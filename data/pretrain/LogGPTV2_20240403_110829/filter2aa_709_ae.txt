given for the 
return state 
from the 
function 
FindWindow/OpenW
indow, 
SetWindowLong/Set
WindowLongPtr 
(2) Target 
address must 
be RX (at least) 
Unmap+ove
rwrite 
Target address 
must be RX (at 
least) 
None 
None (N/A 
– runs 
native 
code) 
Stability: 
code should 
take care to 
retain the 
state of the 
module’s 
static 
variables (it’s 
impossible 
to unmap 
partial 
module 
memory), 
and flush the 
instruction 
cache. This 
needs to be 
done while 
the target 
process is 
suspended. 
This requires 
a memory 
read 
primitive 
(e.g. 
ReadProcess
Memory), 
and process 
suspend+res
ume. 
OpenProcess, 
ntdll!NtUnmapView
OfSection, 
ntdll!NtSuspendProc
ess, 
ntdll!ResumeProcess
, 
FlushInstructionCach
e, 
ReadProcessMemory 
PROPagate 
Switc
h 
virtua
l 
table 
and 
trigge
r 
(1) A window 
belonging to 
the target 
process, that is 
subclassed. 
Specifically, 
one of 
Explorer’s 
System Tray 
sub-windows 
is subclassed; 
(2) Target 
(CFG) 
Target 
addre
ss 
must 
be 
CFG-
valid 
None 
Cleanup: The 
original 
subclass 
structure 
needs to be 
restored. 
FindWindow/OpenW
indow, 
GetProp, SetProp, 
ReadProcessMemoe
y 
address must 
be RX (at least) 
Kernel 
Callback 
Table 
Switc
h 
virtua
l 
table 
and 
trigge
r 
(1) Target 
process must 
own a 
window; (2) 
Target address 
must be RX (at 
least) 
(CFG) 
Target 
addre
ss 
must 
be 
CFG-
valid 
None 
The original 
kernel 
callback 
table must 
be restored. 
FindWIndow/OpenW
indow (or similar), 
OpenProcess, 
ntdll!NtQueryInformatio
nProcess, 
SendMessage 
Ctrl-Inject 
Switc
h 
virtua
l 
table 
and 
trigge
r 
(1) Console 
application; (2) 
Target address 
must be RX (at 
least) 
(CFG) 
Target 
addre
ss 
must 
be 
CFG-
valid 
None 
The original 
Ctrl-C 
handler 
must be 
restored, 
also the key 
pressed 
must be 
released. 
OpenProcess, 
ntdll!RtlEncodeRemo
tePointer, 
SendInput, 
PostMessage 
Service 
Control 
Over
write 
virtua
l 
table 
and 
trigge
r 
(1) Target 
process must 
be a service; 
(2) Target  
address must 
be RX (at least) 
(CFG) 
Target 
addre
ss 
must 
be 
CFG-
valid 
None 
(Probably) 
restore the 
original 
handler 
OpenSCManager, 
OpenService, 
OpenProcess, 
ControlService, 
VirtualQueryEx, 
ReadProcessMemory 
USERDATA 
Switc
h 
virtua
l 
table 
and 
trigge
r 
(1) Console 
application; (2) 
Target address 
must be RX (at 
least) 
(CFG) 
Target 
addre
ss 
must 
be 
CFG-
valid 
None 
The original 
dispatch 
table pointer 
must be 
restored. 
OpenProcess,  
FindWindow/OpenW
indow (or similar) 
GetWindowLongPtr, 
SendMessage 
ALPC 
callback 
Over
write 
virtua
l 
table 
and 
trigge
r 
(1) Target 
process must 
have open 
ALPC port; (2) 
Target  
address must 
be RX (at least) 
(CFG) 
Target 
addre
ss 
must 
be 
CFG-
valid 
None 
Restore the 
original 
callback 
OpenProcess, 
VirtualQueryEx, 
NtDuplicateObject, 
NtConnectPort, 
ReadProcessMemory 
WNF 
callback 
Over
write 
virtua
l 
(1) Target 
process must 
use WNF; (2) 
Target  
(CFG) 
Target 
addre
ss 
R9? 
Restore the 
original 
callback 
OpenProcess, 
ReadProcessMemory, 
NtUpdateWnfStateData 
table 
and 
trigge
r 
address must 
be RX (at least) 
must 
be 
CFG-
valid 
Stack 
Bombing 
(1) Target 
address must 
be RX (at 
least); (2) 
Thread must 
be in alertable 
state 
None 
None 
Cleanup: The 
original 
thread stack 
and registers 
need to be 
restored. 
This is easy 
with the 5 
alertable 
functions. 
OpenThread, 
GetThreadContext, 
SetThreadContext, 
ntdll!NtQueueApcTh
read 
Auxiliary technique 
During our research, we discovered an auxiliary technique that can be helpful for future injection attack 
development. This technique loads a system DLL into the target process, without writing its path to the 
process. 
Sometimes, it may be necessary to forcibly load a system DLL into a process, e.g. when a ROP gadget is 
needed from such DLL. Generally, an execution method with target LoadLibraryA can be used to load a 
DLL, provided the DLL path is in memory. Interestingly, kernelbase.dll contains a list of 1000+ system 
DLLs (as NUL-terminated strings). So arbitrary system DLL loading is possible even without prior write 
primitive. This list can be found in kernelbase!g_DllMap+8, which is a pointer to an array of structures, 
each structure is 3 QWORDs, the first one points to a string which is a DLL name (ASCII, NUL-
terminated). The strings populate a consecutive area in the .rdata section, wherein each string is 8-byte 
aligned. 
PoCs and Library 
All the above PoCs are available at our GIT repository.  Additionally, we provide “full exploitation” PoCs 
which demonstrate execution (MessageBox) for all techniques. Finally, we also provide a unique offering 
in the form of a “mix and match” C++ class library (code name PINJECTRA), so the library’s user can 
construct process injections by combining compatible write primitives with execution methods. This is 
the first such offering. 
Conclusions 
This paper fills a major gap in documentation, analysis, update and comparison of true process injection 
techniques for Windows 10 x64. Additionally, this paper presents a novel technique for writing data to 
memory, and a related technique for execution, both unaffected by all Windows 10 process protection 
methods.  
All techniques are offered as a barebone PoCs and as interchangeable classes in a library which allows 
“mix and match” style process injection coding. 
Acknowledgements 
Kudos to the EnSilo research team, to Odzhan, to Adam of Hexacorn and to Csaba Fitzl AKA TheEvilBit 
for their research and innovation over the recent years.