108
H. Bos and K. Huang
State 0,
      32,
      35, 
      42,
      50:
'Q'  : 36
'h'  : 1
't'  : 43
State 1:
'.'  : 2
'Q'  : 36
'h'  : 1
't'  : 43
'w'  : 33
State 2:
'Q'  : 36
'd'  : 3
'h'  : 1
't'  : 43
State 3:
'Q'  : 36
'h'  : 1
'l'  : 4
't'  : 43
State 4:
'Q'  : 36
'h'  : 1
'l'  : 5
't'  : 43
State 5:
'Q'  : 36
'h'  : 6
't'  : 43
State 6:
'.'  : 2
'Q'  : 36
'e'  : 7
'h'  : 1
't'  : 43
'w'  : 33
State 7:
'Q'  : 36
'h'  : 1
'l'  : 8
't'  : 43
State 8:
'3'  : 9
'Q'  : 36
'h'  : 1
't'  : 43
State 9:
'2'  : 10
'Q'  : 36
'h'  : 1
't'  : 43
State 10:
'Q'  : 36
'h'  : 11
't'  : 43
State 11:
'.'  : 2
'Q'  : 36
'h'  : 1
'k'  : 12
't'  : 43
'w'  : 33
State 12:
'Q'  : 36
'e'  : 13
'h'  : 1
't'  : 43
State 13:
'Q'  : 36
'h'  : 1
'r'  : 14
't'  : 43
State 14:
'Q'  : 36
'h'  : 1
'n'  : 15
't'  : 43
State 15:
'Q'  : 16
'h'  : 1
't'  : 43
State 16:
'Q'  : 36
'h'  : 17
't'  : 43
State 17:
'.'  : 2
'Q'  : 36
'h'  : 1
'o'  : 18
's'  : 38
't'  : 43
'w'  : 33
State 18:
'Q'  : 36
'h'  : 1
't'  : 43
'u'  : 19
State 19:
'Q'  : 36
'h'  : 1
'n'  : 20
't'  : 43
State 20:
'Q'  : 36
'h'  : 1
't'  : 21
State 21:
'Q'  : 36
'h'  : 22
'o'  : 44
't'  : 43
State 22:
'.'  : 2
'Q'  : 36
'h'  : 1
'i'  : 23
't'  : 43
'w'  : 33
State 23:
'Q'  : 36
'c'  : 24
'h'  : 1
't'  : 43
State 24:
'Q'  : 36
'h'  : 1
'k'  : 25
't'  : 43
State 25:
'C'  : 26
'Q'  : 36
'h'  : 1
't'  : 43
State 26:
'Q'  : 36
'h'  : 27
't'  : 43
State 27:
'.'  : 2
'G'  : 28
'Q'  : 36
'h'  : 1
't'  : 43
'w'  : 33
State 28:
'Q'  : 36
'e'  : 29
'h'  : 1
't'  : 43
State 29:
'Q'  : 36
'h'  : 1
't'  : 30
State 30:
'Q'  : 36
'T'  : 31
'h'  : 1
'o'  : 44
't'  : 43
State 31:
'Q'  : 36
'f'  : 32
'h'  : 1
't'  : 43
State 33:
'Q'  : 36
'h'  : 1
's'  : 34
't'  : 43
State 34:
'2'  : 35
'Q'  : 36
'h'  : 1
't'  : 43
State 36:
'Q'  : 36
'h'  : 37
't'  : 43
State 37:
'.'  : 2
'Q'  : 36
'h'  : 1
's'  : 38
't'  : 43
'w'  : 33
State 38:
'Q'  : 36
'h'  : 1
'o'  : 39
't'  : 43
State 39:
'Q'  : 36
'c'  : 40
'h'  : 1
't'  : 43
State 40:
'Q'  : 36
'h'  : 1
'k'  : 41
't'  : 43
State 41:
'Q'  : 36
'f'  : 42
'h'  : 1
't'  : 43
State 43:
'Q'  : 36
'h'  : 1
'o'  : 44
't'  : 43
State 44:
'Q'  : 45
'h'  : 1
't'  : 43
State 45:
'Q'  : 36
'h'  : 46
't'  : 43
State 46:
'.'  : 2
'Q'  : 36
'h'  : 1
's'  : 47
't'  : 43
'w'  : 33
State 47:
'Q'  : 36
'e'  : 48
'h'  : 1
'o'  : 39
't'  : 43
State 48:
'Q'  : 36
'h'  : 1
'n'  : 49
't'  : 43
State 49:
'Q'  : 36
'd'  : 50
'h'  : 1
't'  : 43
Depicted above is the deterministic finite automaton for the following signatures: 
"h.dllhel32hkernQhounthickChGetTf", "hws2", "Qhsockf", "toQhsend", and "Qhsoc"
Matches are found in  the following states (indicated in the table by '    '): 
{32,"h.dllhel32hkernQhounthickChGetTf"}, {35,"hws2"}, {40,"Qhsoc"},
{42,"Qhsockf"}, {50,"toQhsend"}
Fig. 1. Deterministic ﬁnite automaton for Slammer worm
As an aside, we extended the Aho-Corasick algorithm in order to make it
recognise rules that contain multiple strings (e.g., a rule that ﬁres only when the
data contains both strings S1 and S2). Unfortunately, there is no space in the
IXP1200’s instruction store to add this functionality. We recently implemented
it on an IXP2400. In our view, it serves to demonstrate the advantages of a
software-only approach. The port of the original code and its extension was
straightforward. A similar upgrade of an FPGA-based solution would require
substantially more eﬀort.
2.2 Observations
The following observations can be made. First, the algorithm to match the pat-
terns is extremely simple. It consists of a comparison, a state transition and
possibly an action when a pattern is matched. Not much instruction memory
is needed to store such a simple program. Second, the DFA, even for such a
trivial search, is rather large. There are 51 states for 5 small, partly overlapping
patterns, roughly the combined number of characters in the patterns. For longer
scans, the memory footprint of the Aho-Corasick algorithm can grow to be fairly
large. Recent work has shown how to decrease the memory footprint of the algo-
rithm [18]. However, this approach makes the algorithm slower and is therefore
not considered in this paper. Third, as far as speed is concerned, the algorithm
scales well with increasing numbers of patterns and increasing pattern lengths.
Indeed, the performance is hardly inﬂuenced by these two factors, except that
Towards Software-Based Signature Detection for Intrusion Prevention
109
the number of matches may increase with the number of patterns, in which case
the actions corresponding to matches are executed more frequently. Fourth, par-
allelism can be exploited mainly by letting diﬀerent processors handle diﬀerent
packets. There is little beneﬁt in splitting up the set of patterns to search for
and letting diﬀerent processors search for diﬀerent patterns in the same packet.
Fifth, when a traﬃc scan is interrupted, we only need to store the current state
number, to be able to resume at a later stage, i.e., there is no need to store
per-pattern information.
3 Hardware
CardGuard is implemented entirely on a single Intel IXP1200 NPU board (shown
in Figure 2(a)). The IXP1200 used in CardGuard runs at a clockrate of 232 MHz
and is mounted on a Radisys ENP2506 board with 8 MB of SRAM and 256 MB
of SDRAM. The board contains two Gigabit ports 1(cid:3). Packet reception and
packet transmission over these ports is handled by the code on the IXP1200 2(cid:3).
The Radisys board is connected to a Linux PC via a PCI bus 3(cid:3).
The IXP1200 chip itself consists of a StrongARM processor running embedded
Linux and 6 independent RISC processors, known as microengines. Each micro-
engine has a 1K instruction store and 128 general-purpose registers, in addition
to special purpose registers for reading from and writing to SRAM and SDRAM.
On each of the microengines, the registers are partitioned between 4 hardware
contexts or ‘threads’. Threads on a microengine share the 1K instruction store,
but have their own program counters and it is possible to context switch between
threads at zero cycle overhead. On-chip the IXP has a small amount (4KB) of
scratch memory. Approximate access times of scratch, SRAM and SDRAM are
12-14, 16-20 and 30-40 cycles, respectively. Instruction store and registers can be
accessed within a clock cycle. The network processor is connected to the network
interfaces via a fast, proprietary bus (the IX bus). Note that a newer version
of the IXP architecture, the IXP2800, supports no fewer than 16 microengines
(with 8 threads each), has 16KB of scratch memory and operates at 1.4 GHz.
This illustrates that the results in this paper represent what can be achieved
with yesterday’s technology.
(a) The IXP1200 NPU