title:BareDroid: Large-Scale Analysis of Android Apps on Real Devices
author:Simone Mutti and
Yanick Fratantonio and
Antonio Bianchi and
Luca Invernizzi and
Jacopo Corbetta and
Dhilung Kirat and
Christopher Kruegel and
Giovanni Vigna
BareDroid: Large-Scale Analysis
of Android Apps on Real Devices
Simone Mutti 1
PI:EMAIL
Yanick Fratantonio 2
PI:EMAIL
Antonio Bianchi 2
PI:EMAIL
Luca Invernizzi 2
PI:EMAIL
Jacopo Corbetta 2
PI:EMAIL
Dhilung Kirat 3
PI:EMAIL
Christopher Kruegel 2
PI:EMAIL
Giovanni Vigna 2
PI:EMAIL
1 Universitá degli Studi di Bergamo
Bergamo, Italy
2 UC Santa Barbara
Santa Barbara, CA
3 IBM Research T.J. Watson
Yorktown Heights, NY
ABSTRACT
To protect Android users, researchers have been analyzing
unknown, potentially-malicious applications by using sys-
tems based on emulators, such as the Google’s Bouncer and
Andrubis. Emulators are the go-to choice because of their
convenience: they can scale horizontally over multiple hosts,
and can be reverted to a known, clean state in a matter of
seconds. Emulators, however, are fundamentally diﬀerent
from real devices, and previous research has shown how it
is possible to automatically develop heuristics to identify
an emulated environment, ranging from simple (cid:13)ag checks
and unrealistic sensor input, to (cid:12)ngerprinting the hypervi-
sor’s handling of basic blocks of instructions. Aware of this
aspect, malware authors are starting to exploit this funda-
mental weakness to evade current detection systems. Unfor-
tunately, analyzing apps directly on bare metal at scale has
been so far unfeasible, because the time to restore a device
to a clean snapshot is prohibitive: with the same budget, one
can analyze an order of magnitude less apps on a physical
device than on an emulator.
In this paper, we propose BareDroid, a system that
makes bare-metal analysis of Android apps feasible by
quickly restoring real devices to a clean snapshot. We show
how BareDroid is not detected as an emulated analysis en-
vironment by emulator-aware malware or by heuristics from
prior research, allowing BareDroid to observe more poten-
tially malicious activity generated by apps. Moreover, we
provide a cost analysis, which shows that replacing emu-
lators with BareDroid requires a (cid:12)nancial investment of
less than twice the cost of the servers that would be run-
ning the emulators. Finally, we release BareDroid as an
open source project, in the hope it can be useful to other
researchers to strengthen their analysis systems.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ACSAC ’15, December 07-11, 2015, Los Angeles, CA, USA
Copyright 2015 ACM 978-1-4503-3682-6/15/12 ... $15.00
http://dx.doi.org/10.1145/2818000.2818036.
Categories and Subject Descriptors
[Security and privacy]: Software and application security
Keywords
Android, Bare-metal Analysis, Evasive Malware
1.
INTRODUCTION
To analyze potentially-malicious Android apps at scale,
security researchers have developed a variety of virtual-
ized analysis environments, such as Andrubis [34], Google’s
Bouncer [22], Mobile-Sandbox [30], and JoeSandbox [27].
Virtualized environments are the go-to choice because they
are inherently scalable: for example, they can scale horizon-
tally through multi-host parallel execution and, after an app
has been analyzed, the analysis environment can be quickly
reverted to a trusted state in a matter of seconds before
starting the next analysis. This ability of fast restore keeps
the analysis overhead to a minimum.
Unfortunately, malware authors are aware of this trend.
They are exploiting this trend for evasive purposes by cre-
ating malware that collects information about the environ-
ment in which it is being executed, and, if an emulator is
detected, it suppresses its malicious behavior to evade analy-
sis. This evasive behavior is well-known in the security com-
munity [3], and has been observed by researchers in desktop
malware [15, 19] as well as in web malware [13, 17].
Researchers have recently evaluated virtualized Android
analysis environments [16], and they have found more than
10,000 detection heuristics that an app can use to detect
emulated environment. Some issues they have highlighted
can be easily mitigated. For example, researchers have
found that, to bypass Google’s Bouncer, the OBAD [6]
malware contains a series of checks, such as build.MODEL
=="google_sdk":
if these checks trigger, OBAD will not
show any malicious behavior. However, there are classes
of detection heuristics that do not rely on such simple (cid:13)ag
checks; instead, they leverage fundamental diﬀerences be-
tween real devices and emulators that are challenging, if not
impossible, to mitigate. These heuristics include checks on
the GPU performance and power consumption pro(cid:12)le, and
can leverage minute diﬀerences such as how the program-
counter register is updated in QEMU (this method has been
used in [7] to detect Andrubis [34]).
Although Android emulators can be modi(cid:12)ed to mitigate
some of these heuristics and timing attacks, simultaneously
mitigating all these detection techniques is extremely cum-
bersome and challenging. In fact, such modi(cid:12)cations would
require the hypervisor to behave exactly like a real Android
device, and the emulator to realistically simulate a variety
of input signals (e.g., the gyroscopic sensors, accelerome-
ters, magnetometers, mobile/WiFi networks). Moreover, it
is not clear whether it will ever be possible to make the per-
formance discrepancy undetectable. Note also that this is
the attacker’s game: a single imperfection in the mimicking
of a real device would render the emulator detectable, thus
easy to (cid:12)ngerprint and evade.
Despite the signi(cid:12)cant threat posed by emulator-aware
Android malware (as it can evade all current analysis ap-
proaches), no solution to this problem has been proposed.
In the desktop malware world, a robust approach to evasive
malware has been proposed with bare-metal malware analy-
sis [18, 19]: here, Kirat et al.
leverage the IPMI remote-
administration features (to power-cycle the workers) and
iSCSI interface (to attach remote disks to workers) to per-
form the analysis of evasive malware. Unfortunately, it is
not clear how to apply this approach to oﬀ-the-shelf An-
droid devices.
In this paper, we present BareDroid, a system that al-
lows for bare-metal malware analysis on oﬀ-the-shelf An-
droid devices. BareDroid is designed to scale at a price-
point similar to the one oﬀered by emulators. Our evaluation
shows that analyzing malware on BareDroid costs, in the
worst case, at most twice as much as executing the same
volume of suspicious apps inside X86-accelerated emulators.
To achieve this, BareDroid focuses on providing a fast way
to restore the device to the initial state after each execution,
so to minimize overhead.
We also evaluate BareDroid with existing real-world
emulator-aware malicious apps and the known detection
heuristics that have been developed by the Android secu-
rity research community [16]. In all cases, our system is ef-
fective in eliciting suspicious behaviors that are suppressed
when the analysis is performed on an emulator. Note that
BareDroid’s goal is not to provide a novel malware analy-
sis engine; instead, its goal is to provide a platform on top
of which existing and future analysis engines can perform
malware detection without the risk of being evaded by the
mere presence of an emulator-like environment. This is why,
for the bene(cid:12)t of the security community, we release Bare-
Droid as an open source project [21].
The main contributions of this paper are as follows:
(cid:15) We design and implement BareDroid, a scalable
bare-metal malware-analysis platform for Android de-
vices, the (cid:12)rst infrastructure of this kind.
(cid:15) We evaluate BareDroid with emulator-aware mal-
ware and the latest emulator detection heuristics, and
we show how they are ineﬀective when run within our
infrastructure.
(cid:15) We evaluate the feasibility of using BareDroid in
place of emulator for large-scale analysis of Android
apps, and discuss the cost and implementation aspects
of this approach.
(cid:15) We release BareDroid as an open source project.
2. ANDROID EMULATOR DETECTION
In this section we summarize the discrepancies that an
Android app can leverage to check whether it is running in
an emulator or on a real device. These discrepancies can be
divided in three categories: static artifacts, dynamic arti-
facts, and hypervisor artifacts.
Static artifacts provide an immediate way to diﬀerenti-
ate real devices from emulators. These include the (cid:13)ags
in Android SDK Build class, such as Build.HARDWARE ==
"goldfish". Host properties can also be leveraged: exam-
ples include the mobile device’s IMEI [24] (a unique ID for
GSM devices), the SIM card’s IMSI (a unique ID speci(cid:12)c
to the SIM card), the number of cores (emulators typically
have a single core) [16], available peripherals (e.g., no emula-
tor supports USB on-the go), and the network hardware and
its con(cid:12)guration. Static artifacts can typically be removed
by developing more complete emulators, so in principle they
can be mitigated through engineering eﬀort.
In contrast, dynamic artifacts cannot be removed easily
since they are based on the observation that, in an emula-
tor, not all the various interfaces of a real mobile device are
fully functional. For example, an app can check whether
it can receive SMS from the mobile network. Also, sensor
input can be leveraged: current emulators have very lim-
ited support for simulating realistic sensor input (e.g., what
is the current GPS (cid:12)x? What GPS satellites are visible?).
Moreover, mobile devices contain tens of sensors: they typ-
ically have an accelerometer, gyroscope, GPS, barometer,
camera, GSM/WiFi/Bluetooth/RFC radios, internal ther-
mometer(s), proximity sensors, magnetometers, and volt-
meters (for cores and battery). These sensor readings cannot
be trivially replayed, because they can be in(cid:13)uenced by the
app: for example, making the device vibrate has an eﬀect on
the accelerometer, and putting a load on the CPU increases
the internal temperature, the voltage/scaling of the cores,
and the battery drain.
Finally, the hypervisor itself can be (cid:12)ngerprinted. QEMU,
for example, is detectable because of its caching [24] and
scheduling [16] policies. Also, the performance of the GPU
provides a base for side-channel timing attacks [33].
3. BAREDROID
3.1 Goals and Challenges
Our work aims to design and develop a system, Bare-
Droid, that can be used to perform large-scale analysis of
Android apps on real devices. BareDroid should be fast
enough that the hardware cost to achieve a given throughput
(in terms of number of apps that can be analyzed within a
given time slot) is comparable to the cost of doing the same
with emulators.
The (cid:12)rst challenge consists in developing a fast restoring
mechanism, so that the initial state (known to be working
and uncompromised) of a device can be restored with a low
overhead. Note that restoring the state of a device is con-
ceptually straightforward. The immediate approach to this
consists in restoring each and every partition of the device
before each analysis. However, this approach is prohibitively
slow (in our experiments, it takes 141 seconds to perform a
full restore on a Nexus 5). Also, whereas eﬃciently restor-
ing the state of an emulator is simple through the snapshot
restore functionality, it is challenging to achieve the same
speed when restoring real devices.
As our system is meant to scale, another challenge consists
in scheduling the analysis of many apps on multiple devices
and monitoring their hardware status.
In emulators, this
task is trivial: in fact, once the analysis on a single device
is robust, generalizing the analysis to multi-device just re-
quires the development of a software driver component to
keep track of the devices and send them the apps to be an-
alyzed.
However, in our experience, we found that the robustness
of real devices is far from ideal. In particular, hardware com-
ponents (e.g., devices, USB cables, USB hubs) signi(cid:12)cantly
increase the surface for failure. For example, it is not rare
for devices not to boot up properly and for the driver to
be unable to connect and restart the booting process. As
another example, a malfunction of USB hub may not pro-
vide enough power, making the connected devices quickly
exhaust their battery.
3.2 Threat Model
Our system is designed to allow the analysis of malicious
apps. Thus, we assume that an app under analysis might
actively attempt to compromise our infrastructure. In our
threat model, an app can execute arbitrary code on the de-
vice, and it can launch root exploits to perform privilege es-
calation. The only assumption that our system relies upon
is the availability of a kernel-level mechanism to lock a par-
tition (i.e., set its permission as read-only). To achieve this,
we rely on a SELinux policy (refer to Section 4 for the de-
tails): thus, we assume that the SELinux component enforc-
ing this policy cannot be compromised.
We chose this threat model as it provides the best trade-
oﬀ between security and performance:
in our experience,
the behavior of the vast majority of malicious apps is cov-
ered by this threat model. That being said, depending on
the analysis scenario, malware authors might outgrow this
threat model, and compromise the Android kernel. For this
reason, throughout this paper we also discuss the scenario
in which no components can be fully trusted, and we suggest
several strategies (see Section 6.2 for more details).
3.3 Approach Overview
To be fast, BareDroid needs to quickly restore a device
to its initial uncompromised state. On a device, the data
that needs to be restored can be seen as a list of partitions.
The most immediate solution to restoring is to simply over-
write the partitions with their original content. However, we
have found this to be unacceptably slow; for this reason, in
BareDroid we have opted for a signi(cid:12)cantly faster, albeit
more complex, approach.
The various partitions on a device have diﬀerent roles,
and this in(cid:13)uences how common it is for a partition to be
modi(cid:12)ed during the analysis of a given Android app. For ex-
ample, the system partitions, S1; S2; : : : ; Sn, are usually not
modi(cid:12)ed, as they contain the bootloader, the code base for
the recovery mode, and the kernel. On the other hand, the
user partitions, U1; U2; : : : ; Un, are almost always modi(cid:12)ed
during the analysis. In fact, if an app stores even one single
(cid:12)le on the (cid:12)le-system, the user partitions will be modi(cid:12)ed
and, therefore, they will need to be restored. Even if a parti-
tion is usually not modi(cid:12)ed, an app could try to alter it. For
example, a malicious app could (cid:12)rst gain root privileges (by
launching a root exploit) and then modify system partitions:
In this case, BareDroid will restore these partitions.
In general, it is faster to perform a partition integrity
check, than to overwrite its content with its clean version.
For partitions that are only changed occasionally, the amor-