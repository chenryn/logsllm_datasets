title:Securing SSL Certificate Verification through Dynamic Linking
author:Adam Bates and
Joe Pletcher and
Tyler Nichols and
Braden Hollembaek and
Dave Tian and
Kevin R. B. Butler and
Abdulrahman Alkhelaifi
Securing SSL Certiﬁcate Veriﬁcation through Dynamic
Linking
Adam Bates
CISE Dept.
University of Florida
Gainesville, FL
adammbates@uﬂ.edu
Joe Pletcher
CIS Dept.
University of Oregon
Eugene, OR
PI:EMAIL
Braden Hollembaek
iSEC Partners
Seattle, WA
PI:EMAIL
Dave Tian
CISE Dept.
University of Florida
Gainesville, FL
tian@cise.uﬂ.edu
Tyler Nichols
CIS Dept.
University of Oregon
Eugene, OR
PI:EMAIL
Kevin R. B. Butler
CISE Dept.
University of Florida
Gainesville, FL
butler@uﬂ.edu
ABSTRACT
Recent discoveries of widespread vulnerabilities in the SSL-
/TLS protocol stack, particular with regard to the veriﬁca-
tion of server certiﬁcates, has left the security of the In-
ternet’s communications in doubt. Newly proposed SSL
trust enhancements address many of these vulnerabilities,
but are slow to be deployed and do not solve the prob-
lem of securing existing software.
In this work, we pro-
vide new mechanisms that oﬀer immediate solutions to ad-
dressing vulnerabilities in legacy code. We introduce Cert-
Shim, a lightweight retroﬁt to SSL implementations that
protects against SSL vulnerabilities,
including those sur-
veyed by Georgiev et. al.
[19], in a manner that is trans-
parent to the application. We demonstrate CertShim’s ex-
tensibility by adapting it to work with Convergence, DANE,
and Client-Based Key Pinning. CertShim imposes just 20
ms overhead for an SSL veriﬁcation call, and hooks the SSL
dependencies of 94% of Ubuntu’s most popular packages
with no changes necessary to existing applications. This
work signiﬁcantly increases system-wide security of SSL com-
munications in non-browser software, while simultaneously
reducing the barriers to evaluating and adopting the myriad
alternative proposals to the certiﬁcate authority system.
Categories and Subject Descriptors
C.2.0.
eral — Security and protection
[Computer-Communication Networks]: Gen-
Keywords
SSL, TLS, HTTPS, public-key certiﬁcates
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright 2014 ACM ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660338.
1.
INTRODUCTION
Internet applications have relied for years on the SSL/TLS
libraries for secure end-to-end channels, but a growing body
of literature points to systemic lapses in security procedure
that renders our communications insecure. The heart of
these problems lies with the inability for clients to accurately
authenticate the server when presented with its public-key
certiﬁcate. Certiﬁcate validation has been shown to be in-
correct at all layers of the SSL stack, from improper certiﬁ-
cate handling in libraries [7, 29], to confusion and abuse of
SSL APIs [19, 43], to applications that are broken by design
so that they are easier to use [17]. Moreover, high pro-
ﬁle compromises of prominent Certiﬁcate Authorities (CAs)
have eroded the very foundations of the SSL trust model
[12, 18, 32]. Any one of these lapses gives rise to the threat
of a Man-in-the-Middle (MitM) attack, in which an attacker
is able to intercept and read supposedly-secure SSL traﬃc
in transit to or from a target website.
While a variety of forward-thinking solutions have been
proposed in the literature [10], less attention has been paid
to immediate countermeasures, and ways in which we can
ﬁx the vast amount of legacy software that is vulnerable and
inexorably linked to the CA model. Detecting and report-
ing these vulnerabilities is an inadequate solution; studies of
Android SSL usage have found that up to 76% of vulnera-
bilities persist for over a year [43], even once the developers
have been notiﬁed of conﬁrmed vulnerabilities [17]. In the
presence of aloof and unavailable developers, we must pursue
alternate means of securing our Internet communications.
In this paper, we consider a system-wide approach to
securing negligent SSL code in non-browser software that
simultaneously facilitates the immediate use of CA alter-
natives and other SSL trust enhancements. We present
CertShim, a lightweight retroﬁt to existing popular SSL im-
plementations (OpenSSL, GnuTLS, and partial support for
JSSE) that acts as a shim1 into the validation procedure in
dynamically linked applications. CertShim provides appli-
cation and domain speciﬁc handlers that force correct cer-
1A shim is a library that transparently intercepts an API
and changes its parameters or operations.
394tiﬁcate validation on previously insecure applications. We
demonstrate its practicality by incorporating a variety of
veriﬁcation techniques including traditional CA validation,
Convergence [30], DANE [23], and client-side key pinning
[14, 31, 37, 42], some of which were previously only avail-
able as experimental browser plug-ins. CertShim reduces
the barrier to adopting these systems by making them im-
mediate candidates for system-wide deployment.
While recent studies have made recommendations for the
general improvement of the SSL ecosystem, few have intro-
duced system-wide defenses to SSL vulnerabilities in legacy
software. Fahl et al. modify the Android API to restrict
SSL misuse [17], while Conti et al.
introduce MYTHIS,
a benign MitM proxy for Android that is able to defend
against rogue access point attacks [11]. In contrast to these
works, our platform-wide defense does not require a manu-
facturer update, or even administrator privileges, to be put
to use. We also deliver on the promise of pluggable certiﬁ-
cate veriﬁcation that is left to future work by Fahl et al.,
and go a step further by showing that additional security
assurances can be attained by layering multiple veriﬁcation
modules. CertShim works in desktop and server environ-
ments, which are considerably more complex than Android,
as various SSL implementations need be considered. Fur-
thermore, the solutions for Android experience compatibil-
ity issues with some programs; in contrast, we present a
policy engine that provides application- and domain-speciﬁc
certiﬁcate handling.
We make the following contributions:
• Enforce Safe Defaults on SSL: CertShim hooks
calls to SSL APIs in order to enforce hostname valida-
tion and certiﬁcate validation. As this behavior would
otherwise break applications that pin certiﬁcates or
connect to domains that use self-signed certiﬁcates, we
present a policy engine that enforces safe defaults but
provides unique handlers based on the application and
destination domain.
• Enable CA Alternatives: Existing open source ini-
tiatives may be slow to adopt alternative SSL trust
models, may intentionally choose to stay with the sta-
tus quo of certiﬁcate authorities, or may simply have
gone defunct. CertShim provides modular retroﬁts
that allow existing applications to use modern CA al-
ternatives. CertShim provides a means of taking the
consensus of multiple forms of certiﬁcate validation,
which to our knowledge is the ﬁrst of its kind in the
literature, allowing even stronger guarantees through
ensemble validation.
• Performance Analysis of CertShim: We survey
Ubuntu’s 10,000 most popular packages and ﬁnd that
CertShim supports 94% of the 390 packages that were
found to contain SSL usage. Our benchmarks show
that the use of CertShim adds as little as 20 ms to
an SSL lookup under realistic conditions. We also
perform manual testing to determine that CertShim
transparently secures all of the major SSL library mis-
conﬁgurations and 8 of the 9 data-transport library
vulnerabilities identiﬁed by Georgiev et al.[19].
The remainder of this work is organized as follows: Sec-
tion 2 provides background on SSL, CAs, and the prob-
lems associated with certiﬁcate validation. In Section 3 we
present the design and implementation of CertShim, ana-
lyze its features in Section 4, and evaluate its performance
as well as coverage of real world SSL usage in Section 5.
Limitations of our approach and future work are discussed
in Section 6, and related work is summarized in Section 7.
In Section 8 we conclude.
2. BACKGROUND
The SSL/TLS protocol families are largely responsible for
securing the Internet’s web traﬃc. The original SSL (Secure
Socket Layers) protocols were introduced by Netscape in
1995 to provide conﬁdentiality, integrity, and identity to net-
work communications [22]. While the foundations of SSL’s
solutions to conﬁdentiality and integrity have withstood the
test of time, reliably establishing destination identity in SSL
connections has proven to be a surprisingly diﬃcult prob-
lem. Without identity assurances, users are vulnerable to
the threat of impersonation or Man-in-the-Middle (MitM)
attacks, in which an attacker is able to intercept and read
supposedly-secure SSL traﬃc bound to or from a target
website. We still rely on Netscape’s original solution, the
Certiﬁcate Authority (CA) public key infrastructure, which
requires that domains register with one or more CAs in ex-
change for a signed X.509 certiﬁcate. A client can then
authenticate the server validating its certiﬁcate by using the
issuing CA’s public key; obtaining this public key is a trans-
parent process to the client, as it is likely pre-installed into
their operating system or web browser.
Development Vulnerabilities. Good SSL code, par-
ticularly with regards to certiﬁcate veriﬁcation, is very dif-
ﬁcult to correctly implement. Numerous MitM vulnerabili-
ties have been discovered in certiﬁcate chain validation rou-
tines, such as null preﬁx attacks on Pascal strings [28, 29].
Georgiev et al’s survey of SSL connection authentication ex-
posed pervasive misunderstanding of certiﬁcate veriﬁcation
in SSL API’s in non-browser software, and also drew at-
tention to many popular SSL libraries that are broken by
design [19]. Fahl et al.
interviewed developers to ﬁnd that
apps were often intentionally broken so as to allow for eas-
ier development, or to support self-signed certiﬁcates [17].
Even worse, the tomes of vulnerable SSL code that exist
today that are unlikely to ever be patched. Studies of SSL
vulnerabilities in Android apps have found that up to 76% of
vulnerabilities persist for over a year [43], even once the de-
velopers have been notiﬁed of conﬁrmed vulnerabilities [17].
Even more surprisingly, Brubaker et al. perform automated
testing to uncover dramatic inconsistencies in the validation
routines of the major SSL libraries, some of which gave rise
to exploitable vulnerabilities [7]. Given that not even SSL
library development teams can agree on best practices for
certiﬁcate handling, the situation today is certainly grim.
Trust Vulnerabilities. Orthogonal to these implemen-
tation issues are a number of fundamental and systemic limi-
tations in the CA trust model. CAs are under no obligation
to perform due diligence before issuing a certiﬁcate, and
in fact this lack of veriﬁcation is pervasive in the certiﬁ-
cate ecosystem [45]. This, combined with the myriad recent
serious, high-proﬁle compromises and blunders (e.g., Co-
modo[32], Diginotar[18], TURKTRUST[12]), makes it fair
to ask whether CAs are suﬃciently incentivized to preserve
the security of themselves or their customers. These lapses
are at times met without any serious repercussions [9, 30],
and there is even evidence that CAs work directly against
395customer security by oﬀering wiretap services [21, 39, 41,
42]. These problems are serious enough, but they are ex-
acerbated by a lack of scoping; any CA can verify any cer-
tiﬁcate, meaning that conscientious businesses that certify
with reputable CAs are just as at risk, and software ven-
dors often include potentially untrustworthy CAs in order
to ensure compatibility with Internet services [15].
2.1 CA Alternatives
Proposed CA enhancements and alternatives were sur-
veyed by Clark and van Oorschot [10], who identify families
of proposals based on their underlying fundamental princi-
ples of operation. These alternatives vary widely in terms
of both their advantages and limitations, reﬂecting diﬀer-
ences of opinion on the fundamental problems with the CA
trust model. This work makes use of an important subset
of these security enhancements that require no server side
changes in order to be adopted; primitives such as multipath
probing [3, 30, 47], client-based key pinning [14, 31, 37, 42],
and certiﬁcate revocation lists [13, 26, 33, 38] are eligible for
immediate deployment by individual users, providing tangi-
ble security enhancements to today’s Internet threats. Due
to its relative popularity, we also consider the DANE DNS-
based key pinning system, a trust enhancement that embeds
X.509 certiﬁcates in DNSSEC records [23, 27]. However,
none of these trust enhancements has enjoyed widespread
deployment, in part due to the vast amount of non-browser
software that would need to be modiﬁed in order to enable
their system-wide use.
Key pinning, Convergence, and DANE are exemplar trust
enhancements that we make use of in this work. However,
each suﬀers from inherent design or trust limitations that
impact their applicability in certain scenarios. For exam-
ple, client-based key pinning cannot determine whether a
change in a server’s certiﬁcate is malicious or benign. Re-
cent work by Amann et al. [2, 4] shows that routine changes
to SSL trust relationships are often indistinguishable from
attacks, making this a noteworthy limitation. In contrast,
Convergence can oﬀer insight into the cause of the unex-
pected certiﬁcate by detecting whether the certiﬁcate has
changed globally, or just locally. However, if the new certiﬁ-
cate is the result of a MitM attack near the server, the Con-
vergence notaries will conclude that the change is benign,
resulting in a dangerous false negative. DANE, by checking
the target domain’s TLSA record, could oﬀer a deﬁnitive
answer to whether the change was benign, but DANE is
being incrementally deployed and further bloats the tradi-
tional CA trust model to include the DNS architecture. In
this work, we show that by querying multiple certiﬁcate val-
idation systems it is possible to retain the beneﬁts of each
while mitigating each system’s limitations.
3. DESIGN
3.1 Threat Model & Assumptions
Our system is designed with consideration for an adver-
sary in the network that attempts to launch a MitM attack
against SSL communications; this attack could be launched
from a rogue wireless access point to which the client is con-
necting, or from elsewhere on the Internet, such as some-
where on the network paths between the client and server.