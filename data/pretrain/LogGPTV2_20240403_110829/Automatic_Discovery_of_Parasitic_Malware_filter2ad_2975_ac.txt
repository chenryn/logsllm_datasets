### 108
A. Srivastava and J. Giﬃn

The system identifies the malicious process or driver and adds it to the list of malicious code. It then identifies other benign processes that have been infected by the malware by searching through the host attribution sensor's records. The correlation engine periodically purges records generated by both the network and host attribution sensors.

## 5 Low-Level Implementation Details

Pyrenée is an operational prototype implemented for Windows XP SP2 victim systems hosted in virtual machines (VMs) using Xen hypervisor version 3.2. The high-privilege VM, which runs our software, uses Fedora Core 9. Implementing Pyrenée for Windows victim systems required addressing several challenging, low-level technical issues.

### 5.1 Fast Network Flow Discovery

The network attribution sensor intercepts all inbound and outbound network flows of untrusted VMs. To achieve high-speed packet interception, we deployed the sensor’s packet filter within the trusted VM’s kernel space, developing it as a Linux kernel module. To capture packets before they leave the network, we configured the untrusted VMs to use a virtual network interface bridged to the trusted VM. We inserted a hook into the ebtables [4] framework to view packets crossing the bridge. When the sensor’s kernel component receives a TCP SYN packet, it notifies the user-space component to perform introspection.

### 5.2 Introspection

The network attribution sensor identifies local processes that are endpoints of network flows via virtual machine introspection. This requires the sensor’s user-space component to inspect the runtime state of the victim system’s kernel. In Windows, network port and process name information are not stored in a single structure. The network driver (tcpip.sys) manages network connection-related information. To locate the TCBTable structure, the sensor iterates over the kernel’s list of loaded drivers. The TCBTable points to a linked list of objects containing network ports and process IDs for open connections. The sensor converts the process ID to a process name by iterating over the guest kernel’s linked list of running processes. Figure 3 illustrates the complete process of resolving a network connection to a host-level process name.

The correlation engine uses VMI across handle tables to identify the names of processes receiving DLL or thread injection from potentially malicious software. The engine knows handle identifiers because the host attribution sensor observes IN parameters to the Windows system calls used during injection. These parameters include handles. All handles used by a process are maintained in handle tables, structured as shown in Figure 4. To resolve a handle to a process name, the engine uses the handle to find the corresponding EPROCESS data structure in the Windows kernel memory. This inspection also reveals files and registries currently open to the possibly malicious injecting process.

### 5.3 System Call Interpositioning and Parameter Extraction

Pyrenée’s host attribution sensor requires information about system calls used for DLL or thread injection. We developed a system call interpositioning framework for Xen, supporting the inspection of both IN and OUT system call parameters. Windows XP uses the fast x86 system-call instruction SYSENTER, but Intel VTx hardware does not allow SYSENTER to cause a VM exit. Therefore, our sensor forcibly gains execution control at the beginning of a system call by altering the IA32 SYSENTER EIP register to an invalid address. This causes execution to fault to the hypervisor, where the sensor records the system call number and extracts IN parameters. For OUT parameters, a two-step procedure is used: recording the initial value and modifying the return address to an invalid location, causing a fault on system call completion.

### 5.4 Address Space Construction and Switching

We create isolated address spaces for untrusted drivers using the Xen hypervisor and Windows XP 32-bit guest OS. Memory for UPT page tables is allocated transparently to the guest OS inside the hypervisor. Untrusted driver code pages are mapped into the UPT, while trusted kernel and driver code are mapped into the TPT. Untrusted driver code pages in the TPT are marked non-executable and non-writable, and trusted code pages in the UPT are marked non-executable, non-writable, and non-readable. Pyrenée switches between the two address spaces by manipulating the CR3 register, verifying the legitimacy of control flow transitions and raising alarms for invalid entry points.

### 5.5 Interception of Driver Loading

Pyrenée needs to know the load addresses of drivers to map their code pages into the UPT or TPT. Since Windows dynamically allocates memory for drivers, these addresses change. Pyrenée intercepts all driver loading mechanisms by rewriting the kernel’s binary code on driver loading paths at runtime. It modifies the direct call instruction to the ObInsertObject kernel function, causing execution to fault into the hypervisor. On the fault, Pyrenée securely extracts the driver’s load address and resumes execution, providing complete interpositioning of driver loading.

## 6 Evaluation

We tested our prototype implementation of Pyrenée to evaluate its ability to identify malicious software, its performance, and its avoidance of false positives. We used a network simulator acting as a network-based IDS to generate alerts for suspicious network activity.

### 6.1 User-Level Malware Identification

We tested Pyrenée’s ability to detect process-to-process parasitic behaviors with the Conficker worm [38]. Conficker uses DLL injection to infect benign processes. We executed Conficker in a test VM monitored by Pyrenée and connected to a network overseen by our NIDS simulator. The host attribution sensor recorded DLL injection behavior from rundll32.exe targeting specific svchost processes. When our NIDS simulator sent IP addresses and port numbers for outbound malicious traffic, the correlation engine identified the responsible malicious code and generated a complete listing of infected executables. We repeated these tests with the Adclicker.BA trojan and successfully detected its parasitic behavior.

### 6.2 Kernel-Level Malware Identification

We evaluated Pyrenée’s ability to detect kernel-level parasitism by testing it with the Storm worm [23]. Storm injects malicious DLLs into the services.exe process, causing DDoS attacks. We loaded Storm’s malicious driver in the test VM, and Pyrenée loaded it into the isolated address space. The host attribution sensor verified and logged all kernel APIs invoked by the driver, identifying the injection via APCs and the victim process. When our network simulator flagged the traffic made by services.exe, the correlation engine gathered data from the host and network attribution sensors, identifying the parasitism of the malicious driver.

### 6.3 Performance

Pyrenée is designed to operate at runtime with minimal performance impact on the end user’s system. We tested our prototype on an Intel Core 2 Quad 2.66 GHz system, assigning 1 GB of memory to the untrusted Windows XP SP2 VM and 3 GB combined to the Xen hypervisor and the high-privilege Fedora Core 9 VM. We used PassMark Performance Test [24] for CPU and memory experiments and IBM Page Detailer [13] and wget for networking overheads. We measured Pyrenée’s overhead during benign operations, active parasitic attacks, and the isolation of a heavily-used driver in the UPT. All measurements were taken five times, and median values are presented.

First, we measured Pyrenée’s overhead on CPU-bound and memory-intensive operations. Tables 3 and 4 list benchmark measurements for unmonitored execution and for Pyrenée’s monitoring with and without parasitic behaviors present, indicating performance loss percentages.

| **Parasitic Behavior** | **Operations** | **Unmonitored** | **Present %** | **Absent %** |
|-----------------------|----------------|-----------------|---------------|--------------|
| Integer Math (MOps/sec) | 124.8 | 92.5 | 26.88 | 6.17 |
| Floating Point Math (MOps/sec) | 439.5 | 352.0 | 20.00 | 8.00 |
| Compression (KB/sec) | 600.0 | 480.0 | 20.00 | 8.00 |
| Encryption (MB/sec) | 100.0 | 80.0 | 20.00 | 8.00 |
| String Sorting (Thousand strings/sec) | 100.0 | 80.0 | 20.00 | 8.00 |

This table shows the performance impact of Pyrenée under different conditions, demonstrating that it can operate with acceptable overhead even during active parasitic attacks.