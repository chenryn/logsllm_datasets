We present a security proof within the generalized universal composability (GUC) frame-
work. This way, we prove that our OptiSwap protocol Î  GUC-realizes the ideal function-
ality FL
,L,H)-hybrid world. A brief introduction into the (generalized)
universal composability framework is given in Appendix A. The protocol Î  is based on the
assumptions of an IND-CPA-secure symmetric encryption scheme and a hash function that
is modeled as a global programmable random oracle H. The security model is presented in
Appendix B and a formal description of the protocol parties as well as the judge functionality
is given in Appendix C.
jc
Assumptions and Simplications. We assume static corruption, which means that the
protocol parties may be corrupted by the adversary only at the beginning of the execution.
In the following, the four dierent cases of corruption are considered in isolation. For each
scenario, a formal description of a simulator and a detailed argumentation why the sim-
ulator can be used to achieve indistinguishability is given. In addition, the setup of each
scenario is depicted to support the understanding of connections between the parties within
an execution.
32
Algorithm 5 GenerateProof(k, Ï†, R)
Require: (k, Ï†, R), where k is the decryption key, Ï† is the verication circuit, and R is the set of
all responses received so far
else
s = f ailed
break
outIi[j] = Dec(k, eIi[j])
if (Ii[j], eIi[j], Ï€Ii[j]) (cid:54)âˆˆ R then
Ensure: Ï€, where Ï€ is either a proof of misbehavior or false
1: for (i, ei, Ï€i) âˆˆ R do
set s = searching
2:
outi = Dec(k, ei)
3:
parse Ï†i = (i, opi, Ii)
4:
for j = 1 to l do
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21: end for
22: return false
Ï€Ï† = MTProof(MTHash(Ï†), i)
Ï€ = (Ï€Ï†, Ï€i, Ï€Ii[1], . . . , Ï€Ii[l])
return Ï€
end for
if s (cid:54)= f ailed then
out(cid:48)
if outi (cid:54)= out(cid:48)
i = opi(outIi[1], . . . , outIi[l])
i then
end if
end if
end if
The protocol parties of the hybrid world execution are denoted by S and B, while the
dummy parties of the ideal world are denoted by ËœS and ËœB. Malicious parties are delineated
by âˆ—, e.g., a corrupted Seller in the hybrid world is denoted by Sâˆ— and in the ideal world it
is denoted by ËœSâˆ—.
In the following simulations, the ideal adversary internally runs the judge smart contract
GL,H
on input m and obtaining the output m(cid:48) by the simulator is denoted
by m(cid:48) â† GL,H
(m). This implies that the messages m and m(cid:48) are sent to the environment Z
and to the parties according to the behavior of GL,H
is only run internally
by the simulator, no coins are frozen or unfrozen by L.
. Note, since GL,H
. Running GL,H
jc
jc
jc
jc
jc
The environment has the power to delay message sent to FL
via the adversary.
To simplify the simulation, it is assumed that whenever a message is delayed by time Î´, the
ideal adversary uses the inuence port of the ideal functionality FL
icfe in order to delay the
execution in the ideal world by the exact same amount of time Î´. This ensures that the
environment cannot distinguish the execution of the hybrid world and the execution of the
ideal world based on the delay within an execution. In the following simulations, the eect
of delayed messages is not further considered based on this argumentation.
icfe and GL,H
jc
on
are
some
based
proofs
In order to show indistinguishability between the real world execution and the ideal world
games Game0, . . . ,
execution,
Gamen. This common proof technique allows to show indistinguishability between Game0
and Gamen by showing indistinguishability between Gamei and Gamei+1 for each i âˆˆ [nâˆ’1].
Since the goal is to show indistinguishability between the real world execution and the ideal
world execution, Game0 is set to be the real world execution and Gamen is the simulation
in the ideal world. Each intermediate game is a hybrid simulation which simplies the full
UC simulation. Such a hybrid simulation can include a simulator that controls inputs and
outputs of honest parties.
sequence
of
a
33
Algorithm 6 Judge(k, rz, re, rÏ†, Ï€)
Require: (k, rz, re, rÏ†, Ï€), where k is a decryption key, rz, re, rÏ† are Merkle tree roots for the
encrypted witness, the encrypted intermediate computation values, and the circuit, respectively,
and Ï€ is the proof of misbehavior generated by the GenerateProof-algorithm (cf. Algorithm 5)
return 0
return 0
1 , . . . , lÏ†
log2(n))
1, . . . , lo
log2(n))
Ensure: 1 if proof of misbehavior is valid, otherwise 0
1: parse Ï€ = (Ï€Ï†, Ï€out, Ï€Ii[1], . . . , Ï€Ii[l])
2: parse Ï€Ï† = (Ï†i, lÏ†
3: parse Ï†i = (i, opi, Ii)
4: parse Ï€out = (ei, lo
5: outi = Dec(k, ei)
6: if MTVerify(Ï€Ï†, i, rÏ†) = 0 then
7:
8: end if
9: if MTVerify(Ï€out, i, re) = 0 then
10:
11: end if
12: if i = m and outi (cid:54)= 1 then
return 1
13:
14: end if
15: for j âˆˆ [l] do
16:
17:
18:
19:
20:
21: end for
22: out(cid:48)
23: if out(cid:48)
24:
25: end if
26: return 1
end if
parse Ï€Ii[j] = (eIi[j], lIi[j]
1
outIi[i] = Dec(k, eIi[j])
if MTVerify(Ï€Ii[j], Ii[j], re) = 0 then
i = opi(outIi[1], . . . , outIi[l])
i = outi then
, . . . , lIi[j]
log2(n))
return 0
return 0
Since there exist dierent types of indistinguishability, we like to note that whenever
indistinguishability is mentioned in the following security proof, the computational variant
is considered.
Simulation with Two Honest Parties
In the honest execution case, the environment Z provides input values to honest Seller S
and honest Buyer B. After and during the execution of the protocol Î , both honest parties
forward their output values back to the environment. The adversary A provides additional
leakage information to Z and can inuence the execution of the hybrid functionalities GL,H
and H as specied by their interfaces. Since it is sucient to consider a dummy adversary, A
simply forwards all messages received from Z to the specied recipient and leaks all messages
obtained from the hybrid functionalities.
In the ideal world, the simulator needs to provide the same information to the environ-
ment as the adversary A in the hybrid world execution. Therefore, Sim needs to create
a transcript of the whole protocol execution and to send the created messages to Z. This
includes the message sent from Seller to Buyer in the rst round of the protocol as well as
all transactions sent to the judge smart contract GL,H
It is assumed that there exists a secure channel between S and B. This way, the envi-
ronment Z learns that a message was sent, but the content of the message remains secret.
This assumption is important to enable the simulation of the honest case. Suppose there
exists no secure channel, the simulator has to simulate an encrypted witness zâˆ— without the
and all interactions with H.
jc
jc
34
knowledge of the correct witness x. Moreover, the decryption of zâˆ— using a key k has to
equal x.
On the one hand, in the scenario of a corrupted Buyer the programming feature of the
global random oracle H is exploited to ensure the correct decryption. But, since the simulator
never gets to know x during the case of two honest parties, there is no way to exploit the
programming feature to ensure the correct decryption. On the other hand, in the scenario of
a corrupted Seller, the observability feature of H is used to learn the encryption key at the
beginning of the protocol execution. The knowledge of the key and the encrypted witness
z, provided by the corrupted Seller, is sucient for the simulator to reconstruct the correct
witness x and to achieve a correct simulation. The knowledge of the encryption key would
also help in the honest scenario, but the observability feature can only be used to obtain all
queries executed from outside of the protocol session. In particular, honest parties always
belong to the protocol session and hence queries from these parties cannot be obtained.
Therefore, a secure channel must be assumed.
Claim. There exists an ecient algorithm Sim such that for all ppt environments Z that do
not corrupt any party it holds that the execution of Î  in the (GL,H
,L,H)-hybrid world in
presence of adversary A is computationally indistinguishable from the ideal world execution
of FL
Proof. We dene a simulator Sim, which internally runs GL,H
programmable oracle H.
icfe with the ideal adversary Sim.
and has access to the restricted
jc
jc
jc
z , râˆ—
z , râˆ—
z , râˆ—
1. If ËœS starts the execution with FL
(initialize, id, câˆ—, râˆ—
2. If ËœS aborts the execution in the second round, FL
icfe in the rst round, simulator Sim learns
icfe. Sim samples a key kâˆ— â† Gen(1Îº) and sets xâˆ— = 1nÃ—Î». He
e , rÏ†) â† Presetup(Ï†, xâˆ—, kâˆ—). Sim
e , rÏ†, aÏ†, p, fS , fB) â†
e , rÏ†, aÏ†, p, fS , fB). In addition, he provides the infor-
icfe leaks (abort, id, ËœS) to Sim.
(abort, id) and terminates the sim-
id, Ï†, p, fS , fB from FL
computes (câˆ—, dâˆ—) â† Commit(kâˆ—) and (zâˆ—, râˆ—
simulates the execution of Î  by running (active, id, câˆ—, râˆ—
GL,H
mation to Z that ËœS sent a message to ËœB over the secure channel.
The simulator then runs (aborted, id) â† GL,H
ulation.
If Sim receives (buy, id, ËœB) from FL
ceptance of ËœB by running (initialized, id) â† GL,H
3. If ËœB aborts the execution in the third round, FL
icfe in the second round, he simulates the ac-
(accept, id).
icfe leaks (abort, id, ËœB) to Sim.
(abort, id) and
Then Sim simulates the abort by executing (aborted, id) â† GL,H
terminating the simulation.
If no message is leaked by FL
of the encryption key by running (revealed, id, kâˆ—, dâˆ—) â† GL,H
running (sold, id) â† GL,H
icfe in the third round, Sim simulates the revealing
(reveal, id, kâˆ—, dâˆ—).
4. In round four, the simulator simulates the nalization of the fair exchange by
jc
jc
jc
jc
(f inalize, id).
jc
In the following, it is shown that the transcript produced by the Sim is indistinguishable
from the transcript produced by the execution of Î  in the hybrid world.
When receiving an incorrect witness xâˆ— from the environment such that Ï†(xâˆ—) (cid:54)= 1, honest
Seller does not start the protocol execution in the hybrid world. The same behavior is dened
by FL
icfe in the ideal world, since the ideal functionality assumes a correct witness from an
honest Seller. Hence, only an execution with a correct witness x such that Ï†(x) = 1 is
considered. This is a dierence to the protocol presented in [14] in which an honest Seller
may also send an incorrect witness.
35
jc
jc
jc
jc
jc
z , râˆ—
in the hybrid world and GL,H
In round 1, the environment learns the information that Seller sent a message to the
Buyer. Since the message is sent over a secure channel, Z cannot extract any further infor-
mation. The same information is given by Sim in round one. Moreover, the environment
obtains the initialize- and active-message when the honest Seller interacts with GL,H
. The
simulator internally runs GL,H
to obtain the same messages. The values rÏ†, aÏ†, p, fS , fB are
identical in both executions, since they directly depend on the input values provided by Z.