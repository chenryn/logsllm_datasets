quite practical to strengthen existing authorities by retroﬁtting
them to add witness cosigning support.
VII. DISCUSSION AND FUTURE WORK
This paper’s primary technical focus has been on the basic
CoSi protocol for collective witnessing and signing; we make
no pretense to have addressed all the important issues rele-
vant to applying CoSi in any particular cothority application
context. However, we brieﬂy revisit some of the motivating
applications introduced in Section II in light of the above
implementation and evaluation results.
a) Logging and Timestamping Authorities: While the
current CoSi prototype is basic, it nevertheless already imple-
ments the essential functionality of classic tamper-evident log-
ging and timestamping authorities [2], [63], [121]. As neither
the leader nor any signer can produce a collective signature
without the participation of a quorum of the potentially large
collective, such a timestamp cothority can offer much stronger
protection against the equivocation, history-rewriting, or log-
entry back-dating attacks that a centralized timestamp service
can mount if compromised. When integrated into a direc-
tory [89] or software update service [116], this timestamping
architecture can offer strong proofs of freshness, by enabling
clients to submit random challenges and verify that
their
challenges are included in the service’s next signed update.
b) Certiﬁcate Authorities: Adding proactive transparency
and protecting clients against stolen CA-related keys (in-
cluding CT log server keys) may be the most compelling
and immediately urgent use-case for CoSi. While adding
witness cosigning to CT’s log server as we explored above
represents one fairly simple and potentially worthwhile step,
more substantial modiﬁcations to the current CA system may
be needed to address other major issues such as certiﬁcate
freshness and revocation [82].
540540
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:12:54 UTC from IEEE Xplore.  Restrictions apply. 
We envision that in a witness cothority architecture in which
not just one CA but many of them inspect and collectively sign
certiﬁcates, stolen CA keys such as those of DigiNotar [8],
[22] and Comodo [21] would not by themselves be usable to
sign certiﬁcates that a web browser would accept. Not just CAs
but browser vendors and security companies could incorporate
monitoring servers into the certiﬁcate cothority as signers, to
watch for and perhaps proactively impose a temporary “veto”
on the signing of unauthorized certiﬁcates, such as certiﬁcates
proposed by a CA that is not recorded as having contractual
authority over a given domain. Giving other CAs serving as
witnesses even temporary veto power over a CA’s certiﬁcate
issuance processes creates DoS concerns, but such concerns
might be alleviated provided administrative communication
channels between CAs and witnesses are effective.
Deploying a more general certiﬁcate cothority would of
course require addressing many additional issues beyond the
basic collective signing mechanism covered here, not
just
technical but also organizational and political. One important
technical challenge is backward compatibility and incremental
deployment. We anticipate that current root CAs might grad-
ually transition their root signing keys into witness cothority
keys, with their current sets of delegated CAs (and any other
cooperating root CAs) serving as witnesses. Each root CA
could transition independently at
its own pace, driven by
pressure from users and browser vendors to increase security.
Web browsers would need to be upgraded gradually to support
aggregation-compatible signature schemes such as Schnorr in
addition to the currently common RSA, DSA, and ECDSA
schemes. During their transition period root CAs could retain
traditional root CA certiﬁcates for use in older web browsers
while embedding root cothority certiﬁcates instead into suit-
ably upgraded browsers. However, we leave to future work a
detailed exploration and analysis of the “right” way to integrate
witness cosigning into the CA system.
c) Public Randomness Authorities: While not our present
focus, the current CoSi prototype also effectively implements
a simple collective public randomness service that could
improve the trustworthiness of public randomness authori-
ties [103], [110]. Notice that in phase 2 of the signing protocol
(Section III-E) each server i commits to a fresh random secret
i vi that no
vi, contributing to a collective random secret
participant will know unless all signers are compromised or
the discrete-log hardness assumption fails. The ﬁnal response
produced in phase 4 depends unpredictably and 1-to-1 on this
random secret and the collective challenge c. Thus, we can use
the ﬁnal aggregate response ˆr0 as a per-round public random
value that was collectively committed in phase 2 but will be
unpredictable and uncontrollable by any participant unless all
signers are colluding.
(cid:3)
While these random outputs will be unpredictable and un-
controllable, our current prototype cannot guarantee that they
are fully unbiased, due to its reliance on the signing exception
mechanism for availability. In particular, if a malicious leader
colludes with f other signers, then the leader can control
whether these colluders appear online or ofﬂine to produce up
to 2f different possible ﬁnal aggregate responses with different
exception-sets, and choose the one whose response is “most
advantageous” to the leader, just before completing phase 4
of the protocol. Alternative approaches to handling witness
failures, through the judicious use of veriﬁable secret sharing
(VSS) techniques for example [55], [125], might be able to
address this bias issue, by ensuring that every node’s secret
is unconditionally incorporated in the ﬁnal response, unless a
catastrophic failure makes some server’s secret unrecoverable
even via secret-sharing.
With these changes, a future version of CoSi might be
able to offer bias-resistant randomness in a conventional
but scalable threshold-security model, contrasting with more
exotic approaches recently proposed using new cryptographic
primitives and hardness assumptions [79] or the Bitcoin
blockchain [20] for example. We again leave exploration of
this opportunity to future work.
d) Other Types of Authorities:
Integrating witness
cosigning into blockchain systems such as Bitcoin [102]
present interesting opportunities to improve blockchain se-
curity and performance [70]. The tree-based scaling tech-
niques explored here may also be applicable to decentral-
izing other cryptographic primitives such as public-key en-
cryption/decryption. A large-scale cothority might collectively
decrypt ElGamal [51] ciphertexts at particular future dates
or on other checkable conditions,
time-lock
vaults [100], [112], key escrows [43], or fair-exchange pro-
tocols [58].
to implement
VIII. RELATED WORK
The theoretical foundations for CoSi and witness cothorities
already exist in the form of threshold signatures [17], [120],
aggregate signatures [18], [84], [85], and multisignatures [12],
[93]. Threshold signatures allow some subset of authorized
signers to produce a signature, however, often making it
impossible for the veriﬁer to ﬁnd out which signers were
actually involved. In aggregate signatures, a generalization of
multisignatures, signers produce a short signature by com-
bining their signatures on individual statements through an
often serial process. On the other hand, multisignatures closely
ﬁt the requirements of CoSi for security, efﬁciency and the
simplicity of generation across many signers. However, to our
knowledge these primitives have been deployed only in small
groups (e.g., ≈ 10 nodes) in practice, and we are aware of no
prior work experimentally evaluating the practical scalability
of threshold crypto or multisignature schemes.
Merkle signatures [23], [90], [92] employ Merkle trees for a
different purpose, enabling a single signer to produce multiple
one-time signatures veriﬁable under the same public key.
Online timestamping services [2], [63] and notaries [121]
enable clients to prove the existence of some data (e.g., con-
tracts, research results, copyrightable work) before a certain
point in time by including it in a timestamped log entry.
Typically, a trusted third party acts as a timestamping author-
ity [46], [59], [115] and has a unilateral power to include,
exclude or change the log of timestamped data.
541541
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:12:54 UTC from IEEE Xplore.  Restrictions apply. 
Many distributed systems rely on tamper-evident
log-
ging [38], [81]. Logging services are vulnerable to equiv-
ocation, however, where a malicious server rewrites history
or presents different “views of history” to different clients.
Solutions include weakening consistency guarantees as in
SUNDR [81], adding trusted hardware as in TrInc [80] or
relying on a trusted party [117]. Certiﬁcate Transparency or
CT [76], [78] and NIST’s Randomness Beacon [103] are ex-
amples of application-speciﬁc logging services that exemplify
issues related to a trusted-party design paradigm.
Directory services such as Namecoin [132], and Key-
base [37] use blockchains such as Bitcoin [102] as a decentral-
ized timestamping authority [69]. With this approach, history
rewriting or equivocation attacks become difﬁcult once a
transaction is deeply embedded in the blockchain – but clients
unfortunately have no efﬁcient decentralized way to verify that
a timestamp transaction is in the blockchain, other than by
downloading and tracking the blockchain themselves or by
trusting the say-so of centralized “full nodes.” Blockchains
with collectively signed transactions [70] might address this
veriﬁcation weakness in the blockchain approach.
There are many proposals to address PKI weaknesses [36].
Browsers such as Chrome and Firefox hard-code or pin public
keys for particular sites such as google.com [52], [72] or
particular CAs for each site – but browsers cannot ship with
hard-coded certiﬁcates or CAs for each domain for the whole
Web. Alternatively, browsers pin the ﬁrst certiﬁcate a client
sees [122] protecting a site’s regular users but not new users.
TACK [88], another approach to pinning, offers site owners
the ability to authorize TLS keys for their domain using a
long-term TACK key they control. Since the client’s browser
must witness a pin on two different occasions, TACK protects
users from opportunistic attackers but it does not prevent an
attacker with a long-term access to the victim’s network from
tricking him to accept incorrect pins.
More recent mitigations for CA weaknesses rely on log-
ging and monitoring certiﬁcates as proposed in systems like
AKI [68], ARPKI [10], PoliCert [126], and CT [76], [78]. Now
deployed in the Chrome browser, CT requires CAs to insert
newly-signed certiﬁcates into public logs, which independent
auditors and monitors check for consistency and invalid certiﬁ-
cates. Even with CT, an attacker can unfortunately still create
a fake EV certiﬁcate that the Chrome browser will accept
by stealing the secret keys of, or secretly coercing signatures
from, only three servers: any single CA and any two CT log
servers [77]. If the attacker also blocks the targeted device
from gossiping with public CT servers after accepting this fake
certiﬁcate, the attacker can hide this attack indeﬁnitely [57].
CT’s reliance on clients being able to gossip with monitors
and auditors also raises latency and privacy concerns.
COCA [136] distributes the operation of a CA across
multiple servers, and Secure Distributed DNS [27] similarly
distributes a DNSSEC [6] name service. These systems repre-
sent precedents for CoSi’s collective witnessing approach, but
distribute trust across only a small group: at most four servers
in COCA’s experiments and seven in Secure Distributed DNS.
Some of these trust-splitting protocols have used threshold
signatures as a primitive [25], [26], [109], as CoSi does.
The NIST Randomness Beacon [103] logs random values it
produces by signing them using its own secret key and chain-
ing them with previously produced values. While a dishonest
beacon cannot selectively change individual entries, it could
rewrite history from a chosen point and present different views
of the history to different clients. Additionally, there is no
guarantee of freshness of the published randomness. While
the quality of the output is likely not affected if the beacon
precomputes the randomness, the beacon gets to see these
values beforehand, leaving it vulnerable to insider attacks.
TUF [116] and Diplomat [73] address software download
and update vulnerabilities [13], [31], [105], in a framework
that supports threshold signing by creating and checking mul-
tiple independent signatures. Application Transparency [53]
adapts CT to software downloads and updates. CoSi com-
plements both TUF and Application Transparency by greatly
increasing the number of independent servers an attacker must
compromise in order to keep the compromise secret.
IX. CONCLUSION
This paper has demonstrated how using theoretically estab-
lished and well-understood cryptographic techniques, we can
add efﬁcient, scalable witness cosigning to new or existing
authority services. Witness cosigning offers proactive rather
than merely retroactive transparency, by ensuring that an
attacker who compromises the authority’s secret keys cannot
individually sign a statement clients will accept without also
submitting that statement to many witnesses for cosigning,
creating a high probability of immediate detection. By making
authority keys relatively useless “in secret,” witness cosigning
also reduces the value of an authority’s keys to attackers
wishing to operate in secret, disincentivizing attacks against
the authority’s keys in the ﬁrst place. The encouraging scala-
bility and performance results we have observed with our CoSi
prototype lead us to believe that large-scale witness cothorities
are practical. If this is the case, we feel that there may be
little remaining technical reason to settle for the centralized,
weakest-link security offered by current designs for today’s
common types of critical authorities. We can and should
demand stronger, more decentralized security and transparency
from the Internet’s critical authorities.
Acknowledgments
We wish to thank Tony Arcieri, Dan Boneh, Joe Bonneau,
Christian Cachin, Justin Cappos, Rachid Guerraoui, Jean-
Pierre Hubaux, Ben Laurie, Eran Messeri, Linus Nordberg,
Rene Peralta, Apostol Vassilev, and the anonymous reviewers
for valuable feedback and discussion during this project. We
also wish to thank Stephen Schwab and the entire DeterLab
team for their tireless support for our experiments.
REFERENCES
[1] S. Ackerman. FBI chief wants ‘backdoor access’ to encrypted com-
munications to ﬁght Isis. The Guardian, July 2015.
542542
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:12:54 UTC from IEEE Xplore.  Restrictions apply. 
[31] J. Cappos, J. Samuel, S. Baker, and J. H. Hartman. A Look In the
Mirror: Attacks on Package Managers. In 15th ACM Conference on
Computer and Communications Security (CCS), Oct. 2008.
[32] M. Castro, P. Druschel, A.-M. Kermarrec, A. Nandi, A. Rowstron,
and A. Singh. SplitStream: high-bandwidth multicast in cooperative
environments. In ACM Symposium on Operating Systems Principles
(SOSP), 2003.
[33] M. Castro and B. Liskov. Practical Byzantine fault tolerance. In 3rd
USENIX Symposium on Operating Systems Design and Implementation
(OSDI), Feb. 1999.
[34] S. Checkoway, M. Fredrikson, R. Niederhagen, A. Everspaugh,
M. Green, T. Lange, T. Ristenpart, D. J. Bernstein, J. Maskiewicz,
and H. Shacham. On the practical exploitability of Dual EC in TLS
implementations. In USENIX Security Symposium, 2014.
[35] S. Chokhani and W. Ford.
Internet X.509 public key infrastructure
certiﬁcate policy and certiﬁcation practices framework. 1999. RFC
2527.
[36] J. Clark and P. C. van Oorschot. SoK: SSL and HTTPS: Revisiting
past challenges and evaluating certiﬁcate trust model enhancements. In
IEEE Symposium on Security and Privacy, May 2013.
[37] C. Coyne and M. Krohn. Keybase.io, 2014.
[38] S. A. Crosby and D. S. Wallach. Efﬁcient data structures for tamper-
evident logging. In USENIX Security Symposium, Aug. 2009.
[39] I. Dacosta, M. Ahamad, and P. Traynor. Trust no one else: Detecting
MITM attacks against SSL/TLS without third-parties. In 17th European
Symposium on Research in Computer Security (ESORICS), Sept. 2012.
[40] I. Damg˚ard. On Σ-protocols, 2010.
[41] A. Danial. Counting Lines of Code. http://cloc.sourceforge.net/.
[42] S. E. Deering and D. R. Cheriton. Multicast routing in datagram
internetworks and extended LANs. ACM Transactions on Computer
Systems, 8(2), May 1990.
[43] D. E. Denning and D. K. Branstad. Key escrow encryption systems.
Communications of the ACM, 39(3):35, 1996.
[44] DeterLab network security testbed, September 2012. http://isi.deterlab.
net/.
com/.
[45] T. Dierks and E. Rescorla. The transport layer security (TLS) protocol
version 1.2, Aug. 2008. RFC 5246.
[46] DigiStamp - Trusted TimeStamp Authority. https://www.digistamp.
[47] R. Dingledine, N. Mathewson, and P. Syverson. Tor: the second-
generation onion router. In 13th USENIX Security Symposium, Aug.
2004.
[48] C. Doctorow. Using distributed code-signatures to make it much harder
to order secret backdoors. BoingBoing, Mar. 2016.
[49] J. R. Douceur. The Sybil attack.
In 1st International Workshop on