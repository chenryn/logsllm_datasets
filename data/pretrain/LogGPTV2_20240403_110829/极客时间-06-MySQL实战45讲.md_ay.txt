# 案例三：主键索引范围锁第三个例子是关于范围查询的。举例之前，你可以先思考一下这个问题：对于我们这个表t，下面这两条查询语句，加锁范围相同吗？    mysql> select * from t where id=10 for update;mysql> select * from t where id>=10 and id```图 3 主键索引上范围查询的锁]{.reference}```{=html}```现在我们就用前面提到的加锁规则，来分析一下 session A 会加什么锁呢？1.  开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key    lock(5,10\]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了    id=10 这一行的行锁。2.  范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key    lock(10,15\]。所以，session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-keylock(10,15\]。这样，session B 和 session C 的结果你就能理解了。这里你需要注意一点，首次 session A 定位查找 id=10的行的时候，是当做等值查询来判断的，而向右扫描到 id=15的时候，用的是范围查询判断。
# 案例四：非唯一索引范围锁接下来，我们再看两个范围查询加锁的例子，你可以对照着案例三来看。需要注意的是，与案例三不同的是，案例四中查询语句的 where 部分用的是字段c。![](Images/10ea465e81d9f756f92f788920123a64.png){savepage-src="https://static001.geekbang.org/resource/image/73/7a/7381475e9e951628c9fc907f5a57697a.png"}```{=html}```图 4 非唯一索引范围锁]{.reference}```{=html}```这次 session A 用字段 c 来判断，加锁规则跟案例三唯一的不同是：在第一次用c=10 定位记录的时候，索引 c 上加了 (5,10\] 这个 next-key lock后，由于索引 c是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A加的锁是，索引 c 上的 (5,10\] 和 (10,15\] 这两个 next-key lock。所以从结果上来看，sesson B 要插入（8,8,8) 的这个 insert语句时就被堵住了。这里需要扫描到 c=15 才停止扫描，是合理的，因为 InnoDB 要扫到c=15，才知道不需要继续往后找了。
# 案例五：唯一索引范围锁 bug前面的四个案例，我们已经用到了加锁规则中的两个原则和两个优化，接下来再看一个关于加锁规则中bug 的案例。![](Images/cde5851a9de87dc6b919f8e4c61bd256.png){savepage-src="https://static001.geekbang.org/resource/image/b1/6d/b105f8c4633e8d3a84e6422b1b1a316d.png"}```{=html}```图 5 唯一索引范围锁的 bug]{.reference}```{=html}```session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15\这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15这一行就应该停止了。但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20\] 这个 next-keylock 也会被锁上。所以你看到了，session B 要更新 id=20这一行，是会被锁住的。同样地，session C 要插入 id=16的一行，也会被锁住。照理说，这里锁住 id=20 这一行的行为，其实是没有必要的。因为扫描到id=15，就可以确定不用往后再找了。但实现上还是这么做了，因此我认为这是个bug。我也曾找社区的专家讨论过，官方 bug 系统上也有提到，但是并未被verified。所以，认为这是 bug这个事儿，也只能算我的一家之言，如果你有其他见解的话，也欢迎你提出来。
# 案例六：非唯一索引上存在\"等值\"的例子接下来的例子，是为了更好地说明"间隙"这个概念。这里，我给表 t插入一条新记录。    mysql> insert into t values(30,10,30);新插入的这一行 c=10，也就是说现在表里有两个 c=10 的行。那么，这时候索引c上的间隙是什么状态了呢？你要知道，由于非唯一索引上包含主键的值，所以是不可能存在"相同"的两行的。![](Images/d1818cbc67cf566f446ab856c66601ed.png){savepage-src="https://static001.geekbang.org/resource/image/c1/59/c1fda36c1502606eb5be3908011ba159.png"}```{=html}```图 6 非唯一索引等值的例子]{.reference}```{=html}```可以看到，虽然有两个 c=10，但是它们的主键值 id 是不同的（分别是 10 和30），因此这两个 c=10 的记录之间，也是有间隙的。图中我画出了索引 c 上的主键 id。为了跟间隙锁的开区间形式进行区别，我用(c=10,id=30) 这样的形式，来表示索引上的一行。现在，我们来看一下案例六。这次我们用 delete 语句来验证。注意，delete 语句加锁的逻辑，其实跟 select\... for update是类似的，也就是我在文章开始总结的两个"原则"、两个"优化"和一个"bug"。![](Images/6f15bae13ff3f9c972e36320434c2a0f.png){savepage-src="https://static001.geekbang.org/resource/image/b5/78/b55fb0a1cac3500b60e1cf9779d2da78.png"}```{=html}```图 7 delete 示例]{.reference}```{=html}```这时，session A 在遍历的时候，先访问第一个 c=10 的记录。同样地，根据原则1，这里加的是 (c=5,id=5) 到 (c=10,id=10) 这个 next-key lock。然后，session A 向右查找，直到碰到 (c=15,id=15)这一行，循环才结束。根据优化2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成(c=10,id=10) 到 (c=15,id=15) 的间隙锁。也就是说，这个 delete 语句在索引 c上的加锁范围，就是下图中蓝色区域覆盖的部分。\![](Images/da1631187177007caa3c761d04cf672c.png){savepage-src="https://static001.geekbang.org/resource/image/bb/24/bb0ad92483d71f0dcaeeef278f89cb24.png"}```{=html}```图 8 delete 加锁效果示例]{.reference}```{=html}```这个蓝色区域左右两边都是虚线，表示开区间，即 (c=5,id=5) 和 (c=15,id=15)这两行上都没有锁。
# 案例七：limit 语句加锁例子 6 也有一个对照案例，场景如下所示：![](Images/7794a1c4f5fe4bd277243de6a4200f14.png){savepage-src="https://static001.geekbang.org/resource/image/af/2e/afc3a08ae7a254b3251e41b2a6dae02e.png"}```{=html}```图 9 limit 语句加锁]{.reference}```{=html}```这个例子里，session A 的 delete 语句加了 limit 2。你知道表 t 里 c=10的记录其实只有两条，因此加不加 limit2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B 的insert 语句执行通过了，跟案例六的结果不同。这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到(c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。因此，索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30)这个前开后闭区间，如下图所示：\![](Images/4a183d8a3b85b31aabfbbfd5481409d9.png){savepage-src="https://static001.geekbang.org/resource/image/e5/d5/e5408ed94b3d44985073255db63bd0d5.png"}```{=html}```图 10 带 limit 2 的加锁效果]{.reference}```{=html}```可以看到，(c=10,id=30）之后的这个间隙并没有在加锁范围里，因此 insert语句插入 c=12 是可以执行成功的。这个例子对我们实践的指导意义就是，**在删除数据的时候尽量加limit**。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。
# 案例八：一个死锁的例子前面的例子中，我们在分析的时候，是按照 next-key lock的逻辑来分析的，因为这样分析比较方便。最后我们再看一个案例，目的是说明：next-keylock 实际上是间隙锁和行锁加起来的结果。你一定会疑惑，这个概念不是一开始就说了吗？不要着急，我们先来看下面这个例子：![](Images/c848c5496eb0e9a52171d32babae91ae.png){savepage-src="https://static001.geekbang.org/resource/image/7b/06/7b911a4c995706e8aa2dd96ff0f36506.png"}```{=html}```图 11 案例八的操作序列]{.reference}```{=html}```现在，我们按时间顺序来分析一下为什么是这样的结果。1.  session A 启动事务后执行查询语句加 lock in share mode，在索引 c    上加了 next-key lock(5,10\] 和间隙锁 (10,15)；2.  session B 的 update 语句也要在索引 c 上加 next-key lock(5,10\    ，进入锁等待；3.  然后 session A 要再插入 (8,8,8) 这一行，被 session B    的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。你可能会问，session B 的 next-key lock 不是还没申请成功吗？其实是这样的，session B 的"加 next-key lock(5,10\"操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10的行锁，这时候才被锁住的。也就是说，我们在分析加锁规则的时候可以用 next-key lock来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。