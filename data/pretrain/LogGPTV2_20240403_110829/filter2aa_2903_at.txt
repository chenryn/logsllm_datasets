从页表结构来看，IA-32e分页可以支持最大物理地址宽度可以是64
位。但如果从芯片的硬件设计来考虑，物理地址的宽度越大，所需的地
址线条数也就越多，这直接关系到芯片封装和主板设计等方面的成本。
而且考虑到短时间内物理内存的容量也根本不需要那么大，所以目前实
际支持的物理地址宽度并不是64位。页表结构中支持的宽度是52位，也
就是4PB。而CPU硬件的实际物理地址宽度可以是小于52的一个可变化
值，在软件手册中，经常用M来表示，是MAXPHYADDR的简写。可以
通过CPUID指令来获取M的值。先将EAX寄存器赋值为80000008H，执
行CPUID指令后，EAX寄存器的最低字节便是M的值。使用本章附带的
CpuId小程序就可以检测M的值。在作者目前正在使用的Intel Core i5-
2540M CPU上执行的结果是48，也就是物理地址的宽度为48位，可以最
多支持256TB的物理内存。类似地，考虑到软件的实际内存需求情况，
线性地址的实际宽度通常也为48位。在64位的Windows操作系统中，实
际使用的是44位（16TB）。
与普通的PAE分页相比，IA-32e有以下主要不同。
新增一级页表，称为页映射表，简称PML4，是Page Map Level 4的
缩写。
CR3寄存器的宽度为64位，低12位为标志位或者用于优化页表缓存
的进程上下文ID（Process-Context Identifiers，PCID），Bit 12到M-
1为页映射表的物理地址，Bit M到Bit 63保留不用（0）。
将48位的线性地址翻译为物理地址的过程如图2-14所示，其中显示
的是物理内存页的大小为4KB的情况。2.7.4节将讨论内存页大小超过
4KB的情况。
图2-14 将线性地址映射到4KB内存页的过程（IA-32e分页）
 格物致知
实践出真知，接下来，我们还是通过动手试验来认识IA-32e分页的
工作原理。
① 启动WinDBG，打开DUMP文件
C:\swdbg2e\dumps\w764\MEMORY.DMP。
② 执行r cr4显示控制寄存器CR4的内容：
0: kd> r cr4
cr4=00000000000006f8
代表PAE的Bit 5为1，印证IA-32e模式是对普通PAE的进一步扩展。
③ 使用da命令观察线性地址fffff880`00f6704d的内容。
0: kd> da fffff880`00f6704d
fffff880`00f6704d  "!This program cannot be run in D"
fffff880`00f6706d  "OS mode....$"
④ 接下来的目标就是将这个线性地址翻译为物理地址，先使
用.format命令将其转化二进制：
0: kd> .formats fffff880`00f6704d
Binary:  11111111 11111111 11111000 10000000 00000000 11110110 01110000 01
001101
⑤ 执行r cr3观察CR3寄存器的内容：
0: kd> r cr3
cr3=000000006911b000
低12位都是0，因此这个数字便是页映射表的物理基地址。
⑥ 根据图2-14，以线性地址的39～47位为索引，读取页映射表表项
（PML4E）：
0: kd> !dq 000000006911b000+0y111110001*8 L1
#6911bf88 00000001`30404863
低12位是标志位，换为0，即得到页指真表的基地址01`30404000。
⑦ 继续以线性地址的30～38位为索引，读取页指针表表项
（PDPTE）：
0: kd> !dq 01`30404000+0y000000000*8 L1
#130404000 00000001`30403863
将代表标志位的低12位换为0，即得到页目录表的基地址
01`30403000。
⑧ 继续以线性地址的21～29位为索引，读取页目录表表项
（PDE）：
0: kd> !dq 01`30403000+0y000000111*8 L1
#130403038 00000000`03483863
将低12位换为0，即得到页表的基地址3483000。
⑨ 继续以线性地址的12～21位为索引，读取页表表项（PTE）：
0: kd> !dq 3483000+0y101100111*8 L1
# 3483b38 80000000`03606963
最高位中的1是所谓的XD（Execute Disable）位，意思是这个页中
的数据不可以被当作指令来执行。低12位是标志位，Bit 0为1代表对应
的内存页有效。将最高位和低12位换成0，便得到物理页的基地址
3606000，再加上线性地址低12位，便得到了线性地址所对应的物理地
址，360604d。使用!db命令观察这个地址，其内容与第3步所观察到的
完全一致。
⑩ 执行!pte fffff880`00f6704d命令，让WinDBG帮我们自动完成以
上翻译过程，其结果应该是一致的，请大家自己完成。 
2.7.4 大内存页
前面以4KB内存页为例介绍了3种分页模式。本节将统一介绍大内
存页的情况。
还是从基本的32位分页开始。在这种模式下，如果页表项的PS位
（Bit 7）为1，那么就代表这个页目录表项指向的是一个4MB的大内存
页，内存翻译过程到此结束，页表项的高10位便是内存页的起始物理地
址，线性地址的低22位是页内偏移。如果PS位为0，那么页目录表项指
向的就是页表，页表中的页表项再指向4KB的内存页，也就是前面介绍
的情况。从翻译过程来看，当访问4KB内存页的线性地址时，翻译时需
要先查页目录，再查页表，也就是查两级页表，而对于4MB大内存页的
线性地址来说，翻译时只需要查一级页表，这可以明显提高访问内存的
速度。从页表结构来看，大内存页就是省略下一级页表，让页目录表项
直接指向物理内存页。
与32位分页类似，在PAE分页模式下，当页目录表项的PS位为1
时，它指向的是2MB的内存页。
以此类推，在IA-32e分页模式下，有两种大内存页：一种是目录项
的PS位为1时，它指向的是2MB大内存页；另一种是当页目录指针表的
PS位（Bit 7）为1时，它指向的是一个1GB的大内存页。
综上所述，大内存页的大小可能是4MB、2MB或者1GB。在
Windows操作系统中，可以调用GetLargePageMinimum API来查询大内
存页的大小。使用大内存页，可以提高访问内存的速度，因此，
Windows内核通常都会为自己分配大内存页。对于应用程序来说，可以
指定MEM_ LARGE_PAGE标志使用VirtualAlloc API来分配大内存页内
存，但是需要有SeLockMemoryPrivilege权限。
 格物致知
下面通过动手试验来进一步理解大内存页。
① 启动WinDBG，打开
C:\swdbg2e\dumps\xpsp3nop\MEMORY.DMP。
② 成功打开文件后，WinDBG会提示内核文件的基地址，以及内核
模块列表的地址：
Kernel base = 0x804d7000 PsLoadedModuleList = 0x8055b1c0
③ 我们就以后一个地址0x8055b1c0为例来看一看它是如何使用大内
存页的，先将其转化为二进制数：
kd> .formats 0x8055b1c0
  Binary:  10000000 01010101 10110001 11000000
④ 执行r cr3得到页目录基地址，然后以线性地址的高10位为索引观
察页目录表项：
kd> r cr3
cr3=0ca83000
kd> !dd 0ca83000+0y1000000001*4 L1
# ca83804 004001e3
⑤ 将页目录项的内容转化为二进制：
kd> .formats 004001e3
  Binary:  00000000 01000000 00000001 11100011
代表页大小的PS位（Bit 7）为1，说明它指向的是4MB的大内存
页，把页目录表项的高10位与线性地址的低22位合并在一起便得到物理
地址。分别使用!dd和dd命令观察物理地址和线性地址，可以看到二者
的内容是一致的。
kd> !dd 0y00000000010101011011000111000000 L4
#  55b1c0 827fc3b0 826948b8 00000000 00000000
kd> dd 0x8055b1c0 L4
8055b1c0  827fc3b0 826948b8 00000000 00000000
⑥ 请读者自己打开xpsp3pae和w764目录下的转储文件，重复上述
步骤，理解PAE模式和64位下的大内存页。
2.7.5 WinDBG的有关命令
前面我们介绍了用手工方法来直接观察页目录表和页表并翻译内存
地址的方法。除了手工方法，也可以使用调试器的命令来完成这些任
务，比如WinDBG提供了以下几个命令。
dg：显示段选择子所指向的段描述符的信息。
!pte：显示出页目录和页表的地址。
!vtop：将虚拟地址翻译为物理地址。
!vpdd：显示物理地址、虚拟地址和内存的内容。
!ptov：显示指定进程中所有物理内存到虚拟内存之间的映射。
!sysptes：显示系统的页目录表项。
当程序执行时，CPU内部的内存管理单元（Memory Management
Unit，MMU）负责将线性地址翻译为物理地址。页表和页目录位于内
存中。为了减少当翻译地址时访问页表和页目录所造成的开销，CPU会
把最近使用的页表和页目录表项存储在CPU内的专用高速缓存中，该缓
存称为译址旁视缓存（Translation Lookaside Buffer，TLB）。有了
TLB，大多数对页目录和页表的访问请求都可以从TLB中读取，这大大
提高了地址翻译的速度。
启用分页机制不是进入保护模式的必要条件（前面讲的分段机制是
保护模式所必需的）。而且是否启用分页机制也不会影响段管理模式，
只是增加了一级映射，系统要根据页表将分段机制形成的线性地址转换
为物理地址。如果不启用分页机制（对于286根本没有分页机制），那
么段机制形成的线性地址就是物理地址。
从图2-10、图2-11和图2-12中我们可以看到，PDE和PTE中包含的很
多标志与段描述符中的标志很类似，如访问标志、读写标志、存在标志
和AVL标志，表2-5归纳了这些标志的含义。
表2-5 段描述符和PTE/PDE中的相似标志
段 描 述 符
PTE或PDE
描  述
P标志
P标志
存在标志
Type中的A标志
A标志
是否被访问过
Type中的R和W标志
R/W
读写控制
AVL
Avail
留给系统软件使用
DPL
U/S
特权级别
这里再讨论一下PDE和PTE中的U/S标志与段描述符中的DPL标志的
相似性。U/S标志代表一个（PTE）或一组（PDE）内存页的特权级
别。U/S标志为0时代表的是管理特权级（supervisor privilege level），
U/S标志为1代表的是用户特权级（user privilege level）。DPL代表的是
该描述符所描述的段的特权级别，0最高，3最低。尽管DPL有4个值，
但是实际上被使用的主要是0（系统特权级）和3（用户特权级）。因此
可以说U/S标志与DPL标志具有同样的作用。
看到这里读者可能会问，为什么要在分段和分页这两种机制中重复
定义这些标志呢？对于大多数IA-32系统，段机制和页机制都是同时启
用的，会不会因为两个地方都要检查这些标志而影响性能呢？简单的回
答是为了兼容。段机制是x86处理器与生俱来的重要特征之一，从第一
代8086 CPU开始所有x86处理器都保持着该特征。尽管在今天看来，有
了分页机制后，分段机制已经变得越来越不重要了，但是为了兼容性和
权限管理，还必须保留分段机制。可以通过若干措施来淡化分段机制的
影响和作用，比如将段的基址设为0，大小设为4GB，这样一个任务的
整个地址空间便都在一个段中了，从效果上相当于取消了分段。在IA-
32e（64-位）模式下，段描述符的基地址和边界值有时会被忽略，但仍
然会用到其中的某些标志和特权级别。
2.8 PC系统概貌
前面几节对CPU的内部特征、功能和发展做了初步介绍。本节从计
算机系统的角度简要描述CPU是如何与其他部件交互的。尽管本节的概
念也适用于某些服务器和工作站系统，但是这里以配备英特尔架构处理
器的常见PC（个人计算机）系统为例。
图2-15粗略勾勒出了一个经典PC系统的主要部件和连接方式。从上
而下，CPU通过前端总线（FSB）与内存控制器（Memory Controller
Hub，MCH）相连接。在多核技术出现之前，大多数PC系统通常只配
备一个CPU，多核技术使一个CPU外壳内包含多个CPU内核。比如，英
特尔的奔腾D 950（D代表Dual，即双内核）CPU内部就包含两个完整的