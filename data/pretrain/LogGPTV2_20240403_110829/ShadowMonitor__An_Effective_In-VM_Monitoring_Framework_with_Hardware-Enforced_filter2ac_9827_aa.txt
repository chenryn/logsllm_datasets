title:ShadowMonitor: An Effective In-VM Monitoring Framework with Hardware-Enforced
Isolation
author:Bin Shi and
Lei Cui and
Bo Li and
Xudong Liu and
Zhiyu Hao and
Haiying Shen
ShadowMonitor: An Eﬀective In-VM
Monitoring Framework with
Hardware-Enforced Isolation
Bin Shi1, Lei Cui2(B), Bo Li1, Xudong Liu1, Zhiyu Hao2, and Haiying Shen3
1 State Key Laboratory of Software Development Environment, Beihang University,
{shibin,libo,liuxd}@act.buaa.edu.cn
Beijing, China
{cuilei,haozhiyu}@iie.ac.cn
2 Institute of Information Engineering, Chinese Academy of Sciences, Beijing, China
3 Department of Computer Science, University of Virginia, Charlottesville, USA
PI:EMAIL
Abstract. Virtual machine introspection (VMI) is one compelling tech-
nique to enhance system security in clouds. It is able to provide strong
isolation between untrusted guests and security tools placed in guests,
thereby enabling dependability of the security tools even if the guest
has been compromised. Due to this beneﬁt, VMI has been widely used
for cloud security such as intrusion detection, security monitoring, and
tampering forensics. However, existing VMI solutions suﬀer signiﬁcant
performance degradation mainly due to the high overhead upon frequent
memory address translations and context-switches. This drawback limits
its usage in many real-world scenarios, especially when ﬁne-grained mon-
itoring is desired. In this paper, we present ShadowMonitor, an eﬀective
VMI framework that enables eﬃcient in-VM monitoring without impos-
ing signiﬁcant overhead. ShadowMonitor decomposes the whole moni-
toring system into two compartments and then assigns each compart-
ment with isolated address space. By placing the monitored components
in the protected compartment, ShadowMonitor guarantees the safety of
both monitoring tools and guests. In addition, ShadowMonitor employs
hardware-enforced instructions to design the gates across two compart-
ments, thereby providing eﬃcient switching between compartments. We
have implemented ShadowMonitor on QEMU/KVM exploiting several
hardware virtualization features. The experimental results show that
ShadowMonitor could prevent several types of attacks and achieves 10×
speedup over the existing method in terms of both event monitoring and
overall application performance.
Keywords: Virtual machine introspection · Monitor · Isolation
1 Introduction
With the prevalence of cloud computing and virtualization technology, vir-
tual machine introspection (VMI) [7,12,15,17,28,29] has become an essential
c(cid:2) Springer Nature Switzerland AG 2018
M. Bailey et al. (Eds.): RAID 2018, LNCS 11050, pp. 670–690, 2018.
https://doi.org/10.1007/978-3-030-00470-5_31
ShadowMonitor: An Eﬀective In-VM Monitoring Framework
671
technique to tackle security risks in virtualized environments. The basic idea of
VMI is to place the traditional security tools into the hypervisor or a separately
trusted virtual machine (VM, or guest in other literature), and then employ
introspection to monitor and protect the untrusted VMs from outside, so-called
out-of-VM introspection. In this way, it guarantees dependability and integrity
of the security tools even if the untrusted VM has been compromised.
Existing out-of-VM introspection techniques fall into two main categories:
passive technique and active technique. The passive technique usually provides
several APIs to touch the state of the monitored system; it invokes the API peri-
odically to detect whether the system is being compromised or not [15,17,34].
The main drawback is that it fails to detect the instant attack which is completed
within a short while. The active technique, in contrast, adopts an event-driven
way by intercepting a broad range of system events including process-switch,
system calls, interruptions, etc. Therefore, it is able to detect the state change in
real-time and thus detects attacks immediately [27,29]. Although the active tech-
nique is appealing in real-time detection, it introduces signiﬁcant performance
overhead due to frequent context-switches (VM to hypervisor) and software-
based virtual address translations [34]. For example, Virtuoso takes 6 s to run
the simple command pslist [12] which is generally completed within a few mil-
liseconds without the interception. Drakvuf introduces 50% performance degra-
dation of guest applications according to our experiments [21]. Although the
overhead can be reduced by intercepting only a few types of events, this limits
the usage of the active technique.
In addition to placing the VMI outside of the VM, some studies propose
to deploy part of the monitoring components into the monitored VM, so-called
in-VM introspection. The main purpose of in-VM introspection is to provide the
same level of security as the out-of-VM approach without imposing signiﬁcant
performance loss. However, the components placed into the untrusted guests
may be disabled or bypassed by the attackers who have compromised the guest.
Therefore, one key concern is to ensure the security of these components placed
into the guests. To achieve this, SIM [30] employs separate shadow page tables
to isolate the monitor components from the guest for guaranteeing security. The
same idea is adopted in other work including [8,29]. However, these works still
suﬀer from several problems. First, they cannot prevent the address translation
redirection attack [16], which is widely used to deceive the security tools with a
fake address mapping [20,23,26]. For instance, SIM isolates its monitor code in
an isolated address space whereas it cannot prevent the malicious kernel from
employing a diﬀerent address mapping. In addition, the in-VM introspection
requires to insert hooks at the interception points in advance, it thus lacks the
ﬂexibility of dynamic conﬁguration at run-time. What’s worse, since they use
software-level shadow page tables to provide address space isolation, they impose
performance loss compared to the native mode which exploits hardware-assisted
optimization (e.g., EPT [2] or RVI [1]), especially when experiencing memory-
intensive operations.
672
B. Shi et al.
Many approaches have been proposed to enhance VM security with hardware
features. For example, SGX of Intel [25] places application code inside an enclave
and encrypts them with speciﬁc instructions to protect the code from untrusted
hardware and OS with higher privilege levels. SeCage [22] leverages hardware
virtualization features to enforce strong isolation between the protected com-
partments and the main compartment. It ensures that only the functions inside
the protected compartment can access the private data. These approaches, how-
ever, focus on isolation rather than monitoring. In addition, they require the
modiﬁcation of application codes, which limits their usage in practical systems.
To mitigate these problems, we propose ShadowMonitor, a general-purpose
framework that provides eﬃcient in-VM monitoring and strong isolation. The
key idea of ShadowMonitor is inspired by Secage [22], which employs hardware
features to enable privilege separation. ShadowMonitor decomposes the whole
monitored system into two separate compartments, i.e., shadow compartment
which contains the monitor tools along with the private data, and main com-
partment which provides the execution environments for guest OS and user
applications. Then, it isolates the two compartments, so that the shadow com-
partment can be protected even if the guest OS (i.e., main compartment) has
been compromised. To achieve this, ShadowMonitor leverages hardware virtual-
ization features (e.g., Intel multi-EPT feature (EPTP-switching) [2]) to assign
each compartment with a separate address space. Meanwhile, the address space
of shadow compartment is well protected; it can only be touched through some
speciﬁc gates using VMFUNC instruction [2]. In addition, exploiting these hard-
ware features, ShadowMonitor invokes event monitoring without trapping into
the hypervisor. Thus, it eliminates heavyweight operations including VM-exits
and VM-enters, and consequentially accesses memory at native speed. Diﬀerent
from existing monitoring invoking methods [29,30], ShadowMonitor provides
ﬂexible event monitoring with a trap-stepping approach. Rather than setup
hooks in advance, it conﬁgures a set of events at run-time including syscall,
kernel functions, and even single instructions.
We have implemented ShadowMonitor on QEMU/KVM [4] platform. We
evaluate ShadowMonitor with a set of experiments. The results show that Shad-
owMonitor is able to provide defenses against several types of attacks. In addi-
tion, ShadowMonitor gains a considerable speedup over existing methods when
monitoring syscalls and process switches. It provides 11× memory speedup and
reduces the performance loss by 58% compared to the out-of-VM introspection
approach, and improves 36.1% over in-VM approach.
The main contributions of this paper are as follows:
– We propose an eﬃcient in-VM monitoring framework which employs hard-
ware features to separate compartments for isolating security tools from
untrusted guests and discuss the challenges to realize it (Sect. 2).
– We present the solutions of providing strong isolation between compartments,
eﬃcient switching, and security event monitoring, which are key components
in ShadowMonitor. (Sect. 3).
ShadowMonitor: An Eﬀective In-VM Monitoring Framework
673
– We implement ShadowMonitor on QEMU/KVM platform (Sect. 4) and con-
duct a set of experiments to prove its eﬀectiveness and eﬃciency (Sect. 6).
– We analyze how ShadowMonitor defends against several attacks, and show
that it can detect malicious behavior and prevent itself from attacks (Sect. 5).
2 Overview
ShadowMonitor aims to achieve three main goals, (i) provide an eﬃcient mon-
itoring approach without introducing signiﬁcant performance overhead, (ii) be
robust to attacks, and (iii) support customized conﬁguration at run-time. In this
section, we will present the threat model and the basic idea of ShadowMonitor.
2.1 Threat Model
In ShadowMonitor, we follow the common assumption widely-adopted in many
full virtualized environments, i.e., the hypervisor is trustworthy while the guests
are not. In speciﬁc, we assume that the guest OS is trusted in the boot-up
procedure, which is the same as [30]. After boot-up, the attackers are able to
compromise the guest OS, yet they cannot break the underlying hypervisor and
hardware nor operate the isolated address space protected by hardware. In addi-
tion, the memory region of the interrupt descriptor table (IDT) is considered
to be safe, since it can be protected by setting permission ﬂags in EPT entries
and trapping operations on IDTR register [2]. Similarly, the interruptions that
trigger address space switch are considered to be safe too. We also assume that
the users of ShadowMonitor are trusted, so that ShadowMonitor is safely oper-
ated. It’s worth noting that some attacks such as VM-escape attack, denial of
service attack (DDoS), and side-channel attack may break ShadowMonitor, we
will discuss them in Sect. 5.
2.2 Basic Idea
The architecture of ShadowMonitor is shown in Fig. 1. The basic idea is to
decompose the monitored system into two parts, i.e., main compartment and
shadow compartment, each of which is assigned with a separate hardware-
enforced address space. The shadow compartment contains monitor components
(e.g., code and collected data), and the main compartment provides the exe-
cution environments for guest operating systems and user applications. In this
way, the Monitor Code and Monitor Data placed in the shadow compartment
are invisible to the guest OS. The memory mappings of the shadow compartment
are inherited from the main compartment, allowing the monitor components to
access information from the guests. Entry and exit between the two compart-
ments are enabled with speciﬁcally designated gates for safety.
ShadowMonitor can be used as an additional service for a single VM or
VM clusters in clouds. Generally, the cloud provider deploys ShadowMonitor in
clouds and allows the VM user to conﬁgure it. With ShadowMonitor, a user
674
B. Shi et al.
Guest Virtual Machine
Main compartment
Code
trap
GATE
Shadow
compartment
Monitor
Code
Monitor
Data
APP
Opera(cid:415)ng
System
Set or remove
traps
Fetch
monitor data
Event Register
Data Storage
Hypervisor
Hardware
Fig. 1. Overview of ShadowMonitor
is able to monitor applications running insides the VM and manages the VM
according to the monitoring data (e.g. rolling back when a potential attack is
detected). The monitor points can be customized by the user with ShadowMon-
itor APIs. More speciﬁcally, after a safe guest boot-up, ShadowMonitor will exe-
cute the following steps. (1) The VM user requests the cloud provider to deploy
the ShadowMonitor components (i.e., construct the shadow compartment and
then place inside the Monitor Code). (2) Then, the user set up (or remove)
traps in the guest by calling APIs of event register provided by ShadowMonitor.
(3) The traps once being touched will trigger the Monitor Code in the shadow
compartment so that the event, as well as its context (e.g., event address, time-
stamp, and arguments), can be recorded. (4) Finally, the data storage module
of ShadowMonitor will collect the monitoring data periodically and report them
to the VM user.
2.3 Challenges
Although the idea is simple, there are several challenges to be addressed to realize
ShadowMonitor.
– Isolation of compartments: The guest running in the main compartment after
being compromised may attempt to break the security tools deployed in the
shadow compartment. Therefore, to provide strong isolation between the two
is essential to ensure the security of ShadowMonitor.
– Eﬃcient switching between compartments: The entry and exit to the main
and shadow compartments are achieved by a designated gate. Consider that
the switches between the two are frequent, how to switch with low overhead
is critical to the performance of guest application and monitoring.
ShadowMonitor: An Eﬀective In-VM Monitoring Framework
675
– Customized event interception at run-time: ShadowMonitor should be able to
monitor a wide range of events. Meanwhile, the user should be able to register
or cancel an event interception at run-time. Thus, it is important to provide
dynamic and ﬂexible event monitoring.
Guest ordinary memory
Guest 
OS
APPs
Monitor 
Code
Monitor 
Date
EPT-N
R WR W
R W X
R W X
EPT-S
R WR W