mK/'K mark/go to Key (any key)
M walk the mounted filesystems
n/N seek next/prev function/flag/hit (scr.nkey)
o go/seek to given offset
O toggle asm.esil
p/P rotate print modes (hex, disasm, debug, words, buf)
q back to radare shell
r refresh screen / in cursor mode browse comments
R randomize color palette (ecr)
sS step / step over
248
2.2.1 radare2
t browse types
T enter textlog chat console (TT)
uU undo/redo seek
v visual function/vars code analysis menu
V (V)iew graph using cmd.graph (agv?)
wW seek cursor to next/prev word
xX show xrefs/refs of current function from/to data/code
yY copy and paste selection
z fold/unfold comments in disassembly
Z toggle zoom mode
Enter follow address of jump/call
Function Keys: (See 'e key.'), defaults to:
F2 toggle breakpoint
F4 run to cursor
F7 single step
F8 step over
F9 continue
视图模式下的命令和命令行模式下的命令有很大不同，下面列出几个，更多的命令
请查看帮助：
o ：定位到给定的偏移。
; ：添加注释。
V ：查看图形。
: ：运行 radare2 命令
Web 界面使用
Radare2 的 GUI 尚在开发中，但有一个 Web 界面可以使用，如果刚开始你不习惯
命令行操作，可以输入下面的命令：
$ r2 -c=H [filename]
默认地址为 http://localhost:9090/ ，这样你就可以在 Web 中进行操作了，
但是我强烈建议你强迫自己使用命令行的操作方式。
cutter GUI
249
2.2.1 radare2
cutter 是 r2 官方的 GUI，已经在快速开发中，基本功能已经有了，喜欢界面操作的
读者可以试一下（请确保 r2 已经正确安装）：
$ yaourt -S qt
$ git clone https://github.com/radareorg/cutter
$ cd cutter
$ mkdir build
$ cd build
$ qmake ../src
$ make
然后就可以运行了：
$ ./cutter
在 CTF 中的运用
IOLI crackme
radare2-explorations-binaries
更多资源
The radare2 book
Radare2 intro
Radare2 blog
A journey into Radare 2 – Part 1: Simple crackme
A journey into Radare 2 – Part 2: Exploitation
250
2.2.2 IDA Pro
2.2.2 IDA Pro
快捷键
IDA Python
常用插件
常用脚本
技巧
参考资料
快捷键
; ：为当前指令添加全文交叉引用的注释
n ：定义或修改名称，通常用来标注函数名
g ：跳转到任意地址
Esc ：返回到跳转前的位置
D ：分别按字节、字、双字显示数据
A ：按 ASCII 显示数据
IDA Python
常用插件
IDA FLIRT Signature Database -- 用于识别静态编译的可执行文件中的库函数
Find Crypt -- 寻找常用加密算法中的常数（需要安装 yara-python）
IDA signsrch -- 寻找二进制文件所使用的加密、压缩算法
Ponce -- 污点分析和符号化执行工具
snowman decompiler -- C/C++反汇编插件（F3 进行反汇编）
CodeXplorer -- 自动类型重建以及对象浏览（C++）（jump to disasm)
IDA Ref -- 汇编指令注释（支持arm，x86，mips）
auto re -- 函数自动重命名
nao -- dead code 清除
HexRaysPyTools -- 类/结构体创建和虚函数表检测
DIE -- 动态调试增强工具，保存函数调用上下文信息
251
2.2.2 IDA Pro
sk3wldbg -- IDA 动态调试器，支持多平台
idaemu -- 模拟代码执行（支持X86、ARM平台）
Diaphora -- 程序差异比较
Keypatch -- 基于 Keystone 的 Patch 二进制文件插件​
FRIEND -- 哪里不会点哪里，提升汇编格式的可读性、提供指令、寄存器的文
档等
SimplifyGraph -- 简化复杂的函数流程图
bincat -- 静态二进制代码分析工具包，2017 Hex-Rays 插件第一名
golang_loader_assist -- Golang编译的二进制文件分析助手
BinDiff
常用脚本
内存 dump 脚本
调试程序时偶尔会需要 dump 内存，但 IDA Pro 没有直接提供此功能，可以通过脚
本来实现。
import idaapi
data = idaapi.dbg_read_memory(start_address, data_length)
fp = open('path/to/dump', 'wb')
fp.write(data)
fp.close()
技巧
堆栈不平衡
某些函数在使用 f5 进行反编译时，会提示错误 "sp-analysis failed"，导致无法正确
反编译。原因可能是在代码执行中的 pop、push 操作不匹配，导致解析的时候 esp
发生错误。
解决办法步骤如下：
1. 用 Option->General->Disassembly, 将选项 Stack pointer 打钩
252
2.2.2 IDA Pro
2. 仔细观察每条 call sub_xxxxxx 前后的堆栈指针是否平衡
3. 有时还要看被调用的 sub_xxxxxx 内部的堆栈情况，主要是看入栈的参数与 ret
xx 是否匹配
4. 注意观察 jmp 指令前后的堆栈是否有变化
5. 有时用 Edit->Functions->Edit function...,然后点击 OK 刷一下函数定义
参考资料
《IDA Pro权威指南（第2版）》
https://www.hex-rays.com/products/ida/
253
2.2.3 JEB
2.2.3 JEB
快捷键
参考资料
快捷键
参考资料
https://www.pnfsoftware.com/
254
2.2.4 Capstone
2.2.4 Capstone
简介
开发接口
参考资料
简介
Capstone 是一款开源、轻量级、多平台、多架构的反汇编框架，支持 x86、x86-
64、ARM、ARM64、MIPS、PowerPC 等架构，支持 Windows、Linux、macOS
操作系统。
开发接口
参考资料
http://www.capstone-engine.org/
BHUSA2014-capstone
https://github.com/aquynh/capstone
255
2.2.5 Keystone
2.2.5 Keystone
http://www.keystone-engine.org/
256
2.3.1 GDB
2.3.1 GDB
gdb 的组成架构
gdb 基本工作原理
gdb 的三种调试方式
断点的实现
gdb 基本操作
gdb-peda
GEF/pwndbg
参考资料
gdb 的组成架构
257
2.3.1 GDB
gdb 基本工作原理
gdb 通过系统调用 ptrace 来接管一个进程的执行。ptrace 系统调用提供了一种
方法使得父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存
器。它主要用来实现断点调试和系统调用跟踪。ptrace 系统调用的原型如下：
#include 
long ptrace(enum __ptrace_request request, pid_t pid, void *addr
, void *data);
pid_t pid：指示 ptrace 要跟踪的进程。
258
2.3.1 GDB
void *addr：指示要监控的内存地址。
void *data：存放读取出的或者要写入的数据。
enum __ptrace_request request：决定了系统调用的功能，几个主要的选
项：
PTRACE_TRACEME：表示此进程将被父进程跟踪，任何信号（除了
SIGKILL ）都会暂停子进程，接着阻塞于 wait() 等待的父进程被唤
醒。子进程内部对 exec() 的调用将发出 SIGTRAP 信号，这可以让父
进程在子进程新程序开始运行之前就完全控制它。
PTRACE_ATTACH：attach 到一个指定的进程，使其成为当前进程跟踪
的子进程，而子进程的行为等同于它进行了一次 PTRACE_TRACEME 操
作。但需要注意的是，虽然当前进程成为被跟踪进程的父进程，但是子进
程使用 getppid() 的到的仍将是其原始父进程的 pid。
PTRACE_CONT：继续运行之前停止的子进程。可同时向子进程交付指
定的信号。
gdb 的三种调试方式
运行并调试一个新进程
运行 gdb，通过命令行或 file 命令指定目标程序。
输入 run 命令， gdb 执行下面的操作：
通过 fork() 系统调用创建一个新进程
在新创建的子进程中执行操作： ptrace(PTRACE_TRACEME, 0, 0,
0)
在子进程中通过 execv() 系统调用加载用户指定的可执行文件
attach 并调试一个已经运行的进程
用户确定需要进行调试的进程 PID
运行 gdb，输入 attach  ，gdb 将对指定进程执行操
作： ptrace(PTRACE_ATTACH, pid, 0, 0)
远程调试目标机上新创建的进程
gdb 运行在调试机上，gdbserver 运行在目标机上，两者之间的通信数据
格式由 gdb 远程串行协议（Remote Serial Protocol）定义
RSP 协议数据的基本格式为： $..........#xx
gdbserver 的启动方式相当于运行并调试一个新创建的进程
注意，在你将 gdb attach 到一个进程时，可能会出现这样的问题：
259
2.3.1 GDB
gdb-peda$ attach 9091
Attaching to process 9091
ptrace: Operation not permitted.
这是因为开启了内核参数 ptrace_scope ：
$ cat /proc/sys/kernel/yama/ptrace_scope
1
1 表示 True，此时普通用户进程是不能对其他进程进行 attach 操作的，当然你可
以用 root 权限启动 gdb，但最好的办法还是关掉它：
# echo 0 > /proc/sys/kernel/yama/ptrace_scope
断点的实现
断点的功能是通过内核信号实现的，在 x86 架构上，内核向某个地址打入断点，实
际上就是往该地址写入断点指令 INT 3 ，即 0xCC 。目标程序运行到这条指令
之后会触发 SIGTRAP 信号，gdb 捕获这个信号，并根据目标程序当前停止的位置
查询 gdb 维护的断点链表，若发现在该地址确实存在断点，则可判定为断点命中。
gdb 基本操作
使用 -tui 选项可以将代码显示在一个漂亮的交互式窗口中。
break -- b
break 当不带参数时，在所选栈帧中执行的下一条指令处设置断点。
break  在函数体入口处打断点。
break  在当前源码文件指定行的开始处打断点。
break -N break +N 在当前源码行前面或后面的 N 行开始处打断
点， N 为正整数。
break  在源码文件 filename 的 line 行处打断点。
break  在源码文件 filename 的 function 函
260
2.3.1 GDB
数入口处打断点。
break  在程序指令的地址处打断点。
break ... if  设置条件断点， ... 代表上述参数之一（或无参
数）， cond 为条件表达式，仅在 cond 值非零时停住程序。
info
info breakpoints -- i b 查看断点，观察点和捕获点的列表。
info breakpoints [list…]
info break [list…]
list… 用来指定若干个断点的编号（可省略），可以是 2 ， 1-3 ，
2 5 等。
info display 打印自动显示的表达式列表，每个表达式都带有项目编号，
但不显示其值。
info reg 显示当前寄存器信息。
info threads 打印出所有线程的信息，包含 Thread ID、Target ID 和
Frame。
info frame 打印出指定栈帧的详细信息。
info proc 查看 proc 里的进程信息。
disable -- dis
禁用断点，参数使用空格分隔。不带参数时禁用所有断点。
disable [breakpoints] [list…] breakpoints 是 disable 的子命令
（可省略）， list… 同 info breakpoints 中的描述。
enable
启用断点，参数使用空格分隔。不带参数时启用所有断点。
enable [breakpoints] [list…] 启用指定的断点（或所有定义的断点）。
enable [breakpoints] once list… 临时启用指定的断点。GDB 在停止您
的程序后立即禁用这些断点。
enable [breakpoints] delete list… 使指定的断点启用一次，然后删
除。一旦您的程序停止，GDB 就会删除这些断点。等效于用 tbreak 设置的
断点。
261
2.3.1 GDB
breakpoints 同 disable 中的描述。
clear
在指定行或函数处清除断点。参数可以是行号，函数名称或 * 跟一个地址。
clear 当不带参数时，清除所选栈帧在执行的源码行中的所有断点。
clear  , clear  删除在命名函数的入
口处设置的任何断点。
clear  , clear  删除在指定的文件指定的行号
的代码中设置的任何断点。
clear  清除指定程序指令的地址处的断点。
delete -- d
删除断点。参数使用空格分隔。不带参数时删除所有断点。
delete [breakpoints] [list…]
tbreak
设置临时断点。参数形式同 break 一样。当第一次命中时被删除。