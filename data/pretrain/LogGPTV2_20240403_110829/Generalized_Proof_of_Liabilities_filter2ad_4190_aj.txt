Verifiable Oblivious RAM Machine (PVORM) is proposed [16] to
achieve a similar goal as in PoL, i.e., allowing an database manager
to verifiably update the publicly visible but encrypted dataset for
users without leaking usersâ€™ update patterns. Adopting PVORM
in PoL, users donâ€™t even need to verify inclusion proofs after each
update but only the update proofs of PVORM, which we discuss
further in section 4.3.3.
D DAPOL+ PSEUDOCODE
We present the pseudocode of the DAPOL+ protocol in fig. 8 to
help demonstrate how it works.
E ProtDAPOL+ SECURITY
We prove theorem 4.1 that ProtDAPOL+(ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿) satisfies correct-
ness and soundness.
Proof. It is straightforward that ProtDAPOL+(ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿) satisfies
correctness.
Now we prove ProtDAPOL+(ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿) satisfies soundness. Assume
for contradiction that soundness is broken, which means there
exists a (ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿)-valid data set ğ·ğµ, a p.p.t. adversarial prover
Aâˆ— corrupting some users in U, and a subset ğ‘‰ of non-corrupted
users such that with non-negligible probability, the adversary can
cheat users in ğ‘‰ without being detected. First, because usersâ€™ IDs
are distinct in a valid ğ·ğµ, by collision resistance of H(Â·), each
user must be mapped to a unique leaf node. Combining Merkle
proofs for all users in ğ‘‰ , again by collision resistance of H(Â·),
the intersection nodes of different Merkle paths together with the
leaf nodes of ğ‘‰ are consistent. Hence a unique sparse Merkle tree
ğ‘†ğ‘€ğ‘‡ can be derived from the Merkle paths and the leaf nodes for
users in ğ‘‰ . By the computationally binding property of Pedersen
commitments, each leaf node mapped to ğ‘¢ âˆˆ ğ‘‰ commits to the
proverâ€™s liabilities to ğ‘¢. By the additively homomorphic property of
Pedersen commitments, the root node should commit to the sum
of values in all leaf nodes and padding nodes in ğ‘†ğ‘€ğ‘‡ if there is no
overflow. For each ğ‘¢ âˆˆ ğ‘‰ , by the soundness of Bulletproofs, each
sibling node in ğ‘¢â€™s Merkle path commits to a value within range
[0, ğ‘ Â· ğ‘€ğ‘ğ‘¥ğ¿). Since ğ‘™ğ‘¢ âˆˆ [0, ğ‘€ğ‘ğ‘¥ğ¿) as ğ·ğµ is valid, the internal
node at height ğ‘– on the path from ğ‘¢â€™s leaf node to the root commits
to a value within [0, ((ğ» âˆ’ ğ‘–) Â· ğ‘ + 1) Â· ğ‘€ğ‘ğ‘¥ğ¿), so the root within
[0, (ğ» Â· ğ‘ +1)Â· ğ‘€ğ‘ğ‘¥ğ¿). Given that ğ‘ â‰¥ (ğ» Â· ğ‘ +1)Â· ğ‘€ğ‘ğ‘¥ğ¿, there isnâ€™t
an overflow in the additions. Therefore, ğ¿ =ğ‘¢âˆˆğ‘‰ ğ‘™ğ‘¢ +ğ‘–âˆˆğ‘Š ğ‘£ğ‘–,
ğ¿ < ğ‘¢âˆˆğ‘‰ ğ‘™ğ‘¢ indicates that there exists some node ğ‘– âˆˆ ğ‘Š such
where ğ‘Š is the set of padding nodes in ğ‘†ğ‘€ğ‘‡ not mapped to any
user in ğ‘‰ and ğ‘£ğ‘– is the value each node in ğ‘Š is committed to. Thus
that ğ‘£ğ‘– < 0. This violates the security of Bulletproofs proving the
range of ğ‘£ğ‘–. Therefore, ProtDAPOL+(ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿) satisfies soundness
and thus is secure.
â–¡
We now show that ProtDAPOL+(ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿) is Î¦user-private where
Î¦user = âˆ… as defined in theorem 4.2.
Proof. The real game returns ğ‘ƒğ·, ğ·ğµ[ğ‘‰] and {ğœ‹ğ‘¢}ğ‘¢âˆˆğ‘‰ . We
construct as follows the simulator S taking 1ğœ… and ğ·ğµ[ğ‘‰] as inputs:
ProtDAPOL+(ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿)
Public parameters :
ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿, ğ», ğº, ğ‘”1, ğ‘”2, ğ‘ ğ‘ğ‘™ğ‘¡_ğ‘, ğ‘ ğ‘ğ‘™ğ‘¡_ğ‘ 
On init, P executes Setup(1ğœ…, ğ·ğµ) :
Let ğ‘šğ‘ğ‘ ğ‘¡ğ‘’ğ‘Ÿ_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡
Randomly map ğ‘¢ âˆˆ U to a bottom-layer leaf node in an empty SMT;
For ğ‘– in ğ» ..1 :
$â† {0, 1}ğœ…;
Add padding nodes for non-existing siblings of existing nodes at height ğ‘–;
Add parent nodes at height ğ‘– âˆ’ 1 for existing nodes at height ğ‘–;
For ğ‘— in ğ» ..0 :
For ğ‘– is an existing node at height ğ‘— in SMT :
Â· ğ‘”ğ‘ğ‘¢
2
If ğ‘– is a leaf node of user ğ‘¢ :
Let ğ‘¤ğ‘¢ = ğ¾ğ·ğ¹ (ğ‘šğ‘ğ‘ ğ‘¡ğ‘’ğ‘Ÿ_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡, ğ‘–ğ‘‘ğ‘¢);
Let ğ‘ğ‘¢ = ğ¾ğ·ğ¹ (ğ‘¤ğ‘¢, ğ‘ ğ‘ğ‘™ğ‘¡_ğ‘), ğ‘ ğ‘¢ = ğ¾ğ·ğ¹ (ğ‘¤ğ‘¢, ğ‘ ğ‘ğ‘™ğ‘¡_ğ‘ );
Let ğ‘ğ‘¢ = ğ¶ğ‘œğ‘š(ğ‘™ğ‘¢, ğ‘ğ‘¢) = ğ‘”ğ‘™ğ‘¢
1
If ğ‘– is a padding node :
Let ğ‘¤ğ‘– = ğ¾ğ·ğ¹ (ğ‘šğ‘ğ‘ ğ‘¡ğ‘’ğ‘Ÿ_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡, ğ‘–ğ‘‘ğ‘¥ğ‘–);
Let ğ‘ğ‘– = ğ¾ğ·ğ¹ (ğ‘¤ğ‘–, ğ‘ ğ‘ğ‘™ğ‘¡_ğ‘), ğ‘ ğ‘– = ğ¾ğ·ğ¹ (ğ‘¤ğ‘–, ğ‘ ğ‘ğ‘™ğ‘¡_ğ‘ );
Let ğ‘ğ‘– = ğ¶ğ‘œğ‘š(0, ğ‘ğ‘–) = ğ‘”0
2 , â„ğ‘– = H(â€œğ‘ğ‘ğ‘‘â€||ğ‘–ğ‘‘ğ‘¥ğ‘– ||ğ‘ ğ‘–);
If ğ‘– is an internal node :
Let ğ‘ğ‘– = ğ‘ğ‘™ğ‘â„ğ‘– Â· ğ‘ğ‘Ÿğ‘â„ğ‘– , â„ğ‘– = H(ğ‘ğ‘™ğ‘â„ğ‘– ||ğ‘ğ‘Ÿğ‘â„ğ‘– ||â„ğ‘™ğ‘â„ğ‘– ||â„ğ‘Ÿğ‘â„ğ‘– );
1 Â· ğ‘”ğ‘ğ‘–
, â„ğ‘¢ = H(â€œğ‘™ğ‘’ğ‘ğ‘“ â€||ğ‘–ğ‘‘ğ‘¢ ||ğ‘ ğ‘¢);
Let ğ‘†ğ· = (ğ‘šğ‘ğ‘ ğ‘¡ğ‘’ğ‘Ÿ_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡, the mapping);
Publish ğ‘ƒğ· = (ğ‘ğ‘Ÿğ‘œğ‘œğ‘¡ , â„ğ‘Ÿğ‘œğ‘œğ‘¡);
Let ğ¿ =ğ‘¢âˆˆU ğ‘™ğ‘¢, Î  =ğ‘¢âˆˆU ğ‘ğ‘¢ +padding node ğ‘– ğ‘ğ‘–;
Send the requester (â€œVerifyTotâ€, ğ¿, Î );
On receive â€œProveTotâ€ from a requester, P executes ProveTot(ğ·ğµ, ğ‘†ğ·) :
On receive (â€œVerifyTotâ€, ğ¿, Î ) from P, execute VerifyTot(ğ‘ƒğ·, ğ¿, Î ) :
If ğ‘ƒğ· = (ğ‘ğ‘Ÿğ‘œğ‘œğ‘¡ , â„ğ‘Ÿğ‘œğ‘œğ‘¡) and ğ‘ğ‘Ÿğ‘œğ‘œğ‘¡ = ğ‘”ğ¿
return 1;
1 Â· ğ‘”Î 
2 :
Else :
return 0;
exit;
On receive (â€œProveâ€, ğ‘–ğ‘‘) from a request, P executes Prove(ğ·ğµ, ğ‘†ğ·, ğ‘–ğ‘‘) :
If the requester fails to authenticate identity with respect to ğ‘–ğ‘‘ :
Retrieve ğ‘ and ğ‘  of the user with ğ‘–ğ‘‘;
Retrieve the Merkle path {(ğ‘ğ‘–, â„ğ‘–)}ğ‘–âˆˆ[1,ğ» ] authenticating the userâ€™s leaf node;
Generate ğœ‹ğ‘Ÿğ‘ğ‘›ğ‘”ğ‘’ proving {ğ‘ğ‘– }ğ‘–âˆˆ[1,ğ» ] commits to values within [0, ğ‘ Â· ğ‘€ğ‘ğ‘¥ğ¿);
Send the requester (â€œVerifyâ€, ğœ‹ = (ğ‘, ğ‘ , {(ğ‘ğ‘–, â„ğ‘–)}ğ‘–âˆˆ[1,ğ» ], ğœ‹ğ‘Ÿğ‘ğ‘›ğ‘”ğ‘’));
On receive (â€œVerifyâ€, ğœ‹) from P, execute Verify(ğ‘ƒğ·, ğ‘–ğ‘‘, ğ‘™, ğœ‹) :
ğ» = Com(ğ‘™, ğ‘), â„â€²
Let ğ‘â€²
For ğ‘– in ğ» âˆ’ 1..0 :
Let ğ‘â€²
If (ğ‘â€²
0, â„â€²
return 1;
ğ» = H(â€œğ‘™ğ‘’ğ‘ğ‘“ â€||ğ‘–ğ‘‘ ||ğ‘ );
ğ‘–+1 Â· ğ‘ğ‘–+1 and similarly compute â„â€²
ğ‘–;
ğ‘– = ğ‘â€²
0) = ğ‘ƒğ· and ğœ‹ğ‘Ÿğ‘ğ‘›ğ‘”ğ‘’ is valid :
Else :
return 0;
Figure 8: The DAPOL+ protocol.
If ğ‘‰ = âˆ…, randomly sample ğ‘ 
(ğ‘ = Com(0, ğ‘), â„ = H(ğ‘ )), âˆ… and âˆ….
Otherwise, when ğ‘‰ â‰  âˆ…,
$â† {0, 1}ğœ… and ğ‘
$â† Zğ‘, and return
(1) Randomly map each user in ğ‘‰ to a bottom layer node in an
empty SMT of height ğ». For each node mapped to a user
ğ‘¢ âˆˆ ğ‘‰ , let ğ‘ğ‘¢ = Com(ğ‘™ğ‘¢, ğ‘ğ‘¢) and â„ğ‘¢ = H(â€œleafâ€||ğ‘–ğ‘‘ğ‘¢||ğ‘ ğ‘¢),
$â† Zğ‘. Note that H(Â·) and
where ğ‘ ğ‘¢
ğ¾ğ·ğ¹(Â·) are calls to a random oracle.
(2) Construct a sparse Merkle tree ğ‘†ğ‘€ğ‘‡ initiated with the bot-
tom layer nodes mapped to users in ğ‘‰ . For each padding
$â† {0, 1}ğœ… and ğ‘ğ‘¢
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3483consists of one sender and one receiver for simplicity, each transac-
tion involves users either within a single VASP, i.e., the sender and
the receiver belong to the same VASP, or across two VASPs. Here
we empirically analyze all possible scenarios of dispute resolution
for the single-VASP case and the cross-VASP case separately.
F.1 Transaction within a single VASP
$â† {0, 1}ğœ… and ğ‘ğ‘–
$â† Zğ‘. Let ğ‘ğ‘– =
node ğ‘–, randomly sample ğ‘ ğ‘–
Com(0, ğ‘ğ‘–) and â„ğ‘– = H(â€œğ‘ğ‘ğ‘‘â€||ğ‘–ğ‘‘ğ‘¥ğ‘–||ğ‘ ğ‘–). Then for each inter-
nal node ğ‘– with child nodes ğ‘™ğ‘â„ğ‘– and ğ‘Ÿğ‘â„ğ‘–, let ğ‘ğ‘– = ğ‘ğ‘™ğ‘â„ğ‘– Â· ğ‘ğ‘Ÿğ‘â„ğ‘–
and â„ğ‘– = H(ğ‘ğ‘™ğ‘â„ğ‘– ||ğ‘ğ‘Ÿğ‘â„ğ‘– ||â„ğ‘™ğ‘â„ğ‘– ||â„ğ‘Ÿğ‘â„ğ‘–).
(3) Return (ğ‘ğ‘Ÿğ‘œğ‘œğ‘¡ , â„ğ‘Ÿğ‘œğ‘œğ‘¡), ğ·ğµ[ğ‘‰] and inclusion proofs for each
user in ğ‘‰ generated from ğ‘†ğ‘€ğ‘‡ .
Now we have defined the simulator, and the proof is straightforward.
We introduce a hybrid game in which each user in ğ‘‰ is mapped to
a bottom layer node in an empty SMT of height ğ», and the SMT
for ğ‘‰ only is generated as in the real game. This hybrid game is
indistinguishable from the real game. Then by perfect hiding of
Pedersen commitments and zero-knowledge of Bulletproofs, the
hybrid game is indistinguishable from the simulated game.
â–¡
We now show that ProtDAPOL+(ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿) is Î¦auditor-private
where Î¦auditor = âˆ… as defined in theorem 4.3.
Proof. The real game returns ğ‘ƒğ·, ğ¿, Î , ğ·ğµ[ğ‘‰] and {ğœ‹ğ‘¢}ğ‘¢âˆˆğ‘‰ .
We construct as follows the simulator S taking 1ğœ…, ğ¿ and ğ·ğµ[ğ‘‰]
as inputs:
If ğ‘‰ = âˆ…, randomly sample ğ‘ 
(ğ‘ = Com(ğ¿, ğ‘), â„ = H(ğ‘ )), ğ¿, ğ‘, âˆ… and âˆ….
Otherwise, when ğ‘‰ â‰  âˆ…,
$â† Zğ‘, and return
$â† {0, 1}ğœ… and ğ‘
$â† Zğ‘.
(1) Randomly map each user in ğ‘‰ to a bottom layer node in
an empty SMT of height ğ», and compute the commitment
and hash for each user by ğ‘ğ‘¢ = Com(ğ‘™ğ‘¢, ğ‘ğ‘¢) and â„ğ‘¢ =
H(â€œleafâ€||ğ‘–ğ‘‘ğ‘¢||ğ‘ ğ‘¢), where ğ‘ ğ‘¢
$â† {0, 1}ğœ… and ğ‘ğ‘¢
$â† {0, 1}ğœ… and ğ‘ğ‘–
(2) Construct a sparse Merkle tree ğ‘†ğ‘€ğ‘‡ initiated with the bot-
tom layer nodes mapped to users in ğ‘‰ . For each padding
$â† Zğ‘. Let
node ğ‘–, randomly sample ğ‘ ğ‘–
ğ‘ğ‘– = Com(0, ğ‘ğ‘–) and â„ğ‘– = H(â€œğ‘ğ‘ğ‘‘â€||ğ‘–ğ‘‘ğ‘¥ğ‘–||ğ‘ ğ‘–) except that for
Note that when there isnâ€™t a padding node in ğ‘†ğ‘€ğ‘‡ , the tree is
full and the adversary corrupts all users. Next for each inter-
nal node ğ‘– with child nodes ğ‘™ğ‘â„ğ‘– and ğ‘Ÿğ‘â„ğ‘–, let ğ‘ğ‘– = ğ‘ğ‘™ğ‘â„ğ‘– Â· ğ‘ğ‘Ÿğ‘â„ğ‘–
and â„ğ‘– = H(ğ‘ğ‘™ğ‘â„ğ‘– ||ğ‘ğ‘Ÿğ‘â„ğ‘– ||â„ğ‘™ğ‘â„ğ‘– ||â„ğ‘Ÿğ‘â„ğ‘–).
ğ·ğµ[ğ‘‰] and inclusion proofs for each user in ğ‘‰ generated
from ğ‘†ğ‘€ğ‘‡ .
one padding node ğ‘—, let ğ‘ ğ‘— = Com(ğ¿âˆ’ğ‘¢âˆˆğ‘‰ ğ‘™ğ‘¢, ğ‘ ğ‘—) if ğ‘— exists.
(3) Return (ğ‘ğ‘Ÿğ‘œğ‘œğ‘¡ , â„ğ‘Ÿğ‘œğ‘œğ‘¡), ğ¿, ğ‘ğ‘Ÿğ‘œğ‘œğ‘¡ =ğ‘¢âˆˆğ‘‰ ğ‘ğ‘¢+padding node ğ‘– ğ‘ğ‘–,
Now we have defined the simulator, and the proof is similar to that
of theorem 4.2. Consider a hybrid game in which each user in ğ‘‰ is
mapped to a bottom layer node in an empty SMT of height ğ» first,
and users in U âˆ’ ğ‘‰ are mapped next, and then the game proceeds
as in the real game. This hybrid game is indistinguishable from the
real game. By perfect hiding of Pedersen commitments and zero-
knowledge of Bulletproofs, the hybrid game is indistinguishable
from the simulated game.
â–¡
F DISPUTE RESOLUTION
In this section, we take the solvency case as an example and dis-
cuss dispute resolution in PoL. Each virtual asset service provider
(VASP) [27] plays the role of a prover and clients depositing virtual
assets to it need to verify the inclusion of their balances in the
VASPâ€™s total liabilities. A user may send money to another a trans-
action via the VASP he/she belongs to. Assuming every transaction
Figure 9: Transaction within a single VASP.
We depict in fig. 9 the protocol for a user to send a transaction
with only necessary interactions. Note that the green and red dotted
arrows are for the same purpose of guaranteeing that the receiver
has the receipt of the transaction, and are complementary to each
other, which we soon explain in detail. We classify all possible
scenarios of disputes by the set of maliciously colluding entities
and summarize them in table 5. We denote by S the sender, R the
receiver, V the VASP, and H an entity being honest and M being
malicious.
Table 5: Transaction within a single VASP.
S
M
V
H
R
H
H
M
H
H
M
M
H
H
M
H
M
M
H
M
M
Potential attack
deny a tx