regions should be supported on the ARM platform.
Running area
Watermark region
Rich OS
ICE Runtime
Environment
ICE n
…...
ICE i
…...
ICE 1
Rich OS
ICE i
ICE n
…...
ICE i
…...
ICE 1
TDC (64KB)
TDC (64KB)
(a) Rich OS is running
(b) ICE i is running
Fig. 6: Memory Map with Multiple (> 2) ICEs
B. Loading TDC
Similar to other embedded systems, i.MX53 QSB starts
with the code in the Boot ROM when it is powered on. The
code memory address of ROM is between 0x00000000 and
0x0000FFFF. i.MX53 QSB provides a High Assurance Boot
(HAB) to ensure the authenticity and integrity of an image that
will be loaded into the processor chips [13], [22]. The Boot
371371
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:53:17 UTC from IEEE Xplore.  Restrictions apply. 
ROM loads the secure bootloader image from the Micro SD
card, and then HAB veriﬁes the integrity and authenticity of
the secure boot image using SHA-256 and RSA algorithms
embedded in the Boot ROM code. The hash of the public key
of the root certiﬁcate is stored at one electrically programmable
Fuse (eFUSE) named SRK HASH, whose value cannot be
changed after eFUSE blowing. The secure bootloader in this
work is developed based on Uboot [23]. It is responsible
for loading TDC into the watermark region using Uboot
mmc read command. A certiﬁcate signed by root certiﬁcate is
used as the developing certiﬁcate of TDC, and the developing
certiﬁcate is stored with TDC. The value of SRK HASH
is used to verify TDC’s developing certiﬁcate. TDC will be
loaded only if the veriﬁcation succeeds.
C. System State Switching
TDC is responsible for enforcing a secure switching from
the Rich OS to one ICE and then back to the Rich OS. Figure 7
shows the switching steps when an application needs to execute
secure code. When one application is running in the user mode
of the normal domain, an SMC instruction must be called
to switch from the normal domain to the TDC in the secure
domain; however, SMC is a privileged instruction and cannot
be called directly by applications. Hence, we add an SMC
system call into the Rich OS to allow applications to call the
SMC instruction. The system call contains an SMC instruction
to forward the request from the application to TDC.
(3) Configure 
ICE
(2)Call SMC
(4) Enter ICE 
(7) Restore 
Rich OS
TDC
(6)Call SMC
(8) Enter Rich 
OS
Rich OS
(Running)
ICE
(Suspended)
Rich OS
(Suspended)
ICE
(Running)
(1) System Call
(5) System Call
APP:
Normal Code
Secure Code
Normal Code
Fig. 7: Switching between Rich OS and ICE
When secure code needs to be executed, the SMC system
call is triggered to make the system enter the TDC in the
secure domain, and the code indexed by the SMC offset (which
is 0x8) in the exception vector table of the monitor mode is
invoked. The integrity of ICE code is checked by verifying the
signature generated by its developing certiﬁcate. The signature
veriﬁcation algorithm, RSA in our prototype, is implemented
in TDC. The validity of the developing certiﬁcate is ensured
by SRK HASH eFUSE. Next, TDC proceeds the switching
process through following operations.
1)
Backing up the translation tables, the exception vector
table, and related registers used by the Rich OS. TDC
overwrites the translation table to include the memory
map of ICE; the start address of ICE’s exception
vector table is written into the Non-secure Vector
Base Address Register. Then, only the interrupts
required by the ICE are enabled while others are
masked off in the TZIC.
Verifying the signature of the secure code with RSA
algorithm. Loading the secure code into ICE and
generating the security attestation of ICE execution
with TDC’s private key.
Switching the system back into the normal domain
to run the secure code in its ICE.
Resuming the Rich OS. At the end of the secure code,
the SMC system call will be called again to switch
the system into TDC, which cleans up CPU registers
and resumes the Rich OS.
2)
3)
4)
With the interrupt control in the TZIC, the execution of ICE
will not be intercepted by unnecessary interrupts. The desired
interrupts will be handled in the exception vector table of ICE.
Since the Rich OS may hijack the SMC system call to deceive
the user into a fake ICE to perform sensitive transactions, our
prototype uses an LED light that is solely controlled by TDC
on the development board to notify the user if one ICE is
running or not.
D. ICE Development
Our ICE prototype implements a number of basic li-
brary functions for the secure code to call, including a self-
contained cryptographic library that supports RSA signature
and SHA-1 hash, a user interface using LCD touchscreen, and
a network interface based on HUAWEI MC323 CDMA radio
module [21].
code
secure
ICE code is running in the non-secure Supervisor mode,
which allows
running in the non-secure
U ser mode to call system functions by making system calls.
We have deﬁned ﬁve system calls numbered from 1 to 5: (1)
ICE exit call, (2) RSA signature call, (3) SHA-1 hash call, (4)
network interface call, and (5) user interface call. Among the
ﬁve system calls, only the ﬁrst ICE exit call is a must for any
ICE to return to the Rich OS.
The ICE exit call is implemented to call the SMC instruc-
tion to clean up the trace of ICE and resume the Rich OS.
The RSA algorithm is ported from an open-source library
PolarSSL [24]. In our prototype, SHA-1 algorithm uses the
hardware accelerator (SAHARA [13]) on board. The HUAWEI
MC323 CDMA radio module includes a complete TCP/IP
stack, so using AT command, ICE code can easily communi-
cate with a remote server through cellular network. The radio
module is an independent device and its logic code is ﬁxed, so
it cannot be tampered after being deployed on mobile devices.
The user interface call is based on a driver for touchscreen to
display pictures in the format of RGB565 on an 800*480-pixel
screen. It can render any words and pictures ﬁtting into the
screen. When the ICE is running, an interrupt rises as soon as
there is a touch on the screen. The touchscreen driver captures
the interrupt and reads the X-Y coordinates of the touch point.
Figure 8 shows a snapshot of the screen that asks the user
to input a passcode before entering an ICE. In our future
work, we will support additional system functions in ICE, such
as an openGL library and a Wi-Fi driver. Furthermore, more
powerful ICEs can be developed by third-party programmers
and service providers.
372372
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:53:17 UTC from IEEE Xplore.  Restrictions apply. 
TABLE I: TrustICE Switching Time
Operation
Encryption ICE (us)
Interface ICE (us)
From the Rich OS to ICE
From ICE to the Rich OS
527.77
783.47
10611.21
782.96
The time latency for switching from the Rich OS to ICE
includes (1) exiting the Rich OS, (2) loading and verifying
the ICE code, (3) loading and verifying the secure code, (4)
suspending the Rich OS and conﬁguring the ICE, and (5)
entering the ICE. A breakdown of the switching times are
shown in Table II. It spends 0.5 ms to switch from the Rich
OS to the encryption ICE and 10 ms for switching into the
interface ICE. This is because the interface ICE has a larger
code base, which makes the TDC spend more time verifying
its integrity when loading it into the memory. We use the SHA-
1 algorithm to verify the ICE code and the secure code. The
switching time will increase along with the code size of the
ICE and the secure code. However, since ICE is protected by
the watermark when suspended, if we do not worry about ICE
being compromised during its runtime, we can skip the stage
of verifying the ICE code integrity. If so, the switching time
for any ICEs will have a similar value.
TABLE II: Time Breakdown: From the Rich OS to ICE
Operation
Encryption ICE (us)
Interface ICE (us)
exiting the Rich OS
verifying secure code
verifying the ICE
conﬁguring the ICE
entering ICE
total
5.84
9.76
475.85
35.05
1.27
527.77
5.93
9.75
10559.37
34.89
1.27
10611.21
After executing the secure code, the system can switch
from the encryption ICE to the Rich OS in 783.47 us and
switch from the interface ICE to the Rich OS in 782.96 us.
A breakdown of the switching time includes (1) exiting ICE,
(2) restoring the Rich OS and DMA, and (3) entering the Rich
OS. The breakdown results are listed in Table III. Since we
do not need to perform the expensive SHA-1 operations, the
switching time is much smaller than switching from the Rich
OS to one ICE. Moreover, the switching times are almost the
same for different ICEs. Overall, the switching times in both
directions are very small and can barely be perceived by a
user.
TABLE III: Time Breakdown: From ICE to the Rich OS
Operation
exiting ICE
restoring the Rich OS
entering the Rich OS
total
Encryption ICE (us)
Interface ICE (us)
0.49
19.26
763.72
783.47
0.48
19.41
763.07
782.96
B. Performance Comparison between ICE, TDC and the Rich
OS
We compare the performance differences when the system
runs in ICE, TDC, and the Rich OS, respectively. We ﬁrst
373373
Fig. 8: Snapshot of Passcode Input
The secure code can be a code segment of an application
that makes system calls in ICE to request corresponding
services. In this case, the beginning and ending of the secure
code are both marked by SMC system calls. The system call
to mark the beginning of the code is executed in the Rich OS,
and the ending system call is the ICE exit call that is handled
in ICE. An example of secure code is listed in Appendix A.
In the secure code, all privileged functions are implemented
in the ICE. In other words, the secure code cannot rely on the
untrusted Rich OS.
VI. PERFORMANCE EVALUATION
The implementation of TrustICE should satisfy the follow-
ing two performance requirements. First, the switching time
between the Rich OS and one ICE should be small. Second,
the ICE should have small performance impacts on the Rich
OS. We conduct experiments to evaluate the performance on
two ICEs: the encryption ICE includes a self-contained library
for RSA and SHA-1 algorithms and the interface ICE includes
a touchscreen interface and a cellular network interface. For
the encryption ICE, since no interrupts are needed, all the
interrupts are masked. For the interface ICE, only the interrupt
of the 4-wire resistive touchscreen is enabled.
The size of the encryption ICE is 46,424 bytes, and the size
of the interface ICE is 1,050,892 bytes including the display
picture of 1,041,832 bytes. The size of the interface ICE can
be further reduced by compressing the image or choosing a
low-quality picture. We use the performance monitor in the
Cortex-A8 core processor to count the CPU cycles and then
convert the cycles to time by multiplying 1 ns / cycle. We
repeat the experiments 100 times and take the average value.
A. Switching Time
We measure the switching times from the Rich OS to ICE