title:CREDAL: Towards Locating a Memory Corruption Vulnerability with
Your Core Dump
author:Jun Xu and
Dongliang Mu and
Ping Chen and
Xinyu Xing and
Pei Wang and
Peng Liu
CREDAL: Towards Locating a Memory Corruption
Vulnerability with Your Core Dump
Jun Xu†, Dongliang Mu‡†, Ping Chen†, Xinyu Xing†, Pei Wang†, and Peng Liu†
†The Pennsylvania State University, University Park, PA, USA
‡Nanjing University, Nanjing, China
{jxx13,dzm77,pzc10,xxing,pxw172,pliu}@ist.psu.edu
ABSTRACT
After a program has crashed and terminated abnormally, it typically
leaves behind a snapshot of its crashing state in the form of a core
dump. While a core dump carries a large amount of information,
which has long been used for software debugging, it barely serves
as informative debugging aids in locating software faults, particu-
larly memory corruption vulnerabilities. A memory corruption is a
special type of software fault that may lead to manipulation of the
content at a certain memory. As such, a core dump may contain a
certain amount of corrupted data, which increases the difﬁculty in
identifying useful debugging information (e.g., a crash point and
stack traces). Without a proper mechanism to deal with this problem,
a core dump can be practically useless for software failure diagnosis.
In this work, we develop CREDAL, an automatic debugging tool
that employs the source code of a crashing program to enhance
core dump analysis and turns a core dump to an informative aid
in tracking down memory corruption vulnerabilities. Speciﬁcally,
CREDAL systematically analyzes a potentially corrupted core dump
and identiﬁes the crash point and stack frames. For a core dump
carrying corrupted data, it goes beyond the crash point and stack
trace. In particular, CREDAL further pinpoints the variables hold-
ing corrupted data using the source code of the crashing program
along with the stack frames. To assist software developers (or secu-
rity analysts) in tracking down a memory corruption vulnerability,
CREDAL also performs analysis and highlights the code fragments
corresponding to data corruption.
To demonstrate the utility of CREDAL, we use it to analyze 80
crashes corresponding to 73 memory corruption vulnerabilities
archived in Offensive Security Exploit Database. We show that,
CREDAL can accurately pinpoint the crash point and (fully or par-
tially) restore a stack trace even though a crashing program stack
carries corrupted data. In addition, we demonstrate CREDAL can
potentially reduce the manual effort of ﬁnding the code fragment
that is likely to contain memory corruption vulnerabilities.
Keywords
Core Dump; Memory Corruption; Vulnerability Analysis
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from permissions@acm.org.
CCS’16, October 24-28, 2016, Vienna, Austria
c(cid:13) 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978340
1.
INTRODUCTION
Despite best efforts of software developers, software inevitably
contains defects. After a software defect is triggered, and a program
has terminated abnormally, it typically leaves behind a snapshot
of its crashing state. In general, the snapshot of a crashing state is
organized in the form of a core dump, which oftentimes contains the
crashing program stack, the ﬁnal values of local and global variables,
and the ﬁnal values of processor registers.
Since a core dump carries certain clues as to a program crash,
commercial software vendors oftentimes utilize it to facilitate failure
diagnosis and classify crashes likely caused by the same defect [20,
21, 24]. For example, Microsoft’s tool RETracer [19] parses a
core dump and extracts information such as the crash point and the
crashing stack. Then, it employs a backward taint analysis technique
to infer program faults and further triages program crashes. While
shown to be effective in spotting the function that contributes to a
crash, existing technical approaches (e.g., [19, 21]) are less likely to
be effective in identifying some program faults, particularly memory
corruption vulnerabilities (e.g., buffer overﬂow and use after free).
A memory corruption vulnerability is a special type of fault in
software that could lead to unintentional modiﬁcation to the content
at a memory location and thus compromise the data dependency
of a running program. As such, a core dump may carry a certain
amount of corrupted data when a memory corruption vulnerability
is triggered and incurs a program crash. Since corrupted data can
be anywhere in the memory, it leaves a signiﬁcant challenge for
identifying debugging information. In attempting to exploit a buffer
overﬂow vulnerability, for example, an attacker typically overwrites
adjacent memory locations. As we will show later in Section 2, this
may signiﬁcantly increase the difﬁculty in identifying a stack trace
and even spotting the crash point. Since a crash point and stack
trace are the most useful information for failure diagnosis, without
a proper mechanism to locate them in a core dump, a core dump is
practically useless.
In fact, existing core dump analysis techniques can barely serve
as informative debugging aids in locating a memory corruption vul-
nerability, even though there is no impediment in tracking down the
crash point and stack traces of a crashing program. As is mentioned
above, a memory corruption vulnerability allows an attacker to com-
promise the data dependency of a running program. In facilitating
failure diagnosis, existing techniques typically perform backward
program analysis starting from the crash point, and assume the in-
tegrity of a crashing stack is not compromised (e.g., [19, 26]). When
such techniques intersect corrupted data, therefore, they may termi-
nate unexpectedly and produce no information other than the crash
point and stack traces of a crashing program.
In this work, we develop CREDAL, an automatic debugging tool
to assist software developers in tracking down software faults, par-
529Since the state of the program at the crash is an almost-necessary
starting point [30] and stack traces can potentially narrow down the
list of candidate ﬁles that are likely to contain software defects [38],
CREDAL ﬁrst identiﬁes the crash point and attempts to restore the
stack trace of a crashing program.
In general, it is easy to identify a crash point. When a program
has crashed and terminated unexpectedly, the ﬁnal value of the pro-
gram counter typically indicates the crash point. However, memory
corruption may manipulate the program counter, making it point
to an invalid instruction. (e.g., overwriting a return address on the
stack with a non-executable memory location). To address this prob-
lem, CREDAL checks the validity of the program counter. For the
invalid program counter, CREDAL restores its value by analyzing
the remnants on the stack. More speciﬁcally, CREDAL ﬁrst attempts
to identify the function which was just called but silently returned
before the crash, in that this function carries the information about
its parent (i.e., the crash function). Using this function, CREDAL
then locates the crash function as well as the crash point within
it. In recovering the crashing stack, CREDAL makes conservative
inference using the restored program pointer along with call frame
information [18].
As is discussed above, memory corruption can manipulate the
content at a certain memory location, which may result in the viola-
tion of data dependency. Intuition suggests that highlighting data
dependency mismatches seems informative for failure diagnosis. As
a result, we further augment CREDAL with the ability of specifying
data dependency mismatches at the source code level. In particular,
CREDAL identiﬁes the variables – the values of which in memory
mismatch the data dependency of the crashing program – and high-
lights the source code corresponding to the mismatches. Technically
speaking, CREDAL ﬁrst constructs an inter-procedural control ﬂow
graph based on the stack traces restored as well as the source code of
the crashing program. Then, it performs inter-procedural points-to
analysis and reaching deﬁnition analysis to discover the mismatches
in variable values and pinpoint the code fragments corresponding to
the mismatch.
We implemented CREDAL for Linux systems on x86 platform. To
the best of our knowledge, CREDAL is the ﬁrst automatic tool that
can perform core dump analysis in the condition where a core dump
contains a certain amount of corrupted data. We manually analyzed
80 crashes corresponding to 73 memory corruption vulnerabilities
collected from Offensive Security Exploit Database Archive [14],
and compared our manual analysis with the analysis conducted
by CREDAL. We observed that CREDAL can accurately identify a
crash point and (fully or partially) recover stack traces from a core
dump. In addition, we demonstrated that CREDAL can potentially
increase the utility of a core dump. For about 80% of the crashes,
CREDAL can narrow down vulnerability diagnosis within a couple
of functions. For about 50% of the crashes, CREDAL can bound
diagnosis efforts in only tens of lines of code.
ticularly memory corruption vulnerabilities. Our goal is not to let
CREDAL pinpoint a memory corruption vulnerability, but rather to
turn a core dump to an informative aid in locating the vulnerability.
To deal with the challenges that memory corruption introduces to
core dump analysis, technically, CREDAL leverages the source code
of the crashing program to enhance core dump analysis.
In summary, we make the following contributions.
• We designed CREDAL, an automatic debugging tool that lever-
ages the source code of the crashing program to enhance core
dump analysis and provides useful information for software
failure diagnosis.
• We implemented CREDAL on Linux for facilitating software
developers (or security analysts) to locate software faults,
particularly memory corruption vulnerabilities.
• We demonstrated the utility of CREDAL in facilitating mem-
ory corruption vulnerability diagnosis by using 80 crashes
attributable to 73 memory corruption vulnerabilities.
The rest of the paper is organized as follows. Section 2 deﬁnes the
problem scope of our research. Section 3 presents the overview of
CREDAL. Section 4 and 5 describe the design and implementation
of CREDAL in detail. Section 6 demonstrates the utility of CREDAL.
Section 7 surveys related work followed by some discussion on
CREDAL in Section 8. Finally, we conclude this work in Section 9.
2. PROBLEM SCOPE
In this section, we deﬁne the problem scope of our research. We
ﬁrst discuss our threat model. Then, we demonstrate how a memory
corruption vulnerability can undermine the utility of a core dump
with a real world example.
2.1 Threat Model
Our research focuses on diagnosing the crash of a process. There-
fore, we exclude the program crashes that do not incur the unex-
pected termination of a running process (e.g., Java program crashes).
Because our research diagnoses a process crash through core dump
analysis, we further exclude the process crashes that typically do
not produce core dumps. Up to and including Linux 2.2, the default
action for CPU time limit exceeded, for example, is to terminate the
process without a core dump [11].
As is mentioned above, our research is motivated by memory
corruption. As a result, we only deal with process crashes caused
by memory corruption vulnerabilities. Although many software
defects can trigger a process crash, and CREDAL can provide useful
information for diagnosing any process crashes, the software defects
that can trigger a program crash but not result in memory corruption
are out of our research scope. In general, such defects include buffer
over-read, null pointer accesses, uninitialized variables, and out-of-
memory errors. We believe this is a realistic threat model because (1)
it covers all the memory corruption vulnerabilities and (2) techniques
to analyze excluded software defects have been proposed by other
researchers and can be combined with CREDAL.
Note that we design CREDAL as a debugging tool to analyze
crashes triggered by memory corruption during random exercises.
We do not assume CREDAL can act as a defense meant to work in an
adversarial setting where the attackers can actively prevent ofﬂine
debugging.
2.2 Motivating Example
We use a real world vulnerability – CVE-2013-2028 [2] – as
a typical example to illustrate how and why a memory corruption
vulnerability can compromise the integrity of a program counter and
tamper data on the stack, making a core dump futile for software
debugging.
Table 1 shows a code fragment from Nginx-1.4.0. As is de-
scribed in CVE-2013-2028, this code fragment can manipulate a
signed integer and trigger a stack based overﬂow. More speciﬁcally,
an attacker can craft a request and thus manipulate the value of
r->headers_in.content_length_n. When handling this
speciﬁcally crafted request, as is shown in line 15, a worker pro-
cess compares the value held in r->headers_in.content_-
length_n with a constant, chooses the minimum and assigns it
to variable size. Then, the worker process uses this variable to
determine the number of bytes it needs to copy from memory area
r->connection to memory area buffer (see line 17).
5301
2
3
4
5
6
7
8
9