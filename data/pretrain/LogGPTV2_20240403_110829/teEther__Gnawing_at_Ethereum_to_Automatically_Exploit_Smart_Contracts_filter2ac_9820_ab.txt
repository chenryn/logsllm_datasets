the severity of the attacks found by our tool TEETHER.
2.5 Ethical Considerations
On the one hand, we believe that raising awareness of
critical vulnerabilities in smart contracts is fundamen-
tally important to maintain the trust of their manifold
users. Our methodology thus represents a step forward
and allows users to check their contracts for critical ﬂaws
that may lead to ﬁnancial loss. On the other hand, de-
scribing a detailed methodology, and in particular, re-
leasing a tool to automatically ﬁnd and exploit ﬂaws in
contracts may ask for abuse. Yet we argue this is the
right way of going forward, as “security by obscurity”
has proven ineffective since long. Furthermore, espe-
cially the fully automated creation of exploits allows to
easily validate whether the found vulnerabilities are ac-
tually real—an important step to show the effectiveness
and accuracy of any bug ﬁnding mechanism.
A fundamental downside of
largely anonymous
blockchain networks like Ethereum, however, is that we
cannot reach out to owners of vulnerable contracts. This
is in stark contrast to responsible disclosure processes in
open-source software projects that have dedicated points
of contact. For Ethereum accounts and contracts, such
contacts do not exist. We discussed several approaches to
tackle this problem, including but not limited to (i) public
disclosure of all vulnerable accounts such that they can
remedy the problem (yet revealing exactly to the public
which contracts are vulnerable); (ii) temporarily trans-
fer (“steal”) money from vulnerable contracts into secure
contracts until the owner has ﬁxed the problem (yet ren-
dering the old contract unavailable, causing money loss
due to transaction fees, and being illegal). In the end, we
deemed none of these options optimal, and decided to
refrain from mentioning particular vulnerable contracts
in public. If contract owners are in doubt and can prove
their ownership to us, we will responsibly disclose the
generated exploit to them. We aim to release TEETHER
180 days after publication of this paper, to give contract
owners sufﬁcient time ﬁxing their contracts until others
can easily reproduce our work by re-executing our tool.
3 Smart Contract Vulnerabilities
Smart contracts usually enforce certain control over who
is allowed to interact with them. A particularly impor-
tant guarantee is that contracts only allow “authorized”
Ethereum accounts to receive coins that are stored in the
contract. In this context, a contract is vulnerable, if it al-
lows an attacker to transfer Ether from the contract to an
attacker-controlled address. From such vulnerable con-
tracts, an attacker can steal all (or at least parts of) the
Ether stored in them, which can result in a total loss of
value for the contract owner.
We now describe how one can identify such vulnera-
bilities in Ethereum contracts. Our idea is to statically
analyze a contract’s code to reveal critical code parts that
might be abused to steal Ether stored in a contract. To
this end, we describe how the aforementioned vulnera-
bilities map to EVM instructions.
3.1 Critical Instructions
We identify four critical EVM instructions, one of which
must necessarily be executed in order to extract Ether
from a contract. These four instructions fall into two cat-
egories: Two instructions cause a direct transfer, and two
1320    27th USENIX Security Symposium
USENIX Association
instructions allow arbitrary Ethereum bytecode to be ex-
ecuted within a contract’s context.
1 PUSH20 
2 SELFDESTRUCT
3.1.1 Direct value transfer
Two of the EVM instructions described in Ethereum’s
formal speciﬁcation [25] allow the transfer of value to
a given address: CALL and SELFDESTRUCT.3 The CALL
instruction performs a regular transaction, with the fol-
lowing stack arguments:
1. gas – the amount of gas this transaction may con-
sume
2. to – the beneﬁciary of the transaction
3. value – the number of Wei (i.e., 10−18 Ether) that
will be transferred by this call
4.-7. in offset, in size, out offset, out size –
memory location and length of call data respectively
returned data.
Thus, if an attacker can control the second stack argu-
ment (to) when a CALL instruction is executed with a
non-zero third stack argument, they can cause the con-
tract to transfer value to an address under their control.
The SELFDESTRUCT instruction is used to terminate a
contract. This will cause the contract to be deleted, al-
lowing no further calls to this contract. SELFDESTRUCT
takes a single argument – an address where all remaining
funds of this contract will be transferred to.
If an at-
tacker can cause execution of a SELFDESTRUCT instruc-
tion while controlling the topmost stack element, he can
obtain all the contract’s funds as well as cause a perma-
nent Denial-of-Service of this contract.
3.1.2 Code injection
While CALL and SELFDESTRUCT are the only two in-
structions that allow an attacker to directly transfer funds
from a contract to a given address, this does not imply
that contracts lacking these two instructions are not vul-
nerable.
In order to facilitate libraries and code-reuse,
the EVM provides the CALLCODE and DELEGATECALL in-
structions, which allow the execution of third party code
in the context of the current contract. CALLCODE closely
resembles CALL, with the only exception that it does not
perform a transaction to to, but rather to the current con-
tract itself as if it had the code of to.
the bene-
ﬁciary of the new transaction remains the same, but it
will be processed using to’s code. DELEGATECALL does
I.e.
3Additionally, the CREATE instruction allows to create a new con-
tract and transfer value to it. However, this would require an attacker to
have control over the resulting contract to receive the coins. Therefore,
we will not consider CREATE for the remainder of this work.
Figure 2: EVM “shellcode”
the same, but persists the original values of sender and
value, i.e., instead of creating a new internal transaction,
it modiﬁes the current transaction and “delegates” han-
dling to another contract’s code. Consequently, value is
omitted from the arguments of DELEGATECALL.
If an attacker controls the second stack element (to)
of either CALLCODE or DELEGATECALL, they can “inject”
arbitrary code into a contract. By deploying the snippet
from Figure 2 to a new contract, and subsequently is-
suing a CALLCODE or DELEGATECALL in the vulnerable
contract to this new contract, the original contract can be
destructed and all funds transferred to the attacker.
3.1.3 Vulnerable State
Summarizing, this systematic analysis of the Ethereum
instructions allows us to precisely deﬁne when a contract
is in a vulnerable state:
Deﬁnition 1 (Critical Path). A critical path is a potential
execution trace that either
1. leads to the execution of a CALL instruction with a
non-zero third stack element where the second stack
argument can be externally controlled,
2. leads to the execution of a SELFDESTRUCT instruc-
tion where the ﬁrst stack argument can be externally
controlled, or
3. leads to the execution of either a CALLCODE or
DELEGATECALL instruction where the second stack
argument can be externally controlled.
Deﬁnition 2 (Vulnerable State). A contract is in a vul-
nerable state, if a transaction can lead to the execution of
a critical path.
We will call a transaction that exploits a contract in
vulnerable state by one of the critical instructions as a
critical transaction.
3.2 Storage
While it is obvious that a contract in vulnerable state is
vulnerable according to our intuition that attackers can
steal Ether, the converse it not necessarily true. Con-
sider, for example, the contract given in Figure 3. As
long as vulnerable is set to false, this contract is not
in a vulnerable state, as the transfer-statement—and
USENIX Association
27th USENIX Security Symposium    1321
1 contract Stateful{
2
3
4
5
6
7
8
9
10
}
}
bool vulnerable = false;
function makeVulnerable(){
}
function exploit(address attacker){
vulnerable = true;
require(vulnerable);
attacker.transfer(this.balance);
Figure 3: Stateful contract
its corresponding CALL instruction—cannot be reached
due to the preceding require. Only after a call to
makeVulnerable the vulnerable variable is set and a
vulnerable state is reached. Yet, intuitively, this contract
is vulnerable. We thus have to extend our deﬁnition to
also include a notion of state that captures modiﬁcations
made to a contract’s storage.
The only instruction that allows to modify storage is
SSTORE. A transaction that performs a storage modiﬁca-
tion therefore always executes a SSTORE instruction. We
can therefore deﬁne state-changing transactions.
Deﬁnition 3 (State Changing Path). A state changing
path is a potential execution trace that contains at least
one SSTORE instruction.
Deﬁnition 4 (State Changing Transaction). A transac-
tion is state changing if its execution trace is a state
changing path.
Combining this with Deﬁnition 2 allows us to give the
following deﬁnition
Deﬁnition 5 (Vulnerable). A contract is vulnerable if
there exists a (possibly empty) sequence of state chang-
ing transactions that lead to a vulnerable state.
From this it immediately follows that a successful ex-
ploit always consists of a sequence of state changing
transactions followed by a critical transaction.
4 Automatic Exploitation
In this section we present TEETHER, our tool for auto-
matic exploit generation for smart contracts.
4.1 Overview
Figure 4 shows the overall architecture of TEETHER. In
a ﬁrst step, the CFG-recovery module disassembles the
EVM bytecode and reconstructs a control ﬂow graph
(CFG). Next, this CFG is scanned for critical instructions
EVM bytecode
CFG recovery
critical instructions
path generation
constraint generation
exploit generation
exploit
Figure 4: Architecture of TEETHER
Figure 5: An example CFG with dependent edges
and for state changing instructions. The path generation
module explores paths from the root of the CFG lead-
ing to these instructions, from which the constraint gen-
eration module creates a set of path constraints through
symbolic execution. Finally, the exploit generation mod-
ule solves the combined constraints of critical paths and
state changing paths to produce an exploit.
4.2 CFG Recovery
Reconstructing a control ﬂow graph from EVM byte-
code is a non-trivial task. This is due to the fact that the
EVM only provides control ﬂow instructions with indi-
rect jumps. Both the conditional JUMPI and the uncondi-
tional JUMP read the jump target from the top-most stack
element. While the jump target can be trivially inferred
1322    27th USENIX Security Symposium
USENIX Association
0:   0: 34 CALLVALUE    1: 60 PUSH1 0d   3: 57 JUMPI 4:   4: 60 PUSH1 0b   6: 60 PUSH1 00   8: 60 PUSH1 17   a: 56 JUMP 0d:   d: 5b JUMPDEST    e: 60 PUSH1 15  10: 60 PUSH1 ff  12: 60 PUSH1 17  14: 56 JUMP 017:  17: 5b JUMPDEST   18: 50 POP   19: 56 JUMP 4b:   b: 5b JUMPDEST    c: 00 STOP d15:  15: 5b JUMPDEST   16: 00 STOP 4din some cases, such as PUSH2 ; JUMP, it be-
comes less obvious in other cases. For example, consider
the JUMP instruction at address 19 in Figure 5. Here, the
JUMP instruction is used similar to x86’s ret instruction,
to resume execution at a “return address” that the caller
pushed on the stack before the function call.
To address this, TEETHER uses backward slicing to
iteratively reconstruct the CFG. Initially, the CFG con-
tains only trivial edges, i.e., those matching the above
pattern as well as fall-through cases for JUMPI. All other
JUMP and JUMPI instructions are marked as unresolved.
Next, an unresolved JUMP or JUMPI is selected and the
set of (path-sensitive) backward slices of its jump target
is computed.
If a full backward slice can be found, it
is executed to compute the jump target, the newly found
edge is added to the CFG, and the corresponding jump
instruction marked as resolved. Since introduction of a
new edge can lead to possibly new backward slices of
jumps within the newly connected subtree, all JUMP and
JUMPI instructions in this subtree are again marked as
unresolved. This process is repeated until no new edges
are found and all jump instructions marked as resolved.
two backward slices
can be found for the JUMP instruction at address 19,
(PUSH1 0b) and (PUSH1 15), which allows to introduce
two out-edges for basic block 17, 17 → b and 17 → 15.
In the example in Figure 5,
4.2.1 Dependent edges
Another problem that arises from indirect jumps is the
problem that a path in the CFG does not necessarily cor-
respond to a valid execution trace. E.g. the path 0 → 4
→ 17 → 15, while seemingly plausible from the CFG,
can never occur in an actual execution, as the edge 17 →
15 can only be taken if 17 was entered from d.
To reduce the number of invalid paths considered in
further analyses, TEETHER uses an approach we call de-
pendent edges. For this, edges are annotated with a basic
block-level summary of their backward slices. In a for-
wards exploration, a path may be extended by an edge
iff one of its annotations is fully contained in the path.
Referring to Figure 5, the path 0 → 4 → 17 may only
be extended via 17 → b. Likewise, in a backwards ex-
ploration these annotations form a set of path require-
ments, restricting the exploration to subpaths that can
still reach all required basic blocks. For example, a back-
wards analysis starting from 15 → 17 has collected the
requirement set {b} and may not take the back-edge 17
→ 4 as b is not an ancestor of 4.
4.3 Path Generation
The resulting CFG is then scanned for CALL, CALLCODE,
DELEGATECALL, and SELFDESTRUCT instructions. For
each found instruction, the set of backward slices of
its critical argument is computed. As we require that
this argument is potentially attacker controlled, slices
are then ﬁltered for those containing instructions whose
results can be directly (ORIGIN, CALLER, CALLVALUE,
CALLDATALOAD, CALLDATASIZE, CALLDATACOPY) or in-
directly (SLOAD, MLOAD) controlled by an attacker.
Each of the remaining slices deﬁnes an instruction
subsequence of a critical path. To ﬁnd critical paths,
TEETHER explores paths using A* [15], where the cost
of a path is deﬁned as the number of branches this path
traverses in the CFG. As every branch in the CFG cor-
responds to an additional path constraint, this allows
TEETHER to explore less-constrained paths ﬁrst. This
captures the intuition that a path with fewer constraints
is easier to satisfy. To focus on critical paths only, after
every step we check whether all remaining instructions
of at least one critical slice can still be reached from the
current path. If no critical slice can be reached in full,
further exploration of the path is discarded.
State changing paths are found in a similar fashion by
searching for SSTORE instructions. As a state change can
be useful for an attacker even without controlling the ad-
dress or value written (e.g., Figure 3), no backward slices
need to be computed in this case. Thus, the A* search
only has to check whether a SSTORE instruction can be
reached on the current path.
4.4 Constraint Generation
The constraint generation module runs in lockstep with
the path generation. Once a path is found, the path con-
straint generation module tries to execute the path sym-
bolically in order to collect a set of path constraints.
To this end, TEETHER uses a symbolic execution en-
gine based on Z3 [13]. Fixed-size elements, such as
the call value or the caller’s address are modelled us-
ing ﬁxed-size bitvector expressions, variable-length ele-
ments, such as the call data, the memory, and the storage
are modeled using Z3’s array expressions.
Whenever a conditional branch (JUMPI) is encoun-
tered whose condition µs[1] is a symbolic expression,
both the jump target and the fall through target are com-
pared to the next address deﬁned by the given path,
and a new constraint of the form µs[1] (cid:54)= 0 respectively
µs[1] = 0 is added accordingly.
4.4.1
Infeasible Paths
Not all paths generated by the path generation module
necessarily correspond to feasible execution traces. Con-
sider for example the code given in Figure 6. Here the
path generation module will eventually output the path
1 → 2 → 4 → 5 → 6. However, when executing this
USENIX Association
27th USENIX Security Symposium    1323
1 int x = 0;
2 if(msg.value > 0){
3
x = 1;
4
5 if(x!=0){
6
7
}
msg.sender.transfer(this.balance);
}
cute a SHA3 instruction, we introduce a new symbolic