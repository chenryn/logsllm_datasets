10.2 Manual SQL Exploitation
This Learning Unit covers the followiing Learning Objectives:
z
• Manually identify SQL injection vulnerabilities
• Understand UNION SQDLi payloads
• Learn about Error SQLi payloads
• Understand Blind SQLi payloads
Having covered the basic SQL syntax of two major database distributions, let’s explore how to
identify and exploit SQL injection vulnerabilities.
SQL injections are often discovered and abused using automated tools such as sqlmap.458
Nevertheless, we should first understand how to manually trigger a vulnerability to grasp its
mechanics.
10.2.1 Identifying SQLi via Error-based Payloads
We can start our vulnerability analysis using the PHP code we inspected previously:
Listing 189 - PHP Code Vulnerable to SQL injection
Since both the uname and password parameters come from user-supplied input, we can control
the $sql_query variable and craft a different SQL query.
In some cases, SQL injection can lead to authentication bypass, which is the first exploitation
avenue we’ll explore.
By forcing the closing quote on the uname value and adding an OR =1=1 statement followed by a -
- comment separator and two forward slashes (//), we can prematurely terminate the SQL
statement. The syntax for this type of of comment requires two consecutive dashes followed by
at least one whitespace character.
y
In this section’s examples we are trailing these comments with two double slashes. This provides
visibility on our payload, and also adds some protection against any kind of whitespace
k
truncation the web application might employ.
offsec' OR 1=1 -- // s
Listing 190 - Testing for SQLi Authentication Bypass
o
The SQL query assigned to the $sql_query variable results in the SQL query below being
forwarded from the PHP application to the MySQL server.
n
SELECT * FROM users WHERE user_name= 'offsec' OR 1=1 --
Listing 191 - Injected SQL statement
i
Since we have appended an OR statement that will always be true, the WHERE clause will return
z
the first user id present in the database, whether or not the user record is present. Because no
other checks are implemented in the application, we are able to gain administrator privileges by
D
circumventing the authentication logic.
To experiment with this attack against a real application, we can browse to http://192.168.50.16
from our local Kali machine, enter “offsec” and “jam” in the respective username and password
fields, and click Submit.
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 292
Made in Morocco
Penetration Testing with Kali Linux
y
k
s
o
n
i
z
D
Figure 147: Testing for SQLi Authentication Bypass 1
Because the offsec user’s credentials are invalid, we receive an Invalid Password error message.
As a next step, let’s try to insert any special character inside the Username field to test for any
interaction with the underlying SQL server. We’ll append a single quote to the username and click
Submit again.
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 293
Made in Morocco
Penetration Testing with Kali Linux
y
k
s
o
n
i
z
D
Figure 148: Testing for SQLi Authentication Bypass 2
We receive an SQL syntax error this time, meaning we are able to interact with the database.
SQL injection is considered in-band when the vulnerable application provides the
result of the query along with the application-returned value. In this scenario,
we’ve enabled SQL debugging inside the web application; however, most
production-level web applications won’t show these error messages because
revealing SQL debugging information is considered a security flaw.
Given the above conditions, let’s test the authentication payload we discussed earlier by pasting it
inside the Username field.
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 294
Made in Morocco
Penetration Testing with Kali Linux
Figure 149: SQLi payload inside the ‘Username’ fielyd
Now we’ll click the Submit button again.
k
s
o
n
i
z
D
Figure 150: Testing for SQLi Authentication Bypass 2
Nice! This time we received an Authentication Successful message, meaning that our attack
succeeded.
To further expand on our attack, we could also take advantage of the error-based payload by
enumerating the database directly.
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 295
Made in Morocco
Penetration Testing with Kali Linux
By prematurely terminating the implied SQL query again, we can inject an arbitrary second
statement:
' or 1=1 in (select @@version) -- //
Listing 192 - Error-based payload
In this case, we want to retrieve the MySQL version via the @@version directive.
MySQL accepts both version() and @@version statements.
We can now paste the injection payload in the Username field and verify the returned output.
y
k
s
o
n
i
z
D
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 296
Made in Morocco
Penetration Testing with Kali Linux
y
k
s
o
n
i
z
D
Figure 151: Testing for Error-based payload
The running MySQL version (8.0.28) is included along with the rest of the web application
payload. This means we can query the database interactively, similar to how we would use an
administrative terminal.
As it seems we have unbounded control over database queries, let’s try to dump all the data
inside the users table.
' OR 1=1 in (SELECT * FROM users) -- //
Listing 193 - Attempting to retrieve the Users table
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 297
Made in Morocco
Penetration Testing with Kali Linux
After inserting the value into the Username field and submitting the query, we receive the
following error:
y
k
s
o
n
i
z
D
Figure 152: Testing for Error-based payload
This means that we should only query one column at a time. Let’s try to grab only the password
column from the users table.
' or 1=1 in (SELECT password FROM users) -- //
After submitting the payload, we receive several errors along with values resembling MD5
password hashes.
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 298
Made in Morocco
Penetration Testing with Kali Linux
y
k
s
o
n
Figure 153: Retrieving Users Hashes
i
This is somewhat helpful, as we managed to retrieve all user password hashes; however, we don’t
z
know which user each password hash corresponds to. We can solve the issue by adding a
WHERE clause specifying which user’s password we want to retrieve, in this case admin.
D
' or 1=1 in (SELECT password FROM users WHERE username = 'admin') -- //
Listing 194 - Improving our SQLi error-based payload
Once we submit the payload, we receive the user’s password along with the usual error message:
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 299
Made in Morocco
Penetration Testing with Kali Linux
y
k
s
o
Figure 154: Retrieving Users Hashes
n
Nice! We managed to predictably fetch hashed user credentials via the error-based SQL injection
vulnerability we discovered.
i
10.2.2 UNION-based zPayloads
Whenever we’re dealing with in-band SQL injections and the result of the query is displayed along
D
with the application-returned value, we should also test for UNION-based SQL injections.
The UNION459 keyword aids exploitation because it enables execution of an extra SELECT
statement and provides the results in the same query, thus concatenating two queries into one
statement.
For UNION SQLi attacks to work, we first need to satisfy two conditions:
1. The injected UNION query has to include the same number of columns as the original query.
2. The data types need to be compatible between each column.
To demonstrate this concept, let’s test a web application with the following preconfigured SQL
query:
$query = "SELECT * from customers WHERE name LIKE '".$_POST["search_input"]."%'";
Listing 195 - Vulnerable SQL Query
459 (Refsnes Data), https://www.w3schools.com/sql/sql_union.asp
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 300
Made in Morocco
Penetration Testing with Kali Linux
The query fetches all the records from the customers table. It also includes the LIKE460 keyword to
search any name values containing our input that are followed by zero or any number of
characters, as specified by the percentage (%) operator.
We can interact with the vulnerable application by browsing to http://192.168.50.16/search.php
from our Kali machine. Once the page is loaded, we can click SEARCH to retrieve all data from the
customers table.
y
k
s
o
n
i
z
D
Figure 155: Loading the Customer Search Portal
Before crafting any attack strategy, we need to know the exact number of columns present in the
target table. Although the above output shows that four columns are present, we should not
assume based on the application layout, as there may be extra columns.
To discover the correct number of columns, we can submit the following injected query into the
search bar:
' ORDER BY 1-- //
Listing 196 - Verifying the exact number of columns
The above statement orders the results by a specific column, meaning it will fail whenever the
selected column does not exist. Increasing the column value by one each time, we’ll discover that
the table has five columns, since ordering by column six returns an error.
460 (Refsnes Data), https://www.w3schools.com/sql/sql_like.asp
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 301
Made in Morocco
Penetration Testing with Kali Linux
Figure 156: Finding the Exact Number of Columns
With this information in mind, we can attempt our first attack by enumerating the current
database name, user, and MySQL version.
y
%' UNION SELECT database(), user(), @@version, null, null -- //
Listing 197 - Enumerating the Database via SQL UkNION Injection
Since we want to retrieve all the data from the customers table, we’ll use the percentage sign
followed by a single quote to close the search parametesr. Then, we begin our injected query with
a UNION SELECT statement that dumps the current database name, the user, and the MySQL
version in the first, second, and third columns, respoectively, leaving the remaining two null.
n
i
z
D
Figure 157: Enumerating the Database
After launching our attack, we’ll notice that the username and the DB version are present on the
last line, but the current database name is not. This happens because column 1 is typically
reserved for the ID field consisting of an integer data type, meaning it cannot return the string
value we are requesting through the SELECT database() statement.
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 302
Made in Morocco
Penetration Testing with Kali Linux
The web application is explicitly omitting the output from the first column
because IDs are not usually useful information for end users.
With this in mind, let’s update our query by shifting all the enumerating functions to the right-most
place, avoiding any type mismatches.
' UNION SELECT null, null, database(), user(), @@version -- //
Listing 198 - Fixing the Injected UNION Query
Since we already verified the expected output, we can omit the percentage sign and rerun our
modified query.
y
k
s
o
n
i
z
Figure 158: Fixing the SQL Query
D
This time, all three values returned correctly, including offsec as the current database name.
Let’s extend our tradecraft and verify whether other tables are present in the current database.
We can start by enumerating the information schema461 of the current database from the
information_schema.columns table.
We’ll attempt to retrieve the columns table from the information_schema database belonging to
the current database. We’ll then store the output in the second, third, and fourth columns, leaving
the first and fifth columns null.
' union select null, table_name, column_name, table_schema, null from
information_schema.columns where table_schema=database() -- //
Listing 199 - Retrieving Current Database Tables and Columns
Running our new enumeration attempt results in the below output:
461 (Oracle, 2022), https://dev.mysql.com/doc/refman/8.0/en/information-schema-introduction.html
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 303