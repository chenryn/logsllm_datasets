simplifies the proofs: in [6], each pass must be independently proved
to be both correct and CCT-preserving. Instead, each pass is just in-
dependently proved to be correct in our work, and CCT-preserving
proof is done only once.
The FACT compiler [10] transforms an information flow secure
program into cryptographic constant-time (CCT) programs that are
protected against cache-based timing side-channels. Motivated by
Spectre and other recent micro-architectural attacks, recent works
explore compiler-based mitigations under speculative execution.
Guarnieri and Patrignani [16] shows (in)security of several common
compiler-based mitigation techniques, including fence insertion and
speculative load hardening, against these attacks. Their analysis is
based on speculative variants of CCT. Vassena et al. [22] designs and
implements a provably sound automated compiler-based method
for mitigating the BCB (bound check bypass) variant of Spectre
attacks. The correctness of their approach is not machine-checked.
Secure compilation. Abate et al. [1] provides a systematic classi-
fication and comparison of the different notions of secure compila-
tion. This work is primarily foundational; it does not target any spe-
cific compiler and does not address the problem of deploying secure
compilers. To address the latter problem, Namjoshi and Tabajara
[17] develop a translation validation framework for hyperproper-
ties, and illustrate its application to several common optimizations.
The interaction between information-flow and compilation has
been studied extensively. One line of work considers information
flow types preserving compilers, see e.g. [8, 11]. In short, these
works define information-flow type systems for source and target
programs and show that typable source programs are transformed
into typable target programs. Sison and Murray [21] follow a dif-
ferent approach: they define an information flow type system for
source programs and develop secure refinement methods to prove
that typable source programs are compiled into programs that sat-
isfy (timing-sensitive) non-interference. Their proof is mechanized
using the Isabelle proof assistant.
Cost. There is a vast body of work on automatically analyzing
program efficiency. In particular, the fields of WCET (Worst-Case
Execution Time) and cost analyses aim to provide estimates (upper
and lower bounds) of program execution. These estimates use a
broad range of cost models. One of the simplest models is the in-
struction counting model considered in this paper. However, many
works in the WCET community also consider very precise cost
models that account for underlying micro-architectural features.
Analyses are either carried out on source programs (prevailing for
cost analysis) and low-level programs (prevailing for WCET), but
only a few works connect the costs of source and target programs.
One of the first works in this direction is [13], which develops a time
bounds-certifying compiler from a safe dialect of C to assembly.
However, their work focuses on upper rather than exact bounds
for assembly programs and follows the principles of certifying
compilation. In contrast, our work is more focused on transferring
the results of source-level cost analysis. In this sense, our work is
more closely related to the CerCo compiler [4], which connects a
cost analysis for source programs with the cost of target programs.
Their work goes beyond the goals of our present study, as their
compiler provides, via annotations in the source program, realistic
estimates of the time and space cost of basic blocks of the target
programs. A similar approach is taken by Carbonneaux et al. [9] to
provide upper bounds on stack usage of assembly programs gen-
erated by the CompCert verified compiler. In a functional setting,
Paraskevopoulou and Appel [18] prove preservation of stack space
by closure conversion, whereas Gómez-Londoño et al. [15] prove a
similar result for the CakeML compiler. To the exception of [13],
all these works support mechanized correctness proofs using proof
assistants.
9 CONCLUSION
We have introduced new tools: structured leakage and leakage
transformers for reasoning about the compilation of non-functional,
quantitative, properties such as cryptographic constant-time and
cost. Using our tools, we have provided the first mechanized proof
that the Jasmin compiler preserves CCT, and a provably correct
method for computing the cost of assembly programs. In the future,
we would like to consider other observational non-interference
properties and richer execution models that accommodate specula-
tive and out-of-order execution.
ACKNOWLEDGMENTS
We thank our shepherd Chris Hawblitzel and the anonymous re-
viewers for their useful suggestions. This work is partially sup-
ported by ONR Grant N00014-19-1-2292 and Project-ANR-18-CE25-
0014.
REFERENCES
[1] Carmine Abate, Roberto Blanco, Deepak Garg, Catalin Hritcu, Marco Patrignani,
and Jérémy Thibault. 2018. Exploring Robust Property Preservation for Secure
Compilation. In Computer Security Foundations 2019. http://arxiv.org/abs/1807.
04603
[2] José Bacelar Almeida, Manuel Barbosa, Gilles Barthe, Arthur Blot, Benjamin
Grégoire, Vincent Laporte, Tiago Oliveira, Hugo Pacheco, Benedikt Schmidt,
and Pierre-Yves Strub. 2017. Jasmin: High-Assurance and High-Speed Cryp-
tography. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and
Communications Security. ACM.
[3] José Bacelar Almeida, Manuel Barbosa, Gilles Barthe, Benjamin Grégoire, Adrien
Koutsos, Vincent Laporte, Tiago Oliveira, and Pierre-Yves Strub. 2020. The Last
Mile: High-Assurance and High-Speed Cryptographic Implementations. In 2020
IEEE Symposium on Security and Privacy (S&P). 965–982. https://doi.org/10.1109/
SP40000.2020.00028
[4] Roberto M. Amadio, Nicholas Ayache, François Bobot, Jaap Boender, Brian Camp-
bell, Ilias Garnier, Antoine Madet, James McKinna, Dominic P. Mulligan, Mauro
Piccolo, Randy Pollack, Yann Régis-Gianas, Claudio Sacerdoti Coen, Ian Stark,
and Paolo Tranquilli. 2013. Certified Complexity (CerCo). In Foundational and
Practical Aspects of Resource Analysis - Third International Workshop, FOPARA
2013, Bertinoro, Italy, August 29-31, 2013, Revised Selected Papers (Lecture Notes
Session 2B: Formal Analysis and Verification CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea474in Computer Science, Vol. 8552), Ugo Dal Lago and Ricardo Peña (Eds.). Springer,
1–18. https://doi.org/10.1007/978-3-319-12466-7_1
[5] Gilles Barthe, Gustavo Betarte, Juan Campo, Carlos Luna, and David Pichardie.
2014. System-level non-interference for constant-time cryptography. In Pro-
ceedings of the 2014 ACM SIGSAC Conference on Computer and Communications
Security. ACM.
[6] Gilles Barthe, Sandrine Blazy, Benjamin Grégoire, Rémi Hutin, Vincent Laporte,
David Pichardie, and Alix Trieu. 2020. Formal Verification of a Constant-Time
Preserving C Compiler. Proceedings of the ACM on Programming Languages
(POPL) (2020).
[7] Gilles Barthe, Benjamin Grégoire, and Vincent Laporte. 2018. Secure Compilation
of Side-Channel Countermeasures: The Case of Cryptographic “Constant-Time”.
In 2018 IEEE 31st Computer Security Foundations Symposium (CSF). 328–343.
https://doi.org/10.1109/CSF.2018.00031
[8] Gilles Barthe, Tamara Rezk, and David A. Naumann. 2006. Deriving an Informa-
tion Flow Checker and Certifying Compiler for Java. In 2006 IEEE Symposium on
Security and Privacy (S&P 2006), 21-24 May 2006, Berkeley, California, USA. IEEE
Computer Society, 230–242. https://doi.org/10.1109/SP.2006.13
[9] Quentin Carbonneaux, Jan Hoffmann, Tahina Ramananandro, and Zhong Shao.
2014. End-to-end verification of stack-space bounds for C programs. In ACM
SIGPLAN Conference on Programming Language Design and Implementation, PLDI
’14, Edinburgh, United Kingdom - June 09 - 11, 2014, Michael F. P. O’Boyle and
Keshav Pingali (Eds.). ACM, 270–281. https://doi.org/10.1145/2594291.2594301
[10] Sunjay Cauligi, Gary Soeller, Brian Johannesmeyer, Fraser Brown, Riad S. Wahby,
John Renner, Benjamin Grégoire, Gilles Barthe, Ranjit Jhala, and Deian Stefan.
2019. FaCT: a DSL for timing-sensitive computation. In Proceedings of the 40th
ACM SIGPLAN Conference on Programming Language Design and Implementation,
PLDI 2019, Phoenix, AZ, USA, June 22-26, 2019., Kathryn S. McKinley and Kathleen
Fisher (Eds.). ACM, 174–189. https://doi.org/10.1145/3314221.3314605
[11] Juan Chen, Ravi Chugh, and Nikhil Swamy. 2010. Type-preserving compilation of
end-to-end verification of security enforcement. In Proceedings of the 2010 ACM
SIGPLAN Conference on Programming Language Design and Implementation, PLDI
2010, Toronto, Ontario, Canada, June 5-10, 2010, Benjamin G. Zorn and Alexander
Aiken (Eds.). ACM, 412–423. https://doi.org/10.1145/1806596.1806643
[12] Michael R. Clarkson and Fred B. Schneider. 2008. Hyperproperties. In Proceedings
of the 21st IEEE Computer Security Foundations Symposium, CSF 2008, Pittsburgh,
https:
Pennsylvania, USA, 23-25 June 2008. IEEE Computer Society, 51–65.
//doi.org/10.1109/CSF.2008.7
[13] Karl Crary and Stephanie Weirich. 2000. Resource Bound Certification. In POPL
2000, Proceedings of the 27th ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages, Boston, Massachusetts, USA, January 19-21, 2000, Mark N.
Wegman and Thomas W. Reps (Eds.). ACM, 184–198. https://doi.org/10.1145/
325694.325716
[14] Vijay D’Silva, Mathias Payer, and Dawn Song. 2015. The Correctness-Security
Gap in Compiler Optimization. In Security and Privacy Workshops (SPW), 2015
IEEE. 73–87. http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=7163211
[15] Alejandro Gómez-Londoño, Johannes Åman Pohjola, Hira Taqdees Syeda, Mag-
nus O. Myreen, and Yong Kiam Tan. 2020. Do you have space for dessert? a
verified space cost semantics for CakeML programs. Proc. ACM Program. Lang. 4,
OOPSLA (2020), 204:1–204:29. https://doi.org/10.1145/3428272
[16] Marco Guarnieri and Marco Patrignani. 2019. Exorcising Spectres with Secure
Compilers. CoRR abs/1910.08607 (2019). arXiv:1910.08607 http://arxiv.org/abs/
1910.08607
[17] Kedar S. Namjoshi and Lucas M. Tabajara. 2020. Witnessing Secure Compilation.
In Verification, Model Checking, and Abstract Interpretation - 21st International
Conference, VMCAI 2020, New Orleans, LA, USA, January 16-21, 2020, Proceedings
(Lecture Notes in Computer Science, Vol. 11990), Dirk Beyer and Damien Zufferey
(Eds.). Springer, 1–22. https://doi.org/10.1007/978-3-030-39322-9_1
[18] Zoe Paraskevopoulou and Andrew W. Appel. 2019. Closure conversion is safe
for space. Proc. ACM Program. Lang. 3, ICFP (2019), 83:1–83:29. https://doi.org/
10.1145/3341687
[19] Pascal Raymond, Claire Maiza, Catherine Parent-Vigouroux, Erwan Jahier, Nico-
las Halbwachs, Fabienne Carrier, Mihail Asavoae, and Rémy Boutonnet. 2019.
Improving WCET Evaluation using Linear Relation Analysis. Leibniz Trans. Em-
bed. Syst. 6, 1 (2019), 02:1–02:28. https://doi.org/10.4230/LITES-v006-i001-a002
[20] Laurent Simon, David Chisnall, and Ross J. Anderson. 2018. What You Get is What
You C: Controlling Side Effects in Mainstream C Compilers. In 2018 IEEE European
Symposium on Security and Privacy, EuroS&P 2018, London, United Kingdom, April
24-26, 2018. IEEE, 1–15. https://doi.org/10.1109/EuroSP.2018.00009
[21] Robert Sison and Toby Murray. 2019. Verifying that a compiler preserves concur-
rent value-dependent information-flow security. In International Conference on
Interactive Theorem Proving (Lecture Notes in Computer Science). Springer-Verlag.
[22] Marco Vassena, Craig Disselkoen, Klaus von Gleissenthall, Sunjay Cauligi,
Rami Gökhan Kici, Ranjit Jhala, Dean M. Tullsen, and Deian Stefan. 2021. Au-
tomatically eliminating speculative leaks from cryptographic code with blade.
Proc. ACM Program. Lang. 5, POPL (2021), 1–30. https://doi.org/10.1145/3434330
| Pbool
| Parr init
| Pglobal ⇒ ret e id
Fixpoint alloc e (m: map) (e: pexpr) : cexec (pexpr × leak e tr) :=
match e with
| Pconst
| Papp1 o e ⇒
Let: (e, r) := alloc e m e in
ret (Papp1 o e) r
| Pload ws x e ⇒ ...
Let: (e, r) := alloc e m e in
ret (Pload ws x e) [ r, id ]
| Pvar x ⇒
if ... (* x has size ws and is allocated at offset ofs *) then
else ... (* x is a register *)
ret (Pload ws stk ofs) [ id; C (sp + cst ofs) ]
let: (ofs’, t) := mk ofs ws e ofs in
ret (Pload ws stk ofs’) [ r ◦ t, I(x ↦→ sp + cst x × cst ws + cst ofs) ]
ret e id
| Pget ws x e ⇒
Let: (e, r) := alloc e m e in
if ... (* x is allocated at offset ofs *) then
else ... ret (Pget ws x e) [ r, id ]
| ... ⇒ ...
end.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
Figure 15: Pseudo-code of the stack-allocation of expressions
A DETAILS ON STACK-ALLOCATION
This appendix completes Section 5.5. It presents in graphical form
the leakage transformer produced by the stack-allocation pass ap-
plied to the example program, on Figure 16. It also briefly describes
the (Coq) implementation of the stack-allocation pass.
The stack-allocation pass is split into two phases: an analysis
that computes the layout of the stack frame; and a transformation
that introduces the memory operations. As far as leakage trans-
formers are concerned, only the second phase is relevant. The
transformation phase is structured in three main parts, that trans-
form expressions, left values, and instructions, respectively. The
transformations of expressions and of left-values are very similar:
they replace reads from (resp. writes to) variables and arrays with
loads from (resp. stores to) the memory. The final transformation
of instructions recursively applies these sub-transformations and
composes their results in a straightforward way. For the sake of
brevity, this exposition is thus restricted to the transformation of ex-
pressions, implemented by the function alloc e whose pseudo-code
is partially shown on Figure 15.
The compilation of an expression 𝑒 depends on a “map” 𝑚 that
is the result of the analysis phase. It returns an expression and the
corresponding leakage transformer, or fails; hence the monadic re-
turn type 𝑐𝑒𝑥𝑒𝑐 and the ret notation for building successful results.
The alloc e function is recursively defined, following the structure
of the expression to compile. Constant expressions (line 3) are re-
turned as is; the leakage transformer is therefore the identity id.
Unary operators (Papp1) applied to a sub-expression produce the
same leakage as said sub-expression; therefore the leakage trans-
former 𝑟 corresponding to the compilation of the sub-expression
(line 5) directly applies to the whole expression (line 6). The leak-
age for a memory load is a pair: the first component stands for the
evaluation of the address and the second component reveals the
address that is accessed. The compilation of a load expression re-
cursively transforms the address expression but preserves its value
Session 2B: Formal Analysis and Verification CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea475:=
:=
:=
{ ; }
( ,
)
id
( ,
)
id
id
•
𝐼(𝑥 ↦→ sp+ cst 𝑥 × cst 8)
•
𝐼(𝑥 ↦→ sp+ cst 𝑥 × cst 8)
id
id
( ,
)
:=
( ;
)
id
◦
id
•
( ,
)
( ;
)
id
𝐼(𝑥 ↦→ sp+ cst 𝑥 × cst 8)
•
Figure 16: Leakage transformer
(line 10). There are two cases in the compilation of a read from a
variable 𝑥 (line 12): if this variable is bound in the map 𝑚 to some
offset ofs, then it must be transformed into a memory load and a
leakage corresponding to this load is introduced; otherwise, the
expression and its leakage are preserved. Finally, the compilation
of a read of size 𝑤𝑠 from array 𝑥 at index 𝑒 first recursively trans-
forms the sub-expression 𝑒; then if the array is laid out at offset
ofs, the relevant element is at offset 𝑒 × 𝑤𝑠 + ofs. The expression
representing this offset is built by the smart constructor mk ofs
(not shown on the figure) which simplifies constant expressions
and returns the corresponding leakage transformer. The complete
leakage transformer (line 22) is the parallel composition of, on one
hand, the composition of both transformations of the offset, and
on the other hand, the transformation of the array leakage into a
memory leakage.
Session 2B: Formal Analysis and Verification CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea476