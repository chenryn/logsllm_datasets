the effectiveness of our approach to understand common behaviors
between two families with the same capabilities.
We also look at the dual: when apps of two different families
have different feature vectors. For instance, C3829A...03DB.apk from
svpeng family and 877D3B...2AE4.apk from slocker family are differ-
ent in two features. In particular, the first app overlays its window
on top of other windows (feature #24 in Table 3). This app also
has a keyword database to identify encryption-related words in UI
widgets (feature #15 in Table 3). This is similar to variants of the
ransomprober family [33]. Instead, the the second app does not
have any of these capabilities. These two differences are the main
distinctions between the two families. However, all other features
are shared. This indicates that two families have evolved from one
another. It also shows to what extent we can use our system to
explain the differences between apps.
B SMS TROJAN
Case Studies. Like in the previous section, we select two of the
most popular families (i.e., Cvmtld and Rusms) and provide a quali-
tative evaluation or our findings.
Cvmtld is an Android SMS Trojan which contains 19 different sam-
ples out of which: one sample is first detected in 2013, five samples
are first detected in 2014, and the rest have been all detected in
20163. We observe that 8 ensembles of API methods are shared
3https://www.virustotal.com
Figure 3: Distribution of sensitive API call ensembles among
ransomware samples from different families.
Table 3: Mapping between feature numbers and ensembles
of sensitive API methods extracted from ransomware fami-
lies.
#Feature
Ensemble of Sensitive API Methods
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
delete(), exists()
getClassLoader()
insert(), query()
insert()
openConnection()
connect()
getInputStream()
getApplicationInfo()
getSubscriberId()
openConnection(), connect(), getInputStream()
getFilesDir()
mkdir(), exists()
crypto
loadLibrary()
query()
mkdir()
setDataAndType()
exists(), mkdir()
exists()
delete()
getDeviceId()
getActiveNetworkInfo()
mkdir(), delete(), exists()
addFlags()
openConnection(), connect(), getInputStream(), getFilesDir(), exists()
Porndroid is a ransomware family which hides behind a fake pornog-
raphy app. Security reports show that once an app from this family
is downloaded, it downloads another file, known as LockerPin [39].
Then, the user is locked out of the device and the pin number of
the phone is changed. The apps in this family usually display a
warning window from an official source (e.g., security agencies
like FBI) and threaten the victims to pay the ransom in return for
the illegal pornographic websites they have accessed with their
smartphones. If this ransom is not paid, all files are deleted and the
phone is restarted to its factory settings.
Our dataset contains 10 different apps from the porndroid family
and 8 ensembles of API calls are shared by more than 70% of apps.
The behaviors shown by these ensembles of APIs are aligned with
actions described by commercial reports and threat intelligence
gathered from each of the families. In particular, all samples (100%)
do contain 3 common API calls, including getActiveNetworkInfo()
and getClassLoader() and addFlags(). The first method is used to
obtain details about the current active data network and can be used
to check whether or not the compromised device is connected to the
Internet. Once confirmed, the apps download the original malicious
f2f20f1f24f22f15f23f6f5f19f18f7f12f10f16f13f11f8f17f21f9f25f3f14f4Ensembles0100200300400500600700800Numberofapps802753746731725662646641590570521498447442442104605757463416151412(a) Ransomware
(b) SMS Trojan
(c) Banking Trojan
Figure 4: The cosine distance of app vectors in different families for each type of malware (values close to 0 show high simi-
larity, whereas those close to 1 show significant difference). Two or more groups of apps with colors close to blue in one row
are those which are behaviorally similar in different families.
whether or not the WiFi connection is enabled on the target device
(isWifiEnabled()). Once this is clarified, they load a native library
into memory (loadLibrary()) and call the loader to execute all loaded
malicious classes (getClassLoader()). Then, they steal victim’s cre-
dential information (using ensembles such as  and query()) and some extra information (e.g., network
operator using getNetworkOperator()) by overlaying the windows
of other legitimate apps and services (addFlags()). Once these in-
formation are gathered, they encrypt all of them (crypto) and leak
them to remote servers by opening a connection (). Also, they delete original files after encryption
procedure (using exists() and delete()).
Apps in Fareac family are also able to intercept data from cur-
rent open connection (getInputStream()). Additionally, they can all
detect simulated environments (), and, thus,
can bypass dynamic analysis. Indeed, this family is very hard to
be detected as it can potentially evade both static and dynamic
analyses.
Intra-family characterization. Similar to ransomware and SMS
Trojans, we have inspected several cases (see Fig. 4c) of two
apps in different banking Trojan families with identical and differ-
ent behavior. For instance, 6B03C9...807C.apk from sodsack family
and 3DC0F8...D204.apk from ztorg family are two bankers which
load their malicious code at run-time to evade static analysis.
On the other hand, 3CC01D...7012.apk from dhyvax family and
748ECD...0837.apk from the acecard family have different capabili-
ties. The former banker checks the list of files in different directories,
and creates files and folders, whereas the latter is able to delete files
or directories.
among all samples in this family. However, if we look at lower
granularity levels, we observe informative ensembles as well. All
specimens collect sensitive device information and leak them to
remote servers. They are also able to detect emulators and to evade
dynamic analysis () similar to other families
reported in earlier works [41]. As these behaviors are common to
all samples in the family, we can say that these are the “core” capa-
bilities that characterize the family. However, there are other sets of
behaviors that can be used to characterized variants of the family.
As it is clear, 95% of samples send text messages to specific numbers
(sendTextMessage()). There are also behaviors that enable these apps
to update their capabilities during runtime (getClassLoader()).
Intra-family characterization. There are several examples (see
Fig. 4b) where two apps from different SMS Trojan families have
exactly the same behavior. 2F7794...88B8.apk from smsboxer family
and 971913...5B82.apk from darrma family share exactly the same
feature vector although they belong to different families. Both of
these apps are equipped with mechanisms to detect dynamic anal-
ysis systems and can halt their activities if they observe clues of
simulated environments. Also, they rely on Internet connection to
deliver their malicious functionalities and can encrypt/delete files.
When looking at apps with different behaviors, we observe
CD3A15...768D.apk from moavt family and 229C9A...8357.apk from
darrny. The first app collects the phone number string (via get-
Line1Number()) whereas the second one does not. In contrast, the
second app is able to detect emulators (using 
ensemble of API calls) as compared to the first app.
C BANKING TROJAN
Case Studies. We next describe one of the most prevalent banking
Trojans according to our dataset, known as Fareac.
Fareac is a banking Trojan family which contains 37 different mal-
ware samples in our dataset. The results obtained reveal 27 different
ensembles of API methods which are shared by all applications in
this family. In particular, all apps in this family have similar be-
havior and share common characteristics. First of all, they check
00.10.20.30.40.50.60.70.80.9100.10.20.30.40.50.60.70.80.9100.10.20.30.40.50.60.70.80.91