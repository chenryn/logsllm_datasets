"http://example.com/";
Figure 3: Selected nodes from a heap graph showing
a cross-origin JavaScript capability leak of the location
prototype, object@0x1c1d2700, to the attacker af-
ter the victim attempts to frame bust.
This line of JavaScript changes the location of the top-
most frame, navigating that frame to a trusted Web site.
The browser permits cross-origin access to a frame’s
location object to allow navigation [1].
If this script
is the ﬁrst script to access the location object of the
top frame, then WebKit will mistakenly connect the
top frame’s newly constructed location object to the
Object.prototype of the child frame (instead of
to the Object.prototype of the top frame) because
the child frame is currently in scope lexically.
Exploit. To exploit this cross-origin JavaScript capa-
bility leak, the attacker proceeds in two phases:
(1)
the attacker obtains a JavaScript pointer to the hon-
est Object.prototype, and (2) the attacker abuses
the honest Object.prototype to inject a malicious
script into the honest security origin. To obtain a
JavaScript pointer to the honest Object.prototype,
the attacker create an  to an honest document
that frame busts and runs the following script in response
to the beforeunload event:
var location_prototype =
window.location.__proto__;
var honest_object_prototype =
location_prototype.__proto__;
Because the beforeunload event handler runs af-
ter the child frame has attempted to frame bust, the at-
tacker’s location object has been instantiated by the hon-
est document and is mistakenly attached to the honest
Object.prototype (see Figure 3). The attacker ob-
tains a pointer to the honest Object.prototype by
traversing this prototype chain.
Once the attacker has obtained a JavaScript pointer
to the honest Object.prototype, there are a num-
ber of techniques the attacker can use to compromise the
honest security origin completely. We describe two rep-
resentative examples:
1. Many Web sites use JavaScript libraries to smooth
over incompatibilities between browsers and reuse
Attacker Global Object@0x1c1d0040object@0x1c1d2720locationobject@0x1c1d2700__proto__Object Prototype@0x1c1d1420__proto__Victim Global Object@0x1c1d13e0object@0x1c1d2740locationobject@0x1c1d1e20Object__proto__prototypecommon code. One of the more popular JavaScript
libraries is the Prototype library [22], which is used
by CNN, Apple, Yelp, Digg, Twitter, and many oth-
ers. If the honest page uses the Prototype library,
the attacker can inject arbitrary script into the hon-
est page by abusing the powerful invoke function
deﬁned by the Prototype library. For example, the
attacker can use the follow script:
var honest_function =
honest_object_prototype.
__defineGetter__;
var honest_array =
honest_function.
argumentNames();
honest_array.push(frames[0]);
honest_array.invoke("setTimeout",
"... malicious script ...");
In the Prototype library, arrays contain a method
named invoke that calls the method named
by its ﬁrst argument on each element of its ar-
ray, passing the remaining arguments to the in-
voked method. To abuse this method,
the at-
tacker ﬁrst obtains a pointer to an honest ar-
ray object by calling the argumentNames
method of an honest function reachable from
the honest_object_prototype object. The
attacker then pushes the global object of the
child frame onto the array and calls the honest
document’s setTimeout method via invoke.
The honest global object has a reference mon-
itor
from accessing
setTimeout directly, but the reference monitor
allows invoke to access setTimeout because
invoke is deﬁned by the honest document.
that prevents the attacker
2. Even if the honest Web page does not use a complex
JavaScript library, the attacker can often ﬁnd a snip-
pet of honest script to trick. For example, suppose
the attacker installs a “setter” function for the foo
property of the honest Object.prototype as
follows:
function evil(x) {
x.innerHTML =
’’;
});
honest_object_prototype.
__defineSetter__(’foo’, evil);
Now, if the honest script stores a DOM node in a
property of an object as follows:
var obj = new Object();
obj.foo = honest_dom_node;
The JavaScript engine will call the attacker’s setter
function instead of storing honest_dom_node
into the foo property of obj, causing the
variable x to contain a JavaScript pointer
to
honest_dom_node. Once the attacker’s func-
tion is called with a pointer to the honest DOM
node, the attacker can inject malicious script into
the honest document using the innerHTML API.
4.4 Capability Leaks in Subspace
The Subspace mashup design [11] lets a trusted integra-
tor communicate with an untrusted gadget by passing a
JavaScript pointer from the integrator to the gadget:
A Subspace JavaScript object is created in
the top frame and passed to the mediator
frame... The mediator frame still has access to
the Subspace object it obtained from the top
frame, and passes this object to the untrusted
frame. [11]
Unfortunately, the Subspace design relies on leaking
a JavaScript pointer from a trusted security origin to
an untrusted security origin, creating a cross-origin
JavaScript capability leak. By leaking the communica-
tion object, Subspace also leaks a pointer to the trusted
Object.prototype via the prototype chain of the
communication object.
To verify this attack, we examined CrossSafe [25], a
public implementation of Subspace. We ran a Cross-
Safe tutorial in our instrumented browser and examined
the resulting heap graph. Our detector found a cross-
origin JavaScript capability leak: the channel object
is leaked from the integrator to the gadget. By repeat-
edly dereferencing the __proto__ property, the un-
trusted gadget can obtain a JavaScript pointer to the
trusted Object.prototype object. The untrusted
gadget can then inject a malicious script into the trusted
integrator using one of the techniques described in Sec-
tion 4.3.
5 Defense
In this section, we propose a principled defense for
cross-origin JavaScript capability leaks. Our defense ad-
dresses the root cause of these vulnerabilities and incurs
a minor performance overhead.
5.1 Approach
Currently, browser vendors defend against cross-origin
JavaScript capability leaks by patching each individual
leak after the leak is discovered. We recommend an-
other approach for defending against these vulnerabili-
ties: add access control checks throughout the JavaScript
engine. We recommend this principled approach over
ad-hoc leak plugging for two reasons:
• This approach addresses the core design issue un-
derlying cross-origin JavaScript capability leak vul-
nerabilities: the mismatch between the DOM’s ac-
cess control security model and the JavaScript en-
gine’s object-capability security model.
• This approach provides a second layer of defense:
if the browser is leak-free, all the access con-
trol checks will be redundant and pass, but if the
browser contains a leak, the access control checks
prevent the attacker from exploiting the leak.
In a correctly implemented browser, Web content will be
unable to determine whether the browser implements the
access control checks we recommend. The additional
access control checks enhance the mechanism used to
enforce the same-origin policy but do not alter the policy
itself, resulting in zero compatibility impact.
Another plausible approach to mitigating these vul-
nerabilities is to adopt an object-capability discipline
throughout the DOM. This approach mitigates the sever-
ity of cross-origin JavaScript capability leaks by limiting
the damage an attacker can wreak with the leaked capa-
bility. For example, if the browser leaks an honest his-
tory object to the attacker, the attacker would be able to
manipulate the history object, but would not be able to
alter the document object. Conceptually, either adding
access control checks to the JavaScript engine or adopt-
ing an object-capability discipline throughout the DOM
resolves the underlying architectural security issue, but
we recommend adopting the access control paradigm for
two main reasons:
• Adopting an object-capability discipline through-
out the DOM requires “taming” [15] the DOM API.
The current DOM API imbues every DOM node
with the full authority of the node’s security origin
because the API exposes a number of “universal”
methods, such as innerHTML that can be used
to run arbitrary script. Other researchers have de-
signed capability-based DOM APIs [4], but taming
the DOM API requires a number of non-backwards
compatible changes. A browser that makes these
changes will be unpopular because the browser will
be unable to display a large fraction of Web sites.
• The JavaScript language itself has a number of fea-
tures that make enforcing an object-capability dis-
cipline challenging. For example, every JavaScript
object has a prototype chain that eventually leads
back to the Object.prototype, making it dif-
to create a weaker object-capability than
ﬁcult
the Object.prototype. Unfortunately,
the
Object.prototype itself represents a power-
ful object-capability with the ability to interfere
with the properties of every other object from the
same document (e.g., the exploit in Section 4.3.)
Although we recommend that browsers adopt the access
control paradigm for Web content, other projects, such
as Caja [16] and ADsafe [3], take the opposite approach
and elect to enforce an object-capability discipline on
the DOM. These projects succeed with this approach be-
cause the preceding considerations do not apply: these
projects target new code (freeing themselves from back-
wards compatibility constraints) that is written in a sub-
set of JavaScript (freeing themselves from problematic
language features). For further discussion, see Section 6.
5.2 Design
We propose adding access control checks to the
JavaScript engine by inserting a reference monitor into
each JavaScript object. The reference monitor interposes
on each get and set operation (described in Section 3)
and performs the following access control check:
1. Let the active origin be the origin of the document
that deﬁned the currently executing script.
2. Let the target origin be the origin that “owns” the
JavaScript object being accessed, as computed by
the algorithm in Section 3.1.
3. Allow the access if the browser considers the active
origin and the target origin to be the same origin
(i.e., if their scheme, hosts, and ports match).
4. Otherwise, deny access.
If the access is denied, the JavaScript engine returns the
value undefined for get operations and simply ig-
nores set operations. In addition to adding these ac-
cess control checks, we record the security origin of each
JavaScript object when the object is created. Our imple-
mentation does not currently insert access control checks
for delete operations, but these checks could be added
at a minor performance cost. Some JavaScript objects,
such as the global object, are visible across origins. For
these objects, our reference monitor defers to the refer-
ence monitors that already protect these objects.
5.3
The main disadvantage of performing an access control
check for every JavaScript property access is the run-
time overhead of performing the checks. Sophisticated
Web applications access JavaScript properties an enor-
mous number of times per second, and browser vendors
have heavily optimized these code paths. However, we
observe that the proposed access checks are largely re-
dundant and amenable to optimization because scripts
virtually always access objects from the same origin.
Inline Cache
Cutting-edge JavaScript engines,
including Sa-
fari 4’s Nitro JavaScript Engine, Google Chrome’s
V8 JavaScript engine, Firefox 3.5’s TraceMonkey
JavaScript engine, and Opera 11’s Carakan JavaScript
engine, optimize JavaScript property accesses using an
inline cache [24]. (Of the major browser vendors, only
Microsoft has yet to announce plans to implement this
optimization.) These JavaScript engines group together
JavaScript objects with the same “structure” (i.e., whose
properties are laid out the same order in memory). When
a script accesses a property of an object, the engine
caches the object’s group and the memory offset of the
property inline in the compiled script. The next time
that compiled script accesses a property of an object, the
inline cache checks whether the current object has the
same structure as the original object. If the two objects
have the same structure, a cache hit, the engine uses the
memory offset stored in the cache to access the prop-
erty. Otherwise, a cache miss, the engine accesses the
property using the normal algorithm.
Notice that two objects share the same structure only