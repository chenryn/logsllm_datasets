{perladmin)保存本地Perlmaster的E-mail地址。如果s1没有使用动态作用域，这段代码
就很难理解，因为&Confg是一个绑定变量（tiedvariable）。也就是说，对它的任何引l用都
意味着幕后的子程序调用，用sConfig(·)进行正则表达式匹配时，Config中的子程序返
回对应的值。这次匹配发生在上一行的匹配和对$1的使用中间，所以如果S1没有使用动态
作用域，它的值会被修改。所以，SConfig(…)中对s1的任何修改都被动态作用域安全地
保护了起来。
动态作用域还是词法作用域
如果使用恰当，动态作用域能提供许多便利，但是滥用动态作用域会带来无休止的丽梦，
因为阅读程序的人很难理解，分散在散落的1oca1、子程序和本地变量引用之间的复杂交
互。
我曾说，my（….)声明会在词法范圈（lexicalscope）内创造一个私有变量。与私有变量的词
法范围对应的是全局变量的范围，但是词法范围与动态作用域没有关系（仅有的联系是：
不能对my变量调用1ocal）。请记住，1ocal只是行为（action），而my既是行为，又是声
明，这很重要。
匹配修改的特殊变量
SpecialVariables Modified by a Match
成功的匹配会设置一组只读的全局变量，它们通常会自动使用动态作用域。如果匹配不成
功，这些值永远也不会改变。在需要的时候，它们会设置为空字符串（不包括任何字符的
字符串）或者undefind（“未定义”，一个“没有值”的值，与空字符串类似，但测试时两
者不相等）。表7-5给出了若干例子。
详细地说，匹配完成之后会设置这些变量：
$正则表达式所匹配文本的副本。从效率方面考虑（参见第356页的讨论），最好不要使
用这个变量（还包括下面介绍的S和S）。"旦匹配成功，$&就不会是未定义状态，
尽管它可能是空字符事。
---
## Page 326
300
第7章：Perl
表7-5：匹配后特殊变量的说明
如下匹配完成之后
1 2
234431
*Pi is 3.14159, roughly* = m/\b((tasty1fattening) 1(\d+(\.\d*)?))\b/;
设置了下面的特殊变量
变量
含义
值
$'
匹配文本之前的文本
Pi·is*
$&
匹配文本
3 . 14159
$"
匹配文本之后的文本
,'roughly
$1
第1组括号匹配的文本
3 . 14159
$2
第2组括号匹配的文本
undef
$3
第3组括号匹配的文本
3 .14159
$4
第4组括号匹配的文本
. 14159
$+
编号最大的括号匹配的文本
.14159
S~N
最后结束的括号匹配的文本
3 .14159
@-
目标文本中各匹配开始位置的偏移值数组
(6，6，undef,6,7)
@+
目标文本中各匹配结束位置的偏移值数组
(13,13, undef,13,13)
$在目标文本中匹配开始之前（左边）文本的副本。如果使用/g修饰符，你可以期望S
的起点是开始尝试位置的文本，但它每次都是从整个字符串的开始位置开始的。如果匹
配成功，$肯定不会是未定义状态。
$’保存目标文本中匹配成功文本之后（右边）的文本的副本。如果匹配成功，S肯定不会
是未定义状态。匹配成功之后，字符串"$`$&S"就是目标字符串的副本（注5）。
$1、$2、$3、
对应第1、2、3组捕获型括号匹配的文本（请注意，这里没有$0，因为它是脚本的名
字，与正则表达式无关）。如果它们对应的括号在表达式中不存在，或者没有实际参与
匹配，则设置为未定义状态。
匹配之后就可以使用这些变量，在s/…/…./中的replacement也可以使用。它们还能在
动态正则结构或者嵌入代码中使用（327）。在正则表达式中使用这些变量是没多少
意义的（因为已经有了1之类）。请参考第303页的“在正则表达式中使用$1”。
（\w+）和（\w）+的区别可以用来说明s1的设置方式。两个表达式都能匹配同样的文
注5：事实上，即使目标字符串是未定义的，但能匹配成功（虽然不太现实，但有可能），“S'S&
S""是一个空字符串，而不是未定义。只有在这种情况下，两者才不一样。
---
## Page 327
正则表达式相关的Perl教义
301
本，但是它们的区别在于括号内的子表达式匹配的内容。用这个表达式匹配字符串
‘tubby”，第一个表达式的s1的内容是‘tubby”，而第二个表达式中的s1只包含‘y”：
在（\w)+中，加号在括号外面，所以每次选代都会重新捕获，$1保留最后的字符。
还需要注意的是（x)？和（x？）的差别。前一个表达式中括号及其捕获内容不是必然
出现的，所以$1可能是‘x”，或者是未定义，但（x？）中括号在匹配的外面一匹配
的内容不是必然出现的，但匹配必须发生。如果整个表达式匹配成功，这部分的匹配
必然会发生，尽管x？匹配的是空字符串。所以在（x？）中，$1可能是‘x’或者是空
字符串。下表给出了一些例子：
实例
IS
实例
$1
": : * =~ m/:(A?) : /
空字符串
*::* =~ m/ : (\w*) : /
空字符串
*: :" =~ m/ : (A) ?: /
未定义
 : :* =~ m/: (\w) *: /
未定义
:A:*=~ m/:(A?) :/
* :Word: * =~ m/ : (\w*) : /
word
":A: " =~ m/ : (A) ?: /
/:（M\）:/W~=:pxOM:。
d
从上表可以看出，如果需要添加括号来捕获文本，如何添加取决于我们的意图。在所
举的例子中，增加的括号对整体匹配没有影响（整体匹配是不变的），其中唯一的区别
就是$1设置的伴随效应。
$+表示$1、$2等匹配过程中明确设定的，编号最大的变量的副本。在下面的情况中会有
用：
$url =~ m{
href \s*=\s*
#匹配"href="，然后是它的值..
（？："（["]*）*
#双引号字符串，或者..·
，（[.]）.1
#单引号字符串，或者...
丨（[^"<>]+））#非引号形式的值
)ix;
如果没有$+，我们可能需要依次检查S1、$2和$3，才能找出明确设置的那个。
如果正则表达式中没有捕获型括号（或者在匹配中没有用到），则这个值为未定义。
$^N最后结束的，在匹配中明确设定的括号匹配的文本的副本（明确设定的S1等变量中，
闭括号在最后）。如果正则表达式中没有捕获型括号（或者匹配中没有用到），则其值
为未定义。第344页开头有个恰当的例子。
---
## Page 328
302
第7章：Perl
@-和@+
表示各捕获型括号所匹配文本的起始和结束位置在目标文本中偏移值的数组。使用起
来可能有点迷惑，因为它们的名字比较怪异。两个数组的第一个元素都对应整体匹配。
也就是说，通过s-[0]访问到的@-的第一个元素，是整个匹配在目标字符串中的偏移
值，即：
$text=*Version 6 coming soon?";
$text=~m/\d+/:
$-[0】的值为8，代表匹配从目标字符串的第8个位置开始（在Perl中，偏移值从0
开始)。
e+的第一个元素通过s+[0]访问，表示对应匹配文本结束位置的偏移值。在上例中其
值为9，表示整体匹配结束于目标字符串的第9个字符之前。所以，如果stext没有
变化，subatr（$text，$-[o]，$+[0]-$-[o])就等于S&，但没有s&那样的性能缺
陷（356)，下例给出了@-的简单用法：
1 while $line =~s/\t/x(8-$-[0] 8)/e;
它会把给定文本中的制表符（tab）替换为合适长度的空格序列（注6）。
两个数组中接下来的元素分别对应各捕获分组的开始位置和结束位置的偏移值。$-[1]
和$+[1]对应$1，$-[2]和$+[2]对应$2，依次类推。
条件语句（140）中的if部分，则不设定S^R。在正则表达式内部（即在嵌入代码或
者动态正则结构?327中），它会自动根据匹配的各部分进行本地化处理，所以因为回
溯而“交还”的代码对应的S^R的值会被放弃。换一种说法就是，它保存引擎到达当前
状态的工作路径中“最近”的值。
如果正则表达式根据/g修饰符重复使用，那么每次循环都会重新设置这些变量。也就是说
可以在s/././g中使用s1，因为每次匹配时它的值都不一样。
注6：这段代码的局限在与，它只能处理“传统”西方文本，而无法正确处理包含“枝”之类的
宽宇符集，因为宽字符集中显示一个字符可能需要两个以上的位置，某些Unicode语音字
符，例如a，也无法处理（107）。
---
## Page 329
qr../运算符与regex对象
303
在正则表达式中使用$1
Perl手册专门提到，在正则表达式外部，不能用1反向引用（而应该使用s1）。变量s1对
应上次成功匹配中的某个固定字符串。1则是正则表达式元字符，它对应正则引擎遇到1
时第一组捕获型括号捕获的文本。在NFA的回溯过程中，它的值可能会变化。
与之对应的问题是，正则运算元中是否能够使用s1之类的变量。通常，在内嵌代码或者动
态正则结构（327）中可用，在其他情况下就没什么意义。出现在运算元中“表达式部分”
的S1与其他变量一样处理：在匹配或替换操作开始时插值。也就是说，对正则表达式而言，
$1与当前的匹配没什么关系，它属于上一次匹配。
qr/./运算符与regex对象
Theqf.../OperatorandRegexOhjects
在第2章和第6章已经简要介绍过（76，277）一元运算符qr/…/，其运算元为正则表达
式，返回regex对象。返回的对象可以被之后的正则运算符用来匹配、替换、分割，或者可
以作为其他的更长表达式的一部分。
正则表达式编译时提高控制能力，讨论见下文)。
291页已经介绍过，用户可以使用自己的分隔符，例如qr{…）或者qr！！。它还支持核心
修饰符/i、/x、/s、/m和/o。
构建和使用regex对象
Building and Using Regex Ohjects
下面的表达式来自第2章（76）：
my $HostnameRegex=qr/[-a-z0-9]+（?:\.[-a-z0-9]+）*\.(?:comiedulinfo)/i;
my SHttpUr1 = qr(
http://$HostnameRegex\b
#Hostname
/[-a-z0-9- :\@&?=+,.!/ ~*'g\S] *
#可能出现的path
(?<![. , ?!])
#不客许以[.，？！]结尾
(
}ix;
---
## Page 330
304
第7章：Perl
第一行代码把匹配主机名所用的简单正则表达式封装为regex对象，保存到变量sHostname-
Regex中。下一行使用该变量构建匹配HTTPURL的regex对象，保存到sHttpUr1中。构
建完成之后就可以以多种方式使用，例如：
if (Stext =~ $HttpUrl）{
print "There is a URL\n";
用来检测，或者：
while （$text =~m/(SHttpUrl)/g）{
print "Found URL:$1\n*;
用来搜索和显示所有的HTPPURL。
如果按照第5章的讲解（205）修改$HostnameRegex：
my $HostnameRegex = qr{
#一个或多个点号分隔部分
(?:[a-z0-9]\.1[a-z0-9][-a-z0-9](0,61}[a-z0-9]\.)*
#后缀
(?: com|edulgovlintImilInetlorglbiz|info|-|aerol[a-2][a-z] )
)xi ;
它的使用方式与之前的例子相同（开头没有，结尾没有$，也没有捕获型括号），所以，
我们的替换不受限制。这样能得到更准确的SHttpUrl。
匹配模式（即使不设置）是不可更改的
qr/…/支持292页介绍的核心修饰符。regex对象一旦构建完成，对应的匹配模式就不能更
改了，即使regex对象所在的m//有自己的修饰符也是如此。下面的代码就不正确：
mySwordRegex=qr/\b\w+\b/：#这里忘了添加修饰符/x
if （$text =~m/^（$WordRegex)/x）{
print*found wordat start of text:$l\n";
这里希望用/x修饰sWordRegex的匹配模式，但是这并不管用，因为在swordRegex生成时
修饰符（即使不设置）被锁定在qr//中。所以，修饰符必须在恰当的时候使用。
---
## Page 331
qr/../运算符与regex对象
305
下面的代码则没有问题：
mySwordRegex=qr/\b\w+\b/x;#没问题！
if （$text =~m/^($WordRegex)/）{
print "found word at start of text:$1\n*;
）