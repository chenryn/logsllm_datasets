if (pid == -1)
perror (”wait”);
printf (”pid=%d\n”, pid);
if (WIFEXITED (status))
printf (”Normal termination with exit
status=%d\n”, WEXITSTATUS (status));
if (WIFSIGNALED (status))
printf (”Killed by signal=%d%s\n”, WTERMSIG
(status), WCOREDUMP (status) ? ” (dumped
core)” : ””);
if (WIFSTOPPED (status))
printf (”Stopped by signal=%d\n”, WSTOPSIG
(status));
if (WIFCONTINUED (status))
printf (”Continued\n”);
return 0;
}
程子进程出。进程调
wait() 子进程的。进程出子进程的 pid 以及。
子子进程的 main() 以以的出
$ ./wait
pid=8529
Normal termination with exit status=1
子进程的 main() 调 abort()（ 
子进程自 SIGABRT 我们
的将的出
$ ./wait
pid=8678
Killed by signal=6
– 149 –
 5 
进程理
5.4.1 等待特定进程
子进程的的。进程能子进程
子进程的进程的子进程。
方式调 wait()的进程。
的设子进程的
进程存 wait() 的以备将。
进程的 pid以 waitpid() 调
#include 
#include 
pid_t waitpid (pid_t pid, int *status, int
options);
 wait()  waitpid() 更的调。的以
调。
 pid 的或进程的 pid。的
0
进程 pid 的子进程。 500 示 pid  500
的子进程。
 status 的作 wait() 的的的
以的。
 options 零或进或的
WNOHANG
的子进程或或处
的 waitpid() 。
WUNTRACED
  设   即   调  进 程     子 进 程 WIF-
STOPPED 设。以实更的
作业 shell。
– 150 –
 5 
进程理
WCONTINUED 设即调进程子进程 WIFCON-
TINUED 设。 WUNTRACED 对
 shell 的实的。
调时 waitpid() 进程的 pid。设
WNOHANG 的（进程的
0。时 -1 errno 的的
ECHILD  pid 的进程存或调的子进程。
EINTR
设 WNOHANG程。
EINVAL  options 。
作子设的程 pid  1742 的子进程的
子进程, 进程。写出的
int status;
pid_t pid;
pid = waitpid (1742, &status, WNOHANG);
if (pid == -1)
perror (”waitpid”);
else {
printf (”pid=%d\n”, pid);
if (WIFEXITED (status))
printf (”Normal termination with exit
status=%d\n”, WEXITSTATUS (status));
if (WIFSIGNALED (status))
printf (”Killed by signal=%d%s\n”, WTERMSIG
(status), WCOREDUMP (status) ? ” (dumped
core)” : ””);
}
作子 wait() 的
wait (&status);
 waitpid() 的
– 151 –
 5 
进程理
waitpid (-1, &status, 0);
5.4.2 其他等待子进程的方法
作程们更子进程的方式。 XSI 扩展
POSIX Linux 提 waitid():
#include 
int waitid (idtype_t idtype, id_t id, siginfo_t
*infop, int options);
 wait()  waitpid() , waitid() 作子进程的子进程
的（、或。更的以
性的。
 waitpid()  waitid() 程的子进程。
工作 waitid() 。 idtype  id 
的子进程 waitpid() 的 pid 的作。 idtype 的
的
P PID
 pid  id 的子进程。
P GID 进程 ID  id 子进程。
P ALL 子进程 id 。
 id 的 id t 的 ID 。将
能 idtype 的以。新的 idtype 以
进。 id t 的以存何的 pid t 。 Linux
上以 pid t  pid t 的给或
性的。程上的。
 options 以或进进” 或” 的
WEXITED
调进程的子进程（ id  idtyp 。
WSTOPPED
调进程的子进程。
WCONTINUED 调进程的子进程。
WNOHANG
调进程子进程（或
。
– 152 –
 5 
进程理
WNOWAIT
调进程满件的子进程的。调进程
能将。
时 waitid()  infop效的 siginfo t 
。 siginfo t 的实相的。∗
waitpid() 调效的。的调的
si pid
子进程的 pid
si uid
子进程的 uid
si code
  子 进 程 的         、 、  或     
   设   CLD EXITED、 CLD KILLED、 CLD STOPPED 或 
CLD CONTINUED 的。
si signo 设 SIGCHLD。
si status  si code  CLD EXITED子进程的出。
的的。
时 waitid()  0。时 -1。 errno 设
ECHLD  id  idtype 的进程存。
EINTR
子进程的 options 设 WNO-
HANG。
EINVAL options 或 id  idtyp 的。
waitid() 提 wait()  waitpid() 更的。以 siginfo t
的的。更
单的以更的以更更的
Linux 的上。
5.4.3 BSD 中的 wait3() 和 wait4()
 waitpid()  AT&T 的 System V Release 4 的同时 BSD 自的方
提子进程的
#include 
∗实上 siginfo t  Linux 上的。的 /usr/include/bits/sig-
info.h。我们的更。
– 153 –
 5 
进程理
#include 
#include 
#include 
pid_t wait3 (int *status, int options, struct
rusage *rusage);
pid_t wait4 (pid_t pid, int *status, int options,
struct rusage *rusage);
 3  4 实上。
 rusage 的工作方式 waitpid() 对
wait3() 的调
pid = wait3 (status, options, NULL);
的 waitpid() 调
pid = waitpid (-1, status, options);
对 wait4() 的调
pid = wait4 (pid, status, options, NULL);
的 waitpid() 调
pid = waitpid (pid, status, options);
 wait3() 何子进程 wait4()  pid 的子
进程。 options 的作 waitpid() 的。
提调的同 rsuage 。 rsuage 
空的 rsuage 上子进程相的。
提子进程的
#include 
struct rusage {
struct timeval ru_utime; /* user time consumed
*/
struct timeval ru_stime; /* system time
consumed */
– 154 –
 5 
进程理
long ru_maxrss;
/* maximum resident set size
*/
long ru_ixrss;
/* shared memory size */
long ru_idrss;
/* unshared data size */
long ru_isrss;
/* unshared stack size */
long ru_minflt;
/* page reclaims */
long ru_majflt;
/* page faults */
long ru_nswap;
/* swap operations */
long ru_inblock;
/* block input operations */
long ru_oublock;
/* block output operations */
long ru_msgsnd;
/* messages sent */
long ru_msgrcv;
/* messages received */
long ru_nsignals; /* signals received */
long ru_nvcsw;
/* voluntary context switches
*/
long ru_nivcsw;
/* involuntary context
switches */
};
我们。
调时 0。时 -1。 errno 设 waitpid() 
的。
 wait3()  wait4()  POSIX 的∗以们
真的子进程的。们 POSIX 的
的 UNIX 们。
5.4.4 创建并等待一个新进程
ANSI  POSIX 新进程的
以同步的进程。进程新进程然
的的
∗ wait3()  Single UNIX Specification 
– 155 –
 5 
进程理
#define _XOPEN_SOURCE
/* if we want
WEXITSTATUS, etc. */
#include 
int system (const char *command);
system() 以进程同步” 给
”。 system() 单的工程或 shell 的
工程或的。
对 system() 的调 command 的程的
程以以相的。”/bin/sh –c” 作 command 
。将给 shell。
时的同 wait() 的。
的 WEXITSTATUS 。对 /bin/sh 自的调
 WEXITSTATUS 的调 exit(127) 的
的。能调的 127 shell 自
的 127。 system() 调时 -1。
 command  NULL  /bin/sh 的 system() 零的
 0。
     的  程  SIGCHILD       的  SIGINT 
SIGQUIT 。实对 SIGINT  SIGQUIT 的实
方式 system() 调的时。调
system()子进程的出。
do {
int ret;
ret = system (”pidof rudderd”);
if (WIFSIGNALED (ret) && (WTERMSIG (ret) ==
SIGINT || WTERMSIG (ret) == SIGQUIT))
break; /* or otherwise handle */
} while (1);
 fork()、 exec 调 waitpid() 实 system() 的
。自的。性
单的实
– 156 –
 5 
进程理
/*
* my_system - synchronously spawns and waits for
the command
* ”/bin/sh -c ”.
*
* Returns -1 on error of any sort, or the exit
code from the
* launched process. Does not block or ignore any
signals.
*/
int my_system (const char *cmd)
{
int status;
pid_t pid;
pid = fork ( );
if (pid == -1)
return -1;
else if (pid == 0) {
const char *argv[4];
argv[0] = ”sh”;
argv[1] = ”-c”;
argv[2] = cmd;
argv[3] = NULL;
execv (”/bin/sh”, argv);
exit (-1);
}
if (waitpid (pid, &status, 0) == -1)
return -1;
else if (WIFEXITED (status))
return WEXITSTATUS (status);
return -1;
}
– 157 –
 5 
进程理
子式的 system()或何。
程的能能。 SIGINT 
的以的时的。
的实以将的空时同的
。能 fork failed  shell failed。
5.4.5 僵死进程
提的进程的进程
进程进程。进程
进程的。的
进程子进程的时提相的。进程
的内的进程存。
然何 Unix 的或或的进程。进
程进程 (ghosts)进程相的进程。的进程
子进程子进程（的周
即的子进程的。的子进程
进程存。们的进程的程
.
然进程子进程或进程
的子进程何时进程内
的子进程们的进程新设 init 进程（pid  1 的
进程。存进程的进程。 init 进程周性的
子进程时间存的进程进程。进
程子进程或出子进程 init 进程
子进程的进程们的出。的处
理方式周的进程的子进
程。
5.5 用户和组
的进程相的。
ID  ID  C 的 uid t  gid t 示。示读
间的映射（ root 的 uid  0空间的 /etc/passwd 
– 158 –
 5 
进程理
/etc/group 文件的。内处理示的式。
 Linux 进程的 ID  ID 进程以操
作。进程以的。的进程以 root 的。然
的方式小的原进程的以小
的。的进程以 root 的
 root 能的 root
。进程 root 操作时
操作自的 ID 或 ID。
我们何实我们 ID  ID 的
性。
5.5.1 实际用户 (组)ID、有效用户 (组)ID 和保存设置的用户 (组)ID
的集 ID 上 ID 的的。
实上进程相的 ID 们
实 ID、效 ID、存设的 ID 文件
 ID。实 ID 进程的的 uid。
的 uid 设进程的实 ID exec 
调。进程将的 shell 的实
 ID 设的 ID进程的实 ID 
。超（root能实 ID 的
能的。
效 ID 进程的 ID。。
时 ID 实 ID。进程时子进程进程的效
 ID。更进步的 exec 调效 ID。 exec 调
程实 ID 效 ID 的出 setuid (suid) 程
进程以自的效 ID。的效 ID 设
程文件的 ID。 /usr/bin/passwd  setuid 文件的
 root 。进程
进程的效 ID  root 的 ID。
能效 ID 设实 ID 或存
设的 ID。超以效 ID 设何。
存设的 ID 进程原的效 ID。进程时子进程
– 159 –
 5 
进程理
进程存设的 ID。对 exec 调内存设的
 ID 设效 ID exex 调程存效
ID 的。能存设的 ID 的超以设
实 ID 的。
的 ID 效 ID 的作进程
程的 ID。实 ID 存设的 ID 理或
的 ID 的作 root 进程 ID 间相。实
 ID 真程的效 id。存设的 ID  suid 程
的效 id。
5.5.2 改变实际用户 (组)ID 和保存设置的用户 (组)ID
 ID  ID 调设的
#include 
#include 
int setuid (uid_t uid);
int setgid (gid_t gid);
setuid() 设进程的效 ID。进程的效 ID 
0（root实 ID 存设的 ID 的同时设。 root
以 uid 提何将 ID 的设 uid。 root
将实 ID 存设的 ID 设 uid。 root 
能将效 ID 设上的。
调时 setuid()  0。时 -1 errno 设的
EAGAIN uid 的实 ID 的同实 ID 的的 uid 
超 NPROC 的（以的进程
。
EPERM
 root  uid 效 ID 存设的 ID。
的对然的将 setuid()  setgid() uid 