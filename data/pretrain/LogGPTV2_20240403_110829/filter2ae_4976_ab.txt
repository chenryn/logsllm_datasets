### 优化后的文本

#### e 修饰符
在第二个参数中，可以看到攻击有效负载被拆分为多个字符串，并通过 `.` 运算符连接。攻击者还使用了 `strrev` 函数来反转字符串 "lave" 的顺序，从而得到 "eval"。最终连接后的有效负载如下：

```
...
```

该代码不仅使用 Base64 编码，还使用了 "deflate" 数据格式进行压缩。解码和解压缩后，我们得到以下有效负载：

```
...
```

这表明在 GET 或 POST 请求中，会评估 "error" 参数中发送的代码。

#### 字符串替换、连接和编码
**图6：使用字符串替换隐藏函数名称并用 Base64 编码的后门程序**

在此示例中，攻击者将函数名称隐藏在变量中，并对后门本身进行了 Base64 编码以模糊处理。唯一可见的关键字是第2行中的 `str_replace`，仅使用一次。

让我们详细分析这段代码的工作原理：
1. **第2行**：参数 `tsdg` 被赋予值 `str_replace`，取字符串 `bsbtbrb_rbebpblacb e` 并删除所有字母 `b`。
   - 攻击者通过创建包含附加字母的字符串来混淆已知的 PHP 函数，然后使用 `str_replace` 删除这些字母。
2. **第6-7行**：参数 `zjzy` 被赋予值 `base64_decode`，参数 `liiy` 被赋予值 `create_function`。
   - 使用参数 `tsdg` 而不是直接使用 `str_replace` 函数，以逃避检测。
3. **第1-5行**：还有四个参数包含 Base64 编码的文本。
   - 在第8行中，这些参数的值按特定顺序连接，形成一个长的 Base64 编码字符串。
4. **第8行**：参数 `iuwt` 包含以下代码行：
   ```php
   ...
   ```
   - 此代码将创建一个函数，从 Base64 编码的文本中删除所有 "hd"，然后解码它。
5. **第9行**：执行此函数并将 Base64 编码的文本解码为：
   **图7：解码后的 Base64 文本**
   - 这是后门本身，它将执行通过 cookie 发送到受感染服务器的代码。
   - 第6行中使用 `preg_replace` 函数和两个正则表达式更改通过 cookie 发送的值。
   - 更改后的文本经过 Base64 解码并执行，运行攻击者发送的任意代码。

这个后门的逃避技术比我们在前一节中看到的要复杂得多。除了使用参数而不是 PHP 函数外，后门本身也经过 Base64 编码。此外，为了防止简单的 Base64 解码机制，Base64 文本被分成四个部分，并在随机位置添加字符 "hd" 以阻止解码。

#### O 和 0 Catch
**图8：使用多种规避技术的后门程序。所有参数名称都由 O 和 0 组成**

在这个后门中，逃避技术更加复杂，需要更多的步骤才能找到真正的后门：
- 只有两个可见的已知函数是 `urldecode`（用于解码 URL）和 `eval`（用于执行代码）。
- 所有参数名称都由零 (0) 和大写字母 O 组合而成，这两个字符在视觉上相似，使得代码难以阅读和理解。
- 使用先前解码的 URL 中的字符串联接为每个这样的参数分配字符串。

参数值如下：
- **第3行**：`'strtr'`
- **第4行**：`'substr'`
- **第5行**：`'52'`
- **第2 + 6行**：连接在一起形成 `'base64_decode'`

最后，在第7行中，一个长的 Base64 编码文本被解码，然后使用先前定义的 `base64_decode` 参数执行。解码后的文本如下：
**图9：Base64 解码文本。由于存在由 O 和 0 组成的参数，代码仍然是不可读的**

这不是后门本身，而是逃避的又一步。这里，先前定义的 O 和 0 的参数再次被使用。
- **第1行**：包含另一个用 Base64 编码的长文本，但这次解码更复杂，不能按原样解码。
- 将第2行中的参数替换为其值，可得到以下代码行：
  **图10：与之前相同的代码，用其值替换参数**
- 剩余的 O 和 0 参数是第1行的编码 Base64 文本。此命令获取编码文本偏移量为104的部分，然后创建一个映射到编码文本的第二个52个字符的前52个字符，并使用 `strtr` 函数将字符替换为字符。
- 然后，使用 `eval` 函数对被操纵的文本进行 Base64 解码和执行。不使用上述地图就不可能解码文本。
- 最终，文本被解码为实际的后门：
  **图11：Base64 解码后的后门本身。揭示了攻击者的真实意图**

现在，攻击者的真实意图被揭露了。此后门的目的是创建一个包含 "input" 标签的新 HTML 表单，使攻击者能够上传文件。然后，攻击者可以上传他选择的文件，后门将其移动到受攻击服务器内的攻击者指定的目录。后门还通过打印相应的消息指示文件是否已成功移动到所需的文件夹。

### 逃避技术摘要
如上例所示，攻击者正在尽最大努力隐藏其恶意代码并逃避检测。我们在攻击者使用的数据中看到的一些技术包括：
- 使用字符串操作隐藏已知的 PHP 函数（替换、连接、反向、移位和拆分）
- 使用模糊的参数名称，如随机字符或字符 O 和 0 的组合，它们在视觉上相似
- 使用 Base64 编码对后门或其部分代码进行编码
- 使用压缩作为隐藏后门代码的方法
- 通过操纵文本来混淆 Base64 编码的文本以避免简单的解码
- 通过在输入上使用 `preg_replace` 函数上传后发送到后门的请求

### 缓解建议
有几个预防措施可以减轻后门攻击：
1. **在后门上传点进行拦截**：这是阻止后门的最佳位置，因为它甚至在上传到受感染的服务器之前就已经发生了。通常，后门的上传是通过利用已知漏洞或未经授权的文件上传完成的。建议使用易受 RCE 漏洞影响的服务器的组织应用最新的供应商补丁。手动修补的替代方法是虚拟修补，它可以主动保护 Web 应用程序免受攻击，减少暴露窗口，并降低紧急补丁和修复周期的成本。
2. **检查上传的代码**：在上传后门时，可以检查上传的代码是否有恶意内容。由于攻击者会对代码进行模糊处理，因此检查代码可能很复杂。使用静态安全规则和签名可能会导致有限的成功。相反，动态规则包括分析应用程序的正常行为并警告任何偏差。
3. **阻止攻击者和后门之间的通信**：如果后门已经上传到受感染的服务器上，则可以阻止攻击者和后门之间的通信。这种方法会阻止后门工作并向服务器管理员发出警报，以便可以删除后门。

审核人：yiwang  
编辑：边边