and in the two ASIST setups. To evaluate the performance of
sqlite3 we used the C/C++ SQLite interface to implement a
simple benchmark that reads a large tab-separated ﬁle and updates
a table’s entries with the respective values. Figure 9 shows the
slowdown when inserting data into the database using this bench-
mark as a function of the number of insertions. ASIST imposes
less than 1% slowdown on the database’s operation for both static
and dynamic approaches, even on small datasets that do not provide
ASIST with enough time to amortize the encryption overhead.
6. RELATED WORK
Instruction Set Randomization. ISR was initially introduced
as a generic defense against code injections by Kc et al. [31] and
Barrantes et al. [9, 10]. To demonstrate the feasibility of ISR, they
proposed implementations with bochs [33] and Valgrind [36]
respectively. Hu et al. [29] implemented ISR with Strata SDT
tool [42] using AES as a stronger encryption for instruction ran-
domization. Boyd et al. [13] propose a selective ISR to reduce the
runtime overhead. Portokalidis and Keromytis [41] implemented
ISR using Pin [34] with moderate overhead and shared libraries
support. In Section 2.3 we described in more detail all the existing
software-based ISR implementations and we compared them with
ASIST. ASIST addresses most of the limitations of the existing ISR
approaches owing to its simple and efﬁcient hardware support.
Defenses against code injection attacks. Modern hardware
platforms support non-executable data protection, such as the No
eXecute (NX) bit [38]. NX bit prevents stack or heap data from
being executed, so it is capable to protect against code inject at-
tacks without performance degradation. However, its effectiveness
depends on its proper use by software. For instance, an application
may not set the NX bit on all data segments due to backwards com-
patibility constraints, self-modifying code, or bad programming
practices. We believe that ASIST can be used complementary to
NX bit to serve as an additional layer of security, e.g., in case that
NX bit may not be applicable or can be bypassed. For instance,
many ROP exploits use the code of mprotect() to make exe-
cutable pages with injected code, bypassing the NX bit protection.
This way, they can execute arbitrary code to implement the attack
without the need of more speciﬁc gadgets, which may not be easy
to ﬁnd, e.g., due to the use of Address Space Layout Randomiza-
tion (ASLR). In contrast, these exploits cannot execute any injected
code in a system using ASIST, as this code will not be correctly en-
crypted. Thus, ASIST with ASLR provides a stronger defense.
Vanilla
ASIST-Static
ASIST-Dynamic
n
w
o
d
w
o
S
l
1.20
1.15
1.10
1.05
1.00
0.95
0.90
1 2 4 8 1
3
6
1
2
5
1
2
4
8
6
2
4
2
5
1
0
0
0
1
8
6
2
2
4
9
9
4
8
6
2
File size (KB)
n
w
o
d
w
o
S
l
1.20
1.15
1.10
1.05
1.00
0.95
0.90
Vanilla
ASIST-Static
ASIST-Dynamic
128
256
512 1024 2048 4096 8192
Table Insertions
Figure 8: Slowdown when downloading different ﬁles from a
lighttpd Web server as a function of the ﬁle size. We see that
ASIST adds less than 1% delay for all ﬁle sizes.
Figure 9: Slowdown when inserting data into sqlite3 as a func-
tion of the number of insertions. We see that ASIST experiences
less than 1% slowdown even for very small datasets.
A recent attack demonstrated by Snow et al. [47] is also able to
bypass NX bit and ASLR protection using ROP. First, it exploits
a memory disclosure to map process’s memory layout, and then it
uses a disassembler to dynamically discover gadgets that can be
used for the ROP attack. ASIST with ASLR, however, is able to
prevent this attack: even if memory with executable code leaks to
the attacker, the instructions will be encrypted with a randomly-
generated key. This way, attacker will not be able to disassemble
the code and ﬁnd useful gadgets. ASIST ensures that key does not
reside in process’s memory, while stronger encryption algorithms
(like AES) can also ﬁt in our design to avoid inferring the key.
SecVisor [43] protects the kernel from code injection attacks us-
ing a hypervisor to prevent unauthorized code execution. While
SecVisor focuses on kernel’s code integrity, ASIST prevents the
execution of unauthorized code in both user- and kernel-level.
Defenses against buffer overﬂow attacks. StackGuard [21]
uses canaries to protect the stack, while PointGuard [20] encrypts
all pointers while they reside in memory and decrypts them before
they are loaded into a register. Both techniques are implemented
with compiler extensions, so they require program recompilation.
In contrast, BinArmor [46] protects existing binaries from buffer
overﬂows without access to source code, by discovering the data
structures and then rewriting the binary.
Other randomization-based defenses. Address Space Layout
Randomization (ASLR) [39] randomizes the memory layout of a
process at runtime or at compile time to protect against code-reuse
attacks. Giuffrida et al. [27] propose an approach with address
space randomization to protect the operating system kernel. Bhatkar
et al. [11] present randomization techniques for the addresses of
the stack, heap, dynamic libraries, routines and static data in an
executable. Wartell et al. [52] randomize the instruction addresses
at each execution to address code-reuse attacks. Jiang et al. [30]
prevent code injections by randomizing the system call numbers.
Hardware support for security. There are numerous research
efforts aiming to provide hardware support for security without sac-
riﬁcing performance. Dalton et al. [22, 23] propose a hardware-
based architecture for dynamic information ﬂow tracking, by ex-
tending a SPARC V8 processor with four tag bits per each register
and memory word, as well as with tag propagation and runtime
checks to defend against buffer overﬂows and high-level attacks.
Greathouse et al. [28] present a design for accelerating dynamic
analysis techniques with hardware support for unlimited watch-
points. These efforts signiﬁcantly reduce the performance cost for
dynamic information ﬂow analysis, which has a very high overhead
in software-based implementations. Frantzen and Shuey [25] im-
plement a hardware-assisted technique for the SPARC architecture
to protect the return address. Tuck et al. [50] propose hardware en-
cryption to protect function pointers from buffer overﬂow attacks
with improved performance, extending the computationally expen-
sive software-based pointer encryption used by pointguard [20].
Our approach is similar to these works: we also propose hardware
support for another existing technique that prevents the execution
of any code that is not authorized to run in the system.
7. CONCLUSIONS
We have presented the design, implementation and evaluation of
ASIST: a hardware-assisted architecture for ISR support. ASIST is
designed to offer (i) improved performance, without runtime over-
head, (ii) improved security, by protecting the operating system
and resisting key guessing attempts, and (iii) transparent opera-
tion, with shared libraries support and no need for any program
modiﬁcations. Our experimental evaluation shows that ASIST does
not impose any signiﬁcant overhead (less than 1.5%), while it is
able to prevent code injection attacks that exploit user-level and
kernel-level vulnerabilities. We have also proposed a new approach
for dynamic code encryption at the page fault handler when code is
ﬁrst loaded into process’s memory. This approach transparently en-
crypts unmodiﬁed binaries that may use shared libraries with a new
key at each execution, offering protection against incremental key
guessing attacks. Our results indicate that dynamic code encryption
is efﬁcient, without adding any overhead, due to the low text page
fault rate. Our work shows that ASIST can address most of the
limitations of existing software-based ISR implementations while
adding less than 0.7% additional hardware to a SPARC processor.
We believe that ASIST can be easily ported to other architectures
to strengthen existing defenses against code injection attacks.
Acknowledgments
We thank the anonymous reviewers for their valuable feedback.
We also thank the Computer Architecture and VLSI Systems Lab
of FORTH-ICS for providing access to FPGAs and design tools.
The project was co-ﬁnanced by the European Regional Develop-
ment Fund (ERDF) and national funds, under the Operational Pro-
gramme “Competitiveness & Entrepreneurship” (OPCE II), Mea-
sure “COOPERATION” (Action I). This work was also supported
in part by the European Union’s Prevention of and Fight against
Crime Programme “Illegal Use of Internet” - ISEC 2010 Action
Grants, grant ref. HOME/2010/ISEC/AG/INT-002, and by the FP7
projects NECOMA and SysSec, funded by the European Commis-
sion under Grant Agreements No. 608533 and No. 257007.
8. REFERENCES
[1] The SPARC Architecture Manual, Version 8. www.sparc.com/
standards/V8.pdf.
[2] USA National Vulnerability Database. http://web.nvd.nist.
gov/view/vuln/statistics.
[3] Linux Kernel Remote Buffer Overﬂow Vulnerabilities. http://
secwatch.org/advisories/1013445/, 2006.
[4] OpenBSD IPv6 mbuf Remote Kernel Buffer Overﬂow. http://www.
securityfocus.com/archive/1/462728/30/0/threaded,
2007.
[5] Microsoft Security Bulletin MS08-067 – Critical. http://www.
microsoft.com/technet/security/Bulletin/MS08-067.
mspx, 2008.
[6] Microsoft Windows TCP/IP IGMP MLD Remote Buffer Overﬂow
Vulnerability. http://www.securityfocus.com/bid/27100,
2008.
[7] Microsoft security advisory (975191): Vulnerabilities in the ftp service in
internet information services. http://www.microsoft.com/
technet/security/advisory/975191.mspx, 2009.
[8] Microsoft security advisory (975497): Vulnerabilities in smb could allow
remote code execution. http://www.microsoft.com/technet/
security/advisory/975497.mspx, 2009.
[9] E. G. Barrantes, D. H. Ackley, S. Forrest, and D. Stefanovi´c. Randomized
Instruction Set Emulation. ACM Transactions on Information and System
Security, 8(1), 2005.
[10] E. G. Barrantes, D. H. Ackley, T. S. Palmer, D. Stefanovic, and D. D.
Zovi. Randomized Instruction Set Emulation to Disrupt Binary Code
Injection Attacks. In ACM Conference on Computer and Communications
Security (CCS), 2003.
[11] S. Bhatkar, D. C. DuVarney, and R. Sekar. Address Obfuscation: an
Efﬁcient Approach to Combat a Board Range of Memory Error Exploits.
In USENIX Security Symposium, 2003.
[12] T. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang. Jump-Oriented
Programming: A New Class of Code-Reuse Attack. In ACM Symposium
on Information, Computer and Communications Security (ASIACCS),
2011.
[13] S. W. Boyd, G. S. Kc, M. E. Locasto, A. D. Keromytis, and V. Prevelakis.
On the General Applicability of Instruction-Set Randomization. IEEE
Transactions on Dependable Secure Computing, 7(3), 2010.
[14] E. Buchanan, R. Roemer, H. Shacham, and S. Savage. When Good
Instructions Go Bad: Generalizing Return-Oriented Programming to
RISC. In ACM Conference on Computer and Communications Security
(CCS), 2008.
[15] P. P. Bungale and C.-K. Luk. PinOS: A Programmable Framework for
Whole-System Dynamic Instrumentation. In ACM SIGPLAN/SIGOPS
Conference on Virtual Execution Environments (VEE), 2007.
[28] J. L. Greathouse, H. Xin, Y. Luo, and T. Austin. A Case for Unlimited
Watchpoints. In ACM Intrnational Conference on Architectural Support
for Programming Languages and Operating Systems (ASPLOS), 2012.
[29] W. Hu, J. Hiser, D. Williams, A. Filipi, J. W. Davidson, D. Evans, J. C.
Knight, A. Nguyen-Tuong, and J. Rowanhill. Secure and Practical
Defense Against Code-Injection Attacks using Software Dynamic
Translation. In ACM SIGPLAN/SIGOPS Conference on Virtual Execution
Environments (VEE), 2006.
[30] X. Jiang, H. J. Wangz, D. Xu, and Y.-M. Wang. RandSys: Thwarting Code
Injection Attacks with System Service Interface Randomization. In IEEE
International Symposium on Reliable Distributed Systems (SRDS), 2007.
[31] G. S. Kc, A. D. Keromytis, and V. Prevelakis. Countering Code-Injection
Attacks With Instruction-Set Randomization. In ACM Conference on
Computer and Communications Security (CCS), 2003.
[32] V. P. Kemerlis, G. Portokalidis, and A. D. Keromytis. kGuard:
Lightweight Kernel Protection Against Return-to-User Attacks. In
USENIX Security Symposium, 2012.
[33] K. P. Lawton. Bochs: A Portable PC Emulator for Unix/X. Linux Journal,
1996.
[34] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,
S. Wallace, V. J. Reddi, and K. Hazelwood. Pin: Building Customized
Program Analysis Tools with Dynamic Instrumentation. In ACM
SIGPLAN Conference on Programming Language Design and
Implementation (PLDI), 2005.
[35] Nergal. The Advanced return-into-lib(c) Exploits: PaX Case Study.
Phrack, 11(58), 2001.
[36] N. Nethercote and J. Seward. Valgrind: A Framework for heavyweight
Dynamic Binary Instrumentation. In ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI), 2007.
[37] J. Oberheide, M. Bailey, and F. Jahanian. PolyPack: An Automated Online
Packing Service for Optimal Antivirus Evasion. In USENIX Workshop on
Offensive Technologies (WOOT), 2009.
[38] L. D. Paulson. New Chips Stop Buffer Overﬂow Attacks. IEEE Computer,
37(10), 2004.
[39] PaX Tream. Homepage of PaX. http://pax.grsecurity.net/.
[40] P. Porras, H. Saidi, and V. Yegneswaran. Conﬁcker C analysis. SRI
International, 2009.
[41] G. Portokalidis and A. D. Keromytis. Fast and Practical Instruction-Set
Randomization for Commodity Systems. In Annual Computer Security
Applications Conference (ACSAC), 2010.
[42] K. Scott, N. Kumar, S. Velusamy, B. Childers, J. W. Davidson, and M. L.
Soffa. Retargetable and Reconﬁgurable Software Dynamic Translation. In
International Symposium on Code Generation and Optimization:
Feedback-Directed and Runtime Optimization (CGO), 2003.
[43] A. Seshadri, M. Luk, N. Qu, and A. Perrig. SecVisor: A Tiny Hypervisor
to Provide Lifetime Kernel Code Integrity for Commodity OSes. In ACM
Symposium on Operating Systems Principles (SOSP), 2007.
[16] H. Chen, Y. Mao, X. Wang, D. Zhou, N. Zeldovich, and M. F. Kaashoek.
[44] S. Sethumadhavan, S. J. Stolfo, A. Keromytis, J. Yang, and D. August.
Linux Kernel Vulnerabilities: State-of-the-Art Defenses and Open
Problems. In Asia-Paciﬁc Workshop on Systems (APSys), 2011.
The SPARCHS Project: Hardware Support for Software Security. In
SysSec Workshop, 2011.
[17] S. Chen, J. Xu, E. C. Sezer, P. Gauriar, and R. K. Iyer. Non-Control-Data
[45] H. Shacham. The Geometry of Innocent Flesh on the Bone:
Attacks Are Realistic Threats. In USENIX Security Symposium, 2005.
[18] S. Christey and A. Martin. Vulnerability Type Distributions in CVE.
http://cve.mitre.org/docs/vuln-trends/
vuln-trends.pdf, 2007.
[19] C. Cowan, M. Barringer, S. Beattie, G. Kroah-Hartman, M. Frantzen, and
J. Lokier. FormatGuard: Automatic Protection From printf Format String
Vulnerabilities. In USENIX Security Symposium, 2001.
[20] C. Cowan, S. Beattie, J. Johansen, and P. Wagle. PointguardTM:
Protecting Pointers from Buffer Overﬂow Vulnerabilities. In USENIX
Security Symposium, 2003.
[21] C. Cowan, C. Pu, D. Maier, H. Hintony, J. Walpole, P. Bakke, S. Beattie,
A. Grier, P. Wagle, and Q. Zhang. StackGuard: Automatic Adaptive
Detection and Prevention of Buffer-Overﬂow Attacks. In USENIX
Security Symposium, 1998.
Return-into-libc without Function Calls (on the x86). In ACM Conference
on Computer and Communications Security (CCS), 2007.
[46] A. Slowinska, T. Stancescu, and H. Bos. Body Armor for Binaries:
Preventing Buffer Overﬂows Without Recompilation. In USENIX Annual
Technical Conference (ATC), 2012.
[47] K. Z. Snow, L. Davi, A. Dmitrienko, C. Liebchen, F. Monrose, and A.-R.
Sadeghi. Just-In-Time Code Reuse: On the Effectiveness of Fine-Grained
Address Space Layout Randomization. In IEEE Symposium on Security
and Privacy, 2013.
[48] A. N. Sovarel, D. Evans, and N. Paul. Where’s the FEEB? the
Effectiveness of Instruction Set Randomization. In USENIX Security
Symposium, 2005.
[49] Standard Performance Evaluation Corporation (SPEC). SPEC CINT2006
Benchmarks. http://www.spec.org/cpu2006/CINT2006.
[22] M. Dalton, H. Kannan, and C. Kozyrakis. Raksha: A Flexible Information
[50] N. Tuck, B. Calder, and G. Varghese. Hardware and Binary Modiﬁcation
ﬂow Architecture for Software Security. In ACM/IEEE International
Symposium on Computer Architecture (ISCA), 2007.
Support for Code Pointer Protection From Buffer Overﬂow. In IEEE/ACM
International Symposium on Microarchitecture (MICRO), 2004.
[23] M. Dalton, H. Kannan, and C. Kozyrakis. Real-World Buffer Overﬂow
[51] X. Wang, H. Chen, Z. Jia, N. Zeldovich, and M. F. Kaashoek. Improving
Protection for Userspace & Kernelspace. In USENIX Security Symposium,
2008.
Integer Security for Systems with KINT. In USENIX Symposium on
Operating System Design and Implementation (OSDI), 2012.
[24] D. Danchev. Managed polymorphic script obfuscation services. http://
[52] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin. Binary Stirring:
ddanchev.blogspot.com/2009/08/
managed-polymorphic-script-obfuscation.html, 2009.
[25] M. Frantzen and M. Shuey. StackGhost: Hardware Facilitated Stack
Protection. In USENIX Security Symposium, 2001.
[26] Gaisler Research. Leon3 synthesizable processor. http://www.
gaisler.com.
[27] C. Giuffrida, A. Kuijsten, and A. S. Tanenbaum. Enhanced Operating
System Security Through Efﬁcient and Fine-grained Address Space
Randomization. In USENIX Security Symposium, 2012.
Self-randomizing Instruction Addresses of Legacy x86 Binary Code. In
ACM Conference on Computer and Communications Security (CCS),
2012.
[53] Y. Weiss and E. G. Barrantes. Known/Chosen Key Attacks against
Software Instruction Set Randomization. In Annual Computer Security
Applications Conference (ACSAC), 2006.
[54] Xilinx. Xilinx University Program XUPV5-LX110T Development
System. http://www.xilinx.com/support/
documentation/boards_and_kits/ug347.pdf, 2011.