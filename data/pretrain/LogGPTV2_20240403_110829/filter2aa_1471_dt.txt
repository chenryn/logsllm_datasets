RE
AM
M
a
y
b
e
This attribute type can be used for various purposes by 
different NTFS components. See Table 11-7 for more 
details.
Table 11-7 $LOGGED_UTILITY_STREAM attribute
Attri
bute
Att
rib
ute 
Typ
e 
Na
me
R
es
id
e
nt
?
Description
Encr
ypte
d 
File 
Strea
m
$EF
S
M
a
y
b
e
EFS stores data in this attribute that’s used to 
manage a file’s encryption, such as the encrypted 
version of the key needed to decrypt the file and a 
list of users who are authorized to access the file.
Onli
ne 
encr
yptio
n 
back
up
$Ef
sBa
cku
p
M
a
y
b
e
The attribute is used by the EFS Online encryption 
to store chunks of the original encrypted data 
stream.
Tran
sacti
onal 
NTF
SDat
a
$T
XF_
DA
TA
M
a
y
b
e
When a file or directory becomes part of a 
transaction, TxF also stores transaction data in the 
$TXF_DATA attribute, such as the file’s unique 
transaction ID.
Desir
ed 
Stora
ge 
$DS
C
R
es
id
e
The desired storage class is used for “pinning” a file 
to a preferred storage tier. See the “NTFS support 
for tiered volumes” section for more details.
Class
nt
Table 11-6 shows attribute names; however, attributes actually correspond
to numeric type codes, which NTFS uses to order the attributes within a file
record. The file attributes in an MFT record are ordered by these type codes
(numerically in ascending order), with some attribute types appearing more
than once—if a file has multiple data attributes, for example, or multiple file
names. All possible attribute types (and their names) are listed in the
$AttrDef metadata file.
Each attribute in a file record is identified with its attribute type code and
has a value and an optional name. An attribute’s value is the byte stream
composing the attribute. For example, the value of the $FILE_NAME
attribute is the file’s name; the value of the $DATA attribute is whatever
bytes the user stored in the file.
Most attributes never have names, although the index-related attributes and
the $DATA attribute often do. Names distinguish between multiple attributes
of the same type that a file can include. For example, a file that has a named
data stream has two $DATA attributes: an unnamed $DATA attribute storing
the default unnamed data stream, and a named $DATA attribute having the
name of the alternate stream and storing the named stream’s data.
File names
Both NTFS and FAT allow each file name in a path to be as many as 255
characters long. File names can contain Unicode characters as well as
multiple periods and embedded spaces. However, the FAT file system
supplied with MS-DOS is limited to 8 (non-Unicode) characters for its file
names, followed by a period and a 3-character extension. Figure 11-35
provides a visual representation of the different file namespaces Windows
supports and shows how they intersect.
Figure 11-35 Windows file namespaces.
Windows Subsystem for Linux (WSL) requires the biggest namespace of
all the application execution environments that Windows supports, and
therefore the NTFS namespace is equivalent to the WSL namespace. WSL
can create names that aren’t visible to Windows and MS-DOS applications,
including names with trailing periods and trailing spaces. Ordinarily, creating
a file using the large POSIX namespace isn’t a problem because you would
do that only if you intended WSL applications to use that file.
The relationship between 32-bit Windows applications and MS-DOS and
16-bit Windows applications is a much closer one, however. The Windows
area in Figure 11-35 represents file names that the Windows subsystem can
create on an NTFS volume but that MS-DOS and 16-bit Windows
applications can’t see. This group includes file names longer than the 8.3
format of MS-DOS names, those containing Unicode (international)
characters, those with multiple period characters or a beginning period, and
those with embedded spaces. For compatibility reasons, when a file is created
with such a name, NTFS automatically generates an alternate, MS-DOS-style
file name for the file. Windows displays these short names when you use the
/x option with the dir command.
The MS-DOS file names are fully functional aliases for the NTFS files and
are stored in the same directory as the long file names. The MFT record for a
file with an autogenerated MS-DOS file name is shown in Figure 11-36.
Figure 11-36 MFT file record with an MS-DOS file name attribute.
The NTFS name and the generated MS-DOS name are stored in the same
file record and therefore refer to the same file. The MS-DOS name can be
used to open, read from, write to, or copy the file. If a user renames the file
using either the long file name or the short file name, the new name replaces
both the existing names. If the new name isn’t a valid MS-DOS name, NTFS
generates another MS-DOS name for the file. (Note that NTFS only
generates MS-DOS-style file names for the first file name.)
 Note
Hard links are implemented in a similar way. When a hard link to a file is
created, NTFS adds another file name attribute to the file’s MFT file
record, and adds an entry in the Index Allocation attribute of the directory
in which the new link resides. The two situations differ in one regard,
however. When a user deletes a file that has multiple names (hard links),
the file record and the file remain in place. The file and its record are
deleted only when the last file name (hard link) is deleted. If a file has
both an NTFS name and an autogenerated MS-DOS name, however, a
user can delete the file using either name.
Here’s the algorithm NTFS uses to generate an MS-DOS name from a
long file name. The algorithm is actually implemented in the kernel function
RtlGenerate8dot3Name and can change in future Windows releases. The
latter function is also used by other drivers, such as CDFS, FAT, and third-
party file systems:
1. 
Remove from the long name any characters that are illegal in MS-
DOS names, including spaces and Unicode characters. Remove
preceding and trailing periods. Remove all other embedded periods,
except the last one.
2. 
Truncate the string before the period (if present) to six characters (it
may already be six or fewer because this algorithm is applied when
any character that is illegal in MS-DOS is present in the name). If it is
two or fewer characters, generate and concatenate a four-character
hex checksum string. Append the string ~n (where n is a number,
starting with 1, that is used to distinguish different files that truncate
to the same name). Truncate the string after the period (if present) to
three characters.
3. 
Put the result in uppercase letters. MS-DOS is case-insensitive, and
this step guarantees that NTFS won’t generate a new name that differs
from the old name only in case.
4. 
If the generated name duplicates an existing name in the directory,
increment the ~n string. If n is greater than 4, and a checksum was not
concatenated already, truncate the string before the period to two
characters and generate and concatenate a four-character hex
checksum string.
Table 11-8 shows the long Windows file names from Figure 11-35 and
their NTFS-generated MS-DOS versions. The current algorithm and the
examples in Figure 11-35 should give you an idea of what NTFS-generated
MS-DOS-style file names look like.
Table 11-8 NTFS-generated file names
Windows Long Name
NTFS-Generated Short Name
LongFileName
LONGFI~1
UnicodeName.FDPL
UNICOD~1
File.Name.With.Dots
FILENA~1.DOT
File.Name2.With.Dots
FILENA~2.DOT
File.Name3.With.Dots
FILENA~3.DOT
File.Name4.With.Dots
FILENA~4.DOT
File.Name5.With.Dots
FIF596~1.DOT
Name With Embedded Spaces
NAMEWI~1
.BeginningDot
BEGINN~1
25¢.two characters
255440~1.TWO
©
6E2D~1
 Note
Since Windows 8.1, by default all the NTFS nonbootable volumes have
short name generation disabled. You can disable short name generation
even in older version of Windows by setting
HKLM\SYSTEM\CurrentControlSet\Control\FileSystem\NtfsDisable8dot
3NameCreation in the registry to a DWORD value of 1 and restarting the
machine. This could potentially break compatibility with older
applications, though.
Tunneling
NTFS uses the concept of tunneling to allow compatibility with older
programs that depend on the file system to cache certain file metadata for a
period of time even after the file is gone, such as when it has been deleted or
renamed. With tunneling, any new file created with the same name as the
original file, and within a certain period of time, will keep some of the same
metadata. The idea is to replicate behavior expected by MS-DOS programs
when using the safe save programming method, in which modified data is
copied to a temporary file, the original file is deleted, and then the temporary
file is renamed to the original name. The expected behavior in this case is that
the renamed temporary file should appear to be the same as the original file;
otherwise, the creation time would continuously update itself with each
modification (which is how the modified time is used).
NTFS uses tunneling so that when a file name is removed from a directory,
its long name and short name, as well as its creation time, are saved into a
cache. When a new file is added to a directory, the cache is searched to see
whether there is any tunneled data to restore. Because these operations apply
to directories, each directory instance has its own cache, which is deleted if
the directory is removed. NTFS will use tunneling for the following series of
operations if the names used result in the deletion and re-creation of the same
file name:
■    Delete + Create
■    Delete + Rename
■    Rename + Create
■    Rename + Rename
By default, NTFS keeps the tunneling cache for 15 seconds, although you
can modify this timeout by creating a new value called
MaximumTunnelEntryAgeInSeconds in the
HKLM\SYSTEM\CurrentControlSet\Control\FileSystem registry key.
Tunneling can also be completely disabled by creating a new value called
MaximumTunnelEntries and setting it to 0; however, this will cause older
applications to break if they rely on the compatibility behavior. On NTFS
volumes that have short name generation disabled (see the previous section),
tunneling is disabled by default.
You can see tunneling in action with the following simple experiment in
the command prompt:
1. 
Create a file called file1.
2. 
Wait for more than 15 seconds (the default tunnel cache timeout).
3. 
Create a file called file2.
4. 
Perform a dir /TC. Note the creation times.
5. 
Rename file1 to file.
6. 
Rename file2 to file1.
7. 
Perform a dir /TC. Note that the creation times are identical.
Resident and nonresident attributes
If a file is small, all its attributes and their values (its data, for example) fit
within the file record that describes the file. When the value of an attribute is
stored in the MFT (either in the file’s main file record or an extension record
located elsewhere within the MFT), the attribute is called a resident attribute.
(In Figure 11-37, for example, all attributes are resident.) Several attributes
are defined as always being resident so that NTFS can locate nonresident
attributes. The standard information and index root attributes are always
resident, for example.
Figure 11-37 Resident attribute header and value.
Each attribute begins with a standard header containing information about
the attribute—information that NTFS uses to manage the attributes in a
generic way. The header, which is always resident, records whether the
attribute’s value is resident or nonresident. For resident attributes, the header
also contains the offset from the header to the attribute’s value and the length
of the attribute’s value, as Figure 11-37 illustrates for the file name attribute.
When an attribute’s value is stored directly in the MFT, the time it takes
NTFS to access the value is greatly reduced. Instead of looking up a file in a
table and then reading a succession of allocation units to find the file’s data
(as the FAT file system does, for example), NTFS accesses the disk once and
retrieves the data immediately.
The attributes for a small directory, as well as for a small file, can be
resident in the MFT, as Figure 11-38 shows. For a small directory, the index
root attribute contains an index (organized as a B-tree) of file record numbers
for the files (and the subdirectories) within the directory.
Figure 11-38 MFT file record for a small directory.
Of course, many files and directories can’t be squeezed into a 1 KB or 4
KB, fixed-size MFT record. If a particular attribute’s value, such as a file’s
data attribute, is too large to be contained in an MFT file record, NTFS
allocates clusters for the attribute’s value outside the MFT. A contiguous
group of clusters is called a run (or an extent). If the attribute’s value later
grows (if a user appends data to the file, for example), NTFS allocates
another run for the additional data. Attributes whose values are stored in runs
(rather than within the MFT) are called nonresident attributes. The file
system decides whether a particular attribute is resident or nonresident; the
location of the data is transparent to the process accessing it.
When an attribute is nonresident, as the data attribute for a large file will
certainly be, its header contains the information NTFS needs to locate the
attribute’s value on the disk. Figure 11-39 shows a nonresident data attribute
stored in two runs.
Figure 11-39 MFT file record for a large file with two data runs.
Among the standard attributes, only those that can grow can be
nonresident. For files, the attributes that can grow are the data and the
attribute list (not shown in Figure 11-39). The standard information and file
name attributes are always resident.
A large directory can also have nonresident attributes (or parts of
attributes), as Figure 11-40 shows. In this example, the MFT file record
doesn’t have enough room to store the B-tree that contains the index of files
that are within this large directory. A part of the index is stored in the index
root attribute, and the rest of the index is stored in nonresident runs called
index allocations. The index root, index allocation, and bitmap attributes are
shown here in a simplified form. They are described in more detail in the
next section. The standard information and file name attributes are always
resident. The header and at least part of the value of the index root attribute
are also resident for directories.
Figure 11-40 MFT file record for a large directory with a nonresident file
name index.
When an attribute’s value can’t fit in an MFT file record and separate
allocations are needed, NTFS keeps track of the runs by means of VCN-to-
LCN mapping pairs. LCNs represent the sequence of clusters on an entire
volume from 0 through n. VCNs number the clusters belonging to a
particular file from 0 through m. For example, the clusters in the runs of a
nonresident data attribute are numbered as shown in Figure 11-41.
Figure 11-41 VCNs for a nonresident data attribute.
If this file had more than two runs, the numbering of the third run would
start with VCN 8. As Figure 11-42 shows, the data attribute header contains
VCN-to-LCN mappings for the two runs here, which allows NTFS to easily
find the allocations on the disk.
Figure 11-42 VCN-to-LCN mappings for a nonresident data attribute.
Although Figure 11-41 shows just data runs, other attributes can be stored
in runs if there isn’t enough room in the MFT file record to contain them.
And if a particular file has too many attributes to fit in the MFT record, a
second MFT record is used to contain the additional attributes (or attribute
headers for nonresident attributes). In this case, an attribute called the
attribute list is added. The attribute list attribute contains the name and type
code of each of the file’s attributes and the file number of the MFT record
where the attribute is located. The attribute list attribute is provided for those
cases where all of a file’s attributes will not fit within the file’s file record or
when a file grows so large or so fragmented that a single MFT record can’t
contain the multitude of VCN-to-LCN mappings needed to find all its runs.
Files with more than 200 runs typically require an attribute list. In summary,
attribute headers are always contained within file records in the MFT, but an
attribute’s value may be located outside the MFT in one or more extents.