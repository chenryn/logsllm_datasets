message, the associated symbolic information may be
lost. To address the problem, we ﬁll the gap between
senders and receivers by synchronizing the symbol
information in both sides (Section V-B3).
•
Figure 4: Intent In Inter-Apps Communications
Array-indexing class implicit ﬂows: In array-indexing
type operations, if the index is symbolic, it is challeng-
ing to determine which element should be returned. The
problem is known as "implicit ﬂow". Similar problems
also exist in other data structures such as Hashmap,
Android Bundle, and Android share preference. In real
world, this type of operations and data structures was
frequently used in popular apps and ad libs, such as
Google Ads.
To further demonstrate the problem, we use Hashmap
as the example. As Figure 5 shows, in Java, Hashmap is
implemented based on a bucket array with linked lists
that are used to handle hashing collisions. Assume
that the instruction v = M.get(k) is being executed,
where M is the Hashmap object, k is the key and it
is symbolized as ‘key’. In the function Hashmap.get(),
the bucket index is ﬁrstly determined, which is k’s
hashcode. Hence, the index is a symbolic expression
built on key. Then, an array-indexing operation is done
to obtain the associated linked-list. Since the index is
symbolic, the operation introduces an implicit ﬂow.
To mitigate the problem, we instrument k to brute-
forcely try all possibilities of keys (Section V-B4).
Figure 5: The Internal Structure Of HashMap
We implement selective symbolic execution by instrument-
ing the Android framework and Dalvik virtual machine (DVM).
In Android frameworks, event handler functions and sensitive
APIs (Section III-E) are handled. In DVM, the mapping between
variables and their corresponding symbolic expressions are
managed through a global symbolic table. To support string
operations, which are frequently faced in event handlers, the
associated string APIs are modeled, including compare, append,
replace, search, substring and split, and we use Z3-Str [42] to
resolve string based path constraints.
9
1) Heuristic Generation: The heuristic information used
in path selection includes the indication of whether a branch is
interesting. To determine it, EOEDroid uses static analysis to
scan a certain number (such as 100) of instructions in advance
to check if a critical functionality is contained.
Due to the imprecision of static analysis, false negatives
may be introduced (Section I). The determination result may
be further inﬂuenced. To eliminate the concern, we also ﬂag
the following types of operations as interesting.
•
•
•
•
Field variables reading and writing: This affects points-
to and alias relationship.
Virtual function invocation: Resolving this kind of
invocations requires points-to information.
Java Reﬂection: Due to the lack of real data, it is
challenging for static analysis to solve this kind of
problems.
Return Instruction: In event handlers, the returned
values of some event handlers (Section V-A) are
meaningful, such as shouldOverrideUrlLoading() and
shouldInterceptRequest(). Take the former event han-
dler as the example: If the event handler returns true,
it means the app being analyzed handles the input.
Otherwise, the Android system processes the input.
2) Analysis Sandbox: To keep the analysis environment
clean, EOEDroid creates a sandbox environment to replace
the real environment. All interactions with the external real
environment is redirected to the sandbox environment. Based
on the access direction, the interactions can be divided into
two categories: writing and reading. For the writing operation,
EOEDroid updates variables’ values in the sandbox instead
of the real environment. For the reading operation, if the
destination variable is written earlier, the corresponding value
in the sandbox is retrieved and returned; otherwise, the value
in the real environment is returned.
In this paper, we consider the interactions include accessing
ﬁle system, global variables, and ﬁeld variables whose scopes
are bigger than the event handler function being analyzed. To
implement them, necessary APIs and instructions are hooked
and handled. For reading and writing ﬁles, the corresponding
POSIX APIs (in libcore\io\Posix.java) are handled. However,
it is challenging to maintain a ﬁle’s status, especially when the
ﬁle is partially modiﬁed. To mitigate the problem, a backup
ﬁle is created, and then all reading and writing operations are
redirected to the backup ﬁle. For reading and writing global
and ﬁeld variables, the associated instructions (i.e., iget/iput,
aget/aput, and sget/sput) [5] are handled. In practice, it is
challenging to determine the scope of a ﬁeld variable. To
simplify the problem, all changes on the ﬁeld variable are
recorded. Please note that in the beginning of each round of
test, all data and ﬁles saved in the sandbox are cleaned.
3) Intent Handler: To ﬁll the symbolic information gap
between Intent message senders and receivers, it is critical to
restore symbolic information of the message in the receiver side.
For this purpose, when the Intent message is sent, EOEDroid
temporally pauses the program by hooking the associated APIs
(such as startActivity(Intent)), makes snapshot on the Intent
object and its corresponding symbolic data, and also saves it.
Then, when the receiver accepts and reads the message using
ƉƉϭƉƉϮsDsD^ĞƌǀŝĐĞDĂŶĂŐĞƌŝŶĚĞƌŶĚƌŽŝĚ>ŝŶƵǆϬƵĐŬĞƚƐŶƚƌŝĞƐϭŶ͙ǀĂůƵĞϭǀĂůƵĞϮsĂůƵĞŵassociated APIs (such as getIntent()), the snapshot is read, and
then the symbolic information is linked with the Intent object.
Considering the sender and receiver may be not in the same
app, such a snapshot is dumped to a public folder, which is
allowed to be accessed by any app.
As variables’ absolute memory addresses are used to save
their symbolic information in the snapshot, in the receiver side
the restored symbolic information cannot be directly applied
in the received Intent message, whose memory addresses
are totally different from the sent message. To correct the
differences, when the snapshot is made in the sender side,
memory addresses are changed to relative addresses, based
on the starting address of the sent message. Then, when the
snapshot is read in the receiver side, memory addresses are
changed back to the absolute addresses, based on the starting
address of the received message.
Furthermore, to distinguish different Intent messages, each
message is assigned a unique ID, which is also used as the
corresponding snapshot’s name. To support it, a new integer
ﬁeld “IntentId” is added into the Intent Java class. Each time
an Intent message is created, the ﬁeld is automatically added
by one.
4) Array-Indexing Type Implicit Flow: To mitigate the
problem caused by this type of implicit ﬂows, we brute-forcely
convert the associated operation into multiple conditional state-
ments. Array and other data structures are handled respectively
as follows.
•
•
Array: Assume the content of an array A is
[e0, e1, e2, ..., en], and in the operation r = A[i], i
is symbolic. The operation can be converted to the
following structure :
if (0 == i) r = e 0 ;
else if (1 == i) r = e 1 ;
...;
else if (n == i) r = e n ;
Next, EOEDroid can handle the operation as regular
conditional statements.
Hashmap, Android Bundle, and Android Share Prefer-
ence: Similar to array-indexing operations, hashmap
type accessing can also be transformed to conditional
statements. Assume that the following instruction is
faced: r = hashmap.get(k). The keys of hashmap is
[k0, k1, k2, ..., kn]. Hence, by instrumenting k’s real
value in memory, the operation can also be converted
to regular conditional statements.
if (k.equals(k 0 )) k = k 0 ;
else if (k.equals(k 1 )) k = k 1 ;
... ;
else if (k.equals(k n )) k = k n ;
r = hashmap.get(k);
To support
the above operations, all keys in the
hashmap object must be retrieved. However, it is
challenging to do that in the low level layer (e.g.,
DVM). To ﬁx the problem, the HashMap class is
instrumented by adding a string array to record all
keys. Thus, in the DVM, all keys can be retrieved by
restoring the values of the added string array.
C. Program State Analysis
To discover how to reach the program state that leads to
the execution of a critical functionality, we deal with the input
and execution order of event handlers respectively.
10
1) Event Handler Input Generation: Given an arbitrary
interesting path, its input can be generated by handling its
associated path constraints that are collected in the ﬁrst phase.
First, input constraints are extracted from the whole path
constraints by ﬁltering out the constraints of non-symbolic
conditional statements. Second, the input can be generated
by resolving the input constraints using an SMT solver (e.g.,
Z3-Str).
•
•
•
2) Event Handler Execution Order Generation: Given a
path that contains a critical functionality, the execution order of
event handlers can be obtained by addressing the event handler
dependency problem. The algorithm is shown in Algorithm 1.
In the algorithm, three critical functions are required as input.
NS(eh, p, insn): Non-symbolic conditional statements
can be extracted by going backward through p starting
from insn and checking the operands of all faced
conditional statements.
get_origin_variables(eh, p, insn, v): We deﬁne the
origin variables as following. If in p, v(cid:48) can inﬂuence
v’s value, v(cid:48) is an origin variable of v. Hence, to
locate all v(cid:48), we go backward through p starting from
insn, and apply backward data ﬂow tracking on v.
If a variable is found in the backward data ﬂow and
located in the external environment, the variable may
be one of v’s origin variables.
get_origin_values(eh, p, O, insn, value): To compute
the expected values of origin variables, we re-run
symbolic execution on p to construct v’s symbolic
expression relying on origin variables. To this end, all
origin variables in the set O are symbolized. Then, p is
executed and analyzed by feeding eh with appropriate
input. Next, when conditional statements are faced, the
path constraint is constructed and saved. After that,
when the instruction insn is faced, the analysis is
ﬁnished. Finally, the values of origin variables can be
generated by resolving the collected path constraints.
D. Exploit Code Generation
Algorithm 2 shows our algorithm to generate the exploit
code. Two main functions (get_web_trigger_code() and get_js(
)) are required. The former function is implemented based on
our study result (Table I), and the latter function is provided
by the sub-module “JavaScript code syntax analysis”.
1) JavaScript Code Syntax Analysis: . It is challenging to
generate required JavaScript code as part of an event handler’s
input. Because the JavaScript code is executed by associated
WebView APIs (such as loadUrl()), the values of these APIs’
parameters provide hints. Suppose the JavaScript code extracted
from input is I, and the JavaScript code that already exists
in associated WebView APIs (such as hard code format) is J.
I + J have complete semantics.
To mitigate the problem, we assume that I is atomic, i.e.,
it is a leaf element in the AST (Abstract Syntax Tree) of I + J.
We can hence generate I based on its position in the AST. More
speciﬁcally, when a WebView API that can execute JavaScript
code (such as WebView.loadUrl()) is executed, its parameter’s
symbolic expression is dumped. Then, by replacing I with
a speciﬁc concrete string (such as a randomized string), the
concrete string of the parameter (i.e., I + J) is generated. Next,
Algorithm 1 Event Order Generation
Input:
1: EH : all event handlers;
2: P(eh) : return all paths in the event handler eh;
3: N S(eh, p, insn) : return all non-symbolic conditional statements before
the instruction insn in the path p of the event handler eh;
4: get_origin_variables(eh, p, insn, v) : return the variable v‘s origin variables
that inﬂuence v’s value;
5: get_origin_values(eh, p, insn, v, value, O) : return the required values for
all origin variables that can assign value to v.
false.
Output: the event order R
1: function GENERATE_EVENT_HANDLER_ORDER(eh, p, expect_insn)
2:
3:
4:
for ns in NS(eh, p, expect_insn) do
c ← ns’s condition expression
v ← c’s value (cid:46) Depending on which branch is taken, v is true or
r ← resolve_event_handler_dependency(eh, p, ns, c, v)
if FAILURE == r then
5:
6:
7:
8:
9:
10:
11: end function
12:
13: function RESOLVE_EVENT_HANDLER_DEPENDENCY(eh, p, insn, variable,
end for
return SUCCESS
return FAILURE
end if
value)
O ← get_origin_variables(eh, p, insn, variable)
if O == φ then
R ← {} return FAILURE
end if
for o in O do
if o ∈ eh’s parameters then
R.add()
end if
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
end for
for (oi, vi) in get_origin_values(eh, p, insn, value, O) do
(cid:46)
Rerun symbolic execution on the path p to compute each origin variable’s
expected value
for eh(cid:48) in E do
for p(cid:48) in P(eh(cid:48)) do
insn(cid:48) ← the instruction writing oi
r ← resolve_event_handler_dependency(eh(cid:48), p(cid:48), insn(cid:48), oi,
if FAILURE == r then
R ← {} return FAILURE
vi)
end if
end for
28:
29:
30:
31: