ming Languages (New York, NY, USA, 2007), ACM,
pp. 2–1.
[36] JANA, S., KANG, Y., ROTH, S., AND RAY, B. Automat-
ically Detecting Error Handling Bugs using Error Speci-
ﬁcations. In 25th USENIX Security Symposium (USENIX
Security ’16) (Austin, August 2016).
[37] KASHYAP, S., MIN, C., LEE, B., KIM, T., AND
EMELYANOV, P.
Instant OS Updates via Userspace
Checkpoint-and-Restart. In 2016 USENIX Annual Tech-
nical Conference (2016).
[38] KIM, D., NAM, J., SONG, J., AND KIM, S. Automatic
Patch Generation Learned from Human-written Patches.
In Proceedings of the 2013 International Conference on
Software Engineering (2013), IEEE, pp. 802–811.
[39] LUO, L., MING, J., WU, D., LIU, P., AND ZHU, S.
Semantics-based Obfuscation-resilient Binary Code Sim-
ilarity Comparison with Applications to Software Plagia-
rism Detection.
In Proceedings of the 22nd ACM SIG-
SOFT International Symposium on Foundations of Soft-
ware Engineering (2014), ACM, pp. 389–400.
[40] MING, J., PAN, M., AND GAO, D.
iBinHunt: Binary
Hunting with Inter-procedural Control Flow. In Proceed-
ings of International Conference on Information Security
and Cryptology (2012), Springer, pp. 92–109.
[41] PERKINS, J. H., KIM, S., LARSEN, S., AMARASINGHE,
S., BACHRACH, J., CARBIN, M., PACHECO, C., SHER-
WOOD, F., SIDIROGLOU, S., SULLIVAN, G., WONG,
W.-F., ZIBIN, Y., ERNST, M. D., AND RINARD, M.
Automatically Patching Errors in Deployed Software. In
Proceedings of the ACM SIGOPS 22nd Symposium on
Operating Systems Principles (October 2009).
[42] ROSENBERG, D. QSEE TrustZone Kernel Integer Over-
ﬂow Vulnerability. In Black Hat USA (2014).
[43] SHEN, D. Exploiting Trustzone on Android. In Black Hat
USA (2015).
[44] SHOSHITAISHVILI, Y., WANG, R., SALLS, C.,
STEPHENS, N., POLINO, M., DUTCHER, A., GROSEN,
J., FENG, S., HAUSER, C., KRUEGEL, C., AND VIGNA,
G. SoK: (State of) The Art of War: Offensive Techniques
in Binary Analysis. In Proceedings of the 37th IEEE Sym-
posium on Security and Privacy (2016).
[45] SIDIROGLOU, S., LAADAN, O., PEREZ, C., VIENNOT,
N., NIEH, J., AND KEROMYTIS, A. D. ASSURE: Au-
tomatic Software Self-healing Using REscue points.
In
Proceedings of the 14th international conference on Ar-
chitectural support for programming languages and op-
erating systems (March 2009).
[46] SILBERSCHATZ, A., GALVIN, P. B., AND GAGNE, G.
Operating System Concepts. Wiley, 2012.
[47] ZHANG, H., SHE, D., AND QIAN, Z. Android Root and
Its Providers: A Double-Edged Sword.
In Proceedings
of the 22nd ACM SIGSAC Conference on Computer and
Communications Security (New York, NY, USA, 2015),
ACM, pp. 1093–1104.
A Evaluation of Applicability: Additional
Case Studies
A.1 CVE-2014-3153 (Towelroot)
this vulnerability is the second most-used one to root Android
devices, known as “Towelroot”. It lies in the futex_requeue
function, which takes the addresses of two futexes as argu-
ments. By design, the function should only re-queue from a
non-PI (priority inheritance [46]) futex to a PI futex. How-
ever, this condition is violated if these two addresses point to
the same futex. This leads to an exploitable dangling pointer
condition. To ﬁx this bug, Linux simply adds a check to en-
sure that these two futex addresses are different [13]. This vul-
nerability can be similarly ﬁxed in KARMA by hooking the
futex_requeue function, obtaining its arguments, and com-
pare their equality. The patch returns -EINVAL if an attack is
detected (Figure 4).
A.2 CVE-2015-3636 (PingPong Root)
This is another popular vulnerability used to root Android de-
vices, known as “PingPong Root”.
It originates in the inter-
action between the socket and hlist functions. Speciﬁcally,
when hlist_nulls_del(&sk-> sk_nulls_node) is called,
it assigns LIST_POISON2 to sk->sk_nulls_node.pprev.
LIST_POISON2 is deﬁned as the constant of x22. If in-
terpreted as an address, address LIST_POISON2 can be mapped
by a malicious app in the user space without any permissions.
A second call to connect by the attacker will result in a
use-after-free on this attacker-controlled address, compromis-
ing the kernel. The Linux patch sets the pointer to NULL in
the ping_unhash function [16]. However, this method cannot
be applied by KARMA because its patch is prohibited from
writing to the kernel memory.
Instead, the patch checks if
sk->sk_nulls_node.pprev equals to LIST_POISON2. If so,
it returns an error code without freeing the associated mem-
ory. This blocks the exploit but leaves the socket object on the
list. This patch is not clean, but it works and does not impact
the kernel’s functionalities. Alternatively, KARMA can hook
connect in the kernel to prevent reusing the freed socket.
1268    26th USENIX Security Symposium
USENIX Association
Vulnerability
CVE-2016-7117
CVE-2016-5340
CVE-2016-4470
CVE-2016-3951
CVE-2016-3841
CVE-2016-3775
CVE-2016-3768
CVE-2016-3767
CVE-2016-3134
CVE-2016-2503
CVE-2016-2474
CVE-2016-2468
CVE-2016-2467
CVE-2016-2466
CVE-2016-2465
CVE-2016-2067
CVE-2016-2062
CVE-2016-0844
CVE-2016-0843
CVE-2016-0820
CVE-2016-0806
CVE-2016-0805
CVE-2016-0801
CVE-2016-0758
CVE-2016-0728
its
invocation
of __copy_from_user.
the params_length passed into __copy_from_user exceeds
return error code from __copy_from_user
Hotpatching Using KARMA
Hook __sys_recvmmsg and its invocation of fput. On returning of fput, check
if __sys_recvmmsg's err is not equal to 0 and not equal to -EAGAIN. If so, return
err and skip the rest execution.
Hook is_ashmem_file and check the full path of the input ﬁle. Only return
True if the full path is /dev/ashmem. Otherwise return False.
Hook key_reject_and_link and its invocation of __key_link_end. Check
if link_ret is 0 before calling into __key_link_end.
If so, simply return.
key_reject_and_link is void typed so any return value is ﬁne.
It requires writing to kernel memory, violating KARMA's basic constraint.
Hook do_ipv6_setsockopt to avoid concurrent access to the socket options of
the same socket fd.
Hook aio_setup_single_vector and check if the input kiocb->ki_nbytes
exceeds MAX_RW_COUNT. If so, return -EFAULT.
It requires to skip some instructions and continue execution afterwards, which is
not an allowed operation by KARMA.
Hook mtk_p2p_wext_discovery_results etc. functions of which the bodies
are deleted by the ofﬁcial patch, and simply return 0.
Android does not enable CONFIG_USER_NS so this should not be a direct threat
to Android devices. But KARMA can still ﬁx it by iterating newpos = pos +
e->next_offset to check if there is a out-of-bound access.
It requires to reorder the instructions (to change when to take the lock). This is
not an allowed operation by KARMA.
Hook hdd_parse_ese_beacon_req and check the tempInt read from the ar-
gument pValue. If it exceeds SIR_ESE_MAX_MEAS_IE_REQS, return -EINVAL.
Hook _kgsl_sharedmem_page_alloc and validate the input size.
Hook msm_compr_ioctl and
Check if
MAX_AC3_PARAM_SIZE. If so,
without executing into it.
Hook adm_get_params and check if adm_get_parameters[] exceeds
ADM_GET_PARAMETER_LENGTH-1 and params_length/sizeof(int).
If so,
return -EINVAL.
Hook the concerned functions in drivers/video/msm/mdss/mdss_debug.c
patched in the original patch, and their invocations of __copy_to_user. Validate
len and count, and return -EFAULT in case of exploit conditions.
Hook check_vma and return -EFAULT if vma->vm_flags & memdesc->flags
!= memdesc->flags.
Hook adreno_perfcounter_query_group and its invocation of kmalloc. On
the entry of kmalloc, check if t is larger than count.
Hook ipa_wwan_ioctl and its invocation of find_mux_channel_index. On
entry of find_mux_channel_index, if the value of rmnet_index exceeds
MAX_NUM_OF_MUX_CHANNEL, return -EFAULT directly.
Hook msm_l2_test_set_ev_constraint and check if shift_idx >=
PMU_CODES_SIZE. Return -EINVAL in case of that.
Hook priv_get_struct and its invocation of __copy_from_user, check if
prIwReqData->data.length>u4CopyDataMax and return -EFAULT if so.
Hook iw_softap_set_channel_range and check if the caller has the capabil-
ity CAP_NET_ADMIN, return -EPERM if not.
Hook get_krait_evtinfo and check if reg exceeds krait_max_l1_reg, re-
turn -EINVAL if so.
Hook wl_validate_wps_ie and check if subelt_len exceeds the size of
devname (100). Hook wl_notify_sched_scan_results and its invocation of
memcpy and check if the buffer length passed in exceeds DOT11_MAX_SSID_LEN.
Hook asn1_find_indefinite_length and check if dp is larger than datalen.
Return -1 if so.
Hook join_session_keyring and iterate the keyring. Return error if
keyring->usage reaches the overﬂow boundary (0xFFFFFFFF).
Adaptable?
!
!
!
Level-3
!
!
Level-3
!
!
Level-3
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
USENIX Association
26th USENIX Security Symposium    1269
Vulnerability
CVE-2015-8942
CVE-2015-8941
CVE-2015-8940
CVE-2015-8939
CVE-2015-8938
CVE-2015-8816
CVE-2015-6640
CVE-2015-6638
CVE-2015-6619
CVE-2015-2686
CVE-2015-0570
CVE-2014-9902
CVE-2014-9891
CVE-2014-9890
CVE-2014-9887
CVE-2014-9884
CVE-2014-9883
CVE-2014-9882
CVE-2014-9881
CVE-2014-9880
CVE-2014-9879
CVE-2014-9878
CVE-2014-9869
CVE-2014-9868
CVE-2014-9529
the
and
if
the
cmd
and
check
if
the
input
argument
the
argument
PVRSRVSyncPrimSetKM
equals
sd
to
obtain
mdp4_argc_process_write_req
Hotpatching Using KARMA
if
Hook
msm_cpp_subdev_ioctl,
VIDIOC_MSM_CPP_IOMMU_DETACH,
from its
cpp_dev->stream_cnt and check if it equals to 0.
Hook msm_isp_axi_check_stream_state and iterate over
input
stream_cfg_cmd->stream_handle to see if one exceeds MAX_NUM_STREAM.
The other vulnerable functions can be ﬁxed in the same way.
Hook q6lsm_snd_model_buf_alloc and check if the integer argument len is
out of range.
Hook
pgc_ptr->num_r/g/b_stages are out of range.
Hook msm_isp_send_hw_cmd and check if the ioctl input arguments satisfy the
constraints updated by the ofﬁcial patch. The constraint list is long so omitted
here.
Fixing the problem requires locking and increasing the reference of the usb_hub
structure, thus the patch needs to write to kernel memory.
Hook the system call prctl and check if the corresponding argument as the end
passed to prctl_set_vma_anon_name is out of range.
input
Hook
check
psSyncBlk->ui32BlockSize is smaller than another input ui32Index *
sizeof(IMG_UINT32).
The ofﬁcial patch is to remove all .tmpfile handlers. So we can simply hook
such handlers and always return -EINVAL.
Hook sys_sendto/sys_recvfrom and check if the input buff and len/size
are out of range.
Hook __iw_softap_setwpsie and check if ioctl arguments have improper
length, same as the ofﬁcial patch. The check list is long so omitted here.
Hook dot11fUnpackIeCountry and dot11fUnpackIeSuppChannels to vali-
date the value of the input ielen.
Hook __qseecom_process_rpmb_svc_cmd and validate if the input req_ptr
ﬁelds passed in from user space are out of range.
Hook msm_cci_validate_queue and validate if cmd_size extracted from the
inputs is larger than 10.
Hook qseecom_send_modfd_cmd and its invocation of __copy_from_user.
Validate req.cmd_req_len obtained from user space.
Hook qseecom_register_listener etc. handlers to validate pointers passed
in from user space, same as the ofﬁcial patch.
Hook extract_dci_log and check for the integer overﬂow condition of the
input log_length.
Hook
V4L2_CID_PRIVATE_IRIS_RIVA_ACCS_LEN/_POKE, validate if
data length exceeds MAX_RIVA_PEEK_RSP_SIZE.
Hook iris_vidioc_s_ext_ctrls and perform range/overﬂow check on the in-
put ctrl.
Hook vid_enc_ioctl and its invocation of __copy_from_user. Validate
seq_header fetched from user space.
Hook mdp3_histogram_start and validate its input req; hook mdp3_pp_ioctl
and validate mdp_pp obtained from user space.
Hook send_write_packing_test_read and validate its input buffer and
count.
Hook msm_isp_ functions as speciﬁed in the ofﬁcial patch, and validate if
stats_idx from input exceeds MSM_ISP_STATS_MAX.
Hook
and
csi_lane_params->csi_lane_mask.
Fixing the issue requires to change the instruction order (delay the reference put).
This is not a secure operation permitted by KARMA.
iris_vidioc_s_ctrl.
ctrl->id
is
the copied
msm_csiphy_release
validate
input
the
value
of
input
If
the
Adaptable?
!
!
!
!
!
Level-3
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
Level-3
Table 6: A partial list of recent critical Android kernel vulnerabilities and KARMA's effectiveness to create adaptable
patches for them. Some adaptable vulnerabilities are omitted due to the space constraint.
1270    26th USENIX Security Symposium
USENIX Association