to compute inputs that are processed by complex functions
(e.g. encryption or hashing) in a path constraint. This is
because constraint solvers are generally unable to determine
the inputs to such functions, which are necessary to produce
an output that would satisfy the path constraint. Again, in some
cases, a system that uses dynamic feedback as described in the
case of reﬂection might allow IntelliDroid to produce inputs in
these situations, and we are currently exploring this approach.
Similar to obfuscation through reﬂection, malware develop-
ers may hide malicious behavior in packed applications or na-
tive code, which IntelliDroid does not support. IntelliDroid can
be used to direct execution to locations in the code where these
are used (e.g. DexClassLoader, JNI invocations); however,
once again, any constraints that occur after these invocations
will not be extracted by the static component. While not ideal,
the ability to direct execution to these questionable parts of the
application is still valuable and can help an attached dynamic
tool analyze these portions more effectively.
D. Knowledgeable Attacker
Given the above limitations, a suitably knowledgeable
attacker has two main avenues for defeating IntelliDroid. First,
she can exploit the technical difﬁculty of extracting a complete
call graph for Android applications by placing the malicious
code in a section of code that appears to be disconnected from
the rest of the call graph (i.e., dead code). Since IntelliDroid
cannot determine a path to the code, it cannot generate inputs.
The mitigations for this is to have more precise modeling of
Android call edges, as well as conservative over-approximation
of call edges. The former requires more engineering effort,
while the latter may result in IntelliDroid injecting inputs for
paths that are not actually possible to execute.
Second, the attacker can process inputs in malicious code
with complex functions such as encryption and cryptographic
hashing that will defeat the current generation of constraint
solvers (and likely many future ones as well). In such cases,
however, IntelliDroid will experience many constraint solver
time-outs, which in itself is anomalous as none arose during
our experiments. While not necessarily indicative of malicious
behavior, they are infrequent enough to certainly warrant more
attention and possibly manual analysis.
VII. RELATED WORK
Static analysis of Android applications has been widely
used to detect malicious behavior or vulnerabilities [22], [25],
[23], [29], [4], [16], [30]. IntelliDroid’s static analysis is
comparable to the techniques used in previous work, though
in some cases it reduces precision for better scalability and
analysis speed.
13
IntelliDroid is designed to complement dynamic analysis
tools to allow them to quickly identify and analyze paths that
are likely to contain malicious behavior. There are a variety
of dynamic analysis tools that IntelliDroid could be used with,
such as TaintDroid [19], CopperDroid [39], DroidScope [44],
VetDroid [47] or RiskRanker [27]. Similarly, IntelliDroid can
also be used to aid reverse-engineering or manual analysis
using sandboxing analysis tools such as DroidBox [18].
While IntelliDroid’s extraction of path constraints is tech-
nically a form of symbolic execution, it is performed on a
static abstraction of the program rather than on a concrete
execution trace. As a result, it should generally provide faster
performance than concolic test generation systems such as
Dart [26], EXE [15] and KLEE [14], which use concrete
symbolic execution. In addition, IntelliDroid’s main focus is
on generating inputs to trigger a speciﬁc path rather than
obtaining code coverage, making its goals fundamentally dif-
ferent from these systems, as well as more recent Android-
focused concolic testing work, such as DynoDroid [31] and
the ACTEve algorithm [2]. The work in [32] targets ma-
licious code by exploring paths that branch on interesting
input, although the input dependency tracking and constraint
extraction is performed dynamically. Purely static constraint
extraction and solving has been used in tools like Saturn for
veriﬁcation [43] and hybrid static/dynamic symbolic execution
is used in MergePoint [7]. IntelliDroid is also similar to
AEG [6], APEG [11], and DyTa [24] which generate malicious
inputs to exercise vulnerabilities in program binaries. However,
these systems do not target Android applications and thus, do
not have to handle consistent input injection or event-chains.
The work most closely related to IntelliDroid are hy-
brid static/dynamic analyses such as AppAudit [42], Con-
tentScope [28], AppIntent
[45], SmartDroid [48], Smv-
Hunter [37] and Brahmastra [9]. The main difference between
IntelliDroid and these systems is the level of ﬁdelity of the
injected inputs. IntelliDroid can inject inputs into an actual
Android system, enabling integration with full system dynamic
analysis tools such as TaintDroid [19]. To do this, it must detect
event-chains and perform device-framework input injection.
In contrast, systems like AppAudit and ContentScope rely
mainly on the static analysis to ﬁnd vulnerabilities, and only
use dynamic analysis to conﬁrm the feasibility of the paths.
Moreover, ContentScope focuses solely on content providers.
In contrast, IntelliDroid’s goal is to detect malware so it must
support and analyze a wider range of behavior. AppIntent
also uses static analysis to identify relevant sections of code
to execute. However, while IntelliDroid targets speciﬁc paths
and statically generates concrete inputs, AppIntent requires an
exhaustive dynamic symbolic execution to fully explore all
behaviors, similar to that used in concolic testing. In addition,
AppIntent, SmartDroid, Brahmastra, and Smv-Hunter only
handle UI events.
VIII. CONCLUSION
IntelliDroid is a targeted input generator that speciﬁcally
exercise code paths in an application that are relevant to a
dynamic analysis tool. This paper contributes several novel
ideas that enable IntelliDroid to achieve this goal, such as the
use of targeted APIs as an abstraction for dynamic analysis
techniques, event-chain detection and input generation, and
device-framework injection. Using our prototype, we ﬁnd that
the static analysis component can identify and generate inputs
to trigger the targeted behavior in less than 138.4 seconds
on average. The generated inputs are able to trigger 70 out
of 75 malicious behaviors in a set of malware, while saving
the dynamic analysis from having to execute 95% of the
application code. When integrated with TaintDroid [19] and
compared against FlowDroid [4], we ﬁnd that IntelliDroid-
targeted TaintDroid is able to offer better precision. A compar-
ison with Monkey shows that IntelliDroid’s targeted execution
triggers malicious paths more precisely than a standard off-
the-shelf input fuzzer.
ACKNOWLEDGMENT
We would like to thank Zhen Huang, Mariana D’Angelo,
Dhaval Miyani, Wei Huang, Beom Heyn Kim, Sukwon Oh,
and Afshar Ganjali for their suggestions and feedback. We
also thank the anonymous reviewers for their constructive
comments. The research in this paper was supported by an
NSERC CGS-M scholarship, a Bell Graduate scholarship, an
NSERC Discovery grant, an ORF-RE grant, and a Tier 2
Canada Research Chair.
REFERENCES
[1]
3GPP, “Technical realization of Short Message Service (SMS),” 3rd
Generation Partnership Project (3GPP), TS 23.040, Sep. 2014.
[2] S. Anand, M. Naik, M. J. Harrold, and H. Yang, “Automated concolic
testing of smartphone apps,” in Proceedings of the ACM SIGSOFT 20th
International Symposium on the Foundations of Software Engineering.
ACM, 2012, p. 59.
“Apkparser,”
September 2014.
http://code.google.com/p/xml-apk-parser/,
[3]
accessed:
[4] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y. Le Traon, D. Octeau, and P. McDaniel, “FlowDroid: Precise context,
ﬂow, ﬁeld, object-sensitive and lifecycle-aware taint analysis for android
apps,” in Proceedings of
the 35th ACM SIGPLAN Conference on
Programming Language Design and Implementation. ACM, 2014,
p. 29.
[5] K. W. Y. Au, Y. F. Zhou, Z. Huang, and D. Lie, “PScout: Analyzing
the Android permission speciﬁcation,” in Proceedings of the 19th ACM
Conference on Computer and Communications Security (CCS), Oct.
2012.
[6] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley, “AEG:
Automatic exploit generation.” in Proceedings of the 18th Symposium
on Network and Distributed System Security (NDSS), 2011, pp. 59–66.
[7] T. Avgerinos, A. Rebert, S. K. Cha, and D. Brumley, “Enhancing
symbolic execution with veritesting,” in Proceedings of the 36th In-
ternational Conference on Software Engineering. ACM, 2014, pp.
1083–1094.
[8] D. Barrera, J. Clark, D. McCarney, and P. C. Van Oorschot, “Under-
standing and improving app installation security mechanisms through
empirical analysis of android,” in Proceedings of the second ACM
workshop on Security and privacy in smartphones and mobile devices.
ACM, 2012, pp. 81–92.
[9] R. Bhoraskar, S. Han, J. Jeon, T. Azim, S. Chen, J. Jung, S. Nath,
R. Wang, and D. Wetherall, “Brahmastra: Driving apps to test the
security of third-party components,” in Proceedings of the 23rd USENIX
conference on Security Symposium. USENIX Association, 2014, pp.
1021–1036.
[10] T. Bl¨asing, L. Batyuk, A.-D. Schmidt, S. A. Camtepe, and S. Albayrak,
“An android application sandbox system for suspicious software de-
tection,” in Malicious and unwanted software (MALWARE), 2010 5th
international conference on.
IEEE, 2010, pp. 55–62.
14
[12]
[11] D. Brumley, P. Poosankam, D. Song, and J. Zheng, “Automatic patch-
based exploit generation is possible: Techniques and implications,” in
Proceedings of the 2008 IEEE Symposium on Security and Privacy,
2008, pp. 143–157.
I. Burguera, U. Zurutuza, and S. Nadjm-Tehrani, “Crowdroid: behavior-
based malware detection system for android,” in Proceedings of the 1st
ACM workshop on Security and privacy in smartphones and mobile
devices. ACM, 2011, pp. 15–26.
J. Caballero, P. Poosankam, S. McCamant, D. Song et al., “Input
generation via decomposition and re-stitching: Finding bugs in mal-
ware,” in Proceedings of the 17th ACM conference on Computer and
communications security. ACM, 2010, pp. 413–425.
[13]
[14] C. Cadar, D. Dunbar, and D. R. Engler, “KLEE: Unassisted and auto-
matic generation of high-coverage tests for complex systems programs.”
in Proceedings of the 8th Symposium on Operating Systems Design and
Implementation (OSDI), 2008, pp. 209–224.
[15] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler,
“EXE: automatically generating inputs of death,” ACM Transactions on
Information and System Security (TISSEC), vol. 12, no. 2, p. 10, 2008.
[16] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner, “Analyzing inter-
application communication in Android,” in Proceedings of
the 9th
international conference on Mobile systems, applications, and services.
ACM, 2011, pp. 239–252.
[17] L. De Moura and N. Bjørner, “Z3: An efﬁcient SMT solver,” in Tools
and Algorithms for the Construction and Analysis of Systems. Springer,
2008, pp. 337–340.
[18] A. Desnos and P. Lantz, “DroidBox: An android application sandbox
for dynamic analysis,” 2014, https://code.google.com/p/droidbox/, Last
Accessed Oct, 2014.
[19] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung, P. McDaniel,
and A. N. Sheth, “TaintDroid: an information-ﬂow tracking system for
realtime privacy monitoring on smartphones,” in Proceedings of the 9th
Symposium on Operating Systems Design and Implementation (OSDI),
Oct. 2010, pp. 1–6.
[20] Ericsson Mobility,
report,”
ericsson-mobility-report-feb-2015-interim.pdf.
2015,
Feb.
“Interim
update:
mobility
http://www.ericsson.com/res/docs/2015/
Ericsson
[21] M. D. Ernst, “Static and dynamic analysis: Synergy and duality,” in
WODA 2003: ICSE Workshop on Dynamic Analysis, 2003, pp. 24–27.
[22] A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner, “Android
permissions demystiﬁed,” in Proceedings of the 18th ACM Conference
on Computer and Communications Security (CCS), Oct. 2011, pp. 627–
638.
[23] A. P. Fuchs, A. Chaudhuri, and J. S. Foster, “Scandroid: Automated
security certiﬁcation of android applications,” Manuscript, Univ. of
Maryland, http://www. cs. umd. edu/˜ avik/projects/scandroidascaa,
2009.
[24] X. Ge, K. Taneja, T. Xie, and N. Tillmann, “Dyta: dynamic symbolic
execution guided with static veriﬁcation results,” in Proceedings of the
33rd International Conference on Software Engineering (ICSE), 2011,
pp. 992–994.
[25] C. Gibler, J. Crussell, J. Erickson, and H. Chen, AndroidLeaks: auto-
matically detecting potential privacy leaks in Android applications on
a large scale. Springer, 2012.
[26] P. Godefroid, N. Klarlund, and K. Sen, “DART: Directed automated
random testing,” in Proceedings of the 2005 ACM SIGPLAN Conference
on Programming Language Design and Implementation, ser. PLDI ’05.
New York, NY, USA: ACM, 2005, pp. 213–223.
[27] M. Grace, Y. Zhou, Q. Zhang, S. Zou, and X. Jiang, “RiskRanker: scal-
able and accurate zero-day android malware detection,” in Proceedings
of the 10th international conference on Mobile systems, applications,
and services. ACM, 2012, pp. 281–294.
[28] Y. Z. X. Jiang, “Detecting passive content leaks and pollution in android
the 20th Network and Distributed
applications,” in Proceedings of
System Security Symposium (NDSS), 2013.
J. Kim, Y. Yoon, K. Yi, J. Shin, and S. Center, “Scandal: Static analyzer
for detecting privacy leaks in android applications,” MoST, 2012.
[29]
[30] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang, “Chex: statically vetting
android apps for component hijacking vulnerabilities,” in Proceedings of
15
the 2012 ACM conference on Computer and communications security.
ACM, 2012, pp. 229–240.
[31] A. MacHiry, R. Tahiliani, and M. Naik, “Dynodroid: An input gener-
ation system for android apps,” in Proceedings of the 2013 9th Joint
Meeting on Foundations of Software Engineering. ACM, 2013, pp.
224–234.
[32] A. Moser, C. Kruegel, and E. Kirda, “Exploring multiple execution
paths for malware analysis,” in Security and Privacy, 2007. SP’07. IEEE
Symposium on.
IEEE, 2007, pp. 231–245.
[33] D. Octeau, S. Jha, and P. McDaniel, “Retargeting android applications to
java bytecode,” in Proceedings of the ACM SIGSOFT 20th International
Symposium on the Foundations of Software Engineering. ACM, 2012,
p. 6.
[34] M. Parkour,
“Contagio mobile,” 2015, http://contagiominidump.
blogspot.ca/, Last Accessed Aug, 2015.
“Robotium,” 2014, https://code.google.com/p/robotium/.
[35]
[36] A. Shabtai, U. Kanonov, Y. Elovici, C. Glezer, and Y. Weiss, “andro-
maly: a behavioral malware detection framework for android devices,”
Journal of Intelligent Information Systems, vol. 38, no. 1, pp. 161–190,
2012.
[37] D. Sounthiraraj, J. Sahs, G. Greenwood, Z. Lin, and L. Khan, “Smv-
hunter: Large scale, automated detection of ssl/tls man-in-the-middle
vulnerabilities in android apps,” in Proceedings of the 19th Network
and Distributed System Security Symposium, 2014.
[38] V.
Svajcer,
“Sophos
report,”
http://www.sophos.com/en-us/medialibrary/PDFs/other/
security
mobile
threat
2014,
sophos-mobile-security-threat-report.pdf.
[39] K. Tam, S. J. Khan, A. Fattori, and L. Cavallaro, “Copperdroid:
Automatic reconstruction of android malware behaviors,” in Proc. of
the Symposium on Network and Distributed System Security (NDSS),
2015.
“Testing
testing/testing android.html, Last Accessed Oct, 2014.
“Watson libraries for analysis,” http://wala.sourceforge.net, accessed:
September 2014.
http://developer.android.com/tools/
fundamentals,”
2014,
[41]
[40]
[42] M. Xia, L. Gong, Y. Lyu, Z. Qi, and X. Liu, “Effective real-time android
application auditing,” in Proceedings of the 2015 IEEE Symposium on
Security and Privacy, ser. SP ’15.
IEEE Computer Society, 2015.
[43] Y. Xie and A. Aiken, “Saturn: A scalable framework for error detec-
tion using boolean satisﬁability,” ACM Transactions on Programming
Languages and Systems (TOPLAS), vol. 29, no. 3, p. 16, 2007.
[44] L.-K. Yan and H. Yin, “DroidScope: Seamlessly reconstructing the os
and dalvik semantic views for dynamic android malware analysis.” in
Proceedings of the 21th USENIX Security Symposium, 2012, pp. 569–
584.
[45] Z. Yang, M. Yang, Y. Zhang, G. Gu, P. Ning, and X. S. Wang,
“AppIntent: Analyzing sensitive data transmission in android for privacy
leakage detection,” in Proceedings of the 20th ACM Conference on
Computer and Communications Security (CCS), 2013, pp. 1043–1054.
[46] H. Ye, S. Cheng, L. Zhang, and F. Jiang, “Droidfuzzer: Fuzzing the
android apps with intent-ﬁlter tag,” in Proceedings of International
Conference on Advances in Mobile Computing & Multimedia. ACM,
2013, p. 68.
[47] Y. Zhang, M. Yang, B. Xu, Z. Yang, G. Gu, P. Ning, X. S. Wang, and
B. Zang, “Vetting undesirable behaviors in android apps with permission
use analysis,” in Proceedings of the 2013 ACM SIGSAC conference on
Computer & communications security. ACM, 2013, pp. 611–622.
[48] C. Zheng, S. Zhu, S. Dai, G. Gu, X. Gong, X. Han, and W. Zou, “Smart-
droid: An automatic system for revealing ui-based trigger conditions in
android applications,” in Proceedings of the second ACM workshop on
Security and privacy in smartphones and mobile devices. ACM, 2012,
pp. 93–104.
[49] Y. Zhou and X. Jiang, “Dissecting Android malware: Characterization
and evolution,” in Proceedings of the 2012 IEEE Symposium on Security
and Privacy.
IEEE, 2012, pp. 95–109.
[50] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang, “Hey, you, get off of my
market: Detecting malicious apps in ofﬁcial and alternative android
markets.” in NDSS, 2012.