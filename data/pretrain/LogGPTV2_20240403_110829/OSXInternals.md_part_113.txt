mach_port_t requestor_port,
mach_port_t *subset_port);
A lookup operation on subset_port will return not only ports registered with only subset_port but also
ports registered with ancestors of subset_port. If the same service is registered with both subset_port
and an ancestor port, a lookup for that service by a user of subset_port will fetch the subset_port
version of the service. This way, services can be transparently customized for certain tasks without
affecting the rest of the system, which can continue to use the default versions of the services in question.
The lifespan of subset_port is determined by requestor_port; subset_port, its descendants, and any
services advertised by these ports are all destroyed when requestor_port is destroyed.
bootstrap_parent() returns the parent bootstrap port of bootstrap_port, which is typically a
bootstrap subset port. The calling task must have superuser privileges. For example, when called from a
user login context, this function will return the bootstrap port corresponding to the startup context. When
called from the startup context, the parent port returned is the same as the bootstrap port.
kern_return_t
bootstrap_parent(mach_port_t bootstrap_port,
mach_port_t *parent_port);
The /usr/libexec/StartupItemContext program can be used to run an executable in the startup
contextthat is, the context in which the Mac OS X startup items run. It works by calling
bootstrap_parent() repeatedly until it has reached the startup (root) context. It then sets the port as its
own bootstrap port, after which it can execute the requested program.
The automatic relaunching of servers by the Bootstrap Server is useful for creating crash-resistant servers.
However, it is neither necessary nor advisable to create production servers by directly using the Bootstrap
Server interface. Beginning with Mac OS X 10.4, the launch API,[8] as exported through ,
should be used. With this caveat, let us look at two examples of using the Bootstrap Server interface.
[8] Section 5.10.1.2 provides an example of using the launch API.
9.4.3.1. Displaying Information about All Known Services
In this example, we will use bootstrap_info() to retrieve a list of all known services that can be looked
up in the bootstrap context associated with the given bootstrap port. Figure 915 shows the program.
Figure 915. Displaying information about all known services in a bootstrap context
// bootstrap_info.c
#include 
#include 
#include 
#include 
int
main(int argc, char **argv)
{
kern_return_t kr;
name_array_t service_names, server_names;
bootstrap_status_array_t service_active;
unsigned int service_names_count, server_names_count;
unsigned int service_active_count, i;
// We can use bootstrap_port, a global variable declared in a Mach header,
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh46E8.htm 20.08.2007
Chapter 9. Interprocess Communication Page 37 of 153
// for the current task's bootstrap port. Alternatively, we can explicitly
// retrieve the same send right by calling task_get_bootstrap_port(),
// specifying mach_task_self() as the target task. This is how the system
// library initializes the global variable.
// launchd implements this routine
kr = bootstrap_info(bootstrap_port,
&service_names,
&service_names_count,
&server_names,
&server_names_count,
&service_active,
&service_active_count);
if (kr != BOOTSTRAP_SUCCESS) {
mach_error("bootstrap_info:", kr);
exit(1);
}
printf("%s %-48s %s\n%s %-48s %s\n", "up?", "service name", "server cmd",
"___", "____________", "__________");
for (i = 0; i 
#include 
#include 
#include 
#include 
#include 
#include 
#define SERVICE_NAME "com.osxbook.DummySleeper"
#define SERVICE_CMD "/tmp/sleeperd"
#define SERVICE_SHUTDOWN_FILE SERVICE_CMD ".off"
static mach_port_t server_priv_port;
static aslmsg logmsg;
// Note that asl_log() accepts the %m formatting character, which is
// replaced by the ASL facility with the error string corresponding to
// the errno variable's current value.
#define MY_ASL_LOG(fmt, ...) \
asl_log(NULL, logmsg, ASL_LEVEL_ERR, fmt, ## __VA_ARGS__)
static kern_return_t
register_bootstrap_service(void)
{
kern_return_t kr;
mach_port_t service_send_port, service_rcv_port;
// Let us attempt to check in.... This routine will look up the service
// by name and attempt to return receive rights to the service port.
kr = bootstrap_check_in(bootstrap_port, (char *)SERVICE_NAME,
&service_rcv_port);
if (kr == KERN_SUCCESS)
server_priv_port = bootstrap_port;
else if (kr == BOOTSTRAP_UNKNOWN_SERVICE) {
// The service does not exist, so let us create it....
kr = bootstrap_create_server(bootstrap_port,
SERVICE_CMD,
getuid(), // server uid
FALSE, // not on-demand
&server_priv_port);
if (kr != KERN_SUCCESS)
return kr;
// We can now use server_priv_port to declare services associated
// with this server by calling bootstrap_create_service() and passing
// server_priv_port as the bootstrap port.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh46E8.htm 20.08.2007
Chapter 9. Interprocess Communication Page 39 of 153
// Create a service called SERVICE_NAME, and return send rights to
// that port in service_send_port.
kr = bootstrap_create_service(server_priv_port, (char *)SERVICE_NAME,
&service_send_port);
if (kr != KERN_SUCCESS) {
mach_port_deallocate(mach_task_self(), server_priv_port);
return kr;
}
// Check in and get receive rights to the service port of the service.
kr = bootstrap_check_in(server_priv_port, (char *)SERVICE_NAME,
&service_rcv_port);
if (kr != KERN_SUCCESS) {
mach_port_deallocate(mach_task_self(), server_priv_port);
mach_port_deallocate(mach_task_self(), service_send_port);
return kr;
}
}
// We are not a Mach port server, so we do not need this port. However,
// we still will have a service with the Bootstrap Server, and so we
// will be relaunched if we exit.
mach_port_destroy(mach_task_self(), service_rcv_port);
return kr;
}
static kern_return_t
unregister_bootstrap_service(void)
{
return bootstrap_register(server_priv_port, (char *)SERVICE_NAME,
MACH_PORT_NULL);
}
int
main(void)
{
kern_return_t kr;
struct stat statbuf;
// Initialize a message for use with the Apple System Log (asl) facility.
logmsg = asl_new(ASL_TYPE_MSG);
asl_set(logmsg, "Facility", "Sleeper Daemon");
// If the shutdown flag file exists, we are destroying the service;
// otherwise, we are trying to be a server.
if (stat(SERVICE_SHUTDOWN_FILE, &statbuf) == 0) {
kr = unregister_bootstrap_service();
MY_ASL_LOG("destroying service %s\n", SERVICE_NAME);
} else {
kr = register_bootstrap_service();
MY_ASL_LOG("starting up service %s\n", SERVICE_NAME);
}
if (kr != KERN_SUCCESS) {
// NB: When unregistering, we will get here if the unregister succeeded.
mach_error("bootstrap_register", kr);
exit(kr);
}
MY_ASL_LOG("server loop ready\n");
while (1) // Dummy server loop.
sleep(60);
exit(0);
}
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh46E8.htm 20.08.2007
Chapter 9. Interprocess Communication Page 40 of 153
Note that the program also shows an example of using the Apple System Logger (ASL) facility.
Beginning with Mac OS X 10.4, the asl(3) interface is available as a replacement for the syslog(3)
logging interface. Besides logging, the ASL facility provides functions for querying logged messages.
Section 10.8.3 contains an overview of logging in Mac OS X. Our server logs a few messages at the
ASL_LEVEL_ERR log level. These messages will be written to both /var/log/system.log
and /var/log/asl.log. Moreover, if launchd's debugging output is enabled (as described in Section
9.4.2.3), you will see detailed log messages corresponding to the Bootstrap Server calls made by our
program.
$ gcc -Wall -o /tmp/sleeperd bootstrap_server.c
$ /tmp/sleeperd
Apple System Logger (ASL)
The ASL facility allows structured log messages that consist of string-based key-value
dictionaries. The facility provides several predefined keys, such as for priority level, process
ID, time, and message sender. An application can extend the message dictionary by defining
its own keys. Moreover, applications need not be concerned about the whereabouts of log
filesASL stores messages in a single data store. The ASL interface includes functions for
constructing queries and searching for log messages based on those queries.
Beginning with Mac OS X 10.4, the syslogd program is the ASL daemon, although it
provides backward compatibility with previous syslogd implementations. ASL also supports
message filtering both in the client library and in syslogd.
Since our server does not fork and performs no operation other than sleeping, it will hang on running. We
can examine the launchd log at this point to see the relevant messages, which are shown annotated, with
prefixes removed, in Figure 917.
Figure 917. launchd debug messages corresponding to a Mach server's initialization
# server -> bootstrap_check_in()
Service checkin attempt for service com.osxbook.DummySleeper bootstrap 5103
bootstrap_check_in service com.osxbook.DummySleeper unknown
received message on port 5103
...
# server -> bootstrap_create_server()
Server create attempt: "/tmp/sleeperd" bootstrap 5103
adding new server "/tmp/sleeperd" with uid 501
Allocating port f70f for server /tmp/sleeperd
New server f70f in bootstrap 5103: "/tmp/sleeperd"
...
# server -> bootstrap_create_service()
Service creation attempt for service com.osxbook.DummySleeper bootstrap f70f
Created new service c19f in bootstrap 5103: com.osxbook.DummySleeper
...
# server -> bootstrap_check_in()
Service checkin attempt for service com.osxbook.DummySleeper bootstrap f70f
Checkin service com.osxbook.DummySleeper for bootstrap 5103
Check-in service c19f in bootstrap 5103: com.osxbook.DummySleeper
...
# server -> mach_port_destroy()
received destroyed notification for service com.osxbook.DummySleeper
Service f797 bootstrap 5103 backed up: com.osxbook.DummySleeper
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh46E8.htm 20.08.2007
Chapter 9. Interprocess Communication Page 41 of 153
...
Let us kill the server by sending it the interrupt signalthat is, by typing ctrl-c in the shell from which we
executed /tmp/sleeperd. We can then verify that the server was indeed relaunched.
^C
$ ps -ax | grep sleeperd
2364 ?? Ss 0:00.01 /tmp/sleeperd
Let us examine launchd's log again (Figure 918).
Figure 918. launchd debug messages corresponding to a Mach server's relaunch
...
# server died; will be relaunched
server /tmp/sleeperd dropped server port
Allocating port f627 for server /tmp/sleeperd
Launched server f627 in bootstrap 5103 uid 501: "/tmp/sleeperd": [pid 2364]
received message on port f627
# server-> bootstrap_check_in()
Service checkin attempt for service com.osxbook.DummySleeper bootstrap f627
Checkin service com.osxbook.DummySleeper for bootstrap 5103
Check-in service f797 in bootstrap 5103: com.osxbook.DummySleeper
...
# server -> mach_port_destroy()
Received destroyed notification for service com.osxbook.DummySleeper
Service f797 bootstrap 5103 backed up: com.osxbook.DummySleeper
...
We can see that certain log messages are different from when we executed /tmp/sleeperd for the first
time. In the first case, both a new server and a new service were created. In this case, when launchd
respawns the server, the server's first attempt to call bootstrap_check_in() succeeds because the
service already exists.
Now, even if we kill the server process by sending it SIGKILL, launchd will relaunch it. We can cause the
server to terminate permanently by creating the /tmp/sleeperd.off file.
$ touch /tmp/sleeperd.off
$ kill -TERM 2344
$ ps -ax | grep sleeperd
$
The log messages will show that launchd relaunched our server even this time. However, instead of
calling bootstrap_check_in(), the server calls bootstrap_register() with MACH_PORT_NULL
specified as the service port, which makes the service unavailable.
...
# server died
received message on port f627
server /tmp/sleeperd dropped server port
received message on port f03
Notified dead name c1ab
Received task death notification for server /tmp/sleeperd
waitpid: cmd = /tmp/sleeperd: No child processes