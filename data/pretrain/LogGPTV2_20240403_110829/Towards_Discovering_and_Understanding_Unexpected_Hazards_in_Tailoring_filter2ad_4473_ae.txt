We can see that for all AVDs, the null-protection window lengths
PMS Handles Intents by PMS.processPendingInstall(...)Intall Pkg CheckedPMS.installPackageLI(...)Install New Pkg StartedPMS.installNewPackageLI(...)Replace Nonsystem Pkg StartedPMS.replaceNonSystemPackageLI(...)Replace System Pkg StartedPMS.replaceSystemPackageLI(...)New Pkg ProcessedPMS.scanPackageLI(...)Settings UpdatedPMS.updateSettingsLI(...)PMS Service FinishedPMS.sendBroadcast(...)Old Package DeletedPMS.deletePackageLI(...)App Process KilledAMS.killApplicationWithAppId(...)Msg BroadcastedPMS.sendBroadcast(Package_REMOVED)New Package ProcessedCode Signatures VeriﬁedPMS.verifySignaturesLP(...)Settings UpdatedPMS.sendBroadcast(Package_REPLACED)Code Signatures VeriﬁedMsg BroadcastedPMS.sndPkgBrdcast(Pkge_Added)Msg BroadcastedPMS.sendBroadcast(Package_ADDED)Settings UpdatedPMS.sendBroadcast(Package_REPLACED)Old Package RemovedPMS.removePackageLI(...)Msg BroadcastedPMS.sndBrdcast(Pkge_Removed)New Package ProcessedPMS.verifySignaturesLP(...)PMS.scanPackageLI(...)PMS.scanPackageLI(...)PMS.updateSettingsLI(...)PMS.updateSettingsLI(...)in Samsung Note II and Google Nexus IV (LG) are the smallest,
whereas Nexus S (Samsung) has the largest window, from about
9.2-16.8 seconds. Note that all the collected results are the theoret-
ical lower bounds for the null-protection window, because in this
test, our Dynamic Testor keeps sending launching events from adb
tool during each tested AVD updating session. This guarantees the
automatic AVD relaunch right after the AVD is updated.
to Chen et al. [27], in the sense that we both check the reachability
of certain temporal logic in the code. However, our model checker,
particularly targets the Dalvik bytecode of the PMS in Android for
the engineUpdate’s vulnerable temporal program logic.
Figure 6: The Null-protection Window lengths (in seconds) for
all 30 tested AVDs on four Android devices
Since we can automate the process of AVDs’ relaunching, we
think one might provide a preventive design to relaunch the AVD
by the updated new AVD code itself immediately after the engine-
Update ﬁnishes. One interesting mitigation that we come up with
is to add a receiver component in AVD to listen to the broadcasted
action.PACKAGE_REPLACED intent, which indicates the ﬁnish-
ing of the engineUpdate. Then this receiver of the updated new
AVD engine is always triggered by this broadcasted intent right af-
ter the engineUpdate ﬁnishes. Within the registered receiver com-
ponent, we then relaunch the main monitoring process automati-
cally through Android APIs, startActivity(). Note that this mitiga-
tion does not solve the fundamental problem that the old AVD pro-
cess is killed and the vulnerable period is created, but it can only
reduce the null-protection window length to the theoretical lower
bound (caused by the complicated updating operations carried out
by the system). None of the 23 of the tested AVDs that registered
the action.PACKAGE_REPLACED (in Table 3), are actually per-
forming the preventive design for their own updates, but only use
the registered receiver to start a service to scan other apps’ updat-
ing for malware detection purpose. We report our ﬁndings to all the
AVD vendors and propose this short-term mitigation to them. They
responded to us immediately and conﬁrmed the hazard. Similar
patches will be provided in their next release based on our sug-
gested mitigation. However, to completely eliminate the hazard,
the PMS design should be enhanced. Since this hazard can be ap-
plicable to other apps that require continuous monitoring properties
(e.g., Mobile Device Manager (MDM) [18], IPS [12, 14] and etc.),
we reported this hazard to Google and they conﬁrmed our ﬁndings
and we are now working with them on possible feature enhance-
ments for the relevant components and services.
4.3 Model Checking the Vulnerable Logic
To automate the process of verifying the pervasiveness of the
vulnerable temporal logic in AVDs’ engine update procedure, we
leverage the model checking techniques, which have been applied
widely [25, 29, 27] to perform system bugs and vulnerabilities ex-
amination and temporal property checking for both mobile and PC
platforms. Our model checker for the Android platform is similar
Figure 7: The model checking framework
Figure 7 shows the design of our model checking framework.
The inputs are the Android factory images collected from multi-
ple vendors. After the preprocessing phase, we extract the relevant
.odex ﬁle of the PMS components in the system.img. The odex
code, namely the optimized Dalvik bytecode, can be run directly
on the targeted Dalvik VM. We decompile the odex ﬁle into Dalvik
bytecode and produce the CFGs for these components. From the
constructed CFGs, we ﬁrst identify the relevant execution traces
that correspond to the engineUpdate’s temporal logic. Then we
construct FSAs to describe the relevant vulnerable program logic
in PMS. Each edge in the FSA corresponds to a critical method in-
vocation that brings the system state to the next state. For instance,
Figure 5 is a simpliﬁed representation of one of the FSAs for the
relevant vulnerable code in the PMS of Android version 4.4.4_r1.
The completion of the PMS.deletePackageLI() invocation brings
the state from STATE{“Replace Non-system Package Started”} to
the STATE{“Old Package Deleted”}. Therefore, when we per-
form a model checking against the constructed CFG, whenever
the system state STATE{“Replace Non-system Package Started”}
encounters the deletePackageLI() method invocation in the PMS
class ﬁle, our model checker will bring the current system state
to the STATE{“Old Package Deleted”}. It then expects the next
critical method invocation, namely PMS.sndPkgBroadcast(). Our
model checker works in a depth-ﬁrst-search manner to check the
system states along the constructed CFGs. Whenever a sequence of
method invocations is matched to a sequence of edges in the FSA
that lead to the ﬁnal STATE{“PMS Service Finished”}, a trace will
be printed out for further veriﬁcation. These traces help conﬁrm the
existence of the vulnerable logic for the AVD engineUpdate oper-
ation of the PMS component. We actually use the “liveness prop-
erty” of model checking for vulnerability veriﬁcation. Note that
here we are to verify if something “good” will eventually happen,
and here “good” means the identiﬁcation of the exact vulnerable
temporal logic in the PMS. Whenever the newly constructed CFGs
of the PMS does not match the speciﬁed FSAs, we will check into
the relevant CFGs to manually construct a new FSA for the un-
matched PMS version. Most of the time, it is because the names of
the methods are changed slightly, or a new wrapper is provided for
an old method. It turns out that we only need to construct four FSAs
to check the temporal logic of all PMS versions of Android OSes.
The relevant mapping from FSAs to Android versions are given in
Table 7. Due to the space limitation, we skipped some versions if
our model checker reports no critical implementation variances.
Conﬁrm the Goolge Android ofﬁcial factory Images.
To systematically check all Goolge Android factory images, we
have downloaded all the factory images [9], which contain im-
0	
  2	
  4	
  6	
  8	
  10	
  12	
  14	
  16	
  Avira	
  AVD	
  An0yAVL	
  Avast	
  aegislab	
  AVG	
  AnGuanJia	
  TrendMicro	
  Kaspersky	
  Dr.Web	
  ESET	
  Sec	
  CleanMaster	
  McAfee	
  Symantec	
  G	
  DATA	
  Lookout	
  Panda	
  Sophos	
  Tencent	
  Comodo	
  Ikarus	
  F-­‐Secure	
  CMCInfoSec	
  Qihu360	
  NetQin	
  BitDefender	
  TrustGo	
  Bornaria	
  VIRUSﬁghter	
  Webroot	
  Zonner	
  Samsung	
  Note2	
  Google	
  Nexus4	
  (LG)	
  Google	
  Nexus	
  7	
  (1st	
  Asus,	
  Tablet)	
  Goolge	
  Nexus	
  S	
  (Samsung)	
  Control	
  Flow	
  Graph	
  Androguard	
  Analyzer	
  preprocess	
  Android	
  Vendors	
  Factory	
  Images	
  PMS/AMS’s	
  odex	
  Files	
  system.img	
  Model	
  Checker	
  Finite-­‐State	
  Automatons	
  Specify	
  a	
  new	
  FSA	
  Need	
  a	
  new	
  FSA	
  for	
  this	
  new	
  PMS/AMS	
  Vulnerable	
  Logic	
  in	
  AVD	
  Engine	
  Update	
  conﬁrmed	
  !!!	
  Enter	
  FSAs’	
  ﬁnal	
  state	
  ?	
  Table 7: Android OS versions and relevant Models for PMS
OS versions
Constructed FSAs
FSA of v4.4.4_r1
Android v4.4.4
FSA of v4.4.4_r1
Android v4.4_r1
FSA ofv4.4.4_r1
Android v4.3_r2.1
FSA of v4.4.4_r1
Android v4.2_r1
Android v4.1.2_r1
FSA of v4.1.2_r1
FSA of v4.1.2_r1
Android v4.0.3_r1
FSA of v2.3.7_r1
Android v2.3.7_r1
FSA of v2.3.7_r1
Android v2.2_r1.1
FSA of v2.1_r2
Android v2.1_r2
Android v2.0_r1
FSA of v2.1_r2
FSA of v2.1_r2
Android v1.6_r2
Android v1.5_r4
FSA of v2.1_r2
Release dates
19 June 2014
31 October 2013
14 July 2013
13 November 2012
22 August 2012
16 December 2011
11 September 2011
29 June 2010
27 January 2010
14 October 2009
15 September 2009
30 April 2009
ages ranging from Android version v1.5_r4–v4.4.4_r1, totally 34
versions. Our model checker has veriﬁed that the same vulnera-
ble logic in PMS appears from all the Android OS versions from
v1.5_r4 (April 2009) to very recent v4.4.4_r1 (June 2014) for all
Google ofﬁcial Android factory images.
Conﬁrm the Vendor customized stock Images.
Due to the Android vendors’ fragmentation problem [22, 5], we
also download images from HTC and Samsung [17, 11] and con-
duct analysis on recently released stock images from multiple ven-
dors, including Samsung (S4, S3 and S2 with Android v4.4.2, v4.0.4
and v2.3.4), HTC (One Mini, M7 with Android v4.4.2, v4.3), Sony
(Xperia Z2 and Xperia M2 with Android v4.4 and v4.3) and LG
(LGD958 Android v4.2.2). Our analysis also conﬁrms that the
same vulnerable PMS logic appears in all of them. It is because
most of the customized stock images directly reuse most of the
core design logic in mission critical components (e.g., PMS) from
Google AOSP codebase.
Our ﬁnding demonstrates that some seemingly benign, but com-
plicated updates in the system can cause surprising hazards to a sta-
ble system, which is similar to the takeaway message presented by
Xing et al. [46]. But the newly discovered ﬂaw resides in the Pack-
ageManager Service for AVDs’ engineUpdate procedure, which
can unexpectedly nullify any security protection from AVDs.
5. DISCUSSIONS
5.1 Mitigations
One proposed prevention for the discovered information leak-
age channels in Table 2 is based on more ﬁne-grained mandatory
access control. The Android system can leverage the existing SE-
Android [45] mechanism to restrict the public from accessing the
channels under certain usage scenario with high security require-
ments. One speciﬁc policy reﬁnement is to assign a new sub-
ject domain and relevant allow rules in the SEAndroid [45] policy
database and then label a while-listed/authorized apps/services with
the new subject domain. Consequently, only controlled/authorized
accesses to different ﬁles under the /proc/∗ (sub)folders are granted.
However, this requires a solid understanding on different usage sce-
narios of various programs and the underlying Android system de-
sign speciﬁcs, so that the proposed mitigation will not block normal
legitimate usability. One can model the relevant attacks in the mo-
bile system into attack graph surface [33] and then enforce policy
to block different leakage channels accordingly.
We propose another speciﬁc mitigation for the hazards in heavy
sweeping malScan. For example, the underlying system may pro-
vide only the general usage statistics of AVDs (or other mission
critical apps) by normalizing or delaying the reporting of system
resource usage statistics (e.g., the CPU, memory and network) in