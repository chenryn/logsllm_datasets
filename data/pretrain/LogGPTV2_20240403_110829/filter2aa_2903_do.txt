15.2 观止和未雨绸缪
在戏剧和表演方面，人们使用观止（Showstopper）一词来形容令
人拍手叫绝的精彩演出，它被观众的掌声和喝彩声打断，不得不停下来
等人们安静后才能再继续。
在日常生活中，观止也是一个很好的词，人们用它来形容超乎寻常
地美丽和迷人……
但在这个词被引入到计算机特别是软件领域后，它的含义发生了根
本性的变化，它代表的是最严重的问题（Bug）。这样的问题会使整个
项目停滞不前，这样的问题解决不了，产品就不可能发布……
15.2.1 NT 3.1的故事
NT 3.1是Windows NT系列操作系统的第一个版本，Windows
2000、XP、Server 2003和Vista都来源于它。可以说，NT 3.1的很多经典
设计还一直保留在今天的Windows系统中，也正是这些经典设计为NT系
列操作系统的成功打下了坚实基础。
1988年10月31日NT内核之父David Cutler加入微软，11月正式成立
NT开发团队，从那时算起，到1993年7月26日NT 3.1发布，NT 3.1的开
发时间经历了4年零9个月。在这4年多时间里，NT 3.1开发团队从最初
的6人增加到结束时的200人左右。
在我的案边，有一本书生动翔实地记录了NT 3.1的开发过程，作者
是G. Pascal Zachary，书名是《观止》（《Showstopper》）[2]，这个书
名以红色字体赫然印在封面上，格外显眼（见图15-1）。
图15-1 记录NT 3.1开发过程的经典之作——《观止》
除了书名之外，这本书中第 10 章的标题也叫“观
止”（Showstopper），这一章记述了NT 3.1发布前约半年的时间里NT团
队与Showstopper战斗的历程。下面这些情节特别值得回味。
1993年2月28日，计划发布Beta 2的日子，这一天还有45个
Showstopper级别的问题困扰着整个团队，如此多的Showstopper是不符
合发布标准的。
1993年3月8日，NT 3.1的Beta 2发布，并将最终版本的发布时间定
在5月10日。但在接下来的几周内，Showstopper和1号优先级的问题迅
猛出现，到4月19日，已达到令人不安的448个问题。
1993年4月23日，因为还有361个严重问题和近2000个其他问题，
David Cutler不得不取消了5月10日的发布计划，通过电子邮件告诉团队
成员最终版本的发布日期推迟到6月7日。
接下来的一两个月里，很多人经历了不眠之夜，努力修复自己负责
的Bug（特别是Showstopper）。能成功将自己拥有的Bug数降为0的人可
以穿上“Zero Bug”衬衫。
1993年7月9日，Showstopper的数量终于降低到十几个。7月16日，
NT的第509个版本被投入到最后的紧张测试中，这是1993年的第170个
版本。这样的版本编号一直延续到今天，Windows XP的发布版本使用
的编号是2600，Windows Vista的发布版本使用的编号是6000。
1993年7月23日（周五），David Cutler召集了NT 3.1开发历史上的
最后一次早9点会议。团队成员都意识到离项目结束已经很近，对其充
满期待。但是负责测试工作的Moshe Dunnie描述了一个与Pagemaker 5有
关的Showstopper，为NT的最后发布又添加了未知性。
为了解决这个最后的Showstopper，Dunnie从7月23日早晨一直工作
到7月24日夜里10点。Dunnie首先怀疑是字体和打印方面的问题，并请
这方面的工程师来进行调试，但是到中午时，这个怀疑被排除了。于是
Dunnie把希望转到图形（graphics）方面，几个工程师开始一行行地跟
踪图形方面的代码，艰苦的调试工作持续到夜里10点之后，终于发现了
一个问题，并在10min内修正了相关的代码。但是问题并没有完全解
决，当Pagemaker打印时，还是会占用非常多的内存并且极其缓慢。这
时已经是第二天（周六）的凌晨2点。Dunnie找到了Pagemaker的设计者
一同解决问题。第二天上午，终于发现了Pagemaker程序中的问题。考
虑到最终用户并不知道是NT的问题还是应用软件的问题，这个团队决
定在图形代码中加入一个标志来兼容Pagemaker程序。接下来是谨慎的
修改和严格的测试，直到确认测试通过后，团队成员才走出了办公室，
这时已经是第二天的夜里10点。
又经历了41小时的不停测试后，NT 3.1发布并送给工厂制作副本，
当时的时间是1993年7月26日下午2:30。
从上面的叙述可以看出，在NT 3.1开发的最后约半年时间内，解决
Showstopper已经成为整个开发团队的1号任务，也是决定产品能否发布
的最关键指标。
除了对项目发布日期的影响之外，Showstopper还会大量浪费团队
的资源，增加整个项目的成本。另外，项目的参与人员越多，影响也越
大，因为一个Showstopper可能导致团队中大多数人都陷入等待状态，
直到这个Showstopper被铲除。
15.2.2 未雨绸缪
在软件开发领域，像开发NT 3.1那样与Showstopper斗争的故事应该
有很多很多，而且某些可能更精彩和激烈。或许可以说，每个夜晚都有
疲倦的眼神在跟踪冗长的代码，寻找问题的根源。
与NT 3.1的故事类似，很多软件项目延期与存在大量Showstopper直
接相关。而解决Showstopper的关键是寻找问题的根源。对于很多问
题，如果找到了根源，那么解决起来通常非常简单。NT 3.1的最后一个
Showstopper也证明了这一点，寻找问题根源用去了十几个小时，修正
代码只花了10min。
通常一个软件的Beta版本已经包含了所有功能的实现。那么，从此
之后最核心的问题就是发现和修正错误，甚至有人把从Beta开始到软件
发布这一段时间叫作调试阶段。NT 3.1的第一个Beta版本是在1992年10
月12日发布的，到次年7月发布最终版本，又经历了9个多月的时间，这
相当于全部开发时间的9/57 = 16%。Windows Vista的Beta 1在2005年7月
27日发布，正式版本（Volume Licence客户）在2006年12月发布，其间
经历了大约17个月，约占总开发时间的17/67 = 25%。可见，花在Beta阶
段的时间占整个开发周期的比重是比较高的，而且这一阶段也往往是一
个项目最紧张的时候。紧张的原因有很多，时间压力当然是一个方面，
另一方面就是很多问题难以解决。因为在Beta阶段主要定位和修正错
误，所以提高调试效率是这一阶段成功的关键。
高效调试是一项系统工程，除了系统提供好的调试支持外，被调试
软件的可调试性也是至关重要的。要实现好的可调试性，应该从软件的
设计阶段就开始为软件调试做准备，然后把它贯彻到整个项目的实施过
程中。这样就可以在相对比较宽松的项目前期为紧张的调试阶段打下比
较好的基础。相反，如果平时不做准备，那么等问题出现了就要花更多
的时间，并且所需的时间变得难以估算。另外，因为很多问题是在邻近
产品发布时才出现的，所以时间非常紧迫，调试时的压力也很大。这与
未雨绸缪的经验恰好吻合，在下雨之前要把基础设施建好，不要等风雨
来临时叫苦不迭。
15.3 基本原则
软件调试是一项难度较大、复杂度较高的脑力劳动，很多时候为了
解决一个问题要付出数小时乃至数天的探索和努力。因此，提高软件可
调试性的宗旨就是要降低软件调试的难度，使软件易于被调试。软件调
试中难度最大的部分通常是寻找导致问题的根源（root cause）。那么，
降低软件调试的难度也就是要让被调试软件可以更容易地诊断和分析，
让其中的问题更容易发现。基于这一思想，我们归纳出了以下几个原则
以提高软件的可调试性。
15.3.1 最短距离原则
简言之，最短距离原则是指使错误检查代码距离失败操作的距离最
短。
这一原则的目标是及时检测到异常情况。换言之，哪里可能有失
败，哪里就做检查。举例来说，某个类的Init方法调用Load方法来从配
置文件中读取设置并初始化成员变量。因为配置文件丢失，Load方法读
取文件失败，但它没有及时检查到失败情况，并“成功”返回，而后Init
方法在使用没有正确初始化的成员变量时导致错误。对于这样的情况，
错误的第一现场被错过了，这会增加调试的难度。
遵循最短距离原则要求程序员编写足够多的错误检查代码。如果只
有一两个错误检查，那么是很难做到覆盖程序中所有错误情况的。有些
程序员不喜欢编写错误检查代码，很少做错误检查，这是应该纠正的。
15.3.2 最小范围原则
简言之，最小范围原则是指使错误报告或调试信息所能定位到的范
围尽可能小。
换句话说，就是让调试人员可以利用调试信息精确地定位到某个代
码位置，或者某个条件，以加快发现问题根源的速度。如果调试信息非
常空泛，或者模棱两可，那么这样的信息所提供的帮助便可能很有限，
甚至产生误导作用。比如有些程序员输出调试信息时经常只包含一
个“error”或“abnormal”，这样的信息聊胜于无。
最小范围原则的另一个例子是BIOS程序所使用的Post Code。BIOS
代码是CPU复位后最先执行的代码，此时还不能通过日志文件或窗口等
方式来报告错误。因此，BIOS软件使用的典型方式是向0x80端口输出
一个称为Post Code的整数。每个Post Code值代表某一个代码块，或者一
类错误。如果启动失败，那么可以从最后一个Post Code值来推测失败原
因和执行位置。通过供调试用的Post Code接收卡（插在主板上）可以接
收到Post Code。某些BIOS也会将Post Code输出在屏幕上，以方便调
试。Post Code的取值应该是精心编排的，为不同的代码块分配不同的代
码范围，每个代码具有明确的含义，这样便有利于通过Post Code值反向
追溯到相关的代码。类似地，当我们编写驱动程序和应用软件时，也应
该合理地规划返回值和错误代码，尽可能使每个错误代码有明确的范围
和含义，以便使用它可以比较精确地定位到导致错误的代码。
对于使用文字（字符串）来报告错误和调试信息的情况，应该力争
在文字中提供尽可能多而且精确的信息，使不同地方产生的错误描述能
够相互区分，这样可以很容易缩小分析范围，提高调试效率。如果很多
个函数产生的错误信息都是一样的，那么依靠这样的错误信息仍然难以
判断出是哪里出了问题。从这一角度来说，本原则也可以称为信息唯一
性原则。
15.3.3 立刻终止原则
简言之，立刻终止原则是指当检测到严重的错误时，使程序立刻终
止并报告第一现场的信息。
这一原则的一个典型应用就是操作系统的错误检查（Bug Check）
机制，比如Windows操作系统的蓝屏死机（Blue Screen Of Death，
BSOD）机制。蓝屏死机机制可以让系统在遇到危险情况时以可控的方
式停止，防止继续运行可能造成的更大损失。如第13章所介绍的，一旦
内核中的代码发起蓝屏死机，那么系统便立刻停止运行用户态代码和一
切例行工作（文件服务等），只以单线程方式记录和报告错误。另外，
使整个系统终止在发现错误的第一现场有利于分析错误发生的原因。因
为如果让系统继续执行很多任务，那么执行轨迹就会偏离错误的第一现
场。如果执行其他任务又导致错误，原始的错误情况就会被掩盖起来，
为调试设置障碍。因此，这一原则也可以称为报告第一现场原则。
这个原则的另一层含义是当程序遇到错误时，应该“让错误立刻跳
出来”，而不要使其隐匿起来。以蓝屏的方式终止是使错误跳出来的一
种方式。但这种方式的代价是比较大的，系统中运行的所有程序都会戛
然而止，没有保存的文档可能会丢失。因此有人对蓝屏机制发出质疑，
但是作者认为应该从以下两方面来看待这个问题。
触发蓝屏的原因主要是发生在内核空间的错误，有时是硬件方面的
无法恢复错误，有时是某些内核模块（设备驱动程序）中的编码错
误。对于前者，立刻终止是必要的；对于后者，因为内核模块是操
作系统的信任代码，所以对其中的错误实施严厉的制裁也是可以理
解的，这不但有利于提高内核模块的质量，而且有利于抵御侵入到
内核空间的恶意软件的攻击。
作为一个通用的操作系统，应该有一套高效且通用的错误检测和报
告规则，这套机制的主要目标是及时检测到错误，精确报告错误的
第一现场，以便可以准确地定位到导致错误的软硬件模块，然后报
告给这些部件的开发者。从这个角度来衡量，蓝屏机制是合理而且
有效的。
对于应用软件，应该根据软件的特征制订错误报告策略，根据错误
的严重级别决定应该继续执行还是停止运行。
15.3.4 可追溯原则
简言之，可追溯原则是指使代码的执行轨迹和数据的变化过程可以
追溯。
所谓可追溯（Tracable），对于代码，就是可以查找出当前线程是
如何运行到这个代码位置的。对于数据（变量），就是可以知道它的值
是经历了什么样的变化过程而成为当前值的。
很多时候，尽管我们知道了错误发生的位置，如某个模块的某个函
数，但是仍然无法理解它为什么会出错。因为这个函数本身可能根本没
有错误，发生错误是因为其他函数不应该在当前情况下调用它，或者传
递给它的参数有错误。举例来说，很多内核函数只能在特定的中断请求
级别（IRQL）下执行，如果某个驱动程序在不满足这个条件的情况下
调用这些函数，就会发生错误。但这时只知道发生错误的位置是不够
的，还必须有信息可以追溯函数的调用过程，寻找发起错误调用的那个
函数和它所属的驱动程序。
追溯代码执行轨迹最有效的技术就是利用栈中的栈帧信息来生成栈
回溯（Stack Backtrace）序列。根据第1章的介绍，当A函数调用B函数
时，函数调用指令（如call）会自动将函数B执行后的返回地址（函数A
中call指令之后的那条指令的地址）压入到栈中。以此类推，当函数B调
用C时，栈中也会记录下从函数C返回函数B的地址。根据这样的信息，
就可以产生调用函数C的过程（A→B→C），也就是程序执行到函数C
的轨迹。几乎所有调试器都提供了产生栈回溯信息的功能，比如
WinDBG的k系列命令、GDB调试器的bt（Backtrace的缩写）命令和
Visual Studio调试器的“调用栈”（Call Stack）窗口。
因为只有正确地找到每个函数的栈帧，才能据此找到它的返回地
址，所以对于使用了帧指针省略（FPO）的函数，必须依靠调试符号中
记录的FPO信息才能找到其栈帧。如果没有调试符号，那么回溯序列中