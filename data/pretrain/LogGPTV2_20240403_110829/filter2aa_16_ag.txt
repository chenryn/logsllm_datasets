在通常情况下，参数是通过函数原型声明的。这样，当函数被调用时，声明将对参数进 行自动强制转换。例如，对于 sqrt 的函数原型
double sqrt(double);
下列函数调用:
root2 = sqrt(2);
不需要使用强制类型转换运算符就可以自动将整数 2 强制转换为 double 类型的值 2.0。 标准库中包含一个可移植的实现伪随机数发生器的函数 rand 以及一个初始化种子数的
函数 srand。前一个函数 rand 使用了强制类型转换。
unsigned long int next = 1;
/* rand:              return pseudo•random integer on 0..32767 */ int rand(void)
{
next = next * 1103515245 + 12345;
return (unsigned int)(next/65536) % 32768;
}
/* srand:              set seed for rand() */ void srand(unsigned int seed)
{
next = seed;
}
练习 2•3             编写函数 htoi(s)，把由十六进制数字组成的字符串(包含可选的前缀 0x
或 0X)转换为与之等价的整型值。字符串中允许包含的数字包括:09、af 以及 AF。
2.8 自增运算符与自戚运算符
C 语言提供了两个用于变量递增与递减的特殊运算符。自增运算符++使其操作数递增 1， 自减运算符使其操作数递减  1。我们经常使用++运算符递增变量的值，如下所示:
if (c = '\n')
++nl;
++与••这两个运算符特殊的地方主要表现在:它们既可以用作前缀运算符(用在变量前 面，如++n)。也可以用作后缀运算符(用在变量后面，如 n++)。在这两种情况下，其效果都 是将变量 n 的值加 1。但是，它们之间有一点不同。表达式++n 先将 n 的值递增 1，然后再使 用变量 n 的值，而表达式 n++则是先使用变量 n 的值，然后再将 n 的值递增 1。也就是说， 对于使用变量 n 的值的上下文来说，++n 和 n++的效果是不同的。如果 n 的值为 5，那么
x = n++;
执行后的结果是将 x 的值置为 5，而
x = ++n;
将 x 的值置为 6。这两条语句执行完成后，变量 n 的值都是 6。自增与自减运算符只能作用于 变量，类似于表达式(i+j)++是非法的。
在不需要使用任何具体值且仅需要递增变量的情况下，前缀方式和后缀方式的效果相同。 例如:
if (c == '\n') nl++;
但在某些情况下需要酌情考虑。例如，考虑下面的函数 squeeze(s, c)，它删除字符串 s
中出现的所有字符 c:
/* squeeze:              delete all c from s */ void squeeze(char s[], int c)
{
int i, j;
for (i = j = 0; s[i] != '\0'; i++) if (s[i] != c)
s[j++] = s[i];
s[j] = '\0';
}
每当出现一个不是 c 的字符时，该函数把它拷贝到数组中下标为 j 的位置，随后才将 j 的值 增加 1，以准备处理下一个字符。其中的 if 语句完全等价于下列语句:
if (s[i] != c) {
s[j] = s[i]; j++;
}
我们在第 1 章中编写的函数 getline 是类似结构的另外一个例子。我们可以将该函数中 的 if 语句:
if (c == '\n') { s[i] = c;
++i;
}
用下面这种更简洁的形式代替:
if (c == '\n')
s[i++] = c;
我们再来看第三个例子。考虑标准函数 strcat(s, t)，它将字符串 t 连接到字符串 s 的尾部。函数 strcat 假定字符串 s 中有足够的空间保存这两个字符串连接的结果。下面编 写的这个函数没有任何返回值(标准库中的该函数返回一个指向新字符串的指针):
/* strcat:              concatenate t to end of s; s must be big enough */ void strcat(char s[], char t[])
{
int i, j;
i = j = 0;
while (s[i] != '\0') /* find end of s */ i++;
while ((s[i++] = t[j++]) != '\0') /* copy t */
;
}
在将 t 中的字符逐个拷贝到 s 的尾部时，变量 i 和 j 使用的都是后缀运算符++，从而保证在
循环过程中 i 与 j 均指向下一个位置。
练习 2•4             squeeze(s1, s2)，将字符串 s1 中任何与字符串 s2 中字符匹配的字符 都删除。
练习 2•5 编写函数 any(s1, s2)，将字符串 s2 中的任一字符在字符串 s1 中第一次 出现的位置作为结果返回。如果 s1 中不包含 s2 中的字符，则返回•1。(标准库函数 strpbrk 具有同样的功能，但它返回的是指向该位置的指针。)
2.9.             按位运算符
C 语言提供了 6 个位操作运算符。这些运算符只能作用于整型操作数，即只能作用于带符 号或无符号 char、short、int、long 类型:
&             按位与(AND)
|             按位或(OR)
^             按位异或(XOR)
>             右移
~             按位求反(一元运算符)
按位与运算符&经常用于屏蔽某些二进制位，例如:
n = n & 0177:
该语句将 n 中除 7 个低二进制位外的其它各位均置为 0。 按位或运算符|常用于将某些二进制位置为 1，例如: x = x | SET_ON;
该语句将 x 中对应于 SET_ON 中为 1 的那些二进制位置为 1。
按位异或运算符^当两个操作数的对应位不相同时将该位设置为 1，否则，将该位设置为
0。
我们必须将位运算符&、|同逻辑运算符&&、||区分开来，后者用于从左至右求表达式的 真值。例如，如果 x 的值为 1，Y 的值为 2，那么，x & y 的结果为 0，而 x && y 的值为 1。
移位运算符>分别用于将运算的左操作数左移与右移，移动的位数则由右操作数指 定(右操作数的值必须是非负值)。因此，表达式 x > (p+1•n)) & ~(~0 > &              ^              | 如果 expr1 和 expr2 是表达式，那么 expr1 op= expr2
等价于:
expr1 = (expr1) op (expr2)
它们的区别在于，前一种形式 expr1 只计算一次。注意，在第二种形式中，expr2 两边的圆 括号是必不可少的，例如，
x *= y + 1
的含义是:
x = x * (y + 1)
而不是
x = x * y + 1
我们这里举例说明。下面的函数 bitcount 统计其整型参数的值为 1 的二进制位的个数。
/* bitcount:              count 1 bits in x */ int bitcount(unsigned x)
{
int b;
for (b = 0; x != 0; x >>= 1) if (x & 01)
b++;
return b;
}
这里将 x 声明为无符号类型是为了保证将 x 右移时，无论该程序在什么机器上运行，左边空 出的位都用    0(而不是符号位)填补。
除了简洁外，赋值运算符还有一个优点:表示方式与人们的思维习惯比较接近。我们通 常会说"把 2 加到 i 上"或"把 i 增加 2"，而不会说"取 i 的值，加上 2，再把结果放回到 i 中"，因此，表达式 i += 2 比 i = i + 2 更自然，另外，对于复杂的表达式，例如:
yyval[yypv[p3+p4] + yypv[p1+p2]] += 2
赋值运算符使程序代码更易于理解，代码的阅读者不必煞费苦心地去检查两个长表达式 是否完全一样，也无须为两者为什么不一样而疑惑不解，并且，赋值运算符还有助于编译器 产生高效代码。
从上述例子中我们可以看出，赋值语句具有值，且可以用在表达式中。下面是最常见的一个 例子:
while ((c = getchar()) !=EOF)
其它赋值运算符(如+=、•=等)也可以用在表达式中，尽管这种用法比较少见。 在所有的这类表达式中，赋值表达式的类型是它的左操作数的类型，其值是赋值操作完
成后的值，
练习 2•9             在求对二的补码时，表达式 x &= (x –  1)可以删除 x 中最右边值为 1 的 一个二进制位。请解释这样做的道理。用这一方法重写 bitcount 函数，以加快其执行速度。
2.11 条件表达式
下面这组语句:
if (a > b)
z = a; else
z = b;
用于求 a 和 b 中的最大值，并将结果保存到 z 中。条件表达式(使用三元运算符“ ? :")提 供了另外一种方法编写这段程序及类似的代码段，在表达式
expr1 ? expr2 : expr3
中，首先计算 expr1，如果其值不等于 0(为真)，则计算 expr2 的值，并以该值作为条件 表达式的值，否则计算 expr3 的值，并以该值作为条件表达式的值。expr2 与 expr3 中只 能有一个表达式被计算。因此，以上语句可以改写为:
z = (a > b) ? a : b;              /* z = max(a, b) */
应该注意，条件表达式实际上就是一种表达式，它可以用在其它表达式可以使用的任何 地方;如果 expr2 与 expr3 的类型不同，结果的类型将由本章前面讨论的转换规则决定。 例如，如果 f 为 float 类型，n 为 int 类型，那么表达式
(n > 0) ? f : n
是 float 类型，与 n 是否为正值无关。 条件表达式中第一个表达式两边的圆括号并不是必须的，这是因为条件运算符?:的优先