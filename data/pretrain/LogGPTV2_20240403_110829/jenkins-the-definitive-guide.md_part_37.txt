false
365
integration-tests•
...
¶ Do not run the integration-tests group during the test phase.
• Run only the tests in the integration-tests group during the integration-test phase.
It often makes good sense to run your tests in parallel where possible, as it can speed up your tests
significantly (see Section 6.9, “Help! My Tests Are Too Slow!”). Parallel tests are particularly intensive
with slow-running tests that use a lot of IO, disk or network access (such as web tests), which is
convenient, as these are precisely the sort of tests we usually want to speed up.
TestNG provides good support for parallel tests. For instance, using TestNG, you could configure your
test methods to run in parallel on ten concurrent threads like this:
org.apache.maven.plugins
maven-surefire-plugin
2.5
methods
10
As of JUnit 4.7, you can also run your JUnit tests in parallel using a similar configuration. In fact, the
configuration shown above will work for JUnit 4.7 onwards.
You can also set the  configuration item to classes instead of methods, which will try to
run the test classes in parallel, rather than each method. This might be slower or faster, depending on the
number of test classes you have, but might be safer for some test cases not designed with concurrency
in mind.
Mileage will vary, so you should experiment with the numbers to get the best results.
A.2. Automating Your Tests with Ant
Setting up automated testing in Ant is also relatively easy, though it requires a bit more plumbing than
with Maven. In particular, Ant does not come packaged with the JUnit libraries or Ant tasks out of the
box, so you have to install them somewhere yourself. The most portable approach is to use a Dependency
Management tool such as Ivy, or to place the corresponding JAR files in a directory within your project
structure.
To run your tests in Ant, you call the  task. A typical Jenkins-friendly configuration is shown
in this example:
366
¶
•
‚
„
»
…
¶ We need to set up a classpath containing the junit and junit-ant JAR files, as well as the
application classes and any other dependencies the application needs to compile and run.
• The tests themselves are run here. The haltonfailure option is used to make the build fail
immediately if any tests fail. In a Continuous Integration environment, this is not exactly what we
want, as we need to get the results for any subsequent tests as well. So we set this value to no and
use the failureproperty option to force the build to fail once all of the tests have finished.
‚ The classpath needs to contain the JUnit libraries, your application classes and their dependencies,
and your compiled test classes.
„ The Junit Ant task can produce both text and XML reports, but for Jenkins, we only need the
XML ones.
” The fork option runs your tests in a separate JVM. This is generally a good idea, as it can avoid
classloader issues related to conflicts with Ant’s own libraries. However, the default behaviour of
the JUnit Ant task is to create a new JVM for each test, which slows down the tests significantly.
The perBatch option is better, as it only creates one new JVM for each batch of tests.
» You define the tests you want to run in a fileset element. This provides a great deal of flexibility,
and makes it easy to define other targets for different subsets of tests (integration, web, and so on).
… Force the build to fail after the tests have finished, if any of them failed.
If you prefer TestNG, Ant is of course well supported here as well. Using TestNG with the previous
example, you could do something like this:
367
TestNG is a very flexible testing library, and the TestNG task has many more options than this. For
example, to only run tests defined as part of the “integration-test” group that we saw earlier, we could
do this:
Or to run your tests in parallel, using four concurrent threads, you could do this:
368
369
Index disabling, 121
in freestyle build jobs, 114-117
archiving build jobs, 355-356
Artifactory
A
Enterprise Repository Manager, 124, 125
acceptance tests, automated, 6, 137, 157-160 Jenkins support for, 5
Acceptance-Test Driven Development, 6 Artifactory plugin, 280
active (push) notifications, 197 artifacts (see binary artifacts)
Active Directory, Microsoft, as security realm, Atlassian Crowd, as security realm, 180-181
178 Audit Trail plugin, 192-193
administrator auditing user actions, 191-194
for Jenkins internal user database, 173 authorization, 171, 171
for matrix-based security, 183 (see also security)
aggregate test results, 300-301 matrix-based security, 183-187
Amazon EC2 cloud computing service, 318-322 no restrictions on, 172-173
Amazon EC2 plugin, 320 project-based security, 187-189
Amazon Machine Image (AMI), 319 role-based security, 189-191
Amazon Web Services (AWS), 319 automated deployment, 325-329
AMI (Amazon Machine Image), 319 to application server, 330-341
analysis (see code coverage metrics; code quality database updates with, 326-329
metrics; tests) deployment script for, 326
Ant, 76-76 rolling back changes in, 329
automating tests, 366-368 smoke tests for, 329
code coverage metrics with Cobertura, 149-151 automated nightly builds, 5
code quality metrics automated tests (see tests)
with Checkstyle, 230 AWS (Amazon Web Services), 319
with CodeNarc, 238
with FindBugs, 236 B
with PMD and CPD, 233
Backup plugin, 353
configuring, 76-76
backups, 64, 351-355
environment variables, accessing from, 110
batch scripts, 77, 107-108
in freestyle build steps, 107-107
BDD (Behavior-Driven Development), 137
installing, 76
BDD (Behaviour Driven Development), 158
ANT_OPTS environment variable, 56
binary artifacts
application server
archiving, 26
automated deployment to, 330-341
deploying to Enterprise Repository
Java applications, 330-339
Manager, 122-126
scripting-based applications, 339-341
disabling, 121
deploying Jenkins to, 16, 55-56
in freestyle build jobs, 114-117
upgrading Jenkins on, 65
reusing in build pipeline, 289-292
archives of binary artifacts, 26
Boolean parameters, 261
deploying to Enterprise Repository Manager,
build agents
122-126
configuring for multiple JDK versions, 73
monitoring, 317 configuration matrix for, 272
build history creating, 268-269
in builds directory, 62-64 custom axis for, 271
details regarding, 30-32 JDK axis for, 270
disk usage of, 345-349 running, 271-274
number of builds to keep, 83 slave axis for, 269-270
parameterized, 265 naming, 22
permissions for, 186 parameterized, 257-265
results summary for, 27, 30 build scripts for, 259-260
build jobs, 81, 81 creating, 257
(see also freestyle build jobs; Maven build jobs) history of, 265
archiving, 355-356 run against a Git tag, 263-264
binary artifacts from (see binary artifacts) run against a Subversion tag, 262-263
code coverage metrics in (see code coverage starting remotely, 264-265
metrics) types of parameters, 258, 261-262
code quality metrics in (see code quality reports resulting from (see reporting)
metrics) run numbers for, as parameters, 261
copying, 82 running in parallel, 282-285
creating, 21-26, 81-82 scheduling (see build triggers)
delaying start of, 71 source code location for, 23
dependencies between, 282 status of, while running, 26
distributed across build servers, 305-305 steps in, adding, 25-26, 33, 36
associating slave nodes to jobs, 315-317 success of, indicator for, 28
cloud-based build farm for, 318-322 tests in (see tests)
creating slave nodes, 306 triggering manually, 26, 27, 105
master/slave architecture for, 305-315 types of, 22, 81
monitoring slave nodes, 317 unstable build from, 141
starting slave nodes, 306-315 criteria for, 115, 154, 242, 246
external, monitoring, 81 indicator for, 37
failed notifications for, 118, 197, 200
claiming, 202 triggering another build after, 101, 118
details regarding, 141-143 Build Pipeline plugin, 301
example of, 28-32 build pipelines, 285-304
indicator for, 28, 30 aggregating test results for, 300-301
notifications for, 197, 200 deployment pipelines from, 301-304
global properties for, 71-72 Maven version numbers for, 286-288
history of (see build history) promotions in, 286, 292-300
Javadocs generation in, 33-34 reusing artifacts in, 289-292
joins in, 283-284 Build Promotion plugin, 330
locking resources for, 284-285 build radiators, 204-205
migrating, 356-359 build scripts (see scripts)
multiconfiguration, 268-274 build server, 5
combination filter for, 272 installing Jenkins on, 46-47
372
memory requirements for, 46 with Cobertura, 35-41, 147-156
monitoring load of, 349-350 software for, 146
multiple, running builds on (see distributed code examples, using, xxviii
builds) code quality metrics, 6, 227-228
processor requirements for, 46 in build jobs, 228
upgrading, 168 with Checkstyle, 229-232, 245
virtual machine for, 46, 168 code complexity, 248-249
build tools, configuring, 74-77 with CodeNarc, 238-239
build triggers with CPD, 232-236
configuring, 24-25 with FindBugs, 236-238, 245
for freestyle build jobs, 100-105 with IDE, 228
manual, 26, 27, 105 open tasks, 249-250
parameterized, 265-267 plugins for, 227
polling SCM for version control changes, 102 with PMD, 232-236, 245
at regular intervals, 101-102 software for, 228, 229
remotely triggering from version control with Sonar, 227, 251-254
system, 103-104 with Violations plugin, 239-245
when another build has finished, 101 code reviews, 227
BUILD_ID environment variable, 109 CodeNarc, 238-239
BUILD_NUMBER environment variable, 109 coding standards, 227
BUILD_TAG environment variable, 109 commit messages, excluding from triggering build
BUILD_URL environment variable, 109 jobs, 88
builds directory, 62-64 config.xml file, 62
configuration, 17-21, 67-70
C