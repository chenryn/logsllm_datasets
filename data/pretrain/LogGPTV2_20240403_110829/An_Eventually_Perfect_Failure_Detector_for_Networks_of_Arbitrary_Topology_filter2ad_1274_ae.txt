length 1. Recall that a pair (q, ttl) its added to the bag of p if
T T Lp[q] − 1 > 0. Then, when Algorithm 2 starts, process
p sends a HB message to every neighbor included in its
bag, the pair (p, localT T L) (line 7) with localT T L = 2.
This is to guarantee that neighbors forward the information
of p to their neighbors. And as p discovers new processes
in the network, namely, receives pairs from processes that
it does not know, the localT T L will grow. Thus, instead
of ﬁxing the TTL of p to n − 1, it grows dynamically as
processes are discovered. The data structures used for storing
timeouts, clock values, etc. need to be dynamic as well.
In Algorithm 2 we use the array notation for convenience,
but in an implementation, a more efﬁcient (dynamic) data
structure will be used.
When a HB message from a neighbor arrives is the
moment when new processes may be discovered. In the
local variable known are stored processes that have been
discovered. It is initialized with the set of neighbors of p.
When p receives a HB message from a neighbor q containing
a bag, p goes through the pairs (r, m) in the bag and it
checks if r is a known process. If that is the ﬁrst time that p
receives a message labeled with r, p adds process r to its set
of known processes (line 14), and adds a new entry in every
variable (line 15), initialized as described in Algorithm 1.
Algorithm 2 shows the modiﬁcations that are needed to
be done (it does not include all the code); it includes only
the lines that need to be modiﬁed in every module, as well
as the new variables that are needed.
Algorithm 2 Code for process p
Constants
1: neighbors
2: T
Variables
3: known = neighbors
(cid:2) Set containing processes known
by p. This set contains only the neighbors initially
4: localT T L = 2
(cid:2) TTL value of p
HB bag = {(p, localT T L)}
The same HB module as Algorithm 1
5: every T units of time
6: begin:
7:
8:
9: end
10: upon receiving (cid:5)HB bag(cid:6) from a neighbor q
11: begin:
12:
13:
if r /∈ known then
for each (r, m) ∈ bag such that r /∈ neighbors\{q} do .
(cid:2) A new process has been
discovered
known = known ∪ {r}
Add a new entry in lastHB, timeout and suspect
and initialize
localT T L = localT T L + 1
(cid:2) The length
of the longest path may grow up with the discovery of
a process
else
14:
15:
16:
17:
273
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:55:15 UTC from IEEE Xplore.  Restrictions apply. 
Include code of Algorithm 1 from line 24 to 35
18:
19:
20:
21: end
end if
end for
B. Correctness proof
To prove the correctness of Algorithm 2, we need to show
that the implementation satisﬁes the strong completeness
and eventual strong accuracy for partitionable networks
with unknown membership. We only present a sketch of the
proof.
The proof is very similar to the one given in Section III-B.
The ﬁrst thing that needs to be noticed is that the localT T L
of every process p is bounded by n + 1 because p can
receive a pair labeled with every process in the network.
The localT T L only is incremented when a new process is
discovered (line 16). Then, we have to show that given two
correct processes p and q connected by a correct path in the
ﬁnal graph, q eventually knows p and q eventually does not
suspect p.
For proving that all the pairs of a crashed process p
eventually fade out from the network, the proof is similar
to that of Lemma 9, but assuming that this is only true
for processes that know p. Similarly with the proof of
Lemma 11, only processes at a different partition than p that
know p stops sending messages labeled with p. Processes
that do not know p do not send pairs labeled with p.
V. CONCLUSIONS
In this work we presented an algorithm implementing an
eventually perfect failure detector in an arbitrary network
connected by ADD channels using time-to-live values, with
messages of O(n log n) size. In our basic implementation,
the number of processes in the network is known. Then
we show how to extend the algorithm to work when each
process knows initially only its neighbors. A process dy-
namically adapts its timeouts and failure information as it
learns of knew processes in the network.
To the best of our knowledge, this is the ﬁrst time that
the technique of time-to-live values (well-known in the
networking literature) is used for failure detectors. We make
a ﬁrst step in showing that is a useful technique that leads to
ﬂexible failure detector implementations, of small message
size. Further work is needed to study the performance of
our implementation. Also, in future work we plan to study
how to adapt it to more dynamic network scenarios [12].
Especially we are interested in showing that our algorithm
can be adapted to other partially synchronous models such
as the one of [13], and even ones where channels are
unidirectional or they may fail in one direction. Namely,
in situations where reliable link protocol implementations
are impossible, see e.g. [23]. An interesting open question
is if our approach would be useful in dynamic networks with
unknown membership, of the time-free type; such a failure
detector (that does not rely on timers to detect failures) has
been proposed in [24].
There are many interesting opportunities to explore tuning
and extensions of our time-to-live approach. For example,
while a node remains alive, everyone in its connected com-
ponent keeps on receiving heartbeats, albeit of low intensity
if it is a distant node, and hence the intensities can be used to
estimate distances. It seems that in some situations it is not
necessary that a node sends its current set of TTL values
to all its neighbors, to reduce load, it could send it in a
round-by-round way, at the cost of increasing the time to
detect failures. It is also of interest to investigate ways of
tolerating very slow, old messages that can be delivered by
an ADD channel, long after a process is dead. The algorithm
works correctly, but these messages can affect performance
by temporarily stopping to suspect a process that is long ago
dead. This problem is inherent to the ADD deﬁnition when
using bounded size messages, but we plan to explore this
issue further in future work.
Yet another piece of future work is as follows. In the
algorithm we present, a process takes information from a
neighbor only from its adjacent link. We plan to study in
future work the effect of lifting this restriction, and hence,
allowing a process q to receive information (perhaps faster)
about a neighbor process p indirectly, from another neighbor.
ACKNOWLEDGMENT
The authors thank the anonymous reviewers for their
comments, and funding from UNAM-PAPIIT IN109917.
REFERENCES
[1] T. D. Chandra and S. Toueg, “Unreliable failure detectors for
reliable distributed systems,” Journal of the ACM (JACM),
vol. 43, no. 2, pp. 225–267, 1996.
[2] M. K. Aguilera, C. Delporte-Gallet, H. Fauconnier, and
S. Toueg, “Stable leader election,” in Proceedings of
the
15th International Conference on Distributed Computing
(DISC), ser. Lecture Notes in Computer Science book series,
no. 2180. London, UK, UK: Springer-Verlag, 2001, pp.
108–122. [Online]. Available: http://dl.acm.org/citation.cfm?
id=645958.676119
[3] M. K. Aguilera, W. Chen, and S. Toueg, “On quiescent
communication,” SIAM J. Comput., vol. 29,
[Online]. Available:
reliable
no. 6, pp. 2040–2073, Apr. 2000.
https://doi.org/10.1137/S0097539798341296
[4] R. Guerraoui, M. Kapalka, and P. Kouznetsov, “The
failure detectors to boost obstruction-freedom,”
weakest
in Proceedings of
the 20th International Conference
ser. Lecture Notes
on Distributed Computing (DISC),
Berlin, Heidelberg:
in Computer Science, no. 4167.
Springer-Verlag, 2006, pp. 399–412. [Online]. Available:
http://dx.doi.org/10.1007/11864219 28
274
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:55:15 UTC from IEEE Xplore.  Restrictions apply. 
[17] A. S. Tanenbaum and D. Wetherall, Computer networks,
[Online]. Available: http:
Pearson, 2011.
5th Edition.
//www.worldcat.org/oclc/698581231
[18] M. K. Aguilera, W. Chen, and S. Toueg, “Heartbeat: A
timeout-free failure detector for quiescent reliable communi-
cation,” in International Workshop on Distributed Algorithms.
Springer, 1997, pp. 126–140.
[19] M. Larrea, A. F. Anta, and S. Ar´evalo, “Implementing the
weakest failure detector for solving the consensus problem,”
International Journal of Parallel, Emergent and Distributed
Systems, vol. 28, no. 6, pp. 537–555, 2013.
[Online].
Available: https://doi.org/10.1080/17445760.2012.753180
[20] M. Larrea, A. Lafuente,
I. Soraluze, R. Corti˜nas, and
J. Wieland, “On the implementation of communication-
optimal failure detectors,” in Proc. Latin-American Sympo-
sium on Dependable Computing (LADC), ser. Lecture Notes
in Computer Science, A. Bondavalli, F. Brasileiro, and S. Ra-
jsbaum, Eds., no. 4746. Berlin, Heidelberg: Springer, 2007,
pp. 25–37.
[21] S. Sastry, S. M. Pike, and J. L. Welch, “Crash-quiescent
failure detection,” in Proceedings of the 23rd International
Conference on Distributed Computing (DISC), ser. Lecture
Notes in Computer Science, vol. 5805. Berlin, Heidelberg:
Springer-Verlag, 2009, pp. 326–340. [Online]. Available:
http://dl.acm.org/citation.cfm?id=1813164.1813207
[22] E. Jim´enez, S. Ar´evalo, and A. Fern´andez, “Implementing
unreliable failure detectors with unknown membership,” In-
formation Processing Letters, vol. 100, no. 2, pp. 60–63,
2006.
[23] N. A. Lynch, Distributed Algorithms.
San Francisco, CA,
USA: Morgan Kaufmann Publishers Inc., 1996.
[24] F. Greve, P. Sens, L. Arantes, and V. Simon, “Eventually
strong failure detector with unknown membership,” Comput.
J., vol. 55, no. 12, pp. 1507–1524, Dec. 2012. [Online].
Available: http://dx.doi.org/10.1093/comjnl/bxs084
[5] S. M. Pike, Y. Song, and S. Sastry, “Wait-free dining under
eventual weak exclusion,” in Distributed Computing and Net-
working (ICDCN), ser. Lecture Notes in Computer Science,
S. Rao, M. Chatterjee, P. Jayanti, C. S. R. Murthy, and S. K.
Saha, Eds., no. 4904. Berlin, Heidelberg: Springer Berlin
Heidelberg, 2008, pp. 135–146.
[6] S. M. Pike and P. A. G. Sivilotti, “Dining philosophers
with crash locality 1,” in 24th International Conference
on Distributed Computing Systems, 24-26 March 2004,
Hachioji, Tokyo, Japan, 2004, pp. 22–29. [Online]. Available:
https://doi.org/10.1109/ICDCS.2004.1281564
[7] Y. Song and S. M. Pike, “Eventually k-bounded wait-
free distributed daemons,” in The 37th Annual IEEE/IFIP
International Conference on Dependable Systems and
Networks, DSN 2007, 25-28 June 2007, Edinburgh, UK,
Proceedings, 2007, pp. 645–655.
[Online]. Available:
https://doi.org/10.1109/DSN.2007.44
[8] R. Guerraoui, “On the hardness of failure-sensitive agreement
problems,” Inf. Process. Lett., vol. 79, no. 2, pp. 99–104,
Jun. 2001.
[Online]. Available: http://dx.doi.org/10.1016/
S0020-0190(00)00171-X
[9] M. Larrea, A. Fern´andez, and S. Ar´evalo, “On the
implementation of unreliable failure detectors in partially
synchronous systems,” IEEE Trans. Computers, vol. 53,
no. 7, pp. 815–828, 2004.
[Online]. Available: https:
//doi.org/10.1109/TC.2004.33
[10] C. Dwork, N. Lynch, and L. Stockmeyer, “Consensus
in the presence of partial synchrony,” J. ACM, vol. 35,
no. 2, pp. 288–323, Apr. 1988.
[Online]. Available:
http://doi.acm.org/10.1145/42282.42283
[11] M. K. Aguilera, W. Chen, and S. Toueg, “Using the heartbeat
failure detector for quiescent reliable communication and
consensus in partitionable networks,” Theoretical Computer
Science, vol. 220, no. 1, pp. 3–30, 1999.
[12] F. Greve, L. Arantes, and P. Sens, “What model and what
conditions to implement unreliable failure detectors in dy-
namic networks?” in Proceedings of the 3rd International
Workshop on Theoretical Aspects of Dynamic Distributed
Systems. ACM, 2011, pp. 13–17.
[13] M. Hutle, “An efﬁcient failure detector for sparsely connected
networks,” in Parallel and Distributed Computing and Net-
works, 2004, pp. 369–374.
[14] S. Sastry and S. M. Pike, “Eventually perfect failure detectors
using add channels,” in Proc. 5th Int. Symposium on Parallel
and Distributed Processing and Applications (ISPA), ser.
Lecture Notes in Computer Science, no. 4742.
Berlin,
Heidelberg: Springer, 2007, pp. 483–496.
[15] S. Kumar and J. L. Welch, “Implementing diamond P
with bounded messages on a network of ADD channels,”
CoRR, vol. abs/1708.02906, 2017.
[Online]. Available:
http://arxiv.org/abs/1708.02906
[16] J. F. Kurose and K. W. Ross, Computer networking: a top-
Pearson Higher Ed,
down approach: international edition.
2013.
275
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:55:15 UTC from IEEE Xplore.  Restrictions apply.