- 最近最少使用算法LRU
  - 老化算法
  - 双向链表和HashMap实现
- LFU最不经常使用
  - 计算频率
###### **分段技术**
按照类型把进程的地址空间分为多个，每一种功能对应一个地址空间，独立增长，这就是分段思想，分段使得我们不需要关心如何管理和分割地址空间。分段与分页的区别在于，分段存在于逻辑地址的概念上，是一种划分逻辑地址的思想，而分页是解决逻辑地址到物理地址的映射过程的。
#### 文件系统
**文件命名**
- 长度为255
- windows大小写不敏感，linux是大小写敏感
**文件结构**
- 线性+定长
- 树状结构
**目录结构**
- 单层结构
  - 难以查找文件
- 两层结构
  - 解决了命名冲突问题
  - 提高了搜索效率
  - 可以文件共享和保护
- 多层次
  - 文件和目录
**空间分配问题**
- 顺序存储
  - 容易实现、可以直接访问和顺序访问
  - 外部碎片，文件的**长度必须提前知道**
- 链式存储
  - 没有外部碎片、文件变长
  - **随机访问**性能差，存在结构性开销
- i-node
  - 所有的i-node统一存储
  - 每个文件都有自己i-node结点，支持直接访问，不存在外部碎片
  - i-node节点的结构性开销
**共享文件**
- i-node
  - 硬链接，每个节点都会指向这个文件
- 符号链接
  - 其他接待保存路径
#### IO
分类
- 块设备：把信息存储在固定的大小中，每个块都有自己的地址，每个块都能独立于其他块而读写
- 字符设备：不能寻址，也没有任何寻道操作
**轮询**
cpu的干预非常频繁
![image-20210729214538130](C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210729214538130.png)
**中断驱动**
容控制器自己完成任务后向cpu发一个中断信号，处理中断过程就是从控制器中读**一个字的数据**到cpu寄存器中，再写入内存，接着恢复去执行别的，等待下一次中断信号；但是中断次数过多也不好
![image-20210729215353822](C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210729215353822.png)
###### IO多路复用技术
IO多路复用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部空间，使得流之间共享数据非常容易；
但是并发粒度的缩小会让代码量上升，而且使得如果一个逻辑流在忙于读文本行，其他是无法进展的
**DMA**
![image-20210729220610942](C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210729220610942.png)
5.**主要缺点和主要优点**
优点:数据传输以“块”为单位，CPU介入频率进- -步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进- -步增加。CPU和/O设备的并行性得到提升。
缺点: CPU每发出一- 条I/0指令，只能读/写一个或多个连续的数据块。
**控制器的任务**
把串行的位流转换成字节块，并且进行有必要的**错误校验**
CPU**如何与设备控制器何数据缓冲区进行通信**？
- 每个控制存储器被分配一个IO端口；只能由操作系统能对其访问；使用特殊的指令去读写
- 讲IO映射到内存空间中；像访问内存空间一样去访问；不需要特殊的保护机制去组织用户进程执行IO操作
#### 五种IO模型
1. 同步阻塞IO
   ![preview](https://pic3.zhimg.com/v2-abef476a75afe52193be9577dcbcb88a_r.jpg)
2. 同步非阻塞IO
   非阻塞IO是在应用调用recvfrom读取数据时，如果该缓冲区没有数据的话，就会直接返回一个EWOULDBLOCK错误，不会让应用一直等待中。在没有数据的时候会即刻返回错误标识，那也意味着如果应用要读取数据就需要**不断的调用recvfrom请求**，直到读取到它数据要的数据为止。
3. 多路复用IO
   ![preview](https://pic3.zhimg.com/v2-260e80cbec13cbcc677779690f6ab2fa_r.jpg)
   - 为什么会产生多路复用IO？
     因为当有多个网络连接，连接到某个进程的时候，我们想要监听这些socket接口，并当这些接口有数据返回的时候，进行处理。一种解决方案就是，对于每一个socket接口，我们都开辟一个线程来侦听，处理。这样做的局限就是，当连接数变大的时候（成千上万），那么我们就要创建多个线程变量。创建线程变量开销很大，而且，线程切换的开销也会变大。所以我们就寻求一种，**单线程的情况下监听多个socket接口的方式**，所以就会有多路复用IO的诞生。
     本质上还是同步非阻塞IO，但是将阻塞放在了select上
4. 信号驱动IO,继续改良复用IO,思想是发出请求后等你数据准备好了就通知我
5. 异步IO
   ![preview](https://pic4.zhimg.com/v2-5095ab1ffe868a2577bc15310d740293_r.jpg)
   异步IO需要更强的操作系统支持；当用户线程收到通知时，数据已经被内核读取完毕，**并放在了用户线程指定的缓冲区内**，内核在IO完成后通知用户线程直接使用即可。
#### 死锁
死锁的定义：如果一组进程中每个进程都在等待一个事件，而这个事件只有该集合中的另一个进程才能引起，那么该集合就是死锁的。（都占有资源，然后互相等待）
**引起死锁四个条件**
- 互斥条件：资源要么分配给一个进程，要么可用
- 占有资源和等待
- 不可抢占
- 环路等待
**死锁检测**
1. 建模之后寻找环路
2. 多资源的死锁检测，矩阵，先给能满足的，然后释放
**死锁恢复**
- 抢占
- 回滚
- 杀死进程
**死锁避免**
- 资源轨迹图
- 安全状态和不安全状态
- 单个银行家算法
- 多个资源的银行家算法
**死锁预防**
- **破坏互斥条件**：有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。
- **破环占有和等待条件**：预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。**会有“饥饿”**
- **破环不可抢占资源**：当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。
- 破坏循环等待条件：规定每个进程，必须按编号递增的顺序请求资源
活锁：互相谦让，导致谁都没办法开始
**中断**
中断主要是一个cpu硬件产生的定时脉冲，为了能通知操作系统是时间片到了，将cpu的使用权限从用户态切换到内核态中，内核态去根据中断信号进行不同的处理；
中断可能来自cpu内部，也可能来自外部；来自内部就是用户申请使用特权指令、时间片到了；外部一般是外设导致，如键盘输入
**系统调用：**
用户态程序通过系统调用的方法来申请操作系统的服务，因为其可能涉及到一些特权指令才能完成
陷入指令：是唯一一个只能在用户态不能在内核态执行的指令