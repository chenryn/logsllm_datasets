TheDAO attack [12], leading to a loss of over $50 million
worth of Ether at the time the attack occurred.
Let us consider the vulnerable smart contract Bank, a
simpliﬁed version of TheDAO [28], as shown in Fig. 7.
Anyone can deposit ether into Bank, the amount of ether
is recorded in the mapping balance. The ether deposited
can be withdrawn by calling withdraw(), which sends the
ether to the msg.sender address. This transfer implicitly
triggers a fallback method (an anonymous method that does
not take any arguments) of the receiver. This default behavior
can have security consequences as the execution ﬂow can be
controlled by a remote fallback method. The re-entrancy attack
can be lunched by an attacker using the smart contract shown
in Fig. 7. She ﬁrst calls the deposit() method to deposit
two ethers into the target smart contract Bank. Now she is
mapping(address=>uint) balance;
function addBalance() public{
balance[msg.sender] +=msg.value;
}
function withdraw() public{
1 contract Bank{
2
3
4
5
6
7
8
uint amount = balance[msg.sender];
if (msg.sender.call.value(amount)() == false)
balance[msg.sender] = 0;
bool isAttack; address bank;
function Attacker(addr _bank, bool _isAttack){
bank = _bank; isAttack = _isAttack;
}
function() payable{
if(isAttack == true){
{throw;}
}
9
10
11 }
12
13 contract Attacker{
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30 }
}
}
}
function deposit(){
}
function withdraw(){
bank.withdraw():
isAttack = false;
if(bank.withdraw()) {throw;}
bank.call.value(2).addBalance();
Fig. 7: The Bank contract with a re-entrancy vulnerability and the Attacker
contract exploiting it.
ready to attack the target by calling the withdraw() method
of Attacker. Subsequently, Attacker.withdraw()
calls Bank.withdraw() which then triggers a recursive
Bank.withdraw() call via Attacker’s fallback method,
and the line 11 of the Bank smart contract is never reached.
The above attack strategy effectively moves all ether from
Bank to the account controlled by the attacker.
To prevent Bank from being exploited, we use SMACS
with a rule employing ECFChecker [29] – a developed tool for
detection of effectively callback free objects [12]. To integrate
that, the TS deploys an ECFChecker-supported implemen-
tation running an off-chain testnet with the Bank contract
deployed. For every token request, the TS calls a requested
method with the passed arguments and observes the output of
ECFChecker. The TS issues the tokens only if ECFChecker
does not report any security issue. We emphasize that the
described integration gives the contract owner ECFChecker
security beneﬁts without requiring Ethereum participants to
update their conﬁgurations to support ECFChecker. In § VI-B
we show the efﬁciency of this setup.
VI. IMPLEMENTATION AND EVALUATION
To evaluate our design, we fully implement the SMACS
framework. SMACS-enabled smart contracts are developed by
Solidity v0.4.24 and deployed on a testnet. The TS is
implemented as a web server running Node.js v10.2.1
bundled with the node-localStorage package for stor-
ing rules and signature key-pairs. We implement client and
owner with web3.js [30]. This software interacts with
deployed SMACS-enabled smart contracts and TSes. We use
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:34:17 UTC from IEEE Xplore.  Restrictions apply. 
228
Tab. II: Single token processing gas cost.
Tab. IV: Storage cost for the bitmap (this cost is one-time).
Cost
Verify
Misc
Total
USD
Cost
Verify
Misc
Bitmap
Total
USD
Token type (without the one-time property)
Super
108282 (65%)
57675 (35%)
165957
0.041
Method
115108 (67%)
57675 (33%)
172783
0.042
Argument
330889 (85%)
57678 (15%)
388567
0.094
Token type (with the one-time property)
Super
108531 (56%)
57426 (30%)
27471 (14%)
193428
0.047
Method
115651 (58%)
56994 (28%)
27839 (14%)
200484
0.048
Argument
330914 (79%)
57331 (14%)
28003 (7%)
416248
0.101
Tab. III: Gas cost for multiple one-time argument tokens.
Cost
1
Verify 330914 (79%)
Misc
57331 (14%)
Bitmap 28003 (7%)
–
Parse
416248
Total
USD
0.101
Number of Token
2
662952 (79%)
102991 (12%)
56746 (7%)
16986 (2%)
839675
0.204
3
994552 (78%)
150463 (12%)
84612 (7%)
34182 (3%)
1263809
0.307
4
1326506 (78%)
203499 (12%)
112034 (7%)
57872 (3%)
1699911
0.412
the Ethereum’s ECDSA signature scheme as the default one,
as Ethereum provides a native and optimized support for it.
A. Gas Cost
In the SMACS framework, clients send transactions with
proper tokens which are veriﬁed by smart contracts. Therefore,
the main cost is introduced with respect to the computation
and storage whose utilization is charged by the Ethereum
network. We perform a series of experiments to measure the
cost introduced by SMACS in terms of gas consumption.
We conduct experiments for different types of tokens and
record their gas cost, together with the cost converted to US
dollars in Tab. II. The conversion was according to the gas
price from [31] at the time of writing the paper. From the table,
we can see that the dominating operation is the signature ver-
iﬁcation. The cost also increases in arguments tokens as they
require more processing (argName and argValue have to
be processed). However, the overall cost of a token veriﬁcation
is around $0.04 for super and method tokens and around $0.1
for argument tokens. As shown in the table, for tokens with the
one-time property the veriﬁcation gas consumption is similar,
despite additional operations are required by the bitmap.
As discussed in § IV-D, SMACS supports transactions
that invoke a call chain of contracts. In this case, the token
veriﬁcation cost varies according to the depth of the chain,
and additional cost is induced since a contract has to parse the
passed token array before veriﬁcation. We conduct analogical
experiments as in the previous case and the results are shown
in Tab. III and Fig. 8. (Note that the table presents the results
for the argument token type whose veriﬁcation is around two
times more gas consuming than other types.) As presented, the
veriﬁcation cost increases linearly with the call chain length.
Cost
Storage
Deployment
USD
Transaction frequency (tx/s)
35
15.38 KB
8849037
2.140
3.5
1.54 KB
886054
0.214
0.35
0.154 KB
88605
0.021
·106
Super
Method
Argument
Arg. (one-time)
1.8
1.5
1.2
0.9
0.6
0.3
t
s
o
C
s
a
G
1
2
3
4
Number of tokens
Fig. 8: Aggregated gas cost for verifying multiple tokens.
Implementing the one-time property requires to store a
bitmap by smart contracts. The size of this storage depends
on the token lifetime and the expected transaction frequency,
however, this cost is one-time, paid upon the contract creation.
To give insights on the cost we take the ten most popular
smart contracts based on the number of transactions by Jan,
2019 [32] and analyze their transactions distribution. We found
that on average the transaction peak is 35 tx/s which is close to
the Ethereum’s maximum throughput [33]. Setting the lifetime
of one-time tokens to one hour and assuming conservatively
that all transactions use one-time tokens, Tab. IV shows the
required storage and its cost. We can see that to handle even
35 one-time tokens/s a smart contract has to be initialized with
storage costing only one-time fee of $2.14. This cost is linear
in transaction frequency and token lifetime.
B. Token Service Performance
a) TS Throughput: We evaluate the TS throughput
running a TS instance on a system with macOS Sierra 10.12.6,
Intel Core i5 CPU (2.7 GHz), and 8GB RAM. For each token
type, we send 10i (0 ≤ i ≤ 5) token requests to the TS, record
the total time needed by the TS , and compute the average time
required per token request. The rules used are composed of
blacklists and whitelists as presented in Fig. 6. The obtained
results are summarized in Fig. 9.
From Fig. 9 we can see the number of token requests
handled per second raises when the requests are processed in
batches. The throughput becomes stable when the number of
requests is greater than 105, with the time cost about 5ms for
most token types. The single TS instance can easily handle all
transactions processed by the current Ethereum main network
even in peak times. We found the ever highest transactions
peak in Ethereum for one of the most popular smart contracts
– CryptoKitties [34] when it received about 48 transactions
per second (on 05-Dec-17 00:43:03 UTC [35], [36]).
b) Integration with Runtime Tools: In § V we integrate
SMACS with two runtime veriﬁcation tools, i.e., Hydra and
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:34:17 UTC from IEEE Xplore.  Restrictions apply. 
229
Super
Method
Argument
Arg. (one-time)
d
n
o
c
e
s
r
e
p
d
e
s
s
e
c
o
r
p
s
t
s
e
u