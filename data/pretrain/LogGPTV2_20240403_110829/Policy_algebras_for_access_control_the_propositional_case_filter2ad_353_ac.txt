### 1. Propagation and Decision Policies

The propagation policy, denoted as \( P_p \), maps an empty set of authorizations to the following set of permissions:
- \((\text{vehicle}, \text{salesman}, +\text{Sell})\) for vehicles (BMW, SAAB) and salesmen (John, Mary, Bob, Alice)
- \((\text{vehicle}, \text{approved by}, +\text{OK})\) for vehicles (BMW, SAAB) and approvers (John, Mary)

The decision policy, denoted as \( P_d \), is identical to the closed policy in our example. It takes the set of permissions generated by \( P_p \) and transforms it into a new set of permissions, which includes:
- \((\text{vehicle}, \text{salesman}, +\text{Sell})\) for vehicles (BMW, SAAB) and salesmen (John, Mary, Bob, Alice)
- \((\text{vehicle}, \text{approved by}, +\text{OK})\) for vehicles (BMW, SAAB) and approvers (John, Mary)
- \((\text{vehicle}, \text{approved by}, -\text{OK})\) for vehicles (BMW, SAAB) and approvers (Alice, Bob)

### 2. Integrity Rules

The next two rules with error heads state the integrity rules. According to these rules:
- The same car cannot be sold by two different people.
- The sale of a car must be approved by a person different from the salesman.

The integrity checking policy, denoted as \( P_i \), maps the set of permissions generated by \( P_p \) and \( P_d \) to a collection of permission sets that include the following:
1. \(\{(BMW, John, +\text{Sell}), (SAAB, Mary, +\text{Sell}), (BMW, Mary, \text{Approve}), (SAAB, John, \text{Approve})\}\), with all other permissions being negative.
2. \(\{(BMW, Mary, +\text{Sell}), (SAAB, John, +\text{Sell}), (BMW, John, \text{Approve}), (SAAB, Mary, \text{Approve})\}\), with all other permissions being negative.
3. \(\{(BMW, Alice, +\text{Sell}), (SAAB, Mary, +\text{Sell}), (BMW, Mary, \text{Approve}), (SAAB, John, \text{Approve})\}\)
4. \(\{(BMW, Bob, +\text{Sell}), (SAAB, Mary, +\text{Sell}), (BMW, Mary, \text{Approve}), (SAAB, John, \text{Approve})\}\)
5. \(\{(BMW, Bob, +\text{Sell}), (SAAB, Alice, +\text{Sell}), (BMW, Mary, \text{Approve}), (SAAB, John, \text{Approve})\}\)

Thus, the policy used at the car dealership can be stated as \( (P_p, P_d, P_i) \). If the 16 rules are numbered as \( r_1, \ldots, r_{16} \), then \( P_p \), \( P_d \), and \( P_i \) are defined by \(\{r_i : i \leq 12\}\), \(\{r_{13}, r_{14}\}\), and \(\{r_{15}, r_{16}\}\) respectively.

### 3. FAF with Provisions

In the second example, we demonstrate that our policy algebra can model provisional authorizations, where access control decisions involve conditional permissions. An example of such a request is a user accessing an online brokerage who can receive information by filling out name and address fields, but not otherwise.

Provisional authorization specifications, as in [9], are specified as rules in a logic programming language, with provisions written in any logical language \( L \), referred to as pASLL. An example pASLL program would look like the following:

\[
\begin{align*}
\phi_1 : & \ \text{do}(o, s, +a) \leftarrow \text{cando}(o, s, +a) \land \text{do}(o, s, +b) \\
\phi_2 : & \ \text{do}(o, s, +b) \leftarrow \text{cando}(o, s, +b) \\
\phi_3 : & \ \text{cando}(o, s, +a) \leftarrow \text{provision} \\
\phi_4 : & \ \text{cando}(o, s, +b) \leftarrow \text{provision} \\
\phi_5 : & \ \text{cando}(o, s, +a) \leftarrow \text{provision}
\end{align*}
\]

In this example, \(\phi_i\)'s are the provisions specified in some logic \( L \), external to the rule base, while other predicates such as \(\text{do}\) and \(\text{cando}\) appear in the previous example.

The provisional rules given by equations (1) through (5) allow the access \((o, s, +a)\) provided that \((\phi_1 \land \phi_3) \lor (\phi_1 \land \phi_5)\) is satisfied, and it allows \((o, s, +b)\) provided that \(\phi_2 \land \phi_4\) is satisfied.

In our model, if policy \( p_1 \) permits the access \((o, s, +a)\) and policy \( p_2 \) permits the access \((o, s, +b)\), then \((p_1 | ((\phi_1 \land \phi_3) \lor (\phi_1 \land \phi_5)) \cup (p_2 | (\phi_2 \land \phi_4))\) models the policy given by equations (1) through (5).

### 4. Federated Contract Example

The third and final example deals with a federated policy controlling criminal records of juveniles between the judicial (JD) and counter-narcotics (CN) branches of US law enforcement agencies [4]. The CN division maintains a database of suspicious activities and ongoing investigations, while the JD branch maintains records of all ongoing and past case records. The legal agreements between the two agencies are as follows:

1. The CN division names an administrator (Cathy) and two investigators (Vinti and Bill).
2. The JD division's policy is to accept any requests from the counter-narcotics division employees. It monitors every such request and grants read permissions to CN investigators and read/write permissions to CN administrators for juvenile records.

The first part of the JD policy, allowing any CN employee to make a request, can be represented in our algebra as \( p_1 \), mapping the authorization state \(\{(Cathy, ), (Vinti, jRecord, \emptyset), (Bill, jRecord, \emptyset)\}\) to the authorization state \(\{(Cathy, jRecord, \{readRequest, writeRequest\}), (Vinti, jRecord, \{readRequest\}), (Bill, jRecord, \{readRequest\})\}\).

The second part of the policy can be represented as \((p_2 : \phi)\), where \( p_2 \) maps every request to its permissions and \(\phi\) is the scoping restriction that checks for appropriate roles of the requesters. Thus, \((p_2 : \phi)\) maps the authorization state \(\{(Cathy, jRecord, \{readRequest, writeRequest\}), (Vinti, jRecord, \{readRequest\}), (Bill, jRecord, \{readRequest\})\}\) to the authorization state \(\{(Cathy, jRecord, \{read, write\}), (Vinti, jRecord, \{read\}), (Bill, jRecord, \{read\})\}\).

Thus, the policy expressed in parts 1 and 2 can be expressed as \( p_1; (p_2 : \phi) \).

3. The internal policy of CN requires that any data received from other divisions be recorded in the internal write-once database, for which special permission will be granted on an as-needed basis.

This policy can be modeled as \( p_3 \), where the intended semantics of \( p_3 \) map any authorization state \((\text{subject}, \text{external agency.Record}, \{read\})\) to the authorization state \((\text{subject}, \text{internal copy.Record}, \{write\})\).

Hence, the entire policy is modeled as \( p_1; (p_2 : \psi); p_3 \).

### 5. Comparisons

#### 5.1 Comparison with McLean

McLean suggested using algebraic (set-theoretic) constructs for composition of access control and information flow policies [14, 15, 16]. He referred to non-determinism as possibilistic semantics and the sequence operator as the cascading operator. Most of his work focuses on multilevel security (MLS). In this paper, we are concerned with discretionary access control policies and do not address notions such as non-inference and non-interference.

#### 5.2 Comparison with Bonatti et al.

The work of Bonatti et al. [5] is closest to our work, presenting a comprehensive framework for composing access control policies. The fundamental difference between their modeling and ours is that they formulate an access control policy as a set of ground terms over an alphabet for (subject, object, action) terms, whereas we model policies as non-deterministic transformers (relations) over a collection of subjects, objects, and action terms. Thus, [5] takes a set-based approach influenced by logic programming, while we take a state transformation-based approach.

Bonatti et al. have Horn clause rules to derive consequences of policies, and the algebra of policies is captured by having a collection of operators such as union, intersection, closure under rules, and scoping restrictions over policies. In addition, Bonatti et al. [5] have policy variables for yet-to-be-specified policies in policy expressions that can be replaced by a collection of (subject, object, action) triples supplied by an environment.

Our policies are relations, as opposed to functions, because we wanted to model non-deterministic policies. Consequently, there is a difference between our policy operators and those available in [5]. All operators allowed in [5] (such as addition, conjunction, subtraction) operate on ground authorization terms, whereas ours operate on relations that map ground authorization terms to a collection of them.

In our model, sequencing is a first-class operator, i.e., if \( p_1 \) and \( p_2 \) are policies, then \((p_1; p_2)\) and \((p_2; p_1)\) are policies, and they may not result in permitting the same accesses. Due to the fact that policies are modeled as a set of ground authorization terms, and set operations of union, intersection, difference, and closure under a collection of rules, sequential applications of policies cannot be directly modeled as a first-class operation in [5]. However, there are examples provided in [5] that show how the net effect of sequencing (such as in denials take precedence policy) can be modeled by analyzing the semantics of the components.

The modular approach of [5] does not explicitly support negative authorizations. Nevertheless, they show how to model hybrid policies such as denials take precedence policy as \( p^+ - p^- \), where \( p^+ \) and \( p^- \) contain positive and negative authorization terms, respectively. The difficulty, however, is that if authorization terms are not signed, then to define \( p^+ \) and \( p^- \), one needs to know the nature and form of (rules or any other internal mechanism), which arguably violates the abstractness of policy operators. We are especially concerned about how this step would be carried out when unknown policies are passed in as variables.

#### 5.3 Modeling Sets of Accesses vs. Individual Accesses

Our semantics transform sets of accesses per each subject-object pair to another set of accesses and, furthermore, this transformation can associate one access set in the domain to multiple sets of accesses in the range of a policy. This allows us to model separation of duty (SoD) type of policies clearly, by mapping a given set of accesses to all allowable combinations of accesses. Neither the flexible framework of Jajodia et al. [10] nor the modular approach of Bonatti et al. [5] capture them. The main reason for this is that they both lack set-based rules.

It is possible to model SoD policies in [10] provided that all requests are serialized, but this limitation has been removed from our framework.

Simon and Zurko [18] and Gligor et al. [7] discuss SoD policies and their compositions. The former presents a categorization of SoD policies such as static, static-strict, dynamic, and object-based SoD. The latter formalizes them with respect to system states and state transitions. In this formalization, every SoD principle is written as a first-order sentence over sets of objects, subjects, roles, membership relations over these categories, and sets of operations permitted in roles. They use the notation \( p_i(\text{RoleSet}_i, \text{App}_i) \) as a definition for a particular SoD principle. For example, SSoD(RoleSet, App) is satisfied at any state \(\rho\) if \(\forall r_1, r_2 \in \text{RoleSet} \ (r_1 \neq r_2 \rightarrow \text{role set}(r_1) \cap \text{role set}(r_2) = \emptyset)\). Gligor et al. [7] use the notation \( p_1(\text{RoleSet}, \text{App}) \) to denote the set \(\{\rho \in \text{STATES} : \rho \models p_1(\text{RoleSet}, \text{App})\}\). By means of these characterizations, they show that some SoD principles imply others. Further, they derive sufficient conditions for \( p_1 \) and \( p_2 \) to be composable as SoD principles. Although our policy compositions were not designed to explicitly model SoD-preserving compositions, it is sufficient to model static SoD policies and investigate SoD-preserving state transformations. Nevertheless, this work shows the utility of modeling sets of accesses, as opposed to modeling accesses.

#### 5.4 Other Logic-Based Models

Bai and Varadarajan [3] present another logic-based model for access control policies. They model a given state of a security policy as a collection \((C, M)\), where \( C \) is a finite set of first-order formulas over a language consisting of ground atoms, and \( M \) is a Herbrand interpretation. They view \( C \) as the non-changeable part of the policy and \( M \) as changeable facts. Their definition of transformation, syntactically given as \([P re(tran) | P ost(tran)]\), where \( P re(tran) \{h_1, \ldots, h_m\} \), and \( P ost(tran) \{l_1, \ldots, l_n\} \) intuitively means that if the facts \( h_1, \ldots, h_m \) held before the state transformation, then the transformation is eligible to be applied, and the post-conditions \( l_1, \ldots, l_n \) must hold afterwards. Because this work uses the closed-world assumption, each such transformation can have multiple states satisfying the post-conditions and the invariant part. They suggest some priority-based methods to choose one among such competing states.

Although our work is not based on the closed-world assumption and we do not derive states from post-conditions, we can model these state transformations followed by choosing the appropriate end state as a composition of two policies: \( p_{\text{transform}}; p_{\text{choose}} \). The two pertinent points are that non-deterministic choice is relevant, as shown in the work of [3], and our framework is able to capture it. Furthermore, by decomposing the transformation with the priority-based choice for the end state, we can investigate consequences of and alternatives to resolving the non-determinacy.

#### 5.5 Automata-Based Models

Although there are many access control-related works based on automata, we compare our work with [17]. This work formulates policies related to access control, information flow, and resource availability as automata. An enforceable security policy is defined as a safety property, and drawing upon earlier work [1, 2], it is shown how these can be enforced by reference monitors. This work shows how to reverse-engineer an access control matrix-based security enforcement mechanism as an automaton and argues that by composing automata, one could be composing policies, independent of their implementation mechanisms. This is the view taken by our policy composition framework. We further argue that some of our algebraic properties can be used to derive equivalences among such reverse-engineered policies.