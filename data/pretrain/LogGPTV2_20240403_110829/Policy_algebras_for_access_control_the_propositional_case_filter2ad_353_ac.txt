the propagation policy as Pp, and it maps an empty set
of authorizations to the set { (vehicle, salesman, +Sell), :
vehicle = BMW, SAAB and salesman = John, Mary, Bob,
Alice} ∪ { (vehicle, approved by, +OK) : vehicle = BMW,
SAAB and approved by = John, Mary}.
The next two rules, with do heads state the decision pol-
icy, which in our example is the same as the closed policy.
We denote the decision policy by Pd, and it takes the set of
permissions { (vehicle, salesman, +Sell) : vehicle = BMW,
SAAB and salesman = John, Mary, Bob, Alice} ∪ { (ve-
hicle, approved by, +OK) : vehicle = BMW, SAAB and
approved by = John, Mary} to the set of permissions { (ve-
hicle, salesman, +Sell), : vehicle = BMW, SAAB and sales-
man = John, Mary, Bob, Alice} ∪ { (vehicle, approved by,
+OK) : vehicle = BMW, SAAB and approved by = John,
Mary} ∪ { (vehicle, approved by, -OK) : vehicle = BMW,
SAAB and approved by = Alice, Bob}.
The next two rules with error heads state integrity rules.
According to our rules, the same car cannot be sold by the
two diﬀerent people, and the sale of a car must be approved
by a person diﬀerent from the salesman. Accordingly, the
integrity checking policy, which we denote as Pi maps the
set of permissions { (vehicle, salesman, +Sell), : vehicle =
BMW, SABB and salesman = John, Mary, Bob, Alice} ∪ {
(vehicle, approved by, +OK) : vehicle = BMW, SAAB and
approved by = John, Mary} to { (vehicle, salesman, +Sell),
: vehicle = BMW, SAAB and salesman = John, Mary, Bob,
Alice} ∪ { (vehicle, approved by, +OK) : vehicle = BMW,
SAAB and approved by = John, Mary} ∪ { (vehicle, ap-
proved by, -OK) : vehicle = BMW, SAAB and approved by
= Alice, Bob } to a collection of permission sets that include
the following.
1. {(BMW, John, +Sell), (SAAB, Mary, +Sell), (BMW,
Mary, Approve), (SAAB, John, Approve)}, and all
other permissions are negative.
2. {(BMW, Mary, +Sell), (SAAB, John, +Sell), (BMW,
John, Approve), (SAAB, Mary, Approve)}, and all
other permissions are negative.
3. {(BMW, Alice, +Sell), SAAB, Mary, +Sell), (BMW,
Mary, Approve), (SAAB, John, Approve)}
4. {(BMW, Bob, +Sell), (SAAB, Mary, +Sell), (BMW,
Mary, Approve), (SAAB, John, Approve)}
5. {(BMW, Bob, +Sell), (SAAB, Alice, +Sell), (BMW,
Mary, Approve), (SAAB, John, Approve)}
∗
Hence the policy used at the car dealership can be stated
; Pi, as there could be derivations involved up
at (Pp, Pd)
to the decision policy stages. Furthermore, if the 16 rules
are numbered as r1, . . . , r16, then Pp, Pd, Pi, are deﬁned by
{ri : i ≤ 12}, {r13, r14} and {r15, r16} respectively.
6.2 FAF with Provisions
In the second example, we show that our policy algebra
can model provisional authorizations, where access control
decisions of yes/no responses are just not enough, because
they involve conditional permission for access [9]. An exam-
ple access requests that can be modeled by proposed frame-
work of [9] is a user accessing an online brokerage can receive
some information by ﬁlling out name and address ﬁelds, but
not otherwise. The provisional authorization speciﬁcations
of [9] are speciﬁed as rules in a logic programming language,
with provisions written in any logical language L, and re-
ferred to as pASLL. An example pASLL program would
look like the following.
φ1 : do(o, s, +a) ← cando(o, s, +a) ∧ do(o, s, +b)(1)
φ2 : do(o, s, +b) ← cando(o, s, +b)
(2)
(3)
(4)
(5)
φ3 : cando(o, s, +a) ←
φ4 : cando(o, s, +b) ←
φ5 : cando(o, s, +a) ←
In the above example φi’s are the provisions speciﬁed in
some logic L, external to the rule base, but other predicates
such as do and cando are the one’s that appear in the
previous example.
The provisional rules given by equations (1) through (5)
allow the access (o, s, +a) provided that (φ1 ∧ φ3) ∨ (φ1, φ5)
is satisﬁed, and it allows (o, s, +b), provided that φ2 ∧ φ4
In our model, if policy p1 permits the access
is satisﬁed.
(o, s, +a) and policy p2 permits the access (o, s, +b), then
(p1 | ((φ1 ∧ φ3) ∨ (φ1, φ5)) ∪ (p2 | (φ2 ∧ φ4) models the
policy given by equations (1) through (5). Notice again
that the implicit assumption of this framework is that what-
ever cannot be derived as do(o, s, +a) results in the applica-
tion of the non-monotonic completeness rule do(o, s,−a) ←
¬do(o, s, +a).
Consequently, if policy pc encodes this last rule, complete
speciﬁcation is modeled as (p1 | ((φ1 ∧ φ3) ∨ (φ1, φ5)) ∪ (p2 |
(φ2 ∧ φ4); pc. Furthermore the ﬁnal checking of adding an
integrity check pi results in the policy (p1 | ((φ1 ∧ φ3) ∨
(φ1, φ5)) ∪ (p2 | (φ2 ∧ φ4); pc; pi.
6.3 Federated Contract Example
The third and the ﬁnal example deals with a federated
policy controlling criminal records of juveniles between the
judicial (JD) and counter-narcotics (CN) branches of US
law enforcement agencies [4]. The CN division maintains a
database of suspicious activities and ongoing investigations
and the JD branch maintains records of all ongoing and past
case records. Legal agreement between the two agencies are
as follows:
1. The CN division names an administrator Cathy and
two investigators Vinti and Bill.
2. The JD division’s policy is to accept any requests from
the counter-narcotics division employees. It monitors
every such requests and grants read permissions to CN
investigators and read/write permissions to CN admin-
istrators to juvenile records.
The ﬁrst part of the JD policy of allowing any CD em-
ployee to make a request can be represented in our algebra
as p1 with the intended semantics of p1 mapping the autho-
rization state {(Cathy, ), (V inti, jRecord,∅),
(Bill, jRecord,∅)) to the authorization state
{(Cathy, jRecord,{readRequest, writeRequest}),
43(V inti, jRecord,{readRequest}), (Bill, jRecord,
{readRequest})}.
The second part of the policy can be represented as (p2 :
φ) where p2 maps every request to its permissions and φ is
the scoping restriction that checks for appropriate roles of
the requesters. Thus, (p2 : φ) maps the the authorization
state ((Cathy, jRecord,
{readRequest, writeRequest}), (V inti, jRecord,
{readRequest}), (Bill, jRecord,{readRequest})) to the au-
thorization state ((Cathy, jRecord,
{read, write}), (V inti, jRecord,{read}), (Bill, jRecord,
{readRequest}))
Thus, the policy expressed in parts 1 and 2 can be ex-
pressed as p1; (p2 : φ).
3 The internal policy of CN requires that any data re-
ceived from other divisions be recorded in the internal
write once database for which special permission will
be granted on an as needed basis.
This policy can be modeled as p3 where the intended se-
mantics of p3 maps any authorization state (subject,
external agency.Record,{read}) to the authorization state
(subject, internal copy.Record,{write})
Hence, the entire policy is modeled as p1; (p2 : ψ); p3.
7. COMPARISONS
McLean suggested using the notion of algebraic (set the-
oretic) constructs for composition of access control and in-
formation ﬂow policies [14, 15, 16]. He referred to non-
determinism as possibilistic semantics and sequence operator
as cascading operator. Most of his work focus on multilevel
security (MLS). In this paper, we are concerned with discre-
tionary access control policies, and do not address notions
such as non-inference and non-interference.
7.1 Comparison with Bonatti et al.
The work of Bonatti et al. [5] is closest to our work where
a comprehensive framework for composing access control
policies are presented. The fundamental diﬀerence between
their modeling and ours is that they formulate an access
control policy as a set of ground terms over an alphabet for
(subject, object, action) terms, whereas we model policies as
non-deterministic transformers (relations) over a collection
of subjects, objects, action terms. Thus, [5] takes a set-based
approach inﬂuenced by logic programming whereas we take
a state transformation based approach. Further, Bonatti et
al. have Horn clause rules to derive consequences of policies,
and the algebra of policies is captured by having a collection
of operators such as union, intersection, closure under rules,
scoping restrictions over policies etc. In addition, Bonatti
et al. [5] have policy variables for yet to be speciﬁed polices
in policy expressions that can be replaced by a collection of
(subject, object, action) triples supplied by an environment.
Our policies are relations, as opposed to being functions
because we wanted to model non-deterministic policies. Con-
sequently, there is a diﬀerence between our policy operators
and those available in [5]. All operators allowed in [5] (such
as addition, conjunction, subtraction) operate on ground au-
thorization terms, whereas ours operate on relations that
map ground authorization terms to a collection of them.
In our model sequencing is a ﬁrst class operator, i.e., if
p1 and p2 are policies, then (p1; p2) and (p2; p1) are policies,
and they may not result in permitting the same accesses.
Due to the fact that policies are modeled as a set of ground
authorization terms, and set operations of union, intersec-
tion, diﬀerence and closure under a collection of rules, se-
quential applications of policies cannot be directly modeled
as a ﬁrst class operation in [5]. However, there are examples
provided in [5] that show how the net eﬀect of sequencing
(such as in denials takes precedence policy) can be modeled
by analyzing the semantics of the components.
−
−
where p+ and p
The modular approach of [5] does not explicitly support
negative authorizations. Nevertheless, they show how to
model hybrid policy such as denials take precedence policy
as p+ − p
contain positive and negative
authorization terms, respectively. The diﬃculty, however,
is that if authorization terms are not signed, then in order
to deﬁne p+ and p
one needs to know the nature and the
form of (rules or any other internal mechanism) which ar-
guably violates the abstractness of policy operators. We are
specially concerned as to how this step would be carried out
when unknown policies are passed in as variables.
−
7.2 Modeling Sets of Accesses vs. Individual
Accesses
Our semantics transform sets of accesses per each subject
object pair to another set of accesses and, furthermore, this
transformation can associate one access set in the domain
to multiple sets of accesses in the range of a policy. This
allows us to model separation of duty (SoD) type of policies
clearly, by mapping a given set of accesses to all allowable
combinations of accesses. Neither the ﬂexible framework of
Jajodia et al. [10] nor modular approach of Bonatti et al. [5]
capture them. The main reason for this is that they both
lack set based rules.
It is possible to model them in [10]
provided that all requests are serialized, but this limitation
has been removed from our framework.
Simon and Zurko [18] and Gligor et al. [7] discuss SoD
policies and their compositions. The former presents a cat-
egorization of SoD policies such as static, static-strict, dy-
namic, object based SoD etc.. The later formalizes them
with respect to system states and state transitions. In this
formalization, every SoD principle is written as a ﬁrst order
sentence over sets of objects, subjects, roles, membership
relations over these categories, and sets of operations per-
mitted in roles. They use the notation pi(RoleSeti, Appi)
as a deﬁnition for a particular SoD principle. For example
SSoD(RoleSet, App) is satisﬁed at any state ρ if ∀r1, r2 ∈
RoleSetr1 (cid:18)= r2 → role set(r1) ∩ role set(r2) (cid:18)= ∅. Gligor et
al. [7] uses the notation p1(RoleSet, App) to denote the set
{ρ ∈ ST AT ES : ρ |= p1(RoleSet, App)}. By means of these
characterizations, they show that some SoD principles imply
others. Further they derive suﬃcient conditions for p1 and
p2 to be composable as SoD principles. Although our pol-
icy compositions were not designed to explicitly model SoD
preserving compositions, it is suﬃcient to model static SoD
policies and investigate SoD preserving state transforma-
tions. Nevertheless this work shows the utility of modeling
sets of accesses, as opposed to modeling accesses.
7.3 Other Logic Based Models
Bai and Varadarajan [3] present another logic based model
for access control policies. They model a given state of a se-
curity policy as a collection (C, M ) where C is a ﬁnite set
of ﬁrst order formulas over language consisting of ground
44atoms and M is a Herbrand interpretation. They view C as
the nonchangeable part of the policy and M as changeable
facts. Their deﬁnition of transformation, syntactically given
as [P re(tran) | P ost(tran)], where P re(tran){h1, . . . , hm},
and P ost(tran){l1, . . . , ln} intuitively means that if the facts
h1, . . . , hm held before the state transformation, then the
transformation is eligible to be applied and that the post
conditions l1, . . . , ln must hold afterwards. Because this
work uses the closed world assumption, each such trans-
formation can have multiple states satisfying the post con-
dition and the invariant part. They suggest some priority
based methods to choose one among such competing states.
Although our work is not based on the closed world assump-
tion and we do not derive states from post conditions, we
can model these state transformations followed by choosing
the appropriate end state as a composition of two policies:
ptransf orm; pchoose. The two pertinent points are that non-
deterministic choice is relevant, as shown in the work of
[3], and our framework is able to capture it. Furthermore,
by decomposing the transformation with the priority based
choice for the end state, we can investigate consequences of
and alternatives to resolving the non-determinacy.
7.4 Automata Based Models
Although there are many access control related work based
on automatons, we compare our work with [17]. This work
formulates policies related to access control,
information
ﬂow and resource availability as automatons. An enforce-
able security policy is deﬁned as a safety property and, draw-
ing upon earlier work [1, 2], it is shown how these can be
enforced by reference monitors. This work shows how to
reverse engineer an access control matrix based security en-
forcement mechanism as an automaton, and argues that by
composing automatons, one could be composing policies, in-
dependent of their implementation mechanisms - and this is
the view taken by our policy composition framework. We
further argue that some of our algebraic properties can be
used to derive the equivalences among such reveres engi-