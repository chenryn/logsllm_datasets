0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
500
1000
1500
2000
Round
Figure 5. Veriﬁcation cost per round using ea(cid:173)
ger round constraints and XPilot(cid:173)speciﬁc opti(cid:173)
mizations, while checking a 2,000(cid:173)round XPi-
lot game log
is due to the fact that a large portion of the XPilot client
code is dedicated to handling server messages. And while
the veriﬁer in the eager case has preprocessed this portion
of the code, the resulting round constraints are much more
complex than in the lazy approach, where the the veriﬁer
knows the exact values of the server messages when gen-
erating round constraints. This complexity results in con-
straint solving in the eager case (line 305 of Figure 2) being
more expensive.
It is also important to recall that lazy and eager are not
interchangeable, at least in terms of game developer effort.
As discussed in §5.4.1, achieving feasible generation of ea-
ger round constraints required substantial additional manual
tuning, and consequently greater opportunity for program-
mer error. As such, it appears that eager is an inferior ap-
proach to lazy for XPilot. Another comparison between lazy
and eager, with differing results, will be given in §6.
6 Case Study: Cap-Man
Our client veriﬁcation technique challenges the current
game-design philosophy by allowing servers to relinquish
authoritative state to clients while retaining the ability to
validate client behavior and thus detect cheating. As a
way of demonstrating this notion, we have written a game
called Cap-Man that is based on the game Pac-Man.
In
some ways Cap-Man is easier to validate than XPilot was
— it represents a considerably smaller code base (approx-
imately 1,000 lines of C code) and state size. However,
whereas XPilot was written with virtually no authoritative
client state, we will see that Cap-Man is intentionally rife
with it, providing a more interesting challenge for our tech-
nique because it is so much more vulnerable to invalid mes-
sages. The size of its code base also allows us to conduct
a more direct comparison between lazy and eager veriﬁca-
tion.
6.1 The Game
Cap-Man is a Pac-Man-like game in which a player con-
trols an avatar that is allowed to move through a discrete,
two-dimensional map with the aim of consuming all re-
maining “food” items before being caught by the various
enemies (who are also wandering the map). Each map lo-
cation is either an impenetrable wall or an open space, and
the open spaces can contain an avatar, an enemy, pieces of
food, a power-up, or nothing at all. When a player reaches
a map location that contains food or a power-up, he auto-
matically consumes it. Upon consuming a power-up, the
player enters a temporary “power-up mode,” during which
his pursuers reverse course — trying to escape rather than
pursue him — and he is able to consume (and temporarily
displace) them if he can catch them. In addition to these
features (which were present in Pac-Man as well), we have
added a new feature to Cap-Man to invite further abuse and
create more uncertainty at the server: A player may set a
bomb (at his current location), which will then detonate 5
rounds in the future, killing any enemies (or the player him-
self) within a certain radius on the map. Players are not
allowed to set a second bomb until the ﬁrst bomb has deto-
nated.
Cap-Man uses a client-server architecture, which we de-
signed speciﬁcally to go against current game-development
best practices: i.e., it is the server, not the client, which has
a minimum of authoritative state. The client tracks his own
map position, power-up-mode time remaining, and bomb-
placement details. Speciﬁcally, at every round, the client
sends a message to the server indicating its current map po-
sition and remaining time in power-up mode. It also sends
the position of a bomb explosion, if there was one during
that round. Note that the client never informs the server
when it decides to set a bomb. It merely announces when
and where detonation has occurred. The server, in contrast,
sends the client the updated positions of his enemies — this
being the only game state for which the server has the au-
thoritative copy.
The design of Cap-Man leaves it intentionally vulnerable
to a host of invalid-message attacks. For example, although
valid game clients allow only contiguous paths through the
map, a cheating player can arbitrarily adjust his coordinates,
ignoring the rules of the game — a cheat known in game-
security parlance as “telehacking.” He might also put him-
self into power-up mode at will, without bothering to actu-
ally consume a power-up. Finally, there is no check at the
server to see whether or not a player is lying about a bomb
placement by, for example, announcing an explosion at co-
ordinates that he had not actually occupied 5 rounds earlier.
In fact, the Cap-Man server contains no information about
(or manual checks regarding) the internal logic of the game
client.
In order to detect cheating in Cap-Man, we apply our
technique in both its lazy and eager ﬂavors. Due to Cap-
Man’s smaller size and simpler code structure, we can gen-
erate round constraints over an entire iteration of the main
loop in each case, without the need to compartmentalize the
code and adopt signiﬁcant trimming measures as we did for
XPilot.
6.2 Evaluation
Using our technique, we are able to detect invalid-
command cheats of all the types listed above. Below we
present the results of client-validity checks on a game log
consisting of 2,000 rounds (about 6-7 minutes of game-play
time), during which the player moved around the map ran-
domly, performing (legal) bomb placements at random in-
tervals.
Figure 6 shows that the veriﬁcation costs for Cap-Man
were consistently small, with a mean and standard devi-
ation of 814ms and 1.10s for veriﬁcation via lazy round
constraints (Figure 6(a)) and a mean and standard devia-
tion of 260ms and 45.0ms for veriﬁcation using eager round
constraints (Figure 6(b)). The lazy method was (on aver-
age) roughly 2.5 times slower than the eager method, owing
to the overhead of symbolic execution to compute round
constraints for each round individually during veriﬁcation.
While in the XPilot case study, eager veriﬁcation required
signiﬁcantly greater development effort (see §5.4.1), this
additional effort was unnecessary with Cap-Man due to its
relative simplicity.
Figure 6(c) shows the number of satisﬁable accumu-
lated constraints, which did not trend upward during the
run. Note that these values were identical for both the ea-
ger and lazy approaches, as expected. In the case of XPi-
lot, the number of satisﬁable accumulated constraints was
always 1, but in Cap-Man there were often multiple accu-
mulated constraints that remained satisﬁable at any given
round. This increase resulted primarily from state the Cap-
Man client maintains but does not immediately report to the
server (e.g., whether a bomb has been set). The relation-
ship between this hidden state and the number of satisﬁable
accumulated constraints is an important one. Consider the
veriﬁcation of a Cap-Man game that is currently in round i,
with no bomb placements in the last 5 rounds (unbeknownst
to the veriﬁer). The veriﬁer must maintain accumulated
constraints that reﬂect possible bomb placements at each of
rounds i − 4 through i. Upon encountering msg i+1 with an
)
s
d
n
o
c
e
s
(
t
s
o
C
n
o
i
t
a
c
i
f
i
r
e
V
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
0
0
0
0
0
0
0
0
0
0
0
0