number of third-party applications. In this paper, we focus
our attention to Android framework and common applica-
tions that are pre-loaded into every Android distribution
(e.g. contacts, calendar, messaging etc.). These application
are also used by third-party application in implementing
common functionalities. Hence, rigorous evaluation of these
built-in applications are of prime importance. In Android
namespace hierarchy, these applications all share the pack-
age name preﬁx of com.android. After ﬁltering the list
of components with this preﬁx we found 398 components
(297 Activities, 42 Services, and 59 Broadcast Receivers) in
Droid and 455 components (332 Activities, 54 Services, and
and 69 Broadcast Receivers) in Emulator.
In addition to built-in applications, we also tested 5
Most popular (as on 3 Dec, 2011) free apps from Android
Marketplace (recently renamed Google Play). These apps—
Facebook, Pandora Radio, Voxer Walkie Talkie, Angry
Birds, and Skype—had a total of 103 Activities and 11
Service components. Even though our set of Marketplace
apps is small, the large number of Activities (103 as opposed
to 294 in Droid) gives us a realistic comparison of their
robustness with that of Android. Our experiments started by
subjecting all these (Android and Marketplace) components
to a ﬂow of Intents from JarJarBinks over a seven day period.
In the following section, we present our ﬁndings.
IV. EXPERIMENTAL RESULTS
During the course of our experiments, more than 6 million
Intents were sent to 800+ components across 3 versions of
Android. We deﬁne an experiment as follows:
Choose one particular component and inject all the Intents
targeted to that component. The injection is done according
to the Fault Injection Campaigns (thus, if we are doing FIC
A, the  pairs are changed to semi-valid
values).
We collected execution logs from the mobile phones and
emulators using logcat, a logging application in Android
platform tools. This generated more than 3GB of log data
which were later analyzed to gather information about the
failures and their root causes. We deﬁne a crash to be a user
visible failure, i.e., a system alert displaying the message
"Force Close" (in Android 2.2) or "Application
x stopped unexpectedly" (in Android 4.0). These
failure messages manifest in the log ﬁles as a log entry
stating "FATAL EXCEPTION: main" and are essentially
effects of uncaught exceptions thrown by the Android run-
time. It is to be noted that sending(receiving) of certain
Intents (e.g.  or Intents
with "content:" URIs in Data ﬁeld) in Android are
protected by permissions and when JJB sends these Intents
SecurityExceptions are generated. JJB is able to han-
dle these exceptions gracefully and we discard these from
our results. At present we focus on crash failures as opposed
to thread hangs due to their visibility and negative user
experience.
We discuss our results from three perspectives: (i) preva-
lence of crashes caused in the application components due
to the fuzzed Intents for the various types of components
and different fault injection campaigns; (ii) distribution of
uncaught exceptions thrown by components in response to
the fuzzed Intents; and (iii) error propagation from a user-
level application to the Android framework.
In general, Android 2.2 displayed many more crashes
than Android 4.0 and components in all the versions were
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:17:27 UTC from IEEE Xplore.  Restrictions apply. 
vulnerable to NullPointerExceptions. It was pos-
sible to crash some components by sending them an im-
plicit Intent that matched exactly with their Intent-ﬁlter (i.e.
nothing other than the mandatory ﬁelds were speciﬁed).
In Android 2.2,
three of the application crashes caused
cascading failures which eventually restarted the Android
runtime. The Android Emulator also showed signs of stress-
related failures, whereby, the system_server (the frame-
work component that coordinates interaction between Kernel
space and user space) restarted periodically after testing a
ﬁxed number of components. The system_server is a
key part of the Android environment—it runs a host of
essential services (Power Manager, Device Policy, Search
Service, Audio Service, Dock Observer, etc.). A crash of
the system_server kills all user level application and
services and restarts the Android runtime.
Below we present our experimental results organized into
three discussions.
A. Results for Explicit Intents
In Section III-B2, we described how we generated explicit
Intents for four different fault injection campaigns. In FIC A
we sent an invalid  pair to components,
in FIC B we sent an Intent with either Action or Data
blank,
in FIC C random bytes were assigned to either
Action or Data, and ﬁnally in FIC D random bytes were
assigned to Extras values. During our experiments we
found a large number of crashes—2148 in Android 2.2,
641 in Android 4.0, and 152 for Marketplace apps. One
may argue that a comparison between Android 2.2 on a
real phone and Android 4.0 on an emulator compromises
the validity of our results. To verify this, we conducted a
smaller-scale test of Android 2.2 on emulator and Droid and
did not ﬁnd any major difference. Our choice of Android 4.0
on emulator was driven by the lack of a physical device in
a timely fashion. Even if results obtained from a physical
device change from its emulator (i.e. absolute numbers of
crashes change), it does not invalidate the general trends
described in our results. Below, we present an analysis of
the observed crashes.
1) Distribution of Failed Components: We deﬁne a failed
component to be a program that crashes at least once during
a fuzz injection campaign. Due to the nature of our Intent
generation it is possible that a component fails repeatedly
in one experiment where that component is targeted, e.g. an
activity that dereferences Data ﬁeld without null check will
crash for all Intents that has a blank Data ﬁeld. Counting
such repeated crashes masks the actual number of faults
at source code, therefore, for a fault injection campaign
like ours, a better metric of a framework’s reliability can
be obtained by ﬁnding how many failed components it
has. Table I presents the number of failed components for
various types (Activity, Broadcast Receiver, and Services) in
each of our experiments. The number at the top, under the
component type represents the total number of components
of that
type, e.g., Android 2.2 has 297 Activities. The
number in the column “#crash” denotes the number of
components that crashed.
It is encouraging to see that in all cases but two, the
percentage of failed components is less than 10. The per-
centage of failed components in Android 4.0 is generally
lower than in Android 2.2, with the exception of Services.
Across experiments, Activities display higher fraction of
failed components in FIC A than the rest. However, this
may also be due to the fact that FIC A sends nearly twice
as many Intents than FICs B, C, and D combined. The high
count of failed components across component types in FIC
B is another key ﬁnding of our experiments. This indicates
that many Android components do not perform null checks
before dereferencing a ﬁeld from an Intent and, therefore,
are vulnerable to blank ﬁelds. This fact is also veriﬁed by
our data in the next section.
The failure percentages of Marketplace apps are nearly
identical to that of Android 4.0 components with the ex-
ception of FIC A for Activities and for Services, where
Marketplace apps are signiﬁcantly more robust. However, it
was observed that 3 of the apps had at least one component
that failed one or more experiments. Though our sample size
for Marketplace apps (5) is too small to make any claims
about general robustness of third-party apps, we expected
the Top 5 to be more robust as they come from reputed
vendors. This intuition is only partially borne out by the
analysis results.
2) Distribution of Exception Types: To understand how
well
the Android framework handles exceptional condi-
tions, we measured the distribution of exception types from
failure logs. Here, we are focused on uncaught excep-
tions, because they result
in the crashes. Since we are
interested in measuring what percentage of all the crashes
are constituted by a given exception type, here we count
each crash individually. Thus, if in one experiment, 100
fuzzed Intents are sent to a component and the component
crashes 20 times, we will have 20 data points (unlike in
Section IV-A1 where we would have counted the com-
ponent as having crashed and it would have resulted in
a single data point). It can be seen from Fig. 3 that
NullPointerExceptions (NPE) make up the largest
share of all the exceptions. Though the percentage of NPEs
in Android 4.0 (36.50%) has improved since Android 2.2
(45.99%),
this is still signiﬁcant and concurs with our
ﬁndings in Section IV-A1. The results are given in terms of
percentage of all the exceptions, thus for a given Android
version, all the exceptions’ numbers should sum to 100%.
Other exceptions like ClassNotFoundException and
IllegalArgumentException are signiﬁcantly lower
in Android 4.0 than in its previous version. Though excep-
tion types are sensitive to input data, we are applying similar
inputs to the two different versions of Android. Therefore,
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:17:27 UTC from IEEE Xplore.  Restrictions apply. 
Activities
Droid (Android 2.2)
Services
A. Semi-valid
B. Blank
C. Random
D. With Extra
297
#crash
30
21
18
13
42
#crash
1
1
1
1
%
2.4
2.4
2.4
2.4
%
10.1
7.1
6.1
4.4
2
6
4
1
Broadcast
Receivers
59
#crash
332
#crash
29
8
9
7
%
3.4
10.2
6.8
1.7
Activities
Emulator (Android 4.0)
Services
Broadcast
Receivers
69
#crash
%
2.9
8.7
2.9
0.0
2
6
2
0
54
#crash
%
8.7
2.4
2.7
2.1
Table I
3
3
3
3
%
5.6
5.6
5.6
5.6
Marketplace Apps on Droid (Android 2.2)
Activities
Broadcast
Receivers
Services
103
#crash
11
#crash
10
#crash
%
0.0
9.1
0.0
0.0
0
0
0
0
%
0.0
0.0
0.0
0.0
%
3.9
1.9
1.9
2.9
0
1
0
0
4
2
2
3
SUMMARY OF COMPONENT CRASHES IN DIFFERENT VERSIONS OF ANDROID IN RESPONSE TO FUZZED INTENTS IN FOUR DIFFERENT INJECTION
CAMPAIGNS. HERE ONE COMPONENT CRASHING ONE OR MORE TIMES IN RESPONSE TO ONE OR MORE MALFORMED INTENTS DIRECTED AT IT
COUNTS AS ONE CRASH.
our comparisons across the two versions are still valid.
Figure 3.
Distribution of different types of (uncaught) exceptions in
Android 2.2 and 4.0. The bars represent percentage of all the exceptions,
thus will sum to 100 (for each Android version). Note that we do not