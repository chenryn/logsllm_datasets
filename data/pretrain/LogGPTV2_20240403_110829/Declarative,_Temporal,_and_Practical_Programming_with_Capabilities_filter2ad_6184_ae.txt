We deﬁned a capweave policy that strictly limits the
abilities of an attacker who compromises bzip2 or gzip.
The policy restricts bzip2 and gzip to execute with
only the capability to read from the source ﬁle that holds
uncompressed data and write to the ﬁle opened to store the
compressed output. An attacker who compromises a version
of bzip2 or gzip that satisﬁes such a policy can compro-
mise the integrity of the output ﬁles of bzip2 or gzip,
but cannot carry out other malicious actions. For instance,
the attacker cannot overwrite arbitrary ﬁles. Our capweave
policies for bzip2 and gzip were inspired by previous
work on manually writing programs for Capsicum [10], [21].
php-cgi: Executing programs written in web script-
ing languages, such as PHP, raises multiple security issues.
First, analyzing, monitoring, and restricting the behavior
of a program written in a scripting language is inherently
difﬁcult. Second, a maliciously-crafted web program can
potentially compromise the interpreter that executes it, and
then perform any action on its host system that is allowed
for the user who launched the interpreter [5].
We deﬁned a capweave policy for the PHP CGI inter-
preter php-cgi that allows the interpreter to only read from
and write to ﬁles deﬁned by a small set of simple, easily-
audited checking functions. Our policy strictly limits the ﬁle
I/O of php-cgi itself, and thus indirectly limits the I/O of
any PHP script that the interpreter executes. We deﬁned the
policy by collaborating with a group of researchers from
MITLL.
tar: The tar archiving utility archives sets of ﬁles
into a single ﬁle. Unfortunately, past versions of tar have
contained vulnerabilities that allow an attacker who controls
the inputs to tar to run injected code with the privileges
of the user who invoked tar [6], [7].
We deﬁned a capweave policy that strictly limits the
abilities of an attacker who compromises tar. The policy
restricts tar to execute vulnerable functions without am-
bient authority. An attacker who compromises a version of
tar that satisﬁes such a policy can compromise the integrity
of output ﬁles opened by tar, but cannot carry out other
malicious actions.
tcpdump: tcpdump is a widely-used network-facing
application that historically has been the target of many
exploits. tcpdump takes as input a Berkeley Packet Filter
(BPF), and a device from which to read packets. In a correct
execution, it reads packets from the device, matches them
against the input BPF, and if the packet matches, prints
the packet to standard output. Unfortunately, the packet-
matching code in tcpdump is complex; in previous versions
of tcpdump, an attacker who controls the network input to
28
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:01 UTC from IEEE Xplore.  Restrictions apply. 
tcpdump can craft a packet that allows him to take control
of the process executing tcpdump [1].
We deﬁned a capweave policy for tcpdump that
strictly limits the power of an attacker who is able to
compromise tcpdump. In previous work on Capsicum [10],
the Capsicum developers instrumented tcpdump so that
it could only read from its input network device and
write to standard output. The Capsicum developers later
found through testing that this instrumentation did not allow
tcpdump to resolve network addresses in a packet, and the
developers revised the instrumentation of tcpdump so that
only a small, trusted DNS resolver could open ﬁles. The
capweave policy for tcpdump describes the policy that the
revised instrumentation satisﬁes.
its vulnerabilities,
and its capweave policy were discussed in §II. Our
policy for wget was inspired by discussion on the
Capsicum-developer mailing list and known vulnerabilities
of wget [2], [13].
wget: The wget downloader,
B. Experimental Procedure
For each of the benchmark programs and policies de-
scribed in §IV-A1, we deﬁned the benchmark’s policy in
the capweave policy language, and applied capweave to
the program and policy. We also obtained a version of each
program that was manually modiﬁed to satisfy the policy. In
previous work, the Capsicum developers manually rewrote
bzip2, gzip, and tcpdump to satisfy informal versions
of the policies described in §IV-A1. We recompiled these
versions with the LLVM compiler so that we could compare
their runtime overhead with the runtime overhead of the pro-
grams woven by capweave. We manually instrumented the
other three benchmarks to satisfy each of their policies. The
woven and manually instrumented programs were compiled
with the default optimization of each benchmark (“-O2” for
each program). capweave was applied to optimized LLVM
bitcode.
We ran bzip2, gzip, php-cgi, tcpdump, and wget
on the test workloads included in the source distribution of
each program. We ran tar to archive its own source direc-
tory. We ran each original benchmark, woven benchmark,
and manually rewritten benchmark on the benchmark’s test
suite, and compared the executions. In particular, we counted
the number of tests that each of the benchmark programs
passed, and measured the runtime performance overhead of
the rewritten programs compared to the original benchmark.
Because the total time taken by each benchmark on the
test workloads supplied with the source was often less than
a second, we also measured performance on larger, more
realistic workloads.
To validate that the woven programs mitigated attacks
according to their policy, we introduced into each program a
“backdoor” that attempted to carry out an attack disallowed
by the program’s policy. We then ran the woven program on
an input that triggered the backdoor, and observed that the
goal of the attack was not achieved.
C. Analysis of Results
The results of our experiments are given in Tab. I.
(The performance numbers reported in Tab. I are from the
test workloads included in the source distribution of each
program. Performance on larger, more realistic workloads
is discussed below.) For each benchmark, Tab. I contains
three groups of measurements of our experience weaving
the benchmark. The ﬁrst group (cols. 3–5) measures the
complexity of the policy for which the benchmark was
woven, and contains the number of lines of code in which
each policy is represented in our policy language, as well
as the size of the policy DFA constructed by capweave.
The number of lines of policy-language code (“Lines”)
indicates that the policy language supported by capweave
can express practical policies concisely.
The second group of measurements in Tab. I (cols. 6–7)
measures the performance of capweave, and contains the
time and peak memory used by capweave. Each bench-
mark was woven on a server that has sixteen 2.4 GHz cores
and 32 GB of memory, although the capweave implemen-
tation executes sequentially. The running time (cf. “Weaving
Time”) and peak memory (cf. “Weaving Mem.”) indicate
that capweave could be included in the edit-compile-run
toolchain of many programs of small-to-medium size, and
could be included in the nightly build system of a program of
large size. The running time and peak memory also indicate
that the performance of capweave is strongly determined
by the size of the policy, in particular the size of the policy-
automaton alphabet, more than the size of the input program
(cf. “States”, “Alpha. Size”, “Weaving Time”, and “Weaving
Mem”).
The third group of measurements in Tab. I (cols. 8–
15) measures the performance of programs rewritten by
capweave, and contains the number of reference tests
that the unwoven (i.e., baseline) program passed (“Tests”),
the number of tests passed by the woven version of each
benchmark (“OK”), the number of program points at which
capweave added instrumentation (“Woven Points”), the
number of functions that
the benchmark executes in a
synchronous fork (“Interproc. Funcs.”),
the runtime of
the baseline program (“Base”), the runtime of the woven
program expressed as a multiple of the runtime of the
baseline (“Woven Overhead”),
the runtime of the hand-
woven program as a multiple of the runtime of the baseline
(“Hand Overhead”), and the percentage overhead of the
runtime of the woven program over the runtime of the hand-
woven program (“capweave/ Hand”). The geometric mean
of all “capweave/ Hand” values is 1.298 (i.e., capweave
overhead is 29.8%). Each benchmark was run on a host
machine with eight 2.2 GHz processors and 6 GB of
29
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:01 UTC from IEEE Xplore.  Restrictions apply. 
Program Features
Prog. Name
Size
(KLOC)
bzip2-1.0.6
gzip-1.2.4
php-cgi-5.3.2
tar-1.25
tcpdump-4.1.1
wget-1.12
8
9
852
108
87
64
Policy Size
Weaver
Lines States Alpha. Weaving Weaving
Memory
0.3 GB
0.2 GB
25.3 GB
0.2 GB
0.3 GB
0.2 GB
Time
4m57s
3m26s
46m36s
0m08s
0m09s
0m10s
Size
5,156
1,787
15,777
143
223
549
70
68
114
49
52
35
5
5
11
8
6
3
6
2
11
1
29
4
6
2
2
1
27
4
Points Funcs.
1
1
2
2
1
1
66
55
213
62
88
246
Tests OK Woven Interproc. Base (s) Woven
Woven-Program Performance
Hand capweave/
Overhd. Overhd. Hand (%)
20.90
15.03
65.64
64.78
24.77
0.91
1.099
1.278
1.938
21.917
1.224
1.106
0.909
1.111
1.170
13.301
0.981
1.096
0.593
0.036
0.289
0.156
1.328
4.539
EXPERIMENTAL DATA FOR A SET OF BENCHMARKS PROGRAMS AND POLICIES. THE FIELDS OF THE TABLE ARE DISCUSSED IN §IV-C. IN THIS TABLE,
THE PERFORMANCE NUMBERS REPORTED ARE THOSE FROM THE TEST WORKLOADS INCLUDED IN THE SOURCE DISTRIBUTION OF EACH PROGRAM.
PERFORMANCE ON A LARGER, MORE REALISTIC WORKLOAD IS DISCUSSED IN §IV-C.
Table I
memory, in a Capsicum virtual machine with one processor
and 2 GB of memory.
Each woven program behaved identically to its corre-
sponding hand-woven program on each test, and behaved
identically to its corresponding unwoven program on each
test, except for some tests included with tcpdump and
php-cgi. The woven tcpdump failed tests included with
tcpdump that gave a ﬁlepath to a ﬁle containing a secret
key for decrypting IPsec ESP packets, instead of giving the
secret key directly on the command line. The tcpdump
policy speciﬁed that the woven tcpdump should not be
able to open any ﬁle except for the input network device,
and hence could not open the ﬁle containing the secret key.
The woven php-cgi failed tests included with php-cgi
because no weaving of php-cgi can simultaneously satisfy
the policy speciﬁed by the MITLL group and pass all of the
tests. For example, the MITLL policy does not allow a PHP
program to create a new ﬁle in its current directory. The
woven php-cgi thus failed any test in which a program
tried to create a ﬁle for output
in its current directory.
tcpdump and php-cgi thus illustrate one key aspect of
capweave: capweave allows a programmer to specify
the capabilities that a program should hold throughout an
execution, and automatically obtain a program that holds
the speciﬁed capabilities. However, a programmer still must
determine manually whether the capabilities speciﬁed by
a particular policy strike an acceptable balance between