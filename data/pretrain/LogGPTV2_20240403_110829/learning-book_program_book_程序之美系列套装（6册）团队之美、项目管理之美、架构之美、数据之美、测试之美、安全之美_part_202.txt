意味着编译器不能确定关于一个应用程序的所有信息对于它来说是
否都有用，反之则不然。例如，如果一个对象的一个方法正在调
用，而且对于那个对象只有一个可能的类，避免进行动态的方法分
派并直接调用这个方法会更好。在优化的运行时环境中有专门的优
化来处理这种情况，我们将在10.5.3中讨论它们。
10.2.5垃圾收集比显式内存管理更慢
自动的垃圾收集是计算机科学研究的一个高级领域。当内存不再需
要时会被请求并回收。显式内存管理利用给运行时环境发送明确的
命令来请求然后释放内存。虽然显式内存管理易于出错，但是，人
们经常坚持这对于性能来说是必需的。然而，这忽略了由于显式内
存管理所引起的许多复杂性。用了显式内存管理，就必须记录哪些
内存块在使用并维护没有使用的内存块的清单。当这结合了许多线
程并发地请求内存时，内存碎片的问题，以及把较小的区域合并起
来可以形成较大的供分配的内存区域，显式内存管理器的工作会变
得复杂。显式内存管理器还不能在内存中移动东西一例如，为了减
少碎片。
内存管理器的需求是应用程序特有的，在一个元循环运行时的背景
中，一个简单的即时编译器不必进行很多的内存分配，所以，显式
内存管理或自动垃圾收集的方案都能很好地工作。对于一个比较成
熟的优化编译器而言，除了垃圾收集减少了缺陷的可能性之外，两
者的区别不是很明显。对于更复杂的运行时系统的其他部分（稍后
我们将在10.5.5小节中讨论），虽然我们不能反驳垃圾收集比显式
内存管理更慢这种说法，但是，它明确改进了系统的“处理能力”。
10.2.6小结
因为并发工具本身就是应用程序，我们最初关于如何最好地并发一
个应用程序的问题成为了自指（self-referential）。托管语言消除了
缺点并提高了开发人员的生产率。简化开发模型，探索更多的机会
来优化应用程序和运行时，以元循环的方式来做这项工作，这会允
许并发人员从它们引入的特性中获益而避免遇到在应用程序、运行
时和系统的编译器之间的障碍。在下面的几节，我们将介绍Jikes
RVM，一个把这些原理组合在一起的运行时环境。
10.3JikesRVM简史
1142
---
## Page 1144
JikesRVM起源于IBM的Jalapenio项目。Jalapeio项目开始于1997年11
月份，目标是开发一个灵活的研究架构来研究高性能虚拟机设计中
的想法。在1998年初，一个最初的功能原型可以使用了，它能够运
行小的Java程序。在1998年的春大，关于优化编译器的工作开始
了，这个项目的规模快速地增长。在2000年初，项目成员已经发表
了好几篇讲述Jalapeio方面的学术论文，大学研究人员开始表示有
兴趣把这个系统用作为他们自己的研究成果的基础。
到2001年10月这个系统开源的时候，已经有16个大学在IBM的许可
协议下使用JikesRVM。这个团体快速地扩张，现在已经包括了好几
百个研究人员及一百多个机构。JikesRVM已经成为发表在学术刊物
中的多达188遍论文的基础，而且它已经构成了至少36篇学术论文
的基础。
JikesRVM从第2版开始开源，而且已经支持Intel和PowerPC架构。已
经有一些垃圾收集算法可用，包括引用计数（referencecounting）、
标记清除（mark-sweep）和半空间（semi-space）。一年后，2.2版
本的JikesRVM发布了。一个主要增强是全新实现了一个名为内存管
理工具包（MemoryManagementToolkit,MMTK）的内存管理子系
统。内存管理工具包已经成为垃圾收集研究团体中一个使用非常广
泛的框架，而且已经移植到JikesRVM之外的其他运行时。我们将在
10.5.9小节进一步讨论内存管理工具包和垃圾收集技术。优化编译
器和自适应优化系统也有显署的提高，运行时的开发通过转到开源
的GNUClasspath标准类库而简化了。在2003年4月，JikesRVM2.2.1
成为能够运行EclipseIDE重要部分的最早开源的Java运行时之一。
在2.2版本和2.4.6版本之间的近四年内，在功能和性能方面都有了许
多明显的改进，但是，源的结构和架构大部分都没有改变。
2008年8月JikesRVM3.0发布了，它体现了团队近两年改进和使这个
系统现代化的共同成果。代码中采用了Java5.0的语言特性，构建的
系统转为使用ApacheAnt，而且还开发了一个改良很多的测试基础
设施来增加系统稳定性和性能。另外，还进行了许多功能和性能的
改进，导致许多程序的性能可以与使用现代的生产八M所达到的性
能（用传统的运行时语言实现的，如C/C++）相媲美。
JikesRVM有太多的贡献者，以致在这儿不能一一提及，但是，我们
要感谢JikesRVM的开发团队。只有不多于100个人为JikesRVM贡献
了代码，有19个人作为fikesRVM核心团队的成员。要了解全部的感
1143
---
## Page 1145
谢名单，可以去JikesRVM的站点。在2005年《IBMSystemJournal》
（IBM系统杂志）的一篇文章（Alpern等2005）中可以了解关于
JikesRVM的早期历史和它的开源团体的成长的更多信息。
10.4一个自足执行的运行时自举
与一个传统编译器（图10-1）的自举相比，元循环运行时的自举涉
及更多的技巧。图10-2演示了描述这个过程的一个T型图。
创建的JikesRVM
Java
PowerPC
Java
PowerPC
Bytecode
机器码
Bytecode
机器码
PowerPC
PowerPC
Java
Bytecode
Java
Bytecode
机器码
机器码
PowerPC
机器码
自举JVM
PowerPC
机器码
用于编译自举
JVM的C编译器
图10-2：演示了JikesRVM在一个C编写的现有JVM上自举的T型图
这个启动映像包含了当这个系统自足执行时代表内存的好几个文件
（图10-2中最右边的T）。启动映像的内容是代码和数据，类似于
在一个常规编译器的对象文件中的东西。JikesRVM的启动映像中额
外包含了由垃圾收集器创建的根映射。我们将在后面的10.5.9节讲
述根映射。启动映像的创建者是使用JikesRVM的编译器创建这个启
动映像文件的一个程序，在一个自举JVM上执行。一个加载器负责
把这个启动映像加载到恰当的内存区域，在JikesRVM中，这个加载
器是众所周知的启动映像管理器。
10.4.1对象布局
启动映像记录器必须把对象布置在磁盘上，因为它们将用于运行的
JikesRVM中。JikesRVM中的对象模型是可配置的，在保持系统的
其他部分固定的同时允许可选设计进行评估。一个可选设计的例子
1144
---
## Page 1146
是是否为每个对象提供更多的位来容纳对象散列，或为每个对象提
供更多的位来实现同步的快速锁定。JikesRVM对象布局的纵览如图
10-3所示。
Java内容
目录
类型信息块（TIB）
静态和常量的
Type
基础类型
虚方法
静态和常量
接口方法
的引用
class foo
foo对象的
staticint X;
个实例
static fooY;
header
inta;
foob:
a
b
static intbar(){.)
.int boo()(.)
图10-3：JikesRVM中对象的布局
JikesRVM中默认的32位对象模式通常对于对象头使用两个字：第一
个字引用类型信息块，第二个字保存对象锁定、散列和垃圾搜集的
状态信息。位于对象头之后的是对象域。对于数组来说，第一个域
是数组的长度，其余的是数组的元素。为了避免存取数组的移位，
数组的大小就是对象头的大小和数组长度域，对对象的所有引用实
际上引用这个对象内三个字的位置。这样就允许数组中的第一个元
素在这个对象内的偏移为零，但是，这也意味着对象头总是在一个
对象引用之后的三个字，而且，一个对象的第一个域始终位于这个
对象的引用的负偏移位置。
1145
---
## Page 1147
类型信息块负责保存特定类型的每个对象的共同数据。这些数据主
要用于虚方法和接口方法分派。方法分派是识别与特定对象相关并
应该调用的方法的过程。类内部的方法在类型信息块中分配位置，
以便能够进行快速和有效的方法分派。类型信息块还保存那些容许
快速确定运行时类型信息的值，这加速了Java的instanceof和
checkcast的操作。它还保存了特别的方法以在垃圾收集期间处理一
个对象。
和对象一样，属于类的静态数据也必须跟踪。静态数据保存在一个
名为Java内容表（JavaTableOfContents,JTOC）的位置。Java内容
表在两个方向进行组织：Java内容表中的正向偏移保存了包含引用
和引用文字的静态域的内容。Java中文字的值是类似于一个字符事
的东西，是字节码可以直接引用但没有域位置的东西。Java内容表
中的负地址负责保存基础类型的值。按这种方式分离值，使垃圾收
集器更容易地判断静态域的哪些引用应该防止一个对象被认为是垃
圾。
10.4.2运行时内存配置
启动映像记录器负责当虚拟机并始启动时布置它的内存。在启动映
像中必需的所有对象都在那儿，因为它们都由将启动Java应用程序
的代码引用。图10-4显示了当JikesRVM执行时使用的内存区域的概
览。
1146
---
## Page 1148
OxFFFFFFFF
启动映像管理器的栈
本机库
Root Map
代码映像
MMTK空间
Code Array
Code Array
数据映像