understand the behavior of processes [19]. Traditionally, system calls were in-
voked by executing software interrupt instructions causing a transition from
user-space to kernel-space. Such user-/kernel-space interactions can be inter-
cepted by HyperSleuth, as interrupt instructions executed by the guest OS in
VMX non-root mode cause an exit to VMX root mode, i.e., to the VMM.
Alternative and more eﬃcient mechanisms for user-/kernel-space interactions
have been introduced by CPU developers, recently. Unfortunately, Intel VT-x
does not support natively the tracing of system calls invoked through the
sysenter/sysexit fast invocation interface used by modern operating systems.
The approach we use to trace system calls is thus inspired by Ether [5]. System
calls are intercepted through another type of exits: synthetic page fault excep-
tions. All system calls invocations go through a common gate, whose address
is deﬁned in the SYSENTER EIP register. We shadow the value of this register
and set the value of the shadow copy to the address of a non-existent memory
location, such that all system calls invocations result in a page fault exception
and in an exit to root mode. The VMM can easily detect the reason of the fault
by inspecting the faulty address. When a system call invocation is trapped by
the VMM, it logs the system call and then resumes the execution of the guest
from the real address of SYSENTER EIP. To intercept returns from system calls
we mark the page containing the return address as not accessible in the shadow
page table. The log is transmitted via network to the trusted host.
5 Experimental Evaluation
We implemented a prototype of the VMM and of the routines for the three
analyses described in Section 4. Our current implementation of HyperSleuth is
speciﬁc for the Microsoft Windows XP (32-bit) operating system. While the core
of HyperSleuth is mostly OS-independent, the routines for the analysis (e.g.,
the enumeration of running processes and of active network connections) are
OS-dependent and may require to be slightly adapted to provide support for
diﬀerent operating systems.
In this section we discuss the experimental results concerning the launch of
HyperSleuth, the lazy physical memory dumper, and the lie detector. To this
Live and Trustworthy Forensic Analysis of Commodity Production Systems
311
Fig. 5. Round-trip time of the queries performed against the compromised production
DNS server before (1) and after (2) the launch of HyperSleuth and (3–5) during the
lazy dump of the physical memory (the scale of the ordinate is logarithmic).
end, we simulated the compromised production system using an Intel Core i7,
with 3GB RAM, and a Realtek RTL8139 100Mbps network card. Note that we
disabled all cores of the CPU but one, since the VMM currently supports a single
core. We simulated the trusted host using a laptop. We used the trusted host to
attest the correct establishment of the dynamic root of trust and to collect and
subsequently analyze the results of the analysis.
5.1 HyperSleuth Launch and Lazy Dump of the Physical Memory
To evaluate the cost of launching HyperSleuth, the base overhead of the VMM,
and the cost of the lazy physical memory dumper we simulated the following
scenario. A production DNS server was compromised and we used HyperSleuth
to dump the entire content of the physical memory when the server was under
the heaviest possible load. We used an additional laptop, located on the same
network, to ﬂood the DNS server with queries and to measure the instantaneous
round-trip time of the queries. About 20 seconds after we started the ﬂood, we
launched HyperSleuth; 25 seconds later we started to dump the content of the
memory.
Figure 5 summarizes the results of our experiments. The graph shows the
round-trip time of the queries sent to the compromised DNS server over time.
For the duration of the experiment, the compromised machine was able to han-
dle all the incoming DNS queries, and no query timed out. Before launching
HyperSleuth the average round-trip time was ∼ 0.34ms (mark 1 in Figure 5).
Just after the launch, we observed an initial increase of the round-trip time to
about 0.19s (mark 2 in Figure 5). This increase was caused by the bootstrap
of the dynamic root of trust and then by the launch of the VMM, which must
312
L. Martignoni et al.
be performed atomically. After the launch, the round-trip time quickly stabi-
lized around 1.6ms, less than ﬁve times the round-trip time without the VMM.
The overhead introduced by the VMM was mostly caused by the handling of
the shadow page table. When we started the dump of the physical memory we
observed another and steeper peak (mark 3 in Figure 5). We were expecting
this behavior since there are a lot of writable memory pages that are frequently
accessed (e.g., the stack of the kernel and of the user-space processes and the
global variables of the kernel) and that, most likely, are written each time the
corresponding process is scheduled. Thus, the peak was caused by the massive
number of write accesses to pages not yet dumped. A dozen of seconds later the
round-trip time stabilized again around 1.6ms (mark 4 in Figure 5). That cor-
responds to the round-trip time observed before we started the dump. Indeed,
the most frequently written pages were written immediately after the dump was
started, and the cost of the dump of a single page was much less than the round-
trip time and was thus unnoticeable. The regular peaks around 32ms about
every second (mark 5 in Figure 5) were instead caused by the periodic dump of
non-written pages. Since the system was under heavy load, it never entered an
idle loop. Thus, the dump was forced after every second of uninterrupted CPU
activity. More precisely, the dumper was conﬁgured to dump 64 physical pages
about every second. Clearly, the number of non-written pages to be dumped
when either the system enters the idle loop, or the duration of uninterrupted
CPU activity hits a certain threshold, is a parameter that can be tuned accord-
ingly to the urgency of the analysis, to how critical the system is, and to the
throughput of the network.
In conclusion, the dump of the whole physical memory of the system (3GB of
RAM), in the setting just described, required about 180 minutes and the result-
ing dump could be analyzed using an oﬀ-the-shelf tool, such as Volatility [18].
The total time could be further decreased by increasing the number of physical
pages dumped periodically, at the cost of a higher average round-trip time. It
should also be pointed out that, on a 1Gbps network, we could increase the
number of physical pages dumped every second to 640, without incurring in any
additional performance penalty. In this case, the whole physical memory (3GB)
would be dumped in just ∼ 18 minutes. It is important to remark that although
HyperSleuth, and in particular the algorithm for dumping lazily the memory,
introduces a non-negligible overhead, we were able to dump the entire content
of the memory without interrupting the service (i.e., no DNS query timed out).
On the other hand, if the memory were dumped with traditional (atomic) ap-
proaches the dump would require, in the ideal case, about 24 seconds, 50 seconds,
and 4 minutes respectively on a 1Gbps network, on a 480Mbps FireWire chan-
nel, and on a 100Mbps network (these estimations are computed by dividing the
maximum throughout of the media by the amount of data to transmit). In these
cases, the production system would have not been able to handle any incoming
request, for the entire duration of the dump.
Live and Trustworthy Forensic Analysis of Commodity Production Systems
313
Table 1. Results of the evaluation of HyperSleuth’s lie detector with seven diﬀerent
malware (all equipped with a root-kit component)
DKOM
DKOM
Sample Characteristics
FU
FUTo
HaxDoor DKOM, SSDT hooking, API hooking
HE4Hook SSDT hooking
NtIllusion DLL injection
NucleRoot API hooking
Sinowal MBR infection, Run-time patching
Detected?
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
5.2 Lie Detection
Table 1 summarizes the results of the experiments we performed to assess the
eﬃcacy of the lie detection module. To this end, we used seven malware sam-
ples, each of which included a root-kit component to hide the malicious activity
performed on the infected system. We used HyperSleuth’s lie detector to detect
the hidden activities. The results testify that our approach can be used to detect
both user- and kernel-level root-kits.
For each malware sample we proceeded as follows. First, we let the malware
infect the untrusted system. Then, we launched HyperSleuth on the compromised
host and triggered the execution of the lie detector. The module performed the
analysis, ﬁrst by leveraging the in-guest utility, and then by collecting the same
information directly from the VMM through OS-aware inspection. The results
were sent separately to the trusted host. On the trusted host we compared
the two views of the state of the system and, in all cases, we detected some
discrepancies between the two. These discrepancies were all caused by lies. That
is, the state visible to the in-guest utility was altered by the root-kit, while the
state visible to HyperSleuth VMM was not.
As an example, consider the FUTo root-kit. This sample leverages direct ker-
nel object manipulation (DKOM) techniques to hide certain kernel objects cre-
ated by the malware (e.g., processes) [1]. Our current implementation of the lie
detector counteracts DKOM through a series of analyses similar to those imple-
mented in RAIDE [20]. Brieﬂy, those analyses consist in scanning some internal
structures of the Windows kernel that the malware must leave intact in order to
preserve its functionalities. Thus, when we compared the trusted with the un-
trusted view of the state of the system we noticed a process that was not present
in the untrusted view produced by the in-guest utility. Another interesting ex-
ample is NucleRoot, a root-kit that hooks Windows’ System Service Descriptor
Table (SSDT) to intercept the execution of several system calls and to ﬁlter out
their results, in order to hide certain ﬁles, processes, and registry keys. In this
case, by comparing the two views of the state of the system, we observed that
some registry keys related to the malware were missing in the untrusted view.
Although we have not yet any empirical proof, we speculate the even rootkits
like Shadow Walker [2] would be detected by our lie detector since our approach
314
L. Martignoni et al.
allows to inspect the memory directly, bypassing a malicious page-fault handler
and bogus TLBs’ entries.
6 Discussion
We presented HyperSleuth from a technical prospective. The decisions we made
in designing and implementing HyperSleuth were mostly motivated by the intent
of minimizing the dependencies on the hardware and of maximizing the porta-
bility. Therefore, we always opted for pure software-based approaches (e.g., to
secure the launch of the VMM and to virtualize the MMU), whenever possible.
However, since HyperSleuth is a framework for performing live forensic analyses,
it is important to reason about its probatory value. From such a prospective,
we must take into account that the trustworthiness of the results of the analy-
ses depends on the trust people have in the tool that generated the results. To
strengthen its probatory value, all HyperSleuth’s components should be veriﬁed
in order to prove that their code meets all the expectations [21]. At this aim,
in the future we plan to further decrease the size of HyperSleuth’s code base
in order to ease its veriﬁability (e.g., by leveraging hardware-based attestation
solutions, such as the TPM).
HyperSleuth’s eﬀectiveness depends on the impossibility to detect its pres-
ence from the guest. Although the VMM is completely isolated from the guest,
the malware might attempt to detect HyperSleuth by trying to install another
VMM. One approach to contrast such attempts is to let the malware believe
that virtualization support is not available at all.
7 Related Work
The idea of leveraging a virtual machine monitor to perform sophisticated run-
time analyses, with the guarantee that the results cannot be tampered by a mali-
cious attacker, has already been widely explored in the literature. Garﬁnkel et al.
were the ﬁrst to propose to use a VMM to perform OS-aware introspection [6],
and subsequently the idea was further elaborated [22, 5]. Other researchers in-
stead proposed to use a VMM to protect the guest OS from attacks by supervis-
ing its execution, both with a software-based VMM [8] and by leveraging hard-
ware support for virtualization [9]. Similar ideas were also suggested by other
authors [7, 23]. In [24] Chen et al. proposed a solution to protect applications’
data even in the presence of a compromised operating system. More recently, Va-
sudevan et al. proposed XTREC, a lightweight framework to record securely the
execution control ﬂow of all code running in an untrusted system [25]. Unfortu-
nately, in order to guarantee that the analyses they perform cannot be tampered
by an attacker, all the aforementioned solutions must take control of the system
before the guest is booted, and cannot be removed until the guest is shut down.
On the contrary, HyperSleuth can be installed as the compromised system runs,
and, when the analyses are completed, it can be removed on-the-ﬂy. The idea to
take advantage of the possibility to install a VMM on a running system was also
Live and Trustworthy Forensic Analysis of Commodity Production Systems
315
sketched in [26], and later investigated in our previous research work to realize
HyperDbg, a transparent kernel-level debugger [27].
Several researchers proposed to use VMMs to implement malware that are
particularly hard to detect and to eradicate. SubVirt was one of the ﬁrst pro-
totypes that employed this technique [28]. However, being implemented using a
software-based VMM, the installation of Subvirt required to reboot the machine,
and the malware also introduced a noticeable run-time overhead in the infected
target. Later, the Blue Pill malware started to exploit the hardware-assisted sup-
ports for virtualization to implement an eﬃcient VMM-based malware that is
able to infect a machine as it runs, without the need for reboot [10]. HyperSleuth
was inspired by this malware.
8 Conclusion
We presented HyperSleuth, a framework for constructing forensic tools that lever-
ages the virtualization extensions provided by commodity hardware to guaran-
tee that the results of the analyses cannot be altered, even by an attacker with
kernel-level privileges. HyperSleuth consists in a tiny hypervisor that is installed
on a potentially compromised system as it runs, and a secure loader that installs
the hypervisor and veriﬁes its integrity. We developed a proof-of-concept pro-
totype of HyperSleuth and, on top of it, we implemented three forensic analysis
applications: a lazy physical memory dumper, a lie detector, and a system call
tracer. Our experimental evaluation testiﬁed the eﬀectiveness of the proposed
approach.
References
1. Hoglund, G., Butler, J.: Rootkits: Subverting the Windows Kernel. Addison-Wesley
Professional, Reading (2005)
2. Sparks, S., Butler, J.: Shadow Walker. Raising The Bar For Windows Rootkit
Detection. Phrack Magazine 11(63) (2005)
3. AMD, Inc.: AMD Virtualization, www.amd.com/virtualization
4. Intel Corporation: Intel Virtualization Technology,
http://www.intel.com/technology/virtualization/
5. Dinaburg, A., Royal, P., Sharif, M., Lee, W.: Ether: Malware Analysis via Hard-
ware Virtualization Extensions. In: Proceedings of the 15th ACM Conference on
Computer and Communications Security (2008)
6. Garﬁnkel, T., Rosenblum, M.: A Virtual Machine Introspection Based Architecture
for Intrusion Detection. In: Proceedings of the Network and Distributed Systems
Security Symposium. The Internet Society, San Diego (2003)
7. Payne, B.D., Carbone, M., Sharif, M., Lee, W.: Lares: An Architecture for Secure
Active Monitoring Using Virtualization. In: Proceedings of the IEEE Symposium
on Security and Privacy (2008)
8. Riley, R., Jiang, X., Xu, D.: Guest-Transparent Prevention of Kernel Rootkits
with VMM-Based Memory Shadowing. In: Proceedings of the 11th International
Symposium on Recent Advances in Intrusion Detection (2008)
316
L. Martignoni et al.
9. Seshadri, A., Luk, M., Qu, N., Perrig, A.: SecVisor: A Tiny Hypervisor to Provide
Lifetime Kernel Code Integrity for Commodity OSes. In: Proccedings of the ACM
Symposium on Operating Systems Principles. ACM, New York (2007)
10. Rutkowska, J.: Subverting Vista Kernel For Fun And Proﬁt. Black Hat USA (2006)
11. McCune, J.M., Parno, B., Perrig, A., Reiter, M.K., Isozaki, H.: Flicker: An exe-
cution infrastructure for tcb minimization. In: Proceedings of the ACM European
Conference in Computer Systems (2008)
12. Seshadri, A., Luk, M., Shi, E., Perrig, A., van Doorn, L., Khosla, P.: Pioneer:
Verifying integrity and guaranteeing execution of code on legacy platforms. In:
Proceedings of ACM Symposium on Operating Systems Principles (2005)
13. Seshadri, A., Perrig, A., van Doorn, L., Khosla, P.: Swatt: Software-based attes-
tation for embedded devices. In: Proceedings of the IEEE Symposium on Security
and Privacy (2004)
14. Martignoni, L., Paleari, R., Bruschi, D.: Conqueror: tamper-proof code execution
on legacy systems. In: Proceedings of the Conference on Detection of Intrusions
and Malware and Vulnerability Assessment. LNCS. Springer, Heidelberg (2010)
15. Grawrock, D.: Dynamics of a Trusted Platform: A Building Block Approach. Intel
Press, Hillsboro (2009)
16. Carbone, M., Zamboni, D., Lee, W.: Taming virtualization. IEEE Security and
Privacy 6(1) (2008)
17. Smith, J.E., Nair, R.: Virtual Machines: Versatile Platforms for Systems and Pro-
cesses. Morgan Kaufmann, San Francisco (2005)
18. Volatile Systems LLC: Volatility, http://www.volatilesystems.com/
19. Forrest, S., Hofmeyr, S.R., Somayaji, A., Longstaﬀ, T.A.: A Sense of Self for Unix
Processes. In: Proceedings of the IEEE Symposium on Security and Privacy (1996)
20. Butler, J., Silberman, P.: RAIDE: Rookit analysis identiﬁcation elimination. In:
Black Hat USA (2006)
21. Franklin, J., Seshadri, A., Qu, N., Datta, A., Chaki, S.: Attacking, Repairing, and
Verifying SecVisor: A Retrospective on the Security of a Hypervisor. Technical
Report, Carnegie Mellon University (2008)
22. Jiang, X., Wang, X.: “out-of-the-box” monitoring of VM-based high-interaction
honeypots. In: Proceedings of the International Symposium on Recent Advances
in Intrusion Detection (2007)
23. Sharif, M., Lee, W., Cui, W., Lanzi, A.: Secure In-VM Monitoring Using Hard-
ware Virtualization. In: Proceedings of the ACM Conference on Computer and
Communications Security (2009)
24. Chen, X., Garﬁnkel, T., Lewis, E.C., Subrahmanyam, P., Waldspurger, C.A.,
Boneh, D., Dwoskin, J., Ports, D.R.K.: Overshadow: a virtualization-based ap-
proach to retroﬁtting protection in commodity operating systems. Operating Sys-
tems Review 42(2) (2008)
25. Perrig, A., Gligor, V., Vasudevan, A.: XTREC: secure real-time execution trace
recording and analysis on commodity platforms. Technical Report, Carnegie Mellon
University (2010)
26. Sahita, R., Warrier, U., Dewan, P.: Dynamic software application protection. Tech-
nical Report, Intel Corporation (2009)
27. Fattori, A., Paleari, R., Martignoni, L., Monga, M.: HyperDbg: a fully transparent
kernel-level debugger, http://code.google.com/p/hyperdbg/
28. King, S.T., Chen, P.M., Wang, Y.M., Verbowski, C., Wang, H.J., Lorch, J.R.:
SubVirt: Implementing malware with virtual machines. In: Proceedings of IEEE
Symposium on Security and Privacy (2006)
Hybrid Analysis and Control of Malware
Kevin A. Roundy and Barton P. Miller
Computer Sciences Department
{roundy,bart}@cs.wisc.edu
University of Wisconsin
Abstract. Malware attacks necessitate extensive forensic analysis ef-
forts that are manual-labor intensive because of the analysis-resistance
techniques that malware authors employ. The most prevalent of these
techniques are code unpacking, code overwriting, and control transfer
obfuscations. We simplify the analyst’s task by analyzing the code prior
to its execution and by providing the ability to selectively monitor its
execution. We achieve pre-execution analysis by combining static and
dynamic techniques to construct control- and data-ﬂow analyses. These
analyses form the interface by which the analyst instruments the code.
This interface simpliﬁes the instrumentation task, allowing us to reduce
the number of instrumented program locations by a hundred-fold relative
to existing instrumentation-based methods of identifying unpacked code.
We implement our techniques in SD-Dyninst and apply them to a large
corpus of malware, performing analysis tasks such as code coverage tests
and call-stack traversals that are greatly simpliﬁed by hybrid analysis.
Keywords: malware analysis, forensics, hybrid, de-obfuscation, packed
code, self-modifying code, obfuscated code.
1 Introduction
Malicious software infects computer systems at an alarming rate, causing eco-
nomic damages that are estimated at more than ten billion dollars per year [1].
Immediately upon discovering a new threat, analysts begin studying its code to
determine damage done and information extracted, and ways to curtail its im-
pact; analysts also study the malware so they can recover infected systems and
construct defenses. Thus, a primary goal of malware authors is to make these
tasks as diﬃcult and resource intensive as possible. This explains why 90% of
malware binaries employ analysis-resistance techniques [9], the most prevalent of
which are the run-time unpacking of compressed and encrypted code, run-time
modiﬁcations to existing code, and obfuscations of control transfers in the code.
Security companies detect thousands of new malware samples each day [45], yet
despite the importance and scale of this problem, analysts continue to resort to
manual-labor intensive methods.
Analysts accomplish their tasks by studying the malware’s overall structure