请注意，这不是指取代整个系统的单一部署。这可以一部分一部分地完成。这种方法的基础是它创建了一个新的外部服务，旨在取代旧的系统。
这种方法的优点是，它极大地有助于构建新服务，因为它不继承技术债务，并且允许事后重新审视旧问题。
新的服务还可以使用新的工具，并且不需要继续使用任何与公司未来技术方向的战略观点不一致的旧栈。
这种方法的问题在于，成本可能很高，而且可能需要很长时间。对于没有文档记录的旧服务，替换它们可能需要很大的努力。此外，这种方法只能应用于稳定的模块；如果它们被积极开发，试图用其他东西来代替它们会一直移动门柱。
这种方法对于旧的遗留系统来说最有意义，这些遗留系统很小，或者至少有一小部分执行有限的功能，并且是在旧的技术栈中开发的，这很难或者不再被认为是值得维护的。
# 分割方法
如果系统结构良好，也许它的某些部分可以干净地分成自己的系统，保持相同的代码。
在这种情况下，创建一个新服务更多的是一个复制粘贴的练习，用最少的代码量包装它，以允许它独立执行并与其他系统互操作，换句话说，围绕 HTTP 请求构建它的应用编程接口，以获得一个标准接口。
如果可以使用这种方法，这意味着代码已经非常结构化了，这是一个好消息。
被调用到这个部分的系统也必须进行调整以进行调用，不是内部代码，而是通过 HTTP 调用。好的一面是，这可以通过几个步骤来完成:
1.  将代码复制到自己的微服务中并部署它。
2.  旧的调用系统正在使用旧的嵌入式代码。
3.  迁移呼叫并检查系统是否正常工作。
4.  迭代，直到所有旧调用都迁移到新系统。
5.  从旧系统中删除分割的代码。
如果代码的结构不够清晰，我们需要先修改它。
# 变革和结构化方法
如果整体是有机增长的，它不可能所有的模块都是干净的结构。有些结构可能存在，但它们可能不是我们想要的微服务部门的正确结构。
为了调整服务，我们需要进行一些内部更改。这些内部变化可以反复进行，直到服务可以被干净地划分。
这三种方法可以结合起来生成完整的迁移。每一个涉及的工作是不一样的，因为一个容易分割的服务将能够比替换记录不良的遗留代码更快。
在项目的这个阶段，目标是有一个清晰的路线图，它应该分析以下要素:
*   什么样的微服务将首先可用的有序计划，考虑如何处理依赖性。
*   了解最大的痛点是什么，以及解决这些痛点是否是优先事项。痛点是经常处理的元素，当前处理整块的方式使它们变得困难。
*   有哪些难点和易拉罐虫？很可能会有一些。承认它们的存在，并尽量减少它们对其他服务的影响。请注意，它们可能与痛点相同，也可能不同。难点可能是非常稳定的旧系统。
*   几个速战速决将保持项目的势头。快速向您的团队和利益相关者展示优势！这也将让每个人都了解你想要转向的新运作模式，并开始以这种方式工作。
*   关于团队需要的培训以及您想要引入的新要素的想法。此外，无论你的团队中是否缺乏任何技能，你都有可能计划雇佣。
*   任何团队变更和新服务的所有权。考虑团队的反馈很重要，这样他们就可以表达对计划创建过程中任何疏忽的担忧。
对于我们的具体示例，最终计划如下:
*   作为先决条件，负载平衡器需要在操作之前。这将负责将请求引导到适当的微服务。然后，改变这个元素的配置，我们将能够将请求路由到旧的单块或任何新的微服务。
*   之后，静态文件将通过自己独立的服务进行服务，这是一个很容易的改变。静态 web 服务器就足够了，尽管它将作为独立的微服务进行部署。这个项目将有助于理解向 Docker 的转移。
*   认证代码将在新服务中复制。它将使用一个 RESTful API 来登录和生成一个会话，以及注销。该服务将负责检查用户是否存在，以及添加和删除他们:
    *   第一个想法是检查针对服务检索的每个会话，但是，鉴于检查会话是一个非常常见的操作，我们决定生成一个包，在面向外部的微服务之间共享，这将允许检查是否已经使用我们自己的服务生成了会话。这将通过对会话进行加密签名并在我们的服务中共享机密来实现。这个模块预计不会经常改变，因为它是所有微服务的依赖项。这使得会话成为不需要存储的会话。
    *   用户后端需要能够允许使用 OAuth 2.0 模式进行认证，这将允许不基于网络浏览器的其他外部服务进行认证和操作，例如移动应用。
*   思想后端也将被复制为一个 RESTful 应用编程接口。这个后端目前非常简单，它将包括搜索功能。
*   在两个后端都可用之后，当前的整体将被改变，从直接调用数据库，变成使用后端的 RESTful APIs。成功完成后，旧的部署将被 Docker 构建替换并添加到负载平衡器中。
*   新的应用编程接口将从外部添加到负载平衡器，并提升为可从外部访问。制造移动应用的公司将开始整合他们的客户。
我们的新架构模式如下:
![](img/4eebde2f-2787-40c3-855e-855bb045daf0.png)
请注意，HTML 前端将使用外部可用的相同 API。这将验证这些调用是否有用，因为我们将首先将它们用于我们自己的客户端。
这个行动计划可以有可衡量的时间和时间表。也可以采用一些技术选项，在我们的案例中，如下所示:
*   每个微服务都将部署在自己的 Docker 容器中([https://www.docker.com/](https://www.docker.com/))。我们将建立一个 Kubernetes 集群来协调不同的服务。
*   我们决定在 Flask([https://palletsprojects.com/p/flask/](https://palletsprojects.com/p/flask/))中创建新的后端服务，使用 Flask-RESTPlus([https://flask-restplus.readthedocs.io/en/stable/](https://flask-restplus.readthedocs.io/en/stable/))来生成一个文档齐全的 RESTful 应用，并使用 SQLAlchemy([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/))连接到现有数据库。这些工具是 Python，但采用的方法比 Django 更简单。
*   后端服务将使用 uWSGI 服务器([https://uwsgi-docs.readthedocs.io/en/latest/](https://uwsgi-docs.readthedocs.io/en/latest/))提供。
*   静态文件将使用 NGINX([https://www.nginx.com/](https://www.nginx.com/))提供。
*   NGINX 还将用作负载平衡器来控制输入。
*   HTML 前端将继续使用 Django([https://www.djangoproject.com/](https://www.djangoproject.com/))。
团队可以继续使用这些技术栈，并期待学习一些新技巧！
# 执行移动
最后一步是执行精心设计的计划，开始从过时的整块石头转移到微服务的新乐土！
但这一阶段的旅程实际上可能是最长和最困难的——尤其是如果我们希望保持服务运行，并且不发生中断业务的中断。
这个阶段最重要的想法是**向后兼容**。这意味着从外部角度来看，该系统仍像旧系统一样运行。如果我们能够做到这一点，我们就可以透明地改变我们的内部运营，同时我们的客户能够不间断地继续他们的运营。
这显然说起来容易做起来难，有时被称为用福特 T 开始比赛，用法拉利结束比赛，不停地更换每一个零件。好消息是，软件是如此绝对灵活和可延展，以至于它实际上是可能的。
# Web 服务最好的朋友——负载平衡器
负载平衡器是一种工具，允许在几个后端资源之间分发 HTTP 请求(或其他类型的网络请求)。
负载平衡器的主要操作是允许将流量定向到一个地址，并在几个相同的后端服务器之间进行分配，这样可以分散负载并实现更好的吞吐量。通常，流量将通过循环分配，也就是说，按顺序分配给所有流量:
![](img/a75b18b4-6475-4d39-b42c-3db3a565acf2.png)
首先是一名工人，然后是另一名工人，依次是:
![](img/67724773-c5dd-4193-8803-14b43fd27f9b.png)
这是正常的操作。但也可以用来替代服务。负载平衡器确保每个请求干净地传递给一个或另一个工作者。工作人员池中的服务可能不同，因此我们可以使用它在 web 服务的一个版本和另一个版本之间进行干净的转换。