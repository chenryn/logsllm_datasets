Dynamically Allocated Types
Dynamically Exercised Types
REWARDS Accuracy
p
s
p
i
n
g
n
e
t
s
t
a
t
ls
u
p
ti
m
e
Benchmark Program
(b) Accuracy on Heap Variables
u
s
e
r
s
  REWARDS
  MemTrace
  Normal Execution
p
s
p
i
n
g
ls
n
e
t
s
t
a
t
p
w
d
d
a
t
e
u
p
ti
u
n
a
m
m
e
e
Benchmark Program
(d) Performance Overhead
u
s
e
r
s
 100
 80
 60
 40
 20
 0
 6e+07
 5e+07
 4e+07
 3e+07
 2e+07
 1e+07
 0
e
g
a
t
n
e
c
r
e
P
)
s
e
t
y
b
(
n
o
i
t
p
m
u
s
n
o
C
y
r
o
m
e
M
w
o
d
a
h
S
h
o
s
t
n
a
m
e
h
o
s
t
n
a
m
e
Figure 2. Evaluation results for REWARDS accuracy and efﬁciency
Dynamically Executed Funs
Dynamically Exposed Types
REWARDS Accuracy
u
s
h
o
e
r
s
s
t
n
a
m
e
Dynamically Exercised Types
REWARDS Accuracy
p
s
p
i
n
g
ls
n
e
t
s
t
a
t
p
w
d
d
a
t
e
u
p
ti
u
n
a
m
m
e
e
Benchmark Program
(c) Accuracy on Global Variables
u
s
h
o
e
r
s
s
t
n
a
m
e
    REWARDS
p
s
p
i
n
g
ls
n
e
t
s
t
a
t
p
w
d
d
a
t
e
u
p
ti
u
n
a
m
m
e
e
Benchmark Program
(e) Space Overhead
u
s
h
o
e
r
s
s
t
n
a
m
e
racy, we carefully examined the benchmarks and identiﬁed
the following two reasons:
5 Applications of REWARDS
• Hierarchy loss.
If a hierarchical structure becomes
ﬂat after compilation, we are not able to identify its
hierarchy. This happens to structures declared as
global variables or stack variables. And the binary
never accesses such a variable using the base address
plus a local offset.
Instead, it directly uses a global
offset (starting from the base address of the global data
section or a stack frame).
In other words, multiple
composite structures are ﬂattened into one large struc-
ture. In contrast, such ﬂattening does not happen to
heap structures.
• Path-sensitive memory reuse. This often happens
to stack variables.
In particular, the compiler might
assign different local variables declared in different
program paths to the same memory address. As a
result,
the types of these variables are undesirably
uniﬁed in our current design. A more thorough design
would use a path-sensitive local offset to denote a stack
variable.
Despite the imperfect accuracy, REWARDS still suits
our targeted application scenarios, i.e., memory forensics
and vulnerability fuzzing.
For example, although RE-
WARDS outputs a ﬂat layout for all global and stack
variables, we can still conduct vulnerability fuzzing because
the absolute offsets of these variables are sufﬁcient; and we
can still construct hierarchical views of memory images as
pointer types can be obtained.
4.2 Evaluation of Efﬁciency
We also measured the time and space overhead of
REWARDS. We compared it with (1) a standard memory
trace tool, MemTrace (shipped along with PIN-2.6) and
(2) the normal execution of the program, to evaluate the
performance overhead. The result is shown in Figure 2(d).
Note the normal execution data is nearly not visible in this
ﬁgure because they are very small (roughly at the 0.01 sec-
ond level). We can observe that REWARDS causes slow-
down in the order of ten times compared with MemTrace,
and in the order of thousands (or tens of thousands) times
compared with the normal execution.
For space overhead, we are interested in the space con-
sumption by shadow type sets and constraint sets. Hence,
we track the peak value of the shadow memory consump-
tion. The result is shown in Figure 2(e). We can observe
that the shadow memory consumption is around 10 Mbytes
for these benchmarks. A special case is ping, which uses
much less memory. The reason is that it has fewer function
calls and memory allocations, which is also why it runs
much faster than the other programs shown in Figure 2(d).
REWARDS can be applied to a number of applications.
In this section, we demonstrate how REWARDS provides
unique beneﬁts to (1) memory image forensics and (2)
binary vulnerability fuzz.
5.1 Memory Image Forensics
Memory image forensics is a process to extract mean-
ingful information from a memory dump. Examples of
such information are IP addresses that the application under
investigation is talking to and ﬁles being accessed. Data
structure deﬁnitions play a critical role in the extraction
process. For instance, without data structure information,
it is hard to decide if four consecutive bytes represent an
IP address or just a regular value. REWARDS enables
analyzing memory dumps for a binary without symbolic
information. In this subsection, we demonstrate how RE-
WARDS can be used to type reachable memory as well as
some of the unreachable (i.e., dead) memory.
5.1.1 Typing Reachable Memory
In this case study, we demonstrate how we use REWARDS
to discover IP addresses from a memory dump using the
hierarchical view (Section 3.5). We run a web server
nullhttpd-0.5.1. A client communicates with this
server through wget (wget-1.10.2). The client has
IP 10.0.0.11 and the server has IP 10.0.0.4. The
memory dump is obtained from the server at the moment
when a system call is invoked to close the client connection.
Part of the memory dump is shown in Figure 3. The IPs are
underlined in the ﬁgure. From the memory dump, it is very
hard for human inspectors to identify those IPs without a
meaningful view of the memory. We use REWARDS to
derive the data structure deﬁnitions for nullhttpd and
then construct a hierarchical view of the memory dump
following the method described in Section 3.5.
The relevant part of the reconstructed view is presented
in Figure 4(a). The root represents a pointer variable in
the global section. The outgoing edge of the root leads
to the data structure being pointed to. The edge label
“struct 0x0804dd4f *” denotes that this is a heap
data structure whose allocation PC (also its abstraction)
is 0x0804dd4f. According to the view construction
method,
the memory region being pointed to is typed
according to the derived deﬁnition of the data structure
denoted by 0x0804dd4f, resulting in the second layer in
Figure 4(a). The memory region starts at 0x08052170 is
denoted by the node with the address label. The individual
child nodes represent the different ﬁelds of the structure,
e.g. the ﬁrst ﬁeld is a thread id according to the semantic
tag pthread t, the fourth ﬁeld (with offset +12) denotes
...
08052170  b0 5b fe b7 b0 5b fe b7  05 00 00 00 02 00 92 7e  
08052180  0a 00 00 0b 00 00 00 00  00 00 00 00 c7 b0 af 4a
08052190  c7 b0 af 4a 00 00 00 00  58 2a 05 08 00 00 00 00
080521a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
...
08052a50  00 00 00 00 59 31 01 00  4b 65 65 70 2d 41 6c 69
08052a60  76 65 00 00 00 00 00 00  00 00 00 00 00 00 00 00
08052a70  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00 
*
08052ee0  00 00 00 00 00 00 00 00  00 00 00 00 31 30 2e 30
08052ef0  2e 30 2e 34 00 00 00 00  00 00 00 00 00 00 00 00
08052f00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
*
08052fe0  00 00 00 00 00 00 00 00  00 00 00 00 48 54 54 50
08052ff0  2f 31 2e 30 00 00 00 00  00 00 00 00 00 00 00 00
08053000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
*
08053470  00 00 00 00 00 00 00 00  00 00 00 00 31 30 2e 30