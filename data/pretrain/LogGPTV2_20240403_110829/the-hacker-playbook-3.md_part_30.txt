通知。“[ http://bit.ly/2H0n68h ]
接下来，我们继续构建从文件句柄开始的回调函数的功能。在示例代码中，它将在 Windows
系统的 Temp 目录（C:\Windows\Temp）中创建名为 “log.txt” 的文件。 该文件配置了
参数，因为键盘记录器需要不断地将击键输出到文件。如果此临时文件夹中没有该文
append
件，则会创建一个同名文件（log.txt）。
回到 结构体，代码声明了一个 指针，然后将其分配给
KBDLLHOOKSTRUCT KBDLLHOOKSTRUCT
。这将允许访问每个按键的 内的参数。 然后代码检查 是否返回
lParam lParam wParam
，这将检查按键是否被按下。这样做是因为钩子会在按下和释放按键时触发。如
WM_KEYDOWN
果代码没有检查 ，程序将每次写入两次击键。
WM_KEYDOWN
检查按键被按下后，需要有一个 语句，用于检查 的 （虚拟键代码）
switch lParam vkCode
是否有特殊键。某些键需要以不同的方式写入文件，例如返回键（Esc），控制键（Ctrl），
移位（shfit），空格（Space）和制表键（Tab）。对于默认情况，代码需要将按键的
转换为实际的字母。 执行此转换的简单方法是使用 函数。 函数
vkCode ToAscii ToAscii
将包含 ，一个 ，一个指向键盘状态数组的指针，一个指向将接收该字母的
vkCode ScanCode
缓冲区的指针，以及一个 的 值。 和 来自按键结构体，键盘
uFlags int vkCode ScanCode
状态是先前声明的字节数组，用于保存输出的缓冲区， 参数将设置为0。
uFlags
检查是否释放了某些键是非常必要的，例如 shift 键。这可以通过编写另一个 if 语句 来
检查 WM_KEYUP ，然后使用 switch语句 来检查所需的键来完成。 最后，需要关闭该文件并返
回 。回调函数如下所示：
CallNextHookEx
https://github.com/cheetz/ceylogger/blob/master/callback
此时，键盘记录器功能完全正常，但依旧有一些问题。第一个是运行程序会产生一个命令提
示符的窗口，这使得程序运行非常明显，并且窗口没有任何提示输出是非常可疑的。 另一个
问题是将文件放在运行该键盘记录器的同一台计算机上并不是很好。
201
第7章 四分卫突破——逃避杀毒软件和网络检测
通过使用 Windows 特定的 WinMain 函数入口替换标准 C 语言的 Main 函数入口，可以相对
容易地修复有命令提示符窗口的问题。根据我的理解，之所以有效是因为 是
WinMain
Windows 上图形程序的入口。尽管操作系统期望你为程序创建窗口，但我们可以命令它不要
创建任何窗口，因为我们有这个控件。最终，该程序只是在后台生成一个进程而不创建任何
窗口。
该程序的网络编程是简单粗暴的。首先通过声明 WSAData （ http://bit.ly/2HAiVN7 ），启动
winsock ，清除提示结构体以及填写相关需求来初始化 Windows socket 函数。就我们的示
例来说，代码将使用 AF_UNSPEC 用于 IPV4 和 SOC_STREAM 用于 TCP 连接，并使用
getaddrinfo 函数使用先前的需求填充 c2 结构体。在满足所有必需参数后，可以创建
。最后，通过 函数连接到 。
socket socket_connect socket
连接之后， socket_sendfile 函数将完成大部分工作。它使用 Windows 的 CreateFile 函数
打开日志文件的句柄，然后使用 函数获取文件大小。获得文件大小后，代码
GetFileSizeEx
将分配该大小的缓冲区，加上一个用于填充的缓冲区，然后将该文件读入该缓冲区。 最后，
我们通过 发送缓冲区的内容。
socket
对于服务器端，可以在 C2 服务器的3490 端口上的启动 socat 侦听器，命令启动：
socat：socat - TCP4-LISTEN:3490,fork
一旦启动监听器并且键盘记录器正在运行，你应该看到来自受害者主机的所有命令每 10 分钟
被推送到你的 C2 服务器。 可以在此处找到键盘记录器的初始完整版本1：
https://github.com/cheetz/ceylogger/tree/master/version1 。
在编译 version_1.c 之前，请确保将 getaddrinfo 修改为当前的 C2 的IP 地址。编译代码：
cl version_1.c io.c
应该提到的最后一个函数是 函数。 调用函数 来获取当
thread_func thread_func get_time
前系统的分钟。然后检查该值是否可被 5 整除，因为该工具每隔 5 分钟发送一次键盘记录文
件。如果它可以被 5 整除，它会设置 socket 并尝试连接到 C2 服务器。如果连接成功，它
将发送文件并运行清理本地文件。然后循环休眠 59 秒。需要睡眠功能的原因是因为这一切都
在一个固定的循环中运行，这意味着该函数将在几秒钟内获取时间，初始化连接，完成连接
和发送文件。如果没有 59 秒的休眠时间，该程序最终可能会在 1 分钟的时间间隔内发送文件
几十次。休眠功能允许循环等待足够长的时间以便切换到下一分钟，因此每 5 分钟仅发送一
次文件。
混淆
202
第7章 四分卫突破——逃避杀毒软件和网络检测
有数百种不同的方法来执行混淆。虽然本章不能全部一一讲述，但我想为你提供一些基本的
技巧和思路来解决绕过杀毒软件的问题。
你可能已经知道，杀毒软件会查找特定的字符串。可用于绕过杀毒软件的最简单方法之一是
创建一个简单的旋转密码并移动字符串的字符。在下面的代码中，有一个解密函数，可以将
所有字符串移动 6 个字符（ROT6）。这会导致杀毒软件可能无法检测到特征码。在程序开始
时，代码将调用解密函数来获取字符串数组并将它们返回到本来的形式。解密函数如下所
示：
int decrypt(const char* string, char result[])
{
int key = 6;
int len = strlen(string);
for(int n = 0; n < len; n++)
{
int symbol = string[n];
int e_symbol = symbol - key;
result[n] = e_symbol;
}
result[len] = ‘\0’;
return 0;
}
你可以在此处的程序版本2中看到此示
例：https://github.com/cheetz/ceylogger/tree/master/version2 。
另一种可以用来逃避杀毒软件的方法是使用函数指针调用 User32.dll 中的函数，而不是直接
调用函数。为此，首先编写一个函数定义，然后使用 Windows 系统的 GetProcAddress 函数
找到要调用的函数的地址，最后将函数定义指针指定给从 接收的地址。可以
GetProcAddress
在此处找到如何使用函数指针调用 函数的示
SetWindowsHookEx
例：https://github.com/cheetz/ceylogger/blob/master/version3/version_3.c#L197-L241 。
该程序的第 3 版本将前一个示例中的字符串加密与使用指针调用函数的方法相结合。有趣的
是，如果你将已编译的二进制文件提交到 VirusTotal（病毒检测网站），你将不再在导入部分
中看到 User32.dll。在下面的图片中，左侧图像是版本1的检测结果，右侧图像是带有调用指
针的版本3的检测结果 。
203
第7章 四分卫突破——逃避杀毒软件和网络检测
你可以在以下网址找到版本3的完整源代
码：https://github.com/cheetz/ceylogger/tree/master/version3 。
为了了解你是否已成功避开杀毒软件，最佳选择是始终针对实时杀毒软件系统进行测试。在
真实世界的入侵活动中，我不建议使用 VirusTotal 网站，因为你的病毒样本可能会发送给不同
的杀毒软件厂商。然而，它非常适合测试或者学习。对于我们的 payload，以下是 VirusTotal
比较：
对于版本1，32位，21/66（21家检测出），触发杀毒软件：
https://www.virustotal.com/#/file/4f7e3e32f50171fa527cd1e53d33cc08ab85e7a945cf0c0
fcc978ea62a44a62d/detection
http://bit.ly/2IXfuQh
对于版本3，32位，14/69（14家检测出），触发杀毒软件：
https://www.virustotal.com/#/file/8032c4fe2a59571daa83b6e2db09ff2eba66fd299633b1
73b6e372fe762255b7/detection
http://bit.ly/2IYyM7F
最后，如果我们将版本3编译为 64 位的 payload，我们得到 1/69（仅仅一家检测出）！：
https://www.virustotal.com/#/file/e13d0e84fa8320e310537c7fdc4619170bfdb20214baae
e13daad90a175c13c0/detection
http://bit.ly/2JNcBmc
204
第7章 四分卫突破——逃避杀毒软件和网络检测
译者注：根据上面的链接，译者点进去看了每一个数据，但是发现数据都有所更新，所
以把上面的内容修改为和链接到的内容一致的最新数据。但是下面的图片是书上的原
图，所以是老的过期的数据。下面的图片是说，将版本3编译为 64 位的 payload，得到
0/66（无一家一家检测出）的结果，但是现在已经是 1/69，也就是 69 个杀软种有一个
可以检测出病毒。
实验：
下一步我们还可以做什么呢？有无限种可能！可以做一些小的优化比如对 log.txt 内容进行模
糊/加密，或者在程序启动后启动加密套接字，然后将获得击键权限直接写入该套接字。在接
收方，服务器将重建数据流并将其写入文件。 这将阻止日志数据以纯文本形式显示，就像当
前一样，并且还可以防止在硬盘中留下更多的文件痕迹。
如果你想做一些大的改进，那么你可以将可执行文件转换为 DLL，然后将 DLL 注入正在运行
的进程。这样可以防止进程信息显示在任务管理器中。虽然有一些程序可以显示系统中所有
当前加载的 DLL，但注入 DLL 会更加隐蔽。此外，有些程序可以反射性地从内存加载 DLL 而
根本不在磁盘中留下痕迹（无文件），从而进一步降低了被取证的风险。
本书定制的挂钩病毒（Dropper）
Dropper（挂钩病毒）是红队工具包的重要组成部分，允许你在不把程序放在受害者计算机磁
盘上的情况下运行你植入的程序。不将你的植入程序保存在磁盘上会降低它们被发现的风
险，从而可以供你多次使用开展工作。在本章中，我们将介绍本书定制开发的一个 dropper，
它可以导入 shellcode 或仅驻留在内存中的 DLL 。
在设计 dropper 和相应的服务器时，你需要记住一些事项。dropper 的目的是成为你的武器库
中的一件用完就销毁的武器，这意味着你必须假设以当前形式使用它将触发进一步活动中的
检测。
205
第7章 四分卫突破——逃避杀毒软件和网络检测
为了使后续的入侵活动更容易，你需要开发一个可以重复使用的标准服务器。在该示例中，
你将看到一个基本的网络实现，它允许为不同的消息注册新的处理程序（handler）。虽然此
示例仅包含 消息类型的处理程序，但你可以轻松添加新处理程序以扩展功能。这
LOAD_BLOB
样就可以搭建良好的底层架构，因为你的所有通信都已标准化。
编写 dropper 或其他任何你希望快速找到并进行对其逆向的东西的时候，有个很重要步骤就
是要清理你的文本字符串。当你第一次构建软件时，或许你运气好、调试消息显示成功，这
使你无需手动单步执行调试器以查看为什么会出现问题。但是，如果特定的文本字符串在最
终版本中被意外地遗留下来，将使病毒分析师很容易就可以逆向你的恶意软件。很多时候，
反病毒会针对一个独一无二的特定字符串或一个常量值签名。在示例中，我使用
InfoLog()
和 ，它们的预处理器将在发布版本上编译。使用那些宏，通过检查是否定义了
ErrorLog()
_DEBUG，将指示是否包含相关调用。
本书定制 Dropper 代码：https://github.com/cheetz/thpDropper.git
Shellcode 与 DLL
在以下示例中，你可以让 dropper 加载完整的 DLL 或 shellcode。通常对于很多公共植入文
件，你可以生成一个完整的 DLL，它将下载 DLL 然后反射 DLL。让你的 dropper 直接加载
DLL 将使你无需再进行更多的 API 调用，从而保持更好的隐蔽性。由于 header 被修改，某些