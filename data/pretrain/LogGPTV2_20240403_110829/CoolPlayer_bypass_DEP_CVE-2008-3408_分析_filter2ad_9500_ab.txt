                        (Skin.Object[TimeText].y + Skin.Object[TimeText].h))
                {
                    options.show_remaining_time = !options.show_remaining_time;
                    main_draw_time(hWnd);
                    break;
                }
                main_draw_controls_all(hWnd);
                break;
            }
跟我们最相关的是这里
    case EjectButton:
            main_play_control(ID_LOAD, hWnd);
跟进查看`ID_LOAD`的处理代码
    int main_play_control(WORD wParam, HWND hWnd)
    {
        ...
        case ID_LOAD:
                CPVERB_OpenFile(vaDoVerb, hWnd);
                break;
        ...
    }
继续跟进
    void CPVERB_OpenFile(const CPe_VerbAction enAction, void* _pParam)
    {
        if (enAction == vaDoVerb)
        {
            if (playlist_open_file(TRUE))
                CPL_PlayItem(globals.m_hPlaylist, TRUE, pmCurrentItem);
        }
        else if (enAction == vaQueryName)
        {
            CPs_VerbQueryName* pParam = (CPs_VerbQueryName*)_pParam;
            if (stricmp(pParam->m_pcName, "OpenFile") == 0)
                pParam->m_bNameMatched = TRUE;
        }
    }
其实联系上两步，可以发现`enAction == vaDoVerb`，因为`enAction`就是`vaDoVerb`
跟进`playlist_open_file(TRUE)`
    int playlist_open_file(BOOL clearlist)
    {
        OPENFILENAME fn;
        char filefilter[] =
            "All Supported files*.mp1;*.mp2;*.mp3;*.m3u;*.pls;*.wav;*.ogg"
            "MPEG audio files (*.mp1;*.mp2;*.mp3)*.mp1;*.mp2;*.mp3"
            "Vorbis files (*.ogg)*.ogg"
            "Playlist files (*.m3u;*.pls)*.m3u;*.pls"
            "WAV files (*.wav)*.wav"
            "All Files (*.*)*.*";
        ...
        returnval = GetOpenFileName(&fn);
        if (returnval != FALSE)
        {
            char   *newfilename;
            char    path_buffer[_MAX_PATH];
            char    path_buffer2[_MAX_PATH];
            if (clearlist)
                CPL_Empty(globals.m_hPlaylist);
            strcpy(path_buffer, fn.lpstrFile);
            if (path_is_directory(fn.lpstrFile) == TRUE)
            {
                path_add_backslash(path_buffer);
            }
            else
            {
                path_remove_filespec(path_buffer);
            }
            strcpy(options.last_used_directory, path_buffer);
            newfilename = fn.lpstrFile + fn.nFileOffset;
            while (newfilename[0] != 0)
            {
                strcpy(path_buffer2, path_buffer);
                strcat(path_buffer2, newfilename);
                CPL_SyncLoadNextFile(globals.m_hPlaylist);
                CPL_AddFile(globals.m_hPlaylist, path_buffer2);
                newfilename = newfilename + strlen(newfilename) + 1;
            }
            return 1;
        }
        return 0;
    }
其主要的功能就是
  1. 设置可以打开的文件后缀白名单
  2. 获取打开的文件名
  3. 构建文件的绝对路径名
根据分析，函数`CPL_AddFile`会根据绝对路径名去处理文件，继续跟进。该函数首先会判断文件的类型，获取文件的大小，获取文件目录字符串长度等，再根据不同的类型进入不同的分支进行处理，而且还可以从网络上下载文件进行处理。从`1249`行去处理`m3u`文件。
    void CPL_AddFile(CP_HPLAYLIST hPlaylist, const char* pcFilename)
    {
        ...
        // Check for known file types
        enFileType = CPL_GetFileType(pcFilename);
        ...
        // Get playlist file information
        iPlaylist_VolumeBytes = CPL_GetPathVolumeBytes(pcFilename);
        iPlaylist_DirectoryBytes = CPL_GetPathDirectoryBytes(pcFilename, iPlaylist_VolumeBytes); // 这里很重要！！！！
        ...
        // 开始处理m3u文件
        // It's not a URL, so we will read the file from a local (UNC) resource
        hFile = CreateFile(pcFilename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            const DWORD dwFileSize = GetFileSize(hFile, NULL);
            // We will only load playlists that are smaller than 256K
            if (dwFileSize < 0x40000)
            {
                // The plan is to load the entire file into a memblock and then split it into lines
                // and scan off the whitepace and add the items to the list
                pcPlaylistBuffer = (char *)malloc(dwFileSize + 1);
                ReadFile(hFile, pcPlaylistBuffer, dwFileSize, &dwBytesRead, NULL);
                // Read in the file line by line
                iLastLineStartIDX = 0;
                for (iCharIDX = 0; iCharIDX < dwFileSize + 1; iCharIDX++)
                {
                    if ((pcPlaylistBuffer[iCharIDX] == 'r' || pcPlaylistBuffer[iCharIDX] == 'n' || iCharIDX == dwFileSize) && iLastLineStartIDX < iCharIDX)
                    {
                        char cBuffer[512];
                        // Is there a file on this line (strip whitespace from start)
                        if (sscanf(pcPlaylistBuffer + iLastLineStartIDX, " %512[^rn]", cBuffer) == 1)
                        {
                            // Something has been read - ignore lines starting with #
                            if (cBuffer[0] != '#')
                                CPL_AddPrefixedFile(hPlaylist, cBuffer, NULL, pcFilename, iPlaylist_VolumeBytes, iPlaylist_DirectoryBytes);
                        }
                        // Set the line start for the next line
                        if (pcPlaylistBuffer[iCharIDX + 1] == 'n')
                            iCharIDX++;
                        iLastLineStartIDX = iCharIDX + 1;
                    }
                }
                free(pcPlaylistBuffer);
            }
            CloseHandle(hFile);
        }
其中`for`循环，根据列表文件，一次处理一行，由于代码量比较大，并且这块的处理逻辑很重要，我截一个图，再做一些标注，好方便理解。
跟进函数`CPL_AddPrefixedFile`
    void CPL_AddPrefixedFile(CP_HPLAYLIST hPlaylist,
                             const char* pcFilename, const char* pcTitle,
                             const char* pcPlaylistFile,
                             const unsigned int iPlaylist_VolumeBytes,
                             const unsigned int iPlaylist_DirBytes)
    {
        const unsigned int iFile_VolumeBytes = CPL_GetPathVolumeBytes(pcFilename);
        // If the file has volume information - add it as it is
        if (iFile_VolumeBytes)
            CPL_AddSingleFile(hPlaylist, pcFilename, pcTitle);
        // If the filename has a leading  then add it prepended by the playlist's volume
        else if (pcFilename[0] == '\')
        {
            char cFullPath[MAX_PATH];
            memcpy(cFullPath, pcPlaylistFile, iPlaylist_VolumeBytes);
            strcpy(cFullPath + iPlaylist_VolumeBytes, pcFilename + 1);
            CPL_AddSingleFile(hPlaylist, cFullPath, pcTitle);
        }
        // Add the filename prepended by the playlist's directory
        else
        {
            char cFullPath[MAX_PATH];
            memcpy(cFullPath, pcPlaylistFile, iPlaylist_DirBytes);
            strcpy(cFullPath + iPlaylist_DirBytes, pcFilename); // 溢出位置
            CPL_AddSingleFile(hPlaylist, cFullPath, pcTitle);
        }
    }
根据分析，最后执行的会是这里