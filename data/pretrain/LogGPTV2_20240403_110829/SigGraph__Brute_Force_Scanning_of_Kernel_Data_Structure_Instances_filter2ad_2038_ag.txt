signature generation.
The attacker may try harder by destroying a pointer ﬁeld
after a reference, and then restoring it before its next ref-
erence. As such, it is likely that a memory snapshot not
have the true pointer value. However, carrying out such
attacks is challenging as there may be many code sites in
the kernel that access the pointer ﬁeld. All such sites need
to be patched in order to respect the original semantics of
the kernel, which would require a complex and expensive
static analysis on the kernel. To get an (under)-estimate of
the required efforts, we conduct a proﬁling experiment on
task struct. We collect the functions that access each
ﬁeld, including both pointers and non-pointers. The results
are shown in Figure 9(a), We observe that most ﬁelds are
accessed by at least 6 functions. Some ﬁelds are accessed
by 70 functions (the statistics is shown in Figure 9(b)).
Note that these are only dynamic proﬁling numbers, the
static counterparts may be even higher. Even if the attacker
achieves some success, SigGraph can still leverage its mul-
tiple signature capability to avoid using those pointers that
are easily manipulatable.
Malicious Non-Pointer Value Manipulation. Another
possible way to confuse SigGraph is to mutate a non-pointer
value to resemble that of a pointer. SigGraph has built-in
protection against such attacks. First of all, the dynamic
reﬁnement phase will get rid of most ﬁelds that are vul-
nerable to such mutation. Moreover, compared to mutation
within a domain, such as changing an integer ﬁeld (with the
range from 1 to 100) from 55 to 56, cross-domain muta-
tion, such as changing the integer ﬁeld to a pointer, has a
much higher chance to crash the system. Hence, we suspect
that not many non-pointer ﬁelds are susceptible. In the fu-
ture, we plan to use fuzzing, similar to [13], to study how
many ﬁelds allow such cross-domain value mutation.
In
fact, we can effectively integrate SigGraph signatures with
the value-invariant signatures (e.g., those derived by [13])
for the same data structure, which is likely to achieve even
stronger robustness against malicious non-pointer manipu-
lation.
Other Possible Attacks. The attacker may change data
structure layout to evade SigGraph. Without knowledge
about the new layout, SigGraph will fail. However, such
attacks are challenging. The attacker needs to intercept the
corresponding kernel object allocations and de-allocations
to change layout at runtime. Furthermore, all accesses to
the affected ﬁelds need to be patched.
The attacker could also try to generate fake data struc-
ture instances to thwart the use of SigGraph. However, we
 12000
 10000
 8000
 6000
 4000
 2000
s
n
o
i
t
c
n
u
F
l
e
n
r
e
K
Pointer Field
Non-pointer Field
 70
 60
s
n
o
 50
Pointer Field
Non-pointer Field
i
t
c
n
u
F
g
n
s
s
e
c
c
A
i
f
o
r
e
b
m
u
N
 40
 30
 20
 10
 0
 0
 20
 40
 60
 100
 80
 120
ith Field of Task Structure
 140
 160
 180
 200
 0
 0
 20
 40
 60
 100
 80
 120
ith Field of Task Structure
 140
 160
 180
 200
(a) Detailed ﬁeld access functions
(b) Statistics of ﬁeld access functions
Figure 9. Proﬁling accesses to the ﬁelds of task struct
point out that fake data structure instance creation is a gen-
erally hard problem across all signature-based approaches,
including the value invariant-based approaches. In fact, Sig-
Graph makes such attacks harder as the attacker would have
to fake the multiple data structures involved in a graph sig-
nature and make sure that all the points-to relations among
these data structures are properly set up.
SigGraph can help detect kernel rootkit attacks by identi-
fying hidden kernel data structure instances in a given mem-
ory image. There are other types of kernel attacks that do
not involve data hiding (e.g., BluePill [19]). SigGraph, as
a kernel object scanner generator, is not applicable to the
detection of such kernel attacks.
10 Related Work
Kernel Memory Mapping and Analysis: There have
been efforts in developing kernel memory mapping and
data analysis techniques for kernel integrity checking (e.g.,
[26, 15]). Recent advances include the mapping and anal-
ysis of kernel memory images for control ﬂow integrity
checking [29] and kernel data integrity checking [27, 10].
To facilitate kernel data integrity checking, techniques have
been proposed for deriving kernel data structure invariants
[8, 13].
SigGraph is inspired by, and hence closely related to the
above efforts [27, 8, 10, 13]. In particular, Petroni et al. [27]
proposed examining semantic invariants (such as “a process
must be on either the wait queue or the run queue.”) of ker-
nel data structures to detect kernel rootkits. The key ob-
servation is that any violations of semantic invariants indi-
cate kernel rootkit presence. But the semantic invariants
are manually speciﬁed. Baliga et al. [8] proposed using
the dynamic invariant detector Daikon [14] to extract kernel
data structure constraints. The invariants detected include
membership, non-zero, bounds, length, and subset relations.
Dolan-Gavitt et al.
[13] proposed a scheme for generat-
ing robust value invariant-based kernel data structure signa-
tures. Complementing these efforts, SigGraph leverages the
points-to relations between kernel data structures for signa-
ture generation. As suggested in Section 9, SigGraph-based
and value invariant-based signatures can be integrated to
further improve brute force scanning accuracy.
Carbone et al. proposed KOP [10] which involves build-
ing a global points-to graph for kernel memory mapping
and kernel integrity checking. The global graph is con-
structed via an advanced inter-procedural points-to analy-
sis on OS source code. A few heuristics were proposed to
better resolve function pointers. KOP is a highly effective
system when the kernel source code and a powerful static
analysis infrastructure are available. The main differences
between SigGraph and KOP are the following: (1) Unlike
KOP, SigGraph does not require complex points-to analy-
sis (which often involves source code analysis) and instead
only requires kernel data structure deﬁnitions.
(2) KOP
requires that data structure instances be reachable starting
from the root(s) of the global points-to graph; whereas Sig-
Graph does not require such global reachability and hence
supports brute force memory scanning that can start at any
kernel memory address. In particular, SigGraph may recog-
nize kernel objects that are unreachable from global/stack
variables. (3) To achieve robustness against pointer corrup-
tion, the global points-to graph heavily depends on a com-
plete revelation of points-to relations between data struc-
tures; whereas SigGraph can generate multiple signatures
for each data structure by excluding problematic pointers
(e.g., null and void* pointers).
Memory Forensics: Memory forensics is a process of ana-
lyzing a memory image to interpret the state of the system.
It has been evolving from basic techniques such as string
matching to more complex methods such as object traver-
sal (e.g., [28, 34, 11, 22, 10]) and signature-based scan-
ning (e.g., [38, 35, 13, 9, 4]). Signature-based scanning in-
volves directly parsing the memory image using signatures.
In particular, Schuster [35] presented PTﬁnder for linearly
searching Windows memory images to discover process and
thread structures, using manually created signatures. Simi-
lar to PTﬁnder, GREPEXEC [4], Volatility [38], and Mem-
parser [9] are related systems capable of searching for more
types of objects. Dolan-Gavitt et al. [13] further proposed
an automated technique to derive robust data structure sig-
natures. Sharing the same goal of providing robust signa-
tures for brute force memory scanning, SigGraph provides
graph-based, provably non-isomorphic signatures (as well
as the corresponding memory scanners) for individual ker-
nel data structures.
Malware Signature Derivation based on Data Structure
Pattern: Data structures are one of the important and intrin-
sic properties of a program. Recent advances have demon-
strated that data structure patterns can be used as a pro-
gram’s signature.
In particular, Laika [12] shows a way
of inferring the layout of data structure from snapshot, and
uses the layout as signature. Their inference is based on
unsupervised Bayesian learning and they assume no prior
knowledge about program data structures. Laika and Sig-
Graph are substantially different in that: (1) Laika focuses
on deriving a program’s signature from data structure pat-
terns; whereas SigGraph focuses on deriving data struc-
tures’ signatures from the points-to relations among them.
(2) Laika, by its nature, does not assume availability of data
structure deﬁnitions. On the contrary, data structure deﬁ-
nitions are the input of SigGraph to generate data structure
signatures.
Data Structure Type Inference: There is a large body
of research in program data structure type inference, such
as object oriented type inference [24], aggregate structure
identiﬁcation [31], binary static analysis-based type infer-
ence [6, 7, 32], abstract type inference [23, 17], and dy-
namic heap type inference [30]. Most of these techniques
are static, aiming to infer types of unknown objects in a pro-
gram. SigGraph is more relevant to dynamic techniques.
Dynamic heap type inference by Polishchuk et al. [30]
focuses on typing heap objects in memory. SigGraph and
[30] do share some common insights such as leveraging
pointers. However, the latter focuses on type-inference of
heap objects (for debugging) by assuming known start ad-
dresses and sizes of all allocated heap blocks; whereas Sig-
Graph aims at uncovering all kernel objects (including heap,
stack, and global) from a raw memory image. To uncover
those objects, the user can simply execute the data structure-
speciﬁc scanners on the raw memory image – without any
runtime support; whereas techniques in [30] require collect-
ing runtime information. Moreover, the different purpose
of SigGraph raises the new challenge of avoiding structural
isomorphism among data structure signatures.
11 Conclusion
OS kernels are rich in data structures with points-to re-
lations between each other. We have presented SigGraph, a
framework that systematically generates graph-based, non-
isomorphic data structure signatures for brute force scan-
ning of kernel memory images. Each signature is a graph
rooted at the subject data structure with edges reﬂecting the
points-to relations with other data structures. SigGraph-
based signatures complement value invariant-based signa-
tures for more accurate recognition of kernel data structures
with pointer ﬁelds. Moreover, SigGraph differs from global
memory mapping-based approaches that have to start from
global variables and require reachability to all data structure
instances from them. Our experiments with a wide range of
Linux kernels show that SigGraph-based signatures achieve
zero false negative rate and very low false positive rate.
Moreover, the signatures are not affected by the absence of
global points-to graphs and are robust against pointer value
anomalies and corruptions. We demonstrate that SigGraph
can be applied to kernel memory forensics, kernel rootkit
detection, and kernel version inference.
Acknowledgement
We would like to thank our shepherd, Phil Porras, and
the anonymous reviewers For their insightful comments and
suggestions. Special thanks go to Michael Locasto, Wei-
dong Cui and AAron Walters for their constructive feed-
back that has helped improve the paper. This research
was supported, in part, by the National Science Foundation
(NSF) under grants 0716444, 0720516, 0845870, 0852131,
0855036, and 1049303. Any opinions, ﬁndings, and con-
clusions or recommendations in this paper are those of the
authors and do not necessarily reﬂect the views of the NSF.
References
[1] Gnu
compiler
collection
(gcc)
internals.
http://gcc.gnu.org/onlinedocs/gccint/.
[2] Mission critical
linux.
In Memory Core Dump,
http://oss.missioncriticallinux.com/projects/mcore/.
[3] QEMU:
open
http://www.qemu.org/.
an
source
processor
emulator.
[4] bugcheck. grepexec: Grepping executive objects from pool
memory. Uninformed Journal, 4, 2006.
[5] O. Arkin, F. Yarochkin, and M. Kydyraliev. ”the present and
future of xprobe2: The next generati on of active operating
system ﬁngerprinting. sys-security group,, July 2003.
[6] G. Balakrishnan, , G. Balakrishnan, and T. Reps. Analyzing
memory accesses in x86 executables. In Proceedings of In-
ternational Conference on Compiler Construction (CC’04),
pages 5–23. Springer-Verlag, 2004.
[7] G. Balakrishnan and T. Reps. Divine: Discovering variables
in executables. In Proceedings of International Conf. on Ver-
iﬁcation Model Checking and Abstract Interpretation (VM-
CAI’07), Nice, France, 2007. ACM Press.
[8] A. Baliga, V. Ganapathy, and L. Iftode. Automatic inference
and enforcement of kernel data structure invariants. In Pro-
ceedings of the 2008 Annual Computer Security Applications
Conference (ACSAC’08), pages 77–86, Anaheim, California,
December 2008.
Betz.
Memparser.
[9] C.
http://sourceforge.net/projects/memparser.
[10] M. Carbone, W. Cui, L. Lu, W. Lee, M. Peinado, and
X. Jiang. Mapping kernel objects to enable systematic in-
tegrity checking.
In The 16th ACM Conference on Com-
puter and Communications Security (CCS’09), pages 555–
565, Chicago, IL, USA, 2009.
[11] A. Case, A. Cristina, L. Marziale, G. G. Richard, and
V. Roussev. Face: Automated digital evidence discovery
and correlation. Digital Investigation, 5(Supplement 1):S65
– S75, 2008. The Proceedings of the Eighth Annual DFRWS
Conference.
[12] A. Cozzie, F. Stratton, H. Xue, and S. T. King. Digging for
data structures. In Proceeding of 8th Symposium on Oper-
ating System Design and Implementation (OSDI’08), pages
231–244, San Diego, CA, December, 2008.
[13] B. Dolan-Gavitt, A. Srivastava, P. Traynor, and J. Gifﬁn. Ro-
bust signatures for kernel data structures. In Proceedings of
the 16th ACM conference on Computer and communications
security (CCS’09), pages 566–577, Chicago, Illinois, USA,
2009. ACM.
[14] M. Ernst, J. Cockrell, W. Griswold, and D. Notkin. Dy-
namically discovering likely program invariants to support
program evolution. IEEE Trans. on Software Engineering,
27(2):1–25, 2001.
[15] T. Garﬁnkel and M. Rosenblum. A Virtual Machine In-
trospection Based Architecture for Intrusion Detection.
In
Proc. Network and Distributed Systems Security Symposium
(NDSS’03), February 2003.
[16] L. G. Greenwald and T. J. Thomas. Toward undetected op-
erating system ﬁngerprinting.
In Proceedings of the ﬁrst
USENIX workshop on Offensive Technologies, pages 1–10.
USENIX Association, 2007.
[17] P. J. Guo, J. H. Perkins, S. McCamant, and M. D. Ernst. Dy-
namic inference of abstract types. In Proceedings of the 2006
international symposium on Software testing and analysis
(ISSTA’06), pages 255–265, Portland, Maine, USA, 2006.
ACM.
[18] X. Jiang, X. Wang, and D. Xu. Stealthy malware detec-
tion through vmm-based “out-of-the-box” semantic view re-
construction.
In Proceedings of the 14th ACM conference
on Computer and communications security (CCS’07), pages
128–138, Alexandria, Virginia, USA, 2007. ACM.
[19] B. Laurie and A. Singer. Choose the red pill and the blue
pill: a position paper. In Proceedings of the 2008 workshop
on New security paradigms, pages 127–133, 2008.
[20] J. Lee, T. Avgerinos, and D. Brumley. Tie: Principled reverse
engineering of types in binary programs. In Proceedings of
the 18th Annual Network and Distributed System Security
Symposium (NDSS’11), San Diego, CA, February 2011.
[21] Z. Lin, X. Zhang, and D. Xu. Automatic reverse engineering
of data structures from binary execution. In Proceedings of
the 17th Annual Network and Distributed System Security
Symposium (NDSS’10), San Diego, CA, February 2010.
[22] P. Movall, W. Nelson, and S. Wetzstein. Linux physical
memory analysis.
In Proceedings of the FREENIX Track
of the USENIX Annual Technical Conference, pages 23–32,
Anaheim, CA, 2005. USENIX Association.
[23] R. O’Callahan and D. Jackson. Lackwit: a program under-
standing tool based on type inference.
In Proceedings of
the 19th international conference on Software engineering,
pages 338–348, Boston, Massachusetts, USA, 1997. ACM.
[24] J. Palsberg and M. I. Schwartzbach. Object-oriented type
inference.
In OOPSLA ’91: Conference proceedings on
Object-oriented programming systems, languages, and ap-
plications, pages 146–161, Phoenix, Arizona, United States,
1991. ACM.
[25] B. D. Payne, M. Carbone, and W. Lee. Secure and ﬂexible
monitoring of virtual machines. In Proceedings of the 23rd
Annual Computer Security Applications Conference (ACSAC
2007), December 2007.
[26] N. L. Petroni, Jr., T. Fraser, J. Molina, and W. A. Arbaugh.
Copilot - a coprocessor-based kernel runtime integrity moni-
tor. In Proceedings of the 13th USENIX Security Symposium,
pages 179–194, San Diego, CA, August 2004.
[27] N. L. Petroni, Jr., T. Fraser, A. Walters, and W. A. Arbaugh.
An architecture for speciﬁcation-based detection of semantic
integrity violations in kernel dynamic data. In Proceedings
of the 15th USENIX Security Symposium, Vancouver, B.C.,
Canada, August 2006. USENIX Association.
[28] N. L. Petroni, Jr., A. Walters, T. Fraser, and W. A. Arbaugh.
Fatkit: A framework for the extraction and analysis of digital
forensic data from volatile system memory. Digital Investi-
gation, 3(4):197 – 210, 2006.
[29] N. L. Petroni, Jr. and M. Hicks. Automated detection of per-
sistent kernel control-ﬂow attacks. In Proceedings of the 14th
ACM conference on Computer and communications security
(CCS’07), pages 103–115, Alexandria, Virginia, USA, Oc-
tober 2007. ACM.
[30] M. Polishchuk, B. Liblit, and C. W. Schulze. Dynamic heap
type inference for program understanding and debugging.
SIGPLAN Not., 42(1):39–46, 2007.
[31] G. Ramalingam, J. Field, and F. Tip. Aggregate structure
In
identiﬁcation and its application to program analysis.
Proceedings of the 26th ACM SIGPLAN-SIGACT symposium
on Principles of programming languages (POPL’99), pages
119–132, San Antonio, Texas, 1999. ACM.
[32] T. W. Reps and G. Balakrishnan. Improved memory-access
analysis for x86 executables. In Proceedings of International
Conference on Compiler Construction (CC’08), pages 16–
35, 2008.
[33] J. Rhee, R. Riley, D. Xu, and X. Jiang. Kernel malware anal-
ysis with un-tampered and temporal views of dynamic ker-
nel memory. In Proceedings of the 13th International Sym-
posium of Recent Advances in Intrusion Detection, Ottawa,
Canada, September 2010.
[34] J.
Rutkowska.
Klister
v0.3.
https://www.rootkit.com/newsread.php?newsid=51.
[35] A. Schuster. Searching for processes and threads in mi-
crosoft windows memory dumps. Digital Investigation,
3(Supplement-1):10–16, 2006.
[36] M. Smart, G. R. Malan, and F. Jahanian. Defeating tcp/ip
stack ﬁngerprinting. In Proceedings of the 9th conference on
USENIX Security Symposium, pages 17–17. USENIX Asso-
ciation, 2000.
[37] I. Sutherland, J. Evans, T. Tryfonas, and A. Blyth. Acquiring
volatile operating system data tools and techniques. SIGOPS
Operating System Review, 42(3):65–73, 2008.
[38] A. Walters.
The volatility framework:
memory
https://www.volatilesystems.com/default/volatility.
extraction
artifact
utility
Volatile
framework.