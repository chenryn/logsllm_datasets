position will remain unchanged.
andreas
jonathan
jeremy
james
supervisor
/
Group Manager
accountant
/
Team Manager
clerk
/
Team Manager
clerk
/
Employee
sign_cheque
prepare_cheque
dispatch_cheque
Figure 4. Extended role assignment
Of course, we could have also chosen to let the accoun-
tant/Team Manager role inherit the functionality of a clerk
to achieve the same effect, but we assume that no inheri-
tance mechanisms are present. Let us now see how this ex-
tended deﬁnition could be used to resolve some of the con-
ﬂicts identiﬁed earlier on. We ﬁrst have to provide a new
deﬁnition for role delegation. A possible extended func-
tional delegation rule could be:
and role delegation? According to our deﬁnition of sim-
ple static and dynamic Separation of Duty properties (Ta-
ble 2), we might still have conﬂicts for the above initial as-
signment. This depends on whether we declare two roles
to be mutually exclusive on basis of their functions or not.
If the functions of accountant and clerk are still exclusive
and simple static and dynamic constraints are based on this
property we will still obtain conﬂicts as in our earlier sce-
nario. However, the difference to our scenario is that user
andreas will not be able to delegate the supervisor function
to jonathan anymore, as their positions are different. Thus,
an operational Separation of Duty constraint will be difﬁcult
to break assuming that sensitive permissions such as sign-
ing a cheque are only combined with senior positions and
are thus less likely to be delegated.
11 Summary and Conclusion
We have demonstrated how to implement and enforce a
set of static and dynamic Separation of Duty constraints in a
role-based access control model, using a rule-based, declar-
ative approach. Depending on the type of RBAC model,
the initial conﬁguration, administrative actions and user be-
haviour, these can be broken. Extending the model with
simple delegation mechanisms is an additional source of
conﬂict.
Simulating a role-based model with integrated con-
straints and delegation mechanisms is only a ﬁrst step. We
intend to pursue further work on how to detect and resolve
these conﬂicts in a more formal model. According to our
deﬁnition of an extended role we might want to make a dis-
tinction between function and position hierarchies. This ex-
tended deﬁnition of a role and distinction between the func-
tion and position of an employee seems to be a ﬁrst step into
the right direction. However, apart from redeﬁning delega-
tion rules, well-known Separation of Duty constraints might
also have to be changed in order to cater for this extension.
We have recently ﬁnished work describing how we use
the speciﬁcation language Alloy and its model checking fa-
cilities to analyse the implications of the simultaneous in-
tegration of administrative role-based access control (AR-
BAC) extensions and constraints. What we need to investi-
gate now is the relationship between such a formal speciﬁ-
cation and a set of executable rules as presented here.
Def. 1 A user u1 can only delegate the function f1 of a role
(f1/P1) to another user u2, if:
12 Acknowledgements
(cid:2) u1 is assigned to an original role (f1/P1) and
(cid:2) u2 also holds Position P1
So what effect does this rule have with respect to the
problem of conﬂicts between Separation of Duty properties
The author is sponsored by the Engineering and Physics
Research Council (EPSRC) under award no. 99311141.
The comments from the reviewers and from Dr. J. D. Mof-
fett helped to clarify this paper. Further support was given
from the HISE research group under Prof. J. McDermid.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:10:28 UTC from IEEE Xplore.  Restrictions apply. 
[13] R. Sandhu, V. Bhamidipati, and Q. Munawer. The AR-
BAC97 model for role-based administration of roles.
ACM Transactions. Inf. Syst. Security, 2(1):105 – 135,
1999.
[14] R. Sandhu, E. Coyne, H. Feinstein, and C. Youman.
IEEE Computer,
Role-based access control models.
29(2):38–47, 1996.
[15] R. Sandhu, D. Ferraiolo, and R. Kuhn. The NIST
Model for Role-based Access Control: Towards a Uni-
ﬁed Standard. In 5th ACM RBAC, Berlin, Germany,
2000.
[16] A. Schaad and J. Moffett. The Incorporation of Con-
trol Principles into Access Control Policies (Extended
Abstract). In Hewlett Packard Policy Workshop, Bris-
tol, 2001.
[17] A. Schaad, J. Moffett, and J. Jacob. The access control
system of a European bank - a case study.
In ACM
Symposium on access control models and technologies
(SACMAT), Chantilly, VA, USA, 2001.
[18] R. Simon and M. Zurko. Separation of Duty in Role-
Based Environments. In Computer Security Founda-
tions Workshop X, Rockport, Massachusetts, 1997.
[19] M. Sloman and J. Moffett. Delegation of Authority. In
Integrated Network Management II, pages 595–606.
North Holland, 1991.
References
[1] G. Ahn. RCL 2000. Phd dissertation, George Mason
University, 2000.
Framework for Role-
[2] E. Barka and R. Sandhu.
Based Delegation Models.
In 16th Annual Com-
puter Security Applications Conference, New Orleans,
Louisiana, 2000.
[3] F. Chen and R. Sandhu. Constraints for RBAC. In 1st
ACM Workshop on Role-Based Access Control, pages
39–46, Gaithersburg, MD, 1995.
[4] D. Clark and D. Wilson. A Comparison of Commer-
cial and Military Security Policies.
In IEEE Com-
puter Society Press, editor, IEEE Symposium on Secu-
rity and Privacy, pages 184–194, Oakland, California,
1987.
[5] W. Clocksin and C. Mellish. Programming in Prolog.
Springer, 4th edition, 1996.
[6] N. Damianou, N. Dulay, E. Lupu, and M. Sloman.
The Ponder Policy Speciﬁcation Language. In Policies
for Distributed Systems and Networks, volume 1995,
pages 18–38, Bristol, 2001. Springer Lecture Notes in
Computer Science.
[7] R. Kuhn. Mutual exclusion of roles as a means of
implementing separation of duty in role-based access
control systems. In Proceedings of the second ACM
workshop on Role-based access control, pages 23–30,
1997.
[8] Z. Longhua, G. Ahn, and Chu. B. A Rule-based
Framework for Role-Based Delegation. In ACM SAC-
MAT, Chantilly, VA, USA, 2001.
[9] E. Lupu, D. Marriott, M. Sloman, and N. Yialelis. A
policy based role framework for access control. Pro-
ceedings of the ﬁrst ACM Workshop on Role-based ac-
cess control, pages 215–224, 1996.
[10] J. Moffett and M. Sloman. The Source of Authority for
Commercial Access Control. IEEE Computer, pages
59–69, 1988.
[11] M. Nash and K. Poland. Some Conundrums Concern-
ing Separation of Duty.
In IEEE Computer Society
Press, editor, IEEE Symposium on Security and Pri-
vacy, pages 201–209, Oakland, CA, 1990.
[12] R. Sandhu. Transaction Control Expressions for Sepa-
ration of Duties. In 4th Aerospace Computer Security
Conference, pages 282–286, Arizona, 1988.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:10:28 UTC from IEEE Xplore.  Restrictions apply. 
%---------------------------------------------------------------------------
%
%---------------------------------------------------------------------------
Delegation extensions
holds(User, Role):-
holds_o(User, Role).
holds(User, Role):-
holds_d(User, Role).
%General rule: UA = UAO union UAD
delegates(User1, Role1, User2):-
%inserts role delegation as fact
holds_o(User1, Role1),
not holds_o(User2, Role1),
asserta(holds_d(User2, Role1)).
%---------------------------------------------------------------------------
%
%---------------------------------------------------------------------------
Additional functions - Not model specific
%Collects all mutually exclusive roles for a user and
%make sure that the resulting list contains no doubles.
collect_mutex_roles(User, Nodoubleslist):-
call(holds(User, Role)),
call(mutex(Role, R)),
assertz(queue(Role)),
fail;
assertz(queue(end)),
collect(Total),
set(Total, Nodoubleslist).
collect(Total):-
retract(queue(List)),
!,
(List==end,!,Total=[];
append([List], Rest, Total), collect(Rest)).
%Collects for a given set of roles, the union of all permissions
collect_all_permissions([H|T], List_of_permissions):-
T=[], !,
assert(rolestack(H)),
assert(rolestack(end)),
retrieve(List_of_permissions);
assert(rolestack(H)),
collect_all_permissions(T, List_of_permissions).
retrieve(Total):-
retract(rolestack(Role)),
!,
(Role==end,!,Total=[];
setof(Perms, cando(Role, Perms), Permlist),
append(Permlist, Rest, Total), retrieve(Rest)).
%Union of two sets
union([], Ys, Ys).
union([X|Xs], Ys, Zs):-
member(X, Ys), !, union(Xs, Ys, Zs).
union([X|Xs], Ys,[X|Zs]):-union(Xs, Ys, Zs).
%Removes double entries in a set X and gives cleared set Y.
set(Xs, Ys):-
set_1(Xs, [], Ys).
set_1([], As, As). set_1([X|Xs], As, Ys):-
member(X, As), !, set_1(Xs, As, Ys).
set_1([X|Xs], As, Ys):-set_1(Xs, [X|As], Ys).
%Is X a subset of Y? Careful! subset(Y, X).
subset([], _). subset([X|Xs], Ys):-
member(X, Ys),
subset(Xs, Ys).
A Prolog Source Code
Conflict detection in a role-based delegation model
%--------------------------------------------------------------------
%
%--------------------------------------------------------------------
%Author:
%Date:
Andreas Schaad
01/06/2001
%Simple Simulation of the RBAC96 model and RBDM0 delegation extensions
%Integration of static and dynamic Separation of Duty properties
%based on mutually exclusive roles.
%Facts are represented as standard scenario of cheque processing
%--------------------------------------------------------------------
Pre-processor
%--------------------------------------------------------------------
%
%--------------------------------------------------------------------
:- dynamic [plays/2].
:- dynamic [was_executed_on/4].
:- dynamic [holds_d/2].
%Simulate role activation
%Simulate permission execution
%Simulate delegation
unknown_predicate_handler(_,fail).
%--------------------------------------------------------------------
Facts
%--------------------------------------------------------------------
%
%--------------------------------------------------------------------
user(andreas).
user(jonathan).
user(jeremy).
user(james).
%System Users
role(supervisor).
role(accountant).
role(clerk).
permission(sign_cheque).
permission(issue_cheque).
permission(prepare_cheque).
cheque(customer_cheque).
cheque(supplier_cheque).
holds_o(andreas, supervisor).
holds_o(jonathan, accountant).
holds_o(jonathan, clerk).
holds_o(jeremy, clerk).
holds_o(james, clerk).
%System Roles
%System Permissions
%System Objects
%Original User - Role assignemnt
cando(supervisor, sign_cheque).
cando(accountant, prepare_cheque).
cando(clerk, dispatch_cheque).
%Role - Permission assignment
%superior(Role1, Role2)
%Role Hierarchy
mutexclusive(supervisor, accountant).
mutexclusive(accountant, clerk).
%Mutualy exclusive roles
mutex(R1, R2):-
%Symmetry rule
mutexclusive(R1, R2);
mutexclusive(R2, R1).
%required permissions for processing a cheque
operation(process_cheque, [prepare_cheque, sign_cheque, dispatch_cheque]).
%----------------------------------------------------------------------
%
%----------------------------------------------------------------------
%Simple static SoD: A user must not be assigned to any two
%mutually exclusive roles r1,r2.
Separation of Duty constraints
staticsod(User, Role1, Role2):-
holds(User, Role1),
mutex(Role1, Role2),
holds(User, Role2).
%Simple dynamic SoD: A user can be assigned to any two
%mutually exclusive role r1,r2, but must not activate them at the same time.
dynamicsod(User, Role1, Role2):-
staticsod(User, Role1, Role2),
plays(User, Role1),
plays(User, Role2).
%Object-based Separation of Duties: User can hold and play
%mutually exclusive roles.
%He just may not act upon the same object through any of his mutex roles.
%Fact that object was accessed is recorded in
%was_executed_on(sign_cheque, cheque(customer_cheque), jonathan, supervisor).
objectsod(User, Object, Role1, Role2):-
was_executed_on(Permission1, Object, User, Role1),
was_executed_on(Permission2, Object, User, Role2),
Role1\=Role2,
mutex(Role1, Role2).
%Operational Separation of Duties: must not be in possession of all permissions
%required in a sensitive operation.
operationalsod(User, Operation, Processlist, Permissionlist):-
user(User),
operation(Operation, Processlist),
collect_mutex_roles(User, Mutexlist),
collect_all_permissions(Mutexlist, Permissionlist),
subset(Processlist, Permissionlist).
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:10:28 UTC from IEEE Xplore.  Restrictions apply.