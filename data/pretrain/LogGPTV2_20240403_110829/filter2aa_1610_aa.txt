Format
• Three parts in today’s presentation.
– Kernel auditing research.
– A sample of exploitable bugs.
– Kernel exploitation.
• Pause for questions at completion of
each section, but questions are
welcome throughout.
Part (i)
Kernel Auditing Research.
Kernel Auditing Overview
• Manual Open Source Kernel Security
Audit.
• FreeBSD, NetBSD, OpenBSD and
Linux operating systems.
• Auditing for three months; July to
September 2002.
TimeFrame by Operating
System
• NetBSD
– Less than one week.
• FreeBSD
– A week or less.
• OpenBSD
– A couple of days.
• Linux
– All free time.
Prior Work
• Dawson Engler and Stanford Bug
Checker.
– Many concurrency and synchronization
bugs uncovered.
• Linux Kernel Auditing Project?
Presentation Notes
• The use of the term ‘bug’ is always in
reference to a vulnerability unless
otherwise stated.
• At cessation of the auditing period, over
one hundred vulnerabilities (bugs) were
patched.
Kernel Security Mythology (1)
• Kernels are written by security experts
and programming gods.
– Therefore, having no [simplistic [security]]
bugs.
Kernel Security Mythology (2)
• Kernels never have simplistic [security]
bugs.
– Therefore, only security experts or
programming gods can find them.
Kernel Security Mythology (3)
• Kernels, if buggy, are difficult to exploit.
– Therefore, exploitation is probably only
theoretical in nature.
Research Conjectures
• Kernel Code is not ‘special’.
– It’s just another program.
• Language Implementation bugs are
present.
– Its using languages with known pitfalls.
• Kernel Programmers make mistakes.
– Like everyone else.
Auditing Methodology
• Audit only simple classes of bugs.
• Find entry points to audit.
– Kernel / User memory copies based in idea
on Dawson Englers bug checkers.
• Audit using bottom-up techniques.
• Targeted auditing evolved with
experience.
Auditing Experience
• System Calls are simple entry points.
• Device Drivers have simple entry points
by design.
– Unix; everything is a file.
• IOCTL’s are the swiss army knife of
system calls, increasing the attack
vector space.
Immediate Results
• First bug found within hours.
• True for all operating systems audited.
• First bug in [new] non familiar software
is arguably the hardest to find.
Observations (1)
• Evidence of varying degrees of code
quality and security bugs.
• Device Drivers a very large source of
bugs. *
• Bugs tend to exhibit signs of
propagation and clustering. *
• Identical bugs across platforms (2).
Research Bias
• Manual auditing is inherently biased.
• Dawson Englers work in automated bug
discovery states those prior (*)
observations, but provides something
that can be considered less biased than
manual auditing.
Observations (2)
NetBSD 1.6 
int 
i386_set_ldt(p, args, retval) 
        struct proc *p; void *args; register_t *retval; { 
[ skip ] 
        if (ua.start  8192 || (ua.start + ua.num) > 8192) 
OpenBSD 3.1 
int 
i386_set_ldt(p, args, retval) 
        struct proc *p; void *args; register_t *retval; { 
[ skip ] 
        if (ua.start  8192 || (ua.start + ua.num) > 8192) 
Evidence in contradiction to
Kernel Mythology (1)
• Kernels are [not] written by gods..
– Initial bugs were found in hours by all
kernels.
– Bugs were found in large quantities.  Ten
to thirty per day was not uncommon.
– It was assumed and stated that code was
secure, when in fact, it was often not.
Linux 2.4.18
/* 
* Copy bytes to user space. We allow for partial reads, which 
* means that the user application can request read less than 
* the full frame size. It is up to the application to issue 
* subsequent calls until entire frame is read. 
* 
* First things first, make sure we don't copy more than we 
* have - even if the application wants more. That would be 
* a big security embarassment! 
*/ 
if ((count + frame->seqRead_Index) > frame->seqRead_Length) 
count = frame->seqRead_Length - frame->seqRead_Index; 
/* 
* Copy requested amount of data to user space. We start 
* copying from the position where we last left it, which 
* will be zero for a new frame (not read before). 
*/ 
if (copy_to_user(buf, frame->data + frame->seqRead_Index, count)) { 
count = -EFAULT; 
goto read_done; 
} 
Linux 2.2.16
/* 
 * Copy an openpromio structure into kernel space from user space. 
 * This routine does error checking to make sure that all memory 
 * accesses are within bounds. A pointer to the allocated openpromio 
 * structure will be placed in "*opp_p". Return value is the length 
 * of the user supplied buffer. 
 */ 
static int copyin(struct openpromio *info, struct openpromio **opp_p) 
{ 
        int bufsize; 
[ skip ] 
        get_user_ret(bufsize, &info->oprom_size, -EFAULT); 
        if (bufsize == 0 || bufsize > OPROMMAXPARAM) 
                return -EINVAL; 
        if (!(*opp_p = kmalloc(sizeof(int) + bufsize + 1, GFP_KERNEL))) 
                return -ENOMEM; 
        memset(*opp_p, 0, sizeof(int) + bufsize + 1); 
        if (copy_from_user(&(*opp_p)->oprom_array, 
                           &info->oprom_array, bufsize)) { 
                kfree(*opp_p); 
Evidence in contradiction to
Kernel Mythology (2)
• Kernels do have simplistic bugs..
– Almost never was intensive code tracking
required.
– After ‘grepping’ for simple entry points,
bugs were identified in close proximity.
• No input validation present on occasion!
– Inline documentation shows non working
code in many places.
linux/ibcs2_stat.c
int 
ibcs2_sys_statfs(p, v, retval) 
        struct proc *p; 
        void *v; 
        register_t *retval; 
{ 
        struct ibcs2_sys_statfs_args /* { 
                syscallarg(char *) path; 
                syscallarg(struct ibcs2_statfs *) buf; 
                syscallarg(int) len; 
                syscallarg(int) fstype; 
        } */ *uap = v; 
[ skip ] 
        return cvt_statfs(sp, (caddr_t)SCARG(uap, buf), SCARG(uap, len)); 
static int 
cvt_statfs(sp, buf, len) 
        struct statfs *sp; caddr_t buf; int len; 
{ 
        struct ibcs2_statfs ssfs; 
        bzero(&ssfs, sizeof ssfs); 
[ skip ] 
        return copyout((caddr_t)&ssfs, buf, len); 
sparc64/dev/vgafb.c
int 
vgafb_ioctl(v, cmd, data, flags, p) 
        void *v; 
        u_long cmd; 
        caddr_t data; 
        int flags; 
        struct proc *p; 
{ 
        case WSDISPLAYIO_GETCMAP: 
                if (sc->sc_console == 0) 
                        return (EINVAL); 
                return vgafb_getcmap(sc, (struct wsdisplay_cmap *)data); 
int 
vgafb_getcmap(sc, cm) 
        struct vgafb_softc *sc; 
        struct wsdisplay_cmap *cm; 
{ 
        u_int index = cm->index; 
        u_int count = cm->count; 
        int error; 
        error = copyout(&sc->sc_cmap_red[index], cm->red, count); 
fs/binfmt_coff.c
        if (!pageable) { 
                /* 
                 * Read the file from disk... 
                 * 
                 * XXX: untested. 
                 */ 
                loff_t pos = data.scnptr; 
                status = do_brk(text.vaddr, text.size); 
                bprm->file->f_op->read(bprm->file, 
                         (char *)data.vaddr, data.scnptr, &pos); 
                status = do_brk(data.vaddr, data.size); 
                bprm->file->f_op->read(bprm->file, 
                         (char *)text.vaddr, text.scnptr, &pos); 
                status = 0; 
Evidence in contradiction to
Kernel Mythology (3)
• Kernels, if buggy, are [not] difficult to
exploit..
– Exploit to 100% reliably read kernel
memory from proc FS Linux is 38 lines.
– 37 lines for 100% reliable FreeBSD accept
system call exploit to read kernel memory.
– Stack overflow in Linux requires no offsets,
only assuming [correctly], that addresses
on stack are word aligned.
Attack Vectors
• The more code in a kernel, the more
vulnerabilities are likely to be present.
• Entry points that user land can control are
vectors of exploitation.
– Eg, Device Drivers, System Calls, File Systems.
• Less risk of security violations, with less
generic kernels.
– Core Kernel code resulted in relatively few bugs.
Vendor Response
• For this audit, OSS security response
very strong.
• All contact points responding
exceptionally fast.
– Theo de Raadt (OpenBSD) response in 3
minutes.
– Alan Cox (Linux) response in under 3
hours with status of bugs [some resolved
two years prior] and developer names.
[Pesonal] Open Source Bias
• I am [still] a big believer in Open Source
Software, so the responses received,
while true, are arguably somewhat
biased.
• It could be debated that a company
without a legal and marketing
department to protect, can only argue at
a source level.
More Bias!
$ grep -i    hack /usr/src/linux-2.4.19/CREDITS | wc -l 
    106 
$ grep -i  hacker /usr/src/linux-2.4.19/CREDITS | wc -l 
     57 
$ grep -i hacking /usr/src/linux-2.4.19/CREDITS | wc -l 
     25 
$ grep -i   hacks /usr/src/linux-2.4.19/CREDITS | wc -l 
     23 
Linux
• Alan Cox first contact point, and remained
personally involved and responsible for entire
duration.
• Patched the majority of software, although
attributing me with often small patches in
change logs.
• Solar Designer, responsible for 2.2 Linux
Kernels.
• Dave Miller later helping in the patch process
also.
Linux Success!
• RedHat initial advisory almost political in
nature, with references to the DMCA.
• RedHat Linux now regularly release kernel
advisories, which probably can be attributed
to the auditing work carried out last year.
• Audit [ironically considering LKAP] was
probably the most complete in Linux History.
FreeBSD
• FreeBSD has more formalized process
with Security Officer contact point.
• Dialogue, slightly longer to establish,
but very effective thereafter.
• Addressed standardizations issues,
resolving some security bugs very
effectively squashing future bugs.
FreeBSD success?
• FreeBSD released an [unexpected]
advisory on the accept() system call
bug.
• At the time, in a vulnerability
assessment company, a co-worker told
me they had to implement ‘my
vulnerability’. ☺
• Thanks FreeBSD!
NetBSD
• NetBSD dialogue was not lengthy, but
all issues were resolved after small
waiting period.
• These patches where applicable, then
quickly propagated to the OpenBSD
kernel source.
OpenBSD
• Theo de Raadt quickest response in
documented history?
• OpenBSD select advisory released
shortly after 10-15 problems were
reported.
• I did not audit or report select() bug, but
appears Neils Provos started kernel
auditing after my initial problem reports.
OpenBSD ChangeLogs
http://www.squish.net/pipermail/owc/2002-August/00380.html 
The OpenBSD weekly src changes [ending 2002-08-04] 
compat/ibcs2 
  ~ ibcs2_stat.c 
  > More possible int overflows found by Silvio Cesare. 
  > ibcs2_stat.c one OK by provos@ 
ibcs_stat.c
• Linux
• OpenBSD
• NetBSD
• FreeBSD
• FIXED
• FIXED
• FIXED
• 
Kernel Security Today
• Auditing always results in vulnerabilities
being found.
• Auditing and security is [or should be]
an on-going process.
• More bugs and bug classes are
certainly exploitable, than just those
described today.
Public Research Release
• Majority of technical results
disseminated four months ago at
Ruxcon.
• Some bugs (0day) released at that time.
• Bugs still present in kernels.
• Does anyone read conference material
besides us?
Pause for Audience
Participation!
Questions?
Part (ii)
A sample of exploitable kernel
bugs.
arch/i386/sys_machdep.c
#ifdef USER_LDT 
int 
i386_set_ldt(p, args, retval) 
        struct proc *p; 
        void *args; 
        register_t *retval; 
{ 
        if (ua.start  8192 || (ua.start + ua.num) > 8192) 
                return (EINVAL); 
arch/amiga/dev/grf_cl.c
int 
cl_getcmap(gfp, cmap) 
        struct grf_softc *gfp; 
        struct grf_colormap *cmap; 
{ 
        if (cmap->count == 0 || cmap->index >= 256) 
                return 0; 
        if (cmap->index + cmap->count > 256) 
                cmap->count = 256 - cmap->index; 
 [ skip ] 
        if (!(error = copyout(red + cmap->index, cmap->red, cmap->count)) 
            && !(error = copyout(green + cmap->index, cmap->green, cmap-
>count))            && !(error = copyout(blue + cmap->index, cmap->blue, cmap-
>count))) 
                return (0); 
arch/amiga/dev/view.c
int 
view_get_colormap (vu, ucm) 
        struct view_softc *vu; 
        colormap_t *ucm; 
{ 
        int error; 
        u_long *cme; 
        u_long *uep; 
        /* add one incase of zero, ick. */ 
        cme = malloc(sizeof (u_long)*(ucm->size + 1), M_IOCTLOPS, 
M_WAITOK); 
        uep = ucm->entry; 
        error = 0; 
        ucm->entry = cme;         /* set entry to out alloc. */ 
        if (vu->view == NULL || grf_get_colormap(vu->view, ucm)) 
                error = EINVAL; 
        else 
                error = copyout(cme, uep, sizeof(u_long) * ucm->size); 
        ucm->entry = uep;         /* set entry back to users. */ 
        free(cme, M_IOCTLOPS); 
        return(error); 
} 
hp300/hpux_machdep.c
int 
hpux_sys_getcontext(p, v, retval) 
        struct proc *p; 
        void *v; 
        register_t *retval; 
{ 
        struct hpux_sys_getcontext_args *uap = v; 
        const char *str; 
        int l, i, error = 0; 
        int len; 
[ skip ] 
        /* + 1 ... count the terminating \0. */ 
        l = strlen(str) + 1; 
        len = min(SCARG(uap, len), l); 
// since both l and uap->len (and len) are signed integers.. 
        if (len) 
                error = copyout(str, SCARG(uap, buf), len); 
ufs/lfs/lfs_syscalls.c
int 
lfs_bmapv(p, v, retval) 
        struct proc *p; 
        void *v; 
        register_t *retval; 