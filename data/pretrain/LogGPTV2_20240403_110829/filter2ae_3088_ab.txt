    ...
    8129: 5827.567871 5826.924805
    8130: 5828.284668 5827.641602
    8131: 5829.001465 5828.358398 对于最后一个索引来说，现在的差值已经非常大了，因此进行  int转换后，会产生一个oob索引。
(还要注意，这种“安全”计算也会有误差；只是误差没有被传播，换句话说，该误差与输入误差的大小成正比，因此，我们期望输入误差“越小越好”。)
我们确实可以看到，乘法算法的结果不会超过边界；但是，迭代算法则可能返回输入纹理边界之外的索引！
因此，我们在纹理分配结束后读取了整整一行像素——这很容易通过WebGL泄露给JavaScript代码。请大家继续关注即将发布的博客文章，届时，我们将使用这个漏洞以及SwiftShader中的另一个安全漏洞，通过JavaScript代码来控制GPU进程。
**Skia**
* * *
Skia是一个图形库，适用于Chrome、Firefox浏览器和Android平台等各种环境。在Web浏览器中，当使用[CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D
"CanvasRenderingContext2D")绘制canvas元素或绘制SVG图像时，就会用到该图形库。虽然在绘制其他HTML元素时也可以使用Skia，但是从安全角度来看，我们对canvas元素和SVG图像更感兴趣，因为它们能够更加直接地控制图形库绘制的对象。
Skia能够绘制的最复杂的对象（换句话说，从安全角度来看，我们最感兴趣的东西）是[路径](https://skia.org/user/api/SkPath_Reference
"路径")。路径是由诸如线之类的元素组成的对象，同时，也可以包括更复杂的曲线，特别是二次或三次[样条](https://en.wikipedia.org/wiki/Spline_\(mathematics)
"样条")。
由于在Skia中采用的是软件绘图算法，因此，其中很可能存在精度问题，并且，一旦出现这种安全漏洞，通常会导致越界写入问题。
要理解为什么会出现这些问题，先让我们假设在内存中有一个图像（可以将其视为一个缓冲区，大小=宽度x高度x色彩值长度）。通常，在绘制坐标为（x，y）且颜色值为c的像素时，需要确保该像素位于相应图像的空间内，特别是x和y需要满足下列条件：0
> 16);
    }
该函数用于对两个SkFixed数进行相乘，然而，使用该函数对负数进行相乘时会出现问题。下面，我们来举例说明，首先假设  
且  
，如果我们求这两个数的积的话，结果为  
。但是，由于SkFixedMul的工作方式，特别是由于使用右移操作将计算结果转换回SkFixed格式，我们最终得到的结果却是0xFFFFFFFF，这是  
的SkFixed表示形式。因此，我们最终得到的实际结果要远远大于预期值。
由于SkEdge::setLine使用这个乘法运算的结果来调整这里的初始线点的x坐标，因此，我们可以利用SkFixedMul的这个问题来产生额外的误差，最多为位像素的1/64，从而越过绘图区域的边界。
通过组合利用前两个问题，可以使一条线的x坐标变得足够小（小于-0.5），这样，当一个用小数表示的值通过舍入操作变为整数时，Skia将试图在x=-1的坐标处进行绘制，但是这些位置显然位于图像的范围之外。这样，就会出现如[原始漏洞报告](https://bugs.chromium.org/p/project-zero/issues/detail?id=1155
"原始漏洞报告")中所说的越界写漏洞。在Firefox浏览器中，我们可以成功利用该漏洞，为此，只需绘制一幅其坐标具有上述问题的SVG图像即可。
**结束语**
* * *
在本文中，我们为读者介绍了由于图形渲染库精度问题而引发的安全漏洞。其中，我们讲解了SwiftShader图形库和Skia图像库中的精度误差问题，同时，还解释了整数转换为浮点数，以及分数相乘时出现的误差问题。在本文的下篇中，我们将为读者进一步深入讲解其他方面的精度误差问题，以及它们所带来的安全隐患。