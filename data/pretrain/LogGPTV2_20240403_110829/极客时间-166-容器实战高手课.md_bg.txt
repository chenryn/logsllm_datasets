# llvm-objdump -D src/bpf_program.o    …         Disassembly of section tracepoint/syscalls/sys_enter_kill:         0000000000000000 :           0:   79 12 18 00 00 00 00 00         r2 = *(u64 *)(r1 + 24)           1:   55 02 10 00 09 00 00 00         if r2 != 9 goto +16            2:   79 11 10 00 00 00 00 00         r1 = *(u64 *)(r1 + 16)           3:   bf 12 00 00 00 00 00 00          r2 = r1           4:   c7 02 00 00 3f 00 00 00          r2 s>>= 63           5:   0f 21 00 00 00 00 00 00          r1 += r2           6:   af 21 00 00 00 00 00 00          r1 ^= r2           7:   7b 1a f8 ff 00 00 00 00            *(u64 *)(r10 - 8) = r1           8:   b7 01 00 00 01 00 00 00         r1 = 1           9:   63 1a f4 ff 00 00 00 00            *(u32 *)(r10 - 12) = r1          10: bf a2 00 00 00 00 00 00          r2 = r10          11: 07 02 00 00 f8 ff ff ff   r2 += -8          12: bf a3 00 00 00 00 00 00          r3 = r10          13: 07 03 00 00 f4 ff ff ff   r3 += -12          14: 18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     r1 = 0 ll          16: b7 04 00 00 01 00 00 00         r4 = 1          17: 85 00 00 00 02 00 00 00         call 2    …    
### 用readelf读到bpf_program.o中的ELF section信息。      
# llvm-readelf -sections src/bpf_program.o    There are 9 section headers, starting at offset 0x228:         Section Headers:      [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al    …      [ 3] tracepoint/syscalls/sys_enter_kill PROGBITS 0000000000000000 000040 0000a0 00  AX  0   0  8      [ 4] .reltracepoint/syscalls/sys_enter_kill REL 0000000000000000 000190 000010 10      8   3  8      [ 5] maps              PROGBITS        0000000000000000 0000e0 00001c 00  WA  0   0  4好了，看完了 eBPF 程序的内核态部分，我们再来看看它的用户态部分loader.c：     
# cat src/loader.c    #include "bpf_load.h"    #include     #include          int main(int argc, char **argv) {      // Load our newly compiled eBPF program      if (load_bpf_file("src/bpf_program.o") != 0) {        printf("The kernel didn't load the BPF program\n");        return -1;      }           printf("eBPF will listen to force kills for the next 30 seconds!\n");      sleep(30);           // map_fd is a global variable containing all eBPF map file descriptors      int fd = map_fd[0], val;      long key = -1, prev_key;           // Iterate over all keys in the map      while(bpf_map_get_next_key(fd, &prev_key, &key) == 0) {        printf("%ld was forcefully killed!\n", key);        prev_key = key;      }           return 0;    }这部分的代码其实也很简单，主要就是做了两件事：1.       通过执行 load_bpf_file() 函数，加载内核态代码生成的 eBPF    bytecode，也就是编译后得到的文件"src/bpf_program.o"。        2.       等待 30 秒钟后，从 BPF Maps 读取 key/value    对里的值。这里的值就是前面内核态的函数 bpf_prog()，在 kill()    系统调用的 tracepoint 上执行这个函数以后，写入到 BPF Maps    里的值。        至于读取 BPF Maps 的部分，就不需要太多的解释了，这里我们主要看一下load_bpf_file() 这个函数，load_bpf_file() 是 Linux 内核代码samples/bpf/bpf_load.c里封装的一个函数。这个函数可以读取 eBPF bytecode 中的信息，然后决定如何在内核中加载 BPFProgram，以及创建 BPFMaps。这里用到的都是bpf()slate-object="inline"这个系统调用，具体的代码你可以去看一下内核中bpf_load.cslate-object="inline"和bpf.cslate-object="inline"这两个文件。理解了用户态的 load.c这段代码后，我们最后编译一下，就生成了用户态的程序ebpf-kill-example：    
# make    clang -O2 -target bpf -c src/bpf_program.c -Ikernel-src/tools/testing/selftests/bpf -Ikernel-src/tools/lib/bpf -o src/bpf_program.o    clang -O2 -o src/ebpf-kill-example -lelf -Ikernel-src/samples/bpf -Ikernel-src/tools/lib -Ikernel-src/tools/perf -Ikernel-src/tools/include -Llib64 -lbpf \            kernel-src/samples/bpf/bpf_load.c -DHAVE_ATTR_TEST=0 src/loader.c         
# ls -l src/ebpf-kill-example    -rwxr-x--- 1 root root 23400 Jan 24 01:28 src/ebpf-kill-example你可以运行一下这个程序，如果在 30 秒以内有别的程序执行了`kill -9 `，那么在内核中的 eBPF代码就可以截获这个操作，然后通过 eBPF Maps把信息传递给用户态进程，并且把这个信息打印出来了。    
# LD_LIBRARY_PATH=lib64/:$LD_LIBRARY_PATH ./src/ebpf-kill-example &    [1] 1963961    
# eBPF will listen to force kills for the next 30 seconds!    
# kill -9 1    
#  1 was forcefully killed!重点小结今天我们一起学习了 eBPF，接下来我给你总结一下重点。eBPF 对早年的 BPF 技术做了增强之后，为 Linux 网络， Linux 安全以及Linux内核的调试和跟踪这三个领域提供了强大的扩展接口。虽然整个 eBPF 技术是很复杂的，不过对于用户编写 eBPF的程序，还是有一个固定的模式。eBPF 的程序都分为两部分，一是内核态的代码最后会被编译成 eBPFbytecode，二是用户态代码，它主要是负责加载 eBPF bytecode，并且通过 eBPFMaps 与内核态代码通讯。这里我们重点要掌握 eBPF程序里的三个要素，**eBPF Program Types，eBPF Maps 和 eBPFHelpers。** eBPF Program Types 可以定义函数在 eBPF 内核态的类型。eBPF Maps 定义了key/value 对的存储结构，搭建了 eBPF Program之间以及用户态和内核态之间的数据交换的桥梁。eBPF Helpers是内核事先定义好了接口函数，方便 eBPF程序调用这些函数。理解了这些概念后，你可以开始动手编写 eBPF 的程序了。不过，eBPF程序的调试并不方便，基本只能依靠 bpf_trace_printk()，同时也需要我们熟悉eBPF虚拟机的汇编指令。这些就需要你在实际的操作中，不断去积累经验了。思考题请你在ebpf-kill-example这个例子的基础上，做一下修改，让用户态程序也能把调用 kill()函数的进程所对应的进程号打印出来。欢迎你在留言区记录你的思考或疑问。如果这一讲让你有所收获，也欢迎转发给你的朋友，同事，跟他一起学习进步。
# 加餐06 \| BCC：入门eBPF的前端工具你好，我是程远。今天是我们专题加餐的最后一讲，明天就是春节了，我想给还在学习的你点个赞。这里我先给你拜个早年，祝愿你牛年工作顺利，健康如意！上一讲，我们学习了 eBPF 的基本概念，以及 eBPF编程的一个基本模型。在理解了这些概念之后，从理论上来说，你就能自己写出eBPF 的程序，对 Linux系统上的一些问题做跟踪和调试了。不过，从上一讲的例子里估计你也发现了，eBPF的程序从编译到运行还是有些复杂。为了方便我们用 eBPF 的程序跟踪和调试系统，社区有很多 eBPF的前端工具。在这些前端工具中，BCC 提供了最完整的工具集，以及用于 eBPF工具开发的 Python/Lua/C++ 的接口。那么今天我们就一起来看看，怎么使用 BCC这个 eBPF 的前端工具。如何使用 BCC 工具BCC  （BPFCompiler Collection）这个社区项目开始于 2015 年，差不多在内核中支持了eBPF 的特性之后，BCC这个项目就开始了。BCC 的目标就是提供一个工具链，用于编写、编译还有内核加载 eBPF程序，同时 BCC 也提供了大量的 eBPF 的工具程序，这些程序能够帮我们做Linux 的性能分析和跟踪调试。这里我们可以先尝试用几个 BCC 的工具，通过实际操作来了解一下BCC。 大部分 Linux 发行版本都有 BCC的软件包，你可以直接安装。比如我们可以在 Ubuntu 20.04上试试，用下面的命令安装 BCC：    
# apt install bpfcc-tools安装完 BCC 软件包之后，你在 Linux 系统上就会看到多了 100 多个 BCC的小工具 （在 Ubuntu 里，这些工具的名字后面都加了 bpfcc的后缀）：     