how this works. Consider malicious code, trying to disclose
the cookie information as part of a session hijacking attack:
1 var url = "http://host/image.jpg?=" + document.cookie;
2 var i = new Image(); i.src = url;
3 if (i.width > 50) { /* layout the page differently */ }
For this example, we label reading document.cookie as
conﬁdential input, and we label setting the src property of
an Image object (which results in an HTTP request to the
given URL) as public output. Reading the width property of
the image (also a DOM API call) is labeled as public input.
We discuss how this script is executed in FlowFox. First,
it is executed at the low level. Here, reading the cookie
results in a default value, e.g. the empty string. Then the
image is fetched – without leaking the actual cookie content
– and when reading the width of the image (resulting e.g. in
100), the value that was read is stored for reuse in the high
execution:
1 var url = "http://host/image.jpg?=" + document.cookie "";
2 var i = new Image(); i.src = url;
3 if (i.width > 50) { /* layout the page differently */ }
Next, the script is executed at the high level. In this level,
the setting of the src property is suppressed. The reading
of the width property is replaced by the reuse of the value
read at the low level.
1 var url = "http://host/image.jpg?=" + document.cookie;
2 var i = new Image(); i.src = url;
3 if (i.width100 > 50) { /* layout the page differently */ }
This example shows how, even though the script is exe-
cuted twice, each browser API call is performed only once.
As a consequence, if the original script was non-interferent,
the script executed under multi-execution behaves exactly
the same. In other words, SME is precise: the behavior of
secure programs is not modiﬁed by the enforcement mecha-
nism. This is relatively easy to see: if low outputs did not
depend on high inputs to start from, then replacing high
inputs with default values will not impact the low outputs.
We refer again to [18, §IV.A] for a formal proof.
3.4 Security Policies
In FlowFox every DOM API call is interpreted as an
output message to the DOM (the invocation with the actual
parameters), followed by an input from the DOM (the return
value).1 DOM events delivered to scripts are interpreted as
inputs. The policy deals with events by giving appropriate
labels to the DOM API calls that register handlers.
Hence a FlowFox policy must specify two things. First,
it assigns security levels to DOM API calls. Second, a de-
fault return value must be speciﬁed for each DOM API call
that could potentially be skipped by the SME enforcement
mechanism (see Rule 3 in Section 3.2).
: C1 →
Policy Rule. A policy rule has the form R[D]
l1, . . . , Cn → ln (cid:44)→ dv where R is a rule name, D is a DOM
API method name, the Ci are boolean expressions, the li
are security levels and dv is a JavaScript value.
Policy rules are evaluated in the context of a speciﬁc
invocation of the DOM API method D, and the boolean
expressions Ci are JavaScript expressions and can access
the receiver object (arg0) and arguments (argi) of that in-
vocation. Given such an invocation, a policy rule associates
1For API methods that return void, this can be optimized;
they can be considered just outputs, but we ignore that op-
timization in the discussion below.
751a level and a default value with the invocation as follows.
The default value is just the value dv. The conditions Ci
are evaluated from left to right. If Cj is the ﬁrst one that
evaluates to true, the level associated with the invocation
is lj. If none of them evaluate to true, the level associated
with the invocation is L.
Policies are speciﬁed as a sequence of policy rules, and
associate a level and default value with any given DOM
API invocation as follows. For an invocation of DOM API
method D, if there is a policy rule for D, that rule is used
to determine level and default value. If there is no rule in
the policy for D, that call is considered to have level L, with
default value undefined. The default value for invocations
classiﬁed at L is irrelevant, as the SME rules will never re-
quire a default value for such invocations.
Making API calls low by default, supports the writing of
short and simple policies. The empty policy (everything low)
corresponds to standard browser behavior. By selectively
making some API calls high, we can protect the information
returned by these calls. It can only ﬂow to calls that also
have been made high.
JavaScript properties that are part of the DOM API can
be considered to consist of a getter method and a setter
method. For simplicity, we provide some syntactic sugar for
setting policies on properties: for a property P (e.g. doc-
ument.cookie), a single policy rule speciﬁes a level l and
default value dv. The getter method then gets the level l
and default value dv and the setter method gets the level l
and the default value true – for a setter, the return value is a
boolean indicating whether the setter completed succesfully.
Examples.
Policy rule R1 speciﬁes that reading and writing of doc-
ument.cookie is classiﬁed as H, with default value  (the
empty String):
R1[document.cookie] : true → H (cid:44)→ 
As a second example, consider some methods of XML-
HttpRequest objects (abbreviated below as xhr). The as-
signed level depends on the origin to where the request is
sent:(cid:40)
R2[xhr.open] : sameorigin(arg1) → H (cid:44)→ true
R3[xhr.send] : sameorigin(arg0.origin) → H (cid:44)→ true
to the same origin as
is part of.
(cid:40)
with sameorigin() evaluating to true if
its ﬁrst ar-
the document
gument points
the script
the following policy
Finally,
ensures that keypress events are treated as high inputs:
R4[onkeypress] : true → H (cid:44)→ true
R5[addEventListener] : arg1 = ”keypress” → H (cid:44)→ true
4.
FlowFox is implemented on top of Mozilla Firefox 8.0.1
and consists of about ±1400 new lines of C/C++ code. We
discuss the most interesting aspects of this implementation.
4.1 SME-aware JavaScript Engine
IMPLEMENTATION
The SpiderMonkey software library is the JavaScript en-
gine of the Mozilla Firefox architecture.
It is written in
C/C++. The rationale behind our changes to SpiderMon-
key, is to allow JavaScript objects to operate (and poten-
tially behave divergently) on diﬀerent security levels.
#3
...
#4
...
#1
{L, window, Object}
{H, window, Object}
{L, Math, Object}
{H, Math, Object}
{L, a, Object}
{H, a, Object}
{L, b, Object}
{H, b, Numeric}
...
7
#2
{L, sin, Function}
{H, sin, Function}
...
#5
{L, c, Numeric}
...
Figure 2: Extended JSObjects with support for SME.
#3
...
#1
{L, window, Object}
{L, Math, Object}
{L, a, Object}
{L, b, Object}
...
7
#2
{L, sin, Function}
...
#5
{L, c, Numeric}
...
Figure 3: Extended JSObjects in a JSContext viewed
under security level L.
Every execution of JavaScript code happens in a speciﬁc
context, internally known as a JSContext. We augment the
JSContext data structure to contain the current security
level and a boolean variable to indicate if SME is enabled.
JSObjects in SpiderMonkey represent the regular JavaScript
objects living in a JSContext. Each property of a JSObject
has related meta information, contained in a Shape data
structure. Such a Shape is one of the key elements in our
implementation.
By extending Shapes with an extra ﬁeld for the security
level, we allow JSObjects to have the same property (with
a potentially diﬀerent value) on every security level. The
result of this modiﬁcation is a JSObject behaving diﬀerently,
depending on the security level of the overall JSContext.
We represent the augmented Shape by the triplet {security
level, property name, property value} as shown in Figure 2.
Only properties with shapes of the same security level as the
coordinating JSContext are considered when manipulating a
property of a JSObject. Figure 3 shows the visible JSObject
graph of Figure 2 when operating in a JSContext with a low
security level.
With these extensions in place, implementing the multi-
execution part is straightforward: we add a loop over all
available security levels (starting with the bottom element of
our lattice) around the code that is responsible for compiling
7521 process (methodName, args, curLevel) {
2
l, dv = policy(methodName, args);
if (curLevel == l) {
3
4
5
6
7
8
9
10
11
result = perform_call();
resultCache.store(result,methodName,args);
return result;
} else if (curLevel > l) {
result = resultCache.retrieve(methodName, args);
return result;
} else if (curLevel < l) {
return dv;
}
12
13 }
Figure 4: Implementation of the SME I/O rules.
and executing JavaScript code. Before each loop, we update
the associated security level of the JSContext.
4.2 Implementation of the SME I/O Rules
The next important aspect of our implementation is how
we intercept all DOM API calls, and enforce the SME I/O
rules on them.
To intercept DOM API calls, we proceed as follows. Every
DOM call from a JavaScript program to its corresponding
entry in the C/C++ implemented DOM, needs to convert
JavaScript values back and forth to their C/C++ counter-
parts. Within the Mozilla framework, the XPConnect layer
handles this task. The existence of this translation layer
enables us to easily intercept all the DOM API calls. We
instrumented this layer with code that processes each DOM
API call according to the SME I/O rules. We show pseudo
code in Figure 4.
For an intercepted invocation of a DOM API method
methodName with arguments args in the execution at level
curLevel, the processing of the intercepted invocation goes
as follows.
First (line 2) we consult the policy to determine the level
and default value associated with this invocation as detailed
in Section 3.4. Further processing depends on the relative
ordering of the level of the invocation (l) and the level of the
current execution (curLevel). If they are equal (lines 3-6),
we allow the call to proceed, and store the result in a cache
for later reuse in executions at higher levels. If the current
execution is at a higher level (lines 7-9), we retrieve the result
for this call from the result cache – the result is guaranteed
to exists because of the loop with its associated security
level starting at the bottom element and going upwards –
and reuse it in the execution at this level. The actual DOM
method is not called. Finally, if the level of the current
execution is below the level of the DOM API invocation,
then we do not perform the call but return the appropriate
default value (lines 10-11).
4.3 Event Handling
As discussed above, labels for events are speciﬁed in the
policy by labeling the methods/properties that register event
handlers. As a consequence, low events will be handled by
both the low and high execution (in respectively a low and
high context). High events will only be handled by the high
execution. This is the correct way to deal with events in
SME [10].
Hence, we have to execute an event handler in a JSCon-
text with the same security level as it was installed. We
new Image().src = "http://host/?=" + e.charCode;
1 function handler (e) {
2
3 }
4 $("target1").onkeypress = handler;
5 $("target2").addEventListener( "keypress", handler, false);
Figure 5: Example of an event handler leaking pri-
vate information.
augmented the event listener data structure with the SME
state and the security level. We adjust accordingly both the
security level and the SME state of the current JSContext
at the moment of execution of an event handler.
Take as an example the code in Figure 5 that tries to leak
the pressed key code. With the policy discussed in Section
3.4 that makes keypress a H event, the leak will be closed:
the handler will only be installed in the high execution, and
that execution will skip the image load that leaks the pressed
key.
5. EVALUATION
We evaluate our FlowFox prototype in three major ar-
eas: compatibility with major websites, security guarantees
oﬀered, and performance and memory overhead.
5.1 Compatibility
Since SME is precise [18, §IV.A], theory predicts that
FlowFox should not modify the behavior of the browser
for sites that comply with the policy. Moreover, SME can
sometimes ﬁx interferent executions by providing appropri-
ate default values to the low execution. We perform two
experiments to conﬁrm these hypotheses.
In a ﬁrst experiment, we measure what impact Flow-
Fox has for users on the visual appearance of websites. We
construct an automated crawler that instructs two Firefox
browser and one FlowFox browser to visit the Alexa top
500 websites2. FlowFox is conﬁgured with a simple policy
that makes reading document.cookie high. Most websites
are expected to comply with this policy. After loading of
the websites has completed, the crawler dumps a screenshot
of each of the three browsers to a bitmap. We then com-
pare these bitmaps in the following way. First, we compute
a mask that masks out each pixel in the bitmap that is dif-
ferent in the bitmaps obtained from the two regular Firefox
browsers. The mask covers the areas of the site that are
diﬀerent on each load (such as slideshow images, advertise-
ments, timestamps, and so forth). Masks are usually small.
Figure 6 shows the distribution of the relative sizes of the
unmasked area of the bitmaps: 100% means that the two
Firefox browsers rendered the page exactly the same; not a
single pixel on the screen is diﬀerent. The main reasons for
a larger mask – observed after manual inspection – were (i)
content shifts on the y-axis of the screen because of e.g. a
horizontal bar in one the two instances or (ii) varying screen-
ﬁlling images.
Next, we compute the diﬀerence between the FlowFox
generated bitmap and either of the two Firefox generated
bitmaps over the unmasked area. It does not matter which
Firefox instance we compare to, as their bitmaps are of
course equal for the unmasked area. Figure 7 shows the
2http://www.alexa.com/topsite
753y
c
n
e
u
q
e
r
F
60%
50%
40%
30%
20%
10%
0%
0
2
4
6
8
1
%
0
0
0
0
0
%
%
%
%
0
%
Figure 6: Distribution of the relative size of the un-
masked surface for the top-500 web sites.
y
c
n
e
u
q
e
r
F
80%
70%
60%
50%
40%
30%
20%
10%
0%
0
2
4
6
8
1
%
0
0
0