title:Browser Feature Usage on the Modern Web
author:Peter Snyder and
Lara Ansari and
Cynthia Bagier Taylor and
Chris Kanich
Browser Feature Usage on the Modern Web
Peter Snyder
Lara Ansari
Cynthia Taylor
Chris Kanich
{psnyde2,lansar2,cynthiat,ckanich}@uic.edu
Chicago, IL 60607
Department of Computer Science
University of Illinois at Chicago
ABSTRACT
Modern web browsers are incredibly complex, with millions
of lines of code and over one thousand JavaScript functions
and properties available to website authors. This work inves-
tigates how these browser features are used on the modern,
open web. We ﬁnd that JavaScript features diﬀer wildly in
popularity, with over 50% of provided features never used on
the web’s 10,000 most popular sites according to Alexa.
We also look at how popular ad and tracking blockers
change the features used by sites, and identify a set of approx-
imately 10% of features that are disproportionately blocked
(prevented from executing by these extensions at least 90%
of the time they are used). We additionally ﬁnd that in the
presence of these blockers, over 83% of available features
are executed on less than 1% of the most popular 10,000
websites.
We further measure other aspects of browser feature usage
on the web, including how many features websites use, how
the length of time a browser feature has been in the browser
relates to its usage on the web, and how many security
vulnerabilities have been associated with related browser
features.
1.
INTRODUCTION
The web is the world’s largest open application platform.
While initially developed for simple document delivery, it
has grown to become the most popular way of delivering
applications to users. Along with this growth in popularity
has been a growth in complexity, as the web has picked up
more capabilities over time.
This growth in complexity has been guided by both browser
vendors and web standards. Many of these new web capa-
bilities are provided through new JavaScript APIs (referred
to in this paper as features). These capabilities are orga-
nized into collections of related features which are published
as standards documents (in this paper, we refer to these
collections of APIs as standards).
To maximize compatibility between websites and web
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
IMC ’16, November 14–16, Santa Monica, CA, USA.
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4526-2/16/11. . . $15.00
DOI: http://dx.doi.org/10.1145/2987443.2987466
browsers, browser vendors rarely remove features from browsers.
Browser vendors aim to provide website authors with new
features without breaking sites that rely on older browser
features. The result is an ever growing set of features in the
browser.
Many web browser features have been controversial and
even actively opposed by privacy and free software activists
for imposing signiﬁcant costs on users, in the form of infor-
mation leakage or loss of control. The WebRTC [9] standard
has been criticized for revealing users’ IP addresses [46], and
protestors have literally taken to the streets [47] to oppose
the Encrypted Media Extensions [15] standard. This stan-
dard aims to give content owners much more control over
how their content is experienced within the browser. Such
features could be used to prevent users from exerting control
over their browsing experience.
Similarly, while some aspects of web complexity are under-
stood (such as the number of resources web sites request [11]),
other aspects of complexity are not, such as how much of the
available functionality in the browser gets used, by which
sites, how often, and for what purposes. Other related ques-
tions include whether recently introduced features are as
popular as older features, whether popular websites use dif-
ferent features than less popular sites, and how the use of
popular extensions, like those that block advertisements and
online tracking, impact which browser features are used.
This paper answers these questions by examining the use of
browser features on the web. We measure which browser fea-
tures are frequently used by site authors, and which browser
features are rarely used, by examining the JavaScript feature
usage of the ten thousand most popular sites on the web. We
ﬁnd, for example, that 50% of the JavaScript provided fea-
tures in the web browser are never used by the ten thousand
most popular websites.
We additionally measure the browser feature use in the
presence of popular ad and tracking blocking extensions, to
determine how they eﬀect browser feature use. We ﬁnd that
installing advertising and tracking blocking extensions not
only reduces the amount of JavaScript users execute when
browsing the web, but changes the kinds of features browsers
execute. We identify a set of browser features (approximately
10%) that are used by websites, but which ad and tracking
blockers prevent from executing more than 90% of the time.
Similarly, we ﬁnd that over 83% of features available in the
browser are executed on less than 1% of websites in the
presence of these popular extensions.
We have published data described in this work. This data
includes the JavaScript feature usage of the Alexa 10k in
97Browser vendors then expose unique hardware capabilities
like webcams, rotation sensors, vibration motors, or ambient
light sensors [30, 31, 33, 55] directly through JavaScript, re-
gardless of whether the executing device has such a capability.
Furthermore, as new features are added, the current best
practice is to roll them out directly to web developers as
time limited experiments, and allow them to move directly
from experimental features to standard features, available in
all browsers that adhere to the HTML living standard. [48].
Individual websites are also quite complex. Butkiewicz et
al. surveyed 2,000 random websites and found that loading
the base page for a URL required fetching a median of 40
objects, and that 50% of websites fetched at least 6 JavaScript
objects [11].
2.2 Ads and Tracking Blocking
Researchers have previously investigated how people use
ad blockers. Pujol et al. measured AdBlock usage in the
wild, discovering that while a signiﬁcant fraction of web users
use AdBlock, most users primarily use its ad blocking, and
not its privacy preserving, features [44].
User tracking is a more insidious aspect of the modern
web. Recent work by Radler found that users were much
less aware of cross-website tracking than they were about
collection of data by single sites such as Facebook and Google,
and that users who were aware of it had greater concerns
about unwanted access to private information than those who
weren’t aware [45]. Tracking users’ web browsing activity
across websites is largely unregulated, and a complex network
of mechanisms and businesses have sprung up to provide
services in this space [17]. Krishnamurthy and Willis found
that aggregation of user-related data is both growing and
becoming more concentrated, i.e. being conducted by a
smaller number of companies [32].
Traditionally, tracking was done via client-side cookies, giv-
ing users a measure of control over how much they are tracked
(i.e. they can always delete cookies). However, a wide variety
of non-cookie tracking measures have been developed that
take this control away from users, and these are what track-
ing blockers have been designed to prevent. These include
browser ﬁngerprinting [16], JavaScript ﬁngerprinting [37, 40],
Canvas ﬁngerprinting [38], clock skew ﬁngerprinting [29],
history sniﬃng [27], cross origin timing attacks [56], ever-
cookies [28], and Flash cookie respawning [7, 50]. A variety
of these tracking behaviors have been observed in widespread
use in the wild [3, 7, 36, 41, 42, 50, 51].
Especially relevant to our work is the use of JavaScript
APIs for tracking. While some APIs, such as Beacon [20], are
designed speciﬁcally for tracking, other APIs were designed
to support various other functionality and co-opted into
behaving as trackers [38, 60]. Balebako et al. evaluated tools
which purport to prevent tracking and found that blocking
add-ons were eﬀective [8].
3. DATA SOURCES
This work draws on several existing sets of data. This
section proceeds by detailing how we determined which web-
sites are popular and how often they are visited, how we
determined the current JavaScript-exposed feature set of web
browsers, what web standards those features belong to and
when they were introduced, how we determined the known
vulnerabilities in the web browser (and which browser feature
standard the vulnerability was associated with), and which
Figure 1: Feature families and lines of code in popular
browsers over time.
both a default browser conﬁguration and with ad and track-
ing blocking extensions in place, as well as the mappings of
JavaScript features to standards documents. The database
with these measurements, along with documentation describ-
ing the database’s schema, is available online [49].
2. BACKGROUND
In this section, we discuss the complexity of the modern
web browser, along with the use of ad and tracking blockers.
2.1 Modern Web Features
The functionality of modern web browsers has grown to
encompass countless use cases. While the core functionality
embodied by the combination of HTML, CSS, and JavaScript
is largely stable, over the past few years many features have
been added to enable for new use cases. Figure 1 shows the
number of standards available in modern browsers, using
data from W3C documents [61] and Can I Use [14]. Figure 1
also shows the total number of lines of code for Firefox and
Chrome [10]. One relevant point of note in the ﬁgure is that
in mid 2013, Google moved to the Blink rendering engine,
which entailed removing at least 8.8 million lines of code from
Chrome related to the formerly-used WebKit engine [34].
Vendors are very wary of removing features from the
browser, even if they are used by a very small fraction of all
websites [1, 2]. Because the web is evolving and competing
with native applications, browser vendors are incentivized to
continue adding new features to the web browser and not re-
move old features. This is exacerbated by browsers typically
having a uniﬁed code base across diﬀerent types of computers
including mobile devices, browser-based computers such as
Google Chromebooks, and traditional personal computers.
010203040051015Web StandardsMillion LOC2009201020112012201320142015ChromeFirefoxSafariIE98browser extensions we used as representative of common
browser modiﬁcations.
3.1 Alexa Website Rankings
The Alexa rankings are a well known ordering of websites
ranked by traﬃc. Typically, research which uses Alexa relies
on their ranked list of the worldwide top one million sites.
Alexa also provides other data about these sites. In addition
to a global ranking of each of these sites, there are local
rankings at country granularity, breakdowns of which sub-
sites (by fully qualiﬁed domain name) are most popular, and
a breakdown by page load and by unique visitor of how many
monthly visitors each site gets.
We used the 10,000 top ranked sites from Alexa’s list of
the one-million most popular sites, and which collectively
represent approximately one third of all web visits, as repre-
sentative of the web in general.
3.2 Web API Features
We deﬁne a feature as a browser capability that is acces-
sible through calling a JavaScript call or setting a property
on a JavaScript object.
We determined the set of JavaScript-exposed features by
reviewing the WebIDL deﬁnitions included in the Firefox
version 46.0.1 source code. WebIDL is a language that deﬁnes
the JavaScript features web browsers provided to web authors.
In the case of Firefox, these WebIDL ﬁles are included in the
browser source.
In the common case, Firefox’s WebIDL ﬁles deﬁne a map-
ping between a JavaScript accessible method or property
and the C++ code that implements the underlying function-
ality1. We examined each of the 757 WebIDL ﬁles in the
Firefox and extracted 1,392 relevant methods and properties
implemented in the browser.
3.3 Web API Standards
Web standards are documents deﬁning functionality that
web browser vendors should implement. They are generally
written and formalized by organizations like the W3C, though
occasionally standards organizations delegate responsibility
for writing standards to third parties, such as the Khronos
group who maintains the current WebGL standard.
Each standard contains one or more features, generally
designed to be used together. For example, the WebAudio
API [4] standard deﬁnes 52 JavaScript features that together
allow page authors to do programmatic sound synthesis.
There are also web standards that cover non-JavaScript
aspects of the browser (such as parsing rules, what tags and
attributes can be used in HTML documents, etc.). This
work focuses only on web standards that deﬁne JavaScript
exposed functionality.
We identiﬁed 74 standards implemented in Firefox. We
associated each of these to a standards document. We also
found 65 API endpoints implemented in Firefox that are not
found in any web standard document, which we associated
with a catch-all Non-Standard categorization.
1In addition to mapping JavaScript to C++ methods and
structures, WebIDL can also deﬁne JavaScript to JavaScript
methods, as well as intermediate structures that are not ex-
posed to the browser. In practice though, the primary role of
WebIDL in Firefox is to deﬁne a mapping between JavaScript
API endpoints and the underlying implementations, generally
in C++.
In the case of extremely large standards, we identify sub-
standards, which deﬁne a subset of related features intended
to be used together. For example, we treat the subsections
of the HTML standard that deﬁne the basic Canvas API, or
the WebSockets API, as their own standards.
Because these sub-standards have their own coherent pur-
pose, it is meaningful to discuss them independently of their
parent standards. Furthermore, many have been imple-
mented in browsers independent of the parent standard (i.e.
browser vendors added support for “websockets” long before
they implemented the full “HTML5” standard).
Some features appear in multiple web standards. For ex-
ample, the Node.prototype.insertBefore feature appears
in the Document Object Model (DOM) Level 1 Speciﬁca-
tion [6], Document Object Model (DOM) Level 2 Core Spec-
iﬁcation [23] and Document Object Model (DOM) Level 3
Core Speciﬁcation [24] standards. In such cases, we attribute
the feature to the earliest published standard.
3.4 Historical Firefox Builds
We determined when features were implemented in Firefox
by examining the 186 versions of Firefox that have been
released since 2004 and testing when each of the 1,392 features
ﬁrst appeared. We treat the release date of the earliest
version of Firefox that a feature appears in as the feature’s
“implementation date”.
Most standards do not have a single implementation date,
since it could take months or years for all features in a stan-
dard to be implemented in Firefox. We therefore treat the
introduction of a standard’s currently most popular feature
as the standard’s implementation date. For ties (especially
relevant when no feature in a standard is used), we default
to the earliest feature available.
3.5 CVEs
We collected information about browser vulnerabilities by
ﬁnding all Common Vulnerabilities and Exposures (CVEs) [54]
(security-relevant bugs discovered in software) related to Fire-
fox that have been documented in the last three years.
The CVE database lists 470 issues from the last three years
that mention Firefox. On manual inspection we found 14 of
these were not actually issues in Firefox, but issues in other
web-related software where Firefox was used to demonstrate
the vulnerability.
Of the remaining 456 CVEs, we were able to manually as-
sociate 111 CVEs with a speciﬁc web standard. For example,
CVE-2013-0763 [52] describes a potential remote execution
vulnerability introduced in Firefox’s implementation of the
WebGL [26] standard, and CVE-2014-1577 [53] documents
a potential information-disclosing bug related to Firefox’s
implementation of the Web Audio API standard.
We note that this work only considers CVEs associated
with JavaScript accessible features. It does not include CVEs
reporting vulnerabilities in other parts of the browser. For
example, if a CVE reported an vulnerability due to the
implementation of a SVG manipulating JavaScript function,
we included it in our analysis. If, however, the CVE dealt
with some other issue in Firefox’s SVG handling, such as
parsing the text of a SVG document, we did not consider it
in this work.
993.6 Blocking Extensions
Finally, this work pulls from commercial and crowd-sourced
browser extensions, which are popularly used to modify the
browser environment.