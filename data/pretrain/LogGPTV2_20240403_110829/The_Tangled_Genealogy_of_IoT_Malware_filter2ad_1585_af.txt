samples in pure clusters and only 14,204 samples in mixed clusters.
However, even in this case roughly one third of our dataset was
placed in majority clusters which erroneously contained samples
of different families.
We then performed an investigation on the resulting clusters
produced by the different feature group combinations. Here we
wanted to understand whether these clusters could be directly used
to group together samples that belong to the same variant or sub-
family and, if the answer is affirmative, what exactly was changed
between one version and the other. We first looked at the pure
clusters. We noticed that all medium-to-large size malware families
were broken down by our system in many pure clusters. If we con-
sider the combination that produced the best clustering results, i.e.,
the ELF and bytes combination, 20,027 Gafgyt samples were clus-
tered in 1,071 different pure clusters. Also, as many as 13,391 Mirai
The Tangled Genealogy of IoT Malware
ACSAC 2020, December 7–11, 2020, Austin, USA
Table 6: Clustering results: static and dynamic features.
Feature groups
o
r
P
A
D
I
s
g
n
i
r
t
s
r
u
o
i
v
a
h
e
b
k
r
o
w
t
e
n
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
F
L
E
✓
✓
✓
✓
✓
Clusters (# samples)
pure
single
majority
mixed
44,491
3,677
18,141
27,889
34,313
38,825
39,904
42,427
20,822
4,657
45
3,120
1,097
2,337
3,062
2,495
2,587
983
31,649
316
23,412
5,726
12,741
24,234
17,667
34,118
12,964
14,204
1,082
50,328
60,289
45,610
27,531
33,586
14,520
58,883
samples populated a total of 654 pure clusters. Initially, this would
make them good candidates for our sub-family investigation. As
expected, indeed different clusters often captured different common
features of the samples. For example, they separated dynamically
vs statically linked binaries, or those samples that successfully ex-
ecuted in our VM from those that did not (and therefore resulted
in an empty dynamic behavior profile). However, our goal was not
to distinguish Mirai samples that were dynamically or statically
linked, but rather identify its evolution over time. Unfortunately, the
resulting clusters did not capture our need to isolate sub-families
but rather samples that produced similar features (e.g., two samples
that immediately terminate with an error message are not neces-
sarily similar, despite the common behavior). During the manual
investigation of the clustering results, we also noticed that the cap-
tured runtime and network behavior of different variants of the
same family, when not missing, were often identical or so similar
that the clustering algorithm would hardly differentiate them. For
example, most variants of Mirai would follow the same high-level
process after the device is compromised: (i) reach out to the C&C
server, (ii) retrieve some target IP addresses to scan for worm-like
replication, (iii) launch scanning, (iv) receive DDoS attack target(s),
and (v) launch DDoS attack(s). This hinders the identification of
variants from such a trace. Additionally, considering finer-grained
features is likely to introduce overly specific clusters.
We also manually investigated those clusters that contained
samples with different AV labels. In particular, we looked at those
that had a predominant number of samples with a consistent AV
label, and a small number of samples with a different one (majority
clusters), e.g., (gafgyt: 33), (aidra:2). While intuitively this
could have been the result of errors in AV classifications, after
dozens of manual investigations we could not find a single mis-
labeled sample. Please remember that this does not mean there
were no errors in individual AV labels (we did find several of those),
but that by applying the majority voting provided by AVclass the
result (when a consensus was reached) was always correct. Errors
in the majority voting also existed, as explained in more details in
Section 4.2, but we needed a more precise clustering to successfully
isolate them from the noise.
Traditional clustering based on static and dynamic features was
insufficient to identify meaningful similarities and isolate variations
among sub-families. In particular, when applied to a large dataset,
the number of errors largely exceeded the ability to manually in-
vestigate and correct the results. Dynamic features (for example
those extracted from runtime behaviour or network traffic) failed
to accurately classify samples even into coarse-grained malware
families. On the other hand, we observed that static features (for
instance ELF features) would produce very compact micro clusters
sensitive to very fine-grained changes in the binary representation
of malware samples. While this was more successful to group to-
gether samples belonging to the same family, such over-sensitive
classification turned out to be inappropriate for the identification of
IoT malware variants. This contrasts with previous clustering and
lineage works e.g., on Windows [37], where malware programs
express more unique behaviors compared to the IoT counterpart
seen to date.
B LIST OF STATIC AND DYNAMIC FEATURES
Feature name: Description
bytes.common_bytes: List of the three most common bytes (with counter)
bytes.entropy: The entropy of the binary
bytes.header: First 16 bytes of the file
bytes.footer: Last 16 bytes of the file
bytes.longest_sequence.length: Longest sequence of the same byte (byte, offset, length)
bytes.min_entropy: Lowest entropy among 16K bytes blocks
bytes.max_entropy: Highest entropy among 16K bytes blocks
bytes.null_bytes: Number of null (0) bytes
bytes.printable: Number of printable bytes
bytes.rarest_bytes: List of the three rarest bytes (with counter)
bytes.unique_bytes: Number of unique bytes (0-255)
bytes.white_spaces: Number of white-spaces (0x32,\n,\r,\t) bytes
elf.anomalies.ehph_diff: Difference between segment virtual address and file offset
elf.anomalies.entrypoint.permission: Anomalous entrypoint: Permission
elf.anomalies.entrypoint.section: Anomalous entrypoint: Section
elf.anomalies.entrypoint.segment: Anomalous entrypoint: Segment
elf.anomalies.sections.cpp_prelink: Anomalous sections: C++ prelink section
elf.anomalies.sections.grub_module: Anomalous sections: Grub module
elf.anomalies.sections.headers: Anomalous sections: Wrong number of section headers
elf.anomalies.sections.high_entropy: Anomalous sections: High entropy
elf.anomalies.sections.kernel_object: Anomalous sections: Kernel object
elf.anomalies.sections.section_header_null: Anomalous sections: Null section headers
elf.anomalies.sections.shentsize_empty: Size of section header table’s entry null
elf.anomalies.sections.shnum_empty: Anomalous sections: Number of section headers empty
elf.anomalies.sections.shnum_pastfile: Anomalous sections: Section header table beyond file
elf.anomalies.sections.shoff_empty: Anomalous sections: Section header table offset empty
elf.anomalies.sections.shoff_pastfile: Anom. sec.: Section header table offset beyond file
elf.anomalies.sections.uncommon: Anomalous sections: Uncommon sections
elf.anomalies.sections.wrong_shstrndx: Anom. sec.: Wrong section name string table index
elf.anomalies.segments.error: Error in segments table
elf.anomalies.segments.headers: Anomalous segments: Wrong number of program headers
elf.anomalies.segments.high_entropy: Anomalous segments: High entropy
elf.anomalies.segments.high_mem: Segment memory size much bigger than physical size
elf.anomalies.segments.wx: Anomalous segments: W&X permission
elf.class: ELF file’s class
elf.comment: .comment section of the ELF, if present
elf.data: Data encoding of the-specific data
elf.debug: If the binary contains debug information (compiled with -g)
elf.dynfuncs: Dynamic symbols being used, of type FUNC in particular
elf.entrypoint: Binary entrypoint
elf.e_phentsize: Size in bytes of one entry in the program header table
elf.e_phnum: Number of entries in the program header table
elf.e_phoff: Program header table’s file offset in bytes
elf.e_shentsize: Size in bytes of one entry in the section header table
elf.e_shnum: Number of entries in the section header table
elf.e_shoff: Section header table’s file offset in bytes
elf.e_shstrndx: Index of section header table containing section names
elf.gdb: Error raised by gdb
elf.interpreter: ELF’s declared interpreter
elf.link: Statically or dynamically linked
elf.machine: Required architecture for the file
elf.malformed.entrypoint: Malformed ELF: Wrong entrypoint
elf.malformed.pastload: Malformed ELF: Beyond LOAD segment
elf.malformed.pastphnum: Malformed ELF: Beyond program header table
elf.malformed.pastsegment: Malformed ELF: Beyond segment
elf.needed: DT_NEEDED entries for dynamic ELF files
elf.note: .note.* sections of the ELF, if present
elf.nsections: Number of sections
elf.nsegments: Number of segments
elf.osabi: Operating system/ABI identification
ACSAC 2020, December 7–11, 2020, Austin, USA
Cozzi, et al.
elf.pyelftools: Exception raised by pyelftools, if any
elf.readelf: Error raised by readelf
elf.soname: PT_SONAME entry for dynamic ELF files
elf.stripped: Whether the binary has been stripped or not
elf.stripped_sections: Whether the sections table of the binary has been stripped or not
elf.type: Object file type
strings.ip: Potential IPs (v4 and v6) found in the binary
strings.path: Potential UNIX paths found in the binary
strings.url: Potential URLs found in the binary
idapro.average_bytes_func: Average size in bytes of a function
idapro.avg_basic_blocks: Average number of basic blocks respect to functions
idapro.avg_cyclomatic_complexity: Average cyclomatic complexity respect to functions
idapro.avg_loc: Average lines of code respect to functions
idapro.branch_instr: Number of branch instructions
idapro.bytes_func: Total size in bytes of the functions
idapro.call_instr: Number of call instructions
idapro.func_loc: Percentage of instructions belonging to functions
idapro.indirect_branch_instr: Number of indirect branch instructions
idapro.loc: Explored lines of code
idapro.max_basic_blocks: Max basic blocks
idapro.max_cyclomatic_complexity: Max cyclomatic complexity
idapro.nfuncs: Number of functions detected
idapro.percent_load_covered: Percentage of covered load segment
idapro.percent_text_covered: Percentage of covered text section
idapro.syscall_instr: Number of syscall instructions
behavior.user.argv0_rename: Procs renaming argv0
behavior.user.askroot: Wheter the execution got permission related errors
behavior.user.checkgid: If gid is checked
behavior.user.checkuid: If uid is checked
behavior.user.cmds: System cmds
behavior.user.compare: strcmp or memcmp comparison
behavior.user.cve: Possible CVEs exploited
behavior.user.dropped.create: Dropped files: Create
behavior.user.dropped.link: Dropped files: Link
behavior.user.dropped.linkfrom: Dropped files: Link from
behavior.user.dropped.modify: Dropped files: Modify
behavior.user.empty: Empty or no trace
behavior.user.errors.enosys: Errors from execution: Syscall not implemented
behavior.user.errors.execfault: Errors from execution: Execution fault
behavior.user.errors.illegal: Errors from execution: Illegal instruction
behavior.user.errors.missinglibs: Errors from execution: Missing library
behavior.user.errors.segfault: Errors from execution: Segmentation fault
behavior.user.errors.sigbus: Errors from execution: Bus error
behavior.user.errors.wronginterp: Errors from execution: Wrong interpreter
behavior.user.ioctl.fail: Ioctls: Fail
behavior.user.ioctl.success: Ioctls: Success
behavior.user.ioctl.total_no: Ioctls: Total number
behavior.user.libccalls.total_no: Libc calls from execution: Total number
behavior.user.libccalls.unique: Libc calls from execution: Unique
behavior.user.libccalls.unique_no: Libc calls from execution: Unique number
behavior.user.lineslost: Amount of trace lines not correctly parsed
behavior.user.persistence.create: Sample persistence: Create
behavior.user.persistence.link: Sample persistence: Link
behavior.user.persistence.linkfrom: Sample persistence: Link from
behavior.user.persistence.modify: Sample persistence: Modify
behavior.user.proc_rename: Procs renaming
behavior.user.procs: Number of processes spawned
behavior.user.ptrace_request: Ptrace requests
behavior.user.read_only: Files being read
behavior.user.rooterr.EACCES: EACCES type of permission related error
behavior.user.rooterr.EPERM: EPERM type of permission related error
behavior.user.sleep_max: Max sleep
behavior.user.syscalls.total_no: Syscalls from execution: Total number
behavior.user.syscalls.unique: Syscalls from execution: Unique
behavior.user.syscalls.unique_no: Syscalls from execution: Unique number
behavior.user.unlink: Unlink files
behavior.user.unlink_itself: Unlink itself
dynamic.error: Errors encountered during sandboxing
dynamic.stderr: Standard output during analysis
dynamic.stdout: Standard error during analysis
nettraffic.conn.avg_duration: Average duration of connections
nettraffic.conn.bytes: Number of bytes exchanged
nettraffic.conn.conns: Number of connections
nettraffic.conn.ips: List of unique IP addresses contacted
nettraffic.conn.pkts: Number of packets exchanged
nettraffic.conn.ports: List of unique destination ports
nettraffic.dns.qry_resp: List of unique DNS queries and their responses
nettraffic.dns.queried_domains: List of unique domains resolved through DNS
nettraffic.files.dropped_files_hash: List of unique hashes (SHA-256) of dropped files
nettraffic.files.dropped_files_mimetype: List of unique MIME types of dropped files
nettraffic.files.dropped_files_source_ips: List of unique IP addresses from which dropped files
have been downloaded
nettraffic.files.dropping_protos: List of unique protocols used to drop files
nettraffic.ssl.ssl_domains: List of unique domains contacted over SSL/TLS