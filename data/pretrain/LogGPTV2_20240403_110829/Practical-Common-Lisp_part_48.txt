另一个函数也会返回多值，以此类推。
了调用VALUES或VALUES-LIST的结果的函数将返回多值，并且其结果来自对这个函数的调用的
些子形式的值的语言构造都会“传递”多值，并返回由其子形式返回的所有值。这样，一个返回
值。返回多值的开始点是函数VALUES和VALUES-LIST。这些都是正规函数而非特殊操作符，因
个返回值，从而使这个形式可以正常工作。
似下面的形式了：
么每次你调用GETHASH时都必须解析这个列表来取得实际的值，无论你是否关心第二个返回值。
中找到的值和一个布尔值一在没有找到值时为NIL。如果它将这两个值返回到一个列表中，那
言之中。在处理多值时，最常使用的操作符是宏和函数，而非特殊操作符，但最后获取多重返回
多个值的能力。现在我将进一步讨论它的细节。不过，把这些内容放在关于特殊操作符的章节里
理解多重返回值的关键在于，返回多个值与返回一个列表是有本质不同的—如果一个形式
①少量有用的宏并不会传递它们所求值形式的其他返回值。特别的是PROG1宏，它像PROGN那样求值一组形式并返
但是当一个形式被放在值的位置上求值时，只有主值会被使用，这也就是之前的加法形式能
多值返回的机制和向函数传递参数的机制一样，都是具体实现相关的。几乎所有可以返回一
(values-listx)=(apply #values x)
使用多重返回值包括两个方面—返回多个值以及获取那些返回多值的形式所返回的非主
CommonLisp的另一个特性是我在第11章里讨论GETHASH时提到过的，即单一形式可以返回
不总是对多值透明的，在特定的子形式上只返回其主值。
MULTIPLB-VALUE-PROG1那样的行为，这多少算是一个缺点，但这两个宏其实都不太常用。OR和COND宏也并
回第一个形式的值，只返回该形式的主值。同样，PROG2返回其第二个子形式的值，也只返回主值。特殊操作符
多值
www.TopSage.com
---
## Page 241
将EVAL-WHEN视为巫师级别的话题。但其实理解EVAL-WHEN的唯一前提，只是理解两个函数LOAD
20.6
作为可SETF的位置来使用。例如：
些函数应当开始返回一个列表而不是多值了。
的多个值收集到一个列表中。换句话说，它是VALUES-LIST的逆操作。
的作用下被求值。这样：
其中 values-form被求值，它返回的多个值被绑定到那些变量上。然后那些body-form在绑定
VALUE-BIND宏就是最常用的用于接收多重返回值的操作符。它的模板看起来像这样：
你希望多个值分别保存在不同的变量里，然后再对这些变量作处理。第11章里提到的MULTIPLE-
传递其余子形式返回的所有的值。
只能看到并传递那些传给它的主值，而MULTIPLE-VALUE-CALL则为它第一个子形式返回的函数
多个值的机制。MULTIPLE-VALUE-CALL和FUNCALL相似，除了FUNCALL是个正规函数并且因此
够以你期待的方式运行的原因。特殊操作符MULTIPLE-VALUE-CALL提供了访问一个形式返回的
最后，如果你想要将一个形式返回的多个值一次性赋值到已有变量上，那么可以将VALUES
224
为了写出某些特定类型的宏，你必须理解EVAL-WHEN操作符。出于一些原因，Lisp书籍通常
不过，如果你发现自己使用了很多的MULTIPLE-VALUE-LIST，这也许是一个信号，表明某
CL-USER> (multiple-value-list (values 1 2))
另一个宏MULTIPLE-VALUE-LIST甚至更简单—
(multiple-value-bind (x y) (values 1 2)
(multiple-value-bind (variable*) values-form
不过，你一般不需要简单地将一个函数返回的所有值都传给另一个函数。更常见的用法是，
23/34
CL-USER>
23/34
CL-USER>
√
CL-USER> (values-list (multiple-value-list (values 1 2)))
(funcall #'+ (values 1 2) (values 3 4))
（+ xy)）
body-form*)
EVAL-WHEN
第 20章特殊操作符
(setf (values *x* *y*)
*x*
→3
www.TopSage.com
）(floor (/ 57 34)))
一它接受单一的形式，求值它，然后将得到
→4
---
## Page 242
现在一个顶层PROGN中的形式也将作为顶层形式来编译，因为PROGN本身并不做任何事一
样，所有直接出现在一个源代码文件顶层的形式都将作为顶层形式来编译。类似地，任何直接出
式的区别。简单地说，一个顶层形式就是一些编译之后可以在FASL文件加载时运行的代码。这
下COMPILE-FILE，它也称为文件编译器，用来编译一个文件。
的几个EVAL-WHEN形式，同样的代码每种情形各一个。为了解释三种情形的含义，我需要解释一
个操作符允许你控制特定的代码在何时被求值。EVAL-WHEN形式的模板看起来像这样：
Common Lisp从MacLisp中借鉴了EVAL-WHEN，从而避免了类似异常情况的发生。顾名思义，这
在Common Lisp标准之前的Lisp版本里，文件编译器简单地在编译后进一步求值某些形式。
致的行为。
IN-PACKAGE和DEFMACRO等形式，以保持（load“foo.lisp")和(load"foo.fasl")具有一
这些形式或它们的编译后等价物才会被求值。尽管如此，COMPILE-FILE必须求值一些诸如
续代码使用的宏。
后续形式的方式。?类似地，一个较早出现在文件中的DEFMACRO形式可以定义一个可被文件中后
求值后续形式的行为。例如，求值一个IN-PACKAGE形式将改变*PACKAGE*的值，这将影响读取
"foo，fasl")在本质上是等价的。
代码文件编译成FASL文件，后者随后可以被LoAD加载，因此（load“foo.lisp"）和（load
LOAD的任务是加载一个文件并求值它包括的所有顶层形式。COMPILE-FILE的任务则是将一个源
重要，例如你将在第24章和第31章里编写的一些宏。
和COMPILE-FILE是如何交互的。理解EVAL-WHEN对于你开始编写特定类型的更加专业的宏非常
我在前面的章节已经简要提过LOAD和COMPILE-FILE之间的关系，这里有必要再说一次。
②在某些实现中，你或许可以正确求值一个在函数体中使用了未定义宏的DEFUN定义，只要在函数实际被调用之前
① 加载一个带有IN-PACKAGE形式的文件，在LOAD返回以后看不到*PACKAGE*值的改变，这是因为LOAD在对该变
为了解释COMPILE-FILE是如何编译EVAL-WHEN形式的，先要介绍编译顶层形式和非顶层形
那么诸如IN-PACKAGE和DEFMACRO这样的宏在被COMPILE-FILE处理时是怎样工作的呢？
另一方面，COMPILE-FILE通常在编译时不求值文件中的形式。只有当FASL文件被加载时
存在三种可能的情形：:compile-toplevel、
(eval-when (situation*)
由于LOAD在读取每一个形式以后立即求值，因而求值文件中靠前面的形式就会影响读取和
行的。因此一般来说，宏定义必须在它们被使用前被求值。
定义好该宏即可。但仅当从源代码加载这些定义时，它们才可以正常工作，而在通过COMPILE-FILB编译时是不
*READTABLE★，该变量我尚未谈及。
任何对*PACRAGE*的赋值都将是新的绑定，而旧的绑定将在LOAD返回时恢复。它还以同样方式绑定了变量
量做任何改变之前绑定了它的当前值。换句话说，一些等价于下面这个LET形式的结构封装了LOAD中其余的代
(let ((*package* *package*))
body-form*)
?
www.TopSage.com
、:load-toplevel和:execute，并且你指
20.6EVAL-WHEN
一它只
225
---
## Page 243
所用到的任何函数的DEFUN都封装在一个带有:compile-toplevel的EVAL-WHEN里，那么在宏的
文件的后续部分所使用。但是DEFUN正常情况下并不会在编译期产生函数定义。但如果你在定义
型的宏。
个文件开始处的定义可以影响同一个文件内其他定义所生成的代码。你将在第24章里编写这种类
宏时，这些信息将被同一个文件中的其他宏形式的展开式所用到。通常这些都是定义性的宏：一
有:load-toplevel，而在加载源代码时设置是因为有:execute。
编译期和源代码加载期都产生效果：
中的在编译期被求值的EVAL-WHEN)，要么在：eXeCUte存在时被当作PROGN来对待，要么被忽略。
件中的顶层EVAL-WHEN，以及出现在带有：COmpile-tOpleVel情形的顶层EVAL-WHEN的子形式
样被编译，要么被忽略。类似地，一个被求值的EVAL-WHEN（包括那些被LOAD加载的源代码文
EVAL-WHEN的情形列表中，那么编译器将会忽略它。
在:load-toplevel时，它将把那些子形式作为顶层形式来编译。如果这两个情形都不在顶层
制其含义。当存在:compile-toplevel时，文件编译器将在编译期求值其子形式。当存
求值，所有这些条件将按照列在其情形列表中的情形组合来决定。
的，但一个EVAL-WHEN的语义取决于它是作为顶层形式还是非顶层形式来编译的，或是简单地被
展开函数运行时这些定义就可以使用了。你很可能想再加上:load-toplevel和:execute，因为
放在同一个文件里。DEFMACRO已经在其展开式里包含了一个EVAL-WHEN，因此宏定义可以立即被
到函数被调用时才会运行。大多数形式在作为顶层和非顶层形式来编译时产生的结果都是相同
函数名相关联的代码将会在加载FASL时运行—但是函数体中的形式不是顶层形式，它们要等
宏形式的展开式将作为顶层形式来编译。
宏或符号宏之后，编译后的代码中就不再有MACROLET或SYMBOL-MACROLET了。最后，一个顶层
MACROLET或SYMBOL-MACROLET中的形式将作为顶层形式来编译，因为在编译器展开了这些局部
是把其子形式组织在一起，然后它们会在FASL被加载时运行。?类似地，直接出现在一个
一个宏的文件中使用这个宏，就需要确保被用到的宏和该宏所用到的函数都有定义。如果你把该宏
你会经常在两种情况下使用EVAL-WHEN。一种是你想编写一个需要在编译期保存一些信息的
这样，一个诸如IN-PACKAGE这样的宏可以通过展开成类似下面这样的形式，来确保同时在
这样，一个出现在源代码文件顶层的DEFUN就是一个顶层形式，那些定义了函数并且将其与
226
① 相反，一个顶层LET中的子形式并不会作为顶层形式来编译，因为它们不会在FASL加载时直接运行。它们将会运
另一
*PACKAGE*在编译期设置是因为有:compile-toplevel情形，在加载FASL时设置是因为
当一个EVAL-WHEN作为非顶层形式来编译时，它要么在：eXeCUte情形被指定时像PROGN那
(eval-when (:compile-toplevel :load-toplevel :execute)
PROGN来对待，但其实不是这样的，出现在LBT中的子形式不会作为顶层形式来对待。
行，但是在由LBT所建立的绑定和运行期上下文中运行的。理论上来说，一个不绑定任何变量的LET将会被当作
第20章
特殊操作符
www.TopSage.com
---
## Page 244
程序。
Common Lisp的包系统来控制名字空间，这样你才可以写出彼此并存而没有名字冲突的库和应用
不是你需要经常干的事情。
区别在于，symbols-list是在运行期求值的，被绑定的变量名可以动态地确定。要我说，这并
列表的形式。每个符号被动态地绑定到对应的值上，然后求值那些body-form。PROGv和LET的
域变量的语言实现嵌入式解释器尤其有用。其基本框架如下所示：
译时发生的。在未编译的代码中，LOAD-TIME-VALUE在其每次被求值时都会求值其子形式。
这可能是在显式使用COMPILE编译一个函数，或是在求值代码的过程中具体实现进行了隐式的编
可以简化成这样：
含有LOAD-TIME-VALUE形式的代码指向该值。换句话说，下面的写法：
LOAD-TIME-VALUE形式的代码时，它会安排在加载FASL时只求值其第一个子形式一次，然后让
遇到刚好可以用上它们的场合时，就知道该怎么用了。
解释它们能干什么还费劲。因此我只告诉你它们能干什么，让你知道它们的存在。日后当你偶尔
码，
的一部分，它们用来与编译器沟通而对代码的含义没有影响，但可能有助于编译器生成更好的代
访问以其他任何方式都无法访问到的语言的底层部分。LOCALLY和THE是CommonLisp声明系统
20.7其他特殊操作符
在文件被编译加载或者从源代码不编译而直接加载以后，该宏也需要这些函数。
这就是特殊操作符的所有内容。在下一章里，我将回到更加实用的话题，展示如何使用
顾名思义，LOAD-TIME-VALUE用来创建一个在加载期决定的值。当文件编译器编译含有
①唯一一个对程序语义有影响的声明是第6章里提到的SPECIAL声明。
最后，PROGV可以为变量创建其名字在运行期才确定的新的动态绑定。这对于支持动态作用
另外两个LOAD-TIME-VALUE和PROGV都很少会用到，而且解释为什么会想要使用它们，比
，比如更快更清晰的错误信息。“我将在第32章里简要地讨论有关声明的内容。
在没有被COMPILE-FILE处理过的代码中，LOAD-TIME-VALUE仅在代码被编译时求值一次，
其余的4个特殊操作符分别是LOCALLY、THE、LOAD-TIME-VALUE和PROGV，它们都允许你
(progv symbols-list values-list
(defun when-loaded () (load-time-value (get-universal-time)))
(defun when-loaded () *loaded-at*)
(defvar *loaded-at* (get-universal-time))
body-form*)
www.TopSage.com
20.7
其他特殊操作符
227
---
## Page 245
也称为当前包。
函数都接受一个字符串和一个可选的包。当包未指定时，包参数默认为全局变量*PACKAGE*的值，
过函数FIND-PACKAGE找到对应的包。
查找表稍微灵活一些，但这对读者来说通常意义不大。每个包也都有一个名字，该名字可用来通
像成一个字符串和符号的映射表。如同你在下一节里将会看到的，实际的映射过程比一个简单的
细节。现在是时候从更近的角度来看看这个过程中究竟发生什么了。
21.1
文本名字时，那么就需要让读取器分别创建不同的符号来表示它们。
号来表示每个名字。同样地，如果你希望两个名字被视作是不同的，甚至在它们刚好具有相同的
这个问题上：如果你希望相同的名字可以被求值器同等看待，那么需要确保读取器使用相同的符
它的公共API，你会在自己的程序中用到它们。
相同的文本表示。同时，你希望这个库所定义的特定名字就是被用来访问的一
名字。你更希望这个库中的大多数名字和你程序中的名字是彼此无关的，哪怕是它们碰巧使用了
名字与你自己的程序中所使用的名字相冲突，而要知道那个库中的每一个函数、变量、类和宏的
字方面的问题：如何避免彼此无关的人开发的代码出现名字冲突。
对于多种编程任务都是有用的。“不过，这并不是本章的主题。在本章里，我将讨论一个处理名
读取器用来访问包中的名字-符号映射的两个关键函数是FIND-SYMBOL和INTERN。这两个
我先来描述读取器所理解的名字的语法，以及该语法和包之间的关系。目前，你可以将包想
①依赖于符号数据类型的编程，被恰如其名地称为符号计算。它和基于数值的编程正好相反。一个所有程序员都应
在CommonLisp中，这一名字空间问题最后归结到，如何控制读取器将文本名称转化成符号
举个例子，假设你正在编写一个程序并决定在其中使用一个第三方库。你不想为了避免这些
在第4章里，我简单讨论了Lisp读取器是如何将名字转化成符号的，但我刻意忽略了大部分
读取器是如何使用包的
编写大型程序：包和符号
www.TopSage.com
大家网
一这些名字构成