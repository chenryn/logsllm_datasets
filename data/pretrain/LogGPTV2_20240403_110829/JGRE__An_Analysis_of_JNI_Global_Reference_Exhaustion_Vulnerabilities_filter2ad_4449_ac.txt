registerReceiver
bindService
Required Permission (Protection Level) in AOSP 6.0.1
ACCESS FINE LOCATION (dangerous)
USE SIP (dangerous)
USE SIP (dangerous)
-
-
-
-
-
-
-
-
-
-
BLUETOOTH (normal)
-
-
-
-
-
WAKE LOCK (normal)
-
-
-
-
-
GET PACKAGE SIZE (normal)
READ PHONE STATE (dangerous)
READ PHONE STATE (dangerous)
READ PHONE STATE (dangerous)
-
-
-
-
-
-
-
-
-
CHANGE NETWORK STATE (normal)
CHANGE NETWORK STATE (normal)
ACCESS NETWORK STATE (normal)
-
-
-
VULNERABLE IPC INTERFACES PROTECTED BY SERVICE HELPER
TABLE II
CLASSES
Service Name Service Helper Class Vulnerable IPC Interface
clipboard
accessibility
launcherapps
tv input
ethernet
wiﬁ
ClipboardManager
AccessibilityManager
LauncherApps
TvInputManager
EthernetManager
WiﬁManager
addPrimaryClipChangedListener
addClient
addOnAppsChangedListener
registerCallback
addListener
acquireWiﬁLock
acquireMulticastLock
addGpsMeasurementsListener
addGpsNavigationMessageListener
location
LocationManager
third-party app calls WiﬁManager.acquire() multiple times, the
WiﬁManager examines whether the total number of requests
exceeds the maximum lock number that an app can acquire.
If the number exceeds the threshold, WiﬁManager will release
432
the lock immediately. As seen in the comments in AOSP, this
mechanism aims to defend against DoS attacks 2.
Code-Snippet 2 shows a piece of malicious code that can
directly communicate with WiﬁService through IPC without
going through the helper class. After we reported this type
of attacks to Google, Android Security Team conﬁrmed this
vulnerability as a “resource exhaustion issue”. The other seven
methods also constrain the number of JNI entries and can be
totally circumvented. Android Security Team classiﬁes them
into the same cluster of “resource exhaustion issues” after we
submitted the corresponding bug reports.
2) Implementation Flaws on Per Process Constraint: An
alternative defense approach is to limit the request number
per process at the system service side. We ﬁnd 4 interfaces
2The comments explicitly say “prevent apps from creating a ridiculous
number of locks and crashing the system by overﬂowing the global ref table”
Code-Snippet 1 Protection code in WiﬁManager.java.
/* Maximum number of active locks we allow. This
* limit was added to prevent apps from creating a
* ridiculous number of locks and crashing the system
* by overflowing the global ref table.
*/
private static final int MAX_ACTIVE_LOCKS=50;
public void acquire(){
mService.acquireWifiLock(mBinder, mTag);
if (mActiveLockCount >= MAX_ACTIVE_LOCKS){
mService.releaseWifiLock(mBinder)
throw new Exception("Exceeded
maximum number of wifi locks");
}
...
}
Code-Snippet 2 Sample attack code on wiﬁ service.
IWifiManager wifiService = IWifiManager.Stub
.asInterface(ServiceManager.getService("wifi"));
for (int i = 0; i = MAX_PACKAGE_NOTIFICATIONS){
Slog.e(TAG, "Package has already posted"
+ count + " toasts. Not showing more");
return;
}
}
mToastQueue.add(record);
...
}
The
limits
the
number
protection
on
interface
NotiﬁcationManagerSer-
of
vice.enqueueToast()
that can be enqueued by each process, except
Toasts
the
for the system toasts. As shown in Code-Snippet 3,
the ﬁrst
NotiﬁcationManagerService.enqueueToast()
parameter as caller’s package name, and it considers the
toast as a system toast if this parameter is set to “android”.
However, an attacker can bypass this restriction by directly
invoking INotiﬁcationManager.enqueueToast() method and
passing “android” as the ﬁrst parameter instead of its own
takes
IPC INTERFACES PROTECTED BY PER PROCESS CONSTRAINT
TABLE III
Service Name
notiﬁcation
display
input
IPC Interface
enqueueToast
registerCallback
registerInputDevicesChangedListener
registerTabletModeChangedListener
Protected?
No
Yes
Yes
Yes
433
package name to this method. Thus, a malicious app with
zero permission can enqueue enough toasts to eventually
exceed the limit of JGR table. We reported this vulnerability
to Android Security Team and received a conﬁrmed Bug ID.
D. Vulnerabilities in Apps
In addition to system services, we also study the vulnerable
apps that may crash under the JGR DoS attacks. Among
88 prebuilt core apps, We ﬁnd three vulnerabilities in two
apps, namely, Bluetooth and PicoTts, as shown in Table IV.
For instance, PicoTts’s PicoService inherits from the an-
droid.speech.tts.TextToSpeechService interface, which is a base
service class that provides default implementation of IText-
ToSpeechService IPC methods. The setCallback() method in
the default implementation increases JGR entry number when-
ever it is called, and all the JGR entries can be revoked only
when the requesting third-party app exits. Thus, a malicious
app can abuse the usage of this method to crash the app. Note
all apps that extend android.speech.tts.TextToSpeechService
and open IPC interface to third-party apps are vulnerable to
JGRE attacks, including “Google Text-to-speech Engine” app
that has been installed 1010 times.
TABLE IV
VULNERABLE PREBUILT CORE APPS
App
PicoTts
Bluetooth
Code Path in AOSP
external/svox/pico
packages/apps/Bluetooth GattService.registerServer()
Vulnerable IPC Method
PicoService.setCallback()
AdapterService.registerCallback()
We also extend our study to ﬁnd vulnerable third-party
apps. Comparing to system services, third-party apps have
fewer JGR vulnerabilities, since few apps open IPC interface
to other third-party apps. We download 1000 Android apps
from Google Play marketplace and ﬁnd only three apps are
vulnerable to JGRE attacks. Table V shows these three apps
and the corresponding vulnerable IPC interfaces.
TABLE V
VULNERABLE THIRD-PARTY APPS
App
Google Text-to-speech
Supernet VPN
SnapMovie
# of downloads
1∗910-5∗910
1∗106-5∗106
1∗106-5∗106
Vulnerable IPC Interface
TextToSpeechService.setCa-
llback()
IOpenVPNAPIService.regis-
terStatusCallback()
IMainService.a()
V. JGRE COUNTERMEASURE
Based on two key observations on JGR usages, we develop a
JGRE countermeasure that can effectively defeat all identiﬁed
JGRE attacks.
Observation 1. The number of JGR for each system service
used by each benign app is stable and small.
We study the number of system services’ JGR by download-
ing the top popular free apps from Google Play marketplace
and installing them in an Nexus 5X. Due to the limitation of
the 16 GB internal storage, we can install up to 100 apps on
i
l
e
z
S
e
b
a
T
R
G
J
JGR Size of system_server Process
Number of Running Processes
 3000
 2800
 2600
 2400
 2200
 2000
 1800
 1600
 1400
 440
 420
 400
 380
 360
s
e
s
s
e
c
o
r
P
g
n
n
n
u
R
i
f
o
r
e
b
m
u
N
 1200
 5000  10000  15000  20000  25000
 0
Google Play Top 300 App Testing Time (seconds)
 60000
 50000
 40000
 30000
 20000
 10000
)
d
n
o
c
e
s
o
r
c
m
i
i
(
e
m
T
e
t
u
c
e
x
E
 0
 0
 10000
Index of Invoking Vulnerable IPC Interface
 20000
 30000
 40000
 50000
Fig. 4. The size of system server process’s JGR table (left Y axis) and the
number of running processes (right Y axis).
this platform simultaneously. Therefore, we measure 300 top
popular apps in three rounds. We use MonkeyRunner [12] to
run these apps. For each app, we run it for two minutes and