than 2 seconds.
6.2. Electronic purse
Consider a program that receives as input the balance h
of a bank account and debits a ﬁxed amount l from this
account until the balance is insuﬃcient for this transaction,
i.e. until h =l){
h=h-l;
lo=lo+1;
}
Upon termination, the program outputs the number of times
l has been successfully subtracted from h in the variable lo.
This number reveals partial information about the inital bal-
ance of the account. We use our approach to automatically
quantify this information.
The number of loop iterations depends on the account
balance h. Without any restriction on the range of the input
values, the number of program paths (and leaks) is inﬁnite,
and D will not terminate. To avoid this, we bound the
maximal account balance by 20 (i.e. h < 20). We consider a
single experiment where l = 5. With these parameters, D
computes the following equivalence relation on {0, . . . , 19}
≈{5}≡ 10 ≤ h ∧ h ≤ 14 ∧ 10 ≤ h ∧ h ≤ 14
∨ 5 ≤ h ∧ h ≤ 9 ∧ 5 ≤ h ∧ h ≤ 9
∨ 0 ≤ h ∧ h ≤ 4 ∧ 0 ≤ h ∧ h ≤ 4
∨ 15 ≤ h ∧ h ≤ 19 ∧ 15 ≤ h ∧ h ≤ 19 ,
Given ≈{5}, Q computes the equivalence classes
B1 ≡ 0 ≤ h ≤ 4
B2 ≡ 5 ≤ h ≤ 9
B3 ≡ 10 ≤ h ≤ 14
B4 ≡ 15 ≤ h ≤ 19 ,
from which we obtain |B1| = |B2| = |B3| = |B4| = 5. This
result conﬁrms the intuition that our program leaks the result
of integer division of h by l.
For this example, the structure of the equivalence classes
is simple and can be directly interpreted. We also give
an information-theoretic interpretation in terms of guessing.
If the value of h is chosen from a uniform distribution
(modeled by a random variable U), the number of guesses to
correctly determine the purse balance is G(U) = 10.5. Using
Proposition 3, the expected number of guesses decreases to
G(U|V≈{5}) =
1
2 · 20
|Bi|2 +
1
2
= 3
4(cid:88)
i=1
by observing the low output of the program.
The overall running time for analyzing this example
is dominated by the model checker’s running time of 24
seconds. The running times for computing the equivalence
classes and determining their size are each below one
second.
6.3. Sum query
Consider a program that receives as input n secret integers
and computes and outputs their sum. We use our approach to
characterize the information that is revealed by this program.
This result corresponds to the information that a sum query
reveals about a database record. For our example, we choose
n = 3 and represent the input by variables h1, h2, h3, i.e., we
analyze the program
l=h1;
151
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:15:53 UTC from IEEE Xplore.  Restrictions apply. 
l=l+h2;
l=l+h3;
The equivalence relation synthesized by D is
R ≡ h3 = h1 + h2 + h3 − h1 − h2 .
For determining the sizes and the number of the ≈-
equivalence classes, we choose 0 ≤ hi < 10 for i ∈ {1, 2, 3}.
Q computes equivalence classes of the form
Bi ≡ h1 + h2 + h3 = i − 1
for i ∈ {1, . . . , 28} with respective sizes |B1|, . . . ,|B28| of
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 63, 69, 73, 75, 75, 73, 69, 63,
55, 45, 36, 28, 21, 15, 10, 6, 3, 1.
For independently chosen and uniformly distributed input
values (modeled by a random variable U) the expected
number of guesses to correctly determine the input is
G(U) = 500.5 .
The average number of guesses is reduced to
G(U|V≈) =
1
2 · 103
|Bi|2 +
1
2
= 28.126
28(cid:88)
i=1
by observing the output of the analyzed program.
An analysis with the minimal guessing entropy shows
ˆG(U|V≈) = 1 ,
which additionally reveals that there are secrets that are very
easy to guess, a fact that is not revealed by any average-case
measure. This illustrates the beneﬁt of combining multiple
information measures in one analysis.
7. Conclusion
[5] G. Barthe, P. D’Argenio, and T. Rezk. Secure Information
Flow by Self-Composition. In Proc. IEEE Computer Security
Foundations Workshop (CSFW ’04), pages 100–114. IEEE
Computer Society, 2004.
[6] A. Barvinok. A Polynomial Time Algorithm for Counting
Integral Points in Polyhedra when the Dimension is Fixed.
Mathematics of Operations Research, 19:189–202, 1994.
[7] C. Cachin. Entropy Measures and Unconditional Security in
Cryptography. PhD thesis, ETH Z¨urich, 1997.
[8] C. Calcagno, D. Distefano, P. W. O’Hearn, and H. Yang.
Compositional shape analysis by means of bi-abduction. In
Proc. Symposium on Principles of Programming Languages
(POPL ’09), pages 289–300. ACM Press, 2009.
[9] D. Clark, S. Hunt, and P. Malacaria. Quantitative Information
Flow, Relations and Polymorphic Types. J. Log. Comput.,
18(2):181–199, 2005.
[10] D. Clark, S. Hunt, and P. Malacaria. A static analysis for
quantifying information ﬂow in a simple imperative language.
Journal of Computer Security, 15(3):321–371, 2007.
[11] E. M. Clarke, D. Kroening, N. Sharygina, and K. Yorav.
Satabs: SAT-based predicate abstraction for ANSI-C. In Proc.
Intl. Conference on Tools and Algorithms for the Construction
and Analysis of Systems (TACAS’ 05), volume 3440 of LNCS,
pages 570–574. Springer, 2005.
[12] M. R. Clarkson, A. C. Myers, and F. B. Schneider. Belief in
Information Flow. In Proc. IEEE Computer Security Founda-
tions Workshop (CSFW ’05), pages 31–45. IEEE Computer
Society, 2005.
[13] E. Cohen. Information Transmission in Sequential Programs.
In Foundations of Secure Computation, pages 297–335. Aca-
demic Press, 1978.
We presented the ﬁrst automatic method for information-
ﬂow analysis that discovers what information is leaked and
computes its comprehensive quantitative interpretation.
[14] B. Cook, A. Podelski, and A. Rybalchenko. Termination
In Proc. ACM Conference on
proofs for systems code.
Programming Language Design and Implementation (PLDI
’06), pages 415–426. ACM Press, 2006.
References
[1] T. Amtoft, S. Bandhakavi, and A. Banerjee. A logic for
In Proc.
information ﬂow in object-oriented programs.
Symposium on Principles of Programming Languages (POPL
’06), pages 91–102. ACM Press, 2006.
[2] R. B. Ash.
1990.
Information Theory. Dover Publications Inc.,
[3] T. Ball, R. Majumdar, T. Millstein, and S. Rajamani. Au-
tomatic predicate abstraction of C programs. In Proc. ACM
Conference On Programming Language Design and Imple-
mentation (PLDI ’01), volume 36 of ACM SIGPLAN Notices,
2001.
[4] A. Banerjee, D. A. Naumann, and S. Rosenberg. Expressive
declassiﬁcation policies and modular static enforcement. In
Proc. IEEE Symposium on Security and Privacy (S&P ’08),
pages 339–353. IEEE Computer Society, 2008.
152
[15] P. Cousot and R. Cousot. Abstract interpretation: A uniﬁed
lattice model for static analysis of programs by construction
In Proc. Symposium on
or approximation of ﬁxpoints.
Principles of Programming Languages (POPL ’77), pages
238–252, 1977.
[16] A. Darvas, R. H¨ahnle, and D. Sands. A Theorem Proving
Approach to Analysis of Secure Information Flow. In Proc.
International Conference on Security in Pervasive Computing,
LNCS 3450, pages 193 – 209. Springer, 2005.
[17] D. E. Denning. Cryptography and Data Security. Addison-
Wesley, 1982.
[18] R. Giacobazzi and I. Mastroeni. Abstract Non-Interference:
Parameterizing Non-Interference by Abstract Interpretation.
In Proc. ACM Symposium on Principles of Programming
Languages (POPL ’04), pages 186–197. ACM, 2004.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:15:53 UTC from IEEE Xplore.  Restrictions apply. 
[19] S. Graf and H. Sa¨ıdi. Construction of Abstract State Graphs
In Proc. Intl. Conference on Computer Aided
with PVS.
Veriﬁcation (CAV ’97), volume 1254 of LNCS, pages 72–83.
Springer, 1997.
[31] A. Podelski and A. Rybalchenko. ARMC: the logical choice
for software model checking with abstraction reﬁnement. In
Proc. Intl. Symposium on Practical Aspects of Declarative
Languages (PADL ’07). Springer, 2007.
[20] J. W. Gray. Toward a Mathematical Foundation for Infor-
mation Flow Security. Journal of Computer Security, 1(3-
4):255–294, 1992.
[21] T. A. Henzinger, R. Jhala, R. Majumdar, and K. L. McMillan.
In Proc. ACM Symposium on
Abstractions from proofs.
Principles of Programming Languages (POPL ’04), pages
232–244. ACM Press, 2004.
[32] E. Rosser, W. Kelly, W.
T. Shpeisman, and V. Maslov.
http://www.cs.umd.edu/projects/omega/.
05-Nov-2008].
Pugh, D. Wonnacott,
The Omega Project.
[Online; accessed
[33] A. Sabelfeld and A. C. Myers. Language-based Information-
IEEE J. Selected Areas in Communication,
Flow Security.
21(1):5–19, 2003.
[22] R. Jhala and K. L. McMillan. Array abstractions from proofs.
In Proc. Intl. Conference on Computer Aided Veriﬁcation
(CAV ’07), volume 4590 of LNCS, pages 193–206. Springer,
2007.
[34] A. Sabelfeld and A. C. Myers. A model for delimited
In Proc. Intl. Symposium on Software
information release.
Security (ISSS ’03), LNCS 3233, pages 174–191. Springer,
2004.
[23] B. K¨opf and D. Basin. Timing-Sensitive Information Flow
In Proc. European
Analysis for Synchronous Systems.
Symposium on Research in Computer Security (ESORICS
’06), LNCS 4189, pages 243–262. Springer, 2006.
[35] A. Sabelfeld and D. Sands. Dimensions and Principles of
In Proc. IEEE Workshop on Computer
Declassiﬁcation.
Security Foundations (CSFW ’05), pages 255–269. IEEE
Computer Society, 2005.
[24] B. K¨opf and D. Basin. An Information-Theoretic Model for
In Proc. ACM Conference
Adaptive Side-Channel Attacks.
on Computer and Communications Security (CCS ’07), pages
286–296. ACM, 2007.
[25] J. A. D. Loera, D. Haws, R. Hemmecke, P. Huggins, J. Tauzer,
and R. Yoshida. LattE. http://www.math.ucdavis.edu/ latte/.
[Online; accessed 08-Nov-2008].
[36] C. E. Shannon. A Mathematical Theory of Communication.
Bell System Technical Journal, 27:379–423 and 623–656, July
and October 1948.
[37] G. Smith. On the foundations of quantitative information
In Proc. Intl. Conference of Foundations of Software
ﬂow.
Science and Computation Structures (FoSSaCS ’09), LNCS
5504, pages 288–302. Springer, 2009.
[26] G. Lowe. Quantifying Information Flow.
In Proc. IEEE
Computer Security Foundations Workshop (CSFW ’02), pages
18–31. IEEE Computer Society, 2002.
[38] T. Terauchi and A. Aiken. Secure information ﬂow as a safety
problem. In Proc. Intl. Symposium on Static Analysis (SAS
’05), LNCS 3672, pages 352–367. Springer, 2005.
[27] P. Malacaria. Assessing security threats of looping con-
structs. In Proc. Symposium on Principles of Programming
Languages (POPL ’07), pages 225–235. ACM Press, 2007.
[28] J. L. Massey. Guessing and Entropy.
In Proc. IEEE
International Symposium on Information Theory (ISIT ’94),
page 204. IEEE Computer Society, 1994.
[29] S. McCamant and M. D. Ernst. Quantitative information ﬂow
In Proc. Conf. on Programming
as network ﬂow capacity.
Language Design and Implementation (PLDI ’08), pages
193–205, 2008.
[30] J. K. Millen. Covert Channel Capacity.
In Proc. IEEE
Symposium on Security and Privacy (S&P ’87), pages 60–
66. IEEE Computer Society, 1987.
[39] H. Unno, N. Kobayashi, and A. Yonezawa. Combining Type-
Based Analysis and Model Checking for Finding Counterex-
In Proc. Workshop on
amples Against Non-interference.
Programming Languages and Analysis for Security (PLAS
’06), pages 17–26. ACM Press, 2006.
[40] J. T. Wittbold and D. M. Johnson.
Information Flow in
In Proc. IEEE Symposium on
Nondeterministic Systems.
Security and Privacy (S&P ’90), pages 144–161. IEEE Com-
puter Society, 1990.
[41] S. Zdancewic and A. C. Myers. Robust declassiﬁcation. In
Proc. IEEE Computer Security Foundations Workshop (CSFW
’01), pages 15–23. IEEE Computer Society, 2001.
153
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:15:53 UTC from IEEE Xplore.  Restrictions apply.