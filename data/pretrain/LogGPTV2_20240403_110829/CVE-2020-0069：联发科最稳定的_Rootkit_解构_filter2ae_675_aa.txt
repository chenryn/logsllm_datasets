# CVE-2020-0069：联发科最稳定的 Rootkit 解构
|
##### 译文声明
本文是翻译文章，文章原作者 Maxime Rossi Bellom，文章来源：blog.quarkslab.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
在 2020 年的 3 月份，Google 修复了一个影响许多联发科设备的高危漏洞。联发科自 2019 年 4
月就知道了这个漏洞，之后在野被利用！这篇文章中，我们将提供一些关于这个漏洞的细节，并了解如何使用它来实现内核内存的读写。
## 概述
在 2020 年的 3 月份，Google 修复了一个影响许多联发科设备的高危漏洞。联发科自 2019 年 4 月份就知道了这个漏洞 ( 修复前 10 个月
)，该漏洞允许本地攻击者不需要特权即可读写系统内存，实现提权。甚至出现了一个名为 mtk-su 的漏洞利用程序，通过它可以获得很多存在漏洞的设备的 root
权限，这在 2019 年就被开发完成。在撰写本文时，关于这个漏洞的信息很少。所以我们决定自己去研究看看。
## 关于 CVE-2020-0069
根据联发科公布的信息，这个漏洞允许本地攻击者到达任意的物理地址实现内存读写，并能进一步实现提权。受影响的模块是联发科的命令队列驱动程序( Command
Queue driver ) 或者 CMDQ 驱动。在驱动上使用 IOCTL ，这令攻击者有可能分配一个 DMA ( Direct Memory
Access ) 缓冲区，并且向 DMA 硬件发送命令为了实现物理地址的读写。
提醒一下，Direct Memory Access 是允许专用的硬件可以直接与主内存( RAM )
发送和接收数据的一种特性。其目的是为了通过允许大量的内存访问而不占用太多的 CPU 来加速系统。这个驱动似乎允许从用户态与 DMA
控制器通信，以完成媒体和显示相关的任务。
至少有超过 10 个 SoC( System on Chip ) 受到此漏洞的影响，甚至有更多。我们已经能够在小米的 红米6a 设备上利用它 (
使用联发科的 MT6762M SoC )。
## CMDQ 驱动程序
在网络上有此驱动的很多版本。在本次研究中，我们主要关注小米的红米6a 的开源内核。此驱动程序的实现可以在
drivers/misc/mediatek/cmdq 找到。相关的驱动程序可以是 /dev/mtk-cmdq 或 /proc/mtk-cmdq 具体取决于
SoC ，并可用于任何应用程序，无需授权 ( 至少在存在漏洞的设备上是这样的 )。
照之前所说，此驱动程序可以被用户( 从用户态 )通过 IOCTL 系统调用控制。
    #define CMDQ_IOCTL_EXEC_COMMAND _IOW(CMDQ_IOCTL_MAGIC_NUMBER, 3, \
        struct cmdqCommandStruct)
    #define CMDQ_IOCTL_QUERY_USAGE  _IOW(CMDQ_IOCTL_MAGIC_NUMBER, 4, \
        struct cmdqUsageInfoStruct)
    /*  */
    /* Async operations */
    /*  */
    #define CMDQ_IOCTL_ASYNC_JOB_EXEC _IOW(CMDQ_IOCTL_MAGIC_NUMBER, 5, \
        struct cmdqJobStruct)
    #define CMDQ_IOCTL_ASYNC_JOB_WAIT_AND_CLOSE _IOR(CMDQ_IOCTL_MAGIC_NUMBER, 6, \
        struct cmdqJobResultStruct)
    #define CMDQ_IOCTL_ALLOC_WRITE_ADDRESS _IOW(CMDQ_IOCTL_MAGIC_NUMBER, 7, \
        struct cmdqWriteAddressStruct)
    #define CMDQ_IOCTL_FREE_WRITE_ADDRESS _IOW(CMDQ_IOCTL_MAGIC_NUMBER, 8, \
        struct cmdqWriteAddressStruct)
    #define CMDQ_IOCTL_READ_ADDRESS_VALUE _IOW(CMDQ_IOCTL_MAGIC_NUMBER, 9, \
        struct cmdqReadAddressStruct)
在所有可用的操作中，我们关注以下几个 :
  * CMDQ_IOCTL_ALLOC_WRITE_ADDRESS 用于分配 DMA 缓冲区，并且接收一个结构体 cmdqWriteAddressStruct 作为参数
  * CMDQ_IOCTL_FREE_WRITE_ADDRESS 用于释放之前分配的 DMA 缓冲区
  * CMDQ_IOCTL_EXEC_COMMAND 允许发送一个命令缓冲区给 DMA 控制器，并接收结构体 cmdqCommandStruct 作为参数
  * CMDQ_IOCTL_READ_ADDRESS_VALUE 用于读取 DMA 缓冲区的值
## 分配一个 DMA 缓冲区
当调用 CMDQ_IOCTL_ALLOC_WRITE_ADDRESS ，我们提供一个结构体 cmdqWriteAddressStruct ，在 count
字段中包含了请求缓冲区的大小。在字段 startPA 上存储着我们接收到的物理地址，我们无法直接在用户态访问这个地址，为了访问这个内存区域，我们需要使用
CMDQ_IOCTL_EXEC_COMMAND。
释放 DMA 的缓冲区是可能的，我们需要调用 CMDQ_IOCTL_FREE_WRITE_ADDRESS 并且传递一个之前分配时传递的结构体
cmdqWriteAddressStruct 作为参数
## 执行命令
CMDQ_IOCTL_EXEC_COMMAND 接收一个结构体 cmdqCommandStruct 作为参数。
    struct cmdqCommandStruct {
     [...]
     /* [IN] pointer to instruction buffer. Use 64-bit for compatibility. */
     /* This must point to an 64-bit aligned u32 array */
     cmdqU32Ptr_t pVABase;
     /* [IN] size of instruction buffer, in bytes. */
     u32 blockSize;
     /* [IN] request to read register values at the end of command */
     struct cmdqReadRegStruct regRequest;
     /* [OUT] register values of regRequest */
     struct cmdqRegValueStruct regValue;
     /* [IN/OUT] physical addresses to read value */
     struct cmdqReadAddressStruct readAddress;
     [...]
按照之前所说的，这个 IOCTL 系统调用允许发送命令给 DMA 控制器执行。这个命令是存放在用户态的缓冲区的，其地址需要放在字段 pVABase
中，其大小需要放在 blockSize 字段中
在命令结构体中的字段 readAddress 被用来在执行命令后保存从 DMA 缓冲区读取的值。字段 readAddress.dmaAddresses
指向一个用户态缓冲区，这里包含了要读取的 DMA 缓冲区的地址。它的大小由字段 readAddress.count
决定。所有的地址都会被内核读取，并且读取的值将会被存放在由字段 readAddress.values 指向的用户态缓冲区。
读取 DMA 缓冲区同样也可以通过使用 IOCTL 命令 CMDQ_IOCTL_READ_ADDRESS_VALUE 实现。
## 命令描述
一个命令由两个 32 位的字组成，并且由一个命令代码标识
    enum cmdq_code {
     CMDQ_CODE_READ  = 0x01,
     CMDQ_CODE_MASK = 0x02,
     CMDQ_CODE_MOVE = 0x02,
     CMDQ_CODE_WRITE = 0x04,
     CMDQ_CODE_POLL  = 0x08,
     CMDQ_CODE_JUMP = 0x10,
     CMDQ_CODE_WFE = 0x20,
     CMDQ_CODE_EOC = 0x40,
     [...]
下面有一些命令的描述是我们将要去使用的。
CMDQ_CODE_WRITE 和 CMDQ_CODE_READ
write 命令用于将 data 寄存器中的值写入到 address 寄存器所存放的地址中。read 命令读取 address
寄存器指向的地址的内容，并将结果存放在 data 寄存器中。
根据选项位 ( 图中 TYPE A 和 TYPE B )，可以从 REG NUMBER 字段中的名为 subsysID 的值和 value
字段中的偏移量计算地址。subsysID 的值将被内核 DTS 的实际物理地址替代。
CMDQ_CODE_MOVE
这个命令将会允许把一个值 ( 最大 48 bit )传入一个寄存器中。这个值也可以被存放在 data 寄存器或者 address
寄存器，可以是任意数据或者一个地址。这可能是这里最大的问题，因为没有对地址进行检查。
CMDQ_CODE_WFE
WFE 代表的是 Wait For Event and clear ,根据我们的理解，我们可以借助它去阻塞一些寄存器的使用 ( 就像使用互斥锁一样
)。与此命令一起使用的事件标志与我们将在命令缓冲区中使用的一组寄存器相关联。举个例子，对于寄存器 CMDQ_DATA_REG_DEBUG (R7) 和
CMDQ_DATA_REG_DEBUG_DST (P11),必须使用事件 ( 或令牌，源代码中的的称呼 )
CMDQ_SYNC_TOKEN_GPR_SET_4。我们在每个命令缓冲区的开头和结尾使用 WFE 命令。
CMDQ_CODE_EOC
EOC 代表的是 End Of Command,它必须放在每个命令缓冲区的末尾，在 CMDQ_CODE_WFE
命令后面，用于标示命令列表的结尾。看上去它包含了非常多的标志位，但是对于我们的使用而言，我们仅仅需要知道 IRQ 标志位总是需要被设置。
CMDQ_CODE_JUMP
根据源代码的注释，该命令允许使用一个偏移量跳转进命令缓冲区。我们在每个命令缓冲区的末尾使用这个命令，在 CMDQ_CODE_EOC 命令后面，总是在偏移
0x8 处跳转，即之前的命令处。我们的理论是在 DMA 控制器中实现预取机制，这命令将确保 CMDQ_CODE_EOC 命令考虑在内。
## 寄存器
在命令描述中，我们提到了两种类型的寄存器:
  * value 寄存器 ( 从 R0 到 R15 ) 由 32位比特组成
  * address 寄存器 ( 从 P0 到 P7 ) 由 64位比特组成
    enum cmdq_gpr_reg {
        /* Value Reg, we use 32-bit */
        /* Address Reg, we use 64-bit */
        /* Note that R0-R15 and P0-P7 actually share same memory */
        /* and R1 cannot be used. */
        CMDQ_DATA_REG_JPEG = 0x00,  /* R0 */
        CMDQ_DATA_REG_JPEG_DST = 0x11,  /* P1 */
        CMDQ_DATA_REG_PQ_COLOR = 0x04,  /* R4 */
        CMDQ_DATA_REG_PQ_COLOR_DST = 0x13,  /* P3 */
        CMDQ_DATA_REG_2D_SHARPNESS_0 = 0x05,    /* R5 */
        CMDQ_DATA_REG_2D_SHARPNESS_0_DST = 0x14,    /* P4 */