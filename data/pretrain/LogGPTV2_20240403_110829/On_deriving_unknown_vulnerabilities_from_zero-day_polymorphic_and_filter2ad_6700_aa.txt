title:On deriving unknown vulnerabilities from zero-day polymorphic and
metamorphic worm exploits
author:Jedidiah R. Crandall and
Zhendong Su and
Shyhtsun Felix Wu and
Frederic T. Chong
On Deriving Unknown Vulnerabilities from Zero-Day
Polymorphic and Metamorphic Worm Exploits
Jedidiah R. Crandall
Dept. Comp. Sci.
Univ. of Calif., Davis
Davis, CA 95616
PI:EMAIL
S. Felix Wu
Dept. Comp. Sci.
Univ. of Calif., Davis
Davis, CA 95616
PI:EMAIL
Zhendong Su
Dept. Comp. Sci.
Univ. of Calif., Davis
Davis, CA 95616
PI:EMAIL
Frederic T. Chong
Dept. Comp. Sci.
Univ. of Calif., Santa Barbara
Santa Barbara, CA 93106
PI:EMAIL
ABSTRACT
Vulnerabilities that allow worms to hijack the control ﬂow
of each host that they spread to are typically discovered
months before the worm outbreak, but are also typically dis-
covered by third party researchers. A determined attacker
could discover vulnerabilities as easily and create zero-day
worms for vulnerabilities unknown to network defenses. It
is important for an analysis tool to be able to generalize
from a new exploit observed and derive protection for the
vulnerability.
Many researchers have observed that certain predicates
of the exploit vector must be present for the exploit to
work and that therefore these predicates place a limit on
the amount of polymorphism and metamorphism available
to the attacker. We formalize this idea and subject it to
quantitative analysis with a symbolic execution tool called
DACODA. Using DACODA we provide an empirical anal-
ysis of 14 exploits (seven of them actual worms or attacks
from the Internet, caught by Minos with no prior knowledge
of the vulnerabilities and no false positives observed over a
period of six months) for four operating systems.
Evaluation of our results in the light of these two models
leads us to conclude that 1) single contiguous byte string
signatures are not eﬀective for content ﬁltering, and token-
based byte string signatures composed of smaller substrings
are only semantically rich enough to be eﬀective for content
ﬁltering if the vulnerability lies in a part of a protocol that
is not commonly used, and that 2) practical exploit analysis
must account for multiple processes, multithreading, and
kernel processing of network data necessitating a focus on
primitives instead of vulnerabilities.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’05, November 7–11, 2005, Alexandria, Virginia, USA.
Copyright 2005 ACM 1-59593-226-7/05/0011 ...$5.00.
Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection–
invasive software
General Terms
Security, languages
Keywords
worms, polymorphic worms, symbolic execution, polymor-
phism, metamorphism, honeypots
1.
INTRODUCTION
Zero-day worms that exploit unknown vulnerabilities are
a very real threat. Typically vulnerabilities are discovered
by “white hat” hackers using fuzz testing [26, 27], reverse
engineering, or source code analysis and then the software
vendors are notiﬁed. The same techniques for discovering
these vulnerabilities could be as easily employed by “black
hat” hackers, especially now that computer criminals are
increasingly seeking proﬁt rather than mischief. None of
the 14 exploits analyzed in this paper are for vulnerabilities
discovered by the vendors of the software being attacked.
A vulnerability gives the attacker an important primitive (a
primitive is an ability the attacker has, such as the ability to
write an arbitrary value to an arbitrary location in a process’
address space), and then the attacker can build diﬀerent
exploits using this primitive.
The host contains information about the vulnerability and
primitive that cannot be determined from network traﬃc
alone. It is impossible to generalize how the attack might
morph in the future without this information. In order to
respond eﬀectively during an incipient worm outbreak, an
automated analysis tool must be able to generalize one in-
stance of an exploit and derive protection for the exploited
vulnerability, since a worm can build multiple exploits for
the same vulnerability from primitives.
1.1 The Need to Be Vulnerability-Speciﬁc
If a honeypot or network technology generated an
exploit-speciﬁc signature for every exploit, the worm author
could trivially subvert content ﬁltering by generating a
new exploit for each infection attempt. One approach to
ameliorate this is to compare multiple exploits and ﬁnd
common substrings. This can be done in the network [21,37]
or from TCP dumps of diﬀerent honeypots [24]. Our results
in Section 4 show that contiguous byte string signatures are
not semantically rich enough for eﬀective content ﬁltering
of polymorphic and metamorphic worms. The same con-
clusion was reached by Newsome et. al. [28], in which three
new kinds of byte-string signatures were proposed that are
sets composed of tokens (substrings). For more information
see Section 1.3.1. In this paper we generate these tokens for
14 remote exploits using DACODA and conclude that even
token-based byte strings are only semantically rich enough
to distinguish between worms and valid traﬃc if the worm
exploits a vulnerability that is not found in a commonly
used part of a protocol. For example, the signature token
“\x0d\nTransfer-Encoding:\x20chunked\x0d\n\x0d\n”
would have stopped the Scalper worm but also would have
dropped valid traﬃc if valid traﬃc commonly used chunked
encodings. This is the only token for this particular exploit
that distinguishes it from ordinary HTTP traﬃc.
1.2 DACODA: The Davis Malcode Analyzer
Complicating the problem of deriving the vulnerability
from a single exploit is the fact that many exploits can in-
volve more than one network connection, multiple processes,
multithreading, and a signiﬁcant amount of processing of
network data in the kernel. Such experiences with real
exploits have motivated us to develop two diﬀerent mod-
els in order to be more perspicuous in discussing polymor-
phism and metamorphism: the Epsilon-Gamma-Pi (, γ,
π) model [14] for control ﬂow hijacking attacks and the PD-
Requires-Provides model for exploits. Both of these mod-
els take a “from-the-architecture-up” view of the system in
which context switches and interprocess communication are
simply physical transfers of data in registers and memory.
We have developed a tool called DACODA that analyzes
attacks using full-system symbolic execution [22] on every
machine instruction. In this paper, we use DACODA for a
detailed, quantitative analysis of 14 real exploits. DACODA
tracks data from the attacker’s network packets to the hi-
jacking of control ﬂow and discovers strong, explicit equality
predicates about the exploit vector; strong, explicit equality
predicates are predicates that show equality between labeled
data and an integer that are due to an explicit equality check
by the protocol implementation on the attacked machine
using a comparison instruction followed by a conditional in-
struction (typically a conditional jump). Using Minos [13]
as an oracle for catching attacks, DACODA honeypots have
been analyzing attacks exploiting vulnerabilities unknown
to Minos or DACODA with zero observed false positives for
the past six months. More details on DACODA’s operation
are in Section 3.
1.3 Related Work
The details of the Epsilon-Gamma-Pi model are in an-
other paper [14] and will be summarized in Section 2. For
categorizing related work in this section we will only state
here that, in simple terms,  maps the exploit vector from
the attacker’s network packets onto the trace of the machine
being attacked before control ﬂow hijacking occurs, γ maps
the bogus control data used for hijacking control ﬂow (such
as the bogus return pointer in a stack-based buﬀer overﬂow
attack), and π maps the payload executed after control ﬂow
has been hijacked.
1.3.1 Vulnerability Speciﬁcity
Vigilante [10, 11] captures worms with a mechanism simi-
lar to Minos [13], but based on binary rewriting of a single
process, and uses dynamic dataﬂow analysis to generate a
vulnerability signature. The basic idea proposed in Costa
et al. [10] is to replay the execution with an increasingly
larger suﬃx of the log and check for the error condition.
Binary rewriting of a single process does not capture in-
terprocess communication, inter-thread communication, or
any data processing that occurs in kernel space.
It also
modiﬁes the address space of the process being analyzed,
which has the potential of breaking the exploit in its early
stages [3]. DACODA is a full-system implementation and
does not modify the system being analyzed. Another im-
portant distinction of DACODA is that, because it is based
on the Epsilon-Gamma-Pi model, DACODA’s symbolic exe-
cution helps distinguish between what data looks like on the
network and what it looks like at various stages of process-
ing on the host. Encodings such as UNICODE encodings or
string to integer conversion cannot be captured by simply
comparing I/O logs to TCP dumps.
TaintCheck [29] is also based on binary rewriting of a sin-
gle process and proposed dynamic slicing techniques as fu-
ture work to generate vulnerability-speciﬁc signatures. DA-
CODA is based on symbolic execution of every machine in-
struction in the entire system. For RIFLE [41] an Itanium
architecture simulator was augmented with dataﬂow analy-
sis capabilities similar to DACODA, without predicate dis-
covery, but the aim was to enforce conﬁdentiality policies
while DACODA’s aim is to analyze worm exploits.
Newsome et. al. [28] proposed three types of signatures
based on tokens. These tokens can be ordered or associ-
ated with scores. Polygraph, unlike EarlyBird [37], Auto-
graph [21], or Honeycomb [24], does not automatically cap-
ture worms but instead relies on a ﬂow classiﬁer to sort
worm traﬃc from benign traﬃc with reasonable accuracy.
The invariant bytes used for tokens were typically from ei-
ther protocol framing () or the bogus control data (γ). It
was suggested that the combination of these could produce a
signature with a good false positive and false negative rate.
Protocol framing describes a valid part of a protocol, such as
“HTTP GET” in HTTP. Also, γ permits too much polymor-
phism according to our analysis of exploits caught by Minos
honeypots [14], due to register springs.
Register springs are a technique whereby the bogus func-
tion pointer or return pointer overwritten by a buﬀer over-
ﬂow points to an instruction in a library (or the static pro-
gram) that is a jump or call to a register pointing into
the buﬀer containing π. Newsome et. al. [28] correctly
states that for register springs to be stable the address
must be common across multiple Windows versions and cites
Code Red as an example, but Code Red and Code Red II
used an address which was only eﬀective for Windows 2000
with Service Pack 1 or no service packs (the instruction at
0x7801cbd3 disassembles to “CALL EBX” only for msvcrt.dll
version 6.10.8637 [33]). Even with this limitation Code Red
and Code Red II were successful by worm standards, so the
hundreds or sometimes thousands of possible register springs
typical of Windows exploits cannot be ignored.
One current limitation of DACODA is performance. Our
Bochs-based implementation of DACODA achieves on the
order of hundreds of thousands of instructions per second
on a 3.0 GHz Pentium 4 with an 800 MHz front side bus.
Memory bandwidth is the limiting factor, and DACODA
barely achieves good enough performance to be infected by
a worm on a 2.8 GHz Pentium 4 with a 533 MHz front side
bus. All that really is required to detect the attack is Minos
[13], which would have virtually no overhead in a hardware
implementation and could possibly have performance within
an order of magnitude of native execution if implemented on
a higher performance emulator such as QEMU [51]. After
Minos detected an attack DACODA could be invoked by
replaying either the TCP traﬃc [19, 20] or the entire attack
trace [16].
1.3.2 Modeling Polymorphism
Ideas similar to our PD-Requires-Provides model for ex-
ploit polymorphism and metamorphism are presented in Ru-
bin et. al. [34, 35]. The PD-Requires-Provides model is at
a much lower level of abstraction. Rubin et. al. [34, 35] do
not distinguish between what the exploit looks like on the
network and what it looks like when it is processed on the
host, as our Epsilon-Gamma-Pi model does. These works
were also intended for generating exploits based on known
vulnerabilities and not for analyzing zero-day exploits to de-
rive protection for unknown vulnerabilities. A more recent
work [44] generates vulnerability-speciﬁc signatures for un-
known exploits but requires a detailed speciﬁcation of the
protocol that the exploit uses (such as SMB or HTTP). DA-
CODA needs no speciﬁcation because of symbolic execution,
at the cost of not having a full speciﬁcation against which
to model check signatures.
In Dreger et. al. [15] host-based context was used to en-
hance the accuracy of network-based intrusion detection but
this was done from within the Apache HTTP server appli-
cation. Ptacek and Newsham [32] cover some of the same
ideas as we do but within the context of network evasion
of network intrusion detection systems. Christodorescu and
Jha [7] looked at polymorphism of viruses with examples
from real viruses, but polymorphic virus detection and poly-
morphic worm detection are two diﬀerent problems; a worm
needs to be able to hijack control ﬂow of remote hosts be-
cause worms use the network as their main medium of in-
fection.
1.3.3 Polymorphic Worm Detection
Many researchers have studied polymorphic techniques
and detection mechanisms in π [1, 6, 8, 23, 25, 31, 40]. Sev-
eral of the mechanisms which have been proposed are based
on the existence of a NOP sled which simply is not appli-
cable to Windows exploits, nearly all of which use regis-
ter springs [14]. The executable code itself could be made
polymorphic and metamorphic with respect to probably any
signature scheme if we are to consider the relatively long
history of polymorphic computer viruses [38]. Other works
have focused exclusively on γ [30] which can be polymorphic
because there are usually hundreds or even thousands of dif-
ferent register springs an attacker might use [14]. We have
argued in another paper [14] that π and γ permit too much
polymorphism, motivating a closer look at  instead. The
focus of this paper is on polymorphism and metamorphism
of . Other papers have focused on  [10,28,34,35,43,44], all
Figure 1: The Epsilon-Gamma-Pi Model.
of which have already been discussed in this section except
for Shield [43]. Shields are a host-based solution which are
an alternative to patches. They are vulnerability-speciﬁc
but only for known vulnerabilities.
1.3.4 Our Main Contributions
The main distinction of our work is that we focus on un-
known vulnerabilities and use models based on our experi-
ence with analyzing 14 real exploits to give a detailed and
quantitative analysis of polymorphism and metamorphism
for the exploit vector mapped by . Our main contributions
are 1) a tool for whole-system symbolic execution of remote