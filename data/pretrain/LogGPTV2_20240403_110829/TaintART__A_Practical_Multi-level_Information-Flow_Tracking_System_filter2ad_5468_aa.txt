title:TaintART: A Practical Multi-level Information-Flow Tracking System
for Android RunTime
author:Mingshen Sun and
Tao Wei and
John C. S. Lui
TaintART: A Practical Multi-level Information-Flow Tracking
System for Android RunTime
Mingshen Sun
The Chinese University of
Hong Kong
Tao Wei
Baidu X-Lab
John C.S. Lui
The Chinese University of
Hong Kong
ABSTRACT
Mobile operating systems like Android failed to provide suf-
ﬁcient protection on personal data, and privacy leakage be-
comes a major concern. To understand the security risks
and privacy leakage, analysts have to carry out data-ﬂow
analysis. In 2014, Android upgraded with a fundamentally
new design known as Android RunTime (ART) environ-
ment in Android 5.0. ART adopts ahead-of-time compi-
lation strategy and replaces previous virtual-machine-based
Dalvik. Unfortunately, many data-ﬂow analysis systems like
TaintDroid [19] were designed for the legacy Dalvik environ-
ment. This makes data-ﬂow analysis of new apps and mal-
ware infeasible. We design a multi-level information-ﬂow
tracking system for the new Android system called Taint-
ART. TaintART employs a multi-level taint analysis tech-
nique to minimize the taint tag storage. Therefore, taint
tags can be stored in processor registers to provide eﬃcient
taint propagation operations. We also customize the ART
compiler to maximize performance gains of the ahead-of-
time compilation optimizations. Based on the general de-
sign of TaintART, we also implement a multi-level privacy
enforcement to prevent sensitive data leakage. We demon-
strate that TaintART only incurs less than 15 % overheads
on a CPU-bound microbenchmark and negligible overhead
on built-in or third-party applications. Compared to legacy
Dalvik environment in Android 4.4, TaintART achieves
about 99.7 % faster performance for Java runtime bench-
mark.
1.
INTRODUCTION
Mobile devices such as smartphones, tablets and wearable
devices are widely used for communication, photo taking,
entertainment, and monitoring health status. Many appli-
cations (apps for short) installed on the smartphones provide
useful services, but they may also privately send sensitive in-
formation to remote servers for various data analytics [12].
Worse yet, some of them can gain proﬁt from these personal
data [38]. Furthermore, malware can secretly steal sensitive
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978343
information such as contact lists without users’ consent. All
these indicate that privacy leakage is a serious threat to a
large community of mobile users.
To understand the possibility of privacy leakage, research-
ers seek solutions in two directions of data-ﬂow analysis.
Firstly, with the disassembled code of a given app, research-
ers can perform static data-ﬂow analysis techniques such as
static taint analysis and symbolic execution. This type of
methods can statically derive a set of possible data which
may leave devices at runtime, and decide whether sensitive
data leaks to untrusted channels. The limitation of this
method is that it cannot detect runtime information dis-
closures when the app developers use techniques such as
code with Java reﬂection, code encryption, or dynamic code
loading techniques. Therefore, researchers proposed to use
dynamic methodologies to monitor suspicious behaviors at
runtime. The dynamic taint analysis technique [46] is one of
many dynamic methodologies which can track the informa-
tion ﬂows within apps at runtime. The dynamic taint anal-
ysis technique will label (taint) sensitive data from certain
sources and handle label transitions (taint propagation) be-
tween variables, ﬁles, and procedures at runtime. If a tainted
label transmits out of the mobile device through some func-
tions (sinks), one can then monitor the data leakage dynam-
ically. This method can accurately track data ﬂows at an
app’s execution time.
TaintDroid [19] is a notable dynamic taint analysis system
for Android apps. It customizes Android runtime (Dalvik
Virtual Machine) to achieve taint storage and taint prop-
agation. Many systems [16, 63, 5, 43, 42, 54] are based
on TaintDroid to conduct further analysis. However, there
are several constraints which make TaintDroid can no longer
function on the latest Android for privacy tracking and mal-
ware analysis (and to a certain extent, data ﬂow analysis).
Firstly, TaintDroid was originally designed for virtual-
machine-based system (i.e., Dalvik virtual machine), and
implemented on legacy Android systems 2.1, 2.3, 4.1, and
4.3. TaintDroid utilizes the internal memory of Dalvik vir-
tual machine for taint storage and propagation. To enhance
the performance of Android, Google recently changed to the
ahead-of-time (AOT) compilation strategy and introduced
Android RunTime (ART) to replace Dalvik VM starting
from Android 5 and onward. Instead of interpreting code
(or using JIT [25, 62]) by virtual machine at runtime, the
AOT compilation strategy will directly compile apps into
native code at the ﬁrst installation time. Therefore, one
cannot use TaintDroid for the newly-designed runtime and
TaintDroid can at most only support legacy systems up to
Android 4.4.
Secondly, although the latest Android still provides a fall-
back runtime interpreter for debugging, the performance is
not acceptable (as shown in our evaluation). Therefore,
porting TaintDroid to this fallback runtime cannot take ad-
vantage of compiler optimization and the performance issue
hinders eﬀective security and data ﬂow analysis.
Thirdly, because of the compatibility and performance is-
sues, users cannot use TaintDroid for policy enforcement to
prevent privacy leakage. As shown in the Android distribu-
tion statistics [24], about half of Android users have already
upgraded to Android 5.0 or above, and this number contin-
ues to grow.
Last but not least, we discover that app developers tend
to target newer Android versions so as to use latest features
which TaintDroid does not support. We measured SDK ver-
sions of ﬁve hundreds apps in Google Play’s “Top Charts” on
October 2015 and February 2016. As shown in Figure 1, the
average target SDK version has changed from 19 (Android
4.4) to 20 (Android 5.0). Again, this implies that many
new apps may not be analyzed by TaintDroid, and malware
can exploit this incapability to bypass security or data ﬂow
analysis.
In this paper, we design and implement TaintART, a dy-
namic information-ﬂow tracking system which targets the
latest Android runtime. TaintART introduces a multi-level
taint label so as to tag the sensitive levels of diﬀerent taint
sources. TaintART instruments Android’s compiler and
utilizes processor registers for taint storage. Compared to
TaintDroid which needs at least two memory accesses, Taint-
ART only needs few register accesses and hence achieves
faster taint propagation. Therefore, TaintART has a much
better performance than TaintDroid. We also prototype
TaintART on the latest Android system and conduct ex-
tensive performance evaluation.
In summary, we make the following contributions:
• Methodology. We ﬁrst propose a novel method to
eﬃciently track dynamic information ﬂows on the An-
droid mobile operating system with ahead-of-time com-
pilation strategy. By instrumenting the compiler, we
conduct multi-level taint analysis on compiled apps
with optimized code rather than the app’s original
bytecode. Furthermore, instead of relying on mem-
ory storage, our method utilizes processor registers to
achieve fast taint storage and propagation, resulting in
minimal performance and memory overheads.
• Implementation. We implement TaintART on the
latest released Android system (Android 6.0 “Marsh-
mallow”) which supports the newly-designed applica-
tion runtime (i.e., ART runtime). TaintART can
track multi-level information ﬂows within a method,
across methods, as well as data transmitted between
apps. To the best of our knowledge, this is the ﬁrst
information-ﬂow tracking system which supports the
newly-designed ART runtime. Furthermore, because
information-ﬂow analysis is a general analysis tech-
nique which can be used in many research areas, we
shall open-source our system.
• Performance. We also extensively perform the mac-
robenchmarks, microbenchmarks and compatibility test
Figure 1: Trends of minimum SDK versions and tar-
get SDK versions for apps downloaded from Google
Play’s “Top Charts”.
of TaintART. TaintART incurs an overall Java run-
time overhead of less than 15 % compared to the orig-
inal environment with optimizing compiler backend.
It is worth noting that TaintART can achieve 2.5 %
and 99.7 % faster for overall performance compared to
quick compiler backend ART runtime and Dalvik VM
in Android 4.4. In addition, TaintART incurs negligi-
ble memory overhead and less than 5 % IPC overhead.
More importantly, our CTS test shows that Taint-
ART can analyze apps without compatibility issues.
• Application to privacy leakage analysis. On top
of TaintART platform, we discover privacy leakage
issues on popular apps in Android 6.0 and provide
a solution to prevent data leakage in various levels.
Furthermore, we also ﬁnd that some functions of apps
could not be analyzed due to compatibility issues when
we analyze these apps using TaintDroid based on An-
droid’s legacy runtime.
The rest of this paper is organized as follows. Section 2
introduces the background of Android runtime. Section 3
describes our TaintART design on taint storage, taint prop-
agation, and taint logic.
In Section 4, we show the im-
plementation details of TaintART. We also conduct sev-
eral case studies such as privacy tracking in Section 5. In
Section 6, we extensively evaluate the macrobenchmarks,
microbenchmarks and compatibility issues of TaintART.
Section 7 presents TaintART’s limitations and our future
works. Related work is presented in Section 8 and Section 9
concludes.
2. BACKGROUND
In this section, we discuss essential background of Android
systems and Android app environment.
2.1 Android Overview
Android operating system is based on the Linux kernel.
On top of the kernel, Android provides a set of libraries, such
as database libraries and app runtime libraries. Moreover,
there is a middleware called application framework based on
these common libraries. The application framework provides
various APIs for apps developers, such as activity manage-
ment, content management, and view system. Supported by
123456789101112131415161718192021222300.10.20.30.4mean=19.11mean=11.37mean=20.69mean=12.68Android2.34.04.45.06.0AndroidSDKVersionPercentageTargetSDKVersion(Oct.2015)MinimumSDKVersion(Oct.2015)TargetSDKVersion(Feb.2016)MinimumSDKVersion(Feb.2016)app frameworks, many apps and background services run
on the device. There are some system services providing
fundamental functions such as sending and receiving mes-
sages, getting current locations, and reading accelerometer
data. Android apps are mainly written in Java, but to en-
hance performance, developers can also embed C/C++ and
use Java Native Interface (JNI) to interact with apps and
framework APIs. Each app runs in an isolated environment.
Apps can communicate with other apps and services through
a speciﬁc inter-process communication mechanism called the
binder. Messages in the binder can hold actions or data ob-
ject references and will be serialized into parcels. A binder
kernel module is responsible for passing parcel messages be-
tween processes. Using this approach, diﬀerent apps can
request actions or share information across app sandboxes.
2.2 Android App Environment
After developing an app, developers need to compile Java
sources of an app into bytecode by a Java compiler with the
javac tool and convert it to the dex bytecode with the dx
tool. With other resources, the dex ﬁle will be zipped into
one single application package ﬁle (apk ﬁle) for distribution
on app markets. Users can download and install apps from
the markets into their Android devices. Basically, Android
app environment contains two stages: installation stage and
runtime stage. During the installation of apps, Android de-
vices may conduct further compilation or optimizations lo-
cally. After installation, apps can run with the support of
app runtime such as handling method calls to framework
APIs, or interacting with the Java native interface (JNI).
For Android devices, there are two fundamentally diﬀerent
app environments: Dalvik and ART. Figure 2 illustrates the
basic ﬂow of app environment and compares diﬀerences of
these two environments.
Dalvik Environment Legacy Android systems (versions
which are less than 4.4) are equipped with Dalvik environ-
ment. Dalvik adopts virtual machine interpretation strategy
at runtime. During the app installation, a dexopt tool will
optimize original dex bytecode such as pre-computing data,
pruning empty methods, and improving virtual method calls.
At runtime, a Dalvik virtual machine will interpret byte-
code and execute architecture speciﬁc native code. Dalvik
VM maintains an internal stack for local variables and argu-
ments. To improve performance, Dalvik also features mod-
ular interpretation and just-in-time compilation.
The modular interpretation technique is to split each op-
code in platform-speciﬁc modules. For example, the add-
int dex operation will be interpreted as ARM assembly in
the OP_ADD_INT_LIT16.S ﬁle. TaintDroid modiﬁed related
modules in the Dalvik VM to implement taint tracking func-
tions.
ART Environment ART was ﬁrst introduced as an exper-
imental environment along with Android 4.4 in 2014. Start-
ing from Android 5.0 in 2015, Google decided to replace
Dalvik and made ART as the default environment. To im-
prove the runtime performance, ART adopts ahead-of-time
(AOT) compilation strategy instead of virtual machine in-
terpretation. ART provides a compiler called dex2oat. The
dex2oat tool will directly compile dex bytecode into native
code during app’s installation and then store as an oat ﬁle.
Because of the AOT compilation, the dex2oat compiler can
perform multiple passes for optimization to achieve better
Figure 2: Comparison between Android Dalvik and
ART environment.
performance. For historical reasons, there are two compiler
backends in the ART compiler which are “quick” backend