在你的电脑上最佳的值是多少？你的电脑CPU有多少个核心？
Goroutines和线程 369
gopl
9.8.4. Goroutine没有ID号
在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的身份(id)，并且这
个身份信息可以以一个普通值的形式被被很容易地获取到，典型的可以是一个integer或者指
针值。这种情况下我们做一个抽象化的thread-local storage(线程本地存储，多线程编程中不
希望其它线程访问的内容)就很容易，只需要以线程的id作为key的一个map就可以解决问题，
每一个线程以其id就能从中获取到值，且和其它线程互不冲突。
goroutine没有可以被程序员获取到的身份(id)的概念。这一点是设计上故意而为之，由于
thread-local storage总是会被滥用。比如说，一个web server是用一种支持tls的语言实现的，
而非常普遍的是很多函数会去寻找HTTP请求的信息，这代表它们就是去其存储层(这个存储
层有可能是tls)查找的。这就像是那些过分依赖全局变量的程序一样，会导致一种非健康的“距
离外行为”，在这种行为下，一个函数的行为可能不是由其自己内部的变量所决定，而是由其
所运行在的线程所决定。因此，如果线程本身的身份会改变——比如一些worker线程之类的
——那么函数的行为就会变得神秘莫测。
Go鼓励更为简单的模式，这种模式下参数对函数的影响都是显式的。这样不仅使程序变得更
易读，而且会让我们自由地向一些给定的函数分配子任务时不用担心其身份信息影响行为。
你现在应该已经明白了写一个Go程序所需要的所有语言特性信息。在后面两章节中，我们会
回顾一些之前的实例和工具，支持我们写出更大规模的程序：如何将一个工程组织成一系列
的包，如何获取，构建，测试，性能测试，剖析，写文档，并且将这些包分享出去。
Goroutines和线程 370
gopl
第十章 包和工具
现在随便一个小程序的实现都可能包含超过10000个函数。然而作者一般只需要考虑其中很小
的一部分和做很少的设计，因为绝大部分代码都是由他人编写的，它们通过类似包或模块的
方式被重用。
Go语言有超过100个的标准包（译注：可以用 命令查看标准包的具体数
go list std | wc -l
目），标准库为大多数的程序提供了必要的基础构件。在Go的社区，有很多成熟的包被设
计、共享、重用和改进，目前互联网上已经发布了非常多的Go语言开源包，它们可以通过
http://godoc.org 检索。在本章，我们将演示如果使用已有的包和创建新的包。
Go还自带了工具箱，里面有很多用来简化工作区和包管理的小工具。在本书开始的时候，我
们已经见识过如何使用工具箱自带的工具来下载、构建和运行我们的演示程序了。在本章，
我们将看看这些工具的基本设计理论和尝试更多的功能，例如打印工作区中包的文档和查询
相关的元数据等。在下一章，我们将探讨testing包的单元测试用法。
包和工具 371
gopl
10.1. 包简介
任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放
进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对
独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、
甚至全球范围统一的分发和复用。
每个包一般都定义了一个不同的名字空间用于它内部的每个标识符的访问。每个名字空间关
联到一个特定的包，让我们给类型、函数等选择简短明了的名字，这样可以在使用它们的时
候减少和其它部分名字的冲突。
每个包还通过控制包内名字的可见性和是否导出来实现封装特性。通过限制包成员的可见性
并隐藏包API的具体实现，将允许包的维护者在不影响外部包用户的前提下调整包的内部实
现。通过限制包内变量的可见性，还可以强制用户通过某些特定函数来访问和更新内部变
量，这样可以保证内部变量的一致性和并发时的互斥约束。
当我们修改了一个源文件，我们必须重新编译该源文件对应的包和所有依赖该包的其他包。
即使是从头构建，Go语言编译器的编译速度也明显快于其它编译语言。Go语言的闪电般的编
译速度主要得益于三个语言特性。第一点，所有导入的包必须在每个文件的开头显式声明，
这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。第二点，禁止包的
环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编
译，而且很可能是被并发编译。第三点，编译后包的目标文件不仅仅记录包本身的导出信
息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取
每个直接导入包的目标文件，而不需要遍历所有依赖的的文件（译注：很多都是重复的间接
依赖）。
包简介 372
gopl
10.2. 导入路径
每个包是由一个全局唯一的字符串所标识的导入路径定位。出现在import语句中的导入路径也
是字符串。
import (
"fmt"
"math/rand"
"encoding/json"
"golang.org/x/net/html"
"github.com/go-sql-driver/mysql"
)
就像我们在2.6.1节提到过的，Go语言的规范并没有指明包的导入路径字符串的具体含义，导
入路径的具体含义是由构建工具来解释的。在本章，我们将深入讨论Go语言工具箱的功能，
包括大家经常使用的构建测试等功能。当然，也有第三方扩展的工具箱存在。例如，Google
公司内部的Go语言码农，他们就使用内部的多语言构建系统（译注：Google公司使用的是类
似Bazel的构建系统，支持多种编程语言，目前该构件系统还不能完整支持Windows环境），
用不同的规则来处理包名字和定位包，用不同的规则来处理单元测试等等，因为这样可以更
紧密适配他们内部环境。
如果你计划分享或发布包，那么导入路径最好是全球唯一的。为了避免冲突，所有非标准库
包的导入路径建议以所在组织的互联网域名为前缀；而且这样也有利于包的检索。例如，上
面的import语句导入了Go团队维护的HTML解析器和一个流行的第三方维护的MySQL驱动。
导入路径 373
gopl
10.3. 包声明
在每个Go语言源文件的开头都必须有包声明语句。包声明语句的主要目的是确定当前包被其
它包导入时默认的标识符（也称为包名）。
例如，math/rand包的每个源文件的开头都包含 包声明语句，所以当你导入这个
package rand
包，你就可以用rand.Int、rand.Float64类似的方式访问包的成员。
package main
import (
"fmt"
"math/rand"
)
func main() {
fmt.Println(rand.Int())
}
通常来说，默认的包名就是包导入路径名的最后一段，因此即使两个包的导入路径不同，它
们依然可能有一个相同的包名。例如，math/rand包和crypto/rand包的包名都是rand。稍后我
们将看到如何同时导入两个有相同包名的包。
关于默认包名一般采用导入路径名的最后一段的约定也有三种例外情况。第一个例外，包对
应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。名字为
main的包是给go build（§10.7.3）构建命令一个信息，这个包编译完之后必须调用连接器生
成一个可执行程序。
第二个例外，包所在的目录中可能有一些文件名是以 为后缀的Go源文件（译注：前
_test.go
面必须有其它的字符，因为以 或 开头的源文件会被构建工具忽略），并且这些源文件声
_ .
明的包名也是以 为后缀名的。这种目录可以包含两种包：一种是普通包，另一种则是
_test
测试的外部扩展包。所有以 为后缀包名的测试外部扩展包都由go test命令独立编译，
_test
普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循
环导入依赖，具体细节我们将在11.2.4节中介绍。
第三个例外，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例
如"gopkg.in/yaml.v2"。这种情况下包的名字并不包含版本号后缀，而是yaml。
包声明 374
gopl
10.4. 导入声明
可以在一个Go语言源文件包声明语句之后，其它非导入声明语句之前，包含零到多个导入包
声明语句。每个导入声明可以单独指定一个导入路径，也可以通过圆括号同时导入多个导入
路径。下面两个导入形式是等价的，但是第二种形式更为常见。
import "fmt"
import "os"
import (
"fmt"
"os"
)
导入的包之间可以通过添加空行来分组；通常将来自不同组织的包独自分组。包的导入顺序
无关紧要，但是在每个分组中一般会根据字符串顺序排列。（gofmt和goimports工具都可以将
不同分组导入的包独立排序。）
import (
"fmt"
"html/template"
"os"
"golang.org/x/net/html"
"golang.org/x/net/ipv4"
)
如果我们想同时导入两个有着名字相同的包，例如math/rand包和crypto/rand包，那么导入声
明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。
import (
"crypto/rand"
mrand "math/rand" // alternative name mrand avoids conflict
)
导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包，可以用导入包原
本默认的名字或重命名为另一个完全不同的名字。
导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很
笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称
重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普
导入声明 375
gopl
通变量名产生冲突。例如，如果文件中已经有了一个名为path的变量，那么我们可以
将"path"标准包重命名为pathpkg。
每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的
情况，Go语言的构建工具将报告错误。
导入声明 376
gopl
10.5. 包的匿名导入
如果只是导入一个包而并不使用导入的包将会导致一个编译错误。但是有时候我们只是想利
用导入包而产生的副作用：它会计算包级变量的初始化表达式和执行导入包的init初始化函数
（§2.6.2）。这时候我们需要抑制“unused import”编译错误，我们可以用下划线 来重命名
_
导入的包。像往常一样，下划线 为空白标识符，并不能被访问。
_
import _ "image/png" // register PNG decoder
这个被称为包的匿名导入。它通常是用来实现一个编译时机制，然后通过在main主程序入口
选择性地导入附加的包。首先，让我们看看如何使用该特性，然后再看看它是如何工作的。
标准库的image图像包包含了一个 函数，用于从 接口读取数据并解码图
Decode io.Reader
像，它调用底层注册的图像解码器来完成任务，然后返回image.Image类型的图像。使
用 很容易编写一个图像格式的转换工具，读取一种格式的图像，然后编码为另
image.Decode
一种图像格式：
gopl.io/ch10/jpeg
包的匿名导入 377
gopl
// The jpeg command reads a PNG image from the standard input
// and writes it as a JPEG image to the standard output.
package main
import (
"fmt"
"image"
"image/jpeg"
_ "image/png" // register PNG decoder
"io"
"os"
)
func main() {
if err := toJPEG(os.Stdin, os.Stdout); err != nil {
fmt.Fprintf(os.Stderr, "jpeg: %v\n", err)
os.Exit(1)
}
}
func toJPEG(in io.Reader, out io.Writer) error {
img, kind, err := image.Decode(in)
if err != nil {
return err
}
fmt.Fprintln(os.Stderr, "Input format =", kind)
return jpeg.Encode(out, img, &jpeg.Options{Quality: 95})
}
如果我们将 （§3.3）的输出导入到这个程序的标准输入，它将解码输
gopl.io/ch3/mandelbrot
入的PNG格式图像，然后转换为JPEG格式的图像输出（图3.3）。
$ go build gopl.io/ch3/mandelbrot
$ go build gopl.io/ch10/jpeg
$ ./mandelbrot | ./jpeg >mandelbrot.jpg
Input format = png
要注意image/png包的匿名导入语句。如果没有这一行语句，程序依然可以编译和运行，但是
它将不能正确识别和解码PNG格式的图像：
$ go build gopl.io/ch10/jpeg
$ ./mandelbrot | ./jpeg >mandelbrot.jpg
jpeg: image: unknown format
下面的代码演示了它的工作机制。标准库还提供了GIF、PNG和JPEG等格式图像的解码器，
用户也可以提供自己的解码器，但是为了保持程序体积较小，很多解码器并没有被全部包
含，除非是明确需要支持的格式。image.Decode函数在解码时会依次查询支持的格式列表。
包的匿名导入 378
gopl
每个格式驱动列表的每个入口指定了四件事情：格式的名称；一个用于描述这种图像数据开
头部分模式的字符串，用于解码器检测识别；一个Decode函数用于完成解码图像工作；一个
DecodeConfig函数用于解码图像的大小和颜色空间的信息。每个驱动入口是通过调用
image.RegisterFormat函数注册，一般是在每个格式包的init初始化函数中调用，例如
image/png包是这样注册的：
package png // image/png
func Decode(r io.Reader) (image.Image, error)
func DecodeConfig(r io.Reader) (image.Config, error)
func init() {
const pngHeader = "\x89PNG\r\n\x1a\n"
image.RegisterFormat("png", pngHeader, Decode, DecodeConfig)
}
最终的效果是，主程序只需要匿名导入特定图像驱动包就可以用image.Decode解码对应格式
的图像了。
数据库包database/sql也是采用了类似的技术，让用户可以根据自己需要选择导入必要的数据
库驱动。例如：