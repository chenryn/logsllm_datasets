一个通用的Javamakefile
...175
编译Java
.179
---
## Page 10
目录
管理jar.
187
引用树与来自第三方的jar文件
189
EnterpriseJavaBeans
190
第十章改进make的效能
194
基准测试.
.194
找出瓶颈与处理瓶颈
..199
并行式make
.202
分布式make
206
第十一章makefile实例
208
本书的makefile
208
Linux内核的makefile
229
第十二章makefile的调试
241
make的调试功能
241
编写用于调试的代码
.248
常见的错误信息
254
第三部分附录
附录一运行make
261
附录二越过make的极限
264
索引
275
---
## Page 11
序
make实用程序是一个令人满意的仆人，它总是随伺在侧、给人方便，对你而言就像是
不可或缺的伙伴。make起初是一个未能充分发挥潜力的职员，你将一些临时的工作去
给它做，然后它渐渐掌控了整个企业（这是许多小说和电影中常见的情节）。
就在每个项目都被我改成以make为基础之际，我的老板一一本书第一版的作者Steve
Talbott注意到了我的狂热行为，邀请我为本书编写第二版。在我的人生历练中这的确是
关键性的成长（也是相当大的冒险），我因此而进入OReilly的美妙世界，但是我们实在
不知道第二版能在市场上存活多久。一版能存活13年吗？
下面的概述列出了自本书第二版发行以来make的发展：
·本书第二版发行时GNU版的make已经是大多数程序员的选择，停然成为业界的
标准。
GNU/Linux的兴起让GNU编译器工具链的使用更为广泛，其中包括GNU版的
make。举例来说，Linux内核本身就相当依赖GNU版make所提供的扩展功能，
正如本书第十一章所描述的那样。
?
以BSD的变体（Darwin）为核心（core）的MacOSX继续向GNU工具链以及
GNU版的make迈进。
越来越多的诀窍被发现，让你能够健全、无错误、可移植及灵活地使用make。对
于大型项目上常见的问题，已经在社群中逐渐形成了标准的解决方案。已经到了将
这些解决方案立言成书的时候了，这就是本书要做的事情。
尤其是出现了将make应用在C++和Java语言中的新需求，make开发出来时这些
语言尚不存在。以下的例子可以说明make出现的年代：最初的make具有两项特
1
---
## Page 12
2
序
殊的功能，一个是支持FORTRAN的两个变体（这个功能还在！），一个是与SCCS
的不怎么有用的集成。
即使有诸多限制，make仍旧是所有计算机开发项目中最重要的工具，恐怕当年对
make的批评者或洞察者都没预料到这一点。这13年来，有意取代make的新工具
如雨后春笋般不断推陈出新，它们都想超越make在设计上的限制，其中也不乏众
多值得赞贯的巧思。不过，make的简单易用仍使它立于不败之地。
当我观察到这些趋势之后，十年前为本书编写新版的想法文涌上心头。不过我意识到自
已的经验浅薄并不足以担负此重责大任。最后，我找到了RobertMecklenburg，他的专
业能力得到O'Reilly所有同仁的肯定。能将这本书交由他全权负责实在太好了，我则退
居幕后成为本书的编辑，这让我的名字又可以出现在本书的版权页上。
Robert对他的博士学位保持低调，不过他思考的深度和精确度却在本书中展露无遗。或
许更重要的是他把焦点放在实用性上。他会告诉你如何执行得更有效率，以及让你知道
如何进行调试。
这是一个重大的时刻：O'Reilly最早期和最持久的一本书出新版了。坐下来，了解一下，
一个保守的小工具何以有此能耐让几乎每个项目都要使用它。不要安于老旧而无法令人
满意的makefile一—开发你的潜力就在今朝。
—Andy Oram
Editor,O'ReillyMedia
August 19,2004
---
## Page 13
前言
迈向第三版
1979年首次遇到make的时候我还是Berkeley的大学生。当时我正为能够使用“最新
的”设备感到兴奋不已：一台DECPDP11/70（具有128kilobytes的RAM）、一台ADM
3a（具有屏幕的终端机）、BerkeleyUnix以及另外20个同时上线的用户！记得有一次，
大家在赶作业的时候从我键人账号名称到我看到命令提示符一共花了5分钟的登录时间。
毕业之后，当我再次使用Unix的时候已经是1984年了，这次我是美国太空总署Ames
研究中心的程序员。我们买了第一部以微型计算机为基础的Unix系统，它的配置包含一
个68000（不是68010或20）微处理器、1megabyte的RAM以及UnixVersion7—
只能有6个同时上线的用户。我所参与的最后一个项目就是使用C程序语言以及yacc/
lex命令语言（当然还包括make）来实现出一个交互式卫星数据分析系统。
1988年，我返回学校并且参与构建“曲线儿何建模”（spline-basedgeometricmodeler）
的项目。这个系统使用了大约120000行的C程序，涵盖了20个左右的可执行文件。这
个系统的编译方法就是使用一个手工打造的工具genmakefile（它的功能类似于
imake）将makefile模板展开成一般的makefile。这个工具会进行简易的文件引l人、条
必须使用此类封装程序（wrapper）才算是完整的编译工具。直到儿年前我发现GNU项
目以及GNUmake，我才了解到大概不再需要封装程序了。我重新建立了不使用模板或
产生器的编译系统。这个编译系统被移植到了5种Unix版本中，并且包括独立的源文件
树和二进制文件树、每夜自动编译，以及以编译系统填补短缺的二进制文件的方式来支
持开发人员进行部分调出的动作。
3
---
## Page 14
4
前言
下一个重要的make使用经验是在1996年。这是一个商用CAD系统，我的工作是将200
万行的C++（以及40万行Lisp）程序从Unix移植到WindowsNT，使用MicrosoftC++
编译器进行编译的工作。我就是在那个时候发现Cygwin项目的。这个编译系统还支持
独立的源文件树和二进制文件树、多种Unix、儿种图形功能、每夜自动编译和测试、以
引用编译结果让开发人员进行部分调出的动作。
2000年，我的工作是以Java编写实验室信息管理系统。这是我工作了那么多年之后首
次遇到的完全不同的开发环境之一。参与项目的程序员大部分来自于Windows背景，而
且Java似平是他们所使用的第一个程序语言。这个编译环境几平是由一个商用Java集
成开发环境（IntegratedDevelopmentEnvironment，简称IDE）所产生的项目文件构成
的。尽管项目文件已经可以使用，但是它却很少被马上拿来使用，程序员们通常会坐在
彼此的屏幕前处理许多编译问题。
当然，我开始使用make来编写编译系统，但是一个奇特的事情发生了：许多开发人员
根本不愿意使用任何命令行工具。此外，许多人无法准确理解环境变量、命令行选项之
类的概念，也不知道这些工具如何用来编译程序。IDE将这些问题都藏起来了。为解决
这些问题，我所编写的编译系统变得更加复杂。我开始加人更好的错误信息、先决条件
的检查、开发人员机器配置的管理以及对IDE的支持。
于是，GNUmake使用手册被我读过不少于10次。当我在寻找更多资料的时候，我发现
到了本书的第二版，它提供了许多有用的数据，不过缺少GNUmake方面的细节。这并
不令人感到惊讶，想想看它的出版时间。这是一本经得起时间考验的书，不过到了2003
年是需要更新了。本书第三版的重点是GNUmake。诚如PaulSmith（GNUmake的维
护者）所说：“编写具可移植性的“makefile是在自找麻烦，使用具可移植性的make吧！”
第三版有哪些新的内容
本书几乎所有内容都是新的。我将这些内容划分成三个部分：
第一部分基本概念。适度说明GNUmake的功能以及这些功能的使用方法。
第一章如何编写简单的makefile。以简单但完整的范例来简介make。这一章将会说明
make的基本概念，如工作目标以及必要条件，并解释makefile的语法。这应该可以让
你具备编写makefile的能力。
第二章规则。将会探讨规则的结构和语法。除了旧式的后缀规则（suffixrule），这一
章还会非常详细地说明具体规则（explicitrule）和模式规则（patternrule）。特殊的工
作目标以及依存关系的产生也会在此处被讨论到。
---
## Page 15
前言
5
第三章变量与宏。将会说明简单变量与递归变量。这一章还会探讨当变量被展并时
makefile是如何被解析的以及条件指令的处理。
第四章函数。将会查看GNUmake所支持的各种内置函数。此处也会以各种范例，包
含一般的与深层次的概念来说明用户自定义函数。
第五章命令。将会说明脚本的细节，内容涵盖脚本的解析与求值。此处也会探讨命令
修饰符、命令结束状态的检查以及环境变量。我们还会探索命令行长度限制的问题，以
及解决这些问题的若干方法。此刻你已经能够了解本书所要探讨的所有GNUmake的
功能。
第二部分深入与特别的议题。包含了比较多的议题，如将make应用在大型项目上、可
移植性以及调试等。
第六章大型项目的管理。将会探讨以make编译大型项目时可能会遇到的许多问题。第
一个议题是如何进行make的递归调用，以及如何使用单一非递归的makefile来实现前
者所用到的许多makefile。此外，我们还会探讨大型系统的其他议题，像文件系统的配
置、项目组件的管理以及自动化编译与测试。
第七章具可移植性的makefile。将会探讨makefile在各种Unix操作系统与Windows系
统间的可移植性。此处还会讨论Cygwin的Unix模拟环境，以及不具可移植性的文件系
统功能与工具所引发的问题。
取的源文件树”的特例。此处会再次提到依存关系分析，不过这次将会强调与程序语言
有关的解决方案。这一章与下一章将会探讨第六章所提到的许多延伸议题。
第九章Java。将会说明如何把make应用在以Java为基础的开发环境中。此处还会提
到管理CLASSPATH变量、编译大量文件、创建jar以及构造EnterpriseJavaBeans的技
术。
第十章改进make的性能。首先会回顾若干make操作的性能特性，以作为如何编写具
有效率的makefile的立论基础。此处还会探讨如何找出和解决瓶颈的技术，以及GNU
make的并行编译功能。
第十一章makefile实例。将会提供两个复杂的makefile实例。第一个实例是用来建立本
书的makefile。这是个值得一看的例子，部分是由于这是对自动化的相当极端的应用，
部分是由于它将make应用在非传统的领域。另一个实例摘录自Linux2.6kbuild系统。
---
## Page 16
6
前言
第十二章makefile的调试。我们将会钻研修复makefile的魔法。这一章将会介绍“如何
发现make背地里在做什么以及如何减轻开发期痛苦”的技术。
第三部分附录。包含了补充资料。
附录一运行make。提供了GNUmake命令行选项的参考指导。
附录二越过make的极限。将会探索GNUmake两个不太可能被用到的功能：管理数
据结构以及进行算数运算。
排版约定
斜体字（Italic）
用来表示新项目、网址、电子邮件地址、文件名、文件扩展名、路径名称以及目录。
等宽字（ConstantWidth）
用来表示源代码命令、命令行选项、文件的内容或是命令的输出。
等宽黑体字（ConstantWidthBold）
用来表示应该由用户逐字键入的命令或其他文字。
等宽斜体字（ConstantWidthItalic）
其所标示的文字应该被替换成用户所提供的值。
范例程序代码的使用办法
这本书可以协助你把工作做好。一般而言，你可以在自己的应用程序和说明文件中使用
本书的程序代码。除非你要重制重要的程序代码，否则不必取得我们的许可。例如，你
使用本书的程序代码片段写了一个应用程序，并不需要取得我们的许可；但是，把
O'Reilly书籍的程序范例制作成光盘贩卖或散布，就需要取得授权。引用本书的文字和
范例程序代码来回答问题，不需要取得许可；但把本书大量的程序范例整合到你的产品
的说明文件中，则需要取得授权。
虽然不是必要，但若能注明来源我们会很感谢。注明来源通常包括书名、作者、出版商
及ISBN。例如：Managing Projects with GNU Make，Third Edition，by Robert
Mecklenburg.Copyright2005O'ReillyMedia,Inc.,0-596-00610-1。
如果你对书中程序范例的使用情况有别于上述情况，不用客气，尽管和我们联络：
PI:EMAIL
---
## Page 17
前言
建议与评论
本书的内容都经过测试，尽管我们做了最大的努力，但错误和疏忽仍然是在所难免的。
如果你发现有什么错误，或者是对将来的版本有什么建议，请通过下面的地址告诉我们：
美国：
O'ReillyMedia,Inc.
1005GravensteinHighwayNorth
Sebastopol,CA95472
中国：
100080北京市海淀区知春路49号希格玛公寓B座809室
奥莱理软件（北京）有限公司
询问技术问题或对本书的评论，请发电子邮件到：
PI:EMAIL
与本书有关的在线信息（包括勘误、范例程序、相关链接）：
原文书
http://www.oreilly.com/catalog/make3/index.html
中文书
http://www.oreilly.com.cn/book.php?bn=7-5641-0352-3
最后，您可以在WWW上找到我们：
http://www.oreilly.com
http://www.oreilly.com.cn
致谢
我要感谢RichardStallman所编织的梦想以及对美梦终能成真的信心。当然，没有Paul
Smith，GNUmake不会有今日的表现，谢谢你。