other messages of this kind and represented by the single
public value exts.
However, since these components comprise part of the
handshake transcript, we establish whether the client and
server agree on these values by the end of the handshake
through the transcript integrity property.
Alert messages. We also do not explicitly model the TLS
alert protocol; our model does not capture errors arising
from deviations in the protocol that would result in the
immediate termination of a connection (fatal alerts), or
acknowledgements of a graceful shutdown (closure alerts).
From the perspective of our model, and the security prop-
erties we are capturing, an alert and subsequent connection
closure is equivalent to a trace which simply does not have
any subsequent rules for that state.
Over-approximations. In certain situations, we assume
that the client/server will send the maximal message load.
the client will always send 0-RTT data.
For example,
Similarly, we model
the server as always including a
CertificateRequest message in the ﬁrst ﬂight. How-
ever, the client does not always send authentication pa-
rameters, and the server does not necessarily accept these
2. Our current analysis therefore does not cover Logjam-style attacks [2].
476476
parameters if sent. Therefore, the possible traces we observe
are equivalent to those in which the server optionally sends
the request.
3.3. Encoding our abstract model in the Tamarin
framework
The second step in our modelling involves encoding the
constructed abstract model as Tamarin rules. At a very high
level, rules capture honest party and adversary actions alike.
In the case of legitimate clients and servers, our constructed
model rules generally correspond to all processing actions
associated with respective ﬂights of messages.
For instance, our ﬁrst client rule captures a client
generating and sending all necessary parameters as part
of the ﬁrst ﬂight of an (EC)DHE handshake, as well as
transitioning to the next client state within the model. In
Figure 5, the let...in block allows us to perform basic
variable substitutions. In practice, this is useful for enforcing
the type of variables, such as C = $C, or for keeping the rule
computations logically separated. We use the variable tid to
name the newly created client thread. The action DH(C,˜a)
allows us to map the private DH exponent ˜a to the client C.
The Start(tid, C, ’client’) action signiﬁes the
instantiation of the client C in the role of ’client’ and
the Running(C, S, ’client’, nc) action indicates
that the client C has initiated a run of the protocol with
the server S, using the fresh value nc as what is known as
the client_random value in TLS. The C1 action simply
marks the occurrence of the C_1 rule with its associated
tid. The St_C_1_init fact encodes the local state of
thread tid, which doubles as a program counter by allowing
the client to recall sending the ﬁrst message in thread tid.
The Out fact represents sending the ﬁrst client message to
the network, whereafter it becomes adversarial knowledge.
Overview of client handshake rules. Figures 6 and 7
capture all relevant model rules and represent the union
of all the options that a client and a server have in a single
execution. We explain the client-side behaviour and map
it to the corresponding transitions while brieﬂy mentioning
the intended server interaction. The client can initiate three
types of handshake: an (EC)DHE handshake (C_1), a PSK
handshake (C_1_PSK) and a 0-RTT handshake (C_1_KC);
we use KC (an abbreviation for Known Conﬁguration) to
denote 0-RTT handshakes. In the (EC)DHE handshake, the
server may reject the client parameters due to a possible
mismatch, whereafter the client needs to provide new param-
eters (C_1_retry). Additionally, the client may optionally
authenticate in the 0-RTT case (C_1_KC_Auth). While
the (EC)DHE and 0-RTT handshakes only have a single
continuation (respectively C_2 and C_2_KC),
the PSK
handshake has two different modes: plain PSK (C_2_PSK)
and PSK with DHE (C_2_PSK_DHE). The latter is used to
obtain PFS guarantees by means of adding an ephemeral
(EC)DH value to the applicable key derivations.
We model the server as always requesting client authen-
tication, but allow traces to capture when the server accepts
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:17:43 UTC from IEEE Xplore.  Restrictions apply. 
C 1 retry
c1−dhe
1
C
start
c0
C 1 PSK
c1−psk
C
1
KC
c1−kc
C 1 KC Auth
C
2
C 2 PSK DHE
C 2 PSK
C
K
2
C
C 2 NoAuth
C 3 NST
c2a
c2
C 2 Auth
C 3
C send
c3
C recv
Client
authentication
ClientHello
Receive ServerHello/Finished +
Send ClientFinished
Figure 6. Partial client state machines for draft-10 as modelled in our Tamarin analysis. The diagram represents the union of all the options for a client
in a single execution. Not depicted are the additional transitions representing a client starting a new handshake using either a PSK established by C_3_NST
or a ServerConfiguration for a 0-RTT handshake. Note that the C_1_KC_Auth edge may only occur once per handshake.
S 1 retry
H E
D
S 1 P S K
start
s0
P S K
1
S
S
1
K
C
Recv
A
uth
S
1
K
C
S
1
NoAuth
A uth R eq
N o A uth
S 1
S 1
s1a−psk
S
1
P
S
K
S
1
PS
K
A
uth
S 2
S 3 NST
s1
s2
S send
s3
S 2 RecvAuth
S 3
S 2 Auth
S recv
s1a
Update authentication status
Process ClientHello +
Send ServerHello
Update authen-
tication state
Receive ClientFinished
(with authentication)
Figure 7. Partial server state machines for draft-10 as modelled in our Tamarin analysis. The diagram represents the union of all the options for a
server in a single execution. Not depicted are the additional transitions representing a server starting a new handshake using either a PSK established by
S_3_NST or a ServerConfiguration for a 0-RTT handshake. Note that the S_2_Auth edge may only occur at most once per handshake.
authentication or not. If the client decides to authenticate,
it sends the authentication messages along with the client
Finished message (C_2_Auth). Otherwise, only the
Finished message is transmitted (C_2_NoAuth). The
handshake concludes with the client either receiving a new
session ticket (C_3_NST), which can be used for resumption
in a later PSK handshake, or doing nothing (C_3). The client
can then proceed to send (C_Send) and receive (C_Recv)
any ﬁnite number of application data messages.
We note that the ﬁgure represents a ‘snapshot’ in time
beyond the initial establishment of a connection. Conse-
quently, it lacks certain states and transitions in which the
client initiates or the server responds to a newly established
connection. We list the omissions here as rules that can
follow a previously executed rule:
C_2→C_1_KC
C_2_KC→C_1_KC
S_1→S_1_KC
S_1_KC→S_1_KC
S_1→S_1_KC_RecvAuth
S_1_KC→S_1_KC_Recvauth
C_3_NST→C_1_PSK
S_3_NST→S_1_PSK
S_3_NST→S_1_PSK_DHE
•
•
•
•
•
•
•
•
•
477477
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:17:43 UTC from IEEE Xplore.  Restrictions apply. 
rule C_1:
let
// Default C1 values
tid = ˜nc
= $C
// Client Hello
C
nc = ˜nc
pc = $pc
S
= $S
// Client Key Share
ga
= ’g’ˆ˜a
messages = 
in
[ Fr(nc)
, Fr(˜a)
]
--[ C1(tid)
, Start(tid, C, ’client’)
, Running(C, S, ’client’, nc)
, DH(C, ˜a)
]->
[ St_C_1_init(tid, C, nc, pc, S,
˜a, messages, ’no_auth’)
, Out()
]
Figure 5. Rule C 1 in our Tamarin model of TLS 1.3 draft-10
Managing model complexity. The complexity of TLS 1.3
presents an interesting challenge for automated symbolic
analysis. As Figures 6 and 7 demonstrate, the introduction of
new handshake modes has dramatically increased the number
of state transitions in comparison to TLS 1.2.
In software engineering, conditional branches are a fairly
mundane part of code. For example, the code might perform
the check: “if received client authentication then verify
signature and set client status to authenticated else do
nothing”. However, in Tamarin we require two distinct state
transitions representing these two possibilities.
The TLS handshake exhibits such conditional branching.
Ideally, branches would be represented by as few rules as
possible, which can be done by merging some of the resulting
states into one. For example, by the end of the server’s
ﬁrst phase, the state needs to contain a transcript of the
received messages, the computed values of ss and es, and
the authentication status of the client.
While all four handshake modes will compute these
values in a different way, from the point of computation
onwards the server’s behaviour does not depend on the
handshake mode. Therefore these can be merged into the
resulting s1 state.
With this approach, we can create simple rules that ensure
the composability of the various protocol modes and closely
follow the original speciﬁcation. For example, the numbering
of states (c1, c2, etc.) corresponds to message ﬂights. In some
cases, we require two rules to construct a single message
ﬂight, e.g., C_2 and C_2_Auth, wherein a client optionally
adds a signature to its ﬁnal handshake message.
3.4. Examples of complex interactions
By deﬁning the client and server rules as outlined above,
we now have the ability to model the interaction of an
478478
unbounded number of interleaved handshakes. That is, while
we express properties in terms of a client and a server,
there may exist an unbounded number of other interacting
agents, which the adversary may additionally compromise
through revealing their long-term keys. The adversary can
then impersonate these agents, leading to an increase in the
number of possible interactions.
Consider the following scenario: a client and a server
have derived session keys after agreeing to use a PSK. We
know that at some point the client must have authenticated
the server (assuming the PSK is not from the out-of-band
mechanism). However, we potentially need to resolve an
unbounded number of handshakes before we arrive at the
initial handshake in which the client veriﬁed the server’s
signature. The Tamarin prover allows us to reason induc-
tively about such scenarios, facilitating the veriﬁcation of
important security properties that are typically out of reach
of backwards unfolding.
Our Tamarin model is available for inspection at [1].
4. Formal analysis of the model
In this section, we provide the details of our analysis. In
particular, we describe our threat model, the required security
properties and how we formally model them in Tamarin. We
then give our analysis results, reﬂect on our ﬁndings and
provide recommendations for the TLS Working Group.
4.1. General approach and threat model
Our aim is to analyse the core security properties of the
TLS 1.3 protocol. The work on TLS 1.3 to date generally
considers subprotocols in isolation. Our work, as explained
in the previous section, also considers all the possible
complex interactions between the various subprotocols. For
these interactions, we prove both secrecy and authentication
properties.
The threat model that we consider in our analysis is an
active network adversary that can compromise the long-term
keys of agents. In particular, we consider adversaries that can
compromise the long-term keys of all agents after the thread
under attack ends (to capture PFS) as well as the long-term
keys of agents that are not the actor or the intended peer
of the attacked thread, at any time (to capture Lowe-style
MITM attacks and to contain the consequences of long-term
key compromise). Moreover, we include limited support for
Actor Key Compromise [8] by allowing the adversary to
reveal the long-term keys of the client when verifying the
unilateral authentication properties and the secrecy of early
data keys.
Similarly to standard AKE models, our threat model
has two components: the Tamarin rule that encodes the full
capability (i.e., the ability to compromise an agent’s long-
term private key) and a restriction on the security notion
that prevents the adversary from compromising all the keys
(corresponding to the fresh/clean predicates in AKE models).
We give the rule here, and return to the restrictions when
we describe the speciﬁc properties.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:17:43 UTC from IEEE Xplore.  Restrictions apply. 
rule Reveal_Ltk:
[ !Ltk($A, ˜ltkA) ] --[ RevLtk($A) ]-> [ Out(˜ltkA) ]
This rule can be triggered if a long-term private key ˜ltkA
was previously generated for the agent $A. The right-hand