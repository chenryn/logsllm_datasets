and solved by Z3.
To generate server-side execution traces, we leveraged
Xdebug [5], an open source debugger for PHP code.
Note that Xdebug, like any debugging tool, imposes per-
formance issues such as HTTP responses delays due to
trace generation. Therefore, to maintain acceptable per-
formance, NAVEX invokes Xdebug and analyzes traces
on demand.
Broadly, the techniques implemented in NAVEX can
be used to generate exploits for non-PHP web applica-
tions. At an implementation level, NAVEX is applicable
to other server-side languages if the target source code is
represented as CPGs, models of the target language fea-
tures (i.e., built-in functions, operators, etc.) as solver
speciﬁcations are available, and suitable server-side exe-
cution tracing tool is used.
NAVEX is an open-source software available at
https://github.com/aalhuz/navex
5 Evaluation
Dataset. We evaluated NAVEX on 26 real-world PHP ap-
plications with a combined codebase of 3.2M SLOC and
22.7K PHP ﬁles as shown in Table 1. Our criteria for se-
lecting the applications include: (i) evaluation on the lat-
est versions of popular, complex and large PHP applica-
tions such as Joomla, HotCRP, and WordPress, and
(ii) comparison of NAVEX on the same test applica-
tions used by state-of-the-art work in exploit genera-
tion (e.g., Chainsaw [7]) and vulnerability analysis (e.g.,
RIPS [15], [16]).
Setup. NAVEX was deployed on Ubuntu 12.04 LTS
VM with 2-cores of 2.4GHz each and 40GB RAM. We
ﬁrst generated the enhanced CPG and used it to ﬁnd ex-
ploitable paths for all the 26 applications. Then, we de-
ployed the applications that have exploitable paths. The
deployment process includes: installing each application
on a server, creating login credentials for each role, and
populating the application database with initial data by
navigating the application and submitting forms when
necessary. We take a snapshot of each application’s
database and use it after each crawling to restore the orig-
inal state of the database. Note that due to speciﬁc de-
ployment instructions for each application, we could not
leverage automation to include more applications to eval-
uate. Given ample time for manual deployment, NAVEX
Application (version)
myBloggie (2.1.4)
Scarf Beta
DNscript
WeBid (0.5.4)
Eve (1.0)
SchoolMate (1.5.4)
geccbblite (0.1)
FAQforge (1.3.2)
WebChess (0.9)
WordPress (4.7.4)
HotCRP (2.100)
HotCRP (2.60)
Zen-Cart (1.5.5)
OpenConf (6.71)
osCommerce (2.3.4)
osCommerce (2.3.3)
Drupal (8.3.2)
Gallery (3.0.9)
Joomla (3.7.0)
LimeSurvey (3.1.1)
Collabtive (3.1)
Elgg (2.3.5)
CPG (1.5.46)
MediaWiki (1.30.0)
phpBB (2.0.23)
phpBB (3.0.11)
56
19
60
300
8
63
11
17
29
699
145
43
1010
134
684
541
8626
510
2764
3217
836
3201
359
3680
74
387
9090
978
1322
65302
905
15375
323
1676
5219
181257
57717
14870
109896
21108
63613
49378
585094
39218
302701
965164
172564
215870
305245
537913
29164
158756
PHP Files
PHP SLOC
Table 1: Subject applications of our evaluation.
AST, CFG, PDG, and sanitization and DB tags generation
Graph database size
Total # nodes
Total # edges
1hr 25m
4.15 GiB
24,418,552
56,060,195
Table 2: Statistics on the enhanced CPG generation.
can be used to analyze and generate exploits for hundreds
or thousands of applications.
Summary of results. NAVEX constructed a total of 204
exploits, of which 195 are on injection, and 9 are on logic
vulnerabilities. The sanitization-tags-enhanced CPG re-
duced false positives (FPs) by 87% on average. The in-
clusion of client-side code analysis for building the navi-
gation graph enhanced the precision of exploit generation
by 54% on average. On the evaluation set, NAVEX was
able to drill down as deep as 6 HTTP requests to stitch
together exploits.
Enhanced code property graph statistics. For all the
applications under test, Table 2 shows the enhanced CPG
construction time and size. Note, the enhanced graph
represents the source code of all the 26 applications un-
der test, indicating the low runtime overhead of NAVEX.
Navigation graph statistics. Table 3 summarizes the
total time to generate concrete exploits in Step II of
NAVEX. The application list in the table represents the
applications for which NAVEX found exploitable paths.
Therefore, if an application did not have any exploitable
path, NAVEX will not model its navigation behavior. The
number of roles reﬂects the number of all account types
(privileges) for each application. The NG has approxi-
mately 59K nodes and 1M edges.
5.1 Exploits
SQLI
Exploits. NAVEX
examined
calls
to
386    27th USENIX Security Symposium
USENIX Association
Application
myBloggie
SchoolMate
WebChess
Eve
geccbblite
Scarf
FAQforge
WeBid
DNscript
phpBB2
HotCRP (2.60)
osCommerce (2.3.3)
CPG
MediaWiki
LimeSurvey
osCommerce (2.3.4)
OpenConf
Gallery3
Collabtive
Total time
Graph database size
Total Crawling, Forms Spec.
Generation, Solving Time
& NG Building Time
2m
0
1m 36sec
1m 5sec
57sec
1m 44sec
47sec
9m 29sec
51sec
2m 14sec
30m 13sec
2hr 6m 32sec
24m 40sec
15m 30sec
46sec
2hr 19m 1sec
2m 1sec
5m 51sec
24m 2sec
6hr 27m 18sec
104.44 MiB
# of
Roles
2
5
2
1
1
2
1
2
1
2
4
2
2
1
2
2
2
2
3
Table 3: Statistics on the Navigation graph generation.
mssql query, mysql query, mysqli query,
and sqlite query as sinks for SQLI vulnerability.
It reported a total of 155 SQLI exploitable sinks with
a running time of 37m and 45sec.
it
generated 105 concrete SQLI exploits in 7m and 76sec
as summarized in Table 4.
From these,
NAVEX generated SQLI exploits for all applications
that have SQLI exploitable sinks (seeds) except for
SchoolMate.
In SchoolMate, the crawler recovered
only three HTTP requests. This application has 5 differ-
ent roles, and for each role, our crawler was able to log
in successfully. However, each time the crawler sends
an HTTP request after the login, the application redi-
rects the execution to the login page, which means that
the application does not properly maintain user sessions.
Therefore, the crawler did not proceed, and the cover-
age was low. This faulty application was chosen in our
evaluation mainly to compare the results of NAVEX with
other related work that included it in their test applica-
tions. The reported exploitable sinks, nevertheless, are
conﬁrmed to be true positives (TPs).
Selected SQLI Exploit.
One of the applications
for which NAVEX generated a large number of SQLI
exploits is WeBid. Listing 4 shows an exploitable sink
located in the user interface. An authenticated user can
check other users’ messages (line 3), consequently, the
messages will be ﬂagged as read (line 6). The generated
exploit for both sinks is in Listing 5.
1 $messageid = $_GET[’id’]; //no sanitization
2 //1st vul. query
3 $sql = "SELECT * FROM ’".$DBPrefix."messages’ WHERE
’id’=’$messageid’";
4 ....
5 //2nd vul. query
6 $sql = "UPDATE ’".$DBPrefix."messages’ SET ’read’=’1’ WHERE
’id’=’$messageid’";
Listing 4: Simpliﬁed code for SQLI vulnerability in WeBid.
SQLI Exploits
22
0
1
40
5
0
4
14
13
1
5
105
Application
myBloggie
Scarf
DNscript
WeBid
Eve
SchoolMate
geccbblite
FAQforge
WebChess
osCommerce (2.3.3)
phpBB (2.0.23)
Total
SQLI Exp.
Sinks
22
0
1
40
5
50
4
14
13
1
5
155
TPs
22
0
1
40
5
50
4
14
13
1
5
155
FPs
0
0
0
0
0
0
0
0
0
0
0
0
Table 4: Summary of the generated SQLI exploitable sinks
and exploits.
XSS Exp. Sinks
XSS exploits
Application
myBloggie
Scarf