# Memory    used_memory:1039136在使用 String 类型时，每个记录需要消耗 64 字节，这种方式却只用了 16字节，所使用的内存空间是原来的1/4，满足了我们节省内存空间的需求。不过，你可能也会有疑惑："二级编码一定要把图片 ID 的前 7 位作为 Hash类型的键，把最后 3 位作为 Hash 类型值中的 key吗？"**其实，二级编码方法中采用的 ID长度是有讲究的**。在 [第 2讲  slate-object="inline"中，我介绍过 Redis Hash类型的两种底层实现结构，分别是压缩列表和哈希表。那么，Hash类型底层结构什么时候使用压缩列表，什么时候使用哈希表呢？其实，Hash类型设置了用压缩列表保存数据时的两个阈值，一旦超过了阈值，Hash类型就会用哈希表来保存数据了。这两个阈值分别对应以下两个配置项：1.  hash-max-ziplist-entries：表示用压缩列表保存时哈希集合中的最大元素个数。        2.  hash-max-ziplist-value：表示用压缩列表保存时哈希集合中单个元素的最大长度。        如果我们往 Hash 集合中写入的元素个数超过了hash-max-ziplist-entries，或者写入的单个元素大小超过了hash-max-ziplist-value，Redis 就会自动把 Hash类型的实现结构由压缩列表转为哈希表。一旦从压缩列表转为了哈希表，Hash类型就会一直用哈希表进行保存，而不会再转回压缩列表了。在节省内存空间方面，哈希表就没有压缩列表那么高效了。**为了能充分使用压缩列表的精简内存布局，我们一般要控制保存在 Hash集合中的元素个数**。所以，在刚才的二级编码中，我们只用图片 ID 最后 3 位作为Hash 集合的 key，也就保证了 Hash 集合的元素个数不超过 1000，同时，我们把hash-max-ziplist-entries 设置为 1000，这样一来，Hash集合就可以一直使用压缩列表来节省内存空间了。小结这节课，我们打破了对 String 的认知误区，以前，我们认为 String是"万金油"，什么场合都适用，但是，在保存的键值对本身占用的内存空间不大时（例如这节课里提到的的图片ID 和图片存储对象 ID），String类型的元数据开销就占据主导了，这里面包括了 RedisObject 结构、SDS结构、dictEntry结构的内存开销。针对这种情况，我们可以使用压缩列表保存数据。当然，使用 Hash这种集合类型保存单值键值对的数据时，我们需要将单值数据拆分成两部分，分别作为Hash 集合的键和值，就像刚才案例中用二级编码来表示图片ID，希望你能把这个方法用到自己的场景中。最后，我还想再给你提供一个小方法：如果你想知道键值对采用不同类型保存时的内存开销，可以在这个网址slate-object="inline"里输入你的键值对长度和使用的数据类型，这样就能知道实际消耗的内存大小了。建议你把这个小工具用起来，它可以帮助你充分地节省内存。每课一问按照惯例，给你提个小问题：除了 String 类型和 Hash类型，你觉得，还有其他合适的类型可以应用在这节课所说的保存图片的例子吗？欢迎在留言区写下你的思考和答案，我们一起交流讨论，也欢迎你把今天的内容分享给你的朋友。