2ğœ†)â„Ã—1 having a
1-hot sum (cid:174)ğ‘ 0 + (cid:174)ğ‘ 1 whose sole non-zero element resides
in the ğ‘th row and has a least-significant bit of 1;
3) computes (cid:174)ğ‘£ (cid:66) ğº((cid:174)ğ‘ 0[ğ‘]) + ğº((cid:174)ğ‘ 1[ğ‘]) + (ğ‘€ (cid:174)ğ‘’ğ‘Ÿ), where (cid:174)ğ‘ 0[ğ‘]
and (cid:174)ğ‘ 1[ğ‘] respectively denote the ğ‘th rows of (cid:174)ğ‘ 0 and (cid:174)ğ‘ 1,
and where (cid:174)ğ‘’ğ‘Ÿ âˆˆ (F
2ğ¿)1Ã—ğ‘¤ is the standard basis vector
having a 1 in its ğ‘Ÿ th column; and then, finally,
2) samples two column vectors (cid:174)ğ‘ 0, (cid:174)ğ‘ 1 âˆˆR (F
2ğ¿ to the bulletin board, the sender
2ğœ† â†’ (F
4) sends ((cid:174)ğ‘ ğ‘, (cid:174)ğ‘£) to server ğ‘ for ğ‘ = 0, 1.
Upon receiving ((cid:174)ğ‘ ğ‘, (cid:174)ğ‘£), server ğ‘ forms the matrix
which it adds component-wise to the bulletin board to
effectuate the write.
An easy calculation verifies that ğ‘€0 + ğ‘€1 âˆˆ (F
2ğ¿)â„Ã—ğ‘¤ has
message ğ‘€ in its (ğ‘, ğ‘Ÿ)th component and zero elsewhereâ€”
provided the sender generated the ((cid:174)ğ‘ ğ‘, (cid:174)ğ‘£) honestly, which the
servers confirm via the audit protocol. In the audit protocol,
2ğ¿)1Ã—ğ‘¤, and
server ğ‘ sums the rows of ğ‘€ğ‘ to get (cid:174)ğ‘šğ‘ âˆˆ (F
then all three servers run a secure (2+ 1)-party computation
to verify that (cid:174)ğ‘š0 + (cid:174)ğ‘š1 is indeed 1-hot. Notice that auditing
requires O(ğ‘› ğ¿) work by each of server 0 and server 1.
a) Express: The state-of-the-art system in the sender-
is the Express scheme of Es-
anonymous mailbox model
kandarian, Corrigan-Gibbs, Zaharia, and Boneh [14]. Express
uses O(lg ğ‘›)-sized DPFs of Boyle, Gilboa, and Ishai [5] to
2As a hedge against this aggressively high collision rate, Riposte users can
write ordered pairs of the form (ğ‘€, ğ‘€2). This way, if a collision places two
messages ğ‘€ and Â¯ğ‘€ in the same bucket, both recipients will receive the pair
(ğ‘€+ Â¯ğ‘€, ğ‘€2+ Â¯ğ‘€2) from which they can recover ğ‘€âˆ’ Â¯ğ‘€ = (ğ‘€2+ Â¯ğ‘€2)(ğ‘€+ Â¯ğ‘€)âˆ’1
and, thereby, solve for ğ‘€ and Â¯ğ‘€.
ğº((cid:174)ğ‘ ğ‘[0])
ğº((cid:174)ğ‘ ğ‘[1])
...
ğº((cid:174)ğ‘ ğ‘[â„ âˆ’ 1])
 + (cid:174)ğ‘£ Â·
ğ‘€ğ‘ (cid:66)
lsb((cid:174)ğ‘ ğ‘[0])
lsb((cid:174)ğ‘ ğ‘[1])
...
lsb((cid:174)ğ‘ ğ‘[â„ âˆ’ 1])
 âˆˆ (F2ğ¿)â„Ã—ğ‘¤ ,
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 14:58:18 UTC from IEEE Xplore.  Restrictions apply. 
21954
implement oblivious writes into pre-registered mailboxes.
Specifically, a recipient registers a mailbox with the servers
and receives a uniform ğœ†-bit string addr (the â€œmailbox ad-
dressâ€). A sender can deposit a message into the mailbox if
and only if it knows addr. If the registered mailboxes form
a negligibly sparse subset of {0, 1}ğœ†, then attempts to guess
a valid address fail with overwhelming probability.
Express requires (and supports) just two servers. Con-
sider an Express instance with security parameter ğœ† âˆˆ N
(say, ğœ† = 128) having ğ‘› registered mailboxes addressed
by addr1, . . . , addrğ‘›. To deposit a message ğ‘€ âˆˆ F
2ğ¿ into
the mailbox addressed by addrğ‘–, the sender samples a DPF
representation (dpf0, dpf1) of ğ‘€ (cid:174)ğ‘’addrğ‘– , where (cid:174)ğ‘’addrğ‘– âˆˆ (F
2ğ¿)1Ã—2ğœ†
is the standard basis vector having a 1 in its (addrğ‘–)th column,
and then it sends dpfğ‘ to server ğ‘ for ğ‘ = 0, 1.
Upon receiving dpfğ‘, server ğ‘ expands it to the vector
ğ‘€ğ‘ âˆˆ (F
2ğ¿)1Ã—ğ‘› in which the ğ‘— th component is obtained by
evaluating dpfğ‘ at addrğ‘— for ğ‘— = 1, . . . , ğ‘›; server ğ‘ adds ğ‘€ğ‘ to
its mailbox database to effectuate the write.
2ğ¿)1Ã—ğ‘› has
An easy calculation verifies that ğ‘€0 + ğ‘€1 âˆˆ (F
message ğ‘€ in its ğ‘– th column and zero elsewhereâ€”provided
the sender generated (dpf0, dpf1) honestly, which the servers
confirm via the audit protocol. In the audit protocol, the
two servers engage in a secret-shared non-interactive proof
(SNIP) to verify that ğ‘€0 + ğ‘€1 is (at-most-)1-hot. Notice that
auditing requires O(ğ‘› ğœ†) workâ€”i.e., O(ğ‘›) evaluations of the
DPF costing O(ğœ†) length-doubling PRG evaluations a pieceâ€”
by each of server 0 and server 1.
D. De lâ€™Ã‰pÃ©e au Sabre
We present Sabre, a family of SAM protocols with in-
stances operating in both the bulletin-board and mail-
box models. Sabre protocols inherit much of their basic
structure from Riposte and Express, but incorporate key
innovations that improve not only concrete performance
and scalability under normal operations, but also resilience
to resource exhaustion-style DoS attacks in the mailbox
model.
From a technical perspective, the primary difference is how
Sabre implements auditing to identify malformed write re-
quests: the senders construct compact (2- or 3-verifier) SNIPs
that â€œdirectlyâ€ attest to the well-formedness of the DPFs they
submit. We construct the SNIPs in a novel paradigm we call
multi-verifier MPC-in-the-head, which generalizes the (single-
verifier) MPC-in-the-head paradigm of
Ishai, Kushilevitz,
Ostrovsky, and Sahai [19] to achieve good soundness at low
cost in scenarios where two or more distinct verifiers can
check two or more distinct subsets of simulated interaction
transcripts. In the sender-anonymous mailbox model, Sabre
also uses a new trick to decouple the cost of DPF evaluation
from the bit length of the mailbox addresses. Together, these
modifications yield speedups that exceed an order of magni-
tude relative to Express when all the write requests are â€œwell-
formedâ€ and increase significantlyâ€”with the performance
gap growing exponentially in the number of mailboxesâ€”in
the presence of resource-exhaustion DoS attacks.
ğ‘£ (ğœ€)
ğ‘£ (0)
ğ‘£ (1)
ğ‘£ (00)
ğ‘£ (01)
ğ‘£ (10)
ğ‘£ (11)
0
0
0
0
0 ğ’š
0
0
Fig. 1: Binary-tree representation of the generalized
point function with point (ğ‘¥5, ğ‘¦) âˆˆ ğ· Ã— ğ‘…, |ğ·| = 23.
As with both Riposte and Express, the correctness of Sabre
requires that all servers faithfully audit all incoming DPFsâ€”
that is, none of these protocols can operate in the presence
of Byzantine servers. However, like Express, Sabreâ€™s reliance
on non-interactive (SNIP-based) auditing deprives would-
be malicious servers of the opportunity to deviate from
the protocol
in ways that might leak information about
the mapping between writers and the messages they have
penned.
E. Our Contributions
The main contribution of this paper is the design and
evaluation of the Sabre family of SAM protocols. Sabre
protocols are more performant than prior work by a (signifi-
cant) constant factor when there is no attacker and they are
asymptotically faster in the presence of DoS attacks. Toward
the construction of Sabre, we make several contributions of
independent interest, including
1) an efficient secure (2 + 1)-party computation for the
oblivious evaluation of O(lg ğ‘›)-sized DPFs;
2) fast SNIPs from â€œmulti-verifierâ€ MPC-in-the-head;
3) non-interactive zero-knowledge arguments of knowl-
edge for the well-formedness of O(lg ğ‘›)-sized DPFs;
and O(lg ğ‘›)-sized DPF evaluation; and
4) parallel (bitsliced) implementations of fixed-key LowMC
5) a novel, constant-complexity mailbox address check.
II. Building Blocks
This section gives a brief overview of the various building
blocks used to construct Sabre.
A. Distributed point functions
A ğ‘¡-out-of-â„“ distributed point function, or (ğ‘¡, â„“)-DPF,
is
a compact (ğ‘¡, â„“)-threshold shared representation of a so-
called (generalized) point function. Sabre and the related SAM
constructions we consider exclusively use (2, 2)-DPFs (that is,
the special case of ğ‘¡ = â„“ = 2); thus, for brevity, we generally
omit the (2, 2)- qualifier and refer merely to â€œDPFsâ€.
1) (Non-distributed) point functions: Fix a domain ğ· âŠ†
{0, 1}âˆ— and range ğ‘… (a ring with unity), and let 0 and 1 denote
the additive and multiplicative identities in ğ‘….
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 14:58:18 UTC from IEEE Xplore.  Restrictions apply. 
31955
Definition 1. The point function at ğ‘¥ âˆˆ ğ· over ğ‘… is the
function Pğ‘¥ : ğ· â†’ ğ‘… defined via
(cid:40)
Pğ‘¥(ğ‘–) (cid:66)
1 if ğ‘– = ğ‘¥, and
0 otherwise.
That is, the point function at ğ‘¥ âˆˆ ğ· over ğ‘… is 0 everywhere
except at ğ‘¥ where it is 1. Alternatively, one can think of it as
a â€œfunctional representationâ€ of a vector from the standard
basis of a |ğ·|-dimensional module over ğ‘….
A â€œgeneralizedâ€ point function is just a point function
scaled by some value from its range.
Definition 2. If Pğ‘¥ : ğ· â†’ ğ‘… is the point function at ğ‘¥ âˆˆ ğ·
over ğ‘… and if ğ‘¦ âˆˆ ğ‘… is a fixed scalar, then Pğ‘¥,ğ‘¦ : ğ‘– â†¦â†’ ğ‘¦Â·Pğ‘¥(ğ‘–) is
the generalized point function with point (ğ‘¥, ğ‘¦) âˆˆ ğ· Ã— ğ‘….
is 0) or to the right child (if the next bit of ğ‘—
Point functions as binary trees: Suppose ğ· âŠ† {0, 1}âˆ— is
a well-ordered set with cardinality 2â„. One can naturally
represent the generalized point function with point (ğ‘¥, ğ‘¦) âˆˆ
ğ· Ã— ğ‘… by a complete binary tree of height â„ having one
leaf node labelled â€œğ‘¦â€ and all other leaf nodes labelled â€œ0â€.
To evaluate the point function on input ğ‘¥ ğ‘— âˆˆ ğ· â€”the â€œğ‘— th-
smallestâ€ element of ğ· â€”begin at the root and parse the
binary-string representation of ğ‘— bit-by-bit from left to right,
iteratively traversing either to the left child (if the next bit
of ğ‘—
is 1)
of the current node until eventually arriving at a leaf. The
label on this leaf defines the output of the point function on
input ğ‘¥ ğ‘—. Figure 1 depicts the binary-tree representation of
the generalized point function with point (ğ‘¥5, ğ‘¦) âˆˆ ğ· Ã— ğ‘…,
where ğ· has cardinality 23.
Before describing distributed point functions, we elaborate
on some properties of such binary-tree representations that
will prove useful in constructing the Sabre audit protocol. We
first observe that such a tree comprises two distinct kinds of
nodes, which we refer to as type-0 nodes and type-1 nodes. For
brevity, we sometimes use 0-nodes and 1-nodes to reference
type-0 nodes and type-1 nodes, respectively.
Definition 3. A node is of type 0 if it is either (i) a leaf with
label â€œ0â€, or (ii) a non-leaf and both of its children are of type
0; the node is of type 1 if it is either (i) a leaf with a label
other than â€œ0â€, or (ii) a non-leaf with one type-1 child and one
type-0 child.
The next observation follows from Definition 3.
Observation 1. If a tree is rooted at a 0-node, then all of its
leaves are of type 0; if it is rooted at a 1-node, then exactly one
of its leaves is of type 1 and all others are of type 0.
The proof of Observation 1 is by induction on the tree
height â„; it appears in Appendix A.
Observation 1 implies that any tree rooted at a 1-node
contains exactly one path consisting entirely of 1-nodes from
the root to some leaf node (and, moreover, that all 1-nodes
reside along this path). We refer to such a path as a type-1
path through the tree (or a 1-path for short). For example,
the highlighted path in Figure 1 is the 1-path: every node on
it is type 1 while every node not on it is type 0.
The above notions of 1-nodes and 1-paths give us some
alternative ways to characterize the representation of gener-
alized point functions as binary trees.
Corollary 1. The following three characterizations are all
equivalent: A complete binary tree of height â„ represents a
generalized point function if and only if
1) exactly one leaf has type 1 and all others have type 0;
2) its root has type 1; or
3) it contains a 1-path of height â„.
The first characterization in Corollary 1 is appealing be-
cause it most directly maps to the definition of a generalized
point function (as stated in Definition 2); however, looking
ahead, the third characterization will prove particularly con-
venient because it references just â„ nodes on a path from
the root to a leaf, as opposed to all 2â„ leaves. (The second
references just one node, yet the property of being a 1-node
implicitly references a 1-path rooted at that node.)
2) 2-out-of-2 distributed point functions: We now present a
formal definition of (2, 2)-DPFs based on those of Gilboa and
Ishai [17] and Boyle, Gilboa, and Ishai [5], [6].
Definition 4. A (2, 2)-distributed point function, or (2, 2)-
is a pair of PPT algorithms (Gen, Eval) defining an
DPF,
infinite family of secret-shared representations of generalized
point functions; that is, given (i) a security parameter ğœ† âˆˆ N,
(ii) a domain ğ· and range ğ‘…, and (iii) a distinguished point
(ğ‘¥, ğ‘¦) âˆˆ ğ· Ã— ğ‘…, we have
1. Correctness: If (dpf0, dpf1) â† Gen(1ğœ†, ğ·, ğ‘…; ğ‘¥, ğ‘¦), then,
for all ğ‘– âˆˆ ğ·,
(cid:40) ğ‘¦ if ğ‘– = ğ‘¥, and
0 otherwise.
Eval(dpf0, ğ‘–) + Eval(dpf1, ğ‘–) (cid:66)
2. Simulatability: There exists a PPT simulator S such that,
for any given domain ğ·, range ğ‘…, distinguished point
(ğ‘¥, ğ‘¦) âˆˆ ğ·Ã—ğ‘…, and bit ğ‘ âˆˆ {0, 1}, the distribution ensembles
(cid:8)S(1ğœ†, ğ·, ğ‘…; ğ‘)(cid:9)
and
(cid:8)dpfğ‘
ğœ†âˆˆN
(cid:12)(cid:12) (dpf0, dpf1) â† Gen(1ğœ†, ğ·, ğ‘…; ğ‘¥, ğ‘¦)(cid:9)
ğœ†âˆˆN
are computationally indistinguishable.
The dpfğ‘ output by Gen are called (2, 2)-DPF keys; the ğ‘¥-
coordinate of the distinguished point is the distinguished input.
3) The Boyle-Gilboa-Ishai DPF construction: The most com-
pact DPF representation in the literature is due to Boyle,
Gilboa, and Ishai [6]. Their construction uses a length-
doubling PRG to define a pair of â€œsecret-sharedâ€ binary trees
that collectively represent some generalized point function.
Let ğº2Ã— : {0, 1}âˆ— â†’ {0, 1}âˆ— be any length-doubling PRG and
2ğ¿ : {0, 1}âˆ— â†’ F
2ğ¿ be a PRG with ğ¿-bit outputs. Boyle et
ğº
al.â€™s construction follows from the simple observation that
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 14:58:18 UTC from IEEE Xplore.  Restrictions apply. 
41956
ğº2Ã—(ğ‘Ÿ0) = ğº2Ã—(ğ‘Ÿ1) if and (essentially) only if ğ‘Ÿ0 = ğ‘Ÿ1; that is,
length-doubling PRGs map additive shares of 0 to additive
shares of (0, 0), while they map additive shares of ğ‘¥ â‰  0 to
additive shares of (ğ‘¦, ğ‘§) such that both ğ‘¦ â‰  0 and ğ‘§ â‰  0 with
a probability overwhelming in |ğ‘¥|.
In the context of binary-tree representations of generalized
point functions, this roughly equates to observing that ğº2Ã—
preserves the property of being a 0-node. The challenge is
now to extend this so that ğº2Ã— preserves node type for all
nodes in the tree, be they the 0-nodes that comprise most of
the tree or the 1-nodes along the path from the root to the
distinguished point. To this end, the DPF keys include one
ğœ†-bit correction word (CW) per tree level, which is specially
crafted to map exactly one child of the 1-node on that level to
a 0-node. Finally, ğº
2ğ¿ â€œstretchesâ€ each node in the final (i.e.,
leaf) level into a pseudorandom ğ¿-bit value, and then a final
ğ¿-bit CW maps the leaf-level 1-node to the desired output ğ‘¦ âˆˆ
ğ‘…. We elaborate on the semantics of CWs when constructing
our (2+ 1)-party computation for DPF auditing in Section V;
for now, we emphasize only that this approach yields very
compact DPF keys, each comprising a length-â„ (i.e., length-
âŒˆlg|ğ·|âŒ‰) sequence of ğœ†-bit values, plus one additional ğ¿-bit
value to map the leaf-level 1-node to ğ‘¦ âˆˆ ğ‘….
B. Secure multiparty computation
A secure multiparty computation (MPC) protocol is a cryp-
tographic protocol through which two or more mutually
distrusting parties jointly compute some function over their
private inputs while disclosing nothing about their inputs
beyond what is deducible from the shared output. In addition
to the functionality being computed, MPC protocols are