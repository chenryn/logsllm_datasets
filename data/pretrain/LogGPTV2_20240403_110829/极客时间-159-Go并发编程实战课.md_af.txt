# 07 \| Cond：条件变量的实现机制及避坑指南你好，我是鸟窝。在写 Go 程序之前，我曾经写了 10 多年的 Java 程序，也面试过不少 Java程序员。在 Java 面试中，经常被问到的一个知识点就是等待 /通知（wait/notify）机制。面试官经常会这样考察候选人：请实现一个限定容量的队列（queue），当队列满或者空的时候，利用等待/ 通知机制实现阻塞或者唤醒。在 Go中，也可以实现一个类似的限定容量的队列，而且实现起来也比较简单，只要用条件变量（Cond）并发原语就可以。Cond并发原语相对来说不是那么常用，但是在特定的场景使用会事半功倍，比如你需要在唤醒一个或者所有的等待者做一些检查操作的时候。那么今天这一讲，我们就学习下 Cond这个并发原语。Go 标准库的 CondGo 标准库提供 Cond 原语的目的是，为等待 /通知场景下的并发问题提供支持。Cond 通常应用于等待某个条件的一组goroutine，等条件变为 true 的时候，其中一个 goroutine 或者所有的goroutine 都会被唤醒执行。顾名思义，Cond 是和某个条件相关，这个条件需要一组 goroutine协作共同完成，在条件还没有满足的时候，所有等待这个条件的 goroutine都会被阻塞住，只有这一组 goroutine 通过协作达到了这个条件，等待的goroutine 才可能继续进行下去。那这里等待的条件是什么呢？等待的条件，可以是某个变量达到了某个阈值或者某个时间点，也可以是一组变量分别都达到了某个阈值，还可以是某个对象的状态满足了特定的条件。总结来讲，等待的条件是一种可以用来计算结果是true 还是 false 的条件。从开发实践上，我们真正使用 Cond 的场景比较少，因为一旦遇到需要使用Cond 的场景，我们更多地会使用 Channel 的方式（我会在第 12 和第 13 讲展开Channel 的用法）去实现，因为那才是更地道的 Go 语言的写法，甚至 Go的开发者有个"把 Cond从标准库移除"的提议（issue 21165）。而有的开发者认为，Cond是唯一难以掌握的 Go并发原语。至于其中原因，我先卖个关子，到这一讲的后半部分我再和你解释。今天，这一讲我们就带你仔细地学一学 Cond这个并发原语吧。Cond 的基本用法标准库中的 Cond 并发原语初始化的时候，需要关联一个 Locker接口的实例，一般我们使用 Mutex 或者RWMutex。 我们看一下 Cond 的实现：    type Cond      func NeWCond(l Locker) *Cond      func (c *Cond) Broadcast()      func (c *Cond) Signal()      func (c *Cond) Wait()首先，Cond 关联的 Locker 实例可以通过 c.L访问，它内部维护着一个先入先出的等待队列。然后，我们分别看下它的三个方法 Broadcast、Signal 和 Wait方法。 **Signal 方法**，允许调用者 Caller 唤醒一个等待此 Cond 的goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond等待队列中有一个或者多个等待的 goroutine，则需要从等待队列中移除第一个goroutine 并把它唤醒。在其他编程语言中，比如 Java 语言中，Signal方法也被叫做 notify 方法。调用 Signal 方法时，不强求你一定要持有 c.L的锁。 **Broadcast 方法**，允许调用者 Caller 唤醒所有等待此 Cond 的goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond等待队列中有一个或者多个等待的 goroutine，则清空所有等待的goroutine，并全部唤醒。在其他编程语言中，比如 Java 语言中，Broadcast方法也被叫做 notifyAll 方法。同样地，调用 Broadcast 方法时，也不强求你一定持有 c.L的锁。 **Wait 方法**，会把调用者 Caller 放入 Cond 的等待队列中并阻塞，直到被Signal 或者 Broadcast的方法从等待队列中移除并唤醒。调用 Wait 方法时必须要持有 c.L的锁。 Go 实现的 sync.Cond 的方法名是 Wait、Signal 和Broadcast，这是计算机科学中条件变量的通用方法名。比如，C 语言中对应的方法名是pthread_cond_wait、pthread_cond_signal 和pthread_cond_broadcast。知道了 Cond提供的三个方法后，我们再通过一个百米赛跑开始时的例子，来学习下 **Cond的使用方法**。10个运动员进入赛场之后需要先做拉伸活动活动筋骨，向观众和粉丝招手致敬，在自己的赛道上做好准备；等所有的运动员都准备好之后，裁判员才会打响发令枪。每个运动员做好准备之后，将 ready 加一，表明自己做好准备了，同时调用Broadcast 方法通知裁判员。因为裁判员只有一个，所以这里可以直接替换成Signal 方法调用。调用 Broadcast 方法的时候，我们并没有请求 c.L锁，只是在更改等待变量的时候才使用到了锁。裁判员会等待运动员都准备好（第 22行）。虽然每个运动员准备好之后都唤醒了裁判员，但是裁判员被唤醒之后需要检查等待条件是否满足（**运动员都准备好了**）。可以看到，裁判员被唤醒之后一定要检查等待条件，如果条件不满足还是要继续等待。    func main() {        c := sync.NewCond(&sync.Mutex{})        var ready int        for i := 0; i = size {            return nil        }        locals = p.victim        l := indexLocal(locals, pid)        if x := l.private; x != nil { // 同样的逻辑，先从vintim中的local private获取            l.private = nil            return x        }        for i := 0; i = c.maxIdleConns() {//如果连接已满,关闭，不再放入          cn.nc.Close()          return        }        c.freeconn[addr.String()] = append(freelist, cn) // 加入到空闲列表中      }              // 得到一个空闲连接      func (c *Client) getFreeConn(addr net.Addr) (cn *conn, ok bool) {        c.lk.Lock()        defer c.lk.Unlock()        if c.freeconn == nil {           return nil, false        }        freelist, ok := c.freeconn[addr.String()        if !ok || len(freelist) == 0 { // 没有此地址的空闲列表，或者列表为空          return nil, false        }        cn = freelist[len(freelist)-1] // 取出尾部的空闲连接        c.freeconn[addr.String()] = freelist[:len(freelist)-1        return cn, true      }    Worker Pool最后，我再讲一个 Pool 应用得非常广泛的场景。你已经知道，goroutine是一个很轻量级的"纤程"，在一个服务器上可以创建十几万甚至几十万的goroutine。但是"可以"和"合适"之间还是有区别的，你会在应用中让几十万的goroutine一直跑吗？基本上是不会的。一个 goroutine 初始的栈大小是 2048 个字节，并且在需要的时候可以扩展到1GB（具体的内容你可以课下看看代码中的配置：不同的架构最大数会不同），所以，大量的 goroutine还是很耗资源的。同时，大量的 goroutine对于调度和垃圾回收的耗时还是会有影响的，因此，goroutine并不是越多越好。有的时候，我们就会创建一个 Worker Pool 来减少 goroutine的使用。比如，我们实现一个 TCP 服务器，如果每一个连接都要由一个独立的goroutine 去处理的话，在大量连接的情况下，就会创建大量的goroutine，这个时候，我们就可以创建一个固定数量的goroutine（Worker），由这一组 Worker 去处理连接，比如 fasthttp中的 [WorkerPool  slate-object="inline"。Worker的实现也是五花八门的：1.  有些是在后台默默执行的，不需要等待返回结果；        2.  有些需要等待一批任务执行完；        3.  有些 Worker Pool    的生命周期和程序一样长；        4.  有些只是临时使用，执行完毕后，Pool    就销毁了。        大部分的 Worker Pool 都是通过 Channel 来缓存任务的，因为 Channel能够比较方便地实现并发的保护，有的是多个 Worker 共享同一个任务Channel，有些是每个 Worker 都有一个独立的Channel。 综合下来，精挑细选，我给你推荐三款易用的 Worker Pool，这三个 WorkerPool 的 API设计简单，也比较相似，易于和项目集成，而且提供的功能也是我们常用的功能。1.  [gammazero/workerpool            ：gammazero/workerpool    可以无限制地提交任务，提供了更便利的 Submit 和 SubmitWait    方法提交任务，还可以提供当前的 worker 数和任务数以及关闭 Pool    的功能。        2.  [ivpusic/grpool            ：grpool 创建 Pool    的时候需要提供 Worker    的数量和等待执行的任务的最大数量，任务的提交是直接往 Channel    放入任务。        3.  [dpaks/goworkers            ：dpaks/goworkers 提供了更便利的    Submi 方法提交任务以及 Worker 数、任务数等查询方法、关闭 Pool    的方法。它的任务的执行结果需要在 ResultChan 和 ErrChan    中去获取，没有提供阻塞的方法，但是它可以在初始化的时候设置 Worker    的数量和任务数。        类似的 Worker Pool的实现非常多，比如还有panjf2000/antsslate-object="inline"、Jeffail/tunny、benmanns/goworkerslate-object="inline"、go-playground/poolslate-object="inline"、Sherifabdlnaby/gpoolslate-object="inline"等第三方库。pond也是一个非常不错的 WorkerPool，关注度目前不是很高，但是功能非常齐全。其实，你也可以自己去开发自己的 WorkerPool，但是，对于我这种"懒惰"的人来说，只要满足我的实际需求，我还是倾向于从这个几个常用的库中选择一个来使用。所以，我建议你也从常用的库中进行选择。总结Pool是一个通用的概念，也是解决对象重用和预先分配的一个常用的优化手段。即使你自己没在项目中直接使用过，但肯定在使用其它库的时候，就享受到应用Pool 的好处了，比如数据库的访问、http API的请求等等。我们一般不会在程序一开始的时候就开始考虑优化，而是等项目开发到一个阶段，或者快结束的时候，才全面地考虑程序中的优化点，而Pool 就是常用的一个优化手段。如果你发现程序中有一种 GC耗时特别高，有大量的相同类型的临时对象，不断地被创建销毁，这时，你就可以考虑看看，是不是可以通过池化的手段重用这些对象。另外，在分布式系统或者微服务框架中，可能会有大量的并发 Client请求，如果 Client 的耗时占比很大，你也可以考虑池化Client，以便重用。如果你发现系统中的 goroutine数量非常多，程序的内存资源占用比较大，而且整体系统的耗时和 GC也比较高，我建议你看看，是否能够通过 Worker Pool 解决大量 goroutine的问题，从而降低这些指标。![](Images/53e14c4cfe534647dca0014ee1bfa5bb.png)savepage-src="https://static001.geekbang.org/resource/image/58/aa/58358f16bcee0281b55299f0386e17aa.jpg"}思考题在标准库 net/rpc 包中，Server端需要解析大量客户端的请求（Request），这些短暂使用的 Request是可以重用的。请你检查相关的代码，看看 Go开发者都使用了什么样的方式来重用这些对象。欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。