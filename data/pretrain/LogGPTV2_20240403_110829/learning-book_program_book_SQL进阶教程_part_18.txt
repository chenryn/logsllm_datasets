onhand_ant
2006-10-26
12000
12000-- 12000
2006-10-28
2500
14500
0052 + 0002 --
2006-10-31
-15000
-500
-- 12000 + 2500 +(-15000)
2006-11-03
34000
33500
-- 12000 + 2500 + (-15000) + 34000
2006-11-04
-5000
28500
下同
2006-11-06
T200
35700
2006-11-11
11000
46700
这里不加说明就直接给出了答案，多少会让人觉得有点突然。但是，
对于这个查询，大家不觉得似曾相识吗？其实，这是与1-2节里计算位次
的方法属于同种类型的查询语句。这里只是将cOUNr替换成了SUM而已。
因此，冯·诺依曼型递归集合也是可以用来求累计值的，大家注意到了吗？
到目前为止，本节主要是复习以前学过的旧知识，从现在开始，我们
就要进入正题了。刚才的例题并没有指定要求的累计值的时间区间，因此
---
## Page 116
1-6用关联子查询比较行与行—
—103
我们计算的是从最早的数据开始的累计值。接下来，我们考虑一下如何以
3次处理为单位求累计值，即移动累计值。所谓移动，指的是将累计的数
据行数固定（本例中为3行），一行一行地偏移，如下表所示。
■目标区问一行一行地偏移
rc_dale（处理目期）
prc_am [处理金额]
20061026
12 000
20061028
2 500
区间1：500
20061031
15 000
》区间2 ： 21 500
20061103
34 000
区间3 :14 000
20061104
5 000
>区间] 4 : 36 200
20061106
7 200
区间5 ：13 200
20061111
11 000
这里的思路是，往刚才的求累计值的SQL语句里加上这样一个条件：
A2的处理日期与A1的处理日期之间的记录在3行以内。如果使用窗口函
数，可以像下面这样通过指定ROWS关键字来指定数据行数。
--求移动累计值[11：使用窗口函数
SELBCT pre_date, prc_ant,
SUM (prc_ant) OVER IORDER BY prc_diate
ROMS 2 PRECSDINGl AS onband_amt
FROM Account81
如果使用关联子查询，我们还可以像下面这样用标量子查询来计算
行数。
--求移动累计值（21：不满3行的时间区间也输出
SSLBCT pre_dste, A1 pre_ant,
(SSLBCT SUM (prc_ant)
FROM Accounts A2
MHERE Al -prc_date >= A2.prc_date
AND (SEL&CT COUMT(*)
PROM Accounts A3
KHERg A3.prc_date
BETWEEN A2-prc_date AND A1-prc_date ) = A2.prc_date
AND (SEL&CT COUNT(+)
FROM Accounts A3
MHERE A3.prc_date
HAVING  cOONe [*) =3] AS mvg_aum
BETWEEN A2 -prc_date AND A1-pxc_date ) = A2.prc_date
FROM Accounts Al,Accounts A2
AND (SELECT COURT(*)
NHERE A3 prc_date B&TVEEN A2.pre_date JAND A1.prc_date ) <= 3
FROM Accounte A3
ORDER BY A1_date, A2_datej
■执行结果
A1_date
A2_date
ant
2006-10-26 2006-10-26
12000
2006 -1028
2006-1026
12000
2006-10-28 2006-10-28
2500
2006-10-31 2006-10-26
12000
2006 -1031
2006 -102B
2500
-81  -500
2006 -1031
2006-1031
-15000
2006 -11-03
2006-1028
2500
2006 -11-03
2006 -1031
-15000
·S2 : 21500
2006-11-03 2006-11-03
34000
2006 -11-04
2006 -10-31
-150·00
2006 -11-04
2006 -11-03
34000
--53 : 14000
2006 -11 -042006 -11 - 04
 - 50·00
2006 -11 -062006 -11-03
34000
2006 -11-06
2006 -11-04
 - 50·00
--54 : 36200
2006 -11-06
2006 -11-06
7200
2006 -11-11 2006-11-04
- 5000
2006 -11-11
2006-11-06
7200
-S5 : 13200
2006-11-112006-11-11
11000
像上面这样展开后，我们发现，这里的思路与冯·诺依曼型递归集合
一样，生成了几个集合。只不过，这些集合间的关系不是嵌套，而是存在
交集，又有一点“偏移”.而且，集合S3刚好与所有集合都有交集。
图灵社区会员非洲钢(PI:EMAIL）专享尊重版权
---
## Page 119
106—第1章神奇的SOL
■存在部分交集的集合簇
通过将这个集合与冯·诺依曼型同心圆式嵌套集合进行对比，我们
可以明白，集合的生成方式是多种多样的，也是非常有趣的。如果自连接
还有，到目前为止，我们主要思考了累计值的求法，所以使用的是
sUM函数。如果求移动平均值（moving average），那么将suM函数改写成
AVG 函数就可以了。
查询重叠的时间区间
假设有下面这样一张表Reservations，记录了酒店或者旅馆的预约
情况。
Reservations
resarver [入性客人]
slart_dale（入住日期】
end_dale|离店日期|
木村
20061026
20061027
荒木
20061028
20061031
堰
20061031
20061101
山本
20061103
20061104
内田
20061103
20061105
水谷
20061106
20061106
这张表里没有房间编号，请把表中数据当成是某一房间在某段期间内
的预约情况。那么，正常情况下，每天只能有一组客人在该房间住宿。从
表中数据可以看出，这里存在重叠的预定日期。为了让大家看得更清晰，
我们把表中数据转换成了柱状图。
---
## Page 120
1-6用关联子查询比较行与行
107 
10/25
Q/3C
11/01
11/05