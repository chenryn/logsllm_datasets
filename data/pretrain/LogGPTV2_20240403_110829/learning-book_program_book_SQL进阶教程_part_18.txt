### 优化后的文本

#### 库存金额变动记录
- **日期**：2006-10-26  
  **金额**：12,000  
  **累计金额**：12,000
- **日期**：2006-10-28  
  **金额**：2,500  
  **累计金额**：14,500
- **日期**：2006-10-31  
  **金额**：-15,000  
  **累计金额**：-500
- **日期**：2006-11-03  
  **金额**：34,000  
  **累计金额**：33,500
- **日期**：2006-11-04  
  **金额**：-5,000  
  **累计金额**：28,500
- **日期**：2006-11-06  
  **金额**：7,200  
  **累计金额**：35,700
- **日期**：2006-11-11  
  **金额**：11,000  
  **累计金额**：46,700

#### 查询说明
此查询与之前章节中计算位次的方法类似，只是将`COUNT`替换成了`SUM`。因此，冯·诺依曼型递归集合也可用于求累计值。

到目前为止，本节主要是复习以前学过的旧知识。接下来，我们将进入正题。在之前的例子中，我们计算的是从最早的数据开始的累计值。现在，我们考虑如何以3次处理为单位求移动累计值。所谓移动累计值，是指将累计的数据行数固定（本例中为3行），并逐行偏移。

#### 移动累计值示例
| 处理日期 | 处理金额 | 累计区间 |
|----------|----------|----------|
| 2006-10-26 | 12,000   | 区间1: 12,000 |
| 2006-10-28 | 2,500    | 区间2: 14,500 |
| 2006-10-31 | -15,000  | 区间3: -12,500 |
| 2006-11-03 | 34,000   | 区间4: 21,500 |
| 2006-11-04 | -5,000   | 区间5: 14,000 |
| 2006-11-06 | 7,200    | 区间6: 36,200 |
| 2006-11-11 | 11,000   | 区间7: 13,200 |

#### SQL语句
##### 使用窗口函数
```sql
SELECT 
    prc_date, 
    prc_amt, 
    SUM(prc_amt) OVER (ORDER BY prc_date ROWS 2 PRECEDING) AS onhand_amt
FROM Accounts;
```

##### 使用关联子查询
```sql
SELECT 
    A1.prc_date, 
    A1.prc_amt, 
    (SELECT SUM(A2.prc_amt)
     FROM Accounts A2
     WHERE A2.prc_date <= A1.prc_date
       AND (SELECT COUNT(*)
            FROM Accounts A3
            WHERE A3.prc_date BETWEEN A2.prc_date AND A1.prc_date) <= 3
    ) AS mvg_sum
FROM Accounts A1
ORDER BY A1.prc_date;
```

#### 执行结果
| A1_date  | A2_date  | Amount  |
|----------|----------|---------|
| 2006-10-26 | 2006-10-26 | 12,000  |
| 2006-10-28 | 2006-10-26 | 12,000  |
| 2006-10-28 | 2006-10-28 | 2,500   |
| 2006-10-31 | 2006-10-26 | 12,000  |
| 2006-10-31 | 2006-10-28 | 2,500   |
| 2006-10-31 | 2006-10-31 | -15,000 |
| ...      | ...      | ...     |

通过展开这些集合，我们可以看到它们之间的关系类似于冯·诺依曼型递归集合，但存在部分交集和偏移。如果需要求移动平均值，只需将`SUM`函数替换为`AVG`函数即可。

### 预约重叠查询
假设有一张名为`Reservations`的表，记录了酒店或旅馆的预约情况：
| 客人姓名 | 入住日期 | 离店日期 |
|----------|----------|----------|
| 木村     | 2006-10-26 | 2006-10-27 |
| 荒木     | 2006-10-28 | 2006-10-31 |
| 堰       | 2006-10-31 | 2006-11-01 |
| 山本     | 2006-11-03 | 2006-11-04 |
| 内田     | 2006-11-03 | 2006-11-05 |
| 水谷     | 2006-11-06 | 2006-11-06 |

为了检查是否存在重叠的预定日期，可以将数据转换成柱状图进行可视化。