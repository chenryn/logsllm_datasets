[25] Peter Pessl. 2016. Analyzing the shuffling side-channel countermeasure for
lattice-based signatures. In INDOCRYPT 2016. Springer, 153–170.
[26] Peter Pessl, Leon Groot Bruinderink, and Yuval Yarom. 2017. To BLISS-B or not
to be: Attacking strongSwan’s Implementation of Post-Quantum Signatures. In
Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications
Security. ACM, 1843–1855.
[27] Thomas Pornin. 2013. Deterministic usage of the digital signature algorithm (DSA)
and elliptic curve digital signature algorithm (ECDSA). Technical Report.
[28] Prasanna Ravi, Debapriya Basu Roy, Shivam Bhasin, Anupam Chattopadhyay,
and Debdeep Mukhopadhyay. 2019. Number "Not Used" Once-Practical Fault
Attack on pqm4 Implementations of NIST Candidates. In International Workshop
on Constructive Side-Channel Analysis and Secure Design. Springer, 232–250.
[29] Lionel Riviere, Zakaria Najm, Pablo Rauzy, Jean-Luc Danger, Julien Bringer, and
Laurent Sauvage. 2015. High precision fault injections on the instruction cache
of ARMv7-M architectures. arXiv preprint arXiv:1510.01537 (2015).
[30] Elena Trichina and Roman Korkikyan. 2010. Multi fault laser attacks on pro-
tected CRT-RSA. In Fault Diagnosis and Tolerance in Cryptography (FDTC), 2010
Workshop on. IEEE, 75–86.
Session 5B: Fault Attacks and Side Channel AnalysisAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand438A DESCRIPTION OF DILITHIUM SIGNATURE
SCHEME
In this section, we present the rounding algorithms, key generation
and verification procedures of the Dilithium signature scheme.
else
end
return Dq (r , α ) = (r1, r0)
r1 = 0
r0 = r0 − 1
r1 = (r − r0)/α
Compute (r1, r0) = Dq (r , α )
return HBq (r , α ) = r1
Compute r = r (mod q)
Compute r0 = r (mod ± α )
if r − r0 = q − 1 then
Algorithm 4: Rounding Algorithms
1 Procedure Decompose Dq (r , α)
2
3
4
5
6
7
8
9
10
11
1 Procedure HighBits HBq ((r , α ))
2
3
4
1 Procedure MakeHint MHq (u, r , α)
2
3
4
5
6
7
8
9
10
1 Procedure UseHint UHq ((h, r , α ))
2
3
4
5
6
7
8
9
10
11
12
Compute m = (q − 1)/α
Compute (r1, r0) = Dq (r , α )
if h = 1 and r0 > 0 then
r1 = (r1 + 1) (mod m)
Compute r1 = HBq (r , α )
Compute v1 = HBq (u + r , α )
if r1 = v1 then
end
else if h = 1 and r0 ≤ 0 then
end
return MHq (u, r , α ) = h
end
return UHq (h, r , α ) = r1
r1 = (r1−1) (mod + m)
r1 = r1
h = 0
h = 1
else
else
B qTESLA SIGNATURE SCHEME
The qTESLA signature scheme is an improved practical variant
of the Bai-Galbraith signature scheme [3]. It is also based on the
"Fiat-Shamir with Aborts" framework and hence structurally very
similar to Dilithium. The hardness guarantees of qTESLA are de-
rived from the Ring-LWE and Ring-SIS problem based in the ring
Rq = Zq[X]/[X n + 1] with n ≥ 1024. Refer Alg.6 for a brief al-
gorithmic level description of the qTESLA signature scheme. As
ρ, ρ′ ← {0, 1}256
K ← {0, 1}256
N = 0
for i from 0 to ℓ − 1 do
Algorithm 5: Dilithium Signature scheme
1 Procedure KeyGen()
2
3
4
5
6
7
8
9
10
11
12
s1[i] = Sample(PRF(ρ′, N ))
N := N + 1
s2[i] = Sample(PRF(ρ′, N ))
N := N + 1
end
for i from 0 to k − 1 do
q
13
= ExpandA(ρ)
end
a ∼ Rk×ℓ
t = a · s1 + s2
t1 = Power2Roundq (t, d )
tr ∈ {0, 1}384 = CRH(ρ||t1)
return pk = (ρ, t1), sk = (ρ, K, tr , s1, s2, t0)
14
15
16
17
18
1 Procedure Verify(pk, M, σ = (z, h, c))
2
q
a ∈ Rk×ℓ
:= ExpandA(ρ)
µ = CRH (CRH(ρ∥t1)∥M )
w1 := UHq (h, a · z − c · t1 · 2d , 2γ2)
if c = H (µ, w1) and ∥z∥∞ < γ1 − β and wt(h) ≤ ω then
3
4
5
6
7
8
9
return 1
else
return 0
end
stated earlier1, our attacks only apply the deterministic variant of
qTESLA and since its updated specification is a probabilistic one
and hence is inherently protected against our attacks.
B.1 Adapting our attacks to qTESLA
The zgen step (i.e) z = s1 · c + y in Line 10 of Sign in Alg 6, which is
of most interest to our attack computes almost identical operations
as that of Dilithium due to use of the same operating base ring Rq.
We analyzed the reference implementation of qTESLA signature
scheme taken from the pqm4 library and found that the zgen opera-
tion is implemented similar to Variant-3 wherein the result (z) of
the target addition operation is stored in a new variable with the
order of operands similar to Case-2 (z = y upon faulting) of the ad-
dition operation. Thus, our fault attacks demonstrated for Dilithium
directly apply to qTESLA, albeit with different fault complexities
due to differing conditional checks and parameter sets.
Unlike Dilithium, the signatures of qTESLA only contain two
components (z, c). Moreover, the LWE instance t ∈ Rq computed in
the key-generation procedure is directly output as the public key
pk and hence retrieval of s through the skip-addition fault attack
results in a direct break of the signature scheme. Since the NTT
operation is used for polynomial multiplication, our zero-cost miti-
gation technique exploiting the fault propagation characteristics
Session 5B: Fault Attacks and Side Channel AnalysisAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand439in itself is a bijective mapping from one polynomial to another
in the same operating ring. An input sequence p with n elements
(p0, . . . , pn−1) is mapped to its representation ¯p in the NTT domain
as
¯pj =
(8)
where j ∈ [0, n−1] and ω being the nth root of unity in the operating
ring Zq.
i =0
pi · ωi·j
n−1(cid:88)
Figure 9: NTT operation on a polynomial x with degree 8
Referring to Eqn.8 which represents the NTT operation, we can
see that every element of the output polynomial in NTT domain is
a unique function of all the elements of the input polynomial. The
same also applies for the inverse NTT operation. Refer Figure 9 for
the data-flow graph of the NTT, where we can clearly visualize this
dependency between elements of the input and the output of the
NTT transform. We leverage over this property, which we refer to as
the diffusion property of the NTT operation to ensure that the fault
injected in the addition operation for one element is propagated
uniformly to all the elements in the signature component z. This
further ensures that the resulting faulty signatures are rejected by
the signing procedure with very high probability.
of the NTT operation is also applicable for concrete protection of
qTESLA against skip-addition fault attacks.
Algorithm 6: qTESLA Signature scheme
1 Procedure KeyGen()
Goto Sample
end
return pk = (seeda, t), sk = (s, e, seedy, seeda)
$← {0, 1}k
seeda, seedy
a ∈ Rq ← GenA(seeda )
Sample :
s, e ∈ Rq ← Dσ
t ∈ Rq = a · s + e
while (checkS(s)||checkE(e) = 0) do
a ← GenA(seeda )
counter = 0
rand = PRF1(seedy , m)
Rej :
y ∈ Rq ← PRF2 (rand, counter )
v ∈ Rq = a · y (mod q)
c ∈ Rq = Enc(H (Round(v), M ))
z ∈ Rq = s · c + y
if (Reject(z) = 0) then
2
3
4
5
6
7
8
9
10
11
1 Procedure Sign(sk, M)
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
1 Procedure Verify(pk, M, σ = (z, c))
2
3
4
end
w ∈ Rq = v − e · c
if (Reject(w) = 0) then
counter = counter + 1
Goto Rej
a ← GenA(seeda )
w = a · z − t · c (mod q)
return c = H (Round(w), M )
counter = counter + 1
Goto Rej
end
return σ = (z, c)
C NUMBER THEORETIC TRANSFORM
The Number Theoretic Transform (abbreviated as NTT) is widely
used in increasing the efficiency of multiple lattice-based schemes,
including the Dilithium and qTESLA signature schemes. The NTT
operation enables the polynomial multiplication in the ring to be
done in quasilinear time (O(nloд(n))) compared to the quadratic
time (O(n
)) time for the schoolbook polynomial multiplier. The
operand polynomials are first converted into their respective rep-
resentations in the NTT domain. They are then further multiplied
point-wise in the NTT domain after which the final product is
obtained through an inverse NTT operation. The NTT operation
2
Session 5B: Fault Attacks and Side Channel AnalysisAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand440