title:Fail-Secure Access Control
author:Petar Tsankov and
Srdjan Marinovic and
Mohammad Torabi Dashti and
David A. Basin
Fail-Secure Access Control
Petar Tsankov
Institute of Information
Srdjan Marinovic
Institute of Information
Mohammad Torabi Dashti
Institute of Information
David Basin
Institute of Information
Security,
ETH Zurich
Security,
ETH Zurich
PI:EMAIL
PI:EMAIL
PI:EMAIL
PI:EMAIL
Security,
ETH Zurich
Security,
ETH Zurich
ABSTRACT
Decentralized and distributed access control systems are sub-
ject to communication and component failures. These can
aﬀect access decisions in surprising and unintended ways,
resulting in insecure systems. Existing analysis frameworks
however ignore the inﬂuence of failure handling in deci-
sion making. Thus, it is currently all but impossible to
derive security guarantees for systems that may fail. To
address this, we present (1) a model in which the attacker
can explicitly induce failures, (2) failure-handling idioms,
and (3) a method and an associated tool for verifying fail-
security requirements, which describe how access control
systems should handle failures. To illustrate these contri-
butions, we analyze the consequences of failure handling in
the XACML 3 standard and other domains, revealing secu-
rity ﬂaws.
Categories and Subject Descriptors
K.6.5 [Management of Computing and Information
Systems]: Security and Protection; D.4.6 [Operating Sys-
tems]: Security and Protection—access controls
General Terms
Security, Veriﬁcation
Keywords
Access Control; Failure Handling; Formal Analysis
1.
INTRODUCTION
Modern access control systems are often decentralized and
distributed, and therefore subject to communication and
component failures. If failures aﬀect the availability of in-
formation needed for security decisions, then access control
systems must, either implicitly or explicitly, handle these
failures. This concern permeates all access control domains.
For example, ﬁrewalls must operate even when their log en-
gines crash [26] or rule updates fail [28], web applications
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660307 .
must service requests even if authentication services are un-
responsive [27], delegation systems must evaluate requests
even when they cannot update their revocation lists, and
perimeter security systems must control access even when
the wireless channels to their central database are jammed.
In such settings, the access decisions of a Policy Decision
Point (PDP) cannot be understood without considering the
PDP’s failure handlers as well.
The access control community has not thus far rigorously
studied the eﬀects of failure handlers on access decisions.
One reason for this is that simply interpreting failures as
denies appears suﬃcient to conservatively approximate the
PDP’s desired behavior. This would suggest that the pol-
icy writer need not overly concern himself with analyzing
the PDP’s failure handlers. However, failures can aﬀect the
PDP’s decisions in surprising and unintended ways. Such
simplistic approximations are not only inﬂexible, they also
do not necessarily result in secure systems. As an example,
we describe later how the conservative approach of replac-
ing failures with denies had been originally adopted in the
XACML 3 standard, and was later dropped due to its inse-
curity.
Given that failure handling inﬂuences the PDP’s access
decisions, it follows that formal analysis frameworks for ac-
cess control should account for the PDP’s failure handlers.
Only then can security guarantees be derived for the PDP’s
access decisions, both in the presence and absence of failures.
Analysis techniques for obtaining such security guarantees
would be of immediate practical value because existing ac-
cess control systems separate failure handling from the “nor-
mal” (typically declarative) policy interpreted by the PDP,
i.e. the policy that deﬁnes the PDP’s decisions when no fail-
ures occur. The logic that decides access requests is there-
fore split into two parts. This separation makes the PDP’s
behavior diﬃcult to understand and analyze.
Existing formal analysis frameworks for access control poli-
cies are inadequate for the task at hand. This is neither an
issue with the expressiveness of their formal languages nor
the complexity of their decision problems. Rather, they lack
(1) a system and attacker model tailored for failure scenar-
ios, (2) idioms for specifying failure handlers, and (3) meth-
ods for verifying fail-security requirements, i.e. security re-
quirements that describe how distributed access control sys-
tems ought to handle failures. Thus, currently it is all but
impossible to derive security guarantees that extend beyond
the PDP’s normal behaviors. In this paper, we show how to
realize these three artifacts using the BelLog analysis frame-
work [32].
Contributions. This is the ﬁrst paper that systematically
analyzes the role of failure handling in access control sys-
tems. We investigate three kinds of security ﬂaws: failure-
oblivious policy composition, overly eager failure handling,
and the preemptive masking of failures. Examples of sys-
tems that exhibit these ﬂaws are given in the following sec-
tions; a common thread in these systems is their seeming
conformance to security common sense.
We also demonstrate how the PDP, including its failure
handlers, can be modeled and analyzed using the BelLog
policy analysis framework. In particular: (1) We investigate
seven real-world access control systems and use these to ex-
tract a system and an attacker model tailored for analyzing
the eﬀect of failures on the PDP’s decisions. (2) We derive
common failure-handling idioms from these systems, which
can be readily encoded in BelLog. (3) Through examples,
we show how to express fail-security requirements and we
provide a tool to automatically verify them for a given PDP
with respect to our attacker model. We argue that our veri-
ﬁcation method is eﬀective by demonstrating how the three
kinds of security ﬂaws mentioned above can be discovered.
As a ﬁnal remark, we choose BelLog for technical conve-
nience. BelLog is a four-valued extension of Datalog (the
core of most decentralized access control languages), where
one of the truth values, borrowed from Belnap’s logic, can be
used to denote failures; see §4 for details. Our contributions
are however independent of the BelLog formalism. Any suf-
ﬁciently expressive logic, for example ﬁrst-order logic, can
replace BelLog for our purpose.
Related Work. Although fail-security requirements have
been discussed in the security literature [7, 33], there has
been no rigorous, systematic treatment of fail-secure access
control. The existing access control speciﬁcation languages,
such as [3,9,13,16,18,25], do not explicitly deal with failure
handlers in their analysis. Although failures are considered
in [12], failure-handling mechanisms are not dealt with.
Static and dynamic policy analysis frameworks such as [2,
10,14,15,17,23] can potentially be tailored to reason about
PDPs with failure handling, similarly to BelLog. In partic-
ular, PBel’s analysis framework [10] also supports policies
with many-valued policy decisions and can, if delegations
are excluded, express our failure-handling idioms. We re-
mark that dynamic analysis frameworks, such as [2, 14, 17],
consider history-based access decisions, which fall outside
the scope of our paper.
Organization. In §2, we give examples of PDP failure han-
dlers and fail-security requirements for access control sys-
tems. In §3, we deﬁne our system and attacker model. In §4,
we summarize the BelLog speciﬁcation language and use it
to specify the examples from §2. In §5, we analyze these ex-
amples with respect to their fail-security requirements. We
point to future research directions in §6.
2. MOTIVATION
As motivation, we use the XACML 3 standard to show
that approximating failures with denials, although seem-
ingly conservative, can lead to insecure systems. Through
our second and third examples, taken from the web applica-
tion and grid computing domains, we illustrate the common
PDP implementation pattern that treats failure handlers as
a separate add-on to the normal policy engine. We show how
evaluate(Request req)
Set decisions
for (pol in policies)
try
decision = pol.evaluate(req)
if (pol.issuer == admin) or authorize(pol, req)
decisions.add(decision)
catch (EvaluationException e)
skip
return compositionOperator.apply(decisions)
Figure 1. PDP module for evaluating XACML 3 policy
sets. The methods pol.evaluate(req) and authorize(pol, req)
throw an exception if the PDP fails to execute them.
this separation makes understanding and analyzing PDPs
particularly diﬃcult, resulting in systems open to attacks.
XACML 3. XACML 3 is an OASIS standard for spec-
ifying access control policies [36]. XACML 3 policies are
issued by principals and evaluated by a PDP. A policy is-
sued by the PDP’s administrator is called trusted; other-
wise, it is non-trusted. The administrator speciﬁes whether
a non-trusted policy is authorized to decide a given request.
XACML 3 policies are grouped into policy sets and their
decisions are combined with composition operators, such as
permit-overrides, which grants access if at least one policy
grants access. To decide a given request, the PDP ﬁrst com-
putes the decisions of all policies in the set. Afterwards, it
checks which non-trusted policies are authorized by the ad-
ministrator. Finally, the PDP combines the decisions of the
trusted policies and the authorized non-trusted policies us-
ing the policy set’s composition operator.
An XACML 3 PDP obtains all information needed for
policy evaluations, such as attributes and credentials, from
Policy Information Points (PIPs). The XACML standard,
up to Revision 16, stated that the PDP should refrain from
using policies that could not be evaluated or authorized due
to communication and PIP failures. This decision follows
the intuitive idea that all suspicious policies should be ex-
cluded from the PDP’s decision. Figure 1 speciﬁes such
a PDP, including its failure handler, in pseudo-code. Al-
though this failure handler is inﬂexible, the committee did
not anticipate other consequences on the PDP’s decisions
apart from always making them more conservative (less per-
missive). This however turned out to be wrong.
When the proposed failure-handling behavior was consid-
ered together with the deny-overrides composition opera-
tor, the following attack was discovered [37]. Consider a
request r and a policy set P that contains one trusted pol-
icy P1 that grants r and one authorized non-trusted pol-
icy P2 that denies r. P ’s decisions are combined with deny-
overrides. If the PDP successfully evaluates P1 and fails to
evaluate P2, then the PDP will grant r, even though it does
not have all the necessary information to make this decision.
In this case, the attacker can simply launch denial-of-service
attacks against PIPs and obtain a grant decision for r. In §5
we show how this attack can be found through automated
analysis.
This example illustrates that a PDP’s failure handlers,
regardless of their simplicity, can aﬀect access decisions in
surprising ways. In this example, the failure-oblivious com-
position of sub-policies is the root of the security ﬂaw. To
remedy this ﬂaw, the XACML 3 standard currently uses
isAuthorized(User u, Object o, List aclIDs)
try
for (id in aclIDs)
if (readAcl(id).grants(u,o)) return true
catch (ReadAclException e)
return def.grants(u,o) and logger.on()
return false
Figure 2. A PDP module for the web app example.
Owner
Bob
Ann
Carol
Dave
Fred
Subject has access
Subject does not have access
The PDP failed to check that
the delegation is not revoked
Non-revoked delegation
Figure 3. The ﬁgure shows which subjects in the depicted
scenario have access according to FR2. Ann has access be-
cause her delegation is issued by the owner. Bob and Dave
have access because they have non-revoked chains. Fred
and Carol are denied access because they do not have non-
revoked chains and they are not the owner’s direct delegates.
and overloads a designated policy decision (the indetermi-
nate IN) for every policy that cannot be evaluated due to
failures. Consequently, failure handling is now a concern of
the policy writer.
Authorizations in Web Apps. Web applications use ac-
cess control frameworks to specify and manage user per-
missions. Examples include the Java Authentication and
Authorization Service JAAS, Apache Shiro, and Spring Se-
curity. Basic policies can be speciﬁed using declarative pol-
icy languages. A PDP module loads policy speciﬁcations
and evaluates them within its authorization method. A re-
occurring problem is that the PDP module fails to load a
declarative speciﬁcation due to syntactic errors or missing
ﬁles. To deal with this problem, administrators often main-
tain a default speciﬁcation that serves as a fallback option.
Use of the default speciﬁcation is typically conditioned on
whether logging is enabled. This fallback approach imposes