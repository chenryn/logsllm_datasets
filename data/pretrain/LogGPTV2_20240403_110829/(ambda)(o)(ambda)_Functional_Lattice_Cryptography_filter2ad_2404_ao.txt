in size. To obtain the best concrete parameters and security levels, the accumulated error
should be kept as small as possible. More precisely, its coefï¬cients with respect to some
choice of Z-basis should have magnitudes that are as small as possible.
As shown in [LPR13a, Section 6], errors ğ‘’ whose coordinates ğœğ‘–(ğ‘’) in the canonical
embedding are small and (nearly) independent have correspondingly small coefï¬cients with
respect to the decoding basis of ğ‘…âˆ¨. In the tweaked setting, where errors ğ‘’â€² and the decoding
basis both carry an extra ğ‘¡ğ‘š = Ë†ğ‘š/ğ‘”ğ‘š factor, an equivalent hypothesis is the following,
which we codify as an invariant that applications should maintain:
Invariant 4.2.2 (Error Invariant). For an error ğ‘’â€² âˆˆ ğ‘…, every coordinate
ğœğ‘–(ğ‘’â€²/ğ‘¡ğ‘š) = Ë†ğ‘šâˆ’1 Â· ğœğ‘–(ğ‘’â€² Â· ğ‘”ğ‘š) âˆˆ C
should be nearly independent (up to conjugate symmetry) and have relatively â€œlightâ€ (e.g.,
subgaussian or subexponential) tails.
As already mentioned, the invariant is satisï¬ed for fresh errors drawn from tweaked
Gaussians, as well as for small linear combinations of such terms. In general, the invariant
is not preserved under multiplication, because the product of two tweaked error terms
99
ğ‘– = ğ‘¡ğ‘š Â· ğ‘’ğ‘– carries a ğ‘¡2
ğ‘’â€²
factor:
ğ‘š factor. Fortunately, this is easily ï¬xed by introducing an extra ğ‘”ğ‘š
ğ‘”ğ‘š Â· ğ‘’â€²
1 Â· ğ‘’â€²
2 = ğ‘¡ğ‘š Â· ( Ë†ğ‘š Â· ğ‘’1 Â· ğ‘’2)
satisï¬es the invariant, because multiplication is coordinate-wise under ğœ. We use this
technique in the implementation of our SHE scheme in section 4.3.
4.2.3 Ring tunneling as key switching.
Abstractly, ring tunneling is an operation that homomorphically evaluates a desired ğ¸ğ‘-linear
function ğ¿ğ‘ : ğ‘…ğ‘ â†’ ğ‘†ğ‘ on a plaintext, by converting its ciphertext over ğ‘…â€²
ğ‘ to one over ğ‘†â€²
ğ‘.
Operationally, it can be implemented simply as a form of key switching.
Ring tunneling involves two phases: a preprocessing phase where we use the desired
linear function ğ¿ğ‘ and the secret keys to produce appropriate hints, and an online phase where
we apply the tunneling operation to a given ciphertext using the hint. The preprocessing
phase is as follows:
1. Extend ğ¿ğ‘ to an ğ¸â€²
ğ‘-linear function ğ¿â€²
ğ‘ : ğ‘…â€²
ğ‘ â†’ ğ‘†â€²
ğ‘ that agrees with ğ¿ğ‘ on ğ‘…ğ‘, as
described above.
2. Lift ğ¿â€²
ğ‘ to a â€œsmallâ€ ğ¸â€²-linear function ğ¿â€² : ğ‘…â€² â†’ ğ‘†â€² that induces ğ¿â€²
deï¬ne ğ¿â€² by ğ¿â€²(âƒ—ğ‘‘ğ‘Ÿâ€²,ğ‘’â€²) = âƒ—ğ‘¦, where âƒ—ğ‘¦ (over ğ‘†â€²) is obtained by lifting âƒ—ğ‘¦ğ‘ = ğ¿â€²
using the powerful basis.
ğ‘. Speciï¬cally,
ğ‘(âƒ—ğ‘‘ğ‘Ÿâ€²,ğ‘’â€²)
The above lifting procedure is justiï¬ed by the following considerations. We want ğ¿â€² to
map ciphertext errors in ğ‘…â€² to errors in ğ‘†â€², maintaining Invariant 4.2.2 in the respective
ğ‘Ÿâ€²,ğ‘’â€² Â· âƒ—ğ‘’ âˆˆ ğ‘…â€² has
rings. In the relative decoding basis âƒ—ğ‘‘ğ‘Ÿâ€²,ğ‘’â€², ciphertext error ğ‘’ = âƒ—ğ‘‘ğ‘¡
ğ¸â€²-coefï¬cients âƒ—ğ‘’ that satisfy the invariant for ğ¸â€², and hence for ğ‘†â€² as well. Because
we want
ğ¿â€²(ğ‘’) = ğ¿â€²(âƒ—ğ‘‘ğ‘¡
ğ‘Ÿâ€²,ğ‘’â€² Â· âƒ—ğ‘’) = âƒ—ğ‘¦ğ‘¡ Â· âƒ—ğ‘’ âˆˆ ğ‘†â€²
100
to satisfy the invariant for ğ‘†â€², it is therefore best to lift âƒ—ğ‘¦ğ‘ from ğ‘†â€²
ğ‘ to ğ‘†â€² using the
powerful basis, for the same reasons that apply to modulus switching when rescaling
the ğ‘1 component of a ciphertext.1
3. Prepare an appropriate key-switching hint using keys ğ‘ in âˆˆ ğ‘…â€² and ğ‘ out âˆˆ ğ‘†â€². Let âƒ—ğ‘
be an arbitrary ğ¸â€²-basis of ğ‘…â€² (which we also use in the online phase below). Using
a gadget vector âƒ—ğ‘” over ğ‘†â€²
ğ‘, generate key-switching hints ğ»ğ‘— for the components of
ğ¿â€²(ğ‘ in Â· âƒ—ğ‘ğ‘¡), such that
(1, ğ‘ out) Â· ğ»ğ‘— â‰ˆ ğ¿â€²(ğ‘ in Â· ğ‘ğ‘—) Â· âƒ—ğ‘”ğ‘¡
(mod ğ‘ğ‘†â€²).
(4.2.1)
(As usual, the approximation hides appropriate Ring-LWE errors that satisfy Invari-
ant 4.2.2.) Recall that we can interpret the columns of ğ»ğ‘— as linear polynomials.
The online phase proceeds as follows. As input we are given an MSD-form, linear
ğ‘) with associated integer ğ‘˜ = 0 and arbitrary ğ‘™ âˆˆ Zğ‘,
ciphertext ğ‘(ğ‘†) = ğ‘0 + ğ‘1ğ‘† (over ğ‘…â€²
encrypting a message ğœ‡ âˆˆ ğ‘…ğ‘ under secret key ğ‘ in.
1. Express ğ‘1 uniquely as ğ‘1 = âƒ—ğ‘ğ‘¡ Â· âƒ—ğ‘’ for some âƒ—ğ‘’ over ğ¸â€²
ğ‘ (where âƒ—ğ‘ is the same ğ¸â€²-basis
of ğ‘…â€² used in step 3 above).
2. Compute ğ¿â€²(ğ‘0) âˆˆ ğ‘†â€²
ğ‘, apply the core key-switching operation to each ğ‘’ğ‘— with hint ğ»ğ‘—,
and sum the results. Formally, output a ciphertext having ğ‘˜ = 0, the same ğ‘™ âˆˆ Zğ‘ as
the input, and the linear polynomial
ğ‘â€²(ğ‘†) = ğ¿â€²(ğ‘0) +
ğ»ğ‘— Â· ğ‘”âˆ’1(ğ‘’ğ‘—)
(mod ğ‘ğ‘†â€²).
(4.2.2)
âˆ‘ï¸
ğ‘—
1The very observant reader may notice that because ğ¿â€²
ğ‘(âƒ—ğ‘‘ğ‘Ÿâ€²,ğ‘’â€²) = ğ¿ğ‘(âƒ—ğ‘‘ğ‘Ÿ,ğ‘’) is over ğ‘†ğ‘, the order in which
we extend and lift does not matter.
101
For correctness, notice that we have
ğ‘0 + ğ‘ in Â· ğ‘1 â‰ˆ ğ‘
=â‡’ ğ¿â€²(ğ‘0 + ğ‘ in Â· ğ‘1) â‰ˆ ğ‘
ğ‘ Â· ğ‘™âˆ’1 Â· ğœ‡ (mod ğ‘ğ‘…â€²)
ğ‘ Â· ğ‘™âˆ’1 Â· ğ¿(ğœ‡)
(mod ğ‘ğ‘†â€²),
(4.2.3)
where the error in the second approximation is ğ¿â€² applied to the error in the ï¬rst approxima-
tion, and therefore satisï¬es Invariant 4.2.2 by design of ğ¿â€². Then we have
âˆ‘ï¸
ğ‘â€²(ğ‘ out) â‰ˆ ğ¿â€²(ğ‘0) +
ğ¿â€²(ğ‘ in Â· ğ‘ğ‘—) Â· âƒ—ğ‘”ğ‘¡ Â· ğ‘”âˆ’1(ğ‘’ğ‘—)
(Equations (4.2.2), (4.2.1))
ğ‘—
= ğ¿â€²(ğ‘0 + ğ‘ in Â· âƒ—ğ‘ğ‘¡ Â· âƒ—ğ‘’)
= ğ¿â€²(ğ‘0 + ğ‘ in Â· ğ‘1)
ğ‘ Â· ğ‘™âˆ’1 Â· ğ¿(ğœ‡)
â‰ˆ ğ‘
(mod ğ‘ğ‘†â€²)
(ğ¸â€²-linearity of ğ¿â€²)
(deï¬nition of âƒ—ğ‘’)
(Equation (4.2.3))
as desired, where the error in the ï¬rst approximation comes from the hints ğ»ğ‘—.
Comparison to ring hopping. We now describe the efï¬ciency advantages of ring tun-
neling versus ring hopping. We analyze the most natural setting where both the input and
output ciphertexts are in CRT representation; in particular, this allows the process to be
iterated as in [AP13].
Both ring tunneling and ring hopping convert a ciphertext over ğ‘…â€²
ğ‘, either
via the greatest common subring ğ¸â€²
ğ‘ (in hopping). In
both cases, the bottleneck is key-switching, where we compute one or more values ğ» Â· ğ‘”âˆ’1(ğ‘)
for some hint ğ» and ring element ğ‘ (which may be over different rings). This proceeds in
ğ‘ (in tunneling) or the compositum ğ‘‡ â€²
ğ‘ to one over ğ‘†â€²
two main steps:
1. We convert ğ‘ from CRT to powerful representation for ğ‘”âˆ’1-decomposition, and then
convert each entry of ğ‘”âˆ’1(ğ‘) to CRT representation. Each such conversion takes
Î˜(ğ‘› log ğ‘›) = ËœÎ˜(ğ‘›) time in the dimension ğ‘› of the ring that ğ‘ resides in.
102
2. We multiply each column of ğ» by the appropriate entry of ğ‘”âˆ’1(ğ‘), and sum. Because
both terms are in CRT representation, this takes linear Î˜(ğ‘›) time in the dimension ğ‘›
of the ring that ğ» is over.
The total number of components of ğ‘”âˆ’1(ğ‘) is the same in both tunneling and hopping, so we
do not consider it further in this comparison.
In ring tunneling, we switch dim(ğ‘…â€²/ğ¸â€²) elements ğ‘’ğ‘— âˆˆ ğ¸â€²
ğ‘ (see Equation (4.2.2)) using
the same number of hints over ğ‘†â€²
ğ‘. Thus the total cost is
dim(ğ‘…â€²/ğ¸â€²) Â· ( ËœÎ˜(dim(ğ¸â€²)) + Î˜(dim(ğ‘†â€²))) = ËœÎ˜(dim(ğ‘…â€²)) + Î˜(dim(ğ‘‡ â€²)).
By contrast, in ring hopping we ï¬rst embed the ciphertext into the compositum ğ‘‡ â€²
ğ‘ and
key-switch there. Because the compositum has dimension dim(ğ‘‡ â€²) = dim(ğ‘…â€²/ğ¸â€²)Â·dim(ğ‘†â€²),
the total cost is
ËœÎ˜(dim(ğ‘‡ â€²)) + Î˜(dim(ğ‘‡ â€²)).
The second (linear) terms of the above expressions, corresponding to step 2, are essentially
identical. For the ï¬rst (superlinear) terms, we see that step 1 for tunneling is at least a
dim(ğ‘‡ â€²/ğ‘…â€²) = dim(ğ‘†â€²/ğ¸â€²) factor faster than for hopping. In typical instantiations, this
factor is a small prime between, say, 3 and 11, so the savings can be quite signiï¬cant in
practice.
4.3 Somewhat-Homomorphic Encryption in Î›âˆ˜ğœ†
In this section we describe a full-featured somewhat-homomorphic encryption scheme and its
implementation in Î›âˆ˜ğœ†, using the interfaces described in chapter 3. At the mathematical level,
the system reï¬nes a variety of techniques and features from a long series of works [LPR13b;
BV11b; BV14a; BGV14; Gen+13; LPR13a; AP13]. In addition, we describe some important
generalizations and include new operations like ring-tunneling. Along with the mathematical
103
description of each main component, we present the corresponding Haskell code, showing
how the two forms match very closely.
Note that like all prior implementations of SHE, our implementation has a relatively
low-level interface which corresponds directly to the mathematical operations described
in the literature. Actually using this interface requires a great deal of expertise. Chapter 5
describes a compiler which drastically simpliï¬es the use of this powerful application.
4.3.1 Keys, Plaintexts, and Ciphertexts
The cryptosystem is parameterized by two cyclotomic rings: ğ‘… = ğ’ªğ‘š and ğ‘…â€² = ğ’ªğ‘šâ€² where
ğ‘š|ğ‘šâ€², making ğ‘… a subring of ğ‘…â€². The spaces of keys, plaintexts, and ciphertexts are derived
from these rings as follows:
â€¢ A secret key is an element ğ‘  âˆˆ ğ‘…â€². Some operations require ğ‘  to be â€œsmall;â€ more
precisely, we need ğ‘  Â· ğ‘”ğ‘šâ€² to have small coordinates in the canonical embedding
of ğ‘…â€² (Invariant 4.2.2). Recall that this is the case for â€œtweakedâ€ spherical Gaussian
distributions.
â€¢ The plaintext ring is ğ‘…ğ‘ = ğ‘…/ğ‘ğ‘…, where ğ‘ is a (typically small) positive integer, e.g.,
ğ‘ = 2. For technical reasons, ğ‘ must be coprime with every odd prime dividing ğ‘šâ€². A
plaintext is simply an element ğœ‡ âˆˆ ğ‘…ğ‘.
ğ‘ = ğ‘…â€²/ğ‘ğ‘…â€² for some integer modulus ğ‘ â‰¥ ğ‘ that is coprime
ğ‘[ğ‘†], i.e., one with
ğ‘ in an indeterminant ğ‘†, which represents the (unknown) secret
ğ‘)ğ‘‘+1,
â€¢ The ciphertext ring is ğ‘…â€²
with ğ‘. A ciphertext is essentially just a polynomial ğ‘(ğ‘†) âˆˆ ğ‘…â€²
coefï¬cients from ğ‘…â€²
key. We often identify ğ‘(ğ‘†) with its vector of coefï¬cients (ğ‘0, ğ‘1, . . . , ğ‘ğ‘‘) âˆˆ (ğ‘…â€²
where ğ‘‘ is the degree of ğ‘(ğ‘†).
In addition, a ciphertext carries a nonnegative integer ğ‘˜ â‰¥ 0 and a factor ğ‘™ âˆˆ Zğ‘ as
auxiliary information. These values are affected by certain operations on ciphertexts,
as described below.
104
Data types. Following the above deï¬nitions, our data types for plaintexts, keys, and
ciphertexts as follows. The plaintext type PT rp is merely a synonym for its argument
type rp representing the plaintext ring ğ‘…ğ‘.
The data type SK representing secret keys is deï¬ned as follows:
data SK râ€™ where SK :: ToRational v => v -> râ€™ -> SK râ€™
Notice that a value of type SK râ€™ consists of an element from the secret key ring ğ‘…â€², and in
addition it carries a rational value (of â€œhiddenâ€ type v) representing the parameter ğ‘£ = ğ‘Ÿ2
for the (tweaked) Gaussian distribution from which the key was sampled. Binding the
parameter to the secret key in this way allows us to automatically generate ciphertexts and
other key-dependent information using consistent error distributions, thereby relieving the
client of the responsibility for managing error parameters across multiple functions.
The data type CT representing ciphertexts is deï¬ned as follows:
data Encoding
= MSD | LSD
data CT m zp râ€™q = CT Encoding Int zp (Polynomial râ€™q)
The CT type is parameterized by three arguments: a cyclotomic index m and a Zğ‘-representation zp
deï¬ning the plaintext ring ğ‘…ğ‘, and a representation râ€™q of the ciphertext ring ğ‘…â€²
ğ‘. A CT value
has four components: a ï¬‚ag indicating the â€œencodingâ€ of the ciphertext (MSD or LSD; see
below); the auxiliary integer ğ‘˜ and factor ğ‘™ âˆˆ Zğ‘ (as mentioned above); and a polynomial
ğ‘(ğ‘†) over ğ‘…â€²
ğ‘.
Decryption relations. A ciphertext ğ‘(ğ‘†) (with auxiliary values ğ‘˜ âˆˆ Z, ğ‘™ âˆˆ Zğ‘) encrypting
a plaintext ğœ‡ âˆˆ ğ‘…ğ‘ under secret key ğ‘  âˆˆ ğ‘…â€² satisï¬es the relation
ğ‘(ğ‘ ) = ğ‘0 + ğ‘1ğ‘  + Â·Â·Â· + ğ‘ğ‘‘ğ‘ ğ‘‘ = ğ‘’
(mod ğ‘ğ‘…â€²)
(4.3.1)
105
for some sufï¬ciently â€œsmallâ€ error term ğ‘’ âˆˆ ğ‘…â€² such that
ğ‘’ = ğ‘™âˆ’1 Â· ğ‘”ğ‘˜
ğ‘šâ€² Â· ğœ‡ (mod ğ‘ğ‘…â€²).
(4.3.2)
By â€œsmallâ€ we mean that the error satisï¬es Invariant 4.2.2, so that all the coefï¬cients of ğ‘’
with respect to the decoding basis have magnitudes smaller than ğ‘/2. This will allow us to
correctly recover ğ‘’â€² âˆˆ ğ‘…â€² from its value modulo ğ‘, by â€œliftingâ€ the latter using the decoding
basis.
We say that a ciphertext satisfying Equations (4.3.1) and (4.3.2) is in â€œleast signiï¬cant
digitâ€ (LSD) form, because the message ğœ‡ is encoded as the error term modulo ğ‘. An
alternative form, which is more convenient for certain homomorphic operations, is the â€œmost
signiï¬cant digitâ€ (MSD) form. Here the relation is
ğ‘(ğ‘ ) â‰ˆ ğ‘
ğ‘ Â· (ğ‘™âˆ’1 Â· ğ‘”ğ‘˜
ğ‘šâ€² Â· ğœ‡)
(mod ğ‘ğ‘…â€²),
(4.3.3)
where the approximation hides a small fractional error term (in 1
ant 4.2.2. Notice that the message is represented as a multiple of ğ‘
ğ‘ ğ‘…â€²) that satisï¬es Invari-
ğ‘ modulo ğ‘, hence the
name â€œMSD.â€ One can losslessly transform between LSD and MSD forms in linear time,
just by multiplying by appropriate Zğ‘-elements (see [AP13, Appendix A]). Each such
transformation implicitly multiplies the plaintext by some ï¬xed element of Zğ‘, which is why
a ciphertext carries an auxiliary factor ğ‘™ âˆˆ Zğ‘ that must be accounted for upon decryption.
4.3.2 Encryption and Decryption
To encrypt a message ğœ‡ âˆˆ ğ‘…ğ‘ under a key ğ‘  âˆˆ ğ‘…â€², one does the following: