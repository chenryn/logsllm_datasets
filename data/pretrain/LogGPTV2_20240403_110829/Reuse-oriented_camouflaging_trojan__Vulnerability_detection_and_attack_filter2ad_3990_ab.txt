duce undesirable 
and emitting 
functions 
identifies 
effects. 
effects 
extraction 
an output sub-sequence,
fea­
the set of modular functions 
in the 
to the task of manip­
by g. Other less 
them 
as subverting 
the output described 
are less vulnerable 
dedicated 
For example, 
the function 
is used by multiple 
features 
emails and communicating 
in pine includ­
with email servers. 
regarding 
to ROC attacks 
subverting 
the function 
would intro­
for all the services 
relying 
on it. 
output (input) 
More formally, 
to ROC 
features 
candidate 
standard 
(the input 
knowledge 
our approach 
The specified 
specification 
formats that can be inferred 
from 
the above examples, 
about the software. 
by these features. 
the output (input) 
output (input) 
is to represent 
the output generated 
To generalize 
vulnerability 
of software by identifying 
processed) 
often follows 
high-level 
we consider 
the relevant 
sequence 
parser filters the irrelevant 
vulnerability 
provide 
messages can 
ated parser is responsible 
and parsing 
it into fields (nonterminals). 
such fields will be used to compose ROC attacks. 
components, 
the grammar g. For instance, 
To use our ROC 
the user only needs to 
the grammar of email 
The gener­
of bytes and 
as a sub-sequence. 
The sub­
output 
As to be shown, 
for recognizing 
from RFC-2822. 
output (input). 
as a sequence 
is described 
the relevant 
detection 
be easily 
derived 
by a grammar g. The corresponding 
out by profiling. 
Let 
by 9 and 0i repre­
instruments 
byte to the 
the bi­
as PCi, meaning 
Feature 
is mainly carried 
of the instruction 
point of the byte, represented 
o be the output sub-sequence 
accepted 
sent the ith byte of o. Our technique 
nary to support a mapping from an observed 
definition 
the ith instance 
The instrumentation 
pendency 
widely used in data life time tracking 
tion (e.g., 
(e.g., 
In particular, 
movement, 
tween data definition 
stack context 
(namely taint analysis), 
and data arithmetic, 
of data definition 
malware analysis 
we instrument 
is via standard 
tracking 
and usage. 
[25]), 
and so on. 
each memory read, write, data 
[30]), 
to catch dependencies 
be­
which has been 
detec­
[13], exploit 
and usage. We also capture 
the call 
at pc during execution. 
dynamic program de­
The next step is to analyze the binary's 
executions 
that are dedicated 
to producing 
given an execution 
In our solution, 
functions 
identify 
evant output. 
relevant 
a node representing 
a dynamic function 
instance 
and an 
output is 0, a dynamic call tree is constructed, 
to 
the rel­
E whose 
with 
978-1-4244-7501-8/10
/$26.00 
©2010 IEEE 
283 
DSN 2010: Lin et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:05:19 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEEIIFIP International 
Conference 
on Dependable Systems 
& Networks 
(DSN) 
Contexts) 
---+ vsprintf 
Call Tree Paths (Calling 
---+ vfprintf ---+ _IO..defauILxsputn 
of Definitions 
---+smtp_ehlo---+sprintf 
Content 
· . .  call..mailer
EHLO  [10.0.0.4]\r\n 
... call..mailer
RSET\r\n 
MAIL FROM:\r\n · . .  call..mailer
RCPT TO:\r\n · . .  call..mailer
... call..mailer
DATA\r\n 
Date: Wed, 22 Oct 2008 14: 00: ...  ... call..mailer
From: Alice \r\n ... call..mailer
X  X Sender:  PI:EMAIL\r\n ... call..mailer
· . .  call..mailer
To: PI:EMAIL\r\n 
· . .  call..mailer
Subject: a test\r\n 
· . .  call..mailer
Message-ID:  From:  
To: PI:EMAIL  To: PI:EMAIL 
This is a sparn email. 
Subject: Hello 
Hello, 
world 
Table 2. The two different 
test emails 
frame, or a register. 
on the current 
a stack variable 
variable, 
Hence the roots of an RG have to be one of the above three 
types of variables. 
over the memory space so that indices 
tify memory alignment. 
follows. 
The formal definition 
can be used to iden­
of RG is as 
The RG serves as an indexing  scheme 
graph is a pair (N, E) with N be­
Definition 1  A reference 
ing the set of nodes and E being the set of edges. A node 
represents 
a memory region or afield. There are two types 
of edges. 
leads to the same variable 
(memory region) 
across 
• There is afield edge between 
nodes nand m, denoted 
as n --{)  m,  if m  is a field of n. The field name is 
annotated 
information 
is not 
available, 
on the edge. If symbolic 
the offset is annotated. 
some of the program inputs and 
outputs. 
The 
noted as n ----t  m, if n stores 
execution. 
The 
m. 
at the invocation 
• There is a pointer 
edge between nodes nand m, de­
a pointer 
that points to 
the relevant 
In our pine example, 
we acquire 
two executions 
by run­
we need to check if the behavior 
of 
are truly vulnerable, 
these functions 
Therefore, 
identify 
arguments 
out loss of generality, 
this section. 
critical 
the last step in ROC vulnerability 
can be mutated by changing 
of these feature 
we consider 
one feature 
program state. 
detection 
functions. 
function 
is to 
With­
f in 
The ROC vulnerability 
relies 
detector 
on checking 
two 
One is to identify the important 
(mem­
variables 
whose values need to be modified in order to 
the specified output. For example, 
email re­
entails 
email address. 
conditions. 
ory regions) 
manipulate 
direction 
recipient's 
tify the reference 
A variable 
through their absolute 
run to run. Therefore, 
hence f is not vulnerable) 
sistently 
all runs can be identified. 
finding the memory region that stores the 
is to iden­
The other condition 
paths to these variables 
(memory regions). 
or a memory region cannot be accessed 
simply 
addresses, 
an attack cannot be constructed 
which may change from 
(and 
unless a reference 
path that con­
critical 
mem­
We obtain an ex­
Our ROC vulnerability 
detector 
identifies 
function 
by changing 
the software 
f are compared 
through memory differencing. 
to produce different 
is called the reference 
of the two executions 
ory regions 
tra execution 
directing 
original 
execution 
memory snapshots 
of the feature 
memory regions. 
erence execution 
the extra execution 
sage to a different 
the invocations 
pared to identify 
ent address, 
which should be the only difference 
runs. Recall that call...mailer is the candidate 
ble function 
For example, 
sends a message to an address 
is acquired 
address 
of call...mailer in the two runs are com­
by sending the same mes­
identified 
to isolate 
in the pine case, the ref­
of the two 
in the previous 
phase. 
a dynamic data structure 
In practice, 
the memory region that stores the recipi­
y. The memory states before 
x, whereas 
vulnera­
d may be allocated 
in the two runs. Comparing 
the same 
(of d in one run) in both runs may lead to 
value in 
that d does not hold the same 
compare two memory snapshots, 
locations 
to different 
memory location 
the wrong conclusion 
the two runs. To properly 
we need to construct 
cells. 
lem. More formally, 
a memory variable 
tion identifies 
to i. The function 
for short if the two executions 
MA( i) is a partial 
to any memory variable 
noted as MA(i) =  ..1. 
function, 
the correspondence 
between memory 
We define the problem as a memory alignment 
prob­
E and E' and 
i in E, the memory alignment 
given two executions 
func­
a memory variable 
in E' that corresponds 
is denoted as MAE--->E,(i), 
or MA(i) 
are clear from the context. 
for i that does not correspond 
in E', MA( i) is undefined, 
de­
Theoretically, 
memory alignment 
problem. We propose an approximate 
Reference 
Graph (RG). Intuitively, 
paths to all live memory regions. 
gion, there must exist a reference 
For any live memory re­
path starting 
RG identifies 
based on 
reference 
from a global 
is an undecidable 
solution 
ning pine twice, with the same 
sender and recipient 
email contents. 
one is a spam email and the other is a regular 
and 
We show these two test emails in Table 2: 
configuration 
but different 
and the same 
subjects 
addresses, 
one. 
The two RGs at the invocation 
point of call...mailer 
the cur­
and thus omitted). 
in Fig. 4. The root nodes  represent 
are irrele­
In Fig. 4(a) , three 
are presented 
rent stack frame (the roots for the global regions 
vant for our discussion 
fields have been reverse 
0,4 and 8. The first two are pointers, 
a value O. The first pointer 
memory region that has two fields, and so on. 
are aligned 
The two memory snapshots 
field Oxbfffcf58 
with the byte offsets of 
engineered 
the last one contains 
points to a 
by aligning 
their 
their alignment 
can 
graph alignment 
algo­
are highlighted 
is defined as a memory re­
value in its alignment 
out by a simple labeled 
RGs. Since RGs are graphs with labels, 
be carried 
rithm. A memory difference 
gion that has a different 
in the other 
RG. Observe the two RGs in Fig. 4 are highly similar. 
differences 
value differences 
memory allocation. 
the subject 
time-stamps 
content 
diff-ing 
to find the content. 
Note that the 
is encoded, 
of memory 
because a simple scan over the memory would fail 
in 
Two out of the four differences 
are for 
and book-keeping 
which justifies 
information. 
and the content. 
our approach 
to tolerate 