leakage-resilient constructions which can be tweaked to ﬁt these requirements at a reasonable
cost. The ﬁrst one is a binary tree pseudo-random function introduced by Faust, Pietzrak and
Schipper at CHES 2012 [FPS12] and the second one is a sequential stateful pseudo-random
number generator with minimum public randomness proposed by Yu and Standaert at CT-
RSA 2013 [YS13]. We ignore the chronological order and start the description with the second
instantiation since a part of it will be used to complete the ﬁrst one.
Sequential Stateful Pseudo-Random Number Generator from [YS13] The stateful
pseudo-random number generator of Yu and Standaert comes with an internal state made of
two randomly chosen values : a secret key K0 ∈ {0, 1}µ and a public seed s ∈ {0, 1}µ. The
construction is made of two stages. In the upper stage, a (non leakage-resilient) generator F0 is
processed in counter mode to expand the seed s into uniformly random values p0, p1, . . . . In the
lower stage, a (non leakage-resilient) pseudo-random function F generates outputs with public
values pi and updates the secret so it is never used more than twice. The parameter s can be
included in our seed (under the notation X00) since it shares the same properties than X and X0.
However, the current counter is varying and thus need to be stored in the deterministic part of
the internal state. In the proof of [YS13], the counter is implicitly required to be diﬀerent at
each use since the public values pi need to be independent. But in our model of leakage-resilient
robustness, the deterministic part of the internal state can be deﬁnitively compromised by the
attacker who could, in this case, set the counter to a previous value, making the public pi not
independent anymore. To thwart this issue, we suggest to extend the internal state so that
the truncated part of full entropy can contain both the secret key K0 and a uniformly random
counter used only for a single execution of next. This way, no parameter can be compromised
and we are back to the context of the proof made by the designers. The only diﬀerence in the
security comes from the probability of collisions when using a uniformly random counter at each
call.
This two-stage instantiation is illustrated in Figure 6.5. One can note that the input U is split
in two slices, to initiate the secret key K0 and the counter C, each of size µ. In order to relate
these parameters with the parameters of our generator from Section 6.4 that provides an m-bit
random string U as input to the gen G, and wants to receive back an N-bit string, we set
N = n + ‘: κ = N/µ blocks are generated with κ keys and the κ blocks of output and new
internal state are all generated using 2κ − 1 calls to F0 and 2κ − 1 calls to F.
The security of this instantiation is almost entirely guaranteed by its designers in [YS13]. The
only diﬀerence concerns the uniformly generated counter at each call to function next. Consider-
ing the additional possible collisions, Theorem 17 shows how this solution achieves the security
— 103 —
Chapter 6. Robustness Against Side-Channel Attacks
s
e
l
b
a
i
r
a
v
c
i
l
b
u
p
X0
C
K0
F0
p0
F
···
C + ν − 2
F0
C + ν − 1
F0
···
C + ν(κ − 1)
F0
···
C + νκ − 2
F0
pν−2
pν−1
pν(κ−1)
pνκ−2
···
···
K0
F
K0
F
K1
···
Kκ−1
F
···
Kκ−1
F
(S0, R)
Figure 6.5 – Instantiation of Generator G from [YS13] with Random Input U = (C, K0)
requirements in Deﬁnition 40.
Theorem 17. Let µ and κ be parameters such that (ν − 1)κµ = N. Let F : {0, 1}µ ×
{0, 1}µ → {0, 1}µ be a (α/κ, λ)-leakage-resilient and (t, ν, εF)-secure pseudo-random function
and F0 : {0, 1}µ×{0, 1}µ → {0, 1}µ be a (t, q(νκ−1), εF0)-secure pseudo-random function, where
q is a bound on the global number of executions of G. The instantiation proposed for G as
described on Figure 6.5 with F and F0 provides an (α, λ)-leakage-resilient and (t, εG)-secure
pseudo-random number generator where εG ≤ κεF + εF0 + q2(νκ − 1)/2µ.
In the proposal, each call to G makes (νκ − 1) calls to the pseudo-random function F: κ keys
are used at most ν times. The inputs of F are generated by F0 with the key X00 (randomly set in
seed) on a counter C randomly initialized, and then incremented for each F0 call in an execution
of G.
The main details of the proof can be found in [YS13], including the upper stage whose validity
is guaranteed in the peculiar world minicrypt introduced in [Imp95]. The only diﬀerences come
from the (possible) multiple use of the same secret key: ν times instead of two and the uniformly
distributed counter. They are both integrated in the generator parameters.
j) to be distinct
Note however that, for the global security, one needs all the intermediate values (pi
and unpredictable to avoid the attack described above. We thus require F0 to be secure after
qn(νκ − 1) queries and the inputs to be all distinct: by setting the log(νκ − 1) least signiﬁcant
bits of C to zero, we just have to avoid collisions on the µ− log(νκ− 1) most signiﬁcant bits for
2(νκ − 1)/2µ. This probability
the qn queries. The probability of collision is thus less than qn
can appear once and for all in the global security:
Proposition 8. Let us consider parameters n, m, and ‘ in the construction of the pseudo-
random number generator with input G from Section 6.2, using the standard pseudo-random
— 104 —
6.5. Instantiations
2 + 1) ·
ε ≤ qqn ·(cid:16)(qr
2m+1−δ + 3(κεF + εF0)(cid:17)+ qn
√
i used only for the generation of keys Ki.
number generator G as described on Figure 6.5. Let µ and κ be parameters such that (ν−1)κµ =
n+‘, and α > γ∗. Let F : {0, 1}µ×{0, 1}µ → {0, 1}µ be a (α/κ, λ)-leakage-resilient and (t, ν, εF)-
secure pseudo-random function, and F0 : {0, 1}µ × {0, 1}µ → {0, 1}µ be a (t, qn(νκ − 1), εF0)-
secure pseudo-random function. Then, G is (t, qr, qn, qs, γ∗, λ, ε)-leakage-resilient robust after
at most q = qr + qn + qs queries, where qr is the number of D-refresh/leak-refresh-queries, qn
the number of next-ror/leak-next-queries, and qs the number of get-state/set-state-queries, where
2(νκ−1)/2µ, for δ = min{n−log qr, γ∗ − λ}.
It seems reasonable to have (α, λ)-leakage resilience with α = n + ‘ − (νκ − 1)λ: with a large
γ∗, ε can be made small.
Binary Tree Pseudo-Random Function from [FPS12] The second solution was proposed
by Faust et al. at CHES 2012 [FPS12]. It requires a few more calls to F0 and F but depending
on the inherent device, some parts can be parallelized to overtake the performances of the ﬁrst
solution. The initial solution does not provide sources for the required randomness. That is
why we use the same upper stage as proposed in the ﬁrst solution. Whereas the leakage-resilient
security of this combination is provided in [YS13] and [ABF13], for the same reasons as above,
we need to get use of a uniformly random counter, updated at each call to next. Figure 6.6
illustrates this second instantiation with keys K0
The security of this second instantiation with the speciﬁc generation of randomness is claimed
in [FPS12] and [YS13] for the keys generation and in [ABF13] for the global proposal, but for
an incremental counter. The use of a uniformly random counter slightly modiﬁes the security
parameters by taking into account the probability of collisions. Theorem 18 shows the conformity
with the security requirements of Deﬁnition 40.
Theorem 18. Let µ and κ be parameters such that νκµ = N. Let F : {0, 1}µ×{0, 1}µ → {0, 1}µ
be a (α/κ, λ)-leakage-resilient and (t, ν, εF)-secure pseudo-random function and F0 : {0, 1}µ ×
{0, 1}µ → {0, 1}µ be a (t, q(2 log2(κ) + νκ), εF0)-secure pseudo-random function, where q is a
bound on the global number of executions of G. The instantiation proposed for G as described
in Figure 6.6 with F and F0 provides an (α, λ)-leakage-resilient and (t, εG)-secure pseudo-random
number generator where εG ≤ (2κ)εF + εF0 + q2(νκ + 2 log2(κ))/2µ.
In the proposal, each call to G makes νκ calls to the pseudo-random function F: κ keys are used
at most ν times. These keys are the leaves generated by a binary tree whose nodes get use of
the outputs of the generator F0 with the key X00. As mentioned in [FPS12], only two uniformly
distributed inputs by tree layer are necessary. The generator F0, executed in counter mode as
done before, also provides the inputs of F, which raises the total number of required uniformly
distributed inputs to 2 log2(κ) + νκ.
The main details of the proof can be found in [FPS12] for the key generation and in [ABF13]
for the global construction. However and as before, the proof does not consider such a changing
counter. Using the same trick as for the previous instantiation, we get the global security:
Proposition 9. Let us consider parameters n, m, and ‘ in the construction of the pseudo-
random number generator with input G from from Section 6.2, using the generator G as described
on Figure 6.7. Let µ and κ be parameters such that νκµ = n + ‘, and α > γ∗. Let F :
{0, 1}µ × {0, 1}µ → {0, 1}µ be a (α/κ, λ)-leakage-resilient and (t, ν, εF)-secure pseudo-random
function, and F0 : {0, 1}µ × {0, 1}µ → {0, 1}µ be a (t, qn(2 log2(κ) + νκ)), εF0)-secure pseudo-
random function. Then, G is (t, qr, qn, qs, γ∗, λ, ε)-leakage-resilient robust after at most q =
qr + qn + qs queries, where qr is the number of D-refresh/leak-refresh-queries, qn the number
of next-ror/leak-next-queries, and qs the number of get-state/set-state-queries, where ε ≤ qqn ·
2(2 log2(κ)+νκ)/2µ, for δ = min{n−log qr, γ∗−λ}.
2m+1−δ + 3(2κ · εF + εF0)(cid:17)+qn
(cid:16)(qr
√
2 + 1) ·
— 105 —
Chapter 6. Robustness Against Side-Channel Attacks
s
e
l
b
a
i
r
a
v
c
i
l
b
u
p
)
s
e
v
a
e
l
(
s
y
e
k
f
o
n
o
i
t
a
r
e
n
e
g
X00
C
F0
p0
···
C + 2 log2(κ) + κν − 1
F0
p2 log2(κ)+κν−1
K0
0
F(p0)
K0
1
F(p1)
K0
2
F(p2)
F(p3)
F(p4)
F(p5)
p2 log2(κ)
K0
F
···
···
···
K0
···
p2 log2(κ)+1
···
p2 log2(κ)+κν−2
F
···
Kκ−1
F
···
···
p2 log2(κ)+κν−1
Kκ−1
F
(S0, R)
Figure 6.6 – Instantiation of Generator G from [FPS12] with Random Input U = (C, K0
0)
It seems reasonable to have (α, λ)-leakage resilience with α = n + ‘ − νκλ: with a large γ∗, ε
can be made small.
New Instantiation As for the existing constructions, since we cannot use a pseudo-random
function with diﬀerent public inputs and a single key (as shown by the ﬁrst attack in Section 6.2,
we follow the conclusions from [BGS15] and make use of a pseudo-random function with a regular
re-keying whose frequency depends on the parameters of the inherent device. Fortunately, the
number of measurements an attacker can make (which ﬁts with the data complexity) is limited
by design. To thwart the second attack described in Section 6.2 and for the needs of the