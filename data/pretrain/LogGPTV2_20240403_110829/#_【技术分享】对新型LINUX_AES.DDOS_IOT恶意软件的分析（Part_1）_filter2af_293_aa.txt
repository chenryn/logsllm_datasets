# 【技术分享】对新型LINUX/AES.DDOS IOT恶意软件的分析（Part 1）
|
##### 译文声明
本文是翻译文章，文章来源：lloydlabs.github.io
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
****
译者：[兴趣使然的小胃](http://bobao.360.cn/member/contribute?uid=2819002922)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**一、前言**  
在本文中，我们介绍了一款僵尸程序，这款僵尸程序通过暴力破解SSH凭据，使用一系列攻击技术来攻击IoT设备，借助这些设备达到传播目的。这款恶意软件的主要传播者为某位中国黑客，这名黑客对C++及C语言中的构造方法较为了解，但用的最多的还是C++中的`std::string`类。这款僵尸程序几年前针对的只是x86_64平台，但现在情况有所改变。根据我们对`Linux/AES.DDoS`僵尸程序导出符号及C++构造函数的观察，我们判断该应用所使用的是C++语言。
本文中我们用到的分析工具包括：
1、gdb-peda：
2、BinaryNinja：
3、ltrace：
4、radare2：
**  
**
**二、样本概况**
如果我们使用file命令分析这个程序，我们可以得到如下结果：
    ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.14, not stripped.
因此，这是一个32位ELF可执行文件（UNIX系统上的COFF格式），ARM架构，静态链接了所有的库文件。IoT僵尸程序经常在程序中静态链接libc库，因为许多系统上的程序库通常处于不完整甚至损坏状态。因此这类程序一般不会动态链接可执行程序，相反它们会采用静态链接方案。这款恶意软件没有剔除这些有价值信息，因此我们可以在程序中找到一些有意义的对象名，使分析工作大为简化。出于某些奇怪的原因，攻击者使用已有12年历史的一个Linux内核来编译这款软件，这表明恶意软件很有可能是在某个IoT设备或某台老式主机上编译而成。
样本哈希值如下：
MD5：125679536fd4dd82106482ea1b4c1726
SHA1：6caf6a6cf1bc03a038e878431db54c2127bfc2c1
**  
**
**三、ARM快速简介**
ARM是一种32位指令集架构，因此所有的寄存器都是32位寄存器。在ARM架构中，标准的调用约定是将参数存放于r0到r3寄存器中。r0到r3只有4个寄存器，因此如果函数使用的参数个数大于3个，那么剩余的参数可以存放于栈上。我们可以使用16个寄存器，每个寄存器都有其特殊用途，具体用途如下：
1、r0、r1、r2、r3用于参数传递，r0通常用来保存函数返回值；
2、r4、r5、r6、r7、r8、r9用来存放程序内部变量；
3、r10存放当前栈限制指针；
4、r11存放栈帧指针；
5、r12也可以用作程序内部变量寄存器，但我们无法保证调用期间该寄存器保持不变；
6、r13存放堆栈指针（stack pointer，SP）；
7、r14为连接寄存器（link register），指向调用者；
8、r15存放程序计数器。
掌握这些基本知识后，我们可以继续开展后续研究工作。
**  
**
**四、分析main函数**
恶意软件会从原始入口点（main）启动，该函数地址为0x13DEC。我们可以使用rabin2查找原始入口点，具体命令为`rabin2 -s kfts |
grep "type=FUNC name=main"`，这条命令的输出结果如下所示：
    vaddr=0x00013dec paddr=0x0000bdec ord=5366 fwd=NONE sz=688 bind=GLOBAL type=FUNC name=main
这个程序没有经过加壳处理。main方法会执行名为get_executable_name的一个函数分支，该函数通过`readlink(..)`读取符号链接`/proc/self/exe`。如果在进程内部读取这个符号链接，会得到程序运行时所处的具体位置。从反汇编结果中我们可知，程序创建了一个`std::string`字符串，将包含当前执行路径的char数组复制到该字符串中。随后的本地持久化过程中会用到这个字符串。
随后，程序会检查自身是否处于运行状态，根据结果决定是否添加为启动程序。在`check_running`流程中，程序会执行“ps
-e”命令，休眠2秒，然后查找结果中是否包含当前的程序名。如果已包含当前程序名，则跳转到exit分支，退出代码为0（存放于r0寄存器中），以完全关闭当前进程。如果不包含当前程序名，则执行持久化分支。简而言之，如果之前该已处于运行状态，则程序会直接退出执行。
**  
**
**五、持久化方法**
恶意软件通过往`/etc/rc.local`以及`/etc/init.d/boot.local`文件（auto_boot函数）中添加内容实现本地持久化，在覆盖这些文件之前，恶意软件会先检查之前是否已执行过覆盖操作。当所有的系统服务启动完毕后，`/etc/rc.local`会执行某些命令。然而，恶意软件所使用的持久化技术相对而言较为业余，它构造了一个shell命令，然后使用`system`函数来执行这条命令（理论上这种方法相当于调用exec，然后挂起等待被调用的程序返回）。
恶意软件使用sed程序将某个格式化字符串写入目标文件（样本中有几处用到了字符串操作，比如`sed -i -e '2 i%s/%s'