its ETW Provider.
48. Now that boot-start and system-start drivers are loaded, the errata manager loads the INF
database with the driver errata and begins parsing it, which includes applying registry PCI
configuration workarounds.
49. If the computer is booting in safe mode, this fact is recorded in the registry.
CHAPTER 12 Startup and shutdown
829
50. Unless explicitly disabled in the registry, paging of kernel-mode code (in Ntoskrnl and drivers)
is enabled.
51. The power manager is called to finalize its initialization.
52. The kernel clock timer support is initialized.
53. Before the INIT section of Ntoskrnl will be discarded, the rest of the licensing information for
the system is copied into a private system section, including the current policy settings that are
stored in the registry. The system expiration time is then set.
54. The process manager is called to set up rate limiting for jobs and the system process creation
time. It initializes the static environment for protected processes, and looks up various system-
defined entry points in the user-mode system libraries previously mapped by the I/O manager
(usually Ntdll.dll, Ntdll32.dll, and Vertdll.dll).
55. The security reference monitor is called to create the Command Server thread that commu-
nicates with LSASS. This phase creates the Reference Monitor command port, used by LSA to
send commands to the SRM. (See the section Security system components in Chapter 7 in Part
1 for more on how security is enforced in Windows.)
56. If the VSM is enabled, the encrypted VSM keys are saved to disk. The system user-mode librar-
ies are mapped into the Secure System Process. In this way, the Secure Kernel receives all the
needed information about the VTL 0’s system DLLs.
57. The Session Manager (Smss) process (introduced in Chapter 2, System architecture, in Part 1)
is started. Smss is responsible for creating the user-mode environment that provides the visible
interface to Windowsits initialization steps are covered in the next section.
58. The bootvid driver is enabled to allow the NT check disk tool to display the output strings.
59. The TPM boot entropy values are ueried. These values can be ueried only once per boot, and
normally, the TPM system driver should have ueried them by now, but if this driver has not
been running for some reason (perhaps the user disabled it), the unueried values would still
be available. Therefore, the kernel also manually ueries them to avoid this situation in normal
scenarios, the kernel’s own query should fail.
60. All the memory used by the loader parameter block and all its references (like the initialization
code of Ntoskrnl and all boot drivers, which reside in the INIT sections) are now freed.
As a final step before considering the executive and kernel initialization complete, the phase 1 
initialization thread sets the critical break on termination flag to the new Smss process. In this way, if 
the Smss process exits or gets terminated for some reason, the kernel intercepts this, breaks into the 
attached debugger (if any), and crashes the system with a O stop code.
If the five-second wait times out (that is, if five seconds elapse), the Session Manager is assumed to 
have started successfully, and the phase 1 initialization thread exits. Thus, the boot processor executes 
one of the memory manager’s system threads created in step 22 or returns to the Idle loop.
830 
CHAPTER 12 Startup and shutdown
Smss, Csrss, and Wininit
Smss is like any other user-mode process except for two differences. First, Windows considers Smss 
a trusted part of the operating system. Second, Smss is a ne application. Because it’s a trusted 
operating system component, Smss runs as a protected process light (PPL PPLs are covered in Part 1, 
Chapter 3, Processes and jobs) and can perform actions few other processes can perform, such as 
creating security tokens. Because it’s a native application, Smss doesn’t use Windows APIsit uses 
only core executive APIs known collectively as the Windows native API (which are normally exposed by 
Ntdll). Smss doesn’t use the Win32 APIs, because the Windows subsystem isn’t executing when Smss 
launches. In fact, one of Smss’s first tasks is to start the Windows subsystem.
Smss initialization has been already covered in the Session Manager section of Chapter 2 of Part 1. 
For all the initialization details, please refer to that chapter. When the master Smss creates the children 
Smss processes, it passes two section objects’ handles as parameters. The two section objects represent 
the shared buffers used for exchanging data between multiple Smss and Csrss instances (one is used to 
communicate between the parent and the child Smss processes, and the other is used to communicate 
with the client subsystem process). The master Smss spawns the child using the lreeserress 
routine, specifying a flag to instruct the Process Manager to create a new session. In this case, the 
PspAllocateProcess kernel function calls the memory manager to create the new session address space.
The executable name that the child Smss launches at the end of its initialization is stored in the 
shared section, and, as stated in Chapter 2, is usually Wininit.exe for session 0 and Winlogon.exe for any 
interactive sessions. An important concept to remember is that before the new session 0 Smss launches 
Wininit, it connects to the Master Smss (through the SmApiPort ALPC port) and loads and initializes all 
the subsystems. 
The session manager acuires the Load Driver privilege and asks the kernel to load and map the 
Win32k driver into the new Session address space (using the eysenrn native API). It 
then launches the client-server subsystem process (Csrss.exe), specifying in the command line the fol-
lowing information the root Windows Object directory name (Windows), the shared section objects’ 
handles, the subsystem name (Windows), and the subsystem’s DLLs
I 
Basesrv.dll The server side of the subsystem process
I 
Sxssrv.dll The side-by-side subsystem support extension module
I 
Winsrv.dll The multiuser subsystem support module
The client–server subsystem process performs some initialization It enables some process mitigation 
options, removes unneeded privileges from its token, starts its own ETW provider, and initializes a linked 
list of O data structures to trace all the Win32 processes that will be started in the system. It 
then parses its command line, grabs the shared sections’ handles, and creates two ALPC ports
I 
CSR API command port (SessionsIDWindowsApiPort) This ALPC Port will be used by
every Win32 process to communicate with the Csrss subsystem. (Kernelbase.dll connects to it in
its initialization routine.)
CHAPTER 12 Startup and shutdown
831
I 
Susystem Session anager A ort (SessionsIDWindowsSbApiPort) This port is
used by the session manager to send commands to Csrss.
Csrss creates the two threads used to dispatch the commands received by the ALPC ports. Finally, 
it connects to the Session Manager, through another ALPC port (SmApiPort), which was previously 
created in the Smss initialization process (step 6 of the initialization procedure described in Chapter 2). 
In the connection process, the Csrss process sends the name of the just-created Session Manager API 
port. From now on, new interactive sessions can be started. So, the main Csrss thread finally exits.
After spawning the subsystem process, the child Smss launches the initial process (Wininit or 
Winlogon) and then exits. Only the master instance of Smss remains active. The main thread in Smss 
waits forever on the process handle of Csrss, whereas the other ALPC threads wait for messages to 
create new sessions or subsystems. If either Wininit or Csrss terminate unexpectedly, the kernel crashes 
the system because these processes are marked as critical. If Winlogon terminates unexpectedly, the 
session associated with it is logged off.
Pending file rename operations
The fact that executable images and DLLs are memory-mapped when they’re used makes it impos-
sible to update core system files after Windows has finished booting (unless hotpatching technolo-
gy is used, but that’s only for Microsoft patches to the operating system). The ele Windows 
API has an option to specify that a file move be delayed until the next boot. Service packs and 
hotfixes that must update in-use memory-mapped files install replacement files onto a system in 
temporary locations and use the ele API to have them replace otherwise in-use files. When 
used with that option, ele simply records commands in the ennleeneOperns 
and ennleeneOperns keys under KLMSSTEMCurrentControlSetControlSession 
Manager. These registry values are of type , where each operation is specified in pairs of 
file names The first file name is the source location, and the second is the target location. Delete 
operations use an empty string as their target path. ou can use the Pendmoves utility from 
Windows Sysinternals (ps//srs/enus/sysnernls/) to view registered delayed 
rename and delete commands.
Wininit performs its startup steps, as described in the “Windows initialization process” section of 
Chapter 2 in Part 1, such as creating the initial window station and desktop objects. It also sets up the 
user environment, starts the Shutdown RPC server and WSI interface (see the Shutdown section later 
in this chapter for further details), and creates the service control manager (SCM) process (Services.exe), 
which loads all services and device drivers marked for auto-start. The local session manager (Lsm.dll) 
service, which runs in a shared Svchost process, is launched at this time. Wininit next checks whether 
there has been a previous system crash, and, if so, it carves the crash dump and starts the Windows 
Error Reporting process (werfault.exe) for further processing. It finally starts the Local Security 
Authentication Subsystem Service (SystemRootSystem32Lsass.exe) and, if Credential Guard is 
enabled, the Isolated LSA Trustlet (Lsaiso.exe) and waits forever for a system shutdown reuest.
832 
CHAPTER 12 Startup and shutdown
On session 1 and beyond, Winlogon runs instead. While Wininit creates the noninteractive session 0 
windows station, Winlogon creates the default interactive-session Windows station, called WinSta0, 
and two desktops the Winlogon secure desktop and the default user desktop. Winlogon then ueries 
the system boot information using the ueryysenrn API (only on the first interactive 
logon session). If the boot configuration includes the volatile Os Selection menu flag, it starts the GDI 
system (spawning a UMDF host process, fontdrvhost.exe) and launches the modern boot menu appli-
cation (Bootim.exe). The volatile Os Selection menu flag is set in early boot stages by the Bootmgr only 
if a multiboot environment was previously detected (for more details see the section The boot menu 
earlier in this chapter). 
Bootim is the GUI application that draws the modern boot menu. The new modern boot uses the 
Win32 subsystem (graphics driver and GDI calls) with the goal of supporting high resolutions for 
displaying boot choices and advanced options. Even touchscreens are supported, so the user can select 
which operating system to launch using a simple touch. Winlogon spawns the new Bootim process 
and waits for its termination. When the user makes a selection, Bootim exits. Winlogon checks the exit 
code thus it’s able to detect whether the user has selected an OS or a boot tool or has simply re-
quested a system shutdown. If the user has selected an OS different from the current one, Bootim adds 
the sequene one-shot BCD option in the main system boot store (see the section The Windows 
Boot Manager earlier in this chapter for more details about the BCD store). The new boot seuence is 
recognized (and the BCD option deleted) by the Windows Boot Manager after Winlogon has restarted 
the machine using NtShutdownSystem API. Winlogon marks the previous boot entry as good before 
restarting the system.
EXPERIMENT: Playing with the modern boot menu
The modern boot menu application, spawned by Winlogon after Csrss is started, is really a clas-
sical Win32 GUI application. This experiment demonstrates it. In this case, it’s better if you start 
with a properly configured multiboot system otherwise, you won’t be able to see the multiple 
entries in the Modern boot menu. 
Open a non-elevated console window (by typing cmd in the Start menu search box) and go 
to the WindowsSystem32 path of the boot volume by typing cd /d C:\Windows\System32 
(where C is the letter of your boot volume). Then type Bootim.exe and press Enter. A screen 
similar to the modern boot menu should appear, showing only the Turn Off Your Computer op-
tion. This is because the Bootim process has been started under the standard non-administrative 
token (the one generated for User Account Control). Indeed, the process isn’t able to access the 
system boot configuration data. Press CtrlAltDel to start the Task Manager and terminate the 
BootIm process, or simply select Turn Off Your Computer. The actual shutdown process is start-
ed by the caller process (which is Winlogon in the original boot sequence) and not by BootIm.
EXPERIMENT: Playing with the modern boot menu
The modern boot menu application, spawned by Winlogon after Csrss is started, is really a clas-
sical Win32 GUI application. This experiment demonstrates it. In this case, it’s better if you start 
with a properly configured multiboot system otherwise, you won’t be able to see the multiple 
entries in the Modern boot menu. 
Open a non-elevated console window (by typing cmd in the Start menu search box) and go 
to the WindowsSystem32 path of the boot volume by typing cd /d C:\Windows\System32
(where C is the letter of your boot volume). Then type Bootim.exe and press Enter. A screen 
similar to the modern boot menu should appear, showing only the Turn Off Your Computer op-
tion. This is because the Bootim process has been started under the standard non-administrative 
token (the one generated for User Account Control). Indeed, the process isn’t able to access the 
system boot configuration data. Press CtrlAltDel to start the Task Manager and terminate the 
BootIm process, or simply select Turn Off Your Computer. The actual shutdown process is start-
ed by the caller process (which is Winlogon in the original boot sequence) and not by BootIm.
CHAPTER 12 Startup and shutdown
833
Now you should run the Command Prompt window with an administrative token by right-
clicking its taskbar icon or the Command Prompt item in the Windows search box and selecting 
Run As Administrator. In the new administrative prompt, start the BootIm executable. This time 
you will see the real modern boot menu, compiled with all the boot options and tools, similar to 
the one shown in the following picture
In all other cases, Winlogon waits for the initialization of the LSASS process and LSM service. It 
then spawns a new instance of the DWM process (Desktop Windows Manager, a component used to 
draw the modern graphical interface) and loads the registered credential providers for the system (by 
default, the Microsoft credential provider supports password-based, pin-based, and biometrics-based 
logons) into a child process called LogonUI (SystemRootSystem32Logonui.exe), which is responsi-
ble for displaying the logon interface. (For more details on the startup sequence for Wininit, Winlogon, 
and LSASS, see the section “Winlogon initialization” in Chapter 7 in Part 1.)
After launching the LogonUI process, Winlogon starts its internal finite-state machine. This is used 
to manage all the possible states generated by the different logon types, like the standard interactive 
logon, terminal server, fast user switch, and hiberboot. In standard interactive logon types, Winlogon 
shows a welcome screen and waits for an interactive logon notification from the credential provider 
(configuring the SAS seuence if needed). When the user has inserted their credential (that can be a 
password, PIN, or biometric information), Winlogon creates a logon session LUID, and validates the 
logon using the authentication packages registered in Lsass (a process for which you can find more 
Now you should run the Command Prompt window with an administrative token by right-
clicking its taskbar icon or the Command Prompt item in the Windows search box and selecting 
Run As Administrator. In the new administrative prompt, start the BootIm executable. This time 
you will see the real modern boot menu, compiled with all the boot options and tools, similar to 
the one shown in the following picture
834 
CHAPTER 12 Startup and shutdown
information in the section User logon steps in Chapter 7 in Part 1). Even if the authentication won’t 
succeed, Winlogon at this stage marks the current boot as good. If the authentication succeeded, 
Winlogon verifies the seuential logon scenario in case of client SKUs, in which only one session each 
time could be generated, and, if this is not the case and another session is active, asks the user how to 
proceed. It then loads the registry hive from the profile of the user logging on, mapping it to KCU. It 
adds the reuired ACLs to the new session’s Windows Station and Desktop and creates the user’s envi-
ronment variables that are stored in KCUEnvironment. 
Winlogon next waits the Sihost process and starts the shell by launching the executable or executables 
specified in KLMSOFTWAREMicrosoftWindows NTCurrentVersionWinLogonUserinit (with multiple 
executables separated by commas) that by default points at WindowsSystem32Userinit.exe. The new 
Userinit process will live in Winsta0Default desktop. Userinit.exe performs the following steps
1.
Creates the per-session volatile Explorer Session key KCUSoftwareMicrosoftWindows
CurrentVersion\Explorer\SessionInfo\.
2.
Processes the user scripts specified in KCUSoftwarePoliciesMicrosoftWindowsSystem
Scripts and the machine logon scripts in KLMSOFTWAREPoliciesMicrosoftWindows
SystemScripts. (Because machine scripts run after user scripts, they can override user settings.)
3.
Launches the comma-separated shell or shells specified in KCUSoftwareMicrosoftWindows
NTCurrentVersionWinlogonShell. If that value doesn’t exist, Userinit.exe launches the shell or
shells specified in KLMSOFTWAREMicrosoftWindows NTCurrentVersionWinlogonShell,
which is by default Explorer.exe.
4.
If Group Policy specifies a user profile uota, starts SystemRootSystem32Prouota.exe to
enforce the quota for the current user.
Winlogon then notifies registered network providers that a user has logged on, starting the mpno-
tify.exe process. The Microsoft network provider, Multiple Provider Router (SystemRootSystem32
Mpr.dll), restores the user’s persistent drive letter and printer mappings stored in KCUNetwork and 
KCUPrinters, respectively. Figure 12-11 shows the process tree as seen in Process Monitor after a 
logon (using its boot logging capability). Note the Smss processes that are dimmed (meaning that they 
have since exited). These refer to the spawned copies that initialize each session.
CHAPTER 12 Startup and shutdown
835
FIGURE 12-11 Process tree during logon.
ReadyBoot
Windows uses the standard logical boot-time prefetcher (described in Chapter 5 of Part 1) if the system 
has less than 400 MB of free memory, but if the system has 400 MB or more of free RAM, it uses an in-
RAM cache to optimize the boot process. The size of the cache depends on the total RAM available, but 
it’s large enough to create a reasonable cache and yet allow the system the memory it needs to boot 
smoothly. ReadyBoot is implemented in two distinct binaries the ReadyBoost driver (Rdyboost.sys) and 
the Sysmain service (Sysmain.dll, which also implements SuperFetch).
The cache is implemented by the Store Manager in the same device driver that implements 
ReadyBoost caching (Rdyboost.sys), but the cache’s population is guided by the boot plan previously 
stored in the registry. Although the boot cache could be compressed like the ReadyBoost cache, an-
other difference between ReadyBoost and ReadyBoot cache management is that while in ReadyBoot 
mode, the cache is not encrypted. The ReadyBoost service deletes the cache 50 seconds after the 
service starts, or if other memory demands warrant it.
836 
CHAPTER 12 Startup and shutdown
When the system boots, at phase 1 of the NT kernel initialization, the ReadyBoost driver, which is 
a volume filter driver, intercepts the boot volume creation and decides whether to enable the cache. 
The cache is enabled only if the target volume is registered in the KLMSystemCurrentControlSet
ServicesrdyboostParametersReadyBootVolumeUniueId registry value. This value contains the ID of 
the boot volume. If ReadyBoot is enabled, the ReadyBoost driver starts to log all the volume boot I/Os 
(through ETW), and, if a previous boot plan is registered in the BootPlan registry binary value, it spawns 
a system thread that will populate the entire cache using asynchronous volume reads. When a new 
Windows OS is installed, at the first system boot these two registry values do not exist, so neither the 
cache nor the log trace are enabled.
In this situation the Sysmain service, which is started later in the boot process by the SCM, deter-
mines whether the cache needs to be enabled, checking the system configuration and the running 
Windows SKU. There are situations in which ReadyBoot is completely disabled, such as when the boot 
disk is a solid state drive. If the check yields a positive result, Sysmain enables ReadyBoot by writing the 
boot volume ID on the relative registry value (eyluenque) and by enabling the WMI 
ReadyBoot Autologger in the KLMSSTEMCurrentControlSetControlWMIAutoLoggerReadyboot 
registry key. At the next system boot, the ReadyBoost driver logs all the Volume I/Os but without popu-
lating the cache (still no boot plan exists).
After every successive boot, the Sysmain service uses idle CPU time to calculate a boot-time caching 
plan for the next boot. It analyzes the recorded ETW I/O events and identifies which files were accessed and 
where they’re located on disk. It then stores the processed traces in SystemRootPrefetchReadyboot as 
.fx files and calculates the new caching boot plan using the trace files of the five previous boots. The Sysmain 
service stores the new generated plan under the registry value, as shown in Figure 12-12. The ReadyBoost 
boot driver reads the boot plan and populates the cache, minimizing the overall boot startup time.
FIGURE 12-12 ReadyBoot configuration and statistics.
CHAPTER 12 Startup and shutdown
837
Images that start automatically
In addition to the Userinit and Shell registry values in Winlogon’s key, there are many other registry lo-
cations and directories that default system components check and process for automatic process start-
up during the boot and logon processes. The Msconfig utility (SystemRootSystem32Msconfig.exe) 
displays the images configured by several of the locations. The Autoruns tool, which you can download 
from Sysinternals and is shown in Figure 12-13, examines more locations than Msconfig and displays 
more information about the images configured to automatically run. By default, Autoruns shows only 
the locations that are configured to automatically execute at least one image, but selecting the Include 
Empty Locations entry on the Options menu causes Autoruns to show all the locations it inspects. 
The Options menu also has selections to direct Autoruns to hide Microsoft entries, but you should 
always combine this option with eriy mage Signatures otherwise, you risk hiding malicious pro-
grams that include false information about their company name information.
FIGURE 12-13 The Autoruns tool available from Sysinternals.
Shutdown
The system shutdown process involves different components. Wininit, after having performed all its 
initialization, waits for a system shutdown. 