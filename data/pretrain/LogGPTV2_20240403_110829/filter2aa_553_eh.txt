图17.10 在链表中插入一个元素
接下来，考虑如何访问元素。对数组而言，可以使用数组下标直接访问
该数组中的任意元素，这叫做随机访问（random access）。对链表而言，必
须从链表首节点开始，逐个节点移动到要访问的节点，这叫做顺序访问
（sequential access）。当然，也可以顺序访问数组。只需按顺序递增数组下
标即可。在某些情况下，顺序访问足够了。例如，显示链表中的每一项，顺
序访问就不错。其他情况用随机访问更合适。
假设要查找链表中的特定项。一种算法是从列表的开头开始按顺序查
找，这叫做顺序查找（sequential search）。如果项并未按某种顺序排列，则
只能顺序查找。如果待查找的项不在链表里，必须查找完所有的项才知道该
项不在链表中（在这种情况下可以使用并发编程，同时查找列表中的不同部
分）。
1390
我们可以先排序列表，以改进顺序查找。这样，就不必查找排在待查找
项后面的项。例如，假设在一个按字母排序的列表中查找Susan。从开头开
始查找每一项，直到Sylvia都没有查找到Susan。这时就可以退出查找，因为
如果Susan在列表中，应该排在Sylvia前面。平均下来，这种方法查找不在列
表中的项的时间减半。
对于一个排序的列表，用二分查找（binary 
search）比顺序查找好得
多。下面分析二分查找的原理。首先，把待查找的项称为目标项，而且假设
列表中的各项按字母排序。然后，比较列表的中间项和目标项。如果两者相
等，查找结束；假设目标项在列表中，如果中间项排在目标项前面，则目标
项一定在后半部分项中；如果中间项在目标项后面，则目标项一定在前半部
分项中。无论哪种情况，两项比较的结果都确定了下次查找的范围只有列表
的一半。接着，继续使用这种方法，把需要查找的剩下一半的中间项与目标
项比较。同样，这种方法会确定下一次查找的范围是当前查找范围的一半。
以此类推，直到找到目标项或最终发现列表中没有目标项（见图17.11）。
这种方法非常有效率。假如有127个项，顺序查找平均要进行64次比较才能
找到目标项或发现不在其中。但是二分查找最多只用进行7次比较。第1次比
较剩下63项进行比较，第2次比较剩下31项进行比较，以此类推，第6次剩下
最后1项进行比较，第7次比较确定剩下的这个项是否是目标项。一般而言，
n 次比较能处理有 2n-1 个元素的数组。所以项数越多，越能体现二分查找的
优势。
1391
1392
图17.11 用二分查找法查找Susan
用数组实现二分查找很简单，因为可以使用数组下标确定数组中任意部
分的中点。只要把数组的首元素和尾元素的索引相加，得到的和再除以2 即
可。例如，内含100 个元素的数组，首元素下标是0，尾元素下标是99，那
么用于首次比较的中间项的下标应为(0+99)/2，得49（整数除法）。如果比
较的结果是下标为49的元素在目标项的后面，那么目标项的下标应在0～48
的范围内。所以，第2次比较的中间项的下标应为(0+48)/2，得24。如果中
间项与目标项的比较结果是，中间项在目标项前面，那么第3次比较的中间
项下标应为(25+48)/2，得 36。这体现了随机访问的特性，可以从一个位置
跳至另一个位置，不用一次访问两位置之间的项。但是，链表只支持顺序访
问，不提供跳至中间节点的方法。所以在链表中不能使用二分查找。
如前所述，选择何种数据类型取决于具体的问题。如果因频繁地插入和
删除项导致经常调整大小，而且不需要经常查找，选择链表会更好。如果只
是偶尔插入或删除项，但是经常进行查找，使用数组会更好。
如果需要一种既支持频繁插入和删除项又支持频繁查找的数据形式，数
组和链表都无法胜任，怎么办？这种情况下应该选择二叉查找树。
1393
17.7 二叉查找树
二叉查找树是一种结合了二分查找策略的链接结构。二叉树的每个节点
都包含一个项和两个指向其他节点（称为子节点）的指针。图17.12演示了
二叉查找树中的节点是如何链接的。二叉树中的每个节点都包含两个子节点
——左节点和右节点，其顺序按照如下规定确定：左节点的项在父节点的项
前面，右节点的项在父节点的项后面。这种关系存在于每个有子节点的节点
中。进一步而言，所有可以追溯其祖先回到一个父节点的左节点的项，都在
该父节点项的前面；所有以一个父节点的右节点为祖先的项，都在该父节点
项的后面。图17.12中的树以这种方式储存单词。有趣的是，与植物学的树
相反，该树的顶部被称为根（root）。树具有分层组织，所以以这种方式储
存的数据也以等级或层次组织。一般而言，每级都有上一级和下一级。如果
二叉树是满的，那么每一级的节点数都是上一级节点数的两倍。
图17.12 一个从存储单词的二叉树
二叉查找树中的每个节点是其后代节点的根，该节点与其后代节点构成
称了一个子树（subtree）。如图 17.12 所示，包含单词fate、carpet和llama的
1394
节点构成了整个二叉树的左子树，而单词 voyage是style-plenum-voyage子树
的右子树。
假设要在二叉树中查找一个项（即目标项）。如果目标项在根节点项的
前面，则只需查找左子树；如果目标项在根节点项的后面，则只需查找右子
树。因此，每次比较就排除半个树。假设查找左子树，这意味着目标项与左
子节点项比较。如果目标项在左子节点项的前面，则只需查找其后代节点的
左半部分，以此类推。与二分查找类似，每次比较都能排除一半的可能匹配
项。
我们用这种方法来查找puppy是否在图17.12的二叉树中。比较puppy和
melon（根节点项），如果puppy在该树中，一定在右子树中。因此，在右子
树中比较puppy和style，发现puppy在style前面，所以必须链接到其左节点。
然后发现该节点是plenum，在puppy前面。现在要向下链接到该节点的右子
节点，但是没有右子节点了。所以经过3次比较后发现puppy不在该树中。
二叉查找树在链式结构中结合了二分查找的效率。但是，这样编程的代
价是构建一个二叉树比创建一个链表更复杂。下面我们在下一个ADT项目中
创建一个二叉树。
17.7.1 二叉树ADT
和前面一样，先从概括地定义二叉树开始。该定义假设树不包含相同的
项。许多操作与链表相同，区别在于数据层次的安排。下面建立一个非正式
的树定义：
类型名：    二叉查找树
类型属性：    二叉树要么是空节点的集合（空树），要么是有一
个根节点的节点集合
每个节点都有两个子树，叫做左子树和右子树
每个子树本身也是一个二叉树，也有可能是空树
1395
二叉查找树是一个有序的二叉树，每个节点包含一个项，
左子树的所有项都在根节点项的前面，右子树的所有项都在根节点项的
后面
类型操作：    初始化树为空
确定树是否为空
确定树是否已满
确定树中的项数
在树中添加一个项
在树中删除一个项
在树中查找一个项
在树中访问一个项
清空树
17.7.2 二叉查找树接口
原则上，可以用多种方法实现二叉查找树，甚至可以通过操控数组下标
用数组来实现。但是，实现二叉查找树最直接的方法是通过指针动态分配链
式节点。因此我们这样定义：
typedef SOMETHING Item;
typedef struct trnode
{
Item item;
1396
struct trnode * left;
struct trnode * right;
} Trn;
typedef struct tree
{
Trnode * root;
int size;
} Tree;
每个节点包含一个项、一个指向左子节点的指针和一个指向右子节点的
指针。可以把 Tree 定义为指向 Trnode 的指针类型，因为只需要知道根节点
的位置就可访问整个树。然而，使用有成员大小的结构能很方便地记录树的
大小。
我们要开发一个维护 Nerfville 宠物俱乐部的花名册，每一项都包含宠
物名和宠物的种类。程序清单17.10就是该花名册的接口。我们把树的大小
限制为10，较小的树便于在树已满时测试程序的行为是否正确。当然，你也
可以把MAXITEMS设置为更大的值。
程序清单17.10 tree.h接口头文件
/* tree.h -- 二叉查找数     */
/*      树种不允许有重复的项 */
#ifndef _TREE_H_
#define _TREE_H_
1397
#include 
/* 根据具体情况重新定义 Item */
#define SLEN 20
typedef struct item
{
char petname[SLEN];
char petkind[SLEN];
} Item;
#define MAXITEMS 10
typedef struct trnode
{
Item item;
struct trnode * left;   /* 指向左分支的指针 */
struct trnode * right; /* 指向右分支的指针 */
} Trnode;
typedef struct tree
{
Trnode * root;/* 指向根节点的指针     */
int size;   /* 树的项数         */
1398
} Tree;
/* 函数原型 */
/* 操作：   把树初始化为空*/
/* 前提条件：  ptree指向一个树   */
/* 后置条件：  树被初始化为空  */
void InitializeTree(Tree * ptree);
/* 操作：   确定树是否为空            */
/* 前提条件：  ptree指向一个树           */
/* 后置条件：  如果树为空，该函数返回true      */
/*        否则，返回false         */
bool TreeIsEmpty(const Tree * ptree);
/* 操作：   确定树是否已满            */
/* 前提条件：  ptree指向一个树           */
/* 后置条件：  如果树已满，该函数返回true      */
/*        否则，返回false         */
bool TreeIsFull(const Tree * ptree);
/* 操作：   确定树的项数             */
/* 前提条件：  ptree指向一个树           */
/* 后置条件：  返回树的项数             */
1399
int TreeItemCount(const Tree * ptree);
/* 操作：   在树中添加一个项           */
/* 前提条件：  pi是待添加项的地址          */
/*        ptree指向一个已初始化的树    */
/* 后置条件：  如果可以添加，该函数将在树中添加一个项  */
/*        并返回true；否则，返回false   */
bool AddItem(const Item * pi, Tree * ptree);
/* 操作：   在树中查找一个项           */
/* 前提条件：  pi指向一个项            */
/*        ptree指向一个已初始化的树    */
/* 后置条件：  如果在树中添加一个项，该函数返回true  */
/*        否则，返回false         */
bool InTree(const Item * pi, const Tree * ptree);
/* 操作：   从树中删除一个项           */
/* 前提条件：  pi是删除项的地址           */
/*        ptree指向一个已初始化的树    */
/* 后置条件：  如果从树中成功删除一个项，该函数返回true*/
/*        否则，返回false         */
bool DeleteItem(const Item * pi, Tree * ptree);
1400
/* 操作：   把函数应用于树中的每一项        */
/* 前提条件：  ptree指向一个树           */
/*        pfun指向一个函数，       */
/*        该函数接受一个Item类型的参数，并无返回值*/
/* 后置条件：  pfun指向的这个函数为树中的每一项执行一次*/
void Traverse(const Tree * ptree, void(*pfun)(Item item));
/* 操作：   删除树中的所有内容          */
/* 前提条件：  ptree指向一个已初始化的树       */
/* 后置条件：  树为空               */
void DeleteAll(Tree * ptree);
#endif
17.7.3 二叉树的实现
接下来，我们要实现tree.h中的每个函数。InitializeTree()、
EmptyTree()、FullTree()和TreeItems()函数都很简单，与链表ADT、队列ADT
类似，所以下面着重讲解其他函数。
1.添加项
在树中添加一个项，首先要检查该树是否有空间放得下一个项。由于我
们定义二叉树时规定其中的项不能重复，所以接下来要检查树中是否有该
项。通过这两步检查后，便可创建一个新节点，把待添加项拷贝到该节点
中，并设置节点的左指针和右指针都为NULL。这表明该节点没有子节点。
然后，更新Tree结构的 size 成员，统计新增了一项。接下来，必须找出应该
把这个新节点放在树中的哪个位置。如果树为空，则应设置根节点指针指向
1401
该新节点。否则，遍历树找到合适的位置放置该节点。AddItem()函数就根
据这个思路来实现，并把一些工作交给几个尚未定义的函数：SeekItem()、
MakeNode()和AddNode()。
bool AddItem(const Item * pi, Tree * ptree)
{
Trnode * new_node;
if (TreeIsFull(ptree))
{
fprintf(stderr, "Tree is full\n");
return false;     /* 提前返回  */
}
if (SeekItem(pi, ptree).child != NULL)
{
fprintf(stderr, "Attempted to add duplicate item\n");
return false;     /* 提前返回  */
}
new_node = MakeNode(pi);  /* 指向新节点 */
if (new_node == NULL)
{
fprintf(stderr, "Couldn't create node\n");
1402
return false;     /* 提前返回  */
}
/* 成功创建了一个新节点 */
ptree->size++;
if (ptree->root == NULL)      /* 情况1：树为空    */
ptree->root = new_node;     /* 新节点是根节点    */
else                /* 情况2：树不为空   */
AddNode(new_node, ptree->root);/* 在树中添加一个节点*/
return true; /* 成功返回 */
}
SeekItem()、MakeNode()和 AddNode()函数不是 Tree 类型公共接口的一
部分。它们是隐藏在tree.c文件中的静态函数，处理实现的细节（如节点、
指针和结构），不属于公共接口。