2
shellcode = "\x31\xc0\x40\x40\x89\x45\xdc"
exploit = shellcode + "\x90" * (36 - len(
shellcode)) + "\x50\xaf\xaa\xba\n"
Listing 2: The original exploit with shellcode.
2) Original exploit: Listing 2 shows the original exploit for
the running example. The shellcode starts at the beginning
of the exploit, followed by padding and the address with
which to overwrite the return address. When the vulnerable
program executes with the original exploit, the return address
for function example will be changed to 0xbaaaaf50, which
points to the beginning of buffer string, and when function
example returns, the control ﬂow will be redirected to the
shellcode.
826
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
B. Challenges
To demonstrate the challenges inherent in the shellcode
transplant problem, we ﬁrst consider a naive approach: if
we ﬁnd the location of the old shellcode in the original
exploit, we could generate a new exploit by replacing, byte
by byte, the old shellcode with the new one. We call this
the shellcode byte-replacement approach. However, this naive
approach assumes two things, that the shellcode stays in its
original form throughout execution and that the replacement
shellcode is the same size as the original shellcode. As we
discussed previously, both of these assumptions are too strict
for real-world use cases.
For example, consider the following replacement shellcode
for the original exploit in our motivating example:
1
2
3
4
5
6
7
8
xor
lea
lea
push
push
mov
lea
int
%esi,%esi
0x1(%esi),%ebx
0x8(%esi),%edx
0xaaaaaaaa
$0xdddddddd
%esp,%ecx
0x2(%esi),%eax
$0x80
31 f6
8d 5e 01
8d 56 08
ff 35 aa aa aa aa
68 dd dd dd dd
89 e1
8d 46 02
cd 80
Listing 3: The disassembly of the replacement shellcode
shellcode1.
If we apply the shellcode byte-replacement method, the
modiﬁed exploit be:
1
2
shellcode = "\x31\xf6\x8d\x5e\x01\x8d\x56\x08\
xff\x35\xaa\xaa\xaa\xaa\x68\xdd\xdd\xdd\xdd\
x89\xe1\x8d\x46\x02\xcd\x80"
exploit = shellcode + "\x90" * (36 - len(
shellcode)) + "\x50\xaf\xaa\xba\n"
Listing 4: The modiﬁed exploit for shellcode1 using the
shellcode replacement approach.
However, the modiﬁed exploit will not work when applied to
our motivating example. Figure 3a shows the stack layout before
function example starts. Besides saved registers, there are
two variables between string and the saved %eip. When the
program receives an input, the resulting stack layout is shown
in Figure 3b. However, control is not immediately transferred
to the shellcode. The program continues, and because variable
len is updated before returning, the value at this address
changes. By the time the function transfers control ﬂow to
the shellcode, the program changes the 20th through the 28th
bytes of the replacement shellcode, as shown in Figure 3c. In
our example, this represents unexpected modiﬁcation to the
replacement shellcode, rendering it nonfunctional.
In some cases, previous work is, using very resource-
intensive techniques, capable of re-ﬁnding the vulnerability
and re-creating an exploit, but these systems all suffer from
extreme scalability issues because they approach vulnerability
detection as a search problem. If we do not want to re-
execute these resource-expensive systems to re-identify and
re-exploit vulnerabilities, a new approach is needed. To this end,
we identiﬁed two main categories of challenges in shellcode
transplanting: one dealing with the layout of memory at the
time the vulnerability is triggered, and the other having to
do with the actions taken in the path of execution before the
vulnerability is triggered.
1) Memory conﬂicts: Previous work [12, 17] places shell-
code in memory by querying a constraint solver to solve
the constraints generated in the Symbolic Tracing step and
concretizing a region of memory to be equal to the desired
shellcode. However, as is the case in our naive byte-replacement
approach, this is not always possible: often, when dealing with
ﬁne-tuned exploits, there is simply not enough symbolic data
in the state to concretize to shellcode [29].
For example, recall the shellcode in Listing 4 in the context
of our motivating example. This piece of shellcode is 26 bytes
long, which should have ﬁt into the 50 bytes of user input.
However, the 20th through the 28th byte are overwritten, and
the 36th through 40th byte must be set to the address of the
shellcode (to redirect control ﬂow). This leaves three symbolic
regions: a 20-byte one at the beginning of the buffer, an 8-byte
one between the ret and len variables and the saved return
address, and the 10 bytes after the saved return address. None
of these regions are big enough to place this shellcode, causing
a memory conﬂict for the shellcode transplanting process.
2) Path conﬂicts: To drive program execution to the ex-
ploited state, the content of the modiﬁed exploit must satisfy
the path constraints recovered from the Symbolic Tracing step.
However, by requiring the replacement shellcode to be in the
memory of the exploitation state, we add new constraints
(“shellcode constraints”) on the exploit input. These new
conditions may be conﬂict with those generated along the
path. We call such conﬂict the path conﬂict. In the presence
of such a conﬂict, if we locate the replacement shellcode in
the exploitation state (and discard the path constraints that
conﬂict with this), the exploit path will change, and the new
program state resulting from the changed path may not trigger
the vulnerability.
For example, consider the replacement shellcode in Listing 5
in the context of the motivating example.
1
2
3
4
5
6
7
8
9
10
push
push
push
push
mov
mov
mov
mov
lea
int
$0x0
$0xa65
$0x646f636c
$0x6c656873
$0x2,%eax
$0x1,%ebx
%esp,%ecx
$0xa,%edx
0x10(%esp),%esi
$0x80
6a 00
68 65 0a 00 00
68 6c 63 6f 64
68 73 68 65 6c
b8 02 00 00 00
bb 01 00 00 00
89 e1
ba 0a 00 00 00
8d 74 24 10
cd 80
Listing 5: The disassembly of the replacement shellcode.
shellcode2.
When the running example executes with an input string,
the for loop body before the return increments i until
string[i] is a null byte. For the original exploit, the loop
will repeat for 40 times (the length of the exploit string),
meaning that the path constraints will mandate that the ﬁrst 40
bytes of string are not null. For the replacement shellcode,
however, if we locate the new shellcode at the beginning of
827
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
(cid:8)(cid:72)(cid:69)(cid:83)
High
s
s
e
r
d
d
a
Low
(cid:63)(cid:91)(cid:19)(cid:19)(cid:63)(cid:91)(cid:19)(cid:19)(cid:63)(cid:91)(cid:19)(cid:19)(cid:63)(cid:91)(cid:19)(cid:19)
Saved (cid:8)(cid:72)(cid:76)(cid:83)
Saved (cid:8)(cid:72)(cid:69)(cid:83)
Saved (cid:8)(cid:72)(cid:86)(cid:76)
(cid:76)(cid:81)(cid:87) (cid:85)(cid:72)(cid:87)
(cid:76)(cid:81)(cid:87) (cid:79)(cid:72)(cid:81)
(cid:70)(cid:75)(cid:68)(cid:85)(cid:3)(cid:86)(cid:87)(cid:85)(cid:76)(cid:81)(cid:74)(cid:62)(cid:21)(cid:19)(cid:64)
(20 Bytes)
(cid:171)
(cid:63)(cid:91)(cid:19)(cid:19)(cid:63)(cid:91)(cid:19)(cid:19)(cid:63)(cid:91)(cid:19)(cid:19)(cid:63)(cid:91)(cid:19)(cid:19)
(cid:9)(cid:86)(cid:75)(cid:72)(cid:79)(cid:79)(cid:70)(cid:82)(cid:71)(cid:72)
(cid:63)(cid:91)(cid:19)(cid:19)(cid:63)(cid:91)(cid:19)(cid:19)(cid:63)(cid:91)(cid:19)(cid:19)(cid:63)(cid:91)(cid:19)(cid:19)
(cid:9)(cid:86)(cid:75)(cid:72)(cid:79)(cid:79)(cid:70)(cid:82)(cid:71)(cid:72)(cid:20)
(cid:8)(cid:72)(cid:69)(cid:83)
(cid:63)(cid:91)(cid:28)(cid:19)(cid:171)(cid:63)(cid:91)(cid:28)(cid:19)
Saved (cid:8)(cid:72)(cid:86)(cid:76)
(cid:8)(cid:72)(cid:69)(cid:83)
(cid:70)(cid:75)(cid:68)(cid:85)(cid:3)(cid:86)(cid:87)(cid:85)(cid:76)(cid:81)(cid:74)(cid:62)(cid:21)(cid:19)(cid:64)
(cid:86)(cid:75)(cid:72)(cid:79)(cid:79)(cid:70)(cid:82)(cid:71)(cid:72)
(20 Bytes)
(cid:171)
updated (cid:85)(cid:72)(cid:87)
(cid:76)(cid:81)(cid:87) (cid:85)(cid:72)(cid:87)
updated (cid:79)(cid:72)(cid:81)
(cid:76)(cid:81)(cid:87) (cid:79)(cid:72)(cid:81)
(cid:86)(cid:75)(cid:72)(cid:79)(cid:79)(cid:70)(cid:82)(cid:71)(cid:72)(cid:20)
(cid:171)
(a) Before receiving an exploit.
(b) After receiving an exploit.
(c) When example returns.
Fig. 3: The stack layout of function example at runtime.
string, the loop will only iterate once, because the second
byte of the shellcode is null. This creates a contradiction
between the path constraints and the shellcode constraints.
3) Surmounting the challenges: The intelligent reader can
certainly envision approaches to achieve shellcode transplanting
in the motivating example. However, this example is just 12
lines of code. One can see that, with bigger examples and in
the general case, these challenges can be quite complicated to
surmount.
In the rest of the paper, we will discuss how to identify
conﬂicts while transplanting the shellcode and how to satisfy
both memory and path conﬂicts to successfully transplant
shellcode in a wide variety of exploits.
III. SYMBOLIC TRACING
Essentially, ShellSwap separates the entire execution of the
original exploit into two phases: before the control-ﬂow hijack
and after the control-ﬂow hijack. The Symbolic Tracing step
analyzes the former. The goal of this step is to generate the
exploitable state of the program and record the path constraints
that are induced by conditional branches that are encountered
on the path. This involves two main considerations.
First, we must determine when the control-ﬂow hijack occurs.
We do this by leveraging the concept of security policies,
which has been thoroughly explored by researchers [10, 16,
18, 21, 32]. In our work, we use the well-studied taint-based
enforceable security policy [26, 32]. This policy determines
whether or not a program state is safe by checking the
instruction being executed. If the instruction directly is tainted
by remote input, then the program state is deemed unsafe and
the path is terminated.
Second, we must determine how to perform the tracing, as
there are several possible techniques that might be used here.
For example, we could use dynamic taint analysis to identify
when executed instructions are tainted by input data. While
this would be relatively fast, taint analysis is not sufﬁcient.
Although it can identify violations to our security policy caused
by tainted input, it cannot recover and track path constraints.
Thus, in our system, we apply concolic execution to trace the
path that the exploit runs on the program. We ensure tracing
accuracy in two ways: we record a dynamic trace of the exploit
process (and require that our symbolic trace conform to the
same instructions), and we pre-constrain the symbolic data to
be equal to the original exploit. The former avoids the path
explosion inherent in concolic execution exploration (because
we only care about the branch that the exploit chooses), and the
latter greatly simpliﬁes the job of the symbolic constraint solver
during tracing (by providing it with a pre-determined solution).
This method is similar to the pre-constraint tracing and the
input pre-constraining approach proposed by Driller [30] (and,
in fact, part of the implementation derives off of Driller’s
tracing module).
The trace-directed symbolic execution takes a program and
an original exploit and produces path constraints and the
exploitable state. The exploitable state includes the symbolic
value of registers and memory at the moment that the program
starts to execute the shellcode. After this step completes,
the pre-constraints introduced in the beginning are removed,
making it possible to constrain some of the memory in the
exploitable state to contain values representing, for example,
the replacement shellcode. The remaining path constraints
guarantee that any satisfying input will make the program to
execute the same execution trace and triggers the vulnerability.
IV. SHELLCODE TRANSPLANT
After the exploitable state and the path constraints associated
with it have been recovered, ShellSwap can attempt to re-
constrain the shellcode to be equal to the replacement shellcode
by adding shellcode constraints. However, as discussed in
Section II, the shellcode constraints may conﬂict with the
path constraints. Previous work [12, 17] addresses this issue by
trying other shellcode locations, but even the simple motivating
example in Section II is too complicated for this to work.
The Shellcode Transplant steps attempts to resolve these
conﬂicts. If it can do so, the modiﬁed exploit, containing the
replacement shellcode, is produced. If it fails, it returns an
error indicating that the exploit could not be found.
The step proceeds in several phases, in a loop, as shown in
Figure 4. First, in the Preprocessing phase, ShellSwap identiﬁes
possible memory locations into which replacement shellcode
828
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
(or pieces of it) can be placed. Next, in the Layout Remediation
phase, it attempts to remedy memory conﬂicts (as discussed
in Section II-B) and ﬁt the replacement shellcode into the
identiﬁed memory locations, performing semantics-preserving
modiﬁcations (such as code splitting) if necessary. If this fails
due to a resulting conﬂict with the path constraints (a path
conﬂict, as discussed in Section II-B), ShellSwap enters the
Path Kneading phase and attempts to identify alternate paths
that resolve these conﬂicts while still triggering the vulnerability.
If such a path can be found, its constraints replace the path
constraints, and the system repeats from the preprocessing
phase.
If ShellSwap encounters a situation where neither the
memory conﬂicts nor the path conﬂicts can be remedied, it
triggers the Two-Stage Fallback and attempts to repeat the
Shellcode Transplant stage with a fallback, two-stage shellcode.
A. Preprocessing
Before the system tries to locate the new shellcode, it scans
the memory in the exploitable state to identify symbolic buffers.
A symbolic buffer is a contiguous memory where all bytes
are symbolic. To ﬁnd symbolic buffers, our system iterates the
bytes of the memory, marking each contiguous region. After
ﬁnding all symbolic buffers, we sort the buffers by the length
and the number of symbolic input variables involved in each
buffer. Buffers with bigger length and more symbolic values
has more varieties of concrete values, and thus are more likely
to be able to hold the replacement shellcode.
B. Layout Remediation
Given symbolic buffers from the previous phase, the system
attempts to ﬁt the replacement shellcode into the exploitable
program state. As an innovation over prior work, ShellSwap
does not consider a piece of shellcode as an integrated memory