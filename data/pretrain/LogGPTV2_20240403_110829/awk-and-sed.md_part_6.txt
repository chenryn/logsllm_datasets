QQ群：
而不只是这5个，
 awk 的每个实现都会给出不同的出错信息。
50192241
，与我们已经看到的相同。在下一个示例
并且如果是对文档而不是邮件列表
第二章
了解基本操作
因此，
这
---
## Page 37
记录中的名字相同。我们来看这个脚本的执行：
这个 shell脚本有3个部分。程序中调用 awk 以产生 sort 程序的输入，然后再
在那个州的人的名字。下面的示例展示了byState程序：
现在，我们要做一些更有趣的事情。按州的名字排序并列出州的名字，以及住
次
母表排序，
本程序的结果不是非常有用，
个结果。
这里所做的事情可以完全由 sed 完成，
“$4”表示第4个字段。
以上 awk 程序处理由 sed 脚本产生的输出。记住前面的 sed 脚本用逗号和州的
生。而且，因为 awk 允许替换匹配的字符串，所以可以完全用 awk 脚本得到这
性
调用 awk 测式排好序的输入，
称代替缩写。实际上，
print "\t" $2
print $1 
$1 != LastState
print "\t" $2
print $4 ", 
#! /bin/sh
Virginia
Oklahoma 
Virginia
$ sed -f nameState list | awk -F, ′{ print $4 }′ 
LastState = $1 
awk -F,
sort
awk -F,
Massachusetts
Cal ifornia 
Massachusetts
Pennsylvania
Massachusetts
同量给出每个州名出现的资料。
0$=
QQ群：
它将包含城市和州的第三个字段拆分成二个字段。
50192241
可以将它传递给 sort丨uniq-c，它将州名按字
并确定当前记录中的州的名字，是否与前一个
但可能会有更多的困难和更少的通用
第二章
了解基本操作
---
## Page 38
果相同，则只打印人的名字。
第二次调用 awk 时执行程序设计任务。脚本查看每条记录的第一个字段以决定
写排序程序）。
现在，sort程序可以工作了（注意使用 sort实用工具可以避免在 awk 内部编
默认情况下，sort 程序按字母顺序排列行，
Massachusetts
California
Pennsylvania
Massachusetts 
产生的输出：
从 nameState 程序读取输入并期待“$4”成为州的名字。查看由程序的第一行
为了检查byState 程序是如何工作的，
这些名字被按州排序。这是使用 awk 从结构化数据中生成报表的典型示例。
它
不
是否与前一条记录相同。如果不相同，则同时打印州的名字的人的名字。如
是名字)对记录进行排序，我们将州作为排序的关键字插入到记录的开始处。
 Massachusetts, Sal Carpenter, 73 6th Street, Boston,
California, Amy Wi lde,
Virginia, Hubert Sims,
Massachusetts, Eric Adams,
Okl ahoma,
Virginia,
 Massachusetts, John Daggett, 341 King Road, Plymouth,
Pennsylvania, Terry Kalkas,
Virginia
Pennsylvania
 Oklahoma
Massachusetts 
California 
$ sed -f nameState list | byState 
 sed -f nameState list | awk -F,
Terry Kalkas
 Orville Thomas
Sal Carpenter
Amy Wilde
Hubert Sims
Alice Ford
John Daggett
Eric Adams
 Orville Thomas,
 Alice Ford, 22 East Broadway, Richmond, Virginia 
QQ群：
50192241
334 Bayshore Pkwy, Mountain View,
 328A Brook Road,
11345 0ak Bridge Road,
 20 Post Road, Sudbury, Massachusetts 
38
402 Lans Road,
让我们分别看看每个部分。它被设计为
从左到右查看字符。为了按州（而
’{ print $4 "，" $0 }′
Roanoke,
第二章
Beaver Falls,
Virginia
Tulsa, Oklahoma
了解基本操作
---
## Page 39
些内容。
本章概述了有关 sed 的 awk 的基本操作。
使
每条语句做什么事情。
看
这
意在使用某个变量之前不必对它先赋值(因为 awk 将变量初始化为空字符串)。
段来看它是否包含一个变量字符串，
这里还有几个重要的事情，
用。下一章将介绍正则表达式，
到用于比较索引条
是较小的脚本，
print "\t" $2 
print $1 
LastState = $1 
$1 != LastState
print "\t" $2
$1 == LastState {
但是在第十二章“综合应用”中的更大的索引程序中，
QQ群：
条目的类似的程序。然
，这里的目的是给你一个 sed 和 awk 能做什么的概述。
包括给一个变量赋值，
50192241
，即两个程序用来在输入中进行模式匹配的某
并且打印制符来调整输出数据的对齐。
介绍了重要的命令行选项以及脚本的
而，
，测式每个输入行的第一个字
第二章
了解基本操作
可
以
注
---
## Page 40
达式中的元字符的完整清单可以在表 3-1、附录一“sed 的快速参考”和附录一
如果你已经了解了正则表达式语法，
元字符并提供大量的示列，大部分使用 grep 和他的堂兄弟 egrep 来演示实际的
为了理解正则表达式，
供了一个扩展的元字符集。awk 基本上使用与 egrep 相同的元字符集。
如果你用过基于宏的UNIX文本编辑器，那么可能对正则表达式语法比较熟习。
该表达式使用元字符（metacharacter）（也做通配符）或特殊的符号，
在本章中，
的东西。一个表达式描述一种结果。
即使在计算机术语中，表达式也不是按字面意思被解释。它是某些需要被计算
思的方式（表达式）、而不表示它的字面的含义。
the bag（有人把猫从口袋里放了出来）”
应用。
事
当小孩努力理解惯用语表达的含义时，
表
虽
实上，
然正则表达式是UNIX的一个基本部分，
些组合使用元字符进行工作的示列。这就是我们学习本章的方法。介绍每个
达式语法中的所有元字符。基本的元字符集是由ed行编辑器引入的，
本章内容
使用喜欢的元字符
成排的字符
表达式 
下面的这种表达式是非常难理解的：
我们将介绍正则表达式的语法。
QQ群：
^*.*
50192241
必须了解由不同的元字符执行的功能。而且还必须参见
可以根据自己的意愿跳过这一章。正则表
- 40-
，例如“Someone let the cat out of 
但并不是每个人都完全理解其语法。
正则表达式描述了模式或特殊字符
，你可能帮他解释为这是一种表达意
了解正则表达式
第三章 
了解正则表达式语法
第三章
语法
匹配一
而且在
它提
---
## Page 41
程，在输入行上尝试匹配模式“abe”。
就返回并从字符串中这个字符后面的字符重新开始匹配。图3-1说明了这个过
串、而且要看字符串与模式是否匹配，
个模式。然后它们一行一行地读取输入来尝试匹配该模式。输入行是一个字符
接受正则表达式的程序（例如 grep）必须首先解析正则表达式的语法来产生
每个字面字符都是一个正则表达式，
算器改变表达式计算顺序的符号。
计算器通常从左到右计算表达式。然而，某些操作符比其他操作符的优先乡
表达式可以比“2+4”更复杂，事实上，它由多个简单的表达式组成，例如：
我们不能简单地告诉计算机返回6。我们指示计算机计算表达式并返回值。
表
例如，
你可能熟悉一个计算器解释的表达式。请看下面的算术表达式：
表达式
“2加4”出几个常数或字面值和一个操作符组成。计算器程序必须能够识别，
绍了正则表达式的结构和用法。
Jeffrey E.F.Friedl 编著的《Mastering Regular Expression》,该书详细介
一个字符进行比较。
列
着
述
达
达
相
级
20，
高
“awk 的快速参考”中找到。有兴趣的读者可以参考0’Reilly出版并由
组成（初学者倾向于将其考虑成由较高级的单元组成，
每个字符都与它前面的字符相连接。
式：
式的基本操作。也就是一个模式匹配相邻的一系列字符。请看下面的正则表
达式告诉计算机如何产生结果。尽管我们真正想要的就是“2+4”的结果，但
反，
因为乘法的优先级高于加法。将简单的表达式放入圆括号中可以改变优先
也就是，
因此“（2+3）*4”
2+4
一个正则表达式描述了一种模式或字符序列。字符串连接是每个正则表
2+3*4
ABE
“2”是数字常数而加号表示一个操作符，而不能解释为“+”字符。
，它们将被首先执行。
QQ群：
如果匹配，
50192241
或“2加3的和的4倍”的结果为20。圆括号是指示计
就比较第二个字符。无论何时只要匹配失败，
，因此，
它只匹配那个单独的字符。
- 41 -
程序将字符串的第一个字符与模式的
，不一定要将正则表达式描述为由字符序
上面的表达式的结果为14而不是
第三章
，例如由单词而不是独
了解正则表达式语法
，这个表达式描
（注1）
级
。
第
1
---
## Page 42
图3-1：解释正则表达式
注
的
的
PLANE"
元字符*（星号）用于与它前面的正则表达式的零个或多个出现匹配，该表达式
任意字母。因此，
正则表达式不只限于文字字符。例如，
2.在输入释中：
（学符事abe)
输入行（字符串）
串
四
而
配
或
通
配。
“ACE”
模式
1:
的字符的元字符。
字符”
，但是它还匹配在“A”和“E”之间具有任意数目的字符；例如，
两个基
录中的所有的文件）
在 shell中，*本身就具有这种含义（例如，在 shell中，Is*表示列出当
任何字符、
多个字符”
常是一个字符。你也许对*作为一个 shel|元字符更熟习，
学将相比较。
第二个字符和输入行的下一
因为有一个匹起，所以模式的
”可以是零个字符！
本
“A FINE”
”ABE”和“ALE”都匹配。句点与“A”后面的位置上的任何字符匹
类型，
QQ群：
sed 和 awk 区分大小写。
某
，它用于修改它前面的内容。正则表达式.*匹配任意数目的字符，
第一满是模式中
些其他程序为使用正则表达式提供了不区分大小写的选项，但是
be
r!
那些能够被看做单个字符的元字符和那些被看做如何修改前
The jar' s label.
是这与它在正则表达式中的含义不同。星号元字符本身不匹
我们可以指定正则表达式“A.E”而且它将和
50192241
“AFFABLE” 或“A LONG WAY HOME”
，正则表达式“A.*E”匹配任何与“A.E”匹配的字符
3.楼式中的第二个字特与输入行4遂国到模式的第一个
中的下一个字符不匹配。
元字符句点（.）可以作为“通配符”
心
D
1.在这个例子中，输入行的第一个学符与模
第三章
效。所以接着用输入行的下一个字符
式的第一个字符不匹配。因为匹配夷
模式的第一个字符相比较。
0
D
了解正则表达式语法
字符，并与输入行的
jar'
一个字将相比较。
”。注意“任意数目
，在那里它表示“零
abe
“AIR-
前
匹
---
## Page 43
\[n,m\}
$
[...]
特殊字符
表3-1：元字符汇总
都被解释为只匹配它本身的字面值。
正则表达式是由这些相同的元素组成的。任意字符（表3-1中的元字符除外)
7