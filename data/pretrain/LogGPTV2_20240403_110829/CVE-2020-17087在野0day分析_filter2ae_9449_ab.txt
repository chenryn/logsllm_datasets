    cng!CfgAdtpFormatPropertyBlock+a8
    fffff802`3daa2924 668901          mov     word ptr [rcx],ax
    FAULT_INSTR_CODE:  49018966
    SYMBOL_STACK_INDEX:  7
    SYMBOL_NAME:  cng!CfgAdtpFormatPropertyBlock+a8
    FOLLOWUP_NAME:  MachineOwner
    STACK_COMMAND:  .thread ; .cxr ; kb
    BUCKET_ID_FUNC_OFFSET:  a8
    FAILURE_BUCKET_ID:  AV_VRF_INVALID_cng!CfgAdtpFormatPropertyBlock
    BUCKET_ID:  AV_VRF_INVALID_cng!CfgAdtpFormatPropertyBlock
    PRIMARY_PROBLEM_CLASS:  AV_VRF_INVALID_cng!CfgAdtpFormatPropertyBlock
    TARGET_TIME:  2020-11-06T12:49:17.000Z
    OSBUILD:  18362
    OSSERVICEPACK:  0
    SERVICEPACK_NUMBER: 0
    OS_REVISION: 0
    SUITE_MASK:  272
    PRODUCT_TYPE:  1
    OSPLATFORM_TYPE:  x64
    OSNAME:  Windows 10
    OSEDITION:  Windows 10 WinNt TerminalServer SingleUserTS
    OS_LOCALE:  
    USER_LCID:  0
    OSBUILD_TIMESTAMP:  unknown_date
    BUILDDATESTAMP_STR:  190318-1202
    BUILDLAB_STR:  19h1_release
    BUILDOSVER_STR:  10.0.18362.1.amd64fre.19h1_release.190318-1202
    ANALYSIS_SESSION_ELAPSED_TIME:  3908
    ANALYSIS_SOURCE:  KM
    FAILURE_ID_HASH_STRING:  km:av_vrf_invalid_cng!cfgadtpformatpropertyblock
    FAILURE_ID_HASH:  {c7c09a48-39c6-9551-71d6-bb35c7878b4b}
    Followup:     MachineOwner
    ---------    
CfgAdtpFormatPropertyBlock函数如下，可以看到出现整数溢出的逻辑。
没有反编译工具差点没看出来6倍（2+1）+（2+1）。。。
## 分析与调试
cng!CngDispatch
两参数 PDEVICE_OBJECT 以及 PIRP
在调用CngDeviceControl 函数之前，主要a2的IRP数据进行处理，获取In/Out buffer地址以及Length,还有IOCTL
code和RequestMode ,分别作为六个参数，传入CngDeviceControl
。通过调试来看，此派遣历程使用的操作模式Method为METHOD_BUFFERED。
通过IOCTL Code最后一位同样也可以看出，Method 0即为 METHOD_BUFFERED。
    #define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
        ((DeviceType)  dq ffffc18e`eae97000
    ffffc18e`eae97000  00010400`1a2b3c4d 00000000`00000001
    ffffc18e`eae97010  00000000`00000100 00000000`00000003
    ffffc18e`eae97020  00000000`00000200 00000000`00000300
    ffffc18e`eae97030  00000000`00000400 00000000`00000000
    ffffc18e`eae97040  00000000`00000500 00000000`00000600
    ffffc18e`eae97050  00000000`00002aab 00000000`00001000
    ffffc18e`eae97060  00000000`00000000 00000000`00000000
    ffffc18e`eae97070  00000000`00000000 00000000`00000000
第二块block2初始化为0。
将第一块地址 v10, 大小v17,第二块局部变量v19
int型地址，第二块地址v12作为四参数，调用IoUnpack_SG_ParamBlock_Header函数，根据逻辑来看，此函数最终返回0。否则当前函数将返回。
进入IoUnpack_SG_ParamBlock_Header函数：
对传入缓冲区数据一顿判断（表示很疑惑，为什么对常识性的地址大小进行判断而不是其中的值，防止溢出？？），另外将传入缓冲区得数据起始偏移为4得值拷贝到第三参数a3所在地址，很明显进入while循环后，由于block2之前已经初始化为0，那么循环8次后将a4置为-1，进入goto语句，返回0。
再回到ConfigIoHandler_Safeguarded函数中，接着调用ConfigFunctionIoHandler函数，将刚刚拿到的传入缓冲区地址偏移4处的值（0x10400）作为第一参数，block1地址作为第二参数，传入缓冲区大小InBufferLen作为第三参数，输出缓冲区地址作为第四参数，输出缓冲区大小为第五参数，block2地址作为第六参数。
进入ConfigFunctionIoHandler函数，
第一参数逻辑右移16位，结果为1（0x10000= dq rdi
    ffffc18e`eae97000  00010400`1a2b3c4d 00000000`00000001
    ffffc18e`eae97010  ffffc18e`eae97100 00000000`00000003
    ffffc18e`eae97020  ffffc18e`eae97200 ffffc18e`eae97300
    ffffc18e`eae97030  ffffc18e`eae97400 00000000`00000000
    ffffc18e`eae97040  ffffc18e`eae97500 ffffc18e`eae97600
    ffffc18e`eae97050  00000000`00002aab ffffc18e`eae98000
    ffffc18e`eae97060  00000000`00000000 00000000`00000000
    ffffc18e`eae97070  00000000`00000000 00000000`00000000
此函数中对block2内存做修改 ，同时对大量参数使用block1内存进行赋值。注意，a12,即当前的第12参数，拿到了block1+50处的内存值。
并返回0。IoUnpack_SG_Configuration_ParamBlock同样返回0。
后续由于a1由原先的0x10400截断为0x400，调用BCryptSetContextFunctionProperty函数，传入七个参数分别为在IoUnpack_SG_Configuration_ParamBlock做赋值，v14为传入第3参数,被赋值为*（block1+8）
v16为传入第4参数,被赋值为*（block1+10h）
v15为传入第5参数，被赋值为*（block1+18h）
v17为传入第6参数，被赋值为*（block1+20h）
v22为传入第8参数,被赋值为*（block1+30h）
v19为传入第12参数，被赋值为*（block1+50h）
v24为传入第13参数,被赋值为*（block1+58h）
内部v17所处内存即为block1地址，此时block1处内存为
可以看到，与我们刚开始传入缓冲区的略有不同，似乎在某些位置上，原先的值变为加上当前起始地址的结果。
进入 BCryptSetContextFunctionProperty函数，最后两参数分别为 _(block1+50h),以及(_ block1+58h)。
其中调用CfgReg_Acquire尝试打开注册表项System\CurrentControlSet\Control\Cryptography\Configuration\Local
失败，返回error =5。
后续构造三个UnicodeString,巧的是，这里三个UnicodeString的来源，正是block1+100,block1+200,block1+400处的所存储的字符串。
在多次调试发现，后续使用的2AAB正是在调用CfgAdtReportFunctionPropertyOperation前，此时的rsp+3f+38h，正是传入的第六参数（*block1+50h），后续函数会将此处的值取word,传入漏洞函数。
调用CfgAdtReportFunctionPropertyOperation函数，传入四参数(伪代码显示此时传入四参数，这是不准确的，查看汇编，我们可以看到至少传入了10个参数，标记处上方的rsp+48)，而第九参数，为传入的第六参数*（block1+50h）,取低两字节。
进入CfgAdtReportFunctionPropertyOperation
最终将rbp+0x460处的值（传入的第九参数），作为第二参数传入崩溃函数，block1+1000作为第一参数，局部变量UnicodeString传入第三参数，进入CfgAdtpFormatPropertyBlock前：
进入CfgAdtpFormatPropertyBlock函数，六倍edx以后，溢出变为2，申请大小为2，申请到special pool内存block3。
调试后，解释一下整个do…
while循环中的操作，循环次数为2AAB,也就是传进来的a2,通过一个类似与密码表的字符数组，访问a1也就是block1+1000处值，右移4位，作为数组下标，取出单个byte（0x30）,填充申请到的内存block3处（WORD），接着a1++,再与上0xF，作为下标取出单个byte(0x30)，block3++，填充，再block3++,填充一个0x20，依旧当作WORD型。这是一次循环中所做的事情，循环计数器a2—。
一次循环完成后，内存布局如图
第二次循环结束，内存布局，
显然，第三次循环时，当放置0x20时，访问无效内存，系统崩溃。
有效内存覆盖完毕。
后续向下一页写0x20时，系统崩溃。
## 漏洞利用
在野利用配合chrome CVE-2020-15999（FreeType 2库的“
Load_SBit_Png”函数中的堆缓冲区溢出漏洞），进行针对chrome沙箱的逃逸，进而可进行提权或者代码执行。
分析来看，如果后续内存布局得当，计数器的值导致可访问的内存相当可观，但是缺陷是填充的值为密码本中数据，需要精巧的构造才行。时间有限，仅此抛砖引玉，各位内核师傅冲鸭！
## 时间线
2020.10.30 谷歌P0小组披露漏洞。
2020.11.09 本篇漏洞分析完成。
待续…
## 参考链接
[1]Issue 2104: Windows Kernel cng.sys pool-based buffer overflow in IOCTL
0x390400
[2]Issue 2104 attachment: cng_ioctl_390400.cpp (2.0 KB)
[3]内核池基础知识（池损坏）