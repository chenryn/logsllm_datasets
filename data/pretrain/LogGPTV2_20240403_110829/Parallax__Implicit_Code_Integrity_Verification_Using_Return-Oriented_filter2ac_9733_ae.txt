and are difﬁcult to apply to legacy binaries, which has thus far
prevented their widespread deployment. Full CFI, as proposed
by Abadi et al., is difﬁcult to combine with Parallax, due to its
need to record (and thus reveal to an adversary) all legal control
transfers. However, as these are application-level approaches,
there is a large amount of leeway for balancing the level of
CFI enforcement against the desired level of tamperprooﬁng
per binary.
C. Protection Coverage
Our technique provides vastly different protection tradeoffs
than oblivious hashing. (1) As mentioned, oblivious hashing
can only protect code with deterministic execution state. Unpro-
tectable code includes code which depends on system calls like
those in the ptrace detector from Section IV-A [13]. Arguably,
such non-deterministic code is more likely to be targeted by
adversaries than deterministic code. For instance, adversaries
commonly modify control ﬂow instructions which depend on
external inputs like license keys. Thus, a signiﬁcant advantage
of our technique is that it can protect both deterministic and
non-deterministic code. (2) Oblivious hashing covers only code
paths of which the state was recorded during testing. In contrast,
our technique is completely static, and can be applied even to
untested code.
Indeﬁnite attack resistance is impossible to implement in
a self-sufﬁcient tamperprooﬁng system [5]. Rather, Parallax
is designed to raise the bar for attackers, and increase the
effort required to tamper with protected code. A determined
adversary may eventually succeed in tampering with code by
ensuring one or more of the following conditions. (1) The
modiﬁcations reside entirely in instructions without overlapping
gadgets. As discussed in Section VII, Parallax attempts to
minimize such instructions. (2) Protected code is modiﬁed
such that the resulting gadgets do not affect the outcome
of the veriﬁcation code. (3) Protected code is altered such
that
to
the originals (including memory/register allocation). These
conditions signiﬁcantly restrict the modiﬁcations that can be
safely made, making it much harder for an attacker to implement
arbitrary modiﬁcations.
the resulting gadgets are semantically equivalent
IX. RELATED WORK
in contrast
To the best of our knowledge, no prior work exists on using
Return-Oriented Programming techniques for tamperprooﬁng.
Additionally,
to our work, previous work on
tamperprooﬁng does not discuss how the proposed techniques
can be applied at the binary level. We therefore believe that
our work is the ﬁrst to discuss code protection which can be
implemented completely at the binary level, and can thus be
used to tamperproof legacy binaries.
Traditional anti-tampering algorithms make use of code
introspection, typically in the form of checksumming [14]. A
highly resilient example of such an algorithm was proposed by
Chang et al. [11], who use a network of cross-verifying code
regions based on checksumming. Unfortunately, Wurster et al.
have shown all such algorithms to be inherently vulnerable to
an attack which exploits the distinct handling of code and data
in modern processors [36]. The attack completely defeats all
introspection-based algorithms by allowing an attacker to freely
modify code in the processor’s instruction cache, while leaving
the data cache untouched. Later work has explored methods
to re-enable code self-checksumming by implementing checks
to detect the attack of Wurster et al [18]. Unfortunately, these
checks require W⊕X protection to be disabled, making the
checksummed binary vulnerable to traditional code injection.
The foremost among the few algorithms designed to
defeat this attack is oblivious hashing [13, 20]. OH veriﬁes
code integrity by checking that hashes of the execution state
correspond to known correct values. In principle, it provides
strong protection which is difﬁcult to circumvent. However,
the execution state is required to be deterministic, preventing
OH from protecting code with non-deterministic inputs, like
environment parameters or system call return values. The main
beneﬁt of our approach compared to OH is that it can protect
code regions which OH cannot.
Previous work has proposed overlapping non-gadget instruc-
tions for tamperprooﬁng [20, 24]. Instruction-level overlapping
is only applicable to architectures with variable-length byte-
aligned instructions [20]. In contrast, our ROP-based approach
does not have this restriction [10, 12]. Furthermore, overlapping
non-gadget instructions requires the insertion of additional
jumps and partial instructions in the protected code, which
leads to whole-program slowdowns of up to 3× [20]. Our
approach provides better overall performance, and can keep
performance overhead isolated from the protected code itself.
Another approach to overlapping is to share common code
133133
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:51:18 UTC from IEEE Xplore.  Restrictions apply. 
blocks between functions. The usefulness of this approach is
limited, as most common code blocks found in real-world
binaries are non-sensitive instruction sequences like function
prologues. It is typically not possible to protect non-trivial code
blocks longer than one instruction using this approach [20].
Concurrently with our work, Lu et al. have explored the
use of ROP for code obfuscation [25]. However, they do
not consider tamperprooﬁng, and thus do not explore how
to maximize the coverage of protective gadgets, or how to
craft gadgets which overlap with sensitive instructions. Instead,
their work focuses on the use of existing (partial) gadgets to
create ROP chains which are embedded with the intent of
hiding functionality. Furthermore, Lu et al. do not attempt to
prevent adversaries from tampering with their ROP chains once
these are discovered. Similarly, prior work has proposed code
hiding techniques based on function reuse, but this work has
not focused on extending this to tamperprooﬁng [23].
X. CONCLUSION
We introduced a novel code self-veriﬁcation technique
based on overlapping ROP gadgets with selected code. Several
rewriting rules can be used to increase the coverage of
protective gadgets, such that up to 90% of all code bytes are
protectable. This coverage exceeds that of oblivious hashing,
and our technique provides better protection for commonly
attacked non-deterministic control ﬂow instructions. Unlike
code introspection-based veriﬁcation algorithms, our approach
is not vulnerable to direct instruction cache modiﬁcation attacks.
Furthermore, in contrast to oblivious hashing algorithms, our
approach can protect non-deterministic code. The performance
overhead of our approach can be conﬁned to veriﬁcation code
which is separate from the protected code. Thus, performance-
sensitive code is protectable without any slowdown, conﬁning
the performance penalty to other code. The performance
overhead for programs protected using our technique is less
than 4%.
ACKNOWLEDGEMENTS
This work was supported by the European Research Council
Starting Grant “Rosetta”, the European Commission EU FP7-
ICT-257007 SysSec project, and the Netherlands Organisation
for Scientiﬁc Research (NWO).
REFERENCES
[1] Intel Pin. http://software.intel.com/en-us/articles/pin-a-
dynamic-binary-instrumentation-tool.
[2] ROPC compiler. https://github.com/pakt/ropc.
[3] A Framework for Aviation Cybersecurity, 2013. Technical
report, AIAA.
[4] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti.
Control-Flow Integrity: Principles, Implementations, and
Applications. In Proceedings of Conference on Computer
and Communications Security, CCS’05, 2005.
[5] B. Barak, O. Goldreich, R. Impagliazzo, S. Rudich,
A. Sahai, S. Vadhan, and K. Yang. On the (Im)possibility
of Obfuscating Programs. In Crypto’01, 2001.
[6] P. Biondi and F. Desclaux. Silver Needle in the Skype.
In Black Hat Europe, 2006.
[7] J. Borello and L. M´e. Code Obfuscation Techniques for
Metamorphic Viruses. Journal of Computer Virology and
Hacking Techniques, 2008.
[8] D. Bruening, T. Garnett, and S. Amarasinghe. An
Infrastructure for Adaptive Dynamic Optimization.
In
Proceedings of Symposium on Code Generation and
Optimization, CGO’03, 2003.
[9] D. Brumley, I. Jager, T. Avgerinos, and E. J. Schwartz.
BAP: A Binary Analysis Platform.
In Proceedings of
Conference on Computer-Aided Veriﬁcation, CAV’11,
2011.
[10] E. Buchanan, R. Roemer, H. Shacham, and S. Savage.
When Good Instructions Go Bad: Generalizing Return-
Oriented Programming to RISC.
In Proceedings of
Conference on Computer and Communications Security,
CCS’08, 2008.
[11] H. Chang and M. J. Atallah. Protecting Software Code
by Guards. In Proceedings of Digital Rights Management
Symposium, DRM’01, 2001.
[12] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi,
H. Shacham, and M. Winandy. Return-Oriented Program-
ming Without Returns. In Proceedings of Conference on
Computer and Communications Security, CCS’10, 2010.
[13] Y. Chen, R. Venkatesan, M. Cary, R. Pang, S. Sinha,
and M. H. Jakubowski. Oblivious Hashing: A Stealthy
Software Integrity Veriﬁcation Primitive. In Proceedings
of ACM Workshop on Information Hiding and Multimedia
Security, IH’05, 2003.
[14] C. Collberg and J. Nagra. Surreptitious Software: Obfus-
cation, Watermarking, and Tamperprooﬁng for Software
Protection. Addison-Wesley Professional, 1st edition,
2009.
[15] L. Davi, D. Lehmann, A.-R. Sadeghi, and F. Monrose.
Stitching the Gadgets: On the Ineffectiveness of Coarse-
Grained Control-Flow Integrity Protection. In Proceedings
of USENIX Security Symposium, USENIX Sec’14, 2014.
[16] F. Falcon and N. Riva. Dynamic Binary Instrumentation
Frameworks: I Know You’re There Spying On Me. In
RECON’12, 2012.
[17] N. Falliere, L. O Murchu, and E. Chien. W32.Stuxnet
Dossier, 2011. Technical report, Symantec.
[18] J. Gifﬁn, M. Christodorescu, and L. Kruger. Strengthening
Software Self-Checksumming via Self-Modifying Code.
In Proceedings of Annual Computer Security Applications
Conference, ACSAC’05, 2005.
[19] E. G¨oktas¸, E. Athanasopoulos, H. Bos, and G. Portokalidis.
Out Of Control: Overcoming Control-Flow Integrity. In
Proceedings of IEEE Symposium on Security and Privacy,
S&P’14, 2014.
[20] M. Jacob, M. H. Jakubowski, and R. Venkatesan. To-
wards Integral Binary Execution: Implementing Oblivious
Hashing Using Overlapped Instruction Encodings.
In
Proceedings of Conference on Multimedia and Security,
MM&Sec’07, 2007.
[21] Kaspersky Lab Global Research and Analysis Team.
Gauss: Abnormal Distribution, 2012. Technical report,
Kaspersky.
[22] M. Laurenzano, M. M. Tikir, L. Carrington, and
A. Snavely. PEBIL: Efﬁcient Static Binary Instrumentation
for Linux. In Proceedings of Symposium on Performance
Analysis of Systems and Software, ISPASS’10, 2010.
[23] Z. Lin, X. Zhang, and D. Xu. Reuse-Oriented Camou-
134134
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:51:18 UTC from IEEE Xplore.  Restrictions apply. 
ﬂaging Trojan: Vulnerability Detection and Attack Con-
struction. In Proceedings of Conference on Dependable
Systems and Networks, DSN’10, 2010.
[24] C. Linn and S. Debray. Obfuscation of Executable Code to
Improve Resistance to Static Disassembly. In Proceedings
of Conference on Computer and Communications Security,
CCS’03, 2003.
[25] K. Lu, S. Xiong, and D. Gao. RopSteg: Program
Steganography with Return Oriented Programming. In
Proceedings of ACM Conference on Data and Application
Security and Privacy, CODASPY’14, 2014.
[26] K. Lu, D. Zou, W. Wen, and D. Gao. deRop: Remov-
In
ing Return-Oriented Programming from Malware.
ACSAC’11, 2011.
[27] V. Pappas, M. Polychronakis, and A. D. Keromytis.
Transparent ROP Exploit Mitigation Using Indirect Branch
Tracing. In Proceedings of USENIX Security Symposium,
USENIX Sec’13, 2013.
[28] M. Polychronakis and A. D. Keromytis. ROP Payload
Detection Using Speculative Code Execution. In MAL-
WARE’11, 2011.
[29] K. A. Roundy and B. P. Miller. Binary-Code Obfuscations
in Prevalent Packer Tools. ACM Computing Surveys, 2012.
[30] H. Sa¨ıdi, V. Yegneswaran, and P. Porras. Experiences in
Malware Binary Deobfuscation. Virus Bulletin, 2010.
[31] F. Schuster, T. Tendyck, J. Pewny, A. Maass, M. Steeg-
manns, M. Contag, and T. Holz. Evaluating the Effec-
tiveness of Current Anti-ROP Defenses. In Proceedings
of Symposium on Research in Attacks, Intrusions and
Defenses, RAID’14, 2014.
[32] E. J. Schwartz, T. Avgerinos, and D. Brumley. Q: Exploit
In Proceedings of USENIX
Hardening Made Easy.
Security Symposium, USENIX Sec’11, 2011.
[33] H. Shacham. The Geometry of Innocent Flesh on the
Bone: Return-into-Libc Without Function Calls (on the
x86). In Proceedings of Conference on Computer and
Communications Security, CCS’07, 2007.
[34] A. Srivastava and J. Gifﬁn. Automatic Discovery of
Parasitic Malware.
In Proceedings of Symposium on
Research in Attacks, Intrusions and Defenses, RAID’10,
2010.
[35] United States Department of Defense. DoD Software Pro-
tection Initiative. In SSTC’06, 2006. Description at http:
//sstc-online.org/2006/index.cfm?fs=exhlist&Letter=D.
[36] G. Wurster, P. van Oorschot, and A. Somayaji. A Generic
Attack on Checksumming-Based Software Tamper Resis-
tance. In Proceedings of IEEE Symposium on Security
and Privacy, S&P’05, 2005.
[37] H. Yin, Z. Liang, and D. Song. HookFinder: Identifying
and Understanding Malware Hooking Behaviors.
In
Proceedings of Network and Distributed System Security
Symposium, NDSS’08, 2008.
[38] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres,
S. McCamant, D. Song, and W. Zou. Practical Control
Flow Integrity & Randomization for Binary Executables.
In IEEE Symposium on Security and Privacy, S&P’13,
2013.
135135
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:51:18 UTC from IEEE Xplore.  Restrictions apply.