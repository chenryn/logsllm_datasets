User: I'm writing a TCP server that can take 15 seconds or more to begin generating the body of a response to certain requests. Some clients like to close the connection at their end if the response takes more than a few seconds to complete. 
Since generating the response is very CPU-intensive, I'd prefer to halt the task the instant the client closes the connection. At present, I don't find this out until I send the first payload and receive various hang-up errors.
How can I detect that the peer has closed the connection without sending or receiving any data? That means for recv that all data remains in the kernel, or for send that no data is actually transmitted.
Assistant: I've had a recurring problem communicating with equipment that had separate TCP links for send and receive.  The basic problem is that the TCP stack doesn't generally tell you a socket is closed when you're just trying to read - you have to try and write to get told the other end of the link was dropped.  Partly, that is just how TCP was designed (reading is passive).
I'm guessing Blair's answer works in the cases where the socket has been shut down nicely at the other end (i.e. they have sent the proper disconnection messages), but not in the case where the other end has impolitely just stopped listening.
Is there a fairly fixed-format header at the start of your message, that you can begin by sending, before the whole response is ready?  e.g. an XML doctype?  Also are you able to get away with sending some extra spaces at some points in the message - just some null data that you can output to be sure the socket is still open?