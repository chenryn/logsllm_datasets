of Algorithm 8, multiplications in step 3 are accompanied by a
LazyReduced16 and so the components of the vectors y′
i, j are in
the range [−256, +255]. To compute the vectors yi, j in step 4, we do
not perform reduction for vector addition and subtraction, and sub-
traction uses kp for k = 22 and 25. This results in the components
of the output vector to be at most 14-bit long. The multiplications
t′
i, j = yi, j ⊙257 A′
i, j in Algorithm 8 are implemented using the
above vector multiplication followed by a Reduced16 operation,
resulting in each component of the output vector to be 9-bits and
so no further reduction for the additions x′S,i = x′S,i ⊕257 t′
i, j is
K2SN-MSS: An Efficient Post-Quantum Signature (Full Version)
xxx, yyy, zzz
needed. This results in vectors whose components are at most 13-bit
long. Finally, we use Reduced16 on the vector x′S,i to produce the
final result where components of x′S,i are all at most 9 bits.
These optimizations reduce the number of reduction operations.
Figures 2, 3, 4 and 5 show that the total number of vector operations
that are required for steps 3 and 4 of 16-way parallelization of NTT
is significantly smaller than the number of operations required for
8-way parallelization, and this leads to a substantial speedup of the
implementation of SWIFFT-16-avx2.
5.8 Implementation of Cover-Free-Family
KSN uses a 1-CFF which is obtained by taking all subsets of size
t/2 from a set of size t and so one can use a log2
space. Each subset corresponds to a particular message. For efficient
encoding of messages however, we use the algorithm proposed
in [8, 12, 40].
(cid:17) bit message
(cid:16) t
t /2
5.9 Implementation of Pseudo-Random
Function
We use ChaCha20 [6] as the pseudo-random function family Fn.
ChaCha20 is an state-of-the-art stream-cipher which we use to
generate the seed of each KSN-OTS from secret-key of K2SN-MSS,
and all the component secret keys of the OTS instances. We use the
avx2-based implementation of ChaCha20 from supercop [2]1.
6 EXPERIMENTS
We used the following platform for our implementations and ex-
periments:
Skylake: Intel®Core™i7-6700 4-core CPU @ 3.40GHz running.
The timing experiments are performed on a single core. The OS
is 64-bit Ubuntu-18.04 LTS and C codes were compiled by GCC
version 7.3.0. The code of the software is available at [23]. Dur-
ing the experiments, the turbo boost and hyper-threading were
turned off. The cache warm-up was done by 25000 iterations and
the measurements are taken as the median over 100000 iterations.
6.1 Performance Comparison of SWIFFT
Implementations
We have implemented all the parallelized version of the SWIFFT
function using 16-bit avx2 intrinsic instructions. Each element of
Z257 is represented by 9-bit. The SWIFFT evaluations were com-
puted over 1024-bit data blocks. The generalized SWIFFT function
uses 9 × 1024 bit data blocks as input. The output in both cases is a
9 × 64 = 576 bits string. For binary versions of SWIFFT-8-avx2 and
SWIFFT-16-avx2, we require approximately 8KB and 2MB mem-
ory for the precomputation tables, respectively. The Time Stamp
Counter (TSC) was read from the CPU to RAX and RDX registers
using RDTSC instruction. All the experimental results are listed in
Table 7. The results show that SWIFFT-8-avx2 and SWIFFT-16-avx2
are approximately 8% and 25% faster than the previous implemen-
tation in [5, 28]. Based on these results, we use SWIFFT-16-avx2
for K2SN-MSS.
1The software is implemented by D. J. Bernstein and R. Dolbeau and available in the
directory “supercop-20171218/crypto_stream/chacha20/dolbeau/amd64-avx2”
Function Name
Intrinsic Flag
Binary Version
clk/byte Total Clk
Generalized Version
clk/byte
Total clk
SWIFFT-8-sse2 [31]
-
9.93
SWIFFT-8-avx2 [this paper]
8.27
SWIFFT-16-avx2 [this paper]
Table 7: Required clock cycles (clk) for various SWIFFT im-
plementation.
mavx2
mavx2
mavx2
1150
1047
866
8.98
8.17
6.77
-
11435
9535
6.2 Performance Comparison of KSN and
W-OTS+
KSN-OTS and W-OTS+ are the OTS that are used in K2SN-MSS and
XMSS respectively. We compare both of them at n = 512. For the W-
OTS+, we used the code for XMSS [19], available at [1, 3]. The Time
Stamp Counter reading did not work with the XMSS code of [1,
3]. We instead used clock() function of “time.h” header file. Our
measurement is the average over 1,000,000 iterations. The results of
performance comparison of KSN-OTS and W-OTS+ are in Table 8
and it shows that, the key generation of KSN is approximately 22
times faster than that of W-OTS+, while signing and verification are
approximately 23 and 167 times faster than those of W-OTS+. This
performance is due to the simple signing operation (generation of
component secret keys and component-wise vector addition) and
efficient implementation of дSWIFFT that is used in the verification
operation of KSN-OTS.
KSN/SWIFFT-16-avx2 W-OTS+/SHA512/w = 16
Key Generation (µs)
Signing (µs)
Verification (µs)
Secret Key/ (Bytes)
Public Key (Bytes)
Signature Sizes (Bytes)
164
83
10
40
4608
1024
3575
1872
1674
64
4352
4288
Table 8: Performance Comparison of KSN and W-OTS+ in µs
Remark: We compare our implemented K2SN-MSS software
against the results of [15], but the code of [15] is not public.2 [15]
reports the fastest result for XMSS.
6.3 Performance Comparison between
K2SN-MSS and XMSS
The timing measurements are done the same as in Section 6.2. We
compare our implemented software against the XMSS software
results available at [15]. We used the SWIFFT-16-avx2 implemen-
tation of K2SN-MSS. We compute the authentication path using
the TREEHASH algorithm of [10]. The results of the performance
comparisons are in Table 1 and it shows that the key generation,
signing and verification of K2SN-MSS are 2.76 times, 2.89 times and
2.65 times faster than the corresponding operations in XMSS [15],
respectively.
Remarks:
(1) The signature size of K2SN-MSS is comparable with the
signature sizes of the XMSSMT [20] and the SPHINCS [7], but
we can not compare K2SN against XMSSMT and SPHINCS
2We tried to communicate the authors, but did not receive any reply yet.
xxx, yyy, zzz
Sabyasachi Karati and Reihaneh Safavi-Naini
because the use of the Merkle tree is different in the two cases.
In K2SN-MSS and XMSS (single tree version of XMSSMT ) use
only one layer of Merkle tree where XMSSMT and SPHINCS
uses multiple layers of Merkle tree.
(2) Even so, if we want to compare K2SN-MSS against the XMSSMT
and SPHINCS, we need optimized software of them for
n = 512. But in the literature, we could not find a single
implementation of XMSSMT and SPHINCS which provides
512-bit classical (256-bit quantum) security. Thus we are
unable to compare them.
(3) Our comparison is against the multi-buffer entries of the
third row of TABLE IV of [15]. It is due to the following
reasons:
(a) this is the only reported results for SHA512, where SWIFFT
output is 576 bits. This comparison is fair because of the
comparative sizes of the used hash functions.
(b) The experimental platform of [15] was
Skylake: Intel®Core™i7-6700 4-core CPU @ 4.0GHz
which is a faster machine than the machine used in our
experiments. Therefore, we believe that the comparisons
are made in Table 1 are valid and fair.
7 CONCLUDING REMARKS
Hash-based signatures are a strong alternative for post-quantum
signatures. We extended KSN-OTS for signing multiple messages
which is secure under multi-function multi-target attacks and gave
an efficient implementation using parallelization at the instruction
level, using a widely accessible technology of Intel. Our imple-
mentation also improves the state-of-the-art implementation of
SWIFFT and provides parallelization of NTT computation, both of
independent interest. Although our results are for concrete levels of
parallelization, but by providing implementation details we provide
a template for other parameters, for binary and non-binary input
vectors, and with or without precomputation. Our implementation
shows that K2SN-MSS is significantly faster than XMSS, which is
recently proposed as a candidate for standardization.
In our implementation we used SWIFFT both for KSN-OTS, and
the Merkle hash tree. Although SWIFFT is essential in KSN-OTS,
the Merkle tree is used to authenticate the public key PK i, against
the root of the MSS tree and we are not restricted to SWIFFT for
the hash function. Thus, for this tree one can use traditional hash
functions such as SHA512. Our choice of SWIFFT hash function
family for the construction of L trees and MSS has the following
advantages. Firstly, it reduces the complexity of the code: using
two different hash function families will increase the code com-
plexity and size. Secondly, SWIFFT has (asymptotic) provable se-
curity and this improves confidence in the security of the design.
Finally, SHA512 hash function family follows Merkle-Damgård con-
struction [39] which is inherently a sequential construction and
so not easily amenable to parallelization. SWIFFT function family,
however, is highly parallelizable, and can benefit from processor
architecture with longer registers to achieve higher speed.
REFERENCES
[1] [n. d.]. Hülsing. https://huelsing.wordpress.com/code/.
[2] [n. d.]. Supercop: Version 2017.12.18. https://bench.cr.yp.to/supercop.html.
[3] [n. d.]. xmss-reference. https://github.com/joostrijneveld/xmss-reference.
[4] 2018. The Internet Engineering Task Force. https://tools.ietf.org/html/rfc8391.
[5] Y. Arbitman, G. Dogon, V. Lyubashevsky, D. Micciancio, C. Peikert, and A. Rosen.
2008. SWIFFTX: A Proposal for the SHA-3 Standard. https://www.eecs.harvard.
edu/~alon/PAPERS/lattices/swifftx.pdfl.
[6] D. J. Bernstein. 2008. ChaCha, a variant of Salsa20.
[7] D. J. Bernstein, D. Hopwood, A. H ¨ulsing, T. Lange, R. Niederhagen, L. Pa-
pachristodoulou, P. Schwabe, and Z. W. O’Hearn. 2015. SPHINCS: Practical
Stateless Hash-Based Signatures. In Advances in Cryptology – EUROCRYPT (Lec-
ture Notes in Computer Science), Vol. 9056. Springer, 368–397.
[8] K. Bicakci, G. Tsudik, and B. Tung. 2003. How to construct optimal one-time
signatures. Journal of Computer Networks 43, 3 (2003), 339–349.
[9] J. Buchmann, E. Dahmen, and A. Hülsing. 2011. XMSS - A Practical Forward Se-
cure Signature Scheme Based on Minimal Security Assumptions. In Post-Quantum
Cryptography – PQCrypto (Lecture Notes in Computer Science), Vol. 7071. Springer,
117–129.
[10] J. Buchmann, E. Dahmen, and M. Schneider. 2008. Merkle Tree Traversal Revisited.
In Post-Quantum Cryptography - PQCrypto (Lecture Notes in Computer Science),
Vol. 5299. Springer, 63–78.
[11] N. Courtois, M. Finiasz, and N. Sendrier. 2001. How to Achieve a McEliece-based
Digital Signature Scheme. In Advances in Cryptology – ASIACRYPT (Lecture Notes
in Computer Science), Vol. 2248. Springer, 157–174.
[12] T. Cover. 1973. Enumerative Source Encoding. IEEE Transactions on Information
Theory 19, 1 (1973), 73–77.
[13] E. Dahmen, K. Okeya, T. Takagi, and C. Vuillaume. 2008. Digital Signatures Out
of Second-Preimage Resistant Hash Functions. In Post-Quantum Cryptography –
PQCrypto (Lecture Notes in Computer Science), Vol. 5299. Springer, 109–123.
[14] A. Das and C. E. Veni Madhavan. 2009. Public-Key Cryptography: Theory and
Practice. Pearson.
[15] A. K. D. S. de Oliveira, J. LÂťopez, and R. Cabral. 2017. High Performance of
Hash-based Signature Schemes.
International Journal of Advanced Computer
Science and Applications 8, 3 (2017).
IEEE
Transactions on Information Theory 22, 6 (1976), 644–654.
[17] L. Ducas, A. Durmus, T. Lepoint, and V. Lyubashevsky. 2013. Lattice Signatures
and Bimodal Gaussians. In Advances in Cryptology – CRYPTO (Lecture Notes in
Computer Science), Vol. 8042. Springer, 40–56.
[16] W. Diffie and M. E. Hellman. 1976. New directions in cryptography.
[18] A. Fog. 2016. Software optimization resources. http://agner.org/optimize/.
[19] A. Hülsing, D. Butin, S.-L. Gazdag, and A. Mohaisen. 2017. XMSS: Extended
Hash-Based Signatures. draft-irtf-cfrg-xmss-hash-based-signatures, work in
progress.
[20] A. Hülsing, L. Rausch, and J. Buchmann. 2013. Optimal Parameters for XMSSMT .
In Security Engineering and Intelligence Informatics: CD-ARES (Lecture Notes in
Computer Science), Vol. 8128. Springer, 194–208.
[21] A. Hülsing, J. Rijneveld, and F. Song. 2016. Mitigating Multi-target Attacks in
Hash-Based Signatures. In Public Key Cryptography – PKC (Lecture Notes in
Computer Science), Vol. 9614. Springer, 387–416.
[22] Intel. [n. d.]. https://software.intel.com/sites/landingpage/IntrinsicsGuide/#.
[23] K2SN-MSS. [n. d.]. https://github.com/anon1985/K2SN-MSS.
[24] K. Kalach and R. Safavi-Naini. 2016. An Efficient Post-Quantum One-Time
Signature Scheme. In Selected Areas in Cryptography – SAC (Lecture Notes in
Computer Science), Vol. 9566. Springer, 331–351.
[25] L. Lamport. 1979. Constructing Digital Signatures from a One Way Function.
technical report of SRI International.
[26] P. Longa and M. Naehrig. 2016. Speeding up the Number Theoretic Transform
for Faster Ideal Lattice-Based Cryptography. In Cryptology and Network Security
– CANS (Lecture Notes in Computer Science), Vol. 10052. Springer, 124–139.
[27] V. Lyubashevsky and D. Micciancio. 2006. Generalized Compact Knapsacks Are
Collision Resistant. In International Colloquium on Automata, Languages, and
Programming – ICALP (Lecture Notes in Computer Science), Vol. 4052. Springer,
144–155.
[28] V. Lyubashevsky, D. Micciancio, C. Peikert, and A. Rosen. 2008. SWIFFT: A
Modest Proposal for FFT Hashing. In Fast Software Encryption – FSE (Lecture
Notes in Computer Science), Vol. 5086. Springer, 54–72.
[29] R. C. Merkle. 1987. A Digital Signature Based on a Conventional Encryption
Function. In Advances in Cryptology – CRYPTO (Lecture Notes in Computer Science),
Vol. 293. Springer, 369–378.
[30] R. C. Merkle. 1989. A Certified Digital Signature. In Advances in Cryptology –
[31] D. Micciancio. [n. d.]. https://github.com/micciancio/SWIFFT.
[32] D. Micciancio. 2007. Generalized Compact Knapsacks, Cyclic Lattices, and Effi-
CRYPTO (Lecture Notes in Computer Science), Vol. 435. Springer, 218–238.
cient One-Way Functions. Computational Complexity 16, 4 (2007), 365–411.
[33] D. Moody. [n. d.]. Stateful hash-based signatures.
[34] NIST.
als.
Post-Quantum-Cryptography-Standardization/Call-for-Proposals.
Post-Quantum Cryptography - Call
for Propos-
https://csrc.nist.gov/Projects/Post-Quantum-Cryptography/
[35] C. Peikert and A. Rosen. 2006. Efficient Collision-Resistant Hashing from Worst-
Case Assumptions on Cyclic Lattices. In Theory of Cryptography Conference –
2017.
K2SN-MSS: An Efficient Post-Quantum Signature (Full Version)
xxx, yyy, zzz
TCC (Lecture Notes in Computer Science), Vol. 3876. Springer, 145–166.
[36] J. Rompel. 1990. One-way functions are necessary and sufficient for secure
signatures. In ACM symposium on Theory of computing – STOC. ACM, 387–394.
[37] P. W. Shor. 1994. Algorithms for quantum computation: discrete logarithms and
factoring. In Proceedings 35th Annual Symposium on Foundations of Computer
Science. 124–134.
[38] T. Simonite. [n. d.]. MIT Technology Review.
[39] W. Sun, H. Guo, H. He, and Z. Dai. 2007. Design and optimized implementation
of the SHA-2(256, 384, 512) hash algorithms. In International Conference on ASIC.
IEEE, 858–861.
[40] G. M. Zaverucha and D. R. Stinson. 2011. Short one-time signatures. Advances in
Mathematics of Communications–AMC 5, 3 (2011), 473–488.