Once an instance-property model is obtained, there
are many ways
to decompose the model. Naive
decomposition may lead to groups that are difficult to
reuse. Thus, we develop a condition for each group to
be manageable. Although the condition is further
refined, we focus on the essence in this section. The
extensions are presented later in Section 6.
The condition is based on the observation that a
routing policy described by a community generally
involves a set of routes that require the same set of
actions. For example, routes from all customers might
be re-advertised to all the peers and providers. A few
prefixes from some customers might be AS-prepended
three times when re-advertised to other peers so that
those routes are not preferred. Such different sets of
routes are represented by instances in our model. Thus,
in order to identify distinct sets of routes that cause
certain actions in concert, we identify such sets of
instances.
to py.
We formalize the algorithm in Fig. 3 and present an
example in Fig. 4. In a policy model G, we go over
each property py and identify the set of instances Itmp(Y)
that are adjacent
Itmp(Y) represents the set of
routes that match the condition of py and thus are
subject to the same action as described in py. Among all
such sets, we draw distinct sets, I] through IN. These
sets represent distinct sets of routes that take the same
action. Each Ix has its counterpart Px' {Py: Itmp(Y)=Ix}.
For each pair (Ix, Px), all the edges between (Ix, Px)
belong to the same group and thus are assigned to the
same community. In Fig. 4, there are two distinct Ix's
that take the same actions as a unit, I]={i]} and 12={iJ,
ib i3 }. The corresponding P/s are p]={p]} and P2={Pb
P3}. The two routing policy groups use community A
and B,
in the original
configuration (a) and the reproduced configuration (d)
are the same, and thus the transformation is function(cid:173)
preserving. Note that each community (group) in the
reproduced configuration has a consistent meaning. In
"come-from"
fact,
relationship:
routes that come-from Ix take certain
actions in Px as a unit.
respectively. The edges
community
represents
a
a
5. Evaluation
We implement and evaluate our algorithm for the
communities on configurations from four different
1-4244-2398-9/08/$20.00 ©2008 IEEE
302
DSN 2008: Lee et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:18:36 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems &Networks: Anchorage, Alaska, June 24-27 2008
7
: x-th instance
: y-th property
ix
py
G : Policy model. Gx,y = 1 if (ix, Py) E E(G). Otherwise, Gx,y = O.
N : Number of new communities
Cx
Ix
Px
h( ): Hash function associated with a hash table H. If h(Iunp)=x > 0,
Itmp is present in H, where Ix = Itmp. Otherwise, h(Itmp) = O.
: x-th new community
: A set of instances that adds cx
: A set of properties that match Cx
Empty H.
N=O;
for each property py
I tmp = rp;
for each instance ix
if Gx,y = 1 then Itrnp = Itmp U fix};
if h(Itmp) = 0 then {
// create a new community
N = N + 1; h(Itmp) = N;
PN = {py};
IN =Itmp;
} else {Ph(ltmp} = Ph(ltmp} U {Py};}
Figure 3. Algorithm that identifies distinct policies based on the
come-from relationship.
production networks. The evaluation is done in three
steps. First, we assess the reduction in the configuration
length. We use two complexity measures that are
proven to have strong correlation with maintenance
cost. Second, we examine the meanings of the policy
groups before and after the transformation. For these
two steps, we analyze a particular snapshot of each
network between March and April 2006. Finally, we
analyze monthly snapshots of network 1 and 2 for two
years to see if communities generated by our algorithm
for the first snapshot could be reused over time. As
shown in Table 1:
related
commands.
• We reduce up to 90% of communities and 70% of
community
disregard
communities that do not create any edges (Section 5.3),
no reduction is possible for
two networks either
because there is a simple set of policies,
their
communities are well structured, or there have not been
many changes.
If we
• More than 70% of the communities are defined
by the come-from policy. There are a few exceptions,
and we address them in Section 6.
• Most new communities are shown to be reusable
as the number of peering relationships grows by 25%
over the two-year period.
We describe implementation/experimental details in
Section 5.1 and the two complexity measures in
Section 5.2. We then present the details of our results
in Section 5.3.
5.1. Experimental Setup and Implementation
;i
if
if
if
if CorE, ...
, add B C ~ Pi
, add A D k\\ P2 if B or Cor D, •••
, add A D ~ P3 if Bore or D, ...
;1 if
if
if
,addAB'- PI
if A, •..
, addB ~ P2 ifB, ...
, add B ~ P3 ifB, •.•
(a)
D
G
(d)
D
[I}-----0
A
(b)
(c)
Figure 4. An example of routing policies (as shown in (a)), the
corresponding instance-property model (as shown in (b)),
decomposition by the come-from relationship (as shown in (c)), and
the reproduced routing policies (as shown in (d)).
do
on
the
focus
First, we
simplification
domain. We
and
restructuring of internal BGP communities within one
administrative
consider
communities that are intended for use by external
networks. However,
this idea can be extended to
multiple domains
In addition,
predefined standard communities such as no-export and
no-advertise are not subject
to our simplification
process.
in the same way.
not
and
separate
if-then-clauses
Our implementation uses a configuration parser [9]
JUNOS
developed for Cisco lOS and Juniper
related to
commands. We parse routing policies
communities
into
instances/properties in the format shown in Fig. 5. A
property has a condition in Boolean logic since
communities are matched based on Boolean operations
(AND/ORINOT). An instance has a list of communities
attached by its corresponding if-clause. Although a
community can be deleted as well, for simplicity we
consider only the addition of communities.
In the
configurations from the four networks, we find that
deletion of communities is rarely used, and it is only
used to remove certain communities on routes received
from/advertised
networks. Therefore,
deletion of such communities does not influence the
operations
the
administrative domain.
used within
communities
external
of
to
5
an
Fig.
shows
instance-property model
representation for a configlet of Cisco lOS. There are
two route filters,
from_dora and to_toto. We also
show their instance-property model. Instance i1 and
property Pl represent from_dora, whereas i2 and P2
represent
indicates that
routes redistributed through from_dora will match
to_toto. Refer to our technical report [19] for details.
to_toto. The edge (iJ, P2)
1-4244-2398-9/08/$20.00 ©2008 IEEE
303
DSN 2008: Lee et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:18:36 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems &Networks: Anchorage, Alaska, June 24-27 2008
8
TABLE 1.
SUMMARY OF ANALYSIS
Configuration in Cisco IDS syntax:
Index
1
2
3
4
Num. communities
After
8
4
10
4
Before
293 (113)
43 (4)
45 (14)
11 (4)
Num.LOC
Before
9003 (8419)
282 (184)
2756 (1443)
227 (126)
After
2036
194
1409
126
Network {I, 2} are regional providers, and Network {3, 4} are national providers. The
number of routers are (44, 6, 13, 11) and the number of distinct external peers are (133,
39, 414, 77). The numbers in parentheses represent the numbers excluding dangling
communities (as shown in Section 5.3) that do not create any edge.
Note that an edge can also be created by other types
of filters based. on prefix or AS-path attributes. In that
sense, this model can be extended to a layered model
with edges that are made from communities, and which
are elaborated by conditions involving prefixes, AS(cid:173)
path, and so forth. We do not consider these additional
conditions in this paper. However, we preserve the
from communities when reassigning
edges made
communities. Therefore,
the edges will be correctly
elaborated by other conditions that are not considered
in this process, and the underlying routing policies are
left intact.
5.2. Complexity Measures
number of
[17][18]. The
We use two measures, the number of communities
and the number of LaC (Lines of Commands).
Multiple studies validate their correlation with the
number of faults and development/maintenance time
communities
required
measures the total number of distinct communities that
are used internally within a network. This is analogous
to the vocabulary size [17], a software complexity
measure that counts the nu;mber of unique operators
and operands. It reflects the size of search space when
writing or reading a command. As it becomes larger,
the operator has to consider and compare more options
to configure a community, and the configuration
becomes a more complex task. The number of LOC is
the sum of the number of individual communities used
in conditional/action clauses. This
its
counterpart, which counts the number of individual
commands in software. The more places an operator
needs to configure, the more chance to make mistakes.
This is especially true when we configure communities,
each of which can have dependencies and can impact
tens to hundreds of BGP sessions [16]. Furthermore,
our previous work [9] finds a number of community(cid:173)
related errors, such as missing communities and using
wrong communities in a network where each if-then(cid:173)
clause consists of more than five communities on
average.
also has
01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
neighbor 1.1.1.1 route-map from dora in
neighbor 2.2.2.2 route-map to_toto out
route-map from_dora permit 10
match community LIST1
set community 1:200 1:300
!
route-map to_toto permit 10
match community LIST2
set community 3:500
!
ip community-list LIST1 deny 2:444
ip community-list LIST1 2:100
ip community-list LIST2 1:200 1:300
ip community-list LIST2 1:400
Instance-Property Model Representation:
, add 1:2001:300
IPI
if (not 2:444) and 2: 100, ...
, add 3:500
P2 if (1 :200 and 1:300) or 1:400, ...
;1 if
I;2 if
Figure 5. BGP configuration in instance-property model
representation.
5.3. Results