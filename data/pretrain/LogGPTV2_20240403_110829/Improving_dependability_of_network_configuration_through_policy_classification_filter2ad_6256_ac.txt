### Decomposition of Instance-Property Models

Once an instance-property model is obtained, there are multiple ways to decompose it. A naive decomposition may result in groups that are difficult to reuse. To address this, we develop a condition for each group to be manageable. Although this condition can be further refined, we will focus on its core aspects in this section, with extensions discussed in Section 6.

The condition is based on the observation that a routing policy described by a community typically involves a set of routes that require the same set of actions. For example, routes from all customers might be re-advertised to all peers and providers. A few prefixes from some customers might be AS-prepended three times when re-advertised to other peers to ensure they are not preferred. These different sets of routes are represented as instances in our model. Therefore, to identify distinct sets of routes that cause certain actions, we identify such sets of instances.

### Formalization and Example

We formalize the algorithm in Figure 3 and provide an example in Figure 4. In a policy model \( G \), we iterate over each property \( p_y \) and identify the set of instances \( I_{\text{tmp}}(y) \) that are adjacent to \( p_y \). The set \( I_{\text{tmp}}(y) \) represents the routes that match the condition of \( p_y \) and thus are subject to the same action. Among all such sets, we extract distinct sets \( I_1 \) through \( I_N \). Each \( I_x \) has a corresponding set of properties \( P_x = \{ p_y : I_{\text{tmp}}(y) = I_x \} \). For each pair \( (I_x, P_x) \), all edges between \( I_x \) and \( P_x \) belong to the same group and are assigned to the same community.

In Figure 4, there are two distinct \( I_x \) sets that take the same actions: \( I_1 = \{ i_1 \} \) and \( I_2 = \{ i_2, i_3, i_4 \} \). The corresponding \( P_x \) sets are \( P_1 = \{ p_1 \} \) and \( P_2 = \{ p_2, p_3 \} \). The two routing policy groups use communities A and B, respectively. The edges in the original configuration (a) and the reproduced configuration (d) are the same, ensuring that the transformation is function-preserving. Each community in the reproduced configuration has a consistent meaning, representing a "come-from" relationship: routes that come from \( I_x \) take certain actions in \( P_x \) as a unit.

### Evaluation

We implemented and evaluated our algorithm on configurations from four different production networks. The evaluation consists of three steps:

1. **Reduction in Configuration Length**: We assess the reduction in configuration length using two complexity measures that have been shown to correlate strongly with maintenance cost.
2. **Policy Group Meanings**: We examine the meanings of the policy groups before and after the transformation, analyzing a particular snapshot of each network between March and April 2006.
3. **Reusability Over Time**: We analyze monthly snapshots of networks 1 and 2 over two years to determine if the communities generated by our algorithm for the first snapshot can be reused over time.

#### Key Findings

- **Reduction in Communities and Commands**: Our algorithm reduces up to 90% of communities and 70% of related commands. If we disregard communities that do not create any edges, no reduction is possible for two networks due to their simple policies, well-structured communities, or lack of changes.
- **Come-From Policy**: More than 70% of the communities are defined by the "come-from" policy, with a few exceptions addressed in Section 6.
- **Reusability**: Most new communities are reusable as the number of peering relationships grows by 25% over the two-year period.

### Experimental Setup and Implementation

We focus on the simplification and restructuring of internal BGP communities within one administrative domain. We consider communities intended for use by external networks, though this idea can be extended to multiple domains. Predefined standard communities like "no-export" and "no-advertise" are not subject to our simplification process.

Our implementation uses a configuration parser [9] developed for Cisco IOS and Juniper JUNOS, parsing routing policies into instances/properties. A property has a Boolean logic condition, and an instance has a list of communities attached by its corresponding if-clause. Deletion of communities is rarely used and does not influence operations within the administrative domain.

Figure 5 shows an instance-property model representation for a configlet of Cisco IOS. There are two route filters, `from_dora` and `to_toto`, with their respective instance-property models. The edge \((i_1, p_2)\) indicates that routes redistributed through `from_dora` will match `to_toto`.

### Complexity Measures

We use two measures: the number of communities and the number of Lines of Commands (LOC). Multiple studies validate their correlation with the number of faults and development/maintenance time required. The number of communities measures the total number of distinct communities used internally, analogous to vocabulary size in software complexity. The number of LOC is the sum of individual communities used in conditional/action clauses, similar to the number of individual commands in software. This reflects the complexity and potential for errors in configuration.

### Results

Table 1 summarizes the analysis of the configurations. Networks 1 and 2 are regional providers, while Networks 3 and 4 are national providers. The number of routers and distinct external peers are provided, along with the reduction in communities and LOC.

This structured approach ensures that the transformation is function-preserving and that the underlying routing policies remain intact.