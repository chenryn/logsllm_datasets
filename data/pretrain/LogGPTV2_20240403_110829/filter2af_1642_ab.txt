       }
    }
详细的使用方法参考[oraclize](http://docs.oraclize.it/#background)。
#### 2 基础合约参与生成
第二种方法是在区块链中最符合分布式思想的一种，他需要区块链系统中不同的参与者进行合作才能生成伪随机数。具体的算法我们讲解如下：
首先，在随机数生成时，为了能够达到生成随机数的安全特性，我们需要使用密码学的理论来充实我们的概念。首先我们来看 **承诺和打开((Commitment &
Open)**。
在承诺与打开的应用场景下，倘若此处存在两个用户A与B。他们两个人并没有面对面，但是他们想进行一个石头剪刀布的游戏，并决出获胜者。那我们应该怎么做呢？倘若时间不同步，那么一个人就能看到另一个人的情况，这也就意味着他们无法公平的竞争。所以我们要对每个人的结果采取一些措施：
  * 他们先自行做出选择，然后把自己的选择做个哈希；（H(A)、H(B)）
  * 交换这个哈希；
  * 等双方都收到对方的哈希后，再交换双方的选择；
  * 验证对方的选择和之前的哈希一致；
这个过程中也可以添加入自己的公钥以做证据，防止以后反悔。
这样双方都知道了对方的选择，也能确认对方的选择是提前就做好的。
这个哈希值就叫做承诺，因为它里面包含了保密信息，但又没有泄漏保密信息，而最终发送对应的保密信息，就叫做打开承诺。
下面我们讲述一下如何在生产随机数的过程中记录作恶节点并对其进行惩罚。下面我们介绍下秘密共享方案：
秘密共享是说，一个人可以把一个需要保密的信息，拆分成n份，分别发送给n个人，只要恶意节点不超过一定数量，最终大家可以综合各自的信息片段把原始信息还原出来。
并且就算分发者如果作弊，大家也可以检查出来。比如密码共享方案（3，9）即将一个秘密分为九份，然后分配给9个人，只要九份中的三份放在一起就可以恢复出秘密。
例如下面的直接坐标系，我们都知道y = ax
+b直线坐标需要两个点可以确定这个直线。所以我们可以用此方程做(2，n)的共享方案。我们可以在图像上寻找n个点并分发给n个用户，之后倘若有两个用户将点放在一起便可以恢复成直线，也就可以得出b的值。而b的值就是我们隐藏的秘密。
知道了这些，倘若作恶节点不发送随机数的打开方式，那么我们也可以利用合理数量的用户来打开秘密。保证系统的正常运行。如果他想在拆分信息上作弊，大家也能检查出来并把他踢掉。
最后，因为我们本来就是个区块链，所以协议过程中需要广播的信息，我们可以直接写到链上去，
这样可以简化实现，并且也不需要所有投票节点同时在线，并且如果有人作弊，作弊的记录将会永远保存在链上。采取相应的惩罚措施也会使恶意节点收手。
在讲完密码学基础后，我们引用一张图来表示这个过程：
#### 3 公共种子采集生成
在第三种方式，合约采用了公共区块上面的信息进行随机数的seed值，由智能合约根据种子生成伪随机数。这种方法最大的缺陷就是一旦黑客知道了随机数的生成算法，也能获取正确的种子，就能轻易地对智能合约发起随机数攻击。
然而不同于传统的中心化系统，区块链上的信息是所有人都能看到的，区块链上的种子几乎是“透明”的。它是链上的区块信息，所有节点上的智能合约都能够取到，那么从原理上讲，黑客用于攻击的恶意合约同样可以获得这些数值。
下面我们列举几个危险的随机数生成函数”：
    // 如果 block.number 是偶数，则 won 输出为 true。 
    bool won = (block.number % 2) == 0;
在实例中，我们看到使用了`block.number`这个函数。而在我们的实验中，我们可以看到：
    pragma solidity ^0.4.18;
    contract CoinFlip {
      uint256 lastHash;
        function get() view public returns(uint256) {
          lastHash =  uint256(block.blockhash(block.number));
          return lastHash;
        }
    }
    var random = uint(sha3(block.timestamp)) % 2;
除此之外，我们还可以使用困难度进行随机数产生，然而这也是不安全的。
    pragma solidity ^0.4.0;
    contract random{
       function rand() public returns(uint256) {
            uint256 random = uint256(keccak256(block.difficulty,now));
            return  random%10;
        }
    }
由此可见，这种方法也是需要更深刻的进行设计的。当黑客获取到随机数算法后，他就能根据算法的内容进行百分百预测从而进行作恶。
而在我们的的时候发现，许多合约使用了`block.blockhash(block.number)`这个函数作为生成随机数的种子。这是十分危险的。`block.number`
变量可以获取当前区块区块高度。但是还没执行时，这个“当前区块”是一个未来区块，即只有当一个矿工把交易打包并发布时，这个未来区块才变为当前区块，所以合约才可以可靠地获取此区块的区块哈希。
所以这个信息不论怎么运行都只会返回0值。
### 三、参考
  * 
  * 
  * 
  * 
**本稿为原创稿件，转载请标明出处。谢谢。**