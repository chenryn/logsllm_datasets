title:A Robust and Efficient Defense against Use-after-Free Exploits via
Concurrent Pointer Sweeping
author:Daiping Liu and
Mingwei Zhang and
Haining Wang
A Robust and Efficient Defense against Use-after-Free Exploits
via Concurrent Pointer Sweeping
Daiping Liu
University of Delaware
Newark, DE
PI:EMAIL
Mingwei Zhang
Intel Labs
Hillsboro, OR
PI:EMAIL
Haining Wang
University of Delaware
Newark, DE
PI:EMAIL
ABSTRACT
Applications in C/C++ are notoriously prone to memory corrup-
tions. With significant research efforts devoted to this area of study,
the security threats posed by previously popular vulnerabilities,
such as stack and heap overflows, are not as serious as before. In-
stead, we have seen the meteoric rise of attacks exploiting use-after-
free (UaF) vulnerabilities in recent years, which root in pointers
pointing to freed memory (i.e., dangling pointers). Although vari-
ous approaches have been proposed to harden software against UaF,
none of them can achieve robustness and efficiency at the same
time. In this paper, we present a novel defense called pSweeper
to robustly protect against UaF exploits with low overhead, and
pinpoint the root-causes of UaF vulnerabilities with one safe crash.
The success of pSweeper lies in its two unique and innovative de-
sign ideas, concurrent pointer sweeping (CPW) and object origin
tracking (OOT). CPW exploits the increasingly available multi-
cores on modern PCs and outsources the heavyweight security
checks and enforcement to dedicated threads that can run on spare
cores. Specifically, CPW iteratively sweeps all live pointers in a
concurrent thread to find dangling pointers. This design is quite
different from previous work that requires to track every pointer
propagation to maintain accurate point-to relationship between
pointers and objects. OOT can help to pinpoint the root-causes of
UaF by informing developers of how a dangling pointer is created.
We implement a prototype of pSweeper and validate its efficacy
in real scenarios. Our experimental results show that pSweeper is
effective in defeating real-world UaF exploits and efficient when
deployed in production runs.
ACM Reference Format:
Daiping Liu, Mingwei Zhang, and Haining Wang. 2018. A Robust and
Efficient Defense against Use-after-Free Exploits via Concurrent Pointer
Sweeping . In 2018 ACM SIGSAC Conference on Computer and Communi-
cations Security (CCS ’18), October 15–19, 2018, Toronto, ON, Canada. ACM,
New York, NY, USA, 14 pages. https://doi.org/10.1145/3243734.3243826
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
CCS ’18, October 15–19, 2018, Toronto, ON, Canada
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5693-0/18/10...$15.00
https://doi.org/10.1145/3243734.3243826
1 INTRODUCTION
Memory corruption vulnerabilities have plagued software written
in low-level languages like C/C++ for decades. On one hand, effec-
tive defenses against previously popular attacks, such as stack and
heap overflows [16, 20, 22, 23, 25, 33, 39, 42, 47, 50, 59], have been
developed and deployed in commodity systems, making the ex-
ploitation of such memory corruption bugs much harder in system
software (e.g., browser or operating system). On the other hand,
recent years have seen the meteoric rise of memory corruption
attacks exploiting use-after-free (UaF) vulnerabilities that root in
pointers pointing to deallocated memory (i.e., dangling pointers).
Actually, UaF vulnerability has become the largest and severest
on-going exploit vector in numerous popular applications [36].
Different approaches have been proposed to harden the memory
safety of software against UaF vulnerabilities. Most of the existing
solutions attempt to disrupt UaF exploits by making an explicit
[40, 43, 45, 51, 56] or implicit [26] safety check on every pointer
dereference. An alternative approach is to reshape memory allo-
cators to avoid unsafe memory reuse [14, 16, 47]. Conservative
garbage collection [6, 18] heads off UaF exploits through auto-
matic memory management. Moreover, the Silicon Secured Memory
(SSM), recently shipped in Sparc M7 processors, implements tagged
memory as a hardware UaF defense [5]. Recent works [19, 36, 58]
track pointer propagation and nullify dangling pointers at object
free.
Unfortunately, these solutions still suffer two main drawbacks.
First, robustness and efficiency cannot be achieved at the same time.
UaF exploits are guaranteed to be defeated but usually with unac-
ceptable or unpredictable overhead [6, 26, 36, 43, 56, 58]. Systems
like Cling and SSM incur trivial overhead but provide only partial
[14] or probabilistic [5, 16, 47] memory safety. Second, software
developers usually cannot obtain sufficient information about the
exploited UaF vulnerabilities during production runs, making it
difficult to debug and craft patches.
This paper presents pSweeper, a novel defense system that effec-
tively protects against UaF exploits and imposes low overhead for
deployment in production environments, as well as pinpoints the
root-causes of UaF vulnerabilities for easier and faster fixing. The
basic protection principle of pSweeper is to proactively neutralize
dangling pointers so as to disrupt potential UaF exploits, which is
similar to DANGNULL, DangSan, and FreeSentry [36, 54, 58]. How-
ever, very different from those previous solutions, pSweeper has
two unique and innovative features, concurrent pointer sweeping
and object origin tracking, to overcome the above shortcomings.
In order to find and neutralize dangling pointers, existing ap-
proaches [36, 54, 58] synchronously keep track of pointer propaga-
tion at runtime to maintain accurate point-to relationships between
pointers and objects. This design can incur undue overhead, e.g.,
80% in DANGNULL [36]. Leveraging the increasingly available
multi-cores on PCs, pSweeper instead explores a very different
design, concurrent pointer sweeping (CPW), which iteratively
sweeps all live pointers in concurrent threads and neutralizes dan-
gling pointers. Compared to existing work, a major difference and
advantage of this design is that, we only need to check if a pointer
is dangling (i.e., pointing to freed memory) when pSweeper threads
sweep it. In particular, we do not need to know which object a
pointer is pointing to. Thus, there is no need for us to maintain
accurate point-to relationship anymore, which accounts for the
most overhead in previous approaches. In general, using a spare
CPU core, pSweeper can effectively reduce the latency induced by
security checks that are instrumented to applications.
The main challenge of implementing CPW lies in identifying and
efficiently handling entangled races among pSweeper and applica-
tion threads. For example, since pSweeper has to check live pointers
one by one, a dangling pointer may propagate to an already-checked
pointer before being neutralized. pSweeper would provide incom-
plete protection if such races were left unhandled. While most race
conditions can be addressed by using heavyweight synchroniza-
tion mechanisms like locks, it could cause unacceptable overhead
and thus offset the design benefits of CPW. To this end, we devise
several simple and efficient mechanisms to correctly handle these
race conditions, which represent our major technical contributions.
Our key design principle is to place heavyweight workload on
pSweeper threads and instrument as less code as possible to appli-
cation threads. In particular, we leverage hardware features and
lock-free algorithms to avoid stalling application threads whenever
possible.
The remainder of this paper is organized as follows. Section 2
introduces the background of UaF. Section 3 describes the overview
of pSweeper. Section 4 presents the detailed design of pSweeper.
Section 5 empirically evaluates the effectiveness and performance of
pSweeper. Section 6 discusses the limitations of pSweeper. Section
7 surveys related work, and finally, Section 8 concludes the paper.
Another desirable feature that pointer neutralization can pro-
vide is object origin tracking (OOT). When software crashes due
to dangling pointer dereference, OOT can inform us of how the
dangling pointer is caused, i.e., where the pointed object is allocated
and freed. This information can greatly help programmers pinpoint
the root-causes of UaF vulnerabilities. pSweeper achieves OOT by
encoding origin information into neutralized dangling pointers.
Like ASAN [51], pSweeper can pinpoint root-causes of UaF vulner-
abilities in one safe crash. However, pSweeper achieves this at a
trivial cost.
Finally, we implement a prototype of pSweeper and demonstrate
its effectiveness using real-world UaF vulnerabilities. Our evalua-
tion results on SPEC CPU2006 benchmarks show that the induced
overhead is quite low (12.5%∼17.2% compared to around 40% by
state-of-the-art). We demonstrate that pSweeper scales quite well
on multi-thread applications using PARSEC benchmarks. We fur-
ther conduct two case studies with Lighttpd web server and Firefox
browser.
Figure 1: Comparison of CPW with existing solutions [36, 54,
58]. Previous approaches require to maintain complete point-to relationships
between pointers and objects. Whenever a pointer points to a different object,
the point-to relationship must be updated. Instead, CPW in pSweeper only
records live pointers and memory allocation status. In particular, CPW does not
need to know which object a pointer is pointing to or how many different objects
a pointer has pointed to. CPW only needs to check if a pointer is dangling.
2 BACKGROUND AND THREAT MODEL
Dangling Pointer. A pointer variable p is dangling iff an object O
with address range ∀ m, size : [m, m+size-1] has been freed and
p∈[m, m+size-1].
In practice, UaF exploits commonly reuse freed memory and fill
it with specially crafted contents which are then accessed through
dangling pointers. Therefore, it is insufficient to check whether a
pointer points to freed memory. Instead, it is imperative to enforce
that dangling pointers never point to memory that can be arbitrarily
manipulated by attackers.
Threat Model. This paper focuses on UaF vulnerabilities rooted
in dangling pointers which can point to any memory region in-
cluding heap, stack, code and data. The attacker can crash applica-
tions but cannot cause any other consequences. Spatial attacks that
exploit out-of-bound writes like buffer overflows, and temporal
attacks that exploit uninitialized reads, are out of our scope. There-
fore, similar to related works [36, 54, 58], we do not protect our
system from these vulnerabilities and it should be used along with
orthogonal protectors. We also assume applications do not have
concurrency bugs. Finally, we do not deal with undefined behaviors,
such as delete objects created using new[].
3 OVERVIEW
3.1 High-Level Approach of pSweeper
pSweeper aims to robustly protect against UaF exploits with low
overhead and pinpoint the root-causes of UaF vulnerabilities being
exploited in the wild. To accomplish these, pSweeper proposes
Concurrent Pointer Sweeping (CPW) and Object Origin Tracking
(OOT). pSweeper follows a similar protection principle to pointer
nullification in DANGNULL [36], FreeSentry [58] and DangSan
[54]. In particular, when an object is freed, all dangling pointers
are neutralized to disrupt UaF exploits. However, pSweeper differs
significantly in two key design aspects:
1. How to find dangling pointers; and
2. What value is used to neutralize dangling pointers.
&(B->s)Point-to[A]Point-to[B]&(A->p)Point-to[C]&(A->r)&(B->q)Point-to Relationships:Updated upon each pointer propagation instruction at runtimeSource CodeExisting WorkA = malloc()B = malloc()C = malloc()A->p = &(B->data)A->r = &(C->pfunc)B->q = &(C->buf)B->s = &(A->req)free(C)CPW&(B->s)&(A->r)&(A->p)Live PointersMemory Allocation Statusfreedallocated&(B->q)allocatedConcurrent pSweeper ThreadsFinding Dangling Pointers. Previous approaches [36, 54, 58]
synchronously maintain accurate point-to relationships between
pointers and objects at runtime, so that when an object is freed,
they can locate the set of pointers that are still pointing to the
freed object and nullify them. In such a design, for each pointer
propagation instruction, they need to track (1) in which object this
pointer is located and (2) which object this pointer is pointing to.
Since a pointer can point to the middle of an object, both operations
require range-based searches that are notoriously expensive. Even
worse, synchronization mechanisms like locks should be used in
several places to avoid races among application threads [36].
We propose CPW, a totally different design. The key feature of
CPW is to decouple the search for dangling pointers from applica-
tion code. Specifically, CPW iteratively sweeps all live pointers at
runtime in concurrent threads to neutralize the dangling pointers.
Since pSweeper scans every pointer at runtime to find dangling
pointers, there is no need to maintain complete point-to relation-
ships anymore. Figure 1 illustrates the differences between CPW
and previous solutions [36, 54, 58]. Note that, in principle, pSweeper
does not improve the performance of individual security checks.
Instead, pSweeper leverages spare CPU cores to reduce the latency
of security checks that are instrumented into applications, and it
may consume more CPU resources than DANGNULL, FreeSentry,
and DangSan.
Since pSweeper works in a concurrent manner, a freed mem-
ory block may get re-allocated before pSweeper has eliminated
current dangling pointers. This may cause two problems. First,
UaF vulnerability exists in the time window between memory free
and pSweeper’s dangling point neutralization, which could be ex-
ploited by attackers to hijack control flow or escalate privileges
after gaining the control of the re-allocated memory block. Sec-
ond, once a memory block is reused, it becomes impossible for
pSweeper to precisely find all dangling pointers. To prevent the
occurrence of UaF vulnerable windows and avoid missing dangling
pointers, CPW defers object frees to the end of every round of
sweeping. Therefore, for each object, CPW introduces a grace pe-
riod Tдr ace = [Tissue ,Tr elease], where Tissue is when application
code issues a free request and Tr elease is the actual time when
CPW releases the memory back to OS.
Choosing Value for Pointer Neutralization. Previous works
[36, 54, 58] simply set dangling pointers to NULL or kernel space.
This guarantees that applications crash safely when dangling point-
ers are accessed.
pSweeper instead specially crafts the values to neutralize dan-
gling pointers. Our key insight is that the crucial information to pin-
point root-causes of UaF vulnerabilities is how a dangling pointer is
caused, i.e., how the pointed object is allocated and freed. Therefore,
besides enforcing safe crash upon dangling pointer dereference,
pSweeper also encodes object origin information into dangling
pointers to achieve OOT. Compared with other tools that provide a
similar feature to OOT [48, 51], pSweeper is more efficient.
Enforced Protection Protocol. Building upon CPW and OOT,
pSweeper will enforce the runtime protection protocol as follows.
Given a dangling pointer p:
• If p is accessed before being neutralized, applications con-
tinue to execute correctly similar to conservative garbage
Figure 2: Illustration of pSweeper in time line.
collection [31], because memory free requests are deferred
by pSweeper.
• If p is accessed after being neutralized, applications abort
safely with object origin information dumped.
3.2 An Illustration Example
Figure 2 illustrates pSweeper with an example in time line. All
malloc(), free(), and assignment instructions are executed in
application threads. Ri and ∆Ri denote the start and end of the ith
sweeping round of pSweeper threads, respectively.
Assume the application executes three malloc() and one pointer
assignment before ∆Ri−1. From these instructions, pSweeper iden-
tifies four live pointers, p, r, q, and s at runtime.
During the interval of sweeping rounds, i.e., between ∆Ri−1
and Ri, an application thread invokes free(q). However, this free
request will be hooked by pSweeper and delayed to the end of ith
sweeping round. During the ith sweeping round, pSweeper checks
all four pointers to find and neutralize the dangling one q. At ∆Ri,
the delayed free(q) gets executed. If another memory block p is
freed during the ith round, it will be delayed to ∆Ri +1.
While the overall approach sounds simple, it is non-trivial to
efficiently handle the entangled races among pSweeper and applica-
tion threads. For instance, during the ith sweeping round, assume
pSweeper has checked p and r but has not neutralized q. It is possi-
ble that an application thread propagates the dangling pointer to a
swept one, e.g., executing r = q. pSweeper must efficiently handle
such cases.
3.3 Architecture of pSweeper
To implement CPW and OOT, pSweeper combines compile-time
instrumentation and a runtime library, as shown in Figure 3. There
are three components in pSweeper:
Pointer address identification. pSweeper first statically iden-
tifies pointer variables so that pointer addresses can be located at
runtime (§4.2). It achieves this by analyzing the types of local/global
variables. For pointers in dynamically allocated objects (on heap),
we adopt the same strategy as previous work [36, 54, 58]. Specifi-
cally, we rely on the types of operands in store instructions. For
each pointer store instruction, a snippet of code is instrumented
into applications, which will bookmark live pointers at runtime.
Concurrent pointer sweeping thread. At runtime, dedicated
pSweeper threads iteratively sweep all live pointers and neutralize
free(q)free(p)△Ri-1△RiRiRi+1ithsweeping roundtimelinep = malloc(…)r= pq = malloc(...)s = malloc(...) live pointers△Ri+1 (i+1)throundd_free(q)d_free(p)deferred todeferred toGrace period of free(p)Since several components of pSweeper rely on the APIs in Table
1, the efficiency of these APIs is critical to the performance of
pSweeper. We now describe how these APIs are implemented. A
straightforward way is to check against the list of live objects
and pointers. However, for isFreed(), this simple implementation
runs in time complexity of O(P ∗ M) for isFreed() and O(P) for
isPointer(), where P and M denote the number of live pointers
and the number of freed objects, respectively. Obviously, this naive
implementation does not scale well.
To this end, we design a memory allocation status (MAS) table,
which is a shadow heap similar to the design philosophy in previous
work [34, 39, 42, 54, 55]. The MAS table is built on the fact that
pSweeper only needs to know if a memory address is allocated or
freed, and it does not need to know where the object boundaries are.
Every byte in the MAS table records whether the corresponding
byte on heap is allocated. As a result, pSweeper can achieve a fast