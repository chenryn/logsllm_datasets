title:Convicting exploitable software vulnerabilities: An efficient input
provenance based approach
author:Zhiqiang Lin and
Xiangyu Zhang and
Dongyan Xu
Convicting Exploitable Software Vulnerabilities: An Efﬁcient Input Provenance
Based Approach
Zhiqiang Lin Xiangyu Zhang Dongyan Xu
Department of Computer Sciences and CERIAS
Purdue University
{zlin, xyzhang, dxu}@cs.purdue.edu
Abstract
Software vulnerabilities are the root cause of a wide
range of attacks. Existing vulnerability scanning tools are
able to produce a set of suspects. However, they often suffer
from a high false positive rate. Convicting a suspect and
vindicating false positives are mostly a highly demanding
manual process, requiring a certain level of understanding
of the software. This limitation signiﬁcantly thwarts the ap-
plication of these tools by system administrators or regular
users who are concerned about security but lack of under-
standing of, or even access to, the source code. It is often the
case that even developers are reluctant to inspect/ﬁx these
numerous suspects unless they are convicted by evidence.
In this paper, we propose a lightweight dynamic approach
which generates evidence for various security vulnerabili-
ties in software, with the goal of relieving the manual pro-
cedure.
It is based on data lineage tracing, a technique
that associates each execution point precisely with a set of
relevant input values. These input values can be mutated
by an ofﬂine analysis to generate exploits. We overcome
the efﬁciency challenge by using Binary Decision Diagrams
(BDD). Our tool successfully generates exploits for all the
known vulnerabilities we studied. We also use it to uncover
a number of new vulnerabilities, proved by evidence.
1 Introduction
Vulnerabilities in software, especially those that are re-
mote exploitable, are the root cause of wave after wave
of security attacks, such as botnet, zero-day worms, non-
control data corruptions, and even server-break-ins. Thus,
analyzing and exposing software vulnerabilities has become
one of the most active research areas today.
In the past, software vulnerability detection/exposing ap-
proaches could be divided into two categories: dynamic
and static. Dynamic approaches monitor program execution
and detect attempts of attacking a software system. Many
promising approaches have been proposed in this category,
such as TaintCheck [15], Control Flow Integrity [16], and
Data Flow Integrity [17]. However, most of these tech-
niques are often active during program execution, thereby
incurring non-trivial runtime overhead. Moreover, they aim
to detect attacks, and thus vulnerabilities that are not under
attack are invisible.
The second type of approaches are static analysis, and
notable examples include BOON [18], Splint [19], and
Archer [21]. Static analysis is not bound to execution and
thus often capable of identifying potential vulnerabilities
in a program, and also it imposes no overhead at runtime.
Thus, these techniques are more desirable compared with
dynamic approaches if they can live to their promise. Un-
fortunately, most static techniques suffer from a high false-
positive rate and generate a large volume of warnings. For
example, the static analysis tool Splint has nearly 50% false
positive [20], and tools like Flawﬁnder [1] and RATS [2]
often produce hundreds of warnings, in which only a few
of them are the real defects. The procedure of convict-
ing real defects and vindicating false positives remains a
highly demanding manual effort, requiring understanding
of the source code. With respect to system administrators
and regular software users who are concerned about secu-
rity, the lack of the understanding of (even the access to)
source code signiﬁcantly diminishes their enthusiasm about
these techniques. With respect to developers, a long list of
suspects with only some being true rapidly wears out their
patience. Therefore, it becomes a pressing need to develop
new techniques to automatically or semiautomatically gen-
erate evidence to convict real vulnerabilities.
Random test generation (e.g., fuzz testing [7, 8]) that ran-
domly mutates benign inputs has been used to construct
exploits. However, it is known that random test genera-
it might take 232
tion is not effective in many cases, e.g.
tries to satisfy a simple predicate as “P1:if (x==c)”
because x is a 32 bit random value. Thus, recently, there
has been signiﬁcant advance in combining static software
veriﬁcation principles with symbolic execution in test gen-
eration to identify software errors including vulnerabilities
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:15:55 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 20081-4244-2398-9/08/$20.00 ©2008 IEEE247DSN 2008: Lin et al.[9, 11, 10, 12, 13, 14]. These techniques aim to explore all
feasible program paths to expose potential defects. Such an
ambitious goal with symbolic execution incurs scalability
issues. For instance, using symbolic execution an execution
taking the true branch of P1 is modeled by the constraint
of C1:x==c. The technique tries to mutate a benign ex-
ecution through negating constraints and resolve them by
a solver, e.g., solving the negated constraint ¬C1 provides
a new input value satisfying x!=c, which drives the exe-
cution to take the false branch of P1. The state of the art
[13] is capable of handling hundreds of millions of instruc-
tions, which only accounts for a few seconds of execution.
Furthermore, it often requires the user to annotate symbolic
variables (e.g., EXE [9]), which implies understanding of
program semantics.
In this paper, we propose a practical dynamic approach
that is intended to use in combination with other static tools.
We observe that although the suspect pool produced by ex-
isting static tools has a high false positive rate, it is nonethe-
less much smaller than the whole population. Therefore, we
use existing static tools as the frontend to generate a set of
suspects. Our technique then tries to generate exploits for
these suspects. A suspect is convicted only when an exploit
can be acquired as the evidence. Such exploits signiﬁcantly
assist regular users and administrators to evaluate the ro-
bustness of their software and convince vendors to debug
and patch. The key idea is to use data lineage tracing to
identify a set of input values relevant to the execution of
a vulnerable code location. Exploit-speciﬁc mutations are
applied to the relevant input values in order to trigger an at-
tack, for example, changing an integer value to MAXUINT
to induce an integer overﬂow. Since these inputs are usually
a very small subset of the whole input sequence, mutating
the whole input, like in random test generation, is avoided.
Our technique does not rely on symbolic execution and con-
straint solving and thus can easily handle long execution.
In case an execution that covers a vulnerable code location
cannot be found, our tool also allows user interactions to
mutate an input so that the execution driven by the mutated
input covers the vulnerable code location.
Our technique addresses a wide range of vulnerabilities
including buffer overﬂow, integer overﬂow, format string,
etc. Our dynamic analysis works at binary level, which
greatly facilitates users who do not have the source code ac-
cess but are concerned about software vulnerabilities. Note
that a static analysis used as a frontend may or may not re-
quire source code access. Using our system, we are able
to reproduce exploits of all the known vulnerabilities we
studied. We also successfully identify a set of new vulnera-
bilities and prove them by evidence. They were all promptly
conﬁrmed by the developers.
The contributions of our paper are highlighted as fol-
lows.
• We propose a novel dynamic technique which gener-
ates evidence to convict a wide range of real vulnera-
bilities. Compared with the state of the art of test gen-
eration techniques [9, 10, 11], it is less expensive. The
output of our tool is a runnable program input to the
whole software system instead of a module, and such
an input can be easily turned into an exploit.
• The technique is built upon a dynamic program anal-
ysis called data lineage tracing.
It traces the set of
input that is relevant to a particular execution point.
The lineage information is used to guide our evidence
generation procedure. The challenge of efﬁciency is
overcome by using reduced ordered Binary Decision
Diagrams (roBDDs).
• Data lineage on its own is not sufﬁcient in producing
evidence. We design a search algorithm that makes
use of lineage information and looks for a mutation
of a benign program input that triggers a suspicious
vulnerability.
• We apply our technique on a set of real software ap-
plications and our results show that we are able to re-
produce all the known vulnerabilities that we collected
for our experiment. Our case study also presents the
effectiveness of our tool by convicting suspects which
have not been brought to “justice” before.
• Our performance evaluation indicates that our tech-
nique has reasonable overhead.
2 Overview
Figure 1. System Overview.
The overview of our system is presented in Figure 1. It
consists of four components with the shaded ones being our
contributions. The system relies on static analysis to pro-
duce a set of suspects, which are potential vulnerable code,
represented in the forms of instruction addresses at binary
level or source code locations. Benign program inputs are
needed to begin with, which may come from a random test
case generator or from the test suite shipped with the soft-
ware. Provided with a program input and a suspect, the
data lineage tracing component computes lineage for the
execution. This information is consumed by the input muta-
tion component that searches for a way to mutate the previ-
ous program input such that the vulnerability is manifested
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:15:55 UTC from IEEE Xplore.  Restrictions apply. 
Static FrontendData Lineage TracerInput MutatorexploitinputRuntime Detectormutated inputbenign inputsinput,data lineagesuspectsprogram/binaryfailedmutated inputInternational Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 20081-4244-2398-9/08/$20.00 ©2008 IEEE248DSN 2008: Lin et al.through a crash. We call such a mutated input an exploit
in the paper. Note that how to add payload to the crash-
inducing input to gain control of the host program is be-
yond the scope of this paper. The runtime detector is to
check if the vulnerability is triggered. If so, the suspect is
convicted. Otherwise, the suspect is considered innocent.
Since the runtime detector is not our focus, we simply use a
segmentation fault detector. More advanced detectors such
as TaintCheck [15] can be adopted for higher accuracy.
Our technique does not rely on a speciﬁc static analysis
tool, which provides ﬂexibility to the system. More specif-
ically, it can be easily shaped into a system handling buffer
overﬂow, format string, integer overﬂow, or other attacks,
depending on the frontend analysis. Although the static and
runtime detectors may need source code, our lineage tracing
and input mutation components only require binary. The
precision of the static analysis is not a major concern as
well. For example, the user may choose to subject all buffer
accesses to the conviction procedure.
Figure 2. An Illustrative Example.
Next we use a real example to demonstrate the working
of our system. Figure 2 shows one of the integer overﬂow
vulnerabilities in CVE-2004-0994. By providing a mali-
cious gif ﬁle header, remote attackers can exploit the inte-
ger overﬂow at line 494 and eventually launch a heap over-
ﬂow attack.
In our system, suppose static analysis tools are able to
point out that there is an overﬂow suspect at line 494. Note
that many static tools can generate such warnings. Now
given a benign test input (in this case, any gif ﬁle input
touches line 494), a normal gif image with the size of
256 × 128, our system traces the lineage of the execution
of line 494 and identiﬁes that the value of width comes
from “0x00 0x01”, and the value of height comes
from “0x80 0x00”, as shown in the ﬁgure. Our mutation
algorithm eventually ﬁnds that replacing these input values
with large numbers triggers this integer overﬂow vulnera-
bility. Such a mutated input is provided as the evidence for
the conviction.
In order to realize the idea, we have to overcome several
technical challenges such as scalable lineage tracing, input
mutation, and test generation to cover suspects. In the next
two sections, we will present our solutions to these issues.
3 Data Lineage Tracing
The ﬁrst problem that confronts us is to identify the set of
input values that are relevant to a particular execution point.
Although one can say that all the inputs are related to each
point of execution in general, we observe that given a par-
ticular execution point, part of the inputs are much more
closely related than others. A more formal deﬁnition of
“closely related” will be given in later discussion, but in-
tuitive examples can be found in Figure 2. As we can see
from this ﬁgure, the binary strings in the rectangles have
one-one mappings to the values at line 494. The code ex-
cerpt clearly explains how the input values are propagated
to line 4941.
Next, let us formalize our deﬁnition of data lineage. The
deﬁnition is based on the concept of data dependence in the
ﬁeld of program slicing [23]. Given a program execution
E, si denotes the ith execution instance of a statement s.
Note that a statement can be executed multiple times in one
execution.
Deﬁnition 1 A statement execution instance si data de-
pends on another statement execution instance tj if and
only if a variable is deﬁned at tj and then used at si.
For example in Figure 2, assuming all the statements ex-
ecute only once, 4941, the ﬁrst instance of statement 494,
data depends on 2451 and 2461.
Deﬁnition 2 The data lineage of a variable v at an execu-
tion point of si, denoted as DL(v@si), is the set of input
bytes that are directly or indirectly involved in computation
of the value of v at si through data dependence.
In some places of this paper, we also use DL(si) to de-
note the data lineage of the statement instance si. For exam-
ple, DL(width@4941) = {6, 7}, with the numbers denot-
ing the values’ indices in the input sequence2. DL(4941) =
{6, 7, 8, 9}. One may raise the question whether control
dependence [22] needs to be considered. Our experience
shows that simply including control dependence in lineage
computation often leads to undesirably oversized lineage
sets. Therefore we consider control dependence in the
search procedure for mutation (Section 4) instead of in lin-
eage computation. In practice, our strategy is sufﬁcient for
the cases we studied.
Given the deﬁnition, we develop a run-time algorithm to
compute data lineage. The basic rule is that the set of input
elements relevant to a statement instance si is the union of
the relevant input sets of all the statement instances which
1Note that although we present the example in its source code form for
readability, our analysis works directly on binary.
2We store the input sequence into a global buffer so that input values
can be indexed and accessed.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:15:55 UTC from IEEE Xplore.  Restrictions apply. 
fread(&imagehed,sizeof(imagehed),1,in);...width=(imagehed.wide_lo+256*imagehed.wide_hi)height=(imagehed.high_lo+256*imagehed.high_hi);...if((...(byte *)malloc(width*height))...) {       fclose(in);       return(_PICERR_NOMEM);  }  ...2312452464944954964974986789offset=International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 20081-4244-2398-9/08/$20.00 ©2008 IEEE249DSN 2008: Lin et al.si data depends on. In other words, all the input values that
are relevant to some operand of si are considered as relevant
to si as well.
For the simplicity of explanation, let
si : def = f(use0, use1, ..., usen)
be an executed statement instance, in which si deﬁnes vari-
able def by using the variables of use0,use1, ..., and
usen.
For example, the statement instance 2451 can be repre-
sented as
2451 : width = f (imagehed.wide lo, imagehed.wide hi)
Let DEF (x) be the latest statement instance that deﬁnes
variable x. The computation of data lineage can be repre-
sented by the following equations:
DL(si) = DL(def@si)
get new id()
if def is an input value;
(5∀x
= (
&
DL(def@si) =
DL(usex@si)
∀x.DEF (usex)(cid:54)=φ
otherwise.
5
DL(usex@DEF (usex))
(1)
As shown by the equations, the lineage of si is equiva-
lent to the lineage of the variable def deﬁned at si. If def
is considered as an input, function get new id() is called
to assign a unique id for the input instance.
If def does
not represent an input value, its lineage is computed as the
union of the lineage sets of usexs. If a variable usex was
previously deﬁned,
DL(usex@si) = DL(usex@DEF (usex)).