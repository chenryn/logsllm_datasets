'Zoph'
第4章 列表
>>> 'Zo' in name
True
>>> 'z' in name
False
>>> 'p' not in name
False
>>> for i in name:
print('* * * ' + i + ' * * *')
* * * Z * * *
* * * o * * *
* * * p * * *
* * * h * * *
* * * i * * *
* * * e * * *
4.6.1 可变和不可变数据类型
但列表和字符串在一个重要的方面是不同的。列表是“可变的”数据类型，它
的值可以添加、删除或改变。但是，字符串是“不可变的”，它不能被更改。尝试
对字符串中的一个字符重新赋值，将导致 TypeError 错误。在交互式环境中输入以
下代码，你就会看到：
>>> name = 'Zophie a cat'
>>> name[7] = 'the'
Traceback (most recent call last):
File "", line 1, in 
name[7] = 'the'
TypeError: 'str' object does not support item assignment
“改变”一个字符串的正确方式，是使用切片和连接。构造一个“新的”字符
串，从老的字符串那里复制一些部分。在交互式环境中输入以下代码：
>>> name = 'Zophie a cat'
>>> newName = name[0:7] + 'the' + name[8:12]
>>> name
'Zophie a cat'
>>> newName
'Zophie the cat'
我们用[0:7]和[8:12]来指那些不想替换的字符。请注意，原来的'Zophie a cat'字
符串没有被修改，因为字符串是不可变的。尽管列表值是可变的，但下面代码中的
第二行并没有修改列表eggs：
>>> eggs = [1, 2, 3]
>>> eggs = [4, 5, 6]
>>> eggs
[4, 5, 6]
这里eggs中的列表值并没有改变，而是整个新的不同的列表值([4, 5, 6])，覆写
了老的列表值。如图4-2所示。
Python编程快速上手——让繁琐工作自动化
图4-2 当eggs = [4, 5, 6]被执行时，eggs的内容被新的列表值取代
如果你确实希望修改eggs中原来的列表，让它包含[4, 5, 6]，就要这样做：
>>> eggs = [1, 2, 3]
>>> del eggs[2]
>>> del eggs[1]
>>> del eggs[0]
>>> eggs.append(4)
>>> eggs.append(5)
>>> eggs.append(6)
>>> eggs
[4, 5, 6]
在第一个例子中，eggs最后的列表值与它开始的列表值是一样的。只是这个列
表被改变了，而不是被覆写。图4-3展示了前面交互式脚本的例子中，前7行代码
所做的7次改动。
图4-3 del语句和append()方法当场修改了同一个列表值
改变一个可变数据类型的值（就像前面例子中 del 语句和 append()方法所做的
事），当场改变了该值，因为该变量的值没有被一个新的列表值取代。
区分可变与不可变类型，似乎没有什么意义，但4.7.1节“传递引用”将解释，
使用可变参数和不可变参数调用函数时产生的不同行为。首先，让我们来看看元组
数据类型，它是列表数据类型的不可变形式。
4.6.2 元组数据类型
除了两个方面，“元组”数据类型几乎与列表数据类型一样。首先，元组输入
第4章 列表
时用圆括号()，而不是用方括号[]。例如，在交互式环境中输入以下代码：
>>> eggs = ('hello', 42, 0.5)
>>> eggs[0]
'hello'
>>> eggs[1:3]
(42, 0.5)
>>> len(eggs)
3
但元组与列表的主要区别还在于，元组像字符串一样，是不可变的。元组不能
让它们的值被修改、添加或删除。在交互式环境中输入以下代码，注意 TypeError
出错信息：
>>> eggs = ('hello', 42, 0.5)
>>> eggs[1] = 99
Traceback (most recent call last):
File "", line 1, in 
eggs[1] = 99
TypeError: 'tuple' object does not support item assignment
如果元组中只有一个值，你可以在括号内该值的后面跟上一个逗号，表明这种
情况。否则，Python 将认为，你只是在一个普通括号内输入了一个值。逗号告诉
Python，这是一个元组（不像其他编程语言，Python接受列表或元组中最后表项后
面跟的逗号）。在交互式环境中，输入以下的type()函数调用，看看它们的区别：
>>> type(('hello',))
>>> type(('hello'))
你可以用元组告诉所有读代码的人，你不打算改变这个序列的值。如果需要一
个永远不会改变的值的序列，就使用元组。使用元组而不是列表的第二个好处在于，
因为它们是不可变的，它们的内容不会变化，Python可以实现一些优化，让使用元
组的代码比使用列表的代码更快。
4.6.3 用list()和tuple()函数来转换类型
正如str(42)将返回'42'，即整数42的字符串表示形式，函数list()和tuple()将返
回传递给它们的值的列表和元组版本。在交互式环境中输入以下代码，注意返回值
与传入值是不同的数据类型：
>>> tuple(['cat', 'dog', 5])
('cat', 'dog', 5)
>>> list(('cat', 'dog', 5))
['cat', 'dog', 5]
>>> list('hello')
['h', 'e', 'l', 'l', 'o']
如果需要元组值的一个可变版本，将元组转换成列表就很方便。
Python编程快速上手——让繁琐工作自动化
4.7 引用
正如你看到的，变量保存字符串和整数值。在交互式环境中输入以下代码：
>>> spam = 42
>>> cheese = spam
>>> spam = 100
>>> spam
100
>>> cheese
42
你将 42赋给 spam变量，然后拷贝 spam中的值，将它赋给变量 cheese。当稍
后将spam中的值改变为100时，这不会影响cheese中的值。这是因为spam和cheese
是不同的变量，保存了不同的值。
但列表不是这样的。当你将列表赋给一个变量时，实际上是将列表的“引用”
赋给了该变量。引用是一个值，指向某些数据。列表引用是指向一个列表的值。这
里有一些代码，让这个概念更容易理解。在交互式环境中输入以下代码：
 >>> spam = [0, 1, 2, 3, 4, 5]
 >>> cheese = spam
 >>> cheese[1] = 'Hello!'
>>> spam
[0, 'Hello!', 2, 3, 4, 5]
>>> cheese
[ 0, 'Hello!', 2, 3, 4, 5]
这可能让你感到奇怪。代码只改变了cheese列表，但似乎cheese和spam列表
同时发生了改变。
当创建列表时，你将对它的引用赋给了变量。但下一行只是将spam中的列
表引用拷贝到cheese，而不是列表值本身。这意味着存储在spam和cheese中的值，
现在指向了同一个列表。底下只有一个列表，因为列表本身实际从未复制。所以当
你修改cheese变量的第一个元素时，也修改了spam指向的同一个列表。
记住，变量就像包含着值的盒子。本章前面的图显示列表在盒子中，这并不准
确，因为列表变量实际上没有包含列表，而是包含了对列表的“引用”（这些引用
包含一些 ID 数字，Python 在内部使用这些 ID，但是你可以忽略）。利用盒子作为
变量的隐喻，图4-4展示了列表被赋给spam变量时发生的情形。
图4-4 spam = [0, 1, 2, 3, 4, 5]保存了对列表的引用，而非实际列表
第4章 列表
然后，在图4-5中，spam中的引用被复制给cheese。只有新的引用被创建并保
存在cheese中，而非新的列表。请注意，两个引用都指向同一个列表。
图4-5 spam = cheese复制了引用，而非列表
当你改变 cheese 指向的列表时，spam 指向的列表也发生了改变，因为 cheese
和spam都指向同一个列表，如图4-6所示。
图4-6 cheese[1] = 'Hello!'修改了两个变量指向的列表
变量包含对列表值的引用，而不是列表值本身。但对于字符串和整数值，变量
就包含了字符串或整数值。在变量必须保存可变数据类型的值时，例如列表或字典，
Python就使用引用。对于不可变的数据类型的值，例如字符串、整型或元组，Python
变量就保存值本身。
虽然 Python 变量在技术上包含了对列表或字典值的引用，但人们通常随意地
说，该变量包含了列表或字典。
4.7.1 传递引用
要理解参数如何传递给函数，引用就特别重要。当函数被调用时，参数的值被
复制给变元。对于列表（以及字典，我将在下一章中讨论），这意味着变元得到的
是引用的拷贝。要看看这导致的后果，请打开一个新的文件编辑器窗口，输入以下
代码，并保存为passingReference.py：
def eggs(someParameter):
someParameter.append('Hello')
spam = [1, 2, 3]
Python编程快速上手——让繁琐工作自动化
eggs(spam)
print(spam)
请注意，当eggs()被调用时，没有使用返回值来为spam赋新值。相反，它直接
当场修改了该列表。在运行时，该程序产生输出如下：
[1, 2, 3, 'Hello']
尽管spam和someParameter包含了不同的引用，但它们都指向相同的列表。这就是
为什么函数内的append('Hello')方法调用在函数调用返回后，仍然会对该列表产生影响。
请记住这种行为：如果忘了Python处理列表和字典变量时采用这种方式，可能
会导致令人困惑的缺陷。
4.7.2 copy 模块的copy()和deepcopy()函数
在处理列表和字典时，尽管传递引用常常是最方便的方法，但如果函数修改了
传入的列表或字典，你可能不希望这些变动影响原来的列表或字典。要做到这一点，
Python 提供了名为 copy 的模块，其中包含 copy()和 deepcopy()函数。第一个函数
copy.copy()，可以用来复制列表或字典这样的可变值，而不只是复制引用。在交互
式环境中输入以下代码：
>>> import copy
>>> spam = ['A', 'B', 'C', 'D']
>>> cheese = copy.copy(spam)
>>> cheese[1] = 42
>>> spam
['A', 'B', 'C', 'D']
>>> cheese
['A', 42, 'C', 'D']
现在spam和cheese变量指向独立的列表，这就是为什么当你将42赋给下标7
时，只有 cheese 中的列表被改变。在图 4-7 中可以看到，两个变量的引用 ID 数字
不再一样，因为它们指向了独立的列表。
图4-7 cheese = copy.copy(spam)创建了第二个列表，能独立于第一个列表修改
如果要复制的列表中包含了列表，那就使用 copy.deepcopy()函数来代替。
第4章 列表
deepcopy()函数将同时复制它们内部的列表。
4.8 小结
列表是有用的数据类型，因为它们让你写代码处理一组可以修改的值，同时仅
用一个变量。在本书后面的章节中，你会看到一些程序利用列表来完成工作。没有
列表，这些工作很困难，甚至不可能完成。
列表是可变的，这意味着它们的内容可以改变。元组和字符串虽然在某些方面
像列表，却是不可变的，不能被修改。包含一个元组或字符串的变量，可以被一个
新的元组或字符串覆写，但这和现场修改原来的值不是一回事，不像 append()和
remove()方法在列表上的效果。
变量不直接保存列表值，它们保存对列表的“引用”。在复制变量或将列表作
为函数调用的参数时，这一点很重要。因为被复制的只是列表引用，所以要注意，
对该列表的所有改动都可能影响到程序中的其他变量。如果需要对一个变量中的列
表修改，同时不修改原来的列表，就可以用copy()或deepcopy()。
4.9 习题
1．什么是[]？
2．如何将'hello'赋给列表的第三个值，而列表保存在名为spam的变量中？（假
定变量包含[2, 4, 6, 8, 10]）。