[22] Jean-Charles Faugère, Christopher Goyet, and Guénaël
Renault. Attacking (EC)DSA Given Only an Implicit
In Selected Areas in Cryptography – SAC’12,
Hint.
volume 7707 of LNCS, pages 252–274. Springer, 2012.
[23] Cesar Pereida García and Billy Bob Brumley. Constant-
Time Callees with Variable-Time Callers. In USENIX
Security’17, pages 83–98. USENIX Association, 2017.
[24] Cesar Pereida García, Billy Bob Brumley, and Yuval
Yarom. "Make Sure DSA Signing Exponentiations Re-
ally are Constant-Time". In Conference on Computer
and Communications Security – CCS’16, pages 1639–
1650. ACM, 2016.
[25] Iaroslav Gridin, Cesar Pereida García, Nicola Tuveri,
and Billy Bob Brumley. Triggerﬂow: Regression Testing
by Advanced Execution Path Inspection. In Detection
of Intrusions and Malware & Vulnerability Assessment
– DIMVA’19, volume 11543 of LNCS, pages 330–350.
Springer, 2019.
[26] Martin Hlavác and Tomás Rosa. Extended Hidden Num-
ber Problem and Its Cryptanalytic Applications. In Se-
lected Areas in Cryptography – SAC’06, volume 4356
of LNCS, pages 114–133. Springer, 2006.
[27] Nick Howgrave-Graham and Nigel P. Smart. Lattice
Attacks on Digital Signature Schemes. Des. Codes
Cryptography, 23:283–290, 2001.
[28] Simon Josefsson and Ilari Liusvaara. Edwards-Curve
Digital Signature Algorithm (EdDSA), 2017. Request
for Comments: 8032.
[29] Cameron F Kerry and Patrick D Gallagher. Digital
signature standard (DSS); FIPS pub 186-4. Information
Technology Laboratory, National Institute of Standards
and Technology: Gaithersburg, MD, USA, 2013.
[30] Paul C. Kocher. Timing Attacks on Implementations
of Difﬁe-Hellman, RSA, DSS, and Other Systems. In
Advances in Cryptology – CRYPTO’96, volume 1109 of
LNCS, pages 104–113. Springer, 1996.
[31] Boris Köpf, Laurent Mauborgne, and Martín Ochoa.
Automatic Quantiﬁcation of Cache Side-Channels. In
Computer Aided Veriﬁcation – CAV’12, volume 7358 of
LNCS, pages 564–580. Springer, 2012.
[32] Adam Langley. ctgrind: Checking that Functions are
Constant Time with Valgrind. https://github.com/
agl/ctgrind.
[33] Arjen Klaas Lenstra, Hendrik Willem Lenstra, and Lás-
zló Lovász. Factoring polynomials with rational co-
efﬁcients. Mathematische Annalen, 261(4):515–534,
1982.
USENIX Association
29th USENIX Security Symposium    1781
[34] Fangfei Liu, Yuval Yarom, Qian Ge, Gernot Heiser, and
Ruby B. Lee. Last-Level Cache Side-Channel Attacks
are Practical. In Security and Privacy – S&P’15, pages
605–622. IEEE Computer Society, 2015.
[46] Keegan Ryan. Return of the Hidden Number Prob-
lem. A Widespread and Novel Key Extraction Attack
on ECDSA and DSA. IACR Trans. Cryptogr. Hardw.
Embed. Syst., 2019:146–168, 2019.
[35] Elke De Mulder, Michael Hutter, Mark E. Marson, and
Peter Pearson. Using Bleichenbacher"s Solution to the
Hidden Number Problem to Attack Nonce Leaks in 384-
Bit ECDSA. In Cryptographic Hardware and Embed-
ded Systems – CHES’13, volume 8086 of LNCS, pages
435–452. Springer, 2013.
[36] Elke De Mulder, Michael Hutter, Mark E. Marson, and
Peter Pearson. Using Bleichenbacher’s solution to the
hidden number problem to attack nonce leaks in 384-bit
ECDSA: extended version. J. Cryptographic Engineer-
ing, 4:33–45, 2014.
[37] David Naccache, Phong Q. Nguyen, Michael Tunstall,
and Claire Whelan. Experimenting with Faults, Lattices
and the DSA. In Public Key Cryptography – PKC’05,
volume 3386 of LNCS, pages 16–28. Springer, 2005.
[38] Phong Q. Nguyen and Igor E. Shparlinski. The Inse-
curity of the Digital Signature Algorithm with Partially
Known Nonces. J. Cryptology, 15:151–176, 2002.
[39] Phong Q. Nguyen and Igor E. Shparlinski. The Insecu-
rity of the Elliptic Curve Digital Signature Algorithm
with Partially Known Nonces. Des. Codes Cryptogr.,
30:201–217, 2003.
[40] Phong Q. Nguyen and Jacques Stern. Lattice Reduction
in Cryptology: An Update. In International Algorithmic
Number Theory Symposium – ANTS’00, volume 1838
of LNCS, pages 85–112. Springer, 2000.
[41] OpenSSL.
Security policy, 2019.
https://
www.openssl.org/policies/secpolicy.html (Ac-
cessed 26/07/2019).
[42] Colin Percival. Cache Missing for Fun and Proﬁt,
2005. Available online at http://daemonology.net/
hyperthreading-considered-harmful/.
[43] Andy Polyakov.
Improve ECDSA sign by 30-
OpenSSL Pull Request #5001,
40%, 2018.
https://github.com/openssl/openssl/pull/
5001#discussion_r159935593.
[44] Thomas Pornin. Deterministic Usage of the Digital
Signature Algorithm (DSA) and Elliptic Curve Digi-
tal Signature Algorithm (ECDSA), 2013. Request for
Comments: 6979.
[45] Oscar Reparaz, Josep Balasch, and Ingrid Verbauwhede.
Dude, is my code constant time? In Design, Automation
& Test in Europe – DATE’17, pages 1697–1702. IEEE,
2017.
[47] Claus-Peter Schnorr. Efﬁcient Identiﬁcation and Sig-
natures for Smart Cards. In Advances in Cryptology
– CRYPTO’89, volume 435 of LNCS, pages 239–252.
Springer, 1989.
[48] Michael Schwarz, Samuel Weiser, Daniel Gruss, Clé-
mentine Maurice, and Stefan Mangard. Malware Guard
Extension: Using SGX to Conceal Cache Attacks. In
Detection of Intrusions and Malware & Vulnerability
Assessment – DIMVA’17, volume 10327 of LNCS, pages
3–24. Springer, 2017.
[49] Laurent Simon, David Chisnall, and Ross J. Anderson.
What You Get is What You C: Controlling Side Effects
in Mainstream C Compilers. In IEEE European Sympo-
sium on Security and Privacy – EURO S&P’18, pages
1–15. IEEE, 2018.
[50] Eran Tromer, Dag Arne Osvik, and Adi Shamir. Efﬁ-
cient Cache Attacks on AES, and Countermeasures. J.
Cryptology, 23:37–71, 2010.
[51] Joop van de Pol, Nigel P. Smart, and Yuval Yarom. Just
a Little Bit More. In Topics in Cryptology – CT-RSA’15,
volume 9048 of LNCS, pages 3–21. Springer, 2015.
[52] Shuai Wang, Yuyan Bao, Xiao Liu, Pei Wang, Danfeng
Zhang, and Dinghao Wu. Identifying Cache-Based Side
Channels through Secret-Augmented Abstract Interpre-
tation. CoRR, abs/1905.13332, 2019.
[53] Shuai Wang, Pei Wang, Xiao Liu, Danfeng Zhang, and
Dinghao Wu. CacheD: Identifying Cache-Based Tim-
ing Channels in Production Software. In USENIX Secu-
rity’17, pages 235–252. USENIX Association, 2017.
[54] Samuel Weiser, Raphael Spreitzer, and Lukas Bodner.
Single Trace Attack Against RSA Key Generation in
Intel SGX SSL. In Asia Conference on Computer and
Communications Security – AsiaCCS, pages 575–586.
ACM, 2018.
[55] Samuel Weiser, Andreas Zankl, Raphael Spreitzer, Katja
Miller, Stefan Mangard, and Georg Sigl. DATA - Differ-
ential Address Trace Analysis: Finding Address-based
In USENIX Security’18,
Side-Channels in Binaries.
pages 603–620. USENIX Association, 2018.
[56] Jan Wichelmann, Ahmad Moghimi, Thomas Eisenbarth,
and Berk Sunar. MicroWalk: A Framework for Finding
Side Channels in Binaries. In Annual Computer Security
Applications Conference – ACSAC’18, pages 161–173.
ACM, 2018.
1782    29th USENIX Security Symposium
USENIX Association
[57] David Wong. Timing and Lattice Attacks on a Remote
ECDSA OpenSSL Server: How Practical Are They Re-
ally? IACR Cryptology ePrint Archive, 2015:839, 2015.
[58] Yuan Xiao, Mengyuan Li, Sanchuan Chen, and Yin-
qian Zhang. STACCO: Differentially Analyzing Side-
Channel Traces for Detecting SSL/TLS Vulnerabilities
in Secure Enclaves. In Conference on Computer and
Communications Security – CCS’17, pages 859–874.
ACM, 2017.
[59] Yuanzhong Xu, Weidong Cui, and Marcus Peinado.
Controlled-Channel Attacks: Deterministic Side Chan-
nels for Untrusted Operating Systems. In Security and
Privacy – S&P’15, pages 640–656. IEEE Computer So-
ciety, 2015.
[60] Yuval Yarom and Naomi Benger. Recovering OpenSSL
ECDSA Nonces Using the FLUSH+RELOAD Cache
Side-channel Attack. IACR Cryptology ePrint Archive,
2014:140, 2014.
[61] Yuval Yarom and Katrina Falkner. FLUSH+RELOAD:
A High Resolution, Low Noise, L3 Cache Side-Channel
In USENIX Security’14, pages 719–732.
Attack.
USENIX Association, 2014.
[62] Yuval Yarom, Daniel Genkin, and Nadia Heninger.
CacheBleed: A Timing Attack on OpenSSL Constant
Time RSA. In Cryptographic Hardware and Embed-
ded Systems – CHES’16, volume 9813 of LNCS, pages
346–367. Springer, 2016.
[63] Andreas Zankl, Johann Heyszl, and Georg Sigl. Auto-
mated Detection of Instruction Cache Leaks in Modular
Exponentiation Software. In Smart Card Research and
Advanced Applications – CARDIS’16, volume 10146 of
LNCS, pages 228–244. Springer, 2016.
[64] Yinqian Zhang, Ari Juels, Michael K. Reiter, and
Thomas Ristenpart. Cross-VM side channels and their
In Conference on Com-
use to extract private keys.
puter and Communications Security – CCS’12, pages
305–316. ACM, 2012.
A DATA GUI
Figure 5 shows the DATA GUI. It consists of several views:
The left side sorts all leaks according to their call stack (top)
and library (middle). Moreover, it shows for each function the
number of data (D) and control-ﬂow (CF) leaks as well as the
maximum correlation with the leakage models in percent. One
can see several other potential (false-positive) leaks which
do not correlate with any of the predeﬁned leakage-models.
The center box gives a list of data and control-ﬂow leaks for
1 int BN_is_bit_set(const BIGNUM *a, int n) {
2
...
if (a->top d[i]) >> j) & ((BN_ULONG)1));
Listing 4: OpenSSL k-padding leaks k->top (V5).
the selected function. The right side highlights leaks in the
disassembly and the source code, if available, which is crucial
for the analysis. The summary tab on the bottom left gives de-
tails about a particular leak, including correlations for various
leakage models. Also, it allows the analyst to comment and
rate leaks for documentation and communication purposes.
Clickable elements and the synchronization of different views
help to quickly navigate through complex reports.
B SGX Controlled-Channel Attack on (V5)
Fixing some of our reported vulnerabilities demand signiﬁcant
changes to the code base. For example, k-padding (V2) was
ﬁxed in OpenSSL, while the underlying problem of minimal
Bignumbers still persists until OpenSSL has reworked the
Bignumber implementation. Below, we show how to exploit
residual leakage via the k-padding top vulnerability (V5).
During k-padding, BN_is_bit_set is called with the in-
termediate nonce buffer l, as shown in Listing 2 line 18. If
l->top is smaller than q_bits, this causes an early abort in
Listing 4 line 4. In order to exploit this leakage, an attacker
needs to detect whether or not line 5 is executed.
While Flush+Reload might not work due to the small
amount of leaky code, we demonstrate a controlled-channel
attack [59] on an SGX enclave running the vulnerable DSA
sign operation from the SGX SSL library [18]. Controlled-
channel attacks detect individual memory accesses on a page
granularity, be it code or data. Since the vulnerable function
is likely on a single code page, probing this page does not
sufﬁce. Although more elaborate techniques to single-step
enclave execution exist [17], we distinguish whether line 5
accesses the data page covering buffer a->d.
For the attack, we need to trace execution to the vul-
nerable k-padding. We do this with the SGX-Step frame-
work [17] without using its single-stepping functionality. We
unmap all relevant enclave code pages on which the following
functions reside: dsa_do_sign, BN_generate_dsa_nonce,
BN_MONT_CTX_set_locked, BN_add, and BN_is_bit_set.
As soon as one of those pages is fetched by the enclave,
a page fault is triggered, which we capture in user space via
a custom signal handler. Then, we selectively enable only
the faulted page until we hit the vulnerable BN_is_bit_set
function. Now we also unmap the data page holding the nonce
buffer a->d. If the next step throws a page fault on a->d, we
know that line 5 has been executed. If not, we know that the
USENIX Association
29th USENIX Security Symposium    1783
Figure 5: DATA GUI showing the point addition vulnerability (V7) in BoringSSL where the ECDSA scalar multiplica-
tion is leaking bits(k) with 100%.
early abort in line 4 has been triggered. In that case the nonce
was not resized in the ﬁrst addition of k-padding (line 13 of
Listing 2) and, thus, is smaller than the average. We only
collect such signatures and mount a lattice attack.
We build the lattice according to Equation (13) and grad-
ually ﬁll it with leaky signatures until the lattice reduction
reveals the private key. For the actual reduction, we use the
BKZ algorithm with a block size of 30. For a DSA-256 modu-
lus leaking L = 8 bits, recovery succeeded with 36 signatures
within 3.3s. For L = 6 bit leakage, recovery took 47 signatures
and 7.8s. L = 4 required 79 signatures and took 111 hours
with an increased BKZ block size of 50, since it is closer to
the estimated bound in Section 2.2, demanding at least L = 3.
For the attack to work, a->top in line 4 needs to be on a
different page than a->d. This can be easily achieved if the
enclave copies variably-sized attacker-controlled arguments
such as messages to sign to the enclave heap. By changing the
argument’s size, Bignumber a can be shifted appropriately.
C Small Nonce Leakage Details
OpenSSL leaks the word length of small nonces in several
places. Nonce generation in BN_generate_dsa_nonce relies
on BN_div for nonce reduction, which is non-constant time
and leaks the length of small nonces, e.g., via BN_rshift.
Also, the nonce is stripped by skipping leading zero
limbs via bn_correct_top, which leaks the nonce length
in limbs in subsequent steps. OpenSSL’s default scalar
multiplication uses a blinded version of double-and-add
in ec_GF2m_simple_points_mul. Before blinding is ap-
plied, the nonce length leaks when being copied from
scalar to k via BN_copy, when checking its bit length via
BN_num_bits, and during the ﬁrst addition of the nonce
with the cardinality via BN_add. Also, the NIST-optimized
curves call BN_num_bits with the nonce as input, e.g., in
ec_GFp_nistp521_points_mul, which also leaks (cf. [43]).
During the nonce inversion done via BN_mod_exp_mont,
which is invoked by ec_group_do_inverse_ord and
ec_field_inverse_mod_ord, there is an early abort when
comparing the Bignumbers k and q via BN_ucmp. While their
exploitation might be tricky due to the small amounts of code
or data being accessed conditionally, we also found an easy-
to-exploit leak, which we describe in Section 6.1.
For LibreSSL, the situation is similar. Nonce genera-
tion leaks the nonce length via an early abort condition
when checking for a proper nonce during rejection sam-
pling via BN_ucmp. LibreSSL also leaks the nonce length
during the ﬁrst addition of the nonce and the group order in
BN_add (k-padding). However, LibreSSL accidentally per-
forms k-padding twice; 1) in ecdsa_sign_setup and 2) in
ec_GFp_simple_mul_ct. Unlike OpenSSL, nonce inversion
still uses the extended Euclid and is subject to vulnerabil-
ity (V8). Also, LibreSSL used an old non-constant-time ver-
sion of BN_num_bits_word which was patched in OpenSSL
already in January 2018 via commit 972c87df. Due to our
reporting, LibreSSL patched this issue in commit 9046ac5.
1784    29th USENIX Security Symposium
USENIX Association