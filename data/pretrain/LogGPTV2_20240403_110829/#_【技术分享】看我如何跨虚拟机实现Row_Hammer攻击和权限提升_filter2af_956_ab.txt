    								printf("[+] Found target offsetn");
    								res->victim = victim;
    								for (i = 0; i aggressors[i] = aggressors[i];
    								return ret;
    							}
    						}
    					}
    				}
    			}
    		}
    	}
    	return ret;
    }
关于Row-hammer最后一件有趣的事情是：如果我们针对受害者机器中的行数据进行了位翻转，那么通过重新“敲击”相邻行再现位翻转的可能性就很大。
**Memory de-duplication**
****
现在我们知道如何“敲击”，下面我将介绍如何依靠操作系统内存重复数据删除实现在内存中执行位翻转操作。内存重复数据删除在虚拟机环境中尤其有用，因为它显着减少了内存占用。在Linux上，内存重复数据删除由KSM来实现。KSM会定期扫描内存并合并匿名页面（具有
**MADV_MERGEABLE** 标记的页面）。
假设我们知道相邻VM中文件的内容，以下是通过利用Row-hammer漏洞和内存重复数据删除功能来修改文件中随机位的主要步骤：
1.从攻击者虚拟机“敲击”内存。
2.加载内存页面中容易受到位翻转攻击的目标文件。
3.加载受害者虚拟机中的目标文件。
4.等待KSM合并这两个页面。
5.再次“敲击”。
6.受害者虚拟机中的文件应该已被修改。
如Razavi等人在其论文所述，THP和KSM可能对Row-hammer造成意想不到的影响。因为THP会合并正常的4 KB页面以形成庞大的页面（2
MB），而KSM会合并具有相同内容的页面。这可能导致KSM打破巨大页面的情况。为了避免这种情况，我们用8个随机字节填充每个4 KB页面的顶部。
**处理Libpam程序**
****
给定一个程序P，我们怎么能在程序代码中找到可以改变P输出结果的所有可翻转的bit位呢？对程序P执行逆向分析看似是个不错的想法，可逆向工程太耗费时间了。在本文中，我们使用radare2开发了一个PoC（flip
-flop.py），该PoC能够自动捕获程序P的可翻转bit位。该PoC的原理是：我们翻转一些目标函数的每一位，并运行所需的功能，然后检查翻转的位是否影响目标函数的预期结果。我们在pam_unix.so模块（23e650547c395da69a953f0b896fe0a8）的两个函数上运行了PoC，如下图所示：
**pam_sm_authenticate [0x3440]** ：执行验证用户的任务。
**_unix_blankpasswd [0x6130]** ：检查用户是否没有空白密码。
我们总共发现可17个可以翻转的bit位，利用这些bit位我们可以使用空白或错误的密码执行身份验证操作。
值得注意的是，脚本无法从某些崩溃中恢复。原因是由于r2pipe没有提供任何处理错误的机制，那么当有一些致命的崩溃发生，r2pipe是无法恢复会话的。
**开始攻击**
****
我们的目标是在相邻VM中的pam_unix.so模块上运行一个Row-hammer攻击实例。我们首先回顾了绕过受害者VM身份验证机制的主要步骤：
1.分配可用的物理内存。
2.在内存页面添加一些填充数据，以防止KSM破坏THP页面。我们在每4 KB页面的顶部填充8个随机字节，其余的填充'xff'以检查方向1->
0的位翻转（或使用''来检查0->1的位翻转方向）。
3.我们在每个TPH页面中”敲击”每对被“入侵”的行，并检查我们是否在受害者行中进行了位翻转。
4.如果位触发器与表1的偏移量匹配，则将pam_unix.so模块加载到受害者页面中。
5.通过尝试登录来加载受影响虚拟机中的pam_unix.so模块。
6.等待KSM合并页面。
7.再次“敲击”已经产生相关翻转的bit位，此时受害者VM机器中，内存中的pam_unix.so已被更改。
8.操作完毕。
完整的exploit（pwnpam.c）可以在这里找到 。
请注意，漏洞利用不是100％可靠，如果我们找不到可用的位翻转，那么实验将不会成功。
**更进一步**
****
漏洞利用并不完全自动，因为在某些时候，我们需要与漏洞利用进行交互，以确保模块已经加载到受害者VM内存中并且其内容已经与攻击者虚拟机中加载的内容合并在一起，这时执行bit位翻转才会成功。
为了能够自动化的进行漏洞利用，可以通过利用KSM中的侧信道定时攻击来改善攻击，该功能使我们能够检测两个页面是否共享。以下代码是文中描述算法的实现，程序首先分配N个缓冲区（每个4096
KB），并用随机数据填充它，代码如下所示：
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #define PAGE_NB 256
    /* from https://github.com/felixwilhelm/mario_baslr */
    uint64_t rdtsc() {
    	uint32_t high, low;
    	asm volatile(".att_syntaxnt"
    		"RDTSCPnt"
    		: "=a"(low), "=d"(high)::);
    	return ((uint64_t)high  /sys/kernel/mm/ksm/run