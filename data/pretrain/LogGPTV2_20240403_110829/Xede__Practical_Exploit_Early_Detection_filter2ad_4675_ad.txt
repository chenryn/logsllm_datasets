tion is stable and the consumption rate is within 90 %. CPU utilization rate is
around 6 % except some utilization rate bursts. Thus, Xede is scalable to parallel
exploit detection.
Xede: Practical Exploit Early Detection
215
)
%
(
e
t
a
r
n
o
i
t
a
z
i
l
i
t
u
U
P
C
100
80
60
40
20
0
0
50 100 150 200 250 300 350 400 450 500 550
Time (s)
Fig. 6. Increased CPU consumption by Xede compared with QEMU.
)
%
(
e
t
a
r
n
o
i
t
a
z
i
l
i
t
u
e
c
r
u
o
s
e
R
)
%
(
e
t
a
r
n
o
i
t
a
z
i
l
i
t
u
e
c
r
u
o
s
e
R
CPU
MEM
4
3
2
1
0
0
50 100 150 200 250 300 350 400 450 500 550
Time (s)
Fig. 7. CPU cycles and memory consumed by Xede.
CPU
MEM
5
4
3
2
1
0
0
50 100 150 200 250 300 350 400 450 500 550
Time (s)
Fig. 8. Increased CPU and memory consumption by Xede compared with QEMU.
216
M. Nie et al.
CPU
MEM
)
%
(
e
t
a
r
n
o
i
t
a
z
i
l
i
t
u
e
c
r
u
o
s
e
R
100
80
60
40
20
0
0
100 200 300 400 500 600 700 800 900 1000 1100
Time (s)
Fig. 9. CPU and memory consumption with 80 Xede instances.
6 Discussion
Detecting Exploits without ROP and Code Injection. As we observed,
Xede can detect exploits leveraging ROP or/and code injection. However, it may
not be able to detect exploits that hijack control ﬂows without using ROP. For
example, exploits can use the software code to copy shellcode to the legal code
region and leverage legal code to hijack the control ﬂow to the shellcode. It is
very hard to construct such exploits since exploit construction requires strict
conditions, e.g., writable code segment and evading DEP. For instance, we can
compute checksum for diﬀerent memory region to detect memory rewriting. In
real practice, we do not notice any exploits that really implement this. We can
easily extend Xede to detect such exploits.
Accuracy of ROP Detection. Xede does not count the number of gadgets
where source and destination addresses of jmp are same. It signiﬁcantly reduces
the miscounted gadgets, and thereby reduces false positives of detecting JOP.
However, it is possible to evade Xede by constructing gadget chains with the
same intermediate gadgets, i.e., gadget 1->gadget x->gadget 2->gadget x->
··· . In order to perform control ﬂow hijacking from the intermediate gadgets to
diﬀerent gadgets, a large amount of gadgets are required to build chains between
gadgets, e.g., between gadget 1 and gadget x in the example above. However, it
is really diﬃcult to such gadget chains, and we did not observe any attacks in
real practice. Thus, we do not consider the attacks in this paper.
7 Related Work
Malicious code detection is mainly based on behavior analysis [2,3,19,27,45,
46]. The principle of this technique is to monitor APIs called by the target
process and then check if the process behaves properly via analyzing the API
sequence. The behavior analysis techniques are also widely adopted in current
Xede: Practical Exploit Early Detection
217
anti-virus software, such as FireEye [19] and WildFire [45]. The shortcomings of
the approaches are also obvious. They need to conﬁgure corresponding behavior
policies for diﬀerent types of samples. By analyzing API sequence, it is very
diﬃcult either to describe the comprehensive behaviors of a benign software or to
accurately deﬁne the possible behaviors of malicious code [25]. Moreover, exploits
are very sensitive to the system environment. If a victim software version does
not match the expected environment, the exploit will abort and the malicious
behaviors cannot be identiﬁed.
Recently more researches are conducted to detect exploits by identifying
shellcode [31,35,44]. Shellcode detection approaches intend to scan the content
of the sample ﬁle before the ﬁle execution and then to detect whether the ﬁle
includes shellcode characteristics. Polychronakis et al. [31] use a set of runtime
heuristics to identify the presence of shellcode in arbitrary data streams. The
heuristics identify machine-level operations that are inescapably performed by
diﬀerent shellcode types, such as reading from FS:[0x30], writing to FS:[0]. Wang
et al. [44] blindly disassembles each network request to generate a control ﬂow
graph, and then uses novel static taint and initialization analysis algorithms to
determine if self-modifying (including polymorphism) and/or indirect jump code
obfuscation behavior is collected. Such line of approaches shares an important
shortcoming. Content in data ﬁles is the same to the actual layout in process
memory. For example, shellcode hiding in a Doc ﬁle will be parsed and reorga-
nized by its host process, i.e., winword.exe. Therefore, it is not easy to accurately
identify the presence of shellcode in diﬀerent data ﬁles. Moreover, since shell-
code representation may not be fundamentally diﬀerent in structure from benign
payloads [28], these approaches inevitably suﬀers from signiﬁcant false positive
rates.
Exploit detection by enforcing Control Flow Integrity (CFI) generates a com-
plete control ﬂow graph (CFG) of samples (or, the host process of the sample ﬁle
if the sample is a data ﬁle) by performing static pre-analysis [1,21,47]. It moni-
tors the execution of the target process, analyzes each instruction executed, and
veriﬁes the legitimacy of each control ﬂow transfer by checking whether the ﬂow
transfer exists in the CFG. Zhang et al. [47] classify the destination addresses of
indirect control ﬂow transfer into several categories, such as code pointer con-
stants, computed code addresses, exception handling addresses, and verify these
destination addresses according to the results of static analysis. Unfortunately,
the CFI approaches cannot be adopted in real systems because of the following
reasons. Firstly, aiming to construct complete CFGs, CFI usually requires source
code of program or debug information of whole program. The information of
proprietary software is not always available. We could build CFG without those
information with some tools, such as IDA [22], but the accuracy and coverage of
CFG cannot be guaranteed. Secondly, the CFI approaches usually cannot verify
the legitimacy of control ﬂow transfer in dynamic code, which widely exists in
modern software. Lastly, they suﬀers from the problems of ineﬃciency and high
complexity [21].
218
M. Nie et al.
Taint analysis employs a dynamic tracing technique to detect exploits [11–13,
29,33,41]. It marks input data from tainted sample, and then monitors program
execution to track how the tainted attribute propagates and to check if the
tainted data is used in dangerous ways. However, as far as we know, all existing
taint analysis engines are unable to fully support analysis of the entire Intel
instruction set. Hence, the accuracy of the analysis results cannot be guaranteed.
Moreover, taint analysis needs to parse each instruction executed by the target
processes, and record all addresses of tainted data, The computation complexity
and complexity is not acceptable in real practice [36].
The prevention mechanisms, such as ASLR [26] and DEP [17], are adopted
to protect against malicious code exploits. More exploits leverage the ROP tech-
nique to evade the mechanisms. ROP is hard to detect because it uses the existing
legal instruction sequences to construct shellcode, instead of injecting shellcode.
Last Branch Recording (LBR) [23], a recent technique released with Intel proces-
sors, is used to analyze the executed indirect branch instructions to see if there
exists an excessively long chain of gadget-like instruction sequences. LBR-based
approaches [9,30] rely on hardware for instruction-level monitoring, which intro-
duces small runtime overhead and transparent operations. Unfortunately, these
approaches have some inherent drawbacks. The LBR stack can include only 16
records, and is shared by all running processes and threads. Hence, the stack may
not have enough space to record suﬃcient data. Moreover, these approaches can-
not observe the actual path of instruction execution between two indirect jumps,
thereby they cannot accurately count the number of instructions. Therefore, the
LBR-based approaches may not be accurate to analyze and detect exploits. Sim-
ilar to Xede, shadow stack and speculative code execution are adopted to detect
ROP. For example, Davi et al. [16] utilized shadow stack to detect ROP. How-
ever, the system is built upon the PIN subsystem and cannot instrument the
kernel code. Polychronakis et al. [32] used speculative code execution to analyze
non-randomized modules and is unable to detect exploits leveraging randomized
modules.
8 Summary
In this paper, we present the design and implementation of Xede, an exploit
detection system. Xede comprehensively detect diﬀerent types of exploits, e.g.,
generated by pure code injections, pure ROP, and hybrid exploitation techniques.
We have implemented a prototype of Xede with QEMU. The evaluation demon-
strates that Xede can eﬀectively detect diﬀerent exploits according experiments
with samples and real world deployment on the Internet. In particular, with
real world deployment, Xede detects a large number of exploits that cannot be
captured by mainstream anti-virus software and exploits that raise abnormal
execution exceptions due to mismatched execution environments.
Acknowledgement. We would like to thank our shepherd Christopher Kruegel, and
the anonymous reviewers for their insightful comments. This work is partially sup-
ported by the National Basic Research Program of China (973 Program) (Grant
Xede: Practical Exploit Early Detection
219
No.2012CB315804), and the National Natural Science Foundation of China (Grant
No.91418206).
References
1. Abadi, M., Budiu, M., Erlingsson, U., Ligatti, J.: Control-ﬂow integrity. In: Pro-
ceedings of the 12th ACM Conference on Computer and Communications Security,
pp. 340–353. ACM (2005)
2. Amnpardaz. http://jevereg.amnpardaz.com/
3. Anubis. https://anubis.iseclab.org/
4. Flame Malware. http://en.wikipedia.org/wiki/Flame malware
5. Sony Pictures Entertainment hack. http://en.wikipedia.org/wiki/Sony Pictures
Entertainment hack
6. Stuxnet. http://en.wikipedia.org/wiki/Stuxnet
7. Carlini, N., Wagner, D.: Rop is still dangerous: breaking modern defenses. In:
USENIX Security Symposium (2014)
8. Checkoway, S., Davi, L., Dmitrienko, A., Sadeghi, A.R., Shacham, H., Winandy,
M.: Return-oriented programming without returns. In: Proceedings of the 17th
ACM Conference on Computer and Communications Security, pp. 559–572. ACM
(2010)
9. Cheng, Y., Zhou, Z., Yu, M., Ding, X., Deng, R.H.: Ropecker: a generic and prac-
tical approach for defending against rop attacks. In: Symposium on Network and
Distributed System Security (NDSS) (2014)
10. contagiodump. http://contagiodump.blogspot.com/
11. Costa, M., Crowcroft, J., Castro, M., Rowstron, A., Zhou, L., Zhang, L., Barham,
P.: Vigilante: end-to-end containment of internet worms. ACM SIGOPS Oper.
Syst. Rev. 39, 133–147 (2005). ACM
12. Crandall, J.R., Chong, F.: Minos: architectural support for software security
through control data integrity. In: International Symposium on Microarchitecture
(2004)
13. Crandall, J.R., Su, Z., Wu, S.F., Chong, F.T.: On deriving unknown vulnerabilities
from zero-day polymorphic and metamorphic worm exploits. In: Proceedings of the
12th ACM Conference on Computer and Communications Security, pp. 235–248.
ACM (2005)
14. CVE-2012-0158. http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-0158
15. CVE-2014-1761. http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1761
16. Davi, L., Sadeghi, A.R., Winandy, M.: Ropdefender: a detection tool to defend
against return-oriented programming attacks. In: Proceedings of the 6th ACM
Symposium on Information, Computer and Communications Security, pp. 40–51.
ACM (2011)
17. Data Execution Prevention.
http://en.wikipedia.org/wiki/Data Execution
Prevention
18. exploit-db. http://www.exploit-db.com/
19. FireEye. http://www.ﬁreeye.com/
20. Garﬁnkel, T., Rosenblum, M.: A virtual machine introspection based architecture
for intrusion detection. In: Proceedings of the 10th Network and Distributed Sys-
tem Security Symposium, Febuary 2003
21. Goktas, E., Athanasopoulos, E., Bos, H., Portokalidis, G.: Out of control: over-
coming control-ﬂow integrity. In: 2014 IEEE Symposium on Security and Privacy
(SP), pp. 575–589. IEEE (2014)
220
M. Nie et al.
22. IDA Pro. https://www.hex-rays.com/products/ida/
23. Intel: Intel 64 and IA-32 Architectures Software Developer´s Manual, Febuary 2014
24. Jiang, X., Wang, X., Xu, D.: Stealthy malware detection through VMM-based
“Out-Of-the-Box” semantic view reconstruction. In: Proceedings of the 14th ACM
Conference on Computer and Communications Security, October 2007
25. Lanzi, A., Balzarotti, D., Kruegel, C., Christodorescu, M., Kirda, E.: Accessminer:
using system-centric models for malware protection. In: Proceedings of the 17th
ACM Conference on Computer and Communications Security, pp. 399–412. ACM
(2010)
26. Larsen, P., Homescu, A., Brunthaler, S., Franz, M.: SoK: automated software diver-
sity. In: Proceedings of the 2014 IEEE Symposium on Security and Privacy, SP
2014 (2014)
27. LastLine. https://www.lastline.com/
28. Mason, J., Small, S., Monrose, F., MacManus, G.: English shellcode. In: Proceed-
ings of the 16th ACM Conference on Computer and Communications Security, pp.
524–533. ACM (2009)
29. Newsome, J., Song, D.: Dynamic taint analysis for automatic detection, analysis,
and signature generation of exploits on commodity software (2005)
30. Pappas, V., Polychronakis, M., Keromytis, A.D.: Transparent rop exploit mitiga-
tion using indirect branch tracing. In: USENIX Security, pp. 447–462 (2013)
31. Polychronakis, M., Anagnostakis, K.G., Markatos, E.P.: Comprehensive shellcode
detection using runtime heuristics. In: Proceedings of the 26th Annual Computer
Security Applications Conference, pp. 287–296. ACM (2010)
32. Polychronakis, M., Keromytis, A.D.: Rop payload detection using speculative code
execution. In: 2011 6th International Conference on Malicious and Unwanted Soft-
ware (MALWARE), pp. 58–65. IEEE (2011)
33. Portokalidis, G., Slowinska, A., Bos, H.: Argos: an emulator for ﬁngerprinting zero-
day attacks for advertised honeypots with automatic signature generation. ACM
SIGOPS Oper. Syst. Rev. 40, 15–27 (2006). ACM
34. Rabek, J.C., Khazan, R.I., Lewandowski, S.M., Cunningham, R.K.: Detection of
injected, dynamically generated, and obfuscated malicious code. In: Proceedings
of the 2003 ACM Workshop on Rapid malcode, pp. 76–82. ACM (2003)
35. Ratanaworabhan, P., Livshits, V.B., Zorn, B.G.: Nozzle: A defense against heap-
spraying code injection attacks. In: USENIX Security Symposium, pp. 169–186
(2009)
36. Schwartz, E.J., Avgerinos, T., Brumley, D.: All you ever wanted to know about
dynamic taint analysis and forward symbolic execution (but might have been afraid
to ask). In: 2010 IEEE Symposium on Security and Privacy (SP), pp. 317–331.
IEEE (2010)
37. Secunia: Secunia vulnerability review 2015. Technical report, Secunia (2014).
http://secunia.com/vulnerability-review/
38. securityfocus. http://www.securityfocus.com/
39. Shacham, H.: The geometry of innocent ﬂesh on the bone: return-into-libc with-
out function calls (on the x86). In: Proceedings of the 14th ACM Conference on
Computer and Communications Security, October 2007
40. Snow, K.Z., Monrose, F.: Automatic hooking for forensic analysis of document-
based code injection attacks (2012)
41. Suh, G.E., Lee, J.W., Zhang, D., Devadas, S.: Secure program execution via
dynamic information ﬂow tracking. ACM Sigplan Not. 39, 85–96 (2004). ACM
42. TCA Malware Analysis platform. http://www.tcasoft.com/
Xede: Practical Exploit Early Detection
221
43. VirusTotal. https://www.virustotal.com/
44. Wang, X., Jhi, Y.C., Zhu, S., Liu, P.: Still: exploit code detection via static taint
and initialization analyses. In: 2008 Annual Computer Security Applications Con-
ference, ACSAC 2008, pp. 289–298. IEEE (2008)
45. WildFire.
https://www.paloaltonetworks.com/products/technologies/wildﬁre.
html
46. XecScan. http://scan.xecure-lab.com/
47. Zhang, M., Sekar, R.: Control ﬂow integrity for cots binaries. In: Usenix Security,
pp. 337–352 (2013)