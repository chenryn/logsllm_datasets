**作者：王铁磊**  
**原文链接：**
## 1 引言
虚拟内存 (Virtual Memory, VM)
⼦系统是现代操作系统基础核⼼组件，不仅负责虚拟地址和物理内存的映射关系，管理调度物理内存的使⽤，为程序开发提供统⼀透明的地址空间，同时也要为不同执⾏环境提供隔离，管控物理页⾯读、写、执⾏等权限，是系统安全的基⽯。由于VM⼦系统需要同时兼顾性能、效率、透明性和安全等⽬标，导致VM⼦系统在实现过程中逻辑⼤多异常复杂，VM⼦系统中的各种优化策略也就成了"逻辑错误"类型漏洞的重灾区。
本⽂以iOS、macOS操作系统的内核XNU为例，回顾⼀些与XNU
VM⼦系统相关的历史漏洞；通过分析这些漏洞的成因，梳理VM⼦系统逻辑漏洞的脉络，希望能给其他安全研究带来⼀些启发。
## 2 未预期的破坏
VM⼦系统的⼀个经典功能是Swap，是指在调度物理页⾯时，VM系统可能会将部分物理页⾯转储⾄磁盘从⽽获得⾜够的物理空间；当这些转储的物理页⾯被真正访问时，VM⼦系统再从Swap⽂件中恢复原始物理页⾯内容。
2017年，Google Project 0研究员Ian Beer与Jann
Horn在头脑风暴中，想到⼀个问题，这个Swap⽂件能否被篡改破坏？与其百思不解，不如简单⼀试。macOS系统上，Swap⽂件路径是/private/var/vm/swapfifile0。Ian
Beer简单粗暴的⽤随机数据覆盖了该⽂件：
结果也⽐较粗暴，内核直接崩溃了[1]。这意味着macOS上在SIP[2]
保护机制并没有保护这个Swap⽂件。在处理被破坏的Swap⽂件时，内核出现了内存错误。⼤胆思考，勇于尝试，是亘古不变的道理。
## 3 未预期的共享
共享内存 (Shared Memory)
是操作系统中实现进程间通信的重要⽅式，通过把相同的物理页⾯映射在不同执⾏体的虚拟地址空间，使双⽅都能访问同样的物理页⾯，不仅能减少物理页⾯的使⽤，也能避免通信过程中传输⼤块数据，从⽽提⾼通信的效率。不过，如果多⽅对同⼀块内存都具有写权限时，维护内存⼀致性变得很困难，"竞争写"也容易引发很多安全问题。
共享内存的双取 (Double Fetch)
是⼀类⾮常典型的安全漏洞成因。下表展⽰了⼀个简单的双取漏洞：第⼀个⾏调⽤strlen计算共享内存中⼀个字符串的长度；第⼆⾏根据该长度分配⼀个本地堆内存；第三⾏调用strcpy把共享内存中的字符串复制到新分配的本地内存中。这三⾏代码的问题在于，因为C
string以\0为截⽌符，strlen扫描字符串时以第⼀次遇到的\0计算当前字符串的长度，同样， strcpy
复制字符串时，直到遇到的\0才会终⽌复制。⽽共享内存另⼀端控制者，可以在strlen和strcpy之间，把第⼀个\0修改为⾮零字符，这导致strcpy会复制过多字符到
local_buffer 中，造成堆溢出。
随着系统复杂性的增⾼、系统通信层级越来越多，底层开发者与应⽤开发者针对数据传输和使⽤的视⾓很难统⼀，导致很多情况下数据是以⾮预期的共享内存形式传递的，造成很多安全问题。接下来，我们来看⼏个⾮预期共享的案例。
### 3.1 CVE-2017-7047：xpc_data共享内存传输
XNU提供了基于Mach Port和Mach
Message的灵活通信机制。在MachMessage基础上，⽤户态进⼀步封装了libxpc框架，提供了字典、队列、字符串、纯数据等常见数据结构的封装；在libxpc基础上，又封装了NSXPC框架，重点⽀持远程对象和⽅法调⽤。
XNU通信架构
2017年，Ian Beer发现，libxpc在传输xpc_data时，如果数据长度超过0x4000，会调⽤
mach_make_memory_entry_64创建虚拟内存的mach port，然后将mach port发送出去；接收⽅收到这个mach
port后，调⽤mach_vm_map将port对应的虚拟内存再映射到本地。具体流程如下图所⽰。
大块xpc_data传递 (发送方使用MAP_MEM_VM_COPY标志)
为避免共享内存的隐患，发送⽅调⽤ mach_make_memory_entry_64时，使⽤了
MAP_MEM_VM_COPY标志。结合XNU中的注释，不难理解使⽤这个标志位创建mach
port过程中，会创建数据的副本。这样接收⽅通过mach_vm_map再次映射后，获得的也是数据副本。这其实是⼀种将xpc_data以写时复制(Copy-on-Write, COW)形式传递的实现⽅式，避免了xpc_data的完全共享。
然⽽，Ian Beer敏锐地发现，这种COW依赖于发送⽅创建mach
port时指定MAP_MEM_VM_COPY标志。对于"恶意"发送⽅，完全可以创建⼀个全共享内存的port，然后发送给接收⽅。这样通过mach_vm_map简单映射获得的虚拟地址，会和发送⽅完全共享物理页⾯。这样⼀来，接收⽅使⽤xpc_data时就可能存在双取问题。
Ian
Beer继续追踪系统中对xpc_data的不安全使⽤。NSXPC是在libxpc基础上，在进程间通信中⽀持远程对象和远程⽅法调⽤。在实现中，这些远程对象和⽅法调⽤经序列化后由xpc_data发送。Ian
Beer在这个反序列化过程中，把⼀个双取问题转换成了堆溢出，实现了针对任意NSXPC服务的原型攻击 [4]。
Apple的漏洞修复⽅案也很清晰。在传输xpc_data过程中，不再信任发送⽅，⽽是在接收⽅调⽤mach_vm_map时，强制开启copy选项，也就是以COW形式映射。这样发送⽅对
xpc_data 的任何修改都不会传递到接收⽅，避免了双取问题。
大块xpc_data传递 (接收方强制mach_vm_map使用copy选项)
### 3.2 IOKit Out-of-line数据
IOKit是XNU的驱动开发框架，提供了⽤户态程序、内核、设备之间的通信接口。其中，⽤户态程序可以通过 IOConnectCallMethod
接口与内核驱动传递数据。当⽤户态传⼊⼤块数据时（Out-of-line, OOL），系统会创建
IOMemoryDescriptor，将该段数据映射到内核供驱动使⽤。然⽽XNU-3789.31.2版本之前，IOKit开发者没有意识到，这段数据实际是以共享内存形式存在的。IOKit框架和具体驱动开发者之间并没有清晰界定OOL数据的存在形态，以⾄于很多驱动实现中都有双取漏洞。更多漏洞细节可以参考Flanker的blog
[5]。
OOL 双取漏洞实例
例如，在macOS显卡驱动中， IOAccelDisplayPipePostCSCGammaVID::init
函数在处理OOL输⼊时，会根据OOL内的⼀个整数调⽤ IOMalloc 分配内存，然后再次读取该整数⽤于 memcpy
。这种典型的双取漏洞造成极容易利⽤的堆溢出[6]。
鉴于太多驱动开发者都没有意识到OOL数据是通过共享内存传递的，逐⼀纠正驱动开发者的代价太⼤，Apple在XNU-3789.31.2中，直接将OOL数据以COW形式映射。相应的补丁如下。通过使⽤
kIOMemoryMapCopyOnWrite 标志，确保内核获得的数据副本不会存在双取问题。
OOL COW映射补丁
### 3.3 Apple Neural Engine共享内存问题
IOKit处理OOL时犯过的错误，也会反应在单独的驱动中。除了直接使⽤OOL数据，IOKit驱动也可以⾃⾏映射⽤户态内存⾄内核使⽤。2018年，Apple推出了A12仿⽣芯⽚，搭载了强⼤的神经⽹络引擎。相应地，iOS内核中也增加⼀个H11ANEIn驱动，⽤于处理神经⽹络引擎的相关计算请求。H11ANEIn需要⼤量异步处理，IOKit框架提供的OOL数据并不适合其计算需求，因此H11ANEIn直接根据⽤户态提供的地址创建了
IOMemoryDescriptor 。