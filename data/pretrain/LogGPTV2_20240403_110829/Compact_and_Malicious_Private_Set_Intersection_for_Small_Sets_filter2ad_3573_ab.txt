to use an ideal permutation in place of an ideal cipher.
In more detail, the CDJ mechanism has the parties run ğ‘› instances
of string equality tests. Each equality test will return either true or
false, indicating which items are in the intersection. We observe
that full-fledged equality tests are overkill for CDJ. Instead, let the
parties run ğ‘› instances of plain KA, embedded into polynomials
according to their PSI inputs. Each of these KA instances terminates
with an output key. If Alice and Bob hold a common item, then they
will have a key in common. If Alice has an item that Bob doesnâ€™t (or
vice-versa), we show that Alice computes a key that looks random
to Bob. Hence, for PSI it suffices for the parties to simply compare
their set of KA outputs in the clear.
Not only are key agreement protocols conceptually simpler and
more concretely efficient than string equality test protocols â€” they
are also inputless. As a result, KA protocols have the property that
their first protocol message can be reused for many instances. This
is not necessarily true for a string equality test protocol, where
the partyâ€™s input string would typically be â€œbaked intoâ€ the first
protocol message. In terms of the PSI protocol, this means that our
protocol does not require a large polynomial of degree ğ‘› (for ğ‘›
items) for the first message. Instead, Alice can send just a single
KA protocol message, to which Bob computes ğ‘› KA responses.
For a two-message KA protocol (like Diffie-Hellman), the fact
that the second message is pseudorandom ensures that the poly-
nomial hides the input set. By adding random oracle calls in a few
selected places, we provide a â€œhookâ€ for the simulator to extract
malicious partiesâ€™ inputs, yielding a malicious-secure PSI protocol.
Finally, the CDJ mechanism uses an ideal cipher for technical
reasons (giving the simulator the ability to â€programâ€ outputs of
the polynomial). We show that a simpler ideal permutation suffices.
Performance of the Diffie-Hellman Instantiation. When our new
PSI paradigm is instantiated with Diffie-Hellman KA, we obtain the
most efficient DH-based PSI protocol to date. For malicious security
we require the oracle Diffie-Hellman (ODH) assumption [2] to
hold in the cyclic group. For semi-honest security we only require
the standard CDH assumption.
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1168CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
Mike Rosulek and Ni Trieu
Protocol
Communication
28
29
ğ‘› = ğ‘›1 = ğ‘›2
210
212
216
220
Hardness
Assumption
(ğœ™ + ğœ† + log(ğ‘›1ğ‘›2))ğ‘›1 + ğœ™ğ‘›2
(3 + ğ‘ )(ğœ† + log(ğ‘›1ğ‘›2))ğ‘›1 + 1.2â„“ğ‘›2 + |baseOT|
1.02(ğœ† + log2(ğ‘›2) + 2)ğ‘›1 + â„“ğ‘›2 + |baseOT|
2(ğœ† + log(ğ‘›1ğ‘›2))ğ‘›1 + â„“(1 + 1/ğœ†)ğ‘›2 + |baseOT|
(ğœ† + log2(ğ‘›1ğ‘›2))ğ‘›1 + â„“(2.4ğ‘›2 + ğœ† + ğœ’) + |baseOT|
(ğœ† + log(ğ‘›1ğ‘›2))ğ‘›1 + 4.8ğœ…ğ‘›2 + |baseOT|
(ğœ† + log(ğ‘›1ğ‘›2))ğ‘›1 + 217ğœ…ğ‘›0.05
+ 2.4ğœ…ğ‘›2 + |baseOT|
2
(ğœ† + log(ğ‘›1ğ‘›2))ğ‘›1 + 217ğœ…ğ‘›0.05
+ ğœ…ğ‘›2 + |baseOT|
2
(ğœ† + log(ğ‘›1ğ‘›2))ğ‘›1 + ğœ™ğ‘›2 + ğœ™
2ğœ…ğ‘›1 + 6ğœ™ğ‘›2 + 2ğœ™
2ğœ…ğ‘›1 + 3ğœ™ğ‘›2
ğœ™(ğ‘›1 + ğ‘›2) log(ğ‘›1 + ğ‘›2)
2ğœ…ğ‘›1 + â„“(2.4ğ‘›2 + 2ğœ† + ğœ’) + ğœ†(2.4ğ‘›2 + 2â„“) + |baseOT|
2ğœ…ğ‘›1 + 217ğœ…ğ‘›0.05
2
2ğœ…ğ‘›1 + 217ğœ…ğ‘›0.05
2
2ğœ…ğ‘›1 + ğœ™ğ‘›2 + ğœ™
Semi Honest
DH-PSI
KKRT [36]
SpOT-low [42]
SpOT-fast [42]
PaXoS [43]
CM [11]
VOLE-PSI (PaXoS)[48]
VOLE-PSI (interpolation)[48]
Ours
Malicious
DKT [16]
JL [34]
Hazay [25]
PaXoS [43]
VOLE-PSI (PaXoS)[48]
VOLE-PSI (interpolation)[48]
Ours
Table 1: Theoretical communication costs of PSI protocols (in bits), calculated using computational security ğœ… = 128 and
statistical security ğœ† = 40. The cost of base OTs are independent of input size and equal to 5ğœ…, which are ignored in the columns
ğ‘› = ğ‘›1 = ğ‘›2. ğ‘›1 and ğ‘›2 are the input sizes of the sender and receiver respectively. ğœ™ is the size of elliptic curve group elements
(256 is used here). â„“ is width of OT extension matrix (depends on ğ‘›1 and protocol). ğœ’ is the upper bound on the number of cycles
in a cuckoo graph of PaXoS.
CDH
OMGDH
CDH
CDH
LPN+CDH
ODH
584ğ‘›
1032ğ‘›
515ğ‘›
595ğ‘›
1128ğ‘›
686ğ‘›
825ğ‘›
646ğ‘›
328n
1792ğ‘›
1024ğ‘›
8704ğ‘›
1408ğ‘›
1009ğ‘›
830ğ‘›
512n
576ğ‘›
1094ğ‘›
499ğ‘›
571ğ‘›
1101ğ‘›
678ğ‘›
6580ğ‘›
6400ğ‘›
320n
1792ğ‘›
1024ğ‘›
6656ğ‘›
1389ğ‘›
6772ğ‘›
6592ğ‘›
512n
572ğ‘›
1418ğ‘›
495ğ‘›
563ğ‘›
1097ğ‘›
674ğ‘›
23538ğ‘›
23358ğ‘›
316n
1792ğ‘›
1024ğ‘›
5632ğ‘›
1389ğ‘›
23734ğ‘›
23554ğ‘›
512n
568ğ‘›
1349ğ‘›
483ğ‘›
547ğ‘›
1074ğ‘›
670ğ‘›
86838ğ‘›
86659ğ‘›
312n
1792ğ‘›
1024ğ‘›
4608ğ‘›
1370ğ‘›
87038ğ‘›
86859ğ‘›
512n
570ğ‘›
1388ğ‘›
493ğ‘›
559ğ‘›
1095ğ‘›
672ğ‘›
45128ğ‘›
44948ğ‘›
314n
1792ğ‘›
1024ğ‘›
5120ğ‘›
1389ğ‘›
45326ğ‘›
45146ğ‘›
512n
+ 2.4ğœ…ğ‘›2 + |baseOT|
+ ğœ…ğ‘›2 + |baseOT|
592ğ‘›
1018ğ‘›
532ğ‘›
619ğ‘›
1155ğ‘›
694ğ‘›
419ğ‘›
240n
336ğ‘›
1792ğ‘›
1024ğ‘›
10752ğ‘›
1427ğ‘›
595ğ‘›
416n
512ğ‘›
CDH
CDH
LPN+CDH
CDH
Our protocol is both faster and uses less communication
than any other protocol, when the set sizes are small (less than
1000 items) â€” even considering semi-honest protocols and protocols
based on OT extension, which are faster on large sets. For ğ‘› = 256
items, our malicious protocol is 18-30% faster (depending on the
network speed) and uses 10% less communication than the next
best (semi-honest) protocol. Our semi-honest variant uses 45% less
communication than the next best. See Figure 1 for a complete
comparison.
To the best of our knowledge, ours is the first significant im-
provement in communication cost to the 20-year old classic
DH-PSI protocol, due to [29]. We reduce the communication cost
while simultaneously promoting it from semi-honest to malicious secu-
rity. The classic semi-honest DH-PSI protocol of [29] requires total
communication 2ğ‘› group elements plus ğ‘› hashes; the total com-
putation is 4ğ‘› variable-base exponentiations. In our protocol, the
total communication is only ğ‘›+1 group elements plus ğ‘› hashes; the
total computation is 3ğ‘› fixed-base exponentiations, 2ğ‘› variable-base
exponentiations, and 2 polynomial interpolation/multi-evaluations
of a degree-ğ‘› polynomial. The leading malicious DH-based PSI
protocol is due to De Cristofaro, Kim, and Tsudik [16]; its total
communication is 6ğ‘› group elements plus ğ‘› hashes; the total com-
putation is 2ğ‘› fixed-based exponentiations and 4ğ‘› variable-base
exponentiations. Our malicious protocol is over 30Ã— faster and uses
80% less communication.
2 PRELIMINARIES
2.1 Security Model
Secure two-party computation allows mutually distrusting parties
to jointly perform a computation on their private inputs without
revealing any additional information except for the result itself.
There are two adversarial models, which are usually considered.
In the semi-honest model, the adversary is assumed to follow the
Parameters: Size of partiesâ€™ sets: ğ‘› for honest parties and ğ‘›â€² for
corrupt parties.
Functionality:
â€¢ Wait for input ğ‘Œ âŠ† {0, 1}âˆ— from receiver. Abort if |ğ‘Œ| > ğ‘›
and the receiver is honest, or if |ğ‘Œ| > ğ‘›â€² and the receiver is
corrupt.
â€¢ Wait for input ğ‘‹ âŠ† {0, 1}âˆ— from sender and abort if |ğ‘‹| > ğ‘›.
â€¢ Give output ğ‘‹ âˆ© ğ‘Œ to the receiver.
Figure 2: PSI ideal functionality.
protocol, but may try to learn information from the protocol tran-
script. In the malicious model, the adversary follows an arbitrary
polynomial-time strategy, and feasibility holds in the presence of
both types of attacks.
2.2 PSI functionality
In Figure 2, we formally describe the PSI functionality, which allows
2 parties to compute the intersection of their datasets without
revealing any additional information.
Note that the functionality allows a corrupt receiver to have more
input items (ğ‘›â€²) than is â€œadvertisedâ€ (ğ‘›). This property reflects the
fact that our protocol canâ€™t tightly enforce the number of items held
by the receiver. This is a common feature of PSI protocols, shared
in particular by all the fastest malicious-secure PSI protocols [43,
46, 47]. We discuss specific relationship between ğ‘›â€² and ğ‘› achieved
by our protocol in Section 4.1.
2.3 Polynomial Operations
A common implementation of polynomial interpolation and multi-
point evaluation is based on Lagrange algorithm, which costs ğ‘‚(ğ‘›2)
field operations. This implementation typically uses for low-degree
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1169Compact and Malicious Private Set Intersection for Small Sets
CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
polynomials. However, when ğ‘› is very large (e.g. ğ‘› = 220) this algo-
rithm is completely impractical. In this work, we use the faster algo-
rithms [41] which achieves computational complexity of ğ‘‚(ğ‘› log2 ğ‘›)
arithmetic operations. At the high level idea, the algorithms for
both problems follow the divide-and-conquer approach. Particu-
larly, the problem is reduced to two half-size problems after each
iteration. Each combination of individual solutions from two half-
size problems to the full-size solution costs ğ‘‚(ğ‘› log ğ‘›). Therefore,
the total complexity of polynomial interpolation and multi-point
evaluation is ğ‘‚(ğ‘› log2 ğ‘›).
Given ğ‘‹ = {ğ‘¥1, . . . , ğ‘¥ğ‘›} âŠ† F and ğ‘Œ = {ğ‘¦1, . . . , ğ‘¦ğ‘›} âŠ† F, we
use ğ‘ƒ = interpolF({(ğ‘¥1, ğ‘¦1), . . . , (ğ‘¥ğ‘›, ğ‘¦ğ‘›)}) to refer to polynomial
interpolation which finds the unique (ğ‘› âˆ’ 1)-degree polynomial ğ‘ƒ
that satisfies ğ‘ƒ(ğ‘¥ğ‘–) = ğ‘¦ğ‘– for all ğ‘– âˆˆ [ğ‘›].
2.4 Ideal Permutation
In the ideal permutation model, all parties have oracle access to a
random permutation Î  on {0, 1}ğ‘› and its inverse Î âˆ’1. We write
Î Â± to refer to the pair of these oracles. In the proof of security, the
simulator answers the interface of Î Â±, meaning that it can observe
all queries and program the responses. The ideal permutation model
is similar to, but weaker than, the ideal cipher model. An ideal cipher
is a family of ideal permutations, one for each key.
The ideal permutation assumption has recently become popular
in practical MPC implementations, because it allows one to base
cryptographic operations on a fixed-key block cipher â€” i.e., to use
hardware-accelerated AES instructions without computing the AES
key schedule. Ideal permutations have been used to realize efficient
hashing functions for garbled circuits and OT extension [5, 24]. Our
work requires an ideal permutation that supports key-agreement
messages as inputs, therefore our implementation uses Rijndael-
256 rather than AES (whose block size is only 128). We note that
other options are available to instantiate an ideal permutation.
For example, symmetric-key constructions that use the sponge
methodology [7] all use an efficient underlying ideal permutation.
3 KEY AGREEMENT PRELIMINARIES
We construct PSI from 2-round key-agreement protocols. A 2-
round key agreement protocol KA has several parameters:
â€¢ KA.R is the space of random coins for the two parties.
â€¢ KA.M is the space of possible messages for Party 2.
â€¢ KA.K is the space of possible output keys.
A key agreement protocol consists of algorithms: KA.msg1, KA.msg2,
KA.key1, KA.key2, which correspond to an interactive key agree-
ment protocol as shown in Figure 3.
In some 2-round key agreement protocols, the second message
ğ‘š2 does not depend on the first message ğ‘š1, and we can write
ğ‘š2 = KA.msg2(ğ‘) instead of ğ‘š2 = KA.msg2(ğ‘, ğ‘š1). In these cases,