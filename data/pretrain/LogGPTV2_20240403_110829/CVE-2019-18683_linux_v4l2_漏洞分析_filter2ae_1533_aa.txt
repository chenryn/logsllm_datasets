# CVE-2019-18683 linux v4l2 漏洞分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
`CVE-2019-18683`是 linux v4l2 子系统上的一个竞争漏洞，潜伏时间长达5年，[Alexander
Popov](https://a13xp0p0v.github.io/)在[OffensiveCon
2020](https://www.offensivecon.org/speakers/2020/alexander-popov.html)上披露了漏洞细节。影响`vivid`驱动，最终造成uaf，有可能可以做本地提权。
在这篇文章，我们主要分析漏洞相关代码来找出漏洞的成因。
## 漏洞分析
###  调试环境搭建
v4l2 即`video for linux version 2`，
是和linux视频相关的子系统，当你在linux上用电脑的摄像头时就会使用到它，对应的驱动是`/dev/videoX` 。
漏洞影响的是 `vivid` 模块，但是这个模块默认情况下是不会加载的，需要我们手动加载，例如在`ubuntu 1804` 上可以用下面的命令加载它:
可以普通用户也有这个设备的访问权限，这就给攻击提供了可能性。
要调试分析这个驱动，可以直接就是装两个`ubuntu`
的vmware虚拟机，然后双机调试。但是自己测试的时候双机搞实在是慢的可以，而且还会出现各种问题十分蛋疼，所以就自己搞了个qemu
的调试环境，环境的搭建可能不太规范，但还是可以满足基本的调试需求的。
**linux 内核编译**
`vivid` 模块有很多的依赖，但是我不清楚具体内核需要用什么编译选项，所以就直接用了自己虚拟机上的编译配置，我用的是`ubuntu 18.04`
系统，内核用的[linux-5.4版本](https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.4.tar.xz),拷贝系统的config
文件，然后直接`make` 编译即可
    cp /boot/config-4.15.0-76-generic .config
**运行环境**
文件系统的话随便找一个ctf的内核题拿一个就行，我这里用的是常用的
cpio格式的文件系统，但是这里还需要我们自己把模块加载进来，可以把驱动搞进`/lib/modules`
之类的，这里我的做法是把编译好的模块的`ko`文件找出来，在系统运行后自己`insmod`进去。
`vivid`模块在内核的/drivers/media/platform/vivid目录下，这个模块有很多的依赖，需要先把依赖的模块也加载才行,
查看`ubuntu`虚拟机的模块依赖`/lib/modules/5.4.0/modules.dep`可以找到它依赖的ko文件
    ➜ root@prbvv  ~/cve-2019-18683/linux/drivers/media/platform/vivid  cat /lib/modules/5.4.0/modules.dep |grep vivid
    kernel/drivers/media/platform/vivid/vivid.ko: kernel/drivers/media/common/v4l2-tpg/v4l2-tpg.ko kernel/drivers/media/common/videobuf2/videobuf2-dma-contig.ko kernel/drivers/media/v4l2-core/v4l2-dv-timings.ko kernel/drivers/media/cec/cec.ko kernel/drivers/media/rc/rc-core.ko kernel/drivers/media/common/videobuf2/videobuf2-vmalloc.ko kernel/drivers/media/common/videobuf2/videobuf2-memops.ko kernel/drivers/media/common/videobuf2/videobuf2-v4l2.ko kernel/drivers/media/common/videobuf2/videobuf2-common.ko kernel/drivers/media/v4l2-core/videodev.ko kernel/drivers/media/mc/mc.ko
把这些模块全部都拷贝到文件系统里面:
    #!/bin/bash
    abs_dir=/home/prb/cve-2019-18683/linux-5.4
    cp $abs_dir/drivers/media/platform/vivid/vivid.ko vivid.ko
    cp $abs_dir/drivers/media/common/v4l2-tpg/v4l2-tpg.ko v4l2-tpg.ko
    cp $abs_dir/drivers/media/common/videobuf2/videobuf2-dma-contig.ko videobuf2-dma-contig.ko
    cp $abs_dir/drivers/media/v4l2-core/v4l2-dv-timings.ko v4l2-dv-timings.ko
    cp $abs_dir/drivers/media/cec/cec.ko cec.ko
    cp $abs_dir/drivers/media/rc/rc-core.ko rc-core.ko
    cp $abs_dir/drivers/media/common/videobuf2/videobuf2-vmalloc.ko videobuf2-vmalloc.ko
    cp $abs_dir/drivers/media/common/videobuf2/videobuf2-memops.ko videobuf2-memops.ko
    cp $abs_dir/drivers/media/common/videobuf2/videobuf2-v4l2.ko videobuf2-v4l2.ko
    cp $abs_dir/drivers/media/common/videobuf2/videobuf2-common.ko videobuf2-common.ko
    cp $abs_dir/drivers/media/v4l2-core/videodev.ko videodev.ko
    cp $abs_dir/drivers/media/mc/mc.ko mc.ko
然后在系统启动的时候insmod，注意加载的顺序， lsmod 查看是否成功加载。
    #!/bin/sh
    currdir=/mod
    insmod $currdir/v4l2-tpg.ko             
    insmod $currdir/v4l2-dv-timings.ko      
    insmod $currdir/rc-core.ko              
    insmod $currdir/videobuf2-memops.ko     
    insmod $currdir/videobuf2-vmalloc.ko    
    insmod $currdir/mc.ko                   
    insmod $currdir/videodev.ko             
    insmod $currdir/videobuf2-dma-contig.ko 
    insmod $currdir/videobuf2-common.ko     
    insmod $currdir/cec.ko                  
    insmod $currdir/videobuf2-v4l2.ko       
    insmod $currdir/vivid.ko
**gdb 调试**
gdb 调试前还需要先把模块的符号加载好，每次模块的加载地址都不一样，这里我直接写了个脚本暴力找模块加载地址，然后每次系统启动的时候运行
    #!/bin/sh
    #modprobe vivid
    linux=/home/prb/cve-2019-18683/linux-5.4
    vivid=$linux/drivers/media/platform/vivid/vivid.ko
    videodev=$linux/drivers/media/v4l2-core/videodev.ko
    v4l2_tpg=$linux/drivers/media/common/v4l2-tpg/v4l2-tpg.ko
    v4l2_dv_timings=$linux/drivers/media/v4l2-core/v4l2-dv-timings.ko
    videobuf2_v4l2=$linux/drivers/media/common/videobuf2/videobuf2-v4l2.ko           
    videobuf2_dma_contig=$linux/drivers/media/common/videobuf2/videobuf2-dma-contig.ko     
    videobuf2_vmalloc=$linux/drivers/media/common/videobuf2/videobuf2-vmalloc.ko        
    videobuf2_common=$linux/drivers/media/common/videobuf2/videobuf2-common.ko         
    cec=$linux/drivers/media/cec/cec.ko
    mc=$linux/drivers/media/mc/mc.ko
    echo "add-symbol-file $vivid" `cat /proc/modules  |grep '^vivid' | awk -F ' ' '{print $6}'` 
    echo "add-symbol-file $videodev" `cat /proc/modules  |grep '^videodev' | awk -F ' ' '{print $6}'` 
    echo "add-symbol-file $v4l2_tpg" `cat /proc/modules  |grep '^v4l2_tpg' | awk -F ' ' '{print $6}'`
    echo "add-symbol-file $v4l2_dv_timings" `cat /proc/modules  |grep '^v4l2_dv_timings' | awk -F ' ' '{print $6}'`
    echo "add-symbol-file $videobuf2_v4l2" `cat /proc/modules  |grep '^videobuf2_v4l2' | awk -F ' ' '{print $6}'` 
    echo "add-symbol-file $videobuf2_dma_contig" `cat /proc/modules  |grep '^videobuf2_dma_contig' | awk -F ' ' '{print $6}'` 
    echo "add-symbol-file $videobuf2_vmalloc" `cat /proc/modules  |grep '^videobuf2_vmalloc' | awk -F ' ' '{print $6}'`
    echo "add-symbol-file $videobuf2_common" `cat /proc/modules  |grep '^videobuf2_common' | awk -F ' ' '{print $6}'` 
    echo "add-symbol-file $cec" `cat /proc/modules  |grep '^cec' | awk -F ' ' '{print $6}'` 
    echo "add-symbol-file $mc" `cat /proc/modules  |grep '^mc' | awk -F ' ' '{print $6}'
例如我的 qemu 跑起来后是这样的
然后运行gdb(pwndbg插件)，拷贝命令加载符号之后就可以正常调试了。
###  poc 测试
先下载好[Alexander
Popov](https://a13xp0p0v.github.io/)提供的[poc](https://a13xp0p0v.github.io/img/v4l2-crasher.c)
poc 很简单，就开了两个线程，`open("/dev/video0")`,`read(fd, buf, 0xfffded);` 然后是`close`,
不断循环。
为了提高竞争的成功率，这里还指定了线程固定在哪个CPU上运行，比如所线程1就运行在CPU0，线程2运行在CPU1这样。
编译，然后跑一下，为了方便自己调试的时候都是使用的root权限
    gcc -s --static  -o exp exp.c -lpthread
得到的 crash如下:
但是我没有办法得到和[Alexander Popov](https://a13xp0p0v.github.io/)一样的crash,
根据[他的文章](https://a13xp0p0v.github.io/2020/02/15/CVE-2019-18683.html)中的描述，漏洞是因为`vivid_stop_generating_vid_cap`函数在调用`kthread_stop`之前unlock
了 `dev->mutex`
        /* shutdown control thread */
        vivid_grab_controls(dev, false);
          - mutex_unlock(&dev->mutex);
        kthread_stop(dev->kthread_vid_cap);
        dev->kthread_vid_cap = NULL;
          - mutex_lock(&dev->mutex);
`dev->kthread_vid_cap` 保存的是函数`vivid_thread_vid_cap`,它是一个内核线程，`kthread_stop`
之后会结束这个线程。本来是打算`vivid_stop_generating_vid_cap` unlock `dev->mutex`
之后，这个锁就可以被这个内核线程拿到，然后break出循环。但是这个锁也是可以被`vb2_fop_read` 函数拿到，于是就有了竞争。
          for (;;) {
              try_to_freeze();
              if (kthread_should_stop())
                  break;
      -        mutex_lock(&dev->mutex);
      +        if (!mutex_trylock(&dev->mutex)) {
      +            schedule_timeout_uninterruptible(1);
      +            continue;
      +        }
              ...
          }
补丁是把`vivid_stop_generating_vid_cap` 解锁的过程去掉了，但是`vivid_thread_vid_cap`
还是会获取锁，文章中还写了补丁的修改过程挺有趣的。在close
的时候，会调用[`vivid_fop_release`](https://elixir.bootlin.com/linux/v5.4/source/drivers/media/platform/vivid/vivid-core.c#L441)
函数，接着调用[_vb2_fop_release](https://elixir.bootlin.com/linux/v5.4/source/drivers/media/common/videobuf2/videobuf2-v4l2.c#L1034)
    int _vb2_fop_release(struct file *file, struct mutex *lock)
    {
        struct video_device *vdev = video_devdata(file);
        if (lock)
            mutex_lock(lock);
        if (file->private_data == vdev->queue->owner) {
            vb2_queue_release(vdev->queue);
            vdev->queue->owner = NULL;
        }
        if (lock)
            mutex_unlock(lock);