A团队
大木 (28)
逸见（19)
B团队
新蒂（23）
山田( 40 )
久本（29）
D团队
C团队
野野宫(28)
桥田(30}
鬼爆(28)
加募（24）
新城(22 )
一般情况下集合用圆来表示，本书中其他章节也都是用圆来画维恩图
的。但是，为了使“分割”（cut）操作看起来更直观，这里故意使用了直
线来划分子集。
接下来我们重点关注一下划分出的子集。可以发现它们有下面这3个
性质。
1.它们全都是非空集合。
2.所有子集的并集等于划分之前的集合。
3.任何两个子集之间都没有交集。
图灵社区会员 非洲钢(PI:EMAIL) 专享尊重版权
---
## Page 253
240—第2章关系数据库的世界
因为这些子集都是通过表中存在的“team”列的值分割出来的，所以
注0
不可能存在空集·。而且，将分割后的子集全部加起来，很明显就是原来
逐有种只包含 ML 的集合
这昕起来有点奇怪，但是它和空
的集合。换句话说，分割之后不存在没有归属的成员。
集不同。如果“tosm”列存在空
值, NL 也会成为分类的列。
还有，不存在同时属于两个子集（=同时属于多个团队）的成员。一
而且,数学中规定，如果原来的
集合是空奖,那么分剂出来的类
个成员一定只属于分割后的某个子集。所以我们也可以认为，GROUPBY
av在这种情况下也会生成空集。
也是—个空集。 5UL 中的 akoP
和PARTITIONBY都是用来划分团队成员的函数。
在数学中，满足以上3个性质的各子集称为“类”（partition），将原
来的集合分割成若干个类的操作称为”分类”这些都是群论等领域的术语。
SQL中 PARTITIONBY子句的名字就来自于类的概念（即 partition）。
虽然我们可以让GROUPBY子句也使用这个名字，但是因为它在分类之后
会进行聚合操作，所以为了避免歧义而采用了不同的名字，一般来说，我
们可以采取多种方式给集合分类。在SQL中也一样，如果改变GROUPBY
和 PARTITION BY的列，生成的分组就会随之变化。
在SQL中，GROUP BY的使用非常频繁，由此可以知道我们身边存在
着很多类。例如学校中的班级和学生的出生地等。没有学生的班级是没有
存在意义的，而出生地为两个省的人应该也是不存在的（出生地不详的人
可能会有，但是这样的人应该属于列为NULL的类）。
扑克牌的卡片也一样。52张卡片根据花型可以分为4类，根据颜色
可以分为红色和黑色两类。属于同一类的元素满足相同的标准，就像朋友
一样一至少比与不同类的元素之间的关系近一些（数学上这种关系称为
，
在群论中，根据分类方法不同，分割出来的类有各种各样的名字。群
论中有很多非常有趣的类，比如“剩余类”。正如其名，它指的是通过对
整数取余分割出的类（一般来说类不一定都是数的集合，不过现在我们只
考虑数的情况）
例如，通过对3取余给自然数集合N分类后，我们会得出下面3个类。
余0的类：M1=(0,3,6,9,}
余1的类：M2={1,4,7,10,·}
余2的类：M2=[2,5,8,11,)}
---
## Page 254
25  GROUP BY 和 PARTITION BY 
241
从类的第2个性质我们知道，这3个类涵盖了全部自然数。可以用下
面的公式来描述这种情况。
M1 + M2 + M3 = N
我们将这3个类称为“模3剩余类”。模指的是除数，英文是
Modulo。与类相比，模的概念稍微有些抽象，不太好理解。
模在SQL中也有实现，就是取模函数NOD.虽然标准SQL中没有定
义它，但是大部分数据库中都有实现（SQLServer中使用运算符）。在
SQL中一般是下面这样的用法。
--对从1到10的整数以3为模求剩余类
SELBCT MOo (mun, 3) AS modulo,
mun
FROM Natural
ORDER BY nodulo, oun,
■执行结果
modulonun
0
余0的类
安
余1的类
10
2
余2的类
剩余类也有很多有趣的性质，可以有广泛的应用。举一个例子，求剩
余类会将自然数集合分割成大小相等的一些类，所以在需要从大量数据中
按照特定比例抽样的时候非常方便。例如，使用下面的查询语句可以随机
地将数据减为原来的五分之一（表中没有连续编号的列时，使用ROW
NUMBER函数重新编号就可以了）
---
## Page 255
242—第2章关系数据库的世界
--从原未的表中独出（大约】五分之一行的数据
SELSCT *
FROM SomeTb1
MHERE MOD (seg,。  5) = 0;
--表中没有连续编号的列时，使用ROM_MUMBER函数就可以了
SELSCT *
FROM (SELECT col,
EOW_NUIMBER 1)OVER IORDER BY co1)  AS Beq
FROM SomeTb1)
MHERE MOD(seg,。  5) = 0;
当然，实际上表中数据的行数未必刚好是5的倍数，所以剩余类之间
的大小也不一定相等。但是，上面的查询语句肯定满足“随机地等分数据
这一随机抽样的需求。
读到这里，对于GROUP BY和 PARTITION BY的执行过程，以及它们
的数学基础，大家是否有了更深的理解呢？总地来说就是，SQL和关系数
据库中大量引入了集合论、群论中的成果。
可能大家会觉得这些内容有些抽象一—好吧，确实很抽象一—但是正
因为抽象，才有了广泛的应用。数学理论并不是脱离实际的游戏，它其实
隐藏了大量能够用于日常工作的技巧。但是如果只是等待，很难发现它们
的身影。工程师们只有通过自身的努力，在理论和实践之间搭建起连通的
桥梁，才能提高自身的数学应用能力。
---
## Page 256
2-6从面向过程思维向声明式思堆、面向集合思堆转变的7个关键点一
243
从面向过程思维向声明式思维、
面向集合思维转变的7个关键点
画圆
很多软件工程师在习惯了C、COBOL、Java、Per等面向过程（至少以此为基础的）语言之后，不
管再使用什么语言都会不由自主地用面向过程的思维方式来思考问题。但是，对于SQL这种非面向过程
语言，如果想灵活运用，就必须理解它独特的原理和机制。
学习以SQL的思维方式来思考问题，对于很多程序员来说都是一个挑
战。相信你们中的大多数，在职业生涯的大部分时间里都在编写面向过程
语盲的代码。如果有一天，你们必须编写非面向过程语盲的代码了，那么
最重要的就是将顺序的思维方式改为集合的思维方式。
注0
Joe Celko, Thinking rin S0L
—Joe Celko
I http://wxv, dbaz Ine,com
oflrntenest,Ab/-articles/oelio5/)
正如Joe Celko所说，学习SQL的思维方式时，最大的阻碍就是我们
已经习惯了的面向过程语言的思维方式。具体地说，就是以赋值、条件分支、
循环等作为基本处理单元，并将系统整体分割成很多这样的单元的思维方
式。同样地，文件系统也是将大量的数据分割成记录这样的小单元进行处
理的。不管是面向过程语言还是文件系统，都是将复杂的东西看成是由简
注
单单元组合而成的一这是一种还原论的思维方式。
是一种认为可以把高组规象还原
为低级的基本现象的学说。
SQL的思维方式，从某种意义上来说刚好相反。SQL中没有赋值或
一编者注
者循环的处理，数据也不以记录为单位进行处理，而以集合为单位进行处
注
亦称“机体论”。用系统的，整
理。SQL和关系数据库的思维方式更像是一种整体论·的思维方式
体的观点考察有机界的理论。
如果硬要以面向过程的方式写SQL语句，写出的SQL语句要么长且
一编者注
复杂，可读性不好，要么大量借助于存储过程和游标，这样就又会回到已
经习惯的面向过程的世界。
为了然练掌握SQL，我们必须理解并运用支配SQL和关系数据库世
界的独特原理。原理或者理论只靠理解是不够的，我们必须在实际工作中
使用它们，才能让它们发挥作用。这也是贯穿全书的一个观点。发挥出全
图灵社区会员非洲铜(PI:EMAIL)专享尊重版权
---
## Page 257
244—第2章关系数据库的世界
部功能的SQL，其表达能力丝毫不逊十面向过程语言。
本节将总结几个关键点，帮助大家将面向过程的思维习惯转换为SQL
的思维习惯。如果这些关键点能有效地帮助大家在日常工作中实践面向集
合的思维方式，笔者将倍感欣慰。
1.用CASE表达式代替IF语句和CASE语句。SQL
更像一种函数式语言
在面向过程语言中，条件分支是以“语句”为单位进行的。而在SQL
中，条件分支是以语句中的“表达式”为单位进行的。SQL还可以在一个
SELECT语句或UPDATE语句中，表达与面向过程语言一样非常复杂而且
灵活的条件分支，不过这需要借助CASE表达式。
为CASE表达式与1+[2-4）或者（x*y)/z一样，都是表达式，在执行时会
被整体当作一个值来处理。既然同样是表达式，那么能写1+1这样的表达
注0
式的地方就都能写CASE表达式·，而且因为CASE表达式最终会作为一
更通备地统，在期写常量的地方
都可以写GE表达式。常量可
个确定的值来处理，所以我们也可以把CASE表达式当作聚合函数的参数
以理解成“交量个数为0的表达
式”。
来使用。
笔者曾经见过一些局限于面向过程语言的思维方式的写法，以语句为
单位进行条件分支从而导致写出的SQL语句非常肿的事例。其实如果
以“表达式”为单位进行条件分支，那么用非常简洁且易读的代码就能达
成同样的效果。
对于任意输入返回的都是一个值一—从这个角度来说，我们还可以把
CASE表达式看作一种商数。因此使用CASE表达式时的思维方式与使用函
数式语言时是相似的。Lisp语言也支持使用cond或case来描述条件分支，
但是它们都是函数，这一点和面向过程语言中的rr语句不同。因此Lisp
语言与CASE表达式一样，不是以语句而是以表达式（函数）为单位进行
条件分支的，返回的结果都是一个值（Lisp中的列表也可以看成一个值，
这一点与SQL不同，但是相信将来SQL也可以处理复合型的数据）。
下面列举了两者的写法，比较一下。
---
## Page 258
2-6从面向过程思维向声期式思雄、面向集合思堆转变的7个关键点—245
Lia中使用cond函数进行条件分支
1puoo
(=x 1)x是1")
wx,( x =1)
(tx是1和2以外的数})
--SQL中使用CASB表达式进行条件分支
TX, NEHL T =X N3 SYO
MHENX-2THENx是2
BLSEx是1 和 2 以外的数
BND
可以看到，除了Lisp代码中使用了波兰式写法之外，两者实现的功
能都是一样的。因为条件中可以嵌套条件，所以支持表达多层条件分支，
这一点也是相同的。因此已经习惯函数式语言的人应该很容易理解SQL
中的CASE表达式，反过来说也是一样的。由此可见，找到让编程语言互
相连通的关键点，加深对多种编程语言的理解是非常重要的。
参考→1-3节
2.用GROUPBY和关联子查询代替循环
SQL中没有专门的循环语句。虽然可以使用游标实现循环，但是这
样的话还是面向过程的做法，和纯粹的SQL没有关系。SQL在设计之初，
就有意地避免了循环。这一点，我们从Cod的话中就可以明白。
在关系操作中，应该将关系整体作为操作的对象。目的是班免环。
显然，这是提高数据查询终端用户的生产效率的必要条件，同时也利于提
注0
高应用程序员的生产效事。·
携白（关系数报库：生产力的实
用基础)
面向过程语言在循环时经常用到的处理是“控制、中断”。在SQL中，
这两个处理可以分别用GRCUPBY子句和关联子查询来表达。其中，对于
SQL语言的初学者来说，关联子查询可能不太好理解，但是这个技术非
常适合用来分割处理单元。面向过程语言中使用的循环处理完全可以用这
两个技术代替。
笔者曾经听说过一些让人哭笑不得的写法，比如原本用GROUPBY聚
合一下就能实现的功能，写SQL的人因为执于面向过程语言的思维方式，
---
## Page 259
246—第2章关系数据库的世界
非要先用SELECT选出需要的行然后冉使用游标一行一行地聚合。
请大家牢记，SQL中没有循环，而且没有也并不会带来什么问题。
因为去掉普通编程语言中的循环正是SQL语言设计之初的目的之一。
参考→1-6节、1-7节
3.表中的行没有顺序
已经习惯面向过程语言和文件系统的工程师们（这儿乎包括所有工程
从某种意义上来说，这也是没有办法的事情。在理解未知的概念时，
我们首先会根据已经理解的概念去理解一—这是一种行之有效的方法，也
几乎是唯一的方法。但是在理解达到某种程度之后，我们必须放弃对旧概
念的依赖。将表看成文件的最大问题是会误认为表中的行是有顺序的。
对于文件来说，行的顺序是非常重要的。打开文本文件时，如果各行
按照随机的顺序展示，那么文件是没法使用的。但是在关系数据库中，从
表中读取数据时的的确确会发生这样的情况。读出的数据不一定是按照
INSERT的顺序排列的，因为 SQL在处理数据时不需要它们这样。SQL在
处理数据时可以完全不依赖顺序。
关系数据库中的表（关系）是一种数学上的“集合”。表有意地放弃了
行的顺序这一形象的概念，从而使它具有了更高的抽象度。文件和表原本
就是不同的概念，两者之间自然会有些不一致。与其将表比作排列整齐
如果没有意识到这一点而继续依赖顺序，那么我们就容易写出复杂无
用且可移植性不好的代码。例如，在定义视图时指定ORDERBY子句（如
注0
果某种数据库支持这种写法，那么它本身就有间题），或者轻易地使用
“量子力学”详细指述的是物质
和允的性果,特别是原子级的规
象。因为量子是非管非常细小的
顺序的不好的写法。
东西，所以和大家日常接触的东
两波有任何相似性。它不像发
物理学泰斗费恩曼（Richard PhillipsFeynman）曾经这样告诚即将开
动。也不像粒子。和云、撞由退
动、弹簧释等一切大康见到过的
始学习量子力学的学生们：理解这门新学问时，不要和你们学习过的牛顿
东西都不—样。 Me Ffeynal
力学进行类比，量子和你们至今为止了解过的任何东西都不一样·
Lectures or Physics, Addisor
esley, 1965 年 1
学习新的概念时，我们需要暂时舍弃掉旧的概念，或者最起码要把旧
---
## Page 260
2-6从面向过程思维向声明式思堆、面向集合思堆转变的7个关键点—247