（比如A用户买了北京到天津的，B用户买了天津到上海的同一趟车的同一个座位，那么应该设计合理的合并操作（如数据库内核改进）或者从设计上避免锁等待）  
其实就是把座位的空间维度（从哪里到哪里）、本身的属性（座位号）、时间维度（发车日期）进行解耦，放到多条记录中，从而在购买时，可以同时进行。   
因为数据库中最小的锁目前是行锁（单行记录同一时刻只允许一个会话进行更新，其他的被堵塞，等待释放锁），也许随着技术的发展，会演变成列锁，或者列里面的元素锁（比如数组，JSON）。    
6\. 车次的变更简直是牵一发而动全身，比如余票统计会跟着变化，查询系统也要跟着变化。  
还有初始化信息的准备，例如为了加快购票的速度，可能会将车次的数据提前准备好（也许是每个座位一条记录），参考第3个需求的解说。    
综合以上痛点和需求分析，我们在设计时应尽量避免锁等待，避免实时余票查询，同时还要避免席位空洞。    
## 二、猴子请来的救兵来啦  
经过前面的分析，已经把铁路售票系统最关键的几个业务场景进行了描述，并且阐述了其中的设计痛点，那么我们如何设计合理的系统来满足几亿人民抢票的需求呢？   
西游记里每一集孙悟空师父被妖怪抓走，总能找到救兵来解救。   
我们也需要救兵，救兵快来啊。。。。     
PostgreSQL是全世界最高级的开源数据库，几乎适用于任何场景。    
有很多特性是可以用来加快开发效率，满足架构需求的。     
针对铁路售票系统，可以用到哪些救命法宝呢？      
1\. 法宝1，varbit类型   
使用varbit存储每趟车的每个座位途径站点是否已销售。    
例如 G1921车次，从北京到上海，途径天津、徐州、南京、苏州。包括起始站，总共6个站点。   那么使用6个比特位来表示。    
```
'000000'     
```
如果我要买从天津到徐州的，这个值变更为(下车站的BIT不需要设置)   
```
'010000'     
```
这个位置还可以卖从北京到天津，从徐州到终点的任意站点。    
余票统计也很方便，对整个车次根据BIT做聚合计算即可。    
统计任意组合站点的余票（ 北京-天津, 北京-徐州, 北京-南京, 北京-苏州, 北京-上海, 天津-徐州, 天津-南京, ......, 苏州-上海 ）    
```
udf_count(varbit) returns record    
```
统计指定起始站点的余票（start: 北京, end: 南京； 则返回的是 北京-南京 的余票）    
```
udf_count(varbit, start, end) returns record    
```
以上两个需求，开发对应的聚合函数即可，其实就是一些指定范围的bitand的count操作。     
通过法宝1，解决了统计余票的需求、售票无空洞的需求。  
2\. 法宝2，数组类型   
使用数组存储每趟车的起始站点，途经站点。     
使用数组来存储，好处是可以使用到数组的GIN索引，快速的检索哪些车次是可以搭乘的。    
例如查询从北京到南京的车次。    
```
select 车次 from 全国列车时刻表 where column_arr @> array['北京','南京'];  
```
这条SQL是可以走索引的，效率非常高，每秒请求几十万不是问题。   
法宝2解决了高并发请求查询符合条件的列车信息的需求。       
3\. 法宝3，skip locked    
这个特性是跳过已被锁定的行，比如用户在购买某一趟从北京到南京的车票时，其实是一次UPDATE ... SET BIT的操作。    
但是很可能其他用户也在购买，可能就会出现锁冲突，为了避免这个情况发生，可以skip locked，跳过锁冲突，直接找另一个座位。    
```
select * from table   
  where column1='车次号'   -- 指定车次  
  and column2='车次日期'   -- 指定发车日期  
  -- and mod(pg_backend_pid(),100) = mod(pk,100)   -- 提高并发，如果有多个连接并发的在更新，可以直接分开落到不同的行，但是可能某些pID卖完了，可能会找不到票，建议不要开启这个条件  
  and column4='席别'  -- 指定席别  
  and getbit(column3, 开始站点位置, 结束站点位置-1) = '0...0'  -- 获取起始位置的BIT位，要求全部为0  
  order by column3 desc   -- 这个目的是先把已经卖了散票的的座位拿来卖，也符合铁大哥的思想，尽量把起点和重点的票卖出去，减少空洞  
  for update  
  skip locked  -- 跳过被锁的行，老牛逼了，不需要锁等待  
  limit ?;     -- 要买几张票  
```
法宝3解决了一伙人来抢票时，在同一趟车的座位发生冲突的问题。   
4\. 法宝4，cursor  
如果要查询大量记录，可以使用cursor，减少重复扫描。  
5\. 法宝5，路径规划  
如果用户选择直达车已经无票了，可以自动计算如何转乘，根据用户的乘车站点和目的地选择最佳搭乘路线。    
参考一下pgrouting，与物流的动态路径规划需求一致。    
[《聊一聊双十一背后的技术 - 物流, 动态路径规划》](../201607/20160710_01.md)      
6\. 法宝6，多核并行计算  
开源也支持多核并行计算的，在生成余票统计时，为了提高生成速度，可以将更多的CPU加入进来并行计算，快速得到余票统计。    
就比如你策划了一本书，已经列好了大纲，同时你找了100个作者，这100个作者可以根据你分配的工作，同时开始写作，很快就能把一本书写完。   
而传统的情况，一本书，只能一个作者帮你写，即使你找了100个作者，另外的99位也只能空闲，或者他们只能写其他的99本书。    
7\. 法宝7，资源隔离  
PostgreSQL为进程模型，所以可以控制每个进程的资源开销，包括(CPU,IOPS,MEMORY,network)，在铁路售票系统中，查询和售票是最关键的需求，使用这种方法，可以在关键时刻保证关键业务有足够的资源，流畅运行。  
这个思想和双十一护航也是一样的，在双十一期间，会关掉一些不必要的业务，保证主要业务的资源，以及它们的流畅运行。    
8\. 法宝8，分库分表  
铁路数据达到了海量数据的级别，很显然一台机器无法存下所有的铁路数据。    
那么怎么办呢？ 可以将铁路的数据进行分区存储，存到不同的主机。      
PostgreSQL的分库分表方案很多，例如plproxy, pgpool-II, pg-xl, pg-xc, citus等等.    
9\. 法宝9，递归查询   
铁路有非常典型的上下文相关特性，例如一趟车途径N个站点，全国铁路组成了一个很大的铁路网。  
递归查询可以根据某一个节点，向上或者向下递归搜索相关的站点。  
比如在有哪些车可以直达北京，有哪些车可以转车到达北京，又或者查询从北京到拉萨，有哪些线路以及途经线路可以走。   
![pic](20161124_02_pic_003.gif)    
10\. 法宝10，MPP    
为了持续的提高12306的体验，铁大哥还有数据挖掘的需求，比如今年春节应该对哪些线路增加车次，每天的车次增加的规划，哪些线路可以减少车次也能在春节前将用户送回家。   
这些问题可以基于以往的运输数据进行挖掘计算，进行回答。    
基于PostgreSQL的MPP产品很多，例如Postgres-XL, Greenplum, Hawq, REDSHIFT, paraccl, 等等。    
使用PG可以和这些产品很好的融合，保持语法一致。   
降低数据分析的开发成本。    
猴子请来的救兵厉害吧，还有更厉害的，阿里云在PostgreSQL基础上做了很多的改进，比对对于12306的系统，就有特别的定制特性。   
## 三、阿里云PostgreSQL varbit, array增强介绍  
在铁路购票系统中，有几个需求需要用到bit和array的特殊功能，这些特殊的功能目前社区版本没有，阿里云RDS PostgreSQL对此做了增强，如下。    
1\. 余票统计  
统计指定bit范围=全0的计数  
不指定范围，查询任意组合的bit范围全=0的计数  
2\. 购票  
指定bit位置过滤、取出、设置对应的bit值    
根据数组值取其位置下标。    
回顾一下我之前写的两篇文章，也是使用varbit的应用场景，有异曲同工之妙        
[《基于 阿里云 RDS PostgreSQL 打造实时用户画像推荐系统》](../201610/20161021_01.md)         
[《门禁广告销售系统需求剖析 与 PostgreSQL数据库实现》](20161124_01.md)      
PostgreSQL的bit, array功能已经很强大，阿里云RDS PostgreSQL的bitpack也是用户实际应用中的需求提炼的新功能，大伙一起来给阿里云提需求。      
打造属于国人的PostgreSQL吧。           
## 四、数据库设计(伪代码)  
讲了这么多，最后提供一些伪代码，帮助大家来理解一下。  
1\. 列车信息表 :     
```  
create table train     
(id int primary key, --主键    
go_date date, -- 发车日期    
train_num name, -- 车次    
station text[] -- 途径站点数组    
);     
```  
2\. 位置信息表 :     
```  
create table train_sit     
(id serial8 primary key, -- 主键    
tid int references train (id), --关联列车ID    
bno int, -- 车厢或bucket号    
sit_level text, -- 席别  
sit_no int,  -- 座位号  
station_bit varbit  -- 途径站点组成的BIT位信息, 已售站点用1表示, 未售站点用0表示. 购票时设置起点和终点-1, 终点不设置   
);    
```   
3\. 测试数据模型, 1趟火车, 途径14个站点.    
```  
insert into train values (1, '2013-01-20', 'D645', array['上海南','嘉兴','杭州南','诸暨','义乌','金华','衢州','上饶','鹰潭','新余','宜春','萍乡','株洲','长沙']);    
```  
4\. 插入测试数据, 共计200W个车厢或bucket, 每个车厢98个位置.    
```  
insert into train_sit values (id, 1, id, '一等座', generate_series(1,98), repeat('0',14)::varbit) from generate_series(1,1000000) t(id);    
insert into train_sit values (id, 1, id, '二等座', generate_series(1,98), repeat('0',98)::varbit) from generate_series(1000001,2000000) t(id);    
```  
5\. 创建取数组中元素位置的函数 (实际生产时可以使用C实现) :     
```  
create or replace function array_pos (a anyarray, b anyelement) returns int as $$    
declare    
  i int;    
begin    
  for i in 1..array_length(a,1) loop    
    if b=a[i] then    
      return i;    
    end if;    
    i := i+1;    
  end loop;    
  return null;    
end;    
$$ language plpgsql;    
```  
6\. 创建购票函数 (伪代码) :      
下单，更新    
```  
create or replace function buy     
(    