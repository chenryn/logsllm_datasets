    接下来我们就尝试对此应用实施攻击。诱导用户使用以下 URL
    访问应用并使其输入个人信息。
    ``` 代码无行号
    http://example.jp/463/46-020.php?PHPSESSID=ABC
    ```
    受害用户输入自己的个人信息，如下图所示。
    ![{%}](Image00103.jpg)
    **图 4-58 受害用户输入个人信息**
    而在另一边，攻击者会定期监视刚才的 URL
    页面。当用户输入个人信息后，如下图所示，攻击者的浏览器中也能显示用户的个人信息。
    ![{%}](Image00104.jpg)
    **图 4-59 受害用户的个人信息显示在攻击者的浏览器中**
    由此可见，不需要认证的网页如果使用了会话变量，也可能会遭受会话固定攻击。
    但是，由于此情况下攻击者无法伪装成登录后的用户，也无法使用用户的权限进行恶意操作，因此攻击造成的影响就仅限于用户输入的信息被泄漏。
-   **会话采纳**
    前面所介绍的攻击流程中使用了 PHPSESSID=ABC 这个会话
    ID。我们发现，虽然 ABC
    是攻击者任意生成的，但是也能够使攻击得到成功。这是因为能够接受来源不明的会话
    ID 是 PHP 的特性之一。而此特性就被称为会话采纳（Session
    Adoption）。除了 PHP，ASP.NET 中也存在会话采纳的特征。而 PHP 和
    ASP.NET 以外的中间件，如 Tomcat
    等则不存在会话采纳，这种情况下，随意生成的会话 ID 就会被忽略。
    在对不存在会话采纳的中间件上运行的应用程序发动攻击时，攻击者会先浏览攻击目标应用，取得有效的会话
    ID，然后再利用此会话 ID 布置恶意网站。
    由此可见，开发工具中若存在会话采纳就能减少会话固定攻击的步骤，然而，即便不存在会话采纳问题，会话固定攻击也不可能被完全杜绝。
-   **仅在 Cookie 中保存会话 ID 的网站固定会话 ID**
    之前介绍的攻击示例中，我们使用的都是能够将会话 ID 保存在 URL
    中的应用程序。这是因为会话 ID 保存在 URL
    的情况下攻击起来比较容易。然而，仅将会话 ID 保存在 Cookie 时，会话
    ID 还是有可能会被固定化。
    通常情况下，从外部设置 Cookie 的会话 ID
    是行不通的，但是，如果浏览器或 Web
    应用中存在安全隐患就另当别论了。比如，以下安全隐患就有可能造成
    Cookie 被第三方设置。
    -   Cookie Monster Bug（浏览器的安全隐患，参考 3.1 节）
    -   跨站脚本漏洞（参考 4.3 节）
    -   HTTP 消息头注入漏洞（参考 4.7.2）
-   **会话固定攻击的影响**
    一旦会话固定攻击取得成功，由于中招的用户（前例中为
    tanaka）已处于登录状态，攻击者就能够使用该用户的权限执行操作或浏览信息等。
#### **安全隐患的产生原因**
固定会话 ID 安全隐患产生的根本原因为外界能够劫持会话
ID。因此，彻底应对就需要实施以下所有步骤。
-   不将会话 ID 嵌入 URL
-   不使用（或不让用户使用）存在 Cookie Monster Bug[39]{.注释编号}
    的浏览器
-   不使用易发生 Cookie Monster Bug 的地域型域名
-   消除跨站脚本漏洞
-   消除 HTTP 消息头注入漏洞
-   消除其他能够导致 Cookie 被篡改的安全隐患
[39]{.注释编号下} Cookie Monster Bug 的详情请参考 3.1 节的专栏。
但是，想要满足以上所有条目并不简单。比如 Internet Explorer
中使用地域型域名时就存在 Cookie Monster
Bug，而微软似乎并没有打算修复该问题。然而，Internet Explorer
又是使用率最高的浏览器，我们不可能强迫所有用户将其舍弃。
因此，目前采取的普遍做法是，姑且允许会话 ID
被外界挟持，而将防范重点放在防止会话固定攻击造成会话劫持上。
在认证成功时更改会话 ID 就是一种行之有效的方法，具体会在后面详述。
#### **对策**
正如前面所介绍的那样，会话 ID
被外界固定化的手段多种多样，有时还会恶意利用浏览器的
Bug（安全隐患），因此，Web 应用中防范会话固定攻击可以采取如下策略。
-   认证后更改会话 ID
PHP 中执行此处理可以使用 `session_regenerate_id`
函数。该函数的格式如下。
> **格式清单 session_regenerate_id 函数**
``` 代码无行号
bool session_regenerate_id([bool $delete_old_session = false])
```
`session_regenerate_id`
函数中有一个可省略的参数。但由于该参数会指定是否将变更前的会话 ID
对应的会话信息删除，所以应始终将该参数指定为 `true` 。
下面为添加了更改会话 ID 这一处理的脚本。
> **代码清单 /463/46-011a.php**
     登录成功 
     个人信息 
-   **无法更改会话 ID 时采用令牌**
    有些 Web 应用的开发语言或中间件无法在程序中显式地更改会话
    ID。使用此类开发工具时，可以使用令牌来防范会话固定攻击。
    具体方法为，在登录时生成一个随机数字符串（令牌），并将其同时保存至
    Cookie 和会话变量中。然后在各页面进行认证确认时比较 Cookie
    和会话变量中的令牌值，如果两者一致即视为已认证，不一致时即视为认证错误。
    由于只有在登录的时候令牌才能够被传到外界，攻击者无法得知令牌值，因此，使用令牌能够成功防御会话固定攻击。
    此外，鉴于令牌需要确保在足够长的时间内无法被预测，生成令牌时应当使用密码学级别的伪随机数生成器。由于
    PHP 中没有提供能够调用伪随机数生成器的函数，因此，这里我们使用"改善
    PHP 的会话 ID 的随机性的方法"中提到的 /dev/urandom 来进行说明。
    以下为登录后生成令牌部分的脚本。
    > **代码清单 /463/46-015.php**
    ``` 代码无行号
     **代码清单 /463/46-016.php**
    ``` 代码无行号
     认证成功  
    ```
    虽然示例中使用的是 PHP，但由于 PHP 中提供了 `session_regenerate_id`
    函数，因此并非一定要使用令牌。然而，由于令牌也能够作为 4.8.2
    节讲述的"Cookie
    的安全属性设置不完善"的对策来使用，因此，某些情况下该方法对 PHP
    开发者来说会非常有用。详情请参考 4.8 节。
-   **登录前的会话固定攻击的对策**
    如果登录前使用了会话变量，要完全防范会话固定攻击就非常困难。这种情况下，比较现实而有效的对策就是，登录前不使用会话管理机制，而使用
    hidden 参数来传递值。
    像电子商务网站的购物车功能这种不得不在登录前使用会话变量的情况下，可以参考以下对策。但要注意的是，这些都不是根本性的对策，而只能通过组合使用来提高防御能力。
    -   不在登录前的会话变量内存储敏感信息
    -   不使用嵌入 URL 的会话 ID
    -   不使用地域型域名
#### **总结**
本节讲述了不完善的会话管理所导致的会话劫持。会话管理是安全性的要害之处，因此，若出现会话劫持的话就会造成巨大影响。
会话管理不完善的对策如下。
-   不自制会话管理机制而使用 Web 应用开发工具的内置功能
-   将会话 ID 保存至 Cookie 中
-   认证成功时更改会话 ID
-   认证前不在会话变量中存储敏感信息
幸运的是，本节所介绍的安全隐患防范策略的实施场所少而明确，实施成本并不高。因此，建议开发者们从设计阶段就开始有计划地落实防范策略。
## **4.7 重定向相关的安全隐患** {#text00000.html#nav_point_34}
Web 应用中有时会重定向至外界指定的
URL。典型案例为，在登录页面的参数中指定 URL，登录成功后再重定向至该
URL。比如使用以下 URL 登录 Google 后，就会重定向到 continue= 指定的
URL（此处为 Gmail）[40]{.注释编号} 。
[40]{.注释编号下} 写作本书时已进行过确认，但将来可能会有所更改。
    https://www.google.com/accounts/ServiceLogin?continue=https://mail.google.com/mail/
重定向处理时产生的安全隐患有如下几种，而且它们都会招致被动攻击。
-   自由重定向漏洞
-   HTTP 消息头注入漏洞
接下来，本节将对以上两种安全隐患进行详细说明。
### **4.7.1 自由重定向漏洞** {#text00000.html#nav_point_35}
#### **概要**
刚才已经提到，有些 Web 应用中提供了能够重定向到参数指定的 URL
的功能，该重定向功能就被称为重定向器（Redirector）。
其中，能够重定向至任意域名的重定向器叫作自由重定向（Open
Redirect）。自由重定向可能会导致用户在不知情的情况下被带到其他域名的网站，从而遭到钓鱼式攻击（Phishing）。
**自由重定向示例**
> \
> 通过以上 URL 跳转至 
钓鱼式攻击的常见手段为，将用户带到伪装成著名网站的恶意网站，并诱使用户输入个人信息。
如果用户信赖的网站存在自由重定向漏洞，用户就可能会在不知不觉中被诱导到恶意网站，却自以为还在浏览自己信赖的网站。此时，即便是戒心很重的用户也会比较轻易地输入自己的个人信息等重要内容。而自由重定向漏洞就常被用于此类狡猾的钓鱼式攻击。
另外，如果软件或设备驱动程序的下载网站存在自由重定向漏洞，就有可能被不法分子利用来散布恶意软件（非法程序）。
为了防范自由重定向漏洞，应该重新评估"外界能够指定重定向目标
URL"的功能是否真的不可或缺，并尽可能将重定向的目标固定。如果实在不能固定重定向的目标，就需要将重定向的目标限制在允许的域名范围内。
**自由重定向漏洞总览**
![{%}](Image00105.jpg)
#### **攻击手段与影响**
接下来我们就来看一下针对自由重定向漏洞的典型攻击模式及其影响。下面是具备重定向功能的密码认证的示例脚本。
> **代码清单 /47/47-001.php**