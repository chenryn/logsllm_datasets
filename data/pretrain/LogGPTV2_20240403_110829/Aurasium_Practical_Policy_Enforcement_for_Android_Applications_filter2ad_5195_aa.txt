title:Aurasium: Practical Policy Enforcement for Android Applications
author:Rubin Xu and
Hassen Sa&quot;ıdi and
Ross J. Anderson
Aurasium: Practical Policy Enforcement for Android Applications
Rubin Xu
Computer Laboratory
University of Cambridge
Cambridge, UK
PI:EMAIL
Hassen Sa¨ıdi
Computer Science Laboratory
SRI International
Menlo Park, USA
PI:EMAIL
Ross Anderson
Computer Laboratory
University of Cambridge
Cambridge, UK
PI:EMAIL
Abstract
The increasing popularity of Google’s mobile platform
Android makes it the prime target of the latest surge in
mobile malware. Most research on enhancing the plat-
form’s security and privacy controls requires extensive
modiﬁcation to the operating system, which has signif-
icant usability issues and hinders efforts for widespread
adoption. We develop a novel solution called Aurasium
that bypasses the need to modify the Android OS while
providing much of the security and privacy that users de-
sire. We automatically repackage arbitrary applications
to attach user-level sandboxing and policy enforcement
code, which closely watches the application’s behavior
for security and privacy violations such as attempts to re-
trieve a user’s sensitive information, send SMS covertly
to premium numbers, or access malicious IP addresses.
Aurasium can also detect and prevent cases of privilege
escalation attacks. Experiments show that we can apply
this solution to a large sample of benign and malicious
applications with a near 100 percent success rate, with-
out signiﬁcant performance and space overhead. Aura-
sium has been tested on three versions of the Android
OS, and is freely available.
1
Introduction
Google’s Android OS is undoubtedly the fastest grow-
ing mobile operating system in the world. In July 2011,
Nielsen placed the market share of Android in the U.S.
at 38 percent of all active U.S. smartphones [9]. Weeks
later, for the period ending in August, Nielsen found that
Android has risen to 43 percent. More important, among
those who bought their phones in June, July, or August,
Google had a formidable 56 percent market share. This
unprecedented growth in popularity, together with the
openness of its application ecosystem, has attracted ma-
licious entities to aggressively target Android. Attacks
on Android by malware writers have jumped by 76 per-
cent over the past three months according to a report by
MacAfee [29], making it the most assaulted mobile op-
erating system during that period. While much of the
initial wave of Android malware consisted of trojans that
masquerade as legitimate applications and leak a user’s
personal information or send SMS messages to premium
numbers, recent malware samples indicate an escalation
in the capability and stealth of Android malware. In par-
ticular, attempts are made to gain root access on the de-
vice through escalation of privilege [37] to establish a
stealthy permanent presence on the device or to bypass
Android permission checks.
Fighting malware and securing Android-powered de-
vices has focused on three major directions. The ﬁrst
one consists of statically [20] and dynamically [12, 36]
analyzing application code to detect malicious activities
before the application is loaded onto the user’s device.
The second consists of modifying the Android OS to in-
sert monitoring modules at key interfaces to allow the
interception of malicious activity as it occurs on the de-
vice [19, 27, 17, 33, 13]. The third approach consists of
using virtualization to implement rigorous separation of
domains ranging from lightweight isolation of applica-
tions on the device [35] to running multiple instances of
Android on the same device through the use of a hyper-
visor [26, 30, 11].
Two fundamental and intertwined problems plague
these approaches. The ﬁrst is that the deﬁnition of ma-
licious behavior in an Android application is hard to as-
certain. Access to privacy- and security-relevant parts
of Android’s API is controlled by an install-time appli-
cation permission system. Android users are informed
about what data and resources an application will have
access to, and user consent is required before the appli-
cation can be installed. These explicit permissions are
declared in the application package. Install-time permis-
sions provide users with control over their privacy, but
are often coarse-grained. A permission granted at install
time is granted as long as the application is installed on
the device. While an application might legitimately re-
quest access to the Internet, it is not clear what connec-
tions it may establish with remote servers that may be
malicious. Similarly, an application might legitimately
require sending SMS messages. Once the SMS permis-
sion is granted, there are no checks to prevent the appli-
cation from sending SMS messages to premium numbers
without user consent. In fact, the mere request for SMS
permission by an application can be deemed malicious
according to a recent Android applications analysis [24],
where it is suggested that 82 percent of malicious ap-
plications require permissions to access SMS. A recent
survey [18] exposes many of the problems [22, 14] as-
sociated with application components interactions, dele-
gation of permission, and permission escalation attacks
due to poor or missing security policy speciﬁcations by
developers. This prompted early work [21] on security
policy extension for Android.
The second problem is that any approach so far that
attempts to enhance the platform’s security and privacy
controls based on policy extensions requires extensive
modiﬁcation to the operating system. This has signiﬁcant
usability issues and hinders any efforts for widespread
adoption. There exists numerous tablet and phone mod-
els with different hardware conﬁgurations, each running
a different Android OS version with its own customiza-
tions and device drivers. This phenomenon, also known
as the infamous Android version fragmentation problem
[16] demonstrates that it is difﬁcult to provide a custom-
built Android for all possible devices in the wild. And
it is even more difﬁcult to ask a normal user to apply
the source patch of some security framework and com-
pile the Android source tree for that user’s own device.
These issues will prevent many OS-based Android secu-
rity projects from being widely adopted by the normal
users. Alternatively, it is equally difﬁcult to bring to-
gether Google, the phone manufacturers, and the cellular
providers to introduce security extensions at the level of
the consumer market, due to misaligned incentives from
different parties.
Our Approach We aim at addressing these challenges
by providing a novel, simple, effective, robust, and de-
ployable technology called Aurasium. Conceptually, we
want Aurasium to be an application-hardening service: a
user obtains arbitrary Android applications from poten-
tially untrusted places, but instead of installing the ap-
plication as is, pushes the application through the Aura-
sium black box and gets a hardened version. The user
then installs this hardened version on the phone, assured
by Aurasium that all of the application’s interactions are
closely monitored for malicious activities, and policies
protecting the user’s privacy and security are actively en-
forced.
Aurasium does not need to modify the Android OS
at all; instead, it enforces ﬂexible security and privacy
polices to arbitrary applications by repackaging to at-
tach sandboxing code to the application itself, which per-
forms monitoring and policy enforcement. The repack-
aged application package (APK) can be installed on a
user’s phone and will enforce at runtime any deﬁned
policy without altering the original APK’s functionali-
ties. Aurasium exploits Android’s unique application ar-
chitecture of mixed Java and native code execution to
achieve robust sandboxing. In particular, Aurasium in-
troduces libc interposition code to the target application,
wrapping around the Dalvik virtual machine (VM) under
which the application’s Java code runs. The target appli-
cation is also modiﬁed such that the interposition hooks
get placed each time the application starts.
Aurasium is able to interpose almost all types of in-
teractions between the application and the OS, enabling
much more ﬁne-grained policy enforcement than An-
droid’s built-in permission system. For instance, when-
ever an application attempts to access a remote site on the
Internet, the IP of the remote server is checked against
an IP blacklist. Whenever an application attempts to
send an SMS message, Aurasium checks whether the
number is a premium number. Whenever an applica-
tion tries to access private information such as the In-
ternational Mobile Equipment Identity (IMEI), the Inter-
national Mobile Subscriber Identity (IMSI), stored SMS
messages, contact information, or services such as cam-
era, voice recorder, or location, a policy check is per-
formed to allow or disallow the access. Aurasium also
monitors I/O operations such as write and read. We eval-
uated Aurasium against a large number of real-world An-
droid applications and achieved over 99 percent success
rate. Repackaging an arbitrary application using Aura-
sium is fast, requiring an average of 10 seconds.
Our main contributions are that
• We have built an automated system to repackage
arbitrary APKs where arbitrary policies protecting
privacy and ensuring security can be enforced.
• We have developed a set of policies that take advan-
tage of advances in malware intelligence such as IP
blacklisting.
• We provide a way of protecting users from mali-
cious applications without making any changes to
the underlying Android architecture. This makes
Aurasium a technology that can be widely de-
ployed.
• Aurasium is a robust technology that was tested on
three versions of Android. It has low memory and
runtime overhead and, unlike other approaches, is
more portable across the different OS versions.
2
The paper is organized as follows: Section 2 provides
the some background information on the architecture of
Android and then goes through details about the archi-
tecture, enforceable policies and deployment methods of
Aurasium. In Section 3 we evaluate Aurasium with re-
spect to its robustness in repackaging applications, as
well as the overhead introduced by the repackaging pro-
cess. Section 4 describes threat models against Aurasium
and mitigation techniques. Related work and conclusions
are discussed in Section 5 and Section 6, respectively.
2 Aurasium
2.1 Android
Android, the open source mobile operating system de-
veloped by the Open Handset Alliance led by Google,
is gaining increasing popularity and market share among
smartphones. Built on top of a Linux 2.6 kernel, Android
introduces a unique application architecture designed to
ensure performance, security, and application portabil-
ity. Rigorous compartmentalization of installed applica-
tions is enforced through traditional Linux permissions.
Additional permission labels are assigned to applications
during install time to control the application’s access to
security and privacy-sensitive functionalities of the OS,
forming a mandatory access-control scheme.
Android employs an inter-process communication
(IPC) mechanism called Binder [6] extensively for inter-
actions between applications as well as for application-
OS interfaces. Binder is established by a kernel driver
and exposed as a special device node on which individ-
ual applications operate. Logically, the IPC works on the
principle of thread migration. A thread invoking an IPC
call with Binder appears as if it migrates into the target
process and executes the code there, hopping back when
the result is available. All the hard work such as taking
care of argument marshalling, tracking object references
across processes, and recursions of IPC calls is handled
by Binder itself.
Android applications are mainly implemented in Java,
with the compiled class ﬁles further converted into
Dalvik bytecode, running on the proprietary register-
based Dalvik VM. It is similar to the JVM, but designed
for a resource-constrained environment with a higher
code density and smaller footprint. Applications are
tightly coupled with a large and function-rich Android
framework library (c.f.
J2SE). Also, applications are
free to include compiled native code as standalone Linux
shared object (.so) ﬁles. The interaction between an ap-
plication’s Java and native code is well deﬁned by the
Java Native Interface (JNI) speciﬁcation and supported
by Android’s Native Development Kit (NDK). In reality,
the complexity of using native code means that only a
small number of applications employ native code for the
most performance-critical tasks.
2.2 System Design
the
Aurasium is made up of two major components:
repackaging mechanism that
inserts instrumentation
code into arbitrary Android applications and the moni-
toring code that intercepts an application’s interactions
with the system and enforces various security policies.
The repackaging process makes use of existing open
source tools augmented with our own glue logic to re-
engineer Android applications. The monitoring code em-
ploys user-level sandboxing and interposition to intercept
the application’s interaction with the OS. Aurasium is
also able to reconstruct the high-level IPC communica-
tion from the low-level system call data, which allows it
to monitor virtually all of Android’s APIs.
2.2.1 Application-OS Interaction
Under the hood, some of Android’s OS APIs are han-
dled by the kernel directly, while others are implemented
at user-mode system services and are callable via inter-
process communication methods. However, in almost all
scenarios the application does not need to distinguish be-
tween the two, as these APIs have already been fully en-
capsulated in the framework library and the applications
just need to interact with the framework through well-
documented interfaces. Figure 1 shows in detail the lay-
ers of the framework library in individual applications’
address space.
Process Boundary
Application Code
Framework Code - Java
Java Native Interface
Framework Code - Native (C++)
libdvm.so
libandroid runtime.so
libbinder.so
Aurasium
Kernel Boundary
libm.so
libc.so
libstdc++.so
Linux Kernel
Figure 1: Android Application and Framework Structure
The top level of the framework is written in Java and is
the well-documented part of the framework with which
applications interact. This hides away the cumbersome
3
details from the application’s point of view, but in order
to realize the required operations it will hand over the re-
quest to the low-level part of the framework implemented
in native code. The native layer of the framework con-
sists of a few shared objects that do the real work, such as
communicating with the Dalvik VM or establishing the
mechanism for IPC communication. If we dive lower,
we ﬁnd that these shared objects are in fact also relying
on shared libraries at even lower levels. There, we ﬁnd
Android’s standard C libraries called Bionic libc. The
Bionic libc will initiate appropriate system calls into the
kernel that completes the required operation.
For example, if the application wants to download a
ﬁle from the Internet, it has multiple ways to do so, rang-
ing from fully managed HttpURLConnection class to
low-level Socket access. No matter what framework
APIs the application decides to use, they will all land
on the connect() method in the OSNetworkSystem
Java class in order to create the underlying TCP socket.
This connect() method in turn transfers control to
libnativehelper.so, one of the shared objects in the
native layer of the framework, which again delegates
the request to the connect() method in libc.so. The
socket is ﬁnally created by libc issuing a system call into
the Linux kernel.
No matter how complex the upper layer framework li-
brary may be, it will always have to go through appropri-
ate functions in the Bionic libc library in order to interact
with the OS itself. This gives a reliable choke point at
which the application’s interactions with the OS can be
examined and modiﬁed. The next section explains how
function calls from the framework into libc can be inter-
posed neatly.
2.2.2 Efﬁcient Interposition
Similar to the traditional Linux model, shared objects
in Android are relocatable ELF ﬁles that are mapped
into the process’s address space when loaded. To save
memory and avoid code duplication, all shared objects
shipped with Android are dynamically linked against the
Bionic libc library. Because a shared object like libc can
be loaded into arbitrary memory address, dynamic link-
ing is used to resolve the address of unknown symbols at