0.21
0.5
0.16
0.57
0.16
1.48
0.19
0.63
Table 8: Percentage distribution of variable size for Firefox 49.0a1, coreutils 8.25, binutils 2.26 and OpenSSL 1.1.0.
Program size  2048 bytes in size) could lead to data corruption. When
sizes of such objects exceed the alignment size, there is a possi-
bility that an attacker injects payload into such large objects, and
performs a pivot operation to execute the payload. A potential solu-
tion is to relocate large objects to the heap, and rely on P1 to stop
pivoting. A similar technique is implemented by StackArmor [9].
7.3 Inlined Assembly
The ability to lay out the stack frame is key to enforcing SPI, par-
ticularly invariant I2. Modern compilers (GCC and LLVM) fix the
stack frame during the execution of a function. Any save/restore
operations are performed in the prologue and epilogue of a function.
However, it is possible for hand-crafted assembly code (possibly
inlined) to use push and pop instructions within function body.
Such inlined assembly code can hinder frame size calculations. Our
investigation did not reveal any legal compilation scenarios (on
gcc and LLVM) that incorporated implicit SP-update instructions
within function body.
8 RELATED WORK
CFI-based defenses. Numerous efforts [3, 24–26, 33, 39] have
attempted to defeat code-reuse attacks by enforcing various forms
of CFI. These solutions extract the CFG and insert inlined refer-
ence monitors either by relying on source code and debugging
information, or by analyzing the binary itself [44, 45]. Variations
of CFI targeting either performance [7, 33, 43], or security [22, 40]
have been proposed. Fundamentally, completing the CFG is a hard
problem, and improving the precision of indirect branch resolution
is an ongoing direction of research [41]. SPIglass is orthogonal to
the above approaches, and in combination with CFI, SPI provides
stronger overall security.
ASLR-based defenses. ASLR [4, 38] was introduced as a means of
preventing attackers from reusing exploit code effectively against
multiple instantiations of a single vulnerable program. Recent ef-
forts such as binary stirring [42] and TASR [5] focus on increasing
the effectiveness of ASLR by increasing re-randomization frequency.
Redactor [10, 11] uses a combination of compiler transformations
and hardware-based enforcement to mark pages as execute-only,
thereby defeating the objective of memory disclosures. Techniques
that combine CFI and ASLR have also been proposed [23]. While
ASLR can strengthen SPI by making it hard to excavate gadgets,
SPI is not dependent on ASLR.
Stack-based defenses. Microsoft’s EMET [14] defends against
stack pivoting by checking the stack pointer within sensitive APIs
(like VirtualProtect) to ensure that it lies within the stack region of a
thread. However, DeMott demonstrated that the difference between
time-of-check to time-of-use of the stack pointer can be exploited
for practical attacks against EMET [13]. PBlocker [32] takes EMET’s
idea one step further and inserts assertion checks to ensure that the
stack pointer lies within the stack region immediately after each
SP-update instruction.
Fu et al. [16] introduced Slick, a solution that makes use of
exception handling metadata available in a binary to detect stack
layout corruptions caused by an ROP attack. Similar to MS-EMET,
there is a window of time between stack corruption and Slick’s
checks that can give the attacker an opportunity to hide her or
his trail. Slowinski et al. [37] introduces a memory corruption
defense that addresses diversion of control-flow through illegal
data modification detection. Their solutions assign an id (color) to
a memory object and a pointer. A pointer is only allowed access to
a memory object with matching id. SPI as a property is associated
with the stack pointer and not the contents of the stack. SPIglass
strictly monitors and enforces stack pointer invariants immediately
after each explicit stack pointer update.
Other defenses. Kuznetsov et al. [19] proposed Code-Pointer In-
tegrity (CPI), a policy guaranteeing the sanity of code pointers
such as function pointers and saved return addresses throughout
program execution. CPI partitions memory into safe and regular
125regions. By limiting the subset of memory objects that are pro-
tected, CPI limits the amount of instrumentation compared to CFI
schemes and thus achieves a performance benefit. SPI is orthogo-
nal to CPI, and will harden CPI. Dynaguard by Petsios et al. [30]
resists brute-force canary attacks like BlindROP [6] through a per-
thread run-time update of canary values in all stack frames. SPI is
fundamentally different yet complementary to these defenses.
9 CONCLUSION
We introduce Stack-Pointer Integrity, a program integrity prop-
erty that aims to complement CFI and other modern defenses. We
present SPIglass, an LLVM-based implementation of SPI that makes
a memory trade off in order to improve security.
It provides interoperability, and strong security orthogonal to
CFI. We find the stack alignment size of 256 to be optimal. We
opensource SPIglass.
10 ACKNOWLEDGEMENT
We would like to thank anonymous reviewers for their feedback.
This research was supported in part by Office of Naval Research
Grant #N00014-17-1-2929 and National Science Foundation Award
#1566532. Any opinions, findings and conclusions in this paper are
those of the authors and do not necessarily reflect the views of the
funding agencies.
REFERENCES
[1] 2015. Exception Handling in LLVM. http://llvm.org/docs/ExceptionHandling.html.
(2015).
[2] 2017.
http://http://www.metasploit.com/. (2017).
Metasploit
penetration
testing
framework.
[3] Martín Abadi, Mihai Budiu, Úlfar Erlingsson, and Jay Ligatti. 2005. Control-flow
Integrity. In Proceedings of the 12th ACM Conference on Computer and Communi-
cations Security (CCS’05). 340–353.
[4] Sandeep Bhatkar, Daniel C DuVarney, and Ron Sekar. 2003. Address Obfuscation:
An Efficient Approach to Combat a Broad Range of Memory Error Exploits. In
USENIX Security, Vol. 3. 105–120.
[5] David Bigelow, Thomas Hobson, Robert Rudd, William Streilein, and Hamed
Okhravi. 2015. Timely rerandomization for mitigating memory disclosures. In
Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications
Security. ACM, 268–279.
[6] Andrea Bittau, Adam Belay, Ali Mashtizadeh, David Mazieres, and Dan Boneh.
2014. Hacking Blind. In IEEE Symposium on Security and Privacy (SP’2014). IEEE,
227–242.
[7] Tyler Bletsch, Xuxian Jiang, and Vince Freeh. 2011. Mitigating Code-reuse Attacks
with Control-flow Locking. In Proceedings of the 27th Annual Computer Security
Applications Conference (ACSAC ’11). 353–362.
[8] Nicholas Carlini, Antonio Barresi, Mathias Payer, David Wagner, and Thomas R
Gross. 2015. Control-flow bending: On the effectiveness of control-flow integrity.
In 24th USENIX Security Symposium (USENIX Security 15). 161–176.
[9] Xi Chen, Asia Slowinska, Dennis Andriesse, Herbert Bos, and Cristiano Giuf-
frida. 2015. StackArmor: Comprehensive Protection from Stack-based Memory
Error Vulnerabilities for Binaries. In Proceedings of the 22nd Annual Network and
Distributed System Security Symposium (NDSS’15).
[10] S. Crane, C. Liebchen, A. Homescu, L. Davi, P. Larsen, A. R. Sadeghi, S. Brunthaler,
and M. Franz. 2015. Readactor: Practical Code Randomization Resilient to Memory
Disclosure. In 2015 IEEE Symposium on Security and Privacy. 763–780. https:
//doi.org/10.1109/SP.2015.52
[11] Stephen J Crane, Stijn Volckaert, Felix Schuster, Christopher Liebchen, Per Larsen,
Lucas Davi, Ahmad-Reza Sadeghi, Thorsten Holz, Bjorn De Sutter, and Michael
Franz. 2015. It’s a TRaP: Table Randomization and Protection against Function-
Reuse Attacks. In Proceedings of the 22nd ACM SIGSAC Conference on Computer
and Communications Security. ACM, 243–255.
[12] Thurston HY Dang, Petros Maniatis, and David Wagner. 2015. The performance
cost of shadow stacks and stack canaries. In ACM Symposium on Information,
Computer and Communications Security, ASIACCS, Vol. 15.
4.1.
Bypassing
https://bromiumlabs.files.wordpress.com/2014/02/bypassing-emet-4-1.pdf.
[13] Jared
DeMott.
EMET
2014.
(2014).
66–72. https://doi.org/10.1109/MSP.2015.75
[14] J. DeMott. 2015. Bypassing EMET 4.1. IEEE Security Privacy 13, 4 (July 2015),
[15] Erica Eng and Dan Caselden. 2015. Operation Clandestine Wolf – Adobe Flash
Zero-Day in APT3 Phishing Campaign. https://www.fireeye.com/blog/threat-
research/2015/06/operation-clandestine-wolf-adobe-flash-zero-day.html. (2015).
[16] Yangchun Fu, Jungwhan Rhee, Zhiqiang Lin, Zhichun Li, Hui Zhang, and Guofei
Jiang. 2016. Detecting Stack Layout Corruptions with Robust Stack Unwinding. In
Proceedings of the 19th International Symposium on Research in Attacks, Intrusions
and Defenses (RAID’16). Paris, France.
[17] Robert Gawlik and Thorsten Holz. 2014. Towards Automated Integrity Protection
of C++ Virtual Function Tables in Binary Programs. In Proceedings of 30th Annual
Computer Security Applications Conference (ACSAC’14).
[18] Enes Göktaş, Elias Anthanasopoulos, Herbert Bos, and Georgios Portokalidis.
2014. Out of Control: Overcoming Control-Flow Integrity. In Proceedings of 35th
IEEE Symposium on Security and Privacy (Oakland’14).
[19] Volodymyr Kuznetsov, László Szekeres, Mathias Payer, George Candea, R Sekar,
and Dawn Song. 2014. Code-Pointer Integrity. In USENIX Symposium on Operating
Systems Design and Implementation (OSDI).
[20] Julian Lettner, Benjamin Kollenda, Andrei Homescu, Per Larsen, Felix Schus-
ter, Lucas Davi, Ahmad-Reza Sadeghi, Thorsten Holz, and Michael Franz. 2016.
Subversive-C: Abusing and Protecting Dynamic Message Dispatch. In 2016
USENIX Annual Technical Conference (USENIX ATC 16). USENIX Association, Den-
ver, CO, 209–221. https://www.usenix.org/conference/atc16/technical-sessions/
presentation/lettner
[21] Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff
Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood. 2005. Pin:
Building Customized Program Analysis Tools with Dynamic Instrumentation. In
Proceedings of the ACM SIGPLAN Conference on Programming Language Design
and Implementation (PLDI’05). 190–200.
[22] Ali Jose Mashtizadeh, Andrea Bittau, Dan Boneh, and David Mazières. 2015. CCFI:
Cryptographically Enforced Control Flow Integrity. In Proceedings of the 22Nd
ACM SIGSAC Conference on Computer and Communications Security (CCS ’15).
ACM, New York, NY, USA, 941–951. https://doi.org/10.1145/2810103.2813676
[23] Vishwath Mohan, Per Larsen, Stefan Brunthaler, K Hamlen, and Michael Franz.
2015. Opaque control-flow integrity. In Symposium on Network and Distributed
System Security (NDSS).
[24] Ben Niu and Gang Tan. 2014. Modular Control-flow Integrity. In Proceedings
of the 35th ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI’14).
[25] Ben Niu and Gang Tan. 2014. RockJIT: Securing Just-In-Time Compilation
Using Modular Control-Flow Integrity. In Proceedings of 21st ACM Conference on
Computer and Communication Security (CCS ’14).
[26] Ben Niu and Gang Tan. 2015. Per-input control-flow integrity. In Proceedings
of the 22nd ACM SIGSAC Conference on Computer and Communications Security.
ACM, 914–926.
[27] Angelos Oikonomopoulos, Elias Athanasopoulos, Herbert Bos, and Cristiano
Giuffrida. 2016. Poking holes in information hiding. In USENIX Security.
[28] Kaan Onarlioglu, Leyla Bilge, Andrea Lanzi, Davide Balzarotti, and Engin Kirda.
2010. G-Free: defeating return-oriented programming through gadget-less bina-
ries. In Proceedings of the 26th Annual Computer Security Applications Conference.
ACM, 49–58.
[29] Vasilis Pappas, Michalis Polychronakis, and Angelos D Keromytis. 2012. Smash-
ing the Gadgets: Hindering Return-Oriented Programming using in-place Code
Randomization. In IEEE Symposium on Security and Privacy (SP’2012). 601–615.
[30] Theofilos Petsios, Vasileios P Kemerlis, Michalis Polychronakis, and Angelos D
Keromytis. 2015. DynaGuard: Armoring Canary-based Protections against Brute-
force Attacks. In Proceedings of the 31st Annual Computer Security Applications
Conference. ACM, 351–360.
[31] Aravind Prakash, Xunchao Hu, and Heng Yin. 2015. vfGuard: Strict Protection for
Virtual Function Calls in COTS C++ Binaries. In Proceedings of the 22nd Annual
Network and Distributed System Security Symposium (NDSS’15).
[32] Aravind Prakash and Heng Yin. 2015. Defeating ROP Through Denial of Stack
Pivot. In Proceedings of the 31st Annual Computer Security Applications Conference.
ACM, 111–120.
[33] Rui Qiao, Mingwei Zhang, and R Sekar. 2015. A Principled Approach for ROP De-
fense. In Proceedings of the 31st Annual Computer Security Applications Conference.
ACM, 101–110.
[34] Ahmad-Reza Sadeghi, Lucas Davi, and Per Larsen. 2015. Securing Legacy Soft-
ware against Real-World Code-Reuse Exploits: Utopia, Alchemy, or Possible
Future?. In Proceedings of the 10th ACM Symposium on Information, Computer
and Communications Security. ACM, 55–61.
[35] Hovav Shacham. 2007. The geometry of innocent flesh on the bone: Return-into-
libc without function calls (on the x86). In Proceedings of the 14th ACM conference
on Computer and communications security. ACM, 552–561.
[36] Felix Shuster, Thomas Tendyck, Christopher Liebchen, Lucas Davi, Ahmad-reza
Sadeghi, and Thorsten Holz. 2015. Counterfeit Object-oriented Programming,
On the Difficulty of Preventing Code Reuse Attacks in C++ Applications. In
126Proceedings of 36th IEEE Symposium on Security and Privacy (Oakland’15).
[37] Asia Slowinska, Traian Stancescu, and Herbert Bos. 2012. Body Armor for Bina-
ries: Preventing Buffer Overflows Without Recompilation. In Presented as part of
the 2012 USENIX Annual Technical Conference (USENIX ATC 12). USENIX, Boston,
MA, 125–137. https://www.usenix.org/conference/atc12/technical-sessions/
presentation/slowinska
[38] PaX Team. 2003. PaX address space layout randomization (ASLR). (2003).
[39] Caroline Tice, Tom Roeder, Peter Collingbourne, Stephen Checkoway, Úlfar
Erlingsson, Luis Lozano, and Geoff Pike. 2014. Enforcing Forward-Edge Control-
Flow Integrity in GCC & LLVM. In Proceedings of 23rd USENIX Security Symposium
(USENIX Security’14). 941–955.
[40] Victor van der Veen, Dennis Andriesse, Enes Göktaş, Ben Gras, Lionel Sambuc,
Asia Slowinska, Herbert Bos, and Cristiano Giuffrida. 2015. Practical Context-
Sensitive CFI. In Proceedings of the 22nd ACM SIGSAC Conference on Computer
and Communications Security. ACM, 927–940.
[41] Victor van der Veen, Enes Göktas, Moritz Contag, Andre Pawlowski, Xi Chen,
Sanjay Rawat, Herbert Bos, Thorsten Holz, Elias Athanasopoulos, and Cristiano
Giuffrida. 2016. A Tough call: Mitigating Advanced Code-Reuse Attacks At The
Binary Level. In Proceedings of 37th IEEE Symposium on Security and Privacy
(Oakland’16).
[42] Richard Wartell, Vishwath Mohan, Kevin W Hamlen, and Zhiqiang Lin. 2012.
Binary stirring: Self-randomizing instruction addresses of legacy x86 binary code.
In Proceedings of the 2012 ACM conference on Computer and communications
security (CCS’12). ACM, 157–168.
[43] Chao Zhang, Scott A Carr, Tongxin Li, Yu Ding, Chengyu Song, Mathias Payer,
and Dawn Song. 2016. VTrust: Regaining Trust on Virtual Calls. In Symposium
on Network and Distributed System Security (NDSS’16). https://doi.org/10.14722/
ndss.2016.23164
[44] Chao Zhang, Tao Wei, Zhaofeng Chen, Lei Duan, Laszlo Szekeres, Stephen Mc-
Camant, Dawn Song, and Wei Zou. 2013. Practical Control Flow Integrity and
Randomization for Binary Executables. In Proceedings of the IEEE Symposium on
Security and Privacy (Oakland’13). 559–573.
[45] Mingwei Zhang and R. Sekar. 2013. Control Flow Integrity for COTS Binaries. In
Proceedings of the 22nd USENIX Security Symposium (Usenix Security’13). 337–352.
127