title:Uses and Abuses of Server-Side Requests
author:Giancarlo Pellegrino and
Onur Catakoglu and
Davide Balzarotti and
Christian Rossow
Uses and Abuses of Server-Side Requests
Giancarlo Pellegrino1(B), Onur Catakoglu2, Davide Balzarotti2,
and Christian Rossow1
1 CISPA, Saarland University, Saarland Informatics Campus, Saarbr¨ucken, Germany
{gpellegrino,crossow}@cispa.saarland
{onur.catakoglu,davide.balzarotti}@eurecom.fr
2 Eurecom, Biot, France
Abstract. More and more web applications rely on server-side requests
(SSRs) to fetch resources (such as images or even entire webpages) from
user-provided URLs. As for many other web-related technologies, devel-
opers were very quick to adopt SSRs, even before their consequences for
security were fully understood. In fact, while SSRs are simple to add from
an engineering point of view, in this paper we show that—if not properly
implemented—this technology can have several subtle consequences for
security, posing severe threats to service providers, their users, and the
Internet community as a whole.
To shed some light on the risks of this communication pattern, we
present the ﬁrst extensive study of the security implication of SSRs.
We propose a classiﬁcation and four new attack scenarios that describe
diﬀerent ways in which SSRs can be abused to perform malicious activi-
ties. We then present an automated scanner we developed to probe web
applications to identify possible SSR misuses. Using our tool, we tested
68 popular web applications and ﬁnd that the majority can be abused
to perform malicious activities, ranging from server-side code execution
to ampliﬁcation DoS attacks. Finally, we distill our ﬁndings into eight
pitfalls and mitigations to help developers to implement SSRs in a more
secure way.
1 Introduction
Web applications have evolved from purely client-to-server patterns to an inter-
twined network of multiple web services. As a consequence, an increasing num-
ber of web applications retrieve external resources provided by other web ser-
vices, often steered by user inputs. For example, social networks regularly fetch
pages to display image and video previews of links posted by users, online cal-
endars can import remote iCal data, web mail clients fetch emails from user-
provided inboxes, and online image editors retrieve images from user-provided
URLs. Such service-to-service communication is also integrated into business
web applications and is at the core of several web-based protocols (e.g., OpenID
and SAML) and Cashier-as-a-Service web applications (e.g., online stores using
PayPal Express Checkout).
c(cid:2) Springer International Publishing Switzerland 2016
F. Monrose et al. (Eds.): RAID 2016, LNCS 9854, pp. 393–414, 2016.
DOI: 10.1007/978-3-319-45719-2 18
394
G. Pellegrino et al.
To support service-to-service communication, web applications rely on
server-side requests (SSRs), which are HTTP requests generated by a server
towards another web service. SSRs are often used to avoid passing relay mes-
sages between diﬀerent services via the user, or to allow complex services to per-
form requests outside the boundaries of the same origin policy. Unfortunately,
although the communication between web services is not new, we noticed an
alarming lack of information and understanding regarding the threats and the
security implications of this communication pattern. For example, when a user
posts a URL to a social network, the server-side web application automatically
fetches the content from the URL to display a visual preview of the page. How-
ever, giving the user the freedom to choose the URL means that she can control
the destination and potentially also the content of SSRs. This communication
pattern is getting more and more common to improve user experience and pro-
vide advanced features in a wide range of applications. Unfortunately, as is often
the case for emerging web technologies, developers are often too quick to jump
on the bandwagon without fully understanding the risks for security. In fact,
as we present in this paper, SSRs are diﬃcult to get right and, if not prop-
erly implemented, they can be abused to conduct malicious actions against the
service itself, its users, or even third-party web applications.
Existing work in this ﬁeld focuses on Server-Side Request Forgery (SSRF),
a family of software vulnerabilities that allow an attacker to misuse SSRs to
perform port scans [15,27] and buﬀer overﬂows [22]. However, this is only the
tip of the iceberg of the possible security ﬂaws that aﬀect this communication
pattern. Unfortunately, to date, we still lack a complete picture of the threats
posed by SSRs.
To shed some light on the risks of this communication pattern, in this paper
we present the ﬁrst extensive assessment of the security implications of SSRs.
We ﬁrst present a classiﬁcation to propose a common terminology for future
research in the ﬁeld. Our classiﬁcation groups SSRs according to the level of
control the attacker has, the role played by the vulnerable systems, and the
potential attack targets. We then apply our classiﬁcation to introduce four attack
scenarios in which seemingly innocuous services can be composed together to
form sophisticated attacks. For example, we show how popular services can be
abused to distribute links to phishing pages—bypassing existing URL blacklists
and reputation services.
In order to understand how widespread the problem is and what the most
common mistakes are, we propose a tool called g¨unther and use it to analyze
68 web applications that accept user-provided URLs. We found weaknesses and
security risks in 52 of them. Finally, to help developers to take more informed
decisions and reduce the risks associated with this delicate communication pat-
tern, we distilled our ﬁndings in a list of eight security-related recommendations.
To summarize, this paper makes the following contributions:
– We propose a new classiﬁcation to classify SSRs;
– We present four new attack scenarios in which SSRs can be used to mount
sophisticated Denial-of-Service (DoS) attacks, deliver malware, and bypass
Uses and Abuses of Server-Side Requests
395
client-side countermeasures. We show that SSRFs are only one of the possible
security ﬂaws introduced by SSRs.
– We discuss the results of the experiments we conducted on 68 web services,
54 of which we found to be aﬀected by at least one security ﬂaw.
– We present a clear set of mitigations to help developers to implement SSRs in
a more secure way.
2 Background
In this section, we present the SSR communication pattern, and we elaborate on
its use in modern web applications. Then, we present an overview of the threat
models, and ﬁnally, we present the current understanding of the security risks.
2.1 Server-Side Request Communication Pattern
The SSR pattern is shown in Fig. 1a. It involves three entities: a client C, an
SSR service S, and an external server ES. The protocol starts when C sends an
HTTP request req(urlES) to S containing a user-speciﬁed urlES. The position
of urlES in the HTTP request is application-speciﬁc, e.g., it could be inserted in
the query string, in the POST data, or even in the resource ﬁeld of the HTTP
request. S extracts the URL and initiates a connection to fetch the corresponding
resource resES from the remote server ES. Depending on the use of SSR, S can
forward the resource resES back to C (i.e., resS = resES), or return the result
of a transformation (i.e., resS = f(resES)). For instance, S can embed resES
into resS, or simply return an identiﬁer of the retrieved resource.
Fig. 1. SSR pattern and risks
396
G. Pellegrino et al.
Use Cases—SSRs are widely used in web applications. For example, social
networks use SSRs to retrieve user-provided URLs and share them on the user’s
page. SSRs are also common in business applications, such as web oﬃce suites,
in which they are used to include online resources (e.g., pictures) in documents.
The list also includes online development tools, news aggregators, and image
processing applications. Online development tools help developers, for example,
to validate documents such as XML or JSON objects, or allow developers to
test their web application with diﬀerent browsers. SSRs are also at the core
of news aggregators, which retrieve news from newspapers or RSS documents.
Another use of SSRs is in web-based security protocols, such as the OpenID
authentication protocol [8]. In OpenID, a client wants to be authenticated at
the service provider (SP) by using her own credentials at the identity provider
(IdP). OpenID allows the two providers to communicate either indirectly, i.e.,
by using the client’s browser as a relay agent, or directly via SSRs. In this case,
the SP acts as an HTTP client and initiates the connection with the IdP, which
in turn acts as an HTTP server. SSRs are also used in other web-based security
protocols, such as SAML SSO.
Server- vs. Client-Side Requests—The counterparts of SSRs are client-side
requests (CSRs) in which C retrieves a resource at ES and sends it to S. How-
ever, replacing SSRs with CSRs may not be practical, secure, or eﬃcient.
Practicality: CSRs can be implemented with cross-origin requests (CORs) in
which a resource in the domain of ES is transmitted to S. These requests are
subject to the same-origin policy (SOP for CORs) and the cross-origin resource
sharing mechanism [26] (CORS). The former forbids accessing resources in a
domain (i.e., ES) of a diﬀerent origin from the request (i.e., S). These requests
can be relaxed with CORS; however, CORS assumes a pre-established agree-
ment between two diﬀerent domain origins to allow requests from one to access
resources of the other. This solution is often not practical because each service
needs to keep and maintain a whitelist of domains that can access their services,
and developers may not be able to modify the whitelist of third-party services.
This has spurred the development of techniques to circumvent these obstacles,
e.g., to bypass SOP for CORs (often considered to be security ﬂaws, such as
JSONP), or using the more ﬂexible SSR paradigm.
Security: In protocols like OpenID, the involved parties do not agree on shared
secrets such as cryptographic keys. Instead, they generate or exchange keys dur-
ing the protocol run. In contrast to SSRs, CSRs may expose keys to attackers,
thus endangering the validity of the authentication process.
Eﬃciency: CSRs may introduce additional costs. For example, social networks
and online tools for developers may need to retrieve several resources to create
a synthesis of the web page or to analyze its content. For each resource, an SSR
service will issue one request and one response. With CSRs, on the other hand,
the number of messages can double: The ﬁrst request-response pair retrieves the
resource from ES, while the second pair uploads the resource to S for further
processing.
Uses and Abuses of Server-Side Requests
397
2.2 Security Risks and Threat Models
While SSR is a useful communication pattern which enables service-to-service
communication, if not properly implemented it can be abused to perform a wide
range of malicious activities, such as:
R1 SSRs can be abused as stepping stones to attack ES, for instance by perform-
ing denial-of-service attacks against Internet-facing services. Other attacks
can be against services of S’s private network.
R1 S may accept untrusted URLs which reference local resources, e.g., ﬁles
hosted by S. For example, this attack can be used to exﬁltrate system con-
ﬁguration ﬁles, passwords, and databases.
R2 SSRs introduce a new level of indirection between web browsers and the
origin of resources. As a result, browsers may no longer be able to determine
the real origin of a page, thus leaving users exposed to malicious content
such as malware.
R3 Vulnerabilities in S can be exploited with incoming responses from ES.
Responses may be processed to generate resS for C. An adversarial ES can
potentially craft malicious messages resES with the purpose of exploiting
vulnerabilities in S.
These risks are shown in Fig. 1b (for R1 and R2), Fig. 1c (for R3), and Fig. 1d
(for R4). Figure 1b corresponds to the initial threat model proposed by Polyakov
et al. [22]. The entities of Polyakov’s model are an attacker C, an SSR service
S, a service ES, the ﬁle system of S, and a ﬁrewall. C aims to access ES or
the local ﬁle system of S. However, ES is protected by a ﬁrewall that blocks
direct access from the Internet. S is exposed both to the Internet and to the local
network. If not carefully implemented, an attacker can abuse SSRs performed
by S to access internal servers that are in S’s network, i.e., R1, or even retrieve
ﬁles from S (e.g., via the file:// protocol), i.e., R2.
Unfortunately, Polyakov’s threat model is not complete as it neglects C as a
possible victim (i.e., R3) and it considers only a fraction of the attack surface
of S, thus ignoring other threats (i.e., R4). In this paper, we propose a more
complete threat model that also incorporates new attacks in which SSRs are
abused to target C (see Fig. 1c) and S (see Fig. 1d). In Fig. 1c, ES hosts malicious
content and C is an honest client that adopts URL-based countermeasures to
protect the user from malicious content (such as ﬁltering mechanisms like Google
Safe Browsing). The attacker targets C by tricking the user into visiting the
malicious page ES, possibly abusing an innocent but vulnerable S. While C may
believe she is visiting a well-reputed service S, in fact, S may just act as a proxy
for malicious content hosted at ES, eﬀectively circumventing any reputation-
based mechanisms deployed by C. In Fig. 1d, the attacker is C, whereas ES
hosts malicious content. The attacker submits the URL of the malicious content
to S, which fetches resES and processes it. For example, if S implements poor
resource validation mechanisms, it may be susceptible to resource exhaustion
attacks via specially-crafted resources.
398
G. Pellegrino et al.
2.3 Awareness of the Security Risks
A closer look in the academic and non-academic literature and developer best
practices (e.g., design patterns, coding rules, and API documentation) shows
that (i) SSRs have received no attention by academic literature and (ii) exist-
ing non-academic works focus exclusively on Polyakov’s threat model and thus
neglect threats against C and S. In addition, despite the popularity of the attacks
in Polyakov’s threat model, there is a lack of documentation describing proper
ways to implement SSR services and attack countermeasures. As a result, devel-
opers may develop vulnerable SSR services that can be abused by attackers.
3 SSR Classiﬁcation
Despite anecdotal evidence, to date there is no systematic study of the SSR
communication pattern. Therefore, we introduce a classiﬁcation that proposes a
common terminology for us and for future researchers. Our classiﬁcation (Fig. 2)
includes and supersedes pre-existing categorizations, classifying SSRs according
to four diﬀerent directions: ﬂaws, attacker control, S’s behavior, and victims. To
the best of our knowledge, this is the most extensive existing classiﬁcation of
SSRs.
The four dimensions of our classiﬁcation are not mutually exclusive. In fact,
services often play multiple roles and may suﬀer from multiple ﬂaws. For this