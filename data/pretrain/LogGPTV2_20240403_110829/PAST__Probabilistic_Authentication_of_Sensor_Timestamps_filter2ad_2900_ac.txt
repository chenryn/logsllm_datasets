  r
  α−1
h  (       )
2
  r
h  (      )
  n−3
  rh  (      )n−2
Implemented
As FIFO
α
  r
  α
h  ( n−  )
1rh(    )
r
h(        )
α−2
r
h(        )
αrh(     )αrh(     )αr
α−1 h(     )
r
h(       )
n−2
rh(       )
n−1
r
1
r
2
rα−1
rα
rα+1
r
n−1
r
n
Sensor Reading Block
rh(       )
n−1
  rh  (      )n−2
Tail
Head
Figure 3. The current set of witnesses are stored in a FIFO implemented as a circular array. The
column over ri is the state of the witness FIFO when the ith block of data is generated by the sensor.
hj(ri) represents the result of composing the hash function j times using ri as the input.
lier blocks of readings as the input. Thus, the last entry
is hα(ri−(α−1)).
In practice, a FIFO entry has the form
{bi, hj(ri)}, where bi is the base station to which the read-
ings ri were sent.
Each time the sensor readings buffer ﬁlls, it is transmit-
ted to the base station. After this completes, the element
stored at the location of the FIFO’s head pointer is over-
written with the transmitted block’s hash. The head pointer
is then decremented by one (modulo its size, α), making the
new hash the last in the circular array. Each of the other el-
ements in the FIFO are replaced with the result of hashing
themselves. Thus, the FIFO element hj(ri) is replaced with
hj+1(ri) = h(hj(ri)). bi does not have to be updated. (ri
is the set of readings in block i and hj+1(ri) is the (j + 1)th
witness. i and j are indexes modulo α.) Figure 3 illustrates
the state of the FIFO over time as new blocks of readings
are generated.
Since the hash function is assumed to be difﬁcult to in-
vert, if an adversary gains access to the FIFO, it can not
use its contents to generate the previous values stored in
the FIFO. The contents of the FIFO can not be generated
without access to sensor data stream. Finally, every FIFO
entry is related to the current block by the property that it
is derived from one of α preceding blocks. Thus, the en-
tries in the FIFO possess the properties needed to serve as
witnesses.
3.3. Testimony Veriﬁcation
A sensor shares a unique symmetric encryption key with
each base station that acts as a notary on its behalf. At the
time of deployment, the sensor is provisioned with keys to
communicate with β base stations. A β-element array Ψ in
the sensor stores entries of the form {bv, kv} where bv is a
base station’s address and kv is its key. A pseudorandom
generator is used to permute the array elements at initializa-
tion. Subsequently, after every β blocks have been transmit-
ted, the array is randomly permuted again. This prevents an
adversary from predicting which base stations will be desig-
nated as notaries for a given block of readings. As a result,
the best an adversary can do is to compromise a random
base station. Thus, when authenticating a block, the proba-
bility that a notary is compromised is uniformly µb.
When a set of readings are to be transferred to a base
station, they are formatted into a block like the one depicted
in Figure 2. First, the block’s index is incremented by one.
Then, the last reading’s timestamp is stored. Next, the hash
of the readings is computed. The contents of the witness
FIFO are copied starting from the head. Finally, the next
entry {bv, kv} from the array Ψ is retrieved. kv is used to
symmetrically encrypt the aforementioned ﬁelds. Then the
sensor’s address, s, is entered in the source ﬁeld and bi in
the destination ﬁeld. Finally, the PAST block is transmit-
ted to the closest base station which acts as a gateway and
forwards the block to bv. bv decrypts it and commences
veriﬁcation.
bv will attempt to verify each witness. This requires ac-
cess to the block of readings used to generate each witness.
However, these can not be used directly. If they were ac-
cessible, then an adversary could use the data to generate
fraudulent witnesses. Instead PAST utilizes an interactive
protocol between base stations. When bv needs to validate
the witness {bi, hj(ri)}, it does the following. First, it sends
a message to bi with the source sensor’s address, s, the in-
dex i of the block whose integrity is being validated, the po-
sition j of the witness in the header and a random nonce, x.
Since bi had previously received ri from s, it can calculate
w = hj(ri). bi then sends bv the blinded witness, h(w⊕ x).
(The hash prevents an eavesdropper from gaining any infor-
mation.) bv computes h(hj(ri)⊕x) and checks if it matches
w. If it does, the witness has validated the current block.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:34:52 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006If bv does not receive a response within a ﬁxed amount
of time, it aborts. This is necessary for three reasons. The
ﬁrst is that the network may be partitioned and the remote
node may not be accessible. The second is that an adversary
may control the remote node and be attempting to halt the
validation protocol. The third reason is that the remote node
may not yet have received ri from s. The latter case can be
addressed by bv explicitly signaling to bi how long it can
wait for ri to arrive.
As testimony from more witnesses is validated, the cer-
tainty of the block’s integrity increases. However, it should
be noted that even a single validated witness is a strong au-
thenticator. The reason is that compromising a base station
only allows an adversary to deny the validity of a legitimate
witness.
It can not use the control of the base station to
falsely validate a witness since that would require comput-
ing a hash preimage, which is computationally prohibitively
expensive.
3.4. Timestamp Notarization
Once the authentication process described in Section 3.3
completes, the timestamp ti and block of sensor readings ri
are concatenated. This is then encrypted using a randomly
generated encryption key kc and symmetric cipher S() to
produce ei = Skc(ti||ri). kc is encrypted with the stor-
age server’s public key ks and an asymmetric cipher A()
(cid:1)
c = A(ks, kc). Such a scheme is necessary since
to yield k
asymmetric ciphers are signiﬁcantly slower than symmetric
ones. The hybrid protocol allows data to be encrypted at
the rate supported by the symmetric cipher while being de-
cryptable only with the storage server’s private key. Since
(cid:1)
the key kc is not reused, signing k
c with a forward-secure
signature sufﬁces to distinguish data from different time pe-
riods.
(If kc were reused, then ei would also need to be
signed.) As described in Section 3.1, an identity-based dig-
ital signature scheme with ofﬂine veriﬁcation key evolution
is needed. This will allow timestamp and data integrity ver-
iﬁcation to occur in the face of transient connectivity or the
presence of network partitions.
We ﬁrst describe Shamir’s original identity-based signa-
ture scheme [15]. After that we explain how we modify it
to allow ofﬂine evolution of the veriﬁcation key. First, an
RSA modulus N (which is a product of two large primes) is
chosen. A large prime p that is relatively prime to φ(N) is
selected. (φ() is the Euler totient function.) h is a one-way
hash function. N, p, h() are global parameters and can be
broadcast. Only the administrator knows the factorization
of N . It can use this to derive a unique value g which sat-
isﬁes gp = η
(mod N), where η is the user’s identity. g
is only shared with the user η. Only knowledge of g allows
a message to be signed such that η can be used as the key
(cid:1)
to verify the signature. η can sign the key k
c by selecting a
random number x, then computing γ = xp
(mod N) and
(mod N). The signature {δ, γ} can be
δ = g.xh(γ||k(cid:1)
c)
veriﬁed by checking whether δp ?= η.γh(γ||k(cid:1)
(mod N).
To make the signature forward-secure, the identity can
be replaced with the concatenation of the recipient η and
c)
the timestamp τ. Wherever η was used, η||τ is now used.
However, this requires the signer to obtain a new signing
key gτ from the administrator for each distinct value of τ.
One method to implement this is by contacting the admin-
istrator online each time a new signature is to be generated.
The other possibility is that the user obtains signing keys
for a large range of values of τ in advance, incurring sig-
niﬁcant storage overhead. The scheme we introduce be-
low does not suffer from either of these drawbacks.
(To
see why the above scheme is forward-secure, note that once
time τ passes, gτ is discarded. When the node is compro-
mised, signatures for earlier time periods can not be gen-
erated since the corresponding gτ keys have already been
deleted.)
Our scheme is initialized with the same global parame-
ters N, p, h() as the original scheme [15]. At the outset, a
user with identity η is provided with the same key, denoted
(mod N). After
by g0 instead of g. As before, g
time τ passes, the signer computes gτ +1 = g2
(mod N)
and then discards gτ . Deriving gτ from gτ +1 is as in-
tractable as the factorization problem [14]. This ensures the
forward-security of the signing key. Thus, if an adversary
compromises a base station at time τ + 1, they will not be
able to obtain the signing keys for time τ or earlier.
0 = η
The procedure for generating a signature must be
modiﬁed. If γ is being created at time τ, it is constructed as
γ = x2τ p
(mod N). Similarly, when δ is created at time
τ, it is deﬁned to be δ = gτ .x2τ h(γ||k(cid:1)
(mod N). The
c)
c is now {τ, δ, γ}. Finally, the veriﬁcation
(cid:1)
signature for k
condition becomes: δp ?= η2τ
γh(γ||k(cid:1)
c)
(mod N)
p
τ
To see why this condition should hold, note that:
δp = (gτ .x2τ h(γ||k(cid:1)
c))p
0 .x2τ h(γ||k(cid:1)
c))p
c))2τ p
= (g2τ
= (g0.xh(γ||k(cid:1)
(mod N)
(mod N)
(mod N)
and:
η2τ
.γh(γ||k(cid:1)
c) = (g
p
0)2τ
.(x2τ p)h(γ||k(cid:1)
= (g0.xh(γ||k(cid:1)
c))2τ p
(mod N)
c)
(mod N)
Our scheme’s security directly reduces to that of the orig-
inal signature scheme. If an adversary can generate fraudu-
lent signatures for our scheme, then they can do so for time
τ = 0. This would mean that they can generate fraudulent
signatures for the original scheme.
4. Security Analysis
We analyze PAST’s robustness in the face of attacks on
network links, compromises of sensors and base stations
and Sybil attacks.
4.1. Network Attack
Data generated by a sensor traverses three different types
of network links. The ﬁrst is between the sensor and the
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:34:52 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006Figure 4. The x-axis represents the fraction of
compromised base stations in the entire sen-
sor network. The y-axis depicts the certainty
with which a timestamp can be certiﬁed. The
threshold for accepting the timestamp is 2,
that is at least 2 witnesses must veriﬁed. The