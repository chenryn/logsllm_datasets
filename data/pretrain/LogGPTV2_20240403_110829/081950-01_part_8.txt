由于ASCII编码只占用一个字节，也就是二进制8位，共有28 256种可能，完全可以覆
盖英文大小写字母及特殊符号。而我们中文汉字远超过 256 个，使用 ASCII 编码的一个字节
来处理中文显然是不够用的，于是我国就制订了支持中文的GB2312编码，使用两个字节，可
Python自动化运维快速入门
以支持 216共 65536 种汉字，可以覆盖常用的中文汉字 60370 个（当代《汉语大字典》(2010
年版)收字60370个）。
例如：汉字的“汉”。
>>> "汉".encode('gb2312') #将“汉”以GB2312 编码 得到 16进制字节码 b'\xba\xba' 转换为
10进制为 186,186,占用两个字节
b'\xba\xba'
>>> (b'\xba\xba').decode('gb2312') #将字节解码得到汉
'汉'
>>> list("汉".encode('gb2312'))
[186, 186]
在这里介绍几种常见的中文编码。
 GB2312或GB2312-80 是中国国家标准简体中文字符集，共收录6763个汉字，同时
收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的
682个字符。
 GBK 即汉字内码扩展规范，共收入21886个汉字和图形符号。
 GB 8030与GB2312-1980和GBK兼容，共收录汉字70244个，是一二四字节变长编码。
由上可以看出支持的汉字范围：GB18030 > GBK > GB2312。
对于一些生僻字，可能需要GBK 或GB18030进行编码，如“祎”。
>>> "祎".encode("gb2312") #GB 2312没有祎字的编码，报错
Traceback (most recent call last):
File "", line 1, in 
UnicodeEncodeError: 'gb2312' codec can't encode character '\u794e' in position 0:
illegal multibyte sequence
>>> "祎".encode("gbk")
b'\xb5t'
>>> list("祎".encode("gbk"))
[181, 116]
>>> "祎".encode("gb18030")
b'\xb5t'
>>> list("祎".encode("gb18030"))
[181, 116]
这仅仅是适用中文文本的一个编码，全世界有上百种语言，每种语言都设计自己独特的编
码，这样计算机在跨语言进行信息传输时还是无法沟通（出现乱码）的，于是 Unicode 编码
应运而生，Unicode 使用 2~4 个字节编码，已经收录 136690 个字符，并且还在一直不断扩张
中。把所有语言统一到一套编码中，这套编码就是Unicode编码。使用Unicode编码，无论处
理什么文本都不会出现乱码问题。Unicode 编码使用两个字节（16 位 bit）表示一个字符，比
较偏僻的字符需要使用4个字节。
Unicode起到以下作用。
 直接支持全球所有语言，每个国家都可以不用再使用自己之前的旧编码了，用
Unicode就可以。
58
第2章 基础运维
 Unicode包含了与全球所有国家编码的映射关系。
几乎所有的系统、编程语言都默认支持Unicode。但是新的问题又来了，如果一段纯英文
文本，用Unicode编码存储就会比用ASCII编码多占用一倍空间！存储和网络传输时一般数据
都会非常多。为了解决上述问题，UTF 编码应运而生，UTF 编码将一个 Unicode 字符编码成
1~6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才
会被编码成4~6个字节。注意，从Unicode到UTF并不是直接对应的，而是通过一些算法和
规则来转换的。UTF编码有以下三种。
 UTF-8： 使用1、2、3、4个字节表示所有字符，优先使用1个字节，若无法满足，
则增加一个字节，最多4个字节。英文占1个字节、欧洲语系占2个字节、东亚占3
个字节，其他及特殊字符占4个字节。
 UTF-16： 使用 2、4 个字节表示所有字符，优先使用 2 个字节，否则使用 4 个字节
表示。
 UTF-32： 使用4个字节表示所有字符。
例如：汉字的“汉”，在UTF-8字符集中3个字节。
>>> list("汉".encode("utf-8"))
[230, 177, 137]
而英文无论采集哪种编码，都是一致的。如果使用纯英文编写代码，就基本不会遇到编码
问题。如"a"在ASCII、GBK、UTF-8中的编码结果都是一致的。
>>> list("a".encode("ascii"))
[97]
>>> list("a".encode("gbk"))
[97]
>>> list("a".encode("utf-8"))
[97]
下面结合Python代码实例来理解编码，如图2.1所示。
图2.1 代码实例
59
Python自动化运维快速入门
我们使用vim编辑器编写str_encode_decode.py，在第一行指定Python解释器以UTF-8编
码解码源文件，并保存为 UTF-8 编码的文本文件，然后运行程序。这一编码解码过的程如图
2.2所示。
Unicode 编码encode 写入 Unicode
字节 读取 字节
字符串 解码decode 读取 1.py 字符串
指定字符编码
指定字符编码 utf-8/gbk
utf8/gbk
通过编辑器设置 # -*-coding:utf-8 -*-
图2.2 Python源代码的编码解码过程
上图中的Unicode字符串就是我们在编辑器中看到的字符串，如“我是中国人”这个字符
串，在Python 3中所定义的字符串就是Unicode字符串。Unicode字符串可以编码为任意编码
格式的字节码，解码时使用同一编码解码即可得到原来的Unicode字符串。
上述1.py的第5行将Unicode字符串内容以UTF-8的编码方式写入到a.txt，第9行从a.txt
读取内容并以 UTF-8 的编码解码输出 Unicode 字符串，确保写入编码和读取编码一致就不会
出现编码问题。
上述代码的运行结果如图2.3所示。
图2.3 运行结果
在这里顺带介绍一下Python语言的with … as …的用法。有一些任务，可能事先需要设置，
事后做清理工作。对于这种场景，Python 的 with 语句提供了一种非常方便的处理方式。一个
很好的例子是文件处理，你需要获取一个文件句柄，并从文件中读取数据，然后关闭文件句柄。
如果不用with语句，代码如下：
1 file = open("a.txt")
2 data = file.read()
3 file.close()
这里有两个问题：一是可能忘记关闭文件句柄；二是文件读取数据发生异常，没有进行任
何处理。下面是处理异常的加强版本：
1 file = open("a.txt")
2 try: #尝试运行下面的代码
3 data = file.read()
4 finally: #无论上面的代码是否抛出异常，下面的代码都将执行
60
第2章 基础运维
5 file.close()
虽然这段代码运行良好，但是太冗长了，这时候就是 with 一展身手的时候了。除了有更
优雅的语法，with还可以很好地处理上下文环境产生的异常。下面是with版本的代码：
1 with open("a.txt") as file:
2 data = file.read()
with 语句里是怎么执行的呢？Python对with的处理是非常聪明的，with所求值的对象必
须有__enter__()方法和__exit__()方法，紧跟with后面的语句被求值后，调用对象的__enter__()
方法，该方法的返回值将被赋值给as后面的变量。当with后面的代码块全部被执行之后，将
调用前面返回对象的__exit__()方法来收尾。
读者可能会有疑问，如果编写Python程序时未指定Python解释器以何种编码解码呢？答
案是使用系统的默认编码。默认编码可以通过sys.getdefaultencoding()来查看Python解释器会
用的默认编码，以Windows系统为例：
>>> import sys
>>> sys.getdefaultencoding()
'utf-8'
>>>
说明在此电脑上Python解释器默认使用的是UTF-8编码，如果不指定Python解释器以何
种编码解码，则默认以UTF-8方式解码源文件，因此在保存源代码文件时请确保以UTF-8编
码保存。
2.1.2 文件操作
用 Python 或其他语言编写应用程序时，若想把数据永久保存下来，必须保存于硬盘中，
这就涉及我们编写应用程序来操作硬件，而应用程序是无法直接操作硬件的，需要通知操作系
统，由操作系统完成复杂的硬件操作。操作系统把复杂的硬件操作封装成简单的接口给用户/
应用程序使用，其中文件就是操作系统提供给应用程序来操作硬盘虚拟接口，用户或应用程序
通过操作文件，可以将自己的数据永久保存下来。有了文件的概念，我们无须再考虑操作硬盘
的细节，只需要关注操作文件的流程即可。
（1）打开文件，得到一个文件句柄，并赋值给一个变量。
（2）通过句柄对文件进行操作。
（3）关闭文件。
1. 普通文件操作
Python文件操作也是非常简单，只需要一个open函数返回一个文件句柄，无须导入任何
模块。
1 f=open(“a.txt”) # 打开文件，得到一个文件句柄，并赋值给一个变量
2 print(f.read()) #打印读取文件的内容
3 f.close() #关闭文件
61
Python自动化运维快速入门
open函数原型如下：
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None,
closefd=True, opener=None)
其中：
（1）参数 file 是一个表示文件名称的字符串，如果文件不在程序当前的路径下，就需要
在前面加上相对路径或绝对路径。
（2）参数 mode 是一个可选字参数，指示打开文件的方式，若不指定，则默认为以读文
本的方式打开文件。字符串及含义可参见表2-1。
表2-1 字符串及含义
字符串 含义
'r' 以读的方式打开（默认）
'w' 以写的方式打开文件，会先清空文件
'x' 创建一个新文件，以写方式打开
'a' 以写的方式打开文件，如果文件已存在，就在文件最后位置追加内容
'b' 以二进制方式打开，可以和读写命令共用
't' 以文本方式（默认）
'+' 以读和写方式打开文件，用于更新文件
'U' 通用的换行模式（弃用）
默认的打开方式是'rt' (mode='rt')。Python是区分二进制方式和文本方式的，当以二进制方
式打开一个文件时（mode 参数后面跟'b'），返回一个未经解码的字节对象；当以文本方式打
开文件时（默认是以文本方式打开，也可以 mode 参数后面跟't'），返回一个按系统默认编码
或参数encoding传入的编码来解码的字符串对象。
（3）buffering是一个可选的参数，buffering=0表示关闭缓冲区（仅在二进制方式打开时
可用）；buffering=1 表示选择行缓冲区（仅在文本方式打开时可用）；buffering 大于 1 时，
其值代表固定大小的块缓冲区的大小。当不指定该参数时，默认的缓冲策略是这样的：二进制
文件使用固定大小的块缓冲区，文本文件使用行缓冲区。
【示例2-1】先来看一个例子。
1 # -*- coding: utf-8 -*-
2
3 f = open("wb.txt", "w", encoding="utf-8")
4 f.write("测试w方式写入，如果文件存在，则清空内容后写入；如果文件不存在，则创建\n")
5 f.close()
6
7 f = open("wb.txt", "a", encoding="utf-8")
8 f.write("测试a方式写入，如果文件存在，则在文件内容后最后追加写入；如果文件不存在，则创建
")
9 f.close()
10
62
第2章 基础运维
11 f = open("wb.txt", "r", encoding="utf-8")
12 # 以文本方式读，f.read()返回字符串对象
13 data = f.read()
14 print(type(data))
15 print(data)
16 f.close()
17
18 f = open("wb.txt", "rb")
19 # 以文本方式读，f.read()返回字节对象
20 data = f.read()
21 print(type(data))
22 print(data)
23 print('将读取的字符对象解码：')
24 print(data.decode('utf-8'))
25 f.close()
将上述代码保存为read_write_file.py，运行结果如图2.4所示。
图2.4 运行结果
从上面的例子可以看出，以二进制读取文件时，读取的是文件字符串的编码（以encoding
指定的编码格式进行的编码），将读取的字节对象解码，可得出原字符串。
请注意以下几点：
（1）记得使用完毕后及时关闭文件，释放资源。打开一个文件包含两部分资源：操作系
统级打开的文件+应用程序的变量。在操作完毕一个文件时，必须把与该文件的这两部分资源
一个不落地回收，回收操作系统级打开的文件，如f.close()，回收应用程序级的变量，如del f。
其中del f一定要发生在f.close()之后，否则就会导致操作系统打开的文件还没有关闭，白白占
用资源，而Python自动的垃圾回收机制决定了我们无须考虑del f，这就要求我们，在操作完
毕文件后，一定要记住 f.close()。刚开始的时候很容易忘记使用 f.close()方法去关闭，推荐傻
瓜式操作方式：使用 with 关键字来帮我们管理上下文，系统会自动为我们关闭文件和处理异
常，如下面两行代码即可完成安全的写操作。
with open('a.txt','w') as f:
f.write(“hello word”)
（2）open()函数是由操作系统打开文件，如果我们没有为open指定编码，那么打开文件
的默认编码很明显是操作系统默认的编码：在 Windows 下是 gbk，在 Linux 下是 utf-8。若要
63
Python自动化运维快速入门
保证不乱码，就必须让读取文件和写入文件使用的编码一致。
常见的文件操作方法可参见表2-2。
表2-2 常见的文件操作方法
名称 功能
f.read() 读取所有内容，光标移动到文件末尾
f.readline() 读取一行内容，光标移动到第二行首部
f.readlines() 读取每一行内容，存放于列表中
f.write('1111\n222\n') 针对文本模式的写，需要自己写换行符
f.write('1111\n222\n'.encode('utf-8')) 针对b模式的写，需要自己写换行符
f.writelines(['333\n','444\n']) 文件模式
f.writelines([bytes('333\n',encoding='utf-8'),'444\n'.encode('utf-8')]) b模式
f.readable() 文件是否可读
f.writable() 文件是否可读
f.closed 文件是否关闭
f.encoding 如果文件打开模式为b,则没有该属性
f.flush() 立刻将文件内容从内存刷到硬盘
读取文件内位置的定位方法：
（1）通过read方法传输参数，如read(3)，当文件打开方式为文本模式时，代表读取3个
字符，当文件打开方式为二进制模式时，代表读取3个字节。
（2）以字节为单位定位，如seek、tell等方法。其中seek有3种移动方式：0、1、2，其
中1和2必须在二进制模式下进行，但无论哪种模式，都是以bytes为单位移动的。f.tell() 返
回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。如果要改变文件当前的位
置，可以使用 f.seek(offset, from_what) 函数。from_what如果是0，则表示开头；如果是1，
则表示当前位置；如果是2，则表示文件的结尾。例如：
 seek(x,0) 表示从起始位置即文件首行首字符开始移动x个字符；
 seek(x,1)表示从当前位置向后移动x个字符；
 seek(-x,2)表示从文件的结尾向前移动x个字符。
【示例2-2】在文件中定位。
>>> f = open("tmp.txt", "rb+")
>>> f.write(b"abcdefghi")
9
>>> f.seek（5） # 移动到文件的第六个字节
5
>>> print(f.read（1）)
b'f'
>>> f.seek(-3, 2) # 移动到文件的倒数第三个字节
6
>>> print(f.read（1）)
64
第2章 基础运维
b'g'
【示例2-3】基于seek实现类似Linux命令tail -f的功能（文件名为lx_tailf.py）。