2: for Input_Opcode in All_Opcodes do
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18: end for
end for
end if
end if
else[equal(M ethod, Def ault)]
Default Actions
Signature.State ⇐ Def ault_State
Break
present. Other clauses of that sentence are under other opcodes.
5.3 Generating Opcode Vulnerability Signa-
ture
We generate the opcode vulnerability signatures semi-automatically
with the following three steps.
1. Based on the semantics of the vulnerability (e.g., from the CVE
description or vulnerability patches), we locate the opcodes that
are involved in the vulnerability. We create a DFA with each
involved opcode being a node (state).
2. From the data ﬂow part, we extract the critical data structure
involved in the vulnerability related to each opcode operation
and deﬁne a variable in the variable pool of “Action” ﬁeld in
opcode signature.
3. We combine the DFA and the variable pool together by intro-
ducing each variable to the “Condition” ﬁeld of opcode signa-
ture based on the data ﬂow connection between opcodes.
Again, we use CVE-2009-1833 in Figure 7 as an example. We
ﬁrst automatically generate control and data ﬂow [28]. Then, man-
ual work is involved to ﬁnd out the semantics of the vulnerability,
e.g., for CVE-2009-1833, line 3 and line 7 together cause the vul-
nerability. From the control ﬂow graph part, the sequence of three
opcodes (get_by_id, enter, and put_by_id) will lead to the vulner-
ability condition. On contrary, another sequence of three opcodes
(get_by_id, enter, and ret) will lead to a safe state. Therefore, we
create a detection format of our opcode vulnerability signature with
three states in DFA as shown in Figure 9, and meanwhile, we use
a counter i to record the number of opcode enter and ret. Next,
from data ﬂow part, we ﬁnd that line 3 and line 7 are connected
by the memory address of the prototype, and therefore, we use x
in variable pool to record that data. In the end, we combine the
DFA and the variable pool to the detection format of our opcode
vulnerability signature, and follow steps discussed in Section 5.2.2
to generate the ﬁlter format of opcode vulnerability signature.
5.4 Matching Opcode Vulnerability Signature
The matching process of opcode signatures can be divided into
two parts: pre-matching by the ﬁlter format of opcode and match-
ing by the detection format of opcode signature.
At the ﬁltering stage, we match the opcode sequence outputted
from de-obfuscation engine with the ﬁlter format of opcode signa-
ture. If a sequence of opcodes does not match with the ﬁlter format
of opcode signature, we drop it off because it will not match with
the detection format of that opcode signature either. By ﬁltering a
1 this.__defineGetter__("x", function (x){
2
’foo’.replace(/0/g,[1].push)
3
4 for (let y in [,,,])
5
6
for (let y in [,,,])
x = x;
});
Sample Two:
1 while (true) {
2
3 }
Array.prototype.push(0);
Figure 10: Example II: Different Samples that Trigger CVE-2009-0353
(Extracted and Simpliﬁed from CVE Library).
large amount of unmatched samples using fast regular expression
operation, we can accelerate the total matching process.
After the ﬁltering stage, we match the opcode sequence with
detection format. The pseudo-code of the matching algorithm is
shown in Algorithm 1. Given one opcode as an input, the match-
ing algorithm goes over every signature with that opcode. For each
signature, JShield directly fetches the corresponding clause that be-
longs to the sentence of the current state because JShield has al-
ready indexed all the signatures by opcodes. Then, JShield checks
whether the conditions are satisﬁed, and accordingly takes actions.
The complexity for this process is O(Maximum number of Signa-
tures per Opcode × Number of Opcodes).
5.5 Robustness to Polymorphic Attacks
A CVE-2009-0353 example in Figure 10, which is triggered
when repeating push operation of an array exceeding the memory
limit, shows that JShield reduces polymorphic attacks. Instead of
reporting an out-of-memory error, illegal memory address will be
overwritten.
In Figure 10, we show two different snippets of JavaScript trig-
gering CVE-2009-0353, which ﬁre push operation in two different
ways at the JavaScript level. However, at the opcode level, both
need to call opcode get_by_id ﬁrst to get push method, and then
repeat using opcode call (only one call is shown in the ﬁgure). Af-
ter generating the call graph for two JavaScript engines [14, 16] by
doxygen [7] and thus examining functions that calls push method,
we ﬁnd that the only way of calling push method is through the
opcode call. In other words, the opcode signature maps to the vul-
nerability.
For polymorphic attacks, we show that the number of polymor-
phism reduces at the opcode level because (i) one opcode signature
maps to multiple source code representations of that vulnerability;
and (ii) one source code representation of a vulnerability maps to
one speciﬁc opcode signature given an opcode instruction set.
The reasons are as follows. Assume a vulnerability is repre-
sented by an opcode signature. We follow the state transition and
get opcode sequence as follows: op_code1, op_code2, op_code3
and so on. Each opcode can be included in multiple JavaScript
statement. For example, op_call can be triggered by direct func-
tion call and getter property of an object. Similarly, op_jmp can be
triggered by while loop, for loop, and so on. We will choose differ-
ent JavaScript statement and write corresponding JavaScript source
code. To the opposite, if we have a source code representation of
a vulnerability and the opcode instruction set is ﬁxed, we can feed
JavaScript De-obfuscation Engine
Signature Matching Engine
Event Triggering
Opcode Signature Lib
Web 
Page
Browser
DOM
JS
Engine
Filter  Format Detection  Format
Pre-match
Filtering
Opcode
Matching
Report
Drop
Drop
Figure 11: System Architecture.
the source code into the interpreter with the opcode instruction set.
One unique opcode sequence is outputted from the interpreter.
6. SYSTEM ARCHITECTURE
Figure 11 shows the overall architecture of JShield, which con-
sists of two main engines, a JavaScript de-obfuscation engine and
a signature matching engine. The former takes a web page as in-
put, de-obfuscates JavaScripts, and then outputs the correspond-
ing opcode sequence; the latter takes an opcode sequence as input,
matches the sequence with opcode signature, and ﬁnally gives a
report about whether the incoming web page is malicious .
The detailed process is as follows. When a web page is fed to a
JavaScript de-obfuscation engine of JShield, it is executed on a real
browser with event triggering module, which mimics user’s behav-
iors to trigger all the DOM events. If the web page contains PDF,
JShield adopts MPScan [35] to hook an Adobe Reader and out-
put all the opcode sequences. After de-obfuscation, the signature
matching engine ﬁrst ﬁlters opcode sequences outputted from Java-
Script de-obfuscation engine. For the opcode sequences not ﬁltered
out, JShield further matches them with detection format of opcode
vulnerability signatures.
7.
IMPLEMENTATION
We use WebKit r101347 together with Qt 4.8.1 on Linux to im-
plement JShield. Web pages are directly fed into a modiﬁed version
of WebKit that is integrated with event triggering engine. External
libraries and virtual functions are loaded into WebKit through Java-
Script ﬁles. Then opcodes are generated and fed into the opcode
matching engine.
De-obfuscation. We introduce the de-obfuscation engine of JShield,
which increases the total amount of inspected source code written
by attackers, from two aspects: events recording, and event trigger-
ing.
We ﬁrst modify class Document to make every document main-
tain a queue, which records all the registered event listeners. Then
we modify function addEventListener in Node.cpp ﬁle. We choose
to modify this function in order to make sure that all listeners would
be registered, because this function is called every time a listener
is added. So when an event listener is trying to register itself on
a node, the node will call its method addEventListener(), in which
the node adds the listener in the queue maintained by the node’s
Document object. The modiﬁed addEventListener() function also
determines whether to call eventTriggering() function to trigger the
new registered event listener right away, based on whether the on-
load event listener is invoked.
Then, we add two functions: void trigerAllWindowEvents() in
DOMWindow.cpp ﬁle, used to trigger all the event listeners reg-
istered on Window object, and void eventTriggering() in Docu-
ment.cpp ﬁle, used to iterate and trigger all its children nodes
recorded in the queue. Next, we modify the function void dis-
patchWindowLoadEvent() in Document.cpp to call trigerAllWin-
dowEvents() and eventTriggering() functions and trigger all the
event listeners registered so far.
Signature Matching Engine. We ﬁrst extract opcodes from We-
bKit engine of which the interpretation mode for JavaScript is en-
abled. All the opcodes are interpreted by privateExecute function
in Interpreter.cpp at JavaScriptCore of WebKit. We extract all the
register address together with opcode names during the interpreta-
tion and feed them into the opcode matching engine.
Next, we use the standard regular expression library [12] in C++
to match the ﬁlter format of opcode signature, which is stored as
a string. After ﬁltering, the detection format of opcode signatures
is stored as a map container of STL [15], which uses a red-black
tree structure. All the signatures are indexed by opcodes. The data
domain of opcode signatures are implemented by a perl interpreter
in C [8].
8. EVALUATION
We ﬁrst introduce our methodology in Section 8.1. Next, we
evaluate vulnerability coverage in Section 8.2 and robustness to
data pollution in Section 8.3. In the end, We evaluate the perfor-
mance of JShield including JavaScript obfuscation engine, signa-
ture matching engine, and the overall system in Section 8.4.
8.1 Methodology
To evaluate JShield, we obtain JavaScript engine vulnerabilities
and plugin vulnerabilities from CVE database, the details of which
can be found in Section 8.2. We adopt three metrics to evaluate
signature matching:
• Vulnerability Coverage Rate. Vulnerability coverage rate is de-
ﬁned as the number of vulnerabilities covered by a certain ap-
proach divided by the number of all the vulnerabilities.
• Robustness to Data Pollution. We evaluate the robustness to data
pollution by detecting attacks injected with benign features and
attack variants using the same vulnerability.
• Performance. We measure the latency caused by the event trig-
gering process, the signature matching process, and the overall
JShield.
8.2 Vulnerability Coverage
Two sets of vulnerabilities are evaluated on JShield, which
are JavaScript engine vulnerabilities and plug-in vulnerabilities.
JShield contributes on detecting JavaScript engine vulnerabili-
ties, but for plug-in vulnerabilities, we are on par with existing
works [44, 50].
8.2.1 Data Source
We evaluate vulnerability coverage of JShield on those vulner-
abilities in national vulnerability database (NVD) [11]. (i) To ac-
quire JavaScript engine vulnerabilities of web browsers, we search
the keyword “JavaScript Engine” at the search engine provide by
NVD, and examine the “References to Advisories, Solutions, and
Tools” part of all the results. Each “External Source” will be ex-
amined. We pay special attention to the exploiting codes posted by
each external source. (ii) To acquire JavaScript engine vulnerabili-
ties of pdf readers, we search the keyword “JavaScript reader” and
“JavaScript pdf” at the search engine provide by NVD. The same
procedure for a JavaScript engine vulnerability will be applied to
this type of vulnerability. (iii) To acquire inter-module plugin vul-
nerabilities, we obtain information from Song et al [50].
During investigation, we output the opcode sequence of exploit-
ing codes. Based on the output opcodes, we will form an opcode
signature. If we can successfully construct an opcode signature, we
Table 3: Feasibility Comparison of JShield with Other Vulnerabilities-
based Drive-by Download Attack Detection.
Vulnerability
Position
JS Engine
PDF JS Engine
Plug-in
BrowserShield [44]
Song et al. [50]
JShield
3/22
4/18
20/21
0/22
0/18
21/21
22/22
18/18
21/21
Note: All the numbers in the table are theoretical detection ratio for each approach.
BrowserShield represents those with simple policy without control and data ﬂow
matching, and Song et al. represent those with only intra-module communications.
Table 4: JShield’s Detection Accuracy under Data Pollution.
TP for Web Pages
FP for Web Pages
TP for PDF
FP for PDF
Original
100%
0%
100%
0%
Pollted
100%
0%
100%
0%
Note: TP is short for true positive, and FP is short for false positive.
will consider JShield can detect the vulnerability. If the signature
contains only one state, we will consider BrowserShield [44] can
detect the vulnerability. If the vulnerability does not contain any
multi-module communication, we will consider Song et al. [50]
cannot detect the vulnerability.
8.2.2 Coverage Results
Three types of vulnerabilities are evaluated here, which are Java-
Script engine vulnerabilities of web browsers, JavaScript engine
vulnerabilities of PDF readers, and inter-module plug-in vulnera-
bilities, respectively.
• JavaScript Engine Vulnerabilities of Web Browsers. We evalu-
ate all twenty four JavaScript engine vulnerabilities from 2009
to 2014. We do not ﬁnd any test cases for CVE-2011-2991 and
thus skip this vulnerability. CVE-2011-4682, which bypass the
same origin policy, is out of scope of this paper and thus skipped.
For year 2014, because both NVD and CVE prevent public view
of recent vulnerabilities due to security concerns, we can only
ﬁnd two JavaScript engine vulnerability at the time of our inves-
tigation.
The results show that JShield can detect all of those vulnera-
bilities. BrowserShield [44] can only detect 3 out of 22 Java-
Script engine vulnerabilities. Song et al. [50] cannot detect any
of those vulnerabilities because they are not plug-in vulnerabil-
ities. A summary is shown in the second row of Table 3.
• JavaScript Engine Vulnerabilities of PDF Reader. Except for
ﬁve cross-site scripting vulnerabilities, all the JavaScript engine
vulnerabilities of pdf readers from 2007 to 2014. We cannot
look in the references related to two Google chrome pdf vulner-
ability because Google chrome group restrict the permission of
viewing recent vulnerabilities. The results of detecting the rest
vulnerabilities are shown in the third row of Table 3.
• Inter-module Plug-in Vulnerabilities. We obtain all the plug-in
vulnerabilities from Song et al. [50], and ﬁnd that JShield can
detect all the plug-in vulnerabilities as shown in the fourth row
of Table 3.
8.3 Robustness to Data Pollution
The same malicious data set and methodology as Section 3.1 are
used here for web pages. Benign data set for web pages are ex-
tracted from Top 500 Alexa web sites. Both malicious and benign
PDFs are acquired from security company containing 214 benign
and 213 malicious, and the same data pollution for web pages are
performed. Since there is no training stage for JShield, the pollu-
tion of training data is not applicable for JShield. Results are shown
in Table 4. Excluding those samples only contain HTML but no
100
)
%
(
n
o
i
t
c
n
u
F
n
o
i
t