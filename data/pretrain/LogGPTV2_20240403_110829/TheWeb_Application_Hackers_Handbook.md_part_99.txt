placed into another parameter, which is copied into the error message.
Because of the practical constraints imposed on scanners’ brute-force approach
to vulnerability detection, they cannot work through every permutation of
attack string in different parameters, or every permutation of functional steps.
Of course, no human being can do this practically either. However, a human
frequently has a feel for where the bugs are located, where the developer made
assumptions, and where something doesn’t “look right.” Hence, a human tester
will select a tiny proportion of the total possible attacks for actual investigation
and thereby will often achieve success.
cc2200..iinndddd 777777 88//1199//22001111 1122::2211::1100 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 778
778 Chapter 20 n A Web Application Hacker’s Toolkit
Technical Challenges Faced by Scanners
The barriers to automation described previously lead to a number of specifi c
technical challenges that must be addressed in the creation of an effective
vulnerability scanner. These challenges affect not only the scanner’s ability to
detect specifi c types of vulnerabilities, as already described, but also its ability
to perform the core tasks of mapping the application’s content and probing for
defects.
Some of these challenges are not insuperable, and today’s scanners have found
ways of partially addressing them. Scanning is by no means a perfect science,
however, and the effectiveness of modern scanning techniques varies widely
from application to application.
Authentication and Session Handling
The scanner must be able to work with the authentication and session-handling
mechanisms used by different applications. Frequently, the majority of an appli-
cation’s functionality can only be accessed using an authenticated session, and a
scanner that fails to operate using such a session will miss many detectable fl aws.
In current scanners, the authentication part of this problem is addressed by
allowing the user of the scanner to provide a login script or to walk through the
authentication process using a built-in browser, enabling the scanner to observe
the specifi c steps involved in obtaining an authenticated session.
The session-handling part of the challenge is less straightforward to address
and comprises the following two problems:
n The scanner must be able to interact with whatever session-handling
mechanism the application uses. This may involve transmitting a session
token in a cookie, in a hidden form fi eld, or within the URL query string.
Tokens may be static throughout the session or may change on a per-request
basis, or the application may employ a different custom mechanism.
n The scanner must be able to detect when its session has ceased to be valid
so that it can return to the authentication stage to acquire a new one. This
may occur for various reasons. Perhaps the scanner has requested the logout
function, or the application has terminated the session because the scan-
ner has performed abnormal navigation or has submitted invalid input.
The scanner must detect this both during its initial mapping exercises
and during its subsequent probing for vulnerabilities. Different applica-
tions behave in very different ways when a session becomes invalid. For a
scanner that only analyzes the syntactic content of application responses,
this may be a diffi cult challenge to meet in general, particularly if a non-
standard session-handling mechanism is used.
cc2200..iinndddd 777788 88//1199//22001111 1122::2211::1100 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 779
Chapter 20 n A Web Application Hacker’s Toolkit 779
It is fair to say that some of today’s scanners do a reasonable job of working
with the majority of authentication and session-handling mechanisms that are
in use. However, there remain numerous cases where scanners struggle. As
a result, they may fail to properly crawl or scan key parts of an application’s
attack surface. Because of the fully automated way in which standalone scan-
ners operate, this failure normally is not apparent to the user.
Dangerous Effects
In many applications, running an unrestricted automated scan without any user
guidance may be quite dangerous to the application and the data it contains.
For example, a scanner may discover an administration page that contains
functions to reset user passwords, delete accounts, and so on. If the scanner
blindly requests every function, this may result in access being denied to all
users of the application. Similarly, the scanner may discover a vulnerability
that can be exploited to seriously corrupt the data held within the application.
For example, in some SQL injection vulnerabilities, submitting standard SQL
attack strings such as or 1=1-- causes unforeseen operations to be performed
on the application’s data. A human being who understands the purpose of a
particular function may proceed with caution for this reason, but an automated
scanner lacks this understanding.
Individuating Functionality
There are many situations in which a purely syntactic analysis of an application
fails to correctly identify its core set of individual functions:
n Some applications contain a colossal quantity of content that embodies
the same core set of functionality. For example, applications such as eBay,
MySpace, and Amazon contain millions of different application pages
with different URLs and content, yet these correspond to a relatively small
number of actual application functions.
n Some applications may have no fi nite boundary when analyzed from a
purely syntactic perspective. For example, a calendar application may
allow users to navigate to any date. Similarly, some applications with a
fi nite amount of content employ volatile URLs or request parameters to
access the same content on different occasions, leading scanners to con-
tinue mapping indefi nitely.
n The scanner’s own actions may result in the appearance of seemingly new
content. For example, submitting a form may cause a new link to appear
in the application’s interface, and accessing the link may retrieve a further
form that has the same behavior.
cc2200..iinndddd 777799 88//1199//22001111 1122::2211::1100 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 780
780 Chapter 20 n A Web Application Hacker’s Toolkit
In any of these situations, a human attacker can quickly “see through” the
application’s syntactic content and identify the core set of actual functions that
need to be tested. For an automated scanner with no semantic understanding,
this is considerably harder to do.
Aside from the obvious problems of mapping and probing the application
in the situations described, a related problem arises in the reporting of discov-
ered vulnerabilities. A scanner based on purely syntactic analysis is prone to
generating duplicate fi ndings for each single vulnerability. For example, a scan
report might identify 200 XSS fl aws, 195 of which arise in the same application
function that the scanner probed multiple times because it appears in different
contexts with different syntactic content.
Other Challenges to Automation
As discussed in Chapter 14, some applications implement defensive measures
specifi cally designed to prevent them from being accessed by automated client
programs. These measures include reactive session termination in the event of
anomalous activity and the use of CAPTCHAs and other controls designed to
ensure that a human being is responsible for particular requests.
In general, the scanner’s spidering function faces the same challenges as web
application spiders more generally, such as customized “not found” responses
and the ability to interpret client-side code. Many applications implement fi ne-
grained validation over particular items of input, such as the fi elds on a user
registration form. If the spider populates the form with invalid input and is
unable to understand the error messages generated by the application, it may
never proceed beyond this form to some important functions lying behind it.
The rapid evolution of web technologies, particularly the use of browser
extension components and other frameworks on the client side, means that most
scanners lag behind the latest trends. This can result in failures to identify all
the relevant requests made within the application, or the precise format and
contents of requests that the application requires.
Furthermore, the highly stateful nature of today’s web applications, with
complex data being held on both the client and server side, and updated via
asynchronous communications between the two, creates problems for most fully
automated scanners, which tend to work on each request in isolation. To gain
complete coverage of these applications, it is often necessary to understand the
multistage request processes that they involve and to ensure that the application
is in the desired state to handle a particular attack request. Chapter 14 describes
techniques for achieving this within custom automated attacks. They generally
cc2200..iinndddd 778800 88//1199//22001111 1122::2211::1100 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 781
Chapter 20 n A Web Application Hacker’s Toolkit 781
require intelligent human involvement to understand the requirements, confi gure
the testing tools appropriately, and monitor their performance.
Current Products
The market for automated web scanners has thrived in recent years, with a great
deal of innovation and a wide range of different products. Here are some of the
more prominent scanners:
n Acunetix
n AppScan
n Burp Scanner
n Hailstorm
n NetSparker
n N-Stalker
n NTOSpider
n Skipfi sh
n WebInspect
Although most mature scanners share a common core of functionality, they
have differences in their approaches to detecting different areas of vulnerabili-
ties and in the functionality presented to the user. Public discussions about
the merits of different scanners often degenerate into mudslinging between
vendors. Various surveys have been performed to evaluate the performance of
different scanners in detecting different types of security fl aws. Such surveys
always involve running the scanners against a small sample of vulnerable code.
This may limit the extrapolation of the results to the wide range of real-world
situations in which scanners may be used.
The most effective surveys run each scanner against a wide range of sample
code that is derived from real-world applications, without giving vendors an
opportunity to adjust their product to the sample code before the analysis. One
such academic study by the University of California, Santa Barbara, claims to
be “the largest evaluation of web application scanners in terms of the number
of tested tools ... and the class of vulnerabilities analyzed.” You can download
the report from the study at the following URL:
www.cs.ucsb.edu/~adoupe/static/black-box-scanners-dimva2010.pdf
cc2200..iinndddd 778811 88//1199//22001111 1122::2211::1100 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 782
782 Chapter 20 n A Web Application Hacker’s Toolkit
The main conclusions of this study were as follows:
n Whole classes of vulnerabilities cannot be detected by state-of-the-art scan-
ners, including weak passwords, broken access controls, and logic fl aws.
n The crawling of modern web applications can be a serious challenge for
today’s web vulnerability scanners due to incomplete support for com-
mon client-side technologies and the complex stateful nature of today’s
applications.
n There is no strong correlation between price and capability. Some free or
very cost-effective scanners perform as well as scanners that cost thou-
sands of dollars.
The study assigned each scanner a score based on its ability to identify dif-
ferent types of vulnerabilities. Table 20-1 shows the overall scores and the price
of each scanner.
Table 20-1: Vulnerability Detection Performance and Prices of Different Scanners According
to the UCSB Study
SCANNER SCORE PRICE
Acunetix 14 $4,995 to $6,350
WebInspect 13 $6,000 to $30,000
Burp Scanner 13 $191
N-Stalker 13 $899 to $6,299
AppScan 10 $17,550 to $32,500
w3af 9 Free
Paros 6 Free
HailStorm 6 $10,000
NTOSpider 4 $10,000
MileSCAN 4 $495 to $1,495
Grendel-Scan 3 Free
It should be noted that scanning capabilities have evolved considerably in
recent years and are likely to continue to do so. Both the performance and
price of individual scanners are likely to change over time. The UCSB study
that reported the information shown in Table 20-1 was published in June 2010.
Because of the relative scarcity of reliable public information about the per-
formance of web vulnerability scanners, it is recommended that you do your
own research before making any purchase. Most scan vendors provide detailed
product documentation and free trial editions of their software, which you can
use to help inform your product selection.
cc2200..iinndddd 778822 88//1199//22001111 1122::2211::1111 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 783
Chapter 20 n A Web Application Hacker’s Toolkit 783
Using a Vulnerability Scanner
In real-world situations, the effectiveness of using a vulnerability scanner depends
largely on the application you are targeting. The inherent strengths and weak-
nesses that we have described affect different applications in different ways,
depending on the types of functionality and vulnerabilities they contain.
Of the various kinds of vulnerabilities commonly found within web applica-
tions, automated scanners are inherently capable of discovering approximately
half of these, where a standard signature exists. Within the subset of vulnerability
types that scanners can detect, they do a good job of identifying individual cases,
although they miss the more subtle and unusual instances of these. Overall,
you may expect that running an automated scan will identify some but not all
of the low-hanging fruit within a typical application.
If you are a novice, or you are attacking a large application and have limited
time, running an automated scan can bring clear benefi ts. It will quickly identify
several leads for further manual investigation, enabling you to get an initial
handle on the application’s security posture and the types of fl aws that exist.
It will also provide you with a useful overview of the target application and
highlight any unusual areas that warrant further detailed attention.
If you are an expert at attacking web applications, and you are serious about
fi nding as many vulnerabilities as possible within your target, you are all too
aware of the inherent limitations of vulnerability scanners. Therefore, you will
not fully trust them to completely cover any individual category of vulnerabil-
ity. Although the results of a scan will be interesting and will prompt manual
investigation of specifi c issues, you will typically want to perform a full manual
test of every area of the application for every type of vulnerability to satisfy
yourself that the job has been done properly.
In any situation where you employ a vulnerability scanner, you should
keep in mind some key points to ensure that you make the most effective
use of it:
n Be aware of the kinds of vulnerabilities that scanners can detect and those
that they cannot.
n Be familiar with your scanner’s functionality, and know how to leverage
its confi guration to be the most effective against a given application.
n Familiarize yourself with the target application before running your scan-
ner so that you can make the most effective use of it.
n Be aware of the risks associated with spidering powerful functionality
and automatically probing for dangerous bugs.
n Always manually confi rm any potential vulnerabilities reported by the
scanner.
cc2200..iinndddd 778833 88//1199//22001111 1122::2211::1111 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 784
784 Chapter 20 n A Web Application Hacker’s Toolkit
n Be aware that scanners are extremely noisy and leave a signifi cant foot-
print in the logs of the server and any IDS defenses. Do not use a scanner
if you want to be stealthy.
Fully Automated Versus User-Directed Scanning
A key consideration in your usage of web scanners is the extent to which you
want to direct the work done by the scanner. The two extreme use cases in this
decision are as follows:
n You want to give your scanner the URL for the application, click Go, and
wait for the results.
n You want to work manually and use a scanner to test individual requests
in isolation, alongside your manual testing.
Standalone web scanners are geared more toward the fi rst of these use cases.
The scanners that are incorporated into integrated testing suites are geared
more toward the second use case. That said, both types of scanners allow you
to adopt a more hybrid approach if you want to.
For users who are novices at web application security, or who require
a quick assessment of an application, or who deal with a large number of
applications on a regular basis, a fully automated scan will provide some
insight into part of the application’s attack surface. This may help you make
an informed decision about what level of more comprehensive testing is
warranted for the application.
For users who understand how web application security testing is done
and who know the limitations of total automation, the best way to use a scan-
ner is within an integrated testing suite to support and enhance the manual
testing process. This approach helps avoid many of the technical challenges
faced by fully automated scanners. You can guide the scanner using your
browser to ensure that no key areas of functionality are missed. You can
directly scan the actual requests generated by the application, containing
data with the correct content and format that the application requires. With
full control over what gets scanned, you can avoid dangerous functionality,
recognize duplicated functionality, and step through any input validation
requirements that an automated scanner might struggle with. Furthermore,
when you have direct feedback about the scanner’s activity, you can ensure
that problems with authentication and session handling are avoided and that
issues caused by multistage processes and stateful functions are handled
properly. By using a scanner in this way, you can cover an important range
of vulnerabilities whose detection can be automated. This will free you to
look for the types of vulnerabilities that require human intelligence and
experience to uncover.
cc2200..iinndddd 778844 88//1199//22001111 1122::2211::1111 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 785
Chapter 20 n A Web Application Hacker’s Toolkit 785
Other Tools
In addition to the tools already discussed, you may fi nd countless others use-
ful in a specifi c situation or to perform a particular task. The remainder of this
chapter describes a few other tools you are likely to encounter and use when
attacking applications. It should be noted that this is only a brief survey of
some tools that the authors have used. It is recommended that you investigate