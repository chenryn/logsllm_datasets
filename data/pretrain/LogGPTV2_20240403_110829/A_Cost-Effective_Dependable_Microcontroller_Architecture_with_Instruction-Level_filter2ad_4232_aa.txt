title:A Cost-Effective Dependable Microcontroller Architecture with Instruction-Level
Rollback for Soft Error Recovery
author:Teruaki Sakata and
Teppei Hirotsu and
Hiromichi Yamada and
Takeshi Kataoka
A Cost-effective Dependable Microcontroller Architecture with
Instruction-level Rollback for Soft Error Recovery
∗
Teruaki Sakata
∗
†
Standard Product Business Group, Renesas Technology Corp.
E-mail: {teruaki.sakata.ac, teppei.hirotsu.nm, hiromichi.yamada.pc}@hitachi.com
, Teppei Hirotsu
Hitachi Research Laboratory, Hitachi Ltd.
∗
, Hiromichi Yamada
∗
†
, Takeshi Kataoka
Abstract
A cost-effective, dependable microcontroller architec-
ture has been developed. To detect soft errors, we developed
an electronic design automation (EDA) tool that generates
optimized soft error-detecting logic circuits for ﬂip-ﬂops.
After a soft error is detected, the error detection signal goes
to a developed rollback control module (RCM), which re-
sets the CPU and restores the CPU’s register ﬁle from the
backup register ﬁle using a rollback program routine. Af-
ter the routine, the CPU restarts from the instruction exe-
cuted before the soft error occurred. In addition, there is
a developed error reset module (ERM) that can restore the
RCM from soft errors. We also developed an error correc-
tion module (ECM) that corrects ECC errors in RAM after
error detection with no delay overheads. Testing on a 32-
bit RISC microcontroller and EEMBC benchmarks showed
that the area overhead was under 59% and frequency over-
head was under 9%. In a soft error injection simulation,
the MTBF of random logic circuits, and the MTBF of RAM
were 30 and 1.34 times longer, respectively, than those of
the original microcontroller.
1. Introduction
Future automotive electronic control systems, X-by-
Wire systems, are now being developed [1][2], and high-
level automatic controls, such as crash prevention auto-
steering, will be implemented into these systems. X-by-
Wire requires microcontrollers that perform better than de-
vices currently used in anti-lock brake, electric power steer-
ing, and other systems. The microcontroller should be faster
and the semiconductor feature sizes should be smaller.
However, since X-by-Wire is a safety critical system,
highly dependable and fault tolerant architectures must be
developed because a failure of the electronic system could
cause serious accidents. Microcontrollers used in X-by-
Wire systems must be very reliable and urgently require
improved failure detection and recovery architectures. Fail-
ures in microcontrollers can be categorized as hard errors or
soft errors. Hard errors are permanent errors, such as wire
or connection breakage caused by electromigration. Soft er-
rors, which are random transient errors, have recently been
attracting more attention because they are the main cause of
failures in microcontrollers [3]. The causes of soft errors in
microcontrollers include reversal of a memory element’s bit
data due to factors such as alpha rays in a package, neutron
strikes, and noise from the surrounding environment. As
semiconductor feature sizes and supply voltages have de-
creased, soft error rate (SER) has increased [4]. Soft errors
occur both in the microcontroller’s memory elements, such
as RAM and ﬂip-ﬂop (F/F), and in combinational logic cir-
cuits. The former is called a single event upset (SEU), and
the latter is called a single event transient (SET) [5]. SET
occurs at the rise of the clock edge, so SEU is thought to be
predominant in a wide range of embedded microcontrollers,
from dozens to several hundreds of MHz.
The popular approach to highly dependable large-scale
integration is module redundancy and comparison of out-
put signals. However, there are many restrictions, such as
package size, cost, and power consumption, for microcon-
trollers used in automobiles. Therefore the increased area
required for the module redundancy approach is undesir-
able. Also, because error correcting code (ECC) logic cir-
cuits for memory modules have a large frequency overhead,
it is difﬁcult for high-performance X-by-Wire systems to
implement ECC RAM architecture.
We have developed a cost-effective microcontroller ar-
chitecture for soft error recovery that can be used in embed-
ded systems that require low cost and high performance.
In the next Section, we explain our solutions to various
microcontroller design issues. Our dependable microcon-
troller architecture is described in detail in Section 3, the
results of evaluations of our architecture are presented in
Section 4, related work is discussed in Section 5, and the
paper is concluded in Section 6.
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 20072. Design issues and solutions
Our target is a one-chip microcontroller with CPU,
RAM, and random logic circuits. Our purpose is to realize
low-overhead, dependable, low SER microcontroller archi-
tecture. We used microcontrollers with ECC RAM which
have the problems listed below:
1. Soft errors occurring in random logic circuits cannot
be detected.
2. If a soft error is detected, there is no means of recover-
ing from it.
3. The ECC timing critical path incurs a large frequency
overhead.
To solve these problems, we ﬁrst focused on detecting
the soft errors that occur in the F/Fs of the random logic cir-
cuits. Newly generated detecting logic circuits detect data
reverses in F/Fs.
Second, we developed a rollback control module (RCM).
After a soft error is detected, the RCM resets the CPU, and
the rollback program restores the CPU to its pre-error sta-
tus. The CPU then restarts from the instruction that was
executed before the soft error occurred. If soft errors oc-
cur in the RCM, the rollback process will not run correctly.
Therefore, we also developed an error reset module (ERM)
that can restore the RCM and other modules from soft er-
rors.
Third, we changed the ECC architecture so that the ECC
critical path is branched and the CPU reads the uncorrected
data directly from the RAM, eliminating ECC delay over-
heads. If an ECC error is detected, the developed error cor-
rection module (ECM) cancels CPU read access and writes
back correct data at the next cycle. After the ECC error has
been corrected, the CPU restarts from the instruction at the
point when the ECC error was detected.
Details of these developed architectures are described in
the next Section.
3. Features of dependable microcontroller ar-
chitecture
3.1. Automatic generation of soft error-
detecting logic circuits
We implemented an electronic design automation (EDA)
tool that generates soft error-detecting logic circuits for F/Fs
in a microcontroller with low overheads. The ﬁrst feature is
selection of the optimal soft error-detecting logic circuits.
For example, in the random logic circuit in the upper left
of Figure 1, the target for detecting soft errors is the 32-bit
”FFa”. One possible soft error detection approach is parity,
Timing critical part, 
generating parity
32
FFa
32
...
11
＋
Soft Error
Soft Error
Detection
Detection
1
1
＋
11
Random Logic Circuit
Combinational 
Logic Circuit
FFa
32
32
Large Delay
Small Area
32
FFa
32
...
Non-critical part,
generating F/F redundancy
32
Soft Error
Soft Error
Detection
Detection
1
Flip-Flop
＋
XOR(Parity Generation)
Small Delay
Large Area
(a) Selection of soft error detecting logic circuits
FFb
3232
3232
＋
＋
Large Delay
22
FFc
22
44
FFd
44
＋
＋
＋
＋
Timing critical part,
dividing parity
FFb
3232
3232
[31:16]
[15:0]
＋
＋
[31:16]
[15:0]
＋
＋
Small Delay
Soft Error
Soft Error
Detection
Detection
Non-critical part,
grouping parity
22
44
FFc
FFd
22
44
Soft Error
Soft Error
Detection
Detection
＋
＋
Large Area
Small Area
(b) Dividing and grouping of soft error detecting logic circuits
Figure 1. Generaion of soft error-detecting
logic circuits
shown in the upper right of Figure 1(a). Area overhead will
be low, but the delay overhead as a consequence of gener-
ating a parity bit may cause a timing violation. Meanwhile,
F/F redundancy, in the lower right of Figure 1(a) will re-
quire a larger area than parities, but the delay overhead will
be small. The tool therefore selects the optimal soft error-
detecting logic circuits for F/Fs in accordance with timing
information.
The second feature is optimization of generated circuits
by dividing or grouping F/Fs. For instance, there is the ran-
dom logic circuit generated parity shown in the upper left
of Figure 1(b). If the delay overhead of the 32-bit parity
is too large, this tool divides the data signals of ”FFb” into
two 16-bit data signals and generates two parities instead of
one 32-bit parity. This division process decreases the de-
lay overhead of parity generation. The lower left diagram
in Figure 1(b) shows that this tool groups 2-bit and 4-bit
F/Fs synchronized with the same clock signal and generates
one parity. This effectively reduces the area overhead of the
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007CPU Data Path
CPU
Instruction
Instruction
Queue
Queue
PCPC
Instruction Decode
Register File
SRSR
R0R0
Write 0
Write 1
CPU
CPU
Control Unit
Control Unit
ALU
Interrupt
Control
CPU Reset
Soft Error Detecting 
Logic Circuit of CPU
Rollback Control Module (RCM)
Rollback Control Module (RCM)
Execute Instruction Queue
e
d
o
c
e
D
Rollback PC
Reorder Control
Write Queue
Backup Register File
PCPC
R0R0
SRSR
Rollback
State Machine
Rollback 
Miss
Cycle
Inst.1
Inst.2
Inst.3
Inst.4
Inst.5
Inst.6
Inst.m(JMP)
.
.
.
Inst.n(RTE)
Inst.2
Inst.3
1      2     3     4     5     6     7      8
c1   c2   c3   c4  c5
...
MA WB
MA WB
EX
ID EX MA WB
IF ID
MA
EX
WB
IF ID EX MA
IF ID EX
Cancel CPU 
Instructions
IF
IF ID EX
IF ID
IF
CPU restarts 
from Inst.2 
Soft Error
CPU Soft Error
CPU Reg.File
0
1
x
RESET 
...
...
...
...
1 
CPU Bus
Write Cancel
RAM
Soft Error Detecting Signal
Register File Restore Path
Figure 2. Rollback control module (RCM) for
CPU
generated soft error-detecting logic circuits. In this way, the
tool automatically optimizes the area and delay overheads
of the generated detecting logic circuits.
This tool was applied to hierarchical designed random
logic circuits by a bottom-up process in this study, and it
was found that the generation time is faster than that re-
ported in our previous paper [6].
3.2. Instruction-level rollback architecture
for random logic circuits
3.2.1. Soft error recovery of CPU
We developed a rollback control module (RCM) to reset
the CPU and restore its register ﬁle. In Figure 2, a pipelined
RISC CPU executes instructions as follows: the CPU reads
instructions from RAM and inserts the instruction queue;
the CPU decodes the instructions and writes operation data
to the register ﬁle; the operation data are executed by the
ALU; the CPU executes RAM access and register write-
back. The RCM has a backup register ﬁle that stores the
latched data of the CPU’s register ﬁle through the write
queue. The reorder control block in the RCM receives the
in-order information of issued instructions from the execute
instruction queue and selects the write data to be stored to
the backup register ﬁle. When the RCM receives a CPU soft
error signal, the RCM issues a CPU reset signal and a RAM
write cancel signal. Soft errors occurring in the CPU are
detected by soft error-detecting logic circuits that are gen-
erated by the tool explained in Section 3.1. The rollback
sequence is implemented as an exception processing of the
CPU, and the rollback interruption is given the highest pri-
ority. The rollback miss signal is used in case the rollback
control does not work.
Backup Reg.File
-2
-1
0
1                                                               
Rollback by Software
...
...
CPU Soft Error
Write Cancel
CPU Reset
...
...
...
...
...
...
...
Rollback State 
Machine
BACKUP 
DET-
ECT
CPU_ 
RESET 
BRA-
NCH
CPU_ROLLBACK
BACKUP
...
...
CPU
Reset Term
CPU Soft Error 
Exception Term
About 90 CPU Cycles
IF Instruction Fetch
ID Instruction Decode
EX Execute
MA Memory Access WB Register Write Back
Figure 3. Rollback control ﬂow in CPU
Figure 3 shows the rollback sequence for a ﬁve-state
pipelined CPU. CPU instructions are executed from Inst.1.
In normal execution, the rollback state machine stays in
a BACKUP state that stores the delayed data of the CPU
Reg.File. The numbers in the CPU Reg.File and Backup
Reg.File express the instruction numbers at the top of Fig-
ure 3. A soft error occurs in a F/F of the CPU in cycle 3,
the error is detected at that time, and a CPU soft error sig-
nal is issued. In the next cycle, 4, the rollback state machine
changes the DETECT state, and the writing process to RAM
is canceled. In cycle 5, the CPU is reset and the soft error
that occurred in cycle 3 is cleared. After the reset process,
the BRANCH state of the rollback state machine makes the
CPU branch to the soft error exception routine by execut-
ing Inst.m. The rollback state machine stays in the ROLL-
BACK state and restores the data of CPU Reg.File that was
stored in the Backup Reg.File during the CPU soft error
exception routine when Inst.1 was executed.
In this pro-
cess, the CPU recovers from the soft error and its program
counter (PC) is restored to Inst.2, which had not been exe-
cuted when the soft error occurred. After the CPU soft error
exception routine, the return-from-exception (RTE) instruc-
tion is executed and the CPU restarts from Inst.2. The pro-
cess, from detecting a soft error to restarting the CPU takes
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007Rollback Control Module (RCM)
Rollback Control Module (RCM)
Rollback
State
Machine
Resets Instruction 
Queue, Write Queue, 
Backup Register File
Soft Error Detecting 
Logic Circuit of RCM
CPU Soft Error
RCM Reset
RCM Soft Error
CPU Reset
RCM Soft Error 
Exception
Other Module
Reset
Error Reset Module (ERM)
Error Reset Module (ERM)
Error Reset Module (ERM)
Decode
CPU Soft Error
Other Module
Soft Error
TMR Approach
Figure 4. Error reset module (ERM)
about 90 cycles.
Implementing the addition of the RCM is not difﬁcult
because we do not need to customize the original pipelined
CPU architecture.
3.2.2. Soft error recovery of rollback control module by
error reset architecture
To detect soft errors in the RCM, we applied the tool
explained in Section 3.1 to the RCM as shown in Figure
4. We also developed an error reset module (ERM), which
receives soft error signals from the CPU, RCM, and other
modules. If a soft error occurs in the CPU, the ERM issues
a CPU reset signal to the CPU, and the ERM sends a CPU
soft error signal to the RCM to execute the rollback control
process explained in Section 3.2.1. On the other hand, if a
soft error occurs in the RCM, the ERM issues an RCM reset
signal to the RCM, and the ERM sends an RCM soft error
exception signal to the CPU.
Figure 5 shows the timing chart when a soft error has
occurred in the rollback state machine of the RCM in cy-
cle 3. The RCM soft error signal is issued at the same
time. In the next cycle 4, the ERM issues an RCM reset
signal and an RCM soft error exception signal is sent to the
CPU. The CPU cancels Inst.7, fetching a new instruction,
and branches to the RCM soft error exception routine in cy-
cle 6. In the RCM soft error exception routine, the CPU
executes writing data from the CPU Reg.File to the Backup
Reg.File and the remaining effects caused by the soft error
are cleared. After the RCM soft error exception routine,
the RTE instruction is executed and the CPU restarts from
Inst.7. These processes take about 70 cycles.
This ERM is implemented by dual (DMR) or triple mod-
ule redundancy (TMR) approaches because it consists only
of small F/Fs and combinational logic circuits. Therefore,
1      2     3     4     5     6     7
c1   c2  c3  c4   c5
...
Cycle
Inst.1
Inst.2
Inst.3