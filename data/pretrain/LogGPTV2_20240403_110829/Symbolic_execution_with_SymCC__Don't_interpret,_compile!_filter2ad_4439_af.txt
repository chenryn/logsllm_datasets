based approaches), but the analysis is very fast—considerably
faster even than current IR-less techniques.
Acknowledgments
We would like to thank Insu Yun, the ﬁrst author of QSYM,
for helping us to replicate the experimental results reported in
the QSYM paper [45]. Moreover, we are grateful to Khaled
Yakdan for his feedback on earlier versions of this paper. Fi-
nally, we thank the anonymous paper and artifact reviewers
for taking the time to study our work and provide constructive
feedback. This work has been supported by the DAPCODS/I-
OTics ANR 2016 project (ANR-16-CE25-0015).
Availability
SYMCC is publicly available at http://www.s3.eurecom.
fr/tools/symbolic_execution/symcc.html. The page
also contains links to the source code of all programs that we
used in our evaluation, as well as the raw results of the ex-
periments. SYMCC’s code base is thoroughly documented in
order to serve as a basis for future research by the community.
References
[1] Apple Inc.
Swift.org – compiler and standard
https://swift.org/compiler-stdlib/
library.
#compiler-architecture.
[2] Fabrice Bellard. QEMU, a fast and portable dynamic
translator. In USENIX Annual Technical Conference,
FREENIX Track, volume 41, page 46, 2005.
[3] Rastislav Bodík, Kartik Chandra, Phitchaya Mangpo
Phothilimthana, and Nathaniel Yazdani.
Domain-
In 2nd Summit on
speciﬁc symbolic compilation.
Advances in Programming Languages (SNAPL 2017).
Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik,
2017.
[4] Marcel Böhme, Van-Thuan Pham, Manh-Dung Nguyen,
and Abhik Roychoudhury. Directed greybox fuzzing. In
Proceedings of the 2017 ACM SIGSAC Conference on
USENIX Association
29th USENIX Security Symposium    195
Computer and Communications Security, pages 2329–
2344. ACM, 2017.
[5] Cristian Cadar, Daniel Dunbar, and Dawson R. Engler.
KLEE: Unassisted and automatic generation of high-
coverage tests for complex systems programs. In OSDI,
volume 8, pages 209–224, 2008.
[6] Cristian Cadar, Vijay Ganesh, Peter M. Pawlowski,
David L. Dill, and Dawson R. Engler. EXE: automat-
ically generating inputs of death. ACM Transactions
on Information and System Security (TISSEC), 12(2):10,
2008.
[7] Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert,
and David Brumley. Unleashing Mayhem on binary
code. In 2012 IEEE Symposium on Security and Privacy,
pages 380–394. IEEE, 2012.
[8] Hongxu Chen, Yinxing Xue, Yuekang Li, Bihuan Chen,
Xiaofei Xie, Xiuheng Wu, and Yang Liu. Hawkeye:
Towards a desired directed grey-box fuzzer. In Proceed-
ings of the 2018 ACM SIGSAC Conference on Computer
and Communications Security, pages 2095–2108. ACM,
2018.
[9] Vitaly Chipounov, Volodymyr Kuznetsov, and George
Candea. S2E: A platform for in-vivo multi-path analysis
In ACM SIGARCH Computer
of software systems.
Architecture News, volume 39, pages 265–278. ACM,
2011.
[10] Nassim Corteggiani, Giovanni Camurati, and Aurélien
Francillon. Inception: system-wide security testing of
real-world embedded systems software. In 27th USENIX
Security Symposium (USENIX Security 18), pages 309–
326, 2018.
[11] Leonardo De Moura and Nikolaj Bjørner. Z3: An efﬁ-
cient SMT solver. In International conference on Tools
and Algorithms for the Construction and Analysis of
Systems, pages 337–340. Springer, 2008.
[12] Joe W. Duran and Simeon Ntafos. A report on ran-
dom testing. In Proceedings of the 5th International
Conference on Software Engineering, ICSE ’81, pages
179–183, Piscataway, NJ, USA, 1981. IEEE Press.
[13] E. Allen Emerson and Edmund M. Clarke. Character-
izing correctness properties of parallel programs using
ﬁxpoints. In International Colloquium on Automata,
Languages, and Programming, pages 169–181. Springer,
1980.
[14] Shuitao Gan, Chao Zhang, Xiaojun Qin, Xuwen Tu,
Kang Li, Zhongyu Pei, and Zuoning Chen. CollAFL:
Path sensitive fuzzing. In 2018 IEEE Symposium on
Security and Privacy, pages 679–696. IEEE, 2018.
[15] Go git
repositories.
googlesource.com/gollvm/.
gollvm.
https://go.
[16] Patrice Godefroid, Nils Klarlund, and Koushik Sen.
DART: directed automated random testing. In ACM Sig-
plan Notices, volume 40, pages 213–223. ACM, 2005.
[17] Patrice Godefroid, Michael Y. Levin, and David Molnar.
Sage: whitebox fuzzing for security testing. Communi-
cations of the ACM, 55(3):40–44, 2012.
[18] Alex Horn. Clang CRV front-end. https://github.
com/ahorn/native-symbolic-execution-clang,
2014.
[19] Alex Horn. SMT Kit. https://github.com/ahorn/
smt-kit, 2014.
[20] C.-A. Hsieh, M. T. Conte, T. L. Johnson, J. C. Gyllen-
haal, and W.-W. Hwu. Compilers for improved java
performance. Computer, 30(6):67–75, June 1997.
[21] Soomin Kim, Markus Faerevaag, Minkyu Jung, SeungIl
Jung, DongYeop Oh, JongHyup Lee, and Sang Kil Cha.
Testing intermediate representations for binary analysis.
In Proceedings of the 32nd IEEE/ACM International
Conference on Automated Software Engineering, pages
353–364. IEEE Press, 2017.
[22] James C. King. Symbolic execution and program testing.
Communications of the ACM, 19(7):385–394, 1976.
[23] George Klees, Andrew Ruef, Benji Cooper, Shiyi Wei,
and Michael Hicks. Evaluating fuzz testing. In Proceed-
ings of the 2018 ACM SIGSAC Conference on Computer
and Communications Security, pages 2123–2138, 2018.
[24] Volodymyr Kuznetsov, Johannes Kinder, Stefan Bucur,
and George Candea. Efﬁcient state merging in symbolic
execution. In Acm Sigplan Notices, volume 47, pages
193–204. ACM, 2012.
[25] Chris Lattner and Vikram Adve. LLVM: A compilation
framework for lifelong program analysis & transforma-
tion. In Proceedings of the International Symposium on
Code Generation and Optimization: Feedback-Directed
and Runtime Optimization, page 75. IEEE Computer
Society, 2004.
[26] LLVM Project. "libc++" C++ standard library. https:
//libcxx.llvm.org/.
[27] LLVM Project. libFuzzer – a library for coverage-guided
fuzz testing. https://llvm.org/docs/LibFuzzer.
html.
[28] Chi-Keung Luk, Robert Cohn, Robert Muth, Harish
Patil, Artur Klauser, Geoff Lowney, Steven Wallace, Vi-
jay Janapa Reddi, and Kim Hazelwood. Pin: building
196    29th USENIX Security Symposium
USENIX Association
customized program analysis tools with dynamic instru-
mentation. In Acm sigplan notices, volume 40, pages
190–200. ACM, 2005.
[29] Nicholas Nethercote and Julian Seward. Valgrind: a
framework for heavyweight dynamic binary instrumen-
In ACM SIGPLAN 2007 Conference on Pro-
tation.
gramming Language Design and Implementation (PLDI
2007), volume 42, pages 89–100. ACM, 2007.
[30] Anh Nguyen-Tuong, David Melski, Jack W. Davidson,
Michele Co, William Hawkins, Jason D. Hiser, Derek
Morris, Ducson Nguyen, and Eric Rizzi. Xandra: An
autonomous cyber battle system for the cyber grand
challenge. IEEE Security & Privacy, 16(2):42–51, 2018.
[31] Sebastian Österlund, Kaveh Razavi, Herbert Bos, and
Cristiano Giuffrida. Parmesan: Sanitizer-guided grey-
In 29th USENIX Security Symposium
box fuzzing.
(USENIX Security 20), 2020.
[32] Sebastian Poeplau and Aurélien Francillon. Systematic
comparison of symbolic execution systems: intermedi-
ate representation and its generation. In Proceedings of
the 35th Annual Computer Security Applications Con-
ference, pages 163–176. ACM, 2019.
[33] Jean-Pierre Queille and Joseph Sifakis. Speciﬁcation
and veriﬁcation of concurrent systems in CESAR. In
International Symposium on Programming, pages 337–
351. Springer, 1982.
[34] Florent Saudel and Jonathan Salwan. Triton: A dynamic
symbolic execution framework. In Symposium sur la
sécurité des technologies de l’information et des commu-
nications, SSTIC, France, Rennes, June 3-5 2015, pages
31–54. SSTIC, 2015.
[35] Koushik Sen, Darko Marinov, and Gul Agha. CUTE: a
concolic unit testing engine for c. In ACM SIGSOFT
Software Engineering Notes, volume 30, pages 263–272.
ACM, 2005.
[36] Konstantin Serebryany, Derek Bruening, Alexander
Potapenko, and Dmitriy Vyukov. AddressSanitizer: A
fast address sanity checker. In Presented as part of the
2012 USENIX Annual Technical Conference (USENIX
ATC 12), pages 309–318, 2012.
[37] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls,
Nick Stephens, Mario Polino, Andrew Dutcher, John
Grosen, Siji Feng, Christophe Hauser, Christopher
Kruegel, et al. SoK: (State of) The art of war: Offensive
techniques in binary analysis. In 2016 IEEE Symposium
on Security and Privacy, pages 138–157. IEEE, 2016.
[38] Evgeniy Stepanov and Konstantin Serebryany. Memo-
rySanitizer: fast detector of uninitialized memory use
in C++. In Proceedings of the 13th Annual IEEE/ACM
International Symposium on Code Generation and Opti-
mization, pages 46–55. IEEE Computer Society, 2015.
[39] Nick Stephens, John Grosen, Christopher Salls, Andrew
Dutcher, Ruoyu Wang, Jacopo Corbetta, Yan Shoshi-
taishvili, Christopher Kruegel, and Giovanni Vigna.
Driller: Augmenting fuzzing through selective symbolic
execution. In NDSS, volume 16, pages 1–16, 2016.
[40] The Clang Team. Clang C language family frontend for
LLVM. https://clang.llvm.org/, 2019.
[41] The Rust Programming Language Team. Guide to
rustc development. https://rust-lang.github.io/
rustc-guide/, 2019.
[42] Emina Torlak and Rastislav Bodik. A lightweight sym-
bolic virtual machine for solver-aided host languages.
In ACM SIGPLAN Notices, volume 49, pages 530–541.
ACM, 2014.
[43] Trail
of Bits.
Binary
with KLEE-Native.
ecution
//blog.trailofbits.com/2019/08/30/
binary-symbolic-execution-with-klee-native/,
2019.
symbolic
ex-
https:
[44] Clark Wiedmann. A performance comparison between
an apl interpreter and compiler. SIGAPL APL Quote
Quad, 13(3):211–217, March 1983.
[45] Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and
Taesoo Kim. QSYM: A practical concolic execution
In 27th USENIX
engine tailored for hybrid fuzzing.
Security Symposium (USENIX Security 18), pages 745–
761, 2018.
[46] Michał Zalewski.
american fuzzy lop.
lcamtuf.coredump.cx/afl/.
http://
A SYMCC usage example
Figure 4 shows an example interaction with SYMCC: We
ﬁrst compile the program displayed in Listing 3, simulating
a log-in interface. Then we run the program with an initial
test input and demonstrate that concolic execution generates
a new test input that allows us to access the most interesting
portion of the program. While this is a very basic example,
we hope that it gives the reader an idea of how SYMCC can
be used.
USENIX Association
29th USENIX Security Symposium    197
#include 
int main (int argc , char * argv []) {
std :: cout > name ;
if ( name == " root ")
std :: cout / dev / null
What ’s your name ?
Hello , john !
$ cat / tmp / symcc /000008 - optimistic
root
Listing 4: A shell session that demonstrates how a user would
compile and run the program from Listing 3 with SYMCC.
Lines preﬁxed with a dollar sign indicate commands entered
by the user. Note how the analysis proposes “root” as a new
test input.
In larger software projects, it is typically sufﬁcient to ex-
port CC=symcc and CXX=sym++ before invoking the respective
build system; it will pick up the compiler settings and build
an instrumented target program transparently.
B The curious case of NRFIN_00007
The CGC program NRFIN_00007 contains a bug that changes
the program’s observable behavior depending on the compiler
and compilation ﬂags. We believe that it is unrelated to the
intended vulnerability in the program (i.e., a buffer overﬂow
triggered by certain user inputs). Listing 5 shows an excerpt of
the program’s main function. During initialization (and before
any user input is read), it checks the uninitialized variable ret
and exits prematurely if its value is non-zero. In practical
execution, this causes the program to exit early depending
on the stack layout chosen by the compiler. Since SYMCC,
KLEE and QSYM all use different means to compile the target
program, the bug would introduce errors into our evaluation;
we therefore excluded NRFIN_00007 from the test set.
int main (void) {
int ret ;
size_t size ;
malloc_init ();
if ( ret != 0)
_terminate ( ret );
// ...
}
Listing 5: A bug in the code of NRFIN_00007. The variable
ret is used uninitialized; if its value is non-zero, the program
exits prematurely without ever reading user input.
198    29th USENIX Security Symposium
USENIX Association