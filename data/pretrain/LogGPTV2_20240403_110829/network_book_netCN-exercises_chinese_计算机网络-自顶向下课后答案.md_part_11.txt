|24.34.112.235, 4005 |192.168.1.3, 3546 |
P17、
a)由于所有IP数据包都发送到外部，所以我们可以使用数据包嗅探器记录NAT后面的主机生成的所有IP数据包。由于每个主机都生成一个具有序列号的IP数据包序列，并且有一个不同的(很可能是从一个大空间中随机选择的)初始标识号(ID)，因此我们可以将具有连续ID的IP数据包分组到一个集群中。集群的数量是NAT背后的主机数量。
有关更多实用算法，请参阅以下论文。
“A Technique for Counting NATted Hosts”, by Steven M. Bellovin, appeared in 
IMW’02, Nov. 6-8, 2002, Marseille, France. 
“Exploiting the IPID field to infer network path and end-system characteristics.” 
Weifeng Chen, Yong Huang, Bruno F. Ribeiro, Kyoungwon Suh, Honggang Zhang, 
Edmundo de Souza e Silva, Jim Kurose, and Don Towsley. 
PAM'05 Workshop, March 31 - April 01, 2005. Boston, MA, USA. 
b)但是，如果这些识别号码不是按顺序分配的，而是随机分配的，则a)部分中所建议的技术将无法工作，因为在嗅探数据中不会出现集群。
P18、想出这样的技术是不可能的。为了在Arnold和Bernard之间建立一个直接的TCP连接，Arnold或Bob必须启动到另一个连接。但是覆盖Arnold和Bob的NAT丢弃了从WAN端到达的SYN数据包。因此，无论是Arnold还是Bob，如果它们都落后于NAT，就无法启动到对方的TCP连接。
P19、
|S2 Flow Table ||
|-|-------------|
|Match |Action |
|Ingress Port = 1; IP Src = 10.3.*.*; IP Dst = 10.1.*.* |Forward (2) |
|Ingress Port = 2; IP Src = 10.1.*.*; IP Dst = 10.3.*.* |Forward (1) |
|Ingress Port = 1; IP Dst = 10.2.0.3 |Forward (3) |
|Ingress Port = 2; IP Dst = 10.2.0.3 |Forward (3) |
|Ingress Port = 1; IP Dst = 10.2.0.4 |Forward (4) |
|Ingress Port = 2; IP Dst = 10.2.0.4 |Forward (4) |
|Ingress Port = 4 |Forward (3) |
|Ingress Port = 3 |Forward (4)|
P20、
|S2 Flow Table ||
|-|-------------|
|Match |Action |
|Ingress Port = 3; IP Dst = 10.1.*.* |Forward (2) |
|Ingress Port = 3; IP Dst = 10.3.*.* |Forward (2) |
|Ingress Port = 4; IP Dst = 10.1.*.* |Forward (1) |
|Ingress Port = 4; IP Dst = 10.3.*.* |Forward (1) |
P21、
|S1 Flow Table ||
|-|-------------|
|Match |Action |
|IP Src = 10.2.*.*; IP Dst = 10.1.0.1 |Forward (2) |
|IP Src = 10.2.*.*; IP Dst = 10.1.0.2 |Forward (3) |
|IP Src = 10.2.*.*; IP Dst = 10.3.*.* |Forward (1) |
|S3 Flow Table ||
|-|-------------|
|Match |Action |
|IP Src = 10.2.*.*; IP Dst = 10.3.0.6 |Forward (1) 
|IP Src = 10.2.*.*; IP Dst = 10.3.0.5 |Forward (2) 
|IP Src = 10.2.*.*; IP Dst = 10.1.*.* |Forward (3) |
P22、
| S2 Flow Table||
|-|-------------| 
|Match | Action |
|IP Src = 10.1.0.1; IP Dst = 10.2.0.3 |Forward (3) |
|IP Src = 10.1.0.1; IP Dst = 10.2.0.4 | Forward (4) |
|IP Src = 10.3.0.6; IP Dst = 10.2.0.3 |Forward (3) |
|IP Src = 10.3.0.6; IP Dst = 10.2.0.4 |Forward (4) |
|S2 Flow Table ||
|--|--|
|Match |Action| 
|IP Src =.*.*.*.*; IP Dst = 10.2.0.3; port = TCP |Forward (3) |
|IP Src =.*.*.*.*; IP Dst = 10.2.0.4; port = TCP |Forward (4) |
|S2 Flow Table| |
|--|--|
|Match |Action |
|IP Src =.*.*.*.*; IP Dst = 10.2.0.3 |Forward (3) |
|S2 Flow Table| |
|--|--|
|Match |Action |
|IP Src = 10.1.0.1; IP Dst = 10.2.0.3; port = UDP |Forward (3) |
[Back to Index](#目录)
# 第五章
## 复习题5
R1、每个路由器控制意味着一个路由算法在每个路由器中运行；转发和路由功能在每个路由器内都受到约束。每个路由器都有一个路由组件，它与其他路由器中的路由组件通信，以计算其转发表的值。在这种情况下，我们说网络控制和数据平面是以单一方式实现的，因为每个路由器作为一个独立的实体来实现自己的控制和数据平面。
R2、逻辑集中控制是指逻辑中央路由控制器计算和分配每个路由器使用的转发表，而每个路由器不计算其转发表，这与每个路由器控件不同。在逻辑集中控制的情况下，数据平面和控制平面在单独的设备中实现；控制平面在中央服务器或多个服务器上实现，数据平面在每个路由器中实现。
R3、集中式路由算法通过使用关于网络的完整的全局知识来计算源和目的地之间的最小成本路径。该算法需要对所有节点之间的连通性和所有链路的代价有完整的了解。实际计算可以在一个站点上运行，也可以在每个路由器的路由组件中复制。一种分布式路由算法通过路由器以迭代的、分布式的方式计算租赁成本路径.使用分散算法，任何节点都没有关于所有网络链路成本的完整信息。每个节点开始时只知道自己直接连接链路的成本，然后通过与其相邻节点进行计算和信息交换的迭代过程，节点逐渐计算出到达目的地或一组目的地的最小成本路径。
OSPF协议是集中式路由算法的一个例子，BGP协议是分布式路由算法的一个例子。
R4、链路状态算法：使用完整的、全局的网络知识来计算源和目的地之间的最小成本路径。距离向量路由：最小成本路径的计算是以迭代的、分布式的方式进行的。节点只知道它应该向其转发数据包的邻居，以便沿着成本最低的路径到达给定的目的地，以及该路径从自身到目的地的成本。
R5、计数-无穷大问题是指距离矢量路由的问题。所需的问题意味着需要很长的时间用于距离矢量路由算法,当链路成本增加时收敛。例如，考虑三个网络节点X、Y和Z。最初假定链路代价是C(x，y)＝4，c(x，z)＝50，并且C(y，z)＝1。距离矢量路由算法的结果是Z的X的路径是Z→Y→X，成本为5(＝4+1)。当链路(x,y)的成本从4增加到60时,它将花费44次迭代来运行节点Z的距离矢量路由算法,实现其对X的新的最小成本路径通过其直接链路到X，因此Y也将通过Z实现对X的最低成本路径。
R6、没有。每个AS都具有在AS中路由的管理自主权。
R7、政策：在屁股中，政策问题占主导地位。重要的是，源自给定的流量不能通过另一个特定的AS。类似地，一个给定的可能想要控制它在其他驴之间的过境流量。在AS内部，所有事物名义上都处于相同的管理控制之下，因此政策在选择路线方面所起的作用要小得多。
规模：路由算法及其数据结构处理大量网络路由的能力是跨网络路由中的一个关键问题。在AS中，可伸缩性不太受关注。首先，如果单个管理域变得太大，则始终可以将其划分为两个ASS，并在两个新ASS之间执行互选路由。
性能：由于路由非常面向策略，所以使用的路由的质量(例如性能)往往是次要关注的(也就是说，满足某些策略标准的较长或更昂贵的路由很可能被选择在较短但不符合该标准的路由上)。事实上，我们看到，在驴中，甚至没有与路线相关的成本(除了作为跳数)的概念。然而，在一个单一的地方，这种策略关注点就不那么重要了，这使得路由能够更多地关注在路由上实现的性能水平。
R8、假的。
使用ospf，路由器将其链路状态信息广播到它所属的自治系统中的所有其他路由器，而不仅仅是它的邻近路由器。这是因为使用OSPF，每个路由器都需要构造一个完整的AS拓扑图，然后本地运行Dijkstra的最短路径算法来确定它对所有其他节点的最小代价路径。
R9、OSPF自治系统中的一个区域是指一组路由器，其中每个路由器向同一组中的所有其他路由器广播其链路状态。OSPF可以分层配置成多个区域，每个区域运行自己的OSPF链路状态路由算法。在每个区域内，一个或多个区域边界路由器负责在区域外路由数据包。基于扩展性的考虑，引入了Area的概念，即我们希望为大规模OSPF建立分层路由，而区域是分层路由的重要组成部分。
R10、子网是较大网络的一部分；子网不包含路由器；其边界由路由器和主机接口定义。前缀是CDIR地址的网络部分；它以A.B.C.D/x形式写成；前缀包括一个或多个子网。当路由器在BGP会话中通告前缀时，它在前缀中包含许多BGP属性。在BGP术语中，前缀及其属性是BGP路由(或简单地说是路由)。
R11、路由器使用AS-Path属性来检测和防止循环广告；它们还使用它在多个路径中选择相同的前缀。下一跳属性表示沿通告路径的第一个路由器的IP地址(在接收到广告的外部)到给定的前缀。配置时配置它的转发表，路由器使用下一跳属性。
R12、第1级ISP B可能不会携带其他两个一级ISP之间的过境流量，例如A和C，B与它们有对等协议。为了执行这一政策，ISP B不会向通过C的A路做广告，也不会向经过A的C路做广告。
R13、假的。
BGP路由器可以选择不将自己的标识添加到接收到的路径中，然后将新路径发送到其所有邻居，因为bgp是一种基于策略的路由协议。在下面的场景中可能会发生这种情况。接收路径的目的地是其他路径，而不是BGP路由器的AS，而BGP路由器不想充当传输路由器。
R14、通信层通过OpenFlow等协议负责SDN控制器与受控网络设备之间的通信。通过这一层，SDN控制器控制远程SDN启用交换机、主机或其他设备的操作，并且设备将本地观察到的事件(例如，指示链路故障的消息)与控制器通信。
网络范围的状态管理层提供关于网络主机、链路、交换机和其他SDN控制设备的最新信息.控制器还维护各种受控设备的流表的副本。
网络控制应用层代表SDN控制平面的大脑.该层的应用程序使用SDN控制器提供的API来指定和控制网络设备中的数据平面。例如，路由网络控制应用程序可能确定源和目的地之间的端点路径.另一个网络应用程序可能执行访问控制。
R15、我将在SDN的网络控制应用层实现一个新的路由协议，因为这是一个路由协议决定源和目的地之间端到端路径的层。
R16、下面是通过SDN控制器从控制器南行到被控制设备的消息类型的列表。这些消息的接收方是一个受控的数据包交换机。
- 配置。此消息允许控制器查询和设置交换机的配置参数。
- 修改-状态。控制器使用此消息添加/删除或修改交换机流表中的条目，并设置开关端口属性。
- 阅读状态。此消息由控制器用于从交换机的流表和端口收集统计信息和计数器值。
- 发送包。此消息由控制器用于发送特定的数据包在受控开关上的指定端口。
网络控制应用程序(作为发送者)也会通过北向接口向控制器发送消息，例如，在控制器的状态管理层中读取/写入网络状态和流表的消息。
R17、从受控设备到控制器的两种消息类型：
- 流删除消息.它的目的是通知控制器，流表项已被删除，例如，通过超时或接收到的修改状态消息的结果。
- 端口-状态消息.其目的是将港口状态的变化通知控制器。
从控制器到受控设备的两种消息类型：
- 修改-状态。其目的是添加/删除或修改交换机流表中的条目，并设置开关端口属性。
- 读状态。其目的是收集统计数据和计数器值，以查询交换机的流表和端口。
R18、服务抽象层允许内部网络服务应用程序相互通信。它允许控制器组件和应用程序相互调用对方的服务，并订阅它们生成的事件。该层还为通信层中特定的底层通信协议(包括OpenFlow和SNMP)提供了统一的抽象接口。
R19、
Echo回复（至Ping），类型0，代码0
目标网络不可达，类型3，代码0
目标主机不可达，类型3，代码1。
源抑制（拥塞控制），类型4代码0。
R20、ICMP警告消息(类型11代码0)和无法到达的目标端口ICMP消息(类型3代码3)。
R21、管理服务器是一个应用程序，通常有一个人在循环中，运行在网络操作中心的集中网络管理站中。它控制网络管理信息的收集、处理、分析和/或显示。在管理服务器中启动操作以控制网络行为，网络管理员使用管理服务器与网络设备交互。
托管设备是驻留在托管网络上的一段网络设备(包括其软件)。托管设备可能是主机、路由器、交换机、中间盒、调制解调器、温度计或其他网络连接的设备.
网络管理代理是在托管设备中运行的进程，该进程与管理服务器通信，在管理服务器的命令和控制下在托管设备上采取本地操作。
管理信息库(MIB)收集与托管网络中的那些托管对象相关联的信息。MIB对象可以是计数器，例如由于IP数据报报头中的错误而丢弃在路由器上的IP数据报的数量，或者在主机上接收到的UDP段的数量，或者诸如特定设备是否正常工作的状态信息。
R22、GetRequest是从管理服务器发送给代理的消息，用于在代理的托管设备上请求一个或多个MIB对象的值。SetRequest是管理服务器用于在托管设备中设置一个或多个MIB对象的值的消息。
R23、SNMP陷阱消息是作为对设备的管理服务器需要通知的托管设备上发生的事件的响应而生成的。它用于将导致MIB对象值更改的异常情况(例如，向上或向下的链接接口)通知管理服务器。
[Back to Index](#目录)
## 问题5
P1、
y-x-u,y-x-v-u,y-x-w-u,y-x-w-v-u,
y-w-u,y-w-v-u,y-w-x-u,y-w-x-v-u,y-w-v-x-u,
y-z-w-u,y-z-w-v-u,y-z-w-x-u,y-z-w-x-v-u,y-z-w-v-x-u,
P2、
x to z: