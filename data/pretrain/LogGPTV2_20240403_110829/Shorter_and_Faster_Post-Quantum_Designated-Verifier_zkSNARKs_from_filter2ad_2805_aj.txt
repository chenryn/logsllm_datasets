runs in time polynomial in the size of the instance CSğœ…. In contrast, a â€œfully-succinctâ€
SNARK also requires that the setup run in time sublinear (or polylogarithmic) in the
size of CSğœ…. Using recursive composition [29], it is possible to obtain fully succinct
SNARKs from preprocessing SNARKs.
(A.2)
(1ğœ†, 1ğœ…) is defined as
(1) The challenger samples ğ‘
râ† {0, 1}. If ğ‘ = 0, the challenger
computes (crs, st) â† Setup(1ğœ†, 1ğœ…) and gives (crs, st) to A. If
ğ‘ = 1, the challenger computes ((cid:102)crs,(cid:101)st, stS) â† S1(1ğœ†, 1ğœ…) and
gives ((cid:102)crs,(cid:101)st) to A.
(2) The adversary A outputs a statement x and a witness w.
(3) If CSğœ…(x, w) â‰  1, then the experiment halts with output 0.
Otherwise, the challenger proceeds as follows:
â€¢ If ğ‘ = 0, the challenger replies with ğœ‹ â† Prove(crs, x, w).
â€¢ If ğ‘ = 1, the challenger replies with Ëœğœ‹ â† S2(stS, x).
At the end of the experiment, A outputs a bit ğ‘â€² âˆˆ {0, 1}. The
output of the experiment is 1 if ğ‘â€² = ğ‘ and is 0 otherwise.
When the probability in Eq. (A.2) is bounded by 1/2+ ğœ€, we say that
the scheme satisfies ğœ€-computational zero knowledge.
B LINEAR PCP FOR R1CS
In this section, we describe the linear PCP we use for R1CS. The
construction is based on the quadratic arithmetic programs of Gen-
naro et al. [64], and is adapted from the 5-query linear PCP con-
struction by Ben-Sasson et al. [20]. There are two minor differences
in our construction:
â€¢ We remove the statement-dependent query and have the verifier
introduce the statement-dependent components during verifica-
tion. This yields a 4-query linear PCP with shorter query length
at the expense of a slightly more expensive verification step. A
similar approach is used implicitly in [24, 64].
â€¢ The LPCP query-generation samples the random point from a
smaller subset of the field. This introduces some knowledge error,
but enables perfect HVZK. The construction of Ben-Sasson et al.
provided statistical HVZK where the statistical distance was in-
versely proportional to the field size. The difference between sta-
tistical HVZK and perfect HVZK is negligible for super-polynomial
size fields, but not for the moderate-size fields we use in this work.
For completeness, we provide the full description and analysis
below. Our presentation and analysis is adapted from [20, Appen-
dix E].
Construction B.1 (Linear PCP for R1CS [20, 64, adapted]). Let
CS = {CSğœ…}ğœ…âˆˆN be a family of R1CS instances over a finite field F,
Fğ‘ğ‘¤,ğœ…+1 (and entries indexed from 0 to ğ‘ğ‘¤,ğœ…). For notational con-
venience, we write ğ‘› = ğ‘›(ğœ…) to denote a function where ğ‘›(ğœ…) = ğ‘›ğœ…
for all ğœ… âˆˆ N. We define ğ‘ğ‘” = ğ‘ğ‘”(ğœ…), ğ‘ğ‘¤ = ğ‘ğ‘¤(ğœ…), ağ‘– = ağ‘–(ğœ…),
bğ‘– = bğ‘–(ğœ…) and cğ‘– = cğ‘–(ğœ…) similarly. We additionally define the
following components:
â€¢ Let ğ‘† = {ğ›¼1, . . . , ğ›¼ğ‘ğ‘”} âŠ‚ F be an arbitrary subset of F.
â€¢ For each ğ‘– âˆˆ {0, . . . , ğ‘ğ‘¤}, let ğ´ğ‘–, ğµğ‘–, ğ¶ğ‘– : F â†’ F be the unique
polynomial of degree ğ‘ğ‘” âˆ’ 1 where for all ğ‘— âˆˆ [ğ‘ğ‘”],
ğµğ‘–(ğ›¼ ğ‘—) = bğ‘—,ğ‘–, ğ¶ğ‘–(ğ›¼ ğ‘—) = cğ‘—,ğ‘– .
where CSğœ… =(cid:0)ğ‘›ğœ…, ğ‘ğ‘”,ğœ…, ğ‘ğ‘¤,ğœ…, {ağ‘–,ğœ…, bğ‘–,ğœ…, cğ‘–,ğœ…}ğ‘–âˆˆ[ğ‘ğ‘”,ğœ… ](cid:1), ağ‘–,ğœ…, bğ‘–,ğœ…, cğ‘–,ğœ… âˆˆ
â€¢ Let ğ‘ğ‘† : F â†’ F be the polynomial ğ‘ğ‘†(ğ‘§) :=ğ‘— âˆˆ[ğ‘ğ‘”](ğ‘§ âˆ’ ğ›¼ ğ‘—).
ğ´ğ‘–(ğ›¼ ğ‘—) = ağ‘—,ğ‘–,
Namely, ğ‘ğ‘† is the polynomial whose roots are the elements of ğ‘†.
The 4-query linear PCP Î LPCP = (QLPCP, PLPCP,VLPCP) for CS
is defined as follows:
râ† F \ ğ‘†. Define vec-
â€¢ QLPCP(1ğœ…): On input ğœ… âˆˆ N, sample ğœ
tors a = (ğ´1(ğœ), . . . , ğ´ğ‘›(ğœ)), b = (ğµ1(ğœ), . . . , ğµğ‘›(ğœ)), and c =
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea228
Q =
ğ‘ğ‘†(ğœ)
0
0
0
0
ğ‘ğ‘†(ğœ)
0
0
0
0
ğ´ğ‘›+1(ğœ)
ğµğ‘›+1(ğœ)
ğ‘ğ‘†(ğœ) ğ¶ğ‘›+1(ğœ)
0
0
Â· Â· Â· ğ´ğ‘ğ‘¤ (ğœ)
Â· Â· Â·
ğµğ‘ğ‘¤ (ğœ)
Â· Â· Â· ğ¶ğ‘ğ‘¤ (ğœ)
Â· Â· Â·
0
0
0
0
1
0
0
0
ğœ
Â· Â· Â·
Â· Â· Â·
Â· Â· Â·
Â· Â· Â·
0
0
0
ğœ ğ‘ğ‘”
T
âˆˆ F(4+ğ‘ğ‘¤+ğ‘ğ‘”âˆ’ğ‘›)Ã—4.
Figure 3: The query matrix Q output by QLPCP in Construction B.1. Here, ğœ
râ† F \ ğ‘†.
(ğ¶1(ğœ), . . . , ğ¶ğ‘›(ğœ)). Output st = (ğ´0(ğœ), ğµ0(ğœ), ğ¶0(ğœ), a, b, c, ğ‘ğ‘†(ğœ))
and the query matrix Q as defined in Fig. 3.
â€¢ PLPCP(1ğœ…, x, w): On input ğœ… âˆˆ N and an instance (x, w) where
râ† F. Construct polynomials
CSğœ…(x, w) = 1, sample ğ›¿1, ğ›¿2, ğ›¿3
ğ´, ğµ, ğ¶ : F â†’ F, each of degree ğ‘ğ‘”, where
ğ´(ğ‘§) := ğ›¿1ğ‘ğ‘†(ğ‘§) + ğ´0(ğ‘§) +
ğµ(ğ‘§) := ğ›¿2ğ‘ğ‘†(ğ‘§) + ğµ0(ğ‘§) +
ğ¶(ğ‘§) := ğ›¿3ğ‘ğ‘†(ğ‘§) + ğ¶0(ğ‘§) +
ğ‘–âˆˆ[ğ‘ğ‘¤] ğ‘¤ğ‘–ğ´ğ‘–(ğ‘§)
ğ‘–âˆˆ[ğ‘ğ‘¤] ğ‘¤ğ‘– ğµğ‘–(ğ‘§)
ğ‘–âˆˆ[ğ‘ğ‘¤] ğ‘¤ğ‘–ğ¶ğ‘–(ğ‘§).
(B.1)
Let ğ»(ğ‘§) := (ğ´(ğ‘§)ğµ(ğ‘§)âˆ’ğ¶(ğ‘§))/ğ‘ğ‘†(ğ‘§), and let h = (â„0, . . . , â„ğ‘ğ‘”) âˆˆ
Fğ‘ğ‘”+1 be the coefficients of ğ». Parse wT = [xT | ËœwT] Output the
proof vector ğ… = (ğ›¿1, ğ›¿2, ğ›¿3, Ëœw, h) âˆˆ F4+ğ‘ğ‘¤+ğ‘ğ‘”âˆ’ğ‘›.
â€¢ VLPCP(st, x, a): On input st = (ğ‘0, ğ‘0, ğ‘0, a, b, c, ğ‘§), x âˆˆ Fğ‘› and
a âˆˆ F4, the verifier computes ğ‘â€²
1 = ğ‘1+ğ‘0+xTa, ğ‘â€²
2 = ğ‘2+ğ‘0+xTb,
and ğ‘â€²
3 = ğ‘3 + ğ‘0 + xTc. It accepts if
ğ‘â€²
1ğ‘â€²
2 âˆ’ ğ‘â€²
(B.2)
Theorem B.2 (Linear PCP for QAPs). Construction B.1 is complete,
has knowledge error 2ğ‘ğ‘”/(|F| âˆ’ ğ‘ğ‘”), and is perfect HVZK.
3 âˆ’ ğ‘4ğ‘§ = 0.
Proof. Let CS = {CSğœ…}ğœ…âˆˆN be an R1CS system over F. We
consider each property separately:
â€¢ Completeness: Take any ğœ… âˆˆ N and (x, w) where CSğœ…(x, w) =
1. Let (st, Q) â† QLPCP(1ğœ…), ğ… â† PLPCP(1ğœ…, x, w), a â† QTğ….
Consider the value of VLPCP(st, x, a). Let ğ‘â€²
3 be the values
computed by VLPCP. By definition,
ğ‘â€²
1 = ğ‘1 + ğ‘0 + xTa
1, ğ‘â€²
2, ğ‘â€²
= ğ›¿1ğ‘ğ‘†(ğœ) + ğ´0(ğœ) + 
= ğ›¿1ğ‘ğ‘†(ğœ) + ğ´0(ğœ) + 
ğ‘–âˆˆ[ğ‘›]
ğ‘¥ğ‘–ğ´ğ‘–(ğœ) + 
ğ‘–âˆˆ[ğ‘ğ‘¤âˆ’ğ‘›]
ğ‘¤ğ‘–ğ´ğ‘–(ğœ)
ğ‘–âˆˆ[ğ‘ğ‘¤]
ğ‘¤ğ‘›+ğ‘–ğ´ğ‘›+ğ‘–(ğœ)
= ğ´(ğœ).
3 = ğ¶(ğœ). Finally ğ‘4 = â„0 +ğ‘–âˆˆ[ğ‘ğ‘”] â„ğ‘–ğœğ‘– = ğ»(ğœ),
since ğ‘¤ğ‘– = ğ‘¥ğ‘– for ğ‘– âˆˆ [ğ‘›], ğ´ is the polynomial in Eq. (B.1), and
ğœ âˆˆ F\ğ‘† is the element sampled by QLPCP. Similarly, we have that
ğ‘â€²
2 = ğµ(ğœ) and ğ‘â€²
where ğ»(ğ‘§) = (ğ´(ğ‘§)ğµ(ğ‘§) âˆ’ ğ¶(ğ‘§))/ğ‘ğ‘†(ğ‘§) is the polynomial con-
structed by the prover. The verification procedure now computes
1ğ‘â€²
ğ‘â€²
2 âˆ’ ğ‘â€²
3 âˆ’ ğ‘4ğ‘§ = ğ´(ğœ)ğµ(ğœ) âˆ’ ğ¶(ğœ) âˆ’ ğ»(ğœ)ğ‘ğ‘†(ğœ) = 0,
by definition of the polynomial ğ». Completeness follows.
â€¢ Knowledge: Define EâŸ¨ğ…âˆ—,Â·âŸ©
to be the algorithm that on input
a statement x and given linear access to a proof vector ğ…âˆ— =
3, Ëœwâˆ—, hâˆ—), outputs wT = [xT | ( Ëœwâˆ—)T] âˆˆ Fğ‘ğ‘¤ . To show
1, ğ›¿âˆ—
(ğ›¿âˆ—
2, ğ›¿âˆ—
LPCP
2, ğ›¿âˆ—
1, ğ›¿âˆ—
3, Ëœwâˆ—, hâˆ—) where
.
that this extractor works, take any ğ…âˆ— = (ğ›¿âˆ—
2ğ‘ğ‘”
Pr[VLPCP(st, x, QTğ…âˆ—) = 1 : (st, Q) â† QLPCP(1ğœ…)] >
|F| âˆ’ ğ‘ğ‘”
We use ğ…âˆ— and CS to define polynomials ğ´, ğµ, ğ¶, ğ» : F â†’ F:
ğ´(ğ‘§) = ğ›¿âˆ—
Ëœğ‘¤âˆ—
ğ‘– ğ´ğ‘›+ğ‘–(ğ‘§)
Ëœğ‘¤âˆ—
ğ‘– ğµğ‘›+ğ‘–(ğ‘§)
Ëœğ‘¤âˆ—
ğ‘– ğ¶ğ‘›+ğ‘–(ğ‘§)
ğ‘¥ğ‘–ğ´ğ‘–(ğ‘§) + 
ğ‘¥ğ‘– ğµğ‘–(ğ‘§) + 
ğ‘¥ğ‘–ğ¶ğ‘–(ğ‘§) + 
1ğ‘ğ‘†(ğ‘§) + ğ´0(ğ‘§) + 
2ğ‘ğ‘†(ğ‘§) + ğµ0(ğ‘§) + 
3ğ‘ğ‘†(ğ‘§) + ğ¶0(ğ‘§) + 
0 + 
ğ»(ğ‘§) = â„âˆ—
ğ¶(ğ‘§) = ğ›¿âˆ—
ğµ(ğ‘§) = ğ›¿âˆ—
ğ‘–âˆˆ[ğ‘ğ‘¤âˆ’ğ‘›]
ğ‘–âˆˆ[ğ‘ğ‘¤âˆ’ğ‘›]
ğ‘–âˆˆ[ğ‘ğ‘¤âˆ’ğ‘›]
â„âˆ—
ğ‘– ğ‘§ğ‘–
ğ‘–âˆˆ[ğ‘›]
ğ‘–âˆˆ[ğ‘›]
ğ‘–âˆˆ[ğ‘›]
ğ‘–âˆˆ[ğ‘ğ‘”]
2 = ğµ(ğœ), ğ‘â€²
Let Q be the query matrix output by QLPCP, a â† QTğ…âˆ— and
ğ‘â€²
2, ğ‘â€²
1, ğ‘â€²
3 be the components computed by VLPCP. By construc-
tion, ğ‘â€²
1 = ğ´(ğœ), ğ‘â€²
3 = ğ¶(ğœ) and ğ‘4 = ğ»(ğœ). Define
the polynomial ğ‘ƒ : F â†’ F where ğ‘ƒ(ğ‘§) = ğ´(ğ‘§)ğµ(ğ‘§) âˆ’ ğ¶(ğ‘§) âˆ’
ğ»(ğ‘§)ğ‘ğ‘†(ğ‘§). By construction, deg(ğ‘ƒ) â‰¤ 2ğ‘ğ‘”. Next, VLPCP accepts
1ğ‘â€²
if ğ‘â€²
2 âˆ’ ğ‘â€²
3 âˆ’ ğ‘4ğ‘§ = 0, where ğ‘§ = ğ‘(ğœ), or equivalently, if
0 = ğ´(ğœ)ğµ(ğœ) âˆ’ ğ¶(ğœ) âˆ’ ğ»(ğœ)ğ‘ğ‘†(ğœ) = ğ‘ƒ(ğœ).
(B.3)
Suppose Eq. (B.3) holds with probability ğœ€ > 2ğ‘ğ‘”/(|F| âˆ’ ğ‘ğ‘”);
that is, the verifier accepts with probability greater than ğœ€. Since
QLPCP samples ğœ uniformly from F \ ğ‘† and deg(ğ‘ƒ) â‰¤ 2ğ‘ğ‘”, we
conclude by the Schwartz-Zippel lemma (Lemma A.1) that ğ‘ƒ â‰¡ 0.
In particular, this means that for all ğ‘— âˆˆ [ğ‘ğ‘”],
ğ‘ƒ(ğ›¼ ğ‘—) = ğ´(ğ›¼ ğ‘—)ğµ(ğ›¼ ğ‘—) âˆ’ ğ¶(ğ›¼ ğ‘—) = 0,
since ğ‘ğ‘†(ğ›¼ ğ‘—) = 0 for all ğ‘— âˆˆ [ğ‘ğ‘”]. Equivalently, this means that
ğ´(ğ›¼ ğ‘—)ğµ(ğ›¼ ğ‘—) = ğ¶(ğ›¼ ğ‘—) for all ğ‘— âˆˆ [ğ‘ğ‘”]. By construction of ğ´, ğµ, ğ¶,
this means that
[1 | ËœuT]ağ‘— Â· [1 | ËœuT]bğ‘— = [1 | ËœuT]cğ‘— ,
((cid:101)st, ËœQ) â† QLPCP(1ğœ…). It outputs(cid:101)st, ËœQ, and stS =(cid:101)st.
where ËœuT = [xT | ( Ëœwâˆ—)T]. Since this holds for all ğ‘— âˆˆ [ğ‘ğ‘”], we
have that CSğœ…(x, Ëœwâˆ—) = 1, as required.
â€¢ HVZK: We first construct a simulatorSLPCP = (SLPCP,1,SLPCP,2):
â€“ SLPCP,1(1ğœ…): The statement-independent algorithm samples
â€“ SLPCP,2(stS, x): On input the state stS = ( Ëœğ‘0, Ëœğ‘0, Ëœğ‘0, Ëœa, Ëœb, Ëœc, Ëœğ‘§)
and the statement x, the statement-dependent algorithm sam-