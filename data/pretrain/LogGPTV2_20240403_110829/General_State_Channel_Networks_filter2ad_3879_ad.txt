channel network. In the following description, if it is not important
whether γ is ledger state channel or a virtual state channel, and
hence we will refer to γ as a state channel.
(1) Consensus on creation: A state channel γ can be success-
fully created only if all users of γ agree with its creation.
(2) Consensus on updates: A contract instance in a state chan-
nel γ can be successfully updated (this includes also creation
of the contract instance) only if both end-users of γ agree
with the update.
(3) Guarantee of execution: An honest end-user of a ledger
state channel γ can execute a contract function f of a created
contract instance in any round τ0 on input value z even
if the other end-user of γ is corrupt. This property holds
also for virtual state channels with the restriction that τ0  0 was requested by the other party, and
TimeExe(i) that represents the maximal number of rounds it takes
to execute of a contract instance in a state channel of length i > 0.
Both of these functions are of the order O (∆ · i) (see the full version
of this paper [13] for formal definition of these function and their
relationship).
Each entity stores and maintains a set of all state channels it is
aware of. Following [12] this set will be called channel space and
denoted Γ. Sometimes we will abuse notation and interpret the
channel space as a function which on input id ∈ {0, 1}∗ returns
a state channel with identifier id if such state channel exist and
otherwise ⊥. Every time a new contract instance in some of the
state channels stored in Γ is successfully created (or an existing one
is executed), the channels space Γ must be updated accordingly. To
this end we define an auxiliary procedure UpdateChanSpace. The
procedure takes as input a channel space Γ, a channel identifier
id, a contract instance identifier cid, a new contract instance ν and
two values addA and addB representing the required change in the
cash values of the state channel with identifier id. The procedure
sets Γ(id).cspace(cid) := ν, adds addA coins to Γ(id).cash(A) and
adds addB coins to Γ(id).cash(B). Finally, it outputs the updated
channel space Γ. Formal definition can be found in the full version
of this paper [13].
ch
ch
4.2 The ideal functionality
We denote the state channel ideal functionality by F (cid:98)L(∆)
(i, C), where
i ∈ N is the maximal length of a state channel that can be opened
via the functionality, and C denotes the set of contract codes whose
ity F (cid:98)L(∆)
instances can be created in the state channels. The ideal functional-
access to the global ideal functionality (cid:98)L (the ledger). F (cid:98)L(∆)
(i, C) communicates with parties from the set P, and has
(i, C)
maintains a channel space Γ containing all the open state channels.
The set Γ is initially empty.
Since inputs of parties and the messages they send to the ideal
functionality do not contain any private information, we implicitly
assume that the ideal functionality forwards all messages it receives
to the simulator Sim. More precisely, upon receiving the message
m from party P the ideal functionality sends the message (P, m)
to the simulator. The task of the simulator is to instruct the ideal
functionality to make changes on the ledger and to output messages
to the parties in the correct round (both depends on the choice made
ch
Session 5C: Blockchain 2CCS’18, October 15-19, 2018, Toronto, ON, Canada957by the adversary Adv in the real world). In the description of the
ideal functionality, we do not explicitly mention these instructions
of Sim, but instead use the following abbreviation. By saying “wait
for at most ∆ rounds to remove/add x coins from P’s account on
the ledger” we mean that the ideal functionality waits until it is
instructed by the simulator, which will happen within at most ∆
rounds, and then request changes of P’s account on the ledger. Let
us emphasize this abbreviated notation does not affect the reactive
nature of the ideal functionality (meaning that every action of the
functionality has to be triggered by some other entity).
We present the formal definition of the F (cid:98)L(∆)
(i, C) functionality
in Fig. 4. Here we provide some intuitions behind this definition,
introduce the most important restrictions on the environment (see
Sec. 3.3), and argue why the ideal functionality satisfies all the
security and efficiency properties stated in Sec. 3.2. Let us note that
(i, C)
follow from the technical details of our protocols which can be
found, together with the formal proof of the security and efficiency
properties, in the full version of this paper [13].
the constants appearing in the formal description of F (cid:98)L(∆)
ch
ch
ch
State channel creation. The F (cid:98)L(∆)
(i, C) functionality consists of
two “state channel creation” procedures: one for ledger and one for
virtual state channels. The ledger state channel creation procedure