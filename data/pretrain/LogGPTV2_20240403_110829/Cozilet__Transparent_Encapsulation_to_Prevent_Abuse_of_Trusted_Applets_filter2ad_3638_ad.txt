field delegation is unnecessary because most applets do not 
need it. 
4.5.2. Exclusive mode. Cozilets can run in exclusive mode
to  prevent  any  untrusted  applets  from  starting  during  the 
execution of an encapsulated applet. Although this may not 
prevent  the  execution  of  untrusted  applets  running  before 
cozilets start, it can usually make cozilets secure. 
The  exclusive  mode  takes  advantage  of  the  class 
loading  and  defining  restriction  mechanisms  in  the  Sun 
Java VM implementations [4]. The class loading restriction 
mechanism  prevents  untrusted  classes  from  loading  any 
class contained by the particular packages specified in the 
security  property  "package.access"  (whose  default 
value is "sun."). This mechanism makes use of the stack 
inspection  at  class  loading.  The  class  defining  restriction 
mechanism  prevents  untrusted  classes  from  defining  any 
class contained by the particular packages specified in the 
security  property  "package.definition" 
(whose 
default value is ""). This mechanism also makes use of the 
stack inspection at class definition. 
Cozilets  set  the  value  "java.,javax.,sun.,com., 
org.,netscape.,sunw."  to  both  of  the  above  security 
properties  right  after  they  start.  This  is  very  simple,  but 
effectively prevents attacking applets from starting because 
they  cannot 
load  applet  fundamental  classes,  even 
java.applet.Applet.  Of  course,  attacking  applets 
cannot  set  the  security  properties  because  the  stack 
inspection mechanism restricts that operation. 
The exclusive  mode  may  not  prevent the execution of 
attacking applets running before cozilets start, because the 
classes required by the attacking applets may have already 
been  loaded.  Also,  the  exclusive  mode  may  prevent 
browser  script  code  from  accessing  encapsulated  applets, 
because JRE usually regards script code as untrusted code. 
With these exceptions, however, we recommend use of the 
exclusive mode. 
However,  access  from  the  browser  script  code  to 
4.5.3.  Encapsulation  of  local  applet  components.  An 
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
8
applet  usually  consists  of  remote  JAR  files  which  are 
deployed on a Web site and specified in an archive attribute, 
but some applets require users to install local components 
on users’ local disk in advance to reduce network traffic or 
for  use  as  common  system  components.  The  cozilet 
supports encapsulation of such local components to some 
degree. 
Local  components  of  applets  are  local  JAR  files  and 
native libraries. They are usually unsigned, but installed in 
directories  from  which  the  common  system  class  loader
can  load  (which  we  will  refer  to  as  a  system  path)  and 
regarded  as  system  classes  having  all  permissions  or 
system native libraries. 
The cozi-format file can include their installed paths in 
the cozilet properties. The cozi-loader tries to find them by 
using  the  paths  in  the  cozilet  properties.  Moreover,  the 
cozi-format  file  can  also  include  their  hash  values  as 
constant  fields  of  CoziletData  (Section  3.2.2).  The 
cozi-loader checks the integrity of local applet components 
by using these hash values. This encapsulation is done by 
the cozilet generator. 
Note  that  local  JAR  files  should  be  unsigned.  Signed 
JAR  files  may  be  obtained  and  abused  by  attackers.  As 
mentioned,  the  integrity  of  local  JAR  files  (also  native 
libraries) can be verified in the unique way of the  Cozilet 
mechanism.  Also  note  that  local  JAR  files  and  native 
libraries should be moved to any path other than the system 
paths. If they are installed on the system paths, they may be 
abused  by  attackers.  Moving 
the 
transparency of encapsulation (e.g., if they are re-installed), 
but it is strongly recommended. 
them  may  affect 
5. Discussion
In this section,  we discuss the issue in a  more general 
manner, rather than one based on the detailed mechanisms 
of  the  Java  applet  environment  described  in  the  previous 
sections.  Let  us  rephrase  the  issue  as  follows:  to  prevent 
malicious  recomposition  attacks,  all  components  of  an 
applet  (or  any  mobile  code  program)  must  be  securely 
deployed (e.g., identified and composed) on the client-side, 
and  then  the  components  must  be  isolated  from  other 
components. 
For  secure  deployment  of  applets  in  current  Java  VM 
implementations, an  APPLET tag  in an  HTML document 
plays a critical role, determining which JAR file is loaded 
and executed. The current VMs, however, do not consider 
the  tag’s  trustworthiness.  Our  approach  rectifies  this 
weakness  through  two  mechanisms:  applet-document 
binding  ensures  the  origin  of  the  HTML  document 
containing  the  APPLET  tag,  and  digitally  signed  cozilet 
properties  securely  identify  additional  JAR  files  to  be 
deployed. 
Secure deployment is important not only for an applet, 
for  other  componentized  mobile  code 
but  also 
technologies.  Sun's  Java  Web  Start  [18]  is  a  runtime 
environment  for  network-launchable  Java  applications. 
Although  it  is  not  a  perfect  substitute  for  applets  because 
of  its  very  limited  interaction  with  Web  browsers,  it  is 
more secure than applets by the same reason. In addition, 
malicious  deployment  can  be  prevented  by  digitally 
signing a JNLP file, which corresponds to an APPLET tag 
for  an  applet.  Furthermore,  a  Web  Start  application  is 
regarded  as  "signed"  if  and  only  if  all  the  JAR  files 
specified  in  its  JNLP  file  are  signed  by  a  single  signer. 
These features make malicious recomposition attacks hard. 
Microsoft recommends ActiveX control programmers use 
SiteLock  [1],  a  mechanism  similar  to  applet-document 
binding. Also, the Microsoft .NET Framework provides a 
mechanism  called  LinkDemand  [17],  which  prevents 
trusted  assemblies  from  being  accessed  by  malicious 
assemblies.  It  is  preferable  that  Java  VM  itself  support 
such a secure deployment scheme for applets in the future. 
Until then, however, our approach provides an alternative 
way to protect signed applets without modifying VM. 
is  also 
Isolation 
important.  Our  approach  uses 
class-loader-based 
isolation,  which  can  be  easily 
implemented  on  existing  Java  VMs.  It  isolates  the 
namespace of classes, with the exception of system classes 
shared  among  the  JRE.  Therefore,  in  some  cases,  an 
attacking applet can obtain a reference to an instance of a 
class  unique  to  a  victim  applet  as  a  type  of  its  superclass 
which is a system class, such as java.applet.Applet or 
java.lang.Object, and it may cause a security breach. 
While  the  cozilet  takes  some  simple  measures  to  prevent 
leakage  of  the  object  references  of  classes  unique  to  the 
encapsulated  applet,  it  is  difficult  to  completely  prevent 
such leakage. 
Isolation is a general challenge not only to prevent the 
abuse of trusted applets, but also to ensure the reliability of 
general  Java  programs.  For  example,  a  Java-based 
application server needs to isolate each application running 
on  it  to  prevent  applications  affecting  each  other  or  the 
server.  Therefore,  much  work  has  aimed  at  realizing  not 
only  class-loader-based  isolation  but  also  the  isolation  of 
heap  memory,  native  code  memory,  and  other  JRE 
resources  [7][8][9].  In  particular,  JSR-121  Application 
Isolation  API  [7]  is  now  being  standardized  through  the 
Java  Community  Process.  (Unfortunately,  Sun  seems  to 
have put off adopting it in J2SE 1.5.) To prevent the abuse 
of  trusted  applets  more  reliably,  these  strong  isolation 
mechanisms are preferable. 
6. Related work 
Our approach is transparent to both target signed applet 
and  current  Java  VM  implementations.  We  know  of  no 
other groups taking a similar approach at the moment. 
Isolation, as we explained in Section 5, is an effective 
trusted  applets.  However,  current 
to  protect 
way 
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
9
replace 
for 
approaches 
require  users 
isolation  approach 
approaches  [7][8][9]  are  not  transparent  to  users  because 
installed  Java  VM 
they 
to 
implementations.  Other 
non-Java 
applications  have  been  reported.  Alcatraz  [6]  is  a  logical 
application 
that  forces  untrusted 
applications’ insecure execution in Linux to be committed 
by  users.  SoftwarePot  [5]  is  an  application  encapsulation 
approach that prevents malicious behavior by encapsulated 
untrusted applications based on security policies specified 
by users in Solaris and Linux. However, these approaches 
do not aim at preventing the abuse of trusted programs. 
There  are  some  guidelines  available  which  describe 
problems  and  rule-of-thumb  countermeasures.  Securing 
Java  [2]  suggests  programmers  to  care  for 
twelve 
anti-patterns 
in  developing  secure  applets.  Sun  has 
published  the  Security  Code  Guidelines  [4]  and  Inside 
Java2  Platform  Security  [3]  which  describe  various 
security guidelines for Java. Auditing tools based on these 
guidelines have been released or announced [10][11][12]. 
However, it is difficult for  most developers to understand 
and prevent all attacks because these attacks are skillfully 
designed by attackers. 
7. Summary 
We  have  developed  the  Cozilet  mechanism  to  prevent 
malicious  recomposition  attacks.  Such  attacks  are  a 
serious threat to trusted applets, such as signed applets. In 
our  mechanism,  before  deployment,  the  cozilet  generator
encapsulates  a  target  signed  applet  into  a  special  signed 
applet,  a  cozilet,  in  the  indecomposable  cozi-format.  The 
cozilet 
mechanisms: 
class-loader-based isolation and applet-document binding.
Upon  its  execution,  the  cozilet  isolates  the  classes  and 
resources of the encapsulated applet by assigning a special 
class  loader,  the  cozi-loader,  unique  to  the  applet.  It  also 
checks  if  the  HTML  document  was  downloaded  from  a 
trusted Web site, to ensure that no attackers have deployed 
it on their sites. 
protection 
two 
has 
The cozilet can be executed instead of the target applet. 
When it is invoked by JRE, it applies the above protection 
mechanisms to the encapsulated applet, and switches itself 
with  the  applet.  After  switching,  the  encapsulated  applet 
can run normally. The  mechanism can easily protect both 
applets  developed  in  the  future  and  applets  currently  in 
use, because it is transparent not only to the target applets, 
but  also  to  current  Java  VM  implementations.  We  will 
apply  this  mechanism  to  significant  applets  now  being 
used 
in  critical  systems,  such  as  e-commerce  or 
e-government systems. 
8. References 
[1]
“SiteLock Template 1.04 for ActiveX Controls”, 
http://msdn.microsoft.com/archive/en-us/samples/internet/
components/sitelock/default.asp, Microsoft Developer 
Network. 
[2] G. McGraw and E. W. Felten, “Securing Java: Getting 
Down to Business with Mobile Code”, Wiley, 1999. 
[3]
[4]
L. Gong, G. Ellison, and M. Dageforde, “Inside Java 2 
Platform Security: Architecture, API Design, and 
Implementation, 2/E”, Addison-Wesley, 2003. 
“Security Code Guidelines”, 
http://java.sun.com/security/seccodeguide.html, Sun 
Microsystems, Inc., 2000. 
[5] K. Kato and Y. Oyama, “SoftwarePot: An Encapsulated 
Transferable File System for Secure Software Circulation”, 
Software Security - Theories and Systems, Volume 2609 of 
Lecture Notes in Computer Science, Springer-Verlag, 
February 2003. 
Z. Liang, V.N. Venkatakrishnan and R. Sekar, “Isolated 
Program Execution: An Application Transparent Approach 
for Executing Untrusted Programs”, ACSAC'03, Las Vegas, 
December 2003. 
“JSR 121: Application Isolation API Specification”, 
http://jcp.org/en/jsr/detail?id=121, Java Community 
Process. 
“The Barcelona Project”, 
http://research.sun.com/projects/barcelona/, Sun 
Microsystems, Inc. 
“The Janos Project”, http://www.cs.utah.edu/flux/janos/, 
The Flux Research Group. 
J. Viega, et al, “Statically Scanning Java Code: Finding 
Security Vulnerabilities,” IEEE Software 17(5), 2000. 
[6]
[7]
[8]
[9]
[10]
[11] M. Curphey, “codespy”, 
http://www.securityfocus.com/archive/107/349071/2004-0
1-02/2004-01-08/0, January 7th 2004. 
[12] “SIMPLIA/JF Kiyacker”, 
http://www.securityfocus.com/archive/98/341866/2003-10
-17/2003-10-23/0, Fujitsu Limited, October 20th 2003. 
[13] “Java Archive (JAR) Features”, 
http://java.sun.com/j2se/1.4.2/docs/guide/jar/, Sun 
Microsystems, Inc. 
[14] L. Gong, M. Mueller, H. Prafullchandra, and R. Schemers., 
“Going beyond the sandbox: An overview of the new 
security architecture in the java development kit 1.2”, In 
Proceedings of the USENIX Symposium on Internet 
Technologies and Systems, 1997. 
[15] “J2SE 1.4.2 API Documentation”, 
http://java.sun.com/j2se/1.4.2/docs/api/, Sun Microsystems, 
Inc. 
[16]
  “jarsigner - JAR Signing and Verification Tool”, 
http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/jarsi
gner.html, Sun Microsystems, Inc. 
[17] “.NET Framework Developer’s Guide - Link Demands”, 
http://msdn.microsoft.com/library/en-us/cpguide/html/cpc
onlinkdemands.asp, Microsoft Developer Network. 
[18] “Java Network Launching Protocol & API Specification 
(JSR-56) Version 1.0.1”, 
http://java.sun.com/products/javawebstart/, Sun 
Microsystems, Inc. 
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
10