The RAML presented in Section 3 is designed to make it
easy to derive complex SM algebras. In order to do this we
need a slightly weaker property, called monotonicity (M):
(M) For all σ ∈ Σ, and for all λ ∈ L, σ ¹ λ ⊕ σ.
Note that SM implies M.
Protocols such as IS-IS and OSPF are not based on vec-
toring but use link-state approaches that rely on several dis-
tinct components. First, a link-state ﬂooding mechanism is
used to distribute each router’s local information to all other
routers in the link-state routing domain. Second, an algo-
rithm is used locally on each router that computes best paths
in the network, as modelled by a weighted graph, and uses
these paths to determine next-hops for each route. Typi-
cally, some version of Dijksta’s algorithm [4] is employed.
Third, forwarding paths are constructed by the concate-
nation of the next hops determined independently at each
node.
It is possible to generalize link state ﬂooding and Dijk-
stra’s algorithm to an arbitrary algebraic context [19, 24].
However, requirements for correctness are more restrictive.
We require the associativity of ⊕ (which in turn requires
that L = Σ), and that the algebra be isotonic (I):
(I) For all σ1, σ2, σ3 ∈ Σ, if σ1 ¹ σ2, then σ3⊕σ1 ¹ σ3⊕σ2
and σ1 ⊕ σ3 ¹ σ2 ⊕ σ3.
In addition, SM for such algebras must include the SM de-
ﬁned above (left-SM) as well as a right-SM rule. When
constructing new algebras it turns out that these additional
constraints are very diﬃcult to preserve.
It is important to note that we can still call a mecha-
nism “link-state” even when the local algorithm bears no
relation to Dijkstra’s algorithm.
In particular, if an alge-
bra is only SM, then one could use a link-state approach
with a local algorithm that essentially simulates vectoring
on a local model of the network. This is not as strange as
it might seem at ﬁrst glance. In the case that the routing
domain is not too large, it may actually be a reasonable,
especially if fast convergence and complex policy control are
both required. We will call this approach Local Path-Vector
Simulation (LPVS). Table 1 indicates when an algebra is
correctly associated with a given algorithm.
SM I
link-state with Generalized Dijkstra √ √
vectoring √
link-state with LPVS √
assoc. ⊕
√
Table 1: Correctness for various algebra/algorithm
combinations.
2.3 Base Algebras
Table 2 presents a collection of simple routing algebras,
together with their monotonicity property. Each algebra is
now explained in turn.
Algebra
add(n, m)
mult(n, m)
multr(n, m)
max(n)
min(n)
lp(n)
op(n)
seq(n, m)
simseq(n, m)
tags(t)
Description
Properties
int addition
SM (if 1 ≤ n ≤ m)
int product
M (if 1 ≤ n ≤ m)
real product
−
maximum
M
−
minimum
local preference
−
origin preference M
SM
sequences
SM
simple sequences
route tags
M
Table 2: Basic Routing Algebras.
For integers n and m, the routing algebra add(n, m)
represents addition in the range n to m. It has integer sets
L = O = {n, . . . , m} and Σ = {n, . . . , m} ∪ {φ}, where
¹ is taken to be the standard order ≤ on integers, extended
to make φ the least preferred. The operator ⊕ is deﬁned as
normal addition, except for values that are out of range:
i ⊕ j =  φ
i + j
if (i + j) 6∈ {n, . . . , m},
otherwise.
For example, here is the ⊕ table for add(1, 5):
Σ
⊕ 1
5
φ
4
3
2
5
φ φ
4
3
2
1
5
φ φ φ
4
3
2
φ φ φ φ
5
3
4
5
φ φ φ φ φ
4
5
φ φ φ φ φ φ
L
This table conforms to a convention used throughout the
paper — rows are associated with labels displayed in the left-
most column, while columns are associated with signatures,
displayed along the top row. The signatures are presented
with preference decreasing from left to right.
min(3)
2
1
2
2
⊕ 1
1
1
1
2
1
3
lp(3)
2
1
2
3
⊕ 1
1
1
2
2
3
3
3
1
2
3
3
1
2
3
max(3)
2
2
2
3
⊕ 1
1
1
2
2
3
3
op(3)
2
2
⊕ 1
1
κ
3
3
3
3
3
3
Figure 2: The ⊕ tables of several simple routing
algebras.
The algebra mult(n, m) is are deﬁned in a similar man-
ner for integer multiplication. The algebra multr(n, m)
represents real multiplication (at some ﬁxed precision), for
reals between n and m. The algebras min(n) and max(n)
both have L = Σ = O = {1,
. . . , n}, with the preference
relation being the standard order ≤ on integers. The oper-
ations i ⊕ j are deﬁned to be the minimum and maximum,
respectively, of {i, j}. Figure 2 presents the ⊕ tables for
min(3) and max(3).
The algebra lp(n) (local preference) has L = Σ = O =
{1, . . . , n} and the ⊕ operator is deﬁned as i⊕ j = i. That
is, the last link in a path determines the total path weight.
The dual algebra, op(n) (origin preference), has L = {κ},
Σ = O = {1, . . . , n}, and ⊕ operator is deﬁned as κ⊕j = j.
That is, signatures can only be copied with κ and the orig-
inating node determines the total path weight — the only
way signatures can be attached to routes is at origination.
The ⊕ tables for lp(3) and op(3) are also presented in Fig-
ure 2.
We will also use several base algebras that do not lend
themselves well to tabular presentation due to the large
number of entries. Signatures in the routing algebra seq(n, m)
are ﬁnite sequence σ over the integers in {0, . . . , n}, whose
length | σ | is at most m. The preference relation is deﬁned
as σ1 ¹ σ2
def=| σ1 |≤| σ2 |. The ⊕ operation is deﬁned as
i ⊕ σ =  φ
if m =| σ |,
i :: σ otherwise,
where i :: σ denotes adding i to the head of the sequence σ.
The algebra of simple sequences, simseq(n, m), is deﬁned
in the same manner, except that ⊕ is deﬁned as
if m =| σ | or i ∈ σ,
i ⊕ σ =  φ
i :: σ otherwise.
In both cases the origination set is deﬁned as O = {()},
where () represents the empty sequence.
Finally, if t is some type, such as int or string, then
the signatures of the tags algebra, tags(t), represents all
ﬁnite sets of objects of type t. All such sets are given equal
preference. The ⊕ operation allows for insertion and deletion
of elements and copying:
⊕
i(σ1)
d(σ1)
σ
σ ∪ σ1
σ − σ1
σ
κ
We will see later that tags are very useful for implementing
complex routing policies.
3. A ROUTING ALGEBRA
METALANGUAGE
A metarouting language is any language that allows us to
deﬁne routing protocol, RP , as
RP = hA, M, LMi,
where A is a routing algebra, M is a set of mechanisms
that can be associated with a routing adjacency (multiple
mechanisms may be used for the same protocol, and LM is
a set of label modalities that are described in Section 6).
Constructing new routing algebras by hand, especially
complex ones, can be a diﬃcult and tedious task. This is
even more true when we are required to prove monotonic-
ity conditions. To address this, we present a Routing Al-
gebra Meta-Language (RAML) for the speciﬁcation of new
routing algebras. RAML represents a compromise — every
expressions in RAML represents a routing algebra, but it
is certainly not the case that any routing algebra can be
expressed in RAML. In compensation, monotonicity condi-
tions can be automatically derived for RAML speciﬁcations,
much like types in many programming languages. That is,
no tedious proofs are required of the protocol designer using
RAML. Such a formalism could take many forms, but the
one presented here represents our own attempt to strike a
balance between mathematical simplicity and usefulness.
If X and Y are sets, we use the notation X ] Y to denote
their disjoint union, which can be deﬁned as {h0, xi | x ∈
X} ∪ {h1, yi | y ∈ Y }.
3.1 Lexical Product, A ⊗ B
We start with binary operations. Suppose we are given
two routing algebras,
A = hΣA, ¹A, LA, ⊕A, OAi, B = hΣB, ¹B, LB, ⊕B, OBi,
and we want to deﬁne binary operators • for constructing
new routing algebra A • B,
A • B = hΣ, ¹, L, ⊕, Oi,
We would like the deﬁnition of each operator to be fairly
simple and natural.
One natural approach is to take Σ as the product ΣA×ΣB
and deﬁne ¹ as the lexicographic preference relation:
hσA, σBi ¹ hβA, βBi def=
σA ≺A βA or (σA ∼A βA and σB ¹B βB).
A bit of care must be taken if either ΣA or ΣB contains the
prohibited signature φ. In this case we deﬁne Σ as ((ΣA −
{φ}) × (ΣB − {φ})) ∪ {φ}, and extend the deﬁnition of ¹ so
that hσA, σBi ≺ φ for all hσA, σBi ∈ Σ.
One way to apply labels to product signatures is to do it
pair-wise. Deﬁne O as OA × OB, L as LA × LB, and ⊕ as
⊕
hλA, λBi
hσA, σBi
hλA ⊕A σA, λB ⊕B σBi,
where λi ∈ Li and σi ∈ Σi. However, if either λA ⊕A σA or
λB ⊕B σB is equal to φ, then
hλA, λBi ⊕ hσA, σBi = φ.
In addition, it is always the case that hλA, λBi ⊕ φ = φ.
Product algebras are very useful for routing protocols with
multiple routing metrics. For example, we can think of the
route selection of BGP as a lexicographic comparison of mul-
tiple attributes (see Section 5 for more details). OSPF pro-
vides another example that may not be so obvious. At ﬁrst
glance, it may seem that OSPF is a simple protocol needing
only an algebra of the form add(1, m). However, careful
reading of the protocol speciﬁcation [20] reveals that in fact
it is using a lexicographic ordering. An OSPF signature can
be modeled as a pair, hα, di, where α contains area infor-
mation and d represents distance. Route preference must
be deﬁned so that intra-area routes are preferred over inter-
area routes, no matter what the values of route distance,
and this can be accomplished with lexicographic preference.
(For more discussion of OSPF, see Section 7.)
The binary lexical product naturally generalizes to an n-
ary lexical product,
⊗(A1, A2, . . . , An).
It is often useful to have some means of naming the individ-
ual components of a products signature for ease of notation
when it comes to writing conditional policy labels described
below. For this we introduce the unary operator a : A, which
produces a routing algebra which is exactly like A, except
that each signature is now a pair ha, σi, usually written as
a : σ. Now a fully labeled n-ary product can then be written
as
⊗(a1 : A1, a2 : A2, . . . , an : An),
where the ai are unique labels associated with the sub-
algebras. All (non-φ) signatures then have the form
ha1 : σ1, a2 : σ2, . . . , an : σni.
If all attributes of a product are uniquely labeled, then an
implementation need not enforce a strict order on the se-
quence of values in a tuple.
Another useful feature for products, present in BGP, is
the ability to have optional attributes. There are several
reasonable ways of accomplishing this within RAML, each
with slightly diﬀerent semantics. Although optional argu-
ments may seem trivial at ﬁrst glance, they illustrate well
the metarouting approach. Our desire to preserve algebraic
properties, such as M and SM, provides a rigorous frame-
work in which to explore alternative deﬁnitions. And we
can do this in isolation from the distracting complexities —
inherent and accidental — of a particular routing protocol.
Once we sort out these issues and encode our understanding
in well-deﬁned operators, we then can use them repeatedly
to construct complex yet mathematically tractable proto-
cols.
First, we must decide how missing values are treated by
the preference relation. Suppose we are deﬁning a version of
A⊗ B where the ﬁrst element is optional, and we denote the