ShorTor introduces only one additional step into Tor’s routing
procedure. Rather than forwarding cells solely along previously
established circuits, relays establish transient alternate routes
between themselves and the next hop on their circuits. These
alternate routes forward trafﬁc via an additional Tor relay rather
than sending it directly to the next relay on the circuit. As
such, we refer to the intermediate hops between circuit relays
as via relays, the connection between a circuit relay and a via
relay as a via connection, and the communications over this
connection as via trafﬁc.
Note that the ‘circuit’ and ‘via’ modiﬁers denote different
roles a relay may play in ShorTor, but do not correspond to
different physical entities. A via relay is simply a regular Tor
relay that has been chosen as an intermediate hop for some
circuit rather than as part of the circuit itself. Any relay in Tor
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:36:07 UTC from IEEE Xplore.  Restrictions apply. 
41936
Protocol 1: ShorTor
CIRCUIT RELAY
// Circuit relays conduct data races to determine if a suitable via exists
// between themselves and the next relay on the circuit.
// Parameter: self, Tor ID for this relay.
// State: Routes, the routing table for each circuit.
• SHORTOR.CHOOSEVIA(circ, dst, candidates)
1: via ← RACE.RUN(candidates, circ, dst) // (Protocol 3).
if via = ⊥, then return.
2:
3: Routes[circ].via ← via.
// no via faster than default route.
• SHORTOR.HANDLETRAFFIC(cell)
if cell.cmd = VIA then return SHORTOR.HANDLEVIA(cell).
1:
2: candidates ← LATENCIES.VIASFOR(cell.next). // (Protocol 2)
if Routes[cell.circ] = ⊥ then
// no routing table entry.
3:
3.1: SHORTOR.CHOOSEVIA(cell.circ, cell.next, candidates).
if via = ⊥ then proceed with default cell routing and return.
4: via ← Routes[cell.circ].via.
5:
6: Set cell.cmd = VIA and cell.prev = self.
7: Send cell to relay via.
8:
if no response from via then
8.1: candidates ← candidates \ {via}
8.2: SHORTOR.CHOOSEVIA(cell.circ, cell.next, candidates).
8.3: SHORTOR.HANDLETRAFFIC(cell)
VIA RELAY
// Via relays forward cells between circuit relays.
// Via relays do not perform onion decryption and only forward trafﬁc
// if they have the available resources (i.e., bandwidth).
• SHORTOR.HANDLEVIA(cell)
1: route ← Routes[cell.circ]
2:
3: Forward cell to route.next.
4: Forward response from route.next to route.prev.
if under heavy load or route = ⊥ then drop cell and return.
can act as both a circuit and a via relay simultaneously for
different trafﬁc streams.
1) ShorTor Protocol Stages: The ShorTor protocol pro-
ceeds in several stages. On an ongoing basis, relays take
measurements of their round-trip latencies with other relays
(LATENCIES.UPDATE(), Protocol 2). Circuit relays use these
measurements to choose candidate via relays for outgoing
trafﬁc (SHORTOR.CHOOSEVIA(), Protocol 1). They perform
a “data race” to choose the fastest path (RACE, Protocol 3).
If a route with a via relay is faster than the default path, the
circuit relay updates its routing table. In the steady state, the
circuit relay handles trafﬁc for its circuits as usual, but directs
it to the via relay rather than to the next circuit hop.
Establishment: When establishing a connection for a given
circuit, relays on that circuit will run LATENCIES.VIAFOR()
(Protocol 2) to obtain a shortlist of potential vias. These vias
are those that have recently been observed to provide the largest
latency improvements over the default path between this relay
and the next hop on its circuit. The circuit relay then performs
a data race over each of the candidate vias (RACE.RUN(),
Protocol 3).
The ﬁnish line of this race is the next relay on the relevant
(cid:38)(cid:76)(cid:85)(cid:70)(cid:44)(cid:39)
(cid:49)(cid:72)(cid:91)(cid:87)(cid:44)(cid:39)
(cid:51)(cid:68)(cid:92)(cid:79)(cid:82)(cid:68)(cid:71)
(cid:38)(cid:48)(cid:39)
(cid:51)(cid:85)(cid:72)(cid:89)(cid:44)(cid:39)
(cid:53)(cid:82)(cid:88)(cid:87)(cid:76)(cid:81)(cid:74)(cid:3)(cid:55)(cid:68)(cid:69)(cid:79)(cid:72)
(cid:38)(cid:76)(cid:85)(cid:70)(cid:44)(cid:39)
(cid:49)(cid:72)(cid:91)(cid:87)(cid:44)(cid:39)
(cid:57)(cid:76)(cid:68)(cid:44)(cid:39)
(cid:17)
(cid:17)
(cid:17)
(cid:17)
(cid:17)
(cid:17)
(cid:17)
(cid:17)
(cid:17)
Fig. 4: Via Cell and Routing Table (ﬁelds added to baseline Tor
highlighted in grey): Via cells contain additional header ﬁelds with
routing info. This information is used by circuit relays to populate
the routing table with which via (if any) each circuit should be routed
through, while via relays use it to record where to forward cells from
a given circuit.
circuit which can report to the starting relay which of the data
race cells arrived ﬁrst. We provide details on the selection of
candidate via relays in Section III-B2.
Routing: While establishing a via connection, both the
circuit and via relays must update their routing tables: circuit
relays note which via to send cells to, while vias record which
circuit relay should receive their forwarded trafﬁc. To do this,
we simply introduce new ﬁelds in Tor cell headers and routing
tables, described in Figure 4. These allow relays to recognize
trafﬁc streams and route them to the correct next hop.
Steady-State: Trafﬁc over via connections that have
already been established is handled similarly to regular Tor
trafﬁc. Via relays simply forward the received trafﬁc stream
according to their routing table for the circuit. As via relays
are not part of client circuits, they do not perform onion
decryption/encryption prior to forwarding cells. Circuit relays
also function as in baseline Tor except in cases where their
routing table for a circuit contains a via relay. Then, the relay
will alter the header on cells for these circuits as shown in
Figure 4 and send the cells to the indicated via rather than to
the next relay on the circuit. Periodically, relays on a circuit
can repeat the data race to determine whether a given via is
still the fastest option based current network status.
2) Latency Measurements: ShorTor relies on two forms of
latency measurements (1) an up-to-date table of probable via
candidates for each relay pair (Protocol 2) and (2) the data
race that determines the fastest of the candidates (Protocol 3).
3) Pairwise Latency: ShorTor requires latency measurements
between Tor relays to narrow down the set of potential via relay
options for a circuit. In LATENCIES.UPDATE() (Protocol 2),
each Tor relay collects this latency information as needed,
distributing the involved storage, computation, and network
load across the Tor network. This is in contrast to the centralized
measurement methodology we use to evaluate ShorTor in
Section IV which, while useful for this work, would not meet
the performance needs of the live ShorTor protocol.
To participate in the distributed latency measurements of
Protocol 2, each relay maintains their estimated round-trip
latency to every other relay along with a list of “candidate” via
relays. The candidates are computed by each relay using the
round-trip latency tables for itself and for the destination relay
based on latencies provided by the destination. ShorTor uses
latencies reported from the destination for security reasons: an
honest destination will not recommend a dishonest via relay
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:36:07 UTC from IEEE Xplore.  Restrictions apply. 
51937
Protocol 2: LATENCIES
ALL RELAYS
// Parameter: (cid:2), how many routes to keep.
// Parameter: IDs of all n active Tor relays: Tor = {id1, . . . , idn}.
// State: table RTTs: ping times to each other relay.
// State: table NextHop: for each relay, the top (cid:2) candidate vias (id, rtt).
• LATENCIES.UPDATE()
// Keep RTTs and NextHop tables up-to-date.
// Run periodically (once per day).
1: for id ∈ Tor:
1.1: Ping relay id to estimate round-trip time (RTT).
1.2: Set RTTs[ID] to estimated value.
1.3: Remove ( , rtt) ∈ NextHop[id] with rtt ≥ RTTs[id].
1.4: RTTsid ← LATENCIES.RTTS() (remote call to relay id).
1.5: for via ∈ Tor
1.5.1: rtt ← RTTs[via] + RTTsid[via].
if rtt ≥ RTTs[id] then continue
1.5.2:
// no speedup.
1.5.3: Add (via, rtt) to NextHop[id], keeping fastest (cid:2) entries.
• LATENCIES.RTTS()
1: Output RTTs.
• LATENCIES.VIASFOR(id)
1: Output Routes[id].
// up to (cid:2) candidate via relays.
disproportionately often, while a dishonest destination was
already on the circuit and gains nothing by lying. The list of
candidate vias is used to inform the data race which will select
the fastest via from the list at the time of the race.
4) Data Race: Directly choosing via connections based on
measured latencies has several potential drawbacks. First, the
measured latencies are round-trip, while network paths are
directional: the fastest path from relay A to relay B might
be different from the fastest path from relay B to relay A.
Timestamping at the destination halfway through the round
trip does not address this issue, as it becomes impossible to
distinguish between imperfect clock synchronization and path
asymmetry. Second, latencies change in real-time in response to
network conditions, like congestion at relays or on internet links.
Third, latencies might be inaccurate due to measurement errors
or even misreporting by malicious relays; we must take care
to prevent such relays from seeing disproportionate amounts
of trafﬁc. As such, measured latencies alone are insufﬁcient.
Instead circuit relays choose the fastest via using a “data
race:” sending packets along different routes to see which
arrives at the destination ﬁrst (RACE.RUN(), Protocol 3). The
starting relay simultaneously sends a copy of a data race cell
to each prospective via relay, and one copy directly to the
destination. The destination relay, which is the next hop on
the circuit, responds only to the ﬁrst of these cells to arrive.
Data races are directional—relays can identify the fastest
path in each direction separately. Additionally malicious via
relays cannot report lower latencies to artiﬁcially increase their
odds of being selected. Data race cells are not forgeable by the
via, so the via must wait to receive the cell from the source
circuit relay before delivering it to the destination relay. Thus,
the via cannot artiﬁcially reduce its perceived latency below
Protocol 3: RACE
CIRCUIT RELAY:
// Find the fastest via relay for reaching the destination relay.
// Parameter: myId, Tor ID of this relay.
// State: Seen, a set of circuit IDs for which this relay has seen data
race packets.
• RACE.RUN(vias, circ, dst)
next = dst, and circ = circ.
Input: Candidate vias vias = {v1, . . . , v(cid:2)}, destination relay dst
Output: Fastest via v if one exists; ⊥ otherwise.
1: Create data race cell cell with ﬁelds cmd = RACE, prev = self,
2: for via ∈ vias: send cell to via.
3: Send data race cell directly to dst.
4: resp ← response from dst.
5: Output resp.via.
// May be ⊥ if no via provides speedup.
• RACE.RESPOND(cell)
Input: Data race cell from source relay (sender).
if cell.circ ∈ Seen then drop cell and return.
1:
2: Add cell.circ to Seen.
if cell.prev = sender then via ← ⊥
3:
4: else via ← sender.
5: Send response resp to cell.prev with resp.via = via.
VIA RELAY:
// Via relays update their routing tables to forward trafﬁc on a stream,
// provided sufﬁcient resources are available to do so.
// State: Routes, the routing table for each circuit.
• RACE.VIAFORWARD(cell)
Input: Data race cell cell with cell.cmd = RACE.
if under heavy load then drop cell and return.
1:
2: Add cell.prev and cell.next to Routes[cell.circ].
3: Forward the cell to relay cell.next.
the true time it takes to forward the cell.
5) Avoiding Trafﬁc Loops: We deﬁne a loop to occur when
the same trafﬁc stream passes through a relay more than once.
This is an issue as such relays could utilize trafﬁc correlation to
identify the previously seen trafﬁc stream, thus learning a larger
portion of its path through Tor than they should have been privy
to. Tor only builds circuits using distinct, unrelated relays to
ensure that circuits contain no loops. However, because ShorTor
selects via relays separately from the circuit selection process,
care must be taken to avoid loops.
In order to provide the same guarantee as Tor, we require
that ShorTor is applied only to circuits of length exactly three
(the default in Tor) and that only a single via is used between
any pair of relays. This ensures that the middle relay of a
circuit is capable of observing all vias on that circuit and
enforcing the same guarantees as for circuit relays. That is, in
either direction of a circuit, the middle relay will not choose to
use a via that is already in use for the prior hop or is related to
a relay on the circuit. We elaborate on security in Section V,
but note here that a malicious middle relay gains no advantage
by failing to enforce this guarantee, as it already knows the
identities of both the guard and exit relays and does not need
to correlate trafﬁc across the via to get this information.
6) Stability: ShorTor’s distributed via selection protocol
must avoid oscillations where circuit relays swap back and
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:36:07 UTC from IEEE Xplore.  Restrictions apply. 
61938
forth between vias. As an example, without appropriate
precautions, a cycle could form where trafﬁc streams dropped
from an overwhelmed via all divert to the same alternate via,
subsequently overwhelming that via and causing the streams
to revert to the original choice, and so on. We note that this
situation is not prohibitive: CDNs use a similar overlay routing
technique in practice, carrying substantial portions of internet
trafﬁc, without such stability problems.
We mitigate the risk of this situation in ShorTor through
backoff and capacity parameters in the data race. We note that
races are an integral component of the ShorTor protocol and are