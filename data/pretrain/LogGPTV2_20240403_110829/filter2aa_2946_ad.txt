5
);
6
滴水逆向课程笔记  –  Win32
事件  –  52
如下图所示，我们运行了代码，会发现两个线程都执行了，而如果是之前我们使用互斥体的话则线程A先执行
然后线程B等待线程A归还令牌（执行结束）才会执行，这里我们在线程函数的最后使用了getchar()阻止了线程
执行结束，但是两个线程还是都执行了：
#include 
1
2
HANDLE e_event;
3
4
DWORD WINAPI ThreadProc(LPVOID lpParameter) {
5
    // 等待事件
6
    WaitForSingleObject(e_event, INFINITE);
7
    printf("ThreadProc - running ...\n");
8
    getchar();
9
    return 0;
10
}
11
12
DWORD WINAPI ThreadProcB(LPVOID lpParameter) {
13
    // 等待事件
14
    WaitForSingleObject(e_event, INFINITE);
15
    printf("ThreadProcB - running ...\n");
16
    getchar();
17
    return 0;
18
}
19
20
int main(int argc, char* argv[])
21
{
22
23
    // 创建事件
24
    // 第二个参数，FALSE表示非通知类型通知，也就是互斥；TRUE则表示为通知类型
25
    // 第三个参数表示初始状态没有信号
26
    e_event = CreateEvent(NULL, TRUE, FALSE, NULL);
27
28
    // 创建2个线程
29
    HANDLE hThread[2];
30
    hThread[0] = CreateThread(NULL, NULL, ThreadProc, NULL, 0, NULL);
31
    hThread[1] = CreateThread(NULL, NULL, ThreadProcB, NULL, 0, NULL);
32
33
    // 设置事件为已通知，也就是设置为有信号
34
    SetEvent(e_event);
35
36
    // 等待线程执行结束，销毁内核对象
37
    WaitForMultipleObjects(2, hThread, TRUE, INFINITE);
38
    CloseHandle(hThread[0]);
39
    CloseHandle(hThread[1]);
40
    // 事件类型也是内核对象，所以也需要关闭句柄
41
    CloseHandle(e_event);
42
43
    return 0;
44
}
45
滴水逆向课程笔记  –  Win32
事件  –  53
我们修改下创建事件函数的参数为互斥，来看一下，那么互斥和通知类型的区别一下就很明显的展示出来了：
滴水逆向课程笔记  –  Win32
事件  –  54
那么通知类型实现的原理是什么呢？实际上这个跟WaitForSingleObject函数有关，我们可以看下MSDN Library
对该函数的介绍：
可以很清晰的看见最后说到，该函数会修改内核对象的状态，所以通知类型的原理就很简单了，就是当事件对
象为通知类型时该函数就不会去修改对象的状态，这个状态我们可以理解成是占用，当WaitForSingleObject函
数判断为非占用时就修改内核对象的状态为占用然后向下执行，而其他线程想使用就需要等待，这就是互斥的
概念。
13.2 线程同步
线程互斥：线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性；当有若干个线程都要使用
某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者
释放该资源。
线程同步： 线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没
有得到另一个线程的消息时应等待，直到消息到达时才被唤醒；同步的前提是互斥，其次就是有序，互斥并不
代表A线程访问临界资源后就一定是B线程再去访问，也有可能是A线程，这就是属于无序的状态，所以同步就
是互斥加上有序。
滴水逆向课程笔记  –  Win32
事件  –  55
13.2.1 生产者与消费者
想要证明事件和互斥体最本质的区别，我们可以使用生产者与消费者模型来举例子，那么这个模型是什么意思
呢？
我们就可以理解为生产者生产一个物品，将其放进容器里，然后消费者从容器中取物品进行消费，就这样“按
部就班”下去...
互斥体
首先我们来写一段互斥体下的生产者与消费者的代码：
生产者消费者模式就是通过一个容器来解决生产者和消费者的强耦合（依赖性）问题。生产者和消费
者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处
理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一
个缓冲区，平衡了生产者和消费者的处理能力。
滴水逆向课程笔记  –  Win32
事件  –  56
#include "stdafx.h"
1
#include 
2
3
// 容器
4
int container;
5
6
// 次数
7
int count = 10;
8
9
// 互斥体
10
HANDLE hMutex;
11
12
// 生产者
13
DWORD WINAPI ThreadProc(LPVOID lpParameter) {
14
    for (int i = 0; i 
1
2
// 容器
3
int container = 0;
4
5
// 次数
6
int count = 10;
7
8
// 事件
9
HANDLE eventA;
10
HANDLE eventB;
11
12
// 生产者
13
DWORD WINAPI ThreadProc(LPVOID lpParameter) {
14
    for (int i = 0; i < count; i++) {
15
        // 等待事件，修改事件A状态
16
        WaitForSingleObject(eventA, INFINITE);
17
        // 获取当前进程ID
18
        int threadId = GetCurrentThreadId();
19
        // 生产存放进容器
20
        container = 1;
21
        printf("Thread: %d, Build: %d \n", threadId, container);
22
        // 给eventB设置信号
23
        SetEvent(eventB);
24
    }
25
    return 0;
26
}
27
28
// 消费者
29
DWORD WINAPI ThreadProcB(LPVOID lpParameter) {
30
    for (int i = 0; i < count; i++) {
31
        // 等待事件，修改事件B状态
32
        WaitForSingleObject(eventB, INFINITE);
33
        // 获取当前进程ID
34
        int threadId = GetCurrentThreadId();
35
        printf("Thread: %d, Consume: %d \n", threadId, container);
36
        // 消费
37
        container = 0;
38
        // 给eventA设置信号
39
        SetEvent(eventA);
40
    }
41
    return 0;
42
}
43
44
int main(int argc, char* argv[])
45
{
46
    // 创建事件
47
    // 线程同步的前提是互斥
48
    // 顺序按照先生产后消费，所以事件A设置信号，事件B需要通过生产者线程来设置信号
49
    eventA = CreateEvent(NULL, FALSE, TRUE, NULL);
50
    eventB = CreateEvent(NULL, FALSE, FALSE, NULL);
51
52
    // 创建2个线程
53
    HANDLE hThread[2];
54
    hThread[0] = CreateThread(NULL, NULL, ThreadProc, NULL, 0, NULL);
55
滴水逆向课程笔记  –  Win32
事件  –  60
运行结果如下图：
    hThread[1] = CreateThread(NULL, NULL, ThreadProcB, NULL, 0, NULL);
56
57
    WaitForMultipleObjects(2, hThread, TRUE, INFINITE);
58
    CloseHandle(hThread[0]);
59
    CloseHandle(hThread[1]);
60
    // 事件类型也是内核对象，所以也需要关闭句柄
61
    CloseHandle(eventA);
62
    CloseHandle(eventB);
63
64
    return 0;
65
}
66
滴水逆向课程笔记  –  Win32
窗口的本质  –  61
1.
2.
3.
14 窗口的本质
之前我们学习写的程序都是基于控制台的，而从本章开始学习图形化界面相关的知识。
之前我们所学习的进程、线程之类的函数，其接口来源于kernel32.dll → ntoskrnl.exe；而我们要学习的图形化
界面的接口，它就来源于user32.dll、gdi32.dll → win32k.sys。
user32.dll和gdi32.dll的区别在哪呢？前者是你想使用Windows已经画好的界面就用它，我们称之为GUI编程；
后者是你想自己画一个界面，例如你要画一朵花，那么就使用后者，因为这涉及到绘图相关的内容，我们称之
为GDI编程。
之前我们了解过HANDLE句柄，其都是私有的，而在图形界面中有一个新的句柄，其叫HWND，win32k.sys提供
在内核层创建图形化界面，我们想要在应用层调用就需要对应的句柄HWND，而这个句柄表是全局的，并且只
有一个。
14.1 GDI - 图形设备接口
GDI是Graphics Device Interface的缩写，其中文为图形设备接口。
本章主要是学习如何进行GDI编程，但是我们在日常的工作中是不需要用到的，并且没有什么实际意义（需要
的都有现成的），我们学习它就是为了来了解窗口的本质、消息机制的本质。
关于GDI有这么几个概念：
设备对象：画的位置