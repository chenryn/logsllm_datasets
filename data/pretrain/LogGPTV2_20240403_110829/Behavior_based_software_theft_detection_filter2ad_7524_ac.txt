management system call sequences. Therefore, we ignore
all memory management system calls. Second, some types
of system calls are considered as the same in system call
birthmarks, because some system calls provide multiple ver-
sions that take slightly diﬀerent parameters for convenience.
For example, fstat(int fd, struct stat *sb) system call is the
same as stat(const char *path, struct stat *sb) except that
fstat uses the ﬁle descriptor fd as its parameter instead of
the ﬁle name path. By considering such system calls iden-
tical, we can not only reduce the sophistication of dealing
with many diﬀerent system calls, but also address the coun-
terattack where an attacker replaces one system call with
another. Finally, since failed system calls do not aﬀect the
behavior characteristic of a program, they are also ignored.
For example, when a program tries to open a ﬁle, it may
fail at the ﬁrst time but succeed at the second time. Al-
though system call open is called twice, here the ﬁrst failed
call should be removed.
3.4 Extraction of SCDG Birthmarks
⊙ Extraction of Plaintiﬀ Birthmarks. There are four steps to
extract SCDG birthmarks for a plaintiﬀ component. First,
by analyzing the system call trace whose noise has been re-
moved, we determine whether a system call is called by a
plaintiﬀ component. This is useful for detecting software
component theft because we need to know which system
calls are invoked from which component of a plaintiﬀ pro-
gram. Speciﬁcally, there are two implementation options.
One method is to use a special list, L, containing informa-
tion on the functions belonging to the plaintiﬀ component.
List L can be automatically generated by processing the
source code of the plaintiﬀ component with a tool such as
Elsa [2]. Then, whenever a system call is called, Hawk can
notice whether the system call is called by the plaintiﬀ com-
ponent by searching in the call stack (containing callers of
the system call) for any occurrence of the functions listed
in L. Note that we can preserve the symbol table of the
plaintiﬀ component because we have control over the com-
pilation of plaintiﬀ source codes. Alternatively, a simpler
method which does not need to maintain list L is available.
If we can compile the plaintiﬀ component into a dynamic
linked library (DLL), Hawk can simply use a utility func-
tion provided in Valgrind to retrieve the DLL component
that contains any of the callers of the invoked system call.
Second, an SCDG and a dynamic call tree are built from
the system call traces corresponding to the the plaintiﬀ com-
ponent. Building an SCDG is trivial given nodes (system
calls) and edges (dependences). Besides SCDG, we also
build a dynamic call tree, which will be used to partition
an SCDG in later steps. A dynamic call tree here is a tree
with subroutine calls as internal nodes and system calls as
leaf nodes. A node’s parent is its caller and its children are
its callees. The path from a leaf system call node to the
root node is the call stack of the system call. The process of
generating a dynamic call tree is also trivial: we just need
to merge all the call stacks.
Third, we divide an SCDG into subgraphs. Because an
extracted SCDG may be too large to eﬃciently compute
subgraph isomorphism and/or too speciﬁc for the plaintiﬀ
program, they are not directly used as birthmarks. As a
component theft is mostly likely to happen over a subrou-
tine, we partition the graph based on dynamic call tree.
That is, we extract a subtree from the dynamic call tree,
and the leaf nodes in the subtree and their dependence re-
lation consist of an SCDG birthmark candidate. The par-
tition process is as the following. We ﬁrst set a parameter
m, which is used to guarantee that the subgraph is not too
large or too speciﬁc for the partition. Then, the dynamic
call tree of the selected component is traversed by a depth
ﬁrst search algorithm. When a tree node is visited, the num-
ber of leaf nodes in this subtree is calculated. If the number
is less than m, the subtree is selected and search within the
subtree is skipped. The process is ﬁnished when all nodes
in the dynamic call tree is traversed.
Finally, we remove the SCDG subgraphs which represent
common behaviors. This step is necessary because we need
to ﬁnd the unique behavior of plaintiﬀ components as birth-
marks. For this purpose, a set of training programs are used.
The set of programs should include programs which have a
similar component with the plaintiﬀ program but are indeed
completely unrelated programs. The SCDG subgraphs are
compared with the SCDGs of the training set. All SCDG
subgraphs which are subgraph isomorphism to the SCDGs
of the training set are removed, and ﬁnally, the remaining
subgraphs become birthmarks.
⊙ Extraction of Suspect Birthmarks. As mentioned earlier,
we assume that there are no source code and symbolic de-
bugging information of a suspect program. Hence, it is diﬃ-
cult to identify the suspicious components in a suspect pro-
gram, not to mention extracting SCDGs from them. Thus,
we have to extract SCDG birthmarks based on the SCDG
of the whole suspect program. Speciﬁcally, we partition the
whole SCDG according to dynamic call tree, as in the case
for plaintiﬀ birthmark extraction, except that we choose m
to be several times larger.
3.5 Birthmark Comparison
Once both the plaintiﬀ and suspect SCDG birthmarks are
extracted, they are compared using (relaxed) VF subgraph
isomorphism algorithm [14]. n ∗ m pairs subgraph isomor-
phism testing are needed in principle, where n and m are the
numbers of plaintiﬀ and suspect birthmarks, respectively.
Fortunately, most pairs can be pruned through three forms
of loseless pruning.
Pruning Search Space First, SCDG birthmarks smaller
than an interesting size K or the types of system calls smaller
than T are excluded from both plaintiﬀ and suspect birth-
marks. For software theft detection, we only need to locate
birthmark pairs of non-trivial ones, which, if found, can pro-
vide strong evidence for proving theft. Second, based on
the deﬁnition of γ − isomorphism, a SCDG birthmark pair
(g, g ′) can be excluded if |g ′|  mi and ei = 0 if ni ≤ mi
. Based on the deﬁnition of γ −isomorphism, the pair (g, g ′)
can be excluded if d < (1 − γ)|g|.
Computational Feasibility. Because our SCDG birthmark
involves subgraph isomorphism testing, we discuss the com-
putation feasibility of the testing. As mentioned in [19],
although subgraph isomorphism is NP-complete in general,
research in the past three decades has shown that some al-
gorithms are reasonably fast on average and become com-
putationally intractable in a few cases [12,13]. For instance,
algorithms based on backtracking and look-ahead, e.g., Ull-
mann’s algorithm [30] and VF [14], are suitable with graphs
of thousands of nodes.
In addition to the general tractability issue, the charac-
teristics of graphs and the needs for a speciﬁc application
also reduce the computational cost [19]. In our application,
the computational cost are reduced for the following reasons.
First, the size of SCDGs is limited by a predeﬁned parame-
ter (100 or 400 in our experiment). Second, SCDGs are not
ordinary graphs. Their characteristics such as various types
of nodes, makes backtrack-based isomorphism algorithm ef-
ﬁcient. Last, the ﬁrst matching suﬃces for software theft
detection, whereas the traditional testing ﬁnds all isomor-
phism pairs. Hence, the isomorphism testing on SCDGs is
tractable and eﬃcient in practice.
Finally, our search space pruning phase can eﬀectively
identify and discard the spurious SCDG pairs which are
obviously not isomorphic to each other, avoiding detailed
isomorphism testing. As a result, only a small portion of
SCDG pairs are really tested in the case of a real software
theft. Thus, our detection is computationally eﬃcient in our
speciﬁc problem settings.
4. EVALUATION
In Section 1 we mentioned ﬁve key requirements on soft-
ware theft detection.
It is easy to see R4 and R5 are al-
ready met by our design. In this section, we evaluate the
performance of SCDG birthmarks with respect to three pri-
mary criteria: (M1) capability to detect component theft for
large-scale programs, (M2) credibility to independently de-
veloped program, and (M3) resiliency to obfuscation. These
three criteria contain more than R1, R2 and R3 because of
M2.
In the following, we ﬁrst discuss the implementation of our
system and environmental setup. Then, we evaluate criteria
M1 and M2 for SCDG birthmarks with over 30 real-world
large application programs. Finally, we evaluate criteria M3
against evasion techniques that apply diﬀerent compilers,
diﬀerent compiler optimization levels, or obfuscation tech-
niques.
4.1 Implementation and Environmental Setup
We implemented a prototype of SCDG birthmark based
software theft detection system. The entire system consists
of about 5,000 lines of C/C++ code and 1000 lines of Tcl
script code. Our implementation of the γ-isomorphism test-
ing algorithm was adopted from VFlib1. We used tree.hh2,
an STL-like C++ tree class, for dynamic call tree represen-
tation and operation. The version of Valgrind we used is
3.3.1. The entire detection system runs under Ubuntu 8.04.
For detection purpose, we fed the same input and perform
the same operation (spell checking) if applicable; otherwise,
an appropriate input and a simple operation was provided.
In our experiment, we set γ = 0.9, minimal size of SCDG
birthmarks K = 15, and maximal size of SCDG birthmarks
m 100 for plaintiﬀ programs and 400 for training programs
and testing sets (i.e., suspect programs), respectively.
1http://amalﬁ.dis.unima.it/graph
2http://www.aei.mpg.de/∼peekas/tree
4.2 Effectiveness of SCDG
We chose two subject program components for experi-
ments: Gecko layout engine for web browser and GNU As-
pell spell checker. Before we give details on the subject
components’ SCDG birthmarks and show the eﬀectiveness,
we ﬁrst introduce the training program set and the testing
program set.
Training Program Set. The following programs were
part of the training program collection: Dillo, Yudit, Meld,
Gimp, Totem, Pdfedit and Dia. Dillo was chosen for its
similar web content rendering behavior with Gecko engine.
Yudit was chosen for its similar spell checking behavior with
Aspell. Others were chosen for general common behaviors.
Each training program was executed under our dynamic
analysis system and performed a simple operation and then
quit. We fed one of our authors’ home page url as input to
Dillo and quit it after the home page was displayed. The
home page html was also fed to Yudit and performed spell
checking and quit. For other programs, appropriate input
and a simple operation were provided (e.g. giving Gimp a
gif ﬁle and then adjust color balance) and then quit. Table 1
shows the statistics for the SCDGs of the training program
set. Note that for the training program set, we have already
known that none of them contains our subject components.
Table 1: Training set statistics
Program Version
Type
SCDG
Node # Edge #
Dillo
Yudit
Meld
Gimp
Totem
Pdfedit
Dia
0.8.6
2.4.1
1.1.5.1
2.4.5
2.22.1
0.3.2
0.96.1
Web Browser
Text Editor
Diﬀ Viewer
Graph Editor
Media Player
PDF Editor
Diagram Drawing
2612
4576
12314
59372
21865
8937
27145
1510
1023
7084
5972
6762
4867
29185
Table 2: Testing set statistics
Program
Version
Type
SCDG
Node # Edge #
Flock
Epiphany
Konqueror
Amaya
Opera
Songbird
Galeon
AbiWord
KWord
LyX
Texmaker
Kile
Gedit
Blueﬁsh
GNU Emacs
Vim
Pidgin
Kopete
Kmess
GnoCHM
Evince
GV
Quod Libet
Evolution
2.5.2
0.12.7
1.5
0.9.9
2.22.2
3.6.3
1.0
2.22.3
2.0.3
2.22.2
3.5.10
Web Browser
Web Browser
Web Browser
Web Browser
Web Browser
Web Browser
Web Browser
10
9.52
1.1.2
2.0.7
2.4.6 Word Processor
1.6.3 Word Processor
1.5.3
1.6
2.0.0
2.22.3
1.0.7
22.2.1
7.1.138
Latex Editor