S responds with m2 by running s reject(m1). m2 contains
a source-address token stk that will be used later by C to
3In QUIC, kstk is derived using similar methods as the initial and
session keys and may depend on user-supplied inputs. Poorly chosen user
inputs could lead to IP-spooﬁng opportunities, but we do not address this
weakness because quantifying the predictability of user inputs is out of
scope. For simplicity, we assume that users setting up QUIC servers provide
unpredictable inputs, and treat k
stk as a random string in our analysis.
4We ignore the optional server nonce used in the case of persistent time
synchronization problems, and such parameters as the server’s supported
algorithms for key generation, authenticated encryption with associated data
and congestion control as they are not pertinent to our security analysis.
219219
Client(Mc, pkj )
Server(Ms)
Mc = (M 1
c , M 2
c , · · · , M u
c )
Ms = (M 1
s , M 2
s , · · · , M w
s )
(1) Initial Key Agreement
m1 ← c i hello(pkj)
m3 ← c hello(m2)
ik ← get i key c(m3)
(2) Initial Data Exchange
for each α ∈ [ı]
sqnc ← α + 2
m1
m2
m3
m2 ← s reject(m1)
ik ← get i key s(m3)
for each β ∈ [j]
sqns ← β + 1
mα
4 ← pak(ik, sqnc, M α
c )
β
5 ← pak(ik, sqns, M β
s )
m
m4 ← (m1
m4
process packets(ik, m5) m5
4, · · · , mı
4)
(3) Key Agreement
m5 ← (m1
5)
process packets(ik, m4)
5, · · · , m
j
sqns ← 2 + j
m6 m6 ← s hello(m3, ik, sqns)
k ← get key c(m6, sqns)
k ← get key s(m6)
(4) Data Exchange
for each α ∈ {ı + 1, . . . , u}
for each β ∈ {j + 1, . . . , w}
sqnc ← α + 2
sqns ← β + 2
7 ← pak(k, sqnc, M α
mα
c )
m7 ← (mı+1
, · · · , mu
7 )
process packets(k, m8)
7
m7
m8
β
8 ← pak(k, sqns, M β
s )
m
, · · · , mw
m8 ← (m
8 )
process packets(k, m7)
j+1
8
Figure 1. Summary of QUIC’s 1-RTT Connection Establishment
identify itself to S for this and any other additional sessions
in 0-RTT connection requests (which we discuss below). An
stk is similar to a TLS SessionTicket [14]. It consists of
an authenticated-encryption block of the client’s IP address
and a timestamp. To generate an stk, the server uses the
same E algorithm associated with the AEAD with kstk. The
initialization vector ivstk is selected randomly. stk can be
used by the client in later connection requests as long as it
does not expire and the client does not change its IP address.
For simplicity, we take the range of validity of stk to be
bound by the time period during which it was generated or
set up. m2 also contains S’s current state scfgt
pub, which
contains S’s Difﬁe-Hellman (DH) public values with an
expiration date and a signature prof over all the public
values under the server’s secret key sk.
s reject(m):
$← {0, 1}96
ivstk
stk ← (ivstk, E(kstk, ivstk, ε, (IPc, current_times
return (IPs, IPc, ports, portc, cid, 1, scfgt
pub, stk)
After receiving m2, C checks that scfgt
pub is authentic
and not expired. Note that we assume here that a proper PKI
)))
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:06:38 UTC from IEEE Xplore.  Restrictions apply. 
)
)
is in place, so C possesses the public key of S and is able
to perform this check. C then generates a nonce and its own
DH values by running c hello(m2). C then sends its nonce
and public DH values to the server in m3.
c hello(m):
← (g, q, yc)
, nonc ← (current_timec, r)
$← {0, 1}160
$← Zq−1, yc ← gxc , pubc
abort if expy ≤ τt or
Ver(pk, (str, 0x00, scid, pubs, expy), prof) (cid:5)= 1,
where str ← “QUIC server conﬁg signature”
r
xc
pkt info ← (IPc, IPs, portc, ports
return (pkt info, cid, 2, stk, scid, nonc, pubc
After this point, C and S derive the initial key material
ik by running get i key c(m3) and get i key s(m3) respec-
tively. The server has to make sure that it does not process
the same connection twice, so it keeps track of used nonces
with a mechanism called the strike-register or strike. The
client includes a timestamp in its nonc, such that servers
only need to maintain state for a limited amount of time, this
requires a clock sync between client and server. A server
rejects a connection request from a client if its nonc is
already included in its strike or contains a timestamp
that is outside the allowed time range called strikerng.
We consider strikerng to be bound by the time period
during which it was generated or set up.
ik = (ikc, iks, iv) consists of two parts: the two 128-bit
application keys (ikc, iks) and the two 4-byte initialization
vector preﬁxes iv = (ivc, ivs). C uses iks and ivs to
encrypt data that it sends to S, while using ikc and ivc to
decrypt data it receives from S, and vice versa. This stage
needs to take place only once per each time period τt for
which scfgt
pub and stk are not expired. We model the
HMAC with a random oracle in our analysis.
get i key c(m):
ipms ← yxc
return xtrct xpnd(ipms, nonc, cid, m, 40, 1)
s
get i key s(m):
(ivstk, tk) ← stk
dec ← D(kstk, ivstk, ε, tk)
abort if either dec = ⊥, or ﬁrst 4 bytes of dec (cid:5)= IPc, or
last 4 bytes correspond to a timestamp outside allowed time,
or r ∈ strike, or τt /∈ strikerng, or
scid is unknown or corresponds to an expired scfgt(cid:2)<t
or g, q of pubc are not the same as g, q of pubs
ipms ← yxs
return xtrct xpnd(ipms, nonc, cid, m, 40, 1)
pub
c
xtrct xpnd(pms, nonc, cid, m, (cid:8), init):
ms ← HMAC(nonc, pms)
if init = 1, then str ← ”QUIC key expansion”
else, str ← ”QUIC forward secure key expansion”
info ← (str, 0x00, cid, m, scfgt
return the ﬁrst (cid:8) octets (i.e. bytes) of
T = (T(1), T(2), · · · ), where for all i ∈ N,
T(i) = HMAC(ms, (T(i − 1), info, 0x0i)) and T(0) = ε
Initial Data Exchange consists of two packet sequences
1
c , . . . , M ı
c
s encrypted and authenticated using AEAD
α) for each α in [ı] or
m4 and m5. C and S exchange their initial data M
and M
with ik by running pak(ik, sqnc, M i
1
s , . . . , M j
pub)
β) for each β in [j] respectively. sqnc and
pak(ik, sqns, M i
sqns correspond to the sequence numbers of packets sent
by C and S respectively.
get iv in QUIC outputs the iv which is the concatenation
of either ivc and sqns when S sends a packet or ivs and
sqnc when C sends a packet. ivc and ivs are each 4 bytes
in length, while sqnc and sqns are each 8 bytes in length.
Thus, each iv is 12 bytes in length.
Note that the sequence numbers in QUIC are generated
per packet, always start with 1, and are independent of what
that packet is carrying. ı and j correspond to the maximal
number of message blocks that C and S can send prior
to the Key agreement stage. Upon receipt of packets from
S, C decrypts them and outputs their respective payloads
concatenated together in the order of their sequence numbers
with function process packets. S does the same with packets
it receives from C.
get iv(H, κ):
(kc, ks, ivc, ivs) ← κ
if this is a client, then src ← c and dst ← s
else src ← s and dst ← c
(cid, sqn) ← H
return (ivdst, sqn)
pak(κ, sqn, m):
(kc, ks, ivc, ivs) ← κ
if this is a client, then src ← c and dst ← s
else src ← s and dst ← c
pkt info ← (IPsrc, IPdst, portsrc, portdst)
H ← (cid, sqn)
iv ← get iv(H, κ)
return (pkt info, E (kdst, iv, H, m))
process packets(κ, p1, ..., pv):
(kc, ks, ivc, ivs) ← κ
if this is a client , then src ← c and dst ← s
else src ← s and dst ← c
for each γ ∈ [v]
(Hγ, cγ ) ← pγ
ivγ ← get iv(Hγ, κ)
mγ ← D(ksrc, ivγ, Hγ, cγ )
return (m1, . . . , mv)
Key Agreement consists of one message m6. Speciﬁcally,
S generates new DH values and sends its new public
DH values to the client by running s hello(m3, ik, sqn),
encrypted and authenticated using AEAD with ik.
s hello(m3, ik, sqn):
pub, p˜ubs, stk))
$← Zq−1, ˜ys ← g ˜xs , p˜ubs ← (g, q, ˜ys)
(ikc, iks, ivc, ivs) ← ik
˜xs
H ← (cid, sqn)
e ← E (ikc, (ivc, sqn), H, (scfgt
return (IPs, IPc, ports, portc, H, e)
The client veriﬁes the authenticity of the server’s new DH
public values upon receipt of this packet using ik and both
parties at this point can derive the session key material k by
running get key s(m6) and get key c(m6), which both use
the xtrct xpnd function deﬁned earlier.
get key s(m):
pms ← y ˜xs
return xtrct xpnd(pms, nonc, cid, m, 40, 0)
c
220220
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:06:38 UTC from IEEE Xplore.  Restrictions apply. 
get key c(m):
s
(IPs, IPc, ports, portc, cid, sqn, e) ← m
abort if D(ikc, (ivc, sqn), (cid, sqn), e) = ⊥
pms ← ˜yxc
return xtrct xpnd(pms, nonc, cid, m, 40, 0)
Data Exchange consists of two packet sequences m7
and m8. C and S will use k to encrypt and authenticate
their remaining data M ı+1
, . . . , M w
s ,
respectively, instead of ik for the rest of this session.
c and M j+1
, . . . , M u
Similar to ik, k = (kc, ks, iv) consists of two parts: the
two 128-bit application keys (kc, ks) and the two 4-byte
initialization vector preﬁxes iv = (ivc, ivs). C uses ks
and ivs to encrypt data that it sends to S, while using kc
and ivc to decrypt data received from S, and vice versa.
s
c
B. 0-RTT Connection Establishment
pub
):
, nonc ← (current_timec, r)
If the client C has already had a connection with a server
S in the time period τt, then C does not need to send the
c i hello, but can instead initiate another connection request
with the server via a c hello packet containing the previously
obtained stk and scid, as well as new cid, nonc, and
pubc (which should contain its new DH ephemeral public
value). In this case, the c hello function will be:
c hello(stk, scfgt
$← {0, 1}64
$← {0, 1}160
$← Zq−1, yc ← gxc , pubc
cid
r
xc
pkt info ← (IPc, IPs, portc, ports
return (pkt info, cid, 1, stk, scid, nonc, pubc
Upon receipt of c hello, S veriﬁes that the nonc is fresh
by checking it against its strike-register, that the stk is
valid, and that scid is not unknown or expired. If the
veriﬁcation steps fail, S goes back to the 1-RTT case by
generating and sending the s reject as described in Section
V-A, and then the rest of the protocol is exactly the same
as described in Section V-A. If, however, these veriﬁcation
steps succeed, the rest of the protocol is exactly the same
as in Section V-A, except that the packet sequence numbers
account for the fact that there are two fewer packets.
← (g, q, yc)
)
)
VI. SECURITY MODEL
We formally deﬁne the security model for QC protocols,
which is one of our main technical contributions. Our
model is an extension of the Authenticated and Conﬁdential
Channel Establishment (ACCE) security model for TLS to
accommodate performance-driven protocols that do not run
on top of TCP and have two stages for key agreement and
data exchange. We call our model QACCE for Quick ACCE.
We consider a very strong attacker who can initiate
possibly concurrent rounds of a protocol between various
clients and servers and see the exchanged communication.
Moreover, an attacker can corrupt servers, control clients,
and drop or modify the packets exchanged by the honest
parties. Our deﬁnition targets the major security goal of a
221221
communication protocol: secure channel, which means that
data is exchanged in a private and authentic manner and
cannot be re-ordered. The necessary goal of key security and
(unilateral) authentication is also captured by the deﬁnition.
Furthermore, the model addresses particular attacks such as
IP spooﬁng attacks.
After presenting the formal deﬁnition (with informal
explanations) we discuss the differences from the existing
security models and the reasons for them.
In Section VI-B we explain how our formal model cap-
tures server impersonation attacks, attacks on secure chan-
nel, and such malicious behaviors as eavesdropping, man-in-
the-middle attacks, forgeries, and DDoS attacks (e.g. due to
IP spooﬁng). We also explain the levels of forward secrecy