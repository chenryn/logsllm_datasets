需要注意的是，尽管 exit 函数的参数类型是 int，而 main 函数返回值也是 int 类型，
Linux 不会为返回值保留 32 位长度。实际上，你应该只使用 0 到 127 之间的数值作为退出
代码。大于 128 的退出代码有特殊的含义——当一个进程由于一个信号而结束运行，它的退
出值就是 128 加上信号的值。 
3.4.1 等待进程结束 
如果你输入并且运行了代码列表 3.4 的 fork 和 exec 示例程序，你可能已经发现，ls 程
序的输入很多时候出现在“主程序”结束之后。这是因为子进程，也就是运行 ls 命令的进
程，是相独立于主进程被调度的。因为 Linux 是一个多任务操作系统，两个进程看起来是并
行执行的，而且你无法猜测 ls 程序会在主程序运行之前还是之后获取运行的机会。 
不过，在某些情况下，主程序可能希望暂停运行以等待子进程完成任务。可以通过 wait
族系统调用实现这一功能。这些函数允许你等待一个进程结束运行，并且允许父进程得到子
进程结束的信息。Wait 族系统调用一共有四个函数；通过选择不同的版本，你可以选择从
退出进程得到信息的多少，也可以选择关注某个特定子进程的退出。 
3.4.2 wait 系统调用 
这一族函数中，最简单的是 wait。它会阻塞调用进程，直到某一个子进程退出（或者
出现一个错误）。它通过一个传入的整型指针参数返回一个状态码，从而可以得到子进程的
退出信息。例如，WEXITSTATUS 宏可以提取子进程的退出值。 
你可以用 WIFEXITED 宏从一个子进程的返回状态中检测该进程是正常结束（利用
exit 函数或者从 main 函数返回）还是被没有处理的信号异常终止。对于后一种情况，可
以用 WTERMSIG 宏从中得到结束该进程的信号。 
这里还是 fork 和 exec 示例代码中的 main 函数。这一次，父进程通过调用 wait 等
待子进程（也就是运行 ls 命令的进程）退出。 
  int main () 
  { 
    int child_status; 
    /* 传递给 ls 命令的参数列表 */ 
    char* arg_list[] = { 
      "ls",  /* argv[0], 程序的名称 */ 
      "-l",  
      "/", 
www.AdvancedLinuxProgramming.com 
46
      NULL   /* 参数列表必须以 NULL 结束 */ 
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
    }; 
    /* 产生一个子进程运行 ls 命令。忽略返回的子进程 ID。*/ 
    spawn ("ls", arg_list); 
    /* 等待子进程结束。*/ 
    wait (&child_status); 
    if (WIFEXITED (child_status)) 
      printf ("the child proces exited normally, with exit code 
%d\n",  
              WEXITSTATUS (child_status)); 
    else 
      printf ("the child process exited abnormally\n"); 
    return 0; 
  } 
Linux 还提供了一些相似的系统调用；其中一些更具弹性，而一些提供了与退出的子进
程相关的更多的信息。Wait3 函数可以获取退出进程的 CPU 占用情况，而 wait4 函数允
许你通过更多参数指定等待的进程。 
3.4.3 僵尸进程 
如果一个子进程结束的时候，它的父进程正在调用 wait 函数，子进程会直接消失，而
退出代码则通过 wait 函数传递给父进程。但是，如果子进程结束的时候，父进程并没有调
用 wait，则又会发生什么？它是不是简单地就消失了呢？不，因为如果这样，它退出时返
回的相关信息——譬如它是否正常结束，以及它的退出值——会直接丢失掉。在这种情况下，
子进程死亡的时候会转化为一个僵尸进程。 
一个僵尸进程是一个已经中止而没有被清理的进程。清理僵尸子进程是父进程的责任。
Wait 函数会负责这个清理过程，所以你不必在等待一个子进程之前检测它是否正在运行。
假设，一个进程创建了一个子进程，进行了另外一些计算，然后调用了 wait。如果子进程
还没有结束，这个进程会在 wait 调用中阻塞，直到子进程结束。如果子进程在父进程调用
wait 之前结束，子进程会变成一个僵尸进程。当父进程调用 wait，僵尸子进程的结束状态
被提取出来，子进程被删除，并且 wait 函数立刻返回。 
如果父进程不清理子进程会如何？它们会作为僵尸进程，一直被保留在系统中。代码列
表 3.6 里的程序在产生一个立刻结束的子进程之后然后休眠一分钟退出而不清理子进程。 
代码列表 3.7 （zombie.c）制作一个僵尸进程 
#include  
#include  
#include  
int main () 
{ 
www.AdvancedLinuxProgramming.com 
47
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
  pid_t child_pid; 
  /* 创建一个子进程 */ 
  child_pid = fork (); 
  if (child_pid > 0) { 
    /*这是父进程。休眠一分钟。 */ 
    sleep (60); 
  } 
  else { 
    /*这是子进程。立刻退出。 */ 
    exit (0); 
  } 
  return 0; 
} 
试着把这个程序编译成一个名为 make-zombie 的程序。运行这个程序；在它还在运行
的同时，用下列命令在另外一个窗口列出系统中的进程： 
% ps -e -o pid,ppid,stat,cmd 
该命令会列出进程 ID、父进程 ID、进程状态和进程命令行。观察结果，发现除了父进
程 make-zombie 之外，还有一个 make-zombie 出现在列表中。这是子进程；注意它的父进
程 ID 就是第一个 make-zombie 进程的 ID。子进程被标记为而且它的状态代码为
Z，表示僵尸（Zombie）。 
如果 make-zombie 进程退出而没有调用 wait 会出现什么情况？僵尸进程会停留在系统
中吗？不——试着再次运行 ps，你会发现两个 make-zombie 进程都消失了。当一个程序退
出，它的子进程被一个特殊进程继承，这就是 init 进程。Init 进程总以进程 ID 1 运行（它
是 Linux 启动后运行的第一个进程）。Init 进程会自动清理所有它继承的僵尸进程。 
3.4.4 异步清理子进程 
如果你创建一个子进程只是简单的调用 exec 运行其它程序，在父进程中立刻调用 wait
进行等待并没有什么问题，只是会导致父进程阻塞等待子进程结束。但是，很多时候你希望
在子进程运行的同时，父进程继续并行运行。怎么才能保证能清理已经结束运行的子进程而
不留下任何僵尸进程在系统中浪费资源呢？ 
一种解决方法是让父进程定期调用 wait3 或 wait4 以清理僵尸子进程。在这种情况调
用 wait 并不合适，因为如果没有子进程结束，这个调用会阻塞直到子进程结束为止。然而，
你可以传递 WNOHANG 标志给 wait3 或 wait4 函数作为一个额外的参数。如果设定了这
个标志，这两个函数将会以非阻塞模式运行——如果有结束的子进程，它们会进行清理；否
则会立刻返回。第一种情况下返回值是结束的子进程 ID，否则返回 0。 
另外一种更漂亮的解决方法是当一个子进程结束的时候通知父进程。有很多途径可以做
到这一点；在第五章“进程间通信”介绍了这些方法，不过幸运的是 Linux 利用信号机制替
你完成了这些。当一个子进程结束的时候，Linux 给父进程发送 SIGCHLD 信号。这个信号
的默认处理方式是什么都不做；这也许是为什么之前你忽略了它的原因。 
www.AdvancedLinuxProgramming.com 
48
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
因此，一个简单的清理结束运行的子进程的方法是响应 SIGCHLD 信号。当然，当清
理子进程的时候，如果需要相关信息，一个很重要的工作就是保存进程退出状态，因为一旦
用 wait 清理了进程，就再也无法得到这些信息了。列表 3.7 中就是一个利用 SIGCHLD 信
号处理函数清理子进程的程序代码。 
代码列表 3.7 （sigchld.c）利用 SIGCHLD 处理函数清理子进程 
#include  
#include  
#include  
#include  
sig_atomic_t child_exit_status; 
void clean_up_child_process (int signal_number) 
{ 
  /* 清理子进程。*/ 
  int status; 
  wait (&status); 
  /* 在全局变量中存储子进程的退出代码。*/ 
  child_exit_status = status; 
} 
int main () 
{ 
  /* 用 clean_up_child_process 函数处理 SIGCHLD。*/ 
  struct sigaction sigcihld_action; 
  memset (&sigchld_action, 0, sizeof (sigchld_action)); 
  sigcihld_action.sa_handler = &clean_up_child_process; 
  sigaction (SIGCHLD, &sigchld_action, NULL); 
  /* 现在进行其它工作，包括创建一个子进程。*/ 
  /* ...  */ 
  return 0; 
} 
注意信号处理函数中将进程退出代码保存到了全局变量中，从而可以在主程序中访问
它。因为这个变量在信号处理函数中被赋值，我们将它声明为 sig_atomic_t 类型。 
www.AdvancedLinuxProgramming.com 
49
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
第四章：线程 
线程，不同于进程，是一种允许一个程序同时执行不止一个任务的机制。于进程相似，
不同线程看起来是并行运行的；Linux 核心对它们进行异步调度，不断中断它们的执行以给
其它线程执行的机会。 
概念上，线程出现在进程中。相比进程，线程是一种更细粒度的执行单元。当你调用一
个程序，Linux 创建一个新进程，并且在那个新进程中创建一个线程；这个线程依序执行程
序。这个线程可以创建更多的线程；所有这些线程在同一个进程中执行同一个程序，但是每
个线程在特定时间点上可能分别执行这个程序的不同部分。 
我们已经看到一个进程如何创建新进程。子进程开始时候运行父进程的程序，并且从父
进程处复制了虚拟内存、文件描述符和其它信息。子进程可以修改自己的内存、关闭文件描
述符、执行其它各种操作，但是这些操作不会影响父进程；反之亦然。不过，当一个程序创
建了一个线程时并不会复制任何东西。创建和被创建的线程同先前一样共享内存空间、文件
描述符和其它各种系统资源。例如，当一个线程修改了一个变量的值，随后其它线程就会看
到这个修改过的值。相似的，如果一个线程关闭了一个文件描述符，其它线程也无法从这个
文件描述符进行读或写操作。因为一个进程中所有线程只能执行同一个程序，如果任何一个
线程调用了一个 exec 函数，所有其它线程就此终止（当然，新的程序也可以创建线程）。 
GNU/Linux 实现了 POSIX 标准线程 API（所谓 pthreads）。所有线程函数和数据类型
都在  头文件中声明。这些线程相关的函数没有被包含在 C 标准库中，而是在 
libpthread 中，所以当链接程序的时候需在命令行中加入 -lpthread 以确保能正确链接。 
4.1 创建线程 
进程中的每个线程都以线程 ID 标识。在 C 或 C++ 程序中，线程 ID 被表示为 
pthread_t 类型的值。 
创建线程时，每个线程都开始执行一个线程函数。这只是一个普通的函数，包含了线程
应执行的代码；当函数返回的时候，线程也随之结束。在 GNU/Linux 系统中，线程函数接
受一个 void* 类型的参数，并且返回 void* 类型。这个参数（parameter）被称为线程参数
（thread argument）：GNU/Linux 系统不经查看直接将它传递给线程。你的程序可以利用这
个参数给新线程传递数据。相似的，你的线程可以利用返回值给它的创建者线程返回数据。 
函数 pthread_create 负责创建新线程。你需要给它提供如下信息： 
1、一个指向 pthread_t 类型变量的指针；新线程的线程 ID 将存储在这里。 
2、一个指向线程属性（thread attribute）对象的指针。这个对象控制着新线程与程序其
它部分交互的具体细节。如果传递 NULL 作为线程属性，新线程将被赋予一组默认线程属
性。线程属性在 4.1.5 节“线程属性”中有更多讨论。 
3、一个指向线程函数的指针。这是一个普通的函数指针，类型如下： 
void* (*) (void*) 
4、一个线程参数，类型 void*。不论你传递什么值作为这个参数，当线程开始执行的
时候，它都会被直接传递给新的线程。 
函数 pthread_create 会在调用后立刻返回，原线程会继续执行之后的指令。同时，新
线程开始执行线程函数。Linux 异步调度这两个线程，因此你的程序不能依赖两个线程得到
执行的特定先后顺序。 
www.AdvancedLinuxProgramming.com 
50
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
列 表  4.1 中 的 程 序 创 建 一 个 不 断 输 出  x 到 标 准 错 误 输 出 的 线 程 。 在 执 行 