of gray-box fuzzing by up to an order of magnitude.
6.4 Coverage-Guided Kernel Fuzzers
A project called syzkaller was released by Vyukov; it
is the ﬁrst publicly available gray-box coverage-guided
kernel fuzzer [10]. Nossum and Casanovas demonstrate
that most Linux ﬁle system drivers are vulnerable to
feedback-driven fuzzing by using an adapted version of
AFL [34]. This modiﬁed AFL version is based on glue
code to the kernel consisting of a driver interface to
USENIX Association
26th USENIX Security Symposium    179
measure feedback during fuzzing ﬁle system drivers of
the kernel and expose this data to the user space. This
fuzzer runs inside the targeted OS; a crash terminates the
fuzzing session.
In 2016, Hertz and Newsham released a modiﬁed ver-
sion of AFL called TriforceAFL [7]. Their work is based
on a modiﬁcation of QEMU and utilizes the correspond-
ing emulation backend to measure fuzzing progress by
determining the current instruction pointer after a control
ﬂow altering instruction has been executed.
In theory,
their fuzzer is able to fuzz any OS emulated in QEMU. In
practice, the TriforceAFL fuzzer is limited to operating
systems that are able to boot from read-only ﬁle systems,
which narrows down the candidates to classic UNIX-like
operating systems such as Linux, FreeBSD, NetBSD, or
OpenBSD. Therefore, TriforceAFL is currently not able
to fuzz closed-source operating systems such as macOS
or Windows.
7 Discussion
Even though our approach is general, fast and mostly in-
dependent of the underlying OS, there are some limita-
tions we want to discuss in this section.
OS-Speciﬁc Code. We use a small amount (usually
less than 150 lines) of OS-dependent ring 3 code that per-
forms three tasks. First, it interacts with the OS to trans-
late the inputs from the fuzzing engine to interactions
with the OS (e.g., mount the data as a partition). Second,
it obtains the address of the crash handler of the OS such
that we can detect crashes faster than it would take to
wait for the timeout. Third, it can return the addresses of
certain drivers. These addresses can be used to limit trac-
ing to the activity of said drivers, which improves perfor-
mance when only fuzzing individual drivers.
None of these functions are necessary and only im-
prove performance in some cases. The ﬁrst use case
can be avoided by using generic syscall fuzzing. In that
case a single standard C program which does not use any
platform-speciﬁc API would sufﬁce to trigger sysenter/
syscall instructions. We do not strictly need the address
of the crash handler, since there are numerous other ways
to detect whether the VM crashed. It would also be quite
easy to obtain crash handlers dynamically by introduc-
ing faults and analyzing the obtained traces. Finally, we
can always trace the whole kernel, taking a slight perfor-
mance hit (mostly introduced by the increased amount of
non-determinism). In cases such as syscall fuzzing, we
need to trace the whole kernel, therefore syscall fuzzing
would not be impacted if this ability was missing.
In
summary, this is the ﬁrst approach that can fuzz arbitrary
x86-64 kernels without any customization and a near-
native performance.
Supported CPUs. Due to the usage of Intel PT and
Intel VT-x, our approach is limited to certain Intel CPUs
supporting these extensions. Virtually all modern Intel
CPUs support Intel VT-x. Unfortunately, Intel is rather
vague as to which CPUs exactly support process trace
inside of VMs and various other extensions (such as IP
ﬁltering and multi-entry ToPA). We tested our system
on the following CPU models: Intel Core i5-6500, In-
tel Core i7-6700HQ, and Intel Core i5-6600. We believe
that at the time of writing, most Skylake and Kabylake
CPUs have the necessary hardware support.
Just-In-Time Code.
Intel PT does not provide a com-
plete list of executed instruction pointers. Instead, Intel
PT generates as little information as necessary to reduce
the amount of data produced by the processor. Con-
sequently, the Intel PT software decoder does not only
require control ﬂow information to reconstruct the con-
trol ﬂow but also needs the program that was executed
during tracing. If the program is modiﬁed during run-
time, as often done by just-in-time (JIT) compilers in
user and kernel mode, the decoder is unable to exactly
restore the runtime control ﬂow. To bypass this limita-
tion, the decoder requires information about all modi-
ﬁcations applied to the program instead of an ordinary
memory dump or the executable ﬁle. As Deng et al. [18]
have shown, this is possible by making use of EPT viola-
tions when executing written pages. Another, somewhat
more old-fashioned, method to achieve the same is to use
shadow page tables [19]. Once one it is possible to hook
the execution of modiﬁed code, self-modifying code can
be dumped. Reimplementing this technique was out of
the scope of this work. It should be noted though that
fuzzing kernel JIT code is a very interesting topic since
kernel JIT components, such as the BPF JIT in Linux,
have often been part of serious vulnerabilities.
Multibyte Compares. Similar to AFL, we are unable
to effectively bypass checks for large magic values in
the inputs. However, we support specifying dictionaries
of interesting constants to improve performance if such
magic values are known in advance (e.g., from RFCs,
source code, or disassembly). Some solutions involving
techniques such as concolic execution (e.g., Driller [37])
or taint tracking (e.g., Vuzzer [35]) have been proposed.
However, none of these techniques can easily be adapted
to closed-source operating system kernels. Therefore it
remains an open research problem how to deal with those
situations on the kernel level.
Ring 3 Fuzzing. We only demonstrated this technique
against kernel-level code. However, the exact same tech-
nique can be used to fuzz closed-source ring 3 code as
180    26th USENIX Security Symposium
USENIX Association
well. Since our approach has a very modest tracing over-
head, we expect that this technique will outperform cur-
rent dynamic binary instrumentation based techniques
for feedback fuzzing of closed-source ring 3 programs
such as winAFL [20].
8 Conclusion
The latest generation of feedback-driven fuzzing meth-
ods has proven to be an effective approach to ﬁnd vul-
nerabilities in an automated and comprehensive fashion.
Recent work has also demonstrated that such techniques
can be applied to kernel space. While previous feedback-
driven kernel fuzzers were able to ﬁnd a large amount of
security ﬂaws in certain operating systems, their beneﬁt
was either limited by poor performance due to CPU emu-
lation or a lack of portability due to the need for compile-
time instrumentations.
In this paper, we presented a novel mechanism to uti-
lize the latest CPU features for a feedback-driven kernel
fuzzer. As shown in the evaluation, combining all com-
ponents provides the ability to apply kernel fuzz testing
to any target OS with signiﬁcantly better performance
than the alternative approaches.
Acknowledgment
This work was supported by the German Federal
Ministry of Education and Research (BMBF Grant
16KIS0592K HWSec). We would like to thank our shep-
herd Suman Jana for his support in ﬁnalizing this paper
and the anonymous reviewers for their constructive and
valuable comments. Furthermore, we would also like
to thank Ralf Spenneberg and Hendrik Schwartke from
OpenSource Security for supporting this research. Fi-
nally, we would like to thank Ali Abbasi, Tim Blazytko,
Teemu Rytilahti and Christine Utz for their valuable
feedback.
References
[1] Announcing oss-fuzz: Continuous fuzzing for
https://testing.
open source software.
googleblog.com/2016/12/announcing-oss-
fuzz-continuous-fuzzing.html.
2017-06-29.
Accessed:
[2] Capstone disassembly framework. http://www.
capstone-engine.org/. Accessed: 2017-06-29.
[3] A general-purpose fuzzer. https://github.com/
aoh/radamsa. Accessed: 2017-06-29.
[4] Intel Processor Trace Decoder Library.
//github.com/01org/processor-trace.
cessed: 2017-06-29.
https:
Ac-
[5] Linux 4.8,
perf Documentation.
https:
//git.kernel.org/cgit/linux/kernel/
git/torvalds/linux.git/plain/tools/perf/
Documentation/intel-pt.txt?id=refs/tags/
v4.8. Accessed: 2017-06-29.
[6] Peach.
http://www.peachfuzzer.com/. Ac-
cessed: 2017-06-29.
[7] Project Triforce:
Run AFL on Everything!
https://www.nccgroup.trust/us/about-
us/newsroom-and-events/blog/2016/june/
project-triforce-run-afl-on-everything/.
Accessed: 2017-06-29.
[8] Security oriented fuzzer with powerful analysis op-
tions. https://github.com/google/honggfuzz.
Accessed: 2017-06-29.
[9] Sulley. https://github.com/OpenRCE/sulley.
Accessed: 2017-06-29.
[10] syzkaller: Linux syscall fuzzer. https://github.
com/google/syzkaller. Accessed: 2017-06-29.
[11] Trinity: Linux system call
fuzzer.
//github.com/kernelslacker/trinity.
cessed: 2017-06-29.
https:
Ac-
[12] zzuf.
https://github.com/samhocevar/zzuf.
Accessed: 2017-06-29.
[13] O. Bastani, R. Sharma, A. Aiken, and P. Liang.
In ACM
Synthesizing program input grammars.
SIGPLAN Conference on Programming Language
Design and Implementation (PLDI), 2017.
[14] M. Böhme, V.-T. Pham, and A. Roychoudhury.
Coverage-based greybox fuzzing as markov chain.
In ACM Conference on Computer and Communica-
tions Security (CCS), 2016.
[15] C. Cadar, D. Dunbar, and D. R. Engler. Klee: Unas-
sisted and automatic generation of high-coverage
tests for complex systems programs. In Symposium
on Operating Systems Design and Implementation
(OSDI), 2008.
[16] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brum-
ley. Unleashing Mayhem on Binary Code. In IEEE
Symposium on Security and Privacy, 2012.
[17] S. K. Cha, M. Woo, and D. Brumley. Program-
adaptive mutational fuzzing. In IEEE Symposium
on Security and Privacy, 2015.
[18] Z. Deng, X. Zhang, and D. Xu. Spider: Stealthy
binary program instrumentation and debugging via
hardware virtualization. In Annual Computer Secu-
rity Applications Conference (ACSAC), 2013.
USENIX Association
26th USENIX Security Symposium    181
[19] A. Dinaburg, P. Royal, M. Sharif, and W. Lee.
Ether: malware analysis via hardware virtualization
extensions. In ACM Conference on Computer and
Communications Security (CCS), 2008.
[33] D. Molnar, X. C. Li, and D. Wagner. Dynamic
Test Generation to Find Integer Bugs in x86 Binary
Linux Programs. In USENIX Security Symposium,
2009.
[34] V. Nossum and Q. Casasnovas. Filesystem Fuzzing
with American Fuzzy Lop. Vault 2016, 2016.
[35] S. Rawat, V. Jain, A. Kumar, L. Cojocar, C. Giuf-
frida, and H. Bos. Vuzzer: Application-aware evo-
lutionary fuzzing. In Symposium on Network and
Distributed System Security (NDSS), 2017.
[36] A. Rebert, S. K. Cha, T. Avgerinos, J. M. Foote,
D. Warren, G. Grieco, and D. Brumley. Optimiz-
ing seed selection for fuzzing. In USENIX Security
Symposium, 2014.
[37] N. Stephens, J. Grosen, C. Salls, A. Dutcher,
R. Wang,
J. Corbetta, Y. Shoshitaishvili,
C. Kruegel, and G. Vigna. Driller: Augment-
ing fuzzing through selective symbolic execution.
In Symposium on Network and Distributed System
Security (NDSS), 2016.
[38] J. Viide, A. Helin, M. Laakso, P. Pietikäinen,
M. Seppänen, K. Halunen, R. Puuperä, and J. Rön-
ing. Experiences with model inference assisted
fuzzing. In USENIX Workshop on Offensive Tech-
nologies (WOOT), 2008.
[39] T. Wang, T. Wei, G. Gu, and W. Zou. TaintScope:
A checksum-aware directed fuzzing tool for auto-
In IEEE
matic software vulnerability detection.
Symposium on Security and Privacy, 2010.
[40] M. Woo, S. K. Cha, S. Gottlieb, and D. Brumley.
Scheduling black-box mutational fuzzing. In ACM
Conference on Computer and Communications Se-
curity (CCS), 2013.
[20] Fratric,
Ivan. WinAFL: A fork of AFL for
fuzzing Windows binaries. https://github.com/
ivanfratric/winafl, 2017.
[21] V. Ganesh, T. Leek, and M. Rinard. Taint-based
In International Con-
directed whitebox fuzzing.
ference on Software Engineering (ICSE), 2009.
[22] P. Godefroid, N. Klarlund, and K. Sen. DART: Di-
rected Automated Random Testing. In ACM SIG-
PLAN Conference on Programming Language De-
sign and Implementation (PLDI), 2005.
[23] P. Godefroid, M. Y. Levin, and D. Molnar. SAGE:
Whitebox Fuzzing for Security Testing. Queue,
10(1):20, 2012.
[24] P. Godefroid, H. Peleg, and R. Singh. Learn&fuzz:
Machine learning for input fuzzing. Technical re-
port, January 2017.
[25] P. Goodman.
Shin GRR: Make Fuzzing Fast
Again. https://blog.trailofbits.com/2016/
11/02/shin-grr-make-fuzzing-fast-again/.
Accessed: 2017-06-29.
[26] I. Haller, A. Slowinska, M. Neugschwandtner, and
H. Bos. Dowsing for overﬂows: A guided fuzzer to
ﬁnd buffer boundary violations. In USENIX Secu-
rity Symposium, 2013.
[27] C. Holler, K. Herzig, and A. Zeller. Fuzzing with
code fragments. In USENIX Security Symposium,
2012.
[28] Intel.
Intel® 64 and IA-32 Architectures Soft-
ware Developer’s Manual (Order number: 325384-
058US, April 2016).
[29] A. Kleen.
simple-pt: Simple Intel CPU pro-
cessor tracing on Linux. https://github.com/
andikleen/simple-pt.
[30] A. Kleen and B. Strong. Intel Processor Trace on
Linux. Tracing Summit 2015, 2015.
[31] Microsoft.
FSCTL_DISMOUNT_VOLUME.
https://msdn.microsoft.com/en-us/
library/windows/desktop/aa364562(v=
vs.85).aspx, 2017.
[32] Microsoft.
VHD Reference.
//msdn.microsoft.com/en-us/library/
windows/desktop/dd323700(v=vs.85).aspx,
2017.
https:
182    26th USENIX Security Symposium
USENIX Association