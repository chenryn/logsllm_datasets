mediate access in bus architectures by enforcing (one or
multiple of) non-interference, access control, priority, and
fairness between the cores.
Table 3 shows the code size for the biggest synthesized design
in each experiment set. These numbers are reported in terms of
lines of code written in VeriSketch language for the sketch and
specification (i.e., the formal testbench) and in Verilog and AST
for the synthesized code. We will first explain the implementation
details of the framework and then discuss the synthesized designs.
6.1 Implementation
As shown in Fig. 1 and Algorithm 1 VeriSketch flow consists of
an IFT engine and a program synthesis unit. The IFT tool uses the
Yosys [49] front-end parser to get the AST representation of the
Verilog design. It then analyzes the design’s data and control graph
along with the security properties to generate the corresponding
information flow tracking logic. It writes back the instrumented
design in Verilog. The instrumented Verilog design is then given to
the synthesis unit to search for the ideal parameter. The program
synthesis unit makes calls to a SAT/SMT solver for verification, ex-
ploration, and synthesis. This unit can either use a commercial EDA
tool (Questa Formal Tool from Mentor Graphics) or open source
solvers (Any of Yices2 [14], Boolector [8], Z3 [12], or CVC4 [5]) by
using Yosys to translate Verilog to SMT-LIB2 representation.
6.2 Constant Time Arithmetic Units
The Verilog language supports multiplication and division opera-
tors; however, these operators cannot be directly mapped to hard-
ware by EDA tools due to their complexity. For instance the state-
ment “assign c=a\b;" requires the EDA tool to build a divider
Figure 4: Synthesizing a constant time fixed point divider using VeriSketch. (a) Sketch of a shift-and-subtract divider where
the structure of the procedural statements, operations, and constant values are left unspecified as shown by the highlighted
code. Constant time and functional properties are modeled by IFT and built-in Verilog operators, respectively. (b) The divider
unit generated by VeriSketch. The highlighted parts show the code that is generated automatically.
which runs in a single cycle. As this is not feasible in most cases,
the complex operations can only be used in simulation and the
hardware designers need to implement arithmetic units using low
level operators. These arithmetic units run in multiple cycles and
could have early termination based on the operands’ values which
leaks information about the values. We use VeriSketch to design
fixed point multiplier and divider units which run in constant time
independent of their operands’ values.
Sketches and Properties. We sketch a shift-and-add multiplication
unit and a shift-and-subtract division unit for fixed point computa-
tion as described in [1]. The sketch of the divider unit along with
the functional and security properties are shown in Fig. 4(a). We
leave the structure of the procedural statements undefined using
“?=” construct and ask the synthesizer to find the correct control
logic and cycle-level register updates using the list of the control
variables in the design (start,done,count_done and flag). Here,
start and done indicate the beginning and end of the computation
while count_done shows that the counter has reached its maximum
value. Variable flag is defined in the sketch. For simplicity, control
signals ctrl_vars are globally defined for all assignments. We also
use low-level sketch constructs to leave operations and constant
values undefined. The first assertion in Fig. 4(a) describes constant
time requirements using IFT operators. The second property states
that the quotient computed by the sequential circuit should differ
from the value computed by the built-in operations by at most one
bit. This error value is equivalent to 2−Q where Q is the number
of bits used to represent the fractional segment. The dividend is
shifted by Q bits to follow the fixed point representation.
Synthesized Designs. The divider unit synthesized by VeriSketch
is shown in Fig. 4(b). VeriSketch finds the appropriate control sig-
nal to guard execution of the procedural statements as shown by
the if statements. The last statement ensures that the final output
quotient is updated at a constant time, even though the intermedi-
ate variable reg_q may contain the final result sooner. This example
shows how the IFT unit safely downgrades timing variations ( Eq. 3)
from reg_q to quotient since count_done fully controls timing of
the updates to the quotient. We skip reporting the details of the
synthesized multiplier as it is similar to the divider.
Figure 5: VeriSketch synthesizes the sketch from Fig. 2(a) to
a fully specified Verilog design that meets the functional and
security properties specified in Example 5.4.
6.3 Leakage-Free Cache
We use VeriSketch to modify an existing (non-secure) cache im-
plementation such that it defends against timing attacks. We de-
fine sketch and properties for this set of experiments as shown in
Fig. 2(a) and Example 5.4 for both a direct mapped and a 4-way set
associative cache (with the difference that the direct mapped cache
does not require LRU logic). Fig. 5 shows the output of VeriSketch
Synthesizing a fully specified and functional Verilog design. We
only show the parts of the code that is automatically generated. The
synthesized skip logic indicates that when a read or write request
result in a cache miss, it should skip the cache and go through
direct memory access if the block to be evicted is locked. The cache
design created by VeriSketch does not update the LRU state when
a locked cache block is accessed, and hence eliminates the timing
leakage in the original PLCache. Note that as the comb syntax is
mapped to a BDD, it generates logic for certain input combinations
that do not occur in execution (e.g., having both a read and write
request). Using Yices2 [14] as the SMT solver, the synthesis process
takes around six and eight hours for the direct mapped and set
associative caches, respectively. The synthesis time in this set of
experiments are considerably longer compared to the ones reported
in the rest of the examples and are dominated by the time taken to
perform bounded model checking in the verification rounds. This
module div (clk, start, dividend, divisor, quotient, done, overflow);  assign flag = reg_a (>=,>,) reg_b;   always @(posedge clk) begin   if( done && start)      //initialize …   reg_q[reg_count] ?= ??;   reg_b ?= reg_b(>>, >>) ??;    reg_a ?= reg_a - reg_b;   quotient ?= reg_q;   ctrl_vars = [start, done, count_done, flag];   //counter, overflow and sign logic … assert (dividend, divisor -/->t quotient); assert (done && divisor!=0 |->(|quotient-((dividend = reg_b;  always @(posedge clk) begin   if(done && start)      //initialize …   if(!reg_done && !count_done && (reg_a >= reg_b))     reg_q [reg_count] = reg_b))     reg_a <= reg_a - reg_b;   if (!start & !done & count_done)     quotient <= reg_q;   //counter, overflow and sign logic … endmodule  (a)(b)module Sketch_Cache(…); assign skip =   (!rd & wr & !hit & lru_block[m])| (rd & !wr & !hit & lru_block[m])   |(!rd & !wr & hit & lru_block[m])|(!rd & !wr & !hit & lru_block[m])|    (!rd & !wr & hit & !lru_block[m]);  assign lru_update =    (rd & !wr & waiting & stall & !lock)|(rd & !wr & waiting & !stall & !lock)|   (rd & !wr & !waiting & stall  & !lock)|(rd & !wr & !waiting & !stall & !lock)|   (!rd & wr & waiting  & !stall & !lock)|(!rd & wr & !waiting & stall  & !lock)|   (rd & wr  & waiting  & !stall & lock) |(rd & wr  & waiting  & !stall & !lock)|   (rd & wr  & !waiting & !stall & lock ); always @ (posedge clk)  if(!skip)   //cache rd/wr       if(lru_update)     //update LRU  else   //direct memory accessendmoduleis due to the fact that formally verifying and reasoning about mem-
ory elements take large amount of time. This can be alleviated by
abstracting the unrelated data path or giving hints to the solver on
what the relevant variables are. We leave this problem for future
work.
Security Analysis of Sketch Cache vs. PLCache. The PLCache
6.3.1
is resilient against the original Percival attack as the victim’s access
to its preloaded data results in a cache hit and does not evict the
attacker’s data. However, accessing preloaded data changes the LRU
bits of that cache set. More specifically, accessing the preloaded data
marks the locked block as the most recently used block in the set;
and it prioritizes other blocks in the set for eviction. Consequently,
even though accessing locked data does not evict the attacker’s data
directly, it prioritizes eviction of the attacker’s data. In order to exploit
this subtle change in the state of the cache, we extend the Percival
attack such that the adversary can observe the effect of the change
in the LRU bits. This is done by adding an extra stage to the attack
where the attacker tries to evict its own data. If the attacker is
able to evict its data (i.e., the attacker observes an increased access
time in the next access), it indicates that the attacker’s data has
been prioritized for eviction as a result of the victim’s action. The
Percival attack is extended as suggested by the counterexample
trace collected while verifying the PLCache.
the least recently used block is locked and cannot be evicted. The
adversary is able to observe the difference in victim’s action from
stage 3 at stage 5 through timing variation. In case (a) the adversary
experiences a cache miss (i.e., increased cache access time) while
in case (b) adversary’s access results in a cache hit. This difference
is shown in the value of the stall signal in simulation. The IFT
instrumentation shows a high value for rd_proc_t at stage 5 of
Fig. 6(a) which is a violation of the security property specified in
Example 5.4. VeriSketch synthesizer mitigates this vulnerability
by generating the lru_update logic such that accessing locked
blocks does not change the LRU bits (and any other hardware state).
Results of simulating the synthesized cache by the same traces are
available in Appendix B.
Soft Constraint Analysis. As described in Section 5.3, per-
6.3.2
formance related soft constraints are essential for synthesizing
a practical cache. In order to analyze the effect, we simulate the
caches which are synthesized with and without soft constraints
using memory traces from the CloudSuite benchmarks [19]. Fig. 7
shows cache misses for simulating 4-way set associative caches of
size 32KB with one million memory traces for each application. All
numbers are normalized to the number of misses for a non-secure
cache of the same size. As shown by the graph, the cache which
is synthesized with soft constraints has a considerable lower miss
rate.
Figure 6: Timing leakage in PLCache. (a) Victim process
(pid=1) accesses its locked data in stage 3. This results in a
cache miss for the attacker in stage 5 (shown by stall=1).
The verification tool captures this since rd_proc_t has a Hiдh
value in stage 5. (b) Victim does not access its locked data in
stage 3 and the attacker observes a cache hit in stage 5.
Fig. 6 shows the results of simulating the PLCache with simu-
lation traces that resemble the extended Percival attack. In both
Fig. 6(a) and (b) the victim process first preloads and locks its data
(stage 1). Next, the adversary fills the cache set, but fails to evict the
locked block (stage 2). Fig. 6(a) represents the case where the victim
accesses its locked data at stage 3 making the locked data the most
recently used block and the attacker’s data the least recently used
block. Fig. 6(b) represent the case where the victim accesses some
other cache set and leaves the LRU bits unmodified (i.e., the locked
block remains the least recently used block). In stage 4, the adver-
sary aims to observe the change in the LRU bits by trying to evict
the its own data that was used to fill cache in stage 2. In case (a),
adversary’s access to the cache set evicts its own data since victim’s
action from stage 3 has prioritized eviction of the attacker’s data.
In case (b), the attacker’s access to the cache is skipped because
Figure 7: Number of cache misses for caches synthesized
with and without soft constraints simulated with memory
traces from CloudSuite benchmarks [19]. The numbers are
normalized to the number of cache misses from a non-
secure cache.
6.4 Hardware Thread Scheduler
Here we describe design of a hardware thread scheduler module
for fine-grained multithreading in mixed criticality systems [9].
The design problem is borrowed from the FlexPRET project [55]
which implements a processor dedicated to real time needs. We
have expanded the scheduler design by introducing confidentiality
requirements and automatically generating different modifications
of it. The scheduler decides which hardware thread should execute
at each clock cycle based on inputs from the operating system. These
inputs consists of two vectors freq and mode. freq specifies the
expected execution frequency for the threads, and mode describes
//(1) Victim preloading sensitive addresses pid=1, lock=1, addr=0x801, addr_s=0x0,stall=1, rd_proc_t=0
pid=1, lock=1, addr=0x801, addr_s=0x0, stall=0, rd_proc_t=0
//(2) Adversary ﬁlling the cache block pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=0, rd_proc_t=0
pid=0, lock=0, addr=0xE01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xE01, addr_s=0x0, stall=0, rd_proc_t=0
pid=0, lock=0, addr=0xF01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xF01, addr_s=0x0, stall=0, rd_proc_t=0
//(3) Victim accessing preloaded data pid=1, lock=1, addr=0x801, addr_s=0xFFFF, stall=0, rd_proc_t= 0xFFFF
//(4) Adversary actions exposing the eﬀect of the LRU bits  pid=0, lock=0, addr=0xF81, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xF81, addr_s=0x0,  stall=0, rd_proc_t=0
//(5) Adversary getting a cache miss pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=1, rd_proc_t=0x0
pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=0, rd_proc_t= 0xFFFF//(1) Victim preloading sensitive addresses pid=1, lock=1, addr=0x801, addr_s=0x0, stall=1, rd_proc_t=0
pid=1, lock=1, addr=0x801, addr_s=0x0, stall=0, rd_proc_t=0
//(2) Adversary ﬁlling the cache block pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=0, rd_proc_t=0
pid=0, lock=0, addr=0xE01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xE01, addr_s=0x0, stall=0, rd_proc_t=0
pid=0, lock=0, addr=0xF01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xF01, addr_s=0x0, stall=0, rd_proc_t=0
//(3) Victim accessing another cache set pid=1, lock=0, addr=0x802, addr_s= 0x0, stall=0,rd_proc_t= 0x0
//(4) Adversary actions exposing the eﬀect of the LRU bits pid=0, lock=0, addr=0xF81, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xF81, addr_s=0x0, stall=0, rd_proc_t=0
//(5) Adversary getting a cache hit pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=0, rd_proc_t=0x0
(a)(b)Normalized number of cache misses0.911.11.21.31.41.51.61.71.8SAT Solver Data Serving Map Reduce-cMap Reduce-wMedia StreamingTPCC DB2TPCC OracleWeb FrontendWeb SearchSynthesized With Soft ConstraintsSynthesized Without Soft ConstraintsTable 4: Summary of synthesized thread schedulers.
Table 5: Summary of synthesized SoC Arbiters.
Sketch
Size
72bits
192bits
232bits
Prop.
V G C
V G P
V G C P
V G C
V G P
V G C P
V G C
V G P
V G C P
Time(sec.)[Syn., Ver., Exp.]
-
F
E
9, 3, -
7, 4, -
9, 3, -
50, 12, -
114, 18, -
105, 20, -
185, 17, -
357, 20, -
412, 23, -
11, 5, 2
13, 4, 3
12, 4, 2
175, 17, 14
140, 19, 11