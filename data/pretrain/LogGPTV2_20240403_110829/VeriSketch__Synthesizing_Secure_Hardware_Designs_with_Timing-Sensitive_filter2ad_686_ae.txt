### Mediating Access in Bus Architectures
Mediate access in bus architectures by enforcing one or more of the following: non-interference, access control, priority, and fairness between the cores.

### Code Size for Synthesized Designs
Table 3 presents the code size for the largest synthesized design in each experimental set. These values are reported in terms of lines of code written in VeriSketch language for the sketch and specification (i.e., the formal testbench) and in Verilog and Abstract Syntax Tree (AST) for the synthesized code. We will first explain the implementation details of the framework and then discuss the synthesized designs.

#### 6.1 Implementation
As shown in Fig. 1 and Algorithm 1, the VeriSketch flow consists of an Information Flow Tracking (IFT) engine and a program synthesis unit. The IFT tool uses the Yosys [49] front-end parser to obtain the AST representation of the Verilog design. It then analyzes the designâ€™s data and control graph along with the security properties to generate the corresponding information flow tracking logic. The instrumented design is written back in Verilog. The instrumented Verilog design is then given to the synthesis unit to search for the ideal parameters. The program synthesis unit makes calls to a SAT/SMT solver for verification, exploration, and synthesis. This unit can either use a commercial EDA tool (Questa Formal Tool from Mentor Graphics) or open-source solvers (Yices2 [14], Boolector [8], Z3 [12], or CVC4 [5]) by using Yosys to translate Verilog to SMT-LIB2 representation.

#### 6.2 Constant Time Arithmetic Units
The Verilog language supports multiplication and division operators; however, these operators cannot be directly mapped to hardware by EDA tools due to their complexity. For example, the statement `assign c = a / b;` requires the EDA tool to build a divider that runs in a single cycle, which is often not feasible. As a result, complex operations can only be used in simulation, and hardware designers need to implement arithmetic units using low-level operators. These arithmetic units run in multiple cycles and may have early termination based on the operands' values, which can leak information about the values. We use VeriSketch to design fixed-point multiplier and divider units that run in constant time, independent of their operands' values.

**Sketches and Properties:**
We sketch a shift-and-add multiplication unit and a shift-and-subtract division unit for fixed-point computation as described in [1]. The sketch of the divider unit, along with the functional and security properties, is shown in Fig. 4(a). We leave the structure of the procedural statements undefined using the `?=` construct and ask the synthesizer to find the correct control logic and cycle-level register updates using the list of control variables in the design (start, done, count_done, and flag). Here, start and done indicate the beginning and end of the computation, while count_done shows that the counter has reached its maximum value. Variable flag is defined in the sketch. For simplicity, control signals (ctrl_vars) are globally defined for all assignments. We also use low-level sketch constructs to leave operations and constant values undefined. The first assertion in Fig. 4(a) describes the constant time requirements using IFT operators. The second property states that the quotient computed by the sequential circuit should differ from the value computed by the built-in operations by at most one bit. This error value is equivalent to \(2^{-Q}\), where \(Q\) is the number of bits used to represent the fractional segment. The dividend is shifted by \(Q\) bits to follow the fixed-point representation.

**Synthesized Designs:**
The divider unit synthesized by VeriSketch is shown in Fig. 4(b). VeriSketch finds the appropriate control signal to guard the execution of the procedural statements, as shown by the if statements. The last statement ensures that the final output quotient is updated at a constant time, even though the intermediate variable reg_q may contain the final result sooner. This example demonstrates how the IFT unit safely downgrades timing variations (Eq. 3) from reg_q to quotient since count_done fully controls the timing of the updates to the quotient. We skip reporting the details of the synthesized multiplier as it is similar to the divider.

#### 6.3 Leakage-Free Cache
We use VeriSketch to modify an existing (non-secure) cache implementation to defend against timing attacks. We define sketches and properties for this set of experiments as shown in Fig. 2(a) and Example 5.4 for both a direct-mapped and a 4-way set associative cache (with the difference that the direct-mapped cache does not require LRU logic). Fig. 5 shows the output of VeriSketch, synthesizing a fully specified and functional Verilog design. We only show the parts of the code that are automatically generated. The synthesized skip logic indicates that when a read or write request results in a cache miss, it should skip the cache and go through direct memory access if the block to be evicted is locked. The cache design created by VeriSketch does not update the LRU state when a locked cache block is accessed, thus eliminating the timing leakage in the original PLCache. Note that as the comb syntax is mapped to a Binary Decision Diagram (BDD), it generates logic for certain input combinations that do not occur in execution (e.g., having both a read and write request). Using Yices2 [14] as the SMT solver, the synthesis process takes around six and eight hours for the direct-mapped and set associative caches, respectively. The synthesis time in this set of experiments is considerably longer compared to the ones reported in the rest of the examples and is dominated by the time taken to perform bounded model checking in the verification rounds. This is due to the fact that formally verifying and reasoning about memory elements take a large amount of time. This can be alleviated by abstracting the unrelated data path or giving hints to the solver on what the relevant variables are. We leave this problem for future work.

**Security Analysis of Sketch Cache vs. PLCache:**
The PLCache is resilient against the original Percival attack as the victim's access to its preloaded data results in a cache hit and does not evict the attacker's data. However, accessing preloaded data changes the LRU bits of that cache set. Specifically, accessing the preloaded data marks the locked block as the most recently used block in the set and prioritizes other blocks in the set for eviction. Consequently, even though accessing locked data does not directly evict the attacker's data, it prioritizes the eviction of the attacker's data. To exploit this subtle change in the state of the cache, we extend the Percival attack such that the adversary can observe the effect of the change in the LRU bits. This is done by adding an extra stage to the attack where the attacker tries to evict its own data. If the attacker is able to evict its data (i.e., the attacker observes an increased access time in the next access), it indicates that the attacker's data has been prioritized for eviction as a result of the victim's action. The Percival attack is extended as suggested by the counterexample trace collected while verifying the PLCache.

**Soft Constraint Analysis:**
As described in Section 5.3, performance-related soft constraints are essential for synthesizing a practical cache. To analyze the effect, we simulate the caches synthesized with and without soft constraints using memory traces from the CloudSuite benchmarks [19]. Fig. 7 shows cache misses for simulating 4-way set associative caches of size 32KB with one million memory traces for each application. All numbers are normalized to the number of misses for a non-secure cache of the same size. As shown by the graph, the cache synthesized with soft constraints has a considerably lower miss rate.

#### 6.4 Hardware Thread Scheduler
Here, we describe the design of a hardware thread scheduler module for fine-grained multithreading in mixed-criticality systems [9]. The design problem is borrowed from the FlexPRET project [55], which implements a processor dedicated to real-time needs. We have expanded the scheduler design by introducing confidentiality requirements and automatically generating different modifications of it. The scheduler decides which hardware thread should execute at each clock cycle based on inputs from the operating system. These inputs consist of two vectors: freq and mode. The freq vector specifies the expected execution frequency for the threads, and the mode vector describes the criticality level of the threads.

**Summary of Synthesized Thread Schedulers:**
Table 4 summarizes the synthesized thread schedulers, including the sketch size, properties, and synthesis times.

**Summary of Synthesized SoC Arbiters:**
Table 5 summarizes the synthesized SoC arbiters, including the sketch size, properties, and synthesis times.