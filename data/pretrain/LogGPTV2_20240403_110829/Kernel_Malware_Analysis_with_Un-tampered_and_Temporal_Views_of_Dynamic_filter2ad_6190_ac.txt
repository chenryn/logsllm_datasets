### 3.5 动态内核对象识别与类型推导

在运行时，通过分配调用点（如表中的"Call Site"列所示）来识别内核对象。利用静态分析，这些信息被转换为数据类型（如表中的"Data Type"列所示），通过遍历分配代码和指针变量或函数的声明（如表中的"Declaration"列所示）。"Case"列展示了第3.2节中描述的分配代码模式类型。"#Objects"列表示了每种类型的已识别对象数量。在该实例中，LiveDM总共识别出29,488个动态内核对象，这些对象的数据类型是从231个分配代码位置推导出来的。

为了评估识别出的内核对象的准确性，我们构建了一个参考内核，在其中修改了内核内存函数以生成动态内核对象的日志，并在LiveDM中运行该内核。我们观察到日志中的动态对象与LiveDM捕获的实时动态内核对象完全匹配。为了检查类型推导的准确性，我们手动将捕获的调用点转换为数据类型，方法是遍历内核源代码，正如相关方法[5,7]所做的那样。在分配代码处推导出的类型与我们的自动静态代码分析结果一致。

### 3.6 从通用类型到特定类型的代码模式

在第3.1节中，我们讨论了分配驱动映射可以处理特定类型转换为通用类型的情况，但通用类型转换为特定类型可能会有问题。为了估计这种类型转换发生的频率，我们手动检查了所有用于推导内核对象类型的分配代码位置。我们查找了以下代码模式：使用通用指针分配内存，然后将其地址转换为更具体类型的指针。需要注意的是，此模式不包括通用指针的一般用途，例如使用void或整数指针作为位字段或缓冲区是通用指针的有效使用。另一种有效使用是内核内存函数内部处理预类型化内存，使用通用指针将其分配给各种类型。我们在10个分配代码位置（例如tty注册驱动程序和vc分配）上发现了25个表现出这种行为的对象。这些对象不属于表1中显示的核心数据结构，仅占所有对象的0.085%。因此我们认为它们是非显著的边缘情况。由于这些转换发生的位置对LiveDM是可访问的，我们相信可以通过在分配代码之后对代码进行静态分析来自动化识别这种行为并推导出具体类型。

### 3.7 分配驱动映射的性能

由于LiveDM主要针对非生产环境（如蜜罐和内核调试系统），因此性能不是首要关注的问题。尽管如此，我们仍希望提供关于分配驱动映射成本的一般概念。为了测量在运行时生成内核对象映射的开销，我们运行了三个基准测试：编译内核源代码、UnixBench（Byte Magazine Unix Benchmark 5.1.2）和nbench（BYTEmark* Native Mode Benchmark version 2）。与未修改的QEMU相比，我们的原型在最坏情况下对于Redhat 8（Linux 2.4）产生了41.77%的开销，对于Debian Sarge（Linux 2.6）产生了125.47%的开销。对于像nbench这样的CPU密集型工作负载，开销接近于零，因为VMM很少干预。然而，使用需要动态内核内存的内核服务的应用程序会有更高的开销。例如，编译Linux内核在Redhat 8上的开销为29%，在Debian Sarge上的开销为115.69%。需要注意的是，这些数字是在与未修改的VMM比较时测得的开销。基于软件的虚拟化还会增加额外的开销。对于非生产环境中细粒度内核行为的检查，我们认为这种开销是可以接受的。即使在生产环境中，通过使用解耦分析[6]也可以最小化这种开销的影响。

### 6. 案例研究

我们介绍了两个基于LiveDM构建的内核恶意软件分析系统：隐藏内核对象检测器和时间恶意行为监控器。这些系统突出了分配驱动映射的新特性，这些特性对于检测和分析内核恶意软件攻击非常有效。

#### 6.1 隐藏内核对象检测器

静态类型投影方法的一个问题是，如果没有某种数据不变性，它们无法检测动态内核对象操作。本节介绍了一种基于LiveDM构建的隐藏内核对象检测器，它不受此限制。

利用未经篡改的视图。一些高级DKOM（Direct Kernel Object Manipulation）内核Rootkit通过简单地删除内核动态内存中对该对象的所有引用来隐藏内核对象。我们将这种DKOM数据隐藏攻击的行为建模为列表中的数据异常。如果一个动态内核对象没有出现在内核对象列表中，则它是孤立的，因此是异常的。如第3.1节所述，分配驱动映射提供了不受实际内核内存内容操纵影响的内核对象未经篡改的视图。因此，如果一个内核对象出现在LiveDM生成的内核对象映射中，但在遍历内核内存时找不到，则该对象已被隐藏。更正式地说，对于给定数据类型的动态内核对象集，活动集L是内核对象映射中找到的对象集。扫描集S是通过遍历内核内存找到的内核对象集，类似于相关方法[1,5,16]。如果L和S不匹配，则会报告数据异常。

这个过程在清洁者Rootkit隐藏adore-ng Rootkit模块的例子中进行了说明（图3）。图3(a)展示了使用内核模块生命周期的时间线。图3(b)展示了在三个关键时刻内核模块的详细状态以及相应的L和S。内核模块组织成从静态指针变量开始的链表。当清洁者模块在adore-ng模块之后加载时，它修改了链表以绕过adore-ng模块条目（如t2所示）。因此，当清洁者模块卸载时，adore-ng模块从模块列表中消失（t3）。此时，基于静态类型投影映射的扫描集S丢失了隐藏模块，但活动集L保持了所有内核模块的视图。因此，监视器可以根据|L| ≠ |S|的条件检测到隐藏的内核模块。

#### 6.2 时间恶意行为监控器

基于动态类型投影的内核Rootkit分析方法能够对运行中的Rootkit进行时间分析。然而，这些方法的一个问题是，它们只能跟踪注入Rootkit代码后发生的恶意软件行为。如果Rootkit通过其他方式间接修改内存，例如通过合法的内核函数或内核漏洞，这些方法则无法跟踪攻击。

分配驱动映射没有这种弱点。为了进一步说明分配驱动映射的优势，我们构建了一个时间恶意行为监控器（以下简称时间监控器），它使用内核对象映射在内核执行跟踪的时间分析中。

在本节中，我们强调了分配驱动映射提供的两个新特性。首先，分配驱动映射使时间分析中可以使用覆盖所有内核对象的内核对象映射；因此，对于任何给定的动态内核对象，我们可以检查其在动态内核执行跟踪中的使用情况，无论访问代码是合法的还是恶意的，这对于静态和动态类型投影方法都是困难的。其次，分配驱动映射中的数据生命周期使监控器能够避免异步内存映射可能面临的动态数据身份问题（第2.1节）。

通过动态内核内存系统地可视化恶意软件的影响。我们的监控器系统地检查并可视化针对动态内核内存的内核恶意软件攻击的影响。为了分析这种动态攻击行为，我们在内核Rootkit实验期间生成了完整的系统跟踪，包括内核对象映射状态、执行的代码和内存访问。当内核Rootkit攻击启动时，如果它违反了内核代码完整性，我们使用之前的工作NICKLE[22]来识别Rootkit代码。然后，时间监控器通过搜索内核对象映射系统地识别所有Rootkit内存写入的目标。如果攻击没有违反代码完整性，可以使用前一节中提出的技术或其他方法来检测受攻击的动态对象。识别出的对象成为恶意软件行为的原因，其效果通过搜索由这些对象触发的原始和修改后的内核控制流系统地可视化。对于每个被Rootkit目标的对象，通常存在多个使用其值的行为。在这之中，监控器采样一对由相同代码引起的行为，以便进行详细的分析。