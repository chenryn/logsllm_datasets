*   卷
如前所述，版本必须至少为 3 才能与 Docker 栈一起工作。查看`docker-stack.yml`文件中的第 1 行(版本密钥始终在第 1 行)，我们会看到以下内容:
![](img/db63823a-5514-4548-8c15-00c967515e96.png)
完美！我们有一个 3 版规范的合成文件。跳过(折叠的)服务密钥部分一分钟，让我们先看看网络密钥，然后再看看卷密钥。在网络关键部分，我们指示 Docker 创建两个网络，一个名为前端，一个名为后端。实际上，在我们的例子中，网络将具有名称`voteapp_frontend`和`voteapp_backend`。这是因为我们将我们的栈命名为`voteapp`，Docker 会将栈名添加到它作为栈的一部分部署的各种组件中。只需在栈文件的网络密钥中包含所需网络的名称，Docker 就会在我们部署栈时创建我们的网络。我们可以提供每个网络的具体细节(正如我们在[第 6 章](6.html)、 *Docker Networking* 中了解到的)，但是如果我们不提供任何细节，那么将使用某些默认值。对于我们的栈来说，部署网络可能已经足够长了，所以让我们使用 network list 命令来看看我们现在有哪些网络:
![](img/4f26a50f-92fc-4fb0-a453-2a1448250df9.png)
它们是:`voteapp_frontend`和`voteapp_backend`。你可能想知道什么是`voteapp_default`网络。当您部署一个栈时，您总是会得到一个默认的群网络，如果在栈组成文件中没有为它们定义任何其他网络连接，那么所有容器都被附加到它上面。这很酷，对吧？！您不需要执行任何 docker 网络创建命令，就可以创建您想要的网络，并在应用中使用。
卷密钥部分与网络密钥部分的作用基本相同，只是它是针对卷的。部署栈时，会自动创建您定义的卷。如果栈文件中没有提供其他配置，则使用默认设置创建卷。在我们的例子中，我们要求 Docker 创建一个名为`db-data`的卷。正如您可能已经猜到的，创建的卷实际上有`voteapp_db-data`的名称，因为 Docker 在卷名前面加上了我们栈的名称。在我们的例子中，它看起来像这样:
![](img/457d5f8c-cb66-4cd6-96b8-75adb3afcfe9.png)
因此，部署我们的栈创建了我们想要的网络和我们想要的卷。所有这些都包含在我们的栈组成文件中易于创建、易于阅读和理解的内容。好了，现在我们已经很好地掌握了栈合成文件中四个顶级关键部分中的三个。现在，让我们回到服务关键部分。如果我们展开这个关键部分，我们将看到我们希望作为应用的一部分部署的每个服务的定义。在`docker-stack.yml`文件的情况下，我们定义了六个服务。这些是 redis、db、投票、结果、工作者和可视化工具。在栈合成文件中，它们如下所示:
![](img/3fc6f525-3d09-4045-bc56-d9da65483394.png)
让我们扩展第一个，redis，并仔细看看什么是我们应用的 redis 服务:
![](img/4bf276e3-699f-4d20-a441-9182e0db84cb.png)
如果你回想一下[第 5 章](5.html)、 *Docker Swarm* 中对 Docker 服务的讨论，这里显示的许多键应该对你来说很熟悉。现在让我们检查 redis 服务中的密钥。首先，我们有`image`键。服务定义需要映像密钥。这个键是告诉 docker 这个服务要拉取运行的 Docker 镜像是`redis:alpine`。正如你现在应该明白的，这意味着我们正在使用来自 hub.docker.com 的官方 redis 映像，请求标记为`alpine`的版本。下一个关键点`ports`是定义映像将从容器和主机暴露到哪个端口。在这种情况下，主机上要映射到容器的公开端口(`6379`)的端口留给 Docker 分配。您可以使用`docker container ls`命令找到分配的端口。在我的例子中，redis 服务正在将主机上的端口`30000`映射到容器上的端口`6379`。接下来使用的按键是`networks`。我们已经看到，部署栈将为我们创建网络。该指令告诉 Docker redis 副本容器应该连接到哪些网络；在这种情况下是`frontend`网络。如果我们检查 redis 副本容器，检查网络部分，我们会发现这是准确的。您可以使用如下命令查看您的部署(注意，容器名称在您的系统上略有不同):
```
# Inspect a redis replica container looking at the networks
docker container inspect voteapp_redis.1.nwy14um7ik0t7ul0j5t3aztu5  \
 --format '{{json .NetworkSettings.Networks}}' | jq
```
在我们的示例中，您应该看到容器连接到两个网络:入口网络和我们的`voteapp_frontend`网络。
我们的 redis 服务定义中的下一个键是 deploy 键。这是添加到版本 3 的编写文件规范中的一个关键类别。它定义了基于该服务中的映像运行容器的细节:在本例中，是 redis 映像。它本质上是编排指令。`replicas`标记告诉 docker 当应用完全部署时，应该运行多少个副本或容器。在我们的例子中，我们声明我们只需要为我们的应用运行一个 redis 容器实例。`update_config`键提供了`parallelism`和`delay`两个子键，告诉 Docker 应该并行启动多少个容器`replicas`，以及启动每套`parallel`容器`replicas`之间需要等待多长时间。当然，有了一个副本，并行性和延迟细节就没什么用了。如果`replicas`的值更大，例如`10`，我们的 update_config 键将导致一次启动两个副本，两次启动之间有 10 秒的等待时间。最终的部署密钥是`restart_policy`，它定义了在部署的栈中创建新副本的条件。在这种情况下，如果一个 redis 容器出现故障，将会启动一个新的 redis 容器来代替它。让我们看看我们应用中的下一个服务，`db`服务:
![](img/05c62070-b99e-44b6-9aeb-87a5a39cd8e4.png)
db 服务将有几个与 redis 服务相同的键，但是具有不同的值。首先，我们有映像键。这一次，我们表示我们想要带有 9.4 版本标签的官方 postgres 映像。我们的下一个键是卷键。我们表示我们正在使用名为 db-data 的卷，并且在 db 容器中，该卷应该安装在`/var/lib/postgresql/data`处。让我们看看我们环境中的卷信息:
![](img/cc874b3a-4a1f-4e7c-9205-1370c49b6cb7.png)
使用 volume inspect 命令，我们获得卷装载点，然后将容器中文件夹的内容与主机上装载点的内容进行比较:
![](img/c15dc49d-8cbc-44b6-92c8-17fa68ade32c.png)
瞧啊。不出所料，他们匹配。这在苹果电脑上并不简单。请参阅 Docker 卷上的[第 4 章](4.html)、 *Docker Volumes、*了解如何在 OS X 上处理此问题的详细信息。下一个关键点是网络关键点，这里我们将指导 Docker 将后端网络连接到我们的数据库容器。接下来是部署密钥。在这里，我们看到了一个新的子键，叫做`placement`。这是一个指令，告诉 Docker 我们只希望 db 容器在管理器节点上运行，即在具有`manager`角色的节点上运行。
您可能已经注意到，部署键的一些子键存在于 redis 服务中，但在我们的 db 服务中却没有，最值得注意的是`replicas`键。默认情况下，如果不指定要维护的副本数量，Docker 将默认拥有一个副本。总之，数据库服务配置的描述与 redis 服务非常相似。您将看到所有服务配置之间的这种相似性。这是因为 Docker 使得定义我们服务的期望状态变得非常容易，并且通过关联，定义我们的应用。为了验证这一点，让我们来看看栈合成文件中的下一个服务，`vote`服务:
![](img/c7b6874c-7c27-4aa9-895c-297b22c27b06.png)
你应该开始熟悉这些键及其值了。在投票服务中，我们看到定义的映像不是官方容器映像之一，而是在名为`dockersamples`的公共回购中。在该报告中，我们使用了名为`examplevotingapp_vote`的映像，带有`before`的版本标签。我们的端口密钥告诉 Docker 和我们，我们希望在群集主机上打开端口`5000`，并将该端口上的流量映射到正在运行的投票服务容器中的端口 80。事实证明，投票服务是我们应用的`face`，我们将通过端口`5000`访问它。因为它是一项服务，所以我们可以通过访问群中任何一台主机上的端口*来访问它，即使特定的主机没有运行其中一个副本。*
查看下一个键，我们看到我们正在将`frontend`网络附加到我们的投票服务容器。然而，这并不是什么新鲜事，因为我们的下一把钥匙是一把我们从未见过的钥匙:`depends_on`钥匙。这个键告诉 Docker，我们的投票服务需要 redis 服务才能运行。这对我们的`deploy`命令意味着，在启动该服务之前，需要启动依赖的一个或多个服务。具体来说，redis 服务需要在投票服务之前启动。这里的一个关键区别是我说的开始。这并不意味着依赖的服务必须在启动该服务之前运行；依赖的服务必须在它之前启动。同样，具体来说，redis 服务不必在启动投票服务之前处于运行状态，它只需在启动投票服务之前启动。在投票服务的部署密钥中，我们还没有看到任何内容，唯一的区别是我们要求为投票服务提供两个副本。您是否开始理解栈组成文件中服务定义的简单性和强大功能了？
在我们的栈组成文件中定义的下一个服务是结果服务。然而，由于服务定义中没有我们在前面的服务中没有看到的键，我将跳过对结果服务的讨论，转到 worker 服务，在这里我们将看到一些新的东西。以下是工人服务定义:
![](img/b4ddec41-7ece-487d-a782-615d8853be3c.png)
你知道映像键及其含义。你知道网络密钥及其含义。您知道部署密钥，但是我们这里有一些新的子密钥，所以让我们从`mode`密钥开始讨论它们。您可能还记得我们在[第 5 章](5.html)、 *Docker Swarm* 中对服务的讨论，有一个`--mode `参数可以有两个值之一:`global`或`replicated`。这个键和我们在[第五章](5.html)*Docker Swarm*看到的参数完全一样。默认值是复制的，因此如果不指定模式键，您将获得复制行为，即精确定义复制副本的数量(如果未指定复制副本的数量，则为一个复制副本)。使用全局的其他值选项将忽略副本密钥，并为群中的每台主机部署一个容器。
在这个栈合成文件中，我们之前没有看到的下一个键是`labels`键。这个键的位置很重要，因为它可以作为自己的上层键出现，或者作为部署键的子键出现。区别是什么？当您使用`labels`键作为部署键的子键时，标签将仅在服务上设置。当您使用`labels`键作为其自己的上层键时，标签将被添加到作为服务的一部分部署的每个副本或容器中。在我们的示例中，`APP=VOTING `标签将应用于服务，因为`labels`键是部署键的子键。同样，让我们在我们的环境中看到这一点:
```
# Inspect the worker service to see its labels
docker service inspect voteapp_worker \
 --format '{{json .Spec.Labels}}' | jq
```
以下是我的系统上的情况:
![](img/4b1b7fba-94cd-40ec-ac68-66fd1d791c1d.png)
在工作容器上执行 inspect 命令查看其上的标签将显示`APP=VOTING`标签没有出现。如果您想在系统上确认这一点，命令将如下所示(使用不同的容器名称):
```
# Inspect the labels on a worker container
docker container inspect voteapp_worker.1.rotx91qw12d6x8643z6iqhuoj \
 -f '{{json .Config.Labels}}' | jq
```
同样，这是它在我的系统上的样子:
![](img/c4206773-5d0a-4903-a6d6-af59fc260ead.png)
restart_policy 键的两个新的子键是`max_attempts`和`window`键。你大概能猜到他们的目的；`max_attempts`键告诉 Docker，如果工人容器启动失败，继续尝试启动，最多三次，然后放弃。`window`键告诉 Docker，如果工作容器之前未能启动，在重试启动工作容器之前需要等待多长时间。很简单，对吧？同样，这些定义易于设置，易于理解，并且对于编排我们应用的服务极其强大。
好吧。我们还有一个新的服务定义需要审查，那就是可视化服务。这是我们的栈合成文件中的样子:
![](img/9a9366b9-a6af-4510-990e-0c8af430a4da.png)