.got.plt 后面的项则是程序中不同 .so 中函数的引用地址。下面给出一个相应的关系。
## Procedure Linkage Table
PLT 表将导入函数重定向到绝对地址。主要包括两部分
-   **.plt**，与常见导入的函数有关，如 read 等函数。
-   **.plt.got**，与动态链接有关系。
准确的说，plt 表不是查询表，而是一块代码。这一块内容是与代码相关的。
在动态链接下，程序模块之间包含了大量的函数引用。如果在程序开始执行前就把所有的函数地址都解析好，动态链接就会耗费不少时间用于解决模块之间的函数引用的符号查找以及重定位。但是，在一个程序运行过程中，可能很多函数在程序执行完时都不会用到，因此一开始就把所有函数都链接好可能会浪费大量资源，所以 ELF 采用了一种延迟绑定的做法，其基本思想是函数第一次被用到时才进行绑定（符号查找，重定位等），如果没有用则不进行绑定。所以程序开始执行前，模块间的函数调用都没有进行绑定，而是需要用到时才由动态链接器负责绑定。
在惰性绑定的情况下，总体流程如下图所示，蓝线表示首次执行的流程图，红线表示第二次以后调用的流程图：
LD_BIND_NOW 环境变量可以改变动态链接器的行为。如果它的值非空的话，动态链接器在将控制权交给程序之前会执行 PLT 表项。也就是说，动态链接器在进程初始化过程中执行类型为 R\_3862\_JMP_SLOT 的重定位表项。否则的话，动态链接表会对过程链接表项进行延迟绑定，直到第一次执行对应的表项时，才会今次那个符号解析以及重定位。
注意
>   惰性绑定通常来说会提高应用程序的性能，因为没有使用的符号并不会增加动态链接的负载。然而，有以下两种情况将会使得惰性绑定出现未预期的情况。首先，对于一个共享目标文件的函数的初始引用一般来说会超过后续调用的时间，因为动态链接器需要拦截调用以便于去解析符号。一些应用并不能够忍受这种不可预测性。其次，如果发生了错误，并且动态链接器不能够解析符号。动态链接器将会终止程序。在惰性绑定的情况下，这种情况可能随时发生。当关闭了惰性绑定的话，动态链接器在进程初始化的过程中就不会出现相应的错误，因为这些都是在应用获得控制权之前执行的。
链接编辑器不能够解析执行流转换（比如函数调用），即从一个可执行文件或者共享目标文件到另一个文件。链接器安排程序将控制权交给过程链接表中的表项。在 Intel 架构中，过程链接表存在于共享代码段中，但是他们会使用在 GOT 表中的数据。动态链接器会决定目标的绝对地址，并且会修改相应的 GOT 表中的内存镜像。因此，动态链接器可以在不违背位置独立以及程序代码段兼容的情况下，重定向 PLT 项。可执行文件和共享目标文件都有独立的 PLT 表。
绝对地址的过程链接表如下
```assembly
.PLT0:  pushl	got_plus_4
        jmp	*got_plus_8
	      nop; nop
	      nop; nop
.PLT1:  jmp	*name1_in_GOT
        pushl	$offset@PC
	      jmp	.PLT0@PC
.PLT2:  jmp	*name2_in_GOT
        push	$offset
	     jmp	.PLT0@PC
	     ...
```
位置无关的过程链接表的地址如下
```assembly
.PLT0:  pushl	4(%ebx)
        jmp	*8(%ebx)
	      nop; nop
	      nop; nop
.PLT1:  jmp	*name1_in_GOT(%ebx)
        pushl	$offset
	      jmp	.PLT0@PC
.PLT2:  jmp	*name2_in_GOT(%ebx)
        push	$offset
	      jmp	.PLT0@PC
	      ...
```
可以看出过程链接表针对于绝对地址以及位置独立的代码的处理不同。但是动态链接器处理它们时，所使用的接口是一样的。
动态链接器和程序按照如下方式解析过程链接表和全局偏移表的符号引用。
1.  当第一次建立程序的内存镜像时，动态链接器将 GOT 表的第二个和第三个项设置为特殊的值，下面的步骤会仔细解释这些数值。
2.  如果过程链接表是位置独立的话，那么 GOT 表的地址必须在 ebx 寄存器中。每一个进程镜像中的共享目标文件都有独立的 PLT 表，并且程序只在同一个目标文件将控制流交给 PLT 表项。因此，调用函数负责在调用 PLT表项之前，将全局偏移表的基地址设置为寄存器中。
3.  这里举个例子，假设程序调用了name1，它将控制权交给了 lable .PLT1。
4.  那么，第一条指令将会跳转到全局偏移表中 name1 的地址。初始时，全局偏移表中包含 PLT 中下一条 pushl 指令的地址，并不是 name1 的实际地址。
5.  因此，程序将相应函数在 `rel.plt` 中的偏移（重定位偏移，reloc_index）压到栈上。重定位偏移是 32 位的，并且是非负的数值。此外，重定位表项的类型为 R\_386\_JMP_SLOT，并且它将会说明在之前 jmp 指令中使用的全局偏移表项在 GOT 表中的偏移。重定位表项也包含了一个符号表索引，因此告诉动态链接器什么符号目前正在被引用。在这个例子中，就是 name1了。
6.  在压入重定位偏移后，程序会跳转到 .PLT0，这是过程链接表的第一个表项。pushl 指令将 GOT 表的第二个表项(got_plus_4 或者4(%ebx)，**当前ELF对象的信息**)压到栈上，然后给动态链接器一个识别信息。此后，程序会跳转到第三个全局偏移表项(got_plus\_8 或者8(%ebx)，**指向动态装载器中 `_dl_runtime_resolve` 函数的指针**) 处，这将会将程序流交给动态链接器。
7.  当动态链接器接收到控制权后，他将会进行出栈操作，查看重定位表项，解析出对应的符号的值，然后将 name1 的地址写入到全局偏移表项中，最后将控制权交给目的地址。
8.  过程链接表执行之后，程序的控制权将会直接交给 name1 函数，而且此后再也不会调用动态链接器来解析这个函数。也就是说，在 .PLT1 处的 jmp 指令将会直接跳转到 name1 处，而不是再次执行 pushl 指令。
## .rel(a).dyn & .rel(a).plt
.rel.dyn 包含了动态链接的二进制文件中需要重定位的变量的信息，而 .rel.plt 包含了需要重定位的函数的信息。这两类重定位节都使用如下的结构（以 32 位为例）
```
typedef struct {
    Elf32_Addr        r_offset;
    Elf32_Word       r_info;
} Elf32_Rel;
typedef struct {
    Elf32_Addr     r_offset;
    Elf32_Word    r_info;
    Elf32_Sword    r_addend;
} Elf32_Rela;
```
Elf32_Rela 类型的表项包含明确的补齐信息。 Elf32_Rel 类型的表项在将被修改的位置保存隐式的补齐信息。由于处理器体系结构的原因，这两种形式都存在，甚至是必需的。因此，对特定机器的实现可以仅使用一种形式，也可以根据上下文使用两种形式。
其中，每个字段的说明如下
| 成员     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| r_offset | **此成员给出了需要重定位的位置。**对于一个可重定位文件而言，此值是从需要重定位的符号所在节区头部开始到将被重定位的位置之间的字节偏移。对于可执行文件或者共享目标文件而言，其取值是需要重定位的**虚拟地址**，一般而言，也就是说我们所说的 GOT 表的地址。 |
| r_info   | **此成员给出需要重定位的符号的符号表索引，以及相应的重定位类型。**  例如一个调用指令的重定位项将包含被调用函数的符号表索引。如果索引是 STN_UNDEF，那么重定位使用 0 作为“符号值”。此外，重定位类型是和处理器相关的。 |
| r_addend | 此成员给出一个常量补齐，用来计算将被填充到可重定位字段的数值。 |
关于 r_info 更加具体的字段信息如下面的代码所示
- r_info 的高三个字节对应的值表示这个动态符号在 `.dynsym` 符号表中的位置
- r_info 的最低字节表示的是重定位类型类型
```c
#define ELF32_R_SYM(i)    ((i)>>8)
#define ELF32_R_TYPE(i)   ((unsigned char)(i))
// 用于构造 r_info
#define ELF32_R_INFO(s,t) (((s)<<8)+(unsigned char)(t))
```