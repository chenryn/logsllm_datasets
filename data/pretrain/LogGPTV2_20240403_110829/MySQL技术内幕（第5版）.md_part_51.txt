2006-12-26
---
## Page 215
并通过参数返回这两个统计值，让调用者可以访问它们：
型OUT和INOUT 将非常有用。（由于存储函数只能返回一个值，因此它并不适用于这种情形。)
相应的变量将在过程返回时获得那个值。如果想让某个存储过程返回多个结果值，那么参数类
有为参数指定类
则允许调用者向过程传递一个值，
正好相反。
可以对这个值进行修改，但在过程返回之后任何修改对调用者来说都是不可见的。OUT参数则
4.2.2.2存
所示。
致在主、从服务器上的复制结果不一致。）这些限制条件也适用于触发器的创建过程。具体如下
再次执行二进制日志来恢复数据，将不能保证把数据恢复到原来的样子；而且该函数还可能导
定或者会修改数据的存储函数。（如果某个函数针对给定的输入值会生成不同的结果，那么通
件主要用于保证二进制日志在执行备份和复制操作时的安全性，具体做法是，不允许创建不确
撤销机制，
EXECUTE和ALTERROUTINE权限，那么服务器会自动为你授予这些权限，以便你可以执行或删
该数据库的CREATE ROUTINE 权限。默认的情况下，在创建存储例程时，如果你还没有获得
4.2.2.1存储函数和存储过程的权限
除该例程。
储函数里调用 update_expiration（)
下面这个过程演示了oUT参数的用法。它可以分别统计出student表里的男生和女生人数
存储过程的参数分为3种类型。对于 IN参数，调用者会把一个值传递到过程里。这个过程
如果服务器
存储函数和存储过程隶属于某个数据库。
在调用此过程时，请把各个参数替换成相应的用户定义变量。此过程将把统计值放到这些
显式指定参
END;
BEGIN
CREATE PROCEDURE count_students_by_sex (OUT p_male INT, OUT p_female INT)
口如果启用了
口如果未启用log_bin_trust_function_creators 系统变量，你就必须要具备 SUPER
用这种设置。
有在你相信1
END;
BEGIN
DETERMINISTIC
RETURNS DOUBLE
CREATE FUNCTION half（
之一来定义存储函数。
据。为了表明这一点，
权限才能创建存储函数。另外，你创建的所有函数都必须是确定的，并且不得修改数
反。过程把某个值赋给这个参数，但在过程返回后该值可以被调用者访问。INOUT参数
RETURN p_value / 2;
存储过程的参数类型
，在删除例程时，服务器将自动撤销那些权限。如果不想使用这种自动化的权限授
那么可以把系统变量automatic_sp_privileges 设置成0。
类型，则其默认类型为IN。
参数类型的方法是，
器启
MySQL服务器上的所有用户都不会去定义不安全的存储函数时，才可以使
用了二进制日志功能，那么存储函数还需要服从另外一些限制条件，这些条
：(SELECT COUNT(*） FROM Student WHERE SeX=
log_bin_trust_function_creators 系统变量，就没有任何限制了。
需要使用 DETERMINISTIC、NO SQL 或 READS SQL DATA这三者
(p_value DOUBLE)
例如：
，在参数列表里的参数名前面使用IN、OUT或INOUT。如果没
然后再取回一个值。
i
，如果要想创建存储函数或存储过程，则必须拥有
M'）;
4.2使用存储程序
195
过
---
## Page 216
被删除或修改的原行里的列。如果想要用 BEFORE 触发器改变列值，而且想在值存储到表中之
那个新行里的列。类似地，OLD.col_name语法可以用来引用在 DELETE或UPDATE 触发器里将
句体里,可以使用 NEW.co1_name语法来引用在 INSERT或UPDATE 触发器里将被插入或修改的
tbl_name表有关的 AFTERINSERT触发器。
触发器创建语句的基本语法如下所示：
的语句类型（INSERT、UPDATE 或 DELETE）；以及是在行被修改之前触发，还是在之后触发。
一条会在触发器被激活时执行的语句。
语句时，被自动激活。触发器可被设置成语句处理各行之前或之后激活。触发器的定义包含有
4.2.3
都像IN参数。触发器和事件则根本就没有参数。
通过OUT参数把所有这些值传递给调用者。
count_students_by_sex（），那么在这个程序中定义的局部变量或参数可以作为参数传递给
参数里。在它返回之后，这些变量会包含那些统计值：
于指明某次测试或测验在score表里的ID。
count_students_by_sex()。
196
trigger_stmt 是触发器的语句体，即在触发器被激活时需要执行的语句。在触发器的语
触发器是与特定表相关联的存储过程，其定义会在执行表的INSERT、DELETE或 UPDATE
关键字IN、OUT和INOUT 都不能用于存储函数、触发器和事件。对于存储函数，所有参数
这个存储过程可以根据相关的分数计算描述性统计（如平均值、标准偏差、极差等），然后
需要额外参数的例子有很多。例如，你可以编写一个存储过程，让它具有一个IN参数，用
其中，triger_name 是触发器的名字；tbl_name是与触发器相关联的那个表的名字。
CREATE TRIGGER trigger_name
要创建触发器，可以使用CREATETRIGGER语句。在触发器的定义里，
口触发器可以检查或修改将被插入或用来更新行的那些新的数据值。这意味着我们可以
触发器具有以下几个好处。
难道只有用户定义变量才能作为参数进行传递吗？非也。如果在另一个存储程序里调用
口角
口角
FOR EACH ROW trigger_stmt;
ON tbl_name
记录已有行的更改情况。
利用触发器来实现数据完整性约束，如检查某个百分比数值是不是落在了0~100这样一
(INSERT|
BEFORE
触发器
进行定义的列类型提供值。
触发器可以基于某个表达式来为列提供默认值，甚至可以为那些只能使用常量默认值
个区间内。触发器还可以用来对输入数据进行过滤。
第4章
触发器
器可以在行删除或更新之前先检查行的当前内容。这种能力能完成许多任务，如
视图和存储程序
|UPDATE |DELETE)
AFTER)
15
触发器内容
关
激
触触
联
活触发器的语句
发器的名字
发
表
器
激活的时机
需要指明：触发它
在
---
## Page 217
容放到某个在服务器启动时会被读取的选项文件里：
的示例请参考12.8.7.4节。
表轮换等。本节将演示如何完成行过期处理操作。与如何完成基于事件的日志表轮换操作有关
常适合于执行那些无人值守的系统管理任务，如汇总报告定期更新、旧数据过期清理或者日志
的存储程序。计划会定义事件执行的时间或次数，并且还可以定义事件何时强行退出。事件非
4.2.4事件
果你删除某个表，那么MySQL会删除所有与之关联的触发器。）
用的是BEFORE，因此它可以在数据值被插入进表之前对它们进行检查。
型列percent，用于存储百分比值（范围为O~100）；另外还有一个DATETIME列。该触发器使
前改变它，那么可以使用sETNEW.col_name=value。
默认情况下，事件调度器并不会运行，因此必须先启用它才能使用事件。请把下面两行内
MySQL有一个事件调度器，它可以定时激活多个数据库操作。事件就是一个与计划相关联
触发器创建操作具有与存储函数创建操作一样的约束。更多相关信息请参考4.2.2.1节。
在下面这个示例里，表t的INSERT语句有一个名为bi_t 的触发器。其中，表t有一个整
触发器属于表，因此你必须要拥有表的 TRIGGER 权限，才能为表创建或删除触发器。
mysql> INSERT
mySql> INSERT INTOt
我们来看看这个触发器是如何工作的，先往表里插入几行，然后检索表的内容：
口
口如果要插入的百分比值超出了0~100的范围，那么这个触发器将把该值转换成最靠近端
这个触发器将完成以下两个动作。
mysql> delimiter ;
mySql> CREATE TRIGGER bi_t BEFORE INSERT ON
mysql> CREATE TABLE t (percent INT, dt DATETIME);
percent|dt
ysql> SELECT
sgl>
无关的效果。）
里一样可以如设计的那样工作，因此你可以在其他依赖于具体版本的环境里达到版本
列的自动初始化能力。
开
这个触发器将自动为那个DATETIME列提供一个CURRENT_TIMESTAMP 值。实际上，这绕
点的那个值。
间
戳，因此这里的触发器已没什么用处。不过，它在MySQL5.6以及更早一点的版本
了“列的默认值必须是一个常数”的限制，让DATETIME列具备了类似于TIMESTAMP
->
100
INSERT
Q
FOR EACH ROW BEGIN
END$
END$
2012-05-1911:14:56
2012-05-1911:14:54
ELSEIF NEW.percent>100 THEN
INTOt
NEW.dt=CURRENT_TIMESTAMP;
ti
(percent)
（percent)VALUES(-2);DO SLEEP(2）;
(percent)
（自MySQL5.6.5开始，DATETIME列可以被初始化为当前的时
VALUES(120);
VALUES(30);
DO SLEEP(2)
t
4.2使用存储程序
（如
197
---
## Page 218
EVENT:
的定义便会创建一个在一个小时后只执行一次的事件：
的存储程序一样，它可以是一条简单的语句，也可以是一条使用 BEGIN 和END 编写出的复合语句。
事件在被创建后会立刻开始它的第一次执行，并且会定时持续执行下去，永不停止。
datetime和ENDS datetime，用于指定事件的第一次和最后一次执行时间。默认情况下，EVERY
函数里的参数值（HOUR、DAY或MONTH）相似。在EVERY子句的后面，还可以包含可选子句 STARTS
将超过一天的行清除掉，可以编写如下事件定义：
的行越积越多，可以创建一个事件，用于定期清理它们。为实现事件每4小时执行一次，同时
一个名为last_visit 的 DATETIME 列，用于记录每位用户的最近一次访问时间。为防止表里
个名为web_session的表，其存储的内容是与网站访问用户相关的会话状态信息，并且该表有
度器没有如预期的那样运行，那么查看错误日志里的消息，从而找出具体的原因。
在做什么。在事件执行期间，只要有错误发生，事件调度器都会把它们记录下来。如果事件调
说明
个事件。关于这一点，稍后再做讨论。
一个GLOBAL变量，因此必须要拥有SUPER权限才能修改它）的值：
198
如果想创建一个只执行一次的事件，则应该使用AT调度类型，而不要使用EVERY。像下面
如果要禁用某个事件，让它不再执行，或者要重新激活某个被禁用的事件，可以使用ALTER
DO子句负责定义事件的语句体部分，它是一条在事件被触发时执行的SQL语句。与其他类型
其中，EVERYn interval子句用于指定事件定期执行的时间间隔。interva7值与DATE_ADD（）
CREATE EVENT expire_web_session
下面这个示例演示的是：如何创建一个简单的事件，并用它来删除表里的旧行。假设有一
事件属于数据库，因此你必须要拥有数据库的EVENT权限才能创建或删除其触发器。
创建事件的方法是，使用CREATEEVENT语句，其基本语法如下：
事件调度器会把执行情况写到服务器的错误日志里，通过它，你可以查看到事件调度器正
如果你停止了调度器，则所有事件都不会运行。
SET GLOBALevent_scheduler=OFF;
如果想在运行时停止或启动事件调度器，那么可以更改event_scheduler系统变量（它是
如果想在运行时查看事件调度器的状态，那么可以使用下面这条语句：
如果在服务器启动时把变量event_scheduler 设置成DISABLED，那么在运行时只能查
event_scheduler=ON
[mysqla]
82
看其状态，而不能更改它。你可以创建事件，但它们不会执行。
WHERE laSt_Visit<CURRENT_TIMESTAMP-INTERVAL 1 DAY;
第4章视图和存储程序
SCHEDULEEVERY4HOUR
(AT datetime I EVERY expr interval[STARTS datetime][ENDS datetimel]}
_stmt
#或者1
#或者0
，也可以让事件调度器保持运行，但禁用各
由
---
## Page 219
会返回调用用户的账户。
的账户。对于视图和定义时带有 SQL SECURITY INVOKER 特性的存储例程，CURRENT_USER（）
现一个错误。
们没有 SQLSECURITY 特性，总是以定义者的权限来执行。
一来，如果调用者本人无权访问mysql.user表，那么即使他访问这个视图，也无法突破权限限制。
序。例如，下面这个视图将访问 mysql数据库里的某个表，但是是以调用者的权限来运行。这样
限执行）或INVOKER（以对象调用者的权限执行）。
实现对执行时访问检查的附加控制。SQLSECURITY 特性的允许值为DEFINER（以定义者的权
账户。