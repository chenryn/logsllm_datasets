20
30
40
50
60
70
80
90
100
110
120
130
140
150
1151
1737
2647
3739
4422
5106
6002
6238
6929
7874
8982
9702
11259
11910
12909
691
1003
1391
2269
2600
3165
3826
3714
4169
5554
5536
7020
7379
8018
8918
355
435
579
948
1113
1225
1782
1984
1913
2666
1289
2510
Table 4: Executions in AWS (same region) on c5.xlarge machines on a circuit with
1,000,000 multiplication gates and depth 100; time in ms. (GF [28] run only up to 120
parties since HyperMPC requires |F| > 2n.)
HyperMPC with many parties. Finally, we demonstrated that HyperMPC can sup-
port MPC with a very large number of parties. We considered a scenario (like that of
PrivatePoll) where many parties compute mean and variance over their inputs. We tested
this for 250 parties (with a circuit size of 2253 multiplication gates) and 500 parties (with a
circuit size of 4503 multiplication gates). We ran this experiment on c4.large machines in
AWS, in a single region. The execution for 250 parties took 2:30 minutes and the execution
of 500 parties took 6:15 minutes. Although not extremely fast, these results do demon-
strate that it is possible to run MPC with a very large number of parties. To the best of
our knowledge, this is the largest number of parties run in any MPC experiment to date.
37
Acknowledgements
We thank Zuzana Trubini (Beerliov´a) and Daniel Tschudi for helpful discussion, and Hila
Dahari and Meital Levy for their contribution to the implementation of HyperMPC.
References
[1] T. Araki, J. Furukawa, Y. Lindell, A. Nof and K. Ohara. High-Throughput Semi-
Honest Secure Three-Party Computation with an Honest Majority. In the 23rd ACM
CCS, pages 805–817, 2016.
[2] T. Araki, A. Barak, J. Furukawa, T. Lichter, Y. Lindell, A. Nof, K. Ohara, A. Watz-
man and O. Weinstein. Optimized Honest-Majority MPC for Malicious Adversaries
– Breaking the 1 Billion-Gate Per Second Barrier. In the 38th IEEE Symposium on
Security and Privacy, pages 843–862, 2017.
[3] D. Beaver.
Eﬃcient Multiparty Protocols Using Circuit Randomization.
In
CRYPTO’91, Springer (LNCS 576), pages 420–432, 1991.
[4] M. Ben-Or, S. Goldwasser and A. Wigderson. Completeness Theorems for Non-
Cryptographic Fault-Tolerant Distributed Computation. In the 20th STOC, pages
1–10, 1988.
[5] Z. Beerliova-Trubiniova and M. Hirt. Perfectly-Secure MPC With Linear Communi-
cation Complexity. In TCC 2008, Springer (LNCS 4948), pages 213–230, 2008.
[6] D. Bogdanov, S. Laur and J. Willemson. Sharemind: A Framework for Fast Privacy-
Preserving Computations. In the 13th ESORICS, Springer (LNCS 5283), pages 192–
206, 2008.
[7] G. Bracha. An Asynchronous (cid:98)(n − 1)/3(cid:99)-Resilient Consensus Protocol. In the 3rd
PODC, pages 154–162, 1984.
[8] R. Canetti. Security and Composition of Multiparty Cryptographic Protocols. In the
Journal of Cryptology, 13(1):143–202, 2000.
[9] R. Canetti. Universally Composable Security: A New Paradigm for Cryptographic
Protocols. In the 42nd FOCS, pages 136–145, 2001.
[10] K. Chida, D. Genkin, K. Hamada, D. Ikarashi, R. Kikuchi, Y. Lindell and A. Nof. Fast
Large-Scale Honest-Majority MPC for Malicious Adversaries. To appear at CRYPTO
2018.
38
[11] I. Damg˚ard, M. Geisler, M. Krøigaard and J.B. Nielsen. Asynchronous Multiparty
Computation: Theory and implementation. In PKC 2009, Springer (LNCS 5443),
pages 160–179, 2009.
[12] I. Damg˚ard, M. Keller, E. Larraia, V. Pastro, P. Scholl and N.P. Smart. Practical
Covertly Secure MPC for Dishonest Majority – Or: Breaking the SPDZ Limits. In
the 18th ESORICS, Springer (LNCS 8134), pages 1–18, 2013.
[13] I. Damg˚ard and J.B. Nielsen. Scalable and Unconditionally Secure Multiparty Com-
putation. In CRYPTO 2007, Springer (LNCS 4622), pages 572–590, 2007.
[14] I. Damg˚ard, V. Pastro, N.P. Smart and S. Zakarias. Multiparty Computation From
In CRYPTO 2012, Springer (LNCS 7417),
Somewhat Homomorphic Encryption.
pages 643–662, 2012.
[15] O. Goldreich, S. Micali and A. Wigderson. How to Play Any Mental Game — a
In the 19th STOC,
Completeness Theorem for Protocols With Honest Majority.
pages 218–229, 1987.
[16] M. Hirt, U. Maurer and B. Przydatek. Eﬃcient Secure Multi-Party Computation.
In ASIACRYPT 2000, Springer (LNCS 1976), pages 143–161, 2000.
[17] Y. Huang, P. Chapman and D. Evans. Secure Computation on Mobile Devices. In
IEEE S&P Poster Session, 2011.
[18] M. Keller, E. Orsini and P. Scholl. MASCOT: Faster Malicious Arithmetic Secure
Computation With Oblivious Transfer. In the 23rd ACM CCS, pages 830–842, 2016.
[19] E. Kushilevitz, Y. Lindell and T. Rabin. Information-Theoretically Secure Protocols
and Security Under Composition. In the 38th STOC, pages 109–118, 2006.
[20] A. Lapets, E. Dunton, K. Holzinger, F. Jansen and A. Bestavros. Web-Based
Multi-Party Computation With Application to Anonymous Aggregate Compensation
Analytics. http://www.bu.edu/today/2016/gender-pay-equity/, 2017. See also
http://www.cs.bu.edu/techreports/pdf/2015-009-mpc-compensation.pdf.
[21] Y. Lindell and A. Nof. A Framework for Constructing Fast MPC over Arithmetic
Circuits with Malicious Adversaries and an Honest-Majority. In the 24th ACM CCS,
pages 259–276, 2017.
[22] Y. Lindell and B. Riva. Blazing Fast 2PC in the Oﬄine/online Setting With Security
for Malicious Adversaries. In 22nd ACM CCS, pages 579–590, 2015.
[23] P. Mohassel, M. Rosulek and Y. Zhang. Fast and Secure Three-Party Computation:
The Garbled Circuit Approach. In the 22nd ACM CCS, pages 591–602, 2015.
39
[24] J.B. Nielsen, P.S. Nordholt, C. Orlandi and S.S. Burra. A New Approach to Practical
Active-Secure Two-Party Computation. In CRYPTO 2012, Springer (LNCS 7417),
pages 681–700, 2012.
[25] J.B. Nielsen, T. Schneider and R. Triﬁletti. Constant Round Maliciously Secure 2PC
With Function-Independent Preprocessing Using LEGO. IACR Cryptology ePrint
Archive, 2016.
[26] T. Rabin and M. Ben-Or. Veriﬁable Secret Sharing and Multiparty Protocols With
Honest Majority. In the 21st STOC, pages 73–85, 1989.
[27] A. Shamir. How to Share a Secret. Communications of the ACM, 22:612–613, 1979.
[28] X. Wang, A.J. Malozemoﬀ and J. Katz. Faster Secure Two-Party Computation in
the Single-Execution Setting. In EUROCRYPT 2017, Springer (LNCS 10210), pages
399–424, 2017.
[29] WebAssembly, https://developer.mozilla.org/en-US/docs/WebAssembly.
[30] Web Cryptography API, https://www.w3.org/TR/WebCryptoAPI/.
[31] Web
Sockets,
WebSockets_API.
https://developer.mozilla.org/en-US/docs/Web/API/
[32] Web Workers,
https://developer.mozilla.org/en-US/docs/Web/API/Web_
Workers_API/Using_web_workers.
[33] A. Yao. How to Generate and Exchange Secrets. In the 27th FOCS, pages 162–167,
1986.
A Challenges for End-User Implementation
We list the challenges we found and solved for running in each platform:
ARM for Raspberry Pi IOT and Mobile: We used a Raspberry Pi3 with a quad-core
1.2Ghz ARM 7a processor, and Android mobiles. These are common and cheap devices
used widely. Deploying MPC on this platform involved solving the following issues:
1. No Intel SIMD: Existing MPC code heavily uses SIMD instructions from SSE2, SSE4,
and AVX2 extensions for fast operations; e.g., fast OT implementations use _mm_movemask_epi8
and _mm_slli_epi64 for Bit Matrix Transposition. We used an open source library
SSE2NEON to bridge the gap, and extended SSE2NEON to support missing instruc-
tions with good performance.
40
2. Limited compiler support: ARM compilers are limited in some of the advanced features of
C++ 14, for example with template instantiations. We backported code from C++14 to
C+11 to make these libraries work correctly. We also built a cross-compile environment
to compile our code simultaneously to all platforms in a Linux build environment.
3. Limited library support: Typical MPC code uses gmp, NTL, libmiracl math libraries
and in some cased boost for communication. We created valid builds for these libraries.
However, not all NTL functionality (used by our code) is available on all platforms (we
ported up to NTL 9.7).
We are now working on ports to energy-constraint IOT environments with even less pow-
erful boards.
MPC In-The-Browser: As the browser is becoming the new OS for end users, additional
features and capabilities are constantly added, such as access to device (orientation, loca-
tion), new Web Cryptography API [30], and WebAssembly [29]. These open the possibility
of achieving high performance MPC directly in the browser. While writing plain Javascript
code is an option, it would require a major rewrite to MPC protcols. Our solution is to
cross-compile MPC code to WebAssembly. We have achieved this for the HyperMPC
protocol described in Section 3.1.3 and all required libraries. WebAssembly (abbreviated
Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed
as a portable target for compilation of high-level languages like C/C++/Rust, enabling
deployment on the web for client and server applications. Wasm is currently supported
by all major browsers. The design goal of Wasm is a 2x Slowdown compared to native
code. Wasm can interact with additional Javascript libraries, and is executed under the
Same-Origin-Policy of the page from which it loaded. We dealt with the following issues:
1. Code porting: We ported our C++ code to Wasm using Emscripten 1.37 without in-
troducing design changes to the protocol. Our method is generic and can be applied
to any additional MPC protocol. Emscripten is a compiler that runs as a backend to
the LLVM compiler and produces a asm.js / WebAssembly. Emscripten has been used
to port Python, Lua, libsodium, SQLite, Unreal Engine 3 and several other code bases.
To run our MPC code in the browser, we ported the relevant math libraries (NTL,
gmp, mpir) and our protocol code. The compiled JavaScript code executes either in the
browser, or in a Node.js server. Integration into Node.js is also an important outcome,
as MPC can now be delivered through the NPM package manager.
2. Asynchronous communication: Emscripten automatically ports C/C++ sockets to the
WebSockets protocol [31], and we tweaked this to work for our scenario. However, most
open source implementations of MPC use synchronous socket communication, with a
thread-per-peer model, and with “send”–“receive” pairs representing round exchanges,
with send-receive replaced with receive-send based on a role or id in order to avoid
deadlock. This simplistic model is not applicable in a Web Browser, as all socket and I/O
41
in general is asynchronous. Javascript is asynchronous by-design, and we were unable to
use the standard MPC send-receive pattern, even using Web Workers [32]. We therefore
had to re-design our protocol code to use a state-machine and asynchronous-IO, with
a state-machine per-peer. We use the Emscripten capability to create a Virtual File
System in memory to load circuit, input and conﬁguration ﬁles in the same manner as
used today by our protocol.
3. SIMD instructions: WebAssembly does not currently support SIMD instructions. Thus,
these instructions need to be replaced.
See Figure 14 for a screen-shot of the protocol of Section 3.1.3 running in a browser.
Figure 14: The MPC in the browser view.
42