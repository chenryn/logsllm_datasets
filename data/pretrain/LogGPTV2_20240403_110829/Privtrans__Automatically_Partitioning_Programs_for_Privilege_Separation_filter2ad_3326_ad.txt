Windows.
However, the implementation of the wrappers may have
to be customized depending upon the interfaces sup-
ported by the OS. Last, our new system call that allows
a process to change the privilege of it’s children is not
portable. Previous research has addressed this issue, as
detailed below, and we do not duplicate their work.
Potential issues and solutions. There are several is-
sues for privilege separation. Note many of these issues
are not speciﬁc to our approach, and apply to any privi-
lege separation approach.
The setuid and getuid-style routines may not behave as
expected in the original program. For example, since the
privilege-separated version drops all privileges immedi-
ately, a call to getuid will return the uid of the unprivi-
leged user. This may break programs that expect to be
setuid and checks for certain privileges through the ge-
tuid call. In our approach we changed getuid-style calls
to return the uid of the monitor. setuid calls should simi-
larly change the uid of the monitor, not the slave.
File descriptor numbering will also be different due to
the socket between the slave and monitor. For example,
with the select call the ﬁrst argument is an integer in-
dicating the highest number ﬁle descriptor to check for
a change in status. If the slave asks the the monitor to
perform a select call, the highest ﬁle descriptor ar-
gument supplied by the slave may not coincide with the
correct ﬁle descriptor in the monitor. To solve this prob-
lem select calls should be rewritten as poll, since
the poll call contains the list of actual ﬁle descriptors
to check for a change in status.
with ﬁle descriptors owned by the monitor and the slave,
which must be distinguished. Our opaque identiﬁers start
at 100, so we can distinguish between a ﬁle descriptor
owned by the slave, which will be less than 100, and one
owned by the monitor, which will be over 100.
We do not perform any pointer alias analysis. This leads
to two potential problems. First, there may be a pointer
in the slave to an opaque index, which is later used in an
operation. We cannot know of such an operation without
full pointer analysis. Second, since we don’t know the
liveliness of pointers we do not know when it is safe to
free a variable in the monitor. Thus the monitor never
frees memory for a privileged value. In our experience,
neither has been a problem, i.e. the slave never tried to
use a opaque identiﬁer and the monitor’s memory usage
was modest.
Last, there is no simple way for a program that accu-
mulates state as the unprivileged user to become another
user. To solve this problem, we created a system call that
allows a superuser process to change the uid of any run-
ning process, and a non-superuser process to change the
uid of any of it’s slaves. This system call makes sense:
a superuser process could always run a program itself,
granting the necessary privileges. The disadvantage of
this approach is our system call is system-speciﬁc. Other
portable but more complex techniques are explored by
Kilpatrick [18] and Provos et al [28].
6 Related work
also reported issues
Previous work has
around
fork [18]. For example, consider a ﬁle descriptor
opened by the monitor for a slave. Suppose the slave
forks off a new child process, which asks the monitor to
close the ﬁle descriptor. In the slave the parent process
expects the ﬁle descriptor open, while the child expects
to have the ﬁle descriptor closed. Thus, with privilege
separation, we must distinguish in the monitor between
the ﬁle descriptors owned by the child process in the
slave from the parent process in the slave. Our solution
is to fork off a new monitor when a new slave is forked.
While privilege separation can drastically reduce the
number of operations executed with privileges, it is even
more important to write applications securely from cre-
ation. Programs should be developed with the principle
of least privilege, which states every operation should be
executed with the minimum number of privileges [29].
VSFTPD [13] and Postﬁx [36] use separate processes to
limit the damage from a programming error. Both pro-
grams were created from the ground up following the
principle of least privilege.
Another important issue is resolving which elements of
a collection data structure contain privileged and unpriv-
ileged data, such as an array that contains both types.
The opaque identiﬁer returned during privileged data cre-
ation can help identiﬁcation, even though this may not
work in all cases. For example, in thttpd poll() is called
Provos et al. demonstrated the value of privilege separa-
tion in OpenSSH [28]. However, they manually edited
OpenSSH to incorporate privilege separation. When
privilege separation is enabled, OpenSSH resists several
attacks [8, 23, 24]. Our technique entails automatic priv-
ilege separation.
Privman [18], a library for partitioning applications, pro-
vides an API a programmer can use to integrate privilege
separation. However, the library can only make autho-
rization decisions, and cannot be used for ﬁne-grained
policies. Further, the programmer must manually edit the
source at every call point to use the corresponding Priv-
man equivalent. Our method uses data ﬂow techniques
to ﬁnd the proper place to insert calls to the monitor, and
allows for ﬁne-grained policies.
exist
Several different mechanisms
for dynami-
cally checking system calls such as Systrace [27],
GSWTK [14], Tron [5], Janus [16], and MAPbox [1].
Dynamically checking system calls does not allow for
ﬁne-grained policies on regular function calls, although
this technique does not require program source code.
Another drawback is that dynamic techniques cannot
optimize the number of checks. Our approach works for
arbitrary function calls, allows for ﬁne-grained policies,
and optimizes the number of expensive calls to the
monitor.
Type qualiﬁer propagation has been used to ﬁnd bugs in
C programs [32, 42] . We use attributes as type qual-
iﬁers, and use them to guide rewriting the code. Type
qualiﬁers are used to identify potentially sensitive data
in Scrash [7]. CIL is used in this work to rewrite the ap-
plication so that sensitive data may be removed from a
core ﬁle.
JFlow/JIF [21, 41, 43] and Balfanz [4] show how to par-
tition applications by trust level in Java. Since Java is
type-safe it is less vulnerable to malicious attacks. In-
stead, JFlow/JIF and Balfanz focus on preventing unin-
tentionally leaking information in a program.
Operating system mechanisms [3, 25, 39] can provide
ways to reduce the privileges of applications. However,
these mechanisms do not have access to the internals of
a program, and thus cannot be used for arbitrary function
calls as with privilege separation.
Static analysis can be used to ﬁnd bugs in programs [9,
12, 11, 19, 32, 37, 42]. Our goals are different: we wish
to limit the damage from an unknown bug. However, we
use static analysis as a tool to automatically ﬁnd privi-
leged operations.
7 Conclusion
We have shown how to automatically integrate privi-
lege separation into source code. We consider a strong
model of privilege separation where accessing privileged
resources is relegated to the monitor. The monitor can
enforce policies on data derived from a privileged re-
source in addition to access control. Our tool Privtrans
uses static techniques to rewrite the C code, and inserts
dynamic checks to reduce overhead. Privtrans requires
only a few annotations from the programmer, typically
fewer than 5.
We ran Privtrans on several open-source programs suc-
cessfully. Privilege separation has unique beneﬁts for
each program. The overhead due to privilege separation
was reasonable. Thus, Privtrans is applicable to a wide
variety of applications.
8 Acknowledgements
We would like to thank Niels Provos for helpful discus-
sions, comments, and thoughts regarding our work. We
would also like to thank Lujo Bauer, Robert Johnson,
James Newsome, David Wagner, Helen Wang, and the
annonymous reviewers for their helpful comments while
preparing this paper.
References
[1] A. Acharya and M. Raje. MAPbox: Using parame-
terized behavior classes to conﬁne applications. In
the Proceedings 9th USENIX Security Symposium,
2000.
[2] American National Standards Institute (ANSI). Ra-
tionale for International Standard – Programming
Languages – C, October 1999.
[3] Lee Badger, Daniel Sterne, and David Sherman. A
domain and type enforcement unix prototype.
In
the Proceedings of the 5th USENIX Security Sym-
posium, 1995.
[4] Dirk Balfanz. Access Control for Ad-hoc Collabo-
ration. PhD thesis, Princeton University, 2001.
[5] Andrew Berman, Virgil Bourassa, and Erik Sel-
berg. Tron: Process-speciﬁc ﬁle protection for the
In the Proceedings of the
unix operating system.
USENIX Technical Conference on UNIX and Ad-
vanced Computing Systems, 1995.
[17] Brian Hatch and the stunnel development team.
http://www.stunnel.org,
stunnel 4.04.
2004.
[6] Marc Bevand. OpenBSD chpass/chfn/chsh ﬁle con-
tent leak. http://www.opennet.ru/base/
bsd/1044293885_871.txt.html, 2003.
[18] Douglas Kilpatrick. Privman: A library for parti-
tioning applications. In the Proceedings of Freenix
2003, 2003.
[7] Pete Broadwell, Matt Harren, and Naveen Sastry.
Scrash: A system for generating security crash in-
formation. In the Proceedings of the 12th USENIX
Security Symposium, 2003.
[19] David Larochelle and David Evans. Statically de-
tecting likely buffer overﬂow vulnerabilities. In the
Proceedings of the 10th USENIX Security Sympo-
sium, 2001.
[8] CERT/CC. CERT advisory CA-2003-24 buffer
management vulnerability in OpenSSH, September
2003.
[9] Hao Chen and David Wagner. MOPS: an infras-
tructure for examining security properties of soft-
ware. In the Proceedings of the ACM Conference
on Computer and Communications Security 2002,
2002.
[10] David Dittrich.
The Tribe Flood Network
tool.
of
service
attack
denial
distributed
staff.washington.edu/dittrich/
misc/tfn.analysis, 1999.
[11] Dawson Engler, Benjamin Chelf, Andy Chou, and
Seth Hallem. Checking system rules using system-
speciﬁc programmer-written compiler extensions.
In the Proceedings of the Operating Systems De-
sign and Implementation (OSDI), 2000.
[12] Dawson Engler, David Chen, Seth Hallem, Andy
Chou, and Benjamin Chelf. Bugs as deviant behav-
ior: A general approach to inferring errors in sys-
tems code. In the Proceedings of the Symposium on
Operating System Principles, 2001.
[13] Chris Evans. Very secure ftp daemon. http://
vsftpd.beasts.org.
[14] Timothy Fraser, Lee Badger, and Mark Feldman.
Hardening COTS software with generic software
wrappers. In the Proceedings of the IEEE Sympo-
sium on Security and Privacy, pages 2–16, 1999.
[15] Jonathon Gifﬁn, Somesh Jha, and Barton Miller.
Detecting manipulated remote call streams. In the
Proceedings of the 11th USENIX Security Sympo-
sium, 2002.
[16] Ian Goldberg, David Wagner, Randi Thomas, and
Eric A. Brewer. A secure environment for untrusted
helper applications. In the Proceedings of the 6th
USENIX Security Symposium, San Jose, CA, USA,
1996.
[20] Andries Brouwer (Maintainer). util-linux version
2.11y. RedHat RPMS.
[21] Andrew Myers. Jﬂow: Practical mostly-static in-
formation ﬂow control. In the Proceedings of the
Symposium on Principles of Programming Lan-
guages, 1999.
[22] George Necula, Scott McPeak, S. Rahul, and West-
ley Weimer. CIL: Intermediate language and tools
for analysis and transformation of C programs. In
Conference on Compiler Construction, 2002.
[23] OpenSSH. Buffer overﬂow in AFS/Kerberos token
passing code. http://www.openssh.org/
security.html, April 2002.
[24] OpenSSH. Openssh remote challenge vulnerability.
http://www.openssh.org/security.
html, June 2002.
[25] David Peterson, Matt Bishop, and Raju Pandey.
A ﬂexible containment mechanism for executing
untrusted code.
In the Proceedings of the 11th
USENIX Security Symposium, 2002.
[26] Jef Poskanzer.
thttpd. http://www.acme.
com/software/thttpd/.
[27] Niels Provos.
Improving host security with sys-
In the Proceedings of the 12th
tem call policies.
USENIX Security Symposium, 2003.
[28] Niels Provos, Markus Friedl, and Peter Honeyman.
Preventing privilege escalation. In the Proceedings
of the 12th USENIX Security Symposium, 2003.
[29] Jerome Saltzer. Protection and the control of infor-
mation in multics. In Communications of the ACM,
July 1976.
[30] Fred Schneider. Enforceable security policies. In-
formation and System Security, 3(1):30–50, 2000.
Proceedings of the 2003 IEEE Symposium on Secu-
rity and Privacy, 2003.
[31] securiteam.com. Linux ’util-linux’ chfn local root
vulnerability.
http://www.securiteam.
com/unixfocus/5EP0V007PK.html, 2002.
[32] Umesh Shankar, Kunal Talwar, Jeffrey Foster, and
David Wagner. Detecting format-string vulnerabil-
ities with type qualiﬁers. In the Proceedings of the
10th USENIX Security Symposium, 2001.
[33] OpenSSH Development Team. Openssh 3.1.1p1 for
linux. www.openssh.org.
[34] OpenSSL Development Team. Openssl 0.9.7c.
http://www.openssl.org, 2004.
[35] R. Sekar P Uppuluri. Synthesizing fast intrusion
prevention/detection systems from high-level spec-
iﬁcations.
In the Proceedings of the 8th USENIX
Security Symposium, 1999.
[36] Wietse Venema. Postﬁx overview. http://www.
postfix.org/motivation.html.
[37] David Wagner, Jeffrey Foster, Eric Brewer, and
Alexander Aiken. A ﬁrst step towards automated
detection of buffer overrun vulnerabilities.
In the
Proceedings of the ISOC Symposium on Network
and Distributed System Security, 2000.
[38] Robert Wahbe, Steven Lucco, Thomas Anderson,
and Susan Graham. Efﬁcient software-based fault
isolation. In the Proceedings of the Symposium on
Operating System Principles (SOSP), 1993.
[39] Kenneth Walker, Daniel Sterne, and Lee Badger.
Conﬁning root programs with domain and type en-
forcement (DTE).
In the Proceedings of the 6th
USENIX Security Symposium, 1996.
[40] John Whaley, Michael Martin, and Monica Lam.
Automatic extraction of object-oriented component
interfaces.
In the Proceedings of the Interna-
tional Symposium on Software Testing and Analy-
sis, 2002.
[41] Steve Zdancewic, Lantian Zheng, Nathaniel Nys-
trom, and Andrew Myers. Secure program par-
titioning.
In Transactions on Computer Systems,
2002.
[42] Xiaolan Zhang, Antony Edwards, and Trent Jaeger.
Using CQual for static analysis of authorization
hook placement.
In the Proceedings of the 11th
USENIX Security Symposium, 2002.
[43] Lantian Zheng, Stephen Chong, Andrew Myers,
and Steve Zdancewic. Using replication and par-
titioning to build secure distributed systems. In the