in [14] without proof of security. Attacks relying on key/IV
reuse were described in [15], [16]. Fig. 4 is somewhat
nonstandard, as it includes the IV (ğ‘0, ğ‘š0) as part of the key
material. However, in this work, we only require one-time
security of SE, so keys and IVs are generated together and the
IV is not included as part of the ciphertext.
IGE[E].Enc(ğ‘˜, ğ‘š)
For ğ‘– = 1, . . . , ğ‘¡ do
âŠ•ğ‘šğ‘–âˆ’1
Return ğ‘1 (cid:107) . . . (cid:107) ğ‘ğ‘¡
ğ‘ğ‘– â† E.Ev(ğ¾, ğ‘šğ‘– âŠ• ğ‘ğ‘–âˆ’1)
IGE[E].Dec(ğ‘˜, ğ‘)
For ğ‘– = 1, . . . , ğ‘¡ do
âŠ•ğ‘ğ‘–âˆ’1
Return ğ‘š1 (cid:107) . . . (cid:107) ğ‘šğ‘¡
ğ‘šğ‘– â† E.Inv(ğ¾, ğ‘ğ‘– âŠ• ğ‘šğ‘–âˆ’1)
Figure 4: Construction of IGE[E] as SE from block cipher E. Let
ğ‘¡ be the number of blocks of ğ‘š (or ğ‘), i.e. ğ‘š = ğ‘š1 (cid:107) . . . (cid:107) ğ‘šğ‘¡.
Parse ğ¾ (cid:107) ğ‘0 (cid:107) ğ‘š0 â† ğ‘˜ where |ğ¾| = E.kl, |ğ‘0| = |ğ‘š0| = E.ol.
8) SHA hash functions: Let SHA-1 : {0, 1}âˆ— â†’ {0, 1}160
and SHA-256 : {0, 1}âˆ— â†’ {0, 1}256 be the hash functions
: {0, 1}160 Ã— {0, 1}512 â†’ {0, 1}160
of [17] and let â„160
and â„256 : {0, 1}256 Ã— {0, 1}512 â†’ {0, 1}256 be their com-
pression functions. Let SHACAL-1 [18] be the block cipher
deï¬ned by SHACAL-1.kl = 512, SHACAL-1.ol = 160 and
â„160(ğ‘˜, ğ‘¥) = ğ‘˜ Ë†+ SHACAL-1.Ev(ğ‘¥, ğ‘˜), where Ë†+ is a modular
addition over 32-bit words. Let SHACAL-2 be the block cipher
deï¬ned by SHACAL-2.kl = 512, SHACAL-2.ol = 256 and
â„256(ğ‘˜, ğ‘¥) = ğ‘˜ Ë†+ SHACAL-2.Ev(ğ‘¥, ğ‘˜).
III. Bidirectional channels
A. Our formal model in context of prior work
We model Telegramâ€™s MTProto protocol as a bidirectional
cryptographic channel. A channel provides a method for two
users to exchange messages, and it is bidirectional [19] when
both users can send and receive messages. There is a signiï¬cant
body of prior work on primitives that can be thought of as
special cases of a bidirectional channel, building on the early
work of [20] which introduced stateful security notions for
symmetric encryption and used them to analyse SSH. MTProto
uses distinct but related secret keys to send messages in the
opposite directions on the channel, so the simpler primitives
are not sufï¬cient for our analysis.
MTProto cryptographically enforces a complex set of rules
regarding the order in which messages can be decrypted,
allowing out-of-order delivery. Channels are normally required
to satisfy the strongest possible integrity notion, ensuring
strict in-order delivery. But some prior work considers relaxed
integrity requirements, deï¬ning security notions that permit
message replay, reordering, or omission [20], [21], [22]. Fine-
grained message delivery rules are captured in [23]. A more
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:21:42 UTC from IEEE Xplore.  Restrictions apply. 
90
powerful framework for robust channels is deï¬ned in [8]. None
of this work targets bidirectional channels.
We extend the framework of [8], lifting it to the bidirectional
setting. Most notably, our framework uses more information
to make the support decisions. These decisions are based on
per-user communication transcripts. For each sent or received
ciphertext, a userâ€™s transcript includes a plaintext-ciphertext
pair, where one of them can be âŠ¥ to denote a failure. Keeping
track of failures allows us to capture ï¬ne-grained notions of
robustness; keeping track of plaintexts allows to deï¬ne simpler
security deï¬nitions. In the full version of this work we provide
a detailed comparison between our framework and that of [8].
B. Deï¬nitions of channels and support functions
We refer to the two users of a channel as I and R. These
will map to client and server in the setting of MTProto. We
use u âˆˆ {I, R} as a variable to represent an arbitrary user
and u to represent the other user, meaning u denotes the sole
element of {I, R} \ {u}. We use stu to represent the internal
state of user u.
Deï¬nition 1. A channel CH speciï¬es algorithms CH.Init,
CH.Send and CH.Recv, where CH.Recv is deterministic. Asso-
ciated to CH is a plaintext space CH.MS and a randomness
space CH.SendRS of CH.Send. The initialisation algorithm
CH.Init returns Iâ€™s and Râ€™s initial states stI and stR. The
sending algorithm CH.Send takes stu for some u âˆˆ {I, R}, a
plaintext ğ‘š âˆˆ CH.MS, and auxiliary information aux to return
the updated state stu and a ciphertext ğ‘, where ğ‘ =âŠ¥ may be
used to indicate a failure to send. We may surface random
coins ğ‘Ÿ âˆˆ CH.SendRS as an additional input to CH.Send.
The receiving algorithm CH.Recv takes stu, ğ‘ and auxiliary
information aux to return the updated state stu and a plaintext
ğ‘š âˆˆ CH.MS âˆª {âŠ¥}, where âŠ¥ indicates a failure to recover a
plaintext. The syntax used for the algorithms of CH is given in
Fig. 5.
(stI , stR) â†$ CH.Init()
(stu, ğ‘) â† CH.Send(stu, ğ‘š, aux; ğ‘Ÿ)
(stu, ğ‘š) â† CH.Recv(stu, ğ‘, aux)
Figure 5: Syntax of the constituent algorithms of channel CH.
The abstract auxiliary information ï¬eld aux will be used
to associate timestamps to each sent and received message. It
should not be thought of as an associated data that needs to
be authenticated; we do not model associated data.
We deï¬ne a support transcript to represent a record of all
messages sent and received by a single user on a channel. Each
transcript entry includes a plaintext ğ‘š and a label (denoted
by label); we use labels to distinguish between exchanged
user messages that encrypt or encode different plaintexts.
Depending on the level of abstraction, for any ğ‘š we will
use the corresponding ciphertext or message encoding as its
label.4 But we will make use only of the equality patterns that
4This will be a ciphertext ğ‘ when channel security notions are considered.
This will be a message encoding ğ‘ when properties of the message encoding
schemes (deï¬ned in Section III-D) are considered.
arise between labels, not of the exact values. Transcripts can
include entries with plaintexts ğ‘š = âŠ¥ to capture that a received
message was rejected. This allows us to model a range of
channel behaviours in the event of an error (from terminating
after the ï¬rst error to full recovery). Transcript entries can also
include label =âŠ¥, e.g. to indicate that a plaintext could not be
sent over a terminated channel.
Deï¬nition 2. A support transcript tru for user u âˆˆ {I, R} is
a list of entries of the form (op, ğ‘š, label, aux), where op âˆˆ
{sent, recv}. An entry with op = sent indicates that user u
attempted to send a message that encrypts or encodes plaintext
ğ‘š with auxiliary information aux, associated to label. An
entry with op = recv indicates that user u received a message
associated to label with auxiliary information aux, and used
it to recovered plaintext ğ‘š.
We deï¬ne a support function supp that uses user support
transcripts to determine whether a user u âˆˆ {I, R} should
accept an incoming message from u that is associated to label.
If the message should be accepted, then supp must return
a plaintext ğ‘šâˆ— to indicate that u is expected to recover ğ‘šâˆ—
from the incoming message; otherwise supp must return âŠ¥ to
indicate that the message is expected to be rejected. We also
let supp take the auxiliary information aux as input so that
timestamps can be captured in our deï¬nitions.
Deï¬nition 3. A support function supp is a function with syntax
supp(u, tru, tru, label, aux) â†’ ğ‘šâˆ— where u âˆˆ {I, R}, and tru,
tru are support transcripts for users u and u. It indicates that,
according to the transcripts, user u is expected to recover
plaintext ğ‘šâˆ— from the incoming message that is associated to
label with auxiliary information aux.
A support function does not take a channelâ€™s state informa-
tion as input, so it can only rely on equality patterns between
labels across the transcripts of both users. This is sufï¬cient
to specify message delivery rules that can capture attempted
forgeries, replays, reordering and omissions.5 Thus we will
use support functions to specify the permissible adversarial
behaviour on the network that should be supported by a channel.
In the full version of this work we formalise two correctness
properties of a support function supp, but we do not mandate
that they must always be met. Both properties were also
considered in [8]. The order correctness requires that in-order
delivery is supported in either direction if each message is
assigned a distinct label.6 The integrity of supp requires that
it always returns âŠ¥ if the queried label does not appear in tru.
C. Correctness and security of channels
For the following properties, consider the games in Fig. 6. We
allow the adversary to control the randomness used by CH.Send.
We show our games to be equivalent to an authenticated
encryption style security notion for channels in the full version
of this work.
5For example, the supp. function in Fig. 23 mandates strict in-order delivery.
6[8] deï¬nes this notion as a part of the channel correctness game. We note
that this notion cannot be met by some non-robust channels, e.g. those that
close the connection once a number of errors occur.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:21:42 UTC from IEEE Xplore.  Restrictions apply. 
91
CH,supp,F
Game Gcorr
win â† false ; (stI , stR) â†$ CH.Init()
F Send,Recv(stI , stR) ; Return win
Send(u, ğ‘š, aux, ğ‘Ÿ)
(stu, ğ‘) â† CH.Send(stu, ğ‘š, aux; ğ‘Ÿ)
tru â† tru (cid:107) (sent, ğ‘š, ğ‘, aux) ; Return ğ‘
Recv(u, ğ‘, aux)
ğ‘šâˆ— â† supp(u, tru, tru, ğ‘, aux)
If ğ‘šâˆ— = âŠ¥ then return âŠ¥
(stu, ğ‘š) â† CH.Recv(stu, ğ‘, aux)
tru â† tru (cid:107) (recv, ğ‘š, ğ‘, aux)
If ğ‘šâˆ— â‰  ğ‘š then win â† true
Return ğ‘š
CH,supp,F
Game Gint
win â† false ; (stI , stR) â†$ CH.Init()
F Send,Recv ; Return win
Send(u, ğ‘š, aux, ğ‘Ÿ)
(stu, ğ‘) â† CH.Send(stu, ğ‘š, aux; ğ‘Ÿ)
tru â† tru (cid:107) (sent, ğ‘š, ğ‘, aux) ; Return ğ‘
Recv(u, ğ‘, aux)
(stu, ğ‘š) â† CH.Recv(stu, ğ‘, aux)
ğ‘šâˆ— â† supp(u, tru, tru, ğ‘, aux)
tru â† tru (cid:107) (recv, ğ‘š, ğ‘, aux)
If ğ‘š â‰  ğ‘šâˆ— then win â† true
Return ğ‘š
CH,D
Game Gind
ğ‘ â†$ {0, 1} ; (stI , stR) â†$ CH.Init()
ğ‘(cid:48) â†$ DCh,Recv ; Return ğ‘(cid:48) = ğ‘
Ch(u, ğ‘š0, ğ‘š1, aux, ğ‘Ÿ)
If |ğ‘š0| â‰  |ğ‘š1| then return âŠ¥
(stu, ğ‘) â† CH.Send(stu, ğ‘šğ‘, aux; ğ‘Ÿ)
Return ğ‘
Recv(u, ğ‘, aux)
(stu, ğ‘š) â† CH.Recv(stu, ğ‘, aux)
Return âŠ¥
Figure 6: Correctness of channel CH; integrity of channel CH; indistinguishability of channel CH.
CH,supp(F) = Pr[Gcorr
1) Correctness: Consider adversary F in game Gcorr
CH,supp,F
associated to a channel CH and a support function supp. The
advantage of F in breaking the correctness of CH with respect
CH,supp,F]. The
to supp is deï¬ned as Advcorr
game initialises users I and R. The adversary is given their
initial states and gets access to a sending oracle Send and to
a receiving oracle Recv. Calling Send(u, ğ‘š, aux, ğ‘Ÿ) encrypts
the plaintext ğ‘š with auxiliary data aux and randomness ğ‘Ÿ from
user u to the other user u; the resulting tuple (sent, ğ‘š, ğ‘, aux)
is added to the senderâ€™s transcript tru. Recv can only be
called on honestly produced ciphertexts, meaning it exits
when supp returns ğ‘šâˆ— â‰ âŠ¥. Calling Recv(u, ğ‘, aux) thus
recovers the plaintext ğ‘šâˆ— from the support function, decrypts
the corresponding ciphertext ğ‘ and adds (recv, ğ‘š, ğ‘, aux) to
the receiverâ€™s transcript tru; the game veriï¬es that the recovered
plaintext ğ‘š is equal to the originally encrypted plaintext ğ‘šâˆ—.
If the adversary can cause the channel to output a different
ğ‘š, then the adversary wins. This game captures the minimal
requirement one would expect from a communication channel:
honestly sent ciphertexts should decrypt to the correct plaintexts.
It is similar in spirit to the correctness game of [8].
2) Integrity: Consider adversary F in game Gint
CH,supp,F
associated to a channel CH and a support function supp. The
advantage of F in breaking the integrity of CH with respect
CH,supp,F]. The
to supp is deï¬ned as Advint
adversary gets access to oracles Send and Recv (but not
to the usersâ€™ states). Both calls proceed as in the correctness
game except that now Recv does not limit F to querying
only honestly produced ciphertexts. This captures the intuition
that the adversary can manipulate ciphertexts on the network
in an attempt to create a forgery. Take supp(u, tru, tru, ğ‘, aux)
that returns ğ‘šâˆ— iff (sent, ğ‘šâˆ—, ğ‘, aux) âˆˆ tru, and returns âŠ¥
otherwise. Then integrity with respect to supp mandates that a
conventional ciphertext forgery is impossible, but all ciphertext
replays, reordering, and omissions are permitted by the channel.
3) Conï¬dentiality: Consider adversary D in game Gind
CH,D
associated to a channel CH. The advantage of D in breaking
CH (D) = 2 Â·
the IND-security of CH is deï¬ned as Advind
Pr[Gind
CH,D] âˆ’ 1. The adversary can query the challenge oracle
CH,supp(F) = Pr[Gint
Ch(u, ğ‘š0, ğ‘š1, aux, ğ‘Ÿ) as an encryption oracle for user u with
two plaintexts ğ‘š0, ğ‘š1 of the same size, auxiliary information
aux and randomness ğ‘Ÿ, to obtain the ciphertext ğ‘ that encrypts
ğ‘šğ‘. The adversary wins if it can guess the challenge bit ğ‘. The
game also contains a Recv oracle. It is needed to model that
each userâ€™s state stu may be updated every time a ciphertext
is processed, potentially inï¬‚uencing subsequent encryption
operations. However, the Recv oracle does not return any
information directly to D.
D. Message encoding schemes
At its core, a channel can be expected to have a mechanism
that handles encoding of plaintexts into payloads, and decoding