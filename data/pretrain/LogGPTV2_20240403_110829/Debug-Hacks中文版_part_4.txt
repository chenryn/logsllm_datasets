---
## Page 34
将其修改为 unlimited。
储的命令。
启登录到系统的所有用户的内核转储功能。下面这一行即为默认情况下禁用内核转
无法使用/etc/initscript。下面介绍Fedora9 中的步骤。首先编辑/etc/profile，开
以前只需在/etc/initscript 中写一个执行ulimit 的脚本即可，但最近的发行版多数
启用整个系统的内核转储功能
这样，发生内核转储时就会在/var/core/下生成压缩的内核转储文件。
core_helper 的内容很简单。
使用该方法可以自动压缩内核转储文件。
刚才的kernel.core_pattern 中可以加入管道符，启动用户模式辅助程序。管道符
使用用户模式辅助程序自动压缩内核转储文件
如果设置该值为1，文件名末尾就会添加.PID。
上例中设置了 kernel.core_uses_pid=o，是因为我们改变了文件名中 PID 的位置。
16 |第2 章调试前的必知必会
ulimit -S -c 0 > /dev/null 2>1
$ ls /var/core/
 $ cat /usr/local/sbin/core_helper
 # echo "/usr/local/sbin/core_helper" > /proc/sys/kernel/core_pattern
（l）后面可以写程序名。例如下面的格式。
ulimit -S -c unlimited > /dev/null 2>α1
1223269655-a.out-2834-18446744073709551615.core.gz
exec gzip - > /var/core/$1-$2-$3-$4.core.gz
#!/bin/sh
# sysctl -p 
kernel.core_uses_pid = 0
kernel.core_pattern = I/usr/local/sbin/core_helper %t %e %p %℃ 
# cat /proc/sysctl.conf
www.TopSage.com
---
## Page 35
表2-2比特掩码对应的内存类型
设置方法很简单，可以通过/proc//coredump_filter进行。coredump_filter使
存，其他进程无须转储。
必要所有进程都转储。因此，这种应用程序应当设置成只在某个进程中转储共享内
以使用该功能。由于各个共享内存的进程中，共享内存的内容是相同的，所以没有
能。此外，尽管RHEL4.7、RHEL5.2等的基础内核版本号低于上述版本，但也可
因此，从版本2.6.23开始，内核实现了针对各个进程选择内核转储的内存区段的功
转储过程也会加重系统的负载，甚至由于转储时间过长导致服务停止时间过长等。
程序发生内核转储时，所有进程的共享内存全部转储的话，会对磁盘造成巨大压力，
大规模应用程序会使用多个进程，更会使用几个G的庞大的共享内存。这种应用
利用内核转储掩码排除共享内存
最后重新启动系统，就可以启用整个系统的内核转储。
转储文件在固定的目录中生成。
是无效的。启用整个系统的内核转储后，很难判断哪个程序在哪个目录中生成了转
这个设置使得被SUID的程序也能内核转储。出于安全性考虑，默认情况下该选项
最后在/etc/sysctl.conf中加入以下设置。
用比特掩码表示内存类型，如表2-2所示。
需要在/etc/sysconfig/init文件中添加这样一行命令。
比特4
比特3
比特2
比特1
比特0
比特掩码
fs.suid_dumpable=1
DAEMON_COREFILE_LIMIT='unLimited'
内存类型
ELF文件映射（内核版本2.6.24以后的版本可以使用）
file-backed共享内存
file-backed专用内存
匿名共享内存
匿名专用内存
www.TopSage.com
18
---
## Page 36
19
流程如下所述。
的功能极其丰富，我们按照调试的流程进行说明。基本用法很简单。
本 hack 说明 Linux 环境下的标准调试器 GDB。示例中使用的编译器为 GCC。GDB
S#
MOVR
参考文献
功能。
等较为特别的使用方法。此外，还说明了在新版Linux 内核中实现的内核转储掩码
本 hack 说明了获取内核转储的基本设置，以及转储专用目录、用户模式辅助程序
总结
要跳过所有的共享内存区段，应将值改为1。
容可以查看设置情况。
笔者的环境中默认值为3，即转储所有的匿名内存区段。通过 coredump_filter 的内
18 1  第2章 调试前的必知必会
# echo 1 > /proc//coredump_filter
00000003
# cat /proc//coredump_filter
Manpage of CORE
启动调试器（GDB）。
带着调试选项编译、构建调试对象。
本hack 说明GDB的基本使用方法，包括断点设置、继续运行等。
调试器
（x86中为4KB）。这样就可以通过内核转储文件查出，该区域映射了哪个ELF
比特4用于转储共享库或可执行文件等ELF格式文件映射到的内存区段的第1页
文件。
(GDB）的基本使用方法(之一)
www.TopSage.com
一安部东洋
---
## Page 37
构建方法通常会写在INSTALL、README 等文件中，参考即可。
如果用configure脚本生成Makefile，
如果使用 Makefile 构建，
通过 gcc 的-g选项生成调试信息。
准备
$ ./configure CFLAGS="-Wall -02 -g"
5- 2-1- =S
XL 6- z0- 11em- 36 $
(2-4)
(2-3)
(2-2)
(2-1)
继续执行。
显示值。
显示栈帧。
设置断点。
使用C、C++这些过程式编程语言编程，就是利用编译器这个工具把我们期待的
不同，因此利用调试器跟踪运行时，有时会执行到莫名其妙的地方，从而造成混乱。
要用心写出整洁的代码,编译时不要出现任何警告甚至错误信息。编译错误是 bug 
编译器含有针对源代码中的各种各样的错误输出信息的功能，称为警告选项
为什么呢？
译和构建，但我们不推荐这样做。
接查看寄存器的值。由于这些副作用，有些人建议在调试时去掉优化选项进行编
优化还会将局部变量保存到寄存器中，因此无法显示该局部变量的内容，必须直
口点，符号表中也没有该函数的名称。
该函数名上就无法设置断点。这是因为内联优化从目标文件中去掉了该函数的入
比如内联（inline）函数优化（去掉函数调用，而将函数代码在调用的位置展开），
给编译器（GCC）加上优化选项后，实际的执行顺序可能由于优化而与源代码顺序
此外，发生编译错误时不会生成可执行文件。
-Werror选项可以在警告发生时，将其当做错误来处理。
最大的根源。
方式。
（Waming Option）。这些信息并不一定是错误，但却指出了容易引发 bug 的编码
，一般要给 CFLAGS 中指定-g选项。
HACK#5 调试器（GDB) 的基本使用方法（之一)I 19
www.TopSage.com
可以这样用。
20
---
## Page 38
时可以查看该时刻的变量值、显示栈帧、重新设置断点或重新运行等。断点命令
可以在函数名和行号等上设置断点。程序运行后，到达断点就会自动暂停运行。此
设置断点
启动后显示下述信息，出现 gdb提示符。
通过 emacs 启动的方法是 M-x gdb。
$gdb可执行文件名
启动
20
（break）可以简写为b。
(gdb)
This GDB was configured as "i486-linux-gnu".
and "show warranty" for details.
There is NO WARRANTY, to the extent permitted by law. Type "show copying"
't arnaisu pe auo on aaly ae n aeos it st su
License GPLv3+: GNU GPL version 3 or later 
Copyright(c)2008 Free 5oftware Foundation, Inc.
GNU gdb 6.8-debian
Current directory is /home/hyoshiok/work/coreutils/src/
第 2 章调试前的必知必会
优化选项的代码进行测试和调试才是正确的。
件应该只有一个。如果最终发布的代码是带有优化选项的代码，当然只有针对有
程序员是追求快乐的职业，为什么要把事情变得复杂呢？测试、调试的可执行文
上升。
而且，准备两个可执行文件的话，测试的工作量肯定会变成两倍，管理成本也会
执行文件呢？
可执行文件中 bug 并不存在；那么怎样管理由同一源代码编译、构建出的不同可
比如花费大量时间对没有优化选项的可执行文件进行调试，但实际上在优化后的
行文件。管理对象增加会导致管理成本上升，并不是好事。这会消耗大量成本，
如果只在调试时去掉优化选项，那就必须管理有优化选项和无优化选项的两种可执
点的基础之上添加的，用来加快执行速度。所以没有必要特意去除。
道，优化选项可能会让执行顺序与源代码顺序不同。而优化选项就是在理解这一
行为告诉计算机。尽管无须详细了解编译器优化选项的方方面面，但至少应当知
www.TopSage.com
---
## Page 39
设置好的断点可以通过 info break 确认。
如果不指定断点位置，就在下一行代码上设置断点。
3行、地址（0x08116fd6）设置断点。
上面的例子中分别对 iseq_compile()函数、compile.c 的 516 行、现在暂停位置往后
[例] 
格式：
还可以指定与暂停位置的偏移量，或者用地址来设置。
断点可以通过函数名、当前文件内的行号来设置，也可以先指定文件名再指定行号，
break 断点
格式：
Breakpoint 6 at 0x805bd44: file main.c, line 28.
Breakpoint 5 at 0x8116fd6: file iseq.c, line 360.
break *地址
Breakpoint 4 at 0x805bd58: file main.c, line 31.
Breakpoint 3 at 0x810742l: file compile.c, line 516.
(gdb) b isea_compile
break 函数名
 Breakpoint 1 at 0x8048elf: file uname.c, line 184.
(gdb)b
(gdb) b *0x08116fd6
(gdb) b +3
(gdb) b compile.c:516
Breakpoint 2 at 0x81126f6: file compile.c, line 422.
break-偏移量
break+偏移量
break文件名：函数名
break文件名：行号
break行号
(gdb) b main
www.TopSage.com
HACK#5 调试器（GDB) 的基本使用方法（之一）I 21 
---
## Page 40
23
格式：
运行。可以简写为r。
用run命令开始运行。
22|第2章调试前的必知必会
显示所有栈帧。
格式：
backtrace的别名还有where和info stack（简写为info s）。
backtrace命令可以在遇到断点而暂停执行时显示栈帧。该命令简写为bt。此外，
显示栈帧
格式：
能达到同样的效果。
经常用到的一个操作是在main（）上设置断点，然后执行到main（）函数。start命令
run参数
运行
bt
backtrace
start
Breakpoint 1,main(argc=2,argv=0xbf9cd714) at uname.c:184
Starting program:/home/hyoshiok/work/coreutils/src/uname-a
（gdb)run-a
9
S
Num
（gdb)info break
breakpoint
breakpoint
breakpoint
breakpoint
breakpoint
Type
。不加参数只执行run，就会执行到设置了断点的位置后暂停
keepy0x0805bd44
keepy0x08116fd6
keepy0x0805bd58
keepy0x08107421
keepyOx081126f6
DispEnbAddress
www.TopSage.com
in main at main.c:28
iniseq_loadatiseq.c:360
in main at main.c:31
iniseq_translate_threaded_code at compile.c:516
iniseq_compileatcompile.c:422
What
---
## Page 41
[例：只显示前3个栈帧]
后N个）栈帧。
不仅显示 backtrace，
只显示最后 N个栈帧。
[例]
只显示开头N个栈帧。
#0 vm_exec_core (th=oxo, initial=0) at vmexec.c:86
(gdb) bt 3
#9 0x0805bd77 in main (argc=4, argv=0xbfd5f264) at main.c:34
158469360, parent=0, type=3, bopt=0, option=0x8la6ac0) at iseq.c:329
 Breakpoint 2, vm exec_core (th=oxo, initial=0) at vm_exec.c:86
type=3) at iseq.c:306
bt full -N
[gdb)
5
(gdb）bt
backtrace full -N
bt full N
backtrace full N
bt full 
backtrace full
bt -N
backtrace -N
bt N
backtrace N
?
0x0805e4d5 in ruby_init () at eval.c:65
0x0806a595 in rb_call_inits.() at inits.c:55
0x08127148 in Init_VM () at vm.c:1864
0x081179e5 in rb_iseq_new (node=0x0, name=158469360, filename=158469360, parent=0,
0x081175f2 in rb_iseq_new_with_bopt_and_opt (node=0x0, name=158469360, filename=
0x081127c7 in iseq_compile (self=158469340, node=0x0) at compile.c:501
0x08107ac5 in iseq_setup (iseq=0x977dcf0, anchor=0xbfd5f01c) at compile.c:963
0x08107421 in iseq_translate_threaded_code (iseq=0x977dcf0) at compile.c:510
vm_exec_core (th=oxo, initial=0) at vmexec.c:86
，还要显示局部变量。N与前述意思相同，表示开头N个（或最
www.TopSage.com
HACK#5 调试器（GDB）的基本使用方法（之一）I 23
---
## Page 42
print 变量
格式：
print 命令可以显示变量。print 可以简写为 p。
显示变量
路径。
显示栈帧之后，就可以看出程序在何处停止（即断点的位置），以及程序的调用
[例：从外向内显示3个栈帧，及其局部变量]
24 1
$1 = (char **) 0xbf9cd714
#9 0x0805bd77 in main (argc=4, argv=0xbfd5f264) at main.c:34
8388608, 4294967295, 0, 134593648, 3218469272, 135462041, 8388608, 0,5,0, 8388608, 0111
516014545，
#8 x0805e4d5 in ruby_init () at eval.c:65
No locals.
#7 0x0806a595 in rb_call_inits () at inits.c:55
(gdb) bt full -3
(More stack frames follow...)
#2 0x08107ac5 in iseq_setup (iseg=0x977dcf0, anchor=0xbfd5f01c) at compile.c:963