Let ğ‘† be the subset of nodes with |ğ‘†|â‰¤ ğ‘¡, let viewğ‘† be the internal
state of nodes in ğ‘† and messages sent and received by nodes in ğ‘†.
Then, the next theorem ensures formally states the secrecy property
of the VSS.
Theorem D.4 (Theorem 4.4 of [44]). For all adversary A, for
any subset ğ‘† âŠ‚ [ğ‘›] of size ğ‘¡ and viewğ‘† , for all ğ‘  âˆˆ Zğ‘
Pr[A has secret | viewğ‘†] = Pr[A has secret]
ğ’“ = {ğœ™(1), ğœ™(2), . . . , ğœ™(ğ‘›)}.
(3) Let ğ‘£ğ‘˜ = commit(ğ‘ğ‘˜, ğ‘ğ‘˜) for ğ‘˜ = 1, 2, ..., ğ‘¡,
(4) Let ğ’— = {ğ‘£0, ğ‘£1, . . . , ğ‘£ğ‘¡}, ğ’” = {ğ‘(1), ğ‘(2), . . . , ğ‘(ğ‘›)}, and let
(5) return {ğ’—, ğ’”, ğ’“}
PedEvalVerify(ğ‘”0, ğ‘”1, ğ’—, ğ‘–, ğ‘ ğ‘–, ğ‘Ÿğ‘–) â†’ 0/1:
(1) If
commit(ğ‘ ğ‘–, ğ‘Ÿğ‘–) = ğ‘”ğ‘ ğ‘–0 ğ‘”ğ‘Ÿğ‘–1 =
ğ‘£ğ‘– ğ‘—
ğ‘—
ğ‘¡(cid:89)
ğ‘—=0
return 1 otherwise return 0.
Given PedPolyCommit and PedEvalVerify be the polyno-
mial commitment and evaluation scheme, respectively. The
VSS scheme is defined as below.
VSS.Share(ğ‘ , ğ‘”0, ğ‘”1, ğ‘›, ğ‘¡) :
(1) Let {ğ’—, ğ’”, ğ’“} := PedPolyCommit(ğ‘”0, ğ‘”1, ğ‘ )
(2) Broadcast ğ’— to all nodes and send ğ’”[ğ‘–], ğ’“[ğ‘–] to node ğ‘–
VSS.Verify(ğ‘”0, ğ‘”1, ğ’—, ğ‘ ğ‘–, ğ‘Ÿğ‘–) â†’ 0/1:
(1) Output PedEvalVerify(ğ‘”0, ğ‘”1, ğ’—, ğ‘–, ğ‘ ğ‘–, ğ‘Ÿğ‘–).
Let ğ‘‡ be the set of valid shares ğ‘ ğ‘˜ where |ğ‘‡ |= ğ‘¡ + 1, then
VSS.Recon({ğ‘ ğ‘˜}ğ‘˜âˆˆğ‘‡ ) â†’ ğ‘  :
(1) Output
(cid:88)
where ğœ‡ğ‘˜ =(cid:81)ğ‘—Ì¸=ğ‘˜
ğ‘ ğ‘˜ Â· ğœ‡ğ‘˜ = ğ‘(0) = ğ‘ 
(3)
ğ‘˜âˆˆğ‘‡
ğ‘—âˆ’ğ‘˜ for ğ‘˜ âˆˆ ğ‘‡ are Lagrange coefficients.
ğ‘—
Figure 4: Pedersenâ€™s VSS scheme [44]
VSS.Share step terminated correctly, any set of ğ‘¡ + 1 nodes can
combine their shares to recover the secret. Theorem D.3 states that
any subset of ğ‘¡ + 1 nodes will reconstruct the same secret.
Lemma D.1 (Lemma 4.2 of [44]). Let ğ‘† âŠ‚ {1, 2, . . . , ğ‘›} be a set of
ğ‘¡ + 1 nodes such that the verification was successful for these ğ‘¡ + 1
nodes. Then these ğ‘¡ +1 nodes can find a pair (ğ‘ â€², ğ‘¡â€²) such that ğ‘£ = ğ‘”ğ‘ â€²
0 ğ‘”ğ‘¡â€²
1 .
Definition D.2 (Uniqueness). For all subsets ğ‘†1 and ğ‘†2 of {1, 2, . . . , ğ‘›}
of size ğ‘˜ such that all nodes in ğ‘†1 and ğ‘†2 accepted their shares in the
verification protocol described above. Let ğ‘ ğ‘– be the secret computed
by the participants in ğ‘†ğ‘–, then ğ‘ 1 = ğ‘ 2.
Theorem D.3 (Theorem 4.2 of [44]). Under the assumption that
the dealer can not find logğ‘”0 ğ‘”1 except with negligible probability in
|ğ‘|, the verification protocol satisfies uniqueness.
E ZERO KNOWLEDGE PROOF OF EQUALITY
OF DISCRETE LOGARITHM
0 and ğ‘¦ = ğ‘”ğ›¼
1 .
Our dual-threshold ACSS protocol has a step that requires nodes
to produce zero-knowledge proofs about the equality of discrete
logarithms for a tuple of publicly known values. In particular, given
a group G of prime order ğ‘, two uniformly random generators
ğ‘”0, ğ‘”1 â† G and a tuple (ğ‘”0, ğ‘¥, ğ‘”1, ğ‘¦), a prover P wants to prove to a
probabilistic polynomial time (PPT) verifier V, in zero-knowledge,
the knowledge of a witness ğ›¼ such that ğ‘¥ = ğ‘”ğ›¼
We will use the Chaum-Pedersen "Î£-protocols" [21], which as-
sumes the hardness of the Decisional Diffie-Hellman (DDH) prob-
lem, and can be made non-interactive using the Fiat-Shamir heuris-
tic [26].
Decisional Diffieâ€“Hellman assumption. Given a group G with
generator ğ‘” âˆˆ G and uniformly random samples ğ‘, ğ‘, ğ‘ â† Zğ‘, the
Decisional Diffieâ€“Hellman (DDH) hardness assumes that the follow-
ing two distributions ğ·0, ğ·1 are computationally indistinguishable:
ğ·0 = (ğ‘”, ğ‘”ğ‘, ğ‘”ğ‘, ğ‘”ğ‘ğ‘) and ğ·1 = (ğ‘”, ğ‘”ğ‘, ğ‘”ğ‘, ğ‘”ğ‘).
Protocol for equality of discrete logarithm. For any given tuple
(ğ‘”0, ğ‘¥, ğ‘”1, ğ‘¦), the Chaum-Pedersen protocol proceeds as follows.
(1) P samples a random element ğ›½ â† Zğ‘ and sends (ğ‘1, ğ‘2) to
V where ğ‘1 = ğ‘”ğ›½
0 and ğ‘2 = ğ‘”ğ›½
1 .
(2) V sends a challenge ğ‘’ â† Zğ‘.
(3) P sends a response ğ‘§ = ğ›½ âˆ’ ğ›¼ğ‘’ to V.
(4) V checks whether ğ‘1 = ğ‘”ğ‘§
and only if both the equality holds.
0ğ‘¥ğ‘’ and ğ‘2 = ğ‘”ğ‘§
1ğ‘¦ğ‘’ and accepts if
As mentioned, this protocol can be made non-interactive in the
Random Oracle model using the Fiat-Shamir heuristic [26, 45]. This
protocol guarantees completeness, knowledge soundness, and zero-
knowledge. The knowledge soundness implies that if P convinces
the V with non-negligible probability, there exists an efficient
(polynomial time) extractor that can extract ğ›¼ from the prover with
non-negligible probability.
In our dual-threshold ACSS, we use the non-interactive variant
of the protocol described above. In particular, for any given tuple
1, ğœ‹ â† dleq.Prove(ğ‘ , ğ‘”0, ğ‘¥, ğ‘”1, ğ‘¦)
(ğ‘”0, ğ‘¥, ğ‘”1, ğ‘¦) where ğ‘¥ = ğ‘”ğ‘ 
generates the non-interactive zero proof ğœ‹. The proof ğœ‹ is ğ‘‚(ğœ…) bits
long. Given the proof ğœ‹ and (ğ‘”0, ğ‘¥, ğ‘”1, ğ‘¦), dleq.Verify(ğœ‹, ğ‘”0, ğ‘¥, ğ‘”1, ğ‘¦)
verifies the proof.
0 and ğ‘¦ = ğ‘”ğ‘ 
F PUBLICLY VERIFIABLE SECRET SHARING
We restate this section from [23]. Our (ğ‘›, â„“) dual-threshold ACSS
scheme for ğ‘› â‰¥ 3ğ‘¡ + 1 and ğ‘¡ < â„“ â‰¤ ğ‘› âˆ’ ğ‘¡ crucially rely on on a (ğ‘›, â„“)
publicly verifiable secret sharing (PVSS). In particular, we use the
PVSS scheme from Scrape [19], which is an improvement over the
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2720secret ğ‘  using a degree â„“ polynomial among ğ‘› nodes is equivalent
to encoding the message (ğ‘ , ğ‘1, ğ‘2, Â· Â· Â· , ğ‘ğ‘¡) using a [ğ‘›, â„“ + 1, ğ‘› âˆ’ â„“]
Reed Solomon code [46].
Let ğ¶ be a [ğ‘›, ğ‘˜, ğ‘‘] linear error correcting code over Zğ‘ of length
ğ‘› and minimum distance ğ‘‘. Also, let ğ¶âŠ¥ be the dual code of ğ¶ i.e.,
ğ¶âŠ¥ consists vectors ğ’šâŠ¥ âˆˆ Zğ‘›
ğ‘ such that for all ğ’™ âˆˆ ğ¶, âŸ¨ğ’™, ğ’šâŠ¥âŸ© = 0.
Here, âŸ¨Â·, Â·âŸ© is the inner product operation. Scrapeâ€™s PVSS.Verify uses
the following basic fact (Lemma F.1) of linear error correcting code.
We refer readers to [19, Lemma 1] for its proof.
Lemma F.1. If ğ’™ âˆˆ Zğ‘›
ğ‘ \ ğ¶, and ğ’šâŠ¥ is chosen uniformly at random
from ğ¶âŠ¥, then the probability that âŸ¨ğ’™, ğ’šâŠ¥âŸ© = 1 is exactly 1/ğ‘.
The PVSS scheme of Scrape guarantees the IND1-Secrecy prop-
erty as defined in Definition F.2. Intuitively, for any (ğ‘›, â„“) PVSS
scheme, IND1-secrecy ensures that prior to the reconstruction
phase, the public information together with the secret keys ğ‘ ğ‘˜ğ‘–
of any set of at most â„“ players gives no information about the secret.
Formally this is stated as in the following indistinguishability based
definition adapted from [31, 47]:
Definition F.2. (IND1-Secrecy) A (ğ‘›, â„“) PVSS is said to be IND1-
secret if for any probabilistic polynomial time adversary A corrupt-
ing at most â„“ parties, A has negligible advantage in the following
game played against an challenger.
(1) The challenger runs the Setup phase of the PVSS as the dealer
and sends all public information to A. Moreover, it creates
secret and public keys for all honest nodes, and sends the
corresponding public keys to A.
(2) A creates secret keys for the corrupted nodes and sends the
corresponding public keys to the challenger.
(3) The challenger chooses values ğ‘ 0 and ğ‘ 1 at random in the
space of secrets. Furthermore it chooses ğ‘ â† {0, 1} uni-
formly at random. It runs the phase of the protocol with ğ‘ 0
as secret. It sends A all public information generated in that
phase, together with ğ‘ ğ‘.
The advantage of A is defined as |Pr[ğ‘ = ğ‘â€²] âˆ’ 1/2|.
Theorem F.3. (IND1-Secrecy [19, Theorem 1]) Under the Deci-
sional Diffie-Hellman assumption, the PVSS protocol in [19] guar-
antees IND1-secrecy against a static probabilistic polynomial time
adversary that can collude with up to â„“ nodes.
Let ğ‘  be the secret a node (the dealer) with public-private
key pair (ğ‘ ğ‘˜, ğ‘ğ‘˜) wants to share with set of nodes with public
keys {ğ‘ğ‘˜ ğ‘—} ğ‘— for ğ‘— = 1, 2, . . . , ğ‘›. Let ğ‘”0, ğ‘”1 be two randomly
chosen generators of group G.
PVSS.Share(ğ‘ , ğ‘”0, ğ‘›, â„“, {ğ‘ğ‘˜} ğ‘—,ğ‘—=1,2,...,ğ‘›) â†’ (ğ’—, ğ’„, ğ…):
(1) Sample uniform random ğ‘ğ‘– âˆˆ Z for ğ‘– = 1, 2, . . . , â„“ and let
ğ‘(ğ‘¥) = ğ‘  + ğ‘1ğ‘¥ + . . . + ğ‘â„“ğ‘¥ â„“;
; and ğ‘ ğ‘— := ğ‘ğ‘˜ğ‘(ğ‘—)
(2) Let ğ‘£ ğ‘— := ğ‘”ğ‘(ğ‘—)
(3) Let ğœ‹ ğ‘— := dleq.Prove(ğ‘(ğ‘—), ğ‘”0, ğ‘£ ğ‘— , ğ‘ğ‘˜ ğ‘— , ğ‘ ğ‘—)
(4) Output ğ’— = {ğ‘£1, ğ‘£2, . . . , ğ‘£ğ‘›}; ğ’„ = {ğ‘1, ğ‘2, . . . , ğ‘ğ‘›}, and ğ… =
, for ğ‘— = 1, . . . , ğ‘›.
0
ğ‘—
{ğœ‹1, ğœ‹2, . . . , ğœ‹ğ‘›}.
PVSS.Verify(ğ‘”0, ğ‘”1, ğ‘›, â„“, {ğ‘ğ‘˜} ğ‘—,ğ‘—=1,2,...,ğ‘›, ğ’—, ğ’„, ğ…) â†’ 0/1:
(1) Sample a random codeword ğ’šâŠ¥ âˆˆ ğ¶âŠ¥ where ğ’šâŠ¥ =
[ğ‘¦âŠ¥
1 , ğ‘¦âŠ¥
2 , . . . , ğ‘¦âŠ¥
ğ‘› ] and check whether
ğ‘¦âŠ¥
ğ‘˜
ğ‘˜
ğ‘£
= 1G
(4)
ğ‘›(cid:89)
ğ‘˜=1
where 1G is the identity element of G.
(2) Check whether dleq.Verify(ğœ‹ ğ‘— , ğ‘”0, ğ‘£ ğ‘— , ğ‘ğ‘˜ ğ‘— , ğ‘ ğ‘—) = 1 for all ğ‘—.
(3) Output 1 if both checks pass, output 0 otherwise.
Let ğ‘‡ be the set of valid tuples of the form (Ëœğ‘ ğ‘–, Ëœğœ‹ğ‘–) where
Ëœğœ‹ğ‘– = dleq.Prove(ğ‘ ğ‘˜ğ‘–, ğ‘”1, ğ‘ğ‘˜ğ‘–, Ëœğ‘ ğ‘–, ğ‘ğ‘–) and |ğ‘‡ |= â„“ + 1, then
PVSS.Recon(ğ‘”1, {Ëœğ‘ ğ‘–}ğ‘–âˆˆğ‘‡ ) â†’ ğ‘”ğ‘ 
1 :
(1) Output (cid:89)
where ğœ‡ğ‘– =(cid:81)ğ‘—Ì¸=ğ‘–
ğ‘–âˆˆğ‘‡
(Ëœğ‘ ğ‘–)ğœ‡ğ‘– =(cid:89)
ğ‘–âˆˆğ‘‡
ğ‘”ğœ‡ğ‘– Â·ğ‘(ğ‘–)
1
= ğ‘”ğ‘(0)
1
(5)
ğ‘—
ğ‘—âˆ’ğ‘– for ğ‘– âˆˆ ğ‘‡ are Lagrange coefficients.
Figure 5: Scrapeâ€™s PVSS scheme.
Schoenmakers scheme [48]. The scheme allows a node (dealer) to
share a secret ğ‘  âˆˆ Zğ‘ among ğ‘› nodes, such that any subset of at
least â„“ nodes can reconstruct ğ‘”ğ‘ 
1. Here, ğ‘”1 is a random generator
of G. Additionally, any subset of â„“ or less nodes, can not learn any
information about the secret ğ‘ .
The reconstruction threshold â„“ is chosen in a way such that valid
contribution from at least â„“ nodes are required to recover ğ‘”ğ‘ 
1.
A key property of a PVSS scheme is that, not only the recipients
but any third party (with access to recipientsâ€™ public keys) can
verify, even before the reconstruction phase begins, that the dealer
has generated the shares correctly without having plaintext access
to the shares.
The PVSS scheme of Scrape [19] is non-interactive in the Random
Oracle model and has three procedures: PVSS.Share, PVSS.Verify,
and PVSS.Recon. A node (dealer) with public-private key pair ğ‘ğ‘˜, ğ‘ ğ‘˜,
uses PVSS.Share to share a secret ğ‘ , other nodes or external users
use PVSS.Verify to validate the shares, and PVSS.Recon is used to
recover ğ‘”ğ‘ 
1. We describe them in detail in Figure 5.
The verification procedure of Scrapeâ€™s PVSS uses properties of
error correcting code, specifically the Reed Solomon code [46]. They
use the observation by McEliece and Sarwate [39] that sharing a
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2721