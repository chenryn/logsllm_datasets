由于前三次释放的堆块在内存中不连续，因此不会发生合并。按照其大小，h1和h3所指
向的堆块应该被链入freelist[2]的空表，h5则被链入freelist[4]。
堆溢出利
三次释放运行完毕后，堆区的状态如图5.2.12所示
Freeh1
用
Freeh5
图5.2.12在内存中观察空闲双向链表的操作
再去0x00520178处看看空表索引区现在的情况，如图5.2.13所示。
看到了吗？现在已经产生了三条空闲链表了。根据块首的状态和空表索引的状态，聪明的
读者朋友们，您能指出是哪三条空闲链表吗（尽管其中的两条只有一个结点）？
Freelist[o]
Freellst[2]
Freellst[4]
图5.2.13在内存中观察空闲双向链表的索引区
5.2.6堆块的合并
当第4次释放操作结束后，h3、h4、h5这3个空闲块彼此相邻，这时会发生堆块合并操作。
首先这3个空闲块都将从空表中摘下，然后重新计算合并后新堆块的大小，最后按照合并
后的大小把新块链入空表。
159
---
## Page 185
day安全：
0
在这里，h3、h4的大小都是2个堆单位（8字节），h5是4个堆单位，合并后的新块为8
个堆单位，将被链入freelist[8]。
最后一次释放操作执行完后的堆区状态如图5.2.14所示。
软件漏洞分析技术（第2版）
注意，块首中
的slze已经被
改为0x0008
链入
freelist[8]
h3,h4,h5合并
后的新块
图5.2.14堆块合并
可以看到，合并只修改了块首的数据，原块的块身基本没有发生变化。注意合并后的新块
大小已经被修改为0x0008，其空表指针指向0x005201B8，也就是freelist[8]。
这时，在空表索引区观察一下，如图5.2.15所示。
可以看到：
（1）在0x00520188处的freelist[2]，原来标识的空表中有两个空闲块h1和h3，而现在只
剩下h1，因为h3在合并时被摘下了。
（2）在0x00520198处的freelist[4]，原来标识的空表中有一个空闲块h5，现在被改为指向
自身，因为h5在合并时被摘下了。
Froellst[4]
原来的空用块h5
Freellst[8]
被从空表中摘下
链入新合并的块
图5.2.15堆块合并
160
---
## Page 186
第
（3）在0x005201B8处的freelist[8]，原来指向自身，现在则指向合并后的新空闲块
5
0x005206AB。
章
这就是堆块合并的过程。堆块合并可以更加有效地利用内存，但往往需要修改多处指针，
堆
也是一个费时的工作。因此，堆块合并只发生在空表中。在强调分配效率的快表中，堆块合并
溢
一般会被禁止（通过设置堆块为占用态）。另外，空表中的第一个块不会向前合并，最后一个
出
块不会向后合并。
利
用
5.2.7快表的使用
通过前面的介绍我们已经知道空表中的空间申请与释放过程，现在我们再来看看Lookaside
表（快表）中空间申请与释放的过程。我们通过以下代码来观察分析一下快表中的空间申请与
释放。
#include
#include 
void main()
HLOCALh1,h2,h3,h4;
HANDLEhp;
hp=HeapCreate(0,0,0);
asm int3
h1=HeapA11oc(hp,HEAP_ZERO_MEMORY,8);
h2=HeapA11oc(hp,HEAP_ZERO_MEMORY,8);
h3=HeapA11oc(hp,HEAP_ZERO_MEMORY,16);
h4=HeapA11oc（hp,HEAP_ZERO_MEMORY,24);
HeapFree（hp,0,h1);
HeapFree(hp,0,h2);
HeapFree（hp,0,h3);
HeapFree(hp,0,h4);
h2=HeapA11oc（hp.HEAP_ZERO_MEMORY,16);
HeapFree（hp,0,h2);
实验环境如表5-2-3所示。
表5-2-3实验环境
推荐使用的环境
备注
操作系统
Windows 2000
编详环境
VC++6.0
build版本
release版本
需要注意的是程序在使用快表之后堆结构也会发生一些变化，其中最为主要的变化是“尾
块”不在位于堆0x0688偏移处了，这个位置被快表霸占。从偏移0x0178处的空表索引区也可
161
---
## Page 187
0
day安全：
以看出这一点，如图5.2.16所示。
软件漏洞分析技术
偏移不再是
8890x0
图5.2.16“尾块”不再位于偏移0x0688位置
（第2版
现在我们到偏移0x0688（本次实验为0x00360688）处来见识一下传说的快表长什么样，
如图5.2.17所示。
Lookaside[0]
Lookudde[1]
Lookaside[2]
图5.2.17堆初始化后快表状态
可以看到堆刚初始化后快表是空的，这也是为什么代码中我们要反复的申请释放空间。首
先我们从FreeList[0]中依次申请8、16、24个字节的空间，然后再通过HeapFree操作将其释放
到快表中（快表未满时优先释放到快表中）。根据三个堆块的大小我们可以知道8字节的会被
插入到Lookaside[1]中、16字节的会被插入到Lookaside[2]中、24字节的会被插入到Lokkaside[3]
中。执行完四次释放操作后快表区状态如图5.2.18所示。
8字节堆块地址
16字节堆块地址
24学节维块地址
图5.2.18
四次释放后快表状态
162
---
## Page 188
第
我们再到0x00361EA0附近观察一下堆块的状态，大家可以发现快表中的堆块与空表中的
5
堆块有着两个明显的区别。
章
（1）块首中的标识位为0x01，也就是这个堆块是Busy状态，这也是为什么快表中的堆块
堆
不进行合并操作的原因，如图5.2.19所示。
溢出利
（2）块首只存指向下一堆块的指针，不存在指向前一堆块的指针，如图5.2.19所示。
00.00_001
0000000000
状态为0x01
下一堆块指针
用
0000
8字节
8字节
16字节
状李为0x01
24字节
下一堆块指杆
00000
图5.2.19快表中堆块状态
经过前面的释放操作后，快表已经非空了，此时如果我们再申请8、16或24字节大小空
间的时系统会从快表中给我们分配，所以程序中接下来申请16个字节空间时，系统会从
Lookaside[2]中卸载一个堆块分配给程序，同时修改Lookaside[2]表头，如图5.2.20所示。
的释放过程完全一致，在这我们就不重复介绍了。
Lookaside[1]
口口
现在Lookaside[2]
文为空了
Lookaside[3]
图5.2.20再次申请空间后快表状态
5.3
堆溢出利用（上）一一DWORDSHOOT
5.3.1链表“拆卸”中的问题
堆管理系统的三类操作：堆块分配、堆块释放和堆块合并归根结底都是对链表的修改。例
可以看成是把若干个堆块先从空表中“卸下”，修改块首信息（大小），之后把更新后的新块“链
163
---
## Page 189
0
day
入”空表。
安
全
：
堆溢出利用的精髓就是用精心构造的数据去溢出下一个堆块的块首，改写块首中的前向指
软
针（flink）和后向指针（blink），然后在分配、释放、合并等操作发生时伺机获得一次向内存
件
漏
任意地址写入任意数据的机会。
洞
分
DWORDSHOOT发生时，我们不但可以控制射击的目标（任意地址），还可以选用适当的子弹
析
技
（4字节恶意数据）。
术
题外话：“DWORDSHOOT”是本书的提法，在别的文献中可能会被叫做“arbitrary
第
DWORDreSet。不管怎样，“DWORDSHOOT更加形象地点出了这种技术的关键，
2
我喜欢这样称呼它。在英文中，我喜欢把这种现象称为DWORDshooting，听起来可
版
能更加舒服一些。
通过DWORDSHOOT，攻击者可以进而劫持进程，运行shellcode，例如，表5-3-1中列出
的几种情形。
表5-3-1
点射目标（Terget）
子弹（payload）
改写后的结果
栈帧中的函数返回地址
shellcode起始地址
函数返回时，跳去执行shellcode
栈帧中的S.E.H句柄
shellcode起始地址
异常发生时，跳去执行shellcode
重要函数调用地址
shellcode 起始地址
函数调用时，跳去执行shellcode
本节将重点讲解DWORDSHOOT发生的原理，下节将介绍怎样利用DWORDSHOOT劫
持进程，执行shellcode。
这里举一个例子来说明在链表操作中DWORDSHOOT究竞是怎样发生的。将一个结点从
双向链表中“卸下”的函数很可能是类似这样的。
int remove （ListNode*node)
---o
return0;
按照这个函数的逻辑，正常拆卸过程中链表的变化过程如图5.3.1所示。
当堆溢出发生时，非法数据可以淹没下一个堆块的块首。这时，块首是可以被攻击者控制
的，即块首中存放的前向指针（flink）和后向指针（blink）是可以被攻击者伪造的。当这个堆
块被从双向链表中“卸下”时，node->blink->flink=node->flink将把伪造的flink指针值写
164
---
## Page 190
第
入伪造的blink所指的地址中去，从而发生DWORDSHOOT。这个过程如图5.3.2所示。
5
NodeNodNodeNode
章
“卸掉”双向链表
堆溢出利
中的一个节点
node ->bllnk -> flink = node -> flink
用
Node
node -> flink -> blink = node-> blink
图5.3.1
空闲双向链表的拆卸
Step1:
NooeNodeNodeNode
伪造的后向指针
（任意内存地址)）
伪造的前向指针
（4个字节的恶意数
ink
Node
Step2:
fllnk
Node
Node
堆中发生溢出，攻击者湾没了第二个堆块的块
首，从而控制了其前向指针和后向指针的值
node->blink(fake)->fink
Target
node->blink(fake)
node->flink(fake)
4bytes
彩意
Node
数据
Step3:
Node
NooeNode
图5.3.2DWORDSHOOT发生的原理
5.3.2
在调试中体会“DWORDSHOOT”
我们通过一个简单的调试过程来体会前面的DWORDSHOOT技术。用于调试的代码如下。
#include 
main()
165
---
## Page 191
0
day
HLOCALh1,h2,h3,h4,h5,h6;
安
HANDLE hp:
全
hp=HeapCreate（0,0x1000,0x10000);
h1=HeapA11oc(hp,HEAP_ZERO_MEMORY,8);
：
h2=HeapA11oc(hp.HEAP_ZERO_MEMORY,8);
软
件
h3=HeapA11oc（hp,HEAP_ZERO_MEMORY,8);
h4=HeapA1loc（hp,HEAP_ZERO_MEMORY,8);
漏
h5=HeapA11oc（hp.HEAP_ZERO_MEMORY,8);
洞
分
h6=HeapA11oc（hp.HEAP_ZERO_MEMORY,8);
_asm int3//used to breakthe process
析
//free the odd blocks to prevent coalesing
技
术
HeapFree（hp,0,h1);
HeapFree(hp,0,h3);
第
HeapFree(hp,0,h5)://nowfreelist[2]got3entries
2
//willallocate from freelist[2]which meansunlinkthelastentry
版
//(h5)
h1=HeapA1loc（hp,HEAP_ZERO_MEMORY,8);
returnO;
实验环境如表5-3-2所示。
表5-3-2实验环境
推荐使用的环境
备注
操作系统
Windows2000虚拟机
若在其它操作系统上调试，实验将会失败
编详器
Visual C++ 6.0
编译选项
默认编译选项
VS2003、VS2005的GS编译选项将使实验失败
build版本
release版本
如使用debug版本，实验将会失败
说明：堆分配算法依赖于操作系统版本、编译器版本、编译选项、build类型等因素，请在实验前务必确定实验环境是
否恰当.否则将得到不同的调试结果。本实验指导中的所有步骤是在一台Windows2000的虚拟机上完成的。
在这段程序中应该注意：
（1）程序首先创建了一个大小为0x1000的堆区，并从其中连续申请了6个大小为8字节
的堆块（加上块首实际上是16字节），这应该是从初始的大块中“切”下来的。
（2）释放奇数次申请的堆块是为了防止堆块合并的发生。
（3）三次释放结束后，freelist[2]所标识的空表中应该链入了3个空闲堆块，它们依次是hl、
h3、h5。
（4）再次申请8字节的堆块，应该从freelist[2]所标识的空表中分配，这意味着最后一个堆
块h5被从空表中“拆下”。
（5）如果我们手动修改h5块首中的指针，应该能够观察到DWORDSHOOT的发生。