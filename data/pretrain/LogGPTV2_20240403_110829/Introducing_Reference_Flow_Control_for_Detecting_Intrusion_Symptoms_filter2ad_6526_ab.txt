2.3
It is straightforward to implement discretionary access control using references.
Since access permissions are not granted on a “subject/object” basis, user iden-
tities are used for authentication purposes only. As the authentication process
Introducing Reference Flow Control
297
itself is treated as a separate problem, we represent it here by an unique special
login(u) operation method call that sets the calling process’ default reference
bags conforming to the user’s identity u This is functionally equivalent to the
real Unix model where the authentication procedure sets the new process’ uid
and gid. Since the login operation success relies on correct authentication and
not on execution context, it has no reference requirements.
An Access Control List is then the set of user identities whose default ref-
erence bags include the required references to perform a given object method
call. An ACL change modiﬁes the user’s default reference bags in the authenti-
cation component; furthermore this operation can be broadcast to all processes
if the change is required to be immediately eﬀective (a simple way to do this is
to state that any operation is a logical consequence of an ACL change). There
is no direct equivalent of the Unix “object owner” concept, as “subjects” are
not really represented here, thus there are no “chown” and “chgrp” operations.
If needed, object ownership can be modeled as a special usage of ACLs: upon
process initialization, a reference bag is created that contains only references to
objects owned by the process’ identity.
3 Application to Intrusion Detection
In this section, we present a proof-of-concept intrusion detection scheme for a
generic Unix-like operating system. Our goal is to provide users and applications
with a known environment and some form of backward compatibility.
As we stated in the introduction, we focus speciﬁcally on intrusions where an
attacker aims at gaining some unauthorized privilege. If we suppose the system
implementation is such that it won’t allow any user to perform an operation
without having the required rights, attacks we are interested in consist in com-
plex series of steps that involve possibly more than one subject identity to get
eventually an operation performed, but by deﬁnition each step per-se does not
violate the security policy. We call these “attacks by delegation”.
We describe how a Unix-like security policy can be implemented using the
proposed model. Intrusion detection issues are then discussed.
3.1 A Model of an Unix-Like Operating Environment
We consider that a security policy within the Unix operating environment obeys
the following rules:
– Operation on objects are authorized according to discretionary access con-
trol;
– Subject identities require authentication. We take no hypothesis about the
authentication process itself, though.
For the system to be secure, it must also conform to a third rule that is not met
by current implementations, as experience shows:
298
J. Zimmermann, L. M´e, and C. Bidan
– No Unix subject should be able to exploit a privilege that does not corre-
spond to its identity.
The implementation discussed in this example follows the scheme described in
section 2.3. Moreover, if we consider only the original Unix access control model,
relying solely on “user”, “group” and “other” permissions for three operations
(read, write and execute) with no extended ACLs, we can further simplify the
deﬁnition by considering only these three classes of references. Each user iden-
tity is then simply modeled by a reference bag that contains the corresponding
read, write and execute references, in the same way, there is a reference bag
representing each group and an additional reference bag other. The default ref-
erence bags for each process contain the bag corresponding to the process’ uid,
all reference bags corresponding to groups the user is member of, and the other
bag.
For instance, considering the following ﬁle:
-rw-r--r-- 1 bob users 3275 mar 21 09:14 README
There
exists
a
Ruid:bob(READM E.openread)
a
a Rother(READM E.openread)
reference,
Rgid:bob(READM E.openread)
reference and a Ruid:bob(READM E.openwrite) reference.
reference,
Such a deﬁnition provides actually a coarse view of the system but remains
functionally equivalent to the atomic model. It is usable for a basic implementa-
tion of the model, because it reduces considerably the amount of references and
reference bags to be considered while matching well the default Unix semantics,
but on the other hand, it suﬀers of the same limits as the Unix security policy
itself. It is not possible, for example, to devise a policy such that “ﬁles from
/tmp should not be copied into /etc” using this scheme, although it can be
easily deﬁned by introducing additional reference bags.
We consider that enforcing a security policy on root’s actions is pointless if
root’s privileges are unrestricted and encompass those of all other users. Thus
we take into account only operations performed by regular users. Nevertheless,
in Unix, users can still perform operations that do not ﬁt in their privileges using
sudo. By analogy, the equivalent of the /etc/sudoers ﬁle can be implemented
using speciﬁc reference bags. For example, the operation of editing /etc/shadow
is authorized by a bag editshadow that contains all references required to read
and write this ﬁle.
3.2 Detecting Intrusion Symptoms
Considering the model deﬁned in the previous section, the reference bags created
by login(u) represent the operations the user u is authorized to make use of.
An attacker’s goal is then to execute for his own purpose operations that do
not belong to these bags. The security policy’s purpose is to make such goals
impossible.
For example, if no reference bag S containing RS(/etc/shadow.openread) is
created by login(bob), then on the one hand, no consequence of login(bob)
Introducing Reference Flow Control
299
will involve a reference to open /etc/shadow for reading. On the other hand,
since the reference RS(/etc/shadow.openread) will ﬂow to any consequence of
open(/etc/shadow,O RDONLY), we can say that these two operations are not au-
thorized to have a common consequence, which would be precisely the symptom
of an attempt by bob to read /etc/shadow.
In its simplest form, the intrusion symptom detector can raise an alarm upon
such an intrusion attempt. This provides a particular form of an access control
system. Such an alarm indicates an operation violating the security policy, that
can be dealt with in diﬀerent ways:
– the operation can simply be prohibited, as is done in the default Unix access
– the operation can be purposely authorized in order to catch the attacker in
control model
obvious oﬀense
– the intrusion attempt can be reported along with an execution log, for foren-
sic analysis purposes
Another option is an early warning approach: an alarm is raised as soon as an
illegal combination of references appears (i.e. as soon as diﬀerent reference bags
owned by the same process contain references allowing an operation that could
not be executed otherwise). Such an alarm indicates an operation that cannot
be executed and could be correlated to further actual policy violation alarms,
which would provide valuable forensic information.
In any case, the security policy is expressed using reference bags deﬁnitions.
Intrusions appear to violate this policy, but how an illegal operation is eventually
achieved is not taken into account, thus there is no need for a known attack
scenarii database, neither a learned authorized usage proﬁle.
4 Experimental Implementation
This section describes a prototype we use to implement the proposed approach
on a Linux operating system. We show on two examples how real intrusion
symptoms can be detected. A discussion of some strong points and weaknesses
of this approach follows.
4.1 Prototype
By now, our implementation perform non-runtime security policy checking by
relying on execution logs, like most other intrusion detection systems do. Note
however that this is a pure convenience approach we use to ease development
and testing. These logs represent system execution scenarii that can easily be
replayed by a simulator. Our further goal is to replace the simulator by an in-
core implementation, thus the need for logs will be eliminated to allow runtime
security policy enforcement.
The logs are generated by a speciﬁc Linux kernel module. This module hooks
on the kernel API and a report is transmitted to the system logger each time
300
J. Zimmermann, L. M´e, and C. Bidan
a system call is executed. In its purpose, this is similar to the strace utility,
but has a system-wide eﬀect in that the logs contain all system calls observed
during the period the module is active, with the following properties:
– Local process order of operations is respected;
– Local order of object access operations is respected.
As Linux follows, with a few exceptions, the Unix “everything is a ﬁle” paradigm,
the set of system calls to observe is actually quite restricted:
– Process and thread creation/termination;
– User and/or group modifying;
– Input/output descriptor handling;
– System V IPC access control.
Logs generated by this module are then parsed by a reference propagation sim-
ulator. For each process that existed at the log beginning, a default set of ref-
erence bags is provided, based on the process’ identity and group membership
as described in section 3.1. The simulator itself implements reference propaga-
tion rules that match closely information ﬂow in an Unix system, i.e. reference
ﬂowing from a cause to its eﬀect:
– Opening a ﬁle for reading is a consequence of the last write to that ﬁle,
thus references ﬂow from a write operation to the next read operation, as
described in section 2.2;
– By analogy and to conform with standard Unix semantics, the accept op-
eration creates a reference to the newly created socket. This reference is
deﬁned to belong to the same reference bag as the references used to exe-
cute the corresponding connect operation. At the moment, only local socket
connections are treated.
System V shared buﬀers apart, there are no memory buﬀer access semantics
deﬁned in Unix. The only reference we can deﬁne to handle them are thus simple
memory pointers. The only general rule that we can state is that reading from
a memory buﬀer is causally dependent on writing to that buﬀer. Because this
is obviously a weak rule that can be easily bypassed by a malicious program,
a more accurate solution consists in overloading the malloc and free library
calls so that memory buﬀer allocation is emulated through a mmap operation.
The corresponding temporary ﬁle access can then be monitored.
As stated above, we suppose that authentication is performed through a
supposed login operation. To mimic at best the Unix model, we consider the
operations setuid and setgid, whose eﬀect is to construct reference bags ac-
cording to the new user’s identity. More precisely, current user and group bags
are suppressed and replaced by new ones; the other bag is identical for all users,
thus needs no change. In addition, references to objects that are tied to the pro-
gram’s execution (memory objects, pipes etc...) and thus are not explicitly taken
into account in the default reference bag deﬁnition are transferred to the new
user bag, to remain coherent with Unix semantics (only the “owner” process of
these objects can access them).
Introducing Reference Flow Control
301
For authentication to be enforced, setuid and setgid are authorized only
as a consequence of login. More precisely:
Ref [login(u)] = {Rsetuid:u(setuid.u)}
A setuid(u) operation simply wraps the setuid.u method call and thus re-
quires a RSsetuid.u reference. The login operation creates these references in
the setuid : u bag which never contains any other reference: this isolates these
references from other reference ﬂows.
4.2 Examples of Attack Detections
In this section, we describe two examples of classes of attacks that can be de-
tected using our proposed approach. These are presented as a proof of concept,
a throughout evaluation of the approach and its practical performance will be
subject to a further publication.
Race-conditions using symbolic links. As a ﬁrst simple example, we propose
to discuss an old classical attack using “lpr,” that has the advantage of being
well-known and very simple, yet suﬃciently illustrative. Although this particular
problem was solved, we can argue that it was not solved by updating or reﬁning
the security policy deﬁnition, but by modifying “lpr” itself to include speciﬁc,
ad-hoc inode number checking. This “patch-and-pray” approach proved to be
ineﬀective, since other attacks such as the /bin/mail vulnerability [12] rely on
an identical principle. The “lpr” attack consists in the following steps:
1. disconnect the printer
2. Ω1::lpr -s /home/bob/mydoc.ps
3. Ω2::rm /home/bob/mydoc.ps
4. Ω3::ln -s /etc/shadow /home/bob/mydoc.ps
5. connect back the printer
6. Ω4::/etc/shadow is printed by the lpr daemon
Here the user user exploits a side-eﬀect of a standard, legitimate system feature
(in this case, symbolic links) in a way that doesn’t break any access control rules
by itself, yet leads to illegal behaviour because it allows him to print the contents
of a ﬁle (/etc/shadow) even if he does not have a read access permission.
It is important to note that in this example, the initial request to print
/home/user/mydoc.ps could actually have been submitted by any user - even
one that is allowed to read /etc/shadow. Moreover, nothing prevents the user
user from creating links to /etc/shadow as long as they are under the control
of the same access rules as the ﬁle they link to. So this attack involves no illegal
operation in the access control sense.
However, the proposed model allows to detect Ω4 as a security policy viola-
tion. We suppose that the lpr daemon itself is permitted to read /etc/shadow
(in practice, this is case), i.e. Ω4 will be executed using any reference bag rs (as
302
J. Zimmermann, L. M´e, and C. Bidan
“read shadow”) where reading /etc/shadow is possible. Therefore, Ω4 is not
forbidden by itself. We consider also that the user bob operates with reference
bags that do not contain references to read /etc/shadow.
When creating the symbolic link, operation Ω3 generated references to the
symlink, since otherwise, the it could not be accessed. By default, a symlink by
itself is considered to be writable, readable and executable, depending on the
type of the ﬁle it points to. Thus:
ref3 = Ref(Ωuid:bob