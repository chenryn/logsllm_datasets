但是在Go语言的家族树中还有其它的祖先。其中一个有影响力的分支来自Niklaus Wirth所设
计的Pascal语言。然后Modula-2语言激发了包的概念。然后Oberon语言摒弃了模块接口文件
和模块实现文件之间的区别。第二代的Oberon-2语言直接影响了包的导入和声明的语法，还
Go语言起源 10
gopl
有Oberon语言的面向对象特性所提供的方法的声明语法等。
Go语言的另一支祖先，带来了Go语言区别其他语言的重要特性，灵感来自于贝尔实验室的
Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献 顺序通信进程 （
communicating sequential processes ，缩写为CSP。在CSP中，程序是一组中间没有共享状
态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。不过Tony Hoare的CSP
只是一个用于描述并发性基本概念的描述语言，并不是一个可以编写可执行程序的通用编程
语言。
接下来，Rob Pike和其他人开始不断尝试将CSP引入实际的编程语言中。他们第一次尝试引
入CSP特性的编程语言叫Squeak（老鼠间交流的语言），是一个提供鼠标和键盘事件处理的
编程语言，它的管道是静态创建的。然后是改进版的Newsqueak语言，提供了类似C语言语
句和表达式的语法和类似Pascal语言的推导语法。Newsqueak是一个带垃圾回收的纯函数式
语言，它再次针对键盘、鼠标和窗口事件管理。但是在Newsqueak语言中管道是动态创建
的，属于第一类值, 可以保存到变量中。
在Plan9操作系统中，这些优秀的想法被吸收到了一个叫Alef的编程语言中。Alef试图将
Newsqueak语言改造为系统编程语言，但是因为缺少垃圾回收机制而导致并发编程很痛苦。
（译注：在Aelf之后还有一个叫Limbo的编程语言，Go语言从其中借鉴了很多特性。 具体请
参考Pike的讲稿：http://talks.golang.org/2012/concurrency.slide#9 ）
Go语言的其他的一些特性零散地来自于其他一些编程语言；比如iota语法是从APL语言借鉴，
词法作用域与嵌套函数来自于Scheme语言（和其他很多语言）。当然，我们也可以从Go中
发现很多创新的设计。比如Go语言的切片为动态数组提供了有效的随机存取的性能，这可能
会让人联想到链表的底层的共享机制。还有Go语言新发明的defer语句。
Go语言起源 11
gopl
Go语言项目
所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些
不足地方的改进。Go项目是在Google公司维护超级复杂的几个软件系统遇到的一些问题的反
思（但是这类问题绝不是Google公司所特有的）。
正如Rob Pike所说，“软件的复杂性是乘法级相关的”，通过增加一个部分的复杂性来修复问题
通常将慢慢地增加其他部分的复杂性。通过增加功能、选项和配置是修复问题的最快的途
径，但是这很容易让人忘记简洁的内涵，即从长远来看，简洁依然是好软件的关键因素。
简洁的设计需要在工作开始的时候舍弃不必要的想法，并且在软件的生命周期内严格区别好
的改变和坏的改变。通过足够的努力，一个好的改变可以在不破坏原有完整概念的前提下保
持自适应，正如Fred Brooks所说的“概念完整性”；而一个坏的改变则不能达到这个效果，它
们仅仅是通过肤浅的和简单的妥协来破坏原有设计的一致性。只有通过简洁的设计，才能让
一个系统保持稳定、安全和持续的进化。
Go项目包括编程语言本身，附带了相关的工具和标准库，最后但并非代表不重要的是，关于
简洁编程哲学的宣言。就事后诸葛的角度来看，Go语言的这些地方都做的还不错：拥有自动
垃圾回收、一个包系统、函数作为一等公民、词法作用域、系统调用接口、只读的UTF8字符
串等。但是Go语言本身只有很少的特性，也不太可能添加太多的特性。例如，它没有隐式的
数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有
泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。但是，语言本身是成熟和
稳定的，而且承诺保证向后兼容：用之前的Go语言编写程序可以用新版本的Go语言编译器和
标准库直接构建而不需要修改代码。
Go语言有足够的类型系统以避免动态语言中那些粗心的类型错误，但是，Go语言的类型系统
相比传统的强类型语言又要简洁很多。虽然，有时候这会导致一个“无类型”的抽象类型概念，
但是Go语言程序员并不需要像C++或Haskell程序员那样纠结于具体类型的安全属性。在实践
中，Go语言简洁的类型系统给程序员带来了更多的安全性和更好的运行时性能。
Go语言鼓励当代计算机系统设计的原则，特别是局部的重要性。它的内置数据类型和大多数
的准库数据结构都经过精心设计而避免显式的初始化或隐式的构造函数，因为很少的内存分
配和内存初始化代码被隐藏在库代码中了。Go语言的聚合类型（结构体和数组）可以直接操
作它们的元素，只需要更少的存储空间、更少的内存写操作，而且指针操作比其他间接操作
的语言也更有效率。由于现代计算机是一个并行的机器，Go语言提供了基于CSP的并发特性
支持。Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此，创建一个
goroutine的代价很小，创建百万级的goroutine完全是可行的。
Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含
I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格
式和编解码协议。库和工具使用了大量的约定来减少额外的配置和解释，从而最终简化程序
Go语言项目 12
gopl
的逻辑，而且，每个Go程序结构都是如此的相似，因此，Go程序也很容易学习。使用Go语
言自带工具构建Go语言项目只需要使用文件名和标识符名称, 一个偶尔的特殊注释来确定所有
的库、可执行文件、测试、基准测试、例子、以及特定于平台的变量、项目的文档等；Go语
言源代码本身就包含了构建规范。
Go语言项目 13
gopl
本书的组织
我们假设你已经有一种或多种其他编程语言的使用经历，不管是类似C、C++或Java的编译型
语言，还是类似Python、Ruby、JavaScript的脚本语言，因此我们不会像对完全的编程语言
初学者那样解释所有的细节。因为，Go语言的变量、常量、表达式、控制流和函数等基本语
法也是类似的。
第一章包含了本教程的基本结构，通过十几个程序介绍了用Go语言如何实现类似读写文件、
文本格式化、创建图像、网络客户端和服务器通讯等日常工作。
第二章描述了Go语言程序的基本元素结构、变量、新类型定义、包和文件、以及作用域等概
念。第三章讨论了数字、布尔值、字符串和常量，并演示了如何显示和处理Unicode字符。第
四章描述了复合类型，从简单的数组、字典、切片到动态列表。第五章涵盖了函数，并讨论
了错误处理、panic和recover，还有defer语句。
第一章到第五章是基础部分，主流命令式编程语言这部分都类似。个别之处，Go语言有自己
特色的语法和风格，但是大多数程序员能很快适应。其余章节是Go语言特有的：方法、接
口、并发、包、测试和反射等语言特性。
Go语言的面向对象机制与一般语言不同。它没有类层次结构，甚至可以说没有类；仅仅通过
组合（而不是继承）简单的对象来构建复杂的对象。方法不仅可以定义在结构体上, 而且, 可
以定义在任何用户自定义的类型上；并且, 具体类型和抽象类型（接口）之间的关系是隐式
的，所以很多类型的设计者可能并不知道该类型到底实现了哪些接口。方法在第六章讨论，
接口在第七章讨论。
第八章讨论了基于顺序通信进程(CSP)概念的并发编程，使用goroutines和channels处理并发
编程。第九章则讨论了传统的基于共享变量的并发编程。
第十章描述了包机制和包的组织结构。这一章还展示了如何有效地利用Go自带的工具，使用
单个命令完成编译、测试、基准测试、代码格式化、文档以及其他诸多任务。
第十一章讨论了单元测试，Go语言的工具和标准库中集成了轻量级的测试功能，避免了强大
但复杂的测试框架。测试库提供了一些基本构件，必要时可以用来构建复杂的测试构件。
第十二章讨论了反射，一种程序在运行期间审视自己的能力。反射是一个强大的编程工具，
不过要谨慎地使用；这一章利用反射机制实现一些重要的Go语言库函数, 展示了反射的强大用
法。第十三章解释了底层编程的细节，在必要时，可以使用unsafe包绕过Go语言安全的类型
系统。
每一章都有一些练习题，你可以用来测试你对Go的理解，你也可以探讨书中这些例子的扩展
和替代。
本书的组织 14
gopl
书中所有的代码都可以从 http://gopl.io 上的Git仓库下载。go get命令根据每个例子的导入路
径智能地获取、构建并安装。只需要选择一个目录作为工作空间，然后将GOPATH环境变量
设置为该路径。
必要时，Go语言工具会创建目录。例如：
$ export GOPATH=$HOME/gobook # 选择工作目录
$ go get gopl.io/ch1/helloworld # 获取/编译/安装
$ $GOPATH/bin/helloworld # 运行程序
Hello, 世界 # 这是中文
运行这些例子需要安装Go1.5以上的版本。
$ go version
go version go1.5 linux/amd64
如果使用其他的操作系统, 请参考 https://golang.org/doc/install 提供的说明安装。
本书的组织 15
gopl
更多的信息
最佳的帮助信息来自Go语言的官方网站，https://golang.org ，它提供了完善的参考文档，包
括编程语言规范和标准库等诸多权威的帮助信息。同时也包含了如何编写更地道的Go程序的
基本教程，还有各种各样的在线文本资源和视频资源，它们是本书最有价值的补充。Go语言
的官方博客 https://blog.golang.org 会不定期发布一些Go语言最好的实践文章，包括当前语言
的发展状态、未来的计划、会议报告和Go语言相关的各种会议的主题等信息（译注：
http://talks.golang.org/ 包含了官方收录的各种报告的讲稿）。
在线访问的一个有价值的地方是可以从web页面运行Go语言的程序（而纸质书则没有这么便
利了）。这个功能由来自 https://play.golang.org 的 Go Playground 提供，并且可以方便地嵌
入到其他页面中，例如 https://golang.org 的主页，或 godoc 提供的文档页面中。
Playground可以简单的通过执行一个小程序来测试对语法、语义和对程序库的理解，类似其
他很多语言提供的REPL即时运行的工具。同时它可以生成对应的url，非常适合共享Go语言
代码片段，汇报bug或提供反馈意见等。
基于 Playground 构建的 Go Tour，https://tour.golang.org ，是一个系列的Go语言入门教程，
它包含了诸多基本概念和结构相关的并可在线运行的互动小程序。
当然，Playground 和 Tour 也有一些限制，它们只能导入标准库，而且因为安全的原因对一些
网络库做了限制。如果要在编译和运行时需要访问互联网，对于一些更复杂的实验，你可能
需要在自己的电脑上构建并运行程序。幸运的是下载Go语言的过程很简单，从
https://golang.org 下载安装包应该不超过几分钟（译注：感谢伟大的长城，让大陆的Gopher
们都学会了自己打洞的基本生活技能，下载时间可能会因为洞的大小等因素从几分钟到几天
或更久），然后就可以在自己电脑上编写和运行Go程序了。
Go语言是一个开源项目，你可以在 https://golang.org/pkg 阅读标准库中任意函数和类型的实
现代码，和下载安装包的代码完全一致。这样，你可以知道很多函数是如何工作的， 通过挖
掘找出一些答案的细节，或者仅仅是出于欣赏专业级Go代码。
更多的信息 16
gopl
致谢
Rob Pike和Russ Cox，以及很多其他Go团队的核心成员多次仔细阅读了本书的手稿，他们对
本书的组织结构和表述用词等给出了很多宝贵的建议。在准备日文版翻译的时候，Yoshiki
Shibata更是仔细地审阅了本书的每个部分，及时发现了诸多英文和代码的错误。我们非常感
谢本书的每一位审阅者，并感谢对本书给出了重要的建议的Brian Goetz、Corey Kosak、
Arnold Robbins、Josh Bleecher Snyder和Peter Weinberger等人。
我们还感谢Sameer Ajmani、Ittai Balaban、David Crawshaw、Billy Donohue、Jonathan
Feinberg、Andrew Gerrand、Robert Griesemer、John Linderman、Minux Ma（译注：中国
人，Go团队成员。）、Bryan Mills、Bala Natarajan、Cosmos Nicolaou、Paul Staniforth、
Nigel Tao（译注：好像是陶哲轩的兄弟）以及Howard Trickey给出的许多有价值的建议。我
们还要感谢David Brailsford和Raph Levien关于类型设置的建议。
我们从来自Addison-Wesley的编辑Greg Doench收到了很多帮助，从最开始就得到了越来越
多的帮助。来自AW生产团队的John Fuller、Dayna Isley、Julie Nahil、Chuti Prasertsith到
Barbara Wood，感谢你们的热心帮助。
Alan Donovan特别感谢：Sameer Ajmani、Chris Demetriou、Walt Drummond和Google公司
的Reid Tatge允许他有充裕的时间去写本书；感谢Stephen Donovan的建议和始终如一的鼓
励，以及他的妻子Leila Kazemi并没有让他为了家庭琐事而分心，并热情坚定地支持这个项
目。
Brian Kernighan特别感谢：朋友和同事对他的耐心和宽容，让他慢慢地梳理本书的写作思
路。同时感谢他的妻子Meg和其他很多朋友对他写作事业的支持。
2015年 10月 于 纽约
致谢 17
gopl
第一章 入门
本章介绍Go语言的基础组件。本章提供了足够的信息和示例程序，希望可以帮你尽快入门, 写
出有用的程序。本章和之后章节的示例程序都针对你可能遇到的现实案例。先了解几个Go程
序，涉及的主题从简单的文件处理、图像处理到互联网客户端和服务端并发。当然，第一章
不会解释细枝末节，但用这些程序来学习一门新语言还是很有效的。
学习一门新语言时，会有一种自然的倾向, 按照自己熟悉的语言的套路写新语言程序。学习Go
语言的过程中，请警惕这种想法，尽量别这么做。我们会演示怎么写好Go语言程序，所以，
请使用本书的代码作为你自己写程序时的指南。
入门 18
gopl
1.1. Hello, World
我们以现已成为传统的“hello world”案例来开始吧, 这个例子首次出现于1978年出版的C语言
圣经《The C Programming Language》（译注：本书作者之一Brian W. Kernighan也是
《The C Programming Language》一书的作者）。C语言是直接影响Go语言设计的语言之
一。这个例子体现了Go语言一些核心理念。
gopl.io/ch1/helloworld
package main
import "fmt"
func main() {
fmt.Println("Hello, 世界")
}
Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令（译注：
静态编译）。Go语言提供的工具都通过一个单独的命令 调用， 命令有一系列子命令。
go go
最简单的一个子命令就是run。这个命令编译一个或多个以.go结尾的源文件，链接库文件，并
运行最终生成的可执行文件。（本书使用$表示命令行提示符。）
$ go run helloworld.go
毫无意外，这个命令会输出：
Hello, 世界
Go语言原生支持Unicode，它可以处理全世界任何语言的文本。
如果不只是一次性实验，你肯定希望能够编译这个程序，保存编译结果以备将来之用。可以
用build子命令：
$ go build helloworld.go
这个命令生成一个名为helloworld的可执行的二进制文件（译注：Windows系统下生成的可执
行文件是helloworld.exe，增加了.exe后缀名），之后你可以随时运行它（译注：在Windows
系统下在命令行直接输入helloworld.exe命令运行），不需任何处理（译注：因为静态编译，
所以不用担心在系统库更新的时候冲突，幸福感满满）。
Hello, World 19
gopl
$ ./helloworld
Hello, 世界
本书中, 所有的示例代码上都有一行标记，利用这些标记, 可以从gopl.io网站上本书源码仓库
里获取代码：
gopl.io/ch1/helloworld
执行 命令，就会从网上获取代码，并放到对应目录中（需要
go get gopl.io/ch1/helloworld
先安装Git或Hg之类的版本管理工具，并将对应的命令添加到PATH环境变量中。序言已经提
及，需要先设置好GOPATH环境变量，下载的代码会放
在 目录）。2.6和10.7节有这方面更详细的介绍。
$GOPATH/src/gopl.io/ch1/helloworld
来讨论下程序本身。Go语言的代码通过包（package）组织，包类似于其它语言里的库
（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组
成, 目录定义包的作用。每个源文件都以一条 声明语句开始，这个例子里就
package
是 package main , 表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在
这个文件里的程序语句。
Go的标准库提供了100多个包，以支持常见功能，如输入、输出、排序以及文本处理。比
如 包，就含有格式化输出、接收输入的函数。 是其中一个基础函数，可以打印
fmt Println
以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。
包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在 里的 函
main main main
数 也很特殊，它是整个程序执行时的入口（译注：C系语言差不多都这样）。 函数所做
main
的事情就是程序做的。当然了， 函数一般调用其它包里的函数完成很多工作, 比如,
main
。
fmt.Println