# 【技术分享】JAVA反序列化安全实例解析
|
##### 译文声明
本文是翻译文章，文章来源：携程信息安全响应中心
译文仅供参考，具体内容表达以及含义原文为准。
****
**什么是序列化**
序列化
(Serialization)将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。
简单来说：
序列化： 将数据结构或对象转换成二进制串的过程
反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程
下面是将字符串对象先进行序列化，存储到本地文件，然后再通过反序列化进行恢复的样例代码：
    public static void main(String args[]) throws Exception {
        String obj = "hello world!";
        // 将序列化对象写入文件object.db中
        FileOutputStream fos = new FileOutputStream("object.db");
        ObjectOutputStream os = new ObjectOutputStream(fos);
        os.writeObject(obj);
        os.close();
        // 从文件object.db中读取数据
        FileInputStream fis = new FileInputStream("object.db");
        ObjectInputStream ois = new ObjectInputStream(fis);
        // 通过反序列化恢复对象obj
        String obj2 = (String)ois.readObject();
        ois.close();
    }
**反序列化漏洞原理**
反序列化漏洞的本质就是反序列化机制打破了数据和对象的边界，导致攻击者注入的恶意序列化数据在反序列化过程中被还原成对象，控制了对象就可能在目标系统上面执行攻击代码。Java序列化应用于RMI
JMX JMS 技术中。
**漏洞危害**
**案例一：Apache ActiveMQ 5.12.0 远程代码执行漏洞(JMS)**
Apache ActiveMQ 5.13.0之前5.x版本中存在安全漏洞，该漏洞源于程序未能限制可在代理中序列化的类。远程攻击者可借助特制的序列化的Java
Message Service (JMS) ObjectMessage对象利用该漏洞执行任意代码。
受到影响的消息系统如下
Apache ActiveMQ 5.12.0 and earlier
HornetQ 2.4.0 and earlier
Oracle OpenMQ 5.1 and earlier
IBM Websphere MQ 8.0.0.4 and earlier
Oracle Weblogic 12c and earlier
Pivotal RabbitMQ JMS client 1.4.6 and earlier
IBM MessageSight MessageSight V1.2 JMSClient and earlier
SwiftMQ JMS client 9.7.3 and earlier
Apache ActiveMQ Artemis client 1.2.0 and earlier
Apache Qpid JMS client 0.9.0 and earlier
Amazon SQS Java Messaging Library 1.0.0 and earlier
**案例二：JBoss 反序列化漏洞(JMX)**
Jboss利用的是HTTP协议，可以在任何端口上运行，默认安装在8080端口中。JMX是一个java的管理协议，在Jboss中的JMXInvokerServlet可以使用HTTP协议与其进行通话。这一通信功能依赖于java的序列化类。
本地构造恶意的序列化对象
构造恶意的序列化对象发送给目标主机：
执行系统命令
RedHat发布JBoss相关产品的解决方案:
https://access.redhat.com/solutions/2045023
受影响的JBoss产品有：
Environment
Red Hat JBoss A-MQ 6.x
Red Hat JBoss BPM Suite (BPMS) 6.x
Red Hat JBoss BRMS 6.x
Red Hat JBoss BRMS 5.x
Red Hat JBoss Data Grid (JDG) 6.x
Red Hat JBoss Data Virtualization (JDV) 6.x
Red Hat JBoss Data Virtualization (JDV) 5.x
Red Hat JBoss Enterprise Application Platform 6.x
Red Hat JBoss Enterprise Application Platform 5.x
Red Hat JBoss Enterprise Application Platform 4.3.x
Red Hat JBoss Fuse 6.x
Red Hat JBoss Fuse Service Works (FSW) 6.x
Red Hat JBoss Operations Network (JBoss ON) 3.x
Red Hat JBoss Portal 6.x
Red Hat JBoss SOA Platform (SOA-P) 5.x
Red Hat JBoss Web Server (JWS) 3.x
**案例三:**
Jenkins
Remoting的相关API是用于实现分布式环境中master和slave节点或者master和CLI的访问，API没有身份认证并且支持序列化对象。CVE-2016-0788通过Jenkins
Remoting巧妙地开启JRMP，JRMP触发反序列化操作,从而进行漏洞的利用。作者已经提供了完整利用POC：
在远程服务器开启JRMI端口
连接远程服务端口，发送恶意序列化数据包
这样在Jenkins的根目录就会生成一个pwned文件。
受影响的版本
All Jenkins main line releases up to and including 1.649
All Jenkins LTS releases up to and including 1.642.1
**  
**
**漏洞防御**
1、反序列化对象白名单控制，在resolveClass方法中校验对象名字。
    public class LookAheadObjectInputStream extends ObjectInputStream {
       public LookAheadObjectInputStream(InputStream inputStream)
             throws IOException {
          super(inputStream);
       }
       /**
        * Only deserialize instances of our expected Bicycle class
        */
       @Override
       protected Class resolveClass(ObjectStreamClass desc) throws IOException,
             ClassNotFoundException {
          if (!desc.getName().equals(Bicycle.class.getName())) {
             throw new InvalidClassException(
                   "Unauthorized deserialization attempt", desc.getName());
          }
          return super.resolveClass(desc);
       }
    }
2、序列化数据采用对称加密进行传输，接口调用增加身份认证。(此种方法仅仅能提升攻击成本)
3、因为序列化机制不能保证数据的完整和和保密性，如果类中存在敏感数据并且那么这个类还需要序列化，需要在特定对象的一个域上关闭serialization，在这个域前加上关键字transient即可。
更多关注携程安全应急响应中心公众号（CSRC）