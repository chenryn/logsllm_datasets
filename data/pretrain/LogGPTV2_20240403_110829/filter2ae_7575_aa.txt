## 前言
之前对ssti进行了较为浅显的学习，通过考核发现了不少问题，东西没有学透，太不扎实了，自己独立做题的话会因为不同的过滤之类的出现很多的问题，刷题也都是机械性的，属于是无效刷题。在发现自己千疮百孔的ssti学习之后，痛定思痛决定对ssti重新再来一遍
## SSTI是什么
SSTI 全称（Server-Side Template
Injection),中文名服务端模板注入，是由于接受用户输入而造成的安全问题，和sql注入有相似性。
它的实质在于服务器端接受了用户的输入，没有经过过滤或者说过滤不严谨，将用户输入作为web应用模板的一部分，但是在进行编译渲染的过程中，执行了用户输入的恶意代码，造成信息泄露，代码执行，getshell等问题。
这个问题主要是出在web应用模板渲染的过程中，而python中的一个微型框架flask主要就是使用的jinja2来作为渲染模板，因此主要学习关于python
flask的jinja2引发的SSTI。
服务器模板注入，那么什么是模板呢？
## 模板及模板引擎
换句话说，模板就是一段话中存在可动态替换的部分。
    print("hello{username}")
其中的username是可以人为输入或者产生影响的，可以动态替换。由于这句代码能够因为不同的username而显示不同的结果,因此我们可以简单的把这段话理解为一个模板。
而模板引擎的作用是为了使用户界面与业务数据或内容生成特定的文档。
换句话说这一过程可以简述为：拿到数据,塞到模板里,然后让渲染引擎将塞进去的东西生成 html 的文本,最后返回给浏览器.
但是渲染的数据是业务数据,且大多数都由用户提供,这就意味着用户对输入可控.如果后端没有对用户的输入进行检测和判断,那么就容易产生代码和数据混淆,从而产生注入漏洞可以被人注入。
## Flask-jinja2 SSTI 一般利用姿势
### 常用的魔术方法
之前做题的时候对其他大佬的payload总是看的一知半解，不知道为什么这样组合，为什么这样调用，现在从头再学，重新了解一下魔术方法的作用和组合。
ssti是源于python的，且通过import引入了许多的类与方法。python的str(字符串)、dict(字典)、tuple(元组)、list(列表)这些在Python类结构的基类都是object，而object拥有众多的子类。
那字符串，字典，元组，列表有啥区别呢
* * *
字符串：str是不可变的，双引号或者单引号中的数据，就是字符串。str可进行的操作：下表索引、切片。
元组：python的元组与列表类似，可以进行下标索引、切片，不同之处在于元组的元素不能修改，它是不可变的有序集合。元组使用小括号，列表使用方括号，正是因为tuple不可变，所以代码更安全，如果可能，能用tuple代替list就尽量用tuple。
序列类型：[data1,data2....]
tuple的注意点：tuple=(1,),只有1个元素的tuple定义时必须加一个逗号  
字典：用{ }表示，是无序的，可变的，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度，键不可变，是一个可hash对象，键值可变
映射类型：通过键与键值映射实现数据存储和查找
表示方式：{key1:value1,key2:value2......}
列表：list存储一系列有序集合，用[ ]括起来，列表中的元素是可变的，即可以对列表进行修改
序列类型：数据有位置顺序
表示方式：[data1,data2.....]
* * *
`__class__`：用来查看变量所属的类，根据前面的变量形式可以得到其所属的类。 **class** 是类的一个内置属性，表示类的类型，返回 ；
也是类的实例的属性，表示实例对象的类。简单来说，是用来返回的方法，用此方法来查看查找的内容。
    >>> ''.__class__
               //字符串
    >>> ().__class__
             //元组
    >>> [].__class__
              //列表
    >>> {}.__class__
              //字典
`__bases__`：用来查看类的基类，也可以使用数组索引来查看特定位置的值。
通过该属性可以查看该类的所有直接父类，该属性返回所有直接父类组成的元组（虽然只有一个元素）。注意是直接父类。简单来说就是返回类型列表，得和读取的连起来使用，比如说`__class__`
    >>> ().__class__.__bases__
    (,)
    >>> ''.__class__.__bases__
    (,)
    >>> [].__class__.__bases__
    (,)
    >>> {}.__class__.__bases__
    (,)
    >>> ''.__class__.__bases__[0].__bases__[0] // python2下雨python3下不同
    >>> [].__class__.__bases__[0]
`__mro__`：可以用来获取一个类的的调用顺序，可以用此方法来获取基类
    >>> ''.__class__.__mro__    // python2下和python3下不同
    (, )
    >>> [].__class__.__mro__
    (, )
    >>> {}.__class__.__mro__
    (, )
    >>> ().__class__.__mro__
    (, )
    >>> ().__class__.__mro__[1] // 返回的是一个类元组，使用索引就能获取基类了
`__base__`：使用此方法也可以直接获取基类
    >>> ''.__class__.__base__
                 //python3下的
    >>> ''.__class__.__base__    //python2下的
    >>> [].__class__.__base__
    >>> {}.__class__.__base__
    >>> ().__class__.__base__
当掌握了这些类继承的方法，我们可以从任何一个变量回溯到最开始的基类``中，再去获得这个最开始的基类所有能实现的子类，既可以有很多的类和方法了。
`__subclass__()`：查看当前类的子类组成的列表，即返回基类`object`的子类。
    >>>''.__class__.__bases__
    ()
    >>>''.__class__.__bases__[0]
    >>>''.__class__.__bases__.__subclasses__()
    报错
对于这里的报错有些不解，问了一下S神
在第一次访问时返回的是`()`其外面有()的包裹，返回的为一整个数组，在第二次访问时选中了第0个，看到了没有()包裹的``这样才返回了object类，所以说报错的原因在于没有选中数组的第0个，只有选中了第0个才能在object类下面看到其子类。
修改一下
    >>> ''.__class__.__bases__[0].__subclasses__()
    [, , , , , , , ,
    , , , , , , , , 
    , , , , , 
    , , , , , , , ,
    , , , , , , , 
    , , , , , , , 
    , , , , , , 
    , , , , , , 
    , , , , , , 
    , , , , , , 
    , , , , , , , , 
    , , , , , , 
    , , , 
    , , , , 
    , , , , , 
    , , , 
    , , , 
    , , , , , , 
    , , , , 
    , , , , ,
    , , , , , 
    , , , , 
    , , , , , 
    , , , , , , 
    , , , , , 
    , , , , ]
爆出来了很多的子类，而且非常杂乱，查阅起来有困难，我们整理一下：
python2下的类的使用和python3下类的使用有所不同，我们分开放
    #python2
    (0, )
    (1, )
    (2, )
    (3, )
    (4, )
    (5, )
    (6, )
    (7, )
    (8, )
    (9, )
    (10, )
    (11, )
    (12, )
    (13, )
    (14, )
    (15, )
    (16, )
    (17, )
    (18, )
    (19, )
    (20, )
    (21, )
    (22, )
    (23, )
    (24, )
    (25, )
    (26, )
    (27, )
    (28, )
    (29, )
    (30, )
    (31, )
    (32, )
    (33, )
    (34, )
    (35, )
    (36, )
    (37, )
    (38, )
    (39, )
    (40, )
    (41, )
    (42, )
    (43, )
    (44, )
    (45, )
    (46, )