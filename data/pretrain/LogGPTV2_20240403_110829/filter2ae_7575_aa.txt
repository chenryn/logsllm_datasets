## 前言
在对服务器端模板注入（SSTI）进行初步学习后，通过实践发现仍存在诸多不足。我的理解不够深入，导致在面对不同的过滤机制时常常感到力不从心。之前的刷题过程也显得机械而缺乏效率。鉴于此，我决定重新审视并深化对SSTI的理解与掌握。

## 什么是SSTI？
SSTI全称为Server-Side Template Injection，中文名为服务端模板注入，是一种由于不当处理用户输入而导致的安全漏洞，与SQL注入有一定的相似性。其核心问题在于，如果应用程序没有充分验证或过滤用户的输入，就将其作为模板的一部分使用，在渲染过程中可能会执行恶意代码，从而引发信息泄露、远程代码执行等严重后果。

这种安全风险主要出现在Web应用的模板渲染阶段。以Python中的微型框架Flask为例，它通常采用Jinja2作为模板引擎，因此本文将重点探讨由Jinja2引起的SSTI问题。

### 模板及模板引擎简介
简而言之，模板是指一段文本中包含可动态替换的部分。例如：
```python
print("hello {username}")
```
这里的`{username}`可以根据实际需要被不同的值所替代，使得输出结果随输入变化而变化。模板引擎的作用是将业务数据填充到预定义的模板中，并生成最终的HTML文档返回给客户端浏览器展示。然而，当这些数据来源于用户且未经过适当的安全检查时，就可能成为攻击者利用的入口点。

## Flask-Jinja2 SSTI 利用方法概述
### 关键魔术方法解析
在解决相关挑战的过程中，对于一些复杂Payload背后的原理往往感到困惑。为了更深刻地理解它们的工作方式，有必要回顾Python中几个重要的内置特殊方法及其应用场景：

- `__class__`: 获取对象所属类的信息。
- `__bases__`: 显示指定类的所有直接父类。
- `__mro__`: 提供了一个类继承链的有序列表。
- `__base__`: 直接获取当前类的第一个基类。
- `__subclasses__()`: 返回一个包含所有已注册子类的列表。

了解这些基础知识有助于我们从任何给定的对象追溯至最初的基类`object`，进而探索更多可用的类和方法。

#### 数据结构对比
此外，熟悉不同类型的数据结构特征同样重要：

- **字符串** (`str`)：不可变序列，支持索引访问和切片操作。
- **元组** (`tuple`)：固定长度的不可变序列，适用于存储不会改变的数据集。
- **字典** (`dict`)：键值对形式存储数据，具有快速查找特性。
- **列表** (`list`)：可扩展的可变序列，适合于频繁修改场景下的数据管理。

正确区分并合理运用这些基础类型，可以有效提升程序性能并避免潜在的安全隐患。