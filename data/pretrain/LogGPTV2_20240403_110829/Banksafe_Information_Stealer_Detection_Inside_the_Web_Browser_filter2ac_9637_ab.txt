After Microsoft added detections for Zeus to the Malicious Software Removal
Tool automatically shipped with the Windows Update service of operating sys-
tems Microsoft Windows XP, Vista and 7 in October 2010, the company released
statistics of Zeus removals [?]. While the removal of 444,292 infections world-
wide in the ﬁrst month after the release alone is impressive, the MSRT software
uses traditional antivirus signatures to detect Zeus variants and only updates
them once a month. Of these infections 34 percent were detected by old signa-
tures dating back to at least May 2010. Due to the monthly update schedule of
MSRT signatures, botnets that were regularly updated with newly created Zeus
executable ﬁles could survive Microsofts eﬀorts unharmed.
Banksafe Information Stealer Detection Inside the Web Browser
267
The self-proclaimed successor of Zeus is a trojan horse named SpyEye that
bears great resemblance to its rival regarding the construction kit paradigm,
marketing in underground forums and technical implementation. The SpyEye
toolkit entered the underground market in late 2009 [11] at a price that was
lower than Zeus while the features of both trojans are comparable. In the ﬁght
for market shares in the crimeware business, SpyEye introduced a Zeus removal
routine that enables the malware to take over machines that have been infected
by both trojan horses and make sure that only the SpyEye botnet operator could
steal from the victim. In order to estimate the popularity of SpyEye and Zeus we
evaluated data released by two services operated by swiss security researchers
who are tracking command & control servers for these families of trojans. In
the four months from November 2010 to February 2011 Spyeye-Tracker [5] mon-
itored 179 domains while Zeus Tracker [6] lists 303 domains hosting control
infrastructure.
In late 2010 there was a surprising turn of events when the Zeus developer
announced that he would no longer maintain the project and hand over the
source code to his competitor. Researchers of security company RSA analyzed
a newly found sample of SpyEye in February 2011 and found code pieces that
were identical to the corresponding features of the Zeus trojan [1]. It seems that
the Spyeye developer extracted the most valuable functionalities of Zeus and
implemented them in his creation.
Apart from the most successful information stealers, i.e. Zeus and Spyeye,
there were and are several other crimeware families with information stealing
abilities in-the-wild. We came across trojans named Carberp, Patcher, Gozi,
Silentbanker, Bebloh and Katusha while researching information stealers for the
Banksafe project.
4 Detection of Browser Manipulations
On systems running Microsoft Windows, information stealers utilize techniques
of so-called userland rootkits to intercept and manipulate web traﬃc. The mal-
ware injects code into the web browser process when it is started and installs
code hooks for API functions into the system libraries loaded into the process.
The following follwing API functions are hooked by the Trojan Zeus version 2
in the library Wininet.dll inside the web browser Microsoft Internet Explorer:
– HttpQueryInfoA
– HttpSendRequestA
– HttpSendRequestExA
– HttpSendRequestExW
– HttpSendRequestW
– InternetCloseHandle
– InternetQueryDataAvailable
– InternetReadFile
– InternetReadFileExA
268
A. Buescher, F. Leder, and T. Siebert
By hooking such high-level API communication functions in user-mode code,
information stealers are able to intercept web form data before it gets encrypted
in sessions secured by HTTPS. HTTPS sessions providing end-to-end encryption
are used as a de-facto standard to secure online transactions and are common for
the user login management of web applications. By staying inside the user-mode
application, the trojan can more conviniently intercept data than traditional
kernel-rootkits with keyloggers.
Some trojans like SpyEye and Zeus also inject control code into every user pro-
cess including the Windows Explorer and hook API functions in system libraries
like ntdll.dll, kernel32.dll and advapi32.dll similar to other userland rootkits in
order to hide their processes and ﬁles by intercepting API calls to ﬁlesystem,
registry and process control functions. Since the list of API function hooks was
diﬀerent for all trojan families we analyzed, this can be used not only to de-
tect the presence of an information stealer in a Windows system but to identify
its family based on the hooking characteristics. The traces that an information
stealer leaves in the systems web browser by hooking API functions are used
to compute a ﬁngerprint that can be compared with a list of ﬁngerprints of
previously analyzed crimeware for identiﬁcation and classiﬁcation.
Information stealer trojans can use diﬀerent ways to manipulate the related
API functions inside the web browser running in a Windows operating system:
inline hooks, import address table (IAT) hooks, export address table (EAT)
hooks and hook techniques manipulating the windows loader mechanism. We
detect all of the above and compute a ﬁngerprint out of them.
4.1 Inline Hooks
The most common method of intercepting calls being used by information steal-
ers on Windows 32-bit operating systems is so-called inline hooking. In this case
the malware would overwrite code bytes of an API function with a code ﬂow
redirection instruction like the x86 JMP to perform an unconditional jump to a
code section controlled by the trojan. In recent operating systems Microsoft uses
a compiler option to enable the so-called hotpatch functionality in all Windows
API functions of user-level system libraries. This option forces the compiler to
reserve 5 Bytes ﬁlled with no-operation opcodes (NOP) in front of every function
entry and precede the typical API function entry setting up the stack with the
2-byte instruction MOV EDI, EDI like shown below.
90
90
90
90
90
8bff
55
8bec
[NOP]
[NOP]
[NOP]
[NOP]
[NOP]
[MOV EDI, EDI] (FUNCTION ENTRY)
[PUSH EBP]
[MOV EBP, ESP]
Banksafe Information Stealer Detection Inside the Web Browser
269
There are diﬀerent ways to create a reliable code hook for functions. Trojans
Zeus and Spyeye directly overwrite the ﬁrst 5 bytes of the function code with an
unconditional long jump to their code sections injected into the process.
Since inline hooks require direct modiﬁcation of the targeted libraries, our
approach to detect trojans that use inline hooks is to compare the code section of
system libraries in memory with a corresponding copy loaded from the ﬁlesystem.
When loading a DLL ﬁle in portable executable (PE) format into a process,
Windows performs so-called base relocations using a list of relative addresses
that need to be modiﬁed according to the actual position of the executable
in virtual memory. In order to decide whether the code section of a system
library was modiﬁed by malware, we implemented an emulated Windows loader
that performs the relocations speciﬁed in a DLL ﬁle loaded from the hard-disk.
Using this approach it is possible to perform byte-to-byte checks of code sections
of libraries in arbitrary user processes in Microsoft Windows. The ability to
compare a code section with an unbiased original also enables the plugin to
create a list of modiﬁed API functions if inline hooks were detected.
4.2 IAT Hooks
Another technique to intercept calls to API functions inside a Windows process is
the modiﬁcation of the import address table (IAT). This table is used to specify
the location of functions or variables in virtual memory that are imported [28]
from dynamically loaded libraries. This structure is ﬁlled by the Windows loader
when the executable is loaded into a process. IAT hooks overwrite the original
destination of an imported API function and point it to code controlled by the
malware. In this case, an entry from within the table points outside the code
section of the library. This form of IAT hooks is simple to detect by checking
the entries of the table. A variant of IAT hooks tries to circumvent detection
by inserting a so-called trampoline, a jump instruction, into unused bytes inside
the code section of the library. With the approach described in the previous
subsection we are also able to detect trampolines by comparing the code section
with its unmodiﬁed original.
Relying solely on IAT Hooks imposes some drawbacks. First, to hook one
API function, the IATs of all loaded modules have to be parsed to check if the
target API function is imported. Also, the dynamic loading of modules, e.g.
via the LoadLibrary API call, and the dynamic retrieval of function addresses,
e.g. via GetProcAddress, has to be monitored. This is strongly related to the
problem of the Delayed IAT, a table that contains the functions of DLLs which
are scheduled to be loaded on usage only [28] and are extensively used in the
Internet Explorer.
4.3 EAT Hooks
The export address table (EAT) of a module contains the addresses of all API
functions exported by that module. To hook an API function using this table, the
hooking program simply needs to overwrite the corresponding function address
in the table.
270
A. Buescher, F. Leder, and T. Siebert
The advantage of this method is that any kind of subsequent (dynamic) import
is automatically handled. However, imports prior to the hook are not handled.
To propagate this change to the IATs of importing modules, the write to the
EAT has to be done before the importing module is loaded. Otherwise, the IATs
of previously loaded modules have to be changed manually (cf. previous section).
The EAT of a module is usually static, i.e. it doesnt change in memory as the
IAT does. Therefore export table hooks can be detected the same way as inline
hooks: by comparing an in-memory copy with a ﬁlesystem copy.
4.4 Other Methods
While the hooking methods mentioned above are very straight-forward and
widely used, some other methods exist. When an infested process creates a child
process, hooks inside of the parent process may be used to alter the creation
ﬂags of the child process. A common method is to create the child process in
a suspended state. Processes created in a suspended state are suspended even
before the imported libraries are loaded which allows the infested master process
for example to inject watch threads or to change the operating systems loading
routine, thus eﬀectively being able to modify the API addresses of any function
into the IAT of any loaded module.
It is also possible to use several combinations of any of the abovementioned
hooking methods. For example, a parent process may be modiﬁed to start its
child processes in a suspended state. Then a hook is injected into the child
process that places an inline hook inside the loader. This hook then changes the
loader behaviour to modify the resolution of API addresses to place additional
hooks, whereas the inline loader hook may be removed afterwards.
4.5 False Positive Evasion
Legitimate software sometimes also uses hooking techniques to patch certain
functionalities during runtime. One example is the hotpatching introduced by
Microsoft which allows to easily enable inline hooking of WinAPI functions as
described before.
Our approach to prevent false positive detections of legitimate software is
to inspect the destination of each hook found by Banksafe. If a hook points
to code inside a module, Banksafe checks whether the corresponding DLL was
trustfully signed and no code modiﬁcations were made to e.g. install trampolines.
All hooks pointing to code inside a signed module that is trusted are ignored
in Banksafes detection mechanism. We give an overview of software that we
encountered hooking functions inside Microsofts Internet Explorer in subsection
5.5 of the evaluation section.
5 Experimental Evaluation
In order to evaluate the performance of our approach, we conducted a series
of experiments. In a ﬁrst step we analyzed a wide range of specimen from the
Banksafe Information Stealer Detection Inside the Web Browser
271
infamous Zeus and SpyEye families. These give an overview about the detection
capabilities and the number of diﬀerent ﬁngerprints that can be expected within
each family. In a second step, we compared our approach against the detection
capabilities of diﬀerent anti-virus scanners, i.e. the detection using regular sig-
natures as well as behavioral detection. In a last step of the evaluation, we show
that our approach can also be applied to families of other information stealers.
5.1 Classiﬁcation of Zeus and SpyEye
In a ﬁrst experiment, we want to study the detection ratio and ability of our
approach to classify Zeus and Spyeye samples. In order to achieve this, a larger
set of samples has to be analyzed. For the veriﬁcation of the results it is of
major importance to have a sample set with an existing reference classiﬁcation.
Without such a set it is hardly possible to verify the results. The classiﬁcation
provided by anti-virus vendors in their signatures has proved to be very imprecise
as shown in [8].
The most reliable classiﬁcation known for banking trojans are the samplesets
from Zeus-Tracker [6] and SpyEye-Tracker [5]. The two projects focus on mon-
itoring the botnets behind the most prominent banking trojans, i.e. Zeus and
SpyEye. The total set consists of 1,045 samples.
Setup. An individual experiment is conducted for each sample. Each sample is
used to attempt an infection of a clean Windows XP operating system patched
to SP2. In order to quickly revert to a clean state, a VirtualBox virtual machine
is used. The execution state is reverted to a clean state after each experiment.
The basic steps for each run are:
1. Reset VM to clean state