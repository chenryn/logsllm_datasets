title:Avis: In-Situ Model Checking for Unmanned Aerial Vehicles
author:Max Taylor and
Haicheng Chen and
Feng Qin and
Christopher Stewart
Avis: In-Situ Model Checking for
Unmanned Aerial Vehicles
Max Taylor, Haicheng Chen, Feng Qin, Christopher Stewart
The Ohio State University
1
2
0
2
n
u
J
8
2
]
E
S
.
s
c
[
1
v
9
5
9
4
1
.
6
0
1
2
:
v
i
X
r
a
Abstract—Control ﬁrmware in unmanned aerial vehicles
(UAVs) uses sensors to model and manage ﬂight operations,
from takeoff to landing to ﬂying between waypoints. However,
sensors can fail at any time during a ﬂight. If control ﬁrmware
mishandles sensor failures, UAVs can crash, ﬂy away, or suffer
other unsafe conditions. In-situ model checking ﬁnds sensor
failures that could lead to unsafe conditions by systematically
failing sensors. However, the type of sensor failure and its timing
within a ﬂight affect its manifestation, creating a large search
space. We propose Avis, an in-situ model checker to quickly
uncover UAV sensor failures that lead to unsafe conditions.
Avis exploits operating modes, i.e., a label that maps software
execution to corresponding ﬂight operations. Widely used control
ﬁrmware already support operating modes. Avis injects sensor
failures as the control ﬁrmware transitions between modes – a
key execution point where mishandled software exceptions can
trigger unsafe conditions. We implemented Avis and applied
it to ArduPilot and PX4. Avis found unsafe conditions 2.4X
faster than Bayesian Fault Injection, the leading, state-of-the-
art approach. Within the current code base of ArduPilot and
PX4, Avis discovered 10 previously unknown software bugs that
lead to unsafe conditions. Additionally, we reinserted 5 known
bugs that caused serious, unsafe conditions and Avis correctly
reported all of them.
I. INTRODUCTION
Unmanned aerial vehicles (UAVs) hover, ﬂy to set way-
points and perform complex aerial operations. Without a hu-
man aboard, UAVs can handle missions that are too dangerous,
too long or otherwise unproﬁtable for traditional aircraft. For
example, UAVs can enter wildﬁres and war zones [3], [20].
UAVs can also survey large crop ﬁelds at low altitudes to as-
sess damage caused by natural disasters, pests and contagious
crop diseases [43], [44]. UAVs use software, called control
ﬁrmware, to read from sensors, model the state of the aircraft,
respond to pilot commands, and control pitch, thrust and yaw
for navigation. As the global market for UAVs will soon
exceed $42B [32], control ﬁrmware is increasingly crucial
system software. It underlies every major UAV use case and
must support a growing number of ﬂight operations. Software
bugs in UAV control ﬁrmware can have serious consequences,
such as crashes.
UAVs use a myriad of sensors,
including inertial mea-
surement units (IMUs), global positioning systems (GPSs),
compasses, and barometers. Sensors can fail for many reasons.
GPSs can be disrupted by Carrington events that affect the
Earth’s magnetic ﬁeld [33]. Alternatively, sensors can be
disconnected from their power source due to turbulence or
motor vibrations. Control ﬁrmware, by design, accounts for
sensor failures via (1) failing over to redundant sensors,
Fig. 1: Execution analysis of a mishandled sensor failure that
can cause a crash.
(2) discarding invalid readings and (3) employing multiple
methods with diverse input needs to model the state of the
aircraft. Despite these precautions, sensor failures can cause
unsafe ﬂight conditions where control ﬁrmware executes ﬂight
operations that crash the UAV or disrupt its mission. Unsafe
ﬂight conditions occur when fault handling logic does not
anticipate the context surrounding a sensor failure.
Figure 1 depicts an unsafe condition that stemmed from a
sensor failure in ArduPilot. At the end of a landing operation,
IMU sensors failed. The control ﬁrmware detected the failure
and began to return to home using GPS driven ﬂight. At
normal ﬂight altitudes, these actions are safe; the GPS would
measure altitude less precisely than an IMU but sufﬁciently
to conduct simple maneuvers when used with other models.
However, the control ﬁrmware triggered GPS-driven ﬂight
under the incorrect assumption that the UAV could safely
navigate to a new altitude using the GPS alone. At
low
altitudes, such as the end of a landing operation, GPS is
too imprecise to guide major altitude adjustments. We can
repeatedly trigger this crash in simulation by failing IMU
sensors when the UAV is fewer than 2 meters above ground.
Sensor bugs are segments of control ﬁrmware source code
that, if ﬁxed, could eliminate an unsafe ﬂight condition caused
by a sensor failure. Figure 1 was caused by a sensor bug. If
control ﬁrmware checked altitude before switching to GPS
ﬂight, the crash could have been avoided. Instead, the landing
routine could have been allowed to complete normally.
Our analysis of public Github repositories reveals that
sensor bugs represent 40% of source code patches intended
to ﬁx UAV crashes. Further, sensor bugs often lead to crashes
or other serious consequences. However, the source code for
control ﬁrmware is large and complex. In practice, software
developers wait for users to report sensor bug manifestations
before trying to understand root causes. The severity of sensor
bug manifestations necessitates more preemptive approaches.
operating modeexecution tracenavigation plantriggering events0   1   2   3   4   5   6   7   8   9  10takeofffly to waypoint(auto mode)landreturn homeArdupilot sets return home & gps fail safe  imu fails during land;return home via gpsgps resolution is too coarse; crashIn-situ model checking systematically injects faults during
simulated executions, searching for faults that cause the system
to violate invariant properties. While in-situ model checking
enables preemptive analysis, UAVs present unique challenges
for its application. First, control ﬁrmware accesses sensor
readings frequently (103–104 times per second). Also, one
or multiple types of sensors can fail at any moment. This
failure space is immense. Second, sensor bug manifestations
depend on the timing and type of failure. Figure 1 depicts
the narrow window where an IMU failure can cause a UAV
to crash. Practical in-situ model checking approaches must
balance these conﬂicting concerns. While statistics-driven fault
injection seems necessary given the magnitude of the search
space, the sampling approaches could miss fault injections that
trigger time-sensitive bugs.
This paper presents Avis, an aerial-vehicle in-situ model
checker. Avis exploits a common sentiment among control
ﬁrmware developers: Sensor bugs often stem from failure
handling logic that is too narrowly tailored to speciﬁc oper-
ating modes. These bugs are hard to detect because failure
handling logic is implemented in different locations in the
ﬁrmware
[24]. Avis uses custom in-situ workloads that
exercise transitions between operating modes and carefully
injects failures, across all types of sensors, near the transitions
between operating modes. By exploiting operating modes,
Avis ﬁnds a nice balance. It prioritizes injection sites likely
to reveal bugs, but also captures time-sensitive issues at the
critical boundaries between operating modes. Compared to
Bayesian Fault Injection (BFI) [15], a statistically guided
model checker for autonomous vehicles, Avis does not rely
on statistical inference. BFI is more likely to trigger unsafe
conditions that occur in the main ﬂight mode, especially if
unsafe conditions have occurred in the past. In contrast, Avis
does not require training data and can comprehensively explore
fault handling logic that spans operating modes.
We implemented Avis and applied it to two open-source
control ﬁrmware: ArduPilot and PX4. We compared it to BFI
in terms of efﬁciency (unsafe conditions found per simulation)
and efﬁcacy (bugs uncovered). Avis found unsafe conditions
2.4X more efﬁciently than BFI. When we re-inserted 5
previously known software bugs that caused serious, unsafe
conditions, Avis found unsafe conditions caused by each bug.
BFI did not ﬁnd any. When we studied unsafe conditions that
Avis found in the current code base, we found 10 previously
unknown software bugs related to IMU and GPS failures (2
of which have been conﬁrmed by developers).
To summarize, our contributions are:
• A study characterizing the frequency and impact of sensor
bugs in widely used open-source control ﬁrmware.
• A fault injection approach that exploits operating modes
in UAV for stratiﬁed breadth-ﬁrst search.
• A framework for building UAV workloads that exercise
operating modes.
• A prototype of Avis and experimental results on ArduPi-
lot and PX4 that reveal the efﬁciency and efﬁcacy of our
Fig. 2: ArduPilot uses support for multiple threads to query
sensors and asynchronously update its main control loop.
approach by capturing previously known sensor bugs and
uncovering new, previously unknown bugs.
The rest of the paper is organized as follows. §II provides
background on sensor bugs and UAVs. §III shows the impact
of sensor bugs on UAV reliability. §IV presents the design
of Avis, including our framework to create workloads that
exercise operating modes and our stratiﬁed approach for fault
injection. §V describes implementation details. In §VI, we
present our evaluation of Avis and a study analyzing sensor
bugs and their manifestations in UAVs. We discuss related
work in §VII. Finally, we conclude in §VIII.
II. BACKGROUND
Figure 2 depicts runtime execution for ArduPilot, a widely
used software system for controlling UAVs [5]. Created in
2007 by hobbyists, ArduPilot is now used by more than 65
companies in industrial applications. It supports a wide range
of aircraft from large ﬁxed-wing planes to copters that weigh
less than a kilogram. The code base now exceeds 700K lines
with nearly 100 developers contributing to its maintenance.
PX4 is another popular, open-source framework for autopilot
control ﬁrmware [28]. PX4 has over 6M lines of code and is
used by the production-grade PixHawk UAV.
As shown in Figure 2, ArduPilot uses multiple parallel
threads to read from sensors and manage ﬂight dynamics.
Pilots can provide input with a remote control or with a laptop.
Throughout this paper, we refer to pilot inputs as the UAV
workload, i.e., a sequence of ﬂight commands. For example,
ArduPilot supports ﬂight commands to (1) directly adjust
thrust, yaw or pitch, and (2) ﬂy to a waypoint coordinate.
The code used to execute these commands differs. An oper-
ating mode encompasses all code execution associated with a
pilot command. Today, the ArduPilot code base supports 25
operating modes including takeoff, landing, manual piloting,
ﬂy to waypoint, return home, auto avoidance and acrobatics.
In addition, developers can add custom modes to create
automated ﬂight maneuvers.
During every iteration of the simulation, an operating mode
translates user inputs and sensor signals to actuation in the
motor systems. To help developers, ArduPilot includes models
to estimate the state of the aircraft. For any operating mode,
it is important to know the position, altitude and attitude of
the aircraft before adjusting motor systems. However, sensor
2
ArduPilot Runtime ExecutionExtendedKalmanFilterAsynchronous Execution (Background Threads)IMUGPSBarometerSet Operating ModeEnabled Modes0 – Stabilize3 – Auto4 – Guided ...User inputEstimate   -Position  -Attitude  -VelocityMode-AwareNavigation   -Motor &   Servo Ctrlthe frequency of such bugs. (2) Semantic bugs were often
asymptomatic (90%). Common symptoms include improper
messages appearing in logs, unimplemented commands, grad-
ual vehicle drift, and mishandled unit conversions resulting
in the vehicle navigating to an incorrect location. These bugs
reﬂected the growing number of contributors to the code base,
but they were resolved without serious consequences. (3) As
of this writing, ArduPilot and PX4 did not adopt tools for
rigorous fault injection. Code paths related to handling sensor
failures are checked by unit tests, but are not comprehensively
checked across multiple environments.
Finding 2: 47% of the sensor bugs are reproducible under
default settings.
Figure 3(B) examines the 44 sensor bugs in our study.
47% could be reproduced under default environment and
hardware settings. In a nutshell, these bugs followed a simple
template (1) trigger a sensor failure and (2) check the vehicle’s
behavior for symptoms. Wind and humidity contributed to
bugs that required special environmental conditions. However,
new aircraft also introduced bugs. For example, PX4-12758
in PX4 describes a sensor bug where the fault handling logic
in a new copter used the wrong interface to set return to home
mode on the aircraft.
Finding 3: About 34% of the sensor bugs have serious
symptoms.
Not only were sensor bugs the most common root cause
for bugs manifesting as a crash, Figure 3(C) shows that
most reported sensor bugs displayed symptoms. A signiﬁcant
portion of sensor bugs are serious (34%). This ﬁnding demon-
strates the importance of detecting sensor bugs in RVs. Sensor
bugs are prone to serious outcomes because UAV depend on
sensors for safe ﬂight. We noticed that, for many root causes,
developers applied default actions, like return to home, as-
suming they can be executed effectively. When sensors failed,
these assumptions–i.e., the difference between expectations,
modeled state and reality— had severe consequences.
IV. AVIS DESIGN
As shown in Figure 4, Avis consists of three major com-
ponents: workloads, a fault injection engine, and an invariant
monitor. Avis tests a UAV by simulating its behavior in a
physical environment under a workload. Workloads issue ﬂight
commands to the UAV, as shown in Figure 4. While the UAV
runs, the fault injection engine monitors the vehicle’s mode
transitions. The fault injection engine uses mode transitions to
schedule injections. Meanwhile, the invariant monitor checks
the UAV’s simulated physical state to detect unsafe conditions.
If an unsafe condition occurs, the invariant monitor generates
a detailed report to help reproduce and diagnose the bug.
UAV simulation involves executing mostly unmodiﬁed UAV
source code while simulating hardware. The only two modi-
ﬁcations are the use of simulated sensor and actuator drivers.
The sensor drivers read from the simulator instead of hard-
ware. The original ﬁrmware source code uses the simulated
Fig. 3: Analysis of reported bugs for ArduPilot and PX4.
failures can render these models useless because (1) fault
handling logic may not realize that state models differ from
normal ﬂight conditions (as in Figure 1) and (2) sensor failures
may lead to incorrect state models that diverge from reality.
When developer expectations, state models and reality differ,
the UAV is ﬂying in an unsafe condition that could have
serious consequences.