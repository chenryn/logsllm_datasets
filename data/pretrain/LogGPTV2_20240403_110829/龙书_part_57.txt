图5-4 中的 SDD 是L属性的。要知道为什么，考虑对应于继承属性的语义规则。为方
任何包含下列产生式和规则的 SDD 都不是 L 属性的:
A→BC
产生式
1） L→En
产生式
语义规则
print(E. val)
语义规则
B.b
201
口
口
---
## Page 218
足
A-→BCD。A、B、C、D这四个非终结符号都有两个属性：s是一个综合属性，而i是一个继承
出下列表达式对应的注释语法分析树：
部拓扑排序有哪些？
5.2.65.2节的练习
结符号L的各次出现相关的L.inh。
传递到结点5、7和9。这些结点表示和非终
性求值过程开始的地方。然后，这个类型被
addType 的应用于一个类型和这些 entry 值之一的哑属性。
结点1、2 和3 表示了和各个标号为 id的叶子结点相关的属性 entry。结点6、8 和 10 是表示函数
点的父结点的L,nh 值而得到的，这个父结点对应于此产生式的头。
将 L.inh 沿着语法分析树向下传递。也就是说，在一个分析树结点上，值 L.inh 是通过拷贝该结
它赋予正确的值：integer 或 float。这个类型值在产生式1的规则中被传递给属性L.inh。产生式4
相应的符号表条目中。
型沿着标识符列表向下传递，使得它可以被加人到
调它是一个继承属性。L.inh 的作用是将声明的类
非终结符号L也有一个属性，我们称它为inh，以强
列表。T有一个属性 T.type，它是声明 D 中的类型。
可知，这个声明包含一个类型T，后跟--个标识符的
也可以修改这个 SDD,使它能够对标识符声明次数进行检查。
这些条目可以按照任何顺序进行更新。这个SDD 不会检查－个标识符是否被声明了多次，我们
符号表条目中。我们假设录人一个标识符的类型不会影响其他标识符对应的符号表条目。这样，
符列表L。T的类型可以是int 或 float。对于列表中的每个标识符，这个类型被录人到标识符的
例5.10
L属性定义的要求。(出)是否存在和这些规则--致的求值过程？
练习5.2.2：对于图5-8中的SDD，给
练习5.2.1：图5-7中的依赖图的全
结点4 表示属性 T.type，它实际上是属
产生式2 和产生式3 都计算综合属性 T. type，为
非终结符号D表示了一个声明。根据产生式1
202
2) A.s = B.i + C.s 和D.i = A.i + B.s
1) A.s = B.i + C.s
练习5.2.3：假设我们有一个产生式
2) float w, x, y, z
1)int a,b,c 
输人串 float id,，id2，id;的依赖图如图 5-9 所示。数字1 ~10 表示了这个依赖图中的结点。
我们假设函数addType 正确地将 id 所代表的标识符的类型设置为类型值 L.inh。
产生式4 和产生式5还包含另一-个规则。该规则用如下两个参数调用函数 addType:
L.inh：被赋给列表中各个标识符的类型值。
图5-8中的SDD 处理了简单的声明 D。该声明中包含-一个基本类型T，后跟一个标识
图5-9声明 Hoat id,,id2,id,的依赖图
图5-8简单类型声明的语法制导定义 
5）
enh
entry
L→id
L→L1,id 
T →float 
T → int 
产生式
addType(id.entry, L.inh)
L,.inh = L.inh
 T.type = foat
T.type = integer
L.inh=T.type
语义规则
"ids3entry
第5章
---
## Page 219
号都有一个综合属性 node，该属性表示相应的抽象语法树结点。
目运算符+和－。通常，这两个运算符具有相同的优先级，并且都是左结合的。所有的非终结符
op字段，也就是这个结点的标号。这些对象将具有如下所述的其他字段：
例5.11
表子表达式 E,和 E2。
构造的有意义的组成部分。表示表达式E+E2的语法树结点的标号为+，且两个子结点分别代
5. 3.1
法分析过程中使用。第二个是一-个L属性定义，它适合在自顶向下的语法分析过程中使用。
方法，这个方法不需要显式地生成树。）
的 SDD，而通常的 SDD 建立于语法分析树之上。（第6 章将讨论应用一个 SDD 来生成中间代码的
编译器接下来可能使用一组规则来编译这棵语法树。这些规则实际上是一个建立于语法树之上
示形式，所以一种常见的 SDD形式将它的输人串转换为一棵树。为了完成到中间代码的翻译，
出一些例子来解释有代表性的 SDD。
5.3
NFA 的翻译。
的状态，也就是一个之前尚未被这个函数返回的状态。使用任何方便的表示方式来描述这个
char，并且char. lexval 是它所表示的字符。你可以假设存在一个函数 new（），该函数返回一个新
法把一个正则表达式转换为一个不确定的有穷自动机。假设有一个表示任意字符的词法单元
为十进制数5.635。提示：使用一个继承属性L. side 来指明一个二进制位在小数点的哪一边。
我们考虑两个为表达式构造语法树的 SDD。第--个是一个S 属性定义，它适合在自底向上语
语法制导的翻译
我们将使用具有适当数量的字段的对象来实现一棵语法树的各个结点。每个对象将有一个
 2.8.2节讨论过，一棵语法树中的每个结点代表一个程序构造，这个结点的子结点代表这个
本节中的主要应用是抽象语法树的构造。因为有些编译器使用抽象语法树作为一种中间表
本节的最后一个例子是一个处理基本类型和数组类型的L属性定义。
本章中的语法制导的翻译技术将在第6章中用于类型检查和中间代码生成。这里，我们将给
！！练习5.2.6：使用一个自顶向下语法分析文法上的L属性SDD来实现算法3.23。这个算
！！练习5.2.5：为练习5.2.4 中描述的文法和翻译设计一个S属性的 SDD。
设计一个 L属性的 SDD 来计算 S. pal，即输入串的十进制数值。比如，串 101.11 应该被翻译
·如果结点是一个叶子，那么对象将有一个附加的域来存放这个叶子结点的词法值。构造
语法制导翻译的应用
！练习5.2.4：这个文法生成了含"小数点”的二进制数：
!4) A.s = D.i, B.i = A.s + C.s, C.i = B.s 和 D.i = B.i + C.i
3) A.s = B.s + D.s
抽象语法树的构造
一个字段的值为op，其余k个字段的值为c1，，。
如果结点是内部结点，那么它的附加字段的个数和该结点在语法树中的子结点个数相同。
一个指向与叶子结点对应的新记录的指针。
函数Leaf(op，val)创建一个叶子对象。我们也可以把结点看作记录，那么Leaf 就会返回
图5-10 中的S 属性定义为一个简单的表达式文法构造出语法树。这个文法只包含二
203
---
## Page 220
据规则3，指向α 对应的叶子结点的指针同时也是语法分析树中最左边的E的E.node 值。
指向它们的指针，变成了图中的三个标号为T的语法分析树结点上的 T. node 的值。请注意，根
值id.entry 指向符号表，并且词法值 mum.val 是--个常量值。根据规则5 和6，这些叶子结点，或
的值。每条线都指向适当的抽象语法树结点。
使用点虚线表示边。实际上不需要生成语法分析树。第三种线是虚线，它表示 E. node 和 T node
为记录。这些记录的第一个字段是p。现在，抽象语法树的边用实线表示。基础的语法分析树
些结点就成为 T.node 的值。
这些括号了。
它们会影响语法分析树和抽象语法树的结构，但是一旦分组完成，就不需要在抽象语法树中保留
4，即 T-→(E)，也没有创建任何结点。T. node 的值和 E. node 的值相同，因为括号仅仅用于分组。
为 op，使用 E.node 和 T. node 作为代表子表达式的两个子结点。第二个产生式也有类似的规则。
图 5-11显示了为输人α-4+c构造一棵抽象语法树的过程。这棵抽象语法树的结点被显示
最后两个 T-产生式的右部是一个终结符号。我们使用构造函数Leaf 来创建合适的结点。这
每当使用第一个产生式E一E，+T时，它的语义规则就创建出一个结点。创建时使用“+"作
204
我们根据规则 2 创建了--个结点，该结点的 op 字段等于减号，它的指针指向前两个叶子结
在最底端，我们可以看到由 Leaf构造得到的分别表示α、4 和c的叶子结点。我们假设词法
产生式3，即 E-→T，没有创建任何结点，因为 E.node 和 T. node 是一样的。类似地，产生式
5
C
5
to entry for a
id:
T → num
T → id
T→(E)
←
产生式
图5-11α-4+c的抽象语法树
图5-10为简单表达式构造语法树
node
T.node = new Leaf (num, num.val)
T.node = new Leaf(id, id.entry)
T.node = E.node
E.node = T.node
E.node = new Node('-', E).node, T.node)
E.node = new Node('+', E.node, T.node)
nun
opou'g
num:
语义规则
to entry for c
"'T.node
第5章
---
## Page 221
处，E'.inh 表示 α-4 +c 的抽象语法树。
应于α的叶子结点。在结点6 处，E'.inh 表示对应于输入α－4 的部分抽象语法树的根。在结点9
树的根。在图5-14中依赖图的结点5处，E'.inh 表示对应于α的抽象语法树的根，实际上就是对
的部分抽象语法树。明确地说，它表示的是位于 E'的子树左边的输人串前缀所对应的抽象语法
的依赖图和图 5-7 中 3*4 的依赖图的相似之处。
在不同的子树中。非终结符号E'对应于例5.3 中的非终结符号T"。请比较一下图5-14 中α－4+c
递的。这里的思想是在构造x+y的抽象语法树时将x作为-个继承属性传递，因为x和+y 出现
子中，项x＊y中的x和＊y位于语法分析树的不同部分，因此在计算x*y时x是作为继承属性传
同。文法符号 E、T、id和 mum 的属性和例5-11 中讨论的相同。
例5. 12图5-13 中的L 属性定义完成的翻译工作和图 5-10 中的 S 属性定义所完成工作的相
析树的结构和抽象语法树的结构有极大的不同。
到的抽象语法树仍然相同，其构造的步骤也相同，虽然语法分
到的抽象语法树的根结点。
的，或者是在自底向上分析过程中和归约动作一起进行求值
点。然后，规则1将对应于－的结点和第三个叶子组合起来，得到这个抽象语法树的根结点。
非终结符号 E'有一个继承属性 inh 和一个综合属性 sym。属性 E'.inh 表示至今为止构造得到
语法制导的翻译
如果使用--个为自顶向下语法分析而设计的文法，那么得
这个例子中构造抽象语法树的规则和例5.3 中桌上计算器的规则类似。在桌上计算器的例
如果这些规则是在对语法分析树的后序遍历过程中求值
entry
图5-14
图5-13在自顶向下语法分析过程中构造抽象语法树
5
C
←
T → num
↑
E→TE'
产生式
使用图 5-13 中的 SDD 时的α-4 +c的依赖图
E 13 node
num
T.node = new Leaf (num, num.val)
T.node = new Leaf(id,id.entry)
T.node = E.node
E'.syn = E'.inh
E' syn = E syn.
El.inh = new Node('-',E' inh,T.node)
E'.inh = T.node
13val