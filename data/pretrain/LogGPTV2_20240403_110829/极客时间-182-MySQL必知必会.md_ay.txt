# 特别放送（四）\| 位置信息：如何进行空间定位？你好，我是朱晓峰。今天，我来和你聊一聊怎么进行空间定位。我们每天都会用到空间数据，比如你在网上购买一件商品，你手机上的 App就能够算出你是不是需要负担运费，负担多少运费。这其实就是因为手机获取到了你的空间位置信息，发送到网购平台，然后根据你所在的位置是否属于偏远地区，来决定你是否需要负担运费，如果需要的话，应该负担多少。而从应用开发者的角度出发，我们需要知道怎么进行空间定位，获取用户的空间位置信息，以及如何计算发货点与客户地址的距离，这些都要借助与空间数据相关的技术才能解决。今天，我还是借助一个真实的项目，来给你介绍下空间数据类型、空间数据处理函数，以及如何为空间数据创建索引，帮助你提升开发基于空间数据应用的能力。在我们超市项目的实施过程中，超市经营者提出了这样一个要求：要给距离门店5公里范围内的、从线上下单的客户提供送货上门的服务。要想解决这个问题，就需要用到空间数据了。空间数据类型与空间函数我先给你介绍下空间数据类型和空间函数。MySQL 支持的空间数据类型分为 2类： 1.  一类是包含单个值的几何类型（GEOMETRY）、点类型（POINT）、线类型（LINESTRINIG）和多边形类型（POLYGON）；        2.  另一类是包含多个值的多点类型（MULTIPOINT）、多线类型（MULTILINESTRING）、多多边形类型（MULTIPOLYGON）和几何集类型（GEOMETRYCOLLECTION）。        我简单说明一下这几种空间数据类型的特点。几何类型是一个通用的空间数据类型，你可以把点类型、线类型和多边形类型数据的值赋予几何类型数据。但是点类型、线类型和多边形类型数据则不具备这种通用性，你只能赋予它们各自类型数据的值。几何集类型数据可以保存点类型数据、线类型数据和多边形类型数据值的集合。多点类型、多线类型和多多边形类型则分别只能保存点类型数据、线类型数据和多边形类型数据值的集合。下面我们重点介绍一下点类型，因为这种类型是最简单、最基础的空间类型，也最常用。点类型（POINT）点类型是最简单的空间数据类型，代表了坐标空间中的单个位置。在不同比例尺的坐标空间中，一个点可以有不同的含义。例如，在较大比例尺的世界地图中，一个点可能代表一座城市；而在较小比例尺的城市地图中，一个点可能只代表一个车站。点类型数据的属性有 2 种：1.  坐标空间中的 X    轴的值（比如地理坐标中的经度值）；        2.  坐标空间中的 Y    轴的值（比如地理坐标中的纬度值）。        点类型数据的维度是0，边界为空。空间函数MySQL支持的空间函数有一百多种，我们没有必要全部都掌握。所以，我给你重点介绍几个比较常用的空间函数ST_Distance_Sphere()、MBRContains()、MBRWithin() 和ST_GeomFromText()。**1.ST_Distance_Sphere()函数** 我们先从计算空间距离的函数 ST_Distance_Sphere()说起，这个函数的语法结构和功能如下所示：1.  ST_Distance_Sphere(g1,g2)：g1 与 g2 为 2 个点，函数返回球体上 2    个点 g1 与 g2    之间的最小球面距离。        **2.MBRContains() 和 MBRWithin()函数** 在学习 MBRContains() 和 MBRWithin()函数之前，我们要先了解一个概念，也就是最小边界矩形（MBR，MinimumBounding Rectangle ）。最小边界矩形是指以二维坐标表示的若干二维形状（例如点、直线、多边形）的最大范围，即以给定的二维形状各顶点中的最大横坐标、最小横坐标、最大纵坐标、最小纵坐标决定的边界的矩形。知道了这个概念，你就能更好地理解这两个函数了。1.  MBRContains(g1,g2)：如果几何图形 g1 的最小边界矩形包含了几何图形    g2 的最小边界矩形，则返回 1，否则返回    0。    2.  MBRWithin(g1,g2)：与 MBRContains(g1,g2)    函数正好相反，MBRWithin(g1,g2) 表示，如果几何图形 g1    的最小边界矩形，包含在几何图形 g2 的最小边界矩形之内，则返回    1，否则返回 0。        **3.ST_GeomFromText()**这个函数的作用是通过 WKT 形式创建几何图形。而ST_GeomFromText(WKT,SRID) 就表示，返回用 WKT 形式和 SRID指定的参照系表达的几何图形。这里的 WKT 是一种文本标记语言，用来表示几何对象。SRID（SpatialReference Identifier）是空间参照标识符，默认是0，表示平面坐标系。我们平时常用的 SRID 是4326，是目前世界通用的以地球质心为原点的地心坐标系。知道了这些基础知识，我们就可以着手解决超市经营者提出的需求了。这家超市有很多门店，该怎么计算是否应该送货上门呢？如果应该送货上门，应该从哪家门店送货呢？我带你分析下具体的思路。1.  第一步，把门店的位置信息录入数据表中；        2.  第二步，根据下单客户的送货地址，获取到地理位置信息；        3.  第三步，计算各门店位置与送货地址的距离，找出最近的门店安排送货，如果没有一家门店与客户的距离在    5    公里以内，则提示不能送货。        下面我们就来实际操作一下。首先，我们创建一个门店表（demo.mybranch），包含门店编号、名称、位置等信息。    mysql> CREATE TABLE demo.mybranch    -> (    -> branchid SMALLINT PRIMARY KEY,    -> branchname VARCHAR(50) NOT NULL,    -> address GEOMETRY NOT NULL SRID 4326    -> );    Query OK, 0 rows affected (0.07 sec)这里需要注意一下，我这里的 address 字段，定义的空间数据类型是GEOMETRY，SRID 是 4326。因为 GEOMETRY类型比较通用，可以赋予任何类型的空间数据值，而且方便后面创建索引。SRID值为4326，表示采用地心坐标系，这样计算出来的距离才比较准确。当然，你完全可以使用空间数据类型POINT，也能达到同样的效果。现在，我们把门店位置信息录入表中：    mysql> INSERT INTO demo.mybranch VALUES        -> (1,'西直门店',ST_GeomFromText('POINT(39.938099 116.350266)', 4326)),          -- 西直门店的经纬度信息        -> (2,'东直门店',ST_GeomFromText('POINT(39.941143 116.433769)', 4326)),        -> (3,'崇文门店',ST_GeomFromText('POINT(39.896877 116.416977)', 4326)),        -> (4,'五道口店',ST_GeomFromText('POINT(39.9921 116.34584)', 4326)),        -> (5,'清河店',ST_GeomFromText('POINT(39.743378 116.332878)', 4326));    Query OK, 5 rows affected (0.03 sec)    Records: 5  Duplicates: 0  Warnings: 0结果显示，数据插入成功了。这里有 2个问题需要你注意。第一，我是用门店的经度和纬度值，来表示门店的地理位置。要获得门店的地理位置，你可以通过地图数据获得，但是这样做成本比较高。还有一种办法，就是通过大厂提供的免费的API 接口获取，比如百度地图API，这样比较简单。第二，WKT 格式表达一个点的时候，在关键字 POINT后面的括号中，要先写这个点的纬度，后写这个点的经度。这与一般的习惯相反，不要搞错。而且，经度值与纬度值之间用空格隔开，而不是用逗号。准备好各门店的位置信息之后，我们就可以通过空间函数来计算距离了。假设我们获取到客户所在位置的地理坐标为：纬度是 39.994671，经度是116.330788，那么，我们就可以通过下面的 SQL语句查询到这个位置与各个门店的距离：    mysql> SELECT branchid,branchname,st_distance_sphere(ST_GeomFromText('POINT(39.994671 116.330788)',4326),address) AS distance        -> FROM demo.mybranch;    +----------+------------+--------------------+    | branchid | branchname | distance           |    +----------+------------+--------------------+    |        1 | 西直门店   |  6505.859589677078 |    |        2 | 东直门店   |  10604.07854447186 |    |        3 | 崇文门店   |  13123.76779555601 |    |        4 | 五道口店   |  1313.741752971374 |    |        5 | 清河店     | 27943.114458834025 |    +----------+------------+--------------------+    5 rows in set (0.00 sec)结果显示，所有门店与客户位置之间的距离，都已经计算出来了。需要注意的是，这个结果中查出来的距离是以米为单位的。根据这个查询的结果，五道口店的球面最短距离只有1313 米，也就是 1.3 公里，满足送货上门的条件。其他门店的最短距离都在 5公里以上。因此，应该从五道口店送货上门。到这里，超市经营者的要求就得到了满足。好了，到这里，我们已经知道了如何定位一个空间位置，以及如何计算 2个位置之间的距离。接下来，我们就再来了解下如何通过创建索引来提升空间数据的查询效率。用空间数据创建索引对于空间数据的查询，一般分为 2种：一种是查询包括一个点的空间对象；另外一种是查询与某一个区域有交集的空间对象。为了提高查询的速度，就可以用空间数据字段创建空间索引。MySQL 支持使用InnoDB 存储引擎，或者是 MyISAM存储引擎的数据表，创建空间索引。我们有三种创建空间索引的方式。第一，我们可以在创建数据表时创建空间索引，语法结构是：    CREATE TABLE 表名 (字段名 GEOMETY NOT NULL SRID 4326，SPATIAL INDEX(空间数据字段名));第二种是在修改表时创建空间索引，语法结构是：    ALTER TABLE 表名 ADD SPATIAL INDEX (空间数据字段名);第三种是单独创建空间索引，语法结构是：    CREATE SPATIAL INDEX 索引名 ON 表名(空间数据字段名);这里要提醒你注意的是：空间索引与普通索引不同，必须要用关键字SPATIAL，而且，创建空间索引的空间数据字段不能为空。空间索引创建一个 R树索引，支持区域扫描，对提升空间数据查询的效率很有帮助。我还是以刚才的超市门店位置数据为例，来简单说明一下如何用空间类型字段创建空间索引。我我们先用下面的代码，单独创建一下空间索引：    mysql> CREATE SPATIAL INDEX index_address ON demo.mybranch(address);    Query OK, 0 rows affected, 1 warning (0.04 sec)    Records: 0  Duplicates: 0  Warnings: 1结果显示，创建成功了。现在我们来确认一下，刚才创建的空间索引能不能起到优化查询的作用。在 MySQL 中，只有在 WHERE 条件筛选语句中包含类似 MBRContains() 和MBRWithin()这样的函数，空间索引才会起作用。现在，我们来借助一个小例子验证一下，我们创建的空间索引能不能对空间数据的查询起到优化的作用。假设我们创建了一个多边形的地理区域，代码如下所示：    mysql> SET @poly =        -> 'Polygon((        '> 40.016712 116.319618,        '> 40.016712 116.412773,        '> 39.907024 116.412773,        '> 39.907024 116.319618,        '> 40.016712 116.319618))';    Query OK, 0 rows affected (0.00 sec)这里有个坑，你一定要注意，多边形的区域起点和终点一定要一致，否则就不是一个封闭的区域，MySQL就会提示非法的地理位置数据。然后，我们查询下有多少门店在这个区域中。你可以用下面的代码来实现：    mysql> SELECT branchid,branchname FROM demo.mybranch        -> WHERE MBRContains(ST_GeomFromText(@poly,4326),address);    +----------+------------+    | branchid | branchname |    +----------+------------+    |        1 | 西直门店   |    |        4 | 五道口店   |    +----------+------------+    2 rows in set (0.00 sec)结果显示，有 2个门店在这个地理区域范围内。下面我们用查询分析语句来分析一下这个查询，看看有没有用到空间索引：    mysql> EXPLAIN SELECT * FROM demo.mybranch        -> WHERE MBRContains(ST_GeomFromText(@poly,4326),address);    +----+-------------+----------+------------+-------+---------------+---------------+---------+------+------+----------+-------------+    | id | select_type | table    | partitions | type  | possible_keys | key           | key_len | ref  | rows | filtered | Extra       |    +----+-------------+----------+------------+-------+---------------+---------------+---------+------+------+----------+-------------+    |  1 | SIMPLE      | mybranch | NULL       | range | index_address | index_address | 34      | NULL |    5 |   100.00 | Using where |    +----+-------------+----------+------------+-------+---------------+---------------+---------+------+------+----------+-------------+    1 row in set, 1 warning (0.00 sec)结果显示，我们创建的索引起了作用，MySQL优化器使用空间索引进行了区域扫描，提高了查询的效率。总之，MySQL为空间数据提供了一套完整的解决方案。从空间数据类型到空间函数，再到空间索引，可以让我们像处理普通数据那样，来存储、处理和查询空间数据。这样一来，开发基于空间数据的应用就十分方便了。总结这节课，我给你介绍了 MySQL 的空间数据，包括空间数据类型POINT，空间数据处理函数 ST_Distance_Sphere()、MBRContains()、MBRWithin()和ST_GeomFromText()，以及创建空间索引的方法。MySQL的空间数据是非常有用的数据类型，通过各种空间数据处理函数，可以开发出路径规划、线路导航、自动驾驶等各种应用。虽然现在还存在数据量大、查询效率比较低等问题，但是通过不断使用新的技术，比如空间索引中引入R 树索引等，进步是非常明显的。如果你在实际工作中，需要开发基于空间数据的应用，课下可以再参考下链接slate-object="inline"中的内容。思考题在这节课中，我定义的门店表（demo.mybranch）中，地址的空间数据类型是几何类型GEOMETRY，请你改用点类型POINT，完成从创建表到查询最近门店的全部操作。欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你分享给你的朋友或同事，我们下节课见。
# 27 \| 手把手带你设计一个完整的连锁超市信息系统数据库（上）你好，我是朱晓峰。从创建第一个 MySQL 数据库开始到现在，我们已经学完了 MySQL的核心操作。最后这两节课，我想带你实际设计一个超市信息系统的数据库。毕竟，设计数据库很考验我们综合运用单个技术点的能力。所以，通过这个项目，我不仅会带你把前面的内容串联起来，而且还会教你设计数据库的通用思路。为什么选择超市项目呢？一方面呢，超市的场景与我们的日常生活密切相关，你比较容易理解其中的业务逻辑，另一方面，超市的业务又相当复杂，几乎能用到我们学到的所有知识点，利于我们对前面学过的内容进行整合。今天，我就带你一起，从需求分析开始入手，一直到容灾和备份，完成一个全流程的连锁超市数据库设计。这节课，我会主要给你讲解需求分析、ER模型、分库分表和数据库设计方案。我们做项目，首先要从大处着眼，把握方向，这样才不容易出现大的偏差。下节课，我们再设计具体的细节，比如创建数据表、外键约束，设计灾备方案和备份数据等。在开始设计之前，咱们得先了解一下项目背景。随着互联网使用的日益广泛，传统的桌面管理系统的数据不能互通、资源利用率低等弊端越来越明显，显然不能满足用户的需求了。因此，我们需要开发一款基于云服务的连锁超市管理信息系统。具体的要求是：1.       基于浏览器，无需安装，账号开通即可使用，方便快捷；        2.       数据部署在云端，由运营商负责维护，安全可靠；        3.       用户无需自备服务器，只需租用信息服务，资源利用率高。        知道了具体要求，那该怎么进行设计呢？下面我带你来分析一下。如何设计数据结构？用户账号开通即可使用，所以必然要设计分层的数据结构；数据要部署在云端，所以必然要使用云。根据这些要求，我们可以设计一个基于云服务的2层数据结构，这个结构的示意图如下所示：![](Images/45dbd857faffc11c9d6e467e2e04444e.png)savepage-src="https://static001.geekbang.org/resource/image/38/9d/38e25fa9d5e2b449yy498a60ef874e9d.jpg"}我来解释一下图中展示的内容。首先，你可以看到，所有的系统资源和服务都部署在云端。其次，我们来看下数据结构层面，主要有 2层。 1.       第一层是商户。每个入驻的商户都有一个组号，所有与这个商户有关的数据，通过这个组号进行识别。        2.       第二层是分支机构。分支机构从属于商户，相同商户的分支机构有相同的组号。分支机构分为几种，包括总部、门店、配送中心等。门店又分为直营店和加盟店。每个分支机构有一个机构编号，同一分支机构的数据，有相同的组号和机构编号。        这样一来，新商户只需要开通账号，分配一个新的组号，就可以使用了。组号用于隔离商户之间的数据，使商户之间互相不影响。最后，数据由我们统一进行运维，安全性有保障。商户自己不需要采购服务器，只需租用服务，资源的利用率更高。系统的整体结构设计思路有了，那具体在应用层面如何实现呢？我先用一张图来展示具体的应用构成：![](Images/3ba1b5f0c2f390f5320892035c89e376.png)savepage-src="https://static001.geekbang.org/resource/image/59/4c/5985a0c712296421bf7b36d50e4d2b4c.jpg"}这个图展示了应用的 3个层级。 1.       展现层：包括门店收款机 App、移动端的手机    App、小程序，以及通过浏览器访问的后台管理部分。        2.       服务层：包括云端的销售模块、库存模块、营运模块、会员模块等。        3.       数据层：MySQL 数据库。        门店收款 App、移动端的手机App，小程序等与数据库设计无关，我就不多说了。下面我重点介绍一下后台管理部分下面的服务层和数据层的相关内容。服务层包括了销售、库存、营运、会员等管理模块。下面我就以库存管理中的盘点模块为例，详细介绍一下。因为这个模块比较简单，容易理解。盘点，简单来说，就是把超市仓库里的商品都数一遍，然后跟电脑里的库存数比对，看看有没有不对的地方。实际数出来的库存数量叫做盘存数量，电脑中的库存数量叫做结存数量，比对的结果叫做盈亏数量。要是盘存数量比结存数量多，叫盘盈，否则叫做盘亏。盘点操作是超市库存管理模块中的一个重要环节，是掌握实际库存的唯一办法。盘点盈亏数据也是衡量超市管理水平的重要指标。盘点作业一般都在晚上门店营业结束以后进行。这也很好理解，毕竟，在白天营业的过程中，商品不断被顾客取走，又不断得到补充，库存处于一种变化状态，无法获取准确数据。下面我来介绍下盘点的步骤。1.       先生成一张盘点表，把当前系统中的库存数量提取出来，获得结存数量；        2.       把员工实际数出来的库存数据录入盘点表中，获得盘存数量；        3.       计算盈亏数量，公式是"盈亏数量 = 盘存数量 -    结存数量"；        4.       数据确认无误后，验收盘点表，并调整当前库存：库存数量 = 库存数量 +    盈亏数量。        经过这些操作，系统中的库存数量与实际的库存数量就一致了，盘点盈亏也被记录下来了，体现在日报等报表中，超市经营者可以进行查看，为经营决策提供依据。介绍完了盘点业务，现在回到数据库设计的主题上来，看看如何把盘点业务用数据表的形式表现出来。盘点业务都是在门店进行，由员工实际操作，对仓库中的商品进行清点。因此，盘点业务模块中肯定要包含员工、门店、仓库、商品等实体。这个时候，我们就可以使用ER模型这个工具，来理清盘点模块的业务逻辑。盘点模块的 ER 模型我先把模型直接展示给你，一会儿我再带你具体分析一下。![](Images/7bc175dc57787500cd3e89d5b814bc93.png)savepage-src="https://static001.geekbang.org/resource/image/c2/93/c2a44370af7ba1538169bf82e78c5993.jpg"}首先，我们来分析下模型中的实体和关系。这个 ER 模型中包括了 5个实体，分别是：1.       商户        2.       门店        3.       员工        4.       商品        5.       仓库        其中，商户和商品是强实体，门店、仓库和员工是弱实体。这个 ER 模型中还包含了 5 个关系，我们按照 1对多和多对多来分下类。1 对多：1.       商户与门店的从属关系        2.       门店与员工的雇佣关系        3.       门店与仓库的拥有关系        多对多：1.       仓库与商品的库存关系        2.       仓库、商品和员工参与的盘点关系        接下来，我们再分析一下这 5个实体各自的属性。1.       商户：组号、名称、地址、电话、联系人。        2.       门店：组号、门店编号、名称、地址、电话、类别。        3.       员工：组号、门店编号、工号、名称、身份证、电话、职责。        4.       仓库：组号、门店编号、仓库编号、类别。        5.       商品：组号、条码、名称、规格、单位、价格。        除此之外，还有 2个多对多关系的属性。1.       仓库与商品的库存关系：库存数量。        2.       仓库、商品和员工参与的盘点关系：盘存数量、结存数量和盈亏数量。        通过建立 ER模型，我们理清了业务逻辑。接下来，我们就可以把盘点业务中这些实体和关系落实到实际的数据表了。ER 模型转换成数据表你还记得在第 23 讲slate-object="inline"里学的转换规则吗？强实体和弱实体转换成独立的数据表，多对多的关系转换成独立的数据表，1对多的关系转换成外键约束。首先，我们把强实体转换成独立的数据表。商户表（demo.enterprice）：![](Images/882f3a326319c889ae9a868b15e45a4c.png)savepage-src="https://static001.geekbang.org/resource/image/bf/8f/bf5228f8513beb3bd9ab61747c8d5c8f.jpeg"}商品信息表（demo.goodsmaster）：![](Images/ee7b32235c5b25166c2734aff17031ca.png)savepage-src="https://static001.geekbang.org/resource/image/65/a5/65d72ff47b7210968026ee4eba33fba5.jpeg"}接着，我们把弱实体转换成独立的数据表。门店表（demo.branch）：![](Images/8df959ff504a55067c84c5a55c4ab1e9.png)savepage-src="https://static001.geekbang.org/resource/image/89/31/8908eaa15ba0ef46f6a5346005087631.jpeg"}员工表（demo.employee）：![](Images/76bd37c69e9b26b82848fadfcf22beed.png)savepage-src="https://static001.geekbang.org/resource/image/54/87/54d3662c47d68443c468884099d6aa87.jpeg"}仓库表（demo.stockmaster）：![](Images/9602c016cf35926ef873b531eb341871.png)savepage-src="https://static001.geekbang.org/resource/image/44/a2/448b405b670498b70b4a088214f932a2.jpg"}第三步，把多对多的关系转换成独立的数据表。库存表（demo.inventory）：![](Images/33a241743148f6adc5c8edd4f1088b1b.png)savepage-src="https://static001.geekbang.org/resource/image/b0/0d/b0dd7aff562eccb063ee81f44981f80d.jpeg"}盘点关系可以转换成 2个表，分别是盘点单头表和盘点单明细表，这样做是为了满足第三范式的要求，防止冗余。盘点单头表（demo.invcounthead）：![](Images/dd3901f8f412ce5e0b23dea66a38aa89.png)savepage-src="https://static001.geekbang.org/resource/image/68/ab/6884c011854524ae68898109eb2fccab.jpeg"}盘点单明细表（demo.invcountdetails）：![](Images/f98787522ca4dd9bf36481a6ec9f08c2.png)savepage-src="https://static001.geekbang.org/resource/image/0f/ba/0f357a14eed20a91980fe5b4a36f92ba.jpeg"}这样一来，我们就把 ER模型中的实体和多对多的关系，转换成了独立的数据表。这里你要注意的是，我在盘点单明细表中保留了组号和门店编号。这是因为，虽然这2个字段是冗余数据，但是可以加快查询的速度，经过权衡利弊，最后决定还是加上。在我把 1对多的关系转换成外键约束之前，我们还要进行一项重要的工作：分库分表。因为外键约束与数据表以及表中的字段有关，分库分表会影响到表和表中的字段。而且外键约束需要在创建数据表的时候创建，所以咱们下节课和创建数据表一起讲，这节课我们先学习下分库分表。在前面的课程中，每节课我们都是以具体技术点为核心展开的。而分库分表，只有在进行数据库系统整体设计的阶段才会用到。所以，今天我就结合咱们这个项目的系统设计，来给你具体讲一讲如何进行分库分表。为什么要分库分表呢？当数据量足够大的时候，即便我们把索引都建好，系统资源调优到极致，仍然有可能遇到运行缓慢、CPU使用率居高不下的情况。因为单个数据库中单个表的数据量高到一定程度，超过了系统的承载能力。面对这种情况，我们有 2 种选择：一种是购买更多的资源，增加内存，增加CPU的算力，但是这样会增加系统的成本。这个时候，我们就可以用另一种方法，也就是接下来我要讲的分库分表。如何进行分库分表？所谓的分库分表，其实就是把大的数据库拆成小数据库，把大表拆成小表，让单一数据库、单一数据表的数据量变小。这样每次查询时，需要扫描的数据量减少了，也就达到了提升查询执行效率的目的。分库分表又可以分成垂直分表、垂直分库、水平分库和水平分表。垂直分表**所谓垂直分表，就是把一个有很多字段的表，按照使用频率的不同，拆分成2 个或多个表**。为了帮助你理解，还是用我们的盘点模块中的表来演示说明一下。每个商户都有一个自己的商品信息表，数据量比较大。所以，我们可以拆分下这个表。我们把经常使用的字段条码、名称和价格，拆分成商品常用信息表（demo.goods_o）；把剩下的字段，也就是规格和单位拆分成商品不常用信息表（demo.goods_f）。商品常用信息表：![](Images/447830cbf614e16c349c463de387ba51.png)savepage-src="https://static001.geekbang.org/resource/image/0c/5d/0c4bea15a6339f79f000429f4065985d.jpeg"}商品不常用信息表：![](Images/ec1dcfbf0c32bdff5bb258a66254ea16.png)savepage-src="https://static001.geekbang.org/resource/image/a4/36/a4e5260d7e28fbeabf632edf3510cb36.jpeg"}至于商户表、门店表、员工表、仓库表，这些表的数据量有限，不需要拆分。库存表、盘点单头表和盘点单明细表，虽然数据量大，但是评估之后，我们发现字段的使用频率都很高，拆分的价值不大，所以也不需要拆分。下面我再介绍一下什么是垂直分库。垂直分库**垂直分库的意思是，把不同模块的数据表分别存放到不同的数据库中**。这样做的好处是，每个数据库只保存特定模块的数据，系统只有用到特定模块的数据时，才会访问这个数据库。这样就减少了数据库访问的次数，就相当于是把数据访问的流量分散了。这个可能不太好理解，我来画一个简单的示意图：![](Images/4e5ebe27d3d11f3c210144f697e43a89.png)savepage-src="https://static001.geekbang.org/resource/image/44/43/44ea44e705c890cbcd93eac6ae6a1043.jpg"}在这个图中，数据不再存储在一个数据库中，而是根据业务模块的不同，分别存储在不同的数据库中，比如销售数据库、库存数据库、营运数据库、会员数据库等。这样一来，业务模块可以主要与自己的数据库进行数据交互。业务内的数据交互多了，业务与业务之间的数据交互就可以大大减少了。这样做的好处主要有 3 个：1.       单个数据库的数据量减小了；        2.       单个数据库的访问流量分散了；        3.       系统整体的故障风险减小了。        下面我再介绍一下什么是水平分库和水平分表。水平分库和水平分表当垂直分表已经穷尽，垂直分库也不能再拆分的时候，我们还可以做水平分库和水平分表。**水平分表的意思是，把数据表的内容，按照一定的规则拆分出去**。盘点数据会不断累积，数据量越来越大。为了提升系统效率，我们制定了水平分表的策略。第一步，我们把盘点单头表和盘点单明细表水平拆分：把验收处理过的盘点单头表和盘点单明细表拆分到盘点单头历史表和盘点单明细历史表。这样做的好处是，盘点单头表和盘点单明细表经常需要进行插入、删除和修改操作，只保留当前正在处理的数据，可以提升效率，避免在一个不断增长的大表中进行DML 操作。 而盘点单头历史表和盘点单明细历史表中的数据虽然不断增长，但数据不会修改，只进行查询操作。用经常作为筛选条件的字段创建索引，可以大大加快查询的速度。拆分出来的盘点单头历史表（demo.invcountheadhist）与盘点单头表类似，不同之处是增加了验收人编号（confirmer）和验收日期（confirmationdate）。盘点单头表历史表：![](Images/42dfc66b5af052dd3f784dcfb538d24b.png)savepage-src="https://static001.geekbang.org/resource/image/0a/90/0aa2010fcaabc0782f02c6d1823d0f90.jpeg"}拆分出来的盘点单明细历史表（demo.invcountdetailshist）的字段则与盘点单明细表一样。盘点单明细历史表：![](Images/652709f3d6ea2cd6f9f881421f1c9341.png)savepage-src="https://static001.geekbang.org/resource/image/51/e7/51e7b78c773310c54322071ac1aebfe7.jpeg"}第二步，我们把组号大于 500、小于 1000的商户数据，拆分到另外的数据表里进行保存。这里的数字是我们根据对入驻平台商户的数据量进行评估之后得出的，在实际工作中，你可以根据实际情况来决定。**原则是：确保单个数据表中的数据量适中，不会成为操作的瓶颈**。这样，我们就完成了对盘点模块中数据表的水平拆分。接下来，我们来进行水平分库。水平分库的目的是使单个数据库中的数据量不会太大。这样可以确保我们设计出来的数据库，在大数据环境下，也能高效运行。**水平分库的意思与水平分表类似，就是按照一定的规则，****把数据库中的数据****拆分出去，保存在新的数据库当中**。新的数据库可以在相同的服务器上，也可以在不同的服务器上。比如，我们可以把组号大于500、小于 1000的用户数据拆分出来，保存到新的服务器的数据库中。不过，保存到新的服务器，也就意味着增加系统的开销。因此，我们可以以 500 个商户为单位，每 500个商户，在相同的服务器上创建一套新的数据库；每 5000个商户，购置新的服务器。这样，我们就完成了对数据库进行分库的设计。总结这节课，我们一起设计了一个基于云服务的连锁超市管理系统数据库。你要重点掌握如何进行需求分析、如何把分析的结果转换成数据库的设计，以及如何在总体设计的阶段通过使用分库分表使设计出来的数据库能够处理大量数据。在实际项目中，你要重点关注 3个方面。 1.  第一，要充分理解项目需求。有的时候，客户自己也不清楚自己的需求。这个时候，就需要你帮助客户理清思路。你可以把客户的需求用图表等方式整理出来，再跟客户一起讨论。在这个阶段，投入较多的时间是值得的，如果等系统开发完成之后再改，成本就很高了。        2.  第二，使用 ER    模型工具来整理思路，可以提高效率，提高设计的质量。        3.  第三，要充分考虑到系统投入运行之后的承载能力。如果有可能处理大量数据，就需要考虑分库分表的策略。        最后，还有几点你需要注意下。1.       分库分表的策略，需要在设计阶段完成。如果缺乏整体分库分表的策略而匆忙上线，遇到瓶颈时再解决，花费的成本要远远高于在设计阶段投入的时间成本。        2.       分库分表的策略，必然带来开发和运维方面成本的提升，因此，你需要在设计阶段就有一个整体规划。比如，在类的设计里面，用正则表达式计算访问的服务器、数据库和数据表的名称。        3.       分库分表一般适用于比较大的项目，如果你开发的应用数据量小，系统规模有限，团队成员不多，不如就用一个服务器、一个数据库。因为分库分表对数据量小的项目没有什么作用，却会大大提升开发的复杂度，增加开发、运维和项目管理的成本。所以，你要综合考虑利与弊。        思考题假设我有一个数据库demo，当中有一个商品流水表（demo.trans），示例如下：![](Images/e5845706a8cb77fc9774a2520a6a29b9.png)savepage-src="https://static001.geekbang.org/resource/image/1e/cc/1ecd89a9d71e7ayye43ac9e85b8e2bcc.jpg"}在设计阶段，如果预见到未来数据量会非常庞大，你会如何制定分库分表策略？欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你分享给你的朋友或同事，我们下节课见。