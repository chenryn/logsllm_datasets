this log to revert program state to a point before the last network in-
put, and restarts execution from this point. It achieves good runtime
performance by logging only global variable updates, and by sup-
porting recovery at the granularity of function calls. This choice (to
limit logging) leads to total restarts for some applications, thereby
losing the beneﬁts of light-weight recovery.
ARBOR [18] is similar to the approach presented in this paper
in terms of its reliance on an application’s built-in error handling
capabilities for recovery. It differs from the approach described in
this paper in its use of program behavior models [28] (rather than
input format speciﬁcations) to identify input context. For some
programs, the context information provided by the behavior model
isn’t sufﬁcient to generate accurate signatures. Other differences
include the absence of correlation step in ARBOR, and its inability
to generate network level attack signatures.
Network-level Detection of Buffer Overﬂows. Buttercup [23]
and [12] detect buffer-overﬂow attacks in network packets by rec-
ognizing jump addresses within network packets. Buttercup re-
quires these addresses to be externally speciﬁed, while [12] detects
them automatically, by leveraging the nature of stack-smashing at-
tacks and the memory layout used in Linux. [37] suggested a more
robust approach for detecting buffer overﬂow attacks using abstract
execution of the attack payload. PayL [39] develops a new tech-
nique for anomaly detection on packet payloads that can detect
a wider range of attacks. However, the technique has a higher
false positive rate than the above techniques. Shield [38] uses
vulnerability-speciﬁc (but exploit-generic) signatures to ﬁlter out
attacks, but these signatures need to be speciﬁed manually.
Network Signature Generation. Earlybird[32] and Autograph[16],
two of the earliest approaches for worm detection, relied on charac-
teristics of worms to classify network packets as benign or attack-
bearing. Honeycomb [17] avoids the classiﬁcation step by using a
honeynet, which only receives attack trafﬁc.
From the packets classiﬁed as worm-related, these techniques
compute a signature that consists of a single contiguous byte se-
quence that repeats across them. Unfortunately, polymorphic worms
can modify themselves as they propagate from one host to another,
thereby confusing signature generation. To mitigate this problem,
Polygraph [21] can generate multiple (shorter) byte-sequences as
signatures. They argue that there must be some invariants even
in network ﬂows produced by polymorphic worms, and their tech-
nique is tuned to identify these invariants. PADS [36] develops
a technique called position-aware distribution signatures to detect
certain kinds of polymorphic attacks.
Compared with our approach, all of the above approaches op-
erate with rather coarse information about location and context of
attacks within network ﬂows. They don’t have the beneﬁt of ei-
ther our correlation step (which identiﬁes the bytes within network
ﬂows that are related to attacks) or the input context identiﬁcation
step (which identiﬁes the location of these attack bytes within the
structure of an input message). As a result, there is no way for
these techniques to distinguish between relevant parts of attack-
bearing ﬂows from irrelevant parts. To compensate for this, they
need sufﬁcient number of attack samples such that only the “rele-
vant” parts remain invariant across these samples. In contrast, using
correlation and input context identiﬁcation, our approach is able to
generate signatures from single attack instances. Moreover, these
signatures only capture message types and/or ﬁelds relevant to the
attack, thereby reducing false negatives and false positives.
Nemean [42] improves on the above approaches by incorporat-
ing protocol semantics into the signature generation algorithm. By
doing so, they are able to handle a broader class of attacks than pre-
vious signature generation approaches that were primarily focused
on worms. Like other network-based approaches, Nemean does not
have the beneﬁt of a correlation step to pinpoint attack-containing
bytes, but its knowledge of service semantics provides capabilities
similar to our input context identiﬁcation. However, our approach
requires only simpliﬁed message format speciﬁcations, whereas
their approach seems to require more detailed knowledge of ser-
vice semantics that needs to be incorporated into their implemen-
tation. Another signiﬁcant difference is that our technique does
not require expert knowledge about which message ﬁelds are more
likely to contain attacks.
Hybrid Approaches for Signature Generation. The HACQIT
project [25] uses software diversity for attack detection. A rule-
based algorithm is then used to learn characteristics of suspect in-
puts. The approach generates an effective signature for Code Red.
TaintCheck [22] and Vigilante [9] track the ﬂow of information
from network inputs to data used in attacks, e.g., a jump address
used in a code-injection attack. Vigilante also develops the no-
tion of self-certifying alerts (SCAs) that can be shared over the
network without requiring recipients to trust each other. The sig-
natures generated by the two approaches are somewhat simplistic
— Taintcheck uses the 3 leading bytes of a jump address as a sig-
nature, whereas Vigilante relies on absolute offsets of the jump ad-
dress from the beginning of input. In our terminology, these ap-
proaches don’t employ context identiﬁcation step, but do provide
a more robust implementation of correlation. For instance, accu-
rate correlation can be achieved even when input is transformed
(e.g., using URL encoding) before overwriting a pointer.
In our
approach, we have traded this level of accuracy in favor of signif-
icantly better performance — zero overheads under normal opera-
tion, as compared to 10x slowdown in the case of Taintcheck.
FLIPS [19] uses PayL [39] to detect anomalous inputs. If the
anomaly is conﬁrmed by an accurate attack detector (which, in
their implementation, was based on instruction set randomization),
a content-based signature (using longest-common substring) is gen-
erated after several attack instances. In our terminology, their ap-
proach consists of a detection and a signature generation step, but
doesn’t use the correlation and input context identiﬁcation steps.
Independent of our work, Xu et al. [40] developed an approach
for signature generation that uses a post-crash forensic analysis of
address-space randomized programs, similar to our technique. In
addition to analyzing program memory, they use attack replay tech-
niques to re-execute the vulnerable sections of code and pinpoint
the source of the vulnerability. However, since their approach lacks
the correlation and input context identiﬁcation steps, their signa-
tures cannot get to the root cause of a vulnerability, but rather rely
on jump addresses used in an attack. Such an approach can suffer
from false positives, especially with protocols that use binary data.
9. Conclusion
In this paper we presented a new approach, called COVERS, for
protecting servers from repetitive buffer overﬂow attacks, such as
those due to worms and zombies. Our approach combines off-the-
shelf attack detection techniques with a forensic analysis of the vic-
tim server memory to correlate attacks to inputs received from the
network, and automatically generates signatures to ﬁlter out future
attack instances. This improves the ability of victim applications to
withstand attacks by one to two orders of magnitude.
As compared to previous techniques, COVERS introduces mini-
mal overheads of under 10% during normal operation. In our eval-
uation, we showed that COVERS signatures capture the charac-
teristics of underlying vulnerabilities, thereby providing protection
against attack variants that exploit the same vulnerability. In con-
trast with previous approaches, which required many attack sam-
ples to produce signatures that are sufﬁciently general to stop poly-
morphic attacks, our approach is able to generate signatures from a
just a single attack instance. This is because of the use of a 4-step
approach that allows COVERS to localize the source of attacks to a
small part of an input message. We believe that other signature gen-
eration techniques, which often employ more powerful algorithms
at the signature generation step, can derive signiﬁcant beneﬁt by
incorporating our correlation and input context identiﬁcation steps.
The signatures generated by COVERS can be distributed and de-
ployed at other sites over the Internet. This deployment can take the
form of an inline ﬁlter at the network layer. As a proof of this con-
cept, we recently implemented a Snort [34] plug-in that ﬁlters out
network ﬂows that match the signatures generated by COVERS.
Acknowledgement
We thank Mohammed Mehkri and Karthik Sreenivasa Murthy for
the help in collecting attack examples and in the implementation
of input format speciﬁcation. We thank the anonymous reviewers
for their comments, which are very helpful in preparing the ﬁnal
version of this paper.
10. REFERENCES
[1] The PaX team. http://pax.grsecurity.net.
[2] A. Baratloo, N. Singh, and T. Tsai. Transparent run-time defense
against stack smashing attacks. In USENIX Annual Technical
Conference, 2000.
[3] E. Barrantes et al. Randomized instruction set emulation to disrupt
binary code injection attacks. In ACM CCS, 2003.
[4] S. Bhatkar, D. DuVarney, and R. Sekar. Address obfuscation: An
efﬁcient approach to combat a broad range of memory error exploits.
In USENIX Security, 2003.
[5] S. Bhatkar, R. Sekar, and D. DuVarney. Efﬁcient techniques for com-
prehensive protection from memory error exploits. In USENIX
Security, 2005.
[6] S. Chen, J. Xu, E. Sezer, P. Gauriar, and R. Iyer.
Non-control-hijacking attacks are realistic threats. In USENIX
Security, 2005.
[7] T. Chiueh and F. Hsu. RAD: A compile-time solution to buffer
overﬂow attacks. In ICDCS, 2001.
[8] W. Cohen. Fast effective rule induction. In International Conference
on Machine Learning, 1995.
[9] M. Costa et al. Vigilante: End-to-end containment of Internet worms.
In SOSP, 2005.
[10] C. Cowan et al. StackGuard: Automatic adaptive detection and
prevention of buffer-overﬂow attacks. In USENIX Security, 1998.
[11] H. Etoh and K. Yoda. Protecting from stack-smashing attacks.
http://www.trl.ibm.com/projects/security/ssp/main.html, 2000.
[12] F. Hsu and T. Chiueh. CTCP: A centralized TCP/IP architecture for
networking security. In ACSAC, 2004.
[13] T. Jim et al. Cyclone: a safe dialect of C. In USENIX Annual
Technical Conference, 2002.
[14] R. Jones and P. Kelly. Backwards-compatible bounds checking for
arrays and pointers in C programs. In Intl. Workshop on Automated
Debugging, 1997.
[15] G. Kc, A. Keromytis, and V. Prevelakis. Countering code-injection
attacks with instruction-set randomization. In ACM CCS, 2003.
[16] H. Kim and B. Karp. Autograph: Toward automated, distributed
worm signature detection. In USENIX Security, 2004.
[17] C. Kreibich and J. Crowcroft. Honeycomb – creating intrusion
detection signatures using honeypots. In HotNets-II, 2003.
[18] Z. Liang and R. Sekar. Automatic generation of buffer overﬂow
attack signatures: An approach based on program behavior models.
In ACSAC, 2005.
[19] M. Locasto, K. Wang, A. Keromytis, and S. Stolfo. FLIPS: Hybrid
adaptive intrusion prevention. In RAID, 2005.
[20] G. Necula, S. McPeak, and W. Weimer. CCured: Type-safe
retroﬁtting of legacy code. In POPL, 2002.
[21] J. Newsome, B. Karp, and D. Song. Polygraph: Automatically
generating signatures for polymorphic worms. In IEEE S&P, 2005.
[22] J. Newsome and D. Song. Dynamic taint analysis for automatic
detection, analysis, and signature generation of exploits on
commodity software. In NDSS, 2005.
[23] A. Pasupulati et al. Buttercup: On network-based detection of
polymorphic buffer overﬂow vulnerabilities. In IEEE/IFIP Network
Operation and Management Symposium, 2004.
[24] H. Patil and C. Fischer. Efﬁcient run-time monitoring using shadow
processing. International Workshop on Automated and Algorithmic
Debugging, 1995.
[25] J. Reynolds, J. Just, L. Clough, and R. Maglich. On-line intrusion
detection and attack prevention using diversity, generate-and-test,
and generalization. In Hawaii International Conference on System
Sciences, 2003.
[26] M. Rinard, C. Cadar, D. Roy, and D. Dumitran. A dynamic technique
for eliminating buffer overﬂow vulnerabilities (and other memory
errors). In ACSAC, 2004.
[27] O. Ruwase and M. Lam. A practical dynamic buffer overﬂow
detector. In NDSS, 2004.
[28] R. Sekar, M. Bendre, P. Bollineni, and D. Dhurjati. A fast
automaton-based method for detecting anomalous program
behaviors. In IEEE S&P, 2001.
[29] H. Shacham, M. Page, B. Pfaff, E. Goh, N. Modadugu, and D.
Boneh. On the effectiveness of address-space randomization. In ACM
CCS, 2004.
[30] S. Sidiroglou and A. Keromytis. Countering network worms through
automatic patch generation. IEEE Security & Privacy, 2005.
[31] S. Sidiroglou, M. Locasto, S. Boyd, and A. Keromytis. Building a
reactive immune system for software services. In USENIX Annual
Technical Conference, 2005.
[32] S. Singh, C. Estan, G. Varghese, and S. Savage. Automated worm
ﬁngerprinting. In OSDI, 2004.
[33] A. Smirnov and T. Chiueh. DIRA: Automatic detection,
identiﬁcation and repair of control-hijacking attacks. In NDSS, 2005.
[34] Snort. Open source network intrusion detection system.
http://www.snort.org.
[35] A. Sovarel, D. Evans, and N. Paul. Where’s the FEEB?: The
effectiveness of instruction set randomization. In USENIX Security,
2005.
[36] Y. Tang and S. Chen. Defending against Internet worms: A
signature-based approach. In INFOCOM, 2005.
[37] T. Toth and C. Kruegel. Accurate buffer overﬂow detection via
abstract payload execution. In RAID, 2002.
[38] H. Wang, C. Guo, D. Simon, and A. Zugenmaier. Shield:
Vulnerability-driven network ﬁlters for preventing known
vulnerability exploits. In SIGCOMM, 2004.
[39] K. Wang and S. Stolfo. Anomalous payload-based network intrusion
detection. In RAID, 2004.
[40] J. Xu, P. Ning, C. Kil, Y. Zhai, and C. Bookholt. Automatic diagnosis
and response to memory corruption vulnerabilities. In ACM CCS,
2005.
[41] W. Xu, D. DuVarney, and R. Sekar. An efﬁcient and
backwards-compatible transformation to ensure memory safety of C
programs. In FSE, 2004.
[42] V. Yegneswaran, J. Gifﬁn, P. Barford, and S. Jha. An architecture for
generating semantics-aware signatures. In USENIX Security, 2005.