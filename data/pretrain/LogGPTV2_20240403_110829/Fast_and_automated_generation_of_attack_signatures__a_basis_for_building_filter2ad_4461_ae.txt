### Optimized Text

This log reverts the program state to a point before the last network input and restarts execution from that point. It achieves good runtime performance by logging only global variable updates and supporting recovery at the granularity of function calls. However, this limited logging can lead to total restarts for some applications, thereby losing the benefits of lightweight recovery.

ARBOR [18] is similar to the approach presented in this paper in its reliance on an application’s built-in error handling capabilities for recovery. It differs, however, in its use of program behavior models [28] (rather than input format specifications) to identify input context. For some programs, the context information provided by the behavior model is insufficient to generate accurate signatures. Other differences include the absence of a correlation step in ARBOR and its inability to generate network-level attack signatures.

**Network-level Detection of Buffer Overflows:**
- **Buttercup [23]** and **[12]** detect buffer overflow attacks in network packets by recognizing jump addresses within the packets. Buttercup requires these addresses to be externally specified, while [12] detects them automatically by leveraging the nature of stack-smashing attacks and the memory layout used in Linux.
- **[37]** suggested a more robust approach for detecting buffer overflow attacks using abstract execution of the attack payload.
- **PayL [39]** develops a new technique for anomaly detection on packet payloads that can detect a wider range of attacks but has a higher false positive rate compared to the above techniques.
- **Shield [38]** uses vulnerability-specific (but exploit-generic) signatures to filter out attacks, but these signatures need to be specified manually.

**Network Signature Generation:**
- **Earlybird [32]** and **Autograph [16]**, two of the earliest approaches for worm detection, relied on characteristics of worms to classify network packets as benign or attack-bearing.
- **Honeycomb [17]** avoids the classification step by using a honeynet, which only receives attack traffic.
- From the packets classified as worm-related, these techniques compute a signature consisting of a single contiguous byte sequence that repeats across them. Polymorphic worms, however, can modify themselves as they propagate, confusing signature generation. To mitigate this, **Polygraph [21]** generates multiple (shorter) byte-sequences as signatures, identifying invariants even in network flows produced by polymorphic worms.
- **PADS [36]** develops a technique called position-aware distribution signatures to detect certain kinds of polymorphic attacks.

Compared with our approach, all the above methods operate with coarse information about the location and context of attacks within network flows. They lack both the correlation step (which identifies the bytes within network flows related to attacks) and the input context identification step (which identifies the location of these attack bytes within the structure of an input message). As a result, they cannot distinguish between relevant and irrelevant parts of attack-bearing flows. To compensate, they require a sufficient number of attack samples to ensure that only the "relevant" parts remain invariant across these samples. In contrast, using correlation and input context identification, our approach can generate signatures from single attack instances, capturing only message types and/or fields relevant to the attack, thereby reducing false negatives and positives.

**Nemean [42]** improves on the above approaches by incorporating protocol semantics into the signature generation algorithm, allowing it to handle a broader class of attacks. Like other network-based approaches, Nemean does not have the benefit of a correlation step to pinpoint attack-containing bytes, but its knowledge of service semantics provides capabilities similar to our input context identification. However, our approach requires only simplified message format specifications, whereas Nemean seems to require more detailed knowledge of service semantics. Another significant difference is that our technique does not require expert knowledge about which message fields are more likely to contain attacks.

**Hybrid Approaches for Signature Generation:**
- **The HACQIT project [25]** uses software diversity for attack detection and a rule-based algorithm to learn characteristics of suspect inputs, generating an effective signature for Code Red.
- **TaintCheck [22]** and **Vigilante [9]** track the flow of information from network inputs to data used in attacks, such as a jump address in a code-injection attack. Vigilante also develops the notion of self-certifying alerts (SCAs) that can be shared over the network without requiring recipients to trust each other. The signatures generated by these approaches are somewhat simplistic—TaintCheck uses the 3 leading bytes of a jump address as a signature, while Vigilante relies on absolute offsets of the jump address from the beginning of the input. These approaches do not employ a context identification step but provide a more robust implementation of correlation. For instance, accurate correlation can be achieved even when input is transformed (e.g., using URL encoding) before overwriting a pointer. In our approach, we trade this level of accuracy for significantly better performance—zero overheads under normal operation, compared to a 10x slowdown in the case of TaintCheck.
- **FLIPS [19]** uses PayL [39] to detect anomalous inputs. If the anomaly is confirmed by an accurate attack detector (based on instruction set randomization in their implementation), a content-based signature (using longest-common substring) is generated after several attack instances. Their approach consists of a detection and a signature generation step but does not use the correlation and input context identification steps.
- **Xu et al. [40]** developed an approach for signature generation using post-crash forensic analysis of address-space randomized programs, similar to our technique. They analyze program memory and use attack replay techniques to re-execute vulnerable sections of code and pinpoint the source of the vulnerability. However, their approach lacks the correlation and input context identification steps, relying instead on jump addresses used in an attack, which can lead to false positives, especially with protocols that use binary data.

### Conclusion

In this paper, we presented a new approach called COVERS for protecting servers from repetitive buffer overflow attacks, such as those caused by worms and zombies. Our approach combines off-the-shelf attack detection techniques with a forensic analysis of the victim server's memory to correlate attacks to inputs received from the network and automatically generate signatures to filter out future attack instances. This improves the ability of victim applications to withstand attacks by one to two orders of magnitude.

Compared to previous techniques, COVERS introduces minimal overheads of under 10% during normal operation. In our evaluation, we showed that COVERS signatures capture the characteristics of underlying vulnerabilities, providing protection against attack variants that exploit the same vulnerability. Unlike previous approaches, which required many attack samples to produce sufficiently general signatures to stop polymorphic attacks, our approach can generate signatures from a single attack instance. This is due to a 4-step approach that allows COVERS to localize the source of attacks to a small part of an input message. We believe that other signature generation techniques, which often employ more powerful algorithms at the signature generation step, can derive significant benefits by incorporating our correlation and input context identification steps.

The signatures generated by COVERS can be distributed and deployed at other sites over the Internet, potentially as an inline filter at the network layer. As a proof of concept, we recently implemented a Snort [34] plug-in that filters out network flows matching the signatures generated by COVERS.

### Acknowledgement

We thank Mohammed Mehkri and Karthik Sreenivasa Murthy for their help in collecting attack examples and implementing input format specifications. We also thank the anonymous reviewers for their comments, which were very helpful in preparing the final version of this paper.

### References

[References section remains unchanged.]