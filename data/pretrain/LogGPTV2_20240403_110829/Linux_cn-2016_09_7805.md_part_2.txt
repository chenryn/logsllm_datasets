### 浮点数
我们的解析器工作了，但是它做的工作不是很有趣。让我们把它扩展成既能解析整数又能解析浮点数。改变 grammar.ohm 文件使它看起来像下面这样：
```
CoolNums {
  // just a basic integer
  Number = float | int
  int    = digit+
  float  = digit+ "." digit+
}
```
这把 `Number` 规则改变成指向一个浮点数（`float`）或者一个整数（`int`）。这个 `|` 代表着“或”。我们把这个读成“一个 `Number` 由一个浮点数或者一个整数构成。”然后整数（`int`）定义成 `digit+`，浮点数（`float`）定义成 `digit+` 后面跟着一个句号然后再跟着另一个 `digit+`。这意味着在句号前和句号后都至少要有一个数字。如果一个数中没有一个句号那么它就不是一个浮点数，因此就是一个整数。
现在，让我们再次看一下我们的语义功能。由于我们现在有了新的规则所以我们需要新的功能函数：一个作为整数的，一个作为浮点数的。
```
var sem = grammar.createSemantics().addOperation('toJS', {
    Number: function(a) {
        return a.toJS();
    },
    int: function(a) {
        console.log("doing int", this.sourceString);
        return parseInt(this.sourceString,10);
    },
    float: function(a,b,c) {
        console.log("doing float", this.sourceString);
        return parseFloat(this.sourceString);
    }
});
```
这里有两件事情需要注意。首先，整数（`int`）、浮点数（`float`）和数（`Number`）都有相匹配的语法规则和函数。然而，针对 `Number` 的功能不再有任何意义。它接收子节点 `a` 然后返回该子节点的 `toJS` 结果。换句话说，`Number` 规则简单的返回相匹配的子规则。由于这是在 Ohm 中任何规则的默认行为，因此实际上我们不用去考虑 `Number` 的作用，Ohm 会替我们做好这件事。
其次，整数（`int`）有一个参数 `a`，然而浮点数有三个：`a`、`b` 和 `c`。这是由于规则的 实参数量   （    arity    ） 决定的。   实参数量    （    arity    ） 意味着一个规则里面有多少参数。如果我们回过头去看语法，浮点数（`float`）的规则是：
```
  float  = digit+ "." digit+
```
浮点数规则通过三个部分来定义：第一个 `digit+`、`.`、以及第二个 `digit+`。这三个部分都会作为参数传递给浮点数的功能函数。因此浮点数必须有三个参数，否则 Ohm 库会给出一个错误。在这种情况下我们不用在意参数，因为我们仅仅直接攫取了输入串，但是我们仍然需要参数列在那里来避免编译器错误。后面我们将实际使用其中一些参数。
现在我们可以为新的浮点数支持添加更多的测试。
```
test("123",123);
test("999",999);
//test("abc",999);
test('123.456',123.456);
test('0.123',0.123);
test('.123',0.123);
```
注意最后一个测试将会失败。一个浮点数必须以一个数开始，即使它就是个 0，`.123` 不是有效的，实际上真正的 JavaScript 语言也有相同的规则。
### 十六进制数
现在我们已经有了整数和浮点数，但是还有一些其它的数的语法最好可以支持：十六进制数和科学计数。十六进制数是以 16 为基底的整数。十六进制数的数字能从 0 到 9 和从 A 到 F。十六进制数经常用在计算机科学中，当用二进制数据工作时，你可以仅仅使用两个数字表示 0 到 255 的数。
在绝大多数源自 C 的编程语言（包括 JavaScript），十六进制数通过在前面加上 `0x` 来向编译器表明后面跟的是一个十六进制数。为了让我们的解析器支持十六进制数，我们只需要添加另一条规则。
```
  Number = hex | float | int
  int    = digit+
  float  = digit+ "." digit+
  hex    = "0x" hexDigit+
  hexDigit := "0".."9" | "a".."f" | "A".."F"
```
我实际上已经增加了两条规则。十六进制数（`hex`）表明它是一个 `0x` 后面一个或多个十六进制数字（`hexDigits`）的串。一个十六进制数字（`hexDigit`）是从 0 到 9，或从 a 到 f，或 A 到 F（包括大写和小写的情况）的一个字符。我也修改了 `Number` 规则来识别十六进制数作为另外一种可能的情况。现在我们只需要另一条针对十六进制数的功能规则。
```
    hex: function(a,b) {
        return parseInt(this.sourceString,16);
    }
```
注意到，在这种情况下，我们把 `16` 作为基底传递给 `parseInt`，因为我们希望 JavaScript 知道这是一个十六进制数。
我略过了一些很重要需要注意的事。`hexDigit` 的规则像下面这样：
```
  hexDigit := "0".."9" | "a".."f" | "A".."F"
```
注意我使用的是 `:=` 而不是 `=`。在 Ohm 中，`:=` 是当你需要推翻一条规则的时候使用。这表明 Ohm 已经有了一条针对 `hexDigit` 的默认规则，就像 `digit`、`space` 等一堆其他的东西。如果我使用了 `=`, Ohm 将会报告一个错误。这是一个检查，从而避免我无意识的推翻一个规则。由于新的 `hexDigit` 规则和 Ohm 的构建规则一样，所以我们可以把它注释掉，然后让 Ohm 自己来实现它。我留下这个规则只是因为这样我们可以看到它实际上是如何进行的。
现在，我们可以添加更多的测试然后看到十六进制数真的能工作：
```
test('0x456',0x456);
test('0xFF',255);
```
### 科学计数
最后，让我们来支持科学计数。科学计数是针对非常大或非常小的数的，比如 `1.8×10^3`。在大多数编程语言中，科学计数法表示的数会写成这样：1.8e3 表示 18000，或者 1.8e-3 表示 .018。让我们增加另外一对规则来支持这个指数表示：
```
    float  = digit+ "." digit+ exp?
    exp    = "e" "-"? digit+
```
上面在浮点数规则末尾增加了一个指数（`exp`）规则和一个 `?`。`?` 表示没有或有一个，所以指数（`exp`）是可选的，但是不能超过一个。增加指数（`exp`）规则也改变了浮点数规则的实参数量，所以我们需要为浮点数功能增加另一个参数，即使我们不使用它。
```
    float: function(a,b,c,d) {
        console.log("doing float", this.sourceString);
        return parseFloat(this.sourceString);
    },
```
现在我们的测试可以通过了：
```
test('4.8e10',4.8e10);
test('4.8e-10',4.8e-10);
```
### 结论
Ohm 是构建解析器的一个很棒的工具，因为它易于上手，并且你可以递增的增加规则。Ohm 也还有其他我今天没有写到的很棒的特点，比如调试观察仪和子类化。
到目前为止，我们已经使用 Ohm 来把字符串翻译成 JavaScript 数，并且 Ohm 经常用于把一种表示方式转化成另外一种。然而，Ohm 还有更多的用途。通过放入不同的语义功能集，你可以使用 Ohm 来真正处理和计算东西。一个单独的语法可以被许多不同的语义使用，这是 Ohm 的魔法之一。
在这个系列的下一篇文章中，我将向你们展示如何像真正的计算机一样计算像 `(4.85 + 5 * (238 - 68)/2)` 这样的数学表达式，不仅仅是解析数。
额外的挑战：你能够扩展语法来支持八进制数吗？这些以 8 为基底的数能够只用 0 到 7 这几个数字来表示，前面加上一个数字 0 或者字母 `o`。看看针对下面这些测试情况是够正确。下次我将给出答案。
```
test('0o77',7*8+7);
test('0o23',0o23);
```
---
via: 
作者：[Josh Marinacci](https://www.pubnub.com/blog/author/josh/) 译者：[ucasFL](https://github.com/ucasFL) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出