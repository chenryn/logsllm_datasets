iterate over the API levels that the app declares to support and query the API
19
text . s e t T e x t C o l o r ( r e s o u r c e s . g e t C o l o r S t a t e L i s t (
R . color . colorAccent , context . g e t T h e m e () ) ) ;
1 private void setText ( T e x t V i e w text ) {
2
3
4 }
5
6 @ O v e r r i d e
7 p r o t e c t e d void o n C r e a t e ( Bundle b ) {
8
9
10
11
12
13
14
15
16
17
18 }
if ( Build . VERSION . SDK_INT >= 23) {
setText ( text ) ;
}
else { ... }
super . o n C r e a t e ( b ) ;
s e t C o n t e n t V i e w ( R . layout . a c t i v i t y _ m a i n ) ;
T e x t V i e w text = f i n d V i e w B y I d ( R . id . text ) ;
Listing 3.1: Code exploring context-sensitive, path-sensitive and inter-procedural analysis of our
approach
database to determine whether the callback is deﬁned within the entire range of
supported API levels (lines 4-5). This is the major difference from our approach
to prior research, such as Cider [68]. We consider all API callbacks in Android,
without any manual modeling of callbacks. Our approach is also easier to scale, in
terms of ability to detect APIs. We only need minimal manual work to support a
new Android API, as described in Section 3.2
It is important to mention that for this detector, Jitana, our static analyzer
framework, already gives a special ﬂag to API callbacks methods. Therefore,
GAINDroid loops through those nodes in the graph, performing decoding and
API database search from minSdkVersion to maxSdkVersion, which is 28.
The second part of the Mismatch Detection component detects incompatibilities
Algorithm 2 Finding APC mismatches
1: procedure IsApcMismatch(method, app)
(cid:46) Input: Method from call graph, decompiled APK
if IsApiOverride(method) then
if ¬apidb.Contains(method, lvl) then
for each lvl in (app.minSdk..app.maxSdk) do
mismatches ← mismatches ∪ {method}
return mismatches
2:
3:
4:
5:
6:
20
Algorithm 3 Finding PRM mismatches
1: procedure DetectPermissionMismatch(app, graph, permMap)
(cid:46) Input: Decompiled APK, call/data ﬂow graph, permission map
(cid:46) Output: List of detected mismatches
dangerousPerms ← GetDangerousPermsFromManifest(app)
if dangerousPerms = ∅ then
callGraph ← BuildCallGraph(app)
if app.targetSdkVersion ≥ 23 then
return ∅
for each method in callGraph do
if OverridesOnRequestPermissionsResult(method) then
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
return ∅
for each method in callGraph do
return App does not implement runtime permission
dataFlowGraph ← GetDataFlowGraph(graph, method)
for each block in dataFlowGraph do
for each perm in dangerousPerms do
if permMap.IsUsingPermission(perm, block) then
mismatches ← mismatches ∪ {perm}
return mismatches
related to previous and the new run-time permissions system introduced in API
level 23. A unique capability to our approach. The logic of algorithm 3 that checks
permission-induced compatibility issues is as follows: First, extract dangerous
permissions from the app’s manifest (line 2). If there are no dangerous permissions
there is no risk of permission mismatches, as normal permissions are automatically
granted (lines 3-4). In case the app requests dangerous permissions, we get the
call graph from the API Usage Extraction component (line 5). If the app targets a
more recent version of Android (23 or higher), we check if the call graph contains
a method overriding onRequestPermissionsResult (lines 6-8). In case the app does
implement the new run-time permission system, there is no risk of mismatch (line
9). If after looping through all methods from the app, it did not implement the new
run-time system, we return an error message, indicating that developers should
21
implement this functionality to avoid run-time crashes. If app targets an API level
earlier than 23, the revocation of a dangerous permission could result in a run-time
crash. To detect dangerous permission usages, GAINDroid iterates through each
method in the call graph (line 11), retrieve the data ﬂow graph for the method
(line 12) and check whether each block in the data ﬂow graph uses any of the
dangerous permissions (lines 13-15). In case any dangerous permission is used,
add it to the set of mismatches (line 16). While checking if a block in the data ﬂow
uses a dangerous permission, GAINDroid decodes the instruction, analyzes if it is
an Android API invocation, and checks in the mapping produced in Permission
Mapping (Section 3.3) if the API is used by any dangerous permission.
22
Chapter 4
Empirical Evaluation
This section presents the evaluation of GAINDroid. We have implemented GAIN-
Droid’s static analysis capability on top of the Jitana framework[66]. Jitana is a
high-performance hybrid analysis tool for Android. It works directly on Dalvik
executable (dex) ﬁles contained in each APK. We also use APKTool [28] to decom-
pile apks, thus accessing its manifest ﬁle and binaries As a result, our approach
implementation does not require the source code from apps, only their executables
(apk). GAINDroid, can be used not only by developers but also by end-users as
well as third-party reviewers to assess the compatibility of their mobile apps.
We further modiﬁed Jitana to decode dex ﬁles using Android version 6.0.0,
which is the version in which the new runtime permissions system is introduced.
We also extended Jitana to perform inter-procedural dataﬂow analysis, which
enabled us to detect more API related issues within different methods of an
Android app.
To evaluate GAINDroid, we conducted experiments to answer the following
research questions.
RQ1. Accuracy: What is the overall accuracy of GAINDroid in detecting
compatibility issues compared to the other state-of-the-art techniques?
RQ2. Applicability: How well does GAINDroid perform in practice? Can it
23
ﬁnd compatibility issues in real-world applications?
RQ3. Performance: What is the performance of GAINDroid’s analysis to
identify sources of compatibility issues?
4.1 Objects of Analysis
In order to evaluate the effectiveness and efﬁciency of GAINDroid, we compared
GAINDroid against other state-of-the-art applications which utilize different
approaches to detecting API-related compatibility issues. The most closely related
works to ours are by Li et at. [51] (CiD) and by Huang et al. [46] (Cider). To make
the comparison as direct as possible, we used obtained the 7 benchmarks apps
(CiD-Bench) from [51] and the 20 apps (Cider-Bench) used in [46]. One of our
baseline system, Lint, requires building the apps from source code to perform
the compatibility analysis. Out of the 27 benchmark apps, eight apps cannot be
built; therefore, they are excluded from the analysis, leaving the total of 19 apps
used in our comparative study. Table 4.1 shows all benchmark apps, where apps
from 1 to 12 belongs to Cider-Bench and the remaining apps are from CiD-Bench.
The collection includes apps of varying sizes ranging from 10,400 to 294,400 lines
of Dex code and up to tens of thousands of methods. The benchmark apps both
support and target a variety of API levels, with minimum levels ranging from 10
to 21 and targets ranging from level 23 to 27.
We used the Android Studio version 3.1.3 to load and build all the benchmark
apps. However, we were unable to build eight apps from CiD-Bench. The initial
error was related to the Gradle plugin. The applications required to update to
a more recent version of Gradle. After updating the plugin, the apps generated
another error related to toolchains. We had a machine set up with all version of
24
Table 4.1: Basic Characteristics of Objects of Analysis
No.
App
Name
1 AFWall [2]
2 DuckDuckGo [8]
3
FOSS Browser [10]
4 Kolab notes [13]
5 MaterialFBook [14]
6 Network monitor [16]
7 NyaaPantsu [17]
8
Padland [18]
9
PassAndroid [37]
Simple Solitaire [22]
10
SurvivalManual [23]
11
12 Uber ride [24]
13
Basic [46]
14
Forward [46]
15 GenericType [46]
Inheritance [46]
16
17
Protection [46]
18
Protection2 [46]
19 Varargs [46]
Number of
Downloads
500K+
1M+
5K+
1K+
10K+
50K+
-
-
1M+
10K+
1M+
100M+
-
-
-
-
-
-
-
Rating
KLoC
Number of
Methods
minSdkVersion targetSdkVersion
4.3
4.4
4.2
4.1
4.3
4.3
-
-
4.2
4.5
4.7
4.2
-
-
-
-
-
-
-
21.8
10.4
18.0
73.4
68.0
20.8
14.1
58.9
85.0
294.4
49.4
12.7
10.1
10.2
12.4
11.2
10.9
10.8
12.7
46184
45049
10946
34969
34526
43942
66249
8713
52696
27782
35832
25610
5099
6201
5564
6039
5198
5988
5876
15
21
21
16
17
14
21
14
14
11
10
14
10
10
10
10
10
10
10
23
27
27
26
27
27
27
26
25
25
25
26