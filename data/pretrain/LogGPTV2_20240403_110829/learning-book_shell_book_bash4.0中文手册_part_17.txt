在Bash启动时指定“--posix命令行选项，或者在Bash运行时执行Bet=opogix命令，都会使它
改变那些与POSIX规范不一致的行为，从而更接近于POSIX规范。如果作为Bh来启动，Bash就会在读
取启动文件之后进入POSIX模式。下面是这种模式中改变的行为：
①如果散表列中的命令不存在了，Bash会在$PATH中重新搜索基路径。这个行为也可以用shopt=8
checkhash 得到。
2如果作业退出时返回状态不为零，作业控制代码及其内部命令打印的信息是“已完成（状态号）”，
③作业退出时，作业控制代码及其内部命令打印的信息是“已停止（信号名)，其中信号名是诸如
SIGTSTP等名称。
4内部命令bg使用指定的格式显示后台的每个作业，但不没有指明哪个是当前作业，哪个是前一个作
业
5在能够识别保留字的上下文中出现的保留字不会进行别名扩展。
启用了POSIX方式来扩展PS1和PS2，使得！扩展成历史编号，而！！扩展成！.并且不管
pronptvare选项如何设置，都会对PS1和PS2的值进行参数扩展。
执行POSIX的启动文件（SENV）而不是正常的Bash文件。
8只对命令名之前的赋值进行波浪号扩展，而不是对本行中所有赋值都进行。
默认的历史文件是/.BhhiBtory（这是$HISTFILE的默认值）。
10ki11-1的输出是在单行中打印所有信号名，其间用空格分隔，并且不带SIG前缴。
11内部命令ki11不接受带有SIG前缀的信号名。
19在执行".文件名"时如果文件名不存在，则非交互的shell将会退出。
非交互的sbhell在进行算术扩展时如果遇到无效的表达式而产生语法错误就会退出。
14重定向运算符不会对重定向中的单词进行文件名扩展，除非在交互式的shell中。
15重定向运算符不会对重定向中的单词进行单词拆分。
1函数名必须是有效的shell标志符：即它们不能包含字母、数字、下划线以外的字符，也不能以数字开
头。在非交互的shell中如果定义的函数名无效则会导致一个严重错误。
17在搜索命令时，POSIX的特殊命令会在函数名之前找到。
18如果POSIX的特殊命令返回错误的状态，则非交互的shell就会退出，严重错误是指POSIX规范中
列出的那些，包括指定了不正确的选项，重定向错误，命令名之前的变量赋值错误，等等。
19如果设置了CDPATH，内部命令cd就不会在其后隐式附加当前目录。这意味着如果在SCDPATH的任一
条目中都找不到一个有效的目录，cd就会失败，即使其参数指定的目录在当前目录中存在。
20如果变量赋值时发生错误并且其后没有跟着命令名，非交互的shell就会退出并返回错误状态。变量
赋值会发生错误的例子包括试图给只读变量赋值。
p67
目录
BASH 中文文
---
## Page 79
第六章BASH的功能
 6.11 BASH 的 POSIX 模式
+ee e ee ee e ee e e e e e ee e e e ee e ee ee e e e ee e e e ee e e e ee ee e ee e @
②如果or语句中的循环变量或者select语句中的选择变量是只读变量，则非交互的shell就会退出
雅返回错误状态，
29不可以使用远程替换，
2.3在POSIX特殊内部命令之前的赋值语句，在命令执行完毕以后还将持续保留在shell环境中，
②在shell函数调用之前的赋值语句，在函数返回以后还将持续保留在shell环境中，不好像执行了
POSIX特殊内部命令。
25内部命令export和readonly会按照POSIX要求的格式输出内容。
26内部命令trap显示的信号名称不带有SIG前缀。
27内部命令trap不会检查其第一个参数是否是一个信号指示并且在是信号指示时恢复该信号的处理，
除非这个参数只含有数字并且指定了一个有效的信号，如果用户希望把某个信号的处理重围为原来的
程序，则应该用"作为第一个参数。
8如果PATH中不包括当前路径，则内部命令，和source就不会在当前目录中搜索文件名参数。
29为执行命令替换而创建的子shell会继承父shell的“=e"选项。如果不是在POSIX模式中，Bash会在
这种子shell 中重围“=e”选项。
30总是启用别名扩展，即使是在非交互的shell中。
31当用内部命令aliag显示别名定义时，不会在每条输出前加上前导的"alias."，除非指定了“-p"选项，
39如果启动内部命令Bet时没有指定选项，它不会显示shell函数的名称和定义。
3如果启动内部命令&et时没有指定选项，它在显示变量值时就不用引用，即使其中含有不可打印字
符，除非这个值中含有shell元字符。
34如果使用了内部命令cd的逻辑路径模式，并且由$PWD和其参数指定的目录名构成的路径不存在，cd
将会失败，而不是继续尝试物理路径模式。
35如果内部命令pud指定了“-P"选项，它就会把SPWD转换成不带符号链接的路径后输出。
36内部命令pud会检查其打印的路径是否和当前目录相同，即使没有用"-P"选项让它去检查文件系统。
37在列出历史条目时，内部命令fc不会指示每个条目是否已经被修改过。
381c默认使用的编辑器是ed。
39内部命令type和comnand不会报告不可执行的文件，尽管在SPATH中只有这个文件的名称匹配时
shell 会试图去执行它。
40在vi编辑模式中，“v"命令会直接启动vi编辑器，而不是去检查$VISUAL和EDITOR。
41如果打开了xpg-echo选项，Bash不会把echo命令的任何参数当前选项：而是对每个参数进行转义
处理以后直接显示。
4内部命令ulimit的“=e"和"-f"选项使用512字节的块。
还有一些POSIX行为，即使是Bash的poBix模式在默认情况下也没有实现的。特别的：
1当一个程序要编辑历史条目并且这时没有设置FCEDIT变量时，内部命令fc会再去检查SEDITOR，而
不是直接使用默认的ed。只有在没有设置EDITOR时fc才会使用ed。
2如上所说，Bash需要打开xpg_echo选项才能让内部命令écho完全遵循规范，
在编译时，可以指定--enable-atrct=poaix-default（参见s10.8配置选项]，p98）把 Bash 配置成
默认就支持POSIX。
 e ee e e e ee ee e ee e eeeeeeeeeeeeeeee eee ee e e e ee e e e ee @
BASH 中文文档
目录
894
---
## Page 80
第七章作业控制
第七章作业控制
本节讨论作业控制是什么、它怎么工作、以及Bash里面怎么使用这些功能。
67.1作业控制基础
作业控制是指有选择的停止（暂停）并在后来继续（恢复）执行某个进程的能力。通常，用户通过Bash
它会维护一个当前正在执行的作业表，这个表可以用jobe命令列出。当Bash异步的启动一个作业时，它
会打印一条如下的信息：
[1]  25647
表示这个作业的作业号是1，而这个作业所关联的管道中最后一个进程的进程号是25647。一个管道中的所
有进程都是同一作业的组成部分。Bash使用作业这种抽象的机制作为作业控制的基础。
为了便于实现作业控制的用户界面，操作系统维护一个叫当前终端进程组号的概念，这个进程组的成
员（即进程组号与当前终端进程组号相等的进程）接收诸如SIGINT的键盘信号，它们被称为前台进程。而
后台进程是指那些进程组号与终端进程组号不同的进程，它们不受键盘信号的影响。只有前台进程才可以读
信号：这时，如果没有捕获这个信号，这个进程就会暂停。
如果运行Bash的操作系统支持作业控制，Bash就会提供作业控制的功能。在某个进程运行时输入
暂停字符（通常是Z，即C-Z），这个进程就会停止并且把控制权返回给Bash。如果输入延迟暂停字
符（通常是或C-Y），这个进程就会在试图从终端读取输入时停止并且把控制权返回给Bash.这时
用户就可以控制该作业的状态：用bg命令在后台继续运行作业，用fg命令在前台继续运行作业，或者用
ki11命令结束作业。Z会立即生效，并有一个副作用，即丢弃剩余的输出和尚未提交的输入。
有好多方法来表示shell中的作业。“字符引导一个作业指示（jobepec）.作业号n可以记为%n
X%和%+代表shell概念中的当前作业，即前台中停止的最后一个作业或后台中最后一个开始的作业。单个
（后面没有作业指示）也表示当前作业。而前一个作业可以用%-来表示。如果只有一个作业，则%+和%
都可以表示它。在job&命令的输出中，当前作业总是标为+，而前一个作业总是-
还可以用启动时名称中的前缀来表示一个作业，或者用命令行中的子字符串。例如，%ce表示已停止的
进程ce。而使用%?ce却表示任何包含字符串ce的命令。如果前缀或子字符串匹配多个作业，Bash就会
报错。
简单的称呼一个作业可以把它调到前台，例如，%1和fg%1是同义的，它们都把后台中的第一个作业
调到前台。类似的，%1是可以在后台继续执行第一个作业，它和bg%1是等价的。
Shell会即时知悉作业状态的改变。通常，Bash会等待打印提示符时再报告作业状态的改变，以避免干
扰用户的其它输出。如果打开了内部命令Bet的“-k"选项（参见S86[内部命令set]，p42），Bash会立即报告
状态的改变。如果有SIGCHLD陷阱，则在每个子进程退出时执行。
如果作业停止时试图退出Bash（如果打开了checkjobe选项，则也包括作业正在运行时：参见587[内
+++++++++++++++++++++++++++++++++++++++++
p69
BASH 中文文
---
## Page 81
第七章作业控制
57.2作业控制内部命令
的状态。然后，可以用joba命令查看它们的状态]。如果没有输入其它命令而再次试图退出，Bash就不
再打印警告信息，并结束所有已停止的作业。
87.2作业控制内部命令
A.bg
bg[作业指示…·]
在后台继续执行每个暂停的作业指示，就好像启动它们时带有“&”一样。如果没有给定作业指示，则使用当
前的作业。返回状态是零，除非运行时没有启用作业控制，或者虽然启用了作业控制而有些作业指示没有找
到或它们在启动时没有使用作业控制。
B.fg
fg[作业指示]
在前台继续执行作业指示，并把它作为当前作业。如果没有给定作业指示，则使用当前的作业。返回状态是
放到前台的命令的返回状态：除非运行时没有启用作业控制，或者虽然启用了作业控制而有些作业指示没有
找到或它们在启动时没有使用作业控制，这时返回状态是非零。
C.jobs
jobe[-1nprs][作业指示]
joba=x命令[参数表]
第一种形式列出活动和作业：其选项具有下列含义：
-1
除了正常要显示的信息外，还列出进程号。助记词：List，列出
只显示上次把状态通知用户以后，已经改变了状态的作业。助记司：Botify，上次通如
只列出作业进程组中首领进程的进程号-助记词：Proce5，进程号
只显示正在运行的作业。助记词：kunning，正在运行
B
只显示已经停止的作业。助记词：Stoppad，已停止
如果给定作业指示，则只显示该作业的信息。否则，列出全部作业的状态信息。
如果指定了“-x"选项，jobs就会把命令或参数表中的作业指示用对应的进程组号替换，然后把参数
表传给命令并执行它，最后返回这个命令的返回状态。
如果没有打开chockjob&选项。
BASH 中文文档
目录
04
---
## Page 82
$7.3作业控制变量
第七章作业控制
D.kill
ki11[&信号指示][-n信号数字][信号指示作业指示或进程号
kil1-1[退出状态]
把信号指示或信号数字指定的信号发送给作业指示或进程号指定的进程。信号指示是个不区分大小写的信号
名称，例如SIGINT（带有或没有SIG前级），或者是个信号代码：信号数字是个信号代码。如果没有指定信
号指示或信号数字，则使用SIGTERM。“-1"选项助记司：List，列出可以列出所有信号名称。如果“-1"选项还带
有一些参数，则只列出这些参数对应的信号，这时返回状态是零。退出状态是个信号代码或者是能导致进程
结束并返回这个退出状态的信号，如果至少成功发送一个信号，则返回状态是零：如果发生错误，或遇到了
无效的选项，则返回非零。
E.vait
ait[作业指示或进程号-·]
等待由作业指示或进程号指定的进程退出并返回等待的最后一个命令的退出状态。如果给定作业指示，则等
待这个作业的所有进程。如果没有给定参数，则等待当前所有的活动子进程，其返回值为零。如果作业指
示或进程号都没有指定shell的活动子进程，则返回状态是127.
F.disown
disown[-ar][-][作业指示·-]
如果没有选项，则从活动作业表中移除第一个作业指示。如果指定了“-h"选项助记词：Bang，指
挂起，则并不移除
作业，而是给它一个标志，使得shell在接收到SIGHUP信号时不会把这个信号转发给它。如果没有指定作
业指示，并且也没有指定“=a”或“-r"选项，则使用当前作业。如果没有指定作业指示，则“=a"选项助记词
A11.所有会移除或标志所有作业：而“-r"限制只操作正在运行的作业。
G.
suspend
suspend [-f]
暂停执行当前的 shell，直到向它发送SIGCOUNT信号，登录shell不可以暂停：但是可以使用“-r"选项功记
词：Forcs，强制来强制暂停。
■[分节结束]
如果没有启用作业控制，内部命令kil1和vait就不能把作业指示作为参数，它们只能接受进程号。
37.3作业控制变量
A.auto_resume
这个变量控制shell与用户和作业控制的交互。如果这个变量存在，则没有重定向且只包含单个单词
则选择最近访间的作业。在这种情况下，对于已经停止的作业，其名称就是启动时的命令行。如果把这个
的字符串只要和已停止作业名的部分匹配就可以了：gubatring这个值在功能上和作业号%？相类似（参
见57.1[作业控制基础]，p69）。如果设为任何其它的值，则必须是一个已停止作业名称中的开头部分：这和
作业号%在功能上是类似的。
p71
目录
BASH 中文文
---
## Page 83
第八章编辑命令行
第八章编辑命令行
本章介绍GNU命令行编辑界面的基本功能。命令行编辑是Readine库提供的：这个库被几个不同的
程序共用，Bash是其中一个。使用交互式的shell时，默认已经打开了命令行编辑，除非启动shell时指定
使用行编辑。默认情况下，行编辑命令和emacs的很相似：但也可以使用vi风格的行编辑界面。在任何时
候，都可以使用内部命令Bet（参见s4.3.1[内部命令set]，p42）的"=0emace"或"=vi"选项来打开行编辑，
或者使用set的"+oemacs”或"+ovi"选项来关闭。
S8.1行编辑介绍
下面几段介绍键的表示方法。
作“Meta-K”，它表示按下Meta键（如果有这个键）时再按键所得到的字符.在很多键盘上，Meta]
键都标上ALT，如果一个键盘有两个标为ALT的键（通常在空格键的两旁），则一般左边的那个可以当
Meta键使用.右边的那个ALT键也可以配置成Meta键，或者配置成其它的修饰键，例如用来输入字
母音符的Compose键。如果没有Meta或ALT键，也没有其它可以当成Meta键的，则可以先按下
ESC再按下来得到同样的键。这两种键都叫Meta化的键。
字符M-C-k读作“Meta-Control-K，它表示Meta化的C--
出现的DEL、ESC、LFD、SPC、RET和TAB都表示其自身.如果键盘上没有FD键，输入
也会得到同样的字符。在有些键盘上，RET键可能被标为Returm或Ente键。
S8.2与Readline的交互
在交互式的会话中，常常是输入了很长的一行文本，却发现这行的第一个单词拼写错了。Readline提
供了一套在输入时控制文本的命令，用来改正输入错误，而不必要重新输入大部分内容。使用这些编辑命
令，可以把光标移动到需要更正的地方，删除或者插入更正的内容：然后，如果文本行还令人满意，就按下
ET·按下RET不一定要在行的结尾：整行都会读入，不管光标在行中的什么地方。
§8.2.1Readline的基础
要在行中输入字符，只需要按下对应的键。输入的字符在光标后出现，然后光标就向后移动一格的位
置。如果输错了一个字符，可以用删除字符后退并删除这个输错的字符。有时，输错了不会马上发现，直到
又输入了好个几个字符，这种情况下，可以输入向左移动光标然后更正错误。接下来，可以用
向右移动光标。
BASH中文文档
p72
---
## Page 84
8.2与 READLINE 的交互
第八章编辑命令行
如果在行的中间输入，就会发现光标右边的字符被“推过去”以腾出空间容纳刚刚输入的文本。同样的，