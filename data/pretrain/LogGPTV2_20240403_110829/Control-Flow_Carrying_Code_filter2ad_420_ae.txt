security with a longer master key of, say, 80 bits.
7.4 Fine-grained CFI Enforcement
C3 can be extended to enforce fine-grained CFI. For example, C3
can enforce the fine-grained CFI policy for forward-edge indirect
branch transfer instructions enforced in TypeArmor [45] by classi-
fying functions and indirect call instructions into different clusters
according to the number of arguments they can accept, and then en-
crypting basic blocks with the more accurate set of control transfers
derived. We note that enforcing a finer-grained CFI policy could
likely reduce the execution time and space overhead of C3 due
to fewer valid control transfers on average and consequently less
secret sharing and block redistribution needed.
7.5 Other limitations
First, C3 relies on static analysis and rewriting of binaries. The
current implementation does not support dynamically generated
code or self-modifying code.
Second, C3 prevents attackers from directly reading the code
and finding useful gadgets. However, code pointers in data areas
such as stack and heap are still vulnerable to indirect memory
disclosure. For example, if the protected binary has a format string
vulnerability, the attacker can print out the valid memory locations
for return instructions, which may allow an attacker to use, e.g.,
call-preceded gadgets. This is a rather general limitation shared by
other techniques performing binary rewriting [47, 48, 50].
Third, C3 renders caching and pipelining less effective. It is a
limitation for most ISR approaches, excluding those performing
decryption when there are I-cache misses and store plain text in
the I-cache.
Lastly, C3 requires symbol names in the executable to enable
patching function and data pointers after basic block redistribu-
tion. It also requires that data and code be completely separated
to enforce instruction encryption. For binaries that do not contain
symbol information, we can use external tools, e.g., Unstrip7 and
others [35, 39], to restore the symbol information. Similarly, there
are approaches to identify data embedded within code [49, 50].
8 CONCLUSION
We present C3, a new CFI technique that embeds the CFG into in-
structions to perform CFI checks without relying on additional data
structure like the read-only table used in existing CFI approaches.
It encrypts each basic block with a key that can be reconstructed
by any of its valid callers with the help of a secret sharing scheme.
7http://paradyn.org/html/tools/unstrip.html
During execution, C3 reconstructs the key when a branch transfer
instruction is encountered. Our evaluation shows that C3 can ef-
fectively defend against most control-flow hijacking attacks with
moderate overhead.
ACKNOWLEDGEMENT
We thank our shepherd, Hong Hu and the anonymous reviewers for
their valuable comments and suggestions that have helped improve
our paper.
REFERENCES
[1] Martín Abadi, Mihai Budiu, Ulfar Erlingsson, and Jay Ligatti. 2005. Control-flow
integrity. In Proceedings of the 12th ACM conference on Computer and communi-
cations security. ACM, 340–353.
[2] Elena Gabriela Barrantes, David H Ackley, Trek S Palmer, Darko Stefanovic, and
Dino Dai Zovi. 2003. Randomized instruction set emulation to disrupt binary
code injection attacks. In Proceedings of the 10th ACM conference on Computer
and communications security. ACM, 281–289.
[3] Andrew R Bernat and Barton P Miller. 2011. Anywhere, any-time binary in-
strumentation. In Proceedings of the 10th ACM SIGPLAN-SIGSOFT workshop on
Program analysis for software tools. ACM, 9–16.
[4] Andrea Bittau, Adam Belay, Ali Mashtizadeh, David Mazières, and Dan Boneh.
2014. Hacking blind. In Proceedings of the 35th IEEE Symposium on Security and
Privacy. IEEE, 227–242.
[5] Tyler Bletsch, Xuxian Jiang, Vince W Freeh, and Zhenkai Liang. 2011. Jump-
oriented programming: a new class of code-reuse attack. In Proceedings of the 6th
ACM Symposium on Information, Computer and Communications Security. ACM,
30–40.
[6] Erik Bosman, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2016. Dedup
est machina: Memory deduplication as an advanced exploitation vector. In 2016
IEEE symposium on security and privacy (SP). IEEE, 987–1004.
[7] Nicholas Carlini, Antonio Barresi, Mathias Payer, David Wagner, and Thomas R
Gross. 2015. Control-Flow Bending: On the Effectiveness of Control-Flow In-
tegrity.. In Proceedings of the 24th USENIX Security Symposium. 161–176.
[8] Nicholas Carlini and David Wagner. 2014. ROP is Still Dangerous: Breaking
Modern Defenses.. In Proceedings of the 23rd USENIX Security Symposium. 385–
399.
[9] Stephen Checkoway, Lucas Davi, Alexandra Dmitrienko, Ahmad-Reza Sadeghi,
Hovav Shacham, and Marcel Winandy. 2010. Return-oriented programming
without returns. In Proceedings of the 17th ACM conference on Computer and
communications security. ACM, 559–572.
[10] Xiaoyang Cheng, Yan Lin, Debin Gao, and Chunfu Jia. 2019. DynOpvm: VM-
based software Obfuscation with Dynamic Opcode Mapping. In Proceedings of
the 17th International Conference on Applied Cryptography and Network Security.
[11] Yueqiang Cheng, Zongwei Zhou, Yu Miao, Xuhua Ding, Huijie Deng, et al. 2014.
ROPecker: A generic and practical approach for defending against ROP attack.
In Symposium on Network and Distributed System Security.
[12] Mauro Conti, Stephen Crane, Lucas Davi, Michael Franz, Per Larsen, Marco
Negro, Christopher Liebchen, Mohaned Qunaibit, and Ahmad-Reza Sadeghi. 2015.
Losing control: On the effectiveness of control-flow integrity under stack attacks.
In Proceedings of the 22nd ACM Conference on Computer and Communications
Security. ACM, 952–963.
[13] Intel Corporation. 2019. Intel Software Guard Extensions (Intel SGX). https:
//software.intel.com/en-us/sgx/.
[14] Lucas Davi, Ahmad-Reza Sadeghi, Daniel Lehmann, and Fabian Monrose. 2014.
Stitching the Gadgets: On the Ineffectiveness of Coarse-Grained Control-Flow
Integrity Protection.. In Proceedings of the 23rd USENIX Security Symposium.
[15] Ruan de Clercq, Johannes Götzfried, David Übler, Pieter Maene, and Ingrid Ver-
bauwhede. 2017. SOFIA: Software and control flow integrity architecture. Com-
puters & Security 68 (2017), 16–35.
[16] Jianming Fu, Xu Zhang, and Yan Lin. 2015. An Instruction-Set Randomization
Using Length-Preserving Permutation. In IEEE International Conference on Trust,
Security and Privacy in Computing and Communications. IEEE, 376–383.
[17] Xinyang Ge, Weidong Cui, and Trent Jaeger. 2017. GRIFFIN: Guarding control
flows using intel processor trace. In Proceedings of the 22nd International Confer-
ence on Architectural Support for Programming Languages and Operating Systems.
ACM, 585–598.
[18] Enes Göktas, Elias Athanasopoulos, Herbert Bos, and Georgios Portokalidis. 2014.
Out of control: Overcoming control-flow integrity. In Proceedings of the 35th IEEE
Symposium on Security and Privacy. IEEE, 575–589.
[19] Yufei Gu, Qingchuan Zhao, Yinqian Zhang, and Zhiqiang Lin. 2017. PT-CFI:
Transparent backward-edge control flow violation detection using intel processor
Session 1A: Binary Analysis and HardeningAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand13trace. In Proceedings of the Seventh ACM on Conference on Data and Application
Security and Privacy. ACM, 173–184.
[20] Hong Hu, Chenxiong Qian, Carter Yagemann, Simon Pak Ho Chung, William R
Harris, Taesoo Kim, and Wenke Lee. 2018. Enforcing unique code target property
for control-flow integrity. In Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security. ACM, 1470–1486.
[21] Hong Hu, Shweta Shinde, Sendroiu Adrian, Zheng Leong Chua, Prateek Saxena,
and Zhenkai Liang. 2016. Data-oriented programming: On the expressiveness of
non-control data attacks. In Proceedings of the 37th IEEE Symposium on Security
and Privacy. IEEE, 969–986.
[22] Gaurav S Kc, Angelos D Keromytis, and Vassilis Prevelakis. 2003. Countering
code-injection attacks with instruction-set randomization. In Proceedings of the
10th ACM conference on Computer and communications security. ACM, 272–280.
[23] Yan Lin, Xiaoxiao Tang, Debin Gao, and Jianming Fu. 2016. Control flow integrity
enforcement with dynamic code optimization. In International Conference on
Information Security. Springer, 366–385.
[24] Yutao Liu, Peitao Shi, Xinran Wang, Haibo Chen, Binyu Zang, and Haibing
Guan. 2017. Transparent and efficient cfi enforcement with intel processor trace.
In Proceedings of the 23rd IEEE International Symposium on High Performance
Computer Architecture. IEEE, 529–540.
[25] Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff
Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood. 2005. Pin:
building customized program analysis tools with dynamic instrumentation. In
Proceedings of the 2005 ACM conference on Programming language design and
implementation. ACM, 190–200.
[26] Vishwath Mohan, Per Larsen, Stefan Brunthaler, Kevin W Hamlen, and Michael
Franz. 2015. Opaque Control-Flow Integrity.. In Symposium on Network and
Distributed System Security, Vol. 26. 27–30.
[27] George C Necula. 2002. Proof-carrying code. design and implementation. In
Proof and system-reliability. Springer, 261–288.
[28] Ben Niu and Gang Tan. 2014. Modular control-flow integrity. In Proceedings of the
21st ACM Conference on Computer and Communications Security. ACM, 577–587.
[29] Ben Niu and Gang Tan. 2015. Per-input control-flow integrity. In Proceedings
of the 22nd ACM Conference on Computer and Communications Security. ACM,
914–926.
[30] Heidi Pan, Krste Asanović, Robert Cohn, and Chi-Keung Luk. 2005. Controlling
program execution through binary instrumentation. ACM SIGARCH Computer
Architecture News 33, 5 (2005), 45–50.
[31] Antonis Papadogiannakis, Laertis Loutsis, Vassilis Papaefstathiou, and Sotiris
Ioannidis. 2013. ASIST: architectural support for instruction set randomization.
In Proceedings of the 2013 ACM SIGSAC conference on Computer & communications
security. ACM, 981–992.
[32] Vasilis Pappas, Michalis Polychronakis, and Angelos D Keromytis. 2013. Trans-
parent ROP Exploit Mitigation Using Indirect Branch Tracing.. In Proceedings of
the 22nd USENIX Security Symposium. 447–462.
[33] Mathias Payer, Antonio Barresi, and Thomas R Gross. 2015. Fine-grained control-
flow integrity through binary hardening. In International Conference on Detection
of Intrusions and Malware, and Vulnerability Assessment. Springer, 144–164.
Fast and practical
instruction-set randomization for commodity systems. In Proceedings of the 26th
Annual Computer Security Applications Conference. ACM, 41–48.
[35] Rui Qiao and R Sekar. 2017. Function interface analysis: A principled approach for
function recognition in COTS binaries. In Proceeding of the 47th Annual IEEE/IFIP
International Conference on Dependable Systems and Networks. 201–212.
[36] Nguyen Anh Quynh. 2014. Capstone: Next-gen disassembly framework. Black
Hat USA (2014).
[37] Hovav Shacham. 2007. The geometry of innocent flesh on the bone: Return-into-
libc without function calls (on the x86). In Proceedings of the 14th ACM conference
on Computer and communications security. ACM, 552–561.
[38] Adi Shamir. 1979. How to share a secret. Commun. ACM 22, 11 (1979), 612–613.
[39] Eui Chul Richard Shin, Dawn Song, and Reza Moazzezi. 2015. Recognizing
Functions in Binaries with Neural Networks.. In Proceeding of the 24th USENIX
Security Symposium. 611–626.
[40] Kanad Sinha, Vasileios P Kemerlis, and Simha Sethumadhavan. 2017. Reviving
instruction set randomization. In International Symposium on Hardware Oriented
Security and Trust. IEEE, 21–28.
[41] Kevin Z Snow, Fabian Monrose, Lucas Davi, Alexandra Dmitrienko, Christopher
Liebchen, and Ahmad-Reza Sadeghi. 2013.
Just-in-time code reuse: On the
effectiveness of fine-grained address space layout randomization. In Proceedings
of the 34th IEEE Symposium on Security and Privacy. IEEE, 574–588.
[42] Ana Nora Sovarel, David Evans, and Nathanael Paul. 2005. Where’s the FEEB?
The Effectiveness of Instruction Set Randomization.. In Proceedings of the 15th
USENIX Security Symposium.
[34] Georgios Portokalidis and Angelos D Keromytis. 2010.
[43] Dean Sullivan, Orlando Arias, David Gens, Lucas Davi, Ahmad-Reza Sadeghi,
and Yier Jin. 2017. Execution Integrity with In-Place Encryption. arXiv preprint
arXiv:1703.02698 (2017).
[44] Caroline Tice, Tom Roeder, Peter Collingbourne, Stephen Checkoway, Úlfar
Erlingsson, Luis Lozano, and Geoff Pike. 2014. Enforcing Forward-Edge Control-
Flow Integrity in GCC & LLVM.. In Proceedings of the 23rd USENIX Security
Symposium. 941–955.
[45] Victor van der Veen, Enes Göktas, Moritz Contag, Andre Pawoloski, Xi Chen,
Sanjay Rawat, Herbert Bos, Thorsten Holz, Elias Athanasopoulos, and Cristiano
Giuffrida. 2016. A tough call: Mitigating advanced code-reuse attacks at the
binary level. In Proceedings of the 37th IEEE Symposium on Security and Privacy.
IEEE, 934–953.
[46] Robert Wahbe, Steven Lucco, Thomas E Anderson, and Susan L Graham. 1994.
Efficient software-based fault isolation. In ACM SIGOPS Operating Systems Review,
Vol. 27. ACM, 203–216.
[47] Minghua Wang, Heng Yin, Abhishek Vasisht Bhaskar, Purui Su, and Dengguo
Feng. 2015. Binary code continent: Finer-grained control flow integrity for
stripped binaries. In Proceedings of the 31st Annual Computer Security Applications
Conference. ACM, 331–340.
[48] Chao Zhang, Tao Wei, Zhaofeng Chen, Lei Duan, Laszlo Szekeres, Stephen Mc-
Camant, Dawn Song, and Wei Zou. 2013. Practical control flow integrity and
randomization for binary executables. In Proceedings of the 34th IEEE Symposium
on Security and Privacy. IEEE, 559–573.
[49] Mingwei Zhang, Michalis Polychronakis, and R Sekar. 2017. Protecting COTS
binaries from disclosure-guided code reuse attacks. In Proceedings of the 33rd
Annual Computer Security Applications Conference. 128–140.
[50] Mingwei Zhang and R Sekar. 2013. Control Flow Integrity for COTS Binaries.. In
Proceedings of the 22nd USENIX Security Symposium. 337–352.
binaries: An effective defense against real-world ROP attacks. (2015).
[51] Mingwei Zhang and R Sekar. 2015. Control flow and code integrity for COTS
A BASIC BLOCK REDISTRIBUTION
ALGORITHM
Redistribution(priority_callee, master_key, k, p)
if callee not in key_block then
priority_callee = Look_Ahead(callee)
if priority_callee then
Algorithm 1 Basic Block Redistribution
1: procedure Redistribution(callee, master_key, k, p)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
callers = callee_caller[callee]
moved_callers = find_moved_callers(callers)
if len(moved_callers) == 0 then
caller = random_choose_caller(callers)
caller = moved_callers[0]
if len(moved_callers) == 1 then
compute_key(callee, caller , master_key, k, p)
# move all callers of this basic block to be on the curve
for i in callers do
13:
14:
15:
16:
17:
18:
19:
20:
if i not in redistributed_block then
move_caller(callee, i, master_key, k, p)
# DFS: process callees of this basic block
for i in caller_callee[callee] do
Redistribution(i, master_key, k, p)
# backtracking
for i in callers do
for j in caller_callee[i] do
Redistribution(j, master_key, k, p)
Session 1A: Binary Analysis and HardeningAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand14