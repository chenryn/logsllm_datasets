begin n: = 0;
function*grounded: Boolean ;begin grounded: = (n = 0)ends
procedure *down; when n>0 do begin n: =n -l end;
procedure *up; begin n: = hi+ 1 end;
monitor count,
其形式为
例如，计数变元的一个简单管程，用PASCALPLUS 的记
var n:integer;
条件临界区也可用信号量实施。和由程序员直接使用同步信
if n≠0 then print(n)
begin my copy: = content; count:= count-I end
---
## Page 242
第七行的三个点处，并将管程中的全部局部名冠以实例名，得到
来解释。先拷贝一份管程的文本；然后将程序块P拷贝到管程中的
down，这个调用就会被推退，直到P中的其它进程调用rocket，
更新n时不会产生于扰的危险。注意，若在n=0时调用rocket，
性，保证管程中的过程可由P中的任意多个进程所调用，而且在
例如n，这些规定可归编译程序强制执行。管程以固有的互斥
在P中下能使用不带是号的过程，也不能存取不带星号的变元，
up后才会重新执行。这样，确保n不会取负值。
在程序块P中，可用下列命合调用带星号的过程
..uaut papunoieyayooud!umopiayoou.. dnoyoos
申明管程实例的效果可由ALGOL60中过程调用的拷贝规财
procedure rocket,up; begin rocket.n: =rocket .n+ I end;
rocket,n:integer;
刊以申明管程的新的实例，使其局部于程序块P，如
function rocket.grounded: Boolean;
行1
end
procedure rocket.down;
4口使用管程的程序可调用带星号的过程。
31申明三个过程及共过程体。
管程此开始执行。
只有在管程中才能存取它。
印出来。
从用卢程序块退出时，将n的终止值（若非雾时）打
三个粗点是一些内部语句，表示使用管程的程序块。
申明局部于管程的共享变元n。
申明管程及其名称count。
instance rocket:count, P
219
---
## Page 243
误用。详情如下
构亦形如管程，但它局部于实际资源管程。虚拟资源的名称上冠
取，就直接使用资源；也可以使用后忘了释放它。为避免这种危
时刻这种资源只能被--个用户所使用。这类管程可写作
7.2.5管程嵌套
以星号，表示可山用户进程存取。而*acquire和*release上的星
但我现在已不认为，引又这些复杂机制是值得的。
其继续执行。用这种方法可以高效地实现很多漂亮的调度技术；
解除排它性后，另一进程的过程调用又可将挂起的进程唤醒，使
使用这些机制，
更精巧的机制，
其终止值。
拷贝规则使用卢进程不会忘记将#的值初始化，也不会忘记打印
号则删去，使其只能在虚拟资源管程中使用，而不能由其它进程
但是，由上述管程所提供的保护可能被破坏；进程可以不经获
反复检验入口条件会造成低效率，故在管程的设计中引进了
220
monitor singleresource;
管程实例亦可用作信号量，保护单个资源，如打印机；每个
begin free: -trle; * end
procedure *release; begin free: = true end;
procedure *acquire; when free do free: = fatse;
var free:Boolean;
end 
begin rocket ,n: = 0;
if rocket.n≠0 then print(rocket.n)
begin rocket,grounded: = (rooket,n = 0) end
甚至可在过程调用的执行中途挂起自身，在自动
可以让进程等待，或者让等待的进程继续运行。
---
## Page 244
种管程可以更高效地实施，不必涉及排它性和同步；而且可由编
在 PASCALPLUS 中，称只被一个进程使用的管程为闭体；这
同使用虚拟管程的实例 mine，但在这里不讨论这种使用方式。
性使用。原则上，用乒程序块也可分成若干个并行进程，它们共
对打印机的必要的获取和释放操作都由虚拟管程自动地插入于用
在程序块P中，向行式打印机输出一个文件，写为
译程序检查其是否无意地被共享了。
卢程序块的前后，
这个管程的一个实例是
instance mine:Ipsystem .virtual;
begin
procedure lpsystem.release; begin lpsystem.free:
procedure lpsystem.acquire;
var tpsystem.free:Booleany
这些实例申明的含义同于拷贝规则的重复应用，表示如下
begin *..mine,use(ll); ..mine,use(l2); .. end
monitor singleresources
begin free: =true; *. end
procedure acquite;
frec:Boolean;
monitor *virtual;
procedurerelease;
begin free: = true end
when free do free: = falsey
when lpsystem.free do lpsystem.free: = false,
begin acquire; ."; release end
procedure *use(l:line); begin ... end ;
lpsystem.free:= true
，这样就阻止了不讲公德的用卢对打印机的破坏
instance lpsystem:singleresource; P
=true endp
221
---
## Page 245
程过程调用和非结构式的输入输出通信的混合物。进程称作任务，
7.2.6 AdaTy
长处。
计算机上实施一个操作系统，也许 PASCALPLUS具有更多的
种语言，取决于人们的口味，或者是效率的考虑。在共享主存的
PLUS的拷贝规则和进程调用的语义中表示，都是复杂的。选用哪
就是复杂的；无论在通信进程的框架中表示，或者在PASCAL
评，促使我去设计通信的顺序进程。
们的含义，也是合人费解的。Edsger W.Dijkatra当年对它们的批
SIMULA的这套记号是非常笨拙的：用替代及重新命名来解释它
使用星号和嵌套，可以取得极巧妙的效果；但是基于PASCAL和
的操作系统：后来又用PASCALPLUS实施了这些管程。混合
这个拷贝过程。
而有经验的程序员根本不愿读这个繁琐的程序，甚至不必去思考
上面列出的拷贝的细节，是为了给初学者解释虚拟管程的含义；
222
上述记号出现于1975年，当时用来解释一个类似于6.5节中
Ada中用于持发武程序设计的成分是，PASCAL PLUS 的远
但是，由6.5节中的结构可清楚看出，控制共享的机制本来
end 
end;
procedure mine.lpsystem,use(l:line); begin " end;
begin
Ipsystem.release;
..mine,lpsystem.use(ll);
Ipsystem.acquire;
..-mine.lpsystem.use(l2);
---
## Page 246
两个任务都准备好执行它们时，它们才能被执行。执行的效果如
标识符put称为人口名。
相应的调用语句可以为
明。典型的接受语句为
输入参数的过程调用语句，后者从语法和效果上都类似于过程申
它们间的通信是由调用语句和接受语句实现；前者如同带有输出
定分支的选择条件，如·
的，是选中分支中 accept 的 end 后的语句。亦可用 when来规
种选择依赖于调用任务。在完成交汇后，和调用任务并发执行
运行时，由or隔开的分支中恰好只有一个分支被选中执行，这
人或输出时也不复杂。
交汇是经常出现的交替式输出输人现象的简化，在表示单独的输
任务在--起执行它。交汇是Ada的一个非常引入注目的特色，
执行接受语句中的程序体的过程叫作交汇，就象调用任务和接受
（4）然后，从它们的下条语句开始，继续执行各任务。
（3）将输出参数的值送回调用语句。
（2）执行接受语句的程序体。
（1）将调用语句中的输入参数拷贝到接受任务。
设在不同任务中有两个名宇相同的调用语句和接受语句，当
Ada 中的挑选语句类似于口，其形式为
end select
or accept put(v:in integer)do B[i]: = v end;j: = j+ l;***
0r...
accept get(v:out integer) do v: = B[i end; i: =i+ l;.
select 
accept put(V:in integer; PREV:out integer) do
PREV:=K, K:=V end
put(37,X)
223
---
## Page 247
关键的应答，但不影响程序的逻辑行为。将程序的抽象的逻辑正
调用任务和接受任务。优先级的表示叫作pragma，可用于加速
但每个任务可服务于任意多个调用进程，这一点叉同于PASCAI
行。else 似乎等价于时间为零的延迟。
条件为假，或者在共它任务中没有相应的调用语句已在等待执
就选用它；一个分支不能被立即选用的原因，可以是它的when
在终止时做些扫尾工作。
这种办法不如PASCAL PLUS 中的内部语句，内部语句允许管程
各个任务都已终止时，才选择这个分支，从面使该任务亦终止。
择都带有一定的时间延退。
间，故不可能确罚地表示延迟现象，除非规定分支的非确定性选
的错误可能造成的死等的危险。在我们的数学模型中有意不提时
中，则选择以延迟开始的分支。这样可以避免，由于硬件或软件
其效果如同条件临界区。
处理器数，则低优先级的任务就被搁置。执行交汇的优先级高于
解这部分信息。任务体规定了征务的行为，可以和使用该任务的
调用人口名和参数类型。使用任务的程序员及编译程序都必须了
成两部分，描述部分和任务体。描述部分包括任务名，以及全部
PLUS中的管程。程序员还必须保证任务能终止。任务的定义分
事先规定了延迟的时间的长短，若经过规定时间仍无分支被选
程序分别编译。
挑选语句的分支不-一定都以 accept 开始，也可用delay。
224
挑选语句的分支亦允许为 terminate 语句。当调用该任务的
可规定Ada的任务的优先级。若可前进的任务数多于有效的
Ada中申明任务的方式很象4.5节中附庸进程的申明方式；
但这样做的结果可能会降低分布式计算机网络的效率。
调用语句亦可使用delay 或else 来保护自己，免得延迟过
whan not full=accept ...
---
## Page 248
理部件同的通信都是单向的，且只发生在进程及其邻居之间。头
于每个微处理机有自己本地的主存，存取速度极快：这就避免了
这些微处理机之间用电线相连，它们沿着这些线路相互通信。由
个微处理机合作解决一个任务是最经济的增大处理能力的方法。
级。而和微处理机相比传统的计算机仍然相当昂贵。看来，用儿
程网络。微处理机的发明将处理能力的价格降低了若干个数量
于共享存储的多机系统的实施和应用的。
功能，带来更多的复杂现象和交互影响，这里我不再介绍了。
考虑变元是否共享；这样做的效果是无法预测的。还有一些其它
元。编译程序可延迟，重新排序，或者合并变元的更新，根本不
abort），所有任务都仰赖于这种任务。任务可存取和更新共享变
务正等候进入某个人口。一个任务可以突然终止另一个任务（即
选择适宜的硬件解决实时响应问题，经常是比较容易办到的，
确性和其实时响应问题分开处理，是一种极好的想法；用实验或
计语言的多逼编译程序。在有适当存储量的计算机上，同时激活
须能成功终止，不能运行不辍。他提出可用导管结构编写程序设
类似于4.4节X2和X3，但在他的建议中，导管中的各个部件都必
一个提出这个想法的人是Conway，他解释这个想法所用的例子
7.3.1导管
享主存，所造成的瓶颈口问题。
多个处理机共享主存，而每个时刻只能由一个处理机拜访这个共
除了上面提到的那些复杂问题外，Ada的任务化功能是适用
Ada 中还提供别的辅助功能。如，可测知有多少个调用任
4.4节中刻画的线性导管中的通信是最简单的通信方式，
由于计算机硬件的惊人的进展，刺激人们去探索构造通信进
7.3
通
信
225
处
---
## Page 249
发生错误，也很难跟踪和恢复。缓冲是一种成批处理技术，在高
碍；缓存会在激源和响应间插入延迟。一且在加工缓存的激源中
-机。对于人机间的高速和可控的交互作用而言，缓存也是一种障
通信机制。在美国ARPAnet郡类存储转发成组交换网络中，在消
机制；高层次上，提供服务的模块间的通信就使用内核中的缓冲
看来也是自然的。在操作系统RC4000的内核中实施了缓冲通信
7.3.2
记号“，而不是‘》”。
计算机上，对软件的实现是很有价值的。
但达到相同的效果。Conway的建议适用于存储大小不一的各种
征，即在程序设计中允许不同的实施方法，以适用于不同的环境，
不同，但编译的结果完全-一样。这说明了程序设计的一种抽象特
并从文件中输入前一逼产生的数据。尽管这两种的执行方式十分
存放在后备存储器中的文件中。这一·逼完成后，再启动下一逼，
行。存储量不足时，每次只能激活一逼编译，而将其输出的数据
各逼编译过程，在各逼之间传递控制和消息，以此模拟并行执
有有穷个状态，整体网络系统也由无穷缓冲机制而成为无穷状态
充厅被缓冲的消息。而且也会影响数学处理，即使每个进程部件只
长度一律无界。可借，这又会导出严重的低效实施问题，主存中将
度超过5，否则-一定死锁。为避免这种无规律现象，也许令缓存
的缓存长度超过5时就会死锁；也能写出一个程序，除非缓存长
区别。缓冲并不总是可取的：例如，可以写出一个程序，当通信
出现通信回路，这时有无缓冲装置会导致系统的逻辑行为的互大
息源地和目的地之间不可免地要插入缓冲装置。
要缓冲。双向通信是导管的一种自然推广，为通信通道提供缓存
进程间的通信由线性链式通信推广为网络状通信时，就可能
226
导管方法也是UNIXTM操作系统中标准通信方法，但它使用
导管结构只允许进程链单向通信，也不讨论消息序列是否需
多重缓冲通道
---