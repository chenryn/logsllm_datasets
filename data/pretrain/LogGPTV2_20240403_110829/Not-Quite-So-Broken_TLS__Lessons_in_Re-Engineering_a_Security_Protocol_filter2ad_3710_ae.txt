tablished via HTTPS. A user can press a button on the
website which let the server initiate a renegotiation. The
server conﬁguration includes all three TLS protocol ver-
sions and eight different ciphersuites, picking a proto-
col version and ciphersuite at random. Roughly 30 000
traces were recorded from roughly 350 different client
stacks (6230 unique user agent identiﬁers).
Of these, around 27% resulted in a connection estab-
lishment failure. Our implementation is strict, and does
not allow e.g. duplicated advertised ciphersuites. Also,
several accesses came from automated tools which eval-
uate the quality of a TLS server by trying each deﬁned
ciphersuite separately.
USENIX Association  
24th USENIX Security Symposium  233
11
Roughly 50% of the failed connections did not share
a ciphersuite with nqsb-TLS. Another 20% started with
bytes which were not interpretable by nqsb-TLS. 12% of
the failed connections did not contain the secure renego-
tiation extension, which our server requires. 5% of the
failed traces were attempts to send an early change ci-
pher spec. Another 4% tried to negotiate SSL version 3.
2.5% contained a ciphersuite with null (iOS6).
We parse more than 99% of ZMap’s HTTPS
(20150615) and IMAP (20150604) certiﬁcate repository.
The remaining failures are RSASSA-PSS signatures, re-
quiring an explicit NULL as parameter, and unknown
and outdated algorithm identiﬁers.
This four-fold evaluation shows that our TLS imple-
mentation is broadly interoperable with a large number
of other TLS implementations, which also indicates that
we are capturing the de facto standard reasonably well.
Speciﬁcation mismatches While evaluating nqsb-
TLS we discovered several inconsistencies between the
RFC and other TLS implementations:
• Apple’s SecureTransport and Microsoft’s SChannel
deny application data records while a renegotiation
is in process, while the RFC allows interleaving.
• OpenSSL (1.0.1i) accepts any X.509v3 certiﬁcate
which contains either digitalSignature or keyEnci-
pherment in keyUsage. RFC [15] mandates digi-
talSignature for DHE, keyEncipherment for RSA.
• Some unknown TLS implementation starts the
padding data [29] (must be 0) with 16 bit length.
• A TLS 1.1 stack sends the unregistered alert 0x80.
7.2 Security
We assess the security of nqsb-TLS in several ways: the
discussion of the root causes of many classic vulnerabil-
ities and how we avoid them; mitigation of other speciﬁc
issues; our state machine was tested [11]; random testing
with the Frankencert [8] fuzzing tool; a public integrated
system protecting a bitcoin reward; and analysis of the
TCB size of that compared with a similar system built
using a conventional stack.
Avoidance of classic vulnerability root causes
In
Sections 3 and 4 we described how the nqsb-TLS struc-
ture and development process exclude the root causes of
many vulnerabilities that have been found in previous
TLS implementations.
Additional mitigations
The TLS RFC [15] includes
a section on implementation pitfalls, which contains a
list of known protocol issues and common failures when
implementing cryptographic operations. nqsb-TLS miti-
gates all of these.
Further issues that nqsb-TLS addresses include:
sub-protocols,
except between
change of cipher spec and ﬁnished.
empty fragment to randomise the IV (BEAST).
• Interleaving of
• Each TLS 1.0 application data is prepended by an
• Secure renegotiation [40] is required.
• SCSV extension [35] is supported.
• Best practices against attacks arising from mac-
then-encrypt in CBC mode are followed (no miti-
gation of Lucky13 [19])
• No support for export restricted ciphersuites, thus
no downgrade to weak RSA keys and small DH
groups (FREAK and Logjam).
• Requiring extended master secret [4] to resume a
session.
State machine fuzzing Researchers fuzzed [11] nqsb-
TLS and found a minor issue: alerts we send are not en-
crypted. This issue was ﬁxed within a day after discov-
ery, and it is unlikely that it was security-relevant.
Frankencert
Frankencert is a fuzzing tool which gen-
erates syntactically valid X.509 certiﬁcate chains by ran-
domly mixing valid certiﬁcates and random data. We
generated 10 000 X.509 certiﬁcate chains, and compared
the veriﬁcation result of OpenSSL (1.0.1i) and nqsb-TLS
The result is that nqsb-TLS accepted 120 certiﬁcates, a
strict subset of the 192 OpenSSL accepted.
Of these 72 accepted by OpenSSL but not by nqsb-
TLS, 57 certiﬁcate chains contain arbitrary data in
X.509v3 extensions where our implementation allows
only restricted values. An example is the key usage ex-
tension, which speciﬁes a sequence of OIDs. In the RFC,
9 different OIDs are deﬁned. Our X.509v3 grammar re-
stricts the value of the key usage extension to those 9
OIDs. 12 certiﬁcate chains included an X.509v3 exten-
sion marked critical but not supported by nqsb-TLS.
Two server certiﬁcates are certiﬁcate authority certiﬁ-
cates. While not required by the path validation, best
practices from Mozilla recommend to not accept a server
certiﬁcate which can act as certiﬁcate authority. The last
certiﬁcate is valid for a Difﬁe-Hellman key exchange,
but not for RSA. Our experimental setup used RSA, thus
nqsb-TLS denied the certiﬁcate appropriately.
Exposure to new vulnerabilities Building nqsb-TLS
in a managed language potentially opens us up to vul-
nerabilities that would not affect stacks written in C.
Algorithmic complexity attacks are a low-bandwidth
class of denial-of-service attacks that exploit deﬁcien-
cies in many common default data structure implementa-
tions [10]. The modular structure of nqsb-TLS makes it
easy to audit the implementations used within each com-
ponent. The French computer security governmental of-
ﬁce [37] assessed the security of the OCaml runtime in
234  24th USENIX Security Symposium 
USENIX Association
12
2013, which lead to several changes (such as distinction
between immutable strings and mutable byte arrays).
The Bitcoin Pi˜nata To demonstrate the use of nqsb-
TLS in an integrated system based on MirageOS, and
to encourage external code-review and penetration test-
ing, we set up a public bounty, the Bitcoin Pi˜nata. This
is a standalone MirageOS unikernel containing the se-
cret key to a bitcoin address, which it transmits upon es-
tablishing a successfully authenticated TLS connection.
The service exposes both TLS client and server on differ-
ent ports, and it is possible to bridge the trafﬁc between
the two and observe a successful handshake and the en-
crypted exchange of the secret.
The attack surface encompasses the entire system,
from the the underlying operating system and its TCP/IP
stack, to TLS and the cryptographic level. The system
will only accept connections authenticated by the cus-
tom certiﬁcate authority that we set up for this purpose.
Reward is public and automated, because if an attacker
manages to access the private bitcoin key, they can trans-
fer the bitcoins to an address of their choosing, which is
attestable through the blockchain.
While this setup cannot prove the absence of security
issues in our stack, it motivated several people to read
through our code and experiment with the service.
At the end of June 2015, there were 230 000 accesses
to the website from more than 50 000 unique IP ad-
dresses. More than 9 600 failed and 12 000 successful
TLS connections from 1000 unique IPs were present. Al-
though we cannot directly verify that all successful con-
nection resulted from the service being short-circuited
to connect to itself, there have been no outgoing trans-
actions registered in the blockchain. The breakdown of
failed connections is similar to §7.1. We collected 42 cer-
tiﬁcates which were tried for authentication, but failed
(not well formatted, not signed, not signed by our trust
anchor, private key not present). A detailed analysis of
the captured traces showed that most of the ﬂaws in other
stacks have been attempted against the Pi˜nata.
Trusted computing base The TCB size is a rough
quantiﬁcation of the attack surface of a system. We as-
sess the TCB of our Pi˜nata, compared to a similar tradi-
tional system using Linux and OpenSSL. Both systems
are executed on the same hardware and the Xen hyper-
visor, which we do not consider here. The TCB sizes of
the two systems are shown in Table 2 (using cloc).
The traditional system contains the Linux kernel (ex-
cluding device drivers and assembly code), glibc, and
OpenSSL. In comparison, our Pi˜nata uses a minimal op-
erating system, the OCaml runtime, and several OCaml
libraries (including GMP). While the traditional sys-
tem uses a C compiler, our Pi˜nata additionally uses the
OCaml compiler (roughly 40 000 lines of code).
Kernel
Runtime
Crypto
TLS
Total
Linux/OpenSSL Unikernel/nqsb-TLS
(36)
(6)
(14)
(0)
(56)
1600
689
230
41
2560
48
25
23
6
102
Table 2: TCB (in kloc); portion of C code in parens
RSA
DHE-RSA
nqsb-TLS OpenSSL PolarSSL
672 hs/s
367 hs/s
698 hs/s
601 hs/s
723 hs/s
515 hs/s
Handshake performance of nqsb-TLS,
Table 3:
OpenSSL and PolarSSL, using 1024-bit RSA certiﬁcate
and 1024-bit DH group.
The trusted computing base of the traditional system
is 25 times larger than ours. Both systems provide the
same service to the outside world and are hardly distin-
guishable for an external observer.
7.3 Performance
We evaluate the performance of nqsb-TLS, comparing it
to OpenSSL 1.0.2c and PolarSSL 1.3.11. We use a single
machine to avoid network effects. In the case of nqsb-
TLS, we compile the test application as a Unix binary to
limit the comparison to TLS itself.
The test machine has an Intel i7-5600 Broadwell CPU
and runs Linux 4.0.5 and glibc 2.21. Throughput is mea-
sured by connecting the command line tool socat, linked
against OpenSSL, to a server running the tested imple-
mentation, and transferring 100 MB of data from the
client to the server. This test is repeated for various
transmission block sizes. Handshakes are measured by
running 20 parallel processes in a continuous connecting
loop and measuring the maximum number of successful
connection within 1 second; the purpose of parallelism is
to negate the network latency.
Throughput rates are summarized in Figure 4. With
16 byte blocks, processing is dominated by the protocol
overhead. This helps us gauge the performance impact
of using OCaml relative to C, as nqsb-TLS implements
protocol logic entirely in OCaml. At this size, we run at
about 78% of OpenSSL’s speed.
At 8196 bytes, performance becomes almost entirely
dominated by cryptographic processing. All three im-
plementations use AES-NI, giving them roughly compa-
rable speed. OpenSSL’s performance lead is likely due
to its extensive use of assembly, and in particular the
technique of stitching, combining parts the of the cipher
mode of operation and hashing function to saturate the
CPU pipeline. PolarSSL’s performance drop compared
USENIX Association  
24th USENIX Security Symposium  235
13
models need to be validated with actual implementations,
to relate to the de facto standard, but this is rarely done
(to do so, some kind of trace checker or executable needs
to be developed). Some of these models formalised the
handshake protocol, but omitted renegotiation, in which
a security ﬂaw was present until discovered in 2009.
miTLS
The miTLS [5] stack is developed in F7 with
the possibility to extract executable F# code. It is both
a formalisation of the TLS protocol and a runnable im-
plementation. This formalisation allowed its developers
to discover two protocol-level issues: alert fragmentation
and triple handshake. As an implementation, it depends
on the Common Language Runtime for execution, and
uses its services for cryptographic operations and X.509
treatment (including ASN.1 parsing). In contrast, nqsb-
TLS cannot be used for verifying security properties of
TLS, but provides a test oracle and a fast runnable imple-
mentation which is easily deployable. It compiles to na-
tive code and implements the entire stack from scratch,
making it self-contained.
It can be used e.g. in Mira-
geOS, which only provides the bare TCP/IP interfaces
and has no POSIX layer or cryptographic services.
Language-oriented approach to security Mettler et
al. propose Joe-E [33], a subset of Java designed to sup-
port the development of secure software systems. They
strongly argue in favour of a particular programming
style to facilitate ease of security reviews.
Our approach shares some of the ideas in Joe-E. By
disallowing mutable static ﬁelds of Java classes, they ef-
fectively prohibit globally visible mutable state and en-
force explicit propagation of references to objects, which
serve as object capabilities. They also emphasise im-
mutability to restrict the ﬂows of data and achieve better
modularity and separation of concerns.
The difference in our approach is that we use im-
mutability and explicit data-passing not only on the mod-
ule (or class) boundaries but pervasively throughout the
code, aiming to facilitate code-review and reasoning on
all levels. A further difference is that Joe-E focusses the
proposed changes in style on security reviews only, aim-
ing to help the reader of the code ascertain that the code
does not contain unforeseen interactions and faithfully
implements the desired logic. In contrast, we employ a
fully declarative style. Our goals go beyond code review,
as large portions of our implementation are accessible as
a clariﬁcation to the speciﬁcation, and we have an exe-