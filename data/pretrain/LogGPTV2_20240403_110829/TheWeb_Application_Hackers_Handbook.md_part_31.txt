“-” +
System.currentTimeMillis();
Given our analysis of how tokens are created, it is straightforward to con-
struct a scripted attack to harvest the session tokens that the application issues
to other users:
n We continue polling the server to obtain new session tokens in quick
succession.
n We monitor the increments in the fi rst number. When this increases by
more than 1, we know that a token has been issued to another user.
n When a token has been issued to another user, we know the upper and
lower bounds of the second number that was issued to that person, because
we possess the tokens that were issued immediately before and after
his. Because we are obtaining new session tokens frequently, the range
between these bounds will typically consist of only a few hundred values.
n Each time a token is issued to another user, we launch a brute-force attack
to iterate through each number in the range, appending this to the miss-
ing incremental number that we know was issued to the other user. We
attempt to access a protected page using each token we construct, until
the attempt succeeds and we have compromised the user’s session.
n Running this scripted attack continuously will enable us to capture the
session token of every other application user. When an administrative
user logs in, we will fully compromise the entire application.
TRY IT!
http://mdsec.net/auth/339/
http://mdsec.net/auth/340/
http://mdsec.net/auth/347/
http://mdsec.net/auth/351/
cc0077..iinndddd 221177 88//1199//22001111 1122::0077::4400 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 218
218 Chapter 7 n Attacking Session Management
Weak Random Number Generation
Very little that occurs inside a computer is random. Therefore, when random-
ness is required for some purpose, software uses various techniques to generate
numbers in a pseudorandom manner. Some of the algorithms used produce
sequences that appear to be stochastic and manifest an even spread across the
range of possible values. Nevertheless, they can be extrapolated forwards or
backwards with perfect accuracy by anyone who obtains a small sample of values.
When a predictable pseudorandom number generator is used to produce
session tokens, the resulting tokens are vulnerable to sequencing by an attacker.
Jetty is a popular web server written in 100% Java that provides a session
management mechanism for use by applications running on it. In 2006, Chris
Anley of NGSSoftware discovered that the mechanism was vulnerable to a
session token prediction attack. The server used the Java API java.util.Random
to generate session tokens. This implements a “linear congruential generator,”
which generates the next number in the sequence as follows:
synchronized protected int next(int bits) {
seed = (seed * 0x5DEECE66DL + 0xBL) & ((1L >> (48 - bits));
}
This algorithm takes the last number generated, multiplies it by a constant,
and adds another constant to obtain the next number. The number is truncated
to 48 bits, and the algorithm shifts the result to return the specifi c number of
bits requested by the caller.
Knowing this algorithm and a single number generated by it, we can easily
derive the sequence of numbers that the algorithm will generate next. With a
little number theory, we also can derive the sequence that it generated previ-
ously. This means that an attacker who obtains a single session token from the
server can obtain the tokens of all current and future sessions.
NOTE Sometimes when tokens are created based on the output of a pseu-
dorandom number generator, developers decide to construct each token by
concatenating several sequential outputs from the generator. The perceived
rationale for this is that it creates a longer, and therefore “stronger,” token.
However, this tactic is usually a mistake. If an attacker can obtain several
consecutive outputs from the generator, this may enable him to infer some
information about its internal state. In fact, it may be easier for the attacker to
extrapolate the generator’s sequence of outputs, either forward or backward.
Other off-the-shelf application frameworks use surprisingly simple or predict-
able sources of entropy in session token generation, much of which is deterministic.
For example, in PHP frameworks 5.3.2 and earlier, the session token is generated
cc0077..iinndddd 221188 88//1199//22001111 1122::0077::4400 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 219
Chapter 7 n Attacking Session Management 219
based on the client’s IP address, epoch time at token creation, microseconds at
token creation, and a linear congruential generator. Although there are several
unknown values here, some applications may disclose information that allows
them to be inferred. A social networking site may disclose the login time and
IP address of site users. Additionally, the seed used in this generator is the time
when the PHP process started, which could be determined to lie within a small
range of values if the attacker is monitoring the server.
NOTE This is an evolving area of research. The weaknesses in PHP’s session
token generation were pointed out on the Full Disclosure mailing list in 2001
but were not demonstrated to be actually exploitable. The 2001 theory was
fi nally put into practice by Samy Kamkar with the phpwn tool in 2010.
Testing the Quality of Randomness
In some cases, you can identify patterns in a series of tokens just from visual
inspection, or from a modest amount of manual analysis. In general, however,
you need to use a more rigorous approach to testing the quality of randomness
within an application’s tokens.
The standard approach to this task applies the principles of statistical hypoth-
esis testing and employs various well-documented tests that look for evidence of
nonrandomness within a sample of tokens. The high-level steps in this process
are as follows:
1. Start with the hypothesis that the tokens are randomly generated.
2. Apply a series of tests, each of which observes specifi c properties of the
sample that are likely to have certain characteristics if the tokens are
randomly generated.
3. For each test, calculate the probability of the observed characteristics
occurring, working on the assumption that the hypothesis is true.
4. If this probability falls below a certain level (the “signifi cance level”), reject
the hypothesis and conclude that the tokens are not randomly generated.
The good news is you don’t have to do any of this manually! The best tool
that is currently available for testing the randomness of web application tokens
is Burp Sequencer. This tool applies several standard tests in a fl exible way and
gives you clear results that are easy to interpret.
To use Burp Sequencer, you need to fi nd a response from the application
that issues the token you want to test, such as a response to a login request that
issues a new cookie containing a session token. Select the “send to sequencer”
option from Burp’s context menu, and in the Sequencer confi guration, set the
location of the token within the response, as shown in Figure 7-2. You can also
cc0077..iinndddd 221199 88//1199//22001111 1122::0077::4400 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 220
220 Chapter 7 n Attacking Session Management
confi gure various options that affect how tokens are collected, and then click
the start capture button to begin capturing tokens. If you have already obtained
a suitable sample of tokens through other means (for example, by saving the
results of a Burp Intruder attack), you can use the manual load tab to skip the
capturing of tokens and proceed straight to the statistical analysis.
Figure 7-2: Configuring Burp Sequencer to test the randomness of a session token
When you have obtained a suitable sample of tokens, you can perform the
statistical analysis on the sample. You can also perform interim analyses while
the sample is still being captured. In general, obtaining a larger sample improves
the reliability of the analysis. The minimum sample size that Burp requires is
100 tokens, but ideally you should obtain a much larger sample than this. If the
analysis of a few hundred tokens shows conclusively that the tokens fail the
randomness tests, you may reasonably decide that it is unnecessary to capture
further tokens. Otherwise, you should continue capturing tokens and re-perform
the analysis periodically. If you capture 5,000 tokens that are shown to pass the
randomness tests, you may decide that this is suffi cient. However, to achieve
compliance with the formal FIPS tests for randomness, you need to obtain a
sample of 20,000 tokens. This is the largest sample size that Burp supports.
Burp Sequencer performs the statistical tests at character level and bit level.
The results of all tests are aggregated to give an overall estimate of the number
cc0077..iinndddd 222200 88//1199//22001111 1122::0077::4400 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 221
Chapter 7 n Attacking Session Management 221
of bits of effective entropy within the token; this the key result to consider.
However, you can also drill down into the results of each test to understand
exactly how and why different parts of the token passed or failed each test, as
shown in Figure 7-3. The methodology used for each type of test is described
beneath the test results.
Figure 7-3: Analyzing the Burp Sequencer results to understand the properties of
the tokens that were tested
Note that Burp performs all tests individually on each character and bit of data
within the token. In many cases, you will fi nd that large parts of a structured
token are not random; this in itself may not present any kind of weakness. What
matters is that the token contains a suffi cient number of bits that do pass the
randomness tests. For example, if a large token contains 1,000 bits of informa-
tion, and only 50 of these bits pass the randomness tests, the token as a whole
is no less robust than a 50-bit token that fully passes the tests.
cc0077..iinndddd 222211 88//1199//22001111 1122::0077::4400 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 222
222 Chapter 7 n Attacking Session Management
NOTE Keep in mind two important caveats when performing statisti-
cal tests for randomness. These caveats affect the correct interpretation of
the test results and their consequences for the application’s security pos-
ture. First, tokens that are generated in a completely deterministic way may
pass the statistical tests for randomness. For example, a linear congruential
pseudorandom number generator, or an algorithm that computes the hash
of a sequential number, may produce output that passes the tests. Yet an
attacker who knows the algorithm and the internal state of the generator can
extrapolate its output with complete reliability in both forward and reverse
directions.
Second, tokens that fail the statistical tests for randomness may not actu-
ally be predictable in any practical situation. If a given bit of a token fails the
tests, this means only that the sequence of bits observed at that position con-
tains characteristics that are unlikely to occur in a genuinely random token.
But attempting to predict the value of that bit in the next token, based on the
observed characteristics, may be little more reliable than blind guesswork.
Multiplying this unreliability across a large number of bits that need to be
predicted simultaneously may mean that the probability of making a correct
prediction is extremely low.
HACK STEPS
1. Determine when and how session tokens are issued by walking through
the application from the first application page through any login func-
tions. Two behaviors are common:
n The application creates a new session anytime a request is received that
does not submit a token.
n The application creates a new session following a successful login.
To harvest large numbers of tokens in an automated way, ideally identify
a single request (typically either GET/ or a login submission) that causes
a new token to be issued.
2. In Burp Suite, send the request that creates a new session to Burp
Sequencer, and configure the token’s location. Then start a live capture
to gather as many tokens as is feasible. If a custom session management
mechanism is in use, and you only have remote access to the application,
gather the tokens as quickly as possible to minimize the loss of tokens
issued to other users and reduce the influence of any time dependency.
3. If a commercial session management mechanism is in use and/or you
have local access to the application, you can obtain indefinitely large
sequences of session tokens in controlled conditions.
cc0077..iinndddd 222222 88//1199//22001111 1122::0077::4411 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 223
Chapter 7 n Attacking Session Management 223
4. While Burp Sequencer is capturing tokens, enable the “auto analyse” set-
ting so that Burp automatically performs the statistical analysis periodi-
cally. Collect at least 500 tokens before reviewing the results in any detail.
If a sufficient number of bits within the token have passed the tests,
continue gathering tokens for as long as is feasible, reviewing the analysis
results as further tokens are captured.
5. If the tokens fail the randomness tests and appear to contain patterns
that could be exploited to predict future tokens, reperform the exercise
from a different IP address and (if relevant) a different username. This
will help you identify whether the same pattern is detected and whether
tokens received in the first exercise could be extrapolated to identify
tokens received in the second. Sometimes the sequence of tokens cap-
tured by one user manifests a pattern. But this will not allow straight-
forward extrapolation to the tokens issued to other users, because
information such as source IP is used as a source of entropy (such as a
seed to a random number generator).
6. If you believe you have enough insight into the token generation algo-
rithm to mount an automated attack against other users’ sessions, it is
likely that the best means of achieving this is via a customized script.
This can generate tokens using the specific patterns you have observed
and apply any necessary encoding. See Chapter 14 for some generic tech-
niques for applying automation to this type of problem.
7. If source code is available, closely review the code responsible for gener-
ating session tokens to understand the mechanism used and determine
whether it is vulnerable to prediction. If entropy is drawn from data that
can be determined within the application within a brute-forcible range,
consider the practical number of requests that would be needed to brute-
force an application token.
TRY IT!
http://mdsec.net/auth/361/
Encrypted Tokens
Some applications use tokens that contain meaningful information about the
user and seek to avoid the obvious problems that this entails by encrypting the
tokens before they are issued to users. Since the tokens are encrypted using a
secret key that is unknown to users, this appears to be a robust approach, because
users will be unable to decrypt the tokens and tamper with their contents.
cc0077..iinndddd 222233 88//1199//22001111 1122::0077::4411 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 224
224 Chapter 7 n Attacking Session Management
However, in some situations, depending on the encryption algorithm used and
the manner in which the application processes the tokens, it may nonetheless be
possible for users to tamper with the tokens’ meaningful contents without actu-
ally decrypting them. Bizarre as it may sound, these are actually viable attacks
that are sometimes easy to deliver, and numerous real-world applications have
proven vulnerable to them. The kinds of attacks that are applicable depend on
the exact cryptographic algorithm that is being used.
ECB Ciphers
Applications that employ encrypted tokens use a symmetric encryption algorithm
so that tokens received from users can be decrypted to recover their meaningful
contents. Some symmetric encryption algorithms use an “electronic codebook”
(ECB) cipher. This type of cipher divides plaintext into equal-sized blocks (such
as 8 bytes each) and encrypts each block using the secret key. During decryp-
tion, each block of ciphertext is decrypted using the same key to recover the
original block of plaintext. One feature of this method is that patterns within the
plaintext can result in patterns within the ciphertext, because identical blocks of
plaintext will be encrypted into identical blocks of ciphertext. For some types
of data, such as bitmap images, this means that meaningful information from
the plaintext can be discerned within the ciphertext, as illustrated in Figure 7-4.
Figure 7-4: Patterns within plaintext that
is encrypted using an ECB cipher may be
visible within the resulting ciphertext.
In spite of this shortcoming with ECB, these ciphers are often used for encrypt-
ing information within web applications. Even in situations where the problem
of patterns within plaintext does not arise, vulnerabilities can still exist. This
is because of the cipher’s behavior of encrypting identical plaintext blocks into
identical ciphertext blocks.
Consider an application whose tokens contain several different meaningful
components, including a numeric user identifi er:
rnd=2458992;app=iTradeEUR_1;uid=218;username=dafydd;time=634430423694715
000;
cc0077..iinndddd 222244 88//1199//22001111 1122::0077::4411 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 225
Chapter 7 n Attacking Session Management 225
When this token is encrypted, it is apparently meaningless and is likely to pass
all standard statistical tests for randomness:
68BAC980742B9EF80A27CBBBC0618E3876FF3D6C6E6A7B9CB8FCA486F9E11922776F0307
329140AABD223F003A8309DDB6B970C47BA2E249A0670592D74BCD07D51A3E150EFC2E69
885A5C8131E4210F
The ECB cipher being employed operates on 8-byte blocks of data, and the
blocks of plaintext map to the corresponding blocks of ciphertext as follows:
rnd=2458 68BAC980742B9EF8
992;app= 0A27CBBBC0618E38
iTradeEU 76FF3D6C6E6A7B9C
R_1;uid= B8FCA486F9E11922
218;user 776F0307329140AA
name=daf BD223F003A8309DD
ydd;time B6B970C47BA2E249
=6344304 A0670592D74BCD07
23694715 D51A3E150EFC2E69
000; 885A5C8131E4210F
Now, because each block of ciphertext will always decrypt into the same
block of plaintext, it is possible for an attacker to manipulate the sequence of
ciphertext blocks so as to modify the corresponding plaintext in meaning-
ful ways. Depending on how exactly the application processes the resulting
decrypted token, this may enable the attacker to switch to a different user or
escalate privileges.
For example, if the second block is duplicated following the fourth block, the
sequence of blocks will be as follows:
rnd=2458 68BAC980742B9EF8
992;app= 0A27CBBBC0618E38
iTradeEU 76FF3D6C6E6A7B9C
R_1;uid= B8FCA486F9E11922
992;app= 0A27CBBBC0618E38
218;user 776F0307329140AA