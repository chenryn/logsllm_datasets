闲话说的很多了，现在让我们开始吧。
怎样打造链（链接基础）
为了绕过DEP，我们需要打造一连串现有指令。能够在所有的模块中找到的指令（只要它
们可执行，有一个静态地址并且不包含null字节的就行）
基本上，由于你需要将数据放到栈上（将会绕过DEP的函数参数），你将会找一些能够允许
你修改寄存器的指令，将数据入栈和出栈等等。
这些指令中的每一个--由于某种原因--需要跳到你要执行的下一条指令（或者指令集）。最简
单的方法是确保这指令跟着一条RET指令。这个RET指令会从栈上拾取下一个地址然后跳
过去。（毕竟，我们从栈上开始我们的链，因此RET将会返回到栈上然后带走下一个地址）。
因此基本上在我们的链中，我们将会从栈上拾取地址然后跳过去。这些地址的指令能够从栈
上拾取数据（因此当然这些字节不得不放在正确的地方）。这些的结合会形成我们的rop链。
每个“指令+RET”被叫做一个“ROP小配件”。
这意味着，在指针之间（指向指令），你可以通过这些指令中的一个来放你能拾取到的数据。
同时，你需要评估下这些指令能干什么并且栈上两个指针怎样影响你需要的空间。如果一个
指令执行ADDESP，8，然后这将会移动栈指针，并且会影响下一个指针应该放在哪里。因
此小配件末尾的RET需要返回到下一条指令的指针。
我猜很明白你的ROP例程会很可能消费栈上的一定数量的字节。因此我们的例程的可利用
缓冲区空间会很重要。
如果所有听起来很复杂，那么不要担心。我会用一个小例子来使事情明白点：
比如说，作为ROP例程的一部分，我们需要从栈上取出一个值，放在EAX中，并且加上
0x80。换句话说：
●我们需要找到一个指向POP EAX+RET的指针然后放到栈上（小配件1）
●放入EAX中的值必须放在指针的下面
●我们需要找到另一个指针（指向ADD EAX，80+RET）并且将它放在从栈上弹出的值的下面
（小配件2）
●我们需要跳到第一个小配件（指向POP EAX+RET）来开始这个链
我们将在一会儿讨论找rop指针。现在，我将给你这些指针：
10026D56：POP EAX+RET：小配件1
1002DC24：ADD EAX,80+POP EBX+RET:小配件2
（第二个指针会执行POP EBX。这不会破坏我们的链，但是会影响ESP和你需要用作下一个
rop小配件的填料，因此我们不得不插入一些“填料”来弥补这个）
因此，如果我们要一个接一个执行这两个指令，然后用我们期待的在EAX中的值来结束，那
么栈设置是这样的：
栈地址 栈值
ESP指向这里-> 0010F730 10026D56（指向POP EAX+RET）
0010F734 50505050（将被弹入EAX）
0010F738 1002DC24（指向ADDEAX，80+POPEBX+RET）
0010F73C DEADBEEF（将被弹入EBX，填料）
因此，首先，我们将需要确认0x10026D56被执行。我们在我们的exploit的开始处，因此
我们不得不使EIP指向一个RET指令。在一个已经加载的模块中找到一个指向RET的指针然
后将那地址放入EIP中。我们用0x100102DC。
当EIP被一个指向RET的指针覆盖，它明显会跳到那个RET指令。RET指令会返回到栈中，
在ESP（0x10026D56）取出值然后跳到那里。这将指向POP EAX并且将50505050放入EAX
中。POP EAX（在0x10026D57）后的RET会跳到ESP处的地址。这会在0x1002DC24（因为
50505050被弹到eax中）。0x1002DC24是指向ADDEAX，80+POPEBX+RET的指针，因此下一
个小配件会在50505050加上0x80。
我们的例子exploit将会是这样的：
将调试器附加到这个程序中，然后在0x100102DC设置一个断点。运行程序然后倒入m3u文
件。断点将会被碰上：
当碰上断点时，EIP指令指向我们的RETN指令。你可以在CPU窗口下面的小窗口中看到
RET指令会返回到0x10026D56（在栈顶，ESP指向的位置）：
●RETN：EIP跳到0x10026D56，ESP移动到0010F734
●POP EAX：将会从栈上取出50505050然后放入EAX。ESP移到0010F738
●RETN：会将1002DC24放入EIP并且将ESP移到0010F73C
●ADD EAX，80：将会在50505050上加上0x80（EAX）
●POP EBX：这会将DEADBEEF放入EBX中并且会将ESP加上4字节（到0010F740）
●RETN：这会从栈上取出下一个指针然后跳到那里（这个例子中是43434343）
在最后一个RETN被执行前，我们可以看到：
正如你能看到的，我们可以执行指令并且在寄存器上精巧制作值，没有直接在栈上执行一条
单独的机器码。我们已经将现有的指令链在一起，这是ROP的本质。
在继续之前确保你已经理解了链接的思想。
找 RRRROOOOPPPP 小配件
一会儿之前，我已经介绍了ROP链的基础。本质上，你需要找到跟着一个RET指令（RETN，
RETN4，RETN8等等）的指令序列，它会允许你跳到下一个序列/小配件。
有两种方法来找到帮你打造ROP链的小配件：
●你可以明确地找一些指令然后看它们是否跟着一个RET。在你找的指令和RET指令之间的
指令（会结束小配件）应该不要破坏小配件。
●你可以找所有的RET指令然后往回走，看是否前面的指令包括你要找的指令。
在两者情况下，你可以用调试器来找指令，找RET，等等。然而，手动搜索这些指令是很费
时间的。
而且，如果你用“列出所有的并且往回看”的方法（将会立刻产生更多的结果并且给你更精
确的结果），你可以做些机器码分片来找额外的小配件（以同样的ret结束的）
这听起来有点模糊，因此我将给你一个例子。
比如你在0x0040127C（机器码0xC3）找一个RET。在调试器的CPU窗口中，在ret之前的
指令是ADD AL，0x58（机器码0x80 0xc0 0x58）。因此你已经找到一个将0x58加到AL上的
小配件。
这两个指令通过分开ADD指令的机器码能产生另一个小配件。ADD指令的最后一个字节
是58。并且那是POPEAX的机器码。
这意味着有另一个rop小配件，从0x0040127E处开始：
如果你正在找RET然后再调试器窗口看前面的指令，那么你不能发现这个。
为了能使你的生活更简单点，我已经在pvefindaddr写了一个函数，它将
●找所有的ret（RETN，RETN4，RETN8等等）
●往回看（一直到8个指令）
●并且会做“机器码分块”来找新的以同样的RET小配件
因此打造自己的rop小配件集，所有你要做的是运行!Pvefindaddrrop，它将会给你很多的
rop小配件给你玩。并且如果你的指针（rop小配件）必须是没有null字节的，那么简单地
运行“!pvefindaddr rop nonull”。
这个函数会写入所有的ROP小配件到Immunity Debugger的程序文件夹下的“rop.txt”文
件中。注意这个操作很花费CPU的，并且会花一天来产生所有的小配件（取决于加载模块的
数目）。我的建议是找你要用的模块（!Pvefindaddr noaslr）并且运行!Pvefindaddr rop 而不是盲目地在所有模块上运行它。
你能从一个特定的模块中通过制定模块名（如：“!Pvefindaddr rop MSRMfilter03.dl”）创
建rop小配件
注意：“!pvefindaddrrop”将自动忽略ASLR模块中的地址或者需要重定基址的模块。
这会帮我们确认结果（rop.txt）只包含能够导致或多或少可靠的exploit的指针。如果你坚持
包括这些模块的指针，你将不得不手工对这些模块的每一个运行!pvefindaddrrop。
“ccccaaaallllllll 寄存器”小配件
倘使你正在找一个特别的指令，但是看起来不可能找到一个以ret结束的小配件？倘使你已
经你已经在你喜欢加载的模块中完成搜索，并且发现你只能找到一个在RET前有一个“call
寄存器”的指令？
首先，你应该找一种方法来将一个有意义的指针放入那个寄存器中。只是使一个指针放在栈
上然后给自己找一个能将值放入寄存器的小配件。这回确认CALL寄存器指令将会成功。
这个指针可以是一个RET，允许你那样做犹如CALL指令不存在。或者你也能简单地用一
个指向另一个小配件的指针来继续你的rop链。
Pvefindaddrrop也会列出在ret前面有一个call寄存器指令的小配件。
明白了。但是我要怎样////从哪里开始？
在写单独的一行代码前，你要做的第一件事是设置你的策略，通过问自己下面的问题：
●我会用什么技术（WindowsAPI）来绕过DEP并且在栈上创建的栈设置/参数会有什么影响。
当前的DEP策略是什么并且绕过它的选择是什么？
●我能用什么rop小配件？（这个会是你的工具箱并且会允许你精巧制作你的栈）
●怎么开始这个链？怎样转到你控制的缓冲区上？（在一个direct RET exploit中，你很
可能控制ESP，因此你简单地用一个指向RETN的指针来覆盖EIP来开始这个链）
●怎样精巧地布置栈？
回答：
●技术：在这个例子中，我会用VirtualProtect()来修改你的shellcode在的位置的内存
页保护参数。你可以明显用DEP策略兼容函数中的一个，但这个例子中我会用
VirtualProtect()。当函数被调用时，这个函数需要下面的参数放在栈顶：
○返回地址。在VirtualProtect()函数完成时，这个是函数要返回到的地址。
（=shellcode在的位置的指针。在运行时动态产生的地址（rop））
○lpAddress：shellcode在的位置的指针。在运行时动态产生的地址（rop）
○Size：在运行时动态产生（除非你的exploit缓冲区能处理null字节，但是这不是
Easy RM to MP3的情况）
○flNewProtect：新的保护标志。这个值必须设成0x20来使页面可执行。这个值包含
null字节，因此这个值也要在运行时产生。
○lpflOldProtect:接收旧的保护标志值的指针。它可以是静态地址，但是必须是可写
的。我会从Easy RM to MP3 Converter模块（0x10035005）中的一个取出一个地址。
●ROP小配件：!pvefindaddr rop
●开始这个链：转到栈上。这个例子中，是一个direct RET覆盖，因此我们只需一个RET
的指针。我们已经有一个可以成功的指针（0x100102DC）
●可以用不同的方法精巧地布置栈。你可以将值放到寄存器中然后将它们入栈。你可以把一
些值放到栈上然后用sniper技术写入动态值。打造逻辑，这个难题，这个酷比魔方，可能
是整个ROP打造过程中最难的部分。
我们的编码后的shellcode（“弹出一个对话框”）将在620字节左右并且能首先存在栈上的
某个地方。（我们不得不编码整个shellcode因为Easy RM to MP3有一些字符限制）
我们的缓冲区/栈看起来是这样的：
●废物
●eip
●废物
●产生/写入参数的rop链
●调用VirtualProtect函数的rop链
●更多的rop/一些填料/nop
●shellcode
●废物
并且在VirtualProtect函数被调用的同时，栈被rop链修改成这样：
废物
Eip
废物
rop
ESP指向这里-> 参数
更多的rop
填料/nop
Shellcode
废物
开始前测试下
在实际打造rop链之前，我会核实VirtualProtect()会导致期望的结果。最简单的方法是
在调试器里手动布置栈/函数参数：
●是EIP指向VirtualProtect()函数调用。在XP SP3，这个函数能在0x7C801AD4
●手动将VirtualProtect()期望的参数入栈
●将shellcode入栈
●运行函数
如果成功，我确信VirtualProtect()调用会成功，shellcode也会成功运行。
为了使这个简单的测试更容易，我将用下面的exploit脚本：
用这个脚本，我们用VirtualProtect()的指针（0x7C801AD4）覆盖EIP，并且我们会将5个需
要的参数放到栈顶，接着一些nop指令，然后是messageboxshellcode。
lpAddress，Size和flNewProtect参数设成“XXXX”，“YYYY”和“ZZZZ”。我们将在一会
儿手动改变他们。
创建m3u文件，将ImmunityDebugger附加到程序中然后在0x7C801AD4处设一个断点。运
行程序，打开m3u文件并核查断点被碰上：
现在看下栈顶。我们可以看到5个参数：
滚下来知道你能看到shellcode的开头：
记录shellcode的基地址（例子中是0010F80C）然后滚下来核查整个shellcode都在栈中。
现在的思路是手动编辑栈上的参数然后测试VirtualProtect调用会不会成功。
在栈上编辑一个值和选择一个值一样简单，按CTRL+E，然后输入一个新的值（记住这是小
顶机！）。
首先，在0010F730处编辑值（返回地址）然后将它设成shellcode的地址（0010F80C）。
然后在0010F734处（Address，现在包含58585858）编辑值，把它设成0010F80C（同样，
你的shellcode在的位置的地址）
现在，在0010F738处（Size，现在包含59595959）编辑值，把它设成shellcode的大小。我
将花700字节，和0x2BC一致
有点远也没事，只要确保你的shellcode会包含在Address+Size的范围之内。你会看到
当用rop来精巧制作一个值是很困难的，因此你理解你不需要很精确是很重要的。如果你用
nop来包围你的代码并且你确信你能覆盖所有的shellcode，那也可以。
最后，在0010F73C（NewProtect）处编辑值并设成0x40：
修改之后，栈是这样的：
按F7一次然后看怎样跳到VirtualProtect()。
正如你所看到的，这个函数自身很短，除了一些跟栈相互作用的指令之外，只包含一个到
VirtualProtectEx的调用。这个函数将改变访问保护级别。
继续单步步入这些指令（F7）知道你到达RETN10指令（在0x7C801AED）。
在那时，栈包含这个：
ret将会跳到我们的shellcode中然后执行（如果一切顺利的话）