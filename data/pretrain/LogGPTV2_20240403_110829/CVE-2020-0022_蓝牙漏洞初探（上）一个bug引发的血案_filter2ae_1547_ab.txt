### 3.2.3 后续HCI-ACL碎片的处理
若当前HCI-ACL数据包是相应L2CAP PDU的后续碎片，其处理流程如下：

1. **初步解析**：在对数据包进行初步解析后（Line 197），如果当前HCI包为后续碎片，则计算`projected_offset`。该值由`partial_packet->offset + (packet->len - HCI_ACL_PREAMBLE_SIZE)`得出。这里，`partial_packet->offset`表示当前重组结果中的有效数据量（含HCI-ACL头）。因此，`projected_offset`的含义是：整合当前HCI-ACL数据包后的重组结果中的有效数据量（包括HCI-ACL头）。

2. **截断处理**：如果`projected_offset`大于根据首个HCI-ACL碎片内容计算出的完整重组长度（含HCI-ACL头），则需要对当前HCI-ACL碎片的内容进行截断（Line 211 ~ Line 219），以确保其长度合法。通过内存复制操作，将当前HCI-ACL碎片的内容整合到重组结果中（Line 211 ~ Line 212）。最后，完成相关的清理工作（Line 225 ~ Line 232）。

### 3.3 漏洞原理与初步利用
#### 3.3.1 被减小的内存复制量
在3.2.3节中，处理后续HCI-ACL碎片时，代码段（Line 211 ~ Line 219）的目的是对过大的HCI-ACL碎片进行截断，以便按照首个HCI-ACL碎片所指定的L2CAP PDU大小完成重组。然而，Line 217的代码存在一个bug。

- **无截断情况**：当不存在截断时，`packet->len`包含HCI-ACL头的长度。在Line 221中，`packet->len`减去`packet->offset`（赋值为HCI_ACL_PREAMBLE_SIZE，即4字节）得到的是部分L2CAP PDU的长度，从而复制的内容是当前HCI-ACL碎片中的部分L2CAP PDU。

- **有截断情况**：发生截断时，`packet->len`被更新为：
  \[
  partial_packet->len - partial_packet->offset = 重组结果的预期完整长度（含HCI-ACL头） - 重组结果已有有效数据的长度（含HCI-ACL头）
  \]
  这个差值表示重组结果中还能容纳的有效数据长度，即后续HCI-ACL碎片中所包含的一部分L2CAP PDU的最大长度。此时，`packet->len`不再包含HCI-ACL头的长度，而是应整合的一部分L2CAP PDU的长度。因此，Line 221中使用`packet->len`减去`packet->offset`的操作变得多余，导致应拷贝的数据量错误地减少了一个HCI-ACL头的长度。

#### 3.3.2 使能overflow
经验表明，内存复制量的减少会导致传输内容丢失，而内存复制量的增加则是导致溢出和一系列攻击的关键。

由于`memcpy`的第三个参数本质上是一个无符号类型，无论传递的具体数值是多少，都会被强制转换为无符号数处理。因此，只需构造使得Line 221处的`packet->len`小于`packet->offset`（即小于4）。例如，令`packet->len`为2，则`memcpy`的第三个参数为-2，强制转换成无符号数为0xfffffffffffffffe，从而产生溢出。

## 四. 漏洞复现
### 4.1 攻击思路
L2CAP有三种格式：非链接格式、面向链接格式和讯号命令格式。其中，单个讯号命令格式的L2CAP数据包中允许携带一个或多个Command。Command的一种形式是echo请求，类似于ping指令，当向某个可达的蓝牙设备发送echo请求时，默认情况下，该设备将返回一个echo回执，其数据内容与echo请求完全相同。

echo请求采用ACL链路层，具有触发漏洞的潜力，我们对其进行构造以达成攻击。

1. **第一步**：考察一个完整的l2cap echo请求包，其格式如下：
   - L2CAP头中的Length表示后续Command头+Command体的长度。
   - L2CAP头中的CID与L2CAP格式有关，对于讯号命令格式，其值固定为0x02。
   - Command头中的Code表征Command的类型，对于echo请求，其值固定为0x08；而对于echo回执，其值固定为0x09。
   - Command头中的Ident作为请求的标识号，通常是一个逐数据包递增的值。
   - Data含有Command请求体的内容，允许任意设定。

2. **第二步**：将上述请求使用HCI-ACL数据包进行封装，得到两个请求。注意，虽然L2CAP数据包本身进行了拆分，但第一个HCI-ACL碎片所含的L2CAP头中，Length仍是整个Command的长度，即Command头长度 + Command请求体第1部分长度 + Command请求体第2部分长度。

3. **第三步**：通过构造，使得第一个HCI-ACL碎片中，L2CAP头中的Length为Command请求体第1部分长度 + 2。这样一来，正确情况下，第二个HCI-ACL碎片中Command请求体第2部分的长度应为2。然而，我们故意将第二个HCI-ACL碎片的长度（通过HCI-ACL头中的Length表征）设定为大于2，从而触发截断，使得前述`memcpy`的第三个参数变为unsigned(2 – 4) = 0xfffffffffffffffe。

### 4.2 代码片段
为方便读者进一步理解4.1中的攻击思路，笔者书写了以下代码片段，这些代码实测能够达到预期攻击目的。

1. **第一个HCI-ACL碎片的构造与发送**
   - 结合上节的图解不难理解其行为。

2. **第二个HCI-ACL碎片的构造与发送**
   - 结合上节的图解不难理解其行为。

3. **程序自身的正确性验证**
   - 发送一个Command体由8个A字符和8个B字符组成的正常echo数据包，若程序思路无误，则预期返回一个内容相同的echo回执包。

4. **发动攻击**
   - 在第一个HCI-ACL分片的L2CAP头中，将Command体第2部分的大小设定为2，却按照实际大小8进行发送，从而触发截断，达成攻击。

### 4.3 效果演示
1. **正常发送echo数据包时**，使用程序对返回的l2cap数据包内容进行打印，效果如下图所示。
   - 打码部分是笔者手机（Android 8.0）的蓝牙地址。对于程序输出，09为Command中的Code，表征这是一个echo回执包；8个41即8个A字符；8个42即8个B字符。
   - 由此，我们的发包成功触发了手机蓝牙的echo回执，程序自身的正确性得以证明。

2. **发送攻击包时**，观察手机状态，发现蓝牙守护进程崩溃，攻击成功。

## 五. 总结
至此，本系列的第一篇《CVE-2020-0022 蓝牙漏洞初探（上）一个bug引发的血案》结束了。本篇从蓝牙简介开始，逐步深入，阐述了L2CAP层与HCI-ACL层之间数据包的分段与重组，分析了相关代码，阐述了漏洞细节，并以实例加以演示，成功触发了漏洞。

然而，至此我们仅达到了令蓝牙守护进程崩溃的效果。下一步，笔者会为大家带来利用CVE-2020-0022漏洞泄露被攻击目标内存内容的原理与实例，以进一步揭开其神秘面纱。

## 参考文献
[此处添加参考文献]