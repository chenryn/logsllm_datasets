180），该结构除BT_HDR头部外，其余部分大小为full_length字节，用于存放各HCI-ACL数据包的重组结果（含HCI-ACL头）。
在为partial分配空间后，
① 将partial_packet->len设定为full_length，以记录完整重组结果的大小（含HCI-ACL头）（Line 183）；
② 将partial_packet->offset标记为packet->len，以记录此次整合之后，重组结果中所含的有效数据量（含HCI-ACL头）（Line 184）；
③ 通过内存复制，将当前HCI-ACL碎片的内容整合到partial中（Line 186）。
**3.2.3 后续HCI-ACL碎片的处理**
若当前HCI-ACL数据包是相应L2CAP PDU的后续碎片，其相关处理流程如笔者所绘制的下图所示。
继数据包的初步解析后，若当前HCI包为后续碎片（Line 197），则计算projected_offset为partial_packet->offset +
(packet->len –
HCI_ACL_PREAMBLE_SIZE)。由前述内容，partial_packet->offset为当前重组结果的有效数据量；于是，projected_offset的语义为：以完整地整合当前HCI-ACL数据包为前提，所得的重组结果中的有效数据量（包括HCI-ACL头）。
若projected_offset大于根据首个HCI-ACL碎片内容计算所得的完整重组长度（含HCI-ACL头），则对当前HCL-ACL碎片的内容进行截断（Line 211 ~ Line 219），确保当前HCL-ACL长度合法。  
通过内存复制，将当前HCL-ACL碎片的内容整合到重组结果之中。（Line 211 ~ Line 212），再完成相关清理工作（Line 225 ~
Line 232）。
###  3.3 漏洞原理与初步利用
**3.3.1 被减小的内存复制量**
3.2.3节对后续HCL-ACL碎片的处理中，Line 211 ~ Line 219的目的在于：要对过大的当前HCL-ACL碎片进行截断，以便按照首个HCL-ACL碎片所指定的L2CAP PDU大小完成重组。然而，Line 217的代码是存在bug的。
当不存在截断时，packet->len的长度是包含HCI-ACL头的，Line
221中减去packet->offset（被赋值为HCI_ACL_PREAMBLE_SIZE，即4字节）得到的是对应的部分L2CAP
PDU的长度，从而，复制的内容为当前HCI-ACL碎片中的部分L2CAP PDU。
然而，发生截断时，packet->len被更新为：
partial_packet->len – partial_packet->offset  
= 重组结果的预期完整长度（含HCI-ACL头）- 重组结果已有有效数据的长度（含HCI-ACL头）  
= 重组结果中还能容纳的有效数据长度  
= 后续HCI-ACL碎片中所包含的一部分L2CAP PDU的最大长度
注意，这使packet->len的语义发生了变化，它不再包含HCI-ACL头的长度，而是应当进行整合的一部分L2CAP PDU的长度，于是，Line
221使用packet->len减去packet->offset成为了多余的操作，使得应当拷贝的数据量错误地减少了一个HCI-ACL头的长度。
**3.3.2 使能overflow**
经验表明，内存复制量的减少会导致传输内容的丢失，而内存复制量的增加才是导致overflow和一系列攻击的关键。
有趣的是，memcpy的第三个参数本质上是一个unsigned的类型，即，无论传递的具体数值是多少，该参数都会被memcpy当作强制转换成无符号数处理。
于是，只需构造使得Line
221处的packet->len小于packet->offset，即小于4。例如，令其为2，则memcpy的第三个参数为-2，强制转化成无符号数为0xfffffffffffffffe，使得产生overflow。
## 四. 漏洞复现
###  4.1 攻击思路
L2CAP有三种格式：非链接格式（Connectionless）、面向链接格式（Connection-oriented）和讯号命令格式（Signaling
Command）。其中，单个讯号命令格式的L2CAP数据包中允许携带1个或多个Command。Command有多种形式，其一为echo请求。echo请求类似于我们常用的ping指令，当向某个可达的蓝牙设备并发送echo时，默认地，该设备将返回一个echo回执，其数据内容与echo请求完全相同。
echo请求采用ACL链路层，有触发漏洞的潜力，我们对其进行构造以达成攻击。
① 第一步，我们考察一个完整的l2cap echo请求包，笔者将其格式绘制如下。
其中，L2CAP头中的Length即后续Command头+Command体的长度；L2CAP头中的CID与L2CAP格式有关，对于讯号命令格式，其值固定为0x02。
Command头中的Code表征Command的类型，对于echo请求，其值固定为0x08；而对于echo回执，其值固定为0x09；Command头中的Ident作为请求的标识号，一般地，是一个逐数据包递增的值。
Data则含有Command请求体的内容，允许任何设定。
② 第二步，我们将上述请求使用HCI-ACL数据包进行封装，得到两个请求，笔者将其绘制如下。
注意，虽然L2CAP数据包本身进行了拆分，但第一个HCI-ACL碎片所含的L2CAP头中，Length仍是整个Command的长度，即Command头长度
+ Command请求体第1部分长度 + Command请求体第2部分长度。
③ 第三步，通过构造，使得第一个HCI-ACL碎片中，L2CAP头中的Length为Command请求体第1部分长度 +
2。这样一来，正确情况下，第二个HCL-ACL碎片中Command请求体第2部分的长度应为2。然而，我们故意将第二个HCL-ACL碎片的长度（通过HCL-ACL头中的Length表征）设定为大于2，从而触发截断，使得前述memcpy的第三个参数变为unsigned(2 – 4) =
0xfffffffffffffffe。
###  4.2 代码片段
为方便读者进一步理解4.1中的攻击思路，笔者书写了如下代码片段，这些代码实测能够达到预期攻击目的，详见下一节。
① 第一个HCI-ACL碎片的构造与发送
其中，结合上节的图解不难理解其行为。
② 第二个HCL-ACL碎片的构造与发送
其中，结合上节的图解不难理解其行为。
③ 程序自身的正确性验证
其中，我们发送一个Command体由8个A字符和8个B字符组成的正常echo数据包，若程序思路无误，则预期返回一个内容相同的echo回执包。
④ 发动攻击
其中，我们在第一个HCL-ACL分片的L2CAP头中，将Command体第2部分的大小设定为2，却按照实际大小8进行发送，从而触发截断，达成攻击。
###  4.3 效果演示
① 正常发送echo数据包时，使用程序对返回的l2cap数据包内容进行打印，效果如下图所示。
其中，打码部分是笔者手机（Android
8.0）的蓝牙地址。对于程序输出，09为Command中的Code，表征这是一个echo回执包；8个41即8个A字符；8个42即8个B字符。
由此，我们的发包成功触发了手机蓝牙的echo回执，程序自身的正确性得以证明。
② 发送攻击包时，观察手机状态，有，
由此，我们的发包导致了蓝牙守护进程进行预期之外的memcpy，使得进程崩溃。攻击成功。
## 五. 总结
至此，本系列的第一篇《CVE-2020-0022 蓝牙漏洞初探（上）一个bug引发的血案》结束了。本篇从蓝牙简介开始，逐步深入，阐述了L2CAP层与HCL-ACL层之间数据包的分段与重组，分析了相关代码，阐述了漏洞细节，并以实例加以Demo，成功触发了漏洞。
然而，至此我们仅仅达到了令蓝牙守护进程崩溃的效果，而且，0xfffffffffffffffe作为memcpy的第三个参数，似乎意味着一个十分缓慢的操作，难以在用户无察觉的前提下加以利用，当然，这并非事实，细节暂且不表。下一节中，笔者会为大家带来利用CVE-2020-0022漏洞泄露被攻击目标内存内容的原理与实例，以进一步揭开其神秘的面纱。
## 参考文献