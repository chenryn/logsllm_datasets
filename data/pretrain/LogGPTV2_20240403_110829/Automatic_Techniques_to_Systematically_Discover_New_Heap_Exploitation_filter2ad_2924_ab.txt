for the in-use and freed chunks [23].
binning to explore multiple size groups of an allocator. For
example, if we just uniformly pick a size in the 264 space, the
probability of choosing the smallest size group in ptmalloc2
(fd) into a properly encoded location and a backward
pointer (P->bk) into a desired value, attackers can achieve
arbitrary writes (see, P->fd->bk = P->bk). Due to the preva-
lence of double-linked lists, this technique was used for many
allocators, including dlmalloc, ptmalloc2, and even the Win-
/* (1) checking if size == the next chunk’s prev_size */
malloc_printerr("corrupted double-linked list");
malloc_printerr("corrupted size vs. prev_size");
FD = P->fd;
BK = P->bk;
/* (2) checking if prev/next chunks correctly point */
1 #define unlink(AV, P, BK, FD)
2
3 ⋆ if (chunksize(P) != prev_size(next_chunk(P)))
4 ⋆
5
6
7
8 ⋆ if (FD->bk != P || BK->fd != P)
9 ⋆
10 ⋆ else {
11
12
13
14 ⋆ }
FD->bk = BK;
BK->fd = FD;
...
\
\
\
\
\
\
\
\
\
\
\
\
\
sz : any non-fast-bin size
dst: where to write (void*)
val: target value
// [PRE-CONDITION]
//
//
//
// [BUG] buffer overflow (p1)
// [POST-CONDITION] *dst = val
void *p1 = malloc(sz);
void *p2 = malloc(sz);
struct malloc_chunk *fake = p1;
// bypassing (1): P->size == next_chunk(P)->prev_size.
// If fake_chunk->size = 0, next_chunk(fake)->prev_size
// will point to fake->prev_size. By setting both values
// zero, we can bypass the check. These assignements
// can be ommitted since heap memory is zeroed out at
// first time of execution.
fake->prev_size = fake->size = 0;
// bypassing (2): P->fd->bk == P && P->bk->fd == P
fake->fd = (void*)&fake - offsetof(struct malloc_chunk, bk);
fake->bk = (void*)&fake - offsetof(struct malloc_chunk, fd);
struct malloc_chunk *c2 = raw_to_chunk(p2);
// it shrinks the previous chunk’s size,
// tricking ‘fake’ as the previous chunk
c2->prev_size = chunk_size(sz) \
(a) Security checks introduced since glibc 2.3.4 and 2.26. Two
security checks first validate two invariants (see, comments above)
before unlinking the victim chunk (i.e., P).
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
// [BUG] overflowing p1 to modify c2’s size:
// tricking the previous chunk freed, P=0
c2->size &= ~1;
// triggering unlink(fake) via backward consolidation
free(p2);
assert(p1 == (void*)&p1 - offsetof(struct malloc_chunk, bk));
// writing with p1: overwriting itself to dst
*(void**)(p1 + offsetof(struct malloc_chunk, bk)) = dst;
// writing with p1: overwriting *dst with val
*(void**)p1 = (void*)val;
assert(*dst == val);
- offsetof(struct malloc_chunk, fd);
(b) The unsafe unlink exploitation in glibc 2.26
Figure 2: The unlink macros and an exploit abusing the mechanism
in glibc 2.26. Compared to old glibc, two security checks have
been added in glibc 2.26. The first one hardens the off-by-one
overflow, and the second one hardens unlinking abuse. Even though
the security checks harden the attack, it is still avoidable.
dows allocator [1].
To mitigate this attack, allocators have added the new se-
curity check shown in Figure 2a, which turns out to be insuf-
ficient to prevent more advanced attacks. The check verifies
an invariant of a double-linked list that a backward pointer of
a forward pointer of a chunk should point to the chunk (i.e.,
P->fd->bk == P) and vice versa. Therefore, attackers cannot
make the pointer directly refer to arbitrary locations as before
since the pointer will not hold the invariant. Even though the
check prevents the aforementioned attack, attackers can avoid
this check by making a fake chunk to meet the condition, as
1114    29th USENIX Security Symposium
USENIX Association
Abbr. Description
Name
FD
Fast bin dup
UU
Unsafe unlink
HS
House of spirit
PN
Poison null byte
HL
House of lore
OC
Overlapping chunks
HF
House of force
UB
Unsorted bin attack
HE
House of einherjar
Unsorted bin into stack
UBS
House of unsorted einherjar HUE
UDF
Unaligned double free
Overlapping small chunks
OCS
FDO
Fast bin into other bin
Corrupting a fast bin freelist (e.g., by double free or write-after-free) to return an arbitrary location
Abusing unlinking in a freelist to get arbitrary write
Freeing a fake chunk of fast bin to return arbitrary location
Corrupting heap chunk size to consolidate chunks even in the presence of allocated heap
Abusing the small bin freelist to return an arbitrary location
Corrupting a chunk size in the unsorted bin to overlap with an allocated heap
Corrupting the top chunk to return an arbitrary location
Corrupting a freed chunk in unsorted bin to write a uncontrollable value to arbitrary location
Corrupting PREV_IN_USE to consolidate chunks to return an arbitrary location that requires a heap address
Abusing the unsorted freelist to return an arbitrary location
A variant of house of einherjar that does not require a heap address
Corrupting a small bin freelist to return already allocated heap
Corrupting a chunk size in a small bin to overlap chunks
Corrupting a fast bin freelist and use malloc_consolidate() to return an arbitrary non-fast-bin chunk
New
✓
✓
✓
✓
✓
Table 4: Modern heap exploitation techniques from recent work [17] including new ones found by ARCHEAP in ptmalloc2 with abbreviations
and brief descriptions. For brevity, we omitted tcache-related techniques.
in Figure 2b. Compared to the previous one, the check makes
the exploitation more complicated, but still feasible.
3 Heap Abstract Model
In this section, we discuss our heap abstract model, which
enables us to describe a heap exploit technique independent
from an underlying allocator. Here, we focus on an adver-
sarial model, omitting obvious heap APIs (i.e., malloc and
free) for brevity. Note that this abstraction is consistent with
related work [17, 58].
3.1 Abstracting Heap Exploitation
Our model abstracts a heap technique in two aspects: 1)
types of bugs (i.e., allowing an attacker to divert the program
into unexpected states), and 2) impact of exploitation (i.e.,
describing what an attacker can achieve as a result). This
section elaborates on each of these aspects.
1) Types of bugs. Four common types of heap-related bugs
instantiate exploitation:
• Overflow (OF): Writing beyond an object boundary.
• Write-after-free (WF): Reusing a freed object.
• Arbitrary free (AF): Freeing an arbitrary pointer.
• Double free (DF): Freeing a reclaimed object.
Each of theses mistakes of a developer allows attackers
to divert the program into unexpected states in a certain
way: overflow allows modification of all the metadata (e.g.,
struct malloc_chunk in Figure 1) of any consequent chunks;
write-after-free allows modification of the free metadata
(e.g., fd/bk in Figure 1), which is similar in spirit to use-after-
free; double free allows violation of the operational integrity
of the internal heap metadata (e.g., multiple reclaimed point-
ers linked in the heap structure); and arbitrary free similarly
breaks the operational integrity of the heap management but
in a highly controlled manner—freeing an object with the
crafted metadata. Since overflow enables a variety of paths
for exploitation, we further characterize its types based on
common mistakes and errors by developers.
• Off-by-one (O1): Overwriting the last byte of the next
consequent chunk (e.g., when making a mistake in size
calculation, such as CVE-2016-5180 [31]).
• Off-by-one NULL (O1N): Similar to the previous type,
but overwriting the NULL byte (e.g., when using string
related libraries such as sprintf).
It is worth noting that, unlike a typical exploit scenario that
assumes arbitrary reads and writes, we exclude such primi-
tives for two reasons: They are too specific to applications
and execution contexts, hardly meaningful for generalization,
and they are so powerful for attackers to launch easier attacks,
demotivating use of heap exploitation techniques. Therefore,
such powerful primitives are considered one of the ultimate
goals of heap exploitation.
2) Impact of exploitation. The goal of each heap exploita-
tion technique is to develop common types of heap-related
bugs into more powerful exploit primitives for full-fledged
attacks. For the systematization of a heap exploit, we catego-
rize its final impact (i.e., an achieved exploit primitive) into
four classes:
• Arbitrary-chunk (AC): Hijacking the next malloc to
• Overlapping-chunk (OC): Hijacking the next malloc
to return a chunk inside a controllable (e.g., over-
writable) chunk by an attacker.
• Arbitrary-write (AW): Developing the heap vulnerabil-
ity into an arbitrary write (a write-where-what primitive).
• Restricted-write (RW): Similar to arbitrary-write, but
with various restrictions (e.g., non-controllable “what”,
such as a pointer to a global heap structure).
return an arbitrary pointer of choice.
Attackers want to hijack control by using these exploit primi-
tives combined with application-specific execution contexts.
For example, in the unsafe unlink (see, Figure 2), attackers
can develop heap overflow to arbitrary writes and corrupt
code pointers to hijack control.
3.2 Threat Model
To commonly describe heap exploitation techniques, we clar-
ify legitimate actions that an attacker can launch. First, an
attacker can allocate an object with an arbitrary size, and
free objects in an arbitrary order. This essentially means
that the attacker can invoke an arbitrary number of malloc
calls with an arbitrary size parameter and invoke free (or not)
in whatever order the attacker wishes. Second, the attacker
can write arbitrary data on legitimate memory regions (i.e.,
USENIX Association
29th USENIX Security Symposium    1115
the payload in Figure 1 or global memory). Although such
legitimate behaviors largely depend on applications in theory,
assuming this powerful model lets us examine all potential
opportunities for abuses. Third, the attacker can trigger only a
single type of bug. This limits the capabilities of the adversary
to the realistic setting. However, we allow multiple uses of
the same type to simulate a re-triggerable bug in practice. We
note that it is always more favorable to an attacker if a heap
exploit technique requires fewer capabilities than what are
described here, and in such cases, we make a side note for
better clarification.
4 Technical Challenges
Our goal is to automatically explore new types of heap ex-
ploitation techniques given an implementation of any heap
allocator—its source code is not required like AFL [75]. Such