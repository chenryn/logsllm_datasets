Ž
Ŷ
Ž
ŝ
ƚ
Đ
Ă
ƌ
Ĩ
Ɛ
Ŷ
Ž
ŝ
ƚ
Đ
Ƶ
ƌ
ƚ
Ɛ
Ŷ
ŝ


Ğ
ƌ
Ž
ƚ
Ɛ

Ĩ
Ž
Ŷ
Ž
ŝ
ƚ
Đ
Ă
ƌ
Ĩ
Ϭ
ϭϬϬϬϬ
ϱϬϬϬϬ
ƵƉƉĞƌďŽƵŶĚŽŶŶƵŵďĞƌŽĨǁƌŝƚĂďůĞŽďũĞĐƚƐ
ϯϬϬϬϬ
ϮϬϬϬϬ
ϰϬϬϬϬ
ϲϬϬϬϬ
Figure 5. Cumulative distribution of the fraction of
store instructions versus the upper bound on the
number of objects writable by each instruction.
because the write checks fail when a guard is about to be
overwritten. This type of attack is very common.
The write checks do not detect buffer overﬂows and un-
derﬂows inside an object. For example, they will not detect
an overﬂow of an array inside a C structure that overwrites
a function pointer, a data pointer, or some security-critical
In the ﬁrst two cases, WIT
data in the same structure.
can prevent the attacker from successfully exploiting this
type of overﬂow because the indirect call checks severely
restrict the targets of indirect calls and because the write
checks may prevent writes using the corrupt data pointer.
Overﬂows inside objects are not detected by any of the
backwards-compatible C bounds checkers [25, 37, 21] and
unlike WIT they have no additional checks to prevent suc-
cessful exploits.
The write checks prevent all attacks that attempt to over-
write objects with color zero or code. Since objects have
color zero by default, this includes many common types of
attacks. For example, return addresses, saved base pointers,
and exception handler pointers in the stack all have color
zero. Other common attack targets like the import address
table (IAT), which is used for dynamic linking, also have
color zero. The write checks prevent the attacker from mod-
ifying code because the colors assigned to indirect call tar-
gets are different from the colors assigned to unsafe objects
and the rest of the code has color zero.
WIT can prevent corruption of the heap management
data structures used by the standard allocator in Windows
without any changes to the allocator code. The checks
on free prevent corruption due to incorrect use of free,
and the write checks prevent corruption by unsafe aligned
writes because the data structures have color one or zero.
However, writes that are not aligned may overwrite the ﬁrst
few bytes of the heap metadata after an object. Misaligned
writes generate exceptions in many architectures but they
are allowed in the x86. We can prevent corruption in all
cases by adding eight bytes of padding at the end of each
heap object. In most applications, this adds little space and
time overhead but it can add signiﬁcant overhead in applica-
tions with many small allocations. This overhead may not
be justiﬁed because most programs avoid misaligned writes
for portability and performance, and the Windows allocator
can detect corrupt heap meta-data when it tries to use it.
Control-ﬂow integrity provides an effective second line
of defense when the write checks fail to detect an attack.
The number of attacks that violate control-ﬂow integrity
also depends on the precision of the points-to analysis. In
the experiments described above, the maximum number of
indirect call targets with the same color is 212 for gap, 38
for vortex and below 7 for all the other applications.
Even if the analysis assigned the same color to all indi-
rect call targets, an attacker that corrupted a function pointer
could only invoke one of these targets. Furthermore, these
targets do not include functions in dynamically linked li-
braries that are invoked indirectly though the IAT. These
library functions have color zero and we do not check these
indirect calls because the IAT is protected by our write
checks. Therefore, the attacker cannot use a corrupt func-
tion pointer to transfer control to library code, to injected
code, or to other addresses in executable memory regions.
This makes it hard to launch attacks that subvert the in-
tended control ﬂow, which are the most common.
WIT does not prevent out-of-bounds reads. These can
lead to disclosure of conﬁdential data but it is hard to ex-
ploit them to execute arbitrary code without violating write
integrity or control-ﬂow integrity in the process. We ran ex-
periments using the same checks that we used for writes to
prevent most out-of-bounds reads. Since the extra checks
could increase overhead by more than a factor of three, we
decided that the extra overhead did not justify the security
improvement for most applications.
7. Experimental evaluation
We ran experiments to evaluate the overhead of our WIT
implementation and its effectiveness at preventing a broad
range of real and synthetic attacks. This section presents
our results. WIT detects all the attacks in our tests and its
CPU and memory overhead are low.
7.1. Overhead on CPU benchmarks
In our ﬁrst experiment, we measured the overhead added
by WIT to 9 programs from the SPEC CPU 2000 bench-
mark suite [40] (gzip, vpr, mcf, crafty, parser, gap, vortex,
bzip2 and twolf) 3, and to 9 programs from the Olden [12]
benchmark suite (bh, bisort, em3d, health, mst, perimeter,
power, treeadd, and tsp). We chose these programs to facil-
itate comparison with other techniques that have been eval-
uated using the same benchmark suites.
We compared the running time and peak physical mem-
ory usage of the programs compiled using Phoenix [30]
with and without WIT’s instrumentation. We compiled the
programs with options -O2 (maximize speed), -fp:fast (fast
ﬂoating point model), and -GS- (no stack guards). When
building WIT binaries, we linked with our runtime and with
a WIT-instrumented version of libc (see Section 5). We ran
the experiments on Windows Vista Enterprise, on an idle
Dell Optilex 745 Workstation with a 2.46GHz Intel Core 2
processor and 3GB of memory. For each experiment, we
present the average of 3 runs; the variance was negligible.
Figures 6 and 7 show the CPU overhead on SPEC and
Olden benchmarks with WIT. For SPEC, the average over-
head is 10% and the maximum is 25%. For Olden, the av-
erage overhead is 4% and the maximum is 13%. It is hard
to do deﬁnitive comparisons with previous techniques be-
cause they use different compilers, operating systems and
hardware, and they prevent different types of attacks. How-
ever, we can compare WIT’s overhead with published over-
heads of other techniques on SPEC and Olden benchmarks.
3We did not run gcc, eon, and perlbmk because our prototype compiler
cannot compile these benchmarks yet.
йWhŽǀĞƌŚĞĂĚĨŽƌt/d
ŐǌŝƉ
ǀƉƌ ŵĐĨ
ĐƌĂĨƚǇ ƉĂƌƐĞƌ ŐĂƉ ǀŽƌƚĞǆ ďǌŝƉϮ ƚǁŽůĨ
Figure 6. CPU overhead on SPEC benchmarks.
йWhŽǀĞƌŚĞĂĚĨŽƌt/d
ϯϬ
Ϯϱ
ϮϬ
ϭϱ
ϭϬ
ϱ
Ϭ
ϭϰ
ϭϮ
ϭϬ
ϴ
ϲ
ϰ
Ϯ
Ϭ
йŵĞŵŽƌǇŽǀĞƌŚĞĂĚĨŽƌt/d
ŐǌŝƉ
ǀƉƌ ŵĐĨ
ĐƌĂĨƚǇ ƉĂƌƐĞƌ ŐĂƉ ǀŽƌƚĞǆ ďǌŝƉϮ ƚǁŽůĨ
Figure 8. Memory overhead on SPEC benchmarks.
йŵĞŵŽƌǇŽǀĞƌŚĞĂĚĨŽƌt/d
Ϯϱ
ϮϬ
ϭϱ
ϭϬ
ϱ
Ϭ
ϭϴ
ϭϲ
ϭϰ
ϭϮ
ϭϬ
ϴ
ϲ
ϰ
Ϯ
Ϭ
ďŚ
ďŝƐŽƌƚ
ĞŵϯĚ
ŚĞĂůƚŚ
ŵƐƚ
ƉĞƌŝŵĞƚĞƌ
ƉŽǁĞƌ
ƚƌĞĞĂĚĚ
ƚƐƉ
ďŚ
ďŝƐŽƌƚ
ĞŵϯĚ
ŚĞĂůƚŚ
ŵƐƚ
ƉĞƌŝŵĞƚĞƌ
ƉŽǁĞƌ
ƚƌĞĞĂĚĚ
ƚƐƉ
Figure 7. CPU overhead on Olden benchmarks.
Figure 9. Memory overhead on Olden benchmarks.
For example, CCured [33] reports a maximum overhead of
87% and an average of 28% for Olden benchmarks, but it
slows down some applications by more than a factor of 9.
The bounds checking technique in [21] has an average over-
head of 12% and a maximum overhead of 69% in the Olden
benchmarks. WIT has three times lower overhead on aver-
age and the maximum is ﬁve times lower.
Figures 8 and 9 show WIT’s memory overhead on SPEC
and Olden benchmarks. The overhead is low for all bench-
marks. For SPEC, the average memory overhead is 13%
and the maximum is 17%. For Olden, the average is 13%
and the maximum is 16%. This overhead is in line with our
expectations: since WIT uses one byte in the color table for
each 8 bytes of application data, the memory overhead is
close to 12.5%. The overhead can decrease below 12.5%
because we do not set color table entries for safe objects.
On the other hand, the overhead can grow above 12.5% be-
cause we insert guard objects and pads between unsafe ob-
jects, but the results show that this overhead is small.
It
is interesting to compare this overhead with previous tech-
niques even though they have different coverage. For ex-
ample, CCured [33] reports an average memory overhead
of 85% for Olden and a maximum of 161%. Xu et al. [45]
report an average increase of memory usage by a factor of
4.31 for Olden benchmarks and 1.59 for SPEC benchmarks.
We also compiled the SPEC and Olden benchmarks with
a version of WIT that adds 8 bytes of padding at the end of
each heap object to protect heap metadata from hypothetical
corruption by misaligned writes. The average time to com-
plete the SPEC benchmarks increases from 10 to 11% and
the average memory overhead increases from 13 to 15%.
The average time to complete the Olden benchmarks in-
creases from 4 to 7% and the average memory overhead
increases from 13 to 63%. The overhead increases signif-
icantly in the Olden benchmarks because there are many
small allocations. As we discussed earlier, we do not be-
lieve the increased security justiﬁes the extra overhead.
7.2. Overhead on a Web server
The benchmarks used in the previous sections are CPU-
intensive. They spend most time executing instrumented
code at user level. The overhead of our instrumentation
is likely to be higher in these benchmarks than in other
programs where it would be masked by other overheads.
Therefore, we also measured the overhead added by our in-
strumentation to the NullHttpd Web server running the
SPEC WEB 1999 [40] benchmark.
The server ran on a Dell Optilex 745 Workstation with
an Intel Core 2 CPU at 2.4GHz and 2GB of RAM, running
Windows Vista Enterprise. We simulated clients using a
Dell Workstation running Windows XP SP2. The machines
were connected by a 100Mbps D-Link Ethernet switch. We
conﬁgured the clients to request only a static 100-byte ﬁle
from the SPEC Web benchmark. We could easily drive
our overhead to zero by requesting large ﬁles, reading them
from disk, or creating processes to generate dynamic con-
tent. But we chose this setting to measure worst case over-
head for Web server performance with WIT instrumenta-
tion. We measured the average response time and through-
put with and without instrumentation and we increased the
number of clients until the server reached peak throughput.
The results are the average of three runs.
When load is low, WIT’s overhead is masked by the time
to send requests and replies across the network. The average
operation response time in an unloaded server (1 client) is
only 0.2% longer with instrumentation than without. When
load is high and the server is saturated, WIT’s overhead in-
creases because the server is CPU-bound in this benchmark.
The overhead increases up to a maximum of 4.8%, which
shows that WIT can be used in production Web servers.
7.3. Synthetic exploits
We ran the benchmark described in [43] that has 18
control-data attacks that exploit buffer overﬂow vulnerabil-
ities. The attacks are classiﬁed according to the technique
they use to overwrite control-data, the location of the buffer
they overﬂow, and the control-data they target. There are
two techniques to overwrite control-data. The ﬁrst over-
ﬂows a buffer until the control-data is overwritten. The sec-
ond overﬂows a buffer until a pointer is overwritten, and
uses an assignment through the pointer to overwrite the
control-data. The attacks can overﬂow buffers located in
the stack or in the data segment, and they can target four
types of control-data: the return address on the stack, the old
base pointer on the stack, and function pointers and longjmp
buffers in the stack or in the data segment.
WIT can prevent all the attacks in the benchmark. All
the attacks except one are detected when a guard object is
about to be overwritten. The remaining attack is not pre-
vented by the guard objects because it overﬂows a buffer
inside a structure to overwrite a pointer in the same struc-
ture. This attack is detected when the corrupted pointer is
used to overwrite a return address because the return ad-
dress has color zero.
These attacks can be prevented by other techniques, for
example, [37, 28, 6, 13], but these techniques are not widely
used because they have high overhead. StackGuard [20] is
widely deployed because it has low overhead but it does not
prevent attacks that overﬂow non-stack buffers.
7.4. Real vulnerabilities
In our ﬁnal experiment, we tested WIT’s ability to
prevent attacks that exploit real vulnerabilities in SQL
server, Ghttpd, Nullhttpd, Stunnel, and libpng.
SQL server is a relational database from Microsoft that
was infected by the infamous Slammer [32] worm. The vul-
nerability exploited by Slammer causes sprintf to over-
ﬂow a stack buffer. We used WIT to compile the SQL server
library with the vulnerability. WIT detects Slammer when
the sprintf function tries to write over the guard object
inserted after the vulnerable buffer.
Ghttpd is an HTTP server with several vulnerabil-
ities [1].
The vulnerability that we chose is a stack
buffer overﬂow when logging GET requests inside a call to
vsprintf. WIT detects attacks that exploit this vulnerabil-
ity when vsprintf tries to write over the guard object at
the end of the buffer.
Nullhttpd is another HTTP server. This server has a
heap overﬂow vulnerability that can be exploited by send-
ing HTTP POST requests with a negative content length
ﬁeld [2]. These requests cause the server to allocate a heap
buffer that is too small to hold the data in the request. While
calling recv to read the POST data into the buffer, the server
overwrites the heap management data structures maintained
by the C library. This vulnerability can be exploited to over-
write arbitrary words in memory. We attacked NullHttpd
using the technique described in [15]. The attack works by
corrupting the CGI-BIN conﬁguration string. This string
identiﬁes a directory holding programs that may be exe-
cuted while processing HTTP requests. Therefore, by cor-
rupting it, the attacker can force NullHttpd to run arbi-
trary programs. This is a non-control-data attack because