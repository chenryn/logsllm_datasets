并在进程的生存期内使用（实际上基于某些寄存器状态的排序）。这意味着一旦内核调用
定函数调用相同的canary值。
·canary不能保护放置在它之前的本地变量免予溢出攻击。
·在一个多处理器的系统上，也许可以溢出攻击相邻页并在stackcanary检查完成前执行
完攻击代码。如果shellcode将环境恢复得足够完整，那么canary值将在被检查前恢复
原状。
请注意，尽管在编写本书时stackcanary保护变得越来越流行，但是它在许多操作系统上
仍然不普及（或者说默认情况下没有打开）。
董写本地变量
在之前列出的绕过stackcanary保护的选项时，提到了重写本地变量的可能性。事实上，
需要恢复栈状态以使函数安全返回。
这个技术背后的理念是在栈中找到一些重要的变量，从而把栈溢出转化成另一种缺陷。常
见情况包括（但不仅限于此）：
·重写稍后将被复制的指针，此后缺陷将转移到任意的读写中（这取决于该指针如何使用）。
·重写一个已保存的整数值（可能预先计算），产生一个整数问题。
竞态条件
在内核态中的共享资源比比皆是。无论是何种类型的共享资源，内核都需要能够准确地获
取和释放它们。
注意我们在“执行阶段”部分恢复步骤中详细讨论过锁，所以在此不再讨论它们。
---
## Page 76
第3章成功内核利用进阶67
一次错误的释放锁可以导致相关的资源永远都不再可用，或者可能更糟糕的是：在内核检
所获得的资源以致所有的进程都处于等待状态）。一次错误的获取锁可以导致大量的崩溃性问
题和漏洞，因为正持有锁的内核任务期望也依赖于被它锁定的资源。一个类似的情况在没有正
确设计锁定机制的时候发生了。一个典型的例子就是：一个从进程列表中挂起并且优先改变的
进程留下了一个打开的窗口。对于一个小小的时间窗口，黑客能够控制（例如，依附于编译）
一个即将获得优先级的进程（此处与黑客的控制无关）。值得一提的是：锁定机制的误用不只是
竞态条件的唯一源头，一个典型的例子就是TOCTOU（检查时间点、使用时间点），这是一类
包含验证和并发用户态数据访问的漏洞。在这样的问题发生时，内核路径从用户态装载和验证
一些变量，之后再次装载时将不会进行重复验证。我们将会在第4章和第6章提供成功地利用
这种漏洞的实例。
的例子）或者由不同的路径在交错模式的CPU上执行。竞态条件总是在SMP系统中得到利用；
尽管如此，有时候窗口很小，竞态可能很难胜出，结果只有一个竞态条件的子集在UP系统中
被利用。每一次竞态的关键点是提升成功的概率。这是本章的主要内容。
抢占内核和调度程序
第1章介绍了调度程序，它是调度大量任务进出CPU的入口。因为竞态条件的主要目标
是在窗口关闭前执行，所以了解用户态和内核态任务的交互与调度程序之间的关系就变得极为
重要。获取CPU执行路径有两种情景：
·自动放弃CPU，直接调用调度程序。例如，有一些阻塞的锁。进程试图去获取锁，但是
锁是不可用的，所以不选择等待，而是将自己置于睡眠状态并且唤醒调度程序去调度其
他的进程。一个类似的情况就是在等待一个稀有资源变为可用的时候：例如，为了竞争
1/0资源从硬盘上读入一些期望的页。
·调度程序将其从CPU中置出，例如，当任务与时间片相连或者CPU分配量失效时。这
是调度程序例行公事的行为，也是在用户眼中，操作系统为何在处理多任务的时候依然
有比较好的响应能力的原因。如果内核路径可以在执行的时候将CPU让给其他的进程，
我们称这种内核为可抢占的。
在这一点上，如果一个新的任务或进程被唤醒，那么就会给这个进程分配一个新的CPU
信号量。了解接下来要执行的是什么进程很重要，从竞态利用的角度来说，就是使调度程序执
行并选择一个新的进程开始运行。
调度程序运用不同的度量方法来选择接下来要执行的进程，它们中的一些会直接受用
户态影响。操作系统通常在创建进程的时候给每一个进程赋予一个优先级。调度程序在选
择下一个CPU的使用者的时候可以考虑这个优先级以便进行选择。一个进程通常需要更高
种CPU的多个敏感进程不会同时处于活动状态的环境），在恰当的时候降低优先级可能会
影响一些调度进程的选择并允许您利用一个竞争窗口。这在试图在UP系统上利用竞态的时
---
## Page 77
68第一部分内核态
候尤其重要，因为利用调度程序恰当地与您的进程进行交互，这是在第一时间产生这个问
题的唯一方法。
在SMP系统中有更多的方法（这些方法理论上可以制造任何竞态条件利用）。通过绑定不
同的进程到不同的CPU上（一个操作经常是在无优先级的任务上执行）并且使用更高精度的计
时器来同步它们的执行。绑定一个进程到CPU上意味着这个进程将会只能在这个特定的CPU
上去竞争资源，而在其他的CPU竞争中移除了这个进程。这样有利于在调度选择中隔离进程而
不能彼此进行交互。
向内核询问时间信息有很多种方法，但是由于需要更高的精度，所以不能给内核额外的负
担。我们再一次利用了这个架构。为了保持本书的一致性，我们将会展示一个如何使用x86-64
架构的例子。
x86-64架构提供了通往内部时钟的通道，TSC（时间戳计算器）是一个64位机器特有的
寄存器，在每次机器重置的时候设置为0，在每个时钟周期轮转的时候更新。没有权限的用户
态进程可以依靠RDTSC（读TSC）指针取得这个寄存器中的变量，这个指针复制了32个TSC
指针（时间戳不可用）。由于TSC在用户态应用程序中被利用，所以在写时任何一个操作
系统都做不到这一点。
漏洞利用技术
根据临界区的特性，有3种主要的内核竞态机制集。我们将要按照复杂程度的顺序提出这
些场景。也就是说，一种技术在第一种情况下工作成功的话，第二种情况下也会工作成功。下
述的技术是基于更有根据的假设，所以更具有效性和可靠性。
不能重新安排临界区
在这种情况下，当临界区执行的时候，是不能调用调度程序的。这种情况经常发生在竞态
条件遇到一个deferred函数或者一个中断/异常处理器时。在这种情况下，内核控制路径由于
种种原因不能重新安排：它已经请求了一个锁，它正在处理中断（因此没有后台进程睡眠来让
出CPU资源），或者抢占机制临时无效。这种竞态是最难利用的，因为没有调度程序参与。它
只能在SMP系统上并且使用高精度的定时器时才能被利用。当决定要用哪一个定时器的延迟
值去同步用户进程的时候，需要将CPU的频率和到达两个竞态临界区的平均时间等参数考虑进
去。如果开发设计适当，它能持续到窗口被利用。通常使用竞态条件更容易，因为直到所有条
件满足时内核状态才不会受影响。
临界区可以董新安排但是不能访问用户态
在系统调用内核路径的时候，请求进入内核竞态条件执行，这可能是最普通的场景了。这
样的情况通常在UP系统中也是可利用的，而且在SMP系统中也有更多的机会。研究这些漏洞
的一个关键点就是关注调度进程是如何使用的。如果能够使得路径自动放弃CPU，那么就有了
---
## Page 78
第3章成功内核利用进阶69
利用这个漏洞的机会。这种情况通常会影响一些和阻塞相关的功能模块。例如，内存分配程序
在没有内存处于可用状态的时候就会被阻塞。在用户态的应用程序中请求和激活大量的内存就
可以得到这样的机会。
如果需要调度程序去终止当前正在运行的进程，那么这个漏洞就只能在内核抢占的UP
系统中利用。内核抢占在今天已经成为一种趋势，而调度程序机制已经被越来越多的用户态
进程所抛弃。在这里我们要重点讨论的是使用已经基本完成了时间片的内核路径来进入临界
区，并拥有一个CPU敏感的用户态应用程序操纵CPU去执行竞态条件。而且，高精度的时
钟计数器在同步多进程或线程中充当了一个决定者的角色。在SMP系统中，这些问题的利用
以了。
临界区访问用户态
这是到自前为正最容易利用的竞态条件漏洞。当内核路径访问用户态的时候，可以将它置
于睡眠状态，之后扩大可利用窗口的尺寸。无论什么时候访问用户态的缓冲区，即使内核执行
绑定的用户或地址空间模型的时候也不能轻易地终正您的访问。第一，需要检查地址是否低于
有限的独立地址空间。第二，需要确认用户态的映射是否合法，这样在试图访问它的时候就不
会出错。此外，内核需要保证此地址在用户的有效地址空间中，并且下一页已经存在或者已经
转换到硬盘上。例如，一个进程可能会请求内核将一个文件映射到内存中。在这种状况下，内
核将会创建一个与这个文件一样大的有效的映射，但是内核不会用该文件的内容来分配物理内
存页。如果（只是如果）进程试图读取这个文件中的某一页，内核将会反映出这个错误并从硬
盘上载入期望页。这个过程是我们在第1章提到的查询页的方法的核心。
1）映射一个文件到内存中或者映射匿名内存的部分空间。
2）将我们的内核缓冲区置于两页的分界处一一页确认被映射，而将另一页移出分页。
3）使内核路径访问边界上的缓冲区，并且在分页错误处理器去获取第二页的时候将其置
为休眠状态。
4）调度我们的线程并产生竞态。
我们提到了将第二页移出内存，可以通过研究操作系统内核缓存执行机制来完成这个功
能。在通常情况下，这意味着需要预测访问后要移入内存的页数（操作系统会本着尽量移入更
迫使这些页面移到硬盘上去（例如，执行很多满足页面缓存的操作），或者将我们说的方法中
的两个结合起来使用。
我们将会在第4、5、6章中提供一些这类利用的实例。
信息收集阶段
信息收集阶段涉及所有的漏洞利用前的操作，即代码要去收集来自环境的信息。在这个阶
段，注意以下几点：
---
## Page 79
70第一部分内核态
·不要迷失目标这是内核利用的规则。信息收集阶段允许您在运行时决定是否要继续
漏洞利用阶段。例如：想象一下在利用一个正在回收的内核结构，然后要对已破坏
的函数指针解引用。在一个未测试的内核版本上，这个指针的相对位置可能会发生
变化，在这种情况下，应该检测这个位置，然后给出一个停止的机会以保证您有时
间来检查这个特定版本，然后返回一个工作版本。作为一般规则，失败比迷失目标
好。一个发生迷失的目标是一个丢失的目标。（机器会关机，并且目标对象会发出很
大噪声。）
·简化利用过程换句话说，利用系统提供的任何信息可以为shellcode获得一个更
好、更安全的切入点。也就是说可以在内核层任意写。可以尝试写一些看起来依赖
于测试的地址。如果系统能够告诉您在哪儿写，那么将更加方便。但是如果系统不
配合（即在一些内核保护机制面前），那么底层架构能够反映这些信息将是更酷的
事情。
很明显，这两个优势是紧密相连的。第二条充许写一个能够作用于多种目标的一次性内核
利用，因此可降低机器死机的几率。尽可能多地去验证收集的信息很重要。例如：有一个任意
写的问题，并且能够推测出其目的地址。在一个用户态/内核态地址空间相结合的环境下，您
至少要与用户态/内核态地址空间相分离的情况进行对比检查。此外，如果希望这个地址存在
详细描述典型的内核布局）。
到自前为正，涉及的信息都来自于坏境。它不依赖于内核漏洞，而是简单地依赖于对架构
及接口的利用。然而，还有一个更大潜在的信息来源一信息泄露bug。经典的信息泄露bug
在内核层具有任意读权限。您可以从用户态读取部分内核内存。通常，信息泄露只是简单地将
不应暴露的信息输出到用户态。另一个例子，考虑一个栈中的结构分配，初始化了一些成员变
量，然后将其复制回用户态。在这种情况下，未初始化的成员变量的死栈就泄露到了用户态。
这样的问题通常会被低估，因为在一些情况下它们并不会直接导致一个内核利用。但这是一个
非常不好的习惯：尤其对于那些有着高级内核级保护的系统，一个简单的信息泄露会给攻击者
提供一次性可靠的内核利用入口。
注意因为本地内核利用比远程内核利用要普遍得多，本章剩余的部分会主要集中在
本地信息收集上。我们会在第7章涉及远程信息收集与远程利用技术。
环境告诉我们什么
让我们以所处的环境能提供的信息来开始对信息收集方法的分析。即使操作系统以一定程
度的硬化方法向用户态暴露大量的信息。对正确执行合法用户态的应用程序来说，这其中的一
些是强制要求的（知道内核分离地址在哪儿，或者正在运行的操作系统是哪个版本）：有些对
于用户调试问题很有帮助（将加载的特定模块列出，并显示正在使用的机器资源）：一部分由
架构暴露（就像我们之前在讨论竞态条件时TSC/RDTSC例子中提到的）：很多都被低估了，
比如弱保护（堆对象在内核中分配的数量、内核符号清单）。
---
## Page 80
第3章成功内核利用进阶71
仅几条看似无关或无用的信息就可以用来提高漏洞利用的成功几率，这真的很有趣。
操作系统告诉我们什么
我们可以很容易从系统中获得的第一条信息就是当前运行的内核的确切版本。内核是不
口）有些是内部的，因而各个版本会有所差异；而在已发布的正式版本中，（结构和接口）有
些会被提及或者遗漏。在这种情况下，即使发布有细微差别的同一种内核，可能也需要不同的
shellcode和方法。例如，某个特定的Windows服务包可能会遗漏同一个漏洞内核路径绑定的一
个API，或者两个不同的Linux内核之间存在的一个次要的版本号不匹配就要使用完全不同的
内部权限存储结构。所有的操作系统都提供一个用户登录接口以查询特定的内核版本。本书的
第二部分将对这些逐一讨论。
另一条有意思的信息（特别是关于模块化的内核）是，加载了什么样的模块，以及通常
可用的模块有哪些（通常是一些较大的模块）。同样，几乎所有的操作系统都提供了一种方法
的虚拟地址和大小。如果您正为漏洞利用寻找特定的偏移量，这些信息可能会派上用场。如
果此信息被过滤掉（存在额外安全保护的情况下常会发生的事情），而您的目标只是检测某个
特定的模块是否可用，则可以从其保存的目录中列出（甚至读取）可用的模块。此外，现在
几乎所有的操作系统都使用了自动排序的模块加载器，以便在系统真正需要时加载某个特定
模块。基于这个属性，我们可以通过简单地生成权限请求，强制从用户态加载一个漏洞或者
有用的模块。
继续讨论搜集信息问题。在几乎所有的UNIX上都有一个程序将内核日志缓冲区打印到控
制台：dmes9。同样，这个缓冲区可能含有重要价值的信息，如有效的虚拟地址范围或者模块
调试信息。由于这些原因，MacOSX“打破了”UNIX的这一传统，这可以防止非权限用户通
过复制内核控制缓冲区来制作安全保护补丁程序，如Linux上的GRSecurity。
从中我们可以推断出的最有趣的一类信息就是内核在内存中的布局信息，特别是关键结构
或文本（可执行的二进制映像）映射的地址。获取这条信息的一个简单（同时令人惊讶且有效
的）方式是寻找磁盘上的内核二进制映像。在许多系统里，管理者会忘记从该文件中剥离“未
果回想一下高级内核技术，您就会知道这些信息至关重要。我们不仅能够访问所有符号（函
数、变量以及段标识符）的值/地址，还能够看到每个信息的分解。换言之，我们可以推断一
个特定的功能或操作码序列在内存中的位置。
如果内核的二进制映像不可用（例如，因为它处于启动后将会卸载的启动分区或是系统管
理员正确地改变了它的权限），则我们可以转向内核导出的信息。事实上，通过虚拟设备或文件
（如Linux那样，通过/proc/kallsyms）让内核导出一列符号表到用户态权限是很普遍的做法。同
样，通过简单解析这个文件，可以发现内核里的任何结构或函数的地址。让我们通过一个例子
看看该文件如何更好地阐释这一概念：
---
## Page 81
72第一部分内核态
c084e7adr__kstrtab_hrtimer_forward
c084e7bdr-kstrtab_ktime_get_ts
c084e7car_kstrtab_ktime_get_rea1
c084e7d9r__kstrtab_ktime_get
c084e7e3r__kstrtab_downgrade_write
c084e7f3r-kstrtab_up_write
c084e7fcr_kstrtab_up_read
c084e804r__kstrtab_down_write_tryiock
c084e817r-_kstrtab_down_write
c084e822r_kstrtab_down_read_try1ock
c084e834r-kstrtab_down_read
c084e83er-kstrtab_srcu_batches_completed
c084e855r__kstrtab_synchronize_srcu
c084e866r-_kstrtab_srcu_read_un1ock
c084e877r_kstrtab_srcu_read_1ock
c084e886r_kstrtab_cleanup_srcu_struct
如例中所示，每个符号左边是其地址。即使该源丢失，我们也仍然有办法找出内核符号的
布局，该布局基于复制其他位置的目标环境。这种方法对于闭源操作系统如Windows很奏效
（由于知道确切的内核版本和使用的补丁程序，所以它可能重新创建一个相同的映像）；对于不