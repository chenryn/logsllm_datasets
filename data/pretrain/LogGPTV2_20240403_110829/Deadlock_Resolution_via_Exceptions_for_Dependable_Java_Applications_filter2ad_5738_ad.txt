62         Thread er = new Thread(HG, ER, "TimerResolver");
63         dr.setPriority(Thread.MAX_PRIORITY); 
64         er.setPriority(Thread.MAX_PRIORITY);
65         dr.start();  er.start();
66         new Thread(DG, new Manager(jp,1,100),"manager").start();
67         new Thread(DG, new Worker(jp,500),"worker").start(); }}
Figure 3. A manager-worker example
on the information collected and in order to get more in-
formation, programmers can then use various customized
managers and workers in a regulated way. For example,
programmers can have a manager assign some jobs, stop the
manager, and then have a worker take jobs. Programmer can
also try job pools of different sizes, e.g. they can try a job
pool of size 1, and then a job pool of size 2, etc. Sooner or
later, programmers should get to know that if the job pool is
once full, no more jobs can be assigned, no matter whether
or not some jobs are ever taken from the job pool after it
is full. After the bug is identiﬁed, programmers can regu-
late the manager’s behavior to prevent this deadlock from
occurring. Speciﬁcally, programmers can add “while (jp.c()
== (jp.s()-1)) Thread.yield();” to the beginning of line 23 in
Figure 3. This indicates that the job pool accommodates at
most size-1 jobs.
Without deadlock exceptions, experienced programmers
may also ﬁgure out the bug. But it would be difﬁcult. For
example, without the help of deadlock exceptions, it is hard
to know that the manager receives notiﬁcations from the
worker when the job pool size is 1. Knowing this fact is
important to locate the bug to the condition of whether jobs
can be assigned.
The strength of the techniques is that programmers can
know deadlock states by examining the exception objects
and can take further actions to collect more information af-
ter the program is deadlocked. This technical strength also
helps programmers identify false positives. The next sub-
section uses an example to show how to deal with positives.
4.3. Dealing with false positives
During the execution of code in Figure 3, it is possible
that the manager(the worker, resp.) is too slow, so that the
worker(the manager, resp.) waits an excessive long time,
and a DeadEnd exception is thrown because the timer ex-
pires. However, such a DeadEnd exception represents a
false positive. Thus, as a reaction to the false positive, the
global deadlock handler (line 47-53) installed for Timer-
Resovler can simply double the timeout value provided the
timeout value is not huge already. Line 48-53 shows the
implementation of the reaction.
It is worthwhile to emphasize that line 45: “ try {
Thread.currentThread().join(t);}” in Figure 3 is the key to
support the timer-based exceptions. The value t is the ac-
tual argument for the TIMEOUT parameter of the deadlock
detection engine.
In a more complex system, the value of t can be deter-
mined with the help of DeadEnd. Speciﬁcally, to strike
a good balance between the number of false positives and
deadlock detection latencies, the current value of t can
be set to the maximum of some elements in the ﬁeld
AV INTERVALS of DeadEnd, which is described in sub-
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:08:07 UTC from IEEE Xplore.  Restrictions apply. 
section 3.2. The threads corresponding to the elements used
to determine t are reported via DeadEnd, but, from program-
mers’ perspective, they are unlikely deadlocked at current
time point.
5. Implementation: programming effort and
runtime performance
I constructed an initial implementation in a Latte 0.9.1
JVM to support exceptions for deadlocks with notiﬁcations
and locks being the only resource types, and I used this im-
plementation to run and test the examples in section 4. Latte
is a JVM containing an effective jit compiler, an on-demand
exception handing mechanism and a lightweight monitor
implementation [10]. Currently Latte only works on top
of SPARC, and it has its own thread package implemented
inside the JVM. Programming effort and runtime perfor-
mance are two important properties of any implementation.
Below I examine these two properties.
5.1. Programming Effort
Only slight changes were made to the Latte JVM in order
to support the deadlock exceptions: I touched only 5 ﬁles,
and added/modiﬁed less than 1000 lines of code. As essen-
tially only the thread package and the exception-handling
module need to be slightly modiﬁed to support deadlock
exceptions, the techniques used to support deadlock excep-
tions can be easily adapted to other JVMs (using native
threads).
5.2. Runtime performance
As deadlocks rarely occur in reasonable programs, the
total time spent on creating and throwing deadlock excep-
tions for real-life programs is usually small. During pro-
grams’ execution, the main performance overhead for sup-
porting deadlock exceptions is the deadlock detection en-
gine which implements the method proposed in subsection
2.3. The current implementation assumes all DELTA values
to be 0. Support for positive DELTA values will be provided
in a future implementation.
For convenience, I use deadlock exceptions to refer to
corresponding deadlocks. DeadKnot(with DeadCycle as
a special case) is detected by the knot detection solution,
DeadEnd is detected by the timer-based solution, and Dead-
Lock is detected by the blocked-group-based solution. The
order of deadlock detection is as follows: DeadCycle detec-
tion is before DeadKnot detection, which in turn is before
DeadLock detection; DeadEnd detection is triggered by a
timer. Below I ﬁrst discuss the worst-case cost to detect the
four types of deadlocks, and then examine the frequency to
trigger their detection. In the discussion, n is used to denote
the number of threads involved, and locks and notiﬁcations
are the only resource types.
Costs of deadlock detection procedures:
• DeadEnd It takes O(n) to detect a DeadEnd: all
blocked threads have to be checked to see if they have
been waiting for an excessive long time.
• DeadCycle It takes O(n) to detect a DeadCycle: a
thread can have at most one outstanding lock request at
one time, and a lock can be held by at most one thread
at one time.
• DeadKnot As all DELTA values are 0, it takes O(n) to
detect a DeadKnot: DELTA being 0 makes any node in
the dependency graph have at most one outgoing edge,
thus all nodes in a knot are always on a cycle.
• DeadLock It takes a small constant time to detect a
DeadLock: the only operation is to check if the num-
ber of currently alive threads in a group is equal to the
number of blocked threads in that group.
Frequencies of triggering deadlock detection:
• DeadEnd Only a timer expiration will trigger detec-
tion of DeadEnd exceptions. The timeout value of the
timer is an adjustable parameter and is usually large,
so it is infrequent for the timer to expire.
• DeadCycle Only a contended lock request, which
means a request for a lock already held by a thread
other than the requesting thread, will trigger detection
of DeadCycle. [7] claims that lock contention is rare
in well-tuned programs since lock contention is usu-
ally due to “ multiple threads holding global locks too
long or too frequently.” [7] further reports that dur-
ing one run of mtrt, the only multi-threaded program
in the SPECjvm98 benchmark suite, 11 out of 715244
lock requests are contended requests.
• DeadKnot As all DELTA values are 0, only a con-
tended lock request will trigger DeadKnot detection.
• DeadLock A contended lock request, a wait() invoca-
tion and a thread termination will trigger detection of
DeadLock. Because the use of multiple threads is to
maximize performance and frequent wait() operations
will hurt performance, it is reasonable to assume that
wait() is not performed frequently. Thread termination
can be relatively frequent in some programs.
Because of the infrequency of contended lock requests,
the number of threads involved in DeadCycle and Dead-
Knot is usually small. Although thread termination may
be relatively frequent, the cost of DeadLock detection is a
small constant. Thus, the overall cost of deadlock detection
is small for reasonable real-life programs.
There are some other overheads in the system. Speciﬁ-
cally, time-varying data structures need to be maintained for
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:08:07 UTC from IEEE Xplore.  Restrictions apply. 
deadlock detection, and useful information need to be kept
for exception generating. Releasing a lock, a wait() invo-
cation, a notify()/notifyAll()/interrupt() invocation, a con-
tended lock request, starting a thread and killing a thread
are all associated with such overheads. These overheads are
cheap: only a small constant time is needed.
Positive DELTA values, although they are easy to sup-
port, are not supported in the current implementation. Pos-
itive DELTA values change the cost of DeadKnot detection
from O(n) to O(n2), and increase the frequency of trigger-
ing DeadKnot detection. However, given proper DELTA
values, n is likely to be small in the O(n2) cost of Dead-
Knot detection for reasonable programs.
Thus, good runtime performance can be achieved with
little implementation effort to support exceptions for dead-
locks with notiﬁcations and locks as the only resource types.
6. Related work
Deadlock detection and recovery have been researched
for a long time. Due to space limit, I only discuss
some work closely related to deadlock resolution for multi-
threaded Java programs.
In most OS textbooks, e.g., [8], a cyclic wait is a neces-
sary condition of deadlock. In [4], a cyclic wait is not nec-
essary and “a deadlock state is a non-ﬁnal global state with
no out transitions.” [3] gives a description of deadlock for
C programs: “Deadlock occurs when a multithreaded pro-
gram is unable to make progress because a thread is wait-
ing for a condition that will never happen.” My pragmatic
deﬁnition of deadlock focuses on the run-time behavior of
individual threads and builds on user-deﬁnable resources,
thus it has an ﬂexible and extensible scope and facilitates
the implementation of a timer-based solution.
Some researchers have built deadlock detection tools for
Java programs, e.g. JCAT [5], Jlint [1] and Rivet [2]. While
these tools aim to achieve good programs by debugging
them, my goal is to make use of bad code. In addition, these
tools cannot handle large-scale Java programs using certain
Java features, e.g. dynamic class loading.
Sun’s J2SE 1.4.1 platform [6], which was released
around September 2002, incorporates a deadlock detection
utility in its Java HotSpot Virtual Machine. The utility can
only reports deadlock involving cyclic wait for locks. My
approach can report various deadlock types involving var-
ious resource types. Furthermore, the utility does not pro-
vide a means for runtime deadlock recovery while my ap-
proach allows programmers to use exception handlers to re-
solve deadlocks.
7. Conclusions and Future Work
This paper presents an approach of deadlock resolution
via exceptions, and shows that it is practical and effective
in developing dependable Java applications containing code
that may deadlock. Future work includes but is not re-
stricted to: 1) to support more resource types, e.g. mem-
ory and RMI messages, and 2) to use a JIT compiler to im-
prove detection precision, to reduce detection latencies and
to semi-automate recovery code generation.
References
[1] C. Artho and A. Biere. Applying Static Analysis to Large-
Scale, Multi-threaded Java Programs. In: D. Grant (Ed.),
Proceedings of the 13th Australian Software Engineering
Conference (ASWEC 2001), pp. 68 - 75, Canberra, Australia,
August 2001. IEEE Computer Society, PR 01254.
[2] Derek Bruening. Systematic Testing of Multithreaded Java
Programs. Master of Engineering Thesis, Massachusetts In-
stitute of Technology, 1999.
[3] Sung-Eun Choi and E Christopher Lewis. A Study of Com-
mon Pitfalls in Simple Multi-Threaded Programs. In Pro-
ceedings of the Thirty-ﬁrst ACM SIGCSE Technical Sympo-
sium on Computer Science Education, March 2000.
[4] James C. Corbett. Evaluating Deadlock Detection Methods
for Concurrent Software. IEEE Transactions on Software
Engineering, 22(3): 161-180, 1996.
[5] C. Demartini, R. Iosif, and R. Sisto. A Deadlock Detection
Tool For Concurrent Java Programs. Software: Practice and
Experience, 29(7): 577-603, 1999.
[6] http://java.sun.com/j2se/1.4.1/changes.html.
[7] Sheng Liang and Deepa Viswanathan. Comprehensive Pro-
ﬁling Support in the Java Virtual Machine. In 5th USENIX
Conference on Object-Oriented Technologies and Systems
(COOTS ’99), pages 229-240, San Diego, CA, May 3-7,
1999.
[8] William Stallings. Operating Systems: Internals and Design
Principles (4th Edition). ISBN: 0130319996, published by
Prentice Hall 2001.
[9] Allan Vermeulen. Java Deadlock. Dr. Dobbs Journal,
September 1997.
[10] Byung-Sun Yang, Soo-Mook Moon, Seongbae Park, Jun-
pyo Lee, SeungIl Lee, Jinpyo Park, Yoo C. Chung, Suhyun
Kim, Kemal Ebcioglu, and Erik Altman. LaTTe: A Java VM
Just-in-Time Compiler with Fast and Efﬁcient Register Al-
location. 1999 International Conference on Parallel Archi-
tectures and Compilation Techniques (PACT99), New Port
Beach, California, October 1999.
[11] Fancong Zeng. Exploiting Runtime Exceptions
and
Static Analyses to Detect Deadlock in Multithreaded
Java Programs. PhD Qualifying Exam presentation,
http://www.dcis.rutgers.edu/cs/general/colloquia, Rutgers
University, August 6, 2002.
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:08:07 UTC from IEEE Xplore.  Restrictions apply.