computation, including the TinyOT protocol [48] for actively se-
cure two-party computation based on Boolean circuits; the actively
secure multi-party computation protocol based on arithmetic cir-
cuits [16]; and the SPDZ protocol [28, 30] for actively and covertly
secure multi-party computation based on arithmetic circuits.
Fairplay, Sharemind and TASTY are MPC frameworks alternative
to FRESCO. Fairplay is a system originally developed to support
two-party computation [46] and then extended to multiparty com-
putation as FairplayMP [15]: Fairplay implements a two party com-
putation protocol in the manner suggested by Yao; FairplayMP is
based on the Beaver-Micali-Rogaway protocol [10]. Sharemind [21]
is a secure service platform for data collection and analysis, employ-
ing a 3-party additive secret sharing scheme and provably secure
protocols in the honest-but-curious security model with no more
than one passively corrupted party. TASTY (Tool for Automating
Secure Two-partY computations) is a tool suite addressing secure
two-party computation in the semi-honest model [37] whose main
feature is to allow the compilation and evaluation of functions using
both garbled circuits and homomorphic encryption.
Holzer et al. [39] present a compiler that uses the bounded model-
checker CBMC to translate ANSI C programs into Boolean circuits.
The circuits can be used as inputs to the secure computation frame-
work of Huang et al. [40]. This compiler, CBMC-GC, can also be
used as a front-end to our verified implementation of Yao’s proto-
col. However, as we show in Section 4, not only does our approach
deliver higher assurance but also, if one activates all optimizations,
the circuits generated by our compiler can offer, for some classes of
circuits, better performace in comparison with the current version
of CBMC-GC (v0.9.3).
Recently, Amy et al. [45] built a compiler that renders Revs [49]
programs into space-efficient reversible circuits. The work focused
on the usage of such circuits in large quantum computations and
was fully developed and verified using F⋆.
6 CONCLUSIONS AND FUTURE WORK
We have presented a fast and efficient software stack for secure
function evaluation. Possible further steps include adapting our ap-
proach to recent developments in multi-party and verifiable compu-
tation, for instance [50], and to achieve tighter integration between
prototyping tools, verification tools, and verified compilers.
Acknowledgments. This work is partially supported by ONR
Grants N000141210914 and N000141512750, by Cátedra PT-FLAD
em Smart Cities & Smart Governance, by Fundação para a Ciên-
cia e a Tecnologia grant FCT-PD/BD/113967/2015, by the ERDF –
European Regional Development Fund through the Operational Pro-
gramme for Competitiveness and Internationalisation - COMPETE
2020 Programme within project «POCI-01-0145-FEDER-006961»,
and by National Funds through the Portuguese funding agency,
FCT - Fundação para a Ciência e a Tecnologia as part of project
«UID/EEA/50014/2013». The EasyCrypt definitions build on early
work by Guillaume Davy. We thank Pierre-Yves Strub for his role
in the development of EasyCrypt.
REFERENCES
[1]
Joseph A. Akinyele, Christina Garman, Ian Miers, Matthew W. Pagano, Michael
Rushanan, Matthew Green, and Aviel D. Rubin. 2013. Charm: a framework for
rapidly prototyping cryptosystems. J. Crypt. Eng. 3, 2 (2013).
José Bacelar Almeida, Manuel Barbosa, Gilles Barthe, and Francois Dupressoir.
2013. Certified computer-aided cryptography: efficient provably secure machine
code from high-level implementations. In ACM CCS.
José Bacelar Almeida, Manuel Barbosa, Gilles Barthe, and François Dupres-
soir. 2016. Verifiable side-channel security of cryptographic implementations:
constant-time MEE-CBC. In 23rd International Conference on Fast Software En-
cryption (FSE). 163–184.
[2]
[3]
[4] Andrew W. Appel. 2014.
Cambridge University Press.
subjects/computer-science/programming-languages-and-applied-logic/
program-logics-certified-compilers?format=HB
Program Logics -
for Certified Compilers.
http://www.cambridge.org/de/academic/
[5] Andrew W. Appel. 2015. Verification of a Cryptographic Primitive: SHA-256.
ACM Trans. Program. Lang. Syst. 37, 2 (2015), 7:1–7:31.
[6] Michael Backes, Matteo Maffei, and Esfandiar Mohammadi. 2010. Computation-
ally Sound Abstraction and Verification of Secure Multi-Party Computations. In
FSTTCS.
[7] Gilles Barthe, François Dupressoir, Benjamin Grégoire, César Kunz, Benedikt
Schmidt, and Pierre-Yves Strub. 2013. EasyCrypt: A Tutorial. In Foundations of
Security Analysis and Design VII (FOSAD). Lecture Notes in Computer Science,
Vol. 8604. Springer International Publishing, 146–166. https://doi.org/10.1007/
978-3-319-10082-1_6
[8] Gilles Barthe, Cédric Fournet, Benjamin Grégoire, Pierre-Yves Strub, Nikhil
Swamy, and Santiago Zanella-Béguelin. 2014. Probabilistic Relational Verification
for Cryptographic Implementations. In POPL. To appear.
[9] Gilles Barthe, Benjamin Grégoire, Sylvain Heraud, and Santiago Zanella-Béguelin.
2011. Computer-Aided Security Proofs for the Working Cryptographer. In
CRYPTO.
[10] D. Beaver, S. Micali, and P. Rogaway. 1990. The Round Complexity of Secure
Protocols. In Proceedings of the Twenty-second Annual ACM Symposium on Theory
of Computing (STOC ’90). ACM, New York, NY, USA, 503–513. https://doi.org/10.
1145/100216.100287
[11] Mihir Bellare, Viet Tung Hoang, Sriram Keelveedhi, and Phillip Rogaway. 2013.
Efficient Garbling from a Fixed-Key Blockcipher. In IEEE S&P.
Session I4:  Verifying CryptoCCS’17, October 30-November 3, 2017, Dallas, TX, USA2001[12] Mihir Bellare, Viet Tung Hoang, and Phillip Rogaway. 2012. Foundations of
458.
[13] Mihir Bellare and Silvio Micali. 1989. Non-Interactive Oblivious Transfer and
IACR Cryptology ePrint Archive 2005 (2005), 181.
[36] Shai Halevi. 2005. A plausible approach to computer-aided cryptographic proofs.
[37] Wilko Henecka, Stefan Kögl, Ahmad-Reza Sadeghi, Thomas Schneider, and Immo
Wehrenberg. 2010. TASTY: tool for automating secure two-party computations.
In ACM Conference on Computer and Communications Security. ACM, 451–462.
[38] Wilko Henecka, Stefan Kögl, Ahmad-Reza Sadeghi, Thomas Schneider, and Immo
Wehrenberg. 2010. TASTY: Tool for Automating Secure Two-party Computations.
In ACM CCS.
[39] Andreas Holzer, Martin Franz, Stefan Katzenbeisser, and Helmut Veith. 2012.
Secure Two-party Computations in ANSI C. In ACM CCS.
[40] Yan Huang, David Evans, Jonathan Katz, and Lior Malka. 2011. Faster Secure
Two-party Computation Using Garbled Circuits. In USENIX Security.
[41] Vladimir Kolesnikov, Ahmad-Reza Sadeghi, and Thomas Schneider. 2013. A
Systematic Approach to Practically Efficient General Two-Party Secure Function
Evaluation Protocols and their Modular Design. Journal of Computer Security
(JCS) 21, 2 (01 2013), 283–315. https://doi.org/10.3233/JCS-130464 Preliminary
version: http://eprint.iacr.org/2010/079.
[42] Vladimir Kolesnikov and Thomas Schneider. 2008. Improved Garbled Circuit:
Free XOR Gates and Applications. In ICALP.
[43] Xavier Leroy. 2006. Formal certification of a compiler back-end or: programming a
compiler with a proof assistant. In Proceedings of the 33rd ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, POPL 2006, Charleston, South
Carolina, USA, January 11-13, 2006, J. Gregory Morrisett and Simon L. Peyton
Jones (Eds.). ACM, 42–54. https://doi.org/10.1145/1111037.1111042
[44] Yehuda Lindell and Benny Pinkas. 2009. A Proof of Security of Yao’s Protocol
for Two-Party Computation. J. Cryptol. 22, 2 (April 2009).
[45] Rupak Majumdar and Viktor Kuncak (Eds.). 2017. Computer Aided Verification -
29th International Conference, CAV 2017, Heidelberg, Germany, July 24-28, 2017,
Proceedings, Part II. Lecture Notes in Computer Science, Vol. 10427. Springer.
https://doi.org/10.1007/978-3-319-63390-9
[46] Dahlia Malkhi, Noam Nisan, Benny Pinkas, and Yaron Sella. 2004. Fairplay -
Secure Two-Party Computation System. In USENIX Security Symposium, Matt
Blaze (Ed.). USENIX, 287–302. https://www.usenix.org/publications/proceedings/
?f[0]=im_group_audience%3A173
[47] Moni Naor and Benny Pinkas. 2001. Efficient Oblivious Transfer Protocols. In
SODA.
Jesper Buus Nielsen, Peter Sebastian Nordholt, Claudio Orlandi, and Sai Sheshank
Burra. 2012. A New Approach to Practical Active-Secure Two-Party Computation.
In Advances in Cryptology - CRYPTO 2012 - 32nd Annual Cryptology Conference,
Santa Barbara, CA, USA, August 19-23, 2012. Proceedings. 681–700. https://doi.
org/10.1007/978-3-642-32009-5_40
[48]
[49] Alex Parent, Martin Roetteler, and Krysta Marie Svore. 2015. Reversible circuit
compilation with space constraints. CoRR abs/1510.00377 (2015). http://arxiv.
org/abs/1510.00377
[50] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. 2013. Pinocchio:
Nearly Practical Verifiable Computation. In IEEE S&P.
[51] Adam Petcher and Greg Morrisett. 2015. The Foundational Cryptography Frame-
work. In Principles of Security and Trust - 4th International Conference, POST 2015,
Held as Part of the European Joint Conferences on Theory and Practice of Software,
ETAPS 2015, London, UK, April 11-18, 2015, Proceedings (Lecture Notes in Computer
Science), Riccardo Focardi and Andrew C. Myers (Eds.), Vol. 9036. Springer, 53–72.
https://doi.org/10.1007/978-3-662-46666-7_4
[52] Martin Pettai and Peeter Laud. 2014. Automatic Proofs of Privacy of Secure
Multi-Party Computation Protocols Against Active Adversaries. Cryptology
ePrint Archive, Report 2014/240. (2014).
[53] Aseem Rastogi, Matthew A. Hammer, and Michael Hicks. 2014. Wysteria: A
Programming Language for Generic, Mixed-Mode Multiparty Computations. In
IEEE S& P.
[54] Aseem Rastogi, Nikhil Swamy, and Michael Hicks. 2016. WYS*: A Verified
Language Extension for Secure Multi-party Computations. (2016). Manuscript.
[55] Nikhil Swamy, Cătălin Hrit,cu, Chantal Keller, Aseem Rastogi, Antoine Delignat-
Lavaud, Simon Forest, Karthikeyan Bhargavan, Cédric Fournet, Pierre-Yves Strub,
Markulf Kohlweiss, Jean-Karim Zinzindohoué, and Santiago Zanella-Béguelin.
2016. Dependent Types and Multi-Monadic Effects in F*. In 43nd ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages (POPL). ACM, 256–
270. https://www.fstar-lang.org/papers/mumon/
[56] Xiao Wang, Alex J. Malozemoff, and Jonathan Katz. 2017. Faster Secure Two-Party
Computation in the Single-Execution Setting. Springer International Publishing,
Cham, 399–424. https://doi.org/10.1007/978-3-319-56617-7_14
[57] Andrew C. Yao. 1982. Protocols for secure computations. In FOCS.
[58] Cunxi Yu, Walter Brown, Duo Liu, André Rossi, and Maciej Ciesielski. 2016.
Formal Verification of Arithmetic Circuits by Function Extraction. IEEE Transac-
tions on Computer-Aided Design of Integrated Circuits and Systems 35, 12 (2016),
2131–2142. https://doi.org/10.1109/TCAD.2016.2547898
garbled circuits. In ACM CCS.
Applications. In CRYPTO.
[14] Mihir Bellare and Phillip Rogaway. 2006. The Security of Triple Encryption and a
Framework for Code-Based Game-Playing Proofs. In EUROCRYPT (Lecture Notes
in Computer Science), Serge Vaudenay (Ed.), Vol. 4004. Springer, 409–426.
[15] Assaf Ben-David, Noam Nisan, and Benny Pinkas. 2008. FairplayMP: a sys-
tem for secure multi-party computation. In ACM Conference on Computer and
Communications Security. ACM, 257–266.
[16] Rikke Bendlin, Ivan Damgård, Claudio Orlandi, and Sarah Zakarias. 2011. Semi-
homomorphic Encryption and Multiparty Computation. In EUROCRYPT. 169–
188.
[17] Lennart Beringer, Adam Petcher, Katherine Q. Ye, and Andrew W. Appel.
2015. Verified Correctness and Security of OpenSSL HMAC. In 24th USENIX
Security Symposium, USENIX Security 15, Washington, D.C., USA, August 12-
14, 2015., Jaeyeon Jung and Thorsten Holz (Eds.). USENIX Association, 207–
221. https://www.usenix.org/conference/usenixsecurity15/technical-sessions/
presentation/beringer
[18] Karthikeyan Bhargavan, Antoine Delignat-Lavaud, Cédric Fournet, Markulf
Kohlweiss, Jianyang Pan, Jonathan Protzenko, Aseem Rastogi, Nikhil Swamy,
Santiago Zanella-Béguelin, and Jean Karim Zinzindohoué. 2016. Implementing
and Proving the TLS 1.3 Record Layer. Cryptology ePrint Archive, Report
2016/1178. (2016). http://eprint.iacr.org/2016/1178.
[19] Bruno Blanchet. 2008. A Computationally Sound Mechanized Prover for Security
Protocols. IEEE Trans. Dependable Sec. Comput. 5, 4 (2008).
[20] Bruno Blanchet. 2012. Security Protocol Verification: Symbolic and Computa-
tional Models. In POST.
[21] Dan Bogdanov, Sven Laur, and Jan Willemson. 2008. Sharemind: A Framework
for Fast Privacy-Preserving Computations. In ESORICS.
[22] Sally Browning and Philip Weaver. 2010. Designing Tunable, Verifiable Crypto-
graphic Hardware Using Cryptol. (2010).
[23] Randal E. Bryant. 1992. Symbolic Boolean Manipulation with Ordered Binary-
Decision Diagrams. ACM Comput. Surv. 24, 3 (1992), 293–318. https://doi.org/10.
1145/136035.136043
[24] David Cadé and Bruno Blanchet. 2013. Proved Generation of Implementations
from Computationally Secure Protocol Specifications. In POST.
[28]
[27]
[25] Brent Carmer and Mike Rosulek. 2016. Linicrypt: A Model for Practical Cryptog-
raphy. In Advances in Cryptology - CRYPTO 2016 - 36th Annual International Cryp-
tology Conference, Santa Barbara, CA, USA, August 14-18, 2016, Proceedings, Part III
(Lecture Notes in Computer Science), Matthew Robshaw and Jonathan Katz (Eds.),
Vol. 9816. Springer, 416–445. https://doi.org/10.1007/978-3-662-53015-3_15
[26] Morten Dahl and Ivan Damgård. 2014. Universally Composable Symbolic Analy-
sis for Two-Party Protocols Based on Homomorphic Encryption. In EUROCRYPT.
Ivan Damgård, Kasper Damgård, Kurt Nielsen, Peter Sebastian Nordholt, and
Tomas Toft. 2016. Confidential Benchmarking based on Multiparty Computation.
In Financial Cryptography 2016. In print.
Ivan Damgård, Marcel Keller, Enrique Larraia, Valerio Pastro, Peter Scholl, and
Nigel P. Smart. 2013. Practical Covertly Secure MPC for Dishonest Majority -
Or: Breaking the SPDZ Limits. In ESORICS. 1–18.
Ivan Damgård, Jesper Buus Nielsen, Michael Nielsen, and Samuel Ranellucci.
2016. Gate-scrambling Revisited - or: The TinyTable protocol for 2-Party Secure
Computation. IACR Cryptology ePrint Archive 2016 (2016), 695. http://eprint.iacr.
org/2016/695
Ivan Damgård, Valerio Pastro, Nigel P. Smart, and Sarah Zakarias. 2012. Mul-
tiparty Computation from Somewhat Homomorphic Encryption. In CRYPTO.
643–662.
[31] Yael Ejgenberg, Moriya Farbstein, Meital Levy, and Yehuda Lindell. 2012. SCAPI:
The Secure Computation Application Programming Interface. Cryptology ePrint
Archive, Report 2012/629. (2012).
[32] Cédric Fournet, Chantal Keller, and Vincent Laporte. 2016. A Certified Compiler
for Verifiable Computing. In IEEE 29th Computer Security Foundations Symposium,
CSF 2016, Lisbon, Portugal, June 27 - July 1, 2016. IEEE Computer Society, 268–280.
https://doi.org/10.1109/CSF.2016.26
[30]
[29]
[33] Cédric Fournet, Markulf Kohlweiss, and Pierre-Yves Strub. 2011. Modular code-
based cryptographic verification. In ACM CCS.
[34] Martin Franz, Andreas Holzer, Stefan Katzenbeisser, Christian Schallhart, and
Helmut Veith. 2014. CBMC-GC: An ANSI C Compiler for Secure Two-Party
Computations. In Compiler Construction - 23rd International Conference, CC
2014, Held as Part of the European Joint Conferences on Theory and Practice of
Software, ETAPS 2014, Grenoble, France, April 5-13, 2014. Proceedings (Lecture
Notes in Computer Science), Albert Cohen (Ed.), Vol. 8409. Springer, 244–249.
https://doi.org/10.1007/978-3-642-54807-9_15
[35] Adam Groce, Alex Ledger, Alex J. Malozemoff, and Arkady Yerukhimovich.
2016. CompGC: Efficient Offline/Online Semi-honest Two-party Computation.
Cryptology ePrint Archive, Report 2016/458. (2016). http://eprint.iacr.org/2016/
Session I4:  Verifying CryptoCCS’17, October 30-November 3, 2017, Dallas, TX, USA2002The top level abstraction that represents two-party protocols is
given in Figure 11. Two parties want to compute a functionality
f on their joint inputs, each obtaining their share of the output.
This may be done interactively via a protocol prot that may make
use of additional randomness (passed in explicitly for each of the
parties) and produces, in addition to the result, a conversation trace
of type conv that describes the messages publicly exchanged by the
parties during the protocol execution. In addition, the input space
may be restricted by a validity predicate validInputs. This predicate
expresses restrictions on the adversary-provided values, typically
used to exclude trivial attacks not encompassed by the security
definition.
Simulation-based security. Following the standard approach for
secure multi-party computation protocols, security is defined using
simulation-based definitions. In this case we capture honest-but-
curious (or semi-honest, or passive) adversaries. We consider each
party’s view of the protocol (typically containing its randomness
and the list of messages exchanged during a run), and a notion of
leakage for each party, modelling how much of that party’s input
may be leaked by the protocol execution (for example, its length).
Informally, we say that such a protocol is secure if each party’s
view can be efficiently simulated using only its inputs, its outputs
and precisely defined leakage about the other party’s input.
Formally, we express this security notion using two games (one
for each party). We display one of them in Figure 12, in the form of
an EasyCrypt module. Note that modules are used to model games
and experiments, but also schemes, oracles and adversaries.18
18Our formalisation accommodates generic protocols (e.g., oblivious transfer of an
arbitrary, albeit polynomial, number of messages) which justifies the technicality
Modules are composed of a memory (a set of global variables,
here empty) and a set of procedures. Note that procedures in the
same module may share state; it is therefore not necessary to explic-
itly add state to the module signature. In addition, modules can be
parameterized by other modules (in which case, we often call them
functors) whose procedures they can query like oracles. Which ora-
cles may be accessed by which procedure is specified using module
types. A module is said to fulfill a module type if it implements all
the procedures declared in that type. Any procedures implemented
in addition to those appearing in the module type are not accessible
as oracles. For example, even if a module that implements module
type Sim is used to instantiate the S parameter of the Sec1 module,
none of the procedures in Sec1 may call the sim2 oracle.
(i ∈ {1, 2}) tells us that an adversary imper-
sonating Party i is defined by two procedures: i. choose that takes
no argument and chooses a full input pair for the functionality; and
ii. distinguish, that uses Party i’s view of the protocol execution to
produce a Boolean guess as to whether it was produced by the real
system or the simulator. Since the module type is not parameter-
ized, the adversary is not given access to any oracles (modelling a
of parametrising the randomness generation procedures with public information
associated with the protocol inputs.
Module type AdvProt
i
type leak1, leak2.
op ϕ1 : input1 → leak1.
op ϕ2 : input2 → leak2.
type view1 = rand1 ∗ conv.
type view2 = rand2 ∗ conv.
module type Sim = {
proc sim1(i1: input1, o1: output1, l2: leak2) : view1
proc sim2(i2: input2, o2: output2, l1: leak1) : view2
module type Simi = {
proc simi (ii : inputi , oi : outputi , l3−i : leak3−i ) : viewi
}.
}.
module type AdvProt
= {
i
proc choose(): input1 ∗ input2
proc distinguish(v: viewi ) : bool
}.
module Sec1(R1: Rand1, R2: Rand2, S: Sim1, A1: AdvProt
proc main() : bool = {
var real, adv, view1, o1, r1, r2, i1, i2;
(i1,i2) = A1.choose();
real ←$ {0,1};
if (!validInputs i1 i2)
adv ←$ {0,1};
else {
if (real) {
1
) = {
r1 = R1.gen(ϕ1 i1);
r2 = R2.gen(ϕ2 i2);
(conv,_) = prot i1 r1 i2 r2;
view1 = (r1, conv);
} else {
(o1,_) = f i1 i2;
view1 = S.sim1(i1, o1, ϕ2 i2);
}
adv = A1.distinguish(view1);