trace as well as the counts of instructions (“Inst.”) and basic
blocks (“BB”) in the dynamically created CFG of the x86
code.
Our analyzer was able to detect the emulator in all cases:
the table shows information for the extracted bytecode trace,
and we built
the control-ﬂow graph using the extracted
control-ﬂow semantics of the bytecode language. We do not
show the syntax and semantic information of the bytecode
instruction set here because we found that the instruction sets
consistently contain 31 instructions. However, the syntax of
the instructions varied, showing that the instruction sets were
highly randomized. We also manually analyzed the instruc-
tion set and observed that the semantics were very close to
that from Code Virtualizer. This is not surprising given that
both tools are from the same vendor [22] In all samples,
the x86 CFG is very large compared to the corresponding
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
B1223insn: 2B926insn: 5B927insn: 7B730insn: 2B731insn: 7B732insn: 2B756insn: 5B928insn: 5B929insn: 7B734insn: 7B733insn: 2B735insn: 2B736insn: 3B930insn: 5B10insn: 156B11insn: 88B12insn: 56B15insn: 190B13insn: 114B14insn: 161B16insn: 208B7insn: 53B8insn: 113B9insn: 62even though their program sizes and MD5 checksums varied.
After analyzing these malware samples with Rotalum´e, we
found that unlike samples we tested with Themida and
VMProtect, these samples have large portions of their code
converted into bytecode. The bytecode CFGs of these pro-
grams varied signiﬁcantly, showing that they may be quite
different programs even though they share the same name.
6. Discussion
In this section, we discuss three open problems and chal-
lenges: alternative emulator designs, incomplete bytecode
reconstruction, and code analysis limitations.
First, our current work assumes a decode-dispatch emula-
tion model, thus, malware authors may implement variations
or alternative approaches to emulation [5], [16], [19], [30] to
evade our system. For example, our loop identiﬁcation strate-
gies of Section 3.3 are not directly applicable to malware
emulators using a threaded approach. However, the methods
of identifying the candidate bytecode regions and VPC’s are
still applicable. As discussed in Section 2.2, our approach
is likewise not applicable to dynamic translation based
emulation. In dynamic translation, the emulator dynamically
generates new code that the program subsequently executes,
thus, we expect that heuristics used by unpackers to detect
unpacked code will identify the translated instructions. From
the translated code, a system could trace backward to ﬁnd
the translation routines, and it could then utilize our methods
to identify bytecode regions and the VPC. More generally,
we believe that our fundamental ideas and techniques are
applicable to other emulation models: by analyzing an em-
ulator’s execution trace using a given emulation model, we
can identify the bytecode region and discover the syntax and
semantics of the bytecode instructions. The main challenge
in future research is to identify observable and discernible
run-time behavior exhibited by sophisticated emulation ap-
proaches.
Malware using decode-dispatch emulation may attempt
to evade accurate analysis by targeting speciﬁc properties
of our analysis. For example, since our approach expects
each unique address in memory to hold only one abstract
variable, an adversary may utilize the same location for
different variables at different times to introduce imprecision
in our analysis. Our system will put the memory reads
performed using these variables into the same cluster due
to the conservativeness of our analysis. If the additional
data included in the cluster containing the bytecode program
is used in decode or dispatch-like behavior, they may be
incorrectly identiﬁed as bytecode instructions.
The second open problem is how to reconstruct complete
information about the bytecode instruction syntax and se-
mantics, so that a system can extract the entire emulated
malware bytecode program. Using dynamic analysis, we
extracted execution paths in the bytecode program and the
syntax and semantics of the bytecode instructions used
in those paths. However, the paths may not have utilized
all of the possible bytecode instructions supported by the
emulator,
though they may be used in other execution
paths of the program. A plausible approach would apply
static analysis on the dispatch routine once our system has
identiﬁed the emulation phases correctly. More speciﬁcally,
once the dispatching method is identiﬁed, static analysis and
symbolic execution may identify other execution routines
and the opcodes of the bytecode instructions that invoke
their dispatch. This provides the syntactic and semantic
information of the bytecode instructions even though they
are not part of the executed bytecode.
A subsequent open problem is utilizing the discovered
syntax and semantics to completely convert bytecode to
native instructions. A solution is possible only when all
execution paths of the bytecode program can be explored.
A potential solution is to use previous techniques employed
for multi-path exploration [21] with the help of control-ﬂow
semantics identiﬁed in the bytecode. However, emulators
may be written so that speciﬁc control-ﬂow semantics need
not be supported in the bytecode language. Such is the case
for VMProtect, where we have only identiﬁed unconditional
branches. In such bytecode languages, the effects of condi-
tional branches are performed in the program by dynamically
computing the target address based on the condition and
then using an unconditional branch to the speciﬁc target
(an example was provided in Figure 2). More research is
required before multi-path exploration can be applied to
programs written in such languages.
Another related problem is the use of recursive emulation,
which converts the emulator itself to another bytecode
language and introduces an additional emulator to emulate
it. The recursive step can be performed a number of times
by a malware author, with size and performance increases
as the limiting factors. The solution is to ﬁrst apply our
reverse engineering method to the malware instance, use
the discovered syntax and semantics to completely convert
the bytecode program into native binary code, and then
apply our method (recursively) on the converted program
to identify any additional emulation-like behavior.
Third, as with all program analysis tasks, reverse engineer-
ing of emulators also faces the challenges of heap analysis
imprecision, limitations of loop detection, and so on. The
techniques to address these problems are orthogonal to our
techniques in reverse engineering.
7. Related Work
Malware authors have developed obfuscation schemes
designed to impede static analysis [8], [18], [25], [26].
Dynamic analysis approaches that treat malware as a black
box can overcome these obfuscation schemes, but
they
are able to observe only a small number of execution
107
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
paths. Several approaches have been proposed to address
this limitation. Moser et al. proposed a scheme [21] that
explored multiple paths during malware execution. Another
approach [36] forces program execution along different paths
but disregards consistent memory updates. In Rotalum´e,
these solutions are unable to properly analyze emulated
malware because they will explore execution paths of the
emulator rather than that of the bytecode program.
Malware authors have broadly applied packing to im-
pede and evade malware detection and analysis. Several
approaches based on the general unpacking idea have been
proposed [14], [20], [27]. For example, Polyunpack per-
forms universal unpacking based on a combination of static
and dynamic binary analysis. Given a packed executable,
Polyunpack ﬁrst constructs a static view of the code. If the
executable tries to execute any code that is not present in
the static view, Polyunpack detects this as unpacked code.
Recently we observed a new trend in using virtualizers
or emulators such as Themida [24], Code Virtualizer [23],
and VMProtect [35] to obfuscate malware. These emulators
all use a basic interpretation model [31] and transform the
x86 program instructions into its own bytecode in order
to hide the syntax and semantic of the original code and
thwart program analysis. Moreover, by using a randomized
instruction set for the bytecode language together with a
polymorphic emulator, the reverse engineering effort will
have to be applied to every new malware instance, making
it very difﬁcult to reuse the reverse engineered information
of one emulator for another. We argue that this trend will
continue and that a large portion of malware in the near fu-
ture will be emulation based. There is no existing technique
that can reliably counter an emulation-based obfuscation
technique.
Researchers have proposed using a randomized instruction
set with emulation as a software defense against code
injection attacks. Kc et al. [15] and Barrantes et al. [4] de-
veloped approaches that converted a binary program’s native
instructions into a per-process randomized instruction set.
Since an adversary trying to exploit vulnerabilities will not
have knowledge about the random instruction set, injected
code will not run properly and will cause the program to
crash. Subsequent work by Sovarel et al. [32] discussed
the effectiveness of instruction set randomization techniques
against various attacks.
There are research approaches for analysis and reverse
engineering of bytecode for high-level languages such as
Java [9], [33]. However, these approaches assume that the
syntax and semantics of the bytecode are public or already
known. This assumption fails to hold for malware con-
structed using emulators such as Themida, Code Virtualizer,
or VMProtect [23], [24], [35]. These emulators perform a
random translation from bytecode to destination ISA, so the
connection between the bytecode and ﬁnal ISA is unknown.
In order to overcome these emulation-based obfuscation
techniques, we need analyzers that are able to reverse
engineer the emulator model and extract the bytecode syntax
and semantics. This is a new research area. In a related area,
protocol reverse engineering techniques [7], [17], [37] have
been proposed to understand network protocol formats by
automatically extracting the syntax of the protocol messages.
Tupni [10] automatically reverse engineers the formats of
all general inputs to a program. The analysis techniques for
extracting the input or network message syntax assume that
they can be found at predeﬁned locations in the program.
In contrast, one of the main challenges in malware emulator
analysis is to ﬁnd where the bytecode program resides.
8. Conclusion
In this paper, we presented a new approach for automatic
reverse engineering of malware emulators. We described
the algorithms and techniques to extract a bytecode trace
and compute the syntax and semantics of the bytecode
instructions by dynamically analyzing a decode-dispatch
based emulator. We developed Rotalum´e, a proof-of-concept
system, and evaluated it on synthetic and real programs ob-
fuscated with Code Virtualizer and VMProtect. The results
showed that Rotalum´e was able to extract bytecode traces
and syntax and semantic information. For future work, we
plan to address the challenges of reverse engineering other
types of emulators. We also plan to develop algorithms to
extract higher level instruction semantics that include data-
ﬂow information, and to completely convert an extracted
bytecode trace back to x86 form. We hope that our work
will help spawn research in several other related areas, such
as reverse engineering of script interpreters.
Acknowledgments
The authors would like to thank Paul Royal for providing
the malware samples that were used in our experiments and
the anonymous reviewers for their constructive feedback.
This material is based upon work supported in part by the
National Science Foundation under grants no. 0716570 and
0831300 and the Department of Homeland Security under
contract no. FA8750-08-2-0141. Any opinions, ﬁndings, and
conclusions or recommendations expressed in this material
are those of the authors and do not necessarily reﬂect the
views of the National Science Foundation or the Department
of Homeland Security.
References
[1] A. Aho, M. Lam, R. Sethi, and J. Ullman. Compilers—
Principles, Techniques, & Tools. Addison Wesley, 2006.
[2] Avira Antivirus. http://www.free-av.com. Last accessed Mar.
6, 2009.
108
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
Mar. 6, 2009.
[23] Oreans Technologies: Code Virtualizer. http://www.oreans.
com/codevirtualizer.php. Last accessed Mar. 6, 2009.
[24] Oreans Technologies: Themida. http://www.oreans.com/. Last
accessed Mar. 6, 2009.
Heavens, 2003.
[25] S. Pearce. Viral polymorphism.
Technical report, VX
[26] I. V. Popov, S. K. Debray, and G. R. Andrews. Binary
In Proceedings of the USENIX
obfuscation using signals.
Security Symposium, 2007.
[27] P. Royal, M. Halpin, D. Dagon, R. Edmonds, and W. Lee.
PolyUnpack: Automating the hidden-code extraction of
In Proceedings of the Annual
unpack-executing malware.
Computer Security Applications Conference (ACSAC), 2006.
[28] M. Sharif, A. Lanzi, J. Gifﬁn, and W. Lee. Rotalum´e: A
tool for automatically reverse engineering malware emulators.
Technical Report GT-CS-09-05, School of Computer Science,
Georgia Institute of Technology, 2009. http://www.cc.gatech.
edu/research/reports/GT-CS-09-05.pdf.
[29] Silicon Realms. Armadillo/software passport professional.
http://siliconrealms.com/. Last accessed Mar. 6, 2009.
[30] R. L. Sites, A. Chernoff, M. B. Kerk, M. P. Marks, and S. G.
Robinson. Binary translation. Communication of the ACM,
36(2), Feb. 1993.
[31] J. E. Smith and R. Nair. Virtual Machines: Versatile platforms
for systems and processes. Morgan Kaufmann, 2005.
[32] A. N. Sovarel, D. Evans, and N. Paul. Where’s the FEEB? the
effectiveness of instruction set randomization. In Proceedings
of the USENIX Security Symposium, 2005.
[33] R. Stata and M. Abadi. A type system for Java bytecode
subroutines. ACM Transactions on Programming Languages
and Systems (TOPLAS), 21(1), Jan. 1999.
[34] Virus Total. http://www.virustotal.com/. Last accessed Mar.
6, 2009.
[35] VMPsoft VMProtect.
cessed Mar. 6, 2009.
http://www.vmprotect.ru/. Last ac-
[36] J. Wilhelm and T.-c. Chiueh. A forced sampled execution
In Proceedings of
approach to kernel rootkit identiﬁcation.
the International Symposium on Recent Advances in Intrusion
Detection (RAID), 2007.
[37] G. Wondracek, C. Kruegel, and E. Kirda. Automatic network
protocol analysis. In Proceeding of the Annual Network and
Distributed System Security Symposium (NDSS), 2008.
[38] H. Yin, D. Song, M. Egele, C. Kruegel, and E. Kirda.
Panorama: Capturing system-wide information ﬂow for mal-
ware detection and analysis. In Proceedings of the ACM Con-
ference on Computer and Communications Security (CCS),
2007.
[3] G. Balakrishnan and T. Reps. Recovery of variables and
heap structure in x86 executables. Technical Report 1533,
Computer Sciences Department, University of Wisconsin–
Madison, 2005.
[4] E. G. Barrantes, D. H. Ackley, S. Forrest, T. S. Palmer,
D. Stefanovic, and D. D. Zovi. Randomized instruction
set emulation to disrupt binary code injection attacks.
In
Proceedings of the ACM Conference on Computer and Com-
munications Security (CCS), 2003.
[5] J. R. Bell. Threaded code. Communications of the ACM,
16(6), June 1973.
[6] F. Bellard. QEMU, a fast and portable dynamic translator. In
USENIX Annual Technical Conference, 2005.
[7] J. Caballero, H. Yin, Z. Liang, and D. Song.
Polyglot:
Automatic extraction of protocol format using dynamic binary
analysis. In Proceedings of the ACM Conference on Computer
and Communications Security (CCS), 2007.
[8] C. Collberg, C. Thomborson, and D. Low. Manufacturing
cheap, resilient, and stealthy opaque constructs. In Proceed-
ings of the ACM Symposium on Principles of Programming
Languages (POPL), 1998.
[9] J. J. Cook. Reverse execution of Java bytecode. The Computer
Journal, 45(6), 2002.
[10] W. Cui, M. Peinado, K. Chen, H. Wang, and L. Irun-
Briz. Tupni: Automatic reverse engineering of input formats.
In Proceedings of the ACM Conference on Computer and
Communications Security, 2008.
[11] E. H. Debaere and J. M. V. Campenhout. Interpretation and
Instruction Path Coprocessing. MIT Press, Cambridge, MA,
1990.
[12] A. Dinaburg, P. Royal, M. Sharif, and W. Lee.
Ether:
Malware analysis via hardware virtualization extensions. In
Proceedings of the ACM Conference on Computer and Com-
munications Security (CCS), 2008.
[13] The IDA Pro Disassembler and Debugger.
http://www.
hex-rays.com/idapro/. Last accessed Mar. 6, 2009.
[14] M. G. Kang, P. Poosankam, and H. Yin. Renovo: a hidden
code extractor for packed executables. In Proceedings of the
ACM Workshop on Recurring Malcode (WORM), 2007.
[15] G. S. Kc, A. D. Keromytis, and V. Prevelakis. Countering
code-injection attacks with instruction-set randomization. In
Proceedings of the ACM Conference on Computer and Com-
munications Security (CCS), 2003.
[16] P. Klint.
Interpretation techniques. Software Pratice and
Experience, 11(9), Sept. 1981.
[17] Z. Lin, D. Xu, and X. Zhang. Automatic protocol format
reverse engineering through context-aware monitored execu-
tion. In Proceeding of the Annual Network and Distributed
System Security Symposium (NDSS), 2008.
[18] C. Linn and S. Debray. Obfuscation of executable code to
improve resistance to static disassembly. In Proceedings of the
ACM Conference on Computer and Communications Security
(CCS), 2003.
[19] P. S. Magnusson and D. Samuelsson. A compact intermediate
format for SimICS. Technical report, Swedish Institute of
Computer Science, 1994.
[20] L. Martignoni, M. Christodorescu, and S. Jha. OmniUnpack:
Fast, generic, and safe unpacking of malware. In Proceedings
of the Annual Computer Security Applications Conference
(ACSAC), 2007.
[21] A. Moser, C. Kruegel, and E. Kirda. Exploring multiple
execution paths for malware analysis. In Proceedings of the
IEEE Symposium of Security and Privacy, 2007.
[22] Oreans Technologies. http://www.oreans.com/. Last accessed
109
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply.