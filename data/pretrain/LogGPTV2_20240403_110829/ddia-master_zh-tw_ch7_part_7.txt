但是，并发写入间可能发生的竞争条件还没有完。在本节中，我们将看到一些更微妙的冲突例子。
首先，想象一下这个例子：你正在为医院写一个医生轮班管理程式。医院通常会同时要求几位医生待命，但底线是至少有一位医生在待命。医生可以放弃他们的班次（例如，如果他们自己生病了），只要至少有一个同事在这一班中继续工作【40,41】。
现在想象一下，Alice 和 Bob 是两位值班医生。两人都感到不适，所以他们都决定请假。不幸的是，他们恰好在同一时间点选按钮下班。[图 7-8](../img/fig7-8.png) 说明了接下来的事情。
![](../img/fig7-8.png)
**图 7-8 写入偏差导致应用程式错误的示例**
在两个事务中，应用首先检查是否有两个或以上的医生正在值班；如果是的话，它就假定一名医生可以安全地休班。由于资料库使用快照隔离，两次检查都返回 2 ，所以两个事务都进入下一个阶段。Alice 更新自己的记录休班了，而 Bob 也做了一样的事情。两个事务都成功提交了，现在没有医生值班了。违反了至少有一名医生在值班的要求。
#### 写入偏差的特征
这种异常称为 **写入偏差**【28】。它既不是 **脏写**，也不是 **丢失更新**，因为这两个事务正在更新两个不同的物件（Alice 和 Bob 各自的待命记录）。在这里发生的冲突并不是那么明显，但是这显然是一个竞争条件：如果两个事务一个接一个地执行，那么第二个医生就不能歇班了。异常行为只有在事务并发进行时才有可能发生。
可以将写入偏差视为丢失更新问题的一般化。如果两个事务读取相同的物件，然后更新其中一些物件（不同的事务可能更新不同的物件），则可能发生写入偏差。在多个事务更新同一个物件的特殊情况下，就会发生脏写或丢失更新（取决于时序）。
我们已经看到，有各种不同的方法来防止丢失的更新。但对于写入偏差，我们的选择更受限制：
* 由于涉及多个物件，单物件的原子操作不起作用。
* 不幸的是，在一些快照隔离的实现中，自动检测丢失更新对此并没有帮助。在 PostgreSQL 的可重复读，MySQL/InnoDB 的可重复读，Oracle 可序列化或 SQL Server 的快照隔离级别中，都不会自动检测写入偏差【23】。自动防止写入偏差需要真正的可序列化隔离（请参阅 “[可序列化](#可序列化)”）。
* 某些资料库允许配置约束，然后由资料库强制执行（例如，唯一性，外来键约束或特定值限制）。但是为了指定至少有一名医生必须线上，需要一个涉及多个物件的约束。大多数资料库没有内建对这种约束的支援，但是你可以使用触发器，或者物化检视来实现它们，这取决于不同的资料库【42】。
* 如果无法使用可序列化的隔离级别，则此情况下的次优选项可能是显式锁定事务所依赖的行。在例子中，你可以写下如下的程式码：
```sql
BEGIN TRANSACTION;
SELECT * FROM doctors
  WHERE on_call = TRUE
  AND shift_id = 1234 FOR UPDATE;
UPDATE doctors
  SET on_call = FALSE
  WHERE name = 'Alice'
  AND shift_id = 1234;
COMMIT;
```
* 和以前一样，`FOR UPDATE` 告诉资料库锁定返回的所有行以用于更新。
#### 写入偏差的更多例子
写入偏差乍看像是一个深奥的问题，但一旦意识到这一点，很容易会注意到它可能发生在更多场景下。以下是一些例子：
* 会议室预订系统
  比如你想要规定不能在同一时间对同一个会议室进行多次的预订【43】。当有人想要预订时，首先检查是否存在相互冲突的预订（即预订时间范围重叠的同一房间），如果没有找到，则建立会议（请参阅示例 7-2）[^ix]。
  [^ix]: 在 PostgreSQL 中，你可以使用范围型别优雅地执行此操作，但在其他资料库中并未得到广泛支援。
  **例 7-2 会议室预订系统试图避免重复预订（在快照隔离下不安全）**
  ```sql
  BEGIN TRANSACTION;
  -- 检查所有现存的与 12:00~13:00 重叠的预定
  SELECT COUNT(*) FROM bookings
  WHERE room_id = 123 AND
    end_time > '2015-01-01 12:00' AND start_time < '2015-01-01 13:00';
  -- 如果之前的查询返回 0
  INSERT INTO bookings(room_id, start_time, end_time, user_id)
    VALUES (123, '2015-01-01 12:00', '2015-01-01 13:00', 666);
  COMMIT;
  ```
  不幸的是，快照隔离并不能防止另一个使用者同时插入冲突的会议。为了确保不会遇到排程冲突，你又需要可序列化的隔离级别了。
* 多人游戏
  在 [例 7-1]() 中，我们使用一个锁来防止丢失更新（也就是确保两个玩家不能同时移动同一个棋子）。但是锁定并不妨碍玩家将两个不同的棋子移动到棋盘上的相同位置，或者采取其他违反游戏规则的行为。取决于你正在执行的规则型别，也许可以使用唯一约束（unique constraint），否则你很容易发生写入偏差。
* 抢注使用者名称
  在每个使用者拥有唯一使用者名称的网站上，两个使用者可能会尝试同时建立具有相同使用者名称的帐户。可以在事务检查名称是否被抢占，如果没有则使用该名称建立账户。但是像在前面的例子中那样，在快照隔离下这是不安全的。幸运的是，唯一约束是一个简单的解决办法（第二个事务在提交时会因为违反使用者名称唯一约束而被中止）。