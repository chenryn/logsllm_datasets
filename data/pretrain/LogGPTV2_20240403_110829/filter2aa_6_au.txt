[[Value]]
undefined
[[Get]]
undefined
[[Set]]
undefined
[[Writable]]
false
[[Enumerable]]
false
[[Configurable]]
false
当你通过属性描述符（详见下面的一节）创建属性时，这些默认值十分重要。
17.8.2 属性描述符
属性描述符是用于编程处理特性的一种数据结构。它是一个编码属性特性的对象。每个描述符的属性对应一个特性。例如，下面是一个只读属性的描述符，该属性的值是123：
使用访问器，可以实现同样目的。描述符看起来如下：
17.8.3 通过描述符获取和定义属性
属性描述符用于两种操作。
（1）获取属性
一个属性的所有特性都通过一个描述符返回。
（2）定义属性
定义属性意味着会有一些不同，这取决于该属性是否已经存在。
如果属性不存在，会创建一个新的属性，它的特性由描述符指定。如果描述符中没有特性对应的属性，则使用默认值。默认值由特性名的意义指定。这与通过赋值创建属性（属性可写，可枚举和可配置）时使用的值是相反的。例如：
我通常不依赖于默认值，而是显式地声明所有特性以便更加清晰。
如果属性已经存在，那么更新描述符指定的属性特性。如果描述符中的属性没有对应的特性，则特性不变。下面有个例子（继续使用前面的例子）：
下面的操作让你可以通过属性描述符获取和设置属性的特性。
Object.getOwnPropertyDescriptor(obj, propKey)
返回obj对象的propKey键的自有（非继承）属性描述符。如果没有该属性，则返回undefined：
Object.defineProperty(obj, propKey, propDesc)
创建或改变obj对象的propKey键的属性，并通过propDesc指定这个属性的特性，会返回修改后的对象。例如：
Object.defineProperties(obj, propDescObj)
Object.defineProperty()的批量处理版本。propDescObj的每个属性都持有一个属性描述符。属性的键和值告诉Object.defineProperties创建或改变obj的哪些属性。例如：
Object.create(proto, propDescObj?)
首先，创建原型为proto的对象。然后，如果指定了可选参数propDescObj，用类似Object.defineProperties的同样方式给对象添加属性。最后，返回处理结果。例如，下面的代码片段与前面的代码生成的结果一样。
17.8.4 复制对象
为了创建一个对象完全相同的拷贝，你需要确保两件事情：
（1）拷贝必须具有与原对象相同的原型（详见17.4“第2层：对象间的原型关系”）。
（2）拷贝必须具有与原对象相同的属性和特性。
下面的函数进行了这样的复制：
这个函数把属性从orig复制到copy：
其中步骤如下。
（1）获得source所有自有属性键的数组。
（2）遍历这些键。
（3）获取属性描述符。
（4）使用属性描述符创建target的自有属性。
注意，这个函数和Underscore.js库的_.extend()函数（http://underscorejs.org/#extend）非常相似。
17.8.5 属性：定义与赋值
下面两个操作符非常相似：
通过defineProperty()和defineProperties()定义属性（详见17.8.3“通过描述符获取和定义属性”）。
通过 = 给属性赋值。
然而，它们稍有不同。
定义属性意味着创建一个新的自有属性或更新已存在自有属性的特性。这两种情况下，都会完全忽略原型链。
给属性prop赋值意味着改变已存在的属性。这个过程如下：
如果prop是一个setter(自有或继承的)，调用这个setter。
否则，如果prop是只读的（自有或继承的），抛出一个异常（在严格模式下）或什么也不做（在宽松模式下）。下一节会更详细地解释这一现象（有些意想不到）。
否则，如果prop是自有的（且可写），则改变这个属性的值。
否则，要么没有prop属性，要么它是继承来的并且可写。在这两种情况下，都会定义一个自有属性prop，且它是可写、可配置和可枚举的。在后一种继承的情况下，我们只覆盖一个继承的属性（非破坏性改变）。在前一种情况下，会自动定义缺少的属性。而这种自动定义可能存在问题，因为赋值中的拼写错误很难检测。
17.8.6 继承的只读属性不能被赋值
如果一个对象obj从原型继承了不可写的属性foo，那么你不能给obj.foo赋值：
obj从proto继承了只读属性foo。在宽松模式下，设置属性没有影响：
在严格模式下，会得到异常：
这符合赋值改变但不破坏继承属性的理念。如果一个继承属性是只读的，你应禁止所有修改操作，即使是非破坏性的。
注意，你可以通过定义自有属性绕过这种保护（详见17.8.5“属性：定义与赋值”）：
17.8.7 枚举性：最佳实践
一般规则是，系统创建的属性不可枚举，而用户创建的属性可枚举：
特别是对实例原型的内置方法：
枚举的主要目的是判断for-in循环中的哪些属性应该忽略。正如我们刚才所看到的，查看内置构造器的实例时，非用户创建的属性都在for-in中隐藏了。
枚举性只影响这些操作：
for-in循环；
Object.keys()（17.5.1“列出自有的属性键”）；
JSON.stringify()（22.2“JSON.stringify(value, replacer?, space?”)。
这里有一些最佳实践要牢记。
对于你自己的代码，通常可以忽略枚举性，且应该避免使用for-in循环（18.14“最佳实践：遍历数组”）。
你通常不应该给内置原型和对象添加属性。但如果这么做，你应该设置属性不可枚举，避免破坏现有代码。
17.9 保护对象
可以从三个层次上保护对象，下面按从弱到强方式依次列出：
防止扩展（Preventing extensions）；
封闭（Sealing）；
冻结（Freezing）。
17.9.1 防止扩展
通过如下方式防止扩展：
设置对象obj不能添加属性。例如：
在宽松模式下，添加属性静默失败：
而严格模式会抛出一个异常：
但是仍然可以删除属性：
你可以通过如下方式检测对象是否可以扩展：
17.9.2 封闭
密封：
防止扩展，并设置所有的属性“不可配置”。后者意味着属性的特性（详见17.8“属性特性和属性描述符”）不能被改变。例如，只读属性永远保持只读。
下面的例子展示了封闭让所有的属性不可配置：
你仍然可以改变属性foo：
但你不能改变它的特性：
判断一个对象是否封闭：
17.9.3 冻结
执行冻结：
它使所有的属性不可写，且封闭obj。换句话说，obj不能扩展，所有的属性都是只读的，且没有方法可以改变它。让我们看看下面的例子：
在宽松模式下，静默执行失败：
在严格模式下，你会得到错误：
检测一个对象是否被冻结：
17.9.4 缺陷：保护是浅层的
保护对象只是浅层的。它影响自有属性，但不影响这些属性的值。例如，下面的对象：
即使已经冻结了obj，它也不是完全不可变的，你可以改变属性bar的（可变）值：
此外，obj拥有的原型Object.prototype也是可变的。
17.10 第3层：构造函数——实例工厂
构造函数（简称构造器）帮助生成对象。构造函数在某些方面和普通函数类似，但命名、设置和调用不同。
本节阐述了构造函数的工作原理。它相当于其他语言中的类。
我们已经看过两个相似对象的例子（详见17.4.3“通过原型在对象间共享数据”）：
对象jane和tarzan都是“人”，并共享原型对象PersonProto。我们把原型改为可以创建jane和tarzan对象的构造函数Person。构造函数创建的对象称为它的实例。这种实例与jane和tarzan具有相同的结构，包括两个部分：
（1）数据是由实例指定的，并存储在实例对象的自有属性中（前面例子中的jane和tarzan）。
（2）行为被所有的实例所共享，它们公用一个带有方法的原型对象（前面例子中的PersonProto）。
构造函数是通过new操作符调用的函数。按照约定，构造函数的名字以大写字母开头，而普通函数的名字和方法以小写字母开头。第1部分，设置构造函数自身：
Person.prototype中的对象成为Person所有实例的原型。这构成了第2部分：
创建并使用Person的实例：
我们可以把Person看作普通函数。它只有通过new调用时，才变成构造函数。new操作符执行步骤如下。
首先设置行为：创建一个新对象，其原型为Person.prototype。
然后设置数据：Person接受对象作为隐式参数this，并添加实例属性。
图17.3显示了实例jane。Person.prototype的constructor属性指回Person构造函数，详情见17.10.3“实例的constructor属性”。
图17.3 jane是构造函数Person的一个实例，它的原型是对象Person.prototype
instanceof操作符可以用来检查一个对象是否为给定构造函数的实例：
17.10.1 JavaScript中new操作符的实现
如果你手动实现过new操作符，实现大致如下：
在行(1)中，可以看到构造函数Constr创建的实例的原型是Constr.prototype。
行(2)中，揭示了new操作符的另一个特性：可以从构造函数返回一个任意的对象，它成为new操作符的返回结果。如果你想让构造函数返回一个子构造函数的实例，这会十分有用（17.10.5小节的“从构造函数返回任意对象”中有这个例子）。
17.10.2 术语：两个原型
不幸的是，在JavaScript中术语prototype使用意义模糊不清：
（1）原型1：原型关系
一个对象可以是另一个对象的原型：
前面的例子中，proto是obj的原型。
（2）原型2：prototype属性的值
每个构造函数C都有一个prototype属性，它指向一个对象。该对象成为构造函数C的所有实例的原型：
一般这两个原型的意义在上下文环境中会更加清晰。我们有必要消除歧义，然后用prototype来描述对象间的关系，因为这个名字已经通过getPrototypeOf和isPrototypeOf进入了标准库。因此我们需要为prototype属性所引用的对象找一个不同的名称。一个可能是称为构造函数原型（constructor prototype），但由于构造函数也有原型，所以这也是有问题的。
因此，实例原型（instance prototype）这个名称是最好的选择。
17.10.3 实例的constructor属性
默认每个函数C包含一个实例原型对象C.prototype，它的constructor属性指回C：
因为每个实例都从原型中继承了constructor属性，所以你可以使用它得到实例的构造函数。
constructor属性的用例
（1）切换对象的构造函数
下面的catch子句中，我们根据捕获异常的构造函数的不同，采取不同的处理：
警告：
 这个方法只检测给定构造函数的直接实例。相比之下，instanceof既检测直接实例，也检测所有子构造函数的实例。
（2）确定对象的构造函数名
例如：
警告：
 不是所有的JavaScript引擎都支持函数的name属性。
（3）创建相似对象
下面是如何创建一个新的对象y，它和已有的对象x都有相同的构造函数：
这个技巧可用于子构造函数（subconstructors）实例的方法，且想要创建一个和this相似的新实例。这样你就不能使用一个固定的构造函数：
（4）指向父构造函数（superconstructor）
一些继承库把父构造函数（superprototype）赋值给子构造函数（subconstructor）的一个属性。例如，YUI框架通过Y.extend提供子类：
行（1）执行的调用，是因为extend把Sub.superclass设置为Super.prototype。正是由于有了constructor属性，你才可以把父构造函数（superconstructor）作为方法来调用。
注解：
 instanceof运算符（详见17.10.4“instanceof运算符”）不依赖constructor属性。
最佳实践
确保对每个构造函数C，下面的断言都成立：
默认情况下，每个函数f都有一个设置正确的prototype属性：
因此你应该避免替换这个对象，而只为它增加属性：