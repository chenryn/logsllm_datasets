title:(Mostly) Exitless VM Protection from Untrusted Hypervisor through
Disaggregated Nested Virtualization
author:Zeyu Mi and
Dingji Li and
Haibo Chen and
Binyu Zang and
Haibing Guan
(Mostly) Exitless VM Protection from 
Untrusted Hypervisor through Disaggregated 
Nested Virtualization
Zeyu Mi, Dingji Li, Haibo Chen, Binyu Zang, and Haibing Guan, 
Shanghai Key Laboratory for Scalable Computing Systems, School of Software, 
Shanghai Jiao Tong University
https://www.usenix.org/conference/usenixsecurity20/presentation/mi
This paper is included in the Proceedings of the 29th USENIX Security Symposium.August 12–14, 2020978-1-939133-17-5Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX.(Mostly) Exitless VM Protection from Untrusted Hypervisor through
Disaggregated Nested Virtualization
Zeyu Mi, Dingji Li, Haibo Chen, Binyu Zang, Haibing Guan
Shanghai Key Laboratory for Scalable Computing Systems,
School of Software, Shanghai Jiao Tong University
Abstract
Today’s cloud tenants are facing severe security threats
such as compromised hypervisors, which forces a strong ad-
versary model where the hypervisor should be excluded out
of the TCB. Previous approaches to shielding guest VMs ei-
ther suffer from insufﬁcient protection or result in suboptimal
performance due to frequent VM exits (especially for I/O
operations). This paper presents CloudVisor-D, an efﬁcient
nested hypervisor design that embraces both strong protec-
tion and high performance. The core idea of CloudVisor-D
is to disaggregate the nested hypervisor by separating ma-
jor protection logics into a protected Guardian-VM along-
side each guest VM. The Guardian-VM is securely isolated
and protected by the nested hypervisor and provides secure
services for most privileged operations like hypercalls, EPT
violations and I/O operations from guest VMs. By lever-
aging recent hardware features, most privileged operations
from a guest VM require no VM exits to the nested hypervi-
sor, which are the major sources of performance slowdown
in prior designs. We have implemented CloudVisor-D on a
commercially available machine with these recent hardware
features. Experimental evaluation shows that CloudVisor-D
incurs negligible performance overhead even for I/O inten-
sive benchmarks and in some cases outperforms a vanilla hy-
pervisor due to the reduced number of VM exits.
1
Introduction
One premise of multi-tenant clouds is that the cloud will
guarantee the privacy and integrity of tenants’ virtual ma-
chines (VMs). However, this premise is severely threatened
by exploits against the usually-vulnerable hypervisor (includ-
ing the management VM or the host OS). In fact, with the
code size and complexity of the hypervisor continually in-
creasing, the number of discovered security vulnerabilities
of the hypervisor increases as well. As shown in Table 1,
the total number of uncovered security vulnerabilities in the
Xen hypervisor [18] has increased from 32 in 2012 to 303 in
2019.
There have been several software approaches to shield-
ing a VM from an untrusted hypervisor, which can be
mainly classiﬁed into the “in-the-box” or “out-of-the-box”
approaches. The “in-the-box” approach attempts to harden
the hypervisor layer using various techniques such as the
hypervisor decomposition [22, 54, 58], the control ﬂow in-
Year
2012
2013
2014
2015
2016
2017
2018
2019
Xen
32
50
32
54
35
47
29
24
KVM VMWare
16
19
20
15
12
13
9
7
18
16
14
9
24
21
31
21
Table 1: The numbers of vulnerabilities discovered in
Xen [8], KVM [5] and VMWare [7] from 2012 to 2019.
tegrity [63] and minimizing the hypervisor layer [33]. How-
ever, while such an approach can thwart attackers exploiting
the hypervisor vulnerabilities to a certain extent, they cannot
eliminate the risks of exploiting hypervisor vulnerabilities.
The “out-of-the-box” approach exploits a nested hypervi-
sor to deprivilege the commodity hypervisor and securely in-
terposes all interactions between guest VMs and the hyper-
visor to protect privacy and integrity. Speciﬁcally, CloudVi-
sor [72] introduces a small nested hypervisor underneath the
Xen hypervisor and securely isolates the Xen hypervisor and
its VMs. It uses cryptographic approaches to guaranteeing
the privacy and integrity of guest data. However, this design
is at the cost of notably increased VM exits to the nested hy-
pervisor. For instance, these numerous VM exits bring up to
54.5% performance overhead for I/O intensive workloads.
Recently, there have been increasing interests to leverage
the secure hardware modules like Intel SGX [13, 47] to guar-
antee the security and privacy of applications executing in an
untrusted hypervisor [19, 28, 53, 61]. Such an approach can
provide reliable protection agasint an stronger threat model
which contains the adversary controlling hardware. However,
two facts limit its usage for VM protection in a virtualized en-
vironment. First, the SGX enclaves are only available to run
in user mode, preventing its use to provide a VM containing
both user and kernel mode. Second, the hardware limitations
(e.g., limited EPC memory at 128/256 MB) usually incur sig-
niﬁcant performance overhead for memory intensive work-
loads (sometimes 3X [15, 50, 61]).
In this paper, we present CloudVisor-D, a design that
securely and efﬁciently shields VMs from a compro-
mised hypervisor. Like prior solutions such as CloudVisor,
CloudVisor-D leverages nested virtualization to protect the
privacy and integrity of guest VMs. However, CloudVisor-
D tackles the deﬁciency of nested virtualization through a
disaggregated design by decomposing the nested hypervi-
USENIX Association
29th USENIX Security Symposium    1695
sor functionality into a tiny nested hypervisor (RootVisor) in
the privileged mode and a set of Guardian-VMs in the non-
privileged mode. Such a disaggregated design provides one
Guardian-VM for each guest VM and ofﬂoads most protec-
tion logics to each Guardian-VM, while the tiny RootVisor
is responsible for isolating all the Guardian-VMs from the
commercial hypervisor (SubVisor) and guest VMs. Note that
a Guardian-VM is not a full-ﬂedged VM but only contains a
few service handlers and is invisible to the SubVisor. Thus,
it consumes a very small amount of resources.
Recent hardware advances (e.g., VMFUNC and virtualiza-
tion exception) enable the self-handling of VM exits and ef-
ﬁcient EPT switching in the guest mode. Based on these new
hardware features, a Guardian-VM can handle ofﬂoaded VM
operations without VM exits. Assisted by the Guardian-VM,
the guest VM is able to directly invoke the hypercall handling
functions in the SubVisor without trapping into the RootVi-
sor. By utilizing the virtualization exception, normal EPT vi-
olations are converted to exceptions in the guest mode, which
are then redirected to the SubVisor by the Guardian-VM for
processing.
However, it is non-trivial to handle VM operations se-
curely in the guest mode. A VM or the SubVisor may ma-
liciously switch EPT to bypass or even attack the Guardian-
VM. Even if there are some existing solutions [27,39,44,49]
that try to defend against this type of attack, none of them
defeats the new variant of attack we encounter since these
solutions assume that the attacker is not able to modify the
CR3 register value, which is not the case in CloudVisor-
D. CloudVisor-D provides a series of techniques to defend
against this attack. First, the RootVisor creates an isolated
environment to make Guardian-VMs tamperproof. Second,
each Guardian-VM enforces that it interposes all commu-
nication paths in the guest mode between a guest VM and
the SubVisor. The complete mediation is achieved by using
the dynamical EPTP list manipulation technique and the iso-
lated Guardian-VM page table technique.
Based on the tamperproof and complete mediation proper-
ties, a Guardian-VM can handle VM operations without trust-
ing guest VMs and the SubVisor. Speciﬁcally, a Guardian-
VM requires that the corresponding VM can only invoke
functions within a limited range, which is listed in a jump
table. Moreover, it provides a shadow EPT to the SubVisor
for each guest VM and carefully checks the updates made to
the shadow EPT by the SubVisor before copying them back
to the real EPT. Finally, the Guardian-VM also protects the
privacy and integrity of their guest VMs’ I/O data.
We have implemented CloudVisor-D based on the Xen
4.5.0 and deployed it on a commodity Intel Skylake machine.
The code size of CloudVisor-D (including the RootVisor
and Guardian-VM) is roughly equal to that of CloudVisor,
which means it does not increase the TCB size. Our eval-
uation shows that CloudVisor-D signiﬁcantly improves the
performance of nested virtualization. Speciﬁcally, the EPT
violation handling achieves 85% speedup compared with
CloudVisor. Further, CloudVisor-D can efﬁciently support
PV (Para-Virtualization) VMs. It introduces negligible over-
heads for most benchmarks compared with a vanilla Xen and
in some cases outperforms the vanilla Xen due to the reduced
number of VM exits.
Contributions. To summarize, this paper makes the follow-
ing contributions:
• A disaggregated nested virtualization design to shield
VMs from an untrusted hypervisor which reduces a
large number of VM exits.
• A set of techniques to achieve the same level of security
as the nested virtualization.
• Implementation and evaluation of our design on a com-
mercially available machine.
2 Motivation & Background
2.1 Attack Surface of Virtualization Layer
Non-root mode Root mode
ɡ
Guest
VM
Guest
VM
Management
VM/Host OS
ɣ
VM exit
ɠ
VM entry
ɢ
VMM
Hardware
attack
VM attack surface
VMM attack surface
Figure 1: The attack surface in a typical cloud.
Multi-tenant cloud usually adopts virtualization to provi-
sion multiple guest VMs atop a single physical machine to
maximize resource usage [18,62]. As such, the virtualization
layer becomes a key target for attackers to compromise guest
VMs. An attacker can exploit vulnerabilities to “jail-break”
into the hypervisor, which is Step 1 in Figure 1. Such a
threat does exist given a large number of vulnerabilities dis-
covered every year with the increasing complexity of the hy-
pervisor layer (Table 1). The attacker can also exploit vulner-
abilities to tamper with the host OS (in the case of hosted vir-
tualization) or the management VM (in the case of hostless
virtualization) (Step 2 ). After compomising the hypervisor
or the host OS, the attacker can gain control of all other guest
VMs (Step 3 and 4 ).
1696    29th USENIX Security Symposium
USENIX Association
Operation
Control Flow in
Xen
Hypercall
VM → Xen→ VM
EPT violation
handling
VM → Xen → VM
DMA operation
VM → Xen →
Dom0 → Xen →
VM
Control Flow in
CloudVisor
VM → CloudVisor
→ Xen → ... →
CloudVisor → VM
VM → CloudVisor
→ Xen → ... →
CloudVisor → VM
VM → CloudVisor
→ Xen → Cloud-
Visor → Dom0 →
... → CloudVisor →
Xen → CloudVisor
→ VM
Times
> 2X
2 - 6X
> 2X
Table 2: Overhead analysis of VM operations.
2.2 Overheads of Nested Virtualization
To protect guest VMs from the untrusted hypervisor, the
nested virtualization approach tries to exclude the hypervi-
sor layer out of the trusted computing base (TCB) and thus
provides stronger protection from the vulnerable hypervisor
layer. Here, we use CloudVisor [72] as an example to illus-
trate the details of the nested virtualization and its overheads.
One design advantage of CloudVisor is that it separates secu-
rity protection from resource management. Such separation
allows CloudVisor to focus on protection and keep its TCB
small while the untrusted hypervisor’s TCB is enlarged as
more functionalities are continuously added to it.
CloudVisor introduces a tiny nested hypervisor in the most
privileged level (root mode) and deprivileges the Xen hy-
pervisor and the host OS (Dom0) to the guest mode (non-
root mode). The nested hypervisor interposes all communi-
cations between the Xen hypervisor and guest VMs. Cloud-
Visor guarantees that the Xen hypervisor is unable to access
a guest’s memory and disk storage. Therefore, CloudVisor ef-
fectively resolves the threats in the untrusted hypervisor. Yet,
the nested virtualization incurs a large number of VM exits
and introduces large overhead for I/O operations involving
excessive VM exits [72].
Table 2 lists a set of example operations which are com-
monly used in a virtualized system.
Hypercall: Each hypercall ﬁrstly gets trapped into CloudVi-
sor, which forwards this hypercall into the Xen hypervisor for
processing, as shown in Figure 2 (a). During this process, the
hypervisor may execute sensitive instructions (e.g., CPUID)
or access guest’s memory, either of which will cause a VM
exit. When the hypervisor ﬁnishes processing, it tries to re-
sume the guest and triggers another VM exit into CloudVisor.
Therefore, as shown in Table 2, a hypercall in CloudVisor in-
troduces at least twice as many ring crossings as that in Xen,
causing non-trivial overheads for each hypercall.
EPT Violation: The control ﬂow of EPT violation handling
in CloudVisor is similar to the hypercall operation, as shown
in Figure 2 (a). One EPT violation ﬁrst traps the VM into
CloudVisor, which then lets Xen handle this violation. Cloud-
Visor disallows Xen to access guests’ memory by conﬁgur-
ing its EPT (extended page table). During the handling of the
guest’s EPT violation, any modiﬁcation to the guest’s EPT
VM

Non-root Mode
Root  Mode


CloudVisor
(a)
Xen


VM

Non-root Mode
Root  Mode


CloudVisor

(b)
Xen

…

Dom0

…

Figure 2: Figure (a) shows the control ﬂows of hypercall
operation and EPT violation handling in CloudVisor. Figure
(b) shows the control ﬂow of I/O operation in CloudVisor.
causes a new EPT violation, which is trapped to CloudVisor
and handled by it. In the worst case, modifying the whole 4-