for （j
练
东习11.7.3：改写下面的代码
for (i = 0; i<= 97; i++)
A[j] =A[j] + 1;
A[i]= 2*A[i];
A[i] = B[i];
for (i = 1;i< 100;i++)
A[i] = A[i+2];
for
0；]
A[i,j] =(A[i-1,j] + A[i+1,j] + A[i,j-1] + A[i,j+1])/4;
100；j++)
for (i = 1; i <= 100; i++)
（100;
以处理器编号p为下标改写这个循环，使得代码可以在100个处理
j++)
图11-37练习11.7.2 的代码
C[i,j,k]
B[i,j,k]
一
for (i = 1; i <= 100; i++)
5
C
3
二
for （j
.100；j++)
+ B[i-1,j,k] ;
第11章
---
## Page 557
中，用一-个处理器（比如说0号处理器）执行s2。
语句s的不同实例。然后在另一个独立的顺序循环
至少语句，的实例可以并行执行。我们可以把这个
s2 的实例的执行顺序必须和它们在原程序中的顺序一致。
例11.50考虑下面的循环：
循环。利用同步栅障把它们隔开，然后逐一将它们并行化。我们用例11.50 来解释这个技术。
换创造出更多的优化机会。我们可以应用循环裂变转换把原程序中的循环分解成为几个较小的
更多的同步计算有可能降低通信量。我们将在11.9.9节中讨论这个问题。
步，但是这个并行化方案要求几乎所有的矩阵X中的数据在不同的处理器之间传递。通过引人
一个同步操作就可以使算法中的所有计算都被并行化。但是，我们注意到虽然只进行了一次同
等待所有的处理器完成任务后，各个处理器再在各个行上进行运算。使用这个方法，只需要引人
性。但是，我们观察到两个循环都是可以单独并行
数组X的--行上工作。如果要求没有通信运算，整
要求每个处理器在数组X的一列上工作；但是在第
同步并行性。在第-个循环嵌套结构中的依赖关系
化。例11.49说明了这一点。
环是可以并行化的。我们可以在这些循环执行之前和之后引人同步棚障，从而把这些循环并行
11.8.1固定多个同步运算
环中的情况。
为引人固定多个同步运算而获得的并行性。下一节中将讨论一般情况，即把同步运算嵌人到循
程序中增加少量固定多个同步运算之后，可以找到更多的并行性。在本节中，我们将首先讨论因
11.8并行循环之间的同步
应的 SPMD 代码显示在图11-39 中。
代码的一部分并行化，方法是让不同的处理器执行
单地把所有的计算任务都赋予同一个处理器。但是，
化的。
1
Dirrection Implicit)积分算法的典型程序。它没有无
数组必须放在同一个处理器上，因此不存在并行
个循环嵌套结构中的依赖关系要求每个处理器在
没有无同步并行性的程序可能包含一系列循环。如果独立地考虑这些循环，其中的某些循
如果我们不允许处理器之间进行任何同步，很多程序就没有任何并行性。但是通过向一-个
并行性和局部性优化
代码中没有无同步的并行性，算法11.43 将简
看起来，这个方法可能只适用于由一系列循环嵌套组成的程序。但是，我们可以通过代码转
并行化代码的方法之--是在第-个循环中让不同的处理器在数组的不同列上工作，同步并
因为不知道数组A 中的值，我们必须假设语句s中的访问可以写到W的任何元素上。因此,
W[A[i]] = x[i];
X[i]
相
口
图11-39例 11.50 中的循环的 SPMD 代码,
for (i = 1; i < n; i++)
x[p] = Y[p] + Z[p];
图11-38两个顺序的循环嵌套结构
for (j = O; j<n; j++)
其中p 是存放处理器 ID 的变量
for (i=1; i<=n; i++)
W[A[i]] = X[i];
f(x[i,j] + x[i-1,j]);
/*（s1）*/
/*(s2)*/
541
一
---
## Page 558
我们可以在第一个循环的并行执行之前和之后放上一个同步栅障，从而把第一个循环并行化。
它的所有实例，如图11-42所示。第一个循环是可以并行化的，但是第二个循环不能被并行化。
例11.52
分割，首先执行s的所有实例，然后执行 s的实例。
允许进行循环裂变转换。另一-方面，如果依赖关系s;"→s2 是单向的，我们就可以对这个循环进行
请注意，只有当s和 s2 嵌人在同一个循环中的时候才可能有这种相互依赖关系。因为有这种相
两个语句之间的依赖关系，那么 s的某些实例必须在 s的某些实例之后发生，反过来也成立。
的多个语句。在一个 PDG 中，一个环所连接的各个语句不能被分割开。如果 s"→S2 是一个环中
11.50 的程序的 PDG 显示在图 11-40 中。请注意图中有一个只包含 s2
依赖于所有之前的 s2 的实例。也就是说，语句 s2 依赖于它本身。例
用 W[A[i]]可以对数组的 W的每个元素进行写运算，s的第i个实例
个实例必须在语句s的第i个实例之后发生。更糟糕的是，因为数组引
例11.51
在一般情况下，s和s可以是不同的语句，有可能属于不同的循环嵌套结构。
的边，又生成了从 s2 到 s的边。
的下标。
的访问.和语句s2 中的访问,之间有依赖关系。请注意，一个语句的实例可以使用下标向
个动态实例之间存在数据依赖关系，就存在一条从语句s到语句 s2的边。
示语句之间的数据依赖关系以及依赖的方向。只要语句s的某个动态实例和后面的语句s2的一
Graph，PDG)的抽象表示方法。程序的程序依赖图中的各个结点是程序的赋值语句，图中的边表
原程序应用裂变转换。把循环尽可能分解为独立循环，然后独立地并行化每个循环。
11.8.2程序依赖图
的环。
系
i=[i,i2，,im”来刻画，其中i是该语句所在循环嵌套结构中从最外层开始的第k个循环
。一-个语句对中的两个语句可以相同，这两个静态访问也可以相同。假设确定了语句；中
程序依赖图使得我们可以很容易地确定是否可以分割一个循环中
请注意，有可能根据两个语句s和 s2 之间的数据依赖关系，在 PDG 中既生成了从 s 到 s2
为了揭示出所有可以进行循环裂变的机会，我们使用程序依赖图（Program Dependence
在语句s 和 s2 相同的特殊情况下,i <si2 当且仅当i<i(即i 按照词典排序比i 小)。
1）如果有两个语句实例，s的实例i和s2 的实例i，它们之间具有数据依赖关系，并且在
542
2）类似地，如果有两个语句实例，s；的实例i和 s2 的实例i2，它们之间具有数据依赖关系
构造一个程序的PDG时，我们首先找出每一对语句中的两个静态访问之间的数据依赖关
为了找出所有可以通过加人固定多个同步运算而变得可用的并行性，我们可以尽可能地对
图 11-41b 显示了图 11-41a 中程序的程序依赖图。图中语句s, 和ss 属于--个环，因
对于例 11.50 中的程序，在语句s的实例之间没有依赖关系。但是，语句s2 的第i
口
图11-40例11.50的
程序的 PDG
第11 章
口
---
## Page 559
它们之间的顺序。只有当较外层循环的下标值都相同的时候，我们才需要比较下一个内层循环
语句处于同一个循环中，我们从最外层循环开始比较它
照正文顺序执行。我们可以重复上面的讨论，生成执行
标i的值为O 的所有动态实例，语句s、L2、Lg 和 ss
第二个迭代中的指令，这样一直向前执行。对于循环
行来自外层循环的第一个迭代的所有指令，然后再执行
进行，因为它是被执行的第一个语句。接下来，我们执
中着重显示。
例11.53
子结点就是循环体对应的子图，通常是由一个或多个语句组成的序列。
语句。这些子结点按照语句的词典排序从左到右排列。如果某语句是一个循环结构，那么它的
单个赋值语句是一个叶子结点。如果某语句是一个语句序列，那么它的子结点就是该序列中的
序的控制结构就形成了一个层次结构。这个层次结构的顶层结点表示对应于整个程序的语句。
个赋值语句，要么是一个语句序列，要么是一个其循环体为单个语句的循环结构。这样，这个程
块结构的，由循环和简单的算术运算组成，并且不包含其他控制结构。该程序中的语句要么是-
接的方法来计算这种依赖关系。本节中的优化技术经常被应用于这一类程序。假设这个程序是
11.8.3层次结构化的时间
不同语句生成的两个实例之间的顺序问题。如果两个
顺序的其他部分。
我们可以用一种层次结构化的方式来解决由两个
在一般情况下，关系<s的计算是很困难的。但是对于某些类型的程序而言，我们有一个直
并行性和局部性优化
for（i= O;i<n;i++）{
Z[i]
，语句s的唯一实例在所有其他运算之育
图11-43 中程序的层次结构显示在图11-44 中。执行序列的层次结构特性在图 11-45
图11-42对--个循环嵌套结构的强连通子图进行分组
a)一个程序
for (i = O;i<n; i++)
z[i]  =z[i] / W[i];
for（j
图 11-41例11.5.2 的程序和依赖图
z[j] = Z[j] + x[i,j];
/*(s1)*/
< n; j++)
]*Y[i,j]；
按
前
图11-43 
/*(s3）*/
/*(s1）*/
/(s2)*/
一个按层次结构组织的程序
s5;
6
（i=0;...）{
：for
b)它的依赖图
Y
s4;
2.8
543
---
## Page 560
人同步栅障。第二，虽然只会有固定多个同步，但得到的并行化方案会在每次同步的时候在不同
地并行化的程序上，这个算法会对每个语句进行并行化，并且在执行各个语句的并行循环之间引
它可能引人不必要的同步。作为一个现实问题，如果我们把这个算法应用到--个可以被无同步
后都插人同步栅障。
其他结点。
过，
算法11.54
然后独立地并行化各个循环。
11.8.4并行化算法
出现在 s 之前。
否存在。要求解的问题个数依赖于语句s，是否按照正文顺序
要求解多达d或d+1个整数线性规划问题来决定某一条边是
时成立，就存在--个从s到s 的 PDG边。因此，我们可能需
式的析取式。
之前。
而j=[jj，jd,”为 s的一-个实例。
在深度为d的循环中，它们之间有d个公共(外层)循环。当
化”的时间。
们的相对正文位置来决定它们之间的顺序。因此，我们一直在
此类推。如果所有公共循环的下标值都相同，那么我们根据它