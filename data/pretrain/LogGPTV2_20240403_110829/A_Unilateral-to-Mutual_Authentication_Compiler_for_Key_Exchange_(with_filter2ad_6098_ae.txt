includes some cases where the SIGMAC analysis from Sec-
tion 5 does not apply directly. We identify three such cases.
The ﬁrst considers the fact that TLS 1.3 always encrypts
the CSM message for reasons of identity protection. In the
regular handshake case, the encryption key, or “handshake
transport key (HTK)”, is derived from the same interme-
diate key from which Ka and Ks are derived, and by the
properties of the key derivation function HTK is (compu-
tationally) independent from Ka and Ks. Extending the
established by a single client rather than representing the
total number of sessions.
7We take the liberty of referring to the signature and MAC
combination used in TLS 1.3 as “the CSM message”.
1446SIGMAC proof for this case is immediate: the simulator de-
rives the HTK key from the UA session key K, as it does
with Ka and Ks, and uses it to encrypt/decrypt the CSM
message. Due to the independence of HTK from Ka and
Ks, the proof holds with minor adjustments.
In the second case the CSM message is also encrypted but
in this case the encryption uses the same key Ks that the
protocol outputs as the session key. This immediately vi-
olates key indistinguishability since by the time the client
establishes the session key (which is when the key can be
tested for indistinguishability), this key has been used al-
ready. We show (Section 6.2) how to adapt the analysis of
SIGMAC to this case, at the cost of reducing the security
guarantee. Rather than ensuring generic security of Ks (as
induced by the regular indistinguishability property of key-
exchange protocols), we show that Ks can be used as a key
to an authenticated encryption scheme for implementing se-
cure channels. Our analysis is general and can be applied
to diﬀerent modelings of secure channels (e.g.
[20, 15]) as
well as to other applications of the session key8 as long as
the security of such application is not voided by the use of
Ks for encrypting CSM. Our formalization introduces the
notion of functional tests (Section 6.1) that abstracts out
details of applications and implementations.
The third case is the so called “post-handshake client au-
thentication”. Here, the client authenticates with a CSM
message but only after the server and client have already
exchanged application data (i.e., record layer communica-
tion in the TLS context) protected with the session key
Ks. The encrypted data exchange starts after the parties
compute the session key but before the client authenticates.
This raises questions about the notion of security that can
be claimed and the level of protection provided to the ex-
changed data (to which we will refer as pre-authentication
data). One can see that since the handshake protocol with-
out client authentication provides unilateral authentication,
then the data gets the assurance of unilateral authentica-
tion (server authentication in the case of TLS). However,
the SIGMAC analysis from previous sections showing that
the CSM message upgrades the protocol to MA security does
not hold anymore once the session key Ks is used to protect
data before CSM is delivered and veriﬁed. Yet, we are able
to show (Section 6.3) that the CSM message does provide
mutual authentication of the exchanged data but only in
the sense of secure channels, and only after the CSM mes-
sage is veriﬁed by the server. Namely, the parties get the
guarantee (delayed for the server) that only the named party
that passed authentication can authenticate and decrypt the
exchanged information (including data sent before client au-
thentication). Here too, our treatment via functional tests
adds generality and allows us to abstract the details of the
secure channels modeling and implementation.
Finally, combining the last two cases one obtains secure
channels security for the case (also in TLS 1.3) where in ad-
dition to the exchange of pre-authentication data, the post-
handshake CSM message itself is encrypted with the session
key (Section 6.3.1).
8In the case of TLS 1.3, such applications may include the
derivation/update of keys or the issuing of resumption keys
via a New Session Ticket Message. Here the session key
can be the application key or other keys computed in the
protocol such as the exporter master secret.
Fortunately, we can address all these scenarios with sim-
ple adaptations of the analysis of the SIGMAC compiler. We
do so in the following subsections.
6.1 Functional Queries and Functional Tests
Since our goal is to show that the above authentication
variants are suﬃcient to ensure “secure channels” function-
ality, it is worth recalling how such functionality is modeled.
Take as example the ACCE model of Jager et al. [20] that
has been used to prove security of several variants of TLS
1.2. Such model extends the usual key exchange security
formalism with the ability of the attacker to run Encrypt
and Decrypt queries on messages of its choice where the
session key (or keys derived from it) serves as the authenti-
cated encryption key. In addition, to capture the inability
of the attacker to subvert the desired secure channels func-
tionality, the attacker is tested through a dedicated game
that replaces the standard indistinguishability test of key
exchange models. In the ACCE model this test is adapted
from the treatment of stateful authenticated encryption by
Paterson et al. [31]. Other secure channels models diﬀer in
their details and scope but they follow a similar approach.
To increase generality and simplicity, our treatment ab-
stracts out the details of implementation of secure channels,
framing the above model ingredients in an abstract way.
That is, we extend the capabilities of a key exchange at-
tacker with the ability to query abstract “functional queries”
on session keys and we replace the usual indistinguishability
test with an abstract “functional test” that is run on a session
chosen by the attacker (the “test session”) and where the in-
put to the test is the test session key. The only condition on
such a test is that if one replaces the input session key with a
random independent key, then the advantage of the attacker
in winning the test is negligible. The ACCE model is an in-
stantiation of this abstract framework where the functional
queries represent the Encrypt/Decrypt queries and the ses-
sion key experiment is modeled as a stateful authenticated
encryption test (note that this test has the required property
from a functional test, namely, if the authenticated encryp-
tion scheme is keyed with a random value then the attacker
has negligible advantage in winning the ACCE game). This
abstraction frees our analysis from dealing with speciﬁc de-
tails and models while at the same time adding generality.
For example, one can use this abstraction to reason about
whether a session key used to protect key exchange messages
may still be secure for another purpose (say, to derive other
keys) or whether a late client authentication implies authen-
tication of keys derived prior to the authentication (e.g., a
resumption key in TLS 1.3).
Functional family F . Let F be a parametrized family of
(possibly randomized) functions that accept a single input to
which we refer as a session key. Given a parameter p and a
session key k, fp denotes a member of F and fp(k) denotes
an output distribution (or, more commonly, it denotes a
speciﬁc value sampled from that distribution).
Functional queries and tests. We present a modiﬁcation
of the CK model of key exchange security [9] (which we
recalled in Section 2). The only changes to the model are as
follows (we refer by AF to the attacker in this setting):
• We add a new adversarial query type, called a func-
tional query FQuery, associated to a functional family
1447F . AF can issue FQuery against any session eligible
for a Reveal query and also against the test session. In
it, AF provides a session identiﬁer, a parameter p and
gets back fp(k) where fp is an element of F and k is
the session key of the named session.
• We change the test session experiment: A test session
can be chosen under the same rules as in the CK model
but the regular indistinguishability-based Test query is
replaced with a functional test FTest. This can be an
arbitrary test taking the form of an interactive game
between a challenger and attacker AF , where the chal-
lenger’s input is the test session key and a random bit
b, and the output of AF is a bit b(cid:48). We say that AF
wins if b = b(cid:48). The only condition on a functional test
is that if one replaces the input to the challenger with
a random independent key then the advantage of AF
in winning the game is negligible.
We allow the functional queries to use a shared state (for-
mally accommodated through the parameter p that can be
seen as a generalized second input to the function) and also
allow the functional test to share such state. This adds gen-
erality to our treatment and is needed, in particular, for the
formalization of stateful authenticated encryption as used in
the deﬁnition of ACCE security.
Functional CK model. The security deﬁnition in this
functional model remains the same as in the original CK
model (end of Section 2.1) except that the notion of winning
for the attacker changes from the indistinguishability Test
experiment to a given functional test FTest. We will refer to
this notion as Functional CK security and we will denote the
MA and UA variants by F-MA and F-UA (as in the regular
CK model of Section 2, the main diﬀerence between UA and
MA is that only clients have a deﬁned peer and only client
sessions can be chosen as test sessions).
Remark: For sessions other than the test session, the func-
tional queries seem redundant as the attacker can always
query these sessions via a SK reveal query and compute
the functional query by itself. However, note that informa-
tion learned via functional queries on a session can help the
attacker choose that session as the test session (running a
reveal query on a session would disqualify that session for
testing). Moreover, quantifying security via the number of
functional queries in an attack (e.g., number of encrypt and
decrypt queries) can be an important measure. On the other
hand, one may simplify the model by assuming that the at-
tacker chooses its test session at random (at the cost of a
number-of-sessions factor loss in the attacker’s advantage)
in which case functional queries are not needed, except for
the test session and as part of deﬁning a functional test.
Remark: We note that the above formalism via a bit-
guessing game can be generalized. First, one can replace
such a game with any experiment (not necessarily bit-guessing)
where the winning probability of AF on a run over a random
independent key is negligible. Second, it would be enough
to require that the diﬀerence between the success of the at-
tacker on a run over the real session key be negligibly higher
than on a run over a random key (even if the latter case
is not in itself negligible). Finally, note that the functional
approach can be applied to other key exchange models such
as the Bellare-Rogaway [1]; a notion similar to functional
queries was considered by Shoup [34]. One may also be able
to use the ”suitable for” notion from Brzuska et al. [8] as a
replacement for our functional tests. The two notions dif-
fer in their approaches but have a motivation in common,
namely, replacing pure key indistinguishability with more
limited functionalities where the use of the session key dur-
ing the KE process does not void the security of the task at
hand.
Secure channels via functional security. As discussed
above, we are interested in freeing our results from the spe-
ciﬁc details of a secure channels model or its implementa-
tion. The idea is that any such formalism can be framed
via the above functional model. Speciﬁcally, when referring
to secure channels we will deﬁne two abstract functional
queries, Encrypt and Decrypt, and will assume a given func-
tional test. Encrypt and Decrypt will have the regular func-
tionality of encrypting and decrypting messages but their
implementation can take diﬀerent forms (e.g., they can be
deﬁned via general authenticated encryption or with a more
speciﬁc scheme, they can be stateless or stateful, apply to
full messages or fragments, etc.). The functional test can
also take diﬀerent forms, e.g. [20, 15]. For example, [20] de-
ﬁnes its model, ACCE security, through a semantic security
game that mimics the game used to deﬁne the security of the
underlying (stateful) authenticated encryption scheme [31]
and relies on the fact that no attacker can win the latter
game if the key in use is fresh and random. Our formalism
can represent such a model by instantiating the functional
test via this particular ACCE game.
6.2 SIGMAC with encrypted CSM
We consider a variant of the SIGMAC compiler in which
the CSM message is encrypted with the session key Ks from
the same session to which the CSM message belongs. We
show that any application whose security can be deﬁned via
a functional test as in Section 6.1, and where the encryption
and decryption of CSM are included in the functional queries
of the model, enjoys mutual authentication in the sense of
F-MA. As an application, instantiating our abstract formal-
ism with a secure channels model (e.g., [20, 15]), we get that
the session key validated via SIGMAC with encrypted CSM
implements secure channels with mutual authentication (it
is assumed that the secure channels mechanism enforces do-
main separation between the encryption of CSM and encryp-
tion of application data, for example as the ACCE model
does via stateful encryption).
(cid:48) be a protocol resulting from applying SIGMAC
with encrypted CSM to a UA-secure Π1 protocol. (It is pos-
sible to include further information under this encryption
such as the client’s identity or certiﬁcate to protect it from
eavesdroppers.) The encryption of CSM is generated by the
client and the corresponding decryption and veriﬁcation is
performed by the receiving server. We prove this modiﬁed
compiler following the original proof of Theorem 3 but we
replace the regular indistinguishability-based security test
with a functional test as deﬁned in Section 6.1; we also as-
sume Encrypt and Decrypt operations as part of the allowed
functional queries9. We prove:
Let Π2
9Note that the attacker does not provide the message CSM
for encryption, but rather the functional query is deﬁned as
the application of Encrypt to the value CSM generated by
the client and possibly unknown to the attacker.
1448Lemma 7. The SIGMAC compiler with message CSM en-
crypted under session key Ks and applied to a treplication-