2）计算组成缓存的对象数量n。
3）分配n-1个对象。
4）分配那个已利用的对象。
5）溢出进人in-cache控制结构。
这个方法可以参考图3.7。
in-cache控制结构的一个实例是FreeBSD联合内存分配器（UnifiedMemoryAllocator），
有一篇文章详细介绍了对该系统的漏洞利用，即“ExploitingUMA，FreeBSDkernelheap
由对象的查询速度。这样的实现一般用在LinuxSLUB分配器中，我们将会在第4章详细讨论
它。那里给出的利用是一个仅溢出几个字节的很好的例子（实际上，一个字节的溢出通常称为
off-by-one，确实，这种漏洞利用很神奇）。
---
## Page 71
62第一部分内核态
自由
自由
自由
自由
自由
控制
对象
对象
对象
对象
对象
结构
分配一个新的slab
占位
占位
占位
占位
自由
控制
对象
对象
对象
对象
对象
结构
用占位对象填充n-1个对象
占位
占位
占位
占位
被害
控制
对象
对象
对象
对象
对象
结构
分配被害对象作为最后对象
占位
占位
占位
占位
被害
控制
对象
对象
对象
对象
对象
结构
溢出越过被害对象进人缓存结尾的控制结构
图3.7溢出到缓存控制结构
这种依赖于分配器的实现的控制结构变化很大，很难使用通用的技术攻破。这里要强调的
是，即使只有一个字节，如果能正确利用，也能导致一次彻底的危害。
重写相邻页
假设您实现了一个堆溢出，但在具体的高速缓存中没有对象持有任何合理或有意义的数
据。另外，控制结构偏离slab或位于缓存的开始处，这样的话它是不可读到的。这时可以把堆
溢出转化成一种成功的妥协：物理页面分配器。
我们要介绍的技术是在任何操作系统中都有效的，但是较前面介绍的两种技术而言并不可
靠，因为它涉及堆分配器以外的子系统。特别是，它涉及堆分配器依赖的子系统：物理页面分
配器。当我们首次描述泛型堆分配器时，我们说它是物理页分配器的使用者，泛型堆分配器从
物理页分配器接收物理页。然后将得到的物理页划分为对象并进行内部管理。几乎内核中其他
任何地方最终都需要使用物理页面分配器：文件系统用来加载模块的页面缓存，最底层都是分
配内存页。正如您知道的那样，内存是连续的。如果在一个给定的时间点给内存拍一张快照，
将会看到一个接一个的潜在的由独立页组成的列表。分配器的页面分散其中，这就提供了一个
新的利用向量。
这个想法很简单：把受害者对象置于缓存的最后，从那里溢出到下一个相邻页。主要的问
题是预测相邻页的准确度，还有就是如何把一个有用的结构放在那儿。在用户态控制物理内存
页分配器是件很有挑战性的工作。操作系统通常会透露出一些关于堆分配器的信息，却很少透
露物理内存页分配器的信息。此外，驱动一个新页的分配器的操作很可能对页分配器产生一些
---
## Page 72
第3章成功内核利用进阶63
副作用，从而影响算法的精度：这同样会影响所有正在系统上运行的无关进程（从而引发一
些意外的页错误并使布局结构失效，以致失去目标。请注意，在这里需要有两个相邻的内存
页）。
提高您的成功几率的一种方法是依靠一种概率方法：
1）消耗受害者对象所在的缓存，分配除了一个空白页之外的所有可用的对象。这可能需
要关注特定的阈值，分配器可能会加强此阀值以主动从物理分配器请求页。
2）通过请求一个特定的资源（例如，打开一个文件）使得分配很多的页面，从而耗尽自
由页面。目标是达到一种图3.8a描述的状态。页面分配产生的副作用越小（一般来说，这意味
着内核在更浅层就满足了请求），获得成功的机会就越大。这个特定资源和被害对象之间的关
联不是必需的。唯一重要的是，这个特定的资源把一些控制结构或者有趣的指针放置在内存页
的开始处（离开始处越近，需要溢出的变量的数目就越少）。
1
2
3
4
5
分配大量物理页（把虚拟内存子系统放在压力下）
释放一个页面
空表L
的指针
图3.8a驱动分配许多物理页并释放其中一个物理页
3）释放进程中途中分配的一些资源，以便释放的内存的数量加起来达到一页。由于
内核处于内存压力下（您在之前的阶段生成它），这个页面将立即返回到分配器，而不是
作为缓存或是被您在消耗内存阶段使用的任何子系统持有。这么做的目的是，为了通过
3.8a所示）。
4）通过分配一些新的对象来为被害对象缓存分配一个新的页面。释放的页面将返回给堆
---
## Page 73
64第一部分内核态
分配器。
5）在被害对象上执行缓冲区溢出使之溢出到下一个相邻页。
6）开始逐个地释放物理页分配器消耗阶段分配的所有资源，寄希望于由于上一步的溢出
而重写其中的一个。
图3.8b图形化地演示了这个方法的最后几步。
正如可以想象到的，这么做是有风险的，因为有可能会重写一个错误的页面从而改动了一
些敏感的内核数据。如果这个风险确实发生了，被攻击的机器将陷人不稳定的状态，攻击的目
标也将会丢失。这就是尽可能限制溢出字节的数量的重要性所在。
在低负载的机器上，上述技术可以更有效地实现。我们将在第4章更加详细地讨论这种情况
自由
自由
自由
自由
对象
对象
对象
对象
通过物理页分配器之前释放的页得到返回
空表-LRU
指针
占位
占位
占位
被害
对象
对象
对象
对象
用占位对象填充刚分配的缓存（缓存页）使得被害对象放在最后
占位
占位
占位
被害
对象
对象
对象
对象
在被害对象中触发溢出并且写到下个相邻页
图3.8b溢出到相邻页
栈内存破坏
正如在第2章提到的，每一个用户模式下的应用程序至少有两个栈：一个用户模式的栈
和一个内核模式的栈。在本节中，将主要介绍当应用程序在内核态运行溢出时我们能使用的技
术，此时使用的是内核态栈。
您可能还记得，内核模式栈只是一个由物理页分配器分配的很小的内核内存块，就像任
何其他的基于内存的资源一样。相比用户栈来说，它通常很小，且不能根据需求增长，通常内
核态栈会在内核把控制权交给用户态进程时废弃。然而这并不意味着内核态栈每次都会重新分
配。它只是意味着每次进程进入内核态时，内核态栈的指针将指向开始处。
---
## Page 74
第3章成功内核利用进阶65
到目前为止，只讨论了栈溢出这种最常用的栈损坏例子，如图3.9所示。
栈顶
嵌人的函数栈
嵌人的函数栈
本地缓冲区
本地缓冲区
栈canary
栈canary
本地变量
本地变量
在这个
栈溢出
方向上
保存的EBP
保存的EBP
栈增长
返回地址
返回地址
函数参数
函数参数
父帧
父帧
栈底
图3.9栈溢出
对内核态栈损坏进行漏洞利用主要有3种方法：重写返回地址、重写本地变量和重写相邻
页。在一些操作系统和硬件架构的组合中（例如，x86体系上的Linux），用相同的页面来维护
栈和在被分配页面末端为正在运行的进程设置控制结构。这样就容易通过对栈指针进行“与”
运算来确定当前正在运行的进程。因为这样的结构处于栈页的底端，所以图3.9所示的溢出并
不能到达那里（因为写操作只会令地址值增加而不是减少）。从理论上讲，另一个问题可能会
出现：一个足够长的、嵌套的调用序列可能会排到栈的底端。虽然从来没有在任何内核中发现
这种缺陷（内核开发人员非常小心地设计如何使用栈，并且现在的中断通常有硬件架构的支持
或者用软件方法替代的栈），在这里提到它只是为了让讨论更完整一些。
重写返回地址
通过对保存的返回地址进行重写来劫取控制流的栈溢出攻击已经成功地使用了20多年，
现在依然流行。例如，“执行阶段”一节讨论过的返回到内核文本的高级技术就是基于重写指
令指针的。
总之，若要想抵达保存的返回地址，需要溢出大量的其他变量。如果这些溢出的变量中有
的在函数返回之前使用过，那么就需要模拟它的值，也就是说，把它设置成能让函数正确返回
的值。例如，如果函数在结束之前试图读取栈中的一个指针，那么您必须确保已经把该指针的
值重写成一个内核区内可读内存的地址。最后，在本地变量恢复后，就可以应用我们之前介绍
---
## Page 75
66第一部分内核态
过的技术处理了。
在试图阻止典型的栈缓冲区溢出的过程中，在编译器内部设计有一种称为stackcanary的
保护措施并已经得到实施。这个想法很简单：一个伪随机数，即canary，恰好入栈到返回地址
的后面，并在被调用进程返回时进行检查。如果最终得到的值与原始值不同，便是一个栈溢出
的迹象。激活栈canary保护通常只是打开编译器选项，并添加一些处理代码，当检测到溢出时
触发这些代码。这种处理代码可以做的事情简单到只打印一些错误消息和发出警报（警报要比
死机更安全）。通常为了减少对性能的影响，编译器只会选择那些认为有潜在威胁的补丁。在
栈上使用一些空间的功能就属于此类功能。
stackcanary是一个很好的保护机制，但它也有一些缺点：
·一个特殊控制下的溢出可以在不触发它的情况下写canary（例如，对一个在栈上保存的
数组进行基于索引的溢出）。
·canary需要保存在内存的某个地方，因此攻击者可能会通过内存泄漏发现。在当今的实
现中，为每一个进程的栈配置canary已经很普遍了，主要是在创建进程时生成canary，