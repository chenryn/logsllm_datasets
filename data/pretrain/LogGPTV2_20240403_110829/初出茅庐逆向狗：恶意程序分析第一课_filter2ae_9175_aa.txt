# 初出茅庐逆向狗：恶意程序分析第一课
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
不知道在座的各位逆向狗中，有多少人是从CTF开始的逆向之路，在我认识的逆向狗中，要么是从一些小小的破解入坑，要么就是通过CTF
而开始通过CTF入坑的童鞋们，在CTF逆向题做多了之后，都会想要找一个现实生活场景中的案例来试验一下学到的技术：比如恶意程序分析！
今天笔者就提供给大家一个自己遇到的样例：一只可爱的远程控制木马，供各位练练手。
程序不是很出名，“市面上”应该也找不到，大体来源就是有一位给人开发票的大叔想套客户信息，做了个伪装成发票样板的远控马…blabla……分析难度不是很大，但也挺费力气，拿来作为人生第一个分析的恶意程序难度刚刚好~整个分析过程有章可循，对思维启发还是很好的
程序下载链接：[木马在这里吃草~](https://pan.baidu.com/s/1ZE5ORkr23YxYQCB8bWFEBw)
Warning：木马真实有效，功能为远程控制，但已确定无其他对计算机的破坏性行为，请自行丢虚拟机调试！！！若不慎运行可立即断开网络并检查开机启动项，即可解除危险
## 一、文件概览
顶级文件夹内就是这些东西，除了exe外皆隐藏，exe图标进行了伪造，打开文件夹1，里面是一个无害txt发票样板
## 二、文件类型初步窥探
notepad++看一下bin文件和db文件，分别如下：
bin文件是什么文件暂时看不出来，但是db比较有意思，是一串base64编码，我们尝试解码一下：
有发现，竟然是对一个pe文件做了编码（脑洞选手可能已经想到这个可能是木马功能代码，但是我们出于训练逆向能力的目的，不要去解码来分析得到的文件，先一步一步走）
## 三、静态分析
就目前的情况来看，诱骗用户运行的应该就是那个exe，我们把它丢进IDA来分析一下：
这是WinMain的汇编开头部分，F5看它的伪代码：
可以看到，程序开始运行后，首先是打开了文件夹1中的txt，让用户看到所谓的发票模板，然后就开始搞事情了。
CreateFileA是创建了一个文件指针，指向了log.bin那个文件，返回的文件指针给了v4，v4就可以理解成代表这个文件的文件指针，对文件的操作都是通过v4来完成的。
GetFileSize，顾命思意，拿到文件的大小，值给了v5.
VirtualAlloc分配了一块内存空间，刚刚的v5作为参数表示分配的大小，0x40时该空间的属性为可执行，这意图就很明显了，想创建一块和log.bin一样大的内存，然后属性还是可执行，显然就是要把这个文件载入这块内存，而且内容还是可执行的代码！然后v6就指向了这儿
果然，下面马上ReadFile把文件读进来了，此时，v6就指向了这么一块可执行区域，内容即是log.bin
倒数第二行讲v6当作函数指针使用，也就使得程序跳到了那块内存去执行了
（函数具体的参数和说明请自行百度！）
**可见，exe只是个启动器，它只是加载了log.bin中的代码，更阴暗的东西在log.bin里头**
## 四、动态分析
log.bin并不是一个完整的程序，因此IDA已经无能为力了
想要知道log.bin的代码载入内存后究竟做了什么，只能依靠动态调试的力量，我们祭出神器：x64dbg（这个例子中实际是32位的）
调试器打开exe后，先运行一下，让程序运行到Entrypoint:
接下来我们需要找到刚刚静态分析时载入bin文件的地方，结合IDA静态分析的结果，该位置用到了一些字符串，如”1\1.txt”
“log.bin”等等，我们使用调试器的搜索字符串功能来辅助定位。
右键功能里面有：
很快有了结果：
我们在第一条结果右键转到汇编代码，就可以转到对应的汇编代码的位置如下：
对比之前IDA的反汇编，可以确认就是这儿了，此外，可以发现，指令的地址和IDA中是不一样的，应该是开启了随机化，只有低位的地址是和原来一样
下一步我们往下找，找到IDA中调用函数指针v6的地方，因为就是从那儿跳转到log.bin的代码：
很容易就找到了，readfile调用之后，call
eax就是对之前v6函数指针的调用，具体讲的话，就是前面VirtualAlloc返回值eax（函数指针）先压在了栈中，然后通过mov又给回了eax
我们在这儿下上了一个断点，运行到这儿以后再单步运行一下，就可以进入到log.bin的地盘了。
我们运行到断点，然后步进到log.bin的区域：
先是如之前分析那样，到断点时打开了txt
然后步进：
这就是log.bin的代码区域了，之前被加载进来的文件就是这些！
大体扫一眼，不知道各位是否已经看出了端倪？是不是某个地方有点似曾相识呢？
没错！我们看到了从0x3510064开始进行了一系列的push，而push的3、1、80000000和之前IDA中看到的某个函数调用惊人的相似！
而这个函数，回头去看，正是CreateFileA！
还要CreateFile？！这次又要关联哪个文件呢？稍加分析思考，无非两种可能：
1、上面的一大堆call调用的函数创建了一些文件，然后在此处关联上它
2、并没有创建新的文件，那这个文件十有八九就是前面文件夹里的log.db了
显然，下面call esi应该就是调用CreateFileA，我们在那儿下断点，过去就知道是打开哪个文件了：
不出所料，就是log.db，看来这回是要加载log.db了，那么大概大家也可以猜到这个程序的“好意”了：很有可能就是把db文件读进来，base64解码它，然后执行！
接着往下看汇编，果不出我们所料：
正如上图，接下来的三个call依次调用了GetFileSize、VirtualAlloc、ReadFile，与之前的操作如出一辙！
但是再仔细看一下就会发现，VirtualAlloc传参时，压进的第一个参数4，这个参数之前说过是内存属性，为4时是不可执行的！
这就很奇怪，log.db不是要执行的吗？为啥是不可执行的？是因为这里读进来的是base64编码，当然不可执行，这也提示我们，后面肯定要做解码，然后肯定会去执行它！
我们可以猜到，很可能程序是这样一个思路：exe加载执行bin -> bin再加载、解码、执行db -> 恶意功能实现在db中，整个就是一套跳板
**当然只是猜测，我们顺着这个思路来尝试一下：**
思路1、既然是先解码再调用，那会不会这两步是连在一起的，也就是说找到了解码函数就离调用不远了呢？
思路2、解码后，要把解码得到的可执行代码放到一块内存，这块内存还要设置成可执行的属性才行，这样的话是否可以利用VirtualAlloc压栈0x40来定位呢？找一下push
0x40就行
还真别说，稍稍往下一看，隔了没几行代码，还真找着了：
看到了push
40，后面push的值也和之前类似，可以断定最下面那个call就是VirtualAlloc，设置了一块可执行内存，那么上面那俩神秘函数有可能是base64解码也说不定。
我们把这三个call都下断点，去跑一下：
1：我们先进入第一个call，看了看有一些字母表数字表的字符串处理，所以应该是和base64有关，有可能是初始化对照表吧
2：完了以后就是第二个call，可以看到第二个call是有两个参数的，分别是ebx和esi压进去做了参数，此外还mov了一个edi，我们在第二个call下个断点，断到那儿以后回头看这仨寄存器的值：
esi和edi对应了两块内存，对应看：
可见esi是一个未经写入的新内存区域，而edi指向的是之前db文件载入的base64编码
我们往上回溯看一下两个寄存器的来源，就可以看出：在call 0x3510143和读db的call
ReadFile之间，还有一个VirtualAlloc的调用，它返回的内存指针eax，mov给了现在的esi；而之前用来存db内容的VirtualAlloc得到的返回指针也是由eax，mov给了现在的edi
而作为参数之一的ebx寄存器，细心往上回溯也可以找到来源：是GetFileSize的返回至mov给它的（夹在中间那个VirtualAlloc也用的它的大小）
也就是说，在进入第二个call之前：传的两个参数是 **db文件的大小** 和 **对应着这个大小的空内存区域**
，并且还把db文件base64编码内容的内存指针拷贝给了edx
结合这一层分析，我们开动脑洞来猜一下第二个call要干嘛，如果说edx也是个函数接口的化，那么可以认为这个函数有三个参数：大小、空内存、base64编码内存