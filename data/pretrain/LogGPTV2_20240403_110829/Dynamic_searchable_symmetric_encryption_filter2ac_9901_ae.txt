not depend on the number of ﬁle/word pairs in the index.
And their cost per unique word is essentially independent
(modulo a very small constant cost) of the total number of
unique words (or ﬁles) in each operation. So, we present
only the per-word (or per-ﬁle) time for these operations.
Table 2 shows the costs for each operation. For ease of
exposition, we show numbers only for the executions of the
SSE algorithm on the document data set; the numbers for
the email data set and the synthetic data are similar. Search
token generation takes a constant amount of time (a mean
of 35 µs), irrespective of the number of ﬁles that will be
returned from the search. The results show that search and
ﬁle addition and deletion on the client side are eﬃcient and
practical, even for common words, or ﬁles containing many
unique words.
6.2.2 Full performance
To evaluate the performance of SSE as a whole, we ran
the SSE algorithms speciﬁed in § 4 on the email, document
and media data sets. Note that all algorithms displayed on
the graphs have non-zero cost, but in some cases, the cost is
so small compared to the cost of other parts of the operation
that this cost cannot be seen on the graph.
Figure 5 shows the results of the encryption operation,
which takes the most time of any of the algorithms. Note
that the entire encryption protocol is performed in addition
to indexing that must be executed by the client before the
data can be stored.
974)
s
(
e
m
T
i
52
33
14
SSE.Enc
SKE.Enc
53
34
17
)
s
m
(
e
m
T
i
4 11 16
Emails
8 100 250 500
Documents
8 100 250 500
Media
File Collections (with size in MB)
4 11 16
Emails
8 100 250 500
Documents
8 100 250 500
Media
File Collections (with size in MB)
Figure 5: Execution time for SSE.Enc and SKE.Enc.
Figure 6: Execution time for SSE.Search.
Figure 5 shows the diﬀerence between the email data and
the document data. The Enron emails are a collection of
plain text ﬁles, including email headers, so almost every byte
of the ﬁles is part of a word that will be indexed. So, each
small ﬁle contains many words, and the ratio of ﬁle/word
pairs to the size of the data set is high. By contrast, Mi-
crosoft Oﬃce documents may contain signiﬁcant formatting
and visual components (like images) which are not indexed.
So, the ratio of ﬁle/word pairs to ﬁle size is much lower.
Both data sets represent a common case for oﬃce use: our
results show that SSE index generation requires signiﬁcantly
more time for large text collections than for the common of-
ﬁce document formats. Finally, the ratio of indexable words
to ﬁle size is almost zero for the media ﬁles.
The micro-benchmark results of Figure 4 show that SSE
index generation performance is linear in the number of
ﬁle/word pairs for large data sets. So, for an email data
set of size 16 GB (consisting entirely of text-based emails:
i.e., emails containing no attachments), the initial indexing
costs would be approximately 15 hours (which could be per-
formed over the course of a day during the idle time of the
computer). After this initial indexing, adding and removing
emails would be fast.
To evaluate the costs of the remaining SSE algorithms
we performed experiments that gave upper bounds on the
cost of any operation. An upper bound for SSE.Search is a
search for the word contained in the most ﬁles. Our update
operations, use the ﬁle with the most bytes on disk.
Since search was performed for the word that was indexed
for the most ﬁles, the total time needed for the search de-
pended on the prevalence of words in ﬁles: media ﬁles had
few words, even in 500 MB of content, whereas some words
occur in every email. Figure 6 gives the time needed for
the server to perform a search, given a search token (we
neglect the cost of generating a search token, since it is a
small constant in microseconds). The SSE search costs were
small, even for the email index. However, even the longest
searches took only about 50 ms to complete. And for large
media collections, the search time was negligibly small.6
Figure 7 shows the execution time for adding a ﬁle. The
6Note that in our workloads, the time to decrypt all ﬁles re-
turned from search dominates the search costs by orders of
magnitude. Higher-level protocols could mitigate this cost
by using the SSE primitive in a diﬀerent manner:
instead
of storing the ﬁles directly, it could store short, ﬁxed-length
descriptions of the ﬁles. The client could decrypt these re-
sults quickly then use their information to decide which ﬁles
to download and decrypt. This would also allow clients to
delete a ﬁle without downloading the ﬁle from the server.
500
250
)
s
m
(
e
m
T
i
0
Enc
SSE.Add
SSE.AddToken
4 11 16
Emails
8 100 250 500
Documents
8 100 250 500
Media
File Collections (with size in MB)
Figure 7: Execution time for adding a ﬁle.
cost of the operation is divided into several components:
“Enc” refers to the time needed to encrypt the new ﬁle,
“SSE.AddToken” refers to client generation of the add to-
ken for the words being indexed in the ﬁle, and “SSE.Add”
refers to the server using the add token to update the in-
dex. The costs of adding a ﬁle fall mostly on the client:
the dominant costs are SSE add token generation, and ﬁle
encryption, both performed on the client.
In a use case
where add operations dominate (such as indexing encrypted
emails), this allows the server to support many clients easily,
since the client that performs the add also performs most of
the computations.
A similar situation occurs in Figure 8 for deleting a ﬁle.
The label “SSE.DelToken” refers to client generation of the
delete token, and “SSE.Del” refers to the server using the
delete token to update the index. As for add, the delete
operation is eﬃcient and practical; each operation on the
largest ﬁles took approximately half a second.
130
100
75
)
s
m
(
e
m
T
i
0
SSE.DelToken
SSE.Del
4 11 16
Emails
8 100 250 500
Documents
8 100 250 500
Media
File Collections (with size in MB)
Figure 8: Execution time for deleting a ﬁle.
9757. CONCLUSION
Searchable encryption is an important cryptographic prim-
itive that is well motivated by the popularity of cloud storage
services like Dropbox, Microsoft Skydrive and Apple iCloud
and public cloud storage infrastructures like Amazon S3 and
Microsoft Azure Storage. Any practical SSE scheme, how-
ever, should satisfy certain properties such as sublinear (and
preferably optimal) search, adaptive security, compactness
and the ability to support addition and deletion of ﬁles.
In this work, we gave the ﬁrst SSE construction to achieve
all these properties. In addition, we implemented our scheme
and evaluated its performance. Our experiments show that
our construction is highly eﬃcient and ready for deployment.
Acknowledgements
The authors are grateful to Jason Mackay for writing the
indexer that was used in the experiments. The second au-
thor was partially supported by the Kanellakis fellowship at
Brown University and by Intel’s STC for Secure Computing.
8. REFERENCES
[1] G. Amanatidis, A. Boldyreva, and A. O’Neill.
Provably-secure schemes for basic query support in
outsourced databases. In Proc. Working Conference
on Data and Applications Security (DBSEC), pages
14–30, 2007.
[2] M. Bellare, A. Boldyreva, and A. O’Neill.
Deterministic and eﬃciently searchable encryption.
Proc. Int. Cryptology Conference (CRYPTO), pages
535–552, 2007.
[3] M. Bellare, R. Canetti, and H. Krawczyk. Keying hash
functions for message authentication. Proc. Int.
Cryptology Conference (CRYPTO), pages 1–15, 1996.
[4] D. Boneh, G. Di Crescenzo, R. Ostrovsky,
G. Persiano. Public key encryption with keyword
search. Proc. Int. Conference on the Theory and
Applications of Cryptographic Techniques
(EUROCRYPT), pages 506–522, 2004.
[5] Y. Chang and M. Mitzenmacher. Privacy preserving
keyword searches on remote encrypted data. Proc.
Applied Cryptography and Network Security (ACNS),
pages 442–455, 2005.
[6] M. Chase and S. Kamara. Structured encryption and
controlled disclosure. In Proc. Int. Conference on the
Theory and Application of Cryptology and Information
Security (ASIACRYPT), pages 577–594, 2010.
[7] Cryptography API: Next generation (Windows).
http://msdn.microsoft.com/library/aa376210.aspx.
[8] R. Curtmola, J. Garay, S. Kamara, and R. Ostrovsky.
Searchable symmetric encryption: Improved
deﬁnitions and eﬃcient constructions. In Proc. ACM
Conference on Computer and Communications
Security (CCS), pages 79–88, 2006.
[9] R. Curtmola, J. Garay, S. Kamara, and R. Ostrovsky.
Searchable symmetric encryption: Improved
deﬁnitions and eﬃcient constructions. Journal of
Computer Security, 19(5):895–934, 2011.
[10] Y. Dodis, T. Ristenpart, J. Steinberger, and
S. Tessaro. To hash or not to hash again?
(in)diﬀerentiability results for H 2 and HMAC. Proc.
Int. Cryptology Conference (CRYPTO), 2012.
[11] Enron email dataset.
http://www.cs.cmu.edu/˜enron/, 2009.
[12] FIPS 180-3. Secure Hash Standard (SHS). Federal
Information Processing Standard (FIPS), Publication
180-3, National Institute of Standards and Technology,
Washington, DC, October 2008.
[13] FIPS 197. Advanced Encryption Standard (AES).
Federal Information Processing Standard (FIPS),
Publication 197, National Institute of Standards and
Technology, Washington, DC, November 2001.
[14] M. Fredman, J. Komlos, and E. Szemeredi. Storing a
sparse table with O(1) worst case access time. Journal
of the ACM, 31(3):538–544, 1984.
[15] E.-J. Goh. Secure indexes. Technical Report 2003/216,
IACR ePrint Cryptography Archive, 2003.
http://eprint.iacr.org/2003/216.
[16] O. Goldreich and R. Ostrovsky. Software protection
and simulation on oblivious RAMs. Journal of the
ACM, 43(3):431–473, 1996.
[17] W. H¨ormann and G. Derﬂinger. Rejection-inversion to
generate variates from monotone discrete
distributions. ACM Transactions on Modeling and
Computer Simulation, 6(3):169–184, 1996.
[18] M. Islam, M. Kuzu and M. Kantarcioglu. Access
Pattern disclosure on Searchable Encryption:
Ramiﬁcation, Attack and Mitigation. Network and
Distributed System Security Symposium (NDSS ’12),
2012.
[19] S. Kamara and K. Lauter. Cryptographic cloud
storage. In Proc. Workshop Real-Life Cryptographic
Protocols and Standardization (RLCPS), pages
136–149, 2010.
[20] J. Katz and Y. Lindell. Introduction to Modern
Cryptography. Chapman & Hall/CRC, Boca Raton,
FL, 2008.
[21] K. Kurosawa and Y. Ohtaki. UC-secure searchable
symmetric encryption. In Proc. Financial
Cryptography and Data Security (FC), 2012.
[22] D. Song, D. Wagner, and A. Perrig. Practical
techniques for searching on encrypted data. In Proc.
Symposium on Research in Security and Privacy
(SSP), pages 44–55, 2000.
[23] P. van Liesdonk, S. Sedghi, J. Doumen, P. H. Hartel,
and W. Jonker. Computationally eﬃcient searchable
symmetric encryption. In Proc. Workshop on Secure
Data Management (SDM), pages 87–100, 2010.
[24] G. K. Zipf. Psycho-Biology of Languages.
Houghton-Miﬄin, Boston, 1935.
976