的空闲存储空间。因为所有的引用都必须在同－时刻进行分析，所以我们还可以选择将可达对
是不可达的。但是一且计算得到可达集合，它就可以立刻找到很多不可达对象，并同时确定大量
达对象，并为它们加上同样的标号。这个方法必须首先跟踪所有的引用，然后才能决定哪些对象
根集中的所有对象加上“可达的”标号，然后重复地检查可达对象中的所有引用，找到更多的可
们将在7.5.3节中更详细地讨论这个方法。
的动作时，维护了指向各个对象的引用的计数。当计数器变成0时，相应的对象变得不可达。我
计数技术是一种著名的近似实现第一种方法的技术。我们在增变者执行可能改变可达对象集合
以周期性地定位出所有可达对象，然后推出所有其他对象都是不可达的。7.4.5节中介绍的引用
束可能结束对象的可达性。当一个对象变得不可达时，可能会导致更多的对象变得不可达。
会被删除。使用引用计数的垃圾回收器时，每个对象必须有一个用于存放引用计数的字段。
一个指向这样的变量的引用是一个编程错误，不会要求编译器去改正程序中的这个错误。
量分配在栈中呢？答案是很多语言的语义要求局部变量在它们的过程返回后不再存在。保留
失了，从而产生了－个悬空指针的情况。我们是否应该象C所作的那样将象这样的局部变
针被放置在非局部变量中。这些指针将在这个过程返回之后继续存在，但是存放的空间消
引用计数有两个主要的缺点：它不能回收不可达的循环数据结构，并且它的开销较大。循环
5）可达性的传递丢失。当一个对象的引用计数变成〇时，我们必须将该对象中的各个引用
4）过程返回。当一个过程退出时，该过程活动记录的局部变量中所指向的对象的引用数必
现在，我们考虑一个简单但有缺陷的基于引用计数的垃圾回收器。当一个对象从可达转变
302
3）引用赋值。如果u和α都是引用，对于语句μ=,指向的对象的引用计数加1，μ本来指
第二种方法传递地跟踪所有的引用，从而计算可达性。一个基于跟踪的垃圾回收器首先为
2）参数传递。衣
1）对象分配。新对象的引用计数被设置为1。
有两种寻找不可达对象的基本方法。我们可以捕获可达对象变得不可达的转变时刻，也可
总而言之，新的对象通过对象分配被引人。参数传递和赋值可以传递可达性；赋值和过程结
·过程返回。当一个过程退出时，保存其局部变量的活动记录将被弹出栈。如果这个活动记
当一个过程被调用时，一个局部变量的对象被分配在栈中。
的对象保存了指向其他对象的唯一引用，那么那些对象也将变得不可达，以此类推。
录中保存了某个对象的唯一引用，那个对象就变得不可达。同样，如果这个刚刚变得不可达
被传递给一个过程的每个对象的引用计数加一。
栈对象的残存问题
，可能会有一些指向的指
第7章
三
---
## Page 319
7.5.47.5节的练习
较低的空间使用量。
引用计数是一种特别有吸引力的算法。这个方法的另一种优势是垃圾被及时回收，从而保持
因此，当应用必须满足某个时间期限时，或者对于不能接受长时间突然停顿的交互式系统而言，
我们可以很容易地延期执行递归地修改引用计数的运算，并在不同的时间点上逐步完成修改。
这些运算分布在增变者的整个计算过程中。尽管删除一个引用可能致使大量对象变得不可达，
不会被当作垃圾。
包括来自程序根集的引用。除非扫描整个根集仍没有找到指向某一对象的引用，否则这个对象
了消除因这种更新而引起的时间开销，人们提出了延期引用计数的概念。也就是说，引用计数不
需要特别考虑的是对一个程序的根集中的引用的更新。局部栈访问会引起引用计数的更新，为
任何类似的结构永远不会被回收。
同于一次内存泄漏，因为这种垃圾以及
引用计数都大于0。如果我们在垃圾[
一个额外运算。这个开销和程序中的计算量成正比关系，而不仅仅和系统中的对象数目相关。
分的引用。如果这些对象都不是根集的
它们之间的引用，但是没有来自其他部
例7.11
而形成交叉引用。
员，那么它们都是垃圾，但是它们的
运行时刻环境
另一方面，引用计数的优势在于垃圾回收是以增量方式完成的。尽管总的开销可能很大，
引用计数的开销比较大，因为每一次引用赋值，以及在每个过程的入口和出口处，都会增加
练习7.5.2：当图7-20 中的从 A 到D 的指针被删除时，引用计数会发生什么样的改变？
2）
练习7.5.1；当下列事件发生时，图7-19中的对象的引用计数会发生哪些改变？
3）
结点C被删除。
从 X指向 A 的指针被删除。
从 A指向 B 的指针被删除。
图7-18 给出了三个对象以及
图7-19
G
一个对象网络
?
口
等
回
图 7-18
---个不可达的循环数据结构
图 7-20
另一个对象网络
外有米自针
303
但
---
## Page 320
时这些对象的 reached 位被设置为1。第(2)行到第(7)行是一个循环，在此循环中我们逐个检查
位)。在算法开始之前，所有已分配对象的 reached 位都被设定为0。
列表Unscamned 最初为空。另外，每个对象包括一个比特，用来指明该对象是否可达（即 reached
闲/已用状态和大小。
空闲空间列表（free list）。和7.4.4 节中--样，所有空间块都用边界标记进行标识，指明它们的空
来保存所有已分配对象，使得它对每个可达对象只访问一次。
不可达的对象，并将它们放入空闲空间列表。算法7.12在一开始的跟踪步骤中访问并“标记”所
7.6.1基本的标记－清扫式回收器
可能具有的四种状态来描述多个基于跟踪的算法。这一节中还包含了一些对基本算法的改进，
象并收回它们的空间。通常的做法是在空闲空间被耗尽或者空闲空间数量低于某个阈值时启动
7.6基于跟踪的回收的介绍
的后继对象的可达性。也就是说，我们还没有扫描这些对象来确定通过它们能够到达哪些对象。
算法7.12
性框架之后，我们将考虑算法7.14，它是算法7.12的一个优化。算法7.14使用---个附加的列表
有的可达对象，
包括那些将对象重定位加人到垃圾回收功能中的算法。
垃圾回收器。
标记－清扫式（mark-and-sweep）垃圾回收算法是一种直接的全面停顿的算法。它们找出所有
在本节中，我们首先介绍最简单的“标记－清扫式”垃圾回收算法。然后我们将通过存储块
304
在图 7-21的第(1)行，我们初始化 Unscanned 列表，在其中放人所有被根集引用的对象。
--个名为Unscamned 的列表保存了我们已经确定可达的对象，但是我们还没有考虑这些对象
方法：在图 7-21 中显示的算法使用了几个简单的数据结构。列表Free 保存了已知的空闲对
输出：在删除了所有垃圾之后的经过修改的 Free 列表。
基于跟踪的回收器并不在垃圾产生的时候就进行回收，而是会周期性地运行，寻找不可达对
标记－清扫式垃圾回收。
然后“清扫"整个堆区并释放不可达对象。在介绍了基于跟踪的算法的一个一般
Free = 0;
/*清扫阶段*/
图7-21
一个标记－清扫式垃圾回收器
即它的reached位为 0)将o加人到Free中；
(0%  
第7章
同
---
## Page 321
方法上有所不同，但是它们都可以通过下列状态进行描述：
数据结构隐含地表示。
该块内部，也可以使用垃圾回收算法的某个
明这个循环。一个存储块的状态可以存储在
的、未被访问的、待扫描的和已扫描的)说
空间。
配请求。
按照下列方式循环使用的：
合，然后取这个集合的补集。因此，内存是
7.6.2基本抽象
时，其前置条件得到满足。
第(11)行处理可达对象。我们将它们的 reached 位设为0，以便在这个垃圾回收算法下一次运行
达对象的集合，这个算法将清扫整个堆区。第(10)行将空闲且不可达的对象逐个放人Free 列表。
象的空间。请注意，这些对象将包括所有原本就在Free 列表中的对象。因为无法直接枚举不可
述讨论中的对象。它正在被扫描。虚线对应于可能从到达的三种类型的对象：
说明了这个过程。它显示了一个带有四个对象的 Unscanned 列表。列表中的第一个对象对应于上
要在第(6)行将它的 reached 位设置为1，并在第(7)行中将o'加人到 Unscanned 列表中。图 7-22
被扫描过，要么已经在 Unscanned 列表中等待扫描。然而，如果o'还没有被访问到，那么我们需
每个已经被放入 Unscanned 列表中的对象。
运行时刻环境
虽然不同的基于跟踪的算法可能在实现
 图7-23 按照存储块的四种状态（空闲
3）垃圾回收器收回不可达对象的存储
 1）程序(或者说增变者)运行并发出分
所有基于跟踪的算法都计算可达对象集
2）垃圾回收器通过跟踪揭示可达性。
3）-一个可达的数据项，但是之前它被认为是未被访问的。
从第(4)行到第(7)行的for循环实现了对对象o的扫描。我们检查每个在。中被引用的对象
第(8)行到第(11)行是清扫阶段，它收回所有那些在标记阶段结束之后仍然未被访问到的对
2）当前在 Unscanned 列表中的对象。
1）之前扫描过的对象，它不需要被再次扫描。
图7-22
一个标记－清扫式垃圾回收器的标记阶段中对象之间的关系
--———-
图7-23在一个垃圾回收循环中的存储块的状态
已扫描的
空闲的
空闲的
a）跟踪之前：增变者的动作
b)通过跟踪发现可达性
c）回收存储空间
回收
分配
未被访问的
未被访问的
305
---
## Page 322
对象的列表。
算法7.14
以求已分配对象和可达对象之间的差集。
的对象。我们必须将不可达对象的存储返回给空闲空间。为了找出不可达对象的集合，我们可
整个堆区就找到所有不可达对象。由 Baker 提出的一个优化算法用一个列表记录了所有已分配
7.6.3标记－清扫式算法的优化
用算法 7. 12 中的数据结构来刻画四种状态的方式。
位，以及是否在列表 Free 和 Unscanned 中，我们可以区分全部四种状态。图7-24 中的表格归纳了
例7.13，我们看一下算法7.12中的数据结构与上面介绍的四种状态有什么关系。使用 reached
在那个时候，当前可达的某些对象可能实际上已经被变成了不可达的。
被访问状态是正确的，因为当下一轮垃圾回收开始时，我们将要求所有对象都从这个状态出发
状态，见图7-23c中的虚线转换。再次提醒大家，这些对象现在确实是可达的。将它们设定为未
图7-23c 中实线转换所示。为了准备下一轮垃圾回收，处于已扫描状态中的对象将回到未被访问
的对象确实是不可达的。垃圾回收器收回它们占用的空间，并将这些存储块置于空闲的状态，如
引用，决不会包含指向未被访问对象的引用。
访问的对象，那么该对象将被设为待扫描状态。当对一个对象的扫描结束时，这个对象被放人已
我们检查其内部的各个指针，并且沿着这些指针找到它们引用的对象。如果引用指向一个未被
个块可达时，就会发生一个从未被访问状态到待扫描状态的转换，如图7-23b 所示。
个存储块是可达的，但是该块中的指针还没被扫描，那么该块就处于待扫描状态。当我们发现某
态到未被访问状态的转换。这个转换用虚线显示，以强调它是为下一轮处理做准备。
所示，当一个存储块被存储管理器分配出去时，它的状态就被设置为未被访问的。一轮垃圾回收
过程中的任何时刻，如果还没有确定一个块的可达性，该块就处于未被访问的状态。如图7-23a
达对象。
4）已扫描的。每个待扫描对象最终都将被扫描并转换到已扫描状态。在扫描一个对象时
3）待扫描的。已知可达的存储块要么处于待扫描状态，要么处于已扫描状态。如果已知一
后，可达对象的状态仍然会被重置为未被访问状态，以准备下一轮处理，参见图中从已扫描状
2）未被访问的。除非通过跟踪证明存储块可达，否则它被默认为是不可达的。在垃圾回收
输入：
基本的标记－清扫式算法的最后一步的代价很大，因为没有一个容易的方法可以不用检查
当不再有对象处于待扫描状态时，可达性的计算就完成了。到最后仍然处于未被访问状态
1）空闲的。存储块处于空闲状态表示它可以被分配。因此，一个空闲块内不会存放任何可
306
方法：这个算法如图7-25 所示。算法中用于垃圾回收的数据结构是名字分别为 Free、
输出：经过修改的 Free 列表和 Unreached 列表。Unreached 列表保存了被分配的对象。
一-个由对象组成的根集，一个堆区，--个空闲列表 Free，一个名为 Unreached 的已分配
Baker 的标记－清扫式回收器。
状态
闲
图7-24算法7.12 中状态的表示方式