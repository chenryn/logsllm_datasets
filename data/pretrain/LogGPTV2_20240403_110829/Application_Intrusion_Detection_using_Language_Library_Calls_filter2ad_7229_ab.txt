### 3.4 False Positives vs. False Negatives

Intrusion detection systems (IDS) make binary decisions based on the observed values of anomaly measures: a sequence is either classified as anomalous or normal. There are two types of classification errors: false positives and false negatives [4]. A false positive, also known as a false alarm, occurs when a legitimate sequence is incorrectly classified as anomalous. Conversely, a false negative occurs when an intrusion-generated sequence is incorrectly classified as normal, meaning that all sequences generated by the intrusion appear in the signature database.

System administrators generally prefer to minimize both types of errors, but they are more willing to tolerate false negatives than false positives. This is because false negatives can be mitigated by adding layers of defense, while layering does not reduce overall false positives and may even increase them. The primary reason for false positives is the difficulty in collecting comprehensive signature sequences for all normal behaviors in complex applications. To manage this, we set thresholds on the normalized anomaly signal (\(\land AS\)) to limit false positives. We consider an intrusion to be in progress when \(\land AS\) exceeds a threshold \(C\) (where \(0 \leq C \leq 1\)). In our experiments, we set \(C = 0.5\).

### 4. Experimental Environment

Our experiments with the library call approach were conducted using a variety of Unix applications, ranging from small utilities like `ls` and `ps` to large applications such as the Apache HTTP server and MiniSQL. These applications differ in size and privilege. Some run as privileged processes (e.g., `wu-ftpd`), while others (e.g., `finger`) do not. Our results showed no significant difference in the efficiency of our intrusion detection method based on these factors.

All signature data reported in this paper were derived from experiments performed under Linux, a Unix-based operating system. We chose Linux due to its freely available source code, developed under the GNU General Public License. Specifically, we used Red Hat 5.2 with kernel version 2.0.36. This early kernel version was selected to facilitate comparison with previous research on intrusion detection using system calls, which was also conducted with this kernel version.

### 5. Experimental Results

#### 5.1 Building Robust Signature Databases

To build robust signature databases, we extensively exercised the applications to generate a sufficient portion of legitimate library call sequences, ensuring that the false positive rate remains tolerable. Figure 2 illustrates the incremental generation of sequences for the `ps` program, which reports process status. Initially, the database size increases rapidly, but the number of new unique sequences added gradually decreases. We define the database as sufficiently robust when the growth rate flattens, i.e., the number of unique sequences added per total sequences generated falls below a predefined threshold.

Signature databases vary in size, with larger applications typically having larger databases. For example, our signature database for the Apache HTTP server contains 1,383 unique sequences of length 10, while the `ps` signature database contains only 571 unique sequences of the same length. Given that `ps` uses no more than 60 different C library calls, the possible number of sequences for \(k=10\) is \(60^{10}\). Thus, our `ps` signature database represents a very small fraction of the total possible sequences.

#### 5.2 Distinguishing Between Programs

We compared the sequences generated by one application with the signature databases of other applications to determine if library call sequences could distinguish between different programs. If we could not distinguish between two applications in the absence of intrusion, then library call sequences would not be effective for intrusion detection.

For varying sequence lengths, we compared the sequences of one application against the signature databases of other applications. When the sequence length is very low (close to one), there are few mismatches. As the sequence length increases to \(k=30\), mismatches become almost 100% against all applications. Table 1 shows the results of comparing the Apache HTTP server with other Unix utilities for \(k=10\), using the New Mexico STIDE tool.

| Program     | Number Mismatches | % Mismatches |
|-------------|-------------------|---------------|
| `ls`        | 209               | 76            |
| `ls -l`     | 360               | 84            |
| `ls -a`     | 356               | 69            |
| `finger`    | 239               | 100           |

These results indicate that each program has a significant number of different sequences from the Apache HTTP server's signature database (at least 69%). This demonstrates that the behavior of different programs is distinguishable using sequences of C library calls, confirming that library call signatures can effectively characterize applications.

#### 5.3 Sequence Length Analysis

We conducted experiments to explore the relationship between library call sequence length and intrusion detection. Using known attacks that exploit vulnerabilities in the Apache HTTP server, we successfully detected intrusions with our library call signature.

Table 2 shows the intrusion detection results for sequence length \(k=10\). Although the percentage of mismatches is low, the normalized anomaly signal (\(\land AS\)) indicates potential intrusions, as the most anomalous sequence differs from normal sequences in over 70% of its positions.

| Attack                               | Number Mismatches | Percent Mismatches | \(\land AS\) |
|--------------------------------------|-------------------|--------------------|--------------|
| Remote Phf Command Execution         | 251               | 1.5%               | 0.7          |
| nph-test-cgi Vulnerability           | 777               | 3.9%               | 0.8          |

We varied the sequence length \(k\) from 2 to 30. The minimum length used is 2 because \(k=1\) yields \(\land AS = 0\) or \(\land AS = 1\), which is meaningless for sequence analysis. The maximum length used is 30. We observed that adequate detection can be achieved with much shorter sequences. From Figure 3, we conclude that varying the sequence length has little effect on the value of \(\land AS\). Therefore, sequence length 10 is sufficient for detecting the phf vulnerability attack, and sequence length 9 is sufficient for the nph-test-cgi vulnerability attack. In our experiments, we chose sequence length 10 to allow for some margin of error while maintaining acceptable computation cost.

#### 5.4 Various Intrusion Detection Experiments

To test the effectiveness of the library call approach in detecting intrusions, we experimented with various applications and intrusion types, including Buffer Overflow, Trojan programs, and Denial of Service. The purpose of these experiments was to evaluate the robustness and reliability of our method in real-world scenarios.