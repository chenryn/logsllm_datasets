in the signature database, every sequence in the database
must be checked to determine dmin (s). Assume that N is
the  number  of  sequences  in  the  signature  database,  then
the cost totals k*N comparisons. In reality mismatches are
rare, so most of time, the algorithm confirms matches at a
cost  of  k  comparisons.  If  the  rate  of  mismatches  to
matches is RA, then the average complexity of computing
dmin  (s)  per  sequence  is  (k*N*RA)  +  k*(1-RA),  which  is
O(k*RA*N).
The  normalized  anomaly  signal, 
∧
AS ,  expresses  how
much  a  monitored  sequence  deviates  from  the  signature
database in a way that is independent of sequence length.
∧
AS ,  is
The  value  of  the  normalized  anomaly  signal, 
between 0 and 1.
All  three  anomaly  measures  can  be  used  to  express
thresholds, that when crossed, indicate the probability that
an intrusion has occurred.
3.4 False positives vs. false negatives
An  intrusion  detection  system  can  make  intrusion
detection  decisions  based  on  the  observed  values  of  the
above  measures.  In  the  simplest  case,  these  are  binary
decisions: Either a sequence is anomalous, or it is normal.
There are two types of classification errors: false positives
and false negatives [4]. A false positive, also known as a
3
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:05:52 UTC from IEEE Xplore.  Restrictions apply. 
legitimate  behavior 
false  detection  or  false  alarm,  occurs  when  a  sequence
generated  by 
is  classified  as
anomalous.    A  false  negative  occurs  when  none  of  the
sequences  generated  by  an  intrusion  are  detected  as
anomalous, i.e., all sequences  generated  by  the  intrusion
appear in the signature database.
We would like to minimize both types of classification
errors.  But  system  administrators  are  more  willing  to
tolerate false negatives than false positives because false
negatives  can  be  reduced  by  adding  layers  of  defense
while  layering  will  not  reduce  overall  false  positives.  In
some  cases,  layering  even  compounds  false  positives.
The  reason  for  false  positives  is  that  in  reality  it  is
difficult  to  collect  signature  sequences  of  all  normal
behavior  for  a  complex  application.  Therefore,  we  set
thresholds  on  the  normalized  anomaly  signal  values  to
limit  false  positives.  We  regard  an  intrusion  to  be  in
∧
AS ,  is
progress  when  the  normalized  anomaly  signal, 
greater than C (0 <= C <= 1) where C is chosen based on
experience. In our following experiments, we chose C as
0.5.
4. Experimental environment
We experimented with our library call approach using
a  variety  of  applications  in  Unix.  These  programs  vary
from  small  applications  (e.g.,  ls  and  ps)  to  large
applications  (e.g.,  the  Apache  httpd  server,  and  Mini
SQL). The applications differ not only in size, but also in
privilege.  Privileged  processes  perform  services  that
require access to system resources  normally  inaccessible
to  ordinary  users.  In  our  experiments,  some  applications
run  as  privileged  processes  (e.g.,  wu-ftpd),  while  others
(e.g.,  finger)  execute  without  privilege.  We  observed  no
difference  in  the  efficiency  of  our  intrusion  detection
method based on this difference.
All signature data reported in this paper were derived
from  experiments  performed  under  Linux,  a  Unix-based
operating  system.  We  selected  Linux  since  its  source
code,  which  was  developed  under  the  GNU  General
Public License, is freely available. We used Red Hat 5.2
version  of  Linux  with  kernel  version  2.0.36.  We  chose
such an early kernel version because all experiment data
about intrusion detection using sequences of system calls
by the New Mexico researchers were conducted with this
version of the kernel. We wanted to compare our library
call approach with their system call approach in a similar
environment.
5. Experimental results
Our  experimentation  required  that  we  build  signature
databases  for  our  selected  applications.  As  discussed  in
the previous section, we chose to build synthetic signature
databases. Next we performed experiments to determine if
it  is  possible  to  detect  intrusions  that  exploit  security
flaws in our selected applications. We needed to identify
the vulnerabilities, i.e. weakness that could be exploited,
in 
these  applications.  In  a  controlled  experimental
environment, 
intrusions  were  performed.  Then  we
analyzed  the  intrusion  detection  results  and  compared
them with the results of other approaches.
5.1 Build robust signature databases
This section explains the construction of experimental
signature databases. A signature database is described as
robust  if  the  database  records  a  sufficient  portion  of  the
legitimate  sequences  of  library  calls  so  that  the  false
positive  rate  remains  tolerable.  Figure  2  shows  the
incremental  generation  of  sequences  to  be  added  to  the
signature  database  for  ps,  a  program  to  report  process
status.  To  build  the  signature  database,  the  application
was  exercised  extensively,  i.e.,  in  a  carefully  controlled
way  in  order  to  exercise  as  much  of  code  as  possible.
Unique sequences are added to the signature database as
encountered.  Figure  2  illustrates  that  the  database  size
initially increases rapidly. Gradually, the number of  new
unique  sequences  to  be  added  to  the  database  drops  off.
We define the database to be sufficiently robust when the
slope  of  growth  “flattens”,  i.e.,  the  number  of  unique
sequences  added  to  the  database  per  the  total  sequences
generated falls below a threshold set for the application.
Signature  databases  will  differ  greatly 
in  size.
Typically, larger applications (measured in source lines of
code) are associated  with  larger  databases.  For  example,
our signature database the Apache httpd server, the most
widely used web server, contains 1383 unique sequences
of  length  10.  However,  signature  databases  can  be  quite
compact.  For  example,  the  signature  database  for  ps
contains only 571 unique sequences of length 10. To put
this  in  context,  ps  contains  no  more  than  60  different  C
library  calls.  So,  for  k=10  there  are  6010  possible
sequences. Thus our ps signature database contains only a
very  tiny  percentage  of  the  total  possible  number  of
sequences from the use of 60 different library functions.
5.2 Distinguish between programs
In this section we discuss comparison of the sequences
generated by one application with the signature databases
of  other  applications.  We  reasoned  that  if  we  could  not
distinguish  between  two  applications  in  the  absence  of
intrusion, 
library  calls  do  not
characterize  an  application.  As  a  result,  sequences  of
library  calls  from  an  intrusion  are  unlikely  to  be
detectable.
then  sequences  of 
We  performed  this  comparison  for  varying  sequence
lengths. We simply compared the sequences in one
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:05:52 UTC from IEEE Xplore.  Restrictions apply. 
4
600
500
400
300
200
100
e
z
i
S
e
s
a
b
a
t
a
D
0
0
R obust S ignature D atabase - ps
2000
4000
6000
8000
10000
Total S eqences Scanned
Figure  2.  Derivation  of  a  signature  database  for  ps  program.  The  x-axis  indicates  the  total
sequences  generated,  and  the  y-axis  indicates  the  number  of  unique  sequences.  Sequence
length is 10.
against 
signature 
for 
databases 
database 
other
applications.    When  the  sequence  length  is  very  low
(close to one), there are very few mismatches. When the
sequence  length  reaches  k=30,  mismatches  are  almost
100% against all applications. Results of comparisons of
the Apache httpd server with other Unix utilities for k=10
are  presented  in  Table  1.  The  results  are  based  on  the
Apache  httpd  server  signature  database  described  in  the
previous  section.  We  used  New  Mexico  STIDE  tool  to
compare the traces of library calls of these utilities against
the Apache httpd database.
Program
ls
ls –l
ls –a
finger
Number Mismatches %Mismatches
209
360
356
239
76
84
69
100
from  other
Table  1.  Distinguishing  Apache
programs.  Each  column  reports  results  for  an
anomaly  measure:  mismatches  and  percentage  of
mismatches. Sequence length is 10.
Each  program  showed  a  significant  number  of
the  Apache  httpd  server
different  sequences  from 
signature  database 
results
least  69%).  The 
demonstrated  that  the  behavior  of  different  programs  is
distinguishable  using  sequences  of  C  library  calls,  i.e.,
library  call  signatures  can  be  used  to  characterize
applications.
(at 
5.3 Sequence length analysis
Next we preformed several experiments to explore the
relationship between the library call sequence length and
intrusion detection. We experimented with known attacks
that  exploit  the  vulnerabilities  [6]  in  the  Apache  httpd
server.  We  successfully  detected  intrusions  using  our
library call signature.
The intrusion detection results for sequence length k =
10  are  reported  below.  Although  the  percentage  of
∧
AS
mismatches  is  low,  the  normalized  anomaly  signal 
indicates  there  may  be  intrusions  because  the  most
anomalous  sequence  among  all  of  monitored  sequences
differs from the  normal  sequences  in  over  70  percent  of
its positions.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:05:52 UTC from IEEE Xplore.  Restrictions apply. 
5
Attacks  against
Apache
Number
Mismatches
Percent
Mismatches
Remote
Phf 
Command
Execution
nph-test-cgi
Vulnerability
   251
   777
   1.5 %
   3.9 %
∧
AS
0.7
0.8
Table  2.  Successful  detection  of  two  attacks
against  Apache.  Each  column  reports  results
for 
anomaly  measure:  mismatches,
percentage  of  mismatches,  and  normalized
anomaly signal. Sequence length is 10.
an 
∧
AS   =  0  or 
We  varied  sequence  length,  k,  from  2  to  30.  The
minimum  sequence  length  used  is  2  because  k=1  will
∧
AS   =  1,  which  is  meaningless  for
yield 
sequence  analysis.  The  maximum  sequence  length  used
here  is  30.    Note  that  the  cost  of  computation  increases
significantly  with  sequence  length.    We  observed  that
adequate detection resulted from much shorter sequences.
From  Figure  3,  we  can  conclude  that  varying  the
sequence  length  makes  little  difference  in  value  of  the
∧
AS . In other words, varying
normalized anomaly signal 
sequence  length  has  little  effect  on  intrusion  detection
using  C  library  call  signatures.  Also,  we  infer  that  the
intrusion detection result is stable if sequence length is
than  6.  Considering 
larger 
that  computation  cost
proportional to sequence length, we can see that sequence
length  10  is  sufficient  for  detecting  phf  vulnerability
attack  and  that  sequence  length  9  is  sufficient  for
detecting  nph-test-cgi  vulnerability  attack. 
In  our
experiments,  we  chose  sequence  length  10  to  allow  for
some  margins  of  error  while 
incurring  acceptable
computation cost.
5.4 Various intrusion detection experiments
To test the effectiveness of the library call approach in
detecting  intrusions,  we  experimented  with  a  variety  of
applications  and  intrusions,  including  Buffer  Overflow,
Trojan programs, and Denial of Service. The purpose of