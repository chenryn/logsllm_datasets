lutions are required. Consider a thermometer, having a very
small display and communicating using a short-range radio.
If we have a bowl of disinfectant containing many unused
thermometers, it doesn’t really matter which we choose;
but we want to make sure we communicate with the one
we have picked from the bowl. The thermometers could,
of course, be given artiﬁcial names (such as serial numbers,
which could be engraved on the case), but this solution isn’t
very user friendly. Instead, if we have a secure (free of ac-
tive middle-men) communications channel, such as short-
range infrared or physical contact, we can simply transmit
the public key over this channel.
To help application developers in verifying human
readable properties, our utility library provides support
for two common cases: names signed by some cen-
tral authority, and ownership of services (such as “John’s
siesta.pim.Calendar” service). The properties are repre-
sented by subclasses of java.security.Principal.
4.5 Application access control
When designing our system, the environment we had in
mind was a PDA using a single keypair stored on a smart-
card. This key would be used for accessing dozens of dif-
ferent services (using many different client applications).
Therefore, we wanted to restrict what applications could do
with the key. We call this feature “application access con-
trol”.
Since we use SPKI certiﬁcate chains for authorizations,
we can implement more complex restrictions than simply
allowing or denying access to the key. Our implementa-
tion stores these restrictions as a subclass of Permission.
The restrictions are associated with applications using the
standard Java 2 policy mechanisms [15]. The only case re-
quiring special treatment is the proxy class. Since the key
used for signing the code isn’t the same as the service key,
this must be associated with the permission later (when the
proxy state and code have been veriﬁed, as described in
When the proxy requests some permissions to be dele-
gated to its temporary key, the Jini security manager con-
structs the corresponding RemotePermission instance.
It
then uses the Java 2 stack inspection features (AccessCon-
troller) [37] to verify that the application is authorized for
this action.
4.6 Authorization checking
When the server has received a request from the proxy and
veriﬁed the proxy’s key, it gives the key and the certiﬁcates
to a SPKI certiﬁcate chain veriﬁer module. The veriﬁer
then veriﬁes certiﬁcate signatures and validity and ﬁnds all
certiﬁcate chains from the service key to the proxy key.
These chains are then stored inside a PermissionCollection
instance (PermissionCollections are used in the Java 2 se-
curity architecture to store a set of related permissions).
The service software can then call the implies() method
of the collection, giving a parameter corresponding to
the client request (the method then returns either true
or false).
Storing the authorizations inside a Permis-
sionCollection gives the service software another pos-
sibility.
It can use the AccessController.doPrivileged
to associate the permissions with the Java call
call
Permissions are then checked using normal
stack.
System.getSecurityManager().checkPermission() call.
In
many cases, this is a cleaner solution than passing a Per-
missionCollection object through a long chain of method
calls, or storing it in a visible variable. It also allows com-
municating these permissions to code which doesn’t know
the original call was a remote call.
4.7 RMI over TLS
Our architecture allows the proxy to implement any pro-
tocol for communicating with the service. In our tests, we
have used RMI. The default RMI conﬁguration uses normal
TCP sockets, but it is possible to override this behaviour by
supplying a pair of socket factories to be used on the server
and client side of the communication. This is meant for
plugging in Transport Layer Security (TLS) sockets.
Using these facilities, we implemented socket factories
for TLS client authentication using the Java Security Socket
Extension (JSSE) libraries [33]. During the implementa-
tion we found some slight deﬁciencies in the current RMI
implementation. Hopefully, most of these will be ﬁxed in
the next release of RMI, and in the RMI security extension
[32].
4.7.1 Problems with client authentication
Although the socket factories were originally intended for
plugging in TLS sockets, the design supports cleanly only
server authentication. The socket factories are given to the
constructor of java.rmi.server.UnicastRemoteObject which
is the base class of RMI server objects. The application
has no further control of the remote method invocation pro-
cess. The network connections are formed automatically
whenever the client invokes a remote method and a server
method is automatically executed with the arguments sent
over the network. Neither the client nor the server has direct
access to the underlying socket.
On the client side, it is difﬁcult to actually verify that the
stub is using the secure socket factory. Even more difﬁ-
cult is communicating the correct key to the socket factory,
since the socket might be opened even before any methods
are called (due to distributed garbage collection).
Similar problems appear also on the server side. Once a
call is received, there it no way to get access to the socket
instance it came from.
In the case of TLS sockets, the
socket would contain methods to get the client’s key.
We worked around these problems (sort of) by commu-
nicating the keys using thread-local variables, and control-
ling the deserialization of the stub by wrapping it inside a
MarshalledObject. We later found out that Balfanz et al.
had independently discovered a similar workaround [2].
4.7.2 Code bases
We also encountered a limitation in the way RMI serial-
izes stubs. When sending a serialized object to a remote
system, a codebase URL is included with it. The URL
speciﬁes the location where the bytecode can be down-
loaded. The current RMI implementation gets this code-
base URL from a global system conﬁguration property
named “java.rmi.server.codebase”. This makes running
multiple services inside the same JVM more difﬁcult.
Fortunately, if the proxy was originally loaded with a
subclass of java.net.URLClassLoader, its getURLs method
is called to get the codebase URL. If we load the proxy from
the URL on the server side as well, and instantiate and ini-
tialize it using the reﬂection API, the codebase gets set to
the correct value. We must, of course, verify the signature
on the bytecode on the server side to make sure we got the
right proxy.
4.8 Performance
Table 1 shows our initial performance ﬁgures. Basically,
the measurement represents the time required to delegate a
permission from the client to the server through the proxy.
As the measurements show, currently the authorization re-
Measurement
Standard Jini/RMI call
With SPKI and TLS applied
With pre-generated keys
average (ms)
30
6180
983
std dev
2
80
130
Table 1: The results of performance measurements,
measuring the time required for the ﬁrst remote method
call through an already authenticated proxy. The sec-
ond and subsequent calls take about 300 ms in the se-
cure case.
quires quite a lot of time. Most of the time is spent in Java
cryptographic primitives. However, our current implemen-
tation is quite unoptimized. In particular, the process re-
quires that a separate public key pair is created on the ﬂy;
these keys can be generated beforehand, and taken from a
pool of pre-generated keys during the protocol run. As the
table shows, this cuts the time required to a more reasonable
value.
We used Sun’s JDK 1.2.2 under Red Hat Linux 6.2 to
do our measurements. Both the client and the server were
run on the same machine, which was equipped with a 750
MHz AMD Athlon CPU and 256 MB of RAM. The mea-
surements were run ten times, and the average and standard
deviation were calculated.
5 Related work
5.1 Java security
Most work in Java security has focused on protecting the
host from malicious code. The original JDK 1.0 featured a
sandbox which limited the operations untrusted code could
invoke. Since then, the Java 2 security architecture [15]
added more ﬂexible and ﬁne-grained access control. A
number of other solutions have been proposed [36, 38, 19].
The Java 2 security architecture has been extended with
decentralized trust management in [27]. The concept of
"who is running the code" has been implemented in the Java
Authentication and Authorization Services (JAAS) [21],
and has been extended with roles in [14]. Controlling the
amount of resources (computational cycles, memory, etc.)
a program can use is discussed in [8].
5.2 Distributed object
security, mobile
agents
Most work related to remote object security has focused on
CORBA (for example, [3, 22, 31]). Although the concepts
in CORBA security are similar than in Jini, the problem
of untrusted proxy code requires different solutions. This
issue is discussed in Section 5.3 below.
The mobile agent research community has also produced
a lot of results related to mobile code and security. Most
of that work has focused on protecting sites from malicious
agents, and also on protecting agents from malicious hosts.
Often the situation is the reverse of that in Jini: a user sends
an agent to the service site, where it performs some func-
tions on behalf of the user. In Jini, the code moves from the
service to the client.
5.3 Solutions for downloaded proxy code
As explained in Section 1.3, communicating securely
through downloaded proxy code presents new security
challenges. There are a couple of solutions for this prob-
lem, and the following are reported in the literature.
• Fixed protocol.
If the communication protocol is
ﬁxed, proxies can be generated on the client side, ei-
ther statically (using an IDL compiler), or dynamically
on-the-ﬂy (cf. RMI security extension draft [32]).
Statically generated proxies are used by, e.g., Balfanz
et al. [2].
• Centrally signed proxies. The proxy code is signed
by some central authority, and if the signature is valid,
the code is considered fully trusted. This is used by
Hasselmeyer et al. [17] and in the Sun demonstration
solution presented at JavaOne 2000 [30].
• Mixed approach. In the RMI security extension draft
[32], it is also possible to combine dynamically gen-
erated proxies (implementing a ﬁxed protocol) with
signed hand-written proxies.
The hand-written proxy code and data are signed by
someone, usually the service. The “trust veriﬁer” ob-
ject is obtained from the service using the dynamically
generated RMI stub.
All of these approaches have their own beneﬁts and
drawbacks. Fixing the protocol eliminates the need to
download the proxies and allow communicating with any
service, but also lose the ability to implement part of the
proxy functionality on the client side. On the other hand,
requiring that the proxies are signed by some central au-
thority restricts spontaneous networking.
The mixed approach seems most promising of these
three, and resembles our approach in that the data and code
are effectively signed by the service (though the details are
quite different). However, it loses some of the protocol in-
dependence.
5.4 Jini-speciﬁc security
The security of speciﬁcally Jini systems hasn’t been studied
much yet. Sun presented a demonstration solution which
integrates Jini with JAAS at JavaOne 2000 [30]. It is based
on a centralized security server, and a certiﬁcate authority
(CA) signing all proxy code. It is somewhat similar to Ge-
offrey Clements’s Usersecurity project [7].
Hasselmeyer et al. have developed a Jini security solu-
tion based on a centralized secure lookup server [17]. Sim-
ilar secure service directory in non-Jini environment is de-
scribed by Czerwinski et al. in [9].
Sun’s future solution for Jini security is the RMI secu-
rity extension, currently in draft stage [32], which provides
at least some support for intelligent proxies. However, the
initial implementation of it only supports TLS based au-
thentication, which, in turn, relies on a centralized certiﬁ-
cate architecture, and separates the mechanisms for authen-
tication and access control. Furthermore, a trusted compo-
nent (not downloaded from the network) is responsible for
opening the network connections and implementing some
authentication protocol, so this might limit the protocol in-
dependence offered by Jini.
There is also a “Jini and Friends at Work” project going
on at Eurescom, but no results have been published so far
[13].
6 Evaluation and future work
In this project, our goal was to provide a Jini security so-
lution that does not unnecessarily restrict the possibilities
for creating secure Jini services. In particular, we wanted
our solution to be protocol independent, to rely on existing
Java security mechanisms to the greatest extent possible,
to be reasonably transparent to the clients, service proxies,
and services, and not to require any centralized servers.
We feel that we have mostly reached these goals. The im-
plementation allows Jini services to implement any proto-