title:Practical Over-Threshold Multi-Party Private Set Intersection
author:Rasoul Akhavan Mahdavi and
Thomas Humphries and
Bailey Kacsmar and
Simeon Krastnikov and
Nils Lukas and
John A. Premkumar and
Masoumeh Shafieinejad and
Simon Oya and
Florian Kerschbaum and
Erik-Oliver Blass
Practical Multi-party Private Set Intersection
from Symmetric-Key Techniques∗
Vladimir Kolesnikov†
Naor Matania‡
Benny Pinkas‡ Mike Rosulek§
Ni Trieu§
August 24, 2017
Abstract
We present a new paradigm for multi-party private set intersection (PSI) that allows n parties to
compute the intersection of their datasets without revealing any additional information. We explore a
variety of instantiations of this paradigm. Our protocols avoid computationally expensive public-key
operations and are secure in the presence of any number of semi-honest participants (i.e., without an
honest majority).
We demonstrate the practicality of our protocols with an implementation. To the best of our knowl-
edge, this is the ﬁrst implementation of a multi-party PSI protocol. For 5 parties with data-sets of 220
items each, our protocol requires only 72 seconds. In an optimization achieving a slightly weaker variant
of security (augmented semi-honest model), the same task requires only 22 seconds.
The technical core of our protocol is oblivious evaluation of a programmable pseudorandom function
(OPPRF), which we instantiate in three diﬀerent ways. We believe our new OPPRF abstraction and
constructions may be of independent interest.
1 Introduction
In the problem of private set intersection (PSI), several parties each hold a set of items and wish to learn
the intersection of these sets and nothing else. Today, two-party PSI is a truly practical primitive, with
extremely fast cryptographically secure implementations [PSSZ15, KKRT16, PSZ16]. Incredibly, these im-
plementations are only a small factor slower than the na¨ıve and insecure method of exchanging hashed values.
Among the speciﬁc functions of interest in secure multiparty computation (MPC), PSI is probably one of
the most strongly motivated by practice. Indeed, already today companies such as Facebook routinely use
PSI to share and mine shared information [Ops13, Yun15].
In 2012, (at least some of) this sharing was
performed with insecure na¨ıve hashing, where players send and compare hashes of their set elements. Today,
companies are able and willing to tolerate a reasonable performance penalty, with the goal of achieving
stronger security [Yun15]. We believe that the ubiquity and the scale of private data sharing, and PSI in
particular, will continue to grow as big data becomes bigger and privacy becomes a more recognized issue.
We refer reader to [PSZ14, PSSZ15, PSZ16] for additional discussion and motivation of PSI.
In our work, we consider multi-party PSI in the semi-honest model. By “multi-party” we refer to cases
where more than two parties wish to compute the intersection of their private data sets. This is a natural
generalization of the practically very useful two-party PSI, creating opportunities for much richer data sharing
than what was possible with two-party PSI. Consider, for example, a scenario where several organizations,
e.g., Facebook, an advertiser, and a third-party data provider, wish to combine their data to ﬁnd a target
audience for an ad campaign. As another application, consider a set of enterprises which have private audit
logs of connections to their corporate networks, and wish to identify similar activities in all networks.
∗Full version of a paper published in ACM CCS 2017. The ﬁrst author was supported by Oﬃce of Naval Research (ONR)
contract number N00014-14-C-0113. The second and third authors were supported by the BIU Center for Research in Applied
Cryptography and Cyber Security in conjunction with the Israel National Cyber Bureau in the Prime Minister’s Oﬃce. The
fourth and ﬁfth author partially supported by NSF awards #1149647 and #1617197.
†Nokia Bell Labs, PI:EMAIL
‡Bar-Ilan University, PI:EMAIL
§Oregon State University, {rosulekm,trieun}@eecs.oregonstate.edu
1
We note that the multi-party setting in secure computation is notoriously diﬃcult to tackle. Existing
protocols in generic MPC, such as garbled circuits, are signiﬁcantly more complex and costly in the multi-
party case compared to the two-party case. Quite surprisingly, each player in our protocols expend eﬀort
similar to that in the two-party case.
1.1 State of the Art for Two-Party PSI
We focus on the discussion of the state-of-the-art of semi-honest PSI protocols. We note that the earliest PSI
protocols, based on Diﬃe-Hellman assumptions, can be traced back to the 1980s [Sha80, Mea86, HFH99],
and refer the reader to [PSZ14] for an overview of the many diﬀerent protocol paradigms for PSI. Protocols
based on oblivious transfer extension have proven to be the fastest in practice. We note that the OT-based
protocols do not have the lowest communication cost. In settings where computation is not a factor, but
communication is at a premium, the best protocols are in [RA17, KLS+17, CLR17]. In the semi-honest
version of these protocols, each party sends only 2n group elements, where n is the number of items in each
set. However, these protocols require a number of exponentiations proportional to the number of items,
making their performance slow in practice. Concretely, [PSSZ15] found Diﬃe-Hellman-based protocols to
be over 200× slower than the OT-based ones.
Current state-of-the-art semi-honest PSI protocols in the two-party setting are [KKRT16, PSZ16]. They
both use bucketing to reduce the number of comparisons, and rely on oblivious PRF evaluation. Until our
work, these ideas were not used in PSI protocols for the multi-party case.
Most work on concretely eﬃcient PSI is in the random oracle model, and with security against semi-
honest, rather than malicious, adversaries. Some notable exceptions are [FNP04, JL09, HL10] in the standard
model, and [FNP04, DCKT10, DSMRY12, FHNP16, RR17a, PSS16, RR17b] with security against malicious
adversaries.
Lastly, we note that there are eﬃcient constructions for generic MPC [Yao86, Kol05, MR13, AMPR14,
LR15, RR16, KNR+17, WRK17a, WRK17b], which can be used for implementing any functionality.
In
particular, these protocols can be used for securely implementing PSI, in either the two-party or multi-
party settings. However, circuits for computing PSI are relatively large. A natural circuit for two-party
PSI performs O(n2) comparisons, whereas more eﬃcient circuits are of size O(n log n) [HEK12, PSZ16].
However, as demonstrated in [PSZ16], secure evaluation of these circuits is about two orders of magnitude
slower than the most eﬃcient PSI protocols.
1.2 State of the Art for Multi-party PSI
A multi-party PSI protocol was ﬁrst proposed by Freedman, Nissim, and Pinkas [FNP04]. The protocol
of [FNP04] is based on oblivious polynomial evaluation (OPE) which is implemented using additively ho-
momorphic encryption, such as Paillier encryption scheme. The basic idea is to represent a dataset as a
polynomial whose roots are its elements, and send homomorphic encryptions of the coeﬃcients of this pro-
tocol to obliviously evaluate it on the other party’s inputs. Relying on the OPE technique, Kissner and
Song [KS05] proposed a multi-party PSI protocol with quadratic computation and communication complex-
ity in both the size of dataset and the number of parties. The computation overhead is reduced to be linear in
number of participants in [SS08], which was based on bilinear groups. Furthermore, an eﬃcient solution with
quasi-linear complexity in the size of dataset is proposed in [CJS12]. In both [SS08, CJS12], the maximum
number of the corrupted parties are assumed to be n/2. Very recent work [HV17] describes new protocols
which run over a star network topology, and are secure in the standard model against either semi-honest or
malicious adversaries. The basic idea is to designate one party to run a version of the protocol of [FNP04]
with all other parties. The main building block in [HV17] is an additively homomorphic public-key en-
cryption scheme, with threshold decryption, whose key is mutually generated by the parties. The protocol
requires computing a linear number of encryptions and decryptions (namely, exponentiations) in the input
sets. In contrast, our main building block is based on Oblivious Transfer extensions where the number of
exponentiations does not depend on the size of the dataset.
[HV17] does not include implementation, but
we expect that our protocols are much faster due to building from symmetric primitives. We describe the
performance of representative multi-party PSI protocols in the semi-honest settings in Table 1.
2
Leader
Corruption
Client Threshold
Protocol
[KS05]
[CJS12]
[HV17]
Ours
Computation
Communication
Leader
Client
O(tnm log(|X|))λ
O((n2m + nm)λ)
O(nmλ) O(mλ) O(mn log2(m)) O(m)
O(κ)
O(mλ)
O(nmλ)
O(tκ)
O(mtλ)
O(ntm2)
O(nm + m)
O(nκ)
n − 1
(cid:98)n/2(cid:99)
n − 1
n − 1
Security
Model
semi-honest
semi-honest
semi-honest
augmented semi-honest
semi-honest
Table 1: Communication (bits) and computation (number of exponentiations) complexities of multi-party
PSI protocols in the semi-honest setting, where n is number of parties, t dishonestly colluding, each with
set size m; X is the domain of the element; and λ and κ are the statistical and computational security
parameters, respectively. In our protocols, the computational complexities are in an oﬄine preprocessing
phase.
We mention that multi-party PSI was also investigated in the server-aided model, based on the existence
of a server which does not collude with clients [MN15, ATD15]. Information-theoretic PSI protocols, possible
in the multi-party setting, are considered in [LW07, PCR08, BA12].
1.3 Our Contributions
We design a modular approach for multi-party PSI that is secure against an arbitrary number of colluding
semi-honest parties. Our approach can be instantiated in a number of ways providing trade-oﬀs for security
guarantees and computation and communication costs.
We implemented several instantiations of our PSI approach. To our knowledge, this is the ﬁrst imple-
mentation of multi-party PSI. We ﬁnd that multi-party PSI is practical, for sets with a million items held
by around 15 parties, and even for larger instances. The main reason for our protocol’s high performance
is its reliance on fast symmetric-key primitives. This is in contrast with prior multi-party PSI protocols,
which require expensive public-key operations for each item. Our implementation will be made available on
GitHub.
Our PSI Approach. The main building block of our protocol, which we believe to be of independent
interest, is oblivious, programmable PRF (OPPRF). Recall, oblivious PRF (OPRF) is a 2-party protocol
in which the sender learns a PRF key k and the receiver learns F (k, r), where F is a PRF and r is the
receiver’s input. In an OPPRF, the PRF F further allows the sender to “program” the output of F on a
limited number of inputs. The receiver learns the PRF output as before, but, importantly, does not learn
whether his input was one on which the PRF was programmed by the sender. We propose three OPPRF
constructions, with diﬀerent tradeoﬀs in communication, computation, and the number of points that can
be programmed.
Basic idea. Our PSI protocol consists of two major phases. First, in the conditional zero-sharing
phase, the parties collectively and securely generate additive sharings of zero, as follows. Each party Pi
obtains, for each of its items xj, a share of zero, denoted si
j = 0. Namely, if all parties
have xj in their sets then the sum of their obtained shares is zero (else, w.h.p., the sum is non-zero). In
the second phase, parties perform conditional reconstruction of their shares. The idea is for each Pi to
program an instance of OPPRF to output its share si
j when evaluated on input xj. Intuitively, if all parties
evaluate the corresponding OPPRFs on the same value xj, then the sum of the OPPRF outputs is zero.
This signals that xj is in the intersection. Otherwise, the shares sum to a random value.
j. It holds that(cid:80)n
i=1 si
This brief overview ignores many important concerns — in particular, how the parties coordinate shares
and items without revealing the identity of the items. We propose several ways to realize each of the two PSI
phases, resulting in a suite of many possible instantiations. We then discuss the strengths and weaknesses
of diﬀerent instantiations.
A more detailed overview of the approach and the two phases is presented in Section 5, prior to the
presentation of the full protocol.
3
2 Preliminaries
2.1 Secure Computation
The security of a secure multi-party protocol is formally deﬁned by comparing the distribution of the outputs
of all parties in the execution of the protocol π to an ideal model where a trusted third party is given the
inputs from the parties, computes f and returns the outputs. The idea is that if it is possible to simulate
the view of the adversary in the real execution of the protocol, given only its view in the ideal model (when
it only sees its input and output), then the adversary cannot do in the real execution anything that is
impossible in the ideal model, and hence the protocol is said to be secure.
We work in the multi-party setting where the corrupt parties collude. This is modeled by considering a
single monolithic adversary that obtains the views of all corrupt parties. The protocol is secure if the joint
distribution of those views can be simulated.
Functionalities. We deﬁne a particular secure computation task by formally describing the behavior of
the ideal functionality (trusted third party). The ideal functionality for multi-party PSI is given in Figure 1.
Augmented semi-honest model. We present an optimized variant of our protocols that is in a slightly
weaker security model. In the augmented semi-honest model the adversary is allowed to change the inputs
of corrupted parties (but thereafter run the protocol honestly on those inputs).
In the speciﬁc case of multi-party PSI, this additional power is relatively harmless. One can think of a
multi-party PSI as computing XH ∩ XC, where XH is the intersection of all honest parties’ sets and XC is
the intersection of all corrupt parties’ sets. The augmented semi-honest model simply allows an adversary
to choose XC, rather than being bound to whatever XC was chosen by the environment. Without loss of
generality, an augmented semi-honest adversary can simply set all corrupt parties to have the same input
set XC.
We note that the augmented semi-honest model is well known [HL10, Gol09] and was used in previous
work on multi-party PSI and related functionalities [FNP04, GOW12]. We deﬁne and discuss this security
notion at length in Appendix A.
2.2 Cuckoo Hashing
We review the basics of Cuckoo hashing [PR01], speciﬁcally the variant of Cuckoo hashing that involves a
stash [KMW08]. In basic Cuckoo hashing, there are m bins, a stash, and several random hash functions
h1, . . . , hk (often k = 2), each with range [m]. The invariant is that any item x stored in the Cuckoo hash
table is stored either in the stash or (preferably) in one of the bins {h1(x), . . . , hk(x)}. Each non-stash bin
holds at most one item. To insert and element x into a Cuckoo hash table, we place it in bin hi(x), if this
bin is empty for any i. Otherwise, choose a random i ∈R [k], place x in bin hi(x), evict the item currently
in hi(x), and recursively insert the evicted item. After a ﬁxed number of evictions, give up and place the
current item in the stash.
3 Programmable OPRF
Our PSI approach builds heavily on the concept of oblivious PRFs (OPRF). We review the concepts here
and also introduce our novel programmable variant of an OPRF.
3.1 Deﬁnitions
Oblivious PRF. An oblivious PRF (OPRF) [FIPR05] is a 2-party protocol in which the sender learns a
PRF key k and the receiver learns F (k, q1), . . . , F (k, qt), where F is a PRF and (q1, . . . , qt) are inputs chosen
by the receiver. Note that we are considering a variant of OPRF where the receiver can obtain several PRF
outputs on statically chosen inputs. We describe the ideal functionality for an OPRF in Figure 2.
Instantiation and Security Details. While many OPRF protocols exist, we focus on the protocol of
Kolesnikov et al. [KKRT16]. This protocol has the advantage of being based on oblivious-transfer (OT)
extension. As a result, it uses only inexpensive symmetric-key cryptographic operations (apart from a
constant number of initial public-key operations for base OTs). The protocol eﬃciently generates a large
4
Parameters: The number of parties n, and the size of the parties’ sets m.
Functionality:
• Wait for an input Xi = {x1
• Give output
n(cid:84)