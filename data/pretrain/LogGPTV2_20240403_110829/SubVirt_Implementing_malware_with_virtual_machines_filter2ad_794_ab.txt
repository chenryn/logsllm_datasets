Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:48:08 UTC from IEEE Xplore.  Restrictions apply. 
concept VMBRs both use the VMM architecture in
Figure 1, which leverages a host OS to access the un-
derlying hardware devices. The Virtual PC VMBR
uses a minimized version of Windows XP [35] for the
host OS and the VMware VMBR uses Gentoo Linux.
To implement the proof-of-concept VMBRs, we modify
the host Windows XP kernel, Virtual PC, and the host
Linux kernel. We did not have source code for VMware,
but our modiﬁcations to the host Linux kernel were suf-
ﬁcient to support our proof-of-concept VMware-based
VMBR.
3.1. Installation
In the overall structure of a VMBR, a VMBR runs
beneath the existing (target) operating system and its
applications (Figure 2). To accomplish this, a VMBR
must insert itself beneath the target operating system
and run the target OS as a guest. To insert itself be-
neath an existing system, a VMBR must manipulate
the system boot sequence to ensure that the VMBR
loads before the target operating system and applica-
tions. After the VMBR loads, it boots the target OS
using the VMM. As a result, the target OS runs nor-
mally, but the VMBR sits silently beneath it.
To install a VMBR on a computer, an attacker must
ﬁrst gain access to the system with suﬃcient privileges
to modify the system boot sequence. There are nu-
merous ways an attacker can attain this privilege level.
For example, an attacker could exploit a remote vul-
nerability, fool a user into installing malicious software,
bribe an OEM or vendor, or corrupt a bootable CD-
ROM or DVD image present on a peer-to-peer network.
On many systems, an attacker who attains root or Ad-
ministrator privileges can manipulate the system boot
sequence. On other systems, an attacker must execute
code in kernel mode to manipulate the boot sequence.
We assume the attacker can run arbitrary code on the
target system with root or Administrator privileges and
can install kernel modules if needed.
After the attacker gains root privileges, he or she
must install the VMBR’s state on persistent storage.
The most convenient form of persistent storage suitable
for VMBR state is the disk. An attacker can either
use the target OS to allocate disk blocks (e.g., through
the ﬁle system) or can parse on-disk structures to ﬁnd
unused blocks. When the target system is Windows
XP, we store the VMBR state in the beginning of the
ﬁrst active disk partition. We relocate the data that
was in these disk blocks to unused blocks elsewhere on
the disk. When the target system is Linux, we disable
swapping and use the swap partition to store persistent
VMBR state. Both these installation procedures leave
most of the target’s data in its original location on disk.
The next step in installing a VMBR is to modify
the system’s boot sequence to ensure our VMBR loads
before the target OS. The most convenient way for a
VMBR to manipulate the system’s boot sequence is
to modify the boot records on the primary hard disk.
Many current anti-malware applications detect modi-
ﬁcations to the hard disk’s boot blocks. Our imple-
mentation attempts to avoid this type of detection by
manipulating the boot blocks during the ﬁnal stages of
shutdown, after most processes and kernel subsystems
have exited.
When targeting Windows XP systems, we use a
kernel module which registers a LastChanceShutdown
Notification event handler that is invoked late in the
shutdown sequence, after the ﬁle systems have been
ﬂushed and most processes have exited. When Win-
dows invokes our event handler, our kernel module
copies the VMBR boot code into the disk’s active par-
tition, which will cause the system to load the VMBR
at the next system boot. Since our attack code runs
within the OS, we have enough control over the system
to avoid anti-malware software, even if it runs during
the shutdown process. For example, we use the low-
level disk driver to copy our VMBR boot code. Using
the low-level disk driver bypasses the ﬁle system layer,
which is where many anti-malware applications run.
Furthermore, we interpose on the low-level disk con-
troller’s write function to ensure that only our VMBR
is allowed to store disk blocks once installation begins.
When targeting Linux systems, we modify the boot
sequence using user-mode code. We modify the shut-
down scripts so that our installation code runs after all
processes have been killed but before the system shuts
down. We overwrite the disk master boot record using
the Linux hard-drive block-device so that our VMBR
loads at system boot instead of the target OS.
After installation, the target system’s disk space is
contained in a virtual disk. After rebooting, the VMM
translates the target’s virtual disk accesses to the corre-
sponding location on the physical disk. To implement
our disk redirection support for our Virtual PC-based
VMBR, we modiﬁed the VMM’s disk virtualization
module. For our VMware-based VMBR, we modiﬁed
the host Linux’s hard-drive block device.
3.2. Malicious services
After a VMBR is installed, it can run malicious ser-
vices. This section describes the techniques VMBRs
use to implement various types of malicious services.
Traditional malware often trades-oﬀ ease of imple-
mentation against ability to avoid detection. Tradi-
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:48:08 UTC from IEEE Xplore.  Restrictions apply. 
target
application
target
application
target operating system
host hardware
Before infection
After infection
malicious
service
malicious
service
host operating system
target
application
target
application
target operating system
virtual-machine monitor (VMM)
host hardware
Figure 2. This ﬁgure shows how an existing target system can be moved to run inside a virtual
machine provided by a virtual-machine monitor. The grey portions of the ﬁgure show the components
of the VMBR.
tional user-mode malware that runs within the target
OS tends to be easy to implement because malware au-
thors can use any programming language to write these
malicious services. Also, user-mode malware has access
to all libraries and OS-level resources which makes it
easy to provide a rich set of functionality. However,
user-mode malware can be detected by security soft-
ware running within the target OS because all mali-
cious states and events are visible to the target oper-
ating system.
VMBRs use a separate attack OS to deploy malware
that is invisible from the perspective of the target OS
but is still easy to implement. None of the states or
events of the attack OS are visible from within the tar-
get OS, so any code running within an attack OS is
eﬀectively invisible. The ability to run invisible mali-
cious services in an attack OS gives intruders the free-
dom to use user-mode code with less fear of detection.
We classify malicious services into three categories:
those that need not interact with the target system
at all, those that observe information about the target
system, and those that intentionally perturb the exe-
cution of the target system. In the remainder of this
section, we discuss how VMBRs support each class of
service.
The ﬁrst class of malicious service does not com-
municate with the target system. Examples of such
services are spam relays, distributed denial-of-service
zombies, and phishing web servers. A VMBR supports
these services by allowing them to run in the attack
OS. This provides the convenience of user-mode exe-
cution without exposing the malicious service to the
target OS.
The second class of malicious service observes data
or events from the target system.
VMBRs en-
able stealthy logging of hardware-level data (e.g.,
keystrokes, network packets) by modifying the VMM’s
device emulation software. This modiﬁcation does not
aﬀect the virtual devices presented to the target OS.
For example, a VMBR can log all network packets by
modifying the VMM’s emulated network card. These
modiﬁcations are invisible to the target OS because the
interface to the network card does not change, but the
VMBR can still record all network packets.
VMBRs can use virtual-machine introspection to
help observe and understand the software-level ab-
stractions in the target OS and applications. Virtual-
machine introspection enables malicious services to
trap the execution of the target OS or applications at
arbitrary instructions. When these traps occur, a mali-
cious service can use use virtual machine introspection
to reconstruct data and abstractions from the target
system. For example, if a target application uses an
encrypted socket, attackers can use virtual-machine in-
trospection to trap all SSL socket write calls and log
the clear-text data before it is encrypted. This logging
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:48:08 UTC from IEEE Xplore.  Restrictions apply. 
is transparent to the target OS and applications since
the malicious code runs outside of the target and also
because virtual-machine introspection does not perturb
the state of the target system.
The third class of malicious service deliberately
modiﬁes the execution of the target system. For ex-
ample, a malicious service could modify network com-
munication, delete e-mail messages, or change the ex-
ecution of a target application. A VMBR can cus-
tomize the VMM’s device emulation layer to modify
hardware-level data. A VMBR can also modify data
or execution within the target through virtual-machine
introspection.
3.3. Example malicious services
Using our proof-of-concept VMBRs, we developed
four malicious services that represent a range of ser-
vices a writer of malicious software may want to deploy.
We implemented a phishing web server, a keystroke
logger, a service that scans the target ﬁle system look-
ing for sensitive ﬁles, and a defense countermeasure
that defeats a current virtual-machine detector. To
develop these services, we use the host OS as our at-
tack OS (Figure 2). For some services, we also modify
the VMM.
Using our VMware-based VMBR, we developed a
phishing web server which represents malware that
has no interactions with the target OS. Phishing web
servers are used to deploy web sites that look like legit-
imate businesses and fool users into entering personal
information like credit card numbers or passwords. At-
tackers commonly use compromised systems to deploy
these malicious web sites. To implement our phishing
site, we use a thttpd web server running within our at-
tack OS. We modiﬁed our virtual networking settings
so most network traﬃc is forwarded to the target, but
any incoming TCP requests on port 8080 are forwarded
to our phishing server. This phishing web server did
not require any new code since we leveraged an existing
web server and adjusted our existing virtual-network
conﬁguration settings, and yet we were able to run a
full-blown web server within our VMBR environment
that does not have any states or events which are visi-
ble within the target OS.
Using our Virtual PC-based VMBR, we imple-
mented a keystroke logging malicious service. This
represents malware that observes hardware-level data
about the running target system.
Attackers use
keystroke loggers to obtain sensitive information, like
passwords. To implement our keystroke logger, we
modify the keyboard controller emulation module
within the Virtual PC VMM so that all keystrokes are
sent to a program in the attack OS before being for-
warded up to the target OS. The program within the
attack OS analyzes the keystrokes to extract passwords
used to login to the target system. The amount of ex-
tra code needed to support keystroke logging is modest.
Our modiﬁcations to the keyboard controller emulation
module require 60 lines of code. Our analysis program
takes 254 lines of code, which includes a GUI used to
display results. The keystroke logger is transparent to
the target OS because the target OS’s interface to the
virtual keyboard controller remains the same.
Using our VMware-based VMBR, we wrote a ma-
licious service that scans the target OS ﬁle system
looking for sensitive data. This type of malicious ser-
vice represents malware which records software-level
data about the target OS. When attackers break into
a system, they sometimes search the ﬁle system look-
ing for sensitive data like passwords and encryption
keys. We implemented a malicious service that uses
virtual-machine introspection to scan the target OS’s
ﬁle system to copy the password ﬁle (/etc/shadow)
and search all user directories looking for private ssh
keys (user home /.ssh/id dsa). Our scanning mali-
cious service is a 24 line Perl script that runs within
the attack OS. All malicious code runs outside of the
target OS, and the scanning activities are invisible to
the target system.
Using our Virtual PC-based VMBR, we imple-
mented a defense countermeasure service. This rep-
resents malware that actively modiﬁes the execution
of the target OS. We implemented a countermeasure
against an existing program that detects x86 virtual
machines. The redpill
[39] virtual-machine detection
technique detects the presence of a VMM by using the
sidt instruction. The sidt instruction reads the ad-
dress of the processor’s interrupt descriptor table. This
address is diﬀerent for an operating system running di-
rectly above hardware than for an operating system
running above a VMM. VMMs emulate the sidt in-
struction when it is called from kernel-mode, but for
performance reasons this instruction is not virtualized
when called from user-mode. Thus, user-mode code
can execute the sidt instruction to detect the pres-