变量。相应的值被存储到全局变量BlVsmpSystemPolicy中。如果UEFI锁开启，这个EFI变量被设置，并且不能通过winload.efi禁用（它不能移除它，只能使用自定义的EFI代码才能）。
函数OslpPrepareTarget也会调用OslpProcessSIPolicy（被调用两次，第一次直接从函数OslInitializeCodeIntegrity中调用）。OslpProcessSIPolicy使用3个EFI变量“pools”来校验SI策略签名。每个pool包含3个EFI变量，第一个包含策略，第二个包含版本，第三个包含授权的策略更新签名者。例如，对于C:WindowsSystem32CodeIntegritySIPolicy.p7b，变量是Si，SiPolicyVersion和SiPolicyUpdateSigners。如果“version”和“update
signers”变量被设置，系统将增强SI策略签名：它必须是存在且正确的签名，否则引导将失败。通过BlSiPolicyIsSignedPolicyRequired函数来验证它自己。
3种策略和相关的变量总结如下：
我们不确定“revokeSiPolicy”和“skuPolicy”的目的，但是他们似乎和普通的“SiPolicy”使用类似。
**Hyper-V** **和内核组件的加载**
执行将转移到OslArchHypervisorSetup函数，其需要使用与执行的步骤相应的参数来调用，从0开始。在第一次，它将初始化Hyper-V（加载hvloader.efi且通过HvlpLaunchHvLoader执行它）。SecureBoot设置通过OslInitializeCodeIntegrity来校验。
OslpPrepareTarget然后加载NTOS内核（ntoskrnl.exe），并且使用OslpLoadAllModules函数来加载hal.dll和mcupdate.dll模块。然后“Local
Key”和“Identification Key”由OslVsmProvisionLKey和OslVsmProvisionIdk函数加载。
此时，NTOS内核初始化了但还没哟启动。以步骤“0”为参数的OslVsmSetup被调用（与OslArchHypervisorSetup一样：以“步骤”为参数），首先校验Hyper-V已经启动，然后初始化OslVsmLoaderBlock（参数在初始化期间由安全内核提供）。然后，OslVsmSetup加载安全内核（securekernel.exe），并且通过OslpVsmLoadModules函数加载它依赖的skci.dll（OslLoadImage再次被用来校验他们的签名）。EFI变量OslLoaderIndications第一位被设置为1。
最后，OslVsmSetup函数再次被调用，但是参数是步骤“1”。这个触发了OslVsmLoaderBlock的初始化。
当函数OslpPrepareTarget返回后，VBS参数已经被验证完了，并且NTOS和安全内核都被加载了。他们的入口点地址被存储在全局变量OslpVsmSystemStartup和OslEntryPoint中（securekernel.exe和ntoskrnl.exe）以便将来使用。
**0x03 微软EFI变量**
VBS EFI变量属于命名空间：{0x77FA9ABD, 0x0359, 0x4D32, 0xBD, 0x60, 0x28, 0xF4, 0xE7,
0x8F, 0x78, 0x4B}。这些变量有他们的“Boot”和“Setup”属性设置，因此在EFI引导阶段后他们的访问和修改是不被允许的。
然而转储他们是可能的，以便在逆向分析中使用。与VBS相关的EFI变量和他们响应的用法总结如下：
为了转储这些变量的内容，关闭安全启动和使用一个简单的EFI自定义的引导启动器（gnu-efi和VisualStudio能完美实现）。一些变量转储如下：
**  
**
**0x04 Hyper-V和安全内核启动**
回到OslpPrepareTarget，现在开始执行启动Hyper-V和分割VTL0及VTL1空间。这个过程总结如下：
Winload在“第一个“Hyper-V VM中运行
Winload调用安全内核的入口点（EP）
securekernel初始化自身，请求Hyper-V内存保护
securekernel请求VTL1验证
Hyper-V启用VTL1（“第二个“VM），在ShvlpVtlEntry中返回
通过ShvlpVtlReturn，securekernel（现在是VTL1）返回到winload（现在是VTL0）
Winload调用ntoskrnl入口点
下面是securekernel初始化前后的状态（VTL0 VM是蓝色块，VTL1是绿色块，Hyper-V是橙色块）：
图2 – securekernel初始化前后的状态对比
继续执行，通过调用OslFwpKernelSetupPhase1退出EFI模式，并且以“1“参数调用OslArchHypervisorSetup启动Hyper-V。Hvix64通过向HvlpSavedRsp保存的RSP启动并且将HvlReturnFromHypervisor传给hvix64。当HvlpReturnFromHypervisor被命中，使用cpuid指令来验证启动，并且RSP被重置。我们确实处在第一个虚拟机中，其将很快变成VTL1。
OslVsmSetup再次被调用（step“2”）：
校验VBS参数
验证Hyper-V正确运行
修改OslVsmLoaderBlock设置
在相同块中复制OslVsmLKeyArray（Local Key）和OslVsmIdk（“Identification Key”）
调用储存在OslpVsmSystemStartup中的安全内核的入口点，指定OslVsmLoaderBlock和它的大小为参数。
然后安全内核将执行它的初始化，并且将调用SkmiProtectSecureKernelPages以便安装它自己的内存，但是也注册Hyper-V时间拦截例程（HyperGuard和它的Skpg*前缀的例程）。根据[http://www.sandpile.org/x86/msr.htm](http://www.sandpile.org/x86/msr.htm)，对MSR的操作由SkpgxInterceptMsr拦截处理：
**0x1B(APIC_BASE)**
**0x1004(?)**
**0x1005(?)**
**0x1006(?)**
**0x100C(?)**
**0xC0000080(EFER)**
**0xC0000081(STAR)**
**0xC0000082(LSTAR)**
**0xC0000083(CSTAR)**
**0xC0000084(FMASK)**
**0xC0000103(TSC_AUX)**
**0x174(SEP_SEL)**
**0x175(SEP_RSP)**
**0x176(SEP_RIP)**
**0x1a0(MISC_ENABLE)**
我们的假设是这个处理器的设置是为了捕获VTL0中CPL转变，来阻止关键的MSR修改。还有两个其他的例程，SkpgxInterceptRegisters和SkpgInterceptRepHypercall。前者可能是拦截CRXXX注册操作的方法（例如，写CR4能禁用SMEP），后者是拦截未授权的调用（然而这些只是猜测）。
关于HyperGuard，似乎通过SkpgVerifyExtents执行VTL0完整性校验。SkpgHyperguardRuntime被调用，可能是计划执行的（使用SkpgSetTimer）。
HyperGuard处理器和回调函数被复制到SkpgContext（由SkpgAllocateContext和SkpgInitializeContext初始化）。
记住上个章节只是个假设，可能是错误的，因为我们现在没能在VTL1 HyperGuard/PatchGuard例程中花费太多时间。
在初始化的最后，安全内核将执行两个调用：
0x0F，ShvlEnableVpVtl，指定一个ShvlpVtl1Entry函数指针
0x12，ShvlpVtlCall，它不会在任何其他地方使用，并且使用它自己的跳板函数（在下篇文章给出更多细节）。
ShvlpVtl1Entry以SkpPrepareForReturnToNormalMode结束，并且这个过程会使Hyper-V开启VTL0和VTL1，回到ShvlpVtl1Entry，再回到winload.efi进入到VTL0的上下文。
最终，当回到winload.efi的主函数，将通过OslArchTransferToKernel执行NTOS的入口点,它使用OslEntryPoint调用入口点。
然后执行下一个操作，就像Windows在正常环境中启动，只是现在NTOS内核知道了VBS相关的组件（如设备保护）。
**0x05 总结**
基于虚拟化的安全是Windows10安全功能的一个关键组件。通过VBS的安全内核的初始化，我们希望这个文章将给想要深入分析这个功能的逆向者帮助。
在第二部分，我们将涵盖VTL0和VTL1怎么内核通信和Hyper-V调用怎么实现。