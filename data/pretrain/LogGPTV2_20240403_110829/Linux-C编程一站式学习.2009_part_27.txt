，然而更广泛采用的办法是使用偏移的
，或者叫Significand）
，而我们的模型中指数部分没
符号位、指数部分（表
，4称为指数
下一页
---
## Page 233
是-130则称为下溢，计算结果是130则称为上溢。假设按本节介绍的浮点数表示法，取值范围是-
算的定义不同。假设整数采用8位2's Complement表示法,
整数运算会产生溢出，
精确比较了
跟128相等了。在第2节“ilelse语句"讲过浮点数不能做精确比较，现在读者应该知道为什么不能
结果了，
很小的数全被舍去了，
000000000000000000000000000000000000000000000000
由于浮点数表示的精度有限,
两个浮点数相加，
于提高精度，我们说最高位的1是隐含的（Implied）。这样17就只有一种表示方法了，指数部分应
（Significance Loss）问题，
规化（Normalize）
们规定尾数部分的最高位必须是1,
如17=(0.10001)2×25=(0.010001)2×26，这样给计算机处理增加了复杂性。为了解决这个问题，我
现在还有一个问题需要解决：每个浮点数的表示都不唯一，
图14.10.浮点数相加
图14.9.17的正规化尾数浮点数表示
0000000000=000000000+000000000=000000000+0000000000+000000000
11.101110110
11.0010000
sign
0.100110110
0
0
10010
exponent
10000
10010
首先把小数点对齐然后相加：
biased
10101
。由于尾数部分的最高位必须是1，这个1就不必保存了，可以节省出一位来用
浮点运算也会产生溢出，浮点运算的溢出也分上溢和下溢两种，
 有时计算顺序不同也会导致不同的结果，
计算结果末尾的10两位被舍去了。
11011101
00110110
10010000
significand
nomalized
00010000
也就是说尾数必须以0.1开头，
十
，取值范围是-128~127，
例
，做浮点运算时要注意精度损失
，对指数做相应的调整，
比
如果计算结果
后面加的两个
，但和整数运
，这称为正
233
---
## Page 234
3.整数的加减运算
多数平台上，
款25提到 : As far as the committee knows, all machines treat all bits zero as a representation of
某种平台可能会规定一个浮点数的所有bit是0并不表示0值，但[C99 Rationale]第6.7.8节的条
是0。无论是用Sign and Magnitude表示法、1's Complement表示法还是2's Complement表示法
“用0初始化"的意思是变量i、变量a和数组元素a[1]-a[9]的所有字节都用0填充，
如果Initializer中提供的元素不够那么剩下的元素也用o初始化。例如：
最后讨论一个细节问题。我们知道，
的IEEE 754。
前业界广泛采用的浮点数标准是由IEEE（Institute of Electrical and Electronics Engineers）制定
个简单的模型介绍一些基本概念而不深入讨论，理解了这些基本概念有助于你理解浮点数标准，
浮点数是一个相当复杂的话题，
下溢。
一个整数的所有bit是0都表示0值，
double a[10] = { 1.0 };
double 
int
i;
一个浮点数的所有bit是0就表示0值。
不同平台的浮点数表示和浮点运算也有较大差异，
定义全局变量时如果没有Initilizer就用o初始化，定义数组时
全国嵌入式人才培训基地
起始页
一级
第15章数据类型详解
，或者说所有bit都
本节只是通过这
2
下一页
目
---
## Page 235
3.类型转换
4.浮点数
2.浮点型
第 15 章 数据类型详解 请点评
1.整型
目
3.5.编译器如何处理类型转换
3.1. Integer Promotion
Usual Arithmetic Conversion
全国嵌入式人才培训基地
第15章数据类型详解
全国嵌入式人才培训基地
部分Ⅱ. C语言本质
起始页
上一级
235
.整型
---
## Page 236
用char型表示8位的整数，为了可移植性就必须写明是signed还是unsigned。
有问题，
意，ASCI码的取值范围是0~127，
现在开始，
该避免使用。另一方面，
定这是lmplementation Defined，
号整数来解释，取值范围是0~255，如果按有符号整数来解释，
我们知道，在C语言中char型占一个字节的存储空间，
1.整型 请点评
的
的，
的，以及为什么要这样写
就没考虑可移植性的问题。
求程序员非常清楚这些规则，
L二
，
，在该编译器所对应的体系结构上哪种实现效率高就可以采用哪种实现，x86平台的gcc定
一般来说，
是有符号的。
 我们会接触到很多Implementation Defined的特性，C语言与平台和编译器是密不可分
到一个函数调用的各个实参表达式按什么顺序求值是Unspecified的。
不同版本的编译器就可以选择不同的处理方式，
到不同的结果,
译器的文档中，
明确规定按哪种方式处理,
而对于Unspecified的情况，
我们刚才看到一种Implementation-defined的情况，C标准没有明确规
况统称为"未明确定义"的。这三种情况到底有什么不同呢？
defined、Unspecified或Undefined来表述，
在C标准中没有做明确规定的地方会用Implementation-
请点评
Implementation-defined、Unspecified和Undefined
，如果用char型存ASCl码字符,
：这也是C标准的Rationale之一：优先考虑效率,
 写不可移植的代码有时候也是必要的，
如果不是为了效率，
如果要写不可移植的代码,
这样即便用同一个编译器的不同版本来编译也可能
因为编译器没有在文档中明确写它会怎么处理，
，如果你要写可移植的代码，就必须清楚哪些写法是不可移植的，
 所以不管char型是有符号的还是无符号的，存一个ASCI码都没
第15章 数据类型详解
全国嵌入式人才培训基地
编译器可以自己决定，
，往往有几种可选的处理方式，C标准没
，就只能讨论到本书第一部分的程度了。注
，在写这些代码的时候就没打算用别的编译器编译，
1.整型
一般来说就没有理由故意写不可移植的代码。从
一个字节通常是8个bit。如果这8个bit按无符
，在本书中有时把这三种情
你也必须清楚代码中的哪些部分是不可
，比如下一章我们会
，比如Linux内核代码使用了很多只
，采用2's Complement表示法，取
并且也不必写在
也可以定义char型是有符号
而可移植性尚在其次。
那
讲
得
编
有
下一
这
号
规
京
值
贝
---
## Page 237
常量和枚举常量的类型都是int型，因此前三种常量的类型都属于整型。整数常量有很多种，不全
在第2节“常量"讲过C语言的常量有整数常量、字符常量、枚举常量和浮点数常量四种，
且char是有符号的，我不会每次都加以说明，
释。从现在开始本书做以下约定：在以后的陈述中，
指针又是一种什么样的类型,
的C编译器采用这种规范。指针类型的长度总是和计算机的位数一
译器采用这种规范，x86平台的gcc也是如此。
Defined。通常的编译器实现遵守ILP32或LP64规范，如下表所示。
除了char型在C标准中明确规定占一个字节之外，其它整型占几个字节都是lmplementation
是Implementation Defined。
从现在开始我们只讨论2's Complement表示法的情况。还有一
是lmplementation Defined。大多数体系结构都采用2's Complement表示法，x86平台也是如此，
除了char型之外，整型还包括short int（或者简写为short）、
long long|
long
short
char 
表15.1.ILP32和LP64
指针
类型
不得不为每一种浏览器的每一个版本分别写不同的代码。
个浏览器一个样，
的JavaScript程序员吧，
很幸福了，
完美，现实世界里的东西总是不够完美的。但还好啦，C程序员已
法律条文,
初学者看到这些规则通常会很不舒服，
是Undefined的。
译器是检查不出来的，最终会导致运行时错误，比如数组访问越界就
很可能也没规定，甚至也没做出错处理，有很多Undefined的情况编
Undefined的情况则是完全不确定的，C标准没规定怎么处理，编译器
ILP32（位数）
2
9
2
8
只要严格遵照C标准来写代码，
，结果越学越泄气。是的，
 我们到第17章计算机体系结构基础和第 23章指针再分别详细解
，甚至同一个浏览器的不同版本也差别很大，程序员
[LP64（位数）
9
9
9
3
8
他们甚至连一
，但说到其它平台时我会明确指出是什么平台。
缺省平台是x86/Linux/gcc，
一个可以遵照的标准都没有，
，觉得这不是在学编程而是在啃
不要去触碰那些阴暗角
一点是C标准明确规定的，
一点要注意，
、int、long int（或者简写
一致，
 至于什么是计算机的位数
除了char型以外的这些类
 通常32位计算机的C编
遵循ILP32，并
经
，通常64位计算机
不
其实字符
237
---
## Page 238
给定一个整数常量，比如1234U，那么它应该属于“u或U"这一行的"十进制常量"这一列，这个表格
款6.4.4.1)
long关键字并不是一
整数常量还可以在末尾加u或U表示"unsigned"，
制数字表示，这种表示方式相当于把八进制和十六进制整数常量开头的0替换成了。
进制整数常量以0开头，
以前我们只用到十进制的整数常量,
是int型的，
如0x1234U，
，否则无法和八进制区分。
既有u或U，又有I或LL
表 15.2.整数常量的类型
I或LL
既有u或U，又有或L
或L
u或U
无
下面我们详细讨论整数常量。
后缀
一对应的。这个对应关系比较复杂，准确的描述如下表所示（出自[C99]条
后面的数字只能是0~7,
[unsigned long long int unsigned long long int
long long int 
unsigned long long intunsigned long long int 
unsigned long int 
long long int 
long int 
unsigned long long int unsigned long long int 
unsigned long int 
unsigned int
long long int 
long int 
十进制常量
其实在C语言中也可以用八进制和十六进制的整数常量[26]。
，加l或L表示"long"，
例如022，
unsigned 
long long i
unsigned long int 
unsigned long long int 
long long int 
unsigned long int 
long int 
unsigned long int 
unsigned int 
unsigned long long int 
long long int 
unsigned long int 
long int 
unsigned int
int
八进制或十六进制常量
 因此十进制的整数常量就不能以0开头
 long long int 
int 
后面的数字可以
，加ll或LL表示"long long"，例
，以或x加八进制或十六进
238
---
## Page 239
第15章数据类型详解
[25] 我们在第4 节“结构体和联合体"还要介绍一种特殊的整型－－Bit-field。
介绍。
达式也是1ong 1ong型，编译器就不会报警告了。有关类型转换的规则将在第3节“类型转换"详细
其中一个常量是long long型，
的取值范围了
怎么样，
“格式化IO函数”
会报警告
int型。
数，而它的MSB（第31位）是1,
再比如Oxffo000，
么unsigned int就可以表示。
第一个足够长的类型可以表示1234这个数，那么它就是这个整数常量的类型，如果int是32位的那
十六进制的对应关系非常明显，
制的整数常量从未进入C标准，
并
就
算
役
讲
一页
且它的值也没有超出int型的取值范围；或者改成printf（"%lld\n",
不会报警
列十进制常量
符组成的表达式，
一个有意思的问题。我们知道x86平台上int的取值范围是-2147483648~2147483647，
告
整数常量没有你原来想的那么简单吧。再看一个不简单的问题。long long i =
警告
但
量，
警告信息不准确，
-号运算符的两个操作数-2147483647和1都是int型，计算结果也应该是int型，
因为C99以前对于整数常量的类型规定和上表有一些出入，即使不加这个选项t
-2147483648);打印int类型的下界有没有问题呢？如果用gcc main.c－
，应该属于第一行“无"的第二列"八进制或十六进制常量"，
，用八进制或十六进制常量完全可以代替使用二进制常量。
只是某些编译器的扩展，
所以这个常量也超过
、两个int型相乘的表达式仍然是int型，而乘积已经超过int型
虽然-2147483648这个数值能够用int型表示，
，C编译器会把它当成一
全国嵌入式人才培训基地
起始页
上一级
前面再加个负号
了long型的取值范围,
我们写这个十六进制常量是要表示一
，以Ob或OB开头，
所以不建议使用，
 所以编译器报警告。之所以编译命令要
一个整数常量2147483648和-
号组成的表达式仍然是long
-2147483648）;也可以，转
，比如0b0001111，但二进
，由于二进制和八进制、
，-2147483647-1);编译
 根据上表第-
所以请注
而后者
，这一列有六种类
在x86平台
，第二个类型unsigned
者
是unsigned
，但在C语言中却
 两数相乘的表
，从上到下找出
一行“无"的第
2.浮点型
一个负号运
，那么
一个正
下一页
器
换
---
## Page 240
2.浮点型请点评
[2] C99引入一种新的十六进制浮点数表示，基数是2，本书不做详细介绍。
的。
例如3.14f、.01L，
数之间用e或E隔开，例如314e-2表示314x10-2，注意这种表示形式基数是10[27]，如果尾数的小数
以前我们只用到最简单的浮点数常量,
的1ong double型通常是128位。
单元的精度。其它体系结构的浮点运算单元的精度不同，编译器实现也会不同，例如PowerPC上
1.整型
齐的问题)
double型是12字节（96位）
元，
上一页
左边或右边没有数字则表示这一部分为零，
计算机中的表示是基于科学计数法的，所以浮点数常量也可以写成科学计数法的形式，尾数和指
L二
，也没有规定采用哪种表示形式。浮点数的实现在各种平台上差异很大,
只能做整数运算,
H
 浮点数的后缀和类型之间的对应关系比较简单，
，需要用整数运算来模拟浮点运算，称为软浮点（Soft-float）实现。大部分平
这是为了对齐到4字节边界（在第4节“结构体和联合体"详细讨论)
称为硬浮点（Hard-float）实现；有的处理器没有浮点运算单
全国嵌入式人才培训基地
例如3.14,