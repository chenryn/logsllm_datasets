â›âœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâ
ââŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâ 
ââŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâ 
,
ğ‘ âˆ’ 1 Â·Â·Â· âˆ’1 âˆ’1
âˆ’1
...
3
2
1
...
Â·Â·Â·
Â·Â·Â·
Â·Â·Â·
...
3
2
1
...
...
3 âˆ’ ğ‘ 3 âˆ’ ğ‘
.
2 âˆ’ ğ‘
1
2
1
1 2 âˆ’ ğ‘ 3 âˆ’ ğ‘ Â·Â·Â· âˆ’1
1
1
...
1
2
2
...
2
3 âˆ’ ğ‘ Â·Â·Â· âˆ’1
Â·Â·Â· âˆ’1
...
...
Â·Â·Â· ğ‘ âˆ’ 1
3
...
3
and its inverse (which represents division by ğ‘”ğ‘ in the powerful basis) are the
where ğºpow
square (ğ‘ âˆ’ 1)-dimensional matrices
ğ‘
Identical decompositions hold for ğºdec
ğ‘š and ğºcrt
in the decoding and CRT bases, respectively), where
ğ‘š (which represent multiplication by ğ‘”ğ‘š
ğºdec
ğ‘ =
(ğºdec
ğ‘ )âˆ’1 = ğ‘âˆ’1 Â·
,
ğ‘ is the diagonal matrix with 1 âˆ’ ğœ”ğ‘–
and ğºcrt
ğ‘ in the ğ‘–th diagonal entry (indexed from 1 to
ğ‘ âˆ’ 1), where ğœ”ğ‘ is the same primitive ğ‘th root of unity in the base ring used to deï¬ne the
CRT basis.
61
The linear transforms represented by the above matrices can be applied in time linear in
For (ğºdec
the dimension. For ğºpow
ğ‘ and its inverse this is obvious, due to their sparsity.
ğ‘ )âˆ’1, this follows from the fact that every row (apart from the top one) differs from
)âˆ’1, we can compute the entries of the output
vector from the bottom up, by computing the sum of all the input entries and their partial
the preceding one by a single entry. For (ğºpow
, ğºdec
ğ‘ , and ğºcrt
ğ‘
ğ‘
sums from the bottom up.
The Tensor methods mulGPow and mulGDec represent multiplication by ğºpow
ğ‘š and ğºdec
ğ‘š ,
respectively. Similarly, the methods divGPow and divGDec represent division by these
matrices; note that their outputs are wrapped by Maybe, so that the output can be Nothing
when division fails. Finally, mulGCRT and divGCRT represent multiplication and division by
ğºcrt
ğ‘š; note that these methods themselves are wrapped by Maybe, because ğºcrt
ğ‘š and its inverse
are well-deï¬ned over the base ring exactly when a CRT basis exists. (In this case, division
always succeeds, hence no Maybe is needed for the output of divGCRT.)
Chinese Remainder and Discrete Fourier Transforms
Consider a base ring, like Zğ‘ or C, that admits an invertible index-ğ‘š Chinese Remainder
Transform CRTğ‘š, deï¬ned by a principal ğ‘šth root of unity ğœ”ğ‘š. Then as shown in [LPR13a,
Section 3], this transform converts from the powerful basis to the CRT basis (deï¬ned by the
same ğœ”ğ‘š), i.e.,
ğ‘š = âƒ—ğ‘ğ‘¡
âƒ—ğ‘ğ‘¡
ğ‘š Â· CRTğ‘š .
62
Also as shown in [LPR13a, Section 3], CRTğ‘š admits the following sparse decompositions
for ğ‘š > ğ‘:7
CRTğ‘š = (DFTğ‘š/ğ‘ âŠ— ğ¼ğ‘âˆ’1) Â· Ë†ğ‘‡ğ‘š Â· (ğ¼ğ‘š/ğ‘ âŠ— CRTğ‘)
DFTğ‘š = (DFTğ‘š/ğ‘ âŠ— ğ¼ğ‘) Â· ğ‘‡ğ‘š Â· (ğ¼ğ‘š/ğ‘ âŠ— DFTğ‘) .
(3.3.2)
(3.3.3)
(These decompositions can be applied recursively until all the CRT and DFT terms have
subscript ğ‘.) Here DFTğ‘ is a square ğ‘-dimensional matrix with rows and columns indexed
from zero, and CRTğ‘ is its lower-left (ğ‘ âˆ’ 1)-dimensional square submatrix, with rows
indexed from one and columns indexed from zero. The (ğ‘–, ğ‘—)th entry of each matrix is ğœ”ğ‘–ğ‘—
ğ‘ ,
ğ‘š . Finally, Ë†ğ‘‡ğ‘š, ğ‘‡ğ‘š are diagonal â€œtwiddleâ€ matrices whose diagonal entries
where ğœ”ğ‘ = ğœ”ğ‘š/ğ‘
are certain powers of ğœ”ğ‘š.
For the inverses CRTâˆ’1
ğ‘š and DFTâˆ’1
ğ‘š , by standard properties of matrix and Kronecker
products, we have sparse decompositions mirroring those in Equations (3.3.2) and (3.3.3).
Note that DFTğ‘ is invertible if and only if ğ‘ is invertible in the base ring, and the same goes
for CRTğ‘, except that CRT2 (which is just unity) is always invertible. More speciï¬cally,
DFTâˆ’1
ğœ”âˆ’ğ‘–ğ‘—
ğ‘, the (scaled) conjugate transpose of DFTğ‘, whose (ğ‘–, ğ‘—)th entry is
ğ‘ = ğ‘âˆ’1 Â· DFT*
. For CRTâˆ’1
ğ‘ , it can be veriï¬ed that for ğ‘ > 2,
ğ‘
ğ‘ = ğ‘âˆ’1 Â·(ï¸€ğ‘‹ âˆ’ 1 Â· (ğœ”1
CRTâˆ’1
)ğ‘¡)ï¸€,
ğ‘, ğœ”2
ğ‘, . . . , ğœ”ğ‘âˆ’1
ğ‘
where ğ‘‹ is the upper-right (ğ‘âˆ’1)-dimensional square submatrix of DFT*
in the sparse decomposition for CRTâˆ’1
factors from the CRTâˆ’1
ğ‘ and DFTâˆ’1
by the CRTrans interface; see subsection 3.2.5.)
ğ‘. Finally, note that
ğ‘š (for aribtrary ğ‘š), we can collect all the individual ğ‘âˆ’1
terms into a single Ë†ğ‘šâˆ’1 factor. (This factor is exposed
ğ‘
7In these decompositions, the order of arguments to the Kronecker products is swapped as compared with
those appearing in [LPR13a]. This is due to our corresponding reversal of the factors in the Kronecker-product
decompositions of the powerful and CRT bases. The ordering here is more convenient for implementation,
but note that it yields bases and twiddle factors in â€œdigit-reversedâ€ order. In particular, the twiddle matrices
^ğ‘‡ğ‘š, ğ‘‡ğ‘š here are permuted versions of the ones deï¬ned in [LPR13a].
63
The Tensor methods crt and crtInv respectively represent multiplication by CRTğ‘š
and its inverse. These methods themselves are wrapped by Maybe, so that they can be
Nothing when there is no CRT basis over the base ring.
Generating (Tweaked) Gaussians in the Decoding Basis
Cryptographic applications often need to sample secret error terms from a prescribed distri-
bution. For the original deï¬nition of Ring-LWE involving the dual ideal ğ‘…âˆ¨ (see section 2.2),
it is particularly useful to use distributions ğ·ğ‘Ÿ that correspond to (continuous) spherical
Gaussians in the canonical embedding. For sufï¬ciently large ğ‘Ÿ, these distributions are
supported by worst-case hardness proofs [LPR13b]. Note that the error can be discretized in
a variety of ways, with no loss in hardness.
With the â€œtweakedâ€ perspective that replaces ğ‘…âˆ¨ by ğ‘… via the tweak factor ğ‘¡ğ‘š âˆˆ ğ‘…, we
are interested in sampling from tweaked distributions ğ‘¡ğ‘š Â· ğ·ğ‘Ÿ. More precisely, we want a
randomized algorithm that samples a coefï¬cient vector over R, with respect to one of the
standard bases of ğ‘…, of a random element that is distributed as ğ‘¡ğ‘š Â· ğ·ğ‘Ÿ. This is not entirely
trivial because (except in the power-of-two case) ğ‘… does not have an orthogonal basis, so
the output coefï¬cients will not be independent.
The material in [LPR13a, Section 6.3] yields a specialized, fast algorithm for sampling
from ğ·ğ‘Ÿ with output represented in the decoding basis âƒ—ğ‘ğ‘š of ğ‘…âˆ¨. Equivalently, the very
same algorithm samples from the tweaked Gaussian ğ‘¡ğ‘š Â· ğ·ğ‘Ÿ relative to the decoding basis
âƒ—ğ‘‘ğ‘š = ğ‘¡ğ‘š Â· âƒ—ğ‘ğ‘š of ğ‘…. The algorithm is faster (often much moreso) than the naÃ¯ve one that
applies a full CRT*
ğ‘š (over C) to a Gaussian in the canonical embedding. The efï¬ciency
comes from skipping several layers of orthogonal transforms (namely, scaled DFTs and
twiddle matrices), which is possible due to the rotation-invariance of spherical Gaussians.
The algorithm also avoids complex numbers entirely, instead using only reals.
64
The algorithm. The sampling algorithm simply applies a certain linear transform over R,
whose matrix ğ¸ğ‘š has a sparse decomposition as described below, to a vector of i.i.d.
real Gaussian samples with parameter ğ‘Ÿ, and outputs the resulting vector. The Tensor
method tGaussianDec implements the algorithm, given ğ‘£ = ğ‘Ÿ2. (Note that its output type
rnd (t m q) for MonadRandom rnd is necessarily monadic, because the algorithm is
randomized.)
As with all the transforms considered above, we describe the sparse decomposition
of ğ¸ğ‘š where ğ‘š is a power of a prime ğ‘, which then generalizes to arbitrary ğ‘š as described
in subsection 3.3.1. For ğ‘š > ğ‘, we have
where ğ¸2 is unity and ğ¸ğ‘ for ğ‘ > 2 is
ğ¸ğ‘š =âˆšï¸€ğ‘š/ğ‘ Â· (ğ¼ğ‘š/ğ‘ âŠ— ğ¸ğ‘),
â›âœâœâœâœâœâğ¼ âˆ’âˆšâˆ’1ğ½
âˆšâˆ’1ğ¼
ğ½
ââŸâŸâŸâŸâŸâ  âˆˆ R(ğ‘âˆ’1)Ã—(ğ‘âˆ’1) ,
ğ¸ğ‘ = 1âˆš
2
Â· CRT*
ğ‘ Â·
where CRTğ‘ is over C, and ğ½ is the â€œreversalâ€ matrix obtained by reversing the columns
of the identity matrix.8 Expanding the above product, ğ¸ğ‘ has rows indexed from zero and
âˆš
2 Â·
sin ğœƒğ‘–Â·ğ‘—
columns indexed from one, and its (ğ‘–, ğ‘—)th entry is
â§âªâªâ¨âªâªâ©cos ğœƒğ‘–Â·ğ‘—
prime-power factorization ğ‘šâ„“ = âˆï¸€
8We remark that the signs of the rightmost block of the above matrix (containing âˆ’âˆšâˆ’1ğ½ and
â„“ ğ‘šâ„“, we can apply all theâˆšï¸€ğ‘šâ„“/ğ‘â„“ scaling factors
Finally, note that in the sampling algorithm, when applying ğ¸ğ‘š for arbitrary ğ‘š with
for 1 â‰¤ ğ‘— < ğ‘/2
for ğ‘/2 < ğ‘— â‰¤ ğ‘ âˆ’ 1
,
ğœƒğ‘˜ = 2ğœ‹ğ‘˜/ğ‘.
âˆšâˆ’1ğ¼) is
swapped as compared with what appears in [LPR13a, Section 6.3]. The choice of sign is arbitrary, because
any orthonormal basis of the subspace spanned by the columns works equally well.
65
(from the ğ¸ğ‘šâ„“ terms) to the parameter ğ‘Ÿ of the Gaussian input vector, i.e., use parameter
ğ‘Ÿâˆšï¸€ğ‘š/ rad(ğ‘š) instead.
Gram Matrix of Decoding Basis
Certain cryptographic applications need to obtain the Euclidean norm, under the canonical
embedding ğœ, of cyclotomic ring elements (usually, error terms). Let âƒ—ğ‘ denote any Q-basis
of the ambient number ï¬eld and let ğœ denote conjugation, which maps any root of unity to
its inverse. Then the squared norm of ğœ(ğ‘’), where ğ‘’ = âƒ—ğ‘ğ‘¡ Â· e for some rational coefï¬cient
vector e, is
â€–ğœ(ğ‘’)â€–2 = âŸ¨ğœ(ğ‘’), ğœ(ğ‘’)âŸ© = Trğ‘…/Z(ğ‘’ Â· ğœ (ğ‘’)) = eğ‘¡ Â· Trğ‘…/Z(âƒ—ğ‘ Â· ğœ (âƒ—ğ‘ğ‘¡)) Â· e = âŸ¨e, ğºeâŸ© ,
where ğº = Trğ‘…/Z(âƒ—ğ‘ Â· ğœ (âƒ—ğ‘ğ‘¡)) denotes the Gram matrix of the basis âƒ—ğ‘. So computing the
squared norm mainly involves multiplication by the Gram matrix.
As shown below, the Gram matrix of the decoding basis âƒ—ğ‘ğ‘š of ğ‘…âˆ¨ has a particularly
simple sparse decomposition. Now, because the tweaked decoding basis âƒ—ğ‘‘ğ‘š = ğ‘¡ğ‘š Â· âƒ—ğ‘ğ‘š
of ğ‘… satisï¬es ğ‘”ğ‘š Â· âƒ—ğ‘‘ğ‘š = Ë†ğ‘š Â· âƒ—ğ‘ğ‘š, the same Gram matrix also yields â€–ğœ(ğ‘”ğ‘š Â· ğ‘’)â€–2 (up to
a Ë†ğ‘š2 scaling factor) from the coefï¬cient tensor of ğ‘’ with respect to âƒ—ğ‘‘ğ‘š. This is exactly
what is needed when using tweaked Gaussian errors ğ‘’ âˆˆ ğ‘…, because the â€œuntweakedâ€ error
ğ‘”ğ‘š Â· ğ‘’ is short and (near-)spherical in the canonical embedding (see, e.g., Invariant 4.2.2).
The Tensor method gSqNormDec maps the coefï¬cient tensor of ğ‘’ (with respect to âƒ—ğ‘‘ğ‘š) to
Ë†ğ‘šâˆ’1 Â· â€–ğœ(ğ‘”ğ‘š Â· ğ‘’)â€–2.9
9The ^ğ‘šâˆ’1 factor compensates for the implicit scaling between âƒ—ğ‘ğ‘š and ğ‘”ğ‘š Â· âƒ—ğ‘‘ğ‘š, and is the smallest such
factor that guarantees an integer output when the input coefï¬cients are integral.
66
Recall that âƒ—ğ‘ğ‘š is deï¬ned as the dual, under Trğ‘…/Z, of the conjugate powerful basis ğœ (âƒ—ğ‘ğ‘š).
From this it can be veriï¬ed that
âƒ—ğ‘ğ‘ = ğ‘âˆ’1 Â·(ï¸€ğœ ğ‘—
ğ‘ âˆ’ ğœâˆ’1
âƒ—ğ‘ğ‘š,ğ‘ = (ğ‘š/ğ‘)âˆ’1 Â· âƒ—ğ‘ğ‘š,ğ‘ .
)ï¸€
ğ‘
ğ‘—=0,...,ğ‘âˆ’2
Using the above, an elementary calculation shows that
ğ‘ Â· Trğ‘,1(âƒ—ğ‘ğ‘ Â· ğœ (âƒ—ğ‘ğ‘)) = ğ¼ğ‘âˆ’1 + 1
(ğ‘š/ğ‘) Â· Trğ‘š,ğ‘(âƒ—ğ‘ğ‘š,ğ‘ Â· ğœ (âƒ—ğ‘ğ‘š,ğ‘)) = ğ¼ğ‘š/ğ‘ ,
where 1 denotes the all-1s matrix. (Note that for ğ‘ = 2, the Gram matrix of âƒ—ğ‘ğ‘ is just unity.)
Combining these, we have
ğ‘š Â· Trğ‘…/Z(âƒ—ğ‘ğ‘š Â· ğœ (âƒ—ğ‘ğ‘š)ğ‘¡) = ğ‘ Â· Trğ‘,1((ğ‘š/ğ‘) Â· Trğ‘š,ğ‘(âƒ—ğ‘ğ‘š,ğ‘ Â· ğœ (âƒ—ğ‘ğ‘¡