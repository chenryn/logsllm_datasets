⎛⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎝
⎞⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎠
⎞⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎠
,
𝑝 − 1 ··· −1 −1
−1
...
3
2
1
...
···
···
···
...
3
2
1
...
...
3 − 𝑝 3 − 𝑝
.
2 − 𝑝
1
2
1
1 2 − 𝑝 3 − 𝑝 ··· −1
1
1
...
1
2
2
...
2
3 − 𝑝 ··· −1
··· −1
...
...
··· 𝑝 − 1
3
...
3
and its inverse (which represents division by 𝑔𝑝 in the powerful basis) are the
where 𝐺pow
square (𝑝 − 1)-dimensional matrices
𝑝
Identical decompositions hold for 𝐺dec
𝑚 and 𝐺crt
in the decoding and CRT bases, respectively), where
𝑚 (which represent multiplication by 𝑔𝑚
𝐺dec
𝑝 =
(𝐺dec
𝑝 )−1 = 𝑝−1 ·
,
𝑝 is the diagonal matrix with 1 − 𝜔𝑖
and 𝐺crt
𝑝 in the 𝑖th diagonal entry (indexed from 1 to
𝑝 − 1), where 𝜔𝑝 is the same primitive 𝑝th root of unity in the base ring used to deﬁne the
CRT basis.
61
The linear transforms represented by the above matrices can be applied in time linear in
For (𝐺dec
the dimension. For 𝐺pow
𝑝 and its inverse this is obvious, due to their sparsity.
𝑝 )−1, this follows from the fact that every row (apart from the top one) differs from
)−1, we can compute the entries of the output
vector from the bottom up, by computing the sum of all the input entries and their partial
the preceding one by a single entry. For (𝐺pow
, 𝐺dec
𝑝 , and 𝐺crt
𝑝
𝑝
sums from the bottom up.
The Tensor methods mulGPow and mulGDec represent multiplication by 𝐺pow
𝑚 and 𝐺dec
𝑚 ,
respectively. Similarly, the methods divGPow and divGDec represent division by these
matrices; note that their outputs are wrapped by Maybe, so that the output can be Nothing
when division fails. Finally, mulGCRT and divGCRT represent multiplication and division by
𝐺crt
𝑚; note that these methods themselves are wrapped by Maybe, because 𝐺crt
𝑚 and its inverse
are well-deﬁned over the base ring exactly when a CRT basis exists. (In this case, division
always succeeds, hence no Maybe is needed for the output of divGCRT.)
Chinese Remainder and Discrete Fourier Transforms
Consider a base ring, like Z𝑞 or C, that admits an invertible index-𝑚 Chinese Remainder
Transform CRT𝑚, deﬁned by a principal 𝑚th root of unity 𝜔𝑚. Then as shown in [LPR13a,
Section 3], this transform converts from the powerful basis to the CRT basis (deﬁned by the
same 𝜔𝑚), i.e.,
𝑚 = ⃗𝑐𝑡
⃗𝑝𝑡
𝑚 · CRT𝑚 .
62
Also as shown in [LPR13a, Section 3], CRT𝑚 admits the following sparse decompositions
for 𝑚 > 𝑝:7
CRT𝑚 = (DFT𝑚/𝑝 ⊗ 𝐼𝑝−1) · ˆ𝑇𝑚 · (𝐼𝑚/𝑝 ⊗ CRT𝑝)
DFT𝑚 = (DFT𝑚/𝑝 ⊗ 𝐼𝑝) · 𝑇𝑚 · (𝐼𝑚/𝑝 ⊗ DFT𝑝) .
(3.3.2)
(3.3.3)
(These decompositions can be applied recursively until all the CRT and DFT terms have
subscript 𝑝.) Here DFT𝑝 is a square 𝑝-dimensional matrix with rows and columns indexed
from zero, and CRT𝑝 is its lower-left (𝑝 − 1)-dimensional square submatrix, with rows
indexed from one and columns indexed from zero. The (𝑖, 𝑗)th entry of each matrix is 𝜔𝑖𝑗
𝑝 ,
𝑚 . Finally, ˆ𝑇𝑚, 𝑇𝑚 are diagonal “twiddle” matrices whose diagonal entries
where 𝜔𝑝 = 𝜔𝑚/𝑝
are certain powers of 𝜔𝑚.
For the inverses CRT−1
𝑚 and DFT−1
𝑚 , by standard properties of matrix and Kronecker
products, we have sparse decompositions mirroring those in Equations (3.3.2) and (3.3.3).
Note that DFT𝑝 is invertible if and only if 𝑝 is invertible in the base ring, and the same goes
for CRT𝑝, except that CRT2 (which is just unity) is always invertible. More speciﬁcally,
DFT−1
𝜔−𝑖𝑗
𝑝, the (scaled) conjugate transpose of DFT𝑝, whose (𝑖, 𝑗)th entry is
𝑝 = 𝑝−1 · DFT*
. For CRT−1
𝑝 , it can be veriﬁed that for 𝑝 > 2,
𝑝
𝑝 = 𝑝−1 ·(︀𝑋 − 1 · (𝜔1
CRT−1
)𝑡)︀,
𝑝, 𝜔2
𝑝, . . . , 𝜔𝑝−1
𝑝
where 𝑋 is the upper-right (𝑝−1)-dimensional square submatrix of DFT*
in the sparse decomposition for CRT−1
factors from the CRT−1
𝑝 and DFT−1
by the CRTrans interface; see subsection 3.2.5.)
𝑝. Finally, note that
𝑚 (for aribtrary 𝑚), we can collect all the individual 𝑝−1
terms into a single ˆ𝑚−1 factor. (This factor is exposed
𝑝
7In these decompositions, the order of arguments to the Kronecker products is swapped as compared with
those appearing in [LPR13a]. This is due to our corresponding reversal of the factors in the Kronecker-product
decompositions of the powerful and CRT bases. The ordering here is more convenient for implementation,
but note that it yields bases and twiddle factors in “digit-reversed” order. In particular, the twiddle matrices
^𝑇𝑚, 𝑇𝑚 here are permuted versions of the ones deﬁned in [LPR13a].
63
The Tensor methods crt and crtInv respectively represent multiplication by CRT𝑚
and its inverse. These methods themselves are wrapped by Maybe, so that they can be
Nothing when there is no CRT basis over the base ring.
Generating (Tweaked) Gaussians in the Decoding Basis
Cryptographic applications often need to sample secret error terms from a prescribed distri-
bution. For the original deﬁnition of Ring-LWE involving the dual ideal 𝑅∨ (see section 2.2),
it is particularly useful to use distributions 𝐷𝑟 that correspond to (continuous) spherical
Gaussians in the canonical embedding. For sufﬁciently large 𝑟, these distributions are
supported by worst-case hardness proofs [LPR13b]. Note that the error can be discretized in
a variety of ways, with no loss in hardness.
With the “tweaked” perspective that replaces 𝑅∨ by 𝑅 via the tweak factor 𝑡𝑚 ∈ 𝑅, we
are interested in sampling from tweaked distributions 𝑡𝑚 · 𝐷𝑟. More precisely, we want a
randomized algorithm that samples a coefﬁcient vector over R, with respect to one of the
standard bases of 𝑅, of a random element that is distributed as 𝑡𝑚 · 𝐷𝑟. This is not entirely
trivial because (except in the power-of-two case) 𝑅 does not have an orthogonal basis, so
the output coefﬁcients will not be independent.
The material in [LPR13a, Section 6.3] yields a specialized, fast algorithm for sampling
from 𝐷𝑟 with output represented in the decoding basis ⃗𝑏𝑚 of 𝑅∨. Equivalently, the very
same algorithm samples from the tweaked Gaussian 𝑡𝑚 · 𝐷𝑟 relative to the decoding basis
⃗𝑑𝑚 = 𝑡𝑚 · ⃗𝑏𝑚 of 𝑅. The algorithm is faster (often much moreso) than the naïve one that
applies a full CRT*
𝑚 (over C) to a Gaussian in the canonical embedding. The efﬁciency
comes from skipping several layers of orthogonal transforms (namely, scaled DFTs and
twiddle matrices), which is possible due to the rotation-invariance of spherical Gaussians.
The algorithm also avoids complex numbers entirely, instead using only reals.
64
The algorithm. The sampling algorithm simply applies a certain linear transform over R,
whose matrix 𝐸𝑚 has a sparse decomposition as described below, to a vector of i.i.d.
real Gaussian samples with parameter 𝑟, and outputs the resulting vector. The Tensor
method tGaussianDec implements the algorithm, given 𝑣 = 𝑟2. (Note that its output type
rnd (t m q) for MonadRandom rnd is necessarily monadic, because the algorithm is
randomized.)
As with all the transforms considered above, we describe the sparse decomposition
of 𝐸𝑚 where 𝑚 is a power of a prime 𝑝, which then generalizes to arbitrary 𝑚 as described
in subsection 3.3.1. For 𝑚 > 𝑝, we have
where 𝐸2 is unity and 𝐸𝑝 for 𝑝 > 2 is
𝐸𝑚 =√︀𝑚/𝑝 · (𝐼𝑚/𝑝 ⊗ 𝐸𝑝),
⎛⎜⎜⎜⎜⎜⎝𝐼 −√−1𝐽
√−1𝐼
𝐽
⎞⎟⎟⎟⎟⎟⎠ ∈ R(𝑝−1)×(𝑝−1) ,
𝐸𝑝 = 1√
2
· CRT*
𝑝 ·
where CRT𝑝 is over C, and 𝐽 is the “reversal” matrix obtained by reversing the columns
of the identity matrix.8 Expanding the above product, 𝐸𝑝 has rows indexed from zero and
√
2 ·
sin 𝜃𝑖·𝑗
columns indexed from one, and its (𝑖, 𝑗)th entry is
⎧⎪⎪⎨⎪⎪⎩cos 𝜃𝑖·𝑗
prime-power factorization 𝑚ℓ = ∏︀
8We remark that the signs of the rightmost block of the above matrix (containing −√−1𝐽 and
ℓ 𝑚ℓ, we can apply all the√︀𝑚ℓ/𝑝ℓ scaling factors
Finally, note that in the sampling algorithm, when applying 𝐸𝑚 for arbitrary 𝑚 with
for 1 ≤ 𝑗 < 𝑝/2
for 𝑝/2 < 𝑗 ≤ 𝑝 − 1
,
𝜃𝑘 = 2𝜋𝑘/𝑝.
√−1𝐼) is
swapped as compared with what appears in [LPR13a, Section 6.3]. The choice of sign is arbitrary, because
any orthonormal basis of the subspace spanned by the columns works equally well.
65
(from the 𝐸𝑚ℓ terms) to the parameter 𝑟 of the Gaussian input vector, i.e., use parameter
𝑟√︀𝑚/ rad(𝑚) instead.
Gram Matrix of Decoding Basis
Certain cryptographic applications need to obtain the Euclidean norm, under the canonical
embedding 𝜎, of cyclotomic ring elements (usually, error terms). Let ⃗𝑏 denote any Q-basis
of the ambient number ﬁeld and let 𝜏 denote conjugation, which maps any root of unity to
its inverse. Then the squared norm of 𝜎(𝑒), where 𝑒 = ⃗𝑏𝑡 · e for some rational coefﬁcient
vector e, is
‖𝜎(𝑒)‖2 = ⟨𝜎(𝑒), 𝜎(𝑒)⟩ = Tr𝑅/Z(𝑒 · 𝜏 (𝑒)) = e𝑡 · Tr𝑅/Z(⃗𝑏 · 𝜏 (⃗𝑏𝑡)) · e = ⟨e, 𝐺e⟩ ,
where 𝐺 = Tr𝑅/Z(⃗𝑏 · 𝜏 (⃗𝑏𝑡)) denotes the Gram matrix of the basis ⃗𝑏. So computing the
squared norm mainly involves multiplication by the Gram matrix.
As shown below, the Gram matrix of the decoding basis ⃗𝑏𝑚 of 𝑅∨ has a particularly
simple sparse decomposition. Now, because the tweaked decoding basis ⃗𝑑𝑚 = 𝑡𝑚 · ⃗𝑏𝑚
of 𝑅 satisﬁes 𝑔𝑚 · ⃗𝑑𝑚 = ˆ𝑚 · ⃗𝑏𝑚, the same Gram matrix also yields ‖𝜎(𝑔𝑚 · 𝑒)‖2 (up to
a ˆ𝑚2 scaling factor) from the coefﬁcient tensor of 𝑒 with respect to ⃗𝑑𝑚. This is exactly
what is needed when using tweaked Gaussian errors 𝑒 ∈ 𝑅, because the “untweaked” error
𝑔𝑚 · 𝑒 is short and (near-)spherical in the canonical embedding (see, e.g., Invariant 4.2.2).
The Tensor method gSqNormDec maps the coefﬁcient tensor of 𝑒 (with respect to ⃗𝑑𝑚) to
ˆ𝑚−1 · ‖𝜎(𝑔𝑚 · 𝑒)‖2.9
9The ^𝑚−1 factor compensates for the implicit scaling between ⃗𝑏𝑚 and 𝑔𝑚 · ⃗𝑑𝑚, and is the smallest such
factor that guarantees an integer output when the input coefﬁcients are integral.
66
Recall that ⃗𝑏𝑚 is deﬁned as the dual, under Tr𝑅/Z, of the conjugate powerful basis 𝜏 (⃗𝑝𝑚).
From this it can be veriﬁed that
⃗𝑏𝑝 = 𝑝−1 ·(︀𝜁 𝑗
𝑝 − 𝜁−1
⃗𝑏𝑚,𝑝 = (𝑚/𝑝)−1 · ⃗𝑝𝑚,𝑝 .
)︀
𝑝
𝑗=0,...,𝑝−2
Using the above, an elementary calculation shows that
𝑝 · Tr𝑝,1(⃗𝑏𝑝 · 𝜏 (⃗𝑏𝑝)) = 𝐼𝑝−1 + 1
(𝑚/𝑝) · Tr𝑚,𝑝(⃗𝑏𝑚,𝑝 · 𝜏 (⃗𝑏𝑚,𝑝)) = 𝐼𝑚/𝑝 ,
where 1 denotes the all-1s matrix. (Note that for 𝑝 = 2, the Gram matrix of ⃗𝑏𝑝 is just unity.)
Combining these, we have
𝑚 · Tr𝑅/Z(⃗𝑏𝑚 · 𝜏 (⃗𝑏𝑚)𝑡) = 𝑝 · Tr𝑝,1((𝑚/𝑝) · Tr𝑚,𝑝(⃗𝑏𝑚,𝑝 · 𝜏 (⃗𝑏𝑡