nearly perfect match. The errors were larger for the ping-
times. The median of the relative errors was 0.16, the stan-
dard deviation was 0.47. That is, in the live run, on average
the pings needed longer than in pseudo-realtime. However,
the median of the absolute errors was 2ms (standard devi-
ation 5ms), i.e. the differences were in fact rather small in
absolute terms. We assume that these discrepancies stem
from the increased system load when running live. In fact,
examining the system times of the main processes, the me-
dian of the relative errors was much larger than for the user
times (0.64 vs. 0.02). This is due to the live packet captur-
ing and ﬁltering which takes place inside the kernel.
All in all, we believe that pseudo-realtime provides us
with reproducible yet realistic measurements. Therefore,
we used it to examine the communication framework in
more detail.
Measurements: Having the pseudo-realtime mode in
place, we examined three different Bro conﬁgurations to
understand the impact of communication. We captured a
one-hour packet trace in the MWN environment. We in-
cluded all packets except those of one high-volume subnet.
To ensure that we do not lose packets, we captured the traf-
ﬁc with a high-performance Endace DAG card [5]. The
trace spanned 1 hour with a volume of 88GB and a mean
rate of 40K pps. It consisted of 5.2M ﬂows, 144M packets,
92.2% TCP and 6.7% UDP, with HTTP and SSH the most
common protocols (50% and 6% respectively).
We ﬁrst run Bro without any communication at all (using
the same setup as before). Then we conﬁgured it to prop-
agate all events to its peer. Finally, we changed the con-
ﬁguration to emit only a subset of events, which consisted
of all but the connection setup and tear-down events (and
their UDP equivalents raised for basic UDP requests and
replies). These events are semantically rather low-level but
comprise 95% of all events in our trace. Figure 4(b) shows
the differences in the number of events over time.
For the three different conﬁgurations, in Figure 5(a) we
see the densities of CPU utilization per second. The mea-
sured utilizations are the total sum of user and system time
of both main and communication processes (which is why
on the two-CPU machine the values can exceed 1). We
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:11:05 UTC from IEEE Xplore.  Restrictions apply. 
Figure 5: Different conﬁgurations on trace.
6 Summary
No communication
Propagating high−level events
Propagating all events
0.2
0.4
0.6
0.8
1.0
1.2
1.4
CPU utilization
(a) Total CPU utilization.
Propagating selected events
Propagating all events
y
t
i
s
n
e
d
y
t
i
l
i
b
a
b
o
r
P
y
t
i
s
n
e
d
y
t
i
l
i
b
a
b
o
r
P
6
5
4
3
2
1
0
0
6
0
5
0
4
0
3
0
2
0
1
0
0.00
0.02
0.04
0.06
0.08
Ping−time (secs)
(b) Ping-times
see that when emitting all events the average utilization in-
creased noticably: the median shifts from 0.46 without any
communication to 0.97. Yet, with the subset of events the
performance impact is only marginal (median 0.49). Look-
ing at the ping times (Figure 5(b)), we hardly see a differ-
ence between the two runs which involve communication:
with all events, the median of the ping-times was 19ms
while with the subset it was 18ms. Thus, the communi-
cation system was working well within its capacity limits.
In general, the ping times are pleasantly low, considering
the ping/pong path across four processes which also had to
handle a signiﬁcant packet and event load.
Based on these results we draw two main conclusions.
First, our architecture works well enough to support prop-
agating thousands of events even when having to handle a
high packet load (which may either represent normal activ-
ity or be due to an attack). However, in such situations it
does incur a noticable overhead: the increased CPU utiliza-
tion is non-negligible. This implies that simply forward-
ing all events will not scale very well in larger installations.
Giving the amount of trafﬁc, this is hardly surprising. How-
ever, we also see that with smaller amounts of events, the
performance overhead is not signiﬁcant. Thus, distribution
schemes which focus on propagating higher-level events are
a very promising approach for large-scale installations.
In this work we demonstrated the power of exploiting in-
dependent state in network intrusion detection. While tra-
ditionally much of a NIDS’s state resides solely in volatile
memory, we instead argue for making all of a NIDS’s state
exist (potentially) “outside” of any particular process. To
this end, we developed the notions of spatially indepen-
dent state (state that can be propagated from one instance
of the NIDS to another concurrently running process) and
temporally independent state (state that continues to exists
after the termination of all instances, available to future pro-
cesses). The architecture we implemented facilitates inde-
pendent state for the Bro intrusion detection system [16].
It is uniﬁed in that it encompasses all of the internal, ﬁne-
grained state of the NIDS. Thereby, we can continue to pro-
cess independent state using the full set of mechanisms pro-
vided by the system.
The main internal mechanism of our architecture is a
serialization framework. While its implementation was
straight-forward in general, the system’s internal complex-
ity gave us a number of subtle issues to solve. Having the
serialization in place, we added a user-level interface driven
by our operational applications. It enables the user to selec-
tively declare state to be independent. To achieve tempo-
ral independence, we serialize state into ﬁles, either when
an instance exits, or incrementally as it executes. A sub-
sequent process can then read it back. To achieve spatial
independence, we added secure network communication to
the NIDS, allowing instances to share state across different
locations.
The architecture provides us with a wealth of possible
applications. We enhanced Bro’s traditional model of reg-
ular checkpointing by allowing a controlled loss of state,
added crash-recovery, examined different approaches for
distributing the monitoring and analysis, enabled run-time
policy management, and greatly extended the system’s pro-
ﬁling and debugging facilities. These applications were
driven by our operational experiences, and we experimented
with all of them in several large-scale environments. A
performance evaluation of the communication component
shows that our implementation is suitable for deployment
even in large-scale installations. Our architecture has been
included into the latest Bro development version, and we are
in the process of setting up our monitoring environments
to use independent state operationally. We expect that in
regular operational use, the power of independent state will
soon prove invaluable. Moreover, a client library has been
developed to interface trusted applications to the Bro sys-
tem [4]. With its help, we have already successfully inte-
grated Apache web servers [8] and SSH servers into Bro’s
analysis. In addition, we are working on extending Bro’s
event model to more directly support scalable distributed
event analysis [12]. Furthermore, for users who are less fa-
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:11:05 UTC from IEEE Xplore.  Restrictions apply. 
miliar with the details of Bro’s operation, we are planning to
provide predeﬁned sets of related script-level objects. This
will enable the user to share coherent chunks of state among
instances easily, rather than needing to identify individual
relevant script-level variables and events himself.
7 Acknowledgments
We would like to thank the Lawrence Berkeley Na-
tional Laboratory (LBNL), Berkeley, USA; the Leibniz-
Rechenzentrum, M¨unchen, Germany; and the University
of California, Berkeley, USA. We would also like to thank
Anja Feldmann for supporting our work and providing feed-
back, and Mark Allman and Scott Campbell for their helpful
comments. Finally, we would like to thank the anonymous
reviewers for their valuable suggestions.
This work was made possible by the U.S. National Sci-
ence Foundation grant STI-0334088, for which we are
grateful.
References
[1] E. G. Amoroso. Intrusion Detection: An Introduction to In-
ternet Surveillance, Correlation, Trace Back and Response.
Intrusion.Net Books, New Jersey, 1999.
[2] S. Axelsson. The Base-Rate Fallacy and Its Implications for
the Difﬁculty of Intrusion Detection. In ACM Conference on
Computer and Communications Security, pages 1–7, 1999.
[3] CERT Advisory CA-2003-20 W32/Blaster worm.
http://www.cert.org/advisories/
CA-2003-20.html.
[4] Broccoli: The Bro Client Communications Library. http:
//www.cl.cam.ac.uk/∼cpk25/broccoli/.
[5] ENDACE Measurement Systems.
http://www.
endace.com/.
[6] H. Debar and A. Wespi. Aggregation and Correlation of
Intrusion-Detection Alerts. In Proc. Recent Advances in In-
trusion Detection, number 2212 in Lecture Notes in Com-
puter Science. Springer-Verlag, 2001.
[7] H. Dreger, A. Feldmann, V. Paxson, and R. Sommer. Op-
erational Experiences with High-Volume Network Intrusion
Detection. In Proc. 11th ACM Conference on Computer and
Communications Security, 2004.
[8] H. Dreger, C. Kreibich, V. Paxson, and R. Sommer. Enhanc-
ing the Accuracy of Network-based Intrusion Detection with
Host-based Context. In Proc. Conference on Detection of In-
trusions and Malware and Vulnerability Assessment, 2005.
Format.
Detection Message
[9] Intrusion
Exchange
http://www.ietf.org/html.charters/
idwg-charter.html.
[10] K. Julisch. Clustering Intrusion Detection Alarms to Support
Root Cause Analysis. ACM Transactions on Information
and System Security, 6(4):443–471, 2003.
[11] J. Jung, V. Paxson, A. W. Berger, and H. Balakrishnan. Fast
Portscan Detection Using Sequential Hypothesis Testing. In
Proc. IEEE Symposium on Security and Privacy, 2004.
[12] C. Kreibich and R. Sommer. Policy-controlled Event Man-
agement for Distributed Intrusion Detection. In Proc. 4th In-
ternational Workshop on Distributed Event-Based Systems,
2005.
[13] C. Kr¨ugel, T. Toth, and C. Kerer. Decentralized Event Corre-
lation for Intrusion Detection . In Proc. Information Security
and Cryptology, volume 2288 of Lecture Notes in Computer
Science, 2001.
[14] C. Kr¨ugel, F. Valeur, G. Vigna, and R. A. Kemmerer. State-
ful Intrusion Detection for High-Speed Networks. In Proc.
IEEE Symposium on Security and Privacy, 2002.
[15] OpenSSL. http://www.openssl.org.
[16] V. Paxson. Bro: A System for Detecting Network Intruders
in Real-Time. Computer Networks, 31(23–24):2435–2463,
1999.
[17] P. A. Porras and P. G. Neumann. EMERALD: Event mon-
itoring enabling responses to anomalous live disturbances.
In National Information Systems Security Conference, Bal-
timore, MD, October 1997.
[18] Snapp, S., et al. DIDS (Distributed Intrusion Detection Sys-
tem) – Motivation, Architecture, and an Early Prototype. In
Proc. 14th NIST-NCSC National Computer Security Confer-
ence, 1991.
[19] R. Sommer. Viable Network Intrusion Detection in High-
PhD thesis, TU M¨unchen,
Performance Environments.
2005.
[20] R. Sommer and V. Paxson. Enhancing Byte-Level Network
Intrusion Detection Signatures with Context. In Proc. 10th
ACM Conference on Computer and Communications Secu-
rity, 2003.
[21] J. Soukup. Taming C++ – Pattern Classes and Persistence
for Large Projects. Addison-Wesley, 1994.
[22] E. H. Spafford and D. Zamboni. Intrusion Detection Using
Autonomous Agents. Computer Networks, 34(4):547–570,
2000.
[23] Staniford-Chen, S., et al. GrIDS – A Graph-based Intrusion
Detection System for Large Networks. In Proc. 19th NIST-
NCSC National Information Systems Security Conference,
1996.
[24] A. S. Tanenbaum and M. V. Steen. Distributed Systems –
Principles and Paradigms. Prentice Hall, 2002.
[25] A. Valdes and K. Skinner.
Probabilistic Alert Correla-
tion. In Proc. Recent Advances in Intrusion Detection, num-
ber 2212 in Lecture Notes in Computer Science. Springer-
Verlag, 2001.
[26] G. Vigna and R. A. Kemmerer. NetSTAT: A Network-based
Intrusion Detection System. Journal of Computer Security,
7(1):37–71, 1999.
[27] G. Vigna, R. A. Kemmerer, and P. Blix. Designing a Web of
Highly-Conﬁgurable Intrusion Detection Sensors. In Proc.
Recent Advances in Intrusion Detection, number 2212 in
Lecture Notes in Computer Science, 2001.
[28] Y. Zhang and V. Paxson. Detecting Stepping Stones.
In
Proc. 9th USENIX Security Symposium, pages 171–184. The
USENIX Association, 2000.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:11:05 UTC from IEEE Xplore.  Restrictions apply.