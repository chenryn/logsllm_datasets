specify policies according to the format shown in Section 5.4.
In our particular use-case we prevent WhatsApp from ac-
cessing all contact phone numbers that belong to the do-
main corporate. Note that the domain name is maintained
in the kABPersonOrganizationProperty ﬁeld belonging to
the class ABRecordRef. Hence, when WhatsApp retrieves
the contacts, we simply validate for each record whether
kABPersonOrganizationProperty is set to corporate. If so,
we simply replace the entire record with NULL. Appendix A
presents the speciﬁc implementation of the policy.
7. RELATED WORK
The work related to XiOS can be roughly classiﬁed into
protection schemes for iOS and runtime protection mecha-
nisms that aim at hiding function pointers and instrument-
ing function calls.
iOS Security: There are a few proposals that aim at en-
hancing the security of iOS-based systems. PiOS is a static
privacy analysis tool that performs oﬀ-line path validation
on an application’s control-ﬂow graph [16]. Although PiOS
revealed that many apps leak the device ID to application
developers, it cannot detect Jekyll-like attacks [35] where
the malicious behavior is only triggered at runtime. On the
other hand, MoCFI [15] and PSiOS [37] could potentially
03691215182124271 Thread2 Threads4 Threads1 Thread2 Threads4 Threads1 Thread2 Threads4 Threads1 Thread2 Threads4 Threads1 Thread2 Threads4 Threads1 Thread2 Threads4 Threads1 Thread2 Threads4 Threads1 Thread2 Threads4 ThreadsFPU/ALUPI CalcMD5 CalcScrShotDiskQuartz2DResizeIMGTrans3DTime in seconds Benchmarks 100 Polices10 Policies1 PolicyDefaultprevent the mentioned attacks by enforcing control-ﬂow in-
tegrity (CFI) and ﬁne-grained sandboxing policies. How-
ever, both solutions require a jailbreak and suﬀer from per-
formance problems, which limit their deployment in prac-
tice. In contrast, XiOS avoids jailbreaking devices and only
incurs modest performance overhead.
Runtime Protection Mechanisms: For Android-based
systems, several Inline Reference Monitors (IRM) have been
proposed recently. Most of them insert a policy hook or
check before a critical function is called at Dalvik Bytecode
level [7, 22]. Most closely to our approach is Aurasium [39],
as it deploys a similar redirection technique:
it overwrites
entries of the global oﬀset table (GOT) – that holds run-
time addresses of lazy and non-lazy symbols – with the start
address of policy check functions. However, in contrast to
XiOS, it does not provide any mechanism to hide the actual
runtime addresses in a shadow table. Hence, an adversary
can deploy memory disclosure attacks to infer the runtime
address of a critical function and directly redirecting exe-
cution to it (via an indirect branch instruction). Moreover,
Aurasium can be bypassed through native code that directly
invokes system calls [13].
Since the GOT is critical in many Linux-based systems
to intiate runtime attacks, Xu et al. proposed a solution
that randomizes the GOT section at load-time, but allow
its address to be discovered through the procedure linkage
table (PLT) section [38]. Roglia et al. improve this solution
by randomizing the GOT section and rewriting the PLT re-
gion [29]. The mechanisms behind those two solutions can
be migrated to the iOS operating system. However, in con-
trast to our solution, both proposals need to be integrated
into the operating system as they require higher privileges
to rewrite a binary at load-time.
Another approach to instrument function calls aims at
adding a wrapper and verifying the parameters passed to
the function [9, 8]. A common mechanism to load such
interceptors is the Linux LD_PRELOAD linker facility which
forces the application to use a wrapper function rather than
the actual external function. However, since it is unrealistic
that every external function is replaced by a wrapper (due
to space and complexity reasons), an adversary can exploit
the knowledge of the runtime address of one single (not in-
strumented) function to directly call a private API.
In the domain of runtime attack mitigation the security
model of address space layout randomization (ASLR) is used
against memory (i.e., function pointer) disclosure attacks.
The basic idea is to randomize the start address of code and
data segments. Recently, several schemes have been pro-
posed to even enforce ﬁne-grained code randomization [10,
18, 21, 26, 23, 36, 12, 11]. However, sophisticated mem-
ory disclosure attacks [31] can bypass ASLR-based schemes.
Moreover, in order to mitigate the attacks presented in this
paper (Section 2.2 and 3), one would need operating system
support and a jailbreak, because ALSR needs to be applied
to the dynamic loader and public/private frameworks.
8. SUMMARY AND FUTURE WORK
Recent attacks have demonstrated that the current de-
sign of iOS is vulnerable to a variety of attacks that under-
mine the iOS sandboxing model leading to the invocation
of private APIs (e.g., sending text messages in background).
While previous attacks rely on speciﬁc assumptions such as
the availability of a public framework, we showed that the
default iOS application structure by itself can be easily ex-
ploited to invoke dangerous private APIs.
Since existing solutions suﬀer from performance overhead
or require a jailbreak, we introduce a new hardening ser-
vice, XiOS, that implants an inline reference monitor into
an iOS application to tackle these attacks without requiring
a jailbreak or source code of the application. This reference
monitor eﬃciently prevents an application from inferring
addresses of private APIs, and at the same time enforces
(optional) developer-deﬁned policies on public APIs. We
demonstrate the beneﬁts of the latter by enabling a contacts
ﬁltering mechanism for the popular WhatsApp messenger.
In the future, we plan to extend XiOS with a web fron-
tend, where end-users can conveniently upload their custom
policies that are automatically translated into C code and
deployed at runtime when the application is launched on
the device. In addition, we also aim at validating entire call
chains rather than only enforcing access control on a per
function-level.
9. REFERENCES
[1] Gensystek benchmark. http://www.
ooparts-universe.com/apps/app\_gensystek.html.
[2] Lazy binding. http://developer.blackberry.com/
native/documentation/core/com.qnx.doc.
neutrino.prog/topic/devel_lazy_binding.html.
[3] Whatsapp. http://www.whatsapp.com/.
[4] Apple Inc. App review. https:
//developer.apple.com/appstore/guidelines.html.
[5] Apple Inc. iOS developer enterprise program. https:
//developer.apple.com/programs/ios/enterprise/.
[6] Apple Inc. iOS frameworks. https://developer.
apple.com/library/ios/documentation/
Miscellaneous/Conceptual/iPhoneOSTechOverview/
iPhoneOSFrameworks/iPhoneOSFrameworks.html.
[7] M. Backes, S. Gerling, C. Hammer, M. Maﬀei, and
P. von Styp-Rekowsky. AppGuard: Enforcing user
requirements on Android apps. In International
Conference on Tools and Algorithms for the
Construction and Analysis of Systems, TACAS’13.
[8] A. Baratloo, N. Singh, and T. Tsai. Transparent
run-time defense against stack smashing attacks. In
USENIX Annual Technical Conference, ATC ’00.
[9] A. Barenghi, G. Pelosi, and F. Pozzi. Drop-in control
ﬂow hijacking prevention through dynamic library
interception. In Tenth International Conference on
Information Technology: New Generations (ITNG’13).
[10] E. G. Barrantes, D. H. Ackley, T. S. Palmer,
D. Stefanovic, and D. D. Zovi. Randomized
instruction set emulation to disrupt binary code
injection attacks. In ACM Conference on Computer
and Communications Security, CCS ’03.
[11] S. Bhatkar, D. C. DuVarney, and R. Sekar. Address
obfuscation: An eﬃcient approach to combat a board
range of memory error exploits. In USENIX Security,
SSYM’03.
[12] S. Bhatkar, R. Sekar, and D. C. DuVarney. Eﬃcient
techniques for comprehensive protection from memory
error exploits. In USENIX Security, SSYM’05.
[13] S. Bugiel, S. Heuser, and A.-R. Sadeghi. Flexible and
ﬁne-grained mandatory access control on android for
diverse security and privacy policies. In USENIX
Security, Security ’ 13.
[14] Clutch. Clutch.
https://github.com/KJCracks/Clutch.
[30] H. Shacham. The geometry of innocent ﬂesh on the
bone: Return-into-libc without function calls (on the
x86). In ACM Conference on Computer and
Communications Security, CCS ’07.
[15] L. Davi, A. Dmitrienko, M. Egele, T. Fischer, T. Holz,
[31] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko,
R. Hund, S. N¨urnberger, and A.-R. Sadeghi. MoCFI:
A framework to mitigate control-ﬂow attacks on
smartphones. In Network and Distributed System
Security, NDSS ’12.
C. Liebchen, and A.-R. Sadeghi. Just-in-time code
reuse: On the eﬀectiveness of ﬁne-grained address
space layout randomization. In IEEE Security and
Privacy, SP ’13.
[16] M. Egele, C. Kruegel, E. Kirda, and G. Vigna. PiOS:
[32] Symantec Corporation. 2013 internet security threat
Detecting privacy leaks in iOS applications. In
Network and Distributed System Security, NDSS ’11.
[17] A. P. Felt, M. Finifter, E. Chin, S. Hanna, and
D. Wagner. A survey of mobile malware in the wild.
In ACM Workshop on Security and Privacy in
Smartphones and Mobile Devices, SPSM ’11.
[18] C. Giuﬀrida, A. Kuijsten, and A. S. Tanenbaum.
Enhanced operating system security through eﬃcient
and ﬁne-grained address space randomization. In
USENIX Security ’12.
[19] J. Han, S. M. Kywe, Q. Yan, F. Bao, R. Deng, D. Gao,
Y. Li, and J. Zhou. Launching generic attacks on iOS
with approved third-party applications. In Applied
Cryptography and Network Security, ACNS ’13.
[20] N. Hardy. The confused deputy: (or why capabilities
might have been invented). SIGOPS’98 Oper. Syst.
Rev.
[21] J. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, and
J. Davidson. Ilr: Where’d my gadgets go? In IEEE
Security and Privacy, SP’12.
[22] J. Jeon, K. K. Micinski, J. A. Vaughan, A. Fogel,
N. Reddy, J. S. Foster, and T. Millstein. Dr. Android
and Mr. Hide: Fine-grained permissions in Android
applications. In Workshop on Security and Privacy in
Smartphones and Mobile Devices, SPSM ’12.
report, volume 18.
http://www.symantec.com/security_response/
publications/threatreport.jsp.
[33] T. Backdoor in top iPhone games stole user data, suit
claims. http://www.theregister.co.uk/2009/11/06/
iphone_games_storm8_lawsuit/, 2014.
[34] R. Wahbe, S. Lucco, T. E. Anderson, and S. L.
Graham. Eﬃcient software-based fault isolation. In
ACM Symposium on Operating Systems Principles,
SOSP ’93.
[35] T. Wang, K. Lu, L. Lu, S. Chung, and W. Lee. Jekyll
on iOS: when benign apps become evil. In USENIX
Security, SSYM’13.
[36] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin.
Binary stirring: Self-randomizing instruction addresses
of legacy x86 binary code. In ACM Conference on
Computer and Communications Security, CCS ’12.
[37] T. Werthmann, R. Hund, L. Davi, A.-R. Sadeghi, and
T. Holz. PSiOS: bring your own privacy & security to
iOS devices. In ACM SIGSAC Symposium on
Information, Computer and Communications security,
ASIACCS ’13.
[38] J. Xu, Z. Kalbarczyk, and R. Iyer. Transparent
runtime randomization for security. In International
Symposium on Reliable Distributed Systems, 2003.
[23] C. Kil, J. Jun, C. Bookholt, J. Xu, and P. Ning.
[39] R. Xu, H. Sa¨ıdi, and R. Anderson. Aurasium:
Address space layout permutation (ASLP): Towards
ﬁne-grained randomization of commodity software. In
Annual Computer Security Applications Conference,
ACSAC ’06.
[24] H. Lu. ELF: From the programmer’s perspective.
http://linux4u.jinr.ru/usoft/WWW/www_debian.
org/Documentation/elf/node7.html.
[25] Microsoft. Data Execution Prevention (DEP).
http://support.microsoft.com/kb/875352/EN-US/,
2006.
[26] V. Pappas, M. Polychronakis, and A. D. Keromytis.
Smashing the gadgets: Hindering return-oriented
programming using in-place code randomization. In
IEEE Security and Privacy, SP ’12.
[27] V. Pappas, M. Polychronakis, and A. D. Keromytis.
Transparent ROP exploit mitigation using indirect
branch tracing. In USENIX Conference on Security,
Security ’ 13.
[28] PGbiz. Count of active applications in the App Store.
http://www.pocketgamer.biz/metrics/app-store/
app-count/, 2014.
[29] G. F. Roglia, L. Martignoni, R. Paleari, and
D. Bruschi. Surgically returning to randomized lib(c).
In Annual Computer Security Applications
Conference, ACSAC ’09.
Practical policy enforcement for Android applications.
In USENIX Security, Security’12.
[40] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth,
T. Orm, S. Okasaka, N. Narula, N. Fullagar, and
G. Inc. Native client: A sandbox for portable,
untrusted x86 native code. In IEEE Security and
Privacy, Oakland ’09.
APPENDIX
A. WHATSAPP POLICY DEFINITION
unsigned long p o s t e x t e r n a l c a l l ( const char
∗ f u n c t i o n n a m e , const unsigned long
r e t u r n e d v a l u e )
{
}
i f
( x i o s s t r c m p ( f u n c t i o n n a m e , a d d r e s s G e t I D ) ==
0 ) {
char ∗ companyName =
ABRecordCopyValue ( p e r s o n ,
k A B P e r s o n O r g a n i z a t i o n P r o p e r t y ) ;
( x i o s s t r c m p ( ” c o r p o r a t e ” , companyName ) ==
0 ){
i f
return 0 ;
}
}
return r e t u r n e d v a l u e ;