(instead of {0, 1} ˆm ˆn). Let the input
ˆm−1) where z′
p . The input
length of gSWIFFT is ˆm ˆn(cid:6)log2 (p)(cid:7) bits. Similar to SWIFFT, we de-
2.5.1
tion that takes input from Z ˆm ˆn
0, z′
to gSWIFFT be z′ = (z′
1, . . . , z′
ˆm−1(cid:88)
fine gSWIFFT function as:
i ∈ Z ˆn
p
дSWIFFT(z′
) =
(NTT(ai ) ⊙p NTT(z′
i )),
(6)
i =0
gSWIFFT is used for efficient verification of KSN-OTS scheme
(Section 3.1).
2.5.2 Parallelizing SWIFFT Implementation using SIMD . Efficient
implementation of K2SN-MSS requires efficient implementation of
SWIFFT computation that consists of ˆm ring multiplications, fol-
lowed by ring additions. Thus efficient implementation of ring mul-
tiplication is essential for the efficient implementation of K2SN-MSS.
We show how to parallelize each ring multiplication using SIMD
instructions of Intel Intrinsics. The level of parallelization is deter-
mined by the parameter δ, which indicates 2δ output components
will be computed simultaneously. In our setting, the parallelization
level δ, can be chosen in the range δ = 0 (no parallelization at all)
to δ = 6 corresponding to the full parallelization for ring R with
ˆn = 64.
Intel Intrinsics for SIMD Intel introduced SIMD instruction set
MultiMedia eXtension (MMX) in their processors in 1997. MMX
has been later extended to Streaming SIMD Extensions (sse) like
sse2, sse3 upto sse4.2. We use Advanced Vector Extensions (avx)
and in particular avx2 intrinsic. For more details see [18]. The
achievable level of parallelization will depend on the specific set
of instructions that will be chosen for the implementation. For 16
fold parallelization (δ = 4), we use 16 16-bit multiplication SIMD
instruction together with 16-bit addition, subtraction and other
operations such as shift. More details are in Section 5.
3 K2SN-MSS CONSTRUCTION
We first give an overview of KSN-OTS [24] and then describe
K2SN-MSS, and prove its security in using the stronger notion of
multi-function multi-target security.
3.1 KSN: An Efficient Post-Quantum OTS
We propose an MSS based on KSN [24], an OTS scheme with two
building blocks: a cover-free-family and SWIFFT hash function
family.
|∆| = w and for all i (cid:60) ∆, we have(cid:12)(cid:12)(cid:12)Bi ∖(cid:83)
A w-Cover-Free Family (w-CFF) is a set system defined as follows.
Definition 3.1. Let (X, B) be a set system, whereX = {x1, x2, . . . , xt}
is a set of t elements and B = {B1, B2, . . . , Be} be a set of e subsets
of X and the size of each Bi is k. If for all ∆ ⊂ {1, 2, . . . , e} with
call that the set system is a k-uniform w-Cover-free family with t
elements and e subsets, in short w-CFF(t, e, k ).
(cid:12)(cid:12)(cid:12) ⩾ 1 then we
j∈∆ Bj
The SWIFFT hash function family is additive homomorphic and
for two binary inputs x1 and x2 of length ˆm ˆn, satisfying
SWIFFT(x1) + SWIFFT(x2) = дSWIFFT(x1 ⊕p x2),
xxx, yyy, zzz
Sabyasachi Karati and Reihaneh Safavi-Naini
(cid:16) t
(cid:17) ⩾ m. A
where addition SWIFFT(x1) +SWIFFT(x2) is in ring R, and addition
x1 ⊕p x2 is a component-wise modulo p addition of two vectors
of length ˆm ˆn. This property is used in KSN signature scheme [24]
to achieve fast signing and verification, and short signature. An
overview of the scheme is given below. We use a pseudo-random
function family Fn : { fk : {0, 1}2n (cid:55)→ {0, 1}2n | k ∈ {0, 1}n} to
generate component secret keys (instead of uniform selection from
{0, 1}2n).
Consider a message space consisting of m-bit strings. The secret
key and the public key of KSN-OTS scheme consists of t compo-
nent keys, where t is an even integer satisfying log2
component secret is a 2n bit random string and so the total secret
key length is 2tn bits. The component secret keys in practice (and
in our implementation) are generated by applying f ∈ Fn on an
initial seed. Thus the secret key can be considered as the seed of
the PRG. The hash key k of SWIFFT is ˆm multipliers which are ring
elements and are chosen uniformly at random from {0, 1} ˆn⌈log2 (p )⌉.
The signature scheme consists of three algorithms: KeyGen, Sign
and Verify. The parameters of SWIFFT function ( ˆm, ˆn and p) and
the pseudo-random function family Fn will be chosen to achieve
the required security level. A function fsk() is chosen from Fn, and
sk is kept secret (this can be seen as the seed of the pseudo-random
function).
Key Generation. The KeyGen generates the secret key SK and
the public key PK as given in Algorithm 1. The i-th component
secret key is computed as fsk(i + 1). This is the same as the secret
key generation in XMSS [9].
t2
Algorithm 1 Key Generation (KeyGen(1n))
(1) Choose sk as a seed uniformly at random from {0, 1}n.
(2) For i = 0, 1, . . . , t − 1, compute xi as xi = fsk (i + 1).
(3) For i = 0, 1, . . . , t − 1, compute yi as yi = SWIFFTk (xi ).
(4) Return Secret Key SK = sk and Public Key PK =
{y0, y1, . . . , yt−1}.
Signature Generation. The Sign takes an m-bit message mes
and computes the signature σmes using Algorithm 2.
Algorithm 2 Signature Generation (Sign(mes,SK ))
(1) For i = 0, 1, . . . , t − 1, compute xi as xi = fSK (i + 1).
(2) Compute Bmes = cm (mes), where Bmes = {i0, i1, . . . , i t2 −1},
(3) Compute σmes = xi0 ⊕p xi1 ⊕p · · · ⊕p xi t2 −1
; Return σmes.
and ij < ij+1 for all 0 ⩽ j ⩽ t2 − 2.
Signature Verification. The verification algorithm given by
Algorithm 3, takes a message and signature pair (mes, σmes), and
outputs Accept or Reject.
In [24], it has been proved that the KSN scheme is secure under
the collision-resistance of the hash function. The security theorem
is as given below:
[24] If A is a quantum adversary that (ϵ, τ )-wins
Theorem 3.2.
the unforgeability security game for KSN scheme, then A can be used
to (ϵc′, τ + c)-find function collisions where c, c′ are constants.
Algorithm 3 Signature Verification (Verify(mes,σmes,PK ))
mes = cm (mes).
(1) Compute B′
(2) If σmes[i] ⩽ t2 ,∀0 ⩽ i < ˆm ˆn (σmes[i] denotes the i-th com-
ponent of the vector σmes), then continue else Reject.
(3) Compute σ ′
(addition in R), and
ij ∈ B′
mes.
(4) If σ ′
mes = дSWIFFTk (σmes), then Accept, else Reject.
mes = yi0 + yi1 + · · · + yi t2 −1
Definition 3.3. Strong Unforgeability. Let A has queried on a
message M during the query phase of the security game and σ be
the signature of the message. In the strong unforgeability game, A
is considered to be successful even if it can return a signature σ∗ of
the message M where σ∗ (cid:44) σ.
SWIFFT hash function used in KSN-OTS is itself highly paral-
lelizable and this leads to higher speed of K2SN-MSS compared to
XMSS that is based on W-OTS+ that uses l random walks in the
function family Fn which are inherently sequential. Comparison
of the two signature schemes is given in Section 6.2.
3.2 K2SN-MSS construction
K2SN-MSS extends the KSN-OTS to multi-message signature scheme
and uses SWIFFT as the underlying hash function. However, SWIFFT
compresses 2n bits to n + nϵ bits and so concatenation of two out-
puts (in a node of the Merkle tree) results in 2n + 2nϵ bits. We
introduce a function Merge that effectively slides one string over
the other and XORs the overlapping part, to generate a 2n-bit string.
The overlapping part of the two strings is XOR-ed. For our chosen
parameters n = 512 and nϵ = 64.
Merge(y1, y2) = hin−nϵ (y1)∥(low2nϵ (y1) ⊕ hi2nϵ (y2))
∥lown−nϵ (y2),
(7)
where (i) y1 and y2 are (n + nϵ )-bit strings, (ii) hil (y) is the most
significant l bits of y and (iii) lowl (y) is the least significant l bits
of y. The function Merge is used to calculate y′
Figure 2 instead
j,i
of simple concatenation.
Lemma 3.4. Let f be a random oracle which outputs (n + nϵ )-bit
long random strings. Let Oc and Om be two oracles defined as follows:
On a query, Oc outputs a 2n-bit long string y which is computed as y =
$←− f . On the other hand, Om outputs
lown (x1)∥lown (x2) : x1, x2
a 2n-bit long string y′ which is computed as y′ = Merge(x1, x2) :
x1, x2
$←− f . Then Oc and Om are indistinguishable.
Proof. The proof depends on the following facts: (i) a substring
of a random string is a random string, and (ii) concatenation and
XOR of two random strings are also random. The job of a attacker is
to distinguish the oracles from a given string from one of the oracles.
As f and д are two indistinguishable random functions, x1, x2, x′
1
and x′
2 are all random strings with indistinguishable distributions.
Therefore, y and y′ will also have indistinguishable distributions.
If the attacker can distinguish the oracle from the output string
with non-negligible probability, then the attacker can distinguish
between f and д which contradicts the hypothesis.
□
K2SN-MSS: An Efficient Post-Quantum Signature (Full Version)
3.2.1 Algorithms. K2SN-MSS consists of three algorithms: K2SN.KeyGen,
K2SN.Sign and K2SN.Verify.
Key Generation: K2SN.KeyGen uses two function families: Fn
and SWIFFT as given in Algorithm 4. Here n is the length of the
seed of the PRG that is used for secret key generation and is the
security parameter of K2SN-MSS. During computation of each node
in the tree a different hash key has been used. The public key length
is n + nϵ + hkseed + rpseed bits.
Algorithm 4 Key Generation of K2SN-MSS (K2SN.KeyGen(1n))
(1) Choose randomly, (i) sk ∈ {0, 1}n, (ii) hkseed ∈ {0, 1}n and
(iii) rpseed ∈ {0, 1}n.
(2) For i = 0, 1, . . . ,T − 1 (where T = 2h) /* Construction of Li
trees */
(a) For each Li tree, compute ski = lown ( fsk (i + 1)).
(b) For j = 0, 1, . . . , t − 1, ( t = 2ℓ), compute secret key com-
= fski (j + 1).
ponents of the i-th signature as, xij
(c) For j = 0, 1, . . . , t − 1, compute the public key component
of i-th signature as, yij
(d) Compute yh,i, the root of the Merkle tree Li from leaves
yi0 , yi1 , . . . , yit−1. All the remaining nodes of the Li tree
are computed with a new random pad and hash key.
trees are the leaf nodes of the
Merkle tree MSS at height h. Denote the nodes by
yh,0, yh,1, . . . , yh,T−1, and construct the Merkle tree MSS
using different hash keys and random pads. The root of the
tree is denoted by y0,0.
(4) Return, (i) Secret key SK = sk, and (ii) Public key PK =
{y0,0, hkseed, rpseed}.
(3) The roots of the Li
= SWIFFTki (xij ).
(cid:104)
Signature Generation. For the i-th message, mes, the signature
σmes = (i, pk, PK i , Auth), where i, 1 ≤ i ≤ 2h is the index of the
signature, pk is the sum of the secret key components associated
with Bmes, PK i is the set of component public keys of the i-th
signature (i-th instance of KSN) and Auth contains the nodes of
the MSS tree that are required for verification of Li root. The
computations of pk, PK i and Auth are given in Algorithm 5. The
+ 1) ×
signature length consists of h-bits to represent i, (
2n bits to represent pk, PK i consisting of t outputs of SWIFFT
resulting in t (n + nϵ ) bits, and h(n + nϵ ) bits to represent Auth
which consists of the h sibling nodes. In total signature size is
+ nϵ × (t + h) bits.
Signature Verification. To verify σmes = (i, pk, PK i , Auth),
first pk is verified against PK i using the KSN verification algorithm
(Algorithm 3), and then PK i is authenticated against y0,0, the root
of the MSS Merkle tree using the Auth. The algorithm is given in
Algorithm 6.
|σmes| = h + n ×(cid:16)2(cid:16)(cid:104)
+ 1(cid:17)
log2 ( t2 )
(cid:16) t2
(cid:17)(cid:105)
+ t + h
log2
(cid:105)
(cid:17)
3.3 K2SN-MSS Security
Theorem 3.5. If H is a 2h (2ℓ − 1) multi-function multi-target
second-preimage resistant hash function then K2SN-MSS is (ϵ, 2h, τ )
secure against Strong Existential Unforgeable under Chosen Message
attack (SUF-CMA). This means that for any forger A with success
xxx, yyy, zzz
Generation
of
K2SN-MSS
Algorithm 5
(K2SN.Sign(i,mes,SK ))
Signature
such that ij < ij+1 for all 0 ⩽ j ⩽ t2 − 2.
of the i-th KSN-OTS as xij
= fski (j + 1).
as PK i = {yij
(1) Compute the seed ski for the Li tree as ski = fsk (i + 1).
(2) Compute Bmes = cm (mes) and let Bmes = {i0, i1, . . . , i t2 −1}
(3) For j = 0, 1, . . . , t − 1, compute the component secret keys
(4) Compute the component public keys of the i-th KSN-OTS
(5) pk = xi0 ⊕p xi1 ⊕p · · · ⊕p xi t2 −1
(6) Let yh,i be the root of the Merkle tree Li. The Auth contains
the sibling nodes of the MSS Merkle tree from yh,i to the
root y0,0.
= SWIFFTk(xij ), j = 0, 1, . . . , t − 1}.
, where ij ∈ Bmes.
(7) Return σmes = (i, pk, PK i , Auth).
Signature
Verification
of
K2SN-MSS
=
i , Auth).
{j0, j1, . . . , j t2 −1} such that jk < jk +1 for all 0 ⩽ k ⩽ t2 − 2.
Algorithm 6
(K2SN.Verify(mes,σmes))
(1) Let σmes = (i, pk, PK ′
(2) Compute Bmes
= cm (mes) and and let Bmes
(3) If pk[i] ⩽ t2 ,∀0 ⩽ i < ˆm ˆn, then Continue else Reject.
(4) Let PK ′
0, y′
i = {y′
(5) Compute pk′ = y′
are in the ring R.
(6) If pk′ = дSWIFFTk (pk), then Continue, else Reject.
(7) Compute the root of the Merkle tree Li where the leaf nodes
are y′
t−1 and with the hash keys and random pads
used during signing. The hash keys and random pads can be
easily regenerated from the published seed. Let the root of
the Merkle tree Li be y′
t−1} ∈ σmes.
+ · · · + y′
j t2 −1
1, . . . , y′
+ y′
j1
, where the additions
(8) Compute the root of the MSS Merkle tree from y′
h,i
1, . . . , y′
0, y′
using
h,i
j0
.