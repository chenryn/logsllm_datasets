# CVE-2019-3969：Comodo沙箱逃逸提权漏洞分析
|
##### 译文声明
本文是翻译文章，文章原作者 tenable-techblog，文章来源：medium.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
AV（反病毒软件）一直以来都是漏洞挖掘的绝佳目标，这是因为其中涉及到巨大的攻击面、复杂的解析过程以及以高权限运行的各种组件。几个月之前，我决定分析最新版的Comodo
Antivirus
v12.0.0.6810，最终我找到了一些有趣的信息，但这里我想跟大家分享其中一个沙箱逃逸问题，可以将权限提升至`SYSTEM`级别。在本文中，我们会滥用各种COM对象，绕过二进制签名检查，劫持关键服务。下面开始进入主题。
## 0x01 Comodo沙箱机制
首先我想介绍一下Comodo的沙箱技术，Comodo称之为“Containment”，在本文中我将交替使用“Containment”以及“沙箱”这两个词。这种沙箱技术可以限制不可信应用（[RTATC](https://containment.comodo.com/how-it-works/?source=post_page---------------------------)）在类沙箱环境中运行，同时OS中还能运行其他进程。这种技术涉及到用户模式hook以及内核模式驱动，可以阻止对主机上文件或注册表的任何修改操作。该环境中可以读取文件及注册表，但一旦执行写操作，文件I/O就会被转移到沙箱文件系统，后续读取操作将与沙箱文件系统交互，使调用方误认为自己在与正常的文件系统交互。
Comodo通过过滤器驱动`Cmdguard.sys`来实现该功能。该驱动会使用[`FltRegisterFilter`](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/fltkernel/nf-fltkernel-fltregisterfilter?source=post_page---------------------------)
API注册一个[`_FLT_REGISTRATION`](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/fltkernel/ns-fltkernel-_flt_registration?source=post_page---------------------------)结构，该结构包含与来自用户模式应用的各种[IRP](https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/i-o-request-packets?source=post_page---------------------------)（比如[文件访问](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-mj-create?source=post_page---------------------------)、[文件写入](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-mj-write?source=post_page---------------------------)等）对应的回调例程，并且可以执行对应的拦截/处理操作。此外，ALPC（用于各种OS组件的一种Microsoft
IPC）也会被沙箱化处理，Comodo会将ALPC连接转移到“沙箱化”的`svchost.exe`实例，避免通过RPC/ALPC实现沙箱逃逸。这种containment技术工作原理如下图所示：
图1. Comodo Containment技术逆向分析图
`Cmdguard.sys`不仅可以过滤文件/注册表I/O，也会使用[`PsSetCreateProcessNotifyRoutine`](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetcreateprocessnotifyroutine?source=post_page---------------------------)注册[`CREATE_PROCESS_NOTIFY_ROUTINE`](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntddk/nc-ntddk-pcreate_process_notify_routine?source=post_page---------------------------)，跟踪正在运行的进程。当进程运行时，Comodo会将containment状态、信任等级以及其他相关属性跟踪并保存到存储在内核中的一个进程列表。`Cmdguard.sys`会对外提供“filter
ports”，以便用户模式下的Comodo组件通信。Comodo会向`cmdAuthPort`
filterport发送特定消息来设置containment状态，随后内核模式驱动会在该消息指定的目标进程上设置“containment”标志。
在创建沙箱化进程后，`Guard64.dll`（几乎每个运行的进程中都会注入该dll）负责从用户模式中发送这些containment消息。例如，`Guard64.dll`会hook
`Explorer.exe`的`CreateProcessInternalW`
API，这样当用户执行不可信进程时，就会向`Cmdguard.sys`过滤器端口发送一个“containment”消息。现在当不可信进程启动时，驱动程序会将打上“contained”标记，阻止文件、注册表I/O操作。此外，`Cmdguard.sys`会将`Guard64.dll`注入沙箱化进程中，执行用户模式下的hook操作。
图2. `Cmdguard.sys` dll注入流程
`Guard64.dll`在用户模式下设置的hook如下图所示：
图4. `Guard64.dll`用户模式hook
这些hook有个相同的功能，就是避免沙箱化的进程连接非沙箱化进程创建的安全对象。为了完成该任务，Comodo会将一个`!comodo_6`标记附加到沙箱化进程创建或打开的每个对象名，避免对象名与系统上已有的安全对象发生名字冲突（或者关联）。
实际上，这也是RPC/ALPC沙箱隔离的工作原理。RPC/ALPC流量会被转移到沙箱化的`Svchost.exe`实例（参考上图），这是因为`!comodo_6`会附加到沙箱化进程尝试连接的端口名，而沙箱化的`Svchost.exe`实例也会创建附加`!comodo_6`的端口名。如下图所示，我们可以看到沙箱化的MSI安装程序尝试运行，发起RPC调用后最终会创建沙箱化的`MSIexec.exe`服务组件（父进程为`cmdvirth.exe`）。
图5. 沙箱化的ALPC生成沙箱化的MSIExec实例
绕过这些用户模式hook并不难，但想通过这种方式实现沙箱逃逸并不容易。如果想简单patch与ALPC相关的hook，通过WMI实现逃逸显然不可能，因为这些位置同样会被`CmdAgent.exe`监控并阻止。了解关于Comodo沙箱环境的基本知识后，下面我们来研究下如何实现沙箱逃逸及权限提升。
## 0x02 创建Comodo COM客户端
Comodo在各种AV组件之间使用了许多IPC机制，包括：过滤端口、共享内存、LPC以及COM。这里我们将重点关注COM。如果大家想了解COM，可以参考[这篇文章](https://docs.microsoft.com/en-us/windows/desktop/com/the-component-object-model?source=post_page---------------------------)。简而言之，COM的全称为“Component
Object
Model”，是微软提供的一种技术，允许不同模块创建由COM服务端定义的各种对象并与之交互。COM服务端可以本地部署（在当前进程中加载的一个COM服务端dll）或者远程部署，可以通过ALPC进行交互。在利用形式上，远程部署可能是更为有趣的应用场景。
我们发现Comodo可以从低权限进程（如`explorer.exe`，通过Context Shell
Handler（当用户右键点击时出现的菜单）或者`Cis.exe`（Comodo客户端GUI））发起扫描任务。这些扫描任务可以通过调用`CAVWP.exe`中的例程来发起，而该程序以`SYSTEM`权限执行。
如果我们能澄清如何按照Comodo的方式连接到这个服务，那么可能我们会找到一种新的攻击面，发现除“扫描”之外更多有趣的函数。我们需要通过COM实现与`CAVWP.exe`的远程交互，因为从注册表中可知，`CAVWP.exe`是一个进程外的COM服务端：
图5. `CAVWP.exe` COM服务端
接下来分析`Explorer.exe`以及Comodo
COM客户端如何通过COM远程触发这些“扫描”动作。前面提到过，Comodo在`Explorer.exe`的Shell Context
Menu中注册了一个handler（`CavShell.dll`），因此低权限客户端`Explorer.exe`可以发起扫描动作。
图6. `Explorer.exe`中的Comodo Context Menu Handler
逆向分析这个shell扩展接口后，我发现其中Comodo实现了一个“扫描”客户端COM例程。理解这个函数可以帮助我们了解如何构造自己的COM客户端。
图7. `Cavshell.dll`（Context Menu Handler）的“Scan File”例程
该代码流程中对`CoGetClassObject`的调用比较有趣。`CoGetClassObject`会返回指向某个接口的一个指针，而该接口对应与CLSID关联的某个对象。在注册表中查找后，我们发现这个CLSID对应“Cis
Gate Class”，并且很快我们意识到`CAVavWp.exe`与这个类没有任何关系，该类对应的实际COM服务端为`CmdAgent.exe`。
图8. 根据CLSID（CLSID_CisGate）发现COM服务端为`Cmdagent.exe`。
经过研究后我们发现，`CmdAgent`充当的是低权限COM客户端与`CavWp`之间的代理角色，`CavWp`会代表我们通过`CisGate`接口向`CmdAgent`发起扫描请求。这里我们的主要目标是理解并设置这些绑定关系，这样才能进一步利用更多的攻击面。
逆向分析客户端（以及部分`CmdAgent`逻辑）后，我们成功迁移了COM代码，澄清了正确的方法偏移地址，并且重新设计我们的代码，以模拟这些COM对象的操作。
图9. 模拟“伪造的”Comodo COM客户端
## 0x03 代码签名问题
然而，这段代码无法运行成功，`CisClassFactory`的`CreateInstance`会调用失败，返回`E_ACCESSDENIED`。这一点比较奇怪，因为我们的进程权限与`Explorer.exe`以及`Cis.exe`一样，而后者却能成功调用，原因究竟是什么？
在调试器中调试`CmdAgent.exe`，可以看到程序会收到我们执行的`CreateInstance`调用，并且进入一个自定义的`E_ACCESS_DENIED`消息分支。