Listing 2: Regular expression used by SpiderOakONE to check if a ﬁle retrieval
request should be allowed
some security checks to prevent the server from retrieving any ﬁle stored on
the client. Unfortunately we discovered that the checks in place do not prevent
the server from requesting the ﬁle with the user’s password. Each of the three
methods works in essentially the same way: They take as input a ﬁlename,
check if this ﬁlename satisﬁes a certain regular expression (shown in Listing 2)
and if so, return the content of the ﬁle to the server. Two of the three methods
are available by default and the last is available if the user has enabled remote
diagnostics. The ﬁle that stores the user’s password is located at the following
two locations12
tss_external_blocks_snapshot.db/00000003
tss_external_blocks_pandora_sqliite_database/00000003
By inspecting the regular expression in Listing 2 we see that, while the ﬁrst ﬁle
does not match (due to the . before the /), the second ﬁle does.
Therefore, an attacker A can simply request the client to execute one these
insecure RPC and immediately recover the password.
As mentioned in Section 3.3, users can opt-out from the automatic login
functionality and instead choose to input the password at every startup. When
this option is enabled, the plaintext password pw is not stored on the client. In
its place, the client will store a hashed version of the password which is used by
the client to verify the password input by the user. Unfortunately the stored
hash is quite weak, and is calculated as in (1) where u is a value picked by the
server during account registration.
tmp = MD5("password_verify" || u || pw),
h = MD5(tmp || "password_verify" || u || pw),
(1)
Therefore, even more “paranoid” users choosing the stronger security settings
are not immune from the attack, since even in this case the adversary can run
the attack and learn the weakened hash of the password thus leading to a ρ-
password weakening attack with ρ = lg(c) − 1 = 11.
Implementing this attack required more work
Experimental veriﬁcation.
than the the previous one, since relatively little documentation exists for the
12Locations are relative to the SpiderOakONE conﬁguration directory. E.g., $HOME/.config
on Linux.
19
used RPC interface (as opposed to the simple HTTP communication used during
authentication). In addition, as many diﬀerent RPCs are called on the client, it
was not straightforward to inject extra calls to the insecure remote methods, as
this would require our Man-in-the-Middle application to keep track of every call
made after the injected call, and adjust sequence numbers accordingly to avoid
having the client crashing after completion of the attack. Therefore, instead of
injecting new calls between the real SpiderOak server and our client we changed
an existing call originating at the real server to one which requests the ﬁle
containing the user’s password. Then, from the clients response, we veriﬁed
that the password could be successfully extracted.
Practical impact. As already stated, this attack is extremely dangerous as
it is completely undetectable and it allows to recover the password from users
running with standard settings at any time. Even in the case where users chose
the more conservative settings, the attacks is still eﬀective in weakening the
password hash.
4.4 File recovery in directory sharing
The last attack we describe can be run by a passive adversary e.g., it only re-
quires the adversary to be able to observe the server (as opposed to the previous
three that all require A to make the server deviate from normal behaviour in
some way).
In a nutshell, we discovered that a shared directory cannot be securely un-
shared. That is, ﬁles added to a directory after it has been un-shared can still
be read by the server; the same goes for ﬁles moved out of a directory before it
is shared. The following two scenarios illustrate these observations:
Scenario 1: Suppose Alice and Bob begin a new relationship, and therefore
Alice decides to share a directory of photos with Bob. After some time,
Alice and Bob break up and therefore Alice stops sharing this directory
with Bob. Afterwards, she uploads new photos to the same directory
assuming that Bob will be unable to see them. However, Bob, who has read
access to the PECS, can also see her new photos since they are protected by
the same directory key which he learned while they were in a relationship.
Scenario 2: Suppose Alice was on a vacation where she took a lot of photos,
all stored in her PECS directory Dir. She would really like to share these
photos with her colleagues. Alas, a few of the photos are a bit too private
in their nature and thus cannot be shared. To solve this dilemma, Alice
(cid:48) and then
simply moves the few private pictures to a diﬀerent directory Dir
shares Dir. Now everyone can see her cool vacation photos. However, Bob,
who has read access to the PECS, can also see her private photos, as these
are not securely detached from Dir!
Scenario 2 arise because no re-encryption happens when a ﬁle is moved from
In particular, a ﬁle that was encrypted with the
one directory to another.
20
directory key k of Dir, is still encrypted with k even after it has been moved
(cid:48). Thus, when Dir is shared, the ﬁle that was moved
to another directory Dir
inadvertently gets shared as well (recall that sharing reveals the directory key
to the server cf. Section 3.5). The same idea applies in Scenario 1: When a
directory is un-shared, the previously revealed directory key k is not invalidated,
thus making new ﬁles added at a later time readable to the server.
Both scenarios can be phrased in terms Deﬁnition 1 and lead to ﬁle recovery
attacks: In Scenario 1 A makes the client upload some ﬁle in a directory, share
the directory (thus learning the directory key) and unshare the directory. Finally
A makes the client upload an unknown ﬁle to that directory and decrypts it
using the directory key; In Scenario 2 A makes the client upload an (unknown)
ﬁle to a directory, then moves the ﬁle to a diﬀerent directory and ﬁnally shares
the ﬁrst directory, thus learning the directory key which allows to recover the
ﬁle. Note that since no revealing commands were performed on the retrieved
ﬁle both are “valid” attacks.
Experimental validation. Validation of these attacks was carried out by
executing the steps described above on the client. E.g., uploading a ﬁle to
some directory, moving the ﬁle to another directory and then sharing the ﬁrst
directory. We then recorded all traﬃc generated by the client and used it to
extract the ﬁle.
Practical impact. As shown, the attacks presented here lead to ﬁle recovery
for ﬁles that, one way or another, users actively choose to prevent from being
shared and is therefore critical.
4.5 On future secrecy
As mentioned in Section 3.4, very little is changed when a SpiderOakONE user
changes their password which implies that SpiderOakONE does not satisfy our
notion of future security. This is quite critical since, as shown by the previous
attacks, there are several ways in which a user’s password might leak.
The attack can be easily described: when an account is created a number of
long-term secrets are created and encrypted using the password. The long-term
secrets are in turn used to encrypt the individual directories and ﬁles. Thus, if
the password pw is leaked, the adversary A will be able to retrieve the long-term
secrets (and in turn the content of all existing ﬁles and directory). Now when
the user changes their password the long-term secrets are not replaced by new
ones, thus from A’s point of view the password change has no eﬀect at all! Now,
when the user uploads a new ﬁle, A can simply retrieve it using the (unchanged)
long-term secrets, thus breaking future secrecy.
21
5 Mitigations
We reported our ﬁndings on April 5th, 2017. As of September 28th, 2017, all
reported issues have been ﬁxed by SpiderOak [35]. The ﬁxes implemented by
SpiderOak are summarized in this section:
4.1: A check was implemented that (1) ensures cost is at least 12 (thus prevent-
ing a downgrade), and (2), that the salt part of bcrypt(pw, s) is equal to
s (thus preventing the memory leak). It is worth noting that the memory
leak is still present, it is just not exploitable anymore.
4.2: The client now ensures that lst is non-empty. In addition, the message
displayed to the user has been reworded to be less ambiguous.
4.3: SpiderOak claimed that the functions allowing for (almost) arbitrary ﬁle
retrieval was part of an API that never got implemented. As a result,
their ﬁx was simply to remove them.
4.4: Keys are now properly rotated, ensuring that ﬁles are not encrypted under
a key that has been previously revealed.
4.5: future-secrecy is still not supported by SpiderOakOne.
6 Conclusion
In this paper we described a number of vulnerabilities which (might have) al-
lowed a rogue SpiderOak server (or anyone able to bypass certiﬁcate pinning and
manage to interact with the client software) to break the conﬁdentiality of the
user’s ﬁle. While most of the problems have already been ﬁxed by SpiderOak,
the fact that the attacks have been possible so far has serious consequences:
since the attacks are easy to carry out and undetectable at the client side, there
is no way to be completely sure that attacks have not been already run.
We would recommend all SpiderOak users to change their password (as this
could have been stolen). Unfortunately, as described in Section 4.5, changing
the password simply re-encrypts the long term secret key under a new password.
Therefore if an attacker has already obtained this long-term secret key, changing
the password will not help in ensuring the conﬁdentiality of the ﬁles uploaded
by the users in the future (and clearly nothing can restore the eventual loss of
conﬁdentiality which could have already occurred).
Our analysis can also be used to draw some general conclusions about the
design of encrypted cloud storage systems. We believe that “the root of all
evil” in the case of SpiderOak relies in the choice of using the same secret (the
password) both for authentication and conﬁdentiality purposes. We understand
that, from a user experience point of view, it is hard to have to generate, store
and type two strong passwords. However we have also observed how this choice
(combined with authentication protocols which are not zero knowledge in a
strong, cryptographic sense) leads to a complete loss of conﬁdentiality.
22
Acknowledgments
Research funded by the Danish Independent Research Council under Grant-
ID DFF-6108-00169 (FoCC). We are grateful to DDIS for useful sparring and
technical dialogues.
References
[1] Modular crypt format: A explanation about a standard that isn’t. http:
//passlib.readthedocs.io/en/stable/modular_crypt_format.html.
[2] Chetan Bansal, Karthikeyan Bhargavan, Antoine Delignat-Lavaud, and
formal analysis and concrete attacks
In International Conference on Principles of
Sergio Maﬀeis. Keys to the cloud:
on encrypted web storage.
Security and Trust, pages 126–146. Springer, 2013.
[3] Andrey Belenko and Dmitry Sklyarov.
“secure password managers” and
“military-grade encryption” on smartphones: Oh, really? Blackhat Europe,
2012.
[4] Mihir Bellare, Sriram Keelveedhi, and Thomas Ristenpart. Message-locked
encryption and secure deduplication. Cryptology ePrint Archive, Report
2012/631, 2012. http://eprint.iacr.org/2012/631.
[5] Mihir Bellare, Thomas Ristenpart, and Stefano Tessaro. Multi-instance
security and its application to password-based cryptography. In Advances in
Cryptology - CRYPTO 2012 - 32nd Annual Cryptology Conference, Santa
Barbara, CA, USA, August 19-23, 2012. Proceedings, pages 312–329, 2012.
[6] Karthikeyan Bhargavan and Antoine Delignat-Lavaud. Web-based attacks
on host-proof encrypted storage. In 6th USENIX Workshop on Oﬀensive
Technologies, WOOT’12, August 6-7, 2012, Bellevue, WA, USA, Proceed-
ings, pages 97–104, 2012.
[7] Joseph Bonneau. The science of guessing: analyzing an anonymized cor-
In Security and Privacy (SP), 2012 IEEE
pus of 70 million passwords.
Symposium on, pages 538–552. IEEE, 2012.
[8] Moritz Borgmann, Tobias Hahn, Michael Herfert, Thomas Kunz, Marcel
Richter, Ursula Viebeg, and Sven Vowe. On the security of cloud storage
services. 2012.
[9] Stephen Checkoway, Jacob Maskiewicz, Christina Garman, Joshua Fried,
Shaanan Cohney, Matthew Green, Nadia Heninger, Ralf-Philipp Wein-
mann, Eric Rescorla, and Hovav Shacham. A systematic analysis of the
juniper dual EC incident. In Proceedings of the 2016 ACM SIGSAC Con-
ference on Computer and Communications Security, Vienna, Austria, Oc-
tober 24-28, 2016, pages 468–479, 2016.
23
[10] Tom Chothia, Flavio D Garcia, Chris Heppel, and Chris McMahon Stone.
Why banker bob (still) can’t get tls right: A security analysis of tls in
leading uk banking apps. 2017.
[11] McDonald D. A convention for human-readable 128-bit keys. RFC 1751,
RFC Editor, 12 1994.
[12] John R Douceur, Atul Adya, William J Bolosky, P Simon, and Marvin
Theimer. Reclaiming space from duplicate ﬁles in a serverless distributed
ﬁle system.
In Distributed Computing Systems, 2002. Proceedings. 22nd
International Conference on, pages 617–624. IEEE, 2002.
[13] Morris J. Dworkin. Recommendation for Block Cipher Modes of Operation.
NIST Pubs, 2001.
[14] EFF. Who has your back? government data requests 2014. https://www.
eff.org/who-has-your-back-2014#spideroak, 2014.
[15] Gemalto. 2016 mining for database gold. http://breachlevelindex.com/
assets/Breach-Level-Index-Report-2016-Gemalto.pdf, 2016.
[16] Irene Giacomelli, Jesper Madsen, and Claudio Orlandi. Zkboo: Faster
zero-knowledge for boolean circuits. In 25th USENIX Security Symposium,
USENIX Security 16, Austin, TX, USA, August 10-12, 2016., pages 1069–
1083, 2016.
[17] Oded Goldreich and Rafail Ostrovsky. Software protection and simulation
on oblivious rams. J. ACM, 43(3):431–473, 1996.
[18] Shai Halevi, Danny Harnik, Benny Pinkas, and Alexandra Shulman-Peleg.
Proofs of ownership in remote storage systems. In Proceedings of the 18th
ACM Conference on Computer and Communications Security, CCS 2011,
Chicago, Illinois, USA, October 17-21, 2011, pages 491–500, 2011.
[19] Danny Harnik, Benny Pinkas, and Alexandra Shulman-Peleg. Side channels
in cloud services: Deduplication in cloud storage. IEEE Security & Privacy,
8(6):40–47, 2010.
[20] X ITU-T. 690: Itu-t recommendation x. 690 (1997) information technology-
asn. 1 encoding rules: Speciﬁcation of basic encoding rules (ber), canon-
ical encoding rules (cer) and distinguished encoding rules (der). http:
//handle.itu.int/11.1002/1000/12483.
[21] Ari Juels and Burton S. Kaliski Jr. Pors: proofs of retrievability for large
ﬁles. In Proceedings of the 2007 ACM Conference on Computer and Com-
munications Security, CCS 2007, Alexandria, Virginia, USA, October 28-
31, 2007, pages 584–597, 2007.
[22] Burt Kaliski. Pkcs# 5: Password-based cryptography speciﬁcation version
2.0. 2000.
24
[23] Seny Kamara, Kristin E Lauter, et al. Cryptographic cloud storage. In
Financial Cryptography Workshops, volume 6054, pages 136–149. Springer,
2010.
[24] Jonathan Katz and Yehuda Lindell. Introduction to Modern Cryptography,
Second Edition. CRC Press, 2014.
[25] Sriram Keelveedhi, Mihir Bellare, and Thomas Ristenpart. Dupless:
Server-aided encryption for deduplicated storage.
In Proceedings of the
22th USENIX Security Symposium, Washington, DC, USA, August 14-16,
2013, pages 179–194, 2013.
[26] Dhiru Kholia and Przemysław Węgrzyn. Looking inside the (drop) box. In
Presented as part of the 7th USENIX Workshop on Oﬀensive Technologies,
Washington, D.C., 2013. USENIX.
[27] Jemima Kiss. Snowden: Dropbox is hostile to privacy, unlike ’zero knowl-
edge’ spideroak. https://www.theguardian.com/technology/2014/jul/
17/edward-snowden-dropbox-privacy-spideroak, 07 2014.
[28] Zhiwei Li, Warren He, Devdatta Akhawe, and Dawn Song. The emperor’s
new password manager: Security analysis of web-based password managers.
In USENIX Security Symposium, pages 465–479, 2014.