means that our framework logs possible restore points without the
need for the user to intervene. However, the user has the option to
enable a particular class of alert to be active. As an example, one
could set a system driver installation to be an active alert showing
the user whether he/she is going to be installing a privileged com-
ponent. A point to note is that, a user can of course safely go ahead
and install the driver without having to worry about its nature irre-
spective of whether the driver might be benign or malicious.
6 Discussion
6.1 Framework Security
Security of Views: The implementation of views takes advan-
tage of the fact that under normal system operations executables
are never modiﬁed and data ﬁles are normally modiﬁed within a
single session. This leads to a simple and effective implementa-
tion of maintaining COWed copies of modiﬁed ﬁles.
However, an adversary may try to ddos our approach by per-
forming multiple opens and closes resulting in many COWed
copies being created. This attack can be detected by monitor-
ing the number and frequency of such recurring accesses and by
placing an alert on such recurrent accesses. A normal application
by our tests should in most cases never trigger an alert. An ad-
versary could also ddos our attack by employing moderate opens
and closes on huge ﬁles. However, in our experience applications
which deal with such huge ﬁles are most likely to be database ori-
ented and in which case have some internal rollback features em-
bedded for the data. Thus, for huge ﬁles the framework only main-
tains a single COWed copy. However, we can enhance our frame-
work to support this situation by maintaining incremental changes
instead of cowed copies. We leave this for future work.
Another form of attack could try and locate the framework view
ﬁles and tamper with them. However, in order to do so, a malware
has to go though the ﬁle system driver. Our framework intercepts
access to the view ﬁles and returns values which mimic their non-
existence.
Security of Mappings: Our framework can map a system op-
eration to an executing code-stream using call-contexts. If the mal-
ware code is in the form of an executable, dll, kernel mode driver,
allocated pool, the framework mappings always tie them into the
parent infomation of the request to a particular ﬁle or conﬁguration
object as described in section . A malware could however exploit
a vulnerability and execute code on the stack and this code could
overwrite code in some other module in order to execute access
to a ﬁle/ conﬁguration object.
In usermode, such modiﬁcations
will be detected by the framework using COW, however in kernel-
mode it is difﬁcult. Further in user mode a malware could jump
to a module from the stack in order to create a ﬁle. In this case
the mapping would have no parents, and we can signify an orphan.
But if there are modiﬁed modules, then we will link them into the
parent. In kernel-mode normally there are no ﬁle creations done
by standard modules, thus if there are no loaded modules after
framework, then signify an orphan else link the loaded modules as
the parent. In either case depending on where the ﬁle is created,
most likely either in a system path since the malware wishes to be
persistent, the framework can always issue an alert.
Security of Interceptors: The intercepts within our framework
are directly within the ﬁle system driver itself. A malware could
intercept within the FSD, but would still have to invoke the frame-
work since we intercept the FSD at the lowest level where we can
grab enough information about the ﬁles being manipulated. A mal-
ware could try and interpose below us, however in our opinion it
is a non-trivial process and would severely be compromising the
stability of the system as these internal routines and the structures
they employ vary depending on the ﬁle system driver being used.
A malware cannot dynamically load another FSD for the same vol-
ume as the OS will not allow it to do so. It could install a ﬁlter,
but then will have to invoke our framework in the chain. A mal-
ware could overwrite the ﬁlesystem driver image in order to be
activated in the next bootup, but our framework can capture such
a modiﬁcation and will issue an alert.
Security of Recovery: Since we keep track of all modiﬁcations
to our system state and we ensure that these information cannot be
tampered with, recovery will always succeed. The recovery pro-
cess aborts all processes that are related to the view being switched
from and hence cannot be interrupted. This also prevents the risk
of reinfection.
6.2 Limitations
While our framework is capable of capturing all ﬁlesystem and
conﬁguration changes to the system, there are currently some lim-
itations.
The framework maintains internal memory structures related
to views and mappings. It periodically ﬂushes such information
to disk. However, a malware running in kernel-mode could tam-
per with these memory structures resulting in system instability.
While, we can still restore the system to a stable and clean state
on the next bootup, the tampering could lead to loss of more clean
data than usual. A malware could also tamper with the recovery
console (which is a user-mode interface to the user) in order to
prevent restoration. However, in such situations we can always
restore the system after a reboot.
The framework employs COW mechanism on the entire ﬁle in
order to maintain its views. This can have severe impact on the
system when dealing with big ﬁles. The performance of the frame-
work can also be impacted with high volume of small ﬁle creations
and modiﬁcations. One solution to this problem would be to em-
ploy COW at a smaller granularity (such as a multiple of 512 or
1024 bytes) . This would ensure that only parts of a ﬁle that are
changed are COWed rather than the whole ﬁle thereby reducing
320320
the disk space required to maintain views.
A malware running in kernel-mode could directly access the
disk bypassing the ﬁlesystem driver altogether. However, as we
discussed at that level a malware will have to incorporate the com-
plete ﬁlesystem code within itself in order to traverse the disk to
create or read/write ﬁles. This is a non-trivial task. Further, ac-
cessing the disk directly could lead to ﬁlesystem inconsistencies
due to the fact that the ﬁle system drivers often cache directory
entry information (which describes ﬁle/folder information). The
same principle holds true with modiﬁcations to the registry mem-
ory areas/disk structures as the conﬁguration manager caches most
entries which will lead to inconsitencies and system instability.
The framework mappings help in minimizing the amount of
clean data that is lost, but it is still very coarse-grained. In other
words, the mapping does not exactly pinpoint the originator of the
operation. Doing so, requires complete control over the executing
code streams and the modiﬁcations it makes which is a heavy duty
process, especially for code running in kernel-mode.
7 Conclusions
We have described MalTRAK, a framework for tracking and
eliminating known and unknown malware. The framework allows
the user to run any program without requiring policies or rules
to be places apriori, while guaranteeing the capability of restor-
ing the system to a clean state in case of an infection. Further-
more, it does so with minimal runtime overhead and by minimiz-
ing the amount of clean data lost during disinfection. The frame-
work achieves these goals by establishing different logical views
of the system during runtime and by maintaining a relationship be-
tween the views depending upon the system operations. It can then
switch to a clean system state upon infection by switching to the
appropriate view before the infection took place. The framework
monitors system operations at the lowest possible level ensuring
that it is very difﬁcult (almost impossible) to bypass. We imple-
mented MalTRAK on Windows and tested our prototype on 8 real
world malware and compared it with two popular commercial anti-
virus tools. With minimal overhead (both disk space and runtime
latency) we were able to completely remove their effects on the
system while the commercial tools, on an average were only able
to restore 36% of all their effects put together. For one of the mal-
ware samples, the commercial tools could only detect it but could
not repair any of its damage. Further, for two of the malware sam-
ples, the commercial tools were completely unable to detect or
restore any of their effects.
References
[1] A. B. Brown and D. A. Patterson. Undo for operators: Building an
undoable e-mail store. In Proceedings of the Usenix Annual Techni-
cal Conference, 2003.
[2] M. Christodorescu, S. Jha, S. Shesia, D. Song, and R. Bryant. Se-
mantic aware malware detection. In Proceedings of the IEEE Sym-
posium on SEcurity and Privacy, 2005.
[3] M. Christodorescu and J. S. Static analysis of executables to detect
malicious patterns. In Proceedings of the USENIX Security Sympo-
sium, 2003.
[4] F. Cohen. Operating system protection through program evolution.
In Available at (http://all.net/books/ip/evolve.html), 1998.
[5] G. W. Dunlap, S. T. King, S. Cinar, M. Basrai, and P. M. Chen.
Revirt: Enabling intrusion analysis through virtual machine logging
and replay. In Proceedings of the Usenix Symposium on Operating
Systems Design and Implementation (OSDI), 2002.
321321
functions.
1999.
[6] J. Gifﬁn, S. Jha, and B. Miller. Detecting manipulated remote call
streams. In Proceedings of the USENIX Security Symposium, 2002.
[7] A. Goel, K. Po, K. Farhadi, Z. Li, and E. de Lara. The taser intru-
In Proceedings of the ACM Symposium on
sion recovery system.
Opersting System Principles (SOSP), pages 163–176, 2005.
[8] A. Gostev. Malware evolution: January - july 2007. Kaspersky Lab
Report, October 2007.
[9] F. Hsu, H. Chen, T. Ristenpart, J. Li, and Z. Su. Back to the future:
A framework for automatic malware removal and system repair. In
Proceedings of the Annual Computer Security and Applications Con-
ference (ACSAC), 2006.
[10] G. Hunt and D. Brubacher. Detours: Binary interception of win32
In Proceedings of USENIX Windows NT Symposium,
[11] K. Kasslin. Kernel malware: The attack from within. Association of
Anti-virus Asia Researchers (AVAR), 2006.
[12] S. King and P. Chen. Backtracking intrusions. In Proceedings of the
ACM Symposium on Operating Systems Principles (SOSP), 2003.
[13] S. King, G. W. Dunlap, and P. M. Chen. Debugging operating sys-
In Proceedings of the
tems with time-traveling virtual machines.
Usenix Annual Technical Conference, 2005.
[14] S. T. King, G. W. Dunlap, and P. M. Chen. Operating system support
for virtual machines. In Proceedings of the Usenix Annual Technical
Conference, 2003.
[15] E. Kirda, C. Kruegel, G. Banks, G. Vigna, and R. A. Kemmerer. Be-
havior based spyware detection. In Proceedings of IEEE Symposium
on Security and Privacy, 2007.
[16] B. Krebs. Mpack exploit tool slips through security holes. The
Washington Post, June 2007.
[17] C. Kruegel, W. Robertson, and C. Vigna. Detecting kernel level
rootkits through binary analysis. In Proceedings of the Annual Com-
puter Security and Applications Conference, 2004.
[18] R. Kuster. Three ways to inject your code into another process. Code
Project (http://www.codeproject.com/KB/threads/winspy.aspx), Au-
gust 2003.
[19] Z. Liang, V. Venkatakrishnan, and R. Sekar. Isolated program exe-
cution: An application transparent approach for executing untrusted
programs. In Proceedings of Annual Computer Security and Appli-
cations Conference (ACSAC), 2003.
[20] C. Linn and S. Debray. Obfuscation of executable code to improve
resistance to static disassembly. In Proceedings of ACM Conference
on Computer and Communication Security, 2003.
Red-
iff (http://www.rediff.com/money/2006/nov/30spec.htm), November
2006.
Top 10 computer virus threats in 2007.
[21] McAfee Inc.
Virusscan plus: Anti-virus and anti-spyware.
[22] McAfee Inc.
(http://www.mcafee.com), 2007.
[23] mi2g. Five solutions to the rising identity theft and malware prob-
lem. mi2g alerts (http://www.mi2g.com/cgi/mi2g/press/240304.php),
March 2004.
[24] Microsoft Corp. Windows asynchronous procedure calls. MSDN
(http://msdn2.microsoft.com/en-us/library/ms681951.aspx), 2007.
[25] D. A. Patterson, A. Brown, P. Broadwell, G. Candea, M. Chen,
J. Cutler, P. Enriquez, A. Fox, E. Kiciman, M. Merzbacher, D. Op-
penheimer, N. Sastry, W. Tetzlaff, J. Traupman, and N. Treuhaft. Re-
covery oriented computing (roc): Motivation, deﬁnition, techniques,
and case-studies. In Technical Report UCB/CSD021175, 2002.
[26] M. Rosenblum and J. K. Ousterhout. The design and implementation
of a log-structured ﬁle system. In ACM Transactions of Computer
Systems (TOCS), volume 10(1), pages 26–52, 1992.
[27] E. Skoudis. 10 emerging malware trends for 2007. Search Security,
[33] N. Zhu and T. C. Chiueh. Design, implementation and evaluation of
repairable ﬁle service. In International Conference on Dependable
Systems and Networks (DSN), 2003.
January 2007.
[28] W. Sun, Z. Liang, V. Venkatakrishnan, and R. Sekar. One-way iso-
lation: An effective approach for realizing safe execution environ-
ments. In Proceedings of Network and Distributed Systems Sympo-
sium (NDSS), 2005.
[29] Symantec Corp. Norton anti-virus.
(http://www.symantec.com),
[30] P. Szor. The art of antivirus research. Wiley Publishers, 2005.
[31] A. Vasudevan and R. Yerraballi. Sakthi: A retargetable dynamic
framework for binary instrumentation. In Proceedings of the Hawaii
International Conference in Computer Science (HICCS), 2004.
[32] M. Wise. Windows xp system restore. Microsoft Technet Library,
2007.
2002.