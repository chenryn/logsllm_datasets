As shown in Figure 3, the guided fuzzing mechanism takes
as input the output of the symbolic execution component (i.e.,
the sample parameters for the respective syscall and, if present,
additional loop information). The result of the fuzzing phase
is essentially an overview of what we have to do in order
to control the kernel stack, including which syscalls, which
parameters of these syscalls we need to use, and the effect of
these syscalls on the kernel stack (i.e., which range of the stack
we can control).
Verifying spraying. To verify whether spraying is achieved
(i.e., the magic code is left on the kernel stack), first, the
guided fuzzing prepares the concrete parameters for the syscalls
reported by the symbolic execution component, which are
either the sample parameters generated by S2E or magic code.
As described in §IV-A1, we assume a pointer-type parameter
always points to a single-element buffer. To reduce crashes
caused by out-of-bound accesses and increase the spraying
range during the fuzzing, for a pointer-type parameter, we mmap
a memory of the size of the kernel stack, fill in it with magic
code, and let the pointer-type parameter point to this memory.
Second, we need to scan the stack memory right after a syscall
returns. Therefore, we need to intercept the return of the syscall
and dump the stack memory at the point of the return. The
methods to intercepting syscalls include: (1) instrumenting the
Linux kernel source code, (2) patching the syscall table, and
(3) using kprobes [2]. Method (1) might introduce a bias when
verifying the success of the targeted stack-spraying because
it requires changing the source code. Therefore, this method
is not desirable. Method (2) and method (3) are similar in
principle; however, since kprobes provides a more flexible and
reliable way of intercepting syscalls, we chose method (3)
to intercept the return of syscalls and insert our logic in the
handler for the interception. Upon intercepting a syscall return,
the verification is performed by scanning the stack memory and
checking which ranges of stack memory have been polluted
with the magic code. Once the magic code is found, the range
information together with the corresponding syscall parameters
are reported.
Fuzzing loops. A well-known limitation with symbolic
execution is the path explosion problem that the number of
feasible paths in a program grows exponentially in the case of
programs with loops. Even a single loop can generate a huge
number of symbolic execution paths corresponding to the loop
iterations [35], thus resulting in the path explosion problem.
To handle this problem, KLEE (internally adopted by S2E)
randomly picks or uses search heuristics [7] to select a state to
execute. This design decision inherently prevents our targeted
stack-spraying from finding and exploiting a syscall containing
a loop to spray a huge and continuous range of stack. Therefore,
instead of letting S2E symbolically execute the loop, we let
it tell us which syscall contains loops and which parameters
are used as the loop condition. Then we let our guided fuzzer
handle loop cases by specifically fuzzing the condition-related
parameters. All other parameters that are used as input for
the fuzzer are either the sample values generated by S2E or
magic code, as mentioned in §IV-A1. With the combination of
S2E (with the loop information) and the guided fuzzer, we are
able to efficiently and comprehensively identify the controllable
range of the stack.
3) Coordination: The coordination unit is designed to safely
run the symbolic execution and the guided fuzzing components
in parallel. Both the symbolic execution engine and the guided
fuzzer are contained in a QEMU virtual machine, for which two
6
separate QEMU snapshots are created that specifically run either
the symbolic execution engine or fuzzing mechanism. Instead
of running all syscalls in the same instance of a snapshot, each
syscall is tested in a separate instance, thereby enabling us to
run the syscalls independently of each other and thus safely
contain the crash or the error of the running of each syscall. To
facilitate the coordination between the different components,
we have designed two features: (1) a communication scheme
for the whole testing framework and (2) a controlling scheme
for sending commands to the testing instances.
Communication scheme. To efficiently find the syscall and
its parameters that can achieve the targeted stack-spraying, the
symbolic execution snapshot and the guided fuzzing snapshot
run in parallel; therefore, a real-time communication scheme is
required. The communication is used for sending (1) commands
from the coordinator to the virtual machines, (2) outputs of the
symbolic execution engine to the guided fuzzing mechanism,
and (3) verification results from the guided fuzzing mechanism
to the coordinator. We chose pipe as the communication channel
and use the paravirtualized drivers (virtio) [3] of KVM to
improve the performance of I/O operations.
Controlling scheme. During the analysis process, it is common
that the symbolic execution engine and the guided fuzzing
mechanism crash or get stuck in infinite loops. In these
cases, the controlling scheme must terminate or restart the
virtual machines. Specifically, we design a command receiver
along with a set of pre-defined commands, which runs in
both snapshots of the QEMU virtual machine for symbolic
execution and guided fuzzing. As an example, when the guided
fuzzing does not terminate after a specified period of time,
the coordinator will send the command STOP to terminate the
snapshot.
B. Exhaustive Memory Spraying
Although the deterministic stack spraying technique can
deterministically control the frequently used stack region, its
coverage is limited: It is hard to find an execution path that
can save attacker-controlled data in the stack region after the
highest 1KB because stack objects are rarely saved in this region.
To control this region that spans the majority of the kernel
stack, we design the exhaustive memory spraying technique.
Note that this technique is general: It can control not only the
kernel stack but also other memory regions that are dynamically
allocated in the kernel space, such as the kernel heap. Compared
to the deterministic stack spraying technique, the exhaustive
memory spraying technique is straightforward, which includes
two parts: (1) memory occupation, which consumes the majority
of available memory in a system and (2) memory pollution,
which writes malicious data in the remaining memory.
1) Occupying Memory: The goal of occupying the majority
of available memory is to restrict the kernel to use the small
remaining memory for new stack allocations. Because the
remaining memory is small, attackers can finish the next
step, memory pollution, in a quick and effective manner. To
decide how much memory to occupy, we first obtain the
total size of available memory and allow attackers to specify
the amount of non-occupied memory (e.g. 50MB). All other
available memory is then to be occupied. Specifically, we
incrementally create many processes, each of which mmaps
a few megabytes of memory. To avoid being “shrunk” by
techniques Copy-on-Write and Deduplication, we explicitly
write a random 8-byte value (obtained from /dev/urandom) into
each memory page. Moreover, we keep these processes running
during the attack to ensure the memory remains occupied
throughout the exhaustive memory spraying process.
2) Polluting Memory: Since the majority of memory has
already been occupied, when the kernel creates a new process
or thread, the allocated kernel stack will be forced to use the re-
maining available memory. By polluting the remaining memory
with malicious data (that attackers want to spray into the kernel
stack), the allocated kernel stack will overlap the memory pages
with the malicious data. The polluting process also obtains the
size of available memory (after memory occupation), mmaps
a memory of this size and writes the malicious data into it.
Afterwards, the pollution process munmaps the polluted memory.
Note that munmap does not clear the malicious data in memory.
To ensure that the pollution is effective and that the polluted
memory contents are not overwritten by another process, we
perform the munmap operation right before invoking the syscall
with an uninitialized-use vulnerability.
V.
IMPLEMENTATION
In this section, we present the prototype of both the deter-
ministic stack spraying technique and the deterministic stack
spraying technique technique. Although the implementation
currently targets the Linux kernel, it is possible to extend it
to other OS kernels (e.g. windows) since it only requires the
syscall interfaces and can directly work on binaries.
A. Deterministic Stack Sprayer
1) Symbolic Execution Engine: As discussed in §IV-A1, we
use S2E as the symbolic execution engine in our targeted stack-
spraying system. To facilitate the analysis of large numbers of
syscalls, we additionally implemented an automatic test case
generator for syscalls and two S2E plugins that handle the
input generation for the fuzzer and the identification of loops.
Test case generator. The automatic test case generator takes
as input the definition (i.e., the signatures) of the syscalls
to be tested. To obtain these definitions, we searched the
source code of the Linux kernel for the pattern of syscall
definition. Specifically, syscalls are always defined using the
uniform macro SYSCALL_DEFINEx where x denotes the number
of parameters. For example, the open syscall is defined as
follows:
SYSCALL_DEFINE3(open, const char *, filename, int, flags, uint16_t, mode)
Given that we achieve targeted stack-spraying by preparing
data in parameters, syscalls that do not have parameters (e.g.,
getpid) and therefore cannot take user-controlled data are
ignored. Also, because the underlying hardware architecture
of our testing machine is x86/x86_64, only syscalls for this
architecture are selected. The test case generator itself is
implemented as a python script with the execution environment
being set up by LTP. As mentioned in §IV, when handling
pointer-type parameters, we only symbolize the first element
of the buffer the pointer refers to. To reduce potential issues
caused by out-of-bound accesses, during symbolic execution,
we allocate memory chunks of the kernel-stack size (i.e.,
7
16KB) for these elements. Once the respective parameters are
symbolized, we use the general syscall() function to trigger
the symbolic execution for the syscall under analysis.
S2E Plugins. We implemented two S2E plugins to facilitate
the automatic analysis of large numbers of syscalls: (1) a
path explorer plugin that explores possible execution paths and
generates concrete parameters for each execution path, and
(2) a loop explorer plugin that identifies loops whose looping
conditions depend on syscall parameters. The path explorer
plugin intercepts the state-killing signal that occurs when an
execution path is finished, i.e., when a state is terminated. The
signal handler then asks the constraint solver to generate sample
parameters that trigger this path. For each parameter, the plugin
further checks if it is contained in the path constraints: If yes,
the parameter is classified as a controlling parameter that affects
the execution path; otherwise, it is a non-controlling parameter
that will be replaced with magic code during the guided fuzzing.
The loop explorer plugin aims to identify loops with symbolic
conditions. We identify loops using a two-layered approach
that tracks the execution history for each function as well
as the relative offsets between these instructions inside the
respective function. Specifically, we hook S2E at the end of
each block by catching the onTranslateBlockEnd signal and
then check if the last instruction of the block is a direct call
or indirect call instruction to intercept function calls. Note that
S2E translates the binary at block level rather than function
level, so checking the last instruction of each block is necessary
to identify function calls. When the execution enters a function,
we create a list to maintain the executed instructions. Since the
(virtual) address of each instruction in the memory is unique, we
save the PC values (i.e., the values of instruction pointer) in the
list. To know whether an instruction is a conditional jump, we
read the machine code pointed to by the PC to get the opcode
and then match the opcode to confirm the instruction. Once a
conditional jump is identified, the PC of the next instruction
(i.e., the target of the jump) is checked: If it is already in the
executed instruction list, we report it as a loop. Otherwise, we
check whether its PC is smaller than the one of the conditional
jump instruction: If it is, we also report it as a loop. If the
loop condition is symbolic, we use the getRange() function
provided by the constraint solver to compute the possible value
range of the condition value.
2) Guided Fuzzer: The guided fuzzer verifies if the spraying
can be actually achieved and also mitigates the limitations
of symbolic execution by specifically fuzzing loop-related
parameters. Our guided fuzzer is implemented on top of the
Trinity fuzzer [18].
Tailoring the Trinity fuzzer. Fuzzing in general faces the
problem that purely randomized inputs for functions often lead
to failures (i.e., being terminated by sanity checks), preventing
the exploration of interesting execution paths. For example, if a
file descriptor parameter (4-byte) would be purely randomized,
the kernel would likely simply reject the execution of the syscall
and return -EINVAL. Trinity addresses this problem by creating
a list of file descriptors: opening pipes, scanning file systems
(e.g., sysfs, procfs, and /dev), and creating a bunch of sockets
using random network protocols; and then passing one of these
entities at random whenever a syscall needs a file descriptor.
For parameters other than file descriptors, we instruct Trinity to
take as input the concrete parameters generated by the symbolic
execution component. In particular,if a parameter is loop-related
(i.e., it is used as the looping condition), we let Trinity focus
on this parameter by generating random values within the value
range specified by the symbolic execution component.
Spraying verifier. As discussed in
§IV-A2, intercepting
syscall returns is done by using the kprobes tool. kprobes
provides three different types of probes depending on the
intended purpose: kprobe for intercepting syscall entries, jprobe
for intercepting jump instructions, and kretprobe for intercepting
syscall entries and returns. Since we check the stack at syscall
returns, the most suitable probe for us is kretprobe, which we
implemented in a kernel module. Our kretprobe kernel module
takes as input the name of syscall under analysis and intercepts
the return of this particular syscall. Upon interception, we
derive the stack top (the lowest address) of the current kernel
stack by computing stack_pointer &
(THREAD_SIZE - 1)
where stack_pointer is provided by kprobes and the macro
THREAD_SIZE defines the size of the kernel stack, which varies
on operating systems, e.g. it is typically 8K on 64-bit Ubuntu
and 16KB on 64-bit Debian. Once we have computed the stack
top and size of the kernel stack, verification is performed by
searching the stack memory for magic code. To output the
verification results, we need to write the data into user space
files from our kernel module. For safety and reliability reasons,
writing to a user space file from kernel space is discouraged.
Therefore, we use the /proc virtual file system to pass results
to user space, which is later passed to the coordinator.
3) Coordinator: The coordinator controls the symbolic
execution engine and the guided fuzzer. The input for the
coordinator is the specific range of stack that we want to
control, which is used to tell our targeted stack-spraying to find
syscalls with corresponding parameters that can save arbitrary
data in this range. Once it receives that range, the coordinator
runs the symbolic execution engine and the guided fuzzer in
parallel to identify suitable syscalls and their parameters as
quickly as possible.
Ranking and syscalls. To identify syscalls that can spray the
specified range as quickly as possible, the coordinator prioritizes
three types of syscalls: (1) syscalls that set configurations or
write data. Such syscalls (e.g., pwritev) are very likely to
save data on kernel stack; (2) syscalls that contain loops. Such
syscalls usually affect a large region of the kernel stack; and
(3) syscalls that contain (multiple) pointer-type parameters.
By directing pointers to attacker-controlled buffers containing
magic code, syscalls containing more pointer-type parameters
are likely to have a higher chance to save the magic code
on kernel stack. Remaining syscalls are analyzed after the
aforementioned ones. With more interesting syscalls being
analyzed first, it is more likely to find a suitable sprayer in a
fixed amount of time.
B. Exhaustive Memory Sprayer
We implemented the exhaustive memory sprayer as a user-
space program. The amount of available memory in the system
is obtained with command free -m. In our case, we want to
keep some small portion of memory (e.g. 50MB) available and
occupy all other memory. During memory occupation, we fork
processes, each of which occupies 2MB memory, to exhaust all
memory besides that we want to intentionally leave available.
8
The polluting process then writes malicious data (magic code
in our case) to the remaining available memory and munmaps it.
To verify if the newly allocated stacks use the polluted memory
pages, we intercept syscall entries using kprobes and scan stack
memory for magic code. We instrumented the Trinity fuzzer
to asynchronously run memory occupation and call memory
pollution before invoking syscalls.
VI. EVALUATION
We evaluated the effectiveness of our targeted stack-
spraying approach with regard to exploiting uninitialized-use
vulnerabilities by measuring the control coverage we achieved.
We present the total stack ranges that we can control with
deterministic stack spraying and exhaustive memory spraying,
the distribution of controlled regions, and the time spraying
takes. In particular, we investigate the following questions:
• Stack spraying coverage. What is the overall range of