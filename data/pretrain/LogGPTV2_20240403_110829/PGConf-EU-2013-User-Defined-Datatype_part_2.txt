Operator class
An operator class ties the individual operators together. Operator
classes are dened for indexing support, but the B-tree operator
class is a bit special.
CREATE OPERATOR CLASS luminence_ops
DEFAULT FOR TYPE colour
USING btree AS
OPERATOR 1 =,
OPERATOR 5 >,
FUNCTION 1 luminence_cmp(colour, colour);
Ready to order!
postgres=# SELECT * FROM colour_names ORDER BY rgbvalue;
name | rgbvalue
------------+----------
white | #FFFFFF
light grey | #C0C0C0
lawn green | #87F717
green | #00FF00
dark grey | #808080
red | #FF0000
blue | #0000FF
black | #000000
(8 rows)
Indexing
We already created the B-tree operator class:
CREATE INDEX colour_lum_index ON colour_names (rgbvalue);
EXPLAIN SELECT * FROM colour_names
WHERE rgbvalue=’#000000’
ORDER BY rgbvalue;
QUERY PLAN
-------------------------------------------------------------
Index Scan using colour_lum_index on colour_names
(cost=0.13..8.20 rows=4 width=36)
Index Cond: (rgbvalue = ’#000000’::colour)
(2 rows)
postgres=#
Summary so far
We have created a type:
 With input and output functions
 With functions for splitting a colour into components and
calculating luminence
Index support:
 Operators: > >= =  (
PROCEDURE = colour_diff,
LEFTARG=colour,
RIGHTARG=colour
);
Order by distance
postgres=#
SELECT * FROM colour_names ORDER BY rgbvalue  ’#00FF00’;
name | rgbvalue
------------+----------
green | #00FF00
lawn green | #87F717
dark grey | #808080
black | #000000
light grey | #C0C0C0
white | #FFFFFF
blue | #0000FF
red | #FF0000
(8 rows)
But can we index that?
postgres=# explain SELECT * FROM colour_names
ORDER BY rgbvalue  ’#00FF00’;
QUERY PLAN
----------------------------------------------------------
Sort (cost=1.46..1.48 rows=8 width=36)
Sort Key: (sqrt((((((red(rgbvalue) - 0))::double precision ^ 2::double precision) + (((green(rgbvalue) - 255))::double precision ^ 2::double precision)) + (((blue(rgbvalue) - 0))::double precision ^ 2::double precision))))
-> Seq Scan on colour_names (cost=0.00..1.38 rows=8 width=36)
(3 rows)
Oh, a seqscan. With a billion colours, that could be slow..
Advanced index types
PostgreSQL oers three kinds of generalized index types:
 GIN
 GiST (Generalized Search Tree)
 SP-GiST (Space-partitioned GiST)
PostgreSQL provides:
 WAL-logging
 Concurrency
 Isolation
 Durability
 Transactions
GIN
Generalized Inverted Index.
Splits input key into multiple parts, and indexes the parts.
For example:
 Full text search - extract each word from text, index the words
 Arrays - index the array elements
 Word similarity (pg_trgm) - extract trigrams from text, index
trigrams
GiST
General tree structure
 Extremely exible
 You dene the layout
Used for:
 Full-text search
 Trigrams
 Hierarchical labels, ltree contrib module
 B-tree emulation
 Points (R-tree)
B-tree refresher
Five operators:
 >=
One support function;
 colour_cmp() - returns -1, 0 or 1
GiST
GiST has 8 support functions:
 consistent - when searching, decide which child nodes to visit
 union - create a new inner node from a set of entries
 compress - converts a data item to internal format, for storing
 decompress - the reverse of compress
 penalty - used to decide where to insert new tuple
 picksplit - when page becomes full, how to split tuples on new
pages?
 same - returns true if index entries are equal
 distance - returns the distance of an index entry from query
(optional)
R-Tree
Page 1
(1,8)
10
(3,9)
Page 1
9
8
Page 2
7
Page 0 (root)
(3,3)
6 (4,4)
Page 2
(2,8) (3,9) (4,5)
5
(5,5)
Page 3 (3,3) (5,5)
4
(1,2) (4,4)
Page 3
3 (7,1) (9,2)
Page 4
2 (1,2)
(2,3)
1 (2,4)
0
0 1 2 3 4 5 6 7 8 9 10 Page 4
(7,2)
(1,8)
(1,9)
R-Tree using GiST
Support functions:
 consistent - Return true if point falls in the bounding box
 union - Expand bounding box to cover the new point
 penalty - Return distance of given point from bounding box
 picksplit - Divide points minimizing overlap
 same - trivial equality check
 distance - distance of given point from bounding box or point
 compress/decompress - do nothing
R-Tree for colours using GiST
 Treat colours as 3d points.
 In internal nodes, store a bounding box
 In leaf nodes, store the colour itself
Space-Partitioned GiST (SP-GiST)
New index type in PostgreSQL 9.2
Like GiST, but SP-GiST totally partitions the key space. * No
overlapping pages.
Can be used to implement e.g:
 prex tries for text
 Quad-tree for points
 KD-tree for points
KD-tree
5 x=3,5
4
3 y=2,5 y=3
2
x=1,2 x=1,8 x=4,8 x=5,2
1
(1|1) (2|1,5) (1|3) (3|3,5) (4|2) (5|0,5) (4,5|4) (6|5)
0 1 2 3 4 5 6
(2dbaum.svg, Wikimedia Commons / Public Domain)
Implementing SP-GiST operator class for colours
 KD-tree.
 Each colour is a point in 3-D space. Each component, Red,
Green, Blue, is one dimension.
SP-GiST support functions
SP-GiST requires 5 support functions:
 cong - Returns static information about the implementation
 choose - How to insert a new value into an inner tuple?
 picksplit - How to create a new inner tuple over a set of leaf
tuples.
 inner_consistent - Returns set of nodes (branches) to follow
during tree search.
 leaf_consistent - Returns true if a leaf tuple satises a query.
Advanced indexes summary
PostgreSQL oers three kinds of generalized index types:
 GIN (Generalized Inverted Index)
 GiST (Generalized Search Tree)
 SP-GiST (Space-partitioned GiST)
PostgreSQL provides:
 WAL-logging
 Concurrency
 Isolation
 Durability
 Transactions
The end
You’re the expert in your problem domain!
You dene the semantics!
PostgreSQL handles the rest!