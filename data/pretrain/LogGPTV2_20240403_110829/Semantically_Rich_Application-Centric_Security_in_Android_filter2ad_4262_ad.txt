hooks (5) and (6) iterate over the lists of potential
receivers and perform a policy check for each one before
it is allowed to receive a message.
Accessing Content Providers (4.C) — In Android, ap-
plications access content providers by a URI. The Content
Resolver is responsible for mapping a URI to a speciﬁc
content provider and obtaining the IPC interface to the
content provider that performs the operations (e.g. query,
update, etc.). Android’s permission check is performed
by the content provider during the operation execution.
This check is inadequate to protect applications from a
potentially malicious content provider that has registered
under a particular URI.
Saint Hook Placement: To extend the enforcement to
allow the source component to be protected as well, Saint
places authorization hook (7) at the Content Resolver. The
list of registered content providers is stored by the AMS
in form of Provider Record. Therefore, our modiﬁed AMS
provides the Provider Record that matches the authority
string to the Content Resolver. The record contains infor-
mation that allows application policy checking.
Binding Components to Services (4.D) — The last type
of interaction mediated by Saint is binding a component to
a service (allowing the component to access the service’s
APIs). A component binds to a service either by specify-
ing its name or an Intent containing an action string to
which that service has registered. Binding to services is
mediated by the AMS, which ﬁrst resolves the service by
name or action string and then checks that the requesting
component has the necessary permissions to bind it.
Saint Hook Placement: We inserted a single mediation
point, (8), into the AMS to check Saint policy before the
Android permission check. Since access policies require
the source component name in the hook, we extracted the
source name from a ﬁeld in the binding request. For the
other types of component interactions where the source
name was not available, we modiﬁed the execution path
up to the hook to propagate the name of the component
initiating the interaction.
347
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:12:28 UTC from IEEE Xplore.  Restrictions apply. 
App 
Start Activity
Activity
Manager 
Service
Single
Match?
Yes
Start 
Activity 
with
Resolved
Target
3
Yes
No
1
(A)
App 
Broadcast Intent
Activity
Manager Service
Receiver 
Name?
Yes
No
Menu
No
2
Single
Match?
Send to
Broadcast Receiver
Dynamic BR List
Static BR List
4
5
6
(B)
Resolver
Activity
Start
New Activity 
Key
Authorization Hook
Data Structure
Component
Control Flow
App 
Access Content Provider
Content Resolver
Activity
Manager
Service
Provider
Record
7
Content Provider
(C)
App 
Bind to Service
8
Activity
Manager
Service
Bind Application
to Service
(D)
Figure 5. Saint authorization hook placement. The added hooks for each of the four types of component interaction are numbered (1)-(8).
C. AppPolicy Provider
The policies for both the install-time and run-time
mediator are stored in the AppPolicy provider. We em-
bedded the AppPolicy provider inside the middleware
in a way similar to the phone’s address book, calendar,
and DRM provider are included in the platform. The
policy is stored in SQLite database, which is the default
database supported by Android. The database ﬁles for the
provider are located in the system directory, e.g., in the
/data/system/ directory.
More importantly, the AppPolicy provider is the policy
decision point. At install-time, the Saint Installer passes
the information about the package being installed to the
AppPolicy provider for the decision making using the
exposed verifyPermissionGrant API. The new
policy is inserted using insertApplicationPolicy
API. Both API interfaces are implemented as part of
Android’s Activity API. At run-time, inside the mid-
dleware, the Saint mediator’s hooks consult the AppPolicy
provider for policy decision based on the information
about the source and the destination of the interaction.
To make the decision, the AppPolicy provider retrieves
all matched policies and collects all information needed to
evaluate the conditions. For interaction policy, it may need
to contact Package Manager and several system services
such as Location Service and Telephony Service, which
require the caller to run under an application environment;
thus cannot be accessed by the AppPolicy provider. To ad-
dress the problem, we added more functions to the AMS,
which runs under “android” application environment, to
obtain the information for the AppPolicy provider.
Note that it is essential to protect the API interfaces
for accessing the AppPolicy provider from malicious ap-
plications. If not protected, a malicious application could
simply insert bogus policies to block legitimate IPC or
delete others. The current AppPolicy provider checks the
identity of the application that makes the API call. If the
application is not the Saint installer, the request is denied.
We foresee that it may be desirable for future applications
of Saint to allow other applications to view policy (e.g.,
policy viewers, system diagnostics). The current system
will be modiﬁed to either white-list read, write, or delete
for given applications or simply check to see they have
received some other system Saint policy permission.
D. FrameworkPolicyManager
As mentioned in Section V-C, FrameworkPolicyMan-
ager is implemented as an Android application to en-
able the user to override the policy if its override
ﬂag and the system’s SaintOverride ﬂag are true.
It updates the policies in AppPolicy provider using
updateApplicationPolicy API implemented in
Android’s Activity API. To prevent malicious appli-
cations from updating the policies, the identity of the
application is checked to ensure that only the Frame-
workPolicyManager can update the AppPolicy provider.
E. Condition Extensibility
So far, we have covered a set of policy enforcement
mechanisms implemented by Saint. These policies are
made up of conditions based on application conﬁguration
and phone state. Each condition requires code be run to
inspect some aspect of either an application’s context or
the device’s state. Currently, the AppPolicy provider is
limited to the static set of implemented conditions covered
in Section IV. Because we cannot predict the types of
conditions future smartphone apps may wish to check in
their security policies, Saint contains a generic mechanism
to perform custom condition checks implemented by
application developers. This mechanism works as follows.
At install time, an application’s package is checked
for one or more ConditionCheckImpl classes. These
classes are instantiated and registered by Saint at boot
time. The application includes conditions in its runtime
policy that are handled by its ConditionCheckImpl.
Any time a component from that application is either a
source or destination of one of Saint’s mediated com-
ponent interactions, the condition check method of its
ConditionCheckImpl class is called and the result is
composed with the results of the Saint enforced conditions
to make a policy decision. This method has the follow-
ing signature: boolean checkCondition(String
condition), where condition is a custom condition
string provided in the application’s runtime policy and the
return value is the result of the condition check.
348
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:12:28 UTC from IEEE Xplore.  Restrictions apply. 
VII. RELATED WORK
Much of the recent work in cell phone security has
centered around validating permission assignment at ap-
plication installation. For example, the Kirin [10] enforces
install policies that validate that the permissions requested
by applications are consistent with system policy. Kirin
does not consider run-time policies, and is limited to sim-
ple permission assignment. Conversely, the Application
Security Framework [11] offered by the Open Mobile Ter-
minal Platform (OMTP) recommends a certiﬁcate-based
mechanism to determine the application’s access rights
based on its origin. Symbian offers a stricter regimen
in the Symbian-signed program [12]. In this program
Symbian essentially vouches for applications, and pre-
vents unsigned applications from accessing “protected”
interfaces. The MIDP 2.0 security model regulates sensi-
tive permissions such as network access or ﬁle system
access based on protection domain deﬁned by Mobile
Information Device Proﬁle (MIDP) implementator (e.g.,
manufacturers and network providers) [13].
Systems for run-time policy are less developed. The
Linux Security Module (LSM) framework has been fre-
quently used to protect Linux phones. For example, the
trusted mobile phone reference architecture [14] realized
the Trusted Mobile Phone speciﬁcation using an iso-
lation technique developed for mobile phone platform.
Muthukumaran et al. [15] applied SELinux security poli-
cies to Openmoko to ensure the integrity of the phone
and trusted applications. In a related work, Rao et al. [16]
developed a mandatory access control (MAC) system for
smartphones which uses input from multiple stakehold-
ers to dynamically create the policies run-time permis-
sion assignment. The Windows Mobile .NET compact
framework uses security-by-contract [17] that binds each
application to a behavioral proﬁle enforced at runtime.
This technique was further explored as a means for safely
executing potentially malicious code [18]. Techniques
such as system call interposition have also been explored
for Windows Mobile [19]. None of these systems allow
applications to place context-sensitive policies on both the
interfaces they use and those that use their interfaces.
VIII. CONCLUSION
In this paper we present the Saint framework. Saint
addresses the current
limitations of Android security
through install-time permission granting policies and run-
time inter-application communication policies. We pro-
vide operational policies to expose the impact of security
policy on application functionality, and to mange depen-
dencies between interfaces. Driven by an analysis of many
applications, our investigations have provided an initial
taxonomy of relevant security contexts.
We are just at the beginning of this work. A most
pressing need now is the integration of more applications
and the policies they require into the system. We seek to
extend the Saint policies to protect the phone “system”
services and the cellular network, as well as integrate its
interfaces with widely used security infrastructures, e.g.,
PKIs, enterprise systems, etc. Through ongoing feature
enhancement and user study, we hope to transition Saint
from a research system to a viable framework for the
many millions of phones that will soon run Android.
REFERENCES
[1] Apple Inc., “Apple App Store,” http://www.apple.com/
iphone/appstore/, June 2009.
[2] Google Inc., “Android Market,” http://www.android.com/
market/, June 2009.
[3] Research In Motion Ltd., “Blackberry App World,” http:
//na.blackberry.com/eng/services/appworld/, June 2009.
[4] Independent Security Evaluators, “Exploiting android,”
http://securityevaluators.com/content/case-studies/android/
index.jsp.
[5] J. P. Anderson, “Computer security technology planning
study, volume II,” Deputy for Command and Management
Systems, HQ Electronics Systems Division (AFSC), L. G.
Hanscom Field, Bedford, MA, Tech. Rep. ESD-TR-73-51,
October 1972.
[6] W. Enck, M. Ongtang, and P. McDaniel, “Understanding
Android Security,” IEEE Security & Privacy Magazine,
vol. 7, no. 1, pp. 50–57, January/February 2009.
[7] W. Cheswick, S. Bellovin, and A. Rubin, Firewalls and
Internet Security: Repelling the Wily Hacker, Second ed.
ACM Books / Addison-Wesley, 2003.
[8] P. McDaniel and A. Prakash, “Methods and Limitations
of Security Policy Reconciliation,” in IEEE Symposium on
Security & Privacy, May 2002, pp. 73–87.
[9] M. Bishop, Computer Security: Art and Science. Reading,
MA: Addison-Wesley, 2003.
[10] W. Enck, M. Ongtang, and P. McDaniel, “On Lightweight
Mobile Phone Application Certiﬁcation,” in Proceedings
of ACM CCS, November 2009.
[11] Open Mobile Terminal Platform (OMTP), “OMTP Appli-
cation Security Framework V.2.2,” pp. 1–46, 2008.
[12] Symbian
Ltd.,
symbiansigned.com, August 2008.
“Symbian
Signed,”
https://www.
[13] Nokia Forum, “Midp 2.0: Tutorial on signed midlets v.1.1,”
July 2005.
[14] X. Zhang, O. Aciic¸mez, and J.-P. Seifert, “A Trusted
Mobile Phone Reference Architecture via Secure Kernel,”
in Proceedings of the ACM Workshop on Scalable Trusted
Computing, November 2007, pp. 7–14.
[15] D. Muthukumaran, A. Sawani, J. Schiffman, B. M. Jung,
and T. Jaeger, “Measuring Integrity on Mobile Phone
Systems,” in Proceedings of ACM SACMAT, June 2008.
[16] V. Rao and T. Jaeger, “Dynamic Mandatory Access Con-
trol for Multiple Stakeholders,” in Proceedings of ACM
SACMAT, June 2009.
[17] S3MS, “Security of Software and Services for Mobile
Systems,” http://www.s3ms.org/index.jsp.
[18] L. Desmet, W. Joosen, F. Massacci, K. Naliuka, P. Philip-
paerts, F. Piessens, and D. Vanoverberghe, “A ﬂexible
security architecture to support third-party applications on
mobile devices,” in Proceedings of ACM Workshop on
Computer Security Architecture, 2007, pp. 19–28.
[19] M. Becher and R. Hund, “Kernel-level Interception and
Applications on Windows Mobile Devices,” Reihe Infor-
matik, Tech. Rep. TR-2008-003, 2008.
349
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:12:28 UTC from IEEE Xplore.  Restrictions apply.