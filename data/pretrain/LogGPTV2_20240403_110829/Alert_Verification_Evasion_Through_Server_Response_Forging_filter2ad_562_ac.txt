PPTP  server  responded  to  these  malformed  requests  by  simply  resetting  the 
connection with a TCP RST packet.   
Responses to trans2root. The trans2root exploit is included in the Metasploit framework 
(samba_trans2open);  however,  this  experiment  used  the  public  exploit  because  the 
Metasploit exploit was unsuccessful in prior trials.  This exploit takes advantage of the 
266 
A.D. Todd et al. 
Samba call_trans2open() function overflow vulnerability.  This experiment captured the 
server responses generated by using the trans2root exploit against the vulnerable Samba 
version 2.25 and the patched version 3.0.23.  The application  was found to be able to 
exploit only five of the ten distributions (cf., Table 4).   
All  four  of  the  configurations  were  initially  vulnerable  to  the  trans2root  exploit.  
This exploit establishes an SMB session, connects to the SMB file tree, and sends a 
buffer  overflow.    Since  this  is  a  public  exploit,  it  has  a  hardcoded  shellcode  which 
establishes a shell back to the attacking computer.  Besides the packets establishing 
the remote shell, the exploited server responded with a simple acknowledgment and 
closed the connection with a FIN-ACK packet.   
The  configurations  running  the  patched  Samba  version  3.0.23  responded  to  the 
malicious Trans2 requests with an SMB error message.  After replying with an error 
message, the service closed the connection with a RST-ACK packet.   
Operating System Differences. This set of experiments tested the server responses 
generated by different operating systems to the same exploit.  Each operating system 
was  tested  while  installed  with  the  vulnerable  version  of  the  application  and  then 
again after the patched version of the service was installed.  A forged server response 
attack  is  much  more  useful  if  it  can  be  used  against  a  variety  of  operating  systems 
instead of being target specific.  In these tests, patched server responses seemed to be 
uniform  in  every  case  except  the  GNU  Mailutils  exploit.    Two  of  the  servers 
responded with additional error messages that the others did not.  Ultimately, it seems 
that  the  server  responses  remain  consistent  across  Linux  distributions,  and  this  is 
probably  because  these  are  third-party  applications  designed  to  run  on  any  Linux 
system and therefore are not inherently implementation specific. 
Not  only  was  this  experiment  designed  to  determine  the  differences  in  server 
responses between vulnerable and patched servers, but also designed to establish the 
universality of these responses and therefore the applicability of the server response 
forging  attack.    All  tested  exploits  targeted  vulnerabilities  in  applications  compiled 
and installed separately after the initial operating system installation; however, even 
though  all  operating  systems  were  running  the  same  applications,  they  were  not  all 
susceptible  to  the  exploit.    Table  4  shows  the  variety  of  Linux  distributions  and 
versions tested and their corresponding vulnerability to the four exploits. 
Table 4. Operating System Vulnerability  (Y = vulnerable, N = not vulnerable) 
Samba (nttrans)  Mailutils  PoPToP  Samba (trans2open) 
 O.S. 
Red Hat 7.3 
Y 
Fedora Core 2  N 
SuSE 9.3 
Y 
Mandrake 9.1  Y 
Mandrake 10.2  N 
Y 
Ubuntu 4.10 
Ubuntu 5.04 
Y 
N 
Ubuntu 6.06 
Y 
Debian 3.0 
Debian 3.1 
Y 
Y 
N 
Y 
Y 
N 
N 
N 
N 
N 
N 
Y 
N 
N 
Y 
N 
Y 
N 
N 
N 
N 
Y 
N 
Y 
Y 
N 
Y 
N 
N 
N 
Y 
Alert Verification Evasion Through Server Response Forging 
267 
The differences in vulnerability may be explained by different memory management 
techniques or advances in buffer overflow protection.  Buffer overflow attacks rely on 
overwriting the return address with an address pointing back into the buffer on the stack.  
This  type  of  attack  may  fail  when  the  buffer  is  stored  in  a  different  memory  location 
because it makes the buffer address on the stack harder to guess.  It could be the exploits 
are only designed to brute-force the memory locations where specific operating systems 
typically place the buffer on the stack.  Another possibility is the push for more secure 
operating systems which have incorporated protections against buffer overflow attacks.  
There  are  several  buffer  overflow  prevention  mechanisms  for  operating  systems 
including  making  stacks  non-executable  and  replacing  some  library  calls  with  safe 
versions of the same calls [30]. 
Server Response Summary. Server response forging is a valuable attack against an 
overwhelmed NIDS analyst using an automated verification mechanism to determine 
the success of an attack.  As noted previously, verification systems sometimes resolve 
alerts  by  simply  looking  for  the  appropriate  server  response,  typically  generated  by 
patched  servers.    This  technique  opens  up  the  possibility  of  forging.    Successful 
forging  requires:    1)  the  messages  generated  by  a  patched  server  must  be  different 
than that of a vulnerable server, otherwise, the two events would be indistinguishable 
and the analyst would not rely on the server response as a method for determining the 
success  of  an  exploit;  2)  the  response  from  a  patched  server  must  be  constant  or 
predictable.    This  condition  enables  the  correct  and  expected  server  response  to  be 
passed  along  with  the  exploit;  and  3)  successful  forging  requires  that  a  vulnerable 
server  does  not  provide  extra  information  indicating  it  has  been  exploited  (e.g., 
automatically sending a RST of FIN packet to close the connection).  While a server 
response may still be forged, this contradicting evidence may be enough to cause an 
analyst to investigate further. 
With the above guidelines in mind, server response forging seems to be a potential 
attack  against  two  of  the  four  exploits.    The  two  Samba  exploits  meet  all  the 
requirements:  the  vulnerable  and  patched  server  responses  are  different,  the  server 
response  is  constant,  and,  finally,  the  vulnerable  server  does  not  respond  with  any 
uncontrollable  information  which  indicates  that  the  server  has  been  exploited.    To 
forge  a  patched  server  response,  the  samba_nttrans  exploit  must  generate  an  SMB 
error  message  and  then  close  the  connection  with  a  RST  packet.    The  trans2root 
exploit would similarly need to send an SMB error message and close the connection 
with using a RST packet instead of a normal FIN-ACK response. 
The  other  two  exploits,  Mailutils  and  PoPToP,  are  not  good  candidates  for  the 
forged  server  response  attack.    After  a  vulnerable  server  is  compromised  using  the 
mailutils  exploit,  it  returns  several  erroneous  IMAP  responses.    In  the  test  cases 
above,  these  IMAP  responses  occurred  before  the  ping  request  which  means  they 
were  automatically  generated  before  the  shellcode  executed  and  spawned  the  ping 
request.  If these messages are automatically generated by a vulnerable server, then an 
automated verification mechanism will see these messages and investigate the system 
despite the fact that it sees the appropriate response later.  The PoPToP exploit faces a 
similar  problem.    Immediately  after  the  server  is  exploited,  it  closes  the  connection 
using a FIN-ACK packet.  The exploit then executes the shellcode, but this does not 
268 
A.D. Todd et al. 
leave  the  shellcode  with  the  opportunity  to  generate  the  appropriate  patched  server 
response  which  is  closing  the  connection  using  a  RST.    Again  the  verification 
mechanism will see the vulnerable server response and most likely alert the analyst to 
investigate the intrusion. 
Server response testing is necessary to determine if an exploit can be used with this 
type of forgery attack.  The conditions must be just right, but as this experimentation 
shows, it is not an impossible set of requirements to meet.  Half of the tested exploits 
appear  to  be  compatible  with  server  response  forging,  and  this  research  did  not 
consider web vulnerabilities which have been shown to be very susceptible to forged 
server responses [16].  With testing for the applicability of this attack complete and 
successful, the next step is developing forging techniques. 
4.2   Server Response Forging 
The  previous  section  presented  the  requirements  for  forging  a  packet.    This  section 
examines  the  details  and  implementations  of  three  different  forging  methods 
developed during the research and experimentation phases. 
Raw Socket. The first method for forging a packet begins by creating a new socket.  
To send a message, the shellcode must have a socket file descriptor on which to send 
out the message.  A simple way to obtain this socket file descriptor is by creating one.  
The  Linux  kernel  contains  a  socket  library  which  has  a  simple  socket  constructor.  
This constructor creates a raw socket capable of sending out raw datagrams.  This is 
an important feature because the shellcode must create a custom datagram capable of 
forging the server response. 
Network  packets  consist  of  header  information  and  a  payload.    The  payload  is  the 
message to be sent which in this case is a forged response.  Packets subdivide the header 
information between the different protocol layers.  Typical internet traffic consists of an 
Ethernet header, IP protocol header and, in most cases, a TCP protocol header.  The most 
important header is the TCP header which contains packet flags, the acknowledgement 
number, the sequence number, and the destination and source ports.  Some of the port 
numbers should be known ahead of time and the checksum  can be calculated, but the 
other information is much harder to determine.  A TCP session is usually initialized with 
a  random  sequence  number  to  make  session  hijacking  more  difficult;  however,  if  the 
attacker knows the initial numbers, subsequent numbers are predictable.  If the forged 
server  response  uses  an  inaccurate  sequence  or  acknowledgement  number,  the  IDS  or 
firewall may flag or drop the packet.  Therefore, the attacker must either determine the 
sequence  numbers  from  the  first  few  packets  of  the  exploit  and  estimate  the  correct 
sequence  and  acknowledgement  numbers  during  runtime  or  make  some  risky 
assumptions ahead of time.   
Creating  a  raw  datagram  and  modifying  the  header  information  requires  additional 
Linux libraries which offer direct access to these data structures.  The ability to forge a 
server response using raw sockets is enabled by using the C programming language.  The 
shellcode  will  generate  a  forged  message  from  one  host  to  another.    The  source  and 
destination address including port numbers are dynamic along with the forged message.  
This  particular  example  generates  a  shellcode  of  over  900  bytes;  however,  the  length 
could  be  shortened  drastically  if  it  were  implemented  in  assembly  language  and 
optimized. 
Alert Verification Evasion Through Server Response Forging 
269 
The  raw  socket  method  of  forging  a  server  response  has  advantages  and 
disadvantages.  One benefit is that it does not require a currently established network 
connection.  This shellcode does not require a connection to be open, but it may be 
difficult  to  calculate  the  sequence  number,  and  it  may  appear  strange  that  a  server 
response  was  sent  after  the  connection  was  closed.    The  raw  socket  creation  also 
allows  the  modification  of  TCP  header  information.    This  is  quite  useful  when  the 
server  response  is  a  TCP  packet  with  the  RST  flag.    The  primary  drawback  of  this 
method  is  the  overall  size  of  the  payload.    The  extra  function  calls  and  header 
modification increase the total shellcode length, which can be extremely burdensome 
if  more  than  one  packet  is  required  to  forge  the  server  response.    In  the  end,  this 
approach has its advantages but the increased size might be too much of a hindrance, 
especially with buffer overflow exploits that have limited space for the overflow. 
Findport.  The  second  method  for  forging  a  server  response  reuses  a  previously 
existing socket.  Reusing a socket means that the shellcode saves time and space by 
not  creating  one.    While  some  exploits  cause  a  network  connection  to  close 
immediately, other exploits cause the connection to remain open until the  shellcode 
has  executed.    With  the  exploit  leaving  the  current  network  connection  open,  the 
shellcode should be able to find this open socket file descriptor and reuse it to send 
back information to the client machine.   
The  findsock  shellcode  locates  the  current  connection  by  looping  through  all  the 
socket file descriptors and analyzing the peer associated with each socket by calling 
getpeername().  Each socket has an associated peer which is represented as an address 
structure.  This structure contains the IP address along with the port number.  In this 
instance,  the  shellcode  examines  each  peer  and  compares  the  port  associated  with 
each address to a hardcoded port determined by the attacker ahead of time.   
The shellcode uses an interrupt to access the system call table instead of  making 
function  calls  which  require  libraries  to  be  included.    The  code  increments  through 
each socket, compares the port number in each address structure to the hardcoded port 
of the attacker, and finally returns the corresponding socket file descriptor to be used 
later when forging the response.     
The  message  string  is  created  by  using  a  calling  scheme  which  pushes  the  next 
address onto the stack.  Usually this is the address of the next instruction, but in this 
case it is the address of the forged message string.  Next, the function parameters of 
send  are  pushed  onto  the  stack  and  then  the  stack  pointer  is  moved  to  the  third 
parameter  to  the  system  call  table  interrupt.    Again,  the  shellcode  uses  interrupts 
instead of library function calls to send the packet.  The final step pushes the index 
corresponding to a socket call and then causes an interrupt to trigger the system call 
table. 
This  technique  was  implemented  using  assembly  language  as  this  allows  for  the 
highest degree of optimization.  The final shellcode has a payload of 54 bytes plus the 
length of the forged message.  However, a payload must be encoded before it is used 
in an exploit.  This process adds additional bytes causing a payload forging a message 
of  8  bytes  to  be  86  bytes  instead  of  the  original  size  of  62  bytes.    The  byte  code 
generated  from  the  original  shellcode  was  converted  into  a  new  payload  for  the 
Metasploit framework. 
270 
A.D. Todd et al. 
The  findport  technique  for  forging  is  fairly  simple  and  has  a  relatively  small 
payload  size.    It  reuses  an  existing  network  connection  which  may  allow  it  to  pass 
through  firewalls  unnoticed.    Firewalls  can  be  triggered  when  new  outbound 