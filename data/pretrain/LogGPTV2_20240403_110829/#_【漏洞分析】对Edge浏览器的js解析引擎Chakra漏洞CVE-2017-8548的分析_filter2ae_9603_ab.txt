，当发现要设置的值不属于NativeFloatArray应该储存的范畴时，会进行转化，如下所示
    TypeId JavascriptNativeFloatArray::TrySetNativeFloatArrayItem(Var value, double *dValue)
    {
        if (TaggedInt::Is(value))
        {
            *dValue = (double)TaggedInt::ToInt32(value);
            return TypeIds_NativeFloatArray;
        }
        else if (JavascriptNumber::Is_NoTaggedIntCheck(value))
        {
            *dValue = JavascriptNumber::GetValue(value);
            return TypeIds_NativeFloatArray;
        }
        JavascriptNativeFloatArray::ToVarArray(this); // *)seg)->elements[i];
    if (JavascriptNumber::TryGetInt32Value(dval, &ival) && !TaggedInt::IsOverflow(ival))
    {
        newSeg->elements[i] = TaggedInt::ToVarUnchecked(ival);
    }
    else
    {
        newSeg->elements[i] = JavascriptNumber::ToVarWithCheck(dval, scriptContext);
    }
    ...
    //设置新的Type Object
    fArray->GetType()->SetTypeId(TypeIds_Array);
    ...
    //更改虚表
    Assert(VirtualTableInfo::HasVirtualTable(fArray));
    VirtualTableInfo::SetVirtualTable(fArray);
    ...
在进行转化前，Array内存如下
    0x000001CA96B00660  00007ffd6f13f150  P?.o?...
    0x000001CA96B00668  000001ca96ad9140  @????...
    0x000001CA96B00670  0000000000000000  ........
    0x000001CA96B00678  0000000000010005  ........
    0x000001CA96B00680  0000000000000001  ........
    0x000001CA96B00688  000001ca96b006a0  ?.???...
    0x000001CA96B00690  000001ca96b006a0  ?.???...
    0x000001CA96B00698  000001c295048930  0?.??...
    0x000001CA96B006A0  0000000100000000  ........
    0x000001CA96B006A8  0000000000000001  ........
    0x000001CA96B006B0  0000000000000000  ........
    0x000001CA96B006B8  0000000000001234  4.......
可以看到0x000001CA96B00660为NativeFloatArray虚表，0x00001ca96ad9140是指向Type对象的指针，0x00001ca96b006a0为segement指针，segment的size和length皆为1。
在进行转化之后内存的内容变化如下：
    0x000001CA96B00660  00007ffd6f13e1d8  ??.o?...
    0x000001CA96B00668  000001ca96ad8fc0  ?????...
    0x000001CA96B00670  0000000000000000  ........
    0x000001CA96B00678  0000000000010005  ........
    0x000001CA96B00680  0000000000000001  ........
    0x000001CA96B00688  000001ca96b006a0  ?.???...
    0x000001CA96B00690  000001ca96b006a0  ?.???...
    0x000001CA96B00698  0000000000000000  ........
    0x000001CA96B006A0  0000000100000000  ........
    0x000001CA96B006A8  0000000000000001  ........
    0x000001CA96B006B0  0000000000000000  ........
    0x000001CA96B006B8  000001ca96b753e0  ?S???...
可以看到vtable、TypeId、element[0]都发生了改变，其中vtable是从
**JavascriptNativeFloatArray::vtable** 变成了 **JavascriptArray::vtable**
。对象的类型也从JavascriptNativeFloatArray变成JavascriptArray。
原来的Type对象如下所示，0x1f是原来的id值，对应的宏定义是 **TypeIds_NativeFloatArray**
    0x0000026AFD659140  000000000000001f  ........
    0x0000026AFD659148  0000026afd668000  .€f?j...
    0x0000026AFD659150  0000026afd67c000  .?g?j...
    0x0000026AFD659158  00007ffd6e97d480  €??n?...
    0x0000026AFD659160  0000000000000000  ........
    0x0000026AFD659168  0000026afd659100  .?e?j...
    0x0000026AFD659170  0000000000000101  ........
    0x0000026AFD659178  0000000000000000  ........
    0x0000026AFD659180  00007ffd6f2ee9d0  ??.o?...
    0x0000026AFD659188  0000000000001d11  ........
    0x0000026AFD659190  0000000000000001  ........
    0x0000026AFD659198  0000026afd674000  ........
新的Type对象如下所示，0x1f是新的id值，对应的宏定义是TypeIds_Array
    0x0000026AFD658FC0  000000000000001c  ........
    0x0000026AFD658FC8  0000026afd668000  .€f?j...
    0x0000026AFD658FD0  0000026afd67c000  .?g?j...
    0x0000026AFD658FD8  00007ffd6e97d480  €??n?...
    0x0000026AFD658FE0  0000000000000000  ........
    0x0000026AFD658FE8  0000026afd658f80  €?e?j...
    0x0000026AFD658FF0  0000000000000101  ........
    0x0000026AFD658FF8  0000000000000000  ........
    0x0000026AFD659000  00007ffd6f2ee9d0  ??.o?...
    0x0000026AFD659008  0000000000001d11  ........
    0x0000026AFD659010  0000000000000001  ........
    0x0000026AFD659018  0000026afd674000  .@g?j...
**漏洞成因**
我们回过头再来看一下JIT代码，其实可以分为三段。
    function func(a, b, c) {
    a[0] = 2.3023e-320; //