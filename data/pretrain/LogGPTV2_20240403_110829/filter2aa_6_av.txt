如果替换了prototype指向的对象，你应该手动把正确的值赋值给constructor：
注意，JavaScript中并没有什么重要的东西依赖于constructor属性，但设置该属性是一种良好的风格习惯，因为这样本节涉及的技术才得以实现。
17.10.4 instanceof运算符
instanceof运算符：
判断value是由构造函数Constr还是子构造函数（subconstructor）创建的。所以它是检测Constr.prototype是否在value的原型链上。因此，下面的两个表达式是等价的：
下面有一些例子：
正如所料，instanceof对基本类型的值总是false：
最后，如果instanceof的右边不是函数，它会抛出异常：
缺陷：对象不是Object的实例
几乎所有的对象都是Object的实例，因为Object.prototype在这些对象的原型链上。但也有对象不属于这种情况。下面有两个例子：
前面的对象在17.16.4“字典模式：没有原型的对象更适合用作映射”中有更详细的解释。后面的对象是大多数原型链的末端（原型链必须在某个地方结束）。下面是没有原型的对象：
但typeof可以正确地把这些对象归类为对象：
这个缺陷并不会引起大多数instanceof用例产生这个问题，但你需要注意。
缺陷：跨域（帧或窗口）
在Web浏览器中，每一个帧和窗口都拥有自己的域，具有独立的全局变量。这使得instanceof不可用于这些跨域的对象。想知道为什么，来看下面的代码：
如果myvar是来自另一个域的数组，那么它的原型是那个域的Array.prototype。因此，instanceof不会在myvar的原型链上找到当前域的Array.prototype，会返回false。ECMAScript 5的函数Array.isArray()，可以解决这个问题：
很明显，非内建的构造函数也存在这个问题。
除了使用Array.isArray()，还有其他几种方式可以解决这个问题。
避免对象跨域。浏览器有postMessage()方法（http://mzl.la/1fwmNrL），它可以把对象复制到另一领域，而不是传递引用。
检测实例构造函数的名字（只对支持函数name属性的引擎起作用）。
使用prototype属性标记实例属于的类型T。有几种方式可以这样做。检测value是否是T的实例如下。
value.isT()：T的实例原型必须从该方法返回true；普通父构造函数应该返回默认值false。
'T' in value：应该用键为'T'（或更特别的键）的属性标记T实例的原型。
value.TYPE_NAME === 'T'：每个相关的原型必须具有TYPE_NAME属性和对应的值。
17.10.5 实现构造函数的小技巧
本节会介绍一些实现构造函数的小技巧。
防止遗漏new：严格模式
如果你在使用构造函数时忘记了new，那么该函数会作为一个普通函数调用，而不是构造函数。在宽松模式下，你不会得到实例而是创建了全局变量。不幸的是，发生这一切并不会有任何警告：
在严格模式下，你会得到一个异常：
从构造函数返回任意对象
在大多数面向对象语言中，构造函数只能产生直接实例。例如Java，假设你想实现Expression类，它有子类Addition和Multiplication。解析产生后面两个类的直接实例。你不能通过Expression的构造函数来实现，因为该构造函数只能产生Expression的直接实例。可在Java中使用静态工厂方法作为解决方案：
在JavaScript中，你可以简单地从构造函数中返回任何需要的对象。因此，前面代码的JavaScript版看起来如下：
这是个好消息：你可以随时改变想法，构造函数是返回一个直接实例还是其他对象，JavaScript对此没有限制。
17.11 原型属性中的数据
本节介绍了在大多数情况下，你不应该把数据放在原型属性中。然而，这个规则有一些例外。
17.11.1 对于实例属性，避免使用带初始值的原型属性
原型包含的属性共享于多个对象。因此，这适用于方法。此外，接下来会介绍一种方法，你也可以使用这个方法为实例属性提供初始化值。我稍后会解释为什么不推荐这么做。
构造函数通常为实例属性设置初始化值。如果其中一个值为默认的，那么你不需要创建一个实例属性。你只需要具有相同键的带有默认值的原型属性即可。例如：
参数data是可选的。如果缺少参数，实例没有获得属性data，而是继承Names.prototype.data。
这种方法在大多数情况下会正常执行：你可以创建Names的实例n。获取n.data时会读取Names.prototype.data。设置n.data会在n中创建一个新的自有属性，且在原型中保留共享的默认值。只有在我们改变默认值（不是用新的值替换）时，会产生一个问题：
在上面的例子中，push()改变了Names.prototype.data的数组。因为这个数组被所有的没有自有属性data的实例共享，所以n2.data的初始值发生了改变。
最佳实践：不应共享默认值
我们刚刚讨论过，最好不要共享默认值，而应该总是创建一个新值：
显然，如果共享的默认值是不可变的（所有的基本类型都是，详见8.2.1“原始值”），那么改变共享的默认值的问题不会发生。但为了一致性，最好坚持一种单独设置属性的方式。我也推荐保持通常的关注点分离（详见17.10“第3层：构造函数——实例工厂”）：构造函数设置实例属性，而原型包含方法。
ECMAScript 6将会把这些作为最佳实践，因为构造函数参数可以有默认值，而且你可以通过类来定义原型方法，但不能给原型属性设置数据。
根据需要创建实例属性
有时候，创建一个属性值的操作（计算或智能存储）代价高昂。在这种情况下，你可以根据需要创建实例属性。
我们不能通过赋值为实例添加属性data，因为JavaScript会提示缺少setter（只找到getter时会提示）。因此，我们需要通过Object.defineProperty()添加属性。查看17.8.5“属性：定义与赋值”来回顾定义和赋值的区别。在行（1）中，我们确保属性constructor设置正确（详见17.10.3“实例的constructor属性”）。
显然，这样做的工作量有点多，因此你必须确保这样做是值得的。
17.11.2 避免非多态的原型属性
如果相同的属性（相同的键、相同语义，通常有不同的值），在几个原型中同时存在，称为多态（polymorphic）。那么通过实例读取属性的结果是由实例原型动态决定的。原型属性不用于多态情况时，可以替换为变量（这可以更好地反映非多态性）。
例如，你可以在原型属性中存储一个常量，并通过this访问：
这个常量不是多态的。因此你也可以通过变量访问：
17.11.3 多态的原型属性
下面是一个用不可变数据设置多态原型属性的例子。通过原型属性标记的构造函数实例，你可以区分不同构造函数生成的实例。
由于多态的TYPE_NAME“标签”，你甚至在实例与构造函数跨域（instanceof不能正常工作；详见17.10.4小节的“缺陷：跨域（框架或窗口）”）时，也可以分辨ConstrA和ConstrB的实例。
17.12 保持数据私有性
JavaScript没有专门的方式来管理对象的私有数据。本节将介绍3种技术来突破这种局限：
构造函数环境中的私有数据；
带有特殊标记键的属性中的私有数据；
具体化键的属性中的私有数据。
此外，我会介绍如何通过IIFE保持全局数据私有。
17.12.1 构造函数环境中的私有数据（Crockford私有模式）
在调用构造函数时，创建了两个东西：构造函数实例和环境（详见16.9“环境：变量的管理”）。该实例由构造函数初始化，而该环境保持了构造函数的参数和局部变量。每个在构造函数内部创建的函数（包括方法）都会保存此环境（创建函数时的环境）的引用。由于保存了此环境的引用，即使在构造函数执行结束后，也仍然可以访问这个环境。这种函数和环境的结合称为闭包（16.10“闭包：使得函数可以维持其创建时所在的作用域”）。构造函数的环境是独立于实例的数据存储，且与实例关联只因为这两个是同时创建的。为了正确连接实例和环境，我们必须使函数在这两个范围中都可用。使用Douglas Crockford的技术（http://www.crockford.com/javascript/private.html），实例可以有三种值与之关联（详见图17.4）。
图17.4 在调用构造函数Constr时，创建了两个数据结构：一个保存参数与局部变量的环境和一个被初始化的实例
（1）公有属性
存储在属性中的值（实例或它的原型）是可以公共访问的。
（2）私有值
存储在环境中的数据和函数是私有的——只有构造函数和构造函数创建的函数可以访问。
（3）特权方法
私有函数可以访问公有属性，但原型中的公有方法不能访问私有数据。因此我们需要特权方法——实例中的共有方法。特权方法是公有的，且可以被任何实例调用，而这种方法也可以访问私有值，因为它们是在构造函数中创建的。
下一节会更详细地介绍各种不同的值。
公有属性
记住，给定的构造函数Constr有两种属性是公有的，任何人都可以访问。首先，原型属性存储在Constr.prototype中并被所有实例共享。原型属性是通常的方法：
其次，实例属性是每个实例所独有的。这些属性通常在构造函数中添加并保存数据（不是方法）：
私有值
构造函数的环境由参数和局部变量组成。它们只能从构造函数内部访问，因此被实例所私有：
特权方法
私有数据十分安全不能从外部访问，以至于原型方法也不能访问。但是不用constructor该如何访问呢？答案是特权方法：函数在构造函数内部创建，并被添加作为实例的方法。这意味着，一方面，这种函数可以访问私有数据，另一方面，它是公有的且因此对原型方法可见。换句话说，它充当私有和公有数据（包括原型方法）的中介：
示例
下面是使用Crockford私有模式实现的StringBuilder：
下面是执行结果：
Crockford私有模式的利弊
在使用Crockford私有模式时，有几点需要考虑：
（1）它不是很优雅
中介通过特权方法访问私有数据引入了不必要的间接方法。特权方法和私有函数破坏了构造函数（设置实例数据）和实例原型（方法）之间的关注点的分离。
（2）它是完全安全的
一方面，没有方法可以从外部访问内部环境数据，如果你需要这么做，这个方案很安全（例如，针对强调安全的代码）。另一方面，私有数据无法被外部访问也是一种不便。有时你想要单元测试私有功能。而一些临时快速修复取决于访问私有数据的能力。这种快速修复无法预测，因此不管你的设计有多好，都可能出现这种需求。
（3）它可能比较慢
在现有的JavaScript引擎中访问原型链上的属性都已高度优化过。访问闭包中的值可能会慢一些。但这些都在不断变化，所以你必须权衡这些是否会真正影响你的代码。
（4）它会消耗更多的内存
保存周围环境和在实例中添加特权方法需要消耗内存。那么你需要再一次确认和权衡这是否会真正影响你的代码。
17.12.2 使用标记的键的属性保存私有数据
对于大多数不强调安全的应用程序，私有数据更像是对使用API的客户的一种暗示：“你不需要看到这个”。这是封装的关键益处——隐藏复杂性。尽管更多的情况是，你只需要了解API的公共部分。命名约定的目的是让客户知道带有标记的键的属性是私有的。下划线前缀通常用于这一目的。
让我们来重写前面StringBuilder的例子，以便把buffer保存在属性_buffer中，_buffer只是按照约定是私有的：
通过带有标记的属性键实现私有性有一些利弊：
（1）它提供了更自然的编码风格
能够用相同的方式访问私有和公有数据，比使用私有环境更优雅。
（2）它污染了属性的命名空间
标记键的属性随处可见。越多的人使用IDE，就会变得越麻烦。这些属性和公有属性显示在一起，而它们本应该被隐藏的。理论上，IDE可以通过识别命名约定和隐藏私有属性来解决这个问题。
（3）可以从“外部”访问私有属性
这对单元测试和快速修复十分有用。此外，子构造函数和辅助函数（所谓的“友元函数”）可以得益于更快地访问私有数据。而私有环境的方案不能提供这种灵活性，只能从构造函数内部访问私有数据。
（4）它会导致键的冲突
私有属性的键可能会产生冲突。这也是子构造函数的一个问题，但如果你使用多重继承（一些类库中可以），这个问题会更严重。而使用私有环境的方案，绝不会有任何冲突。
17.12.3 使用具体化键的属性保存私有数据
私有属性命名约定的一个问题是可能导致属性键冲突（例如，构造函数中的键和子构造函数中的键，或来自mixin的键和来自构造函数的键）。你可以使用较长的键避免冲突，例如，包含构造函数的名字。那么，在前面的情况中，私有属性_buffer将称为_StringBuilder_buffer。如果这种键对你来说太长，那么可以选择把键具体化，存储在变量中：
我们现在可以通过this[KEY_BUFFER]访问私有数据：
我们用IIFE包装了StringBuilder，因此常量KEY_BUFFER保存在本地，并不会污染全局命名空间。
具体化属性的键可以使用UUID（全局唯一标识符）。例如，使用Robert Kieffer的node-uuid（https://github.com/broofa/node-uuid）：
每次代码运行时KEY_BUFFER的值都不同。例如，它可能看起来如下：
使用UUID的长键几乎不可能产生冲突。
17.12.4 通过IIFE保持全局数据私有
本小节阐述了如何通过IIFE对单例对象、构造函数和方法保持全局数据私有（详见16.6“通过IIFE引入新的作用域”）。这些IIFE创建了新的环境（参考16.9“环境：变量的管理”），用来保存私有数据。
把私有全局数据存储于一个单例对象
在一个环境中，你不需要使用构造函数来整合对象的私有数据。下面的例子出于同样的目的，展示了如何使用IIFE包装一个单例对象：
保持全局数据对所有构造函数私有
一些全局数据只与构造函数和原型方法有关。通过IIFE包装这些数据，可以把它们从公共视线中隐藏。17.12.3“使用具体化键的属性保存私有数据”提供了一个例子：构造函数StringBuilder和它的原型方法使用包含了一个属性键的常量KEY_BUFFER。该常量存储在IIFE的环境中：
请注意，如果你正在使用模块系统（详见第31章），你可以在模块中，通过给构造函数增加方法，用更简洁的代码达到同样的效果。
把全局数据放在一个方法中
有时，你只需要一个单独方法获取全局数据。可以把数据放在IIFE包装该方法的环境中来保持私有。
下面是运行结果：
17.13 第4层：构造函数之间的继承
本节中，我们将研究如何继承构造函数：给定构造函数Super，我们如何编写新的构造函数Sub，它除了拥有Super的所有特性，还增加了一些自己的特性。遗憾的是，JavaScript没有内建机制实现这种功能。因此，我们必须手动完成这些工作。
图17.5展示了这个思路。子构造函数Sub除了拥有自己的属性，还应该具有Super的所有属性（包括原型属性和实例属性）。因此，我们已经对Sub的样子有了粗略的想法，但还不知道如何实现。有几点事情我需要指出，接下来会进行说明。
继承实例属性。
继承原型属性。
确保instanceof正常工作：如果sub是Sub的一个实例，我们也希望sub instanceof Super的结果是true。
在Sub中通过覆写方法来修改Super的方法。
调用super：如果覆写了Super的某个方法，我们可能需要从Sub中调用它的原始方法。
图17.5 Sub继承Super：Sub除了有它自己的属性外，还应该具有Super的所有原型属性和实例属性。注意，methodB覆盖了Super的methodB
17.13.1 继承实例属性
实例的属性是在它自己的构造函数中设置的，因此继承父构造函数的实例属性会涉及调用其父构造函数：
通过new调用Sub时，它的隐式参数this指向一个新的实例。它首先把该实例传给Super（1），Super添加自己的实例属性。之后，Sub设置它自己的实例属性（2，3）。该技巧是，不要通过new调用Super，因为这样会创建一个新的Super实例。相反，我们把Super作为普通函数调用，并传递当前（sub）实例作为this的值。
17.13.2 继承原型属性
共享的属性，例如方法会保存在实例的原型中。因此，我们需要为Sub.prototype找到一种方法来继承Super.prototype的所有属性。而这个解决方法是指定Sub.prototype的原型为Super.prototype。
提示：
 对这两种原型有困惑？
确实，这里使用的JavaScript术语令人困惑。如果你感觉迷惑，请参考17.10.2“术语：两个原型”，其中解释了它们的不同。
下面是实现代码：
Object.create()生成了一个新的对象，它的原型是Super.prototype。然后，我们给Sub添加方法。详见17.10.3“实例的constructor属性”，我们还需要设置constructor属性，因为替换了原有实例原型的正确值。
图17.6展示了Sub和Super现在的关系。我之前描述的Sub的结构类似于图17.5。图中没有显示实例属性，这些属性通过图中的函数调用设置。
图17.6 通过调用构造函数Super并把Sub.prototype设置为Super.prototype的原型对象，构造函数Sub继承了构造函数Super
17.13.3 确保instanceof正常工作
“确保instanceof正常工作”意味着每个Sub的实例必须也是Super的实例。图17.7显示了Sub的一个实例subInstance的原型链，看起来：它的第一个原型是Sub.prototype，第二个原型是Super.prototype。
让我们从简单的问题开始：subInstance是否是Sub？是的。因为下面的两个断言是等价的（后者可以认为是前者的定义）：
图17.7 subInstance由构造函数Sub创建。它有两个原型Sub.prototype和Super.prototype
如前所述，Sub.prototype是subInstance的原型之一，因此两个断言都是正确的。同样， subInstance也是Super的实例，因为下面的两个断言成立：
17.13.4 覆写方法
我们通过添加Sub.prototype.methodB的同名方法，可以覆写Super.prototype的方法，图17.7中是一个例子，我们可以看到它是如何工作的：methodB的查找从subInstance开始，并在Super. prototype.methodB前查找到Sub.prototype.methodB。
17.13.5 父调用
为了理解父调用，你需要了解术语“主对象”（home object）。一个方法的主对象是一个对象，它具有一个属性且该属性的值指向这个方法。例如，Sub.prototype.methodB的主对象是Sub.prototype。父调用foo方法包括三个步骤。
（1）从（原型中的）当前方法中的主对象“之后”，开始查找。
（2）查找名为foo的方法。
（3）用当前的this调用此方法。基本原理是，父方法（supermethod）必须作为当前方法使用同一实例调用；父方法必须可以访问同一实例的属性。
因此，子方法的代码看起来如下。它执行父调用，调用被覆盖的方法。
在行（1）中访问父调用的一种方法如下：直接引用父方法并通过当前this调用。然而，如果我们把它分成三个部分，会发现上述的步骤。