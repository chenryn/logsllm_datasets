# 21 \| 开放封闭原则：不改代码怎么写新功能？你好！我是郑晔。上一讲，我们讲了一个最基础的设计原则：单一职责原则，从这个原则中，你知道了一个模块只应该包含来自同一个变化来源的内容。这一讲，我们来看下一个设计原则：开放封闭原则。作为一名程序员，来了一个需求就要改一次代码，这种方式我们已经见怪不怪了，甚至已经变成了一种下意识的反应。修改也很容易，只要我们按照之前的惯例如法炮制就好了。这是一种不费脑子的做法，却伴随着长期的伤害。每人每次都只改了一点点，但是，经过长期积累，再来一个新的需求，改动量就要很大了。而在这个过程中，每个人都很无辜，因为每个人都只是遵照惯例在修改。但结果是，所有人都受到了伤害，代码越来越难以维护。既然"修改"会带来这么多问题，那我们可以不修改吗？开放封闭原则就提供了这样的一个新方向。不修改代码开放封闭原则是这样表述的：>  > 软件实体（类、模块、函数）应该对扩展开放，对修改封闭。> > >这个说法是 Bertrand Meyer在其著作《面向对象软件构造》（Object-Oriented SoftwareConstruction）中提出来的，它给软件设计提出了一个极高的要求：不修改代码。或许你想问，不修改代码，那我怎么实现新的需求呢？答案就是**靠扩展**。用更通俗的话来解释，就是新需求应该用新代码实现。开放封闭原则向我们描述的是一个结果，就是我们可以不修改代码而仅凭扩展就完成新功能。但是，这个结果的前提是要在软件内部留好扩展点，而这正是需要我们去设计的地方。因为**每一个扩展点都是一个需要设计的模型。**举个例子，假如我们正在开发一个酒店预订系统，针对不同的用户，我们需要计算出不同的房价。比如，普通用户是全价，金卡是8 折，银卡是 9折，代码写出来可能是这样的：    class HotelService {      public double getRoomPrice(final User user, final Room room) {        double price = room.getPrice();        if (user.getLevel() == Level.GOLD) {          return price * 0.8;        }                if (user.getLevel() == Level.SILVER) {          return price * 0.9;        }                return price;      }    }这时，新的需求来了，要增加白金卡会员，给出 75折的优惠，如法炮制的写法应该是这样的：    class HotelService {      public double getRoomPrice(final User user, final Room room) {        double price = room.getPrice();        if (user.getLevel() == UserLevel.GOLD) {          return price * 0.8;        }                if (user.getLevel() == UserLevel.SILVER) {          return price * 0.9;        }                if (user.getLevel() == UserLevel.PLATINUM) {          return price * 0.75;        }                return price;      }    }显然，这种做法就是修改代码的做法，每增加一个新的类型就要修改一次代码。但是，一个有各种级别用户的酒店系统肯定不只是房价有区别，提供的服务也可能有区别。可想而知，每增加一个用户级别，我们要改的代码就漫山遍野。那应该怎么办呢？我们应该考虑如何把它设计成一个可以扩展的模型。在这个例子里面，既然每次要增加的是用户级别，而且各种服务的差异都体现在用户级别上，我们就需要一个用户级别的模型。在前面的代码里，用户级别只是一个简单的枚举，我们可以给它丰富一下：    interface UserLevel {      double getRoomPrice(Room room);    }    class GoldUserLevel implements UserLevel {      public double getRoomPrice(final Room room) {        return room.getPrice() * 0.8;      }    }    class SilverUserLevel implements UserLevel {      public double getRoomPrice(final Room room) {        return room.getPrice() * 0.9;      }    }我们原来的代码就可以变成这样：    class HotelService {      public double getRoomPrice(final User user, final Room room) {        return user.getRoomPrice(room);      }    }    class User {      private UserLevel level;      ...            public double getRoomPrice(final Room room) {        return level.getRoomPrice(room);      }    }这样一来，再增加白金用户，我们只要写一个新的类就好了：    class PlatinumUserLevel implements UserLevel {      public double getRoomPrice(final Room room) {        return room.getPrice() * 0.75;      }之所以我们可以这么做，是因为我们在代码里留好了扩展点：UserLevel。在这里，我们把原来的只支持枚举值的UserLevel 升级成了一个有行为的UserLevel。 经过这番改造，HotelService 的 getRoomPrice这个方法就稳定了下来，我们就不需要根据用户级别不断地调整这个方法了。至此，我们就拥有了一个稳定的构造块，可以在后期的工作中把它当做一个稳定的模块来使用。当然，在这个例子里，这个方法是比较简单的。而在实际的项目中，业务方法都会比较复杂。构建扩展点好，现在我们已经对开放封闭原则有了一个基本的认识。其实，我们都知道修改是不好的，道理我们都懂，就是在**代码层面**，有人就糊涂了。我做个类比你就知道了，比如说，如果我问你，你正在开发的系统有问题吗？相信大部人的答案都是有。那我又问你，那你会经常性主动调整它吗？大部人都不会。为什么呢？因为它在线上运行得好好的，万一我调整它，调整坏了怎么办。是啊！你看，道理就是这么个道理，放在系统层面人人都懂，而在代码层面，却总是习惯性被忽视。所以，我们写软件就应该提供一个又一个稳定的小模块，然后，将它们组合起来。一个经常变动的模块必然是不稳定的，用它去构造更大的模块，就是将隐患深埋其中。你可能会说，嗯，我懂了，可我还是做不好啊！为什么我们懂了道理后，依旧过不好"这一关"呢？因为**阻碍程序员们构造出稳定模块的障碍，其实是构建模型的能力**。你可以回顾一下前面那段代码，看看让这段代码产生变化的UserLevel 是如何升级成一个有行为的 UserLevel的。 在讲封装的时候，我说过，封装的要点是行为，数据只是实现细节，而很多人习惯性的写法是面向数据的，这也是导致很多人在设计上缺乏扩展性思考的一个重要原因。**构建模型的难点，首先在于分离关注点，这个我们之前说过很多次了，不再赘述，其次在于找到共性**。在多态那一讲，我们说过，要构建起抽象就要找到事物的共同点，有了这个理解，我们看前面的例子应该还算容易理解。而在一个业务处理的过程中，发现共性这件事对很多人来说就已经开始有难度了。我们再来看个例子，下面是一个常见的报表服务，首先我们取出当天的订单，然后生成订单的统计报表，还要把统计结果发送给相关的人等：    class ReportService {      public void process() {        // 获取当天的订单        List orders = fetchDailyOrders();        // 生成统计信息        OrderStatistics statistics = generateOrderStatistics(orders);        // 生成统计报表        generateStatisticsReport(statistics);        // 发送统计邮件        sendStatisticsByMail(statistics);      }    }很多人在日常工作中写出的代码都是与此类似的，但这个流程肯定是比较僵化的。出现一个新需求就需要调整这段代码。我们这就有一个新需求，把统计信息发给另外一个内部系统，这个内部系统可以把统计信息展示出来，供外部合作伙伴查阅。该怎么做呢？我们先分析一下，发送给另一个系统的内容是统计信息，在原有的代码里，前面两步分别是获取源数据和生成统计信息，后面两步分别是，生成报表和将统计信息通过邮件发送出去。也就是说，后两步和即将添加的步骤有一个共同点，都使用了统计信息，这样我们就找到了它们的共性，所以，我们就可以用一个共同的模型去涵盖它们，比如，OrderStatisticsConsumer：    interface OrderStatisticsConsumer {      void consume(OrderStatistics statistics);    }    class StatisticsReporter implements OrderStatisticsConsumer {      public void consume(OrderStatistics statistics) {        generateStatisticsReport(statistics);      }    }    class StatisticsByMailer implements OrderStatisticsConsumer {      public void consume(OrderStatistics statistics) {        sendStatisticsByMail(statistics);      }    }    class ReportService {      private List consumers;            void process() {        // 获取当天的订单        List orders = fetchDailyOrders();        // 生成统计信息        OrderStatistics statistics = generateOrderStatistics(orders);                for (OrderStatisticsConsumer consumer: consumers) {            consumer.consume(statistics);        }      }    }如此一来，我们的新需求也只要添加一个新的类就可以实现了：    class StatisticsSender implements OrderStatisticsConsumer {      public void consume(final OrderStatistics statistics) {        sendStatisticsToOtherSystem(statistics);      }    }你能看出来，在这个例子里，我们第一步做的事情还是分解，就是把一个一个的步骤分开，然后找出步骤之间相似的地方，由此构建出一个新的模型。真实项目里的代码可能比这个代码要复杂，但其实，并不一定是业务逻辑复杂，而是代码本身写得复杂了。所以，我们要先根据上一讲的单一职责原则，将不同需求来源引起的变动拆分到不同的方法里，形成一个又一个的小单元，再来做我们这里的分析。通过这个例子你也可以看出，在真实的项目中，想要达到开放封闭原则的要求并不是一蹴而就的。这里我们只是因为有了需求的变动，才提取出一个OrderStatisticsConsumer。未来可能还会有其他的变动，比如，生成报表的逻辑。到那时，也许我们还会提取出一个新的OrderStatisticsGenerator的接口。但总的来说，我们每做一次这种模型构建，最核心的类就会朝着稳定的方向迈进一步。所以，好的设计都会提供足够的扩展点给新功能去扩展。在《Unix编程艺术》一书中，Unix编程就提倡"提供机制，而不是策略"，这就是开放封闭原则的一种体现。同样的，我们知道很多系统是有插件机制的，比如，很多人使用的 VIM 和Emacs，离我们比较近的还有 Eclipse 和 Visual StudioCode，它们都体现着开放封闭原则。去了解它们的接口，我们就可以看到这个软件给我们提供的各种能力，这也是一种很好的学习方式。开放封闭原则还可以帮助我们改进自己的系统，我们可以通过查看自己的源码控制系统，找出那些最经常变动的文件，它们通常都是没有满足开放封闭原则的，而这可以成为我们改进系统的起点。总结时刻今天，我们讲了开放封闭原则，软件实体应该对扩展开放，对修改封闭。简单地说，就是不要修改代码，新的功能要用新的代码实现。其实，道理大家都懂，但对很多人来说，做到是有难度的，尤其是在代码里留下扩展点，往往是需要有一定设计能力的。而构建模型的难点，首先就在于分离关注点，其次是找到共性。今天我们也讲了在一个真实项目中，怎样逐步地去构建扩展点，让系统稳定下来。很多优秀的软件在设计上都给我们提供了足够的扩展能力，向这些软件的接口学习，我们可以学到更多的东西。如果说单一职责原则主要看的还是封装，开放封闭原则就必须有多态参与其中了。显然，要想提供扩展点，就需要面向接口编程。但是，是不是有了接口，就是好的设计了呢？下一讲，我们来看设计一个接口还需要满足什么样的原则。如果今天的内容你只能记住一件事，那请记住：**设计扩展点，迈向开放封闭原则**。![](Images/58c79b6d90b38f74711274566f126024.png)savepage-src="https://static001.geekbang.org/resource/image/61/4a/611dd0fbcf3c87a3de84b457ac6bf44a.jpg"}思考题最后，我想请你找一个提供了扩展点的开源项目，分析一下它是如何设计这个扩展点的。欢迎在留言区写下你的想法。感谢阅读，如果你觉得这一讲的内容对你有帮助的话，也欢迎把它分享给你的朋友。
# 22 \| Liskov替换原则：用了继承，子类就设计对了吗？你好！我是郑晔。上一讲，我们讲了开放封闭原则，想要让系统符合开放封闭原则，最重要的就是我们要构建起相应的扩展模型，所以，我们要面向接口编程。而大部分的面向接口编程要依赖于继承实现，虽然我们在前面的课程中说过，继承的重要性不如封装和多态，但在大部分面向对象程序设计语言中，继承却是构建一个对象体系的重要组成部分。理论上，在定义了接口之后，我们就可以把继承这个接口的类完美地嵌入到我们设计好的体系之中。然而，用了继承，子类就一定设计对了吗？事情可能并没有这么简单。新的类虽然在语法上声明了一个接口，形成了一个继承关系，但我们要想让这个子类真正地扮演起这个接口的角色，还需要有一个好的继承指导原则。所以，这一讲，我们就来看看可以把继承体系设计好的设计原则：Liskov替换法则。 Liskov 替换原则2008 年，图灵奖授予 BarbaraLiskov，表彰她在程序设计语言和系统设计方法方面的卓越工作。她在设计领域影响最深远的就是以她名字命名的Liskov 替换原则（Liskov substitution principle，简称LSP）。 1988 年，Barbara Liskov在描述如何定义子类型时写下这样一段话：>  > 这里需要如下替换性质：若每个类型 S 的对象 o1，都存在一个类型 T> 的对象 o2，使得在所有针对 T 编程的程序 P 中，用 o1 替换 o2 后，程序 P> 行为保持不变，则 S 是 T> 的子类型。> > >用通俗的讲法来说，意思就是，子类型（subtype）必须能够替换其父类型（basetype）。 这句话看似简单，但是违反这个原则，后果是很严重的，比如，父类型规定接口不能抛出异常，而子类型抛出了异常，就会导致程序运行的失败。虽然很好理解，但你可能会有个疑问，我的子类型不都是继承自父类型，咋就能违反LSP 呢？这个 LSP是不是有点多此一举呢？我们来看个例子，有不少的人经常写出类似下面这样的代码：    void handle(final Handler handler) {      if (handler instanceof ReportHandler) {        // 生成报告        ((ReportHandler)handler).report();        return;      }            if (handler instanceof NotificationHandler) {        // 发送通知        ((NotificationHandler)handler).sendNotification();      }      ...    }根据上一讲的内容，这段代码显然是违反了 OCP的。另外，在这个例子里面，虽然我们定义了一个父类型Handler，但在这段代码的处理中，是通过运行时类型识别（Run-Time TypeIdentification，简称 RTTI），也就是这里的instanceof，知道子类型是什么的，然后去做相应的业务处理。但是，ReportHandler 和 NotificationHandler 虽然都是 Handler的子类，但**它们没有统一的处理接口**，所以，它们之间并不存在一个可以替换的关系，这段代码也是违反LSP的。这里我们就得到了一个经验法则，**如果你发现了任何做运行时类型识别的代码，很有可能已经破坏了LSP**。基于行为的 IS-A如果你去阅读关于 LSP的资料，很有可能会遇到一个有趣的问题，也就是长方形正方形问题。在我们对于几何通常的理解中，正方形是一种特殊的长方形。所以，我们可能会写出这样的代码：    class Rectangle {      private int height;      private int width;            // 设置长度      public void setHeight(int height) {        this.height = height;      }            // 设置宽度      public void setWidth(int width) {        this.width = width;      }            //      public void area() {        return this.height * this.width;      }    }    class Square extends Rectangle {      // 设置边长      public void setSide(int side) {        this.setHeight(side);        this.setWidth(side);    t      }            @Override      public void setHeight(int height) {        this.setSide(height);      }      @Override      public void setWidth(int width) {        this.setSide(width);      }    }这段代码看上去一切都很好，然而，它却是有问题的，因为它在下面这个测试里会失败：    Rectangle rect = new Square();    rect.setHeight(4); // 设置长度    rect.setWidth(5);  // 设置宽度    assertThat(rect.area(), is(20)); // 对结果进行断言如果想保证断言（assert）的正确性，Rectangle 和 Square二者在这里是不能互相替换的。使用 Rectangle的代码必须知道自己使用的到底是 Rectangle 还是Square。 出现这个问题的原因就在于，我们构建模型时，会理所当然地把我们直觉中的模型直接映射到代码模型上。在我们直觉中，正方形确实是一种长方形。在我们设计的这个对象体系中，边长是可以调整的。然而，在几何的体系里面，长方形的边长是不能随意改变的，设置好了就是设置好了。换句话说，两个体系内，"长方形"的行为是不一致的。所以，在这个对象体系中，正方形边长即使可以调整，但正方形也并不是一个长方形，也就是说，它们之间不满足IS-A 关系。 你可能听说过继承要符合 IS-A的关系，也就是说，**如果 A 是 B 的子类，就需要满足 A 是一个 B（A is aB）**。但你有没有想过，凭什么 A 是一个 B呢？判断依据从何而来呢？你应该知道，这种判定显然不能依靠直觉。其实，从前面的分析中，你也能看出一些端倪来，**IS-A的判定是基于行为的**，只有行为相同，才能说是满足 IS-A的关系。 这个道理说起来很简单，但在实际的工作中，我们时常就会走上歧途。我给你举个例子，我要做一个图片制作的网站，创作者可以在上面创作自己的内容，还可以发布自己创作的一些素材在网站上销售。显然，这个网站要提供一个销售的能力，那这个可以销售的素材算不算商品呢？如果站在销售的角度看，它确实是一个商品，我们需要给它定价，需要让它支持后续的购买行为等等。从行为上看，素材也确实是商品，但它又与创作相关，我们需要知道它的作者是谁，需要知道它所应用的不同创作阶段等等，这些行为又与商品完全无关。其实，在我们分析问题的时候，答案就已经呼之欲出了。这里的"素材"就不是一个"素材"，前面讲SRP的时候，我们已经做过类似的分析了，虽然我们在讨论的时候，用的是一个词"素材"，但创作者和销售却是两个不同的领域。所以，如果我们把"素材"做一个拆分，这个问题就迎刃而解了。一个是"创作者素材"，一个是"可销售素材"，显然，"可销售素材"是一种商品，而"创作者素材"不是。这是一种常见的概念混淆。产品经理在描述一个需求时，可能并不会注意到这是两个不同领域的概念，而程序员如果不好好分析一下，在概念上就会走偏，后续的问题将无穷无尽。所以，IS-A这个关系理解起来并不难，但在实际工作中，当它和其他一些问题混在一起的时候，它就不像看起来那么简单了。到这里，你应该对 LSP原则有了一些理解，**要满足LSP，首先这个对象体系要有一个统一的接口，而不能各行其是，其次，子类要满足IS-A 的关系**。有了对 LSP的理解，你再用它去衡量一些设计，就会发现一些问题。比如，程序员们最常用的数据结构List，很多人都习惯地把它当做接口传来传去。在绝大多数场景下，使用它的目的只是为了传递一些数据，也就是为了从中读取数据，但List 接口本身一般都有写的方法。所以，尽管你的目的是读，但还是有人不小心写了，就会导致一些奇怪的问题。Google的 Guava 库提供了一个ImmutableList，在概念上做了改进。但为了配合现有的各种程序，它不得不继承自List接口，实际上，根本的问题并没有得到完全的解决。还有一类常见的违反 LSP的问题，就是继承数据结构。比如，我要实现包含多个学生的类，结果声明成：    class Students extends ArrayList {      ...    }这是一种非常直觉的设计，只要一继承ArrayList，添加、获取的方法就都有了。但从我们前面讲的内容上来看，这显然是不好的，因为Students 不是一个 ArrayList，不能满足 IS-A关系。这种做法想做的就是实现继承，而我们在前面讲继承的时候，就说过这种做法的问题。你会发现，LSP的关注点让人把注意力放到父类上，而一旦子类成了重点，我们必须小心谨慎。在前面讲继承的时候，我们说过，关心子类是一种实现继承的表现，而实现继承是我们要努力摒弃的，接口继承才是我们的努力方向，而做好接口继承，显然会更符合LSP。 更广泛的 LSP如果理解了LSP，你会发现，它不仅适用于类级别的设计，还适用于更广泛的接口设计。比如，我们在开发中经常会遇到系统集成的问题，有不同的厂商都要通过REST接口把他们的统计信息上报到你的系统中，但是，有一个大厂上报的消息格式没法遵循你定义的格式，因为他的系统改动起来难度比较大。你该怎么办呢？也许，专门为大厂设计一个特定接口是最简单的想法，但是，一旦开了这个口子，后面的各种集成接口都要为这个大厂开发一份特殊的，而且，如果未来再有其他大厂也提出要求，你要不要为它们也设计特殊接口呢？事实上，很多项目功能不多，但接口特别多，就是因为在这种决策的时候开了口子。**请记住，公开接口是最宝贵的资源，千万不能随意添加**。如果我们用 LSP的角度看这个问题，通用接口就是一个父类接口，而不同厂商的内容就相当于一个个子类。让厂商面对特定接口，系统将变得无法维护。后期随着人员变动，接口只会更加膨胀，到最后，没有人说清楚每个接口到底是做什么的。好，那我们决定采用统一的接口，可是不同的消息格式该怎么处理呢？首先，我们需要区分出不同的厂商，办法有很多，无论是通过REST 的路径，还是 HTTP头的方式，我们可以得到一个标识符。然后呢？很容易想到的做法就是写出一个 if语句来，像下面这样：    if (identfier.equals("SUPER_VENDOR")) {      ...    }但是，千万要遏制自己写 if的念头，一旦开了这个头，后续的代码也将变得难以维护。我们可以做的是，提供一个解析器的接口，根据标识符找到一个对应的解析器，像下面这样：    RequestParser parser = parsers.get(identifier);    if (parser != null) {      return parser.parse(request);    }这样一来，即便有其他厂商再因为某些奇怪的原因要求有特定的格式，我们要做的只是提供一个新的接口实现。这样一来，所有代码的行为就保持了一致性，核心的代码结构也保持了稳定。**总结时刻**今天，我们讲了 Liskov替换原则，其主要意思是说子类型必须能够替换其父类型。理解 LSP，我们需要站在父类的角度去看，而站在子类的角度，常常是破坏LSP 的做法，一个值得警惕的现象是，代码中出现 RTTI相关的代码。继承需要满足 IS-A 的关系，但 IS-A的关键在于行为上的一致性，而不能单纯凭日常的概念或直觉去理解。LSP不仅仅可以用在类关系的设计上，我们还可以把它用在更广泛的接口设计中。任何接口都是宝贵的，在设计时，都要精心考量。这一讲，你可以看到 LSP的根基在于继承，但显然接口继承才是重点。那我们该如何设计接口呢？我们下一讲来讨论。如果今天的内容你只能记住一件事，那请记住：**用父类的角度去思考，设计行为一致的子类**。![](Images/57017a470fed584c337d0bb141baef15.png)savepage-src="https://static001.geekbang.org/resource/image/bc/00/bcfbb2358f37ae40383fe89bccedb400.jpg"}思考题在今天的内容中，我们提到了长方形正方形问题，我只分析了这个做法有问题的地方，现在我把解决这个问题的机会留给你，请你来动动脑，欢迎在留言区写下你的解决方案。感谢阅读，如果你觉得这一讲的内容对你有帮助的话，也欢迎把它分享给你的朋友。