### 优化后的文本

#### 引用文献
1. **互联网恶意软件**。《近期入侵检测进展研讨会论文集》，2007年9月。
2. **U. Bayer, P. M. Comparetti, C. Hlauschek, C. Kruegel, 和 E. Kirda**。可扩展的行为型恶意软件聚类。《网络与分布式系统安全研讨会论文集》，2009年。
3. **D. Bernstein**。[http://www.cse.yorku.ca/~oz/hash.html](http://www.cse.yorku.ca/~oz/hash.html)。
4. **A. Broder 和 M. Mitzenmacher**。Bloom过滤器在网络应用中的综述。《互联网数学》，第1卷，第4期，2005年，页码485-509。
5. **D. Chakrabarti, S. Papadimitriou, D. Modha, 和 C. Faloutsous**。全自动交叉关联。《ACM SIGKDD会议论文集》，2004年8月。
6. **J. Dean 和 S. Ghemawat**。MapReduce：简化大规模集群上的数据处理。《USENIX操作系统设计与实现研讨会论文集》，2004年。
7. **A. Dinaburg, P. Royal, M. Sharif, 和 W. Lee**。Ether：通过硬件虚拟化扩展进行恶意软件分析。《ACM CCS会议论文集》，2008年。
8. **D. Eppstein**。快速层次聚类及其他动态最近对的应用。《ACM离散算法研讨会论文集 (SODA)**，1998年。
9. **F. Guo, P. Ferrie, 和 T.-C. Chiueh**。关于打包问题及其解决方案的研究。《国际入侵检测最新进展研讨会论文集》，2008年，页码98-115。
10. **X. Hu, T. cker Chiueh, 和 K. G. Shin**。使用函数调用图进行大规模恶意软件索引。《ACM计算机与通信安全会议论文集》，2009年。
11. **N. Jain, M. Dahlin, 和 R. Tewari**。使用Bloom过滤器精炼网页搜索结果。《第八届国际Web和数据库研讨会 (WebDB 2005) 论文集》，2005年6月。
12. **M. Karim, A. Walenstein, A. Lakhotia, 和 L. Parida**。基于代码排列的恶意软件谱系生成。《计算机病毒学杂志》，第1卷，第1期，2005年11月，页码13-23。
13. **G. Karypis**。CLUTO：一个聚类工具包，版本2.1.1。技术报告，明尼苏达大学，2003年。
14. **J. Z. Kolter 和 M. A. Maloof**。在野外学习检测和分类恶意可执行文件。《机器学习研究杂志》，第7卷，2006年12月，页码2721-2744。
15. **P. Li, L. Lu, D. Gao, 和 M. Reiter**。评估恶意软件聚类的挑战。《国际入侵检测最新进展研讨会论文集》，2010年。
16. **L. Martignoni, M. Christodorescu, 和 S. Jha**。OmniUnpack：快速、通用且安全的恶意软件解包。《年度计算机安全应用会议论文集》，2007年。
17. **A. Moser, C. Kruegel, 和 E. Kirda**。探索多条执行路径进行恶意软件分析。《IEEE安全与隐私研讨会论文集》，2007年。
18. **A. Moser, C. Kruegel, 和 E. Kirda**。静态分析在恶意软件检测中的局限性。《年度计算机安全应用会议论文集》，2007年。
19. **S. Papadimitrou 和 J. Sun**。Disco：使用Map-Reduce的分布式共聚类。《ICDM会议论文集》，2008年。
20. **R. Perdisci, A. Lanzi, 和 W. Lee**。准确计算机病毒检测的压缩可执行文件分类。《模式识别字母》，第29卷，第14期，2008年，页码1941-1946。
21. **R. Perdisci, W. Lee, 和 N. Feamster**。基于HTTP的恶意软件行为聚类及签名生成。《NSDI会议论文集》，2010年。
22. **P. Royal, M. Halpin, D. Dagon, R. Edmonds, 和 W. Lee**。PolyUnpack：自动提取解压执行恶意软件的隐藏代码。《计算机安全应用会议论文集》，2006年12月。
23. **S. Schleimer, D. Wilkerson, 和 A. Aiken**。Winnowing：文档指纹识别的局部算法。《ACM SIGMOD/PODS会议论文集》，2003年。
24. **M. Sharif, A. Lanzi, J. Giffin, 和 W. Lee**。自动逆向工程恶意软件模拟器。《IEEE安全与隐私研讨会论文集》，2009年。
25. **Q. Shi, J. Petterson, G. Dror, J. Langford, A. Smola, 和 S. Vishwanathan**。结构化数据的哈希核。《机器学习研究杂志》，2009年。
26. **Q. Shi, J. Petterson, G. Dror, J. Langford, A. Smole, A. Strehl, 和 V. Vishwanathan**。哈希核。《第12届人工智能与统计学国际会议 (AISTATS) 论文集》，2009年。
27. **A. Walenstein 和 A. Lakhotia**。恶意软件分析中的软件相似性问题。《软件复制、冗余与相似性会议论文集》，2007年。
28. **K. Weinberger, A. Dasgupta, J. Langford, A. Smola, 和 J. Attenberg**。用于大规模多任务学习的特征哈希。《ICML会议论文集》，2009年。

### 附录
#### 定理1的证明
我们的分析表明，以高概率，Jaccard指数 \(\frac{|g_i \cap g_j|}{|g_i \cup g_j|}\) 可以很好地近似为 \(\frac{S(f_i \wedge f_j)}{S(f_i \vee f_j)}\)，其中 \(f_i\) 和 \(f_j\) 是 \(g_i\) 和 \(g_j\) 的指纹。在整个分析过程中，我们令 \(c\) 表示集合 \(g_i\) 和 \(g_j\) 之间的共享元素数量；注意Jaccard指数 \(\frac{|g_i \cap g_j|}{|g_i \cup g_j|}\) 等于 \(\frac{c}{2N - c}\)。我们的分析重点是显示比率 \(\frac{S(f_i \wedge f_j)}{S(f_i \vee f_j)}\) 以高概率接近 \(\frac{c}{2N - c}\)（与其他分析 [22] 不同，它们只关注计算 \(S(f_i \wedge f_j)\) 的期望值）。我们假设使用的哈希函数是k独立的。

我们首先考虑并集 \(g_i \cup g_j\)。注意到两个指纹 \(f_i\) 和 \(f_j\) 的按位或运算得到的位向量等价于直接插入所有 \(g_i \cup g_j\) 中的元素所得到的位向量，如果使用相同的k个哈希函数和相同大小的位向量。

令随机变量 \(U\) 表示 \(f_i \vee f_j\) 中设置为1的位数。注意集合 \(g_i \cup g_j\) 包含 \(2N - c\) 个元素。如果这些元素插入到大小为 \(m\) 的位向量中，并使用k个哈希函数，则某一位被设置为1的概率 \(q_u\) 为：\(1 - \left(1 - \frac{1}{m}\right)^{k(2N - c)}\)。我们可以利用这一点来计算 \(U\) 的期望值：
\[ E[U] = m q_u = m \left(1 - \left(1 - \frac{1}{m}\right)^{k(2N - c)}\right) \]
由于 \(U\) 紧密集中在其期望值附近 [15]，我们有：
\[ P(|U - E[U]| \geq \epsilon m) \leq 2 e^{-2 \epsilon^2 m^2 / (2N - c) k} \]

接下来，我们考虑交集 \(g_i \cap g_j\)。令随机变量 \(I\) 表示 \(f_i \wedge f_j\) 中设置为1的位数。一位 \(z\) 在 \(f_i \wedge f_j\) 中被设置为1有两种方式：(1) 它可能由 \(g_i \cap g_j\) 中的某个元素设置；(2) 它可能由 \(g_i - (g_i \cap g_j)\) 和 \(g_j - (g_i \cap g_j)\) 中的某些元素共同设置。令 \(I_z\) 表示 \(f_i \wedge f_j\) 中位 \(z\) 的指示变量。则：
\[ P(I_z = 1) = \left(1 - \left(1 - \frac{1}{m}\right)^{k(|g_i| - c)}\right) \left(1 - \left(1 - \frac{1}{m}\right)^{kc}\right) + \left(1 - \left(1 - \frac{1}{m}\right)^{k(|g_j| - c)}\right) \left(1 - \left(1 - \frac{1}{m}\right)^{kc}\right) \]
这可以简化为：
\[ P(I_z = 1) = 1 - \left(1 - \frac{1}{m}\right)^{kN} - \left(1 - \frac{1}{m}\right)^{kN} + \left(1 - \frac{1}{m}\right)^{k(2N - c)} \]
利用期望的线性性质，我们可以计算 \(E[I]\)：
\[ E[I] = m \left(1 - \left(1 - \frac{1}{m}\right)^{kN} - \left(1 - \frac{1}{m}\right)^{kN} + \left(1 - \frac{1}{m}\right)^{k(2N - c)}\right) \]

注意到随机变量 \(I_1, I_2, \ldots, I_m\) 是负相关的，因此我们可以应用Chernoff-Hoeffding界来计算 \(I\) 显著偏离 \(E[I]\) 的概率：例如，
\[ P(I \geq E[I](1 + \epsilon_2)) \leq e^{-mq \epsilon_2^2 / 3} \]
其中 \(q = 1 - \left(1 - \frac{1}{m}\right)^{kN} - \left(1 - \frac{1}{m}\right)^{kN} + \left(1 - \frac{1}{m}\right)^{k(2N - c)}\)。

我们现在转向比率 \(\frac{S(f_i \wedge f_j)}{S(f_i \vee f_j)}\)；令随机变量 \(Y\) 表示这个比率。我们已经证明 \(U\) 和 \(I\) 都很可能接近它们的期望值，我们可以利用这一点来计算 \(Y\) 的上下界——因为 \(U\) 和 \(I\) 分别以至少 \(1 - 2 e^{-mq \epsilon_2^2 / 3}\) 和 \(1 - 2 e^{-2 \epsilon^2 m^2 / (2N - c) k}\) 的概率保持在它们的期望值的加性或乘性因子内，我们可以推导出 \(Y\) 的上下界，这些界以至少 \(1 - 2 e^{-mq \epsilon_2^2 / 3} - 2 e^{-2 \epsilon^2 m^2 / (2N - c) k}\) 的概率成立。

为此，我们首先简化 \(E[U]\) 和 \(E[I]\)。假设 \(m \gg 2kN\)，我们可以丢弃3和4中的二项式的高阶项来近似 \(E[U]\) 和 \(E[I]\)：
\[ E[U] \approx k(2N - c) \]
\[ E[I] \approx ck \]

利用这些近似值，我们看到 \(Y \leq \frac{c(1 + \epsilon_2)}{2N - c - m \epsilon}\)，以至少 \(1 - e^{-mq \epsilon_2^2 / 3} - 2 e^{-2 \epsilon^2 m^2 / (2N - c) k}\) 的概率成立。

类似地，我们可以计算 \(Y\) 的下界，即 \(Y \geq \frac{c(1 - \epsilon_2)}{2N - c + m \epsilon}\)，以至少 \(1 - e^{-mq \epsilon_2^2 / 3} - 2 e^{-2 \epsilon^2 m^2 / (2N - c) k}\) 的概率成立。因此，对于适当选择的 \(m\) 和 \(k\) 值，比率 \(\frac{S(f_i \wedge f_j)}{S(f_i \vee f_j)}\) 以高概率接近Jaccard指数 \(\frac{c}{2N - c}\)。

最后，我们给出一个例子来说明我们在应用场景中的界限。假设我们设置 \(\epsilon m \geq 5\)，\(m \approx 1000N\)，\(k = 6\)。那么，我们的分析表明，以至少95%的概率，\(Y \in \left[\frac{c(1 - \sqrt{4})}{2N - c - 5}, \frac{c(1 + \sqrt{4})}{2N - c + 5}\right]\)，即设置为1的位数与并集的比例非常接近Jaccard指数。

#### 扩展
**包含关系**。BITSHRED-JACCARD度量特征之间的比例相似性。然而，我们可能还想度量一个特征集是否完全包含在另一个特征集中，例如，判断一个恶意软件是否完全包含在另一个代码中。例如，假设恶意软件A是由两个恶意软件样本B和C组成，且 \(|B| \gg |C|\)。那么A和C之间的相似性将成比例地非常低。在这种情况下，可以使用以下替代相似性度量：
\[ BITSHRED-JACCARD_c(f_a, f_b) = \frac{S(f_a \wedge f_b)}{S(f_b)} \]
当 \(f_i\) 是恶意软件 \(s_i\) 的指纹且 \(|s_a| \gg |s_b|\) 时。