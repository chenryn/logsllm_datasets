.fi
.RE
..
.de UL
\\$1\l'|0\(ul'\\$2
..
.TH expr 3tcl 8.3 Tcl "Tcl Built-In Commands"
.BS
'\" Note:  do not modify the .SH NAME line immediately below!
.SH NAME
expr \- 求一个表达式的值     
.SH "总览 SYNOPSIS"
\fBexpr \fIarg \fR?\fIarg arg ...\fR?
.BE
.SH "描述 DESCRIPTION"
.PP
连接(concatenate)所有 \fIarg\fR (在它们中间添加分隔符空格)，把结果作为一个Tcl 表示式来求值(evaluate)并返回结果。在 Tcl 表达式中允许的操作符式在 C  表达式中允许的操作符的一个子集，并且它们与相应的 C 操作符有相同意义和优先级。表达式几乎总是产生一个数值结果(整数或浮点数的值)。例如，表达式     
.CS
\fBexpr 8.2 + 6\fR
.CE
求值出 14.2.
Tcl 表达式与 C 表达式在操作数指定的方式上有区别。还有，Tcl 表达式支持非数值操作符和字符串比较。       
.SH "操作数 OPERANDS"
.PP
一个 Tcl 表达式由操作符、操作数和括号的组合构成。在操作符、操作数和括号之间可使用白空格；它被表达式的指令所忽略。指定整数值可以使用十进制(通常的情况)、八进制(如果操作数的第一个字符是 \fB0\fR)、或十六进制(如果操作数的前两个字符是 \fB0x\fR)。如果一个操作数没有上述的整数格式，则如果可能的话把它作为浮点数对待。指定浮点数可以使用任何遵从 ANSI 的 C 编译器可接受方式(除了在多数安装(installation)中不允许 \fBf\fR、\fBF\fR、\fBl\fR\fB \fR和 \fBL\fR  后缀)。例如，下列的数都是有效的浮点数: 2.1、3.、6e4、7.91e+16。如果没有可能的数值解释，则一个操作数被作为字符串来保留(并且对它只提供一组有限的操作符)。
.PP
可以用下列方式指定操作数: 
.IP [1]
为一个数值值，要么是整数要么是浮点数。        
.IP [2]
作为一个 Tcl 变量，使用标准的 \fB$\fR 记号。变量的值将被用作操作数。        
.IP [3]
作为用双引号包围起来的一个字符串。表达式分析器将在引号之间的信息上完成反斜杠、变量和命令替换，并把结果值用作操作数。
.IP [4]
作为用花括号包围起来的一个字符串。在左花括号和相匹配的右花括号之间的字符将被用作操作数而不做任何替换。
.IP [5]
作为一个用方括号包围起来的 Tcl 命令。命令将被执行并且它的结果将被用作操作数。   
.IP [6]
作为一个数学函数，它的参数可以是操作数的任何上述形式，比如 \fBsin($x)\fR。参见下面的已定义的函数的一个列表。       
.LP
在上述替换发生的地方(例如在被引用起来的字符串当中)，他们由表达式的指令来完成。但是，在调用表达式处理器之前命令分析器可能已经完成了一个额外的替换层。如下面讨论的那样，通常最好把表达式包围在花括号中来防止命令分析器在这些内容上进行替换。
.PP
举一些简单的表达式的例子，假设变量\fBa\fR  的值是 3 并且变量 \fBb\fR  的值是 6。则下面的每行左边的命令将生成右边的值。
.CS
.ta 6c
\fBexpr 3.1 + $a	6.1
expr 2 + "$a.$b"	5.6
expr 4*[llength "6 2"]	8
expr {{word one} >\fR
左移和右移。只对整数操作数有效。一右移总是传播(propagate)符号位。  
.TP 20
\fB\0\0=\fR
Boolean 小于，大于，小于等于，大于等于。如果条件是真则每个操作符产生 1，否则 0。这些操作符可以象提供给数值操作数一样提供给字符串，在这种情况下使用字符串比较。        
.TP 20
\fB==\0\0!=\fR
Boolean 等于和不等于。每个操作符产生一个零/一结果。对所有操作数类型有效。        
.TP 20
\fB&\fR
位与。只对整数操作数有效。       
.TP 20
\fB^\fR
位异或。只对整数操作数有效。       
.TP 20
\fB|\fR
位或。只对整数操作数有效。       
.TP 20
\fB&&\fR
逻辑与。如果两个操作数都是非零则生成一个 1，否则生成 0。只对 boolean 和数值(整数或浮点数)操作数有效。       
.TP 20
\fB||\fR
逻辑或。如果两个操作数都是零则生成一个 0，否则生成 1。只对 boolean 和数值(整数或浮点数)操作数有效。       
.TP 20
\fIx\fB?\fIy\fB:\fIz\fR
If-then-else，如同 C 语言那样。如果 \fIx\fR 求值为非零，则结果是 \fIy\fR\fI \fR的值。否则结果是 \fIz \fR的值。\fIx\fR操作数必须是一个数值值。    
.LP
参见 C 手册来得到对每个操作符的生成结果的更详细的描述。所有相同的优先级的二元操作符从左至右的组合(group)。例如，命令       
.CS
\fBexpr 4*2  "2"}\fR
\fBexpr {"0y" < "0x12"}\fR
.CE
都返回 1。做第一个比较使用了整数比较，而做第二个比较在把第二个操作数转换成字符串 \fB18\fR之后使用了字符串比较。因为 Tcl 趋向于尽可能的把值作为数值对待，在你事实上想进行字符串比较并且操作符的值可以是任意的的时候使用象 \fB==\fR  这样的操作符通常不是个好主意；在这种情况下最好使用 \fBstring\fR命令。        
.SH "性能的考虑 PERFORMANCE CONSIDERATIONS"
.PP
要得到最快的速度和最小的存储需求，就要把表达式包围在花括号中。这允许 Tcl 字节码编译器生成最好的代码。
.PP
象上面所提及的那样，表达式被替换两次: 一次由 Tcl 解释器，一次由 \fBexpr\fR  命令。例如，命令
.CS
\fBset a 3\fR
\fBset b {$a + 2}\fR
\fBexpr $b*4\fR
.CE
返回 11，而不是 4 的倍数。这是因为 Tcl 分析器将首先把变量 \fBb\fR替换成 \fB$a + 2\fR，接着 \fBexpr\fR  命令将求值表达式 \fB$a + 2*4\fR。
.PP
多数表达式不需要两轮替换。要它们被包围在花括号中，要么它们的变量和命令替换生成数值或本身不需要替换的字符串。但是，因为一些未用化括号包围起来的表达式需要两轮替换，字节码编译器必须散布(emit)额外的指令来处理这些情况。对于未用化括号包围起来的表达式，代价最高昂的代码是包含命令替换的代码。必须通过在每次执行这个表达式时生成新的代码来实现这些表达式。       
.SH "关键字 KEYWORDS"
arithmetic, boolean, compare, expression, fuzzy comparison
.SH "[中文版维护人]"
.B 寒蝉退士
.SH "[中文版最新更新]"
.B 2001/07/22 
.SH "《中国 Linux 论坛 man 手册页翻译计划》:"
.BI http://cmpp.linuxforum.net