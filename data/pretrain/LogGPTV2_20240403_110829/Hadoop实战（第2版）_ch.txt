16 for（String child：children）
17 System.out.println（child）；
18}
19
20 public static void main（String[]args）throws IOException, KeeperException，
InterruptedException{
21 ListMembers lm=new ListMembers（）；
22 lm.createZKInstance（）；
23 lm.list（"/ZKGroup"）；
24}
25}
在执行删除组操作时，我们首先需要删除组目录下的所有成员，当组目录空时，再将组目录删除。那么，这过程中首先就需要调用getChildren（）函数，获取组目录的所有成员，然后调用delete（）函数将其一一删除。最后删除组目录。详见代码清单15-13。
代码清单15-13 DelGroup
1 package cn.edu.ruc.cloudcomputing.book.chapter15；
2
3 import java.io.IOException；
4 import java.util.List；
5
6 import org.apache.zookeeper.KeeperException；
7
8 public class DelGroup extends ZooKeeperInstance{
9 p u b l i c v o i d d e l e t e（S t r i n g g r o u p P a t h）t h r o w s K e e p e r E x c e p t i o n，
InterruptedException{
10 List＜String＞children=zk.getChildren（groupPath, false）；
11//如果不空，则进行删除操作
12 if（！children.isEmpty（））{
13//删除所有子节点
14 for（String child：children）
15 zk.delete（groupPath+"/"+child，-1）；
16}
17//删除组目录节点
18 zk.delete（groupPath，-1）；
19}
20
21 public static void main（String args[]）throws IOException, KeeperException，
InterruptedException{
22 DelGroup dg=new DelGroup（）；
23 dg.createZKInstance（）；
24 dg.delete（"/ZKGroup"）；
25 dg.ZKclose（）；
26}
27}
限于篇幅，本章只介绍了关于Zookeeper的一些基本知识，希望大家通过本章的学习能够对ZooKeeper的机制有一个全面的了解。另外，希望大家能够亲自动手编写Zookeeper程序，这样可以促进对ZooKeeper更深入的了解。
15.8 BooKeeper
BooKeeper具有副本的功能，目的是提供可靠的日志记录。在BooKeeper中，服务器被称为账本（Bookies），在账本之中有不同的账户（Ledgers），每一个账户由一条条的记录（Entry）组成。如果使用普通的磁盘存储日志数据，那么日志数据可能遭到破坏，当磁盘发生故障的时候，日志也可能被丢失。BooKeeper为每一份日志提供了分布式的存储，并且采用了大多数（quorum，相对于全体）的概念，也就是说，只要集群中的大多数机器可用，那么该日志一直有效。
BooKeeper通过客户端进行操作，客户端可以对BooKeeper进行添加账户、打开账户、添加账户记录、读取账户记录等操作。另外，BooKeeper的服务依赖于ZooKeeper，可以说BooKeeper是依赖于ZooKeeper的一致性及分布式的特点在其之上提供了另外一种可靠性服务。如图15-12为BooKeeper的架构。
从上图中可以看出，BooKeeper中总共包含四类角色，分别为：账本（Bookie）、账户（Ledger）、客户端（BooKeeper Client）以及元数据存储服务（Metadata Storage Service）。下面我们来简单介绍这四类角色的功能。
账本（Bookie）：账本是BookKeeper的存储服务器，它存储的是一个个的账本，可以将账本理解为一个节点。在一个BookKeeper系统中存在有多个账本（节点），每个账户被不同的账本所存储。若要写一条记录到指定的账户中，该记录将被写到维护该账户的所有账本节点中。为了提高系统的性能，这条记录并不是真正地被写入到所有节点中，而是选择集群的一个大多数集进行存储。该系统独有的特性使得BookKeeper系统有良好的扩展性。即，我们可以通过简单地添加机器节点的方法提高系统的容量。
图 15-12 BooKeeper架构
账户（Ledger）：账户中存储的是一系列的记录（Entry），每一条记录包含一定的字段。记录通过写操作一次性写入，只能进行附加操作不能进行修改。每条记录包含如下字段，见表15-6。
当满足下列两个条件时，某条记录才被认为是存储成功：
1）之前所记录的数据被账本节点的大多数集所存储；
2）该记录被账本节点的大多数集所存储。
客户端（BookKeeper Client）：客户端通常与BookKeeper应用程序进行交互，它允许应用程序在系统上进行操作，包括创建账户，写账户等。
元数据存储服务（Metadata Storage Service）：元数据信息存储在ZooKeeper集群当中，它存储关于账户和账本的信息，例如，账本由集群中的哪些节点进行维护，账户由哪个账本进行维护等。
应用程序在使用账本的时候，首先需要创建一个账户。在创建账户时，系统首先将该账本的Metadata信息写入到ZooKeeper中。每一个账户在某一时刻只能有一个写实例。在其它实例进行读操作之前首先需要将写实例关闭。如果写操作由于故障而未能正常关闭，那么下一个尝试打开账户的实例将需要首先对其进行恢复并正确关闭写操作。在进行写操作时同时需要将最后一次的写记录存储到ZooKeeper中，因此恢复程序仅需要在ZooKeeper中查看该账户所对应的最后一条写记录，然后将其正确地点写入到账户中，再正确关闭写操作。在BookKeeper中该恢复程序由系统自动执行，不需要用户的参与。
15.9 本章小结
ZooKeeper作为Hadoop项目的一个子项目，是Hadoop集群管理中一个必不可少的模块。它主要用来控制集群中的数据，如管理Hadoop集群中的NameNode，以及Hbase中的Master Election、Server之间的状态同步等。除此之外，它还在其他多种场合中发挥着重要的作用。
本章介绍了ZooKeeper的基本知识，以及ZooKeeper的配置、使用和管理等内容。另外还深入挖掘了ZooKeeper重要功能的实现机制，并介绍了它的某些应用场景。ZooKeeper作为一个用于协调分布式程序的服务，必将在更多的场合发挥越来越重要的作用。
第16章 Avro详解
本章内容
Avro介绍
Avro的C/C++实现
Avro的Java实现
GenAvro（Avro IDL）语言
Avro SASL概述
本章小结
16.1 Avro介绍
Avro作为Hadoop下相对独立的子项目，是一个数据序列化的系统。类似于其他序列化系统，Avro可以将数据结构或对象转化成便于存储或传输的格式，特别是在设计之初它可以用来支持数据密集型应用，适合于大规模数据的存储和交换。总之，Avro可以提供以下一些特性和功能：
丰富的数据结构类型；
快速可压缩的二进制数据形式；
存储持久数据的文件容器；
远程过程调用（RPC）；
简单的动态语言结合功能。
Avro和动态语言结合后，读写数据文件和使用RPC协议都不需要生成代码了，而代码作为一种可选的优化只需要在静态类型语言中实现。
Avro依赖于模式（Schema）。Avro数据的读/写操作很频繁，而这些操作都需要使用模式，这样可减少写入每个数据资料的开销，使得序列化快速而又轻巧。这种数据及其模式的自我描述方便了动态脚本语言的使用。
当Avro数据存储到文件中时，它的模式也随之存储，这样任何程序都可以对文件进行处理。如果读取数据时使用的模式与写入数据时使用的模式不同，那也很容易解决，因为读取和写入的模式都是已知的。图16-1表示的是Avro的主要作用，它将用户定义的模式和具体的数据编码成二进制序列存储在对象容器文件中，假设用户定义了包含学号、姓名、院系和电话的学生模式，那么Avro对其进行编码后存储在student.db文件中，其中存储数据的模式放在文件头的元数据中，这样即使读取的模式与写入的模式不同，也可以迅速地读出数据，如果另一个程序需要获取学生的姓名和电话，只需定义包含姓名和电话的学生模式，然后用此模式去读取容器文件中的数据即可。
图 16-1 Avro的主要作用
当在RPC中使用Avro时，服务器和客户端可以在握手连接时交换模式。服务器和客户端有彼此全部的模式，因此含有相同命名字段、缺失字段和多余字段等信息之间通信时，需要处理的一致性问题就可以容易地解决。如图16-2所示，协议中定义了用于传输的消息，消息使用框架后放入缓冲区中进行传输，由于传输的初始就交换了各自的协议定义，即使传输双方使用的协议不同，所传输的数据也能够正确解析，具体过程将在后面介绍。
图 16-2 RPC使用Avro
Avro模式是用JSON（一种轻量级的数据交换模式）定义的，这样对于已经拥有JSON库的语言来说就可以容易地实现。
Avro提供与诸如Thrift和Protocol Buffers等系统相似的功能，但是在一些基础方面还是有区别的，主要表现在以下几个方面：
动态类型：Avro并不需要与生成代码、模式和数据存放在一起，而整个数据的处理过程并不生成代码、静态数据类型等。这方便了数据处理系统和语言的构造。
未标记的数据：因为读取数据的时候模式是已知的，所以需要和数据一起编码的类型信息就很少了，这样序列化的规模也就小了。
不需要用户指定字段号：即使模式发生了改变，但是新旧模式都是已知的，所以处理数据时可以通过使用字段名称来解决差异问题。
下面详细介绍模式的声明和Avro的具体使用。
16.1.1 模式声明
模式声明主要是定义数据的类型，Avro中的模式可以使用JSON通过以下方式表示。
1）JSON字符串，指定已定义的类型。
2）JSON对象，其形式为：
{"type"："typeName"……attributes……}
其中，typeName可以是原生的或衍生的类型名称，本章没有定义的属性可以视为元数据，但是其不能影响序列化数据的格式。
3）JSON数组，表示嵌入类型的联合。
声明的类型必须是Avro所支持的数据类型，其中包括原始类型（Primitive Types）和复杂类型（Complex Types），下面分别介绍它们。
原始类型名称包括以下几部分。
null：没有值；
boolean：二进制值；
int：32位有符号整数；
long：64位有符号整数；
float：单精度（32位）IEEE 754浮点数；
double：双精度（64位）IEEE 754浮点数；
bytes：8位无符号字节序列；
string：unicode字符序列。
原始类型没有特定的属性，其名称可以通过类型来定义，如模式"string"相当于：
{"type"："string"}
Avro支持六种复杂类型：记录（records）、枚举（enums）、数组（arrays）、映射（maps）、联合（unions）和固定型（fixed），下面一一介绍。
（1）记录（records）
记录使用类型名称“record”并且支持以下属性：
name：提供记录名称的JSON字符串（必须）。
namespace：限定名称的JSON字符串。
doc：向模式使用者提供说明的JSON字符串（可选）。
aliases：字符串的JSON数组，为记录提供代替名称（可选）。
field：一个JSON数组，用来列出字段（必须）。每个字段就是一个JSON对象且拥有以下属性。
·name：提供记录名称的JSON字符串（必须）。
·doc：为使用者提供字段说明的JSON字符串（可选）。
·type：定义模式的JSON对象，或者记录定义的JSON字符串（必须）。
·default：该字段的默认值用于读取缺少该字段的实例（可选）。如表16-1所示，允许的值依赖于字段的模式类型。联合字段的默认值对应于联合中的第一个模式。字节和固定字段的默认值是JSON字符，这里0～255的Unicode映射到0～255的8位无符号字节。
·order：指定该字段如何影响记录的排序（可选）。有效的值有“ascending”（默认）、“descending”或“ignore”。
·aliases：字符串的JSON数组，为该字段提供可选的名称（可选）。
例如，一个64位的链表可以定义为：
{
"type"："record"，
"name"："LongList"，
"aliases"：["LinkedLongs"]，//别名
"fields"：[
{"name"："value"，"type"："long"}，//每个元素都含有长整型
{"name"："next"，"type"：["LongList"，"null"]}
//下一元素
]
}
（2）枚举（enums）
枚举使用类型名称“enum”并且支持以下几种类型。
name：提供实例名称的JSON字符串（必须）。
namespace：限定名称的JSON字符串。
aliases：字符串的JSON数组，为枚举提供替代名称（可选）。
doc：对模式使用者提供说明的JSON字符串（可选）。
symbols：列出标记的JSON数组（必须）。枚举中的所有标记必须是唯一的，不允许有重复的标记。
例如，纸牌游戏可以定义为：
{"type"："enum"，
"name"："Suit"，
"symbols"：["SPADES"，"HEARTS"，"DIAMONDS"，"CLUBS"]
}
（3）数组（arrays）
数组使用类型名称“array”并且支持一个属性。