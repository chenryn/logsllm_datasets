title:A Practical Dynamic Buffer Overflow Detector
author:Olatunji Ruwase and
Monica S. Lam
A Practical Dynamic Buffer Overﬂow Detector
Olatunji Ruwase
Monica S. Lam
Transmeta Corporation
3990 Freedom Circle
Santa Clara, CA 95054
PI:EMAIL
Computer Systems Laboratory
Stanford University
Stanford, CA 94305
PI:EMAIL
Abstract
Despite previous efforts in auditing software manually
and automatically, buffer overruns are still being discov-
ered in programs in use. A dynamic bounds checker de-
tects buffer overruns in erroneous software before it oc-
curs and thereby prevents attacks from corrupting the in-
tegrity of the system.
Dynamic buffer overrun detectors have not been
adopted widely because they either (1) cannot guard
against all buffer overrun attacks, (2) break existing code,
or (3) incur too high an overhead. This paper presents
a practical detector called CRED (C Range Error Detec-
tor) that avoids each of these deﬁciencies. CRED ﬁnds all
buffer overrun attacks as it directly checks for the bounds
of memory accesses. Unlike the original referent-object
based bounds-checking technique, CRED does not break
existing code because it uses a novel solution to support
program manipulation of out-of-bounds addresses. Fi-
nally, by restricting the bounds checks to strings in a pro-
gram, CRED’s overhead is greatly reduced without sacri-
ﬁcing protection in the experiments we performed.
CRED is implemented as an extension of the GNU
C compiler version 3.3.1. The simplicity of our design
makes possible a robust implementation that has been
tested on over 20 open-source programs, comprising over
1.2 million lines of C code. CRED proved effective in de-
tecting buffer overrun attacks on programs with known
vulnerabilities, and is the only tool found to guard against
a testbed of 20 different buffer overﬂow attacks[34]. Find-
ing overruns only on strings impose an overhead of less
This research was performed while the ﬁrst author was at Stanford Uni-
versity, and this material is based upon work supported in part by the
National Science Foundation under Grant No. 0086160.
than 26% for 14 of the programs, and an overhead of up
to 130% for the remaining six, while the previous state-of-
the-art bounds checker by Jones and Kelly breaks 60% of
the programs and is 12 times slower. Incorporating well-
known techniques for optimizing bounds checking into
CRED could lead to further performance improvements.
1. Introduction
Buffer overﬂows are the most common form of secu-
rity threat in software systems today, and vulnerabilities
attributed to buffer overﬂows have consistently dominated
CERT advisories[7]. In the year 2002, 57% of security ad-
visories for the year were related to buffer overﬂow vul-
nerabilities. As of August 2003, 50% of the security advi-
sories issued for the year fell under this category. In addi-
tion, 50% of the 60 most severe vulnerabilities as posted
on CERT/CC were caused by buffer overﬂow errors in
programs[8]. A similar pattern is also observable in vul-
nerabilities listings posted on computer security websites,
such as SecurityFocus[27] and Securiteam[26]. Computer
worms such as Slammer, CodeRed, and more recently,
Blaster and Welchia have exploited buffer overﬂow vul-
nerabilities in programs to inﬂict billions of dollars worth
of damages on the computing community. An effective
solution to buffer overruns will have a signiﬁcant impact
in improving the security of our computing systems.
1.1. Background
In a buffer-overﬂow attack on a vulnerable program,
the attacker attempts to modify the memory state of the
program so that it yields control of the machine to the at-
tacker in the privilege mode of the program. To launch an
attack, the attacker would supply carefully-crafted excess
1
input data to the program. A program that does not check
if the input exceeds its memory buffer size would copy the
excess data into locations adjacent to the buffer. By con-
trolling the contents, the attacker can cause the program
to deviate from its intended purpose.
A classic and simple example of such an attack, known
as stack smashing[1], simply overwrites the return ad-
dress of a function on the stack so that, when the func-
tion returns, control jumps to a location where the attacker
would have inserted malicious code. Other more complex
variants attempt to modify locations referenced by func-
tion pointers and the global offset table.
Although the buffer overrun problem surfaced many
years ago, a practical solution has eluded the software
community despite efforts in code auditing and devel-
opment of static and dynamic buffer overﬂow detectors.
Static buffer overﬂow detectors attempt to verify that all
memory accesses are checked for overruns[11, 22, 31].
The problem, unfortunately, is undecidable in general.
Sound tools tend to generate too many false warnings and
unsound tools can miss errors in the code. Moreover,
warnings generated by the analysis tools require that pro-
grammers manually inspect the code and insert in the ap-
propriate checks. These weaknesses render static buffer
overﬂow detectors impractical.
Dynamic buffer overﬂow detectors are attractive be-
the necessary guards.
cause they automatically insert
However, for a dynamic detector to be deployed:
it
must (1) protect against all buffer overﬂow attacks, (2)
not break working code, and (3) be reasonably efﬁcient.
There are no buffer overﬂow detectors proposed to date
that satisfy all these requirements.
Some dynamic buffer overﬂow detectors do not of-
fer complete protection against buffer overﬂow attacks;
tools such as StackGuard[10], StackShield[30], and
Propolice[12] attempt to guard against only stack smash-
ing. Bounds checkers detect any bounds violations in pro-
gram execution and hence guard against all buffer over-
ﬂow attacks. Some bounds checkers modify the repre-
sentation of C pointers[9, 17, 19]. They replace each
pointer in the program with a structure that holds infor-
mation needed for bounds checking, such as the base and
extent address of the buffer referenced by the pointer. Not
only does such modiﬁcation increase memory storage sig-
niﬁcantly, it is incompatible with legacy code.
The bounds checker proposed by Jones and Kelly is
particularly attractive in that no pointer representation
modiﬁcations are necessary[18]. They deﬁne the refer-
ent object of a pointer to be the program buffer that the
pointer is intended to reference. They observe that the re-
sult of a pointer arithmetic operation must have the same
referent object as the original pointer. Thus, given an in-
bounds pointer, and the ability to retrieve the base and ex-
tent of the referent object, the checker can determine if the
computed address is in-bounds. However, their approach
cannot handle the case where an out-of-bounds pointer to
an object is stored and later retrieved to compute an in-
bounds address. This weakness causes the tool to gener-
ate false alarms on many existing programs. Furthermore
this tool imposes signiﬁcant runtime overhead because all
non copy pointer operations are instrumented.
1.2. Contributions
This paper presents a practical dynamic buffer overrun
detector called CRED (C Range Error Detector). CRED
enforces a relaxed standard of correctness by allowing
program manipulations of out-of-bounds addresses (a vio-
lation of the ANSI C standard) that do not result in buffer
overﬂows.
The idea is to replace every out-of-bounds
pointer value with the address of a special OOB (out-of-
bounds) object created for that value. Kept with the OOB
object is the actual pointer value and information on the
referent object. The OOB addresses can be copied around
arbitrarily, just like any other data. When the value is used
as an address, however, it is replaced by the actual out-of-
bounds address. Any pointer derived from the address is
bounds checked before it can be dereferenced. Our design
supports the relatively rare out-of-bounds address manip-
ulation, without increasing the overhead for the common
case. Also, it minimizes the space overhead by reclaiming
storage associated with deallocated pointers, ensuring that
no memory is leaked. In addition, CRED exploits type in-
formation to minimize run-time overhead by restricting
checks to only accesses that present security risks.
We have implemented our idea on top of Jones and
Kelly’s extension to the GNU C compiler version 3.3.1.
We tested our implementation extensively by running it on
20 open-source programs, which together comprise over
1.2 million lines of code. Unlike Jones and Kelly’s im-
plementation, which failed on 60% of the programs, code
generated by our compiler passed all the test suites. Our
system is also shown to be effective in detecting buffer
overﬂows.
It is the only tool reported so far to be ef-
fective against a testbed of 20 different buffer overﬂow
attacks[34]. Our optimizations impose an overhead of less
than 26% for 14 of the programs, and an overhead of up
to 130% for the remaining six, while the previous state-
of-the-art tool by Jones and Kelly runs 12 times slower.
This research shows that it is feasible to build a simple,
robust, and compatible C bounds checker that can guard
against all buffer overruns. The performance of our sys-
tem can be further improved by applying known compiler
optimization techniques.
1.3. Paper Organization
We present the bounds-checking technique based on
referent objects in Section 2, discuss its deﬁciency, and
describe our proposed solution. We then discuss an op-
timization in Section 3. Section 4 presents experimental
results of applying CRED to commonly used software ap-
plications. In Section 5, we review other approaches to
tackling the buffer overﬂow problem. Section 6 presents
our conclusion and future work.
2. Bounds Checking Using Referent Objects
To check the bounds of a pointer, we need to determine
its referent object, and then check if the pointer is within
bounds. Because C is not type safe, allows arbitrary ad-
dress calculations, and allows pointers to point to the mid-
dle of an object, it is not easy to determine the referent
object of a pointer.
The referent-object based approach proposed by Jones
and Kelly[18] is based on the principle that an address
computed from an in-bounds pointer must share the same
referent object as the original pointer.
Their scheme uses an object table, a run-time data
structure that collects all the base address and size in-
formation of all static, heap and stack objects. To deter-
mine if an address computed off an in-bounds pointer is
in-bounds, the checker ﬁrst locates the referent object by
comparing the in-bounds pointer with the base and size in-
formation stored in the object table. Then, it checks if the
new address falls within the extent of the referent object.
The object table is implemented as a splay tree[29] to
optimize the pointer lookups. The size of the object table
is relatively small because it is linear with respect to the
number of objects, and not the number of pointers, during
program execution.
Jones and Kelly’s tool was implemented as a run-time
library of checking routines. They modiﬁed the front end
of gcc so that all object creation, address manipulations
and dereference operations are intercepted and replaced
with calls to appropriate routines in the checking library.
These calls make sure that the object table is kept up to
date and that all the addresses generated and dereferenced
are within bounds. In addition, the tool provides a bounds-
checked version of each of the unsafe standard C library
routines that have been instrumental to successful exploits
of vulnerable programs.
An important advantage of Jones and Kelly’s approach
is that code instrumented with their tool is compati-
ble with uninstrumented code, such as linked libraries.
Clearly, since the representation of pointers has not been
changed, uninstrumented codes can work with pointers
and objects created by the instrumented code without any
modiﬁcation. Conversely, it is also easy to allow instru-
mented codes to work with pointers pointing to objects
created by uninstrumented codes.
Heap objects created by uninstrumented codes are
checked like all other heap objects. They are allocated
and de-allocated using bounds-checked versions of mal-
loc and free that appropriately update the object table.
Stack and static objects declared in uninstrumented code
are called unchecked objects and do not appear in the ob-
ject table. Unchecked stack objects are located between
the stack pointer and the top of the stack. Unchecked
static objects are located between address 0 of the virtual
memory and the one byte beyond the BSS section, or in
the region where dynamically linked libraries are loaded.
Thus, a bounds checker can easily determine if an address
points to an unchecked object and not bother checking its
bounds.
2.1. Jones and Kelly’s Design for Handling Out-
of-bounds Pointers
The design described so far assumes that every address
is computed from a pointer that is known to be in-bounds.
What if we compute an out-of-bounds address, store it,
and then access it later? How do we know it is out of
bounds? Jones and Kelly’s design provides an answer to
this question. However, their design breaks if a stored
out-of-bounds address is used subsequently to compute
an in-bounds address. This, unfortunately, happens quite
often.
The C standard offers one possible way to the handle
out-of-bounds pointers. In the C standard, pointer arith-
metic is well deﬁned if and only if the resulting address
lies within the extent of the array, or if it points to the very
next byte after the array. This rule also applies to scalar
objects by treating them simply as an array of one ele-
ment. The C standard allows the generation of the address
pointing immediately past an array because the value is
often used to determine if the end of the array is reached
in a loop. While it is legal to generate the address imme-
diately past an array, dereferencing it results in undeﬁned
behavior. For all other out-of-bounds addresses, both the
generation of the address and the dereference operations
are considered to be undeﬁned.
Jones and Kelly’s approach takes full advantage of the
language standard in their design. First, to handle the off-
by-one addresses, they pad all objects, with the exception
of parameters to a function, by an extra byte. This means
that a pointer pointing immediately past an object can be
easily identiﬁed. The pointer’s intended referent is sim-
ply the object preceding the address; the pointer can be
compared with other pointers to the same object, it can
also be stored, but dereferencing it would cause a buffer
overrun. Parameters in a function are not padded, other-
wise instrumented and uninstrumented code would have
different parameter layouts.
Second, all other out-of-bounds addresses resulting
from pointer arithmetic operations are replaced with a
special ILLEGAL value, deﬁned as (void*) −2. These
addresses can be copied without requiring any special
handling. They can be cast to other types, as a pointer to
an array of characters for instance, before they are copied.
The ILLEGAL value is not allowed to be dereferenced or
used to generate an address. Any such operation, easily
identiﬁable because it is preceded by a cast to a pointer,
will cause the run-time system to halt the program and
report a buffer overrun error.
Unfortunately, many existing programs do not follow
the C standard; 60% of the programs we tested fell into
this category. In particular, there are programs that gen-
erate and store out-of-bound addresses and later retrieve
these values in their computation, without causing buffer
overruns. For example, they may be used in compar-
isons and computations of in-bounds addresses.
Jones
and Kelly’s approach substitutes the out-of-bound address
with a special ILLEGAL value whenever it is computed,
thus causing such programs to no longer behave the same.
Figure 1(a) shows a simple C program that demon-
strates this problem. This program only allocates a heap
buffer to pointer p and sets all other pointers to in-bounds
and out-of-bounds locations of the buffer. Figure 1(b)
shows the memory state of an uninstrumented code af-
ter line 6. While s points to an illegal address, r points
to a legal one and can be dereferenced without causing
an error. If the code has been instrumented, the memory
state after line 5 is shown in Figure 1(c). p, q have the
same referent object. s is found to be out of bounds and
is therefore set to the ILLEGAL value (−2). The checker
incorrectly crashes the program at line 6, since it does not
permit arithmetic on out-of-bounds pointers. It is unac-
ceptable for a checker to break working code. Figure 1(d),
described in more detail below, shows how our proposed
technique handles this program.
2.2. Proposed Out-of-Bound Addresses Handling
As discussed above, it is unacceptable to lose the stored
value of an out-of-bounds address. We must retain the
value of the pointer, and at the same time, keep track of its
referent object. Our approach is to create a unique out-of-
bounds object (OOB object) in the heap for every stored
out-of-bounds address value, and substitute the value with
the address of the corresponding OOB object. These ob-
jects are deallocated as soon as they are no longer needed
to minimize the space overhead. An OOB object contains
(a) the out-of-bounds address value and (b) the referent
object that the value refers to. It is not entered into the ob-
ject table, but rather entered into an out-of-bounds object
hash table (OOB hash table).
We can check if a pointer points to an OOB object
quickly by consulting this hash table. The hash table is
consulted only in the rare case where the checker could
neither ﬁnd the referent object of a pointer used in a non-