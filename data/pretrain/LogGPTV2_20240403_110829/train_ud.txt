(this feature is present at least as far back as glibc 2.0.)
thus, one could write the following to have
.br scanf ()
allocate a buffer for an input string,
with a pointer to that buffer being returned in
.ir *buf :
.pp
    char *buf;
    scanf("%as", &buf);
.pp
the use of the letter
.b a
for this purpose was problematic, since
.b a
is also specified by the iso c standard as a synonym for
.b f
(floating-point input).
posix.1-2008 instead specifies the
.b m
modifier for assignment allocation (as documented in description, above).
.pp
note that the
.b a
modifier is not available if the program is compiled with
.i "gcc \-std=c99"
or
.ir "gcc \-d_isoc99_source"
(unless
.b _gnu_source
is also specified), in which case the
.b a
is interpreted as a specifier for floating-point numbers (see above).
.pp
support for the
.b m
modifier was added to glibc starting with version 2.7,
and new programs should use that modifier instead of
.br a .
.pp
as well as being standardized by posix, the
.b m
modifier has the following further advantages over
the use of
.br a:
.ip * 2
it may also be applied to
.b %c
conversion specifiers (e.g.,
.br %3mc ).
.ip *
it avoids ambiguity with respect to the
.b %a
floating-point conversion specifier (and is unaffected by
.ir "gcc \-std=c99"
etc.).
.sh bugs
all functions are fully c89 conformant, but provide the
additional specifiers
.b q
and
.b a
as well as an additional behavior of the
.b l
and
.b l
specifiers.
the latter may be considered to be a bug, as it changes the
behavior of specifiers defined in c89.
.pp
some combinations of the type modifiers and conversion
specifiers defined by ansi c do not make sense
(e.g.,
.br "%ld" ).
while they may have a well-defined behavior on linux, this need not
to be so on other architectures.
therefore it usually is better to use
modifiers that are not defined by ansi c at all, that is, use
.b q
instead of
.b l
in combination with
\fbd\fp, \fbi\fp, \fbo\fp, \fbu\fp, \fbx\fp, and \fbx\fp
conversions or
.br ll .
.pp
the usage of
.b q
is not the same as on 4.4bsd,
as it may be used in float conversions equivalently to
.br l .
.sh examples
to use the dynamic allocation conversion specifier, specify
.b m
as a length modifier (thus
.b %ms
or
\fb%m[\fp\firange\fp\fb]\fp).
the caller must
.br free (3)
the returned string, as in the following example:
.pp
.in +4n
.ex
char *p;
int n;
errno = 0;
n = scanf("%m[a\-z]", &p);
if (n == 1) {
    printf("read: %s\en", p);
    free(p);
} else if (errno != 0) {
    perror("scanf");
} else {
    fprintf(stderr, "no matching characters\en");
}
.ee
.in
.pp
as shown in the above example, it is necessary to call
.br free (3)
only if the
.br scanf ()
call successfully read a string.
.sh see also
.br getc (3),
.br printf (3),
.br setlocale (3),
.br strtod (3),
.br strtol (3),
.br strtoul (3)
.sh colophon
this page is part of release 5.13 of the linux
.i man-pages
project.
a description of the project,
information about reporting bugs,
and the latest version of this page,
can be found at
\%https://www.kernel.org/doc/man\-pages/.
.\" copyright 1993 rickard e. faith (PI:EMAIL)
.\"
.\" %%%license_start(verbatim)
.\" permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" since the linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  the author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  the author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%license_end
.\"
.\" historical remark, aeb, 2004-06-05
.th getuid 2 2021-03-22 "linux" "linux programmer's manual"
.sh name
getuid, geteuid \- get user identity
.sh synopsis
.nf
.b #include 
.pp
.b uid_t getuid(void);
.b uid_t geteuid(void);
.fi
.sh description
.br getuid ()
returns the real user id of the calling process.
.pp
.br geteuid ()
returns the effective user id of the calling process.
.sh errors
these functions are always successful
and never modify
.\" https://www.austingroupbugs.net/view.php?id=511
.\" 0000511: getuid and friends should not modify errno
.ir errno .
.sh conforming to
posix.1-2001, posix.1-2008, 4.3bsd.
.sh notes
.ss history
in unix\ v6 the
.br getuid ()
call returned
.ir "(euid 
.\"
.\" %%%license_start(verbatim)
.\" permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" since the linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  the author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  the author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%license_end
.\"
.th pthread_cleanup_push_defer_np 3 2021-03-22 "linux" "linux programmer's manual"
.sh name
pthread_cleanup_push_defer_np, pthread_cleanup_pop_restore_np \- push and pop
thread cancellation clean-up handlers while saving cancelability type
.sh synopsis
.nf
.b #include 
.pp
.bi "void pthread_cleanup_push_defer_np(void (*" routine ")(void *), void *" arg );
.bi "void pthread_cleanup_pop_restore_np(int " execute );
.fi
.pp
compile and link with \fi\-pthread\fp.
.pp
.rs -4
feature test macro requirements for glibc (see
.br feature_test_macros (7)):
.re
.pp
.br pthread_cleanup_push_defer_np (),
.br pthread_cleanup_pop_defer_np ():
.nf
    _gnu_source
.fi
.sh description
these functions are the same as
.br pthread_cleanup_push (3)
and
.br pthread_cleanup_pop (3),
except for the differences noted on this page.
.pp
like
.br pthread_cleanup_push (3),
.br pthread_cleanup_push_defer_np ()
pushes
.i routine
onto the thread's stack of cancellation clean-up handlers.
in addition, it also saves the thread's current cancelability type,
and sets the cancelability type to "deferred" (see
.br pthread_setcanceltype (3));
this ensures that cancellation clean-up will occur
even if the thread's cancelability type was "asynchronous"
before the call.
.pp
like
.br pthread_cleanup_pop (3),
.br pthread_cleanup_pop_restore_np ()
pops the top-most clean-up handler from the thread's
stack of cancellation clean-up handlers.
in addition, it restores the thread's cancelability
type to its value at the time of the matching
.br pthread_cleanup_push_defer_np ().
.pp
the caller must ensure that calls to these
functions are paired within the same function,
and at the same lexical nesting level.
other restrictions apply, as described in
.br pthread_cleanup_push (3).
.pp
this sequence of calls:
.pp
.in +4n
.ex
pthread_cleanup_push_defer_np(routine, arg);
pthread_cleanup_pop_restore_np(execute);
.ee
.in
.pp
is equivalent to (but shorter and more efficient than):
.pp
.\" as far as i can see, linuxthreads reverses the two substeps
.\" in the push and pop below.
.in +4n
.ex
int oldtype;
pthread_cleanup_push(routine, arg);
pthread_setcanceltype(pthread_cancel_deferred, &oldtype);
\&...
pthread_setcanceltype(oldtype, null);
pthread_cleanup_pop(execute);
.ee
.in
.\" sh versions
.\" available since glibc 2.0
.sh conforming to
these functions are nonstandard gnu extensions;
hence the suffix "_np" (nonportable) in the names.
.sh see also
.br pthread_cancel (3),
.br pthread_cleanup_push (3),
.br pthread_setcancelstate (3),
.br pthread_testcancel (3),
.br pthreads (7)
.sh colophon
this page is part of release 5.13 of the linux
.i man-pages
project.
a description of the project,
information about reporting bugs,
and the latest version of this page,
can be found at
\%https://www.kernel.org/doc/man\-pages/.
.so man3/fmax.3
.\" copyright (c) 2010 by michael kerrisk 
.\"
.\" %%%license_start(verbatim)
.\" permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" since the linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  the author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  the author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%license_end
.\"
.th aio 7 2021-03-22 "linux" "linux programmer's manual"
.sh name
aio \- posix asynchronous i/o overview
.sh description
the posix asynchronous i/o (aio) interface allows applications
to initiate one or more i/o operations that are performed
asynchronously (i.e., in the background).
the application can elect to be notified of completion of
the i/o operation in a variety of ways:
by delivery of a signal, by instantiation of a thread,
or no notification at all.
.pp
the posix aio interface consists of the following functions:
.tp
.br aio_read (3)
enqueue a read request.
this is the asynchronous analog of
.br read (2).
.tp
.br aio_write (3)
enqueue a write request.
this is the asynchronous analog of
.br write (2).
.tp
.br aio_fsync (3)
enqueue a sync request for the i/o operations on a file descriptor.
this is the asynchronous analog of
.br fsync (2)
and
.br fdatasync (2).
.tp
.br aio_error (3)
obtain the error status of an enqueued i/o request.
.tp
.br aio_return (3)
obtain the return status of a completed i/o request.
.tp
.br aio_suspend (3)
suspend the caller until one or more of a specified set of
i/o requests completes.
.tp
.br aio_cancel (3)
attempt to cancel outstanding i/o requests on a specified
file descriptor.
.tp
.br lio_listio (3)
enqueue multiple i/o requests using a single function call.
.pp
the
.i aiocb
("asynchronous i/o control block") structure defines
parameters that control an i/o operation.
an argument of this type is employed with all of the functions listed above.
this structure has the following form:
.pp
.in +4n
.ex
#include 
struct aiocb {
    /* the order of these fields is implementation\-dependent */
    int             aio_fildes;     /* file descriptor */
    off_t           aio_offset;     /* file offset */
    volatile void  *aio_buf;        /* location of buffer */
    size_t          aio_nbytes;     /* length of transfer */
    int             aio_reqprio;    /* request priority */
    struct sigevent aio_sigevent;   /* notification method */
    int             aio_lio_opcode; /* operation to be performed;
                                       lio_listio() only */
    /* various implementation\-internal fields not shown */
};
/* operation codes for \(aqaio_lio_opcode\(aq: */
enum { lio_read, lio_write, lio_nop };
.ee
.in
.pp
the fields of this structure are as follows:
.tp
.i aio_fildes
the file descriptor on which the i/o operation is to be performed.
.tp
.i aio_offset
this is the file offset at which the i/o operation is to be performed.
.tp
.i aio_buf
this is the buffer used to transfer data for a read or write operation.
.tp
.i aio_nbytes
this is the size of the buffer pointed to by
.ir aio_buf .
.tp
.i aio_reqprio
this field specifies a value that is subtracted
from the calling thread's real-time priority in order to
determine the priority for execution of this i/o request (see
.br pthread_setschedparam (3)).
the specified value must be between 0 and the value returned by
.ir sysconf(_sc_aio_prio_delta_max) .
this field is ignored for file synchronization operations.
.tp
.i aio_sigevent
this field is a structure that specifies how the caller is
to be notified when the asynchronous i/o operation completes.
possible values for
.ir aio_sigevent.sigev_notify
are
.br sigev_none ,
.br sigev_signal ,
and
.br sigev_thread .
see
.br sigevent (7)
for further details.
.tp
.i aio_lio_opcode
the type of operation to be performed; used only for
.br lio_listio (3).
.pp
in addition to the standard functions listed above,
the gnu c library provides the following extension to the posix aio api:
.tp
.br aio_init (3)
set parameters for tuning the behavior of the glibc posix aio implementation.
.sh errors
.tp
.b einval
the
.i aio_reqprio
field of the
.i aiocb
structure was less than 0,
or was greater than the limit returned by the call
.ir sysconf(_sc_aio_prio_delta_max) .
.sh versions
the posix aio interfaces are provided by glibc since version 2.1.
.sh conforming to
posix.1-2001, posix.1-2008.
.sh notes
it is a good idea to zero out the control block buffer before use (see
.br memset (3)).
the control block buffer and the buffer pointed to by
.i aio_buf
must not be changed while the i/o operation is in progress.
these buffers must remain valid until the i/o operation completes.
.pp