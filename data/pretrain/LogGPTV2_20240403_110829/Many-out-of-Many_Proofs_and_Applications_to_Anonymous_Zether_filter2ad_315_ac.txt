D := Com(cid:0)−a2
(cid:1)
A := Com (a0, . . . , am−1; rA)
(ak · (1 − 2bk))m−1
C := Com
m−1; rD
Protocol Bit commitment [10, Fig. 4]
1: P1 computes...
2:
3:
4:
5:
6: end P1
7: P1 → V1 : A, C, D
8: V1 : x ←$ Fq
9: V1 → P1 : x
10: P1 computes...
11:
12:
13:
14: end P1
15: P1 → V1 : f0, . . . , fm−1, zA, zC
16: V1 requires...
17:
BxA
18:
CxD
19: end V1
(cid:16)
?
= Com ((f0, . . . , fm−1); zA)
(fk · (x − fk))m−1
?
= Com
(cid:17)
k=0 ; zC
for each k ∈ {0, . . . , m − 1} do fi := bi · x + ai end for
zA := rB · x + rA
zC := rC · x + rD
Finally:
Lemma III.5 (Bootle et al. [10, Lem. 1]). The protocol P1,V1
is perfectly complete for R1. If Com is (perfectly) binding, then
it is (perfectly) (3)-special sound. If Com is (perfectly) hiding,
then it is (perfectly) special honest veriﬁer zero knowledge.
In practice, we incorporate an additional improvement due
to Esgin, Zhao, Steinfeld, Liu and Liu [15, §1.3]. That is,
we commit to all 0th-order components in A (incorporating
also D) and to all 1st-order components in B (incorporating
also C). Finally, we eliminate zC. This technique reduces the
proof’s size, and simpliﬁes the veriﬁer’s checks.
B. Overview of Groth–Kohlweiss [9]
We now review Groth and Kohlweiss [9], incorporating also
ideas from Bootle et al. [10]. These works describe a proof
protocol for the relation:
{(σ, (c0, . . . , cN−1); l, r) | cl = Com(0; r)} ;
in short, the prover proves that she knows an opening to 0
of a secret element cl among a public list of commitments
(c0, . . . , cN−1).
We recall the proof technique, deferring to the papers for
further details. The bit commitment protocol above shows, in
fact, that the responses fk,1 := fk sent by the prover are
evaluations—at the veriﬁer’s challenge x—of linear polynomi-
als Fk,1(X) = bk· X + ak whose ﬁrst-order coefﬁcients bk are
bits (chosen by the prover). In light of this fact, the quantities
fk,0 := x − fk, which the veriﬁer may also compute, are in
turn necessarily evaluations at x of Fk,0(X) := X − Fk,1(X),
i ∈ {0, . . . , N − 1}, pi :=(cid:81)m−1
at x of Pi(X) :=(cid:81)m−1
whose ﬁrst-order coefﬁcients are also bits (in fact the logical
negations of the bk). Finally, the veriﬁer may set, for each
k=0 fk,(i)k, where (i)k denotes
the kth bit of i. By the same reasoning, each pi is the evaluation
k=0 Fk,(i)k (X). The key property of the
Pi(X) pertains to their degrees. In fact, by the structure of
the Fk,b(X), Pi(X) is of degree m (and monic) for one and
only one index i (namely that i whose binary representation
is b0, . . . , bm−1).
i
This fact convinces the veriﬁer that the multi-exponentiation
is equal to the group-product of (cl)xm (for some
i=0 cpi
secret l chosen by the prover) with further terms which depend
on lower powers of x. The veriﬁer allows the prover to
“cancel out” these lower-order terms by sending additional
group elements; the prover must send these before seeing x.
(cid:81)N−1
C. Main protocol
q → Fs
We ﬁx commitments c0, . . . , cN−1, a free permutation κ ∈
SN of order o, and a linear map Ξ : Fo
q. Our main result
in this section is a proof of knowledge of an index l, as well
as of openings r0, . . . , rs−1 to 0 of the image points under
Ξ of the commitments cl, cκ(l), cκ2(l), . . . , cκo−1(l) represented
by l’s ordered orbit. We represent Ξ as an s × o matrix with
entries in Fq in what follows. We thus have the relation:
(σ, (c0, . . . , cN−1), κ, Ξ; l, (r0, . . . , rs−1)) |
R2 =
(cid:110)
(cid:2) Com(0; ri) (cid:3)s−1
i=0
=(cid:2) Ξ (cid:3) ·(cid:2) cκj (l)
(cid:111)
.
(cid:3)o−1
j=0
rB, ρ0, . . . , ρm−1 ←$ Fq
B := Com(l0, . . . , lm−1; rB)
(A, C, D) ← P1(σ, B; (l0, . . . , lm−1, r))
Protocol Many-out-of-many proof
1: P2 computes...
2:
3:
4:
5: end P2
6: P2 → V2 : A, B, C, D
7: V2 : v ←$ Fq
8: V2 → P2 : v
10: P2 computes...
11:
for k ∈ {0, . . . , m − 1} do
9: P2 and V2 evaluate(cid:2)1, v, . . . , vs−1(cid:3) · Ξ =: [ξ0, . . . , ξo−1]
(cid:19)ξj · Com(0; ρk)
Gk :=(cid:81)o−1
(cid:18)(cid:81)N−1
κ−j (i),k
P
i
j=0
i=0 c
end for
(cid:17) · xm −(cid:80)m−1
(cid:16)(cid:80)s−1
12:
13:
14: end P2
15: P2 → V2 : G0, . . . , Gm−1
16: V2 : x ←$ Fq
17: V2 → P2 : x
18: P2 computes...
(f0, . . . , fm−1, zA, zC ) ← P1(x)
19:
20:
z :=
21: end P2
22: P2 → V2 : f0, . . . , fm−1, zA, zC , z
23: V2 requires...
24:
25:
26:
27:
28: end V2
(cid:81)o−1
V1(σ, B, x, A, C, D, (fk)m−1
(cid:16)(cid:81)N−1
i=0 vi · ri
(cid:17)ξj ·(cid:81)m−1
p
i=0 c
i
j=0
k=0 ρk · xk
k=0 , zA, zC )
?
= 1
(cid:46) and ∀i ∈ {0, . . . , N − 1}, pi :=(cid:81)m−1
κ−j (i)
?
= Com(0; z)
(cid:46) where ∀k, fk,1 := fk, fk,0 := x − fk
k=0 fk,ik
k=0 G−xk
k
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:00 UTC from IEEE Xplore.  Restrictions apply. 
1804
i=0
i=0 c
pκ−j (i)
i
j=0
q → Fs
(cid:105)o−1
pκ−j (i)
i=0 c
i
(cid:1)xm (cid:105)o−1
In fact, our theory carries through identically even if the
map Ξ : Fo
q is allowed to be afﬁne linear, as opposed to
linear (i.e., including an additive, “0th-order” part). In order to
exploit matrix notation, we suppress this fact; nonetheless, it
constitutes a useful generalization of the theory.
The essential idea is, as indicated above, that the veriﬁer
may permute the components of the vector (pi)N−1
in accor-
dance with κ, and use each permuted vector in its own multi-
exponentiation. Though the veriﬁer does not know that index
l for which deg Pl(X) = m, the veriﬁer nonetheless knows
that deg Pκ−j (i)(X) = m if and only if i = κj(l). By conse-
quence, the veriﬁer knows that, for each j ∈ {0, . . . , o − 1},
gives the group-product of (cκj (l))xm with
(cid:81)N−1
lower-order terms; likewise, (cid:2) Ξ (cid:3) ·(cid:104) (cid:81)N−1
gives the group product of (cid:2) Ξ (cid:3) ·(cid:104) (cid:0)cκj (l)
j=0
with
lower-order terms. As before, these terms may be cancelled
out by the prover.
Example III.6. Setting κ = id ∈ SN the identity permutation,
and Ξ = I1 : Fq → Fq the identity map, exactly recovers the
original protocol of Groth and Kohlweiss [9].
Example III.7. For o dividing N, we consider the iterate
κ := (0, 1, . . . , N − 1)N/o, and set Ξ = Io as the identity map
on Fo
q. In this setting, the protocol of this section demonstrates
knowledge of a secret residue class l mod N/o, as well as of
openings to 0 (say, r0, . . . , ro−1) of those commitments ci for
which i ≡ l mod N/o.
Example III.8. Subsection II-D sketches the choice κ :=
(0, 1, . . . , N − 1) and Ξ : FN
q → Fq a linear functional.
This setting gives a proof of knowledge of a secret permu-
tation K ∈ (cid:104)(0, 1, . . . , N − 1)(cid:105) for which the “messages” of
cK(0), cK(1), . . . , cK(N−1) reside in a prespeciﬁed hyperplane
of FN
q .
Example III.9. Setting κ := (0, 1, . . . , N − 1) and choos-
ing for Ξ : FN
the afﬁne linear map Ξ :
(m0, m1, . . . , mN−1) (cid:55)→ (m0 − 1, m1, . . . , mN−1) yields a
proof that the “messages” of c0, c1, . . . , cN−1 give a standard
basis vector el ∈ FN
q , which moreover conceals the particular
standard basis vector represented (i.e., the index l).
q → FN
q
The protocol Π = (Setup,P2,V2) given above is perfectly
complete. This follows essentially by inspection; we note in
particular that (0;(cid:80)s−1
i=0 vi · ri) opens the matrix product
(cid:2) 1
v
. . .
vs−1 (cid:3) ·(cid:2) Ξ (cid:3) ·
cl
cκ(l)
...
cκo−1(l)
 ,
by hypothesis on the r0, . . . , rs−1.
Informally, the protocol is sound because [9, Fig. 2] is, and
because the prover must commit to the polynomials Pi(X)
(through the commitments B and A) before seeing v, as well
as send the correction terms Gk before seeing x. The protocol
is zero-knowledge because the transcript features, essentially,
the same structure as that of [10, Fig. 5], demanding little extra
work for the simulator. We record security theorems below;
proof sketches are given in Appendix B, while rigorous proofs
are given in the full version of this paper.
Theorem III.10. If Com is (perfectly) binding, then Π is
(perfectly) (s, m + 1)-special sound.
Proof. Deferred to Appendix B.
Theorem III.11. If Com is (perfectly) hiding,
(perfectly) special honest veriﬁer zero knowledge.
then Π is
Proof. Deferred to Appendix B.
D. Efﬁciency
We discuss the efﬁciency of our protocol, and argue in
particular that it can be computed in quasilinear time for
both the prover and the veriﬁer. In order to facilitate fair
comparison, we assume throughout that only “elementary”
ﬁeld, group, and polynomial operations are used (in contrast
with [9], who rely on multi-exponentiation algorithms and
unspeciﬁed “fast polynomial multiplication techniques”).
i=0
i=0 and (pi)N−1
1) Analysis of Groth–Kohlweiss [9]: We begin with an
analysis of [9]. The prover and veriﬁer may na¨ıvely compute
the polynomials Pi(X) and the evaluations pi in O(N log2 N )
and O(N log N ) time, respectively. We claim that the prover
and veriﬁer can compute (Pi(X))N−1
(respec-
tively) in O(N log N ) and O(N ) time. (These are clearly
optimal, in light of the output sizes.) To this end, we informally
sketch an efﬁcient recursive algorithm, which closely evokes
those used in bit reversal (see e.g., Jeong and Williams [16]).
Having constructed the linear polynomials Fk,1(X) and
Fk,0(X) for k ∈ {0, . . . , m − 1}, the prover constructs the
Pi(X) using a procedure which, essentially, arranges the “up-
ward paths” through the m×2 array Fk,b(X) into a binary tree
k=0 Fk,(i)k (X) =
Pi(X), which can be written into the ith index of a global array
(the index i can be kept track of throughout the recursion,
using bitwise operations). Each edge of this tree, on the other
hand, represents the multiplication of an O(log N )-degree
“partial product” by a linear polynomial; we conclude that
the entire procedure takes O(N log N ) time. (The m multi-
exponentiations of c0, . . . , cN−1 by Pi,k—conducted during
the construction of the Gk—also take O(N log N ) time.)
of depth m. Each leaf i gives the product(cid:81)m−1
The veriﬁer of [9] can be implemented O(N ) time. Indeed,
the same binary recursive procedure—applied now to the
evaluations fk,b—takes O(N ) time, as in this setting the
products don’t grow as the depth increases, and each “partial
product” can be extended in O(1) time.