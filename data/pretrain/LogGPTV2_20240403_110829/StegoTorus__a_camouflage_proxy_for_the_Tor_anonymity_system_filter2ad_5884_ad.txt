20
Figure 3: Payload lengths for the ﬁrst 20 non-empty packets of 63,585 unidirectional ﬂows on TCP port 443, taken from the CAIDA 2011-Chicago data
set. [14] Port 443 is oﬃcially assigned to HTTP over TLS, but Tor relays are sometimes conﬁgured to accept connections on this port. Scanning for
586-byte TCP payloads identiﬁes 67 of the ﬂows as probable Tor traﬃc.
)
X
≤
x
(
r
P
1.0
0.8
0.6
0.4
0.2
0.0
0
10
20
30
40
50
60
70
Connection length (seconds)
CAIDA port 80
Tor
Obfsproxy
StegoTorus-HTTP
0
500
1000
1500
Per-packet payload (bytes)
20
0
100
Connection payload (decimal kB)
40
60
80
Figure 4: Empirical CDFs of connection length, total data transferred, and per-packet payload for 20 visits to each of the Alexa top ten websites, using
Tor directly (dashed line), obfsproxy (dot-dash line), and StegoTorus-HTTP (dotted line). CAIDA Chicago-2011 port 80 traﬃc for reference (solid line).
5.1 Detecting Tor
The Tor protocol [22] sends nearly all messages in the form of
“cells” with a ﬁxed length of 512 bytes. These cells are packed
into TLS 1.0 application-data records [17] on the wire. Because of
the “empty record” countermeasure for a cryptographic weakness
in TLS 1.0 [5, 6], the overhead of TLS encapsulation is 74 bytes
per application-data record. The client will pack many cells into a
record if it has enough to say, and TCP will split large records in the
middle in order to transmit MTU-sized packets, but Tor nonetheless
winds up transmitting many TCP packets that contain exactly one
cell. These packets have a characteristic payload length of 586
bytes. A ﬁltering router can pick Tor streams out of other traﬃc by
counting how often they appear.
We implemented the following concrete algorithm: let τ be the
adversary’s current estimate of the probability that a given TCP ﬂow
is Tor, initially set to zero. Ignore packets containing only an ACK
and no payload; these are best treated as neutral [57]. Otherwise,
update τ ← ατ + (1 − α)1l=586 where α ∈ (0, 1) is a tuning parameter
and 1l=586 is one if the TCP payload length l equals 586 bytes, zero
otherwise.
If τ rises past a threshold value T , the TCP ﬂow is
considered Tor traﬃc.
To do this, a perimeter ﬁlter must be capable of tracking TCP
ﬂows in realtime, and maintaining one scalar value (the estimate τ)
for each; to the best of our knowledge, this is within the capabili-
ties of modern DPI hardware. Empirically, α = 0.1 and T = 0.4
identiﬁes Tor within a few dozen packets. Figure 3 shows proba-
ble Tor ﬂows picked out of all the port-443 traﬃc in the CAIDA
2011-Chicago data set [14] with this technique. (This data set only
includes IP and TCP headers for each packet captured, so we are
unable to conﬁrm that the selected ﬂows are actually Tor, or how
much of the background traﬃc is in fact HTTPS.)
To conﬁrm the eﬀectiveness of this attack against vanilla Tor, we
collected traﬃc traces from visiting the top ten Alexa sites twenty
times over vanilla Tor, obfsproxy [21], and StegoTorus with the
HTTP steganography module. In addition to non-zero TCP pay-
load sizes for each packet, we extracted the lifetime and total data
transferred (treating the two directions as independent) of each TCP
stream. Figure 4 presents a qualitative comparison of these features
in the form of empirical CDFs, with all TCP ﬂows on port 80 of
the CAIDA 2011-Chicago data set (again, we cannot conﬁrm this,
but port 80 traﬃc on the public Internet is almost surely HTTP)
for reference. Tor’s predilection for generating 586-byte packets is
clearly seen in the rightmost panel of Figure 4, and the other panels
show other characteristics that would be easy for the adversary to
detect, such as a tendency for TCP connections to last exactly 20 or
30 seconds. Obfsproxy does little to alter these features.
StegoTorus fares much better. It is not perfect, but it generates
empirical CDFs for all three features that are closer to the CAIDA
port 80 reference than they are to either Tor or obfsproxy. In par-
115ticular, it eliminates the 586-byte characteristic payload size. Still,
a determined adversary with more analytic power at its disposal
might be able to detect the remaining statistical diﬀerences between
StegoTorus-HTTP and “normal” HTTP traﬃc that Figure 4 reveals.
Improving our HTTP emulation will reduce these diﬀerences. If
necessary, we could also implement an explicit statistical model of
what HTTP traﬃc “should” be like.
5.2 Identifying Visits to Facebook
Once the censor has identiﬁed TCP streams as Tor traﬃc, they
would also like to learn which sites are being accessed clandestinely.
We present a simple method to determine whether a Tor user is
visiting Facebook; this site has sometimes been completely blocked
by government censors. It is a cut-down version of Panchenko
et al. [57], which can identify accesses to a small set of censored
websites within a larger Tor session. Their classiﬁer uses a support
vector machine, which is too expensive to run on a ﬁltering router,
even on a small number of streams. With careful optimization, our
classiﬁer requires a handful of probability calculations per arriving
packet, plus maintenance of a sliding-window vector per stream
under surveillance; this should be acceptably cheap.
Once a stream has been identiﬁed as Tor traﬃc, the censor main-
tains a pair of sequences, ui and di, sliding over the last n non-empty
packets observed by the ﬁltering router. Each ui is the cumulative
sum of payload lengths for packets 1 through i sent “upward” (client
to relay), and di is the same for packets sent “downward” (relay
to client). The censor has previously observed “typical” Facebook
traﬃc, and modeled the probability distributions Pr[Ui] and Pr[Di]
that one would expect to see if a trace were a visit to Facebook.
Using this model, the censor computes
log Pr [{ui}, {di} is Facebook]
=
n
Xi=1
log Pr[Ui = ui] +
n
Xi=1
log Pr[Di = di]
Log-probabilities are used to avoid ﬂoating-point underﬂow, since
the per-packet probabilities can be very small. If the overall log-
probability exceeds a threshold, the censor classiﬁes the traﬃc as a
visit to Facebook.
We trained this classiﬁer on the ﬁrst 250 packets transmitted in
each direction over ten visits to the Facebook home page (login
screen), and modeled the probability distributions as independent
Gaussians for each position in the sequence. This is a deliberate
departure from reality: Ui+1 has a strong dependence on Ui, since
they are cumulative sums, but treating them as independent makes
the classiﬁer robust to variation in the order of resources downloaded.
We then tested it on 20 more visits to Facebook, plus 40 visits to
other web sites chosen from Alexa’s categorized directory of popular
sites [3]. For all of the test visits, we browsed randomly until we had
somewhere between 5,000 and 30,000 TCP packets; this resulted
in a total of over 450,000 total packets and 500MB of Tor traﬃc.
Figure 5 shows the results. Only one of the Facebook visits is not
detected, and none of the other sites are misdetected as Facebook.
We augmented this attack to detect visits to nine of the top ten
Alexa sites.2 The classiﬁer described above is intrinsically binary:
site-X or not-site-X. An adversary wishing to know which of some
set of sites was being visited would have to run a classiﬁer for each
site in parallel, suﬀering additional resource costs proportional to
the number of sites. If the adversary cares only about visits to a
fairly small number of sites, this will not be a signiﬁcant problem.
For each site, we trained a classiﬁer using the same procedure
as described above for Facebook, using traces for ten visits to its
front page. A traﬃc stream generated by a real user would not stop
after loading the front page of whatever site he or she was visiting.
Therefore, we adjusted the training window size for each site to
ensure that the classiﬁer did not simply learn the overall amount of
data involved in loading the front page. We then tested each binary
classiﬁer on an additional ten visits to the target site, plus ten traces
for each of the other eight sites.
For test runs with “vanilla” Tor, we took the best classiﬁcation
result obtained among four diﬀerent window sizes: 50, 100, 150,
and 200 packets. For test runs with StegoTorus, we added a 500-
packet window, since StegoTorus-HTTP generates a much larger
volume of traﬃc. We present classiﬁcation accuracy in Table 2, as
trapezoidally approximated AUC scores (area under the receiver
operating characteristic curve) for Tor and StegoTorus visits to
each of the nine sites. AUC scores allow evaluation of classiﬁer
eﬀectiveness without ﬁrst having to choose a tradeoﬀ between false
negatives and false positives.
Facebook
Similar
Other
sports.yahoo.com
paypal.com thesaurus.com
twitter.com yahoo.com
undetected Facebook visit
y
t
i
l
i
b
a
b
o
r
p
-
g
o
l
d
e
t
f
i
h
S
2,000
500
0
−500
−10,000
−300,000
Figure 5: Log-probabilities reported by Facebook classiﬁer, shifted
to place the classiﬁcation threshold at zero on the y-axis. Visits to
Facebook (squares) show the shifted log-probability for the ﬁrst 250
packets. Visits to non-Facebook sites (circles) show the maximum
shifted log-probability observed for a 250-packet sliding window.
Web Site
Tor
StegoTorus
Google
Facebook
Youtube
Yahoo
Wikipedia
Windows Live
Blogspot
Amazon
Twitter
0.9697
0.9441
0.9947
0.8775
0.9991
0.9403
0.9825
0.9841
0.9944
0.6928
0.5413
0.4125
0.7400
0.7716
0.6763
0.6209
0.8684
0.7366
Table 2: AUC scores for detecting visits to nine of the Alexa top ten
sites’ front pages, over Tor and StegoTorus.
An AUC score of 0.5 indicates a classiﬁer performing no better
than random guessing, and a score of 1 indicates perfect accuracy.
Over Tor by itself, we can often obtain AUC scores better than
0.95, but over StegoTorus, the scores drop to 0.75 or less in most
cases. For real-time classiﬁcation of the traﬃc volume seen at a
perimeter router, the adversary requires an AUC score very close to
1 to avoid being swamped by errors. StegoTorus does not reduce
2baidu.com was excluded because visits to this site did not ex-
change enough packets to perform a meaningful analysis.
11650 kB/s stream
150 kB/s stream
300 kB/s stream
Tor
StegoTorus (chopper only)
StegoTorus (HTTP, 2 parallel connections)
StegoTorus (HTTP, 4 parallel connections)
StegoTorus (HTTP, 6 parallel connections)
e
t
a
r
d
a
o
l
n
w
o
d
d
e
n
i
a
t
s
u
S
)