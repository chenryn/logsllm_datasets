2.3.2 Execution-based Analysis through VM-based
Page Rendering
A drive-by download attack occurs when a Web page
exploits a ﬂaw in the victim’s browser.
In the worst
case, an attack permits the attacker to install and run arbi-
trary software on the victim’s computer. Our execution-
based approach to detecting such attacks is adapted from
a technique we developed in our earlier spyware mea-
surement study [28], where we used virtual machines to
determine whether a Web page had malicious content.
We summarize this technique here.
Our detection method relies on the assumption that
malicious Web content will attempt to break out of the
security sandbox implemented by the browser. For ex-
ample, the simple act of rendering a Web page should
never cause any of the following side-effects:
the cre-
ation of a new process other than known helper appli-
cations, modiﬁcations to the ﬁle system outside of safe
folders such as the browser cache, registry modiﬁcations,
browser or OS crashes, and so on. If we can determine
that a Web page triggers any of these unacceptable con-
ditions, we have proof that the Web page contains mali-
cious content.
To analyze a Web page, we use a “clean”
VMware [45] virtual machine conﬁgured with unneces-
sary services disabled. We direct an unmodiﬁed browser
running in the VM to fetch and render the Web page. Be-
cause we disabled other services, any side effects we ob-
serve must be caused by the browser rendering the Web
page. We monitor the guest OS and browser through
“triggers” installed to look for sandbox violations, in-
cluding those listed above. If a trigger ﬁres, we declare
the Web page to be unsafe. This mechanism is described
in more detail in [28].
Note that this technique is behavior-based rather than
signature-based. We do not attempt to characterize vul-
nerabilities;
instead, we execute or render content to
look for evidence of malicious side-effects. Accordingly,
given a sufﬁciently comprehensive set of trigger condi-
tions, we can detect zero-day attacks that exploit vulner-
abilities that have not yet been identiﬁed.
2.4 Limitations
Our approach is effective, but has a number of chal-
lenges and limitations. First, the overhead of cloning a
VM, rendering content within it, and detecting trigger
conditions is potentially high. In Section 3 we describe
several optimizations to eliminate or mask this overhead,
and we evaluate the success of these optimizations in
Section 4. Second, our trigger monitoring system should
be located outside the VM rather than inside it, to prevent
it from being tampered with or disabled by the malware
it is attempting to detect. Though we have not done so,
we believe we could modify our implementation to use
techniques such as VM introspection [18] to accomplish
this. Third, pre-executing Web content on-the-ﬂy raises
several correctness and completeness issues, which we
discuss below.
2.4.1 Non-determinism
With SpyProxy in place, Web content is rendered
twice, once in the VM’s sandboxed environment and
once on the client. For our technique to work, all at-
tacks must be observed by the VM: the client must never
observe an attack that the VM-based execution missed.
This will be true if the Web content is deterministic and
follows the same execution path in both environments. In
this way, SpyProxy is ideal for deterministic Web pages
that are designed to be downloaded and displayed to the
user as information.
However, highly interactive Web pages resemble
general-purpose programs whose execution paths depend
on non-deterministic factors such as randomness, time,
unique system properties, or user input. An attacker
could use non-determinism to evade detection. For ex-
ample, a malicious script could ﬂip a coin to decide
whether to carry out an attack; this simple scheme would
defeat SpyProxy 50% of the time.
As a more pertinent example, if a Web site relies on
JavaScript to control ad banner rotation, it is possible that
the VM worker will see a benign ad while the client will
see a malicious ad. Note, however, that much of Inter-
net advertising today is served from ad networks such
as DoubleClick or Advertising.com.
In these systems,
a Web page makes an image request to the server, and
any non-determinism in picking an ad happens on the
server side. In this case, SpyProxy will return the same
ad to both the VM worker and the client.
In general,
only client-side non-determinism could cause problems
for SpyProxy.
There are some potential solutions for handling non-
determinism in SpyProxy. Similar to ReVirt [12], we
could log non-deterministic events in the VM and re-
play them on the client; this likely would require exten-
sive browser modiﬁcations. We could rewrite the page to
make it deterministic, although a precise method for do-
ing this is an open problem, and is unlikely to generalize
across content types. The results of VM-based rendering
can be shipped directly to the client using a remote dis-
play protocol, avoiding client-side rendering altogether,
but this would break the integration between the user’s
browser and the rest of their computing environment.
None of these approaches seem simple or satisfactory;
as a result, we consider malicious non-determinism to be
a fundamental limitation to our approach. In our proto-
type, we did not attempt to solve the non-determinism
problem, but rather we evaluated its practical impact
on SpyProxy’s effectiveness. Our results in Section 4
demonstrate that our system detected all malicious Web
pages that it examined, despite the fact that the major-
ity of them contained non-determinism. We recognize
that in the future, however, an adversary could intro-
duce non-determinism in an attempt to evade detection
by SpyProxy.
2.4.2 Termination
Our technique requires that the Web page rendering
process terminates so that we can decide whether to
block content or forward it to the user. SpyProxy uses
browser interfaces to determine when a Web page has
been fully rendered. Unfortunately, for some scripts ter-
mination depends on timer mechanisms or user input,
and in general, determining when or whether a program
will terminate is not possible.
To prevent “timebomb-based” attacks, we speed up
the virtual time in the VM [28]. If the rendering times
out, SpyProxy pessimistically assumes the page has
caused the browser to hang and considers it unsafe. Post-
rendering events, such as those that ﬁre because of user
input, are not currently handled by SpyProxy, but could
be supported with additional implementation. For exam-
ple, we could keep the VM worker active after rendering
and intercept the events triggered because of user input to
forward them to the VM for pre-checking. The interposi-
tion could be accomplished by inserting run-time checks
similar to BrowserShield [33].
2.4.3 Differences Between the Proxy and Client
In theory, the execution environment in the VM and
on the client should be identical, so that Web page ren-
dering follows the same execution path and produces the
same side-effects in both executions. Differing environ-
ments might lead to false positives or false negatives.
In practice, malware usually targets a broad audience
and small differences between the two environments are
not likely to matter. For our system, it is sufﬁcient that
harmful side-effects produced at the client are a subset
of harmful side-effects produced in the VM. This im-
plies that the VM system can be partially patched, which
makes it applicable for all clients with a higher patch
level. Currently, SpyProxy uses unpatched Windows
XP VMs with an unpatched IE browser. As a result,
SpyProxy is conservative and will block a threat even if
the client is patched to defend against it.
There is a possibility that a patch could contain a bug,
causing a patched client to be vulnerable to an attack to
which the unpatched SpyProxy is immune [24]. We as-
sume this is a rare occurrence, and do not attempt to de-
fend against it.
2.5 Client-side vs. Network Deployment
As we hinted before, SpyProxy has a ﬂexible imple-
mentation: it can be deployed in the network infrastruc-
ture, or it can serve as a client-side proxy. There are
many tradeoffs involved in picking one or the other. For
example, a network deployment lets clients beneﬁt from
the workloads of other clients through caching of both
data and analysis results. On the other hand, a client-side
approach would remove the bottleneck of a centralized
service and the latency of an extra network hop. How-
ever, clients would be responsible for running virtualiza-
tion software that is necessary to support SpyProxy’s VM
workers. Many challenges, such as latency optimizations
or non-determinism issues, apply in both scenarios.
While designing our prototype and carrying out our
evaluation, we decided to focus on the network-based
SpyProxy. In terms of effectiveness, the two approaches
are identical, but obtaining good performance with a net-
work deployment presents more challenges.
3 Performance Optimizations
The simple proxy architecture described in section 2
will detect and block malicious Web content effectively,
but it will perform poorly. For a given Web page request,
the client browser will not receive or render any content
until the proxy has downloaded the full page from the re-
mote Web server, rendered it in a VM worker, and satis-
ﬁed itself that no triggers have ﬁred. Accordingly, many
of the optimizations that Web browsers perform to mini-
mize perceived latency, such as pipelining the transfer of
embedded objects and the rendering of elements within
the main Web page, cannot occur.
To mitigate the cost of VM-based checking in our
proxy, we implemented a set of performance optimiza-
tions that either enable the browser to perform its normal
optimizations or eliminate proxy overhead altogether.
3.1 Caching the Result of Page Checks
Web page popularity is known to follow a Zipf dis-
tribution [6]. Thus, a signiﬁcant fraction of requests
generated by a user population are repeated requests for
the same Web pages. Web proxy caches take advantage
of this fact to reduce Web trafﬁc and improve response
times [1, 13, 15, 21, 52, 53]. Web caching studies gener-
ally report hit rates as high as 50%.
Given this, our ﬁrst optimization is caching the result
of our security check so that repeated visits to the same
page incur the overhead of our VM-based approach only
once. In principle, the hit rate in our security check cache
should be similar to that of Web caches.
This basic idea faces complications. The principle
of complete mediation warns against caching security
checks, since changes to the underlying security pol-
icy or resources could lead to caching an incorrect out-
come [34]. In our case, if any component in a Web page
is dynamically generated, then different clients may be
exposed to different content. However, in our architec-
ture, our use of the Squid proxy ensures that no confu-
sion can occur: we cache the result of a security check
only for objects that Squid also caches, and we invalidate
pages from the security cache if any of the page’s objects
is invalid in the Squid cache. Thus, we generate a hit
in the security cache only if all of the Web page content
will be served out of the Squid proxy cache. Caching
checks for non-deterministic pages is dangerous, and we
take the simple step of disabling the security cache for
such pages.
3.2 Prefetching Content to the Client
In the unoptimized system shown in Figure 1, the
Web client will not receive any content until the entire
Web page has been downloaded, rendered, and checked
by SpyProxy. As a result, the network between the
client and the proxy remains idle when the page is be-
ing checked. If the client has a low-bandwidth network
connection, or if the Web page contains large objects,
this idle time represents a wasted opportunity to begin
the long process of downloading content to the client.
To rectify this, SpyProxy contains additional com-
ponents and protocols that overlap several of the steps
shown in Figure 1. In particular, a new client-side com-
ponent acts as a SpyProxy agent. The client-side agent
both prefetches content from SpyProxy and releases it
to the client browser once SpyProxy informs it that the
Web page is safe. This improves performance by trans-
mitting content to the client in parallel with checking the
Web page in SpyProxy. Because we do not give any Web
page content to the browser before the full page has been
checked, this optimization does not erode security.
In our prototype, we implemented the client-side
agent as an IE plugin. The plugin communicates with
the SpyProxy front end, spooling Web page content and
storing it until SpyProxy grants it authorization to release
the content to the browser.
3.3 The Staged Release of Content
Although prefetching allows content to be spooled
to the client while SpyProxy is performing its security
check, the user’s browser cannot begin rendering any of
that content until the full Web page has been rendered
and checked in the VM worker. This degrades respon-
siveness, since the client browser cannot take advantage
Figure 2: Staged release optimization. The progression of
events in the VM worker’s browser shows how staged release
operates on a Web page with two embedded objects. As em-
bedded objects become fully downloaded and rendered by the
VM worker’s browser, more of the Web page is released to the
client-side browser.
of its performance optimizations that render content well
before the full page has arrived.
We therefore implemented a “staged release” opti-
mization. The goal of staged release is to present con-
tent considered safe for rendering to the client browser
in pieces; as soon as the proxy believes that a slice of
content (e.g., an object or portion of an HTML page) is
safe, it simultaneously releases and begins transmitting
that content to the client.
Figure 2 depicts the process of staged release. A page
consists of a root page (typically containing HTML) and
a set of embedded objects referred to from within the root
page. As a Web browser downloads and renders more
and more of the root page, it learns about embedded ob-
jects and begins downloading and rendering them.
Without staged release, the proxy releases no content
until the full Web page and its embedded objects have
been rendered in the VM. With staged release, once the
VM has rendered an embedded object, it releases that
main pageembeddedobjectembeddedobjectmain pageembeddedobjectembeddedobjectmain pageembeddedobjectembeddedobjectmain pageembeddedobjectembeddedobjectmain pageembeddedobjectembeddedobjectmain pageembeddedobjectembeddedobjectnotdownloadeddownloaded and renderedbut not releaseddownloaded andreleased(a)(b)(c)(d)(e)(f)object and all of the root page content that precedes its
reference. If the client browser evaluates the root page in
the same order as the VM browser, this is safe to do; our