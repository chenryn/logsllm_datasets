作者在13个CDN厂商的CDN进行实验，分别为Alibaba Cloud、Tencent Cloud、Huawei
Cloud、Cloudflare、CDN77、Flastly、Azure、CDNsum、G-Core
Labs、CloudFront、Akamai、StackPath。作者首先测试各个厂商应对Range响应的策略。根据两种攻击类型来分别测试对Range请求的响应策略，分别为单一CDN应用场景下的Range请求测试，和多CDN应用场景下多段范围重叠Range请求测试。作者通过对比本地测试构造的Range请求，和源服务器接收到的请求，来判断CDN厂商对于Range请求的应对策略。
####  0x01：单一CDN应用场景下的测试（SBR）
作者通过构造两种Range请求来测试CDN的响应策略，一种是请求前几字节数据，另一种是请求末尾几字节请求数据。作者通过分析源服务器接受到的请求，来确定CDN的响应策略。最终得到的实验结果如下。
从表中可以看到Akamai, Alibaba Cloud, CDN77, CDNsun, Cloudflare, Fastly, G-Core Labs,
Huawei Cloud, and TencentCloud
都采取了删除策略。国内的三家厂商分别提供了是否开启Range请求的按钮，但是开启之后都容易被SBR攻击。其中微软的Azure当Range请求的范围低于8M时采用Deletetion策略。但是当目标资源高于8M，Azure将会采用Expansion策略，将Range头替换为`Range:
bytes=8388608-16777215`.KeyCDN和StackPath都采用Laziness策略，但是对于第一次Range请求，CDN不缓存目标资源。当再一次接受到目标资源时，CDN才会缓存。作者测试出以上13个CDN均能满足SBR攻击的条件。
####  0x02：多CDN应用场景下的多段范围重叠Range请求测试（OBR）
作者也对多CDN应用场景下可能存的多段范围重叠Range请求对各CDN进行测试，此次测试实际上是在测试满足OBR攻击两个条件的FCND和BCDN。作者得到的测试结果如表二、表三。
表格二中显示，CDN77、CDNsum、Cloudflare、StackPath等CDN对于多端范围重叠Range请求，没有任何改变直接转发，采用Laziness策略。满足发动OBR攻击FCND的Liness策略，如果这四个CDN厂商的CDN，在多CDN应用场景中被用作FCND那么就有可能遭受OBR攻击。
表格三中显示，Akamai、Azure、StackPath三个厂商，在处理多段范围重叠Range请求时，没有对范围重叠字段进行检查，同时会对多段范围范围重叠Range请求，做出相应。也就是说当用户构造的请求为`Range:
bytes=-n,-n,-n,-n,-n,....`,m次`-n`请求，那么在FCND和BCND服务器之间传输的数据将是m*目标资源大小的流量。
###  0x02：第二次试验
第二次试验中作者测试SBR攻击可以将流量放大的系数。作者对以上提及的13个CDN进行SBR攻击测试，测试SBR攻击能够将原始攻击流量放大的系数。实验的方法为：作者分别在源服务器上放上1MB、10MB、25MB的资源。通过抓取作者发送的攻击流量包和捕获源服务器向CDN发送的数据包，计算出两个数据包之间流量数据相差倍数，即为放大的系数。作者得到的结果如下所示。
从图中我们可以看流量被放大的倍数还是非常可观的，1MB最小被放大的系数为724，25MB时被放大的系数最大为43330。从流量中可以发现其实返回的目标资源是一样大的，不同的是不同的CDN在对目标资源的请求时，会加上不同的请求头所以导致请求放大的系数有所差异。根据上表，作者绘制了放大系数与文件大小之间的图。
作者发现当使用Azure的CDN是当文件大小超过16MB时，随着目标资源的增大，放大系数达到稳定。同样的情况发生在CloudFront上，当文件大小超过10M时，放大系数不增大反而降低。同时作者通过绘制用户接受到的CDN返回的流量和文件大小的关系的图例。
发现KeyCDN返回用户的资源信息离谱的大，原因是因为KeyCDN每次需要至少发送两次Range请求，因此KeyCDN发给用户的响应数据比较大。
###  0x03:第三次实验
第三次实验作者主要是对OBR攻击进行了测试。进行OBR攻击首先需要FCND和BCDN满足条件，FCND需要满足的条件为：采用Lainess策略。在上文中的表二，作者测试出满足条件的四个CDN为：CDN77、CDNsum、Cloudflare、StackPath。BCDN需要满足的条件为：会对多段重叠的Range请求做出响应，通过不会检查Range请求范围是否重叠。在上文中的表三，作者测试出满足条件的三个CDN为：Akamai、Azure、StackPath。接着作者对这12中组合进行实验。作者通过将FCDN将源主机代理到一台服务器中，同时这台服务器将代理的请求转发至BCDN。抓取这台代理服务器的流量，最终获取到FCND和BCDN之间传输的流量数据。同时根据OBR攻击的理论指导。CDN之间传输的流量为分段Range传输中n的个数*目标资源的文件大小。但是CDN对于HTTP请求头大小存在限制：Akamai最大请求头为32KB、StackPath最大请求头为81KB、CDN77
和 CDNsun
请求头为16KB、Cloudflare限制请求头大小为：31KB（其中包含Host请求头），只有Azure限制Range请求头为64。作者为了不影响CDN厂商的工作，只在服务器上存放1KB的目标资源。而是将请求头能利用的空间沾满。从而获得最大的放大系数。作者得到的实验结果如下：
可以看到在BCDN和FCDN之间传输的流量非常的大。而原服务器和客户端接收到的流量却非常小。
###  0x04：第四次实验
第四次实验作者利用SBR攻击来实际测试下能够占用多少带宽。作者在服务器上放置10MB大小的目标资源文件，同时控制每秒发送的range请求的数量，得到用户带宽占用如下图所示。
此图的x轴为时间，Y轴为用户收到的响应数据所占用的带宽。不同颜色的折线表示每秒发送的rang请求的数量。可以看到无论每秒发送多少Range请求，用户的带宽都不会超过500Kb/s。作者接近着又对服务器端的出站流量进行分析。通过绘图结果如下所示。
作者服务器的带宽是1000MB，但是通过SBR攻击，在攻击客户端最高带宽不到500KB/S，能让服务器的1000Mb的带宽全部占满。
###  0x05:原因分析
同时作者发现HTTP2.0中依然是继承了，HTTP1.0中的Range请求策略。作者认为根本的原因在于RFC文档中定义不明确和服务商的安全疏忽造成了这个漏洞的产生。
## 0x05：漏洞复现
作者最后将漏洞提交给各大厂商，收到了各大厂商的好评，论文上说各大厂商修补了这个漏洞。就在看完实验部分想立马动身开始搞一下的时候，作者给我泼了一把冷水，最后我全当测试着玩，发现了小惊喜。华XX，并没有完全修补这个漏洞。在服务器上放10M的文件，burp35线程发包。100Mb的带宽一分钟之内打满。效果如下。
复现过程如下，只要把自己的域名在华某云上加速，然后dig查询下自己的域名是否被加速。
只要出现.cdnhwc2.com结尾的CNAME就证明加速成功。接着在后台开启Range回源选项。
接下来放在服务器上一个资源，这里我放的是1M.zip。利用HTTP range request 请求CDN。具体请求如下：
    GET /1M.zip?9989z=z HTTP/1.1
    Host: www.xxx.xxx
    Range: bytes=0-0
    Content-Length: 4
    Connection: close
其中文件后面的参数是来绕过CDN的缓存的。请求过程中抓取源服务器的数据包得到如下结果。
`0-524287`是0.5M的资源。他的响应策略就是每次缓存0.5Mb的资源缓存到服务器上。但是对于`Range:
bytes=9999-`,或者是重叠的Range请求，依然采取的是缓存整个目标资源。而且是每次请求0.5M的资源。10M的资源他需要去发送20个Range请求。可以构造请求如下。
    GET /10M.zip?9989z=z HTTP/1.1
    Host: www.xxx.xxx
    Range: bytes=0-1,1-1
    Content-Length: 4
    Connection: close
源服务器接收到的请求流量数据为下图所示。
请求了多次，每次请求0.5MB的资源。
最后burp一把梭，线程开高点，一会就会把源服务器打躺下。
最后想测试一把OBR攻击，作者测试的那个存在OBR攻击的CDN厂商，有几个需要信用卡来注册。比较麻烦，时间又不怎么够就没有测试。
## 0x06：总结
仔细读了这篇文章，复现加上写笔记补知识花了一个星期整吧，也是满满的收获。其实仔细一想作者的攻击手段并不复杂，但是其创新的思路和攻击方法是很难想到的。作者能够发现这样的漏洞一定是有很深厚的基础知识，看了很多类似的论文。从这篇文章我学到一点去翻看官方的RFC文档真的很重要，很具有权威性。最后本菜鸡第一次发文，大佬轻喷。