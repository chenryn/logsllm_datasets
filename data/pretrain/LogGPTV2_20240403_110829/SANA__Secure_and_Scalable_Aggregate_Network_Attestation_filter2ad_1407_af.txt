if and only if all devices in G (at least those that are not physically
attacked) are running a software it agrees on. We formalize this
between an adversary A (as
goal as a security experiment Exp
deﬁned in Section 2.3), G and V. In this experiment, A physically
attacks a number of provers P1, . . . Pp, and modiﬁes the software
of at least one prover Pc that it did not physically attack. A may
have full control of all aggregators. After a polynomial number (in
terms of the security parameters (cid:96)N , (cid:96)c, and (cid:96)Sign) of steps by A, V
outputs its decision r = 1 indicating it accepts the attestation result,
A
or r = 0 otherwise. The result of the experiment is deﬁned as the
output of V, i.e., Exp
= r. A secure collective attestation scheme
A
is deﬁned as follows:
collective attestation scheme is secure if Pr(cid:2)r = 1|Exp
DEFINITION 4
(SECURE COLLECTIVE ATTESTATION). A
(1(cid:96)) = r(cid:3)
is negligible in (cid:96) = f ((cid:96)N , (cid:96)c, (cid:96)Sign), where the function f is
polynomial in (cid:96)N , (cid:96)c, and (cid:96)Sign.
A
THEOREM 1
(SECURITY OF SANA). SANA is a secure col-
lective attestation scheme (Deﬁnition 4) if the underlying Aggregate-
Multi Signature (OAS) scheme is not forgeable (Deﬁnition 3).
PROOF (SKETCH) OF THEOREM 1. The veriﬁer V returns r =
i.e., accepts an attestation response α1 only if B =
1,
B = φ, and M = (cid:0)hash(h1| . . .|hz)(cid:1)|N|cl|vl. N is the nonce,
{(m1, S1), . . . , (mµ, Sµ)} = Verify(apk , S⊥, M , α1), where
apk is the OAS aggregate public key of all provers in G, S⊥ = φ,
h1, . . . , hz are all the benign software conﬁgurations included in H,
and cl (resp. vl) is the id (resp. value) of the counter previously sent
by V. To avoid detection of a compromised prover Pc, A can use
one of the following strategies: (1) A does not alter the response
from Pc; (2) A uses an old signature αold previously generated
by Pc on the good software conﬁguration hg; (3) A modiﬁes H
to include the software conﬁguration of Pc; (4) A generates an
aggregate signature that attributes a response M = hg|N|cl|vl to
Pc; or (5) A modiﬁes the aggregate public keys apk sent from the
owner O to V during tokenReq protocol.
We start with strategy (1). According to our assumptions in Sec-
tion 2, A can neither tamper with the code performing integrity
measurements on Pc nor extract its secret signing key sk c. Con-
sequently, the response of Pc will include an OAS signature on
hc|N|cl|vl, where hc is the current software conﬁguration of Pc.
Since hc is the security conﬁguration of a maliciously modiﬁed
software, V will always return r = 0, if the underlying integrity
measurement mechanism that generates the software conﬁguration
can detect this modiﬁcation (i.e., hc /∈ H). On the other hand, if
A uses an old signature αold over Mold = hg|Nold|cl|vl (Strategy
(2)), B will be equal to φ only if N = Nold, which is negligible
in (cid:96)N , where (cid:96)N represents the size of the nonce. Consequently, V
will always return r = 0.
Next, we consider strategy (3), where the adversary modiﬁes
H to include the software conﬁguration hc of Pc. Since H is
part of the authenticated token T , A should forge the signature σ1
generated by the owner O. The success probability of this strategy
is negligible in (cid:96)(cid:48)Sign, where (cid:96)(cid:48)Sign represents the security parameter
of the digital signature scheme used. Note that, H is also included
in αc. Therefore, any modiﬁcation to H consequently changes αc.
According to strategy (4), A may generate an aggregate signa-
ture that attributes m = hg|N|cl|vl to Pc, where N is the fresh
nonce sent by V. Since the current software of Pc is not in H, and
since N is a fresh nonce, the probability of Pc signing hg|N|cl|vl
is negligible in (cid:96)N . Consequently, as OAS is unforgeable accorf-
ing to Deﬁnition 3, the probability of ﬁnding such an aggregate is
negligible in (cid:96)Sign, where (cid:96)Sign represents OAS security parameter.
Finally, we consider A modifying the aggregate public key apk,
and replacing pkc with pkA, to which it knows the secret key skA.
A can at this point sign arbitrary messages (including attestation
responses) on behalf of Pc, regardless of Pc’s current software
conﬁguration. However, since the integrity of apk is protected
with a digital signature, the probability of success of this attack is
negligible in (cid:96)N and (cid:96)(cid:48)Sign.
Consequently, the probability of A making V return r = 1, when
it has maliciously modiﬁed the software of one prover Pc in G
pk(cid:48)
pk(cid:48)
that
aggregation
∈S⊥ pk(cid:48).
∈S⊥ pk(cid:48) = gx
(that it did not physically attacked), is negligible in (cid:96)N , (cid:96)Sign, and
(cid:96)(cid:48)Sign. Similarly, if none of the provers is physically attacked, the
probability of A making V return r = 1, when at least one device
has a malicious software is negligible in (cid:96)N , (cid:96)Sign, and (cid:96)(cid:48)Sign.
B. CORRECTNESS AND SECURITY OAS
(cid:81)
Correctness.
If sk = x and all parties behave honestly, then
2 and apk = AggPK(S⊥ ∪ {pk}) =
we have that pk = gx
µ = 0, apk M = apk /(cid:81)
If m = M , then α = Sign(sk , m, M ) =
gx
2
(τ,B) = (H(M )x,∅) so that during veriﬁcation we have that
2 , and e(τ, g2) =
e(H(M )x, g2) = e(H(M ), apk M ) as required. If m (cid:54)= M , then
apk /(pk ·(cid:81)
α = Sign(sk , m, M ) = (τ,B) = (H(m)x,{(m,{pk})} so that
during veriﬁcation we have that µ = 1, apk 1 = pk = gx
2 , apk M =
pk(cid:48)inS⊥ pk(cid:48)) = 1, and, since e(H(M ), 1) = 1, that
e(τ, g2) = e(H(m)x, g2) = e(H(m), apk1) as required.
works,
To
if
see
Verify(AggPK(Sj), S⊥,j, αj, M ) = Bj for j = 1, 2, by the
veriﬁcation equation (2) it holds that
e(τj , g2) = e(cid:0)H(M ), apk M ,j(cid:1) ·
where apk i,j = (cid:81)
SM ,j = Sj \ S⊥,j \(cid:83)
e(τ1τ2, g2) = e(cid:0)H(M ), apk M ,1apk M ,2(cid:1)
µ1(cid:89)i=1
µ2(cid:89)i=1
e(cid:0)H(mi,1), apk i,1(cid:1) ·
e(cid:0)H(mi,2), apk i,2(cid:1)
= e(cid:0)H(M ), apk M(cid:1) · (cid:89)(mi,Si)∈B
e(cid:0)H(mi), apk i(cid:1) .
where apk M = (cid:81)
pk and
B = B1 (cid:116) B2. The second equality follows from the disjointness of
S1 and S2 and the deﬁnition of the merging operator (cid:116).
Security. We now prove the security of our OAS scheme based on
the computational co-Difﬁe-Hellman assumption, that is deﬁned as
follows.
pk and apk M ,j = (cid:81)
pk, apk i = (cid:81)
e(cid:0)H(mi,j ), apk i,j(cid:1) ,
pk for
Si,j. Multiplying the veriﬁca-
tion equations for j = 1, 2 gives
pk∈SM ,1∪SM ,2
(mi,j ,Si,j )∈Bj
pk∈Si,j
pk∈SM ,j
µj(cid:89)i=1
pk∈Si
·
DEFINITION 5. We say that
the computational co-Difﬁe-
Hellman problem in (G1, G2) is hard if the probability that a
polynomial-time adversary A, on input g2, ga
2 , h where a ←R Zp
and h ←R G1, outputs ha is negligible.
THEOREM 2. If the computational co-Difﬁe-Hellman (co-CDH)
problem is hard in (G1, G2), then the above OAS scheme is unforge-
able in the random-oracle model.
PROOF. Given an adversary A against the unforgeability of the
OAS scheme as per Deﬁnition 3, we construct an adversary B that
solves the co-CDH problem in (G1, G2). Algorithm B gets as input
2 , h. It runs A on input pk = ga
2 , answering its oracle queries
g2, ga
as follows:
• Random-oracle queries H(m): Without loss of generality, we
assume that A never asks the same random-oracle query twice
and always queries H(m) before querying a signature on m
or using it as part of its forgery. B guesses one query index
q∗ ←R {1, . . . , qH}, where qH is (an upper bound on) the
number of random-oracle queries issued by A. B answers all
of A’s random-oracle queries other than the q∗th query so that
it can generate a valid signature by choosing r ←R Zp, storing
(m, r) and returning gr
1 as random-oracle response. For the
q∗th query, B stores (m,⊥) and returns h as response.
2
{pk 1, . . . , pk n}\S⊥\(cid:83)
r = ⊥ then B aborts. Otherwise, it returns ψ((ga
as the target signer’s signature for m.
• Signature queries Sign(sk , m): B looks up a tuple (m, r). If
2 )r) = gar
1
When A produces its output (α = (τ,B), S⊥, (pk 1, . . . , pk n),
(sk 1, . . . , sk n)), it checks that pk i = gsk i
for all i = 1, . . . , n
such that pk i (cid:54)= pk, and runs apk ← AggPK({pk 1, . . . , pk n}). It
veriﬁes the signature as B ← Verify(apk , S⊥, α, M ). Let SM =
Si. For A to be successful in its
attack, it must hold that S⊥ ⊆ S and Si ⊆ S for all (mi, Si) ∈ B,
and hence by consequence that SM ⊆ S. Also, there must either
exist (m∗, S∗) ∈ B such that pk ∈ S∗ and m∗ was never queried
from the Sign oracle, or it must hold that pk ∈ SM and A never
queried M from the Sign oracle. In the ﬁrst case, with probability
1/qH, m∗ was A’s q∗th random-oracle query. If not, B aborts;
otherwise, B knows the discrete logarithms rM of H(M ) and ri
of H(mi) for mi (cid:54)= m∗. It can compute a solution to the co-CDH
problem as follows. From the veriﬁcation equation, we know that
(mi,Si)∈B
e(τ, g2) = e(cid:0)H(M ), apk M(cid:1) · (cid:89)(mi,Si)∈B
= e(cid:0)ψ(apk M )rM , g2(cid:1) · (cid:89)(mi, Si) ∈ B
hsk i , g2(cid:1) · e(cid:0)ha, g2(cid:1).
· e(cid:0) (cid:89)pk i∈Si\{pk}
mi (cid:54)= m∗
e(cid:0)H(mi), (cid:89)pk∈Si
e(cid:0) (cid:89)pk∈Si
pk(cid:1)
ψ(pk )ri , g2(cid:1)
One can therefore compute ha as
τ·(cid:18)ψ(apk M )rM · (cid:89)(mi, Si) ∈ B
mi (cid:54)= m∗ (cid:89)pk∈Si
ψ(pk )ri· (cid:89)pk i∈Si\{pk}
hsk i(cid:19)−1
.
In the second case that m∗ = M , again with probability 1/qH we
have that M was A’s q∗th random-oracle query. If so, then B knows
all discrete logarithms ri of H(mi), so that the veriﬁcation equation
becomes
e(τ, g2) = e(cid:0) (cid:89)pk i∈SM
· (cid:89)(mi,Si)∈B
hsk i , g2(cid:1) · e(cid:0)ha, g2)
e(cid:0) (cid:89)pk∈Si
ψ(pk )ri , g2(cid:1).
B can compute ha as
τ ·(cid:18) (cid:89)pk i∈SM
ω ← (cid:89)pk j∈S∗
\{pk}
hsk i · (cid:89)(mi,Si)∈B (cid:89)pk∈Si
ψ(pk )ri(cid:19)−1
.
H(m∗) (cid:89)(mi,Si)∈B (cid:89)pk j∈Si
H(mi)sk j · (cid:89)i : pk i = pk
∧mi (cid:54)= mi∗
(ga
2 )ri
σ ← τ /ω
Note that, for this reduction to work, we really rely on the fact that
S⊥ and Si are all subsets of S, because otherwise B does not know
the necessary secret keys.