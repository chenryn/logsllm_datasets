co-CDH
co-CDH, ROM
TABLE I: Efﬁciency of multi-signatures in the key veriﬁcation model. The ﬁrst block of schemes depicts all known two-
round multi-signature schemes without pairings. For completeness, we also include existing three-round schemes as well as
non-interactive pairing-based schemes in the second and third blocks. Columns 2–5 show the computational efﬁciency of the
individual algorithms by counting the number of (multi-)exponentiations and pairings, where “G” denotes an exponentiation
in group G, “Gk” denotes an k-multi-exponentiation in group G, “P ” denotes a pairing operation, and n denotes the number
of signers. Column 6 shows the number of communication rounds and columns 7–9 show the size of the individual signer’s
public key, the signature, and the aggregated public key, respectively, where any “proof-of-possession” of the secret key is
considered to be part of the public key, and q denotes the order of the groups. Column 10 shows the assumptions under which
the scheme is proved secure, if any, where “ROM” indicates a proof in the random-oracle model.
2.2 Algebraic Algorithms
Boneh and Venkatesan [BV98] deﬁne algebraic algorithms
to study the relation between breaking RSA and factoring. An
algorithm working in some group is algebraic if it only uses the
group operations to construct group elements. More precisely,
it can test equality of two group elements, perform the group
operation on two elements to obtain a new element, and invert
a group element. This means that an algebraic algorithm that
receives group elements y1, . . . , yn as input can only construct
new group elements y for which it knows α1, . . . , αn such that
y =
(cid:5)
We use the formalization by Paillier and Vergnaud [PV05]:
Deﬁnition 3. An algorithm A that on input group elements
(y1, . . . , yn) is algebraic if it admits a polynomial time algo-
rithm Extract that given the code of A and its random tape
outputs (α1, . . . , αn) such that h =
for any group
element h that A outputs.
i=1 yαi
i=1 yαi
(cid:5)
n
n
.
i
i
GFA(in):
f = (ρ, h1, . . . , hqH ) ←$ Ω
(J,{out j}j∈J , aux ) ← AO
If J = ∅ then output fail
Aux ← aux
Let J = {j1, . . . , jn} such that j1 ≤ . . . ≤ jn
For i = 1, . . . , n do
(in, f )
succi ← 0 ; ki ← 0 ; kmax ← 8nqH/ · ln(8n/)
Repeat until succi = 1 or ki > kmax
(cid:3)(cid:3)|ji = f|ji
(cid:3)(cid:3)
(cid:3)(cid:3)
= (ρ, h1, . . . , hji−1, h
ji , . . . , h
qH )
}j∈J(cid:2)(cid:2) , aux ) ← AO
(cid:3)(cid:3)
(in, f
)
(cid:3)(cid:3) (cid:9)= ∅ and ji ∈ J
ji ; succi ← 1
(cid:3)(cid:3) ←$ Ω such that f
f
(cid:3)(cid:3)
Let f
,{out(cid:3)(cid:3)
(cid:3)(cid:3)
(J
Aux ← Aux ∪ aux
(cid:9)= hji and J
(cid:3)(cid:3)
If h
← out(cid:3)(cid:3)
out(cid:3)
ji
then
(cid:3)(cid:3)
ji
j
If succi = 1 for all i = 1, . . . , n
Then output (J,{out j}j∈J ,{out(cid:3)
Else output fail
j
}j∈J , Aux )
2.3 Generalized Forking Lemma
We recall here a slight modiﬁcation of the forking lemma
of Bagherzandi, Cheon, and Jarecki [BCJ08]. Let A be an
algorithm that is given an input in as well as randomness f =
(ρ, h1, . . . , hqH ), where ρ is A’s random tape and h1, . . . , hqH
are random values from Zq. Let Ω be the space of all such
vectors f and let f|i = (ρ, h1, . . . , hi−1). We consider an
execution of A on input in and randomness f with access
to oracle O, denoted AO
(in, f ), as successful if it outputs a
tuple (J,{out j}j∈J , aux ), where J is a multi-set that is a non-
empty subset of {1, . . . , qH}, {out j}j∈J is a multi-set of side
outputs, and aux is an additional set of auxiliary outputs. We
say that A failed if it outputs J = ∅. Let  be the probability
that A(in, f ) is successful for fresh randomness f ←$ Ω and
for an input in ←$ IG generated by an input generator IG.
For a given input in, the generalized forking algorithm GFA
is deﬁned as follows:
We say that GFA succeeds if it doesn’t output fail. The
difference to Bagherzandi et al.’s forking lemma [BCJ08] is
A’s access to the oracle O and the additional auxiliary output
aux that gets accumulated in Aux over all runs of A, including
failed runs. If the oracle O is deterministic, meaning that it
always answers the same query with the same response, it is
easy to see that these extensions do not impact the bounds of
their forking lemma, so the following statement continues to
hold.
Lemma 1 (Generalized Forking Lemma [BCJ08]). Let IG be
a randomized algorithm and A be a randomized algorithm
running in time τ with access to a deterministic oracle O that
succeeds with probability . If q > 8nqH/, then GFA(in)
runs in time at most τ · 8n2qH/ · ln(8n/) and succeeds
with probability at least /8, where the probability is over
the choice of in ←$ IG and over the coins of GFA.
(cid:18)(cid:17)(cid:25)(cid:23)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:45:54 UTC from IEEE Xplore.  Restrictions apply. 
2.4 Security of Multi-Signatures
the model
We follow the syntax and security model due to Bagherzandi
et al. [BCJ08], which follows the so-called key-veriﬁcation
model, as introduced by Bagherzandi and Jarecki [BJ08],
where individual public keys must be veriﬁed by the signature
veriﬁer. We adapt
to support signers that are
organized in a tree structure for more efﬁcient communication.
Prior work always assumed a communication setting where
every cosigner communicates directly with the initiator, which
our tree-based modeling supports by choosing a tree in which
every cosigner is a direct child of the initiator. Moreover,
we formalize the notion of an “aggregated key” of a group
of signers, by adding an algorithm that computes a single
aggregated public key from a set of public keys, and this
aggregated key will be used by the veriﬁcation algorithm. The
idea of splitting key aggregation from veriﬁcation is that if a
group of signers will repeatedly sign together, a veriﬁer will
only once compute the aggregate public key and reuse that
for later veriﬁcations. If the aggregated key is smaller than
the set of public keys, or even constant size, this will allow
for more efﬁcient schemes. Note that this change does not
exclude multi-signature schemes that do not have this feature:
indeed, such schemes can simply use the identity function as
key aggregation algorithm.
A multi-signature scheme consists of algorithms Pg, Kg,
Sign, KAg, KVf, and Vf. A trusted party generates the
system parameters par ← Pg. Every signer generates a
key pair (pk , sk ) ←$ Kg(par ), and signers can collectively
sign a message m by each calling the interactive algorithm
Sign(par , sk ,T , m), where T describes a tree between the
signers that deﬁnes the intended communication between the
signers. At the end of the protocol, the root of the tree T
obtains a signature σ. Algorithm KAg on input parameters par
and a set of public keys PK outputs a single aggregate public
key PK . A veriﬁer can check the validity of a signature σ
on message m under an aggregate public key PK by running
Vf(par , PK , m, σ) which outputs 0 or 1 indicating that the
signatures is invalid or valid, respectively. Anybody can check
the validity of a public key by using key veriﬁcation algorithm
KVf(par , pk ).
First, a multi-signature scheme should satisfy completeness,
meaning that 1) for any par ← Pg and any (pk , sk ) ←
Kg(par ), we have KVf(par , pk ) = 1, and 2) for any n, if
i, sk i) ← Kg(par ) for i = 1, . . . , n, and any tree
we have (pk
T containing exactly these n signers, and for any message
m, if all signers input Sign(par , sk i,T , m), then the root
of T will output a signature σ such that Vf(par , KAg(par ,
{pk
a) Setup: The challenger generates
, sk∗
i
Second, a multi-signature scheme should satisfy unforge-
ability. Unforgeability of a multi-signature scheme MS =
(Pg, Kg, Sign, KAg, Vf, KVf) is deﬁned by a three-stage game.
the parameters
) ←$ Kg(par ). It
par ← Pg and a challenge key pair (pk∗
runs the adversary on the public key A(par , pk∗
b) Signature queries: A is allowed to make signature
queries on a message m with a tree T , meaning that it has
access to oracle OSign(par ,sk∗
,·,·) that will simulate the honest
signer interacting in a signing protocol to sign message m
}n
i=1), m, σ) = 1.
).

m
Children Ci
Signer Si
{(PK j, tj)}j∈Ci- r ←$ Zq
(cid:5)
ti ← gr
(cid:5)
j∈Ci tj
PK i ← yi
j∈Ci
c ← H0(¯t, m)
{sj}j∈Ci - si ← r + csk i
(¯t, PK )
(cid:6)

Parent Pi
m
PK j
(ti, PK i)-
(¯t, PK )

+
j∈Ci sj mod q
si -
Fig. 1: The CoSi signing protocol for signer Si with secret
key sk i and public key pk = (yi, πi). If Si is the leader then,
instead of sending (ti, PK i) to its parent, it sends (¯t, PK ) =
(ti, PK i) to its children, and instead of sending si to its parent,
it outputs (c, s) = (c, si) as the signature.
with intended communication tree T . Note that A may make
any number of such queries concurrently.
c) Output: Finally, the adversary halts by outputting a
multi-signature forgery σ, a message m and a set of public
keys PK. In the key-veriﬁcation setting, the adversary wins
if pk∗ ∈ PK, KVf(par , pk ) = 1 for every pk ∈ PK with
, PK ← KAg(par ,PK), Vf(par , PK , σ, m) = 1,
pk (cid:9)= pk∗
and A made no signing queries on m. A special case of
the key-veriﬁcation model
is the plain public key model,
where there is no need to verify individual public keys, i.e.,
KVf always returns 1.1 In the weaker knowledge-of-secret-
key (KOSK) setting, the adversary is required to additionally
output corresponding secret keys sk pk for all pk ∈ PK, pk (cid:9)=
pk∗
Deﬁnition 4. We say A is a (τ, qS, qC, qH, )-forger for multi-
signature scheme MS = (Pg, Kg, Sign, Vf) if it runs in time
τ, makes qS signing queries such that at most qC signing
protocols are concurrently active (i.e., started but not yet
ﬁnished) at any given time, makes qH random oracle queries,
and wins the above game with probability at least . MS
is (τ, qS, qC, qH, )-unforgeable if no (τ, qS, qC, qH, )-forger
exists.
.
2.5 The CoSi Multi-Signature Scheme
CoSi is a multi-signature scheme introduced by Syta et
al. [STV+16] that follows a long line of work on Schnorr-
based multi-signatures [MOR01], [BN06], [RY07], [BCJ08],
[MWLD10]. With a two-round signing protocol and veriﬁ-
cation as efﬁcient as verifying a single Schnorr signature,
CoSi is more efﬁcient than prior schemes, but it was proposed
without a formal security proof. By organizing signers in a tree
structure, thousands of signers can create a multi-signature in
seconds, as demonstrated by the open source implementation.2
Since its recent introduction, CoSi has already led to a large
1The distinction between the key-veriﬁcation model and plain public key
model is a bit informal, as they are in fact equivalent: any multi-signature
scheme that is unforgeable in the key-veriﬁcation model is also secure in the
plain public key model, where the key veriﬁcation is simply considered part
of the veriﬁcation algorithm.
2The implementation is available at github.com/dedis/cothority.
(cid:18)(cid:17)(cid:25)(cid:24)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:45:54 UTC from IEEE Xplore.  Restrictions apply. 
body of follow-up work [KJG+16], [SJKK+17], [BKJ+17],
[NKJ+17], [KKJG+18].
Below, we describe a slight variant of the original CoSi
scheme where we add a proof of possession to the public
key, and where during signing the cosigners receive the ﬁnal
commitment value ¯t instead of just the hash c = H(¯t, m). The
ﬁrst change was already suggested in the original paper, the
latter is necessary because the scheme is insecure without it,
since signers are unable to ensure that they are signing the
message that they intended to sign.
Parameters generation. The Pg algorithm sets up a group
G = (cid:2)g(cid:3) of order q, where q is a κ-bit prime. It also
Zq. Output par ←
chooses two hash functions H0, H1 : {0, 1}∗
(G, g, q, H0, H1).
Key generation. The key generation algorithm Kg(par ) sam-
ples sk ←$ Zq and computes y ← gsk . It then generates a proof
of possession π = (c, s) by choosing r ←$ Zq and computing
s ← r + H1(gr, y). Output pk ← (y, π) and sk.
Signing. Signing is a four-step protocol. A signer Si on input
Sign(par , sk i, m,T ) behaves as follows.
Announcement. If Si is the leader (i.e., the root of tree T ),
it initiates the protocol by sending an announcement to its
children, which consists of a unique identiﬁer for this signing
session ssid. If Si is not the leader, it waits to receive an
announcement message and forwards it to its children in T .
After doing so, Si proceeds with the commitment phase.
Commitment. Let Ci denote the set of children of Si in tree
T . Si waits to receive all values (tj, PK j) for j ∈ Ci. Note
that if Si has no children (i.e., it is a leaf in tree T ), it will
gri ·(cid:5)
proceed immediately. Si chooses ri ←$ Zq and computes ti ←
i = (yi, πi).
If Si is not the leader, it sends ti to its parent. If Si is the
leader, Si proceeds with the challenge phase.
Challenge. If Si is the leader, it sets ¯t ← ti and PK ← PK i,
computes c ← H0(¯t, m), and sends (¯t, PK ) to its children.
If Si is not the leader, it waits to receive a message (¯t, PK ),
computes c ← H0(¯t, m), and sends (¯t, PK ) to its children.
Response. Si waits to receive all values sj for j ∈ Ci (note that
if Si is a leaf it will proceed immediately), and then computes
si ← ri + c · sk i +
j∈Ci sj. It sends si to its parent, unless
Si is the root, then Si sets s ← si and outputs σ ← (c, s).
Key Aggregation. On input a set of public keys PK, KAg
it outputs aggregate public key PK ← (cid:5)
checks for all (y, (c, s)) ∈ PK that c = H1(gsy
−c, y). If so,
(cid:8)
gs · PK −c, m
Veriﬁcation. Vf on input an aggregate public key PK , a
signature σ = (c, s), and a message m, checks that
j∈Ci tj and PK i ← yi ·(cid:5)
(y,π)∈PK y.
PK j for pk
(cid:6)
j∈Ci
c ?= H0
(cid:7)
.
included in the same paper, we describe the BCJ scheme for
that instantiation here. We also adapt the scheme to support
signers in a tree structure.
Parameters generation. Pg sets up a group G of order q
with generators g1, h1, g2, and h2, where q is a κ-bit prime.
Choose hash functions H0, H1 : {0, 1}∗ → Zq and output
par ← (G, g1, h1, g2, h2, q, H0, H1).
Key generation. The key generation algorithm Kg(par ) takes
sk ←$ Zq and sets y ← gsk
1 . Compute proof-of-posession π =
(c, s) by taking r ←$ Zq, c ← H1(y, gr
1), s ← r + c · sk. Let
pk ← (y, π) and output (pk , sk ).
Signing. Signing is the four-step protocol. A signer Si on input
Sign(par , sk i, m,T ) behaves as follows.
Announcement. If Si is the leader (i.e., the root of tree T ),
it initiates the protocol by sending an announcement to its
children, which consists of a unique identiﬁer for this signing
session ssid. If Si is not the leader, it waits to receive an
announcement message and forwards it to its children in T .
After doing so, Si proceeds with the commitment phase.
Commitment. Let Ci denote the set of children of Si in tree
T . Si waits to receive all values (tj,1, tj,2, PK j) for j ∈ Ci.
Note that if Si has no children (i.e., it is a leaf in tree T ), it
will proceed immediately. Si chooses (ri, αi,1, αi,2) ←$ Z3
q and
·(cid:5)
computes ti,1 ← gαi,1
·
j∈Ci tj,1 and ti,2 ← gαi,1
2 hαi,2
2
gri
PK j. If Si is not the
1
leader, it sends (ti,1, ti,2, PK i) to its parent. If Si is the leader,
Si proceeds with the challenge phase.
Challenge. If Si is the leader, it sets ¯t1 ← ti,1, ¯t2 ← ti,2,
and PK ← PK i. It computes c ← H0(¯t1, ¯t2, PK , m), and
sends (¯t1, ¯t2, PK ) to its children. If Si
is not the leader,
it waits to receive a message (¯t1, ¯t2, PK ), computes c ←
H0(¯t1, ¯t2, PK , m), and sends (¯t1, ¯t2, PK ) to its children.
Response. Si waits to receive all values (sj, γj,1, γj,2) for j ∈
Ci (note that if Si is a leaf it will proceed immediately), and
(cid:6)
then computes si ← ri + c · sk i +
j∈Ci sj, γi,b ← αi,b +
j∈Ci γj,b for b ∈ {1, 2}. It sends (si, γi,1, γi,2) to its parent,
unless Si is the root, then Si sets s ← si, γ1 ← γi,1, γ2 ←
γi,2, and outputs σ ← (¯t1, ¯t2, s, γ1, γ2).
Key Aggregation. KAg on input a set of public keys PK
∈ PK as (yi, (ci, si)), and if this public key
parses every pk
Output aggregate public key PK ← (cid:5)
−ci
has not been validated before, check that ci = H1(yi, gsi
).
1 y
i
j∈Ci tj,2, and PK i ← yi ·(cid:5)
1 hαi,2
·(cid:5)
(cid:6)
j∈Ci
(y,π)∈PK y.
1
i
Veriﬁcation. Vf on input aggregate public key PK , a sig-
nature σ = (¯t1, ¯t2, s, γ1, γ2), and a message m, compute