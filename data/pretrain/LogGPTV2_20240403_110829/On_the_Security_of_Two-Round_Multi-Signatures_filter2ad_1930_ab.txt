co-CDH
co-CDH, ROM
TABLE I: Efï¬ciency of multi-signatures in the key veriï¬cation model. The ï¬rst block of schemes depicts all known two-
round multi-signature schemes without pairings. For completeness, we also include existing three-round schemes as well as
non-interactive pairing-based schemes in the second and third blocks. Columns 2â€“5 show the computational efï¬ciency of the
individual algorithms by counting the number of (multi-)exponentiations and pairings, where â€œGâ€ denotes an exponentiation
in group G, â€œGkâ€ denotes an k-multi-exponentiation in group G, â€œP â€ denotes a pairing operation, and n denotes the number
of signers. Column 6 shows the number of communication rounds and columns 7â€“9 show the size of the individual signerâ€™s
public key, the signature, and the aggregated public key, respectively, where any â€œproof-of-possessionâ€ of the secret key is
considered to be part of the public key, and q denotes the order of the groups. Column 10 shows the assumptions under which
the scheme is proved secure, if any, where â€œROMâ€ indicates a proof in the random-oracle model.
2.2 Algebraic Algorithms
Boneh and Venkatesan [BV98] deï¬ne algebraic algorithms
to study the relation between breaking RSA and factoring. An
algorithm working in some group is algebraic if it only uses the
group operations to construct group elements. More precisely,
it can test equality of two group elements, perform the group
operation on two elements to obtain a new element, and invert
a group element. This means that an algebraic algorithm that
receives group elements y1, . . . , yn as input can only construct
new group elements y for which it knows Î±1, . . . , Î±n such that
y =
(cid:5)
We use the formalization by Paillier and Vergnaud [PV05]:
Deï¬nition 3. An algorithm A that on input group elements
(y1, . . . , yn) is algebraic if it admits a polynomial time algo-
rithm Extract that given the code of A and its random tape
outputs (Î±1, . . . , Î±n) such that h =
for any group
element h that A outputs.
i=1 yÎ±i
i=1 yÎ±i
(cid:5)
n
n
.
i
i
GFA(in):
f = (Ï, h1, . . . , hqH ) â†$ Î©
(J,{out j}jâˆˆJ , aux ) â† AO
If J = âˆ… then output fail
Aux â† aux
Let J = {j1, . . . , jn} such that j1 â‰¤ . . . â‰¤ jn
For i = 1, . . . , n do
(in, f )
succi â† 0 ; ki â† 0 ; kmax â† 8nqH/ Â· ln(8n/)
Repeat until succi = 1 or ki > kmax
(cid:3)(cid:3)|ji = f|ji
(cid:3)(cid:3)
(cid:3)(cid:3)
= (Ï, h1, . . . , hjiâˆ’1, h
ji , . . . , h
qH )
}jâˆˆJ(cid:2)(cid:2) , aux ) â† AO
(cid:3)(cid:3)
(in, f
)
(cid:3)(cid:3) (cid:9)= âˆ… and ji âˆˆ J
ji ; succi â† 1
(cid:3)(cid:3) â†$ Î© such that f
f
(cid:3)(cid:3)
Let f
,{out(cid:3)(cid:3)
(cid:3)(cid:3)
(J
Aux â† Aux âˆª aux
(cid:9)= hji and J
(cid:3)(cid:3)
If h
â† out(cid:3)(cid:3)
out(cid:3)
ji
then
(cid:3)(cid:3)
ji
j
If succi = 1 for all i = 1, . . . , n
Then output (J,{out j}jâˆˆJ ,{out(cid:3)
Else output fail
j
}jâˆˆJ , Aux )
2.3 Generalized Forking Lemma
We recall here a slight modiï¬cation of the forking lemma
of Bagherzandi, Cheon, and Jarecki [BCJ08]. Let A be an
algorithm that is given an input in as well as randomness f =
(Ï, h1, . . . , hqH ), where Ï is Aâ€™s random tape and h1, . . . , hqH
are random values from Zq. Let Î© be the space of all such
vectors f and let f|i = (Ï, h1, . . . , hiâˆ’1). We consider an
execution of A on input in and randomness f with access
to oracle O, denoted AO
(in, f ), as successful if it outputs a
tuple (J,{out j}jâˆˆJ , aux ), where J is a multi-set that is a non-
empty subset of {1, . . . , qH}, {out j}jâˆˆJ is a multi-set of side
outputs, and aux is an additional set of auxiliary outputs. We
say that A failed if it outputs J = âˆ…. Let  be the probability
that A(in, f ) is successful for fresh randomness f â†$ Î© and
for an input in â†$ IG generated by an input generator IG.
For a given input in, the generalized forking algorithm GFA
is deï¬ned as follows:
We say that GFA succeeds if it doesnâ€™t output fail. The
difference to Bagherzandi et al.â€™s forking lemma [BCJ08] is
Aâ€™s access to the oracle O and the additional auxiliary output
aux that gets accumulated in Aux over all runs of A, including
failed runs. If the oracle O is deterministic, meaning that it
always answers the same query with the same response, it is
easy to see that these extensions do not impact the bounds of
their forking lemma, so the following statement continues to
hold.
Lemma 1 (Generalized Forking Lemma [BCJ08]). Let IG be
a randomized algorithm and A be a randomized algorithm
running in time Ï„ with access to a deterministic oracle O that
succeeds with probability . If q > 8nqH/, then GFA(in)
runs in time at most Ï„ Â· 8n2qH/ Â· ln(8n/) and succeeds
with probability at least /8, where the probability is over
the choice of in â†$ IG and over the coins of GFA.
(cid:18)(cid:17)(cid:25)(cid:23)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:45:54 UTC from IEEE Xplore.  Restrictions apply. 
2.4 Security of Multi-Signatures
the model
We follow the syntax and security model due to Bagherzandi
et al. [BCJ08], which follows the so-called key-veriï¬cation
model, as introduced by Bagherzandi and Jarecki [BJ08],
where individual public keys must be veriï¬ed by the signature
veriï¬er. We adapt
to support signers that are
organized in a tree structure for more efï¬cient communication.
Prior work always assumed a communication setting where
every cosigner communicates directly with the initiator, which
our tree-based modeling supports by choosing a tree in which
every cosigner is a direct child of the initiator. Moreover,
we formalize the notion of an â€œaggregated keyâ€ of a group
of signers, by adding an algorithm that computes a single
aggregated public key from a set of public keys, and this
aggregated key will be used by the veriï¬cation algorithm. The
idea of splitting key aggregation from veriï¬cation is that if a
group of signers will repeatedly sign together, a veriï¬er will
only once compute the aggregate public key and reuse that
for later veriï¬cations. If the aggregated key is smaller than
the set of public keys, or even constant size, this will allow
for more efï¬cient schemes. Note that this change does not
exclude multi-signature schemes that do not have this feature:
indeed, such schemes can simply use the identity function as
key aggregation algorithm.
A multi-signature scheme consists of algorithms Pg, Kg,
Sign, KAg, KVf, and Vf. A trusted party generates the
system parameters par â† Pg. Every signer generates a
key pair (pk , sk ) â†$ Kg(par ), and signers can collectively
sign a message m by each calling the interactive algorithm
Sign(par , sk ,T , m), where T describes a tree between the
signers that deï¬nes the intended communication between the
signers. At the end of the protocol, the root of the tree T
obtains a signature Ïƒ. Algorithm KAg on input parameters par
and a set of public keys PK outputs a single aggregate public
key PK . A veriï¬er can check the validity of a signature Ïƒ
on message m under an aggregate public key PK by running
Vf(par , PK , m, Ïƒ) which outputs 0 or 1 indicating that the
signatures is invalid or valid, respectively. Anybody can check
the validity of a public key by using key veriï¬cation algorithm
KVf(par , pk ).
First, a multi-signature scheme should satisfy completeness,
meaning that 1) for any par â† Pg and any (pk , sk ) â†
Kg(par ), we have KVf(par , pk ) = 1, and 2) for any n, if
i, sk i) â† Kg(par ) for i = 1, . . . , n, and any tree
we have (pk
T containing exactly these n signers, and for any message
m, if all signers input Sign(par , sk i,T , m), then the root
of T will output a signature Ïƒ such that Vf(par , KAg(par ,
{pk
a) Setup: The challenger generates
, skâˆ—
i
Second, a multi-signature scheme should satisfy unforge-
ability. Unforgeability of a multi-signature scheme MS =
(Pg, Kg, Sign, KAg, Vf, KVf) is deï¬ned by a three-stage game.
the parameters
) â†$ Kg(par ). It
par â† Pg and a challenge key pair (pkâˆ—
runs the adversary on the public key A(par , pkâˆ—
b) Signature queries: A is allowed to make signature
queries on a message m with a tree T , meaning that it has
access to oracle OSign(par ,skâˆ—
,Â·,Â·) that will simulate the honest
signer interacting in a signing protocol to sign message m
}n
i=1), m, Ïƒ) = 1.
).

m
Children Ci
Signer Si
{(PK j, tj)}jâˆˆCi- r â†$ Zq
(cid:5)
ti â† gr
(cid:5)
jâˆˆCi tj
PK i â† yi
jâˆˆCi
c â† H0(Â¯t, m)
{sj}jâˆˆCi - si â† r + csk i
(Â¯t, PK )
(cid:6)

Parent Pi
m
PK j
(ti, PK i)-
(Â¯t, PK )

+
jâˆˆCi sj mod q
si -
Fig. 1: The CoSi signing protocol for signer Si with secret
key sk i and public key pk = (yi, Ï€i). If Si is the leader then,
instead of sending (ti, PK i) to its parent, it sends (Â¯t, PK ) =
(ti, PK i) to its children, and instead of sending si to its parent,
it outputs (c, s) = (c, si) as the signature.
with intended communication tree T . Note that A may make
any number of such queries concurrently.
c) Output: Finally, the adversary halts by outputting a
multi-signature forgery Ïƒ, a message m and a set of public
keys PK. In the key-veriï¬cation setting, the adversary wins
if pkâˆ— âˆˆ PK, KVf(par , pk ) = 1 for every pk âˆˆ PK with
, PK â† KAg(par ,PK), Vf(par , PK , Ïƒ, m) = 1,
pk (cid:9)= pkâˆ—
and A made no signing queries on m. A special case of
the key-veriï¬cation model
is the plain public key model,
where there is no need to verify individual public keys, i.e.,
KVf always returns 1.1 In the weaker knowledge-of-secret-
key (KOSK) setting, the adversary is required to additionally
output corresponding secret keys sk pk for all pk âˆˆ PK, pk (cid:9)=
pkâˆ—
Deï¬nition 4. We say A is a (Ï„, qS, qC, qH, )-forger for multi-
signature scheme MS = (Pg, Kg, Sign, Vf) if it runs in time
Ï„, makes qS signing queries such that at most qC signing
protocols are concurrently active (i.e., started but not yet
ï¬nished) at any given time, makes qH random oracle queries,
and wins the above game with probability at least . MS
is (Ï„, qS, qC, qH, )-unforgeable if no (Ï„, qS, qC, qH, )-forger
exists.
.
2.5 The CoSi Multi-Signature Scheme
CoSi is a multi-signature scheme introduced by Syta et
al. [STV+16] that follows a long line of work on Schnorr-
based multi-signatures [MOR01], [BN06], [RY07], [BCJ08],
[MWLD10]. With a two-round signing protocol and veriï¬-
cation as efï¬cient as verifying a single Schnorr signature,
CoSi is more efï¬cient than prior schemes, but it was proposed
without a formal security proof. By organizing signers in a tree
structure, thousands of signers can create a multi-signature in
seconds, as demonstrated by the open source implementation.2
Since its recent introduction, CoSi has already led to a large
1The distinction between the key-veriï¬cation model and plain public key
model is a bit informal, as they are in fact equivalent: any multi-signature
scheme that is unforgeable in the key-veriï¬cation model is also secure in the
plain public key model, where the key veriï¬cation is simply considered part
of the veriï¬cation algorithm.
2The implementation is available at github.com/dedis/cothority.
(cid:18)(cid:17)(cid:25)(cid:24)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:45:54 UTC from IEEE Xplore.  Restrictions apply. 
body of follow-up work [KJG+16], [SJKK+17], [BKJ+17],
[NKJ+17], [KKJG+18].
Below, we describe a slight variant of the original CoSi
scheme where we add a proof of possession to the public
key, and where during signing the cosigners receive the ï¬nal
commitment value Â¯t instead of just the hash c = H(Â¯t, m). The
ï¬rst change was already suggested in the original paper, the
latter is necessary because the scheme is insecure without it,
since signers are unable to ensure that they are signing the
message that they intended to sign.
Parameters generation. The Pg algorithm sets up a group
G = (cid:2)g(cid:3) of order q, where q is a Îº-bit prime. It also
Zq. Output par â†
chooses two hash functions H0, H1 : {0, 1}âˆ—
(G, g, q, H0, H1).
Key generation. The key generation algorithm Kg(par ) sam-
ples sk â†$ Zq and computes y â† gsk . It then generates a proof
of possession Ï€ = (c, s) by choosing r â†$ Zq and computing
s â† r + H1(gr, y). Output pk â† (y, Ï€) and sk.
Signing. Signing is a four-step protocol. A signer Si on input
Sign(par , sk i, m,T ) behaves as follows.
Announcement. If Si is the leader (i.e., the root of tree T ),
it initiates the protocol by sending an announcement to its
children, which consists of a unique identiï¬er for this signing
session ssid. If Si is not the leader, it waits to receive an
announcement message and forwards it to its children in T .
After doing so, Si proceeds with the commitment phase.
Commitment. Let Ci denote the set of children of Si in tree
T . Si waits to receive all values (tj, PK j) for j âˆˆ Ci. Note
that if Si has no children (i.e., it is a leaf in tree T ), it will
gri Â·(cid:5)
proceed immediately. Si chooses ri â†$ Zq and computes ti â†
i = (yi, Ï€i).
If Si is not the leader, it sends ti to its parent. If Si is the
leader, Si proceeds with the challenge phase.
Challenge. If Si is the leader, it sets Â¯t â† ti and PK â† PK i,
computes c â† H0(Â¯t, m), and sends (Â¯t, PK ) to its children.
If Si is not the leader, it waits to receive a message (Â¯t, PK ),
computes c â† H0(Â¯t, m), and sends (Â¯t, PK ) to its children.
Response. Si waits to receive all values sj for j âˆˆ Ci (note that
if Si is a leaf it will proceed immediately), and then computes
si â† ri + c Â· sk i +
jâˆˆCi sj. It sends si to its parent, unless
Si is the root, then Si sets s â† si and outputs Ïƒ â† (c, s).
Key Aggregation. On input a set of public keys PK, KAg
it outputs aggregate public key PK â† (cid:5)
checks for all (y, (c, s)) âˆˆ PK that c = H1(gsy
âˆ’c, y). If so,
(cid:8)
gs Â· PK âˆ’c, m
Veriï¬cation. Vf on input an aggregate public key PK , a
signature Ïƒ = (c, s), and a message m, checks that
jâˆˆCi tj and PK i â† yi Â·(cid:5)
(y,Ï€)âˆˆPK y.
PK j for pk
(cid:6)
jâˆˆCi
c ?= H0
(cid:7)
.
included in the same paper, we describe the BCJ scheme for
that instantiation here. We also adapt the scheme to support
signers in a tree structure.
Parameters generation. Pg sets up a group G of order q
with generators g1, h1, g2, and h2, where q is a Îº-bit prime.
Choose hash functions H0, H1 : {0, 1}âˆ— â†’ Zq and output
par â† (G, g1, h1, g2, h2, q, H0, H1).
Key generation. The key generation algorithm Kg(par ) takes
sk â†$ Zq and sets y â† gsk
1 . Compute proof-of-posession Ï€ =
(c, s) by taking r â†$ Zq, c â† H1(y, gr
1), s â† r + c Â· sk. Let
pk â† (y, Ï€) and output (pk , sk ).
Signing. Signing is the four-step protocol. A signer Si on input
Sign(par , sk i, m,T ) behaves as follows.
Announcement. If Si is the leader (i.e., the root of tree T ),
it initiates the protocol by sending an announcement to its
children, which consists of a unique identiï¬er for this signing
session ssid. If Si is not the leader, it waits to receive an
announcement message and forwards it to its children in T .
After doing so, Si proceeds with the commitment phase.
Commitment. Let Ci denote the set of children of Si in tree
T . Si waits to receive all values (tj,1, tj,2, PK j) for j âˆˆ Ci.
Note that if Si has no children (i.e., it is a leaf in tree T ), it
will proceed immediately. Si chooses (ri, Î±i,1, Î±i,2) â†$ Z3
q and
Â·(cid:5)
computes ti,1 â† gÎ±i,1
Â·
jâˆˆCi tj,1 and ti,2 â† gÎ±i,1
2 hÎ±i,2
2
gri
PK j. If Si is not the
1
leader, it sends (ti,1, ti,2, PK i) to its parent. If Si is the leader,
Si proceeds with the challenge phase.
Challenge. If Si is the leader, it sets Â¯t1 â† ti,1, Â¯t2 â† ti,2,
and PK â† PK i. It computes c â† H0(Â¯t1, Â¯t2, PK , m), and
sends (Â¯t1, Â¯t2, PK ) to its children. If Si
is not the leader,
it waits to receive a message (Â¯t1, Â¯t2, PK ), computes c â†
H0(Â¯t1, Â¯t2, PK , m), and sends (Â¯t1, Â¯t2, PK ) to its children.
Response. Si waits to receive all values (sj, Î³j,1, Î³j,2) for j âˆˆ
Ci (note that if Si is a leaf it will proceed immediately), and
(cid:6)
then computes si â† ri + c Â· sk i +
jâˆˆCi sj, Î³i,b â† Î±i,b +
jâˆˆCi Î³j,b for b âˆˆ {1, 2}. It sends (si, Î³i,1, Î³i,2) to its parent,
unless Si is the root, then Si sets s â† si, Î³1 â† Î³i,1, Î³2 â†
Î³i,2, and outputs Ïƒ â† (Â¯t1, Â¯t2, s, Î³1, Î³2).
Key Aggregation. KAg on input a set of public keys PK
âˆˆ PK as (yi, (ci, si)), and if this public key
parses every pk
Output aggregate public key PK â† (cid:5)
âˆ’ci
has not been validated before, check that ci = H1(yi, gsi
).
1 y
i
jâˆˆCi tj,2, and PK i â† yi Â·(cid:5)
1 hÎ±i,2
Â·(cid:5)
(cid:6)
jâˆˆCi
(y,Ï€)âˆˆPK y.
1
i
Veriï¬cation. Vf on input aggregate public key PK , a sig-
nature Ïƒ = (Â¯t1, Â¯t2, s, Î³1, Î³2), and a message m, compute