---
## Page 71
[root(@localhost ~]# cat /proc/self/statm
654 57 44 0 0 334 0
输出解释
CPU以及CPUO。的每行的每个参数意思（以第一行为例）为：
参数解释/proc//status
Size(pages)任务虚拟地址空间的大小VmSize/4
Resident(pages)应用程序正在使用的物理内存的大小VmRSS/4
Shared(pages)共享页数 0
Trs(pages）程序所拥有的可执行虚拟内存的大小VmExe/4
Lrs(pages)被映像到任务的虚拟内存空间的库的大小VmLib/4
Drs(pages）程序数据段和用户态的栈的大小（VmData+VmStk）4
t0 (sa8ed)ap
查看机器可用内存
/proc/28248/>free
total used free shared buffers cached
Mem: 1023788 926400 97388 0 134668 503688
-/+ buffers/cache: 288044 735744
Swap: 1959920 89608 1870312
我们通过free命令查看机器空闲内存时，会发现free的值很小。这主要是因为，在linux中有这么一种
思想，内存不用白不用，因此它尽可能的cache和 buffer一些数据，以方便下次使用。但实际上这些内
存也是可以立刻拿来使用的。
所以空闲内存=free+buffers+cached=total-used
2、vmstat
很显然从名字中我们就可以知道vmstat是一个查吞虚拟内存（Virtual Memory）使用状况的工具，但
是怎样通过vmstat来发现系统中的瓶颈呢？在回答这个间题前，还是让我们回顾一下Linux中关于虚拟
内存相关内容。
2.1、虚拟内存运行原理
在系统中运行的每个进程都需要使用到内存，但不是每个进程都需要每时每刻使用系统分配的内存
空间。当系统运行所需内存超过实际的物理内存，内核会释放某些进程所占用但未使用的部分或所有物
理内存，将这部分资料存储在磁盘上直到进程下一次调用，开将释放出的内存提供给有蓄要的进程使用，
在Linux内存管理中，主要是通过“调页Paging”和“交换Swapping”来完成上述的内存调度。调页算
法是将内存中最近不常使用的页面换到磁盘上，把活动页面保留在内存中供进程使用。交换技术是将整
个进程，而不是部分页面，全部交换到磁盘上。
内核需要一个分页时，但发现此分页不在物理内存中（因为已经被Page-Out了)，此时就发生了分页错误
( Page Fault) 。
当系统内核发现可运行内存变少时，就会通过Page-Out来释放一部分物理内存。经管Page-Out不是经
常发生，但是如果Page-out频繁不断的发生，直到当内核管理分页的时间超过运行程式的时间时，系
统效能会急剧下降。这时的系统已经运行非常慢或进入暂停状态，这种状态亦被称作thrashing（颠簸]。
2.2、使用vmstat
1.用法
vmstat [-a] [-n] [-S unit] [delay [ count]]
---
## Page 72
vmstat [-s] [-n] [-S unit]
vmstat [-m] [-n] [delay [ count]]
vmstat [-d] [-n] [delay [ count]
vmstat [-p disk partition] [-n] [delay [ count]
vmstat [-f]
vmstat [-V]
-a：显示活跃和非活跃内存
-f：显示从系统启动至今的fork数量。
-m:显示 slabinfo
-n：只在开始时显示一次各字段名称。
-5：显示内存相关统计信息及多种系统活动数量。
delay：刷新时间间隔。如果不指定，只显示一条结果。
count：刷新次数。如果不指定剧新次数，但指定了刷新时间间隔，这时刷新次数为无穷。
-d：显示磁盘相关统计信息。
-p：显示指定磁盘分区统计信息
-S：使用指定单位显示。参数有k、K、m、M，分别代表1000、1024、1000000、1048576字节（byte）。
默认单位为K（1024 bytes）
-V：显示vmstat版本信息。
2.3、实例
例子1：每2秒输出一条结果
procs
nemory-
buff cache
--dons-
-i0-
-systen--
cpu-
rb
supd
free
31
30
bi
bo
in
n pT n 
00
89
38636 162572 329964
0
0
0
3
1
0
0000T00
00
89
38636 162572 329964
0
0
0
01022
00
337
0
0066T
68
38636 162572 329964
0
0
0
161024
332
0010000
00
68
38636 162572 329964
0
0
/ba.cidaeg
01020
338
019900
00
6838636162572329964
0
0
字段说明：
Procs（进程）：
r:运行的和等待（CPU时间片）运行的进程数，这个值也可以判断是否需要增加CPU（长期大于1)
b:等待IO的进程数量，处于不可中断状态的进程数，常见的情况是由IO引起的
Memory（内存）：
swpd:使用虚拟内存大小，切换到交换内存上的内存（默认以KB为单位)
如果swpd的值不为0，或者还比较大，比如超过100M了，但是si,so的值长期为0，这种情况我
们可以不用担心，不会影响系统性能。
free:空闲的物理内存
buff：用作缓冲的内存大小
cache:用作缓存的内存大小，文件系统的cache，如果cache 的值大的时候，说明cache住的文件数
多，如果频繁访问到的文件都能被cache住，那么磁盘的读IObi会非常小
Swap:
si:：每秒从交换区写到内存的大小，交换内存使用，由磁盘调入内存
50:每秒写入交换区的内存大小，交换内存使用，由内存调入磁盘
内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响。磁盘10和
CPU资源都会被消耗。
---
## Page 73
要结合si,so，如果free很少，但是siso 也很少（大多时候是0)，那么不用担心，系统性能这时不会受
到影响的。
IO：（现在的Linux版本块的大小为1024bytes）
bi:每秒读取的块数，从块设备读入的数据总量（读磁盘)(KB/s)
bo:每秒写入的块数，写入到块设备的数据总理（写磁盘)(KB/s)
随机磁盘读写的时候，这2个值越大（如超出1M），能看到CPU在1O等待的值也会越大
system:
in:每秒中断数，包括时钟中断。
cs:每秒上下文切换数。
上面这2个值越大，会看到由内核消耗的CPU时间会越多
CPU（以百分比表示）：
us:用户进程消耗的CPU时间百分比，us 的值比较高时，说明用户进程消耗的CPU时间多，但是如
果长期超过50%的使用，那么我们就该考虑优化程序算法或者进行加速了
SY:内核进程消耗的CPU时间百分比，Sy的值高时，说明系统内核消耗的CPU资源多，这并不是良
性的表现，我们应该检查原因。
id:CPU处在空闲状态时间百分比(包括IO等待时间)
wa:IO等待消耗的CPU时间百分比，wa的值高时，说明IO等待比较严重，这可能是由于磁盘大量
作随机访问造成，也有可能是磁盘的带宽出现瓶颈（块操作）。
例子2：显示活跃和非活跃内存
[xoot8
~]#vmstat-a2
procs
-nemory-
--svap--
---s--------
--ndo--.
pdas
free
inact active
31
30
b1
bo
1n
nT 
00
68
38416
93472 831652
0
0
0
1
0000T000
00
38416
93472831652
0
0
0
010243200010000
00
68
38416
93472831652
0
0
01025343019900
00
68
38112
93472831692
0
0
501024373119900
00
6838112
93472 831692
0
0
使用-a选项显示活跃和非活跃内存时，所显示的内容除增加inact和active外，其他显示内容与例子1
相同。
字段说明：
Memory（内存）：
inact:非活跃内存大小（当使用-a选项时显示）
active：活跃的内存大小（当使用-a选项时显示）
注：如果r经常大于4，且id经常少于40，表示cpu的负荷很重，如果bi，bo长期不等于0，表示内
存不足，如果disk经常不等于0，且在b中的队列大于3，表示io性能不好。
CPU问题现象：
1.)如果在processes中运行的序列(processr)是连续的大于在系统中的CPU的个数表示系统现在运行比较
慢，有多数的进程等待CPU.
2.)如果r的输出数大于系统中可用CPU个数的4倍的话，则系统面临着CPU短缺的问题，或者是CPU的速
率过低，系统中有多数的进程在等待CPU，造成系统中进程运行过慢
3.)如果空闲时间(cpuid)持续为0并且系统时间(cpu sy)是用户时间的两倍(cpuus)系统则面临着CPU资源
的短缺.
解决办法：
---
## Page 74
当发生以上问题的时候请先调整应用程序对CPU的占用情况.使得应用程序能够更有效的使用CPU.同
时可以考虑增加更多的CPU.关于CPU的使用情况还可以结合mpstat，
ps auxtopprstat-a等
等一些相应的命令来综合考虑关于具体的CPU的使用情况，和那些进程在占用大量的CPU时间.一般情
况下，应用程序的问题会比较大一些.比如一些SQL语句不合理等等都会造成这样的现象.
内存问题现象：
内存的瓶颈是由 scan rate[sr)来决定的.scan rate 是通过每秒的始终算法来进行页扫描的.如果 scan
rate[sr)连缕的大于每秒200页则表示可能存在内存缺陷.同样的如果page项中的pi和po这两栏表示每
秒页面的调入的页数和每秒调出的页数.如果该值经常为非零值，也有可能存在内存的瓶颈，当然，如果个
别的时候不为0的话，属于正常的页面调度这个是虚拟内存的主要原理
解决办法：
1.调节applications & servers 使得对内存和 cache 的使用更加有效.
2.增加系统的内存.
3. Implement priority paging in s in pre solaris 8 versions by adding line *set priority paging=1" in
/etc/system. Remove this line if upgrading from Solaris 7 to 8 & retaining old /etc/system file.
存的使用情况，和那些进程在占用大量的内存.一般情况下，如果内存的占用率比较高，但是，CPU的占用
很低的时候，可以考虑是有很多的应用程序占用了内存没有释放，但是，并没有占用CPU时间，可以考虑
应用程序，对于未占用CPU时间和一些后台的程序，释放内存的占用
4.4、案例
案例学习：
1：在这个例子中这个系统被充分利用
# vmstat 1
procs
memory
swap
io
system
cpu
rb
pdms
free
buff cache
50
bi
bo
in
pI eM As sn s3
30 206564
15092
80336 176080
0
0
0
0718
26 811900
20 2065641477280336 176120
0
0
0
0758
2396400
1 0 206564 14208 80336 176136
0
0
0820