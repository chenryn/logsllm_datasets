间布局随机化（AddressSpaceLayoutRandomization，ASLR））或Windows（有数据执行预防
（dataexecutionprevention）、ASLR）等项目。
保护自己
防御是一个多层次的方法
把所有的防御集中到一个地方从来不是一个好方法，在多个层面进行防御也是开发
防漏洞攻击程序的一个策略。尽管内核级的补丁程序可能是最广泛的、最有效的、最适当
的，但是我们也应将安全策略应用在其他不同层次。编译器就是一个补丁感兴趣的地方：如
何更好地保护代码而不是把防御直接嵌入到代码里？例如，更新版本的GNU编译器集合
（GNUCompilerCollection，GCC，http://gcc.gnu.org）I具带有FortifySource工具和Stack
SmashingProtector（堆栈粉碎保护器）选项，也称为ProPolice（www.trl.ibm.com/projects/
security/ssp/)。通用的函数库是补丁程序感兴趣的另一处地方：它们是动态链接二进制代码的
一部分，并且包含了诸如内存分配器之类很敏感的子系统。有一个项目包含了所有这些类
型的补丁程序，这就是应用于RedHat和Fedora的ExecShield项目。
统。在介绍漏洞利用的时候，我们涉及了本书中提到的大部分操作系统都实现了的经典的用户
模型。这个模型的优点是简易性，当然这也是它最主要的缺点：它不能很好地捕获运行在一个
系统上的应用程序的使用模型（usagemodel）。我们将用一个简单明了的例子说明这一点。
打开一个较低级的TCP或UDP端口（端口1到1023）和从系统中删除一个用户是两种常
见的权限操作。在之前描述过的单纯用户模型里，拥有超级用户权限的用户可以执行这两个操
作。然而，一个应用程序不可能需要上述两种操作。因为让一个Web服务器含有管理一个系统
上的用户账户的逻辑功能是没有道理的。另一方面，Web服务器应用程序的缺陷将会让攻击者
例如，在编译的时候，这个编译器知道某个缓冲区的大小，然后就可以使用这个信息把调用strcpy函数（不
安全）的方法用安全函数strncpy来代替。
---
## Page 17
8第一部分内核态
取得对整个系统的全权控制。权限分离背后的理念就是尽量减少运行在全权状态下的代码数
量。对于Web服务器来说，只有在传统的超文本传输协议端口（80端口）打开侦听的套接
字才需要超级用户权限；执行该操作后，没有必要保持超级用户状态。为了降低已经成功利
用的漏洞的影响，应用程序如HTTP服务器应该在执行完权限操作后尽快退出超级用户状态。
其他的守护进程如sshd会根据应用程序必须执行的操作类型把应用程序划分成不同的部分。
然后把全权分配给需要全权的那部分，这些部分相应地会设计得尽量简短。因此，在应用程
序的生命周期内，各部分之间将通过一些进程间通信（interprocesscommunication，IPC）通道
进行通信。
我们能做得更好吗？可以退一步，将相同的最小权限原则应用于整个系统。强制访问控
制（MandatoryAccessControl，MAC）、访问控制列表（AccessControlList，ACL）和基于
角色的访问控制（Role-BasedAccessControl，RBAC）系统以不同的风格把前面提及的原则
应用到整个系统，抛弃了超级用户的概念，每一个用户都将分配到最少但必要的权限集以完
成其任务。这种系统的示例包括Solaris信任扩展、Linuxgrsecurity和NSASELinux（www
nsa.gov/research/selinux/index.shtml，在2.6版本以后的主流Linux内核里）的补丁程序，以及
WindowsVista强制完整性控制的补丁程序。
编写一个能绕过刚才讨论的防护措施的、有效且可靠的用户态漏洞利用是一件很有挑战性
的工作。幸运的是（或者遗憾，这取决于您的位置），漏洞利用的门槛已经很高。基于漏洞利
用的攻击在过去的20年里越来越普遍。因此，对于所有主要的用户态软件世界上很多黑客和
安全专家都审计过不止一次。显然，软件在不断演进，而认为软件的演进不会引人新的缺陷是
愚蠢的。然而，找到新的漏洞已经不像10年前那样是一个高产的任务了。
警告我们把注意力集中在以软件方法防御漏洞利用，但是有一些保护措施也能在硬
件级别实现。例如x86-64架构（86架构的64位演化）为内存的物理页面提供了一种
NX位。现代内核可以利用这个位把一些内存的地址空间标记为不可执行的，由此来
减少攻击者用来存放shellcode的地方的数量。我们将在第3章对此进行更详细的讲
解（并且演示如何绕过这种保护机制）。
内核态漏洞利用和用户态漏洞利用
刚才从漏洞利用安全策略实施载体的角度描述了内核。随着安全补丁越来越多，以
及用户态软件缺陷越来越少，漏洞利用者把主要精力转移到操作系统的内核上也就不足
为奇了。然而，与用户态的漏洞利用相比，写一个内核态的漏洞利用要面对许多额外的
挑战：
·内核是系统唯一不可或缺的软件。只要内核正常运行，就不会出现不可恢复的情况。这
就是在用户态使用蛮力法为什么可行的原因：当数次搞垮要攻击的应用程序时，您只需
NX（或不可执行的）位在支持物理地址扩展（PAE）的32位x86机器上也是可用的。我们将在第3章讨论
更多的细节。
---
## Page 18
第1章从用户态利用到内核态利用
9
要关心日志文件中的踪迹。当要进行内核态的漏洞利用时，这个假设就不再有效了：内
核级别的错误会导致系统进入不一致的状态，通常需要手动重启系统使之恢复到正常状
态。如果错误发生在内核的敏感区域，操作系统将关机，是一种称作“恐慌”（panic）的
情况。有些操作系统，比如Solaris，会在可能的情况下将“恐慌”（panic）的信息输出
到一个故障转储文件中以备事后分析。
·内核通过硬件、软件与应用程序隔离开。搜集内核的信息是一项更复杂的任务。与此同
时，不受攻击者控制的变量的数目却在以指数级的速度增长。以内存分配器作为例子，
在用户态漏洞利用时，内存分配表在进程里，通常通过共享的系统库进行链接。您的目
标是其唯一的使用者和“影响者”。然而，系统中所有的进程都可以影响内核内存分配表
的行为和状态。
·内核是一个庞大复杂的系统。其源代码数量可能达到百万行的级别。内核必须管理所有
的硬件和大部分底层软件（虚拟内存、文件系统、进程间通信机制等）。因此内核被转化
为多层次、相互关联的子系统。为了成功触发和利用某个漏洞，攻击者必须深入地理解
这些子系统才行。内核庞大复杂的特性对漏洞利用者来说也有好处，那就是一个复杂的
系统不太可能是没有错误的。
比起应用程序，内核在某些方面更易受攻击。因为内核在系统中是权限级别最高的代码
（不考虑虚拟化解决方案，请看下面的注意部分），它也是最难保护的。除了硬件，没有任何实
体可以对内核实施保护。
注意在编写本书时，虚拟化系统开始普及，不久以后将会看到基于虚拟化的内核保
护措施。如果想推广虚拟化系统，就不能让它对受保护的内核形成重大影响。
此外，请注意先前所描述的那些保护措施，它们都有一个共同的缺点，就是造成系统性能
中（也就是说针对整个系统），那么它的影响会大得多。对用户来说，性能是很关键的，当安
全是以性能为代价时，他们经常会舍弃安全。表1.1列出了用户态漏洞利用和内核态漏洞利用
的关键区别。
表1.1用户态漏洞利用和内核态漏洞利用的区别
企图
用户态漏洞利用
内核态漏洞利用
这导致了应用程序可以多次在崩溃后重
这将导致机器陷人不一致的状态，通常
蛮力法利用漏洞
启（或者自动重启，例如在Linux里可以用
会导致死机或重启
inetd实现）
攻击者对被攻击程序（特别是本地攻击）
拥有更多的控制（例如，攻击者可以设置被
攻击者需要和其他所有意欲“影响”内
影响目标程序
攻击程序的运行环境）。被攻击程序是它的
核的应用程序竞争。所有的应用程序都是
内核子系统的使用者
库子系统的唯一使用者（例如内存分配表）
---
## Page 19
10第一部分内核态
（续）
企图
用户态漏洞利用
内核态漏洞利用
shellcode在更高的权限级别上执行，并
shellcode可以利用已经通过安全和正确性
执行shellcode
且必须在不惊动系统的情况下正确地返回
保证的用户态门来调用内核态的系统调用
到应用程序
大部分保护措施在内核态，但并不能保
绕过反漏洞利用保护措施
这要求越来越复杂的方法
护内核本身。攻击者甚至能禁用大部分保
护措施
在内核态上可以实施的利用是非常多的，这是内核的复杂性的另一个好处。可以在
本书的其他部分发现这一点，对内核态的漏洞进行分类要比用户态更难。尽管能找到一
些通用的漏洞利用分类列表（这是我们将要做的事情），但是每一个内核漏洞都有其自身
的特点。
休息一下，旅程才刚刚开始。
一个漏洞利用者的内核观
前面的部分勾勒了用户态漏洞利用和内核态漏洞利用的区别，从这里开始我们将只关心内
核。本节将进一步介绍一些理论概念，这将对我们的理解很有帮助，在后面内容中将讨论内
核漏洞和内核攻击。由于这不是一本关于操作系统的书，所以为了更清晰地介绍漏洞利用相
关的细节，我们将先介绍漏洞利用的概念，这些概念与操作系统概念密切相关，因为对于操
作系统了解得越多，对漏洞利用概念的理解就越好。对操作系统的学习不仅令人着迷，而且
当您想进行攻击时，这种学习也很有帮助（想了解更多操作系统中的概念，请看本章最后的
“相关阅读”）。
用户态进程和调度
我们理所当然地认为操作系统有一个特性，就是可以同时运行多个进程。很明显，除非系
统有多个CPU，否则在任意指定的时间点上只能有一个进程处于活动状态。通过把CPU上的
时间片分配给每个进程和快速地将CPU在进程间切换，内核就能给终端用户一种假象一—多个
任务是同时运行的。为了达到上述目的，内核为每个进程保存并关联一组表示该进程状态的信
息：这个进程执行到了哪儿，它处于就绪状态还是在等待某些资源，当将它从CPU上换下来时
机器的状态等。所有这些信息通常称为执行上下文，而为了运行另一个进程把当前进程从CPU
上撤下的操作称为上下文切换。调度程序是一个子系统，它负责在很多等待运行的任务中挑选
一个进程运行并把CPU的使用权赋给这个进程。您将看到，在利用竞态条件的时候，具有影响
调度程序决策的能力是非常重要的。
除了正确执行上下文切换的信息外，内核还会跟踪和进程相关的其他信息，例如，它打开
了哪个文件，它的安全身份验证是什么，它使用的内存范围是什么。能够成功定位到包含这些
---
## Page 20
第1章从用户态利用到内核态利用11
详细信息的结构通常是内核漏洞利用中shellcode开发的第一步。一旦能够得到保存有某运行进
程的身份验证的结构时，就可以轻松地提高自己的权限级别。
虚拟内存
内核的另一个子系统负责为进程和内核提供虚拟内存的抽象，这个子系统也是漏洞利用程
序开发者需要熟悉的。计算机用来存储临时、易变的数据的物理内存是固定的（随机存取内存
或者说RAM）。内存物理地址空间的范围从0到RAM的大小减1。同时，现代操作系统为每
一个运行的进程和不同内核子系统提供了一种假象，那就是每个进程或者子系统都以为自己拥
有一个很大的私有地址空间。这种虚拟的地址空间经常比计算机所提供的物理地址空间还大，
并受到架构的制约：在一个n位架构上，这个空间一般是0到2"-1。虚拟内存子系统就负责维
护这种抽象，管理虚拟内存地址到物理内存地址（或者反过来）的映射，强制隔离不同的地址
空间。就像前面所说的，一个安全的系统的构建原则之一就是把内核和进程隔离，并且把各个
进程也相互隔离开。为了实现这个目标，几乎所有操作系统（实际上是这本书要讲到的那些操
作系统）都把物理内存地址空间切分成固定大小的块，称为页帧，并把虚拟地址空间切分成同
样大小的块，称为页。当一个进程需要某页内存的时候，虚拟内存管理系统就会给它分配一个
物理的页顿。物理的页顿到虚拟页的地址映射通过页表完成，页表会告诉一个给定的虚拟地址
映射到哪个物理页。一旦分配完所有的物理页，而此时恰好有一个进程需要一个新的物理页，
操作系统将会挑选一个当前没有使用的虚拟页，将其复制到磁盘上一个称作“交换区”的专用
空间，这样就释放了一个物理页，然后将其分配给需要的进程。当需要硬盘交换区上的页面
时，操作系统会将另一个内存物理页的内容放到交换区，然后把需要的页面装入空出来的物理
内存，这个操作称为“交换”。因为对硬盘的访问很费时，所以为了改进性能，虚拟内存子系
统首先为进程创建一个虚拟地址空间，在此之后只有当一个地址第一次用到时才为该地址所在
的虚拟页分配一个物理页，这种方法称为请求页面调度。
工具与策略
观察进程的虚拟地址空间
对于虚拟内存是什么，它怎样工作，我们刚才只给了一个很初级的描述。如果要查看
它的行动，可以使用操作系统自带的一些工具。在安装有Linux操作系统的计算机上，可
以执行这个命令：“cat/proc//maps”（是您感兴趣的那个进程的数字类型的参数
PID）来查看所有该进程映射（例如，进程请求的所有虚拟内存地址的范围）的内存列表。
下面是一个示例：
luser@katamaran:~$cat/proc/3184/maps
00400000-004c1000
r-xp0000000003:01703138/bin/bash
006c1000-006cb000
rw-p000c100003:01703138/bin/bash
006cb000-006d0000
rW-p006cb00000:000
00822000-008e2000
rW-p0082200000:000
[heap]
7f7ea5627000-7f7ea5632000r-xp0000000003:01809430
/1ib/1ibnss_files-2.9.so
7f7ea5632000-7f7ea5831000
-p0000b00003:01809430
---
## Page 21
12第一部分内核态
/1ib/1ibnss_files-2.9.so
[...]
正如所看到的，这个命令提供了很多信息，如地址范围（在左边显示的）、页保护
（rwxp的意思是读/写/执行/私有）和最终的备份文件的映射。在几乎所有操作系统上
都能得到这些信息。在OpenSolaris上可以用pmap命令，例如，pmap-x；而在Mac
OSX操作系统中可以用vmmap命令，例如，vmmap或者vmmap，其
中是一个字符串，它将在系统上运行的所有进程中匹配。在Windows上，
我们建议下载MarkRussinovich的SysinternalsSuite（http://technet.microsoft.com/en-us/
sysinternals/bb842062.aspx），它不仅提供了vmmap，还提供了很多有用的系统和进程的分
析工具。
在虚拟内存管理过程中，可能或多或少需要硬件上的支持，这取决于架构。抛开细节不谈
（您可以在任何一本讲架构或者操作系统的书中找到的细节），CPU的核心需要操作物理内存地
址，而作为漏洞利用者却几乎只能操作虚拟内存（地址）。
刚才谈到，虚拟地址到物理地址的映射是通过查询一个特殊的数据结构一页表来实现
的。不同的进程有不同的页表，在每一次上下文切换的时候，也会装载相应的页表。因为每个
进程都有一个不同的页表，因此每个进程也就有不同的一组内存页，看起来好像一个只属于该
进程的连续的虚拟地址空间一样，并且强制和其他的进程隔离。特殊的页属性允许内核通过
“隐藏”内存页来保护免受用户态程序的干扰。针对不同的实现，需要面对两种可能的情形：用
内核的内存空间代表用户态的内存空间，或者将内核地址空间和用户程序地址空间隔离。我们
将在下一节讨论为什么从漏洞利用的角度来说这是一个很有趣的特点。
内核空间中的用户空间和隔离的地址空间的对比
也看不到内核地址空间映射到的地址。另一方面，您是从用户态开始攻击的。我们刚才提到了
两种可能遇到的设计：
·用内核态内存空间代表用户态内存空间在这种情况下将虚拟地址分为两部分一一一部
内核页表的入口地址来实现。例如，在一个32位的x86机器的Linux系统中，内核态的