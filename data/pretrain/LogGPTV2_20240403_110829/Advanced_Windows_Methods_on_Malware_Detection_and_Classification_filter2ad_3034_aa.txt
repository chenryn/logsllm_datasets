title:Advanced Windows Methods on Malware Detection and Classification
author:Dima Rabadi and
Sin G. Teo
Advanced Windows Methods on Malware Detection and
Classification
Dima Rabadi
Institute for Infocomm Research, Singapore
PI:EMAIL
Sin G. Teo
Institute for Infocomm Research, Singapore
PI:EMAIL
ABSTRACT
Application Programming Interfaces (APIs) are still considered the
standard accessible data source and core wok of the most widely
adopted malware detection and classification techniques. API-based
malware detectors highly rely on measuring API’s statistical fea-
tures, such as calculating the frequency counter of calling specific
API calls or finding their malicious sequence pattern (i.e., signature-
based detectors). Using simple hooking tools, malware authors
would help in failing such detectors by interrupting the sequence
and shuffling the API calls or deleting/inserting irrelevant calls
(i.e., changing the frequency counter). Moreover, relying on API
calls (e.g., function names) alone without taking into account their
function parameters is insufficient to understand the purpose of
the program. For example, the same API call (e.g., writing on a
file) would act in two ways if two different arguments are passed
(e.g., writing on a system versus user file). However, because of the
heterogeneous nature of API arguments, most of the available API-
based malicious behavior detectors would consider only the API
calls without taking into account their argument information (e.g.,
function parameters). Alternatively, other detectors try considering
the API arguments in their techniques, but they acquire having pro-
ficient knowledge about the API arguments or powerful processors
to extract them. Such requirements demand a prohibitive cost and
complex operations to deal with the arguments. To overcome the
above limitations, with the help of machine learning and without
any expert knowledge of the arguments, we propose a light-weight
API-based dynamic feature extraction technique, and we use it to
implement a malware detection and type classification approach.
To evaluate our approach, we use reasonable datasets of 7774 be-
nign and 7105 malicious samples belonging to ten distinct malware
types. Experimental results show that our type classification mod-
ule could achieve an accuracy of 98.0253 %, where our malware
detection module could reach an accuracy of over 99.8992 %, and
outperforms many state-of-the-art API-based malware detectors.
CCS CONCEPTS
• Security and privacy → Malware and its mitigation; • Com-
puting methodologies → Machine learning; Feature selec-
tion.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ACSAC 2020, December 7–11, 2020, Austin, USA
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-8858-0/20/12...$15.00
https://doi.org/10.1145/3427228.3427242
KEYWORDS
API calls; feature generation; malicious behavior analysis; dynamic
analysis; anomaly-based detectors; malware detection; malware
type classification; machine learning
ACM Reference Format:
Dima Rabadi and Sin G. Teo. 2020. Advanced Windows Methods on Malware
Detection and Classification. In Annual Computer Security Applications
Conference (ACSAC 2020), December 7–11, 2020, Austin, USA. ACM, New
York, NY, USA, 15 pages. https://doi.org/10.1145/3427228.3427242
1 INTRODUCTION
Despite the diversity of the available anti-virus vendors and the
significant progress in malware detection research, it has been no-
ticed that malware detection has increased year-over-year by only
one percent [26]. There is a competition between a pair of almost
an equal effort from two entities: 1. malware authors (cyberattack-
ers) generating and spreading new variants of malware samples,
and 2. researchers meanwhile detecting and removing them. Such
competition, together with the interconnected nature of the Inter-
net infrastructure, helped in continuously creating sophisticated
malware over the years. Therefore, malware has indeed become
much harsher and harder to be detected, and it is considered the
most significant threat on the Internet. Thus, malware detection be-
comes a priority in every aware security system. The term malware
represents any malicious program, software, or code, or harmful
script that achieves the adversarial aim of the attacker. Once the
malware is detected, the presence of its aim to harm the computer
would be predicted. Malware detection has mainly two broad cate-
gories, namely static and dynamic analysis, respectively. The static
analysis investigates the structure of malware’s binary code with-
out executing it, while the dynamic seeks its behavior during the
execution. It has been observed that static analysis is unprotected
against unknown and zero-day attacks because it has a deficiency
in dealing with polymorphic malware, compression, packing, and
obfuscation techniques.
Several types of research [7, 15, 24] have proven that dynamic
analysis is more resilient to the techniques mentioned above and
gives more reliable detection performance than the static. There
are two strategies to perform dynamic analysis. In the first strategy,
a predefined system state is determined at a particular point be-
fore executing the malware. Then, system states and modifications
before and after that predefined point are examined to detect the
malware effect on the system. In the second strategy, the malware
sample is executed in an isolated and well-monitored environment,
such as the sandboxing. Then, the malware behavior and its effect
on the system are observed. Both strategies examine various ex-
tracted information from the system while executing the malware.
Such as the registry keys modification, the accessed/modified and
54ACSAC 2020, December 7–11, 2020, Austin, USA
Dima Rabadi and Sin G. Teo
dropped files, newly created and accessed processes (i.e., Applica-
tion Programming Interfaces, APIs), and kernel requested services,
to name a few. However, using extracted features from API calls
to understand and detect the malware behavior shows promising
performance using both static and dynamic analyses.
API is capable of holding enough information about the program
and its behavior as it provides access to the essential resources
that are available to the kernel system. API has two main parts,
the function name and parameters (arguments). Function name is
easily extracted as it is represented by a string that belongs to differ-
ent categories (i.e., security, system services, and networking [32]).
However, function parameters are very complex and belong to
various types (e.g., integers, strings, and address pointers). Con-
sequently, most of the available API-based malware detection ap-
proaches ignore the API arguments in their feature extraction tech-
niques [14, 16, 25, 36]. API-based malware detection has received
significant attention from researchers [22, 24, 35, 38, 40, 41, 54]. In
literature, API-based malware detection has made its advances
during three distinct stages. (1) Using static analysis to create
static-signatures (byte strings) out of the extracted sequence of
API calls [45]. (2) Static analysis has then evolved from using only
the API signatures to also calculating various API-based statisti-
cal properties, such as the frequency counter of calling specific
API calls. Then, both frequency counter and signatures are used
together to detect the malware [1, 51]. However, techniques based
on API signatures and statistical properties are non-resilient to mal-
ware authors who would insert redundant API calls, thus, altering
the frequency counter. (3) As a result, researchers expand the API-
based detection topic by moving their attention to more efficient
techniques based on dynamic analysis. For example, in [24], com-
mon patterns from the API call sequences are extracted using the
Longest Common Subsequence (LCS) alignment. Similarly, in [38],
searching algorithms and sequence alignment using n-gram are
used to find malicious API patterns. Authors of [3] study the con-
textual relationships between the API calls to distinguish benign
from malicious behavior. They group the API calls with similar cat-
egories into clusters, then based on pattern recognition techniques
(i.e., Markov Chain), the malicious sequences of API clusters are
recognized from the benign. Such work is highly dependent on
the sequence (order) of API calls and ignores the API arguments.
However, detection techniques relying on API sequence pattern
recognition can be evaded by inserting irrelevant calls or shuffling
the API sequence using any off-the-shelf hooking tools. Therefore,
malware authors can easily mislead both static and dynamic analy-
ses that rely on calculating the statistical properties or recognizing
the malicious sequence pattern of the API calls.
Recently, extracted features from API calls are used in various
machine learning techniques such as Random Forest (RF) [44] and
Sequential Minimal Optimization (SMO) [52] to implement mal-
ware detection frameworks. Such machine learning detection tech-
niques have achieved outstanding performance and high accuracy
detection rates. However, most of the available machine learning
techniques try to gather domain knowledge about the arguments
which requires complex operations to process them, or completely
ignore the API arguments in the feature extraction operations, due
to the complexity and the heterogeneous nature of the arguments.
Ignoring the API arguments and relying on the API function names
alone is insufficient to understand the purpose of the program. For
example, the same API call (e.g., writing on a file) would act in
two ways if different arguments (e.g., writing on the system ver-
sus user file) are passed to the call. As a result, other researches
have applied deep learning models (e.g., Convolutional or Recur-
rent Neural Network, CNN, and RNN, respectively), for malicious
behavior detection [21, 36, 56]. Expensive and powerful computers
(e.g., a Graphics Processing Unit, GPU) would be needed to run
such models.
Like legitimate Windows programs, malware has developed over
the years and starts getting equipped with different functionalities
and harmful goals. After detecting the malware, the next question
is how to remove it from the system (e.g., malware mitigation). In
malware analysis, the simple way to mitigate the malware is to
know its family or type. In academia, there is still inconsistency in
dealing with malware type and family concepts. As described in
the well-known malware vendors (e.g., Microsoft, Malwarebytes,
Symantec) and [4, 13], the malware family describes all malware
samples that share the same specific functionality, or their payloads
have similar source code as the origin. They behave similarly by
using the same methods to achieve their goals. In contrast, a mal-
ware type describes the sample’s general malicious behavior, where
malware samples with the same type share a general functionality
(e.g., same malicious goal) by having similar features and behav-
ior. The scanned malware sample’s detection name given by the
anti-virus vendors and the multi-scanning services like VirusTotal
is usually considered a malware type. Thus, as our malware labels
are identified based on the information given by Malwarebytes [28]
engine in VirusTotal, we only focus on malware type classifica-
tion in this paper. In order to get a post malware response and
well-defined defense, malware must not only be detected but also
categorized based on its functionality into its type. Understanding
the evolvement of different malware types over the years helps in
analyzing and extracting salient features, which are then used to
train good malware detection models. On the other hand, knowing
how different types of malware spread is vital to containing and
removing them from the system.
In this paper, we explore a new low-cost malware detection and
type classification approach by studying the API calls together
with their arguments. An important research question that we seek
to answer is whether a low-cost API feature extraction without
any domain knowledge of the arguments is sufficient to detect the
malware and classify it into its type. To answer this question, we
propose two methods using the extracted API arguments. In the
first method, all arguments of each API call are extracted as one
feature, whereas in the second method, each argument of each API
call is extracted as one feature. To the best of our knowledge, no
research has studied the feature extraction technique presented in
the second method. We conduct extensive measurements on ten
different malware types using 7774 and 7105, benign and malicious
samples, respectively. Our malware detection gives an accuracy of
over 99.8992 %, and outperforms the state-of-the-art API-based dy-
namic analysis methods. We make the following main contributions
in this paper:
• We run around 14879 samples and extract their sequence of
API calls and arguments.
55Advanced Windows Methods on Malware Detection and Classification
ACSAC 2020, December 7–11, 2020, Austin, USA
• We propose multiple processes to study and generalize the
heterogeneous API arguments without the need for explicit
expertly in the domain.
• Based on the proposed processes, we design two feature
extraction and generation methods (Method 1 and Method
2) without the need for any expert domain knowledge of
the arguments. Method 1 uses the entire list of arguments
of each API call and considers them as one feature (e.g.,
number of features equals the number of API calls). Method
2 generalizes each argument of each API call separately (e.g.,
number of features equals the number of API arguments).
• We use Method 1 and Method 2 to implement five machine
learning models for both malware detection and type classi-
fication.
• Unlike the API-based malware detection methods presented
in the state-of-the-art, our approach is resilient against se-
quence interruption, as we do not rely on the sequence (or-
der) or the statistical features of the API calls.
• We conduct extensive experiments to evaluate the efficacy
of our proposed malware detection and type classification
methods. We verify by using real malware samples that API
arguments are capable of detecting malware and classifying
it into its type. Moreover, our methods outperform the state-
of-the-art with an accuracy of over 99.8992 %.
• The experiments and the results of this paper are repro-
ducible; we release the source code and the hash values of
the used malware samples 1. The benign and malware exe-
cutable files can be shared upon direct request from authors
via email.
The rest of the paper is organized as follows. Section 2 reviews
malware detection and type classification related literature. Sec-
tion 3 presents the working principles of the proposed approach,
feature extraction, and generation. The experiments evaluation
and our benign and malicious datasets are detailed in Section 4. A
comparison between our proposed methods and state-of-the-art
API-based malware detection techniques is shown in Section 5. Sec-
tion 6 further discusses the limitations as well as the future work
of this paper. Section 7 concludes.
2 RELATED WORK
In this section, we review the recent API-based malware detec-
tion and classification methods from machine learning and feature
extraction and generation perspectives.
2.1 Malware Detection
A significant amount of research on static and dynamic API-based
feature extraction techniques for malware detection and type classi-
fication has been conducted recently. Finding the Cosine similarity
between two portable executable (PE) files [47], distinguishing ma-
licious API sequence patterns, and calculating the frequency of
calling specific API calls, to name a few, are all examples on static
API-based feature extraction techniques. In [45, 54], Veeramani et al.
and Sami et al. propose two respective frameworks to analyze and
categorize PE files based on their relevant static API call features.
Despite their high detection accuracy, it has been proven that static
features are not precisely secure, as such techniques can be easily
cheated by applying obfuscation tools [33].
Consequently, researchers are currently focusing on dynamic
API-based feature extraction techniques [2, 24, 38, 51] as being
more promising than the static. In [11], the Multiple Sequence
Alignment (MSA) algorithm is used to determine the representative
API pattern from the sequence of API calls. Their work can be
evaded in two ways. First, by increasing the length of API calls
sequence as MSA is not practical for a sequence longer than a
predefined threshold. Second, by shuffling the API sequence and/or
inserting irrelevant calls; thus, modifying the pattern. Similarly,
in [24], Longest Common Subsequence (LCS) alignment is used
to extract the representative patterns from the API calls sequence.
Further, in [38], searching algorithms and sequence alignment using
n-gram are used to find malicious API patterns. As previously stated,
such techniques can be evaded by simply altering the pattern using
simple hooking techniques.
In [2], Alazab et al. implement online and offline modules to
extract both the spatial statistical features from the API arguments
plus the temporal statistical features from the sequence of API calls.
Such statistical features include mean and variance values and
pointer addresses. Their modules have achieved a high detection ac-
curacy of 96.3 %. However, malware authors can easily modify their
temporal features by faking the API calls sequence. In [17], Gupta et
al. use the Microsoft Detours library to hook user-level Windows
API calls and correlate their functionalities into 26 categories based
on their purposes. In [51], the frequency counters of both the API
calls and their arguments are calculated, then WEKA library [18] is
used to classify the samples into benign and malicious classes. Such
frequency-based detection tools can be easily evaded by adding
more redundant API calls and modifying the frequency counter
value.
Instead of limiting the research to only investigating the mali-
cious programs behavior, Lanzi et al. focus on studying the behavior
of benign programs to implement n-gram and API sequence-based
malware detection model [29]. They define the global behavior of
benign programs and how generally they interact with the environ-
ment, by studying the interactions between benign programs and
the operating system. The sequence of system calls2 is extracted
while running various normal activities on ten different computers.
Once their detection model observes any new and unseen system
call sequences, it either raises a false alarm or drops the malicious
program that contains such sequences. Their detection model has
achieved an accuracy of over 90 % with a low false-positive rate.
Other researchers suggest using dynamic and static analyses
together (hybrid analysis) for more effective malware detection
techniques. For instance, in [35], Bruce et al. propose a model
to extract dynamic and static features from the sequence of API
calls. Similarity-based machine learning algorithms, such as LCS,
Minkowski distance, and Cosine similarity, are then trained using
these features to classify the samples into benign and malicious
classes. Similarly, authors of [20], propose a malware detection
framework, MalDAE, that correlates dynamic and static features
1Click this link to download the source code and the hash values of the used malware
samples.
2The system calls are system-level API calls which request services from the kernel
operating system. API calls could be a user or system-level calls.
56ACSAC 2020, December 7–11, 2020, Austin, USA
Dima Rabadi and Sin G. Teo
from the sequence of API calls. Experimental results of both works
have shown that although the syntax of the dynamic and static
API call features is different, there is a semantic mapping and clear