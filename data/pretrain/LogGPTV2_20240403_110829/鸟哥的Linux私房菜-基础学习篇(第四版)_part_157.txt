### CPU调度与例行性工作调度的区别

CPU调度与例行性工作调度是两种不同的概念。CPU调度指的是操作系统决定每个程序何时及如何被CPU执行的规则，而例行性工作调度则是指将特定程序安排在某个时间点由系统执行。因此，CPU调度更直接地与操作系统的运行相关。

### 优先级（Priority）与Nice值

我们知道，CPU在一秒钟内可以执行数以亿计的微指令。通过核心的CPU调度机制，各个程序可以在一秒钟内被CPU切换运行，从而确保每个程序都能得到一定程度的执行机会。然而，如果所有程序都集中在一个队列中等待CPU处理，并且没有优先顺序的话，就像我们在游乐场排队等候热门游戏一样，每个人必须按顺序等待。这种情况下，即使某个程序已经执行过一次但仍需继续执行（即未完成），它也必须重新排队等待。

例如，在图16.3.1所示的示意图中，假设pro1和pro2是紧急程序，而pro3和pro4是一般程序。如果没有优先顺序，pro1和pro2仍需要等待pro3和pro4的执行完毕，这可能会导致紧急程序的延迟。为了解决这个问题，我们可以引入优先级的概念。如图16.3.2所示，具有高优先级的pro1和pro2可以获得更多的CPU执行机会，从而更快完成任务。

为了实现这一功能，Linux系统为每个进程分配了一个“优先级（priority, PRI）”。这个PRI值越低，表示优先级越高。需要注意的是，PRI值是由操作系统动态调整的，用户无法直接修改。不过，用户可以通过调整Nice值来间接影响PRI。Nice值范围从-20到19，其中负值表示更高的优先级。

#### Nice值调整方法
- **nice命令**：用于在启动新进程时设置其Nice值。
  ```bash
  [root@study ~]# nice -n -5 vim &
  ```
- **renice命令**：用于更改已存在的进程的Nice值。
  ```bash
  [root@study ~]# renice -n 5 -p 1234
  ```

### 系统资源监控工具

除了上述的CPU调度和优先级管理外，我们还需要关注系统的其他资源使用情况。以下是一些常用的系统监控工具：

- **free**：显示内存使用情况。
  ```bash
  [root@study ~]# free -m
  ```
- **uname**：获取系统和内核相关信息。
  ```bash
  [root@study ~]# uname -a
  ```
- **uptime**：显示系统启动时间和负载情况。
  ```bash
  [root@study ~]# uptime
  ```
- **netstat**：显示网络连接、路由表、接口统计等信息。
  ```bash
  [root@study ~]# netstat -atunlp
  ```

通过这些工具，我们可以更好地管理和优化系统的性能。