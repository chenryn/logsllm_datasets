CPU 调度与前一章的例行性工作调度并不一样。 CPU 调度指的是每支程序被 CPU 运行的演算规则， 而例行性工作调度则是将某支程序安排在
某个时间再交由系统执行。 CPU 调度与操作系统较具有相关性！
Priority 与与 Nice 值值
我们知道 CPU 一秒钟可以运行多达数 G 的微指令次数，通过核心的 CPU 调度可以让各程序被 CPU 所切换运行， 因此每个程序在一
秒钟内或多或少都会被 CPU 执行部分的指令码。如果程序都是集中在一个伫列中等待 CPU 的运行， 而不具有优先顺序之分，也就是像我们
去游乐场玩热门游戏需要排队一样，每个人都是照顺序来！ 你玩过一遍后还想再玩 （没有执行完毕），请到后面继续排队等待。情况有点像
下面这样：
图16.3.1、并没有优先顺序的程序伫列示意图
上图中假设 pro1, pro2 是紧急的程序， pro3, pro4 是一般的程序，在这样的环境中，由于不具有优先顺序， 唉啊！pro1, pro2 还是得要
继续等待而没有优待呢！如果 pro3, pro4 的工作又臭又长！那么紧急的 pro1, pro2 就得要等待个老半天才能够完成！真麻烦啊！所以啰，我们
想要将程序分优先顺序啦！如果优先序较高则运行次数可以较多次， 而不需要与较慢优先的程序抢位置！我们可以将程序的优先顺序与 CPU
调度进行如下图的解释：
图16.3.2、具有优先顺序的程序伫列示意图
如上图所示，具高优先权的 pro1, pro2 可以被取用两次，而较不重要的 pro3, pro4 则运行次数较少。 如此一来 pro1, pro2 就可以较快被
完成啦！要注意，上图仅是示意图，并非较优先者一定会被运行两次啦！ 为了要达到上述的功能，我们 Linux 给予程序一个所谓的“优先执行序
（priority, PRI）”， 这个 PRI 值越低代表越优先的意思。不过这个 PRI 值是由核心动态调整的， 使用者无法直接调整 PRI 值的。先来瞧瞧 PRI
曾在哪里出现？
[root@study ~]# ps -l
F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD
4 S 0 14836 14835 0 90 10 - 29068 wait pts/0 00:00:00 bash
0 R 0 19848 14836 0 90 10 - 30319 - pts/0 00:00:00 ps
# 你应该要好奇，怎么我的 NI 已经是 10 了？还记得刚刚 top 的测试吗？我们在那边就有改过一次喔！
由于 PRI 是核心动态调整的，我们使用者也无权去干涉 PRI ！那如果你想要调整程序的优先执行序时，就得要通过 Nice 值了！Nice 值
就是上表的 NI 啦！一般来说， PRI 与 NI 的相关性如下：
PRI（new） = PRI（old） + nice
不过你要特别留意到，如果原本的 PRI 是 50 ，并不是我们给予一个 nice = 5 ，就会让 PRI 变成 55 喔！ 因为 PRI 是系统“动态”决定的，
所以，虽然 nice 值是可以影响 PRI ，不过， 最终的 PRI 仍是要经过系统分析后才会决定的。另外， nice 值是有正负的喔，而既然 PRI 越小越
早被执行， 所以，当 nice 值为负值时，那么该程序就会降低 PRI 值，亦即会变的较优先被处理。此外，你必须要留意到：
nice 值可调整的范围为 -20 ~ 19 ；
root 可随意调整自己或他人程序的 Nice 值，且范围为 -20 ~ 19 ；
一般使用者仅可调整自己程序的 Nice 值，且范围仅为 0 ~ 19 （避免一般用户抢占系统资源）；
一般使用者仅可将 nice 值越调越高，例如本来 nice 为 5 ，则未来仅能调整到大于 5；
这也就是说，要调整某个程序的优先执行序，就是“调整该程序的 nice 值”啦！那么如何给予某个程序 nice 值呢？有两种方式，分别是：
一开始执行程序就立即给予一个特定的 nice 值：用 nice 指令；
调整某个已经存在的 PID 的 nice 值：用 renice 指令。
nice ：：新新执执行行的的指指令令即即给给予予新新的的 nice 值值
[root@study ~]# nice [-n 数数字字] command
选项与参数：
-n ：后面接一个数值，数值的范围 -20 ~ 19。
范例一：用 root 给一个 nice 值为 -5 ，用于执行 vim ，并观察该程序！
[root@study ~]# nice -n -5 vim &
[1] 19865
[root@study ~]# ps -l
F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD
4 S 0 14836 14835 0 90 10 - 29068 wait pts/0 00:00:00 bash
4 T 0 19865 14836 0 85 5 - 37757 signal pts/0 00:00:00 vim
0 R 0 19866 14836 0 90 10 - 30319 - pts/0 00:00:00 ps
# 原本的 bash PRI 为 90 ，所以 vim 默认应为 90。不过由于给予 nice 为 -5 ，
# 因此 vim 的 PRI 降低了！RPI 与 NI 各减 5 ！但不一定每次都是正好相同喔！因为核心会动态调整
[root@study ~]# kill -9 %1  子程序之间传递的呢！ 另外，除了 renice 之外，其实那个 top 同样的也是可以调整 nice 值的！
除了系统的程序之外，我们还必须就系统的一些资源进行检查啊！举例来说，我们使用 top 可以看到很多系统的资源对吧！那么，还有
没有其他的工具可以查阅的？ 当然有啊！下面这些工具指令可以玩一玩！
free ：：观观察察内内存存使使用用情情况况
[root@study ~]# free [-b|-k|-m|-g|-h] [-t] [-s N -c N]
选项与参数：
-b ：直接输入 free 时，显示的单位是 KBytes，我们可以使用 b（Bytes）, m（MBytes）
k（KBytes）, 及 g（GBytes） 来显示单位喔！也可以直接让系统自己指定单位 （-h）
-t ：在输出的最终结果，显示实体内存与 swap 的总量。
-s ：可以让系统每几秒钟输出一次，不间断的一直输出的意思！对于系统观察挺有效！
-c ：与 -s 同时处理～让 free 列出几次的意思～
范例一：显示目前系统的内存容量
[root@study ~]# free -m
total used free shared buff/cache available
Mem: 2848 346 1794 8 706 2263
Swap: 1023 0 1023
仔细看看，我的系统当中有 2848MB 左右的实体内存，我的 swap 有 1GB 左右， 那我使用 free -m 以 MBytes 来显示时，就会出现上面
的信息。Mem 那一行显示的是实体内存的量， Swap 则是内存交换空间的量。 total 是总量， used 是已被使用的量， free 则是剩余可用的
量。 后面的 shared/buffers/cached 则是在已被使用的量当中，用来作为缓冲及高速缓存的量，这些 shared/buffers/cached 的用量中，在系统
比较忙碌时， 可以被释出而继续利用！因此后面就有一个 available （可用的） 数值！ 。
请看上头范例一的输出，我们可以发现这部测试机根本没有什么特别的服务，但是竟然有 706MB 左右的 cache 耶！ 因为鸟哥在测试过
程中还是有读/写/执行很多的文件嘛！这些文件就会被系统暂时高速缓存下来，等待下次运行时可以更快速的取出之意！ 也就是说，系统是“很
有效率的将所有的内存用光光”，目的是为了让系统的存取性能加速啦！
很多朋友都会问到这个问题“我的系统明明很轻松，为何内存会被用光光？”现在了了吧？ 被用光是正常的！而需要注意的反而是 swap
的量。一般来说， swap 最好不要被使用，尤其 swap 最好不要被使用超过 20% 以上， 如果您发现 swap 的用量超过 20% ，那么，最好还是
买实体内存来插吧！ 因为， Swap 的性能跟实体内存实在差很多，而系统会使用到 swap ， 绝对是因为实体内存不足了才会这样做的！如此，
了解吧！
Tips
Linux 系统为了要加速系统性能，所以会将最常使用到的或者是最近使用到的文件数据高速缓存 （cache） 下来， 这样未来系统要使用该文件
时，就直接由内存中搜寻取出，而不需要重新读取硬盘，速度上面当然就加快了！ 因此，实体内存被用光是正常的喔！
uname：：查查阅阅系系统统与与核核心心相相关关信信息息
[root@study ~]# uname [-asrmpi]
选项与参数：
-a ：所有系统相关的信息，包括下面的数据都会被列出来；
-s ：系统核心名称
-r ：核心的版本
-m ：本系统的硬件名称，例如 i686 或 x86_64 等；
-p ：CPU 的类型，与 -m 类似，只是显示的是 CPU 的类型！
-i ：硬件的平台 （ix86）
范例一：输出系统的基本信息
[root@study ~]# uname -a
Linux study.centos.vbird 3.10.0-229.el7.x86_64 #1 SMP Fri Mar 6 11:36:42 UTC 2015
x86_64 x86_64 x86_64 GNU/Linux
这个咚咚我们前面使用过很多次了喔！uname 可以列出目前系统的核心版本、 主要硬件平台以及 CPU 类型等等的信息。以上面范例一
的状态来说，我的 Linux 主机使用的核心名称为 Linux，而主机名称为 study.centos.vbird，核心的版本为 3.10.0-229.el7.x86_64 ，该核心版本
创建的日期为 2015-3-6，适用的硬件平台为 x86_64 以上等级的硬件平台喔。
uptime：：观观察察系系统统启启动动时时间间与与工工作作负负载载
这个指令很单纯呢！就是显示出目前系统已经开机多久的时间，以及 1, 5, 15 分钟的平均负载就是了。还记得 top 吧？没错啦！这个
uptime 可以显示出 top 画面的最上面一行！
[root@study ~]# uptime
02:35:27 up 7:48, 3 users, load average: 0.00, 0.01, 0.05
# top 这个指令已经谈过相关信息，不再聊！
netstat ：：追追踪踪网网络络或或插插槽槽档档
这个 netstat 也是挺好玩的，其实这个指令比较常被用在网络的监控方面，不过，在程序管理方面也是需要了解的啦！ 这个指令的执行
如下所示：基本上， netstat 的输出分为两大部分，分别是网络与系统自己的程序相关性部分：
[root@study ~]# netstat -[atunlp]
选项与参数：
-a ：将目前系统上所有的连线、监听、Socket 数据都列出来
-t ：列出 tcp 网络封包的数据
-u ：列出 udp 网络封包的数据
-n ：不以程序的服务名称，以埠号 （port number） 来显示；