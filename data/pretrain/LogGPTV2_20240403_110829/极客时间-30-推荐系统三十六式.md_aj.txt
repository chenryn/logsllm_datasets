### 1. 有限数据集 {#08.html#1-}等概率采样的方法非常简单，任意编程语言中都有伪随机数实现，就不在本文讨论范围内了。现在假设你有用户标签若干，每一个标签都有个权重w，权重高低反映了用户对这个标签的感兴趣程度高低。你希望每次输出一部分标签用于召回推荐候选集，每次输出时都不一样，但是又能反映用户标签的权重，输出的概率和权重成正比。这时候你需要一个公式：]{.MathJax_Preview style="color: inherit; display: none;"} {.MathJax_Display style="text-align: center;"}``{=html}[[[[[S[]{style="display: inline-block; overflow: hidden; height: 1px; width: 0.049em;"}]{#08.html#MathJax-Span-4.mistyle="font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.155em, 1000.66em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[i]{#08.html#MathJax-Span-7.mistyle="font-size: 70.7%; font-family: MathJax_Math-italic;"}]{#08.html#MathJax-Span-6.mrow}]{#08.html#MathJax-Span-5.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -3.856em; left: 0.614em;"}]{style="display: inline-block; position: relative; width: 0.944em; height: 0px;"}]{#08.html#MathJax-Span-3.msubsup}[=]{#08.html#MathJax-Span-8 .mostyle="font-family: MathJax_Main; padding-left: 0.285em;"}[R]{#08.html#MathJax-Span-10.mistyle="font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.155em, 1000.75em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[[[[1]{#08.html#MathJax-Span-14.mnstyle="font-size: 50%; font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.532em, 1000.24em, 4.144em, -999.998em); top: -4.327em; left: 50%; margin-left: -0.139em;"}[[w]{#08.html#MathJax-Span-16.mistyle="font-size: 50%; font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.626em, 1000.33em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[i]{#08.html#MathJax-Span-19.mistyle="font-size: 50%; font-family: MathJax_Math-italic;"}]{#08.html#MathJax-Span-18.mrow}]{#08.html#MathJax-Span-17.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -3.856em; left: 0.379em;"}]{style="display: inline-block; position: relative; width: 0.567em; height: 0px;"}]{#08.html#MathJax-Span-15.msubsup}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.626em, 1000.57em, 4.285em, -999.998em); top: -3.762em; left: 50%; margin-left: -0.28em;"}[[]{style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 0.708em; height: 0px;"}[]{style="display: inline-block; width: 0px; height: 1.085em;"}]{style="position: absolute; clip: rect(0.896em, 1000.71em, 1.226em, -999.998em); top: -1.221em; left: 0em;"}]{style="display: inline-block; position: relative; width: 0.708em; height: 0px; margin-right: 0.144em; margin-left: 0.144em;"}]{#08.html#MathJax-Span-13.mfrac}]{#08.html#MathJax-Span-12 .mrow}]{#08.html#MathJax-Span-11.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.515em; left: 0.755em;"}]{style="display: inline-block; position: relative; width: 1.744em; height: 0px;"}]{#08.html#MathJax-Span-9.msubsup style="padding-left: 0.285em;"}]{#08.html#MathJax-Span-2.mrow}[]{style="display: inline-block; width: 0px; height: 2.355em;"}]{style="position: absolute; clip: rect(1.038em, 1004.05em, 2.638em, -999.998em); top: -2.351em; left: 0em;"}]{style="display: inline-block; position: relative; width: 4.049em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.232em; border-left: 0px solid; width: 0px; height: 1.768em;"}]{#08.html#MathJax-Span-1.mathstyle="width: 5.085em; display: inline-block;"}``{=html}[$$S_{i} = R^{\frac{1}{w_{i}}}$$]{.MJX_Assistive_MathML.MJX_Assistive_MathML_Blockrole="presentation"}]{#08.html#MathJax-Element-1-Frame .MathJaxtabindex="0" style="text-align: center; position: relative;"mathml="Si=R1wi"role="presentation"}$$$$解释一下这个公式：1.  wi 是每个样本的权重，比如用户标签权重；2.  R 是遍历每个样本时产生的 0 到 1 之间的随机数；3.  Si 就是每个样本的采样分数遍历之后，按照采样分数排序，输出前 k个结果就是你得到的采样结果。可以编程简单做个模拟，比如下面有这样几个简单样本。![](Images/6c683656e4530edd21b4ae72bddef2d8.png){savepage-src="https://static001.geekbang.org/resource/image/70/7e/70e81cc194a14ba091a91ecb8bf2477e.png"}模拟 10000 次后，三个样本被采样次数如下：![](Images/3fe7fca8d75c3823ff9a9e4b04c5b3e5.png){savepage-src="https://static001.geekbang.org/resource/image/dc/27/dc701147b5785fd40ad7205364feeb27.png"}你可以看到，每个样本采样概率和它的权重成正比。还有另一种加权采样方法，是利用指数分布。我先给忘记了指数分布的人复习一下什么是指数分布。假设你到银行去办业务，每个人办理业务的时间是不确定的，那每个人办理业务时间的概率分布就是指数分布，用教科书上的话说，就是两个事件发生的时间间隔。指数分布的概率密度函数是：![](Images/50e250a397f8d799c4d58b327c8f093a.png){savepage-src="https://static001.geekbang.org/resource/image/98/70/9894def1fc772650414574cbfbd55170.png"}指数分布的参数 Lambda，它的倒数，[]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[[[[1]{#08.html#MathJax-Span-23.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.391em, 1000.28em, 4.144em, -999.998em); top: -4.374em; left: 50%; margin-left: -0.186em;"}[[λ]{#08.html#MathJax-Span-24.mistyle="font-size: 70.7%; font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.391em, 1000.38em, 4.144em, -999.998em); top: -3.621em; left: 50%; margin-left: -0.186em;"}[[]{style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 0.52em; height: 0px;"}[]{style="display: inline-block; width: 0px; height: 1.085em;"}]{style="position: absolute; clip: rect(0.896em, 1000.52em, 1.226em, -999.998em); top: -1.315em; left: 0em;"}]{style="display: inline-block; position: relative; width: 0.52em; height: 0px; margin-right: 0.144em; margin-left: 0.144em;"}]{#08.html#MathJax-Span-22.mfrac}]{#08.html#MathJax-Span-21.mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.32em, 1000.8em, 2.826em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 0.802em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.526em; border-left: 0px solid; width: 0px; height: 1.709em;"}]{#08.html#MathJax-Span-20.mathstyle="width: 1.038em; display: inline-block;"}``{=html}[$\frac{1}{\lambda}$]{.MJX_Assistive_MathMLrole="presentation"}]{#08.html#MathJax-Element-2-Frame .MathJaxtabindex="0" style="position: relative;"mathml="1λ"role="presentation"}$$就是事件发生时间间隔的期望。把指数分布的这个意义放进标签中来考虑，标签的权重其实反映一个直觉：权重越大的标签，用户消费它就越频繁，也就是间隔时间就会短。所以根据这个原理，就有另一个加权采样的办法：为每一个标签构造一个指数分布随机数，这个指数分布的参数Lambda就是标签权重，然后用这个指数分布的产生一个随机数，再输出随机数最大的 k个标签作为采样结果, 是不是很完美？还是上面的权重，再来模拟 10000 次。![](Images/49ef87c69c6182979ea846ef7838b845.png){savepage-src="https://static001.geekbang.org/resource/image/46/df/468fcee6b610b57649a62ad9904e75df.png"}依然完美符合权重的相对大小。
### 2. 无限数据集 {#08.html#2-}上面的两种采样都是针对有限数据集的，也就是采样之前都要遍历一遍所有样本。那么如果面对的数据集无限大，或者不知道多大时，该怎么做加权采样呢？这就要讲到另一个采样算法了，名字叫蓄水池采样（也叫蓄水池抽样）。蓄水池采样可以用在推荐系统的哪些地方呢？比如可以再模型融合之后加一层蓄水池抽样，或者在召回阶段加一层蓄水池采样，这样在不影响整个推荐流程和转化概率的前提下，降低计算复杂度和提升推荐多样性。或者，在线阶段要使用用户的反馈行为做实时推荐，对于不同的用户，活跃程度不同，产生的反馈行为数量不同，你也可以用蓄水池采样，为每个用户取出固定数量的行为用于更新推荐结果。下面，我先讲蓄水池采样，再讲加权蓄水池采样。假如有一个数据集合，一共有 n 条，要从中采样取出 k个，那么每个样本被选中的概率就是 []{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[[[[k]{#08.html#MathJax-Span-28.mistyle="font-size: 70.7%; font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.391em, 1000.38em, 4.144em, -999.998em); top: -4.421em; left: 50%; margin-left: -0.186em;"}[[n]{#08.html#MathJax-Span-29.mistyle="font-size: 70.7%; font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.532em, 1000.43em, 4.144em, -999.998em); top: -3.668em; left: 50%; margin-left: -0.233em;"}[[]{style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 0.567em; height: 0px;"}[]{style="display: inline-block; width: 0px; height: 1.085em;"}]{style="position: absolute; clip: rect(0.896em, 1000.57em, 1.226em, -999.998em); top: -1.315em; left: 0em;"}]{style="display: inline-block; position: relative; width: 0.567em; height: 0px; margin-right: 0.144em; margin-left: 0.144em;"}]{#08.html#MathJax-Span-27.mfrac}]{#08.html#MathJax-Span-26.mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.273em, 1000.85em, 2.779em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 0.849em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.468em; border-left: 0px solid; width: 0px; height: 1.709em;"}]{#08.html#MathJax-Span-25.mathstyle="width: 1.085em; display: inline-block;"}``{=html}[$\frac{k}{n}$]{.MJX_Assistive_MathMLrole="presentation"}]{#08.html#MathJax-Element-3-Frame .MathJaxtabindex="0" style="position: relative;"mathml="kn"role="presentation"}$$ 。蓄水池采样的做法是：1.  直接先取出前 k 个样本留着，这 k 个就是随时准备最终要输出的；2.  从第 k+1 个开始，每个都以 []{.MathJax_Preview    style="color: inherit; display: none;"}[``{=html}[[[[[k]{#08.html#MathJax-Span-33    .mi    style="font-size: 70.7%; font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.391em, 1000.38em, 4.144em, -999.998em); top: -4.421em; left: 50%; margin-left: -0.186em;"}[[n]{#08.html#MathJax-Span-34    .mi    style="font-size: 70.7%; font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.532em, 1000.43em, 4.144em, -999.998em); top: -3.668em; left: 50%; margin-left: -0.233em;"}[[]{style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 0.567em; height: 0px;"}[]{style="display: inline-block; width: 0px; height: 1.085em;"}]{style="position: absolute; clip: rect(0.896em, 1000.57em, 1.226em, -999.998em); top: -1.315em; left: 0em;"}]{style="display: inline-block; position: relative; width: 0.567em; height: 0px; margin-right: 0.144em; margin-left: 0.144em;"}]{#08.html#MathJax-Span-32    .mfrac}]{#08.html#MathJax-Span-31    .mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.273em, 1000.85em, 2.779em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 0.849em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.468em; border-left: 0px solid; width: 0px; height: 1.709em;"}]{#08.html#MathJax-Span-30    .math    style="width: 1.085em; display: inline-block;"}``{=html}[$\frac{k}{n}$]{.MJX_Assistive_MathML    role="presentation"}]{#08.html#MathJax-Element-4-Frame .MathJax    tabindex="0" style="position: relative;"    mathml="kn"    role="presentation"}$$ 的概率去替换那留着的 k 个样本中的一个。这个过程，随时可以取用那个 k个集合作为输出结果，任意时刻，当总样本遍历了 n 个时，他们的概率都是]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[[[[k]{#08.html#MathJax-Span-38.mistyle="font-size: 70.7%; font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.391em, 1000.38em, 4.144em, -999.998em); top: -4.421em; left: 50%; margin-left: -0.186em;"}[[n]{#08.html#MathJax-Span-39.mistyle="font-size: 70.7%; font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.532em, 1000.43em, 4.144em, -999.998em); top: -3.668em; left: 50%; margin-left: -0.233em;"}[[]{style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 0.567em; height: 0px;"}[]{style="display: inline-block; width: 0px; height: 1.085em;"}]{style="position: absolute; clip: rect(0.896em, 1000.57em, 1.226em, -999.998em); top: -1.315em; left: 0em;"}]{style="display: inline-block; position: relative; width: 0.567em; height: 0px; margin-right: 0.144em; margin-left: 0.144em;"}]{#08.html#MathJax-Span-37.mfrac}]{#08.html#MathJax-Span-36.mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.273em, 1000.85em, 2.779em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 0.849em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.468em; border-left: 0px solid; width: 0px; height: 1.709em;"}]{#08.html#MathJax-Span-35.mathstyle="width: 1.085em; display: inline-block;"}``{=html}[$\frac{k}{n}$]{.MJX_Assistive_MathMLrole="presentation"}]{#08.html#MathJax-Element-5-Frame .MathJaxtabindex="0" style="position: relative;"mathml="kn"role="presentation"}$$ 。这就是蓄水池采样，蓄水池采样，顾名思义，k个元素的样本集合就是个蓄水池，是任意时刻的采样结果，可以随时取用。现在回到我们今天的主题来，实际上更需要的是加权蓄水池采样。加权蓄水池采样利用的依然是在前面说的第一种加权采样方法，只不过结合了蓄水池采样的思想。要从大数据集中采样 k 个，其具体做法是这样的：1.  为每一个样本生成一个分数，分数还是用这个公式 []{.MathJax_Preview    style="color: inherit; display: none;"}[``{=html}[[[[[S[]{style="display: inline-block; overflow: hidden; height: 1px; width: 0.049em;"}]{#08.html#MathJax-Span-43    .mi    style="font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.155em, 1000.66em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[i]{#08.html#MathJax-Span-46    .mi    style="font-size: 70.7%; font-family: MathJax_Math-italic;"}]{#08.html#MathJax-Span-45    .mrow}]{#08.html#MathJax-Span-44    .texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -3.856em; left: 0.614em;"}]{style="display: inline-block; position: relative; width: 0.944em; height: 0px;"}]{#08.html#MathJax-Span-42    .msubsup}[=]{#08.html#MathJax-Span-47 .mo    style="font-family: MathJax_Main; padding-left: 0.285em;"}[R]{#08.html#MathJax-Span-49    .mi    style="font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.155em, 1000.75em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[[[[1]{#08.html#MathJax-Span-53    .mn    style="font-size: 50%; font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.532em, 1000.24em, 4.144em, -999.998em); top: -4.327em; left: 50%; margin-left: -0.139em;"}[[w]{#08.html#MathJax-Span-55    .mi    style="font-size: 50%; font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.626em, 1000.33em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[i]{#08.html#MathJax-Span-58    .mi    style="font-size: 50%; font-family: MathJax_Math-italic;"}]{#08.html#MathJax-Span-57    .mrow}]{#08.html#MathJax-Span-56    .texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -3.856em; left: 0.379em;"}]{style="display: inline-block; position: relative; width: 0.567em; height: 0px;"}]{#08.html#MathJax-Span-54    .msubsup}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.626em, 1000.57em, 4.285em, -999.998em); top: -3.762em; left: 50%; margin-left: -0.28em;"}[[]{style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 0.708em; height: 0px;"}[]{style="display: inline-block; width: 0px; height: 1.085em;"}]{style="position: absolute; clip: rect(0.896em, 1000.71em, 1.226em, -999.998em); top: -1.221em; left: 0em;"}]{style="display: inline-block; position: relative; width: 0.708em; height: 0px; margin-right: 0.144em; margin-left: 0.144em;"}]{#08.html#MathJax-Span-52    .mfrac}]{#08.html#MathJax-Span-51 .mrow}]{#08.html#MathJax-Span-50    .texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.515em; left: 0.755em;"}]{style="display: inline-block; position: relative; width: 1.744em; height: 0px;"}]{#08.html#MathJax-Span-48    .msubsup style="padding-left: 0.285em;"}]{#08.html#MathJax-Span-41    .mrow}[]{style="display: inline-block; width: 0px; height: 2.355em;"}]{style="position: absolute; clip: rect(1.038em, 1004.05em, 2.638em, -999.998em); top: -2.351em; left: 0em;"}]{style="display: inline-block; position: relative; width: 4.049em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.232em; border-left: 0px solid; width: 0px; height: 1.768em;"}]{#08.html#MathJax-Span-40    .math    style="width: 5.085em; display: inline-block;"}``{=html}[$S_{i} = R^{\frac{1}{w_{i}}}$]{.MJX_Assistive_MathML    role="presentation"}]{#08.html#MathJax-Element-6-Frame .MathJax    tabindex="0" style="position: relative;"    mathml="Si=R1wi"    role="presentation"}$$;2.  如果结果不足 k 个，直接保存到结果中；3.  如果结果中已经有 k 个了，如果 []{.MathJax_Preview    style="color: inherit; display: none;"}[``{=html}[[[[[S[]{style="display: inline-block; overflow: hidden; height: 1px; width: 0.049em;"}]{#08.html#MathJax-Span-62    .mi    style="font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.155em, 1000.66em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[i]{#08.html#MathJax-Span-65    .mi    style="font-size: 70.7%; font-family: MathJax_Math-italic;"}]{#08.html#MathJax-Span-64    .mrow}]{#08.html#MathJax-Span-63    .texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -3.856em; left: 0.614em;"}]{style="display: inline-block; position: relative; width: 0.944em; height: 0px;"}]{#08.html#MathJax-Span-61    .msubsup}]{#08.html#MathJax-Span-60    .mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.461em, 1000.94em, 2.591em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 0.944em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.232em; border-left: 0px solid; width: 0px; height: 1.179em;"}]{#08.html#MathJax-Span-59    .math    style="width: 1.179em; display: inline-block;"}``{=html}[$S_{i}$]{.MJX_Assistive_MathML    role="presentation"}]{#08.html#MathJax-Element-7-Frame .MathJax    tabindex="0" style="position: relative;"    mathml="Si"    role="presentation"}$$ 比已有的结果里最小那个分数大，就替换它。
## 总结 {#08.html#-}今天介绍的算法非常简单，但是在推荐系统中有很多的用途。尤其是面对的数据需要采样、需要有所变化时，加权采样本质上来说就是让权重影响采样概率。前面的几种加权采样算法，都是让采样概率和权重成正比，这意味着你的样本权重之间的关系要合理。那么，请思考另一个问题，如果你的样本权重有正有负，该如何加权采样呢？欢迎留言一起讨论。感谢你的收听，我们下次再见。![](Images/d3b48a2755db0a3707ef37007c2179c8.png){savepage-src="https://static001.geekbang.org/resource/image/87/b0/873b086966136189db14874181823fb0.jpg"}
# 【其他应用算法】推荐候选池的去重策略今天依然要讲到两个问题，它们看似和推荐系统没有必然关系，但实际上，在你构建自己的推荐系统的时候，不可避免地会遇到这两个问题。
## 去重是刚需 {#09.html#-}在推荐系统中，有一个刚需就是去重，那么说在哪些地方有去重的需求呢？主要是在两个地方：一个是内容源去重，另一个是不重复给用户推荐。先说说内容源的去重，这部分以前几年的图文信息流推荐为典型的例子。如果一个平台自己不生产内容，只是做内容搬运和聚合分发，那么从大量第三方的内容生产处抓取内容，就难免遇到相似甚至重复的内容。这就需要对内容做一个重复检测了。对内容做重复检测，直观的思路是分词，然后提取关键词，再两两计算词向量之间的距离，距离小于一定阈值后就判定为重复。然而，这对于海量内容，比如几千万以上的内容来说简直就是灾难。其实，内容源去重并不是仅在推荐系统中才首次出现，这早在搜索引擎时代就是一个刚需了，搜索引擎把整个互联网的网页都下载到自己的服务器上，这时，重复冗余的内容就需要被检测出来。另一个需求是在内容阅读类推荐场景下，给用户推荐的内容不要重复，推荐过的内容就不再出现在推荐候选集中。在你刷一个信息流产品时，不断看到重复的内容，想必不是使用感很好的一件事。因为以抓取作为主要内容来源的信息流产品，不同于社交网站上用户自发产生内容，除非遇到用户恶意发送，否则后者是不容易重复的。以上两个场景，需要在你打造自己的推荐系统时予以考虑和应对。今天就介绍两种最常见的去重算法，两者有相通之处也有不同的之处，听我慢慢说来。``{=html}