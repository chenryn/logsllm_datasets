    The [task manager](task_management.md#task-manager) tool to make your
    interaction with the tasks easier. You can start with the [simplest task
    manager](task_management.md#the-simplest-task-manager), a markdown file
    in your computer with a list of tasks to do. Annotate only the
    actionable tasks that you need to do today, otherwise it can quickly
    grow to be unmanageable.
* Improvement: Add the benefits when you do task management well, and the side effects if you do it wrong.
* Improvement: Add a small guide on how to introduce yourself into task management.
### [Task Management Workflows](life_planning.md)
* New: Introduce the main task management workflows.
    Task management can be done at different levels. All of them help you in
    different ways to reduce the mental load, each also gives you extra benefits
    that can't be gained by the others. Going from lowest to highest abstraction
    level we have:
    * Pomodoro.
    * Task plan.
    * Day plan.
    * Week plan.
    * Month plan.
    * Semester plan.
    In the commit I've detailed the [Pomodoro technique](life_planning.md#pomodoro) and the [task](life_planning.md#task-plan), [day](life_planning.md#day-plan) and [week](life_planning.md#week-plan) plans.
* New: [Explain the difference of surfing the hype flow versus following a defined plan.](life_planning.md#hype-flow-versus-a-defined-plan)
## [Interruption Management](interruption_management.md)
* New: Introduce the interruption management concept.
    Interruption management is the [life management](life_management.md) area that
    gathers the processes to minimize the time and willpower toll consumed by
    interruptions.
    The article proposes a way to analyze your existent interruptions and define how can you improve your interaction with them. I've applied it both to my [work](work_interruption_analysis.md) and [personal](personal_interruption_analysis.md) interruptions.
* Improvement: [Explain what to do once you have the interruption analysis.](interruption_management.md#workflow)
### [Work Interruption Analysis](work_interruption_analysis.md)
* Improvement: Add analysis of instant message interruptions.
### [Personal Interruption Analysis](personal_interruption_analysis.md)
* Improvement: Add analysis of instant message interruptions.
## [Money Management](money_management.md)
* Reorganization: Move the accounting automation to money management.
## [Email Management](email_management.md)
* New: Explain how I configure and interact with email efficiently.
### [Email Automation](email_automation.md)
* New: Explain how setup an infrastructure to automate.
## [Music Management](music_management.md)
* New: Introduce how I manage my music library.
### [MusicBrainz](musicbrainz.md)
* New: How to contribute to MusicBrainz.
    [MusicBrainz](https://musicbrainz.org) is an open music encyclopedia that
    collects music metadata and makes it available to the public.
    MusicBrainz aims to be:
    * The ultimate source of music information by allowing anyone to contribute and
        releasing the data under open licenses.
    * The universal lingua franca for music by providing a reliable and unambiguous
        form of music identification, enabling both people and machines to have
        meaningful conversations about music.
    Like Wikipedia, MusicBrainz is maintained by a global community of users and we
    want everyone — including you — to [participate and contribute](https://musicbrainz.org/doc/How_to_Contribute).
## [Book Management](book_management.md)
* New: Introduce the book management concept.
    Book management is the set of systems and processes to get and categorize books
    so it's easy to browse and discover new content. It involves the next actions:
    * Automatically index and download metadata of new books.
    * Notify the user when a new book is added.
    * Monitor the books of an author, and get them once they are released.
    * Send books to the e-reader.
    * A nice interface to browse the existent library, with the possibility of
        filtering by author, genre, years, tags or series.
    * An interface to preview or read the items.
    * An interface to rate and review library items.
    * An interface to discover new content based on the ratings and item metadata.
    I haven't yet found a single piece of software that fulfills all these needs, in the article I tell you about [Readarr](https://readarr.com/), [Calibre-web](https://github.com/janeczku/calibre-web), [calibre]((https://manual.calibre-ebook.com/), [Polar bookself](https://getpolarized.io/), [GCStar](http://www.gcstar.org/), and how they interact with each other.
* Improvement: Add link to the calibre-web kobo integration project.
## [Map Management](map_management.md)
* New: How I manage maps in my life.
    For navigating on the go, I strongly recommend [OSMand+](osmand.md), for
    browsing maps in the browser, use [OpenStreetMaps](https://osm.org) or
    [CyclOSM](https://www.cyclosm.org) if you want to move by bike.
    To plan routes, you can use [brouter.de](https://brouter.de/brouter-web), it works perfectly for bikes. For hiking is awesome too, it shows you a lot of data needed to plan your tracks (check the settings on the right). If you want to invest a little more time, you can even set your [personalize profiles](https://github.com/poutnikl/Brouter-profiles/wiki/Hiking-profiles), so that the routing algorithm prioritizes the routes to your desires. It's based on [brouter](https://github.com/abrensch/brouter) and both can be [self-hosted](https://github.com/nrenner/brouter-web), although [brouter does not yet use Docker](https://github.com/abrensch/brouter/issues/359).
## [Instant Messages Management](instant_messages_management.md)
* New: Explain how I configure and interact with chat applications efficiently.
## [Process Automation](process_automation.md)
* Improvement: Add xkcd comics that gather the essence and pitfalls of process automation.
### [Virtual Assistant](virtual_assistant.md)
* New: Introduce project with kalliope.
* New: Explain the Speech-To-Text open source solutions.
# Health
## [Sleep](sleep.md)
* New: [Explain the sleep cycle.](sleep.md#the-sleep-cycle)
    Humans cycle through two types of sleep in a regular pattern throughout the
    night with a period of 90 minutes. They were called non-rapid eye movement (NREM) and rapid
    eye movement (REM).
    I answer the questions:
    * What is the period of the REM/NREM cycle?
    * What happens to your body in REM and NREM phases?
    * How does the ratio of REM/NREM changes throughout the night? with
        a possible explanation.
    * Why sleeping 6 hours can make you loose up to 90% of your REM or NREM phases?
* New: [Explain sleeping time and sense distortions.](sleep.md#sleeping-time-and-sense-distortions)
    Answer the questions:
    * Why time feels longer in our dreams?
    * How do we loose awareness of the outside world when sleeping?
## [Teeth](teeth.md)
* New: Explain how to take care of your teeth.
    A full guide on why should you take care of your teeth, the description
    on how the basic oral diseases work, why and how to brush your teeth, floss and usage of mouthwash
* Correction: Recommend a regular clean instead of a deep clean.
### [Deep cleaning](teeth_deep_cleaning.md)
* New: Explain what a deep cleaning is and when should you do it.
    Analyze the reasons why would you need to do this procedure, how it
    works, when you need to do it, side effects and scientific evidences of
    it's effectiveness.
## [Fitness Tracker](fitness_band.md)
* New: Introduce the fitness band in your life automation.
    [Fitness tracker](https://en.wikipedia.org/wiki/Activity_tracker) or activity
    trackers are devices or applications for monitoring and tracking fitness-related
    metrics such as distance walked or run, calorie consumption, and in some cases
    heartbeat. It is a type of wearable computer.
    Explain also why it's interesting
* Improvement: Discovery of wasp-os and Colmi P8.
    [wasp-os](https://github.com/daniel-thompson/wasp-os) is an open source
    firmware for smart watches that are based on the nRF52 family of
    microcontrollers. Fully supported by [gadgetbridge](gadgetbridge.md),
    Wasp-os features full heart rate monitoring and step counting support
    together with multiple clock faces, a stopwatch, an alarm clock,
    a countdown timer, a calculator and lots of other games and utilities.
    All of this, and still with access to the MicroPython REPL for
    interactive tweaking, development and testing.
    One of the supported devices, the [Colmi
    P8](https://wasp-os.readthedocs.io/en/latest/install.html#colmi-p8),
    looks really good.
### [Amazfit Band 5](amazfit_band_5.md)
* New: Add insights on sleep detection.
    The sleep tracking using Gadgetbridge is not [good at
    all](https://codeberg.org/Freeyourgadget/Gadgetbridge/wiki/Huami-Deep-Sleep-Detection).
    After two nights, the band has not been able to detect when I woke in the middle
    of the night, or when I really woke up, as I usually stay in the bed for a time
    before standing up. I'll try with the proprietary application soon and compare results.
* New: Explain how to upgrade the firmware.
    Gadgetbridge people have a [guide on how to upgrade the
    firmware](https://codeberg.org/Freeyourgadget/Gadgetbridge/wiki/Amazfit-Band-5-Firmware-Update),
    you need to get the firmware from the [geek doing
    forum](https://geekdoing.com/threads/amazfit-band-5-original-firmwares-resources-fonts.2331/)
    though, so it is interesting to create an account and watch the post.
* Improvement: Add insights on sleep tracking.
    You can't use the Withings sleep analyzer without their app (as
    expected), maybe the [Emfit
    QS](https://github.com/karlicoss/HPI/blob/master/my/emfit/__init__.py)
    is the way to go.
# [Coding](vuejs.md)
* New: Introduce Vue.js.
    [Vue.js](https://vuejs.org) is a progressive framework for building user
    interfaces.
## Generic Coding Practices
### [Program Versioning](versioning.md)
* New: Define how to use versioning in software.
    A **long** article on how to use versioning both as a developer and as a consumer. It includes:
    * [Deciding what version system to use for your programs](versioning.md#deciding-what-version-system-to-use-for-your-programs).
    * [How to evolve your code version](versioning.md#how-to-evolve-your-code-version).
    * [Deciding how to manage the versions of your dependencies](versioning.md#deciding-how-to-manage-the-versions-of-your-dependencies).
    * A huge rant on [Upper version pinning](versioning.md#upper-version-pinning).
    * [When to use lower version pinning](versioning.md#lower-version-pinning).
    * [How to automatically upgrade and test your dependencies](versioning.md#automatically-upgrade-and-test-your-dependencies).
    * [Monitor your dependencies evolution](versioning.md#monitor-your-dependencies-evolution).
### [Keep a Changelog](semantic_versioning.md)
* New: Introduce the Changelog practice.
    A changelog is a file which contains a curated, chronologically ordered list of notable changes for each version of a project.
    It's purpose is to make it easier for users and contributors to see precisely what notable changes have been made between each release (or version) of the project.
    In the article we added:
    * [Guidelines](changelog.md#changelog-guidelines) on how to build good changelogs
    * [How to reduce the effort required to maintain a changelog](changelog.md#how-to-reduce-the-effort-required-to-maintain-a-changelog)
* New: Introduce Semantic Versioning.
    [Semantic Versioning](https://semver.org/) is a way to define your program's version based on the type of changes you've introduced. It's defined as a three-number string (separated with a period) in the format of `MAJOR.MINOR.PATCH`.
    Also included in the article is:
    * [When to do a major release](semantic_versioning.md#when-to-do-a-major-release).
    * [Semantic versioning system problems](semantic_versioning.md#semantic-versioning-system-problems).
### [Calendar Versioning](documentation.md)
* New: Start explaining how to write good documentation for a software project.
    It doesn't matter how good your program is, because if its documentation is not
    good enough, people will not use it.
    People working with software need different kinds of documentation at different
    times, in different circumstances, so good software documentation needs them
    all. In this first iteration, I define the five kinds of documentation,
    and give the ideas to write good introduction and get started sections.
* New: Introduce Calendar Versioning.
    [Calendar Versioning](https://calver.org/) is a versioning convention based on
    your project's release calendar, instead of arbitrary numbers.
    CalVer suggests version number to be in format of: `YEAR.MONTH.sequence`. For example, `20.1` indicates a release in 2020 January, while `20.5.2` indicates a release that occurred in 2020 May, while the `2` indicates this is the third release of the month.
## [Python](python.md)
* New: Explain how to check if a loop ends completely.
* New: Explain how to merge lists and dictionaries.
* New: Explain how to create your own exceptions.
* New: Add python landing page.
* Improvement: Add aiomultiprocess to the list of libraries to test.
    [aiomultiprocess](https://github.com/omnilib/aiomultiprocess): Presents
    a simple interface, while running a full AsyncIO event loop on each
    child process, enabling levels of concurrency never before seen in
    a Python application. Each child process can execute multiple coroutines
    at once, limited only by the workload and number of cores available.
* New: [Add interesting links on how to write good documentation.](python.md#how-to-write-good-documentation)
    I would like to refactor
    [divio's](https://documentation.divio.com/introduction/) and
    [Vue's](https://v3.vuejs.org/guide/contributing/writing-guide.html#principles)
    guidelines and apply it to my projects.
* Improvement: Add FastAPI docs as a model to study and follow.
* New: Add apprise to the interesting libraries to explore.
    [apprise](https://github.com/caronc/apprise): Allows you to send
    a notification to almost all of the most popular notification services
    available to us today such as: Linux, Telegram, Discord, Slack, Amazon
    SNS, Gotify, etc. Look at [all the supported notifications](https://github.com/caronc/apprise#supported-notifications)
    `(¬º-°)¬`.
* New: Add kivi and kivimd to the interesting libraries to explore.
    [kivi](https://kivy.org/) is used to create android/Linux/iOS/Windows applications with python. Use it with [kivimd](https://github.com/kivymd/KivyMD) to make it beautiful, check [the examples](https://github.com/HeaTTheatR/Articles) and the [docs](https://kivymd.readthedocs.io/en/latest/).
* New: Add parso library to interesting libraries to explore.
    [parso](https://github.com/davidhalter/parso) is a library to parse Python code.
* Improvement: Add textual as interesting library to explore.
    [textual](https://github.com/willmcgugan/textual): Textual is a TUI (Text User Interface) framework for Python using Rich as a renderer.
* New: Add schedule to interesting libraries to explore.
    [schedule](https://github.com/dbader/schedule) is a Python job scheduling for humans. Run Python functions (or any other callable) periodically using a friendly syntax.
* New: Add tryceratops to interesting linters to try.
    [tryceratops](https://github.com/guilatrova/tryceratops) is a linter of exceptions.
### [Pydantic Field Types](asyncio.md)
* New: Introduce the asyncio library.
    [asyncio](https://docs.python.org/3/library/asyncio.html) is a library to write
    concurrent code using the async/await syntax.
    asyncio is used as a foundation for multiple Python asynchronous frameworks that
    provide high-performance network and web-servers, database connection libraries,
    distributed task queues, etc.
    asyncio is often a perfect fit for IO-bound and high-level structured network
    code.
* New: [Limit concurrency.](asyncio.md#limit-concurrency)
    Use [`asyncio.Semaphore`](https://docs.python.org/3/library/asyncio-sync.html#semaphores).
    ```python
    sem = asyncio.Semaphore(10)
    async with sem:
        # work with shared resource
    ```
* New: [Using constrained strings in list attributes.](pydantic_types.md#using-constrained-strings-in-list-attributes)
    ```python
    import re
    import pydantic
    from pydantic import Field
    from typing import List
    class Regex(pydantic.ConstrainedStr):
        regex = re.compile("^[0-9a-z_]*$")