approach to host based IDS which inhibits their use in actual deployment. The
ﬁrst is that the computational overhead of monitoring all system calls is very
high, which degrades the performance of a system. The second is that system
calls themselves are irregular by nature, which makes it diﬃcult to diﬀerentiate
between normal and malicious behaviors, which may cause a high false positive
rate.
In this paper, we examine a new approach to host IDS that monitors a pro-
gram’s use of the Windows Registry. We present a system called RAD (Registry
Anomaly Detection), which monitors the accesses to the registry in real time
and detects the actions of malicious software.
The Windows Registry is an important part of the Windows operating system
and is very heavily used, making it a good source of audit data. By building
a sensor on the registry and applying the information gathered to an anomaly
detector, we can detect activity that corresponds to malicious software. The main
advantages of monitoring the Windows Registry is that the activity is regular
by nature, can be monitored with low computational overhead, and almost all
system activities interact with the registry.
Our anomaly detection algorithm is a registry-speciﬁc version of PHAD
(Packet Header Anomaly Detection), an anomaly detection algorithm originally
presented to detect anomalies in packet headers [25]. We show that the data
generated by a registry sensor is useful in detecting malicious behavior. We shall
describe how various malicious programs use the registry, and what data can be
gathered from the registry to detect these malicious activities. We then apply an
anomaly detection algorithm to this data to detect abnormal registry behavior
38
F. Apap et al.
which corresponds to the actions of malicious software. By showing the results
of an experiment and detailing how various malicious activities use the registry,
we show that the registry is a good source of data for intrusion detection. The
paper will also discuss the modiﬁcations of the PHAD algorithm as it is applied
in the RAD system.
We present results of experiments evaluating the RAD system and demon-
strate that it is eﬀective in detecting attacks while maintaining a low rate of
false alarms.
2 Modeling Registry Accesses
2.1 The Windows Registry
In Microsoft Windows, the registry ﬁle is a database of information about a
computer’s conﬁguration. The registry contains information that is continually
referenced by many diﬀerent programs. Information stored in the registry in-
cludes the hardware installed on the system, which ports are being used, proﬁles
for each user, conﬁguration settings for programs, and many other parameters
of the system. It is the main storage location for all conﬁguration information
for many Window programs. The Windows Registry is also the source for all se-
curity information: policies, user names, and passwords. The registry also stores
much of the important run-time conﬁguration information that programs need
to run.
The registry is organized hierarchically as a tree. Each entry in the registry
is called a key and has an associated value. One example of a registry key is
HKCU\Software\America Online\AOL Instant Messenger (TM)
\CurrentVersion\Users\aimuser\Login\Password
This is a key used by the AOL instant messenger program. This key stores
an encrypted version of the password for the user name aimuser. Upon start up
the AOL instant messenger program queries this key in the registry in order to
retrieve the stored password for the local user. Information is accessed from the
registry by individual registry accesses or queries. The information associated
with a registry query is the key, the type of query, the result, the process that
generated the query and whether the query was successful. One example of a
query is a read for the key shown above. For example, the record of the query
is:
Process: aim.exe
Query: QueryValue
Key: HKCU\Software\America Online\AOL Instant Messenger
(TM)\CurrentVersion\Users\aimuser\Login\Password
Response: SUCCESS
ResultValue: " BCOFHIHBBAHF"
Detecting Malicious Software
39
The Windows Registry is an eﬀective data source to monitor attacks because
many attacks show up as anomalous registry behavior. Many attacks take ad-
vantage of Windows’ reliance on the registry. Indeed, many attacks themselves
rely on the Windows Registry in order to function properly.
Many programs store important information in the Registry, notwithstanding
the fact that other programs can arbitrarily access the information. Although
some versions of Windows include security permissions and Registry logging,
both features are rarely used (because of the computational overhead and the
complexity of the conﬁguration options).
2.2 Analysis of Malicious Registry Accesses
Most Windows programs access a certain set of Registry keys during normal
execution. Furthermore, most users use a certain set of programs routinely while
running their machines. This may be a set of all programs installed on the
machine or more typically a small subset of these programs. Another important
characteristic of Registry activity is that it tends to be regular over time. Most
programs either only access the registry on start-up and shutdown, or access
the registry at speciﬁc intervals. This regularity makes the registry an excellent
place to look for irregular, anomalous activity, since a malicious program may
substantially deviate from normal activity and can be detected.
Many attacks involve launching programs that have never been launched
before and changing keys that have not been changed since the operating system
had ﬁrst been installed by the manufacturer. If a model of the normal registry
behavior is computed over clean data, then these kinds of registry operations
will not appear in the model. Furthermore malicious programs may need to
query parts of the registry to get information about vulnerabilities. A malicious
program can also introduce new keys that will help create vulnerabilities in the
machine.
Some examples of malicious programs and how they produce anomalous reg-
istry activity are described below.
the
the Windows keys. The
– Setup Trojan: This program when launched adds
full
the host machine.
registry by creating a registry structure
structure
read/write
sharing access on the ﬁle system of
It makes
use of
in the net-
working section of
stems
from
HKLM\Software\Microsoft\Windows\CurrentVersion\Network\LanMan.
It then creates typically eight new keys for its own use. It also accesses
HKLM\Security\Provider in order to ﬁnd information about the security
of the machine to help determine vulnerabilities. This key is not accessed
by any normal programs during training or testing in our experiments and
its use is clearly suspicious in nature.
– Back Oriﬁce 2000: This program opens a vulnerability on a host machine,
which grants anyone with the back oriﬁce client program complete control
over the host machine. This program does make extensive use of the registry,
however, it uses a key that is very rarely accessed on the Windows system.
40
F. Apap et al.
HKLM\Software\Microsoft\VBA\Monitors was not accessed by any normal
programs in either the training or test data, which allowed our algorithm to
determine it as anomalous. This program also launches many other programs
(LoadWC.exe, Patch.exe, runonce.exe, bo2k 1 o intl.e) as part of the
attack all of which made anomalous accesses to the Windows Registry.
– Aimrecover: This is a program that steals passwords from AOL users.
It’s actually a very simple program that simply reads the keys from the
registry where the AOL Instant Messenger program stores the user names
and passwords. The reason that these accesses are anomalous is because
Aimrecover is accessing a key that usually is accessed by a diﬀerent program
that created that key.
– Disable Norton: This is a very simple exploitation of the registry that dis-
ables Norton Antivirus. This attack toggles one record in the registry, the key
HKLM\SOFTWARE\INTEL\LANDesk\VirusProtect6\CurrentVersion\Storages\
Files\System\RealTimeScan\OnOff. If this value is set to 0 then Norton
Antivirus real time system monitoring is turned oﬀ. Again this is anomalous
because of its access to a key that was created by a diﬀerent program.
– L0phtCrack: This program is probably the most popular password cracking
program for Windows machines. It retrieves the hashed SAM ﬁle contain-
ing the passwords for all users and then uses either a dictionary or brute
force approach to ﬁnd the passwords. This program also uses ﬂaws in the
Windows encryption scheme which allows the program to discover some of
the characters in the password. This program uses the registry by creating
its own section in the registry. This will consist of many create key and set
value queries, all of which will be on keys that did not exist previously on
the host machine and therefore have not been seen before.
Another important piece of information that can be used in detecting attacks,
all programs observed in our data set, and presumably all programs in general,
cause Windows Explorer to access a speciﬁc key. The key
HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File
Execution Options\processName
where processName is the name of the process being executed, is a key that is
accessed by Explorer each time an application is run. Therefore we have a ref-
erence point for each speciﬁc application being launched to determine malicious
activity. In addition many programs add themselves in the auto-run section of
the Windows Registry under
HKLM\Software\Microsoft\Windows \CurrentVersion\Run .
While this is not malicious in nature, this is a rare event that can deﬁnitely be
used as a hint that a system is being attacked. Trojan programs such as Back
Oriﬁce utilize this part of the registry to auto load themselves on each boot.
Anomaly detectors do not look for malicious activity directly. They look for
deviations from normal activity. It is for this reason that any deviation from
normal activity will be declared an attack by the system. The installation of
Detecting Malicious Software
41
a new program on a system will be viewed as anomalous activity. Programs
often create new sections of the registry and many new keys on installation.
This will cause a false alarm, much like adding a new machine to a network may
cause an alarm on an anomaly detector that analyzes network traﬃc. There are
a few possible solutions to this problem. Malicious programs are often stealthy
and install quietly so that the user does not know the program is being installed.
This is not the case with most user initiated (legitimate) application installations
that make themselves (loudly) known. The algorithm could be modiﬁed to ignore
alarms while the install shield program was running because that would mean
that the user is aware that a new program is being installed. Another option
is to simply prompt the user when a detection occurs so that the user can
let the anomaly detection system know that a legitimate installed program is
under way and that therefore the anomaly detection model needs to be updated
with a newly available training set gathered in real time. This is a typical user
interaction in many application installations where user feedback is requested
for conﬁguration information.
3 Registry Anomaly Detection
The RAD system has three basic components: an audit sensor, a model genera-
tor, and an anomaly detector. The sensor logs each registry activity to either a
database where it is stored for training, or to the detector to be used for anal-
ysis. The model generator reads data from the database and creates a model
of normal behavior. The model is then used by the anomaly detector to decide
whether each new registry access should be considered anomalous.
In order to detect anomalous registry accesses, RAD generates a model of
normal registry activity. A set of ﬁve features are extracted from each registry
access. Using these feature values over normal data, a model of normal registry
behavior is generated. This model of normalcy consists of a set of consistency
checks applied to the features. When detecting anomalies, the model of nor-
malcy determines whether the values in features of the current registry access
are consistent with the normal data or not. If new activity is not consistent, the
algorithm labels the access as anomalous.
3.1 RAD Data Model
The RAD data model consists of ﬁve features directly gathered from the registry
sensor. The ﬁve raw features used by the RAD system are as follows.
– Process: This is the name of process accessing the registry. This is useful
because it allows the tracking of new processes that did not appear in the
training data.
– Query: This is the type of query being sent to the registry, for example,
QueryValue, CreateKey, and SetValue are valid query types. This allows
the identiﬁcation of query types that have not been seen before. There are
many query types but only a few are used under normal circumstances.
42
F. Apap et al.
– Key: This is the actual key being accessed. This allows our algorithm to
locate keys that are never accessed in the training data. Many keys are used
only once for special situations like system installation. Some of these keys
can be used to create vulnerabilities.
– Response: This describes the outcome of the query, for example success,
not found, no more, buffer overflow, and access denied.
– Result Value: This is the value of the key being accessed. This will allow the
algorithm to detect abnormal values being used to create abnormal behavior
in the system.
Table 1. Registry Access Records. Two registry accesses are shown. The ﬁrst is a
normal access by AOL Instance Messenger to the key where passwords are stored.
The second is a malicious access by AIMrecover to the same key. The ﬁnal column
shows which ﬁelds register as anomalous. Note that the pairs of features must be used
to detect the anomalous behavior of AIMrecover.exe. This is because under normal
circumstances only AIM.exe accesses the key that stores the AIM password. Another
process accessing this key generates an anomaly.
3.2 RAD Anomaly Detection Algorithm
Using the features that we monitor from each registry access, we train a model
over features extracted from normal data. That model allows us to classify reg-
istry accesses as either normal or malicious.
Any anomaly detection algorithm can be used to perform this modeling.
Since we aim to monitor a signiﬁcant amount of data in real time, the algorithm
must be very eﬃcient. We apply a probabilistic algorithm described in Eskin,
2002 [14] and here we provide a short summary of the algorithm. The algorithm
is similar to the heuristic algorithm that was proposed by Chan and Mahoney
in the PHAD system [25], but is more robust.
In general, a principled probabilistic approach to anomaly detection can be
reduced to density estimation. If we can estimate a density function p(x) over
the normal data, we can deﬁne anomalies as data elements that occur with
low probability. In practice, estimating densities is a very hard problem (see the
Detecting Malicious Software
43
discussion in Sch¨olkopf et al., 1999 [26] and the references therein.) In our setting,
part of the problem is that each of the features have many possible values. For
example, the Key feature has over 30, 000 values in our training set. Since there
are so many possible feature values relatively rarely does the same exact record
occur in the data. Data sets with this characterization are referred to as sparse.
Since probability density estimation is a very hard problem over sparse data,
we propose a diﬀerent method for determining which records from a sparse data
set are anomalous. We deﬁne a set of consistency checks over the normal data.
Each consistency check is applied to an observed record. If the record fails any
consistency check, we label the record as anomalous.
We apply two kinds of consistency checks. The ﬁrst consistency check eval-
uates whether or not a feature value is consistent with observed values of that
feature in the normal data set. We refer to this type of consistency check as a ﬁrst
order consistency check. More formally, each registry record can be viewed as
the outcome of 5 random variables, one for each feature, X1, X2, X3, X4, X5. Our
consistency checks compute the likelihood of an observation of a given feature
which we denote P (Xi).
The second kind of consistency check handles pairs of features as motivated
by the example in Table 1. For each pair of features, we consider the conditional
probability of a feature value given another feature value. These consistency
checks are referred to as second order consistency checks. We denote these likeli-
hoods P (Xi|Xj). Note that for each value of Xj, there is a diﬀerent probability
distribution over Xi.
In our case, since we have 5 feature values, for each record, we have 5 ﬁrst
order consistency checks and 20 second order consistency checks. If the likelihood
of any of the consistency checks is below a threshold, we label the record as
anomalous.
What remains to be shown is how we compute the likelihoods for the ﬁrst
order (P (Xi)) and second order (P (Xi|Xj)) consistency checks. Note that from
the normal data, we have a set of observed counts from a discrete alphabet for
each of the consistency checks. Computing these likelihoods reduces to simply
estimating a multinomial. In principal we can use the maximum likelihood esti-
mate which just computes the ratio of the counts of a particular element to the
total counts. However, the maximum likelihood estimate is biased when there
is relatively small amounts of data. When estimating sparse data, this is the
case. We can smooth this distribution by adding a virtual count to each possi-
ble element. This is equivalent to using a Dirichlet estimator [11]. For anomaly
detection, as pointed out in Mahoney and Chan, 2001 [25], it is critical to take
into account how likely we are to observe an unobserved element. Intuitively,
if we have seen many diﬀerent elements, we are more likely to see unobserved
elements as opposed to the case where we have seen very few elements.
To estimate our likelihoods we use the estimator presented in Friedman and
Singer, 1999 [16] which explicitly estimates likelihood of observing a previously
44
F. Apap et al.
unobserved element. The estimator gives the following prediction for element i
P (X = i) =
α + Ni