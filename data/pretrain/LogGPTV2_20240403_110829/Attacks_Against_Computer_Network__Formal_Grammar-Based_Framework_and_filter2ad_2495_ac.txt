these families of grammars are transformed into the generalized grammars that
correspond to each non-terminal node of ontology for all of the intentions.
It is assumed that if a value of the production condition is not determined at
the moment of production selection all available productions may be used at the
respective step of attack simulation. Also it is supposed that the terminal ac-
tions generated by productions are associated with the probabilities of successful
realization of those actions (attacks) and the host response.
Let us consider, for example, the grammars for the intention “Users and
{(Win) UE → UE1(1), (NS)UE1 →
(0.7),
A1
A1 → R
groups Enumeration” (U E):
Level “Network Attack”: VN = {A, A1}, VT = {R}, S = {A},
P = {A → A1
(1), A1 → R
(0.3)};
Level “Reconnaissance”: VN = {R, R1}, VT = {UE}, S = {R},
P = {R → R1 (1), R1 → UE (0.7), R1 → UE R1 (0.3)};
Level “Users and groups Enumeration”
VN = {UE, UE1, UE2, UE3, UE4}, S = {UE},
VT = {DNNT, EUE, PIUD, IAUS, SNMPE, FUE, UTFTP},
Pfor Windows 9x,Me,NT,2000
UE1 → SNMPE(0.25), UE1 → SNMPE UE1 (0.05), (NS)UE1 → UE2 UE1
(0.05), (&)UE2 → CNS UE3(1), UE3 → DNNT (0.2), UE3 → DNNT UE4
(0.05), UE3 → IAUS(0.35), UE3 → EUE(0.2), UE3 → PIUD (0.2),
UE4 → DNNT UE4(0.1), UE4 → DNNT(0.9)},
Pfor Unix/Linux = {(Unix, Linux) UE → UE1(1), UE1 → FUE(0.3),
UE1 → SNMPE(0.2), UE1 → UTFTP(0.1), UE1 → FUE UE1(0.1),
UE1 → SNMPE UE1(0.1), UE1 → UTFTP UE1(0.2)};
UE2(0.65),
=
Level “Identifying Accounts with user2sid/sid2user”:
VN = {IAUS, IAUS1, IAUS2}, VT = {ISU, IAS}, S = {IAUS},
P = {(NT) IAUS → IAUS1 (1), (&) IAUS1 → ISU IAS (0.8),
IAUS1 → IAUS1 IAUS2 (0.2), (&) IAUS2 → ISU IAS (1)}.
In this set of grammars the following denotations are used: A — Network At-
tack; R — Reconnaissance; UE — Users and groups Enumeration; DNNT — Dumping
the NetBIOS Name Table with nbtstat and nbtscan; EUE — Enumerating Users with
enum; PIUD — Providing Information about Users with DumpSec (DumpACL); IAUS —
Identifying Accounts with user2sid/sid2user; SNMPE — SNMP Enumeration with sn-
mputil or IP Network Browser; FUE — Finger Users Enumeration; UTFTP — Use of
Trivial File Transfer Protocol for Unix enumerating by stealing /etc/passwd and (or)
/etc/hosts.equiv and (or) ˜/.rhosts; ISU — Identifying SID with user2sid; IAS — Identi-
fying Account with sid2user using user’s RID; A1, R1, UE1, UE2, UE3, UE4, IAUS1,
IAUS2 — auxiliary symbols.
Algorithmic interpretation of the attack generation speciﬁed as formal gen-
eralized grammars is implemented by a family of state machines. The basic
elements of each state machine are states, transition arcs, and explanatory texts
230
V. Gorodetski and I. Kotenko
for each transition. States of each state machine are divided into three types:
ﬁrst (initial), intermediate, and ﬁnal (marker of this state is End). The initial
and intermediate states are the following: non-terminal, those that initiate the
operation of the corresponding nested state machines; terminal, those that in-
teract with the host model; auxiliary states. Transition arcs are identiﬁed with
the productions of grammars. The model of each state machine is set by specify-
ing the following elements: diagram; main parameters; parameters of transitions
that determine the stochastic model of the state machine for diﬀerent relevant
intentions; executable scripts; transition conditions.
5 Formal Model of the Attacked Computer Network
The attack development depends on the malefactor’s “skill”, information re-
garding network characteristics, which he/she possesses, some other malefactor’s
attributes [39], security policy of the attacked network, etc. An attack is devel-
oping as interactive process, in which the network is reacting on the malefactor’s
action. Computer network plays the role of the environment for attacker, and
therefore its model must be a part of the attack simulation tool.
The peculiarity of any attack is that the malefactor’s strategy depends on the
results of the intermediate actions. This is the reason why it is not possible to
generate the complete sequence of malefactor’s actions from the very beginning.
The malefactor’s action has to be generated on-line in parallel with the getting
reaction from the attacked network. The proposed context-free grammar syntax
provides the model with this capability. At each particular step of inference, it
generates no more than single terminal symbol that can be interpreted by the
computer network model as a malefactor’s action. The network returns the value
of the result (success or failure). The model of attacker receives it and generates
the next terminal symbol according to the attack model and depending on the
returned result of the previous phase of the attack.
Model of the attacked computer network is represented as quadruple M A =, where MCN is the model of the computer network
structure; {MHi} are the models of the host resources; MP is the model of
computation of the attack success probabilities; MHR is the model of the host
reaction in response of attack. Let us determine the model MCN of a computer
network structure CN as follows: MCN =, where A is the network
address; P is a family of protocols used (e.g., TCP/IP, FDDI, ATM, IPX, etc.);
N is a set {CNi} of sub-networks and/or a set {Hi} of hosts of the network
CN; C is a set of connections between the sub-networks (hosts) established as a
connectivity matrix. If N establishes a set of sub-networks {CNi}, then each sub-
network CNi can in turn be speciﬁed by the model MCN i (if its structure needs
to be developed in detail and if information is available about this structure).
Each host Hi is determined as a pair MHi =, where A is the host
address, T is the host type (e.g., ﬁrewall, router, host, etc.).
Models {MHi} of the network host resources serve for representing the host
parameters that are important for attack simulation. Let us determine the model
Attacks against Computer Network
231
of the network host resources as follows: MHi = , where A — IP-address, M — mask of the
network address, T — type and version of OS, N — users’ identiﬁers (IDs),
D — domain names, P — host access passwords, S — users’ security identiﬁers
(SID), DP — domain parameters (domain, names of hosts in the domain, domain
controller, related domains), ASP — active TCP and UDP ports and services
of the hosts, RA — running applications, SP — security parameters, SR —
shared resources, T H — trusted hosts.
j
Success or failure of any attack action (corresponding to terminal level of the
attack ontology) is determined by means of the model MP of computation of the
attack success probabilities. This model is speciﬁed as follows: MP = {RSP r
},
where RSP r
is a special rule that determines the action success probability de-
pending on the basic parameters of the host (attack target). The rule RSP r
includes IF and THEN parts. The IF part contains action name and precondi-
tion (values of attributes constraining the attack applicability). The THEN part
contains value of success probability (SPr). Examples of interpretations of the
probability computation rules are as follows:
j
j
‘‘If action is ’FF’ (Connection on FTP and examination of bin-files in
the directory /bin/ls) and OS Type is ’Unix, Linux’ and Service is ’FTP’
then SP is 0.7”;
‘‘If action is ’FCA’ (Free Common Access) and OS type is ’Windows 9x’
and Security parameter is ’CFP’ (shared files and printers) then SP is
0.7”.
j
j
}, RHR
The result of each attack action is determined according to the model MHR
of the host reaction. This model is determined as a set of rules of the host
reaction: MHR = {RHR
: Input → Output [& Post-Condition]; where In-
put — the malefactor’s activity, Output — the host reaction, Post-Condition —
a change of the host state, & — logical operation “AND”, [ ] — optional part of
the rule. The Input format: :  :  [; . The Output
format:
{ [: ]; { [: ]}. The Attack Success
is determined by the success probability of the attack that is
Parameter
associated with the host (attack target) depending on the implemented attack
type. The values of attack success parameter are Success (S), and Failure
(F). The part of output message shown in the  is taken from the
corresponding ﬁeld of the host (target) parameters. The part of output message
shown in quotation marks ” ” is displayed as a constant line. The Post-Condition
format: {p1 = P1, p2 = P2, :, pn = Pn}, where pi — ith parameter of the host
(for instance, SP, SR, TH, etc.) which value has changed, Pi — the value of ith
parameter.
Examples of the host reaction rules:
SFB: Scanning ‘‘FTP Bounce’’: Target host; Intermediate host (FTP-ser-
ver) → {S: ; F: ‘‘It was not
possible to determine Active ports (services)’’};
232
V. Gorodetski and I. Kotenko
IF: ICMP message quoting: Target host → { S: ; F: ‘‘It was not possible to determine the type of operating
system’’}.
6 Implementation of Attack Simulator
The software prototype of the attack simulator has been implemented. Now it
is used for validation of the accepted formal framework. It consists of three
components: the model of attacker, the model of the attacked computer network
and the background traﬃc generator. Background traﬃc is formed taking into
account the model of the attacked computer network as a set of sessions between
hosts of the network. The common traﬃc generated by integration of streams of
data from these components can be an input for IDSs evaluation and learning.
Each of the components of the attack simulator was built as an agent of multi-
agent system (MAS). The design and implementation of the attack simulator is
being carried out on the basis of MASDK — “Multi-Agent System Development
Kit” [16]. All MAS agents generated by MASDK have the same architecture.
Diﬀerences are reﬂected in the content of particular agent’s data and knowledge
bases. Each agent interacts with other agents, environment which is perceived,
and, possibly, modiﬁed by agents, and user communicating with agents through
his interface. Receiver of input and Sender of output messages perform the re-
spective functions. Messages received are recorded in Input message buﬀer. The
order of its processing is managed by Input message processor. In addition, this
component performs syntax analysis and messages interpretation and extracts
the message contents. The component Database of agent’s dialogs stores for each
input message its attributes like identiﬁers, type of message and its source. If a
message supposes to be replied it is mapped the respective output message when
it is sent.
Meta-state machine manages the semantic processing of input messages di-
recting it for processing by the respective State machines. The basic agent’s
computations are executed by a set of State machines. The selection of scenario
and therefore the output result depend on the input message content and inner
state of the State Machine. In turn, inner state of this Machine depends on pre-
history of its performance; in particular, this prehistory is reﬂected in the state
of agent’s Knowledge base and Database. One more state machine called “Self-
activated behaviour machine” is changing its inner state depending on the state
of the data and knowledge bases. In some combinations of these states it can acti-
vate functionality independently on input messages or state of the environment.
Each agent class is provided with a set of particular message templates accord-
ing to its functionalities. The developer carries out the specialization procedure
with Editor of message templates, which, in turn, is a component of MASDK.
Communication component of each agent includes also data regarding potential
addressees of messages of given template.
The screen indicating generation of the intention “Gaining Access to Re-
sources” (GAR) is depicted in Fig. 4. In this screen the attack generation at
Attacks against Computer Network
233
Fig. 4. Visualization of the attack development: the reconnaissance stage of the attack
“Gaining Access to Resources” after execution of the action EUE
the reconnaissance stage after execution of the action “Enumerating Users with
enum” (EUE) is ﬁxed. In the ﬁgure the information is divided on four groups:
(1) the attack task speciﬁcation units are mapped in the left top of the screen;
(2) to the right of them the attack generation tree is visualized; (3) the strings
of the malefactor’ s actions are placed in the left part of the screen below the
attack task speciﬁcation; (4) on the right of each malefactor’s action a tag of
success (failure) as green (black) quadrate and data obtained from an attacked
host (a host response) are depicted.
From implementation issue, a computer network attack can be considered as
a sequence of coordinated actions of the spatially distributed malefactors. Each
malefactor is mapped as an intelligent agent of the same architecture possessing
the similar functionality. While developing an attack, these agents interact via
message exchange informing each other about current state and results of the at-
tack in order to coordinate their further activity. These messages are represented
in KQML that is standard of DARPA (for message “wrapper”), and XML (for
message content).
We are developing2 a teamwork interpretation of the malefactors’ activity
performing distributed attacks on the basis of joint intention theory [37]. When
2 Currently this part of work is in progress.
234
V. Gorodetski and I. Kotenko
implementing the complex coordinated attacks, the special meta-agent should
form the common scenario of the attack and assigns areas of responsibility to
other agents based on the general attack goal constituted by simulation tool
user. The agents, responsible for the particular fragments (steps) of the common
scenario, can in turn “employ” other agents or realize particular operations inde-
pendently. For this purpose the special scenarios of operations and protocols of