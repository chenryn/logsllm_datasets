#           [sp+0x30]  (sp of caller)  0x0000000104fb2ce0: mov    DWORD PTR [rsp-0x14000],eax  0x0000000104fb2ce7: push   rbp  0x0000000104fb2ce8: sub    rsp,0x20  0x0000000104fb2cec: test   esi,esi  0x0000000104fb2cee: je     0x0000000104fb2cfe // 跳转至?  0x0000000104fb2cf0: xor    eax,eax            // 将返回值设置为 0  0x0000000104fb2cf2: add    rsp,0x20  0x0000000104fb2cf6: pop    rbp  0x0000000104fb2cf7: test   DWORD PTR [rip+0xfffffffffca32303],eax // safepoint  0x0000000104fb2cfd: ret      ...总结一下，根据条件跳转指令的分支profile，即时编译器可以将从未执行过的分支剪掉，以避免编译这些很有可能不会用到的代码，从而节省编译时间以及部署代码所要消耗的内存空间。此外，"剪枝"将精简程序的数据流，从而触发更多的优化。在现实中，分支 profile出现仅跳转或者仅不跳转的情况并不多见。当然，即时编译器对分支 profile的利用也不仅限于"剪枝"。它还会根据分支profile，计算每一条程序执行路径的概率，以便某些编译器优化优先处理概率较高的路径。
## 基于类型 profile 的优化另外一个例子则是关于 instanceof 以及方法调用的类型profile。下面这段代码将测试所传入的对象是否为 Exception的实例，如果是，则返回它的系统哈希值；如果不是，则返回它的哈希值。    public static int hash(Object in) {  if (in instanceof Exception) {    return System.identityHashCode(in);  } else {    return in.hashCode();  }}// 编译而成的字节码：public static int hash(java.lang.Object);  Code:     0: aload_0     1: instanceof java/lang/Exception     4: ifeq          12     7: aload_0     8: invokestatic java/lang/System.identityHashCode:(Ljava/lang/Object;)I    11: ireturn    12: aload_0    13: invokevirtual java/lang/Object.hashCode:()I    16: ireturn假设应用程序调用该方法时，所传入的 Object 皆为 Integer实例。那么，偏移量为 1 的 instanceof 指令的类型 profile 仅包含Integer，偏移量为 4 的分支跳转语句的分支 profile 中不跳转的次数为0，偏移量为 13 的方法调用指令的类型 profile 仅包含 Integer。![](Images/7ee4796557081af53b25135131694ec4.png){savepage-src="https://static001.geekbang.org/resource/image/2c/77/2c13a1af8632a2bbf77338e57c957b77.png"}在 Java 虚拟机中，instanceof 测试并不简单。如果 instanceof 的目标类型是final 类型，那么 Java 虚拟机仅需比较测试对象的动态类型是否为该 final类型。在讲解对象的内存分布那一篇中，我曾经提到过，对象头存有该对象的动态类型。因此，获取对象的动态类型仅为单一的内存读指令。如果目标类型不是 final 类型，比如说我们例子中的 Exception，那么 Java虚拟机需要从测试对象的动态类型开始，依次测试该类，该类的父类、祖先类，该类所直接实现或者间接实现的接口是否与目标类型一致。不过，在我们的例子中，instanceof 指令的类型 profile 仅包含Integer。根据这个信息，即时编译器可以假设，在接下来的执行过程中，所输入的Object 对象仍为 Integer 实例。因此，生成的代码将测试所输入的对象的动态类型是否为Integer。如果是的话，则继续执行接下来的代码。（该优化源自 Graal，采用 C2可能无法复现。）然后，即时编译器会采用和第一个例子中一致的针对分支 profile的优化，以及对方法调用的条件去虚化内联。我会在接下来的篇章中详细介绍内联，这里先说结果：生成的代码将测试所输入的对象动态类型是否为Integer。如果是的话，则执行 Integer.hashCode()方法的实质内容，也就是返回该 Integer 实例的 value 字段。    public final class Integer ... {    ...    @Override    public int hashCode() {        return Integer.hashCode(value);    }     public static int hashCode(int value) {        return value;    }    ...}![](Images/17d87db93b534d4d4a6bcad5cd8fcac8.png){savepage-src="https://static001.geekbang.org/resource/image/ef/b6/ef02474d3474e96c6f55b07493652fb6.png"}和第一个例子一样，根据数据流分析，上述代码可以最终优化为极其简单的形式。![](Images/18622072f363c0a01e48837b953bbde2.png){savepage-src="https://static001.geekbang.org/resource/image/53/be/53e470037dd49d3d27695a5174fc3dbe.png"}这里我打印了 Graal 的编译结果。可以看到，在地址为 1ab7的指令处进行过一次比较之后，该机器码便直接返回所传入的 Integer 对象的value 字段。    Compiled method (JVMCI)     600   23       4...----------------------------------------------------------------------CompilationTest.hash (CompilationTest.hash(Object))  [0x000000011d811aa0, 0x000000011d811b00]  96 bytes[Entry Point][Verified Entry Point][Constants]  
# {method} {0x00000001157053c8} 'hash' '(Ljava/lang/Object;)I' in 'CompilationTest'  
# parm0:    rsi:rsi   = 'java/lang/Object'  
#           [sp+0x20]  (sp of caller)  0x000000011d811aa0: mov    DWORD PTR [rsp-0x14000],eax  0x000000011d811aa7: sub    rsp,0x18  0x000000011d811aab: mov    QWORD PTR [rsp+0x10],rbp  // 比较 [rsi+0x8]，也就是所传入的 Object 参数的动态类型，是否为 Integer。这里 0xf80022ad 是 Integer 类的内存地址。  0x000000011d811ab0: cmp    DWORD PTR [rsi+0x8],0xf80022ad  // 如果不是，跳转至？  0x000000011d811ab7: jne    0x000000011d811ad3  // 加载 Integer.value。在启用压缩指针时，该字段的偏移量为 12，也就是 0xc  0x000000011d811abd: mov    eax,DWORD PTR [rsi+0xc]  0x000000011d811ac0: mov    rbp,QWORD PTR [rsp+0x10]  0x000000011d811ac5: add    rsp,0x18  0x000000011d811ac9: test   DWORD PTR [rip+0xfffffffff272f537],eax          0x000000011d811acf: vzeroupper   0x000000011d811ad2: ret和基于分支 profile 的优化一样，基于类型 profile的优化同样也是作出假设，从而精简控制流以及数据流。这两者的核心都是假设。对于分支 profile，即时编译器假设的是仅执行某一分支；对于类型profile，即时编译器假设的是对象的动态类型仅为类型 profile 中的那几个。那么，当假设失败的情况下，程序将何去何从？我们继续往下看。
## 去优化Java虚拟机给出的解决方案便是去优化，即从执行即时编译生成的机器码切换回解释执行。在生成的机器码中，即时编译器将在假设失败的位置上插入一个陷阱（trap）。该陷阱实际上是一条call 指令，调用至 Java 虚拟机里专门负责去优化的方法。与普通的 call指令不一样的是，去优化方法将更改栈上的返回地址，并不再返回即时编译器生成的机器码中。在上面的程序控制流图中，我画了很多红色方框的问号。这些问号便代表着一个个的陷阱。一旦踏入这些陷阱，便将发生去优化，并切换至解释执行。去优化的过程相当复杂。由于即时编译器采用了许多优化方式，其生成的代码和原本的字节码的差异非常之大。在去优化的过程中，需要将当前机器码的执行状态转换至某一字节码之前的执行状态，并从该字节码开始执行。这便要求即时编译器在编译过程中记录好这两种执行状态的映射。举例来说，经过逃逸分析之后，机器码可能并没有实际分配对象，而是在各个寄存器中存储该对象的各个字段（标量替换，具体我会在之后的篇章中进行介绍）。在去优化过程中，Java虚拟机需要还原出这个对象，以便解释执行时能够使用该对象。当根据映射关系创建好对应的解释执行栈桢后，Java 虚拟机便会采用 OSR技术，动态替换栈上的内容，并在目标字节码处开始解释执行。此外，在调用 Java虚拟机的去优化方法时，即时编译器生成的机器码可以根据产生去优化的原因来决定是否保留这一份机器码，以及何时重新编译对应的Java 方法。如果去优化的原因与优化无关，即使重新编译也不会改变生成的机器码，那么生成的机器码可以在调用去优化方法时传入Action_None，表示保留这一份机器码，在下一次调用该方法时重新进入这一份机器码。如果去优化的原因与静态分析的结果有关，例如类层次分析，那么生成的机器码可以在调用去优化方法时传入Action_Recompile，表示不保留这一份机器码，但是可以不经过重新profile，直接重新编译。如果去优化的原因与基于 profile的激进优化有关，那么生成的机器码需要在调用去优化方法时传入Action_Reinterpret，表示不保留这一份机器码，而且需要重新收集程序的profile。这是因为基于 profile的优化失败的时候，往往代表这程序的执行状态发生改变，因此需要更正已收集的profile，以更好地反映新的程序执行状态。
## 总结与实践今天我介绍了 Java 虚拟机的 profiling以及基于所收集的数据的优化和去优化。通常情况下，解释执行过程中仅收集方法的调用次数以及循环回边的执行次数。当方法被 3 层 C1 所编译时，生成的 C1 代码将收集条件跳转指令的分支profile，以及类型相关指令的类型 profile。在部分极端情况下，Java虚拟机也会在解释执行过程中收集这些 profile。基于分支 profile 的优化以及基于类型 profile的优化都将对程序今后的执行作出假设。这些假设将精简所要编译的代码的控制流以及数据流。在假设失败的情况下，Java虚拟机将采取去优化，退回至解释执行并重新收集相关的 profile。今天的实践环节，你可以使用参数    -XX:CompileCommand='print,*ClassName.methodName'来打印程序运行过程中即时编译器生成的机器码。官方的 JDK可能不包含反汇编器动态链接库，如 hsdis-amd64.dylib。你可能需要另外下载。    // java -XX:CompileCommand='print,CompilationTest.foo' CompilationTestjava -XX:CompileCommand='print,CompilationTest.foo' CompilationTestpublic class CompilationTest {  public static int foo(boolean f, int in) {    int v;    if (f) {      v = in;    } else {      v = (int) Math.sin(in);    }    if (v == in) {      return 0;    } else {      return (int) Math.cos(v);    }  }  public static void main(String[] args) throws InterruptedException {    for (int i = 0; i `{=html}举个例子（[来源](https://en.wikipedia.org/wiki/Static_single_assignment_form)），上面这段代码所对应的SSA 形式伪代码是下面这段：    y1 = 1;y2 = 2;x1 = y2;在源代码中，我们可以轻易地发现第一个对 y的赋值是冗余的，但是编译器不能。传统的编译器需要借助数据流分析（具体的优化叫[reachingdefinition](https://en.wikipedia.org/wiki/Reaching_definition)），从后至前依次确认哪些变量的值被覆盖（kill）掉。不过，如果借助了 SSAIR，编译器则可以通过查找赋值了但是没有使用的变量，来识别冗余赋值。除此之外，SSA IR 对其他优化方式也有很大的帮助，例如常量折叠（constantfolding）、常量传播（constant propagation）、强度削减（strengthreduction）以及死代码删除（dead code elimination）等。    示例：x1=4*1024 经过常量折叠后变为 x1=4096x1=4; y1=x1 经过常量传播后变为 x1=4; y1=4y1=x1*3 经过强度削减后变为 y1=(x11){y1=1;}else{y2=1;}经过死代码删除后变为 y1=1部分同学可能会手动进行上述优化，以期望能够达到更高的运行效率。实际上，对于这些简单的优化，编译器会代为执行，以便程序员专注于代码的可读性。SSA IR会带来一个问题，那便是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码if 语句的两个分支中，变量 y 分别被赋值为 0 或1，并且在接下来的代码中读取 y的值。此时，根据不同的执行路径，所读取到的值也很有可能不同。    x = ..;if (x > 0) {  y = 0;} else {  y = 1;}x = y;为了解决这个问题，我们需要引入一个 Phi函数的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码便可以转换为下面这段SSA 伪代码。这里的 Phi 函数将根据前面两个分支分别选择 y1、y2的值，并赋值给 y3。    x1 = ..;if (x1 > 0) {  y1 = 0;} else {  y2 = 1;}y3 = Phi(y1, y2);x2 = y3;总之，即时编译器会将 Java 字节码转换成 SSAIR。更确切的说，是一张包含控制流和数据流的 IR图，每个字节码对应其中的若干个节点（注意，有些字节码并没有对应的 IR节点）。然后，即时编译器在 IR 图上面进行优化。我们可以将每一种优化看成一个独立的图算法，它接收一个 IR图，并输出经过转换后的 IR图。整个编译器优化过程便是一个个优化串联起来的。