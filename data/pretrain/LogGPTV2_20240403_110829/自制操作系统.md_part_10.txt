HLT
JMP fin
设定AH=0x00后，调用显卡BIOS的函数，这样就可以切换显示模式了。我们还可以在支持
网页（AT）BIOS里看看。
设置显卡模式（video mode）
 AH=0x00;
 AL=模式：（省略了一些不重要的画面模式）
 0x03：16色字符模式，80 × 25
 0x12：VGA 图形模式，640 × 480 × 4位彩色模式，独特的4面存储模式
 0x13：VGA 图形模式，320 × 200 × 8位彩色模式，调色板模式
 0x6a：扩展VGA 图形模式，800 × 600 × 4位彩色模式，独特的4面存储模式
（有的显卡不支持这个模式）
 返回值：无
参照以上说明，我们暂且选择0x13画面模式，因为8位彩色模式可以使用256种颜色，这一点
看来不错。
如果画面模式切换正常，画面应该会变为一片漆黑。也就是说，因为可以看到画面的变化，
所以能判断程序是否运行正常。由于变成了图形模式，因此光标会消失。
图灵社区会员 metorm 专享 尊重版权
8 32位模式前期准备 …… 57
另外，这次还顺便修改了其他一些地方。首先将ipl.nas的文件名变成了ipl10.nas。这是为了
1
提醒大家这个程序只能读入10个柱面。另外，想要把磁盘装载内容的结束地址告诉给haribote.sys，
所以我们在“JMP 0xc200”之前，加入了一行命令，将CYLS的值写到内存地址0x0ff0中。这样启
2
动区程序就算完成了。
3
3
5
6
赶紧“make run”看看。 7
哦哦，画面一片漆黑。运行顺利！真是太好了!
有一点要先说明一下，现在我们把启动区里与haribote.sys没有关系的前后部分也读了进来， 8
所以启动时很慢。可能会有人觉得这样做很浪费时间，但对于我们的纸娃娃操作系统来说，装载
启动区这些部分，以后会起大作用的，所以暂时先忍耐一下吧。
9
88 32 位模式前期准备
10
今天还有些时间，再往下讲一点吧。
11
现在，汇编语言的开发告一段落，我们要开始以C语言为主进行开发了，这是我们当前的目标。
笔者准备的C编译器，只能生成32位模式的机器语言。如果一定要生成16位模式机器语言，
12
虽然也不是做不到，但是很费事，还没什么好处，所以就用32位模式吧。
所谓32位模式，指的是CPU的模式。CPU有16位和32位两种模式。如果以16位模式启动的话，
13
用AX和CX等16位寄存器会非常方便，但反过来，像EAX和ECX等32位的寄存器，使用起来就很
麻烦。另外，16位模式和32位模式中，机器语言的命令代码不一样。同样的机器语言，解释的方
法也不一样，所以16位模式的机器语言在32位模式下不能运行，反之亦然。 14
32位模式下可以使用的内存容量远远大于1MB。另外，CPU的自我保护功能（识别出可疑的
机器语言并进行屏蔽，以免破坏系统）在16位下不能用，但32位下能用。既然有这么多优点，当 15
然要使用32位模式了。
16
■■■■■
图灵社区会员 metorm 专享 尊重版权
58 …… 第3天：进入32位模式并导入C语言
可是，如果用32位模式就不能调用BIOS功能了。这是因为BIOS是用16位机器语言写的。如
果我们有什么事情想用BIOS来做，那就全部都放在开头先做，因为一旦进入32位模式就不能调
用BIOS函数了。（当然，也有从32位返回到16位的方法，但是非常费工夫，所以本书不予赘述。）
再回头说说要使用BIOS做的事情。画面模式的设定已经做完了，接下来还想从BIOS得到键
盘状态。所谓键盘状态，是指NumLock是ON还是OFF等这些状态。
所以，我们这次只修改了haribote.nas。修改后的程序就是projects/03_day下的harib00h。
本次的haribote.nas
; haribote-os
; TAB=4
; 有关BOOT_INFO
CYLS EQU 0x0ff0 ; 设定启动区
LEDS EQU 0x0ff1
VMODE EQU 0x0ff2 ; 关于颜色数目的信息。颜色的位数。
SCRNX EQU 0x0ff4 ; 分辨率的X（screen x）
SCRNY EQU 0x0ff6 ; 分辨率的Y（screen y）
VRAM EQU 0x0ff8 ; 图像缓冲区的开始地址
ORG 0xc200 ; 这个程序将要被装载到内存的什么地方呢？
MOV AL,0x13 ; VGA 显卡，320x200x8位彩色
MOV AH,0x00
INT 0x10
MOV BYTE [VMODE],8 ; 记录画面模式
MOV WORD [SCRNX],320
MOV WORD [SCRNY],200
MOV DWORD [VRAM],0x000a0000
;用BIOS取得键盘上各种LED指示灯的状态
MOV AH,0x02
INT 0x16 ; keyboard BIOS
MOV [LEDS],AL
fin:
HLT
JMP fin
看一下程序就能明白，设置画面模式之后，还把画面模式的信息保存在了内存里。这是因为，
以后我们可能要支持各种不同的画面模式，这就需要把现在的设置信息保存起来以备后用。我们
暂且将启动时的信息称为BOOT_INFO。INFO是英文information（信息）的缩写。
■■■■■
[VRAM]里保存的是0xa0000。在电脑的世界里，VRAM指的是显卡内存（video RAM），也
就是用来显示画面的内存。这一块内存当然可以像一般的内存一样存储数据，但VRAM的功能不
仅限于此，它的各个地址都对应着画面上的像素，可以利用这一机制在画面上绘制出五彩缤纷的
图案。
图灵社区会员 metorm 专享 尊重版权
9 开始导入C语言 …… 59
其实VRAM分布在内存分布图上好几个不同的地方。这是因为，不同画面模式的像素数也不
1
一样。当画面模式为〇×时使用这个VRAM；而画面模式为◇△时可能使用那个VRAM，像这样，
不同画面模式可以使用的内存也不一样。所以我们就预先把要使用的VRAM地址保存在
2
BOOT_INFO里以备后用。
这次VRAM的值是0xa0000。这个值又是从哪儿得来的呢？还是来看看我们每次都参考的
3
（AT）BIOS支持网页。在INT 0x10的说明的最后写着，这种画面模式下“VRAM是0xa0000～0xaffff
的64KB”。
3
另外，我们还把画面的像素数、颜色数，以及从BIOS取得的键盘信息都保存了起来。保存
位置是在内存0x0ff0附近。从内存分布图上看，这一块并没被使用，所以应该没问题。
5
99 开始导入 C 语言
6
终于准备就绪，现在我们直接切换到32位模式，然后运行用C语言写的程序。这就是
projects/03_day下的harib00i。
7
程序里添加和修改了很多内容。首先是haribote.sys，它的前半部分是用汇编语言编写的，而
后半部分则是用C语言编写的。所以以前的文件名haribote.nas也随之改成了asmhead.nas。并且，
8
为了调用C语言写的程序，添加了100行左右的汇编代码。
虽然笔者也很想现在就讲这100行新添的程序，但是很抱歉，还是先跳过这部分吧。等我们
9
再往后多学一点，再回过头来仔细讲解这段程序。其实笔者曾多次对这一部分进行说明，但每次
都写得很长很复杂，恐怕大家很难理解。等到后面，大家掌握的内容多了，这一部分再理解起来
10
也就轻松了，所以暂时先不做说明了。
下面讲C语言部分。文件名是bootpack.c。为什么要起这样的名字呢？因为以后为了启动操作
11
系统，还要写各种其他的处理，我们想要把这些处理打成一个包（pack），所以就起了这么一个
名字。最重要的核心内容非常非常短，如下所示：
12
本次的bootpack.c
void HariMain(void)
{ 13
fin:
/*这里想写上HLT，但C语言中不能用HLT!*/
goto fin; 14
}
15
这个程序第一行的意思是：现在要写函数了，函数名字叫HariMain，而且不带参数（void），
不返回任何值。“{}”括起来的部分就是函数的处理内容。
16
C语言中所说的函数是指一块程序，在某种程度上可以看作数学中的函数一般，即从变量x
图灵社区会员 metorm 专享 尊重版权
60 …… 第3天：进入32位模式并导入C语言
取得值，将处理结果送给y。而上面情况下，既不从变量取得值，也不返回任何值，不太像数学
中的函数，但在C语言中这也是函数。
goto指令是新出现的，相当于汇编语言中的JMP，实际上也是被编译成JMP指令。
由“/*”和“*/”括起来的部分是注释，正如这里所写的那样，C语言中不能使用HLT，也没
有相当于DB的命令，所以不能用DB来放一句HLT语句。这让喜欢HTL语句的笔者感觉很是可惜。
■■■■■
那么，这个bootpack.c是怎样变成机器语言的呢？如果不能变成机器语言，就是说得再多也
没有意义。这个步骤很长，让我们看一看。
 首先，使用cc1.exe从bootpack.c生成bootpack.gas。
 第二步，使用gas2nask.exe从bootpack.gas生成bootpack.nas。
 第三步，使用nask.exe从bootpack.nas生成bootpack.obj。
 第四步，使用obi2bim.exe从bootpack.obj生成bootpack.bim。
 最后，使用bim2hrb.exe从bootpack.bim生成bootpack.hrb。
 这样就做成了机器语言，再使用copy指令将asmhead.bin与bootpack.hrb单纯结合到起来，
就成了haribote.sys。
来来去去搞出了这么多种类的文件，那么下面就简单介绍一下吧。
cc1是C编译器，可以将C语言程序编译成汇编语言源程序。但这个C编译器是笔者从名为gcc
的编译器改造而来，而gcc又是以gas汇编语言为基础，输出的是gas用的源程序。它不能翻译成nask。
所以我们需要把gas变换成nask能翻译的语法，这就是gas2nask。解释一下这个名字。英语中
的“从A到B”说成 “from A to B”，省略一下，就是“A to B”。这里把“to”写成“2”，世界上
开发工具的人有时会这么写（这是英语中的谐音，2与to同音）。所以，gas2nask的意思就是“把
gas文件转换成nask文件的程序”。
一旦转换成nas文件，它可就是我们的掌中之物了，只要用nask翻译一下，就能变成机器语言
了。实际上也正是那样，首先用nask制作obj文件。obj文件又称目标文件，源自英文的“object”，
也就是目标的意思。程序是用C语言写的，而我们的目标是机器语言，所以这就是“目标文件”
这一名称的由来。
可能会有人想，既然已经做成了机器语言，那只要把它写进映像文件里就万事大吉了。但很
遗憾，这还不行，事实上这也正是使用C语言的不便之处。目标文件是一种特殊的机器语言文件，
必须与其他文件链接（link）后才能变成真正可以执行的机器语言。链接是什么意思呢？实际上
C语言的作者已经认识到，C语言有它的局限性，不可能只用C语言来编写所有的程序，所以其中
有一部分必须用汇编来写，然后链接到C语言写的程序上。
现在为止，都只有一个源程序，由它来直接生成机器语言文件，这好像是理所当然的，
图灵社区会员 metorm 专享 尊重版权
9 开始导入C语言 …… 61
完全不用考虑什么目标文件的链接。但是这个问题以后要考虑了。下面我们来讲一下用汇编 1
语言做目标文件的方法。
所以，为了将目标文件与别的目标文件相链接，除了机器语言之外，其中还有一部分是用来 2
交换信息的。单个的目标文件还不是独立的机器语言，其中还有一部分是没完成的。为了能做成
完整的机器语言文件，必须将必要的目标文件全部链接上。完成这项工作的，就是obj2bim。bim
3
是笔者设计的一种文件格式，意思是“binary image”，它是一个二进制映像文件。
映像文件到底是什么呢？这么说来，磁盘映像也是一种映像文件。按笔者的理解，所谓 3
映像文件即不是文件本来的状态，而是一种代替形式。英文里面说到image file，一般是指图
像文件，首先要有一个真实的东西，而它的图像则是临摹仿造出来的，虽然跟它很像，但毕
5
竟不是真的，只是以不同的形式展示出原物的映像。不是常有人这么讲吗，“嗯，搞不懂你在
说什么。能不能说得再形象一点儿？”，也就是说 “如果直接说明起来太困难的话，可以找
6
个相似的东西来类比一下。”所谓类比，“不是本来的状态，而是一种代替的形式”。……映像
文件大致也就是这个意思。
7
所以，实际上bim文件也“不是本来的状态，而是一种代替的形式”，也还不是完成品。这只
是将各个部分全部都链接在一起，做成了一个完整的机器语言文件，而为了能实际使用，我们还
需要针对每一个不同操作系统的要求进行必要的加工，比如说加上识别用的文件头，或者压缩等。 8
这次因为要做成适合 “纸娃娃操作系统”要求的形式，所以笔者为此专门写了一个程序
bim2hrb.exe，这个程序留到后面来介绍。
9
■■■■■
10
可能有人会想：“我在Windows和Linux上做了很多次C程序了，既没用过那么多工具，也没
那么多的中间文件就搞定了，这次是怎么回事呢？”说到底，这是因为那些编译器已经很成熟了。
11
但是，如果我们的编译器能够直接生成可执行文件，那再想把它用于别的用途可就难了。其实
在编译器内部也要做同样的事，只是在外面看不见这些过程而已。这次提供的编译器，是以能适应
12
各种不同操作系统为前提而设计的，所以对内部没有任何隐藏，是特意像这样多生成一些中间文件的。
这样做的好处是仅靠这个编译器，就可以制作Windows、Linux以及OSASK用的可执行文件，
13
当然，还有我们的“纸娃娃操作系统”的可执行文件。
根据以上内容，对Makefile也做了很大改动。如果大家想知道编译时指定了什么样的选项，
可以看一看Makefile。 14
■■■■■ 15
啊，忘了一件大事。函数名HariMain非常重要，程序就是从以HariMain命名的函数开始运行
的，所以这个函数名不能更改。 16
图灵社区会员 metorm 专享 尊重版权
62 …… 第3天：进入32位模式并导入C语言
执行这个函数，结果出现黑屏。这表示运行正常。
1100 实现 HLT（harib00j）
虽然夜已经深了，但笔者现在还不能说“今天就到此结束”。不让计算机处于HALT（HLT）
状态心里就不舒服。我们做出的程序这么耗电，不把这个问题解决掉怎么能睡得着呢（笑）。我
们来努力尝试一下吧。
首先写了下面这个程序，naskfunc.nas。
naskfunc.nas
; naskfunc
; TAB=4
[FORMAT "WCOFF"] ; 制作目标文件的模式
[BITS 32] ; 制作32位模式用的机械语言
;制作目标文件的信息
[FILE "naskfunc.nas"] ; 源文件名信息
GLOBAL① _io_hlt ; 程序中包含的函数名
;以下是实际的函数
[SECTION .text] ; 目标文件中写了这些之后再写程序
_io_hlt: ; void io_hlt(void);
HLT
RET
也就是说，是用汇编语言写了一个函数。函数名叫io_hlt。虽然只叫hlt也行，但在CPU的指
令之中，HLT指令也属于I/O指令，所以就起了这么一个名字。顺便说一句，MOV属于转送指令，
ADD属于演算指令。
用汇编写的函数，之后还要与bootpack.obj链接，所以也需要编译成目标文件。因此将输出
格式设定为WCOFF模式。另外，还要设定成32位机器语言模式。
在nask目标文件的模式下，必须设定文件名信息，然后再写明下面程序的函数名。注意要在
函数名的前面加上“_”，否则就不能很好地与C语言函数链接。需要链接的函数名，都要用
GLOBAL指令声明。
下面写一个实际的函数。写起来很简单，先写一个与用GLOBAL声明的函数名相同的标号
（label），从此处开始写代码就可以了。这次新出现的RET指令，相当于C语言的return，意思就是