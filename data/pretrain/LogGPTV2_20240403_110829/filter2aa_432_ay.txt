（Transmission Control / Internet Protocol）是最常见的。 TCP/IP 是一个网络协议协议族，
我们将在下面进行详细介绍。
6.3.1  什么是 TCP/I P?
用简单的话来讲， TCP/IP 是一个网络协议族的名字，协议是所有软件产品必须遵守
的、能够保证各种软件产品能够正确通讯的规则。协议还定义了每一部分数据块怎样管理
所传输的数据。
精确一点说，一个协议定义了两个应用程序或是计算机之间能够进行互相通讯，对于
其中的每一个（应用程序或计算机）都保证使用同样的标准。TCP/IP 代表传输控制协议/
网络协议（注意：它们是两个不同的协议！），它是做为软件的网络组成部件而设计的。每
个 TCP/IP 的协议都有他专门的工作，比如万维网（WWW），发送电子邮件（E-mail），传
输文件（Ftp），提供远程登陆服务等。
TCP/IP 协议可以根据提供的不同的服务分为几组：
1．控制数据的协议
TCP（传输控制协议 Transmission Control Protocol）以连接为基础，也就是说两台电脑
必须先建立一个连接，然后才能传输数据。事实上，发送和接受的电脑必须一直互相通讯
和联系。
UDP（使用者数据报协议 User Datagram Protocol）它是一个无连接服务，数据可以直
接发送而不必在两台电脑之间建立一个网络连接。它和有连接的 TCP 相比，占用带宽少，
但是你不知道你的数据是否真正到达了你的客户端，而客户端收到的数据也不知道是否还
是原来的发送顺序。
2．数据路由协议
路由协议分析数据包的地址并且决定传输数据到目的电脑最佳路线。他们也可以把大
的数据分成几部分，并且在目的地再把他们组合起来。
IP（因特网协议 Internet Protocol）处理实际上传输数据。
ICMP（因特网控制信息协议 Internet Control Message Protocol）处理 IP 的状态信息，
比如能影响路由决策的数据错误或改变。
RIP（路由信息协议 Routing Information Protocol）它是几个决定信息传输的最佳路由
路线协议中的一个。
OSPF（Open Shortest Path First）一个用来决定路由的协议。网络地址协议决定了命名
电脑地址的方法：使用一个唯一的数字和一个字母名字。
ARP（地址决定协议 Address Resolution Protocol）确定网络上一台电脑的数字地址。
DNS（域名系统 Domain Name System）从机器的名字确定一个机器的数字地址。
RARP（反向地址决定协议 Reverse Address Resolution Protocol）确定网络上一台计算
机的地址，和 ARP（地址决定协议 Address Resolution Protocol）正好相反。
3．用户服务
BOOTP（启动协议 Boot Protocol） 由网络服务器上取得启动信息，然后将本地的网
- 142 -
Linux网络编程
络计算机启动。
FTP（文件传输协议 File Transfer Protocol）通过国际互连网从一台计算机上传输一个
或多个文件到另外一台计算机。
TELNET（远程登陆）允许一个远程登陆，使用者可以从网络上的一台机器通过 TELNET
连线到另一台机器，就像使用者直接在本地操作一样。
EGP（外部网关协议 Exterior Gateway Protocol）为外部网络传输路由信息。
GGP（网关到网关协议 Gateway-to-Gateway Protocol）在网关和网关之间传输路由协
议。
IGP（内部网关协议 Interior Gateway Protocol）在内部网络传输路由信息。
3．其他协议( 也为网络提供了重要的服务)
NFS（网络文件系统 Network File System）允许将一台机器的目录被另一台机器上的
用户 安装（Mount）到自己的机器上，就像是对本地文件系统进行操作一样进行各式各样
的操作。
NIS（网络信息服务 Network Information Service）对整个网络用户的用户名、密码进
行统一管理，简化在 NIS 服务下整个网络登陆的用户名／密码检查。
RPC（远程过程调用 Remote Procedure Call）通过它可以允许远程的应用程序通过简
单的、有效的手段联系本地的应用程序，反之也是。
SMTP（简单邮件传输协议 Simple Mail Transfer Protocol）一个专门为电子邮件在多台
机器中传输的协议，平时发邮件的 SMTP 服务器提供的必然服务。
SNMP（简单网络管理协议 Simple Network Management Protocol）这是一项为超级用
户准备的服务，超级用户可以通过它来进行简单的网络管理。
6.4  套接字地址
好了，关于 socket 的背景知识我们已经讲得够多了，下面，就让我们正式开始揭开 socket
的神秘面纱吧！
6.4.1  什么是 Socket ？
大家经常谈论 “ Socket”（套接字），那么一个套接字究竟是什么呢？
一个套接字可以这样来解释：它是通过标准的 UNIX 文件描述符和其他的程序通讯的
一个方法。
6.4.2  Socket 描述符
使用 UNIX 的黑客高手有这么一句话：“ 恩，在 UNIX 系统中，任何东西都是一个文
件。” 这句话描述了这样一个事实：在 UNIX 系统中，任何对 I/O 的操作，都是通过读或写
一个文件描述符来实现的。
一个文件描述符只是一个简单的整形数值，代表一个被打开的文件（这里的文件是广
义的文件，并不只代表不同的磁盘文件，它可以代表一个网络上的连接，一个先进先出队
列，一个终端显示屏幕，以及其他的一切）。在 UNIX 系统中任何东西都是一个文件！！所
以如果你想通过 Internet 和另外一个程序通讯的话，你将会是通过一个文件来描述符实现
的。你最好相信这一点。
第 6 章  berkeley 套接字
- 143 -
好的，你已经相信 Socket 是一个文件描述符了，那么我们应该怎样才能得到这个代表
网络连接的文件描述符呢？你现在一定非常在意这个问题。是这样的：你首先调用系统函
数 socket()，它返回一个套接字（Socket）描述符，然后你就可以通过对这个套接字描述符
进行一些操作：系统函数 send() 和 recv()（你可以使用 “ man” 命令来查找系统帮助：man
send, man recv）。
你会想：“ 套接字描述符是一个文件描述符，为什么不能用对文件操作的 write() 和
read() 来进行套接字通讯呢？” 事实上， write() 和 read() 是可以对套接字描述符进行操
作的，但是，通过使用 send() 和 recv() 函数，你可以对网络数据的传输进行更好的控制！
6.4.3  一个套接字是怎样在网络上传输数据的？
我们已经谈过了网络协议层，那么我们还应该继续多了解一些东西：物理网络上的数
据是怎样传送的。
我们可以认为是这样的：
数据被分成一个一个的包（Packet），包的数据头（或数据尾）被第一层协议（比如 TFTP
协议） 加上第一层协议数据；然后整个包（包括内部加入的 TFTP 信息头）被下层协议再
次包装（比如 UDP），再这之后数据包会再次被下层协议包装（比如 IP 协议），最后是被
最底层的硬件层（物理层）包装上最后一层信息（Ethernet 信息头）。
当接受端的计算机接收到这个包后，硬件首先剥去数据包中的 Ethernet 信息头，然后
内核在剥去 IP 和 UDP 信息头，最后把数据包提交给 TFTP 应用程序，由 TFTP 剥去 TFTP
信息头，最后得到了原始数据。
下面我们再大致回顾一下著名的网络层次模型。
通过这个网络模型，你可以写套接字的应用程序而不必在乎事实上数据在物理层中的
传输方法（无论是以太网，还是并口、AUI 或是其他的什么方法）。
因为已经有程序在底层为你处理了这些问题了。下面是 OSI 模型，你可以记住它来应
付一些测验。
应用层
表示层
会话层
传输层
网络层
数据链路层
物理层
物理层就是硬件层（比如并口，以太网）。应用程序层离物理层很远很远，以至于它
可以不受物理层的影响。
上面这个模型是最一般的模型，但是在 Linux 中，真正用到的模型是下面这样子的：
应用层（Telnet，Ftp，等等）
主机间对话层（TCP 和 UDP）
网络层（IP 和路由）
网络底层（相当于 OSI 模型中网络、数据链路和物理层）
现在，你大概已经明白各个协议层是怎样对原始数据进行包装和解包的了吧。看见对
- 144 -
Linux网络编程
于每一个数据包有多少项工作需要做了吗？对！你对每一个数据包都需要自己用“ cat” 命
令来查看协议信息头！
开个玩笑。对流式套接字你所需要做的只是调用 send() 函数来发送数据。而对于数据
报套接字，你需要自己加个信息头，然后调用 sendto() 函数把数据发送出去。Linux 系统
内核中已经建立了 Transport Layer 和 Internet Layer。硬件负责 NetworkAccess Layer。简单
而有效，不是吗？
6.5  套接字的一些基本知识
好的，从现在开始，我们应该谈些和程序有关的事情了。
6.5.1  基本结构
首先，我想介绍一些使用套接字编程中常见的网络数据结构对大家会很有帮助。
1．st ruct  sockaddr
这个结构用来存储套接字地址。
数据定义：
struct sockaddr {
unsigned short sa_family; 
/* address族, AF_xxx */
char sa_data[14]; 
/* 14 bytes的协议地址 */
};
sa_family 一般来说，都是 “ AFINET”。
sa_data 包含了一些远程电脑的地址、端口和套接字的数目，它里面的数据是杂溶在一
切的。
为了处理 struct sockaddr， 程序员建立了另外一个相似的结构 struct sockaddr_in：
struct sockaddr_in (“ in”  代表 “ Internet” )
struct sockaddr_in {
short int sin_family; 
/* Internet地址族 */
unsigned short int sin_port; 
/* 端口号 */
struct in_addr sin_addr; 
/* Internet地址 */
unsigned char sin_zero[8]; 
/* 添0（和struct sockaddr一样大小）*/
};
这个结构提供了方便的手段来访问 socket address（struct sockaddr）结构中的每一个元
素。注意 sin_zero[8] 是为了是两个结构在内存中具有相同的尺寸，使用 sockaddr_in 的时
候要把 sin_zero 全部设成零值（使用 bzero()或 memset()函数）。而且，有一点很重要，就
是一个指向 struct sockaddr_in 的指针可以声明指向一个 sturct sockaddr 的结构。所以虽然
socket() 函数需要一个 structaddr * ，你也可以给他一个 sockaddr_in * 。注意在 struct
sockaddr_in 中，sin_family 相当于 在 struct sockaddr 中的 sa_family，需要设成 “ AF_INET”。
最后一定要保证 sin_port 和 sin_addr 必须是网络字节顺序（见下节）！
2．st ruct  i n_addr
其定义如下：
/* 因特网地址 (a structure for historical reasons) */
第 6 章  berkeley 套接字
- 145 -
struct in_addr {
unsigned long s_addr;
};
如 果 你 声 明 了 一 个  “
ina ”
作 为 一 个 struct sockaddr_in
的 结 构 ， 那 么
“ ina.sin_addr.s_addr” 就是 4 个字节的 IP 地址（按网络字节顺序排放）。需要注意的是，
即使你的系统仍然使用联合而不是结构来表示 struct in_addr，你仍然可以用上面的方法得
到 4 个字节的 IP 地址（一些 #defines 帮了你的忙）。
6.5.2  基本转换函数
在前面提到了网络字节顺序。那么什么是网络字节顺序，它有什么特殊性，又如何将
我们通常使用的数据转换成这种格式呢？
1．网络字节顺序
因为每一个机器内部对变量的字节存储顺序不同（有的系统是高位在前，底位在后，
而有的系统是底位在前，高位在后），而网络传输的数据大家是一定要统一顺序的。所以
对与内部字节表示顺序和网络字节顺序不同的机器，就一定要对数据进行转换（比如 IP 地
址的表示，端口号的表示）。但是内部字节顺序和网络字节顺序相同的机器该怎么办呢？
是这样的：它们也要调用转换函数，但是真正转换还是不转换是由系统函数自己来决定的。
2．有关的转化函数
我们通常使用的有两种数据类型：短型（两个字节）和长型（四个字节）。下面介绍
的这些转换函数对于这两类的无符号整型变量都可以进行正确的转换。
如果你想将一个短型数据从主机字节顺序转换到网络字节顺序的话，有这样一个函
数：它是以“ h” 开头的（代表“ 主机”）；紧跟着它的是“ to”，代表“ 转换到”；然后是“ n”
代表“ 网络”；最后是“ s”，代表“ 短型数据”。H-to-n-s，就是 htons() 函数（可以使用 Host
to Network Short 来助记）
很简单吧⋯ ⋯ 我没有理解的时候觉得这个函数不好记呢⋯ ⋯
你可以使用 “ n”，“ h” ，“ to”，“ s”，“ l” 的任意组合⋯ ⋯ 当然，你要在可能的情况下
进行组合。比如，系统是没有 stolh() 函数的（Short to Long Host?）。
下面给出套接字字节转换程序的列表：
htons()——“ Host to Network Short” 主机字节顺序转换为网络字节顺序（对无符号
短型进行操作 4 bytes）
htonl()——“ Host to Network Long” 主机字节顺序转换为网络字节顺序（对无符
号长型进行操作 8 bytes）
ntohs()——“Network to Host Short “ 网络字节顺序转换为主机字节顺序（对无符
号短型进行操作 4 bytes）
ntohl()——“Network to Host Long “ 网络字节顺序转换为主机字节顺序（对无符
号长型进行操作 8 bytes）
注意：现在你可能认为自己已经精通于这几个函数的用处了⋯ ⋯ 你可能会想：“ 恩⋯ ⋯ 在我的 68000
机器内部，字节的表示顺序已经是网络字节顺序了，那么我的程序里就不必调用 htonl() 来转换我的 IP 地
址了”。是的，你可能是对的。但是假如你把你的程序移植到一个内部字节顺序和网络字节顺序相反的机
器上，你的程序就会运行不正常！所以，一定要记住：在你把数据发送到 Internet 之前，一定要把它的字
- 146 -
Linux网络编程
节顺序从主机字节顺序转换到网络字节顺序！
在 struct sockaddr_in 中的 sin_addr 和 sin_port 他们的字节顺序都是网络字节顺序，而
sin_family 却不是网络字节顺序的。为什么呢？
这个是因为 sin_addr 和 sin_port 是从 IP 和 UDP 协议层取出来的数据，而在 IP 和 UDP
协议层，是直接和网络相关的，所以，它们必须使用网络字节顺序。然而， sin_family 域
只是内核用来判断 struct sockaddr_in 是存储的什么类型的数据，并且， sin_family 永远也
不会被发送到网络上，所以可以使用主机字节顺序来存储。
3．I P 地址转换
很幸运， Linux 系统提供和很多用于转换 IP 地址的函数，使你不必自己再写出一段
费力不讨好的子程序来吃力的变换 IP。
首先，让我假设你有一个 struct sockaddr_in ina，并且你的 IP 是 166.111.69.52 ，你想
把你的 IP 存储到 ina 中。你可以使用的函数： inet_addr() ，它能够把一个用数字和点表
示 IP 地址的字符串转换成一个无符号长整型。你可以像下面这样使用它：
ina.sin_addr.s_addr = inet_addr（“166.111.69.52”）;
注意：
inet_addr() 返回的地址已经是网络字节顺序了，你没有必要再去调用 htonl() 函数，是不是很
方便呢？
上面的用法并不是一个很好的习惯，因为上面的代码没有进行错误检查。如果 inet_addr() 函数
执行错误，它将会返回 –1⋯ ⋯ 等等！二进制的无符号整数值 –1 相当于什么？相当于 255.255.255.255 !! 一
个广播用的 IP 地址！没有办法，你只能在你自己的程序里进行对症下药的错误检查了。
好，现在我们已经可以把字符串的 IP 地址转换成长整型了。那么还有没有其他的方法
呢？如果你有一个 struct in_addr 并且你想把它代表的 IP 地址打印出来（按照 数字.数字.数
字.数字的格式）⋯ ⋯
这里，你可以使用函数 inet_ntoa()（“ ntoa” 代表“ Network to ASCII”）：
printf（“%s”, inet_ntoa(ina.sin_addr)）;
这段代码将会把 struct in_addr 里面存储的网络地址以 数字.数字.数字.数字 的格式显
示出来。
注意：
inet_ntoa() 使用 struct in_addr 作为一个参数，不是一个长整型值。
inet_ntoa() 返回一个字符指针，它指向一个定义在函数 inet_ntoa() 中的 static 类型字符串。所
以每次你调用 inet_ntoa()，都会改变最后一次调用 inet_ntoa() 函数时得到的结果。
比如：
char *a1, a2;
a1 = inet_ntoa(ina1.sin_addr); /* this is 166.111.69.52 */
a2 = inet_ntoa(ina2.sin_addr); /* this is 166.111.69.53 */
printf(“ address 1: %s\n”,a1);
printf(“ address 2: %s\n”,a2);
将会显示出：
address 1: 166.111.69.53