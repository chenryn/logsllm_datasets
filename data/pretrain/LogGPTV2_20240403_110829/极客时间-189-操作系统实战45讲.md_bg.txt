# 37 \| 从内核到应用：网络数据在内核中如何流转你好，我是 LMOS。上节课我们对一次请求到响应的过程积累了一些宏观认识，相信你已经对整个网络架构有了一个整体蓝图。这节课，让我们来仔细研究一下网络数据是如何在内核中流转的，让你开阔视野，真正理解底层工程的实现思路。凡事先问目的，在网络数据在内核中的流转，最终要服务于网络收发功能。所以，我会先带你了解一次具体的网络发收过程，然后带你了解lwIP的网络数据收发。有了这些基础，我还会示范一下如何实现协议栈移植，你可以在课后自行动手拓展。好，让我们正式开始今天的学习吧。课程配套代码，你可以点击这里slate-object="inline"获取。先看看一次具体的网络发收过程理解软件的设计思想，最重要的是先要理解需求。而内核中的数据流转也只是为了满足网络收发的需求而进行的设计。发送过程总览下面我们一起来看看应用程序通过网络发送数据的全过程。应用程序首先会准备好数据，调用用户态下的库函数。接着调用系统 API接口函数，进入到内核态。内核态对应的系统服务函数会复制应用程序的数据到内核的内存空间中，然后将数据移交给网络协议栈，在网络协议栈中将数据层层打包。最后，包装好的数据会交给网卡驱动，网卡驱动程序负责将打包好的数据写入网卡并让其发送出去。我为你准备了一张流程图供你参考，如下所示。![](Images/ee78d8c8efd04e7a5d597288b72ad2bd.png)savepage-src="https://static001.geekbang.org/resource/image/dc/bc/dcb38fc1c0eef666eb1496cbf97a82bc.jpg?wh=2705x3530"}发送过程总览上图中，只是展示了大致流程，其中还有 DMA 处理、CRC校验、出错处理等细节，但对于我们理解梳理发送流程，这些就够了。接收过程总览了解了发送数据的过程以后，掌握接收数据的过程就更容易了，因为它就是**发送数据的逆过程**。首先，网卡接受到数据，通过 DMA复制到指定的内存，接着发送中断，以便通知网卡驱动，由网卡驱动处理中断复制数据。然后网络协议收到网卡驱动传过来的数据，层层解包，获取真正的有效数据。最后，这个数据会发送给用户态监听的应用进程。为了让你更加直观地了解这一过程，我特意准备了一张流程图供你参考，如下所示。![](Images/c60f90ad30b2a2987d5119464cb9e7fb.png)savepage-src="https://static001.geekbang.org/resource/image/8a/dd/8a726909f0a19ff1683e541d3712b4dd.jpg?wh=3095x3230"}接收过程总览前面只是帮你梳理一下数据的发送与接收的流程，其实我们真正要关注的是网络协议。可是我们若手动实现一个完整的网络协议，不太现实，网络协议的复杂度大到也许要重新开一门课程，才可以完全解决，所以下面我们借用一下lwIP项目，以这个为基础来讨论网络协议。认识一下 lwIP 架构现在我们清楚了一次具体网络发收过程是怎么回事，那怎么让 Cosmos实现网络通信呢？这里我们选择 lwIP 这个 TCP/IP协议的轻量级开源项目，让它成为 Cosmos的网络部的战略合作伙伴。lwIP 是由瑞典计算机科学研究院（SICS）的 Adam Dunkels 开发的小型开源TCP/IP 协议栈。它是一个用 C语言实现的软件组件，一共有两套接口层，向下是操作系统要提供的，向上是提供给应用程序的。这样lwIP就能嵌入到任何操作系统之中工作，并为这个操作系统上的应用软件提供网络功能支持了。为啥说 lwIP 是轻量级的呢？很简单，跟 Linux比，从代码行数上就能看得出。lwIP的设计目标就是尽量用少量资源消耗，实现一个相对完整的 TCP/IP协议栈。 这里的"完整性"主要是指 TCP协议的完整性，实现的关键点就是**在保持 TCP 协议主要功能的基础上减少对 RAM的占用。** 同时，lwIP还支持 IPv6的标准实现，这也让我们与现代交换设备的对接变得非常方便。这里额外提供你一份扩展阅读资料，lwIP的项目主页链接slate-object="inline"，这里包含了大量相关资料，感兴趣的同学可以课后深入了解。另外，lwIP既可以移植到操作系统上运行，也可以在没有操作系统的情况下独立运行。lwIP 在结构上可分为四层：OS 层、API层、核心层、硬件驱动层，如下图所示。![](Images/3a71d9f3b864e3787ff96019ff5b963f.png)savepage-src="https://static001.geekbang.org/resource/image/ba/60/ba5f483d0f1a6a5d241bde9c25e6d160.jpg?wh=2745x2524"}lwIP架构图副本**第一层**MCU 的业务层是 lwIP 的服务对象，也是其自身代码使用 lwIP的地方。大部分时候我们都是从这里入手，通过 netconn 或 lwip_api 使用 lwIP的各种功能函数。在典型的 TCP 通信的客户端应用程序中，一般先要通过 netconn_new创建一个 struct netconn 对象，然后调用 netconn_connect连接到服务器，并返回成功或失败。成功后，可以调用 netconn_write向服务器发送数据，也可以调用 netconn_recv 接收数据。最后，关闭连接并通过netconn_close 释放资源。**第二层**lwIP 的 api 层是 netconn 的功能代码所在的层，负责为上层代码提供netconn 的 api。习惯使用 socket 的同学也可以使用 lwip_socket等函数，以标准的 socket 方式调用 lwIP。新版本增加了 http、mqtt等应用的代码，这些额外的应用对目前的物联网通信来说确实很方便。**第三层**lwIP 的核心层存放了 TCP/IP 协议栈的核心代码，它不仅实现了大部分的 TCP和 UDP 功能，还实现了 DNS、ICMP、IGMP等协议，同时也实现了内存管理和网络接口功能。该层提供了 sys_arch 模块设计，便于将 lwIP移植到不同的操作系统，如线程创建、信号量、消息队列等功能。和操作系统相关的真正定义写在了lwip/include/sys.h 文件中。**第四层**硬件驱动层提供 PHY 芯片驱动，用来匹配 lwIP 的使用。lwIP会调用该层的代码将组装好的数据包发送到网络，同时从网络接收数据包并进行分析，实现通信功能。lwIP 的三套应用程序编程接口理清了架构，我们再说一说 lwIP的应用程序编程接口，一共有三套。原始 API：原始的 lwIPAPI。它通过事件回调机制开发应用程序。该应用编程接口提供了最佳的性能和优化的代码长度，但它增加了应用程序开发的复杂性。Netconn API：是高级的有序API、需要实时操作系统（RTOS）的支持（提供进程间通信的方法）。Netconn API支持多线程。BSD 套接字 API：类似伯克利的套接字 API（在 Netconn API上开发，需要注意 NETCONN API 即为 SequentialAPI）。 对于以上三种接口，前者只需要裸机调用，后两种需要操作系统调用。因此，移植lwIP 有两种方法，一种是只移植内核，不过这样之后只能基于 RAW/Callback API编写应用程序。第二种是移植内核和上层 API。这时应用程序编程可以使用三种API，即 RAW/Callback API、顺序 API 和 SocketAPI。 lwIP 执行流程现在，想必聪明的你已经理解了前文中的网络收发过程。接下来，让我们顺着之前的思路来对应到 lwIP在收发过程中的核心函数，具体过程我同样梳理了流程图。你可以结合图里关键的函数名以及步骤顺序，按这个顺序在IwIP 代码中检索阅读。数据发送首先要说的是数据发送过程。由于我们把 lwIP 作为 Cosmos 的一个内核组件来工作，自然要由 lwIP接受来自内核上层发来的数据。内核上层首先会调用 lwIP 的 netconn层的接口函数 **netconn_write**，通过这个函数，数据正式流进 lwIP组件层。 接着，netconn 层调用 lwIP 组件的 TCP 层的接口函数 tcp_write，在 TCP层对数据首次进行打包。然后，TCP 层将打包好的数据通过调用 io_output函数，向下传递给 lwIP 组件的 IP层，进行打包。最后，IP 层将打包好的数据发送给网卡驱动接口层netif，这里调用了实际的网卡驱动程序，将数据发送出去。![](Images/098a1831a507959091ed991d332f5f3b.png)savepage-src="https://static001.geekbang.org/resource/image/b3/2c/b31c19ff5c0f89729f0a3d2a42a2452c.jpg?wh=2455x3222"}数据发送逻辑数据接收数据接收的步骤相比数据发送稍微多一些，但也不用害怕，跟住我的讲解思路一定可以理清这个过程。数据接收需要应用程序首先调用 lwIP 的 netconn 层的 netconn_recv接口。然后由 netconn 层调用 sys_arch_mbox_fetch 函数，进入监听等待相关的mbox。 接着，数据会进入网卡，驱动程序相关的函数负责把它复制到内存。再然后是调用ethernet_input 函数，进入 ethernet 层。完成相关处理后，调用 ip4_input函数，数据在 lwIP 组件的 IP 层对数据解包，进行相应处理之后，还会调用tcp_input 函数，进入 lwIP 组件的 TCP层对数据解包。最后，调用 sys_mbox_trypost 函数把数据放入特定的mbox，也就是消息盒子里，这样等待监听的应用程序就能得到数据了。![](Images/1073c6da9483d4355cc52812f73cc335.png)savepage-src="https://static001.geekbang.org/resource/image/d3/ef/d3e0530bb72990da0b56784a73e8ecef.jpg?wh=4030x2305"}数据接收逻辑在了解了 lwIP组件收发数据的过程之后，就可以进行移植的相关工作了。lwIP的结构设计非常优秀，这让移植工作变得很容易。我们这里只要了解 lwIP 组件的 **sys_arch层的接口函数**即可。下面我们一起了解 lwIP的移植细节。协议栈移植lwIP 有两种移植模式，一种是NO_SYS，无操作系统模式，一种是有操作系统模式。用 NO_SYS模式比较简单，你可以自行探索。操作系统模式主要需要基于操作系统的 IPC机制，对网络连接进行了抽象（信号量、邮箱 /队列、互斥体等机制），从而保证内核与应用层 API 的通讯，这样做的好处是 **lwIP内核线程可以只负责数据包的 TCP/IP封装和拆封，而不用进行数据的应用层处理，从而极大地提高系统对网络数据包的处理效率。**而这些操作系统模拟层的函数主要是在 sys.h 中声明的，我们一般在sys_arch.c文件中完成其定义。所以，我们很清楚，带操作系统的移植就是在无操作系统的基础上添加操作系统模拟层。再接下来我们就看看操作系统模拟层的编写。有操作系统模式在之前的课程里我们已经正确实现了 Cosmos 操作系统了，现在我们就可以在Cosmos 系统提供的 IPC 等机制基础之上，对照 sys.h文件中声明的函数一一去实现了。实际工程中完整移植网络栈，需要将后面表格里的这 30多个函数全部实现。我会带你完成邮箱和系统线程相关的关键部分移植，其他函数的移树思路也大同小异，这里就不一一演示了。![](Images/efad10fada09dd018a80f476e746c1a0.png)savepage-src="https://static001.geekbang.org/resource/image/51/ff/51791a1817fca811aaa1c0240c4135ff.jpg?wh=902x1198"}函数表格从上表中我们可以发现，这些变量和函数主要面向信号量、互斥体和邮箱，包括创建、删除、释放和获取等各种操作，所以我们需要根据操作系统的规定来实现这些函数。突然看到这么多功能，是不是有点慌？其实不用怕，因为这些功能的实现起来非常简单。首先，我们通过一个例子来看看邮箱功能的实现。在 lwIP中，用户代码通过邮箱与协议栈内部交互。邮箱本质上是指向数据的指针。API将指针传递给内核，内核通过这个指针访问数据，然后进行处理。相反，内核也是通过邮箱将数据传递给用户代码的。具体代码如下，关键内容我都做了详细注释。    /*创建一个空的邮箱。*/    err_t sys_mbox_new(sys_mbox_t *mbox, int size)    {    osMessageQDef(QUEUE, size, void *);    *mbox = osMessageCreate(osMessageQ(QUEUE), NULL);    #if SYS_STATS    ++lwip_stats.sys.mbox.used;    if (lwip_stats.sys.mbox.max buffer != NULL) && (thread_def->controlblock != NULL)) {    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,    thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),    thread_def->buffer, thread_def->controlblock);    }    else {    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,    thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),    &handle) != pdPASS) {    return NULL;    }    }    #elif( configSUPPORT_STATIC_ALLOCATION == 1 )    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,    thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),    thread_def->buffer, thread_def->controlblock);    #else    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,    thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),    &handle) != pdPASS) {    return NULL;    }    #endif    return handle;    }至此，基于 Cosmos 操作系统移植 lwIP协议栈的关键部分就算完成了。重点回顾好，这节课的内容告一段落了，我来给你做个总结。我们首先从数据发送接收的视角，观察了数据从用户态到内核态，再从内核态到流动到用户态的全过程。接着，我们发现网络协议栈移植与 DMA、内核的 IPC、信号量、DMA等机制密切相关。理解网络栈移植的关键步骤，能够让我们更好地理解内核特性在工程中是如何应用的。最后，我们实现了将 lwIP 网络协议栈的关键部分移植到 Cosmos操作系统下。不过这节课我带你实现了邮箱和系统线程相关的关键部分，其他函数移植道理相通，感兴趣的同学可以自行探索。思考题我们已经了解到了操作系统内核和网络协议栈的关系，可是网络协议栈真的一定只能放在内核态实现么？欢迎你在留言区跟我交流探讨。也欢迎你把这节课分享给自己的朋友、同事。我是 LMOS，我们下节课见！