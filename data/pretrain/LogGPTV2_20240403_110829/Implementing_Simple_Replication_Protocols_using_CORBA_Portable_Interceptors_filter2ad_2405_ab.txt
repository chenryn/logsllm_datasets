the same request twice, leading to a possible system
inconsistency. This is the rationale for the buffering of
requests.
This buffering technique works correctly in a single-client
case, because in case (iii) the first request received by the
backup necessarily corresponds to the last received
set_state request (we assume that our clients are
single-threaded). The multi-client case is more subtle, and
is discussed in the next section.
3.2. Multi-client implementation
Some difficulties here are inherent
to distributed
programming in an asynchronous context, and others arise
from limitations of CORBA’s portable interceptors.
As in the single-client case, in case of failure, the backup
and the remaining clients must agree on when the primary
has crashed to avoid inconsistencies. However, unlike the
single-client case,
the backup can't determine with
certainty whether the system is in case (i), (ii) or (iii) of
the above classification. First, the backup can never know
it has received a l l set_state
with certainty that
requests issued before the crash (in the mono client case
this is done by numbering the client's requests and
set_state info). Secondly, when the backup is asked
to become the primary by some client C1, if the last
set_state info it received corresponds to a request
issued by another client C2, the backup can never be sure
whether C2 has obtained its reply [case (i)] or whether C2
is going to contact it again by re-issuing its request
[case(iii)].
the backup m u s t apply the
set_state info, or C2 would have seen a future that
would have been lost by the crash, resulting in an
inconsistency. In case (ii), the backup can't apply the
set_state info, otherwise it won't be able to answer C2
without re-executing its request twice (as in the single-
client case), thus also resulting in an inconsistency.
Because we're using TCP/IP connections, which are
asynchronous, these problems are demonstrated to have
no solution that works in all configurations. To solve the
problem, we rely on an implicit synchrony assumption, by
assuming that with a very high probability, messages don't
take longer than a predefined duration to reach their
destination. This means that after a given time window,
the reply issued by the primary has been received by the
client, or that the client has re-sent the request to the
backup. Of course,
the use of an atomic broadcast
framework would resolve the problems caused by the
system’s asynchrony by imposing a total order on all
requests. Unfortunately, CORBA portable interceptors
In case (i),
don't support this option, because the communication
primitives used by the ORB cannot be adapted using the
PI mechanisms.
3.3. Application
We have used a simple banking application to assess the
performance of these fault tolerance mechanisms. The
server is a CORBA service that implements the basic
operations needed to operate bank accounts: account
creation, balance of an account, deposit or withdrawal on
an account, transfer between two accounts, etc. The client
accesses the bank service through CORBA requests. We
have compared the latency of client requests in three
different system configurations:
A. The standalone banking application;
B. The
banking
together with
“transparent” portable interceptors, in order to
measure interception overhead;
application
C. A fault-free execution of the banking application
with interceptors implementing the full primary-
backup replication mechanism.
Our experimental testbed comprises hosts with 1GHz i686
processors running Linux 2.4,
interconnected over
100Mb/s Ethernet. The client runs on a different host from
the server, and in the fault tolerant configuration the
primary and backup run on the same host. We performed
1000 experiments, each experiment
including 1000
invocations (account creation, withdrawal or deposit). We
measured the duration of an experiment and obtained the
results shown in Figure 3.
)
s
m
(
e
m
i
T
18
16
14
12
10
8
6
4
2
0
A p p l
i c a t i o n
A p p   w i t h   I n t e r c e p t i o n
A p p   w i t h   F T
A. Response time for a remote client
Application
15%
Interception
7%
De-serialization
15%
Serialization
15%
Minimum
Average
Maximum
FT Algorithms
48%
B. Cost breakdown of the DAISY mechanisms
Figure 3. Preliminary performance measurements
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:29:07 UTC from IEEE Xplore.  Restrictions apply. 
in the
tolerance mechanisms
Figure 3.A shows response latency (mean, minimum and
maximum values) for configurations A, B and C. The
results show that while the use of “empty” interceptors
only increases response latency by 15%, the addition of
fault
interceptors
significantly increases overhead. It is worth noting that
our application is very simple, and that the relative cost of
these mechanisms would be considerably lower for a more
realistic application. Figure 3.B shows the breakdown of
this overhead per aspect of the mechanism. Except for the
interception overhead, which is independent of the nature
of the application, most of these costs depend on the size
of the checkpointed state. These variable costs include
serialization of the primary’s state,
the transfer of
information for
replica synchronization, and the
deserialization of the state on the backup.
4. Discussion
the application. However,
section described the use of
The previous
Java
serialization and CORBA portable interceptors to
implement a simple replication mechanism. In this
section, we consider the advantages of these basic
reflective mechanisms over more
conventional
implementation approaches, and discuss a number of
limitations that they impose.
The JVM Serialization interface provides access to the
internal state of Java objects in a portable format. This
relieves application developers
from the task of
implementing this critical aspect of the replication
protocol. We use Java serialization to checkpoint
application objects on the primary and to apply
checkpoints on the backup.
In more traditional
approaches, the application programmer would have to
implement (correct!) methods for saving and restoring the
state of
the state of an
application includes several facets, not only the internal
state of the application objects, but also some external
state that is embedded within the underlying executive
layers [13]. Java serialization deals only with the internal
state, i.e. the attributes of the object. Handling the other
facets calls for more advanced reflective features and
requires a clear understanding of the mapping relations
between application objects, middleware and operating
system data structures.
CORBA portable interceptors enable requests to be
intercepted and processed by the fault-tolerance
mechanisms. The main benefit
is that client-server
interactions can be controlled transparently, without
requiring any modifications to the application-level code.
Portable interceptors can be inserted easily without
disturbing the development of application objects and thus
can be changed (at load time only) depending on system
configuration and environmental conditions. Moreover, as
it resides at the ORB level, the interceptor is independent
from the operating system and transport layer. Interceptors
are also independent of the server and client application,
and are therefore portable and reusable.
However, CORBA’s Portable Interceptors have a number
of important drawbacks.
1. PIs cannot modify a request’s input parameters.
Implementing certain non-functional mechanisms, such as
ciphering client-server communications, would require the
ability to modify the parameters of a request, by replacing
them with their ciphered counterpart. However, PIs are
able to piggyback some information along with the
request and are thus able to sign requests.
2. PIs cannot modify a request’s output parameters.
In our implementation, the backup cannot directly apply
the checkpoints it receives to its object. It buffers them
and waits in order to know whether the invoker of the
request corresponding to the checkpoint has received the
reply. When a client has not received its reply, the backup
receives the corresponding request but cannot forge a
reply; it has to re-process the request in order to produce
the reply. The ability to modify output parameters would
simplify this mechanism considerably: the backup could
cache the reply received from the primary and apply the
checkpoint. When receiving the corresponding request
from the client, it would send the reply back without
having to process the request twice.
3. PIs must invoke every request.
The only way to prevent a PI from invoking a request is to
throw an exception that will probably be interpreted as an
error signal at
the client side. Some fault-tolerant
mechanisms, such as the leader-follower replication
algorithm, cannot be easily implemented with this
restriction. In a leader-follower configuration, several
replicas receive the requests but only one replies to them.
This would necessitate cheating if implemented with PIs.
4. PIs are not CORBA objects.
PIs cannot communicate with one another directly. In our
implementation, the PI of the primary sends set_state
requests to the Backup server in order to communicate
with the PI of the backup. The backup PI intercepts the
invocation, checks what type of request it is (for the server
or the PI). If it is for the PI, it will throw an exception in
order not to process the request. This trick requires the
server to implement an interface that includes an “empty”
set_state method that is used only by the interceptors.
Likewise, the server must implement an empty p i n g
method that is used for error detection. These methods
have nothing to do with application-level concerns, but
limitations of interceptor mechanism means that they
become visible to application programmers. This
intrusiveness could be eliminated if interceptors were
CORBA objects: each interceptor would have an object
reference, would be able to implement an interface, and
would be able to communicate with other interceptors.
The fault
tolerance mechanisms would be more
transparent for the user and the interceptors would be
easier to develop.
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:29:07 UTC from IEEE Xplore.  Restrictions apply. 
is single- or multi-threaded,
5. PIs don’t have their own thread.
As we mentioned above, each interceptor inherits a
concurrency model from its associated CORBA object.
Whether the object
the
interceptor is only activated by the arrival of an incoming
request; it cannot implement its own event loop. This
means that certain mechanisms, such as periodic “I’m
alive” messages, cannot be easily implemented.
6. PIs cannot reorder requests.
As discussed in section 3.2, handling multiple clients is
very difficult. When the backup PI is switching to the
primary mode, it has to wait for the last request processed
by the former primary in order to decide whether or not to
apply the last checkpoint
it received. It might have
received a certain number of requests from other clients in
the meantime, and has to “freeze” them while waiting for
this particular request. This is very difficult with some
ORB threading strategies. A solution would be for
requests to be first class objects, which means being able
to manipulate them as regular objects: passivate, serialize
and forward them [12]. This change would simplify the
development of complex fault-tolerance strategies, but
would require more work at the middleware level when
providing information to the interceptor.
5. Conclusion
This experimental work shows that simple replication
mechanisms can be implemented from basic and
standardized interception and serialization mechanisms,
namely CORBA Portable
Interceptors and J a v a
Serialization. A set of customized Portable Interceptors
could be developed to offer a wide range of fault-tolerance
strategies that could be selected according to the needs of
the application and the infrastructure configuration. It is
worth noting that these mechanisms can be provided in a
non-intrusive manner, transparently to the application
level. However, our work has highlighted a number of
limitations in CORBA’s interceptors. Some of the issues
identified in section 4 could easily be solved by a new
generation of portable interceptors, which would greatly
facilitate the implementation of replication-based fault
tolerance mechanisms. These improvements would be
industrially relevant as these standard executive supports
are now being used in several application domains where
lightweight and non-intrusive implementation of
replicated processing for availability has some merits.
We are currently using the DAISY platform to investigate
the implementation of extended fault tolerance features,
with a focus on wrapping techniques for improved error
detection at the communication level, at the middleware
level, and at
the operating system level. Regarding
behavioral and state control at all levels of the system
architecture, we are currently investigating multilevel
reflection, i.e. reflective principles applied to all system
layers, previously presented at DSN’2003(cid:0)[12].
6. References
[1]
[2]
[3]
[4]
[5]
[6]
[7]
[8]
[9]
[10]
[11]
[12]
OMG, “Common Object Request Broker Architecture
(CORBA/IIOP) 3.0.2,” 2002-12-02, 2002.
Sun, “Java Object Serialization Specification,” Sun
Microsystems, Technical Report November 1998.
CORBA,
“Common Object Request Broker
Architecture: Core Specification,” ch.23 Fault Tolerant
CORBA, OMG formal/02-12-06, December 2002.
R. Baldoni, C. Marchetti and A. Termini, “Active
Software Replication throught Three-tier Approach,”
presented at 21st
IEEE Symposium on Reliable
Distributed Systems (SRDS2002), Osaka, Japan, 2002.
L. E. Moser, P. M. Melliar-Smith, and P. Narasimhan,
“A Fault Tolerant Framework for CORBA,” presented
at 29th International Symposium on Fault-Tolerant
Computing, Madison, Wisconsin, USA, 1999.
R. Friedman and E. Hadad, “A Group Adaptor-Based
to CORBA Fault-Tolerance,” IEEE distributed systems
online, middleware 2001.
J.-C. Ruiz-García, M.-O. Killijian, J.-C. Fabre, and P.
Thévenod-Fosse, “Reflective Fault-Tolerant Systems:
From Experience to Challenges,” IEEE Transactions
on Computers, Special Issue on Reliable Distributed
Systems, vol. 52, pp. 237-254, 2003.
“Concepts
and Experiments
Pattie Maes,
in
Computational Reflection,” ACM Conference on
Object-Oriented Programming Systems, Languages,
and Applications (OOPSLA'87), pp.147-155, Orlando,
Florida, October 1987.
G. Agha, S. Frolund, R. Panwar, and D. Sturman, “A
Linguistic Framework for Dynamic Composition of
Dependability Protocols,” presented at DCCA-3, 1993.
B. Garbinato, R.Guerraoui
and K.Mazouni,
“Implementation of the GARF Replicated Object
Platform,” Distributed System Engineering Journal,
vol2, pp 14-27, 1995.
S. Chiba, “A Metaobject Protocol for C++,” presented
at ACM Conference on Object Oriented Programming
Systems, Languages, and Applications (OOPSLA’95),
Austin, Texas, USA, 1995.
F. Taiani, J.-C. Fabre, and M.-O. Killijian, “Towards
Implementing Multi-Layer Reflection for Fault-
Tolerance,” presented at DSN’2003, The International
Conference on Dependable Systems and Networks,
San Francisco, CA, USA, 2003.
[13] M.-O. Killijian, J.-C. Ruiz-Garcia, and J.-C. Fabre,
“Portable serialization of CORBA objects: a reflective
approach,” presented at 2002 ACM SIGPLAN
Conference on Object-Oriented Programming Systems,
Languages and Applications, OOPSLA 2002, Seattle,
Washington, USA, 2002.
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:29:07 UTC from IEEE Xplore.  Restrictions apply.