70
4080
60
20
pivotkey=501ow
high
图9-9-1
2.第5~13行为whil循环，目前bw=1pivotkey=50，因此不执行第8行。
4.第9行，交换Lr[ow]与L.r[high]的值，使得Lr[1]=20，Lr[9]=50。为什么要
交换，就是因为通过第7行的比较知道，Lr[high]是一个比pivotkey=50（即
Lr[ow]）还要小的值，因此它应该交换到50的左侧，如图9-9-2所示。
下标
0
2
3
4
20109030
70
40
80
60
50
pivotkey=50low
high
图9-9-2
5.第10行，当Lr[low]=Lr[1]=20，pivotkey=50，Lr[ow]50，退出循环。
419
---
## Page 444
大据数据结构
6.第12 行，交换Lr[bw]=Lr[3]与Lr[high]=Lr[9]的值，使得Lr[3]=50，
Lr[9]=90。此时相当于将一个比50大的值90交换到了50的右边。注意此时
bw已经指向了3，如图9-9-3所示。
下标0
20105030
pivotkey=50
low
high
图9-9-3
7.继续第5行，因为kw=3pivotkey，因此第8
行，high--，此时high=8。继续循环，Lr[8]=60>50，high-，此时high=7。
Lr[7]=80>50，high-，此时high=6。Lr[6]=4050，退出循环。
11.第12行，交换Lr[ow]=Lr[5]=70与Lr[high]=Lr[6]=50的值，使得
Lr[5]=50，Lr[6]=70，如图9-9-5所示。
下标0123
4
6
8
201040305070806090
pivotkey=50
low
high
图9-9-5
420
---
## Page 445
第9章排序
12.再次循环。因bw=5T（k）+n
n
由数学归纳法可证明，其数量级为0（nogn)。
就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度
为bg2n，其空间复杂度也就为O[ogn），最坏情况，需要进行n-1递归调用，其空间
复杂度为0（n），平均情况，空间复杂度也为0（ogn）。
可惜的是，由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳
定的排序方法。
9.9.3快速排序优化
刚才讲的快速排序还是有不少可以改进的地方，我们来看一些优化的方案。
1.优化选取枢轴
如果我们选取的pivotkey是处于整个序列的中间位置，那么我们可以将整个序列
分成小数集合和大数集合了。但注意，我刚才说的是“如果是中间”，那么假如我
们选取的pivotkey不是中间数又如何呢？比如我们前面讲冒泡和简单选择排序一直用
到的数组{9.1,5,8,3,7,4,6.2}，由代码第4行“pivotkey=L>r[ow]:知道，我们应该选
422
---
## Page 447
第9章排序
取9作为第一个枢轴pivotkey。此时，经过一轮“pivot=Partition（L1,9）：”转换
后，它只是更换了9与2的位置，并且返回9给pivot，整个系列并没有实质性的变
化，如图9-9-8所示。
下标0123456789
9
pivotkey=9
lowhigh
8°6°6 ]
就是说，代码第4行“pivotkey=L->r[ow]：”变成了一个潜在的性能瓶颈。排序速
度的快慢取决于Lr[1]的关键字处在整个序列的位置，Lr[1]太小或者太大，都会影响
性能（比如第一例子中的50就是一个中间数，而第二例子的9就是一个相对整个序列
过大的数）。因为在现实中，待排序的系列极有可能是基本有序的，此时，总是固定选
取第一个关键字（其实无论是固定选取哪一个位置的关键字）作为首个枢轴就变成了
极为不合理的作法。
改进办法，有人提出，应该随机获得一个bw与high之间的数rmd，让它的关键
字Lr[rnd]与Lr[kow]交换，此时就不容易出现这样的情况，这被称为随机选取枢轴
法。应该说，这在某种程度上，解决了对于基本有序的序列快速排序时的性能瓶颈。
不过，随机就有些撞大运的感觉，万一没撞成功，随机到了依然是很小或很大的关键
字怎么办呢？
再改进，于是就有了三数取中（median-of-three）法。即取三个关键字先进行排
序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。这样
至少这个中间数一定不会是最小或者最大的数，从概率来说，取三个数均为最小或最
大数的可能性是微乎其微的，因此中间数位于较为中间的值的可能性就大大提高了。
由于整个序列是无序状态，随机选取三个数和从左中右端取三个数其实是一回事，而
且随机数生成器本身还会带来时间上的开销，因此随机生成不予考虑。
我们来看看取左端、右端和中间三个数的实现代码，在Partition函数代码的第3
行与第4行之间增加这样一段代码。
3int pivotkey;
intm=1ow+（high-1ow）/2：/*计算数组中间的元素的下标*/
（[ubTu]xr[m]>L->r[1ow]）
swap（L,m,1ow）;
/*交换中间与左端数据，保证左端较小*/
/*此时L.r[1ow]已经为整个序列左中右三个关键半的中间值。*/
[Tr[low];
/用子表的第一个记录作相轴记录·/
L->r[0]=pivotkey;
/*将框轴关键字备份到L->r[0]*/
while(1owr[high]>=pivotkey)
high--!
L->r[1ow]=L->r[high];/采用替换而不是交换的方式进行操作/
while（1owr[1ow]z[high]=L->r[1ow];/采用替换而不是交换的方式进行操作*/
424
---
## Page 449
第9章排序
:[0]x<-T=[noT]x<-T
/将枢轴数值替换回L.r[1ow]*/
return low;
返团想轴所在位置*/
注意代码中加粗部分的改变。我们事实将pivotkey备份到Lr[O]中，然后在之前
是swap时，只作替换的工作，最终当bw与high会合，即找到了枢轴的位置时，再
将Lr[0]的数值赋值回Lr[ow]。因为这当中少了多次交换数据的操作，在性能上又得
到了部分的提高。如图9-9-9所示。
注意这里Lr[0]-pivotkey
下标0
1234
50501090307040806020
pivotkey=501ow
high
下标
50201090307040806020
下标
40
pivotkey=50
下标
50
2010
40
30
70
40
pivotkey=50