threshold is independent of the circuit size.
6 IMPLEMENTATION AND RESULTS
We implemented our protocol in C++ using Shoup’s NTL library
for the (cid:27)nite (cid:27)eld operations. We used BOOST::MPI for emulating
a network. To pick the evaluation points, we chose a prime that
had su(cid:28)ciently large power of two roots of unity and set ηi and ζj
values to be roots of unity. This enabled us to perform interpolation
and evaluation using inverse FFT and FFT operations. We ran our
experiments on Intel Core i7-4720HQ CPU 2.60 GHz, 4 cores, 8 GiB
RAM. For our collision resistant hash function we used SHA-256.
We primarily compare our work with ZKB++/ZKBoo [13, 22]
that qualitatively match our result in most aspects. The crucial
advantage of our approach over ZKBoo/ZKB++ is that our com-
munication is sublinear in the circuit size whereas ZKBoo/ZKB++
incurs communication that is proportional in the circuit size. More-
over, in the amortized setting, our approach provides signi(cid:27)cantly
better communication cost and runtimes over ZKBoo/ZKB++.
The primary Boolean predicate we used to demonstrate our
implementation was verifying a SHA-256 certi(cid:27)cate as it is the
common benchmark used in prior works. Namely, on a common
input a 256-bit string y and a private input x of the prover, the
prover convinces the veri(cid:27)er that SHA256(x) = y.
Optimizations. A standard computation of the SHA certi(cid:27)cate,
involves AND and XOR gates and addition modulo 232 gates. One
approach is to simply realize the addition modulo 232 gates us-
ing Boolean AND and XOR gates. We follow a di(cid:29)erent approach,
where we express the addition modulo 232 gate consistency as a
linear constraint over the bits of the inputs and output of the gate.
Following Section 4.5, this can be e(cid:28)ciently realized if we rely on a
prime (cid:27)eld larger than 233. However, as mentioned in the previous
section, to obtain optimal communication for a given witness size
requires choosing a (cid:27)eld of a speci(cid:27)c size. To handle this, we incor-
porate these addition gates by considering a word size of (cid:100)log |F|(cid:101)
and performing 32-bit additions using arithmetic over the smaller
word size. Following these optimizations, results in a witness size
of 33928 bits for the SHA-256 certi(cid:27)cate (for |F| ≥ 214). We ran our
protocol for di(cid:29)erent circuit sizes and for each size, we ran ad-hoc
optimizers to obtain optimal parameters for soundness 2−40. We
remark that a tighter soundness error for the tests described in
Section 4 which in turn is used in our ZKIPCP can be obtained by
discarding the last inequality in Lemma 4.2, 4.6 and 4.8. We relied
on these better bounds in our optimizer (as opposed to the cleaner
bounds that appear in the Lemma statements). For the case of 2−80
soundness error the communication and computation costs doubles
(as in [13, 22]). For boolean circuits, the quadratic constraints only
involves checking if each element of the witness is binary and we
can simplify the test in Section 4.3 by eliminating x, y, z and having
the prover compute p0(•) =
In Figure 1, we compare the prover and veri(cid:27)er running times
for verifying circuits of sizes varying from 2048 gates to 400000
gates.4 The computational complexity of both the prover and the
veri(cid:27)er in the single instance setting are proportional to O(s log s)
(cid:27)eld operations, where s is the circuit size. The optimal (cid:27)eld size
can be asymptotically shown to be O(log s) resulting in a overall
computational complexity of O(s log2
s). We remark here that if
we make uniformity assumptions on the circuit, then the veri(cid:27)er’s
computational complexity becomes sublinear in the circuit size. In
fact, the multi-instance setting can be seen as a uniformity assump-
tion and here the veri(cid:27)er’s complexity is indeed smaller than the
computational complexity.
i (•) · pw
i ri · (pw
i (•) − pw
i (•)).
4Note that our proof length and computation times are not in(cid:30)uenced by circuit
topology and only depend on the witness size which in turn depends only on the
number of gates. In fact, in the case of Boolean circuits, they are independent of gate
composition (assuming the circuit comprises of only XOR and AND gates).
Session J1:  OutsourcingCCS’17, October 30-November 3, 2017, Dallas, TX, USA2100Figure 1: Prover and veri(cid:27)er running times for verifying
a single instance of di(cid:29)erent circuit sizes.
Figure 2: Proof lengths for proving a single instance of
di(cid:29)erence circuit sizes.
Figure 3: Amortized prover and veri(cid:27)er running times
for verifying multiple instances of 2048 and gate circuit
and SHA-256 circuit.
In Figure 2, we provide the communication complexity in kilo-
bytes (KB) of our zero-knowledge argument. We plot two instan-
tiations of our protocol. We provide communication cost for our
provable variant labelled Ligero and the variant that assumes Con-
jecture 4.1 labelled as Ligero-Strong. We observe that Ligero-Strong
Figure 4: Amortized proof lengths for multiple instances
of 2048 gate circuit and SHA-256 circuit.
yields a 20% reduction in communication on the average. The com-
munication for a SHA certi(cid:27)cate is 44KB with Ligero and 34KB with
Ligero-Strong. We can also see in Figure 2 that beyond 3 million
gates our communication cost is smaller than the circuit size.
103104105106107510501005001s5s10s50s3minSHA256s(circuitsize)Runtime(ms)ProvertimeVeriﬁertime1103104105106510501005003·106G(#gates)Communication(KB)LigeroLigero-StrongZKB++lengthCircuitSize11101001000500010−410−310−210−1100101102N(instances)Runtime/instance(ms)Provertime(2048)Veriﬁertime(2048)Provertime(SHA256)Veriﬁertime(SHA256)11248163264128256292102112121001011021031042048gatecir.SHA256N(instances)Communication/instance(KB)2048gatecir.SHA2561Session J1:  OutsourcingCCS’17, October 30-November 3, 2017, Dallas, TX, USA2101We compare our complexity with ZKB++ [13, 22]). We (cid:27)rst note
that the complexity of ZKB++ only depends on the number of
Boolean AND gates (as XOR’s are for free). In our implementation
we relied on prime (cid:27)elds and our communication cost depends on
the number of AND and XOR gates. However, had we relied on
extension (cid:27)eld of GF2, we can eliminate the dependence on XOR
gates similar to ZKB++. In this variant of our protocol, each AND
gate will incur 3 bits in the witness. In Figure 2, in order to make
a fair comparison with ZKB++ for a circuit of size s, we plot the
communication cost incurred by the ZKB++ protocol for a circuit
of size 2s/3. The idea is that for a circuit comprising of 2s/3 AND
gates the cost of ZKB++ is compared with the communication cost
of our protocol assuming a characteristic-2 FFT implementation.
The threshold for which our approach incurs lesser communication
than ZKB++ is roughly 3000 (AND) gates.
In Figures 3 and 4 we provide our prover and veri(cid:27)er running
times and communication for the multi-instance version of our
protocol. We take a 2048 gate circuit and the SHA-256 circuit to
illustrate our performance. The heaviest part of the veri(cid:27)cation
involves performing FFTs over domains of sizes N and s where s
is the circuit size. Since we considered 1 to 4096 instances, even
for moderately sized circuits the FFT over domain of size s dom-
inates the cost. The prover complexity, on the other hand, varies
as Ns log s. We see a reduction in the amortized prover’s cost per
instance with periodic jumps because we perform FFT over a larger
domain, which is usually set to a power of 2.
The communication complexity varies additively in N and s. The
amortized communication cost per instance decreases linearly be-
cause, similar to the veri(cid:27)er complexity, s dominates the complexity
until N becomes signi(cid:27)cant compared to s.
7 CONCLUSIONS AND FUTURE WORK
We designed and implemented a zero-knowledge argument for NP
that simultaneously o(cid:29)ers good concrete e(cid:28)ciency and sublinear
communication in the circuit size. As the computational complex-
ity of our protocol is dominated by polynomial evaluations and
interpolations, we can rely on e(cid:28)cient FFT implementations for
minimizing its computational cost. In the following we mention
some additional optimizations that we have not fully explored.
The current implementation relies on prime (cid:27)elds. This allows us
to optimize arithmetics over integers by considering a su(cid:28)ciently
large prime. Moreover, the witness includes two bits per gate for
both XOR and AND gates. If we instead rely on characteristic 2
(cid:27)elds, then the witness size will require three bits per AND gate and
0 bits for XOR gates. Hence there is a tradeo(cid:29) in choosing between
the two options. It is also unclear how the FFT algorithms compare
for characteristic 2 and prime (cid:27)elds, though fast implementations
for the characteristic 2 case are known [10, 20].
The veri(cid:27)cation of our zero-knowledge argument needs to eval-
uate a polynomial on a subset of the points in the domain. We
currently implement this by having the veri(cid:27)er evaluate the poly-
nomial on the entire domain via FFT and extract the points in this
subset. Improving this will improve the veri(cid:27)er’s e(cid:28)ciency. Relying
on GPU for FFT computations can also bring signi(cid:27)cant savings.
Finally, one can exploit a repetitive circuit structure (“uniformity”)
to reduce veri(cid:27)cation time. We currently only take advantage of this
for reducing the amortized cost of verifying multiple evaluations
of the same circuit. On the prover side, more than 50% of the total
prover time for small circuits and 66% for large circuits is spent on
computing the hashes of the leaves of the Merkle tree. This leaves
room for improvement by relying on space- and cache-e(cid:28)cient
hashing algorithms.
Finally, it would be interesting to explore the concrete e(cid:28)ciency
of other approaches to lightweight sublinear zero-knowledge argu-
ments. In particular, one could consider constructions of PCPs based
on bivariate polynomials such as the one of Polishchuk and Spiel-
man [40] (see [8] for work in this direction), or the zero-knowledge
PCP obtained by applying our general transformation to the MPC
protocol from [17]. This type of constructions can be further sim-
pli(cid:27)ed by applying an interactive procedure for testing linear con-
straints as we do in Section 4.2.
Acknowledgments. We thank Eli Ben-Sasson, Swastik Kopparty,
abhi shelat, Salil Vadhan, and Mike Wal(cid:27)sh for useful discussions
and pointers, the anonymous CCS reviewers for helpful comments,
and Victor Shoup for his assistance with the NTL library.
The (cid:27)rst and last authors were supported by Google Faculty Re-
search Grant and NSF Awards CNS-1526377 and CNS-1618884. The
second author was supported by the European Research Council
under the ERC consolidators grant agreement n. 615172 (HIPS), and
by the BIU Center for Research in Applied Cryptography and Cyber
Security in conjunction with the Israel National Cyber Bureau in
the Prime Minister’s O(cid:28)ce. The third author was supported by
a DARPA/ARL SAFEWARE award, DARPA Brandeis program un-
der Contract N66001-15-C-4065, NSF Frontier Award 1413955, NSF
grants 1619348, 1228984, 1136174, and 1065276, ERC grant 742754,
NSF-BSF grant 2015782, ISF grant 1709/14, BSF grant 2012378, a
Xerox Faculty Research Award, a Google Faculty Research Award,
an equipment grant from Intel, and an Okawa Foundation Research
Grant. This material is based upon work supported by the Defense
Advanced Research Projects Agency through the ARL under Con-
tract W911NF-15-C-0205. The views expressed are those of the
authors and do not re(cid:30)ect the o(cid:28)cial policy or position of Google,
the Department of Defense, the National Science Foundation, or
the U.S. Government.
REFERENCES
[1] Sanjeev Arora, Carsten Lund, Rajeev Motwani, Madhu Sudan, and Mario Szegedy.
1998. Proof Veri(cid:27)cation and the Hardness of Approximation Problems. J. ACM
45, 3 (1998), 501–555.
[2] Sanjeev Arora and Shmuel Safra. 1998. Probabilistic Checking of Proofs: A New
[3] László Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. 1991. Checking
Characterization of NP. J. ACM 45, 1 (1998), 70–122.
Computations in Polylogarithmic Time. In STOC. 21–31.
[4] Eli Ben-Sasson, Iddo Bentov, Alessandro Chiesa, Ariel Gabizon, Daniel Genkin,
Matan Hamilis, Evgenya Pergament, Michael Riabzev, Mark Silberstein, Eran
Tromer, and Madars Virza. 2017. Computational Integrity with a Public Random
String from Quasi-Linear PCPs. In EUROCRYPT. 551–579.
[5] Eli Ben-Sasson, Iddo Bentov, Ynon Horesh, and Michael Riabzev. 2017. Scalable,
transparent, and post-quantum secure computational integrity. Manuscript.
(2017). Slides at https://people.eecs.berkeley.edu/~alexch/docs/pcpip_bensasson.
pdf.
[6] Eli Ben-Sasson, Alessandro Chiesa, Ariel Gabizon, Michael Riabzev, and Nicholas
Spooner. 2016. Short Interactive Oracle Proofs with Constant Query Complexity,
via Composition and Sumcheck. IACR Cryptology ePrint Archive 2016 (2016),
324.
[7] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers,
Eran Tromer, and Madars Virza. 2014. Zerocash: Decentralized Anonymous
Session J1:  OutsourcingCCS’17, October 30-November 3, 2017, Dallas, TX, USA2102[17]
[16]
Payments from Bitcoin. In 2014 IEEE Symposium on Security and Privacy, SP 2014,
Berkeley, CA, USA, May 18-21, 2014. 459–474.
[8] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. 2013. On
the concrete e(cid:28)ciency of probabilistically-checkable proofs. In Symposium on
Theory of Computing Conference, STOC’13, Palo Alto, CA, USA, June 1-4, 2013.
585–594.
Interactive
[9] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. 2016.
Oracle Proofs. In TCC. 31–60.
[10] Eli Ben-Sasson, Matan Hamilis, Mark Silberstein, and Eran Tromer. 2016. Fast
Multiplication in Binary Fields on GPUs via Register Cache. In Proceedings of the
2016 International Conference on Supercomputing, ICS 2016, Istanbul, Turkey, June
1-3, 2016. 35:1–35:12.
[11] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. 2013. Recursive
composition and bootstrapping for SNARKS and proof-carrying data. In STOC.
111–120.
[12] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth.
2013. Succinct Non-interactive Arguments via Linear Interactive Proofs. In TCC.
315–333.
[13] Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ra-
macher, Christian Rechberger, Daniel Slamanig, and Greg Zaverucha. 2017. Post-
Quantum Zero-Knowledge and Signatures from Symmetric-Key Primitives. IACR
Cryptology ePrint Archive 2017 (2017), 279.
[14] Hao Chen and Ronald Cramer. 2006. Algebraic Geometric Secret Sharing Schemes
and Secure Multi-Party Computations over Small Fields. In CRYPTO. 521–536.
[15] Graham Cormode, Michael Mitzenmacher, and Justin Thaler. 2012. Practical
veri(cid:27)ed computation with streaming interactive proofs. In ITCS. 90–112.
Ivan Damgård and Yuval Ishai. 2006. Scalable Secure Multiparty Computation.
In CRYPTO. 501–520.
Ivan Damgård, Yuval Ishai, and Mikkel Krøigaard. 2010. Perfectly Secure Mul-
tiparty Computation and the Computational Overhead of Cryptography. In
EUROCRYPT. 445–465.
[18] George Danezis, Cédric Fournet, Markulf Kohlweiss, and Bryan Parno. 2013.
Pinocchio coin: building zerocoin from a succinct pairing-based proof system.
In PETShop’13, Proceedings of the 2013 ACM Workshop on Language Support for
Privacy-Enhancing Technologies, Co-located with CCS 2013, November 4, 2013,
Berlin, Germany. 27–30.
[19] Amos Fiat and Adi Shamir. 1986. How to Prove Yourself: Practical Solutions to
Identi(cid:27)cation and Signature Problems. In CRYPTO. 186–194.
Finite Fields. IEEE Trans. Inf. Theor. 56, 12 (Dec. 2010), 6265–6272.
[21] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. 2013. Qua-
dratic Span Programs and Succinct NIZKs without PCPs. In EUROCRYPT. 626–
645.
Irene Giacomelli, Jesper Madsen, and Claudio Orlandi. 2016. ZKBoo: Faster
Zero-Knowledge for Boolean Circuits. In USENIX. 1069–1083.
[23] Sha(cid:27) Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. 2015. Delegating
Computation: Interactive Proofs for Muggles. J. ACM 62, 4 (2015), 27:1–27:64.
[24] Sha(cid:27) Goldwasser, Silvio Micali, and Charles Racko(cid:29). 1985. The Knowledge
Complexity of Interactive Proof-Systems (Extended Abstract). In STOC. 291–
304.
[25] Vipul Goyal, Yuval Ishai, Mohammad Mahmoody, and Amit Sahai. 2010. In-
teractive Locking, Zero-Knowledge PCPs, and Unconditional Cryptography. In
CRYPTO. 173–190.