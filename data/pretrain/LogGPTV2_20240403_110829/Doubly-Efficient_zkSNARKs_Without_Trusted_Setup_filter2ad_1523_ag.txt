graphic operations proportional to M. Hyrax has lower P time
than these systems because it uses cryptographic operations only
for P’s messages in Gir++ and for w (§4–§6).
• The provers in both BCCGP-sqrt and Bulletproofs ran out of
memory for the largest benchmarks (Figs. 2b and 2h) despite
having twice as much RAM as Hyrax (“Testbed,” above). This is
because they operate, roughly speaking, over all wire values in the
AC at once. In contrast, Hyrax’s P works layer-by-layer (§3.2).10
• Hyrax’s P is more expensive than either ZKB++’s or Ligero’s,
because those systems do not use any public-key cryptography.
• While Ligero’s P is asymptotically more costly than Hyrax’s
P, this is not apparent at the problem sizes we consider.
• libSTARK’s P is 12–40× more expensive than Hyrax’s for
these problem sizes. It is also memory intensive: for the largest
problem, it exceeded available RAM despite having twice as
much as Hyrax (“Testbed,” above).
• Hyrax’s reﬁnements compared to Hyrax-naive (§5–6) yield a
constant factor lower P cost, at most ≈3×.
V time (Fig. 2c, 2f, 2i):
• For matrix factoring, Hyrax’s V bottleneck is sum-check
invocations for small N, and ˜Vy evaluation for large N (§3.2). The
RDL (§6.2) dominates V’s costs in the other two benchmarks.
• Hyrax’s V cost is lower than BCCGP-sqrt for large enough
problems: the latter requires O(M) ﬁeld operations.
• Hyrax’s V cost is much less than Bulletproofs’s: the latter
requires a multi-exponentiation of length 2M (which can be
computed using O(M/log M) cryptographic operations [83]).
• ZKB++ has veriﬁcation cost linear in the problem size, so
Hyrax wins on large enough problems.
• Ligero’s V amortizes its bottleneck computation over repeated
SHA-256 instances [1, §5.4], so over this range of problem sizes
it has sublinear scaling and concretely fast veriﬁcation time.
• libSTARK’s V has the best asymptotics among all systems
and extremely low concrete costs.
• Hyrax-naive requires cryptographic operations proportional
to |w|; Hyrax’s reﬁnements give more than 100× savings.
8.2 Eﬀect of trading V runtime for smaller proofs
Method. We run the Merkle tree benchmark using the same
setup as in Section 8.1, except that we vary the size of P’s witness
commitment (§6.1). We experiment with commitments of size
log |w|, |w|1/3, and |w|1/2. V’s witness-related work at these three
settings is O(|w|), O(|w|2/3), and O(|w|1/2), respectively.
Results. Figure 3 shows proof size and runtime for the speciﬁed
commitment sizes. For Hyrax-1/2, proof sizes are large but P and
V runtimes are small; Hyrax-log is the opposite. Hyrax-1/3 has
similar runtimes to Hyrax-1/2: P’s costs are dominated by Gir++,
V’s by the RDL (§6.2). Meanwhile, its proof sizes are not much
larger than Hyrax-log, because the Gir++-related proof costs are
the same in both cases, and because the constants hidden in the
asymptotic notation mean that the log and cube-root protocols
10It is probably possible to engineer the BCCGP-sqrt and Bulletproofs provers
to reduce memory requirements, e.g., by streaming from disk. We attempted a
standard approach—paging memory to an array of fast SSDs—but this caused
thrashing and dramatically worsened runtimes.
937
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:29:14 UTC from IEEE Xplore.  Restrictions apply. 
Hyrax-1/3
Hyrax-1/2
Hyrax-log
B
k
i
,
e
z
i
s
f
o
o
r
p
)
r
e
t
t
e
b
s
i
r
e
w
o
l
(
130
110
90
75
60
Hyrax-1/3
Hyrax-1/2
Hyrax-log
s
d
n
o
c
e
s
,
e
m
i
t
r
e
v
o
r
p
)
r
e
t
t
e
b
s
i
r
e
w
o
l
(
104
103
100
10
Hyrax-1/3
Hyrax-1/2
Hyrax-log
s
d
n
o
c
e
s
,
e
m
i
t
r
e
ﬁ
i
r
e
v
)
r
e
t
t
e
b
s
i
r
e
w
o
l
(
100
10
1
2
8
log2 M, number of leaves in Merkle tree
(a) Proof size: SHA-256 Merkle tree
4
6
2
8
log2 M, number of leaves in Merkle tree
(b) P time: SHA-256 Merkle tree
4
6
2
8
log2 M, number of leaves in Merkle tree
(c) V time: SHA-256 Merkle tree
4
6
Figure 3—Proof size and P and V runtime for diﬀerent sizes of P’s witness commitment (§6.1; §8.2). Hyrax-1/2 has commitment size |w|1/2,
Hyrax-1/3 has commitment size |w|1/3, and Hyrax-log has commitment size log |w|. Hyrax-1/2 gives the largest proofs but has the fastest runtimes.
Hyrax-log gives the smallest proofs but has the longest runtimes. Hyrax-1/3 gets essentially the best of both for this application.
have similar concrete costs at these problem sizes. In other words,
Hyrax-1/3 gets very nearly the best of both worlds.
8.3 Discussion
Our results show that Hyrax is competitive with the baselines,
and that the reﬁnements of Sections 5 and 6 give substantial im-
provements. Hyrax gives smaller proofs than all but Bulletproofs,
which pays for its smaller proofs with very high computational
costs. Meanwhile, for problem sizes of practical interest, only
Ligero is faster for both P and V; ZKB++ has faster P but often
slower V; libSTARK has faster V but much slower P; and all
three systems produce larger proofs than Hyrax.
On the other hand, there are several limitations to this analysis.
First, because Gir++ is geared to data-parallel computations (§3.2;
Thm. 1), Hyrax is competitive with prior work primarily when
computations contain suﬃcient parallelism or are amenable to
batching; this is evident in the way Hyrax’s performance relative
to the baselines improves as parallelism increases in Figure 2.
While an RDL (§6.2) lets Hyrax take advantage of parallelism
within one computation (as it did in the Merkle tree and image
scaling benchmarks), not all applications ﬁt these paradigms.
Moreover, the RDL is asymptotically and concretely costly for
V; eliminating this bottleneck is future work.
Second, we compare ZKB++, Ligero, and libSTARK only
on the SHA-256 Merkle tree benchmark. This makes sense for
ZKB++ because it is geared to Boolean circuits, where SHA-256
is a natural benchmark; similarly, Ligero’s primary evaluation is
on SHA-256 [1, §6]. For libSTARK, however, a hash function
that is more eﬃcient in F264 would improve performance [11,
Fig. 4]; future work is to compare Hyrax and all baselines on
Merkle trees using hash functions tailored to each system (e.g.,
[11, Appx. E; 15, §5.2; 29, §3.2]). Furthermore, Ligero and
libSTARK can in principle work over large ﬁelds, but the current
implementations do not [11, 101], so we could not evaluate on
matrix factoring or image scaling; future work is to do so.11
Third, our comparison does not consider multi-threaded per-
formance because, to our knowledge, libSTARK is the only
baseline with a multi-threaded implementation [11, 67]. Prior
work [99, 103, 104] suggests that Gir++ is highly parallelizable;
exploring this in Hyrax is future work.
11We note that, since Hyrax’s proof size is primarily due to witness size |w|
rather than arithmetic circuit size |C|, we expect it to outperform Ligero on
applications like matrix factoring where |w| (cid:18) |C|.
Finally, our comparison does not consider argument systems
like libsnark [16, 66] that require trusted setup and non-standard,
non-falsiﬁable assumptions (§2, paragraph 2); Hyrax’s goal is
to avoid these requirements. Ignoring this, Hyrax’s proofs are
bigger: libsnark’s proofs are a constant ≈300-bytes, independent
of the AC C. Hyrax’s P cost is concretely and asymptotically
smaller: libsnark has a logarithmic overhead in |C|, and it re-
quires cryptographic operations per AC gate, while Hyrax’s P is
essentially linear in computation size and requires cryptographic
operations only for P’s Gir++ messages and for w (§4–§6). For
V, libsnark’s oﬄine setup is very expensive [105, §5.4], and it
must be performed by V or someone V trusts; but libsnark’s
online V costs are essentially always cheaper than Hyrax’s (and
roughly comparable to libSTARK’s, in practice).
9 Conclusion
We have described a succinct zero-knowledge argument for NP
with no trusted setup and low concrete cost for both the prover and
the veriﬁer, based on standard cryptographic assumptions. This
scheme is practical because it tightly integrates three components:
a state-of-the-art interactive proof (IP), which we tweak to reduce
communication complexity; a highly optimized transformation
from IPs to zero-knowledge arguments following the approach
of Ben-Or et al. [8] and Cramer and Damgård [37]; and a
new cryptographic commitment scheme tailored to multilinear
polynomials that adapts prior work [30, 52] to allow a sender
to commit to a log G-variate multilinear polynomial and later
to open it at one point, with O(G1/ι) total communication and
O(G(ι−1)/ι) receiver runtime for any ι ≥ 2. A careful comparison
with prior work shows that our argument system is competitive
on both proof size and computational costs. Key future work is
to further reduce proof size without increasing veriﬁer runtime.
More broadly, ours and other recent work [108–110] suggest
that the applicability of the GKR interactive proof [49] has
been underestimated. In particular, GKR seemingly requires
deterministic arithmetic circuits, and saves work for the veriﬁer
(relative to computing the circuit) only when those circuits have
low depth. Zhang et al. sidestep these issues, extending GKR
to non-deterministic, low-depth computations [108] and more
recently to arbitrary RAM programs [110], in both cases saving
work asymptotically for the veriﬁer. But even those enhanced
protocols fall short of state-of-the-art work-saving zkSNARKs [4,
5, 12, 13, 15, 16, 29, 34, 36, 39, 42–44, 64, 76, 79, 105], because
938
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:29:14 UTC from IEEE Xplore.  Restrictions apply. 
they fail to address zero-knowledge applications. This work (and
concurrent work by Zhang et al. [109]) closes that gap—and, in
our view, attests to the power and versatility of the GKR protocol.
[21] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and O. Paneth. Succinct
non-interactive arguments via linear interactive proofs. In IACR TCC,
Mar. 2013.
[22] M. Blum. How to prove a theorem so no one else can claim it. In ICM,
Aug. 1986.
[23] M. Blum, W. Evans, P. Gemmell, S. Kannan, and M. Naor. Checking the
correctness of memories. In FOCS, Oct. 1991.
[24] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. Eﬃcient
zero-knowledge arguments for arithmetic circuits in the discrete log
setting. In EUROCRYPT, Apr. 2016.
[25] J. Bootle, A. Cerulli, E. Ghadaﬁ, J. Groth, M. Hajiabadi, and S. Jakobsen.
Linear-time zero-knowledge proofs for arithmetic circuit satisﬁability. In
ASIACRYPT, Dec. 2017.
[26] J. Bootle and J. Groth. Eﬃcient batch zero knowledge arguments for low
degree polynomials. In PKC, Mar. 2018.
[27] X. Boyen and B. Waters. Compact group signatures without random
[28] X. Boyen and B. Waters. Full-domain subgroup hiding and constant-size
oracles. In EUROCRYPT, May 2006.
group signatures. In PKC, Apr. 2007.
[29] B. Braun, A. J. Feldman, Z. Ren, S. Setty, A. J. Blumberg, and
M. Walﬁsh. Verifying computations with state. In SOSP, Nov. 2013.
[30] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell.
Bulletproofs: Eﬃcient range proofs for conﬁdential transactions. In IEEE
S&P, May 2018.
[31] Cﬃ. https://bitbucket.org/cffi/cffi.
[32] M. Chase, D. Derler, S. Goldfeder, C. Orlandi, S. Ramacher,
C. Rechberger, D. Slamanig, and G. Zaverucha. Post-quantum