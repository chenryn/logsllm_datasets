  Test	
  the	
  classiﬁer	
  with	
  the	
  new	
  sample	
  No	
  Yes	
  Is	
  the	
  sample	
  labeled	
  Malicious?	
  Yes	
  End	
  No	
  Start	
  Malicious	
  Region	
  Benign	
  Region	
  Decision	
  Boundary	
  Benign Sample!Malicious Sample!Figure 7: Diﬀerences between the beginning of the
trees in benign and malicious sample
Figure 8: An example of a PDF embedded object
tion object is changed from 176 to 182. Those two objects
are usually related to actions such as code execution or, for
benign ﬁles, the ﬁlling of a form. Needless to say, the pres-
ence of these objects make the ﬁle more suspicious, but it
does not constitute a proof of maliciousness by itself. Figure
7 better explains the changes introduced by the new version
to the logical tree.
Object 182 contains the JavaScript keyword, which au-
tomatically 4 triggers a launch action on the embedded ﬁle,
described by the keyword EmbeddedFiles, which is ﬁnally
contained inside the stream 181. This is also known as the
CVE-2010-1240 vulnerability, and it was discovered by Di-
dier Stevens. Mr. Stevens has also implemented a way to
make an application be launched inside a PDF without us-
ing JavaScript [35]. It is not important to explain any single
detail of how the vulnerability can be exploited. The reason
why this vulnerability is interesting, although not being very
recent (indeed, this attack will not work on Adobe Reader
X), is that it is a clear (and concrete, as we have generated
real samples) proof-of-concept of the eﬀectiveness of the re-
verse mimicry attack.
5.3.2 PDF Embedding
A limit of the attack we have just described is that it is
related to an old vulnerability, and therefore, even if it is
able to evade structural analysis techniques, it might not
work in patched Adobe Reader versions (speciﬁcally, after
the 9.3). However, the PDF standard supports the embed-
ding of other ﬁle formats apart from the EXE one (whose
automatic execution is currently banned by Adobe). In par-
ticular, the most interesting format is the PDF one itself. In-
deed, it is possible to embed a PDF ﬁle inside another one, so
that the embedded ﬁle is automatically opened without user
interaction. Therefore, it is possible to embed a malicious
ﬁle inside a benign one. Interestingly for our purposes, there
are no restrictions on the ﬁle that can be embedded: it can
contain JavaScript, Flash code, etc. Such samples can be
automatically built using the embedding function provided
by the PeePDF tool [7]. To improve the obfuscation of an
embedded ﬁle, PeePDF can embed the ﬁle in a compressed
stream. This means that, in order to retrieve the features of
the embedded ﬁle, the parser should be able to decompress
the stream by applying the correct ﬁlter. This can give a
strong advantage against raw parsers which do not decom-
press objects contained inside a PDF ﬁle. Figure 8 shows
4That is, without user interaction.
an example of a typical PDF ﬁle embedded object. As it
can be seen, the keyword EmbeddedFile (along with some
others) is added to the carrier ﬁle. This is a clear marker
that an embedded ﬁle is contained inside the carrier. Again,
the presence of such a keyword may make the ﬁle more sus-
picious, but it does not constitute a proof of maliciousness
by itself. The couple of keys Filter and FlateDecode, fol-
lowed by the stream, means that the embedded object is
compressed with the FlateDecode ﬁlter. This simple ap-
proach may completely bypass simple parsers such as PdfID
[5], that are not able to decompress object streams. There-
fore, accurate parsers are fundamental in order to retrieve
useful information about embedded content. Even if a parser
is able to decompress object streams, embedding a PDF ﬁle
allows a ﬁne-grain control on the structural features of the
carrier ﬁle. For example, we can carefully choose what struc-
tural features are injected, depending also on the vulnera-
bility that is exploited by the malicious sample.
In other
terms, PDF embedding allows devising reverse mimicry at-
tacks that exploit a wide spectrum of vulnerabilities, even
those that aﬀect the latest versions of PDF readers.
JavaScript Injection
5.3.3
Most of malicious PDF ﬁles adopt JavaScript code [24] to
exploit vulnerabilities in the reader application. Smutz et
al. showed that there are basically two types of JavaScript
code that can be used: one type that, along with the code
to exploit the vulnerability, includes the payload used for the
attack and the other one that relies to other objects in the
ﬁle, or to external malicious links, to download malicious
code [33]. The best way to perform a reverse mimicry at-
tack is to encapsulate a malicious JavaScript code that does
not contain references to other objects. This is because only
one object will be added to the PDF tree and, consequently,
a minimum variation over the structure of the root (benign)
ﬁle is introduced. Furthermore, a single object addition is
much faster and more feasible for an attacker than a com-
plicated obfuscation process. An interesting characteristic
of JavaScript injection is that no new version is added: the
whole tree is completely rewritten. This causes little mod-
iﬁcations in the reference to the tree structure: the whole
structure is substantially the same, and this leads to little
variations of the PDF pattern in the feature space. Figure
9 shows an example of this speciﬁc attack, that can be eas-
ily built using speciﬁc Python libraries [14]. As it can be
seen, a JavaScript object is added, and the JavaScript code
Version 0: Figure 9: An example of an injected JavaScript ob-
ject and how the Catalog object is changed conse-
quently
Figure 10: A conceptual representation of the layers
is inserted after the JS keyword (the one in the Figure was
cut for space reason). It is also possible to observe how the
Catalog object is changed. The reference marked by 93 0
R has been added in order for the code to be executed in-
dependently from the presence of other objects within the
PDF ﬁle.
5.4 Systems Weaknesses
The reason why the reverse mimicry, along with its vari-
ants, is so eﬀective against Machine Learning systems, is
easily deducible by observing the parts of the PDF ﬁle on
which the detection systems focus. Figure 10 shows a con-
ceptual representation of the layers on which systems such as
PJScan, Malware Slayer and PDFRate calibrate their anal-
ysis.
Generally speaking, we can distinguish three types of lay-
ers:
• Standard Objects (STO) Layer: objects that are not
related to external actions (such as execution of code).
Figure 11: An example of evasion of systems that
extract features from STO and SUO layers
They can, however, contain references to suspicious or
malicious objects.
• Suspicious Objects (SUO) Layer: objects that are re-
lated to external actions (such as code execution, forms,
etc.). In this category there are objects that can con-
tain, for example, keywords such as Acroform, Names,
JavaScript, etc.
• Malicious code or Embedded Files (CE) Layer: this
layer describes codes or embedded ﬁles contained inside
suspicious objects.
It is the point in which the real
attack is contained, therefore, in this representation,
it is considered the most internal layer.
Malware Slayer [26] only extracts information from the
STO and the SUO layers. The injection, for example, of Java-
Script, introduces small changes in both layers. The clas-
siﬁer can see this variation in terms of suspicious objects.
However, objects in SUO layer do not necessarily contain
malicious code.
Indeed, if there is a code inside the sus-
picious object, it might also be benign. Therefore, there
might be a benign ﬁle with a suspicious distribution of the
objects in the STO and SUO layers. Now, let us consider
a malicious and a benign JavaScript code: suppose that
these codes are injected inside the same PDF ﬁle, therefore
obtaining two ﬁles, one malicious and one benign. Given a
set of features related to STO and SUO layers only, the two
ﬁles would be indistinguishable from each other. Figure 11
shows a graphical representation of this behavior.
Of course, the same approach is valid when an embedded
ﬁle is used instead of code. PJScan [24], on the contrary,
does not suﬀer from this issue, as its features are mainly ex-
tracted from the CE layer. However, the tool only analyzes
JavaScript code, and therefore it could be easily evaded by
a sample carrying other malicious content, such as Action-
Script code, EXE Payloads, etc.
6. EXPERIMENTAL EVALUATION
To assess the eﬃcacy of reverse mimicry attacks, we im-
plemented the three attack variants presented in Section 5.3,
  “Standard”	
  Objects	
  (STO)	
  Layer	
  “Suspicious”	
  Objects	
  (SUO)	
  Layer	
  Code	
  Or	
  Embedded	
  Files	
  (CE	
  Layer)	
  Malicious	
  Code	
  Benign	
  Code	
  PDF	
  FILE	
  A	
  PDF	
  FILE	
  A	
  PDF	
  FILE	
  B	
  INJECTION	
  PROCESS	
  INJECTION	
  PROCESS	
  PDF	
  FILE	
  M	
  CLASSIFIER	
  SAME	
  LABEL	
  AS	
  FILE	
  M	
  SAME	
  LABEL	
  AS	
  FILE	
  B	
  Table 1: Eﬃcacy of EXEembed, PDFembed, JSinject evasion techniques against six PDF malware detection tools
Detector
PJScan
PDFRate Contagio
PDFRate George Mason
PDFRate Community
Malware Slayer
Wepawet
EXEembed
evaded (-/.317)
evaded (.002/.069)
evaded (0/.162)
evaded (.001/.2)
evaded (0/.08)
-
PDFembed
evaded (-/-)
evaded (0/.008)
evaded (0/0)
evaded (.008/.024)
evaded (0/0)
-
JSinject
detected (-/.905)
evaded (0/.148)
evaded (0/.013)
evaded (0/.125)
evaded (0/.08)
-
namely, EXE Payload embedding —EXEembed—, PDF em-
bedding —PDFembed—, JavaScript injection —JSinject—
and tested them against various PDF malware detectors pro-
posed so far, namely, Wepawet (online tool) [10], PJScan [24],
Malware Slayer [26] and PDFRate [33]. More precisely, we
tested three online versions of PDFRate diﬀering each other
on the data source employed for training: Contagio, George
Mason and Community version5.
PJScan and Malware Slayer have been trained on a data-
set composed by 5993 malicious samples retrieved from the
Contagio repository [1], that is, the same data source em-
ployed by PDFRate Contagio. For Malware Slayer, 5591
benign ﬁles collected automatically using the Yahoo search
API [42] have also been adopted. Each attack variant has
been built starting from a randomly-chosen benign ﬁle6, that
we call as root. In particular we built the attacks as follows:
• EXEembed: we embedded a Zeus EXE payload which
implements a simple type of compression;
• PDFembed: we embedded a PDF ﬁle containing malicious
JavaScript code that implements the CVE-2009-4324
vulnerability. The embedded ﬁle is opened automat-
ically (without user interaction) as soon as the root
ﬁle is opened.
• JSinject: we injected the same JavaScript code em-
ployed for PDFembed in the root ﬁle; we recall that this
task does not require an addition of a version on the
ﬁle.
For each PDF malware detector we veriﬁed that such a
root ﬁle was indeed correctly labelled as benign. For those
detectors that provide also a maliciousness score, we com-
puted how much such score changed before and after the
attack implementation, i.e., we computed the score of the
root ﬁle, as well as the score of the PDF attack instance
built upon it. This task allowed us to evaluate the sen-
sitivity of each detector with respect to a certain evasion
technique.
Table 1 shows a summary of evasion results. For each
detector we indicate whether an evasion attack is successful
(evaded, in bold) or not (detected). Between parentheses,
5More details are available at https://www.csmutz.com/
pdfrate/data.
6We performed this operation multiple times, with diﬀer-
ent benign ﬁles.
In all runs, we were able to get the
same results in terms of evasion success (with slightly dif-
ferent score). For simplicity, we report only the results
attained by attacks built in the ﬁrst run. Such reverse
mimicry attacks, together with the associated root ﬁles, can
be downloaded at https://dl.dropbox.com/u/65430791/
ASIACCSSamples.zip. Open them at your own risk!
when available, we indicate root and attack score, sepa-
rated by a /. The maliciousness score ranges from 0 to 1,
and an ideal detector should assign high values for attack in-
stances and very low values to benign samples. As it can be
seen from Table 1, the reverse mimicry attacks are incred-
ibly eﬀective against all PDF detectors. Almost all PDF
detectors assign a relatively low score to the three attack
instances, and are thus successfully evaded. More precisely,
all detectors which adopt structural analysis, i.e., PDFRate
and Malware Slayer are successfully evaded, whereas PJS-
can is evaded by both EXEembed and PDFembed, but it is able
to detect JSinject. In fact, this behavior is quite reason-
able, because as explained in Section 5, PJScan operates at
the CE layer, and therefore its features are not inﬂuenced by
the structural injection operated by reverse mimicry attacks.