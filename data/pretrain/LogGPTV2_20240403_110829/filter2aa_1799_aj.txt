Physically in service:  Y  .  .  .  .  .  .  .  .  Y  Y  Y  .  .  .  .
Physically masked:
Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y
Physically requested:   Y  .  .  .  .  .  .  .  .  Y  Y  Y  .  .  .  .
Level Triggered:
.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
!apic command on a system running with Hyper-V enabled, which 
you can see due to the presence of the SINTI
Controller (SynIC), described in Chapter 9. Note that during local kernel debugging, this com-
mand shows the APIC associated with the current processor—in other words, whichever proces-
at a crash dump or remote system, you can use the ~ (tilde) command followed by the processor 
number to switch the processor of whose local APIC you want to see. In either case, the number 
next to the ID: label will tell you which processor you are looking at.
lkd> !apic
Apic (x2Apic mode)  ID:1 (50014)  LogDesc:00000002  TPR 00
TimeCnt: 00000000clk  SpurVec:df  FaultVec:e2  error:0
Ipi Cmd: 00000000`0004001f  Vec:1F  FixedDel    Dest=Self
edg high
Timer..: 00000000`000300d8  Vec:D8  FixedDel    Dest=Self
edg high
m
Linti0.: 00000000`000100d8  Vec:D8  FixedDel    Dest=Self
edg high
m
Linti1.: 00000000`00000400  Vec:00  NMI         Dest=Self
edg high
Sinti0.: 00000000`00020030  Vec:30  FixedDel    Dest=Self
edg high
Sinti1.: 00000000`00010000  Vec:00  FixedDel    Dest=Self
edg high
m
Sinti2.: 00000000`00010000  Vec:00  FixedDel    Dest=Self
edg high
m
Sinti3.: 00000000`000000d1  Vec:D1  FixedDel    Dest=Self
edg high
Sinti4.: 00000000`00020030  Vec:30  FixedDel    Dest=Self
edg high
Sinti5.: 00000000`00020031  Vec:31  FixedDel    Dest=Self
edg high
Sinti6.: 00000000`00020032  Vec:32  FixedDel    Dest=Self
edg high
Sinti7.: 00000000`00010000  Vec:00  FixedDel    Dest=Self
edg high
m
Sinti8.: 00000000`00010000  Vec:00  FixedDel    Dest=Self
edg high
m
Sinti9.: 00000000`00010000  Vec:00  FixedDel    Dest=Self
edg high
m
Sintia.: 00000000`00010000  Vec:00  FixedDel    Dest=Self
edg high
m
Sintib.: 00000000`00010000  Vec:00  FixedDel    Dest=Self
edg high
m
Sintic.: 00000000`00010000  Vec:00  FixedDel    Dest=Self
edg high
m
Sintid.: 00000000`00010000  Vec:00  FixedDel    Dest=Self
edg high
m
Sintie.: 00000000`00010000  Vec:00  FixedDel    Dest=Self
edg high
m
Sintif.: 00000000`00010000  Vec:00  FixedDel    Dest=Self
edg high
m
TMR: 95, A5, B0
IRR: 
ISR: 
38 
CHAPTER 8 System mechanisms
The various numbers following the Vec labels indicate the associated vector in the IDT with 
Interrupt Processor Interrupt (IPI) vector, and interrupt number 0xE2 handles APIC errors. Going 
back to the !idt
Interrupt (meaning that an IPI was recently used to send an APC from one processor to another), 
The following output is for the !ioapic
IRQ 9 (the System Control Interrupt, or SCI) is associated with vector B0h, which in the !idt output 
from the earlier experiment was associated with ACPI.SYS.
0: kd> !ioapic 
Controller at 0xfffff7a8c0000898 I/O APIC at VA 0xfffff7a8c0012000 
IoApic @ FEC00000  ID:8 (11)  Arb:0 
Inti00.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m 
Inti01.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m 
Inti02.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m 
Inti03.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m 
Inti04.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m 
Inti05.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m 
Inti06.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m 
Inti07.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m 
Inti08.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m 
Inti09.: ff000000`000089b0  Vec:B0  LowestDl  Lg:ff000000
lvl high
Inti0A.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m 
Inti0B.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m  
Software interrupt request levels (IRQLs)
Although interrupt controllers perform interrupt prioritization, Windows imposes its own interrupt 
priority scheme known as interrupt request levels (IRQLs). The kernel represents IRQLs internally as a 
number from 0 through 31 on x86 and from 0 to 15 on x64 (and ARM/ARM64), with higher numbers 
Interrupts are serviced in priority order, and a higher-priority interrupt preempts the servicing of 
a lower-priority interrupt. When a high-priority interrupt occurs, the processor saves the interrupted 
-
saved machine state. The interrupted thread resumes executing where it left off. When the kernel low-
ers the IRQL, lower-priority interrupts that were masked might materialize. If this happens, the kernel 
repeats the process to handle the new interrupts.
The various numbers following the Vec labels indicate the associated vector in the IDT with 
Vec labels indicate the associated vector in the IDT with 
Vec
Interrupt Processor Interrupt (IPI) vector, and interrupt number 0xE2 handles APIC errors. Going 
back to the !idt
Interrupt (meaning that an IPI was recently used to send an APC from one processor to another), 
The following output is for the !ioapic
IRQ 9 (the System Control Interrupt, or SCI) is associated with vector B0h, which in the !idt output 
from the earlier experiment was associated with ACPI.SYS.
0: kd> !ioapic
Controller at 0xfffff7a8c0000898 I/O APIC at VA 0xfffff7a8c0012000
IoApic @ FEC00000  ID:8 (11)  Arb:0
Inti00.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m
Inti01.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m
Inti02.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m
Inti03.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m
Inti04.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m
Inti05.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m
Inti06.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m
Inti07.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m
Inti08.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m
Inti09.: ff000000`000089b0  Vec:B0  LowestDl  Lg:ff000000
lvl high
Inti0A.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m
Inti0B.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000
edg high
m  
CHAPTER 8 System mechanisms
39
x86
Hardware
interrupts
Software
interrupts
Normal thread
execution
High
Power fail
Interprocessor interrupt
Clock
Profile/Synch
Device n
•
•
•
Corrected Machine Check Interrupt
Device 1
DPC/dispatch
APC
Passive/Low
•••
31
30
29
28
27
26
5
4
3
2
1
0
x64
•••
15
14
13
12
11
4
3
2
1
0
High/Profile
Interprocessor interrupt/Power
Clock
Synch
Device n
Device 1
Dispatch/DPC
APC
Passive/Low
FIGURE 8-13 x86 and x64 interrupt request levels (IRQLs).
IRQL priority levels have a completely different meaning than thread-scheduling priorities (which 
are described in Chapter 5 of Part 1). A scheduling priority is an attribute of a thread, whereas an IRQL 
is an attribute of an interrupt source, such as a keyboard or a mouse. In addition, each processor has an 
IRQL setting that changes as operating system code executes. As mentioned earlier, on x64 systems, 
the IRQL is stored in the CR8 register that maps back to the TPR on the APIC.
-
by calling KeRaiseIrql and KeLowerIrql or, more commonly, indirectly via calls to functions that acquire 
the current level interrupt the processor, whereas interrupts from sources with IRQLs equal to or be-
low the current level are masked until an executing thread lowers the IRQL.
Interrupts masked on
Processor A
Interrupts masked on
Processor B
Processor B
Processor A
IRQL setting
•••
High/Profile
Interprocessor interrupt/Power
Clock
Synch
Device n
Device 1
Dispatch/DPC
APC
Passive/Low
IRQL = DPC/dispatch
IRQL = Clock
FIGURE 8-14 Masking interrupts.
40 
CHAPTER 8 System mechanisms
-
-
rupt source. This elevation masks all interrupts at and below that IRQL (on that processor only), which 
lower level. The masked interrupts are either handled by another processor or held back until the IRQL 
drops. Therefore, all components of the system, including the kernel and device drivers, attempt to 
keep the IRQL at passive level (sometimes called low level). They do this because device drivers can re-
periods. Thus, when the system is not performing any interrupt work (or needs to synchronize with it) 
or handling a software interrupt such as a DPC or APC, the IRQL is always 0. This obviously includes any 
-
fects on system operation. In fact, returning to a user-mode thread with the IRQL above 0 results in an 
immediate system crash (bugcheck) and is a serious driver bug.
another due to preemption—run at IRQL 2 (hence the name dispatch level), meaning that the proces-
sor behaves in a single-threaded, cooperative fashion at this level and above. It is, for example, illegal to 
wait on a dispatcher object (more on this in the “Synchronization” section that follows) at this IRQL, as 
a context switch to a different thread (or the idle thread) would never occur. Another restriction is that 
only nonpaged memory can be accessed at IRQL DPC/dispatch level or higher. 
resident results in a page fault. When a page fault occurs, the memory manager initiates a disk I/O and 
the scheduler to perform a context switch (perhaps to the idle thread if no user thread is waiting to 
level or higher at the time of the disk read). A further problem results in the fact that I/O completion 
complete because the completion APC would not get a chance to run.
If either of these two restrictions is violated, the system crashes with an IRQL_NOT_LESS_OR_EQUAL 
or a DRIVER_IRQL_NOT_LESS_OR_EQUAL crash code. (See Chapter 10, “Management, diagnostics, and 
tracing” for a thorough discussion of system crashes.) Violating these restrictions is a common bug in 
type of bug.
Conversely, this also means that when working at IRQL 1 (also called APC level), preemption is still 
active and context switching can occur. This makes IRQL 1 essentially behave as a thread-local IRQL 
instead of a processor-local IRQL, since a wait operation or preemption operation at IRQL 1 will cause 
KTHREAD structure, as seen 
thread at passive level (IRQL 0) can still preempt a thread running at APC level (IRQL 1), because below 
IRQL 2, the scheduler decides which thread controls the processor.
CHAPTER 8 System mechanisms
41