```shell
echo "vm.overcommit_memory=1" > /etc/sysctl.conf  # 或 vi /etcsysctl.conf , 然后reboot重启机器
echo 1 > /proc/sys/vm/overcommit_memory  # 不需要启机器就生效
```
2. WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
```shell
echo 511 > /proc/sys/net/core/somaxconn
```
## 更改配置
Redis 的配置文件位于 Redis 安装目录下，文件名为 `redis.conf`。上面已经将它拷贝到`/etc/redis`目录下了，配置文件在 `sudo vi /etc/redis/6380.conf` 这里可以编辑
```bash
sudo vi /etc/redis/6380.conf
```
你可以通过 CONFIG 命令查看或设置配置项。配置设置命令
```bash
## 进入redis获取
127.0.0.1:6379> CONFIG GET CONFIG_SETTING_NAME
## 进入redis设置
127.0.0.1:6379> CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE
## 获取所有配置
127.0.0.1:6379> CONFIG GET *
## 设置配置开启通知功能
$ redis-cli config set notify-keyspace-events KEA
```
## 设置请求密码
打开 `vim /etc/redis/6380.conf` 配置文件编辑它，更改下面两项内容：
```bash
# ...
# requirepass foobared
# 更改成下面内容，把 foobared 改为你想要设置的密码
requirepass 111111
# bind 127.0.0.1 去掉 # 注释并改为
bind 0.0.0.0
```
更改为之后你就可以带密码访问redis了。
```bash
redis-cli -h 127.0.0.1 -p 6379 -a 111111
```
## 主从架构配置
假设有两台服务器，一台做主，一台做从
```bash
Redis 主信息：
  IP：12.168.1.114
  端口：6379
Redis 从信息：
  IP：12.168.1.115
  端口：6379
```
编辑从机的 Redis 配置文件，找到 `# slaveof`开头的这一行应该是注释的：`# slaveof  `我们需要去掉该注释，并且填写我们自己的主机的 IP 和 端口，比如：`slaveof 192.168.1.114 6379`。
```bash
# slaveof  
# 这行更改成下面内容
slaveof 192.168.1.114 6379
```
配置完成后重启从机 Redis 服务重启完之后，进入主机的 redis-cli 状态下，输入：`INFO replication` 可以查询到当前主机的 redis 处于什么角色，有哪些从机已经连上主机。
此时已经完成了主从配置，我们可以测试下：
1. 我们进入主机的 redis-cli 状态，然后 set 某个值，比如：set mygithub jaywcjlove
2. 我们切换进入从机的 redis-cli 的状态下，获取刚刚设置的值看是否存在：get mygithub，此时，我们可以发现是可以获取到值的。
3. 但是有一个需要注意的：从库不具备写入数据能力，不然会报错。 从库只有只读能力。
## 基本操作
```bash
## 命令行客户端启动
$ redis-cli
# 测试心跳
127.0.0.1:6379> ping
PONG
# 设置 mykey 键的值
127.0.0.1:6379> set mykey hello
OK
# 获取 mykey 键的值
127.0.0.1:6379> get mykey
"hello"
## 设置 mykey 失效事件
127.0.0.1:6379> expire mykey 2
# 查看当前redis的配置信息
127.0.0.1:6379> config get *
# 获取所有的key
127.0.0.1:6379> keys *
# 删除redis当前数据库中的所有Key
127.0.0.1:6379> flushdb
127.0.0.1:6379> config get dir
# 馋哭当前库 key 的数量
127.0.0.1:6379> dbsize
# 删除所有数据库中的key
127.0.0.1:6379> flushall
# 退出
127.0.0.1:6379> exit
# 找出拖慢 Redis 的罪魁祸首
# 通过这个工具可以查看所有命令统计的快照，
# 比如命令执行了多少次，
# 执行命令所耗费的毫秒数(每个命令的总时间和平均时间)
# 只需要简单地执行 CONFIG RESETSTAT 命令就可以重置，这样你就可以得到一个全新的统计结果。
127.0.0.1:6379> commandstats
cmdstat_get:calls=78,usec=608,usec_per_call=7.79
cmdstat_setex:calls=5,usec=71,usec_per_call=14.20
cmdstat_keys:calls=2,usec=42,usec_per_call=21.00
cmdstat_info:calls=10,usec=1931,usec_per_call=193.10
```
## 支持的数据类型
### 字符串
```bash
# 启动客户端 ,存储字符串到redis.
redis> SET name forezp
OK
# 取字符串:
redis> get name 
"forezp"
```
### Hashes - 哈希值
```bash
redis > HMSET king username forezp password xxdxx age 22
redis > HGETALL king
1) "username"
2) "forezp "
3) "password "
4) "xxdxx "
5) "age "
6) "22"
```
### Lists - 列表
```bash
redis> lpush pricess kenny
(integer) 1
redis 127.0.0.1:6379> lpush pricess jolin
(integer) 2
redis 127.0.0.1:6379> lpush pricess mayun
(integer) 3
redis 127.0.0.1:6379> lrange pricess 0 10
1) "kenny"
2) "jolin"
3) "mayun"
```
### 有序集合
```bash
redis > ZADD kindom 1 redis
(integer) 1
redis> ZADD kindom 2 mongodb
(integer) 1
redis > ZADD kindom 3 mysql
(integer) 1
redis > ZADD kindom 3 mysql
(integer) 0
redis > ZADD kindom 4 mysql
(integer) 0
redis > ZRANGE kindom 0 10 WITHSCORES
1) "redis"
2) "1"
3) "mongodb"
4) "2"
5) "mysql"
6) "4"
```
## 开启通知
键空间事件通知默认被禁用，因为这个特性消耗CPU电量不是很明智。使用`redis.conf`的`notify-keyspace-events`，或者通过`CONFIG SET`来开启通知。 
```bash 
## 设置配置开启通知功能
$ redis-cli config set notify-keyspace-events KEA
## 命令行监控所有通知
$ redis-cli --csv psubscribe '__key*__:*'
Reading messages... (press Ctrl-C to quit)
"psubscribe","__key*__:*",1
```
键值说明
```bash
K     Keyspace events, published with __keyspace@__ prefix.  
E     Keyevent events, published with __keyevent@__ prefix.  
g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...  
$     String commands  
l     List commands  
s     Set commands  
h     Hash commands  
z     Sorted set commands  
x     Expired events (events generated every time a key expires)  
e     Evicted events (events generated when a key is evicted for maxmemory)  
A     Alias for g$lshzxe, so that the "AKE" string means all the events. 
```
不同命令产生的事件(Events generated by different commands) 
按照下面的清单，不同的命令产生不同类型的事件。 [Redis Keyspace Notifications](http://redis.io/topics/notifications)
- DEL 为每一个被删除的键产生一个del事件。
- RENAME 产生两个事件，为源键产生一个rename_from事件，为目标键产生一个rename_to事件。
- EXPIRE 当为键设置过期时产生一个expire事件，或者每当设置了过期的键被删除时产生一个expired事件(查看EXPIRE文档获取更多信息)。
- SORT 当STORE用于设置一个新键时产生一个sortstore事件。当结果列表为空，并且使用了STORE选项，并且已经有一个该名字的键存在，那么这个件键被删除，所以这种条件下或产生一个del事件。
- SET及其所有变种(SETEX, SETNX,GETSET) 产生set事件。但是SETEX还会产生一个expire事件。
- MSET 为每个键产生一个单独的set事件。
- SETRANGE 产生一个setrange事件。
- INCR, DECR, INCRBY, DECRBY 都产生incrby事件。
- INCRBYFLOAT 产生一个incrbyfloat事件。
- APPEND 产生一个append事件。
- LPUSH和LPUSHX 产生单个lpush事件，即使在可变情况下(even in the variadic case)。
- RPUSH和RPUSHX 产生单个rpush事件，即使在可变情况下(even in the variadic case)。