title:Off-Path TCP Exploits: Global Rate Limit Considered Dangerous
author:Yue Cao and
Zhiyun Qian and
Zhongjie Wang and
Tuan Dao and
Srikanth V. Krishnamurthy and
Lisa M. Marvel
Off-Path TCP Exploits: Global Rate Limit 
Considered Dangerous
Yue Cao, Zhiyun Qian, Zhongjie Wang, Tuan Dao, and Srikanth V. Krishnamurthy,  
University of California, Riverside; Lisa M. Marvel, United States Army Research Laboratory
 https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/cao
This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX Off-Path TCP Exploits: Global Rate Limit Considered
Dangerous
Yue Cao, Zhiyun Qian, Zhongjie Wang, Tuan Dao, Srikanth V. Krishnamurthy, Lisa M. Marvel†
University of California, Riverside, †US Army Research Laboratory
{ycao009,zhiyunq,zwang048,tdao006,krish}@cs.ucr.edu, PI:EMAIL
Abstract
In this paper, we report a subtle yet serious side chan-
nel vulnerability (CVE-2016-5696) introduced in a re-
cent TCP speciﬁcation. The speciﬁcation is faithfully
implemented in Linux kernel version 3.6 (from 2012)
and beyond, and affects a wide range of devices and
hosts.
In a nutshell, the vulnerability allows a blind
off-path attacker to infer if any two arbitrary hosts on
the Internet are communicating using a TCP connection.
Further, if the connection is present, such an off-path at-
tacker can also infer the TCP sequence numbers in use,
from both sides of the connection; this in turn allows
the attacker to cause connection termination and perform
data injection attacks. We illustrate how the attack can
be leveraged to disrupt or degrade the privacy guarantees
of an anonymity network such as Tor, and perform web
connection hijacking. Through extensive experiments,
we show that the attack is fast and reliable. On average,
it takes about 40 to 60 seconds to ﬁnish and the success
rate is 88% to 97%. Finally, we propose changes to both
the TCP speciﬁcation and implementation to eliminate
the root cause of the problem.
1
Introduction
TCP and networking stacks have recently been shown to
leak various types of information via side channels, to a
blind off-path attacker [22, 14, 12, 21, 11, 29, 5]. How-
ever, it is generally believed that an adversary cannot eas-
ily know whether any two arbitrary hosts on the Internet
are communicating using a TCP connection without be-
ing on the communication path. It is further believed that
such an off-path attacker cannot tamper with or terminate
a connection between such arbitrary hosts. In this work,
we challenge this belief and demonstrate that it can be
broken due to a subtle yet serious side channel vulnera-
bility introduced in the latest TCP speciﬁcation.
The two most relevant research efforts are the fol-
lowing: 1) In 2012, Qian et al., framed the so called
“TCP sequence number inference attack”, which can be
launched by an off-path attacker [22, 23]. However,
the attack requires a piece of unprivileged malware to
be running on the client to assist the off-path attacker;
this greatly limits the scope of the attack. 2) In 2014,
Knockel et al., identiﬁed a side channel that allows an
off-path attacker to count the packets sent between two
arbitrary hosts [21]. The limitation is that the proposed
attack requires on average, an hour of preparation time
and works at the IP layer only (cannot count how many
packets are sent over a speciﬁc TCP connection).
In this paper, we discover a much more powerful off-
path attack that can quickly 1) test whether any two arbi-
trary hosts on the Internet are communicating using one
or more TCP connections (and discover the port num-
bers associated with such connections); 2) perform TCP
sequence number inference which allows the attacker to
subsequently, forcibly terminate the connection or inject
a malicious payload into the connection. We emphasize
that the attack can be carried out by a purely off-path at-
tacker without running malicious code on the communi-
cating client or server. This can have serious implications
on the security and privacy of the Internet at large.
The root cause of the vulnerability is the introduc-
tion of the challenge ACK responses [26] and the global
rate limit imposed on certain TCP control packets. The
feature is outlined in RFC 5961, which is implemented
faithfully in Linux kernel version 3.6 from late 2012.
At a very high level,
the vulnerability allows an at-
tacker to create contention on a shared resource, i.e., the
global rate limit counter on the target system by send-
ing spoofed packets. The attacker can then subsequently
observe the effect on the counter changes, measurable
through probing packets.
Through extensive experimentation, we demonstrate
that the attack is extremely effective and reliable. Given
any two arbitrary hosts, it takes only 10 seconds to suc-
cessfully infer whether they are communicating. If there
is a connection, subsequently, it takes also only tens of
USENIX Association  
25th USENIX Security Symposium  209
1
seconds to infer the TCP sequence numbers used on the
connection. To demonstrate the impact, we perform case
studies on a wide range of applications.
The contributions of the paper are the following:
• We discover and report a serious vulnerability unin-
tentionally introduced in the latest TCP speciﬁcation
which is subsequently implemented in the latest Linux
kernel.
• We design and implement a powerful attack exploit-
ing the vulnerability to infer 1) whether two hosts are
communicating using a TCP connection; 2) the TCP
sequence number currently associated with both sides
of the connection.
• We provide a thorough analysis and evaluation of the
proposed attack. We present case studies to illustrate
the attack impact.
• We identify the root cause of the subtle vulnerability
and discuss how it can be prevented in the future. We
propose changes to the kernel implementation to elim-
inate or mitigate the side channel.
2 Background
Security was not the primary concern in the design of
TCP. There have been many security patches over the
years at both the speciﬁcation and implementation level.
Interestingly, most new speciﬁcations are well thought
out and typically improve security. Unfortunately, as we
discover, one of the most recent speciﬁcations intended
to improve security creates an even more serious vulner-
ability.
In this section, we ﬁrst present the threat model that
is being addressed in RFC 5961 and how the new spec-
iﬁcation is supposed to protect against blind in-window
attacks. In the next section, we will show that how this
speciﬁcation introduces a new vulnerability.
Threat model: As illustrated in Figure 1, a realistic
threat model for TCP is off-path attacks. There are three
hosts involved: a victim client, a victim server and an off-
path attacker. Any machine might act as the attacker in
this model as long as its ISP allows the off-path attacker
to send packets to the server with the spoofed IP address
of the victim client. Alternatively, as shown in Figure 2,
the off-path attacker is able to send packets to the client
with the spoofed IP address of the victim server.
Blind in-window attacks: Under the above threat
models, the most common attacks considered are “blind
in-window attacks” where an off-path attacker sends
spoofed TCP packets with guessed sequence numbers in
an attempt to achieve DoS or data injection attacks. To
succeed in such an attack, it is necessary to ﬁrst know
the target 4-tuple  of an
ongoing TCP connection between a client and a server 1.
Once the correct 4-tuple is known, if the guessed se-
quence number of the spoofed packet happens to fall
in the receive window, (called an in-window sequence
number), one can in fact reset or inject acceptable mali-
cious data into the connection. To be more precise, an in-
window sequence number is one that satisﬁes the follow-
ing condition, (RCV.NXT ≤ SEG.SEQ ≤ RCV.NXT +
RCV.W ND), where SEG.SEQ is the guessed sequence
number, RCV.NXT and RCV.W ND are the sequence
number of the next byte that the receiver expects to re-
ceive, and the receive window size, respectively. To carry
out a blind attack, one typically needs to blast the entire
sequence number space by sending a large sequence of
spoofed packets.
In this sequence, the sequence num-
ber of a packet is larger than that of its predecessor by a
window size.
To defend against such attacks, RFC 5961 proposes
several modiﬁcations on how TCP should process in-
coming packets, We highlight only the necessary details
below.
2.1 Mitigating the Blind Reset Attack us-
ing the SYN Bit
An attacker might tear down an existing TCP connec-
tion by injecting SYN packets (TCP packets in which the
SYN ﬂag is set). This is because a valid SYN packet will
cause the receiver to believe that the sender has restarted
and thus, the connection should be reset.
In the former (pre-RFC 5961) Linux kernel versions,
reset this connection.
an incoming SYN packet is processed as follows:
• If the sequence number is outside the valid receive
window, the receiver will send an ACK back to sender.
• If the sequence number is in-window, the receiver will
It is obvious that the attacker only needs a single SYN
packet with an in-window sequence number to reset
an ongoing TCP connection.
Instead, RFC 5961 pro-
poses modiﬁcations in processing the SYN packets as
follows:
• If a receiver sees an incoming SYN packet, regardless
of the sequence number, it sends back an ACK (re-
ferred to as a challenge ACK) to the sender to conﬁrm
the loss of the previous connection.
• If the packet is indeed initiated from the legitimate re-
mote peer, it must have truly lost the previous connec-
tion and is now attempting to initiate a new one. Upon
receiving the challenge ACK, the remote peer will
send a RST packet with the correct sequence num-
1This can be achieved, among other methods, through brute-force
attempts.
210  25th USENIX Security Symposium 
USENIX Association
2
Client
Client
Network
Network
Server
Attacker
Attacker
Challenge ACK
Window
SND.UNA – 
SND.MAX.WIN
Server
SND.UNA 
– 2G
Acceptable 
ACK Range
SND.UNA
Invalid ACK 
Range
SND.NXT
Figure 1: Threat model 1
Figure 2: Alternative threat model
Figure 3: ACK window illustration
ber (derived from the ACK ﬁeld of the challenge ACK
packet) to prove that the previous connection is indeed
terminated.
Hence, if the SYN packet is a spoofed one, it can
no longer terminate a connection with an in-window se-
quence number.
2.2 Mitigating the Blind Reset Attack us-
ing the RST Bit
An attacker might also tear down the connection by in-
jecting RST packets (TCP packets in which the RST ﬂag
is set) into an ongoing TCP connection.
just
In pre-RFC 5961 Linux kernels,
like in the
SYN packet case, a RST packet can terminate a con-
nection successfully as long as its sequence num-
ber is in-window. RFC 5961 suggests the following
changes:
• If the sequence number is outside the valid receive
window, the receiver simply drops the packet. No
modiﬁcations are proposed for this case.
• If the sequence number exactly matches the next ex-
pected sequence number (RCV.NXT ), the connection
is reset.
• If the sequence number is in-window but does not ex-
actly match RCV.NXT , the receiver must send a chal-
lenge ACK packet to the sender, and drop the unac-
ceptable RST packet.
In the ﬁnal case, if the sender is legitimate, it sends back
a RST packet with the correct sequence number (derived
from the ACK number in the challenge ACK) to reset the
connection. On the other hand, if the RST is spoofed,
the challenge ACK packet will not be observable by the
off-path attacker. Therefore, the attacker needs to be ex-
tremely lucky to be able to succeed — only one out of
232 sequence numbers will be accepted.
2.3 Mitigating the Blind Data Injection
An attacker might corrupt the contents of a transmission
by injecting spoofed DATA packets. When a packet ar-
rives, the receiver ﬁrst checks the sequence number to
make sure it is in-window; in addition, the ACK num-
ber will be checked. Pre-RFC 5961, the ACK number is
considered valid as long as it falls in the wide range of
[SND.UNA − (231 − 1), SND.NXT ]; this is effectively
half of the ACK number space. Here, SND.UNA is
the sequence number of the ﬁrst unacknowledged byte.
SND.NXT is the sequence number of the next byte about
to be sent.
RFC 5961 suggests a much smaller valid ACK number
range of [SND.UNA − MAX.SND.W ND,SND.NXT ],
where MAX.SND.W ND is the maximum window size
the receiver has ever seen from its peer. This is illus-
trated in Figure 3. The reasoning is that the only valid
ACK numbers are those that are (i) not too old (bytes that
are recently sent) and (ii) not too new (receiver cannot
ACK bytes that are yet to be sent). The remaining ACK
values will be in the range of [SND.UNA − (231 − 1),
SND.UNA − MAX.SND.W ND), denoted as the chal-
lenge ACK window. Even though ACK numbers inside
this window are still considered invalid, the speciﬁca-
tion requires the receiver to generate outgoing challenge
ACKs in response to packets with such ACK numbers.
Overall, this more stringent ACK number check does not
eliminate, but helps dramatically reduce the probability
that invalid data is successfully injected. Speciﬁcally, if
the MAX.SND.W ND is small (which is typically the case
for most connections), then the acceptable ACK window
will be much smaller than the half of the ACK number
space (as illustrated in Figure 3).
2.4 ACK Throttling
In general, as explained earlier, RFC 5961 enforces a
much stricter check on incoming TCP packets; for ex-
ample, it requires the RST packets to have an exact se-
quence number to actually reset the connection, whereas
a “good enough” in-window value only triggers a chal-
lenge ACK. In order to reduce the number of challenge
ACK packets that waste CPU and bandwidth resources,
an ACK throttling mechanism is also proposed. Specif-
ically, the system administrator can conﬁgure the max-
imum number of challenge ACKs that can be sent out
in a given interval (say, 1 second). The RFC clearly
states “An implementation SHOULD include an ACK
USENIX Association  
25th USENIX Security Symposium  211
3
throttling mechanism to be conservative.” Therefore, the
Linux kernel has faithfully implemented this feature by
storing the challenge ACK counter in a global variable
shared by all TCP connections. This approach, unfor-
tunately, creates an undesirable side channel, as will be
elaborated. We emphasize that the RFC states that ACK
throttling applies to only challenge ACKs and not to reg-
ular ACKs. This means that the challenge ACK counter
is unlikely to be affected by legitimate ACK trafﬁc as the
conditions that trigger challenge ACKs are all considered
rare or due to attacks.
3 Vulnerability Overview
The Linux kernel ﬁrst implemented all the features sug-
gested in RFC 5961, in version 3.6 in September 2012.
The changes were backported to certain prior distribu-
tions as well. The ACK throttling feature is specif-
ically implemented as follows: a global system vari-
able sysctl tcp challenge ack limit was in-
troduced to control the maximum number of challenge
ACKs generated per second. It is set to 100 by default.
As this limit is shared across all connections (possibly
including the connections established with the attacker),
the shared state can be exploited as a side channel.
Assuming we follow the threat model in Figure 1,
the basic idea is to repeat the following steps: 1) send
spoofed packets to the connection under test (with a spe-
ciﬁc four-tuple), 2) create contention on the global chal-
lenge ACK rate limit, i.e., by creating a regular connec-
tion from the attacker to the server and intentionally trig-
gering the maximum allowed challenge ACKs per sec-
ond, and 3) count the actual number of challenge ACKs