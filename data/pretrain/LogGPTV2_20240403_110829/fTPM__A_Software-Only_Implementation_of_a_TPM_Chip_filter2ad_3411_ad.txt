characteristics: dTPM3 is much faster than dTPM1 and
dTPM2. Looking at the raw data (shown in [44]), we
believe that dTPM3 searches for prime numbers in the
background, even when no TPM command is issued, and
maintains a cache of prime numbers.
Figure 7 also shows that the latency of creating keys
has high variability due to how quickly prime numbers
are found. To shed more light into the variability of
ﬁnding prime numbers, we instrumented the fTPM code-
base to count the number of prime candidates considered
when creating an RSA 2048 key pair. For each test, all
candidates are composite numbers (and thus discarded)
USENIX Association  
25th USENIX Security Symposium  851
11
100
75
50
25
0
First Prime
Second Prime
1
10
100
1000
10000
# of Candidate Primes
n
o
i
t
a
r
u
D
d
n
a
m
m
o
C
)
s
d
n
o
c
e
s
i
l
l
i
m
(
150
100
50
0
fTPM1 fTPM2 fTPM3 fTPM4 dTPM1 dTPM2 dTPM3
Figure 8: Performance of searching for primes.
Figure 12: Performance of TPM verify command.
n
o
i
t
a
r
u
D
d
n
a
m
m
o
C
)
s
d
n
o
c
e
s
i
l
l
i
m
(
500
400
300
200
100
0
fTPM1 fTPM2 fTPM3 fTPM4 dTPM1 dTPM2 dTPM3
n
o
i
t
a
r
u
D
d
n
a
m
m
o
C
)
s
d
n
o
c
e
s
i
l
l
i
m
(
1,000
800
600
400
200
0
fTPM1 fTPM2 fTPM3 fTPM4 dTPM1 dTPM2 dTPM3
Figure 9: Performance of TPM seal command.
Figure 13: Performance of TPM encrypt command.
n
o
i
t
a
r
u
D
d
n
a
m
m
o
C
)
s
d
n
o
c
e
s
i
l
l
i
m
(
1,500
1,000
500
0
fTPM1 fTPM2 fTPM3 fTPM4 dTPM1 dTPM2 dTPM3
Figure 10: Performance of TPM unseal command.
n
o
i
t
a
r
u
D
d
n
a
m
m
o
C
)
s
d
n
o
c
e
s
i
l
l
i
m
(
1,200
1,000
800
600
400
200
0
fTPM1 fTPM2 fTPM3 fTPM4 dTPM1 dTPM2 dTPM3
n
o
i
t
a
r
u
D
d
n
a
m
m
o
C
)
s
d
n
o
c
e
s
i
l
l
i
m
(
800
600
400
200
0
fTPM1 fTPM2 fTPM3 fTPM4 dTPM1 dTPM2 dTPM3
Figure 14: Performance of TPM decrypt command.
n
o
i
t
a
r
u
D
d
n
a
m
m
o
C
)
s
d
n
o
c
e
s
i
l
l
i
m
(
1,000
800
600
400
200
0
fTPM1 fTPM2 fTPM3 fTPM4 dTPM1 dTPM2 dTPM3
Figure 11: Performance of TPM sign command.
except for the last number. We repeated this test 1,000
times. We plot the cumulative distribution function of
the number of candidates for each of the two primes (p
and q) in Figure 8. These results demonstrate the large
variability in the number of candidate primes considered.
While, on average, it takes about 200 candidates until
a prime is found (the median was 232 and 247 candi-
dates for p and q, respectively), sometimes a single prime
search considers and discards thousands of candidates
(the worst case was 3,145 and 2,471 for p and q, respec-
tively).
10.3 Comparing fTPMs to dTPMs
Figures 9–15 show the latencies of several common TPM
2.0 commands. The main result is that fTPMs are much
faster than their discrete counterparts. On average, the
slowest fTPM is anywhere between 2.4X (for decryp-
Figure 15: Performance of TPM load command.
tion) and 15.12X (for seal) faster than the fastest dTPM.
This is not surprising because fTPMs run their code on
ARM Cortex processors, whereas discrete chips are rele-
gated to using much slower microprocessors. The fTPM
technical report illustrates these vast performance im-
provements in even greater detail [44].
These performance results are encouraging. Tradi-
tionally, TPMs have not been used for bulk data crypto-
graphic operations due to their performance limitations.
With ﬁrmware TPMs however, the performance of these
operations is limited only by processor speed and mem-
ory bandwidth. Furthermore, fTPMs could become even
faster by taking advantage of crypto accelerators. Over
time, we anticipate that crypto operations will increas-
ingly abandon the OS crypto libraries in favor of the
fTPM. This provides increased security as private keys
never have to leave TrustZone’s secure perimeter.
852  25th USENIX Security Symposium 
USENIX Association
12
10.4 Evaluation Summary
In summary, our evaluation shows that (1) the ﬁrmware
TPM has better performance than discrete TPM chips,
and (2) creating RSA keys is a lengthy operation with
high performance variability.
11 Security Analysis
The fTPM’s security guarantees are not identical to those
of a discrete TPM chip. This section examines these dif-
ferences in greater depth.
On- versus off-chip. Discrete TPM chips connect to
the CPU via a serial bus; this bus represents a new attack
surface because it is externally exposed to an attacker
with physical access to the main board. Early TPM chips
were attached to the I2C bus, one of the slower CPU
buses, that made it possible for an attacker to intercept
and issue TPM commands [49]. Modern TPM speciﬁca-
tions have instructed the hardware manufacturers to at-
tach the TPM chip to a fast CPU bus and to provide a
secure platform reboot signal. This signal must guaran-
tee that the TPM reboots (e.g., resets its volatile registers)
if and only if the platform reboots.
In contrast, by running in the device’s ﬁrmware, the
fTPM sidesteps this attack surface. The fTPM has no
separate bus to the CPU. The fTPM reads its state from
secure storage upon initialization, and stores all its state
in the CPU and the hardware-protected DRAM.
Memory attacks. By storing its secrets in DRAM,
the fTPM is vulnerable to a new class of physical at-
tacks – memory attacks that attempt to read secrets from
DRAM. There are different avenues to mount memory
attacks, such as cold boot attacks [23, 39], attaching a
bus monitor to monitor data transfers between the CPU
and system RAM [21, 17, 18], or mounting DMA at-
tacks [6, 8, 42].
In contrast, discrete TPM chips do not make use of the
system’s DRAM and are thus resilient to such attacks.
However, there is a corresponding attack that attempts
to remove the chip’s physical encasing, expose its inter-
nal dies, and thus read its secrets. Previous research has
already demonstrated the viability of such attacks (typi-
cally referred to as decapping the TPM), although they
remain quite expensive to mount in practice [26].
The fTPM’s susceptibility to memory attacks has led
us to investigate inexpensive counter-measures. Sentry
is a prototype that demonstrates how the fTPM can be-
come resilient to memory attacks. Sentry retroﬁts ARM-
speciﬁc mechanisms designed for embedded systems but
still present in today’s mobile devices, such as L2 cache
locking or internal RAM [10]. Note that in constrast with
TrustZone, Intel SGX [25] provides hardware encryption
of DRAM, which protects against memory attacks.
Side-channel attacks. Given that certain resources
are shared between the secure and normal worlds, great
care must be given to side-channel attacks. In contrast, a
discrete TPM chip is immune to side-channel attacks that
use caching, memory, or CPU because these resources
are not shared with the untrusted OS.
a. Caches, memory, and CPU: The ARM Trust-
Zone speciﬁcation takes great care to reduce the likeli-
hood of cache-based side-channel attacks for shared re-
sources [1]. Cache-based side-channel attacks are difﬁ-
cult because caches are always invalidated during each
transition to and from the secure world. Memory is stat-
ically partitioned between the two worlds at platform
initialization time; such a static partitioning reduces the
likelihood of side-channel attacks. Finally, the CPU also
invalidates all its registers upon each crossing to and
from the secure world.
b. Time-based attacks: The TPM 2.0 speciﬁcation
takes certain precautions against time-based attacks. For
example, the entire cryptography subsystem of TPM 2.0
uses constant time functions – the amount of computa-
tion needed by a cryptographic function does not depend
on the function’s inputs. This makes the fTPM imple-
mentation as resilient to time-based side-channel attacks
as its discrete chip counterpart.
12 Discussion
Most of ARM TrustZone’s shortcomings stem from the
nature of this technology: it is a standalone CPU-based
security mechanism. CPU extensions alone are insufﬁ-