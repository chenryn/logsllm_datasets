into a Xfer-table, an internal data structure of the framework,
which enables the BCXE to obtain runtime information on the
supervised code-streams, which include among other things,
the address of the target code-stream to generate a new block
from. A xfer-stub replaces the CTI (conditional or the uncon-
ditional) that terminates a block. In some cases, where block
creation terminates because a predeﬁned number of non-CTIs
were reached, Cobra treats the block as ending with an uncon-
ditional branch/jump instruction and creates a corresponding
xfer-stub. Figure 3b shows the xfer-stub implementations for
conditional and unconditional CTIs on the IA-32 (and com-
patible) processors. For unconditional CTIs the corresponding
xfer-stub simply performs an unconditional jump (JMP) into
the BCXE. For conditional CTIs, the xfer-stub translates a con-
ditional into a conditional and an explicit JMP. This ensures
that the BCXE gets control for both situations where the condi-
tional evaluates to true and false. The parameter to a xfer-stub
is passed via a Parameter Information Block (PIB) — a per-
thread, framework internal memory area, instead of the thread
stack. This is required to prevent Cobra from being detected or
countered by the malware being analyzed (see Section 4.2.2).
The xfer-table (shown in Figure 3c) is an array of struc-
tures, one element for each xfer-stub that is currently used by
the framework. Every entry in the xfer-table consists of (1) a
target-address type (TAT), (2) a target-address value (TAV), (3)
the xfer-stub type (XST), and (4) additional xfer-stub parame-
ters (if applicable). The TAT determines if the address at which
the BCXE will create a new block from, is an immediate value
(VALIMM) or an indirect expression (VALIND) whose value
has to be evaluated by the BCXE at runtime upon entry from
the xfer-stub. The TAV is a constant (when TAT is VALIMM)
or an expression (when TAT is VALIND). The XST indicates
whether the xfer-stub is for a standard CTI with no additional
processing (XNORMAL) or a CTI that needs special process-
ing (XSPECIAL). XST XNORMAL is used in the majority of
cases while XST XSPECIAL is used to handle cases where:
(1) the CTI uses the thread stack implicitly (CALL, INT etc.)
(see Section 4.1.3), and (2) the framework needs to employ
block speciﬁc xfer-stubs to remain stealth (see Section 4.2.1).
In both cases the framework makes use of additional xfer-stub
speciﬁc parameters.
Figure 3c shows the entries corresponding to the xfer-stubs
for the blocks shown in Figure 2b. As seen, entry0 has TAT
set to VALIMM and TAV set to the constant 8d003ff0h since
the corresponding xfer-stub is for a CALL instruction (Line 4,
Figure 2a) which deals with a constant target address at which
the BCXE generates the next block from. However, entry4 has
TAT set to VALIND and TAV set to the expression EAX since
the corresponding xfer-stub is for a CALL instruction (Line 12,
Figure 2a) whose target address depends on the runtime value
of EAX at that point in execution. For both cases, the XST is
set to XSPECIAL to indicate that the xfer-stubs require addi-
tional processing.
4.1.3. Obfuscated Code and SM-SC Code Cobra’s model
of employing xfer-stubs for every CTI (unconditional or con-
ditional) enable the framework to support any form of code ob-
fuscation, since obfuscated code rely on conditional and/or un-
conditional branches in between instructions for their function-
ing [31, 18, 19, 55]. Since every block generated by the BCXE
terminates on exactly one CTI and the fact that the BCXE can
handle both direct and indirect control transfers, it is guaran-
teed that the destination memory-address for the next block
creation always points to an address from which a valid block
can be constructed using the disassembler. Lines 14–16, Fig-
ure 2a and blocks 5–7, Figure 2b, show an example of obfus-
cation in a code-stream and the corresponding blocks gener-
ated. Note how the blocks successfully un-obfuscate the code
stream as it would happen during normal execution in the ab-
sence of the framework. A point to be noted is that if a block
tried to include more than one CTI, the resulting block gener-
ated might escape the framework supervision during execution
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply. 
bcxe(entry_number);
(a)
              conditional
     unconditional
     mov PIB, entry
     jmp bcxe
mov PIB, entry_truepart
  jxx bcxe 
  mov PIB, entry_falsepart
  jmp bcxe
jxx = je, jne, jc, jnc, jb etc.
Entry  Number     Target Address     Target Address        Xfer-Stub                Xfer-Stub
                                      Type (TAT)            Value (TAV)               Type                     Parameters
        entry0                    VALIMM               8d003ff0h            XSPECIAL               8d003ff0h
        entry1                    VALIND                 [edi+0bh]            XSPECIAL               8d003ffch
        entry2                    VALIMM               8d003ff1h            XNORMAL                NULL
        entry3                    VALIMM               8d003ffeh            XNORMAL                NULL
        entry4                    VALIND                     eax                    XSPECIAL               8d004003h
        entry5                    VALIMM               8d00400ah          XNORMAL                NULL
        entry6                    VALIMM               8d004008h          XNORMAL                NULL
        entry7                    VALIMM               8d004010h          XNORMAL                NULL 
        entry8                    VALIND                [edi+eax*4]          XNORMAL                NULL
(b)
(c)
Figure 3. (a) Xfer-Stub Abstraction, (b) Xfer-Stub Implementation on IA-32 (and compatible) processors,
and (c) Xfer-Table
due to a CTI with an indirect target address (e.g CTI in line
12, Figure 2a). However, the framework can be conﬁgured dy-
namically to construct blocks including multiple CTIs or coa-
lesce existing blocks for performance enhancements (see Sec-
tion 4.3) in cases where one can be certain that such blocks
will not escape the framework supervision.
Cobra handles CTIs that employ the stack implicitly, in a
special fashion. As an example, on the IA-32 (and compat-
ible) processors, the CALL instruction transfers control to a
procedure unconditionally. The instruction pushes the return
address on the stack as a part of its semantic which is then
popped by a corresponding RET instruction to resume execu-
tion at the caller. This property is exploited by most if not all
SM-SC code which, instead of using the RET instruction, pop
the value into a register and use it to access their code in a
position independent manner for modiﬁcation and/or integrity
checking. Cobra ensures that the program counter of the target
code-stream is always reﬂected in the corresponding xfer-stub
for such instructions thereby supporting SM-SC code. Block
1, Figure 2b shows the cobra xfer-stub corresponding to the
CALL instruction shown in line 4, Figure 2a. As seen the cor-
responding xfer-table entry, entry0 (Figure 3c), sets the XST to
XSPECIAL and stores the original program counter as the pa-
rameter. The BCXE thus pushes the original program counter
on the stack before proceeding with block creation at the des-
tination address.
4.1.4. Block Execution Localized-executions start from a
user-deﬁned point — which we call an overlay point — in a
target code-stream. An overlay point is the memory-address
(typically a OS and/or a library function address) in a target
code-stream from where ﬁne-grained analysis is desired. An
overlay point under Cobra is deﬁned by employing SPiKE [51]
(a stealth coarse-grained malware analysis framework) and/or
VAMPiRE [50] (a stealth breakpoint framework). Once execu-
tion reaches an overlay point, Cobra is invoked to start ﬁne-
grained analysis until a release point is reached. A release
point is the memory-address in a target code-stream where
Cobra relinquishes supervision and lets the code-stream exe-
cute in a normal fashion. A overlay point and its correspond-
ing release point thus establish a ﬁne-grained analysis range
on a target code-stream under Cobra, while allowing other
code-streams to execute as is — a technique we call selec-
tive isolation. Under Cobra, one can specify multiple over-
lapping and/or non-overlapping overlay and release points for
a target code-stream. The framework also supports nesting of
overlay and release points and allows release points to be in-
ﬁnite, in which case the complete thread containing the target
code-stream is constantly run under Cobra’s supervision, un-
til the thread terminates or the framework is invoked to stop
localized-executions.
As an example, the W32/Ratos trojan runs under the Win-
dows OS and employs several kernel-mode threads for its inner
functioning. One such kernel-mode thread replaces the default
single-step handler in the Interrupt Descriptor Table (IDT) with
a trojan speciﬁc handler. With Cobra, we employ KiSwitch-
Context (an internal Windows kernel function responsible for
thread pre-emption) as the ﬁrst overlay point to execute each
of the trojan kernel-mode threads under the supervision of Co-
bra with inﬁnite release points. Upon detection of an access
to the single-step vector in the IDT via a Cobra generated
event (see Section 4.1.5), we employ the destination address
of the single-step handler as our second overlay point (with the
corresponding release point being the return from exception),
thereby allowing us to study the W32/Ratos single-step han-
dler in further detail. All this is done while co-existing with
other OS user- and kernel-mode threads and exception han-
dlers.
Cobra’s BCXE executes individual blocks in an unprivi-
leged mode regardless of the execution privilege of the tar-
get code-stream. This ensures that Cobra has complete con-
trol over the executing instructions. The framework can also
monitor any access to speciﬁed memory regions, the OS ker-
nel and resources, dynamic libraries etc. Cobra employs the
virtual memory system combined with subtle techniques for
memory access monitoring. On the IA-32 (and compatible)
processors, for example, Cobra elevates the privilege level of
speciﬁed memory regions and critical memory structures such
as page-directories/page-tables, the IDT, the descriptor tables
(GDT and LDT), task state segments (TSS) etc. by changing
their memory page attributes and installs its own page-fault
handler (PFH) to tackle issues involving memory accesses. The
PFH also facilitates hiding framework speciﬁc details in the
page-table/page-directories and the IDT while at the same time
allowing a code-stream to install their own handlers and de-
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply. 
scriptors in these tables. Cobra employs stealth-implants (see
Section 4.2.1) to support supervised execution of privileged
instructions in the event that the target code-stream runs in
kernel-mode.
Cobra does not make use of any OS speciﬁc functions
within its BCXE. The disassembler employed by the frame-
work is completely re-entrant. The framework employs a per-
thread PIB for the block xfer-stubs, does not tamper with
the executing stack and employs subtle techniques to remain
stealth (see section 4.2). These features enable the framework
to support multithreading since the executing threads see no
difference with or without CORBA in terms of their registers,
stack contents or time block. Cobra also supports automatic
thread monitoring for a speciﬁed process or the OS kernel. This
is a feature that automatically blocks every code-stream asso-
ciated with a target process. Thus an entire process can be ex-
ecuted under Cobra by specifying the process creation API as
an intial overlay point and allowing the framework to automat-
ically insert overlay points thereafter on every new thread or
process associated with the parent.
4.1.5. Events and Callbacks Cobra generates various events
during block execution. These include block creations, stealth
implants, begin/end execution of a whole block, execution of
individual and/or speciﬁc instructions within a block, system
calls and standard function invocations, access to user deﬁned
memory regions, access to critical structures such as page-
directories/page-tables, IDT, GDT etc. An analysis tool em-
ploying Cobra can employ event speciﬁc processing by reg-
istering callbacks — functions to which control is transferred
by the framework to process a desired event during block ex-
ecution. Callbacks are passed all the information they need to
change the target code-stream registers and memory (includ-
ing the stack), examine the block causing the event and in-
structions within it. A callback can also establish a new over-
lay point during an analysis session. Events and Callbacks thus
facilitate tuning the level of ﬁne grained analysis from as ﬁne
as instruction level to progressively less ﬁner levels.
A typical analysis process in our experience would employ
events on block creations, begin/end of block executions, ac-
cess to critical memory regions and any stealth implants before
doing an instruction level analysis of blocks. As an example, if
one considers the W32/Ratos, it overwrites the IDT single-step
handler entry with a value pointing to its own single-step han-
dler within a polymorphic code envelope. A IDT-write event
can be used to obtain the trojan single-step handler address in
the ﬁrst place. The callback for the IDT-write event would use
the single-step handler address as an overlay point to further
analyze the trojan single-step handler in a ﬁne-grained fashion.
The events of block creation, begin/end block executions can
then be used to build an execution model of the polymorphic
code envelope. The inner working of the single-step handler
can then be studied by an instruction level analysis on identi-
ﬁed blocks.
4.2. Stealth Techniques
Block execution occurs at an unprivileged level and can
cause problems with privileged instructions in the event that
the target code-stream runs in kernel-mode. Also, certain situ-
ations can result in the betrayal of the real state of an execut-
ing code-stream. Blocks can contain instructions which read
the machine state but do not cause an exception and thus es-
cape Cobra. As an example the RDTSC instruction can be used
to obtain the relative execution time of a region of code. This
time will be more in the case of a block being executed than in
normal execution. Certain instructions silently change the be-
havior of the executing code. An example would be a POPF
instruction which sets the trap ﬂag resulting in single step ex-
ceptions for every instruction executed thereafter. A malware
code-stream could also employ detection schemes against the
framework by accessing structures such as the stack, page-
tables, descriptor tables (IDT, GDT and LDT) etc. Cobra em-
ploys a host of techniques to tackle issues involving privileged
instructions and the framework stealthness.
4.2.1. Stealth-Implants Cobra scans a block for privileged
instructions and instructions that betray the real state of the
executing code-stream and replaces them with what we call
stealth-implants. These are Cobra code constructs that aid in
supervised execution of privileged instructions and the frame-
work stealthness, while preserving the semantics of the orig-
inal instructions in the target code-stream. Stealth-implants
only take place on blocks and never on the original code.
Thus they are undetectable by any intergrity checks, as such
checks always operate on the original code-stream. Cobra in-
serts stealth-implants for various instructions and employs a
host of antidotes for various possible ways in which a malware
could detect the framework. However, due to space constraints
we will concentrate on the discussion of a few important in-
structions on the IA-32 (and compatible) processors and tech-
niques that can be used to detect the framework and their anti-
dotes.
IA-32 (and compatible)
 Processor Instruction
Stealth Implant
rdtsc
push segreg
pop segreg
mov destination,segreg
mov segreg,source
sidt destination
sgdt destination
sldt destination
str destination
mov drx/crx,source
mov destination,drx/crx
in al/ax/eax,port
out port,al/ax/eax
pushf
popf
mov eax,cobra_tcounter *
push cobra_segreg
pop cobra_segreg *
mov destination,cobra_segreg
mov cobra_segreg,source *
mov destination,cobra_idtclone
mov destination,cobra_gdtclone
mov destination,cobra_ldtclone
mov eax,cobra_tssselector
mov cobra_drx/cobra_crx,source *
mov destination,cobra_drx/cobra_drx
mov al/ax/eax,cobra_valuefrom_port *
mov cobra_valueto_port,al/ax/eax *
push cobra_eflag