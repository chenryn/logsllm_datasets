bels control who can view, edit, or add to the posts and comments.
In one of our programs, the blog owner atomically reads a post
and updates its text to alternate between “ﬁzz” and “buzz”. In an-
other program, another user comments on the ﬁrst post (Fig. 10).
To keep this comment pertinent to the content of the post, reading
the post and adding the comment are done atomically. Since posts
and comments have different labels, this transaction has at least two
stages: one to read the post, and another to write the comment.
We were able to compile and run these programs with our mod-
iﬁed system with relatively few changes. Of the 352 lines of code,
we had to change a total of 50, primarily by adding annotations to
method signatures (§7.2.4).
8.3 Rainforest
We implemented the Rainforest example from §2.1. In our code,
two nodes within Rainforest act with Rainforest’s authority. They
perform transactions representing the orders of Gloria and Fred
from Fig. 1. Each transaction updates inventory data stored at one
location, and banking data stored at another. Fig. 11 gives examples
of the policies for price, inventory, and banking data.
While attempting to modify this code to work with SC, we dis-
covered that the staging order chosen in § 7.2.3 makes it impossi-
ble to provide the atomicity of the original application while both
meeting its security requirements and ensuring deadlock freedom.
To illustrate, suppose Gloria is purchasing an item from Outel.
To ensure she is charged the correct price, the event that updates
Example Program
Hospital
Blog
patsy
post
comment
SC
2PC
# stages Dyn. checks Total time Total time
6.38 ms
1.01 ms
1.01 ms
0.45 ms
0.11 ms
0.29 ms
9.17 ms
1.03 ms
1.30 ms
3
2
3
Figure 12: Performance overhead of SC. Reported times are per-transaction averages, across three 5-minute runs of the blog application and
three 20-minute runs of the hospital application. Relative standard error of all measurements is less than 2%.
the inventory must share a transaction with the one that debits Glo-
ria’s bank account. The conﬂict label for the inventory event cor-
responds to {Outel}, whereas the conﬂict label for the debit event
corresponds to {Bank, Gloria}. Since neither is a subset of the
other, the compiler cannot put them in the same transaction.
These difﬁculties in porting the Rainforest application arise be-
cause Fabric is designed to be an open system, and so an a pri-
ori choice of staging order must be chosen.
If the application
were written as part of a closed system, deadlock freedom can be
achieved by picking a staging order that works for this particular
application (e.g., {Outel} before {Bank, Gloria}), but it might
be difﬁcult to extend the system with future applications.
8.4 Overhead
The staged commit protocol adds two main sources of overhead
compared to traditional 2PC. First, each stage involves a round trip
to prepare the data manipulated during the stage, leading to over-
head that scales with the number of stages and with network la-
tency. Second, as described in § 7.3, dynamic labels result in po-
tential stagepoints, which must be resolved using run-time checks.
The number of checks performed depends on how well the com-
piler’s static analysis predicts potential stagepoints.
We measured this overhead in our implementation on an Intel
Core i7-2600 machine with 16 GiB of memory, using the transac-
tions in our examples. The post and comment transactions in the
blog example were each run continually for 15 minutes, and Patsy’s
transaction in the hospital example was run continually for 1 hour.
Fig. 12 gives the overall execution times for both the original
system and the modiﬁed system. For the modiﬁed system, it also
shows the number of stages for each transaction and the average
time spent in dynamic checks for resolving potential stagepoints.
The comment transaction in our experiments has one more stage
than as described in Fig. 10, because in all transactions, there is
an initial stage performed to obtain the principals involved in the
application.
By running the nodes on a single machine and using in-memory
data storage, we maximize the fraction of the transaction run time
occupied by dynamic checks. Nevertheless, this fraction remains
small. While the effective low latency of communication between
nodes reduces the overhead due to communication round-trips for
staging precommits, we report the number of stages, from which
this overhead can be calculated for arbitrary latency.
9. RELATED WORK
Various goals for atomic transactions, such as serializability [28]
and ACID [20], have long been proposed and widely studied, and
are still an active research topic. While much of the recent interest
has been focused on performance, we focus on security.
Information leaks in commonly used transaction scheduling pro-
tocols have been known for at least two decades [36, 6]. Kang and
Keefe [21] explore transaction processing in databases with multi-
ple security levels. Their work focuses on a simpler setting with
a global, trusted transaction manager. They assume each trans-
action has a single security level, and can only “read down” and
“write up.” Smith et al. [36] show that strong atomicity, isola-
tion, and consistency guarantees are not possible for all transac-
tions in a generalized multilevel secure database. They propose
weaker guarantees and give three different protocols that meet var-
ious weaker guarantees. Their Low-Ready-Wait 2PL protocol is
similar to SC, and provides only what the authors call ACIS−–
correctness. Speciﬁcally, “aborted operations at a higher level may
prevent all lower level operations from beginning” [36, p37]. Al-
though our implementation is conservative and would not allow
such a thing, the theory behind SC could allow a later stage with
less trustworthy participants to hold up earlier, precommitted stages
indeﬁnitely. Duggan and Wu [16] observe that aborts in high-
security subtransactions can leak information to low-security par-
ent transactions. Their model of a single, centralized multilevel se-
cure database with strictly ordered security levels is more restrictive
than our distributed model and security lattice. Our abort channels
generalize their observation. They arrive at a different solution,
building a theory of secure nested transactions. Atluri, Jajodia,
and George [5] describe a number of known protocols requiring
weaker guarantees or a single trusted coordinator. Our work in-
stead focuses on securely serializing transactions in a fully decen-
tralized setting. Our analysis is also the ﬁrst in this vein to consider
liveness: SC can guarantee deadlock freedom of transactions with
relaxed monotonicity.
In this work, we build on a body of research that uses lattice-
based information ﬂow labels and language-based information ﬂow
methods [12, 14, 31]. Relatively little work has studied informa-
tion ﬂow in transactional systems. Our implementation is built on
Fabric [24, 3], a distributed programming system that controls in-
formation ﬂow over persistent objects. The only other information-
ﬂow-sensitive database implementation appears to be IFDB [33],
which also does not account for abort channels.
10. CONCLUSION
There is a fundamental trade-off between strong consistency guar-
antees and strong security properties in decentralized systems. We
investigate the secure scheduling of transactions, a ubiquitous build-
ing block of modern large-scale applications. Abort channels offer
a stark example of an unexplored security ﬂaw: existing transac-
tion scheduling mechanisms can leak conﬁdential information, or
allow unauthorized inﬂuences of trusted data. While some sets of
transactions are impossible to serialize securely, we demonstrate
the viability of secure scheduling.
We present relaxed monotonicity, a simple condition under which
secure scheduling is always possible. Our staged commit protocol
can securely schedule any set of transactions with relaxed mono-
tonicity, even in an open system. To demonstrate the practical ap-
plicability of this protocol, we adapted the Fabric compiler to check
transactional programs for conditions that allow secure scheduling.
These checks are effective: the compiler identiﬁes an intrinsic se-
curity ﬂaw in one program, and accepts other, secure transactions
with minimal adaptations.
This work sheds light on the fundamentals of secure transac-
tions. However, there is more work to be done to understand the
pragmatic implications. We have identiﬁed separate necessary and
sufﬁcient conditions for secure scheduling, but there remains space
between them to explore. Ultimately, abort channels are just one in-
stance of the general problem of information leakage in distributed
systems. Similar channels may exist in other distributed settings,
and we expect it to be fruitful to explore other protocols through
the lens of information ﬂow analysis.
Acknowledgments
The authors would like to thank the anonymous reviewers for their
suggestions. This work was supported by MURI grant FA9550-
12-1-0400, by NSF grants 1513797, 1422544, 1601879, by gifts
from Infosys and Google, and by the Department of Defense (DoD)
through the National Defense Science & Engineering Graduate Fel-
lowship (NDSEG) Program.
11. REFERENCES
[1] Distributed transactions: .NET framework 4.6.
https://msdn.microsoft.com/en-us/library/ms254973%28v=
vs.110%29.aspx. Accessed: 2015-11-13.
[2] XA standard. In L. Liu and M. T. Özsu, editors, Encyclopedia
of Database Systems, pages 3571–3571. Springer US, 2009.
[3] O. Arden, J. Liu, T. Magrino, and A. C. Myers. Fabric 0.3.
Software release, http://www.cs.cornell.edu/projects/fabric,
June 2016.
[4] A. Askarov, D. Zhang, and A. C. Myers. Predictive black-box
mitigation of timing channels. In CCS, 2010.
[5] V. Atluri, S. Jajodia, and B. George. Multilevel Secure
Transaction Processing. Advances in Database Systems.
Springer US, 2000.
[6] V. Atluri, S. Jajodia, T. F. Keefe, C. D. McCollum, and
R. Mukkamala. Multilevel secure transaction processing:
Status and prospects. DBSec, 8(1):79–98, 1996.
[7] G. Barthe, T. Rezk, and M. Warnier. Preventing timing leaks
through transactional branching instructions. Electron. Notes
Theor. Comput. Sci., 153(2):33–55, May 2006.
[8] E. Bertino, B. Catania, and E. Ferrari. A nested transaction
model for multilevel secure database management systems.
ACM Trans. Inf. Syst. Secur., 4(4):321–370, Nov. 2001.
[9] B. Calder, J. Wang, A. Ogus, N. Nilakantan, A. Skjolsvold,
S. McKelvie, Y. Xu, S. Srivastav, J. Wu, H. Simitci, et al.
Windows Azure Storage. In SOSP, 2011.
[10] M. R. Clarkson and F. B. Schneider. Hyperproperties. In
CSF, 2008.
[11] J. C. Corbett, J. Dean, M. Epstein, A. Fikes, C. Frost, J. J.
Furman, S. Ghemawat, A. Gubarev, C. Heiser, P. Hochschild,
et al. Spanner: Google’s globally distributed database. ACM
Transactions on Computer Systems (TOCS), 31(3):8, 2013.
[12] D. E. Denning. A lattice model of secure information ﬂow.
Comm. of the ACM, 19(5):236–243, 1976.
[13] D. E. Denning. Cryptography and Data Security.
Addison-Wesley, Reading, Massachusetts, 1982.
[14] D. E. Denning and P. J. Denning. Certiﬁcation of programs
for secure information ﬂow. Comm. of the ACM,
20(7):504–513, July 1977.
[15] A. Dragojevi´c, D. Narayanan, E. B. Nightingale,
M. Renzelmann, A. Shamis, A. Badam, and M. Castro. No
compromises: Distributed transactions with consistency,
availability, and performance. In SOSP, 2015.
[16] D. Duggan and Y. Wu. Transactional correctness for secure
nested transactions. In TGC, pages 179–196, 2011.
[17] K. P. Eswaran, J. N. Gray, R. A. Lorie, and I. L. Traiger. The
notions of consistency and predicate locks in a database
system. Comm. of the ACM, 19(11):624–633, Nov. 1976.
Also published as IBM RJ1487, December 1974.
[18] M. J. Fischer, N. A. Lynch, and M. S. Paterson. Impossibility
of distributed consensus with one faulty process. Journal of
the ACM, 32(2):374–382, Apr. 1985. (MIT/LCS/TR-282).
[19] J. A. Goguen and J. Meseguer. Security policies and security
models. In IEEE Symp. on Security and Privacy, pages
11–20, Apr. 1982.
[20] T. Haerder and A. Reuter. Principles of transaction-oriented
database recovery. ACM Comput. Surv., 15(4):287–317, Dec.
1983.
[21] I. E. Kang and T. F. Keefe. Transaction management for
multilevel secure replicated databases. J. Comput. Secur.,
3(2-3):115–145, Mar. 1995.
[22] B. Köpf and M. Dürmuth. A provably secure and efﬁcient
countermeasure against timing attacks. In 2009 IEEE
Computer Security Foundations, July 2009.
[23] L. Lamport. Time, clocks, and the ordering of events in a
distributed system. Comm. of the ACM, 21(7):558–565, July
1978.
[24] J. Liu, M. D. George, K. Vikram, X. Qi, L. Waye, and A. C.
Myers. Fabric: A platform for secure distributed computation
and storage. In SOSP, 2009.
[25] D. McCullough. Noninterference and the composability of
security properties. In IEEE Symp. on Security and Privacy,
pages 177–186. IEEE Press, May 1988.
[26] S. Microsystems. JavaBeans (version 1.0.1-a).
http://java.sun.com/products/javabeans/docs/spec.html, Aug.
1997.
[27] A. C. Myers and B. Liskov. Protecting privacy using the
decentralized label model. ACM Transactions on Software
Engineering and Methodology, 9(4):410–442, Oct. 2000.
[28] C. H. Papadimitriou. The serializability of concurrent
database updates. J. of the ACM, 26(4):631–653, Oct. 1979.
[29] D. R. K. Ports and K. Grittner. Serializable snapshot
isolation in PostgreSQL. Proc. VLDB Endow.,
5(12):1850–1861, Aug. 2012.
[30] A. W. Roscoe. CSP and determinism in security modelling.
In IEEE Symp. on Security and Privacy, 1995.
[31] A. Sabelfeld and A. C. Myers. Language-based
information-ﬂow security. IEEE Journal on Selected Areas in
Communications, 21(1):5–19, Jan. 2003.
[32] A. Sabelfeld and A. C. Myers. A model for delimited release.
In 2003 International Symposium on Software Security,
number 3233 in Lecture Notes in Computer Science, pages
174–191. Springer-Verlag, 2004.
[33] D. A. Schultz and B. Liskov. IFDB: decentralized
information ﬂow control for databases. In EUROSYS, 2013.
[34] I. Sheff, T. Magrino, J. Liu, A. C. Myers, and R. van
Renesse. Safe serializable secure scheduling: Transactions
and the trade-off between security and consistency. Technical
Report 1813–44581, Cornell University Computing and
Information Science, Aug. 2016.
[35] A. Silberschatz, P. Galvin, and G. Gagne. Operating System
Concepts. Windows XP update. Wiley, 2003.
[36] K. Smith, B. Blaustein, S. Jajodia, and L. Notargiacomo.
Correctness criteria for multilevel secure transactions.
Knowledge and Data Engineering, IEEE Transactions on,
8(1):32–45, Feb 1996.
[37] S. Zdancewic and A. C. Myers. Observational determinism
for concurrent program security. In CSFW, 2003.