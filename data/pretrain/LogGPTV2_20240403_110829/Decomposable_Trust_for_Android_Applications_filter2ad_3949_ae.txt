6.5% of the system calls on both the host and the CVM
(e.g., fork, mmap), as described in Section III-D. Finally, we
block 2.1% (module insertion, shutdown) calls since they are
outright malicious if executed by an app. This is more of
an optimization to save round trips to the CVM, where, if
redirected, these calls would have no effect.
UI/Input system exploits. Anception trusts the UI system.
In our case, the UI system’s attack surface is the set of types
of ioctl calls an application may invoke on the window
managers. We have not found any attacks via these IPC calls
to the UI/Input and lifecycle management services. We did ﬁnd
exploits involving direct access of the frame buffer [31]. As
we have shown in Section V-A, such calls are redirected to the
CVM.
Anception runtime. A large percentage of Anception’s
code marshals and unmarshals data. Concretely, out of 5219
lines of C code (measured using sloccount), 2438 lines deal
with marshaling and unmarshaling (46.7%). The remaining
lines deals with bookkeeping such as maintaining process
state and memory maps. Automated techniques can instead
be used to generate the marshaling/unmarshaling code from
an interface speciﬁcation.
Number of deprivileged lines of code. Anception de-
privileges a signiﬁcant portion of the kernel and framework
services. We analyzed the Android framework and present a
conservative lower bound on the number of lines deprivileged.
All measurements were made on Android 4.2 and Linux
kernel 3.4. Privileged framework services are 181,260 lines of
code. Services related to UI, input and lifecycle management
comprise 72,542 lines. Anception’s current
implementation
deprivileges approximately 60% (108,718) of Android privi-
leged service code. We also obtained rough estimates on the
number of lines deprivileged within the linux kernel for the
ﬁlesystem and the network. fs/ext4 contains 26,451 lines
of code, while fs/ contains 725,466 lines of code. Similarly,
net/ipv4 contains 59,166 lines and net/ contains 515,383
lines of code. Thus, Anception deprivileges approximately 1.2
million lines of kernel code related to the ﬁle system and
network.
VI. PERFORMANCE EVALUATION
We quantify performance using several popular bench-
marks available from the Play Store. These benchmarks test
Disk I/O, 2D/3D graphics, CPU and memory performance and
are used by systems in the literature. We also execute mi-
crobenchmarks to quantify the overhead introduced by system
call interception and host ↔ guest context switching, which we
term as world switching. All experiments are run on a Samsung
Galaxy Tab 10.1 hosting Android 4.2 with 1GB of RAM,
a 1.6GHz processor and 64MB physical memory assigned
to the CVM. All readings are averaged over 5 runs of the
benchmark unless stated otherwise. Each benchmark averages
results internally as well. For example, our microbenchmarks
allow sufﬁcient time for the caches to warm up before making
timing measurements.
Active-set of apps. The benchmarks reported below were
run concurrently with the standard set of Android 4.2 apps
that launched at boot. Based on the ofﬁcial Android source
syscall
Null call – getpid
Filesystem – write (4096B)
Filesystem – read (4096B)
Binder IPC – ioctl (128B)
Binder IPC – ioctl (256B)
Native
0.76 μs
28.61 μs
6.51 μs
12 ms
12 ms
Anception
0.76 μs
384.45 μs
305.03 μs
31 ms
31.3 ms
TABLE I.
ASIM LATENCY
code (4.2), these apps are: home screen, launcher, contacts
(and its provider process), photo gallery, dialer, MMS and
settings. Vendors customize this list and add more apps. On our
Samsung Galaxy tab, there were a total of 23 apps (including
standard apps) in the active-set when our benchmarks were
run. We did not kill the active-set since it closely resembles
real world usage of the device were multiple apps are present
in the executing state.
A. Microbenchmarks
We measured the overhead introduced by ASIM using
the getpid syscall. For this purpose, getpid call executes on
the host and does not
involve any world switching. The
ﬁrst row of Table I shows that the ASIM is very efﬁcient
and introduces negligible overhead. We then measured the
performance of read and write syscalls to quantify the overhead
due to world switching. The benchmark writes (reads) 16
MB of data to (from) the internal storage of the device. The
results are indicated in the Table I below. Apart from the world
switching latency, part of the increase in latency is attributed
to chunking behavior in the data transfer channel as we can
only accommodate ﬁxed sized buffers7 for transfers between
the host and guest. Our current conﬁguration chunks data into
4096 byte packets.
A slowdown on a system call is experienced only when
a call is serviced in the CVM; when an app is not making
a system call, i.e., only running user-level application code,
it runs at native speed. Furthermore, UI-related system calls,
which all occur via ioctl() system call on Android, run at
essentially native speed since they are not redirected because of
security reasons. Not redirecting UI-related system calls also
helps performance. Using ProﬁleDroid [44], we found that
approximately 58.7% to 80.1% (average = 73.7) of system
calls made by popular apps are ioctl calls. After performing
an additional custom proﬁling of only ioctl calls, we found
that 81.35% of such calls are UI-related and thus will run at
native speed.
IPC and ﬁlesystem calls serviced in the CVM experience
a slowdown,
though the overheads appear acceptable. For
example, an IPC call to get a GPS ﬁx will return with an added
latency of 19 ms. Regarding ﬁle I/O microbenchmarks, the
additional latency appears to have minimal impact at the macro
level, possibly because of extensive memory-buffering that
occurs in ﬁlesystems. The macrobenchmarks below to evaluate
SQLite database performance, which is used extensively in
Android by many apps, validates this.
B. Macrobenchmarks
We used AnTuTu [6] (v2.9.4) to evaluate Anception per-
formance on app-oriented DB workloads (see Figure 6). An-
ception’s score was only 3% lower than with native Android,
7We can increase buffer sizes based on proﬁling information
351351
AnTuTu Benchmark
Native vs Anception (Normalized to Native)
Native
Anception
)
s
d
n
o
c
e
s
i
l
l
i
m
(
i
e
m
T
n
o
i
t
u
c
e
x
E
DatabaseI/O
2DGraphics
3DGraphics
 800
 700
 600
 500
 400
 300
 200
 100
 0
SunSpider Benchmark -- Native vs Anception
Native
Anception
3D
access
bitops
ctrlflow
math
string
 1
 0.8
 0.6
 0.4
 0.2
 0
Fig. 6. Relative AnTuTu benchmark scores – Higher bar is better.
Fig. 7.
several benchmarks.
SunSpider Benchmark illustrating Anception performance across
suggesting that the I/O performance hit at the microbenchmark
level is largely masked by memory buffering that occurs within
the ﬁlesystem and within SQLite. Earlier studies of Android
have shown that SQLite database I/O is typically the bulk of
the ﬁlesystem I/O by apps on Android. So, we believe that
deprivileging ﬁlesystem code by executing system calls on the
guest is the correct design decision. If I/O latency were to
matter in some context, one could choose to keep ﬁlesystem
I/O on the host side (while still keeping rest of the code in the
CVM deprivileged).
We also ran additional AnTuTu [6] macrobenchmarks as
well as SunSpider [42] benchmarks, which test Anception’s
ability to run unmodiﬁed, graphics-rich applications. For the
AnTuTu benchmark, Anception’s overall score is 2.8% less
than native Android. Detailed results on individual tests appear
in Figure 6. Anception’s performance was close to native on
2D and 3D tests (Figure 6). On the SunSpider benchmark An-
ception’s performance was essentially indistinguishable from
native Android (Figure 7).
We ran a sqlite benchmark that wrote 10,000 rows (each
row is 26 bytes) of data within a transaction. Given that 90%
of write requests on a smartphone are to a sqlite DB [28], and
a further 64% of I/O operations less than 4KB in size [28],
we feel this is a good characterization of normal smartphone
ﬁle I/O workload. The time to execute the benchmark on
Anception is 86.67 μs (SD = 1.17) compared to 86.55 μs (SD
= 2.0) for native Android. Thus, Anception’s performance is
virtually indistinguishable from native.
C. Memory Overhead
Anception’s unique design enables us to execute headless
Android within the CVM. We have found empirically that
assigning 64MB to the CVM allows proper operation (typical
Android devices have 1 – 4GB RAM). Note that the version of
Android executing in the CVM is a stock version of Android
minus the UI code. The active memory used is 25460 KB
± 524.54 KB out of 49228 KB available on average, i.e.,
almost 51% of assigned memory is available for use by proxy
processes. A proxy process is much smaller than the actual
process running on the host and thus Anception supports
multiple proxies in the CVM comfortably.
VII. DISCUSSION
that
High assurance apps can store cryptographic keys in their
read-only code that
is protected by Anception from other
apps and the CVM. However, Anception’s architecture makes
it possible to transparently provide encryption to any app.
All
is required is to provide each app a transparent
cryptographic ﬁle-system in the CVM. A per-app key for that
ﬁlesystem would reside in the host. An implementation is
to use encfs [18], a user-level encrypting ﬁle system based
on FUSE [19]. The app’s data directory would point to an
encrypted ﬁle system. The reads/writes from the FUSE layer
to the host OS are redirected as before. The net result is that
the CVM only sees read/write calls that contain encrypted data,
but does not have access to the keys (which reside on the host).
Anception does not rule out Iago attacks [12] on an
application, say the banking app, from the compromised CVM.
Iago attacks are carried out by returning bad system call results
to an app and attempting to corrupt it at run-time and make
it leak unencrypted sensitive data. These attacks are difﬁcult
to craft. The easiest attack vector for this kind of attack
would be to modify the results from ﬁle read calls. Using an
encryption wrapper for ﬁle system calls, as described earlier
in this section, makes such attacks more difﬁcult.
VIII. RELATED WORK
OS Virtualization. Current research is bringing classical
virtualization to smartphone hardware [27], [15], [17], [8].
Cells [5] is a lightweight (namespaces) approach to virtual-
ization that uses a shared kernel for VMs and is vulnerable
to kernel-level exploits. AirBag [45] builds upon Cells and
uses a single Play Store instance to provide a seamless user
experience. However, both systems run complete Android
stacks in each VM, The key difference with Anception is
that our design deprivileges a large chunk of the trusted base
and delegates it to a container. As we run apps on the host,
but delegate calls to services in the container, we are able
to run a headless OS in the container, thus reducing memory
consumption by design.
Overshadow [13], InkTag [25] and SP3 [47] are systems
aimed at providing virtual memory and disk data conﬁden-
tiality when the host OS is malicious through the use of
352352
encryption. Anception provides similar guarantees through
memory isolation and split execution. Anception takes a ﬁner
grained view of the OS and provides conﬁdentiality of UI
interactions.