# XDCTF2015 WriteUp
|
##### 译文声明
本文是翻译文章，文章来源：复旦六星战队@360安全播报
译文仅供参考，具体内容表达以及含义原文为准。
**MISC 100**
给出了一张官网logo一模一样的图片,一开始完全摸不着头脑。后来给出了原图,但是俩文件大小差了不少,应该不是简单的修改。然后给出了brain的提示,其实想到了跟brainfuck有关,但是我对brainfuck的理解也就是一个比较奇怪的编程语言,没有深入搜索。再然后说braintools了,我估摸着也是用了什么现成的图片隐写工具,直接GOOGLE或者github搜,找到braintool然后用命令解出来即可。
如此得到了brainfuck代码,然后用BFI工具跑一下就可以得到结果。
**  
**
**MISC 300**
上来肯定先例行检查下LSB啦
    python
    >>> import Image
    >>> a=Image.open('zxczxc.png')
    >>> a.point(lambda i: 255 if i&1 else 0).show()
可以发现第一列有藏着东西,仔细看看像素值
    python
    >>> for i in xrange(100):
    ...     print a.getpixel((0,i))
    ...
    (252, 255, 254)
    (253, 252, 255)
    (254, 252, 252)
    (254, 253, 254)
    (252, 255, 253)
    (252, 253, 254)
    (253, 254, 252)
    (254, 252, 255)
    (253, 255, 253)
    (252, 253, 254)
    (254, 253, 252)
    (254, 253, 253)
    (253, 254, 253)
    (252, 253, 254)
    (252, 255, 252)
    ...
发现其在252~255之间,那就是用了最后两位藏数据
最后试了下是按像素顺序、RGB顺序、倒数第二第一位的顺序排列的01串
    python
    >>> s=''
    >>> for i in xrange(165):
    ...     p=a.getpixel((0,i))
    ...     for k in xrange(3):
    ...             s+='1' if p[k]&2 else '0'
    ...             s+='1' if p[k]&1 else '0'
    ...
    >>> s
    '001110010011100000100110001101000110011000100011011101000110100100100101011001000110001100110010001100010011000000101110001100100011011100101110001100010011000000101110001100010011100100110101001011010011001000110000001100010011010100101101001100000011100100101101001100010011011001010100001100000011010100111010001100100011000100111010001101010011001000101011001100000011001000111010001100000011000000111001001110000010011000110100011001100010001101110100011010010010010101100100011000110111100011011010101010110100100001001001001011100100100110101011001011100010111000110001010011100100111111001100001100110100100000101111001100100010100111001000101010001101010001001101110011010100101100110110010010000011000111010110001101010011011110101110001010001101000100110101110011000010101111001001110101110011010111001100001101010100100101001111101011010000010100000000010110100111000000001111000101110011100100111000001001100011010001100110001000110111010001101001001001010110010001100011111111'
    >>> def tostr(s):
    ...     ret=''
    ...     for i in xrange(0, len(s), 8):
    ...             ret+=chr(int(s[i:i+8],2))
    ...     return ret
    ...
    >>> tostr(s)
    '98&4f#ti%dc210.27.10.195-2015-09-16T05:21:52+02:0098&4f#ti%dcxxdaxabHI.Ixab..1NOxcc3H/2)xc8xa8xd4MxcdK6H1xd657xae(xd15xcc+xc9xd75xcc5IOxadx05x00Zpx0fx1798&4f#ti%dc?'
    >>>
可以看到210.27.10.195-2015-09-16T05:21:52+02:00以及分隔符样的东西98&4f#ti%dc
一开始还以为那个IP 210.27.10.195有什么东西…
然后队友说这是zlib compressed才注意到第二个分隔符后有xxda这个头…..
    python
    >>> import zlib
    >>> zlib.decompress('xxdaxabHI.Ixab..1NOxcc3H/2)xc8xa8xd4MxcdK6H1xd657xae(xd15xcc+xc9xd75xcc5IOxadx05x00Zpx0fx1798&4f#ti%dc')
    'xdctf{st3gan0gr4phy-enc0d3-73xt-1nto-1m4ge}'
得到Flag
**REVERSE 100**
做题人在赶火车,留下程序就跑了……
这题好像比较坑的是,以为不会运行到的一段程序才是真的逻辑,一直被关注的地方过掉的话拿到的那个 congratulations 后面跟着 `?`
    python
    strs = '\|Gq\@?BelTtK5L`\|D`d42;'
    tmp = ''
    for c in strs:
    tmp+=chr(ord(c)^6)
    strs=tmp
    def check2(a):
    ans = {}
    for i in range(24):
    key = i - 12 * (((0x0AAAAAAAAAAAAAAAB * i) >> 64) >> 3)
    value = a[i] ^ ord(strs[i])
    if (key in ans):
    if ans[key]!=value:
    return
    else:
    ans[key]=value
    s = ''
    for c in ans:
    s += chr(ans[c])
    print s
    #print ord(s[1])
    def rotate(a):
    for i in range(6):
    t = a[i]
    a[i] = a[17-i]
    a[17-i] = t
    def check(a):
    rotate(a)
    check2(a)
    rotate(a)
    def dfs(a, i):
    if i == len(a):
    check(a)
    return
    dfs(a,i+1)
    if a[i]>31 and a[i]> __l['bpos']) & 1) for __l['bpos'] in [((__l['pos'] % 8))]][0] for __l['cpos'] in [((__l['pos'] / 8))]][0] for __l['p'], __l['pos'] in [(p, pos)]][0])({}), 'getbit')]][0] for __g['setbit'], setbit.__name__ in [(lambda p, pos, value: (lambda __l: [[[(lambda __target, __slice, __value: [(lambda __target, __slice, __value: [__l['p'] for __target[__slice] in [((lambda __old: (lambda __ret: __old | __value if __ret is NotImplemented else __ret)(getattr(__old, '__ior__', lambda other: NotImplemented)(__value)))(__target[__slice]))]][0])(__l['p'], __l['cpos'], (__l['value'] ", line 1, in 
      File "", line 1, in 
    IOError: [Errno 2] No such file or directory: 'flag.txt'
    >>> globals()
    {'string': , '__builtins__': , '__package__': None, 'i': 654, 'table': '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&'()*+,-./:;?@[\]^_`{|}~', 'encode': , '__name__': '__main__', 'getbit': , '__doc__': None, 'setbit': }
也就是import string,并生成了encode(), getbit(), setbit()的函数,还有一个table
下面还是先介绍下背景知识吧….
**函数式编程与lambda运算**
这个程序跟函数式编程还是有一定关系的,当然不会也能做…
下面就是这个.py的主要trick
**等量代换(实现where语句,scope内赋值)**
不妨先看下这样的例子:
    [y for y in [1]] == [1]
再看个复杂点的
    python
    [x for x in [range(3)]] == [x for x in [[0, 1, 2]]] == [ [0,1,2] ]
如果把最外层的方括号看成一个scope,也就是如同C语言里的{}所起的作用一样,那么这句话就是一个等量代换,把这句话变形一下易于理解,即:
    [
    x
    for x in [range(3)]
    ]
去掉in,得
    [
    x
    for x = range(3)
    ]
把最外层[]理解成c语言的scope
    {
    x = range(3)
    返回 x
    }
求值得
    {
    [0, 1, 2]
    }