IDA 能够识别大量字符串格式。默认情况下，IDA 会搜索并格式化C风格、以空字符结尾的字符串。要强制将数据转换为字符串，可以通过Edit▶Strings 菜单中的选项，选择一种字符串风格。如果当前选中地址开始部分的字节构成了一个选定风格的字符串，IDA 会将这些字节合并在一起，组成一个单字符串变量。任何时候，你都可以使用热键A以默认的字符串风格对当前选中的位置进行格式化。
有两个对话框可用于配置字符串数据。第一个对话框如图7-9所示，通过Options▶ASCII String Style 命令即可打开该对话框，ASCII在这里有些用词不当，因为IDA 能够理解许多其他字符串风格。
与“数据类型配置”对话框类似，左侧的按钮用于在当前选中的位置创建一个指定风格的字符串。只有当前位置的数据符合指定的字符串格式，才能创建字符串。对于以字符结尾的字符串，可以在对话框的底部指定两个终止符。对话框右侧的单选按钮用于指定字符串热键（A）的默认字符串风格。
图7-9
  字符串数据配置
第二个用于配置字符串操作的对话框如图7-10 所示，通过Options▶General可打开该对话框，再单击上面的Strings 选项卡即可在这里配置其他与字符串有关的选项。虽然你可以使用下拉框指定默认的字符串类型，但是，这里的绝大多数选项主要与字符串数据的命名和显示有关。对话框右侧的Name generation（名称生成）区只有在你选择了Generation names（生成名称）选项后才会显示。如果关闭“名称生成”，则IDA 会为字符串变量提供以asc_
 为前缀的哑名。
图7-10
  IDA 字符串选项
如果启用名称生成，Name generation 选项将控制IDA 如何为字符串变量生成名称。如果没有选择Generate serial names（生成序列名，默认设置），IDA 将使用指定的前缀和从字符串中提取出的字符，生成一个长度不超过当前最大名称长度的名称，下面的字符串即是一个例子：
.rdata:00402069 aThisIsACharact db 'This is a Character array',0
名称的首字母要大写，在生成名称时，任何禁止用在名称中的字符（如空格）将被省略。选择Mark as autogenerated （标记为自动生成）选项，生成的名称（默认为深蓝色）将以一种不同于用户指定的名称（默认为蓝色）的颜色显示。Preserve case（保留大小写）强制名称在字符串中出现时使用字符，而不是把它们转换成首字母大写。最后，Generate serial names 会使IDA 通过在名称后附加数字后缀（以数字开头），对名称进行序列化。生成的后缀中的数字由Width字段控制。根据图7-10 中的配置，生成的前3个名称分别为a000
 、a001
 和a002
 。   
7.4.3 指定数组
由高级语言生成的反汇编代码清单的一个缺点在于，它们极少提供有关数组大小方面的信息。在反汇编代码清单中，如果数组中的每一个元素都必须在它自己的反汇编行上指定，那么，指定一个数组可能需要大量空间。下面是位于已命名变量unk_402060
 之后的数据声明。其中只有第一个项被指令引用，表明它可能是某个数组中的第一个元素。通常，数组中的其他元素并不直接引用，而是需要经过更加复杂的索引计算，通过其与数组开头之间的偏移量来引用。
.rdata:00402060 unk_402060      db    0    ; DATA XREF: sub_401350+8↑o
.rdata:00402060                            ; sub_401350+18↑ o
.rdata:00402061                 db    0
.rdata:00402062                 db    0
.rdata:00402063                 db    0
.rdata:00402064                 db    0
.rdata:00402065                 db    0
.rdata:00402066                 db    0
.rdata:00402067                 db    0
.rdata:00402068                 db    0
.rdata:00402069                 db    0
.rdata:0040206A                 db    0
IDA 提供一些工具，可将连续的数据定义结合起来，组成一个单独的数组定义。要创建数组，首先选择数组中的第一个元素（这里我们选择的是unk_402060
 ），然后通过Edit▶Array命令打开如图7-11 所示的“创建数组”对话框。如果指定位置的一个数据项已经被定义，那么，当你右击该项时，上下文菜单中将显示Array选项。要创建的数组类型由你选择作为数组第一个元素的项的数据类型决定。在这里，我们创建了一个字节数组。
说明
  在创建数组之前，请确保将数组中第一个元素的大小更改为适当的值，从而为数组的元素选择适当的大小。  
图7-11
  创建数组对话框
下面是该对话框中用于创建数组的字段。  
Array element Width（数组元素宽度）
 。这个值表示各数组元素的大小（这里为1字节）， 它由你在打开对话框时选择的数据值的大小决定。
Maximum possible size（最大可能大小）
 。这个值由自动计算得出，它决定在遇到另一个 已定义的数据项之前，可包含在数组中的元素（不是字节）的最大数目。你可以指定一 个更大的值，但这需要随后的数据项为未定义数据项，以将它们吸收到数组中。
Number of elements （元素数量）
 。你可以在这里指定数组的具体大小。数组占用的总字 节数可通过“元素数量×数组元素宽度
 ”计算得出。
Items on a line （行中的项目）
 。指定在每个反汇编行显示的元素的数量。通过它可以减 少显示数组所需的空间。
Element width（元素宽度）
 。这个值仅用于格式化。当一行显示多个项目时，它控制列宽。
Use “dup” construct （使用重复结构）
 。这个选项可将相同的数据值合并起来，用一个重 复说明符组合成一项。
Signed elements（有符号元素）
 。表示将数据显示为有符号还是无符号的值。
Display indexes （显示索引）
 。使数组索引以常规注释的形式显示。如果你需要定位大型 数组中的特定数据，可以使用这个选项。选择该选项还将启用Indexes单选按钮，这样就 可以选择每个索引值的显示格式。
Create as array （创建为数组）
 。不选择这个选项似乎有悖于本对话框的目的，该选项默 认处于选中状态。如果你只希望指定一定数量的连续项目，而不是将它们组合成一个数 组，即可取消该选项。
接受图7-11 中指定的选项，可以得到下面的简单数组声明，它是一个名为byte_402060
 的字节 数组（db
 ），由416（1A0h）
 个0值构成。
.rdata:00402060 byte_402060     db 1A0h dup(0)     ; DATA XREF: sub_401350+8 ↑o
.rdata:00402060                                    ; sub_401350+18↑o
这段代码唯一的作用就是将这416行反汇编代码合并成单独一行（主要是因为使用了重复结构）。在下一章中，我们将讨论如何在栈帧中创建数组。
7.5 小结
本章及前一章介绍了IDA 用户需要执行的最常见的操作。通过修改数据库，你可以将自己的知识与IDA 在分析阶段收集到的信息结合起来，生成更加有用的数据库。和源代码一样，有效使用名称、分配数据类型和详尽的注释不仅可帮助你记忆分析过程，还可为那些需要参考你的工作的人们提供极大的帮助。在下一章中，我们将继续深入研究IDA 的功能，了解如何处理更加复杂的数据结构（如C结构体表示的数据结构），并讨论编译C++ 代码的一些基础知识。
第8章 数据类型与数据结构
要理解二进制程序的行为，首先必须对程序调用的库函数进行分类。调用 connect
 函数的C 程序要创建网络连接，调用RegOpenKey
 的Windows 程序要访问 Windows 注册表。但是，要了解如何及为何调用这些函数，还需要进行其他一些分析。
了解如何调用函数，首先需要知道给该函数传递哪些参数。以 connect
 函数调用为例，除了该函数被调用这一事实外，更为重要的是，还需要了解程序连接到的具体地址。要逆向工程一个函数的签名（该函数所需参数的数量、类型和顺序），了解传递给该函数的数据尤为关键，这也说明了理解汇编语言如何操纵数据类型和数据结构的重要性。
在本章中，我们将讨论 IDA 如何向用户传递数据信息，数据结构如何存储在内存中，以及如何访问这些数据结构中的数据。将特定数据类型与变量关联起来的最简单方法是，理解该变量作为某个函数（我们对该函数有一定了解）的参数时的用法。如果一个变量作为 IDA 拥有原型的函数的参数，在分析阶段，IDA 会尽其所能推断出该变量的数据类型。如有可能，IDA 会对该变量使用一个从函数原型中提取出的正式名称，而不是为其生成默认的哑名。下面调用 connect
 函数的反汇编代码即说明了这一点：
.text:004010F3                 push    10h             ; namelen  
.text:004010F5                 lea     ecx, ➊ [ebp+name]  
.text:004010F8                 push    ecx             ; name  
.text:004010F9                 mov     edx, ➊ [ebp+s]  
.text:004010FF                 push    edx             ; s  
.text:00401100                 call    connect
我们看到，每个 push
 指令都用被压入的参数的名称（根据 IDA 对函数原型的了解）进行了注释。此外，➊处的两个局部栈变量已经用它们对应的参数进行了命名。多数情况下，与IDA 生成的哑名相比，这些名称能够提供更多信息。
IDA 传播来自函数原型的类型信息的能力并不仅限于 IDA 类型库中包含的库函数。只要你明确设置函数的类型信息，IDA 就可以传播你的数据库中任何函数的正式参数名称和数据类型。在初始分析阶段，如果通过类型传播没有得出其他结论，IDA 会向所有函数参数分配哑名和一般类型int
 。任何时候，你必须使用 Edit ▶Functions ▶Set Function Type命令，或者在函数名称上右击鼠标并在上下文菜单中选择 Set Function Type（或使用热键 Y）来设置函数的类型。对于如下所示的函数，上述操作将生成如图 8-1 所示的对话框，你可以在其中输入正确的函数原型。
.text:00401050 ; ======== S U B R O U T I N E =========================  
.text:00401050  
.text:00401050 ; Attributes: bp-based frame  
.text:00401050  
.text:00401050 foo     proc near      ; CODE XREF: demo_stackframe+2A ↓ p  
.text:00401050  
.text:00401050 arg_0   = dword ptr  8  
.text:00401050 arg_4   = dword ptr  0Ch  
.text:00401050  
.text:00401050         push    ebp  
.text:00401051         mov     ebp, esp  
如下所示，IDA 假定了int
 返回类型，根据所使用的 ret
 指令类型正确推断出该函数采用了cdecl
 调用约定，并将其结合到函数名称中（如我们修改的那样），同时假定所有参数均为`int 类型。由于我们尚未修改参数名称，IDA 仅显示它们的类型。
图8-1 设置函数的类型
如果我们将该原型修改为 int __cdecl foo(float f, char * ptr)
 ，IDA 将自动为该函数插入原型注释（➊）并在反汇编列表中更改参数名称（➊），如下所示：
.text:00401050 ; ======== S U B R O U T I N E =========================  
.text:00401050  
.text:00401050 ; Attributes: bp-based frame  
.text:00401050  
.text:00401050  ➊ ; int __cdecl foo(float f, char *ptr)  
.text:00401050 foo     proc near      ; CODE XREF: demo_stackframe+2A ↓ p  
.text:00401050  
.text:00401050  ➋ f       = dword ptr  8  
.text:00401050  ➋ ptr     = dword ptr  0Ch  
.text:00401050           
.text:00401050         push    ebp  
.text:00401051         mov     ebp, esp  
最后，IDA 会向新修改的函数的所有调用方传播这些信息，从而改进对此处显示的所有相关函数调用的附加说明。请注意，在调用函数中，参数名称 f
 和ptr
 已作为注释（➌）进行传播，并对之前使用哑名的变量（➍）进行了重命名。
.text:004010AD         mov     eax, [ebp+ ➍ ptr] 
.text:004010B0         mov     [esp+4], eax     ➌ ; ptr  
.text:004010B4         mov     eax, [ebp+ ➍ f]  
.text:004010B7         mov     [esp], eax       ➌ ; f  
.text:004010BA         call    foo
返回到导入的库函数，IDA 通常已经知道被调用函数的原型了。在这种情况下，将光标放在函数名称上，你就可以轻易查看该函数的原型。1
 如果IDA 不知道该函数需要哪些参数，此时你至少需要知道导入函数的库的名称（见Imports窗口）。如果发生这种情况，你最好通过相关手册或其他可用的 API 文档（如 MSDN 在线文档2
 ）了解该函数的行为。如果所有其他资源都无法提供帮助，你还可以搜索 Google 。
1. 将光标定位在IDA 窗口中的任何名称上，IDA 将显示一个类似于工具提示条的弹出窗口，其中包含目标位置多达10行的反汇编代码。如果该名称为库函数名，窗口中通常包含用于调用该库函数的原型。
2. 参见http://msdn.microsoft.com/library/
 。
在本章的剩余部分，我们将讨论如何确定程序何时使用数据结构，如何解析这些结构的组织布局，以及如何利用 IDA 来提高包含这类结构的反汇编代码清单的可读性。由于 C++ 类是C 结构体的一种复杂扩展，在本章末尾，我们将讨论如何逆向工程已编译的 C++ 程序。
8.1 识别数据结构的用法
虽然基本数据类型通常能够与 CPU 寄存器或指令操作数的大小很自然地适应，但是，要访问复合数据类型（如数组和结构体）所包含的各数据项，则需要更加复杂的指令序列。在讨论改善代码（其中包含复杂的数据类型）可读性的 IDA 功能之前，首先简单分析一下相关代码。
8.1.1 数组成员访问
就内存布局而言，数组是最简单的复合数据结构。传统意义上的数组指包含同一数据类型的连续元素的连续内存块。用数组中元素的数量乘以每个元素的大小，即可直接计算出数组的大小。使用C 语句，以下数组：
int array_demo[100];
所占用的最小字节的计算方法为：
int bytes = 100 * sizeof(int);
各数组元素通过索引值进行访问，这个索引值可能是变量或常量，如下面这些数组引用所示：
➊ array_demo[20] = 15;  //fixed index into the array  
  for (int i = 0; i < 100; i++) {  
➋     array_demo[i] = i;  //varying index into the array  