# 如何在不调用Win32_Process的情况下使用WMI横向渗透
|
##### 译文声明
本文是翻译文章，文章来源：https://www.cybereason.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 引言
对攻击者来说，如果需要对某个网络中的多台计算机进行攻击，那么横向移动是至关重要的一个步骤。假如攻击者已经拥有正确的证书，他们往往会滥用允许远程执行代码的现有机制，从而实现横向移动。虽然这些机制大多数都被合法使用，但仍然有许多环境会对它们进行监控，以防止其被非法使用。如果使用了很少在特定环境中使用的向量，远程执行代码可能会被检测为异常，并标记为恶意代码。例如，在网络的远程服务创建过程中使用了PSExec工具，这就是非常少见的，从而可能引发告警。  
一个更专业的攻击者更愿意使用远程执行技术，随着这种技术不断发展，其过程越来越趋近于正常合法的行为，此外，这些技术还滥用了容易被防护方遗漏掉得的执行通道。基于此，如果能够改进出一套可用的横向移动技术，就可以让攻击者在不被检测到的前提下实现攻击。  
在本文中，我们主要讲解由Cybereason发现的通过对WMI（Windows Management
Infrastructure）滥用实现的一种新型横向移动技术（
）。另外，我们也会对已经公开披露的横向移动方法进行详细分析。由于这些新型技术目前还没有普遍流行，所以许多安全工具无法对它们进行检测。然而，Cybereason编写了一个工具，这是该技术的一个概念验证（PoC），可以具体展现攻击者借助这种攻击方式具体都可以做什么。PowerShell脚本请参考：
 。  
如果大家想了解更多关于哪些合法功能正在被滥用以进行横向移动的内容，请阅读这篇文章（
），其中讨论了攻击者如何使用分布式组件对象模型（DCOM）。
## 关于WMI的简要介绍
WMI是Windows操作系统上WBEM和CIM标准的实现，允许用户、管理员和开发人员（包括攻击者）在操作系统中对各种托管组件进行遍历、操作和交互。具体而言，WMI提供了一个抽象的、统一的面向对象模型，从而不再需要直接与许多不相关的API进行交互，当然也无需再研究这些不相关API的文档。  
WMI包含表示元素的类，例如系统注册表、进程、线程和硬件组件。  
我们可以通过发出WQL查询来列举出由类表示的组件实例，这些查询是使用WQL（类似SQL）语言编写的，也可以通过诸如PowerShell CIM / WMI
cmdlet的抽象。此外，也可以在类和实例上调用方法，从而使用WMI接口来操纵底层的托管组件。  
WMI的一个重要特性是能够使用DCOM或WinRM协议与远程机器的WMI模块进行交互。这样一来，就使得攻击者可以远程操作主机上的WMI类，而无需事先运行任何代码。
## WMI的主要组件
WMI由三个主要组件组成：  
1、WMI服务（winmgmt）充当客户端与WMI模型本身之间的中间人，负责处理来自客户端进程的所有请求（方法调用、查询等）。虽然其自身不能处理大部分请求，但它能够将请求转发给其他组件，并将其响应转发回客户端。  
2、WMI提供程序（WMI Providers）是用于实现代码实现类、实例和方法。提供程序大多是作为进程内COM对象来实现的。  
3、WMI存储库是模型的中央存储区域，其中包含类定义和需要持久化的对象实例（与提供程序动态生成的实例相对）。  
在了解WMI主要的组件之后，我们来考虑经典WMI横向移动技术的场景。当一个本地或远程客户端试图调用Win32_Process的Create方法时，会向WMI服务发送这个行为的请求，然后查询存储库，确定其提供程序为CIMWin32。然后，WMI服务将请求转发给提供程序，该提供程序创建一个新进程并将表示该进程的Win32_Process实例返回给该服务，并将该实例发送回客户端。如果想了解更多关于WMI安全性的内容，建议阅读这篇文章：
 。  
由于这种横向移动的方法是非常经典的，所以目前很多安全产品都会对这种方式进行检测。因此，攻击者也在基于这种最经典的技术不断改进，研究出其他利用WMI进行横向移动的方法。
## WMI横向移动的其他方案
###  派生类
尽管从严格意义上来说，这不是一种新的横向移动方法，但这种技术不需要攻击者与常常会被监控的Win32_Process::Create方法直接进行交互。攻击者可以远程创建一个新类，从已有的类（例如Win32_Process）继承，并调用新类中的方法（或者创建实例），而不直接调用可能会引起怀疑的方法，具体如下所述：  
1、创建Win32_Process的子类Win32_NotEvilAtAll，该过程可以通过WMI远程进行；  
2、新类继承父类的所有方法；  
3、调用新定义类中的“Create”方法。  
下图是我们编写的Invoke-WmiLm脚本中的部分内容，我们使用Derive和Put方法，在远程主机上创建了Win32_Process的子类，并调用了新定义类的Create方法。  
现在，让我们看看WMI-Activity ETW提供程序的事件，初步看来我们已经避免了直接使用Win32_Process：  
实际上，事件11的所有实例都体现了向WMI服务发出的请求，但其中并没有Win32_Process类的痕迹。我们在这里看到了希望，但经过仔细观察，我们发现这种规避方法还存在不完美之处：  
为什么在这里仍然会显示Win32_Process::Create呢？  
其原因在于，尽管我们用相同的“Create”方法创建了一个新类，但我们实际上没有向目标主机引入任何新代码。这也就意味着该方法会在相同提供程序的环境中执行。WMI-Activity提供程序的事件12体现了WMI服务与WMI提供程序之间的通信，并且展示了谁是真正实现了方法执行请求的提供程序。  
其中，有一种非常不一样的检测方法，就是WMI自检。WMI提供了一个全面的事件管理系统，同时也有一些非常有用的事件来对自己实现监控。在这样的事件中，会描述主机上的所有WMI方法调用。  
从上图中可以看出，MSFT_WmiProvider_ExecMethodAsyncEvent_Pre并不描述客户端请求的方法，而是再次描述了提供程序实现的真实方法，我们采用的逃避技术并没有对其奏效。  
尽管这种技术并不像我们所希望的那样，能实现对WMI方法调用的混淆，但该方法仍然适用于不需要使用方法（例如事件订阅）的情况下，这样在所有事件中显示的就是派生类的名称，而不是原始名称。  
另外，我们还尝试了“类克隆”的方式，通过滥用WMI类的层次结构来逃避被记录。该方法需要选定一个目标类，并且定义了一个新的目标类，与目标共享所有成员和层次结构。根据我们的推测，这种方法的逃避监测效果更好，因为我们的新类并不是目标的子类。然而，在WMI服务中，我们无法找到克隆类中定义的方法的实现，因此该方案就变得不太可行。
## WMI修改经典技术
如果我们能使用WMI执行常见的横向移动任务（例如替换PSEXEC），那么就会改变攻击者的行为，从而足以逃避相关的监控。下面是该技术的几个示例。
###  服务创建
远程服务创建（通常使用PSEXEC工具）大概是Windows环境中最常见的横向移动方法，该方法也可以在WMI中实现。  
Win32_Service类表示一台主机上的单个服务，并且公开了Windows服务管理器（sc.exe工具）几乎所有的功能。  
我们快速了解一下Win32_Service方法，该方法让类可以轻松地在目标主机上对服务进行操作。这样就足以实现攻击者通常借助服务进行横向移动的全过程：创建、启动、停止、删除。  