因为指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通
过该指针来更新变量的值。例如下面这个例子就是通过指针来更新变量的值，然后返回更新
后的值，可用在一个表达式中（译注：这是对C语言中 操作的模拟，这里只是为了说明
++v
指针的用法，incr函数模拟的做法并不推荐）：
func incr(p *int) int {
*p++ // 非常重要：只是增加p指向的变量的值，并不改变p指针！！！
return *p
}
v := 1
incr(&v) // side effect: v is now 2
fmt.Println(incr(&v)) // "3" (and v is 3)
每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名。例
如， 就是是 变量v的别名。指针特别有价值的地方在于我们可以不用名字而访问一个变
*p
量，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部
变量 59
gopl
的别名（译注：这是Go语言的垃圾回收器所做的工作）。不仅仅是指针会创建别名，很多其
他引用类型也会创建别名，例如slice、map和chan，甚至结构体、数组和接口都会创建所引
用变量的别名。
指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应
命令行标志参数的变量可能会零散分布在整个程序中。为了说明这一点，在早些的echo版本
中，就包含了两个可选的命令行参数： 用于忽略行尾的换行符， 用于指定分隔字
-n -s sep
符（默认是空格）。下面这是第四个版本，对应包路径为gopl.io/ch2/echo4。
gopl.io/ch2/echo4
// Echo4 prints its command-line arguments.
package main
import (
"flag"
"fmt"
"strings"
)
var n = flag.Bool("n", false, "omit trailing newline")
var sep = flag.String("s", " ", "separator")
func main() {
flag.Parse()
fmt.Print(strings.Join(flag.Args(), *sep))
if !*n {
fmt.Println()
}
}
调用flag.Bool函数会创建一个新的对应布尔型标志参数的变量。它有三个属性：第一个是的命
令行标志参数的名字“n”，然后是该标志参数的默认值（这里是false），最后是该标志参数对
应的描述信息。如果用户在命令行输入了一个无效的标志参数，或者输入 或 参
-h -help
数，那么将打印所有标志参数的名字、默认值和描述信息。类似的，调用flag.String函数将于
创建一个对应字符串类型的标志参数变量，同样包含命令行标志参数对应的参数名、默认
值、和描述信息。程序中的 和 变量分别是指向对应命令行标志参数变量的指针，因此
sep n
必须用 和 形式的指针语法间接引用它们。
*sep *n
当程序运行时，必须在使用标志参数对应的变量之前先调用flag.Parse函数，用于更新每个标
志参数对应变量的值（之前是默认值）。对于非标志参数的普通命令行参数可以通过调用
flag.Args()函数来访问，返回值对应对应一个字符串类型的slice。如果在flag.Parse函数解析
命令行参数时遇到错误，默认将打印相关的提示信息，然后调用os.Exit(2)终止程序。
让我们运行一些echo测试用例：
变量 60
gopl
$ go build gopl.io/ch2/echo4
$ ./echo4 a bc def
a bc def
$ ./echo4 -s / a bc def
a/bc/def
$ ./echo4 -n a bc def
a bc def$
$ ./echo4 -help
Usage of ./echo4:
-n omit trailing newline
-s string
separator (default " ")
2.3.3. new函数
另一个创建变量的方法是调用用内建的new函数。表达式new(T)将创建一个T类型的匿名变
量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为 。
*T
p := new(int) // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // "0"
*p = 2 // 设置 int 匿名变量的值为 2
fmt.Println(*p) // "2"
用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变
量的名字外，我们还可以在表达式中使用new(T)。换言之，new函数类似是一种语法糖，而
不是一个新的基础概念。
下面的两个newInt函数有着相同的行为：
func newInt() *int {
return new(int)
}
func newInt() *int {
var dummy int
return &dummy
}
每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"
变量 61
gopl
当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是0，例
如 struct{} 和 [0]int , 有可能有相同的地址（依赖具体的语言实现）（译注：请谨慎使用大
小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行
为，具体请查看 函数相关文档）。
runtime.SetFinalizer
new函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会
更灵活（§4.4.1）。
由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为
别的类型。例如下面的例子：
func delta(old, new int) int { return new - old }
由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的。
2.3.4. 变量的生命周期
变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。对于在包一级声明的变量
来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的声明周期
则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变
量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被
调用的时候创建。
例如，下面是从1.4节的Lissajous程序摘录的代码片段：
for t := 0.0; t < cycles*2*math.Pi; t += res {
x := math.Sin(t)
y := math.Sin(t*freq + phase)
img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
blackIndex)
}
译注：函数的有右小括弧也可以另起一行缩进，同时为了防止编译器在行尾自动插入分号而
导致的编译错误，可以在末尾的参数变量后面显式插入逗号。像下面这样：
for t := 0.0; t < cycles*2*math.Pi; t += res {
x := math.Sin(t)
y := math.Sin(t*freq + phase)
img.SetColorIndex(
size+int(x*size+0.5), size+int(y*size+0.5),
blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性
) // 小括弧另起一行缩进，和大括弧的风格保存一致
}
变量 62
gopl
在每次循环的开始会创建临时变量t，然后在每次循环迭代中创建临时变量x和y。
那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避
开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局
部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访
问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结
果。
因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期
可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。
编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个
选择并不是由用var还是new声明变量的方式决定的。
var global *int
func f() {
var x int
x = 1
global = &x
}
func g() {
y := new(int)
*y = 1
}
f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找
到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相
反，当g函数返回时，变量 将是不可达的，也就是说可以马上被回收的。因此， 并没
*y *y
有从函数g中逃逸，编译器可以选择在栈上分配 的存储空间（译注：也可以选择在堆上分
*y
配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何
时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需
要额外分配内存，同时对性能的优化可能会产生细微的影响。
Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考
虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变
量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，
特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性
能）。
变量 63
gopl
2.4. 赋值
使用赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在=的左边，
新值的表达式放在=的右边。
x = 1 // 命名变量的赋值
*p = true // 通过指针间接赋值
person.name = "bob" // 结构体字段赋值
count[x] = count[x] * scale // 数组、slice或map的元素赋值
特定的二元算术运算符和赋值语句的复合操作有一个简洁形式，例如上面最后的语句可以重
写为：
count[x] *= scale
这样可以省去对变量表达式的重复计算。
数值变量也可以支持 递增和 递减语句（译注：自增和自减是语句，而不是表达式，因
++ --
此 之类的表达式是错误的）：
x = i++
v := 1
v++ // 等价方式 v = v + 1；v 变成 2
v-- // 等价方式 v = v - 1；v 变成 1
2.4.1. 元组赋值
元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句
右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。这对于处理有些同
时出现在元组赋值语句左右两边的变量很有帮助，例如我们可以这样交换两个变量的值：
x, y = y, x
a[i], a[j] = a[j], a[i]
或者是计算两个整数值的的最大公约数（GCD）（译注：GCD不是那个敏感字，而是
greatest common divisor的缩写，欧几里德的GCD是最早的非平凡算法）：
赋值 64
gopl
func gcd(x, y int) int {
for y != 0 {
x, y = y, x%y
}
return x
}
或者是计算斐波纳契数列（Fibonacci）的第N个数：
func fib(n int) int {
x, y := 0, 1
for i := 0; i < n; i++ {
x, y = y, x+y
}
return x
}
元组赋值也可以使一系列琐碎赋值更加紧凑（译注: 特别是在for循环的初始化部分），
i, j, k = 2, 3, 5
但如果表达式太复杂的话，应该尽量避免过度使用元组赋值；因为每个变量单独赋值语句的
写法可读性会更好。
有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在
元组赋值右边的表达式中时（译注：右边不能再有其它表达式），左边变量的数目必须和右
边一致。
f, err = os.Open("foo.txt") // function call returns two values
通常，这类函数会用额外的返回值来表达某种错误类型，例如os.Open是用额外的返回值返回
一个error类型的错误，还有一些是用来返回布尔值，通常被称为ok。在稍后我们将看到的三
个操作都是类似的用法。如果map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）
出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否
成功：
v, ok = m[key] // map lookup
v, ok = x.(T) // type assertion
v, ok = <-ch // channel receive
译注：map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边
时，并不一定是产生两个结果，也可能只产生一个结果。对于值产生一个结果的情形，map
查找失败时会返回零值，类型断言失败时会发送运行时panic异常，通道接收失败时会返回零
赋值 65
gopl
值（阻塞不算是失败）。例如下面的例子：
v = m[key] // map查找，失败时返回零值
v = x.(T) // type断言，失败时panic异常
v = <-ch // 管道接收，失败时返回零值（阻塞不算是失败）
_, ok = m[key] // map返回2个值