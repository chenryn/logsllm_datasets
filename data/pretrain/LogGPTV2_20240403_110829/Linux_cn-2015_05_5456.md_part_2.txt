* **中间缓存代理**：任何在客户端和您的基础架构之间的服务器都可以按期望缓存一些内容。这些缓存可能由ISP（网络服务提供者）或者其他独立组织提供。
* **反向缓存**：您的服务器基础架构可以为后端的服务实现自己的缓存。如果实现了缓存，那么便可以在处理请求的位置返回相应的内容而不用每次请求都使用后端服务。
上面的这些位置通常都可以根据它们自身的缓存策略和内容源的缓存策略缓存一些相应的内容。
### 缓存头部
缓存策略依赖于两个不同的因素。所缓存的实体本身需要决定是否应该缓存可接受的内容。它可以只缓存部分可以缓存的内容，但不能缓存超过限制的内容。
缓存行为主要由缓存策略决定，而缓存策略由内容拥有者设置。这些策略主要通过特定的HTTP头部来清晰地表达。
经过几个不同HTTP协议的变化，出现了一些不同的针对缓存方面的头部，它们的复杂度各不相同。下面列出了那些你也许应该注意的：
* \*\*`Expires`\*\*：尽管使用范围相当有限，但`Expires`头部是非常简洁明了的。通常它设置一个未来的时间，内容会在此时间过期。这时，任何对同样内容的请求都应该回到原始服务器处。这个头部或许仅仅最适合回退模式（fall back）。
* \*\*`Cache-Control`\*\*：这是`Expires`的一个更加现代化的替换物。它已被很好的支持，且拥有更加灵活的实现。在大多数案例中，它比`Expires`更好，但同时设置两者的值也无妨。稍后我们将讨论您可以设置的`Cache-Control`的详细选项。
* \*\*`ETag`\*\*：`ETag`用于缓存验证。源服务器可以在首次服务一个内容时为该内容提供一个独特的`ETag`。当一个缓存需要验证这个内容是否即将过期，他会将相应的`ETag`发送回服务器。源服务器或者告诉缓存内容是一致的，或者发送更新后的内容（带着新的`ETag`）。
* **`Last-Modified`**：这个头部指明了相应的内容最后一次被修改的时间。它可能会作为保证内容新鲜度的验证策略的一部分被使用。
* \*\*`Content-Length`\*\*：尽管并没有在缓存中明确涉及，`Content-Length`头部在设置缓存策略时很重要。某些软件如果不提前获知内容的大小以留出足够空间，则会拒绝缓存该内容。
* \*\*`Vary`\*\*：缓存系统通常使用请求的主机和路径作为存储该资源的键。当判断一个请求是否是请求同样内容时，`Vary`头部可以被用来提醒缓存系统需要注意另一个附加头部。它通常被用来告诉缓存系统同样注意`Accept-Encoding`头部，以便缓存系统能够区分压缩和未压缩的内容。
### Vary头部的隐语
`Vary`头部提供给您存储同一个内容的不同版本的能力，代价是降低了缓存的容量。
在使用`Accept-Encoding`时，设置`Vary`头部允许明确区分压缩和未压缩的内容。这在服务某些不能处理压缩数据的浏览器时很重要，它可以保证基本的可用性。`Vary`的一个典型的值是`Accept-Encoding`，它只有两到三个可选的值。
一开始看上去`User-Agent`这样的头部可以用于区分移动浏览器和桌面浏览器，以便您的站点提供差异化的服务。但`User-Agent`字符串是非标准的，结果将会造成在中间缓存中保存同一内容的许多不同版本的缓存，这会导致缓存命中率的降低。`Vary`头部应该谨慎使用，尤其是您不具备在您控制的中间缓存中使请求标准化的能力（也许可以，比如您可以控制CDN的话）。
### 缓存控制标志怎样影响缓存
上面我们提到了`Cache-Control`头部如何被用与现代缓存策略标准。能够通过这个头部设定许多不同的缓存指令，多个不同的指令通过逗号分隔。
一些您可以使用的指示内容缓存策略的`Cache-Control`的选项如下：
* **`no-cache`**：这个指令指示所有缓存的内容在新的请求到达时必须先重新验证，再发送给客户端。这条指令实际将内容立刻标记为过期的，但允许通过验证手段重新验证以避免重新下载整个内容。
* **`no-store`**：这条指令指示缓存的内容不能以任何方式被缓存。它适合在回复敏感信息时设置。
* **`public`**：它将内容标记为公有的，这意味着它能被浏览器和其他任何中间节点缓存。通常，对于使用了HTTP验证的请求，其回复被默认标记为`private`。`public`标记将会覆盖这个设置。
* **`private`**：它将内容标记为私有的。私有数据可以被用户的浏览器缓存，但*不能*被任何中间节点缓存。它通常用于用户相关的数据。
* **`max-age`**：这个设置指示了缓存内容的最大生存期，它在最大生存期后必须在源服务器处被验证或被重新下载。在现代浏览器中这个选项大体上取代了`Expires`头部，浏览器也将其作为决定内容的新鲜度的基础。这个选项的值以秒为单位表示，最大可以表示一年的新鲜期（31536000秒）。
* **`s-maxage`**：这个选项非常类似于`max-age`，它指明了内容能够被缓存的时间。区别是这个选项只在中间节点的缓存中有效。结合这两个选项可以构建更加灵活的缓存策略。
* **`must-revalidate`**：它指明了由`max-age`、`s-maxage`或`Expires`头部指明的新鲜度信息必须被严格的遵守。它避免了缓存的数据在网络中断等类似的场景中被使用。
* **`proxy-revalidate`**：它和上面的选项有着一样的作用，但只应用于中间的代理节点。在这种情况下，用户的浏览器可以在网络中断时使用过期内容，但中间缓存内容不能用于此目的。
* **`no-transform`**：这个选项告诉缓存在任何情况下都不能因为性能的原因修改接收到的内容。这意味着，缓存不允许压缩接收到的内容（没有从原始服务器处接收过压缩版本的该内容）并发送。
这些选项能够以不同的方式结合以获得不同的缓存行为。一些互斥的值如下：
* `no-cache`，`no-store`以及由其他前面未提到的选项指明的常用的缓存行为
* `public`和`private`
如果`no-store`和`no-cache`都被设置，那么`no-store`会取代`no-cache`。对于非授权的请求的回复，`public`是隐含的设置。对于授权的请求的回复，`private`选项是隐含的。他们可以通过在`Cache-Control`头部中指明相应的相反的选项以覆盖。
### 开发一种缓存策略
在理想情况下，任何内容都可以被尽可能缓存，而您的服务器只需要偶尔的提供一些验证内容即可。但这在现实中很少发生，因此您应该尝试设置一些明智的缓存策略，以在长期缓存和站点改变的需求间达到平衡。
### 常见问题
在许多情况中，由于内容被产生的方式（如根据每个用户动态的产生）或者内容的特性（例如银行的敏感数据），这些内容不应该被缓存。另一些许多管理员在设置缓存时可能面对的问题是外部缓存的数据未过期，但新版本的数据已经产生。
这些都是经常遇到的问题，它们会影响缓存的性能和您提供的数据的准确性。然而，我们可以通过开发提前预见这些问题的缓存策略来缓解这些问题。
### 一般性建议
尽管您的实际情况会指导您选择的缓存策略，但是下面的建议能帮助您获得一些合理的决定。
在您担心使用哪一个特定的头部之前，有一些特定的步骤可以帮助您提高您的缓存命中率。一些建议如下：
* **为图像、CSS和共享的内容建立特定的文件夹**：将内容放到特定的文件夹内使得您可以方便的从您的站点中的任何页面引用这些内容。
* **使用同样的URL来表示同样的内容**：由于缓存使用内容请求中的主机名和路径作为键，因此应保证您的所有页面中的该内容的引用方式相同，前一个建议能让这点更加容易做到。
* **尽可能使用CSS图像拼接**：对于像图标和导航等内容，使用CSS图像拼接能够减少渲染您页面所需要的请求往返，并且允许对拼接缓存很长一段时间。
* **尽可能将主机脚本和外部资源本地化**：如果您使用Javascript脚本和其他外部资源，如果上游没有提供合适的缓存头部，那么您应考虑将这些内容放在您自己的服务器上。您应该注意上游的任何更新，以便更新本地的拷贝。
* **对缓存内容收集文件摘要**：静态的内容比如CSS和Javascript文件等通常比较适合收集文件摘要。这意味着为文件名增加一个独特的标志符（通常是这个文件的哈希值）可以在文件修改后绕开缓存保证新的内容被重新获取。有很多工具可以帮助您创建文件摘要并且修改HTML文档中的引用。
对于不同的文件正确地选择不同的头部这件事，下面的内容可以作为一般性的参考：
* **允许所有的缓存存储一般内容**：静态内容以及非用户相关的内容应该在分发链的所有节点被缓存。这使得中间节点可以将该内容回复给多个用户。
* **允许浏览器缓存用户相关的内容**：对于每个用户的数据，通常在用户自己的浏览器中缓存是可以被接受且有益的。缓存在用户自身的浏览器能够使得用户在接下来的浏览中能够瞬时读取，但这些内容不适合在任何中间代理节点缓存。
* **将时间敏感的内容作为特例**：如果您的数据是时间敏感的，那么相对上面两条参考，应该将这些数据作为特例，以保证过期的数据不会在关键的情况下被使用。例如，您的站点有一个购物车，它应该立刻反应购物车里面的物品。依据内容的特点，可以在`Cache-Control`头部中使用`no-cache`或`no-store`选项。
* **总是提供验证器**：验证器使得过期的内容可以无需重新下载而得到刷新。设置`ETag`和`Last-Modified`头部将允许缓存向原始服务器验证内容，并在内容未修改时刷新该内容新鲜度以减少负载。
* **对于支持的内容设置长的新鲜期**：为了更加有效的利用缓存，一些作为支持性的内容应该被设置较长的新鲜期。这通常比较适合图像和CSS等由用户请求用来渲染HTML页面的内容。和文件摘要一起，设置延长的新鲜期将允许缓存长时间的存储这些资源。如果资源发生改变，修改的文件摘要将会使缓存的数据无效并触发对新的内容的下载。那时，新的支持的内容会继续被缓存。
* **对父内容设置短的新鲜期**：为了使得前面的模式正常工作，容器类的内容应该相应的设置短的新鲜期，或者设置不全部缓存。这通常是在其他协助内容中使用的HTML页面。这个HTML页面将会被频繁的下载，使得它能快速的响应改变。支持性的内容因此可以被尽量缓存。
关键之处便在于达到平衡，一方面可以尽量的进行缓存，另一方面为未来保留当改变发生时从而改变整个内容的机会。您的站点应该同时具有：
* 尽量缓存的内容
* 拥有短的新鲜期的缓存内容，可以被重新验证
* 完全不被缓存的内容
这样做的目的便是将内容尽可能的移动到第一个分类（尽量缓存）中的同时，维持可以接受的缓存命中率。
结论
--
花时间确保您的站点使用了合适的缓存策略将对您的站点产生重要的影响。缓存使得您可以在保证服务同样内容的同时减少带宽的使用。您的服务器因此可以靠同样的硬件处理更多的流量。或许更重要的是，客户们能在您的网站中获得更快的体验，这会使得他们更愿意频繁的访问您的站点。尽管有效的Web缓存并不是银弹，但设置合适的缓存策略会使您以最小的代价获得可观的收获。
---
via: 
作者: [Justin Ellingwood](https://www.digitalocean.com/community/users/jellingwood) 译者：[wwy-hust](https://github.com/wwy-hust) 校对：[wxy](https://github.com/wxy) 推荐：[royaso](https://github.com/royaso)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创翻译，[Linux中国](http://linux.cn/) 荣誉推出