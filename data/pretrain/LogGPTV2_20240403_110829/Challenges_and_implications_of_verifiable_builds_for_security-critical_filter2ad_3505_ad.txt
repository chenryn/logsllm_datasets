ating the build environment, other diﬀerences remain.
In the 32-bit driver, a diﬀerence at ﬁle oﬀset 0x00000270
corresponds to the time/date-stamp in the PE headers. File
oﬀsets 0x0001EA44 and 0x00034184 show the same time-
stamp diﬀerence. More speciﬁcally, the one at 0x0001EA44
matches the timestamp location in the debug directory
structure [30], which contains the address of the debug sec-
tion.
In turns, this debug section is located at ﬁle oﬀset
0x0002CBA8 in the 32-bit driver and oﬀset 0x0002F490 in
the 64-bit driver, where another diﬀerence is found (see
the next paragraph). Similarly, the timestamp at oﬀset
0x00034184 matches the location of the timestamp in the
export directory table. File oﬀset 0x000002C0 is the op-
tional PE checksum header, which also diﬀers for the same
reason as in the previous ﬁles: the ﬁle has slight diﬀerences
that lead to a diﬀerent checksum. File oﬀset 0x00000300
represents the certiﬁcate table diﬀerence, which as we ex-
plained is expected. The end of the original ﬁle contains
the certiﬁcate.
In the PDB debug section, pointed by the debug direc-
tory previously mentioned, we still ﬁnd one diﬀerence of 16
bytes starting at 0x0002CBAC. The format of this section is
undocumented, however it is explained in [19] as containing
a signature (the string “RSDS”), followed by a GUID (Glob-
ally Unique IDentiﬁer) that is regenerated in each build and
is used by the debugger to link a binary ﬁle to its PDB de-
bug ﬁle. Our 16-byte diﬀerence matches the location of the
GUID. Next to it is an “age” ﬁeld followed by the path of
the debug ﬁle, which led to a diﬀerence we had previously
resolved by using the same project path as in the oﬃcial
build. As the project was compiled in release conﬁgura-
tion (not in debug conﬁguration), such information should
not be present at all in the output ﬁles. Their presence
remains unclear.
In versions 6.3 and 6.3a, the readme ﬁle suggests the use
of NASM “version 2.06 or compatible”. However, if we use
version 2.06 during the build process, NASM will crash when
assembling the 64-bit driver. While investigating this prob-
lem, we found a ticket on the NASM bug tracking system [40]
mentioning this speciﬁc issue. The issue has been resolved
in 2.08-rc1, which was released one week before TrueCrypt
v6.3’s realease. One may further correlate this bug ticket
with the internal development of TrueCrypt.
The 64-bit version of the driver, truecrypt-x64.sys, shows
the same patterns. However, in version 6.2 and 6.2a, we
observe an additional diﬀerence spanning on 5 consecutive
bytes at ﬁle oﬀset 0x0001CFCB. Contrary to other diﬀer-
ences that we identiﬁed so far, this one does not aﬀect meta-
data but rather is located in the .text section of the binary
ﬁle, which contains the logic of the driver. Our build reads
0F 1F 44 00 00 while the oﬃcial build reads 66 66 90 66
90. The disassembled binary ﬁles show a more comprehen-
sive comparison shown below.
66 66 90
66 90
data32 xchg ax,ax
xchg
ax,ax
0F 1F 44 00 00
DWORD PTR [rax+rax*1+0x0]
Functionally, both sequences are eﬀectively realizing No
Operation (NOP). These NOPs only serve alignment for
nop
the remaining code. We can ﬁnd a partial explanation for
this diﬀerence in Intel’s documentation [23], which lists se-
quences of various lengths that realize a NOP (in Table 4-9
entitled “Recommended Multi-Byte Sequence of NOP In-
struction”). Our NOP corresponds to a 5-byte NOP in this
table. However, we cannot ﬁnd the oﬃcial build’s NOP se-
quence in this table. The explanation actually lies in the
type of processor used in the build environment. While In-
tel’s documentation recommends 0F 1F 44 00 00 for a 5-
byte NOP, AMD’s documentation [1] recommends 66 66 90
66 90. We can infer that the compiler determines the pro-
cessor it is running on and adapts its output accordingly.
This hypothesis is conﬁrmed after we compiled this version
of TrueCrypt on a machine with an AMD processor. The
5-byte NOP was present as in the oﬃcial build. We can
further deduce that the developers were using an AMD pro-
cessor for the release of versions 6.2 and 6.2a.
3.3.3 TrueCrypt installer
Now that the remaining ﬁles have been analyzed and the
diﬀerences between our build and the oﬃcial one have been
explained, we can package the original ﬁles with our com-
piled installer. After packaging the original ﬁles with our
compiled installer, we obtain an installer of 3,458,614 bytes,
which is close to the original installer’s size (3,466,248 bytes).
Again, the usual time/date-stamp, checksum and certiﬁcate
table diﬀer, and the original installer has a certiﬁcate at the
end of its ﬁle. A new diﬀerence occurs at 0x0034C632 on
4 bytes that look like a checksum. By investigating True-
Crypt’s source code, we can ﬁnd that it is indeed a checksum.
During the packaging of the ﬁles, the installer computes an
integrity checksum over its complete version. At this point,
the installer is not yet signed, which means it does not em-
bed a certiﬁcate and its certiﬁcate table is all zeros. How-
ever, after the installer is signed, it itself needs to be able
to recompute the checksum over its unsigned version. To
achieve this, the installer computes the checksum by replac-
ing bytes between ﬁle oﬀsets 0x00000130 and 0x000001FF
(inclusive) with zeros, so as to zero out the Certiﬁcate Table.
This range however contains more information than just the
certiﬁcate table, speciﬁcally half of the optional PE header
and the whole data directories, including the Export, Im-
port, Resource, Exception, Base Relation, and Import Ad-
dress tables. In practice, erasing this byte range eﬀectively
deletes these ﬁelds in the header, and weakens the coverage
of the integrity check. The installer also truncates the ﬁle
after the magic word “TCINSCRC”, which is located right
before the checksum in question, eﬀectively deleting the dig-
ital signature. The CRC32 computed over this modiﬁed ﬁle
corresponds to the alleged checksum we are investigating.
Version 5.1a was released twice; the second edition was
released the same day as version 6.0. This second edition
repackages the original ﬁles with a new installer derived from
the installer of version 6.0. The main apparent goal was to
update the license shown during the installation. Compar-
ing this new installer with the installer from v6.0 however
shows signiﬁcant diﬀerences. Once disassembled, many ad-
dresses diﬀer, some part of the code is changed (mostly for
alignment), and eight resources are completely diﬀerent. As
the exact source of this new installer was never made avail-
able, we are left with the option of reverse-engineering the
installer or trying to recreate its source, based on the knowl-
edge that it is an intermediate version between 5.1a and 6.0.
After several experiments, we concluded that this installer
comes from v6.0 with changes made to VERSION STRING
and VERSION NUM constants to simulate version 5.1a.
Once compiled, the installer packages the original ﬁles from
v5.1a with the new License.txt ﬁle. Incidentally, when using
this new installer on a system-encrypted environment, the
bootloader installed by the installer is in fact the one from
v6.0 renamed as v5.1a (which caused the diﬀerences in the
resource section as several versions of the bootloader exist
and they are gzipped in that section). This brings another
source of non-determinism, which is any (allegedly unimpor-
tant) code modiﬁcation that the authors made to compile a
build without releasing or documenting them.
3.4 Summary
In this analysis, we showed that the compiled versions 5.0
to 7.1a of TrueCrypt are directly compiled from the available
source code. From a security perspective, this shows True-
Crypt is not backdoored by the developers in a way that is
not visible from the sources, i.e., the provided executables
for Windows are not added with any feature not visible from
the sources; addressing the untrusted authors’ threat.
From a software engineering perspective, our study helps
identify sources of non-determinism in a simple Visual Stu-
dio project over the years, from which many ﬁndings can be
generalized. We now summarize our experience throughout
the 16 versions of TrueCrypt. The most important factor is
the version of the compiler and of the additional resources
required to build the project. We showed that a slight vari-
ation in the version number (or minor update) can signif-
icantly change the output. Then, we revealed a particular
feature in the Microsoft Visual Studio compiler that opti-
mizes the alignment of NOPs according to the recommen-
dations of the manufacturer of the processor on which the
compiler is running, making the build processor-dependent.
We showed that the project path is sometimes stored in the
output and results in cascading variations due to a shifting
eﬀect. Moreover, the instructions provided by the authors
of the software may not be accurate and lead to incomplete
builds as we observed with a bug in the version of NASM
advertised in the readme ﬁle. These instructions may not
be precise enough to avoid ambiguities in version numbers
as we experienced with Visual Studio or Windows SDK; or,
they may be incomplete altogether. In our case, the dd util-
ity was missing. Incomplete code may also be an issue, as
we saw with the second version of v5.1a’s installer.
Furthermore, embedded timestamps proved to be a very
common source of variations, leading to checksum diﬀer-
ences. We also showed that the timestamps and checksums
may not be included only once in a pre-deﬁned location (as
in the PE headers), but also in the resource section of the
binary and they may follow application-speciﬁc algorithms
(as in the case of TrueCrypt’s installer). Debug informa-
tion embeds unique identiﬁers that are randomly generated
during every build. Finally, as embedded digital signatures
are impossible to regenerate, they should either be copied
as is from the oﬃcial build after investigation of their con-
tent, or reside in a separate ﬁle to enable ﬁle-based compar-
ison. We emphasize on the fact that recompiling a project
twice on the same environment does not necessarily exhibit
all sources of non-determinism. One needs to try on diﬀer-
ent environments with various conﬁgurations (e.g., hetero-
geneous CPUs and other hardware) to see all the diﬀerences,
if any. Surprisingly, in our analysis, we did not encounter
any diﬀerences caused with a diﬀerent operating system (we
compiled some versions on both Windows XP and 7).
4. SUMMARY OF CURRENT EFFORTS
In this section, we summarize the eﬀorts from other
projects involving deterministic or reproducible builds. Due
to space limitations, we provide more details about each of
them in an extended version of this work [9].
The most advanced work to date on deterministic builds
is probably the one initiated by Bitcoin, named Gitian [17],
and later adapted by the Tor project for the Tor Browser
Bundle. Gitian provides a virtual environment for Ubuntu
in which various sources of non-determinism can be ﬁxed.
The solution is however diﬃcult to generalize for other open-
source software, and presents several limitations. The adap-
tation by Tor, although not fully satisfactory, may be a step
in the right direction.
Debian focuses on deterministic package build, as pre-
sented by Bobbio at DebConf’13 [4] and FOSDEM’14 [5].
Their approach is still experimental and is based on a spe-
cial branch of the package management tools (dpkg). As of
January 26, 2014, 67% of 6887 source packages were found
reproducible. As an operating system, Debian can aﬀord
changing its own tools for the right purpose. Such liberty
may however not exist in heterogeneous environment shar-
ing both open- and closed-source components.
Other Linux distributions have also started their own pro-
cess towards reproducible/veriﬁable builds. Fedora only fo-
cused on comparing two builds [13], with the underlying
assumption that only predictable diﬀerences will be present.
OpenSUSE also provides build-compare, a script to compare
compiled software packages [34]. However, their approach
remains preliminary as they do not provide a way to recom-
pile a project for veriﬁcation. As we observed in our study,
it may not be always possible to automate the veriﬁcation of
non-deterministic builds. We note nonetheless that a frame-
work for reconstructing the original environment might help
the veriﬁcation of current and past software.
5. RELATED WORK
Related projects about deterministic and veriﬁable builds
have been discussed in Section 4. We present below other
attempts to analyze TrueCrypt, which is the core part of our
case study.
The Ubuntu Privacy Remix Team primarily assessed True-
Crypt 7.0a for Linux in 2011, based on previously unpub-
lished review of past versions 4.2a, 6.1a and 6.3a [45]. They
created a tool, tcanalyzer,4 which helps the study of True-
Crypt containers’ headers. This tool was used to verify the
correctness of both the oﬃcial build and their own build.
They report that they could not ﬁnd mistakes or backdoors
in the encryption or the header format. They further re-
viewed the cryptographic algorithms in TrueCrypt. They
argue about the possibility of hiding a container’s crypto-
graphic keys inside the salt value in the TrueCrypt headers
in Linux or Windows; or, inside an unused section of the
headers in Windows. They advise to recompile the source
rather than using the oﬃcial binaries to prevent such at-
tacks.
It is worth noting that in the Linux version, the