$field = $1;
}else{
sfield = $2;
Sfield =~ s/*"/*/g:
#].
现在可以处理Sfield了...
f
---
## Page 241
扩展的例子
215
将其应用于测试数据，结果为：
[Ten*Thousand][10000] [·2710·][10, 000][It's**10·Grand*, *baby][10K]
看来没问题，但不幸的是它不会输出为空的第四个字段。如果“处理sfie1d”是将字段的
值存入数组，完成后访问数组的第五个元素得到第五个字段（"10，000"）。这显然不对，因
为数组的元素与空字段不对应。
想到的第一个办法是把[^"，+改为（^"，]*，这看来是显而易见的，但它正确吗？
试一下，下面是结果：
[Ten*Thousand][][10000][][·2710·][][][][10,000][][][It's•"10·Grand",
哇，现在出来了一堆空字段！仔细检查检查，就不会这么吃惊。（）*的匹配可以不占用任
何字符。如果真的遇到空字段，确实能匹配，那么考虑第一个字段匹配之后的情况呢，此
时正则表达式从‘Ten·Thousand，1000o..’开始应用。如果表达式中没有元素可以匹配逗
号（就本例来说），就会发生长度为0的成功匹配。实际上，这样的匹配可能有无穷多次，
因为正则引擎可能在同一位置重复这样的匹配，现代的正则引擎会强迫进行驱动过程，所
以同一位置不会发生两次长度为0的匹配（131）。所以每个有效匹配之间还有个空匹
配，在每个引号字段之前会多出一个空匹配（而且数组末尾还会有一个空匹配，只是此处
没有列出来)。
分解驱动过程
要解决问题，我们就不能依赖传动机构的驱动过程来越过逗号。所以，我们需要手工来控
制。能想到的办法有两个：
1.手工匹配逗号。如果采取此办法，需要把逗号作为普通字段匹配的一部分，在字符串中
“迈步（pace ourselves）”。
2.确保每次匹配都从字段能够开始的位置开始。字段可以从行首，或者是逗号开始。
可能更好的办法是把两者结合起来。从第一种办法（匹配逗号本身）出发，只需要保证逗
号出现在第一个字段之外的所有字段开头。或者，保证逗号出现在最后一个字段之外的所
有字段的末尾。可以在表达式前面添加1，，或者后面添加'$！，，用括号控制范围。
---
## Page 242
216
第5章：正则表达式实用技巧
在前面添加，就得到：
(?:1,)
(?：
#引号和运号之外的文本...
（（×"，]*）
#...或者是..
#·：双引号字段（其中客许出现连在一起的成对双引号）
”#起始双引号
（(?：[*]1**)*)
#结束双引号
）
看起来它应当没错，但实际的结果却是：
[Ten*Thousand][10000](·2710·][][][000][][·baby][10K]
而我们期望的是：
[Ten·Thousand][10000][·2710·]{][10,000][It's*"10·Grand",·baby][10K]
问题出在哪里呢？似乎是双引号字段没有正确处理，所以问题出在它身上，对吗？不对，
问题在前面。或许176页的告诫有所帮助：如果多个多选分支能够在同一位量匹配，必须
小心地排列顺序。第一个多选分支[，*不需要匹配任何字符就能成功，除非之后的元
素强迫，否则第二个多选分支不会获得尝试的机会。而这两个多选分支之后没有任何元素，
所以第二个多选分支永远不会得到尝试的机会，这就是问题所在！
哇，现在我们已经找到了问题所在。OK，交换一下多选分支的顺序：
（？：1,）
（？：#或者是匹配双引号字段（其中容许出现连在一起的成对双引号）、·
“#（起始双引号）
((?:["]1"*)*)
“#（起始双引号）
#..，或者是引号和适号之外的文本..
（[=,]*）
）
动过程”，而最保险的办法就是以完整测试作为基础的思考，故可以用G来确保每次匹配
从上一次匹配结束的位置开始。考虑到构建和应用正则表达式的过程，这样做应该绝对没
问题。如果在表达式开始添加G，就会禁止引擎的驱动过程。我们希望这样修改不会出问
---
## Page 243
扩展的例子
217
题，但是结果并非如此。之前输出
[Ten*Thousand][10000][·2710·][][][000][][baby][10K]
的正则表达式添加\G之后，得到
如果起初没看明白，这样看会更明显。
CSVProcessinginJava
这里有一个使用Sun的java.util.regex解析CSV的例子。这段程序着眼于简洁的、
更有效的版本-—第8章（401）将会介绍。
import java.util.regex.*;
Stringregex=//把双引号字段存入group（1）、非引号字段存入group（2）
"\\G(？:1,)
\n*+
* (?:
\n*+
#要么是双引号字段..
\n*+
\"
宇段起始双引号
\n*+
（？：[\=]++1\"\"）*+）
\n"+
\“
#宇段结束双引号
\n"+
|#
要么是
\n" +
#非引号非运号文本
\n"+
（[~\,]*)
\n" +
\n*;
11创建使用上面正则表达式的matcher，暂时不指定需要应用的文本
Matcher mMain = Pattern.compile(regex,Pattern.COMMENTS).matcher("");
//为"创建一个matcher，暂时不指定需要应用的文本
Matcher mQuote =Pattern.compile("\"\"").matcher("*);
//上面都是准备工作，下面的代码逐行处理文本
mMain.reset（line）：//下面处理line中的CSV文本
while (mMain.find())
String field;
if (mMain.start(2) >= 0)
fie1d =mMain.group(2);
//非引号字段，直接使用
else
//引号字段，替换其中的成对双引号
field = mQuote.reset(mMain.group(1)).replaceAll(*\**);
//处理字段...
---
## Page 244
218
第5章：正则表达式实用技巧
另一个办法
本节的开头提到有两种办法正确匹配各个字段。之二是确保匹配只能在容许出现字段的地
方开始。从表面上看，这类似于添加1，，只是使用了逆序环视“（?[^"]+1""）*。下一页用VB.NET的例子做了说明。
如果像Sun的Javaregexpackage那样支持占有优先量词（142），也可以使用占有优先量
词。JavaCSV程序的补充内容说明了这一点。
这些修改背后的道理会在下一章讲解，最终我们会在271页给出效率最高的办法。
其他CSV格式
Microsoft的CSV格式很流行，因为它是Microsoft的CSV格式，但其他程序可能有不同格
式，我见过的情况还有：
·
使用任意字符，例如：·或者制表符作为分隔。（不过这样名字还能叫“逗号分隔值
吗？）
·容许分隔符之后出现空格，但不把它们作为值的一部分。
---
## Page 245
扩展的例子
219
用反斜线转义引号（例如用‘"’而不是‘"’类表示值内部的引号）。通常这意味着
反斜线可以在任何字符前出现（并忽略）。
这些变化都很容易处理。第一种情况只需要把逗号替换为对应的分隔符，第二种只需要在
第-一个分隔符之后添加s*，例如以（？：^1，\B*）开头。
第三种情况，我们可以用之前的办法（198），把[~"]+1""替换为[\\"]+\\.1。当然，
我们必须把后面的s/""/"/g改为更通用的s/\\（.)/$1/g，或者对应语言中的代码。
VB.NET的CSV处理
Imports System.Text.RegularExpressions
Dim FieldRegex as Regex - New Regex(
(？:~1,)
*(?：
#
(?#
要么是双引号宇段...）
&
* 1I
(?#
字段起始双引号）
&
（
(?>
&
#
(?#
宇段结束双引号）
&
(?#
...or
...)
&
&
(?#
非引号非通号文本...）
（[,]*）
&
")",RegexOptions.IgnorePatternWhitespace)
Dim QuotesRegex as Regex = New Regex(**"")
双引号字将串
Dim FieldMatch as Match = FieldRegex.Match(Line)
While FieldMatch.Success
Dim Field as String
If FieldMatch.Groups(1).Success
Field = QuotesRegex.Replace(FieldMatch.Groups(1).Value,
* * = * )
Else
Field = FieldMatch.Groups(2).Value
End If
Console.WriteLine(&Field&
现在可以处理·Field
FieldMatch =FieldMatch.NextMatch
End While
---
## Page 247
第
章
打造高效正则表达式
Crafting an Effcient Expression
Perl、Java、.NET、Python和PHP（这里没有列全，其他语言请参考第145页的表格）使
用的都是表达式主导的NFA引擎，细微的改变就可能对匹配的结果及方式产生重大的影响。
DFA中不存在的问题，对NFA来说却很重要。因为NFA引I擎容许用户进行精确控制，所
以我们可以用心打造（译注1）正则表达式，但对不熟悉的人来说，这样可能会带来麻烦。
本章讲解的就是调校正则表达式的诀窍。
调校表达式时需要考虑的两个因素是准确性和效率：精确匹配我们需要的文本，不包含多
余的内容，而且速度要快。第4章和第5章探讨了准确性，现在我们来考察NFA引擎的效
率，以及如何有效地利用这些知识（我们会在合适的时候提到DFA的问题，不过本章主要
关注的还是基于NFA的引擎）。总的来说，关键在于彻底理解回溯背后的过程，学习些技
巧来避免可能的回溯。在深入了解了处理机制的细节之后，读者不但能够把匹配的速度提
到最高，写更复杂的正则表达式时也会更有信心。
本章内容
为了让读者彻底掌握这些知识，本章首先说明了效率的重要性，然后回顾前几章讲解过的
回溯，重点强调效率和回溯对整个匹配的影响，为掌握高级的技巧做准备。然后我们会考
察一些常见的内部优化措施、它们可能对效率有相当程度的实质性影响：还要讲解，针对
具体实现方式，如何构建最合适的正则表达式。最后，我会做个总结，传授一些终极技巧，
来构建快如雷霆的NFA表达式
---
## Page 248
222
第6章：打造高效正则表达式