# 10丨案例：在JMeter中如何设置参数化数据？今天我们来做一个实例，看下在 JMeter中，如何合理地设置参数化数据。正式场景前的基准测试在没有做业务混合场景之前，我们需要先做 Benchmark测试，来确定一个登录业务能支持多少的业务量，这样就可以在业务混合场景中，根据场景中各业务的比例来确定登录的数据需要多少真实的数据。我们继续用上一篇文章中用户登录的例子，单独测试登录业务，结果如下：    Java    summary +    125 in 00:00:04 =   31.0/s Avg:    28 Min:     0 Max:   869 Err:     0 (0.00%) Active: 1 Started: 1 Finished: 0    summary +   3404 in 00:00:30 =  113.2/s Avg:    31 Min:     0 Max:   361 Err:     0 (0.00%) Active: 6 Started: 6 Finished: 0    summary +   4444 in 00:00:30 =  148.4/s Avg:    57 Min:     0 Max:   623 Err:    10 (0.23%) Active: 11 Started: 11 Finished: 0从上面的结果可以看到登录业务能达到的 TPS 是 113 左右，这里我们取整为100，以方便后续的计算。在测试工具中配置参数在上面的试探性测试场景中，不需要观察系统的资源，只需要根据 TPS做相应的数据统计即可。前面我们知道，在这个示例中只做了近 10万条的用户数据，为了方便示例进程。下面我们从数据库中查询可以支持登录 5分钟不重复的用户数据。根据前面的公式，我们需要 30000条数据。     Java    100x5mx60s=30000 条接下来连接数据库，取 30000条数据，存放到文本中，如下所示：    Java    username,password    test00001,test00001    test00002,test00002    test00003,test00003    test00004,test00004    test00005,test00005    test00006,test00006    test00007,test00007    ...................    test30000,test30000参数化配置在 JMeter 中的使用说明我们将这些用户配置到测试工具的参数当中，这里以 JMeter 的 CSV Data Set Config 功能为例。配置如下：![](Images/c4197df2d50e8d9b0a54f0391a2c416b.png)savepage-src="https://static001.geekbang.org/resource/image/d4/a6/d40134621469079dd7b9de6e19165ca6.png"}在 JMeter的参数化配置中，有几个技术点，在这里说明一下。"Allow quoted data?"这里有两个选择，分别是 False 和True。它的含义为是否允许带引号的数据，比如说在参数化文件中有这样的数据。    Java    "username","password"    "test00001","test00001"    "test00002","test00002"    ...................    "test30000","test30000"如果有引号，这个选择必须是 True。如果设置为False，那么我们在脚本中会看到如下的数据：    Java    username=%22test00001%22password=%22test00001%22由于设置为 False，JMeter 将（\"）转换为了 %22 的 URL编码，很显然这个数据是错的。如果选择为True，则显示如下：    Java    username=test00001password=test00001这里就显示对了。除此之外，还有如下几个功能点需要说明：1.  Recycle on EOF? ：这里有三个选择，False、True 和    Edit。前两个选择非常容易理解。False    是指在没有参数的时候不循环使用；True    是指在没有参数的时候循环使用。Edit    是指在没有参数的时候会根据定义的内容来调用函数或变量。        2.  Stop thread on EOF?：这里有三个选择，False、True 和    Edit。含义和上面一致。        3.  Sharing mode : 这里有四个选择，All threads、Current thread    group、Current    thread、Edit。        Sharing mode的前三个选择是比较容易理解的，参数是在所有线程中生效，在当前线程组生效，还是在当前线程中生效。但这里的Edit 和前两个参数中的 Edit 相比，有不同的含义。这里选择了 Edit之后，会出现一个输入框，就是说这里并不是给引用函数和参数使用的，而是要自己明确如何执行Sharing mode。那如何来使用呢？举例来说，假设我们有 Thread Group 1-5四个线程组，但是参数化文件只想在 Thread Group 1、3、5中使用，不想在线程组 2、4中使用，那么很显然前面的几个选项都达不到目的，这时我们就可以选择 Edit选项，在这里输入`SharedWithThreadGroup1and3and5`。而在其他的线程组中配置其他参数化文件。也就是说同样的一个变量名，在线程组 1/3/5 中取了一组数据，在线程组 2/4中取了另一组数据。以上三个参数的选项可以随意组合。于是就会得到如下表。**需要注意的是，EOF是文件结束符的意思。在下面的解释中，为了更符合性能测试中的术语，特意解释为参数不足时。**以上三个功能点根据参数设计得不同，会产生不同的组合，我们依次查看一下。![](Images/a416bca0fcab89141dad62914927cd69.png)savepage-src="https://static001.geekbang.org/resource/image/b7/8a/b7e601e7d28dae9d1aa295ff561a8f8a.png"}这个组合显然是矛盾的，没有参数时不让循环，还不让停止线程，这不是耍流氓吗？真实的结果是什么呢？当我们执行时就会发现，参数变成了这样：    username=%3CEOF%3E&password=%3CEOF%3E服务端果然返回了：`{"flag":false,"errMsg":"账号不存在"}`。![](Images/f8c66e35df62ab2efb2152b23833fe20.png)savepage-src="https://static001.geekbang.org/resource/image/00/8f/00e6f263f3da8ac27fd305ef9984db8f.png"}这个组合中第二个选项显然是没意义的，既然参数允许重复使用了，又怎么会发生参数不足停止线程的情况呢？![](Images/3a1b5daf03b3a7797c59ea5e20e7857b.png)savepage-src="https://static001.geekbang.org/resource/image/10/e4/10c0899e9e315699ac0b64376efe8ee4.png"}这个组合因为第一个选项为"Edit"所以变得不确定了，如果在 Edit的函数或变量返回为 True，则和第 2 种组合一样；如果返回为 False，则和第 1种组合一样。![](Images/9a7a50de688ba9bbb87e1ce4aaa48817.png)savepage-src="https://static001.geekbang.org/resource/image/f1/84/f1a4ba678516f8645713a4ea67160b84.png"}这是一个完全合情合理的组合！![](Images/0a03587cc550fe27aeeb6ee4aee53cc3.png)savepage-src="https://static001.geekbang.org/resource/image/6b/19/6bc0c30057843b67f2fd354413316219.png"}同第二个组合一样，第二个选项显然没有意义。![](Images/46bd963e4abba84d495d9f1d735de49f.png)savepage-src="https://static001.geekbang.org/resource/image/eb/e5/ebd582384b9b0e472d574242ecdb86e5.png"}这个组合同样因为第一个选项为 Edit，所以变得不确定了，如果在 Edit的函数或变量返回为 True，则和第 3 种组合一样；如果返回为 False，则和第 4种组合一样。![](Images/64afc4eb20f0bf7a4846ff18a99b18d5.png)savepage-src="https://static001.geekbang.org/resource/image/7a/67/7abe03f34c1eb34e1f526bfe87fbc567.png"}这个组合因为是否停止线程的不确定性会出现两种可能，有可能是第 1种组合，也有可能是第 4 种组合。![](Images/3ecf6126de90ef1be8560f37882d5d5b.png)savepage-src="https://static001.geekbang.org/resource/image/c7/16/c774e067c8546ba135154ec036931c16.png"}这个组合中是否停止线程的 Edit配置没有意义，因为可循环使用参数，所以不会发生参数不足导致线程停止的情况。![](Images/846f69e945ef2db3f22edc9dde9e7f8b.png)savepage-src="https://static001.geekbang.org/resource/image/9d/62/9d2bf655d7390101e6047bba65631862.png"}这是一个古怪的组合，具有相当的不确定性，有可能变成第 1、2、4、5种组合。 下面我们再来看下其他衍生的设置组合。![](Images/d5f8ef7affa52e1e8644f98ed80d6a35.png)savepage-src="https://static001.geekbang.org/resource/image/b5/99/b5cc19c445317691c6d609219bd5ff99.jpg"}真实场景下的 JMeter 参数配置和执行结果根据以上的描述，我们先用 10 个用户来测试下，将 Stop`thread on EOF?`改为True，将`Recycle on EOF?`改为False，其他不变。同时将线程组中配置为 1 个线程循环 11次。这样设置的目的是为了看在数据不足时，是否可以根据规则停掉线程组。如下所示：![](Images/c4197df2d50e8d9b0a54f0391a2c416b.png)savepage-src="https://static001.geekbang.org/resource/image/d4/a6/d40134621469079dd7b9de6e19165ca6.png"}线程组配置如下：![](Images/5bcee3a2675e42441d3fe0c57a40c761.png)savepage-src="https://static001.geekbang.org/resource/image/d2/3f/d26aeda4baea18631966b15dd5084a3f.png"}执行之后，我们会在日志中看到如下信息：    Java    2019-09-05 22:56:30,171 INFO o.a.j.t.JMeterThread: Stop Thread seen for thread Thread Group 1 1-1, reason: org.apache.jorphan.util.JMeterStopThreadException: End of file:/Users/Zee/Downloads/user10.csv detected for CSV DataSet:CSV Data Set Config configured with stopThread:true, recycle:false可以看到在参数用完又不可循环使用参数的情况下，JMeter主动停止了线程。我们延续使用上文中场景二的条件，即希望场景中每个线程的每次迭代都用不同的数据。为了能很快地整理出实际的结果，我们只使用 10条数据来模拟，条件设置如下：    线程组：2    线程（每线程组）：6    参数化数据：10 条执行完场景后，会在日志中看到如下信息：    Java    2019-09-07 23:24:25,585 INFO o.a.j.t.JMeterThread: Stop Thread seen for thread Thread Group 1 1-1, reason: org.apache.jorphan.util.JMeterStopThreadException: End of file:/Users/Zee/Downloads/user10.csv detected for CSV DataSet:CSV Data Set Config configured with stopThread:true, recycle:false    2019-09-07 23:24:25,452 INFO o.a.j.t.JMeterThread: Stop Thread seen for thread Thread Group 1 1-2, reason: org.apache.jorphan.util.JMeterStopThreadException: End of file:/Users/Zee/Downloads/user10.csv detected for CSV DataSet:CSV Data Set Config configured with stopThread:true, recycle:false    2019-09-07 23:24:23,406 INFO o.a.j.t.JMeterThread: Stop Thread seen for thread Thread Group 2 2-1, reason: org.apache.jorphan.util.JMeterStopThreadException: End of file:/Users/Zee/Downloads/user10.csv detected for CSV DataSet:CSV Data Set Config configured with stopThread:true, recycle:false    2019-09-07 23:24:25,517 INFO o.a.j.t.JMeterThread: Stop Thread seen for thread Thread Group 2 2-2, reason: org.apache.jorphan.util.JMeterStopThreadException: End of file:/Users/Zee/Downloads/user10.csv detected for CSV DataSet:CSV Data Set Config configured with stopThread:true, recycle:false可见所有的线程都按我们的配置停止了线程，同时各线程取得参数如下表所示：![](Images/068e174f855d79d20debebd1cce2fdaa.png)savepage-src="https://static001.geekbang.org/resource/image/fe/29/fe0f0ad5af8a526b6fa2ecbddb2da829.png"}每次执行场景会有不同，不同点是线程组 1 有可能执行 6 次，而线程组 2只执行 4 次；或者线程组 1 中的线程 2执行次数比线程 1执行次数多。但总体执行次数会是 10次。 如果数据可以被线程平均分配，则每个线程的迭代次数会相同。如果数据不能被线程平均分配，则每个线程的迭代次数不会相同，但相差不会大。参数化配置在 LoadRunner 中的使用说明在 LoadRunner中参数配置页面如下：![](Images/19c898193c6dd3ce3f49073ef9a5d4e7.png)savepage-src="https://static001.geekbang.org/resource/image/88/a7/88659e50f65ba8cb8005aa2e82c742a7.png"}它的取值组合如下所示：![](Images/735129d7d9018ad08592debc35fd8985.png)savepage-src="https://static001.geekbang.org/resource/image/73/f2/733a30c107112ca08147fceef837a4f2.png"}以上的组合中，组合 7 对应着上文中 JMeter真实场景中每次迭代取不同数据的组合，即 JMeter 中的参数组合4。 总结通过今天的内容，我们对性能测试中的参数化做了一次解析，在执行性能测试时，我们需要根据实际的业务场景选择不同的数据量和参数设置组合。不同的压力工具在参数化的实现逻辑上也会不同，但是参数化必须依赖业务逻辑，而不是工具中能做到什么功能。所以在参数化之前，我们必须分析真实业务逻辑中如何使用数据，再在工具中选择相对应的组合参数的方式去实现。这里我总结一下性能工作中参数化的逻辑，希望对你有所启发。1.       分析业务场景；        2.       罗列出需要参数化的数据及相对应的关系；        3.       将参数化数据从数据库中取出或设计对应的生成规则；        4.       合理地将参数化数据保存在不同的文件中；        5.       在压力工具中设置相应的参数组合关系，以便实现模拟真实场景。        通过以上步骤，我们就可以合理的参数化数据，模拟出真实场景。思考题你可以思考一下下面几个问题：1.       为什么参数化数据要符合生产环境的数据分布？        2.       为什么参数化数据要关注组合逻辑关系，而不是随意设置组合？        欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。
# 11丨性能脚本：用案例和图示帮你理解HTTP协议当前使用得最为广泛的应用层协议就是 HTTP了。我想了好久，还是觉得应该把 HTTP协议写一下。因为做性能测试分析的人来说，HTTP 协议可能是绕不过去的一个槛。在讲HTTP之前，我们得先知道一些基本的信息。HTTP（HyperText TransferProtocol，超文本传输协议），显然是规定了传输的规则，但是它并没有规定内容的规则。HTML（HyperText MarkedLanguage，超文本标记语言），规定的是内容的规则。浏览器之所以能认识传输过来的数据，都是因为浏览器具有相同的解析规则。希望你先搞清楚这个区别。我们首先关注一下 HTTP交互的大体内容。想了很久，画了这么一张图，我觉得它展示了我对 HTTP协议在交互过程上的理解。![](Images/75e28dade3f432a2f5045d4bf2ee81a4.png)savepage-src="https://static001.geekbang.org/resource/image/5f/ba/5fe0f2607000183eb8375cb66cfd41ba.jpg"}在这张图中，可以看到这些信息：1.       在交互过程中，数据经过了 Frame、Ethernet、IP、TCP、HTTP    这些层面。不管是发送和接收端，都必须经过这些层。这就意味着，任何每一层出现问题，都会影响    HTTP 传输。        2.       在每次传输中，每一层都会加上自己的头信息。这一点要说重要也重要，说不重要也不重要。重要是因为如果这些头出了问题，非常难定位（在我之前的一个项目中，就曾经出现过    TCP 包头的一个 option 因为 BUG    产生了变化，查了两个星期，一层层抓包，最后才找到原因）。不重要是因为它们基本上不会出什么问题。        3.       HTTP 是请求 -    应答的模式。就是说，有请求，就要有应答。没有应答就是有问题。        4.       客户端接收到所有的内容之后，还要展示。而这个展示的动作，也就是前端的动作。        **在当前主流的性能测试工具中，都是不模拟前端时间的**        **，**        比如说    JMeter。我们在运行结束后只能看到结果，但是不会有响应的信息。你也可以选择保存响应信息，但这会导致压力机工作负载高，压力基本上也上不去。也正是因为不存这些内容，才让一台机器模拟成千上百的客户端有了可能。        如果你希望能理解这些层的头都是什么，可以直接抓包来看，比如如下示图：![](Images/fbfab7a3432d7dc3af367e05797dd557.png)savepage-src="https://static001.geekbang.org/resource/image/5c/06/5cb8a2717a30ab54334728e8e7658306.png"}从这个图中，我们就能看到各层的内容都是什么。当然了，这些都属于网络协议的知识范围，如果你有兴趣，可以去看一下《TCP/IP详解 卷 1：协议》。我们还是主要来说一说 HTTP层的内容。同样，我希望通过最简单的示例的方式，给你解释一下 HTTP的知识，而不是纯讲压力工具，或纯理论。在我看来，只有实践的操作和理论的结合，才能真正的融会贯通。只讲压力工具而不讲原理，是不可能学会处理复杂问题的；空有理论没有动手能力是不可能解决实际问题的。由于压力工具并不处理客户端页面解析、渲染等动作，所以，以下内容都是从协议层出发的，不包括前端页面层的部分。JMeter 脚本在这里，我写了一个简单的 HTTP GET 请求（由于 HTTP2.0在市场上还没有普及，所以这里不做特别说明的话，就是HTTP1.1）。 ![](Images/d8c43acc4540a9e353b0d0c151ae863a.png)savepage-src="https://static001.geekbang.org/resource/image/d1/21/d1dd869b165bf14a06102d452a3a6921.png"}在前面的文章中，我已经写过了 HTTP GET 和 POST请求。在这里只解释几个重要信息：第一个就是 Protocol。这个当然重要。从"HTTP"这几个字符中，我们就能知道这个协议有什么特点。HTTP 的特点是建议在 TCP 之上、无连接（TCP就是它的连接）、无状态（后来加了 Cookies、Session 技术，用 KeepAlive来维持，也算是有状态吧）、请求 -响应模式等。第二个是 Method 的选项 GET。HTTP 中有多少个 Method 呢？我在这里做个说明。在 RFC 中的 HTTP相关的定义中（比如 RFC2616、2068），定义了 HTTP的方法，如下：GET、POST、PUT、PATCH、DELETE、COPY、HEAD、OPTIONS、LINK、UNLINK、PURGE。回到我们文章中的选项中来。GET方法是怎么工作的呢？>  > The GET method means retrieve whatever information (in the form of> an entity) is identified by the> Request-URI.> > >也就是说，GET 可以得到由 URI请求（定义）的各种信息。同样的，其他方法也有清楚的规定。我们要注意的是，HTTP只规定了你要如何交互。它是交互的协议，就是两个人对话，如何能传递过去？小时候一个人手上拿个纸杯子，中间有根线，相互说话能听到，这就是协议。第三个是 Path，也就是请求的路径。这个路径是在哪里规定的呢？在我这个Spring Boot 的示例中。       @RequestMapping(value = "pabcd")        public class PABCDController {            @Autowired            private PABCDService pabcdService;            @Autowired            private PABCDRedisService pabcdRedisService;            @Autowired            private PABCDRedisMqService pabcdRedisMqService;            @GetMapping("/redis_mq/query/{id}")            public ResultVO getRedisMqById(@PathVariable("id") String id) {                User user = pabcdRedisMqService.getById(id);                return ResultVO.builder().success(user).build();            }看到了吧。因为我们定义了 request 的路径，所以，我们必须在 Path中写上`/pabcd/redis_mq/query`这样的路径。第四个是 Redirect，重定向。HTTP 3XX的代码都和重定向有关，从示意上来看，如下所示。![](Images/8329f430fed63a975ab5f7ee0ab10bce.png)savepage-src="https://static001.geekbang.org/resource/image/1d/73/1d03ddd7a269480b0e38dec3c6bb0f73.jpg"}用户发了个 URL A 到服务 A 上，服务 A 返回了 HTTP 代码 302 和 URL B。这时用户看到了接着访问 URL B，得到了服务 B 的响应。对于 JMeter来说，它可以处理这种重定向。第五个是 Content-Encoding，内容编码。它是在 HTTP的标准中对服务端和客户端之间处理内容做的一种约定。当大家都用相同的编码时，相互都认识，或者有一端可以根据对端的编码进行适配解释，否则就会出现乱码的情况。默认是UTF8。但是我们经常会碰到这种情况。当我们发送中文字符的时候。比如下面的名字。![](Images/b5614c03fb3305d1d39451451a6057d0.png)savepage-src="https://static001.geekbang.org/resource/image/d5/0e/d56493383d4c80469d9af7960e94830e.png"}当我们发送出去时，会看到它变成了这种编码。如下图所示：![](Images/af1246c317adf205bb856912ca8e1e91.png)savepage-src="https://static001.geekbang.org/resource/image/c1/d0/c1884e6b0a4e071edc0d1e17b8ba3fd0.png"}如果服务端不去处理，显然交互就错了。如下图所示：![](Images/2885853a8f0425e1665cf0d516e86582.png)savepage-src="https://static001.geekbang.org/resource/image/73/3a/73680e9d1fb278dbd0ab144ffe8a373a.png"}这时，只能把配置改为如下：![](Images/092796e04f3b5e792ed4d0620bfbb93c.png)savepage-src="https://static001.geekbang.org/resource/image/6c/49/6c48ebfddff84238fb5ea01a175eb449.png"}我们这里用 GBK来处理中文。就会得到正确的结果。![](Images/21b523d888468a565d0e34d9d361a9ff.png)savepage-src="https://static001.geekbang.org/resource/image/6d/5f/6dbc3c868b1790c001942bd9d777df5f.png"}你就会发现现在用了正常的中文字符。在这个例子，有人选择用 URL编码来去处理，会发现处理不了。这是需要注意的地方。第六个是超时设置。在 HTTP协议中，规定了几种超时时间，分别是连接超时、网关超时、响应超时等。如下所示，JMeter中可以设置连接和响应超时：![](Images/ac9cce9c7ed59ace66ef8d4157478de6.png)savepage-src="https://static001.geekbang.org/resource/image/3b/fd/3b0b351b50b2deeb1cbc6853eeb886fd.png"}在工具中，我们可以定义连接和响应的超时时间。但通常情况下，我们不用做这样的规定，只要跟着服务端的超时走就行了。但在有些场景中，不止是应用服务器有超时时间，网络也会有延迟，这些会影响我们的响应时间。如果HTTP 默认的 120s超时时间不够，我们可以将这里放大。在这里为了演示，我将它设置为100ms。我们来看一下执行的结果是什么样。![](Images/7bae6b2f92f741ad2285e22f12170bea.png)savepage-src="https://static001.geekbang.org/resource/image/ab/50/ab12ae557c1a89cb74de32c0a8ed4a50.png"}从栈的信息上就可以看到，在读数据的时候，超时了。超时的设置是为了保证数据可以正常地发送到客户端。做性能分析的时候，经常有人听到"超时"这个词就觉得是系统慢导致的，其实有时也是因为配置。通常，我们会对系统的超时做梳理，每个服务应该是什么样的超时设置，我们要有全局的考量。比如说：![](Images/c306914662eeeaf8469664cacd4d5e75.png)savepage-src="https://static001.geekbang.org/resource/image/34/13/34e07921468afe8d5bba61093de97813.jpg"}超时应该是逐渐放大的（不管你后面用的是什么协议，超时都应该是这个样子）。而我们现在的系统，经常是所有的服务超时都设置得一样大，或者都是跟着协议的默认超时来。在压力小的时候，还没有什么问题，但是在压力大的时候，就会发现系统因为超时设置不合理而导致业务错误。如果倒过来的话，你可以想像，用户都返回超时报错了，后端还在处理着呢，那就更有问题了。而我们性能测试人员，都是在压力工具中看到的超时错误。如果后端的系统链路比较长，就需要一层层地往后端去查找，看具体是哪个服务有问题。所以在架构层级来分析超时是非常有必要的。![](Images/ac9cce9c7ed59ace66ef8d4157478de6.png)savepage-src="https://static001.geekbang.org/resource/image/3b/fd/3b0b351b50b2deeb1cbc6853eeb886fd.png"}在上图中，还有一个参数是客户端实现（ClientImplementation）。其中有三个选项：空值、HTTPClient4、Java。官方给出如下的解释。JAVA： 使用 JVM 提供的 HTTP 实现，相比 HttpClient实现来说，这个实现有一些限制，这个限制我会在后面提到。HTTPClient4：使用 Apache 的 HTTP 组件 HttpClient 4.x实现。 空值：如果为空，则依赖 HTTP Request默认方法，或在`jmeter.properties`文件中的`jmeter.httpsample`定义的值。用 JAVA实现可能会有如下限制。1.       在连接复用上没有任何控制。就是当一个连接已经释放之后，同一个线程有可能复用这个已经释放掉的连接。        2.       API    最适用于单线程，但是很多设置都是依赖系统属性值的，所以都应用到所有连接上了。        3.       不支持 Kerberos    Authentication（这是一种计算机网络授权协议，用在非安全网络中，对个人通信以安全的手段进行身份认证）。        4.       不支持通过 keystore    配置的客户端证书。        5.       更容易控制重试机制。        6.       不支持 Virtual hosts。        7.       只支持这些方法： GET、POST、HEAD、OPTIONS、PUT、DELETE 和    TRACE。    8.       使用 DNS Cache Manager 更容易控制 DNS    缓存。    第八个就是 HTTP层的压缩。我们经常会听到在性能测试过程中，因为没有压缩，导致网络带宽不够的事情。当我们截获一个HTTP 请求时，你会看到如下内容。![](Images/929427528b8d04c5d44cdab955f9acba.png)savepage-src="https://static001.geekbang.org/resource/image/3a/64/3a339b618e592c19493cd6acce810364.png"}这就是有压缩的情况。在我们常用的 Nginx中，会用如下常见配置来支持压缩：        gzip  on;   
# 打开 gzip        gzip_min_length 2k; 