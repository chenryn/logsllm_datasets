Host
phys 0 x10ba10000 = Paging
mem 0 x01020000
12
Host
phys 0 x10ba18000 = Paging
mem 0 x01028000
13
Host
phys 0 x10ba20000 = Paging
mem 0 x01030000
14
Host
phys 0 x10ba28000 = Paging
mem 0 x01038000
Listing 19. Extracting the conﬁguration of the paging memory, from the chip
If
the
chip
does
not
keep
all
pages
when
processing
the
FW_PAGING_BLOCK_CMD command, how is it able to use this memory?
By accessing memory through the debug ﬁlesystem, we conﬁrm that the
memory located at addresses 0x01000000, 0x01008000, etc. is indeed
readable and writable. The answer is: by using the Memory Management
Unit!
Indeed the UMAC processor deﬁned handlers for the exception vec-
tors TLBMissI and TLBMissD (at addresses 0xc0080108 and 0xc0080110)
which occur when a memory access fails. These handlers integrate a com-
plex state machine which loads the requested memory page from the host
using DMA, in a memory area between 0x00422000 and 0x00447fff. To
conﬁrm that the analysis is correct, we read the global variables used by
this state machine, which include an array at 0x804508b8. For example,
in an experiment this array starts with the bytes ff ff 10 ff 0b ff.
Every byte is related to a virtual memory page.
— The ﬁrst byte is 0xff, meaning that the ﬁrst page (at 0x01000000)
is not currently mapped by the chip.
— The second byte was 0xff, meaning that the page at 0x01001000
is not mapped.
— The third byte, 0x10, means that the page at 0x01002000
is mapped at physical address 0x00422000 + 0x10*0x1000 =
0x00432000 of the chip. This is conﬁrmed by reading the data
stored at this address directly.
— etc.
The Wi-Fi chip has space for 38 4KB-pages and the ﬁrmware deﬁnes
59 pages so it is impossible to load all of them simultaneously. Moreover
these regions contain global variables which are updated by the ﬁrmware.
How does the ﬁrmware keep the modiﬁed bytes when some room is needed
to load a newly requested page? By sending another DMA request to
write the modiﬁed bytes to the host memory. And indeed, using chipsec
to read the host physical memory, we observe that the buﬀer allocated for
this Paging memory is modiﬁed.
N. Iooss, G. Campana
23
In short, the code running on the UMAC processor uses its MMU to
extend its memory capacity, by relying on DMA transfers with the host
memory to store the data which do not ﬁt.
Protecting the integrity of the Paging Memory Once we understood
the mechanism of the Paging Memory, we tried an obvious attack: we
modiﬁed a byte in the host memory and made the Wi-Fi chip request it
by issuing a command to read memory. This failed (the UMAC reported a
NMI_INTERRUPT_UMAC_FATAL error and iwlwifi restarted the chip), and
we did not understand why. How is the integrity of the Paging Memory
guaranteed?
The function which handles command FW_PAGING_BLOCK_CMD performs
some operations that we ﬁrst overlooked:
— It writes the address 0x8048f400 in the peripheral register
0x00a0482c and 0x1000 in 0x00a0480c.
— Before receiving a page (to verify the signature), it writes the
physical address of the received page in 0x00a04808, the index of
the virtual page in 0x00a04804, and 1 in 0x00a04800.
— After receiving a page, it waits for some bits in the peripheral
register 0x00a04800 to become set.
These registers are also used near the code which performs DMA
requests. Maybe they are used to compute some digest of the data? Where
would these digests be stored? Maybe at the ﬁrst address which is used,
0x8048f400 (which is the physical address 0x0048f400). Surprisingly, the
content at this location is not readable using the debug commands used
by iwlmvm/mem. This limitation is due to a check which forbade reading
any data between 0x0048f000 and 0x0048fffff. Fortunately we are not
stopped by this, as we are able to load a modiﬁed ﬁrmware without this
restriction.
After more experiments, we discover that 0x0048f400 holds a table
of 32-bit checksums for each 4 KB page of the Paging Memory. The
checksum of the ﬁrst page (whose virtual address is 0x01000000) is located
at 0x0048f400, the checksum of the second one at 0x0048f404, etc. In
an experiment, we obtain that:
— the checksum of a page with 4096 zeros is 00 00 00 00,
— A page with 4095 zeros and 01 has checksum 11 ac d8 7f
— A page with 4095 zeros and 02 has checksum 22 58 b1 ff
— A page with 4095 zeros and 03 has checksum 33 f4 69 80
— A page with 4095 zeros and 04 has checksum c9 b0 62 ff
24
Ghost in the Wireless, iwlwiﬁ edition
These values are not so random: they are linear with the input! By
XOR-ing the results of the lines with 01 and 02, we obtain the result
written in the line with 03. Also taking the bytes of the line with 01
and shifting them left one bit gives the result of the line with 02, with
a bit moved from ac to b1. Continuing this trail, we found out that the
computation involved a 32-bit Linear Feedback Shift Register (LFSR) on
the input bytes considered as a sequence of 32-bit Little Endian integers,
with polynomials 0x10000008d. But it is not only an LFSR, as values
change every time the chip is reset.
More experiments reduce the algorithm to the Python function pre-
sented in listing 20. Discussions within our awesome team made us under-
stand we were watching a scheme named Universal Message Authentication
Code, and our implementation actually matches the example written on
Wikipedia.27
1
def
checksum (page , secret_key ):
2
# Return
the
checksum
of a 4096 - byte
page
with a 1024 - int
key
3
result = 0
4
for
index_32bit_word
in
range (1024):
5
page_bytes = page[ index_32bit_word *4: index_32bit_word *4+4]
6
page_value = int. from_bytes (page_bytes , "little")
7
8
sec = secret_key [ index_32bit_word ]
9
for
bit_pos
in
range (32):
10
if
page_value & (1 << bit_pos ):
11
result
^= sec
12
13
# Linear
Feedback
Shift
Register
with 0 x10000008d
14
if sec & 0 x80000000 :
15
sec = (( sec & 0 x7fffffff ) << 1) ^ 0x8d
16
else:
17
sec = sec
<< 1
18
return
result
Listing 20. Python implementation of the checksum algorithm used to ensure
the integrity of the Paging Memory
This algorithm is quite weak in this case: in our study we were able to
request the checksums for pages containing bytes 01 00...00, 00 00 00
00 01 00...00, etc., which directly leaks the 1024 integers used in the
secret key. With this key, it is simple to modify a page in a way which
does not modify the checksum.
In short, the integrity of the Paging Memory, which prevents the Linux
kernel from modifying its content, is guaranteed by a 32-bit checksum
algorithm, a secret key generated each time the chip boots and the impos-
sibility to read the stored checksums (we achieved this by compromising
27 https://en.wikipedia.org/wiki/UMAC#Example (accessed on 2022-01-17)
N. Iooss, G. Campana
25
the integrity of the ﬁrmware beforehand). So we did not discover a vulner-
ability there, but a way to leverage future arbitrary-read vulnerabilities
into arbitrary code execution on the Wi-Fi chip.
4.2
Instrumentation, Tooling and Fuzzing
Debugger A debugger has been developed to make the dynamic analysis
of some pieces of ﬁrmware code easier.
A shellcode is ﬁrst written in a part of uninitialized ﬁrmware memory.
The ﬁrst instruction of the debugged code is modiﬁed to redirect the
ﬁrmware execution to the shellcode. The shellcode waits in a loop for
custom commands from the host to:
— read and write LMAC and UMAC CPU registers,
— read and write from/to memory,
— resume the execution of the ﬁrmware.
In order to make debugging faster, an experiment has been conducted
with QEMU to redirect the execution of the debugged code in QEMU,
and forward the memory and register accesses to the debugger. Slight
modiﬁcations of QEMU’s core are required to allow QEMU’s plugin system
to write to memory.
Nevertheless, a few issues are encountered:
— Firmware timers are triggered at regular intervals, disturbing de-
bugging. Disabling these timers leads to unexpected side eﬀects.
— Extension Core Registers are modiﬁed by the hardware even if
executed instructions don’t reference them.
— A few ARC700 instructions must be ﬁxed or added to QEMU.
Traces Once secure boot is disabled and unsigned ﬁrmware can be loaded,
the ﬁrmware can be patched to change the behavior of some functions. In
order to facilitate ﬁrmware analysis, a tracing mechanism was developed
to tell dynamically which functions are executed.
The list of all ﬁrmware functions is retrieved thanks to a custom
Ghidra script. These functions are patched to replace the ﬁrst prologue
instruction (push_s blink) with the instruction trap_s 0. The code of
the associated interrupt handler is replaced to store the address of the
instruction which triggered the interrupt, in a buﬀer shared with the host.
This mechanism allows to gather every function executed by the
ﬁrmware, but it’s slightly more complicated on the UMAC processor:
— The instruction trap_s 0 triggers an unrecoverable machine check
exception. An invalid instruction seems to trigger a diﬀerent in-
26
Ghost in the Wireless, iwlwiﬁ edition
terrupt handler, but it can also be replaced to store the faulty
instruction.
— Some functions can’t be instrumented because triggering an in-
terrupt during their execution seems to lead to a machine check
exception, probably because of a double fault.
On-Chip Fuzzing In order to ﬁnd vulnerabilities, the code of the
ﬁrmware has been modiﬁed to hook some functions related to Wi-Fi
packets parsing and fuzz randomly input parameters. While it indeed
leads to crashes, these functions use hardware registers which make crashes
bound to the state of the card. Crashes are thus diﬃcult to reproduce.
Moreover, some checks on packet validity seem to be done by the hard-
ware, before packets are handled by the ﬁrmware. These crashes can’t be
reproduced through remote frame injection.
4.3
Initial crash analysis
Further analysis showed that the initial bug that led to this study isn’t
exploitable. It’s a crash of the LMAC CPU because the ﬁrmware doesn’t
expect to receive TDLS Setup Request commands from the host, while
the device seems to support TDLS (Tunnel Direct Link Setup, listing 21).
1
$ iw phy | grep -i tdls
2
* tdls_mgmt
3
* tdls_oper
4
Device
supports
TDLS
channel
switching
Listing 21. Querying TDLS support on the ﬁrst studied chip
Several users reported this crash on the Kernel Bug Tracker 28 and
the bug is actually ﬁxed since ﬁrmware update 36.29 As explained by the
maintainer in this comment:
Anyway, the new ﬁrmware has the ﬁx: we don’t advertise TDLS
anymore.
It’s worth noting that even if a ﬁrmware update is available, some
Linux distributions don’t include it. For instance, this crash can reliably
be triggered remotely with a single Wi-Fi packet targeting an up-to-date
Ubuntu 18.04, leading to the reboot of the Wi-Fi ﬁrmware.
28 https://bugzilla.kernel.org/show_bug.cgi?id=203775
29 https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-
firmware.git/commit/?id=5157165f22041346b3a82e12ba072d456777fdf2
N. Iooss, G. Campana
27
5
Conclusion
This journey studying Intel Wi-Fi chips was incredible. We did not
expect to bypass the secure boot mechanism of the chip, and this achieve-
ment opened the door to many new possibilities. Most importantly, we can
now instrument the ﬁrmware to better understand some undocumented
parts.
While this document is quite large, it does not include some work
which was also done: studying how the WoWLAN (Wake-on-Wireless
Local Area Network) feature is implemented, how ThreadX operating
system is used by the UMAC code, how the chip really communicates
with the host using DMA, how fragmented Wi-Fi frames are parsed, how
the LMAC conﬁgures a MPU (Memory Protection Unit), etc. In the
future we will likely continue looking for vulnerabilities in the Wi-Fi radio
interface. Future work can also include how the Wi-Fi part of the chip
interacts with the Bluetooth part. Indeed, all studied chips also provide
a Bluetooth interface which seems to require some coordination with
the Wi-Fi ﬁrmware to operate. Another area of interest could be the
interaction between the Wi-Fi chip and Intel CSME (Converged Security
and Management Engine) for AMT (Active Management Technology):
the iwlwifi module was modiﬁed in Linux 5.17-rc1 (released in January
2022) to document how this works.30
We would like to thank our employer Ledger for letting us work on
this exciting topic, Intel developers for providing useful documentation in
iwlwifi and Microsoft for publishing the ThreadX source code.31
Finally, we hope that the publication of this article will lay the ground-
work for helping other researchers to dive into that topic.
A
Appendix: glossary
— BAR: Base Address Register
— CSS: (probably) Code Signature Section (a ﬁrmware section which
contains metadata about other sections, including a signature)
— DMA: Direct Memory Access (a way to transmit data between two
devices without running code on a processor)
— DCCM: Data Close Coupled Memory (some kind of memory)
— LMAC: Lower Medium Access Controller
30 https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/
commit/?id=2da4366f9e2c44afedec4acad65a99a3c7da1a35
31 https://github.com/azure-rtos/threadx/
28
Ghost in the Wireless, iwlwiﬁ edition
— MMIO: Memory-Mapped Input Output
— SRAM: Static Random Access Memory (some kind of memory)
— UMAC: Upper Medium Access Controller
References
1. ARC. Arc 700 memory management unit reference, 2008. http://me.bios.io/
images/7/73/ARC700_MemoryManagementUnit_Reference.pdf.
2. Gal Beniamini. Over the air: Exploiting broadcom’s wi-ﬁ stack (part 1), 2017.
https://googleprojectzero.blogspot.com/2017/04/over-air-exploiting-
broadcoms-wi-fi_4.html.
3. Andrés
Blanco
and
Matías
Eissler.
One
ﬁrmware
to
monitor
’em
all, 2012.
http://archive.hack.lu/2012/Hacklu-2012-one-firmware-Andres-
Blanco-Matias-Eissler.pdf.
4. Guillaume Delugré. How to develop a rootkit for broadcom netextreme network cards.
RECON, July 2011. https://recon.cx/2011/schedule/events/120.en.html.
5. Louis Granboulan.
cpu_rec.py, un outil statistique pour la reconnaissance
d’architectures binaires exotiques. SSTIC, June 2017. https://www.sstic.org/
2017/presentation/cpu_rec/.
6. Nicolas
Iooss.
Analyzing
arcompact
ﬁrmware
with
ghidra.
SSTIC,
June 2021. https://www.sstic.org/2021/presentation/analyzing_arcompact_
firmware_with_ghidra/.
7. Yuval Oﬁr Omri Ildis and Ruby Feinstein.
Wardriving from your pocket,
2013.
https://recon.cx/2013/slides/Recon2013-Omri%20Ildis%2C%20Yuval%
20Ofir%20and%20Ruby%20Feinstein-Wardriving%20from%20your%20pocket.pdf.
8. Yves-Alexis Perez, Loïc Duﬂot, Olivier Levillain, and Guillaume Valadon. Quelques
éléments en matière de sécurité des cartes réseau. SSTIC, June 2010. https://www.
sstic.org/2010/presentation/Peut_on_faire_confiance_aux_cartes_reseau/.
9. Julien
Tinnès
and
Laurent
Butti.
Recherche
de
vulnérabilités
dans
les
drivers
802.11
par
techniques
de
fuzzing.
SSTIC,
June
2007.
https://www.sstic.org/2007/presentation/Recherche_de_vulnerabilites_
dans_les_drivers_par_techniques_de_fuzzing/.