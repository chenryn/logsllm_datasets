# Necurs.P2P：一种新型的点对点僵尸网络
|
##### 译文声明
本文是翻译文章，文章来源：360安全播报
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
上周，我收到了一个安全研究人员发给我的僵尸网络分析样本，该研究人员认为这是一个点对点的对等网络，但是在我对其进行了几天的分析之后，我可以确定这个网络不仅只是一个P2P网络，而且它还是一个当前非常活跃的对等网络系统。给我提供分析样本的人是我的一个好朋友，他也是一名安全研究人员，即[R136a1](https://twitter.com/TheEnergyStory)（他不仅发现了这个僵尸网络，而且他曾经还发现了[ZeroAccess3](http://kryptoslogic.blogspot.com/2016/01/zeroaccess-3-analysis.html)，并[找出了这个僵尸网络背后的控制者](http://www.kernelmode.info/forum/viewtopic.php?f=16&t=4235&sid=ad9e7df0658a4b04ad4d6a6fb6ec2f20#p27900)）。
在我上网搜索了一些相关信息之后，我发现了一篇发表于2015年5月份的[文章](https://isc.sans.edu/diary/Exploit+kits+delivering+Necurs/19719)，这篇文章介绍了一些有关Necurs的知识，也许大家能够从这篇文章中找到一些你们需要的信息。但是，这篇文章并没有提到Necurs中UDP数据包的主要用途。除此之外，我还在[bluecoat](https://www.bluecoat.com/security-blog/2013-09-10/necurs-%E2%80%93-cc-domains-non-censorable)上找到了一篇时间更加久远的文章，这篇文章发表于2013年9月，文中对Necures僵尸网络的变种进行了非常详细的讨论，感兴趣的读者也可以阅读一下。
虽然我不敢百分之百地肯定，但我认为我们将要讨论的这个僵尸网络应该是原始Necurs的一个变种。
**安装过程**
我在安装的过程中，发生了…
**好吧…大家别介意啊！**
在我对系统进行了一次快速检测之后，我发现计算机的蓝屏死机是由嵌入在恶意软件中的反虚拟化代码所引起的，而且这种情况非常的罕见，也非常的奇怪。当我们对虚拟环境进行检测的时候，恶意软件将会向系统中所有的进程注入一个简单的程序，这个程序能够创建一个异常处理程序，并执行VMCPUID指令。
VMCPUID指令可以将虚拟机的CPUID返回给我们，但有趣的是，VMCPUID指令只能在某些虚拟机中正常使用。如果虚拟机系统不支持使用这个命令的话，它将会生成一个无效的指令，并引起系统异常。这时，我们就需要一个异常处理程序来捕获并处理这种异常。当恶意软件将函数注入到每一个进程中之后，系统将无法创建正常的异常处理程序，因为系统的异常信息会被存储在.rdata会话进程中，它也没有复制功能。所以结果就是，如果恶意软件检测到了当前的系统为虚拟机系统，而且该系统不支持使用VMCPUID命令的话，那么系统中的所有进程都会崩溃，进而导致系统的蓝屏死机。所以我猜测，恶意软件的开发人员的意图是想要尝试去实现对虚拟机系统进行某种注入检测，但是却使得虚拟机不断地死机，所以他们干脆直接将这项不成熟的技术当作一种凡虚拟化的技术来使用了（尽管这项技术不应该引起支持使用VMCPUID命令的虚拟机系统崩溃）。
当恶意软件成功利用漏洞CVE-2010-4398并为bot进程提权之后，bot的副本将会把可执行程序和相应驱动程序分别复制到C:Installers{BotGUID}syshost.exe和C:Drivers{RandomName}.sys内。恶意软件会将这一可执行程序设置为一个自启动的服务，并且将驱动程序设置为启动设备（如果需要的话，bot还会启用TESTSIGNING模式来加载未进行签名的驱动程序）。在完成了相应的配置之后，系统将会重新启动。
在系统重启完成之后，bot将会尝试使用netsh.exe来将其进程列入系统防火墙的白名单中（在Windows
XP系统中，恶意软件将会直接禁用系统的防火墙功能）。
下图显示的是恶意软件利用netsh.exe来尝试将其自身进程列入防火墙白名单的相关代码：
**点对点通信**
因为僵尸网络的控制命令是由一个中央C&C服务器来发送的，这与普通僵尸网络的运行机制类似，所以这种C&C结构也被称为“混合式P2P网络”。但是，由于恶意软件可以随时利用点对点网络来向僵尸网络中所有的bot推送新的C&C服务器地址，所以相较于传统的僵尸网络而言，这种新型的僵尸网络不仅可以一直保持其有效性，而且还具有P2P对等网络的灵活性。
为了启用P2P通信，系统还必须生成一个随机端口号，并将其保存至系统的注册表中。这个端口将会被绑定到系统的UDP和TCP协议中（即使系统在绝大多数情况下使用的是UDP协议），并以此来保证相应的P2P通信数据能够正常地发送。僵尸网络中的bot拥有超过1000个IP地址，其端口绑定信息存储在初始配置文件中，各个端口每秒钟都会发送信息，直到接收到响应消息为止。在接收到了响应信息之后，信息的发送周期将会变成每分钟发送一次。奇怪的是，在每一个请求信息发送之前，系统都需要从0-4中随机选择一个数字：如果选择的数字为0，bot将会尝试与远程主机建立TCP链接，否则它将会向远程主机发送UDP数据包。所以情况将会变成，发送UDP数据包和发送TCP数据的比例大概为4:1（目前我仍无法确定这一机制的目的是什么）。
下图显示的是P2P协议处理程序：
僵尸网络中所有的bot主机都会对请求信息进行响应，并且会在其发送的响应信息中嵌入一个经过密钥（这个密钥为僵尸网络的主控密钥，这是一个长度为2048位的RSA密钥，其作用就是为了防止其他人向僵尸网络中引入新的响应payload）签名的payload。
值得注意的是，在P2P协议中并不存在对等交换功能，这是因为僵尸网络的主机不会信任网络中的对等主机，也不会在与网络中的其他主机共享信息。它们会选择生成一个主机列表，并通过C&C服务器来进行广播。这种方式可以有效地防止中毒和外部攻击，因为网络服务器可以根据这个主机列表来检测数据中心内的相应IP地址，否则僵尸网络将有可能被安全公司所破坏。
**Payload存储**
所有从C&C服务器或者P2P网络中下载下来的数据都会被存储在临时文件夹之中，每一个文件名都有一个单独的UUID，后缀均为.tmp。系统会对bot的标识符（一个长度为64位的静态整形数据，用于标识文件的内容）使用SHA1算法进行哈希处理，并生成相应的UUID。
下图显示的是文件名的生成函数：
文件会使用RC4算法进行加密，系统将从上图所显示的函数中提取出其使用的加密密钥。除此之外，系统还会生成一个经过哈希处理的随机变量，并将其存储在文件末尾，这样一来，生成文件的签名就不会起任何作用了。
**结论**
上述的内容均来源于我的分析结果，当我与我的同事完成了所有的数据采集工作之后，我们应该可以更加深入地去了解这个僵尸网络。我们将会在得到了研究结果之后立刻更新。