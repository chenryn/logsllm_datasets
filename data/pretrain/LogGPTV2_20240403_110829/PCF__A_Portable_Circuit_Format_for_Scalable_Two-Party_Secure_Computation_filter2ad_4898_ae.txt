# 优化后的文本

## 表9：在恶意模型中几种电路的在线运行时间
- 128位乘法
- 256位乘法
- 76±4%
- 2820±2%
- 1200±10%
- 3900±3%
- 21±2%
- 11.2±0.2%
- 23±2%
- 27±4%
- 10±20%
- 63.0±0.4%
- 100±40%
- 260±10%
- 16±6%
- 70.1±1%
- 192±0.3%
- 47.2±0.6%
- 637±0.5%
- 160±1%
- 210±2%
- 33.3±0.5%
- 49±6%
- 187±2%
- 168±0.4%
- 577±0.3%

表9显示了在恶意模型中几种电路的在线运行时间。这些时间是在50个样本上取平均值，并计算出95%的置信区间。

## 减少手机和PC环境之间的性能差异
此外，KSS12系统使用更高效的加密原语，进一步提高了性能。

## 相关工作
近年来，编译器方法在安全两方计算中受到了广泛关注。Henecka等人提出的TASTY系统结合了混淆电路方法和同态加密，并包含一个编译器，可以生成在两种模型中都能使用的电路。与Fairplay和KSS12一样，TASTY要求函数用特定领域的语言描述。TASTY编译器对正在编译的函数的抽象语法树进行优化。Kruger等人开发了一个有序BDD编译器来测试他们的系统相对于Fairplay的性能。Mood等人专注于通过PALC系统在移动设备上编译安全函数，这涉及对Fairplay编译器的修改。

最近，Holzer等人提出了一种基于有界模型检查的编译器方法。在这项工作中，CBMC系统被用来构建电路，然后重新编写以减少非XOR门的数量。这种方法有几个优点，最突出的是函数可以用广泛使用的C编程语言描述，并且CBMC的使用允许应用更高级的软件工程技术到安全计算协议中。然而，与KSS12一样，这种方法展开所有循环（最多固定次数迭代），并将高级描述直接转换为布尔电路，然后进行优化。

除了SFE之外，还提出了用于证明系统的高效编译器的工作。Almeida等人开发了一个针对Σ-协议的零知识证明编译器，该编译器将特定领域语言中的协议规范转换为证明者和验证者运行的程序。Setty等人提出了一种可验证计算系统，该系统使用Fairplay编译器的修改版本，计算二次约束系统而不是布尔电路，并生成证明者和验证者的可执行文件。我们的系统与这些方法有些相似，因为我们可以将电路表示视为由SFE系统中的双方执行的程序；然而，我们的方法在处理控制流和迭代结构方面是独特的。

与我们工作密切相关的是Sharemind系统，它将安全计算作为隐私保护分布式应用程序的构建块。与我们的方法一样，Sharemind中使用的安全计算部分的电路直到协议实际运行时才完全展开。Sharemind中的函数使用一种名为SecreC的特定领域语言描述。尽管已经有关于SecreC的静态分析工作，但SecreC编译器不执行自动优化。相比之下，我们的方法侧重于允许在比特级别进行电路优化，而无需展开整个电路。

Kerschbaum提出了基于术语和表达式重写的安全计算自动化优化方法。这种方法基于最大化离线计算的使用，推断每个参与者可以在不知道对方输入的情况下计算什么，并且不将底层安全计算原语视为黑盒。因此，为了在恶意模型中保持安全性，需要额外的工作。我们的技术可以与Kerschbaum的方法结合，以减少在线组件的开销。

## 未来工作
我们的编译器可以读取任何字节码表示作为输入；一个直接的未来方向是为另一种字节码格式（如LLVM或JVM）编写指令翻译，这将允许函数用更广泛的语言表达。此外，我们认为我们的技术可以与Sharemind结合，通过让我们的编译器读取Sharemind VM的字节码并计算优化的PCF文件，在Sharemind协议中使用混淆电路计算的情况下。

PCF格式不传达关于数据操作或类型的高级信息。此类信息可能进一步减少计算的电路大小。编译器对此类信息的静态分析已被广泛研究，我们的编译器可以扩展以支持进一步减少PCF解释器发出的电路大小。关于数据结构的高级信息也可以用于在优化之前改进电路的生成，使用Evans和Zahur最近提出的技术。

我们的系统和技术可能可以推广到多方情况，以及其他函数表示形式，如算术电路。这将需要对我们编译器的优化策略和目标进行重大更改，但对于PCF解释器则不需要太多更改。类似的修改也可以支持同态加密系统。

## 结论
我们提出了一种编译和存储安全计算系统电路的方法，所需的计算资源比以前的方法要少得多。我们使用具有不同电路大小和控制流结构的各种函数提供了改进和实用性的实证证据。此外，我们还介绍了一种读取字节码作为输入的编译器，而不是特定领域的语言，并探讨了这种做法所面临的挑战。我们还介绍了在PC和手机上评估我们新语言的解释器。

编译器、PCF解释器和测试用例的代码将在作者的网站上提供。

## 致谢
我们要感谢Elaine Shi提供的宝贵建议。我们还要感谢Chih-hao Shen帮助将KSS12移植到使用PCF。这项研究得到了美国国防高级研究计划局（DARPA）和空军研究实验室（AFRL）的支持，合同编号FA8750-11-2-0211。美国政府有权复制和分发再版物，无论是否有版权标记。本文的观点和结论仅代表作者的观点，不应解释为代表DARPA或美国政府的官方政策或认可，无论是明示还是暗示。

## 参考文献
[1] J. B. Almeida, E. Bangerter, M. Barbosa, S. Krenn, A.-R. Sadeghi, and T. Schneider. A Certifying Compiler For Zero-Knowledge Proofs of Knowledge Based on Σ-Protocols. In Proceedings of the 15th European conference on Research in computer security, ESORICS’10, pages 151–167, Berlin, Heidelberg, 2010. Springer-Verlag.
[2] A. Biere, A. Cimatti, E. M. Clarke, and Y. Zhu. Symbolic Model Checking without BDDs. In Proceedings of the 5th International Conference on Tools and Algorithms for Construction and Analysis of Systems, TACAS ’99, pages 193–207, London, UK, UK, 1999. Springer-Verlag.
... (其他参考文献省略)

## 附录A: PCF语义
PCF文件格式包括一个声明输入大小的头部分，随后是一系列操作，这些操作被分成子程序。在运行时，这些操作会操纵PCF解释器的内部状态，在必要时生成门。PCF解释器的内部状态包括指令指针、调用堆栈、线值数组和指针数组。指针是正整数。线值可以是0、1或⊥，其中⊥表示依赖于输入数据的值，这些输入数据由调用解释器的代码提供。线表中的每个位置都可以被视为一个堆栈。

每个PCF指令最多可以有3个参数。指令及其语义如下：
- CLABEL/SETLABELC：仅出现在头部分，用于设置每方的输入大小。CLABEL声明值的位宽，SETLABELC设置值。
- FUNCTION：表示子程序的开始。当子程序被调用时，指令指针被设置为该指令之后的位置。
- GADGET：表示分支目标

### 示例PCF描述
下面是一个PCF文件的示例。它多次迭代一个循环，将两个参与者的输入与内部状态的一个位进行异或运算。

GADGET: main
CLABEL ALICEINLENGTH 32
CLABEL BOBINLEGNTH 32
CLABEL xxx 32
SETLABELC ALICEINLENGTH 128
SETLABELC ALICEINLENGTH 128
FUNCTION: main
1111 32 0 0
0000 33 0 0
0000 34 0 0
0000 35 0 0
GADGET: L
0110 36 35 34
0001 35 36 36
0110 36 34 33
0001 34 36 36
0110 36 33 32
0001 33 36 36
ALICEINPUT32 0 0
0001 36 0 0
BOBINPUT32 0 0
0001 37 0 0
0110 38 37 36
0110 39 33 38
SHIFT OUT ALICE 39
BRANCH L 35
RETURN xxx

BRANCH：接受两个参数：一个目标（用GADGET声明）和线表中的一个位置。如果线值为0，则指令指针被设置为目标之后的指令。如果线值为1，则指令指针递增。如果线值为⊥，则评估停止并报错。
- FUNC：调用子程序，将当前指令指针压入调用堆栈。
- PUSH：将指定位置的线值副本压入该位置的堆栈。
- POP：弹出指定位置的堆栈。如果该堆栈只有一个值，则评估停止并报错。
- ALICEIN32/BOBIN32：从一方获取32位输入，从该方输入的指定位位置开始。位位置由线表中的32个值指定。如果这些值中有任何一个为⊥，则评估停止并报错。输入值都将具有值⊥，并将存储在线表的位置0到31。
- SHIFT OUT：输出给定方的单个位。
- RETURN：从子程序返回。指令指针被重新定位到从调用堆栈顶部弹出的值。
- STORECONSTPTR：在指针表中设置一个值。
- OFFSETPTR：向指针添加一个值，该值由线表中从某个位置开始的32个线值指定。如果这些值中有任何一个为⊥，则评估停止并报错。
- PTRTOWIRE：将指针值保存为32位无符号整数。每一位都被压入线表中的堆栈。
- PTRTOPTR：将一个位置的指针表中的值复制到另一个位置。
- CPY121：从指针指定的位置复制一个线值到静态指定的位置。
- CPY32：从静态指定的位置复制一个线值到指针指定的位置。
- g0,0g0,1g1,0g1,1：根据线表中的两个输入值计算具有指定真值表的门，输出存储在指定位置。当一个或两个输入值为⊥时，应用逻辑简化规则。如果无法简化，则输出为⊥，解释器将生成一个门。这既用于局部计算（如更新循环索引），也用于计算协议中使用的门。