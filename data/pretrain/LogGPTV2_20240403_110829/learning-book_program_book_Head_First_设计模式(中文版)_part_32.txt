的方法。
Adapter
Adaptee
(ssanbau
specifcRequest()
遥配器实现了鸭子的接口，但它收
感谢道配器，火路（被通配者）会
PDG
到方法调用时，会香托给火端。
接到客户作用于鸭子接口上的调用。
246
第7章
---
## Page 283
适配器模式
今夜话题：对象适配器和类适配器的面对
面接触。
对象适配器
类适配器
因为我使用组合，我不仅可以适配某个类，也可以
适配该类的任何子类，所以我更胜一筹。
你说的是实话，我的确做不到这一一点，因为我只
能够采用某个特定的被适配类。但是我有一个很
大的优点，那就是：我不需要重新实现我的整个
被适配者。必要的时候，我也可以覆盖被适配者
的行为，因为我利用继承的方式。
在我的世界中，我们喜欢使用组合多过于使用继
承：或许你的做法可以多节省几行代码，但是我
只需要写一些代码，将工作委托给被适配者进行。
我们喜欢让事情更有弹性。
弹性，或许吧！但效率呢？我可不认为有效率。
使用类适配器，仅仅需要一个类适配器，而不需
只不过多了一个小对象，何须如此担心？你或许
要一个适配器和一个被适配者。
能够很快地覆盖一个方法，但是我加进适配器代
码中的任何行为，都可以和我的被适配者类“以
及”其所有的子类搭配工作。
是的，但是万一被适配者的子类加人了新的行为，
又会如何？
嘿！拜托，饶了我吧，我只需要让组合的对象是
子类，就可以解决这个问题了。
听起来很麻烦.
你想知道麻烦是什么吗？去照照镜子吧！
你现在的位置，247
---
## Page 284
真实世界的适配器
真实世界的适配器
让我们看看真实世界中一个简单的适配器（至少比鸭子更
实际些）.
旧世界的枚举器
如果你已经使用过Java，可能记得早期的
校举有一个简单的接口。
集合（collection）类型（例如：Vector、
C
>
告知是否在集合中还有更多元
Stack、Hashtable）都实现了一个名为
Enumeration
elements(）的方法。该方法会返回一个
hasMoreElements()
Enumeration（举）。这个Enumeration接口
nextElement)
可以逐一走过此集合内的每个元素，而无需
取得集合中的下一个元
知道它们在集合内是如何被管理的。
素。
用来取代校举接口中的
新世界的送代器
hasMoreElements）。这个方法告
知你是否已经迹历集合中的所
当Sun推出更新后的集合类时，开始使用了
Iterator
有项。
Iterator（选代器）接口，这个接口和枚举接
口很像，都可以让你遍历此集合类型内的每
hasNext()
next
取得集合中的下一个元
个元素，但不同的是，选代器还提供了删除
remove
意。
元素的能力。
从集合中则除
个项。
而今天…
我们经常面对遗留代码，这些代码暴露出枚举器接口，但我
们又希望在新的代码中只使用选代器。想解决这个问题，看
来我们需要构造一个适配器。
248
第7章
---
## Page 285
适配器机式
将枚举适配到送代器
我们先看看这两个接口，找出它们的方法映射关系。换句话说，我们要找出每一
个适配器方法在被适配者中的对应方法是什么。
这两个方法看起来很容
目标接口
易，直接映射到送代器的
hasgNext()fenext()。
>
>
Iterator
Enumeration
hasNext()
hasMoreElements()
next()
nextElement)
remove()
被遥配者接口
但这个remove(）方法又该如何映射：
在校举中并没有类似的方法。
设计适配器
这个类应该是这样的：我们需要一个适配器，实现了目标接口，而此目标接口是
由被适配者所组合的。hasNext(）和next(）方法很容易实现，直接把它们从目标对应
到被适配者就可以了。但是对于remove（）方法，我们又该怎么办？请花一些时间想
一想（我们在下一页就会处理）。目前，类图是这样的：
>
我们要使旧代码中的校举变得像是
新代码依然使用选代
lterator
hasNext()
新代码中的选代器。
器，虽然实际上背后障
next0
这个实现了枚举
藏的是枚举器。
remove()
接口的类，正是
被适配者。
Enumerationlterator
Enumeration
>
这就是谨配器。
hasNext()
hasMoreElements()
next(
nextElement)
remove()
你现在的位置
249
---
## Page 286
枚举迭代器适配器
处理remove(）方法
好了，我们知道枚举不支持删除，因为枚举是一个“只读”接口。适配器无法实现一个有实
际功能的remove（方法，最多只能抛出一个运行时异常。幸运地，选代器接口的设计者事先
料到了这样的需要，所以将remove(方法定义成会抛出UnsupportedOpeartionException。
在这个例子中，我们看到了适配器并不完美；客户必须小心潜在的异常，但只要客户够小心，
而且适配器的文档能做出说明，这也算是一个合理的解决方案。
编写一个Enumeratorlterator适配器
这是一份简单而有效的代码，适合依然会产生枚举的遗留类。
因为我们将校举遥配成选代器，
遥配器需要实现选代器接口…….
送配器必须看起来就像是一个透
public class EnumerationIterator implements Iterator
代器。
Enumeration enum;
我们利用组合的方式，将校举结合
public EnumerationIterator (Enumeration enum)
进入遥配器中，所以用一个实例变
this.enum = enum;
量记录校举。
选代器的hasNext（）方法其实是要托给校举
public boolean hasNext(){
的hasMoreElements）方法.….
return enum.hasMoreElements () ;
….而送代器的next(）方法其实是善托给校
public Object next () {
举的nextElement（）方法。
return enum.nextElement ();
public void remove ()(
很不章，我们不能支持进代器的
throw new UnsupportedOperationException();
temove（）方法，所以必须放弃。在
这里，我们的做法是抛出一个异
常。
250第7章
---
## Page 287
适配器模式
练习
虽然Java已经采用了选代器，但还是有相当多的遗留“客户代码”，依赖于
枚举接口，所以利用适配器将选代器转换成枚举，其实是很有用的技巧。
编写一个适配器来做这样的转换，可以将此适配器用在ArrayList上作为测试。
ArrayList类支持选代器接口，但不支持枚举（尚未支持）。
RAIN
POWWER
某些交流电适配器所做的事情不只是改变接口，它们还加了一些其他的特性，例如：电涌保
护、指示灯、警报声等。
如果要你实现这类特性，你要使用什么模式？
你现在的位置
251
---
## Page 288
围炉夜话：装饰者与适配器
团护农话
今夜话题：装饰者模式和适配器模式讨论彼
此的差异。
装饰者
适配器
我很重要，我的工作全都是和“责任”相关的。你
知道的，当事情一涉及到装饰者，就表示有一些新
的行为或责任要加人到你的设计中。
你们这些家伙老是把光环放在自己身上，但我们
这些适配器却隐身于沟渠中，干着脏活一—转换
接口。我们的工作或许不是光彩夺目，但我们的
客户却很感激我们让他们的生活变得更容易。
你说的可能是真的，但可不要认为我们工作不努
力。当我们必须装饰一个大型接口时，咳！可是
需要很多代码的。
当你必须将若干类整合在一起来提供你的客户所
期望的接口时，不妨扮演适配器的角色看看，这
才够棘手。不过，我们有一句格言：“被解耦的
客户才是快乐的客户”。
很俏皮！别认为我们独揽了所有的光环，有时候我
只是一个装饰者，天晓得还有多少其他的装饰者会
再将我包装起来。当一个方法调用委托给我时，我
根本不知道有多少其他装饰者已经处理过这个调用
了，而我也根本不知道我对这个请求所做的付出是
否会得到别人的注意。
哎呀，我们其实同病相怜。只要适配器工作顺利，
客户甚至不会意识到我们的存在。根本没有人会
感谢适配器所做的一切。
252第7章
---
## Page 289
适配器模式
装饰者
适配器
但是，关于我们适配器的好处是，我们允许客户
使用新的库和子集合，无须改变“任何”代码，
由我们负责做转换即可。嘿！这是我们的市场。
我们装饰者也可以做到，但是我们可以让“新行
为”加人类中，而无需修改现有的代码。我还是认为
适配器只是一种装饰者的变体，我的意思是说，适配
器就和我们一样，都是用来包装对象的。
不！不！不！才不是这样。我们“一定会”进行
接口的转换，但你们“绝不会”这么做。我宁可
认为装饰者其实是一种适配器的变体，只是你们
不会改变接口。
不！我们的工作是扩展我们包装的对象的行为或责任，
并不是“简单传送”就算了。
嘿！你说谁“简单传送”？来呀！转换几个接口
让我瞧瞧，看你能持续多久！
或许我们应该体会到，我们在纸上看起来虽然很类似，
但其实我们的意图差异颜大。
没错，你这么说就对了。
PDC
你现在的位置
253
---
## Page 290
谁做了什么？
现在，看看不同之处···
在本章中，还有另一个模式。
你已经知道适配器模式是如何将一个类的接口转换成另一个符合客户期望的接口的，
你也知道在Java中要做到这一点，必须将一个不兼容接口的对象包装起来，变成兼容
的对象。
我们现在要看一个改变接口的新模式，但是它改变接口的原因是为了简化接口。这
个模式被巧妙地命名为外观模式（Facade-Pattern），之所以这么称呼，是因为它将一
个或数个类的复杂的一切都隐藏在背后，只显露出一个干净美好的外观。
找出每个模式的目的：
模式
意图
装饰者
将一个接口转成另一个接
不改变接口，但加入责任
适配器
外观
让接口更简单
254
第7章
---
## Page 291
适配器模式
甜蜜的家庭影院
在我们进入外观模式的细节之前，让我们看一个风行全美的热潮：建
立自己的家庭影院。
通过一番研究比较，你组装了一套杀手级的系统，内含DVD播放器
投影机、自动屏幕、环绕立体声，甚至还有爆米花机。
看看这些组件的组成：
vdPlaye
MDvd(
DvdPlayer
有很多类，很多交
etTuner()
ofl)
ae()
互，还有一大群接
ejed)
pause(
口，等着我们去学
play)
play0)
习、使用。
CdPlayer
sefTwoChameiAudio()
stop()
play0
dop(
dPlayer
38
lapowA
TheaterLights
你花了好几个星期布线、挂上投影机、连接所有的装置并进行微调。现
在，你准备开始享受一部电影.
PDG
你现在的位置
255
---
## Page 292
看电影的事前工作
观赏电影（围困难的方式）
挑选一部DVD影片，放松，准备开始感受电影的魔幻魅力。
哎呀！忘了一件事：想看电影，必须先执行一些任务。
①打开爆米花机
②开始爆米花
③将灯光调暗
4放下屏幕
5打开投影机
6将投影机的输入切换到DVD
将投影机设置在宽屏模式
③打开功放
9将功放的输入设置为DVD
10将功放设置为环绕立体声
1将功放音量调到中（5）
②打开DVD播放器
累死人了！还必须打开达
③开始播放DVD
么多开关！
PDG
256
第7章
---
## Page 293
适配器模式
让我们将这些任务写成类和方法的调用
打丹爆米花机，开始爆米花。
popper.on ();
popper.pop() ;
灯光调啥到10%的亮度…
1ights.dim(10) ;
把展幕放下。
screen.down() ;
涉及到六个不
同的类！