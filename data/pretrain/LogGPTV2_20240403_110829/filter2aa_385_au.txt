Weplayedaroundwithavarietyofapproachestohandle
referentialdata,eventuallysettlingonasolutionthatutilizesa
combinationofstructurefieldtagsandreflection.Recallthat
reflectionisatechniquethroughwhichaprogramcaninspect
itself,particularlyexaminingthingslikeitsowndatatypes.
Fieldtagsaresomewhatrelatedtoreflectioninthatthey
definearbitrarymetadataaboutastructfield.Youmayrecall
themfrompreviousXML,MSGPACK,orJSONencoding
examples.Forexample,Listing6-5usesstructtagstodefine
JSONfieldnames.
typeFoostruct{
Aint`json:"a"`
Bstring`json:"b"`
}
Listing6-5:AstructdefiningJSONfieldtags
Go’sreflectpackagecontainsthefunctionsweusedto
inspectdatatypesandextractfieldtags.Atthatpoint,itwasa
matterofparsingthetagsanddoingsomethingmeaningful
withtheirvalues.InListing6-6,youcanseeastructdefined
intheSMBpackage.
typeNegotiateResstruct{
Header
StructureSizeuint16
SecurityModeuint16
DialectRevisionuint16
Reserveduint16
ServerGuid[]byte`smb:"fixed:16"`❶
Capabilitiesuint32
MaxTransactSizeuint32
MaxReadSizeuint32
MaxWriteSizeuint32
SystemTimeuint64
ServerStartTimeuint64
SecurityBufferOffsetuint16`smb:"offset:SecurityBlob"`❷
SecurityBufferLengthuint16`smb:"len:SecurityBlob"`❸
Reserved2uint32
SecurityBlob*gss.NegTokenInit
}
Listing6-6:UsingSMBfieldtagsfordefiningfieldmetadata(/ch-
6/smb/smb/smb.go)
Thistypeusesthreefieldtags,identifiedbytheSMBkey:
fixed❶,offset❷,andlen❸.Keepinmindthatwechoseall
thesenamesarbitrarily.Youaren’tobligatedtouseaspecific
name.Theintentofeachtagisasfollows:
fixedidentifiesa[]byteasafixed-lengthfieldoftheprovidedsize.Inthiscase,
ServerGuidis16bytesinlength.
offsetdefinesthenumberofbytesfromthebeginningofthestructtothefirst
positionofavariable-lengthdatabuffer.Thetagdefinesthenameofthefield—
inthiscase,SecurityBlob—towhichtheoffsetrelates.Afieldbythisreferenced
nameisexpectedtoexistinthesamestruct.
lendefinesthelengthofavariable-lengthdatabuffer.Thetagdefinesthename
ofthefield—inthiscase,SecurityBlob,towhichthelengthrelates.Afieldby
thisreferencednameshouldexistinthesamestruct.
Asyoumighthavenoticed,ourtagsallowusnotonlyto
createrelationships—througharbitrarymetadata—between
differentfields,butalsotodifferentiatebetweenfixed-length
byteslicesandvariable-lengthdata.Unfortunately,adding
thesestructtagsdoesn’tmagicallyfixtheproblem.Thecode
needstohavethelogictolookforthesetagsandtakespecific
actionsonthemduringmarshalingandunmarshaling.
ParsingandStoringTags
InListing6-7,theconveniencefunction,calledparseTags(),
performsthetag-parsinglogicandstoresthedatainahelper
structoftypeTagMap.
funcparseTags(sfreflect.StructField❶)(*TagMap,error){
ret:=&TagMap{
m:make(map[string]interface{}),
has:make(map[string]bool),
}
tag:=sf.Tag.Get("smb")❷
smbTags:=strings.Split(tag,",")❸
for_,smbTag:=rangesmbTags❹{
tokens:=strings.Split(smbTag,":")❺
switchtokens[0]{❻
case"len","offset","count":
iflen(tokens)!=2{
returnnil,errors.New("Missingrequiredtagdata.Expectingkey:val")
}
ret.Set(tokens[0],tokens[1])
case"fixed":
iflen(tokens)!=2{
returnnil,errors.New("Missingrequiredtagdata.Expectingkey:val")
}
i,err:=strconv.Atoi(tokens[1])
iferr!=nil{
returnnil,err
}
ret.Set(tokens[0],i)❼
}
Listing6-7:Parsingstructuretags(/ch-6/smb/smb/encoder/encoder.go)
Thefunctionacceptsaparameternamedsfoftype
reflect.StructField❶,whichisatypedefinedwithinGo’sreflect
package.Thecodecallssf.Tag.Get("smb")ontheStructFieldvariable
toretrieveanysmbtagsdefinedonthefield❷.Again,thisis
anarbitrarynamewechoseforourprogram.Wejustneedto
makesurethatthecodetoparsethetagsisusingthesamekey
astheoneweusedinourstruct’stypedefinition.
Wethensplitthesmbtagsonacomma❸,incaseweneed
tohavemultiplesmbtagsdefinedonasinglestructfieldinthe
future,andloopthrougheachtag❹.Wespliteachtagona
colon❺—recallthatweusedtheformatname:valueforourtags,
suchasfixed:16andlen:SecurityBlob.Withtheindividualtagdata
separatedintoitsbasickeyandvaluepairing,weuseaswitch
statementonthekeytoperformkey-specificvalidationlogic,
suchasconvertingvaluestointegersforfixedtagvalues❻.
Lastly,thefunctionsetsthedatainourcustommapnamed
ret❼.
InvokingtheparseTags()FunctionandCreatinga
reflect.StructFieldObject
Now,howdoweinvokethefunction,andhowdowecreate
anobjectoftypereflect.StructField?Toanswerthesequestions,
lookattheunmarshal()functioninListing6-8,whichiswithin
thesamesourcefilethathasourparseTags()convenience
function.Theunmarshal()functionisextensive,sowe’lljust
piecetogetherthemostrelevantportions.
funcunmarshal(buf[]byte,vinterface{},meta*Metadata)(interface{},error){
typev:=reflect.TypeOf(v)❶
valuev:=reflect.ValueOf(v)❷
--snip--
r:=bytes.NewBuffer(buf)
switchtypev.Kind(){❸
casereflect.Struct:
--snip--
casereflect.Uint8:
--snip--
casereflect.Uint16:
--snip--
casereflect.Uint32:
--snip--
casereflect.Uint64:
--snip--
casereflect.Slice,reflect.Array:
--snip--
default:
returnerrors.New("Unmarshalnotimplementedforkind:"+
typev.Kind().String()),nil
}
returnnil,nil
}
Listing6-8:Usingreflectiontodynamicallyunmarshalunknowntypes(/ch-
6/smb/smb/encoder/encoder.go)
Theunmarshal()functionusesGo’sreflectpackagetoretrieve
thetype❶andvalue❷ofthedestinationinterfacetowhich
ourdatabufferwillbeunmarshaled.Thisisnecessarybecause
inordertoconvertanarbitrarybytesliceintoastruct,weneed
toknowhowmanyfieldsareinthestructandhowmanybytes
toreadforeachfield.Forexample,afielddefinedasuint16
consumes2bytes,whereasauint64consumes8bytes.Byusing
reflection,wecaninterrogatethedestinationinterfacetosee
whatdatatypeitisandhowtohandlethereadingofdata.
Becausethelogicforeachtypewilldiffer,weperformaswitch
onthetypebycallingtypev.Kind()❸,whichreturnsareflect.Kind
instanceindicatingthekindofdatatypewe’reworkingwith.
You’llseethatwehaveaseparatecaseforeachoftheallowed
datatypes.
HandlingStructs
Let’slookatthecaseblock,inListing6-9,thathandlesastruct
type,sincethatisalikelyinitialentrypoint.
casereflect.Struct:
m:=&Metadata{❶
Tags:&TagMap{},
Lens:make(map[string]uint64),
Parent:v,
ParentBuf:buf,
Offsets:make(map[string]uint64),
CurrOffset:0,
}
fori:=0;i
")
}
buf,err:=ioutil.ReadFile(os.Args[1])
iferr!=nil{
log.Fatalln(err)
}
options:=smb.Options❶{
Password:os.Args[2],
Domain:os.Args[3],
Host:os.Args[4],