IDA 的idsutils
 实用工具用于创建.ids 文件。这些实用工具包括两个库解析器：从Windows DLL 中提取信息的 dll2idt 和从ar 库中提取信息的ar2idt.exe 。无论使用哪一个解析器，其输出都是一个.idt 文本文件，它每行显示一个导出函数，并将导出函数的序号与函数名称对应起来。.idt文件的语法非常简单，idsutils 自带的readme.txt 文件介绍了这种语法。.idt 文件中的绝大多数行用于根据以下方案描述导出函数。
导出项以正数开头，这个数是导出函数的序号。
序号后是一个空格，后面接 Name=
 函数形式的Name
 指令，例如，Name=RegOpenKeyA
 。如果使用零这个特殊的序号，则Name
 指令用于指定当前的.idt 文件所描述的库名称，如下所示：
0 Name=advapi32.dll
一个可选的 Pascal
 指令可用于说明一个函数是否使用了 stdcall
 调用约定，并指出该函数在返回时从栈中删除了多少个字节的数据。例如：
483 Name=RegOpenKeyA Pascal=12
可以在导出项后附加一个可选的 Comment
 指令，指定一条注释，并在反汇编代码清单中每个引用该函数的位置与函数一起显示这条注释。一个完整的导出项如下所示：
483 Name=RegOpenKeyA Pascal=12 Comment=Open a registry key
此外，读者可以参阅 idsutils
 的readme.txt 文件了解其他可选指令。idsutils
 解析实用工具的目的，是尽可能自动化地创建.idt 文件。创建.idt 文件的第一步是获得你希望解析的库的副本。然后，使用合适的解析实用工具解析这个副本。如果希望为与 OpenSLL 有关的ssleay32.dll 库创建一个.idt 文件，可以使用以下命令：
$ ./dll2idt.exe ssleay32.dll  
Convert DLL to IDT file. Copyright 1997 by Yury Haron. Version 1.5  
File: ssleay32.dll   ... ok
这时，如果解析成功，我们将得到一个名为 SSLEAY32.idt 的文件。由于 dll2idt.exe 基于从DLL 库本身获得的信息生成输出文件名，因此，输入文件名与输出文件名之间存在大小写差异。生成的.idt 文件的前几行如下所示：
ALIGNMENT 4  
;DECLARATION  
;  
0 Name=SSLEAY32.dll  
;  
121 Name=BIO_f_ssl  
173 Name=BIO_new_buffer_ssl_connec  
122 Name=BIO_new_ssl  
174 Name=BIO_new_ssl_connect  
124 Name=BIO_ssl_copy_session_id  
需要注意的是，解析器无法确定一个函数是否使用 stdcall
 ，以及如果使用了，它从栈上删除了多少字节的数据。要想增加任何 Pascal
 或Comment
 指令，你必须在创建最终的.ids 文件之前使用文本编辑器手动添加。创建.ids 文件的最后一个步骤是使用 zipids.exe实用工具压缩.idt 文件，并将得到的.ids 文件复制到/ids目录中。
$ ./zipids.exe SSLEAY32.idt  
File: SSLEAY32.idt   ... {219 entries [0/0/0]}          packed  
$ cp SSLEAY32.ids ../Ida/ids
这样，只要加载了一个链接到 ssleay32.dll 的二进制文件，IDA 就会加载 SSLEAY32.ids。如果你选择不将新建的.ids 文件复制到/ids目录中，你随时可以通过File▶Load File ▶IDS File 加载它们。
在使用.ids 文件时，可采用另一个步骤将.ids 文件链接到特定的.sig 或.til 文件。在选择.ids 文件时，IDA 会使用一个名为/ida/idsnames的IDS 配置文件。这个文本文件可执行以下操作。
将共享库的名称与它对应的.ids 文件名映射起来。如果共享库的名称不能完全转换成一个MS-DOS 8.3形式的文件名，这样做可帮助 IDA 定位正确的.ids 文件，如下所示：
libc.so.6     libc.ids          +
将.ids 与.til 文件映射起来。这样，只要IDA 加载指定的.ids 文件，它会自动加载指定的.til文件。使用下面的命令，一旦 IDA 加载SSLEAY32.ids，openssl.til文件将会自动加载（请参阅idsnames文件了解相关语法信息）：
SSLEAY32.ids    SSLEAY32.ids      +   openssl.til
将.sig 文件与对应的.ids 文件映射起来。这样，只要反汇编代码清单应用指定的.sig 文件，IDA 将加载指定的.ids 文件。下面的命令行指出：一旦用户应用libssl.sig FLIRT 签名，IDA应加载SSLEAY32.ids文件：
libssl.sig      SSLEAY32.ids      +
第15 章将介绍如何使用脚本编写 idsutils
 提供的库解析器。同时，我们将利用IDA 的函数分析功能生成更加详细的.idt 文件。
13.2 使用loadint 扩充预定义注释
在第7 章中，我们介绍了 IDA 的“自动注释”概念，如果启用了它，IDA 将显示描述每个汇编语言指令的注释。如下所示是这种注释的两个例子：
.text:08048654                 lea     ecx, [esp+arg_0] ; Load Effective Address
.text:08048658                 and     esp, 0FFFFFFF0h ; Logical AND
这些预定义注释保存在/ida.int 文件中，这些注释主要按 CPU 类型排序，其次按指令类型排序。如果启用自动注释，IDA 会在 ida.int 文件中搜索与每一条指令有关的注释，如果找到，它将在反汇编代码清单的右侧显示这些注释。
使用loadint
1
 实用工具可以修改现有的注释，或在 ida.int 文件中添加新注释。如我们前面讨论的其他附加实用工具一样，loadint
 发行版自带的readme.txt 文件介绍了loadint
 的用法。loadint
 发行版中还包含大量的.cmt 文件，它们是描述 IDA 的所有处理器模块的预定义注释。修改现有注释的过程非常简单，首先确定与处理器关联的注释文件（如用于x86 处理器的pc.cmt文件），其次修改其中的注释，运行loadint 重新创建ida.int 注释文件，最后将得到的 ida.int 文件复制到IDA 主目录中，下次启动时，IDA 将从这个目录加载新建的 ida.int 文件。一段重建注释数据库的简单代码如下所示：
1. 当前版本为loadint61.zip。
$ ./loadint comment.cmt ida.int  
Comment base loader. Version 2.04. Copyright (c) 1991-2011 Hex-Rays  
17566 cases, 17033 strings, total length: 580575  
你希望进行的更改包括：修改现有注释，或为没有注释的指令添加注释。例如，在pc.cmt文件中，为使在启用自动注释时不会生成过多注释，IDA 并没有为几个比较常见的指令添加注释。下面的代码行取自 pc.cmt 文件，它们证实，默认情况下，x86 mov
 指令并不生成注释：
NN_ltr:                 "Load Task Register"  
//NN_mov: "Move Data"  
NN_movsp:               "Move to/from Special Registers"
如果你希望为 mov
 指令添加注释，你可以删除中间一行注释，并根据详细步骤重建注释数据库。
loadint
 文档资料中的一条提示指出：loadint 必须能够找到IDA 发行版自带的 ida.hlp 文件。如果你收到以下错误消息，应该将 ida.hlp 文件复制到loadint 目录，并重新运行 loadint 。
$ ./loadint comment.cmt ida.int  
Comment base loader. Version 2.04. Copyright (c) 1991-2011 Hex-Rays  
Can't initialize help system.  
File name: 'ida.hlp', Reason: can't find file (take it from IDA distribution).
此外，你可以对 loadint
 使用-n
 选项，指定
 的位置，如下面的命令行所示：
$ ./loadint -n  comment.cmt ida.int
comment.cmt 文件是loadint
 的主输入文件，这个文件的语法记录在 loadint
 文档中。简言之，commnet.cmt 创建处理器类型与相关的注释文件之间的映射。特定于处理器的注释文件则反过来指定特定指令与每条指令的相关注释文本之间的对应关系。整个过程由几个枚举（C 风格枚举）常量控制，它们定义所有处理器类型（位于 comment.cmt 文件中）以及每个处理器可能使用的所有指令（位于 allins.hpp 文件中）。
如果你希望给一个全新的处理器类型添加预定义注释，这个过程可能会比仅修改现有的注释要复杂一些。而且，这个过程还与创建新的处理器模块（参见第 19 章）直接相关。如果不深入分析处理器模块，要给一个全新的处理器类型添加注释，首先，你需要在 allins.hpp 文件中创建一个新的枚举常量集合（与处理器模块共享），由它为指令集中的每条指令定义一个常量；其次，必须创建一个注释文件，将每个枚举指令常量与相关的注释文本关联起来；最后，必须为你的处理器类型定义一个新常量（同样，与处理器模块共享），并在comment.cmt 中创建一个条目，将处理器类型与相关的注释文件对应起来。完成这些步骤后，必须运行loadint ，建立一个新的注释数据库，并将新的处理器类型及相关注释添加到其中。
13.3 小结
虽然idsutils
 和loadint
 现在似乎对你没有什么用处，但是，只要开始应用 IDA 的高级功能，你就需要用到这些实用工具。只需要花一点点时间创建一个.ids 或.til 文件，随后，如果你在将来的项目中遇到由这些文件描述的库，就可以节省大量的时间。记住，IDA 不可能为现有的每一个库提供注释。本章介绍的工具旨在帮助你全面了解 IDA 中的库。
第14章 修补二进制文件及其他IDA 限制
IDA 新用户及潜在用户最常问的一个问题是：“如何使用IDA 修补二进制文件？”这个问题的答案非常简单：“你无法做到。”IDA 的目标是提供最全面的反汇编代码清单，帮助你理解二进制文件的行为。IDA 并不能帮助你轻松修改你所分析的二进制文件。由于没有具体的答案，一些顽固的用户通常会继续提出以下问题：“那么Edit ▶Patch Program菜单有什么用呢？”“File▶Produce File▶Create EXE File 的作用又是什么？”本章将讨论这些明显的反常现象，同时，我们将让 IDA 帮助我们（至少在一定程度上）为二进制程序文件开发补丁程序。
14.1 隐藏的补丁程序菜单
如第11 章所述，Edit ▶Patch Program 菜单是GUI 版本的 IDA 的一项隐藏功能，用户需要编辑idagui.cfg配置文件才能激活该菜单（默认情况下，控制台版本的IDA 的Patch菜单是可用的）。Edit ▶Patch Program 子菜单中的可用选项如图 14-1 所示。
图14-1 Patch program 子菜单
其中的每一个菜单项均表明，你能够以某种有趣的方式修改二进制文件。具体来说，这些选项提供了 3 种修改数据库的方法。实际上，与其他任何菜单项相比，这些菜单项能够更清楚地区分IDA 数据库与创建该数据库的二进制文件之间的区别。创建一个数据库后，IDA 绝不会再次引用最初的二进制文件。鉴于此，这个菜单更适合叫做修补数据库
 。
但是，尽管如此，图 14-1 中的菜单项仍然提供了一种最直接的方法，让你观察你对最初的二进制文件所作的任何更改所造成的影响。在本章后面，我们将讨论如何导出你所作的修改，并最终利用这些信息来修补二进制文件。
14.1.1 更改数据库字节
Edit ▶Patch Program▶Change Byte菜单项用于编辑IDA 数据库中的字节值。相关的字节编辑对话框如图 14-2 所示。
图14-2 Patch Bytes 对话框
这个对话框显示了从光标所在位置开始的 16 个字节的值。你可以更改对话框中显示的部分或全部字节，但是，如果不关闭该对话框，将光标重新定位到一个新的数据库位置，并重新打开该对话框，你将不能修改这 16 个字节以外的其他字节。注意，这个对话框还显示你所更改的字节的虚拟地址和“文件偏移量”值。“文件偏移量”值是你所修改的字节在最初的二进制文件中的十六进制偏移量。由于 IDA 在数据库中保留每个字节在最初文件中的偏移量信息，如果希望为最初的二进制文件开发补丁，就可以利用这些信息。最后，无论你如何修改数据库中的字节，对话框的Original value 字段将始终显示最初加载到数据库中的字节值。IDA 不能自动恢复你对最初的字节值所作的修改，不过，你可以创建一段 IDA 脚本来完成这个任务。
IDA 5.5 引入了一个功能更加强大的十六进制窗口（参见第 5 章），为编辑数据库字节提供了一种更好的解决方案。有了这个集成式十六进制编辑功能，用户很少需要使用 IDA 的“更改字节”功能。
14.1.2 更改数据库中的字
相比于字节修补功能，IDA 的字修补功能的作用更加有限。IDA 的Patch Word 对话框如 图14-3 所示，它一次只能修补一个 2 字节的字。
图14-3 Patch Word 对话框
和修补字节对话框一样，该对话框显示了所修改的字的虚拟地址和文件偏移量。需要记住的是，这里的字值使用底层处理器的自然字节顺序显示。例如，在x86 反汇编代码清单中，字被当做“小端”值处理，而在 MIPS反汇编代码清单中，字被当做“大端”值处理。在输入新的字值时，请记住这一点。与修补字节对话框相同，不论你使用修补字对话框修改过多少次字的值，Original value 字段将始终显示从原始二进制文件中加载的初始值。与字节编辑一样，在 IDA 的Hex View窗口中执行编辑更容易。
14.1.3 使用汇编对话框
“修补程序”菜单中最有趣的功能，可能要数“汇编”选项（Edit ▶Patch Program ▶Assemble ）。遗憾的是，这项功能并非对所有处理器类型有效，因为它取决于当前的处理器模块是否拥有一个内部汇编器。例如，x86 处理器模块支持汇编，而 MIPS处理器模块却不支持汇编。如果缺乏汇编器，你将收到一条错误消息，它指出：“对不起，本处理器模块不支持这种汇编器。”
利用“汇编”选项可以输入使用一个内部汇编器汇编的汇编语言语句。然后，IDA 会将得到的指令字节写入当前的屏幕位置。用于输入指令的 Assemble instruction对话框如图 14-4 所示。
图14-4 Assemble instruction对话框
在Instruction输入框中，一次可以输入一条指令。IDA x86 处理器模块的汇编器组件接受在x86反汇编代码清单中使用的语法。单击 OK（或按下 ENTER键）后，IDA 将汇编你输入的指令，并将对应的指令字节输入数据库中，这些指令字节的起始地址为Address字段中显示的虚拟地址。内部IDA 汇编器可在指令中使用符号名称，只要程序中存在这些名称即可。诸如mov [ebp+var_4]
 、eax
 和call sub_401896
 之类的语法都属于合法语法，汇编器能够正确解析符号引用。
输入一条指令后，该对话框仍处于打开状态，并准备在紧接输入的前一条指令之后的虚拟地址上接受另一条新指令。在你输入其他指令后，该对话框将在 Previous line字段中显示你输入的前一条指令。
输入新指令时，必须注意指令对齐。如果你正输入的指令的长度与它所替代的指令的长度不同，就特别需要注意指令对齐。如果新指令比它所替代的指令短，那么，你需要考虑如何处理旧指令剩下的多余字节（插入NOP1
 指令是一种可行的解决办法）。如果新指令长于它所替代的指令，IDA 将覆盖后面指令的字节，以满足新指令需要。这样做可能会对你的操作造成巨大影响，因此，在使用汇编器修改程序字节时，必须仔细规划。你可以把汇编器看做是一个始终处于覆盖模式的字处理器。如果不覆盖现有的指令，你很难为新指令“开辟”空间。
1. NOP 表示no operation（无操作），在填充程序中的空间时，经常使用这种指令。
需要记住的是，IDA 的数据库修补功能仅限于能够轻松融入现有数据库空间的小型简单补丁。如果补丁需要大量的补充空间，你就需要在最初的二进制文件中查找尚未使用的空间。这些空间通常表现为填充字节，汇编器插入这些填充字节的目的是为了将二进制文件的不同节与特殊的文件边界对齐。例如，在许多 Windows PE文件中，每个程序节的起始文件偏移量必须是 512字节的整数倍。如果某节占用的空间不是 512 字节的整数倍，则必须对它填充，从而为下一节提供一个512 字节的边界。下面这个 PE文件的反汇编代码清单即证实了这种情况：
.text:0040963E     ; [00000006 BYTES: COLLAPSED FUNCTION RtlUnwind. PRESS KEYPAD "+" TO EXPAND]  
.text:00409644                 ➊ align 200h  
.text:00409644     _text           ends  
.text:00409644  
.idata:0040A000     ; Section 2. (virtual address 0000A000)
在这个代码清单中，IDA 使用一个对齐指令（➊）指出该节被填充到一个 512 字节（200h
 ）的边界，其起始地址为.text:00409644
 ，其终点为下一个整数倍的 512 字节，. text:00409800
 。通常，编译器会用零填满填充区域，在十六进制窗口中，这个区域将突出显示。在这个特殊的二进制文件中，文件中的空间足够插入最大为 444（0x1BC=409800h 409644h）字节的补丁数据，这些数据将覆盖.text
 节末尾的一部分或全部以零填充的区域。你可以对函数进行修补，以跳转到二进制文件的这个区域，执行新插入的程序指令，然后跳回最初的函数。
需要注意的是，该二进制文件的下一节，.idata
 节，它的起始地址实际上为.idata:0040A000
 。之所以出现这种情况，是因为内存对齐（而非文件对齐）限制要求 PE区域采用4Kb （一个内存页）的边界。理论上，你可以在00409800~0040A00
 0的内存范围内插入额外的 2048 字节的补丁数据。但是，你很难完成上述操作，因为在这个可执行文件的磁盘映像中，并不存在与这个内存范围对应的字节。为了利用这片空间，你要做的不只是覆盖最初的二进制文件中的一些节。首先，在现有的.text
 节末尾与.idata
 节开头之间插入一个 2048 字节的数据块。其次，我们需要在 PE文件头中调整.text
 节的大小。最后，我们需要在 PE文件头中调整.idata
 及随后的所有节的位置，以反映一个事实，即随后的所有节现在均被后移了 2048 字节。这些更改听起来可能并不十分复杂，但它们需要操作者极其注意细节，并精通 PE文件的格式。