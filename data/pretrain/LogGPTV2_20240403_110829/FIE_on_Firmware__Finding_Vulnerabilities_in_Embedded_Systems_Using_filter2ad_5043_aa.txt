title:FIE on Firmware: Finding Vulnerabilities in Embedded Systems Using
Symbolic Execution
author:Drew Davidson and
Benjamin Moench and
Thomas Ristenpart and
Somesh Jha
FIE on Firmware: Finding Vulnerabilities in 
Embedded Systems using Symbolic Execution
Drew Davidson, Benjamin Moench, Somesh Jha, and Thomas Ristenpart,  
University of Wisconsin—Madison
Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Finding Vulnerabilities in Embedded Systems using Symbolic Execution
FIE on Firmware:
Drew Davidson
Thomas Ristenpart
University of Wisconsin–Madison, {davidson,bsmoench,jha,rist}@cs.wisc.edu
Benjamin Moench
Somesh Jha
Abstract
Embedded systems increasingly use software-driven
low-power microprocessors for security-critical settings,
surfacing a need for tools that can audit the security of
the software (often called ﬁrmware) running on such de-
vices. Despite the fact that ﬁrmware programs are of-
ten written in C, existing source-code analysis tools do
not work well for this setting because of the speciﬁc ar-
chitectural features of low-power platforms. We there-
fore design and implement a new tool, called FIE, that
builds off the KLEE symbolic execution engine in order
to provide an extensible platform for detecting bugs in
ﬁrmware programs for the popular MSP430 family of
microcontrollers. FIE incorporates new techniques for
symbolic execution that enable it to verify security prop-
erties of the simple ﬁrmwares often found in practice.
We demonstrate FIE’s utility by applying it to a corpus
of 99 open-source ﬁrmware programs that altogether use
13 different models of the MSP430. We are able to ver-
ify memory safety for the majority of programs in this
corpus and elsewhere discover 21 bugs.
1
Embedded microprocessors are already ubiquitous, pro-
viding programmatic control over critical, increasingly
Internet-connected physical infrastructure in consumer
devices, automobiles, payment systems, and more. Typ-
ical low-power embedded systems combine a software-
driven microprocessor, together with peripherals such as
sensors, controllers, etc. The software on such devices is
referred to as ﬁrmware, and it is most often written in C.
The use of ﬁrmware exposes embedded systems to
the threat of software vulnerabilities, and researchers
have recently discovered exploitable vulnerabilities in
a wide variety of deployed embedded ﬁrmware pro-
grams [12, 18, 19, 21, 22, 24, 27]. These bugs were found
using a combination of customized fuzz testing and man-
ual reverse engineering, requiring large time investments
by those with rare expertise.
Introduction
To improve ﬁrmware security, one possible approach
would be to use the kinds of source-code analysis tools
that have been successful in more traditional desktop and
server settings (e.g., [2, 4, 8, 9, 11, 13, 17, 26, 28, 31, 36]).
These tools, however, prove insufﬁcient for analyzing
ﬁrmware:
the microcontrollers used in practice have a
wide range of architectures, the nuances of which frus-
trate tools designed with other architectures in mind
(most often x86). Firmware also exhibits characteris-
tics dissimilar to more traditional desktop and server pro-
grams, such as frequent interrupt-driven control ﬂow and
continuous interaction with peripherals. All this suggests
the need to develop new analysis tools for this setting.
We initiate work in this space by building a system,
called FIE, that uses symbolic execution to audit the se-
curity of ﬁrmware programs for the popular MSP430
family of 16-bit microcontrollers. We have used FIE
to analyze 99 open-source ﬁrmware programs written
in C and of varying code complexity. To do so, FIE
had to support 13 different versions of the MSP430
family of 16-bit RISC processors. Our analyses ulti-
mately found 20 distinct memory-safety bugs and one
peripheral-misuse bug.
We designed FIE to support analysis of all potential
execution paths of a ﬁrmware. This means that, modulo
standard but important caveats (see Section 6), FIE can
verify security properties hold for the relatively simple
ﬁrmware programs often seen in practice. For example,
we verify memory safety for 53 of the 99 ﬁrmware pro-
grams in our corpus.
Overview of approach: FIE is based on the KLEE sym-
bolic execution framework [10]. In addition to the en-
gineering efforts required to make KLEE work at all for
MSP430 ﬁrmware programs, we architected FIE to in-
clude various features that render it effective for this new
domain. First, we develop a modular way to specify the
memory layout of the targeted MSP430 variant, the way
in which special memory locations related to peripherals
should be handled, and when interrupt handlers should
USENIX Association  
22nd USENIX Security Symposium  463
be invoked. This all allows analysts to ﬂexibly detail pe-
ripheral behavior. We provide a default speciﬁcation that
models worst-case behavior of all peripherals and inter-
rupts. This default enables analysis without any knowl-
edge or access to (simulators of) individual microcon-
trollers or peripheral components, while ensuring con-
sideration of any possible deployment environment.
Small ﬁrmware programs appear to arise frequently
(our corpus has many that have less than 100 lines of
code) and for these we might hope to achieve complete
analyses, meaning all possible paths are checked. Even
with very small ﬁrmware programs, however, deep or
inﬁnite loops arise often and force the analysis to visit
already-analyzed states of the symbolic execution. We
therefore use a technique called state pruning [6], which
detects when a program state has been previously ana-
lyzed, and if so, removes it from further consideration.
Our realization of pruning keeps a history of all changes
made to memory at each program point, and while sim-
pler than prior approaches (see Section 7) it proves ef-
fective. We also introduce a new technique called mem-
ory smudging, which heuristically identiﬁes loop coun-
ters and replaces them with unconstrained symbolic vari-
ables. While smudging can introduce false positives, our
experiments show them to be rare. Together, pruning and
smudging signiﬁcantly improve code coverage and sup-
port the ability to analyze all possible paths of simpler
ﬁrmware programs.
Summary: This paper has the following contributions:
• We provide (to the best of our knowledge) the ﬁrst
open-source tool designed for automated security
analysis of ﬁrmware for the widely used MSP430 mi-
crocontrollers.
• We explore use of state pruning and memory smudg-
ing to enhance coverage of symbolic execution and to
attempt to verify the absence of classes of bugs. Ul-
timately, FIE is able to verify memory safety on 53
open-source ﬁrmware programs.
• FIE found 21 distinct bugs in the ﬁrmware corpus,
many of which appear to be exploitable memory-
safety violations.
To do these analyses at scale, we developed a system for
managing FIE-powered analyses on Amazon EC2 [1].
The source code for FIE, the ﬁrmware corpus, and the
EC2 virtual machine images and associated management
scripts will all be made publicly available from the ﬁrst
author’s website.1
Outline: The remainder of this paper is structured as
follows: In Section 2, we give background on embed-
ded systems and the MSP430 family, describe a corpus
of open-source ﬁrmware that we gathered, and explain
1http://pages.cs.wisc.edu/davidson/fie
some of the key challenges that must be overcome for
use of symbolic execution in our context. We then give
a high-level overview of how FIE works in Section 3,
and explain its mechanisms in greater detail in Section 4.
We evaluate FIE on the corpus of ﬁrmware examples and
discuss the vulnerabilities found in Section 5. Finally we
discuss limitations of FIE in Section 6, related work fur-
ther in Section 7 and conclude in Section 8.
2 Background and Analysis Targets
Our system, FIE, analyzes embedded ﬁrmware programs
for the MSP430 family of microcontrollers using sym-
bolic execution [2, 8–11, 13, 17, 28, 31, 36]. In this sec-
tion, we describe details of the MSP430 family, discuss
a representative corpus of ﬁrmware programs that we
gathered, review symbolic analysis, and explore the chal-
lenges faced in attempting to use existing tools for anal-
ysis of ﬁrmware programs.
2.1 MSP430 Microcontrollers
We chose Texas Instruments’ (TI’s) MSP430 family of
microcontrollers as our analysis target because of its
popularity. MSP430s already ﬁnd use in security crit-
ical applications such as credit-card point of sale sys-
tems, smoke detectors, motion detectors, seismic sen-
sors, and more [34]. We believe porting our approach to
other, similar low-power microprocessor families would
be straightforward.
Architecture and memory layouts: MSP430s use a
custom, but simple, RISC instruction set, and have a
von Neumann architecture (instructions and data share
the same address space) with at least 16-bit addressing.
MSP430s have a set of CPU registers, which are accessed
via special memory locations. There are over 500 differ-
ent MSP430 microcontroller products. One example is
the MSP430G2x53 series, which consists of 5 different
chips. These have from 1 kB to 16 kB of non-volatile
ﬂash memory and from 256 to 512 bytes of volatile ran-
dom access memory. The memory layouts for the differ-
ent models are distinct, meaning some physical addresses
are invalid on one variant while valid on another.
Hardware peripherals: MSP430 microcontrollers are
used in conjunction with both built-in and external hard-
ware peripherals. Built-in peripherals include ﬂash
memory,
interfaces and
the like, whereas external peripherals (USB hardware,
modems, sensors, etc.) must be connected to the micro-
controller via I/O pins. MSP430s have a limited number
of I/O pins, and so they are multiplexed amongst vari-
ous functions. Usually, one function is general purpose
I/O and the other is an internal function. For applications
that need to use many different functions of the device, a
given pin may be switched between its multiplexed du-
ties several times during execution. Accessing periph-
timers, power management
464  22nd USENIX Security Symposium 
USENIX Association
2
1
2
3
4
5
6
FCTL3 = FWKEY ;
FCTL1 = FWKEY + ERASE ;
* F_ptr = 0;
while ( FCTL3 & BUSY );
FCTL1 = FWKEY ;
FCTL3 = FWKEY + LOCK ;
Figure 1: Code excerpt that clears a ﬂash segment
erals works via memory-mapped I/O or special registers
(which are, in turn, accessed via special memory loca-
tions). We refer to all memory that serves internal or
external peripherals as special memory.
Peripherals often have intricate semantics. For exam-
ple, consider accessing ﬂash memory, which is a built-
in peripheral for nearly all MSP430 models. Figure 1
gives a code snippet taken from the USB drivers in our
corpus (see next section). This code clears a segment
of ﬂash memory using various special registers, which
is required before any writes to that segment can occur:
ﬂash control register 3 (FCTL3) must be set to the spe-
cial ﬂash write key (FWKEY) to unlock the memory and
allow writes to it, and ﬂash control register 1 (FCTL1)
must contain the FWKEY value masked with the particu-
lar value to indicate the type of write. Finally, after the
memory is erased, the ﬂash memory is re-locked by as-
signing the special value FWKEY + LOCK.
Firmware programming: Most MSP430 programs are
written in C, using one of three compilers recommended
by TI: IAR, CCS, and msp430-gcc. The ﬁrst two com-
pilers are commercial products packaged in IDEs, while
the third is a port of the gcc toolchain to the MSP430.
Each of these tools provides a number of extensions to
C. Unfortunately, the extensions do not agree on a single
syntax. As a result, many programs conditionally include
code based on the compiler that is being used. we chose
to base our tool on the msp430-gcc syntax as it is popu-
lar, open-source, and has straightforward extensions.
Embedded ﬁrmware usually operates by setting up
conﬁguration for the program and then spinning in an
inﬁnite loop while waiting for input from the environ-
ment. These event-driven programs use interrupt han-
dlers, busy waiting (e.g., line 4 in Figure 1), and the like
to drive computation in response to I/O from peripherals,
and so interrupt handlers often contain the bulk of the
program logic. A typical ﬁrmware will initialize several
registers specifying which interrupts to activate and then
go to sleep either by setting the chip to a low-power sleep
mode or by entering an explicit inﬁnite loop.
2.2 Firmware Corpus
As mentioned, MSP430s are used in a wide variety of
security-critical applications. The diversity of appli-
cations is reﬂected in the ﬁrmware programs found in
practice, ranging from simple programs for controlling
some external hardware peripheral on up to feature-rich
lightweight operating systems such as Contiki [35]. To
have a concrete set of analysis targets and as well edu-
cate our design of FIE, we have gathered a corpus of 99
open-source MSP430 ﬁrmware programs, which we now
discuss further.
Cardreader: The ﬁrst ﬁrmware in our corpus is
cardreader, a secure credit card reader designed for the
MSP430g2553 and written by one of the authors inde-
pendently of the development of FIE. This was motivated
by recent attacks against smartphone-based point-of-sale
MSP430 devices [20]. Our ﬁrmware assumes the pres-
ence of a magnetic credit card stripe reader attached to
port 1 (conﬁgured for general purpose I/O), and a UART
connection on port 2 (to transmit gathered credit card
data). The cardreader gets as input card data from the
stripe reader, loads a stored cryptographic key from ﬂash
memory, and applies AES encryption to the card data
before writing the result to the UART. cardreader is fully
functional, with 1,883 lines of C code as computed by
the cloc utility, and incorporates many of the MSP430
programming constructs that, as we will see, can thwart
traditional symbolic-execution-based analysis. We made
no efforts to tailor the code to be amenable to analysis
by FIE. We also performed extensive manual audit of
the code to verify the absence of memory or peripheral-
misuse errors.
USB drivers: We additionally use two USB driver
ﬁrmware programs, CDC Driver and HID Driver, taken
from the TI-supplied USB developers package. These
programs include a full USB code stack, and include
7,453 and 7,448 lines of C code, respectively. The partic-
ular programs we chose exercise the CDC (Communica-
tions Device Class) and HID (Human Interface Device)
USB classes, which represent different device types in
the USB speciﬁcation. The CDC-using ﬁrmware, for ex-
ample, takes string commands from an attached terminal
program on a host PC, uses these commands to toggle
the LED in various ways, and sends back an acknowledg-
ment string to the host device. The code that we tested
was written for the IAR compiler, but we manually wrote
Makeﬁles to compile the source code for our analysis.
Community projects and GitHub: In order to increase
the size of our corpus, we searched for open source
projects both on the TI MSP430 Community Projects
website [33] and GitHub. For the former, we manually
crawled the website, and downloaded all projects with
a Makeﬁle, of which we found 12 that compiled prop-
erly. For the latter, we used the GitHub API to automat-
ically download all projects that matched the keyword
“msp430”. There were 360 such projects. Of these, we
culled out those that either: did not include makeﬁles,
USENIX Association  
22nd USENIX Security Symposium  465
3
g2553
g2452
g2231
g2221
g2211
g2001
f5529
f5521
f5310
f2013
f2012
f1612
f149
0
10
20
30
40
LOC
1− 50