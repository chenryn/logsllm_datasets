branch instruction in the mapping table which incurs runtime
overhead. In this section, we evaluate the execution overhead
of rewritten binaries without sanitization. In addition, we also
measure the execution overhead incurred by our sanitization
procedure and the processing time of µSBS itself.
Each ﬁrmware in our benchmark was instrumented and ex-
ecuted twenty times. For example, we executed LCD_Display
original and instrumented ﬁrmware for displaying 5 images
twenty times. Figure 4 presents the runtime overhead results.
The average slowdown for our benchmark without sanitiza-
tion is 8.5%. The second bar in Figure 4 presents the ex-
ecution overhead of instrumented ﬁrmware with the µSBS
sanitizer. It increases the execution overhead to an average
of 32.5% compared to rewritten ﬁrmware without sanitiza-
tion. Audio-Playback, mbed-TLS, and ST-PLC are memory-
intensive ﬁrmware, and therefore we expected the high over-
head results arising from a large number of memory accesses
that are expensive after being instrumented and checked.
While, these overheads are not negligible, we believe that
they are reasonable as this overhead is only incurred on the
devices under security test and not the devices that are actually
deployed on the ﬁeld.
Figure 5 presents how long it takes µSBS to rewrite and
sanitize ﬁrmware binaries. As expected, larger binaries take
more time to be processed. On average, µSBS spends 5.72
seconds on binaries in our benchmark. We regard this as a
promising result compared to state-of-the-art fault observation
method [42]. The efﬁciency of µSBS makes it a practical tool
for the large-scale sanitization of ﬁrmware binaries.
6 Related Work
This section provides an overview of the state-of-the-art. Re-
lated work can be categorised in works related to: (1) fault
observation and (2) binary rewriting.
6.1 Fault Observation
Muench et al. [42] proposed the only existing method for
fault observation in embedded systems by introducing six
heuristics such as heap object tracking. They implemented
these heuristics on top of a combination of the Avatar [61],
PANDA [29], and Boofuzz [2] frameworks. However, these
heuristics suffer from their reliance on a variety of informa-
tion such as: memory accesses, memory mappings, executed
instructions, register state and allocation and deallocation
functions. This information must be extracted from target bi-
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    389
Figure 4: Performance impact of µSBS on 11 real ﬁrmware binaries with and without sanitization.
(HAL), and it is only applicable when the HAL is available to
the analyst. Consequently, HALucinator is not mature enough
for instrumentation in large-scale stripped ﬁrmware binaries.
BinRec [17] is a dynamic binary rewriter that leverages mul-
tiple dynamic analysis techniques to lift binaries into LLVM
IR. BinRec is built on top of S2E [25] and QEMU virtual
machine [21] that do not support bare-metal ﬁrmware.
There are a number of static binary rewriting approaches
that transform binaries before execution. These approaches
differ from each other in how they transform binaries without
breaking their functionality and semantics. Solutions such as
Bistro [27] and STIR [56] redirect control ﬂow from the orig-
inal location to trampoline code containing new instructions.
Trampoline-based rewriters are able to preserve application
semantics after instrumentation, at the cost of considerable
performance and memory penalties.
Uroboros [55] presents a set of heuristics for recognizing
references among integer values and converting them into
assembler labels in order to generate a relocatable assembly
code. Ramblr [54], built atop angr [49, 50], is a similar ap-
proach that improves Uroboros using a composition of static
analyses and heuristics. Unfortunately, heuristics-based ap-
proaches suffer from false positives and negatives that result in
broken reassembled binary. RetroWrite [28] and Egalito [59]
provide an instrumentation method that uses relocation in-
formation which is only available in position independent
codes. This is not a practical solution for ﬁrmware binaries
that are statically linked. Multiverse [20] leverages a super-
set disassembling technique [38, 39, 58] and disassembles at
each offset of the binary code to produce a superset of in-
structions. Multiverse binary rewriter is built on top of the
disassembler to instrument all superset instructions. As noted
by Miller et el. [41], superset disassembly has a substantial
code size overhead (763% on SPECint 2006 benchmarks).
Furthermore, experimental results [59] show that Multiverse
does not support statically linked binaries.
All the above static approaches are designed and devel-
oped for the x86 architecture. RevARM [36] is the only static
binary rewriter proposed for instrumenting ARM-based mo-
Figure 5: µSBS processing time for 11 real ﬁrmware binaries.
nary through reverse engineering and advanced static analysis,
which adds both imprecision and complexity. Furthermore,
applying heuristics for fault observation results in false posi-
tives and false negatives. Instead, µSBS approach turns out
to be not only lightweight, avoiding heavyweight manual
ﬁrmware analysis, but also reliable, being capable of provid-
ing platform-agnostic fault observation.
6.2 Binary Rewriting
Binary rewriting refers to the process of modifying one binary
into another while one or more new instructions are optionally
inserted to provide new features or behaviors. Binary rewrit-
ing methods can be categorized into two main classes: dy-
namic and static methods. Approaches [22,40,43] that belong
to the ﬁrst category transform stripped binaries that are loaded
into memory while they are executing. However, they are not
practical for fault observation on bare-metal devices due to the
high performance overhead and special software/hardware re-
quirements. HALucinator [26] is the state-of-the-art approach
for dynamic binary instrumentation of bare-metal devices. In
addition to the signiﬁcant performance penalty, HALucinator
only supports a small number of microcontrollers. HALucina-
tor emulates ﬁrmware that use a Hardware Abstraction Layer
390    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
Audio-PlaybackLCD-DisplayLCD-AnimateFatFs-uSDTCP-Echo-ClientTCP-Echo-ServerUDP-Echo-ClientUDP-Echo-ServerCamera-USBmbed-TLSST-PLC020406080100120% Performance OverheadRewritten Firmware w/o SanitizationSanitized FirmwareAudio-PlaybackLCD-DisplayLCD-AnimateFatFs-uSDTCP-Echo-ClientTCP-Echo-ServerUDP-Echo-ClientUDP-Echo-ServerCamera-USBmbed-TLSST-PLC0.02.55.07.510.012.515.0Processing Time (Seconds)8.933.163.151.694.84.94.94.74.310.6911.76Table 4: A subjective comparison between µSBS and state-
of-the-art binary rewriting methods proposed for General
Purpose (GP) computers, Mobile (M), and Bare-metal (B)
devices. X and A denote x86 and ARM architectures respec-
tively.
]
0
2
[
]
6
3
[
]
5
5
[
]
8
2
[
e
t
i
r
]
9
5
[
o
t
i
l
a
g
E
]
4
5
[
r
l
b
m
a
R
S
B
S
µ
M
R
A
v
e
R
W
o
r
t
e
R
Objectives
s
o
r
o
b
o
r
U
GP GP GP GP GP M B
A A
Architecture
X
w/o Heuristics

 
w/o Relocation 
 
w/o IR Lifting

 
X



X



X



e
s
r
e
v
i
t
l
u
M
X



Target
bile applications. RevARM lifts binary code to a higher-level
intermediate representation (IR) and performs the instrumen-
tation procedure at that level. As pointed out by Dinesh et
al. [28] lifting a binary to an IR usually misses application
semantics and actual control ﬂows since it is necessary to
precisely model instruction set architecture (ISA) and extract
type information from the binary ﬁle. Additionally, RevARM
uses the Uroboros technique for differentiating references and
integer values which is an impractical solution that is unable
to work on non-trivial application binaries. Table 4 presents
a subjective comparison of state-of-the-art binary rewriting
approaches and µSBS.
7 Discussion
In this section, we discuss the limitations in our system and
shed some light for future work.
Supported microcontrollers. This paper focuses on a spe-
ciﬁc subclass of embedded microcontrollers running a sin-
gle statically linked ﬁrmware—bare-metal ﬁrmware. Like all
other static binary instrumentation methods, we do not handle
any dynamically loaded code. Support for sanitizing such
code requires dynamic instrumentation since such code can
only be seen while the ﬁrmware is running.
Supported CPU architectures. The current implementa-
tion of µSBS supports ARMv7-M architecture as the most
widely used core for embedded systems [35]. Our platform-
independent approach can support bare-metal ﬁrmware devel-
oped for other architectures like x86 with a small extra engi-
neering effort since they are comparable or have more relaxed
requirements for the binary instrumentation purpose [36]. For
example, it is mainly required to change the assembly lan-
guage of the rewritten and inserted instructions and mapping
function in order to support x86 ﬁrmware.
Fuzzing. Although the current µSBS implementation has
focused on the observation of faulty states due to the memory
corruptions, it may be extended and integrated with fuzzing
methods to uncover new bugs in bare-metal ﬁrmware. To be
concrete, µSBS sanitizer can be leveraged to improve the bug-
ﬁnding ability of fuzzing methods [47, 63]. More speciﬁcally,
we may guide the input generation process of the fuzzers
towards triggering µSBS sanitizer checks. Improvement on
IoT fuzzing [31, 32, 62] is orthogonal to this paper, and we
will leave it for future work.
Sanitization. µSBS can potentially observe a wide array
of memory corruptions by applying memory safety policies.
The current implementation of µSBS sanitization process is
inspired by AddressSanitizer and Valgrind’s Memcheck poli-
cies. However, other sanitization techniques can be developed
on top of µSBS binary instrumentation component for observ-
ing faulty states caused by other types of memory corruption
vulnerabilities. We leave such improvements to future work.
8 Conclusion
Memory corruption vulnerabilities are common in IoT
ﬁrmware binaries and can lead to signiﬁcant damage on bare-
metal embedded devices that are increasingly intertwined
with critical industrial and medical processes. In this paper,
we have presented a concrete investigation of hardware se-
curity feature (i.e., MMU, MPU, and DEP) in a represen-
tative selection of IoT SoC families. Our analysis shows
that the IoT fuzzing world lags behind the general-purpose
world. We have also developed and demonstrated µSBS, the
ﬁrst fully automatic approach for observing faulty states
in bare-metal ﬁrmware. µSBS uses a novel combination
of static binary instrumentation and sanitization to validate
memory accesses in a ﬁrmware binary, allowing for an im-
proved fault observation mechanism. We evaluated µSBS
using a fault observation benchmark and 11 real ﬁrmware
binaries. Our approach correctly sanitized all the ﬁrmware
binaries with reasonable run-time over-head and size ex-
pansion while discovering the same set of vulnerabilities
as the state-of-the-art. To motivate further research in this
ﬁeld and encourage reproducibility, we open-source µSBS at
https://github.com/pwnforce/uSBS.
Acknowledgments
This research is supported by the research fund of KU Leu-
ven and imec, a research institute founded by the Flemish
government. The work of the third author has been partially
supported by the EU H2020-SU-ICT-03-2018 Project No.
830929 CyberSec4Europe. We are grateful to anonymous
reviewers for assisting us with their helpful comments and
criticisms.
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    391
References
[1] ARMv7-M
architecture
reference
manual.
https://static.docs.arm.com/ddi0403/eb/
DDI0403E_B_armv7m_arm.pdf. Accessed: February
2020.
[2] BooFuzz source code repository. https://github.
com/jtpereyda/boofuzz. Accessed: February 2020.
[3] Capstone: The ultimate disassembler framework. http:
//www.capstone-engine.org/. Accessed: February
2020.