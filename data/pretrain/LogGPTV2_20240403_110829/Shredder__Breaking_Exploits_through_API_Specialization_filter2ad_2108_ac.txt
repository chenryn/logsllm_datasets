ues. As shown in the second and third columns of Table 2, the
number of imported critical functions and respective call sites is
typically small, with iTunes and Firefox having the highest number
of critical functions. Due to the low number of call sites that need to
be analyzed, Shredder’s data (cid:30)ow analysis takes only a few seconds,
as shown in the fourth column (the reported time excludes the time
IDA Pro needs for code disassembly).
Function Argument Identification. Depending on the accuracy
5.3.2
of the analysis, the nature of the arguments used, and the complexity
of the application, the number of extracted policies varies across
di(cid:29)erent applications, and roughly grows linearly with the number
of critical functions, as shown in the (cid:27)fth column of Table 2. The
highest number of policies (61) is derived for Notepad++, which
involve 11 functions (as shown in the sixth column). On the other
hand, only (cid:27)ve policies could be generated for VLC, which though
still prevent the majority of shellcode samples and some of the
ROP payloads. This is a worst-case scenario, as VLC has a few
invocations of VirtualProtect() performed with the executable
memory (cid:30)ag set, which prohibit the extraction of any meaningful
policy (i.e., all possible values for that argument may be legitimately
observed).
s
n
o
i
t
c
n
u
f
l
a
c
i
t
i
r
c
d
e
t
r
o
p
m
i
f
o
%
0
8
0
6
0
4
0
2
0
7Zip
Chrome
Edge
Firefox
iTunes
PhotoViewer
Notepad++
Powershell
VLC
Winrar
Known Arguments
1
2
3
4
5
6
Figure 3: Percentage of critical API functions with at least
one known argument, for the tested applications. The break-
down in each bar corresponds to the actual number of
known arguments.
To get a better understanding about the cases in which Shred-
der fails to generate a policy, Table 3 lists the functions for which
a policy could not be generated, ordered according to their pop-
ularity in terms of number of call sites (third column) across all
applications. We see that the most frequently challenging functions
are CloseHandle() and DuplicateHandle(), which both take as
argument a handle to an object, which can only be determined
at runtime, followed by (cid:27)le-related functions, which also usually
involve non-static arguments. Although all arguments remain un-
known (last column) in all call sites of these two functions, this
does not impact Shredder’s e(cid:29)ectiveness signi(cid:27)cantly, as these
functions cannot have any signi(cid:27)cant security impact on their own,
and are mostly used in combination with other API functions in
some shellcode samples. On the other hand, for some truly critical
functions like VirtualProtect(), Shredder can still derive known
arguments for the majority of call sites—but not for all of them,
hence the inability to derive a policy. In such cases, more (cid:27)ne-
grained per-call-site policies can be used to force the attacker to use
only the callsites with unknown argument instances, as discussed
in Appendix A.
Fortunately, for most functions, Shredder is able to derive all
possible values for a given argument (in which case it becomes a
known argument, as discussed in Section 3.1). Figure 3 shows the
percentage of critical functions in each application with at least one
known argument. In addition, each bar shows the breakdown in
terms of the number of arguments with known values. For instance,
in 7zip, about 20% of the imported critical functions have one known
argument, 20% have two known arguments, and there are also
a few functions with three and six known arguments. Overall,
with the exception of Chrome, Edge and VLC, Shredder is able
to derive known argument values for more than half of the critical
functions. Usually, a larger number of known arguments for a given
function leads to a larger number of policies, as there is a higher
potential for deriving further restrictions across di(cid:29)erent argument
combinations, as discussed in Section 3.1.
7ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Shachee Mishra and Michalis Polychronakis
Table 2: Policy generation and protection e(cid:29)ectiveness results for a set of Windows 64-bit applications.
Analysis Generated
Functions
Policies w/ Policies
Broken Exploit Payloads
Shellcode
ROP ROP Equiv.
Application
Critical
Functions
Call
Sites
7Zip
Google Chrome
Microso(cid:28) Edge
Mozilla Firefox
iTunes
PhotoViewer
Notepad++
Powershell
VLC
Winrar
8
14
15
20
33
8
12
5
12
10
39
113
337
104
315
17
84
5
24
120
Time (sec)
1.2
3.4
4.8
1.8
2.3
1.4
1.1
0.4
0.5
1.3
Table 3: Functions for which Shredder cannot derive a policy
in some applications.
API Function
Apps
Call
Sites
Known Unknown
Instances
Instances
CloseHandle()
DuplicateHandle()
DeleteFileW()
ReadFile()
WriteFile()
VirtualProtect()
ExitThread()
ioctlsocket()
CreateProcessW()
InternetReadFile()
InternetOpenW()
ExitProcess()
bind()
closesocket()
10
7
6
2
1
5
4
1
1
2
2
3
1
1
124
13
12
3
1
6
6
3
5
4
4
3
1
1
0
0
0
1
0
3
1
2
4
3
2
0
0
0
124
13
12
2
1
3
5
1
1
1
2
3
1
1
5.4 Protection E(cid:29)ectiveness
After generating API specialization policies for each application,
we set out to explore their e(cid:29)ectiveness against real-world exploits,
and the added protection bene(cid:27)t compared to code stripping [50],
i.e., simply removing any non-imported system API functions.
5.4.1 E(cid:27)ectiveness Against Real-world Exploits. Based on our con-
servative assumption that any of the 251 shellcode and 30 ROP
payload samples (for brevity, we collectively refer to both as “pay-
loads” in the rest of this section) in our data set can be used against
any application, we used our custom payload analysis framework
to run each sample and capture all critical API function invocations.
We then compare these invocation patterns with the API special-
ization policies of each application to determine whether Shredder
is able to block a given payload. A payload is broken if at least
one of the API functions it uses violates one the enforced policy.
This means that either the function is not imported and used at all
(in which case code stripping alone would also block it), or that
7
9
12
17
25
6
11
4
5
8
242 ( 96%)
251 (100%)
248 ( 98%)
244 ( 97%)
246 ( 98%)
228 ( 91%)
244 ( 97%)
246 ( 98%)
216 ( 86%)
242 ( 96%)
30 (100%)
30 (100%)
30 (100%)
30 (100%)
22 ( 65%)
30 (100%)
30 (100%)
30 (100%)
9 ( 30%)
30 (100%)
30 (100%)
30 (100%)
30 (100%)
30 (100%)
1 ( 3%)
30 (100%)
30 (100%)
30 (100%)
1 ( 3%)
30 (100%)
14
29
28
54
59
21
61
14
11
34
0
5
2
0
0
2
0
5