0
..
..
..
..
..
..
..
1
2,2
...
ζ∗
...
ζ∗
p,2
0
...
..
η∗
1,m
0
...
η∗
2,m
0
...
η∗
p,m
0
0
..
..
..
..
..
0
. . .
..
..
0
...
0
(cid:34) 1
...
..
..
...
. . .
..
. . .
..
1
...
0
 C =
η∗
1,1
0
...
η∗
2,1
0
...
η∗
p,1
0
0
B =
(cid:35)
..
. . .
..
..
..
..
1
0
...
0
0
..
0
..
..
ij is the jth element of aggregate parameter vectors ζ∗
ij is the jth element of aggregate
where ζ∗
for application i. Similarly, η∗
parameter vectors η∗ for application i.
B. The Model Predictive Controller
The control goal is to steer the system into a state of
optimum target tracking, while penalizing large changes in
the control variables. It minimizes the deviation of application
performance from their respective targets.
1) MIMO Control Problem: The model predictive con-
troller decides the control actions at every control period k
by minimizing the following cost function:
V (k) =
||r − y(k + i)||2
P +
||∆u(k + j)||2
Q.
(13)
i=1
j=0
Hp(cid:88)
Hc−1(cid:88)
7
Here, y(k) is a vector containing the performance measure
of each application. The controller uses the linearized state-
space model to predict each application’s performance over
Hp control periods, called the prediction horizon. It computes
a sequence of control actions ∆u(k), ∆u(k + 1), .., ∆u(k +
Hc − 1) over Hc control periods, called the control horizon,
to keep the predicted performance close to their pre-deﬁned
targets r. The control action is the change in CPU usage limits
imposed on various applications. P and Q are the weighting
matrices whose relative magnitude provides a way to tradeoff
tracking accuracy for better stability in the control actions.
The control problem is subject to the constraint that the
sum of CPU usage limits assigned to all applications must be
bounded by the total CPU capacity of the physical server. The
constraint is formulated as:
(∆uj(k) + uj(k)) ≤ Umax
(14)
j=1
where M is the number of applications hosted in a resource
pool and Umax is the total CPU capacity of the resource pool.
2) Transformation to Quadratic Programming Problem:
We transform the control formulation to a standard quadratic
programming problem, which allows us to design and imple-
ment the control algorithm based on an effective quadratic
programming method. The MIMO control problem deﬁned by
Eq. (13) is transformed to a quadratic program:
M(cid:88)
Minimize 1
2
subject to constraint Ω∆u(k) ≤ ω.
∆u(k)T H∆u(k) + cT ∆u(k)
(15)
The matrices Ω and ω are chosen to formulate the con-
straints on CPU resource usage. Here, ∆u(k) is a matrix con-
taining the CPU usage limits on each virtual machine over the
entire control horizon Hc. In the minimization formulation,
H = 2(RT
u P Ru + Q).
(16)
c = 2[RT
(17)
The matrices Ru and Rx are associated with the performance
interference model of the hosted applications.
u P T (RxAx(k) − r)]T .
Ru =
C
CA
...
CAHp−1
 Rx =
CB
CAB
0
CB
..
..
0
0
...
. . .
CAHp−1B CAHp−1B ..
...
...
CAHp−Hc B
VI. SYSTEM IMPLEMENTATION
A. The Testbed
We have implemented NINEPIN on a testbed of an HP
ProLiant BL460C G6 blade server module and an HP EVA
storage area network with 10 Gbps Ethernet and 8 Gbps
Fibre/iSCSI dual channels. The blade server is equipped with
Intel Xeon E5530 2.4 GHz quad-core processor and 32 GB
PC3 memory. Xeon processor incorporates a three level cache
hierarchy, where each core has its own L1 (32KB) and L2
(256KB) caches, and there is a large shared 8MB L3 cache.
Virtualization of the server is enabled by an enterprise-level
virtualization product, VMware ESX 4.1. VMware’s vSphere
module controls the CPU usage limits in MHz allocated to the
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:50:15 UTC from IEEE Xplore.  Restrictions apply. 
8
Fig. 4. Service-level utility of various SPEC CPU2006 applications.
on the data collected from the virtualized server system
to construct performance interference and energy usage
models. The fuzzy logic toolbox in MATLAB is invoked
for this purpose.
4) Hierarchical Controller: It applies a genetic algorithm
for system utility optimization and invokes a quadratic
programming solver, quadprog, in MATLAB to execute
the control algorithm described in Section V-B. The
solution of the control algorithm in terms of VM CPU
usage limits is sent to the resource allocator.
5) Resource Allocator: It uses vSphere API to impose CPU
usage limits on the VMs. The vSphere module provides
an interface to execute a method Reconf igV M T ask
to modify a VM’s CPU usage limit.
VII. PERFORMANCE EVALUATION
For performance evaluation, we consider various service-
level utility functions of SPEC CPU2006 applications as
shown in Figure 4. We chose these utility functions as a
case study without any loss of generality. We consider that
the utility of energy consumption is given by a linear utility
function as follows:
U (E) =  ∗ Energy
(18)
where Energy is the total energy consumed by virtualized
resource pool hosting multiple SPEC CPU2006 applications
and  is a negative constant, which expresses the relative
value of energy and performance objectives. Note that the
applicability of NINEPIN in virtualized servers is independent
of the chosen utility functions.
We use SPEC CPU2006 suite’s runspec tool to run various
benchmarks simultaneously on the co-located VMs. Each
benchmark is run on multiple iterations to measure its average
performance in terms of the SPECspeed metric. It is amount
of time taken to complete a single task. The energy usage
is measured in kilojoules (kJ). It is a product of the average
power consumption and the average task completion time of
the benchmark with the longest running tasks.
A. Performance Isolation
First, we study the impact of performance interference
between co-located applications on their performance. We
Fig. 3. SPEC CPU2006 workload mixes.
VMs. It also provides an API to support the remote manage-
ment of VMs. We create a resource pool from the virtualized
server to host multiple applications. Each application is hosted
inside a VMware virtual machine with one VCPU, 4 GB RAM
and 15 GB hard disk space. We assign the CPU afﬁnity of each
VM to a particular CPU core. The guest operating system used
is Ubuntu Linux version 10.04.
Our testbed utilizes four VMs on the same quad-core
processor to host a set of four CPU bound benchmark appli-
cations from the SPEC CPU2006 suite. We choose ﬁve of the
SPEC CPU2006 benchmarks that are identiﬁed as being cache
sensitive in study [20], and use all possible combinations of
four as experimental workload mixes shown in Figure 3.
For experiments with heterogeneous application environ-
ment, we use SPEC CPU2006 benchmark with the popular
RUBiS benchmark [6], [14], [22]. RUBiS is an open-source
multi-tier application benchmark. It implements the core func-
tionality of an eBay like auction site: selling, browsing and
bidding. The application contains a Java-based client
that
generates a session-oriented workload. RUBiS sessions have
an average duration of 15 minutes and the average think time
is ﬁve seconds. We use three VMs to host a three-tier RUBiS
application and the fourth VM to host one SPEC CPU2006
benchmark application. We instrument RUBiS clients to gen-
erate workloads of time-varying intensity.
B. NINEPIN Components
We implement the components of the NINEPIN framework
on a separate machine and issue commands to the virtualized
server over the network using VMware vSphere API 4.1.
1) Power Monitor: The average power consumption of the
virtualized server is measured at the resource pool level
by using a new feature of VMware ESX 4.1. VMware
gathers such data through its Intelligent Power Manage-
ment Interface sensors. The power monitor program uses
vSphere API to collect the power measurement data.
2) Performance Monitor: It uses a sensor program provided
by RUBiS client for performance monitoring of the
interactive application in terms of average end-to-end
request response time. For compute intensive jobs, it
measures the average job completion time of each VM
running the SPEC CPU2006 benchmark application.
3) Performance Interference and Energy Usage Modeling:
It applies subtractive clustering and ANFIS techniques
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:50:15 UTC from IEEE Xplore.  Restrictions apply. 
 0 200 400 600 800 1000UtilityJob Completion Time (ms)471.omnetpp470.lbm437.leslie3d459.GemsFDTD436.cactusADM9
(a) Normalized performance.
(b) Performance improvement.
(c) Resource allocations.
Fig. 5. Performance isolation by default, Q-Clouds and NINEPIN.
PERFORMANCE OF WORKLOAD MIX-1’S CPU2006 BENCHMARK
APPLICATIONS WITHOUT PERFORMANCE ISOLATION.
TABLE 1
PERFORMANCE TARGETS FOR SPEC CPU2006 APPLICATIONS.
TABLE 3
Completion Time (ms)
Running alone
Running in co-located VMs
Application
436.cactusADM
437.leslie3d
459.GemsFDTD
470.lbm
2433
1091
1190
825
2931
1586
1676
1145
Target
Set
1
2
3
4
5
CPU Equivalent Performance %
436.cactusADM 437.leslie3d
459.GemsFDTD
25
50
75
100
70
25
50
75
100
83
25
50
75
100
78
470.lbm
25
50
75
100
88
PERFORMANCE OF WORKLOAD MIX-1’S CPU2006 BENCHMARK
APPLICATIONS WITH PERFORMANCE ISOLATION.
TABLE 2
Application
436.cactusADM
437.leslie3d
459.GemsFDTD
470.lbm
Completion Time (ms)
Q-Clouds
NINEPIN
2796.5
2482.65
1435.52
1487.5
993.97
1091
1190
750
consider SPEC CPU2006 workload mix 1 that consists of CPU
2006 benchmark applications 436.cactusADM, 437.leslie3d,
459.GemsFDTD and 470.lbm. Table 1 compares the average
completion time of the four benchmark applications in the
workload mix 1 when each is run on an isolated VM as
opposed to when all of them are run simultaneously in
co-located VMs. All four benchmark applications exhibit
performance degradation in the absence of a performance
isolation mechanism. For example, for benchmark applica-
tion 436.cactusADM, the performance degradation is about
20%. For benchmark application 437.leslie3d, the performance
degradation is about 20%. We observe an average performance