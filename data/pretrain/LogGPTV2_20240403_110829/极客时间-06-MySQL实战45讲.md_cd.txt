## 追问 9：redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？回答：这两个问题可以一起回答。在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：    begin;insert into t1 ...insert into t2 ...commit;这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没commit 的时候就直接写到 redo log 文件里。所以，redo log buffer 就是一块内存，用来先存 redo日志的。也就是说，在执行第一个 insert 的时候，数据的内存被修改了，redolog buffer 也写入了日志。但是，真正把日志写到 redo log 文件（文件名是 ib_logfile+数字），是在执行 commit 语句的时候做的。（这里说的是事务执行过程中不会"主动去刷盘"，以减少不必要的 IO消耗。但是可能会出现"被动写入磁盘"，比如内存不够、其他事务提交等情况。这个问题我们会在后面第22 篇文章《MySQL 有哪些"饮鸩止渴"的提高性能的方法？》中再详细展开）。单独执行一个更新语句的时候，InnoDB会自己启动一个事务，在语句执行完成的时候提交。过程跟上面是一样的，只不过是"压缩"到了一个语句里面完成。以上这些问题，就是把大家提过的关于 redo log 和 binlog的问题串起来，做的一次集中回答。如果你还有问题，可以在评论区继续留言补充。
# 业务设计问题接下来，我再和你分享 \@ithunter 同学在第 8篇文章[《](https://time.geekbang.org/column/article/70562)[事务到底是隔离的还是不隔离的？](https://time.geekbang.org/column/article/70562)[》](https://time.geekbang.org/column/article/70562)的评论区提到的跟索引相关的一个问题。我觉得这个问题挺有趣、也挺实用的，其他同学也可能会碰上这样的场景，在这里解答和分享一下。问题是这样的（我文字上稍微做了点修改，方便大家理解）：> 业务上有这样的需求，A、B> 两个用户，如果互相关注，则成为好友。设计上是有两张表，一个是 like> 表，一个是 friend 表，like 表有 user_id、liker_id> 两个字段，我设置为复合唯一索引即> uk_user_id_liker_id。语句执行逻辑是这样的：> 以 A 关注 B 为例：\> 第一步，先查询对方有没有关注自己（B 有没有关注 A）\> select \* from like where user_id = B and liker_id = A;> 如果有，则成为好友\> insert into friend;> 没有，则只是单向关注关系\> insert into like;> 但是如果 A、B 同时关注对方，会出现不会成为好友的情况。因为上面第 1> 步，双方都没关注对方。第 1> 步即使使用了排他锁也不行，因为记录不存在，行锁无法生效。请问这种情况，在> MySQL 锁层面有没有办法处理？首先，我要先赞一下这样的提问方式。虽然极客时间现在的评论区还不能追加评论，但如果大家能够一次留言就把问题讲清楚的话，其实影响也不大。所以，我希望你在留言提问的时候，也能借鉴这种方式。接下来，我把 \@ithunter 同学说的表模拟出来，方便我们讨论。    CREATE TABLE `like` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `user_id` int(11) NOT NULL,  `liker_id` int(11) NOT NULL,  PRIMARY KEY (`id`),  UNIQUE KEY `uk_user_id_liker_id` (`user_id`,`liker_id`)) ENGINE=InnoDB; CREATE TABLE `friend` (  id` int(11) NOT NULL AUTO_INCREMENT,  `friend_1_id` int(11) NOT NULL,  `firned_2_id` int(11) NOT NULL,  UNIQUE KEY `uk_friend` (`friend_1_id`,`firned_2_id`)  PRIMARY KEY (`id`)) ENGINE=InnoDB;虽然这个题干中，并没有说到 friend 表的索引结构。但我猜测 friend_1\_id 和friend_2\_id 也有索引，为便于描述，我给加上唯一索引。顺便说明一下，"like"是关键字，我一般不建议使用关键字作为库名、表名、字段名或索引名。我把他的疑问翻译一下，在并发场景下，同时有两个人，设置为关注对方，就可能导致无法成功加为朋友关系。现在，我用你已经熟悉的时刻顺序表的形式，把这两个事务的执行语句列出来：\![](Images/95708cf4e4ac1681280e2c6791a03393.png){savepage-src="https://static001.geekbang.org/resource/image/c4/ed/c45063baf1ae521bf5d98b6d7c0e0ced.png"}```{=html}```图 3 并发"喜欢"逻辑操作顺序]{.reference}```{=html}```由于一开始 A 和 B 之间没有关注关系，所以两个事务里面的 select语句查出来的结果都是空。因此，session 1 的逻辑就是"既然 B 没有关注A，那就只插入一个单向关注关系"。session 2 也同样是这个逻辑。这个结果对业务来说就是 bug了。因为在业务设定里面，这两个逻辑都执行完成以后，是应该在 friend表里面插入一行记录的。如提问里面说的，"第 1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效"。不过，我想到了另外一个方法，来解决这个问题。首先，要给"like"表增加一个字段，比如叫作 relation_ship，并设为整型，取值1、2、3。> 值是 1 的时候，表示 user_id 关注 liker_id;\> 值是 2 的时候，表示 liker_id 关注 user_id;\> 值是 3 的时候，表示互相关注。然后，当 A 关注 B 的时候，逻辑改成如下所示的样子：应用代码里面，比较 A 和 B 的大小，如果 A\ begin; /* 启动事务 */insert into `like`(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship=relation_ship | 1;select relation_ship from `like` where user_id=A and liker_id=B;/* 代码中判断返回的 relation_ship，  如果是 1，事务结束，执行 commit  如果是 3，则执行下面这两个语句：  */insert ignore into friend(friend_1_id, friend_2_id) values(A,B);commit;如果 A\>B，则执行下面的逻辑    mysql> begin; /* 启动事务 */insert into `like`(user_id, liker_id, relation_ship) values(B, A, 2) on duplicate key update relation_ship=relation_ship | 2;select relation_ship from `like` where user_id=B and liker_id=A;/* 代码中判断返回的 relation_ship，  如果是 2，事务结束，执行 commit  如果是 3，则执行下面这两个语句：*/insert ignore into friend(friend_1_id, friend_2_id) values(B,A);commit;这个设计里，让"like"表里的数据保证 user_id \ CREATE TABLE `t` (`id` int(11) NOT NULL primary key auto_increment,`a` int(11) DEFAULT NULL) ENGINE=InnoDB;insert into t values(1,2);这时候，表 t 里有唯一的一行数据 (1,2)。假设，我现在要执行：    mysql> update t set a=2 where id=1;你会看到这样的结果：![](Images/9c4551c25ed7e8f9638fa927d1629ba9.png){savepage-src="https://static001.geekbang.org/resource/image/36/70/367b3f299b94353f32f75ea825391170.png"}\结果显示，匹配 (rows matched) 了一行，修改 (Changed) 了 0 行。仅从现象上看，MySQL 内部在处理这个命令的时候，可以有以下三种选择：1.  更新都是先读后写的，MySQL 读出数据，发现 a 的值本来就是    2，不更新，直接返回，执行结束；2.  MySQL 调用了 InnoDB 引擎提供的"修改为    (1,2)"这个接口，但是引擎发现值与原来相同，不更新，直接返回；3.  InnoDB 认真执行了"把这个值修改成    (1,2)\"这个操作，该加锁的加锁，该更新的更新。你觉得实际情况会是以上哪种呢？你可否用构造实验的方式，来证明你的结论？进一步地，可以思考一下，MySQL为什么要选择这种策略呢？你可以把你的验证方法和思考写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。
# 上期问题时间上期的问题是，用一个计数表记录一个业务表的总行数，在往业务表插入数据的时候，需要给计数值加1。逻辑实现上是启动一个事务，执行两个语句：1.  insert into 数据表；2.  update 计数表，计数值加 1。从系统并发能力的角度考虑，怎么安排这两个语句的顺序。这里，我直接复制 \@阿建 的回答过来供你参考：> 并发系统性能的角度考虑，应该先插入操作记录，再更新计数表。\> 知识点在[《行锁功过：怎么减少行锁对性能的影响？》](https://time.geekbang.org/column/article/70215)\> 因为更新计数表涉及到行锁的竞争，先插入再更新能最大程度地减少事务之间的锁等待，提升并发度。评论区有同学说，应该把 update计数表放后面，因为这个计数表可能保存了多个业务表的计数值。如果把 update计数表放到事务的第一个语句，多个业务表同时插入数据的话，等待时间会更长。这个答案的结论是对的，但是理解不太正确。即使我们用一个计数表记录多个业务表的行数，也肯定会给表名字段加唯一索引。类似于下面这样的表结构：    CREATE TABLE `rows_stat` (  `table_name` varchar(64) NOT NULL,  `row_count` int(10) unsigned NOT NULL,  PRIMARY KEY (`table_name`)) ENGINE=InnoDB;在更新计数表的时候，一定会传入 wheretable_name=\$table_name，使用主键索引，更新加行锁只会锁在一行上。而在不同业务表插入数据，是更新不同的行，不会有行锁。评论区留言点赞板：> \@北天魔狼、@斜面镜子 Bil 和 \@Bin 等同学，都给出了正确答案；\> \@果然如此> 同学提了一个好问题，虽然引入事务，避免看到"业务上还没提交的更新"，但是> Redis 的计数被提前看到了。核心原因还是两个系统，不支持一致性视图；\> @ 帆帆帆帆帆帆帆帆 同学的问题提醒了大家，count(id)> 也是可以走普通索引得到的。![](Images/48edcb93fb03e3e52d7e7099be6b5cb3.png){savepage-src="https://static001.geekbang.org/resource/image/09/77/09c1073f99cf71d2fb162a716b5fa577.jpg"}
# 30 \| 答疑文章（二）：用动态的观点看加锁在第[20](https://time.geekbang.org/column/article/75173)和[21](https://time.geekbang.org/column/article/75659)篇文章中，我和你介绍了InnoDB 的间隙锁、next-keylock，以及加锁规则。在这两篇文章的评论区，出现了很多高质量的留言。我觉得通过分析这些问题，可以帮助你加深对加锁规则的理解。所以，我就从中挑选了几个有代表性的问题，构成了今天这篇答疑文章的主题，即：用动态的观点看加锁。**为了方便你理解，我们再一起复习一下加锁规则。这个规则中，包含了两个"原则"、两个"优化"和一个"bug"：**-   原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock    是前开后闭区间。-   原则 2：查找过程中访问到的对象才会加锁。-   优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock    退化为行锁。-   优化    2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key    lock 退化为间隙锁。-   一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。接下来，我们的讨论还是基于下面这个表 t：    CREATE TABLE `t` (  `id` int(11) NOT NULL,  `c` int(11) DEFAULT NULL,  `d` int(11) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `c` (`c`)) ENGINE=InnoDB; insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);
# 不等号条件里的等值查询有同学对"等值查询"提出了疑问：等值查询和"遍历"有什么区别？为什么我们文章的例子里面，where条件是不等号，这个过程里也有等值查询？``{=html}我们一起来看下这个例子，分析一下这条查询语句的加锁范围：    begin;select * from t where id>9 and id```图 1 索引 id 示意图]{.reference}```{=html}```1.  首先这个查询语句的语义是 order by id    desc，要拿到满足条件的所有行，优化器必须先找到"第一个 id\```图 2 in 语句的 explain 结果]{.reference}```{=html}```可以看到，这条 in 语句使用了索引 c 并且 rows=3，说明这三个值都是通过 B+树搜索定位的。在查找 c=5 的时候，先锁住了 (0,5\]。但是因为 c不是唯一索引，为了确认还有没有别的记录 c=5，就要向右遍历，找到 c=10才确认没有了，这个过程满足优化 2，所以加了间隙锁 (5,10)。同样的，执行 c=10 这个逻辑的时候，加锁的范围是 (5,10\] 和 (10,15)；执行c=20 这个逻辑的时候，加锁的范围是 (15,20\] 和 (20,25)。通过这个分析，我们可以知道，这条语句在索引 c上加的三个记录锁的顺序是：先加 c=5 的记录锁，再加 c=10 的记录锁，最后加c=20 的记录锁。你可能会说，这个加锁范围，不就是从 (5,25) 中去掉 c=15的行锁吗？为什么这么麻烦地分段说呢？因为我要跟你强调这个过程：这些锁是"在执行过程中一个一个加的"，而不是一次性加上去的。理解了这个加锁过程之后，我们就可以来分析下面例子中的死锁问题了。如果同时有另外一个语句，是这么写的：    select id from t where c in(5,20,10) order by c desc for update;此时的加锁范围，又是什么呢？我们现在都知道间隙锁是不互锁的，但是这两条语句都会在索引 c 上的c=5、10、20 这三行记录上加记录锁。这里你需要注意一下，由于语句里面是 order by c desc，这三个记录锁的加锁顺序，是先锁 c=20，然后 c=10，最后是 c=5。也就是说，这两条语句要加锁相同的资源，但是加锁顺序相反。当这两条语句并发执行的时候，就可能出现死锁。关于死锁的信息，MySQL只保留了最后一个死锁的现场，但这个现场还是不完备的。有同学在评论区留言到，希望我能展开一下怎么看死锁。现在，我就来简单分析一下上面这个例子的死锁现场。