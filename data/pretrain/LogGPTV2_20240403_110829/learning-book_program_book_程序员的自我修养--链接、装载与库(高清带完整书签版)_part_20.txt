这种简单面原始的方法的确能够暂时减少多种语言目标文件之间的符号冲突的概率，但
还是没有从根本上解决符号冲突的问题，比如同一种语言编写的目标文件还有可能会产生符
号冲突，当程序很大时，不同的模块由多个部门（个人）开发，它们之间的命名规范如果不
严格，则有可能导致冲突。于是像C++这样的后来设计的语言开始考虑到了这个间题，增加
了名称空间（Namespace）的方法来解决多模块的符号冲突问题。
但是随着时间的推移，很多操作系统和编译器被完全重写了好儿遍，比如UNIX也分化
成了很多种，整个环境发生了很大的变化，上面所提到的跟Fortran和古老的汇编库的符号
冲突问题已经不是那么明显了。在现在的Linux下的GCC编译器中，默认情况下已经去掉
了在C语言符号前加”_”的这种方式：但是Windows平台下的编译器还保持的这样的传统，
比如 Visual C++编译器就会在C语言符号前加r"_",GCC在Windows平台下的版本（cygwin、
“-fno-leading-underscore”来打开和关闭是否在C语言符号前加.上下划线。
C++符号修饰
众所周知，强大而又复杂的C++拥有类、继承、虚机制、重载、名称空间等这些特性，
它们使得符号管理更为复杂。最简单的例子，两个相同名字的函数func(int)和 func(double)，
尽管函数名相同，但是参数列表不同，这是C++里面函数重载的最简单的一种情况，那么编
译器和链接器在链接过程中如何区分这两个函数呢？为了支持C++这些复杂的特性，人们发
明了符号修饰（Name Decoration）或符号改编（Name Mangling）的机制，下面我们来看
看C++的符号修饰机制。
首先出现的一个间题是C++允许多个不同参数类型的函数拥有一样的名字，就是所调的
函数重载：另外C++还在语言级别支持名称空间，即允许在不同的名称空间有多个同样名字
的符号。比如清单3-4这段代码。
清单3-4C++函数的名称修饰
int func (int):
float func(float);
class C {
int fune(int);
class C2 {
1 ;
int func (int) ;
) :
namespace N (
int func (int):
程序员的自我修养一链接、装载与库
---
## Page 111
88
第3章目标文件里有什么
class C {
int fune(int):
} 1
1
这段代码中有6个同名函数叫func，只不过它们的返回类型和参数及所在的名称空间不
同。我们引入一个术语叫做函数签名（Function Signature），函数签名包含了一个函数的信
息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息。函数签名用于识别不
同的函数，就像签名用于识别不同的人一样，函数的名字只是函数签名的一部分。由于上面
6个同名函数的参数类型及所处的类和名称空间不同，我们可以认为它们的函数签名不同。
在编译器及链接器处理符号时，它们使用某种名称修饰的方法，使得每个函数签名对应一个
修饰后名称（Decorated Name）。编译器在将C++源代码编译成目标文件时，会将函数和
变量的名字进行修饰，形成符号名，也就是说，C++的源代码编译后的目标文件中所使用的
符号名是相应的函数和变量的修饰后名称。C++编译器和链接器都使用符号来识别和处理函
数和变量，所以对于不同函数签名的函数，即使函数名相同，编译器和链接器都认为它们是
不同的函数。上面的6个函数签名在GCC编译器下，相对应的修饰后名称如表3-18所示。
表3-18
函数签名
修饰后名称（符号名）
int func(int)
ZAfunci
float funo(float)
ZAfuncf
int C:fune(int)
_ZN1C4funcEi
int C:C2::func(int)
ZN1C2C24funcEi
int N:func(int)
_ZN1N4funcEi
int N::C::func(int)
_ZN1N1C4funcEi
GCC的基本C++名称修饰方法如下：所有的符号都以“_Z”开头，对于嵌套的名字（在
名称空间或在类里面的），后面紧跟“N”，然后是各个名称空间和类的名字，每个名字前是
名字字符串长度，再以“E”结尾。比如N:C：func经过名称修饰以后就是_ZNINIC4funcE。
对于一个函数来说，它的参数列表紧跟在“E”后面，对于int类型来说，就是字母“i”。所
以整个N：C：func（int）函数签名经过修饰为_ZNIN1C4funcEi，更为其体的修饰方法我们在这
里不详细介绍，有兴避的读者可以参考GCC的名称修饰标准，幸好这种名称修饰方法我们
平时程序开发中也很少手工分析名称修饰问题，所以无须很详细地了解这个过程，binurils
里面提供了一个叫“c++6ilt”的工具可以用来解析被修饰过的名称，比如：
$ c++fi1t _zN1N1C4funcE1
N: : C: : func (int)
签名和名称修饰机制不光被使用到函数上，C++中的全局变量和静态变量也有同样的机
制，对于全局变量来说，它跟函数一样都是个全局可见的名称，它也遵循上面的名称修饰
机制，比如一个名称空间foo中的全局变量bar，它修饰后的名字为：_ZN3foo3barE。值得
程序员的自我修养—链接、装载与库
---
## Page 112
3.5链接的接口—符号
89
注意的是，变量的类型并没有被加入到修饰后名称中，所以不论这个变量是整形还是浮点型
甚至是一个全局对象，它的名称都是一样的。
名称修饰机制也被用来防止静态变量的名字冲突，比如main0函数里面有一个静态变量
叫foo，而funcO函数里面也有一个静态变量叫foo.为了区分这两个变量，GCC会将它们
的符号名分别修饰成两个不同的名字_ZZ4mainE3foo和_ZZAfuncvE3foo，这样就区分了这两
个变量。
不同的编译器厂商的名称修伤方法可能不同，所以不同的编译器对于同一个函数签名可
能对应不同的修饰后名称。比如上面的函数签名中在VisualC++编译器下，它们的修饰后名
称如表3-19所示。
表3-19
函数签名
int fune(int)
ZHHAung
float func(float)
int C:func(int)
int C:C2:func(int)
?func@C2@C@@AAEHH@Z
int N:fune(int)
ZOHHAN
int N:C:func(int)
unc@C@N@AAEHH@Z
我们以 intN:C：func(int）这个函数签名来猜测Visual C++的名称修饰规则（当然，你只
须大概了解这个修饰规则就可以了）.修饰后名字由“？”开头，接着是函数名由“@”符号
第4章详细介绍），接着是函数的参数类型及返回值，由“@”结束，最后由“Z”结尾。可
以看到函数名、参数的类型和名称空间都被加入了修饰后名称，这样编译器和链接器就可以
区别同名但不同参数类型或名字空间的函数，而不会导致ink的时候函数多重定义。
VisualC++的名称修饰规则并没有对外公开，当然，一般情况下我们也无须了解这套规
则，但是有时候可能须要将一个修饰后名字转换成函数签名，比如在链接、调试程序的时候
可能会用到。Microsoft 提供了一个UnDecorateSymbolNameO的 API，可以将修饰后名称转
换成函数签名。下面这段代码使用UnDecoratSymbolNameO将修饰后名称转换成函数签名：
/* 2-4.c
•Compi1e1C12-4.c/1ink Dbghe1p.1ib
· Usage: 2-4.exe DecroatedName
*/
include 
#include 
int main( int arge, char* argv[1 1
程序员的自我修养一链接、装载与库
---
## Page 113
90
第3章目标文件里有什么
char buffer [256]:
if (argc == 2)
UnDecorateSymbo1Nane( argv[1], buffer, 256, 0 )J
printf ( buffer 1:
else
printf ( *Usage: 24.exe DecroatedNane\n* ):
return 0;
由于不同的编译器采用不同的名字修饰方法，必然会导致由不同编译器编泽产生的目标
文件无法正常相互链接，这是导致不同编译器之间不能互操作的主要原因之一。我们后面的
关于C++ABI和COM的这一节将会详细讨论这个问题。
3.5.4extern“C”
C++为了与C兼容，在符号的管理上，C++有一个用来声明或定义一个C的符号的“exterm
"C"”关键字用法：
extern *c*(
int fune (int);
int var;
C++编译器会将在extem“C”的大括号内部的代码当作C语言代码处理，所以很明显，
上面的代码中，C++的名称修饰机制将不会起作用。它声明了一个C的函数func，定义了一
个整形全局变量var。从上文我们得知，在Visual C++平台下会将C语言的符号进行修饰，
所以上述代码中的 func和 var的修饰后符号分别是_fune和_var：但是在Linux版本的 GCC
编译器下却没有这种修饰，extem"C"里面的符号都为修饰后符号，即前面不用加下划线。
如果单独声明某个函数或变量为C语言的符号，那么也可以使用如下格式：
extern *C* int func(int):
extern *c* int var;
上面的代码声明了一个C语言的函数func和变量var，我们可以使用上述的机制来做一
个小实验：
5uTTfuewauenTenuen o- ddo*DuTTfueweaeNtenueg ++5 / /
/ / Manua1NameKangling. cpp
#include cstdio.h>
namespace mynane {
int var = 42;
程序员的自我修养一链接、装载与库
---
## Page 114
3.5链接的接口—符号
9
}
extern *C* double _zN6myname3varE;
int main ()
printf( *&d\n*, _ZN6myname3varE 1:
return 0;
上面的代码中，我们在myname的名称空间中定义了一个全局变量var，根据我们所掌
握的GCC名称修饰规则，这个变量修饰后的名称为“_ZN6myname3varE”，然后我们手工
使用extem“C"的方法声明一个外部符号_ZN6myname3varE，并将其打印出来。我们使用
GCC来编译这个程序并且运行它，我们就可以得到程序输出为42：
$ g++ ManaulNsmeMangling.cpp -O ManualManeHangling
$./ManualNameMangling
42
很多时候我们会碰到有些头文件声明了一些C语言的函数和全局变量，但是这个头文
件可能会被C语言代码或C++代码包含。比如很常见的，我们的C语言库函数中的stringh
中声明了memset这个函数，它的原型如下：
void *nemset (void *, int, size_t);
如果不加任何处理，当我们的C语言程序包含stringh的时候，并且用到了memset 这
个函数，编泽器会将memset符号引用正确处理：但是在C++语言中，编译器会认为这个
memset函数是一个C++函数，将memset的符号修饰成_Z6memsetPvi，这样链接器就无法
与C语言库中的memset符号进行链接。所以对于C++来说，必须使用exterm"C"来声明
memset这个函数。但是C语言又不支持extem“C"语法，如果为了兼容C语言和C++语言
定义两套头文件，未免过于麻烦，幸好我们有一种很好的方法可以解决上述问题，就是使用
C++的宏“_cplusplus”，C++编译器会在编译C++的程序时默认定义这个宏，我们可以使用
条件宏来判断当前编译单元是不是C++代码。具体代码如下：
sndandoeps#
1.x
#endif
void *nemset (void *, int, size_t);
ifdef _cplusplus
#endif
如果当前编译单元是C++代码，那么memset会在extem“C"里面被声明：如果是C代
码，就直接声明。上面这段代码中的技巧几乎在所有的系统头文件里面都被用到。
程序员的自我修养一链接、装载与库
---
## Page 115
92
第3章自标文件里有什么
3.5.5弱符号与强符号
我们经常在编程中碰到一种情况叫符号重复定义，多个目标文件中含有相同名字全局符
号的定义，那么这些目标文件链接的时候将会出现符号重复定义的错误。比如我们在目标文
件A和目标文件B都定义了一个全局整形变量global，并将它们都初始化，那么链接器将A
和B进行链接时会报错：
a,o:(.data+0x0): first defined here
这种符号的定义可以被称为强符号（StrongSymbol）。有些符号的定义可以被称为弱符
号（WeakSymbol）。对于C/C++语言米说，编译器默认函数和初始化了的全局变量为强符
号，未初始化的全局变量为弱符号。我们也可以通过GCC的“_attribute_（（weak)）”来定
义任何一个强符号为弱符号。注意，强符号和弱符号都是针对定义来说的，不是针对符号的
引用。比如我们有下面这段程序：
extern int ext;
int strong = 1
int weak;
_attribute__( (weak) ) weak2 = 2:
int main ()
return 0;
F
“ext”既非强符号也非弱符号，因为它是一个外部变量的引用。针对强弱符号的概念，链
接器就会按如下规则处理与选择被多次定义的全局符号：
规则1：不允许强符号被多次定义（即不同的目标文件中不能有同名的强符号）：如果
有多个强符号定义，则链接器报符号重复定义错误。
·规则2：如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选
择强符号。
·规则3：如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一
个。比如目标文件A定义全局变量global为int型，占4个字节：目标文件B定义global
为double型，占8个字节，那么目标文件A和B 链接后，符号global占8个字节（尽
量不要使用多个不同类型的弱符号，否则容易导致很难发现的程序错误）。
弱引用和强引用目前我们所看到的对外部目标文件的符号引用在目标文件被最终链
接成可执行文件时，它们须要被正确决议，如果没有找到该符号的定义，链接器就会报符号
程序员的自我修养一链接、装载与库
---
## Page 116
3.5键接的接口——符号
93
未定义错误，这种被称为强引用（StrongReference）。与之相对应还有一种弱引用（Weak
Reterence），在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议：如果
该符号未被定义，则链接器对于该引用不报错，链接器处理强引用和弱引用的过程几乎一样，
只是对于未定义的弱引用，链接器不认为它是一个错误。一般对于米定义的弱引用，链接器
默认其为0，或者是一个特殊的值，以便于程序代码能够识别。引用和翁符号主要用于库