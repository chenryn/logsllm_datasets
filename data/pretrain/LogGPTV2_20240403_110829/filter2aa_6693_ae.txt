一般说来 用 这个方法 找到的 文件 是 库文件\(em\&即由 目标文件 组成的 
归档文件 (archive file).
连接器 处理 归档文件 的 方法 是: 扫描 归档文件, 寻找 某些 成员,
这些 成员 的 符号 目前 已 被引用, 不过 还没有 被定义.
但是, 如果 连接器 找到 普通的 目标文件, 而不是 库文件, 就把 这个 目标文件
按 平常方式 连接 进来. 指定 `\|\c
.B \-l\c
\&\|' 选项 和 指定 文件名 的 唯一 区别 是, `\|\c
.B \-l\c
选项 用 `\|\c
.B lib\c
\&\|' 和 `\|\c
.B .a\c
\&\|' 把 
.I library
包裹 起来, 而且 搜索 一些 目录.
.TP
.B \-lobjc
这个
.B \-l
选项 的 特殊形式 用于 连接 Objective C 程序.
.TP
.B \-nostartfiles
不连接 系统 标准启动文件, 而 标准库文件 仍然 正常 使用.
.TP
.B \-nostdlib
不连接 系统 标准启动文件 和 标准库文件. 只把 指定的 文件 传递给 连接器.
.TP
.B \-static
在 支持 动态连接 (dynamic linking) 的 系统 上, 阻止 连接 共享库.
该选项 在 其他系统上 无效.
.TP
.B \-shared
生成 一个 共享目标文件, 他 可以 和 其他 目标文件 连接 产生 可执行文件.
只有 部分 系统 支持 该选项.
.TP
.B \-symbolic
建立 共享目标文件 的 时候, 把 引用 绑定到 全局符号上.
对 所有 无法解析的 引用 作出 警告 (除非 用 连接编辑选项 `\|\c
.B
\-Xlinker \-z \-Xlinker defs\c
\&\|' 取代).  
只有 部分 系统 支持 该选项.
.TP
.BI "\-Xlinker " "option"
把 选项 \c
.I option
传递给 连接器. 可以 用 他 传递 系统 特定的 连接 选项, GNU CC 无法 识别 
这些 选项.
.Sp
如果 需要 传递 携带 参数 的 选项, 你 必须 使用 两次 `\|\c
.B \-Xlinker\c
\&\|', 一次 传递 选项, 另一次 传递 他的 参数. 例如, 如果 传递 `\|\c
.B
\-assert definitions\c
\&\|', 你 必须 写成 `\|\c
.B
\-Xlinker \-assert \-Xlinker definitions\c
\&\|',  而不能 写成 `\|\c
.B
\-Xlinker "\-assert definitions"\c
\&\|', 因为 这样 会把 整个 字符串 当做 一个 参数 传递, 显然 这 不是
连接器 期待的.
.TP
.BI "\-Wl," "option"
把 选项 \c
.I option\c
\& 传递给 连接器.  如果 \c
.I option\c
\& 中 含有 逗号, 就在 逗号 处 分割成 多个 选项. 
.TP
.BI "\-u " "symbol"
使 连接器 认为 取消了
.I symbol
的 符号定义, 从而 连接 库模块 以 取得 定义. 你 可以 使用 多个 `\|\c
.B \-u\c
\&\|' 选项, 各自 跟上 不同的 符号, 使得 连接器 调入 附加的 库模块.
.SH "目录选项 (DIRECTORY OPTION)
下列 选项 指定 搜索路径, 用于 查找 头文件, 库文件, 或 编译器 的 某些成员:
.TP
.BI "\-I" "dir"
在 头文件 的 搜索路径 列表 中 添加
.I dir 
目录.
.TP
.B \-I\-
任何 在 `\|\c
.B \-I\-\c
\&\|' 前面 用 `\|\c
.B \-I\c
\&\|' 选项 指定 的 搜索路径 只适用于 `\|\c
.B
#include "\c
.I file\c
.B
\&"\c
\&\|' 这种 情况; 他们 不能 用来 搜索 `\|\c
.B #include \c
\&\|' 包含 的 头文件.
.Sp
如果 用 `\|\c
.B \-I\c
\&\|' 选项 指定的 搜索路径 位于 `\|\c
.B \-I\-\c
\&\|' 选项 后面, 就可以 在 这些 路径 中 搜索 所有的 `\|\c
.B #include\c
\&\|'
指令. (一般说来
.B \-I
选项 就是 这么 用的.)
.Sp
还有, `\|\c
.B \-I\-\c
\&\|' 选项 能够 阻止 当前目录 (存放 当前 输入文件 的 地方) 成为 搜索 `\|\c
.B
#include "\c
.I file\c
.B
\&"\c
\&\|' 的 第一选择. 没有 办法 克服 `\|\c
.B \-I\-\c
\&\|' 选项 的 这个效应.  你 可以 指定 `\|\c
.B \-I.\c
\&\|' 搜索 那个目录, 它 在 调用 编译器 时 是 当前目录. 
这 和 预处理器 的 默认行为 不完全 一样, 但是 结果 通常 令人满意.
.Sp
`\|\c
.B \-I\-\c
\&\|' 不影响 使用 系统标准目录, 因此, `\|\c
.B \-I\-\c
\&\|' 和 `\|\c
.B \-nostdinc\c
\&\|' 是 不同的 选项.
.TP
.BI "\-L" "dir"
在 `\|\c
.B \-l\c
\&\|' 选项 的 搜索路径 列表 中 添加 \c
.I dir\c
\& 目录.
.TP
.BI "\-B" "prefix"
这个选项 指出 在何处 寻找 可执行文件, 库文件, 以及 编译器 自己 的 数据文件.
.Sp
编译器 驱动程序 需要 执行 某些 下面的 子程序: `\|\c
.B cpp\c
\&\|', `\|\c
.B cc1\c
\&\|' (或 C++ 的 `\|\c
.B cc1plus\c
\&\|'), `\|\c
.B as\c
\&\|' 和 `\|\c
.B ld\c
\&\|'.  他 把 
.I prefix\c
\& 当作 欲执行的 程序 的 前缀, 既可以 包括 也可以 不包括 `\|\c
.I machine\c
.B /\c
.I version\c
.B /\c
\&\|'.
.Sp
对于 要运行的 子程序, 编译器 驱动程序 首先 试着 加上 `\|\c
.B \-B\c
\&\|' 前缀 (如果存在).  如果 没有 找到 文件, 或 没有 指定 `\|\c
.B \-B\c
\&\|' 选项, 编译器 接着 会 试验 两个 标准 前缀 `\|\c
.B /usr/lib/gcc/\c
\&\|' 和 `\|\c
.B /usr/local/lib/gcc-lib/\c
\&\|'.  如果 仍然 没能够 找到 所需文件, 编译器 就在 `\|\c
.B PATH\c
\&\|' 环境变量 指定的 路径 中 寻找 没加 任何 前缀 的 文件名.
.Sp
如果 有需要, 运行时 (run-time) 支持文件 `\|\c
.B libgcc.a\c
\&\|' 也在 `\|\c
.B \-B\c
\&\|' 前缀 的 搜索 范围 之内. 如果 这里 没有 找到, 就在 上面 提到的
两个 标准 前缀 中 寻找, 仅此而已. 如果 上述 方法 没有 找到 这个 文件,
就 不连接 他了. 多数 情况 的 多数 机器 上, `\|\c
.B libgcc.a\c
\&\|' 并非 必不可少.
.Sp
你 可以 通过 环境变量
.B GCC_EXEC_PREFIX\c
\& 获得 近似的 效果; 如果 定义了 这个 变量, 其值 就和 上面 说的 一样
用做 前缀. 如果 同时 指定了 `\|\c
.B \-B\c
\&\|' 选项 和
.B GCC_EXEC_PREFIX\c
\& 变量, 编译器 首先 使用 `\|\c
.B \-B\c
\&\|' 选项, 然后 才尝试 环境变量值.
.SH "警告选项 (WARNING OPTION)"
警告 是 针对 程序结构 的 诊断信息, 程序 不一定 有错误, 而是 存在
风险, 或者 可能 存在 错误.
.Sp
下列 选项 控制 GNU CC 产生 的 警告 的 数量 和 类型:
.TP
.B \-fsyntax\-only
检查 程序 中 的 语法错误, 但是 不产生 输出信息.
.TP
.B \-w
禁止 所有 警告信息.
.TP
.B \-Wno\-import
禁止 所有 关于
.BR #import 
的 警告信息.
.TP
.B \-pedantic
打开 完全服从 ANSI C 标准 所需的 全部 警告诊断; 拒绝接受 采用了
被禁止的 语法扩展 的 程序.
.Sp
无论 有没有 这个 选项, 符合 ANSI C 标准 的 程序 应该 能够 被 正确 编译
(虽然 极少数 程序 需要 `\|\c
.B \-ansi\c
\&\|' 选项).  然而, 如果 没有 这个 选项, 某些 GNU 扩展 和 传统 C 特性
也 得到 支持. 使用 这个 选项 可以 拒绝 这些 程序. 没有 理由 使用 这个
选项, 他 存在 只是 为了 满足 一些 书呆子 (pedant).
.Sp
对于 替选关键字 (他们 以 `\|\c
.B _\|_\c
\&\|' 开始 和 结束) `\|\c
.B \-pedantic\c
\&\|' 不会 产生 警告信息. Pedantic 也 不警告 跟在
.B _\|_extension_\|_\c
\& 后面 的 表达式. 不过 只应该 在 系统头文件 中 使用 这种 转义措施,
应用程序 最好 避免.
.TP
.B \-pedantic\-errors
该 选项 和 `\|\c
.B \-pedantic\c
\&\|' 类似, 但是 显示 错误 而不是 警告.
.TP
.B \-W
对 下列 事件 显示 额外的 警告信息:
.TP
\ \ \ \(bu
非易变自动变量 (nonvolatile automatic variable) 可能 在 调用
.B longjmp\c
\& 时 发生 改变. 这些 警告 仅在 优化编译 时 发生.
.Sp
编译器 只知道 对 \c
.B setjmp\c
\& 的 调用, 他 不可能 知道 会 在哪里 调用 \c
.B longjmp\c
\&, 事实上 一个 信号处理例程 可以 在 程序 的 任何 地点 调用 他.
其结果是, 即使 程序 没有 问题, 你 也可能会 得到 警告, 因为 无法 在
可能 出现 问题 的 地方 调用 \c
.B longjmp\c
\&.
.TP
\ \ \ \(bu
既可以 返回 值, 也可以 不返回 值 的 函数. (缺少 结尾 的 函数体 被看作
不返回 函数值) 例如, 下面的 函数 将 导致 这种 警告:
.Sp
.nf
foo (a)
{
  if (a > 0)
    return a;
}
.Sp
.fi
由于 GNU CC 不知道 某些 函数 永不返回 (含有 \c
.B abort\c
\& 和 \c
.B longjmp\c
\&), 因此 有可能 出现 虚假 警告.
.TP
\ \ \ \(bu
表达式语句 或 逗号表达式 的 左侧 没有 产生 作用 (side effect).
如果要 防止 这种 警告, 应该把 未使用的 表达式 强制转换 为 void 类型.
例如, 这样的 表达式 `\|\c
.B x[i,j]\c
\&\|' 会 导致 警告, 而 `\|\c
.B x[(void)i,j]\c
\&\|' 就 不会.
.TP
\ \ \ \(bu
无符号数 用 `\|\c
.B >\c
\&\|' 或 `\|\c
.B <=\c
\&\|' 和 零 做比较.
.PP
.TP
.B \-Wimplicit-int
警告 没有 指定 类型 的 声明.
.TP
.B \-Wimplicit-function-declaration
警告 在 声明 之前 就 使用 的 函数.
.TP
.B \-Wimplicit
同 -Wimplicit-int 和 -Wimplicit-function-declaration.
.TP
.B \-Wmain
如果 把
.B main
函数 声明 或 定义 成 奇怪 的 类型, 编译器 就 发出 警告.
典型情况下, 这个 函数 用于 外部连接, 返回 