92
        {
93
            // 转换消息
94
            TranslateMessage(&msg);
95
            // 分发消息：就是给系统调用窗口处理函数
96
            DispatchMessage(&msg);
97
        }
98
    }
99
100
    return 0;
101
}
102
滴水逆向课程笔记  –  Win32
第一个Windwos程序  –  73
滴水逆向课程笔记  –  Win32
消息类型  –  74
17 消息类型
17.1 消息的产生与处理流程
消息的产生与处理流程，从消息发起这个点开始说，假设我们点击了某个窗口时就会产生一个消息，操作系统
得到这个消息后先判断当前点击的是哪个窗口，找到对应的窗口对象，再根据窗口对象的里的某一个成员找到
对应线程，一旦找到了对应线程，操作系统就会把封装好的消息（这是一个结构体，包含了你鼠标点击的坐标
等等消息）存到对应的消息队列里，应用程序就会通过GetMessage不停的从消息队列中取消息。
17.2 消息结构体
我们是通过GetMessage函数接收消息的，其第一个参数就是接收的消息（结构体），所以可以在之前的代码中
选中MSG然后F12跟进看一下消息结构体的定义：
滴水逆向课程笔记  –  Win32
消息类型  –  75
能产生消息的情况有四种情况：1. 键盘 2. 鼠标 3. 其他应用程序 4. 操作系统内核程序，有这么多消息要处理，
所以操作系统会将所有消息区分类别，每个消息都有独一无二的编号。
消息这个结构体存储的信息也不多，只能知道消息属于哪个窗口，根本不知道对应窗口函数是什么，所以我们
不得不在之后对消息进行分发（DispatchMessage函数），而后由内核发起调用来执行窗口函数。
换而言之，我们这个消息的结构体实际上就是传递给了窗口函数，其四个参数对应着消息结构体的前四个成员
。
17.3 消息类型
我们想要关注自己想要关注的消息类型，首先可以在窗口函数中打印消息类型来看看都有什么消息类型：
typedef struct tagMSG {
1
  HWND   hwnd;      // 所属窗口句柄
2
  UINT   message;   // 消息类型：编号
3
  WPARAM wParam;    // 附加数据，进一步描述消息的
4
  LPARAM lParam;    // 附加数据，进一步描述消息的
5
  DWORD  time;      // 消息产生的时间
6
  POINT  pt;        // 在哪里产生的
7
} MSG, *PMSG; 
8
滴水逆向课程笔记  –  Win32
消息类型  –  76
可以看见这边输出了一个0x1，想要知道这个对应着什么，我们可以在C:\Program Files\Microsoft Visual 
Studio\VC98\Include目录中找到WINUSER.H这个文件来查看，搜索0x0001就可以找到：
// 窗口函数定义
1
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
2
    char szOutBuff[0x80];
3
    sprintf(szOutBuff, "Message: %x - %x \n", hwnd, uMsg);
4
    OutputDebugString(szOutBuff);
5
6
    // 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的
7
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
8
}
9
滴水逆向课程笔记  –  Win32
消息类型  –  77
那么我们可以看见对应的宏就是WM_CREATE，这个消息的意思就是窗口创建，所以我们有很多消息是不需要
关注的，而且消息时刻都在产生，非常非常多。
17.3.1 处理窗口关闭
在窗口关闭时，实际上进程并不会关闭，所以我们需要在窗口函数中筛选条件，当窗口关闭了就退出进程。
17.3.2 处理键盘按下
我们除了可以处理窗口关闭，处理键盘按下也是没问题的，键盘按下的宏是WM_KEYDOWN，但是我们想要按
下a这个键之后才处理该怎么办？首先我们需要查阅一下MSDN Library：
// 窗口函数定义
1
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
2
    switch(uMsg) {
3
    // 当窗口关闭则退出进程
4
    case WM_DESTROY:
5
        {
6
            PostQuitMessage(0);
7
            break;
8
        }
9
    }
10
11
    // 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的
12
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
13
}
14
滴水逆向课程笔记  –  Win32
消息类型  –  78
可以很清楚的看见窗口函数的第三个参数就是虚拟键码（键盘上每个键都对应一个虚拟键码），我们可以输出
下按下a，其对应虚拟键码是什么：
LRESULT CALLBACK WindowProc(
1
  HWND hwnd,       // handle to window
2
  UINT uMsg,       // WM_KEYDOWN
3
  WPARAM wParam,   // virtual-key code
4
  LPARAM lParam    // key data
5
);
6
// 窗口函数定义
1
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
2
    switch(uMsg) {
3
    // 当键盘按下则处理
4
    case WM_KEYDOWN:
5
        {
6
            char szOutBuff[0x80];
7
            sprintf(szOutBuff, "keycode: %x \n", wParam);
8
            OutputDebugString(szOutBuff);
9
            break;
10
        }
11
    }
12
13
    // 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的
14
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
15
}
16
滴水逆向课程笔记  –  Win32
消息类型  –  79
如上图所示，按下a之后输出的虚拟键码是0x41，所以我们可以根据这个来进行判断。
17.4 转换消息
之前我们举例可以处理键盘按下的消息，但是我们想要直观的看到底输入了什么而不是虚拟键码该怎么办？这
时候我们就需要使用WM_CHAR这个宏了，但是在这之前，我们的消息是必须要经过转换的，只有其转换了，
我们的虚拟键码才能变成具体的字符。
WM_CHAR宏对应的窗口函数参数作用如下：
第三个参数就是字符所以我们直接输出这个即可：
LRESULT CALLBACK WindowProc(
1
  HWND hwnd,       // handle to window
2
  UINT uMsg,       // WM_CHAR
3
  WPARAM wParam,   // character code (TCHAR)
4
  LPARAM lParam    // key data
5
);
6
滴水逆向课程笔记  –  Win32
消息类型  –  80
滴水逆向课程笔记  –  Win32
子窗口控件  –  81
1.
2.
3.
18 子窗口控件
18.1 关于子窗口控件
Windows提供了几个预定义的窗口类以方便我们的使用，我们一般叫它们为子窗口控件，简称控件；
控件会自己处理消息，并在自己状态发生改变时通知父窗口；
预定义的控件有：按钮、复选框、编辑框、静态字符串标签和滚动条等。
18.2 创建编辑框和按钮
我们想使用子窗口控件可以使用CreateWindow函数来创建，创建位置我们可以选在窗口函数中，当窗口创建则
开始创建子窗口控件。
滴水逆向课程笔记  –  Win32
子窗口控件  –  82
// Windows.cpp : Defines the entry point for the application.
1
//
2
3
#include "stdafx.h"
4
// 定义子窗口标识
5
#define CWA_EDIT 0x100
6
#define CWA_BUTTON_0 0x101
7
#define CWA_BUTTON_1 0x102
8
9
// 定义全局模块
10
HINSTANCE gHinstance;
11
12
13
// 窗口函数定义
14
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
15
    switch (uMsg) {
16
    // 当键盘按下则处理
17
    case WM_CHAR:
18
        {
19
            char szOutBuff[0x80];
20
            sprintf(szOutBuff, "keycode: %c \n", wParam);
21
            OutputDebugString(szOutBuff);
22
            break;
23
        }
24
    // 当窗口创建则开始创建子窗口控件
25
    case WM_CREATE:
26
        {
27
            // 创建编辑框
28
            CreateWindow(
29
                TEXT("EDIT"),  // registered class name 注册的类名，使用EDIT则为编辑框
30
                TEXT(""), // window name 窗口名称
31
                WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE,        // window style 子窗口控
件样式：子窗口、创建后可以看到、滚动条、自动换行
32
                0,                // horizontal position of window 在父窗口上的x坐标
33
                0,                // vertical position of window 在父窗口上的y坐标
34
                400,           // window width 控件宽度
35
                300,          // window height 控件高度
36
                hwnd,      // menu handle or child identifier 父窗口句柄
37
                (HMENU)CWA_EDIT,          // menu handle or child identifier 子窗口标识
38
                gHinstance,  // handle to application instance 模块
39
                NULL        // window-creation data 附加数据
40
            );
41
42
            // 创建"设置"按钮
43
            CreateWindow(
44
                TEXT("BUTTON"),  // registered class name 注册的类名，使用BUTTON则为按钮
45
                TEXT("设置"), // window name 按钮名称
46
                WS_CHILD | WS_VISIBLE,        // window style 子窗口控件样式：子窗口、创建后可以看到
47
                450,                // horizontal position of window 在父窗口上的x坐标
48
                150,                // vertical position of window 在父窗口上的y坐标
49
                80,           // window width 控件宽度
50
                20,          // window height 控件高度
51
                hwnd,      // menu handle or child identifier 父窗口句柄
52
                (HMENU)CWA_BUTTON_0,          // menu handle or child identifier 子窗口标识
53
                gHinstance,  // handle to application instance 模块
54
滴水逆向课程笔记  –  Win32
子窗口控件  –  83
                NULL        // window-creation data 附加数据
55
            );
56
57
            // 创建"获取"按钮
58
            CreateWindow(
59
                TEXT("BUTTON"),  // registered class name 注册的类名，使用BUTTON则为按钮
60
                TEXT("获取"), // window name 按钮名称
61
                WS_CHILD | WS_VISIBLE,        // window style 子窗口控件样式：子窗口、创建后可以看到
62
                450,                // horizontal position of window 在父窗口上的x坐标
63
                100,                // vertical position of window 在父窗口上的y坐标
64
                80,           // window width 控件宽度
65
                20,          // window height 控件高度
66
                hwnd,      // menu handle or child identifier 父窗口句柄
67
                (HMENU)CWA_BUTTON_1,          // menu handle or child identifier 子窗口标识
68
                gHinstance,  // handle to application instance 模块
69
                NULL        // window-creation data 附加数据
70
            );
71
72
            break;
73
        }
74
    // 当按钮点击则处理
75
    case WM_COMMAND:
76
        {
77
            // 宏WM_COMMAND中，wParam参数的低16位中有标识，根据标识我们才能判断哪个按钮和编辑框，使用LOWORD()
可以获取低16位
78
            switch (LOWORD(wParam)) {
79
            // 当按钮为设置
80
            case CWA_BUTTON_0:
81
                {
82
                    // SetDlgItemText函数修改编辑框内容
83
                    SetDlgItemText(hwnd, (int)CWA_EDIT, TEXT("HACK THE WORLD"));
84
                    break;
85
                }
86
            // 当按钮为获取
87
            case CWA_BUTTON_1:
88
                {
89
                    // MessageBox弹框输出编辑框内容
90
                    TCHAR szEditBuffer[0x80];
91
                    GetDlgItemText(hwnd, (int)CWA_EDIT, szEditBuffer, 0x80);
92
                    MessageBox(NULL, szEditBuffer, NULL, NULL);
93
                    break;
94
                }
95
            }
96
            break;
97
        }
98
    }
99
100