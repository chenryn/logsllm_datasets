was originally considered unpatchable. Piston makes the novel con-
tribution of exploitation clean up, recovering from many of the un-
predictable state changes introduced during a memory corruption
exploit. We evaluated Piston on a large, real-world binary and a syn-
thetic dataset provided by DARPA. Piston was able to apply patches
to each binary and, in most cases, carried out the patch completely
automatically.
ACKNOWLEDGMENTS
This material is based upon work supported by ONR under Award
Numbers N00014-17-1-2897, N00014-17-1-2011, N00014-15-1-
2948. Any opinions, findings, and conclusions or recommendations
expressed in this publication are those of the author(s) and do not
necessarily reflect the views of the ONR.
REFERENCES
[1] Cve-2013-2028 advisory. https://web.nvd.nist.gov/view/vuln/detail?vulnId=
CVE-2013-2028.
26737/.
[2] Nginx cve 2013-2028 kingcope exploit. https://www.exploit-db.com/exploits/
[3] Nginx cve 2013-2028 patch. http://nginx.org/download/patch.2013.chunked.txt.
[4] Vulnerability
type.
of CVE security
vulnerabilities
distribution
by
http://www.cvedetails.com/vulnerabilities-by-types.php.
[5] J. Arnold and M. F. Kaashoek. Ksplice: Automatic rebootless kernel updates. In
Proceedings of the 4th ACM European conference on Computer systems, pages
187–198. ACM, 2009.
[6] G. Balakrishnan and T. Reps. WYSINWYX: What you see is not what you execute.
ACM Transactions on Programming Languages and Systems (TOPLAS), 32(6):23,
2010.
[7] M. Bourquin, A. King, and E. Robbins. Accurate comparison of binary executables.
2013.
[8] M. Bourquin, A. King, and E. Robbins. Binslayer: accurate comparison of binary
executables. In Proceedings of the 2nd ACM SIGPLAN Program Protection and
Reverse Engineering Workshop, page 4. ACM, 2013.
2Available at https://github.com/angr/angr
[9] D. Brumley, P. Poosankam, D. Song, and J. Zheng. Automatic patch-based exploit
generation is possible: Techniques and implications. In Security and Privacy, 2008.
SP 2008. IEEE Symposium on, pages 143–157. IEEE, 2008.
[10] C. Cadar, D. Dunbar, D. R. Engler, et al. Klee: Unassisted and automatic generation
of high-coverage tests for complex systems programs. In OSDI, volume 8, pages
209–224, 2008.
[11] F. Castaneda, E. C. Sezer, and J. Xu. Worm vs. worm: preliminary study of an
active counter-attack mechanism. In Proceedings of the 2004 ACM workshop on
Rapid malcode, pages 83–93. ACM, 2004.
[12] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley. Unleashing mayhem on binary
code. In Security and Privacy (SP), 2012 IEEE Symposium on, pages 380–394.
IEEE, 2012.
[13] Y.-Y. Chang, P. Zavarsky, R. Ruhl, and D. Lindskog. Trend analysis of the cve for
software vulnerability management. In Privacy, Security, Risk and Trust (PASSAT)
and 2011 IEEE Third Inernational Conference on Social Computing (SocialCom),
2011 IEEE Third International Conference on, pages 1290–1293. IEEE, 2011.
[14] H. Chen, J. Yu, C. Hang, B. Zang, and P.-C. Yew. Dynamic software updating
using a relaxed consistency model. Software Engineering, IEEE Transactions on,
37(5):679–694, 2011.
[15] V. Chipounov, V. Kuznetsov, and G. Candea. S2E: A platform for in-vivo multi-path
analysis of software systems, volume 47. ACM, 2012.
[16] C. Cifuentes and M. Van Emmerik. Recovery of jump table case statements
In Program Comprehension, 1999. Proceedings. Seventh
from binary code.
International Workshop on, pages 192–199. IEEE, 1999.
[17] T. Dullien and R. Rolles. Graph-based comparison of executable objects (english
version). SSTIC, 5:1–3, 2005.
[18] M. Egele, M. Woo, P. Chapman, and D. Brumley. Blanket execution: Dynamic
similarity testing for program binaries and components. In 23rd USENIX Security
Symposium (USENIX Security 14), pages 303–317, 2014.
[19] H. Flake. Structural comparison of executable objects. 2004.
[20] C. Giuffrida, C. Iorgulescu, A. Kuijsten, and A. S. Tanenbaum. Back to the future:
Fault-tolerant live update with time-traveling state transfer. In LISA, pages 89–104,
2013.
[21] C. Giuffrida, A. Kuijsten, and A. S. Tanenbaum. Safe and automatic live update
for operating systems. ACM SIGPLAN Notices, 48(4):279–292, 2013.
[22] D. Goodin. Windows 7, not xp, was the reason last weekâ ˘A ´Zs wcry worm spread
so widely, 2017. https://arstechnica.com/security/2017/05/windows-7-not-xp-
was-the-reason-last-weeks-wcry-worm-spread-so-widely/.
[23] C. M. Hayden, E. K. Smith, M. Denchev, M. Hicks, and J. S. Foster. Kitsune:
Efficient, general-purpose dynamic software updating for c. In ACM SIGPLAN
Notices, volume 47, pages 249–264. ACM, 2012.
[24] C. M. Hayden, E. K. Smith, M. Hicks, and J. S. Foster. State transfer for clear and
efficient runtime updates. In Data Engineering Workshops (ICDEW), 2011 IEEE
27th International Conference on, pages 179–184. IEEE, 2011.
[25] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna. Static disassembly of obfuscated
binaries. In USENIX security Symposium, volume 13, pages 18–18, 2004.
[26] J. Lee, T. Avgerinos, and D. Brumley. TIE: principled reverse engineering of types
in binary programs. In Proceedings of the Network and Distributed System Security
Symposium, NDSS 2011, San Diego, California, USA, 6th February - 9th February
2011, 2011.
[27] H. Martorell, J.-C. Fabre, M. Roy, and R. Valentin. Towards dynamic updates
in autosar. In SAFECOMP 2013-Workshop CARS (2nd Workshop on Critical
Automotive applications: Robustness & Safety) of
the 32nd International
Conference on Computer Safety, Reliability and Security, page NA, 2013.
[28] H. Martorell, J.-C. Fabre, M. Roy, and R. Valentin.
of autosar embedded applications.
Symposium on Applied Computing, pages 384–390. ACM, 2014.
Improving adaptiveness
In Proceedings of the 29th Annual ACM
[29] G. McManus, hal, and saelo.
Nginx cve 2013-2028 metasploit exploit.
https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/
linux/http/nginx_chunked_size.rb.
[30] M. A. McQueen, T. A. McQueen, W. F. Boyer, and M. R. Chaffin. Empirical
In System Sciences, 2009.
estimates and observations of 0day vulnerabilities.
HICSS’09. 42nd Hawaii International Conference on, pages 1–12. IEEE, 2009.
[31] C. Mulliner, J. Oberheide, W. Robertson, and E. Kirda. Patchdroid: Scalable
third-party security patches for android devices. In Proceedings of the 29th Annual
Computer Security Applications Conference, pages 259–268. ACM, 2013.
[32] A. Nappa, R. Johnson, L. Bilge, J. Caballero, and T. Dumitras. The attack of the
clones: a study of the impact of shared code on vulnerability patching. In Security
and Privacy (SP), 2015 IEEE Symposium on, pages 692–708. IEEE, 2015.
[33] J. A. Navas, P. Schachte, H. Søndergaard, and P. J. Stuckey. Signedness-agnostic
program analysis: Precise integer bounds for low-level code. In Programming
Languages and Systems, pages 115–130. Springer, 2012.
[34] I. Neamtiu and M. Hicks. Safe and timely updates to multi-threaded programs.
In ACM Sigplan Notices, volume 44, pages 13–24. ACM, 2009.
[35] I. Neamtiu, M. Hicks, G. Stoyle, and M. Oriol. Practical dynamic software
updating for C, volume 41. ACM, 2006.
151[36] M. Noonan, A. Loginov, and D. Cok. Polymorphic type inference for machine
code. In Proceedings of the 37th ACM SIGPLAN Conference on Programming
Language Design and Implementation, pages 27–41. ACM, 2016.
[37] Oracle. Ksplice. http://www.ksplice.com/.
[38] J. H. Perkins, S. Kim, S. Larsen, S. Amarasinghe, J. Bachrach, M. Carbin,
C. Pacheco, F. Sherwood, S. Sidiroglou, G. Sullivan, et al. Automatically patching
errors in deployed software. In Proceedings of the ACM SIGOPS 22nd symposium
on Operating systems principles, pages 87–102. ACM, 2009.
[39] E. Perla and M. Oldani. A guide to kernel exploitation: attacking the core. Elsevier,
2010.
[40] J. Pewny, B. Garmany, R. Gawlik, C. Rossow, and T. Holz. Cross-architecture bug
search in binary executables. In Security and Privacy (SP), 2015 IEEE Symposium
on, pages 709–724. IEEE, 2015.
[41] D. A. Ramos and D. Engler. Under-constrained symbolic execution: correctness
checking for real code. In 24th USENIX Security Symposium (USENIX Security
15), pages 49–64, 2015.
[42] B. Schwarz, S. Debray, and G. Andrews. Disassembly of executable code revisited.
In Reverse engineering, 2002. Proceedings. Ninth working conference on, pages
45–54. IEEE, 2002.
[43] Secunia. Resources vulnerability review 2015. http://secunia.com/resources/
vulnerability-review/introduction/.
[44] Y. Shoshitaishvili, R. Wang, C. Hauser, C. Kruegel, and G. Vigna. Firmalice - auto-
matic detection of authentication bypass vulnerabilities in binary firmware. 2015.
[45] M. Siniavine and A. Goel. Seamless kernel updates. In Dependable Systems and
Networks (DSN), 2013 43rd Annual IEEE/IFIP International Conference on, pages
1–12. IEEE, 2013.
[46] A. Sotirov. Hotpatching and the rise of third-party patches. BlackHat USA, 2006.
[47] Tok, Teck Bok and Guyer, Samuel Z and Lin, Calvin. Efficient flow-sensitive
In Compiler
interprocedural data-flow analysis in the presence of pointers.
Construction, pages 17–31. Springer, 2006.
[48] J. Troger and C. Cifuentes. Analysis of virtual method invocation for binary
translation. In Reverse Engineering, 2002. Proceedings. Ninth Working Conference
on, pages 65–74. IEEE, 2002.
[49] R. van der Meulen. Gartner says 6.4 billion connected "things" will be in use in
2016, up 30 percent from 2015. http://www.gartner.com/newsroom/id/3165317.
[50] R. Wang, Y. Shoshitaishvili, C. Kruegel, and G. Vigna. Steal this movie:
Automatically bypassing drm protection in streaming media services. In USENIX
Security, pages 687–702, 2013.
[51] Wikipedia. Dll injection. https://en.wikipedia.org/wiki/DLL_injection.
[52] L. Xu, F. Sun, and Z. Su. Constructing precise control flow graphs from binaries.
University of California, Davis, Tech. Rep, 2009.
A APPENDIX
A.1 Example
To shed more light into Piston’s operation, we provide an example
binary in which Piston can automatically patch out a stack-based
buffer overflow. In Listing 2 there is an overflow in line 12 with the
call to gets(). Piston will receive as inputs the original binary for
the code in Listing 2, the patched version, and an exploit specification
to achieve code execution. Note that we show the source code for
clarity, although Piston will run entirely on the compiled executables.
Piston will execute the following high-level steps to remotely patch
a process running the code in Listing 2:
Patch generation. Using binary diffing techniques, Piston will iden-
tify that the hello() function has changed in the replacement
binary. Piston then prepares a patch to insert the updated hello()
function into the memory of the remote process.
Repair planning. Piston will analyze the exploit specification and
trace the exploit off-line to determine what is corrupted during
the exploit. As shown in Figure 2 (b) the return address and value
of the variable counter are corrupted. Piston will automatically
generate a repair routine to recover the value of the stack variable
counter as well as the return address. In Figure 2 (c) the arrow
between main_counter and counter shows that the repair
plan uses the value of main_counter to restore the value of
counter.
Remote patching. Piston will exploit the process using the specifi-
cation provided to inject the patcher core. The patcher core first
receives the repair routine from Piston, which is used to restore the
corrupted stack values. Then the patcher core receives the prepared
patches to replace the hello() function. Finally, the process exe-
cution will be resumed on line 10, at the start of the patched hello,
now running a patched version of the function.
i n t m a i n _ c o u n t e r = 0 ;
while ( 1 ) {
h e l l o ( m a i n _ c o u n t e r ) ;
m a i n _ c o u n t e r += 1 ;
. . .
1 void main ( ) {
2
3
4
5
6
7
8 }
9 void h e l l o ( i n t
10
11
12
13
}
c o u n t e r ) {
char buf [ 0 x20 ] ;
p u t s ( " E n t e r your name : \ n " ) ;
g e t s ( buf ) ;
p r i n t f ( " h e l l o
. . .
14
15 }
%s , you a r e v i s t o r %d \ n " , buf ,
c o u n t e r ) ;
Listing 2: An example of a stack-based overflow that Piston can
patch.
A.2 Glossary
We have been careful to use consistent terminology throughout the
paper, and collect its definitions here.
Corruption effects. A register or memory write that is influenced
by data that was corrupted by the exploit.
Exploitation point. The point, in the exploitation trace, at which it
becomes apparent that the binary has been exploited.
Exploit specification. Fundamentally, a script that carries out an
exploit against the remote process to achieve remote code
execution.
Exploitation trace. A detailed trace of the exploit running against
the original binary (configured with the remote configuration).
This trace is analyzed to generate the rollback and repair func-
tions.
Hijacked function. The function from which the exploit hijacks
control flow.
Original binary. The binary that is currently running on the remote
process.
Overflow instruction. The instruction that performs the write that
triggers the detection of the exploitation point.
Patch set. The specific set of patches that Piston will apply to the
remote process to transform it into a functional copy of the
replacement binary.
Patching stub. A small payload that is injected by Piston into the
remote process to facilitate the various patching tasks.
Persistence routine. An optional routine, provided by the user, that
tries to persist Piston’s changes on the remote machine (i.e., by
overwriting the original binary with the replacement binary).
In most use-cases for Piston, this is not actually possible due
to lack of access.
Recovery set. A set of registers and stack variables that Piston has de-
termined need to be recovered before resuming remote process
execution.
152Figure 2: A view of the stack frames of the program shown in Listing 2 during the automated repair process. (a) Here the program is currently executing
the function hello(). At the bottom of the stack frame of hello() is the return address, followed by the variable counter. (b) After the call to
gets() the buffer overflows, corrupting the values of ret_addr and counter. (c) Piston restores the value of counter using the redundant data
on the stack that was not corrupted, specifically the value of main_counter. The value of the return address is also restored. (d) Piston replaces
hello() with the new version of the function hello_patched() which is taken from the patched binary. Finally, Piston chooses to restart the
function hello_patched() and program execution continues safely.
Remote configuration. The configuration of the remote process. For
example, if the remote process is a web server, this would be
the configuration file of the web server. Piston uses this to
recreate an accurate exploit trace.
Remote process. A process (or piece of firmware) running on the
remote system that the analyst wants to patch.
Repair routine. A function, either generated by Piston or provided
by the analyst, that repairs state corruption in the remote pro-
cess after Piston exploits it.
Replacement binary. The binary that the analyst wants to replace
the original binary with on the remote process.
Rollback routine. A function, either generated by Piston or pro-
vided by the analyst, that undoes the effects of the hijacked
function when the exploit prevents the hijacked function from
completing properly.
Scratch Space. Memory that can be used inside of a function, but
will not be accessed outside of the function. This includes local
stack space as well as data in the heap that will be freed before
the end of the function.
State transition routine. A function provided by the analyst which
is necessary when a patch introduces changes to structures.
This function is responsible for updating all instances of the
affected structures to fit the new definition of the structure.
stack frame hello()stack frame main()bufret_addrcounter...main_counterbuf...main_counterret_addrcounter...main_counterrestorea)b)c)buf0x000xffbufret_addrcounter...main_counterd)stack frame hello_patched()stack frame main()153