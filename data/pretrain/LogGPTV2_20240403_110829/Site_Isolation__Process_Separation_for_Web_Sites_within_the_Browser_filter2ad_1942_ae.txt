1672    28th USENIX Security Symposium
USENIX Association
ent to web pages. During deployment, we closely monitored
bug reports for several months to judge the impact on actual
users and content. We have received around 20 implemen-
tation bugs, most of which are now ﬁxed. We did uncover
some behavior changes, described below. Overall, however,
none of the bug reports warranted turning Site Isolation off,
indicating that our design does not result in major compati-
bility problems when deployed widely.
Asynchronous Full-page Layout. With Site Isolation, full-
page layout is no longer synchronous, since the frames of a
page may be spread across multiple processes. For exam-
ple, if a page changes the size of a frame and then sends
it a postMessage, the receiving frame may not yet know
its new size when receiving the message. We found that this
disrupted behavior for some pages, but since the HTML spec
does not guarantee this behavior and relatively few sites were
affected, we chose not to preserve the old ordering. Instead,
we provided guidance for web developers to ﬁx the few af-
fected pages [7] and are pursuing speciﬁcation changes to
explicitly note that full-page layout is asynchronous [27].
Partial Failures. Site Isolation can expose new failure
modes to web pages, because out-of-process iframes may
crash or become unresponsive independently from their em-
bedder, after having been loaded. Although this may lead to
unexpected behavior in the page, it happens rarely enough to
avoid being a problem in practice, and for users, losing an
iframe is usually preferable to losing the entire page.
Detecting Site Isolation. A web page should not know
if it is rendered with or without Site Isolation, and we
have avoided introducing APIs for doing so: a browser’s
process model is an implementation detail that developers
should not depend on. We did encounter and ﬁx some
bugs that allowed detection of Site Isolation, such as dif-
fering JavaScript exception behavior for in-process and out-
of-process frames. Fundamentally, though, it is possible to
detect Site Isolation via timing attacks. For example, a cross-
process postMessage will take longer than a same-process
postMessage, due to an extra IPC hop through the browser
process; a web page could perform a timing analysis to de-
tect whether a frame is in a different process. However, such
timing differences are unlikely to affect compatibility, and
we have not received any such reports.
6 Future Directions
Site Isolation protects a great deal of site data against ren-
derer exploit attackers and memory disclosure attackers, but
there is a strong incentive to address the limitations outlined
in Section 2.2.
It is worth noting that web browsers are not alone in fac-
ing a new security landscape. Other software systems that
isolate untrustworthy code may require architecture changes
to avoid leaking data via microarchitectural state. For exam-
ple, SQL queries in databases might pose similar risks [47].
Second, the Chrome team is working to isolate cross-site
PDFs and other types [2, 60]. Developer outreach may also
cut down on mislabeled subresources, eliminating the need
for CORB conﬁrmation snifﬁng.
Third, recent proposals call for browsers to make cross-
origin subresource requests without credentials by de-
fault [73]. This would prevent almost all sensitive cross-site
data from entering a renderer process, apart from cases of
ambient authority (e.g., intranet URLs which require no cre-
dentials).
These options may close the gaps to ensure essentially all
Applications that download and render untrustworthy con-
tent from the web, such as document editors, should likewise
leverage OS abstractions to isolate their own principals [42].
6.1 Protecting More Data
CORB currently only protects HTML, XML, and JSON re-
sponses, and only when the browser can conﬁrm them using
snifﬁng or headers. There are several options for protect-
ing additional content, from using headers to protect partic-
ular responses, to expanding CORB to cover more types, to
changing how browsers request subresources.
First, web developers can explicitly protect
sen-
sitive resources without
relying on CORB, using a
Cross-Origin-Resource-Policy response header [21]
or
refusing to serve cross-site requests based on the
Sec-Fetch-Site request header [71].
sensitive web data is protected by Site Isolation.
6.2 Additional Layers of Mitigation
Because Site Isolation uses OS process boundaries as an iso-
lation mechanism, it is straightforward to combine it with
additional OS-level mitigations for attacks. This may in-
clude other sandboxing mechanisms (e.g., treating different
sites as different user accounts) or mitigations for additional
types of transient execution attacks. For example, microcode
updates and OS mitigations (e.g., PTI or disabling Hyper-
Threading) may be needed for cross-process or user/kernel
attacks [15, 24, 40, 57, 66]. These are complementary to
the mitigations Site Isolation offers for same-process attacks,
where the OS and hardware have less visibility.
6.3 Practical Next Steps
Mobile Devices. This paper has described deploying Site
Isolation to users on desktop and laptop devices, but the new
web attackers are important to consider for mobile phone
browsers as well. Site Isolation faces greater challenges on
mobile devices due to fewer device resources (e.g., mem-
ory, CPU cores) and a different workload: there are fewer
renderer processes in the working set due to proactive dis-
carding by the mobile OS, and thus fewer opportunities for
process sharing. We are investigating options for deploying
similar mitigations on mobile browsers, such as isolating a
subset of sites that need the protection the most.
USENIX Association
28th USENIX Security Symposium    1673
Isolation in Other Browsers. There are opportunities for
other browsers to provide a limited form of process isola-
tion without the signiﬁcant implementation requirements of
out-of-process iframes. For example, sites might adopt head-
ers like Cross-Origin-Opener-Policy to opt into a mode
that can place a top-level document in a new process by dis-
rupting some cross-window scripting [44].
Origin Isolation. Within browsers with Site Isolation, fur-
ther isolation may be practical by selectively moving from a
site granularity to a ﬁner origin granularity. Too many web
sites rely on modifying document.domain to deploy ori-
gin isolation by default, but browsers may allow sites to opt
out of this feature and thus become eligible for origin isola-
tion [72]. Making this optional may reduce the impact on the
process count. Similarly, we plan to evaluate the overhead
impact of isolating opaque origins, especially to improve se-
curity for sandboxed same-site iframes.
Performance. Finally, there are performance opportunities
to explore to reduce overhead and take advantage of the new
architecture. More aggressive renderer discarding may be
possible with less cross-site sharing of renderer processes.
Isolating cross-origin iframes from some web applications
may also provide performance beneﬁts by parallelizing the
workload, moving slower frames to a different process than
the primary user interface to keep the latter more responsive.
7 Related Work
Prior to this work, all major production browsers, including
IE/Edge [76], Chrome [52], Safari [70], and Firefox [43],
had multi-process architectures that rendered untrustworthy
web content in sandboxed renderer processes, but they did
not enforce process isolation between web security princi-
pals, and they lacked architectural support for rendering em-
bedded content such as iframes out-of-process. Site Isolation
makes Chrome the ﬁrst widely-adopted browser to add such
support. Other research demonstrated a need for an archi-
tecture like Site Isolation by showing how existing browsers
are vulnerable to cross-site data leaks, local ﬁle system ac-
cess via sync from cloud services, and transient execution
attacks [25, 33, 53].
Several research browsers have proposed isolating web
principals in different OS processes, including Gazelle [68],
OP and its successor OP2 [23, 62], and IBOS [63]. Com-
pared to these proposals, Site Isolation is the ﬁrst to sup-
port the web platform in its entirety, with practical per-
formance and compatibility. First, these proposals all de-
ﬁne principals as origins, but this cannot support pages that
change document.domain [12]. Other research browsers
isolate web applications with principals that are similarly
incompatible: Tahoma [16] uses custom manifests, while
SubOS [31, 32] uses full URLs that include path in addi-
tion to origin. To preserve compatibility, we adopt the site
principal proposed in [52]; this also helps reduce process
The OP and OP2 browsers [23, 62] also use OS processes
to isolate other browser components, including the network
stack, storage, and display. Such additional process separa-
tion is orthogonal to Site Isolation and offers complementary
beneﬁts, such as making the browser more modular, reduc-
ing the size of the browser process, and keeping crashes in
one component isolated from the rest of the browser.
Dong et al [19] argued that practical browser designs will
require a trade-off between ﬁner-grained isolation and per-
formance. Our experience echoes this ﬁnding, and we in-
deed make trade-offs to reduce memory overhead, such as
isolating sites rather than origins. Dong et al’s evaluation
relied on sequentially browsing top Alexa sites; we addition-
ally collect measurements from browsing workloads in the
wild, providing a more realistic performance evaluation. For
example, this factors in process sharing across multiple tabs,
which signiﬁcantly reduces overhead in practice.
count compared to origins. Second, we describe new opti-
mizations that make Site Isolation practical, and we evaluate
our architecture on a real workload of Chrome users. This
shows that Site Isolation introduces almost no additional
page load latency and only 9-13% memory overhead, lower
than expected from microbenchmark evaluations. Third,
we comprehensively evaluate the implications of new tran-
sient execution attacks [8] for browser security. Fourth, we
show that protecting cross-origin network responses requires
new forms of conﬁrmation snifﬁng to preserve compatibility;
content types and even traditional MIME snifﬁng are insuf-
ﬁcient. Finally, while Gazelle, OP2, and IBOS have out-
of-process iframes, our work overcomes many challenges to
support these in a production browser, such as supporting the
full set of cross-process JavaScript interactions, challenges
with painting and input event routing, and updating affected
features (e.g., ﬁnd-in-page, printing).
Other researchers propose disabling risky JavaScript fea-
tures unless user-deﬁned policies indicate they are safe for a
desired site [56, 61]. These approaches aim to disrupt a wide
variety of attacks (including microarchitectural), but they im-
pose barriers to adoption of powerful web features, and they
rely on users or third parties to know when features are safe
to enable. Site Isolation’s scope is more limited by compati-
bility, but it does not require actions from users or disabling
powerful features.
8 Conclusion
The web browser threat model has changed signiﬁcantly.
Web sites face greater threats of data leaks within the
browser due to compromised renderer processes and tran-
sient execution attacks. Site Isolation offers the best path to
mitigating these attacks in the browser, protecting a signif-
icant amount of site data today with future opportunities to
expand the coverage. We have shown that Site Isolation is
practical to deploy in a production desktop web browser, in-
curring a 9-13% total memory overhead on real-world work-
1674    28th USENIX Security Symposium
USENIX Association
loads. We recommend that web developers and browser ven-
dors continue down this path, protecting additional sensi-
tive resources, adding more mitigations, and pursuing sim-
ilar isolation in environments like mobile browsers.
9 Acknowledgements
We would like to thank Łukasz Anforowicz, Jann Horn, Ken
Buchanan, Chris Palmer, Adrienne Porter Felt, Franziska
Roesner, Tadayoshi Kohno, Antoine Labour, Artur Janc, our
shepherd Adam Doup´e, and the anonymous reviewers for
their input on this paper. We also thank the many Chrome
team members who made this work possible.
References
[1] Adobe. Flash & The Future of Interactive Content. https:
//theblog.adobe.com/adobe-flash-update/, 2017.
[2] L. Anforowicz. More CORB-protected MIME types -
adding protected types one-by-one. https://github.com/
whatwg/fetch/issues/860, Jan. 2019.
[3] A. Barth, C. Jackson, and J. C. Mitchell. Robust Defenses for
Cross-Site Request Forgery. In CCS, 2008.
[4] A. Barth, D. Song, and J. Caballero. Secure Content Snifﬁng
for Web Browsers, or How to Stop Papers from Reviewing
In IEEE Symposium on Security and Privacy,
Themselves.
2009.
[5] A. Barth, J. Weinberger, and D. Song. Cross-origin JavaScript
Capability Leaks: Detection, Exploitation, and Defense. In
USENIX Security, 2009.
[6] M. Blumberg. Security enhancements and more for enter-
https://www.blog.
prise Chrome browser customers.
google/products/chrome-enterprise/security-
enhancements-and-more-enterprise-chrome-
browser-customers/, Dec. 2017.
[7] M. Bynens.
Site
Isolation for web developers.
https://developers.google.com/web/updates/
2018/07/site-isolation, July 2018.
[8] C. Canella, J. V. Bulck, M. Schwarz, M. Lipp, B. von Berg,
P. Ortner, F. Piessens, D. Evtyushkin, and D. Gruss. A Sys-
tematic Evaluation of Transient Execution Attacks and De-
fenses. In USENIX Security, 2019.
[9] Changes to Cross-Origin Requests in Chrome Extension
https://www.chromium.org/Home/
Content Scripts.
chromium-security/extension-content-script-
fetches, Jan. 2019.
[10] S. Chen, H. Chen, and M. Caballero. Residue Objects: A
Challenge to Web Browser Security. In EuroSys, 2010.
[11] S. Chen, D. Ross, and Y.-M. Wang. An Analysis of Browser
Domain-Isolation Bugs and A Light-Weight Transparent De-
fense Mechanism. In CCS, 2007.
[12] Chrome
Platform
Status:
DocumentSetDomain.
https://www.chromestatus.com/metrics/feature/
popularity#DocumentSetDomain, Dec. 2018.
[13] Chromium Blog: Changes to the Field Trials infrastruc-
ture. https://blog.chromium.org/2012/05/changes-
to-field-trials-infrastructure.html, May 2012.
[14] Chromium Security:
Side-Channel At-
https://www.chromium.org/Home/chromium-
Mitigating
tacks.
security/ssca, Jan. 2018.
[15] J. Corbet. The current state of kernel page-table isolation.
https://lwn.net/Articles/741878/, Dec. 2017.
[16] R. S. Cox, J. G. Hansen, S. D. Gribble, and H. M. Levy.
A Safety-Oriented Platform for Web Applications. In IEEE
Symposium on Security and Privacy, 2006.
[17] Cross-Origin Read Blocking
(CORB).
https:
//chromium.googlesource.com/chromium/src/+/
master/services/network/cross_origin_read_
blocking_explainer.md, Mar. 2018.
[18] Cross-Origin Resource Sharing (CORS).
https://
developer.mozilla.org/en-US/docs/Web/HTTP/CORS,
2019.
[19] X. Dong, H. Hu, P. Saxena, and Z. Liang. A Quantitative
Evaluation of Privilege Separation in Web Browser Designs.
In ESORICS, 2013.
[20] Fetch Standard: CORB. https://fetch.spec.whatwg.
org/#corb, May 2018.
[21] Fetch Standard:
Cross-Origin-Resource-Policy header.
https://fetch.spec.whatwg.org/#cross-origin-
resource-policy-header, Jan. 2019.
[22] First Contentful
Paint.
https://developers.
google.com/web/tools/lighthouse/audits/first-
contentful-paint, 2019.
[23] C. Grier, S. Tang, and S. T. King. Designing and Implement-
ing the OP and OP2 Web Browsers. TWEB, 5:11, May 2011.
[24] D. Gruss, M. Lipp, M. Schwarz, R. Fellner, C. Maurice, and
S. Mangard. KASLR is Dead: Long Live KASLR. In ESSoS,
2017.
[25] N. Hadad and J. Afek. Overcoming (some) Spectre browser
mitigations. https://alephsecurity.com/2018/06/26/
spectre-browser-query-cache/, June 2018.
[26] V. Hailperin. Cross-Site Script Inclusion. https://www.
scip.ch/en/?labs.20160414, Apr. 2016.
[27] C. Harrelson. Adjust event loop processing model to al-
low asynchronous layout of frames. https://github.com/
whatwg/html/issues/3727, May 2018.
[28] J. Horn.
Speculative Execution, Variant 4:
Specula-
https://bugs.chromium.org/p/
tive Store Bypass.