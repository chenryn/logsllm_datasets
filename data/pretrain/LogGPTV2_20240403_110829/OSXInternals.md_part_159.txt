of the allocation block size, there will be some trailing space that will not have a corresponding bit in the
Allocation file. Even in this case, the alternate volume header is stored at a 1024-byte offset from the end of
the volumethat is, possibly in the unaccounted-for area. Nevertheless, HFS+ will still consider the last
Allocation-file-tracked 1024 bytes as used and will mark the corresponding allocation block (or blocks) as
allocated.
12.7.1.1. Viewing the Contents of the Allocation File
We can use hfsdebug to viewindirectlythe contents of the Allocation file. We say "indirectly" because
hfsdebug can examine the Allocation file and enumerate all free extents on a volume. Thus, the Allocation file
bits corresponding to the extents that hfsdebug lists are all clear, whereas the remaining bits are all set.
$ sudo hfsdebug -0
# Free Contiguous Starting @ Ending @ Space
16 0x60c7 0x60d6 64.00 KB
16 0x1d6d7 0x1d6e6 64.00 KB
16 0x1f8e7 0x1f8f6 64.00 KB
32 0x23cf7 0x23d16 128.00 KB
130182 0x25f67 0x45bec 508.52 MB
...
644 0x2180d00 0x2180f83 2.52 MB
4857584 0x2180f85 0x2622e74 18.53 GB
Allocation block size = 4096 bytes
Allocation blocks total = 39988854 (0x2622e76)
Allocation blocks free = 8825849 (0x86abf9)
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 26 of 81
12.7.1.2. The Roving Next-Allocation Pointer
For each mounted HFS+ volume, the kernel maintains a roving pointeran allocation block number as a hintthat
is used as a starting point while searching for free allocation blocks in many (but not all) cases. The pointer is
held in the nextAllocation field of the hfsmount structure. An allocation operation that uses the pointer also
updates it.
$ sudo hfsdebug -m
...
free allocation blocks = 0x86d12b
start block for next allocation search = 0x20555ea
next unused catalog node ID = 3256261
...
$ echo hello > /tmp/newfile.txt
$ sudo hfsdebug -m
...
free allocation blocks = 0x86d123
start block for next allocation search = 0x20555eb
next unused catalog node ID = 3256262
...
$ sudo hfsdebug /tmp/newfile.txt
...
# Catalog File Record
type = file
file ID = 3256261
...
# Data Fork
...
extents = startBlock blockCount % of file
0x20555eb 0x1 100.00 %
1 allocation blocks in 1 extents total.
...
You can also set the value of nextAllocation for a given volume. The HFS_CHANGE_NEXT_ALLOCATION
request of the fsctl() system call can be used to do so. Figure 1211 shows a program that sets
nextAllocation for the given volume path.
Figure 1211. Hinting to the file system where to look for free space on a volume
// hfs_change_next_allocation.c
#include 
#include 
#include 
#include 
// ensure that the following match the definitions in bsd/hfs/hfs_fsctl.h
// for the current kernel version, or include that header file directly
#define HFSIOC_CHANGE_NEXT_ALLOCATION _IOWR('h', 3, u_int32_t)
#define HFS_CHANGE_NEXT_ALLOCATION IOCBASECMD(HFSIOC_CHANGE_NEXT_ALLOCATION)
#define PROGNAME "hfs_change_next_allocation"
int
main(int argc, char **argv)
{
int ret = -1;
u_int32_t block_number, new_block_number;
if (argc != 3) {
fprintf(stderr, "usage: %s  \n",
PROGNAME);
exit(1);
}
block_number = strtoul(argv[2], NULL, 16);
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 27 of 81
new_block_number = block_number;
ret = fsctl(argv[1], HFS_CHANGE_NEXT_ALLOCATION, (void *)block_number, 0);
if (ret)
perror("fsctl");
else
printf("start block for next allocation search changed to %#x\n",
new_block_number);
exit(ret);
}
Let us test the program shown in Figure 1211 on a new HFS+ disk image (Figure 1212).
Figure 1212. Examining allocation block consumption on a volume
$ hdiutil create -size 32m -fs HFSJ -volname HFSHint /tmp/hfshint.dmg
...
created: /tmp/hfshint.dmg
$ open /tmp/hfshint.dmg
$ sudo hfsdebug -V /Volumes/HFSHint -m
...
start block for next allocation search = 0xaf7
...
$ hfsdebug -V /Volumes/HFSHint -0
# Free Contiguous Starting @ Ending @ Space
630 0x881 0xaf6 2.46 MB
5372 0xaf9 0x1ff4 20.98 MB
Allocation block size = 4096 bytes
Allocation blocks total = 8182 (0x1ff6)
Allocation blocks free = 6002 (0x1772)
$ echo hello > /Volumes/HFSHint/file.txt
$ hfsdebug /Volumes/HFSHint/file.txt
...
extents = startBlock blockCount % of file
0xaf9 0x1 100.00 %
1 allocation blocks in 1 extents total.
...
$ hfsdebug -V /Volumes/HFSHint -0
# Free Contiguous Starting @ Ending @ Space
630 0x881 0xaf6 2.46 MB
5371 0xafa 0x1ff4 20.98 MB
Allocation block size = 4096 bytes
Allocation blocks total = 8182 (0x1ff6)
Allocation blocks free = 6001 (0x1771)
$ sudo hfsdebug -V /Volumes/HFSHint -m
...
start block for next allocation search = 0xaf9
...
$
Since allocation blocks 0xafa through 0x1ff4 are free on the volume shown in Figure 1212, let us use the
program from Figure 1211 to set the nextAllocation value to 0xbbb. We can then create a file and see if the
file starts at that allocation block.
$ gcc -Wall -o hfs_change_next_allocation hfs_change_next_allocation.c
$ ./hfs_change_next_allocation /Volumes/HFSHint 0xbbb
start block for next allocation search changed to 0xbbb
$ echo hello > /Volumes/HFSHint/anotherfile.txt
$ hfsdebug /Volumes/HFSHint/anotherfile.txt
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 28 of 81
...
extents = startBlock blockCount % of file
0xbbb 0x1 100.00 %
1 allocation blocks in 1 extents total.
...
12.7.2. The Catalog File
The Catalog file describes the hierarchy of files and folders on a volume. It acts both as a container for holding
vital information for all files and folders on a volume and as their catalog. HFS+ stores file and folder names
as Unicode strings represented by HFSUniStr255 structures, which consist of a length and a 255-element
double-byte Unicode character array.
// bsd/hfs/hfs_format.h
struct HFSUniStr255 {
u_int16_t length; // number of Unicode characters in this name
u_int16_t unicode[255]; // Unicode characters
// (fully decomposed, in canonical order)
};
Each file or folder on the volume is identified by a unique catalog node ID (CNID) in the Catalog file. The
CNID is assigned at file creation time. In particular, HFS+ does not use an inode table. A folder's CNID
(directory ID) and a file's CNID (file ID) are reported[15] as their respective inode numbers when queried
through a Unix-based interface such as the stat() system call.
[15] Hard links are an exception to this behavior. See Section 12.8.6.
On traditional Unix file systems, an index node, or inode, is an object describing the internal representation of
a file. Each file or directory object has a unique on-disk inode that contains the object's metadata and the
locations of the object's blocks.
As noted earlier, the Catalog file is organized as a B-Tree to allow for quick and efficient searching. Its
fundamental structure is the same as we discussed in Section 12.2.6. However, the formats of the keys and the
data stored in its records are specific to it.
Each user file has two leaf records in the Catalog file: a file record and a file thread record. Similarly, each
folder has two leaf records: a folder record and a folder thread record. The purposes of these records are as
follows.
 A file record (struct HFSPlusCatalogFile [bsd/hfs/hfs_format.h]) contains standard (as opposed
to extended) file metadata, which includes the file's CNID, various timestamps, Unix-style permissions,
Finder information, and the initial extents of the file's data and resource forks.
 A folder record (struct HFSPlusCatalogFolder [bsd/hfs/hfs_format.h]) contains standard folder
metadata, most of which is identical to file metadata, except that a folder has no data or resource forks.
Each folder has a valence value representing the number of children (not descendants) the folder hasthat
is, the sum of the numbers of files and immediate subdirectories within the folder.
 Both file thread and folder thread records are represented by an HFSPlusCatalogThread structure
[bsd/hfs/hfs_format.h], whose recordType field indicates the thread record's type. A thread record
contains the name and parent CNID of the catalog node it represents. Thread records represent the
hierarchical structure of the file system by threading together the relative organization of files and
folders.
In traditional Unix file systems, directories are explicitly stored on disk. Storing the hierarchical structure in a
B-Tree has several performance benefits, but not without costfor example, the Catalog B-Tree must be locked,
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 29 of 81
sometimes exclusively, for several file system operations.
Let us see how a file might be accessed given its identifying information. Depending on the programming
interface it uses, a user program can specify the file system object it wishes to access on a given volume in
several ways:
The target's Unix-style relative or absolute pathname
The target's CNID
The target's node name and the CNID of its parent folder
The volume file systemnormally mounted under /.volallows files and folders on an HFS+ volume to be
looked up by their CNIDs. As we saw in Chapter 11, the /.vol directory contains a subdirectory for each
mounted volume that supports the volume file system. The subdirectory names are the same as the respective
volume IDs.
Pathname lookups are broken down into component-wise lookup operations in the kernel. Recently looked up
names are cached[16] so that the namei() function does not have to go all the way down to the file system on
every lookup. At the catalog-level, tree searches are either one-step or two-step, depending on how the search
key is populated. A Catalog B-Tree key is represented by the HFSPlusCatalogKey structure.
[16] Resource fork names are not cached.
// bsd/hfs/hfs_format.h
struct HFSPlusCatalogKey {
u_int16_t keyLength;
// parent folder's CNID for file and folder records;
// node's own CNID for thread records
u_int32_t parentID;
// node's Unicode name for file and folder records;
// empty string for thread records
HFSUniStr255 nodeName;
};
Figure 1213 shows an overview of how the Catalog B-Tree is searched. If we begin with only the CNID of the
target object, a two-step search is required. The search key is prepared as follows: The parentID field of the
HFSPlusCatalogKey structure is set to the target's CNID, and the nodeName field is set to the empty string. A
B-Tree lookup performed with such a key yields the target's thread record (if it exists). The contents of the
thread recordthe target's node name and its parent's CNIDare what we require to perform a one-step search. A
second lookup will yield an HFSPlusCatalogFile or HFSPlusCatalogFolder record, depending on whether
the target is a file or a folder, respectively. When comparing two catalog keys, their parentID fields are
compared first and the nodeName fields are compared next.
Figure 1213. Searching in the Catalog B-Tree
[View full size image]
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 30 of 81
Figure 1214 shows an overall picture of how a file might be accessed by an HFS+ implementation. Suppose
we wish to read a file. We will start at the volume header (1), which will provide us with the extents of the
Catalog file (2). We will search the Catalog B-Tree to find the desired file record (3), which will contain the
file's metadata and initial extents (4). Given the latter, we can seek the appropriate disk sectors and read the file
data (5). If the file has more than eight extents, we will have to perform one or more additional lookups in the
Extents Overflow file.
Figure 1214. An overview of accessing a file's contents
[View full size image]
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 31 of 81
12.7.2.1. Catalog Node IDs
As noted earlier, each file and folder on an HFS+ volumeincluding the special filesis assigned a unique CNID,
which is implemented as a 32-bit unsigned integer. Apple reserves the first 16 CNIDs for its own use. Table
122 shows how these CNIDs are used.
Table 122. Standard CNID Assignments on HFS+ Volumes
CNID Assignment
0 Invalid CNIDnever used for a file system object.
1 Represents the parent ID of the root folder (for the purpose of B-Tree
lookups).
2 Root folder's ID (similar to the Unix convention of using 2 as the
inode number for a file system's root directory).
3 The Extents Overflow file's ID.
4 The Catalog file's ID.
5 Used as the ID of a hypothetical file (the Bad Blocks file) that owns
allocation blocks containing bad sectors. The Bad Blocks file does
not have any catalog recordsall its extents are in the Extents Overflow
file.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 32 of 81
6 The Allocation file's ID.
7 The Startup file's ID.
8 The Attributes file's ID.
9 Unused/reserved.
10 Unused/reserved.
11 Unused/reserved.
12 Unused/reserved.
13 Unused/reserved.
14 Used as the ID of a temporary Catalog file while the file system is
being repaired.
15 Used temporarily during an invocation of the exchangedata()
system call, which performs an atomic swap of the fork data in two
files.
The next unused CNID is maintained in both the volume header (as the nextCatalogID field) and the
hfsmount structure (as the vcbNxtCNID field).
The first CNID available for user files and folders is 16. In practice, it will be assigned to a file or a folder
created before the user begins to access the volumefor example, a journal file.
An interesting property of HFS+ is that it allows a Unix pathname of a file system object to be determined
from its inode number. With the exception of hard links, an object's CNID is used as its inode number from the
standpoint of the Unix APIs. Since a thread record connects an object to its parent, a complete pathname can
be constructed by repeatedly looking up thread records until we reach the root. Note that we say "a pathname"
and not "the pathname" because a Unix-visible inode number may have more than one referring pathname if
the file's link count is greater than onethat is, if it has several hard links.[17]
[17] As is normally the case on file systems that support hard links, HFS+ does not permit hard
links to directories.
hfsdebug supports the previously mentioned methods of looking up a file system object, for example:
$ sudo hfsdebug -c 16 # look up by CNID
path = Macintosh HD:/.journal
# Catalog File Record
type = file
file ID = 16
...
$ sudo hfsdebug -F 2:.journal # look up by node name and parent's CNID
path = Macintosh HD:/.journal
...
The Carbon File Manager provides the PBResolveFileIDRefSync() function to retrieve the node name and
parent CNID of a file system object given its CNID. The program shown in Figure 1215 prints the Unix
pathname of a file or foldergiven its CNIDresiding on the default (root) volume. It continues to find the name
of each component of the given pathname until the parent ID of a given component is the same as that of the
component.
Figure 1215. Using the Carbon File Manager API to convert a CNID to a Unix pathname
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 33 of 81
// cnid2path.c
#include 
#include 