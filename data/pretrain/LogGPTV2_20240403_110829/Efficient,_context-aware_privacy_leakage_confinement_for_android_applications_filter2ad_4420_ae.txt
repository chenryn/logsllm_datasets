A study [15] shows that many Android applications make use
of Java reﬂection to call undocumented methods. While in 88.3%
cases, the class names and method names of these reﬂective calls
can be statically resolved, the rest can still cause problems.
In
our experiment, we seldom encounter this situation, because even
though some apps indeed use reﬂective calls, they are rarely lo-
cated within the taint propagation slices. That is, these reﬂective
calls in general are not involved in privacy leakage. We could use a
conservative function summary, such that all output parameters and
the return value are tainted if any of input parameter is tainted, but
it might be too conservative. A more elegant solution might be to
capture the class name and the method name at runtime and redi-
rect to the corresponding function summary, which enforces more
precise propagation logic. We leave this as our future work.
Native Components.
Android applications sometimes need auxiliary native compo-
nents to function, while, unfortunately, static bytecode-level analy-
sis is not capable of keeping track of information ﬂow within JNI
calls. However, many apps in fact use common native components,
which originate from reliable resources and are of widely recog-
nized dataﬂow behavior. Thus, it is possible to model these known
components with ofﬂine knowledge.
In other words, we could
build a database for well-known native libraries and create proper
function summaries for JNI calls, and therefore exercise static data
propagation through native calls with the help of such summaries.
7. RELATED WORK
In this section, we discuss previous work that is related to code
rewriting and optimization and privacy leakage detection and miti-
gation on mobile platforms.
Bytecode Rewriting.
Many efforts are made to rewrite apps for security purposes. The
Privacy Blocker application [2] performs static analysis of applica-
tion binaries to identify and selectively replace requests for sensi-
tive data with hard-coded shadow data. I-ARM-Droid [10] rewrites
Dalvik bytecode, where it interposes on all the invocations of these
API methods to implement the desired security policies. Aura-
sium [32] repackages Android apps to sandbox important native
APIs and watch the applications’ behaviors for security and privacy
violations. Livshits and Jung [23] implemented a graph-theoretic
algorithm to place mediation prompts into bytecode program and
thus protect resource access. In comparison, we proposed a new
bytecode rewriting technique to track information ﬂow and enforce
information-ﬂow based policies.
Instrumentation Code Optimization.
We reduce code instrumentation overhead by performing vari-
ous static analysis and optimizations. Several other works share
the same insight. To ﬁnd error patterns in Java source code, Mar-
tin et al. optimized dynamic instrumentation by performing static
pointer alias analysis [26]. To detect numerous software attacks,
Xu et al. inserted runtime checks to enforce various security poli-
cies in C source code, and remove redundant checks via compiler
optimizations [33]. While we share the same insight, our work
deals with Dalvik bytecode programs and speciﬁc instrumentation
methods are completely different.
Privacy Leakage Detection.
Egele et al. [11] studied the privacy threats in iOS applications.
They proposed PiOS, a static analysis tool to detect privacy leaks
in Mach-O binaries. TaintDroid is a dynamic analysis tool for de-
tecting and analyzing privacy leaks in Android applications [12].
It modiﬁes Dalvik virtual machine and dynamically instruments
Dalvik bytecode instructions to perform dynamic taint analysis.
Enck et al. [13] proposed a static analysis approach to study privacy
leakage as well. They convert a Dalvik executable to Java source
code and leverage a commercial Java source code analysis tool
Fortify360 [20] to detect surreptitious data ﬂows. CHEX [24] is
designed to vet Android apps for component hijacking vulnerabili-
ties and is essentially capable of detecting privacy leakage. It con-
verted Dalvik bytecode to WALA [4] SSA IR, and conducted static
dataﬂow analysis with WALA framework. AndroidLeaks [17] is a
static analysis framework, which also leverages WALA, and identi-
ﬁes potential leaks of personal information in Android applications
on a large scale. Mann et al. [25] analyzed the Android API for
possible sources and sinks of private data and thus identiﬁed exem-
plary privacy policies.
Privacy Leak Mitigation.
Based on TaintDroid, Hornyack et al. [19] proposed AppFence to
further mitigate privacy leaks. When TaintDroid discovers the data
dependency between source and sink, AppFence enforces privacy
policies, either at source or sink, to protect sensitive information.
At source, it may provide the app with fake information instead of
the real one; at sink, it can block sending APIs. AppFence requires
268modiﬁcations in the Dalvik virtual machine to track information
ﬂow and incurs considerable performance overhead (14% on av-
erage according to TaintDroid [12]). In contrast, Capper takes a
bytecode rewriting approach. There is no hurdle for deployment,
and due to static dataﬂow analysis and a series of optimizations,
the new application rewritten by Capper can achieve higher efﬁ-
ciency.
8. CONCLUSION
We developed a bytecode rewriting approach to defeat privacy
leakage in Android applications. Given an unknown Android app,
we ﬁrstly selectively rewrite the program by inserting bytecode
instructions along taint propagation slices for potential informa-
tion leakage. Then to differentiate true leakage with benign sen-
sitive dataﬂow, we leverage user’s semantic knowledge and devise
a context-aware policy enforcement mechanism. Our evaluation on
4723 real-world Android applications demonstrates that Capper
can effectively track and mitigate privacy leaks. Moreover, after
going through a series of optimizations, the instrumentation code
only represents a small portion (4.48% on average) of the entire
program. In addition, the runtime overhead introduced by Capper
is also minimal, merely 1.5% for intensive data propagation.
9. ACKNOWLEDGMENT
We would like to thank anonymous reviewers for their com-
ments. This research was supported in part by NSF Grant #1018217,
NSF Grant #1054605 and McAfee Inc. Any opinions, ﬁndings, and
conclusions made in this material are those of the authors and do
not necessarily reﬂect the views of the funding agencies.
10. REFERENCES
[1] dex2jar. http://code.google.com/p/dex2jar/.
[2] Privacy blocker.
http://privacytools.xeudoxus.com/.
[3] Soot: a java optimization framework.
http://www.sable.mcgill.ca/soot/.
[4] T.j. watson libraries for analysis.
http://wala.sourceforge.net.
[5] J. Andrus, C. Dall, A. V. Hof, O. Laadan, and J. Nieh. Cells:
A Virtual Mobile Smartphone Architecture. In Proceedings
of the 23rd ACM Symposium on Operating Systems
Principles (SOSP’11), October 2011.
[6] A. R. Beresford, A. Rice, N. Skehin, and R. Sohan.
MockDroid: Trading Privacy for Application Functionality
on Smartphones. In Proceedings of the 12th Workshop on
Mobile Computing Systems and Applications
(HotMobile’11), March 2011.
[7] K. Z. Chen, N. Johnson, V. D’Silva, S. Dai, K. MacNamara,
T. Magrino, E. X. Wu, M. Rinard, and D. Song. Contextual
Policy Enforcement in Android Applications with
Permission Event Graphs. In Proceedings of the 20th Annual
Network and Distributed System Security Symposium
(NDSS’13), February 2013.
[8] M. Conti, V. T. N. Nguyen, and B. Crispo. CRePE:
Context-Related Policy Enforcement for Android. In
Proceedings of the 13th International Conference on
Information Security (ISC’10), October 2010.
[9] L. Davi, A. Dmitrienko, A.-R. Sadeghi, and M. Winandy.
Privilege Escalation Attacks on Android. In Proceedings of
the 13th International Conference on Information Security
(ISC’10), October 2011.
[10] B. Davis, B. Sanders, A. Khodaverdian, and H. Chen.
I-ARM-Droid: A Rewriting Framework for In-App
Reference Monitors for Android Applications. In
Proceedings of the Mobile Security Technologies Workshop
(MoST’12), May 2012.
[11] M. Egele, C. Kruegel, E. Kirda, and G. Vigna. PiOS:
Detecting Privacy Leaks in iOS Applications. In Proceedings
of 18th Annual Network and Distributed System Security
Symposium (NDSS’11), February 2011.
[12] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung,
P. McDaniel, and A. N. Sheth. TaintDroid: An
Information-Flow Tracking System for Realtime Privacy
Monitoring on Smartphones. In Proceedings of the 9th
USENIX Symposium on Operating Systems Design and
Implementation (OSDI’10), October 2010.
[13] W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri. A
Study of Android Application Security. In Proceedings of
the 20th Usenix Security Symposium, August 2011.
[14] W. Enck, M. Ongtang, and P. McDaniel. On Lightweight
Mobile Phone Application Certiﬁcation. In Proceedings of
the 16th ACM Conference on Computer and
Communications Security (CCS’09), November 2009.
[15] A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner.
Android Permissions Demystiﬁed. In Proceedings of the
18th ACM Conference on Computer and Communications
Security (CCS’11), October 2011.
[16] A. P. Felt, H. J. Wang, A. Moshchuk, S. Hanna, and E. Chin.
Permission Re-delegation: Attacks and Defenses. In
Proceedings of the 20th USENIX Security Symposium,
August 2011.
[17] C. Gibler, J. Crussell, J. Erickson, and H. Chen.
AndroidLeaks: Automatically Detecting Potential Privacy
Leaks in Android Applications on a Large Scale. In
Proceedings of the 5th International Conference on Trust
and Trustworthy Computing (TRUST’12), June 2012.
[18] M. Grace, Y. Zhou, Z. Wang, and X. Jiang. Systematic
Detection of Capability Leaks in Stock Android
Smartphones. In Proceedings of the 19th Annual Network
and Distributed System Security Symposium (NDSS’12),
February 2012.
[19] P. Hornyack, S. Han, J. Jung, S. Schechter, and D. Wetherall.
These Aren’t The Droids You’re Looking For: Retroﬁtting
Android to Protect Data from Imperious Applications. In
Proceedings of the 18th ACM Conference on Computer and
Communications Security (CCS’11), October 2011.
[20] C. Inc. Hp fortify source code analyzer.
http://www.cigital.com/training/
elearning/fortify-source-code-analyzer.
[21] J. Kim, Y. Yoon, K. Yi, and J. Shin. SCANDAL: Static
Analyzer for Detecting Privacy Leaks in Android
Applications. In Proceedings of the Mobile Security
Technologies Workshop (MoST’12), May 2012.
[22] M. Lange, S. Liebergeld, A. Lackorzynski, A. Warg, and
M. Peter. L4Android: A Generic Operating System
Framework for Secure Smartphones. In Proceedings of the
1st ACM Workshop on Security and Privacy in Smartphones
and Mobile Devices (SPSM’11), October 2011.
[23] B. Livshits and J. Jung. Automatic Mediation of
Privacy-Sensitive Resource Access in Smartphone
Applications. In Proceedings of the 22th Usenix Security
Symposium, August 2013.
[24] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang. CHEX: statically
vetting Android apps for component hijacking
vulnerabilities. In Proceedings of the 2012 ACM Conference
269on Computer and Communications Security (CCS’12),
October 2012.
[25] C. Mann and A. Starostin. A Framework for Static Detection
of Privacy Leaks in Android Applications. In Proceedings of
the 27th Annual ACM Symposium on Applied Computing
(SAC’12), March 2012.
[26] M. Martin, B. Livshits, and M. S. Lam. Finding Application
Errors and Security Flaws Using PQL: A Program Query
Language. In Proceedings of the 20th Annual ACM
SIGPLAN Conference on Object-oriented Programming,
Systems, Languages, and Applications (OOPSLA’05),
October 2005.
[27] M. Nauman, S. Khan, and X. Zhang. Apex: Extending
Android Permission Model and Enforcement with
User-deﬁned Runtime Constraints. In Proceedings of the 5th
ACM Symposium on Information, Computer and
Communications Security (ASIACCS’10), April 2010.
[28] D. Octeau, S. Jha, and P. McDaniel. Retargeting Android
Applications to Java Bytecode. In Proceedings of the ACM
SIGSOFT 20th International Symposium on the Foundations
of Software Engineering (FSE’12), November 2012.
[29] M. Ongtang, S. McLaughlin, W. Enck, and P. McDaniel.
Semantically Rich Application-Centric Security in Android.
In Proceedings of the 2009 Annual Computer Security
Applications Conference (ACSAC’09), December 2009.
[30] S. Shekhar, M. Dietz, and D. S. Wallach. AdSplit: Separating
Smartphone Advertising from Applications. In Proceedings
of the 20th Usenix Security Symposium, August 2012.
[31] C. Wu, Y. Zhou, K. Patel, Z. Liang, and X. Jiang. AirBag:
Boosting Smartphone Resistance to Malware Infection. In
Proceedings of the 21th Annual Network and Distributed
System Security Symposium (NDSS’14), February 2014.
[32] R. Xu, H. Saïdi, and R. Anderson. Aurasium: Practical
Policy Enforcement for Android Applications. In
Proceedings of the 21st USENIX Conference on Security
Symposium, August 2012.
[33] W. Xu, S. Bhatkar, and R. Sekar. Taint-enhanced Policy
Enforcement: A Practical Approach to Defeat a Wide Range
of Attacks. In Proceedings of the 15th Conference on
USENIX Security Symposium, July 2006.
[34] Z. Yang, M. Yang, Y. Zhang, G. Gu, P. Ning, and X. S.
Wang. AppIntent: Analyzing Sensitive Data Transmission in
Android for Privacy Leakage Detection. In Proceedings of
the 20th ACM Conference on Computer and
Communications Security (CCS’13), November 2013.
[35] M. Zhang and H. Yin. AppSealer: Automatic Generation of
Vulnerability-Speciﬁc Patches for Preventing Component
Hijacking Attacks in Android Applications. In Proceedings
of the 21th Annual Network and Distributed System Security
Symposium (NDSS’14), February 2014.
[36] Y. Zhou and X. Jiang. Dissecting Android Malware:
Characterization and Evolution. In Proceedings of the 33rd
IEEE Symposium on Security and Privacy (Oakland’12),
May 2012.
[37] Y. Zhou and X. Jiang. Detecting Passive Content Leaks and
Pollution in Android Applications. In Proceedings of the
20th Network and Distributed System Security Symposium
(NDSS’13), February 2013.
[38] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang. Hey, You, Get Off
of My Market: Detecting Malicious Apps in Ofﬁcial and
Alternative Android Markets. In Proceedings of 19th Annual
Network and Distributed System Security Symposium
(NDSS’12), February 2012.
[39] Y. Zhou, X. Zhang, X. Jiang, and V. W. Freeh. Taming
Information-Stealing Smartphone Applications (on Android).
In Proceedings of the 4th International Conference on Trust
and Trustworthy Computing (TRUST’11), June 2011.
APPENDIX
Figure 9: Taint Propagation Tree for the Running Example.
A. TAINT PROPAGATION TREE FOR RUN-
NING EXAMPLE
Figure 9 illustrates the result for applying the dataﬂow analysis
on the running example. While the entire graph shows the taint
propagation tree, the subgraph surrounded by dotted lines is the
taint slice for the critical information ﬂow (i.e.
IMEI leakage).
Each node represents a Jimple statement and its function call con-
text. This tree starts at the invocation of getDeviceId() in
getIMEI(). The source data is thus obtained and further propa-
gated back to onStart() via return value. Then, in onStart(),
IMEI is stored into a static ﬁeld. Taking the static ﬁeld as the source
of the next iteration, the graph further expands into two branches.
In the right branch, the static ﬁeld is read from onResume() and
then passed to toastIMEI() for display; In the left branch, the
static ﬁeld is accessed from onDestroy() which further prop-
agates the data to crypt() and post() sequentially, and thus
sends it out to the network. From this graph, we can see that the
left branch is actually leading to privacy leakage and thus is our
target to instrument. The right branch is irrelevant to leakage and
thus removed from the taint slice.
: r6 = virtualinvoke r4.(): return r6: $r1 = virtualinvoke r0.():  = $r1: $r1 = : $r1 = : virtualinvoke r0.($r1): r1 := @parameter0: String: $r6 = virtualinvoke $r5.(r1): $r7 = virtualinvoke $r6.(): $r8 = staticinvoke ($r4, $r7, 0): virtualinvoke $r8.(): r2 = virtualinvoke $r1.(): $i1 = lengthof r2: $b2 = r2[i0]: $b3 = virtualinvoke r0.($b2): b0 := @parameter0: byte: $b2 = b0 ^ $b1: return $b2: $b3 = virtualinvoke r0.($b2): r2[i0] = $b3: virtualinvoke r0.($r3, r2): r2 := @parameter1: byte[]: $i0 = lengthof r2:virtualinvoke r6.(r2, 0, $i0)Static Field270