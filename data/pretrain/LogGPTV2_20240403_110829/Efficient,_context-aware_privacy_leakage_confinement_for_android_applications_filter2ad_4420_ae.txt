### 优化后的文本

#### Java反射调用
一项研究 [15] 表明，许多Android应用程序使用Java反射来调用未记录的方法。虽然在88.3%的情况下，这些反射调用的类名和方法名可以静态解析，但剩余部分仍可能引发问题。在我们的实验中，这种情况很少遇到，因为即使某些应用程序确实使用了反射调用，它们也很少出现在污点传播切片中。也就是说，这些反射调用通常不涉及隐私泄露。

我们可以使用保守的函数摘要，即如果任何输入参数被污染，则所有输出参数和返回值也被视为污染，但这可能过于保守。一个更优雅的解决方案是在运行时捕获类名和方法名，并重定向到相应的函数摘要，从而实现更精确的传播逻辑。我们将此作为未来的工作方向。

#### 原生组件
Android应用程序有时需要辅助的原生组件才能正常运行，但不幸的是，静态字节码级分析无法跟踪JNI调用中的信息流。然而，许多应用程序实际上使用了来自可靠资源且数据流行为广泛认可的通用原生组件。因此，可以利用离线知识对这些已知组件进行建模。

换句话说，我们可以为知名的原生库建立一个数据库，并为JNI调用创建适当的函数摘要，从而借助这些摘要实现静态数据通过原生调用的传播。

#### 相关工作
本节讨论与代码重写和优化以及移动平台上的隐私泄露检测和缓解相关的先前工作。

##### 字节码重写
许多努力致力于为了安全目的重写应用程序。例如，Privacy Blocker应用 [2] 对应用程序二进制文件进行静态分析，以识别并选择性地将敏感数据请求替换为硬编码的影子数据。I-ARM-Droid [10] 重写了Dalvik字节码，在所有API方法调用中插入中介，以实施所需的安全策略。Aurasium [32] 重新打包Android应用程序以沙箱化重要的原生API，并监视应用程序的行为以防止安全和隐私违规。Livshits和Jung [23] 实现了一种图论算法，将调解提示插入字节码程序，从而保护资源访问。相比之下，我们提出了一种新的字节码重写技术，用于跟踪信息流并实施基于信息流的策略。

##### 代码插桩优化
我们通过执行各种静态分析和优化来减少代码插桩开销。其他一些工作也分享了同样的见解。Martin等人 [26] 通过执行静态指针别名分析来优化动态插桩，以查找Java源代码中的错误模式。Xu等人 [33] 在C源代码中插入运行时检查以实施各种安全策略，并通过编译器优化删除冗余检查。尽管我们有相同的见解，但我们的工作处理的是Dalvik字节码程序，具体的插桩方法完全不同。

##### 隐私泄露检测
Egele等人 [11] 研究了iOS应用程序中的隐私威胁，并提出了PiOS，这是一种静态分析工具，用于检测Mach-O二进制文件中的隐私泄露。TaintDroid [12] 是一种用于检测和分析Android应用程序中隐私泄露的动态分析工具。它修改了Dalvik虚拟机，并动态插桩Dalvik字节码指令以执行动态污点分析。Enck等人 [13] 提出了一种静态分析方法来研究隐私泄露。他们将Dalvik可执行文件转换为Java源代码，并利用商业Java源代码分析工具Fortify360 [20] 来检测隐秘的数据流。CHEX [24] 设计用于检测Android应用程序中的组件劫持漏洞，本质上也可以检测隐私泄露。它将Dalvik字节码转换为WALA [4] SSA IR，并使用WALA框架进行静态数据流分析。AndroidLeaks [17] 是一种静态分析框架，同样利用WALA，在大规模上识别Android应用程序中潜在的个人信息泄露。Mann等人 [25] 分析了Android API中可能的私有数据来源和汇点，从而确定了示例性的隐私策略。

##### 隐私泄露缓解
基于TaintDroid，Hornyack等人 [19] 提出了AppFence以进一步缓解隐私泄露。当TaintDroid发现源和汇点之间的数据依赖关系时，AppFence会在源或汇点实施隐私策略，以保护敏感信息。在源点，它可以提供虚假信息而不是真实信息；在汇点，它可以阻止发送API。AppFence要求在Dalvik虚拟机中进行修改以跟踪信息流，并导致显著的性能开销（根据TaintDroid [12] 的报告，平均为14%）。相比之下，Capper采用了字节码重写方法。部署没有障碍，并且由于静态数据流分析和一系列优化，由Capper重写的新应用程序可以实现更高的效率。

#### 结论
我们开发了一种字节码重写方法，以防止Android应用程序中的隐私泄露。对于未知的Android应用程序，我们首先通过沿潜在信息泄露的污点传播切片插入字节码指令来选择性地重写程序。然后，为了区分真正的泄露和良性的敏感数据流，我们利用用户的语义知识并设计了一个上下文感知的策略实施机制。我们在4723个真实世界的Android应用程序上的评估表明，Capper能够有效地跟踪和缓解隐私泄露。此外，经过一系列优化后，插桩代码仅占整个程序的一小部分（平均为4.48%）。此外，Capper引入的运行时开销也非常小，仅为1.5%。

#### 致谢
感谢匿名评审员的评论。这项研究得到了NSF Grant #1018217、NSF Grant #1054605和McAfee Inc.的部分支持。本文中的观点、发现和结论属于作者，并不一定反映资助机构的观点。

#### 参考文献
[1] dex2jar. http://code.google.com/p/dex2jar/
[2] Privacy blocker. http://privacytools.xeudoxus.com/
[3] Soot: a java optimization framework. http://www.sable.mcgill.ca/soot/
[4] T.j. watson libraries for analysis. http://wala.sourceforge.net
... （省略后续参考文献）

#### 附录
图9：运行示例的污点传播树。

**污点传播树**
图9展示了对运行示例进行数据流分析的结果。虽然整个图显示了污点传播树，但虚线包围的子图是关键信息流（即IMEI泄露）的污点切片。每个节点代表一个Jimple语句及其函数调用上下文。这棵树从getIMEI()中的getDeviceId()调用开始。源数据由此获得并通过返回值进一步传播回onStart()。然后，在onStart()中，IMEI被存储到一个静态字段中。以静态字段作为下一次迭代的源，图形进一步扩展为两个分支。在右分支中，静态字段从onResume()读取并传递给toastIMEI()进行显示；在左分支中，静态字段从onDestroy()访问，进而依次传播到crypt()和post()，最终将数据发送到网络。从这个图中可以看出，左分支实际上导致了隐私泄露，因此是我们要插桩的目标。右分支与泄露无关，因此从污点切片中移除。

希望这些优化能使您的文本更加清晰、连贯和专业！