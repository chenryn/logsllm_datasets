in Table III are similarly clear. DREAM produces goto-free
and compact code. As can be seen in the Zeus sample,
Hex-Rays produces 1,571 goto statements. These statements
make analyzing these pieces of malware very time-consuming
and difﬁcult. While further studies are needed to evaluate if
compactness is always an advantage, the total elimination of
goto statements from the decompiled code is a major step
forward and has already been of great beneﬁt to us in our
work analyzing malware samples.
Due to space constraints, we cannot present a com-
the decompiled malware source code in this
parison of
this reason, we have created a supplemen-
paper. For
tal document which can be accessed under
the follow-
ing URL: https://net.cs.uni-bonn.de/ﬁleadmin/ag/martini/Staff/
yakdan/code_snippets_ndss_2015.pdf. Here we present listings
of selected malware functions so that the reader can get a
personal impression on the readability improvements offered
by DREAM compared to Hex-Rays.
VIII. RELATED WORK
There has been much work done in the ﬁeld of de-
compilation and abstraction recovery from binary code. In
this section, we review related work and place DREAM in
the context of existing approaches. We start by reviewing
control-ﬂow structuring algorithms. Next, we discuss work in
decompilation, binary code extraction and analysis. Finally,
techniques to recover type abstractions from binary code are
discussed.
Control-ﬂow structuring. There exist two main approaches
used by modern decompilers to recover control-ﬂow structure
from the CFG representation, namely interval analysis and
structural analysis. Originally, these techniques were devel-
oped to assist data ﬂow analysis in optimizing compilers.
Interval analysis [3, 13] deconstructs the CFG into nested
regions called intervals. The nesting structure of these regions
helps to speed up data-ﬂow analysis. Structural analysis [34] is
a reﬁned form of interval analysis that is developed to enable
the syntax-directed method of data-ﬂow analysis designed for
ASTs to be applicable on low-level intermediate code. These
algorithms are also used in the context of decompilation to
recover high-level control constructs from the CFG.
to vanilla structural analysis. The goal
Prior work on control-ﬂow structuring proposed several
enhancement
is to
recover more control structure and minimize the number
of goto statements in the decompiled code. Engel et. al.
[18] extended structural analysis to handle C-speciﬁc control
statements. They proposed a Single Entry Single Successor
(SESS) analysis as an extension to structural analysis to handle
the case of statements that exist before break and continue
statements in the loop body.
These approaches share a common property; they rely on a
predeﬁned set of region patterns to structure the CFG. For this
reason, they cannot structure arbitrary graphs without using
goto statements. Our approach is fundamentally different in
that it does not rely on any patterns.
Another related line of research lies in the area of elimi-
nating goto statements at the source code level such as [19]
and [39]. These approaches deﬁne transformations at the AST
level to replace goto statements by equivalent constructs. In
some cases, several transformations are necessary to remove a
single goto statement. These approaches increase the code
size and miss opportunities to ﬁnd more concise forms to
represent the control-ﬂow. Moreover, they may insert unneces-
sary Boolean variables. For example, these approaches cannot
ﬁnd the concise form found by DREAM for region R3 in our
running example. These algorithms do not solve the control-
ﬂow structuring problem as deﬁned in Section II-B.
Decompilers. Cifuentes laid the foundations for modern de-
compilers. In her PhD thesis [11], she presented several tech-
niques to decompile binary code into a high-level language.
13
These techniques were implemented in dcc, a decompiler for
Intel 80286/DOS to C. The structuring algorithm in dcc [12]
is based on interval analysis. She also presented four region
patterns to structure regions resulted from the short-circuit
evaluation of compound conditional expressions, e.g., x ∨ y.
Van Emmerik proposed to use the Static Single Assignment
(SSA) form for decompilation in his PhD thesis [17]. His
work demonstrates the advantages of the SSA form for several
data ﬂow components of decompilers, such as expression
propagation, identifying function signatures, and eliminating
dead code. His approach is implemented in Boomerang, an
open-source decompiler. Boomerang’s structuring algorithm is
based on parenthesis theory [35]. Although faster than interval
analysis, it recovers less structure.
Chang et. el. [9] demonstrated the possibility of applying
source-level tools to assembly code using decompilation. For
this goal, they proposed a modular decompilation architecture.
Their architecture consists of a series of decompilers connected
by intermediate languages. For their applications, no control-
ﬂow structuring is performed.
Hex-Rays is the de facto industry standard decompiler. It
is built as plugin for the Interactive Disassembler Pro (IDA).
Hex-Rays is closed source, and thus little is known about its
inner workings. It uses structural analysis [22]. As noted by
Schwartz et el. in [33], Hex-Rays seems to use an improved
version of vanilla structural analyses.
Yakdan et al. [40] developed REcompile, a decompiler
that employs interval analysis to recover control structure. The
authors also proposed node splitting to reduce the number of
goto statements. Here, nodes are split into several copies.
While this reduces the amount of goto statements, it increases
the size of decompiled output.
Phoenix is the state-of-the-art academic decompiler [33].
It
is built on top of the CMU Binary Analysis Platform
(BAP) [8]. BAP lifts sequential x86 assembly instructions
into an intermediate language called BIL. It also uses TIE
[29] to recover types from binary code. Phoenix enhances
structural analysis by employing two techniques: ﬁrst, iterative
reﬁnement chooses an edge and represents it using a goto
statement when the algorithm cannot make further progress.
This allows the algorithm to ﬁnd more structure. Second,
semantics-preserving ensures correct control structure recov-
ery. The authors proposed correctness as an important metric
to measure the performance of a decompiler.
The key property that all structuring algorithms presented
above share is the reliance on pattern matching, i.e, they use
a predeﬁned set of region schemas that are matched against
regions in the CFG. This is a key issue that prevents these
algorithms from structuring arbitrary CFGs. This leads to
unstructured decompiled output with goto statements. Our
algorithm does not rely on such patterns and is therefore able to
produce well-structured code without a single goto statement.
Binary code extraction. Correctly extracting binary code
is essential for correct decompilation. Research in this ﬁeld
is indispensable for decompilation. Kruegel et al. presented
a method [27] to disassemble x86 obfuscated code. Jakstab
[26] is a static analysis framework for binaries that follows
the paradigm of iterative disassembly. That is, it interleaves
multiple disassembly rounds with data-ﬂow analysis to achieve
accurate and complete CFG extraction. Zeng et el. presented
trace-oriented programming (TOP) [43] to reconstruct pro-
gram source code from execution traces. The executed instruc-
tions are translated into a high-level program representation
using C with templates and inlined assembly. TOP relies on
dynamic analysis and is therefore able to cope with obfuscated
binaries. With the goal of achieving high coverage, an ofﬂine
combination component combines multiple runs of the binary.
BitBlaze [37] is a binary analysis platform. The CMU Binary
Analysis Platform (BAP) [8] is successor to the binary analysis
techniques developed for Vine in the BitBlaze project.
Type recovery. Reconstructing type abstractions from binary
code is important for decompilation to produce correct and
high-quality code. This includes both elementary and complex
types. Several prominent approaches have been developed
in this ﬁeld including Howard [36], REWARDS [30], TIE
[29], and [23]. Other work [15, 20, 21, 25] focused on C++
speciﬁc issues, such as recovering C++ objects, reconstructing
class hierarchy, and resolving indirect calls resulting from
virtual inheritance. Since our work focuses on the control ﬂow
structuring we do not make a contribution to type recovery but
we based our type recovery on TIE [29].
IX. CONCLUSION
In this paper we presented the ﬁrst control-ﬂow struc-
turing algorithm that
is capable of recovering all control
structure and thus does not generate any goto statements. Our
novel algorithm combines two techniques: pattern-independent
structuring and semantics-preserving transformations. The key
property of our approach is that
it does not rely on any
patterns (region schemas). We implemented these techniques
in our DREAM decompiler and evaluated the correctness
of our control-ﬂow structuring algorithm. We also evaluated
our approach against the de facto industry standard decom-
piler, Hex-Rays, and the state-of-the-art academic decompiler,
Phoenix. Our evaluation shows that DREAM outperforms both
decompilers; it produced more compact code and recovered
the control structure of all the functions in the test without any
goto statements. We also decompiled and analyzed a number
of real-world malware samples and compared the results to
Hex-Rays. Again, DREAM performed very well, producing
goto-free and compact code compared to Hex-Rays, which
had one goto for every 32 lines of code. This represents
a signiﬁcant step forward for decompilation and malware
analysis. In future work, we will further examine the quality
of the code produced by DREAM speciﬁcally concerning the
compactness. Our experience based on the malware samples
we analyzed during the course of this paper suggests that more
compact code is better for human understanding. However, it
is conceivable that in some cases less compact code is easier
to understand. This will require further research and potential
optimization of the post-processing step.
ACKNOWLEDGEMENTS
We are grateful to Fabian Yamaguchi, the author of joern,
who was very helpful and created several patches to improve
the parsing of the coreutils. We sincerely thank Edward
J. Schwartz for sharing the Phoenix experiments results. We
14
would also like to thank the anonymous reviewers for their
valuable feedback.
REFERENCES
[1] REC Studio 4 - Reverse Engineering Compiler. http://www.backerstreet.
com/rec/rec.htm. Page checked 7/20/2014.
[2] The IDA Pro disassembler and debuger. http://www.hex-rays.com/
idapro/.
[3] F. E. Allen, “Control Flow Analysis,” in Proceedings of ACM Sympo-
sium on Compiler Optimization, 1970.
[4] D. Andriesse, C. Rossow, B. Stone-Gross, D. Plohmann, and H. Bos,
“Highly Resilient Peer-to-Peer Botnets Are Here: An Analysis of
Gameover Zeus,” in Proceedings of the 8th IEEE International Confer-
ence on Malicious and Unwanted Software (MALWARE), 2013.
[5] A. Bessey, K. Block, B. Chelf, A. Chou, B. Fulton, S. Hallem, C. Henri-
Gros, A. Kamsky, S. McPeak, and D. Engler, “A Few Billion Lines of
Code Later: Using Static Analysis to Find Bugs in the Real World,”
Communications of the ACM, vol. 53, no. 2, pp. 66–75, Feb. 2010.
[6] E. Bosman, A. Slowinska, and H. Bos, “Minemu: The World’s Fastest
Taint Tracker,” in Proceedings of the 14th International Conference on
Recent Advances in Intrusion Detection (RAID), 2011.
[7] D. Brumley, T. Chiueh, R. Johnson, H. Lin, and D. Song, “RICH:
Automatically Protecting Against Integer-Based Vulnerabilities,” in
Proceedings of
the 14th Network and Distributed System Security
Symposium (NDSS), 2007.
[8] D. Brumley, I. Jager, T. Avgerinos, and E. J. Schwartz, “BAP: A Binary
Analysis Platform,” in Proceedings of the 23rd International Conference
on Computer Aided Veriﬁcation (CAV), 2011.
[9] B.-Y. E. Chang, M. Harren, and G. C. Necula, “Analysis of Low-
level Code Using Cooperating Decompilers,” in Proceedings of the 13th
International Conference on Static Analysis (SAS), 2006.
[10] W. Chang, B. Streiff, and C. Lin, “Efﬁcient and Extensible Security
Enforcement Using Dynamic Data Flow Analysis,” in Proceedings of
the 15th ACM Conference on Computer and Communications Security
(CCS), 2008.
[11] C. Cifuentes, “Reverse Compilation Techniques,” Ph.D. dissertation,
Queensland University of Technology, 1994.
[12] ——, “Structuring Decompiled Graphs,” in Proceedings of the 6th
International Conference on Compiler Construction (CC), 1996.
J. Cocke, “Global Common Subexpression Elimination,” in Proceedings
of the ACM Symposium on Compiler Optimization, 1970.
[13]
[14] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein, Introduction
to Algorithms, 3rd ed. The MIT Press, 2009.
[15] D. Dewey and J. T. Gifﬁn, “Static detection of C++ vtable escape
vulnerabilities in binary code,” in Proceedings of the 19th Network and
Distributed System Security Symposium (NDSS), 2012.
[16] E. W. Dijkstra, “Letters to the Editor: Go to Statement Considered
Harmful,” Communications of the ACM, vol. 11, no. 3, pp. 147–148,
Mar. 1968.
[17] M. J. V. Emmerik, “Static Single Assignment for Decompilation,” Ph.D.
dissertation, University of Queensland, 2007.
[18] F. Engel, R. Leupers, G. Ascheid, M. Ferger, and M. Beemster,
“Enhanced Structural Analysis for C Code Reconstruction from IR
Code,” in Proceedings of the 14th International Workshop on Software
and Compilers for Embedded Systems (SCOPES), 2011.
[19] A. Erosa and L. J. Hendren, “Taming Control Flow: A Structured
Approach to Eliminating Goto Statements,” in Proceedings of 1994
IEEE International Conference on Computer Languages, 1994.
[20] A. Fokin, E. Derevenetc, A. Chernov, and K. Troshina, “SmartDec:
Approaching C++ Decompilation,” in Proceedings of the 2011 18th
Working Conference on Reverse Engineering (WCRE), 2011.
[21] A. Fokin, K. Troshina, and A. Chernov, “Reconstruction of Class
Hierarchies for Decompilation of C++ Programs,” in Proceedings of the
14th European Conference on Software Maintenance and Reengineering
(CSMR), 2010.
I. Guilfanov, “Decompilers and Beyond,” in Black Hat, USA, 2008.
[22]
15
[23]
[24]
I. Haller, A. Slowinska, and H. Bos, “MemPick: High-Level Data
Structure Detection in C/C++ Binaries,” in Proceedings of the 20th
Working Conference on Reverse Engineering (WCRE), 2013.
I. Haller, A. Slowinska, M. Neugschwandtner, and H. Bos, “Dowsing
for Overﬂows: A Guided Fuzzer to Find Buffer Boundary Violations,”
in Proceedings of the 22nd USENIX Security Symposium, 2013.
[25] W. Jin, C. Cohen, J. Gennari, C. Hines, S. Chaki, A. Gurﬁnkel,
J. Havrilla, and P. Narasimhan, “Recovering C++ Objects From Binaries
Using Inter-Procedural Data-Flow Analysis,” in Proceedings of ACM
SIGPLAN on Program Protection and Reverse Engineering Workshop
(PPREW), 2014.
J. Kinder and H. Veith, “Jakstab: A Static Analysis Platform for
Binaries,” in Proceedings of
the 20th International Conference on
Computer Aided Veriﬁcation (CAV), 2008.
[26]
[27] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna, “Static Disassembly
of Obfuscated Binaries,” in Proceedings of the 13th Conference on
USENIX Security Symposium, 2004.
[28] S. Kumar. DISC: Decompiler for TurboC. http://www.debugmode.com/
[29]
dcompile/disc.htm. Page checked 7/20/2014.
J. Lee, T. Avgerinos, and D. Brumley, “TIE: Principled Reverse En-
gineering of Types in Binary Programs,” in Proceedings of the 18th
Network and Distributed System Security Symposium (NDSS), 2011.
[30] Z. Lin, X. Zhang, and D. Xu, “Automatic Reverse Engineering of Data
Structures from Binary Execution,” in Proceedings of the 17th Annual
Network and Distributed System Security Symposium (NDSS), 2010.
[31] S. S. Muchnick, Advanced Compiler Design and Implementation. San
Francisco, CA, USA: Morgan Kaufmann Publishers Inc., 1997.
[32] C. Rossow, D. Andriesse, T. Werner, B. Stone-Gross, D. Plohmann,
C. J. Dietrich, and H. Bos, “P2PWNED: Modeling and Evaluating the
Resilience of Peer-to-Peer Botnets,” in Proceedings of the 34th IEEE
Symposium on Security and Privacy (S&P), 2013.
[33] E. J. Schwartz, J. Lee, M. Woo, and D. Brumley, “Native x86 Decom-
pilation using Semantics-Preserving Structural Analysis and Iterative
Control-Flow Structuring,” in Proceedings of the 22nd USENIX Security
Symposium, 2013.
[34] M. Sharir, “Structural Analysis: A New Approach to Flow Analysis
in Optimizing Compilers,” Computer Languages, vol. 5, no. 3-4, pp.
141–153, Jan. 1980.
[35] D. Simon, “Structuring Assembly Programs,” Honours thesis, Univer-
sity of Queensland, 1997.
[36] A. Slowinska, T. Stancescu, and H. Bos, “Howard: A Dynamic Excava-
tor for Reverse Engineering Data Structures,” in Proceedings of the 18th
Annual Network and Distributed System Security Symposium (NDSS),
2011.
[37] D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager, M. G. Kang,
Z. Liang, J. Newsome, P. Poosankam, and P. Saxena, “BitBlaze: A New
Approach to Computer Security via Binary Analysis,” in Proceedings
of the 4th International Conference on Information Systems Security
(ICISS), 2008.
[38] X. Wang, H. Chen, Z. Jia, N. Zeldovich, and M. F. Kaashoek, “Improv-
ing Integer Security for Systems with KINT,” in Proceedings of the 10th
USENIX Conference on Operating Systems Design and Implementation
(OSDI), 2012.
[39] M. H. Williams and G. Chen, “Restructuring Pascal Programs Contain-
ing Goto Statements,” The Computer Journal, 1985.
[40] K. Yakdan, S. Eschweiler, and E. Gerhards-Padilla, “REcompile: A De-
compilation Framework for Static Analysis of Binaries,” in Proceedings
of the 8th IEEE International Conference on Malicious and Unwanted
Software (MALWARE), 2013.
[41] F. Yamaguchi, N. Golde, D. Arp, and K. Rieck, “Modeling and
Discovering Vulnerabilities with Code Property Graphs,” in Proceedings
of the 35th IEEE Symposium on Security and Privacy (S&P), 2014.
[42] F. Yamaguchi, C. Wressnegger, H. Gascon, and K. Rieck, “Chucky:
Exposing Missing Checks in Source Code for Vulnerability Discov-
ery,” in Proceedings of the 20th ACM Conference on Computer and
Communications Security (CCS), 2013.
J. Zeng, Y. Fu, K. A. Miller, Z. Lin, X. Zhang, and D. Xu, “Obfuscation
Resilient Binary Code Reuse Through Trace-oriented Programming,” in
Proceedings of the 20th ACM Conference on Computer and Communi-
cations Security (CCS), 2013.
[43]