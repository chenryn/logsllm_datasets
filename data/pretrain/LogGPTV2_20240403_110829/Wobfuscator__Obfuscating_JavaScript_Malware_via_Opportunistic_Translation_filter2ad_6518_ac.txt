[24], [17]. To evade detection, we remove suspicious function
names from the JavaScript code through a transformation rule
T3-FunctionName (LT 3, pT 3, tT 3) where:
LT 3. T3 may apply on CallExpression nodes or NewExpres-
sion nodes that contain specific identifier names.
tT 3. The transformation function is defined in row T3-
FunctionName in Table I. To obfuscate the function name
eval, tT 3 removes the function name from JavaScript and
stores it in WebAssembly linear memory. In the WebAssembly
code, a global variable $d1 is defined and exported with a
value of 0 (line 1), which is the starting index of the function
name “eval” stored in the linear memory. Next, a memory is
created and exported (line 2). To initialize the linear memory,
a data section is defined that contains “eval” at offset 0
(line 3). In the transformed JavaScript code, it instantiates
a WebAssembly module (line 2) and defines a variable to
access the linear memory (line 3). The variable startInd
is assigned the value of the exported d1 that contains the
starting index of “eval” in the linear memory (line 5). Finally,
loadStrFromBuf is used to create the string “eval”, and
eval is called from the window object with str, the same
argument used in the original eval() (line 6).
pT 3. This transformation can be applied to call expressions
or new expressions referencing global functions accessible
through the window object. Specifically, we identify eight
global functions commonly used in malicious files and apply
the transformation only if the identifier is in the following list:
eval, escape, atob, btoa, WScript, unescape, escape,
Function, and ActiveXObject. While these functions are
not inherently malicious, many of the analyzed malware files
use these functions to decode and execute hidden code.
4) Obfuscating Calls: Aside from the suspicious functions,
we construct a transformation rule T4-CallExpression for
general JavaScript function calls. This transformation converts
function calls in JavaScript into a call of an exported Web-
Assembly function, which in turn performs a function call in
WebAssembly to an imported JavaScript function. Unlike T3-
FunctionName, which completely removes suspicious function
names from JavaScript, this transformation modifies the con-
text of the function being used in call sites that AST-based
malware detectors use when scanning for malicious code.
There is a trade-off in this transformation between com-
patibility with the WebAssembly Minimum Viable Product
(MVP) version and the amount of transformable function calls.
Thus, we create two variations of this transformation: T4-
CallExpression(a) is fully compatible with the WebAssem-
bly MVP (i.e., uses no language extensions) but can only
be applied on functions that do not return a value; T4-
CallExpression(b) transforms functions with return values but
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:59:50 UTC from IEEE Xplore.  Restrictions apply. 
51578
tT 4a) where:
LT 4a. LT 4a are CallExpression nodes containing the iden-
tifier and arguments of a function call.
requires the WebAssembly Reference Types proposal [9].
Firefox and Chrome enable this proposal by default.
T4-CallExpression(a) is a transformation rule (LT 4a, pT 4a,
tT 4a. tT 4a is defined in row T4-CallExpression(a) in Table I.
To obfuscate a JavaScript function call f(a), tT 4a moves the
function call into an anonymous function that is imported into
WebAssembly (line 2). At the original call site, a WebAssem-
bly export function f0 is called (line 4). In the WebAssembly
code, the function that wraps the JavaScript function call is
imported as $impFunc. The function $f0 is exported and
calls the imported function $impFunc (lines 1-2). Note that
the anonymous function used to wrap the original JavaScript
function always has the same type signature,
i.e., a void
function with no parameters. Thus, the same WebAssembly
module can be compiled once and reused for every replaced
function call, changing only the import object containing the
appropriate JavaScript function.
pT 4a. This transformation can be applied to locations where
the call expressions do not have a return value that is used in
an assignment or in another expression, as the primitive data
types of WebAssembly, i32, i64, f32, f64 cannot represent
all possible JavaScript function return values.
The generalized variant T4-CallExpression(b) is a transfor-
mation rule (LT 4b, pT 4b, tT 4b) where:
LT 4b. LT 4b is the same as LT 4a.
tT 4b. tT 4b is defined in row T4-CallExpression(b) in Table I.
The experimental WebAssembly Reference Types proposal [9]
adds a new WebAssembly value type, externref, that can be
used to pass references of arbitrary JavaScript values to and
from WebAssembly. With this new type, the transformation
only needs to import a reference to the transformed function.
Specifically,
the transformed JavaScript code only imports
the function reference f into WebAssembly (line 2). In the
original call expression, the function f is replaced with a
WebAssembly export function f0 that takes in the argument
a of the original call and returns any value that the original
function outputs (line 4). In the WebAssembly code, the export
function $f0 takes in a parameter of type externref and
returns a value of type externref (line 1). Inside $f0, it
calls the imported function $impFunc with a value that is
the argument passed into $f0 (lines 2-3). The benefits of
this transformation over T 4a include supporting more function
calls by including those with return values and moving more
behavior into WebAssembly than T 4a.
pT 4b. This variant of the call transformation can be applied
only if: (i) the callee function does not contain a reference
to this; (ii) the arguments of the call expression cannot
contain a reference to this; (iii) the data dependencies of the
variables referenced within the callee cannot contain this;
(iv) the callee function is not a method of a literal value; and
(v) the callee function is not the special functions bind or
super. Conditions (i)-(iv) must be met because the value of
this is changed when calling the function from within the
WebAssembly module, which can lead to incorrect behavior.
Condition (v) is needed as bind and super have restrictions
on how they are called, so these functions cannot be passed
as imports to the WebAssembly module.
5) Obfuscating If Statements: By leveraging the control-
flow instructions in WebAssembly, the behavior of if-else
statements in JavaScript can be moved to WebAssembly,
removing the syntactic information while preserving the se-
transformation rule T5-
mantics. To this end, we present
IfStatement (LT 5, pT 5, tT 5) where:
LT 5. The transformation rule applies to IfStatement nodes.
tT 5. The transformation is defined in row T5-IfStatement
in Table I. At the translation site, tT 5 wraps the code within
the if- and else-blocks in two anonymous functions that
are imported into the WebAssembly module (lines 2-4). A
WebAssembly export function f is called and the result of the
test condition of the original if-statement is converted to a
(zero or one) integer that is passed as the argument to f (line
6). Within the WebAssembly module, the two functions wrap-
ping the code within the if- and else-blocks are imported as
$imp1 and $imp2 (lines 4,6). The exported function $f takes
in an integer parameter which will be either zero or one to act
as a Boolean (lines 1-7). $f contains if-else instructions that
are decided by the function parameter p. If p is non-zero, the
if instruction calls $imp1 that contains the code originally in
the if-block. Similarly, if p is zero, then the else instruction
calls $imp2 containing the code originally in the else-block.
By leveraging the if-else instructions in WebAssembly, the
original semantics are preserved while the use of the control-
flow statement is hidden from the JavaScript syntax.
pT 5. The if statements can be transformed if the code
include the keywords break, continue,
blocks do not
return, yield, or throw. These keywords are not compati-
ble with moving the inner code blocks into functions.
6) Obfuscating For Loops: To obfuscate for loops, we
define transformation rule T6-ForStatement (LT 6, pT 6, tT 6):
LT 6. The transformation locations where this rule applies
are ForStatement nodes, which represent C-style for loops.
tT 6. The transformation is defined in row T6-ForStatement
in Table I. At the translation site, tT 6 wraps the loop condition,
increment and body in three JavaScript functions that will be
imported to the WebAssembly module (lines 3-8). The loop
counter initialization can be hoisted out of the loop scope
safely (line 2). Finally, a WebAssembly export function f is
called which emulates the JavaScript for loop (line 11). In
the WebAssembly module, the three JavaScript functions that
are used to wrap the loop condition, increment, and body are
imported as $cond, $body, and $incre, respectively (lines
4, 7, 8). The export function $f contains a block of code
with label $L0, which encloses a loop block with label $L1
(lines 2-3). Inside the loop, $cond is called (line 4) which
evaluates the test condition of the JavaScript for loop and the
result is checked using i32.eqz (line 5). If the test condition
is false, the instruction br_if $L0 branches out to the end
of block $L0, terminating the loop (line 6). Otherwise, if the
test condition is true, functions $body and $incre are called
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:59:50 UTC from IEEE Xplore.  Restrictions apply. 
61579
to execute the statements within the loop body and the update
expression (lines 7-8). The br $L1 is used to branch to label
$L1, which continues iteration (line 9).
pT 6. The precondition is the same as pT 5.
7) Obfuscating While Loops: Analogous to the above,
we obfuscate while loops with a transformation rule T7-
WhileStatement (LT 7, pT 7, tT 7) where:
LT 7. The rule applies to WhileStatement nodes.
tT 7. The transformation, defined in row T7-WhileStatement
in Table I, is similar to tT 6. The only differences are that in
tT 7, there is no loop increment nor loop counter initialization.
A while loop can be created by only wrapping the loop
condition and the loop body into anonymous functions and
importing them to WebAssembly (lines 4, 7). The function $f
is defined and exported, which emulates the JavaScript while
loop by calling the import functions within the loop block.
pT 7. The precondition is the same as pT 5 and pT 6.
C. Synchronous and Asynchronous WebAssembly Instantiation
For each transformation rule in Section IV-B (aside from
T4-CallExpression(b)), we develop two variants differing
in whether they instantiate the WebAssembly module syn-
chronously or asynchronously, i.e., the implementation of the
instanWasm() primitive.
1 let m = new WebAssembly.Module(
2
3 return new WebAssembly.Instance(m, impObj);
new Uint8Array(decodeBase64('...')));
Fig. 2. Synchronous WebAssembly instantiation.
The synchronous variants implement the primitive by using
the WebAssembly.Module and WebAssembly.Instance
constructor functions. Figure 2 shows the code, where in line
1, variable m is set to the compiled WebAssembly.Module ob-
ject. The WebAssembly.Module constructor accepts a typed
array containing the module bytes. Hence, we encode the
module bytes into a base64 string, which is decoded to a
typed Uint8Array at runtime (line 2). On line 3, the module
object m, along with the import object, is then passed into the
WebAssembly.Instance constructor. The returned instance
object can be utilized by the transformation functions.
is
standard,
Since this
synchronous code,
there are
no restrictions on how to integrate
instantiation into
the original JavaScript application. However, because the
WebAssembly.Module constructor can block the JavaScript
main thread, browser vendors discourage this method.
Chromium in particular even limits the input module to at
most 4KB in size [6] and throws an exception otherwise.
To get around this limitation, each synchronous trans-
formation can emit one or more WebAssembly mod-
ules. Specifically,
transformations T3-FunctionName, T4-
CallExpression(a), T5-IfStatement, T6-ForStatement, and T7-
WhileStatement only emit one WebAssembly module per file
transformed. T1-StringLiteral, T2-ArrayInitialization, and T4-
CallExpression(b) can emit one or more modules since the
data stored within the modules can grow larger than 4KB.
When a single WebAssembly module grows too large, e.g.,
because it contains many string literals in its data section, we
split it into multiple modules to keep each under 4KB. For
string literals larger than 4KB, the string literal is split across
multiple modules and joined in the string reconstruction phase.
// Transformation site: ...
await (async () => {
let mod = await WebAssembly.instantiateStreaming(
1 async function someFunction(){
2
3
4
5
6
7
8 }
//Transformation function code...
})()
fetch("generated_module.wasm"), impObj);
Fig. 3.
Instantiation of the asynchronous variant.
We also support asynchronous instantiation of the Web-
Assembly modules, which is
the method that browser
providers recommend. Asynchronous instantiation has several
benefits, including unrestricted module size and the ability
to put the generated WebAssembly modules in separate files.
These benefits allow each transformation to only emit a single
WebAssembly module.
For these variants, the instanWasm() primitive is imple-
mented via the WebAssembly.instantiateStreaming()
function, as shown in Figure 3 (line 4). This API spawns
compilation on a separate thread, thus not blocking the main
thread of execution. Since this API returns a Promise, we need
to add the await keyword to allow the Promise to resolve
before continuing. Line 6 represents a placeholder for the
transformation code of T1-T7. The await keyword can only
be employed in asynchronous functions, so we wrap the in-
stantiation in an async anonymous function (line 3). Similarly,
since the anonymous function is an async function, its invo-
cation must also have the await keyword added (line 3). The
enclosing function, someFunction, now contains the await
keyword, so the function definition must have the async
keyword added (line 1). Elsewhere in the code, any function
calls to someFunction would also require adding the await
keyword. As this example shows, inserting the async/await
keywords to a translation site causes these keywords to be
propagated to functions and call sites throughout the file.
This keyword propagation makes the asynchronous transfor-
mations non-trivial to design and implement. Specifically, we
encountered three code locations that are difficult to propagate
the async/await keywords to. First, anonymous functions
used as parameters in other function calls, e.g., .map, are
difficult
to handle. Depending on the return type of the
anonymous function, the await keyword may need to be
added within the called function’s definition or to the function
invocation. Second, class constructors cannot be made async,
so a check must be done to detect if a constructor is in the
call chain of any function. Third, if a transformed function is
exported from a module, any other files using the function as
an import must be checked for functions and function calls to
add async and await to.
All of the transformation rules have both synchronous
and asynchronous variants except for T4-CallExpression(b).
T4-CallExpression(b) relies on an experimental WebAssem-
bly proposal
imposes complex preconditions. Adding
that
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:59:50 UTC from IEEE Xplore.  Restrictions apply. 
71580
the asynchronous restrictions to this may break the orig-
inal semantics and lead to incorrect
transformations. T4-
CallExpression(b) exposes more translation sites than T4-
CallExpression(a), increasing the number of edge cases that
can be encountered. We leave this combination as future work.
D. Applying Transformations
We now present the overall algorithm for applying these
transformations to a given JavaScript AST. The input to the
algorithm is a list of transformation rules and the AST of
the original JavaScript file. The algorithm consists of three
steps: (a) Identifying AST nodes where transformations should
be applied, i.e., translation sites; (b) rewriting the AST by
modifying the subtrees rooted at the translation sites; and (c)
adding code to the AST root to instantiate the generated Web-
Assembly modules. The algorithm outputs the transformed
AST corresponding to the obfuscated JavaScript code.
a) Identifying AST Nodes as Translation Sites: To iden-
tify translation sites, we perform a pre-order traversal of the
AST starting at
the root node. For each visited node n,
the algorithm iterates through the list of transformation rules
and checks which rules are applicable. A transformation rule
(L, t, p) is applicable if the node n is in the set L of code
locations and if the precondition p holds for n. A set of
translation site nodes is produced for each transformation rule.
b) Rewriting AST Subtrees: After identifying all transla-
tion site nodes, the next step is to rewrite the subtrees rooted at
these nodes. The algorithm applies transformations based on
the size of the syntactic structures they target. Specifically,
we iterate through the transformation rules in this order,
applying each rule to all applicable subtrees before moving
on to the next rule: T1-StringLiteral, T2-ArrayInitialization,
T3-FunctionName, T4-CallExpression, T5-IfStatement, T6-
ForStatement, T7-WhileStatement. This ordering ensures that
transformations targeting finer-grained syntactic structures,
such as string and array literals, are performed prior to trans-
formations targeting coarser-grained structures, such as loops.
If more coarse-grained transformation were applied first, the
change could prevent more fine-grained transformations from
being applied. For each rule (L, t, p), the algorithm visits all
translation site nodes and applies the transformation function
t, which modifies the AST in-place and yields a WebAssembly
module used in the rewritten code. The output of this step is
the rewritten AST and a set W of WebAssembly modules.
c) Adding WebAssembly Instantiation Code: The final
step is adding code to instantiate the WebAssembly modules
W . To this end, the algorithm inserts statements at the begin-
ning of the script, i.e., at the root of the AST. For modules
that are instantiated synchronously, we encode each module
in W as a base64 string and add statements that decode
and instantiate the modules. For asynchronously instantiated
modules, we serialize the modules to separate files and issue
corresponding fetch requests in the code. For asynchronous
translations, the algorithm additionally adds the async wrapper
(described in Section IV-A) around the root of the AST to
support asynchronous keywords in the remainder of the code.
V. IMPLEMENTATION
The
data
We implement Wobfuscator with Node.js (v14.17.2) and
TypeScript. The tool relies on the Esprima (v4.0.1) [3] and
Espree (v7.3.1) [2] packages to parse the JavaScript files and
on Escodegen (2.0.0) [1] to convert the transformed AST back