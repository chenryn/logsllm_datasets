In
this case, the malware is most likely to attempt to sub-
scribe to some premium service covertly. We also ob-
served malware NickySpy [3] leaking device IMEI via
SMS in another test run. We believe automatic classiﬁ-
cation on SMS number and content is possible to further
reduce user intervention.
2.3.3 Network Policy
Similarly to the privacy policies, we enforce a set of net-
work policies that regulate how an application is allowed
to interact with the network. Since the Android permis-
sion scheme allows unrestricted access to the Internet
when an application is installed, we enforce ﬁner-grained
Knowing the attack signatures based on suspicious ex-
ecutables can prevent certain types of escalation of priv-
ilege attacks. Figure 7 illustrates an interception of the
su command. The Aurasium warning indicates that the
application is trying to gain root access on a potentially
rooted phone by executing the su command.
In another scenario, Aurasium warns the user when the
application is about to load a native library. Malicious
native code can interfere with Aurasium and potentially
break out of its sandbox, which we discuss further in sec-
tion 4.
Figure 7: Enforcement of Privilege Escalation Policy
2.3.5 Automatic Embedding of policies
Our implementation allows us to naturally compare the
behavior of an application against a policy expressed not
as a single event such as a single access to private data, to
a system service or a single invocation of a system call,
but as a sequence of such events. We plan on automat-
ically embedding into an application code an arbitrary
user-deﬁned policy expressible in an automaton.
2.4 Deployment Models
Driven by the need for deployable mobile security solu-
tions for Android and other platforms, we support mul-
tiple deployment models for Aurasium. The unrestricted
and open nature of the Android Market allows us to
provide Aurasium hardened and repackaged applications
to users directly. Here, we discuss several deployment
models for Aurasium that users can directly use without
modifying the Android OS on their phones.
2.4.1 Web Interface
We have a web interface6 that allows users to upload ar-
bitrary applications and download the Aurasium repack-
aged and hardened version. Aurasium can be employed
to repackage any APKs that the user possesses.
6www.aurasium.com
8
Figure 5: Enforcement of SMS Sending
policies that are expressed as a combination of the fol-
lowing:
• restrict the application to only a particular web do-
main or set of IP addresses
• restrict the application from connecting to a remote
IP address known to be malicious
Figure 6: Enforcement of Network Policies: Access to
an IP address with an unveriﬁed level of maliciousness
We use an IP blacklisting provided by the Bothunter
network monitoring tool [4] to harvest information about
malicious IP addresses. For each connection, the service
retrieves information about the remote location, and the
warning presented to the user indicates the level of ma-
liciousness of the remote location (Figure 6). We also
display the geo-location of the remote IP. It would be
possible to include more threat intelligence from various
diverse sources.
2.3.4 Privilege Escalation Policy
In addition to the privacy policy and the network policy,
we implement a policy that warns the user when a suspi-
cious execvp is invoked. Aurasium intervenes whenever
the application tries to execute external ELF binaries.
2.4.2 Cooperation with Application Markets
We are exploring collaborations with Android markets
run by mobile service providers to deploy Aurasium.
Subscribers to the mobile service who get their applica-
tions from the ofﬁcial Android market supported by the
mobile provider will have all their applications packaged
with Aurasium for protection.
2.4.3 Deployment in the Cloud
Another deployment model consists of writing a custom
download application that runs on a user’s phone so that
whenever a user browses an Android market and wishes
to download an application, the application is pulled and
sent to the Aurasium cloud service where the application
is repackaged and then downloaded to the user’s phone.
This may be more accessible as users no longer need to
interact with Aurasium’s web interface manually.
2.4.4 Phone Deployment
Similarly to the cloud service, we plan on porting the
repackaging tool to the Android phone itself. That is, we
will be able to repackage an application on the device
itself.
2.4.5 Corporate Environment
Many corporations have security concerns about mobile
devices in their infrastructure and Aurasium can help to
establish the desired security and privacy polices on ap-
plications to be installed on these devices. These An-
droid devices should be conﬁgured to allow installing
only Aurasium-protected applications (by means of APK
signatures for example), while the applications can be
provided by some methods described above, such as an
internal repackaging service or a transparent repackaging
proxy between the application market and the device.
3 Evaluation
We have evaluated Aurasium on a collection of Android
applications to ensure that the application repackaging
succeeds and that our added code does not impede the
original functionality of the application. We have con-
ducted a broad evaluation that includes a large number of
benign applications as well as malware collection. Our
evaluation was conducted on a Samsung Nexus S phone
running Android 2.3.6 “Gingerbread”.
3.1 Setting Up An Evaluation Framework
Aurasium consists of scripts that implement the repack-
aging process described in Figure 2. It transforms each
APK ﬁle in the corpus to the corresponding hardened
repackaged application. We scripted to load the applica-
tion onto the Nexus S phone, start the application auto-
matically, and capture the logs generated by Aurasium.
Android Monkey [8] is used to randomly exercise the
user interface (UI) of the application.
Monkey is a program running on Android that feeds
the application with pseudo-random streams of user
events such as clicks and touches, as well as a number
of system-level events. We use Monkey to stress-test the
repackaged applications in a random yet repeatable man-
ner. The captured logs allow us to determine whether the
application has started and is being executed normally or
whether it crashes due to our repackaging process. As a
random fuzzer, Monkey is fundamentally unable to ex-
ercise all execution paths of an application. But in our
setup, running random testing over a large number of in-
dependent applications proves useful, covering most of
Aurasium’s policy logic and revealing several bugs.
3.2 Repackaging Evaluation
We ﬁrst performed an evaluation to determine how many
APK ﬁles can successfully be repackaged by Aurasium.
Table 1 shows a breakdown of the Android APK ﬁles cor-
pus on which we ran our evaluation. We applied Aura-
sium to 3491 applications crawled from a third-party
application store7 and 1260 known malicious applica-
tions [39]. Table 1 shows the success rate of repackaging
for each category of applications.
Type of App
#of Apps Repackaging Success
Rate
App store corpus
Malware corpus
3491
1260
99.6%(3476)
99.8%(1258)
Table 1: Repackaging Evaluation Results
We have a near 100% success rate in repackaging ar-
bitrary applications. Our failures to repackage an appli-
cation are due to bugs in apktool in disassembling and
reassembling the hardened APK ﬁle. We are working on
improving apktool to achieve a 100% success rate.
3.3 Runtime Robustness
As we pointed out earlier, Aurasium is able to run on
all major Android versions (2.2, 2.3, 3.x) without any
problem. We performed the robustness evaluation on a
Samsung Nexus S phone running Android 2.3.6 (which
is among the most widely used Android distributions
7http://lisvid.com
9
2.3.3 − 2.3.7 [10]). For each hardened application we
use Monkey to exercise the application’s functionalities
by injecting 500 random UI events. These hardened ap-
plications are built with a debug version of Aurasium
that will output a log message when Aurasium success-
fully intercepts an API invocation. Out of 3476 suc-
cessfully repackaged application, we performed tests on
3189 standalone runnable applications8 on the device.
We were able to start all of the applications in the sense
that Aurasium successfully reported the interception of
the ﬁrst API invocation for all of them.
3.4 Performance Evaluation
We take two Android benchmark applications from the
ofﬁcial market and apply Aurasium to them in order to
check if Aurasium introduces signiﬁcant performance
overhead to a real-world application. In both cases, the
benchmark scores turn out to be largely unaffected by
Aurasium (Table 2).
Benchmark App
AnTuTu Benchmark
BenchmarkPi
with
without
Aurasium Aurasium
2892 Pts
2900 Pts
1280 ms
1293 ms
Table 2: Performance on Benchmark Applications
Aurasium introduces the most overhead when the ap-
plication performs API invocations, which is not the
most important test factor of these benchmarks. So we
synthesized an artiﬁcial application that performs a large
number of API invocations, in order to ﬁnd Aurasium’s
performance overhead in the worst cases. Because these
APIs all involve IPC with remote system services, they
are expected to induce the most overhead as Aurasium
needs to fully parse the Binder communication. Results
in Table 3 show that Aurasium introduces an overhead
of 14% to 35% in three cases, which we believe is ac-
ceptable as IPC-based APIs are not frequently used by
normal applications to become the performance bottle-
neck.
In objective testing we did not feel any lagging
when playing with an Aurasium-hardened application.
3.5 Size Overhead
We evaluated application size after being repackaged
with Aurasium code, as shown in Figure 8. On aver-
age, Aurasium increases the application size by only 52
8The rest are applications that do not have a main launchable Activ-
ity, and applications that fail to install due to clashes with pre-installed
version.
200 API
Invocations
Get Device Info
Get Last Location
Query Contact List
With
Without
Aurasium Aurasium
143 ms
106 ms
41 ms
55 ms
1340 ms
1270 ms
Overhead
35%
34%
14%
Table 3: Performance on Synthesized Application
Kb, which is a very small overhead for the majority of
applications.
Figure 8: Application Size Increase After Repackaging.
3.6 Policies Enforcement
We observe the various behaviors intercepted from the
3031 runnable applications that were previously repack-
aged and run on the Nexus S device under Monkey. Table
4 shows a breakdown of the application corpus into per-
mission requested in the manifest ﬁle of the applications.
It also shows which applications actually make use of the
permission to access the requested service.
Permission
Internet Permission
GPS Permission
Phone State Permission
Requested Accessed
2686
846
1243
1305
132
378
Table 4: Permission Requested and Permissions Used
Due to the random fuzzing nature of our evaluation,
10
Size Increase After Repackaging / KbNo. of Apps20406080100120140020406080Mean:  52.2the accessed permission is most likely to be an underes-
timate. We also observed that 226 applications included
native code libraries in their application bundle.
4 Attack Surfaces
Because fundamentally Aurasium code runs in the same
process context as the application’s code, there is no
strong barrier between the application and Aurasium.
Hence, it is non-trivial to argue that Aurasium can re-
liably sandbox arbitrary Android applications. We de-
scribe possible ways that a malicious application can
break out of Aurasium’s policy enforcement mechanism
and discuss possible mitigation against them.
4.1 Native Code
Aurasium relies on being able to intercept calls to Bionic
libc functions by means of rewriting function pointers
in a module’s global offset table. This is robust against
arbitrary Java code, but a malicious application can em-
ploy native code to bypass Aurasium completely either
by restoring the global offset table entries, by making
relevant system calls using its own libc implementation
rather than going through the monitored libc, or by tam-
pering with the code or private data of Aurasium. How-
ever, because Android runtime requires applications to
bootstrap as Java classes, the ﬁrst load of native code
in even malicious applications has to go through a well-
deﬁned and ﬁxed pathway as deﬁned by JNI. This gives
us an upper hand in dealing with potential untrusted na-
tive code: because of the way our repackaging process
works, Aurasium is guaranteed to start before the appli-
cation’s code and hence be able to intercept the applica-
tion’s ﬁrst attempt to load alien native code (invocation
of dlopen() function in libc). As a result, Aurasium
is guaranteed to detect any potential circumvention at-
tempts by a malicious application.
What can Aurasium do with such an attempt? Silently
denying the load of all native code is not satisfactory be-
cause it will guarantee an application crash and some
legitimate applications use native code. Even though
Aurasium has the power to switch off the unknown na-
tive code, the collateral damage caused by false positives
would be too severe.
If Aurasium is to give binary decisions on whether or
not to load some unknown native code, then it reduces
to the arms race between malware and antivirus software
that we have seen for years. Aurasium tries to classify
native code in Android applications, while malware au-
thors craft and obfuscate it to avoid being detected. It is
better not to go down the same road; and a much neater
approach would be letting the native code run, but not
with unlimited power.
Previous work [28, 40, 34] on securely executing un-
trusted native code provides useful directions for exam-
ple, by using dynamic binary translation.
In our sce-
nario we are required to restrict the application’s native
code from writing to guarded memory locations (to pre-
vent tampering with Aurasium and the libc interposition
mechanism), using special machine instructions (to ini-
tiate system calls without going through libc), and per-
forming arbitrary control ﬂow transfer into libc. Due to
time constraints we have not implemented such facilities
in Aurasium. Currently, Aurasium prompts the user for
a decision, and informs the user that if the load is al-
lowed then Aurasium can be rendered ineffective from
this point onwards. We consider this problem a high pri-
ority for future work.
Unlike the ﬁltering-based hybrid sandboxes that are
prone to the ‘time of check/time of use’ race condi-
tions [25, 38], Aurasium’s sandboxing mechanism is del-
egation based and hence much easier to defend against
this class of attack.
Java Code
4.2
A possible attack on Aurasium would be using Java’s
reﬂection mechanism to interfere with the operation of
Aurasium. Because currently Aurasium’s policy en-
forcement logic is implemented in Java, a malicious ap-
plication can use reﬂection to modify Aurasium’s inter-
nal data structures and hence affect its correct behavior.
We prevent such attacks by hooking into the reﬂection
APIs in libdvm.so and preventing reﬂection access to
Aurasium’s internal classes.