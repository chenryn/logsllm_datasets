### 2.3.3 Network Policy

Similar to privacy policies, we enforce a set of network policies that regulate how an application can interact with the network. Since the Android permission scheme allows unrestricted internet access when an application is installed, we implement finer-grained controls. These policies can include:

- Restricting the application to specific web domains or IP addresses.
- Preventing the application from connecting to known malicious IP addresses.

We use IP blacklisting provided by the Bothunter network monitoring tool [4] to gather information about malicious IP addresses. For each connection, the service retrieves details about the remote location and presents a warning to the user indicating the level of maliciousness (Figure 6). We also display the geolocation of the remote IP. Integrating more threat intelligence from diverse sources could further enhance this feature.

### 2.3.4 Privilege Escalation Policy

In addition to privacy and network policies, we implement a policy that alerts the user when a suspicious `execvp` command is invoked. Aurasium intervenes whenever the application attempts to execute external ELF binaries. This helps prevent privilege escalation attacks. For example, Figure 7 illustrates an interception of the `su` command, where Aurasium warns the user that the application is trying to gain root access on a potentially rooted phone.

### 2.3.5 Automatic Embedding of Policies

Our implementation allows us to compare an application's behavior against a policy expressed as a sequence of events, rather than a single event such as a single access to private data, a system service, or a system call. We plan to automatically embed arbitrary user-defined policies, expressible in an automaton, into the application code.

### 2.4 Deployment Models

To provide deployable mobile security solutions for Android and other platforms, Aurasium supports multiple deployment models. The open nature of the Android Market allows us to provide hardened and repackaged applications directly to users without modifying their Android OS. Here are several deployment models:

#### 2.4.1 Web Interface

We offer a web interface [www.aurasium.com](http://www.aurasium.com) where users can upload any application and download the Aurasium-repackaged and hardened version. This interface can be used to repackage any APKs the user possesses.

#### 2.4.2 Cooperation with Application Markets

We are exploring collaborations with Android markets run by mobile service providers to deploy Aurasium. Subscribers who get their applications from the official Android market supported by the mobile provider will have all their applications packaged with Aurasium for protection.

#### 2.4.3 Deployment in the Cloud

Another deployment model involves a custom download application running on the user’s phone. When a user browses an Android market and wishes to download an application, the application is pulled and sent to the Aurasium cloud service for repackaging before being downloaded to the user’s phone. This model reduces the need for users to interact with Aurasium’s web interface manually.

#### 2.4.4 Phone Deployment

We plan to port the repackaging tool to the Android phone itself, allowing applications to be repackaged directly on the device.

#### 2.4.5 Corporate Environment

Aurasium can help corporations establish desired security and privacy policies for applications installed on their devices. Android devices should be configured to allow only Aurasium-protected applications, which can be provided through internal repackaging services or a transparent repackaging proxy between the application market and the device.

### 3 Evaluation

We evaluated Aurasium on a collection of Android applications to ensure successful repackaging and to verify that our added code does not impede the original functionality. Our evaluation included both benign and malicious applications, conducted on a Samsung Nexus S phone running Android 2.3.6 "Gingerbread."

#### 3.1 Setting Up an Evaluation Framework

Aurasium uses scripts to transform each APK file into a hardened, repackaged application. We scripted the process to load the application onto the Nexus S phone, start it automatically, and capture logs generated by Aurasium. Android Monkey [8] was used to randomly exercise the application's user interface (UI).

Monkey feeds the application with pseudo-random streams of user events and system-level events, stress-testing the repackaged applications in a random yet repeatable manner. The captured logs help determine whether the application starts and runs normally or crashes due to the repackaging process.

#### 3.2 Repackaging Evaluation

We evaluated the success rate of repackaging 3491 applications from a third-party store and 1260 known malicious applications [39]. The results are shown in Table 1.

| Type of App | # of Apps | Repackaging Success Rate |
|------------|-----------|--------------------------|
| App store corpus | 3491 | 99.6% (3476) |
| Malware corpus | 1260 | 99.8% (1258) |

We achieved a near 100% success rate in repackaging, with failures due to bugs in apktool. We are working to improve apktool to achieve a 100% success rate.

#### 3.3 Runtime Robustness

Aurasium runs on major Android versions (2.2, 2.3, 3.x) without issues. We performed robustness tests on a Samsung Nexus S phone running Android 2.3.6. For each hardened application, we used Monkey to inject 500 random UI events. Out of 3476 successfully repackaged applications, we tested 3189 standalone runnable applications on the device. All applications started successfully, with Aurasium reporting the interception of the first API invocation.

#### 3.4 Performance Evaluation

We applied Aurasium to two benchmark applications from the official market to check for performance overhead. The results in Table 2 show that Aurasium did not significantly affect the benchmark scores.

| Benchmark App | with Aurasium | without Aurasium |
|---------------|---------------|-------------------|
| AnTuTu Benchmark | 2892 Pts | 2900 Pts |
| BenchmarkPi | 1280 ms | 1293 ms |

To find the worst-case performance overhead, we synthesized an application that performs a large number of API invocations. Results in Table 3 show that Aurasium introduces an overhead of 14% to 35% in three cases, which is acceptable since IPC-based APIs are not frequently used by normal applications.

| API Invocation | with Aurasium | without Aurasium | Overhead |
|----------------|---------------|-------------------|----------|
| Get Device Info | 143 ms | 106 ms | 35% |
| Get Last Location | 41 ms | 55 ms | 34% |
| Query Contact List | 1340 ms | 1270 ms | 14% |

#### 3.5 Size Overhead

Repackaging with Aurasium increases the application size by an average of 52 KB, a small overhead for most applications (Figure 8).

#### 3.6 Policy Enforcement

We observed various behaviors intercepted from 3031 runnable applications. Table 4 shows a breakdown of the permissions requested and accessed in the manifest files of the applications.

| Permission | Requested | Accessed |
|------------|-----------|----------|
| Internet Permission | 2686 | 1305 |
| GPS Permission | 846 | 132 |
| Phone State Permission | 1243 | 378 |

Due to the random fuzzing nature of our evaluation, the accessed permissions are likely underestimated. We also observed that 226 applications included native code libraries.

### 4 Attack Surfaces

Since Aurasium code runs in the same process context as the application, there is no strong barrier between them. Therefore, it is challenging to argue that Aurasium can reliably sandbox arbitrary Android applications. We describe possible attack vectors and mitigations.

#### 4.1 Native Code

Aurasium intercepts calls to Bionic libc functions by rewriting function pointers in the global offset table. This is robust against Java code, but malicious applications can bypass Aurasium using native code by restoring the global offset table entries, making system calls directly, or tampering with Aurasium's code or data.

However, because Android requires applications to bootstrap as Java classes, the first load of native code must go through a well-defined pathway defined by JNI. This allows Aurasium to intercept the first attempt to load native code (invocation of `dlopen()` in libc), ensuring detection of potential circumvention attempts.

Silently denying the load of all native code is not satisfactory as it would cause legitimate applications to crash. Aurasium currently prompts the user for a decision, informing them that allowing the load may render Aurasium ineffective. Implementing restrictions on native code, such as preventing writes to guarded memory locations and controlling flow transfers, is a high-priority future work.

Unlike filtering-based hybrid sandboxes, Aurasium's delegation-based sandboxing mechanism is less prone to 'time of check/time of use' race conditions.

#### 4.2 Java Code

A possible attack on Aurasium is using Java's reflection mechanism to interfere with its operation. Since Aurasium's policy enforcement logic is implemented in Java, a malicious application can use reflection to modify Aurasium's internal data structures. We prevent such attacks by hooking into the reflection APIs in `libdvm.so` and blocking reflection access to Aurasium's internal classes.