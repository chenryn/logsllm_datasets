p
p
Detection Result
p
p
p
p
p
p
p
p
p
p
p
p
Figure 12: The Screenshot of the hidden process detection.
be e(cid:11)ective in detecting them. We will discuss the detection
of the most classical rootkit adore-ng in details, and show
the detection results of all the rootkits in a table. The sec-
ond set of experiments is to evaluate DeepScanner’s ability
against evasion attacks. We develop an experimental rootkit
for evasion attacks based on adore-ng rootkit. The results
show that it could not evade DeepScanner without breaking
the normal functions of target objects and the system.
We perform our experiments in two versions of Linux k-
ernel (2.4.18 and 2.6.9) in order to test our approach with
more available rootkits. The detail con(cid:12)gurations of our
experiment environment are listed in Table 1.
5.1 Real-world Rootkits Experiments
We have evaluated DeepScanner with 7 real-world Linux
rootkits shown in Table 2. These rootkits all have the func-
tion of hiding one or more kinds of system objects, including
processes, sockets and kernel modules. The major stealth
techniques (KOH and DKOM) were covered by these rootk-
its. DeepScanner successfully detected all stealthy objects
hidden by these rootkits via scanning system kernel memo-
ry with the four invariants discussed above. The remarkable
thing is that DeepScanner’s precision is perfect, it doesn’t
produce any false negatives or false positives. In the follow-
ing, we describe in detail our experiments with a classical
rootkit.
The adore-ng rootkit infects the kernel as an LKM. It has
the function of hiding processes, sockets and kernel modules.
The stealth technique it adopts to hide processes is KOH tar-
geting kernel function pointers proc root.proc iops->readdir
and proc root inode operations->loopup. The same way it
works to hide sockets targeting the kernel function pointer
proc net->get info. In addition, adore-ng employs DKOM
technique to hide kernel modules, it unlinks the target mod-
ule from the module list maintained by Linux kernel.
We use DeepScanner to detect the objects hidden by adore-
ng rootkit. The screenshot of the hidden process detection
is shown in Figure 12. We can observe that a calculator
process (PID: 5603) is still running even though that adore-
ng rootkit hides it. It cannot be found in the result of ps
utility while we can get it from the output of DeepScanner.
According to the cross-view technique, scanner could de(cid:12)-
nitely draw a conclusion that the process with PID 5603 is
a hidden process. In DeepScanner console, hidden objects
will be shown at the top of the objects list and highlighted.
5.2 Performance
We measured two aspects of DeepScanner’s performance:
(a) detection time, i.e., the time taken to scan memory to
discover hidden objects; and (b) performance overhead, i.e.,
the overhead on the target system as a result of signature
pages protection.
225
Detection Time. DeepScanner employs a directive scan-
ning strategy. DeepScanner only fetches candidate memory
block from speci(cid:12)c parts of kernel memory space rather than
traversing the whole kernel memory byte by byte, i.e., it on-
ly checks the memory blocks in the slab list with speci(cid:12)c
item size to (cid:12)nd the socket alloc data structure, the memo-
ry blocks with 8kb-aligned start addresses to (cid:12)nd thread info
data structure, and identi(cid:12)es imported signature pages page
by page. Consequently, the scanning of DeepScanner is very
fast, the time of scanning processes, sockets and kernel mod-
ules is no more than 1 second in the experiment environment.
Performance Overhead. Before enforcing the signature
pages protection, we use Unixbench to measure the perfor-
mance of the whole system. The (cid:12)nal score is 94.2. After
install signature pages protection mechanism, the (cid:12)nal score
is reduced to 93.4 (only fell less than 1%). The performance
overhead is negligible and acceptable completely.
5.3 Experiments for Evasion Attacks
In order to evaluate the DeepScanner’s ability against eva-
sion attacks, we implement an experimental rootkit based on
adore-ng. It makes evasion attacks by modifying the (cid:12)eld-
s related to signatures. This set of experiments consists
of 4 parts. Each one attempts to evade the detection via
violating one of the four invariants used by DeepScanner.
The experiment results show that the rootkit cannot evade
DeepScanner without breaking the normal functions of tar-
get objects and the system.
1) Violation of Invariant 1.
The experimental rootkit attempts to evade hidden
socket detection by breaking the reference chain about
the socket alloc data structure. It does this via setting
any one link pointer (cid:12)eld of the chain with another
arbitrary address value to break the original reference,
i.e., (cid:12)le, f dentry, or d inode pointer is set to an acces-
sible address di(cid:11)erent from original value. After doing
this, the connection becomes unstable and broken (cid:12)-
nally.
2) Violation of Invariant 2.
The experimental rootkit attempts to evade hidden
process detection by breaking the cross-reference rela-
tionship between a task struct data structure t and a
related thread info data structure th. It does so by set-
ting either (t.thread info)->task or (th.task )->thread info
to another value. As a result, system crashes immedi-
ately.
3) Violation of Invariant 3.
Similar to 1), the experimental rootkit attempts to e-
vade hidden socket detection by breaking the reference
relationship of a socket alloc data structure sa, a relat-
ed task struct data structure t, and a related (cid:12)le data
structure f.
If it does so by pointing either socket-
related (t.(cid:12)les)->fd array[i] or (f.f dentry)->d inode
to another place, the socket will be disconnected. If
it does so by modifying the (sa.socket)->(cid:12)le pointer,
the system will crash.
the guest OS level, directly modifying the content in
a signature page will incur a segmentation fault. Fur-
thermore, the experimental rootkit also attempts to
set the signature pages to writeable by modifying the
related PTE. Under the protection of the monitor de-
ployed in XEN hypervisor, any modi(cid:12)cation towards
the protected PTE is terminated and fails.
6. LIMITATIONS AND FUTURE WORK
The fundamental limitation of our approach is that the
signatures are concluded based on the manual analysis to
kernel data structures. Although there is a small number
of desired objects need to be analyzed, it is only feasible
for an open source OS, e.g., Linux. For a closed source OS,
like Windows, we need to develop an automatic technique
for signatures generation similar to [12][16]. In the future,
we want to introduce dynamic analysis to generate inter-
structure signatures for closed source OS. The fuzzing tech-
nique will be employed to explore the relationships between
multiple data structures.
Because the main purpose of DeepScanner is to demon-
strate the e(cid:11)ectiveness of inter-structure signatures and im-
ported signatures, its detection mechanism is currently im-
plemented as an LKM. A limitation of DeepScanner is that
detection is enforced in target OS kernel. The detection may
be compromised by rootkits designed speci(cid:12)cally to tamper
with the detection mechanisms. Cooperating with virtual
machine techniques, we can also develop an out-of-box scan-
ner. It is advisable that security mechanisms are deployed in
hypervisors so that they can be shielded from malicious at-
tacks coming from a guest virtual machine, even if the guest
operating system kernel is compromised. In the future, we’ll
port DeepScanner to hypervisor to counter possible attacks.
7. CONCULSIONS
Scanning memory for object signatures to detect stealthy
malwares has been proven to be a useful approach.
It is
critical to construct robust scanning signatures for detec-
tion. Traditional approaches choose (cid:12)elds from a single data
structure to be scanning signatures. But, our analysis and
experiments prove that this way is limited or even impos-
sible as to some critical system object structures, e.g., the
module data structure in Linux kernel. In this paper, two
new concepts are introduced: inter-structure signature and
imported signature. Based on the two concepts, the space of
signatures is extended to involving relationships of multiple
data structures or importing arti(cid:12)cial signatures rather than
being limited in a single data structure. In this paper, we
provide four invariants as signatures to detect hidden pro-
cesses, sockets, and kernel modules in Linux. Accordingly,
we implement a detection prototype system DeepScanner
and a hypervisor-based monitor to protect imported signa-
tures. The experiment results show that DeepScanner can
e(cid:11)ectively and e(cid:14)ciently detect stealthy malwares and it can
also resist evasion attacks. Our works provide a new method
to construct robust signatures. The invariants presented in
this paper can be used immediately by applications to locate
processes, sockets and kernel modules in memory.
4) Violation of Invariant 4.
The experimental rootkit attempts to evade hidden
module detection by tampering the signature pages.
Due to all signature pages without write permission in
8. ACKNOWLEDGMENTS
The authors would like to thank the anonymous review-
ers for their insightful comments that helped improve the
226
[17] N. Petroni Jr, T. Fraser, A. Walters, and W. Arbaugh.
An architecture for speci(cid:12)cation-based detection of
semantic integrity violations in kernel dynamic data.
In Proceedings of the 15th USENIX Security
Symposium, 2006.
[18] J. Rhee, R. Riley, D. Xu, and X. Jiang. Defeating
dynamic data kernel rootkit attacks via VMM-based
guest-transparent monitoring. In Proceedings of the
4th IEEE Conference on Availability, Reliability and
Security (ARES), 2009.
[19] R. Riley, X. Jiang, and D. Xu. Guest-transparent
prevention of kernel rootkits with vmm-based memory
shadowing. In Proceedings of the 11th International
Symposium on Recent Advances in Intrusion Detection
(RAID), 2008.
[20] J. Rutkowska. Klister v0.3.
https://www.rootkit.com/newsread.php?newsid=51.
[21] A. Schuster. Searching for processes and threads in
Microsoft Windows memory dumps. Digital
Investigation, 3:10{16, 2006.
[22] A. Seshadri, M. Luk, N. Qu, and A. Perrig. SecVisor:
A tiny hypervisor to provide lifetime kernel code
integrity for commodity OSes. In Proceedings of 21th
ACM SIGOPS Symposium on Operating Systems
Principles (SOSP), 2007.
[23] A. Walters. The volatility framework: Volatile
memory artifact extraction utility framework.
https://www.volatilesystems.com/default/volatility.
[24] A. Walters and N. Petroni Jr. Volatools: Integrating
volatile memory forensics into the digital investigation
process. Black Hat DC, 2007.
[25] Y. Wang, D. Beck, B. Vo, R. Roussev, and
C. Verbowski. Detecting stealth software with Strider
GhostBuster. In Proceedings of the 35th IEEE
International Conference on Dependable Systems and
Networks (DSN), 2005.
[26] Z. Wang, X. Jiang, W. Cui, and P. Ning. Countering
kernel rootkits with lightweight hook protection. In
Proceedings of the 16th ACM Conference on Computer
and Communications Security (CCS), 2009.
[27] Z. Wang, X. Jiang, W. Cui, and X. Wang. Countering
persistent kernel rootkits through systematic hook
discovery. In Proceedings of the 11th International
Symposium on Recent Advances in Intrusion Detection
(RAID), 2008.
[28] H. Yin, Z. Liang, and D. Song. HookFinder:
Identifying and understanding malware hooking
behaviors. In Proceedings of the 15th Network and
Distributed System Security Symposium (NDSS), 2008.
presentation of this paper. The work has been supported
by the National Natural Science Foundation of China under
Grant No. 60873213, 91018008, 60703103 and 61070192, the
Beijing Science Foundation under Grant No. 4082018 and
Shanghai Key Laboratory of Intelligent Information Pro-
cessing, China. Grant No. IIPL-09-006.
9. REFERENCES
[1] Bypassing Klister.
http://www.rootkit.com/newsread.php?newsid=235.
[2] Chkrootkit. http://www.chkrootkit.org.
[3] KSTAT.
http://www.s0ftpj.org/tools/kstat24 v1.1-2.tgz.
[4] QEMU. http://www.qemu.org.
[5] Rkhunter.
http://www.rootkit.nl/projects/rootkit hunter.html.
[6] A. Baliga, V. Ganapathy, and L. Iftode. Automatic
inference and enforcement of kernel data structure
invariants. In Proceedings of the 24th ACM Conference
on Computer Security Applications Conference
(ACSAC), 2008.
[7] P. Barham, B. Dragovic, K. Fraser, S. Hand,
T. Harris, A. Ho, R. Neugebauer, I. Pratt, and
A. War(cid:12)eld. Xen and the art of virtualization. In
Proceedings of the 19th ACM SIGOPS Symposium on
Operating Systems Principles (SOSP), 2003.
[8] C. Betz. MemParser.
http://sourceforge.net/projects/memparser.
[9] C. Bugcheck. Grepexec: Grepping executive objects
from pool memory.
http://www.uninformed.org/?v=4&a=2&t=sumry.
[10] M. Carbone, W. Cui, L. Lu, W. Lee, M. Peinado, and
X. Jiang. Mapping kernel objects to enable systematic
integrity checking. In Proceedings of the 16th ACM
Conference on Computer and Communications
Security (CCS), 2009.
[11] D. Chisnall. The de(cid:12)nitive guide to the xen hypervisor,
2nd edn. Prentice Hall Press, 2007.
[12] B. Dolan-Gavitt, A. Srivastava, P. Traynor, and
J. Gi(cid:14)n. Robust signatures for kernel data structures.
In Proceedings of the 16th ACM Conference on
Computer and Communications Security (CCS), 2009.
[13] T. Gar(cid:12)nkel and M. Rosenblum. A virtual machine
introspection based architecture for intrusion
detection. In Proceedings of the 10th Network and
Distributed Systems Security Symposium (NDSS),
2003.
[14] X. Jiang, X. Wang, and D. Xu. Stealthy malware
detection through vmm-based out-of-the-box semantic
view reconstruction. In Proceedings of the 14th ACM
Conference on Computer and Communications
Security (CCS), 2007.
[15] S. Jones, A. Arpaci-Dusseau, and R. Arpaci-Dusseau.
VMM-based hidden process detection and
identi(cid:12)cation using Lycosid. In Proceedings of the 4th
ACM Conference on Virtual Execution Environments
(VEE), 2008.
[16] Z. Lin, J. Rhee, X. Zhang, D. Xu, and X. Jiang.
SigGraph: Brute force scanning of kernel data
structure instances using graph-based signatures. In
Proceedings of the 18th Network and Distributed
System Security Symposium (NDSS), 2011.
227