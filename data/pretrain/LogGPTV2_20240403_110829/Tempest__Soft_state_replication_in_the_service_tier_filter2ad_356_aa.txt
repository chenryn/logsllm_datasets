title:Tempest: Soft state replication in the service tier
author:Tudor Marian and
Mahesh Balakrishnan and
Ken Birman and
Robbert van Renesse
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 2008
Tempest: Soft State Replication in the Service Tier*
Tudor Marian, Mahesh Balakrishnan, Ken Birman, Robbert van Renesse
Department of Computer Science
Cornell University, Ithaca, NY 14853
{tudorm,mahesh,ken,rvr}@cs.comell.edu
Abstract
Soft state in the middle tier is key to enabling scalable
and responsive three tier service architectures. While soft(cid:173)
state can be reconstructed upon failure, replicating it across
multiple service instances is critical for rapid fail-over and
high availability. Current techniques for storing and man(cid:173)
aging replicated soft state require mapping data structures
to different abstractions such as database records, which
can be difficult and introduce inefficiencies. Tempest is a
system that provides programmers with data structures that
look very similar to conventional Java Collections but are
automatically replicated. We evaluate Tempest against al(cid:173)
ternatives such as in-memory databases and we show that
Tempest does scale well in real world service architectures.
1 Introduction
Service-Oriented Architectures (SOAs) have emerged as
the paradigm of choice for structuring large datacenter(cid:173)
hosted systems. Most contemporary large-scale applica(cid:173)
tions are built as SOAs: online stores, search engines, en(cid:173)
terprise software and financial infrastructure are some ex(cid:173)
amples. The canonical design for such systems is a three(cid:173)
tier architecture: a first tier load-balancing proxies sends
requests to a second tier of state-less service logic which in
tum accesses and updates a third tier of durable databases
or filesystems.
Soft state in the service tier is key to building highly re(cid:173)
sponsive and scalable SOAs. Soft state is characterized as
data that does not have to be stored durably and can be re(cid:173)
constructed at some cost [39, 24, 17] -
examples include
short-lived user sessions, stored aggregates and transforma(cid:173)
tions on large datasets, and general purpose write-through
*This work was supported by DARPAlIPTO under the SRS program
and by the Rome Air Force Research Laboratory, AFRL/IF, under the
Prometheus program. Additional support was provided by the NSF,
AFOSR, and by Intel.
caches for files and database records. Third-tier constructs
are extremely fault-tolerant but correspondingly slow and
expensive, and soft state is typically used to limit their role
in performance-critical data paths. For example, the devel(cid:173)
oper of an online travel service might use the memory of
the service instance to store intermediate choices made by a
user during the booking process, so that only the final sale
a small fraction of all user activity - hits the
transaction -
third-tier database.
In this paper, we consider the availability of soft state
stored in the service tier. When soft state is lost or made
unavailable due to service instance crashes and overloads,
reconstructing it through user interaction or third-tier re(cid:173)
access can be expensive in time and resources. Replicat(cid:173)
ing soft state provides applications with two critical capa(cid:173)
bilities:
rapid fail-over to other instances during crashes
and fine-grained load-balancing across instances to prevent
overload [39]. For example, a user request can be trans(cid:173)
parently redirected during a crash or overload to a different
service instance that has up-to-date session context, without
requiring her to log in again.
Many options exist for adding high availability to
programs that manipulate soft state and these can be
broadly classified into three categories: clustered appli(cid:173)
cation servers [3], messaging toolkits, and collocated in(cid:173)
memory databases. However, all these options require
the developer to write code in "state-aware" ways, map(cid:173)
ping data structures to special replication-aware containers,
replicated state-machine stores and database-style records,
respectively. Such mapping needs to be done carefully
to avoid performance issues -
for example, storing fine(cid:173)
grained variables in a database could result in severe locking
contention [1]. However the natural way for programmers
to store and manage soft state in a service is to use con(cid:173)
ventional in-memory data structures such as hash tables or
linked lists.
In this paper, we present Tempest, a Java runtime library
designed for easy storage and replication of service-level
soft state. Tempest provides developers with TempestCol(cid:173)
lections: custom data structures that look similar to con-
1-4244-2398-9/08/$20.00 ©2008 IEEE
227
DSN 2008: Marian et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:30:40 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 2008
ventional Java Collections [35]. Data stored in these struc(cid:173)
tures is transparently andfully replicated upon multiple ma(cid:173)
chines, providing fail-over and load-balancing for soft (in(cid:173)
memory) state with zero extra effort by the developer. Un(cid:173)
der the hood, Tempest uses a fast but unreliable IP multicast
operation to spreadlbroadcast invocations to multiple ser(cid:173)
vice instances and then uses gossip-based reconciliation to
maintain replica consistency in the face of faults and over(cid:173)
loads. Additional adaptive mechanisms are used to maintain
high responsiveness during failures.
High-performance in-memory databases are used exten(cid:173)
sively to store soft state in currently deployed systems [6,
30, 13] and we show that Tempest outperforms them in
large-scale SOA settings. Real-world SOAs often have
many services interacting with each other to perform com(cid:173)
plex tasks -
for example, a first-tier front-end could con(cid:173)
tact a hundred second-tier services to assemble a webpage
[20]. Further, each service is potentially contacted in paral(cid:173)
lel by a large number of load-balancing first-tier front-ends.
Tempest scales in both the number of front-ends querying
a single service and the number of services being queried
by a single front-end.
In contrast, in-memory databases
fail to scale in these dimensions due to contention, large
latency variations and inefficiencies in cross-process inter(cid:173)
actions between the service and the database.
Accordingly, the contributions of this paper are as fol(cid:173)
lows:
• We present a Java runtime library that exposes data
structures to programmers that are transparently repli(cid:173)
cated across multiple nodes.
• We describe the gossip-based mechanisms used within
the system for rapidly replicating data and speeding-up
access to it.
• We evaluate Tempest on two datacenter-style testbeds
the Emulab testbed at Utah [37] and a 252 node
-
cluster at Cornell. We show that Tempest maintains
rapid responsiveness under heavy loads and outper(cid:173)
forms in-memory and on-disk databases while scaling
the number of front(cid:173)
in two important dimensions -
ends accessing a single service and the number of ser(cid:173)
vices composing a single response.
The remainder of this paper is structured as follows: Sec(cid:173)
tion 2 describes the interface and semantics provided by
TempestCollections to service developers. Section 3 de(cid:173)
scribes the protocols and mechanisms used by Tempest to
implement the TempestCollection abstraction, and Section
4 provides an evaluation of Tempest on datacenter testbeds.
2 The TempestCollection Abstraction
2.1
SerVice Model
Services are self-contained entities designed to support
interoperable machine to machine interaction over a net(cid:173)
wor . Each service exposes an API through which a set
of methods can be invo ed by clients, and each service of(cid:173)
fers its own quality of service and availability guarantees.
Ta e for example the interface of a shopping cart service as
listed in Figure 1.
public interface ShoppingCartIF extends Iterable {
update int add(String itemSymbol,
update int remove(String itemSymbol,
update int update(String itemSymbol,
read int check(String itemSymbol);
int count);
int count);
int count);
Figure 1. 'Shopping Cart' service interface.
Add, remove and update do the obvious things; these are
classified as update operations because they change state.
Chec is a read operation; it retrieves the current number of
items in the shopping cart for the symbol of interest. Clients
issue add/ remove /update and check requests against
the service; the service processes each request and in return
sends bac a reply. This simple example can be trivially ex(cid:173)
tended to services li e item browsing history, product avail(cid:173)
ability, product rating, or caching services.
In this wor we assume that business logic is collocated
with soft state stored in the memory of the service instance;
as mentioned before, this is a natural design choice for ap(cid:173)
plications requiring scalability and responsiveness. For ex(cid:173)
ample, storing shopping cart information in-memory allows
the service to handle a large quantity of browsing traffic that
otherwise would have reached the third tier. A developer
implementing the shopping cart service in Java could use
different data structures to store the state of the cart; a natu(cid:173)
ral way would involve using a hash table to store mappings
between item identifiers and corresponding counts.
Service state is modified by updates sent to it through its
in the conventional three-tier setup, this refers
interface -
to database state hidden by the service, but in our case it in(cid:173)
cludes soft state maintained by the service. In our shopping
cart example, items are added to or subtracted from the cart.
The implementation of a service as a Java application
running on a single node is obviously prone to crashes, over(cid:173)
loads and slowdowns. Our goal is to transparently replicate
a service on multiple nodes while retaining the program(cid:173)
ming ease and familiarity of Java's built-in Collection data
structures. Accordingly, we provide developers with Tem(cid:173)
data structures very similar to vanilla
pestCollections -
Collections but providing automatic replication of the data
stored in them.
1-4244-2398-9/08/$20.00 ©2008 IEEE
228
DSN 2008: Marian et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:30:40 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 2008
2.2 TempestCollection: Syntax and Se(cid:173)
mantics
TempestCollections are syntactically identical to stan(cid:173)
dard Java Collections. For example, a TempestHashtable
exposes get and put methods while a TempestSet has
add, remove methods. Li e most Java Collections, ob(cid:173)
jects stored in a TempestCollection cannot be modified in
place. For example, to change a field inside an Object stored
in a TempestSet, the programmer would have to remove the
Object, modify it and then re-insert it into the set.
This is a very common programming idiom within the
Java Collections framewor . For example, Java TreeSets
provide ordered iteration over their elements, and changing
the value of an item in-place can push the TreeSet into an
inconsistent state by modifying the outcome of compare op(cid:173)
erations. Programmers are expected to instead change val(cid:173)
ues by removal, modification and re-insertion if they want
the TreeSet to remain consistent and ordered.
In general,
many Collections involve comparisons through equals
and compareTo -
such as HashMaps, TreeSets or Hash(cid:173)
and do not allow safe in-place modification of ob(cid:173)
Sets -
jects stored within them.
In this respect, TempestCollec(cid:173)
tions offer identical semantics.
To prevent accidental modification of stored items
TempestCollections implement by-value parameter passing:
Deep clones of added Objects are stored within the Tem(cid:173)
pestCollection and clones of stored Objects are returned by
accessor functions. For example, calling put (K, A) on
a TempestHashMap will result in a clone A' being stored
within the collection, and calling get (K) will return A"
to the programmer.
However, the Tempest runtime can alter the contents of
TempestCollections by adding and / or removing items to
eep collections consistent across replicas. TempestCollec(cid:173)
all replicas converge
tions provide eventual consistency -
to the same set of objects [12, 10]. An implication of this
model is that the programmer is not provided with ACID
transactions; however, this is not a major limitation for soft
state management [10]. In many soft state applications, data
stored within structures is naturally immutable -
for in(cid:173)
stance, a browsing history service that stores a list of item
identifiers. For others, updates do not depend on current
state -
for example, a map from users identifiers to last
viewed items. Even if the soft state is manipulated with ar(cid:173)
bitrary operations, it is expected by definition to not have
strong semantics -
the user is always as ed to verify the
contents of a shopping cart or the final itinerary of a travel
plan before committing to it.
To summari e, TempestCollections are data structures
exposing interfaces identical to those in the Java Collections
framewor and supporting similar semantics by not allow(cid:173)
ing in-place modifications of stored Objects. The sole devi-
- aside the wea
ation from the Java Collections framewor
consistency implications - is that Tempest enforces Object
immutability by passing parameters by-value -
a side ef(cid:173)
fect of this is the possibility for services to operate on stale
data. By deliberately choosing a wea er consistency model
we had more opportunities to provide a massively scalable
solution -
as a result developers are required to understand
and account for unreliable soft state.
3 Tempest Architecture.,1
1
..
1
!I
'i
Figure 2. Tempest architecture.
In this section we describe the mechanisms used to im(cid:173)
plement replicated TempestCollections. Tempest services
reside on second-tier servers; a single server represents the