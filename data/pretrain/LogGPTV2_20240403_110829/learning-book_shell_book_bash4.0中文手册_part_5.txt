*）echo-n"末知数目的";；
8 esac
9echo*腿。·
模式列表前面可以加一个与"”匹配的“"，但不是必须的。
目录
BASH 中文文
---
## Page 21
第三章SHELL的基本功能
§3.2 SHELL 命令
如果使用了“：：”（来结束分句），则匹配第一个模式以后就不会再匹配其它模式。如果用；&"来代
替“：：”，则执行命令块后，如果下面还有其它分句，就继续执行该分句，如果用”；：&"来代替”：：”，则
执行命令块后，如果下面还有其它分句，就检查其模式（如果有的话）：如果其模式为真，继续执行其对应
的命令块。
如果任何模式都不匹配，该命令的返回状态是零：否则，返回最后一个被执行的命令的返回值，
C.
select
Belect结构使得菜单的生成变得简单。它的语法格式几乎和for命令一样：
Belect名称[in单词表-.·]；do命令块；done
in后面的单词表被扩展并生成一个项目列表：这个扩展后的列表将会打印到标准错误输出流中，并且每个
项目前面都会加上一个序数。如果省略了“in单词表"部分，则打印位置参数，就好像使用了“in$Q”一样。
之后，将显示PS3提示符，并且从标准输入读取一行的输入。如果输入的行含有一个与所打印出的词项对
应的数字，则name的值就被置为该单词。如果输入的为空，则重新显示单词表和提示符。如果输入了EOF
字符，Belect命令将结束。输入任何其它值都会使名称被置为空值。读取到地值被存放在变量REPLY中。
每次选择之后都会执行命令块，直到遇到一个break命令为止一这时Belect命令将结束。
下面是Belect的一个例子。该例允许用户从当前目录中选择一个文件，并显示用户选择的文件名及其
序号。
亲代码清单2：Belect的例子
: select fnane in *;
2 do
echo you picked $fnane \($REPLY\)
break;
5done
D.
((-··))
（（算术表达式））
根据后面将要介绍的规则（参见56.5Shell的算术运算]，p61）对算术表达式求值。如果这个值不是零，则返
回状态是零，否则返回1.这和下面的命令完全等价：
let"表达式"
关于内部命令1et的完整介绍，请参见54.2[Bash的内部命令1et]，p38。
E.[[-..]]
[[条件表达式]
对条件表达式求值，并根据其结果返回0或者1。条件表达式是由56.4Bash条件表达式，p59中介绍的原
子成分组成的，在“[”和“]]”中间的单词不会进行单词和文件名扩展，但却进行波浪号扩展、参数和变
量扩展、算术扩展、命令替换、进程替换以及引用去除。诸如“-r"等条件运算符不能被引用，否则它们就不
是原子算术表达式了。
如果使用了-"和“！"运算符，则运算符的右边会被看作是一个模式，并且按照≤3.5.8.1[模式匹配]
p20中所介绍的匹配规则进行匹配。如果打开了shell 的nocasematch 选项（参见587[内部命令shopt]
BASH 中文文档
目录
p10
---
## Page 22
3.2SHELL命令
第三章SHELL的基本功能
p47），则匹配时不考虑字母的大小写。如果使用了“-"并且字符串匹配，或者使用了“!-"并且字符串不匹
配，则其返回值是0，否则返回1。模式的任何部分都可以被引用以强制把其当作字符串来匹配。
还可以使用另外一个双目运算符“-”：它和“”以及“！-"具有同样的优先级。如果使用了它，则其右
边的字符串就被认为是一个扩展的正则表达式来匹配（如regex3一样）。如果字符串和模式匹配，则返
回值是0，否则返回1，如果这个正则表达式有语法错误，则整个条件表达式的返回值是2，如果打开了
shell的nocasenatch选项（参见g87[内部命令shopt]，p47），则匹配时不考虑字母的大小写。模式的任何
部分都可以被引用以强制把其当作字符串来匹配。由正则表达式中括号里面的子模式匹配的字符串被保存在
数组变量BASH_REMATCH中。BASH_REMATCH中下标为0的元素是字符串中与整个正则表达式匹配的部分。
BASH_REMATCH中下标为n的元素是字符串中与第n个括号里面的子模式匹配的部分。
表达式可以通过下面的运算符（按优先级降序排列）组合在一起：
（表达式）
返回表达式的值。这样写可以改变运算符的正常优先级。
！表达式
如果表达式为假，则返回真。
表达式一表达式二
如果表达式一和表达式二同时为真则返回真。
表达式一11表达式二
如果表达式一或者表达式二为真则返回真。
如果表达式一的值已经足以判断整个条件表达式的返回值，则&是和1运算符就不再对表达式二进行求值。
53.2.4.3命令组合
Bash提供了两种方式来把一系列命令放在一起作为整体执行。当命令被组织在一起时，可以对整个命
令列表进行重定向。例如，命令列表中所有命令的输出都可以重定向到一个单一的流中。
A.()
（表达式）
把一列命令放在括号中间就会创建一个子shell环境（参见≤3.7.3命令执行的环境]，p25）并在这个子shell
中执行该列表中的每个俱。就是因为命令列表是在子shell中执行的，所以在子shell结束后，其中的变量
赋值将不再有效。
B.}
{表达式；}
把一列命令放在大括号中间，这列命令就会在当前shell中执行，而不是创建子shell。命令列表后面的逗
号（或者换行符）是必须的。
指npge
pl1
目录
BASH 中文文
---
## Page 23
第三章SHELL的基本功能
3.3 SHELL 函数
命令的分隔符
在Bash的分隔符中，“：的使用是最频繁的。它除了具有分隔的作用，没有其它任何含义：所
以，任何命令的末尾都可以使用它。但如果一个命令单独成行，这个符号完全可以省略。例如，
for nane in *;do echo ${nane/-png/-jpg}; done
扣
for nane in *
do
echo ${nane/ .png/-Jpg)
done
是完全等价的，
■[分节结束]
除了子shell的创建，上述两种结构之间由于历史的原因还有微妙的差别。大括号是保留字，所以它们
与命令列表之间必须用空白符或其它shell的元字符分开：而圆括号是运算符，所以即使它们和命令列表之
间没有用空白符分开也会被shell当作独立的符号。
这两种结构的命令返回值都是其中命令列表的返回值。
$3.2.5协同进程
协同进程coprocess是指一个shell命令前面有coproc保留字：它是在子shell中异步执行的，就好像
这个命令后面有控制运算符&一样。协同进程和其父shell进程之间有双向的管道。这个命令的格式是：
coproc[NAME]命令[重定向]
上述命令创建了一个名为NAME的协同进程。如果没有指定NAME，默认的名称是COPRDC。如果这里的命
当coproc执行时，shell会在父进程中创建一个名为NAME的数组变量（参见S6.7数组]，p62）。命令的
标准输出通过管道和父进程的一个文件描述符相连：该文件描述符被赋给NAME[O]，命令的标准输入通过管
道和父进程的一个文件描述符相连：该文件描述符被赋给NANME[1]。这个管道是在命令当中指定的任何重定
向（参见&3.6[重定向]，p21）之前就建立了。这些文件描述符可以在shell命令和重定向中通过标准的单词扩
展而当作参数使用。
用来执行协同进程的子shell的进程号保留在数组变量NAME[PID]中。可以使用内部命令Wait来等待
协同命令的结束。协同进程的返回状态是其中命令的返回状态。
§3.3Shell函数
Shell函数把一组命令与单一的名称相关联，以便以后执行。在执行时，它们就和“常规”命令一样。如
果shell函数的名称被当作一个简单命令使用，与它相关联的命令就会被执行。Shell函数是在当前的shell
环境中执行的，而不是创建新的进程来执行。
函数通过下面的语法来定义：
[function]名称（复合命令块[重定向]
上面定义了一个叫做名称的函数。保留字funnction是可选的。如果有function这个保留字，则可以省
略括号。复合命令块（参见53.2.4复合命令]p8）是函数体：它通常是包含在【和}之间的命令列表，也可
以是上面列出的任何复合命令，每当名称被指定为一个命令名时，复合命令块就会被执行。当函数被执行
时，与之相关的重定向（参见53.6[重定向]，p21）也会同时被执行。
BASH 中文文档
目录
p12
---
## Page 24
3.4 SHELL参数
第三章SHELL的基本功能
可以使用内部命令unset的“-r"选项（参见54.1[波恩Shell的内部命令unset]，p34）来取消函数的定
义。
除非发生语法错误，或者一个同名并且为只读的函数已经存在，函数定义的返回值是零。执行时，函数
的返回值是函数体内最后一个被执行命令的返回值。
注意，由于历史的原因，通常情况下，函数体外的大括号与函数体之间必须用空白符或者换行符分开。
因为大括号是保留字，但是只有它们与其中间的命令列表空格或其它shell元字符分隔时才能被识别为保留
字。此外，使用大括号时，其中间的命令列表必须用逗号、“”或者换行符结束。
函数执行时，传递给它的参数成为它执行期间的位置参数（参见53.4.1[位置参数]，p14）-能扩展为位置
参数个数的特殊参数“将随之更新。特殊参数oI不变。在函数执行时，变量FUNCNAME的第一名元素被
设为函数的名称。除了DEBUG和RETURN这两个陷阱没有被继承以外，函数和其调用者之间在Shell执行环
境所有其它方面都完全一样。如果用内部命令declare设置了函数的trace属性，或者设置了内部命令
Bet的functrace选项，以便使，则函数也会继承调用者的 DEBUG和RETURN陷阱。参见4.1[波恩Shell
的内部命令trap，p33的描述。
如果在函数里面执行了内部命令return，则函数的执行将结束，并且返回到调用函数那里的下一个
命令，任何与RETURN陷阱相关联的命令都将在执行恢复前被执行。函数结束时，位置参数以及特殊参
数“的值恢复到函数被执行以前的状态。如果return带有一个数值型参数，则这个参数就是函数的返回
值：否则，函数的返回状态是其返回前最后一个被执行命令的返回状态。
函数本地的变量可以用内部命令1ocal来声明。这些变量只对函数及它使用的命令是可见的。
函数名称及其定义可以用内部命令typeget或者declare加上“-f"选项（参见g4.2Bash的内部命
令declare]，p36）来列出：而typeset或者declare 加上“-F"选项只列出函数名（如果打开了shell的
extdebug选项，则还会列出源文件和行号）。通过内部命令export的"-f"选项（参见54.1[波恩Shell的内
部命令export]，p30），还可以把函数导出，使得它们在子shell中自动得以定义。注意，如果shell函数和
变量同名，则可能导致传给shell子进程的环境中有多个完全一样的名字，如果这样会引发问题，就需要避
免同名。
函数可以是递归的。对递归调用的次数没有限制。
$3.4
Shell参数
参数是能存储值的实体：它可以是一个名称、一个数字、或者下面列出的特殊字符之一。变量是名称所
代表的参数。每个变量都有值以及零个或多个属性，属性通过内部命令declare（参见54.2Bash的内部命
令declare]：p36）来设置。
参数通过赋值来设置。空字符串也是一个有效的值。参数一且设置以后，只能通过内部命令unset才
能取消设置。
可以通过下面的语句形式给参数赋值回：
名称=[值]
如果没有给定值，则变量被赋于空字符串。所有的值都会进行大括号扩展、参数和变量扩展、命令替换、算
术扩展、以及引用去除（详见下述）。如果启用了变量的integer属性，则把该变量当作算术表达式求值，
即使没有使用s（（-.)）扩展（参见53.5.4命令替换]，p18）.除了下述的“$”，否则不会进行单词扩展。文
件名扩展也不会进行。赋值语句还可以作为内部命令alias、declare、typeset、export、readonly和
local的参数。
在赋值语句给shell变量或数组（参见56.7数组]，p62）元素赋值的行文中，可以使用“+-"运算符附
加或增加到变量原来的值中。如果变量启用了integer属性并且使用"+"，则按照算术表达式对值进行求
值，并把它加入到变量原来的值中后再求值。如果对数组变量进行复合赋值（参见56.7数组]，p62）时使
用了“+-"，则变量原来的值不会被覆盖（像用“"那样），新的值被附加到数组中下标最大的那个元素的后
附加在变量的值后面。
即转。通需表示脚本的名称。
在引号中。
同原文为 index，实际应该是指数组中位于index的某个元素。
+++++++++++++++++++++++++++++++++++++++++++
p13
目录
BASH 中文文
---
## Page 25
第三章SHELL的基本功能
53.5 SHELL 扩展
+ee ee e e e ee e e e e e ee e e e e e e ee ee e e e e e e e e ee e e e ee e e e ee e e e
S3.4.1位置参数
位置参数是由除了单个0以外的一个或多个数字表示的参数：它是在shell启动时由其参数赋值的，并
且可以用内部命令Bet来重新赋值。第N个位置参数可以表示为$N}：如果N只含有一个数字，也可以
表示为$N。位置参数不可以通过赋值语句来赋值：而应该用内部命令Bet或者ehift（参见54.3.1[内部命
令set]，p42和≤4.1[波恩Shell的内部命令shift]，p32）来设置或删除。在执行shell函数时（参见g3.3[Shell
函数]，p12），位置参数会暂时被更换。
含有多于一个数字的位置参数在扩展时必须放在大括号中。
S3.4.2特殊参数
Shell会对一些参数特殊处理。这些参数只能使用而不能对它们赋值。
扩展为从1开始的所有位置参数。如果它出现在双引号中，则扩展为一个包含每个参数的单词，参数
变量IFS的第一个字符，如果IFS没有设置，则参数之间用空格分隔。如果IFS为空，则参数直接相
之间用特殊变量IFS的第一个字符分隔。也就是说，"$*”和$1c$2c.-”是等价的：其中，c是特殊
连，中间没有分隔。
扩展为从1开始的所有位置参数。如果它出现在双引号中，则每个参数都扩展为一个单词：也就是说，
"$Q"和"$1e"$2c"-.·是等价的。其中，c是特殊变量IFS的第一个字符。如果IFS没有设置，则
参数之间用空格分隔。如果IFS为空，则参数直接相连，中间没有分隔。如果这这样的双引号扩展发
的最后一个部分连在一起，如果没有位置参数，则“$”和$扩展后为空，也即它们会被删除。
扩展为位置参数的个数，用十进制表示。
？
扩展为最近在前台执行的命令的退出状态。
（连字符）扩展为当前的所有选项：这些选项是启动时给定的，或者通过内部命令Bet打开的，或者由
shell 本身打开的（例如=i选项）。
事
扩展为当前shell 的进程号。在子shell（）中，扩展为启动shell的进程号，而不是子shell 的进程号。
扩展为最近在后台（异步）执行的命令的退出状态。
0
扩展为 shell 或者shell脚本的名称。它是在 shell 初始化时设置的。如果 Bash 启动时带有包含命令
的文件名参数（参见g6.1Bash的启动]，p55），S0就被设为该文件名。如果Bash启动时带有“=e"选
项（参见s6.1[Bash的启动]，p55），则s0被设为待执行字符串后面的第一个参数（如果这个参数存
在）。否则，它就是用来启动Bash的文件名，即（命令行的）第一个参数。
（下划线）在shell启动时，设为启动shell的绝对路径，或者在执行环境或参数列表中所传递的待执行
的shell脚本的绝对路径。随后，扩展为前一条命令的最后一个参数扩展后的值。还可设为每个已执
行命令的绝对路径，这些路径是启动时指定的并且导入到命令的执行环境中。检查邮件时，这个变量
保存邮箱文件的文件名。
$3.5Shell扩展
命令行被拆分成符号以后要进行扩展：扩展的方式有七种：
大括号扩展
波浪号扩展
BASH 中文文档