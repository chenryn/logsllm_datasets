discovered opens a door for hackers to successfully attack
anyone of the millions of web sites developed with a
given version of the web application. Furthermore, it is
common to find a vulnerability in a specific version of a
web application that also affects a large number of
previous versions. The overall situation is even worse
because web site administrators do not always update the
software of the site in due time when new patches and
releases are available. This can be confirmed by the
results of the security analyst David Kierznowski who
performed a survey showing that 49 out of 50 WordPress
blogs checked did not upgrade to the last stable version
and were running software with known vulnerabilities
[28].
2.3. Obtaining the patch code
The availability to the public of the past collection of
vulnerability patches is closely related to the policies the
developers have about sharing information about older
especially those with security problems.
versions,
Furthermore, most of
security announcements
available are so vague that it is impossible to know what
source files and variables are affected. Moreover, some of
the information disclosed includes other types of security
vulnerabilities which are not the target of the present
paper (e.g. directory traversal,
remote file inclusion,
cookie poisoning).
the
In order to gather the actual code of security patches
several sources of data had to be used, such as mirror web
sites, other sites with the source code, online reviews,
news
sites,
changelog files of the application,
the version control
system repository, etc.
related to security, hacker
sites,
sites
For the purpose of this study, we only need the
changes made to the code of the application that corrected
the vulnerability problem. There is no standard way of
providing the data about a security vulnerability fix;
therefore, the variety of resources of information provides
different presentations of the collected data. This makes it
harder to perform the analysis because the information
about
the code fix has to be obtained from several
sources. The four main source types used in the current
paper are described next:
1) Security patch files available with information
about the target version of the application. This
patch file was written to substitute the original file in
which the vulnerability existed, leaving all the other
source files intact. To obtain the code changes of
these two files we used the UNIX diff command.
2) Updated version of the web application. Actually,
this is a completely new version of the application
containing all
the new features and bug fixes
1-4244-2398-9/08/$20.00 ©2008 IEEE
260
DSN 2008: Fonseca &Vieira
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:20:06 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems &Networks: Anchorage, Alaska, June 24-27 2008
the code responsible for
(including security ones). This is
the source of
information that needs more work to be done. We
have to find, amongst all the other source files of the
application,
the various
security vulnerabilities addressed by this version.
Additional information is needed about what source
files have been updated with the security fixes. This
information is commonly found in the changelog file
that
is distributed with the application. This file
contains the summary of the changes made in the
several versions of the application,
including what
bugs and security issues were fixed. After identifying
the vulnerable source file we had to use the UNIX diff
command to obtain the code changes between this file
and the corresponding file from the vulnerable version
of the application (usually it is the previous version).
3) Available security diff file. This is a file containing
only the code changes needed to fix a referenced
vulnerability. The contents are ready to be applied to
the
the UNIX patch
command. This is all the information we need and,
although this is the easiest data source to work with, it
is the rarest to find.
application using
target
4) The version control system repository. Almost all
open source applications are developed using a
version control system to administer the contributions
of the large community of developers from around the
world. With granted permissions
to query the
repository of the version control system we have
access to all the revisions (similar to versions) of the
application and corresponding changelog files. By
querying the changelog we can obtain the information
the revisions of the application where the
about
security vulnerability problems were fixed. It is then
possible to obtain the security diff file using the
version control system commands.
2.4. Patch code analysis guidelines
need to
be
decisions
clarified. To
The patch code is analyzed according to the extension
of the ODe classification, emphasizing the nature of the
patch as missing, wrong, or extraneous code. Because of
the different coding practices of the target applications
some
avoid
classification mistakes and for the coherent analysis of
the fix code some generic guidelines were defined:
1) When the patch can fix both XSS and SQL Injection
type is accounted for both
the corresponding fault
security vulnerabilities. For example,
this occurs
when a variable not properly sanitized is used in a
query (allowing SQL injection) and,
later on is
displayed on the screen (allowing XSS). When this
variable is properly sanitized both vulnerabilities will
be mitigated simultaneously.
2) It is assumed that the information publicly disclosed
in specialized sites is accurate and that the fix made
by the programmer of the patch and made available by
the company that develops the web application solves
the stated problem.
3) To correct a single vulnerability several code changes
may be necessary. All the changes will be considered
as a series of singular fault type fixes. For example,
suppose that two functions are needed to properly
sanitize a variable. Missing any of these functions
makes the application vulnerable, so both of them
must be taken into account.
4) When a particular code change corrects immediately
several vulnerabilities, each one is considered as a
singular fix. For example, suppose that
the value
assigned to a specific variable may come from two
sources of external inputs; and the variable is only
displayed in one place without ever being sanitized.
We consider that
the application has two security
vulnerabilities because it can be attacked from two
different inputs. However to correct the problem all
that is needed is to sanitize the variable just before it
is displayed. In this example we consider that two
security problems have been fixed, although only one
change of code was needed.
the code fixes. However,
5) A security vulnerability may affect several versions of
the application. This happens when the code has not
been changed for a long time, but is vulnerable. The
patch to fix the problem is the same for all versions,
and therefore it is considered to be only one fix.
By following the previous guidelines it is possible to
in some
classify almost all
situations, patching one or more vulnerabilities involved
so many changes, including the creation of new functions
or a change in the structure of the overall piece of code,
that it was impossible to classify it. These situations are
usually associated with major code changes involving
simultaneously security and other bug fixes. These
occurrences are quite marginal
(5.4%) and were not
considered in our study because they are complex and
to analyze due to the lack of information
difficult
available.
3. Results and discussion
We have classified 655 XSS and SQL injection
security fixes found in the six web applications. Figure 1
shows the global distribution of XSS and SQL injection
vulnerabilities found in all the web applications analyzed.
As can be seen, XSS is the most frequent type by far.
This trend is also confirmed by vulnerability reports
disclosed in eVE [8, 9]. One of the factors that contribute
to the prevalence of XSS is that every input variable of
the application is a potential attack entry point for XSS,
1-4244-2398-9/08/$20.00 ©2008 IEEE
261
DSN 2008: Fonseca &Vieira
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:20:06 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 2008
variables, when the code is unsecured.
3) A poor regular expression (regex) string used to filter
the user input. Looking at several versions of the same
program we frequently found the same regex string
being updated as new attacks were discovered.
Excluding the faults types already discussed (MFC
extended, WPFV, MIFS and WVAV), the remaining fault
security
types
vulnerabilities found. These fault types are EFC, WFCS,
MVIV, MLAC, MFC, MIA, MLOC and ELOC.
correspond to only 7.63% of
the
Table 3 shows the individual results for each fault
type found in all web applications. All the fault types
contribute to XSS, but only eight
to SQL injection,
however, the four fault types that do not contribute to
SQL injection (MFC, MIA, MLOC and ELOC) only
account for 1.22% of all the fault types.
A common belief is that vulnerabilities related to
input validation are mainly due to missing IF constructs
or even missing conditions in the IF construct. However,
our field study shows that this is not the case, as the
overall MISSING IF fault types (MIFS and MIA: see
table 1) have a weight of 5.5%. As for the MISSING
CONDITION fault types (MLAC and MLOC), they only
represent 1.52%. We verified that programmers typically
do not use IF constructs to validate the input data,
because of the usual complexity of the validation
procedure to avoid XSS and SQL injection. The typical
approach is to use a function to clean (filter) the input
instead of
data and let
the filtered data go through,
stopping the program and raising an exception.
3.1. Comparing security faults with generic
software faults
Figure 1. XSS and SQL injection distribution
which is not the case for SQL injection, where only
variables used in SQL queries matter.
The distribution of the occurrences of XSS and SQL
injection throughout the twelve classification fault types
is shown in Figure 2. The most representative and
widespread fault type is the MFC extended. This is the
most common fault type, representing 75.88% of all the
fault types found. The high value observed for this fault
type comes from the massive use of specific functions to
validate and clean data that comes from the outside of the
application (user inputs, database records, files, etc.). In
many cases, functions are also used to convert a variable
to a numeric value, therefore preventing string injection.
The next
three most common fault
types are the
WPFV, MIFS and WVAV. These vulnerabilities usually
arise from the following main situations:
1) Missing ",,, around a PHP variable in SQL queries
allowing an attacker to inject a custom query (SQL
injection).
2) Missing "if' around a statement. When a variable is
not null it needs to be sanitized, otherwise a malicious
code may be injected from the outside. This is an
exploit of the PHP directive "register_globals
= on" [29] which allows the injection in all sorts of
Relative dstrilUion
4OO---r----------------------------------~
350
300
250
200
150
100
50
0
~
.xss
357
140
_
~~
~
~
~
~
1 5
~
17
~
1 8
2 7
1 3
~
~
~
o 2
~
o 1
o 1
~
~
Fadttypes
Figure 2. Vulnerability fault types summary
1-4244-2398-9/08/$20.00 ©2008 IEEE
262
DSN 2008: Fonseca &Vieira
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:20:06 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 2008
Table 3. Detailed results
PHP-Nuke
SQL
XSS
120
133
31
5
2
2
Drupal
4
SQL XSS
39
3
2
3
PHP-Fusion WordPress
SQL XSS
SQL
94
6
XSS
13
5
6
6
2
7
1
1
1
2
1
3
1
2
1
1
3
4
1
1
1
phpBB
SQL
3
XSS
27
1
2
17
4
4
1
phpMyAdmin
SQL
XSS
51
4
10
4
1
2
1
2
13
Web applications
Fault type
MFC extended
WPFV
MIFS
WVAV
EFC
WFCS
MVIV
MLAC
MFC
MIA
MLOC
ELOC
Total Faults
1
55
4
137
158
21
The original ODC classification is broadly used and
accepted as quite adequate for
the classification of
software faults. Dudies [14] analyzed 668 faults from a
collection of 12 representative open source C programs
using the ODC, while Christmansson and Chillarege [12]
studied large databases and operating systems. Each of
these
and
programming technology. Thus, it is relevant to compare
our results with other field studies like [14] and [12], as
shown in Table 4.
application
different
studies
uses
a
Although the values of the current field study are
quite different from those of the two other studies [12,
14], the Algorithm has the highest value followed by the
Assignment. The overall distribution in table 4 is quite
different and reinforces the idea that the kind of mistakes
a different
leading to security vulnerabilities has
distribution from the generic fault
types. There is an
increasing importance of some fault types in detriment of
others when we want to analyze the security of web
applications.
Based on the fact that some common vulnerabilities
found are caused by specific characteristics of the
programming language (like the use of default value of
the "register_globals" directive,
in PHP), we
believe that the type of language/technologies involved
Table 4. ODe vulnerabilities
ODe defect
type
Assignment
Checking
Interface
Algorithm
Function
# vuln.
0/0 vuln.
37
13
46
559
0
5.65%
1.98°A»
7.02°A»
85.30%
0%
0/0 vuln.
0/0 vuln.
[14]
21.4%
25%
7.3%
40.1%
6.1%
[12]
21.98%
17.48%
8.17°A»
43.41%
8.74°A»
6
3
1
73
55
are
109
analyzing
33
will
influence the distribution of faults over the ODC
types when we
faults.
Programming languages, in general, have a great concern
in security and this can be seen in the new features that
are being implemented in recent versions. However, input
validation is transversal to all languages and our results
can be useful when developing using other web
application languages, like Java, or .net.
security
Another important conclusion can also be derived by
comparing our results with those presented by the study
in [17]. In this study the authors propose a method to
benchmark web application vulnerability scanners by
injecting generic software faults. Although the purpose of
the paper was to test fuzzers, the results also show what
common fault types may produce XSS and SQL injection
vulnerabilities. Analyzing the results presented in [17] we
find that they could inject both vulnerabilities with one
fault type that was not detected during our study. This
fault type is "WLEC - Wrong logical expression used as