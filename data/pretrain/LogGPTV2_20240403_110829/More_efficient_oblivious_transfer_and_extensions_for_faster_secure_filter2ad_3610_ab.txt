i-th column of T . The parties then invoke the κ×OTm functionality, where R
plays the sender with inputs (ti, ti ⊕ r) and S plays the receiver with input s.
Let Q = [q1 | . . . | qκ] denote the m × κ matrix received by S. Note that
qi = (si · r)⊕ ti and qj = (rj · s)⊕ tj (where tj, qj are the j-th rows of T and Q,
j ⊕ H(qj ⊕ s),
respectively). S sends (y0
for 1 ≤ j ≤ m. R ﬁnally outputs zj = yrj
j ⊕ H(tj) for every j. The protocol is
secure assuming that H : {0, 1}m (cid:55)→ {0, 1}(cid:96) is a random oracle, or a correlation
robust function as in Deﬁnition A2; see [32] for more details.
j ⊕ H(qj) and y1
j = x0
j , y1
j ) where y0
j = x1
2.3 Yao’s Garbled Circuits Protocol
Yao’s garbled circuits protocol [58] allows two parties to securely compute an ar-
bitrary function that is represented as Boolean circuit. The sender S encrypts the
Boolean gates of the circuit using symmetric keys and sends the encrypted func-
tion together with the keys that correspond to his input bits to the receiver R. R
then uses a 1-out-of-2 OT to obliviously obtain the keys that correspond to his
inputs and evaluates the encrypted function by decrypting it gate by gate. To
obtain the output, R sends the resulting keys to S or S provides a mapping from
keys to output bits. We emphasize that Yao’s garbled circuits protocol requires
a 1-out-of-2 OT on κ-bit strings for each input bit of R. For our experiments we
use the Yao’s garbled circuits framework FastGC [28].
2.4 The GMW Protocol
The protocol of Goldreich, Micali, and Wigderson (GMW) [19] also represents
the function to be computed as a Boolean circuit. Both parties secret-share their
inputs using the XOR operation and evaluate the Boolean circuit as follows. An
XOR gate is computed by locally XORing the shares while an AND gate is
evaluated interactively with the help of a multiplication triple [3, 56] which can
be precomputed by two random 1-out-of-2 OTs on bits (cf. §5.1). To reconstruct
the outputs, the parties exchange their output shares. The performance of GMW
depends on the number of OTs and on the depth of the evaluated circuit, since
the evaluation of AND gates requires interaction. For our experiments we use
7
the GMW framework of [56], which is an optimization of the framework of [10]
for the two party case.
3 Random Number Generation
The correct instantiation of primitives in implementations of cryptographic pro-
tocols is a challenging task, since various security properties have to be met. For
instance, an important security property of a pseudo-random generator (PRG)
is its unpredictability, i.e., given a sequence of pseudo-random bits x1...xn, the
next bit xn+1 should not be predictable. If the security property of the primitive
is not met, the security of the overall scheme can be compromised. We found
that this was the case for the FastGC framework in version 0.1.1 [28] that uses
the standard Java Random class in order to generate random values used in the
base OTs, the random choices of vector s and matrix T in the OT extension,
and the input keys of the garbled circuit. Overall, this enables an attack that
allows each party to recover the inputs of the respective other party, as we will
describe now.
3.1 The Java Random Class
The Java Random class implements a so-called truncated linear congruential
generator (T-LCG) with secret seed ψ ∈ {0, 1}48. Random numbers can be gen-
erated by invoking the next method of an object of the Java Random class which
takes as input the requested number of random bits b (for 1 ≤ b ≤ 32), updates
the seed ψ(cid:48) = (αψ + β) mod m, and returns the topmost b bits of ψ, where
α = 0x5DEECE66D, β = 0xB, and m = 248 are public constants. If more than
32 random bits are needed, next is called repeatedly until a suﬃcient number of
bits has been generated.
The security of T-LCGs was widely studied and they were shown to be pre-
dictable [22], even if the generated sequence is not directly output [5]. In case
of the Java Random class, each iteration reveals b bits of the seed, leaving a
remaining entropy of 48 − b bits. Furthermore, consecutive values can be used
to build linear equations.
For our analysis, we assume that the generated random value has at least length
64 bits, i.e., it was generated by two consecutive calls to the next method with
b = 32. This holds for the FastGC framework [28] which uses a Java Random ob-
ject to generate symmetric keys and the columns of the T matrix (we use the ﬁrst
64 bits only). To predict the output of the Java Random object, we recover its
secret seed ψ = ψ1...ψ48 using the 64 bit output d = d1...d64. Since the topmost
32 bits are directly used as output, we have ψ17...ψ48 = d1...d32. In addition,
we have ψ(cid:48)
48 = d33...d64. Now, the remaining lower 16 bits ψ1...ψ16 can be
recovered using the linear equation ψ(cid:48) = (αψ + β) mod m. Speciﬁcally, for each
48) · 216.
of the 216 possible values of ψ we compute (αψ + β) mod m − (ψ(cid:48)
Now, for the correct value of ψ the result will be zero in the 32 most-signiﬁcant
bits and so will be smaller than 216, whereas for all other values it will be larger
17...ψ(cid:48)
17...ψ(cid:48)
8
(with high probability). In practice, this suﬃces for ﬁnding the entire seed ψ in
216 steps, which takes under a second. The recovered secret seed ψ can then be
used to predict the output of the Java Random object.
3.2 Exploiting the Weak PRG in FastGC [28]
We demonstrate how the usage of the Java Random class in version v0.1.1 of
the FastGC [28] framework can be exploited such that the sender can recover
the input bits of the receiver using the T matrix generated in the OT extension
protocol (cf. §2.2), and the receiver can recover the input bits of the sender using
the sender’s input keys to the garbled circuit. We implemented and veriﬁed both
attacks on FastGC, which both run in less than a second. Note that both attacks
are carried out on the honestly generated transcript, as required for the setting
of semi-honest adversaries.
Recovering the Receiver’s Inputs. The sender can recover the receiver’s input
bits using the T matrix, which is chosen randomly by the receiver in the OT
extension (cf. §2.2). Upon receiving the matrix Q = [q1 | . . . | qκ], the sender
knows that qi = ti, if si = 0, and qi = ti⊕ r, if si = 1. Hence, whenever the
receiver has si = 0, the sender obtains qi = ti and can recover an intermediate
seed ψ of the Java Random object that was used to generate this column of T .
Afterwards, the sender computes for j > i consecutive random outputs tj until
he obtains a column qj (cid:54)= tj where sj = 1 which occurs with overwhelming
probability 1 − κ+1
2κ . Now, the sender can recover the receiver’s input bits r by
computing qj ⊕ tj = tj⊕ r ⊕tj = r.
Recovering the Sender’s Inputs. The receiver can recover the sender’s input
bits using the sender’s input keys to the garbled circuit. In FastGC, the sender
generates random symmetric keys ki ∈ {0, 1}κ for each of his (cid:96) input bits bi ∈
{0, 1} using the same Random object. If bi = 0, he sends Ki = ki to the receiver,
else he sends Ki = ki⊕(∆||0), where ∆ ∈ {0, 1}κ−1 is a constant global value [38].
In order to recover the sender’s input bits, the receiver iteratively computes a
candidate for the seed with which Ki was generated, computes the next (cid:96)−i keys
j (i < j ≤ (cid:96)) and checks whether the candidate seed generates a consistent view
k(cid:48)
for the observed values K(cid:48)
j. If bi = 0, then Ki = ki and the receiver knows that
i+2 = Ki+1 ⊕ Ki+2
i+1 ⊕ k(cid:48)
he has recovered the correct seed by ﬁnding either k(cid:48)
if there are at least two more input bits bi+1 = bi+2 = 1 or k(cid:48)
j = Kj if another
input bit is bj = 0. Once the receiver has found such a bi = 0, he can recover
j = Kj (⇒ bj = 0) or not
all subsequent input bits by checking whether k(cid:48)
(⇒ bj = 1). If bi = 1, then Ki = ki ⊕ (∆||0) and the receiver recovers the wrong
i+2 = Ki+1 ⊕ Ki+2 hold with very
seed such that neither K(cid:48)
high probability. Thus, the receiver knows that bi = 1 and repeats the attack for
i + 1. Note that this attack fails if the sender has less than three input bits or all
except the last two input bits of the sender are set to 1. In this case, however, the
receiver can recover the input bits with high probability by using the remaining
κ − 64 bits of the key to check if the candidate seed is correct.
j = Kj nor K(cid:48)
i+1 ⊕ K(cid:48)
9
Securing FastGC [28]. Securing the FastGC framework is relatively easy, since
Java also provides a cryptographically strong random number generator, called
SecureRandom, which by default is implemented based on SHA-1.3 Replacing
all usage of the Random class by SecureRandom increased the runtime of our
experiments in §7 by around 0.5− 4%, depending on the application. A comple-
mentary method to reduce the overhead in runtime is to use our correlated input
OT extension of §5.4 which eliminates the need of generating a random T matrix
s.t. our attack for reconstructing the receiver’s inputs no longer works. Never-
theless, all randomness that is needed (even for our method) must be generated
using SecureRandom.
4 Algorithmic Optimizations
In the following we describe algorithmic optimizations that improve the scalabil-
ity and computational complexity of OT extension protocols. We identiﬁed com-
putational bottlenecks in OT extension by micro-benchmarking the 1-out-of-2
OT extension implementation of [56].4 We found that the combined computation
time of S and R was mostly spent on three operations: the matrix transposition
(43%), the evaluation of H, implemented with SHA-1 (33%), and the evaluation
of G, implemented with AES (14%). To speed up OT extension, we propose to
use parallelization (§4.1) and an eﬃcient algorithm for bit-matrix transposition
(§4.2). Note that these implementation optimizations are of general nature and
can be applied to our, but also to other OT extension protocols with security
against stronger active/malicious adversaries, e.g., [32,49]. As we will show later
in our experiments in §6.2, both algorithmic improvements result in substantially
faster runtimes, but only in settings where the computation is the bottleneck,
i.e., over a fast network such as a LAN.
4.1 Blockwise Parallelized OT Extension
Previous OT extension implementations [10,56] improved the performance of OT
extension by using a vertical pipelining approach, i.e., one thread is associated to
each step of the protocol: the ﬁrst thread evaluates the pseudorandom generator
G and the second thread evaluates the correlation robust function H (cf. §2.2).
However, as evaluation of G is faster than evaluation of H, the workload between
the two threads is distributed unequally, causing idle time for the ﬁrst thread.
Additionally, this method for pipelining is designed to run exactly two threads
and thus cannot easily be scaled to a larger number of threads.
As observed in [24], a large number of OT extensions can be performed by
sequentially running the OT extension protocol on blocks of ﬁxed size. This
3 In response to our ﬁndings, the usage of Random has been replaced with SecureRan-
dom in version 0.1.2 of FastGC.
4 Note that the implementation in [56] performs 1-out-of-4 OT, but we adapted their
implementation since our protocol optimizations in §5 target 1-out-of-2 OT exten-
sion.
10
reduces the total memory consumption at the expense of more communication
rounds.
We propose to use a horizontal pipelining approach that splits the matrices
processed in the OT extension protocol into independent blocks that can be
processed in parallel using multiple threads with equal workload, i.e., each of
the N threads evaluates the OT extension protocol for m
N inputs in parallel.
Each thread uses a separate socket to communicate with its counterpart on the
other party, s.t. network scheduling is done by the operating system.
4.2 Eﬃcient Bit-Matrix Transposition
The computational complexity of cryptographic protocols is often measured by
counting the number of invocations of cryptographic primitives, since their evalu-
ation often dominates the runtime. However, non-cryptographic operations can
also have a high impact on the overall run time of executions although they
might seem insigniﬁcant in the protocol description. Matrix transposition is an
example for such an operation. It is required during the OT extension protocol
to transpose the m × κ bit-matrix T (cf. §2.2), which is created column-wise
but hashed row-wise. Although transposition is a trivial operation, it has to be
performed individually for each entry in T , making it a very costly operation.
We propose to eﬃciently implement the matrix transposition using Eklundh’s
algorithm [14], which uses a divide-and-conquer approach to recursively swap ele-
ments of adjacent rows (cf. Fig. 2). This decreases the number of swap operations
for transposing a n × n matrix from O(n2) to O(n log2 n). Additionally, since
we process a bit-matrix, we can perform multiple swap operations in parallel by
loading multiple bits into one register. Thereby, we again reduce the number of
swap operations from O(n log2 n) to O((cid:100) n
r (cid:101) log2 n), where r is the register size
of the CPU (r = 64 for the machines used in our experiments). Jumping ahead
to the evaluation in §6, this reduced the total time for the matrix transposition
by approximately a factor of 9 from 7.1 s to 0.76 s per party.
Fig. 2. Eﬃcient matrix transposition of a 4 × 4 matrix using Eklundh’s algorithm.
11
1011129141516136785234113111591412161064825371711153812164610142591315 Protocol Optimizations
In this section, we show how to eﬃciently base the GMW protocol on random
1-out-of-2 OTs (§5.1), introduce a new OT protocol (§5.2), outline an optimized
OT extension protocol (§5.3), and optimize OT extension for usage in secure
computation protocols (§5.4).
5.1 GMW with Random 1-out-of-2 OTs
An AND gate in the GMW protocol can be computed eﬃciently using the mul-
tiplication triple functionality [3]: the parties hold no input, and the functional-
ity chooses random bits a0, a1, b0, b1, c0, c1 under the constraint that c0 ⊕ c1 =
(a0 ⊕ a1)(b0 ⊕ b1). Each Pi receives the shares labeled with i. To precompute the
multiplication triples, previous works suggest to use 1-out-of-4 bit OT [10, 56].
In the following, we present a diﬀerent approach for generating multiplication
triples using two random 1-out-of-2 OTs on bits (R-OT). The R-OT functional-
ity is exactly the same as OT, except that the sender gets two random messages
as outputs. Later in §5.4, we will show that R-OT can be instantiated more ef-
ﬁciently than OT. In comparison to 1-out-of-4 bit OTs, using two R-OTs only
slightly increases the computation complexity (one additional evaluation of G
and H and two additional matrix transpositions), but improves the communi-
cation complexity by a factor of 2.
In order to generate a multiplication triple, we ﬁrst introduce the f ab function-
ality that is implemented in Algorithm 1 using R-OT. In the f ab functionality,
the parties hold no input and receive random bits ((a, u), (b, v)), under the con-
straint that ab = u ⊕ v. Now, note that for a multiplication triple c0 ⊕ c1 =
(a0 ⊕ a1)(b0 ⊕ b1) = a0b0 ⊕ a0b1 ⊕ a1b0 ⊕ a1b1. The parties can generate a multi-
plication triple by invoking the f ab functionality twice: in the ﬁrst invocation P0
acts as R to obtain (a0, u0) and P1 acts as S to obtain (b1, v1) with a0b1 = u0⊕v1;
in the second invocation P1 acts as R to obtain (a1, u1) and P0 acts as S to ob-
tain (b0, v0) with a1b0 = u1 ⊕ v0. Finally, each Pi sets ci = aibi ⊕ ui ⊕ vi.
For correctness, observe that c0 ⊕ c1 = (a0b0 ⊕ u0 ⊕ v0) ⊕ (a1b1 ⊕ u1 ⊕ v1) =
a0b0⊕ (u0⊕ v1)⊕ (u1⊕ v0)⊕ a1b1 = a0b0⊕ a0b1⊕ a1b0⊕ a1b1 = (a0⊕ a1)(b0⊕ b1),
as required. A proof sketch for security is given in Appendix B.
Algorithm 1 Random (a, u), (b, v) with ab = u ⊕ v
1: R chooses a ∈R {0, 1}.
2: S and R perform a R-OT with a as input of R.
3: R sets u = xa; S sets b = x0 ⊕ x1 and v = x0.
S obtains bits x0, x1 and R obtains bit xa as output.
[Note that ab = u⊕v as ab = a(x0⊕x1) = (a(x0⊕x1)⊕x0)⊕x0 = xa⊕x0 = u⊕v.]
4: R outputs (a, u) and S outputs (b, v).
12
Proof Sketch In Algortihm 1, a is generated randomly and used as input for
R-OT. R gains no information on b = x0 ⊕ x1, since x0 and x1 are randomly
generated by the R-OT. By the deﬁnition of OT, S gains no information on a
and R gains no information on v.
5.2 Optimized Oblivious Transfer
The best known protocols for oblivious transfer with security in the presence of
semi-honest adversaries are those of Naor-Pinkas [46]. They present two proto-