了目标集，所有序号大于讠的区域组成了稳定集。为了为各种可能的部分回收找到根集，我们为
前所在区域被提升到下一个较高的区域，直到它到达最老的区域，即序号为的区域。
前被填满区域的最高编号。每当一个对象经历了一轮回收（即它被确定为可达的)，它就从它
象分配到这个区域。当0区再次被填满，它的垃圾又被回收，且它的可达对象被拷贝到1区，
时，它的垃圾被回收，且其中的可达对象被移到1区。现在，0区又成为空的，我们继续把新对
们进行编号，序号越小的区域存放的对象越年轻。对象首先在0区域被创建。当这个区域被填
性的有效方法。在世代垃圾回收中，堆区被分成一系列小的区域。我们将用0，1，2,"，n对
7.7.4世代垃圾回收
在的卡片或页，以压缩被记忆集合的表示。
方法。在增量回收中，我们需要在跟踪过程中记录所有对从已扫描对象到未被访问对象的引用
这些对象被认为是可达的。
收的方式工作。现在根集指的不仅是存放在寄存器、栈和全局变量中的对象，它还包括所有指向
是保守地回收那些无法从根集和稳定集到达的对象。因为稳定集中的一些对象自身也是不可达
从技术上来说，区域不会被填满，因为如果需要，存储管理器可以使用附加的磁盘块对它们进行扩展。然而，除
2）根据这种策略，我们只需要记录从较老世代指向较新世代的引用。也就是说，对最年轻
1）因为较年轻的世代往往包含较多的垃圾，也就更频繁地被回收。所以，我们可以将它们
在这个方案中，只要我们对进行回收，所有序号小于i的区域也将进行垃圾回收。有两个
区应用垃圾回收。
之前被拷贝的对象合在一起。这个模式一直被重复，直到1区也被填满为止。此时应对0区和
世代垃圾回收(generational garbage collection）是一种充分利用了大多数对象“英年早逝”的特
部分垃圾回收器通常被实现为拷贝垃圾回收器。通过使用链表来跟踪可达对象，也可以实
被记忆集合(remembered set）。如7.7.2节中讨论的，我们可以只记录下包含了被写人对象
这个引用，要么记录下写入的位置。我们把保存了从稳定对象到目标对象的引用的对象集合
写运算。只要增变者将一个指向某个目标对象的引用保存到稳定对象中时，我们要么记录
写运算。在这里，我们需要记录下增变者的整个运行过程中对从稳定对象到目标对象的引用
踪，以找到所有的可达对象。我们可以忽略所有指向稳定对象的指针，因为在本轮部分回收中
标集对象的稳定集中的对象。从-一个目标对象指向其他目标对象的引用按照以前的方法进行
我们可以修改7.6.1节和7.6.4 节中描述的垃圾回收器，改变“根集”的定义，使之以部分
运行时刻环境
使用7.7.3节中介绍的术语，当区域i及更低区域中的垃圾被回收时，从0到i的区域组月
一般来说，每一轮垃圾回收都是针对序号小于等于某个的区域进行的，应该将选择为
为了找出那些引用了目标对象的稳定对象，我们可以采用和增量垃圾回收所用技术类似的
了最后一个区域，其他区域的尺寸通常都有一个界限。我们将把到达这一界限称为“填满”。
315
成
称
回
---
## Page 332
照词典顺序进行排序：首先以列车号排序，在同一列车中则以车厢号排序，如图7-30所示。
厢被组织成列车(train)。一辆列车中的车厢数量没有限制，且列车的数量也没有限制。车厢之间按
以是一个磁盘块，否则可以将车厢的尺寸设得更大。但是车厢的大小一旦确定就不再变化。多节车
们在使用引用计数进行垃圾回收时碰到的问题。
如果我们从没有进行过一轮包括了i和j的回收，那么我们就会碰到循环垃圾的问题，也就是我
这个循环结构将被完全包含在正在被回收的堆区中，我们就可以确定它是否真的是垃圾。然而，
结构。一般来说，这里显示的对象之间的“链接”可能涉及很多对象和一条很长的引用链。
收这两个对象。然而，它们可能实际上是一个循环垃圾结构中的一部分，没有外部链接指向该垃圾
其中j>i。因为这两个对象都有来自其区域之外的指针，只对区域i或只对区域j进行回收都不能回
必须偶尔进行一轮全面的垃圾回收。图7-29 给出了位于两个区域i和”中的两个相互连接的对象
不需要进行全面的垃圾回收过程，而在世代垃圾回收中却仍然必须偶尔那样做。
仍然存在，才将它们提升到另---个由列车算法管理的堆区。列车算法的另一个优点是我们永远
但是更好的方法是使用世代方法来处理年轻的对象，只有当这些对象经历了几轮世代回收之后
被称为列车算法的增量式回收方法用于改进对成熟对象的处理。它可以用来回收所有的垃圾。
个垃圾回收过程涉及某个成熟对象时，该对象都会被移动，而且它们不太可能变成垃圾。另一种
7.7.5列车算法
骤，因此也会在程序运行时引人较长时间的停顿。接下来将讨论另一种只处理成熟对象的方法。
最昂贵的，因为它相当于一次完整的回收。也就是说，世代回收器偶尔也需要执行完整的跟踪步
时间进行一次回收，以删除不可达对象。最老的世代保存了最成熟的对象，对这些对象的回收是
有较年轻世代的回收，同时它们包含的垃圾也相应减少。虽然如此，较老世代还是需要每过一
进行垃圾回收的效费比特别高。对较老世代的垃圾回收则要花更多的时间，因为它包括了对所
不得不同时记录从较年轻世代指向较年老世代的引用。
对某个区域进行回收，但是不回收某个较年轻的世代，那么后者将成为稳定集的一-部分。我们将
列车算法使用固定大小的被称为车厢(car)的区域。当没有对象比磁盘块更大时，一-节车厢可
为了描述列车算法的动机，我们首先看一个简单的例子。该例子告诉我们为什么在世代方法中
尽管世代方法在处理年轻对象时非常高效，但它在处理成熟对象时却相对低效，因为每当
总而言之，这种方案更频繁地回收较年轻的世代，并且因为“对象英年早逝”，对于这些世代
316
在世代垃圾回收中，我们最终会回收区域j，并且因为i<j，我们同时还会回收i区域。那么
列车3
列车2
列车1
图7-29一个跨越区域的可能是循环垃圾的环状结构
区域
图 7-30
车厢31
车厢21
车厢11
列车算法中的堆区组织
车厢32
车厢22
车厢12
车厢33
-—
车厢23车厢24
···
区域
第7章
段
---
## Page 333
整节车厢都将消失，因此不必回收它们的空间。
收车厢之外的对象。在这次跟踪之后，该车厢中的某些对象可能被确定为垃圾。因为无论如何
达集包括了该车厢中被来自根集的引用指向的对象，以及被该车厢的被记忆集中的引用指向的
循环垃圾，因此将在下一轮垃圾回收时被回收；要么其中的垃圾不是循环的，那么它的车厢就
同类型的被记忆集。
车的被记忆集是它内部的所有车厢的被记忆集的并集，但是不包含列车内部的引用。因此，可以
组成，这些引用来自：
对象。然后，我们像标记－清扫式回收器那样扫描这些对象，但是不会扫描任何可达的位于被回
新
建
向
以被逐个回收。
地
车
厢。然而，算法中的两种垃圾回收过程分别处理第一-辆列车的第一节车厢和整个第一辆列车
新对象放人其中。
将被加到最后一个车厢之后的新车厢中。然而，我们会定期新建--列只有一节车厢的列车，并
创建的对象一般会被放置在这节车厢中；如果该车厢中没有足够空间，该对象就会被放到一个
k个对象之后就新建一辆列车。也就是说，当最后一辆列车的最后车厢中还有足够的空间时
一辆列车中加人新的车厢。但是，我们偶尔也需要创建出新的列车。例如，我们可以设定每
管理被记忆集，只要增变者改变了任何对象中的引用，就需要相应地改变被记忆集。
三厢或者列车。因此记录下指向较高序号车厢的引用没有什么意义。当然，我们必须认真、正确
此，当在垃圾回收中需要使用被记忆集的时候，已经没有更早的地方可以有引用到达被处理的
运行时刻环境
列车算法的核心是我们如何在一轮垃圾回收中处理第一辆列车的第一节车厢。一开始，可
因为对一辆列车中的车厢数目没有限制，每当我们需要更多空间时，在原则上我们可以直接
单节车厢的垃圾回收
我们的目标是找出第－辆列车中所有非循环垃圾的对象。此时，第一辆列车要么只包含
管理列车 
注意，指向这些对象的引用可以来自各个地方，不只是来自按字典顺序排列的序号较高的车
2）序号较高的列车中的对象。
1）同一辆列车中序号较高的车厢中的对象，以及
此外，每辆列车有一个被记忆集，它由来自较高序号列车中的引用组成。也就是说，--个列
现在我们给出列车算法的细节。每节车厢有一个被记忆集，它由指向该车厢中对象的引用
被记忆集
列车算法有两种回收垃圾的方式：
辆列车。
列车的引用。在这种情况下，该列车就是一个巨大的循环垃圾集合，我们可以删除整
针，并且各节车厢中的被记忆集中只有来自本列车的其他车厢的引用，没有来自其他
有时，第一辆列车没有外部引用。也就是说，没有从根集指向该列车中任何车厢的指
中删除。
记忆"列表，所以这一步类似于世代算法中针对第一-个区域的回收步骤。这里我们确定比
尚存的第一节车厢)首先被回收。因为我们保留了一个来自该车厢之外的所有指针的“被
在--个增量式垃圾回收步骤中，按照词典顺序排列的第一节车厢（即尚存的第一辆列车中
是被移至其他的某个车厢中，因此每个被回收过的车厢都变成空车厢，可以从这辆列车
317
创
三
总
---
## Page 334
们。同时假设我们使用写关卡来保证没有可达对象被当作垃圾。在开始时，A 和 B 在 Unscannel
行管理。当扫描一个对象时，如果有多个对象要被放进这个列表中，我们按照字母顺序加人官
7. 7. 67. 7 节的练习
恐慌模式，继续正常处理，确保当前的第一辆列车一定要比以前小。
只要不是移到第一辆列车，移到哪辆列车并不重要。
点中设置的哑引用，那么即使该对象没有来自其他列车的引用，我们还是将它移至另一-辆列车。
个新成员。
辆列车中。在这种“恐慌模式”下，我们做出两个变化：
所谓无效垃圾回收是指，在回收一节车厢时没有一-个对象可以作为垃圾删除或者被移动到另一
险：有可能一直只对当前的第--辆列车进行垃圾回收。
被全部移出。然而，有可能在某个阶段我们根本回收不到任何垃圾，这样就会存在出现循环的风
解决了，因为没有新的对象会被加人到第一辆列车中，所以第一辆列车中的所有对象最终一定会
列车的引用，就会出现上述问题。只要在回收一节车厢时有一个对象从这个列车中移出，问题就
变者改变引用的方式使得我们在回收一节车厢时一直没有在被记忆集中看到任何来自较高序号
永远不能继续处理另一辆列车？
况，-一辆列车的每一个回收步骤都产生一节新车厢，以致于我们永远不能回收完这辆列车，结果
因为第一节车厢中的所有对象一定能够被一起放到最后的新车厢中。然而，是否会出现这种情
第一节车厢时可能会产生一个位于最后的新车厢。这个过程不会创建出两个或更多的新车厢，
被删除，且该列车每次至少会减少一节车厢。然而，根据上面的第二个规则，回收第一辆列车的
车迟早会变成第一辆列车，并且如果这辆列车不是循环垃圾，那么此列车中的所有车厢最后都会
规则如下：
按照这个方法，如果有一个指向第一辆列车的对象的引用来自该列车之外，在我们回收每节
练习7.7.1：假设图7-20 中的对象网络由一个增量式算法进行管理。该算法和 Baker 算法一
2）在进行垃圾回收时，如果第--节车厢中的--个对象有来自根集的引用，其中包括在第！
1）当指向第一辆列车中的某个对象的某个引用被覆写时，我们将这个引用保留为根集的一
为了避免出现这个问题，只要我们遇到一个无效(futie)垃圾回收，我们就需要改变做法。
遗憾的是，这种情况是可能出现的。如果我们有一个大型的、循环的非垃圾的结构，并且增
然而，该车厢中很可能还有一些可达对象，这些对象必须被移到其他地方。移动一个对象的
318
恐慌模式
在从第一节车厢中移出了所有可达对象之后，我们就可以删除这节车厢。
·如果被记忆集中有一个来自其他列车的引用(该列车的序号高于被回收车厢所在列车的
个车厢中。
末端。如果有可能，挑选有一个指向该对象的引用的车厢，以尽快把循环结构放到同一
象移到同一列车中的其他车厢中。如果没有足够空间，就创建一个新的车厢放到列车的
如果没有来自其他列车的引用，但是存在来自根集或第一辆列车的引用，那么就将此对
进人一个新的、最末端的车厢。
能够找到足够的空间，就将该对象移动这辆列车的某节车厢中。如果找不到空间，它就
序号），那么将这个对象移到这些列车中的某一辆中。如果在发出一个引用的某辆列车中
第7章
---
## Page 335
型，在并行计算过程中协调多个线程。
行的本质会带来一些新的实现问题。我们将讨论这个算法如何使用一个相当常见的工作队列模
间。这个算法在本质上并没有引人新的有关垃圾回收的基本概念，它说明了我们如何将曾经描
大部分的跟踪工作，然后执行一个全面停顿式的步骤来保证找到所有的可达对象并回收存储多
器使用多个线程，我们就称其为并行的（parallel）。如果回收器和增变者同时运行，就说它
性
7.8.1并行和并发垃圾回收
7.8垃圾回收中的高级论题
这个引用被覆写了。当我们对车厢11进行垃圾回收时，0会发生什么事情？
略号)。当前我们处于恐慌模式。车厢 11中的对象01只有一个来自车厢12 中的对象02的引用。
收，对象最后在什么地方？
略号)。有来自车厢12、23 和32 的引用指向车厢11中的对象0。当我们对车厢11进行垃圾回
被放在了列表 Free 中？‘
列表中，假设下列事件发生：
送
并
增
的思想组合起来，创造出一个解决并发、并行的垃圾回收问题的完整解决方案。然而，并行执
发的（concurrent）。
曾变者。堆区通常会包含几千兆的存储。
生。对于服务器应用，在同一时刻运行成千上万个线程是常有的事情；其中的每个线程都是一个
我们将描述一个并行的且基本上并发的垃圾回收器。它使用一个并发且并行的阶段来完成
运行时刻环境