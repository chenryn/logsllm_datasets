计为给用户一个月的下拉列表(一月到十二月)。在这种情况下，登录的用户应该只输入 12
个值中的一个，因为他们通常不应该输入任何文本，而是简单地选择预定义的下拉值之一。
如果接收此表单的服务器遵循了安全编码实践，它通常会审计表单字段是否与 12 个允许值
中的一个匹配，然后认为它是有效的。如果表单字段不匹配，它将返回一个错误，并可能在
服务器中记录一条消息。这可以防止攻击者利用这个特定的字段，但是这不太可能阻止攻击
者，他们会转移到其他表单字段。 
在这种情况下，我们可以获得的信息比我们记录的要多。我们已经向用户返回了一个错
误，并且可能在服务器上记录了一个错误。事实上我们知道得更多：经过身份验证的用户输
入了一个无效值，这是他们在正常使用中永远无法做到的(因为这是一个下拉列表)。 
这可能有几个原因: 
⚫ 
软件有缺陷，用户没有恶意。 
⚫ 
攻击者窃取了用户的登录凭据，并试图攻击系统。 
⚫ 
用户已经登录，但带有试图攻击系统的病毒/特洛伊木马。 
⚫ 
用户已经登录，但正在遭受中间人攻击。 
⚫ 
用户无意恶意，但通过某种浏览器插件改变了值，等等。 
 如果是上面的第一种情况，那么公司应该知道它以修复他们的系统。如果是情况 2、3
或 3，则应用程序应该采取一些措施来保护自己和用户，例如减少用户可用的功能(即，PII
259 
不可见，不能更改密码，不能执行金融交易)或强制进一步的身份验证，如安全问题或带外
身份验证。系统还可以提醒用户意外输入被发现的事实，并建议他们运行防病毒等。从而在
攻击进行时阻止攻击。 
显然，在限制用户功能或警告用户这是一个诚实的错误时必须小心，所以应该使用风险
评分或注意会话警告。例如，如果浏览会话中一切正常，1 个字符不合适，则显示一个红色
弹出框说明用户被黑客攻击是不合理的，但是如果这不是用户的通常 IP 地址，他们在不寻
常的时间登录，而且有 5 个异常字符，看起来像是 SQL 注入字符串，则应用程序做出反应
是合理的。这种可能的反应需要在法律文件中说明。 
 在另一种情况下，如果攻击者已经通过应用程序防御提取了应用程序客户数据库的一
部分，公司会知道吗？从效率的角度来看，将数据库中的信息拆分成单独的表是有意义的，
但从安全的角度来看，将机密信息放入单独的分区也会使攻击者更加困难。但是，如果攻击
者掌握了信息，就很难检测到，应用程序应该采取措施来帮助警报软件(例如，SIEM 系统)。
许多金融机构使用风险评分系统来查看用户会话的元素以给出风险评分，如果约翰尼总是在
星期四下午 6 点从同一个 IP 登录，那么我们就有了一个可信的模式。如果约翰尼在早上 2:15
突然从世界另一端的一个 IP 地址登录，在 7 次弄错密码后，那么他可能在长途旅行后时差
反应，或者他的账户被黑客攻击了。无论哪种方式，要求他进行带外身份验证都是合理的，
可以允许约翰尼登录，或者阻止攻击者使用约翰尼的帐户。 
 如果应用程序从更大的角度来看，它可以确定在正常情况下，3%的用户以被认为是更
危险的方式登录，即，不同的 IP 地址，不同的时间等。如果周四看到这个数字上升到 23%，
那么用户群是不是发生了什么奇怪的事情，或者数据库被黑了？此类信息可用于对 23%的
260 
“高风险”用户实施全面的带外身份认证(以及日志内部调查)，从而将用户的风险分值与应
用程序的整体风险分值结合起来。 
 另一个好的选择是“蜂蜜账户”，这是用户名和密码，永远不会给用户。这些帐户就
像任何其他用户一样被添加，并存储在数据库中，但是它们也记录在一个特殊的缓存中，并
在登录时进行审计。因为它们从来没有给过任何用户，所以任何用户都不应该使用它们登录，
但是如果使用了其中一个帐户，那么唯一知道用户名和密码组合的方法就是攻击者获得数据
库，并且该信息允许应用程序进入更安全的状态，并警告公司数据库已被黑客攻击。 
4.5.2  审计什么 
从安全警报的角度查看代码模块时，需要注意的一些常见问题包括: 
⚫ 
应用程序会知道它是否受到攻击吗？它是否忽略无效输入、登录等。或者它记录它
们并监控这种状态，以获取系统当前风险的累积感知？ 
⚫ 
应用程序能否自动更改其日志记录级别以应对安全威胁？更改安全级别是动态的
还是需要重启？ 
⚫ 
软件开发生命周期要求或设计文档是否记录了构成安全警报的内容？这个判定是
否经过同行评议？测试周期是否贯穿这些场景？ 
⚫ 
系统是否使用“蜂蜜账户”，这样应用程序就可以知道数据库是否受到损害？ 
⚫ 
是否有基于风险的评分系统，记录用户的正常使用情况，并允许在风险增加时进行
判断或做出反应？ 
⚫ 
如果正在使用 SIEM 系统，是否已经确定了适当的触发因素？是否创建了自动化测
试来确保这些触发日志消息不会被未来的增强或错误修复意外修改？ 
261 
⚫ 
系统是否跟踪用户经历了多少次失败的登录尝试？系统对此有反应吗？ 
⚫ 
某些功能(即，交易启动、更改密码等)根据应用程序当前运行的风险分值有不同的
运行模式？ 
⚫ 
当安全风险分值降至正常水平时，应用程序能否恢复到“正常”操作？ 
⚫ 
当安全风险得分上升时，管理员如何得到警报？或者当违约已经被认定，在操作层
面，是否定期测试？人事变动是怎么处理的？ 
4.6 审计主动防御 
在应用层进行的攻击检测可以访问用户交互的完整上下文和关于用户的详细信息。如果
在代码中应用逻辑来检测可疑活动(类似于应用程序级入侵防御系统)，那么应用程序将知道
什么是高价值问题，什么是噪音。输入数据已经在应用程序中被解密和规范化，因此特定于
应用程序的入侵检测不太容易受到高级规避技术的影响。如果选择适当的检测点，这将导致
非常低水平的攻击识别误报。 
 基本要求是能够执行四项任务: 
1.  检测一系列可疑和恶意事件。 
2. 集中使用这些知识来识别攻击。 
3.  预定义供选择的响应。 
4. 响应的执行。 
262 
4.6.1 描述 
应用程序可以采取一系列响应，其中可能包括高风险功能，如更改用户帐户或应用程序
防御姿态的其他更改。在动态分析中很难检测到主动防御，因为测试人员可能看不到响应。
代码审计是确定这种防御存在的最好方法。 
其他应用程序功能，如身份验证失败计数和锁定，或对文件上传速率的限制，是“本地
化”的保护机制。在本文中，这种独立的逻辑“不是”主动防御的等价物，除非它们被组装
到一个应用范围的传感网络和集中的分析引擎中。 
它不是一个固定的工具或代码库，而是为组织提供了一种方法来指定或开发他们自己的
实现——特定于他们自己的业务、应用程序、环境和风险概况——建立在现有的标准安全
控制之上。 
4.6.2  审计什么 
在使用代码审计来检测防御存在的情况下，它的缺失应被视为一个弱点。请注意，主动
防御不能防御具有已知漏洞的应用程序，因此本指南的其他部分极其重要。代码审计者应该
注意到缺少主动防御是一个漏洞。 
代码审计的目的不一定是确定主动防御的有效性，而可能只是确定这种能力是否存在。 
检测点可以集成到应用程序的表示层、业务层和数据层。特定于应用程序的入侵检测不
需要识别所有无效的用法，就能够确定攻击。不需要“无限数据”或“大数据”，因此“检
测点”的位置在源代码中可能非常稀疏。 
识别此类代码的一个有用方法是找到用于检测可疑活动的专用模块的名称(如 OWASP 
AppSensor)。此外，公司可以基于米特的常见攻击模式枚举和分类(Mitre’s Common 
263 
Attack Pattern Enumeration and Classifcation ：CAPEC)、字符串(如 CAPEC-212、
CAPEC-213 等)来实施标记主动防御检测点的策略。 
OWASP 应用传感器检测点类型标识符和 CAPEC 代码通常用于配置值(例如，
[https://code . Google . 
com/p/appsensor/source/browse/trunk/AppSensor/src/test/resources/.esapi/ESA
PI.properties？对于 Java 在 ESAPI 中 r = 53)，参数名和安全事件分类。此外，审计错误
日志记录和安全事件日志记录机制，因为它们可能被用来收集数据，然后用于攻击检测。确
定执行此日志记录的代码或调用的服务，并审计记录/发送的事件属性。然后确定这些调用
的所有地方。 
审计与输入和输出验证相关的错误处理代码很可能会发现检测点的存在。例如，在白名
单类型的检测点中，可能已经在错误处理代码流附近或内部添加了额外的代码: 
在某些情况下，攻击检测点正在寻找列入黑名单的输入，否则测试可能不存在， 
if ( var !Match this ) { 
Error handling 
Record event for attack detection 
} 
所以需要全新的代码。检测点的识别还应找到记录事件的位置(“事件存储”)。如果找
不到检测点，请继续审计代码以执行响应，因为这可能会提供对主动防御存在的证明。 
必须实时或非常频繁地分析事件存储，以便根据预定义的标准识别攻击。应该在配置设
置中定义标准(例如，在配置文件中，或者从另一个源如数据库中读取)。一个进程将审计事
件存储，以确定攻击是否正在进行，通常这将试图识别经过身份验证的用户，但它也可能考
虑单个 IP 地址、IP 地址范围或用户组，如一个或多个角色、具有特定权限的用户甚至所有
264 
用户。 
一旦确定了攻击，将根据预定义的标准选择响应。同样，对配置数据的审计应该揭示与
每个检测点、检测点组或总阈值相关的阈值。 
最常见的响应操作是用户警告消息、注销、帐户锁定和管理员通知。然而，当这种方法
被连接到应用程序中时，响应动作的可能性只受到应用程序的编码能力的限制。 
任何全局搜索代码都包括上述轮询攻击识别/响应。响应动作(同样是用户、IP 地址、用
户组等)通常由应用发起，但是在某些情况下，其他应用(例如，更改欺诈设置)或基础架构组
件(例如，阻止一个 IP 地址范围)也可以发起。 
审计配置文件和应用程序执行的任何外部通信。 
以下类型的响应可能已编码: 
⚫ 
Logging 增加 
⚫ 
管理员通知 
⚫ 
其他通知(例如，其他系统) 
⚫ 
代理 
⚫ 
用户状态变化 
⚫ 
用户通知 
⚫ 
时间变化 
⚫ 
流程终止(与传统防御相同) 
⚫ 
功能禁用 
265 
⚫ 
帐户注销 
⚫ 
账户锁定 
⚫ 
从用户处收集数据。 
应用程序和相关系统组件的其他功能可以重新调整用途或扩展，以提供选定的响应操作。
因此，请查看与任何本地化安全措施(如帐户锁定)相关的代码。 
4.6.3  参考 
在 WASP_AppSensor_Project 中给出的向应用程序添加主动响应的指南类别:企业安
全应用编程接口-https://code.google.com/p/appsensor/应用传感器演示代码 
4.7 竞争条件 
当一段代码不能正常工作时(像许多安全问题一样)，就会出现竞争情况。它们是事件的
意外顺序的结果，这可能导致代码的状态转换到未定义的状态，并且还会引起多个执行线程
对同一资源的争用。多个执行线程对内存或持久数据中的相同区域进行操作，这将导致完整
性问题。 
4.7.1  描述 
如果资源没有使用步锁或利用一个基于令牌的系统（如信号量），由于竞争任务操作相
同的资源，我们可以很容易地得到一个竞争条件。例如，如果有两个进程(线程 1，T1)和(线
程 2，T2)。线程中的代码将 10 加到一个整数 x 上。X 的初始值是 5。 
X = X + 10 
在多线程环境中，如果没有围绕此代码的控件，代码可能会遇到以下问题: 
266 
T1 将 X 放入线程 1 的寄存器中，T2 将 X 放入线程 2 的寄存器中 
T1 将 T1 寄存器中的值加 10，得到 15，T2 将 T2 寄存器中的值加 10，得到 15，T1
将寄存器值(15)保存到 X 中。 
T1 将寄存器值(15)保存到 x 中。 
该值实际上应该是 25，因为每个线程在初始值 5 的基础上增加了 10。但是实际值是
15，因为 T2 没有让 T1 在取值为 X 之前保存到 X 中。 
这将导致未定义的行为，即应用程序处于不确定状态，因此无法准确实施安全性。 
4.7.2  审计什么 
在 C#. NET 中寻找使用多线程环境的代码 
⚫ 
Thread 
⚫ 
System.Threading 
⚫ 
ThreadPool 
⚫ 
System.Threading.Interlocked 
⚫ 
在 Java 代码中，寻找 java.lang.Thread 
⚫ 
java.lang.Thread 
⚫ 