-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-D
-D
-
-
-
-
-
-
-D
-D
-D
-D
-D
-D
-
-
-
-
-
-
-
-
-
-
-
-
-G
-G
-G
-G
-D
-D
-
-
-
-
-
-
-
-
-
-
D
D
M
M
MM
MM
IM
IM
S
S
B
B
V
V
US
US
UB
UB
UV
UV
-
-
-
-
-
-
-
-
-
-
-G
-G
-GDGGG
-GDGGG
-GGG
-GGG
-G
-G
-GDGGD
-GDGGD
-G
-G
-G
-G
-D
-D
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-DDDDD
-DDDDD
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-D
-D
-
-
-
-
-
-
-
-
-
-
-
-
GGGGGGGGGGGGGGGGGGGG
GGGGGGGGGGGGGGGGGGGG
-GGGGG
-GGGGG
-
-
-GGGDG
-GGGDG
-
-
-GGGG
-GGGG
G
G
(a) With the DTD
(b) Without the DTD
Table 2: Results of Static Analysis of XMark Queries
-G
-G
-
-
-
-
-
-
-
-
-
-
-
-
-G
-G
-G
-G
-G
-G
-
-
-
-
-G
-G
-G
-G
-
-
-
-
-
-
-
-
-
-
-
-
-G
-G
-GD
-GD
D
D
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-D
-D
-
-
-
-
-
-
-
-
-
-
D
D
no access
access without
runtime access check
access with runtime
access check
tion 4, we over- and under-estimate the access control au-
tomata in order to perform the static analysis.
Queries Made Efﬁcient. For each query/role pair, we check
whether or not our static analysis removes the runtime ac-
cess check. We perform the experiment for two cases: one
case with the DTD and the other case without the DTD. We
statically analyze all the XPath expressions for each query.
Recall that if an XPath expression in the query is always-
denied, we rewrite the query.
Tables 2(a) and 2(b) show the results of our static analysis
with and without the DTD, respectively. Each entry in the
table indicates the result by either “G”, “D”, or “−”.
• “G” indicates that all XPath expressions in the query
are always-granted.
• “D” indicates that at least one of the XPath expres-
sions in the query is always-denied, while all other ex-
pressions are always-granted.
• “−” indicates that at least one XPath expression in
the query is statically indeterminable.
A query marked by “G” contains no XPath expressions re-
quiring the runtime access check. If a query is marked by
“D”, it contains XPath expressions that always fail their
runtime access checks. However, in this case, we rewrite
such expressions as null lists in advance. As a result of this
rewrite, the runtime access check becomes unnecessary. Fi-
nally, if queries are marked by “−”, the result of the runtime
check is not predictable, and must be performed.
For example, we can read from Table 2(a) that the mark
of Query #4 for role IM is “D”. This means that when a
user ﬁlling a role IM makes Query #4, we ﬁrst rewrite the
query so that it can be evaluated without the runtime access
check.
Tables 2(a) and 2(b) show that 65% and 40% of the que-
ry/role pairs, respectively (i.e., “G” + “D”), do not require
the runtime access check. Furthermore, for 25% and 10% of
the query/role pairs (i.e., “D”), we can optimize queries by
rewriting.
From Table 2(b), we conclude that even when no DTDs
are available, our static analysis can result in signiﬁcant op-
timization of the query. From from Table 2(a), we conclude
that the analysis can be further reﬁned by exploiting DTD
information. Note that the sample policy contains XPaths
with predicates, which cause over- and under-estimation of
the access control automata. Even in such a case, our static
3500
3000
2500
2000
1500
1000
s
e
d
o
t n
n
a
v
le
f re
r o
e
b
m
u
n
500
0
M
M IM S B V
M
S
U
B
U
V
U
role
Figure 5: Nodes Exempted from Access or Runtime
Access Check
analysis frequently makes runtime access checks unneces-
sary.
Nodes Exempted from Access or Runtime Access Check.
Here we consider how much cost of query evaluation is re-
duced by our static analysis and query optimization. As
the metric of reduced cost, we count the number of nodes
exempted from access or runtime access check by our static