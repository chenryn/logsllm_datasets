PDG
---
## Page 289
第7章
远程内核漏洞利用面临的挑战
本章主要内容
·利用远程漏洞
·执行第一条指令
·远程payload
引言
相比本地的内核漏洞利用，远程内核漏洞利用在很长一段时期内避开了公众视线（至少在
公开渠道上）。第一个公开的远程内核漏洞利用的例子要追溯到2005年，来自eEye数字安全的
BarnabyJack发布了一篇名为“RemoteWindowsKernelExploitation-StepintotheRingO”的文章，
这篇文章对赛门铁克个人防火墙的一个远程内核漏洞利用进行了详细分析。
短短几年，这种情况就发生了巨大变化。每一个主要的操作系统都至少有了一个远程
内核漏洞利用的目标。举例来说，OpenBSD的座右铭是成为“在默认的安装中只有两个远
之后），而Windows、Linux和MacOSX的无线设备驱动程序也成为各种远程漏洞的温
本章反复出现了stager和stage两个词。它们都是代码片段，服务于payload。但stager更为小巧和简洁，由
于远程利用环境的限制，可能无法直接传送。stage，这就需要先传送一个stager在攻击者和目标主机间建立
一个连接，然后再传送stage来实现更多的功能。一译者注
Barnaby Jack,“RemoteWindowsKernel Exploitation-Stepinto the RingO,”http://research.eeye.com/html/
papers/download/StepIntoTheRing.pdf(accessed 06.22.10)
eEye Research,“SymantecMultipleFirewallRemoteDNSKERNELOverflow”http://research.eeye.com/html/
advisories/published/AD20040512D.html(acccssed06.22.10).
AlfredoOrtega,“Only twoRemote holes in the default install”http://ortegaalfredo.googlepages.com/
OpenbsdPresentation.pdf(accessed06.22.10)
---
## Page 290
第7章远程内核漏洞利用面临的挑战281
床。并且，当一篇分析一个具体的漏洞利用类型的论文发表之后，这些技术就会广泛传播。
例如，skape，HDMoore和JohnnyCache基于一系列Windows无线驱动的问题，写了一篇关
于Windows远程内核利用的文章并发表在一本不出名杂志的e-zine上（2006年年底），作者
UNIX世界（具体是Linux）。远程内核漏洞利用已经不再神秘。虽然还有很多人觉得它神奇非
凡，但远程内核漏洞利用已成为现实。
大多数情况下，远程内核漏洞利用比本地内核漏洞利用更为复杂，就像写远程用户态漏洞
利用要比写本地漏洞利用复杂一样。另一方面，尽管内核级别的反漏洞利用保护的数量有限，
但是用户态的保护正变得更加严密。单凭这一点，就使得探索漏洞利用技术来寻找目标内核漏
洞这一过程变得十分有趣。
为了与本书中其他部分保持一致，本章主要关注方法和理论。喜欢从代码人手的读者可以
跳到第8章，那里将按我们的方式有步骤地开发出一个针对Linux内核的、可靠的并可一次性
通过的远程内核漏洞利用。
利用远程漏洞
远程漏洞攻击和本地漏洞攻击区别不大。事实上，在代码级别，它们并没有什么区别。内
存损坏还是内存损坏，逻辑bug也还是逻辑bug。我们第2章的所有的分类也同样适用于远程
利用的情况。同时，触发漏洞背后的大量理论（比如，在slab漏洞利用中，定位一个靠近溢出
对象的目标）也是基本相同的。因此，读者自然而然会想，远程漏洞利用到底有什么重大的区
别，以至于本书专门用一章来讨论这个主题。
缺少公开信息
“远程利用”的定义首先指出了上述问题的答案。在定义一个漏洞利用为远程漏洞利用时，
是指可以通过网络来对一个系统执行指令而不需要直接访问它。从某种程度上说，远程的漏洞
利用是一种旨目的攻击。对于攻击者来说，大量目标信息被简单地隐藏起来。如果是本地漏洞
利用，可以利用诸如输出标志、分配统计和结构相关的入口（比如：中断描述符表（IDT），可
以通过SIDT用法说明获得它的地址）等信息来实施攻击，这些信息大多数时候对开展攻击都
很重要，而远程漏洞攻击则没有这些信息。内核不会给远程的攻击者暴露任何这类的信息，我
们也不能直接地询问底层的结构。内核标志不同，方法也将完全不同。尽管我们没有办法去查
DavidMaynor,JohnnyCache,“Device Drivers(don't build a house on shakyfoundations)”www.blackhat.com/
presentations/bh-usa-06/BH-US-06-Cache.pdf[accessed 06.22.10].
Eriksson-Janmar/Whitepaper/bh-eu-07-eriksson-WP.pdf[accessed06.22.10]
sgrakkyu,madwifiWPA/RSNIEremotekernelbufferoverflow”www.milworm.com/exploits/3389[accessed06.22.10]
Johnny Cache,HDMooreskape,“Exploiting802.11WirelessDriverVulnerabilitiesonWindowshttp://uninformed
org/?v=6&a=2&t=txt(accessed06.22.10).
---
## Page 291
282第三部分远程内核漏洞利用
询内核运行时关于函数和变量的地址（比如：Linux上的/proc/kallsyms），但是基于对远程运行
的内核镜像鉴别的精确程度，可以推测它们的地址。
提示传统意义上，对于远程系统的利用以收集被利用主机的相关数据开始：哪些端
口是打开的，什么服务和哪个版本的服务是可获得的，运行的是什么操作系统，是否
有可获取的网站等。在这一步骤中，一个用户态利用携带的攻击和基于内核的攻击并
没有太大的不同，它们集中在鉴别远程目标的应用和操作系统的版本和结构。间接暴
露的信息的重要性也不可低估。举例来说，像“Poweredby...”这样的字或者HTTP
详细的错误信息都可能暴露有关目标内核版本的关键信息。
事实上，内核通常都在固定的地址载入它们的代码和数据段，这个固定的地址常常是在编译
的时候决定的。这样做的主要原因是为了简化启动操作（从内存管理的各个方面来说，处理已知的
固定的内存范围要比随机的更加容易，尤其是在启动的时候）、调试和保证不会内存越界（比如：
一个设备的地址空间间隙或者一些其他的结构限制）。这个事实提供了一些我们感兴趣的暗示：
·第一，假定我们能足够精确地指出远程内核版本（利用自定义编译内核时的异常），就
能够在本地复制同样的环境，并载入我们需要的地址硬编码（和测试）。换句话说，我们
能够下载同样的镜像，检查那里的标志，由于内核的载入地址是可以预知的，可以计算
出远程目标在虚拟内存中的地址。
·一部分内存（比如，内核的头部，或者一些在启动时使用的静态的结构）包含一些可以预知的内
容，而且这些内容在一些版本中也不会改变位置。我们感兴趣的一系列返回的伪代码（比如：一
为了帮助分析，表7.1列出了本书涉及的操作系统的内核核心组件载入的地址。
表7.1不同操作系统的内核核心载入地址
操作系统
32位×86
64位x86-64
Linux
OxC0100000
0xFFFFFFFFF8100000
Solaris
OxFE800000
OxFFFFFFFFFB800000
MacOSX(Leopard)
0x111000
/
WindowsServer2003
0x8080000
0xFFFFF80001000000
如表7.1所示，几乎所有的目标默认使用一个固定的、可预测的地址。唯一例外的就是
Windows最近发布的版本（从Vista/Server2008开始）一—没有显示在表7.1中，它的启动地
址每一次都是随机的。下面的程序切片显示了几个在连续重启WindowsServer2008R264位机
器时，ntoskrnl.exe镜像载入的地址。
ntoskrnl.exebaseimageaddress:0xfffff80001616000
ntoskrnl.exebaseimageaddress:0xfffff80001655000
ntoskrnl.exebaseimageaddress:0xfffff80001612000
自定义编译内核，虽然任何开源的内核都是可能的，但是自定义编译内核也仅现于Linux世界（甚至在
Linux世界，很多主机也使用发行版编译的内核来简化更新操作）。
---
## Page 292
第7章远程内核漏洞利用面临的挑战283
内核代码段和数据段不是我们唯一能够依靠的静态范围/地址。另外一个能引起我们极
大兴趣的是所谓的1:1直接映射。多数的内核都会在系统的物理页面上保持一个1：1的映射。
从一个给定的虚拟地址开始，系统上所有可利用的物理帧一个接一个地映射上去。举个例子，
一个Linux上的函数phys_to_virt（）。这个函数负责获取一个物理地址和返回一个虚拟映射
地址：
staticinlinevoid*phys_to_virt(phys_addr_taddress)
return_va(address):
define—va（x)
(（void*)（(unsignedTong)(x)+PAGE_OFFSET))
definePAGE_OFFSET（（unsignedlong)_PAGE_OFFSET)
#define_PAGE_OFFSET_AC(CONFIG_PAGE_OFFSET,UL)
#define__PAGE_OFFSET_AC(Oxffff880000000000,UL)
如上所示，phys_to_virtO获取一个物理地址然后简单地在获取的物理地址上加一个
PAGE_OFFSET。对于32位的内核，OxC0000000是一个典型的CONFIG_PAGE_OFFSET值，
而在64位系统上，这个地址明确定为0xFFFF880000000000。
当没有公开信息时，这两个例子阐述了如何寻找信息的大体思路，那就是利用操作系统
内核的知识去寻找一个固定的地址和可能固定的内容。这些地方可能成为恶意篡改的目标（远
程利用最有力的形式），或者在一些复杂的情况下，成为基于面向返回编程（ReturnOriented
Programming，ROP）利用的入口。通过后面章节的介绍，我们还将见到其他操作系统中具体
的区域，比如Linux的vsysca11页面和WindowsShareduserData节。
缺少对远程目标的控制
第二个问题在于我们对远程用户态进程的控制有限，而本地的内核攻击起初就是使用这
些进程来实现的。当专注于理解各种内核攻击技术的细枝末节时，很容易忽略获得一个用户态
进程支持的重要性，特别是在用户/系统地址空间结合的情况下。还记得我们创建一个特定的
hocO_DIRECT映射来确保获得一个页面错误吗？或者将shellcode存储在进程映射里，然后再
设法控制合适的（比如：可执行的）保护位和计算它的位置吗？
的O_DIRECT例子），也给了我们一个容易的方案来解决执行第一条指令（判定返回地址）的
问题。即使是在用户/系统地址空间分离的例子中，用命令行对“合适”的进程进行控制能使
我们容易地存储shellcode和返回，而且不用考虑由于控制操作（如按顺序分配许多文件描述
符），直接影响内核行为（如耗尽SLAB缓存）。
在远程的情况中，以上方法就不太适用。尽管在理论上还是有可能在用户/系统组合地
分实用。
---
## Page 293
284第三部分远程内核漏洞利用
提示继续我们对固定地址和固定内容的探索，进程代码段一在异常的环境中使用
位置无关的可执行文件（PIEs）或者其他随机的形式运行—又加载到一个固定的地
址并以一个可以预见的二进制头（比如：ELF）开始。这种内存可能再次成为另一个
潜在的安全地址用于回跳，就像之前章中的例子说明的。
因此，我们面临的一个关键问题是：如何执行第一个payload指令？这实际上是远程利用
的主要问题，因为我们一旦获得执行控制，就能使用复杂的payload来发现和使用我们需要的
地址，从而实现一个成功的利用。这些情况在那些提供一个适当的位来标记页面为不可执行的
结构中（在我们的例子中，页面地址扩展[PAE]x86-64和x86-32被标记为可用）变得尤其复
杂，因为存放shellcode的地方是用于接收网络包的缓存，通常会被标记为不可执行。下一节
“执行第一条指令”将仔细分析我们选择的两种架构上的可能的解决方案，涉及x86-32位read
implies-execute（读一理解一执行）语义和x86-64位NX环境。
注意值得指出的是，比起本地的例子，我们在远程的例子里，更多的是发现自己处
在没有任何支持的进程来触发漏洞的情境中，也就是通过中断上下文来利用一个漏
洞。在“远程payload”一节，我们将探讨一些成功地避开中断上下文并迁移到不同
情境中的payload的技术。
执行第一条指令
执行payload中的第一条指令是远程（和强化（hardened））情况中的关键问题。总的说
来，就是要找到可以执行的内存，然后把我们的payload存在里面并执行。显然，这还包括
知道这个内存地址。第一步，找到一些可以执行的内存，这在x86-32位的架构上是相当容易
的，对payload来说，最合适的地方就是接收特定网络包的内核缓存，而且我们还能够从那里
去执行它。
然而在x86-64架构上，就不一样了，许多授权存储“数据”的区域都被正确地标记成为
了不可执行。尽管从在私有地址空间采取“最少页保护”的原则来看，内核并不是无懈可击，
然而存放我们payload的缓存有可能是不能执行的。这无疑对远程漏洞利用构成了非同寻常的
挑战，基本上只能够利用可以进行任意篡改类型的漏洞。
我们首先从如何利用“直接指令流重定向”的情况（经典函数指针/保存的P重定向）开始分析，
这主要在x86-32架构上讨论。之后将更详细地讨论在x86-64架构上的进行任意篡改的问题。
直接执行流程重定向
直接执行流程重定向是指破坏一个指针，然后用它来获取一条执行指令。导致这种情景
这不完全令人吃惊：内核利用依然是被看做“新生事物”，同时，由于在多数的操作系统中，返回到用户态的
shellcode还没有被遏制，所以到目前为止，并没有造成很大的压力，以便让操作系统去修复这些区域。
由于这两个结构之间的主要区别是有没有合适的页面保护位，所以基本上所有我们谈到的关于64位的情况
都适用于32位。
---
## Page 294
第7章远程内核漏洞利用面临的挑战285
的经典案例是栈溢出（重写保存的返回地址或某些局部函数指针）和堆溢出（重写内部相邻对
象的函数指针）。因为这里关注的是x86-32下的情况，所以可以使用缓冲区溢出来存储我们的
shellcode。唯一的问题是如何才能找到它在内存中的地址。事实上，在栈和堆的例子中，我们
并不知道接收我们包的缓冲区在虚拟内存空间中的位置。（或者，在一般情况下，缓冲区的位
置会因为我们的包而溢出到目标指针上。）
简单观察一下就能得到解决方案。尽管我们不知道缓存的位置，但是一些结构上的组件
（比如：寄存器）可能会有它的地址或者附近的值。这在栈的情况中尤其如此，当执行RET指
令后，栈指针将恰好指向重写指令指针的后面。如果我们能够到达存储的EIP°，就可以废弃
多一点的内存，从而控制ESP（栈指针）指向的地址数据了。如图7.1所示。
如果您熟悉用户态基于栈的攻击，您就知道我们现在到了哪一步：如果不熟悉的话，我们
将要讨论跳转指令序列了。
跳转指令序列是一个或多个指令集，它将执行流转移给寄存器中的一个值。在x86的结构
下主要有3种形式：
.CALL
将控制转交给中指定的地址。CALL指令将当前的指令指针压栈，这是一些在
payload回复/清理部分必须要考虑到的事情。
·JMP
跳转到指定的地址。没有其他影响。
·PUSH，RET
这个顺序基本上是模拟一个过程返回。想要跳转的地址被压栈（就如CALL做的），然后调
用RET指令，它将控制转交到跳转的地址。也可以认为这个序列也是没有其他影响的。
如图7.1中，在RET的右边，ESP指向了重写指令指针的第一个字节。
警告调用约定的方式会影响我们的方法，我们必须精心设计每一步骤。C调用约定
规定由调用者将参数压入栈。
pushs0x3
push%ebx
callsome_func
add
$0x8，%esp
微软stdcall调用约定有明确的参数调用：
push
$0x3
push
%ebx
call
some_func
[...]