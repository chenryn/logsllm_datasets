## Page 250
无回路网络是这类函数的复合面数。例如，合并三个已排序的输
输入序列的结构递归定义这类函数，但不能考虑空输人序列。例
性进程。通道看作是通道上传递的可下断增长的消息序列。可由
7.3.3函数式多道处理
速响应而不是大量计算的情况下，实在不宜使用。
Hamming的间题，按升序输出非平凡素数因子为2，3或5的全
图7.1为这个函数的网络示意图。
入流的函数是
如，将每个输入的数乘以n，并输出结果的进程，可定义为
merge2(leftl,left2) =
将输人通道映象为输出通道的数学函数，可以用来定义确定
else if left2o^merge2(left1,left 2')
有回路网络则可由递归方程组定义。例如，Dijkstra 提供给
if left!o^merge2(leftl',left2)
prodn(left)=^prodn(left')
merge3(left1,left2,left3)=
merge2(leftl,merge2(left2,left3))
merge2
merge3
else^merge2(leftl',left2')
图7.1
mcrge2
227
---
## Page 251
其理山为
7.3.4无缓冲通信
再由进程merge3排序，见图7.2。
和5×x也是这类数字。用进程proda,prods,prod产生这些乘积；
也放松了（3）和（4）的限制。
（4）所有进程都是确定的。
（2）输到缓存中的每个值要一直保存到所有输人进程都取到它
（1）实施时，一般要求所有通道都有无界缓冲装置。
法有很大区别，即
体数字。第一个这样的数字是1，若x是这类数宇，则2×x，3×x
228
多年来，我选用无缓冲（同步）通信作为基本的通信方式。
近年来的研究已部分解决了（1）和（2）引起的低效率问题，
不允许进程等待两个输入之一，而且取任一个先到者。
后，才能删去。
多处理机网络的函数式表示方法，在下列方面和本书中的方
Hamming=
所求雨数是无输入的：其定义为
(1>^merge3(prod,(Hamming),prods(Hamming),
prods
prod,
prod,
prods(Hanming))
图7.2
11
merge3
---
## Page 252
同的进程的名字不同，缀在进程之前，用一对冒号隔开，如
就用通信顺序进程作为标题。那个早期的建议和本书相比较，有
7.3.5通信顺序进程
用命合α?x输人这个值。进程名字是局部于它们所出现的并行组
进程P中的命合bu，将值输向名字为的进程。进程Q中则
（1）并行组合
两个重要的不同。
认，而每个输入后跟之输出一个确认。
了；同步亦可用其实现，只需在每个输出后跟之以输人一个确
原始通信方式，则不必严格要求子程序调用和返回必须交替出现
连接两个进程，共-一用其输人，另－·用其输出。但在实用和理论
念。而且在逻辑上就不会破坏对通道的下远限制，即一个通道只
（4）
(3)
（1)
方面也有缺点。
合，
）这和用电线作为物理介质连接通信体是相配的。而电线是不
）7.3.2节结尾处提及的缓存的缺点，也是不选用的理由。
我第一次全面解释一种基于并发和通信的程序设计语言时，
当然这些理由不能使人绝对信服。例如，若以缓冲通信作为
抖行组合中分进程间的通信是被藏匿的。
需要缓冲时，可用进程实施；而且缓冲的深度亦可由程序员
的效果是相当的。
这和在单处理器中，
能存消息的。
这种写法的优点是，在语言中不必引入通道或通道申明的概
早期的通道没有名字。而拜行结构的分进程却具有名字，不
严格控制。
[a:·P!b::Q|.|.::R]
，用拷贝参数和结果，调用子程序并返回
229
---
## Page 253
缩排。
不使用插人式的算子符，而使用前缀式运算，它不用括号，而用
助于语法检查编辑程序，可在屏幕上组合occam的语法对象；它
严格遵循本书中提出的各个原则。最大的不同只是记号而已；借
7.3.60ccam
定；对更复杂的情形，采用了别的方法（见6.4节）。
也更为复杂。在4,5节中，我放宽了简单附戚进程必须终止的限
SIMULA和PASCALPLUS的已被实践证明的十分有用的特征。
止。这样，附庸进程在终止前就可完成必要的终止化工作；这是
自动终止的条件是，向它输出消息的进程，如进程a,b，…，都终
止时必须通知其附庸进程。这样就引进了一个特别的约定，即循
为满意。）附进程必须终止的规定造成的后果是，使用进程终
望却从未得到满足，而其它证明方法，见1.10节，现在看来是更
性，也就是在进程成功终止时，某个谓词应该为真。（这个希
理由是，希望能用传统程序设计中的后置条件来描述进程的正确
（2）自动终止
(ii）数学上的缺点是，并行组合不再是一个可结合的二元算
230
不同于Ada，occam 是一种非常简单的程序设计语言，非常
这个约定增加了定义和实施的困难；程序正确性的证明方法
早期版本中，并行命合中的所有进程都应终止。这个规定的
子，而是一个带有可变多个参数的运算了。
名宇；这就使建立附庸进程库的工作很复杂。
SEQ
*[a?x-Pb?x-→Q…·]
d
表示(P;Q;R)
---
## Page 254
量。例如，简单的拷贝进程可申明为
输入输出通道上的通信来实现。为此，过程申明中可以通道为参
的进程（6.4节）的专用记号。各种通信方式都用通道名字相同的
时间后才能被选用。
尔条件所限制：若代之以等待，则该分支只能在度过规定的某段
上述的输入命令亦可用SKIP 替代，这时该分支的选择完至由布
尔条件B限制某分支的选用，如
occam中没有关于导管（4.4节），附庸进程（4.5节），和共享
ALT对应于Ada中的挑选语句，并提供类似的花样。可用布
PROG copy(GHAN left,right) =
WHILEB表示（B*P)
IF
ALT
PAR
c?x
ION
d? y
6
P
B&o?x
B
P
表示(PB≠Q)
表示（o？x→→Pd？y→Q)
表示（PIQIR)
231
---
## Page 255
而两单位的缓存COPY>COPY 则由
用递归过程。
的，故上例中的值n必须是一个常数。由于同样的原因，也不能
由于occam是在个数确定的处理器上，用静态存储分配技术实施
指标为；的n－1个进程，
的一种累接形式所构成！
构成。1+1个缓存的链，
232
为得到附庸式进程，也需用类似的构造，
PROC double(left,right)=
CHAN mid[n-1]:
WHILE TRUE
WHILE TRUE
PAR
VARx:
copy(mid[n-1],right)
copy(left,mid[o])
VARx:
PARi=[o FORn-2]
CHAN mid:
，这种并行累接形式构成自0至n－2间的
SEQ
copy(mid[i],mid[i+ 1])
则可用一个n个通道的数组，并行结构
right!x:
SEQ
PAR
left?x
right1(x+x):
leftix
copy(mid,right)
copy(left,mid)
如
---
## Page 256
程为
一个新的数据，就输出迄今输入的所有数据的和数。合所要的进
进程使用通道数组的一个元素。例如，设计一个积分器，每输人
在P中，将数加倍的方法是
这个程序可由单个用后进程P申明为其附庸进程，如
句。当然，程序员必须保证他的程序的逻辑正确性是和优先级的
即选用，则写在最前面的分支被选用；其它方面的效用如ALT语
也提供类似的优先级安排，即有PRIALT。若有多个分支可立
屏幕编辑程序还提供重排进程优先级的编辑命合。对ALT构造，
只要将PAR换成PRIPAR，则位置在前的进程有较高优先级。
用通道数组及ALT的累接形式可实现共享的进程，每个用片
类似于Ada，
CHAN doub.left,doub,right:
CHAN add,integral[n-I]:
doub.leftl4sdoub.right?y;.….
occan中亦可对行组合中的进程设置优先级，
PAR
PAR
VAR sum,x:
double(doub,teft,doub.right)
SEQ
ALT i=[0 FOR n]
stm:=0 
add[i]?x
PARi=[0 FOR n]
SEQ
integral[i!sum
..-user processes...
sum:= sm+x
233
---
## Page 257
语义。数学语义给予语营一种安全的、无歧义的、精确的、稳定
针和程序中通道的对应的手段，包括规定输入程序的插针。
设置无关的。
他定义了表达式间的一系列等价关系，其中最重要的有
架。他以表达式的基本语法为起点，表达式用于表示进程，然后
研究的目标是给出在不同描象程度上构造和比较不同模型的框
7.4.1
本书中的数学模型给上述问题以肯定回答。
（3）理论上是否可以输出命合构造卫式？·
（2）如果可以，则能否用递归过程并行地调用自已？
（1）是否可在并行命合中嵌套另一并行命合？
结果很多重要的设计问题无法解决，例如
Euclid和Gypsy的描远中就朵用了这一建议。
一组正确的证明规则，而不是一个清晰的数学模型。PASCAL，
程序员履行保证其程序正确性的义务。R.W.Floyd提出，语义是
那些计量。
学语义是语言标准化的关键，就如同螺栓螺母标准化中所用到的
口。它也是声称不同的实施都实现了同一语言的必要的依据。数
的描述；这种描越可用作语言的用户及实施者双方同意的一种接
234
另有在处理器间分配进程的手段，以及规定处理器的物理捕
强等价
并发性的数学模型的主要突破是由Robin Milner完成的。
通信顺序进程早期的设计（见7.3.5节）中没给出数学语义，
60年代后期，人们发现了数学语义更重要的作用，它有助于
在60年代初，人们就认识到程序设计语言应该有精确的数学
1通信系统演算CCS
7.4数学模型
---
## Page 258
的，图7.3中的树是各不相同的。
这些对应并不确切，因为出t所定义的CCS 的非确定性是非结合
个完整的CCS 语言。
为类似的不发散进程的区别。我认为，这就不可能有效地实施一
的)好处是能执行的无界序列的进程不一定都能归约到CHAOS；
用特殊符号表示一个隐匿的事件或者一个内部的转移。使用这
比记法上的不同更为重要的差别是在隐匿的处理上。在CCS中，
到的模型作为进程间相等的最基本的定义。
每一种等价关系定义并发性的·-个模型。CCS 通常以观察同余得
这样就可区分发散进程。但是CCS不能分辨可能发散的进程和行
从而保证解的唯一性，见2.8.3节的说明。另一个（但不很重要
个记号记录隐匿事件的痕迹的好处是，可用其构造卫式递归方程，
CCS不以门为原始操作。但可用t模拟非确定性，如
CCS 的基本记号解释如下
观察同余
观察等价
(t,P)+(a.Q)
(t,P)+(t,Q)
NIL
(a.P)+(b.Q)