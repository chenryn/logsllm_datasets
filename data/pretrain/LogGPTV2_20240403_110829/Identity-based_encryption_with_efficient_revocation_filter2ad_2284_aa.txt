title:Identity-based encryption with efficient revocation
author:Alexandra Boldyreva and
Vipul Goyal and
Virendra Kumar
Identity-based Encryption with Efﬁcient Revocation
Alexandra Boldyreva∗
School of Computer Science
Georgia Institute of
Technology
Atlanta, GA
PI:EMAIL
Vipul Goyal†
Virendra Kumar‡
Dept. of Computer Science
University of California at Los
School of Computer Science
Georgia Institute of
Angeles
Los Angeles, CA
PI:EMAIL
Technology
Atlanta, GA
PI:EMAIL
ABSTRACT
Identity-based encryption (IBE) is an exciting alternative to
public-key encryption, as IBE eliminates the need for a Pub-
lic Key Infrastructure (PKI). The senders using an IBE do
not need to look up the public keys and the corresponding
certiﬁcates of the receivers, the identities (e.g. emails or IP
addresses) of the latter are suﬃcient to encrypt. Any set-
ting, PKI- or identity-based, must provide a means to revoke
users from the system. Eﬃcient revocation is a well-studied
problem in the traditional PKI setting. However in the set-
ting of IBE, there has been little work on studying the re-
vocation mechanisms. The most practical solution requires
the senders to also use time periods when encrypting, and
all the receivers (regardless of whether their keys have been
compromised or not) to update their private keys regularly
by contacting the trusted authority. We note that this solu-
tion does not scale well – as the number of users increases,
the work on key updates becomes a bottleneck. We pro-
pose an IBE scheme that signiﬁcantly improves key-update
eﬃciency on the side of the trusted party (from linear to log-
arithmic in the number of users), while staying eﬃcient for
the users. Our scheme builds on the ideas of the Fuzzy IBE
primitive and binary tree data structure, and is provably
secure.
Categories and Subject Descriptors
E.3 [Data]: Data Encryption
General Terms
Algorithms, Security
∗
†
Supported in part by NSF CAREER award 0545659.
Supported in part from grants from the NSF ITR and Cy-
bertrust programs (including grants 0627781, 0456717, and
0205594), a subgrant from SRI as part of the Army Cyber-
TA program, an equipment grant from Intel, a Microsoft
Research Fellowship, an Alfred P. Sloan Foundation Fellow-
ship, and an Okawa Foundation Research Grant.
‡
Supported in part by the grant of the ﬁrst author.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’08, October 27–31, 2008, Alexandria, Virginia, USA.
Copyright 2008 ACM 978-1-59593-810-7/08/10 ...$5.00.
Keywords
Identity-based encryption, revocation, provable security
1.
INTRODUCTION
1.1 Motivation
Identity (ID)-based encryption, or IBE for short, is an
exciting alternative to public-key encryption, which elimi-
nates the need for a Public Key Infrastructure (PKI) that
makes publicly available the mapping between identities,
public keys, and validity of the latter. The senders using an
IBE do not need to look up the public keys and the corre-
sponding certiﬁcates of the receivers, because the identities
(e.g. emails or IP addresses) together with common public
parameters are suﬃcient for encryption. The private keys
of the users are issued by a trusted third party called the
private key generator (PKG). Ideas of identity-based cryp-
tography go back to 1984 and Shamir [25], but the ﬁrst IBE
scheme was constructed by Boneh and Franklin only in 2001
[7], building on the progress in elliptic curves with bilinear
pairings.
Any setting, PKI- or identity-based, must provide a means
to revoke users from the system, e.g.
if their private keys
get compromised. In a PKI setting a certiﬁcation authority
informs the senders about expired or revoked keys of the
users via publicly available digital certiﬁcates and certiﬁcate
revocation lists.
As a solution to this problem for IBE, Boneh and Franklin
[7] suggested that users renew their private keys periodically,
e.g. every week, and senders use the receivers’ identities
concatenated with the current time period, e.g. “week 15 of
2008”. Notice that since only the PKG’s public key and the
receiver’s identity are needed to encrypt, and there is no way
to communicate to the senders that an identity has been re-
voked, such a mechanism to regularly update users’ private
keys seems to be the only viable solution to the revocation
problem. This means that all users, regardless of whether
their keys have been exposed or not, have to regularly get
in contact with the PKG, prove their identity and get new
private keys. The PKG must be online for all such transac-
tions, and a secure channel must be established between the
PKG and each user to transmit the private key. Taking scal-
ability of IBE deployment into account, we observe that for
a very large number of users this may become a bottleneck.
We note that alternatively, in order to avoid the need for
interaction and a secure channel, the PKG may encrypt the
new keys of non-revoked users under their identities and
the previous time period, and send the ciphertexts to these
users (or post them online). With this approach, for every
non-revoked user in the system, the PKG is required to per-
form one key generation and one encryption operation per
key update. We note that this solution, just as the original
suggestion, requires the PKG to do work linear in the num-
ber of users, and does not scale well as the number of users
grow. The goal of the paper is to study this problem and
ﬁnd solutions to alleviate it.
1.2 Related work
Eﬃcient revocation is a well-studied problem in the tradi-
tional PKI setting, e.g. [19, 22, 1, 21, 20, 12, 13]. However
in the setting of IBE, there has been little work on studying
the revocation mechanisms. Hanaoka et al.
[16] propose a
way for the users to periodically renew their private keys
without interacting with the PKG. Each user updates the
keys locally with the help of a special secret key contained
in a device that is assumed to be physically-secure. We,
on the other hand, consider a setting where all secret key
information of a user can be compromised.
Revocation has been studied in the ID-based setting with
mediators [6, 18].
In this setting there is a special semi-
trusted third party called a mediator who holds shares of all
users’ private keys and helps users to decrypt each cipher-
text. If an identity is revoked then the mediator is instructed
to stop helping the user. But we want to focus on a much
more practical standard IBE setting where users are able to
decrypt on their own.
The goal of broadcast encryption is to prevent revoked
users from accessing secret information being broadcast. The
broadcast encryption solutions, however, and in particular
ID-based broadcast encryption ones, do not directly trans-
late into solutions for our problem. In broadcast encryption,
a non-revoked user can help a revoked user gain access to
the sensitive information being broadcast (since this infor-
mation is the same for all parties). On the other hand, in
the IBE setting a revoked user, or the adversary holding its
private key, should not be able to decrypt messages even if
it colludes with any number of non-revoked users.
Thus, to the best of our knowledge, the solution proposed
by Boneh and Franklin in [7] remains the most practical user
revocation solution in the IBE setting.
1.3 Contributions
We propose a new way to mitigate the limitation of IBE
with regard to revocation, and improve eﬃciency of the pre-
vious solution. We want to remove interaction form the
process of key update, as keeping the PKG online can be a
bottleneck, especially if the number of users is very large. At
the same time we do not want to employ physically-secure
devices and we want to signiﬁcantly minimize the work done
by the PKG and users.
First we deﬁne the Revocable IBE primitive and its secu-
rity model that formalizes the possible threats. The model,
of course, takes into account all adversarial capabilities of
the standard IBE security notion. I.e. the adversary should
be able to learn the private keys of the users with identi-
ties of its choice, and in the case of chosen-ciphertext attack
to also see decryptions under the private key of the chal-
lenge identity of the ciphertexts of its choice. The adversary
should not be able to learn any partial information about
the messages encrypted for the challenge identity. In addi-
tion we consider the adversary having access to periodic key
updates (as we assume this information is public) and being
able to revoke users with IDs of its choice. The adversary
should not be able to learn any partial information about
the messages encrypted for any revoked identity when the
ciphertext is created after the time of revocation (i.e.
for
the ID containing the time past the revocation time).
We show that it is possible to reduce the amount of work
a PKG has to do for key updates and the total size of key
updates to logarithmic in the number of users, while keeping
the key update process non-interactive, and encryption and
decryption eﬃcient.
Our idea is to build on the Fuzzy IBE construction by
Sahai and Waters [24]. The Fuzzy IBE primitive provides
some sort of error-tolerance, i.e. identities are viewed as sets
of attributes, and a user can decrypt if it possesses keys for
enough of (but not necessarily all) attributes a ciphertext is
encrypted under. At the same time, colluding users cannot
combine their keys to decrypt a ciphertext which none of
them were able to decrypt independently.
We propose to combine the Fuzzy IBE construction from
[24] with the binary tree data structure, which was previ-
ously used to improve eﬃciency of revocations in the PKI
setting [22, 1]. In order to decrypt a ciphertext encrypted
for an identity and time period the user must possess the
keys for these two attributes. The PKG publicly posts and
regularly updates the keys for the current time attribute.
Even though the time attributes are the same for all users,
this does not have to compromise security, thanks to the
collusion-resistance property of Fuzzy IBE. To reduce the
size of key updates from linear to logarithmic in the num-
ber of users, the binary tree data structure is used. Here
we employ a trick to modify the Fuzzy IBE scheme in such
a way that collusion of some users (corresponding to non-
revoked users in our scheme) on some attributes (i.e. time
attribute) is possible. We provide more details and present
the full construction in Section 4.
While our scheme provides major computation and band-
width eﬃciency improvements at the stage of key update, it
also permits eﬃcient encryption and decryption. We show
that our scheme provably guarantees security assuming the
decisional bilinear Diﬃe-Hellman (DBDH) problem is hard,
which is a quite common assumption nowadays (cf. e.g. [4,
24, 26, 15]).
We also show two ways to address chosen-ciphertext at-
tack. Our ﬁrst solution is to modify our scheme by ad-
ditionally employing a strongly-unforgeable one-time signa-
ture scheme in a manner somewhat similar to that from [8,
15]. We also show that it is possible to employ the Fujisaki-
Okamoto (FO) transform [10, 11]. Security of the latter
solution relies on the random oracle model [2], but unlike
the former solution, it is generic, in that it can be applied
to any Revocable IBE scheme.
Since the existing Fuzzy IBE schemes are only secure in
the weaker selective-ID model [9], where the adversary has
to declare the challenge identity up front, with the above
approach we can only achieve selective-ID security as well.
We leave it as an interesting open problem to achieve full
security without such limitation.
We note that senders in our scheme, just like in a regular
IBE scheme, do not need to know anything besides the iden-
tities of the intended receivers and the current time period
in order to encrypt a message. The information posted by
the PKG is only for the receivers to update their secret keys.
Finally, we note that the problem of revocation is equally
important for Fuzzy IBE and attribute-based encryption
(ABE) [15] schemes. While the same periodic key update
solution due to Boneh and Franklin applies, it similarly lim-
its scalability. We show that it is possible to extend our
techniques to provide eﬃcient non-interactive key update to
Fuzzy IBE and ABE schemes.
2. NOTATION AND CONVENTIONS
$← S; . . . ; sn
If S is a ﬁnite set then s
$← S as a shorthand for s1
If κ ∈ N then 1κ denotes the string consisting of κ con-
secutive “1” bits. We denote by φ the empty set. If x, y are
strings then x(cid:3)y denotes the concatenation of x and y, and
we assume that x and y can be eﬃciently and unambigu-
ously recovered from x(cid:3)y.
$← S
denotes that s is selected uniformly at random from S . We
$←
will often write s1, s2, . . . , sn
$← S. When describing algorithms, a ← b
S; s2
denotes that a is assigned the value b. If A is a randomized
$← A(i1, i2, . . . , in) denotes
algorithm and n ∈ N, then a
that a is assigned the outcome of the experiment of run-
ning A on inputs i1, i2, . . . , in. If A is deterministic, then we
drop the dollar sign above the arrow. If S = {s1, s2, . . . , sn},
then {xs}s∈S denotes the set {xs1 , xs2 , . . . , xsn}. An adver-
sary is an algorithm. By convention, the running-time of
an adversary includes that of its overlying experiment. All
algorithms are assumed to be randomized and eﬃcient (i.e.
polynomial in the size of the input), unless noted otherwise.
In the rest of the paper κ ∈ N is the security parameter,
n(·) denotes a polynomial in κ, but for simplicity we use the
notation n.
3. REVOCABLE IBE AND ITS SECURITY
3.1 Syntax of Revocable IBE
Definition 3.1. [Revocable IBE] An identity-based en-
cryption with eﬃcient revocation or simply Revocable IBE
scheme RIBE = (S,SK,KU, DK,E ,D,R) is deﬁned by se-
ven algorithms and has associated message space M, iden-
tity space I and time space T . We assume that the size of
T is polynomial in the security parameter. Each algorithm
is run by either one of three types of parties - key authority,
sender or receiver. Key authority maintains a revocation list
rl and state st. Revocation list rl can be part of state st,
but we keep it explicit for clarity. In what follows, we call
an algorithm stateful only if it updates rl or st. We treat
time as discrete as opposed to continuous.
• The stateful setup algorithm S (run by key authority)
takes input security parameter 1κ and number of users
n, and outputs public parameters pk, master key mk,
revocation list rl (initially empty) and state st.
• The stateful private key generation algorithm SK (run
by key authority) takes input public parameters pk,
master key mk, identity ω ∈ I and state st, and out-
puts private key skω and an updated state st.
• The key update generation algorithm KU (run by key
authority) takes input public parameters pk, master key
mk, key update time t ∈ T , revocation list rl and state
st, and outputs key update kut.
• The deterministic decryption key generation algorithm
DK (run by receiver) takes input private key skω and
key update kut, and outputs decryption key dkω,t or a
special symbol ⊥ indicating that ω was revoked. (We
say an identity ω was revoked at time t if revocation
algorithm R was run by key authority on input (ω, t, rl,
st) for any rl, st.)
• The encryption algorithm E (run by sender) takes in-
put public parameters pk, identity ω ∈ I, encryption
time t ∈ T and message m ∈ M, and outputs cipher-
text c. For simplicity and wlog we assume that ω, t are
eﬃciently computable from c.
• The deterministic decryption algorithm D (run by re-
ceiver) takes input decryption key dkω,t and ciphertext
c, and outputs a message m ∈ M or, a special symbol
⊥ indicating that the ciphertext is invalid.
• The stateful revocation algorithm R (run by key au-
thority) takes input identity to be revoked ω ∈ I, revo-
cation time t ∈ T , revocation list rl and state st, and
outputs an updated revocation list rl.
The consistency condition requires that for all κ ∈ N and
polynomials (in κ) n, all pk and mk output by setup algo-
rithm S, all m ∈ M, ω ∈ I, t ∈ T and all possible valid
states st and revocation lists1 rl, if identity ω was not re-
voked before or, at time t then the following experiment
returns 1 with probability 1:
$← SK(pk, mk, ω, st)
$← KU (pk, mk, t, rl, st)
(skω, st)
kut
dkω,t ← DK(skω, kut)