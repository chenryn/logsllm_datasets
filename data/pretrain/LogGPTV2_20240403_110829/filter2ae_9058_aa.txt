（接上文）
**入口点逆向分析**
* * *
在第一篇文章中，我们已经给出了数据库的定义，现在，我们再来回顾一下。数据库是一组二进制文件，用于存放结构化数据和相互之间的交叉引用。现在，我们只对定义的第一部分感兴趣，即文件中的数据是结构化的。这里的结构属性，则意味着文件是具有相同格式的记录组成的。例如，文件catalogue的单个记录用于描述单个车辆。因此，在定义一个记录的格式后，就会自动定义所有记录的格式。换句话说，对于上图来说，只要弄清楚了Bob
Cat ML
1980相关的字节的含义，就足以理解所有其他车辆相关字节的含义。但是，文件实际上很少仅包含单种类型的记录，实际上，它们通常是由多个表组成的，并且不同的表通常存放的是不同格式的记录。
如何对记录格式和文件格式进行逆向分析？所有针对文件格式的逆向分析技术都适用于该任务（回想一下第一篇文章中抽象级的层次结构，当时已将数据库逆向分析置于顶部）。实际上，这些技术的面世时间已经很长了（具体参见文章末尾的参考文献部分），下文中我们将用到它们。
对文件进行逆向分析时，第一步就是确定文件中表的数量。为此，可以通过观察不同格式的相邻记录来完成这一任务。我们以grpinc.dat文件为例。请查看下面的屏幕截图，其中两种记录格式的区别是非常明显的，我们可以轻松区分开来。
其中，四个彩色的记录可能与表1相关，其后的纯文本则可能与表2相关。表1中每个记录的大小为0x3A字节。但是，表2中的记录的大小则是未知的，也许所有这些文本都只是单个硕大的记录。不过，我们可以得出这样的结论：grpinc.dat文件包含2个表，即包含两种不同的记录格式。这只是一个非常简单的例子。有时您可能遇到具有高熵的二进制文件，这时，我们就只能通过某些字节模式的消失/出现来确定从一个表到另一个表的切换情况。然而，这时只靠肉眼来区分就有点难度了。
现在，让我们回到catalogue文件。查看整个文件后，我们没有发现任何对比明显的数据：开头和结尾部分都有车辆名称。
FNAc.dat文件的开头部分
FNAc.dat文件的结尾部分
接下来，我们需要确定单个记录的大小。为此，我们需要找出相应的模式，并计算两个相邻模式的间距。下面，让我们来看一个具体的例子。让我们在catalogue文件的开头部分寻找重复出现的信息。需要注意的是，这里谈论的是信息的含义，而不是那些重复的字节内容。就这里来说，重复出现的信息是车辆名称，即以“!CAT”开头的字符串和以“VL”开头的字符串。实际上，这里共有三种不同的模式，现在，让我们取其中一种模式，即车辆名称模式，然后计算第一个和第二个车辆名称之间的间距。
这里的间距是0x800-0x0 =
0x800。因此，文件catalogue中保存的记录的大小为0x800字节。这是一种非常重要的文件格式逆向分析技术，我们应该熟练掌握它（当然，其他的非也应该熟练掌握）。另外，其实没有必要采用最前面两个或最后面两个记录来计算模式之间的间距。当确定位于文件中间部分的记录的大小时，即使不知道记录的起始字节在哪里，仍然可以设法计算出它们之间的间距。
现在，是将这些结果记录下来的时候了。下面，我们将使用前一篇文章中提到的Kaitai
Struct来描述文件格式。如果将来需要以编程方式处理文件的话，可以使用KS支持的编程语言轻松地将文件格式的描述转换为相应的代码。到目前为止，我们对catalogue文件的了解，仅限于其记录的大小，因此，我们将其内容视为原始字节来对待。
    meta:
      id: catalogue
      file-extension: dat
      endian: le
      encoding: ascii
    seq:
      - id: vehicle
        type: vehicle
        repeat: eos
    types:
      vehicle:
        seq:
          - id: unk_1
            size: 0x800
Kaitai Struct有一个可视化工具，名为ksv，具体显示如下。
接下来，您需要逐步调查记录字段，而不是一次考察单个大字段（在我们的示例中为0x800字节）。为此，有许多方法可用，但是具体取决于字节的异构性。在我们的例子中，您可以看到几乎所有字节都是字符串字符，因此，我们可以将一个字符串从其开头到下一个字符串的开头之间的内容划分为单个字段。完成该操作后，我们将得到如下所示的记录格式。
让我们分析每个字段。从记录开头到最后一个空格字符之间的第一个0x64字节，名为vehicle_name_1，其内容为汽车名称。接下来的两个字节（0x0026）可能是一个单独的字段，但其含义目前还不清楚，因此，我们将其命名为unk_1。那么，我们该如何确定它是一个单独的字段，还是这两个字节属于前一个字符串，甚至属于下一个字符串呢？没有灵丹妙药，我们应该做出假设并进行类推：如果所有字符串都以空格字符（0x20）结尾且没有NULL字节，则第一个字符串则是个例外，这是不太可能的。此外，这两个字节还可能是表示第二个字符串的长度的字段，但是，首先，其长度为0x64（从“Aerostar”到“VL38!”），其次，它似乎再次成为例外，这是非常值得怀疑的。我们需要检查该假设对其他记录的有效性（记住，我们现在讨论的是第一个记录），以确保该假设对它们都有效。
unk_1字段后面是vehicle_name_2，因为其内容是vehicle_name_1的副本。接下来的字段是vl_code_1和cat_code以及vl_code_2字符串，这些字符串以其值的前几个字母来命名。其中，前两个字段的大小为0x16字节。vl_code_2的长度可以是0x1A2字节，但是要具体视下一个“MX”字符串出现的位置，所以不要草率地将其大小设置为0x16。
事实上，vl_code_2字段在许多记录中具有与vl_code_1相同的值，所以，我们不妨假设它们的长度是相同的。另一方面，从vl_code_2 +
0x16偏移处到“MX”字符串之间的字节间距，在所有记录中都是0x20（个空格），因此，它们可以包含在vl_code_2字段中，但为了清楚起见，我们将它们划分到empty_1字段。
从“MX”字符串到“A”字符串之间为下一个假想字段，大小为0xD2。
事实证明，它是一个字符串数组，而非字符串，其中每个字符串的长度为0xA字节。将0xD2除以0xA，得到0x15，这就是数组的元素数量。这些字符串的具体含义尚不清楚，不过，其中某些字符串看起来像是国家代码（US，CA）或州代码（CA，MX），所以，不妨将该字段命名为unk_2。
再后面是“A”字符串，其长度可以直至充满最后0x20字节为止。利用前面类似的计算方法，我们发现，该数组有0x9个元素，每个元素的长度为0xC字节，在这里我们将其命名为unk_3。
剩余字节的含义目前还不太清楚，因为它们都不是字符串。
不过，我们不难看出这里有两个字（或双字），它们位于不同的位置，其中，第一个值是0x7C2，第二个值是0x7CB。如果将它们翻译成十进制数值的话，就会发现它们好像是两个年份：0x7C2
= 1986，0x7CB = 1995。大家还记得vehicle_name_1 = “Aerostar A
1986–1995”吗？由此看来，这两个数字分别表示生产年份的起止时间，所以，我们分别将其命名为year_from和year_to。
year_from和year_to之间的字节在所有记录中都是零，因此，我们将它们划归为大小为0x28的zero_1字段。在year_to之后，具有相同数量的归零字节，让我们将其划归为zero_2字段。其余字节的用途目前尚不清楚，所以，我们将其命名为unk_4。
如果我们仔细浏览几条记录，unk_1和vl_code_1以及vl_code_2和cat_code字段就会引起我们的注意——我们会发现，unk_1的数字值以字符形式存在于这些字段中。因此，我们可以推断unk_1是车辆标识符，所以，我们将其重命名为vehicle_id。这时，文件格式变成下面的样子。
    meta:
      id: catalogue
      file-extension: dat
      endian: le
      encoding: ascii
    seq:
      - id: vehicle
        type: vehicle
        size: 0x800
        repeat: eos
    types:
      vehicle:
        seq:
          - id: vehicle_name_1
            type: str
            size: 0x64
          - id: vehicle_id
            type: u2le
          - id: vehicle_name_2
            type: str
            size: 0x64
          - id: vl_code_1
            type: str
            size: 0x16
          - id: cat_code
            type: str
            size: 0x16
          - id: vl_code_2
            type: str
            size: 0x16
          - id: empty_1
            type: str
            size: 0x18C
          - id: unk_2
            type: str
            size: 0xA
            repeat: expr
            repeat-expr: 0x15
          - id: unk_3
            type: str
            size: 0xC
            repeat: expr
            repeat-expr: 9
          - id: year_from
            type: u2le
          - id: zero_1
            size: 0x28