从Bitnami目录中选择Web应用程序，该目录提供了可随时部署的预配置Web应用程序的容器。选择Bitnami应用是由于其受欢迎程度，多样性和先前工作的使用。在评估时，Bitnami包含211个容器。丢弃了105个没有Web应用程序且没有重复项的容器，例如，使用不同Web服务器的相同Web应用程序。其余的106个Web应用程序是：内容管理系统（23个），分析（15个），客户关系管理（11个），开发人员工具和错误跟踪（10个），电子商务（8个），论坛和聊天（8个），电子邮件和营销自动化（5个），电子学习（4个），媒体共享（3个），项目管理（2个），会计和投票管理（2个）以及其他（15个）。
Web应用程序的完整列表中包括WordPress，Drupal，GitLab，phpMyAdmin和ownCloud。然后，对于每个Web应用程序，为每个受支持的特权级别创建一个用户帐户，并创建一个Selenium测试用例来执行登录。总共创建了136个测试脚本，每个应用程序包含1到5个测试用例。
**JAW输入：**
JAW的输入是种子URL，Selenium测试用例和语义类型映射。种子URL包含用于用户登录的URL（总共113个登录URL），而测试用例是在配置测试平台时准备的。然后，对于所有Web应用程序，使用下表列出的语义类型。
**客户端CSRF检测方法：**
在本地部署了正在评估的Web应用程序，并针对每个目标实例化了JAW。在数据收集和创建HPG之后，运行一组查询以识别攻击者可控制的请求。然后，使用其他查询来确定攻击者控制下的请求字段和控制类型，通过人工验证来评估查询结果的准确性。对于每个可伪造的请求，将页面加载到检测到的浏览器中，并验证在客户端请求中是否观察到操纵的输入。例如，如果请求使用WIN.LOC类型的数据值，将标记插入易受攻击的页面URL中，并在传出请求中搜索该标记。确认请求的可伪性后，将其用于攻击中。首先，搜索执行安全性相关的状态更改操作（例如修改服务器端存储上的数据）的服务器端端点。然后构造一个字符串，当该字符串由易受攻击的页面处理时，它将导致向标识的端点的请求。最后将字符串打包到恶意URL中，并验证攻击是否针对具有有效会话的Web应用程序用户，该用户单击URL。
**影响动态快照方法：** 进行了其他实验，以评估动态快照方法在（i）漏洞检测和（ii）HPG构建中的影响。首先准备了JAW的变体，以下称为JAW-static，它遵循纯静态方法进行HPG构建和分析。具体来说，JAW-static不考虑以下动态信息：触发事件，处理程序注册，HTTP消息，全局对象状态，针对DOM查询的指向分析，脚本标记的动态插入以及DOM树快照。用JAW-static重复了评估，并通过将其与JAW的评估结果进行比较，确定了JAW-static中漏报和误报漏洞的下限。此外比较了HPG节点，边和属性的差异。
然后记录了所有未触发的触发事件，并且JAW找不到用于HPG构建的代码行。此类情况表明JAW生成的HPG中存在漏报边。因此，手动检查所有情况以找出出现漏报边的原因。最后进行了另一个实验，以评估由于使用DOM树快照进行DOM查询的指向分析而导致的误报和漏报性边。对于所有网页，检测JavaScript代码以记录DOM查询所引用的实际元素，并将其与JAW解析的值进行比较。
JAW使用这些分辨率来创建ERDDG边，从而为误报边和漏报边打开了可能性。
### B.收集数据分析
**分析的大小：**
JAW从113个种子URL开始，提取了4,836个网页，每个Web应用程序从1到456个网页，每个应用程序大约46个网页。对这些URL的结构分析表明，它们中的865个具有散列片段，这表明这些URL带有客户端JavaScript程序的状态信息，这是单页Web应用程序的特征。总共有39个Web应用程序使用带有哈希片段的URL。  
JAW从4,836页中提取了228,763,028个LoC，通过处理每页47,304个LoC来生成4,836个HPG。在查看代码的来源时，发现其中的大部分（即60.55％）来自共享库，例如jQuery（每页28,645个LoC，总共138,525,092个LoC），而其余部分是脚本中的应用程序代码标签（每页39.42％或18,649
LoC，总计超过90,188,256 LoC）和可忽略不计的金额是内联代码（每页0.02％或10 LoC，共超过49,680 LoC）。
最终在运行时，观察到总共有104,720个脚本标签被动态加载（即，通过以编程方式插入脚本标签）约2.63％的脚本标签。另外，JAW观察到有51,974个事件在加载页面时触发（每页大约11个事件），这些事件分布在46个事件类型中，其中38个是HTML5类型（例如，动画和DOM突变事件），其中8个是自定义事件。正如接下来将要展示的，即使运行时监视事件的数量可以忽略不计，它们在分析中的作用也是至关重要的。
**符号建模的重要性：**
客户端程序的分析需要处理228,763,028个LoC，其中138,525,092个仅用于库，占总数的60％。分析表明，库在Web应用程序和页面之间都可以大量重用。首先，测试平台中的106个Web应用程序总共使用了31个不同的库。其次，每个页面包含从零到七个脚本库，平均每个页面有两个库。第三，这31个库的代码总量为412,575
LoC，比所有页面上的总138,525,092
LoC小335倍。因此，对库代码进行预处理以提取符号模型的过程将生成HPG所需的工作量减少了一半以上（-60.37％），从228,763,028
LoC变为90,650,511（即应用程序，内联JavaScript，和31个库）。
对于31个库中的每一个，JAW都会生成一个HPG并提取一个符号模型。上表概述了符号建模步骤的结果。
JAW在大约半小时内总共建模了11,977个函数，其中一半具有输入输出关系的语义类型（即5,923个函数），这是一种正确重构程序数据流的相关函数行为。
确定了64,854,097个事件边（即注册，依赖和分派），其中6,451,582是分派边，即为执行事件处理程序的意图建模的边。为了进行比较，将控件也转移到程序其他站点的调用边数为7,179,021，这意味着ERDDG表示能够识别+
89.87％的将程序控件转移到边上。
### C.可伪造请求
检测客户端CSRF的第一步是识别可以生成攻击者控制的请求的代码行。为此，准备了一组查询。根据威胁模型考虑了由攻击者控制的JavaScript程序的不同输入，这些输入可以由不同的攻击者伪造。
JAW在可发送HTTP请求的106个应用程序中识别出49,366行代码，并将其中36,665行标记为在页面加载期间无法访问或未使用攻击者控制的输入。其余的12,701个请求可以由攻击者控制。将这些请求按照对应于不同攻击者的输入源的语义类型进行了分组，如下表所示。注意到大多数应用程序（即87个）在页面加载时发送至少一个可伪造的请求。
**误报：**
考虑到大量可伪造的请求，无法通过人工检查来验证所有请求。相反，首先选择所有组中的所有请求，但DOM.READ除外。然后，对于DOM.READ，集中于针对每个Web应用程序的一个请求（随机选择），即83个请求。总共检查了516个可伪造的请求。为了进行检查，在检测到的浏览器中加载了易受攻击的页面，以注入操纵的字符串，并观察传出的请求是否包括操纵的字符串。除了83个DOM.READ请求之一之外，所有请求都包含操纵的内容。经过仔细的调查，发现由于对上下文敏感的this关键字的指针分析不正确而导致误报，此关键字具有运行时绑定，并且对于函数的每次调用可能有所不同，具体取决于该函数的方式调用，例如，动态调用的函数，或使用调用和应用方法的层次结构的不同调用参数导致此操作的不同绑定。
**利用：**
接下来为515个请求寻找了实际的利用方法。在这些实验中，假设所有输入源都为Web攻击者模型，但Cookie除外，假设其为网络攻击者模型。能够为影响七个Web应用程序的203个可伪造请求生成可利用的漏洞，它们全部使用WIN.LOC的数据值，任何网络攻击者都可以伪造该数据。对于其他组请求，无法找到漏洞利用程序。在手动寻找漏洞时很难达到完整性，因为这样的任务需要广泛的Web应用程序知识来识别目标URL和攻击者可以注入恶意负载的点，找不到漏洞利用程序这一事实并不意味着该漏洞利用程序不存在。对于这些情况，确认JavaScript代码通过无条件处理来自不同数据结构的数据值来发送HTTP请求。攻击者最终可能会找到一种在这些数据结构中注入恶意有效载荷并利用这些可伪造请求的方法。
### D.可伪造请求分析
在本节中将详细研究攻击者可以对上表伪造请求进行的操作程度。提取了发送可伪造请求的代码行的堆栈跟踪，并从三个方面描述了易受攻击的行为：请求字段，操作类型和请求模板。
**请求字段：**
首先，可以操作的请求字段可以确定漏洞的严重性。例如，如果攻击者可以更改请求的域名，则可以使用客户端CSRF进行跨域攻击。根据被操纵的字段将Web应用程序分为四类，发现在9，34、41和41个Web应用程序中，攻击者可以操纵URL域，URL路径，URL查询字符串和body参数。
同样，根据可以在请求中处理的字段数将应用程序分组。总共有55、34和12个应用程序允许分别修改一个，一个以上和所有字段。
**操作类型：**
影响严重性的另一个因素是在一个或多个字段中复制操作值的操作。发现28个应用程序允许攻击者更改一个或多个字段的值。同样，有38个和28个应用程序允许攻击者通过将攻击者控制的字符串分别添加和添加到最终字符串来添加一个或多个字段。
**可伪造的请求模板：**
通过模板对HTTP请求进行特征化，在模板中对可以操作的字段的类型和数量以及操作的类型进行编码。上表列出了所有模板，对于每个模板，它显示了匹配请求和使用它们的Web应用程序的数量。总共确定了25个不同的模板。观察到，大多数Web应用程序在其所有网页上仅使用一个模板（即68个应用程序）或两个模板（即17个应用程序）。
### E.利用和攻击
203个可利用的客户端CSRF影响七个目标，如下所示。 漏洞利用与传统CSRF相同的方式攻击Web应用程序，即通过执行与安全性相关的状态更改请求。
此外，发现利用客户端CSRF的XSS和SQLi攻击是无法通过经典攻击向量来利用的。
**SuiteCRM和SugarCRM：**
总共在SuiteCRM和SugarCRM中发现了115和38个可伪造的请求，这些请求可被利用来破坏服务器的完整性。
在这两个应用程序中，JavaScript代码均读取哈希片段参数（例如ajaxUILoc），并将其逐字用作提交异步请求的端点。
攻击者可以向状态更改服务器端端点发出任何任意请求，以删除帐户，联系人，案例或任务。
203个可利用的客户端CSRF影响七个目标，如下所示。我们的漏洞利用与传统CSRF相同的方式攻击Web应用程序，即通过执行与安全性相关的状态更改请求。此外，我们发现了利用客户端CSRF进行XSS和SQLi攻击的方法，而传统的攻击向量无法利用此方法。
SuiteCRM和SugarCRM。总共，我们在SuiteCRM和SugarCRM中发现了115和38个可伪造的请求，这些请求可被利用来破坏服务器的完整性。在这两个应用程序中，JavaScript代码均读取哈希片段参数（例如ajaxUILoc），并将其逐字用作向其提交异步请求的端点。攻击者可以向状态更改服务器端端点发出任何任意请求，以删除帐户，联系人，案例或任务，仅举几个我们手动确认的实例。
**Neos：** 在Neos中发现了8个可伪造的请求。在所有这些参数中，HTTP请求的每个参数p都源自页面的URL参数moduleArguments
[@p]。例如，拥有后端服务器用来将请求路由到内部模块的action和controller参数。这种行为使攻击者可以将请求定向到任何有效的内部模块，包括实现状态更改操作的模块。例如，利用此行为从文件系统中删除资产。
**Kibana：** 发现了一个由Timelion生成的可伪造请求，该请求是Kibana的一个组件，将独立的数据源组合并可视化。