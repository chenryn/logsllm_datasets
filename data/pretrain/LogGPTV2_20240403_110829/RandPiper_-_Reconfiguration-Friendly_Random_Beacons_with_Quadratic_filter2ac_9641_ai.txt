Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3516last ğ‘‘ğ‘¡â„ time it was a leader to buffer ğ‘‘ shares. Next, we observe
that HydRand cannot tolerate more than ğ‘¡ > ğ‘›/3 because it fails to
deliver the PVSS encryptions to all correct nodes, if the leaders fails
to send it to them. We solve this concern using extension techniques
from recent works [36]. However, these works assume threshold
signatures which we avoid in our protocol. Thus, in RandPiper, we
achieve an optimal fault tolerance of ğ‘¡  â„) that extends ğµâ„.
Fact B.1. If an honest node delivers an object ğ‘ at time ğœ in epoch
ğ‘’ and no honest node has detected an epoch ğ‘’ equivocation by time
ğœ + Î”, then all honest nodes will receive object ğ‘ by time ğœ + 2Î” in
epoch ğ‘’.
Proof. Suppose an honest node ğ‘ğ‘– delivers an object ğ‘ at time
ğœ in epoch ğ‘’. Node ğ‘ğ‘– must have sent valid code words and witness
âŸ¨codeword, mtype, ğ‘  ğ‘— , ğ‘¤ ğ‘— , ğ‘§ğ‘’, ğ‘’âŸ©ğ‘– computed from object ğ‘ to every
ğ‘ ğ‘— âˆˆ P at time ğœ. The code words arrive at all honest nodes by time
ğœ + Î”.
Since no honest node has detected an epoch ğ‘’ equivocation by
time ğœ + Î”, it must be that either honest nodes will forward their
code word âŸ¨codeword, mtype, ğ‘  ğ‘— , ğ‘¤ ğ‘— , ğ‘§ğ‘’, ğ‘’âŸ© when they receive the
code words sent by node ğ‘ğ‘– or they already sent the corresponding
code word when they either delivered object ğ‘ or received the code
word from some other node ğ‘ ğ‘—. In any case, all honest nodes will
forward their epoch ğ‘’ code word corresponding to object ğ‘ by time
ğœ + Î”. Thus, all honest nodes will have received ğ‘¡ + 1 valid code
words for a common accumulation value ğ‘§ğ‘’ by time ğœ +2Î” sufficient
to decode object ğ‘ by time ğœ + 2Î”.
â–¡
Fact B.2.
then all honest nodes receive ğµâ„ by time ğœ.
If an honest node votes for a block ğµâ„ at time ğœ in epoch ğ‘’,
Proof. Suppose an honest node ğ‘ğ‘– votes for a block ğµâ„ at time
ğœ in epoch ğ‘’. Node ğ‘ğ‘– must have received proposal ğ‘ğ‘’ for ğµâ„ by
time ğœ âˆ’ 2Î” and detected no epoch ğ‘’ equivocation by time ğœ. This
implies no honest node detected an epoch ğ‘’ equivocation by time
ğœ âˆ’ Î”. Node ğ‘ğ‘– must have invoked Deliver(propose, ğ‘ğ‘’, ğ‘§ğ‘ğ‘’, ğ‘’) at
time ğœ âˆ’2Î”. By Fact B.1, all honest nodes receive ğ‘ğ‘’ by time ğœ. Thus,
all honest nodes must have received ğµâ„ by time ğœ.
â–¡
Lemma B.3. If an honest node directly commits a block ğµâ„ in epoch
ğ‘’, then (i) no equivocating block certificate exists in epoch ğ‘’, and (ii)
all honest nodes receive Cğ‘’(ğµâ„) before quitting epoch ğ‘’.
Proof. Suppose an honest node ğ‘ğ‘– commits a block ğµâ„ in epoch
ğ‘’ at time ğœ. Node ğ‘ğ‘– must have received a vote-cert for ğµâ„ at time
ğœ âˆ’ 2Î” such that its epoch-timerğ‘’ â‰¥ 3Î” and did not detect an
equivocation by time ğœ. This implies no honest node detected an
epoch ğ‘’ equivocation by time ğœ âˆ’ Î”. In addition, some honest node
ğ‘ ğ‘— must have voted for ğµâ„ by time ğœ âˆ’ 2Î”. By Fact B.2, all honest
nodes would receive ğµâ„ by time ğœ âˆ’ 2Î”.
For part (i), observe that no honest node received an equivocating
proposal by time ğœ âˆ’ 2Î”; otherwise, all honest nodes would have
received a code word for equivocating proposal by time ğœ âˆ’ Î” and
node ğ‘ğ‘– would not commit. And, no honest node would vote for an
equivocating block after time ğœ âˆ’ 2Î” (since they have received ğµâ„
by time ğœ âˆ’ 2Î”). Thus, an equivocating block certificate does not
exist in epoch ğ‘’.
For part (ii), observe that node ğ‘ğ‘– must have invoked the primitve
Deliver(vote-cert, ğ‘£ğ‘’, ğ‘§ğ‘£ğ‘’, ğ‘’) for ğ‘£ğ‘’ = Cğ‘’(ğµâ„) at time ğœ âˆ’ 2Î” and
did not detect epoch ğ‘’ equivocation by time ğœ. By Fact B.1, all
honest nodes receive ğ‘£ğ‘’ by time ğœ. Note that node ğ‘ğ‘– must have
its epoch-timerğ‘’ â‰¥ 3Î” at time ğœ âˆ’ 2Î”. Since, all honest nodes are
synchronized within Î” time, all other honest nodes must have
epoch-timerğ‘’ â‰¥ 2Î” at time ğœ âˆ’ 2Î”. Thus, all nodes are still in epoch
ğ‘’ at time ğœ and receive Cğ‘’(ğµâ„) before quitting epoch ğ‘’.
â–¡
Lemma B.4 (Unique Extensibility).
If an honest node directly com-
mits a block ğµâ„ in epoch ğ‘’, then any certified blocks that ranks higher
than Cğ‘’(ğµâ„) must extend ğµâ„.
Proof. The proof is by induction on epochs ğ‘’â€² > ğ‘’. For an epoch
ğ‘’â€², we prove that if a Cğ‘’â€²(ğµâ„â€²) exists then it must extend ğµâ„.
For the base case, where ğ‘’â€² = ğ‘’ + 1, the proof that Cğ‘’â€²(ğµâ„â€²)
extends ğµâ„ follows from Lemma B.3. The only way Cğ‘’â€²(ğµâ„â€²) for ğµâ„â€²
forms is if some honest node votes for ğµâ„â€². However, by Lemma B.3,
there does not exist any equivocating block certificate in epoch ğ‘’
and all honest nodes receive and lock on Cğ‘’(ğµâ„) before quitting
epoch ğ‘’. Thus, a block certificate cannot form for a block that does
not extend ğµâ„.
Given that the statement is true for all epochs below ğ‘’â€², the proof
that Cğ‘’â€²(ğµâ„â€²) extends ğµâ„ follows from the induction hypothesis
because the only way such a block certificate forms is if some
honest node votes for it. An honest node votes in epoch ğ‘’â€² only if
ğµâ„â€² extends a valid certificate Cğ‘’â€²â€²(ğµâ„â€²â€²). Due to Lemma B.3 and the
induction hypothesis on all block certificates of epoch ğ‘’  ğ‘¡ shares reconstruct a unique ğ‘ .
Verify if the sharing is correct. A successful verification guarantees that all the encrypted shares are correct
and that any ğ‘¡ + 1 nodes will reconstruct a unique ğ‘ . 0 indicates a failure and 1 indicates a success.
Reconstruct the shared secret ğ‘  from the collection of shares PVSS.(cid:174)ğ‘† âŠ† {PVSS.s1, . . . , PVSS.sğ‘›}ğ‘¡+1
Some honest nodes might have received a higher ranked certificate
than leader ğ¿ğ‘’ before entering epoch ğ‘’; thus, they send their highest
ranked certificate to leader ğ¿ğ‘’.
Leader ğ¿ğ‘’ might have entered epoch ğ‘’ at time ğœ while some
honest nodes enter epoch ğ‘’ only at time ğœ + Î”. The 2Î” wait in the
Propose step ensures that the leader can receive highest ranked
certificates from all honest nodes. However, leader ğ¿ğ‘’ may enter
epoch ğ‘’ Î” time after the earliest honest nodes. Due to 2Î” wait
after entering epoch ğ‘’, leader ğ¿ğ‘’ collects the highest ranked cer-
tificate Cğ‘’â€²(ğµğ‘™) by time ğœ + 3Î” and sends a valid proposal ğ‘ğ‘’ =
âŸ¨propose, ğµâ„, ğ‘’, Cğ‘’â€²(ğµğ‘™), ğ‘§ğ‘ğ‘’âŸ©ğ¿ğ‘’ for a block ğµâ„ that extends Cğ‘’â€²(ğµğ‘™)
which arrives all honest nodes by time ğœ + 4Î”.
Thus, all honest nodes satisfy the constraint epoch-timerğ‘’ â‰¥ 7Î”.
In addition, ğµâ„ extends the highest ranked certificate. So, all honest
nodes will invoke Deliver(propose, ğ‘ğ‘’, ğ‘§ğ‘ğ‘’, ğ‘’) and set vote-timerğ‘’
to 2Î” which expires by time ğœ + 6Î”. All honest nodes send vote
for ğµâ„ to ğ¿ğ‘’ which arrives ğ¿ğ‘’ by time ğœ + 7Î”. Leader ğ¿ğ‘’ forwards
Cğ‘’(ğµâ„) which arrives all honest nodes by time ğœ + 8Î”. Note that
all honest nodes satisfy the constraint epoch-timerğ‘’ â‰¥ 3Î” and
honest nodes set their commit-timerğ‘’ to 2Î” which expires by time
ğœ + 10Î”. Moreover, no equivocation exists in epoch ğ‘’. Thus, all
honest nodes will commit ğµâ„ and its ancestors in epoch ğ‘’ before
their epoch-timerğ‘’ expires.
â–¡
Theorem B.7 (Liveness). All honest nodes keep committing new
blocks.
Proof. For any epoch ğ‘’, if the leader ğ¿ğ‘’ is Byzantine, it may not
propose any blocks or propose equivocating blocks. Whenever an
honest leader is elected in epoch ğ‘’, by Fact B.6, all honest nodes
commit in epoch ğ‘’. Since we assume a round-robin leader rotation
policy, there will be an honest leader every ğ‘¡ + 1 epochs, and thus
the protocol has a commit latency of ğ‘¡ + 1 epochs.
â–¡
Lemma B.8 (Communication complexity). Let â„“ be the size of block
ğµâ„, ğœ… be the size of accumulator and ğ‘¤ be the size of witness. The
communication complexity of the protocol is ğ‘‚(ğ‘›â„“ + (ğœ… + ğ‘¤)ğ‘›2) bits
per epoch.
Proof. At the start of an epoch ğ‘’, each node sends a highest
ranked certificate to leader ğ¿ğ‘’. Since, size of each certificate is ğ‘‚(ğœ…ğ‘›),
this step incurs ğ‘‚(ğœ…ğ‘›2) bits communication. A proposal consists
of a block of size â„“ and block certificate of size ğ‘‚(ğœ…ğ‘›). Proposing
ğ‘‚(ğ‘› + â„“)-sized object to ğ‘› nodes incurs ğ‘‚(ğœ…ğ‘›2 + ğ‘›â„“). Delivering
ğ‘‚(ğœ…ğ‘›+ â„“)-sized object has a cost ğ‘‚(ğ‘›â„“ +(ğœ… +ğ‘¤)ğ‘›2), since each node
broadcasts a code word of size ğ‘‚((ğ‘› + â„“)/ğ‘›), a witness of size ğ‘¤
and an accumulator of size ğœ….
In Vote cert step, the leader broadcasts a certificate for block
ğµâ„ which incurs ğ‘‚(ğœ…ğ‘›2) communication. Delivering ğ‘‚(ğœ…ğ‘›)-sized
Cğ‘’(ğµâ„) incurs ğ‘‚((ğœ… + ğ‘¤)ğ‘›2) bits. Hence, the total cost is ğ‘‚(ğ‘›â„“ +
(ğœ… + ğ‘¤)ğ‘›2) bits.
â–¡
B.2 GRandPiper Security Analysis
Theorem B.9 (Consistent beacon). Let ğ¿ = ğ¿ğ‘’ denote the leader
of epoch ğ‘’. Then the following properties hold:
Block consistency: if an honest node commits a block ğµ
proposed in epoch ğ‘’â€² â‰¤ ğ‘’ âˆ’ ğ‘¡, then all the honest nodes