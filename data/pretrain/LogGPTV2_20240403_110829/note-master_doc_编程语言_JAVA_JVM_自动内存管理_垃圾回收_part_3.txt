设置线程最大调用深度`-Xss`
#### 内存溢出与内存泄漏
内存溢出就是申请的内存大小超出了系统所能提供的，系统不能满足需求，于是产生溢出
内存泄漏是使用过的内存空间没有被及时释放，长时间占用内存，最终导致内存空间不足，而出现内存溢出
## 垃圾收集器
衡量垃圾收集器的三项最重要的指标是：
- 内存占用（Footprint）
- 吞吐量（Throughput）
- 延迟（Latency）
截止到JDK14,当前JAVA已有的垃圾回收器
![批注 2020-05-08 163037](/assets/批注%202020-05-08%20163037.png)
1. Serial 几十兆
2. PS 上百兆 - 几个G
3. CMS - 20G
4. G1 - 上百G
5. ZGC - 4T - 16T（JDK13）
连线表示垃圾收集器可以配合使用
垃圾回收器的发展路线是随着内存越来越大演进以及从分代算法演化到不分代算法
除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行
### 串行垃圾收集器Serial
![2020316989](/assets/2020316989.jpg)
- 会导致STW（stop the world）
- Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大 而且没有线程切换的开销
- FGC的时间较长
```
[120.792s][info   ][gc           ] GC(25) Pause Young (Allocation Failure) 10M->6M(15M) 0.936ms
[120.792s][info   ][gc,cpu       ] GC(25) User=0.00s Sys=0.00s Real=**0.00s**
```
通过JVM参数`-XX:+UseSerialGC`可以使用串行垃圾回收器
### ParNew
![20203169926](/assets/20203169926.jpg)
它是 Serial 收集器的多线程版本
```
[GC (Allocation Failure) [ParNew: 4928K->512K(4928K), 0.0024282 secs] 7129K->3525K(15872K), 0.0024673 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
```
参数控制：`-XX:+UseParNewGC` 指定使用ParNew收集器
`-XX:ParallelGCThreads` 限制线程数量
### Parallel Scavenge
其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器
吞吐量指的是CPU用于运行用户程序的时间占总时间的比值
停顿时间短，回收效率高，对吞吐量要求高
`-XX:-UseParallelGC`(年轻代) 和 `-XX:+UseParallelOldGC`(老年代)
### Serial Old
Serial 收集器的老年代版本，给 Client 场景下的虚拟机使用
![屏幕截图 2020-10-19 145451](/assets/屏幕截图%202020-10-19%20145451.png)
如果用在Server端：是作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用
### Parallel Old
![202031692117](/assets/202031692117.jpg)
Parallel Scavenge 收集器的老年代版本
### CMS垃圾收集器
![202031692235](/assets/202031692235.jpg)
（Concurrent Mark Sweep）
> CMS是老年代垃圾收集器，在收集过程中可以与用户线程并发操作。它可以与Serial收集器和Parallel New收集器搭配使用。CMS牺牲了系统的吞吐量来追求收集速度，适合追求垃圾收集速度的服务器上
```mermaid
stateDiagram-v2
  闲置等待 --> 初始化标记
  初始化标记 --> 并发标记
  并发标记 --> 预处理
  预处理 --> 重新标记
  重新标记 --> 并发清理
  并发清理 --> 调整堆大小
  调整堆大小 --> 重置
  重置 --> 闲置等待
```
- 响应时间优先，减少垃圾收集停顿时间
- CMS默认启动的回收线程数是（处理器核心数量+3）/4 ，如果在CPU核数较低的情况下，对应用本身的性能还是有影响的
- 采用的标记清除算法 会产生大量空间碎片
通过JVM参数 `-XX:+UseConcMarkSweepGC`设置
### G1垃圾收集器
一款面向服务端应用的垃圾收集器 目标是替代CMS
- JDK9默认开启
- 暂停时间更加可控
- 使用的标记复制算法 不会产生大量碎片
- 优先回收垃圾最多的区域
![屏幕截图 2020-09-19 104157](/assets/屏幕截图%202020-09-19%20104157.png)
G1将堆空间划分成若干个相同大小的区域 不同的区域存放不同的对象
几个问题：
- Region里面存在的跨Region引用对象如何解决？通过记忆集解决
- 并发标记阶段如何保证收集线程与用户线程互不干扰地运行？通过快照的方式
- 怎样建立起可靠的停顿预测模型？通过收集信息来得到最近一段时间来得到统计状态以进行分析，根据回收价值排序来得到可预测的回收时间
**过程:**
1. 初始标记 STW 标记GC根可达对象
2. 根区域扫描 从上一阶段标记的存活区域扫描老年代对象
3. 并发标记 对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象
4. 最终标记 STW 完成最终的标记处理 用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录
5. 清理 STW 统计所有存活对象 并将回收区域排序 优先回收垃圾最多的区域
![屏幕截图 2020-10-20 142254](/assets/屏幕截图%202020-10-20%20142254.png)
G1使用建议：
- 避免设置年轻代大小
- 暂停时间不要太苛刻(默认为200ms)
通过JVM参数 `-XX:+UseG1GC` 使用G1垃圾回收器
从G1开始，最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的内存分配速率
G1比CMS的弱项：
- G1的卡表实现更为复杂，无论扮演的是新生代还是老年代角色，都必须有一份卡表
- G1对写屏障的复杂操作要比CMS消耗更多的运算资源
### Shenandoah收集器
目的是每次停顿都在10ms内
使用了连接矩阵来维护Regin 之间的引用关系：
![屏幕截图 2020-10-20 144003](/assets/屏幕截图%202020-10-20%20144003.png)
过程：
1. 初始标记 STW 标记与GC Roots直接关联的对象 停顿时间与GC Roots的数量相关
2. 并发标记 遍历对象图，标记出全部可达的对象
3. 最终标记 STW 处理并发标记时产生的新关系
4. 并发回收 把回收集里面的存活对象先复制一份到其他未被使用的Region之中 使用的读屏障及转发指针实现
5. 初始引用更新 STW 并发回收阶段复制对象结束后，还需要把堆中所有指
向旧对象的引用修正到复制后的新地址
6. 并发引用更新
7. 最终引用更新 STW 解决了堆中的引用更新后，还要修正存在于GC Roots
中的引用
8. 并发清理
![屏幕截图 2020-10-20 145308](/assets/屏幕截图%202020-10-20%20145308.png)
#### 转发指针
![屏幕截图 2020-10-20 145619](/assets/屏幕截图%202020-10-20%20145619.png)
有两点问题需要注意：
1. 并发更新问题 通过CAS解决
2. 增加了一层转发肯定会带来效率的损失
### ZGC
>一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器
目的也是在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟
- 会因为GC Root增大而增加STW时间
- 会将内存划分为区域大不同的区域
堆内存布局：
![屏幕截图 2020-10-20 150231](/assets/屏幕截图%202020-10-20%20150231.png)
过程：
![屏幕截图 2020-10-20 151632](/assets/屏幕截图%202020-10-20%20151632.png)
1. 并发标记 遍历对象图做可达性分析的阶段
2. 并发预备重分配 这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集
3. 并发重分配 把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（ForwardTable），记录从旧对象到新对象的转向关系 如果用户代码此时访问了位于重分配集中的对象 会进行一次引用修改 使其指向新对象
4. 并发重映射 修正整个堆中指向重分配集中旧对象的所有引用
#### 染色指针
它直接把标记信息记在引用对象的指针上
![批注 2020-05-11 100706](/assets/批注%202020-05-11%20100706.png)
由于只有42位作为对象地址 所以ZGC最高能管理的内存只有4TB 并且不支持32位平台 也不支持压缩指针
但是染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理
染色指针的操作系统问题：
重新定义内存中某些指针的其中几位，操作系统是否支持？处理器是否支持？
Linux/x86-64平台上的ZGC使用了多重映射（Multi-Mapping）将多个不同的虚拟内存地址映射到同一个物理内存地址上
![屏幕截图 2020-10-20 151432](/assets/屏幕截图%202020-10-20%20151432.png)
### Epsilon收集器
所谓垃圾收集器 干的不仅仅是收集垃圾的活 它还要负责堆的管理与布局、对象的分配、与解释器的协作、与编译器的协作、与监控子系统协作等职责
这款垃圾收集器不干GC的活 对于微服务 低内存 运行时间短的应用及时不回收垃圾 也是可以接受的
## GC日志分析
一些参数：
1. 看GC基本信息，在JDK 9之前使用-XX：+PrintGC，JDK 9后使用-Xlog:gc
2. 看GC详细信息，在JDK 9之前使用-XX：+PrintGCDetails，在JDK 9之后使用-X-log:gc*
3. 查看GC前后的堆、方法区可用容量变化，在JDK 9之前使用-XX：+PrintHeapAtGC，JDK 9之后使用-Xlog:gc+heap=debug
4. 查看GC过程中用户线程并发时间以及停顿的时间，在JDK 9之前使用-XX：+Print-GCApplicationConcurrentTime以及-XX+PrintGCApplicationStoppedTime，JDK 9之后使用-Xlog:safepoint
5. 查看收集器Ergonomics机制（自动设置堆空间各分代区域大小、收集目标等内容，从Parallel收集器开始支持）自动调节的相关信息。在JDK 9之前使用-XX：+PrintAdaptive-SizePolicy，JDK 9之后使用-Xlog：gc+ergo*=trace
6. 查看熬过收集后剩余对象的年龄分布信息，在JDK 9前使用-XX：+PrintTenuring-Distribution，JDK 9之后使用-Xlog：gc+age=trace
### 可视化GC日志分析工具
[gceasy](http://gceasy.io)