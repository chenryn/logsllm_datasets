when the event is inconsistent with previous events. How-
ever, the methods to access it are hidden, it is not docu-
mented, and we never see it set in any of our attacks.
Application Limitations. Finally, our design and im-
plementation place certain limitations on applications. For
example, since unrestricted use of reﬂection allows an ap-
plication to circumvent any secure library, we require that
developers who use reﬂection annotate their applications ac-
cordingly and that a human veriﬁer inspects any usages of
reﬂection. Though alternate static analysis approaches may
remove such restrictions, approaches without OS support
are more likely to encounter such challenges.
6. EVALUATIONS
We show that it is feasible to integrate our implementation
with real applications. We also test it on malicious code
and show that it prevents attacks in the scope of our threat
model. We evaluate the performance impacts of diﬀerent
random check frequencies. Finally, we evaluate how often
applications create and modify events in practice.
6.1 Aiding Good: Porting Applications
We integrate AUDACIOUS into existing applications to
evaluate the development impact. We ﬁnd the following:
integrating ACGs only slightly increases code size.
applications, integrating ACGs decreases code size.
• Some applications have ACG-like UI elements. In these
• In applications that do not have ACG-like UI elements,
• Flexibility of permission models is desirable. All of the
applications that we evaluate have permission uses for
which ACGs may not be ideal.
• Applications beneﬁt from increased customization of
and interaction with ACGs. A software-based approach
should consider this in its design.
• A proactive developer can decrease the burden of in-
formation ﬂow analysis by following best practices.
6.1.1 Applications
We build AUDACIOUS into ﬁve open-source applications
from the F-Droid repository.5 We summarize these applica-
tions in Table 3. We select these applications for non-trivial
uses of permissions and for varying complexity. Simple ap-
plications have little advanced functionality; more complex
applications may have complicated permissions uses or pass
information through Intents.
6.1.2 Development Impact
We evaluate the impact of integrating AUDACIOUS in
three places: the library, the event analysis, and the informa-
tion ﬂow analysis. We count Java LOC using SLOCCount.6
We summarize our results in Tables 4 and 5.
ACG Library.
Integrating the library requires few code
changes. Three of the ﬁve applications already include un-
veriﬁed UI elements that behave like ACGs. For example,
Speed of Sound has a toggle button to start and stop lo-
cation tracking; this functions like the UpdateLocationACG.
Integrating the library into these applications decreases code
size. Two applications do not have ACG-like UI elements.
For example, Solar Compass accesses location automatically
when the application starts.
Integrating the library into
these applications only slightly increases code size.
5https://f-droid.org/
6http://www.dwheeler.com/sloccount/
Event Analysis. The event analysis takes at most 24 sec-
onds and reports no false positives in four out of ﬁve applica-
tions. It reports two false positives in the rotateTouchEvent
method of a map class in a dependency of WikiJourney. This
method determines the orientation of the map and rotates
events accordingly. This is not malicious behavior; the hu-
man veriﬁer can check this in the approval stage.
Information Flow. Annotation burden is low for simple
applications and higher for more complex applications. The
ﬂow for Pinpoi is especially complex, as it allows users to
import points of interest from many diﬀerent data sources
and uses Intents heavily. We use a tool in SPARTA to au-
tomatically infer annotations for Pinpoi. This tool infers
487 annotations; we correct incorrect annotations and add
missing annotations. We expect that this increases our an-
notation count. Overall, the developer understands the code
best and so is in the best position to decrease this burden.
SPARTA takes at most 96 seconds and reports no errors
for three of the annotated applications. It reports one error
in Speed of Sound and 21 errors in Pinpoi. These are the
results of illegal ﬂows. For example, Speed of Sound over-
rides toString() and leaks sensitive information from Blue-
tooth (BLUETOOTH → ANY). Pinpoi catches and prop-
agates runtime exceptions (ANY → ANY). Neither appli-
cations use these ﬂows maliciously; this is human-veriﬁable.
Nonetheless, SPARTA reports errors to prevent these be-
haviors. A proactive developer can decrease the number of
false-positives by following best practices (for example, by
only leaking sensitive information in sensitive methods, or
by using checked exceptions).
6.1.3 Lessons and Observations
ACGs encapsulate existing behavior. When applica-
tions already have ACG-like UI elements, integrating the
library is simply a matter of swapping those elements with
ACGs, which decreases code size. However, even when ap-
plications do not have ACG-like UI elements, integrating
the library only slightly increases code size. That is, even
though we must add new user interaction, we may remove
some of the resource-accessing code. Overall, we ﬁnd that
ACGs act not only as a security guarantee for the user, but
also as a reusable component for the developer.
Flexibility of permission models is desirable. All ﬁve
applications have permission uses for which user-driven ac-
cess control may not be ideal. Consider Speed of Sound:
The application saves songs to a database while the user is
driving, but the user cannot interact with the application
at that time. We can require the user to give permission
to save songs before beginning a route or upon ﬁnishing a
route. However, this may impose an unwanted burden on
the user. This supports the claim that ACGs alone do not
fully represent all modes of interaction with resources [7].
Furthermore, in practice, it may not be feasible to enumer-
ate all possible uses of ACGs. We can avoid these problems
by allowing applications to use alternative permission mod-
els for functionalities for which user-driven access control is
not ideal.
Applications beneﬁt from increased customization
of and interaction with ACGs. The original model for
ACGs [23] introduces three types of ACGs: one-time, ses-
Application
Purpose
Complexity
Resources
ACG Integrated
VoiceRecorder
Record and save audio
Solar Compass
Show position of sun relative to location
Simple
Simple
Audio, ﬁlesystem
Location
RecordAudioACG
LocationACG
Speed of Sound Adjust volume based on driving speed
Complex
Bluetooth, location, internet
UpdateLocationACG
Pinpoi
Manage points of interest
Complex
Location, internet, ﬁlesystem UpdateLocationACG
WikiJourney
Show Wikipedia articles for nearby locations Moderate
Location, internet, ﬁlesystem UpdateLocationACG
Table 3: Summary of applications.
VoiceRecorder
Solar Compass
Speed of Sound Pinpoi WikiJourney
Original Layout
Original Java
Layout Changes
Java Changes, ACGs
Java Changes, SPARTA
SPARTA Annotations, manual
SPARTA Annotations, automatic
52
139
21
-50
3
3
0
224
308
7
9
7
14
0
338
1774
3
-71
79
149
0
586
3897
17
-16
129
224
487
458
1283
7
28
41
178
0
Table 4: Code changes to integrate ACGs.
sion, and permanent. This continues to adequately model
ACG use in applications. However, applications depend on
further customization and interaction. A software-based
design should consider these use cases. Paradigms we en-
counter include the following:
1. Conﬁguration: Applications pass conﬁguration op-
tions to Android resource APIs. For example, VoiceRe-
corder conﬁgures the audio recording API to customize
the audio output format.
2. Communication: Applications need to know not only
when the resource is available, but also when the user
interacts with the ACG in other ways. For example,
VoiceRecorder starts and stops a timer that displays
the duration of the recording, so it needs to react when
the user presses the “record” button.
3. Updates: Applications request periodic updates from
resource APIs. Three out of the ﬁve applications that
we evaluate ask for location updates when the user’s lo-
cation changes by some amount or when some amount
of time passes. This appears to be a common mode of
interaction for location access.
6.2 Fighting Evil: Security Analysis
We instantiate the classes of attacks we outline in Sec-
tion 3 and test that our tool defends against them. We are
unaware of available open-source malware for these attacks,
so we create our own testing framework for generating ap-
plication variants. We implement 57 attacks in EvilApp, a
test application. AUDACIOUS prevents 55 of these. The
two that it does not prevent are limited by lack of OS sup-
port. We revisit these attacks and detail the point at which
AUDACIOUS prevents them.
UI modiﬁcation attacks change the ACG UI after cre-
ation to trick the user into interacting with the ACG. Li-
brary design decisions prevent these attacks: The attacks
compile, but have no eﬀect on the UI.
Event forgery attacks create or modify events, or call
methods like performClick(). Some of these try to trick
the analysis by obfuscating the event ﬂow. The static event
analysis catches all of these attacks.
Cover attacks add application-level elements that overlap
with the ACG UI. The bitmap check stage of the dynamic
UI context check catches these.
Tapjacking attacks use system-level pop-up notiﬁcations
(Toasts) to cover the ACG UI and trick the user. The dy-
namic UI context check catches all but one of these. AUDA-
CIOUS does not catch the attack that partially obscures the
ACG UI because of the bug we have reported to Android.
Replay attacks capture events from the location of the
ACG and schedule them for a later point in time. The UI
at the time of the original event may or may not match
the ACG UI. The UI consistency stage of our dynamic UI
context check catches these.
Bait-and-switch attacks cover the ACG UI and then, at
the last minute, put the ACG UI on top so that at the time
of the UI check, the UI looks authentic. The random bitmap
check stage of the dynamic UI context check catches all but
one of these. AUDACIOUS does not catch the attack that
uses a Toast to do this, since there is no way to check the
obscured ﬂag during a random check.
Resource ﬂow attacks circumvent the library: They call
resource-accessing APIs directly, access resources that are
diﬀerent from the ones that users expect, or expose their
own buttons and directly access resources in response to
them. AUDACIOUS catches these attacks statically using
SPARTA, as all of them expose invalid ﬂows.
6.3 Random Check Frequency
AUDACIOUS uses random checks to guarantee that the
user has enough time to perceive the UI before interacting
with an ACG. Smaller frequencies for random checks provide
better protection against timing-based attacks. However,
frequent random checks add performance overhead. A more
sensitive ACG (for example, an ACG that handles payment
methods) may wish to use a smaller frequency at some cost
to performance.
We evaluate the performance impact on the UI of diﬀerent
validation frequencies on Solar Compass. Over 40 seconds,
VoiceRecorder
Solar Compass
Speed of Sound Pinpoi WikiJourney
SPARTA Warnings
SPARTA Errors
Event Analysis Errors
SPARTA Time (s)
Event Analysis Time (s)
2
0
0
46
5
1
0
0
55
9
8
1
0
77
7
26
21
0
96
9
17
0
2
66
24
Table 5: Static analysis performance.
we toggle the LocationACG button 30 times. We compute
the total time from the beginning of the ﬁrst event to the