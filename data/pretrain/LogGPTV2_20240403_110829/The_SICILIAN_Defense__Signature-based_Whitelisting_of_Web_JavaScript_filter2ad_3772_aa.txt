title:The SICILIAN Defense: Signature-based Whitelisting of Web JavaScript
author:Pratik Soni and
Enrico Budianto and
Prateek Saxena
The SICILIAN Defense:
Signature-based Whitelisting of Web JavaScript
∗
Pratik Soni
National University of Singapore, Singapore
{pratikso, enricob, prateeks}@comp.nus.edu.sg
Enrico Budianto
Prateek Saxena
ABSTRACT
Whitelisting has become a common practice to ensure the execu-
tion of trusted applications. However, its effectiveness in protecting
client-side web application code has not yet been established. In
this paper, we seek to study the efﬁcacy of signature-based white-
listing approach in preventing script injection attacks. This includes
a recently-proposed W3C recommendation called Subresource In-
tegrity (SRI), which is based on raw text signatures of scripts. Our
3-month long measurement study shows that applying such raw
signatures require signature updates at an impractical rate. We then
present SICILIAN1, a novel multi-layered approach for whitelisting
scripts that can tolerate changes in them without sacriﬁcing the se-
curity. Our solution comes with a deployment model called pro-
gressive lockdown, which lets browsers assist the server in compos-
ing the whitelist. Such assistance from the browser minimizes the
burden of building the signature-based whitelist. Our evaluation on
Alexa’s top 500 sites and 15 popular PHP applications shows that
SICILIAN can be fully applied to 84.7% of the sites and all the PHP
applications with updates to the whitelist required roughly once in
a month. SICILIAN incurs an average performance overhead of
7.02%.
Categories and Subject Descriptors
D.2.8 [Software Engineering]: Metrics; D.3.3 [Programming Lan-
guages]: Language Constructs and Features; D.4.6 [Operating
Systems]: Security and Protection
Keywords
Web security; whitelisting; script injection attacks
1.
INTRODUCTION
Whitelisting has become a common practice to ensure the exe-
cution of trusted application code. Mainstream operating systems
∗This work was done while the author was visiting NUS.
1Sicilian is one of the strongest and most successful defense openings in chess where
the player does not play for equality but for the advantage.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
c(cid:13) 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813710.
such as Windows and Linux check the signature of application
binaries against the public whitelist before installing them [59].
Browsers enable code signature veriﬁcation on its extensions to
make sure that its code is signed by a trusted party (e.g., Mozilla’s
AMO [38]). Although whitelisting has been successfully imple-
mented in several application platforms, its effectiveness in pro-
tecting web applications has not yet been established.
In this paper, we seek to study the efﬁcacy of signature-based
whitelisting in defending web applications against script injection
attacks. Script injection attacks are the most prevalent threat on
the web. They occur through many attack channels, such as cross-
site scripting (XSS) attacks or tampering with the scripts’ content
included from third-party services (e.g., CDNs [45,47] and popular
JavaScript libraries [30, 40]). In a web page’s context, a whitelist
can be deﬁned as a set of scripts that are authorized by the website
owner to execute at the client-side. This makes signature-based
whitelisting a strong defense against script injection attacks.
There have been solutions that propose the idea of signature-
based whitelisting to secure web applications, such as BEEP [29],
DSI [39], and Noncespaces [20]. Some of these ideas have taken
shape in mainstream web browsers such as Chrome and Firefox
in the form of a W3C recommendation known as Subresource In-
tegrity (SRI) [53]. SRI allows to specify a cryptographic hash
(SHA256) of the text of the script’s code as a signature that signiﬁes
the integrity of the script. This signature can be designated as the
integrity attribute of a  tag — we call such signatures as
raw signatures. The viability of a signature-based whitelisting ap-
proach relies on the premise that script signatures remain static over
time. Therefore, we hypothesize that such whitelisting is applica-
ble to websites that remain mostly static. To evaluate how many
websites fall in this category, we conduct a longitudinal study on
Alexa’s top 500 websites (45,066 web pages) and 15 popular PHP
applications, crawling with a depth limit of 3.
In the crawl, we
monitor 33,302 scripts for a 3-month period, starting 31st January
2015. The objective of this study is to understand how scripts on
these web pages change and determine the fraction of the websites
for which JavaScript whitelisting would be sufﬁcient. Our obser-
vation suggests that majority of the scripts on these websites are
indeed mostly static and have the following characteristics:
• Observation 1: Of the 33,302 scripts that we have crawled, only
2,313 scripts change over time. The changes in 586 out of 2,313
scripts preserve the code semantics. These changes are merely
syntactic changes like miniﬁcation, variable renaming and dif-
ferences in the code comments.
• Observation 2: 1,156 of the 2,313 scripts have changes that may
impact the code semantics, but the changes introduce no new
code. In fact, they affect only the data used in small portions of
1542the functionality in the website. For example, random tokens in
the query parameter of advertisement URLs.
– Scripts in Observation 1 and 2 together contribute 1,644 of
the 2,313 changing scripts (71.07%) – with 98 scripts be-
longing to both categories.
• Observation 3: We further categorize the changes in the remain-
ing 669 scripts (28.9%) as code-introducing updates. These are
due to the addition or deletion of code from the script. Based
on how frequently these happen, we observe two sub-classes:
461 scripts that change somewhat infrequently and 208 scripts
that change very frequently (Section 5).
Our Proposal. In our study, 97.99% of the scripts remain mostly
static: no new code is introduced in these scripts. Thus, we believe
whitelisting via signatures can be as effective in preventing script
injection as it has been in securing desktop application in binary
form. The raw signature mechanism, proposed in SRI, can be ap-
plied to 93% of the 33,302 scripts. However, only 69 out of 500
websites have all the scripts remaining static. Hence, we expect
SRI to have limited practical adoption on real-world websites as-is,
and will raise a high number of false positives (Section 5). There-
fore, we develop SICILIAN, a multi-layered solution for JavaScript
whitelisting, with the raw signature as the ﬁrst layer of defense and
a more relaxed signature as the second layer of defense. SICILIAN
interposes on all functions evaluated by the JavaScript parser mod-
ule in the browser and only allows scripts in the website’s whitelist
to be executed. Our relaxed signature mechanism is designed to
be secure, that is, without allowing the attacker any signiﬁcant ad-
vantage in constructing illegitimate scripts. We call our signature
mechanism structural signatures as they are based on the abstract
syntax tree representation (structure) of the script code. Structural
signatures are efﬁciently computable and robust against syntactic
changes in the scripts (Observation 1). Furthermore, our relaxed
signature scheme is designed to handle certain changes which are
beyond syntactic changes — as long as they do not introduce any
new code (Observation 2). This extends the applicability of our
idea to another 1,156 scripts of the 2,313 scripts which change.
Finally, of the 2,313 scripts, 461 scripts (20%) rarely change as
described in Observation 3. To handle these, we propose a mecha-
nism based on browser-server collaboration to efﬁciently update the
whitelist with the latest signatures, which we detail in Section 4.4.
We consider the remaining 208 scripts of 33,302 (only 0.62%) in
Observation 3 as beyond our scope due to their high update fre-
quency.
Progressive Lockdown Deployment. Script injection attacks have
been well-recognized in the past decade. Any solution to block
them faces a deployment challenge: the difﬁculty in using the so-
lution without raising false positives and without extensive manual
work. To smoothen the transition, we propose a new incremen-
tal approach called progressive lockdown. Our approach consists
of three phases: INIT, CRAWL, and LOCKDOWN (Section 4.3).
First, our signature protection mechanism is only meant for mostly
static websites and therefore it is an opt-in mechanism. When a
website registers to use SICILIAN, it can start with an INIT phase.
This is a pre-deployment testing phase for compiling the initial
whitelist by locally scanning the website. Note that the initial white-
list database may not be complete during this phase. Next, there is
an optional CRAWL phase, in which the website can get feedback
from the users’ browsers about the scripts that were not covered
during the testing — hence the browsers assist the website in com-
posing the whitelist. These scripts are added to the whitelist based
on a trust-on-ﬁrst-use (TOFU) assumption, meaning that the ﬁrst
time a browser sees a script out of the whitelist in the CRAWL
phase, it locally compiles a signature for the script and then sends
it to the whitelist. This phase is optional and only required on web-
sites for which the INIT phase is insufﬁcient. The CRAWL phase
is assumed to have a similar trust assumption as the trust-on-ﬁrst-
use in SSH [58]. Finally, after the whitelist is sufﬁciently pop-
ulated, the site initiates the LOCKDOWN phase. In the LOCK-
DOWN phase, the server can turn on a speciﬁc header to initiate
a lockdown procedure. During this phase, no scripts outside this
whitelist will be executed by the client. Thus, we progressively
lock down the versions of the scripts that can execute under a web
page. Similar incremental deployment models have been success-
ful in blocking mixed content vulnerabilities [27, 37] on the web
and we believe this makes a pragmatic alternative for a wider adop-
tion of the solution.
Evaluation on Alexa’s Top 500. We evaluate our solution on
Alexa’s top 500 sites with the objective of measuring the reduction
in false positives and the performance overhead of our approach.
Our evaluation covers changes in scripts with respect to time and
multiple user accounts. Our evaluation on Alexa’s top websites
shows that a SICILIAN-enabled browser introduces 4.68% perfor-
mance overhead over a SRI-enabled browser and 7.02% overhead
over the vanilla browser. Such overhead is acceptable for all but
the most latency-sensitive websites. Furthermore, SICILIAN can be
fully applied to 372 domains with updates required only once in a
month. Therefore, SICILIAN covers ﬁve times more domains than
SRI, which is based on raw signatures (69 domains).
Contributions. We make the following contributions in the paper.
• We conduct a 3-month study on how scripts change in the Alexa
Top 500 sites and 15 popular PHP applications to evaluate the
efﬁcacy of JavaScript whitelisting via script signatures. We
monitor changes with respect to time and multiple users.
• We propose SICILIAN, a multi-layered whitelisting approach
based on signatures to prevent script injection attacks. SICIL-
IAN employs a novel signature scheme, structural signatures
which rely on source code structure and are secure & robust
against syntactic changes in the scripts. On average, structural
signatures reduce the frequency of signature updates by four
times over raw signatures.
• We propose a browser-assisted deployment model called pro-
gressive lockdown, a pragmatic approach to incrementally build
the whitelist for preventing script injection attacks.
2. PROBLEM DEFINITION
We discuss various channels available to carry out script injec-
tion attacks (Section 2.1), problems with existing approaches (Sec-
tion 2.2) and deﬁne our problem statement (Section 2.3).
2.1 Channels of Script Injection
Web applications are vulnerable to a variety of script injection
attacks. First, such attacks can happen via cross-site scripting vul-
nerabilities (XSS). XSS proliferates as a result of executing illegit-
imate scripts within an origin. Such illegitimate script originates
from attacker-controlled data to the server’s code which are re-
ﬂected to the generated HTML content (i.e., reﬂected XSS), from
persistent storage (i.e., persistent XSS), or by utilizing unsafe usage
of several JavaScript DOM objects (i.e., DOM-based XSS [31,48]).
Second, an attacker can tamper with the scripts’ contents via in-
secure networks or due to unauthorized modiﬁcations at the third-
party servers. Such attacks come in many variants, most notably
are attacks where malware resides in third-party scripts provider,
like those of CDNs or servers of popular JavaScript libraries. An
1543increasing demand for using external JavaScript libraries and CDN-
based hosting makes them the primary target to malware attacks,
as has been reported recently [30, 45, 47]. Once the malware runs
on the server, it has unfettered access to tamper with the scripts’
content which is sent to the embedding websites. Additionally, in
typosquatting XSS attacks (TXSS) [40], the attacker makes use of
the developer’s mistake of mistyping the URL address of the script
resources. As a result, such mistyping leads to a script resource
being loaded from attacker-controlled servers.
2.2 Problems with Existing Approaches
To defend against script injection attacks, a number of counter-
measures have been proposed, ranging from sanitization [44, 56],
privilege separation [4, 8, 20], conﬁnement [3, 13], ﬁltering [6], to
various policy enforcement mechanisms [29,52]. We make the fol-
lowing observations explaining why previous works are insufﬁcient
to handle script injection attacks.
Handling Multiple Injection Channels is Difﬁcult. In script in-
jection attacks, a web application is vulnerable to malicious script
injection via multiple injection channels in the browser (Section 2.1).
Therefore, enforcing a reactive approach by securing each and ev-
ery script injection channel in the browser is not a pragmatic ap-
proach due to: 1) a plethora of channels in the browser and web
applications to hook; and 2) the continuous addition of new fea-
tures and web speciﬁcations to the browser [51]. For example, the
client-side web provides a wide array of features, such as browser
extensions, cross-origin channels, and local storage that an attacker
can exploit to execute malicious scripts.
Weak Notion of Malicious Script. Many existing solutions cat-
egorize malicious scripts based on the origin or context in which
such scripts are being executed. For example, CSP “over-generalizes”
malicious scripts as any scripts injected via inline scripts [18] or
eval(). As a result, developers who legitimately use inline scripts
and would like to retroﬁt CSP into their web application will suffer
from such an approach. They must relocate their code from inline
HTML tag to make the application comply with CSP – this raises
deployability burden as discussed in [15, 16, 57]. Many other so-
lutions also have a loose notion of malicious scripts. For example,
DSI [39] “under-generalizes” script injection as privilege escala-
tion where untrusted DOM nodes try to execute scripts. While this
clearly provides protection against script injection via untrusted in-
line content, it does not give any security guarantees for attacks
like DOM-based XSS, where legitimate-but-vulnerable DOM ob-
jects evaluate a potentially untrusted data into code.
Browser Variations. There are many subtleties, incoherencies,
and variations in the implementation of browsers that may lead to
script injection attacks [46]. For example, ﬁltering bad input for
XSS is known to be hard since browsers have their own way of
interpreting or blocking certain inputs. Therefore attacker may tar-
get certain browsers for injecting payloads. The XSS ﬁlter evasion
cheat sheet as issued by OWASP is also non-exhaustive [41]. Fur-
ther, attacks such as mXSS work even when a website is properly
sanitized because such attacks exploit the subtleties in the underly-
ing browser implementation, particularly the backtick implementa-
tion [23].
2.3 Problem Statement
Our goal is to propose a solution to mitigate script injection at-
tacks via signature-based whitelisting of JavaScript. To do so, we
ﬁrst evaluate the efﬁcacy of existing script signature techniques on
real-world web applications, consisting of Alexa’s top 500 sites and
15 popular PHP applications (Table 1 Section 5). Motivated by the
kind of changes observed in these scripts, we propose SICILIAN,
a robust multi-layered defense to block script injection attacks. In
this work, we answer the following research questions.
• RQ1: Are raw signatures practical in real-world websites?
• RQ2: Do scripts on the web change? If so, what kinds of
changes are reﬂected in them, with respect to time and users?
• RQ3: What are the characteristics of a signature scheme that is
secure and robust for practical adoption?
• RQ4: Is whitelisting via script signatures sufﬁcient to prevent
script injection attacks?
Threat Model & Scope. We consider the attacker to be a web at-