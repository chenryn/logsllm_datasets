# func "SN2013-08-022" call hardware hal_info
（3）API模式
import func.overlord.client as func
client = func.Client（"SN2013-08-022"）
print client.hardware.info（with_devices=True）
print client.hardware.hal_info（）
8.系统Mount管理模块
（1）功能
MountModule实现远程主机Linux系统挂载、卸载分区管理。
（2）命令行模式
# func "SN2013-08-022" call mount list
# func "SN2013-08-022" call mount mount /dev/sda3 /data
# func "SN2013-08-022" call mount umount "/data"
（3）API模式
import func.overlord.client as func
client = func.Client（"SN2013-08-022"）
print client.mount.list（）
print client.mount.umount（"/data"）
print client.mount.mount（"/dev/sda3"，"/data"）
9.系统进程管理模块
（1）功能
ProcessModule实现远程Linux主机进程管理。
（2）命令行模式
# func "SN2013-08-022" call process info "aux"
# func "SN2013-08-022" call process pkill nginx -9
# func "SN2013-08-022" call process kill nginx SIGHUP
（3）API模式
import func.overlord.client as func
client = func.Client（"SN2013-08-022"）
print client.process.info（"aux"）
print client.process.pkill（"nginx"， "-9"）
print client.process.kill（"nginx"， "SIGHUP"）
10.系统服务管理模块
（1）功能
ServiceModule实现远程Linux主机系统服务管理。
（2）命令行模式
# func "SN2013-08-022" call service start nginx
（3）API模式
import func.overlord.client as func
client = func.Client（"SN2013-08-022"）
print client.service.start（"nginx"）
11.系统内核参数管理模块
（1）功能
SysctlModule实现远程Linux主机系统内核参数管理。
（2）命令行模式
# func "SN2013-08-022" call sysctl list
# func "SN2013-08-022" call sysctl get net.nf_conntrack_max
# func "SN2013-08-022" call sysctl set net.nf_conntrack_max 15449
（3）API模式
import func.overlord.client as func
client = func.Client（"SN2013-08-022"）
print client.sysctl.list（）
print client.sysctl.get（'net.ipv4.icmp_echo_ignore_broadcasts'）
print client.sysctl.set（'net.ipv4.tcp_syncookies'， 1）
func命令功能参数举例：
1）查看所有主机uptime，开启5个线程异步运行，超时时间为3秒，命令如
下：
# func -t 3 "*" call --forks="5" --async command run "/usr/bin/uptime"
2）格式化输出结果，默认格式为Python的元组，分别添加--jsion或--xml来
输出JSON及XML格式，命令如下：
# func -t 3 "*" call --forks="5" --json --
async command run "/usr/bin/uptime"
11.3 自定义Func模块
Func自带的模块已经非常丰富，但在日常系统运维当中，尤其是面对大规模
的服务器集群、不同类别的业务平台，此时Func自带的模块或许已经不能满足
我们的需求，所以有必要通过自定模块来填补这块的不足。本节介绍一个简单
的Func自定义模块的，通过采用Func自带的建模块工具func-create-module来现
实。
（1）自定义模块步骤
如图11-3所示，自定义模块分为四个步骤进行，第一步生成模块，即通过
fun-create-module命令创建模块初始模板；第二步编写逻辑，即填充我们的业务
功能逻辑，生成模块；第三步分发模块，将编写完成的模块分发到所有被控主
机；第四步执行已经分发完成的模块，调用方法与Func自带模块无差异。详细
过程见图11-3。
图11-3 自定义模块发布流程
（2）生成模块
切换到Func安装包minion模块存储目录。笔者使用的是系统自带的Python
2.6，具体路径为/usr/lib/python2.6/site-packages/func/minion/modules。
# cd /usr/lib/python2.6/site-packages/func/minion/modules
运行创建模块命令func-create-module，根据图11-14填写相关信息。
图11-4 创建模块时填写的信息
最终生成了一个初始化的模块代码文件mymodule.py：
【/usr/lib/python2.6/site-packages/func/minion/modules/mymodule.py】
#
# Copyright 2014
# liutiansi 
#
# This software may be freely redistributed under the terms of the GNU
# general public license.
#
# You should have received a copy of the GNU General Public License
# along with this program； if not， write to the Free Software
# Foundation， Inc.， 675 Mass Ave， Cambridge， MA 02139， USA.
import func_module
class Mymodule（func_module.FuncModule）：
# Update these if need be.
version = "0.0.1"
api_version = "0.0.1"
description = "My module for func."
def echo（self）：
"""
TODO： Document me ...
"""
pass
（3）编写逻辑
这一步只需在上述模块基础上做修改即可，如模块实现一个根据指定的条数
返回最新系统日志（/var/log/messages）信息，修改后的代码如下：
【/usr/lib/python2.6/site-packages/func/minion/modules/mymodule.py】
#
# Copyright 2010
# liutiansi 
#
# This software may be freely redistributed under the terms of the GNU
# general public license.
#
# You should have received a copy of the GNU General Public License
# along with this program； if not， write to the Free Software
# Foundation， Inc.， 675 Mass Ave， Cambridge， MA 02139， USA.
import func_module
from func.minion import sub_process
class Mymodule（func_module.FuncModule）：
# Update these if need be.
version = "0.0.1"
api_version = "0.0.1"
description = "My module for func."
def echo（self，vcount）：
"""
TODO： response system messages info
"""
command="/usr/bin/tail -n "+str（vcount）+" /var/log/messages"
cmdref = sub_process.Popen（command， stdout=sub_process.PIPE，
stderr=sub_process.PIPE， shell=True，
close_fds=True）
data = cmdref.communicate（）
return （cmdref.returncode， data[0]， data[1]）
（4）分发模块
首先编写分发模块的功能，使用Func的copyfile模块来实现，原理比较简
单，即读取主控端func minion包下的模块文件（参数传入），通过Func的
copyfile模块同步到目标主机的同路径下。一次编写可持续使用，源码如下：
【/home/test/func/RsyncModule.py】
#！/usr/bin/python
import sys
import func.overlord.client as fc
import xmlrpclib
module = sys.argv[1]
pythonmodulepath="/usr/lib/python2.6/site-packages/func/minion/modules/"
client = fc.Client（"*"）
fb = file（pythonmodulepath+module， "r"）.read（）
data = xmlrpclib.Binary（fb）
#分发模块
print client.copyfile.copyfile（pythonmodulepath+ module，data）
#重启Func服务
print client.command.run（"/etc/init.d/funcd restart"）
分发模块的运行结果如图11-5所示。
图11-5 模块分发结果
检查被控主机/usr/lib/python2.6/site-packages/func/minion/modules目录是否多
了一个mymodule.py文件，是则说明模块已经成功分发。
（5）执行模块
最后，执行模块及返回结果见图11-6。
图11-6 执行模块结果
正常返回了5条/var/log/messages信息，完成了自定义模块的全过程。
11.4 非Python API接口支持
Func通过非Python API实现远程调用，目的是为第三方工具提供调用及返回
接口。Func使用func-transmit命令来实现，支持YAML与JSON格式，实现了跨应
用平台、语言、工具等，比如通过Java或C生成JSON格式的接口定义，通过fun-
transmit命令进行调用，使用上非常简单，扩展性也非常强。
定义一个command模块的远程执行，分别采用YAML及JSON格式进行定义，
如下：
【/home/test/func/run.yaml】
clients： "*"
async： False
nforks： 1
module： command
method： run
parameters： "/bin/echo Hello World"
【/home/test/func/run.json】
{
"clients"： "*"，
"async"： "False"，
"nforks"： 1，
"module"： "command"，
"method"： "run"，
"parameters"： "/bin/echo Hello World"
}
各参数详细说明如下。
·clients，目标主机，"*"代表所有被控主机；
·async，是否异步，是一个布尔值，True为使用异步，False则不使用；
·nforks，启用的线程数，用数字表示；
·module，模块名称，如command、copyfile、process等；
·method，方法名称，如command模块下的run方法；
·parameters，参数，如"/usr/bin/tail-100/var/log/messages"。
通过func-transmit命令调用不同接口配置，将返回不同的格式串，如图11-7
和图11-8所示。
图11-7 返回标准的YAML格式
图11-8 返回标准的JSON格式
返回的两种格式都可以被绝大部分语言所解析，方便后续处理。
11.5 Func的Facts支持
Facts是一个非常有用的组件，其功能类似于Saltstack的grains、Ansible的
Facts，实现获取远程主机的系统信息，以便在对目标主机操作时作为条件进行
过滤，产生差异。Func的Facts支持通过API来扩展用户自己的属性。Facts由两部
分组成，一为模块（module），另为方法（method），可通过
list_fact_modules、list_fact_methods方法来查看当前支持的模块与方法的清单，
如图11-9所示。
图11-9 查看主机支持模块及方法
在使用Facts时，我们关注它的方法（func"*"call fact list_fact_methods显示的
清单）即可，可通过命令行调用Facts的call_fact方法查看所有主机的操作系统信
息，具体见图11-10。
图11-10 查看主机操作系统信息
Fact支持and与or作为条件表达式连接操作符，下面详细介绍。
（1）and表达式--filter
语法：
--filter "keyword[operator]value，keyword2[operator]value2"
--filter "value in keyword，value ini keyword"
示例：所有满足内核（kernel）版本大于或等于2.6，并且操作系统信息包含
CentOS的目标主机运行uptime命令，如图11-11所示。
图11-11 根据fact条件（and）过滤主机
（2）or表达式--filteror
语法：
--filteror "keyword[operator]value，keyword2[operator]value2"
--filteror "value in keyword，value ini keyword"
示例：所有满足内核（kernel）版本大于或等于2.6，或者运行级别等于5的
目标主机运行df-m命令，如图11-12所示。
图11-12 根据fact条件（or）过滤主机
参考提示 11.1节~11.5节关于Func的介绍参考官网文档
https://fedorahosted.org/func/。
第12章 Python大数据应用详解
随着云时代的到来，大数据（big data）也越来越受大家的关注，比如互联网
行业日常生成的运营、用户行为数据，随着时间及访问量的增长这一规模日益
庞大，单位可达到日TB或PB级别。如何在如此庞大的数据中挖掘出对我们有用
的信息？目前业界主流存储与分析平台是以Hadoop为主的开源生态
圈，MapReduce作为Hadoop的数据集的并行运算模型，除了提供Java编写
MapReduce任务外，还兼容了Streaming方式，我们可以使用任意脚本语言来编写
MapReduce任务，优点是开发简单且灵活。本章详细介绍如何使用Python语言来
实现大数据应用，将分别通过原生Python与框架（Framework）方式进行说明。
提示 因为Hadoop不作为本章的主体内容，所以将不对其架构、子
项目、优化等进行说明。
12.1 环境说明
为了方便读者理解，笔者通过虚拟化环境部署了Hadoop平台来进行演示，操
作系统版本为CentOS release 6.4，以及Python 2.6.6、hadoop-1.2.1、jdk1.6.0_45、
mrjob-0.4.2等。相关服务器信息如表12-1所示。
表12-1 环境说明表
12.2 Hadoop部署
由于部署Hadoop需要Master访问所有Salve主机实现无密码登录，即配置账号