title:Analyses of the Reverse Path Forwarding Routing Algorithm
author:Christie Bolton and
Gavin Lowe
Analyses of the Reverse Path Forwarding
Routing Algorithm
Christie Bolton
Gavin Lowe
Oxford University Computing Laboratory
Wolfson Building
Parks Road
Oxford OX1 3QD
{christie,gavinl}@comlab.ox.ac.uk
Abstract
The reverse path forwarding algorithm is a protocol for
distributing messages throughout networks. The inten-
tion is to preserve correctness—messages sent will eventu-
ally be received by all nodes in the originator’s connected
component—whilst minimising the number of propagations
of each message.
We use a variety of analysis techniques to identify neces-
sary additional constraints, and to prove correctness under
these conditions. In particular we present counter exam-
ples found by the model-checkers FDR and the Alloy Ana-
lyzer, illustrating that the protocol is incorrect if the cost of
links is dependent upon the node using that link. We then
consider the case where the cost of links is independent of
the node using that link; we use a special-purpose network
sampling program to increase conﬁdence in the correctness
of this stricter protocol, and then perform a hand-proof to
verify correctness. We conclude with a discussion of the
suitability of these techniques for reasoning about proto-
cols of this complexity.
1. Introduction
In networks, nodes need to know the best path by which
to route messages to other nodes. In order to do this, nodes
exchange information about network links, so that the best
route can be calculated. Obviously correctness—that ev-
ery message sent will eventually be received by all nodes
in the originator’s connected component—is of paramount
importance but, as communication networks become larger
and more pervasive, efﬁciency—minimising the number
of propagations of each message—becomes highly signiﬁ-
cant.
We study here the reverse path forwarding routing algo-
rithm (RPF) [1], a particular protocol or technique for dis-
tributing information about the state of network links that
is often used as part of larger protocols on distributed net-
works. In this protocol, each node maintains a record of its
perception of the state of the system, and continually broad-
casts this information throughout the network. Each piece
of information is time-stamped, and a node will update its
routing tables only in response to receiving link-state infor-
mation that is more recent than the currently stored infor-
mation.
The reverse path forwarding protocol, as usually stated,
is under-speciﬁed and open to different interpretations:
whilst it is made clear that packets are dropped if they are
sent along a path that is not the reverse of the path that the
recipient would use to send a message to the sender, it is
left undeﬁned how such paths should be calculated. Our
initial remit in this piece of work was both to identify and
explore the correctness of different interpretations of the re-
verse path forwarding algorithm, and to determine the suit-
ability and effectiveness of two existing model-checkers for
performing such an analysis.
The reverse path forwarding algorithm is similar to the
link state routing algorithm [2] in that every node main-
tains a map recording its belief about the state of the net-
work. The main difference is that instead of using ﬂooding,
whereby all messages are propagated, in the reverse path
forwarding algorithm nodes may choose to ignore mes-
sages. In particular, each node n accepts a packet or mes-
sage received from node p that was initiated by node i only
if n believes that p is the ﬁrst node on n’s shortest path to i;
we will call p the provider to n for i in this case. We illus-
trate this in Figure 1.
It can be easily shown that under stable network con-
ditions (i.e. where routing tables don’t change), reverse
path forwarding works correctly in the sense that a broad-
cast is accepted exactly once by every node in the origina-
tor’s connected component, and the re-broadcasting even-
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:51:36 UTC from IEEE Xplore.  Restrictions apply. 
2
n
4
3
20
4
3
p
2
i
Figure 1. Node n accepts a packet initiated by i only if it is received from p, since p is the ﬁrst node on the shortest
path from n to i.
tually stops. However, as noted in [1], if the routing tables
change, a broadcast message might never be accepted by a
node.
This paper investigates the hypothesis that if the state
of the links eventually stabilises (i.e. they stop breaking
and being remade) and if the algorithm is correctly applied,
then the system will eventually stabilise into a state where
every node has the correct information about every link in
its connected component, and so all subsequent messages
are correctly received. A variety of tools and techniques
are used in the investigation.
Our results show that the hypothesis is false: we present
counter examples found by the model-checkers FDR and
the Alloy Analyzer, illustrating that, under the interpreta-
tion that the cost of links is dependent upon the node using
that link, the protocol is incorrect. We then use a special-
purpose network sampling program to increase our con-
ﬁdence in the correctness of the protocol assuming addi-
tional constraints to overcome this error. Finally we per-
form a hand-proof to verify correctness under these condi-
tions.
The main contributions are therefore: the exploration of
several different interpretations of the reverse path forward-
ing protocol; the identiﬁcation of an error in a reasonable
interpretation of the protocol that can lead to nodes in a
stable network having incorrect information about links in
their connected component; a proof of the correctness of a
stricter variant of the protocol in which the cost of links is
independent of node; and a comparative case study lead-
ing to a discussion of the suitability of these techniques for
reasoning about protocols of this complexity.
The paper begins with a detailed description of the re-
verse path forwarding routing algorithm and its complex-
ities, and a discussion of our choices of tools and tech-
niques. The following three sections discuss our tool-based
analysis of the algorithm, ﬁrstly using FDR [3] the model-
checker for the process algebra CSP [4, 5], secondly using
the Alloy Analyzer [6], and thirdly using a special-purpose
Java programme. In Section 6 we present a hand proof of
the validity of the algorithm before concluding in Section 7
with a discussion of our ﬁndings. The code for the auto-
matic analyses is included in [7].
2. The Reverse Path Forwarding algorithm
and our chosen veriﬁcation techniques.
In any distributed network an efﬁcient and reliable pro-
tocol is needed to pass packets between nodes. Vari-
ous routing algorithms have been proposed to achieve this
end. A routing algorithm should ensure that, provided the
source and destination nodes are connected, each packet
sent should eventually reach its destination. If the source
and destination nodes are not directly connected then this
will take multiple hops. Furthermore, the problem becomes
more complicated if the network is dynamic and links may
be made or broken.
Simple algorithms such as the ﬂooding algorithm
achieve this by forwarding every incoming packet that has
not reached its destination on every path except that on
which it arrived. Although this protocol satisﬁes the cor-
rectness condition it is highly inefﬁcient.
The reverse path forwarding routing algorithm [1] is
an example of an adaptive routing algorithm: the path on
which a node sends a packet is determined by that node’s
current perception of the state of the system, be it the topol-
ogy of the network or the number of packets passing along
each link. Beliefs about the state of the system are regu-
larly updated as messages about changes in the state are
propagated throughout the system. Hence the choice of
path along which to send these messages and packets is
also regularly updated.
The reverse path forwarding routing algorithm [1] is
similar to the link state routing algorithm in that every node
maintains a map recording its belief about the state of the
network; every node determines the distance to each of its
direct neighbours, and regularly distributes packets con-
taining this information throughout the system. The main
difference is that instead of propagating all messages that
have not reached their destination using ﬂooding, nodes
take responsibility for determining whether or not mes-
sages are redundant.
More speciﬁcally, the originator of a message broad-
casts it to all its neighbours. A node id will accept a mes-
sage that it receives from node p and that originated from i
only if p is the ﬁrst node on the route that id would use to
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:51:36 UTC from IEEE Xplore.  Restrictions apply. 
route messages to i; we will call p the provider to id for i in
this case. If routing is symmetric, then this is equivalent to
saying that id normally receives from p messages that orig-
inate from i. If id accepts a message, it then broadcasts it to
all its neighbours except p. Observe that a node i need not
in general be a provider for itself to another node id even if
there is a direct link between the two nodes.
There are really two aspects of the protocol: the choos-
ing of routes given link state information; and the method
of broadcasting given those routes. As observed in Sec-
tion 1, the way in which routes are chosen from link state
information is left underspeciﬁed; in this paper we will
adopt and explore the correctness of several different in-
terpretations.
2.1. Complexity
We consider now the complexity of the system: why
current model-checkers can consider only very small sys-
tems.
Since every link in the system can be either up or down,
and assuming that knowledge about the state of any link
can be either “old” or “recent”1 it follows that each node
can have any one of four beliefs about the state of any link.
Hence, in a network with a possible n links, each node can
have any one of 4n beliefs. Moreover, there must be 4mn
belief sets in a network with m nodes and n links.
We see that the number of networks to be considered is
exponential both in the number of nodes and the number of
links. When considering a system as small as a four-node
ring we need to consider the 416 ≈ 4× 109 possible states
that the network could be in. This is close to the limit that
can be analysed using explicit state exploration with current
technology.
2.2. Choice of veriﬁcation techniques
There are a wide variety of tools and techniques avail-
able for automatically verifying the correctness of proto-
cols. Model-checkers are typically excellent at identifying
ﬂaws or errors but can consider only ﬁnite systems. Other
techniques should then be applied to prove the extensibil-
ity of results. Theorem provers, on the other hand, are very
useful for proving results correct even for large or inﬁnite
systems. However, if the conditions are not quite right,
theorem provers seldom shed light on how they should be
adapted.
Part of our remit in this project was to compare the
model checkers FDR and the Alloy Analyzer, associated
respectively with the process algebra CSP and the state-
based speciﬁcation language Alloy, and so these were our
1In Section 3 we discuss the simplifying assumption that knowledge is
either “old” or “recent” and deﬁne formally what we mean by these terms.
ﬁrst two choices of veriﬁcation techniques. The results of
these analyses are presented in Sections 3 and 4. A com-
parison of the two tools is presented in Section 7.3.
As observed above, the number of possible networks to
be considered is exponential both in the number of nodes
and the number of links, and even the most simple of sys-
tems will stretch current technology to its limits. Although
both tools found an error—an inconsistency in beliefs be-
tween connected nodes about the status of a link in a stable
network—in the protocol for a small network, thereby in-
dicating necessary additional constraints, even four node
rings pushed them to the limit of their capabilities. To be
conﬁdent that there were no errors for larger systems, even
with these additional constraints, alternative proof tech-
niques were necessary.
Before attempting a hand-proof we needed to be con-
ﬁdent that our constraints were sufﬁcient and so we used
a specially built tool that generated large numbers of net-
works satisfying these constraints and checked for errors;
this tool is discussed in detail in Section 5. The hand-proof
is presented in Section 6.
3. CSP-based analysis
As observed by Clarke et al. in [8] and by Steiner et
al. in [9], model-checking is an increasingly important
technique in the veriﬁcation and validation of the correct-
ness of systems.
CSP [4, 5] is a mathematical language for capturing
the behaviour of systems by recording the occurrence of
events, or exchange of messages between components.
Analysis of the system can then be performed by using the
model-checker FDR to compare a formal speciﬁcation—a
simple process capturing speciﬁc desired properties of the
system—with the process describing the model itself.
In this section we present the results of our CSP-based
analysis. We resolve the under-speciﬁcation of the protocol
and model two different interpretations of the way in which
routes are selected from link state information. We present
the results of our analysis of each and conclude the section
with a discussion of the validity of the errors found in each
model.
3.1. Features common to both models
The key events when modelling the reverse path for-
warding algorithm represent the making and breaking of
links, and the propagation of information about the status
of links. The events make.{i,j} and break.{i,j} respec-
tively represent the making and the breaking of the link
that connects nodes i and j. The event send.i.j.k.l.s.t repre-
sents node i telling node j that t time units ago node k said
that the link between it and node l had status s, either Up or
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:51:36 UTC from IEEE Xplore.  Restrictions apply. 
Down.
We need also an event that represents the selection or
re-selection by a node of the provider for another node to
which it is connected. For instance, if the information about
the status of a link connecting nodes k and l received by
node j from node i in the message send.i.j.k.l.s.t is more
recent than j’s current belief of the status of that link, then j
will update its routing tables accordingly, and might need to
re-set its providers. The event setProvider.i.j.k represents
node i selecting node k as its provider for node j.
Since the send messages require a time stamp, in addi-
tion we need an event tock that represents the passage of
time. An abstraction of our model is that whenever a tock
event occurs all information about non-adjacent links be-
comes old. We therefore only require the time-stamps 0
and 1, indicating whether or not the information is recent.
Finally, for our validity checks, we need an event that
communicates a node’s belief about the status of a link: the
event signal.i.{j,k}.s indicates that node i believes that the
link connecting nodes j and k has status s.
For each model we verify correctness by performing a
reﬁnement check that determines whether any node can
signal an incorrect belief about the status of a link in its
connected component when the network is stable. With-
out loss of generality, we assume in each case that the net-
work under consideration is initially fully connected, and
that initially every node has recent and correct information
about the status of every link.
3.2. First CSP interpretation
In the ﬁrst CSP interpretation of the reverse path for-
warding algorithm we abstract away from the costs of
edges so that a node’s choice of provider for one node is
independent of its selection of provider for all other nodes.
Hence, the provider is chosen nondeterministically from all
those nodes that could feasibly be a provider. More speciﬁ-
cally, each node id chooses providers for each other node n
by picking the ﬁrst node p on some cycle-free path from id
to n along only those edges that it believes to be up.2
As depicted in Figure 2, FDR ﬁnds an error in this inter-
pretation when considering a three node ring. This occurs