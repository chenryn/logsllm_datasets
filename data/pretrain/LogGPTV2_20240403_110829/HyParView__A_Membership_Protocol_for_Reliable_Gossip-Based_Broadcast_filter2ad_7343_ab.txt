cost-effective gossip protocols.
ii) High failure rates may have a strong impact on the
quality of partial views. Even if the membership protocol
has healing properties, the reliability of message broadcasts
after heavy failures may be seriously affected. Therefore,
gossip would strongly beneﬁt from membership protocols
with fast healing properties, which can be achieved by also
using TCP as a failure detector.
In the following paragraphs, we show some ﬁgures that
illustrate these facts.
3.1. On the Fanout Value
The ﬁrst two plots in Figure 1 show simulation results
where we depict the reliability of the protocol delivering
50 messages sent by a gossip protocol that uses Cyclon or
Scamp as the underlying membership protocol. The simula-
tions were run with a network of 10.000 nodes (we describe
our simulation model in detail later in Section 5). As it
can be observed, in order to obtain reliability values above
99%, Cyclon requires a fanout of 5; it requires a fanout of
6 to achieve values near 99, 9%. Scamp requires a fanout
of 6 to reach values of reliability above the 99%. In this
run, with a fanout of 6, there are potentially 20.000 extra
messages exchanged than in a scenario that uses a fanout
of 4 (by the results presented in [4], this fanout should en-
sure a reliability between 98% and 99%). More than 99%
of these 20.000 extra messages are redundant, which means
that less than 200 of these messages will, in fact, contribute
to actual deliveries. We will later show that our approach al-
lows to achieve higher reliability with a fanout value close
to log(n).
3.2. Eﬀect of Failures
The last plot in Figure 1 depicts reliability ﬁgures for the
100 messages exchanged after heavy node failure. In this
scenario, we have failed 50% of the system nodes, and mea-
sured the effect on a network of 10.000 nodes using Cyclon
and Scamp as the membership protocol. These messages
are sent before Cyclon has the opportunity to execute a cy-
cle of shufﬂe (note that the Cyclon period is typically large
enough to exchange several thousands of messages), or be-
fore the lease time of Scamp expires. As it can be observed,
reliability is lost (as no message is ever delivered to more
than 85% of the nodes, and many messages are delivered
to a much smaller numbers of nodes). This long period of
unstable behavior may be unacceptable in applications ex-
hibiting high reliability requirements and high throughput.
4. The HyParView Protocol
4.1. Overview
The HyParView protocol maintains two distinct views at
each node. A small active view of size fanout+1, as links
are symmetric and thus each node must avoid relaying each
message back to the sender. A larger passive view, that en-
sures connectivity despite a large number of faults and must
be larger than log(n). Note that the overhead of the passive
view is minimal, as no connections are kept open.
The active views of all nodes create an overlay that is
used for message dissemination. Links in the overlay are
symmetric. This means that if node q is in the active view
of node p then node p is also in the active view of node
q. As we have stated before, our architecture assumes that
nodes use TCP to broadcast messages in the overlay. This
means that each node keeps an open TCP connection to ev-
ery other node in its active view. This is feasible because
the active view is very small. When a node receives a mes-
sage for the ﬁrst time, it broadcasts the message to all nodes
of its active view (except, obviously, to the node that has
sent the message). Therefore, the gossip target selection is
deterministic in the overlay. However, the overlay itself is
created at random, using the gossip membership protocol
described in this section.
A reactive strategy is used to maintain the active view.
Nodes can be added to the active view when they join the
system. Also, nodes are removed from the active view when
they fail. The reader should notice that each node tests its
entire active view every time it forwards a message. There-
fore, the entire broadcast overlay is implicitly tested at every
broadcast, which allows a very fast failure detection.
In addition to the active view, each node maintains a
larger passive view. The passive view is not used for mes-
sage dissemination. Instead, the goal of the passive view is
to maintain a list of nodes that can be used to replace failed
members of the active view. The passive view is maintained
using a cyclic strategy. Periodically, each node performs a
shufﬂe operation with one random node in order to update
its passive view.
One interesting aspect of our shufﬂe mechanism is that
the identiﬁers that are exchanged in a shufﬂe operation are
not only from the passive view: a node also sends its own
identiﬁer and some nodes collected from its active view to
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:49:01 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007(a) Cyclon
(b) Scamp
(c) 50% node failure
Figure 1. Fanout x Reliability and Effect of failures
its neighbor. This increases the probability of having nodes
that are active in the passive views and ensures that failed
nodes are eventually expunged from all passive views.
4.2. Join Mechanism
Algorithm 1 depicts the pseudo-code for the join opera-
tion. When a node wishes to join the overlay, it must know
another node that already belongs to the overlay. We name
that node the contact node. There are several ways to learn
about the contact node, for instance, members of the overlay
could be announced through a set of well known servers.
In order to join the overlay, a new node n establishes
a TCP connection to the contact node c and sends to c a
JOIN request. A node that receives a JOIN request will start
by adding the new node to its active view, even if it has to
drop a random node from it. In this case a DISCONNECT
notiﬁcation is sent to the node that has been dropped from
the active view. The effect of the DISCONNECT message is
described later in the section.
The contact node c will then send to all other nodes in its
active view a FORWARDJOIN request containing the new
node identiﬁer. The FORWARDJOIN request will be prop-
agated in the overlay using a random walk. Associated to
the join procedure, there are two conﬁguration parameters,
named Active Random Walk Length (ARWL), that speci-
ﬁes the maximum number of hops a FORWARDJOIN request
is propagated, and Passive Random Walk Length (PRWL),
that speciﬁes at which point in the walk the node is inserted
in a passive view. To use these parameters, the FORWARD-
JOIN request carries a “time to live” ﬁeld that is initially set
to ARWL and decreased at every hop.
When a node p receives a FORWARDJOIN, it performs
the following steps in sequence: i) If the time to live is equal
to zero or if the number of nodes in p’s active view is equal
to one, it will add the new node to its active view. This step
is performed even if a random node must be dropped from
the active view.
In the later case, the node being ejected
from the active view receives a DISCONNECT notiﬁcation.
ii) If the time to live is equal to PRWL, p will insert the
new node into its passive view. iii) The time to live ﬁeld is
iv) If, at this point, n has not been inserted
decremented.
in p’s active view, p will forward the request to a random
node in its active view (different from the one from which
the request was received).
4.3. Active View Management
The active view is managed using a reactive strategy.
When a node p suspects that one of the nodes present in
its active view has failed (by either disconnecting or block-
ing), it selects a random node q from its passive view and
attempts to establish a TCP connection with q. If the con-
nection fails to establish, node q is considered failed and
removed from p’s passive view; another node q0 is selected
at random and a new attempt is made. The procedure is
repeated until a connection is established with success.
When the connection is established with success, p sends
to q a NEIGHBOR request with its own identiﬁer and a pri-
ority level. The priority level of the request may take two
values, depending on the number of nodes present in the ac-
tive view of p: if p has no elements in its active view the
priority is high; the priority is low otherwise.
A node q that receives a high priority NEIGHBOR request
will always accept the request, even if it has to drop a ran-
dom member from its active view (again, the member that
is dropped will receive a DISCONNECT notiﬁcation). If a
node q receives a low priority NEIGHBOR request, it will
only accept the request if it has a free slot in its active view,
otherwise it will refuse the request.
If the node q accepts the NEIGHBOR request, p will re-
move q’s identiﬁer from its passive view and add it to the
active view. If q rejects the NEIGHBOR request, the initia-
tor will select another node from its passive view and repeat
the whole procedure (without removing q from its passive
view).
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:49:01 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007Algorithm 1: Membership Operations
upon init do
Send(JOIN, contactNode, myself);
upon Receive(JOIN, newNode) do
trigger addNodeActiveView(newNode)
foreach n ∈ activeView and n 6= newNode do
Send(FORWARDJOIN, n, newNode, ARWL, myself)
upon Receive(FORWARDJOIN, newNode, timeToLive, sender) do
if timeToLive== 0k#activeView== 1 then
trigger addNodeActiveView(newNode)
else
trigger addNodePassiveView(newNode)
if timeToLive==PRWL then
n ←− n ∈ activeView and n 6= sender
Send(FORWARDJOIN, n, newNode, timeToLive-1, myself)
upon dropRandomElementFromActiveView do
n ←− n ∈ activeView
Send(DISCONNECT, n, myself)
activeView ←− activeView \{n}
passiveView ←− passiveView ∪{n}
upon addNodeActiveView(node) do
if node 6= myself and node /∈ activeView then
if isfull(activeView) then
activeView ←− activeView ∪ node
trigger dropRandomElementFromActiveView
upon addNodePassiveView(node) do
if node 6= myself and node /∈ activeView and node /∈ passiveView then
if isfull(passiveView) then
n ←− n ∈ passiveView
passiveView ←− passiveView \{n}
passiveView ←− passiveView ∪ node
upon Receive(DISCONNECT, peer) do
if peer ∈ activeView then
activeView ←− activeView \ {peer}
addNodePassiveView(peer)
4.4. Passive View Management
The passive view is maintained using a cyclic strategy.
Periodically, each node performs a shufﬂe operation with
one of its peers at random. The purpose of the shufﬂe oper-
ation is to update the passive views of the nodes involved in
the exchange. The node p that initiates the exchange creates
an exchange list with the following contents: p’s own iden-
tiﬁer, ka nodes from its active view and kp nodes from its
passive view (where ka and kp are protocol parameters). It
then sends the list in a SHUFFLE request to a random neigh-
bor of its active view. SHUFFLE requests are propagated
using a random walk and have an associated “time to live”,
just like the FORWARDJOIN requests.
A node q that receives a SHUFFLE request will ﬁrst de-
crease its time to live. If the time to live of the message is
greater than zero and the number of nodes in q’s active view
is greater than 1, the node will select a random node from its
active view, different from the one he received this shufﬂe
message from, and simply forwards the SHUFFLE request.
Otherwise, node q accepts the SHUFFLE request and sends
back, using a temporary TCP connection, a SHUFFLERE-
PLY message that includes a number of nodes selected at
random from q’s passive view equal to the number of nodes
received in the SHUFFLE request.
Then, both nodes integrate the elements they received
in the SHUFFLE/SHUFFLEREPLY message into their passive
views (naturally, they exclude their own identiﬁer and nodes
that are part of the active or passive views). Because the
passive view has a ﬁxed length, it might get full; in that
case, some identiﬁers will have to be removed in order to
free space to include the new ones. A node will ﬁrst attempt
to remove identiﬁers sent to the peer. If no such identiﬁers
remain in the passive view, it will remove identiﬁers at ran-
dom.
4.5. View Update Procedures
Algorithm 1 also shows some basic manipulation prim-
itives used to change contents of the passive and active
views. The important aspect to retain from these primitives
is that nodes can move from the passive view to the active
view in order to ﬁll the active view (e.g. in reaction to node
failures). Nodes can be moved from the active view to the
passive view whenever a correct node has to be removed
from the active view. Note that since links are symmetric,
by removing a node p from the active view of node q, q
creates a “free slot” in p’s active view. By adding p to its
passive view, node q increases the probability of shufﬂing
q with other nodes and, subsequently, having p be target of
NEIGHBOR requests that might assist it to reﬁll its view.
5. Evaluation
We conducted simulations using the PeerSim Simula-
tor [11]. We have implemented both HyParView, Cyclon
and Scamp in this simulator in order to get comparative ﬁg-
ures. In order to validate our implementation of Cyclon and
Scamp, we have compared the results of our simulator with
published results for these systems (we omit these simula-
tions from the paper, as they do not contribute to the assess-
ment of merit of our approach).
We have also implemented a version of Cyclon, to which
we called CyclonAcked, that adds a failure detection sys-
tem to Cyclon based on the exchange of explicitly acknowl-
edgments during the message dissemination. Thus, Cy-
clonAcked is able to detect a failed node when it attempts to
gossip to it and, therefore, is able to remove failed members
from partial views, increasing the accuracy of these views.
We use this benchmark to show that the beneﬁts of our ap-
proach do not come only from the use of TCP as a failure
detector, but also from the clever use of two separate partial
views.
Finally, we have implemented on PeerSim a gossip
broadcast protocol that can use any of the protocols above as
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:49:01 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007a peer sampling service. In this protocol, a node forwards
a message when it receives it for the ﬁrst time (therefore,
there is no a priori bound on the number of gossip rounds).
In all simulations, the overlay was created by having
nodes join the network one by one, without running any
membership rounds in between. Cyclon was initiated by
having a single node to serve as contact point for all join
requests. Scamp was initiated by using a random node al-
ready in the overlay as the contact point. These are the con-
ﬁgurations that provide the best results with these protocols.
HyParView achieves similar results with either method (we
have used the same procedure as Cyclon).
5.1. Experimental Setting
All experiments were conducted in a network of 10.000
nodes and results show an aggregation from multiple runs of
each experiment. Furthermore, each membership protocol
was conﬁgured as follows: In HyParView, we set the active
membership size to 5, and passive membership’s size to 30.
Active Random Walk Length parameter was set to 6 and the
Passive Random Walk Length was set to 3. In each shufﬂe
message, kp = 4 elements (at most) were sent from the pas-
sive view, while ka = 3 elements (at most) were sent from
the active view. The total size of shufﬂe messages is 8, as
nodes also send their own identiﬁer in each shufﬂe message.
Cyclon protocol was conﬁgured with partial views of 35 el-
ements (this is the sum of HyParView’s active and passive
view sizes). Shufﬂe message lengths were set to 14 and the
time to live of random walks in the overlay was conﬁgured
to 5. Scamp was conﬁgured with parameter c - the parame-
ter that is related with fault-tolerance of the protocol - to 4.
The reason behind the selected value to this parameter was
because it generated partial views which size’s where dis-
tributed around a middle point of 34, which is as near as we