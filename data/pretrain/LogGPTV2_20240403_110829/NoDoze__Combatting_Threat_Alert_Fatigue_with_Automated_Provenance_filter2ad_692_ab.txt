3
SvchostIExplorer.exe springs.7zipSvchost.exeExplorer.exedropper.exe7zip.exe        Skype.exeIExplorere.exe           IExplorere.exe dropper.exey.y.y.y:445Spoolsv.exe encrypt.exeSvchost.exeencryptor.exe       Attack Other hostssmbdz.z.z.z:445sys-report.txtLow Anomaly Score Progeny of E2High Anomaly Score Progeny of E1 Powershellsys-report.txtWBEM/WMICREGNETSTATTASKLISTROUTEIPCONFIG              Other ﬁle nodesOther ﬁle nodesvimdiﬀcheck-ﬁlebashsys-report.txtcatlsgrepcut      Low  Anomaly Score Ancestry of E2High Anomaly Score Ancestry of E1  collect-info.ps1PowershellSvchost.exeUserinit12IExplorer.exe springs.7zipSvchost.exeExplorer.exedropper.exe7zip.exea.a.a.a dropper.exeSvchost.exeSpoolsv.exe encrypt.exeSvchost.exeencryptor.exeAll ﬁlenodesb.b.b.by.y.y.y:445All ﬁlenodesE1Fig. 3: Overview of NODOZE. Alerts generated by threat detector are provided to NODOZE, which ranks the alerts based on their aggregate
anomaly scores and produces concise alert dependency graphs for investigation.
Prior solutions to the dependency explosion problem [46],
[51], [50], [44] propose to partition the execution of a long
running process into autonomous “units” in order to provide
more precise causal dependency between input and output
events. However, these systems require end-user involvement
and system changes through source code instrumentation,
training runs of application with typical workloads, and mod-
ifying the kernel. Due to proprietary software and licensing
agreements, code instrumentation is not often possible in an
enterprise. Furthermore, these systems are only implemented
for Linux, and their designs are inapplicable to commodity-off-
the-shelf operating systems like Microsoft Windows. Finally,
acquiring typical application workloads in a heterogeneous
large enterprise is not practically feasible.
C. Goals
The aforementioned limitations motivate the following de-
sign goals for the NODOZE system:
• Alert Reduction. NODOZE should reduce false positives,
false negatives and non-actionable items as compared to
existing TDS.
• Concise Contextual Alerting. NODOZE-generated depen-
dency graphs of threat alerts should be concise and com-
plete.
• Generality. NODOZE design and techniques should be in-
dependent of underlying platforms (e.g. OS, VM, etc.),
applications, and TDS.
• Applicability. NODOZE should not require any end system
change and should be deployable on any existing TDS.
III. NODOZE OVERVIEW & APPROACH
The overall workﬂow of NODOZE system to triage alerts
based on anomaly scores is shown in Fig. 3. NODOZE acts as
an add-on to an existing TDS in order to reduce false alarms
and provide contextual explanations of generated threat alerts.
To triage alerts, NODOZE ﬁrst assigns an anomaly score to
each event in the generated alerts provenance graph. Anomaly
scores are calculated using frequencies with which related
events have happened before in the enterprise. NODOZE then
uses a novel network diffusion algorithm to propagate and
aggregate anomaly scores along the neighboring events. Fi-
nally, it generates an aggregate anomaly score for the generated
alert which is used for triaging – escalating the most critical
incidents for remediation and response.
As mentioned previously, existing execution partitioning
techniques [46], [51], [50], [44] for precise dependencies
are not feasible in an enterprise. In the case of true alerts,
NODOZE solves this problem by leveraging the observation
4
Fig. 2b shows
that the attack’s dependencies will be readily apparent because
the true path will have much higher anomaly score. We call
this approach as behavioural execution partitioning for alert
investigation. In our attack example, since IExplorer.exe has
only two socket connections from anomalous websites (one
of them is a malicious website from which malware was
downloaded) while all the other socket connections were to
websites common (normal) in the enterprise. Hence, we can get
rid of all the common IP connection vertices and partition the
execution of IExplorer.exe based on its abnormal behaviour.
the dependency graph generated by
NODOZE for our motivating example. It concisely captures
the minimal causal path between the root cause (initial socket
connection to IExplorer.exe)
(dropper.exe
socket connection to another host), and all other ramiﬁcations
(encryptor.exe encrypting several ﬁles). Observe that in Fig. 2a
there are two threat alert events annotated by E1 and E2 shown
with dashed arrows. Looking at these alert events in isolation,
they look similar (both make socket connection to important
internal hosts). However, when we consider the ancestry and
progeny of each these alert events using backward and forward
tracing, we can see that the behaviour of each of them is
markedly different.
the threat alert
In order to identify if a threat alert is a true attack or a
false alarm, NODOZE uses anomaly scores which quantify
the “rareness”, or transition probability, of relevant events that
have happened in the past. For example, the progeny of alert
event E1 i.e. dropper.exe → y.y.y.y:445 consists of several
events that are more rare i.e., have low transition probability.
For example, in the progeny of Spoolsv.exe (print service),
spawning another process that reads/writes several ﬁles hap-
pened 0 times in the organization earning this behaviour a
high anomaly score. Similarly, in the ancestry of E1, a chain
of events in which an executable is downloaded using Internet
Explorer and then connects to a large number of hosts in a
short period of times is very rare and thus has a high anomaly
score. As a result, when we combine the ancestry and progeny
behaviours of E1, we get a high aggregate anomaly score for
the alert.
In contrast, when we consider the progeny of alert event
E2 i.e. Powershell → z.z.z.z:445, we see a chain of events that
are quite common in an enterprise because these behaviours
are exhibited by common Linux utilities (e.g. diff and cut).
Moreover, the ancestry of alert event E2 contains diagnostic
events such as Tasklist and Ipconfig which are regularly
performed to check the health of computers in the enterprise.
Therefore, the aggregate anomaly score of E2 will be quite
lower than the anomaly score of E2.
Once NODOZE has assigned an aggregate anomaly score to
System Log DBOS-Level LogsThreat DetectorThreatAlertsDependency Graph Construction Event Freq. DBRanked SubgraphsNetwork Diffusion & Behavioral partitioningNoDozethe alert event, it extracts the subgraph from the dependency
graph that has the highest anomaly score. The dependency
graph for true alert E1 is shown in Fig. 2b. Observe that in
Fig. 2a, Spoolsv.exe has created many other socket connections
(total 130 sockets); however, the NODOZE generated graph
has only encrypt.exe process since this behaviour was more
anomalous than the other events. Similarly, while IExplorer.exe
received several socket connections, NODOZE only picked rare
IP addresses a.a.a.a (malicious website from which malware
was downloaded) and b.b.b.b since these have higher anomaly
scores than the other normal socket connections.
IV. THREAT MODEL & ASSUMPTIONS
Our threat model is similar to existing provenance-based
systems [56], [26], [54], [49], [63], [24], [51], [36] i.e., the
underlying OS; and provenance tracker are in our trusted
computing base (TCB). In this work, we consider an attacker
whose goal is to exﬁltrate sensitive data, manipulate informa-
tion present on a system, or to move laterally to other hosts
on the network. To achieve this goal the attacker may install
malware on the targeted system, exploit a running process, or
inject a backdoor.
We make the following assumptions about our system.
We assume that the attacker cannot manipulate or delete the
provenance record i.e., log integrity is maintained all the time.
While log integrity is an important goal, it is orthogonal to
the aims of this system and can be ensured by using existing
secure provenance systems [35], [25]. We also do not consider
the attacks performed using implicit ﬂows (side channels) that
do not go through the syscall interface and thus cannot be
captured by the underlying provenance tracker. Finally, we do
not track attacks exploiting kernel vulnerabilities.
The only underlying TDS’s feature that NODOZE relies on
is threat alerts. We assume that underlying TDS’s detection
rate is complete i.e. threats related to true attacks are always
detected. We also assume that there is at least one event that is
anomalous in the ancestry or progeny of alert to categorize it as
a true attack. We do not consider Mimicry attacks [62] where
attacker evades detection using a sequence of events which
are normal in an enterprise. While mimicry is an important
consideration, it is out of scope for this work because their
detection is actually a limitation of the underlying TDS.
V. PROBLEM DEFINITION
In this section, we ﬁrst introduce several formal deﬁnitions
which are required to understand NODOZE’s anomaly propa-
gation algorithm and then we formulate the problem statement
for NODOZE.
A. Deﬁnitions
Dependency Event. OS-level system logs refer to two
kinds of entities: subjects and objects. Subjects are pro-
cesses, while objects correspond to ﬁles, socket connections,
IPC etc. A dependency (causal) event E is deﬁned as a 3-
tuple  where SRC ∈ {process}
initiates the information ﬂow whereas DST ∈
entity that
{process, f ile, socket} entities which receive information
ﬂow, while REL represents information ﬂow relationship. The
TABLE I: Dependency Event Relationships
SRC
Process
DST
Process
File
Socket
REL
Pro Start; Pro End
File Write; File Read; File Execute
IP Write; IP Read
Fig. 4: Example dependency paths of length 5 for alert event E2 from
the motivating example (§II).
various kinds of dependency event relationships we consider
in this work are shown in Table I. For example, in Fig. 2a a de-
pendency event E1 is represented as .
Dependency Path. A dependency path P of a dependency
event Ea represents a chain of events that
led to Ea and
chain of events induced by Ea. It is an ordered sequence
of dependency events and represented as P := {E1, Ei, ...
, Ea, ... En } of length n. Each dependency event can have
multiple dependency paths where each path represents one
possible ﬂow of information through Ea. Dependency path may
contain overlapping events, making it possible to represent any
dependency graph as a set of dependency paths.
We further divide dependency paths into two categories:
– A control dependency path (CD) of an event ε is a de-
pendency path PCD = {ε1, ε2, ..., εn} such that ∀ REL ∈
{P ro Start, P ro End}.
– A data dependency path (DD) of an an event ε is a de-
pendency path PDD = {ε1, ε2, ..., εn} such that ∀ REL /∈
{P ro Start, P ro End}.
From the motivating attack example, two possible depen-
dency paths {P1, P2} of length 5, one control dependency path
PCD1 and one data dependency path PDD1 for the alert event
E2 are shown in Fig. 4.
Dependency Graph. All the dependency paths of an event
when merged together constitute one single dependency graph.
For example, the dependency graph of alert events E1 and E2
is shown in Fig. 2a.
True Alert Dependency Graph. As we discussed in §II, due
to long running programs there are false dependency events in
the dependency graph. Due to false dependencies, there will be
unrelated benign events in the dependency graph of a true alert
event which might not be causally related to the attack. So we
partition the long running programs based on their normal and
anomalous behaviour. We call this technique as behavioural
execution partitioning. This technique will generate a true
alert dependency graph, which will contain most anomalous
dependency paths. True alert dependency graphs are concise
as compared to complete dependency graphs and accelerate
5
P1P1 F1S1P2F2P1: PowershellP2: smbd P3: check-ﬁleP1P3P1P1 F1S1P2P2P1P1P2P1P1 F2PCD1PDD1F1: collect-info.ps1F2: out.txt S1: z.z.z.z:445the investigation process without losing vital contextual infor-
mation about the attack.
B. Problem Statement
Given a list of n alert events {E1, E2, ..., En} and user-
speciﬁed threshold parameters τl and τd, we aim to rank these
alerts based on their anomaly scores and ﬁlter out all the
alerts whose anomaly score is less than τd as false alarms.
Furthermore, we also aim to generate true alert dependency
graphs with dependency paths of atmost τl length.
There are two key challenges in this problem: 1) assigning
anomaly scores to dependency paths of different lengths using
historical and contextual information and 2) generating true
alert dependency graphs that completely capture attack behav-
iors. In the next section, we will present a concrete algorithm to
assign scores to threat alerts and generate true alert dependency
graphs.
VI. ALGORITHM
In this section, we present a concrete network diffusion
algorithm to assign anomaly score to each event in an alert
dependency path using historical information, then generate a
true alert dependency graph.
A. Roadmap
An anomaly score quantiﬁes the degree of suspiciousness
of an event in a dependency path. A na¨ıve way to assign
anomaly score is to use frequency of the system events that
have happened in the past such that events that are rare in
the organization are considered more anomalous. However,
sometimes this assumption may not hold since attacks may
involve events that happen a lot. From the motivating attack
(§II), unzipping a ﬁle (springs.7zip) is a common event in an
organization; however, it was one of the events that led to the
attack. Thus, simple frequency-based approach to ﬁnd anomaly
cannot catch such attacks. However, if we consider the chain
of events that were informed by springs.7zip ﬁle, such as
initiating a large number of IP connections in a short period of
time, we can ﬁnd out that this is not common behaviour after
someone unzips the springs.7zip ﬁle. Therefore, our objective
is to deﬁne the anomaly score not just based on a single
event in the dependency path but based on the whole path.
Next, we discuss how to calculate the anomaly scores for each
dependency path based on the whole path.
B. Anomaly Score Propagation
In order to calculate a dependency path’s anomaly score,
we ﬁrst need to ﬁnd dependency paths of an alert event. Given
a complete dependency graph G of an alert event Eα, we ﬁnd
all the dependency paths of length τl for the Eα. To do so,
we run depth-ﬁrst traversal in a backward and forward fashion
from the alert event and then we combine those backward and
forward paths to generate uniﬁed paths such that each uniﬁed
path contains both the ancestry and progeny causal events of
alert. In Algorithm 1, Lines 2 to Lines 6 show the dependency
path search algorithm. Function GETDEPENDENCYGRAPH
generates a complete dependency graph of an input event,
functions GETSRCVERTEX and GETDSTVERTEX return SRC
and DST entities of input event respectively, functions DFS-
TRAVERSALBACKWARD and DFSTRAVERSALFORWARD re-
turn backward and forward dependency paths for input event
respectively, and function COMBINEPATHS combine backward
and forward paths.
After generation of dependency paths for candidate alert
event, NODOZE assigns anomaly scores to each event
in
the dependency paths. In Algorithm 1, Lines 7 to Lines 10
show this process. To calculate the anomaly scores, we ﬁrst
construct a N × N transition probability matrix M for the
given dependency graph G of alert event, where N is the total
number of vertices in G. Each matrix entry Mε is computed
by the following equation:
Mε = probability(ε) =
|F req(ε)|
|F reqsrc rel(ε)|
(1)
Here, F req(ε) represents how many times the causal
event ε has happened in the historic time window with all
3-tuple of ε exactly same, while F reqsrc rel(ε) represents
how many times event ε where only SRC and REL from
3-tuple are exactly same. Hence, Mε means the happening
probability of this speciﬁc event. If ε event never happened
before in historical information, then its value is 0. On the
other hand, if ε is the only event between SRC and any other
entity with REL in our historical information then its value
1. Note that this anomaly score assignment algorithm is an
unsupervised algorithm with no training phase. To count the
frequency of events that have happened in the past we built an