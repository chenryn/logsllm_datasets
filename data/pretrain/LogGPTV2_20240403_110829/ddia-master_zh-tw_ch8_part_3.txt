我们几十年来一直在建设计算机网路 —— 有人可能希望现在我们已经找出了使网路变得可靠的方法。但是现在似乎还没有成功。
有一些系统的研究和大量的轶事证据表明，即使在像一家公司运营的资料中心那样的受控环境中，网路问题也可能出乎意料地普遍。在一家中型资料中心进行的一项研究发现，每个月大约有 12 个网路故障，其中一半断开一台机器，一半断开整个机架【15】。另一项研究测量了架顶式交换机，汇聚交换机和负载平衡器等元件的故障率【16】。它发现新增冗余网路装置不会像你所希望的那样减少故障，因为它不能防范人为错误（例如，错误配置的交换机），这是造成中断的主要原因。
诸如 EC2 之类的公有云服务因频繁的暂态网路故障而臭名昭著【14】，管理良好的私有资料中心网路可能是更稳定的环境。尽管如此，没有人不受网路问题的困扰：例如，交换机软体升级过程中的一个问题可能会引发网路拓扑重构，在此期间网路资料包可能会延迟超过一分钟【17】。鲨鱼可能咬住海底电缆并损坏它们 【18】。其他令人惊讶的故障包括网路介面有时会丢弃所有入站资料包，但是成功传送出站资料包 【19】：仅仅因为网路连结在一个方向上工作，并不能保证它也在相反的方向工作。
> #### 网路分割槽
>
> 当网路的一部分由于网路故障而被切断时，有时称为 **网路分割槽（network partition）** 或 **网路断裂（netsplit）**。在本书中，我们通常会坚持使用更一般的术语 **网路故障（network fault）**，以避免与 [第六章](ch6.md) 讨论的储存系统的分割槽（分片）相混淆。
即使网路故障在你的环境中非常罕见，故障可能发生的事实，意味著你的软体需要能够处理它们。无论何时透过网路进行通讯，都可能会失败，这是无法避免的。
如果网路故障的错误处理没有定义与测试，武断地讲，各种错误可能都会发生：例如，即使网路恢复【20】，丛集可能会发生 **死锁**，永久无法为请求提供服务，甚至可能会删除所有的资料【21】。如果软体被置于意料之外的情况下，它可能会做出出乎意料的事情。
处理网路故障并不意味著容忍它们：如果你的网路通常是相当可靠的，一个有效的方法可能是当你的网路遇到问题时，简单地向用户显示一条错误资讯。但是，你确实需要知道你的软体如何应对网路问题，并确保系统能够从中恢复。有意识地触发网路问题并测试系统响应（这是 Chaos Monkey 背后的想法；请参阅 “[可靠性](ch1.md#可靠性)”）。
### 检测故障
许多系统需要自动检测故障节点。例如：
* 负载平衡器需要停止向已死亡的节点转发请求（从轮询列表移出，即 out of rotation）。
* 在单主复制功能的分散式资料库中，如果主库失效，则需要将从库之一升级为新主库（请参阅 “[处理节点宕机](ch5.md#处理节点宕机)”）。
不幸的是，网路的不确定性使得很难判断一个节点是否工作。在某些特定的情况下，你可能会收到一些反馈资讯，明确告诉你某些事情没有成功：
* 如果你可以连线到执行节点的机器，但没有程序正在侦听目标埠（例如，因为程序崩溃），作业系统将透过传送 FIN 或 RST 来关闭并重用 TCP 连线。但是，如果节点在处理请求时发生崩溃，则无法知道远端节点实际处理了多少资料【22】。
* 如果节点程序崩溃（或被管理员杀死），但节点的作业系统仍在执行，则指令码可以通知其他节点有关该崩溃的资讯，以便另一个节点可以快速接管，而无需等待超时到期。例如，HBase 就是这么做的【23】。
* 如果你有权访问资料中心网路交换机的管理介面，则可以透过它们检测硬体级别的链路故障（例如，远端机器是否关闭电源）。如果你透过网际网路连线，或者如果你处于共享资料中心而无法访问交换机，或者由于网路问题而无法访问管理介面，则排除此选项。
* 如果路由器确认你尝试连线的 IP 地址不可用，则可能会使用 ICMP 目标不可达资料包回复你。但是，路由器不具备神奇的故障检测能力 —— 它受到与网路其他参与者相同的限制。
关于远端节点关闭的快速反馈很有用，但是你不能指望它。即使 TCP 确认已经传送了一个数据包，应用程式在处理之前可能已经崩溃。如果你想确保一个请求是成功的，你需要应用程式本身的正确响应【24】。
相反，如果出了什么问题，你可能会在堆叠的某个层次上得到一个错误响应，但总的来说，你必须假设你可能根本就得不到任何回应。你可以重试几次（TCP 重试是透明的，但是你也可以在应用程式级别重试），等待超时过期，并且如果在超时时间内没有收到响应，则最终宣告节点已经死亡。
### 超时与无穷的延迟
如果超时是检测故障的唯一可靠方法，那么超时应该等待多久？不幸的是没有简单的答案。
长时间的超时意味著长时间等待，直到一个节点被宣告死亡（在这段时间内，使用者可能不得不等待，或者看到错误资讯）。短的超时可以更快地检测到故障，但有更高地风险误将一个节点宣布为失效，而该节点实际上只是暂时地变慢了（例如由于节点或网路上的负载峰值）。
过早地宣告一个节点已经死了是有问题的：如果这个节点实际上是活著的，并且正在执行一些动作（例如，传送一封电子邮件），而另一个节点接管，那么这个动作可能会最终执行两次。我们将在 “[知识、真相与谎言](#知识、真相与谎言)” 以及 [第九章](ch9.md) 和 [第十一章](ch11.md) 中更详细地讨论这个问题。
当一个节点被宣告死亡时，它的职责需要转移到其他节点，这会给其他节点和网路带来额外的负担。如果系统已经处于高负荷状态，则过早宣告节点死亡会使问题更严重。特别是如果节点实际上没有死亡，只是由于过载导致其响应缓慢；这时将其负载转移到其他节点可能会导致 **级联失效**（即 cascading failure，表示在极端情况下，所有节点都宣告对方死亡，所有节点都将停止工作）。
设想一个虚构的系统，其网路可以保证资料包的最大延迟 —— 每个资料包要么在一段时间内传送，要么丢失，但是传递永远不会比 $d$ 更长。此外，假设你可以保证一个非故障节点总是在一段时间 $r$ 内处理一个请求。在这种情况下，你可以保证每个成功的请求在 $2d + r$ 时间内都能收到响应，如果你在此时间内没有收到响应，则知道网路或远端节点不工作。如果这是成立的，$2d + r$ 会是一个合理的超时设定。
不幸的是，我们所使用的大多数系统都没有这些保证：非同步网路具有无限的延迟（即尽可能快地传送资料包，但资料包到达可能需要的时间没有上限），并且大多数伺服器实现并不能保证它们可以在一定的最大时间内处理请求（请参阅 “[响应时间保证](#响应时间保证)”）。对于故障检测，即使系统大部分时间快速执行也是不够的：如果你的超时时间很短，往返时间只需要一个瞬时尖峰就可以使系统失衡。
#### 网路拥塞和排队
在驾驶汽车时，由于交通拥堵，道路交通网路的通行时间往往不尽相同。同样，计算机网路上资料包延迟的可变性通常是由于排队【25】：
* 如果多个不同的节点同时尝试将资料包传送到同一目的地，则网路交换机必须将它们排队并将它们逐个送入目标网路链路（如 [图 8-2](../img/fig8-2.png) 所示）。在繁忙的网路链路上，资料包可能需要等待一段时间才能获得一个插槽（这称为网路拥塞）。如果传入的资料太多，交换机伫列填满，资料包将被丢弃，因此需要重新发送资料包 - 即使网路执行良好。
* 当资料包到达目标机器时，如果所有 CPU 核心当前都处于繁忙状态，则来自网路的传入请求将被作业系统排队，直到应用程式准备好处理它为止。根据机器上的负载，这可能需要一段任意的时间。
* 在虚拟化环境中，正在执行的作业系统经常暂停几十毫秒，因为另一个虚拟机器正在使用 CPU 核心。在这段时间内，虚拟机器不能从网路中消耗任何资料，所以传入的资料被虚拟机器监视器 【26】排队（缓冲），进一步增加了网路延迟的可变性。
* TCP 执行 **流量控制**（flow control，也称为 **拥塞避免**，即 congestion avoidance，或 **背压**，即 backpressure），其中节点会限制自己的传送速率以避免网路链路或接收节点过载【27】。这意味著甚至在资料进入网路之前，在传送者处就需要进行额外的排队。
![](../img/fig8-2.png)