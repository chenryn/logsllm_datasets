```
每循环一次，就会把当前的数组元素赋值给变量 |n|
## 散列
散列（hash）也是一个程序里常用到的容器。散列是键值对（key-value pair）的一种数据结构。在 Ruby 中，一般是以字符串或者符号（Symbol）作为键，来保存对应的对象.
**什么是符号**
在 Ruby 中，符号（symbol）与字符串对象很相似，符号也是对象，一般作为名称标签来使用，用来表示方法等的对象的名称。
创建符号，只需在标识符的开头加上 `:` 就可以了。
```ruby
sym = :foo      # 表示符号“:foo”
sym2 = :"foo"   # 意思同上
```
符号能实现的功能，大部分字符串也能实现。但像散列键这样只是单纯判断“是否相等”的处理中，使用符号会比字符串比较更加有效率，因此在实际编程中我们也会时常用到符号。
另外，符号与字符串可以互相任意转换。对符号使用 `to_s` 方法，则可以得到对应的字符串。反之，对字符串使用 `to_sym` 方法，则可以得到对应的符号。
```ruby
> irb --simple-prompt
>> sym = :foo
=> :foo
>> sym.to_s         # 将符号转换为字符串
=> "foo"
>> "foo".to_sym     # 将字符串转换为符号
=> :foo
```
**散列的创建**
创建散列的方法与创建数组的差不多，不同的是，不使用 `[]`，而是使用 `{}` 把创建的内容括起来。散列用 `=>` 来定义获取对象时所需的键（key），以及键相对应的对象（value）。
```ruby
address = {:name => "高桥", :pinyin => "gaoqiao", :postal => "1234567"}
```
将符号当作键来使用时，程序还可以像下面这么写：
```ruby
address = {name: "高桥", pinyin: "gaoqiao", postal: "1234567"}
```
**散列的使用**
从散列取出对象、将对象保存到散列的使用方法也都和数组非常相似。我们使用以下方法从散列里取出对象。
```ruby
散列名 [ 键 ]
```
保存对象时使用以下方法。
```ruby
散列名[ 键 ] = 希望保存的对象
```
```ruby
> irb --simple-prompt
>> address = {name: "高桥", pinyin: "gaoqiao"}
=> {:name=>"高桥", :pinyin=>"gaoqiao"}
>> address[:name]
=> "高桥"
>> address[:pinyin]
=> "gaoqiao"
>> address[:tel] = "000-1234-5678"
=> "000-1234-5678"
>> address
=> {:name=>"高桥", :pinyin=>"gaoqiao", :tel=>"000-1234-5678"}
```
**散列的循环**
使用 each 方法，我们可以遍历散列里的所有元素，逐个取出其元素的键和对应的值。循环数组时是按索引顺序遍历元素，循环散列时按照键值组合遍历元素。
散列的 each 语法如下。
```ruby
散列 .each do | 键变量 , 值变量 |
 希望循环的处理
end
```
```ruby
> irb --simple-prompt
>> address = {name: "高桥", pinyin: "gaoqiao"}
=> {:name=>"高桥", :pinyin=>"gaoqiao"}
>> address.each do |key, value|
?>   puts "#{key}: #{value}"
>> end
name: 高桥
pinyin: gaoqiao
=> {:name=>"高桥", :pinyin=>"gaoqiao"}
```
显而易见，程序循环执行了输出散列 address 的键和值的 puts 方法
**正则表达式**
在 Ruby 中处理字符串时，我们常常会用到正则表达式（regular expression）。使用正则表达式，可以非常简单地实现以下功能：
- 将字符串与模式（pattern）相匹配
- 使用模式分割字符串
Ruby 的前辈——Perl、Python 等脚本语言至今还在使用正则表达式。Ruby 继承了这一点，把正则表达式的使用嵌入到语法中，大大简化了正则表达式的调用方式。正是在正则表达式的帮助下，字符串处理变成了一个 Ruby 非常擅长的领域。
我们有时会有按照特定模式进行字符串处理的需求，比如“找出包含○○字符串的行”或者“抽取○○和 ×× 之间的字符串”。判断字符串是否适用于某模式的过程称为匹配，如果字符串适用于该模式则称为匹配成功。
像这样的字符串模式就是所谓的正则表达式。
乍一看，“正则表达式”这个词可能会给人一种深奥、难理解的印象。的确，正则表达式非常复杂，但如果只是使用单纯的匹配功能，也并不怎么难。所以大家也无需感到如临大敌，我们暂时只需要知道有个工具叫“正则表达式”就足够了。
创建正则表达式对象的语法如下所示。
```ruby
/ 模式 /
```
例如，我们希望匹配 Ruby 字符串的正则表达式为：
```ruby
/Ruby/
```
把希望匹配的内容直接写出来，就这么简单。匹配字母、数字时，模式按字符串原样写就可以了。
汉字也可以通过同样的方法做匹配。
我们用运算符 `=~` 来匹配正则表达式和字符串。它与判断是否为同一个对象时用到的 `==` 有点像。
匹配正则表达式与字符串的方法是：
```ruby
/ 模式 / =~ 希望匹配的字符串
```
若匹配成功则返回匹配部分的位置。字符的位置和数组的索引一样，是从 0 开始计数的。也就是说，字符串的首个字符位置为 0。反之，若匹配失败，则返回 `nil。`
```ruby
> irb --simple-prompt
>> /Ruby/ =~ "Ruby"
=> 0
>> /Ruby/ =~ "Diamond"
=> nil
```
之前曾提到过，使用单纯的字母、数字、汉字模式时，如果字符串里存在该模式则匹配成功，否则匹配失败。
```ruby
> irb --simple-prompt
>> /Ruby/ =~ "Yet Another Ruby Hacker,"
=> 12
>> /Yet Another Ruby Hacker,/ =~ "Ruby"
=> nil
```
正则表达式右边的 `/` 后面加上 `i` 表示不区分大小写匹配。
```ruby
> irb --simple-prompt
>> /Ruby/ =~ "ruby"
=> nil
>> /Ruby/ =~ "RUBY"
=> nil
>> /Ruby/i =~ "ruby"
=> 0
>> /Ruby/i =~ "RUBY"
=> 0
>> /Ruby/i =~ "rUbY"
=> 0
```
# nil 是什么
nil 是一个特殊的值，表示对象不存在。像在正则表达式中表示无法匹配成功一样，方法不能返回有意义的值时就会返回 nil。另外，从数组或者散列里获取对象时，若指定不存在的索引或者键，则得到的返回值也是 nil。
```ruby
> irb --simple-prompt
>> hash = {"a"=>1, "b"=>2}
=> {"a"=>1, "b"=>2}
>> hash["c"]
=> nil
```
if 语句和 while 语句在判断条件时，如果碰到 false 和 nil，则会认为是“假”，除此以外的都认为是“真”。因此，除了可以使用返回 true 或者 false 的方法，也可以使用“返回某个值”或者返回“nil”的方法作为判断条件表达式。