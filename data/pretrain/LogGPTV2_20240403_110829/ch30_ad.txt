  许多人仍然在没有轮值补偿的岗位上工作，或者没有正式的补偿计划。公司没有这个计划确实会更省不少钱，但这是非常短视的。首先是对员工的生活不利，其次道德上也不正确。尽管短期可能会省钱，但是对业务来说是不利的。相反，我们应该有一个清晰明确的行业规范，或一系列规范，以便每个组织都可以选择最适合它的规范，并且组织中的工程师也可以自由选择。通过为轮值者提供支持，承认企业有义务保障轮值者的利益，这将增加愿意这样做的工程师，从而有利于保持团队多样性，也保障了团队成员的生活品质。
灵活的日程安排
   要保证日程安排很灵活，首先应该消除不灵活的来源。管理层可能首先需要确认这个观点，那就是通过更灵活的日程安排，不但整体绩效会更好，招聘也会更容易。每一天的工作时间可能会有所不同，具体取决于那天发生故障的可能性。正式的服务级别协议（SLA）不仅极大地帮助了基于服务级别目标（SLO）的警报，这通常会降低警报的数量。哪怕是首次尝试探讨服务级别协议，也会帮助管理层了解问题的本质：那就是，他们实际上并不需要尝试（也不可能）获得100％的可用性。这反过来又可以实现更灵活的日程安排。恢复
 我见过的大多数轮值员工的补偿计划都侧重于加班补贴或休假，但并不一定会在令人疲惫的值班后立即补偿。在轮值期间的工作超过一定强度时，公司可以从前一天晚上开始提供一个上午的休假，这应该是在换休制度以外的特别奖励才对。
避免遭到排挤
   确保人们对你所在的团队感到安全（无论他们对轮值的态度是什么或能力如何）主要是靠成功的一线管理，而不是公司政策的一部分。但公司可以提前发出信号，表示他们采取“选择退出而无需顾虑的轮值”政策，这将再次有助于吸引更多员工。 
提高在职绩效
 在职表现在很多方面是解决待命问题的最不重要的组成部分。首先，它实际上没有推进摆脱它的议程。此外，糟糕但可通过的轮值表现不太可能让你被解雇。如果真的解雇轮值员工的话，一个组织最终可能会不断解雇更多轮值员工，导致最终没人愿意承担这个职责，这样的恶性循环会导致最后无人愿意值守。相反，通常来的情况是，只有那些犯下严重错误的人才会遭到解雇，大多数管理层关心的是工程师认真解决问题付出的努力，而不是一味追求泰勒主义一贯推崇的低平均恢复时间（MTTR）Frederick Taylor 是一位科学管理理论家，他通过密切管理指标，介绍了在工作环境中使人们机械化的非常成功的想法。指标。因此，在轮值的人出现并做出努力之后，系统本身通常没有足够的激励来改善它，唯一的推动力是不想本周再写一次故障报告。
话虽如此，仍然有很多技术可以用来改进。
Cognitive hacks
  首先，有许多认知“小窍门”可以改善轮值情况下的表现；例如，皱眉可以帮助我们减少力量，这反过来又使我们不太可能专注于特定情况，而排除其他所有干扰；阅读 John Allspaw 关于不谈论责任的故障报告的材料也可以帮助我们在分布式系统中出现故障时，摆脱对实际存在问题的错误假设，并专注于自我反思，这是能帮助我们避免情绪化应对的关键途径。如前所述，反应是发现复杂事实的严重障碍，分布式系统中没有其他类型的真相。另一个潜在的小窍门的是组对轮值；这有非常有用的效果，当你需要向别人解释自己的思路时，不得不明确表达你的想法，通常可以帮助你弄清自己是否错了，只需要通过语言表达出来。这与主动/被动或首要/次要轮值的概念不同，因为这意味着人们在轮值期间以交互方式紧密合作。（这在工作时间最容易处理，却很难以小团队方式组织。）积极的假设，这是一种在想法出错之后抛出想法的技术，尽可能不同，也可能是有用的。当许多事情同时出现问题时尤其如此，因为压力增加会使思想变得狭窄。它还有助于问题定位，避免认知偏差问题。最后，良好的纪律，例如始终保持切换记录和遵循良好的故障管理流程，对于有效应对快速发生的事件是必要的；通过流程规定的大量深入调查，可以帮助你在不确定的情况下做出正确的反应。 
我们需要从根本上改变方法
 尽管所有这些实用建议都很有用，但总是给人一种感觉是在随大流。那么，一个更有趣的问题是，我们可以做些什么来从根本上改变这种情况？当然，这取决于您如何给问题定性。回想一下软件系统核心的根本冲突：我们知道它们是肯定存在的，所以无论如何它们都有迹象。然而，问题不断地以最糟糕的方式表现出来，让我们惊讶于问题的复杂性（和问题如何相互作用）是如何导致故障的。
但是这种不可靠性是如何产生的呢？“网站可靠性工作手册”中对 Google 故障的一项调查表明，二进制问题和配置问题共同构成了几乎 70％导致故障的因素，软件本身和开发过程中的失败导致近 62％的根本原因，“ 复杂的系统行为“只有大约 17％的情况会导致系统出错。记住这些数字，或者至少记住要分析故障的原因结构这个实践。
在这里，让我介绍一下在本章其余部分中提到的两个立场：严格抵制轮值（SAOC）和尽量避免轮值（WAOC）。
严格抵制轮值（SAOC）
 严格抵制轮值（SAOC）的理念是这样的。严格抵制轮值（SAOC）
 严格抵制轮值（SAOC）的理念是这样的。
软件系统是确定性的。我们有两种可能的方法来解决故障问题。我们可以排除故障的来源，或者我们可以防止故障造成灾难性后果。由于软件系统是确定性的，如果我们排除所有故障根源，系统就不会失败。（SAOC 不认为同时做这两件事情是有意义的。）
让我们花点时间回顾一下构建软件系统时不可靠的来源。我们可能犯一个简单的编程错误、拼写错误或类似其他错误。我们可能犯设计错误，构造一些肯定会出错的东西。我们可能错误地将自身与环境隔离（库、依赖项或是错误地分析数据）。我们可能错误地处理远程依赖项，例如假定它们始终可访问或始终返回正确的数据。
正如前面所讨论的那样，故障之所以令人抓狂，因为其中许多是完全可以避免的。SAOC 的立场在于防止#underlying_assumptions_driving_on_call_fo那些已识别的错误来源在系统中重现。虽然这里有太多要详细讨论的问题，但好消息是变更管理的许多困难已经得到了很好的理解，而我们正在努力做的是更成功地实现已经相对容易理解的东西。坏消息是，如果我们一直遇到某个问题，那么可能它是有原因的。