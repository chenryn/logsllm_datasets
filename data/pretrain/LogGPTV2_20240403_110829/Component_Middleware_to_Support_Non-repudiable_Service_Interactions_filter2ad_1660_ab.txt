will support the conclusion of dispute resolution in favour
of honest parties. The infrastructure requirements implied
by the above assumptions are discussed in the extended ver-
sion of this paper [4].
The following descriptions of non-repudiation services
apply to all three approaches to constructing a trust domain.
In the case of a single inline TTP, trusted interceptors acting
on behalf of each party are co-located and communication
between them is internal to the TTP. In practice, this may
mean that the interceptors are constructed from components
hosted by the same application server and interfaces to in-
teract through the interceptors are presented to participating
organisations.
3.2. Non-repudiable service invocation
Figure 4(a) shows a typical two-party, client-server in-
Client
request
response
Server
(a) Service invocation
Client
req
resp
req, NROreq
NRRreq
resp, NROresp
NRRresp
req
resp
Server
interceptor
interceptor
(b) Non-repudiable service invocation
Figure 4. Non-repudiable service invocation
teraction. The client invokes a service by sending a request
to the server who issues a response. We assume at-most-
once service invocation semantics (supported by most mid-
dleware): if the client receives the response then this means
that the invoked operation has been executed once; if no re-
sponse is received then the operation may or may not have
been executed. Non-repudiable service invocation provides
the following additional assurances to the client: (1) that
following an attempt to submit a request to a server, either:
(a) the submission failed and the server did not receive the
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:47:40 UTC from IEEE Xplore.  Restrictions apply. 
request; or (b) the submission succeeded and there is proof
that the request is available to the server; and: (2) that if a
response is received, there is proof that the server produced
the response. For the server, the corresponding assurances
are: (1) that if a request is received, there is proof iden-
tifying the client who submitted the request; and: (2) that
following an attempt to deliver a response to the client, ei-
ther: (a) the delivery failed and the client did not receive the
response; or (b) delivery succeeded and there is proof that
the response is available to the client.
To provide the above assurances, trusted interceptors ex-
ecute a non-repudiation protocol that ensures the following:
1. a request is passed to a server if, and only if, the client
(or its interceptor) provides non-repudiation evidence
of the origin of the request (NROreq) and the server
(or its interceptor) provides non-repudiation evidence
of receipt of the request (NRRreq)
2. the response is passed to the client if, and only if, the
server (or its interceptor) provides non-repudiation ev-
idence of the origin of the response (NROresp) and the
client (or its interceptor) provides non-repudiation ev-
idence of receipt of the response (NRRresp).
Non-repudiation tokens include a unique request identiﬁer,
to distinguish between protocol runs and to bind protocol
steps to a run, and a signature on a secure hash of the evi-
dence generated. Figure 4(b) models the exchange of ev-
idence achieved by the execution of an appropriate non-
repudiation protocol between interceptors acting on behalf
of client and server. The client initiates a request for some
service. The client’s interceptor generates an NROreq token
and then sends both the request and the token to the server’s
interceptor. The server’s interceptor generates an NRRreq
token and returns it to the client’s interceptor. The server’s
interceptor then passes the request to the server to generate
a response. On receipt of the response, the server’s intercep-
tor generates an NROresp token and sends both the response
and the token to the client’s interceptor. As noted in Sec-
tion 3.1, the interceptors are responsible for veriﬁcation and
persistence of evidence generated during the exchange. The
exact meaning of generation of non-repudiation evidence
will be dependent on the actual protocol used to execute the
exchange. Client and server may sign evidence, or their in-
terceptors may sign on their behalf, or, as with some fair
exchange protocols, a combination of client/server signing
in the normal case and TTP signing in case of recovery will
be used. Minimally, the interceptors ensure that irrefutable
evidence of the exchange is generated.
Assuming the server-side response (resp) includes evi-
dence as to whether the request was made available to the
server, the above model of the interaction between client in-
terceptor (CI) and server interceptor (SI) can be simpliﬁed
to:
CI → SI
SI → CI
CI → SI
req, N ROreq
resp, N RRreq, N ROresp
:
:
: N RRresp
If the request was made available to the server, then resp
is either the result of normal execution of the request at
the server or interceptor-generated evidence that the request
failed or that the server did not respond within some agreed
timeout or that the client initiated an abort of the request
before a result was available. If the request was not made
available to the server, then resp indicates that the request
was received but not executed. Similarly, the client-side re-
ceipt for the server-side response, NRRresp, may include
evidence as to the client’s consumption of the response. For
example, if the interceptor can prevent access to the result of
the server’s execution of the client’s request, then the NR-
Rresp can indicate that the response was received but not
consumed by the client. This equates to at-most-once se-
mantics where a server may do work on behalf of a client
that is not consumed. Given these semantics, the client may
fail or timeout and the server will receive evidence that a
response was generated that the client did not consume.
3.3. Non-repudiable information sharing
Figure 5(a) shows three organisations (A, B and C) ac-
Org. B
update
Org.
A
update
i
update
Org. C
Org.
A
1
interceptor
2
2
Org. B
interceptor
3
i
interceptor
Org. C
(a) Information sharing
(b) Non-repudiable information sharing
Figure 5. Non-repudiable information sharing
cessing and updating shared information. If, for example,
A wishes to update the information, then they must reach
agreement with B and C on the validity of the proposed up-
date. For the agreement to be non-repudiable: (i) B and C
require evidence that the update originated at A; and (ii) A,
B and C require evidence that, after reaching a decision on
the update, all parties have a consistent view of the agreed
state of the shared information. The latter condition im-
plies that there must be evidence that all parties received
the update and that they all agreed to it being applied to the
information.
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:47:40 UTC from IEEE Xplore.  Restrictions apply. 
Figure 5(b) shows A proposing an update to the informa-
tion shared by A, B and C. Interceptors are used to mediate
each organisation’s access to the information. In step 1, A
attempts an update to the information. A’s interceptor inter-
cepts the update and, in step 2, executes a non-repudiable
state coordination protocol with B and C to achieve the fol-
lowing:
1. That A’s update is irrefutably attributable to A and pro-
posed to B and C.
2. That B and C independently validate A’s proposed
update, using a locally determined and application-
speciﬁc process, and their respective decisions are
made available to A and are irrefutably attributable to
B and C.
4. Component-based implementation
This section presents a component middleware imple-
mentation of the services described in Section 3. The imple-
mentation is based on a J2EE application server. J2EE ap-
plications are assembled from components (self-contained
software units). The components include Enterprise Jav-
aBeans (EJBs) that are deployed on an application server.
EJBs run in an environment called an EJB container. To-
gether, the server and container provide a bean’s runtime
environment. The container intercepts remote invocations
on the bean and is responsible for invoking appropriate low-
level services, such as persistence and transaction manage-
ment, for each operation on the bean. The application pro-
grammer concentrates on the functional (business logic) as-
pects of a bean’s behaviour while the container provides ser-
vices to ensure correct, non-functional behaviour.
3. That the collective decision on the validity of the up-
date (in this case, responses from B and C to A) are
made available to all parties (A, B and C).
EJB
Client
If the resolution of the protocol executed at step 2 represents
agreement to the update then the shared information is up-
dated in step 3. Otherwise, the information remains in the
state prior to A’s proposed update. Non-repudiable connect
and disconnect protocols govern changes to the membership
of the group of organisations sharing the information.
Our previous work on B2BObjects [5] presents a real-
isation of the above abstraction of regulated information
sharing. The paper gives a detailed description of a non-
repudiable state coordination protocol used to reach agree-
ment on update to shared information that offers the live-
ness and safety guarantees discussed in Section 3.1. A
Java RMI-based implementation of B2BObjects is also de-
scribed. This implementation is the starting point for the
component middleware support for regulated information
sharing described in Section 4.3.
3.4. Evidence generation requirements
To meet non-repudiation requirements the evidence gen-
erated, and signed, during service invocation or update to
shared information must be in a form that cannot be sub-
sequently disputed. For non-repudiable service invocation,
the requirement is that a meaningful snapshot of the invo-
cation is generated (including details of the request, the ser-
vice invoked and the response). For non-repudiable infor-
mation sharing, the main requirement is that an agreed rep-
resentation of information state is used for evidence gen-
eration. Additional details of the components and form of
evidence are provided in the extended version of the paper
[4].
Container
Services
Persistence
Messaging
Transaction
Management
Non
Repudiation
EJB Component
Figure 6. J2EE-based non-repudiation
Figure 6 shows an EJB client invoking an operation on
an EJB component and the container interception of the in-
vocation to provide various services. As shown, the inten-
tion is to add a non-repudiation service to regulate access to
EJBs.
Our prototype extends the JBoss J2EE application server
[8].
JBoss makes systematic use of reﬂection and invo-
cation path interceptors to support extension to its exist-
ing services and the addition of new services. This pro-
vides a straightforward mechanism for the implementation
of the trusted interceptors introduced in Section 3. Although
this exploits JBoss-speciﬁc mechanisms, similar support is
found in other component-based systems.
In JBoss,
interceptors are used to invoke container-
level services to meet requirements speciﬁed in a compo-
nent’s deployment descriptor. An application-level invoca-
tion passes through a chain of interceptors, each intercep-
tor completing some task before passing the invocation to
the next interceptor in the chain. Existing services can be
modiﬁed or new services added to a container by inserting
additional interceptors in the chain. JBoss uses reﬂection to
provide the interceptor with access to the application-level
method called, the method parameters, the target bean and
its deployment descriptor. JBoss provides interceptors both
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:47:40 UTC from IEEE Xplore.  Restrictions apply. 
at the server and the client (using a dynamic proxy). Thus
the mechanism supports the execution of additional logic at
the client-side on behalf of a container-level service.
The prototype implementation uses JBoss interceptors to
access our non-repudiation middleware that uses a generic
B2BCoordinator service for the exchange of protocol mes-
sages. Custom protocol handlers are registered with the
coordinator to execute non-repudiation protocols. The co-
ordinator service also provides access to generic services
that support execution of protocols (such as credential man-
agement and state storage). The combination of generic
coordinator service and custom protocol handlers provides
a middleware that is adaptable to different application re-
quirements, for example to execute different protocols and
to support the different interaction styles described in Sec-
tion 3.1.
The implementations are based on the direct trusted in-
terceptor interaction shown in Figure 3(c). Furthermore,
no TTP is used to support protocol execution. Thus, the
implementation of service invocation guarantees safety and
liveness if client and server satisfy the trusted interceptor
assumptions. The implementation of information sharing
guarantees: (i) no invalid changes to shared information
whatever the behaviour of participants, and (ii) liveness if
all parties satisfy the trusted interceptor assumptions. The
ﬂexibility inherent in our approach means that we can trans-
form these implementations by introducing a TTP to sup-
port execution of fault-tolerant fair exchange protocols of
the kind described in [7]. This transformation would then
allow us to relax the strong assumptions about the parties to
the interaction.
4.1. B2BCoordinator service and protocol handlers
Each trusted interceptor provides a B2BCoordinator ser-
vice for the exchange of messages with other trusted inter-
ceptors.
In the J2EE implementation, this service is ex-
ported as a remote object that remote trusted interceptors
make invocations on to deliver messages. This service is the
external entry point for execution of non-repudiation proto-
cols. The interface is:
B2BCoordinatorRemote {
void deliver(B2BProtocolMessage msg);
B2BProtocolMessage
deliverRequest(B2BProtocolMessage msg);
}
Remote invocation of deliver results in delivery of the
given message from the remote party (as a parameter to
the call). deliver can be used for synchronous or asyn-
chronous protocol execution. deliverRequest is a conve-
nience method that allows a remote party to deliver a mes-
sage and then to wait synchronously for a response (the re-
sult of the call). A B2BProtocolMessage is an interface to
content that is common to non-repudiation protocol mes-
sages — request (protocol run) identiﬁer, sender, proto-
col step, signed content, payload etc. Concrete implemen-
tations of B2BProtocolMessage meet protocol-speciﬁc re-
quirements.
To execute speciﬁc protocols, and meet different applica-
tion or platform requirements, custom protocol handlers are
registered with the coordinator service. The coordinator is
responsible for mapping an incoming protocol message to
an appropriate handler. The coordinator also provides ac-
cess to local services that are not protocol or platform spe-
ciﬁc. All protocol handlers provide the following interface
to the local coordinator service to process incoming mes-
sages:
B2BProtocolHandler {
void process(B2BProtocolMessage msg);
B2BProtocolMessage
processRequest(B2BProtocolMessage msg);
}
Protocol handlers use the coordinator service provided by
remote parties to deliver outgoing protocol messages. As
discussed below, for non-repudiable service invocation, a
B2BInvocationHandler initiates protocol execution by an
appropriate protocol handler. For non-repudiable informa-
tion sharing, a B2BObjectController initiates protocol exe-
cution.
4.2. Implementation of non-repudiable service in-
vocation
Client Proxy
Client
Server
Trusted Interceptor
Trusted Interceptor
EJB
Client
B2BCoordinators
B2B Protocol
Handlers
B2B Invocation
Handlers
JBoss NR
Interceptor
Other JBoss
Interceptors
EJB Component
Container Services