A. Warﬁeld. Xen and the art of virtualization. In
SOSP’03, pages 164–177, New York, NY, USA, 2003.
ACM.
[7] C. Barsan and J. Cappos. ContainmentInSeattle –
Seattle – Trac. https://seattle.cs.washington.
edu/wiki/ContainmentInSeattle. Accessed April 3,
2010.
[8] A. Barth, A. P. Felt, P. Saxena, and A. Boodman.
Protecting browsers from extension vulnerabilities.
Technical Report UCB/EECS-2009-185, EECS
Department, University of California, Berkeley, Dec
2009.
[9] A. Berman, V. Bourassa, and E. Selberg. TRON:
Process-Speciﬁc File Protection for the UNIX
Operating System. In In Proceedings of the USENIX
1995 Technical Conference, pages 165–175, 1995.
[10] A. Bittau, P. Marchenko, M. Handley, and B. Karp.
Wedge: splitting applications into reduced-privilege
compartments. In NSDI’08, pages 309–322, Berkeley,
CA, USA, 2008. USENIX Association.
[11] BOINC. http://boinc.berkeley.edu/. Accessed
April 2, 2010.
[12] A security vulnerability in the Java Runtime
Environment (JRE) related to deserializing calendar
objects may allow privileges to be escalated.
http://sunsolve.sun.com/search/document.do?
assetkey=1-26-244991-1. Accessed April 8, 2010.
[13] B. Cannon and E. Wohlstadter. Controlling Access to
Resources Within The Python Interpreter.
http://www.cs.ubc.ca/~drifty/papers/python_
security.pdf. Accessed July 19, 2010.
[14] B. Cannon and E. Wohlstadter. Enforcing security for
desktop clients using authority aspects. In AOSD’09,
pages 255–266, New York, NY, USA, 2009. ACM.
[15] S. Chong, K. Vikram, A. Myers, et al. SIF: Enforcing
conﬁdentiality and integrity in web applications. In
Proc. 16th USENIX Security, 2007.
[16] G. Czajkowski. Application isolation in the Java
Virtual Machine. In OOPSLA’00, pages 354–366, New
York, NY, USA, 2000. ACM.
[17] G. Czajkowski and L. Dayn´es. Multitasking without
comprimise: a virtual machine evolution. In
OOPSLA’01, pages 125–138, New York, NY, USA,
2001. ACM.
[18] D. Dean, E. Felten, and D. Wallach. Java security:
From HotJava to Netscape and beyond. In 1996 IEEE
Symposium on Security and Privacy., pages 190–200,
1996.
[19] E. W. Dijkstra. The structure of the
“THE”-multiprogramming system. Commun. ACM,
11(5):341–346, 1968.
[20] P. Efstathopoulos, M. Krohn, S. VanDeBogart,
C. Frey, D. Ziegler, E. Kohler, D. Mazieres,
F. Kaashoek, and R. Morris. Labels and event
processes in the Asbestos operating system. In
SOSP’05, page 30. ACM, 2005.
221[21] U. Erlingsson. The inlined reference monitor approach
to security policy enforcement. PhD thesis, Cornell,
2004.
[22] FBJS - Facebook developers wiki. http:
//wiki.developers.facebook.com/index.php/FBJS.
Accessed April 2, 2010.
[23] Pwn2own 2010: interview with charlie miller.
http://www.oneitsecurity.it/01/03/2010/
interview-with-charlie-miller-pwn2own/.
Accessed July 26, 2010.
[39] M. S. Miller. Robust Composition: Towards a Uniﬁed
Approach to Access Control and Concurrency Control.
PhD thesis, Johns Hopkins University, Baltimore,
Maryland, USA, May 2006.
[40] A. Myers, L. Zheng, S. Zdancewic, S. Chong, and
N. Nystrom. Jif: Java information ﬂow. Software
release at http://www.cs.cornell.edu/jif. Accessed
April 3, 2010.
[41] S. Oaks. Java Security. O’Reilly and Associates, Inc.,
Sebastopol, CA, USA, 2001.
[24] T. Fraser, L. Badger, and M. Feldman. Hardening cots
[42] N. Paul and D. Evans. Comparing Java and .NET
software with generic software wrappers. Foundations
of Intrusion Tolerant Systems, 0:399–413, 2003.
[25] FutureRepyAPI – Seattle. https:
//seattle.cs.washington.edu/wiki/FutureRepyAPI.
Accessed April 15, 2010.
[26] T. Garﬁnkel. Traps and pitfalls: Practical problems in
system call interposition based security tools. In
NDSS’03. Citeseer, 2003.
security: Lessons learned and missed. Computers and
Security, pages 338–350. Volume 25, Issue 5, July
2006.
[43] PlanetLab. http://www.planet-lab.org. Accessed
April 2, 2010.
[44] N. Provos. Improving host security with system call
policies. In Proceedings of the 12th USENIX Security
Symposium, volume 1, page 10. Washington, DC, 2003.
[27] T. Garﬁnkel, B. Pfaﬀ, J. Chow, M. Rosenblum, and
[45] PTrace. http://en.wikipedia.org/wiki/Ptrace.
D. Boneh. Terra: a virtual machine-based platform for
trusted computing. In SOSP’03, pages 193–206, New
York, NY, USA, 2003. ACM.
[28] I. Goldberg, D. Wagner, R. Thomas, and E. A.
Brewer. A secure environment for untrusted helper
applications conﬁning the Wily Hacker. In SSYM’96:
Proceedings of the 6th conference on USENIX Security
Symposium, Focusing on Applications of Cryptography,
Berkeley, CA, USA, 1996. USENIX Association.
Accessed April 2, 2010.
[46] Fujitsu Java Runtime Environment reﬂection API
vulnerability. http://jvndb.jvn.jp/en/contents/
2005/JVNDB-2005-000705.html, Accessed April 8,
2010.
[47] Sun Java Runtime Environment reﬂection API
privilege elevation vulnerabilities.
http://www.kb.cert.org/vuls/id/974188, Accessed
April 8, 2010.
[29] C. Hawblitzel, C.-C. Chang, G. Czajkowski, D. Hu,
[48] Section 5 – the three parts of the default sandbox.
and T. von Eicken. Implementing multiple protection
domains in Java. In USENIX ATC’98, pages 22–22,
Berkeley, CA, USA, 1998. USENIX Association.
[30] Learn about Java technology.
http://www.java.com/en/about/, Accessed April 8,
2010.
[31] P. A. Karger, M. E. Zurko, D. W. Bonin, A. H.
Mason, and C. E. Kahn. A Retrospective on the VAX
VMM Security Kernel. IEEE Trans. Softw. Eng.,
17(11):1147–1165, 1991.
[32] S. Koivu. Calendar bug.
http://slightlyrandombrokenthoughts.blogspot.
com/2008/12/calendar-bug.html. Accessed April 8,
2010.
[33] B. Lampson. Computer security in the real world.
Computer, 37:37–46.
[34] H. M. Levy. Capability-Based Computer Systems.
Butterworth-Heinemann, Newton, MA, USA, 1984.
[35] S. Li and G. Tan. Finding bugs in exceptional
situations of JNI programs. In CCS’09, pages 442–452,
New York, NY, USA, 2009. ACM.
[36] P. Loscocco and S. Smalley. Integrating ﬂexible
support for security policies into the Linux operating
system. In USENIX ATC’01, pages 29–40, 2001.
http://www.securingjava.com/chapter-two/
chapter-two-5.html. Accessed April 8, 2010.
[49] Seattle: Open peer-to-peer computing.
http://seattle.cs.washington.edu/. Accessed April
3, 2010.
[50] V. Simonet and I. Rocquencourt. Flow Caml in a
nutshell. In Proceedings of the ﬁrst APPSEM-II
workshop, pages 152–165. Citeseer, 2003.
[51] L. Singaravelu, C. Pu, H. H¨artig, and C. Helmuth.
Reducing TCB complexity for security-sensitive
applications: three case studies. In EuroSys’06, pages
161–174, New York, NY, USA, 2006. ACM.
[52] E. G. Sirer, R. Grimm, A. J. Gregory, and B. N.
Bershad. Design and implementation of a distributed
virtual machine for networked computers. In SOSP’99,
pages 202–216, New York, NY, USA, 1999. ACM.
[53] M. Stiegler and M. Miller. How Emily tamed the
Caml. Technical Report HPL-2006-116, Advanced
Architecture Program. HP Laboratories Palo Alto,
2006.
[54] G. Tan and J. Croft. An empirical security study of
the native code in the JDK. In Proceedings of the
USENIX Security Symposium, pages 365–377,
Berkeley, CA, USA, 2008. USENIX Association.
[37] S. Maﬀeis, J. Mitchell, and A. Taly. An operational
[55] J. Viega, J. Bloch, and P. Chandra. Applying
semantics for JavaScript. Programming Languages and
Systems, pages 307–325.
aspect-oriented programming to security. Cutter IT
Journal, 14(2):31–39, 2001.
[38] A. Mettler, D. Wagner, and T. Close. Joe-E: A
security-oriented subset of Java. In Network and
Distributed Systems Symposium. Internet Society,
2010.
[56] R. Wahbe, S. Lucco, T. Anderson, and S. Graham.
Eﬃcient software-based fault isolation. In SOSP’94,
page 216. ACM, 1994.
[57] R. N. M. Watson. Exploiting concurrency
222vulnerabilities in system call wrappers. In WOOT’07,
pages 1–8, Berkeley, CA, USA, 2007. USENIX
Association.
[58] Making JavaScript safe for advertising.
http://www.adsafe.org/. Accessed April 2, 2010.
[59] N. Zeldovich, S. Boyd-Wickizer, E. Kohler, and
D. Mazi`eres. Making information ﬂow explicit in
HiStar. In OSDI’06, pages 263–278.
APPENDIX
A. THE REPY LANGUAGE
This section describes how we restricted the Python pro-
gramming language to a subset we call Repy, that is similar
to an object-capability system. Python is a memory-safe
language, in that, it does not allow a program to manipu-
late pointers or inspect memory directly. However, memory-
safety is not suﬃcient for the construction of an object-
capability system. While a similar eﬀort has been performed
for Java [38], Python has some interesting diﬀerences be-
cause the language allows much more introspection than
Java.
A.1 Python Scopes
In Python, there are three scopes: local, global, and built-
in. The local scope is associated with a function or a block of
code, the global scope is associated with a module, and the
built-in scope is always available. In Python each of these
scopes is represented by a dictionary. The built-in scope
contains the primitives, basic data structures, and common
exceptions. Normally, this dictionary also contains unsafe
functions such as import, and eval but we remove these dur-
ing sandbox initialization. Our technique for isolating sys-
tem code from user code is to deﬁne sensitive code in a sepa-
rate global context and to control all references between the
user and system code. The only permitted references from
the user’s global scope to the system’s global scope are API
calls, all of which are explicitly added to the scope before
any user code executes. Since the local scope is created and
destroyed at a function level, there is no need to handle it
separately as it does not have access to anything not already
available in the global scope.
A.2 Code Safety Evaluation
The goal of code safety evaluation is to test if the provided
program can execute on the underlying runtime system with-
out presenting a security risk. For this, a candidate program
is validated by checking whether it meets a behavioral spec-
iﬁcation, which restricts the source code to just the valid
operations. This analysis is performed on the interpreter’s
parse tree of a program and disallows unsafe instructions,
such as the import instruction.
A.3 Programming Language
The sandbox virtual machine executes code written in a
subset of the Python language. To minimize the risk of
bugs, the virtual machine implementation attempts to build
on parts of the underlying trusted computing base that are
stable, conceptually simple and widely used. For example,
we allow use of a vanilla type of the Python interpreter’s
style of classes and simple types; we do not allow classes that
subclass basic types, provide their own namespace storage
mechanisms, or utilize other complex mechanisms that are
rarely used or new to the language.
This language supports a subset of Python language prim-
itives and constructs – it is, in fact, executed by the Python
interpreter. The virtual machine loads code as text and then
uses the standard compiler module built into the interpreter
to build a parse tree of the code. The virtual machine ver-
iﬁes that the parse tree contains only the supported subset
of the language using a popular safety module, which was
initially developed by Phil Hassey and that we signiﬁcantly
adapted to our context.
If there is a disallowed language
construct, the code is rejected without executing. We found
this method to be eﬃcient and robust in detecting disallowed
or unrecognized functions and language constructs. Assum-
ing the parse tree for the code contains the valid subset of
Python, the code is executed once the built-ins and the API
are mapped into its namespace.
The virtual machine veriﬁes multiple aspects of the Python
interpreter before it begins executing loaded code. Allowed
built-in Python functions are checked to ensure their sig-
natures (i.e. argument list) are deﬁned as expected. This
prevents diﬀerences in interpreter implementations or in-
terpreter versions, which may result in changes to built-in
functions, from exposing unintended functionality to un-
trusted code.
A.4 Language Built-ins
Static analysis of a parse tree will not catch all security
threats. Many dynamic languages have built-in functions
and object attributes that allow a high degree of introspec-
tion (referred to as reﬂection in Java), enabling code to
inspect and manipulate elements of the execution environ-
ment. Introspection is useful in debugging, proﬁling, and (as
we have found) in restricting the functionality of executing
code. However, introspection also provides mechanisms for
circumventing the API and language restrictions. To combat
this, the virtual machine remaps the introspective built-ins
to make them trap out of the sandbox and cause termina-
tion. This remapping essentially augments the interpreter
to perform simple run-time analysis for further safety.
However, while language constructs constrain what loaded
code executes, there remain certain built-in functions that
provide functionality outside of what can be expressed
within our language constraints. These built-ins must also
be correctly restricted because execution of these unsafe
functions may cause the code to escape the sandbox re-
source or isolation restrictions.
The set of allowed built-ins consists of 87 items obtained
directly from Python’s interpreter. These include deﬁnitions
of constants and exceptions like True and ValueError (53),
type conversion functions like ﬂoat and chr (15), math func-
tions like max and pow (8), as well as miscellaneous Python
operations like len and range (11). Notice that operations
like import (which includes code from another module), eval,
and exec are not directly allowed because verifying their
safety is known to be diﬃcult. The virtual namespace prim-
itive (Section 4) provides unprivileged code with access to
equivalent functionality that is safely implemented.
223