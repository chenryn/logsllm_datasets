以下是优化后的文本，使其更加清晰、连贯和专业：

---

**参考文献**

1. A. Warfield. Xen and the Art of Virtualization. In *SOSP’03*, pages 164–177, New York, NY, USA, 2003. ACM.

2. C. Barsan 和 J. Cappos. ContainmentInSeattle – Seattle – Trac. https://seattle.cs.washington.edu/wiki/ContainmentInSeattle. 访问日期：2010年4月3日。

3. A. Barth, A. P. Felt, P. Saxena, 和 A. Boodman. 保护浏览器免受扩展程序漏洞的影响。技术报告 UCB/EECS-2009-185, EECS 部门, 加州大学伯克利分校, 2009年12月。

4. A. Berman, V. Bourassa, 和 E. Selberg. TRON: 针对 UNIX 操作系统的进程特定文件保护。在 *USENIX 1995 技术会议* 的论文集中, pages 165–175, 1995 年。

5. A. Bittau, P. Marchenko, M. Handley, 和 B. Karp. Wedge: 将应用程序拆分为权限降低的隔间。在 *NSDI’08*, pages 309–322, Berkeley, CA, USA, 2008. USENIX 协会。

6. BOINC. http://boinc.berkeley.edu/. 访问日期：2010年4月2日。

7. Java 运行时环境 (JRE) 中与反序列化日历对象相关的安全漏洞可能允许权限提升。http://sunsolve.sun.com/search/document.do?assetkey=1-26-244991-1. 访问日期：2010年4月8日。

8. B. Cannon 和 E. Wohlstadter. 控制 Python 解释器中的资源访问。http://www.cs.ubc.ca/~drifty/papers/python_security.pdf. 访问日期：2010年7月19日。

9. B. Cannon 和 E. Wohlstadter. 使用权限方面强制桌面客户端的安全性。在 *AOSD’09*, pages 255–266, New York, NY, USA, 2009. ACM。

10. S. Chong, K. Vikram, A. Myers 等. SIF: 在 Web 应用中强制执行机密性和完整性。在 *第16届 USENIX 安全研讨会* 的论文集中, 2007 年。

11. G. Czajkowski. Java 虚拟机中的应用程序隔离。在 *OOPSLA’00*, pages 354–366, New York, NY, USA, 2000. ACM。

12. G. Czajkowski 和 L. Daynés. 多任务处理而不妥协：虚拟机的演变。在 *OOPSLA’01*, pages 125–138, New York, NY, USA, 2001. ACM。

13. D. Dean, E. Felten, 和 D. Wallach. Java 安全：从 HotJava 到 Netscape 及以后。在 *1996 IEEE 安全与隐私研讨会* 的论文集中, pages 190–200, 1996 年。

14. E. W. Dijkstra. “THE” 多道程序系统结构。*ACM 通讯*, 11(5):341–346, 1968 年。

15. P. Efstathopoulos, M. Krohn, S. VanDeBogart, C. Frey, D. Ziegler, E. Kohler, D. Mazieres, F. Kaashoek, 和 R. Morris. Asbestos 操作系统中的标签和事件过程。在 *SOSP’05*, page 30. ACM, 2005 年。

16. U. Erlingsson. 内联引用监视器方法实现安全策略执行。博士学位论文, 康奈尔大学, 2004 年。

17. FBJS - Facebook 开发者维基。http://wiki.developers.facebook.com/index.php/FBJS. 访问日期：2010年4月2日。

18. Pwn2own 2010: 对 Charlie Miller 的采访。http://www.oneitsecurity.it/01/03/2010/interview-with-charlie-miller-pwn2own/. 访问日期：2010年7月26日。

19. M. S. Miller. 强健组合：迈向统一的访问控制和并发控制方法。博士学位论文, 约翰霍普金斯大学, 巴尔的摩, 马里兰州, 美国, 2006 年5月。

20. A. Myers, L. Zheng, S. Zdancewic, S. Chong, 和 N. Nystrom. Jif: Java 信息流。软件发布于 http://www.cs.cornell.edu/jif. 访问日期：2010年4月3日。

21. S. Oaks. Java 安全。O’Reilly and Associates, Inc., Sebastopol, CA, USA, 2001 年。

22. T. Fraser, L. Badger, 和 M. Feldman. 增强 COTS [商业现成产品] 的安全性。在 *NDSS’03*. Citeseer, 2003 年。

23. 从 Java 和 .NET 软件中吸取的经验教训和遗漏。计算机安全, pages 338–350. 第25卷, 第5期, 2006年7月。

24. PlanetLab. http://www.planet-lab.org. 访问日期：2010年4月2日。

25. N. Provos. 使用系统调用策略改进主机安全性。在 *第12届 USENIX 安全研讨会* 的论文集中, 第1卷, page 10. 华盛顿特区, 2003 年。

26. T. Garfinkel. 陷阱和坑洼：基于系统调用插入的安全工具的实际问题。在 *NDSS’03*. Citeseer, 2003 年。

27. T. Garfinkel, B. Pfaff, J. Chow, M. Rosenblum, 和 D. Boneh. Terra: 一个基于虚拟机的可信计算平台。在 *SOSP’03*, pages 193–206, New York, NY, USA, 2003. ACM。

28. I. Goldberg, D. Wagner, R. Thomas, 和 E. A. Brewer. 为不受信任的帮助应用程序提供安全环境：限制狡猾的黑客。在 *SSYM’96: 第六届 USENIX 安全研讨会* 的论文集中, 重点关注密码学应用, Berkeley, CA, USA, 1996 年。USENIX 协会。

29. Fujitsu Java 运行时环境反射 API 漏洞。http://jvndb.jvn.jp/en/contents/2005/JVNDB-2005-000705.html, 访问日期：2010年4月8日。

30. Sun Java 运行时环境反射 API 权限提升漏洞。http://www.kb.cert.org/vuls/id/974188, 访问日期：2010年4月8日。

31. C. Hawblitzel, C.-C. Chang, G. Czajkowski, D. Hu, 和 T. von Eicken. 在 Java 中实现多保护域。在 *USENIX ATC’98*, pages 22–22, Berkeley, CA, USA, 1998. USENIX 协会。

32. 了解 Java 技术。http://www.java.com/en/about/, 访问日期：2010年4月8日。

33. P. A. Karger, M. E. Zurko, D. W. Bonin, A. H. Mason, 和 C. E. Kahn. VAX VMM 安全内核回顾。*IEEE 软件工程学报*, 17(11):1147–1165, 1991 年。

34. S. Koivu. 日历漏洞。http://slightlyrandombrokenthoughts.blogspot.com/2008/12/calendar-bug.html. 访问日期：2010年4月8日。

35. B. Lampson. 现实世界中的计算机安全。*计算机*, 37:37–46。

36. H. M. Levy. 基于能力的计算机系统。Butterworth-Heinemann, Newton, MA, USA, 1984 年。

37. S. Li 和 G. Tan. 在 JNI 程序的异常情况下查找漏洞。在 *CCS’09*, pages 442–452, New York, NY, USA, 2009. ACM。

38. P. Loscocco 和 S. Smalley. 将灵活的安全策略支持集成到 Linux 操作系统中。在 *USENIX ATC’01*, pages 29–40, 2001 年。

39. Seattle: 开放的点对点计算。http://seattle.cs.washington.edu/. 访问日期：2010年4月3日。

40. V. Simonet 和 I. Rocquencourt. Flow Caml 简介。在 *第一届 APPSEM-II 研讨会* 的论文集中, pages 152–165. Citeseer, 2003 年。

41. L. Singaravelu, C. Pu, H. H¨artig, 和 C. Helmuth. 降低安全敏感应用程序的 TCB 复杂性：三个案例研究。在 *EuroSys’06*, pages 161–174, New York, NY, USA, 2006. ACM。

42. E. G. Sirer, R. Grimm, A. J. Gregory, 和 B. N. Bershad. 分布式虚拟机的设计与实现。在 *SOSP’99*, pages 202–216, New York, NY, USA, 1999. ACM。

43. M. Stiegler 和 M. Miller. 如何驯服 Caml。技术报告 HPL-2006-116, 高级架构计划。HP 实验室帕洛阿尔托, 2006 年。

44. G. Tan 和 J. Croft. JDK 中本地代码的经验安全研究。在 *USENIX 安全研讨会* 的论文集中, pages 365–377, Berkeley, CA, USA, 2008 年。USENIX 协会。

45. S. Maffeis, J. Mitchell, 和 A. Taly. JavaScript 的操作语义。编程语言和系统, pages 307–325。

46. A. Mettler, D. Wagner, 和 T. Close. Joe-E: 一种面向安全的 Java 子集。在网络和分布式系统研讨会。互联网协会, 2010 年。

47. R. Wahbe, S. Lucco, T. Anderson, 和 S. Graham. 高效的软件故障隔离。在 *SOSP’94*, page 216. ACM, 1994 年。

48. R. N. M. Watson. 利用系统调用包装器中的并发漏洞。在 *WOOT’07*, pages 1–8, Berkeley, CA, USA, 2007. USENIX 协会。

49. 使 JavaScript 适用于广告。http://www.adsafe.org/. 访问日期：2010年4月2日。

50. N. Zeldovich, S. Boyd-Wickizer, E. Kohler, 和 D. Mazières. 在 HiStar 中明确信息流。在 *OSDI’06*, pages 263–278。

**附录 A: Repy 语言**

本节描述了我们如何将 Python 编程语言限制为一个称为 Repy 的子集，该子集类似于对象能力系统。Python 是一种内存安全的语言，不允许程序直接操作指针或检查内存。然而，内存安全性不足以构建一个对象能力系统。虽然类似的努力已经在 Java 中进行过 [38]，但 Python 有一些有趣的差异，因为该语言允许比 Java 更多的自省功能。

**A.1 Python 作用域**

在 Python 中，有三种作用域：局部、全局和内置。局部作用域与函数或代码块相关联，全局作用域与模块相关联，而内置作用域始终可用。在 Python 中，这些作用域都由字典表示。内置作用域包含基本数据类型和常见异常。通常，这个字典还包含不安全的函数，如 `import` 和 `eval`，但我们会在沙箱初始化过程中移除它们。我们通过在单独的全局上下文中定义敏感代码并控制用户代码和系统代码之间的所有引用，来隔离系统代码和用户代码。从用户的全局作用域到系统全局作用域的唯一允许引用是 API 调用，这些调用在任何用户代码执行之前都被显式添加到作用域中。由于局部作用域是在函数级别创建和销毁的，因此无需单独处理它，因为它无法访问全局作用域中尚未提供的任何内容。

**A.2 代码安全性评估**

代码安全性评估的目标是测试所提供的程序是否可以在底层运行时系统上执行，而不会带来安全风险。为此，候选程序需要通过行为规范验证，该规范限制源代码只能包含有效的操作。这种分析是在解释器生成的程序解析树上进行的，并禁止不安全的指令，例如 `import` 指令。

**A.3 编程语言**

沙箱虚拟机执行用 Python 语言子集编写的代码。为了最小化错误风险，虚拟机实现试图建立在稳定、概念简单且广泛使用的底层可信计算基础上。例如，我们允许使用 Python 解释器风格的基本类和简单类型；我们不允许那些继承基本类型、提供自己的命名空间存储机制或利用其他复杂机制的类，这些机制很少使用或新引入语言。

这种语言支持 Python 语言原语和构造的一个子集——实际上是由 Python 解释器执行的。虚拟机将代码作为文本加载，然后使用解释器内置的标准编译器模块构建代码的解析树。虚拟机使用一个流行的 Safety 模块（最初由 Phil Hassey 开发，并经过我们的大幅修改）来验证解析树是否仅包含语言支持的子集。

如果存在不允许的语言构造，代码将在执行前被拒绝。我们发现这种方法在检测不允许或未识别的函数和语言构造方面既高效又可靠。假设代码的解析树包含有效的 Python 子集，那么在将内置函数和 API 映射到其命名空间后，代码将被执行。

虚拟机在开始执行加载的代码之前，会验证 Python 解释器的多个方面。允许的内置 Python 函数会被检查以确保其签名（即参数列表）符合预期。这可以防止不同解释器实现或解释器版本导致内置函数的变化，从而向不可信代码暴露意外的功能。

**A.4 语言内置函数**

静态分析解析树不能捕获所有的安全威胁。许多动态语言具有内置函数和对象属性，允许高度的自省（在 Java 中称为反射），从而使代码能够检查和操纵执行环境的元素。自省在调试、性能分析以及（正如我们所发现的）限制执行代码的功能方面非常有用。然而，自省也提供了绕过 API 和语言限制的机制。为了应对这一点，虚拟机重新映射自省内置函数，使其在沙箱外触发并导致终止。这种重新映射实际上增强了解释器，使其能够执行简单的运行时分析以进一步提高安全性。

然而，尽管语言构造约束了加载代码的执行，但仍有一些内置函数提供了超出我们语言约束所能表达的功能。这些内置函数也必须正确地加以限制，因为执行这些不安全的函数可能会使代码逃逸出沙箱资源或隔离限制。

允许的内置函数集合包括从 Python 解释器直接获取的 87 个项目。这些项目包括常量和异常的定义，如 `True` 和 `ValueError`（53 项）、类型转换函数如 `float` 和 `chr`（15 项）、数学函数如 `max` 和 `pow`（8 项），以及其他各种 Python 操作如 `len` 和 `range`（11 项）。请注意，像 `import`（包含另一个模块的代码）、`eval` 和 `exec` 这样的操作是不允许直接使用的，因为验证它们的安全性非常困难。虚拟命名空间原语（第4节）为无特权代码提供了安全实现的等效功能。

---