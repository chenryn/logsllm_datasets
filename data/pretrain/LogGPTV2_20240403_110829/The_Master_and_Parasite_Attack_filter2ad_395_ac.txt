### Effectiveness of Refresh Methods to Remove Objects Stored with Cache API (Not Supported by IE)

We conducted an evaluation of injection attacks on popular Internet caches and demonstrated that the scope of these attacks extends well beyond end-user browser caches. The vulnerable caches identified in our study are listed in Table IV. The primary vulnerability lies in the shared nature of the browser cache among multiple sites. As a defense, some modern browsers provide isolated caches for each 'calling context.' However, network caches (e.g., on ISP or local networks) do not support such isolation, making them a shared resource and thus susceptible to these attacks. In addition to side-channel attacks, network caches can also be used as a vector for infection. If a cache entry is compromised, it affects all clients connected to that cache. Since network-based HTTP(s) caches are designed to minimize resource usage by sharing resources, but lack security mechanisms, they are inherently vulnerable to such attacks. To mitigate this, isolating the cache per client could be implemented, although this would negatively impact performance. Fixing the software of network caches is non-trivial. Injection attacks against reverse proxies (e.g., on CDNs) also affect all users of the infected proxy.

In our evaluations, we observed that different types of caches have varying persistence strategies. We experimentally evaluated the persistence of Cache API3 in browsers using a lab validation server. Our results showed that simply cleaning the cache is insufficient to prevent attacks; cookies must also be deleted to remove the parasites from the cache, as detailed in Table III.

### Command & Control Channel

After the victim disconnects from the network where the initial infection occurred, the attacker uses a Command & Control (C&C) channel to communicate with the parasite instances on the victim's device. We designed and implemented a bi-directional C&C channel for communication between the parasites on the victim and the remote attacker. This channel enables sending commands to the bots and retrieving data from the victims, as illustrated in Figure 4.

To avoid relying on known protocols and features that can be blocked, such as CORS, we developed our own communication protocol. Our method leverages HTTP information leakage combined with cross-origin requests to create a channel with the parasite scripts in different domains. This channel is based on the dimensions of cross-origin image requests. While most image properties are hidden, the image dimensions are visible, which is necessary for adapting the page to the image proportions. For communication, we transfer multiple images, encoding the information in the width and height of the images. Our experiments show that once the dimension exceeds 65,535, browsers downgrade it to this value. Therefore, we can transfer two values between 0 and 65,535 in each image, resulting in 4 bytes of encoded data per image. We use SVG format to keep the total image size small, reducing the overhead for transferring these 4 bytes of data. An empty SVG image is approximately 100 bytes, and in our experiments, we achieved a communication channel of 100KB/s from the master’s server to the parasite.

For the reverse communication channel, from the parasite to the master’s server, we use HTTP requests where the URL or URL get/post parameters encode the data, thus avoiding bandwidth limitations.

### Evaluation of Caches in the Wild

Our evaluation of various caches, including those on the victim host, victim network, and remote caches, revealed their default caching behaviors. The results are summarized in Table IV. Different types of caches, such as browser caches, transparent proxies, web filters, and firewalls, have varying levels of support for HTTP and HTTPS. Some caches, like those on CDNs and mobile networks, are particularly vulnerable due to their design for resource sharing without built-in security mechanisms.

### Parasite Attacks Against Applications

The attacks we developed and evaluated are application-specific and can be categorized into three main targets: browsers, operating systems, and networks. The attacks, along with their types, targets, exploits, and requirements, are listed in Table V. We incorporated the following modules into the parasite:
1. A module to read browser data such as the current URL, user agent, cookies, and local storage.
2. A module for extracting protected browser data, such as microphone access.
3. A module for spreading the parasite through customized phishing.
4. A module to extract login data from applications like Google, Facebook, or online banking.

The vulnerabilities that enable these attacks stem from the execution of untrusted JavaScript (JS) with full access to the Document Object Model (DOM). JS has complete read and write access to the DOM, and submit events can be intercepted. By reading data from the DOM, the parasite can access email communication, account numbers, and financial status. Encryption of network traffic does not prevent the attack since the parasite reads the data directly from input fields and transfers it to the attacker via the C&C channel. If the user is logged in, a fake login screen can be presented. Manipulating the DOM allows the attacker to alter bank transfer details in online banking.

Preventing such attacks at the browser level is challenging because the parasite uses only standardized JS functions. The most effective defense is to limit communication between the attacker and the parasites by enforcing strong Content Security Policy (CSP), Sub-Resource Integrity, and ensuring a fresh load of the main HTML file. Network traffic encryption does not help in this stage of the attack, as the data is read directly from the DOM and transferred via the C&C methods described in Section VI-C.

To prevent 'two-factor authentication' attacks, the user should be required to confirm transaction details on a second device. Advanced attacks, such as phishing, exploit the same vulnerabilities. Security-critical applications like web mail should have all DNS and HTTP-level security measures enabled, including CSP, Sub-Resource Integrity, and HSTS, which enforces HTTPS. The parasites can also execute side-channel attacks against hardware, and defenses against these are specific to low-level systems. Additionally, the parasite can use WebRTC to find the internal IP of the client and run reconnaissance to find hosts via WebSockets. Once a device is identified, the exploit starts via JS. To execute attacks against the victim's OS and network, the victim must open any site with manipulated files in the cache.

### Recommendations for Countermeasures

We recommend disabling the caching of scripts to ensure a fresh copy is loaded every time. This can be achieved by adding a random query string to each request. Another defense is cache partitioning, which browser vendors have started deploying, although studies show it is inefficient. We also recommend that web servers support CSP, which prevents resources from being integrated by third parties. Our measurement of 15,000 top Alexa domains shows that CSP is implemented in only 4.33% of pages, and only about 4.7% actually supply CSP rules, with 15.3% using deprecated configurations. Lastly, poorly configured headers, such as 'connect-src *;', allow unrestricted WebSockets, which can be exploited.