(cid:8)
(cid:8)
(cid:8)
(cid:8)
n/a
EFFECTIVENESS OF REFRESH METHODS TO REMOVE OBJECTS STORED WITH CACHE
API (NOT SUPPORTED BY IE).
We perform evaluation of parasites’ injection into popular
caches in the Internet and show that the attack has a substan-
tially wider application scope than merely being applicable
to end hosts’ (clients) browser caches. The caches that we
found vulnerable to our attack are listed in Table IV. The
vulnerability in that case is that the browser cache is shared
between multiple sites. As a defence some modern browsers
offer separate caches for each ‘calling context’. Network
caches (e.g., on ISP or on local network) do not support
such an isolation and can therefore be seen as a shared
resource hence enable the associated attacks. Besides side
channel attacks, it is also possible to use network caches as
a way of infection. If the entry for a client in the cache is
infected, it automatically affects all other clients connected to
the cache. Since it is a design feature of network caches to
minimise resource usage by sharing resources, but no security
mechanisms are provided on the protocol side, all network-
based HTTP(s) caches are vulnerable to our attacks. To prevent
this, an isolation can be applied in the cache per client, which
2http://52.144.44.214/demo.html
however would harm performance. Fixing the software of the
network cache is not trivial. Injection attacks against reverse
proxies (e.g., on CDNs) also affect all users of the infected
proxy.
In our evaluations, we saw that different types of caches
have different persistence strategies. The persistence of the
browsers with regard to Cache API3 was experimentally
evaluated using a lab validation server. Our evaluations demon-
strated that in all the browsers, cleaning up the cache does not
sufﬁce to prevent the attacks. In particular, the cookies must
also be deleted in order to remove the parasites from the cache;
see Table III.
C. Command & Control Channel
After the victim disconnects from the network on which
the initial infection was made, the master uses a C&C chan-
nel to communicate to its parasite instances on the victim.
We design and implement a bi-directional C&C channel for
communication between the different parasites on a victim
and for communication between the parasites and the remote
attacker. Our channel enables sending commands to the bots
and retrieving data from the victims. The process is illustrated
in Figure 4.
Instead of relying on known protocols and features, which
can be blocked, such as CORS, we design our own commu-
nication protocol.
We use HTTP information leakage combined with cross
requests to allow a remote attacker to create a channel with
the parasite scripts in different domains. Our channel is based
on the dimensions of a cross image requests. When a cross
image request is performed, most image properties are hidden,
but the image dimensions are visible. This is needed to adapt
the page to the image proportions. For communication we
are transferring multiple images, encoding the information in
the width and height of the images. Our experiments show
that once the dimension is over 65,535, the browsers will
downgrade it to this value. Therefore, we can transfer in each
image 2 values between 0 and 65,535. Consequently, each
image contains 4 bytes of encoded data. We use SVG format,
Victim
1
3
4
GET top2.com/jquery.js
load from cache
reload original file
establish C&C connection
2
Internet
Fig. 4. C&C communication to parasites.
so that the total image size remains small, keeping down the
overhead bytes for transferring these 4 bytes of data. An SVG
image, having no actual content, is of size 100 bytes, and
in our experiments, using a client which sends requests for
multiple images simultaneously, we achieve a communication
channel of 100KB/s, from the master’s server to the parasite.
The communication channel in the other direction, from
the parasite to the master’s server is as follows: we use
HTTP requests, where the URL, or even the URL get/post
parameters are the encoded data, and hence with no bandwidth
limitations.
3https://developers.google.com/web/fundamentals/instant-and-ofﬂine/web-
storage/cache-api
Location
Caches on Victim Host -
Client-internal Caches
Caches on Victim Network -
Client-side Cache
Remote Caches - Backbone and
Server-Side Caches
Type
Browser Cache
Transparent Proxy
Web Filter
Firewall
Transport
Reverse Proxies
HTTP Accelerators
Web Application Firewall
ISP
Mobile Network
Instance
Desktop
Smartphones [26]
Squid
Cisco Web Security Appliances
McAfee Web Gateway
Citrix NetScaler [10]
Barracuda Web Filter
Blue Coat ProxySG
Sophos UTM
Fortigate
Barracuda F-Series
Cisco ASA
pfSense
Airplanes [31, 32]
(Cruise) Vessels [2, 41]
CDNs
Varnish HTTP Cache
F5 Big-IP WebAccelerator
SiteCelerate
GoDaddy WAF
CacheMara
LTE Network[28]
5G Networks [43]
TABLE IV
HTTP








*
(cid:8)
(cid:8)
(cid:8)*
(cid:8)*
(cid:8)
(cid:8)
(cid:8)
(cid:8)
(cid:8)
(cid:8)
(cid:8)
(cid:8)
‡
‡
Comment
HTTPS


(cid:8)
(cid:8)
(cid:8)
‡
×
×
(cid:8)
(cid:8)
×
×
×
‡
‡
(cid:8)
(cid:8)*
(cid:8)*
(cid:8)*
‡
×
×
×
AsyncOS 9.1.1
*community-documented
*via redirect
*via squid module
*when used with
separate SSL Ofﬂoader
with MEC
EVALUATION OF CACHES IN THE WILD. CACHING ENABLED BY DEFAULT (), OPTIONAL ((cid:8)), NOT SUPPORTED (×) OR SUPPORTED BY ARCHITECTURE MODEL BUT FUNCTION
second device. So in addition to the one-time password (OTP)
there must be implemented an out-of-band transaction detail
conﬁrmation.
VII. PARASITE ATTACKS AGAINST APPLICATIONS
NOT PUBLICLY DOCUMENTED OR IMPLEMENTATION-DEPENDENT (‡).
The attacks we developed and evaluated are application
dependent. We categorise the attacks per
target: against
browsers, against operating systems and against networks. The
attacks, along with their type, the targets, the exploits and
the requirements are listed in Table V. We incorporated the
different attacks into the parasite via the following modules:
(1) a module that reads the browser data such as current
URL, user agent, cookies, the local storage; (2) a module for
extracting protected browser data, for example, microphone
capturing; (3) a module for spreading the parasite based on
customised phishing, similar to Emotet [37]; (4) a module
that extracts login data, e.g., from Google, Facebook or online
banking applications. The parasites use the URL to detect on
which website they are currently running, then execute the
corresponding attack modules.
The vulnerabilities that allow our attacks is the execution
of untrusted JS with full access to the DOM. JS has complete
read and write access to the DOM, and the submit events
can be hooked. By reading data from the DOM the parasite
can read email communication, e.g., from Gmail, or account
numbers, e.g., on crypto exchanges, or to read the ﬁnancial
status in online banking. Encryption of the network trafﬁc does
not prevent the attack since the parasite can read the data
directly from the input ﬁelds and then transfer it to the attacker
via C&C channel. If the user is logged in, a corresponding
fake login screen is presented. By manipulating the DOM the
attacker can manipulate bank transfer details in online banking.
Preventing such attacks on the Browser level is hard, be-
cause the parasite utilises only standardised JS functions. The
most promising way is to limit the communication between
the attacker and the parasites by enforcing a strong CSP,
Sub-Resource-Integrity and a fresh load of the main HTML
ﬁle. In this stage of the attack the encryption of the network
trafﬁc does not help, because the data is read directly from the
DOM and then transferred to the attacker via the Command
& Control methods described in Section VI-C.
The defence to prevent ‘two-factor authentication’ attacks
should require the user to conﬁrm the transaction details on a
The vulnerabilities that allow advanced attacks, such as
phishing, are the same as previously listed. Security-critical
applications like web mail should have all the security mea-
sures on DNS and HTTP level enabled. Besides CSP and
sub-resource-integrity, HSTS should be enabled, because it
blocks the attack by enforcing HTTPS. The parasites can also
execute side channel attacks against hardware. The defences
to prevent such attacks are speciﬁc to the low-level systems,
the parasites are used only to execute the corresponding JS
based exploit code. In addition to attacking the browser and
the OS of the victim, we implemented functionality to ﬁnd
other hosts and propagate to them. The parasite uses WebRTC
to ﬁnd the internal IP of the client and runs reconnaissance
to ﬁnd hosts via WebSockets. We ﬁngerprint found hosts by
including ‘img’ tags and stylesheets into the DOM, listed to
onload events. Once a device is identiﬁed, the exploit starts
via JS. To execute attacks against victim OS and network the
victim has to open any site with manipulated ﬁles in the cache.
VIII. RECOMMENDATIONS FOR COUNTERMEASURES
We recommend to disable caching of scripts to ensure that
a fresh copy is loaded every time - we implemented this
by adding a random query string to each request. The used
alphabet in these ﬁles is allows to compress the ﬁle a lot.
Another defence is cache partitioning which browser ven-
dors started deploying, but studies show that it is inefﬁcient,
[11]. We also recommend that web servers support CSP, which
prevents resources from being integrated by third parties. Our
measurement of 15K-top Alexa domains shows that CSP is
implemented in only 4.33% of the pages, and only approx-
imately 4.7% actually supply CSP rules, from which 15.3%
where using a deprecated conﬁguration; see CSP statistics in
Figure 5. Lastly, not well conﬁgured headers are supplied in
those conﬁgurations as well as for example ’connect-src
*;’, which simply allows every connect-src (and there-
fore also WebSockets without restriction). Out of 160 times
Targets
Social networks, web mail, online
banking, crypto-exchanges
Name
Steal Login Data
Browser Data
Personal Browser Data
Website Data
Side Channels
Circumvent
Two Factor Authentication
Exploit
Use JS access to DOM & wait for events. Exﬁltrate data via C&C
by encoding data to JSON, and send to server with ‘src’ property
of an ‘img’ tag that is added to the DOM. We implemented modules
to read browser data (user agent cookies, local storage), to extract
login data by hooking into login forms (e.g., Google, Facebook, online
banking apps), and tested them (e.g., on Gmail, Facebook)
Cookies, LocalStorage
Access via Browser API
Geolocation, microphone, webcam Access via Browser API
Financial status, chats, emails...
Side channels between the
browser tabs to communicate
on the machine of a victim
Google Authenticator, TAN...
Access via DOM
Timing, CPU usage...
Exploits de-synchronisation of knowledge between server and client.
Access to the DOM allows attacker to manipulate the data and
interfaces the user sees. Attack is done in JS context of attacked site.
Let the user think he does his intended transaction,
but in reality he will accept an evil transaction
Transaction Manipulation
Online banking, crypto exchanges
Send Phishing
Steal Computation
Resources