# OpenSSL CVE-2016-0799： BIO_printf函数可引起堆内存崩溃
|
##### 译文声明
本文是翻译文章，文章来源：360安全播报
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
OpenSSL
是一个强大的安全套接字层密码库，其囊括了目前主流的密码算法，常用的密钥，证书封装管理功能以及SSL协议，并提供了丰富的应用程序可供开发人员测试或其它目的使用。
但是安全研究人员发现，OpenSSL的BIO_*printf()函数中存在几个问题，该函数定义在crypto/bio/b_print.c文件之中。开发人员将会在即将发布的安全补丁中修复这一问题。
这个函数的主要功能是负责解释和转换格式字符串，该函数的输入参数为_dpor()。
dpor()可以以一种渐进的方式对格式字符串中的字符逐个进行扫描，并利用doapr_outch()函数对数据进行输出。
doapr_outchr()函数的前两个参数是一个指向静态分配缓冲区（char**
sbuffer）的double类型指针,以及一个指向char类型指针（char
**buffer）的指针。值得注意的是，该指针的值是由doapr_outch()函数所分配的动态内存空间来决定的。
第一个参数，即静态缓冲区，应该始终是有效的。其内存空间的大小是由第三个参数所决定的，即t* currlen。
    static void
    701    doapr_outch(char **sbuffer,
    702                char **buffer, size_t *currlen, size_t *maxlen, int c)
    703    {
    704        /* If we haven't at least one buffer, someone has doe a big booboo */
    705        assert(*sbuffer != NULL || buffer != NULL);
    706
    707        /* |currlen| must always be  0) {
    719                    assert(*sbuffer != NULL);
    720                    memcpy(*buffer, *sbuffer, *currlen);
    721                }
    722                *sbuffer = NULL;
    723            } else {
    724                *buffer = OPENSSL_realloc(*buffer, *maxlen);
    725                if (!*buffer) {
    726                    /* Panic! Can't really do anything sensible. Just return */
    727                    return;
    728                }
    729            }
    730        }
    731
    732        if (*currlen  0) {
    719                    assert(*sbuffer != NULL);
    720                    memcpy(*buffer, *sbuffer, *currlen);
    721                }
    722                *sbuffer = NULL;
sbuffer被清空之后，数据字节将会被写入基于堆的*buffer，而不是基于栈的*sbuffer:
    if (*currlen < *maxlen) {
    733            if (*sbuffer)
    734                (*sbuffer)[(*currlen)++] = (char)c;
    735            else
    736                (*buffer)[(*currlen)++] = (char)c;
    737        }
BIO_printf/BIO_vprintf与BIO_snprintf/BIO_vsnprintf之间的区别
BIO_printf()函数与BIO_vprintf()函数可以允许doapr_outch()根据一个指向char指针的有效指针来为系统动态分配内存空间。
     int BIO_printf(BIO *bio, const char *format, ...)
    745    {
    746        va_list args;
    747        int ret;
    748
    749        va_start(args, format);
    750
    751        ret = BIO_vprintf(bio, format, args);
    752
    753        va_end(args);
    754        return (ret);
    755    }
    756
    757    int BIO_vprintf(BIO *bio, const char *format, va_list args)
    758    {
    759        int ret;
    760        size_t retlen;
    761        char hugebuf[1024 * 2];     /* Was previously 10k, which is unreasonable
    762                                     * in small-stack environments, like threads
    763                                     * or DOS programs. */
    764        char *hugebufp = hugebuf;
    765        size_t hugebufsize = sizeof(hugebuf);
    766        char *dynbuf = NULL;
    767        int ignored;
    768