dashed  arrows  depict  pChain  links  in  their  opposite 
directions,  which  show  propagations.  BRM2  has  a  newly 
created  signature  element,  so  its  src  is  labeled  as  “!IdP”, 
which also causes the dst element in BRM1 to bear a “!”. 
The cookie is ignored as it was set before the SSO starts.  
BRM1: src=RP   dst=https://!IdP/handler.php 
Arguments: notifyURL[URL] 
Cookies: sessionID[BLOB] 
BRM2: src=!IdP dst=https://RP/auth.php 
Arguments: 
username[WORD][UU] & sig[BLOB][SU][NC][SIG]
trace 
labeled  with  individual  elements’  semantic  meanings,  our 
analyzer  further evaluates  whether the adversary, Bob, can 
read  or  write  elements  in  the  three  SSO  triangles  in  the 
scenarios  illustrated  in  Figure  4:  Bob-IdP-RP,  Alice-IdP-
Bob  and 
readability  and 
writability  are  denoted  by  ↑  and  ↓  respectively.  Table  3 
elaborates the rules we used to label individual elements, to 
indicate how they can be accessed by the adversary.  
(Alice+Bob)-IdP-RP.  Here 
Adversary  accessibility 
labeling.  Over 
the 
369
Table 3: labeling rules for adversary’s accessibility 
Scenario (A): Bob acts as a browser  
•  All elements are readable; 
•  An element not covered by a signature is writable; 
•  For  an  element  protected  by  a  signature,  if  it  is  newly  created 
(NC),  then  it  is  not  writable;  otherwise,  inherit  the  writability 
label from its ancestor using pChain.  
Argument or Cookie elements in the BRM are readable; 
Scenario  (B):  Bob  acts  as  an  RP  to  the  IdP  in  order  to  get 
Alice's credential for the target RP 
•  Replace any occurrence of “RP” in the trace with “Bob”; 
•  For  any  BRM  sent  to  Bob  (or  the  dst  element  is  writable),  all 
•  For any BRM made by Bob, the dst element, or any Argument or 
Set-cookie element in the BRM is writable, if the element is not 
protected by the IdP’s signature; 
•  For  an  element  protected  by  a  signature,  if  it  is  newly  created 
(NC),  then  it  is  not  writable;  otherwise,  inherit  the  writability 
label from its ancestor using pChain. 
Scenario (C): Bob deposits a page in Alice’s browser
•  No element is readable; 
•  Cookies and set-cookies are not writable; 
•  Because the BRM can be generated by Bob, the dst element or 
any  Argument  element  in  a  BRM  is  writable,  if  the  element  is 
not protected by a signature; 
•  For  an  element  protected  by  a  signature,  if  it  is  newly  created 
(NC),  then  it  is  not  writable;  otherwise,  inherit  the  writability 
label from its ancestor using pChain. 
Output visualization. After analyzing the input traces, 
the  BRM  analyzer  produces  its  output  in  dynamic  HTML, 
which  allows  a  human  analyst  to  conveniently  retrieve  the 
understanding obtained through the automatic analysis using 
a browser. Figure 7 is a screenshot that displays an output 
trace. When the mouse hovers over an element, the element 
and  all  other  elements  on  its  pChain  are  all  highlighted, 
which enables the analyst to examine how the value of the 
element propagates. The mouseover event also brings up a 
tip popup that shows the element’s value. 
Figure 7: Visualization of an output trace 
4. STUDYING SSO SCHEMES ON MAJOR WEBSITES 
Like  a  debugger  extracting  ground  truths  about  call 
stack, memory and registers, the BRM analyzer described in 
section  3  extracts  necessary  ground  truths  about  an  SSO 
scheme  to  be  studied,  e.g.,  what  Bob  could  read  or  write, 
especially some key elements (e.g., those labeled with SEC 
or SIG, etc.). With this tool, we now can go onto the field 
study  about  leading  commercial  web  SSO  systems.  The 
study  covers  popular  SSO  services  on  the  web  (e.g., 
Facebook,  Google,  JanRain  and  PayPal),  and  the  SSO 
systems  of  high-profile  websites/services  (e.g.,  FarmVille, 
Freelancer, Nasdaq and Sears). The result shows that these 
prominent web SSO systems contain serious logic flaws that 
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:47:30 UTC from IEEE Xplore.  Restrictions apply. 
make it completely realistic for an unauthorized party to log 
into their customers’ accounts. These flaws are also found to 
be diverse, distributed across the code of RPs and IdPs, and 
at  the  stages  of  login  and  account  linking.  We  elaborate 
these vulnerabilities in the rest of the section.  
4.1.  Google ID (and OpenID in general) 
OpenID is a popular open standard for single sign on. It 
was  reported  that  there  were  over  one  billion  OpenID-
enabled user accounts and 9 million websites using OpenID 
as of December 2009 [22]. Google ID is based on OpenID. 
The number of its relying websites is very significant.  
the 
trace  and 
the 
information  about 
Analysis  result.  Our  analysis  on  Google  ID  started 
with the raw traffic. Not surprisingly, the raw traffic would 
be  very  time-consuming  for  human  to  parse  and  analyze. 
Using the BRM analyzer, we could automatically obtain the 
semantic 
three 
adversarial scenarios in Figure 5. The trace for scenario (A) 
is  shown  in  Figure  8,  in  which  the  RP  is  Smartsheet.com 
and  the  IdP  is  Google.com. All  elements  in  the  BRMs  are 
readable  in  scenario  (A),  so  the  readability  label  (↑)  is 
ignored.  The  figure  only  shows  the  writability  label  (↓). 
Note  that  a  specific  design  of  OpenID  is  that  many 
enumerable values are expressed in the format of URL. This 
detail is not important to our description below, so we label 
them [WORD] to avoid potential confusion.  
BRM1:src=RP dst=http://IdP/accounts/o8/ud ↓  
Arguments:  
openid.ns[WORD]↓ & openid.claimed_id[UU] ↓ & 
openid.identity[UU] ↓ & 
openid.return_to[URL]{RP/b/openid} ↓ & 
openid.realm[URL]{RP/b/openid} ↓ &  
openid.assoc_handle[BLOB]  ↓ & 
openid.openid.ns.ext1[WORD]  ↓ &    
openid.ext1.type.email[WORD]  ↓ & 
openid.ext1.type.firstname[WORD]  ↓ &  
openid.ext1.type.lastname[WORD]  ↓ & 
openid.ext1.required[LIST]  ↓ 
(email,firstname,lastname)
BRM2:src=IdP↓  dst=http://!IdP/openid2/auth 
Arguments: st[MU][SEC]  ↓ 
BRM3: src=!IdP  dst=https://RP/b/openid↓ 
Arguments: 
openid.ns[WORD] ↓ & openid.mode[WORD] &  
openid.response_nonce[SEC] & 
openid.return_to[URL] ↓ & 
openid.assoc_handle[BLOB] ↓ &  
openid.identity[UU] & openid.claimed_id[UU]& 
openid.sig[SIG] &  
openid.signed[LIST] ↓ & 
openid.opEndpoint[URL]{IdP/accounts/o8/ud}↓ &
openid.ext1.type.firstname[WORD] ↓ &  
openid.ext1.value.firstname[UU] & 
openid.ext1.type.email[WORD] ↓ & 
openid.ext1.value.email[UU] & 
openid.ext1.type.lastname[WORD] ↓ & 
openid.ext1.value.lastname[UU] 
protected  by 
openid.sig 
Figure 8: GoogleID+Smartsheet trace for scenario (A) 
We found that BRM3 is the message for proving to the 
RP  the  identity  of  the  user  the  browser  represents.  This 
370
message  carries  a  SIG  element  openid.sig,  indicating 
that the SSO is based on a signed token. The analysis further 
revealed the elements covered by the signature, as  marked 
in Figure 8.  Among these elements, openid.signed is a 
list that indicates the names for those signed elements. What 
is interesting here is that some of the signed elements were 
labeled  by  our  analyzer  as  writable  by  the  adversary.  A 
closer  look  at  them  shows  that  their  values  are  actually 
propagated from BRM1, which are not under any signature 
protection.  Particularly,  openid.signed  contains  the 
list  from  openid.ext1.required  on  BRM1,  an 
element  that  describes  which  elements  the  RP  requires  the 
IdP to sign, such as email, firstname and lastname, 
as  shown  in  the  popup  by  the  mouse  cursor  in  Figure  8. 
However,  since  openid.signed 
(BRM3)  can  be 
controlled  by  the  adversary  through  openid.ext1. 
required (BRM1), there is no guarantee that any of the 
elements that the RP requires the IdP to sign will be signed 
by the IdP (i.e., protected by openid.sig) in BRM3.  
Flaw and  exploit.  It is very common for a website to 
use  a  user’s  email  address  (e.g.,  PI:EMAIL)  as  his/her 
username, which is probably why the RP requires email to 
be  signed.  The  analysis  above  shows  that  an  attacker  in 
scenario (A) may cause the IdP to exclude the email element 
from the list of elements it signs, which will be sent back to 
the RP through BRM3. Therefore, the question to be asked 
about an actual system is: 
Does  the  RP  check  whether  the  email  element  in 
BRM3 is protected by the IdP’s signature, even though 
the protection has been explicitly required by BRM1? 
It turns out that this question indeed points to a serious 
logic  flaw  in  Google  ID  SSO.  Specifically,  we  tested  the 
exploit  on  Smartsheet:  when  our  browser  (i.e.,  Bob’s 
browser)  relayed  BRM1,  it  changed  openid.ext1. 
required (Figure 8)  to (firstname,lastname). As 
a  result,  BRM3  sent  by  the  IdP  did  not  contain  the  email 
element (i.e., openid.ext1.value.email). When this 
message  was  relayed  by  the  browser,  we  appended  to  it 
PI:EMAIL  as 
that 
Smartsheet  accepted  us  as  Alice  and  granted  us  the  full 
control of her account. 
the  email  element.  We  found 
the  flaw  also  existed 
Broader  impacts.  We  further  discovered  that  the 
problem  went  far  beyond  Smartsheet.  Google  confirmed 
that 
in  open  source  projects 
OpenID4Java (an SDK that Google authentication had been 
tested  against)  and  Kay  Framework.  In  OpenID4Java,  the 
function  for  an  RP  to  verify  BRM3  is  verify().  The 
source  code  showed  that  it  only  checked  whether  the 
signature covered all the elements in the openid.signed 
list,  so  a  “verified”  BRM3  does  not  ensure  authenticity  of 
the  elements  that  the  RP  required  the  IdP  to  sign.  Besides 
smartsheet,  we  examined  other  popular  websites  Yahoo! 
Mail, zoho.com, manymoon.com and diigo.com. They were 
all vulnerable to this attack. 
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:47:30 UTC from IEEE Xplore.  Restrictions apply. 
Responses  from  Google  and  OpenID  Foundation. 
We  reported  our  finding  to  Google,  Yahoo  and  OpenID 
Foundation, and helped Google to fix the issue. Google and 
OpenID Foundation published security advisories about this 
issue,  in  which  they  acknowledged  us.  We  provide  these 
advisories  in  [33].  Several  news  articles  reported  these 
advisories,  including  those  from  eWeek,  The  Register, 
ZDNet,  Information  Week,  etc  [33].  We  received  a 
monetary reward from Google,  who also added our  names 
to its official acknowledgement page [18]. 
4.2.  Facebook 
Authentication  on  Facebook  often  goes 
through 
Facebook Connect, which is a part of Facebook’s platform. 
We studied this SSO scheme. 
Analysis result. We performed our automatic analysis 
on  the  traces  collected  from  an  SSO  through  Facebook 
Connect.  The  result  (not  involving  the  adversary)  is 
illustrated  in  Figure  9.  Here,  the  IdP  is  Facebook,  and  the 
RP is NYTimes.com. We can see here that BRM3 carries a 
secret  token  result,  which  the  browser  uses  to  prove  to 
the RP the user’s identity. The secret comes from BRM2 as 
an argument for the API call http://!IdP/xd_proxy.php1. This 
secret token enables the  RP to acquire Alice’s information 
from  Facebook  and  also  grant  her  browser  access  to  her 
account.  Also  interesting  here  is  BRM1,  in  which  the  RP 
declares  to  the  IdP  its  identity  (e.g.,  NYTimes)  through 
app_id  and  provides  other  arguments.  Note  that  though 
the element cb in the figure is also labeled as SEC, it was 
found to be generated by the browser (labeled BG, see Table 
2) and thus not a secret shared between the RP and the IdP.  
BRM1:src=RP dst=http://!IdP/permissions.req 
Arguments: app_id[BLOB] & cb[SEC][BG] &   
   next[URL]{   
      http://!IdP/connect/xd_proxy.php?  
      origin[BLOB]&transport[WORD] 
   } & … & … & … (other 13 elements ) 
BRM2:src=!IdP  dst=http://!IdP/xd_proxy.php 
Arguments: origin[BLOB] & transport[WORD] & 
           result[SEC] & … & … (other 4 elements )
BRM3:src=!IdP  dst=http://RP/login.php  
Arguments: origin[BLOB] & transport[WORD] & 
           result[SEC] & … & … (other 3 elements ) 
Figure 9: the benign Facebook+NYTimes trace 
Our  analyzer  further  evaluated  the  trace  in  Figure  9 
under different adversarial scenarios. Figure 10 shows what 
we  found  under  Scenario  (B),  in  which  the  adversary  Bob 
impersonates the RP to Facebook when Alice is visiting his 
website. According to Table 3, all occurrences of “RP” are 
replaced with “Bob”. A potential vulnerability immediately 
shows  up  here  is  that  all  elements  in  BRM1,  including 
app_id, are  writable,  so  Bob  could  declare  that  he  was 
1 The hostname is  !IdP, rather than IdP, because our test showed 
that  Facebook  server  whitelists  its  allowed  hostnames.  It  only 
allows  a  hostname  under  facebook.com  or  a  Facebook-affiliated 
domain, such as fbcdn.net, etc.  
371
NYTimes using the app_id of NYTimes, which is public 
knowledge. As a result, the secret token result in BRM3, 
which Facebook generates specifically for Alice’s access to 
NYTimes  and  for  NYTimes  to  acquire  Alice’s  Facebook 
data under her consent, now goes to Bob.  
BRM1:src=Bob dst=http://!IdP/permissions.req  
Arguments: app_id[BLOB] ↓ & cb[SEC][BG] &  
   next[URL]{ 
      http://!IdP/connect/xd_proxy.php↓?  
      origin[BLOB] ↓ & transport[WORD] ↓ 