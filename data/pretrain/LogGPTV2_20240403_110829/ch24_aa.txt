不变的基础架构和 SRE
Jonah Horowitz，前 Netflix和 Stripe 员工
  不可变的基础设施可以显著减少维护大量生产服务器所需的工作量。它通过减少系统中的可变因素数量并更容易进行部分替换来实现这一点，因为服务的所有实例都是相同的。
可扩展性、可靠性和性能
SRE 这个词可能已经变得有点空洞，但其核心定义可以归结为几件事情：大规模提高 Web 操作的可扩展性、可靠性和性能。一个具有挑战性的，但令人难以置信的强大挑战，但是可以通过不变的基础设施来实现。
  不变的基础架构是使用小型的基础映像来启动每个软件组件的构建，然后将软件安装到该映像上的做法。对于每个版本，此映像在发布到生产之前都会重建。发布后，映像永远不会更改或更新，只可能替换为新影响。该过程称为“不可变”，因为已发布的软件已冻结且永不更改，仅被替换。正在运行的实例在启动后永远不会通过 Puppet，Chef 甚至 Secure Shell（SSH）等工具进行更新（它们可能仍运行 SSH 服务以便调试只需）。不可变的基础架构允许基础架构的水平扩展，从而提供可扩展性和性能。从正在运行的群集中添加和删除节点，这个任务的挑战之一是：确保每个节点都具有正确且相同的配置。登录并手动配置每个节点，这个方法可以管理 10 个节点的群集，但它是容易疲累的，因此容易出错。手动管理 100 个节点是愚蠢的。对于拥有一千个或更多节点的集群，如果每周每个节点花费超过 10 分钟，则实际上不可能单人完成。面对这样的辛劳，组织求助于配置管理工具来处理大型服务器群集。Chef 和 Puppet 是两个更受欢迎的选择，但还有更多的选择，包括从头写一个（显然不推荐这么做）。
Chef 和 Puppet 等配置管理系统最初工作良好，但当群集大小增加时，尤其是当你开始需要动态扩展时，它们最终会失败。当每个节点必须启动并运行另一个工具时（首先安装软件，然后配置软件）时，最终会浪费大量时间。如果节点已经准备好软件，则它们仅受其启动时间的限制。随着业界开始向容器化运维的方向迁移，启动时间变得更加快。如果可以在需要容量时快速添加节点，则可以节省资源，因为在任意给定时间只需足够的在线容量来支持当前流量负载。大多数网站在凌晨三点的流量明显少于下午七点。如果在看到负载增加后的几分钟内可以扩展容量，则可以使用较小的代价来运行系统，并且当负载较低时，也可以更有信心进行缩减。
故障恢复
  不变的基础架构支持的另一个功能是能够从故障中快速恢复。如果单个节点下的硬件发生故障，可以使用不变的映像来快速启动另一个节点以替换它。此新节点不需要其他配置或软件安装，因为它从群集中每个节点已使用的同一映像引导。此外，这使你可以利用 Netflix 的 Chaos Monkey 等工具来引发系统故障，从而保证你能够从容处理该故障。
更简单的运维
 简单性是速度的基本组成部分。不可变系统的一个优点是它使运维操作更简单。组件将被替换而不必修复，因此不再需要管理旧状态和新状态之间的状态转换之细节。无论是在服务器上运行的应用程序的新版本、操作系统的配置更改还是基础库的更新，这些统统都不会发生。在任何情况下，都可以保证运行相同的流程来将更新释放到生产环境中。这种简单性是需要强调的重要一点。无需对生产环境进行就地修补，这可大大提高部署的速度和可靠性。传统上管理基础结构时，许多代码专用于在更改之前检查当前状态，然后确保更新以预期的方式来影响当前状态。
考虑在 /etc/resolv.conf 中对 DNS 服务器进行简单配置更新。如果没有不可变的基础架构，那就必须确保先把旧 DNS 服务器下线，然后确保将新 DNS 服务器上线到正确的位置。使用不可变的基础架构，只需发布指向更新后 DNS 服务器的新版本，操作要简单得多。
更快的启动时间
 当我开始在技术领域工作时，我们要大约花一天的时间才能将一台新服务器投入负载均衡器中开始运作。通过配置管理，我能够将投入时间降低到不足一个小时，但使用不可变的基础架构则只要 5 分钟。这是一个策略上的权衡。构建新映像需要更长的时间，但每个映像的启动速度明显加快。这就好像我们做出的许多其他权衡。例如，我们使用gcc -O2来进行代码编译，用编译时间延长来换运行时间缩短。gcc 的 -O2 的参数会通过增长的编译时间来提高代码运行性能（https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html）。更快的启动时间使我们能够更高效地扩展我们的系统。如果启动时间为一小时，则需要提前至少一小时预测系统将承受的负荷，然后开始扩展以满足需求。如果启动时间只有 5 分钟，则只需预测未来 5 分钟的负荷。与所有预测一样，时间跨度越短，就可能越准确。这同样使你能够自信地缩减规模。如果流量呈下降趋势，并且预计流量在晚高峰已过，就可以自信地缩小群集规模，因为哪怕预测不正确，你也还是可以快速恢复容量。
更快的启动时间允许更实时或即时的容量管理，但它真正赋予我们的是增强对故障的抵御能力。快速替换节点的能力意味着，当节点因运行环境的外部故障或内部事件（如灾难演习）而崩溃时，我们可以立即自动替换节点，而无需人工干预。如果没有不可变的基础架构，灾难演习中你的基础架构可能会以真正的混乱告终。
已知状态已知状态
SRE 团队和安全团队最关心的问题之一是其基础设施中未知的黑暗角落。如果机器已经运行非常久的话，你永远无法真正知道它的状态。如果没有不可变的基础架构，机器可以保持生产多年，并不断升级和补丁，且安装新软件，并且可以在没有完整重新备份的情况下移除旧软件。你无法知道像这类系统的完整状态。
从安全角度来看，这很可怕，因为不知道计算机是否在很久以前就遭到入侵，也就是说计算机上是否有残存的恶意软件。从 SRE 的角度来看，这同样令人恐惧，因为不知道系统中是否潜伏着未知的 bug。可能某个库未升级，或者未安装其中一个修补程序。也许贵公司的某一位工程师手动安装了软件包或单个二进制文件。使用不可变的基础架构，就不必让实例运行超过几周，最好干脆少于几天。
与复杂系统中的所有内容一样，配置管理本身也并非完美无缺。它有时会失败，因此，即使使用维护最好的基础架构，最终也会得到一些没有得到最近更新的系统。这可能是因为代理当时恰好处于崩溃状态，或者因为存在网络问题。但无论出于何种原因，最终都无法让所有系统以预期的方式配置完美。使用不可变的基础架构，可以确保从映像正确启动新的计算机，并且确保配置正确且是最新的，因为实例的整个生命周期中只需完成一次配置。如果实例由于任何原因工作失常，只需将其关闭并将其替换为新实例即可。
自信地完成持续集成/持续部署
在传统的基础架构中，新的软件首先安装在开发环境，然后是测试环境，然后是登台环境，最后才是产品环境。 在每种情况下，软件的部署方式可能略有不同，特别是如果服务器在安装之间被重复使用。服务器之间的差异随着时间而变化。你不能假定在测试或登台中正常工作的改进在进入生产环境时会以相同的方式运行。当迁移到不可变的基础架构时，这种风险会大大降低。所使用的印象对于每个环境都是完全相同的，并且不会听到开发人员辩解“它在测试环境中明明运行良好！”部署不可变的基础架构的最佳方法是使用蓝/绿部署。其工作方式是，如果你有一个包含 200 个实例的群集来提供服务，我们将其标记为蓝色，然后再启动 200 个新版本映像实例，我们将其标记为绿色。当 200 个新实例启动并开始导入流量时，就可以停止到旧实例的流量。经过一段时间（可能一小时）的验证，确定它们是否正常运行，然后可以考虑终止旧实例。此过程允许非常平滑的推新和回滚。如果新版本发布后的错误比以前增加，只需将流量移回旧版本即可。
安全性
  不可变的基础架构在安全性方面也具有优势。因为每个实例都是从头开始构建的，所以在节点上累积的风险要低得多。这意味着安装用于临时解决问题的程序（或不再使用的旧库）不会让易受攻击的范围扩大。
即使攻击者获得对节点的控制，他们可以利用该节点的时间也会比较短，因为可以很容易的将此节点销毁，因此他们无法注入可长时间运行的漏洞。在推出安全修补程序时，可以使用与应用程序代码更改相同的发布过程。这最大限度地减少了风险，因为一个经常执行也易于理解的过程不太容易失败。
更痛苦的安全更新类型之一是内核修补程序。在传统基础架构中，做这件事风险很高，因为必须重新启动每台服务器，并期待服务器重启后再次联机。这可能由于多种原因而失败。在尝试升级之前，可能会发现未注意到的配置问题，还可能发现未知的潜在硬件问题。使用不可变的基础架构，就可以构建新内核的服务器映像，然后通过正常发布管道推送该映像即可。这样做更安全，速度更快，并且不需要在服务器重新启动时手动调试（或编写令人头痛的脚本）。