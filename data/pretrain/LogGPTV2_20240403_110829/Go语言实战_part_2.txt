Go语言及Go语言社区，积极寻求促进社区成长的新方法。
关于封面插图
本书封面插图的标题为“来自东印度的人”。这幅图选自伦敦的 Thomas Jefferys 的《A
Collection of the Dresses of Different Nations, Ancient and Modern》（4卷），出版于1757年到1772
年之间。书籍首页说明了这幅画的制作工艺是铜版雕刻，手工上色，外层用阿拉伯胶做保护。
Thomas Jefferys（1719—1771）被称作“地理界的乔治三世国王”。作为制图者，他在当时英国地
图商中处于领先地位。他为政府和其他官员雕刻和印刷地图，同时也制作大量的商业地图和地图
册，尤其是北美地图。他作为地图制作者的经历，点燃了他收集各地风俗服饰的兴趣，最终成就
了这部衣着集。
对遥远大陆的着迷以及对旅行的乐趣，是 18 世纪晚期才兴起的现象。这类收集品也风行一
时，向实地旅行家和空想旅行家们介绍各地的风俗。Jefferys 的画集如此多样，生动地向我们描
述了200年前世界上不同民族的独立特征。从那之后，衣着的特征发生了改变，那个时代不同地
区和国家的多样性，也逐渐消失。现在，很难再通过本地居民的服饰来区分他们所在的大陆。也
许，从乐观的方面看，也许，从乐观的角度来看，我们用文化的多样性换取了更加多样化的个人
生活——当然也是更加多样化和快节奏的科技生活。
在很难将一本计算机书与另一本区分开的时代，Manning创造性地将两个世纪以前不同地区
的多样性，附着在计算机行业的图书封面上，借以来赞美计算机行业的创造力和进取精神也为
Jeffreys的画带来了新的生命。
目录 1
目录
1 3.5.1 go vet 44
第1章 关于Go语言的介绍 1 3.5.2 Go代码格式化 45
3.5.3 Go语言的文档 45
1.1 用Go解决现代编程难题 2
3.6 与其他Go开发者合作 48
1.1.1 开发速度 2
1.1.2 并发 3 3.7 依赖管理 48
1.1.3 Go语言的类型系统 5 3.7.1 第三方依赖 49
1.1.4 内存管理 7 3.7.2 对gb的介绍 50
1.2 你好，Go 7 3.8 小结 52
1.3 小结 8
2 第4章 数组、切片和映射 53
第2章 快速开始一个Go程序 9 4 4.1 数组的内部实现和基础
2.1 程序架构 9 功能 53
2.2 main包 11 4.1.1 内部实现 53
4.1.2 声明和初始化 54
2.3 search包 13
4.1.3 使用数组 55
2.3.1 search.go 13 4.1.4 多维数组 58
2.3.2 feed.go 21 4.1.5 在函数间传递数组 59
2.3.3 match.go/default.go 24
4.2 切片的内部实现和基础
2.4 RSS匹配器 30
功能 60
2.5 小结 36
4.2.1 内部实现 60
3 4.2.2 创建和初始化 61
第3章 打包和工具链 37 4.2.3 使用切片 63
3.1 包 37 4.2.4 多维切片 74
4.2.5 在函数间传递切片 75
3.1.1 包名惯例 38
3.1.2 main包 38 4.3 映射的内部实现和基础
3.2 导入 39 功能 76
3.2.1 远程导入 40 4.3.1 内部实现 76
3.2.2 命名导入 40 4.3.2 创建和初始化 78
3.3 函数init 41 4.3.3 使用映射 79
4.3.4 在函数间传递映射 81
3.4 使用Go的工具 42
4.4 小结 82
3.5 进一步介绍Go开发
工具 44
ii 目录
5 7.2 pool 158
第5章 Go语言的类型系统 83
7.3 work 168
5.1 用户定义的类型 83 7.4 小结 174
5.2 方法 87
8
5.3 类型的本质 90 第8章 标准库 176
5.3.1 内置类型 91 8.1 文档与源代码 177
5.3.2 引用类型 91
8.2 记录日志 178
5.3.3 结构类型 93
8.2.1 log包 179
5.4 接口 95
8.2.2 定制的日志记录器 182
5.4.1 标准库 96 8.2.3 结论 186
5.4.2 实现 98
8.3 编码/解码 187
5.4.3 方法集 99
5.4.4 多态 103 8.3.1 解码JSON 187
8.3.2 编码JSON 192
5.5 嵌入类型 105
8.3.3 结论 193
5.6 公开或未公开的
8.4 输入和输出 193
标识符 113 8.4.1 Writer和Reader接口 194
5.7 小结 121 8.4.2 整合并完成工作 195
6 8.4.3 简单的curl 199
8.4.4 结论 200
第6章 并发 122
8.5 小结 200
6.1 并发与并行 122
9
6.2 goroutine 125 第9章 测试和性能 201
6.3 竞争状态 132
9.1 单元测试 201
6.4 锁住共享资源 135 9.1.1 基础单元测试 202
6.4.1 原子函数 135 9.1.2 表组测试 205
6.4.2 互斥锁 138 9.1.3 模仿调用 208
6.5 通道 140 9.1.4 测试服务端点 212
6.5.1 无缓冲的通道 141 9.2 示例 217
6.5.2 有缓冲的通道 146 9.3 基准测试 220
6.6 小结 149
9.4 小结 224
7
第7章 并发模式 150
7.1 runner 150
1
第 1 章 关于 Go 语言的介绍
第1章 关于Go语言的介绍
本章主要内容
 用Go语言解决现代计算难题
 使用Go语言工具
计算机一直在演化，但是编程语言并没有以同样的速度演化。现在的手机，内置的 CPU 核
数可能都多于我们使用的第一台电脑。高性能服务器拥有 64 核、128 核，甚至更多核。但是我
们依旧在使用为单核设计的技术在编程。
编程的技术同样在演化。大部分程序不再由单个开发者来完成，而是由处于不同时区、不同
时间段工作的一组人来完成。大项目被分解为小项目，指派给不同的程序员，程序员开发完成后，
再以可以在各个应用程序中交叉使用的库或者包的形式，提交给整个团队。
如今的程序员和公司比以往更加信任开源软件的力量。Go语言是一种让代码分享更容易的编
程语言。Go 语言自带一些工具，让使用别人写的包更容易，并且 Go 语言也让分享自己写的包
更容易。
在本章中读者会看到 Go 语言区别于其他编程语言的地方。Go 语言对传统的面向对象开发
进行了重新思考，并且提供了更高效的复用代码的手段。Go 语言还让用户能更高效地利用昂贵
服务器上的所有核心，而且它编译大型项目的速度也很快。
在阅读本章时，读者会对影响Go语言形态的很多决定有一些认识，从它的并发模型到快如
闪电的编译器。我们在前言中提到过，这里再强调一次：这本书是写给已经有一定其他编程语言
经验、想学习Go语言的中级开发者的。本书会提供一个专注、全面且符合习惯的视角。我们同
时专注语言的规范和实现，涉及的内容包括语法、Go 语言的类型系统、并发、通道、测试以及
其他一些非常广泛的主题。我们相信，对刚开始要学习Go语言和想要深入了解语言内部实现的
人来说，本书都是最佳选择。
本书示例中的源代码可以在https://github.com/goinaction/code下载。
我们希望读者能认识到，Go 语言附带的工具可以让开发人员的生活变得更简单。最后，读
者会意识到为什么那么多开发人员用Go语言来构建自己的新项目。
1.1 用 Go 解决现代编程难题
Go 语言开发团队花了很长时间来解决当今软件开发人员面对的问题。开发人员在为项目选
择语言时，不得不在快速开发和性能之间做出选择。C和C++这类语言提供了很快的执行速度，
而Ruby和Python这类语言则擅长快速开发。Go语言在这两者间架起了桥梁，不仅提供了高性
能的语言，同时也让开发更快速。
在探索Go语言的过程中，读者会看到精心设计的特性以及简洁的语法。作为一门语言，Go
不仅定义了能做什么，还定义了不能做什么。Go语言的语法简洁到只有几个关键字，便于记忆。
Go语言的编译器速度非常快，有时甚至会让人感觉不到在编译。所以，Go开发者能显著减少等
待项目构建的时间。因为Go语言内置并发机制，所以不用被迫使用特定的线程库，就能让软件
扩展，使用更多的资源。Go 语言的类型系统简单且高效，不需要为面向对象开发付出额外的心
智，让开发者能专注于代码复用。Go 语言还自带垃圾回收器，不需要用户自己管理内存。让我
们快速浏览一下这些关键特性。
1.1.1 开发速度
编译一个大型的C或者C++项目所花费的时间甚至比去喝杯咖啡的时间还长。图1-1是XKCD
中的一幅漫画，描述了在办公室里开小差的经典借口。
图1-1 努力工作？（来自XKCD）
Go语言使用了更加智能的编译器，并简化了解决依赖的算法，最终提供了更快的编译速度。
编译Go程序时，编译器只会关注那些直接被引用的库，而不是像Java、C和C++那样，要遍历
依赖链中所有依赖的库。因此，很多Go程序可以在1 秒内编译完。在现代硬件上，编译整个Go
语言的源码树只需要20秒。
因为没有从编译代码到执行代码的中间过程，用动态语言编写应用程序可以快速看到输出。
代价是，动态语言不提供静态语言提供的类型安全特性，不得不经常用大量的测试套件来避免在
运行的时候出现类型错误这类bug。
想象一下，使用类似JavaScript这种动态语言开发一个大型应用程序，有一个函数期望接收
一个叫作 的字段。这个参数应该是整数，是字符串，还是一个 UUID？要想知道答案，只能
ID
去看源代码。可以尝试使用一个数字或者字符串来执行这个函数，看看会发生什么。在Go语言
里，完全不用为这件事情操心，因为编译器就能帮用户捕获这种类型错误。
1.1.2 并发
作为程序员，要开发出能充分利用硬件资源的应用程序是一件很难的事情。现代计算机都拥
有多个核，但是大部分编程语言都没有有效的工具让程序可以轻易利用这些资源。这些语言需要
写大量的线程同步代码来利用多个核，很容易导致错误。
Go 语言对并发的支持是这门语言最重要的特性之一。goroutine 很像线程，但是它占用的
内存远少于线程，使用它需要的代码更少。通道（channel）是一种内置的数据结构，可以让
用户在不同的 goroutine之间同步发送具有类型的消息。这让编程模型更倾向于在 goroutine
之间发送消息，而不是让多个 goroutine争夺同一个数据的使用权。让我们看看这些特性的
细节。
1．goroutine
goroutine 是可以与其他 goroutine 并行执行的函数，同时也会与主程序（程序的入口）并行
执行。在其他编程语言中，你需要用线程来完成同样的事情，而在Go语言中会使用同一个线程
来执行多个goroutine。例如，用户在写一个Web服务器，希望同时处理不同的Web请求，如果
使用 C 或者 Java，不得不写大量的额外代码来使用线程。在 Go 语言中，net/http 库直接使用了
内置的goroutine。每个接收到的请求都自动在其自己的 goroutine 里处理。goroutine 使用的内存
比线程更少，Go 语言运行时会自动在配置的一组逻辑处理器上调度执行 goroutine。每个逻辑处
理器绑定到一个操作系统线程上（见图1-2）。这让用户的应用程序执行效率更高，而开发工作量
显著减少。
如果想在执行一段代码的同时，并行去做另外一些事情，goroutine是很好的选择。下面是一
个简单的例子：
func log(msg string) {
．这里是一些记录日志的代码
..
}
代码里有些地方检测到了错误
//
发生了可怕的事情
go log(" ")
图1-2 在单一系统线程上执行多个goroutine
关键字 go 是唯一需要去编写的代码，调度 log 函数作为独立的 goroutine 去运行，以便与
其他 goroutine 并行执行。这意味着应用程序的其余部分会与记录日志并行执行，通常这种并行
能让最终用户觉得性能更好。就像之前说的，goroutine占用的资源更少，所以常常能启动成千上
万个goroutine。我们会在第6章更加深入地探讨goroutine和并发。
2．通道
通道是一种数据结构，可以让 goroutine 之间进行安全的数据通信。通道可以帮用户避免其
他语言里常见的共享内存访问的问题。
并发的最难的部分就是要确保其他并发运行的进程、线程或 goroutine 不会意外修改用户的
数据。当不同的线程在没有同步保护的情况下修改同一个数据时，总会发生灾难。在其他语言中，
如果使用全局变量或者共享内存，必须使用复杂的锁规则来防止对同一个变量的不同步修改。
为了解决这个问题，通道提供了一种新模式，从而保证并发修改时的数据安全。通道这一模
式保证同一时刻只会有一个goroutine修改数据。通道用于在几个运行的goroutine之间发送数据。
在图1-3中可以看到数据是如何流动的示例。想象一个应用程序，有多个进程需要顺序读取或者
修改某个数据，使用goroutine和通道，可以为这个过程建立安全的模型。
图1-3 使用通道在goroutine之间安全地发送数据
图 1-3中有 3 个 goroutine，还有 2个不带缓存的通道。第一个 goroutine通过通道把数
据传给已经在等待的第二个 goroutine。在两个 goroutine 间传输数据是同步的，一旦传输完
成，两个 goroutine都会知道数据已经完成传输。当第二个 goroutine利用这个数据完成其任
务后，将这个数据传给第三个正在等待的 goroutine。这次传输依旧是同步的，两个 goroutine
都会确认数据传输完成。这种在 goroutine之间安全传输数据的方法不需要任何锁或者同步
机制。
需要强调的是，通道并不提供跨 goroutine 的数据访问保护机制。如果通过通道传输数据的
一份副本，那么每个 goroutine 都持有一份副本，各自对自己的副本做修改是安全的。当传输的
是指向数据的指针时，如果读和写是由不同的goroutine完成的，每个goroutine依旧需要额外的
同步动作。
1.1.3 Go 语言的类型系统
Go 语言提供了灵活的、无继承的类型系统，无需降低运行性能就能最大程度上复用代码。
这个类型系统依然支持面向对象开发，但避免了传统面向对象的问题。如果你曾经在复杂的Java
和C++程序上花数周时间考虑如何抽象类和接口，你就能意识到Go语言的类型系统有多么简单。
Go 开发者使用组合（composition）设计模式，只需简单地将一个类型嵌入到另一个类型，就能
复用所有的功能。其他语言也能使用组合，但是不得不和继承绑在一起使用，结果使整个用法非
常复杂，很难使用。在Go语言中，一个类型由其他更微小的类型组合而成，避免了传统的基于
继承的模型。
另外，Go 语言还具有独特的接口实现机制，允许用户对行为进行建模，而不是对类型进行
建模。在Go语言中，不需要声明某个类型实现了某个接口，编译器会判断一个类型的实例是否
符合正在使用的接口。Go 标准库里的很多接口都非常简单，只开放几个函数。从实践上讲，尤
其对那些使用类似Java的面向对象语言的人来说，需要一些时间才能习惯这个特性。
1．类型简单
Go语言不仅有类似 int和 string这样的内置类型，还支持用户定义的类型。在Go语言
中，用户定义的类型通常包含一组带类型的字段，用于存储数据。Go 语言的用户定义的类型看
起来和C语言的结构很像，用起来也很相似。不过Go语言的类型可以声明操作该类型数据的方
法。传统语言使用继承来扩展结构——Client继承自User，User继承自Entity，Go语言与此不同，
Go 开发者构建更小的类型——Customer 和 Admin，然后把这些小类型组合成更大的类型。图1-4
展示了继承和组合之间的不同。
2．Go接口对一组行为建模
接口用于描述类型的行为。如果一个类型的实例实现了一个接口，意味着这个实例可以执行