本文是[《ASLR PROTECTION FOR STATICALLY LINKED
EXECUTABLES》](https://www.leviathansecurity.com/blog/aslr-protection-for-statically-linked-executables)的翻译文章
# 1 简介
本文提供了对静态链接可执行文件更加隐蔽的安全漏洞的见解，包括但不限于以下内容：
  * 静态链接可执行文件的glibc初始化代码
  * 对于静态链接的可执行文件，攻击面看起来是什么样的
  * 为什么像RELRO和ASLR这样的缓解对于静态链接的可执行文件和动态链接的可执行文件同样重要
  * 关于RELRO，ASLR和静态可执行文件的常见误解：静态链接会禁用重要的安全缓解，使程序容易受到攻击
目前，只读重定位（RELRO）是一种安全保护（在2.3节中讨论），对静态链接的可执行文件至关重要。即使是杰出的ELF二进制工程师也没有发现这种RELRO保护措施（于静态链接文件中）的存在，并且这种措施还被误认为对于静态链接的可执行文件并不重要。正如我们将通过一些RE示例演示的那样，静态和动态链接的可执行文件具有相同的攻击面。第二个问题是ASLR不能应用于静态可执行文件，但是像RELRO一样，现在是一个重要的安全保护措施。在这篇文章中，我们深入探讨了针对静态可执行文件使用RELRO和ASLR的细节，以及每个问题的解决方案。然后提供一个POC供读者推断或用于保护静态可执行安全风险，直到得出一个更完整的解决方案为止。
静态二进制文件通常用于常见的现成软件（COTS），原因有很多种，例如避免依赖动态库版本的兼容性问题。这忽略了静态链接可执行文件的安全性后果，部分原因是某些脚本（例如checksec.sh
[3]）错误地报告从而启用了部分RELRO的静态链接可执行文件。
本文的目的是为软件开发过程的安全性做出贡献，这个开发的生命周期一般应用于越来越多的支持ELF二进制格式的操作系统（OSs：operating
systems）。静态可执行文件现在比以往任何时候都更像是一个主要目标，正如我们将在3.1节中看到的那样，RELRO和ASLR使得利用更难以实现。
如果某个软件存在内存损坏漏洞，则启用适当的二进制保护可能会完全阻止漏洞利用。例如，在攻击者只有一个指针宽度写入原语的情况下，没有mprotect@PLT将RELRO段标记为可写，这时RELRO会使漏洞无法利用。如上所述，我们将在3.1节中更详细地探讨这一点。
# 2 标准ELF安全保护的状态
多年来，glibc（GNU
C库），GNU链接器和动态链接器都进行了大量改进，这使得各种安全保护成为可能，包括完整的ASLR，这需要修改编译器和链接器。Pipacs是一个备受尊敬且多产的PaX安全研究工程师，从ASLR到PAGEEXEC
[4] ，他已经开发了许多用户空间和核心空间的保护技术。
Pipacs的一个发现是，除了随机化堆，堆栈和共享的地址空间之外，还可以随机化ELF可执行文件本身的地址空间，从而使ret2plt和ROP攻击更加困难。他还提出了两种解决方案：首先是RandExec
[5]，然后是更优雅的解决方案就是，引导PIE（位置无关的可执行文件）文件。
引导PIE文件背后的想法是，您可以创建一个ELF可执行文件，使其具有与共享库对象相同的属性：位置无关代码（PIC）和基本地址0x0，使内核可以在运行时重定位二进制文件。常规共享库和PIE可执行文件之间的唯一区别是初始化代码，并且可执行文件必须具有PT_INTERP段来描述动态链接器的路径。常规可执行文件具有ELF文件类型ET_EXEC，而PIE可执行文件具有ET_DYN文件类型，共享库也是如此。PIE可执行文件使用IP相对寻址模式来避免硬编码对绝对地址的引用。一个ELF
ET_DYN且基址为0x0的程序可以在每次运行时随机重定位到不同的基址。
## 2.1支持静态PIE的相关工作
在写完本文的大部分内容之后，我发现了一些可以尝试将静态PIE可执行文件放入主函数线的方法。但是，据我所知，这仍然没有标准选项。我还发现有一个补丁可以添加静态PIE选项。有关的详细信息请参阅[6]和[7]，这是我在查找资料时发现的两个论坛帖子。
## 2.2什么时候ASLR是完整的？
当可执行文件在高权限状态下运行时，例如sshd，在理想情况下，它将被编译并链接到PIE可执行文件中，该PIE可执行文件可以在将运行时将重定位放入随机地址空间，从而将攻击面强化为更加恶劣的游戏场。以root身份运行的敏感程序永远都不应构建为静态链接，并且在绝大多数的情况下应始终启用所有可用的二进制保护。
不使用PIE二进制文件的一个原因是IP相对寻址会影响各个级别的程序性能，如Red
Hat团队的这篇有趣的论文所述[8]。偶尔会出现边缘情况，其中必须关闭保护措施，例如-fstack-protector，以便启用自定义保护。但一般情况下，应尽可能为敏感程序启用从金丝雀到ASLR和完整RELRO的所有内容。例如，sshd几乎总是在启用所有保护的情况下构建的，包括完整的ASLR，这意味着sshd是作为PIE可执行文件构建的。尝试运行`readelf
-e /usr/sbin/sshd | grep DYN`，你会看到sshd（最有可能）以这种方式构建，尽管有一些例外，具体情况取决于架构。
## 2.3 RELRO入门
现在让我们来看看另一个鲜为人知的安全保护措施。RELRO是一种具有两种模式（部分和完全）的安全保护技术。在默认情况下，只执行部分RELRO，因为它使用缓慢链接（lazy
linking），而完整RELRO需要精确链接（strict
linking）[1]。精确链接与缓慢链接相比，在程序加载时间上更低效，因为动态链接器在精确链接中而不是按需绑定/重新定位。但是，通过将数据段中的特定区域标记为只读，即.init_array，.fini_array，.jcr，.got，.got.plt部分，完整的RELRO可以非常有力地强化攻击面。.got.plt部分和.fini_array是攻击者最常见的目标，因为它们分别包含共享库例程的函数指针和析构函数例程的函数指针。
# 3静态链接可执行文件和安全性的整体视图
开发人员经常使用静态链接的可执行文件，因为它们更易于管理，调试和发布;
一切都是自足的。用户遇到静态链接可执行文件问题的可能性远小于动态链接可执行文件，因为后者需要许多甚至有时数千个的动态库依赖项。作为这个领域的专业研究人员，我已经意识到静态链接的ELF可执行文件的更明显的优点和缺点，但我认为它们不会遇到与动态链接的可执行文件相同的ELF安全问题。事实上，令我惊讶的是，我发现静态链接的可执行文件容易受到许多与动态链接的可执行文件相同的攻击，包括3.1节中详述的那些：
## 3.1 RELRO保护的攻击点
  * 恶意软件的共享库注入
  * Dtors（.fin_array）中毒（注意：仅与某些静态链接的可执行文件相关）
  * Got.plt中毒（即GOTPLT劫持）
## 3.2为什么静态链接可执行文件中的这些漏洞长期以来都备受关注？
静态链接的可执行文件中的这些漏洞长期以来都备受关注，因为.got.plt部分并不总是用作一种聪明的优化方式。它根本不存在，因此没有出现攻击面。我不知道引入这个.got.plt优化的确切日期。
## 3.3完全RELRO保护与部分RELRO保护
完全RELRO保护所有部分（.got.plt，.got，.init_array，.fini_array，.dynamic和.jcr），而部分RELRO省略保护.got.plt，因为它需要在整个过程的生命周期内更新以支持按需动态链接。这是一个问题，因为它将.got.plt暴露为攻击面。
默认情况下，即使静态可执行文件仅在进程初始化时更新.got.plt，甚至没有启用RELRO，它仍然会暴露.got.plt攻击面。如果攻击者可以找到.got.plt部分，他们可以破坏关键函数指针。
那么，保护静态可执行文件的解决方案是什么？
注意：.init_array和.fini_array是.ctors和.dtors的新名称，并且具有相应的SHT_INIT_ARRAY和SHT_FINI_ARRAY类型。
## 3.4深入攻击面
发现.got.plt是静态链接二进制文件中暴露的攻击面让我以及我认识的几位熟练的ELF研究人员感到惊讶。让我们看看用RELRO保护可执行文件的所有方法。
### 3.4.1共享库注入保护
虽然共享库注入保护不是RELRO的最初目的，但它可以与DEP的各种运行相结合，例如PaX
mprotect()限制，并防止运行时被恶意软件攻击。例如，共享库函数重定向因PaX禁止PTRACE_POKETEXT为只读段而被挫败。
### 3.4.2同样的旧开发技术是适用的
从开发的角度来看，当你意识到.got.plt部分仍然是静态链接的可执行文件中的相关攻击面时，事情会变得更有趣。我们将很快讨论.got.plt的目的，但是现在，重要的是要注意.got.plt包含指向libc例程的函数指针，并且曾经被动态链接的可执行文件利用。.init_array和.fini_array函数指针分别指向初始化和析构函数例程。
具体来说，.fini_array，也称为.dtors，尽管它的利用可能不像.got.plt部分那样普遍存在，但它也已经被用于许多类型漏洞中的代码执行。在以下部分中，我们分析静态链接可执行文件中缺少安全性保护，与此同时，我们还将探索一些逆向工程和二进制保护技术。该分析将向读者证明静态链接可执行文件的攻击面几乎与动态链接可执行文件的攻击面相同。此信息很重要，因为RELRO和ASLR等二进制保护不适用于与当前工具链的静态链接可执行文件。如果你很时间充裕，那就等一下。稍后我们将深入探讨具体细节，并通过将ASLR和RELRO应用于静态链接的可执行文件来探索一些创新的黑客攻击方式。
### 3.4.3静态链接的可执行文件中的RELRO歧义
下面的静态二进制文件是在使用`gcc -static -Wl, -z, relro, -z,
now`命令启用完全RELRO的情况下构建的，之后即使是精明的反编译器也可能会误以为RELRO已启用。此时，部分RELRO和完整RELRO都与静态链接的可执行文件不兼容，因为动态链接器负责重新映射和保护数据段中的常见攻击点，例如.got.plt，并且如图所示。输出下面没有类型PT_INTERP的程序头来指定解释器，我们也不会静态链接的可执行文件中看到它，因为它们不使用动态链接。
默认链接描述文件就是指示链接器创建GNU_RELRO段，即使此段不起作用也会创建。我们设计了一个解决方案，使用PT_GNU_RELRO程序头，在静态链接的可执行文件上启用RELRO。PT_GNU_RELRO程序头与数据段的程序头共享相同的p_vaddr和p_offset，因为这是.init_array，.fini_array，.jcr，.dynamic，.got和.got.plt部分将存储在内存中的位置。内存中PT_GNU_RELRO的大小由程序头的p_memsz字段描述，该字段应与下一个PAGE_SIZE对齐，以获取动态链接器传递给mprotect()以标记页面的'len'值，从而将页面标记为只读。让我们仔细看看这些程序头和映射到它们的部分。
以下是静态链接的ELF可执行文件的程序头：
    $ readelf -l test
    Elf file type is EXEC (Executable file)
    Entry point 0x4008b0
从偏移量64开始有6个程序头：
    Program Headers:
      Type           Offset             VirtAddr           PhysAddr
                     FileSiz            MemSiz              Flags  Align
      LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                     0x00000000000cbf67 0x00000000000cbf67  R E    200000
      LOAD           0x00000000000cceb8 0x00000000006cceb8 0x00000000006cceb8
                     0x0000000000001cb8 0x0000000000003570  RW     200000
      NOTE           0x0000000000000190 0x0000000000400190 0x0000000000400190
                     0x0000000000000044 0x0000000000000044  R      4
      TLS            0x00000000000cceb8 0x00000000006cceb8 0x00000000006cceb8
                     0x0000000000000020 0x0000000000000050  R      8
      GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                     0x0000000000000000 0x0000000000000000  RW     10
      GNU_RELRO      0x00000000000cceb8 0x00000000006cceb8 0x00000000006cceb8
                     0x0000000000000148 0x0000000000000148  R      1
节到段的映射：
    Segment Sections...
       00     .note.ABI-tag .note.gnu.build-id .rela.plt .init .plt .text __libc_freeres_fn __libc_thread_freeres_fn .fini .rodata __libc_subfreeres __libc_atexit .stapsdt.base __libc_thread_subfreeres .eh_frame .gcc_except_table
       01     .tdata .init_array .fini_array .jcr .data.rel.ro .got .got.plt .data .bss __libc_freeres_ptrs
       02     .note.ABI-tag .note.gnu.build-id
       03     .tdata .tbss
       04   
       05     .tdata .init_array .fini_array .jcr .data.rel.ro .got
请注意，GNU_RELRO段指向数据段的开头，通常是您希望动态链接器将N个字节保护为只读的位置。通常，不超过数据段的前4096个字节是需要保护的。但是，尽管有GNU_RELRO段，静态可执行文件并没有考虑到安全性。一个明显的迹象是包含TLS数据的.tdata部分，作为数据段中的第一部分，如果它用mprotect()标记为PROT_READ，那么多线程程序将无法正确运行。如果glibc
ld / gcc开发人员考虑过RELRO，他们可能会将.tdata部分放在.data部分和.bss部分之间。
### 3.4.4 重要的注释
正如@ulexec指出的那样，.init_array/.fini_array部分在glibc静态链接的可执行文件中不起作用。另一方面，.got.plt非常活跃，因为它被用作静态可执行文件中的libc例程的优化。.got.plt是最大的威胁，它用于glibc的静态链接模型，而我们传统上说的.ctors和.dtors却不会被使用，尽管它们存在而且通常为.init_array和.fini_array。但是，静态可执行文件并不总是像使用-static标志那样严格，当你从glibc的严格链接描述文件和标准init / deinit例程的上下文中删除静态ELF时，将会证明这一点。
因为-static并不像看起来那么严格，所以我们必须考虑通常受RELRO保护的所有ELF部分（不仅仅是.got.plt）在静态链接的可执行文件中的活动和行为几乎相同，除了经过证明的个别案例以外。我们现在已经知道了.got.plt用作libc例程的优化，这个将在稍后进行演示，这个函数指针的.got.plt表是一个很好的攻击面，并且早在2000年就已经用于动态链接的可执行文件中了，如多年前出版的Nergal的论文所示。[9]
### 3.4.5 checksec.sh无法提供准确的信息
checksec.sh
[3]使用GNU_RELRO段作为表示是否在二进制文件上启用了RELRO的一种标志。在静态编译的二进制文件的情况下，checksec.sh将报告启用了部分RELRO，因为它无法找到DT_BIND_NOW动态段标志，静态链接的可执行文件中也没有动态段。为了使这更具体，让我们通过一个静态链接可执行文件的glibc初始化代码进行轻量级浏览。
在上面的输出中，数据段中有一个.got和.got.plt部分。通常，启用完整RELRO需要将它们合并为一个单独的“.got”部分。但是，我们设计了一个不需要合并的工具“RelroS”，只需要将它们都标记为只读。
# 4 更深入的静态链接和攻击面概述
注意：可以在这里查看ftrace工具的高级概述： 该工具可以执行函数级别的跟踪。
    $ ftrace test_binary
    LOCAL_call@0x404fd0:__libc_start_main()
    LOCAL_call@0x404f60:get_common_indeces.constprop.1()
    (RETURN VALUE) LOCAL_call@0x404f60: get_common_indeces.constprop.1() = 3
    LOCAL_call@0x404cc0:generic_start_main()
    LOCAL_call@0x447cb0:_dl_aux_init() (RETURN VALUE) LOCAL_call@0x447cb0:
    _dl_aux_init() = 7ffec5360bf9
    LOCAL_call@0x4490b0:_dl_discover_osversion(0x7ffec5360be8)
    LOCAL_call@0x46f5e0:uname() LOCAL_call@0x46f5e0:__uname()
通常在动态链接器中发生的大部分繁重工作都是由函数generic_start_main()执行的，该函数除了其他任务外，还对数据段中的多个部分（包括.got）执行全面的重定位和修复，包括
plt部分。这样就能够设置一些观察点来观察早期的一个查询CPU信息的功能，如CPU缓存大小。此函数能让glibc
init代码智能地确定应该使用哪个版本的给定函数（例如strcpy()）进行优化。
请注意，当我们在GOT条目上为多个共享库例程设置监视点时，generic_start_main()在某种意义上用作动态链接器的类似机制，因为它的工作主要是执行重定位和修复。  
\-- 在一个带有静态二进制文件的探索性GDB会话中 --
    (gdb) x/gx 0x6d0018 /* .got.plt entry for strcpy */
    0x6d0018:    0x000000000043f600