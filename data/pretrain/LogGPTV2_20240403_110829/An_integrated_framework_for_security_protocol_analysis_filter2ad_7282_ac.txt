represents an independent party interested in using the application 
reader  and  a  PIN  pad.  The  goal  of  the  protocol  is  to  establish  a 
secure  channel  between  the  SE  and  SP,  transmit  the  data  to  be 
signed  to  the  smartcard  held  by  SE  and  deliver  the  signed 
document first to SP and then to AP to finalize the transaction.  
The UML model of the TSC protocol is presented in Figure 8. For 
clarity,  we  have  removed  the  Application  Provider  from  the 
model,  as  his  involvement  in  the  protocol  is  limited  to  receiving 
the  signed  data  in  the  last  message  of  the protocol. For the same 
reason we have omitted any > notes present in the 
full model. The notation used in the model is briefly explained in 
Figure 9. 
SE : Signing Entity
SP : Service 
Provider 
1. { SE, PK_AUT(SE) }{ SK_SIG(CA) }, TRANS_ID
>
SE, TRANS_ID
> 
RND(SP) 
2. RND(SP)
> 
PART_KEY(SE), RND(SE) 
TSC 
Subprotocol A
3. {{ PART_KEY(SE), RND(SP), SP }{ SK_AUT(SE) }}{ PK_AUT(SP) }, RND(SE)
4. {{ PART_KEY(SP), RND(SE), SE }{ SK_AUT(SP) }}{ PK_AUT(SE) }
>
SP, RND(SP)
> 
PART_KEY(SP) 
>
SE, RND(SE)
> 
SK
5. { PIN }{ SK }, { SK }{ PK_AUT(SP) } 
>
SM_KEY = f1(PART_KEY(SE), PART_KEY(SP))
SM_KEY_MAC = f2(PART_KEY(SE), PART_KEY(SP))
6. { PIN }{ SM_KEY }, h(PIN, SM_KEY_MAC) 
>
PIN 
> 
SM_KEY = f1(PART_KEY(SE), PART_KEY(SP)) 
SM_KEY_MAC = f2(PART_KEY(SE), PART_KEY(SP))
TSC 
Subprotocol B 
7. { g(DTBS) }{ SM_KEY }, h(g(DTBS), SM_KEY_MAC)
8. {{g(DTBS)}{SK_SIG(SE)}}{SM_KEY},h({g(DTBS)}{SK_SIG(SE)}, SM_KEY_MAC)
> 
SE
knows {SE, PK_AUT(SE)}{SK_SIG(CA)}
knows PIN 
knows PK_AUT(*), PK_SIG(SE), 
knows SK_AUT(SE), SK_SIG(SE). 
knows SE, SP, TRANS_ID, g(DTBS) 
>
SP
knows PK_AUT(SP)
knows PK_SIG(CA), PK_SIG(SP)
knows SK_AUT(SP), SK_SIG(SP)
knows SP, SE, TRANS_ID
Figure 8. Trusted Signature Creation Protocol 
offered  by  the  AP.  The  service  provider  supplies  the  SE  with  a 
personal  smartcard  and the PIN number for accessing the private 
signature key stored on the card. The system is designed to allow 
the  SE  to  sign  electronic  documents  remotely  on  the  Internet, 
providing  he  has  access  to  a  terminal  equipped  with  a  smartcard 
4.2  Modeling the TSC protocol with FOCUS 
The FOCUS formal method [9] together with its supporting tool, 
AutoFocus  [23],  were  applied  in  the  formal  modeling  process. 
The  AutoFocus  tool  was  originally  intended  for  developing 
reliable embedded systems. It was adapted to cryptographic  
82
Symbol 
Ni ∈
Mi (for 
) 
M1,M2,M3… 
{M}{K} 
PK_AUT(A), 
SK_AUT(A) 
PK_SIG(A), 
SK_SIG(A) 
>  
M1, M2, M3 ... 
> 
 M1, M2, M3 
... 
TRANS_ID 
Definition 
atomic data or a data 
structure 
concatenation of fields 
M1, M2, M3 … 
message M encrypted or 
signed using K 
A’s public and private 
key for encryption 
A’s public and private 
key for signatures 
an agent checks values 
of M1, M2, M3 … after 
receipt 
an agent generates fresh 
values of M1, M2, M3 
…  
a transaction (session) 
identification number 
  Symbol 
  K 
  A 
  SK, SM_KEY 
  PIN 
  M = 
f(M1,M2,M3…) 
  h(M1,M2,M3…), 
g(M1,M2,M3…) 
Definition 
key used for encryption 
or signatures 
agent or a Certification 
Authority  
a shared session key 
SE’s private 
identification number 
M is generated using 
values M1, M2, M3 … 
one-way hash functions 
  DTBS 
data to be signed by SE 
  RND(A),  
PART_KEY(A) 
random numbers 
generated by A 
Figure 9. Notation used in the model of the TSC protocol 
protocol analysis because FOCUS allows modeling of all relevant 
cryptographic  operations  and  functions  [24].  However,  the 
flexibility of the formal language and its universal nature result in 
a relatively high degree of model complexity. 
A  security  protocol  specification  in  FOCUS  can  be  documented 
using a number of diagrams. Agents and communication channels 
that  connect  them  are  modeled  with  System  Structure  Diagrams 
(SSD).  Internal  behavior  of  agents  is  represented  using  State 
Transition  Diagrams  (STD).  Sequence  diagrams,  which  are  used 
to represent how a protocol session is run, are shown as extended 
Event  Traces  Diagrams  (EET).  Finally,  types  of  messages  and 
variables as well as functions are declared as Data Type Definition 
(DTD) specifications. 
The biggest challenge which we encountered in the process of the 
protocol  analysis,  was  the  complexity  of  the  resulting  protocol 
specification.  Experiments  with  formalization  and  verification  of 
the  entire  protocol  model  failed.  This  led  to  a  decision  that 
decomposition  of  the  model  is  necessary.  The  TSC  protocol  was 
divided into two parts, as shown in Figure 8. 
The  first  part  –  TSC  Subprotocol  A  -  consists  of  the  first  four 
messages. The objective of Subprotocol A is to have the Signing 
Entity  (SE)  and  Service  Provider  (SP)  successfully  establish 
values of secret keys SM_KEY and SM_KEY_MAC. The second 
part  –  TSC  Subprotocol  B  -  consists  of  the  last  five  messages 
(four,  if  you  do  not  count  communication  with  the  Application 
Provider  at  the  very  end  of  the  session).  The  objective  of 
Subprotocol  B  is  to  provide  the  Application  Provider  (AP)  and 
the SP with a properly signed hash of the document to be signed: 
g(DTBS).  This  goal  is  achieved  with  the  help  of  a  secret  pair  of 
keys:  SM_KEY  and  SM_KEY_MAC  established  as  a  result  of 
Subprotocol  A.  Separate  formal  models  were  created  for  both 
subprotocols.  Then  it  was  proved  in  a  classical,  deductive  way 
that  if  both  subprotocols  are  secure  then  the  whole  scheme  is 
secure as well. 
Specifications for both subprotocols included three active parties: 
two  legitimate  agents  SE  and  SP  and  the  intruder.  AP  was  not 
explicitly  included  in  the  model.  The  role  of  AP  was  taken  into 
account by redirecting the last message of the protocol originally 
intended for him to SE. This modification allowed us to limit the 
complexity of the resulting specification. At the same time it was 
proven that the transformation was secure, which means it did not 
influence  the  results  of  model  verification.  The  specification  of 
TSC agents is shown in Figure 10. 
Figure  10.  Simplified  formal  model  of  the  communication 
parties of the protocol 
the 
intruder 
is  modeled  by 
For  both  subprotocols 
two 
subcomponents: Fake-Store and Overhear as shown in Figure 11. 
The  first  component 
is  responsible  for  storing  messages, 
performing  analyses,  and  creating  faked  messages  based  on  the 
acquired  knowledge.  The  second  component  models  the  control 
intruder  has  over  the  network,  his  ability  to  capture  messages  or 
introduce  messages  from  Fake-Store  into  the  network.  Such  a 
model is consistent with the mathematical definition of the Dolev-
Yao intruder. 
Figure 11. Formal model of the intruder 
The  next  step  was  to  create  a  state  diagram  for  each  FOCUS 
component (agents and the intruder). Our model permitted only a 
single  protocol  session  between  SE  and  SP  and  one  session 
83
between SP and the intruder acting as a dishonest user. However 
it was proved that this assumption would not influence the results 
of model verification. 
4.3  Verification and results 
Properties  of  our  formal  models  of  the  TSC  protocol  were 
analyzed  using  a  model  checker.  For  Subprotocol  A,  formal 
showed  that  both  halves  of  the  two  secret  keys:  SM_KEY  and 
SM_KEY_MAC  generated  by  the  SE  and  SP  are  exchanged and 
authenticated correctly and their secrecy is not compromised.  
The objective of formal verification of Subprotocol B was to show 
that  secret  values  of  SE’s  PIN  and  the  session  key  SK  are  not 
intercepted  and  that  every  message  accepted  by  the  AP  agent 
contains  a  legitimate  signed  document  hash  issued  by  SE. 
However,  a  potential  flaw  was  discovered  in  the  protocol.  The 
protocol  has  an  anomaly  which  arguably  allows  the  intruder  to 
intercept user’s PIN number. 
The attack can be performed in the following way: 
• 
The intruder intercepts and stores message five from the 
session 
– 
{PIN}{SK},{SK}{PK_AUT(SP)}. 
between 
and 
SE 
SP 
•  He repeats the captured message during his own session 
as a legitimate user. 
•  As  a 
the 
reply, 
receives  a  message 
{PIN}{SM_KEY_A},  where  SM_KEY_A  is  a  secret 
key known only by SP and the intruder. 
intruder 
• 
From  this  message  PIN  is  retrieved  as  the  intruder 
knows SM_KEY_A. 
The  protocol  has  an  anomaly  because  one  of  rules  of  robust 
protocol  design  was  broken  i.e.  every  message  should  be 
cryptographically  linked  with  one  or  more  other  messages  in  the 
same  session.  Message  5  is  open  to  a  simple  replay  attack.  An 
example solution to this problem could be to include TRANS_ID 
in  the  fifth  message  encrypting  it  with  the  session  key  SK 
alongside the PIN. 
It  is  worth  mentioning  that  analysis  of  the  same  protocol 
conducted using CSP/Casper and reported in [22] discovered the 
same anomaly. The issue was corrected by the protocol designers. 
No  further  anomalies  were  discovered  in  any  of  the  other 
protocols designed for the distributed digital signatures system. 
5.  PBK Case Study 
The  subject  of  this  case  study  was  analysis  of  the  Purpose-Built 
Keys  (PBK)  protocol.  Our  objective  was  to  take  a  protocol  that 
we  know  has  at  least  one  vulnerability,  analyze  it  using  our 
framework and at least two different formal methods and compare 
the  results.  An  additional  requirement  was  that  original  design 
documentation must be available for the protocol, and not just an 