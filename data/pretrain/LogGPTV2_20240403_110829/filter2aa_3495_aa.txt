July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Max Bazaliy 
Jailbreaking 
Apple Watch 
July 27-30, 2017  
whoami 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
o  Security researcher at Lookout 
o  Lead researcher on Pegasus exploit chain 
o  Focused on advanced exploitation techniques 
o  Fried Apple team co-founder 
o  iOS/tvOS/WatchOS jailbreak author 
July 27-30, 2017  
o  Released in 2015%
o  Apple S1/S2%processor 
o  ARMv7k 32 bit architecture 
o  512 MB RAM 
o  WatchOS 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
What is Apple Watch ? 
July 27-30, 2017  
o  Its fun J 
o  Access to sensitive user data 
o  Run tools like radare or frida on a watch 
o  iPhone attack vector 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Why to pwn a watch? 
July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Apple Watch security 
o  Secure boot chain 
o  Mandatory Code Signing  
o  Sandbox 
o  Exploit Mitigations 
o  Secure Enclave Processor (2-nd generation only)  
o  Data Protection 
July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Possible attack vectors 
o  Malformed USB descriptor (cable required) 
o  Malformed email, message, photo, etc 
o  Application extension based 
July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Attack plan 
o  Leak kernel base 
o  Dump whole kernel 
o  Find gadgets and setup primitives 
o  Disable security restrictions 
o  Run ssh client on a watch 
July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Bugs of interest 
o  CVE-2016-4656%- osunserialize bug 
o  CVE-2016-4669%- mach_port register 
o  CVE-2016-7644%- set_dp_control_port 
o  CVE-2017-2370%- voucher extract recipe 
July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Leaking kernel slide 
o  CVE-2016-4655%and CVE-2016-4680%
o  Object constructor missing bounds checking 
o  OSNumber object with high number of bits 
o  Object length used to copy value from stack 
o  Kernel stack memory leaked 
o  Can be triggered from an app’s sandbox 
July 27-30, 2017  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
OSObject * OSUnserializeBinary(const char *buffer, size_t bufferSize,  
 OSString **errorString) { 
uint32_t key, len, wordLen; 
len = (key & kOSSerializeDataMask); 
...  
case kOSSerializeNumber: 
                bufferPos += sizeof(long long); 
                if (bufferPos > bufferSize) break; 
                value = next[1]; 
                value unsigned64BitValue(); 
 len = off->numberOfBytes();
 bytes = &offsetBytes;  
... 
if (bytes) { 
 if( *dataCnt  code exec 
o  Problem: kernel dump required 
o  Bonus: we can deref any address via fake vtable 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
OSObject * OSUnserializeBinary(const char *buffer, size_t bufferSize, …) { 
newCollect = isRef = false; 
... 
case kOSSerializeDictionary: 
       o = newDict = OSDictionary::withCapacity(len); 
       newCollect = (len != 0); 
       break; 
... 
        if (!isRef) 
        { 
          setAtIndex(objs, objsIdx, o); 
            if (!ok) break; 
            objsIdx++; 
        } 
  Save object to objs array 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
 if (dict) { 
            if (sym) 
             … 
            else { 
                sym = OSDynamicCast(OSSymbol, o); 
                if (!sym && (str = OSDynamicCast(OSString, o))) { 
                    sym = (OSSymbol *) OSSymbol::withString(str); 
                    o->release(); 
                    o = 0; 
                } 
                ok = (sym != 0); 
            } 
        } 
case kOSSerializeObject: 
                if (len >= objsIdx) break; 
                o = objsArray[len]; 
                o->retain(); 
                isRef = true; 
                break; 
 Object saved to objs array destroyed 
Deallocated object retained 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
o  No WatchOS kernel dumps in public 
o  No keys for WatchOS 2.x kernels 
o  Idea: read kernel as OSString chunks 
o  vtable offset required to fake OSString 
o  vtable stored in __DATA.__const in kernel 
Dumping kernel as OSString 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
Getting vtable - __DATA.__const leak 
o  __DATA.__const address is in Mach-O header 
o  Kernel base + 0x224 == __DATA.__const  
o  Deref and branch address via fake vtable 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
Getting vtable - known offset 
o  Get vtable offset from similar XNU build 
o  Known  delta from __DATA.__const start 
o  Tune address with +/- delta 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
Getting vtable - known offset 
o  Get vtable offset from similar XNU build 
o  Known  delta from __DATA.__const start 
o  Tune address with +/- delta 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
Getting vtable – OSString layout 
OSString::~OSString().
OSObject::getRetainCount().
OSObject::release(int).
OSObject::retain().
OSObject::release().
vtable.ptr.+.0x8.
retain.count.
ﬂags.
length.
string.ptr.
vtable.ptr.+.0x8.
retain.count.
ﬂags.
length.
string.ptr.
OSString::~OSString().
OSObject::getRetainCount().
OSObject::release(int).
OSObject::retain().
OSObject::release().
0x0.
0x4.
0x8.
0xC.
0x10.
0x0.
0x8.
0x10.
0x18.
0x0.
0x4.
0x8.
0xC.
0x10.
0x0.
0x8.
0x10.
0x18.
0x20.
OSString 32 bit 
OSString 64 bit 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
OSString layout 
OSString vtable pointer 
OSObject::retain() offset 
32%
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
o  vtable ptr is first 8 bytes of a on object 
o  OSString size is 0x20 (64 bit) 
o  retain() off is vtable start + 0x20 (64 bit) 
o  Next node ptr as deallocated object vtable 
o  Idea - retain() OOB to next node in freelist 
o  If next node is OSString – branch object vtable 
Getting vtable – next free node trick 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
kalloc.32 freelist 
Next node pointer 
32%
Freelist head 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
July 27-30, 2017  
o  Heap spray OSString objects  
o  Make dozen OSDictionaries with OSString 
o  Trigger OSDictionary deallocation 
o  retain() -> deref next free chunk pointer 
o  Free chunk is surrounded by OSStrings 
o  retain() ->%OOB branch to next OSString node 
Getting vtable – next free node trick 
13 
14 
15 
16 
17 
18 
19 
20 
21 