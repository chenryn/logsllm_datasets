# Computational Soundness for Key Exchange Protocols with Symmetric Encryption

**Authors:**
- Ralf Küsters, University of Trier, Germany
- Max Tuengerthal, University of Trier, Germany

## Abstract
Formal analysis of security protocols using symbolic models has proven highly effective in identifying flaws and verifying the security of published protocols. A critical question is whether such formal analyses provide strong security guarantees in the context of modern cryptography. This question was first addressed by Abadi and Rogaway, leading to numerous positive results demonstrating the so-called computational soundness of formal analysis. However, achieving computational soundness for key exchange protocols that use symmetric encryption, especially in the presence of active adversaries, remains a significant challenge.

In this paper, we present the first general computational soundness result for key exchange protocols with symmetric encryption, building on the work of Canetti and Herzog on protocols with public-key encryption. Specifically, we develop a symbolic, automatically checkable criterion based on observational equivalence and show that a key exchange protocol satisfying this criterion realizes a key exchange functionality in the sense of universal composability. Our results hold under standard cryptographic assumptions.

**Categories and Subject Descriptors:**
- C.2.2 [Computer-Communication Networks]: Network Protocols—Protocol Verification
- C.2.0 [Computer-Communication Networks]: Security and Protection

**General Terms:**
- Security, Verification

## 1. Introduction
Formal analysis of security protocols using symbolic models, also known as Dolev-Yao models, has been highly successful in identifying flaws and proving the security of published protocols. This success is due to the relative simplicity and rich tool support available, ranging from finite state model checking to general-purpose theorem provers. However, a crucial question is whether the results obtained in these symbolic models can be translated into the realm of modern cryptography, which employs strong security notions.

Initiated by the seminal work of Abadi and Rogaway, the computational soundness problem has attracted considerable attention, resulting in many positive outcomes. However, establishing computational soundness for protocols with symmetric encryption in the presence of active adversaries remains challenging. Most results for symmetric encryption assume passive or at most adaptive adversaries, while results for active adversaries typically focus on asymmetric cryptography, such as public-key encryption and digital signatures. One reason for this difficulty is that, unlike private keys in asymmetric settings, symmetric keys may "travel" between parties and some of these keys may be dishonestly generated by the adversary. The behavior of encryption and decryption under dishonestly generated keys is almost arbitrary, making it hard to map to the symbolic setting, as cryptographic definitions do not consider such keys.

The goal of this work is to achieve computational soundness for protocols that use symmetric keys in the presence of active adversaries, under standard cryptographic assumptions. Specifically, our contributions are as follows:

### Contribution of this Paper
1. **Symbolic Protocol Class:** We propose a class of symbolic key exchange protocols based on the applied pi calculus, incorporating pairing, symmetric encryption, nonces, and branching via general if-then-else statements. These protocols have a straightforward computational interpretation, requiring only minimal tagging (primarily for pairs and keys). We use the IITM model, a simulation-based security model, as our computational model. This model is similar to Canetti's UC model but is more suitable for our purposes due to certain technical issues in the UC model.

2. **Computational Soundness Criterion:** For our main result, we develop a natural symbolic criterion for key exchange protocols. This criterion requires:
   - Observational equivalence between the symbolic key exchange protocol and its randomized version, where a freshly generated key is output instead of the actual session key.
   - All keys used within one session of the key exchange protocol remain secret if the session is uncorrupted.

   The first condition is the symbolic counterpart of cryptographic key indistinguishability, while the second condition ensures that keys in an uncorrupted session do not become known to the adversary. This second condition enables us to handle dishonestly generated keys, unlike previous work. The symbolic criterion is simple to check using automatic tools.

3. **Main Result:** If a symbolic key exchange protocol satisfies our symbolic criterion, then its computational interpretation realizes a key exchange functionality in the sense of universal composability. This provides a strong security guarantee, implying that polynomially many concurrent copies of the protocol can be securely used in any probabilistic polynomial-time environment. Our result holds for any symmetric encryption scheme that guarantees authenticated encryption (IND-CPA and INT-CTXT security).

4. **Proof Strategy:** We first prove the computational soundness result for the case where symmetric encryption is performed using an ideal functionality for symmetric encryption with short- and long-term keys. We then replace this functionality with its realization using the composition theorem. This step requires that the protocol does not produce key-cycles and does not cause the commitment problem. We provide symbolic, automatically checkable criteria for these properties.

### Structure of the Paper
- **Section 2:** We review the applied pi calculus.
- **Section 3:** We introduce the class of symbolic key exchange protocols.
- **Section 4:** We present the computational model, the IITM model.
- **Section 5:** We discuss the ideal functionalities used in our work.
- **Section 6:** We introduce the computational interpretation of the symbolic protocol.
- **Section 7:** We present the main result, with a proof sketch in Section 8.
- **Section 9:** We conclude with a discussion of related work.

Full definitions and proofs can be found in our technical report [27].

## 2. The Symbolic Model
Our symbolic model is an instance of the applied π-calculus, similar to the one in [15].

### 2.1 Syntax
Let Σ be a finite set of function symbols, the signature. The set of terms T(N, X) over Σ and infinite sets N and X of names and variables, respectively, is defined as usual. The set of ground terms, i.e., terms without variables, is T(N).

In this paper, we consider the signature Σ = {(·,·), π1(·), π2(·), {·}·, dec(·,·), sk(·)}, where (t1, t2) is the pairing of the terms t1 and t2, π1(t) and π2(t) are the projections to the first and second component of t (in case t is a pair), {t}r_k stands for the ciphertext obtained by encrypting t under the key k using randomness r, dec(t, k) is the plaintext obtained by decrypting t with k (in case t is a ciphertext under k), and sk(k) is used to tag symmetric keys.

Accordingly, Σ is associated with the following equational theory E: π1((x, y)) = x, π2((x, y)) = y, dec({x}z_y, y) = x. We denote by =E the congruence relation on terms induced by E. A term t is reduced or in normal form if it is not possible to apply one of the above equations from left to right. Every term has a unique normal form.

We also consider the following predicate symbols over ground terms, which may be used in if-then-else statements in processes:
1. M is a unary predicate such that M(t) is true if the normal form of t does not contain π1(·), π2(·), and dec(·,·), and for every subterm of t of the form {t1}t3_t2, there exists t2' such that t2 =E sk(t2').
2. EQ is a binary predicate such that EQ(s, t) is true if s =E t, M(s), and M(t).
3. Ppair is a unary predicate such that Ppair(t) is true if t is a pair, i.e., t =E (t1, t2) for some terms t1, t2.
4. Penc is a unary predicate such that Penc(t) is true if t is a ciphertext, i.e., t =E {t1}t3_t2 for some terms t1, t2, t3.
5. Pkey is a unary predicate such that Pkey(t) is true if t is a key, i.e., t =E sk(t') for some term t'.

For example, the predicates M(tex) and EQ(tex, b) are true, while M(π1({a}r_k)) is false. These predicates can be encoded in ProVerif [9, 11].

We call M(t), EQ(s, t), Ppair(t), Penc(t), Pkey(t) for terms s and t (possibly with variables) atoms. A condition φ is a Boolean formula over atoms. If φ contains only ground terms, the truth value of φ is defined in the obvious way. If φ holds true, we write |= φ.

Now, (plain) processes P, Q and extended processes A, B are defined in Figure 1. There should be at most one active substitution for a variable, and the set of active substitutions should be cycle-free, e.g., {x → x} is not allowed. Extended processes extend plain processes by what is called a frame. A frame ϕ is of the form (νn)σ, where σ denotes a substitution, i.e., a set {x1 → s1, ..., xl → sl}, and n is a name.

**Figure 1: Syntax of Processes**

- P, Q ::= c(x).P | c〈s〉.P | 0 | P || Q | (να)P | !P
  - input
  - output
  - terminated process
  - parallel composition
  - restriction
  - replication
  - conditional: if φ then P else Q

- A, B ::= P | A || B | (να)A | {x → s}
  - (plain) process
  - parallel composition
  - restriction
  - active substitution

This structure and syntax provide a foundation for the symbolic analysis of key exchange protocols, enabling the development and verification of secure communication systems.