# Practical Proactive Integrity Preservation: A Basis for Malware Defense

**Authors:**  
Weiqing Sun, R. Sekar, Gaurav Poothia, Tejas Karandikar  
Department of Computer Science, Stony Brook University, Stony Brook, NY 11794

**Abstract:**
Unlike current reactive approaches, information flow-based methods can provide positive assurances about overall system integrity, thereby defending against sophisticated malware. However, these techniques have not been widely successful in modern desktop systems due to the strict application of information flow policies, which can break existing applications and operating system (OS) services. Additionally, policy development is challenging, requiring the specification of integrity labels for a large number of system objects. This paper introduces a new approach for proactive integrity protection that decouples integrity labels from access policies. We also develop an analysis method to automate the generation of integrity labels and policies, ensuring the usability of most applications while preventing various sophisticated malware attacks. Our prototype implementation on a Linux desktop distribution demonstrates that it does not disrupt or inconvenience the use of most applications while effectively stopping a variety of sophisticated malware attacks.

## 1. Introduction

Security threats have escalated rapidly over the past few years. Zero-day attacks, delivered through seemingly innocuous means like web pages and documents, have become significant threats. Malware is widespread, often installed on millions of computers via implicit or explicit software downloads from untrusted sources. The rise of cybercrime has led to increasingly stealthy and sophisticated attacks, making it difficult for even the best available defenses to detect and mitigate them.

Current malware defenses primarily rely on reactive approaches such as signature-based scanning, behavior monitoring, and file integrity monitoring. Unfortunately, attackers can easily modify their malware to evade detection by these methods. They may also subvert system integrity monitoring tools using rootkit-like techniques. Therefore, it is necessary to develop proactive techniques that can prevent malware from damaging system integrity.

Sandboxing is a commonly used proactive defense against untrusted and potentially malicious software. It restricts the resources (e.g., files) that untrusted processes can write to and limits communication with other processes. However, regulating write-access without restricting read-access is insufficient to address adaptive malware threats. Specifically, sandboxing does not adequately address indirect attacks where a benign application consumes malware outputs stored in persistent storage (e.g., files).

For example, malware can modify:
- **System libraries, configuration files, or scripts**: Preventing untrusted software from storing files in system directories can preclude the use of many legitimate applications. Alternatively, explicitly enumerating all files in system directories used by benign applications is challenging, given the large number of such files (over 100K in a typical Linux distribution). Errors in such enumerations can introduce opportunities for indirect attacks.
- **User-specific customization files and scripts**: Identifying all user-specific scripts and customization files is even more difficult, as different applications use different conventions for their locations. Some files may load other user files or run scripts within user directories, making static identification very hard.
- **Data files**: Malware can create data files with malicious content that exploit vulnerabilities in benign software. When a user opens such a file, the benign viewer can be compromised, allowing the malware to achieve its objectives using the viewer's privileges.

In contrast, our approach, called Practical Proactive Integrity (PPI), aims to provide positive assurance about overall system integrity. PPI identifies a subset of objects (typically files) as integrity-critical and a set of untrusted objects. System integrity is preserved as long as untrusted objects are prevented from influencing the contents of integrity-critical objects, either directly or indirectly through intermediate files. In other words, there should be no information flow from untrusted objects to integrity-critical objects.

Although information-flow-based integrity preservation techniques, such as the Biba integrity model, have existed for a long time, they have not been practical in modern operating systems like Windows and Linux. This is due to the cumbersome task of labeling every object and the inflexibility of the approach, which often breaks many applications. To overcome these issues, we have developed a practical information-flow-based integrity protection for desktop Linux systems by:
- Automating the development of integrity labels and policies.
- Providing a degree of assurance that these labels and policies protect system integrity.
- Developing a flexible framework that supports contemporary applications while minimizing usability problems and the need to designate applications as "trusted."

Our experiments on a modern Linux workstation OS, with numerous benign and untrusted applications, show that our technique preserves system usability while thwarting sophisticated malware.

### 1.1. Goals of the Approach
- **Provide positive assurances about system integrity** on a contemporary workstation, such as a Linux CentOS/Ubuntu desktop, even if untrusted programs run with root privileges.
- **Effectively block rootkits and most other malware**. Most malware, including rootkits and spyware, should be detected and removed automatically when they attempt to install themselves. Stealthier malware should be detected and removed when they attempt to damage system integrity.
- **Be easy to use** for end-users and system administrators. Usability includes:
  - Preserving the availability of benign applications.
  - Minimizing administrator effort by automating the development of file labels and integrity policies.
  - Eliminating user prompts, as frequent security decisions from users can lead to fatigue and social engineering attacks.
- **Reduce reliance on trusted applications** to provide better overall assurance.

### 1.2. Salient Features
- **Flexible decomposition of high-level policies into low-level policies**: Traditional information-flow-based integrity models, like the Biba model, associate a fixed label with an object at creation, which defines the access policies. In contrast, PPI distinguishes between labels, which judge the trustworthiness of an object, and policies, which state whether certain read or write access should be permitted. This allows integrity levels to change over the lifetime of objects and subjects, providing flexibility in developing low-level policies that preserve system integrity without impacting usability.
- **Automated analysis for generating enforceable policies**: Given the large number of objects and subjects, manual setting of policies is impractical. We develop techniques that use an analysis of access patterns observed on an unprotected system to automatically derive policies. This analysis can also complete the set of integrity-critical applications starting from a partial list provided by a policy developer. Our technique is sound, ensuring system integrity even if the access logs are compromised by malicious applications.
- **A flexible enforcement framework**: Our enforcement framework consists of a small, security-critical component in the OS kernel and a user-level component that incorporates complex features to enhance functionality without compromising security. This framework also includes features for learning and synthesizing policies for new applications.
- **Mechanisms for limiting trust**: High-integrity applications sometimes need to access low-integrity files. We develop techniques to restrict such exceptions, typically distinguishing between code/configuration inputs and data inputs, and ensuring that exceptions are made only for data inputs. This limits the trust placed on important applications like software installers, web browsers, and file utilities.

We have implemented our technique on desktop systems running RedHat/Ubuntu Linux, consisting of several hundred benign software packages and a few tens of untrusted packages. Our evaluation shows that the approach is practical, does not impose significant usability problems, and is effective in preventing the installation of most malware packages and detecting (and blocking) malicious actions performed by stealthy malware.

## 2. Policy Framework

### 2.1. Trust and Integrity Levels
Figure 1 illustrates the integrity and trust levels used in our framework. For simplicity, we use two integrity levels: high and low. Integrity labels are associated with all system objects, including files, devices, and communication channels. A subset of high-integrity objects is identified as integrity-critical, which provides the basis for defining system integrity:

**Definition 1 (System Integrity):** System integrity is preserved as long as all integrity-critical objects have high integrity labels.

The set of integrity-critical objects is specified by a system administrator or an OS distribution developer. It is important to note that the integrity-critical list does not need to be comprehensive. If objects are left out, our technique will automatically detect them using the analysis described in Section 3, as long as these objects are accessed after the kernel module enforcing PPI policies has begun execution. On Linux, the minimal set of integrity-critical objects includes all files within `/boot`, the binaries used by `init`, and the files used by PPI.