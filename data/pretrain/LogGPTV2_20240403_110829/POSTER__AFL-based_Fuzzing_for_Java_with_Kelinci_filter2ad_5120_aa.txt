title:POSTER: AFL-based Fuzzing for Java with Kelinci
author:Rody Kersten and
Kasper Søe Luckow and
Corina S. Pasareanu
POSTER: AFL-based Fuzzing for Java with Kelinci∗
Carnegie Mellon University Silicon
Carnegie Mellon University Silicon
Carnegie Mellon University Silicon
Kasper Luckow
Corina S. Păsăreanu
Rody Kersten
Valley
Moffett Field, California
PI:EMAIL
Valley
Moffett Field, California
PI:EMAIL
Valley
NASA Ames Research Center
Moffett Field, California
PI:EMAIL
ABSTRACT
Grey-box fuzzing is a random testing technique that has been shown
to be effective at finding security vulnerabilities in software. The
technique leverages program instrumentation to gather information
about the program with the goal of increasing the code coverage
during fuzzing, which makes gray-box fuzzers extremely efficient
vulnerability detection tools. One such tool is AFL, a grey-box fuzzer
for C programs that has been used successfully to find security vul-
nerabilities and other critical defects in countless software products.
We present Kelinci, a tool that interfaces AFL with instrumented
Java programs. The tool does not require modifications to AFL and
is easily parallelizable. Applying AFL-type fuzzing to Java programs
opens up the possibility of testing Java based applications using
this powerful technique. We show the effectiveness of Kelinci
by applying it on the image processing library Apache Commons
Imaging, in which it identified a bug within one hour.
CCS CONCEPTS
• Software and its engineering → Software testing and de-
bugging; Dynamic analysis; • Security and privacy → Software
and application security;
KEYWORDS
AFL, Fuzzing, Random Testing, Java
ACM Reference Format:
Rody Kersten, Kasper Luckow, and Corina S. Păsăreanu. 2017. POSTER:
AFL-based Fuzzing for Java with Kelinci. In Proceedings of CCS ’17, Dallas,
TX, USA, October 30-November 3, 2017, 3 pages.
https://doi.org/10.1145/3133956.3138820
1 INTRODUCTION
Fuzz testing [6, 10] is an automated testing technique that is used
to discover security vulnerabilities and other bugs in software.
In its simplest, black-box, form, a program is run on randomly
∗This material is based on research sponsored by DARPA under agreement number
FA8750-15-2-0087. The U.S. Government is authorized to reproduce and distribute
reprints for Governmental purposes notwithstanding any copyright notation thereon.
The views and conclusions contained herein are those of the authors and should not
be interpreted as necessarily representing the official policies or endorsements, either
expressed or implied, of DARPA or the U.S. Government.
CCS ’17, October 30-November 3, 2017, Dallas, TX, USA
2017. This is the author’s version of the work. It is posted here for your personal use.
Not for redistribution. The definitive Version of Record was published in Proceedings
of CCS ’17, October 30-November 3, 2017, https://doi.org/10.1145/3133956.3138820.
generated or mutated inputs, in search of cases where the pro-
gram crashes or hangs. More advanced, white-box, fuzzing tech-
niques leverage program analysis to systematically increase code
coverage during fuzzing [2, 5, 9]. Grey-box fuzzers leverage pro-
gram instrumentation rather than program analysis to gather in-
formation about the program paths exercised by the inputs to
increase coverage. An extensive list of tools can be found here:
https://github.com/secfigo/Awesome-Fuzzing#tools. Popular tools
available for Java include EvoSuite [3] and Randoop [7].
1.1 AFL
American Fuzzy Lop (AFL) is a security-oriented grey-box fuzzer
that employs compile-time instrumentation and genetic algorithms
to automatically discover test cases that trigger new internal states
in C programs, improving the functional coverage for the fuzzed
code [11]. AFL has been used to find notable vulnerabilities and
other interesting bugs in many applications and has helped make
countless non-security improvements to core tools. For example,
AFL was instrumental in finding several of the Stagefright vulnera-
bilities in Android, the Shellshock related vulnerabilities CVE-2014-
6277 and CVE-2014-6278, Denial-of-Service vulnerabilities in BIND
(CVE-2015-5722 and CVE-2015-5477), as well as numerous bugs
in (security-critical) applications and libraries such as OpenSSL,
OpenSSH, GnuTLS, GnuPG, PHP, Apache, IJG jpeg, libjpeg-turbo
and many more.
It supports programs written in C, C++, or Objective C, compiled
with either GCC or Clang. On Linux, the optional QEMU mode
allows black-box binaries to be fuzzed, too. There are variants and
derivatives of AFL that allow fuzzing of Python, Go, Rust, OCaml,
etc.—yet there is no support for Java programs. The only effort
that we are aware of uses the GNU Compiler for Java (GCJ), a free
compiler for the Java programming language, that was meant to
compile Java source code to machine code for a number of CPU
architectures. However, it is no longer maintained [4]. In this paper,
we present Kelinci1, which addresses this gap. We demonstrate
the effectiveness of the tool by applying it to the image processing
library, Apache Commons Imaging, where it found a bug within
one hour of analysis.
2 KELINCI
Inspired by the success of AFL we developed Kelinci, with the goal
of applying AFL-style fuzzing to Java based applications. Kelinci
provides an interface to execute AFL on Java programs. It adds AFL-
style instrumentation to Java programs and communicates results
back to a simple C program that interfaces with the AFL fuzzer.
1Kelinci means rabbit in Indonesian, the language spoken on the Java island.
CCS ’17, October 30-November 3, 2017, Dallas, TX, USA
Rody Kersten, Kasper Luckow, and Corina S. Păsăreanu
memory plus error status) once the run is done, writes results to
shared memory and crashes if the Java program resulted in an
exception escaping the main method.
For a given input file generated by the fuzzer, the interaction
between the C and Java sides is as follows:
Figure 1: Overview of the design of Kelinci.
It does not require any modifications to AFL, but instead behaves
exactly as a C program that was instrumented by one of AFL’s
compilers. The tool is available at https://github.com/isstac/kelinci.
The overall design of Kelinci is depicted in Fig. 1. The first
step when applying the tool is to add AFL-style instrumentation
to a Java program. AFL uses a 64 kB region of shared memory for
communication with the target application. Each basic block is
instrumented with code that increments a location in the shared
memory bitmap corresponding to the branch made into this basic
block.
The Java version of this instrumentation is the following:
Mem.mem[id^Mem.prev_location]++;
Mem.prev_location = id >> 1;
In this example, the Mem class is the Java representation of the
shared memory and also holds the (shifted) id of the last program
location. The id of a basic block is a compile-time random integer,
where 0 ≤ id < 65536 (the size of the shared memory bitmap). The
idea is that each jump from a block id1 to a block id2 is represented
by a location in the bitmap id1 ⊕ id2. While obviously there may
be multiple jumps mapping to the same bitmap location, or even
multiple basic blocks which have the same id, such loss of precision
is considered rare enough to be an acceptable trade-off for efficiency.
The reason that the id of the previous location is shifted is that,
otherwise, it would be impossible to distinguish a jump id1 → id2
from a jump id2 → id1. Also, tight loops would all map to the
location 0, as id ⊕ id = 0 for any id.
Instrumentation is added to the program using the ASM byte-
code manipulation framework [1]. Basic blocks are instrumented
as described, the Mem class is added, as well as a TCP server compo-
nent, which handles communication with the C side and execution
of the target application on incoming files.
AFL expects two pieces of information from an instrumented
application. First, the application should be running a fork server,
which responds to requests from the fuzzer to fork the process
and run the forked process on the provided input file. Second,
the application is expected to connect to the shared memory and
write to locations corresponding to branches in the program. The
interface.c component implements a fork server that is identical
to the one in programs instrumented by an AFL compiler. When
a request to fork comes in, it creates a fork of itself that sends
the provided file over to the Java side, receives the result (shared