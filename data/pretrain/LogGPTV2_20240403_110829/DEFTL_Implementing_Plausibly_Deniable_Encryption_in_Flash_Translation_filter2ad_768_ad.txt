quirement for a hidden volume-based PDE (Sec. 2.3) is that the
entire storage medium must be (cid:27)lled with cryptographically secure
random data, which will be used to deny the existence of hidden
sensitive data. However, all the existing hidden volume-based PDE
schemes for mobile devices [6, 33, 34, 44] can only (cid:27)ll the (cid:30)ash
medium with randomness using a block-based access interface.
This however, is not able to ensure that all the physical (cid:30)ash blocks
will be (cid:27)lled with randomness (Sec. 3.1.3). DEFTL works in the FTL
layer and can have direct access to the raw (cid:30)ash. Therefore, we can
simply (cid:27)ll each physical (cid:30)ash block with randomness, which can
be generated by taking advantage of random telegraph noise [40].
Initializing the public and the hidden volume. We create a
public volume across the entire (cid:30)ash, to store all the public non-
sensitive data. The corresponding public volume metadata (i.e., the
mapping table and the dirty block table) will be encrypted using
the decoy key and stored in a few (cid:30)ash blocks, and this location
information will be kept in the root table. The root table, the bad
block table, and the erasure count table will be stored in the (cid:30)ash
blocks reserved at the beginning of the (cid:30)ash medium. The mapping
table is empty and can be (cid:27)lled with “0” initially, and the dirty
block table should include all the (cid:30)ash blocks except the reserved
blocks. Note that the dirty block table will organize the blocks
according to the count of valid pages in each block in an increasing
order. The entire public volume will be encrypted using the decoy
key. A portion of (cid:30)ash blocks are used to create a hidden volume,
which will be encrypted using the true key. The corresponding
hidden volume metadata (i.e., the mapping table and the dirty block
table, which are empty and can be (cid:27)lled with “0” initially) will be
encrypted by the true key and stored in a few (cid:30)ash blocks (see
Sec. 5.5) belonging to the hidden volume. Without obtaining the
true key, the adversary is not able to identify the existence of the
hidden volume and its metadata since they cannot be di(cid:29)erentiated
from the randomness (cid:27)lled by DEFTL. A storage layout of DEFTL
is shown in Figure 3.
5.4 Public Mode
The public mode is used to manage the public volume, which stores
the regular non-sensitive data that can be disclosed to the adver-
sary (i.e., public data). In the following, we elaborate several key
operations in this mode, including public volume mounting, block
allocation, and garbage collection. These operations incorporate our
design considerations for deniability purpose. Note that we neglect
other regular operations (e.g., bad block management, public block
unmounting), since no special designs need to be incorporated to
them to achieve deniability.
Session J4:  Flash SecurityCCS’17, October 30-November 3, 2017, Dallas, TX, USA2223Figure 3: A storage layout of DEFTL
Mounting the public volume. The public volume is encrypted
by a decoy key, which can be derived from a decoy password using
a key derivation function (e.g., PBKDF2 [19]). During booting, the
user enters the decoy password to activate the public mode. Using
the decoy password, DEFTL can derive the decoy key and use the
decoy key to decrypt the public volume metadata, which can be
localized by reading the root table. If the password is the correct
decoy password, the decryption will be successful1; otherwise, the
system aborts from mounting the public volume. Using the mapping
table of the public volume, the blocks for the public volume can
be localized, and the entire public volume will be decrypted and
mounted. Note that during this mounting process, all the (cid:30)ash
blocks which store data/metadata of the hidden volume cannot
be localized and decrypted. This can prevent the adversary from
identifying the existence of the hidden volume. In addition, from
the view of upper layer, the public volume appears as a regular
block device, which can be used to deploy any block-based (cid:27)le
systems (e.g., EXT4, FAT32). This (cid:27)le system friendliness [6] is an
“unexpected” bene(cid:27)t of DEFTL.
Block allocation. In the public mode, DEFTL allocates (cid:30)ash blocks
for the new writes according to the public volume dirty block ta-
ble. Note that the dirty block table stores the count of valid pages
for each (cid:30)ash block, and organizes the blocks according to their
counts in an increasing order. When new write requests have been
received and new blocks need to be allocated, DEFTL selects the
free blocks from the head of the dirty block table (Figure 4). By
smartly manipulating the dirty block table of the public volume,
DEFTL ensures that it is more likely the blocks in state A will be
allocated (see Sec. 5.5), rather than the blocks in state B, which store
the hidden sensitive data. A free block being allocated needs to be
erased if it has not yet been erased before.
As it is shown in Figure 5, the free blocks being allocated will be
used to store valid public data, turning to state D (arrow 1 in Fig-
ure 5). The blocks in state D may then be updated/deleted, turning
to state C (arrow 2 in Figure 5).
Garbage collection. In the public mode, both the blocks in state
A and the blocks in state B are viewed as free blocks and can be
allocated for storing new data. In other words, once the blocks in
state A have been completely used, the blocks in state B will be
allocated, leading to data lost in the hidden volume. It seems that
the over-write issue cannot be completely addressed for the hidden
1This can be easily veri(cid:27)ed by embedding a few known symbols at the beginning of
the metadata.
Figure 4: The dirty block table of the public volume
Figure 5: Block state transition in the public mode
volume-based PDEs [6, 33, 34, 44], since the hidden volume is part
of the public volume. DEFTL further mitigates this issue by tuning
the garbage collection strategy. Speci(cid:27)cally, DEFTL performs an
active garbage collection over those blocks in state C to reclaim the
space occupied by the invalid pages. When the number of invalid
pages in a block in state C reaches a certain threshold, DEFTL will
copy the valid data from this block to a block in state D. After all
the pages in this block are invalidated, it will turn to state A (arrow
3 of Figure 5). Correspondingly, it will be relocated to the head of
dirty block table (Figure 4).
5.5 PDE Mode
The PDE mode is used to manage the hidden volume, which stores
the sensitive data whose existence needs to be denied. In the fol-
lowing, we elaborate several key operations in this mode, including
hidden volume mounting/unmounting, block allocation, garbage
collection, and bad block management. These operations incorpo-
rate our design considerations in the PDE mode for deniability
purpose.
Before elaborating di(cid:29)erent operations, we (cid:27)rst answer a re-
mained question about where to store the hidden volume metadata
(including both the mapping table and the dirty block table). Two
design concerns are: 1) they will not (or very unlikely) be over-
written by the public data; and 2) they can be localized in the PDE
mode. We choose to store them at the last several free blocks in
the dirty block table of the public volume. Note that in the public
mode, the free blocks include blocks in both state A and B. This
solution can address the aforementioned concerns, because: First, it
is very unlikely that the public data will over-write them since the
public mode allocates free blocks from the head of the dirty block
table. Second, they can be localized in the PDE mode by reading the
public volume metadata. Although the adversary may also be able
to localize them. Without the true key, he/she will not be able to
decrypt the blocks storing those metadata, and cannot di(cid:29)erentiate
them from the blocks full of randomness.
A flash blockReserved blocksPublic volume and its metadata (encrypted with the decoy key)Hidden volume and its metadata (encrypted with the true key)CDA,BBlock allocationGarbage collection1  (block allocation)C （valid pages and invalid pages）D (all valid pages)A,B (no valid page)2  (data updated/deleted)3  (garbage collection)Session J4:  Flash SecurityCCS’17, October 30-November 3, 2017, Dallas, TX, USA2224Figure 6: The dirty block table of the hidden volume
Mounting the hidden volume. Hidden volume is encrypted with
a true key, which is derived from a true password using a key
derivation function (e.g., PBKDF2 [19]. During booting, the user
can enter the true password to activate PDE mode. Using the true
password, DEFTL can derive the true key. DEFTL further localizes
the hidden volume metadata, and decrypts them using the true key.
If the decryption is successful (refer to Sec. 5.4 for the approach
about how to check whether the decryption is successful or not),
the true key is correct and the hidden volume can be mounted.
Otherwise, the system aborts from mounting the hidden volume.
Using the mapping table of the hidden volume, the blocks storing
hidden sensitive data (i.e, the blocks in state B) will be localized,
and the entire hidden volume will be decrypted. Note that from
the view of upper layer, the hidden volume appears to be a regular
block device, which can be used to deploy any block-based (cid:27)le
systems.
Block allocation. In the PDE mode, DEFTL allocates blocks ac-
cording to the hidden volume dirty block table. The dirty block
table stores the count of valid pages (i.e., the pages which store
valid hidden data) for the blocks in state A and B, and organizes
those blocks according to their counts in an increasing order. Note
that each time when mounting the hidden volume, DEFTL will
adjust the hidden volume dirty block table according to the public
volume dirty block table, such that the blocks in state A and B will
be exactly the same in both tables. When new sensitive data are
written and new blocks need to be allocated, DEFTL selects free
blocks from the dirty block table from the tail of the blocks in state
A (Figure 6). Excluding blocks in state C and D from the hidden
volume dirty block table is necessary, as it can prevent the hidden
data from over-writing the data stored in the public volume. When
a free block is allocated, it needs to be erased (cid:27)rst if it has not yet
been erased before. When the new data have been written, the map-
ping table/dirty block table need to be updated correspondingly.
Especially for the dirty block table, the blocks should be always
organized according to the count of valid pages in each block in an
increasing order.
We further di(cid:29)erentiate the blocks in state B into two sub-types:
B1 - the blocks which only contain valid hidden data; B2 - the blocks
which contain both valid and invalid hidden data. As it is shown in
Figure 7, the free blocks being allocated will be used to store valid
hidden data, turning to B1 (arrow 4 in Figure 7). The blocks in state
B1 may be updated/deleted, turning to B2 (arrow 5 in Figure 7).
Garbage collection. To ensure an enough amount of blocks in
state A, DEFTL needs to reclaim the space occupied by the invalid
pages from the blocks in state B2. This can be achieved by an active
garbage collection in the PDE mode. Speci(cid:27)cally, when the number
of invalid pages in a B2 block reaches a certain threshold, DEFTL
Figure 7: Block state transition in the PDE mode
will copy the valid data from this block to a B1 block. After all the
valid pages in this victim block are reclaimed, it will turn to state A
(arrow 6 of Figure 7). Correspondingly in the dirty block table, it
will be relocated to the head of the blocks in state A (Figure 6). To
eliminate deniability compromises caused by the garbage collection
(Sec. 3.1.2), DEFTL erases the reclaimed block immediately.
Bad block management. When a (cid:30)ash block is identi(cid:27)ed as “bad”,
DEFTL will replace it using a free block. The valid data from this
bad block will be copied to the free block, and the mapping table
will be updated. To eliminate deniability compromises from bad
block management (Sec. 3.1.2), DEFTL will immediately erase this
bad block [39].
Unmounting the hidden volume. The PDE mode will create a
few blocks in state B, which are unknown to the public mode. There-
fore, the public mode may allocate those blocks to store data written
to the public volume. To reduce this probability, upon unmounting
the hidden volume, DEFTL will modify the dirty block table of the
public volume in the following manner: 1) keep the positions of
the blocks in state C and D unchanged; 2) relocate the positions
of the blocks in state A and B according to the dirty block table of
the hidden volume, so that they are exactly the same in both tables.
Adjusting the public volume dirty block table is to ensure that the
public mode will not use the blocks in state B until all the blocks in
state A have been used, signi(cid:27)cantly reducing the chance of over-
writing. In addition, to avoid deniability compromises (Sec. 3.1.1),
DEFTL will (cid:27)nd out those blocks in state B which have not yet been
fully used, and (cid:27)ll the empty pages in those blocks with random
data. This can ensure that those blocks will be indistinguishable
from blocks truly (cid:27)lled with randomness from the view of the pub-
lic mode. DEFTL also needs to (cid:27)ll those empty pages (i.e., pages
with all “1” bits) in blocks of state A with randomness, to prevent
the amount of randomness from decreasing (Sec. 3.1.3).
5.6 User Steps
To activate the mobile device equipped with a (cid:30)ash-based block
device, the user will enter either the decoy or the true password.
How to di(cid:29)erentiate the decoy and the true password has been
well discussed in the existing hidden volume-based mobile PDE
systems [6, 33, 34, 44]. Note that the user can either memorize the
password, or use a smart card if the password is long and hard
to be memorized. When a password is entered, the bootloader
will inform DEFTL to boot into the corresponding mode. There
are a few reserved command block wrappers (CBW) in the SCSI
command [11], which can be used to pass the commands from the
upper layer to DEFTL.
B2B1ABlock allocationGarbage collectionA (truly free blocks)B1 (all valid pages)B2 (with invalid pages)5  (data updated/deleted)4  (block allocation)6 (garbage collection)Session J4:  Flash SecurityCCS’17, October 30-November 3, 2017, Dallas, TX, USA2225For regular daily use, the user enters the decoy password to
activate the public mode. When storing sensitive data, the user
quits the public mode (i.e., unmounts the public volume and logs
out), and enters the true password. A potential booting-time attack
which may compromise deniability was mitigated by adding dump
operations during password authentication [44]. Note that during
initialization, the user should (cid:27)rst enter the public mode, initial-
ize the public volume metadata, and then enter the PDE mode to