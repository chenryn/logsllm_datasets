匹配，因此会返回一条304 Not Modified响应。
条件请求
GET /announce.html HTTP/1.0
If-None-Match: "v2.6"
ETag:"v 2.6" ETag:"v2.6"
HTTP/1.0 304 Not Modified
缓存 服务器
Date: Wed, 03 Jul 2002, 19:18:23 GMT
ETag: "v2.6"
Expires: Fri, 05 Jul 2002, 05:00:00 GMT
响应
图7-15 因为实体标签仍然匹配，If-None-Match再验证成功 180
如果服务器上的实体标签已经发生了变化（可能变成了v3.0），服务器会在一个200
OK响应中返回新的内容以及相应的新Etag。
可以在If-None-Match首部包含几个实体标签，告诉服务器，缓存中已经存在带
缓 存 ｜ 189
有这些实体标签的对象副本：
If-None-Match: "v2.6"
If-None-Match: "v2.4","v2.5","v2.6"
If-None-Match: "foobar","A34FAC0095","Profiles in Courage"
7.8.7 强弱验证器
缓存可以用实体标签来判断，与服务器相比，已缓存版本是不是最新的（与使用最
近修改日期的方式很像）。从这个角度来看，实体标签和最近修改日期都是缓存验证
器（cache validator）。
有时，服务器希望在对文档进行一些非实质性或不重要的修改时，不要使所有的已
缓存副本都失效。HTTP/1.1支持“弱验证器”，如果只对内容进行了少量修改，就
允许服务器声明那是“足够好”的等价体。
只要内容发生了变化，强验证器就会变化。弱验证器允许对一些内容进行修改，但
内容的主要含义发生变化时，通常它还是会变化的。有些操作不能用弱验证器来实
现（比如有条件地获取部分内容），所以，服务器会用前缀“W/”来标识弱验证器。
ETag: W/"v2.6"
If-None-Match: W/"v2.6"
不管相关的实体值以何种方式发生了变化，强实体标签都要发生变化。而相关实体
在语义上发生了比较重要的变化时，弱实体标签也应该发生变化。
注意，原始服务器一定不能为两个不同的实体重用一个特定的强实体标签值，或者
为两个语义不同的实体重用一个特定的弱实体标签值。缓存条目都可能会留存任意
长的时间，与过期时间无关，有人可能希望当缓存验证条目时，绝对不会再次使用
在过去某一时刻获得的验证器，这种愿望可能不太现实。
7.8.8 什么时候应该使用实体标签和最近修改日期
如果服务器回送了一个实体标签，HTTP/1.1客户端就必须使用实体标签验证器。如
果服务器只回送了一个Last-Modified值，客户端就可以使用If-Modified-Since
验证。如果实体标签和最后修改日期都提供了，客户端就应该使用这两种再验证方
181 案，这样HTTP/1.0和HTTP/1.1缓存就都可以正确响应了。
除非HTTP/1.1原始服务器无法生成实体标签验证器，否则就应该发送一个出去，
如果使用弱实体标签有优势的话，发送的可能就是个弱实体标签，而不是强实体标
签。而且，最好同时发送一个最近修改值。
190 ｜ 第7章
如果HTTP/1.1缓存或服务器收到的请求既带有If-Modified-Since，又带有实体
标签条件首部，那么只有这两个条件都满足时，才能返回304 Not Modified响应。
7.9 控制缓存的能力
服务器可以通过HTTP定义的几种方式来指定在文档过期之前可以将其缓存多长时
间。按照优先级递减的顺序，服务器可以：
• 附加一个Cache-Control: no-store首部到响应中去；
• 附加一个Cache-Control: no-cache首部到响应中去；
• 附加一个Cache-Control: must-revalidate首部到响应中去；
• 附加一个Cache-Control: max-age首部到响应中去；
• 附加一个Expires日期首部到响应中去；
• 不附加过期信息，让缓存确定自己的过期日期。
本节描述了缓存控制首部。下一节，也就是7.10节介绍了如何为不同的内容分配不
同的缓存信息。
7.9.1 no-Store与no-Cache响应首部
HTTP/1.1提供了几种限制对象缓存，或限制提供已缓存对象的方式，以维持对象的
新鲜度。no-store首部和no-cache首部可以防止缓存提供未经证实的已缓存对象：
Pragma: no-cache
Cache-Control: no-store
Cache-Control: no-cache
标识为no-store的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服
务器一样，向客户端转发一条no-store响应，然后删除对象。
标识为no-cache的响应实际上是可以存储在本地缓存区中的。只是在与原始服
务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。这个首部使用do-
not-serve-from-cache-without-revalidation这个名字会更恰当一些。
HTTP/1.1中提供Pragma: no-cache首部17是为了兼容于HTTP/1.0+。除了与只
理解Pragma: no-cache的HTTP/1.0应用程序进行交互时，HTTP 1.1应用程序都
应该使用Cache-Control: no-cache。 182
注17： 从技术上来讲，Pragma:no-cache首部只能用于HTTP请求，但在实际中它作为扩展首部已被广
泛地用于HTTP请求和响应之中。
缓 存 ｜ 191
7.9.2 max-age响应首部
Cache-Control: max-age首部表示的是从服务器将文档传来之时起，可以认为此
文档处于新鲜状态的秒数。还有一个s-maxage首部（注意maxage的中间没有连
字符），其行为与max-age类似，但仅适用于共享（公有）缓存：
Cache-Control: max-age=3600
Cache-Control: s-maxage=3600
服务器可以请求缓存不要缓存文档，或者将最大使用期设置为零，从而在每次访问
的时候都进行刷新：
Cache-Control: max-age=0
Cache-Control: s-maxage=0
7.9.3 Expires响应首部
不推荐使用Expires首部，它指定的是实际的过期日期而不是秒数。HTTP设计者
后来认为，由于很多服务器的时钟都不同步，或者不正确，所以最好还是用剩余秒
数，而不是绝对时间来表示过期时间。可以通过计算过期值和日期值之间的秒数差
来计算类似的新鲜生存期：
Expires: Fri, 05 Jul 2002, 05:00:00 GMT
有些服务器还会回送一个Expires:0响应首部，试图将文档置于永远过期的状态，
但这种语法是非法的，可能给某些软件带来问题。应该试着支持这种结构的输入，
但不应该产生这种结构的输出。
7.9.4 must-revalidate响应首部
可以配置缓存，使其提供一些陈旧（过期）的对象，以提高性能。如果原始服务器
希望缓存严格遵守过期信息，可以在原始响应中附加一个Cache-Control: must-
revalidate首部。
Cache-Control: must-revalidate
Cache-Control: must-revalidate响应首部告诉缓存，在事先没有跟原始服务
器进行再验证的情况下，不能提供这个对象的陈旧副本。缓存仍然可以随意提供新
鲜的副本。如果在缓存进行must-revalidate新鲜度检查时，原始服务器不可
183 用，缓存就必须返回一条504 Gateway Timeout错误。
192 ｜ 第7章
7.9.5 试探性过期
如果响应中没有Cache-Control:max-age首部，也没有Expires首部，缓存可
以计算出一个试探性最大使用期。可以使用任意算法，但如果得到的最大使用期大
于24小时，就应该向响应首部添加一个Heuristic Expiration Warning（试探性过期
警告，警告13）首部。据我们所知，很少有浏览器会为用户提供这种警告信息。
LM-Factor算法是一种很常用的试探性过期算法，如果文档中包含了最后修改日期，
就可以使用这种算法。LM-Factor算法将最后修改日期作为依据，来估计文档有多
么易变。算法的逻辑如下所示。
• 如果已缓存文档最后一次修改发生在很久以前，它可能会是一份稳定的文档，不
太会突然发生变化，因此将其继续保存在缓存中会比较安全。
• 如果已缓存文挡最近被修改过，就说明它很可能会频繁地发生变化，因此在与服
务器进行再验证之前，只应该将其缓存很短一段时间。
实际的LM-Factor算法会计算缓存与服务器对话的时间跟服务器声明文档最后被修
改的时间之间的差值，取这个间隔时间的一部分，将其作为缓存中的新鲜度持续时
间。下面是LM-factor算法的Perl伪代码：
$time_since_modify = max(0, $server_Date - $server_Last_Modified);
$server_freshness_limit = int($time_since_modify * $lm_factor);
图7-16以图形方式给出了LM-factor的新鲜周期。图中用交叉线画出的阴影表示的
是将LM-factor设置为0.2计算出的新鲜周期。
获取时间和最近修改时间之间
间隔的20%（LM-factor=0.2） 已缓存副本在这个 新的过期时间
时段内是新鲜的
时间
最近修改时间 缓存与服务器
对话的时间
图7-16 用LM-factor算法计算新鲜周期
通常人们会为试探性新鲜周期设置上限，这样它们就不会变得太大了。尽管比较保
守的站点会将这个值设置为一天，但通常站点会将其设置为一周。
如果最后修改日期也没有的话，缓存就没什么信息可利用了。缓存通常会为没有任
何新鲜周期线索的文档分配一个默认的新鲜周期（通常是一个小时或一天）。有时，
比较保守的缓存会将这种试探性新鲜生存期设置为0，强制缓存在每次将其提供给
客户端之前，都去验证一下这些数据仍然是新鲜的。 184
缓 存 ｜ 193
与试探性新鲜计算有关的最后一点是——它们可能比你想象的要常见得多。很多原始服
务器仍然不会产生Expires和max-age首部。选择缓存过期的默认时间时要特别小心！
7.9.6 客户端的新鲜度限制
Web浏览器都有Refresh（刷新）或Reload（重载）按钮，可以强制对浏览器或
代理缓存中可能过期的内容进行刷新。Refresh按钮会发布一个附加了Cache-
Control请求首部的GET请求，这个请求会强制进行再验证，或者无条件地从服
务器获取文档。Refresh的确切行为取决于特定的浏览器、文档以及拦截缓存的配置。
客户端可以用Cache-Control请求首部来强化或放松对过期时间的限制。有些应
用程序对文档的新鲜度要求很高（比如人工刷新按钮），对这些应用程序来说，客
户端可以用Cache-Control首部使过期时间更严格。另一方面，作为提高性能、
可靠性或开支的一种折衷方式，客户端可能会放松新鲜度要求。表7-4对 Cache-
Control请求指令进行了总结。
表7-4 Cache-Control请求指令
指 令 目 的
Cache-Control: max-stale 缓存可以随意提供过期的文件。如果指定了参数，在这段
Cache-Control: max-stale =  时间内，文档就不能过期。这条指令放松了缓存的规则
Cache-Control: min-fresh= 至少在未来秒内文档要保持新鲜。这就使缓存规则更加严格了
Cache-Control: max-age =  缓存无法返回缓存时间长于秒的文档。这条指令会使缓存
规则更加严格，除非同时还发送了max-stale指令，在这种
情况下，使用期可能会超过其过期时间
Cache-Control: no-cache 除非资源进行了再验证，否则这个客户端不会接受已缓存的
Pragma: no-cache 资源
Cache-Control: no-store 缓存应该尽快从存储器中删除文档的所有痕迹，因为其中可能
会包含敏感信息
Cache-Control: only-if-cached 只有当缓存中有副本存在时，客户端才会获取一份副本
7.9.7 注意事项
文档过期系统并不是一个完美的系统。如果发布者不小心分配了一个很久之后的过期
185 日期，在文档过期之前，她要对文档做的任何修改都不一定能显示在所有缓存中。18
注18： 文档过期采用了“生存时间”技术，这种技术用于很多因特网协议，比如DNS中。与HTTP一样，
如果发布了一个很久之后才到时的过期日期，然后发现需要进行修改，DNS就会遇到麻烦。但是，
与DNS不同的是，HTTP为客户端提供了一些覆盖和强制重载机制。
194 ｜ 第7章
因此，很多发布者都不会使用很长的过期日期。而且，很多发布者甚至都不使用过
期日期，这样缓存就很难确定文档会在多长时间内保持新鲜了。
7.10 设置缓存控制
不同的Web服务器为HTTP Cache-Control和Expiration首部的设置提供了一
些不同的机制。本节简要介绍了流行的Apache Web服务器是怎样支持缓存控制的。
具体细节请参见你的Web服务器文档。
7.10.1 控制Apache的HTTP首部
Apache Web服务器提供了几种设置HTTP 缓存控制首部的机制。其中很多机制在
默认情况下都没有启动——你要启动它们（有些情况下先要获取Apache的扩展模
块）。下面是对某些Apache特性的简要描述。
• mod_headers
通过mod_headers模块可以对单独的首部进行设置。装载了这个模块，就可以用设置
单个HTTP首部的指令来扩充Apache的配置文件了。还可以将这些设置与Apache
的常用表达式以及过滤器结合在一起使用，将这些首部与个别内容关联起来。这里
有一个配置实例，这个例子将某目录下所有的HTML文件都标识为非缓存的：
Header set Cache-control no-cache
• mod_expires
mod_expires模块提供的程序逻辑可以自动生成带有正确过期日期的Expires首
部。通过这个模块，就可以将文档的过期日期设置为对其最后一次被访问之后或
者其最近修改日期之后的某一时间段。通过这个模块可以为不同的文件类型设
置不同的过期日期，还可以使用便捷的详尽描述信息来描述其缓存能力，比如
“access plus 1 month（自访问之后起1个月）”。这里有几个例子：
ExpiresDefault A3600
ExpiresDefault M86400
ExpiresDefault "access plus 1 week"
ExpiresByType text/html "modification plus 2 days 6 hours 12 minutes"
• mod_cern_meta
通过mod_cern_meta模块可以将一个包含HTTP首部的文件与特定的对象联系起
来。启动这个模块时，就创建了一组“元文件”，每个需要控制的文档一个，而
且还会为每个元文件添加所期望的首部。 186
缓 存 ｜ 195