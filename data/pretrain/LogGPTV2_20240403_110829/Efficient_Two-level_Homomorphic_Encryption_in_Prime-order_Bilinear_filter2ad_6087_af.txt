### 优化后的文本

#### 表5: 基于WebAssembly实现的性能测试结果（使用Barreto–Naehrig曲线BN254）

| 算法 | 操作 | BN254 | BN382 | BN462 |
| --- | --- | --- | --- | --- |
| ReRand | - | 0.0668 | 0.199 | 0.452 |
| Add'1 | - | 0.191 | 0.532 | 1.14 |
| Add'2 | - | 2.33 | 4.85 | 9.01 |
| Mult' | - | 2.61 | 5.5 | 10.01 |
| Enc | - | 0.0646 | 0.196 | 0.447 |
| Dec | - | 0.193 | 0.571 | 1.14 |
| ReRand | - | 0.0025 | 0.0053 | 0.0109 |
| Add'1 | - | 0.0063 | 0.0126 | 0.0231 |
| Add'2 | - | 1.16 | 3.82 | 8.47 |

**注释：**
- *消息加密或解密的位长度为32位。
- † Enc, Dec, 和 ReRand 使用了221条目的预计算查找表。
- ‡ Add'2 和 Mult' 表示在没有 ReRand 的情况下 Add1, Add2 和 Mult 的部分（详见第4.1节）。
- § 所有时间单位均为毫秒。

#### 平台性能对比

| 平台 | 操作 | Windows (Core i7-6700, 3.4GHz) | iPhone 7 (MNCF2J/A) |
| --- | --- | --- | --- |
| ReRand | - | 0.60 | 1.90 |
| Add'1 | - | 1.64 | 3.74 |
| Add'2 | - | 16.0 | 25.2 |
| Mult' | - | 17.8 | 27.7 |
| Enc | - | 0.63 | 1.95 |
| Dec | - | 1.69 | 3.83 |
| ReRand | - | 0.036 | 0.048 |
| Add'1 | - | 0.056 | 0.084 |
| Add'2 | - | 9.4 | 14.5 |

**注释：**
- * 有关两个平台“Windows”和“iPhone”的具体规格，请参阅正文。
- † 其他条件与表4中的*、†、‡和§脚注相同。

### 第6.3节：WebAssembly实现

除了上述实现外，我们还使用WebAssembly (wasm) [31] 实现了我们的方案。我们在以下URL公开了一个演示版本：

```
https://herumi.github.io/she-wasm/she-demo.html
```

WebAssembly (wasm) 是一种高效的低级字节码格式，既紧凑又加载迅速。尽管它最近才被引入，但由于其有用性，wasm 已经得到了几乎所有主流网络浏览器的支持。因此，特别是我们的实现和演示可以在这些浏览器上运行，而无需安装任何插件。这包括Microsoft Edge、Safari、Google Chrome和Firefox等流行的浏览器，在Windows/Linux/macOS/Android/iPhone平台上均可使用。

在这个实现中，我们再次使用了Barreto–Naehrig曲线BN254，并采用了如第6.2.2节所述的查找表优化技术。可解密的消息空间设置为所有位长不超过20位的比特串。

我们用C++编写了程序，并使用Emscripten编译器版本1.37.22生成了相应的wasm字节码。需要注意的是，这并不是一个简单的任务，因为像GMP库这样的全功能任意精度算术库还没有提供给wasm。因此，我们特别设计并实现了所需的功能，以便直接用于wasm。我们将这些功能包含在当前版本的mcl库中。实现方法的详细信息不在本文讨论范围内，这里省略。

类似于我们的x86实现，我们的wasm实现也非常快速。感兴趣的读者可以通过访问上述URL来在自己的设备上运行演示（请参阅下面关于演示的说明）。为了展示定量性能，我们在两个平台上运行了演示。第一个是Windows平台，使用Core i7-6700 (3.4GHz) CPU，运行Windows 10 Pro和Firefox 59.0.2浏览器。第二个是iPhone平台，使用iPhone 7型号MNCF2J/A，运行iOS 11.2.1和内置浏览器（Safari）。性能结果见表5。

**网络浏览器上的演示**

要尝试演示，请确保更新您的网络浏览器以支持wasm。如果可以运行，将显示“library status ok”消息（这意味着支持wasm）。当前版本的演示展示了客户端发送一些密文对：
\[
\left( \text{Enc}(1, x_1), \text{Enc}(1, y_1) \right), \ldots, \left( \text{Enc}(1, x_n), \text{Enc}(1, y_n) \right)
\]
到服务器，服务器计算加密数据的内积，得到 \(\text{Enc}(2, x_1y_1 + \cdots + x_ny_n)\)，然后将其返回给客户端进行解密。为了简化起见，我们省略了公钥 \(pk\)。当 \(x_1y_1 + \cdots + x_ny_n \leq 2^{20}\) 时，解密是可能的。请注意，这里并没有真正的客户端和服务器，它们只是为了演示。实际上，所有算法都在浏览器上运行，甚至可以在状态确认对话框出现后关闭互联网连接来体验这一点。为了简化密文的可视化，我们仅包括了Enc(1, xi)的G1组件和Enc(1, yi)的G2组件，类似于第1.3节中的“基本方案”（尽管演示中包含了重新随机化）。

### 第7节：结论

本文提出了一种在素数阶双线性群中的高效两层同态公钥加密方案，显著改进了Freeman提出的现有最佳方案。我们的方案具有与提升的ElGamal加密[19]完全相同的结构，因此可以直接插入许多已经利用提升ElGamal加密方案作为构建块的实际密码协议中。通过这种替换，可以增强各种密码协议的功能。例如，Sakai等人[52]提出了一个非交互式零知识证明，可以验证提升ElGamal密文是否是对预先定义的两个值之一的加密。该方案已应用于生物信息学领域的一些实际问题[55-57]，并且有很大的潜力在各种应用中使用。从仅能评估线性多项式（通过提升ElGamal方案）到能够评估二次多项式（通过我们的方案），这一功能升级对于这些实际应用非常有益，因为它扩展了可以在加密数据上计算的函数类。这种扩展已经在[9, 12, 36]中建议的应用中证明是有用的。当我们应用（广义的）Catalano-Fiore转换[12]到我们的两层HE方案时，我们进一步获得了一个四层HE方案，允许评估加密数据上的四次多项式；我们预计这将进一步扩展应用范围。

### 致谢

本研究的部分工作得到了日本科学技术振兴机构（JST CREST）的支持，资助编号为JPMJCR1688。

### 参考文献

[此处列出参考文献]

---

通过这种方式，文本变得更加清晰、连贯和专业。希望这对您有所帮助！