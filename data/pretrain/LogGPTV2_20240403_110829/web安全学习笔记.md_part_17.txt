$this->data = $data;
echo "construct";
}
public function __wakeup()
{
echo "wake up";
}
public function __destruct()
{
(下页继续)
5.1. PHP 143
Web-Sec Documentation, 发布 1.0
(续上页)
echo "Data's value is $this->data. ";
echo "destruct";
}
}
var_dump(serialize(new Demo("raw value")));
输出
construct
Data's value is raw value.
destruct
string(44) "O:4:"Demo":1:{s:4:"data";s:9:"raw value";}"
把序列化的字符串修改一下后，执行
unserialize('O:4:"Demo":1:{s:4:"data";s:15:"malicious value";}');
输出
wake up
Data's value is malicious value.
destruct
这里看到，值被修改了.
上面是一个 unserialize() 的简单应用，不难看出，如果 __wakeup() 或者 __desturct() 有敏感操作，比
如读写文件、操作数据库，就可以通过函数实现文件读写或者数据读取的行为。
那么，在 __wakeup() 中加入判断是否可以阻止这个漏洞呢？在 __wakeup() 中我们加入一行代码
public function __wakeup()
{
if($this->data != 'raw value') $this->data = 'raw value';
echo "wake up";
}
但其实还是可以绕过的，在 PHP5 fn_flags &= ~(ZEND_ACC_VARIADIC | ZEND_ACC_HAS_TYPE_HINTS | ZEND_ACC_HAS_
,!RETURN_TYPE);
func->num_args = 0;
func->arg_info = NULL;
func->handler = ZEND_FN(display_disabled_function);
return SUCCESS;
}
return FAILURE;
}
和函数的实现方式类似，disable classes 也是这样实现的
ZEND_API int zend_disable_class(char *class_name, size_t class_name_length) /* {{{ */
{
zend_class_entry *disabled_class;
zend_string *key;
key = zend_string_alloc(class_name_length, 0);
zend_str_tolower_copy(ZSTR_VAL(key), class_name, class_name_length);
disabled_class = zend_hash_find_ptr(CG(class_table), key);
zend_string_release_ex(key, 0);
if (!disabled_class) {
return FAILURE;
}
INIT_CLASS_ENTRY_INIT_METHODS((*disabled_class), disabled_class_new);
disabled_class->create_object = display_disabled_class;
zend_hash_clean(&disabled_class->function_table);
return SUCCESS;
}
因为这个实现机制的原因，在 PHP 启动后通过 ini_set 来修改 disable_functions 或 disable_classes
是无效的。
146 Chapter 5. 语言与框架
Web-Sec Documentation, 发布 1.0
Bypass
• LD_PRELOAD 绕过
– https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD
– mail() + putenv
• PHP OPcache
• Mail 函数
• imap_open
– https://www.cvedetails.com/cve/cve-2018-19518
5.1.4 Open Basedir
机制实现
PHP 中 Disable Function 的实现是在 php-src/main/fopen-wrappers.c 中，实现方式是在调用文件等相关操
作时调用函数根据路径来检查是否在 basedir 内，其中一部分实现代码如下：
PHPAPI int php_check_open_basedir_ex(const char *path, int warn)
{
/* Only check when open_basedir is available */
if (PG(open_basedir) && *PG(open_basedir)) {
char *pathbuf;
char *ptr;
char *end;
/* Check if the path is too long so we can give a more useful error
* message. */
if (strlen(path) > (MAXPATHLEN - 1)) {
php_error_docref(NULL, E_WARNING, "File name is longer than the maximum␣
,!allowed path length on this platform (%d): %s", MAXPATHLEN, path);
errno = EINVAL;
return -1;
}
pathbuf = estrdup(PG(open_basedir));
ptr = pathbuf;
while (ptr && *ptr) {
(下页继续)
5.1. PHP 147
Web-Sec Documentation, 发布 1.0
(续上页)
end = strchr(ptr, DEFAULT_DIR_SEPARATOR);
if (end != NULL) {
*end = '\0';
end++;
}
if (php_check_specific_open_basedir(ptr, path) == 0) {
efree(pathbuf);
return 0;
}
ptr = end;
}
if (warn) {
php_error_docref(NULL, E_WARNING, "open_basedir restriction in effect. File(
,!%s) is not within the allowed path(s): (%s)", path, PG(open_basedir));
}
efree(pathbuf);
errno = EPERM; /* we deny permission to open it */
return -1;
}
/* Nothing to check... */
return 0;
}
5.1.5 安全相关配置
函数与类限制
可通过 disable_functions / disable_classes 限制 PHP 可调用的函数和类。
目录访问限制
可通过 open_basedir 限制 PHP 可访问的目录。
远程引用限制
可通过 all_url_include 限制远程文件包含，默认关闭。可通过 allow_url_fopen 限制打开远程文件，默
认开启。
148 Chapter 5. 语言与框架
Web-Sec Documentation, 发布 1.0
Session
Session.Save
PHP 的 Session 默认 handler 为文件，存储在 php.ini 的 session.save_path 中，若有任意读写文件的权
限，则可修改或读取 session。从 phpinfo 中可获得 session 位置。
Session.Upload
PHP默认开启了session.upload_progress.enabled，该选项会导致生成上传进度文件，其存储路径可以
在 phpinfo 中获取。
那么可以构造特别的报文向服务器发送，在有 LFI 的情况下即可利用。
5.1.6 PHP 流
简介
流（Streams）的概念是在 php 4.3 引入的，是对流式数据的抽象，用于统一数据操作，比如文件数据、网络
数据、压缩数据等。
流可以通过 file、open、fwrite、fclose、file_get_contents、file_put_contents 等函数操作。
封装协议
PHP 带有很多内置 URL 风格的封装协议，可用于类似 fopen()、copy()、file_exists() 和 filesize() 的文件系
统函数。支持的协议可用 stream_get_wrappers() 查看。
• file:// 访问本地文件系统
• http:// 访问 HTTP(s) 网址
• ftp:// 访问 FTP(s) URLs
• php:// 访问各个输入/输出流（I/O streams）
• zlib:// 压缩流
• data:// 数据（RFC 2397）
• glob:// 查找匹配的文件路径模式
• phar:// PHP 归档
• ssh2:// Secure Shell 2
• rar:// RAR
• ogg:// 音频流
5.1. PHP 149
Web-Sec Documentation, 发布 1.0
• expect:// 处理交互式的流
PHP 支持流
PHP 提供了一些输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，内存中、
磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。
需要注意的是，流不受allow_url_fopen限制，但是php://input、php://stdin、php://memory和php:/
/temp 受限于 allow_url_include 。
输入输出流
php://stdin 、php://stdout 和 php://stderr 允许直接访问 PHP 进程相应的输入或者输出流。数据流
引用了复制的文件描述符，所以如果在打开 php://stdin 并在之后关了它，仅是关闭了复制品，真正被引用
的 STDIN 并不受影响。
其中 php://stdin 是只读的，php://stdout 和 php://stderr 是只写的。
fd
php://fd 允许直接访问指定的文件描述符。例如 php://fd/3 引用了文件描述符 3。
memory 与 temp
php://memory 和 php://temp 是一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是
php://memory 总是把数据储存在内存中，而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）
存入临时文件中。临时文件位置的决定和 sys_get_temp_dir() 的方式一致。
php://temp 的内存限制可通过添加 /maxmemory:NN 来控制，NN 是以字节为单位、保留在内存的最大数据
量，超过则使用临时文件。
input
php://input是个可以访问请求的原始数据的只读流。POST请求的情况下，最好使用php://input来代替
$HTTP_RAW_POST_DATA，因为它不依赖于特定的 php.ini 指令。而且，这样的情况下 $HTTP_RAW_POST_DATA
默认没有填充，比激活 always_populate_raw_post_data 潜在需要更少的内存。enctype="multipart/
form-data" 的时候 php://input 是无效的。
filter
php://filter 是一种元封装器，设计用于数据流打开时的筛选过滤应用。PHP 默认提供了一些流过滤器，
除此之外，还可以使用各种自定义过滤器。
150 Chapter 5. 语言与框架
Web-Sec Documentation, 发布 1.0
filter 有 resource, read, write 三个参数，resource 参数是必须的。它指定了你要筛选过滤的数据流。read 和
write 是可选参数，可以设定一个或多个过滤器名称，以管道符（|）分隔。
过滤器列表
可以通过 stream_get_filters() 获取已经注册的过滤器列表。其中 PHP 内置的过滤器如下：
• 字符串过滤器
– string.rot13
– string.toupper
– string.tolower
– string.strip_tags
• 转换过滤器
– convert.base64-encode
– convert.base64-decode
– convert.quoted-printable-encode
– convert.quoted-printable-decode
– convert.iconv.*
• 压缩过滤器
– zlib.deflate
– zlib.inflate
– bzip2.compress
– bzip2.decompress
• 加密过滤器
– mcrypt.‘‘ciphername‘‘
– mdecrypt.‘‘ciphername‘‘
过滤器利用 tricks
• LFI
– php://filter/convert.base64-encode/resource=index.php
• XXE 读取文件时会因而解析报错，可用 base64 编码
• base64 编码会弃掉未在码表内的字符，可用于绕过一些文件格式
5.1. PHP 151