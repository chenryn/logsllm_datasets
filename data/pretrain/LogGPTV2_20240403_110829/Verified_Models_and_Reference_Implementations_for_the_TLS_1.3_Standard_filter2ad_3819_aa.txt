title:Verified Models and Reference Implementations for the TLS 1.3 Standard
Candidate
author:Karthikeyan Bhargavan and
Bruno Blanchet and
Nadim Kobeissi
2017 IEEE Symposium on Security and Privacy
Veriﬁed Models and Reference Implementations
for the TLS 1.3 Standard Candidate
Karthikeyan Bhargavan, Bruno Blanchet, Nadim Kobeissi
{karthik.bhargavan,bruno.blanchet,nadim.kobeissi}@inria.fr
INRIA
Abstract—TLS 1.3 is the next version of the Transport Layer
Security (TLS) protocol. Its clean-slate design is a reaction both
to the increasing demand for low-latency HTTPS connections
and to a series of recent high-proﬁle attacks on TLS. The
hope is that a fresh protocol with modern cryptography will
prevent legacy problems; the danger is that it will expose
new kinds of attacks, or reintroduce old ﬂaws that were ﬁxed
in previous versions of TLS. After 18 drafts, the protocol is
nearing completion, and the working group has appealed to
researchers to analyze the protocol before publication. This
paper responds by presenting a comprehensive analysis of the
TLS 1.3 Draft-18 protocol.
We seek to answer three questions that have not been fully
addressed in previous work on TLS 1.3: (1) Does TLS 1.3
prevent well-known attacks on TLS 1.2, such as Logjam or the
Triple Handshake, even if it is run in parallel with TLS 1.2?
(2) Can we mechanically verify the computational security of
TLS 1.3 under standard (strong) assumptions on its crypto-
graphic primitives? (3) How can we extend the guarantees of
the TLS 1.3 protocol to the details of its implementations?
To answer these questions, we propose a methodology
for developing veriﬁed symbolic and computational models
of TLS 1.3 hand-in-hand with a high-assurance reference
implementation of the protocol. We present symbolic ProVerif
models for various intermediate versions of TLS 1.3 and
evaluate them against a rich class of attacks to reconstruct
both known and previously unpublished vulnerabilities that
inﬂuenced the current design of the protocol. We present
a computational CryptoVerif model for TLS 1.3 Draft-18
and prove its security. We present RefTLS, an interoperable
implementation of TLS 1.0-1.3 and automatically analyze its
protocol core by extracting a ProVerif model from its typed
JavaScript code.
I. INTRODUCTION
The Transport Layer Security (TLS) protocol is widely
used to establish secure channels on the Internet. It was
ﬁrst proposed under the name SSL [45] in 1994, and has
undergone a series of revisions since, leading up to the stan-
dardization of TLS 1.2 [37] in 2008. Each version adds new
features, deprecates obsolete constructions, and introduces
countermeasures for weaknesses found in previous versions.
The behavior of the protocol can be further customized via
extensions, some of which are mandatory to prevent known
attacks on the protocol.
One may expect that TLS clients and servers would use
only the latest version of the protocol with all security-
critical extensions enabled.
In practice, however, many
legacy variants of the protocol continue to be supported
for backwards compatibility, and the everyday use of TLS
© 2017, Karthikeyan Bhargavan. Under license to IEEE.
DOI 10.1109/SP.2017.26
483
depends crucially on clients and servers negotiating the most
secure variant that they have in common. Securely com-
posing and implementing the many different versions and
features of TLS has proved to be surprisingly hard, leading
to the continued discovery of high-proﬁle vulnerabilities in
the protocol.
A history of vulnerabilities. We identify four kinds of
attacks that TLS has traditionally suffered from. Downgrade
attacks enable a network adversary to fool a TLS client and
server into using a weaker variant of the protocol than they
would normally use with each other. In particular, version
downgrade attacks were ﬁrst demonstrated from SSL 3 to
SSL 2 [72] and continue to be exploited in recent attacks
like POODLE [60] and DROWN [7]. Cryptographic vul-
nerabilities rely on weaknesses in the protocol constructions
used by TLS. Recent attacks have exploited key biases in
RC4 [3], [71], padding oracles in MAC-then-Encrypt [4],
[60], padding oracles in RSA PKCS#1 v1.5 [7], weak
Difﬁe-Hellman groups [1], and weak hash functions [23].
Protocol composition ﬂaws appear when multiple modes
of the protocol interact in unexpected ways if enabled in
parallel. For example, the renegotiation attack [65] exploits
the sequential composition of two TLS handshakes,
the
Triple Handshake attack [15] composes three handshakes,
and cross-protocol attacks [58], [72] use one kind of TLS
handshake to attack another. Implementation bugs contribute
to the fourth category of attacks on TLS, and are perhaps the
hardest to avoid. They range from memory safety bugs like
HeartBleed and coding errors like GotoFail to complex state
machine ﬂaws like SKIP and FREAK [12]. Such bugs can
be exploited to bypass all the security guarantees of TLS,
and their prevalence, even in widely-vetted code, indicates
the challenges of implementing TLS securely.
Security proofs. Historically, when an attack is found on
TLS, practitioners propose a temporary ﬁx that is imple-
mented in all mainstream TLS libraries, then a longer-term
countermeasure is incorporated into a protocol extension
or in the next version of the protocol. This has led to
a attack-patch-attack cycle that does not provide much
assurance in any single version of the protocol, let alone
its implementations.
An attractive alternative would have been to develop
security proofs that systematically demonstrated the absence
of large classes of attacks in TLS. However, developing
proofs for an existing standard that was not designed with
security models in mind is exceedingly hard [63]. After
years of effort, the cryptographic community only recently
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply. 
published proofs for the two main components of TLS: the
record layer that implements authenticated encryption [57],
[62], and the handshake layer that composes negotiation and
key-exchange [46], [51]. These proofs required new security
deﬁnitions and custom cryptographic assumptions, and even
so, they apply only to abstract models of certain modes of
the protocol. For example, the proofs do not account for
low-level details of message formats, downgrade attacks,
or composition ﬂaws. Since such cryptographic proofs are
typically carried out by hand, extending the proofs to cover
all these details would require a prohibitive amount of work,
and the resulting large proofs themselves would need to be
carefully checked.
A different approach taken by the protocol veriﬁcation
community is to symbolically analyze cryptographic pro-
tocols using simpler, stronger assumptions on the under-
lying cryptography, commonly referred to as the Dolev-
Yao model [39]. Such methods are easy to automate and
can tackle large protocols like TLS in all their gory de-
tail, and even aspects of TLS implementations [31], [18].
Symbolic protocol analyzers are better at ﬁnding attacks,
but since they treat cryptographic constructions as perfect
black boxes, they provide weaker security guarantees than
classic cryptographic proofs that account for probabilistic
and computational attacks.
The most advanced example of mechanized veriﬁcation
for TLS is the ongoing miTLS project [21], which uses de-
pendent types to prove both the symbolic and cryptographic
security of a TLS implementation that supports TLS 1.0-
1.2, multiple key exchanges and encryption modes, session
resumption, and renegotiation. This effort has uncovered
weaknesses in both the TLS 1.2 standard [15] and its
other implementations [12], and the proof is currently being
extended towards TLS 1.3.
Towards Veriﬁed Security for TLS 1.3. In 2014, the TLS
working group at the IETF commenced work on TLS 1.3,
with the goal of designing a faster protocol inspired by the
success of Google’s QUIC protocol [44]. Learning from the
pitfalls of TLS 1.2, the working group invited the research
community to contribute to the design of the protocol
and help analyze its security even before the standard is
published. A number of researchers, including the authors
of this paper, responded by developing new security models
and cryptographic proofs for various draft versions, and
using their analyses to propose protocol changes. Cryp-
tographic proofs were developed for Draft-5 [40], Draft-
9 [52], and Draft-10 [55], which justiﬁed the core design
of the protocol. A detailed symbolic model in Tamarin was
developed for Draft-10 [35]. Other works studied speciﬁc
aspects of TLS 1.3, such as key conﬁrmation [41], client
authentication [50], and downgrade resilience [14].
Some of these analyses also found attacks. The Tamarin
analysis [35] uncovered a potential attack on the composition
of pre-shared keys and certiﬁcate-based authentication, and
this attack was prevented in Draft-11. A version downgrade
attack was found in Draft-12 and its countermeasure in
Draft-13 was proved secure [14]. A cross-protocol attack on
RSA signatures was described in [47]. Even in this paper,
we describe two vulnerabilities in 0-RTT client authentica-
tion that we discovered and reported, which inﬂuenced the
subsequent designs of Draft-7 and -13.
After 18 drafts, TLS 1.3 is entering the ﬁnal phase of
standardization. Although many of its design decisions have
now been vetted by multiple security analyses, several unan-
swered questions remain. First, the protocol has continued
to evolve rapidly with every draft version, so many of
the cryptographic proofs cited above are already obsolete
and do not apply to Draft-18. Since many of these are
manual proofs, it is not easy to update them and check
all
the proof steps. Second, none of these symbolic or
cryptographic analyses, with the exception of [14], con-
sider the composition of TLS 1.3 with legacy versions like
TLS 1.2. Hence, they do not account for attacks like [47] that
exploit weak legacy crypto in TLS 1.2 to break the modern
cryptographic constructions of TLS 1.3. Third, none of these
works addresses TLS 1.3 implementations. In this paper, we
seek to cover these gaps with a new comprehensive analysis
of TLS 1.3 Draft-18.
Our Contributions. We propose a methodology for devel-
oping mechanically veriﬁed models of TLS 1.3 alongside a
high-assurance reference implementation of the protocol.
We present symbolic protocol models for TLS 1.3 written
in ProVerif [27]. They incorporate a novel security model
(described in §II) that accounts for all recent attacks on TLS,
including those relying on weak cryptographic algorithms.
In §III-V, we use ProVerif to evaluate various modes and
drafts of TLS 1.3 culminating in the ﬁrst symbolic analysis
of Draft-18 and the ﬁrst composite analysis of TLS 1.3+1.2.
Our analyses uncover known and new vulnerabilities that
inﬂuenced the ﬁnal design of Draft-18. Some of the features
we study no longer appear in the protocol, but our analysis
is still useful for posterity,
to warn protocol designers
and developers who may be tempted to reintroduce these
problematic features in the future.
In §VI, we develop the ﬁrst machine-checked crypto-
graphic proof for TLS 1.3 using the veriﬁcation tool Cryp-
toVerif [24]. Our proof reduces the security of TLS 1.3
Draft-18 to standard cryptographic assumptions over its
primitives. In contrast to manual proofs, our CryptoVerif
script can be more easily updated from draft-to-draft, and
as the protocol evolves.
Our ProVerif and CryptoVerif models capture the protocol
core of TLS 1.3, but they elide many implementation details
such as the protocol API and state machine. To demon-
strate that our security results apply to carefully-written
implementations of TLS 1.3, we present RefTLS (§VII),
the ﬁrst reference implementation of TLS 1.0-1.3 whose
core protocol code has been formally analyzed for security.
RefTLS is written in Flow, a statically typed variant of
JavaScript, and is structured so that all its protocol code
is isolated in a single module that can be automatically
translated to ProVerif and symbolically analyzed against our
rich threat model.
The full version of this paper is published as a technical
report [13], and our models and code are available at:
https://github.com/inria-prosecco/reftls
484
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply. 
II. A SECURITY MODEL FOR TLS
Client C
Server S
Knows (sk C, pk C), psk
Negotiation (oﬀer C, mode S)
Knows (sk S, pk S), psk
Authenticated Key Exchange (cid , kc, ks, psk
(cid:2)
)
New client session:
C = C (cid:2) cid (cid:3)→ (oﬀer C, mode S,
pk C, pk S, psk ,
kc, ks, psk
(cid:2))
New server session:
S = S (cid:2) cid (cid:3)→ (oﬀer C, mode S,
pk C, pk S, psk ,
kc, ks, psk
(cid:2))
Authenticated Encryption (enckc (m0), encks (m1), . . .)
Application Data Stream:
cid←→ S : m0, m1, . . .
C
Application Data Stream:
cid←→ S : m0, m1, . . .
C
Figure 1: TLS Protocol Structure: Negotiation, then Authen-
ticated Key Exchange (AKE), then Authenticated Encryption
(AE) for application data streams.
(cid:2)
Figure 1 depicts the progression of a typical TLS con-
nection. Since a client and server may support different
sets of features, they ﬁrst negotiate a protocol mode that
they have in common. In TLS,
the client C makes an
oﬀer C and the server chooses its preferred mode S, which
includes the protocol version, the key exchange protocol, the
authenticated encryption scheme, the Difﬁe-Hellman group
(if applicable), and the signature and hash algorithms.
Then, C and S execute the negotiated authenticated
key exchange protocol (e.g. Ephemeral Elliptic-Curve Difﬁe
Hellman), which may use some combination of the long-
term keys (e.g. public/private key pairs, symmetric pre-
shared keys) known to the client and server. The key
exchange ends by computing fresh symmetric keys (kc, ks)
for a new session (with identiﬁer cid) between C and S, and
potentially a new pre-shared key (psk
) that can be used to
authenticate future connections between them.
In TLS, the negotiation and key exchange phases are
together called the handshake protocol. Once the handshake
is complete, C and S can start exchanging application data,
protected by an authenticated encryption scheme (e.g. AES-
GCM) with the session keys (kc, ks). The TLS protocol layer
that handles authenticated encryption for application data is
called the record protocol.
Security Goals for TLS. Each phase of a TLS connection
has its own correctness and security goals. For example,
during negotiation, the server must choose a mode S that is
consistent with the client’s oﬀer C; the key exchange must
produce a secret session key, and so on. Although these
intermediate security goals are important building blocks
towards the security of the full TLS protocol, they are less
meaningful to applications that typically use TLS via a TCP-
socket-like API and are unaware of the protocol’s internal
structure. Consequently, we state the security goals of TLS
from the viewpoint of the application, in terms of messages
it sends and receives over a protocol session.
All goals are for messages between honest and authenti-
cated clients and servers, that is, for those whose long-term
keys (sk C, sk S, psk) are unknown to the attacker. If only the
server is authenticated, then the goals are stated solely from
the viewpoint of the client, since the server does not know
whether it is talking to an honest client or the attacker.
Secrecy: If an application data message m is sent over a
session cid between an honest client C and honest
server S, then this message is kept conﬁdential from
an attacker who cannot break the cryptographic con-
structions used in the session cid.
Forward Secrecy: Secrecy (above) holds even if the long-
term keys of the client and server (sk C, pk C, psk) are
given to the adversary after the session cid has been
completed and the session keys kc, ks are deleted by C
and S.
Authentication: If
an
application
data message m
received over a session cid from an honest
peer must
application data m in a
parameters
is
and