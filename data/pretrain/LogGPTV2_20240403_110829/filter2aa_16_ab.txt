在该程序中，绝大部分工作都是在循环体中完成的。循环体中的赋值语句
celsius =              5 * (fahr • 32) / 9: 用于计算与指定华氏温度相对应的摄氏温度值，并将结果赋值给变量 celsius。在该语句中，
之所以把表达式写成先乘 5 然后再除以 9 而不是直接写成 5 / 9，其原因是在 C 语言及许多
其它语言中，整数除法操作将执行舍位，结果中的任何小数部分都会被舍弃。由于 5 和 9 都
是整数，5 / 9 相除后经截取所得的结果为 0，因此这样求得的所有摄氏温度都将为 0。
从该例子中也可以看出 printf 函数的一些功能。printf 是一个通用输出格式化函数， 第  7  章将对此做详细介绍。该函数的第一个参数是待打印的字符串，其中的每个百分号(%) 表示其它的参数(第二个、第三个、……参数)之一进行替换的位置，并指定打印格式。例 如，%d 指定一个整型参数，因此语句
printf(" %d\t%d\n", fahr, celsius);
用于打印两个整数 fahr 与 celsius 的值，并在两者之间留一个制表符的空间(\t)。
printf 函数的第一个参数中的各个%分别对应于第二个、第三个、……参数，它们在数 目和类型上都必须匹配，否则将出现错误的结果。
顺便指出，printf 函数并不是 C 语言本身的一部分，C 语言本身并没有定义输入/输出 功能。printf 仅仅是标准库函数中一个有用的函数而己，这些标准序函数在 C 语言程序中 通常都可以使用。但是，ANSI 标准定义了 printf 函数的行为，因此，对每个符合该标准的 编译器和库来说，该函数的属性都是相同的。
为了将重点放到讲述 C 语言本身上，我们在第 7 章之前的各章中将不再对输入/输出做 更多的介绍，并且，特别将格式化输入推后到第 7 章讲解。如果读者想了解数据输入，可以 先阅读 7.4 节中对 scanf 函数的讨论部分，scanf 函数类似于 printf 函数，但它用于读输 入数据而不是写输出数据。
上述的温度转换程序存在两个问题。比较简单的问题是，由于输出的数不是右对齐的， 所以输出的结果不是很美观。这个问题比较容易解决:如果在  printf 语句的第一个参数的
%d 中指明打印宽度，则打印的数字会在打印区域内右对齐。例如，可以用语句
printf(" %3d %6d\n", fahr, celsius);
打印 fahr 与 celsius 的值，这样，fahr 的值占 3 个数字宽，celsius 的值占 6 个数字宽， 输出的结果如下所示:
0              •17
20              •6
40              4
60              15
80              26
100              37
...
另一个较为严重的问题是，由于我们使用的是整型算术运算，因此经计算得到的摄氏温 度值不太精确，例如，与     0F对应的精确的摄氏温度应该为•17.8C，而不是•17C。为了得到 更精确的结果，应该用浮点算术运算代替上面的整型算术运算。这就需要对程序做适当修改。 下面是该程序的又一种版本
#include 
/* print Fahrenheit•Celsius table
for fahr = 0, 20, ..., 300; floating•point version */ main()
{
float fahr, celsius; float lower, upper, step;
lower = 0;              /* lower limit of temperatuire scale */ upper = 300;              /* upper limit */
step = 20;              /* step size */
fahr = lower;
while (fahr 
/*打印华氏温度—摄氏温度对照表*/
main()
{
int fahr;
for (fahr = 0; fahr 
#define
LOWER
0
/* lower limit of table */
#define
UPPER
300
/* upper limit */
#define
STEP
20
/* step size */
/* print Fahrenheit•Celsius table */ main()
{
int fahr;
for (fahr = LOWER; fahr 
/* copy input to output; 1st version              */ main()
{
int c;
c = getchar(); while (c != EOF) {
putchar(c);
c = getchar();
}
}
其中，关系运算符!=表示"不等于"。 字符在键盘、屏幕或其它的任何地方无论以什么形式表现，它在机器内部都是以位模式
存储的。char 类型专门用于存储这种字符型数据，当然任何整型(int)也可以用于存储字
符型数据。因为某些潜在的重要原因，我们在此使用 int 类型。
这里需要解决如何区分文件中有效数据与输入结束符的问题。C  语言采取的解决方法是: 在没有输入时，getchar 函数将返回一个特殊值，这个特殊值与任何实际字符都不同。这个 值称为 EOF(end of file，文件结束)。我们在声明变量 c 的时候，必须让它大到足以存 放 getchar 函数返回的任何值。这里之所以不把 c 声明成 char 类型，是因为它必须足够大， 除了能存储任何可能的字符外还要能存储文件结束符 EOF。因此，我们将 c 声明成 int 类型。
EOF 定义在头文件中，是个整型数，其具体数值是什么并不重要，只要它与 任何 char 类型的值都不相同即可。这里使用符号常量，可以确保程序不需要依赖于其对应的 任何特定的数值。
对于经验比较丰富的 C 语言程序员，可以把这个字符复制程序编写得更精炼一些。在 C
语言中，类似于
c = getchar()