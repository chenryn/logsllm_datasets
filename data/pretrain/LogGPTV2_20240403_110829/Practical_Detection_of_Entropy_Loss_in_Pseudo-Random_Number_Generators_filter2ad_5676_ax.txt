proof, we continue to make use of unpredictable values as inputs of the pseudo-random function.
Combining these two approaches, we recover the two stages exhibited by existing constructions.
While the upper stage remains the same, we modify the lower stage to improve the security and
the performances of function next (as we detail below).
The new lower stage makes several calls to a pseudo-random function F : {0, 1}µ × {0, 1}µ →
{0, 1}µ, with public but uniformly distributed inputs and several distinct secret key (as in the
second existing construction). The latter are directly extracted from the input value U =
[X0 · S]m1 . This pseudo-random function, denoted by F, is just expected to be secure with
respect to a very few calls, namely ν, with the same secret key. The precise security requirements
— 106 —
6.5. Instantiations
s
e
l
b
a
i
r
a
v
c
i
l
b
u
p
X00
C
K0
F0
p0
F
···
C + ν − 1
F0
pν−1
···
C + ν(κ − 1)
F0
···
C + νκ − 1
F0
pν(κ−1)
pνκ−1
···
···
K0
F
···
Kκ−1
F
···
Kκ−1
F
(S0, R)
Figure 6.7 – New Instantiation of Generator G with Random Input U = (C, K0, . . . , Kκ−1)
are formalized in Deﬁnition 41. For the sake of simplicity, we restrict this deﬁnition to keyed
functions, where keys, inputs, and outputs are all µ-bit long.
Deﬁnition 41 (Leakage-Resilient Pseudo-Random Function). A pseudo-random function F :
{0, 1}µ × {0, 1}µ → {0, 1}µ is (α, λ)-leakage-resilient and (t, q, ε)-secure if it is ﬁrst a (t, q, ε)-
pseudo-random function, but in addition, for any adversary A, running within time t, that
ﬁrst outputs a leakage f with λ-bit outputs, there exists a source S that outputs (Li, Pi, Ti)i ∈
({0, 1}λ×{0, 1}µ×{0, 1}µ)q, with a uniform distribution for the P’s, so that the entropy of (Ti)i,
conditioned to (Li, Pi)i, is greater than α, and the advantage with which A can distinguish the
tuple (f(Ki, Pi), Pi, FK(Pi))i from (Li, Pi, Ti)i is bounded by ε.
Of course, when q is large, such a requirement implies security against DPA, but when q is
small only SPA is available, which are quite limited attacks in practice. Furthermore, such an
assumption is implicitly done in [YS13] with α = µ − λ, since the loss of entropy in the output
is the leakage one directly gets on it.
This new two-stage instantiation is illustrated in Figure 6.7. One can note that the input U will
be split in κ + 1 slices, to initiate the κ keys K0, . . . , Kκ−1, and the counter C, each of size µ.
Theorem 19 shows that our proposal achieves the security requirements in Deﬁnition 40.
Theorem 19. Let µ and κ be parameters such that νκµ = N. Let F : {0, 1}µ×{0, 1}µ → {0, 1}µ
be a (α/κ, λ)-leakage-resilient and (t, ν, εF)-secure pseudo-random function and F0 : {0, 1}µ ×
{0, 1}µ → {0, 1}µ be a (t, qνκ, εF0)-secure pseudo-random function, where q is a bound on the
global number of executions of G. The instantiation proposed for G as described in Figure 6.7
with F and F0 provides an (α, λ)-leakage-resilient and (t, εG)-secure standard pseudo-random
number generator where εG ≤ κ · εF + εF0 + q2νκ/2µ.
In the proposal, each call to G makes νκ calls to the pseudo-random function F: κ keys are
used at most ν times. The inputs of F are generated by F0 with the key X00 (randomly set in
— 107 —
Chapter 6. Robustness Against Side-Channel Attacks
seed) on a counter C randomly initialized, and then incremented for each F0 call in an execution
of G.
However, for the global security, one needs all the intermediate values (pi
j) to be distinct and
unpredictable to avoid the attack described above. We thus require F0 to be secure after qnνκ
queries and the inputs to be all distinct: by setting the log(νκ) least signiﬁcant bits of C to
zero, we just have to avoid collisions on the µ − log(νκ) most signiﬁcant bits for the qn queries.
2νκ/2µ. This probability can appear once and
The probability of collision is thus less than qn
for all in the global security:
Theorem 20. Let us consider parameters n, m, and ‘ in the construction of the pseudo-random
number generator with input G from Section 6.2, using the generator G as described on Fig-
ure 6.7. Let µ and κ be parameters such that νκµ = n + ‘, and α > γ∗. Let F : {0, 1}µ ×
{0, 1}µ → {0, 1}µ be a (α/κ, λ)-leakage-resilient and (t, ν, εF)-secure pseudo-random function,
and F0 : {0, 1}µ×{0, 1}µ → {0, 1}µ be a (t, qnνκ, εF0)-secure pseudo-random function. Then, G is
(t, qr, qn, qs, γ∗, λ, ε)-leakage-resilient robust after at most q = qr + qn + qs queries, where qr is the
number of D-refresh/leak-refresh-queries, qn the number of next-ror/leak-next-queries, and qs the
number of get-state/set-state-queries, where ε ≤ qqn ·(cid:16)(qr
2m+1−δ + 3(κ · εF + εF0)(cid:17) +
2νκ/2µ, for δ = min{n − log qr, γ∗ − λ}.
qn
It seems reasonable to have (α, λ)-leakage resilience with α = n + ‘ − νκλ: with a large γ∗, ε
can be made small.
√
2 + 1) ·
6.6 Benchmarks
We present some benchmarks of the construction presented in Section 4.3 and the three instan-
tiations. Since our leakage-resilient construction is based on the one presented in Section 4.3,
we use the latter as a reference when measuring eﬃciency. Thus, we simply implemented them
on an Intel Core i7 processor to show that the new property does not signiﬁcantly impact the
performances. This is mainly due to the use of SPA-resistant AES implementations instead of
DPA-resistant (e.g., masked ones). While the target of such constructions is hardware oriented,
our benchmarks rely on software implementations, as we focus on estimating the potential ef-
ﬁciency loss of our new construction. We used the same public cryptographic libraries that in
Section 4.6 and to achieve a similar security level as the construction presented in Section 4.3,
our experiments show that the tweaked binary tree construction is only less than 4 times slower.
For our practical analysis, as in Section 4.6 , since it is widely used and adapted to constraint
devices, we use AES with 128-bit keys to instantiate the pseudo-random functions.
refresh(S, I) =
We recall that our construction is based on the construction of Section 4.3:
S · X + I ∈ F2n and next(S) = G(U), with U = [X0 · S]m1 . In [DPR+13], the standard pseudo-
random number generator G is deﬁned by G(U) = AESU(0)k . . .kAESU(ν − 1), where ν is the
number of calls to AES with a 128-bit key U, and thus m = 128. For a security parameter
k = 40, the security analysis leads to n = 489, γ∗ = 449, and ν = 5. To achieve leakage-
resilience, we need additional security requirements for the standard pseudo-random number
generator G. The three instantiations split G between two pseudo-random functions F and
F0, where F is used with public uniformly distributed inputs and κ diﬀerent secret keys. In
the existing constructions, a ﬁrst key is extracted from the truncated product U and the other
ones are derived through a re-keying process. In the new instantiation, all the secret keys are
extracted from U. The public inputs of F are generated by the pseudo-random function F0 in
counter mode, with a secret initial value for the counter also extracted from U: m = 2 · 128 for
the existing constructions or m = 128(κ + 1) for the new instantiation if both F = F0 = AES
— 108 —
6.6. Benchmarks
Table 6.1 – Security bounds For Robustness against Side-Channel Attacks
Refs
[YS13]
[FPS12]
New
Security
Bound G
κF + 0
F +
q2(νκ − 1)/2µ
2κF + 0
F +
q2(νκ + 2 log2(κ))/2µ
κεF + εF0 + q2νκ/2µ
n
768
896
1408
2−40 Security
keys
(128)
7
4
6
AES
calls
26
20
24
n
1152
1408
1792
2−64 Security
keys
(256)
5
4
5
AES
calls
30
24
30
with 128-bit keys. To provide the security bounds of the three constructions, we need to ﬁx the
security bounds of functions F and F0. As far as we know, the best key recovery attacks on AES
without leakage [BKR11] require a complexity of 2126.1 with 288 data. However, our functions
being executed at most twice (resp. 6 times) with the same secret keys for 2−40 security (resp.
for 2−64 security), such a complexity is unreachable. We use this bound in a conservative way, to
bound the security of the pseudo-random functions. As for the leakage, we give the adversary λ
bits of useful information by leaking query. Nevertheless, until now it remains unclear how these
λ bits of information in a single trace may reduce the security bound of the AES. In [VGS14]
for instance, the authors show that a single trace on the AES might give the adversary all the
required knowledge to recover the secret key, namely, when a suﬃcient number of noisy Ham-
ming Weight values are available. But summing the useful information of these noisy Hamming
Weight values would give a very large λ for which we cannot guarantee anything. However, we
can expect either a larger amount of noise, a desynchronization of the traces or a low leaking
from the inherent component which would result in a reasonable value for λ. In this case, we
can ﬁx εF = εF0 ≈ 2−127. The resulting security bounds are given in Table 6.1 with the size n
of the internal state, the number of 128 or 256-bit keys and the number of AES calls in function
next, for 2−40 and 2−64 security.
The best instantiation in terms of complexity is the construction from [FPS12]. This is not
surprising considering the advantageous binary shape of this function. However, if we relax
the security assumptions on the AES with εF = εF0 = 2−126 for security of the pseudo-random
functions, the conditions of the security proof are not met and therefore we cannot guarantee
its security based on Corollary 20. In these speciﬁc cases, our construction seems to be the best
one to use since it guarantees that the conditions of the security proof are met. Note that for
2−64 security, as explained below, we cannot get a provable security with 128-bits input blocks,
and we need εF and εF0 to be smaller than 2−200, and then use AES with 256-bit keys.
Since the implementation built from [FPS12] appears to be the best one in the general case,
we implement it to compare it with the benchmarks of Section 4.6. As in Section 4.6, we use
fb_mul_lodah and fb_add from RELIC open source library [AG], extended with the necessary
ﬁelds (F2489, deﬁned with X489 + X83 + 1 and F2896, deﬁned with X896 + X7 + X5 + X3 + 1). We
use public functions aes_setkey_enc and aes_crypt_ctr from PolarSSL open source library [Pol].
As in [DPR+13], we measure the number of CPU cycles for a recovering process and a key
generation process. The CPU cycles count is done using ASM instruction RDTSC, our C code is
optimized with O2 ﬂag. We simulate a full recovery of the generetor for [FPS12] and [DPR+13]
implementations, with an input containing one bit of entropy per byte. Then, 8 inputs of size 489
bits are necessary to recover from a compromise for [DPR+13], whereas, for [FPS12], 8 inputs of
size 896 bits are necessary. Then we simulate the generation of 2048-bit keys that each requires
— 109 —
Chapter 6. Robustness Against Side-Channel Attacks
16 calls to next, as every call outputs 128 bits. Figure 6.8 gives the numbers of CPU cycles
for 100 complete recovering experiments (left) and 100 key generations (right) for [DPR+13]
and [FPS12]. Both processes require on average 4 times less CPU cycles to perform for [FPS12]
implementation than for [DPR+13] implementation.
CPU Cycles
CPU Cycles
1.5 ×105
1 ×105
0.5 ×105
0
25 50 75 100
0
Recovering Experiments
[FPS12]
[DPR+13]
Exp. index
3 ×105
2 ×105
1 ×105
0
0
[FPS12]
[DPR+13]
Key index
25 50 75 100
Key Generations
Figure 6.8 – Benchmarks Between [FPS12] and [DPR+13]
The Tweaked Binary Tree Instantiation. We ﬁrst recall the constraints (Theorem 20): the
quality of the pseudo-random number generator is measured by
ε ≤ qqn ·(cid:16)(qr
2m+1−δ + 3(2κ · εF + εF0)(cid:17) + qn
√
2(2 log2(κ) + νκ)/2µ,
2 + 1) ·
for δ = min{n − log qr, γ∗ − λ}.
With qr = qn = qs = 2k, we get:
ε ≤ 3 · 22k ·(cid:16)(22k + 1) ·
≤ ε1 + ε2 + ε3 + ε4
√
2m+1−δ + 3(2κ · εF + εF0)(cid:17) + (2 log2(κ) + νκ) · 22k/2µ
where
• ε1 = 24k+2+(m+1−δ)/2,
• ε2 = 18κ · 22k · εF,