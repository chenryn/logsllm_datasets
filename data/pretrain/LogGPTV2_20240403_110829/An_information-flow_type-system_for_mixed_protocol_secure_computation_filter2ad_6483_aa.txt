title:An information-flow type-system for mixed protocol secure computation
author:Florian Kerschbaum
An Information-Flow Type-System for
Mixed Protocol Secure Computation
Florian Kerschbaum
SAP Applied Research
Karlsruhe, Germany
ﬂPI:EMAIL
ABSTRACT
There are a number of domain-speciﬁc programming lan-
guages for secure computation. Out of those, the ones that
are based on generic programming languages support mix-
ing diﬀerent protocol primitives and enable implementing a
wider, possibly more eﬃcient range of protocols. On the one
hand, this may result in better protocol performance. On
the other hand, this may lead to insecure protocols. In this
paper we present a security type system that enables mix-
ing protocol primitives in a generic programming language,
but also ensures that well-typed programs are secure in the
semi-honest model. Consequently, a compiled protocol must
be secure. We show an extension of the L1 language with
our security type system and evaluate the implementation
of two protocols from the literature. This shows that our
type system supports the provably secure implementation
even of complex protocols.
Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection—
Cryptographic controls; D.3.4 [Programming Languages]:
Processors—Compilers
General Terms
Security, Programming Languages
Keywords
Secure Two-Party Computation, Type System, Program-
ming, Domain-Speciﬁc Language, Information Flow
1.
INTRODUCTION
Secure (two-party) computation [37] allows two parties to
compute a function f over their joint, private inputs x and
y, respectively. No party can infer anything about the other
party’s input (e.g. y) except what can be inferred from one’s
own input (e.g. x) and output (e.g. f (x, y)). Secure compu-
tation has many applications, e.g. in the ﬁnancial sector, and
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIA CCS’13, May 8–10, 2013, Hangzhou, China.
Copyright 2013 ACM 978-1-4503-1767-2/13/05 ...$15.00.
has been successfully deployed in commercial and industrial
settings [5, 6, 7, 23].
Secure computation protocols are notoriously diﬃcult to
implement. First, they can encompass arbitrary functional-
ity in the joint computation. Second, they need to follow a
rigorous approach to security. Often special protocols – mix-
ing several diﬀerent primitives – are developed for important
problems. This is expected to provide more eﬃcient proto-
cols due to insight into the problem domain [16]. These
protocols then require a manual veriﬁcation and security
proof.
Current domain-speciﬁc programming languages for se-
cure computation [2, 4, 9, 18, 19, 28, 35] do not adequately
address these problems. Either they are tied to a speciﬁc
protocol [2, 4, 18, 28] or they enable implementing inse-
cure protocols [9, 19, 35]. On the one hand, if they are
tied to a speciﬁc protocol, then this protocol may be proven
secure manually independent of the functionality. Such a
proof extends to all protocols implemented in this language,
but the language prevents implementing many special, pos-
sibly more eﬃcient protocols. On the other hand, if the
programming language is built upon a generic programming
language, such as Python [9] or Java [19, 35], all special pro-
tocols can be implemented. Yet, this allows the programmer
to also implement insecure protocols that do not withstand
security veriﬁcation.
In this paper we address this problem in a novel way. We
build upon the L1 language [35] which is a domain-speciﬁc
language extension for secure computation based on Java
that allows mixing several diﬀerent protocol primitives. Al-
though we use this speciﬁc language, our approach is generic
and can be adapted for any domain-speciﬁc language that
allows mixing protocols and is not tied to a protocol, e.g. [9,
19]. We augment the L1 language with a novel security type
system. This type system provably ensures that well-typed
programs are secure in the semi-honest model of secure com-
putation. Loosely speaking, in the semi-honest model – as
deﬁned by Goldreich [15] – all parties follow the protocol
description, but may keep a record of the interaction and
try to infer additional information about the other party’s
input. Protocols secure in the semi-honest model provably
prevent any such inference which includes many real-world
attacks, such as insider attacks.
Through the use of the type system the compiler statically
veriﬁes the security of the protocol during compilation. Only
secure protocols are compiled. The programmer is immedi-
ately notiﬁed about any (possible) security violation.
We evaluate our security type system for the L1 language
by implementing two examples. The ﬁrst one is a simple
multiplication protocol based on [14]. The second one is
a complex protocol for privacy-preserving string processing
from [21]. This example shows that even such protocols –
using a wide variety of protocol primitives in intricate ways
– can be eﬀectively implemented in our type system. Fur-
thermore, the security proof of our type system also extends
to this new implementation. This underpins the protocol’s
manual security proof from [21] by formal veriﬁcation.
In summary, this paper contributes
• a security type system for mixed protocol secure com-
putation.
• an integration of this type system into the L1 language.
• a proof that any well-typed program is secure in the
semi-honest model.
• an evaluation using two exemplary protocols for mul-
tiplication and substring creation. This shows that
implementing any functionality and even complex pro-
tocols using our type system is feasible.
The remainder of this paper is structured as follows. In
Section 2 we review the related work in secure computa-
tion and security type systems. Section 3 reviews the pro-
tocol primitives implemented for secure computation and
Section 4 reviews the L1 language. Sections 5 and 6 present
our main results. Section 5 describes how re-randomization
is implemented and Section 6 describes the security type
system. We show our examples in Section 7 and conclude
the paper in Section 8.
2. RELATED WORK
Our work is related to domain-speciﬁc languages (and ex-
tensions) for secure computation [2, 4, 9, 18, 19, 28, 32, 35]
and type systems for information ﬂow security [12, 29, 34,
36].
Domain-speciﬁc languages (DSL) for secure computations
can be coarsely classiﬁed into those based on a speciﬁc se-
cure computation protocol, such as [2, 4, 18, 28], and those
that extend a generic programming language [9, 19, 35].
DSLs based on speciﬁc secure computation protocols im-
plement functionality solely based on those protocols. This
may not limit implementable functionality, since these pro-
tocols are generic and support any functionality, but it may
limit performance, since problem-speciﬁc protocol primitives
are usually expected to yield better eﬃciency. Nevertheless,
once the speciﬁc protocols is proven secure, any implemented
functionality is also secure.
The ﬁrst such domain-speciﬁc language for secure compu-
tation was FairPlay [28]. It implemented Yao’s two-party,
garbled circuit protocol [37]. It was later extended to multi-
party computations in [2] based on the multi-party version
of Yao’s protocol [1]. It introduced the SFDL programming
language which provided an abstraction of the ideal func-
tionality, i.e. the function computed by the secure protocol.
Programs in SFDL are translated into a binary circuit which
is interpreted using Yao’s protocol. Secure multi-party com-
putations were also implemented by ShareMind [4] based on
the information-theoretically secure protocol of [3]. Its pro-
gramming language is rather simplistic and resembles ma-
chine language. This makes programming harder, but also
makes it easier to ensure security. All these single primitive
DSLs generally suﬀer from poor performance of the com-
piled protocols. Mixing primitives in a DSL, such as Yao’s
protocol and homomorphic encryption, was introduced in
TASTY [18]. Nevertheless, they restricted themselves to one
provably secure protocol of [25] and enabled annotations in
the language naming the primitive to use.
DSLs as extensions of existing, generic programming lan-
guages can implement any protocol based on mixing (al-
most) arbitrary primitives. This allows implementing the
most eﬃcient protocols, but also does not prevent the pro-
grammer from making mistakes and implementing insecure
protocols. The ﬁrst such language is VIFF [9] based on
the Python language. Although it is catered for the multi-
party protocol using linear secret sharing of [8] which is also
considered as the basis for the related SCML programming
language of [32], in its implementation it supports the full
power of Python. Similar extensions have been presented for
the Java language [19, 35]. The framework of [19] is based
on Yao’s protocol [37] and currently produces the most ef-
ﬁcient protocols, but provides very little language support.
A signiﬁcant portion of its eﬃciency gain is based on opti-
mizations by the programmer, which also invites mistakes
likely at the expense of security. Implementing some such
optimizations in the compiler was proposed in [22].
Our security type system is based on the L1 language [35]
for mixed protocol secure computation, although it can be
adapted for other mixed-protocol languages. This language
also currently provides little support to the programmer for
protocol security.
Our idea of supporting security in a programming lan-
guage by a type system has been applied to information ﬂow
security. Information ﬂow is concerned with conﬁdentiality
breaches between principals in computer systems [26]. Its
lattice policy model of security levels has been introduced
in [10]. Later, it was shown that compliance with such a
policy can be statically veriﬁed given the program source
code [11]. Volpano et al. were the ﬁrst to recognize that
these policies can also be implemented using a type sys-
tem [36]. Their type system also inﬂuenced our construction
of our secure computation security type system.
Since type systems can be eﬀectively handled by program-
mers as well as compilers, this sparked recent interest in
language-based information ﬂow security. A very good sur-
vey of current research can be found in [34]. There is also
an implementation of a type system for information ﬂow
security in Java called JIF [29].
Recently information ﬂow types have been applied to ho-
momorphic encryption [12]. These do not yet cover se-
cure computations using homomorphic encryption, since all
secure computations involve admissible information ﬂows.
Therefore the basic typing assumption of non-interference
does not hold in secure computation. Our security type sys-
tem must therefore cater for a more complicated use case.
3. SECURE COMPUTATION
We implement secure computations using the primitives
of homomorphic encryption, secret sharing, garbled circuits
and oblivious transfer. These primitives can be combined in
many ways and even potentially result in an insecure proto-
col. For simplicity we only consider secure two-party com-
putation.
3.1 Homomorphic Encryption
Secure computation can be implemented based on addi-
tively homomorphic encryption. On the one hand, opposed
to fully homomorphic encryption [13] additively homomor-
phic encryption only implements addition (modulo a key-
dependent constant) as the homomorphic operation. On the
other hand, additively homomorphic encryption is as fast as
standard public-key cryptography.
Let EX (x) denote the encryption of plaintext x encrypted
under X’s (Alice’s or Bob’s) public key and DX (c) the cor-
responding decryption of ciphertext c. Then the homomor-
phism can be expressed as
DX (EX (x) · EX (y)) = x + y
The following property can be easily derived
DX (EX(x)y) = xy
In our implementation we mainly use Paillier’s encryption
system [33], although our language also supports diﬀerent
encryption systems such as Naccache-Stern [31] and allows
the programmer to extend the available encryption systems.
Paillier’s and Naccache-Stern’s encryption systems are not
only public-key, but also secure against chosen plaintext at-
tacks (IND-CPA). This semantic security implies that two
diﬀerent ciphertexts – even of the same plaintext – cannot
be distinguished (without the private key).
In secure computation based on homomorphic encryption
it is usually suﬃcient to use one key per party. Our type
system - diﬀerently than [12] – therefore does not protect
against mixing ciphertexts from diﬀerent keys.
3.2 Secret Sharing
In order to implement the full functionality of secure com-
putation we augment homomorphic encryption with secret
sharing. Each variable is secretly shared between Alice and
Bob. Let x be the variable secretly shared and p be the
modulus of the homomorphic encryption. Then Alice has
xA and Bob has xB, such that
x = xA + xB mod p
In the following we show how secret sharing and homo-
morphic encryption can be used to implement any function-
ality in secure computation. Many other combinations of
homomorphic encryption and secret sharing may already be
insecure, e.g. by revealing dependent shares.
In order to
implement any ideal functionality it suﬃces to implement
addition and multiplication. Addition of x = xA + xB and
y = yA + yB (of the same bit-length l) can be implemented
locally by addition of each party’s shares. Multiplication
z = x · y needs to be implemented as a protocol. Let r be
a uniformly random number in Zp. We use the commonly
used protocol in Figure 1 from [14].
A −→ B EA(xA), EA(yA)
B −→ A EA(c) = EA(xA)yB EA(yA)xB EA(r)
A
B
zA = xAyA + c mod p
zB = xByB − r mod p
It is easy to verify that zA + zB = (xA + xB)(yA + yB).
Figure 1: Multiplication Protocol
3.3 Oblivious Transfer
Oblivious transfer (OT) is a protocol between a sender and
a receiver. As input the sender has n messages x0, . . . , xn−1
and the receiver has an index i (0 ≤ i < n). After the
protocol the receiver obtains xi as output. A secure OT
protocol ensures that the sender has not learnt i and the
receiver has learnt nothing about the other messages xj (j 6=
i).
OT can be used as a primitive in mixed secure computa-
tions. It facilitates a distributed “if” statement, where one
party has the results of the branches and the other party
the condition. Furthermore, although we do not implement
this protocol in our language, OT can also be used as the
sole primitive to implement generic secure computation pro-
tocols [15].
There are a number of eﬃcient implementations of OT
including [30]. Nevertheless, all OT involve some public key
operations. In [20] the authors describe a technique to ex-
tend a constant number of OTs to polynomially many OTs
using symmetric cryptography.
3.4 Garbled Circuits
Yao introduced secure two-party computation in [37]. He
uses a technique called garbled circuits. Garbled circuits al-
low the computation of any function, but in our language we
combine garbled circuits with secret shares and somewhat
restrict its functionality. Our restriction is that each input
and output (function result) must be a secret share. Let
Alice’s input be a and Bob’s input b which both may be a
secret share. Let f be the function to be computed using
garbled circuits. We then automatically augment the circuit
using an additional input r by the circuit encryptor. The
circuit then computes the function f ′:
f ′(a, b, r) = f (a, b) − r
The circuit encryptor obtains no output from the secure
computation, but uses its locally chosen r as return value.
The circuit decryptor obtains the new function result f ′.
These two return values are secret shares of the function re-
sult f (a, b) which can be subsequently used in computations
using homomorphic encryptions or garbled circuits.
Secrets as inputs are automatically reconstructed at the
beginning of the function. For example, let xA, yA and xB,
yB be shares of x and y, respectively. Then the function
f (x, y) = x < y to compare x and y is implemented as
follows:
f ′′(xA, yA, xB, yB, r) = ((xA + xB) < (yA + yB)) − r
4. THE L1 LANGUAGE
We extend the L1 language [35] for mixed-protocol secure
computation with our security type system. L1 is a sim-
pliﬁcation and extension of Java that incorporates features
to better support secure computation. The two L1 features
important for this paper are messaging support and player-
speciﬁc code.
Messaging support enables the parties to send each other
messages.
It is implemented using a framework for asyn-