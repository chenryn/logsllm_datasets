Custome Proxy ❸ observes the trigger event and notifies Our Server ❺
Table 5: Example of applet execution timeline: A2 under E2.
t (s)
0
0.04
0.16 ❸ receives the confirmation from trigger service ❺
81.1
82.1
83.0
83.8
IFTTT engine ❼ polls trigger service ❺ about the trigger
IFTTT engine ❼ sends action request to action service ❺
Aftering querying ❺, ❸ sends the action to the IoT device
Test controller ❾ confirms that the action has been executed
Our Service ❺). Over a period of three days, the testbed executed
each applet 50 times at different time. Before each test, we ensure
both local WiFi and the Internet connectivity are good through
active probing so the network never becomes the performance
bottleneck. For better visualization, we group the latency of A1 to A4
and A5 to A7 together, because within each group the performance
is qualitatively similar. We first examine A1 to A4. Their T2A latency
values are not only large, but also highly variable, with the 25-th,
50-th, and 75-th percentiles being 58s, 84s, and 122s, respectively.
This may not be a big issue for “non-real-time” applets such as A4,
However, for applets like A2 (using a smart switch to turn on a light),
such a long and highly variable latency degrades user experience.
In the extreme case, the T2A latency can reach 15 minutes.
To find out the cause of such high latency and variance, we
replace the involved service entities with our own implementation,
which is known to be performance-wise efficient. We design the
following three experiments and run them on our testbed.
• E1: replace the official trigger service (e.g., Hue Service ❻) with
Our Service ❺.
• E2: replace the trigger and action services with Our Service ❺.
• E3: in addition to E2, further replace the IFTTT engine ❼ with our
own implementation that follows the IFTTT protocol and performs
frequently polling (every 1 second).
Figure 5 plots the T2A latency for A2 under scenarios E1/E2 and
E3 (for each scenario we run 20 tests). The results clearly indicate
that the performance bottleneck is the IFTTT engine itself, as E3
dramatically reduces the T2A latency compared to E1 and E2 that
exhibit similar performance. Specifically, we observe that IFTTT
employs very long polling interval that dominates the overall T2A
latency. To illustrate this, Table 5 exemplifies the breakdown of the
T2A latency for a typical execution of applet A2 under the scenario
E2. As shown, our service ❺ is notified about the trigger event at
Figure 6: Two examples of sequen-
tial applet execution.
Figure 7: Example of
concurrent applet exe-
cution.
t=0.16 sec; but the polling request from the IFTTT engine ❼ arrives
much later at t=81.1 sec.
Besides performing regular polling, IFTTT also provides real-
time API, which allows a trigger service to proactively send a
notification to IFTTT about a trigger event. Through experiments,
we find that using the real-time API brings no performance impact
for our service (figure not shown). Note the real-time API merely
provides hints to the IFTTT engine, which still needs to poll the
service to get the trigger event delivered. In other words, the IFTTT
engine has full control over trigger event queries and very likely
ignores real-time API’s hints. We provide more discussions in §6.
Another observation relates to the low T2A latency of A5 to A7
in Figure 4. Since they all use Alexa as the trigger, it is likely that
IFTTT customizes the polling frequency or more likely, processes
the real-time API hints for some services (such as Alexa) with timing
requirements. But as indicated by our previous results (e.g., A2),
such customization does not yet cover all applets requiring low
latency. When we use our own service to host Alexa, its latency
becomes large.
Sequential Execution of Applets. We next test the perfor-
mance when a trigger is activated multiple times sequentially (every
5 seconds in our experiment). As exemplified in the top part of
Figure 6, due to the long and highly variable polling latency, 119
seconds later, the action associated with the first trigger is executed
together with a cluster of subsequent actions. The second and third
cluster come at 247 and 351 seconds respectively. The actions are
sequentially mapped to triggers but the actions’ timing is “reshaped”
by IFTTT. Such a clustered pattern, which is observed from all
triggers for A1 to A4, is caused by the batched process of IFTTT
polling. Upon receiving a polling query, the trigger service should
return many buffered trigger events (up to k) to IFTTT. k is a
parameter in the polling query (50 by default). Because each polling
query response contains multiple trigger events, the resulting
actions naturally form a cluster. The bottom part of Figure 6 shows
one extreme case (possibly when IFTTT experiences high workload)
where the polling delay between two clusters inflate to 14 minutes.
0100200300400when email arrives, blink hue lightTriggerAction05001000store gmail attachment to google driveTime (second)-60 0 60 120  CDF00.20.40.60.81T2A Latency Diff. (s)IMC ’17, November 1–3, 2017, London, UK
Xianghang Mi et al.
Concurrent Execution of Applets. Users can create two
applets with the same trigger, say “if A then B” and “if A then
C” to realize “if A then B and C”. When A is triggered, ideally B
and C should be executed at the same time. Figure 7 plots the CDF
for T2A latency difference between “turn on Hue light when email
arrives” and “activate WeMo switch when email arrives”, which
share the same trigger, across 20 tests. As shown, the T2A latency
difference ranges from -60 to 140 seconds. This is because (1) the
polling delay is highly fluctuating, and (2) the polling response
of one applet cannot be piggybacked with that of another applet.
The results indicate that in reality, IFTTT cannot guarantee the
simultaneous execution of two applets with the same trigger. This
may cause unexpected results to end users (e.g., a user wants to use
a smart switch to turn on the heat and close the window).
Infinite Loop. Multiple applets can be chained in IFTTT. How-
ever, users may misconfigure chained applets to form an “infinite
loop” e.g., A triggers B, which further triggers A. An infinite
loop may waste resources and even damage the IoT equipment.
Through experiments, we confirm that despite a simple task, no
“syntax check” is performed by IFTTT to detect a potential infinite
loop. Furthermore, we also experimentally confirm that an infinite
loop may be jointly triggered by IFTTT and 3rd-party automation
services. For example, a user applies the following IFTTT applet:
add a row in my Google Spreadsheet when an email is received.
Meanwhile, the user has also enabled in her spreadsheet the
notification feature [12], which sends her an email if the spreadsheet
is modified. The applet and the enabled notification thus cause an
implicit infinite loop. Since IFTTT is not aware of the latter, it
cannot detect the loop by analyzing the applets offline. Instead,
some runtime detection techniques are needed.
5 RELATED WORK
IFTTT Characterization. Ur et al. investigated the human factor
of trigger-action programming in smart home [27]. As a part of
the study, they collected 67K IFTTT recipes (i.e., applets) in 2013
to demonstrate that users can possibly create a large number of
combinations of triggers and actions. A follow-up CHI note [28]
by the same authors analyzed basic statistics of 224K IFTT recipes
crawled in 2015. Surbatovich et al. [25] used the dataset of [28] to
analyze the security and privacy risks of IFTTT recipes. Huang et
al. [19] investigated how to make IFTTT-style TAP better fit users’
mental model. Our study distinguishes from the above in several
aspects. First, we provide an up-to-date characterization of the
IFTTT ecosystem with new observations that differ from previous
measurements (e.g., the dominance of IoT services described in §3.2).
Second, we build a real IFTTT testbed and show the interaction
among different entities in the ecosystem. Third, we conduct
experiments to analyze the applet execution performance.
IFTTT-like Platforms. There also exist commercial platforms
such as Atooma [2], WigWag [14], Android Tasker [11], Zipato [15],
Stringify [10] and WayLay [13]. Some use more complex languages
such as flowchart [10] or even Bayesian Networks [13]. All of them
have registered less popularity compared to IFTTT.
Trigger-action Programming (TAP) has been studied for
more than a decade. It is oftentimes used in automation for smart
homes [17, 21, 26, 29, 30], smart buildings [22], and general IoT/context-
aware systems [16, 18, 20, 23]. We instead conduct an empirical
study of IFTTT, the most popular commercial TAP platform [19].
6 DISCUSSIONS AND CONCLUSIONS
Performance Improvements. We observe that oftentimes the
T2A latency, which is dominated by the polling delay, is long and
highly variable2. Instead of doing polling, an effective way to reduce
the latency is to perform push (or utilize the real-time API with
the same concept). However, we believe there are reasons why
IFTTT has not yet fully adopted this approach3. One reason we can
possibly imagine is that, if all trigger services perform push, the
incurred instantaneous workload may be too high: IoT workload is
known to be highly bursty [24]; for IFTTT it is likely also the case
(consider popular applets such as “update wallpaper with new NASA
photo”). On the other hand, this creates opportunities for predicting
the trigger events to perform polling smartly or provisioning the
resources for accepting more real-time hints. Such optimizations
only need to apply to top applets that dominate the usage (Figure 3).
Distributed Applet Execution. For now, all applet executions
need to be handled by the centralized IFTTT engine. In fact, many
applets can be executed fully locally by using users’ smartphones
or tablets as a local IFTTT engine. In this way, the scalability of
the system can be dramatically improved. Nevertheless, designing
such a hybrid (centralized + distributed) applet execution scheme
is challenging in many aspects: what are users’ incentives for
adopting the local version (maybe better privacy or operating
without Internet)? How to determine which applets to execute
locally? How to quickly recover when the local IFTTT engine goes
down? More research is needed in this direction.
Permission Management. We notice that IFTTT performs
coarse-grained permission control at the service level: for a service
involved in any trigger or action installed by the user, IFTTT will
need all permissions of the service. For example, installing an
applet with the trigger “new email arrives” requires permissions
for reading, deleting, sending, and managing emails. This facilitates
the usability (as the user will not be bothered when future applets
involving the same service are installed) but incurs potential
security issues (as the “least privilege principle” is violated). We
need better permission management schemes that balance the
tradeoff between usability and security.
Limitations. We acknowledge that observing the IoT ecosystem
from the perspective of IFTTT is interesting but still limited as
IFTTT may not cover all available IoT devices and their owners.
To conclude, in this study, we observe the fast growth of the
IFTTT ecosystem and its increasing usage for automating IoT-
related tasks, which correspond to 52% of services and 16% of the
applet usage. We observe several performance inefficiencies and
identify their causes. We plan to study future IFTTT features such
as queries and conditions [25].
ACKNOWLEDGEMENTS
We would like to thank our shepherd, Hamed Haddadi, and the
anonymous reviewers for their valuable comments and suggestions.
This research was supported in part by the National Science
Foundation under grant #1629347 and #1566331.
2We contacted IFTTT and they confirmed this issue.
3In their response, IFTTT said that they were working on the push support.
An Empirical Characterization of IFTTT: Ecosystem, Usage, and Performance
IMC ’17, November 1–3, 2017, London, UK
REFERENCES
[1] Amazon echo - what we know now (updated). http://files.constantcontact.com/
150f9af2201/70c07fdd-a197-4505-9476-e83aa726f025.pdf.
Proceedings of the 2014 ACM International Joint Conference on Pervasive and
Ubiquitous Computing, pages 105–115. ACM, 2014.
[22] A. A. Nacci, B. Balaji, P. Spoletini, R. Gupta, D. Sciuto, and Y. Agarwal.
Buildingrules: a trigger-action based system to manage complex commercial
buildings. In Adjunct Proceedings of the 2015 ACM International Joint Conference on
Pervasive and Ubiquitous Computing and Proceedings of the 2015 ACM International
Symposium on Wearable Computers, pages 381–384. ACM, 2015.
[23] M. W. Newman, A. Elliott, and T. F. Smith. Providing an integrated user experience
of networked media, devices, and services through end-user composition. In
International Conference on Pervasive Computing, pages 213–227. Springer, 2008.
[24] M. Z. Shafiq, L. Ji, A. X. Liu, J. Pang, and J. Wang. A first look at cellular machine-to-
machine traffic: large scale measurement and characterization. ACM SIGMETRICS
Performance Evaluation Review, 40(1):65–76, 2012.
[25] M. Surbatovich, J. Aljuraidan, L. Bauer, A. Das, and L. Jia. Some recipes can
do more than spoil your appetite: Analyzing the security and privacy risks of
ifttt recipes. In Proceedings of the 26th International Conference on World Wide
Web, pages 1501–1510. International World Wide Web Conferences Steering
Committee, 2017.
[26] K. Tada, S. Takahashi, and B. Shizuki. Smart home cards: tangible programming
with paper cards. In Proceedings of the 2016 ACM International Joint Conference
on Pervasive and Ubiquitous Computing: Adjunct, pages 381–384. ACM, 2016.
[27] B. Ur, E. McManus, M. Pak Yong Ho, and M. L. Littman. Practical trigger-action
programming in the smart home. In Proceedings of the SIGCHI Conference on
Human Factors in Computing Systems, pages 803–812. ACM, 2014.
[28] B. Ur, M. Pak Yong Ho, S. Brawner, J. Lee, S. Mennicken, N. Picard, D. Schulze,
and M. L. Littman. Trigger-action programming in the wild: An analysis of
200,000 ifttt recipes. In Proceedings of the 2016 CHI Conference on Human Factors
in Computing Systems, pages 3227–3231. ACM, 2016.
[29] M. Walch, M. Rietzler, J. Greim, F. Schaub, B. Wiedersheim, and M. Weber.
homeblox: making home automation usable. In Proceedings of the 2013 ACM
conference on Pervasive and ubiquitous computing adjunct publication, pages 295–
298. ACM, 2013.
[30] J.-b. Woo and Y.-k. Lim. User experience in do-it-yourself-style smart homes.
In Proceedings of the 2015 ACM international joint conference on pervasive and
ubiquitous computing, pages 779–790. ACM, 2015.
[2] Atooma. https://www.atooma.com/.
[3] Google APIs. https://console.developers.google.com/.
[4] IFTTT. https://ifttt.com/.
[5] IFTTT API (2017). https://platform.ifttt.com/docs/api_reference.
[6] IFTTT Egg Minder Service. https://ifttt.com/eggminder.
[7] OAuth 2.0. https://oauth.net/2/.
[8] Philips Hue. http://www2.meethue.com/en-us/.
[9] Philips Hue API. https://www.developers.meethue.com/philips-hue-api.
[10] Stringify. https://www.stringify.com/.
[11] Tasker for Android. http://tasker.dinglisch.net/.
[12] Turn on notifications in a Google spreadsheet. https://support.google.com/docs/
answer/91588.
[13] Waylay.io. http://www.waylay.io/index.html.
[14] WigWag smart home. https://www.wigwag.com/home.html.
[15] Zipato. https://www.zipato.com/.
[16] F. Cabitza, D. Fogli, R. Lanzilotti, and A. Piccinno. End-user development in
ambient intelligence: a user study. In Proceedings of the 11th Biannual Conference
on Italian SIGCHI Chapter, pages 146–153. ACM, 2015.
[17] L. De Russis and F. Corno. Homerules: A tangible end-user programming interface
for smart homes. In Proceedings of the 33rd Annual ACM Conference Extended
Abstracts on Human Factors in Computing Systems, pages 2109–2114. ACM, 2015.
[18] A. K. Dey, T. Sohn, S. Streng, and J. Kodama. icap: Interactive prototyping of
context-aware applications. In International Conference on Pervasive Computing,
pages 254–271. Springer, 2006.
[19] J. Huang and M. Cakmak. Supporting mental model accuracy in trigger-action
programming. In Proceedings of the 2015 ACM International Joint Conference on
Pervasive and Ubiquitous Computing, pages 215–225. ACM, 2015.
[20] C.-J. M. Liang, B. F. Karlsson, N. D. Lane, F. Zhao, J. Zhang, Z. Pan, Z. Li, and Y. Yu.
Sift: building an internet of safe things. In Proceedings of the 14th International
Conference on Information Processing in Sensor Networks, pages 298–309. ACM,
2015.
[21] S. Mennicken, J. Vermeulen, and E. M. Huang. From today’s augmented houses
to tomorrow’s smart homes: new directions for home automation research. In