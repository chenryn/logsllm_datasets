relatively high, up to 10,233, as compared with the no FN
achieved by ReDoSHunter. In terms of FP, the number of FPs
of baselines range from 0 to 2,348, with an average of 379.42
((5 + 288 + 13 + 2348 + 2 + 0 + 0) / 7 = 379.42). Some
baselines have no FP at the cost of many FNs, resulting in
poor recall (e.g., 1.08% achieved by SDL). The experiment
result shows that ReDoSHunter can precisely detect far more
vulnerabilities than any baselines.
In addition, we analyze the vulnerabilities commonly de-
tected by each tool to further evaluate the effectiveness of Re-
DoSHunter. As shown in Figure 6 (Venn diagram), the amount
of vulnerabilities detected by all baselines is still less than that
of ReDoSHunter (in yellow). Besides, there are 4,487 ReDoS-
vulnerabilities uniquely detected by ReDoSHunter, whereas
no vulnerabilities can be uniquely detected by any baselines.
These experiment results demonstrate that ReDosHunter is
signiﬁcantly more effective than all baselines in the detection
of ReDoS vulnerabilities.
5000
4000
3000
2000
1000
l
.
n
u
V
#
n
o
i
t
c
e
s
r
e
t
n
I
0
SDL
ReScue
RXXR2
NFAA
Regexploit
Rexploiter
safe−regex
ReDoSHunter
#Vuln.
112
188
224
975
1051
2052
3760
10345
12500
10000
7500
5000
2500
0
labels
NFAA
ReDoSHunter
Regexploit
ReScue
Rexploiter
RXXR2
safe−regex
SDL
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
Figure 6: An Illustration of Effectiveness of ReDoSHunter
in Java-8. The bar chart in the left-hand side shows the total
number of ReDoS-vulnerabilities detected by each tool. The
Venn diagrams illustrates the intersection of detected vulnera-
bilities of each tool. The two vertical bar charts together show
the number of ReDoS-vulnerabilities (the upper vertical bar
chart) that can be detected uniquely by the corresponding
tools (the lower vertical bar chart with lined dots to represent
the use of the corresponding tools).
4.2.2 Evaluation on Different Regex Engines
Some regexes may not be ReDoS-vulnerable on spe-
ciﬁc engines with particular implementation optimiza-
tions. Let us consider the regex mentioned in §2 again
([0-9]*)+(\.[0-9]+)+, it is ReDoS-vulnerable in Python
2/3, Java-8 and Node.js 4-16, but not in Java-13. Therefore,
we use multiple regex engines for TP, FP, FN, precision, and
recall evaluation as shown in Table 8.
The precision and recall of baselines vary across regex
engines. For example, NFAA achieves a 98.68% precision
on the Java-8 engine but 85.22% precision on the Node.js-14
engine. In constrast, ReDoSHunter uniformly achieves 100%
precision and 100% recall across the engines. The result
demonstrates that ReDoSHunter’s dynamic validation step
can work well across different popular regex engines (Python
2/3, Java 7-15, Node.js 6-14). Furthermore, the numbers of
vulnerabilities in different regex engines also indicate the
performance difference of these engines varies. The more is
the number of vulnerabilities detected, the less is the regex
engine optimized. In our experiments, all eight techniques
detected the most vulnerabilities on Java-8 (compared to Java-
13, Python-3.7 and Node.js-14). In other words, the Java-8
regex engine is the least optimized, whose behavior resembles
the Java-13/Python-3.7/Node.js-14 regex engine.
Corpus
RegExLib
Snort
6.3%
7.2%
13.6%
18.2%
54.7%
13.0%
10.7%
33.6%
14.7%
39.6%
17.7%
16.9%
21.8%
17.3%
14.7%
#Vuln. = 1
#Vuln. = 2
#Vuln. = 3
#Vuln. = 4
#Vuln. ≥ 5
Figure 7: The Distribution Pie Charts of the Number of
ReDoS-Vulnerabilities in Regexes Detected by ReDoSHunter
in Java-8.
4.2.3 Multiple Vulnerabilities in One Regex
According to our observation, in one ReDoS-vulnerable regex,
it has a high probability of containing more than one vulnera-
bility. Figure 7 summarizes the percentage of different number
of vulnerabilities (denoted as #Vuln.) in ReDoS-vulnerable
regexes which were detected by ReDoSHunter. As we can
see from Figure 7, there are more than a half (i.e., 66.4%
and 60.4%) vulnerable regexes from RegExLib and Snort
datasets containing more than one ReDoS-vulnerabilities —
the amount of such regexes is non-negligible. However, the
existing tools neglect this situation and thus are inapplicable
to detect the multi-vulnerabilities in one regex, making it very
likely to have serious consequences by reporting only one
USENIX Association
30th USENIX Security Symposium    3857
vulnerability. The result indicates a urgent need for effective
tools that can identify multiple ReDoS-vulnerabilities from a
vulnerable regex, reﬂecting the usefulness of ReDoSHunter.
4.2.4 Efﬁciency
The efﬁciency of different tools is illustrated in Figure 8.
The left-hand side of the ﬁgure shows the average time of
processing a regex, and right-hand side shows the number
of ReDoS-vulnerable regexes detected within the runtime
showed in the left-hand side. Overall, the static methods are
much faster than dynamic methods, with less than one second
per regex and about one minute per regex, respectively. And
on average, ReDoSHunter has a comparable running time
with static-based methods, taking around one second (1.06
seconds) to process one regex, and apparently outperforms the
dynamic methods (up to 54.15 seconds). Considering the far
more vulnerabilities detected by ReDoSHunter than existing
methods, it is clear that ReDoSHunter is quite efﬁcient.
1.91 · 10−2
2.73 · 10−2
RXXR2
Rexploiter
0.89
NFAA
2 · 10−4
1.39 · 10−2
0.6
54.15
safe-regex
Regexploit
SDL
ReScue
224
2,052
975
3,760
1,051
112
188
1.06
ReDoSHunter
10,345
Runtime (s)
# of ReDoS-vulnerable regexes
Figure 8: Comparison on the Running Time and the Number
of ReDoS-vulnerable Regexes Detected.
4.2.5 Effectiveness of Generated Attack Strings
We further evaluate the effectiveness of attack strings gen-
erated by each tool in terms of the success attack rate (the
number of strings that launch ReDoS attack successfully over
the number of corresponding TPs). The result is shown in
Table 9. Taking Java-8 as an example, we can see that the
attack strings generated by the existing works are not al-
ways effective — the success attack rate ranges from 56.25%
to 96.81%, none of them achieve 100%. The lowest suc-
cess rate (56.25% achieved by SDL) is about half of Re-
DoSHunter (100%). For example, for the ReDoS-vulnerable
regex ^("(\\["\\]|[^"])*"|[^\n])*$ from RegExLib,
the tool RXXR2 generated a failed attack string ‘""’ × n
(i.e., the matching time of the attack string is very fast, e.g.,
when n = 30, 000, it only took 0.002s). Similar situation hap-
pens using different regex engines. Note that comparing with
the unstable success rates achieved by other works (the most
Table 9: The Effectiveness of Generated Attack Strings.
The division formula represents the number of strings that suc-
cessfully launch the ReDoS attack divided by the correspond-
ing TPs. The symbol “–” indicates that the corresponding
tools do not generate attack strings.
Technique
Java-8
Java-13
Python-3.7
Node.js-14
RXXR2
152 / 224
(67.86%)
114 / 216
129 / 213
142 / 219
(52.78%)
(60.56%)
(64.84%)
Reploiter
—
—
—
—
NFAA
724 / 975
(74.26%)
731 / 968
519 / 857
496 / 842
(75.52%)
(60.56%)
(58.91%)
safe-regex
—
—
—
—
Regexploit
SDL
ReScue
989 / 1,051
949 / 1,051
984 / 1,044
944 / 1,032
(94.10%)
63 / 112
(56.25%)
182 / 188
(96.81%)
(90.29%)
(94.25%)
(91.47%)
13 / 108
54 / 98
46 / 102
(12.04%)
(55.10%)
(45.10%)
62 / 183
162 / 175
150 / 179
(33.88%)
(92.57%)
(83.80%)
ReDoSHunter
10,345 / 10,345
10,248 / 10,248
9,807 / 9,807
9,646 / 9,646
(100.00%)