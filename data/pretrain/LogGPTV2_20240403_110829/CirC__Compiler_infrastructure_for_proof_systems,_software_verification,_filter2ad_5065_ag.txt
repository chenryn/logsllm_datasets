M. Walﬁsh, “Verifying computations with state,” in SOSP, Nov.
2013. Extended version: http://eprint.iacr.org/2013/356.
B. Parno, J. Howell, C. Gentry, and M. Raykova, “Pinocchio: Nearly
practical veriﬁable computation,” in IEEE S&P, May 2013.
C. Costello, C. Fournet, J. Howell, M. Kohlweiss, B. Kreuter,
M. Naehrig, B. Parno, and S. Zahur, “Geppetto: Versatile veriﬁable
computation,” in IEEE S&P, May 2015.
[10] A. E. Kosba, C. Papamanthou, and E. Shi, “xJsnark: A framework
for efﬁcient veriﬁable computation,” in IEEE S&P, May 2018.
[11] R. S. Wahby, S. Setty, Z. Ren, A. J. Blumberg, and M. Walﬁsh,
[12]
“Efﬁcient RAM and control ﬂow in veriﬁable outsourced
computation,” in NDSS, Feb. 2015.
J. Eberhardt and S. Tai, “ZoKrates—scalable privacy-preserving
off-chain computations,” in IEEE Blockchain, July 2018.
“ZoKrates.” https://zokrates.github.io/.
“Zinc.” https://zinc.matterlabs.dev/.
J. Baylina, “Circom.” https://github.com/iden3/circom.
“Noir.” https://noir-lang.github.io/book/index.html.
“Leo.” https://developer.aleo.org/aleo/getting started/overview/.
[13]
[14]
[15]
[16]
[17]
[18] C. Chin, H. Wu, R. Chu, A. Coglio, E. McCarthy, and E. Smith,
“Leo: A programming language for formally veriﬁed, zero-knowledge
applications,” 2021. https://ia.cr/2021/651.
[19] Y. Lindell, “Secure multiparty computation (MPC).”
https://eprint.iacr.org/2020/300. To appear in CACM.
[20] V. Vaikuntanathan, “Computing blindfolded: New developments in
fully homomorphic encryption,” in FOCS, Oct. 2011.
[21] C. Barrett, A. Stump, and C. Tinelli, “The SMT-LIB standard:
Version 2.0,” in SMT, 2010.
[22] M. Barnett, B.-Y. E. Chang, R. DeLine, B. Jacobs, and K. R. M.
Leino, “Boogie: A modular reusable veriﬁer for object-oriented
programs,” in FMCO, 2005.
[23] K. R. M. Leino, “Dafny: An automatic program veriﬁer for
functional correctness,” in LPAR, 2010.
[24] N. Bjørner and L. de Moura, “Applications of SMT solvers to
program veriﬁcation,” in Notes for the Summer School on Formal
Techniques, 2014.
[25] Z. Rakamari´c and M. Emmi, “Smack: Decoupling source language
details from veriﬁer implementations,” in CAV, 2014.
[26] E. Torlak and R. Bodik, “A lightweight symbolic virtual machine for
solver-aided host languages,” in PLDI, 2014.
[27] E. Clarke, D. Kroening, and F. Lerda, “A tool for checking ANSI-C
programs,” in TACAS, 2004.
[28] A. Solar-Lezama, L. Tancau, R. Bodik, S. Seshia, and V. Saraswat,
“Combinatorial sketching for ﬁnite programs,” in ASPLOS, 2006.
[29] E. Kneuss, I. Kuraj, V. Kuncak, and P. Suter, “Synthesis modulo
[30]
recursive functions,” in OOPSLA, 2013.
S. Srivastava, S. Gulwani, and J. S. Foster, “From program
veriﬁcation to program synthesis,” in POPL, 2010.
[31] R. Fourer, D. M. Gay, and B. W. Kernighan, AMPL: A Modeling
Language for Mathematical Programming. Boston, MA, USA:
Cengage Learning, 2nd ed., 2002.
[32] W. E. Hart, C. D. Laird, J.-P. Watson, D. L. Woodruff, G. A.
Hackebeil, B. L. Nicholson, and J. D. Siirola, Pyomo-optimization
modeling in Python, vol. 67. Springer, 2017.
[34]
[33] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella, “Fairplay–A secure
two-party computation system,” in USENIX Security, Aug. 2004.
S. T. V. Setty, V. Vu, N. Panpalia, B. Braun, A. J. Blumberg, and
M. Walﬁsh, “Taking proof-based veriﬁed computation a few steps
closer to practicality,” in USENIX Security, Aug. 2012. Extended
version: https://ia.cr/2012/598.
[35] A. Gurﬁnkel and J. A. Navas, “A context-sensitive memory model for
veriﬁcation of C/C++ programs,” in SAS, 2017.
[36] C. Sinz, S. Falke, and F. Merz, “A precise memory model for
low-level bounded model checking,” in SSV, 2010.
[37] C. Cadar, D. Dunbar, and D. R. Engler, “KLEE: Unassisted and
automatic generation of high-coverage tests for complex systems
programs,” in OSDI, 2008.
[38] K. R. M. Leino, “This is Boogie 2.” https://www.microsoft.com/
en-us/research/wp-content/uploads/2016/12/krml178.pdf, 2008.
[39] E. Cohen, M. Moskal, S. Tobies, and W. Schulte, “A precise yet
[40]
efﬁcient memory model for C,” in SSV, Oct. 2009.
I. Yun, S. Lee, M. Xu, Y. Jang, and T. Kim, “QSYM: A practical
concolic execution engine tailored for hybrid fuzzing,” in USENIX
Security, 2018.
[41] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza,
“SNARKs for C: Verifying program executions succinctly and in zero
knowledge,” in CRYPTO, Aug. 2013.
[42] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza, “Succinct
non-interactive zero knowledge for a von Neumann architecture,” in
USENIX Security, Aug. 2014.
[43] C. Lattner and V. Adve, “LLVM: A compilation framework for
lifelong program analysis and transformation,” in CGO, 2004.
S. Arora and B. Barak, Computational Complexity: A Modern
Approach. Cambridge, UK: Cambridge University Press, 2009.
[44]
[45] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and
C. Papamanthou, “vSQL: Verifying arbitrary SQL queries over
dynamic outsourced databases,” in IEEE S&P, 2017.
[46] G. Danezis, C. Fournet, M. Kohlweiss, and B. Parno, “Pinocchio
coin: Building Zerocoin from a succinct pairing-based proof system,”
in PETShop, 2013.
[47] R. S. Wahby, M. Howald, S. Garg, a. shelat, and M. Walﬁsh,
“Veriﬁable ASICs,” in IEEE S&P, 2016.
[48] R. S. Wahby, Y. Ji, A. J. Blumberg, a. shelat, J. Thaler, M. Walﬁsh,
and T. Wies, “Full accounting for veriﬁable outsourcing,” in CCS,
2017.
[49] M. Walﬁsh and A. J. Blumberg, “Verifying computations without
reexecuting them: from theoretical possibility to near practicality,”
CACM, vol. 58, pp. 74–84, Feb. 2015.
J. Thaler, “Proofs, arguments, and zero-knowledge.”
http://people.cs.georgetown.edu/jthaler/ProofsArgsAndZK.pdf.
[50]
[51] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza, “Scalable zero
knowledge via cycles of elliptic curves,” in CRYPTO, Aug. 2014.
[52] M. Fredrikson and B. Livshits, “Zø: An optimizing distributing
zero-knowledge compiler,” in USENIX Security, Aug. 2014.
[53] Y. Xie and A. Aiken, “Saturn: A scalable framework for error
detection using boolean satisﬁability,” in TOPLAS, 2007.
[54] M. W. Hall, J. M. Anderson, S. P. Amarasinghe, B. R. Murphy, S.-W.
Liao, E. Bugnion, and M. S. Lam, “Maximizing multiprocessor
performance with the SUIF compiler,” IEEE Computer, 1996.
[55] C. Lattner, J. A. Pienaar, M. Amini, U. Bondhugula, R. Riddle,
A. Cohen, T. Shpeisman, A. Davis, N. Vasilache, and O. Zinenko,
“MLIR: A compiler infrastructure for the end of Moore’s law.”
https://arxiv.org/abs/2002.11054.
[56] L. Daoud, D. Zydek, and H. Selvaraj, “A survey of high level
[57]
synthesis languages, tools, and compilers for reconﬁgurable high
performance computing,” in ICSS, Apr. 2013.
S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walﬁsh,
“Resolving the conﬂict between generality and plausibility in veriﬁed
computation,” in EuroSys, Apr. 2013.
“libsnark.” https://github.com/scipr-lab/libsnark.
“bellman.” https://github.com/zkcrypto/bellman.
[58]
[59]
[60] A. Ben-David, N. Nisan, and B. Pinkas, “FairplayMP: a system for
secure multi-party computation,” in CCS, Oct. 2008.
[61] W. Henecka, S. K¨ogl, A.-R. Sadeghi, T. Schneider, and
I. Wehrenberg, “TASTY: tool for automating secure two-party
computations,” in CCS, Oct. 2010.
[62] N. B¨uscher, D. Demmler, S. Katzenbeisser, D. Kretzmer, and
T. Schneider, “HyCC: Compilation of hybrid protocols for practical
secure computation,” in CCS, Oct. 2018.
[63] C. Acay, R. Recto, J. Gancher, A. C. Myers, and E. Shi, “Viaduct:
An extensible, optimizing compiler for secure distributed programs,”
in PLDI, 2021.
[64] A. Holzer, M. Franz, S. Katzenbeisser, and H. Veith, “Secure
two-party computations in ANSI C,” in CCS, Oct. 2012.
[65] L. Cordeiro, B. Fischer, and J. Marques-Silva, “SMT-based bounded
model checking for embedded ANSI-C software,” in ASE, 2009.
[66] D. Kroening and M. Tautschnig, “CBMC–C bounded model checker,”
[67]
[68]
in TACAS, 2014.
P. Cuoq, F. Kirchner, N. Kosmatov, V. Prevosto, J. Signoles, and
B. Yakobowski, “Frama-C,” in SEFM, 2012.
F. Kirchner, N. Kosmatov, V. Prevosto, J. Signoles, and
B. Yakobowski, “Frama-C: A software analysis perspective,” in FAC,
2015.
[69] T. Ball, V. Levin, and S. K. Rajamani, “A decade of software model
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:58:36 UTC from IEEE Xplore.  Restrictions apply. 
2263
checking with SLAM,” CACM, vol. 54, pp. 68–76, July 2011.
2020.
[70] T. Ball, E. Bounimova, V. Levin, R. Kumar, and J. Lichtenberg, “The
[102] S. Poeplau and A. Francillon, “Symbolic execution with SymCC:
Static Driver Veriﬁer research platform,” in CAV, 2010.
[71] K. R. M. Leino, P. M¨uller, and J. Smans, “Veriﬁcation of concurrent
programs with Chalice,” in FOSAD, 2009.
[72] B. Jacobs, J. Smans, P. Philippaerts, F. Vogels, W. Penninckx, and
F. Piessens, “VeriFast: A powerful, sound, predictable, fast veriﬁer
for C and Java,” in NASA Formal Methods Symposium, 2011.
[73] N. Vazou, Liquid Haskell: Haskell as a theorem prover. PhD thesis,
UC San Diego, 2016.
Don’t interpret, compile!,” in USENIX Security, 2020.
[103] “Gurobi.” https://www.gurobi.com/.
[104] J. Forrest and R. Lougee-Heimer, “CBC user guide,” in Emerging
theory, methods, and applications, pp. 257–277, 2005.
[105] A. V. Aho, R. Sethi, and J. D. Ullman, Compilers, principles,
techniques. Addison Wesley, 1986.
[106] M. Blum, W. S. Evans, P. Gemmell, S. Kannan, and M. Naor,
“Checking the correctness of memories,” in FOCS, 1991.
[74] N. Vazou, E. L. Seidel, R. Jhala, D. Vytiniotis, and S. Peyton-Jones,
[107] E. Mullen, D. Zuniga, Z. Tatlock, and D. Grossman, “Veriﬁed
“Reﬁnement types for haskell,” in ICFP, 2014.
[75] N. Swamy, C. Hrit¸cu, C. Keller, A. Rastogi, A. Delignat-Lavaud,
S. Forest, K. Bhargavan, C. Fournet, P.-Y. Strub, M. Kohlweiss, J.-K.
Zinzindohoue, and S. Zanella-B´eguelin, “Dependent types and
multi-monadic effects in F(cid:63),” in POPL, 2016.
peephole optimizations for CompCert,” in PLDI, 2016.
[108] “Pequin: A system for verifying outsourced computations and
applying SNARKs.” https://github.com/pepper-project/pequin.
[109] Y. Zhang, A. Steele, and M. Blanton, “PICCO: A general-purpose
compiler for private distributed computation,” in CCS, Nov. 2013.
[76] L. Cordeiro, P. Kesseli, D. Kroening, P. Schrammel, and M. Trtik,
[110] I. Abal, “Haskell Z3 bindings.”
“JBMC: A bounded model checking tool for verifying Java
bytecode,” in CAV, 2018.
[77] N. P. Lopes, D. Menendez, S. Nagarakatte, and J. Regehr, “Provably
correct peephole optimizations with Alive,” in PLDI, 2015.
[78] D. Menendez, S. Nagarakatte, and A. Gupta, “Alive-FP: Automated
veriﬁcation of ﬂoating point based peephole optimizations in LLVM,”
in SAS, 2016.
[79] A. N¨otzli and F. Brown, “Lifejacket: Verifying precise ﬂoating-point
optimizations in LLVM,” in SOAP, 2016.
[80] K. v. Gleissenthall, R. G. Kıcı, A. Bakst, D. Stefan, and R. Jhala,
“Pretend synchrony: synchronous veriﬁcation of asynchronous
distributed programs,” in POPL, 2019.
[81] R. Uhler and N. Dave, “Smten with satisﬁability-based search,” in
OOPSLA, 2014.
POPL, 2012.
[82] A. K¨oksal, V. Kuncak, and P. Suter, “Constraints as control,” in
[83] L. Moura, “Z3Py guide: Z3 API in Python.”
https://ericpony.github.io/z3py-tutorial/guide-examples.htm.
[84] L. Erk¨ok, “SBV: SMT based veriﬁcation in Haskell.”
https://hackage.haskell.org/package/sbv.
[85] E. Torlak and R. Bodik, “Growing solver-aided languages with
[86]
[87]
Rosette,” in Onward!, 2013.
J.-C. Filliˆatre and A. Paskevich, “Why3—where programs meet
provers,” in ESOP, 2013.
P. M¨uller, M. Schwerhoff, and A. J. Summers, “Viper: A veriﬁcation
infrastructure for permission-based reasoning,” in VMCAI, 2016.
https://github.com/PLSysSec/haskell-z3.
[111] J. Bootle, A. Cerulli, J. Groth, S. Jakobsen, and M. Maller, “Arya:
Nearly linear-time zero-knowledge proofs for correct program
execution,” in ASIACRYPT, 2018.
[112] B. Braun, “Compiling computations to constraints for veriﬁed
computation.” UT Austin Honors Thesis HR-12-10, Dec. 2012.
[113] R. Brinkmann and R. Drechsler, “RTL-datapath veriﬁcation using
integer linear programming,” in ASP-DAC/VLSI, 2002.
[114] Z. Zeng, P. Kalla, and M. Ciesielski, “LPSAT: A uniﬁed approach to
RTL satisﬁability,” in DATE, 2001.
[115] D. Beyer, “Automatic veriﬁcation of C and Java programs:
SV-COMP 2019,” in TACAS, 2019.
[116] “Zcash Sapling circuit library.”
https://github.com/zcash-hackworks/sapling-crypto, 2018.
[117] “pedersen hash.rs.” https://github.com/zcash-hackworks/
sapling-crypto/blob/49017b4e055ba4322dad1f03fe7d80dc0ed449cc/
src/circuit/pedersen hash.rs, 2018.
[118] A. Ozdemir, F. Brown, and R. S. Wahby, “CirC: Compiler
infrastructure for proof systems, software veriﬁcation, and more.”
https://eprint.iacr.org/2020/1586. Extended version.
[119] M. Chang, “Performance issue on QF NIRA formula. CVC4 Issue
5354.” https://github.com/CVC4/CVC4/issues/5354.
[120] N. Becker, P. M¨uller, and A. J. Summers, “The Axiom Proﬁler:
Understanding and debugging SMT quantiﬁer instantiations,” in
TACAS, 2019.
[121] F. Baader and T. Nipkow, Term rewriting and all that. Cambridge,
[88] L. Nelson, J. Bornholt, R. Gu, A. Baumann, E. Torlak, and X. Wang,
UK: Cambridge University Press, 1999.
“Scaling symbolic evaluation for automated veriﬁcation of systems
code with Serval,” in SOSP, 2019.
[122] C. Barrett, C. L. Conway, M. Deters, L. Hadarean, D. Jovanovi´c,
T. King, A. Reynolds, and C. Tinelli, “CVC4,” in CAV, 2011.
[89] Z. Nehai and F. Bobot, “Deductive proof of Ethereum smart contracts
[123] A. Niemetz and M. Preiner, “Bitwuzla at the SMT-COMP 2020.”
[90] M. Baranowski, S. He, and Z. Rakamari´c, “Verifying Rust programs
[124] A. Niemetz, M. Preiner, C. Wolf, and A. Biere, “Btor2 , BtorMC and
[93] R. Baldoni, E. Coppa, D. C. D’elia, C. Demetrescu, and I. Finocchi,
[128] W. Wang, C. Barrett, and T. Wies, “Partitioned memory models for
using Why3.” arXiv:1904.11281, 2019.
[91]
with SMACK,” in ATVA, 2018.
´A. Hajdu and D. Jovanovi´c, “solc-verify: A modular veriﬁer for
Solidity smart contracts,” in VSTTE, 2019.
[92] N. Swamy, J. Weinberger, C. Schlesinger, J. Chen, and B. Livshits,
“Verifying higher-order programs with the Dijkstra monad,” in PLDI,
2013.
“A survey of symbolic execution techniques,” ACM Computing
Surveys, vol. 51, no. 3, pp. 1–39, 2018.
[94] C. Cadar and K. Sen, “Symbolic execution for software testing:
Three decades later,” CACM, vol. 56, no. 2, pp. 82–90, 2013.
[95] D. A. Ramos and D. Engler, “Under-constrained symbolic execution:
[96]
[97]
Correctness checking for real code,” in USENIX Security, 2015.
P. Godefroid, M. Y. Levin, and D. Molnar, “SAGE: Whitebox fuzzing
for security testing,” CACM, vol. 55, no. 3, pp. 40–44, 2012.
P. Godefroid, N. Klarlund, and K. Sen, “DART: Directed automated
random testing,” in PLDI, 2005.
[98] K. Sen, D. Marinov, and G. Agha, “CUTE: A concolic unit testing
engine for C,” in ESEC-FSE, 2005.
[99] V. Chipounov, V. Kuznetsov, and G. Candea, “S2E: A platform for
in-vivo multi-path analysis of software systems,” in ASPLOS, 2011.
[100] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta,
Y. Shoshitaishvili, C. Kruegel, and G. Vigna, “Driller: Augmenting
fuzzing through selective symbolic execution,” in NDSS, 2016.
[101] F. Brown, D. Stefan, and D. Engler, “Sys: A static/symbolic tool for
ﬁnding good bugs in good (browser) code,” in USENIX Security,
arXiv:2006.01621, 2020.
Boolector 3.0,” in CAV, 2018.
TACAS, 2008.
[125] L. De Moura and N. Bjørner, “Z3: An efﬁcient SMT solver,” in
[126] B. Dutertre, “Yices 2.2,” in CAV, 2014.
[127] R. Bruttomesso, A. Cimatti, A. Franz´en, A. Griggio, and
R. Sebastiani, “The MathSAT 4 SMT solver,” in CAV, 2008.
program analysis,” in VMCAI, 2017.
[129] R. M. Burstall, “Some techniques for proving correctness of
programs which alter data structures,” Machine intelligence, vol. 7,
no. 23-50, p. 3, 1972.
[130] R. Sasnauskas, Y. Chen, P. Collingbourne, J. Ketema, G. Lup,
J. Taneja, and J. Regehr, “Souper: A synthesizing superoptimizer.”
arXiv:1711.04422, 2017.
[131] E. Albert, P. Gordillo, A. Rubio, and M. A. Schett, “Synthesis of
super-optimized smart contracts using Max-SMT,” in CAV, 2020.
[132] Z. Jia, O. Padon, J. Thomas, T. Warszawski, M. Zaharia, and
A. Aiken, “TASO: optimizing deep learning computation with
automatic generation of graph substitutions,” in SOSP, 2019.
[133] Y. Bertot and P. Cast´eran, Interactive theorem proving and program
development: Coq’Art: the calculus of inductive constructions.
Springer Science & Business Media, 2013.
[134] J. Baron, “Securing information for encrypted veriﬁcation and
evaluation.” https://web.archive.org/web/20200221151433/https: