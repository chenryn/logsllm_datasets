我们用来确定活跃性和后续使用信息的算法对每个基本块进行--次反向的遍历。我们把得
对每个类似于=+2的三地址语句，我们希望确定对α、和z的下-次使用是什么。当前
知道--个变量的值接下来会在什么时候使用对于生成良好的代码是非常重要的。如果一个
340
我们通常会增加两个分别称为“入口”（entry)和“出口”（exit）的结点。它们不和任何可执行
当将一个中间代码程序划分成为基本块之后，我们用一个流图来表示它们之间的控制流。
在这里，我们使用+作为代表任意运算符的符号。如果三地址语句i形如=+y或者=，
1）把在符号表中找到的有关、y和z的当前后续使用和活跃性信息与语句关联起来。
输入："一-个三地址语句的基本块B，我们假设在开始的时候符号表显示B中的所有非临时变
在一个三地址语句中对一-个名字的使用（use)的定义如下。假设三地址语句i给×赋了－个
我们说B是C的前驱（predecessor），而C是B的一个后继（successor）。
·按照原来的三地址语句序列中的顺序，C 紧跟在B之后，且B 的结尾不存在无条件跳转
·有--个从 B 的结尾跳转到C 的开头的条件或无条件跳转语句。
3）在符号表中，设置与z为"活跃”，并把它们的下一次使用设置为语句。
2）在符号表中，设置x为“不活跃"和“无后续使用”。
语句。
对-一个基本块中的每--个语句确定活跃性与后续使用信息。
第8章
口
---
## Page 357
例8.9
并且这个循环人口结点不是整个流图的人口结点本身。
点。也就是说，从整个流图的人口结点开始到L中的任何结点的路径都必然经过循环人口结点，
就说流图中的一个结点集合L是一个循环。
代码就变得非常重要。很多代码转换依赖于对流图中“循环”的识别。如果下列条件成立，我们
中。因为事实上每个程序会花很多时间执行循环，所以对于一个编译器来说，为循环生成优良的
8. 4.5
示
针，再加上基本块的指令数量或一个指向结尾指令的指针来表示结点的内容。但是，因为我们可
需要有它们自己的表示方式。我们可以用一个指向该基本块在三地址指令数组中的首指令的指
标指令之后修正跳转指令的目标。
的目标是指令，我们将不得不在每次改变了某个目
个基本块中的指令做出实质性的改变。如果跳
这
指
件或无条件跳转指令总是跳转到某些基本块的市
块的跳转，这么做是很正常的。回忆一下，所有
达指令的序号或标号的跳转指令替换为到达基
8.4.4流图的表示方式
Bg 结尾处的条件跳转指令。
在流图对应的程序之后的代码的唯一方式是穿越
到达 B4 的首指令。
件跳转指令(即指令9)的目标。另-个后继是 B4，
身，因为 B; 的首指令(即指令3)是 B, 结尾处的条
之后。
转指令，且 B2的首指令紧跟在B，的结尾指令
一后继是B2，因为B的结尾不是--个无条件跳
因为B;包含了这个程序的第一-个指令。B，的唯
平
例8.8
方法。
流图就是通常的图，它可以用任何适合表示图的数据结构来表示。结点(即基本块)的内容
么做的原因是，在流图构造完成之后经常会对多
令，而现在这些跳转指令指向了相应的基本块。
首先，从图8-9 中可以看出，在流图里面把到
1为控制流可能穿越B结尾处的条件跳转指令而
代码生成
2）L中的每个结点都有一个到达L的人口结点的非空路径，并且该路径全部在L中。
2) B自身
1）在L中有一个被称为循环入口(lop enty)的结点，它是唯一的其前驱可能在L之外的结
像 while 语句、do-while 语句和 for 语句这样的程序设计语言构造自然地把循环引人到程户
只有Bg指向流图的出口结点，因为到达紧跟
1)B3自身
基本块B;有两个后继。其中的一个是它本
图8-9中的流图有三个循环：
循环
转
条
本
口
5
B:
图8-9基于图8-7构造的流图
i=i+
-1
-1
工：
8
ENTRY
EXIT
10 goto Bs
341
序
---
## Page 358
8.5.1基本块的 DAG 表示
个基本块之间流动的。全局优化是一个很复杂的主题，它将考虑很多不同的技术。
时间。更加彻底的全局优化将从第9 章开始讨论。全局优化将检查信息是如何在一个程序的多
8.5
字节存放。
开始把所有的α[订初始化为 TRUE；如果我们找到了j的一个因子，就把α[设置为 FALSE。
使用筛法来完成计算。也就是说，最后α[订为真仅当没有小于等于的质数可以整除i。我们一
址语句。
成为我们在本节中一-直使用的那种三地
的数值，而且矩阵按行存放。把程序翻译
阵乘法程序。
8.4.68.4节的练习
有路径 B2-→B3-→B4-→B2c
不在L中的前驱B。而且，这三个结点中都有在L中且到达B2的非空路径。比如，从B2开始就
集合B2”中的非空路径。
此，像B这样的单一-结点(它没有一条 B2一B2的边)不是循环，因为没有从B2到其自身，且在
B,本身为入口结点的循环。请注意，循环的第二个条件要求有一个从 B到本身的非空路径。因
仅仅通过对各个基本块本身进行局部优化，我们就常常可以实质性地降低代码运行所需的
1）把程序翻译成为我们在本节中使用的那种三地址语句序列。这里假设--个整数需要4个
1）假设矩阵的元素是需要8个字节
练习8.4.1：图8-10是一个简单的矩
第三个循环L=“B2，B3，B4}的循环入口结点是B2。请注意，这三个结点中只有B2有一个
342
3）找出在(2)中得到的流图的循环。
2）为在(1)中得到的代码构造流图。
练习8. 4. 2：图8-11中是计算从2～n之间素数个数的代码。它在一个适当大小的数组α上
3）找出在(2)中得到的流图的循环
2）为(1)中得到的代码构造流图。
其中的前两个循环都由单一-结点组成，这些结点都有到其自身的边。比如，B,形成一个以
3){B2,Bs, B4}
基本块的优化
count
for (i=2; i
0；
图8-11筛法选取素数的代码
a[j］=FALSE；/*i的倍数都不是素数*/
(j=2*i;j<=n;j = j+i)
for(
(i=0;
for （j=0;
c[i][j] = 0.0;
for
图 8-10-个矩阵相乘算法
i<n;
c[i] [j] =c[i][j] + a[i][k]*b[k][j];
j<n;j++)
i++)
k<n;
第8章
口
---
## Page 359
b，可以使用α来存放图8-12 中标号为－的结点所代表的值。这个基本块就变成了：
只有三个语句的基本块。实际上，假如b在这个基本块的出口点不活跃，我们不需要计算变量
把α 加到这个标记为－的结点的定值变量表中。
d。的结点。因为运算符和子结点都和语句2对应的结点相同，我们不需要创建这个结点，而是
和语句3 所计算的值混淆。
为这个结点是b的最近的定值。因此，我们不会把语句1
知道b+ c 中b 的使用指向图8-12 中标号为－的结点。因
例8.10
检测公共子表达式的“值编码”方法。
点，N计算的值和M计算的值是一样的，因此可以用N替换M。在6.1.1节中，这个技术被称为
否存在一个结点N，它和M具有同样的运算符和子结点，且子结点顺序相同。如果存在这样的结
8.5.2寻找局部公共子表达式
计算过程。
持在寄存器中的时间。
复计算-
就是说，这些变量的值可能以后会在流图的另一个基本块中被使用到。计算得到这些“活跃变
晚对这些变量进行定值的语句。
应结点。这些语句是在s之前、最后---个对s所使用的某个运算分量进行定值的语句。
表达式的集合。我们按照如下方式为一个基本块构造 DAG：
原文如此。如果s的某个运算分量在基本块内没有在之前被定值，那么这个运算分量对应的子结点就是代表该
4）我们可以使用代数规则来重新排列三地址指令的运算分量的顺序。这么做有时可以简化
代码生成
因为在图8-12 的 DAG 中只有三个非叶子结点，看起来例8.10 中的基本块可以替换为--个
 然而，对应于第四个语句 d=a－α 的结点的运算符是 － ，
检测公共子表达式的方法是这样的。当一个新的结点 M 将被加人到 DAG 中时，我们检查是
3）我们可以对相互独立的语句进行重新排序，这样的重新排序可以降低一个临时值需要保
 4）某些结点被指明为输出结点(output node)。这些结点的变量在基本块的出口处活跃。
2）我们可以消除死代码（dead code），即计算得到的值不会被使用的指令。
3）结点N的标号是s中的运算符；同时还有一组变量被关联到N，表示s是在此基本块内最
2）基本块中的每个语句s都有一个相关的结点 N。N的子结点是基本块中的其他语句的对
当我们为第三个语句c= b +c 构造结点的时候，我们
1）我们可以消除局部公共子表达式（local common subexpression）。所谓公共子表达式就是重
自
运算分量的初始值的结点。——译者注
一个已经计算得到的值的指令。
本块的DAG表示使我们可以对基本块所代表的代码进行-些转换，以改进代码的质量。
+
下面的基本块的 DAG 见图 8-12。
图8-12例8.10 中的基本块的 DAG
，且它的子结点是标记有变量 a 
?
b,d
do
?
343
是
---
## Page 360
表达式求值，并把此常量表达式替换为求出的值。
这样的恒等式来从一个基本块中消除计算步骤。
8.5.4代数恒等式的使用
一个代价较低的运算。比如：
因为它们都附有活跃变量。
根结点。然后标记为c 的结点就变成根结点，也可以被删除。标记为a 和b 的结点被保留下来，
例8.12
有对应于死代码的结点。
加活跃变量的根结点（即没有父结点的结点）。重复应用这样的处理过程就可以从 DAG 中消除所
8.5.3消除死代码
在DAG 中应用代数恒等式可以揭示出这样的等值关系。
个序列的DAG 见图 8-13。它没有显示出任何公共子表达式。但是，如8.5.4节中将要讨论的
在第一个和第四个语句之间改变了，但它们的和仍保持不变，因为b+=（b－d）+（c+d)。这
中，第--和第四个语句实际上计算的是同-一-个表达式的值，即b。+C。。也就是说，虽然b 和 
句序列 
式。因此，DAG方法不能看到下面的事实，即下面的语
上是寻找不管如何计算一定能得到相同结果值的表达