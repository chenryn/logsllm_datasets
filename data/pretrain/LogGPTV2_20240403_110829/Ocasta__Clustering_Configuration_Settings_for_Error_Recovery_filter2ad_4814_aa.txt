title:Ocasta: Clustering Configuration Settings for Error Recovery
author:Zhen Huang and
David Lie
2014 44th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
Ocasta: Clustering Conﬁguration Settings For Error Recovery
Zhen Huang
David Lie
Department of Electrical and Computer Engineering
University of Toronto
Abstract—Effective machine-aided diagnosis and repair of
conﬁguration errors continues to elude computer systems
designers. Most of the literature targets errors that can be
attributed to a single erroneous conﬁguration setting. However,
a recent study found that a signiﬁcant amount of conﬁguration
errors require ﬁxing more than one setting together. To
address this limitation, Ocasta statistically clusters dependent
conﬁguration settings based on the application’s accesses to its
conﬁguration settings and utilizes the extracted clustering of
conﬁguration settings to ﬁx conﬁguration errors involving more
than one conﬁguration settings. Ocasta treats applications as
black-boxes and only relies on the ability to observe application
accesses to their conﬁguration settings.
We collected traces of real application usage from 24 Linux
and 5 Windows desktops computers and found that Ocasta
is able to correctly identify clusters with 88.6% accuracy. To
demonstrate the effectiveness of Ocasta, we evaluated it on
16 real-world conﬁguration errors of 11 Linux and Windows
applications. Ocasta is able to successfully repair all evaluated
conﬁguration errors in 11 minutes on average and only requires
the user to examine an average of 3 screenshots of the output
of the application to conﬁrm that the error is repaired. A user
study we conducted shows that Ocasta is easy to use by both
expert and non-expert users and is more efﬁcient than manual
conﬁguration error troubleshooting.
Keywords-Fault diagnosis, System recovery, Clustering algo-
rithms, Software tools
I. INTRODUCTION
Conﬁguration errors are a leading cause of failure and
unavailability for desktop applications [1]. Fixing such er-
rors has essentially two steps: identifying the conﬁguration
settings causing the error, and replacing the faulty settings
with values that ﬁx the conﬁguration error.
To facilitate the ﬁrst step, proposals in the literature
have tried to pinpoint the time the conﬁguration error ﬁrst
appeared [2], used statistical anomaly detection to detect
abnormal conﬁguration settings [3], [4], [5], or used white-
box dynamic analysis to ﬁnd the particular conﬁguration
setting that causes the application to execute an erroneous
code path [6]. Of these three approaches, only the last two
try to identify the conﬁguration setting that causes the error
and even then, they only work if the error is the result
of a single conﬁguration setting. Unfortunately, this can
be a serious drawback since a recent study found that a
signiﬁcant number of conﬁguration errors (14.9%-34.7%)
require changing more than one conﬁguration setting to
ﬁx [7], because some conﬁguration settings are related.
One example of related conﬁguration settings is illustrated
in Figure 1a: the number of “Item” settings should never
exceed the value of Max Display setting. Microsoft Word
automatically maintains this relationship. For instance, if a
user reduces the maximum number of recently accessed doc-
uments from the Preference menu, Microsoft Word not only
reduces the value of Max Display setting, but also deletes
extra Item settings. Consequently, if the user wants to undo
the effect of reducing the maximum number of recently
accessed documents, both the old value of Max Display
and the deleted Item settings need to be recovered.
In this paper, we present a novel technique that uses hier-
archical agglomerative clustering [8] to identify clusters of
related conﬁguration settings, relying only on the ability to
observe application accesses to its conﬁguration store, and is
thus language, binary and OS independent. We implemented
this technique in Ocasta, which treats applications as black-
boxes and is able to work on a wide range of applications
and environments.
To evaluate the effectiveness of Ocasta, we collected
traces of application usage from both Windows and Linux
machines ranging from 18 to 76 days in length and then use
Ocasta to identify clusters of related conﬁguration settings
in 11 different application in across 4 different OS ﬂavors.
Using this data and 16 real-world conﬁguration errors, we
show that Ocasta’s clustering is able to accurately identify
88.6% of the clusters of related conﬁguration settings.
To further evaluate Ocasta, we added a simple GUI-based
conﬁguration error repair tool that, with user input, uses the
clustering information from Ocasta to automatically search
for and ﬁx settings causing conﬁguration errors. The Ocasta
search tool requires the user to provide a GUI-action script
that triggers the error, which it then uses to automatically
search historical values of the clusters of conﬁguration
settings found by Ocasta for a ﬁx. A screenshot of the result
is recorded after each search and the user is asked to select a
screenshot that shows that the symptoms of the conﬁguration
have been treated.
Conﬁguration error repair in general is very hard and
while Ocasta’s proof of concept tool is able to ﬁx the symp-
toms of all of our conﬁguration errors, it cannot guarantee
that the selected ﬁx does not introduce new hidden errors,
nor can it ﬁx errors that do not have any visible symptoms.
In general, studies have shown that even trained humans
may fail to ﬁx conﬁguration errors completely, create new
978-1-4799-2233-8/14 $31.00 © 2014 IEEE
DOI 10.1109/DSN.2014.51
479
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:26:43 UTC from IEEE Xplore.  Restrictions apply. 
Application: MS WORD 2010 
…\File MRU\Max Display: 20 
…\File MRU\Item 1: \Path\To\ Document1 
… 
…\File MRU\Item 20: \Path\To\ Document20 
Description: The “Max Display” setting 
determines the number of recently accessed 
documents stored in the “Item” settings. 
Application: Acrobat Reader 
…/InlineAutoComplete: true 
…/RecordNewEntries: true 
…/ShowDropDown: true 
Application: Evolution Mail 
…/mail/display/mark_seen: true 
…/mail/display/mark_seen_timeout: 15 
Description: The “InlineAutoComplete” setting 
enables/disables the “auto complete” feature 
when user fills a form. The other settings specify 
how the “autocomplete” feature should behave. 
Description: When the setting “mark_seen” is 
set to true, Evolution marks an email as “seen” 
after the email is opened for the time specified in 
the setting “mark_seen_timeout”. 
(a) MS Word
(b) Acrobat Reader
(c) Evolution Mail
Figure 1: Examples of dependency relationships among conﬁguration settings
errors in the process troubleshooting or ﬁxing an existing
error, or have to resort to resetting the application back
to its defaults to remove the symptoms of a conﬁguration
error [9]. Our evaluation demonstrates that Ocasta’s method
for inferring related conﬁguration settings broadens the
range of errors automated conﬁguration error repair tools
can handle by providing with clustering information. We
believe that even when automated tools fail, the clustering
information provided by Ocasta will still be valuable to
human troubleshooters.
Our contributions are:
• We characterize the types and reasons of for relation-
ships between conﬁguration settings by manually in-
specting and analyzing over 500 conﬁguration settings
across 11 applications.
• We present the design and prototype implementation
of Ocasta, which uses black-box statistical clustering
of application behavior to identify related conﬁguration
settings. Ocasta has been implemented on both Linux
and Windows and evaluated on both systems using data
collected from machines used by real people.
• We further evaluate the usability of Ocasta’s clustering
with a proof-of-concept tool that given a set of ac-
tions that recreates a conﬁguration error, automatically
searches historical values of clusters of conﬁguration
settings for a ﬁx. We demonstrate the effectiveness of
our tool against 16 real-world conﬁguration errors. We
also provide a user study showing the effectiveness of
Ocasta’s conﬁguration repair tool.
We begin by studying relations between conﬁguration set-
tings and deﬁning the problem solved by Ocasta in Sec-
tion II. We then describe Ocasta’s high-level design in
Section III and give implementation details in Section IV.
We describe how we collected our traces in Section V and
evaluate Ocasta in Section VI. Finally, we discuss related
work in Section VII and conclude in Section VIII.
II. PROBLEM DEFINITION
Similar to relationships between program variables [10],
relationships between conﬁguration settings are a common,
though not often documented phenomenon that applications
exhibit. We begin by describing 3 representative examples
Name
Windows 7
Windows
Vista
Windows
Vista-2
Windows
XP
Windows
XP-2
Linux-1
Linux-2
Linux-3
Linux-4
Days
42
53
Reads
6.76M
3.46M
Writes
67.72K
20.5K
# Keys
4,611
14,673
TTKV Size
85MB
29MB
18
25
32
25
84
46
64
15.08M
224.64K
1,123
6.3MB
22.80M
311.9K
14,667
24MB
26.76M
268.96K
19,501
46MB
91.52K
8.15K
52.41K
507.07K
3.34K
0.48K
0.44K
5.43K
1,660
35
706
751
6MB
0.1MB
0.7MB
6.4MB
Table I: Summary of trace statistics. The traces on the
Linux machines are aggregated by users instead of machines.
We only list statistics for users whose data we use in the
evaluation of this paper. The last column gives the size of
the TTKV at the end of the trace. For Linux-2, Linux-3 and
Linux-4, the TTKV only stores keys from the application-
ﬁle logger.
of related conﬁguration settings that we found by manually
inspecting over 500 conﬁguration settings that were accessed
by 11 different Windows and Linux applications in our traces
(trace statistics given in Table I).
In Figure 1a, to control the number of documents listed
in the recently opened documents list in Microsoft Word,
Max Display limits the number of document names
stored in the Item settings (e.g. Item 1, Item 2). In
Figure 1b, Acrobat Reader uses InlineAutoCompelete
to determine whether to enable the “auto complete” feature
when user ﬁlls a form, while RecordNewEntries and
ShowDropDown specify how the “auto complete” feature
works, including whether to record user-entered data and
whether to display the list of previously recorded data
in a dropdown box. Finally, in Figure 1c, Evolution will
automatically mark an opened email as “seen” after an email
has been opened by the user for the time interval speciﬁed
by the value of mark_seen_timeout, but only when
mark_seen is set to “true”. These examples illustrate that
related conﬁguration settings exist when one or more settings
controls the validity or meaning of another group of settings.
Because related conﬁguration are designed to work to-
480
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:26:43 UTC from IEEE Xplore.  Restrictions apply. 
gether, applications are likely to update related conﬁguration
settings together, in order to satisfy their relation as illus-
trated in our 3 examples. In addition, users tend to change
related conﬁguration settings together. For example, a user
will probably set the value of mark_seen_timeout and
change the value of mark_seen to “true” together,
in
order to enable Evolution to automatically mark an opened
email. In contrast, independent conﬁguration settings are
unlikely to be changed together. Based on this intuition,
Ocasta identiﬁes the relations among conﬁguration settings
by observing the access correlations among them and uses
hierarchical agglomerative clustering to group together con-
ﬁguration settings based on access correlations.
Limitations: Ocasta has several limitations. First, inde-
pendent conﬁguration settings can be accidentally updated
simultaneously and cause the hierarchical agglomerative
clustering algorithm that Ocasta uses to incorrectly identify
them as dependent. Similarly, partial update of dependent
settings may be legal
in some cases causing Ocasta to
incorrectly infer that related settings should be in separate
clusters. Ocasta’s clustering can be tuned to handle such
cases, but this tuning may require some manual intervention.
Ultimately, Ocasta can only perform as well as the quality
and amount of data available to it. Second, Ocasta must be
able to intercept and record accesses to the individual keys
where the application stores its persistent settings. We have
implemented and tested such capabilities for OS-provided
key-value stores like the Windows Registry and GConf in
Linux. While many applications use OS-provided stores,
some applications use their own ﬁles to store conﬁgurations.
Thus we have also implemented custom parsers for several
common ﬁle formats, such as XML, JSON, PostScript, INI
and plain text.
Ocasta’s proof-of-concept error repair tool has some ad-
ditional limitations. First, a ﬁx for the conﬁguration error
must exist in the application’s recorded history. Our tool
cannot ﬁx applications that have always been misconﬁgured
or where the conﬁguration error arose due to a change
in an external dependency. Second, the conﬁguration error
must occur deterministically, because our tool only performs
one trial execution per historical cluster value in its search.
Finally, because the user must be able to identify a ﬁxed
application from its screenshot, the conﬁguration error must
be visually observable on the display.
III. OVERVIEW
A. Clustering conﬁguration settings
Ocasta improves conﬁguration troubleshooting and repair
by heuristically identifying clusters of related conﬁguration
settings. Ocasta abstracts conﬁgurations into key-value pairs,
with the key being the name of the conﬁguration setting
and the value being the content of the setting. As we see
in Section IV, many application conﬁgurations naturally ﬁt
into this abstraction.
It is important that the clusters of conﬁguration settings
that Ocasta extracts from observing application behavior
be accurate. On one hand, extracting undersized clusters
can create clusters that do not contain all the conﬁguration
keys necessary to ﬁx a conﬁguration error. Even worse,
attempting to ﬁx an error with an undersized cluster can,
in some cases, break dependencies between conﬁguration
settings, leading to a non-working application conﬁguration.
On the other hand, extracting oversized clusters causes
unrelated conﬁguration settings to be clustered together, and
can lead to extraneous conﬁguration changes when trying
to repair errors. As an extreme example, repairs that reset
an application conﬁguration back to its defaults, or copy a
conﬁguration from a previous snapshot or a different user,
essentially treat the application’s conﬁguration as a single,
large, oversized cluster.
Ocasta uses the property that related conﬁguration keys
are much more likely to be modiﬁed together than unrelated