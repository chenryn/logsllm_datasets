    CONTAINER ID  IMAGE                                   COMMAND  CREATED        STATUS         PORTS   NAMES               POD ID        PODNAME
    24666f47d9b2  registry.access.redhat.com/ubi8:latest  top      3 minutes ago  Created                container0          3130f724e229  systemd-pod
    56eb1bf0cdfe  k8s.gcr.io/pause:3.2                             4 minutes ago  Created                3130f724e229-infra  3130f724e229  systemd-pod
    62118d170e43  registry.access.redhat.com/ubi8:latest  top      3 seconds ago  Created                container1          3130f724e229  systemd-pod
    ```
5.  为新 pod 生成 systemd 单元文件：
    ``` literallayout
    $ podman generate systemd --files --name systemd-pod
    /home/user1/pod-systemd-pod.service
    /home/user1/container-container0.service
    /home/user1/container-container1.service
    ```
    请注意，生成了三个 systemd 单元文件，一个用于
    `systemd-pod`{.literal} pod，两个用于容器 `container0`{.literal} 和
    `container1`{.literal}。
6.  显示 `pod-systemd-pod.service`{.literal} 单元文件：
    ``` literallayout
    $ cat pod-systemd-pod.service
    # pod-systemd-pod.service
    # autogenerated by Podman 3.3.1
    # Wed Sep  8 20:49:17 CEST 2021
    [Unit]
    Description=Podman pod-systemd-pod.service
    Documentation=man:podman-generate-systemd(1)
    Wants=network-online.target
    After=network-online.target
    RequiresMountsFor=
    Requires=container-container0.service container-container1.service
    Before=container-container0.service container-container1.service
    [Service]
    Environment=PODMAN_SYSTEMD_UNIT=%n
    Restart=on-failure
    TimeoutStopSec=70
    ExecStart=/usr/bin/podman start bcb128965b8e-infra
    ExecStop=/usr/bin/podman stop -t 10 bcb128965b8e-infra
    ExecStopPost=/usr/bin/podman stop -t 10 bcb128965b8e-infra
    PIDFile=/run/user/1000/containers/overlay-containers/1dfdcf20e35043939ea3f80f002c65c00d560e47223685dbc3230e26fe001b29/userdata/conmon.pid
    Type=forking
    [Install]
    WantedBy=multi-user.target default.target
    ```
    ::: itemizedlist
    -   `[Unit]`{.literal} 部分中的 `Requires`{.literal} 行定义
        `container-container0.service`{.literal} 和
        `container-container1.service`{.literal}
        单元文件的依赖关系。两个单元文件都会被激活。
    -   `[Service] 部分中的 [`{.literal} ` ExecStart`{.literal}
        和ExecStop``{=html} 行分别启动和停止 infra-container。
    :::
7.  显示 `container-container0.service`{.literal} 单元文件：
    ``` literallayout
    $ cat container-container0.service
    # container-container0.service
    # autogenerated by Podman 3.3.1
    # Wed Sep  8 20:49:17 CEST 2021
    [Unit]
    Description=Podman container-container0.service
    Documentation=man:podman-generate-systemd(1)
    Wants=network-online.target
    After=network-online.target
    RequiresMountsFor=/run/user/1000/containers
    BindsTo=pod-systemd-pod.service
    After=pod-systemd-pod.service
    [Service]
    Environment=PODMAN_SYSTEMD_UNIT=%n
    Restart=on-failure
    TimeoutStopSec=70
    ExecStart=/usr/bin/podman start container0
    ExecStop=/usr/bin/podman stop -t 10 container0
    ExecStopPost=/usr/bin/podman stop -t 10 container0
    PIDFile=/run/user/1000/containers/overlay-containers/4bccd7c8616ae5909b05317df4066fa90a64a067375af5996fdef9152f6d51f5/userdata/conmon.pid
    Type=forking
    [Install]
    WantedBy=multi-user.target default.target
    ```
    ::: itemizedlist
    -   `[Unit]`{.literal} 部分中的 `BindsTo`{.literal} 行定义
        `pod-systemd-pod.service`{.literal} 单元文件的依赖项
    -   `[Service] 部分中的 [`{.literal} ` ExecStart`{.literal}
        和ExecStop``{=html} 行分别启动和停止
        `container0。`{.literal}
    :::
8.  显示 `container-container1.service`{.literal} 单元文件：
    ``` literallayout
    $ cat container-container1.service
    ```
9.  将所有生成的文件复制到 `$HOME/.config/systemd/user`{.literal}
    中，以非 root 用户身份安装：
    ``` literallayout
    $ cp pod-systemd-pod.service container-container0.service container-container1.service $HOME/.config/systemd/user
    ```
10. 启用该服务并在用户登录时启动：
    ``` literallayout
    $ systemctl enable --user pod-systemd-pod.service
    Created symlink /home/user1/.config/systemd/user/multi-user.target.wants/pod-systemd-pod.service → /home/user1/.config/systemd/user/pod-systemd-pod.service.
    Created symlink /home/user1/.config/systemd/user/default.target.wants/pod-systemd-pod.service → /home/user1/.config/systemd/user/pod-systemd-pod.service.
    ```
    请注意，服务会在用户注销时停止。
:::
::: itemizedlist
**验证步骤**
-   检查是否启用该服务：
    ``` literallayout
    $ systemctl is-enabled pod-systemd-pod.service
    enabled
    ```
:::
::: itemizedlist
**其它资源**
-   `man podman-create`{.literal}
-   `man podman-generate-systemd`{.literal}
-   `man systemctl`{.literal}
-   [使用 Podman 和共享 systemd
    服务运行容器](https://www.redhat.com/sysadmin/podman-shareable-systemd-services){.link}
-   [使用 systemd
    管理服务章节](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/managing-services-with-systemd_configuring-basic-system-settings){.link}
:::
:::
::: section
::: titlepage
# []{#assembly_porting-containers-to-systemd-using-podman_building-running-and-managing-containers.html#proc_auto-updating-containers-using-podman_assembly_porting-containers-to-systemd-using-podman}使用 Podman 自动更新容器 {.title}
:::
`podman auto-update`{.literal}
命令允许您根据自动更新策略自动更新容器。当注册表上更新容器镜像时，`podman auto-update`{.literal}
命令会更新服务。要使用自动更新，必须使用
`--label "io.containers.autoupdate=image"`{.literal} 标签创建容器，并在
`podman generate systemd --new 命令生成的 systemd`{.literal}
单元中运行。
Podman 会搜索运行中的容器，其 `"io.containers.autoupdate"`{.literal}
标签设置为
`"image"`{.literal}，并与容器注册表通信。如果镜像已更改，Podman
将重新启动对应的 systemd
单元，以停止旧容器并使用新镜像创建新容器。因此，容器、其环境和所有依赖项都会被重启。
::: itemizedlist
**先决条件**
-   已安装 `container-tools`{.literal} 模块。
    ``` literallayout
    # yum module install -y container-tools
    ```
:::
::: orderedlist
**流程**
1.  根据
    `registry.access.redhat.com/ubi8/ubi-init 镜像启动一个 myubi`{.literal}
    容器``{=html} ：
    ``` literallayout
    # podman run --label "io.containers.autoupdate=image" \
    --name myubi  -dt registry.access.redhat.com/ubi8/ubi-init top
    bc219740a210455fa27deacc96d50a9e20516492f1417507c13ce1533dbdcd9d
    ```
2.  可选：列出正在运行或已退出的容器：
    ``` literallayout
    # podman ps -a
    CONTAINER ID  IMAGE                                            COMMAND  CREATED         STATUS             PORTS   NAMES
    76465a5e2933  registry.access.redhat.com/ubi8/ubi-init:latest  top      24 seconds ago  Up 23 seconds ago          myubi
    ```
3.  为 `myubi`{.literal} 容器生成 systemd 单元文件：
    ``` literallayout
    # podman generate systemd --new --files --name myubi
    /root/container-myubi.service
    ```
4.  将单元文件复制到 `/usr/lib/systemd/system`{.literal} 中以 root
    用户身份安装它：
    ``` literallayout
    # cp -Z ~/container-myubi.service /usr/lib/systemd/system
    ```
5.  重新载入 systemd Manager 配置：
    ``` literallayout
    # systemctl daemon-reload
    ```
6.  启动并检查容器的状态：
    ``` literallayout
    # systemctl start container-myubi.service
    # systemctl status container-myubi.service
    ```
7.  自动更新容器：
    ``` literallayout
    # podman auto-update
    ```
:::
::: itemizedlist
**其它资源**
-   [改进了 Systemd 与 Podman
    2.0](https://www.redhat.com/sysadmin/improved-systemd-podman){.link}
    的集成
-   [使用 Podman 和共享 systemd
    服务运行容器](https://www.redhat.com/sysadmin/podman-shareable-systemd-services){.link}
-   [使用 systemd
    管理服务章节](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html-single/System_Administrators_Guide/index.html#chap-Managing_Services_with_systemd){.link}
:::
:::
::: section
::: titlepage
# []{#assembly_porting-containers-to-systemd-using-podman_building-running-and-managing-containers.html#proc_auto-updating-containers-using-systemd_assembly_porting-containers-to-systemd-using-podman}使用 systemd 自动更新容器 {.title}
:::
如 [使用 Podman
自动更新容器](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/building_running_and_managing_containers/index#auto-updating-containers-using-podman_building-running-and-managing-containers){.link}
一节中所述，您可以使用 `podman auto-update`{.literal}
命令更新容器。它集成到自定义脚本中，并在需要时调用。自动更新容器的另一种方法是使用预安装的
`podman-auto-update.timer`{.literal} 和
`podman-auto-update.service`{.literal} systemd
服务。`podman-auto-update.timer`{.literal}
可以配置为在特定日期或时间触发自动更新。`podman-auto-update.service`{.literal}
可以进一步通过 `systemctl`{.literal} 命令启动，或者由其他 systemd
服务用作依赖项。因此，可以根据时间和事件触发自动更新，以满足个人需求和用例。
::: itemizedlist
**先决条件**
-   已安装 `container-tools`{.literal} 模块。
    ``` literallayout
     # yum module install -y container-tools
    ```
:::
::: orderedlist
**流程**
1.  显示 `podman-auto-update.service`{.literal} 单元文件：
    ``` screen
    # cat /usr/lib/systemd/system/podman-auto-update.service
    [Unit]
    Description=Podman auto-update service
    Documentation=man:podman-auto-update(1)
    Wants=network.target
    After=network-online.target
    [Service]
    Type=oneshot
    ExecStart=/usr/bin/podman auto-update
    [Install]
    WantedBy=multi-user.target default.target
    ```
2.  显示 `podman-auto-update.timer`{.literal} 单元文件：
    ``` screen
    # cat /usr/lib/systemd/system/podman-auto-update.timer
    [Unit]
    Description=Podman auto-update timer
    [Timer]
    OnCalendar=daily
    Persistent=true
    [Install]
    WantedBy=timers.target
    ```
    在本例中，`podman auto-update`{.literal} 命令每天午夜启动。
3.  在系统启动时启用 `podman-auto-update.timer`{.literal} 服务：
    ``` screen
    # systemctl enable podman-auto-update.timer
    ```
4.  启动 systemd 服务：
    ``` screen
    # systemctl start podman-auto-update.timer
    ```
5.  可选：列出所有计时器：
    ``` screen
    # systemctl list-timers --all
    NEXT                         LEFT      LAST                         PASSED       UNIT                         ACTIVATES
    Wed 2020-12-09 00:00:00 CET  9h left   n/a                          n/a          podman-auto-update.timer     podman-auto-update.service
    ```
    您可以看到 `podman-auto-update.timer`{.literal} 激活
    `podman-auto-update.service`{.literal}。
:::
::: itemizedlist
**其它资源**
-   [改进了 Systemd 与 Podman
    2.0](https://www.redhat.com/sysadmin/improved-systemd-podman){.link}
    的集成
-   [使用 Podman 和共享 systemd
    服务运行容器](https://www.redhat.com/sysadmin/podman-shareable-systemd-services){.link}
-   [使用 systemd
    管理服务章节](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html-single/System_Administrators_Guide/index.html#chap-Managing_Services_with_systemd){.link}
:::
:::
:::
[]{#assembly_building-container-images-with-buildah_building-running-and-managing-containers.html}
::: chapter
::: titlepage
# []{#assembly_building-container-images-with-buildah_building-running-and-managing-containers.html#assembly_building-container-images-with-buildah_building-running-and-managing-containers}第 13 章 使用 Buildah 构建容器镜像 {.title}
:::
Buildah 有助于构建符合 [OCI 运行时规范的 OCI
容器镜像](https://github.com/opencontainers/runtime-spec){.link}。使用
Buildah，您可以创建一个可运行的容器，可以从头开始，也可以使用一个镜像作为起点。您可以从正常工作的容器或
`Containerfile`{.literal}
中的说明创建镜像。您可以挂载和卸载正常工作容器的根文件系统。
::: section
::: titlepage
# []{#assembly_building-container-images-with-buildah_building-running-and-managing-containers.html#con_the-buildah-tool_assembly_building-container-images-with-buildah}Buildah 工具 {.title}
:::
使用 Buildah 与使用 docker 命令构建镜像不同：
::: variablelist
[无守护进程]{.term}
:   buildah 不需要容器运行时。
[基础镜像或涂销]{.term}
:   您可以基于另一个容器构建镜像，或者从空镜像(scratch)开始。
[构建工具是外部的]{.term}
:   Buildah 不包含镜像本身的构建工具。因此，Buildah:
    ::: itemizedlist
    -   减少构建的镜像的大小。
    -   通过从生成的镜像中排除软件（如 gcc、make 和
        yum）来提高镜像的安全性。
    -   由于镜像大小减少，允许使用较少的资源传输镜像。
    :::
[兼容性]{.term}
:   Buildah 支持使用 Dockerfile 构建容器镜像，从而可以轻松从 Docker
    转换到 Buildah。
:::
::: {.note style="margin-left: 0.5in; margin-right: 0.5in;"}
### 注意 {.title}
容器存储的默认位置 Buildah 与 CRI-O
容器引擎用于存储镜像本地副本的位置相同。因此，通过 CRI-O 或 Buildah 从
registry 中拉取的镜像或由 buildah
命令提交的镜像会存储在相同的目录结构中。但是，即使 CRI-O 和 Buildah
当前能够共享镜像，它们也无法共享容器。