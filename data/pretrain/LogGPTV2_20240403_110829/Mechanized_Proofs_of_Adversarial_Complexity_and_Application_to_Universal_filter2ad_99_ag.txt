Γ ⊢p struct st end : sig S restr θ end
Struct
Alias
Γ ⊢ pa : M
Γ ⊢p pa : M
Func
Γ, module x = absparam : M0 ⊢p(x) m : M
Γ ⊢p func(x : M0) m : func(x : M0) M
Γ(x)(cid:32)undef
Γ ⊢ M0
Sub
Γ ⊢p m : M0
⊢ M0 <: M
Γ ⊢p m : M
ProcDecl
Module structure typing Γ ⊢p,θ st : S.
body = { var ((cid:174)vl : (cid:174)τl); s; return r }
(cid:174)v, (cid:174)vl fresh in Γ
Γf = Γ, var (cid:174)v : (cid:174)τ , var (cid:174)vl : (cid:174)τl
Γ ⊢ body ▷ θ[f ]
Γf ⊢ r : τr
Γf ⊢ s
Γ(p.f )(cid:32)undef
Γ, proc p.f ((cid:174)v : (cid:174)τ) → τr = body ⊢p,θ st : S
Γ ⊢p,θ (proc f ((cid:174)v : (cid:174)τ) → τr = body; st) : (proc f ((cid:174)v : (cid:174)τ) → τr ; S)
ModDecl
Γ ⊢p.x m : M
Γ, module p.x = m : M ⊢p,θ st : S
Γ(p.x)(cid:32)undef
Γ ⊢p,θ (module x = m; st) : (module x : M; S)
StructEmp
Γ ⊢p,θ ϵ : ϵ
Environments typing ⊢ E
EnvSeq
⊢ E
E ⊢ δ
⊢ E, δ
EnvEmp
⊢ ϵ
EnvMod
E ⊢x m : M
E ⊢ (module x = m : M)
E(x)(cid:32)undef
EnvVar
E ⊢ var v : τ
E(v)(cid:32)undef
E(x)(cid:32)undef
EnvAbs
E ⊢ Ml
E ⊢ (module x = absK : M)
Figure 13: Core typing rules.
or procedure declaration, with a type.
δ ::= var v : τ | module p = m : M | module x = absK : M
| proc p.f ((cid:174)v : (cid:174)τ) → τr = body
K ::= open | param
Γ ::= ϵ | Γ, δ
Note that module and procedure declarations can be rooted at an
arbitrary path p.
An abstract module declaration module x = absK : M states that
x is a module with signature M whose code is unknown. This is
used either for open code, or to represent a functor parameter at
typing time. Open modules and parameters are treated differently
Session 10B: Crypto and Protocol Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2555Restriction checking Γ ⊢ { var ((cid:174)vl : (cid:174)τl); s; return e } ▷ θ.
RestrCheck
Γ ⊢ body ▷ λm
Γ ⊢ body ▷ λc
Γ ⊢ body ▷ λm ∧ λc
RestrMemS
memΓ(s) ⊑ λm
Γ ⊢ s ▷ λm
RestrMemExt
Γ ⊢ s ▷ λm
Γ ⊢ e ▷ λm
Γ ⊢ { _; s; return e } ▷ λm
RestrComplTop
Γ ⊢ body ▷⊤
RestrMemE
vars(e) ⊑ λm
Γ ⊢ e ▷ λm
RestrCompl
E ⊢ {⊤} s {ψ | t}
⊢ {ψ} r ≤ tr
(t + tr · 1conc) ≤compl λc
E ⊢ { _; s; return r } ▷ λc
Notes: the relation ⊑ checks the inclusion of a memory restriction
into another, and is defined in Figure 17.
Also, memΓ(s) computes an over-approximation of a instruction’s
memory footprint, and is defined in Figure 18.
Figure 14: Restriction checking rules.
module A = {
module B = { · · · }
module C = {
module E = A.B
module F = B
}}
(∗ Valid full path ∗)
(∗ Invalid path ∗)
Figure 15: Example of valid and invalid paths.
by the type system: a memory restriction ignores the memory foot-
print of a functor parameter; and a complexity restriction restricts
the number of calls that can be made by parameters’ procedures.
Therefore, we annotate an abstract module with its kind, which
can be open or param. Finally, module and procedure declarations
come with the absolute path from the root of the program to the
parent module where the declaration is made (variable and abstract
modules are always declared at top-level).
For example, the entry (module p.x = m : M) means that there
is a sub-module m named x and with type M declared at path
p. As usual we require that typing environments do not contain
two declarations with the same path. This allows to see a typing
environment Γ as a partial function from variable names v, module
paths p or procedure paths p.f to (base, module, abstract modules
or procedure) values and their types, defined as follows:
= τ
= m : M
= absK x : M
Γ(v)
Γ(p)
Γ(x)
Γ(p.f ) = proc f ((cid:174)v : (cid:174)τ) → τr = body
( if Γ = (Γ1; var v : τ ; Γ2))
( if Γ = (Γ1; module p = m : M; Γ2))
( if Γ = (Γ1; module x = absK : M; Γ2))
( if Γ = (Γ1; proc p.f ((cid:174)v : (cid:174)τ) → τr = body; Γ2))
and Γ(z) = undef otherwise. Also, we write Γ(z)(cid:32)undef when
Γ(z′) = undef. for any prefix z′ of z.11
11Meaning that the (variable, module or procedure) path z is not declared by Γ, even
through a sub-module or functor application.
Abstract modules. Abstract modules representing open code (i.e.
with kind open) are restricted to low-order signatures:
Ml ::= sig Sl restr θ end | func(x : sig Sl restr θ end) Ml
Dl ::= proc f ((cid:174)v : (cid:174)τ) → τr
Sl ::= Dl1; . . . ; Dln
Basically, we only allow module structures, or functors whose pa-
rameters are module structures. This restriction is motivated by
the fact that further generality is not necessary for cryptographic
proofs (adversaries and simulations usually return base values, not
procedures); and, more importantly, this restriction allows the ab-
stract call rule of our instrumented Hoare logic Abs presented in
Figure 6 to remain tractable.
For any Ml, we let procs(Ml) = { f1, . . . , fn} be the set of proce-
dure names declared in Ml.
Typing module paths. The typing judgment Γ ⊢ p : M states that
the module path p refers to a module with type M. Its typing rules,
which are given in Figure 13, are standard, except for the functor
application typing rule FuncApp:
FuncApp
Γ ⊢ p : func(x : M′) M
Γ ⊢ p′ : M′
Γ ⊢ p(p′) : M[x (cid:55)→ memΓ(p′)]
A key point here is that we need to substitute x in the module
signature. The substitution function is standard (for a full definition,
see the long version [5]), except for module restrictions, which are
modified as follows:
• a memory restriction restricts the variables that a proce-
dure can access directly — however, memory accesses done
through functor parameters are purposely not restricted.
Hence, when we instantiate a functor parameter x by a mod-
ule path p′, we must add its memory footprint, which is
memΓ(p′). This is handled when substituting x in a memory
restriction:
λm[x (cid:55)→ memΓ(p′)] = λm ⊔ memΓ(p′)
• a complexity restriction gives upper bounds on a procedure
execution time, and on the number of calls it can make to
its functors’ parameters. When we instantiate a functor, we
remove a functor parameter, and therefore remove the cor-
responding entries in the complexity restrictions.
compl[intr : k, y1 .f1 : k1, . . . , yl .fl : kl][x (cid:55)→ _] =
compl[intr : k, (y1 .f1 : k1)[x (cid:55)→ _], . . . , (yl .fl : kl)[x (cid:55)→ _]]
where
(y.f : k)[x (cid:55)→ _] =
if y = x
otherwise
ϵ
y.f : k
(cid:40)
Also, note that when substituting x into p in p.y, we do not
substitute the module component identifier y (essentially, only top-
level module names are substituted). Similarly, when we substitute
x into p in a module declaration (module y = m), we ignore y.
Other typing rules. The typing judgment for module expressions
Γ ⊢p m : M states that the module expression m, declared at path
p, has type M. Functor are typed by the Func rule. Note that the
functor body is typed in an extended typing environment, where
the module parameter x has been declared as an abstract module
with kind param.
Session 10B: Crypto and Protocol Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2556module A = {
module B = { proc f () : unit = · · · }
module C = {
proc g () : unit = · · ·
proc h () : unit = {
A.B.f();
A.C.g();
}}}
Figure 16: Example of procedures typing.
The typing judgment for module structures Γ ⊢p,θ st : S is an-
notated by both the module path of the structure being typed, and
the module restriction θ that the structure must verify. Remark
that when we type a procedure using ProcDecl, we check that the
procedure f body satisfies the module restriction θ[f ] by requiring
that the restriction checking judgment Γ ⊢ body ▷ θ[f ] holds.
The rule RestrMemExt in Figure 14 is more general than the
RestrMem rule presented in the body, as it allows typing a memory
restriction in any typing environment Γ, not only in an environ-
ment E. Crucially, the complexity checking rule RestrCompl is not
extended to typing environment, because the cost Hoare judgment
E ⊢ {⊤} s {ψ | t} is not defined for typing environment.
Remark B.1. While we could probably extend RestrCompl to
allow typing in a typing environment Γ, this would complicate a lot
the soundness proof of our logic. Indeed, as it stands, we do not
need to show closure of Hoare logic derivations under substitution
of a module parameter x of type absparam : M by a concrete module
m of the same type M (because an environment E cannot contain a
declaration of an abstract module of kind param, only of open mod-
ules of kind open, which are never substituted, only instantiated).
Instead, we only need to show closure under such substitution for
typing judgment (not Hoare logic derivations), which makes the
proof simpler.
B.2 Additional Typing Rules
The memory restriction union ⊔, intersection ⊓ and the memory
restriction subset ⊑ operations are defined in Figure 17. In Figure 18,
we present our sub-typing rules, our typing rules for statements
and expressions, and the definition of the function memΓ(p) which
computes the memory footprint of p in Γ. Note that we need two
different rules to type function paths: T-Proc1 does a lookup of
the procedure as a component of an already typed module; and
T-Proc2 does a lookup of the procedure in the typing environment,
in case the procedure is declared in one of the parent modules of
the current sub-module being typed (consequently, these modules
are not yet fully typed).
Example B.1. Consider the modules and procedures given in
Figure 16. When typing h, the typing environment contains one
module declaration and one procedure declaration:
Γ = (module A.B = _ : struct proc f() → unit end);
(proc A.C.g() → unit = . . . )
Here, the call to f in h is typed using the T-Proc1 rule, while the
call to g is typed using T-Proc2.
C MODULE RESOLUTION
Our module resolution mechanism, given in Figure 19, allows to
evaluate any module expression m in a typing environment Γ
(mostly, it takes care of functor applications). Essentially, this de-
fines the semantics of our module system, and will be used to give
the semantics of our programming language in Appendix D.
Extended module resolution. Because a module expression m is
evaluated in a typing environment Γ that can contain abstract mod-
ules (representing open code or functor parameters), the resolved
module resΓ(m) may not be a module expression according to our
syntactic categories. We let extended module expressions be the
elements of the form:
¯m ::= m | absK x
Note that it would not make much sense to extend the syntax of
module expressions to allow them to contain abstract modules, as
abstract modules of kind param are reserved to the type system;
and open modules must be introduced at the logical level (in the
ambient higher-order logic).
Module resolution. The resolution function resΓ(_) evaluates a
module path, in Γ, into a (resolved) extended module expression,
which can be a module structure, a functor, or an (potentially ap-
plied) abstract module. Mostly, resΓ(_) take care of functor applica-
tion through the rules:
resΓ(p(p′)) = resΓ(m0[x (cid:55)→ p′])
(if resΓ(p) = func(x : M) m0)
resΓ(p(p′)) = (absK x)((cid:174)p0, p′)
(if resΓ(p) = (absK x)((cid:174)p0))
(the full definition is in Figure 19). In the concrete functor case, we
must substitute the module identifier x into a path p′ in a module
expression m0.
Example C.1. Consider a typing environment Γ, and the path
x.y(z)(v)(w), which must be read as (((x.y)(z))(v))(w). Then, assum-
ing that Γ(z) = absopen z, Γ(v) = mv, Γ(w) = absparam w and:
Γ(x) = struct module y = func(u : _) u end
where mv is some module expression, then resΓ(x.y(z)(v)(w)) =
(absopen z)(v, w).
We define the module procedure resolution function f-resΓ(m.f ).
A resolved module procedure f-resE(m.f ) is: i) either a concrete
procedure declaration (proc f ((cid:174)v : (cid:174)τ) → τr = body); ii) or the
procedure component f of a resolved (potentially applied) abstract
module (absK x)((cid:174)p).f .
Soundness. Then, we need show that our module resolution
mechanism has the subject reduction property. Unfortunately, this
does not hold, because of sub-modules declarations, as shown in
the following example.
Example C.2. Consider a well-typed typing environment ⊢ Γ,