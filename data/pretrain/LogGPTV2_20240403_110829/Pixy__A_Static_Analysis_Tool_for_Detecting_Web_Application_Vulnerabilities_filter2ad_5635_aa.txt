title:Pixy: A Static Analysis Tool for Detecting Web Application Vulnerabilities
(Short Paper)
author:Nenad Jovanovic and
Christopher Kr&quot;ugel and
Engin Kirda
Pixy: A Static Analysis Tool for Detecting Web Application Vulnerabilities
(Short Paper)
Nenad Jovanovic, Christopher Kruegel, and Engin Kirda
Technical University of Vienna
Secure Systems Lab
{enji,chris,ek}@seclab.tuwien.ac.at
Abstract
The number and the importance of Web applications
have increased rapidly over the last years. At the same time,
the quantity and impact of security vulnerabilities in such
applications have grown as well. Since manual code re-
views are time-consuming, error-prone and costly, the need
for automated solutions has become evident.
In this paper, we address the problem of vulnerable
Web applications by means of static source code analysis.
More precisely, we use ﬂow-sensitive, interprocedural and
context-sensitive data ﬂow analysis to discover vulnerable
points in a program. In addition, alias and literal analysis
are employed to improve the correctness and precision of
the results. The presented concepts are targeted at the gen-
eral class of taint-style vulnerabilities and can be applied to
the detection of vulnerability types such as SQL injection,
cross-site scripting, or command injection.
Pixy, the open source prototype implementation of our
concepts, is targeted at detecting cross-site scripting vul-
nerabilities in PHP scripts. Using our tool, we discovered
and reported 15 previously unknown vulnerabilities in three
web applications, and reconstructed 36 known vulnerabil-
ities in three other web applications. The observed false
positive rate is at around 50% (i.e., one false positive for
each vulnerability) and therefore, low enough to permit ef-
fective security audits.
1. Introduction
Web applications have become one of the most impor-
tant communication channels between various kinds of ser-
vice providers and clients. Along with the increased impor-
tance of Web applications, the negative impact of security
ﬂaws in such applications has grown as well. Vulnerabili-
ties that may lead to the compromise of sensitive informa-
tion are being reported continuously, and the costs of the
resulting damages are increasing. The main reasons for this
phenomenon are time and ﬁnancial constraints, limited pro-
gramming skills, or lack of security awareness on part of
the developers.
The existing approaches for mitigating threats to Web
applications can be divided into client-side and server-side
solutions. The only client-side tool known to the authors
is Noxes [14], an application-level ﬁrewall offering protec-
tion in case of suspected cross-site scripting (XSS) attacks
that attempt to steal a user’s credentials. Server-side solu-
tions have the advantage of being able to discover a larger
range of vulnerabilities, and the beneﬁt of a security ﬂaw
ﬁxed by the service provider is instantly propagated to all
its clients. These server-side techniques can be further clas-
siﬁed into dynamic and static approaches. Dynamic tools
(e.g., [9, 18, 21], and Perl’s taint mode try to detect attacks
while executing the audited program, whereas static analyz-
ers ([10, 11, 15, 16]) scan the Web application’s source code
for vulnerabilities.
In this paper, we present Pixy, the ﬁrst open source tool
for statically detecting XSS vulnerabilities in PHP 4 [20]
code by means of data ﬂow analysis. We chose PHP as
target language since it is widely used for designing Web
applications [23], and a substantial number of security ad-
visories refer to PHP programs [3]. Although our prototype
is aimed at the detection of XSS ﬂaws, it can be equally
applied to other taint-style vulnerabilities such as SQL in-
jection or command injection (see Section 2). The main
contributions of this paper are as follows:
• A ﬂow-sensitive,
interprocedural,
and context-
targeted at
sensitive data ﬂow analysis for PHP,
detecting taint-style vulnerabilities.
This analysis
process had to overcome signiﬁcant conceptual
challenges due to the untyped nature of PHP.
• Additional literal analysis and alias analysis steps that
lead to more comprehensive and precise results than
those provided by previous approaches.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:23 UTC from IEEE Xplore.  Restrictions apply. 
• Pixy, a system that implements our proposed analysis
technique, written in Java and licensed under the GPL.
• Experimental validation of Pixy’s ability to detect un-
known vulnerabilities with a low false positive rate.
2. Taint-Style Vulnerabilities
The presented work is targeted at the detection of taint-
style vulnerabilities. Tainted data denotes data that origi-
nates from possibly malicious users and that can possibly
cause security problems at vulnerable points in the program
(called sensitive sinks). Tainted data may enter the program
at speciﬁc places, and can spread across the program via as-
signments and similar constructs. Using a set of suitable op-
erations, tainted data can be untainted (sanitized), removing
its harmful properties. Many important types of vulnerabil-
ities (e.g., cross-site scripting or SQL injection) can be seen
as instances of this general class of taint-style vulnerabili-
ties. An overview of these vulnerabilities is given in [15].
2.1. Cross-Site Scripting (XSS)
One of the main purposes of XSS attacks is to steal
the credentials (e.g., the cookie) of an authenticated user
by means of malicious JavaScript code. Due to the sand-
box model, JavaScript has access only to cookies that be-
long to the site from which the JavaScript originated. XSS
attacks circumvent the sandbox model by injecting mali-
cious JavaScript into the output of vulnerable applications
that have access to the desired cookies. More details on
this attack can be found in [4]. When speaking in terms of
the sketched class of taint-style vulnerabilities, XSS can be
roughly described by the following properties:
• Entry Points into the program: GET, POST and
COOKIE arrays.
• Sanitation Routines:
htmlspe-
cialchars(), and type casts that destroy potentially
malicious characters or transform them into harmless
ones (such as casts to integer).
htmlentities(),
• Sensitive Sinks: All routines that return data to the
browser, such as echo(), print() and printf().
2.2. Other Vulnerabilities
Although our current prototype focuses on XSS vulner-
abilities, other vulnerabilities such as SQL injection and
command injection have been identiﬁed as belonging to the
general class of taint-style vulnerabilities and differ only
with respect to the concrete values of a few parameters. The
presented concepts are targeted at their underlying general
characteristics, and adjusting Pixy to the detection of other
instances only requires some engineering effort.
3. Data Flow Analysis
The goal of our analysis is to determine whether it is
possible that tainted data reaches sensitive sinks without be-
ing properly sanitized. For this, we apply the technique of
data ﬂow analysis, which is a well-understood topic in com-
puter science and has been used in compiler optimizations
for decades ([1, 17, 19]). In a general sense, the purpose
of data ﬂow analysis is to statically compute certain infor-
mation for every single program point (or for coarser units
such as functions). For instance, the classical constant anal-
ysis1 computes, for each program point, the literal values
that variables may hold.
Data ﬂow analysis operates on the control ﬂow graph
(CFG) of a program. Hence, we ﬁrst construct a parse
tree of the PHP input ﬁle using the Java lexical analyzer
JFlex [12] and the Java parser Cup [5]. The parse tree is
then transformed into a linearized form resembling three-
address code [1], and kept as a control ﬂow graph for each
encountered function.
A straightforward approach to solving the problem of de-
tecting taint-style vulnerabilities would be to immediately
conduct a taint analysis on the intermediate three-address
code representation generated by the front-end. This taint
analysis would identify points where tainted data can en-
ter the program, propagate taint values along assignments
and similar constructs, and inform the user of every sen-
sitive sink that receives tainted input. However, to enable
the analysis to produce correct and precise results, signiﬁ-
cant preparatory work is required. For instance, whenever
a variable is assigned a tainted value, this taint value must
not be propagated only to the variable itself, but also to all
its aliases (variables pointing to the same memory location).
Hence, we also perform an alias analysis for providing in-
formation about alias relationships. Moreover, it would be
very beneﬁcial for the taint analysis to know about the lit-
eral values that variables and constants may hold at each
program point. This task is performed by literal analysis.
Currently, we use the information collected by literal analy-
sis to evaluate branch conditions and ignore program paths
that cannot be executed at runtime (a technique called path
pruning). Other potential uses of literals information would
be the resolution of non-literal include statements, variable
variables, variable array indices, and variable function calls.
One of the key features of our analysis is its high preci-
sion, since it is ﬂow-sensitive, interprocedural, and context-
sensitive. Moreover, we are the ﬁrst to perform alias analy-
1Note that we use the name “literal analysis” instead of the classical
term “constant analysis” in order to prevent confusion with PHP’s con-
stants.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:23 UTC from IEEE Xplore.  Restrictions apply. 
sis for an untyped, reference-based scripting language such
as PHP. Although there exists a rich literature on C pointer
analysis, it is questionable whether these techniques can
be directly applied to the semantically different problem
of alias analysis for PHP references. As mentioned in an
unpublished paper by Xie and Aiken [25], static analysis
of scripting languages is regarded as a difﬁcult problem
and has not achieved much attention so far.
In this con-
text, even apparently trivial issues such as the simulation of
the effects of a simple assignment require careful consid-
erations. For instance, multi-dimensional arrays can con-
tain elements that are neither explicitly addressed nor de-
clared. To correctly handle the assignment of such a multi-
dimensional array to another array variable, these hidden
elements must be taken into account. More details on these
and other aspects of the applied analyses can be found in
our full-length technical report [13].
3.1. Limitations
Currently, Pixy does not support object-oriented features
of PHP. Each use of object member variables and methods
is treated in an optimistic way, meaning that malicious data
can never arise from such constructs. In addition, ﬁles in-
cluded with “include” and similar keywords are not scanned
automatically. In our experiments, we frequently observed
false positives stemming from these lacking ﬁle inclusions,
which we eliminated through manual inclusion. Unfortu-
nately, automation of this manual procedure is not straight-
forward because ﬁle inclusions in PHP are dynamic, in con-
trast to the static preprocessor includes in C. This means that
the names of the ﬁles to be included can be constructed at
run-time, recursive and conditional inclusions are permit-
ted, and included ﬁles can even return values. In this sense,
the inclusion mechanism of PHP strongly resembles that
of function calls, with a number of differences concerning
variable scoping.
4. Empirical Results
We performed a series of experiments with our proto-
type implementation to demonstrate its ability to detect pre-
viously known cross-site scripting vulnerabilities, as well
as new ones. To this end, Pixy was run on six popular,
open source PHP programs. The program ﬁles on which
Pixy was evaluated and our prototype itself can be obtained
from our website [13]. Since Pixy does not automatically
continue its analysis into included ﬁles yet, we manually
resolved include relationships for the scanned ﬁles. More
precisely, we simply provided missing function deﬁnitions
and static deﬁnitions of global variables, which took less
than an hour for each application. We are currently working
on a straightforward extension that automatically inlines in-
cluded ﬁles, which would eliminate this manual task. Each
ﬁle was analyzed in less than a minute using a 3.0 GHz Pen-
tium 4 processor with 1GB RAM, even though our proto-
type still presents many opportunities for performance tun-
ing.
Tables 1 and 2 summarize the results of our experiments.
In three applications, we reconstructed 36 known vulnera-
bilities with 27 false positives (FP’s). In three other applica-
tions, we discovered 15 previously unknown vulnerabilities
with 16 false positives.
In these cases, we informed the
authors about the issues and posted security advisories to
the BugTraq mailing list [3]. Pixy also reported a few pro-
gramming bugs not relevant for security, such as function
calls with too many arguments. Note that since these bugs
have no inﬂuence on a program’s security properties, they
were counted neither as vulnerabilities nor as false posi-
tives. These results clearly show that our analysis is capable
of ﬁnding novel vulnerabilities in real-world applications.
4.1. Case Studies
Detailed descriptions of the discovered vulnerabilities
can be found in the corresponding BugTraq postings.
In
this section, we will take a closer look at two interesting
vulnerabilities that demonstrate the requirement to perform
an analysis that is able to track data ﬂows throughout the
program.
The Reviews Module of PhpNuke contains an interesting
ﬂaw related to the use of a superﬁcially harmless-looking
built-in function. Our analyzer makes sure that all built-in
functions are considered to return tainted values by default.
This way, no vulnerabilities can be missed due to built-in
functions that have not been modeled explicitly to return un-
tainted values. Explicit modeling is performed by providing
a short speciﬁcation in a conﬁguration ﬁle that is processed
at start-up. A list of currently modeled built-in functions
can be found in our technical report [13]. False positives
arising from harmless but unmodeled functions can easily
be eliminated by providing a speciﬁcation of the function’s
true behavior. In Figure 1, a simpliﬁed version of the vul-
nerable code shows that the second parameter of function
postcomment is echoed on Line 3. Originally, this warning
was issued because the function urldecode was unmodeled,
and hence, returned a tainted value. However, a look into
the PHP manual revealed that urldecode has to be handled
with care, since it is able to transform benign character se-
quences into dangerous ones, such as transforming %3c into
<. This is why even explicit sanitization prior to the call of
function postcomment fails, which was reported in BugTraq
posting 10493.
Figure 2 shows a simpliﬁed version of the ﬁle pre-
view static cgi.php in Simple PHP Blog. The sensitive sink
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:23 UTC from IEEE Xplore.  Restrictions apply. 
1: function postcomment($id, $title) {
2:    $title = urldecode($title);
3:    echo $title;
4: }
Figure 1. PhpNuke vulnerability (simpliﬁed).
1: if (...) {
2:    $entry = $_GET[’entry’];
3:    $temp_file_name = $entry;
4: } else {
5:    $temp_file_name =
         stripslashes($_POST[’file_name’]);
6: }
7: echo($temp_file_name);
Figure 2. Simple PHP Blog vulnerability (sim-
pliﬁed).
on Line 7 receives the variable $temp ﬁle name, which is
initialized with a tainted value on both program paths of the
“if”-construct on Line 1. If the guarding condition is true,
the variable is initialized with $entry (on Line 3), which was
assigned a tainted value from the GET array before (Line
2). Inside the second branch, $temp ﬁle name is tainted by
a POST variable indirectly over a call to the built-in func-
tion stripslashes. This function returns the taint value of
its parameter and has been modeled to do so. Note that
Pixy would also have correctly detected a vulnerability if
$temp ﬁle name were assigned an untainted value on just
one of the two branches.
4.2. False Positives
Among the 47 false positives that Pixy reported, 14 were
caused by global variables that are initialized dynamically
(e.g., through a database read) inside an included ﬁle. As
mentioned previously, we only considered static initializa-
tions during the manual preprocessing step. Since uninitial-
ized globals are conservatively treated as tainted, warnings
were issued at the program points where these variables are
sent back to the user. We are conﬁdent, however, that these
false positives will be eliminated when include ﬁles are au-
tomatically processed as well.