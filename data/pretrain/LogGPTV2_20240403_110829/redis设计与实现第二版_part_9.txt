升级
图 6-4 
元
位
contents 数组的各个元素，
0至15位
图6-3
INTSET_ENC_INT16
contents
encoding
length
intset
一个包含三个int16_t类型的
16至31位
元素的整数集合
以及它们所在的位
32至47位
123
---
## Page 53
ENC_INT32，并将length 属性的值从3改为 4，设置完成之后的整数集合如图6-10所示。
contents 数组的索引l 3 位置上，也即是数组的 96 位至 127 位的空间内，如图 6-9 所示。
contents 数组的索引 o位置上,
contents 数组的索引 1位置上，也即是数组的 32 位至 63 位的空间内，如图 6-7 所示。
contents 数组的索引 2 位置上，也即是数组 64 位至 95 位的空间内，如图 6-6 所示。
正确的位上面，而且在放置元素的过程中，需要维持底层数组的有序性质不变。
所以程序接下来要做的就是将这三个元素转换成int32_t 类型，并将转换后的元素放置到
最后，程序将整数集合encoding 属性的值从 INTSET_ENC_INT16改为 INTSET
然后，因为元素65535在1、2、3、65535四个元素中排名第四，所以它将被添加到
之后，因为元素1在1、2、3、65535四个元素中排名第一，
接着，
首先，
元素
位
，因为元素2在1、2、3、65535四个元素中排名第二，所以它将被移动到
因为元素3在1、2、3、65535四个元素中排名第三，
0至15位
元素
位
位
元素
元
元素
位
0至15位
图6-8对元素1进行类型转换，并保存在适当的位上
图6-7
图6-6对元素3进行类型转换，并保存在适当的位上
16至31位
从 int16_t 类型转换为 int32_t 类型
0至31位
0至31位
2
0至15位
对元素2进行类型转换，并保存在适当的位上
从int16_t类型转换为int32_t类型
16至31位
图 6-5
图6-9添加 65535 到数组
 即数组的 0 位至 31位的空间内，如图 6-8 所示。
32至47位
从int16_t类型转换为int32_t类型
32至63位
进行空间重分配之后的数组
32至63位
16至31位
2
32至63位64位至95位
（新分配空间）
48至63位
64位至95位
64位至95位
32至47位
96位至127位
64位至95位
96位至127位
（新分配空间）
添加新元素
（新分配空间）
48至127位
65535
96位至127位
（新分配空间）
，所以它将被移动到
196位至127位
所以它将被移动到
第6章整数集合·49
（新分配空间）
---
## Page 54
50·第一部分数据结构与对象
作只会在有需要的时候进行，这可以尽量节省内存。
int64_t类型的空间去保存它们，从而出现浪费内存的情况。
即使添加到整数集合里面的都是 int16_t 类型或者 int32_t 类型的值，数组都需要使用
最简单的做法就是直接使用int64_t类型的数组作为整数集合的底层实现。不过这样一来，
6.3.2节约内存
这种做法非常灵活。
int16_t、int32_t 或者 int64_t 类型的整数添加到集合中，而不必担心出现类型错误,
int32_t 类型的数组来保存int32_t 类型的值，诸如此类。
放在同一个数据结构里面。
6.3.1提升灵活性
约内存。
6.3升级的好处
级过程类似。
ENC_INT64 编码，升级的过程都和上面展示的升
者从INTSET_ENC_INT32 编码升级为INTSET_
INT16编码升级为INTSET_ENC_INT64编码，或
新元素的时间复杂度为 O(M)。
有的所有元素进行类型转换，所以向整数集合添加
新元素的值要么就大于所有现有元素，要么就小于所有现有元素：
而整数集合现在的做法既可以让集合能同时保存三种不同类型的值，又可以确保升级操
当然，要让一个数组可以同时保存 int16_t、int32_t、int64_t三种类型的值，
但是，因为整数集合可以通过自动升级底层数组来适应新元素，所以我们可以随意地将
例如，我们一般只使用 int16_t 类型的数组来保存 int16_t类型的值，只使用
因为C语言是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值
整数集合的升级策略有两个好处，一个是提升整数集合的灵活性，另一个是尽可能地节
其他类型的升级操作，比如从INTSET_ENC_
因为每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已
口在新元素小于所有现有元素的情况下，新元素会被放置在底层数组的最开头
因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个
0
(索引 length-1 )。
在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾
（索引0）；
升级之后新元素的摆放位置
图6-10完成添加操作之后的整数集合
INTSET_ENC_INT32
contents
length
encoding
intset
1123 65535
---
## Page 55
6.6
6.5
INTSET_ENC_INT64，底层数组也仍然会是 int64_t 类型的，如图6-12 所示。
使用int64_t 类型来保存的元素 4 294967 295删除了，整数集合的编码仍然会维持
6.4
值添加到集合时，程序才会对数组进行升级。
就会一直是int16_t 类型的数组，只有在我们要将 int32_t 类型或者int64_t 类型的
 intsetBlobLen
intsetLen
intsetRandom
intsetGet
intsetFind
intsetRemove
intsetAdd
intsetNew
图6-11数组编码为INTSET_ENC_INT64的整数集合
INTSET_ENC_INT64
口整数集合只支持升级操作，不支持降级操作。
口升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。
口整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有
整数集合是集合键的底层实现之一。
表6-1列出了整数集合的操作 API。
举个例子，对于图6-11所示的整数集合来说，即使我们将集合里唯一一个真正需要
整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。
降级
例如，如果我们一直只向整数集合添加 int16_t类型的值，那么整数集合的底层实现
重点回顾
1.5
整数集合 API
contents
encoding
需要时，程序会根据新添加元素的类型，改变这个数组的类型。
length
intset
5]1012 65535 4294967295
返回整数集合占用的内存字节数
返回整数集合包含的元素个数
取出底层数组在给定索引上的元素
从整数集合中随机返回一个元素
检查给定值是否存在于集合
从整数集合中移除给定元素
将给定元素添加到整数集合里面
创建一个新的压缩列表
作
表 6-1  整数集合 API
用
图6-12 删除 4 294967 295 的整数集合
法来进行，所以复杂度为 O(logM)
INTSET_ENC_INT64
0(1)
0(1)
0(1)
0(1)
因为底层数组有序，查找可以通过二分查找
O(M)
O(M)
0(1)
contents
encoding
intset
时间复杂度
第6章整数集合·51
5101265535
---
## Page 56
保存一-个字节数组或者一个整数值。
7.1
及相关操作进行详细的介绍。
要么就是长度比较短的字符串，那么 Redis 就会使用压缩列表来做哈希键的底层实现。
这样的短字符串。
会使用压缩列表来做列表键的底层实现。
列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么 Redis 就
另外，当一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，
图 7-1展示了压缩列表的各个组成部分，表7-1 则记录了各个组成部分的类型、长度以
压缩列表是Redis 为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺
哈希键里面包含的所有键和值都是小整数值或者短字符串。本章将对压缩列表的定义以
举个例子，执行以下命令将创建一个压缩列表实现的哈希键：
列表键里面包含的都是1、3、5、10086这样的小整数值，以及"hello"、"world"
例如，执行以下命令将创建一个压缩列表实现的列表键：
"ziplistn
redis> OBJECT ENCODING profile
redis> HMSET profile "name" "Jack" "age" 28 "job" "Programmer"
redis> OBJECT ENCODING lst 
"PIiom, "oTiau. 98001 S E I 4sT Hsnaα <Stpax
压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量
"ziplist"
(integer)6
压缩列表的构成
压缩列表
第7章
---
## Page 57
及用途。
 zlend
entryx
zltail
zlbytes
zlbytes
zllen
0xd2
属性
口列表 z1len 属性的值为 0x5（十进制 5），表示压缩列表包含五个节点。
口列表z1bytes 属性的值为0xd2（十进制 210），表示压缩列表的总长为 210字节。
图7-3展示了另一个压缩列表示例：
口列表 z1len 属性的值为 0x3（十进制3），表示压缩列表包含三个节点。
口 列表 z1tai1属性的值为 0x3c（十进制 60），这表示如果我们有一个指向压缩列
口列表z1bytes 属性的值为0x50（十进制 80），表示压缩列表的总长为 80 字节。
图 7-2展示了一个压缩列表示例：
zlbytes
entry5 的地址。
表起始地址的指针 p，那么只要用指针p加上偏移量179，就可以计算出表尾节点
0x50
entry3的地址。
表起始地址的指针 p，那么只要用指针p加上偏移量60，就可以计算出表尾节点
zlbytes
uint16_t
uint32_t
uint32_t
zltail
uint8_t
列表节点
0xb3
类型
zltail
0x3c
zltail
zllen
2字节
1字节
不定
4字节
4字节
0x5
长度
表 7-1
zllen
图7-3包含五个节点的压缩列表
entry1
图7-2
zllen
UINT16_MAX时，节点的真实数量需要遍历整个压缩列表才能计算得出
（65535）时，这个属性的值就是压缩列表包含节点的数量；当这个值等于
偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址
或者计算 zlend 的位置时使用
图 7-1压缩列表的各个组成部分
0x3
特殊值0xFF（十进制255），用于标记压缩列表的末端
压缩列表包含的各个节点，节点的长度由节点保存的内容决定
记录了压缩列表包含的节点数量：当这个属性的值小于UINT16_MAX
记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个
记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，
压缩列表各个组成部分的详细说明
包含三个节点的压缩列表
entryi
entry2
entryl
entry2
entry3
entry2
用 
entry4
entryN
entry3
p+60
entry5
第7章压缩列表·53
p+179
zlend
OxFE
zlend
---
## Page 58
54第一部分教据结构与对象
才是前一节点的实际长度。
中值的最高位字节OxFE表示这是一个五