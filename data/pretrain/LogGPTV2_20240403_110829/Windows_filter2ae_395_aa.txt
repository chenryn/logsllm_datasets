# 走进Windows中的提权行为
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
在 [《基于异常行为检测CobaltStrike》](https://blog.moofeng.cn/wei-xie-shou-lie/ji-yu-yi-chang-hang-wei-jian-ce-cobaltstrike#privilege-escalation) 一文里，简单提及过
CobaltStrike 的提权方式，当时受限于篇幅，没有深入研究
最近看了几篇文章，结合对一些数据源的思考，想在这里汇总下部分常见提权手法的攻击原理和检测技巧
本文主要关注 GetSystem 的过程，对应 ATT&CK 攻击框架中的 [T1134 – Access Token
Manipulation](https://attack.mitre.org/techniques/T1134/)，不涉及 UAC bypass
因为相关名词较多，例如 logon session 和 access token，过程理解可能需要一定的前置知识
这些都写进来怕显得文章又臭又长，以后有精力再另起一篇总结下知识背景吧
以下主要选择两种技术对象作为演示实例—— **命名管道提权** 和 **访问令牌窃取**
## 命名管道提权
还是从最经典的 meterpreter 中的 getsystem 命令讲起，因为有
[源码](https://github.com/rapid7/metasploit-payloads/blob/master/c/meterpreter/source/extensions/priv/namedpipe.c)
可供参考，更方便读者理解
其代码注释中也简单解释了下工作原理和前置条件：
> Elevate from local admin to local system via Named Pipe Impersonation.
>
> We spawn a cmd.exe under local system which then connects to our named pipe
> and we impersonate this client.
>
> This can be done by an Administrator without the need for .
>
> Works on 2000, XP, 2003 and 2008 for all local administrators. On Vista and
> 7 it will only work if the host process has been elevated through UAC first.
> Does not work on NT4.
该技术的核心在于对 **ImpersonateNamedPipeClient** API 的利用，通过命名管道的服务端进程模仿客户端进程的访问令牌，获取
SYSTEM 权限
关于该 API 的详细说明，具体内容可以参考 [官方文档](https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-impersonatenamedpipeclient)
当然，想调用它，前提是进程具备 SeImpersonatePrivilege 的权限，而这通常意味着我们已经是 Admin 用户了
对照源代码，我大致拆解了下该模块具体的实现步骤：
1) getsystem 新建一个线程创建命名管道并等待服务发来的连接 (服务端)  
2) getsystem 创建了一个以 SYSTEM 权限运行的 Windows 服务，该服务会向命名管道发起连接 (客户端)  
3) 启动该服务，向目标命名管道发起连接 (客户端 -> 服务端)  
4) 该进程(服务端)接收连接，调用 ImpersonateNamedPipeClient，从而模仿了 SYSTEM 权限的访问令牌  
5) 完成提权过程后，停止并删除该服务
先简单的复现一下，然后让我们去日志中一一验证 getsystem 的行为轨迹
###  第一步：创建命名管道
这一步在 sysmon 中有对应的 EID 17 (Pipe Created) 日志记录，很容易就能观测到
另外，在时间节点附近，结合该进程对应的 Guid 我们还能看到它更多的动作，文中后半部分有所演示
###  第二步：创建服务
这一步我们可以借助 Windows 系统日志观测到 EID 7045 (A new service was installed in the system)
的事件发生
不过我习惯了使用 sysmon，但是其日志类型中并没有涉及到 Windows 服务，那是不是就束手无策了呢？
这里需要了解一个小窍门： **Windows 安装服务的时候会写入注册表的特定位置**
这一知识可以应用在检测 Windows 可疑服务的创建，比如注册表键值中包含 powershell 敏感命令、base64 编码、特殊路径等
那么借助以下命令，我们就能定位到这一步创建的服务名称和命令参数等信息
`index=windows EventCode=13
TargetObject="HKLM\\System\\CurrentControlSet\\Services\\*\\ImagePath"`
从上图结果中能很明显的看出，该服务启动后(此时尚未启动)会向服务端的命名管道写入数据
###  第三步：启动服务，连接管道
关于 Windows 服务的启动，这里有个很有意思的细节
本来我还愁找不到相应的系统日志来监测服务的启动行为，但是经过多次实验后，却发现每次都会伴随着 EID 7009 (服务连接超时)的发生
这时我才留意到源码中的这行注释，突然想起来，类似 cmd.exe 这种非有效的服务，它不会向服务管理器返回信号
例如，如果我们在命令行中手动创建个简易的服务，然后再看看事件管理器中的系统日志
由此引起的 EID 7009，同样可以作为我们判断 getsystem 命令执行过程中启动服务的证据
而服务启动后，我们可以结合前面分析的命令行参数，检索到其触发 EID 1(Process Create) 的相应动作
该命令向服务端命名管道发起连接，这一行为会被 sysmon 的 EID 18 (Pipe Connected) 记录到
###  第四步：调用 API，完成提权
API 的调用暂无对应日志记录，但是可以根据用户名(User)和进程完整性(IntegrityLevel)等字段定位到提权的结果
如果这时我们在 MSF 的控制台执行 shell 命令，可以看到一个 SYSTEM 权限的 cmd.exe 诞生，而其父进程却是非 SYSTEM 权限
这一特征也标识着整个提权行为的顺利完成，更多的原理细节和检测步骤可以参考文章后半部分的内容
###  第五步：删除服务
最后一步容易被很多人忽视——痕迹清除，这一行为在成熟的攻击框架中做得很到位，但同时也有利于我们做行为检测分析
我也是通过分析源码才记起来加上这一检测点，从而在日志中发现了服务删除的动作
## 访问令牌窃取
除了上面例子中使用到的 ImpersonateNamedPipeClient 之外，还有一些 Windows API 也能帮助我们完成到 SYSTEM
权限的提升
例如 ImpersonateLoggedOnUser、DuplicateTokenEx 等等
以上图右边最经典的提权路线为例，我简单解释下各步骤：
1) 通过 [OpenProcess](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess) 获取
SYSTEM 权限进程的句柄  
2) 通过 [OpenProcessToken](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken)
获取该进程的访问令牌  
3) 通过 [DuplicateTokenEx](https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex)
函数复制该令牌  
4) 通过 [CreateProcessWithTokenW](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw) 创建具备同样访问令牌的进程
贴一段自己测试时使用的代码，参考  修改而来
    #include 
    #include 
    int main(int argc, char** argv) {
        // Grab PID from command line argument
        char *pid_c = argv[1];
        DWORD PID_TO_IMPERSONATE = atoi(pid_c);
        HANDLE tokenHandle = NULL;
        HANDLE duplicateTokenHandle = NULL;
        STARTUPINFOW startupInfo;
        PROCESS_INFORMATION processInformation;