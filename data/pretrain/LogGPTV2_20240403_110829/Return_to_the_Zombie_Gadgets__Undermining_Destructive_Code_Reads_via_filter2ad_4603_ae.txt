Yes (manual)
77%
76%
78%
84%
63%
67%
51%
64%
76%
70%
Yes (automatic)
within the segment remains the same. By leveraging multiple
copies of the same generated code, our attack can destructively
read the generated code until the preamble of a gadget—which
is known in advance—is found. Destroying some gadgets of
interest during this process is not a problem, as they can be
located in other JIT’ed copies of the same generated code
by following the same strategy. At the same time, constant
blinding of only 4-byte constants leaves enough room for the
generation of useful gadgets by exploiting 1-byte and 2-byte
constants, and overlapping instructions [2]. Simply extending
constant blinding to smaller constants is not an attractive
solution, as the associated overhead has been shown to be
prohibitively high [2]. Additionally, Evans et al. [20] and
Carlini et al. [14] have shown that protections based on CFI at
the JIT engine level [34] may still allow an attacker to generate
enough permitted control ﬂow paths for the construction of a
functional ROP payload.
B. On Reloaded Code Gadgets Available
We now turn our attention to the feasibility of our attacks
leveraging the lack of code persistence in destructive code
reads, namely the library reload and process reload attacks
described in section §V. These attacks more closely follow the
original methodology of just-in-time code reuse attacks in that
we leak an initial code pointer from a virtual function pointer
table (vtable) by leveraging a memory disclosure attack, then
proceed to disclose gadgets in that
library module. Note,
however, that in the case of shared library reloads, we are
limited to disclosing only those gadgets within the libraries
we can load and unload. That is, disclosing any other bytes
of code will leave that code destroyed with no way to restore
it to it’s original form. Thus, Table I provides an analysis of
the gadgets available in the speciﬁc libraries we control in our
example attack (d3d10warp.dll and urlmon.dll).
Speciﬁcally, we analyzed gadgets in the libraries with both
the ROPSHELL3 gadget engine and the JIT-ROP gadget
engine. Examining those unique gadgets more closely, we
found a number of useful gadgets in each category in both
3See the interface available at ropshell.com.
libraries. Note that even after eliminating those gadgets located
in execution paths for loading and unloading the libraries, we
can still identify gadgets of each type. Unfortunately, even
with all gadget types being available, the JIT-ROP compiler
was unable to automatically generate a payload using only the
gadgets identiﬁed in each distinct library. However, we were
able to construct functional code reuse payloads by inspecting
the available gadget set and manually chaining together gad-
gets in ways not supported by the automated compiler. One
could, of course, update the JIT-ROP compiler to recognize
and make use of those combinations automatically.
Fig. 10. The number of gadgets found in each JIT-ROP category across all
reachable libraries that are also available for disclosure (i.e., those gadgets
that are not executed during normal program execution).
Our process reload technique is much more ﬂexible in terms
of where gadgets may be disclosed than the library reload
attack. That is, we may recursively disclose gadgets in any
library that the initially disclosed library depends upon. To do
so, we simply follow function pointers in the module’s import
section to navigate to new shared library modules. Indeed,
we found that when using vgx.dll as the starting point (as
given by the speciﬁc exploit we used), we could ultimately
navigate to 42 of the 109 loaded libraries by recursively
963963
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:10:39 UTC from IEEE Xplore.  Restrictions apply. 
following imports using the same memory disclosure. Table I
also reports both the gadgets found in vgx.dll as well as
the cumulative percent of gadgets available in all reachable
(and loaded) libraries.
LoadReg:
| pop edi | ret
(value to load)
LoadReg:
| pop esi | ret
(value to load)
LoadReg:
| pop ebp | retn 0xc
(value to load)
(padding)
(padding)
(padding)
LoadReg:
| pop ebx | ret
(value to load)
PushA: LOADLIBRARYW* | pusha
String data (’kernel32’)
String data
String data
String data
String data
LoadReg:
| pop edi | ret
(value to load)
LoadReg:
| pop esi | ret
(value to load)
| ret
| ret
MovReg:
LoadReg:
| xchg eax,ebp | ret
| pop ebx | ret
(value to load)
PushA: GETPROCADDRESS* | pusha
String data (’WinExec’)
String data
LoadReg:
| pop edi | ret
(value to load)
MovReg:
LoadReg:
| xchg eax,esi | ret
| pop ebp | retn 0xc
(value to load)
(padding)
(padding)
(padding)
LoadReg:
| pop ebx | ret
(value to load)
LoadReg:
| pop edx | retn 0x8
(value to load)
(padding)
(padding)
PushA: WINEXEC* | pusha
String data (’calc’)
String data
| ret
Listing 2. High-level representation of the ROP payload automatically
generated by JIT-ROP using gadgets available in the reachable libraries.
The disclosure of only the initial shared library, vgx.dll,
yields results similar to that of the shared library reload
technique. We observe signiﬁcantly more gadgets when con-
sidering that, in practice, the adversary will be able to disclose
the code of all libraries dependent on that initial library. As
shown in Table I and Figure 10, we are able to identify a
plethora of gadgets in each of the requisite categories that are
useful for building a malicious code reuse payload. Indeed, the
JIT-ROP compiler is able to automatically construct a code
reuse payload in this case that launches the calculator process
and cleanly exits the exploited process. Listing 2 depicts one
of the many possible payloads that could be automatically
generated by the JIT-ROP compiler. In short, each line of the
listing represents one 8-byte value to be loaded on the program
stack after a control-ﬂow hijacking followed by a stack pivot.
964964
Gadgets execute, in order, from the ﬁrst line to the last, with
data and padding intermingled between the gadget pointers.
The most important take-away of Table I and Figure 10,
however, is not the number of gadgets and types that we are
able to identify in this particular exploit instance, or even
whether we are able to build a payload from those gadgets.
Indeed, one can likely discover more gadgets using different
techniques from those employed in this paper, such as using
jump [10] or call-oriented programming [13] or use more
sophisticated techniques for identifying standard ROP gadgets
with or without side-effects. Instead, our results conservatively
describe the effectiveness of destructive code reads empirically
by noting the average reduction of gadgets across all of these
experiments.
In doing so we conclude that, conservatively, destructive
code reads offer only a 30% reduction in the gadgets available
to the attacker, and this reduction is wholly attributable to
eliminating gadgets that exist within the normal program
execution path. That is, disclosing a gadget located in the
normal program execution path results in the destruction of
that code, and ultimately the program crashes before an exploit
can complete.
C. On Implicit Code Reads
To assess the feasibility of implicit code disclosure against
the in-place code randomization technique of Pappas et al.
[35], we evaluated how many randomized gadgets can be
implicitly read by following the inference strategy outlined in
Section IV-D. As discussed, the effectiveness of implicit dis-
closure in the face of instruction substitution and basic block
instruction reordering depends on multiple factors related to
the speciﬁcs of the particular randomized gadget, including
(but not limited to) the size of the basic block in which it is
contained and the location of substitutable instructions.
Due to the complexity involved in that analysis, and more
importantly, the lower coverage of those two transformations,
we opted instead to focus on register reassignment and reg-
ister preservation code reordering. Given the nature of these
two transformations, precise inference of the state of these
randomized gadgets is always possible without having to
destructively read even a single byte of the gadget being
revealed—only memory locations preceding the actual gadget
must be disclosed.
As an example, Figure 11 shows the bytes of the randomized
instance of the code depicted in Figure 8. By destructively
reading just two bytes, corresponding to the two out of the
three instructions that can be reordered at
the function’s
prologue, an attacker can infer the values of the randomized
bytes at the function’s epilogue, i.e., which of the six possible
orderings of the pop instructions of the gadget is actually
used. Similarly, as shown in Figure 12 (which corresponds to
the example of Figure 9), by destructively reading just a single
byte, an attacker can infer which of the two possible register
operand combinations are used in the gadget.
For our empirical analyses, we used a set of 47 libraries
from Adobe Reader v9.3 and Adobe Acrobat Reader DC,
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:10:39 UTC from IEEE Xplore.  Restrictions apply. 
(cid:39)(cid:72)(cid:86)(cid:87)(cid:85)(cid:88)(cid:70)(cid:87)(cid:76)(cid:89)(cid:72)(cid:3)(cid:53)(cid:72)(cid:68)(cid:71)(cid:86)(cid:3)(cid:11)(cid:21)(cid:3)(cid:69)(cid:92)(cid:87)(cid:72)(cid:86)(cid:12)
(cid:44)(cid:81)(cid:73)(cid:72)(cid:85)(cid:85)(cid:72)(cid:71)(cid:3)(cid:37)(cid:92)(cid:87)(cid:72)(cid:86)
(cid:24)(cid:26) (cid:24)(cid:22) (cid:24)(cid:25) (cid:27)(cid:28)
(cid:38)(cid:37)
(cid:24)(cid:40) (cid:24)(cid:37) (cid:24)(cid:41) (cid:38)(cid:22)
(cid:83)(cid:88)(cid:86)(cid:75)(cid:3)(cid:72)(cid:71)(cid:76)
(cid:83)(cid:88)(cid:86)(cid:75)(cid:3)(cid:72)(cid:69)(cid:91)
(cid:83)(cid:88)(cid:86)(cid:75)(cid:3)(cid:72)(cid:86)(cid:76)
(cid:80)(cid:82)(cid:89)(cid:3)(cid:3)(cid:72)(cid:69)(cid:91)(cid:15)(cid:72)(cid:70)(cid:91)
(cid:83)(cid:82)(cid:83)(cid:3)(cid:3)(cid:72)(cid:86)(cid:76)
(cid:83)(cid:82)(cid:83)(cid:3)(cid:3)(cid:72)(cid:69)(cid:91)
(cid:83)(cid:82)(cid:83)(cid:3)(cid:3)(cid:72)(cid:71)(cid:76)
(cid:85)(cid:72)(cid:87)
(A) Instruction Substitution
(B) Instruction Reordering
(C) Register Reassignment
(D) Reg. Preserv. Reordering
Inferable gadgets (C ∪ D)
All (A ∪ B ∪ C ∪ D)
0
10
30
60
20
Randomized gadgets (%)
40
50
70
80
Fig. 11. Destructively reading two bytes in the function’s prologue allows an
attacker to infer the values of the randomized bytes of the gadget, i.e., which
of the six possible orderings of the pop instructions actually used.
Fig. 13. Randomization coverage achieved by the different transformations of
in-place code randomization. The state of randomized gadgets due to register
reassignment (C) and register preservation code reordering (D) can always be
inferred through indirect disclosure. This means that an extra 68.72% of all
gadgets (C ∪ D) can be safely used by an attacker.
(cid:39)(cid:72)(cid:86)(cid:87)(cid:85)(cid:88)(cid:70)(cid:87)(cid:76)(cid:89)(cid:72)(cid:3)(cid:53)(cid:72)(cid:68)(cid:71)(cid:3)(cid:11)(cid:20)(cid:3)(cid:69)(cid:92)(cid:87)(cid:72)(cid:12)
(cid:44)(cid:81)(cid:73)(cid:72)(cid:85)(cid:85)(cid:72)(cid:71)(cid:3)(cid:37)(cid:92)(cid:87)(cid:72)(cid:86)
(cid:24)(cid:19) (cid:27)(cid:37) (cid:23)(cid:24) (cid:19)(cid:27)
(cid:27)(cid:39) (cid:23)(cid:39) (cid:41)(cid:38) (cid:24)(cid:20) (cid:24)(cid:19) (cid:41)(cid:41) (cid:39)(cid:26)
(cid:83)(cid:88)(cid:86)(cid:75)(cid:3)(cid:72)(cid:68)(cid:91)
(cid:72)(cid:68)(cid:91)
(cid:80)(cid:82)(cid:89)(cid:3)(cid:3)
(cid:15)(cid:62)(cid:72)(cid:69)(cid:83)(cid:14)(cid:19)(cid:91)(cid:27)(cid:64)
(cid:79)(cid:72)(cid:68)(cid:3)(cid:3)(cid:72)(cid:70)(cid:91)(cid:15)(cid:62)(cid:72)(cid:69)(cid:83)(cid:16)(cid:19)(cid:91)(cid:23)(cid:64)
(cid:83)(cid:88)(cid:86)(cid:75)(cid:3)(cid:72)(cid:70)(cid:91)
(cid:83)(cid:88)(cid:86)(cid:75)(cid:3)(cid:72)(cid:68)(cid:91)
(cid:70)(cid:68)(cid:79)(cid:79)(cid:3)(cid:72)(cid:71)(cid:76)
Fig. 12. Destructively reading a single byte in an instruction that involves
a reassigned register allows an attacker to infer the state of the randomized
gadget.
which in total contain 628,907 gadgets. We used the publicly
available implementation of in-place code randomization [35]
to randomize the libraries. Figure 13 shows the percentage of
gadgets that can be randomized by each of the four randomiza-
tion techniques. Note that a given gadget can be randomized
by more than one technique. The combination of all techniques
randomizes 78.28% of all gadgets found in the analyzed
code. We found that similar to the results reported by Pappas
et al. [35], instruction substitution and basic block instruction
reordering achieve the lowest randomization coverage (21.43%
and 33.98%, respectively).
The two more effective transformations, which happen to
always allow for implicit code disclosure, achieve a combined
coverage of 68.72%. In other words, by focusing only on reg-
ister reassignment and register preservation code reordering,
an attacker can infer the state of 90.44% of all randomized
gadgets (i.e., including the 21.72% of the gadgets that cannot
be randomized by any of the transformations of Pappas et al.
[35]). Based on these results, and considering that further
inference against instruction substitution and basic block re-
ordering is likely possible, we conclude that in-place code
randomization is not sufﬁcient for use in conjunction with
binary-level execute-only memory protections.
VI. DISCUSSION AND POSSIBLE MITIGATIONS
Many of the problems associated with binary-compatible
execute-only or destructive read mitigations can be solved by
using source and compiler-level techniques. For instance, the