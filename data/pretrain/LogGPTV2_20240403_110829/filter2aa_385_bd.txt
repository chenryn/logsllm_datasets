exceptthelast,orremovethelinebreaksaltogethertoproduce
onelong,continuousstring.Forsmallpayloadsthismaybe
acceptable,butforlargerpayloadsthisbecomestedioustodo
manually.You’llfindyourselflikelyturningtootherLinux
commandssuchassedandtrtocleanitup.
Onceyoucleanupthepayload,you’llhaveyourpayload
asastring.Tocreateabyteslice,you’dentersomethinglike
this:
payload:=[]byte("\xfc\xe8\x82...").
It’snotabadsolution,butyoucandobetter.
HexTransform
Improvinguponthepreviousattempt,let’slookatahex
transform.Withthisformat,msfvenomproducesalong,
continuousstringofhexadecimalcharacters:
fce8820000006089e531c0648b50308b520c8b52148b72280fb74a2631ff...6400
Ifthisformatlooksfamiliar,it’sbecauseyouuseditwhen
portingtheJavadeserializationexploit.Youpassedthisvalue
asastringintoacalltohex.DecodeString().Itreturnsabyteslice
anderrordetails,ifpresent.Youcoulduseitlikeso:
payload,err:=
hex.DecodeString("fce8820000006089e531c0648b50308b520c8b52148b
72280fb74a2631ff...6400")
TranslatingthistoGoisprettysimple.Allyouhavetodo
iswrapyourstringindoublequotesandpassittothefunction.
However,alargepayloadwillproduceastringthatmaynotbe
aestheticallypleasing,wrappinglinesorrunningbeyond
recommendedpagemargins.Youmaystillwanttousethis
format,butwe’veprovidedathirdalternativeintheeventthat
youwantyourcodetobebothfunctionalandpretty.
NumTransform
Anumtransformproducesacomma-separatedlistofbytesin
numerical,hexadecimalformat:
0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,
0x50,0x30,
0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,
0x31,0xff,
--snip--
0x64,0x00
Youcanusethisoutputinthedirectinitializationofabyte
slice,likeso:
payload:=[]byte{
0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,
0x50,0x30,
0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,
0x31,0xff,
--snip--
0x64,0x00,
}
Becausethemsfvenomoutputiscomma-separated,thelistof
bytescanwrapnicelyacrosslineswithoutclumsilyappending
datasets.Theonlymodificationrequiredistheadditionofa
singlecommaafterthelastelementinthelist.Thisoutput
formatiseasilyintegratedintoyourGocodeandformatted
pleasantly.
RawTransform
Arawtransformproducesthepayloadinrawbinaryformat.
Thedataitself,ifdisplayedontheterminalwindow,likely
producesunprintablecharactersthatlooksomethinglikethis:
ÐÐÐ`ÐÐ1ÐdÐP0ÐR
Ð8ÐuÐ}Ð;}$uÐXÐX$ÐfÐYIÐ:IÐ4ÐÐ1ÐÐÐÐ
Youcan’tusethisdatainyourcodeunlessyouproduceit
inadifferentformat.Sowhy,youmayask,areweeven
discussingrawbinarydata?Well,becauseit’sfairlycommon
toencounterrawbinarydata,whetherasapayloadgenerated
fromatool,thecontentsofabinaryfile,orcryptokeys.
Knowinghowtorecognizebinarydataandworkitintoyour
Gocodewillprovevaluable.
UsingthexxdutilityinLinuxwiththe-icommandline
switch,youcaneasilytransformyourrawbinarydataintothe
numformatoftheprevioussection.Asamplemsfvenom
commandwouldlooklikethis,whereyoupipetherawbinary
outputproducedbymsfvenomintothexxdcommand:
$msfvenom-p[payload][options]-fraw|xxd-i
Youcanassigntheresultdirectlytoabytesliceas
demonstratedintheprevioussection.
Base64Encoding
Althoughmsfvenomdoesn’tincludeapureBase64encoder,it’s
fairlycommontoencounterbinarydata,includingshellcode,
inBase64format.Base64encodingextendsthelengthofyour
data,butalsoallowsyoutoavoiduglyorunusablerawbinary
data.Thisformatiseasiertoworkwithinyourcodethannum,
forexample,andcansimplifydatatransmissionoverprotocols
suchasHTTP.Forthatreason,it’sworthdiscussingitsusage
inGo.
TheeasiestmethodtoproduceaBase64-encoded
representationofbinarydataistousethebase64utilityin
Linux.Itallowsyoutoencodeordecodedataviastdinorfrom
afile.Youcouldusemsfvenomtoproducerawbinarydata,and
thenencodetheresultbyusingthefollowingcommand:
$msfvenom-p[payload][options]-fraw|base64
MuchlikeyourCoutput,theresultingpayloadcontains
linebreaksthatyou’llhavetodealwithbeforeincludingitas
astringinyourcode.YoucanusethetrutilityinLinuxto
cleanuptheoutput,removingalllinebreaks:
$msfvenom-p[payload][options]-fraw|base64|tr-d"\n"
Theencodedpayloadwillnowexistasasingle,continuous
string.InyourGocode,youcanthengettherawpayloadasa
byteslicebydecodingthestring.Youusetheencoding/base64
packagetogetthejobdone:
payload,err:=
base64.StdEncoding.DecodeString("/OiCAAAAYInlMcBki1Awi...WFuZAA=")
You’llnowhavetheabilitytoworkwiththerawbinary
datawithoutalltheugliness.
ANoteonAssembly
Adiscussionofshellcodeandlow-levelprogrammingisn’t
completewithoutatleastmentioningassembly.Unfortunately
fortheshellcodecomposersandassemblyartists,Go’s
integrationwithassemblyislimited.UnlikeC,Godoesn’t
supportinlineassembly.Ifyouwanttointegrateassemblyinto
yourGocode,youcandothat,sortof.You’llhaveto
essentiallydefineafunctionprototypeinGowiththe
assemblyinstructionsinaseparatefile.Youthenrungobuildto
compile,link,andbuildyourfinalexecutable.Whilethismay
notseemoverlydaunting,theproblemistheassembly
languageitself.Gosupportsonlyavariationofassembly
basedonthePlan9operatingsystem.Thissystemwascreated
byBellLabsandusedinthelate20thcentury.Theassembly
syntax,includingavailableinstructionsandopcodes,isalmost
nonexistent.ThismakeswritingpurePlan9assemblya
daunting,ifnotnearlyimpossible,task.
SUMMARY
Despitelackingassemblyusability,Go’sstandardpackages
offeratremendousamountoffunctionalityconduciveto
vulnerabilityhuntersandexploitdevelopers.Thischapter
coveredfuzzing,portingexploits,andhandlingbinarydata
andshellcode.Asanadditionallearningexercise,we
encourageyoutoexploretheexploitdatabaseat
https://www.exploit-db.com/andtrytoportanexistingexploit
toGo.Dependingonyourcomfortlevelwiththesource
language,thistaskcouldseemoverwhelmingbutitcanbean
excellentopportunitytounderstanddatamanipulation,
networkcommunications,andlow-levelsysteminteraction.
Inthenextchapter,we’llstepawayfromexploitation
activitiesandfocusonproducingextendabletoolsets.
10
GOPLUGINSANDEXTENDABLE
TOOLS
Manysecuritytoolsareconstructedasframeworks—core
components,builtwithalevelofabstractionthatallowsyouto
easilyextendtheirfunctionality.Ifyouthinkaboutit,this
makesalotofsenseforsecuritypractitioners.Theindustryis
constantlychanging;thecommunityisalwaysinventingnew
exploitsandtechniquestoavoiddetection,creatingahighly
dynamicandsomewhatunpredictablelandscape.However,by
usingplug-insandextensions,tooldeveloperscanfuture-
prooftheirproductstoadegree.Byreusingtheirtools’core
componentswithoutmakingcumbersomerewrites,theycan
handleindustryevolutiongracefullythroughapluggable
system.
This,coupledwithmassivecommunityinvolvement,is
arguablyhowtheMetasploitFrameworkhasmanagedtoage
sowell.Hell,evencommercialenterpriseslikeTenableseethe
valueincreatingextendableproducts;Tenablereliesona
plug-in-basedsystemtoperformsignaturecheckswithinits
Nessusvulnerabilityscanner.
Inthischapter,you’llcreatetwovulnerabilityscanner
extensionsinGo.You’llfirstdothisbyusingthenativeGo
plug-insystemandexplicitlycompilingyourcodeasashared
object.Thenyou’llrebuildthesameplug-inbyusingan
embeddedLuasystem,whichpredatesthenativeGoplug-in
system.Keepinmindthat,unlikecreatingplug-insinother
languages,suchasJavaandPython,creatingplug-insinGois
afairlynewconstruct.Nativesupportforplug-inshasexisted
onlysinceGoversion1.8.Further,itwasn’tuntilGoversion
1.10thatyoucouldcreatetheseplug-insasWindowsdynamic
linklibraries(DLLs).Makesureyou’rerunningthelatest
versionofGosothatalltheexamplesinthischapterworkas
planned.
USINGGO’SNATIVEPLUG-IN
SYSTEM
Priortoversion1.8ofGo,thelanguagedidn’tsupportplug-
insordynamicruntimecodeextendibility.Whereaslanguages
likeJavaallowyoutoloadaclassorJARfilewhenyou
executeyourprogramtoinstantiatetheimportedtypesandcall
theirfunctions,Goprovidednosuchluxury.Althoughyou
couldsometimesextendfunctionalitythroughinterface
implementationsandsuch,youcouldn’ttrulydynamically
loadandexecutethecodeitself.Instead,youneededto
properlyincludeitduringcompiletime.Asanexample,there
wasnowaytoreplicatetheJavafunctionalityshownhere,
whichdynamicallyloadsaclassfromafile,instantiatesthe
class,andcallssomeMethod()ontheinstance:
Filefile=newFile("/path/to/classes/");
URL[]urls=newURL[]{file.toURL()};
ClassLoadercl=newURLClassLoader(urls);
Classclazz=cl.loadClass("com.example.MyClass");
clazz.getConstructor().newInstance().someMethod();
Luckily,thelaterversionsofGohavetheabilitytomimic
thisfunctionality,allowingdeveloperstocompilecode
explicitlyforuseasaplug-in.Limitationsexist,though.
Specifically,priortoversion1.10,theplug-insystemworked
onlyonLinux,soyou’dhavetodeployyourextendable
frameworkonLinux.
Go’splug-insarecreatedassharedobjectsduringthe
buildingprocess.Toproducethissharedobject,youenterthe
followingbuildcommand,whichsuppliespluginasthebuildmode
option:
$gobuild-buildmode=plugin
Alternatively,tobuildaWindowsDLL,usec-sharedasthe
buildmodeoption:
$gobuild-buildmode=c-shared
TobuildaWindowsDLL,yourprogrammustmeetcertain
conventionstoexportyourfunctionsandalsomustimportthe
Clibrary.We’llletyouexplorethesedetailsonyourown.
Throughoutthischapter,we’llfocusalmostexclusivelyonthe
Linuxplug-invariant,sincewe’lldemonstratehowtoloadand
useDLLsinChapter12.
Afteryou’vecompiledtoaDLLorsharedobject,a
separateprogramcanloadandusetheplug-inatruntime.Any
oftheexportedfunctionswillbeaccessible.Tointeractwith
theexportedfeaturesofasharedobject,you’lluseGo’splugin
package.Thefunctionalityinthepackageisstraightforward.
Touseaplug-in,followthesesteps:
1. Callplugin.Open(filenamestring)toopenasharedobjectfile,creatinga
*plugin.Plugininstance.
2. Onthe*plugin.Plugininstance,callLookup(symbolNamestring)toretrievea
Symbol(thatis,anexportedvariableorfunction)byname.
3. UseatypeassertiontoconvertthegenericSymboltothetypeexpectedbyyour
program.
4. Usetheresultingconvertedobjectasdesired.
YoumayhavenoticedthatthecalltoLookup()requiresthe
consumertosupplyasymbolname.Thismeansthatthe
consumermusthaveapredefined,andhopefullypublicized,
namingscheme.ThinkofitasalmostadefinedAPIorgeneric
interfacetowhichplug-inswillbeexpectedtoadhere.
Withoutastandardnamingscheme,newplug-inswould
requireyoutomakechangestotheconsumercode,defeating
theentirepurposeofaplug-in-basedsystem.
Intheexamplesthatfollow,youshouldexpectplug-insto
defineanexportedfunctionnamedNew()thatreturnsaspecific
interfacetype.Thatway,you’llbeabletostandardizethe
bootstrappingprocess.Gettingahandlebacktoaninterface
allowsustocallfunctionsontheobjectinapredictableway.
Nowlet’sstartcreatingyourpluggablevulnerability
scanner.Eachplug-inwillimplementitsownsignature-
checkinglogic.Yourmainscannercodewillbootstrapthe
processbyreadingyourplug-insfromasingledirectoryon
yourfilesystem.Tomakethisallwork,you’llhavetwo
separaterepositories:oneforyourplug-insandoneforthe
mainprogramthatconsumestheplug-ins.
CreatingtheMainProgram
CreatingtheMainProgram
Let’sstartwithyourmainprogram,towhichyou’llattach
yourplug-ins.Thiswillhelpyouunderstandtheprocessof
authoringyourplug-ins.Setupyourrepository’sdirectory
structuresoitmatchestheoneshownhere:
$tree
.
---cmd
---scanner
---main.go
---plugins
---scanner
---scanner.go
Thefilecalledcmd/scanner/main.goisyourcommandline
utility.Itwillloadtheplug-insandinitiateascan.Theplugins
directorywillcontainallthesharedobjectsthatyou’llload
dynamicallytocallvariousvulnerabilitysignaturechecks.
You’llusethefilecalledscanner/scanner.gotodefinethedata
typesyourplug-insandmainscannerwilluse.Youputthis
dataintoitsownpackagetomakeitalittlebiteasiertouse.
Listing10-1showswhatyourscanner.gofilelookslike.
(Allthecodelistingsattherootlocationof/existunderthe
providedgithubrepohttps://github.com/blackhat-go/bhg/.)
packagescanner
//Scannerdefinesaninterfacetowhichallchecksadhere
❶typeCheckerinterface{
❷Check(hoststring,portuint64)*Result
}
//Resultdefinestheoutcomeofacheck
❸typeResultstruct{
Vulnerablebool
Detailsstring
}
Listing10-1:Definingcorescannertypes(/ch-10/plugin-core/scanner/scanner.go)
Inthispackage,namedscanner,youdefinetwotypes.The
firstisaninterfacecalledChecker❶.Theinterfacedefinesa
singlemethodnamedCheck()❷,whichacceptsahostandport
valueandreturnsapointertoaResult.YourResulttypeis
definedasastruct❸.Itspurposeistotracktheoutcomeofthe
check.Istheservicevulnerable?Whatdetailsarepertinentin
documenting,validating,orexploitingtheflaw?
You’lltreattheinterfaceasacontractorblueprintofsorts;
aplug-inisfreetoimplementtheCheck()functionhoweverit
chooses,solongasitreturnsapointertoaResult.Thelogicof
theplug-in’simplementationwillvarybasedoneachplug-in’s
vulnerability-checkinglogic.Forinstance,aplug-inchecking
foraJavadeserializationissuecanimplementtheproper
HTTPcalls,whereasaplug-incheckingfordefaultSSH
credentialscanissueapassword-guessingattackagainstthe
SSHservice.Thepowerofabstraction!
Next,let’sreviewcmd/scanner/main.go,whichwill
consumeyourplug-ins(Listing10-2).
constPluginsDir="../../plugins/"❶
funcmain(){
var(
files[]os.FileInfo
errerror
p*plugin.Plugin
nplugin.Symbol
checkscanner.Checker
res*scanner.Result
)
iffiles,err=ioutil.ReadDir(PluginsDir)❷;err!=nil{
log.Fatalln(err)
}
foridx:=rangefiles{❸
fmt.Println("Foundplugin:"+files[idx].Name())
ifp,err=plugin.Open(PluginsDir+"/"+files[idx].Name())❹;err!=nil{
log.Fatalln(err)
}
ifn,err=p.Lookup("New")❺;err!=nil{
log.Fatalln(err)
}
newFunc,ok:=n.(func()scanner.Checker)❻
if!ok{
log.Fatalln("Pluginentrypointisnogood.Expecting:funcNew()
scanner.Checker{...}")
}
check=newFunc()❼
res=check.Check("10.0.1.20",8080)❽
ifres.Vulnerable{❾
log.Println("Hostisvulnerable:"+res.Details)
}else{
log.Println("HostisNOTvulnerable")
}
}
}
Listing10-2:Thescannerclientthatrunsplug-ins(/ch-10/plugin-
core/cmd/scanner/main.go)
Thecodestartsbydefiningthelocationofyourplug-ins
❶.Inthiscase,you’vehardcodedit;youcouldcertainly
improvethecodesoitreadsthisvalueinasanargumentor
environmentvariableinstead.Youusethisvariabletocall
ioutil.ReadDir(PluginDir)andobtainafilelisting❷,andthenloop
overeachoftheseplug-infiles❸.Foreachfile,youuseGo’s
pluginpackagetoreadtheplug-inviaacalltoplugin.Open()❹.If
thissucceeds,you’regivena*plugin.Plugininstance,whichyou
assigntothevariablenamedp.Youcallp.Lookup("New")to
searchyourplug-inforasymbolnamedNew❺.
Aswementionedduringthehigh-leveloverviewearlier,
thissymbollookupconventionrequiresyourmainprogramto
providetheexplicitnameofthesymbolasanargument,
meaningyouexpecttheplug-intohaveanexportedsymbolby
thesamename—inthiscase,ourmainprogramislookingfor
thesymbolnamedNew.Furthermore,asyou’llseeshortly,the
codeexpectsthesymboltobeafunctionthatwillreturna
concreteimplementationofyourscanner.Checkerinterface,which
wediscussedintheprevioussection.
Assumingyourplug-incontainsasymbolnamedNew,you
makeatypeassertionforthesymbolasyoutrytoconvertitto
typefunc()scanner.Checker❻.Thatis,you’reexpectingthe
symboltobeafunctionthatreturnsanobjectimplementing
scanner.Checker.Youassigntheconvertedvaluetoavariable
namednewFunc.Thenyouinvokeitandassignthereturned
valuetoavariablenamedcheck❼.Thankstoyourtype
assertion,youknowthatchecksatisfiesyourscanner.Checker
interface,soitmustimplementaCheck()function.Youcallit,
passinginatargethostandport❽.Theresult,a*scanner.Result,
iscapturedusingavariablenamedresandinspectedto
determinewhethertheservicewasvulnerableornot❾.
Noticethatthisprocessisgeneric;itusestypeassertions
andinterfacestocreateaconstructthroughwhichyoucan
dynamicallycallplug-ins.Nothingwithinthecodeisspecific
toasinglevulnerabilitysignatureormethodusedtocheckfor
avulnerability’sexistence.Instead,you’veabstractedthe
functionalityenoughthatplug-indeveloperscancreatestand-
aloneplug-insthatperformunitsofworkwithouthaving
knowledgeofotherplug-ins—orevenextensiveknowledgeof
theconsumingapplication.Theonlythingthatplug-inauthors
mustconcernthemselveswithisproperlycreatingthe
exportedNew()functionandatypethatimplements
scanner.Checker.Let’shavealookataplug-inthatdoesjustthat.
BuildingaPassword-GuessingPlug-in