2009 IEEE Symposium on Security and Privacy (SP ’09). IEEE Computer Society,
Washington, DC, USA, 110–125. https://doi.org/10.1109/SP.2009.14
[14] Jonathan Corbet, Alessandro Rubini, and Greg Kroah-Hartman. 2005. Linux
Device Drivers: Where the Kernel Meets the Hardware. " O’Reilly Media, Inc.".
[15] International Data Corporation. 2016. Smartphone OS Market Share. (2016).
http://www.idc.com/promo/smartphone-market-share/os.
//github.com/Cr4sh/ioctlfuzzer.
dows Kernel (IOCTL) Fuzzer. (2014). https://github.com/debasishm89/iofuzz.
[18] Kyle Dewey, Jared Roesch, and Ben Hardekopf. 2015. Fuzzing the Rust Type-
checker Using CLP (T). In Proceedings of the 2015 IEEE/ACM International Con-
ference on Automated Software Engineering (ASE ’15). IEEE Computer Society,
Washington, DC, USA, 482–493. https://doi.org/10.1109/ASE.2015.65
[19] Fabien Duchene, Sanjay Rawat, Jean-Luc Richier, and Roland Groz. 2014.
KameleonFuzz: Evolutionary Fuzzing for Black-box XSS Detection. In Proceed-
ings of the 2014 ACM Conference on Data and Application Security and Privacy
(CODASPY ’14). ACM, New York, NY, USA, 37–48. https://doi.org/10.1145/
2557547.2557550
[20] Adrienne Porter Felt, Matthew Finifter, Erika Chin, Steve Hanna, and David
Wagner. 2011. A Survey of Mobile Malware in the Wild. In Proceedings of the 2011
ACM Workshop on Security and Privacy in Smartphones and Mobile Devices (SPSM
[17] debasishm89. 2014. A mutation based user mode (ring3) dumb in-memory Win-
[16] Cr4sh. 2011. IOCTL Fuzzer - Windows kernel drivers fuzzer. (2011). https:
(2017).
’11). ACM, New York, NY, USA, 3–14. https://doi.org/10.1145/2046614.2046618
[21] Vijay Ganesh, Tim Leek, and Martin Rinard. 2009. Taint-based Directed White-
box Fuzzing. In Proceedings of the 2009 International Conference on Software
Engineering (ICSE ’09). IEEE Computer Society, Washington, DC, USA, 474–484.
https://doi.org/10.1109/ICSE.2009.5070546
[22] GNU. 2007. GNU General Public License. (2007). https://www.gnu.org/licenses/
gpl-3.0.en.html.
[23] Patrice Godefroid, Adam Kiezun, and Michael Y. Levin. 2008. Grammar-based
Whitebox Fuzzing. In Proceedings of the 2008 ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation (PLDI ’08). ACM, New York, NY,
USA, 206–215. https://doi.org/10.1145/1375581.1375607
[24] Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: Directed Auto-
mated Random Testing. In Proceedings of the 2005 ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI ’05). ACM, New York,
NY, USA, 213–223. https://doi.org/10.1145/1065010.1065036
[25] Patrice Godefroid, Michael Y Levin, David A Molnar, et al. 2008. Automated
Whitebox Fuzz Testing.. In Proceedings of the 2008 Symposium on Network and
Distributed System Security (NDSS ’08). San Diego, CA, USA.
[26] Google. 2016. The Kernel Address Sanitizer. (2016). https://www.kernel.org/
doc/html/latest/dev-tools/kasan.html.
https://
[27] Google. 2017.
android.googlesource.com/kernel.
syzkaller.
[28] Google. 2017. syzkaller - linux syscall fuzzer. (2017). https://github.com/google/
[29] Gustavo Grieco, Martín Ceresa, and Pablo Buiras. 2016. QuickFuzz: An Automatic
Random Fuzzer for Common File Formats. In Proceedings of the 2016 International
Symposium on Haskell (Haskell ’16). ACM, New York, NY, USA, 13–20. https:
//doi.org/10.1145/2976002.2976017
[30] Istvan Haller, Asia Slowinska, Matthias Neugschwandtner, and Herbert Bos. 2013.
Dowser: a guided fuzzer to find buffer overflow vulnerabilities. In Proceedings of
the 2013 USENIX Security Symposium (SEC ’13). Washington, DC, USA, 49–64.
[31] Christian Holler, Kim Herzig, and Andreas Zeller. 2012. Fuzzing with Code
Fragments.. In Proceedings of the 2012 USENIX Security Symposium (SEC ’12).
Bellevue, WA, USA, 445–458.
[32] HTC. 2017. HTC Android Kernel Sources. (2017). https://www.htcdev.com/
[33] Huawei. 2017.
http://
Huawei Android Kernel Sources.
Goole Android Kernel Sources.
devcenter/downloads.
list?m=Mc001&s=Sc002.
consumer.huawei.com/ng/support/downloads/index.htm.
Linux Symposium (OLS ’11).
ldd3/chp-3-sect-4.
[34] Dave Jones. 2011. Trinity: A system call fuzzer. In Proceedings of the 2011 Ottawa
[35] kernel. 2001. Character device registration. (2001). http://www.makelinux.net/
[36] Paul Larson, Nigel Hinds, Rajan Ravindran, and Hubertus Franke. 2003. Improving
the Linux Test Project with kernel code coverage analysis. In Proceedings of the
2003 Ottawa Linux Symposium (OLS ’03).
[37] Vu Le, Chengnian Sun, and Zhendong Su. 2015. Finding Deep Compiler Bugs via
Guided Stochastic Program Mutation. In Proceedings of the 2015 ACM SIGPLAN
International Conference on Object-Oriented Programming, Systems, Languages,
and Applications (OOPSLA ’15). ACM, New York, NY, USA, 386–399. https://
doi.org/10.1145/2814270.2814319
[38] Stanislas Lejay. 2016. Fuzzing IOCTLs with angr. (2016). https://thunderco.re/
project/security/2016/07/18/fuzzing-ioctls/.
[39] LG. 2017. LG Android Kernel Sources. (2017). http://opensource.lge.com/osList/
[40] Zhiqiang Lin, Xiangyu Zhang, and Dongyan Xu. 2010. Automatic Reverse En-
gineering of Data Structures from Binary Execution. In Proceedings of the 2010
Annual Information Security Symposium (CERIAS ’10). CERIAS - Purdue Univer-
sity, West Lafayette, IN, Article 5, 1 pages. http://dl.acm.org/citation.cfm?id=
2788959.2788964
[41] Guang-Hong Liu, Gang Wu, Zheng Tao, Jian-Mei Shuai, and Zhuo-Chun Tang.
2008. Vulnerability analysis for x86 executables using genetic algorithm and
fuzzing. In Proceedings of the 2008 Convergence and Hybrid Information Technology
(ICCIT ’08), Vol. 2. IEEE, 491–497.
[42] Manuel Mendonça and Nuno Neves. 2008. Fuzzing wi-fi drivers to locate secu-
rity vulnerabilities. In Proceedings of the 2008 Dependable Computing Conference
(EDCC ’08). IEEE, 110–119.
[43] Alessio Merlo, Gabriele Costa, Luca Verderame, and Alessandro Armando. 2016.
Android vs. SEAndroid. Pervasive Mob. Comput. 30, C (Aug. 2016), 113–131.
https://doi.org/10.1016/j.pmcj.2016.01.006
[44] Microsoft. 2017. How to Perform Fuzz Tests with IoSpy and IoAttack.
(2017). https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/
how-to-perform-fuzz-tests-with-iospy-and-ioattack.
[45] Barton P. Miller, Louis Fredriksen, and Bryan So. 1990. An Empirical Study
of the Reliability of UNIX Utilities. Commun. ACM 33, 12 (Dec. 1990), 32–44.
https://doi.org/10.1145/96267.96279
[46] Motorola. 2017. Motorola Android Kernel Sources. (2017). https://github.com/
MotorolaMobilityLLC.
(2017).
Session J2:  Fun with FuzzingCCS’17, October 30-November 3, 2017, Dallas, TX, USA2136[47] Nicholas Nethercote and Julian Seward. 2007. Valgrind: A Framework for Heavy-
weight Dynamic Binary Instrumentation. In Proceedings of the 2007 ACM SIG-
PLAN Conference on Programming Language Design and Implementation (PLDI
’07). ACM, New York, NY, USA, 89–100. https://doi.org/10.1145/1250734.1250746
[48] Matthias Neugschwandtner, Paolo Milani Comparetti, Istvan Haller, and Her-
bert Bos. 2015. The BORG: Nanoprobing Binaries for Buffer Overreads. In Pro-
ceedings of the 2015 ACM Conference on Data and Application Security and Pri-
vacy (CODASPY ’15). ACM, New York, NY, USA, 87–97. https://doi.org/10.1145/
2699026.2699098
[49] Peach. 2017. The Peach Fuzzer. (2017). http://www.peachfuzzer.com/.
[50] Hendrik Post and Wolfgang Küchlin. 2007. Integrated Static Analysis for Linux
Device Driver Verification. Springer Berlin Heidelberg, Berlin, Heidelberg, 518–537.
https://doi.org/10.1007/978-3-540-73210-5_27
[51] LLVM Project. 2003. LLVM Bitcode File Format. (2003). http://llvm.org/docs/
BitCodeFormat.html.
[52] Fernando Magno Quintao Pereira, Raphael Ernani Rodrigues, and Victor Hugo
Sperle Campos. 2013. A fast and low-overhead technique to secure programs
against integer overflows. In Proceedings of the 2013 IEEE/ACM International
Symposium on Code Generation and Optimization (CGO ’13). IEEE Computer
Society, 1–11.
[53] Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano Giuffrida,
and Herbert Bos. 2017. VUzzer: Application-aware Evolutionary Fuzzing. In
Proceedings of the 2017 Network and Distributed System Security Symposium (NDSS
’17). San Diego, CA, USA.
https://access.redhat.com/
documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Reference_Guide/s2-
proc-devices.html.
[55] Juha Röning, Marko Laakso, and Ari Takanen. 2002. PROTOS – Systematic
Approach to Eliminate Software Vulnerabilities. Invited presentation at Microsoft
Research (May 2002).
[56] Alessandro Rubini and Jonathan Corbet. 2001. Linux device drivers. " O’Reilly
Media, Inc.".
http:
[57] Samsung. 2017.
//opensource.samsung.com/reception/receptionSub.do?method=sub&sub=
T&menu_item=mobile&classification1=mobile_phone.
[58] Sergej Schumilo, Ralf Spenneberg, and H Schwartke. 2014. DonâĂŹt trust your
[54] redhat. 2017. Proc device registration.
Samsung Android Kernel Sources.
(2017).
(2017).
(2017).
[60] Sony. 2017.
Sony Android Kernel Sources.
USB! How to find bugs in USB device drivers. Blackhat Europe (2014).
[59] Kwan Yong Sim, F-C Kuo, and R Merkel. 2011. Fuzzing the out-of-memory killer
on embedded Linux: an adaptive random approach. In Proceedings of the 2011
ACM Symposium on Applied Computing (SAC ’11). ACM, 387–392.
https://github.com/
sonyxperiadev/kernel.
[61] Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu Wang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution. In
Proceedings of the 2016 Network and Distributed System Security Symposium (NDSS
’16). San Diego, CA, USA.
[62] Jeffrey Vander Stoep. 2016. Android: protecting the kernel. In Linux Security
Summit. Linux Foundation.
[63] Linus Torvalds. 2011. C2XML - Converting source code to XML. (2011). http:
//c2xml.sourceforge.net/.
[64] Vincent M Weaver and Dave Jones. 2015. perf fuzzer: Targeted fuzzing of the perf
event open () system call. Technical Report. Technical Report UMAINEVMW-TR-
PERF-FUZZER, University of Maine.
[65] Wiki. 2017. TanenbaumâĂŞTorvalds debate. (2017). https://en.wikipedia.org/
[66] Xiaomi. 2017. Xiaomi Android Kernel Sources. (2017). https://github.com/
IOCTLbf is just a small tool (Proof of Concept) that can be
[67] Xst3nZ. 2012.
https:
used to search vulnerabilities in Windows kernel drivers.
//code.google.com/archive/p/ioctlbf/.
[68] Michal Zalewski. 2014. Binary fuzzing strategies: what works, what doesn’t.
(2014). https://lcamtuf .blogspot.com/2014/08/binary-fuzzing-strategies-what-
works.html.
[69] M. Zalewski. 2017. American Fuzzy Lop. (2017). http://lcamtuf .coredump.cx/
afl/technical_details.txt.
wiki/Tanenbaum%E2%80%93Torvalds_debate.
MiCode/Xiaomi_Kernel_OpenSource.
(2012).
A IOCTL REGISTRATION STRUCTURES
There are several structures that could be used by the Linux ker-
nel drivers to register an ioctl handler. Listing 7 shows the list of
structures in the Kernel running on the Huawei P9.
B HANDLING V4L2 DRIVERS
struct.media_file_operations
struct.video_device
struct.v4l2_file_operations
struct.block_device_operations
struct.tty_operations
struct.posix_clock_operations
struct.security_operations
struct.file_operations
struct.v4l2_subdev_core_ops
struct.snd_pcm_ops
struct.snd_hwdep_ops
struct.snd_info_entry_ops
struct.adf_obj_ops
struct.net_device_ops
struct.kvm_device_ops
struct.ide_disk_ops
struct.ide_ioctl_devset
struct.hdlcdrv_ops
struct.uart_ops
struct.fb_ops
struct.proto_ops
struct.tty_ldisc_ops
struct.watchdog_ops
struct.atmdev_ops
struct.atmphy_ops
struct.atm_ioctl
struct.vfio_device_ops
struct.vfio_iommu_driver_ops
struct.rtc_class_ops
struct.usb_gadget_ops
struct.ppp_channel_ops
struct.cdrom_device_info
struct.cdrom_device_ops
Listing 7: List of structures that can be used to register an
ioctl handler.
There are certain ioctl functions whose commands and argu-
ments are first verified by the Linux kernel before the driver specific
functions are invoked. This includes Video for Linux (v4l2) ioctls as
shown in Listing 8, where the driver provides a standardized, over-
rideable ioctl handler (set by drivers using the v4l2_ioctl_ops
structure, line 2 in Listing 8) to ease the creation of video devices
(such as cameras). The Linux kernel implements the ioctl handler
function video_ioctl2 (line 10), which checks the provided ioctl
identifier and calls specific v4l2 handler functions provided by the
driver itself. Similar to other ioctl handlers, video_ioctl2 also ex-
pects specific structures from the user, depending on the command
identifier. Furthermore, the dispatched v4l2 handler functions them-
selves also expect properly formatted input with proper command
codes passed in.
This poses two analysis challenges. First, as mentioned in Sec-
tion 4.1, we consider only the functions defined by the driver. As
such, we would miss the ioctl handler video_ioctl2, which is
defined by the kernel. To handle this, we identify the v4l2 registra-
tion function video_register_device (line 32) and traverse the
structures of its arguments to identify the v4l2_ioctl_ops data
structure (line 32 → 29 → 13 → 17 → 2), treating each function
pointer in the structure as analogous to a top-level ioctl handler.
However, we need to tackle a second problem. In order to trigger the
execution of any of the functions registered via v4l2_ioctl_ops,
the proper standardized v4l2 ioctl command identifier must be
provided. Furthermore, the sub-handlers provided by the driver
introduce their own command identifiers as well. Thus, DIFUZE
keeps track of a nested interface for such devices..
Session J2:  Fun with FuzzingCCS’17, October 30-November 3, 2017, Dallas, TX, USA21371
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
1
2
// v4l2_ioctl_ops initialized with required functions.
static const struct v4l2_ioctl_ops iris_ioctl_ops = {
.vidioc_querycap = iris_vidioc_querycap,
.vidioc_s_tuner = iris_vidioc_s_tuner
}
static const struct v4l2_file_operations iris_fops = {
// here video_ioctl2, implemented by kernel
// is the main ioctl handler.
.unlocked_ioctl = video_ioctl2
};
static struct video_device iris_viddev_template = {
//initialize file operations.
.fops
// initialize ioctl operations.
.ioctl_ops = &iris_ioctl_ops
= &iris_fops,
};
static int __init driver_init() {
struct iris_device *radio;
int radio_nr = -1;
radio = kzalloc(sizeof(struct iris_device), GFP_KERNEL);
if (!radio) {
FMDERR(": Could not allocate radio device\n");
return -ENOMEM;
}
// copy the video_device structure.
memcpy(radio->videodev, &iris_viddev_template,
sizeof(iris_viddev_template));
// register the v4l2 device
video_register_device(radio->videodev, VFL_TYPE_RADIO, radio_nr);
}
Listing 8: Example of a v4l2_ioctl_ops initialization and reg-
istering of a v4l2 device.
vidioc_querycap:2154321408
vidioc_s_tuner:1079268894
Listing 9: An example v4l2-function-mapping, which con-
tains entries in : format.
To handle this, we first create a mapping between the command
ID and the function pointer, to identify which function in the set
will be called for a given command value. DIFUZE automatically
extracts such information with LLVM. For the example v4l2 driver
in Listing 8, we generate a mapping called v4l2-function-mapping,
as shown in Listing 9. DIFUZE associates the sub-handler func-
tions iris_vidioc_querycap and iris_vidioc_s_tuner (line 3
and line 4 in Listing 8), with v4l2-standard ioctl command identi-
fiers of 2154321408 and 1079268894 (line 1 and line 4 in Listing 9).
These functions would then be further analyzed to recover nested
interface information.
Session J2:  Fun with FuzzingCCS’17, October 30-November 3, 2017, Dallas, TX, USA2138