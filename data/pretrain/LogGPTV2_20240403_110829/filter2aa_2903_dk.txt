这里的核心是指整个GPU，是过时的叫法，在较新的资料中把每个ALU
称为一个核心（见图13-2）。核心管理单元负责与CPU接口，接收任务
并分发执行。标有“管理器”字样的三个矩形代表三种不同数据/任务的接
收和预处理结构，上面的矩形代表顶点数据管理器，中间的矩形代表像
素数据管理器（是从第4代的ISP演化而来的），最下面的矩形代表计算
数据管理器。三种类型的数据经过预处理后，会进一步分解为若干个子
任务，然后送给粗粒度调度器（Coarse Grain Scheduler）。粗粒度调度
器再把任务分发给中间部分的某个统一着色器集群。在着色器集群中，
有细粒度任务调度器，稍后介绍它。
统一着色器集群（Universal Shading Cluster，USC）是PowerVR
GPU内的重要执行单位，用于把更小范围的计算资源组合成一个较大的
集群，与Gen GPU的片区概念类似。
USC的数量是可以根据产品的市场定位配置的，在针对中高端市场
的XT产品线里，至少包含两个USC，最多可以有16个。在XE产品线
中，最多包含1个。
当存在多个USC时，每两个会组成一个USC对，它们共享一个纹理
处理单元。多个USC对排列在一起称为USC阵列（USC Array）。图13-
1中，画出了两个USC对，中间的省略号代表可以有更多个USC对。图
中USC阵列右侧的图块加速器（Tiling Accelerator）和像素处理后端
（Pixel Back End,PBE）属于固定功能单元，用于前面介绍的基于TBDR
技术的3D渲染任务。
13.2.2 USC
接下来，我们再深入到USC内部。首先，在每个USC内部，包含多
条ALU流水线（ALU Pipeline）。比如在第6代XT配置中，有16条ALU
流水线，其结构如图13-2所示。
图13-2 ALU流水线结构框图[8]
通常，在每一条ALU流水线中，包含了多个算术逻辑单元
（ALU）。图13-2中，每一条ALU流水线包含两个全浮点（FP32）ALU
核心、4个半浮点（FP16）核心，外加一个特殊函数单元。
在每个USC中，除了用于执行指令的ALU流水线外，还有用于存储
数据的存储空间。存储空间分为两种。一种是整个USC内共享的公共存
储空间（Common Store），简称USCCS。另一种是每个流水线内执行
单元共享的统一存储空间（United Store），简称US，如图13-3所示。
图13-3 包含存储单元和调度器的USC框图[6]
图13-3左下角的矩形代表细粒度调度器，它负责把要执行的线程以
线程组为单位分发到硬件流水线。调度器上方的矩形代表驻留在USC中
的待执行任务。另外，图13-3中示意性地画了4条ALU流水线，每条流
水线中画了4个ALU和1块统一存储空间，这些数量都是示意性的，是不
准确的。
13.2.3 ALU流水线
图13-4是Rogue的ALU流水线示意图。图中左侧代表输入，右侧代
表输出，中间是执行不同操作的子流水线。
图13-4中画了很多条从左到右的执行流程，这些流程是可以并行
的。理想情况下，尽量让所有子流水线都在工作，充分利用硬件资源。
为了提高并行度，ALU流水线又把每个时钟周期细分为三个阶段
（Phase，或者称相位），即图13-4中顶部标注的阶段0、阶段1和阶段
2。在指令手册中，明确定义了每条指令在每个阶段所做的操作和输出
的中间结果。这样，一条指令在阶段0的输出就可以被另一条指令在阶
段1中使用。后面在介绍指令集时会通过代码实例进一步介绍。
另外值得说明的是，图13-2、图13-3和图13-4三幅图中，都包含
ALU，但是表现方式不同。图13-3只是模糊地画出抽象表达，图13-2标
出了类型，图13-4最详细，把不同类型的ALU放在各自的工作位置上，
有的包含多个实例。图中的Byp是Bypass（旁路）的缩写，表示跳过该
部分操作。
图13-4 ALU流水线
13.3 参考指令集
2014年10月，IMG公司公开了PowerVR GPU的指令集（ISA），这
在当时引起了不小的轰动。这说明了两个问题。一方面是人们都深知指
令集信息的价值，求之若渴。另一方面也反映了SoC GPU领域的技术氛
围相对封闭，不如PC GPU领域开放。
需要说明的是，公开的指令集文档主要针对Rogue架构的第6代
PowerVR GPU，但是没有针对具体的硬件版本。这意味着有些描述是版
本模糊的，可能与具体硬件不匹配，所以文档中把这个指令集叫作参考
指令集（Instruction Set Reference，ISR）。
13.3.1 寄存器
在公开的文档中，包含了编写普通GPU应用程序时可能使用到的寄
存器。这些寄存器分为多个类型，本书将其归纳在表13-1中。
表13-1 公开的PowerVR寄存器
类型
名字
最大
数量
访问
说  明
临时 Rn
248
读/写
通用寄存器，从统一存储（US）分配，没有初始
化
顶点
输入 Vin
248
读/写
与临时寄存器类似，不过已经初始化为对应的输
入
系数 CFn
与架
构相
关
读/写
包含预先初始化好的系数输入，从USCCS分配，
供一个线程组的多个线程实例共享访问
包含初值，从USCCS分配，供一个线程组的多个
共享 SHn
4096
读/写
线程实例共享访问
索引 IDXi
2
读/写
用于索引其他寄存器组（bank），未初始化
像素
输出 On
与架
构相
关
读/写
供像素着色器使用，向PBE（像素处理后端）模
块输出数据
特殊
常量 SCn/SRn 240
SC只读，
SR可读写
用于存放常量
顶点
输出 Von
256
只写
用于向UVS模块输出数据
在表13-1中，寄存器名字（第2列）中的n代表阿拉伯数字，另
外，n前面的字母也可以小写，也就是，具体的寄存器名是r0、r1、vi0
等。此外，从这个表可以看出，寄存器的分类很细，根据用途做了深入
细分，但是针对的用途主要是图形渲染。这意味着Rogue架构是针对3D
图形任务量身设计的，对于通用计算任务，很多设施是不适用的。
13.3.2 指令组
回想上一节介绍的ALU流水线，其内部有很多个可以并行工作的子
流水线。为了提高ALU流水线的利用率，PowerVR设计了指令组概念。
每个指令组包含多条指令，可以一起提交（co-issue）到ALU流水线。
在汇编语言中，使用下面这样的简单格式来表达指令组。
 : [if (cond)] # n is group number (if is optional)
     # First op
    [Op 1] # Second op (optional)
    ..
    [Op N] # Nth operation (optional)
其中，n为指令组序号，从0开始，单调递增，其后的冒号是必需
的。每个指令组可以包含一个条件描述，这个条件总是相对于整个指令
组的。条件描述可以有if，也可以直接用小括号来表示。
比如，下面是使用反汇编工具得到的一段指令，包含了三个指令
组。
0 : mov ft0, vi0 
  mov ft1, sh13 
  tstg.u32 ftt, p0, ft0, ft1 
1 : (ignorepe) 
  cndst 3, i3, c0, 1 
2 : br.allinst 178
在0号指令组中，包含了3条指令。第1条指令把顶点输入寄存器vi0
的值赋给内部的馈通寄存器ft0，这里ft是FeedThrough的缩写。第2条指
令把共享寄存器sh13（h后为阿拉伯数字1，不是l）赋值给馈通寄存器
ft1。第3条寄存器测试ft0是否大于ft1（Test greater than），测试结果会
放入内部的ftt寄存器和谓词寄存器p0中。
介绍到这里，读者可能有个疑问：显然，第3条指令是依赖前两条
指令的，要等前两条指令执行完，才可以执行第3条，怎么可以同时把3
条指令提交给硬件呢？简单回答，这里巧妙使用了上一节介绍的“阶
段”概念，在每个时钟周期内，又分为三个执行阶段，第3条指令的测试
操作总是在最后一个阶段才执行（见图13-4），而前两条指令的赋值操
作会在阶段1或者阶段2就完成，因此同时提交是没有问题的。
1号指令组有个条件描述（ignorepe），其中，pe代表执行谓词
（execution predicate），用于存在分支判断的地方，可以屏蔽某个或者
某些线程实例。ignorepe表示忽略谓词状态。
13.3.3 指令修饰符
在Rogue的指令中，可以出现不同形式的修饰符（modifier），比
如，在上面介绍的tstg.u32指令中，.u32便是用于指定操作数类型的描述
符，代表无符号32位整数。
除了类型修饰符之外，还有一些有趣的修饰符，比如，指令mov
ft0, sh0.abs表示取sh0的绝对值，赋给ft0。与取绝对值的.abs修饰符
类似，mov ft0, sh0.neg中的.neg代表取负值。另外，可以用.e0、.e1
这样的修饰符来引用寄存器中的一部分。
13.3.4 指令类型
在公开的参考指令集中，把指令分成如下10种类型。
浮点指令，比如FMAD是乘加指令，FADD是加法指令，FSQRT可
以取平方根，FLOG用来取对数等。
数据移动指令，比如赋值用的MOV指令，打包数据的PCK指令，
解包数据的UNPCK指令等。
整数指令，针对整数的各种计算，操作符名称都以I开头，比如
IMAD、IMUL等。
测试指令，执行各种测试和比较操作，比如前面介绍过的TSTG指
令便属于此类。
位操作指令，包括“与”或“非”、移位等位操作。
后端指令，与其他功能单元交互的指令。
流程控制指令，执行各种分支跳转操作的指令，比如BA可以用来
跳转到指定的绝对地址，BR可以完成相对跳转。
条件指令，执行不同情况的条件判断。
数据访问指令，访问共享或者全局数据的一些指令，比如DITR指
令可以从指定系数开始遍历坐标。另外，SBO指令用来设置共享数
据或者系数区域的基地址偏移量。
64位浮点指令，针对64位浮点数的各种运算，包括乘法
（F64MUL）、乘加（F64MAD）、除法（F64DIV）、取平方根
（F64SQRT）等。
13.3.5 标量指令
Rogue架构的指令属于标量指令，每条指令针对单个标量数据执行
操作。比如加法指令的格式如下。
fadd dst0, src0, src1
它执行的操作就是dst0 = src0 + src1。
13.3.6 并行模式
在Rogue架构中，也有与Nvidia的WARP和AMD的波阵类似的线程
组概念。Rogue硬件会以线程组为单位来执行着色器函数，属于同一个
线程组的一组线程在Rogue的多条ALU流水线上同步执行。
在题为“PowerVR图形——最新进展和未来计划”（PowerVR
Graphics—Latest Developments and Future Plans）的官方演讲文件中[8]，