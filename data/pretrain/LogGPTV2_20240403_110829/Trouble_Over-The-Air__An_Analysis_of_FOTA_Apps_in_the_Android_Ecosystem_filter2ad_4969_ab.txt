are present in both certiﬁed and non-certiﬁed vendors with
capabilities for installing anything on those devices. An analysis
of these projects is out of the scope of this paper due to the
lack of representative data, and it is left for future work.
III. DATASET
We use two complementary datasets in this paper: (1)
Firmware Scanner’s set of pre-installed apps, and (2) app
reputation and installation logs obtained from NortonLifeLock.
For clarity and consistency purposes, we will refer to apps as
a unique instance of an Android app by its MD5 hash, and to
packages as all app versions under the same package name.
Firmware Scanner: Most FOTA apps come pre-installed on
Android devices, and are not available on public app stores.
To overcome this limitation, we got access to the dataset
of pre-installed apps collected by Gamba et al. [43] using
Firmware Scanner, a purpose-built app publicly available on
Google Play [13]. Firmware Scanner extracts pre-installed
apps from the possible system partitions paths, (i.e., /system,
/vendor, /oem, /odm and /product). Preinstalled apps are
crowd-sourced in a privacy-preserving fashion from volunteers
without collecting any personal data from users. We refer
the reader to the paper by Gamba et al. [43] for a technical
description of Firmware Scanner and for a discussion of its
ethical implications. As of June 2020, this dataset contains
422,121 pre-installed apps collected from 40,165 users, from
184 countries, with 26% of the users in Europe, 26% in America,
and 40% in Asia according to the Mobile Country Codes (MCC)
of the users. We discard 152,097 apps that were only found
on rooted devices. In doing so, we aim at maximizing the
validity of our results by focusing on devices that have not
been tampered with by the user, or a malicious actor.
Reputation and Installation Logs: One critical aspect to
consider in the characterization and analysis of FOTA apps
is what type of software they are installing on user devices.
We use a dataset provided by a NortonLifeLock that cap-
tures the presence of apps in real devices and the process
responsible for their installation. The customers opted-in to
share their data and the devices are anonymized to preserve
their privacy. The dataset includes only app metadata and
not the actual apps (i.e., APK ﬁles). A reputation log record
contains an anonymized device identiﬁer, APK’s SHA256 hash,
package name, signer key, parent package name (potentially
null) and, for a subset of those logs, the parent APK’s
SHA256 hash and signer key. The parent package information
is obtained via the Android’s Package Installer using the
PackageInstaller.getInstallerPackageName method. As
such, this dataset is limited to installations from FOTA apps
that invoke the PackageInstaller. We further discuss how
this limitation affects our analysis in §VII-A.
Customer devices regularly query a cloud-based reputation
system to obtain reputation for the APKs installed on the
device. This means that the client may query the same APK
multiple times. To remove duplicated events we obtain the
earliest date that a record is observed in a device and use it as
an approximation of the installation time of the app. In total,
this dataset contains 1.6 B installation events from 19.3 M
Android devices collected from January to December 2019.
Prior work has used the same dataset to analyze distribution
vectors of unwanted apps [48]. In this work, we extend the
dataset to contain installation events for a 12-months period.
IV. DISCOVERY OF FOTA APPS
Detecting FOTA apps is a challenging process, as these
apps can differ in their implementation details. FOTA apps
may not have distinctive package names, their functionality
may be split among multiple apps, or may contain customized
code. Thus, we design FOTA Finder, a tool to automatically
identify and classify FOTA capabilities in a given APK ﬁle.
In this section, we ﬁrst describe FOTA Finder (§IV-A) and
its limitations (§IV-B). We then present the results obtained
over our dataset of pre-installed apps (§IV-C), and validate the
accuracy of this discovery process (§IV-D).
A. FOTA Finder
We begin our process by extracting FOTA-speciﬁc code
ﬁngerprints from Google’s FOTA documentation and manually
analyzing the code of 18 well-known FOTA apps. To collect
these apps, we search the Firmware Scanner dataset for apps
with descriptive names—i.e., package names that contain terms
such as update or fota. Armed with a complete list of
code ﬁngerprints, we build FOTA Finder to automatically
classify a given APK as FOTA or not. The tool is based on
Androguard [36], an Android analysis framework that offers
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:11:06 UTC from IEEE Xplore.  Restrictions apply. 
1608
Signal
RV
RI
CMD
A/B
Description
Call to the method verifyPackage from the API
class android.os.RecoverySystem
Call to the method installPackage from the API
class android.os.RecoverySystem
Use of the strings “/cache/recovery/command”
and “--update-package” in the code
Call to the method applyPayload from the API class
android.os.UpdateEngine
Table I: Features for detecting FOTA apps.
APIs to facilitate static analysis of Android apps. For each APK,
FOTA Finder ﬁrst detects the compiled code in DEX (Dalvik
EXecutable) format that is typically included in one or more
classes.dex ﬁles. If an app uses ahead-of-time optimized
code, FOTA Finder parses the ODEX ﬁle and extracts the
original DEX ﬁle(s). Since the ODEX ﬁle format is not publicly
documented (the only source being the dex2oat tool [59]), we
go through a reverse engineering effort to develop a tool for
DEX extraction, Dextripador [11]. Finally, we parse the DEX
code for speciﬁc method calls and strings related to FOTA
system updates.
Table I summarizes the key FOTA detection features (ﬂags)
used to detect the mechanisms provided by the Android
platform to install new apps in the system partition (§II). These
features cover both the old update procedures based on the
RecoverySystem as well as the newer A/B system updates.
If an app has at least one of these signals, FOTA Finder will
categorize it as FOTA.
Detecting OTA capabilities. During the manual analysis of
FOTA apps, we identiﬁed other signals associated to behaviors
implemented by OTA apps—i.e., apps that can install and
remove user (i.e., non-system) apps under the /data directory.
FOTA Finder also uses these signals, since they allow us to
identify other package installation capabilities in FOTA apps.
We provide a complete list of OTA features along with further
details in Appendix B.
B. Scope and Limitations
We identify three main technical limitations in FOTA Finder
during our design, development, and exploratory research efforts.
First, our tool can only FOTA apps that follow Google’s
recommendations and use FOTA-speciﬁc API functions. It
cannot detect FOTA apps that follow custom implementations
(e.g., use of custom services, or native code). Nevertheless,
we also look for the presence of /cache/recovery/command
and --update_package strings, as their usage are part of the
internal implementation of an update for recovery [50].
Second, FOTA Finder fails to parser ODEX code for 37% of
the apps. This happens because of the lack of documentation
of the ODEX ﬁle format, and changes on the internal structure
can be wrongly handled by the FOTA Finder parser.
Finally, our detection of FOTA apps relies exclusively on
static analysis of DEX code. This is problematic because FOTA
apps may use dynamic code loading, reﬂection, native code
or obfuscation of strings. This can cause FOTA Finder to
wrongly classify FOTA apps as non-FOTA. However, we resort
to static analysis only, as running pre-installed apps in a sandbox
environment at scale remains an open problem.
C. FOTA Finder Results
We run FOTA Finder on 422,121 pre-installed apps found in
non-rooted devices from 40,165 users in the Firmware Scanner
dataset (§III). FOTA Finder could not process 37% (154,922)
of the apps. All of these errors are due to the usage of ODEX
ﬁles by these apps. In total, FOTA Finder detects 2,013 FOTA
apps in 20,924 devices. 24% of these apps are using ODEX
code, which FOTA Finder managed to parse successfully.
An analysis of the FOTA apps package names shows that
32% (647) of them do not contain any string tokens that may
reveal the purpose of the app (e.g., update, install, fota).
We also ﬁnd that 93% (1,878) of the FOTA apps rely on
the RecoverySystem API for the update process, while the
remaining 7% (135) support the A/B system updates. 32%
(651) of the FOTA apps can also perform installations at the
user level. We investigate these capabilities in detail in §VII,
as FOTA apps can use them to install malicious apps.
D. FOTA Finder Evaluation
We consider acceptable for FOTA Finder to miss some apps
(False Negatives, FN) due to its technical limitations (§IV-B).
Our methodology offers sufﬁcient coverage of FOTA apps
to analyze the ecosystem and draw general conclusions. We
therefore focus on reducing False Positives (FP), i.e., non-FOTA
apps missclassiﬁed as FOTA, since these can introduce bias
and affect the validity of our results. We thus consider FOTA
Finder as a best-effort yet accurate approach that does not aim
to be complete. To this extent, we focus our evaluation on
detecting potential FPs, mainly in two ways. First, we perform
a manual review of a subset of 50 FOTA apps. Second, we
search Google Play Store for the presence of FOTA apps. Due
to the intrinsic characteristics of FOTA apps (e.g., they must
be installed on a read-only system partition) we do not expect
to ﬁnd these apps on the Play Store market, as Google Play
policies prohibit apps with the ability to install others [41],
[56] (concrete wording in Appendix E).
Manual review: We validate our method by manually in-
vestigating a subset of 50 FOTA apps randomly chosen.
We chose these apps using the features in Table I, and
include RecoverySystem based, A/B system update based
and command based FOTAs. One of the authors manually
classiﬁed them as FOTA apps, discovering three apps that
are potential FPs. However, a closer look on those apps
reveals that these are not fully-ﬂedged FOTA apps, but part
of a larger FOTA system composed of multiple apps, each
one of them responsible for different phases (e.g., down-
load, verify and install the packages). Speciﬁcally, a FOTA
(com.samsung.sdm) veriﬁes the update package using the
method RecoverySystem.verifyPackage, but relies on a na-
tive library (libmno_dmstack.so) to apply the update. Another
app (com.qualcomm.qti.loadcarrier) applies the veriﬁca-
tion but relies on the service CarrierAccessCacheService
from another package for the actual installation. Finally,
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:11:06 UTC from IEEE Xplore.  Restrictions apply. 
1609
com.zte.zdm relies on an custom update method (thus, not
implemented in FOTA Finder), which uses an intent with the
action android.intent.action.RECOVERY_REBOOT with the
speciﬁc parameters to perform the update. Accordingly, we do
not consider them as actual FPs and we do not remove them
from our dataset.
Samsung is an interesting example of the use of native code:
we ﬁnd a total of 149 devices with a FOTA app, but also the
libmno_dmstack.so library. Manual analysis of the library
reveals that the update is implemented by writing directly
into /cache/recovery/command. Even though there is no
enforcement on Google’s side, none of its recommendations
use native code for system updates.
FOTA apps in the Play Store: We search all FOTA package
names in Google’s Play Store from Madrid, Spain on the June
24, 2020. We rely on a purpose-built crawler that uses the
package name (indexing ﬁeld on Google Play) to identify
the presence of an app in the market. We detect 7 FOTA
packages that are available in the store, including Google
Play Services. Although Google Play Services does not
perform any system updates, it still updates Google related
apps that often come pre-installed. We review the descriptions
and certiﬁcated of the other six apps and verify that these apps
are indeed FOTA apps, used for system updates of speciﬁc
phone models and released by the actual device vendor. We
lack sufﬁcient insights to explain why these apps were accepted
on Google Play despite Google’s Terms of Service [56].
V. ECOSYSTEM
Developing and deploying FOTA apps, as well as operating
the updating infrastructure, are critical parts of the Android
supply chain. While some OEMs might keep these processes
in-house, others rely on third-party FOTA suppliers for some
or all of the steps. The number and relationships between
the stakeholders involved in the ﬁrmware update process are
generally unknown, and it is not always possible to determine
their identity due to the lack of accurate attribution signals. In
this section, we leverage FOTA Finder’s results to explore this
ecosystem. First, we identify the different stakeholders present
in the deployment of FOTA apps (§V-A). Second, we analyze
their prevalence across different devices and brands (§V-B).
A. FOTA stakeholders
One critical aspect of the FOTA supply chain is identifying
the company or organization responsible for building and
deploying the FOTA component. A number of technical
challenges prevent us from reliably performing authorship
attribution in the Android ecosystem. This is, to a great degree,
the result of a lack of a public key infrastructure (PKI) to verify
the legitimacy of the certiﬁcates used to sign apps. This issue
is particularly critical on pre-installed apps [43] as they lack
the developer metadata that can be found for regular apps on
app stores. Furthermore, confusion is added when brands and
developers use multiple organization unit names within their
products (e.g., Samsung Corporation vs. Samsung Electronics)
or when they use generic names such as Android [61].
Despite these limitations, we analyze FOTA package names
and certiﬁcates to identify the companies responsible for the
deployment of FOTA apps and, if possible, their developers.
We assume that the company that signs a FOTA package is the
one behind its deployment. We also check the FOTA package
name and, if it contains a company name that differs from the
signer, we assume that the app is developed by the company that
appears in the package name and deployed by the company that
signs it. We combine the methodology proposed by Sebastian et
al. [61] with the device brand as reported by Firmware Scanner.
To get the organizations from the certiﬁcates, we rely on the
Organization ﬁeld (O) and the domain of the Email from the
subject’s Distinguished Name (DN). From this analysis, we ﬁnd
269 unique certiﬁcates that sign FOTA apps, belonging to 219
subjects from 127 organizations. The spectrum of organizations
in the certiﬁcates is wide, ranging from certiﬁed OEM vendors
such as Samsung to MNOs such as Vodafone.
To better explore the FOTA providers landscape, we classify
them by their type of company following a semi-manual
snowball sampling method [45]. We performed web searches
to identify unknown companies that remained unclassiﬁed.
This process allow us to identify the following categories,
presented by number of package names detected for each
category and the percentage of apps within the 2,013 FOTAs
detected: (i) OEMs: 53% of FOTA apps from 77 different
packages; (ii) SoCs: 9% of FOTAs apps from 13 packages;
(iii) SFDs: e.g., Adups or Redstone: 9% of FOTA apps from 13
packages; (iv) MNOs: 1.6% of FOTA apps from 4 packages.
Additionally, there are 15% FOTAs from 2 Google packages
(com.google.android.gms and com.google.android.gsf).
We could not ﬁnd information for 12% FOTA apps from
24 packages, which we label as Uncategorized (UNC). This
analysis reveals that the FOTA ecosystem is rich and goes
beyond just OEM vendors.
While one would expect a one-to-one mapping between pack-
age names and signatures, we ﬁnd that this is not the case in the
FOTA landscape: 49 (37%) packages are signed by 2 or more
different organizations. This is due to different organizations de-
veloping the FOTA and deploying them in the devices. The most
extreme case is a single package, com.adups.fota.sysoper,
signed by 60 different organizations. Adups is a FOTA software
development company whose products are integrated in (mostly
low-end) smartphones [19], [47]. Organizations signing this
package include OEMs such as Konka, Tinno and Wheatek. In
many of these cases, this a mandatory requirement in order
to acquire the system shared UID as we will show in §VI.
Another package, com.mediatek.systemupdate.sysoper, is
signed by 33 different certiﬁcates from various organizations,
including OEMs like Oppo, Lenovo and HTC. Mediatek is
a SoC manufacturer, and the presence of one of its FOTAs
might be required to update speciﬁc ﬁrmware. However, as
we describe in §V-B and §VII, some FOTA apps from SoC
vendors do install apps available on public markets.
Security implications: The lack of control over the FOTA
signing process has attribution implications but also security
ones. We ﬁnd 40 FOTA apps (2%), corresponding to 13
different packages that are signed with default (thus well-
known) test-keys released as part of the AOSP. At least 171
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:11:06 UTC from IEEE Xplore.  Restrictions apply. 
1610
Package
# dev.
98
com.adups.fota.sysoper
16
com.mediatek.systemupdate.sysoper
13
pl.zdunex25.updater
com.abastra.android.goclever.otaupdate 11
10
com.mediatek.googleota.sysoper
8
com.redstone.ota.ui
6
com.freeme.ota
4
com.fw.upgrade.sysoper
3
com.fota.wirelessupdate
3
org.pixelexperience.ota
2
com.android.settings
1
com.adups.fota
1
com.rock.gota
Brand
Alps
Xiaomi
Samsung
Goclever
Allview
Doogee
Iku
Blackview
Bravis
Cubot
Elite_5
BQ
Others (9)
# dev.
80
16
12
11
10
9
8
6
6
3
2
2
11
Table II: FOTA Packages (left) signed by default keys from
AOSP and Top brands (right) affected.
devices from 20 brands present this issue as listed in Table II.
The use of such keys is discouraged in the FOTA development
guidelines deﬁned in the Android ofﬁcial documentation due to
their concerning security implications [30]. Examples of these
risks are the replacement of legitimate app as an update or, in
case of misconﬁguration of the sharedUID and components
permissions, another app running in the same process memory