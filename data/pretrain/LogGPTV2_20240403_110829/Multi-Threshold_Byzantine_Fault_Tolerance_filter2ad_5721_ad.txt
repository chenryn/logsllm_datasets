We further observe that these two protocols also share two fun-
damental steps in achieving safety despite their different timing
models and fault thresholds. In particular, they both need to guar-
antee safety within a view and across views. Let |C| be the quorum
size; |C| = 2ğ‘“ + 1 out of ğ‘› = 3ğ‘“ + 1 in PBFT and |C| = ğ‘“ + 1 out of
ğ‘› = 2ğ‘“ +1 in Sync HotStuff, where ğ‘“ is the fault tolerance threshold.
(P1) consistency within a view: If an honest replica commits a
value ğ‘ in view ğ‘£, no conflicting value ğ‘â€² has a certificate in view ğ‘£.
(P2) consistency across views: If an honest replica commits a
value ğ‘ in view ğ‘£, more than ğ‘› âˆ’ |C| honest replicas receive a
certificate of ğ‘ from view ğ‘£ before entering the next view ğ‘£ + 1.
PBFT achieves P1 using the standard quorum intersection tech-
nique. With up to ğ‘“ Byzantine faults out of ğ‘› = 3ğ‘“ + 1 replicas, two
quorums of |C| = 2ğ‘“ + 1 replicas intersect at at least one honest
replica (because 2|C|âˆ’ğ‘› = ğ‘“ +1). Having two conflicting certificates
from the same view would imply that an honest replica voted for
two equivocating proposals, which cannot happen. For P2, PBFT
uses two rounds of voting, so an honest replica commits a value
only after |C| = 2ğ‘“ + 1 replicas (at least ğ‘“ + 1 honest) voted for the
certificate of that value.
Sync HotStuff, on the other hand, cannot rely on quorum inter-
section because it tolerates ğ‘“ Byzantine faults out of ğ‘› = 2ğ‘“ + 1
replicas. Instead, it uses synchronous waiting periods to achieve
these properties. An honest replica ğ‘Ÿ commits a value only after
Session 6A: Consensus and Attacks CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1691waiting for 2Î” time and detecting no leader equivocation or view-
change. The equivocation check makes sure no honest replica votes
for conflicting values. This rules out conflicting certificates in this
view, achieving P1. Checking view-change of other replicas makes
sure no honest replica enters the next view early. This leaves enough
time for all honest replicas to receive (from ğ‘Ÿ) a certificate for the
committed value before entering the next view, achieving P2.
Combining PBFT and Sync HotStuff. Our key observation is
that the orthogonal techniques of PBFT and Sync HotStuff are
compatible under the three constraints at the beginning of this
section and a quorum size |C| = ğ‘› âˆ’ ğ›¾ğ‘ , as we elaborate below.
PBFTâ€™s quorum intersection ensures that two quorums of size
ğ‘› âˆ’ ğ›¾ğ‘  intersect at 2(ğ‘› âˆ’ ğ›¾ğ‘ ) âˆ’ ğ‘› = ğ‘› âˆ’ 2ğ›¾ğ‘  = ğ›½ğ‘ + 1 replicas. Under
partial synchrony, this ensures P1 with up to ğ›½ğ‘ faults, which is our
target fault threshold for partially synchronous safety. Moreoever,
a quorum of |C| = ğ‘› âˆ’ ğ›¾ğ‘  = ğ›¾ğ‘  + ğ›½ğ‘ + 1 replicas contains at least
ğ›¾ğ‘  +1 > ğ‘›âˆ’|C| honest replicas, so PBFTâ€™s two-phase voting ensures
P2 under partial synchrony.
Under synchrony, we can show the 2Î” waiting periods ensure
that P1 and P2 still hold. When an honest replica commits a value,
the 2Î” waiting period before commit still ensures that no honest
replica votes for a conflicting value, hence ruling out a conflicting
certificate (P1 holds) under ğ›½ğ‘  faults because |C| = ğ‘› âˆ’ ğ›¾ğ‘  = ğ›½ğ‘  + 1.
Similarly, the 2Î” waiting period in view change ensures that all
ğ‘› âˆ’ ğ›½ğ‘  = ğ›¾ğ‘  + 1 > ğ‘› âˆ’ |C| honest replicas receive a certificate before
entering the next view (P2 holds).
Therefore, combining the techniques of PBFT and Sync HotStuff
seamlessly with a quorum size of |C| = ğ‘› âˆ’ ğ›¾ğ‘  gives a MT-BFT SMR
protocol with optimal fault thresholds.
4.3 Protocol Description
Block chaining. Following recent BFT protocols [2, 47], we uti-
lize the â€œblock chainingâ€ paradigm to simplify the protocol. In the
steady state protocol, the leader proposes a block containing a list
of transactions and a hash digest of the previous block. Thus, a
block determinies a unique hash chain for all previous blocks in
the log. Any chains starts at a hard-coded genesis block, and the
distance from the genesis block to a block ğµ in the chain is called
the height of block ğµ. A block of height ğ‘˜, denoted ğµğ‘˜, is formatted
as (ğ‘‘ğ‘˜, ğ»(ğµğ‘˜âˆ’1)) where ğ‘‘ğ‘˜ is a set of transactions and ğ»(ğµğ‘˜âˆ’1) is
the hash of the predecessor block ğµğ‘˜âˆ’1. The genesis block ğµ0 can
be written as ğµ0 = (âŠ¥,âŠ¥). We say a block ğµğ‘˜ = (ğ‘‘ğ‘˜, â„ğ‘˜âˆ’1) is valid
if (i) it is the genesis block or (ii) there is a valid block ğµğ‘˜âˆ’1 and
â„ğ‘˜âˆ’1 = ğ»(ğµğ‘˜âˆ’1). We say a block ğµğ‘˜ extends ğµğ‘™ if ğµğ‘˜ = ğµğ‘™ or ğµğ‘˜ is a
descendant of ğµğ‘™. If two blocks do not extend one another, we say
they conflict with each other. Conflicting blocks can occur due to
network asynchrony or faulty leaders. If two conflicting blocks are
signed in the same view by the same leader, they form a proof of
leader equivocation.
Each view is identified by a monotonically increasing integer
denoted ğ‘£ â‰¥ 1, and has a leader ğ¿ selected in a round robin manner
(e.g., ğ‘£ mod ğ‘›). In each view ğ‘£, the steady state protocol (Figure
2) runs the following steps in iterations. Note that each step is
triggered by an â€œuponâ€ event and is hence non-blocking. Thus,
subsequent blocks ğµğ‘˜+1, ğµğ‘˜+2 can be proposed before the previous
block ğµğ‘˜ is committed.
Propose. The leader ğ¿ of view ğ‘£ proposes a block ğµğ‘˜ =
(ğ‘‘ğ‘˜, ğ»(ğµğ‘˜âˆ’1)) in the form of âŸ¨propose, ğµğ‘˜, Cğ‘£(ğµğ‘˜âˆ’1), ğ‘£âŸ©ğ¿. The cer-
tificate in the proposal must be the certificate for the predecessor
ğµğ‘˜âˆ’1 in the current view ğ‘£. In the steady state, the leader ğ¿ pro-
poses ğµğ‘˜ upon receiving Cğ‘£(ğµğ‘˜âˆ’1) for its previous proposal ğµğ‘˜âˆ’1
in the current view. For the first proposal after entering view ğ‘£, the
certificate Cğ‘£(ğµğ‘˜âˆ’1) is formed during the view change protocol and
will be described later.
Vote. Upon receiving a valid proposal âŸ¨propose, ğµğ‘˜, Cğ‘£(ğµğ‘˜âˆ’1), ğ‘£âŸ©ğ¿
by the leader ğ¿ of the current view ğ‘£, a replica ğ‘Ÿ votes for the block
ğµğ‘˜ in the form of âŸ¨vote, ğµğ‘˜, ğ‘£âŸ©ğ‘Ÿ , if the replica has not received an
equivocating proposal signed by ğ¿ in the current view ğ‘£.
Certificates and ranking. A quorum of |C| = ğ‘› âˆ’ ğ›¾ğ‘  votes form
a quorum certificate (or certificate for short). This is the key ingre-
dient of many SMR protocols including ours. To elaborate, each
replica ğ‘Ÿ votes for a block ğµğ‘˜ (at height ğ‘˜ proposed by the leader
of the current view ğ‘£ in the form of âŸ¨vote, ğµğ‘˜, ğ‘£âŸ©ğ‘Ÿ . A quorum of
âŸ¨vote, ğµğ‘˜, ğ‘£âŸ©âˆ— messages from distinct replicas form a certificate for
block ğµğ‘˜ in view ğ‘£, denoted Cğ‘£(ğµğ‘˜). We say a block ğµğ‘˜ is certified
in view ğ‘£ if the certificate Cğ‘£(ğµğ‘˜) is formed. Certificates are ranked
first by view number and then by height. For example, Cğ‘£(ğµğ‘˜) is
ranked higher than Cğ‘£âˆ’1(ğµğ‘˜+1) but lower than Cğ‘£(ğµğ‘˜+1).
Pre-commit. Upon receiving a certificate Cğ‘£(ğµğ‘˜), a replica ğ‘Ÿ for-
wards it to all other replicas. Then, after waiting for 2Î”, it broadcasts
âŸ¨commit, ğµğ‘˜, ğ‘£âŸ©ğ‘Ÿ . The 2Î” waiting step helps maintain consistency
both within a view and across views (i.e., P1 and P2) under syn-
chrony as in Sync HotStuff. The commit message corresponds to
the second vote in PBFT, which helps maintain consistency across
views (i.e., P2) under partial synchrony.
Commit. Finally, upon collecting a quorum of âŸ¨commit, ğµğ‘˜, ğ‘£âŸ©âˆ—, a
replica forwards them to all other replicas, and commits the block
ğµğ‘˜. As we mentioned before, a replica commits a log by broad-
casting a signature on the log instead of each block or transaction.
However, as all blocks are chained by hash references, the block
ğµğ‘˜ works as a snapshot of the log that consists of ğµğ‘˜ and all its
ancestors. Therefore, we hereafter say a replica commits a block/log
interchangeably.
The view change protocol (Figure 3) monitors the progress in
the steady state and changes the view when the leader exhibits a
faulty behavior or replicas fail to make progress.
Blame. A replica blame the view by broadcasting âŸ¨blame, ğ‘£âŸ©ğ‘Ÿ if it
detects leader equivocation or suspects the leader is misbehaving
such as stalling progress or censoring transactions. A transaction
ğ‘¡ğ‘¥ is considered to be censored if it has not been committed by
max{ğ‘‡ğ‘¡ğ‘¥ ,ğ‘‡ğ‘£} + Î› where ğ‘‡ğ‘¡ğ‘¥ is the time it receives ğ‘¡ğ‘¥, and ğ‘‡ğ‘£ is the
time it starts view ğ‘£, and Î› is a given time (the specific value is
discussed later). In the case of the leaderâ€™s equivocation, the replica
forwards the two equivocating proposals to all other replicas as
proof of misbehavior of the current leader, and stops all processes
in the steady state of view ğ‘£.
Status. A quorum of distinct âŸ¨blame, ğ‘£âŸ©âˆ— is called a blame-certificate
for view ğ‘£, denoted Bğ‘£. Upon receiving Bğ‘£, a replica ğ‘Ÿ forwards it
Session 6A: Consensus and Attacks CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1692to all other replicas, and stops all processes in the steady state of
view ğ‘£. Then, the replica ğ‘Ÿ sets a variable lockğ‘Ÿ to a highest ranked
certificate to lock on and sends it to the leader ğ¿â€² of the next view
ğ‘£ + 1 in a message âŸ¨status, lockğ‘Ÿ , ğ‘£âŸ©ğ‘Ÿ . At this point, replica ğ‘Ÿ starts
the new view ğ‘£ + 1.
New-View. A quorum of âŸ¨status, lock, ğ‘£âŸ©âˆ— messages form a status-
certificate, denotedSğ‘£. Upon receivingSğ‘£, the new leader ğ¿â€² of view
ğ‘£ + 1 picks a highest certificate lockğ‘£+1 among Sğ‘£, and broadcasts
âŸ¨new-view, lockğ‘£+1,Sğ‘£, ğ‘£ + 1âŸ©ğ¿â€². One status message in Sğ‘£ must
come from an honest replica. Since more than ğ‘›âˆ’|C| honest replicas
lock on all blocks committed till the previous view ğ‘£ (by P2), the
selected highest certificate lockğ‘£+1 always extends all committed
blocks.
First-Vote. Upon receiving a first âŸ¨new-view, Cğ‘£â€²â€²(ğµğ‘˜â€²),Sğ‘£, ğ‘£ +1âŸ©ğ¿â€²,
a replica ğ‘Ÿ first checks that the selected certificate Cğ‘£â€²â€²(ğµğ‘˜â€²) has a
highest rank in Sğ‘£. If the check passes, a replica ğ‘Ÿ forwards it to all
other replicas and sends âŸ¨vote, ğµğ‘˜â€², ğ‘£ + 1âŸ©ğ‘Ÿ . This step forms the first
certificate in the new view ğ‘£ + 1 that all subsequent proposals in
view ğ‘£ + 1 should extend.
4.4 Correctness of the Protocol
We prove the safety and liveness of the protocol. We say a replica
directly commits a block ğµğ‘˜ in a view ğ‘£ if it is due to the replica
receiving a quorum of ğ‘› âˆ’ ğ›¾ğ‘  âŸ¨commit, ğµğ‘˜, ğ‘£âŸ©. If a replica commits
a block ğµğ‘˜ as a result of directly committing one of its descendant,
then we say ğµğ‘˜ is indirectly committed.
Safety under partial synchrony. We prove safety under partial
synchrony in the presence of at most ğ›½ğ‘ faulty replicas.
Lemma 4.2 (Consistency within a View). If two certificates
Cğ‘£(ğµğ‘˜) and Cğ‘£(ğµğ‘™) from the same view ğ‘£ exist, then ğµğ‘˜ and ğµğ‘™ do
not conflict with each other.
Proof. Suppose for the sake of contradiction two conflicting
certificates Cğ‘£(ğµğ‘˜) and Cğ‘£(ğµğ‘™) both exist, then at least an honest
replica must have voted for both, because two quorums of ğ‘› âˆ’ ğ›¾ğ‘ 
intersect at an honest replica, i.e., 2(ğ‘› âˆ’ ğ›¾ğ‘ ) âˆ’ ğ‘› > ğ›½ğ‘. This cannot
happen because an honest replica stops voting in view ğ‘£ as soon as
it detects equivocating proposals.
â–¡
Lemma 4.3. If an honest replica directly commits a block ğµğ‘˜ in
a view ğ‘£, then at least ğ›¾ğ‘  + 1 honest replicas receive Cğ‘£(ğµğ‘˜) before
entering view ğ‘£ + 1.
Proof. Suppose an honest replica directly commits a block ğµğ‘˜
in a view ğ‘£, then it must have received ğ‘›âˆ’ğ›¾ğ‘  âŸ¨commit, ğµğ‘˜, ğ‘£âŸ©, out of
which at least ğ‘› âˆ’ ğ›¾ğ‘  âˆ’ ğ›½ğ‘ > ğ›¾ğ‘  must be from honest replicas. These
ğ›¾ğ‘  + 1 honest replicas must have received the certificate Cğ‘£(ğµğ‘˜)
before sending âŸ¨commit, ğµğ‘˜, ğ‘£âŸ© before entering view ğ‘£ + 1.
â–¡
Lemma 4.4 (Consistency across Views). If an honest replica
directly commits a block ğµğ‘˜ in a view ğ‘£, then for all view ğ‘£â€² â‰¥ ğ‘£, if a
certificate Cğ‘£â€²(ğµğ‘™) exists, then ğµğ‘™ does not conflict with ğµğ‘˜.
Proof. We prove by induction on the view number. The base
case (i.e., ğ‘£â€² = ğ‘£) follows from Lemma 4.2. We prove for the induc-
tive step (i.e., view ğ‘£â€² + 1). Suppose a certificate Cğ‘£â€²+1(ğµğ‘™) exists.
Let ğµğ‘š be the block of lowest height in the chain that is certified
in view ğ‘£â€² + 1. Then, at least an honest replica must have voted
for ğµğ‘š in the First-Vote phase of the view change protocol. Oth-
erwise, blocks extending ğµğ‘™ (including ğµğ‘™) could not have been
certified in view ğ‘£â€² + 1, as every valid proposal should contain a
certificate for the previous block in the same view. In the First-Vote
phase, the honest replica must have voted for ğµğ‘š in response to
âŸ¨new-view, Cğ‘£â€²â€²(ğµğ‘š),S, ğ‘£â€²+1âŸ©ğ¿â€² message from the leader ğ¿â€² of view
ğ‘£â€² + 1, and Cğ‘£â€²â€²(ğµğ‘š) (ğ‘£â€²â€² â‰¤ ğ‘£â€²) should be the highest certificate in
S. However, recall that at least ğ›¾ğ‘  + 1 honest replicas (denoted ğ‘…)
receive Cğ‘£(ğµğ‘˜) before entering view ğ‘£ + 1 â‰¤ ğ‘£â€² + 1 (Lemma 4.3).
As ğ‘… and S (|S| â‰¥ ğ‘› âˆ’ ğ›¾ğ‘ ) intersect, Cğ‘£â€²â€²(ğµğ‘š) should be as highly
ranked as Cğ‘£(ğµğ‘˜). By the inductive hypothesis, ğµğ‘š should extend
ğµğ‘˜. Therefore, ğµğ‘™ (which extends ğµğ‘š) does not conflict with ğµğ‘˜. â–¡
Lemma 4.5 (Safety for Replica). Honest replicas do not commit
conflicting blocks.
Proof. Suppose two blocks ğµğ‘˜ and ğµğ‘˜â€² are committed due to
directly committed descendants ğµğ‘™ and ğµğ‘™â€², respectively. As all
directly committed blocks are certified, by Lemma 4.4, ğµğ‘™ and ğµğ‘™â€²
do not conflict with each other. Therefore, ğµğ‘˜ and ğµğ‘˜â€² are both
ancestors of ğµğ‘™ (and ğµğ‘™â€²), and do not conflict with each other.
â–¡
Safety under synchrony. We next prove the safety under syn-
chrony, assuming in the presence of at most ğ›½ğ‘  faulty replicas.
Lemma 4.6 (Consistency within a View). If an honest replica
directly commits a block ğµğ‘˜ in a view ğ‘£, then a certificate Cğ‘£(ğµğ‘™) for