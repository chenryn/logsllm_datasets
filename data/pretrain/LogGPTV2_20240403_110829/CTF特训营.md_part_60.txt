的字节略小于三分之二时也是可以接受的，在条件合适的情况下
1024bit的p只泄露了576bit的情况下也可成功破解，链接地址为http：//
inaz2.hatenablog.com/entries/2016/01/20
gQFin
Cin
/St1
1328227995704915072503007063200364576
I X boad rerp*eted
x/(-10）-
R345102397731110574E29155831-80T0
 Salutismz pesrible?
434
---
## Page 737
CTF特训营：技术详解、解题方法与
21.2.8 LLL-attack
737/1144
图21-13sagemathonline使用示意图
n=
9334937733448456075603114208679090133527655906458043282473500456798
8751415648830617936580383688095318734763846475747947760683566685845
2624731764118679536238192864087991140729609078631518839424163207442
0208528687744469643112120156828944408293810942046877025345351592988
9828385480770293599077948553598433641577
pbits =512
kbits = 128
pbar=
2600959663750293864336314076747402320112860286027241676686664211559
3768934857799915513538773094516413541887435644845
pbar=pbar=PolynomialRing(Zmod（n)
f=x+pbar
x0 = f.small_roots(X=2^kbits, beta=0.4)[0]#find root = n^0.3
print x0 + pbar
当只知道部分明文的时候，也可以使用LLLattack，代码如下：
import time
def matrix_overview(BB, bound):
def coppersmith_howgrave_univariate(pol,modulus, beta, mm,t, XX):
length_N =1024 #sizeof the modulus
Kbits=72
2#sizeof theroot
e=3
#RSA gen(for the demo)
N=
0xccb42e1da27b1c1c1047a7377ea3bfe9bd85b50b753f58b2e5fe28144dd281ee994
0ffc752b9fccde6bff54f90a67de0856239f6dd69f4467bf712551c9ce974f4c3d5fc05ec
bbe1ae3a8197b96ee6fb094fb6a50f946fd19dc56c9f108718890c922095b27d43eb43
5e59e901814fdd751269c900704684eb0c2fd74676c7a7
C=
0xa4957e1adc6d775f61fb07d62e07e078f7ae2d91686bb4b65151d34ce0a1e28373e
---
## Page 738
CTF特训营：技术详解、解题方法与
21.2.8 LLL-attack
738/1144
a3e6bbe3462f905c5fd71db7fd5aa46d38cd5c25e129ca180f3d37194588660eace46b
c3187b6c0e687119dff24d9a3aed959b832403d568ec1195107a71cb4f7088c064755
e7d40ce431c11456207d777d2ba3e8c3af72a84957ce959810
partial_m=
0xa6717a7ee57e329b717a29f2a9fc503641bf481d5c24198fe2f9c15dc3ddee11a184
c46b0065b54fa332aebfed130d7d44da249ec51d27000000000000000000
#Problem toequation(default)
ZmodN = Zmod(N);
P.=PolynomialRing(ZmodN)#,implementation='NTL)
pol=（partial_m-2^Kbits+x)e-C
dd =pol.degree()
#Tweak those
beta = 1
#b=N
epsilon = beta/7
#= 0）:
t=Arithmetic.is_perfectsquare(discr)
if t|=-1 and (s +t） % 2==0:
print("Hacked!")
return d
#TESTfunctions
def test_hack_RSA()
print(Testing WienerAttack")
times=5
while(times>0):
e,n,d=RSAvulnerableKeyGenerator.generateKeys(1024)
print（"(e，n） is ("，e,"，”，n,")")
print("d=",d)
hacked_d=hack_RSA（e,n)
if d==hacked_d:
print("Hack WORKED!")
else:
print(Hack FAILED")
print("d="， d,",hacked_d =",hacked_d)
times -= 1
f
name=="main”：
#test_is_perfect_square()
#print（?--
test_hack_RSA()
其中，hack_RSA（e，n）函数即为进行攻击的函数，这里我们修改
此文件如下（为了避免报错，我们在此文件的头部插入一句sys指令
用于增加回溯的空间）：
---
## Page 742
CTF特训营：技术详解、解题方法与
21.2.9 Wiener Attack&:Boneh Durfee Attack
742/1144
CreatedonDec14,2011
@author:pablocelayes
importContinuedFractions,Arithmetic，RSAvulnerableKeyGenerator
import sys
sys.setrecursionlimit(10000000)
def hack_RSA(e, n):
Finds d knowing (e,n)
applyingtheWienercontinuedfractionattack
frac=ContinuedFractions.rational_to_contfrac(e,n)
convergents=ContinuedFractions.convergents_from_contfrac(frac)
for(k,d)in convergents:
#checkif d isactually thekey
if kI=0 and (e*d-1) %k==0:
phi=(e*d-1)// k
s=n-phi+1
#check if the equation x^2-s*x+n=0
#has integer roots
discr=s*s-4*n
if (discr >= 0):
t=Arithmetic.is_perfect_square(discr)
if t != -1 and (s + t) % 2 == 0:
print("Hacked!")
return d
if_name_==_main：
=u
1313574815292206885180756225999183352617573077748412402361299385182
0430465037487878895896130071293914692462327355434771499295389681886
2725321923319965267452566983753865159969071487636488204871579930383
6733470450538700637221756089930801627164154864480275324243837246950
7180157132200526110633487733404721165939792933355560883710762675539
3427056320625857002257080722498437768960750360112169740061492146894
7983083075717524227698210884923685569229717801600035882881191549383
95902573141227
e=
1247264361265855636268812776194663908173934485921871455970996525605
---
## Page 743
CTF特训营：技术详解、解题方法与
21.2.9 Wiener Attack&:Boneh Durtee Attack
743/1144
2431749454548817304848413467042472979918287245463205407261868802360
2512972704011563556323537814958080098820812794336309648653631424339
4003288264288445051243538918837166331033291887549337037067812648545
3550431880160141317463203769606991758739033821056257388276263873215
0555458294503511572471826886948803841300076498076317271422681284390
3268126699834297895984508016199805845887340292959743830419418592760
9154133353292494116640984586259361644245928207767098232359227782789
3586539301839533299413545978789430490608316049186615598693935755726
07525778785647
print hack_RSA(e,n)
输出结果如下：
Hacked!
2355246239
算出来的结果是d，然后进行解密并转化：
n=
1313574815292206885180756225999183352617573077748412402361299385182
9955443156593171810566108770514215820542984343663846287282386582824
0430465037487878895896130071293914692462327355434771499295389681886
2725321923319965267452566983753865159969071487636488204871579930383
6733470450538700637221756089930801627164154864480275324243837246950
7180157132200526110633487733404721165939792933355560883710762675539
3427056320625857002257080722498437768960750360112169740061492146894
7983083075717524227698210884923685569229717801600035882881191549383
95902573141227
C=
2484709721197628568638797402073216500708160464312296481998154858152
9841910279650254479897357345114413785606554500498272804213946847946
8686863712979202592246705063763386171248943905092403425079136204429
5391037523401336182117452300215045245450296408968446161318116489796
9321952517280123704642753807082229650340385354447180366074174097918
---
## Page 744
CTF特训营：技术详解、解题方法与
21.2.9 WienerAttack&Boneh Durfee Attack
744/1144
3744766600366204445415719316381678856907782811329370712566969122411
7600396751474529444594474580294996493669660917501480978005643339242
3781329941759412861038276422318590147352313468457232643720815151230
6054708160038
d=2355246239
m=pow(c,d,n)
def num2str(num):
tmp=hex(num)[2:].replace("L",")
if len(tmp) % 2 == 0:
return tmp.decode("hex")
else:
return("O"+tmp).decode("hex")
print num2str(m)
结果输出如下：
flag(wiener_attack)
如果d没有足够小，那么其bit数量略大时，WienerAttack将不会
起作用。这时，我们可以尝试BonehDurfeeattack进行攻击。具体代
码参见Git的相关内容。
---
## Page 745
CTF特训营：技术详解、解题方法与
21.2.10共模攻击
745/1144
21.2.10共模攻击
Bob为了省事，在两次通信的过程中使用了相同的n，而Alice是
对相同的m加密，在这种情况下，Cat可以不计算d而直接计算出m的
值。
想要使用共模攻击的前提是有两组及以上的RSA加密过程，而且
其中两次的m和n都是相同的，那么Cat可以通过计算直接计算出m。
下面使用一个案例进行讲解，样例数据如下：
n1=
2166019093101327055948798314196634727966604446857200032562828257859
5119101840917794617733535995976710097702806131277006786522442555607
8424859756166892975595833524131600871636568510197694656378569675118
1980347394015471251638058014662001892140635466860452372334089584300
9899397618067679200188650754096242296166060735958270930743173912010
8524671140473015299834966692506713427308041494287002804014814217351
8489996546819180284428569998537023852816350567435038052860014388061
9512293622576854525700785474101747293316814980311297382429844950643
9778257712687573040882595312582220936678474688988233672518243168885
63269155865061
e1=65537
c1=
1162324252006356472150969903903421032931423823406883613075645733514
2671659158578379060500554276831657322012285562047706736377103534543
5651796608637964960711875338608961481538568456389893844296589631349
1523089857217372045427136954343570899445728081936331878341303377401
4447450648051500214508699056865320506104733203716242071136228269326
4514121597608186768141294282525232488223166333393938210526140338846
6164937660424574465114295949891723513807736681810989273829825116176
---
## Page 746
CTF特训营：技术详解、解题方法与
21.2.10共模攻击
746/1144
5421598000993718723961814486554488421489986675681047108074113581179
39831241620315
n2=
2166019093101327055948798314196634727966604446857200032562828257859
5119101840917794617733535995976710097702806131277006786522442555607
1980347394015471251638058014662001892140635466860452372334089584300
9899397618067679200188650754096242296166060735958270930743173912010
8524671140473015299834966692506713427308041494287002804014814217351
8489996546819180284428569998537023852816350567435038052860014388061
9512293622576854525700785474101747293316814980311297382429844950643
9778257712687573040882595312582220936678474688988233672518243168885
63269155865061
e2=70001
c2=
8180690717251057689732022736872836938270075717486355807317876695012
3182831594409358662976445614072388070045655102634135445304210723537
3578128416668591942030580812306390727292559490985221224970492388977
6430284878600408776341129645414000647100303326242514023325498519509
0773119071618494079906493963301461467284473127540916701391593463162
6409179862376443493275327655478169223842805795159310482182302966520
3821775755835076337570281155689527215367647821372680421305939449511
6212442881042292901614846490565057846414863767414094434503319915572
2154005057402489442713933141623626378397706831529419818416915435253
6388685040531
如所给条件，两次rsa的通信过程中给出的n都是相同的，那么我
们可以假设两次加密的明文是相同的，并利用共模攻击进行攻击，代
码如下：
from Crypto.Util.number import long_to_bytes,bytes_to_long.getPrime,isPrime
importprimefac
defsame_n_sttack(n,e1,e2,c1,c2)
def egcd(a,b):
x,lastX=0,1
y,lastY=1,0
---
## Page 747
CTF特训营：技术详解、解题方法与
21.2.10共模攻击
747/1144
while (b!=0):
q=a//b
a,b=b,a%b