的队列主拷贝。对于通过故障节点进行连接的消费者来说，这倒没什么困难的。因
为它们去失了到节点的TCP连接，在它们重新附加到集群中一个新的节点时，会自
动选取新的队列主拷贝。但对于那些通过节点附加到镜像队列且节点正常运行的消
费者来说，RabbitMQ会发送给这些消费者一个消费者取消（consumercancellation）
通知，告知它们已不再附加在队列主拷贝了。如果AMQP客户端库能够支持消费者
取消通知的含义，那么它会抛出一个异常，同时应用程序就会知道已经不再附加到
队列上了，需要重新附加。另一方面，如果你的客户端库不支持消费者取消的话，
那事情就难办了。客户端无法通知应用程序其指向队列主拷贝的消费循环已不复存
在。因此你的应用程序呆坐在那里，以为队列里没有消息可供消费。不幸的是，针
对这种情况并没有好的解决方法（譬如，Rabbit关闭消费者的信道以强制抛出异常）。
所以如果客户端库不能支持消费者取消通知的话，你应该避免使用镜像队列。不然
的话，你的队列会被未消费的消息塞满，然后监控系统就会在半夜用电话叫醒你。
在了解了取消通知之后，剩下唯一关于镜像队列需要注意的是，那些已经消费
了但未被确认的消息。当镜像队列的主节点失败时，Rabbit不得不对那些已经投递
到消费者，但尚未得到确认的消息做个决定。虽然消息确实投递给了消费者，但是
Rabbit却不能区分故障转移中去失的确认消息和那些尚未得到确认的消息。所以为
了安全起见，已经消费但尚未被确认的消息会重新入队到它们所原来在的队列位置
（或者在队列的末尾，在版本2.7.0之前）
---
## Page 142
120
第5章集群并处理失败
5.7总结
当开始本章之前，你完全受制于使用单一Rabbit节点来为应用程序提供动力和
通信。现在你不再担心Rabbit崩溃了，因为RabbitMQ集群会确保基础架构正常运作。
更重要的是，你理解了集群内部实现的细枝末节，所以你能为RabbitMQ架构做出
明智的设计决定。这些决定可以最大化正常运行时间和可扩展性，并同时最小化消
息丢失带来的负面影响。但是RabbitMQ集群只是所有工作的一半。即便拥有动力
十足的Rabbit集群作为基础架构的“心脏”，你的应用程序仍然只是连接到了一个
节点。如果该集群节点发生故障的话，客户端会在集群中进行重连，这样它们就可
以不用停顿，继续运作。集群是Rabbit高可用性的最终方案。是时候讨论如何编写
可以幸免于单一节点故障的应用程序代码了，以便为这个高可用性方案画上圆满的
句号。
---
## Page 143
从故障中恢复
本章要点
■理解负载均衡
■安装并配置HAProxy来为Rabbit
做负载均衡
■重连并从故障中恢复
构建RabbitMQ集群来确保可用性和性能只是保障弹性消息通信基础架构的一
半。另一半则是编写当节点发生故障时知道如何重连到集群的应用程序。处理到集
群的重连有多种策略，我们所关注的这种是使用负载均衡来处理节点的选择。通过
使用负载均衡，不仅可以减少应用程序处理节点故障代码的复杂性，又能确保在集
群中连接的平均分布。但是即便使用了负载均衡器，编写处理节点故障的应用程序
也要比建立到集群的连接复杂得多。应用程序需要准备好重新创建交换器和队列以
应对初始节点故障。当使用主备设置的两台独立Rabbit节点时更为重要（我们会在
第7章介绍）。在开始编写故障处理代码之前，我们先看看RabbitMQ中如何使用负
载均衡器
---
## Page 144
122
第6章从故障中恢复
6.1为Rabbit做负载均衡
限于每个人不同的背景，你也许并不了解负载均衡器（loadbalancer）。一台负
载均衡器表示了单个IP地址背后存在多台服务器。假设你拥有三台服务器来为网站
提供支撑，它们分别是web1.acme.com、web2.acme.com和web3.acme.com。
如果没有负载均衡器的话，你的客户不得不手工指定访问webl，并且如果web1岩
机的话，再尝试web2或者web3。这不仅给你的客户带来了麻烦，同时又让你对每
台服务器的负载失去控制。如果拥有负载均衡器的话，你可以为其创建一个IP地址，
命名为www.acme.com。然后当客户连接到www时，负载均衡器会根据负载情况透
明地将连接代理到web1、web2或者web3。如果web1宕机了，负载均衡器会足够
聪明地检测到这一点，并停止将连接发送到web1，转而发送至web2和web3。对
你的客户来说，这就像你拥有一台巨大的叫作www的服务器，他们只需关心这一点
就够了。所有的负载均衡和故障服务器检测都交由负载均衡器一手包办（见图6.1）
客户
客户看到的是：WWW
一吕福
web1
web2
web3
图6.1将多台web服务器做负载均衡，看起来像一台服务器一样
当为RabbitMQ添加负载均衡器时，集群节点就作为负载均衡器背后的服务器，
而你的生产者和消费者就是客户了。应用程序只需知道负载均衡器的前端IP；负载
均衡器会以最小的连接负载透明地将客户端连接到集群节点。-如果你想要为集群增
强性能，则无须更改应用程序一你只需服务器新增节点，然后将其添加到负载均
衡器配置即可。无须修改应用程序。如果没有负载均衡器的话，应用程序就不得不
对每一个集群节点的IP做手工配置。同时也不得不自行处理集群节点的选择和故障
---
## Page 145
6.1为Rabbit做负载均衡
123
服务器检测。由于每个应用程序需要自行选择节点，因此你就无法在集群内将负载
平均分配。负载分配基本上是随机的。所以通过将负载均衡器放置在Rabbit集群的
前端，你就可以让它来处理节点选择、故障服务器检测以及负载分布这些复杂的事
情了（见图6.2）
消费者应用
生产者应用
客户看到的是：localhost:5670
交换器A
交换器A
交换器A
队列1
队列2
队列3
集群
集群
RabbitMQ
RabbitMQ
RabbitMQ
rabbit@localhost
rabbit_1@localhost
rabbit_2@localhost
localhost:5672
localhost:5673
localhost:5674
localhost
图6.2为RabbitMQ集群做负载均衡
市面上有许多不同的负载均衡器，它们可以分为两类：硬件装置和软件。硬件
装置是非常强大的专用网络系统，可以轻松处理每秒数以百万计的连接。它们经常
提供高级集群设置，使得两个负载均衡器能够像一个独立单元那样，以应对单点失
败。如果你已经有了一个硬件负载均衡器的话，那就使用它来作为RabbitMQ集群
的负载均衡，将其设置成第四层负载均衡模式。不过绝大多数情况下，一个软件负
载均衡器就已经绰绰有余了。在超过软件负载均衡器所能满足的集群能力之前，你
更有可能先达到集群能够支持的最大节点数上限。在众多的软件负载均衡器里面，
我们选择使用HAProxy。它是免费的，而且非常可靠，并且为各种站点处理高负载，
例如StackOverflow。同时，它可以运行在几乎所有的基于UNIX的平台上，并且非
常容易配置。对HAProxy的夸赞到此为止，下面展示如何安装它并进行配置，为
---
## Page 146
124
第6章从故障中恢复
RabbitMQ集群做负载均衡。
6.1.1安装HAProxy
安装HAProxy非常简单。大多数现代Linux发行版的包管理系统都有现成的
HAProxy。不过，我们会从源代码编译构建。首先将HAProxy下载到你的开发系统中，
并解压缩：
$wgethttp://haproxy.1wt.eu/download/1.4/src/haproxy-1.4.14.tar.gz
Resolving.haproxy.1wt.eu...88.191.124.161
Connecting to haproxy.1wt.eu|88.191.124.161l:80... connected
HTTP request sent, awaiting response... 2o0 OK
Length:812238 (793K) [application/x-gzip]
Savingto:haproxy-1.4.14.tar.gz'
100%[=======
======>]812,238
192K/s in 4.1s
2011-03-2919:16:56(192KB/s)-haproxy-1.4.14.tar.gz'saved
$ sudo tar xfz haproxy-1.4.14.tar.gz
将源代码解压之后，需要运行make来将HAProxy编译为可执行程序。在运
行make之前，你需要先选择目标平台。如果你是在Linux2.6系统上进行编译的
话，设置TARGET=linux26以开启epoll支持。对于其他基于UNIX的系统来说，
TARGET=generic通常是明智的选择。事不宜迟，让我们这就开始编译吧。
注意：epoll是Linux2.6内核的一个功能，它使得像HAProxy这样基于事
件的网络软件在新的包到达时收到通知，以取代周期轮询。这有助于减少
CPU的占用并在负载较重的系统中提升性能。FreeBSD也有相似的功能，
叫作kqueues。在HAProxy中通过设置TARGET=freebsd来加以利用。
$ cd haproxy-1.4.14
$ sudo make TARGET=generic
gcc -g -o haproxy src/haproxy.o src/sessionhash.o src/b...
现在在build目录下应该有个名为haproxy的可执行文件了。如果一切正常，
你应该可以运行haproxy--help来看看它的配置选项。最后，将haproxy可执
行文件复制到/usr/local/sbin，这样就可以在UNIX路径下可用了。现在需要
对HAProxy进行配置，这样它就可以在开发系统上为RabbitMQ集群做负载均衡了。
---
## Page 147
6.1为Rabbit做负载均衡
125
6.1.2配置HAProxy
HAProxy使用单一配置文件来定义所有属性，包括从前端IP 到后端服务器。下
列清单展示了用于本地Rabbit集群负载均衡的配置。
清单6.1本地RabbitMQ集群的HAProxy配置
global
日志
1og 127.0.0.1
local0 info
选项
maxconn 4096
      o o 
daemon
defaults
加载默认
1og
global
负载均衡
mode
tcp
配置
option
tcplog
option
dontlognull
retries
3
option redispatch
maxconn
2000
timeout
connect
5s
1前端IP，供
timeout client 120s
消费者和生
timeoutserver 120s
产者使用
负载均3
1isten rabbitmq_local_cluster 127.0.0.1:5670
衡中的
mode tcp
集群节
balance roundrobin
负载均
点配置
server rabbit 127.0.0.1:5672 check inter 5000 rise 2 fa11 3
2衡选项
server rabbit_1 127.0.0.1:5673 check inter 5000 rise 2 fa11 3
server rabbit_2 127.0.0.1:5674 check inter 5000 rise 2 fa11 3
listen private_monitoring :8100
数据统
mode http
4计页面
option httplog
stats enable
stats uri
/stats
stats refresh 5s
在处，你定义了IP和端口以供客户端连接。你使用了5670端口，这样不会
和RabbitMQ集群节点相冲突。然后你告诉HAProxy使用轮询算法②来将负载分发
给后台服务器（见图6.3）
最有趣的部分是3，在这里我们定义了后台服务器：
server rabbit 127.0.0.1:5672 check inter 5000 rise 2 fa1l 3
server rabbit_1 127.0.0.1:5673 check inter 5000 rise 2 fal1 3
server rabbit_2 127.0.0.1:5674 check inter 5000 rise 2 fa113
---
## Page 148
126
第6章从故障中恢复
消费者
消费者
消费者
#1
#2
#3
消费者#2
消费者#3
交换器A
交换器A
交换器A
队列1
队列2
队列3
集群
RabbitMQ
RabbitMQ