Windows
7组织涉及到PEB的堆内存并同时使用两种分配器。其中一个是后端，另一个是前端。前端堆是基于竞争的分配器，称为低碎片堆（LFH）。这主要在Chris
Valasek关于低碎片堆的论文中有所记录：
LFH的一个重要特性是，分配的堆块是8的倍数。一旦进行堆分配，它的长度会除以8，然后用于确定从哪个内存段返回堆块。一旦片段被标识，内存段内的指针实际将指向根据该长度返回的堆块。这意味着分配给Row对象（0x14）的空间将向上取整为桶的长度0x18。对于桶长度0x18，在竞争场里有255个可用的槽位。
内存段
    + ------- + ------- + -------------------------------- + ----------- + ------- +
    | ... | 竞争场| AggregateExchg.FreeEntryOffset | 块长度 | ... |
    + ------- + ------- + -------------------------------- + ----------- + ------- +
     竞争场
    + ----------------- + ----- + ----------- + --------- + --- ------ + ------------ +
    | 段指针| ... | 签名| 块1 | 块2 | 块X ... |
    + ----------------- + ----- + ----------- + --------- + --- ------ + ------------ +
LFH的另一个重要特性是，直到目标应用程序的分配遵循特定模式才实际使用它。直到发生这种情况，分配器将使用后端分配器。为了确保LFH堆被用于特定的桶长度，目标应用程序必须进行相同长度的0x12（18）分配。一旦完成，那么将使用前端分配器来分配所有该长度的内存。发现Palette记录是非常灵活的，可以用来做任意永远不会释放的分配。启用桶的LFH的步骤如下：
    *使用Palette记录分配相同大小的0x12内存。
    *分配255个内存强制使分配器分配一个新的段。
（注意：这可以合并为255-0x12的分配。）
当第一次分配段时，平台将用一个到竞争场的偏移量初始化内存段，其确定了返回的第一个块。当分配内存段的竞争场时，每个块预先写有表示到要返回的下一个堆块偏移的16位偏移（FreeEntryOffset）。当进行分配时，将从竞争场中的下一空闲块开头读取16位偏移并存储在段内。块中的16位偏移将被覆盖，因为它是应用程序所请求分配的一部分。
竞争场 – 开始
    + ---------------- + -------------------- + ----------- ----- + ---------------- +
    | 块1（占用）| 块2（空闲）| 块3（空闲）| 块X（空闲）|
    | 数据：... | FreeEntryOffset：3 | FEO：4 | FEO：X + 1 |
    + ---------------- + -------------------- + ----------- ----- + ---------------- +
这样，当做出另一个分配时，分配器将在段中设置FreeEntryOffset，其中正在分配的块中的FreeEntryOffset使得在下一个分配期间它将知道要返回的下一个块位置。当分配块时，在要返回的块中的偏移和位于段内的偏移之间执行原子交换操作。这防止当多个线程从相同的段/场地分配时的并发问题。
    状态0  - 开始
    下一个槽位：3
    当前加载到内存段的块3的偏移
    v 
        + -------------------- + -------------------- + ------- --------------- +
        | 块3（空闲）| 块4（空闲）| 块X（空闲）|
        | FreeEntryOffset：4 | FreeEntryOffset：5 | FreeEntryOffset：X + 1 |
        + -------------------- + -------------------- + ------- --------------- +
    状态1  -  malloc
    返回槽位3。将FreeEntryOffset从块3加载到内存段中。
    下一个槽位：4
                                现在是加载到内存段的块4偏移
                                v
        + ---------------- + -------------------- + ----------- ----------- +
        | 块3（占用）| 块4（空闲）| 块X（空闲）|
        | 数据：... | FreeEntryOffset：5 | FreeEntryOffset：X + 1 |
        + ---------------- + -------------------- + ----------- ----------- +
    状态2  -  malloc
    返回槽4.将FreeEntryOffset从块4加载到内存段中。
        下一个槽位：5
                                                        块5的偏移量被加载到段中
                                                        v
        + ---------------- + ---------------- + --------------- ------- +
        | 块3（占用）| 块4（占用）| 块X（空闲）|
        | 数据：... | 数据：... | FreeEntryOffset：X + 1 |
        + ---------------- + ---------------- + --------------- ------- +  |
    + ---------------- + ------------------ + ------------- --------- +
    状态3  -  malloc
    分配器将返回块5，因为它是下一个块。
    块5中的FreeEntryOffset将被加载到段中用于下一次分配。
    如果TxO记录用3覆盖这个值，这将意味着块3将作为下一个块返回。
    v
    + ---------------- + ------------------ + ------------- --- +
    | 块3（占用）| 块4（占用）| 块5（占用）|
    | | 数据：TxO Record | 数据：... |
    + + --------------------> |
    + ---------------- + ------------------ + ------------- --- +
    状态4  -  malloc
    返回块3.块3中的第一个16位字也将被加载到内存段。
    + ---------------- + ------------------ + ------------- --- +
    | 块3（占用）| 块4（占用）| 块5（占用）|
    | | 数据：TxO Record | 数据：... |
    + ---------------- + ------------------ + ------------- --- +
这使攻击定位在最佳情况下，以覆盖在进程时间线内较早分配的对象。以下步骤可用于定位在Row对象的前面TxO缓冲区，以覆盖其vtable。
        *使用TxO记录使大小为0x18的分配与Row对象处于同一个竞争场。
        *溢出TxO记录以覆盖FreeEntryOffset。
        *分配Row对象。这将强制覆盖的FreeEntryOffset加载到内存段中。
        *分配相同大小的另一个TxO记录，它将位于Row对象的前面。
        *将TxO记录溢出到包含Row对象的块中，以便控制其vtable。
发生这种情况后，解析最后一个EOF记录将导致Row对象的vtable可被取值，以便为Row对象调用析构函数。
        0：000> r
        eax = deadbeeb ebx = ffffffff ecx = 045d7d88 edx = 0000ffff esi = 00127040 edi = 00000000
        eip = 3f7205c7 esp = 00126fdc ebp = 00127028 iopl = 0 nv up ei pl nz na po nc
        cs = 001b ss = 0023 ds = 0023 es = 0023 fs = 003b gs = 0000 efl = 00010202
        JCXCALC！JCXCCALC_Jsfc_ExConvert + 0x9c40b：
        3f7205c7 ff5004 call dword ptr [eax + 4] ds：0023：deadbeef =
        0：000> .logclose
        0：000> dc ecx
        045d7d88 deadbeeb 64646464 64646464 64646464 dddddddddddddddd
        045d7d98 64646464 64646464 64646464 64646464 dddddddddddddddd
        045d7da8 64646464 64646464 64646464 64646464 dddddddddddddddd
        045d7db8 64646464 64646464 64646464 64646464 dddddddddddddddd
        045d7dc8 64646464 64646464 64646464 64646464 dddddddddddddddd
        045d7dd8 64646464 64646464 64646464 64646464 dddddddddddddddd
        045d7de8 64646464 64646464 64646464 64646464 dddddddddddddddd
        045d7df8 64646464 64646464 64646464 64646464 dddddddddddddddd
攻击者现在正在控制一个被调用的函数指针。