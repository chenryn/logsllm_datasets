0 ğ´â€²
1
0 ğ´â€²
1
0 ğ´â€²
1
1 ğ´â€²
1
0 ğ´â€²
2
0
0
1
0
1
0
1
1
0
1
0
1
0
1
0
1
#
1
2
3
4
5
6
7
8
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
Table 8: Truth table for the correction terms ğ‘0 and ğ‘1 in the
proof of division theorem (Appendix C).
2 ğœ†(ğœ‚ + 1) + 31ğœ‚. Concretely, we get the best
can be rewritten as < 3
communication for ğœ‚ = 32 by taking ğ‘š = 7 for the millionaire
invocations, getting a total communication of 5288 bits.
C PROOF OF DIVISION THEOREM
Here, we prove Theorem 4.1.
Proof. From Equation 2, we can write rdiv(âŸ¨ğ‘âŸ©ğ‘›
ğ‘– , ğ‘‘) as:
rdiv(âŸ¨ğ‘âŸ©ğ‘›
ğ‘– , ğ‘‘) =ğ‘› idiv(ğ‘ğ‘– âˆ’ 1{ğ‘ğ‘– â‰¥ ğ‘›â€²} Â· ğ‘›, ğ‘‘)
=ğ‘› idiv(ğ‘1
=ğ‘› ğ‘1
ğ‘– Â· ğ‘‘ + ğ‘0
ğ‘– âˆ’ 1{ğ‘ğ‘– â‰¥ ğ‘›â€²} Â· (ğ‘›1 Â· ğ‘‘ + ğ‘›0), ğ‘‘)
ğ‘– âˆ’ 1{ğ‘ğ‘– â‰¥ ğ‘›â€²} Â· ğ‘›1 + idiv(ğ‘0
ğ‘– âˆ’ 1{ğ‘ğ‘– â‰¥ ğ‘›â€²} Â· ğ‘›0, ğ‘‘),
(3)
for ğ‘– âˆˆ {0, 1}. ğ‘ğ‘¢ can be expressed as ğ‘ğ‘¢ = ğ‘0 + ğ‘1 âˆ’ ğ‘¤ Â· ğ‘›, where
the wrap-bit ğ‘¤ = 1{ğ‘0 + ğ‘1 â‰¥ ğ‘›}. We can rewrite this as:
ğ‘ğ‘¢ = ğ‘0 + ğ‘1 âˆ’ ğ‘¤ Â· ğ‘›
= (ğ‘1
= (ğ‘1
0 + ğ‘1
0 + ğ‘1
1 âˆ’ ğ‘¤ Â· ğ‘›1) Â· ğ‘‘ + (ğ‘0
0 + ğ‘0
1 âˆ’ ğ‘¤ Â· ğ‘›1 + ğ‘˜) Â· ğ‘‘ + (ğ‘0
0 + ğ‘0
1 âˆ’ ğ‘¤ Â· ğ‘›0)
0 + ğ‘0
(4)
1 âˆ’ ğ‘¤ Â· ğ‘›0 âˆ’ ğ‘˜ Â· ğ‘‘ < ğ‘‘. Similar
1 âˆ’ ğ‘¤ Â· ğ‘›0 âˆ’ ğ‘˜ Â· ğ‘‘),
for some integer ğ‘˜ such that 0 â‰¤ ğ‘0
to Equation 3 and from Equation 4, we can write rdiv(ğ‘, ğ‘‘) as:
rdiv(ğ‘, ğ‘‘) =ğ‘› ğ‘1
1 âˆ’ ğ‘¤ Â· ğ‘›0 âˆ’ ğ‘˜ Â· ğ‘‘ âˆ’ 1{ğ‘ â‰¥ ğ‘›â€²} Â· ğ‘›0, ğ‘‘)
0 + ğ‘1
+ idiv(ğ‘0
0 + ğ‘1
+ idiv(ğ‘0
1 âˆ’ ğ‘¤ Â· ğ‘›1 + ğ‘˜ âˆ’ 1{ğ‘ â‰¥ ğ‘›â€²} Â· ğ‘›1
0 + ğ‘0
1 âˆ’ ğ‘¤ Â· ğ‘›1 âˆ’ 1{ğ‘ â‰¥ ğ‘›â€²} Â· ğ‘›1
0 + ğ‘0
1 âˆ’ ğ‘¤ Â· ğ‘›0 âˆ’ 1{ğ‘ â‰¥ ğ‘›â€²} Â· ğ‘›0, ğ‘‘).
=ğ‘› ğ‘1
(5)
0 , ğ‘‘) âˆ’ rdiv(âŸ¨ğ‘âŸ©ğ‘›
From Equations 3 and 5, we have the following correction term:
ğ‘ =ğ‘› rdiv(ğ‘, ğ‘‘) âˆ’ rdiv(âŸ¨ğ‘âŸ©ğ‘›
=ğ‘› (cid:0)1{ğ‘0 â‰¥ ğ‘›â€²} + 1{ğ‘1 â‰¥ ğ‘›â€²} âˆ’ ğ‘¤ âˆ’ 1{ğ‘ â‰¥ ğ‘›â€²}(cid:1) Â· ğ‘›1
âˆ’(cid:0)idiv(ğ‘0
1 âˆ’ ğ‘¤ Â· ğ‘›0 âˆ’ 1{ğ‘ â‰¥ ğ‘›â€²} Â· ğ‘›0, ğ‘‘)
0 + ğ‘0
0 âˆ’ 1{ğ‘0 â‰¥ ğ‘›â€²} Â· ğ‘›0, ğ‘‘) + idiv(ğ‘0
1 âˆ’ 1{ğ‘1 â‰¥ ğ‘›â€²} Â· ğ‘›0, ğ‘‘)(cid:1)
+ idiv(ğ‘0
1 , ğ‘‘)
ğ‘– = idiv(ğ‘0
=ğ‘› ğ‘1 Â· ğ‘›1 + ğ‘0 âˆ’ ğµ
(7)
Let ğ´â€²
1 âˆ’ ğ‘– Â· ğ‘›0, ğ‘‘). Then the values of the correction
0 + ğ‘0
terms ğ‘1 and ğ‘0 are as summarized in Table 8.
From the table, we have ğ‘1 = corr and can rewrite the correction
term as ğ‘ =ğ‘› corr Â· ğ‘›1 + ğ‘0 âˆ’ ğµ. Thus, adding corr Â· ğ‘›1 âˆ’ ğµ mod ğ‘› to
rdiv(âŸ¨ğ‘âŸ©ğ‘›
1 , ğ‘‘) accounts for all the correction terms
except ğ‘0 mod ğ‘›.
0 , ğ‘‘) + rdiv(âŸ¨ğ‘âŸ©ğ‘›
(6)
16
0 + ğ‘0
1 and ğ´ = ğ‘0
Now all that remains to be proven is that ğ‘0 = 1 âˆ’ ğ¶. Let
ğ¶0 = 1{ğ´ < ğ‘‘}, ğ¶1 = 1{ğ´ < 0}, and ğ¶2 = 1{ğ´ < âˆ’ğ‘‘}. Then,
we have ğ¶ = ğ¶0 + ğ¶1 + ğ¶2. Note from the theorem statement that
1 âˆ’ 2 Â· ğ‘›0 for the cases corresponding to
ğ´ = ğ‘0
1 âˆ’ ğ‘›0 for
rows 1 and 8 respectively from the table, while ğ´ = ğ‘0
the rest of cases. Thus, it is easy to see that ğ‘0 = idiv(ğ´, ğ‘‘). Also
note that âˆ’2 Â· ğ‘‘ + 2 â‰¤ ğ´ â‰¤ 2 Â· ğ‘‘ âˆ’ 2, implying that the range of ğ‘0 is
{âˆ’2,âˆ’1, 0, 1}. Now we look at each value assumed by ğ‘0 separately
as follows:
0 + ğ‘0
0 + ğ‘0
â€¢ ğ‘0 = âˆ’2: In this case, we have (ğ´ < âˆ’ğ‘‘), implying ğ¶0 = ğ¶1 =
ğ¶2 = 1, and 1 âˆ’ ğ¶ = âˆ’2.
â€¢ ğ‘0 = âˆ’1: In this case, we have (âˆ’ğ‘‘ â‰¤ ğ´ < 0), implying
ğ¶0 = ğ¶1 = 1, ğ¶2 = 0 and 1 âˆ’ ğ¶ = âˆ’1.
â€¢ ğ‘0 = 0: In this case, we have (0 â‰¤ ğ´ < ğ‘‘), implying ğ¶0 =
1, ğ¶1 = ğ¶2 = 0 and 1 âˆ’ ğ¶ = 0.
â€¢ ğ‘0 = 1: In this case, we have (ğ‘‘ â‰¤ ğ´), implying ğ¶0 = ğ¶1 =
ğ¶2 = 0 and 1 âˆ’ ğ¶ = 1.
0 , ğ‘‘) âˆ’
1 , ğ‘‘).
â–¡
Thus, ğ‘ =ğ‘› corr Â· ğ‘›1 + (1 âˆ’ ğ¶) âˆ’ ğµ =ğ‘› rdiv(ğ‘, ğ‘‘) âˆ’ rdiv(âŸ¨ğ‘âŸ©ğ‘›
rdiv(âŸ¨ğ‘âŸ©ğ‘›
D PROTOCOL FOR GENERAL DIVISION
0 , âŸ¨ğ›¼âŸ©ğµ
0 , âŸ¨corrâŸ©ğ¿
We describe our protocol for general division formally in Al-
gorithm 9. As discussed in Section 4.2.2, our protocol builds on
Theorem 4.1 and we compute the various sub-terms securely us-
ing our new protocols. Let ğ›¿ = âŒˆlog 6ğ‘‘âŒ‰. We compute the shares
of corr over both Zğ‘› and ZÎ” (Step 15). We write the term ğ¶ as
(DReLU(ğ´ âˆ’ ğ‘‘) âŠ• 1) + (DReLU(ğ´) âŠ• 1) + (DReLU(ğ´ + ğ‘‘) âŠ• 1),
which can be computed using three calls to F int,ğ›¿
DReLU (Step 19) and
F ğ‘›
B2A (Step 20) each.
1 ) =
Correctness and Security. First, ğ‘š = Reconstğµ(âŸ¨ğ‘šâŸ©ğµ
1 ) = 1{ğ‘ â‰¥ ğ‘›â€²}. Next, similar to Algorithm 5,
Reconstğµ(âŸ¨ğ›¼âŸ©ğµ
1 ),
0 , âŸ¨corrâŸ©Î”
Reconstğ¿(âŸ¨corrâŸ©ğ¿
where corr is as defined in Theorem 4.1. Given the bounds on
value of ğ´ (as discussed above), it easy to see that Steps 16&17
compute arithmetic shares of ğ´, and ğ´0 = (ğ´ âˆ’ ğ‘‘), ğ´1 = ğ´, ğ´2 =
(ğ´ + ğ‘‘), respectively. Now, invocation of F int,ğ›¿
DReLU on shares of ğ´ğ‘—
(Step 19) returns boolean shares of ğ›¾ = (1 âŠ• MSB(ğ´ğ‘—)) over ğ›¿ bit
integers, which is same as 1 âŠ• 1{ğ´ğ‘— < 0} over Z. Hence, ğ¶â€²
ğ‘— =
Reconstğµ(âŸ¨ğ¶â€²
0 , âŸ¨ğ¶â€²âŸ©ğµ
1 ) = 1{ğ´ğ‘— < 0}. By correctness of F ğ‘›
ğ‘—âŸ©ğµ
B2A,
step 22 computes arithmetic shares of ğ¶ as defined in Theorem 4.1.
In step 23, ğµ0 + ğµ1 =ğ‘› ğµ as defined. Hence, correctness holds and
âŸ¨ğ‘§âŸ©ğ‘›
0 , âŸ¨ğ‘šâŸ©ğµ
1 ) = corr = ReconstÎ”(âŸ¨corrâŸ©Î”
of the protocol is easy to see in ((cid:0)4
and(cid:0)4
bits.(cid:0)4
(cid:1)-OTğœ‚+ğ›¿, F int,ğ›¿
(cid:1)-OTğœ‚+ğ›¿, and three calls each to F int,ğ›¿
(cid:1)-OTğœ‚+ğ›¿ and 3 Ã— F ğ‘›
0 and âŸ¨corrâŸ©Î”
0 are uniformly random, security
B2A)-hybrid.
, F ğ‘›
1
involves a single call to F ring,ğ‘›
Communication complexity. Î ring,ğ‘›,ğ‘‘
DReLU
B2A. From
2 âˆ’ 13
DReLU as 3
B2A cost 2ğœ† + 4 Â· (ğœ‚ + ğ›¿) and 3ğœ† + 3ğœ‚ bits
DReLU is ğœ†â„“ + 13 1
2 bits
DReLU requires 3ğœ†ğ›¿ + 40 1
2 bits
respectively. Since the cost of F int,â„“
(see Appendix B), 3 Ã— F int,ğ›¿
2 ğœ†ğœ‚ + 27ğœ‚ âˆ’ ğœ†
2 â„“ âˆ’ 3ğœ† âˆ’ 35 1
2ğ›¿ âˆ’ 9ğœ† âˆ’ 106 1
ğ‘ are shares of rdiv(ğ‘, ğ‘‘).
Given that âŸ¨corrâŸ©ğ‘›
Appendix B, we have the cost of F ring,ğ‘›
DReLU and F ğ‘›
DReLU
DIV
1
1
ğ‘— = ( ğ‘—0|| ğ‘—1).
ğ‘ƒ0 computes ğ‘¡ ğ‘— = (âŸ¨ğ‘šâŸ©ğµ
if ğ‘¡ ğ‘— âˆ§ 1{ğ‘¥0 = 0} then
ğ‘ƒ0 sets ğ‘  ğ‘— =ğ‘› âˆ’âŸ¨corrâŸ©ğ‘›
else if ğ‘¡ ğ‘— âˆ§ 1{ğ‘¥0 = 1} then
ğ‘ƒ0 sets ğ‘  ğ‘— =ğ‘› âˆ’âŸ¨corrâŸ©ğ‘›
else
ğ‘ƒ0 sets ğ‘  ğ‘— =ğ‘› âˆ’âŸ¨corrâŸ©ğ‘›
7:
8:
9:
10:
11:
12:
13:
14: end for
0 âˆ’ 1 and ğ‘Ÿ ğ‘— =Î” âˆ’âŸ¨corrâŸ©Î”
0 + 1 and ğ‘Ÿ ğ‘— =Î” âˆ’âŸ¨corrâŸ©Î”
0 and ğ‘Ÿ ğ‘— =Î” âˆ’âŸ¨corrâŸ©Î”
0 .
0 âˆ’ 1.
0 + 1.
Algorithm 9 Integer ring division, Î ring,ğ‘›,ğ‘‘
Input: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ holds âŸ¨ğ‘âŸ©ğ‘›
Output: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ learns âŸ¨ğ‘§âŸ©ğ‘›
1: For ğ‘ âˆˆ {0, 1}, let ğ‘ğ‘, ğ‘0
DIV
:
ğ‘ , where ğ‘ âˆˆ Zğ‘›.
ğ‘ s.t. ğ‘§ = rdiv(ğ‘, ğ‘‘).
ğ‘ âˆˆ Z and ğ‘›0, ğ‘›1, ğ‘›â€² âˆˆ Z be as defined
, ğ‘1
ğ‘
in Theorem 4.1. Let ğœ‚ = âŒˆlog(ğ‘›)âŒ‰, ğ›¿ = âŒˆlog 6ğ‘‘âŒ‰, and Î” = 2ğ›¿.
output âŸ¨ğ›¼âŸ©ğµ
2: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ invokes F ring,ğ‘›
ğ‘ . Party ğ‘ƒğ‘ sets âŸ¨ğ‘šâŸ©ğµ
3: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ sets ğ‘¥ğ‘ = 1{âŸ¨ğ‘âŸ©ğ‘›
4: ğ‘ƒ0 samples âŸ¨corrâŸ©ğ‘›
0
5: for ğ‘— = {00, 01, 10, 11} do
6:
DReLU with input âŸ¨ğ‘âŸ©ğ‘›
ğ‘ = âŸ¨ğ›¼âŸ©ğµ
ğ‘ â‰¥ ğ‘›â€²}.
$â† Zğ‘› and âŸ¨corrâŸ©Î”
0
ğ‘ âŠ• ğ‘.
$â† ZÎ”.
0 âŠ• ğ‘—0 âŠ• ğ‘¥0) âˆ§ (âŸ¨ğ‘šâŸ©ğµ