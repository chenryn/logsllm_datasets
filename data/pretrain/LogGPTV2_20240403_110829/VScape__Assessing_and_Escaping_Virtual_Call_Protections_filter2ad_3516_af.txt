must exceed 128 bytes. Thus, to meet the requirements for
heap layouts, we can only select victim classes in a primitive
database whose size is big enough.
Primitive in Exploit. According to above, we order
VScape with several rules (1) the size of victim class ex-
ceed 128, (2) the offset of victim member variable off mod
8 > 1 (Hi address byte) and (3) the primitive has capa-
bilities of St-nonPtr. The number of matched candidate
UVC is 71. And 12 of them are triggered in reachabil-
ity tests. Then, the primitive tuple that we select is (An-
imation::UpdateTiming(), Animation, CSSAnimation)
in the namespace of mozilla::dom.
Before composing a real exploit, we emulate a PC hijack
toward the counterfeit virtual function, and implement sym-
bolic execution by Angr, to assess whether the target instruc-
tion is reachable in the assumption that the memory of re-
lay objects is controllable. In this case, the instruction for
OOB-Writing only executes when a variable named mNeed-
sNewAnimationIndexWhenRun is not null, which is exactly
an overwritten variable in the relay object. And the condition
does not conﬂict with the supposed gadget who is going to
zero the boolean type variable.
Speciﬁcally, Firefox provides Web Animation APIs for
users to describe animations on DOM elements. When
we declare animation conﬁg with javascript code, corre-
USENIX Association
30th USENIX Security Symposium    1729
1,662840220162,27996918312#UVC-CVF#UVC-OVF#UVC-Reachable#UVC-QualifiedChosenPrimitive01,0002,0003,0004,0005,0006,000#UVCs of PyQt#UVCs of FirefoxS1S2S3S4508,1412299657183,786166548121101001,00010,000100,0001,000,000Primitives of PyQtPrimitives of FirefoxS2:UVCreachabilitytestS4:InstreachabilitysolveS3:VulnerabilitymatchingS1:Primitivesearch#UVC-CVFChosenprimitiveploits the defect in detail design of IFCC and VTV [6] to
realize successful hijack in Chrome.
Recently proposed CFI solutions (e.g., pCFI [61], OS-
CFI [2] and µCFI [8]) utilize runtime context information
to reduce the size of EC, providing better defenses against
these attacks. These solutions provide data ﬂow integrity to
a certain extent, but in general, are hard to deploy in practice.
COOP [5] ﬁrst used counterfeit objects to enable Turing-
complete malicious computations. But it is wrongly declared
that COOP can only circumvent CFI solutions that are not
aware of C++ semantic. Instead, one variant of COOP, i.e.,
COOPLUS, is able to bypass virtual call protections that are
C++ semantics aware but neither break the C++ ABI nor pro-
tect the integrity of vptr, even when only weak vulnerabili-
ties are given.
6.2 Automated Exploit Generation
Automated exploit generation (AEG) can be used to assess
the exploitability of vulnerability by generating an exploit.
Since David et al. proposed automatic patch-based exploit
generation (APEG) [76], AEG [9–11, 16, 77] has become a
research focus in recent years.
Representative techniques
include AEG [9], May-
hem [10], Q [14] and CRAX [15]. These AEG solutions
share a similar workﬂow.
In general, they will ﬁrst ana-
lyze vulnerabilities in detail along with a crashing path, then
search for exploitable states, collect vulnerability and exploit
constraints respectively, and ﬁnally generate exploit inputs.
Repel [78] shows examples to exploit heap-based vulnera-
bilities with symbolic executions starting from crash points.
PRIMGEN [79] automatically counterfeits fake objects to
obtain exploit primitives in Web browsers. A key limita-
tion in these AEG solutions is that they only focus on ana-
lyzing one single program state in crashing paths. Recently,
FUZE [80] and Revery [11] use fuzzing to explore more ex-
ploitable states. Note that, all such solutions are not fully
automated, and still require expert knowledge or annotations.
Gollum [12] ﬁrst completes an end-to-end AEG system from
primitive extraction to heap layout inference in user space.
Another key challenge is heap layout manipulation.
ARCHEAP [81] presents an automatic tool to systematically
discover the unexplored heap exploitation primitives for spe-
ciﬁc heap allocators. RELAY [82] simulates human exploita-
tion behavior for metadata corruption and solves layout prob-
lems according to the exploit pattern. And HEAPG [83] au-
tomates multi-hop exploitation for heap-based vulnerability
via known techniques of ptmalloc. These three studies help
synthesize exploits in CTF challenges but do not help much
when composing a heap-based exploit in real world.
Gollum [12] applies a genetic algorithm to solve this prob-
lem and accelerates the performance of the random search
algorithm proposed in SHRIKE [38]. Another work SLAKE
[37] extracts heap operations and obtains desired slab layouts
based on the speciﬁc knowledge of kernel heap allocator.
Figure 9: COOPLUS exploit primitives for Firefox.
1 vulnerable object - ﬂoat list 2 victim object - mozilla::
dom::Animation 3 relay object - item list of ArrayObject.
sponding Animation objects will be allocated on jemal-
loc heap during page rendering. CSSAnimation is a sub
class of Animation, the counterfeit function CSSAnima-
tion::UpdateTiming() tries to zero the boolean variable
mNeedsNewAnimationIndexWhenRun.
Exploit Synthesis. The object size of Animation is 256
bytes. Thus, such objects will only be found in runs for 256
bytes. To create the required heap layout, the vulnerable ob-
ject (ﬂoat list) and the relay object (data list for ArrayOb-
ject) are all modiﬁed into the same size.
As shown in Figure 9, after triggering the counterfeit func-
tion, we can tamper with the NaN-boxing pointer of Ar-
rayObject’s item. When the pointer is redirected toward
controllable memory, we use a counterfeit JSStringObject
to get AAR. Then with similar technique, replacing coun-
terfeit JSStringObject with a counterfeit TypedArrayOb-
ject, AAW is as well achieved.
6 Related Work
6.1 CFI-Oriented Attacks
Researchers have proposed a number of practical yet impre-
cise CFI solutions. Although these coarse-grained CFI so-
lutions can signiﬁcantly reduce the attack surface, multiple
attacks [72–74] have been proposed to bypass these CFI so-
lutions, by exploiting the fact that the size of equivalence
class (EC) for each ICT is still large.
To defeat attacks against coarse-grained CFI solutions, re-
searchers also proposed ﬁne-grained CFI solutions. How-
ever, as sound and complete pointer analysis is unfortunately
undecidable, ﬁne-grained CFI solutions rely on sound but in-
complete pointer analysis in practice, providing conservative
over-approximate results and enabling potential attacks. For
example, Control Jujutsu [75] shows that common software
engineering practices force points-to analysis to merge sev-
eral equivalence classes. Imprecise ECs are large enough for
arbitrary computation, to enable an attacker to execute arbi-
trary malicious code even when ﬁne-grained CFI is enforced.
Control-Flow Bending [27] goes one step further and shows
that CFI solutions with ideal point-to analysis results are still
vulnerable. Some other attacks target implementations of
speciﬁc CFI solutions. For example, StackDeﬁler [28] ex-
1730    30th USENIX Security Symposium
USENIX Association
0xfffe0aca122351e0(1)MemorylayoutbeforeCOOPLUSattack①②③JSStringObjectDatapointerDataFieldControllablememoryArbitraryaddress0xfffe0aca120051e0CounterfeitptrSensitivedataStrings…vptrCounterfeitvptr(2)MemorylayoutafterCOOPLUSattack……Although some of AEG solutions show their effectiveness
in real applications, none of them have taken modern de-
fenses into consideration. For instance, Revery [11] and Gol-
lum [12]) focusing on exploiting heap vulnerabilities only
works well when the defense ASLR [13] is disabled. AEG
solutions targeting stack-based buffer overﬂow, e.g., Q [14],
CRAX [15] and PolyAEG [16], cannot bypass stack ca-
nary [17]. Compared with these AEG solutions, VScape is
able to generate exploits to bypass virtual call protections
and evaluate COOPLUS with real CVE cases.
DOP attacks. A generalized form of data-only attacks is
Data Oriented Programming (DOP) [84]. Since DOP does
not tamper with control ﬂow, it is outside the scope of most
CFI solutions. Data Flow Integrity (i.e., [21, 22]) is a pop-
ular defense against DOP. The work [85] has developed a
semi-automated framework to search for DOP gadgets. By
assuming AAR and AAW capability, BOPC [34] further au-
tomatically generates DOP exploit payloads. However, in
practice, how to get AAR and AAW capability in practice,
especially when the target is fully protected, is not addressed
in previous solutions.
In contrast, COOPLUS is a CFI-oriented attack. Given a
weak vulnerability, VScape is committed to building AAR
and AAW primitives under modern defenses.
7 Discussion
Potential Mitigations. Given the preconditions of the
COOPLUS, there are two ways to protect applications from
this attack, including: (1) separating vptr from writable and
vulnerable heap objects, e.g., by putting them in a separate
protected memory region; and (2) protecting the integrity of
vptr, e.g., by applying DFI to block illegal writes to vptr.
The ﬁrst type of defense will break the C++ ABI, as
shown in CFIXX [24]. Thus, such defenses are not prac-
tical. Proper mitigation would be protecting the integrity
of vptr. However, traditional data-ﬂow integrity solutions
(e.g., [21, 22]) in general have high performance overheads,
which also prohibit the adoption.
Instead, we think applicable mitigation is a combination
of type-based and context-sensitive CFI solutions, which
could provide similar protection as data ﬂow integrity. As
shown in our experiment, the context-sensitive CFI solution
µCFI [8] successfully protects the benchmark code [67] from
COOPLUS with precise runtime information. But µCFI re-
quires Intel PT and works on a customized kernel, making
it hard to deploy in practice. By contrast, type-based CFI
solutions are popular and take less effort in implementation
and deployment. Thus, for a perfect defense, it is necessary
to measure the size of overridden virtual functions for each
virtual call site. For a virtual call with only one candidate vir-
tual function implementation, a type-based check is enough
to ensure the control-ﬂow integrity. But for virtual calls hav-
ing more than one compatible function, the context informa-
tion (e.g., the origin of objects) should be considered.
But there are some challenges to address, in order to ef-
ﬁciently track context information without causing compat-
ibility issues. CFI-LB [62] uses call stack to represent the
context, is able to reduce the size of EC, but still leaves mul-
tiple valid targets. OS-CFI [2] utilizes the origin sensitivity
to divide the targets of each ICT into the smallest sets, how-
ever, has severe compatibility issues [32]. These challenges
are left as future work.
Limitations of VScape.
Same to other state-of-the-
art AEG researches (i,e, Gollum [12], Revery [11] and
BOPC [34],), VScape is also not fully automated.
It still
greatly depends on exploit templates to prepare for the
prospective exploit routine. There are still several open chal-
lenges to address, including but not only limited to (1) auto-
mated heap layout manipulation, especially in a heap man-
ager with a garbage collector, (2) generating exploits for
complicated and large applications (such as browsers), and
(3) requiring expert knowledge (e.g., exploiting strategies) to
compose multi-step exploits. These challenges greatly limit
the availability of these AEG tools, including VScape.
Practicality of COOPLUS. For C++ applications utiliz-
ing virtual functions, the COOPLUS attack surface is large,
as shown in Table 1. As proved by the examples in Firefox
and PyQt, this attack is feasible in real world targets. We
believe this type of attack is general and realistic. However,
we cannot guarantee this type of attack will always succeed.
The key factor affecting the success rate is the number of
available exploit primitives existed in target applications.
8 Conclusions
In this paper, we propose an advanced attack COOPLUS, and
present a solution VScape to assess the effectiveness of vir-
tual calls defenses against this attack. COOPLUS is a code
reuse attack that is able to bypass every virtual call protec-
tion as long as it (1) does not break the ABI of virtual calls,
(2) cannot guarantee the integrity of C++ objects’ VTable
pointers, and (3) allow multiple runtime targets at virtual call
sites. Following the principle of COOPLUS, our solution
VScape analyzes target applications and compiles proper ex-
ploit primitives for generating ﬁnal exploits, to assess the ef-
fectiveness of target defenses. We evaluated VScape on C++
applications with known vulnerabilities. Results showed that
real-world applications have a large set of exploitable virtual
calls, and VScape could be utilized to generate working ex-
ploits to bypass virtual call protections with weak vulnera-
bilities. We concluded that, to fully mitigate COOPLUS in
practice, we have to protect the integrity of vptr with a low
performance overhead and good compatibility.
Acknowledgement
This work was supported in part by National Natu-
ral Science Foundation of China under Grant 61772308,
USENIX Association
30th USENIX Security Symposium    1731
61972224, U1736209 and U1836112, and BNRist Net-
work and Software Security Research Program under Grant
BNR2019TD01004 and BNR2019RC01009.
References
[1] M. MartnAbadi and J. L. ÚlfarErlingsson, “Control ﬂow integrity:
Principles, implementations, and applications.” in Proceedings of the
12th ACM Conference on Computer and Communications Security,
Alexandria, Virginia, 2005, pp. 340–353.
[2] M. R. Khandaker, W. Liu, A. Naser, Z. Wang, and J. Yang, “Origin-
sensitive control ﬂow integrity.” in 28th USENIX Security Symposium
(USENIX Security 19), 2019, pp. 195–211.
[3] M. Zhang and R. Sekar, “Control ﬂow integrity for cots binaries.” in
Presented as part of the 22nd USENIX Security Symposium (USENIX
Security 13), 2013, pp. 337–352.
[4] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant,
D. Song, and W. Zou, “Practical control ﬂow integrity and random-
ization for binary executables.” in 2013 IEEE Symposium on Security
and Privacy.
IEEE, 2013, pp. 559–573.
[5] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, and
T. Holz, “Counterfeit object-oriented programming: On the difﬁculty
of preventing code reuse attacks in c++ applications.” in 2015 IEEE
Symposium on Security and Privacy.
IEEE, pp. 745–762. [Online].
Available: https://ieeexplore.ieee.org/document/7163058/
[6] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway, Ú. Erlingsson,
L. Lozano, and G. Pike, “Enforcing forward-edge control-ﬂow in-
tegrity in gcc & llvm.” in 23rd USENIX Security Symposium (USENIX
Security 14), 2014, pp. 941–955.
[7] C. Zhang, D. Song, S. A. Carr, M. Payer, T. Li, Y. Ding, and C. Song,
“Vtrust: Regaining trust on virtual calls.” in NDSS, 2016.
[8] H. Hu, C. Qian, C. Yagemann, S. P. H. Chung, W. R. Harris, T. Kim,
and W. Lee, “Enforcing unique code target property for control-ﬂow
integrity.” in Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security. ACM, 2018, pp. 1470–
1486.
[9] T. Avgerinos, S. K. Cha, B. Lim, T. Hao, and D. Brumley., “Aeg:
Automatic exploit generation,” 2011.
[10] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley, “Unleashing
mayhem on binary code.” in Security and Privacy (SP), 2012 IEEE
Symposium on.
IEEE, 2012, pp. 380–394.
[11] Y. Wang, C. Zhang, X. Xiang, Z. Zhao, W. Li, X. Gong, B. Liu,
K. Chen, and W. Zou, “Revery: From proof-of-concept
to ex-
ploitable.” in Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security. ACM, 2018, pp. 1914–
1927.
[12] S. Heelan, T. Melham, and D. Kroening, “Gollum: Modular and grey-
box exploit generation for heap overﬂows in interpreters.” in Proceed-
ings of the 2019 ACM SIGSAC Conference on Computer and Commu-
nications Security. ACM, 2019, pp. 1689–1706.
[13] PaX-Team, “PaX ASLR (Address Space Layout Randomization),”
http://pax.grsecurity.net/docs/aslr.txt, 2003.
[14] E. J. Schwartz, T. Avgerinos, and D. Brumley, “Q: Exploit hardening
made easy.” in USENIX Security Symposium, 2011, pp. 25–41.
[15] S.-K. Huang, M.-H. Huang, P.-Y. Huang, C.-W. Lai, H.-L. Lu, and
W.-M. Leong, “Crax: Software crash analysis for automatic exploit
generation by modeling attacks as symbolic continuations.” in Soft-
ware Security and Reliability (SERE), 2012 IEEE Sixth International
Conference on.
IEEE, 2012, pp. 78–87.
[16] M. Wang, P. Su, Q. Li, L. Ying, Y. Yang, and D. Feng, “Automatic
polymorphic exploit generation for software vulnerabilities.” in Inter-
national Conference on Security and Privacy in Communication Sys-
tems. Springer, 2013, pp. 216–233.