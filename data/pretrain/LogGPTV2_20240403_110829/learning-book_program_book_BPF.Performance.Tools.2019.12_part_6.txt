C
+
---
## Page 49
12
Chapter 1 Introduction
The columns are process ID (PID), process command name (COMM),file descriptor (FD),error
code (ERR), and the path of the file that the syscall attempted to open (PATH). The opensnoop.bt
tool can be used to troubleshoot failing software, which may be attempting to open files from the
wrong path, as well as to determine where config and log files are kept, based on their accesses. It
can also identify some performance issues, such as files being opened too quickly, or the wrong
locations being checked too frequently. It is a tool with many uses.
bpftrace ships with more than 20 such ready-to-run tools, and BCC ships with more than 70. In
addlition to helping you solve problems directly, these tools provide source code that shows how
various targets can be traced. Sometimes there are gotchas, as we saw with tracing the open(2)
syscall, and their source code may show solutions to these.
1.9
BacktoBCC:Tracingopen()
Now let's look at the BCC version of opensnoop(8):
doousuedo 1
PID
COMK
FD ERR PATH
2262
DNS Res~er 65T
2.2
0 /etc/hosts
2262
DNS Res-er 654
178
0 /etc/hosts
2958B
device po11
4
qgsn/sng/nep/ 0
29588
device po11
6
0 /dev/bus/usb/004
29588
device po11
0 /dev/bus/usb/004/001
Ttod ataap 88567
6 0/dev/bus/usb/003
°C
+
The output here looks very similar to the output of the earlier one-linerat least it has the same
columns. But this opensnoop(8) output has something that the bpftrace version does not: It can
be invoked with different command line options:
q- doousuedo 
usage: apensnoop[h] [-T] [=×][=p PID][=t TED] [=d DURATIoN] [=n SAME]
[e] [-f FLAG_FILTER]
Trace open() syscalls
optional arguments:
deu--*-
shov this help ressage and exit
-T, --timestanp
include timestanp on output
x, --failed
only shox falled opens
-p PID, --pid PID
trace this PID only
-t TID,
 --t1d 7I0
trace this TID only
-d DURATI08, -=duration DURAT10N
total duzation of trace in seconds
---
## Page 50
1.9  Back to BCC: Tracing open()
13
-n NAME, -=nane MAME only print process nanes contasining this nane
-e, -=extended_fle1ds
shov extended fields
-f FLAC_FILTER, --f1ag_11tex FLAG_FILTER
filter on flags argument leg-, 0_WRoNLY)
exanples1
/opensnoop
# trace all open(1 syscalls
- doousuado/*
include timestanps
/opensnoop =x
only show falled opens
Tet d- doousuado/
 only trace PID 181
 /opensnoop
 -t 123
 only trace TID 123
./opensnoop -d 10
 trace for 10 seconds only
/opensnoop -n naIn
# only print process nanes contalning *nain*
a- doousuado/*
shov extended fields
/opensnoop -f o_MRoNLY -f o_RDKR # only print calls foz vziting
While bpftrace tools are typically simple and do one thing, BCC tools are typically complex and
support a variety of modes of operation. While you could moxdify the bpftrace tool to only show
failed opens, the BCC version already supports that as an option (x):
 opensnoop -x
PID
COMX
FD ERR PATH
991
Irqbalance
-1
tuTgzeds/Ect/bxt/ooxdl/ z
991
1rqbalance
2 /proc/irq/141/smp_affin.ity
991
1rqbalance
-1 
2 /pzoc/1rq/131/smp_afrin.ity
991
irqbalance
-1 
2 /proc/irq/138/smp_affin.ity
991
Irgbalance
1 
2 /pzoc/1rq/18/snp_afrin1ty
20543 systend-resolve
2 /run/systend/netif/1inks/5
20543
systend-resolve
-1
2 /run/systend/net1c/1inks/5
20543
systend-resolve
2 /run/systend/netif/Links/5
[..-]
This output shows repeated failures. Such patterns may point to inefficiencies or
misconfigurations that can be fixed.
BCC tools often have several such options for changing their behavior, making them more
versatile than bpftrace tools. This makes them a good starting point: hopefully they can solve
your needs without you needing to write any BPF code. If, however, they do lack the visibility
you need, you can then switch to bpftrace and create custom tools, as it is an easier language to
develop.
---
## Page 51
14
Chapter 1 Introduction
A bpftrace tool can later be converted to a more complex BCC tool that supports a variety of
options, like opensnoop(8) shown previously. BCC tools can also support using different events:
using tracepoints when available, and switching to kprobes when not. But be aware that BCC
programming is far more complex and is beyond the scope of this book, which focuses on
bpftrace programming. Appendix C provides a crash course in BCC tool development.
1.10Summary
BPF tracing tools can be used for performance analysis and troubleshooting, and there are two
main projects that provide them: BCC and bpftrace. This chapter introduced extended BPF, BCC,
bpftrace, and the dynamic and static instrumentation that they use.
The next chapter dives into these technologies in much more detail. If you are in a hurry to solve
issues, you might want to skip Chapter 2 for now and move on to Chapter 3 or a later chapter
explainedl in Chapter 2, but they are also summarized in the Glossary.
that covers the topic of interest. These later chapters make heavy use of terms, many of which are
---
## Page 52
Chapter:
Technology Background
Chapter 1 introduced various technologies used by BPF performance tools. This chapter explains
them in more detail: their histories, interfaces, internals, and use with BPE
This is the most technically deep chapter in the book, and for the sake of brevity, it assumes some
knowledge of kernel internals and instruction-level programming.*
The learning objectives are not to memorize every page in this chapter, but for you to:
•Know the origins of BPF, and the role of extended BPF today
Understand frame pointer stack walking and other techniques
• Understand how to read flame graphs
Understand the use of kprobes and uprobes, and be familiar with their stability caveats
● Understand the role of tracepoints, USDT probes, and dynamic USDT
 Be aware of PMCs and their use with BPF tracing tools
• Be aware of future developments: BTF other BPF stack walkers
Understanding this chapter will improve your comprehension of later content in this book,
but you may prefer to skim through this chapter now and return to it for more detail as needed.
Chapter 3 will get you started on using BPF tools to find performance wins.
2.1BPFIllustrated
Figure 2-1 shows many of the technologies in this chapter and their relationships to each other.
1. To lesm necessary ke
nory, and VFS, such as [Gregg 1.3b]
---
## Page 53
16
Chapter 2 Technology Background
User
Kernel
Static tracing
BPF Tool
BTF
Sockets
Tracepoints
BPF
BPF
program
bytecode
User Markers
Dynamic tracing
Event config
kprobes
Per-event data
perf buff
uprobes
Output
4
Statistics, stacks
Maps
s
Sampling, PMCs
perf_events
Figure 2-1 BPF tracing technologies
2.2
BPF
a, saded z66t au u paquosap s pue tuasis Suesado sg aq rog padopasap Aeu3uo sem dd
BSD Packet Filter: A New Architecture for User-level Packet Capture* [McCanne 92]. This paper was
presented at the 1993 USENIX Winter conference in San Diego, alongside *Measurement, Analysis,
and Improvement of UDP/IP Throughput for the DECstation S000° [7]. DECstations are long gone,
but BPF has survived as the industry standard solution for packet filtering.
BPF works in an interesting way: A filter expresion is defined by the end user using an instruction
set for a BPF virtual machine sometimes called the BPF bytecode and then passed to the kernel
for execution by an interpreter. This allows filtering to occur in the kernel level without costly
copies of each packet going to the user-level processes, improving the performance of packet
filtering, as used by tcpdump(8). It also provides safety, as filters from user space can be verified as
being safe before execution. Given that early packet filtering had to occur in kernel space, safety
was a hard requirement. Figure 2-2 shows how this works.
User
Kernel
Filter instructions
All packets
Network
Output
tcpdump
BPF
Devices
Filtered packets
Figure 2-2 tcpdump and BPF
---
## Page 54
2.3 Extended BPF (eBPF)
17
You can use the -d option to tcpdump(8) to print out the BPF instructions it is using for the filter
expression. For example:
 topdurp
 -d host 127.0.0.1 and port 80
(000) 1dh
[12]
(001)jeg
0x800
jt 2
jf 18
(002)
1d
[26]
(003)
jeg
+0x7f000001
t 6
f 4
(004)
1d
[30]
(005)
jeg
+0x7f000001
jt 6
jf 18
(006)
1db
[23]
(L00)
jeq
+0x84
t 10
jf 8
(800)
jeq
#0×5
jt 10
jf 9
(009)
jeg
+0x11
jt 10
jf 18
(010)
1dh
[20]
(011)
jset
+0x1fff
jt 18
jf 12
(012)
1dxb
4* ([14| s0x)
(013) 1dh
[x + 14]
(014)[eg
#0x50
t 17
f 15
(015) 1dh
[x + 16]
(016)
#0x50
jt 17
f18
(017)ret
262144
183 (810)
#0
The original BPF, now referred to as “classic BPF,* was a limited virtual machine. It had two regis-
ters, a scratch memory store consisting of 16 memory slots, and a program counter. These were all
operating with a 32-bit register size.² Classic BPF arrived in Linux in 1997, for the 2.1.75 kernel [8].
Since the axddlition of BPF to the Linux kernel, there have been some important improvements.
Eric Dumazet added a BPF just-in-time (JIT) compiler in Linux 3.0, released in July 2011 [9],
improving performance over the interpreter. In 2012, Will Drewry added BPF filters for seccomp
(secure computing) syscall policies [10]; this was the first use of BPF outside of networking, and it
showed the potential for BPF to be used as a generic execution engine.
2.3ExtendedBPF(eBPF)
Extended BPF was created by Alexei Starovoitov while he worked at PLUMgrid, as the company
was investigating new ways to create software-defined networking solutions. This would be the
first major update to BPF in 20 years, and one that would extend BPF to become a general-purpose
virtual machine. While it was still a proposal, Daniel Borkmann, a kernel engineer at Red Hat,
2 For classic BPF on a 64bit keel, addresses are 64bit, but the registers only ever see 32bit data, and the loads are
hidden behind some extermal kemel helper functions.
3 While BPF is often called a virtual machine, that only describes its specification. Its implementation in Linux (its
runtime) has an interpreter and a JITto-native code compllec. The term virtual machine may imply that there is another
machine layer on top of the processor, but there isnt. Wih JIT ompled code, instructions run directly on the processor
just like any other native kernel code. Note that after the Spectre vulnerability, some distributions unconditionally enable
the JIT for x86, which removes the interpreter entirely (as it gets complled out).
---
## Page 55
1.8
Chapter 2 Technology Background
helped rework it for inclusion in the kernel and as a replacement for the existing BPE:* This
extended BPF was successfully included and has since had contributions from many other
developers (see the Acknowledgments).
Extended BPF added more registers, switched from 32-bit to 64-bit words, created flexible BPF
*mapa storage, and allowed calls to some restricted kernel functions.° It was also designed to
be JTed with a one-to-one mapping to native instructions and registers, allowing prior native
instruction optimization techniques to be reused for BPE The BPF verifier was also updated to
handle these extensions and reject any unsafe code.
Table 2-1 shows the differences between classic BPF and extended BPF
Table 2-1 Classic BPF Versus Extended BPF
Factor
Classic BPF
Extended BPF
Register count
2: A, X
10: R0R9, plus R10 as a read-only
frame pointer
Register width
32-bit
64-bit
Storage
16 memory slots: M[015]
51.2 bytes of stack space, plus infinite
*map* storage
Restricted kemel calls
Very limited, JIT specific
Yes, via the bpf_callinstruction
Event targets
Packets, seccomp-BPF
Packets, kernel functions, user functions,
tracepoints, user markers, PMCs
Alexei’s original proposal was a patchset in September 2013 titled *extended BPF* [2]. By
December 2013, Alexei was already proposing its use for tracing filters [11]. After discussion and
development with Daniel, the patches began to merge in the Linux kernel by March 2014 [3][12].°
The JIT components were merged for the Linux 3.15 release in June 2014, and the bpf(2) syscall for
the Linux 4.x series added BPF support for kprobes, uprobes, tracepoints, and perf_events.
controlling BPF was merged for the Linux 3.18 release in December 2014 [13]. Later additions in
In the earliest patchsets, the technology was abbreviated as eBPF, but Alexei later switched to
calling it just BPE. All BPF development on the net-dev mailing list [14] now refers to it as just BPE
4 Alesei and Daniel have since changed companies. They are also currently the kemel *maintainers° for BPF: a role
where they provide leadership, review patches, and decide what gets included.
5 Without needing to overload instructions, a workaround used with classic BPF that was complicated as every JIT
needed to be changed to handle it.
6 Early on, t as also calld ntemal BPF* efore It was expesed va he bp(2) syscalL Since BPF was aneoring
technology, these patches were sent to and accepted by the netorking maintainer David S. Miler. Today, BPF has grown
[auax pxsudq pue jdq umo aoug opul pafiaw aue supped paqeard8 le pue rumo syI jo kqjunuawoo suax aie e oqu]
trees. Tradition is steady that BPF tree pullrequests are stil accepted by David S. Miler.
7 1 also suggested to Alexei that we come up with a diferent and better name. But naming is hard, and we’re
engineers, so were stuck wth it's eBPF but reall just BPF, which stands for erkeley Packet Fiter athough today it
has Iitle to do with Berkeley, packets, or fitering.° Thus, BPF should be regarded now as a technology name rather than
as an acronym.
---
## Page 56
2.3Extended BPF (eBPF)
1g
The architecture of the Linux BPF runtime is illustrated in Figure 2-3, which shows how BPF
instructions pass the BPF verifier to be executed by a BPF virtual machine. The BPF virtual
machine implementation has both an interpreter and a JIT compiler: the JIT compiler generates