    State:                  00001000          MEM_COMMIT
    Protect:                00000020          PAGE_EXECUTE_READ
    Type:                   01000000          MEM_IMAGE
    Allocation Base:        00007ffb`f6b00000
    Allocation Protect:     00000080          PAGE_EXECUTE_WRITECOPY
    Image Path:             ntdll.dll
    Module Name:            ntdll
    Loaded Image Name:      C:WindowsSYSTEM32ntdll.dll
    Mapped Image Name:      
    More info: lmv m ntdll More info: !lmi ntdll More info: ln 0x7ffbf6b9cb50 More info: !dh 0x7ffbf6b00000 Content source: 1 (target), length: 7b4b0
可以看到，记事本在其进程虚拟内存中对NtCreatreFile函数具有读取以及执行权限。这是因为记事本需要确保它可以执行该函数的syscall，同时读取其返回值。
在上一篇文章中，我解释了每个应用程序的虚拟地址空间是私有的，而且一个应用程序无法更改属于另一个应用程序的数据，除非后者对其部分私有地址空间进行共享。
由于我们现在在C＃中使用了不安全的上下文，并且穿过了托管代码和非托管代码之间的边界。所以我们需要在程序的虚拟内存空间对内存的访问进行管理，因为这时候CLR已经不会再为我们完成这项工作了！而且只有这样，我们才能将参数写入syscall，执行该代码，并为委托函数读取其返回的数据！
但我们要如何实现上述内容呢？好吧，接下来我要向你介绍一个新的伙伴——[VirtualProtect](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)函数。
通过 **VritualProtect**
函数，我们就能修改调用进程虚拟地址空间中已提交页中一个区域的保护机制。这就表示，如果在syscall的内存地址（我们刚刚获得）使用该原生函数，我们就能将该虚拟进程内存设置为读-写-执行权限！
我们在`Native.cs`文件中实现该原生函数。这样我们就能在`Syscalls.cs`中使用它修改汇编代码的内存保护机制了。
与往常一样，让我们看一下该函数的C结构。
    BOOL VirtualProtect(
      LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD  flNewProtect,
      PDWORD lpflOldProtect
    );
看起来很简单，
我们只需要把函数中的[flNewProtect](http://pinvoke.net/default.aspx/kernel32/VirtualQueryEx.html)标志添加进行就可以了。
接下来添加该标志。 完成后，Native类中实现的内存保护标志应如下所示。
VirtualProtect函数应如下所示：
很好，我们已经有了很大的进展，而且就要结束了！ 好吧，还是有一些事情要做的。
现在我们已经实现了VirtualProtect函数，回到`Syscall.cs`文件，对`memoryAddress`指针执行VirtualProtect函数，赋予其读-写-执行权限。
同时，将该原生函数放入一个 **IF** 语句中。
这样如果函数执行失败，我们就能抛出一个[Win32Exception](https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.win32exception?view=netframework-4.8)异常，显示错误代码并停止代码的执行。
同时确保在代码的顶部添加了`using System.ComponentModel;`语句。 这样就可以使用`Win32Exception`类了。
完成上述操作后，我们的代码应如下所示：
如果VirtualProtect执行成功，非托管syscall汇编代码的虚拟内存地址（即`memoryAddress`变量所指向的地址）现在应该已经具有了读-写-执行权限。
这就表示我们现在有了一个指向非托管函数的指针。在之前也介绍过了，我们现在需要做的是使用[Marshal.GetDelegateForFunctionPointer](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.getdelegateforfunctionpointer?view=netframework-4.8#System_Runtime_InteropServices_Marshal_GetDelegateForFunctionPointer_System_IntPtr_System_Type_)把该非托管函数指针转换为指定类型的委托。在此例中，应该转换为
**NtCreateFile** 委托。
我知道现在你们中的有些人可能会感到困惑，或者想知道我们为什么要这么做。在我解释有关内存保护的概念的时候，你就应该已经明白上述操作的原因了。但无论如何，我还是解释一下，确保在继续之前每个人都处在同一水平。
之所以要把非托管函数指针转换为NtCreateFile委托，是因为这样做之后，在执行syscall汇编代码的时候，就可以把该函数当作一个回调函数进行使用了。你可以回去看一下`Syscalls.cs`文件的第20行。
所以我们之前究竟在干什么呢？如果你的答案是“将参数传递给函数”，那么你是对的！
一旦委托函数接受创建文件需要的参数之后，它进一步把syscall所在内存位置的保护机制更新为读-写-执行。然后，把指向syscall的指针转换为NtCreateFile委托，即将其转换为实际的函数表示形式。
完成后，我们对该初始化的委托以及传递的参数调用return语句。从本质上讲，程序在这里会把参数压入堆栈，执行syscall，然后将结果返回给调用方，也就是`Program.cs`文件中的函数！
现在清楚了吗？很好！你已经是一个syscall学院的毕业生了！ ‍🎓
在解释完所有内容之后，我们就要实现[Marshal.GetDelegateForFunctionPointer](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.getdelegateforfunctionpointer?view=netframework-4.8#System_Runtime_InteropServices_Marshal_GetDelegateForFunctionPointer_System_IntPtr_System_Type_)转换了，首先实例化NtCreateFile委托，将其命名为`assembledFunction`。完成后，将非托管指针类型转换为委托类型。
完成后，我们就能使用一个简单的return语句，通过实例化的`assembledFunction`委托返回syscall中的所有参数。
最终的`Syscall.cs`代码应如下所示。
这样我们就有了函数调用后syscall执行的最终版本！
## 执行syscall
到目前为止我们已经实现了syscall逻辑，现在要做的就是在程序中编写实际的使用 **NtCreateFile**
函数的代码，该函数会执行我们的syscall。
首先，确保已经导入了我们的静态类，这样就能像下图中这样使用所有原生函数和syscall了。
完成后，我们就可以初始化[NtCreateFile](https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile)函数需要的结构和变量了，比如说文件句柄以及对象属性。
在此之前，还有一件事。 [OBJECT_ATTRIBUTES](https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_object_attributes)，尤其是其中的`ObjectName`属性，要求一个指向[UNICODE_STRING](https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_unicode_string)的指针，该结构中包含了句柄要打开的对象的名称。在此例中就是指我们要创建的文件名。
对于非托管代码来说，要初始化此结构，我们需要调用[RtlUnicodeStringInit](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntstrsafe/nf-ntstrsafe-rtlunicodestringinit)函数。
所以要确保把这个函数添加到`Native.cs`文件中，以便使用其功能。
知道了以上内容，我们就可以继续初始化相关结构了。 首先创建文件句柄以及unicode字符串结构。
我们选择把测试文件保存到桌面，所以把filename路径设置为`C:UsersUserDesktop.test.txt`，如下所示。
完成后，我们就能初始化 **OBJECT_ATTRIBUTES** 结构了。
最后，剩下要做的就是初始化 **IO_STATUS_BLOCK** 结构，并调用 **NtCreateFile** 委托及其参数从而执行syscall！
完成所有内容后，最终的`Program.cs`文件应如下所示。
太棒了，我们终于完成了所有代码！ 现在就到了最重要的时刻——编译代码！
在Visual Studio中，确保已经把 **Solution Configuration** 修改成了 “ **Release** ”。
之后，在上面的工具栏中选择 **Build** –> **Build Solution** 。
几秒钟后，你就应该能看到以下输出，显示编译成功！
好吧，先不要太兴奋！ 这个代码可能还会在测试过程中失败，不过我敢肯定不会！ 😁
要测试这个新编译完成的代码，先打开命令提示符并进入到项目的编译位置。我这里是
`C:UsersUserSourceReposSharpCallbinRelease`。
如你所见，我的桌面上并没有`test.txt`文件，如下所示。
如果一切顺利，在执行了`SharpCall.exe`后，会执行我们的syscall，并在桌面上创建一个新的`test.txt`文件。
好吧，关键时刻。 让我们执行来看看！
视频在[这里](https://jhalon.github.io/images/syscall-code-21.mp4)。
确实出现了`test.txt`文件，我们的代码能够正常工作，而且成功地执行了我们的syscall！
但我们怎么确定执行的是syscall，而不是来自 **ntdll** 的原生api函数呢？
为了确保执行的是我们的syscall，我们可以再次使用[Process Monitor](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon)监控我们的程序。
我们可以在这个软件中查看特定的读/写操作属性及其调用堆栈。
在监视该进程的执行过程后，我们发现里面有一个`test.txt`文件的`CreateFile`操作。如果查看该操作的调用堆栈，可以看到以下内容：
可以看到里面没有从 **ntdll** 发出的任何调用，只是一个从 **unknown** 到 **ntoskrnl.exe**
的syscall！我们实现了一个有效的syscall！
使用这种方法就能够绕过在 **NtCreateFile** 函数上的任何API hooking！ 😈
## 结束语
女士们，先生们，到这里我们就完成了此次旅程！我们学习了很多有关Windows
Internals，Syscall以及C＃的知识，现在你应该可以利用这些内容在C＃中创建自己的syscall了！
该项目的最终代码已经添加到了我的Github，位于[SharpCall](https://github.com/jhalon/SharpCall)仓库中。
在本文开头，我提到会提供一些使用相同技术的项目的资源链接。所以如果你觉得仍有问题或者只是想获得更多信息，那么我建议你看一下以下项目。
  * [SharpMiniDump](https://github.com/b4rtik/SharpMiniDump/)
  * [LOLBITS](https://github.com/Kudaes/LOLBITS)
  * [directInjectPOC](https://github.com/badBounty/directInjectorPOC)
好吧，差不多了！非常感谢大家阅读这两篇文章，并且让第一篇文章取得了如此巨大的成功！我没想到它会如此受欢迎。希望你能像阅读第一篇文章一样享受这篇文章，也希望你学到了一些新知识！
感谢阅读的每一个人！谢谢!