密密钥)..base64url (初始向量).base64url(明文)的字符串（注意这个字符
串中连续的两个点号）。在CVE-2019-18848中，是因为校验程序通过点
号split时，没有正确校验JWE格式而导致的校验过程绕过。
在GitHub上，漏洞发现者给出了此漏洞发生的伪码描述，如图9-13
所示。
如果实现机制存在问题，导致格式校验被绕过，而JWT格式的数据
仅为Base64编码，攻击方会通过解码后篡改JWT数据绕过校验，达到获
取敏感信息或绕过授权的目的。
●图9-13 GitHub上denisenkom对CVE-2019-18848漏洞成因分析
一般来说，单纯性的JWT格式是不会传递敏感信息的，尤其是在标
头和有效载荷部分。如果因技术实现产生错误，将敏感信息放入标头或
有效载荷部分，则攻击者会解码JWT格式数据获取敏感信息，这其中最
为常见的敏感信息如Token、密钥。在包含这些敏感信息的情况下，如
果签名验证机制再被绕过，则签名校验相当于无效，攻击者可以达到接
管账号或提升权限的目的。比如通过修改标头设置"alg"为"none"绕过签
名校验，解码后将普通用户user替换为admin来提升权限。
9.3.2 JWT加解密和算法相关漏洞
加解密操作和加解密算法是消息保护的基础，如果加解密操作被破
坏或加解密算法、密钥被攻击，则会导致整个消息保护的安全机制失
效。而在针对JWT的攻击中，针对加解密操作、密钥、算法的攻击也是
很常见的。
在JWS的使用中，通常使用HMAC签名密钥SHA-256、SHA-384或
SHA-512对消息生成消息认证码，比如使用共享密钥shareSecret对消息
应用SHA-256进行签名的代码片段如下（此处使用java-jwt类库）：
这是很通用的JWT签名在Java中的代码实现，并没有什么特别的地
方。这种格式的数据在JWT签名验证时，也同样基于共享密钥，采用相
同的算法，对消息进行签名，再比对签名字符串的一致性，从而校验消
息在传输过程是否被篡改。而对攻击者来说，他们可以获取应用程序中
JWT格式的字符串，使用破解工具（比如jwt_tool，网址为
https://github.com/ticarpi/jwt_tool）离线破解共享密钥，再伪造JWT数据
以达到攻击的目的。
除此之外，还有另一种针对签名算法的攻击，比如应用安全研究人
员Sjoerd 
Langkemper在其博客（https://www.sjoerdlangkemper.nl）提及
的将RS256更改为HS256算法，使用公钥作为私钥，以达到签名绕过的
目的。一般情况下，Java代码中使用RS256签名时，其代码片段如下
（此处使用java-jwt类库）：
这段代码实现是没有问题的，它演示了使用公钥、私钥对JWT签名
的过程。如果一个应用程序服务器端，同时支持RSA和HMAC两种签名
算法（这很正常，JWS规范中即是如此定义的），则当客户被强制指定
为HMAC HS256时，此时的公钥是公开的，相当于使用HMAC签名密钥
SHA-256中的共享密钥被破解了，被攻击利用后所造成的危害是一样
的。
9.3.3 其他消息保护类型的漏洞
针对消息保护技术攻击的手法很多，比如针对JSON格式的Unicode
转义的恶意破坏，上文提及的针对JWT格式的各种攻击。除了这些针对
特殊数据格式的攻击外，传统的Web安全攻击手法在消息保护的过程中
也经常出现，比如点击劫持、CSRF、SQL注入等。
无论是JWT格式、Paseto格式还是XML格式的数据，在接收方进行
数据处理时，都会对数据格式进行解析，如果解析后仍需要与后端的数
据库、主机、存储等交互，则最为常见的SQL注入、命令行注入、XEE
等漏洞都可能会发生。比如在JWT格式中，通常包含客户端ID或用户ID
字段，这些字段在服务器端校验时，通常会查询数据库做数据匹配，如
果JWT数据被恶意篡改为攻击向量，则会导致SQL注入，如下JWT数据
所示：
同理，如果代码中处理JWT的JSON数据使用了Fastjson，则会导致
JSON反序列化的通用漏洞如下代码所示：
对于这类通用漏洞，在安全设计时，需要从组件或依赖库引入层面
进行考虑，通过“引入审核-过程监控-流程闭环”来保障应用程序的安全
性。
除此之外，针对令牌或标识类的漏洞，比如令牌重放攻击、令牌不
失效、标识字段易猜解、令牌泄露、中间人劫持等，在API消息保护中
也会存在，这也是在本书中反复强调要基于API生命周期去考虑API安
全性的一个重要原因。
9.4 业界最佳实践
通过上述传输层消息保护和应用层消息保护技术的介绍可以看出，
无论哪种类型的消息格式，所使用的保护技术主要集中在如下两个层
面。
■ 通信链路的TLS加密传输。
■ 应用层消息的加密和签名。
基于以上的这些知识储备，接下来将和读者一起来看看国内头部互
联网企业在消息保护中所使用的技术细节。
9.4.1 案例之百度智能小程序OpenCard消息保护
消息保护技术在互联网应用中使用比较广泛，尤其是在公开的网络
环境中，恶意用户往往混合在正常用户之中，为了防止恶意用户的蓄意
破坏，使用消息保护技术也成了互联网应用的基本要求，百度智能小程
序OpenCard消息保护就是其中一个很好的例子。
1.背景介绍
OpenCard是百度搜索专为百度智能小程序开发者推出的一个新合作
模式，当用户搜索某检索词时，百度数据开放平台会对用户的检索词进
行分析提炼，按照用户需求整合开发者的数据资源和百度数据开放平台
资源，以OpenCard的形式同步展示在搜索结果中。不同类目的
OpenCard都有自己的展示样式，开发者也可以自己调用各种组件来进行
卡片样式的自主设计，如大图组件、筛选组件、运营组件等。其交互过
程如图9-14所示。
当用户在移动客户端上发起查询请求（比如百度搜索请求）时，会
调用百度数据开放平台的API接口来传递请求数据。百度数据开放平台
接收请求参数后，进行语义分析，推断用户实际需求，并调用小程序
Webhook通信接口获取资源信息。当小程序应答资源信息后，将资源信
息与百度数据开放平台的数据进行整合，响应客户端的API请求，以
OpenCard的样式进行展示。在整个交互流程中，尤其是客户端与百度数
据开放平台之间，消息传输的保护尤其重要，百度在此方面使用了消息
保护技术来保护小程序提供的资源数据不被第三方窃取以及双方的通信
不被中间人劫持。
●图9-14 OpenCard通信交互示意图
2.技术选择与应用
OpenCard小程序使用JWE作为消息保护技术，以方便开发者根据自
身需求，选择合适的开源类库，在小程序服务开发中使用与集成。
（1）消息格式
作为通信传输的内容，OpenCard小程序定义了请求消息和应答消息
的格式，其官方对于请求消息关键部分格式定义如表9-2所示。
表9-2 OpenCard小程序请求消息格式定义
同样，应答消息关键部分格式定义如表9-3所示。
表9-3 OpenCard小程序应答消息格式定义
（2）加密算法选择和使用
在通信交互过程中，使用加密算法对请求消息和响应消息进行加密
保护。在JWE消息中，通常使用两种加密算法的组合。
在百度的OpenCard这个案例中，所使用的两种加密算法单独组合
定义为{"alg":"A128KW"，"enc":"A128CBC-HS256"}，其中A128KW
算法用于和预共享密钥PSK生成每次会话需要的内容加密密钥CEK，而
A128CBC-HS256用于消息内容的加密和认证标签的生成以及数据完整
性签名校验。
在开始加密前，需要定义加密密钥。这里可以使用JWK密钥生成工
具（网址为https://mkjwk.org/）生成JWT格式的签名密钥文件（读者需
要注意的是，OpenCard中使用的kid不是此工具生成的，是开发者在使
用时指定的），如图9-15所示。
●图9-15 mkjwk工具
密钥确定下来之后，接下来将使用A128KW算法和PSK生成CEK。
PSK是需要开发者提前配置在开发者管理平台的，开发者在平台中输入
的格式为Base64url(PSK)，即经过Base64url编码的PSK值。PSK存储在
双方服务器中，仅用于生成加密内容密钥CEK，不放入消息体中进行传
输。
同时，平台中会存在多个版本的PSK的情况，为了解决这个问题，
在JOSE标头的protected header中增加了一个额外字段kid，与PSK建立映
射关系。当通信交互时，携带kid，通过kid告知通信方使用哪个PSK解
密请求消息和加密返回消息。如API调用接口测试中的配置，如图9-16
所示。
rid的格式为毫秒时间戳-随机数，直接以Base64url编码的形式放在
protected header中作为签名内容的一部分，响应方解码后需要将rid值原
样返回给发送方，以保证响应与请求的一致性。
（3）API消息加密样例
在百度小程序OpenCard接入文档中，给出了不同开发语言的示例，
这里，以其官方的Python语言代码片段为例，展现其使用过程。
●图9-16 OpenCard小程序中关键参数配置页面截图
1）消息的生成与发送。
当上述脚本执行完成后，输出的JWT格式数据为（注意其中的点号
连接符）：
请求方将HTTP Header设置为Content-Type: application/jwt，以POST
方式发送HTTP请求。
2）消息的接收与验证。
当响应端接收到请求消息后，首先从JOSE标头中的protected header
中获取kid值，再通过kid拿到解密的key，对请求消息解密后进行业务处
理。最后，将业务处理结果按照请求消息的格式封装为JWT格式，做出
应答响应。如下伪码片段所示：
通过上述的两个过程可以看出，百度小程序OpenCard在API消息保
护上遵循了标准的JWT规范，将需要保护的业务数据以intent和data节点
的形式，放入JWT中进行保护。当读者在使用JWT进行消息保护时，可
以参考此样例，来实现自己的JWT逻辑与流程。
9.4.2 案例之微信支付消息保护
在人们的日常生活中，使用电子支付已很普遍，即使在某些偏远地
区，购物付款时现在也可以使用电子支付的方式。下面将结合微信支付
的使用场景，来分析一下其中的消息保护技术。
1.背景介绍
微信支付是腾讯集团旗下国内领先的第三方支付平台，致力于为用
户和企业提供安全、便捷、专业的在线支付服务。2018年腾讯公开的数
据已经显示，以微信支付为核心的“智慧生活解决方案”已覆盖数百万门
店、30多个行业，用户可以使用微信支付来看病、购物、吃饭、旅游、
交水电费等，微信支付已深入生活的方方面面。
在这里，为读者选择微信支付中JSAPI的核心接口统一下单场景来
讲述微信支付的消息保护。统一下单的使用场景为除付款码支付外，其
他的支付场景下，商户系统先调用统一下单接口在微信支付服务后台生
成预支付交易单，再根据后台服务返回的预支付交易会话标识调用
JSAPI完成交易支付的场景。JSAPI交易支付的流程如图9-17所示。
●图9-17 微信支付交互流程示意图
用户使用移动端设备（比如手机）打开商户网页选购商品，在确认
微信支付后，网页调用JS 
getBrandWCPayRequest接口发起微信支付请
求，进入支付页面。当用户输入密码成功支付后，直接进入支付成功页