ISA dependent; Table I summarizes Alpha instruction for-
mat. Experiments affecting unused bits always resulted into
strict correct results. Faults affecting branch instructions were
validated by checking the simulation statistical information.
For example when inserting a fault into the displacement bits
of the instruction and the branch is not taken the simulation
statistics were the same and the end-result was categorized as
strict correct. Faults affecting the Ra ﬁeld may cause no error,
should the result of the branch remain the same. Whenever
faults altered the displacement ﬁeld of memory instructions
the application would crash with a high probability. The same
was observed when the error altered the Ra value of a memory
instruction, since the base address was read by another register.
Finally we observed that, exactly as expected, when faults
were injected into the opcode or the function and the resulting
opcode/function is not implemented the benchmarks always
terminated their execution due to illegal instruction.
A similar analysis was applied for faults inserted in the
selection of registers during the decoding stage. Errors which
affect the selection of the base of load/store instructions would
usually cause a segmentation fault. An interesting observation
is that faults inserted in the decoding stage of the PI algorithm
result to crashes almost at half the probability compared with
the remaining applications, because PI performs almost no
data accesses from memory. Errors in the decoding stage
usually lead to SDCs. This is expected, since operations
are executed with different inputs. Correct results may be
627
produced only by faults which alter a squashed instruction,
or due to inherent, algorithmic application resiliency.
Faults introduced in the execution stage, which alter mem-
ory access instructions tended to result to crashes, because at
this stage the virtual address of the memory transfer is being
calculated. Faults altering the resulting address usually result
to segmentation violations. The variation between the percent-
age of crashes among different applications is consistent with
the variation of the percentage of memory operations in the
instruction mix. In Knapsack, which makes heavy use of arrays
and pointers 42% of faults in the execution stage result to
crashes. On the other hand, PI evaluation, with almost no data
accesses from memory, suffers almost no crashes. Correct and
strictly correct results when fault injecting in the execution
stage were found to be due to faults that have been masked
during the remaining execution of the application, or faults
that affected the less signiﬁcant bits of data computations.
Faults altering the result of data loads/stores rarely resulted
to crashes, and when they did it was because the error affected
a store/load of an address. For example, altering the stored or
loaded value of the return address usually led to crash. In
total, errors affecting data store/load operations exhibit high
resiliency, resulting to correct results in 78% of the cases.
Finally faults altering the value of the PC address were
almost always fatal for the affected applications. Correct
results were obtained in the few cases when the corrupted
PC address was close to the correct one. This, in practice,
corresponds to a small forward or backward jump.
Another interesting aspect of the experimental validation
is the correlation of the timing of fault
injection to the
effects on the application. Fig. 6 depicts the results from
three fault injections campaigns with interesting trends. The
horizontal axis corresponds to the timing of fault injection
normalized to the application execution time and the vertical
axis corresponds to the fraction of experiments that resulted
to each of the classes of outcomes. Acceptable represents the
union of correct and strictly correct results.
For Monte Carlo PI estimation the time when fault injec-
tion took place appears to be uncorrelated with application
behavior. This is reasonable, since the application iteratively
produces random numbers, which are used to compute the ﬁnal
result. All iterations affect the ﬁnal result similarly, therefore
we did not expect different behavior with respect to the timing
of the faults. On the other hand, Knapsack demonstrates a
different behavior. The later the faults are injected, the more
likely the results are acceptable. Faults corrupting data in a
manner that does not result to values which converge towards
the solution will be discarded on the following iteration, after
applying the ﬁtness function. This effect becomes more intense
Fig. 6: Correlation of the timing of fault injection with the effect on the application.
on each consecutive iteration of the algorithm. In Jacobi, faults
inserted at the beginning of the execution tend to result to
strict correctness. The later the faults are injected, the more the
correct results at the expense of strictly correct. Given that the
input matrix is diagonally dominant, errors which do not alter
important variables of the application (etc. iterators) but alter
input or intermediate data, will have no signiﬁcant effect to
the results, since the algorithm is bound to converge. However,
more iterations may be needed to achieve convergence.
V. GEMFI PERFORMANCE EVALUATION
In order to evaluate the overhead of GemFI we compare the
execution time for simulated runs of all the aforementioned
benchmarks on both GemFI and the unmodiﬁed Gem5 simu-
lator. We measure and compare simulation time for the part
of the application for which fault injection is active (between
ﬁ activate inst() calls). Despite activating the fault injection
functionality, in this set of experiments we do not actually
inject any faults in the GemFI simulations. Should we inject
faults, the behavior of applications would potentially change,
thus making the comparison between the two tools infeasible.
It should be noted that, despite the fact that no faults are
injected, all GemFI functionality is activated — especially the
modules of GemFI that are executed on each simulated cycle,
thus resulting to most overhead — apart from the last step
of the process described in Fig. 2, the fault injection itself.
However, the actual fault injection step would, in any case, be
activated only once, with negligible overhead. Moreover, since
no faults are injected, there are no opportunities to switch to
atomic simple mode after fault manifestation, therefore the
simulation is performed in the high-overhead O3 CPU model.
Fig. 7 depicts the experimental results, which can be con-
sidered as a worst-case overhead scenario for GemFI. The
overhead varies from -0.1% to 3.3%. It is mainly dependent
on the number of instructions simulated with fault injection
enabled. The overhead introduced by GemFI clearly is mini-
mal. For PI estimation GemFI appears to perform better than
Gem5, however this observation is not statistically signiﬁcant.
in
Sec. III-D, GemFI is able to signiﬁcantly reduce the time
for executing simulation campaigns. Fig. 8 summarizes the
simulation time for the campaigns discussed in Sec. IV, with
and without using the checkpointing capability to fast-forward
the simulation to the point where fault injection is activated.
checkpointing methodology
presented
Using
the
Fig. 7: GemFI average overhead compared with unmodiﬁed
Gem5. The chart also depicts the 95% conﬁdence interval for
each application.
Fig. 8: Effect of GemFI optimizations on the execution time
of fault injection campaigns (y-axis in logarithmic scale).
The beneﬁt from checkpointing is a 3x to 244x (64.5x on
average) speedup with respect
to the non fast-forwarded
execution of the campaign. The speedup is mainly dependent
on the ratio of the execution time spent for each application
on the pre- and post-checkpoint code.
The third set of bars in Fig. 8 depicts the execution time of
the simulation campaigns on a network of 27 workstations, us-
ing the meta-simulation infrastructure discussed in Sec. III-E.
Each workstation is equipped with quad core Intel Xeon E5520
CPUs at 2.27 Ghz and 8 GB RAM each. On each workstation
we execute simultaneously 4 experiments (simulations). The
additional speedup, compared with execution on a simple
system with checkpoint-based fast forwarding, is consistent
with the number of simultaneously executed experiments (in
all cases approximately 108x).
VI. RELATED WORK
The impacts of faults have been evaluated by several re-
search groups. Different approaches are used towards injecting
628
faults such as software fault injection, simulation fault injec-
tion and physical level fault injection.
RIFFLE [9] and MESSALINE [10] inject faults at
the
pin level, while FIAT [11] and FERRARI [11] implement
software-level fault injection. Simulation based fault injection
has the ability to model complex system with great accuracy
however, ensuring that the simulated models are realistic and
restraining simulation time are signiﬁcant challenges. Exam-
ples of fault simulators are MEFISTO [12] and VERIFY [13].
MEFISTO inserts faults into VHDL models. This method
provides high accuracy in both the location and the timing
of the fault, as well as high validity of results. The drawback
of using MEFISTO is the overhead of the system evaluation;
the system is based in mutants [14], which is static information
and the model has to be recompiled for each experiment.
In VERIFY, another VHDL simulation-based fault injection
toolset, basic logic gates (AND, OR, etc.) have been extended
with extra signals, allowing to alter their behavior based on
these external signals. Although the methodology is quite
efﬁcient in simulating different fault models, recompilation of
the framework is required, introducing signiﬁcant overhead.
Czeck and Siewiorek [15] performed a similar analysis
through fault injection using bit-ﬂip faults in their simula-
tion model. However, their approach is limited to a speciﬁc
conﬁguration. Gaisler [16] injected faults into the register ﬁle
of a SPARC V8 simulator, while enhancing the register ﬁle
fault tolerance by adding ECC bits on each register. In [17]
fault injection is performed on simulated processor similar to
ALPHA 21264 or AMD ATHLON and the system tolerance
is enhanced by providing extra hardware support.
In our work we provide a tool which is based on a broadly
used reconﬁgurable simulator (Gem5). The purpose of our tool
is to support any arbitrary fault model, by allowing the user
to describe the faults to an input ﬁle. Moreover to the best of
our knowledge GemFI is the ﬁrst infrastructure that can target
speciﬁc applications areas, while minimizing the changes to
the original source code of the application under test.
VII. CONCLUSION
In this paper we introduced GemFI, a new simulator en-
abling fault injection of transient, intermittent and permanent
faults. GemFI simulates unreliable environments in full sys-
tem, cycle accurate mode. It is not limited to speciﬁc fault
models, but is easily extensible and facilitates support of future
fault models. Moreover, GemFI features such as checkpointing
allow the execution of large-scale fault injection campaigns.
In order to validate GemFI and evaluate its performance, we
executed a number of fault injection campaigns on different
applications. We found that the outcome of fault injection cam-
paigns was the expected one, according to the characteristics
of each application. Moreover, the overhead of GemFI over
Gem5 proved minimal, whereas the performance optimizations
in GemFI have a profound effect on the execution time of
simulation campaigns.
629
In the future, we plan to extend GemFI with fault injection
capabilities outside the processor, namely on the processor
/ memory interconnect, as well as on external I/O devices.
Moreover, we plan to enhance it with realistic fault models,
associating the supply voltage (Vdd) with the error rate in
different system components. Our goal is to study the limits
of aggressively reducing power consumption at the expense of
correctness, yet within the error tolerance of applications and
the software stack.
ACKNOWLEDGMENT
This work has been partially supported by the EC within the
7th Framework Program under the FET-Open grant agreement
SCoRPiO, grant number 323872.
REFERENCES
[1] N. Binkert, B. Beckmann, G. Black, S. K. Reinhardt, A. Saidi, A. Basu,
J. Hestness, D. R. Hower, T. Krishna, S. Sardashti, R. Sen, K. Sewell,
M. Shoaib, N. Vaish, M. D. Hill, and D. A. Wood, “The Gem5
Simulator,” ACM SIGARCH Computer Architecture News, 2011.
[2] C. R. Yount and D. P. Siewiorek, “A methodology for the rapid injection
of transient hardware errors,” IEEE Trans. on Computers, 1996.
[3] J. Ansel, K. Arya, and G. Cooperman, “DMTCP: Transparent Check-
pointing for Cluster Computations and the Desktop Proc,” in Proc. of
the IEEE International Symposium on Parallel & Distributed Processing
(IPDPS), 2009.
[4] A. Skodras, C. Christopoulos, and T. Ebrahimi, “The JPEG 2000
the IEEE International
image compression standard,” Proc. of
still
Symposium on Signal Processing (ICSP), 2001.
[5] L. Fan, S. Ma, and F. Wu, “Overview of AVS video standard,” in Proc.
of the IEEE International Conference on Multimedia and Expo (ICME),
2004.
[6] C. Bienia and K. Li, “PARSEC 2.0: A New Benchmark Suite for
Chip-Multiprocessors,” in Proc. of the Annual Workshop on Modeling,
Benchmarking and Simulation (MoBS), 2009.
[7] R. Leveugle, A. Calvez, P. Maistri, and P. Vanhauwaert, “Statistical fault
injection: quantiﬁed error and conﬁdence,” in Proc. of the Conference
& Exhibition on Design, Automation & Test in Europe (DATE), 2009.
[8] S. T. Welstead, Fractal and wavelet image compression techniques.
SPIE Optical Engineering Press, 1999.
[9] H. Madeira, M. Rela, F. Moreira, and J. G. Silva, “RIFLE: A general
purpose pin-level fault injector,” in Proc. of the European Dependable
Computing Conference (EDCC), 1994.
[10] J. Arlat, M. Aguera, L. Amat, Y. Crouzet, J.-C. Fabre, J.-C. Laprie,
E. Martins, and D. Powell, “Fault Injection for Dependability Validation:
A Methodology and Some Applications,” IEEE Trans. on Software
Engineering, 1990.
[11] J. H. Barton, E. W. Czeck, Z. Z. Segall, and D. P. Siewiorek, “Fault
Injection Experiments Using FIAT,” IEEE Trans. on Computers, 1990.
[12] E. Jenn, J. Arlat, M. Rimn, J. Ohlsson, and J. Karlsson, “Fault Injection
into VHDL Models: The MEFISTO Tool,” in Proc. of the Symposium
on Fault-Tolerant Computing (FTCS), 1994.
[13] V. Sieh, O. Tschche, and F. Balbach, “VERIFY: Evaluation of Reliability
Using VHDL-Models with Embedded Fault Descriptions,” in Proc. of
the Symposium on Fault-Tolerant Computing (FTCS), 1997.
[14] M. Rim´en, J. Ohlsson, J. Karlsson, E. Jenn, and J. Arlat, “Design
guidelines of a VHDL-based simulation tool for the validation of fault
tolerance,” ESPRIT Basic Research Project (PDCS-2), Tech. Rep., 1993.
[15] E. W. Czeck and D. P. Siewiorek, “Effects of transient gate-level faults
on program behavior,” in Proc. of the International Symposium on Fault-
Tolerant Computing (FTCS), 1990.
[16] J. Gaisler, “A Portable and Fault-Tolerant Microprocessor Based on the
SPARC V8 Architecture.” in Proc. of the International Conference on
Dependable Systems and Networks (DSN), 2002.
[17] N. J. Wang, J. Quek, T. M. Rafacz, and S. J. Patel, “Characterizing the
Effects of Transient Faults on a High-Performance Processor Pipeline,”
in Proc. of the International Conference on Dependable Systems and
Networks (DSN), 2004.