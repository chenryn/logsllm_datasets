-preceded—the
rest of them would all result in illegal returns.
3.2 Gadget Chaining
It is clear from the previous section that even a “lighter”
version of kBouncer that would just prohibit the execu-
tion of illegal returns would still signiﬁcantly raise the
bar, as i) it would prevent the execution of the ROP code
typically found in publicly available Windows exploits,
and more importantly, ii) it would force attackers to ei-
ther use only a limited set of
gadgets, or resort to
jump-oriented code—options of increased complexity.
To account for potential future exploits of these sorts,
the second attribute that kBouncer uses to identify the
execution of ROP code is an inherent characteristic of its
construction: the observation of several short instruction
sequences chained through indirect branches. This is a
generic constraint that holds for both return-oriented and
jump-oriented code (or potential combinations—in the
rest of this section we refer to both techniques as ROP).
Figure 6: The state of the LBR stack at
the time
kBouncer blocks an exploit against Adobe Flash [2]. Di-
agonal pairs of addresses with the same shade correspond
to the ﬁrst and last instruction of each gadget.
Although legitimate programs also contain an abundance
of code fragments linked with indirect branches, these
fragments are typically much larger than gadgets, and
more importantly, they do not tend to form long unin-
terrupted sequences (as we show below).
The CPU records in-sequence all executed indirect
branches, enabling kBouncer to reconstruct the chain of
gadgets used by any ROP code. Each LBR record R[b,t ]
contains the address of the branch (b) and the address of
its target (t), or from the viewpoint of ROP code, the end
of a gadget and the beginning of the following one.
Figure 6 illustrates the contents of the LBR stack at
the time kBouncer blocks the ROP code of an exploit
against Adobe Flash [2] (although kBouncer blocks this
exploit due to illegal returns, we use it for illustrative pur-
poses, as we are not aware of any publicly available JOP
exploit). Starting with the most recent (bottom-most)
record, the detection algorithm checks whether the tar-
USENIX Association  
22nd USENIX Security Symposium  453
get (located at address Rn−1[t ]) of the previous branch,
is an instruction that precedes the branch (located at ad-
dress Rn[b]) of the current record. If starting from address
Rn−1[t ], there exists an uninterrupted sequence of at most
20 instructions that ends with the indirect branch at ad-
dress Rn[b], then the sequence is considered as a gadget.
Recall that kBouncer treats as gadgets even fragmented
instruction sequences linked through conditional or un-
conditional relative jumps. The same process repeats
with the previous records, moving upwards, as long as
chained gadgets are found.
that transfers control to
The ROP code in this example consists of 11 gad-
gets, all ending with a
instruction except the ﬁnal
one (G11), which is a single-instruction gadget with an
indirect
in
(note the difference in the high
bytes of the target address in record 13). The two
bottom-most records in the LBR stack correspond to
kBouncer’s function hook (from
to
, which signals the kernel compo-
which is called
nent), and a
by
from
.
A crucial question for the effectiveness of the above
algorithm is whether legitimate code could be misclas-
siﬁed as ROP code due to excessively long chains of
gadget-like instruction sequences. To assess this possi-
bility, we measured the length of the gadget chains ob-
served across all inspected LBR stack instances for the
applications and workloads listed in Table 2. As de-
scribed in Sec. 2.2.2, kBouncer inspects the LBR stack
right before the execution of a sensitive Windows API
function. In total, kBouncer inspected 79,885 LBR stack
instances, i.e., the tested applications legitimately in-
voked a sensitive API function 79,885 times.
Figure 7 (solid line) shows the percentage of instances
with a given gadget chain length. In the worst case, there
is just one instance with a chain of ﬁve gadgets, and
there are no instances with six or more gadgets. On the
other hand, complex ROP code that would rely on
-
preceded or non-
gadgets would result in excessively
long gadget chains, ﬁlling the LBR stack. Indicatively, a
jump-oriented Turing-complete JOP implementation for
Linux uses 34 gadgets [23]. Furthermore, current JOP
code implementations rely on a special dispatcher gad-
get that always executes between useful gadgets, at least
doubling the amount of executed gadgets.
Although we can never rule out the possibility that
benign code in some other application might result in a
false positive, to ascertain that this possibility is unlikely,
we also analyzed 97,554,189 LBR stack instances taken
at the entry points of all executed functions during the
lifetime of the same tested applications. In this orders-
of-magnitude larger data set, the maximum gadget chain
length observed is nine (dashed line), which is still far
Protected API calls
All function calls
)
%
(
s
e
c
n
a
t
s
n
i
k
c
a
t
s
R
B
L
100
10
1
0.1
0.01
    −3
10    
    −4
10    
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
Gadget chain length
Figure 7: Percentage of LBR stack instances with a
given gadget chain length for i) the instances inspected
by kBouncer at the entry points of protected API func-
tion calls, and ii) the instances taken at the entry points
of all function calls.
from ﬁlling up the LBR stack. This means that even if
there is a need in the future to protect more API func-
tions, or perform LBR checks in other parts of a program,
we will more than likely still be able to set a robust detec-
tion threshold that will not result in false positives. For
the current set of protected functions we use a threshold
of eight gadgets, which allows for increased resilience to
false positives.
Finally, note that in the above benign executions, the
vast majority of the gadget-like chains stem from our
conservative choice of considering fragmented gadgets
of up to 20 instructions long—signiﬁcantly more com-
plex and longer than the gadgets used in actual exploits.
Although we could choose more reasonable constraints
about what is considered as a gadget, we preferred to
stress the limits of the proposed approach.
4 Implementation
4.1 kBouncer
To demonstrate the effectiveness of our proposed ap-
proach, we developed a prototype implementation for the
x86 64-bit version of Windows 7 Professional SP1. Our
prototype, kBouncer, consists of three components: i) an
ofﬂine gadget extraction and analysis toolkit, ii) a user-
space thin interposition layer between the applications
and Windows API functions, and iii) a kernel module.
For the executable segments of a protected application,
the gadget extraction toolkit identiﬁes any instruction se-
quence ending in an indirect branch, starting from each
and every byte of a segment. In the current version of
our prototype we assume that the complete set of an ap-
plication’s modules is available in advance. However, it
is possible to trivially relax this assumption by process-
454  22nd USENIX Security Symposium 
USENIX Association
application
call VirtualProtect
user
space
detour.dll
kernel32.dll
API call:
LBR check
BOOL VirtualProtect() {
...
ntoskrnl.exe
kernel
space
kBouncer
module
system call handler:
API call verif cation
i
CPU
LBR stack
Figure 8: Overview of kBouncer’s implementation. At
the entry point of Windows API functions, kBouncer de-
tours the execution, inspects the LBR stack in kernel
mode, and then returns control back to the application.
ing new modules on-the-ﬂy at the time they are loaded
by a protected application. The maximum gadget length
is given as a parameter—in our experiments we conser-
vatively used a length of 20 instructions. As discussed
in Sec. 3.1, our extraction algorithm differs from previ-
ous approaches as it considers even instruction sequences
that contain conditional or unconditional relative jumps.
For this reason, code analysis explores all possible paths
from every offset within a code segment, and follows re-
cursively any conditional branches. The output of the
analysis phase is two hash tables: one containing the off-
sets of
-preceded gadgets, and another containing
the rest of the found gadgets. In the future, we will con-
sider switching to Bloom ﬁlters to save space.
The overall operation of the runtime system is de-
picted in Fig. 8. The interposition component is imple-
mented on top of the Detours framework [38], which
provides a library call interception mechanism for the
Windows platform. During initialization, it requests by
kBouncer’s kernel module to enable the LBR feature
on the CPU. The two components communicate through
control messages over a pseudo-device that is exported
by the kernel module (using the
API
function). Then, it selectively hooks the set of the pro-
tected Windows API functions. Each time a protected
function is called, the detour code sends a control mes-
sage to the kernel component, instructing it to inspect the
contents of the LBR stack for abnormal control transfers.
The kernel module is responsible for three main tasks:
i) enabling or disabling the LBR facility, ii) analyzing the
recorded indirect branches, and iii) writing and verifying
the appropriate checkpoint before allowing a system call
to proceed. The ﬁrst task involves reading and writing
a few Model Speciﬁc Registers (MSR) using the
instructions. For the second task, whenever
and
a control request is received from the user-space compo-
nent, kBouncer analyzes the contents of the LBR stack,
looking for the attributes described in Sec. 3. The MSR
registers that hold the recorded information and conﬁgu-
ration parameters are considered part of the running pro-
cess context, and are preserved during context switches.
To identify illegal return instructions, the kernel mod-
ule fetches a few bytes before each return target and at-
tempts to decode any
instruction located right be-
fore the target instruction (call site check). Gadget chain-
ing patterns are identiﬁed as follows: starting from the
most recent branch in the LBR stack, the number of con-
secutive targets that point to gadgets are counted. Any
-preceded gadgets
hash table, whereas
targets are looked up
in both hash tables,
-preceded or not. The most re-
cent branch target is not considered, as it does not point
to a gadget, but to the protected API function. To pro-
tect the kernel-level component from potential crashes
when accessing invalid user-level locations, we use the
targets are looked up in the
or
function of the Windows kernel API.
Unfortunately, the ﬁnal task for API call veriﬁcation
has been only partly implemented, as it is not possible
to perform system-call interposition in the current ver-
sion of Windows 7. A recently added kernel feature in
the 64-bit version of Windows, called PatchGuard [32],
protects against kernel-level rootkits by preventing any
changes to critical data structures, such as the System
Service Descriptor Table (SSDT). Although this is effec-
tive against rootkits, PatchGuard removed the ability of
legitimate applications, such as antivirus software, to in-
tercept system calls. In response, Microsoft added a set
of kernel-level APIs for ﬁltering network and ﬁle-system
operations (Windows Filtering Platform [48]). Hope-
fully, future OS versions will provide system call ﬁltering
capabilities as well.
Still, we did verify the correct operation of checkpoint
veriﬁcation by simulating it using the dataset of Table 2.
We should note that this is not a design limitation, but
only an implementation issue stemming from our choice
of the target platform. For example, this would not have
been an issue had we decided to implement kBouner for
Linux, or any other open platform. For now, we plan to
implement the checkpointing functionality for 32-bit ap-
plications by hooking system calls at user level through
the WOW64 layer [4] (which, however, will not provide
the same protection guarantees as an actual kernel-level
implementation).
In case an attack attempt is detected after the analy-
sis of the recorded branches, the process is terminated
and the user is informed with an alert message, as shown
in Fig. 9.
In this example, kBouncer blocks a mali-
cious PDF sample that exploits an (at the time of writing)
USENIX Association  
22nd USENIX Security Symposium  455
Figure 9: A screen capture of kBouncer in action, block-
ing a zero-day exploit against Adobe Reader XI [19].
unpatched vulnerability in the latest version of Adobe
Reader XI [19]. The displayed information, such as
branch locations and targets, is supplied from the kernel-
level module.
4.2 Analysis Framework
Moving from the basic concept to a functional prototype
required a number of decisions that were mostly based on
analyzing the behavior of large applications. To ease the
effort required to perform this type of analysis, we devel-
oped an LBR analysis framework. Its goal is to provide a
way to iterate over the LBR instances during the lifetime
of an application, while at the same time providing useful
information, such as translating addresses to function or
image names. The framework is split in two parts: data
gathering and analysis.
The data-gathering component is based on dynamic
binary instrumentation. Although the runtime overhead
of dynamic instrumentation is quite high (as discussed in
Sec. 2.1), we use it here only for data gathering, which
is an off-line and one-time operation. The tool we de-
veloped is built on top of Pin [64, 46], and records the
following information during process execution: i) the
ﬁle path and starting and ending address of any loaded
executable image, ii) the location and name of any rec-
ognized function (e.g., exported functions), iii) the thread
ID, location, and target of executed indirect branches
(
), iv) the thread ID, location, and num-
ber of system calls, and v) the thread ID, location, and
return address of any identiﬁed function that was called.
The analysis part is a set of Python scripts that process
the gathered data for each application. It provides a con-
ﬁgurable LBR iterator which simulates different scenar-
ios, such as returning LBR stack instances before system
calls or certain function calls, or even after each branch is
or
,
Table 3: Microbenchmarks.
executed. To avoid mixing branches from different sys-
tem threads in the same LBR instance, it internally keeps
a list of separate LBRs per thread id. Finally, it provides
convenient methods to translate addresses to function or