}
...
int slice(int a, int b)
{
...
}
在C中，编译器假定用户使用旧风格声明函数。在C++中，编译器假定
slice()与slice(void)相同，且未声明slice(int, int)函数。
另外，C++允许用户声明多个同名函数，只要它们的参数列表不同即
可。
B.9.2 char常量
C把char常量视为int类型，而C++将其视为char类型。例如，考虑下面的
语句：
char ch = 'A';
在C中，常量'A'被储存在int大小的内存块中，更精确地说，字符编码被
储存为一个int类型的值。相同的数值也储存在变量ch中，但是在ch中该值只
占内存的1字节。
在C++中，'A'和ch都占用1字节。它们的区别不会影响本书中的示例。
但是，有些C程序利用char常量被视为int类型这一特性，用字符来表示整数
值。例如，如果一个系统中的int是4字节，就可以这样编写C代码：
1628
int x = 'ABCD'; /*对于int是4字节的系统，该语句出现在C程序中没问
题，但是出现在C++程序中会出错 */
'ABCD'表示一个4字节的int类型值，其中第1个字节储存A的字符编码，
第2个字节储存B的字符编码，以此类推。注意，'ABCD'和"ABCD"不同。前
者只是书写int类型值的一种方式，而后者是一个字符串，它对应一个5字节
内存块的地址。
考虑下面的代码：
int x = 'ABCD';
char c = 'ABCD';
printf("%d %d %c %c\n", x, 'ABCD', c, 'ABCD');
在我们的系统中，得到的输出如下：
1094861636 1094861636 D D
该例说明，如果把'ABCD'视为int类型，它是一个4字节的整数值。但
是，如果将其视为char类型，程序只使用最后一个字节。在我们的系统中，
尝试用%s转换说明打印'ABCD'会导致程序奔溃，因为'ABCD'的数值
（1094861636）已超出该类型可表示的范围。
可以这样使用的原因是C提供了一种方法可单独设置int类型中的每个字
节，因为每个字符都对应一个字节。但是，由于要依赖特定的字符编码，所
以更好的方法是使用十六进制的整型常量，因为每两位十六进制数对应一个
字节。第15章详细介绍过相关内容（C的早期版本不提供十六进制记法，这
也许是多字符常量技术首先得到发展的原因）。
B.9.3 const限定符
在C中，全局的const具有外部链接，但是在C++中，具有内部链接。也
就是说，下面C++的声明：
1629
const double PI = 3.14159;
相当于下面C中的声明：
static const double PI = 3.14159;
假设这两条声明都在所有函数的外部。C++规则的意图是为了在头文件
更加方便地使用 const。如果const变量是内部链接，每个包含该头文件的文
件都会获得一份const变量的备份。如果const变量是外部链接，就必须在一
个文件中进行定义式声明，然后在其他文件中使用关键字 extern 进行引用式
声明。
顺带一提，C++可以使用关键字extern使一个const值具有外部链接。所
以两种语言都可以创建内部链接和外部链接的const变量。它们的区别在于
默认使用哪种链接。
另外，在C++中，可以用const来声明普通数组的大小：
const int ARSIZE = 100;
double loons[ARSIZE]; /* 在C++中，与double loons[100];相同 */
当然，也可以在C99中使用相同的声明，不过这样的声明会创建一个变
长数组。
在C++中，可以使用const值来初始化其他const变量，但是在C中不能这
样做：
const double RATE = 0.06;      // C++和C都可以
const double STEP = 24.5;      // C++和C都可以
const double LEVEL = RATE * STEP; // C++可以，C不可以
B.9.4 结构和联合
1630
声明一个有标记的结构或联合后，就可以在C++中使用这个标记作为类
型名：
struct duo
{
int a;
int b;
};
struct duo m; /* C和C++都可以 */
duo n; /* C不可以，C++可以*/
结果是结构名会与变量名冲突。例如，下面的程序可作为C程序编译，
但是作为C++程序编译时会失败。因为C++把printf()语句中的duo解释成结构
类型而不是外部变量：
#include 
float duo = 100.3;
int main(void)
{
struct duo { int a; int b;};
struct duo y = { 2, 4};
printf ("%f\n", duo); /* 在C中没问题，但是在C++不行 */
return 0;
1631
}
在C和C++中，都可以在一个结构的内部声明另一个结构：
struct box
{
struct point {int x; int y; } upperleft;
struct point lowerright;
};
在C中，随后可以使用任意使用这些结构，但是在C++中使用嵌套结构
时要使用一个特殊的符号：
struct box ad;    /* C和 C++都可以 */
struct point dot;   /* C可以，C++不行 */
box::point dot;    /* C不行，C++可以 */
B.9.5 枚举
C++使用枚举比C严格。特别是，只能把enum常量赋给enum变量，然后
把变量与其他值作比较。不经过显式强制类型转换，不能把int类型值赋给
enum变量，而且也不能递增一个enum变量。下面的代码说明了这些问题：
enum sample {sage, thyme, salt, pepper};
enum sample season;
season = sage;      /* C和C++都可以 */
season = 2;       /* 在C中会发出警告，在C++中是一个错误 */
1632
season = (enum sample) 3; /* C和C++都可以*/
season++;      /* C可以，在C++中是一个错误 */
另外，在C++中，不使用关键字enum也可以声明枚举变量：
enum sample {sage, thyme, salt, pepper};
sample season;  /* C++可以，在C中不可以 */
与结构和联合的情况类似，如果一个变量和enum类型的同名会导致名
称冲突。
B.9.6 指向void的指针
C++可以把任意类型的指针赋给指向void的指针，这点与C相同。但是
不同的是，只有使用显式强制类型转换才能把指向void的指针赋给其他类型
的指针。下面的代码说明了这一点：
int ar[5] = {4, 5, 6,7, 8};
int * pi;
void * pv;
pv = ar;     /* C和C++都可以 */
pi = pv;     /* C可以，C++不可以 */
pi = (int * ) pv; /* C和C++都可以 */
C++与C的另一个区别是，C++可以把派生类对象的地址赋给基类指
针，但是在C中没有这里涉及的特性。
B.9.7 布尔类型
1633
在C++中，布尔类型是bool，而且ture和false都是关键字。在C中，布尔
类型是_Bool，但是要包含stdbool.h头文件才可以使用bool、true和false。
B.9.8 可选拼写
在C++中，可以用or来代替||，还有一些其他的可选拼写，它们都是关键
字。在C99和C11中，这些可选拼写都被定义为宏，要包含iso646.h才能使用
它们。
B.9.9 宽字符支持
在C++中，wchar_t是内置类型，而且wchar_t是关键字。在C99和C11
中，wchar_t类型被定义在多个头文件中（stddef.h、stdlib.h、wchar.h、
wctype.h）。与此类似，char16_t和char32_t都是C++11的关键字，但是在C11
中它们都定义在uchar.h头文件中。
C++通过iostream头文件提供宽字符I/O支持（wchar_t、char16_t和
char32_t），而 C99通过wchar.h头文件提供一种完全不同的I/O支持包。
B.9.10 复数类型
C++在complex头文件中提供一个复数类来支持复数类型。C有内置的复
数类型，并通过complex.h头文件来支持。这两种方法区别很大，不兼容。C
更关心数值计算社区提出的需求。
B.9.11 内联函数
C99支持了C++的内联函数特性。但是，C99的实现更加灵活。在
C++中，内联函数默认是内部链接。在 C++中，如果一个内联函数多次出现
在多个文件中，该函数的定义必须相同，而且要使用相同的语言记号。例
如，不允许在一个文件的定义中使用int类型形参，而在另一个文件的定义中
使用int32_t类型形参。即使用typedef把int32_t定义为int也不能这样做。但是
在C中可以这样做。另外，在第15章中介绍过，C允许混合使用内联定义和
外部定义，而C++不允许。
1634
B.9.12 C++11中没有的C99/C11特性
虽然在过去C或多或少可以看作是C++的子集，但是C99标准增加了一
些C++没有的新特性。下面列出了一些只有C99/C11中才有的特性：
指定初始化器；
复合初始化器（Compound initializer）；
受限指针（Restricted pointer）（即，restric指针）；
变长数组；
伸缩型数组成员；
带可变数量参数的宏。
注意
以上所列只是在特定时期内的情况，随着时间的推移和 C、C++的不断
发展，列表中的项会有所增减。例如，C++14新增的一个特性就与C99的变
长数组类似。
[1].也称为世界标准时间，简称UTC，从英文“Coordinated Universal Time”/法
文“Temps Universel Cordonné”而来。中国内地的时间与UTC的时差为+8，也
就是UTC+8。——译者注
[2].fwide()函数用于设置流的定向，根据mode的不同值来执行不同的工作。
——译者注
1635