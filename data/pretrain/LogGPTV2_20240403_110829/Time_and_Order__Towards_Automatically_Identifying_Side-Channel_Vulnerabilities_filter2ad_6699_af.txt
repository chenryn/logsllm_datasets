8050 b08 :
8050b0b :
89 1c 24
83 c3 02
e8 e0 63 00 00
_unguarded_linear_insert >
8050 b10 :
8050 b12 :
. . .
39 de
75 f1
%ebx ,(% esp )
$0x2,%ebx
8056 e f 0 
8056 ef 0 :
. . .
8056 f28 :
8056 f2a :
8056 f2 c :
8056 f 2 f :
8056 f32 :
8056 f36 :
8056 f39 :
8056 f3d :
8056 f40 :
8056 f42 :
8056 f45 :
89 c2
89 d8
0 f b7 18
66 89 1a
0 f b6 50 f f
8d 58 f e
0 f b6 70 f e
c1 e2 08
01 f2
66 39 ca
77 e1
%eax,%edx
%ebx,%eax
mov
mov
movzwl (%eax ),%ebx
%bx,(%edx )
mov
movzbl −0x1(%eax ),%edx
−0x2(%eax ),%ebx
l e a
movzbl −0x2(%eax ),% e s i
s h l
add
cmp
ja
$0x8,%edx
%e s i ,%edx
%cx,%dx
8056 f28 
. . .
Figure 4: The assembly code of std::sort
Figure 5: A subgraph of Gp for function std::sort
6.2.3 Hunspell
Hunspell is a popular spell checker. Xu et al. identiﬁed
that Hunspell is vulnerable to page-level controlled chan-
nel attacks due to its input-dependent access pattern to data
pages [43]. But its control ﬂow was considered immune to
side-channel attacks. However, as shown in Table 2, AN-
ABLEPS identiﬁes various control-ﬂow side-channel vulnera-
bilities that may be exploited by attackers.
With the help of ANABLEPS, we narrow down our atten-
tion to the get_parser() function of Hunspell, in which the
function std::sort(vector.begin(), vector.end()) is
called to sort the data in the vector. We found this function
both have cache-level and branch-level order-based vulnera-
bility and page-level time-based vulnerability. This is a func-
tion implemented in C++ standard library. After compilation,
n0get_parser()0x8050Order: {n1, n1, n1, n1}Time: {0.9, 0.8, 0.9, 0.8}n1_unguarded_linear_insert()0x8056Order: {n0, n0, n0, n0}Time: {6, 13, 19, 18}44454          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Associationthe linear insertion algorithm is used in this sort function
with the snippet of assembly code in Figure 4. According
to the code snippet of function get_parser(), the function
_unguarded_linear_insert() is called when an element
in the unsorted vector is to be inserted into the sorted vector.
As such, by monitoring the execution sequence that involves
this function, the attacker is able to learn the number of el-
ements to be sorted in page-level, cache-level and branch-
level. Moreover, function _unguarded_linear_insert()
contains a loop to compare the element to be inserted with
elements already in the sorted vector. According to the
insertion sort algorithm, the number of loops in function
_unguarded_linear_insert() reﬂects the number of com-
parisons during the insertion, which can be used to infer the
location of an element after the insertion.
Such leakage can be easily identiﬁed in Gps with time-
based vulnerability. A subgraph of G i
p of a particular input
Ii is shown in Figure 5. The edge n0 → n1 is executed 4
times, which reﬂects that four elements are being sorted.
The elements of Time list in node n1 reveals the number of
comparisons in function _unguarded_linear_insert():
the ﬁrst element corresponds to no comparison, the second
element corresponds to 1 comparison, the third and fourth
elements correspond to 2 comparisons. Therefore, the page
level order-based vulnerability in Hunspell, or more precisely
the sort algorithm implemented in the standard C++ library,
can only leak the number of elements to be sorted; however,
the time-based vulnerability can be exploited to leak the list
to be sorted if sorting result is known. We specially tested the
sort algorithm by providing a set of |I| unsorted lists that
correspond to the same sorted list after sorting. As expected,
ANABLEPS reports |E(p,I )| = |I| for this set of inputs.
7 Limitations and Future Work
Although we have demonstrated that ANABLEPS is capable
of identifying side-channel vulnerabilities in enclave binaries,
we only made a ﬁrst step and there are a number of avenues
for future works. First, the currently design only considers
side-channel vulnerabilities due to secret-dependent control
ﬂows. Leakages due to secret-dependent data accesses are
out of scope currently. Interestingly, the differences in the
data access pattern caused by divergence in the control
ﬂow can actually be identiﬁed by ANABLEPS’s control-ﬂow
based vulnerability analysis. What is missed by ANABLEPS
is memory pointers or array indexes that are determined
by the secret values. One of the future works is to extend
ANABLEPS in handling of these vulnerabilities.
Second, while ANABLEPS has integrated the state-of-the-
art input generation tools such as fuzzing and concolic exe-
cution, it still cannot generate the complete set of input. Cur-
rently, we rely on developers’ knowledge to remediate this
limitation since developers have the best understanding of the
semantic of the enclave program and its input space. Certainly,
any advances in the research of test case generation itself will
improve ANABLEPS.
Third, the capability of the constraint solver is limited.
Given an input to a program, ANABLEPS relies on symbolic
execution to collect constraints. These constraints are solved
by a constraint solver to determine the size of G i’s input
space. However, not all the constraints can be solved (e.g.,
hash functions). Also, a solver may take too much time to
solve a constraint. Currently, ANABLEPS requires the solver
to return the result in 90 minutes. Otherwise, it considers
unsolvable. Any advancement of constraint solver will make
ANABLEPS more efﬁcient.
8 Conclusion
In conclusion, we designed and implemented ANABLEPS, a
software tool for automatically vetting side-channel vulner-
abilities in SGX enclave programs. ANABLEPS is the ﬁrst
side-channel vulnerability analysis tool that considers both
time and order of a program’s memory access patterns. It
leverages concolic execution and fuzzing techniques to gen-
erate input sets for an arbitrary enclave program, constructs
extended dynamic control-ﬂow graph representation of exe-
cution traces using Intel PT, and automatically analyzes and
identiﬁes side-channel vulnerabilities using graph analysis.
With ANABLEPS, we have uncovered a large number of side
channel leaks in enclave binaries we tested. Our experimen-
tal results also demonstrate ANABLEPS can be used by both
security analysts and software developers to identify the side-
channel vulnerabilities for enclave programs.
Acknowledgments
We would like to thank the anonymous reviewers for their
very helpful comments. This work was supported in part by
the NSF grants 1750809, 1718084, 1834213, 1834215, and
1834216 as well as a research gift from Intel.
References
[1] american fuzzy lop. http://lcamtuf.coredump.cx/afl/.
(Accessed on 04/28/2018).
[2] Graphene / graphene-SGX library os - a library os for linux
multi-process applications, with intel SGX support. https:
//github.com/oscarlab/graphene.
[3] libipt - an intel(r) processor trace decoder library. https:
//github.com/01org/processor-trace.
[4] Lists of instruction latencies, throughputs and micro-operation
breakdowns for intel, amd and via cpus. https://www.agner.
org/optimize/instruction_tables.pdf.
[5] pyelftools - parsing elf and dwarf in python. https://github.
com/eliben/pyelftools.
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 455guard
extensions
software
guide.
[6] Intel R(cid:13)
writer’s
com/sites/default/files/managed/ae/48/
Software-Guard-Extensions-Enclave-Writers-Guide.
pdf, 2017. Revision 1.02, Accessed May, 2017.
enclave
https://software.intel.
[7] E. Bauman and Z. Lin. A case for protecting computer
games with SGX.
In Proceedings of the 1st Workshop on
System Software for Trusted Execution (SysTEX’16), Decem-
ber 2016.
[8] A. Baumann, M. Peinado, and G. Hunt. Shielding applications
from an untrusted cloud with haven. ACM Transactions on
Computer Systems (TOCS’15), 2015.
[9] F. Brasser, U. Müller, A. Dmitrienko, K. Kostiainen, S. Capkun,
and A.-R. Sadeghi. Software grand exposure: SGX cache
attacks are practical.
In USENIX Workshop on Offensive
Technologies, 2017.
[10] G. Chen, S. Chen, Y. Xiao, Y. Zhang, Z. Lin, and T. H. Lai.
Stealing intel secrets from SGX enclaves via speculative execu-
tion. In Proceedings of the 2019 IEEE European Symposium
on Security and Privacy, June 2019.
[11] G. Chen, W. Wang, T. Chen, S. Chen, Y. Zhang, X. Wang,
T.-H. Lai, and D. Lin. Racing in hyperspace: Closing hyper-
threading side channels on SGX with contrived data races.
In 2018 IEEE Symposium on Security and Privacy (SP’18).
IEEE, 2018.
[12] S. Chen, X. Zhang, M. K. Reiter, and Y. Zhang. Detecting
privileged side-channel attacks in shielded execution with
déjà vu. In 12th ACM on Asia Conference on Computer and
Communications Security (ASIA CCS ’17). ACM.
[13] V. Costan and S. Devadas. Intel SGX explained. Technical
report, Cryptology ePrint Archive, Report 2016/086, 20 16.
http://eprint. iacr. org.
[14] Y. Fu, E. Bauman, R. Quinonez, and Z. Lin. Sgx-lapd: Thwart-
ing controlled side channel attacks via enclave veriﬁable page
faults. In Proceedings of the 20th International Symposium
on Research in Attacks, Intrusions and Defenses (RAID’17),
September 2017.
[15] J. Götzfried, M. Eckert, S. Schinzel, and T. Müller. Cache
attacks on intel SGX. In 10th European Workshop on Systems
Security (EuroSec’17). ACM, 2017.
[16] D. Gruss, J. Lettner, F. Schuster, O. Ohrimenko, I. Haller,
and M. Costa. Strong and efﬁcient cache side-channel pro-
In USENIX
tection using hardware transactional memory.
Security Symposium (USENIX Security’17). USENIX Asso-
ciation, 2017.
[17] M. Hähnel, W. Cui, and M. Peinado. High-resolution side
channels for untrusted operating systems. In 2017 USENIX
Annual Technical Conference (USENIX ATC 17). USENIX
Association,, 2017.
[18] S. M. Kim, J. Han, J. Ha, T. Kim, and D. Han. Enhancing secu-
rity and privacy of tor’s ecosystem by using trusted execution
environments. In (NSDI’17), 2017.
[19] P. Kocher, D. Genkin, D. Gruss, W. Haas, M. Hamburg,
M. Lipp, S. Mangard, T. Prescher, M. Schwarz, and Y. Yarom.
Spectre attacks: Exploiting speculative execution. ArXiv
e-prints, Jan. 2018.
[20] S. Lee, M.-W. Shih, P. Gera, T. Kim, H. Kim, and M. Peinado.
Inferring ﬁne-grained control ﬂow inside SGX enclaves with
branch shadowing.
In 26th USENIX Security Symposium
(USENIX Security’17). USENIX Association, 2017.
[21] M. Lipp, M. Schwarz, D. Gruss, T. Prescher, W. Haas, S. Man-
gard, P. Kocher, D. Genkin, Y. Yarom, and M. Hamburg. Melt-
down. ArXiv e-prints, Jan. 2018.
[22] O. Oleksenko, B. Trach, R. Krahn, M. Silberstein, and C. Fetzer.
Varys: Protecting SGX enclaves from practical side-channel
attacks.
In 2018 USENIX Annual Technical Conference
(USENIX ATC 18). USENIX Association, 2018.
[23] D. A. Osvik, A. Shamir, and E. Tromer. Cache attacks and
In 6th Cryptographers’
countermeasures: the case of AES.
track at the RSA conference on Topics in Cryptology, 2006.
[24] C. Percival. Cache missing for fun and proﬁt. In 2005 BSDCan,
2005.
[25] F. Schuster, M. Costa, C. Fournet, C. Gkantsidis, M. Peinado,
G. Mainar-Ruiz, and M. Russinovich. Vc3: Trustworthy data
analytics in the cloud using SGX. In 2015 IEEE Symposium
on Security and Privacy (SP’15). IEEE, 2015.
[26] M. Schwarz, S. Weiser, D. Gruss, C. Maurice, and S. Man-
gard. Malware guard extension: Using SGX to conceal cache
attacks. Springer International Publishing, 2017.
[27] J. Seo, B. Lee, S. Kim, M.-W. Shih, I. Shin, D. Han, and
T. Kim. SGX-shield: Enabling address space layout random-
ization for SGX programs.
In In Proceedings of the 2017
Annual Network and Distributed System Security Symposium
(NDSS), 2017.
[28] M.-W. Shih, S. Lee, T. Kim, and M. Peinado. T-SGX: Erad-
icating controlled-channel attacks against enclave programs.
In Proceedings of the 2017 Annual Network and Distributed
System Security Symposium (NDSS’17), 2017.
[29] S. Shinde, Z. L. Chua, V. Narayanan, and P. Saxena. Prevent-
ing page faults from telling your secrets. In 11th ACM on
Asia Conference on Computer and Communications Security
(ASIA CCS’16). ACM, 2016.
[30] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Cor-
betta, Y. Shoshitaishvili, C. Kruegel, and G. Vigna. Driller:
Augmenting fuzzing through selective symbolic execution. In
(NDSS’16), 2016.
[31] C.-C. Tsai, D. E. Porter, and M. Vij. Graphene-SGX: A
practical library os for unmodiﬁed applications on SGX. In
Proceedings of the USENIX Annual Technical Conference
(ATC’17), 2017.
[32] J. Van Bulck, M. Minkin, O. Weisse, D. Genkin, B. Kasikci,
F. Piessens, M. Silberstein, T. F. Wenisch, Y. Yarom, and
R. Strackx.
Foreshadow: Extracting the keys to the in-
tel SGX kingdom with transient out-of-order execution. In
27th USENIX Security Symposium (USENIX Security’18).
USENIX Association, 2018.
[33] J. Van Bulck, F. Piessens, and R. Strackx. SGX-step: A prac-
tical attack framework for precise enclave execution control.
In Proceedings of the 2Nd Workshop on System Software for
Trusted Execution, (SysTEX’17), 2017.
456          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Association[34] J. Van Bulck, F. Piessens, and R. Strackx. Nemesis: Studying
microarchitectural timing leaks in rudimentary cpu interrupt
logic. In Proceedings of the 2018 ACM SIGSAC Conference
on Computer and Communications Security (CCS’18). ACM,
2018.
[35] J. Van Bulck, N. Weichbrodt, R. Kapitza, F. Piessens, and
R. Strackx.
Telling your secrets without page faults:
Stealthy page table-based attacks on enclaved execution.
In Proceedings of the 26th USENIX Security Symposium
(USENIX Security’17). USENIX Association, 2017.
[36] R. Wang, Y. Shoshitaishvili, A. Bianchi, A. Machiry, J. Grosen,
P. Grosen, C. Kruegel, and G. Vigna. Ramblr: Making re-
assembly great again.
In Proceedings of the 24th Annual
Symposium on Network and Distributed System Security
(NDSS’17), 2017.
[37] S. Wang, P. Wang, X. Liu, D. Zhang, and D. Wu. Cached: Iden-
tifying cache-based timing channels in production software. In
26th USENIX Security Symposium (USENIX Security’17).
USENIX Association, 2017.
[38] W. Wang, G. Chen, X. Pan, Y. Zhang, X. Wang, V. Bind-
schaedler, H. Tang, and C. A. Gunter. Leaky cauldron on
the dark land: Understanding memory side-channel hazards
in SGX.
In Proceedings of the ACM SIGSAC Conference
on Computer and Communications Security, (CCS’17). ACM,
2017.
[39] S. Weiser, A. Zankl, R. Spreitzer, K. Miller, S. Mangard, and
G. Sigl. DATA – differential address trace analysis: Find-
ing address-based side-channels in binaries. In 27th USENIX
Security Symposium (USENIX Security’18). USENIX Asso-
ciation, 2018.
[40] J. Wichelmann, A. Moghimi, T. Eisenbarth, and B. Sunar.
Microwalk: A framework for ﬁnding side channels in bina-
ries.
In Proceedings of the 34th Annual Computer Security
Applications Conference. ACM, 2018.
[41] J. C. Wray. An analysis of covert timing channels. J. Comput.
Secur., 1992.
[42] Y. Xiao, M. Li, S. Chen, and Y. Zhang. Stacco: Differen-
tially analyzing side-channel traces for detecting SSL/TLS
vulnerabilities in secure enclaves. In Proceedings of the ACM
SIGSAC Conference on Computer and Communications
Security, (CCS’17). ACM, 2017.
[43] Y. Xu, W. Cui, and M. Peinado. Controlled-channel attacks:
Deterministic side channels for untrusted operating systems.
In Proceedings of the 2015 IEEE Symposium on Security and
Privacy (SP’15). IEEE, 2015.
[44] F. Zhang, E. Cecchetti, K. Croman, A. Juels, and E. Shi.
Town crier: An authenticated data feed for smart contracts.
In Proceedings of the 2016 ACM SIGSAC Conference on
Computer and Communications Security (CCS’16). ACM,
2016.
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 457