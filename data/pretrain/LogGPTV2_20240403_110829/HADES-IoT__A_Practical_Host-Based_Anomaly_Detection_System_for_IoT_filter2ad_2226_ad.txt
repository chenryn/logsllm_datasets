enforcing mode of HADES-IoT. The signed command, together with
PKi, authentication path APi, and ID of the leaf i are sent to the
user space application that passes them to the kernel space appli-
cation of HADES-IoT. HADES-IoT verifies the authenticity of the
message using delivered content and embedded master public key
(see Section 5.2). As part of the verification, the ID of the message
is compared to the reply counter, and if this ID is smaller or equal,
then the authentication fails due to reply attack check, otherwise
authentication is successful, and the reply counter is updated. After
authentication of the message, protection by HADES-IoT is dis-
abled, and the user receives an acknowledgment, so he can execute
firmware update. Once the device is updated, the signed command
instructing HADES-IoT to perform the profiling and subsequently
to enable the protection is sent. The verification of the authentic-
ity is performed in the same way as in the previous case, and if
successful, the protection is enabled.
6 EVALUATION
We implemented a proof-of-concept of HADES-IoT and tested it on
seven IoT devices (see Table 1). In this section, we start by demon-
strating that HADES-IoT can be deployed by a manufacturer as
well as by an end user. Furthermore, we experiment with various
profiling time periods and determine the minimal amount of time
Figure 7: Firmware update procedure.
required to extract an accurate profile. Then, we evaluate the de-
tection performance of HADES-IoT on vulnerabilities exploited by
recent IoT malware and measure resource consumption.
6.1 Precompilation of HADES-IoT
To ensure that configuration options and features of HADES-IoT’s
LKM match the kernel of a targeted IoT device (see Section 3.2), we
went through a process in which we determined the minimal set
of such features and options enabling us to run HADES-IoT. First,
we selected several IoT devices (i.e., D-Link DCS-942L, Provision
PT-737E, SimpleHome XCS7-1001), cases in which manufacturers
provided the kernel source code and configuration.8 With the se-
lected set of devices, we cross-compiled HADES-IoT against the
manufacturer’s custom Linux kernels using the default configu-
ration created by the manufacturer. We used the manufacturer’s
toolchain for the compilation of HADES-IoT and verified success-
ful deployment. In the next step, using Linux kernel archives,9
we downloaded the source code of the generic Linux kernel with
the version matching that of the manufacturer. Then, we selected
the default configuration file of the architecture model closest to
the architecture model of the IoT device, modified it to match the
manufacturer’s configuration as much as possible, and compiled
HADES-IoT against the kernel. After that, we kept selectively re-
moving parts of manufacturer’s configuration to determine the
minimal options that must match in order to successfully deploy
HADES-IoT. We found that only a few options must match for all
of the tested IoT devices, and more importantly, the information
8Note that in the case of legacy devices, manufactures may not provide it.
9https://www.kernel.org/
IoT DevicePrecompile HADES-IoTHADES-IoT binaryProfile HADES-IoTUserIntegrate master public key to HADES-IoTUser buys the deviceRun deviceGenerate seed SGenerate master public keyHADES-IoTUser space appSign command “disable”User{disable}SKi, PKi, APi, i{disable}SKi, PKi, APi, iVerify authenticity of message and iUpdate reply counter to i Disable protectionUpdate IoT deviceSign command “profile & enable”{profile & enable}SKi+1, PKi+1, APi+1, i+1Verify authenticity of message and i+1Update reply counter to i+1AckiAckiAcki+1Acki+1SKi = F(S||i)PKi = h(SKi)SKi+1 = F(S||i+1)PKi+1 = h(SKi+1){profile & enable}SKi+1, PKi+1, APi+1, i+1Profile and ProtectDevice
Netgear WNR2000v3
ASUS RT-N16
ASUS RT-N56U
Cisco Linksys E4200
D-Link DCS-942L
SimpleHome XCS7-1001
Provision PT-737E
Router
Router
Router
Router
Total
Memory
[MB]
32
128
128
64
128
32
32
Available
Memory
[MB]
16.06
87.22
78.56
18.63
38.75
1.90
3.88
265.2
239.2
249.3
239.2
534.5
218.7
218.7
Type
Kernel
Version
CPU
Architecture
CPU
Performance
[BoдoMips]
2.6.15
2.6.21
2.6.21
2.6.22
2.6.28
3.0.8
3.4.35
MIPS
MIPSel
MIPSel
MIPSel
ARM
ARM
ARM
IP Camera
IP Camera
IP Camera
Table 1: IoT devices used in the evaluation.
about such options can always be extracted directly from the IoT
device.
After identifying the minimal configurations, we investigated
whether HADES-IoT can be deployed on an IoT device without
the support of the manufacturer. In order to accomplish this, we
used a publicly available generic Linux kernel and toolchain for
precompilation. We were able to precompile and deploy HADES-
IoT with generic resources for all of the tested IoT devices, which
indicates that HADES-IoT can be deployed not only by a manufac-
turer but also by an owner of an IoT device. Hence, HADES-IoT
can protect even legacy devices that are no longer supported by
the manufacturers.
6.1.1 Configuration. We identified two critical options that must
be adjusted in order to run HADES-IoT successfully on all of the
tested IoT devices. First, in Linux configuration the embedded-
application binary interface (EABI) must be enabled for successful
deployment. Second, the optimization in compiler must be set to
performance instead of size. If optimization is set incorrectly, then
HADES-IoT will be installed successfully in the kernel but will not
function properly. The details about specific configuration options
for the tested devices are presented in the following section.
6.1.2 Device-Specific Configuration Options. Some devices
require specific configuration options that must be adjusted in the
configuration file for the successful compilation and deployment of
HADES-IoT. In the following, we provide details about such devices,
the options they require, and the way how device-specific options
can be extracted.
D-Link DCS-942L: Linux is configured in a preemptive mode on
this device. Therefore, when configuring Linux options for
compilation, the preemptive mode must be enabled. Note
that in general, the value of this setting can be extracted
from file "/proc/version".
SimpleHome XCS7-1001: We found only one specific configura-
tion that must be modified. More specifically, the "CONFIG_-
ARM_UNWIND" must be disabled, otherwise, installation of
HADES-IoT will fail on compatibility check.
Provision PT-737E: Like the previous case, we must disable the
"CONFIG_ARM_UNWIND" option; however in contrast to
the previous device, we may also need to enable the "CONFIG_-
FS_POSIX_ACL" option. To determine whether it is necessary
to enable this option, the following commands should be
issued: "cat /proc/kallsyms | grep acl". In cases in which there
is a non-empty result, the options must be enabled.
6.2 Profiling Period
During bootstrapping, HADES-IoT must run in the profiling mode
that extracts the profile of an IoT device. The longer HADES-IoT
runs in this mode, the more accurate the extracted profile. However,
it can be inconvenient for a user when the profiling takes too long.
Therefore, we conducted an experiment in which we determined
the boundaries on the amount of profiling time needed to obtain
an accurate profile. We experimented with profiling times of one,
two, and four hours. The results of this experiment are presented in
Table 2. We can see that after one hour of profiling no new processes
were found on any of the devices, which means that an accurate
profile can be obtained even after one hour of profiling. On the other
hand, there is the possibility that a new program might be executed
or a new signal might be sent after a four hour profiling period (e.g.,
a scheduled job). However, with the update mechanism described
in Section 4.5.2, any missing program or signal can be added to the
whitelist after the profiling phase. Note that in this experiment, we
were not interested in the programs executed during the booting
of the device, since these are added into the whitelist regardless of
the length of the profiling time.
Next, we measured the difference in the whitelist size when a
user interacts with the GUI of a device and cases in which there is
no user interaction. The results show that on some devices, such as
Netgear WNR2000v3 and D-Link DCS-942L, the whitelist increases
significantly, while on devices, such as Cisco Linksys E4200 and
ASUS RT-N56U, the increase is only small. These results suggest
that it is important to interact with the device during the profiling
period, otherwise many programs and signals could be missed,
leading to a less accurate profile.
Finally, we compared the number of all executables to the number
of executables presented in the whitelist. Table 2 shows that each
device contains a large number of executables that are never used.
If an attacker compromises the device, none of these executables
can be used due to the protection provided by HADES-IoT – the
attacker is strictly limited to the executables in the whitelist.
6.3 Effectiveness of Detection & Prevention
To demonstrate the prevention capabilities of HADES-IoT, we per-
formed several attacks that exploit vulnerabilities used by recent
real-world IoT malware. We describe these attacks in the following.
6.3.1 Enabled Telnet with Default Credentials & Mirai. The
Mirai IoT malware takes advantage of the fact that many IoT de-
vices connected to the Internet have Telnet open by default, and
additionally, that the devices have default credentials configured
HADES-IoT: A Practical Host-Based Anomaly Detection System for IoT Devices
IoT Device
Netgear WNR2000v3
ASUS RT-N16
ASUS RT-N56U
Cisco Linksys E4200
D-Link DCS-942L
SimpleHome XCS7-1001
ProVision PT-737E
Total
Executables
Found
526
638
375
399
1256
588
482
No. of IDs
in Whitelist
1 hour
12
5
3
9
20
4
5
No. of IDs
in Whitelist
2 hours
12
5
3
9
20
4
5
No. of IDs
in Whitelist
4 hours
12
5
3
9
20
4
5
No. of IDs
in Whitelist
1 hour (User Inter).
61
38
6
11
105
29
9
Table 2: Effect of various profiling periods on the size of whitelist.
(SimpleHome IP camera in our set is such a case). However, with
HADES-IoT even such a default misconfiguration does not cause
harm, as execution of any unauthorized binary (e.g., Mirai binary)
is terminated upon its spawning, as witnessed by our evaluation.
[CVE-2017-8225] & IoTReaper, Persirai. CVE-2017-8225
6.3.2
represents a vulnerability of a custom HTTP server that does not
properly check access to .ini files and allows an attacker to retrieve
them; the authentication can be bypassed by providing an empty
string for a user name and a password. By exploiting this vulnerabil-
ity, the attacker can read the root credentials from the system.ini file,
as they are stored in plain text. When the attacker is in possession