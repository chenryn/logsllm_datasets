                err = check_alu_op(env, insn);
                if (err)
                    return err;
            //BPF_LDX指令
            } else if (class == BPF_LDX) {
                enum bpf_reg_type src_reg_type;
                /* check for reserved fields is already done */
                /* check src operand */
                err = check_reg_arg(regs, insn->src_reg, SRC_OP);
                if (err)
                    return err;
                err = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);
                if (err)
                    return err;
                src_reg_type = regs[insn->src_reg].type;
                /* check that memory (src_reg + off) is readable,
                 * the state of dst_reg will be updated by this func
                 */
                err = check_mem_access(env, insn->src_reg, insn->off,
                               BPF_SIZE(insn->code), BPF_READ,
                               insn->dst_reg);
                if (err)
                    return err;
                if (BPF_SIZE(insn->code) != BPF_W) {
                    insn_idx++;
                    continue;
                }
                if (insn->imm == 0) {
                    /* saw a valid insn
                     * dst_reg = *(u32 *)(src_reg + off)
                     * use reserved 'imm' field to mark this insn
                     */
                    insn->imm = src_reg_type;//判断出了一种指令类型，即地址取值指令
                } else if (src_reg_type != insn->imm &&
                       (src_reg_type == PTR_TO_CTX ||
                        insn->imm == PTR_TO_CTX)) {
                    /* ABuser program is trying to use the same insn
                     * dst_reg = *(u32*) (src_reg + off)
                     * with different pointer types:
                     * src_reg == ctx in one branch and
                     * src_reg == stack|map in some other branch.
                     * Reject it.
                     */
                    verbose("same insn cannot be used with different pointers\n");
                    return -EINVAL;
                }
            //BPF_STX指令
            } else if (class == BPF_STX) {
                enum bpf_reg_type dst_reg_type;
                if (BPF_MODE(insn->code) == BPF_XADD) {
                    err = check_xadd(env, insn);
                    if (err)
                        return err;
                    insn_idx++;
                    continue;
                }
                /* check src1 operand */
                err = check_reg_arg(regs, insn->src_reg, SRC_OP);
                if (err)
                    return err;
                /* check src2 operand */
                err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
                if (err)
                    return err;
                dst_reg_type = regs[insn->dst_reg].type;
                /* check that memory (dst_reg + off) is writeable */
                err = check_mem_access(env, insn->dst_reg, insn->off,
                               BPF_SIZE(insn->code), BPF_WRITE,
                               insn->src_reg);
                if (err)
                    return err;
                if (insn->imm == 0) {
                    insn->imm = dst_reg_type;
                } else if (dst_reg_type != insn->imm &&
                       (dst_reg_type == PTR_TO_CTX ||
                        insn->imm == PTR_TO_CTX)) {
                    verbose("same insn cannot be used with different pointers\n");
                    return -EINVAL;
                }
            //BPF_ST指令
            } else if (class == BPF_ST) {
                if (BPF_MODE(insn->code) != BPF_MEM ||
                    insn->src_reg != BPF_REG_0) {
                    verbose("BPF_ST uses reserved fields\n");
                    return -EINVAL;
                }
                /* check src operand */
                err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
                if (err)
                    return err;
                /* check that memory (dst_reg + off) is writeable */
                err = check_mem_access(env, insn->dst_reg, insn->off,
                               BPF_SIZE(insn->code), BPF_WRITE,
                               -1);
                if (err)
                    return err;
            //BPF_JMP指令
            } else if (class == BPF_JMP) {
                u8 opcode = BPF_OP(insn->code);
                //直接跳转CALL
                if (opcode == BPF_CALL) {
                    if (BPF_SRC(insn->code) != BPF_K ||
                        insn->off != 0 ||
                        insn->src_reg != BPF_REG_0 ||
                        insn->dst_reg != BPF_REG_0) {
                        verbose("BPF_CALL uses reserved fields\n");
                        return -EINVAL;
                    }
                    //在这个函数中会检查跳转的地址有无超过范围，函数的五个参数的参数类型(是否是key/value/map地址/stack_size等)，更新返回值寄存器，更新reg_state等。
                    err = check_call(env, insn->imm);
                    if (err)
                        return err;
                } else if (opcode == BPF_JA) {
                    if (BPF_SRC(insn->code) != BPF_K ||
                        insn->imm != 0 ||
                        insn->src_reg != BPF_REG_0 ||
                        insn->dst_reg != BPF_REG_0) {
                        verbose("BPF_JA uses reserved fields\n");
                        return -EINVAL;
                    }
                    insn_idx += insn->off + 1;
                    continue;
                } else if (opcode == BPF_EXIT) {
                    if (BPF_SRC(insn->code) != BPF_K ||
                        insn->imm != 0 ||
                        insn->src_reg != BPF_REG_0 ||
                        insn->dst_reg != BPF_REG_0) {
                        verbose("BPF_EXIT uses reserved fields\n");
                        return -EINVAL;
                    }
                    //r0保存返回值，bpf_exit为指令集合结束标志，在此之前检查有无写入值
                    /* eBPF calling convetion is such that R0 is used
                     * to return the value from eBPF program.
                     * Make sure that it's readable at this time
                     * of bpf_exit, which means that program wrote
                     * something into it earlier
                     */
                    err = check_reg_arg(regs, BPF_REG_0, SRC_OP);
                    if (err)
                        return err;
                    if (is_pointer_value(env, BPF_REG_0)) {
                        verbose("R0 leaks addr as return value\n");
                        return -EACCES;
                    }
                    //遇到一个exit就结束一个分支，回退到分叉处执行另一个branch，类似于走迷宫遍历路径
    process_bpf_exit:
                    insn_idx = pop_stack(env, &prev_insn_idx);
                    if (insn_idx code);
                if (mode == BPF_ABS || mode == BPF_IND) {
                    err = check_ld_abs(env, insn);
                    if (err)
                        return err;
                } else if (mode == BPF_IMM) {
                    err = check_ld_imm(env, insn);
                    if (err)
                        return err;
                    insn_idx++;
                } else {
                    verbose("invalid BPF_LD mode\n");
                    return -EINVAL;
                }
            } else {
                verbose("unknown insn class %d\n", class);
                return -EINVAL;
            }
            insn_idx++;
        }
        return 0;
    }
    //很有意思的是我在这里发现了一个非递归的DFS伪代码，应该是拿来帮助读者理解check中深度优先算法实现的代码。
    /* non-recursive DFS pseudo code
     * 1  procedure DFS-iterative(G,v):
     * 2      label v as discovered
     * 3      let S be a stack
     * 4      S.push(v)
     * 5      while S is not empty
     * 6            t <- S.pop()
     * 7            if t is what we're looking for:
     * 8                return t
     * 9            for all edges e in G.adjacentEdges(t) do
     * 10               if edge e is already labelled
     * 11                   continue with the next edge
     * 12               w <- G.adjacentVertex(t,e)
     * 13               if vertex w is not discovered and not explored
     * 14                   label e as tree-edge
     * 15                   label w as discovered
     * 16                   S.push(w)
     * 17                   continue at 5
     * 18               else if vertex w is discovered
     * 19                   label e as back-edge
     * 20               else
     * 21                   // vertex w is explored
     * 22                   label e as forward- or cross-edge
     * 23           label t as explored
     * 24           S.pop()
     *
     * convention:
     * 0x10 - discovered
     * 0x11 - discovered and fall-through edge labelled
     * 0x12 - discovered and fall-through and branch edges labelled
     * 0x20 - explored
     */
可以看到检查的逻辑很多，这些都是为了避免攻击者注入恶意代码到内核，在这些所有检查完成之后，会调用`__bpf_prog_run`函数来解码伪指令并运行，解码主要是通过一个表查找来进行的，不再展开，实现在`kernel/bpf/core.c`中。
    /**
     *  __bpf_prog_run - run eBPF program on a given context
     *  @ctx: is the data we are operating on
     *  @insn: is the array of eBPF instructions
     *
     * Decode and execute eBPF instructions.
     */
    static unsigned int __bpf_prog_run(void *ctx, const struct bpf_insn *insn)
    {
        u64 stack[MAX_BPF_STACK / sizeof(u64)];
        u64 regs[MAX_BPF_REG], tmp;
        static const void *jumptable[256] = {
            [0 ... 255] = &&default_label,