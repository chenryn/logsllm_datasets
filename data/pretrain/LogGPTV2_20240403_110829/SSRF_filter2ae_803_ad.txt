去主动调用 php-cgi，而 fastcgi 进程又提供了很多辅助功能比如内存管理，垃圾处理，保障了 cgi 的高效性，并且 CGI
此时是常驻在内存中，不会每次请求重新启动
**FastCGI Record**
Fastcgi其实是一个通信协议，和HTTP协议一样，都是进行数据交换的一个通道。
HTTP协议是浏览器和服务器中间件进行数据交换的协议，浏览器将HTTP头和HTTP体用某个规则组装成数据包，以TCP的方式发送到服务器中间件，服务器中间件按照规则将数据包解码，并按要求拿到用户需要的数据，再以HTTP协议的规则打包返回给服务器。
类比HTTP协议来说，fastcgi协议则是服务器中间件和某个语言后端进行数据交换的协议。Fastcgi协议由多个record组成，record也有header和body一说，服务器中间件将这二者按照fastcgi的规则封装好发送给语言后端，语言后端解码以后拿到具体数据，进行指定操作，并将结果再按照该协议封装好后返回给服务器中间件。
和HTTP头不同，record的头固定8个字节，body是由头中的contentLength指定，其结构如下：
    typedef struct {      /* Header */      unsigned char version; // 版本      unsigned char type; // 本次record的类型      unsigned char requestIdB1; // 本次record对应的请求id      unsigned char requestIdB0;  unsigned char contentLengthB1; // body体的大小      unsigned char contentLengthB0;  unsigned char paddingLength; // 额外块大小      unsigned char reserved;       /* Body */      unsigned char contentData[contentLength];      unsigned char paddingData[paddingLength];} FCGI_Record;
头由8个uchar类型的变量组成，每个变量1字节。其中，`requestId`占两个字节，一个唯一的标志id，以避免多个请求之间的影响；`contentLength`占两个字节，表示body的大小。
语言端解析了fastcgi头以后，拿到`contentLength`，然后再在TCP流里读取大小等于`contentLength`的数据，这就是body体。
Body后面还有一段额外的数据（Padding），其长度由头中的paddingLength指定，起保留作用。不需要该Padding的时候，将其长度设置为0即可。
可见，一个fastcgi record结构最大支持的body大小是2^16^，也就是65536字节
**FastCGI Type**
`Type`就是指定该record的作用。因为fastcgi一个record的大小是有限的，作用也是单一的，所以我们需要在一个TCP流里传输多个record。通过`type`来标志每个record的作用，用`requestId`作为同一次请求的id。
也就是说，每次请求，会有多个record，他们的`requestId`是相同的。
借用[该文章](http://blog.csdn.net/shreck66/article/details/50355729)中的一个表格，列出最主要的几种`type`（其他杂七杂八的上网查吧）：
type值 | 主要含义  
---|---  
1 | 在与php-fpm建立连接之后发送的第一个消息中的type值就得为1，用来表明此消息为请求开始的第一个消息  
2 | 异常断开与php-fpm的交互  
3 | 在与php-fpm交互中所发的最后一个消息中type值为此，以表明交互的正常结束  
4 | 在交互过程中给php-fpm传递环境参数时，将type设为此，以表明消息中包含的数据为某个name-value对  
5 | web服务器将从浏览器接收到的POST请求数据(表单提交等)以消息的形式发给php-fpm,这种消息的type就得设为5  
6 | php-fpm给web服务器回的正常响应消息的type就设为6  
7 | php-fpm给web服务器回的错误响应设为7  
看了这个表格就很清楚了，服务器中间件和后端语言通信，第一个数据包就是`type`为1的record，后续互相交流，发送`type`为4、5、6、7的record，结束时发送`type`为2、3的record。
当后端语言接收到一个`type`为4的record后，就会把这个record的body按照对应的结构解析成key-value对，这就是环境变量。环境变量的结构如下：
    typedef struct {      unsigned char nameLengthB0;  /* nameLengthB0  >> 7 == 0 */      unsigned char valueLengthB0; /* valueLengthB0 >> 7 == 0 */     unsigned char nameData[nameLength];      unsigned char valueData[valueLength];} FCGI_NameValuePair11;typedef struct {      unsigned char nameLengthB0;  /* nameLengthB0  >> 7 == 0 */      unsigned char valueLengthB3; /* valueLengthB3 >> 7 == 1 */      unsigned char valueLengthB2;      unsigned char valueLengthB1;      unsigned char valueLengthB0;      unsigned char nameData[nameLength];      unsigned char valueData[valueLength          ((B3 & 0x7f) > 7 == 1 */      unsigned char nameLengthB2;      unsigned char nameLengthB1;     unsigned char nameLengthB0;      unsigned char valueLengthB0; /* valueLengthB0 >> 7 == 0 */      unsigned char nameData[nameLength          ((B3 & 0x7f) > 7 == 1 */      unsigned char nameLengthB2;      unsigned char nameLengthB1;     unsigned char nameLengthB0;      unsigned char valueLengthB3; /* valueLengthB3 >> 7 == 1 */      unsigned char valueLengthB2;      unsigned char valueLengthB1;      unsigned char valueLengthB0;      unsigned char nameData[nameLength          ((B3 & 0x7f)  **不同搭建环境配置文件位置不同，最好手工搭建！类似phpstudy和宝塔面板等很多安全选项会进行删割**
>
> **从此处开始均为手动搭建的环境！搭建方法见文末**
>
> **非标注的环境，均为手工搭建**
**TCP 模式**
TCP 模式即是 php-fpm 进程会监听本机上的一个端口(默认 9000)，然后 nginx 会把客户端数据通过 fastcgi 协议传给 9000
端口，php-fpm 拿到数据后会调用 cgi 进程解析
nginx的配置文件像这个样子:
> /etc/nginx/sites-available/default
    location ~ \.php$ {      index index.php index.html index.htm;      include /etc/nginx/fastcgi_params;      fastcgi_pass 127.0.0.1:9000;      fastcgi_index index.php;      include fastcgi_params; }
Windows下的配置如图（PHPstudy弄的）
php-fpm 的配置文件像这个样子
> /etc/php/7.3/fpm/pool.d/www.conf
    listen=127.0.0.1:9000
**Unix Socket**
unix socket 其实严格意义上应该叫 unix domain socket，它是 unix
系统进程间通信（IPC）的一种被广泛采用方式，以文件（一般是.sock）作为 socket 的唯一标识（描述符），需要通信的两个进程引用同一个 socket
描述符文件就可以建立通道进行通信了。
具体原理这里就不讲了，但是此通信方式的性能会优于 TCP
> 位置同上
    location~\.php${      index index.php index.html index.htm;      include /etc/nginx/fastcgi_params;      fastcgi_pass unix:/run/php/php7.3-fpm.sock;      fastcgi_index index.php;      include fastcgi_params;}
> 位置同上
    listen = /run/php/php7.3-fpm.sock
###  Nginx和IIS7的解析漏洞
Nginx和IIS7曾经出现过一个PHP相关的解析漏洞，该漏洞现象是，在用户访问`http://127.0.0.1/favicon.ico/.php`时，访问到的文件是favicon.ico，但却按照.php后缀解析了。
用户请求`http://127.0.0.1/favicon.ico/.php`，nginx将会发送如下环境变量到fpm里：
    {    ...    'SCRIPT_FILENAME': '/var/www/html/favicon.ico/.php',    'SCRIPT_NAME': '/favicon.ico/.php',    'REQUEST_URI': '/favicon.ico/.php',    'DOCUMENT_ROOT': '/var/www/html',    ...}
正常来说，`SCRIPT_FILENAME`的值是一个不存在的文件`/var/www/html/favicon.ico/.php`，是PHP设置中的一个选项`fix_pathinfo`导致了这个漏洞。PHP为了支持Path
Info模式而创造了`fix_pathinfo`，在这个选项被打开的情况下，fpm会判断`SCRIPT_FILENAME`是否存在，如果不存在则去掉最后一个`/`及以后的所有内容，再次判断文件是否存在，往次循环，直到文件存在。
所以，第一次fpm发现`/var/www/html/favicon.ico/.php`不存在，则去掉`/.php`，再判断`/var/www/html/favicon.ico`是否存在。显然这个文件是存在的，于是被作为PHP文件执行，导致解析漏洞。
正确的解决方法有两种，一是在Nginx端使用`fastcgi_split_path_info`将path
info信息去除后，用tryfiles判断文件是否存在；二是借助PHP-FPM的`security.limit_extensions`配置项，避免其他后缀文件被解析。
###  Security.Limit_Extensions配置项