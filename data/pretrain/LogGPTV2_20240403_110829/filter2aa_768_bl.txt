置好引导扇区的内容。引导的职责通常是加载操作系统的加载程序（OS Loader）。OS 
Loader 得到控制权后，再进一步加载操作系统的内核和其它程序。本期我们就以 Windows 
Vista 操作系统为例谈一谈 OS Loader 的工作过程以及如何调试这一阶段的问题。 
切换工作模式
切换工作模式
切换工作模式
切换工作模式 
我们知道，对于 x86 CPU 来说，不管它是否支持 32 位或 64 位，在它复位后都是处
于 16 位的实地址模式。在 BIOS 阶段，CPU 可能被切换到保护模式，但是在 BIOS 把控
制权移交给主引导记录前，它必须将 CPU 恢复回实模式，这是一直保持下来的传统。对
于使用 EFI 固件的系统，固件可以在保护模式下把控制权移交给操作系统的加载程序。但
本文仍旧讨论传统的方式。 
因为实模式下的每个段最大只有 64K，而且只能直接访问 1MB 的内存，这个空间是
无法容纳今天的主流操作系统的核心文件的，所以 OS Loader 首先要做的一件事就是把
CPU 切换到可以访问更大空间的保护模式。 
在切换到保护模式前，应该先建立好全局描述符表（GDT）和中断描述符表（IDT）。
通常在 OS Loader 阶段不会开启 CPU 的分页机制（Paging），而且描述符表中的每个段的
基地址通常都设置为 0，界限设置为 0xFFFFFFFF，这样便可以在程序中自由访问 4GB 的
地址空间，而且线性地址的值就等于物理地址的值，这里使用内存空间的方法就是所谓的
平坦模式（Flat Model）。以Windows Vista操作系统为例，它的引导管理器程序BootMgr.EXE
内部既有 16 位代码又有 32 位代码，16 位代码先执行，在验证文件的完好后，会切换到
保护模式，并把内嵌的 32 位程序映射到 0x400000 开始的内存区，然后把控制权移交给
32 位代码的起始函数 BmMain。此时观察 CR0 寄存器，可以看到代表保护模式的位 0 已
经为 1。 
kd> r cr0 
《软件调试》补编 
- 160 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
cr0=00000013 
但是代表分页机制的位 31 为 0，说明没有启用分页。观察代码段和数据段的段描述
符： 
kd> dg cs 
                                  P Si Gr Pr Lo 
Sel    Base     Limit     Type    l ze an es ng Flags 
---- -------- -------- ---------- - -- -- -- -- -------- 
0020 00000000 ffffffff Code RE Ac 0 Bg Pg P  Nl 00000c9b 
kd> dg ds 
                                  P Si Gr Pr Lo 
Sel    Base     Limit     Type    l ze an es ng Flags 
---- -------- -------- ---------- - -- -- -- -- -------- 
0030 00000000 ffffffff Data RW Ac 0 Bg Pg P  Nl 00000c93 
可见，它们的基地址都是 0，边界都是 0xFFFFFFFF，这正是平坦模式的典型特征。
分别使用 dd 命令和!dd（观察物理地址）观察同一个地址值： 
kd> dd idtr l4 
0001f080  00500390 00008f00 002073b0 00448e00 
kd> !dd idtr l4 
#   1f080 00500390 00008f00 002073b0 00448e00 
显示的内容是一样的，这说明线性地址与它所对应的物理地址的值是相等的。 
休眠
休眠
休眠
休眠（
（
（
（Hibernation）
）
）
）支持
支持
支持
支持 
在执行 BlImgQueryCodeIntegrityBootOptions 函数和 BmFwVerifySelfIntegrity 函数对自
身的完整性做进一步检查后，BootMgr 会调用 BmResumeFromHibernate 检查是否需要从休
眠（Hibernation）中恢复，如果需要，那么它会加载 WinResume.exe，并把控制权移交给
它。 
显示启动菜单
显示启动菜单
显示启动菜单
显示启动菜单 
BootMgr 会从系统的引导配置数据（Boot Configuration Data，简称 BCD）中读取启动
设置信息，如果有多个启动选项，那么它会显示出启动菜单。清单 1 中的栈回溯显示的便
是 BootMgr 在显示启动菜单后等待用户选择时的状态。 
清单 1 等待用户选择启动项 
kd> kn 
 # ChildEBP RetAddr   
00 00061e34 00432655 bootmgr!DbgBreakPoint 
01 00061e44 00431c24 bootmgr!BlXmlConsole::getInput+0xe 
02 00061e90 00402e8f bootmgr!OsxmlBrowser::browse+0xe0 
03 00061e98 00402b5e bootmgr!BmDisplayGetBootMenuStatus+0x13 
04 00061f10 004017ce bootmgr!BmDisplayBootMenu+0x174 
05 00061f6c 00401278 bootmgr!BmpGetSelectedBootEntry+0xf8 
06 00061ff0 00020a9a bootmgr!BmMain+0x278 
WARNING: Frame IP not in any known module. Following frames may be wrong. 
07 00000000 f000ff53 0x20a9a 
08 00000000 00000000 0xf000ff53 
栈帧 6 中的 BmMain 便是 BootMgr 的 32 位代码的入口函数，栈帧 4 中的
BmDisplayBootMenu 是显示启动菜单的函数，栈帧 7 和 8 是在实模式中执行时的痕迹。 
《软件调试》补编 
- 161 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
执行用户选择的启动项
执行用户选择的启动项
执行用户选择的启动项
执行用户选择的启动项 
当用户选择一个启动选项后，BootMgr 会调用 函数来准备引导对应的操作系统。如
果系统上有 Windows XP 或者更老的 Windows，而且用户选择了这些项，那么 BootMgr
会加载 NTLDR 来启动它们。如果用户选择的是 Windows Vista 的启动项，那么 BootMgr
会寻找和加载 WinLoad.exe，如果没有找到或者在检查文件的完整性时发现问题，那么
BootMgr 会显示出图 1 所示的错误界面。 
在成功加载 WinLoad.exe 后，BootMgr 会为其做一系列其它准备，包括启用新的 GDT
和 IDT，然后调用平台相关的控制权移交函数把执行权移交给 WinLoad。在 x86 平台中，
完成这一任务的是 Archx86TransferTo32BitApplicationAsm 函数。至此，BootMgr 完成使命，
WinLoad 开始工作。 
加载系统核心文件
加载系统核心文件
加载系统核心文件
加载系统核心文件 
WinLoad 的主要任务是把操作系统内核加载到内存，并为它做好“登基”的准备。它
首先要做的一件事就是进一步改善运行环境，启用 CPU 的分页机制。然后初始化自己的
支持库，如果启用了引导调试支持（稍后介绍），那么它会初始化调试引擎。 
图 1 加载 WinLoad.exe 失败时的错误提示 
接下来 WinLoad 会读取启动参数，决定是否显示高级启动菜单，高级菜单中含有以
安全模式启动等选项，也叫 Windows Error Recovery 菜单。如果用户按了 F8 或者上次没
有正常关机，那么 WinLoad 便会显示高级启动菜单。 
接下来要做的一个重要工作是读取和加载注册表的 System Hive，因为其中包含了更
多的系统运行参数，负责这项工作的是 OslpLoadSystemHive 函数。 
做好以上工作后，WinLoad 开始它的核心任务，那就是加载操作系统的内核文件和引
导类型的设备驱动程序。它首先加载的是 NTOSKRNL.EXE，这个文件包含了 Windows
操作系统的内核和执行体。此时真正的磁盘和文件系统驱动程序还没有加载进来，所以
WinLoad 是使用它自己的文件访问函数来读取文件的。例如，FileIoOpen 函数便是用来打
开一个文件的， 
如果 FileIoOpen 打开文件失败，那么调用它的 BlpFileOpen 函数会返回错误码
0C000000Dh，否则返回 0 代表成功。 
《软件调试》补编 
- 162 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
其中，PSHED.DLL 用于支持 WHEA（Windows Hardware Error Architecture）（《软件
调试》第 17 章有详细介绍），HAL.DLL 是硬件抽象层模块，BOOTVID.DLL 用于引导期
间和发生蓝屏时的显示，KDCOM.DLL 用于支持内核调试，CLFS.SYS 是支持日志的内核
模块，CI.DLL 是用于检查模块的完整性的（Code Integrity）。 
加载好系统模块后，WinLoad 还需要加载引导类型（Boot Type）的设备驱动程序，在
安装驱动程序时，每个驱动程序都会指定启动类型（Start Type），这个设置决定了驱动程
序的加载时机，指定为引导类型的驱动程序是最先被加载的。 
接下来加载的是硬件抽象层模块 HAL.DLL，支持调试的 KDCOM.DLL 和它们的依赖
模块。使用 Depends 工具可以观察一个 PE 模块所依赖的其它模块，例如，图 2 显示出了
内核文件 NTOSKRNL.EXE 所依赖的其它模块。 
图 2 使用 DEPENDS 工具观察 NTOSKRNL.EXE 所依赖的其它模块 
如果在加载以上程序模块或者注册表的过程中找不到需要的文件或者在检查文件的
完整性时发现异常，那么 WinLoad 便会提示错误而停止继续加载，我们在 08 年第 11 期
中提到的问题便是与此有关的。当遇到这样的问题时，可以使用安装光盘引导，然后恢复
丢失或者被破坏的文件。 
完成模块加载后，WinLoad 开始准备把执行权移交给内核，包括为内核准备新的 GDT
和 IDT（OslArchpKernelSetupPhase0）和建立内存映射（OslBuildKernelMemoryMap）等。
所有准备工作做完后，WinLoad 调用 OslArchTransferToKernel 函数把供内核使用的 GDT
和 IDT 地址加载到 CPU 中，然后调用内核的入口函数，正式把控制权移交个内核。 
启用调试选项
启用调试选项
启用调试选项
启用调试选项 
Windows Vista 的 BootMgr 和 WinLoad 程序内部都集成了调试引擎，不管是 Checked
版本还是 Free 版本，对于 Free 版本，默认是禁止的，使用时需要开启，具体做法如下： 
如果要启用 BootMgr 中的调试引擎，那么应该在一个具有管理员权限的控制台窗口中
《软件调试》补编 
- 163 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
执行如下命令： 
《软件调试》补编 
- 164 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
bcdedit /set {bootmgr} bootdebug on 
bcdedit /set {bootmgr} debugtype serial 
bcdedit /set {bootmgr} debugport 1 
bcdedit /set {bootmgr} baudrate 115200 
以上命令是使用串行口作为主机和目标机之间的通信方式，如果使用其它方式，那么
应该设置对应的参数。 
如果要启用 WinLoad 程序中的调试引擎，那么应该先找到它所对应的引导项的 GUID
值，然后执行如下命令： 
bcdedit /set {GUID} bootdebug on 
启用调试引擎并连接通信电缆后，在主机端运行 WinDBG 工具，便可以进行调试了，
栈回溯、访问内存、访问寄存器等内核调试命令都可以像普通内核调试一样使用。 
Windows Vista 之前的情况
之前的情况
之前的情况
之前的情况 
在 Vista 之前，NTLDR 是 Windows 操作系统的加载程序。因为只有 Checked 版本的
NTLDR 才支持调试，所以如果要调试加载阶段的问题，应该先将 NTLDR 替换为 Checked
版本。DDK 中通常包含有 Checked 版本的 NTLDR 程序。记住，在替换前，应该先去除
NTLDR 文件的系统、隐藏和只读属性，在更换后，要加上这些属性，否则的话引导扇区
中的代码会报告 NTLDR is missing 错误，无法继续启动。 
除了加载内核和引导类型的驱动程序外，NTLDR 会调用 NTDETECT.COM 来做基本
的硬件检查并搜集硬件信息。NTDETECT 会把搜集到的信息存放到注册表中。如果找不
到 NTDETECT.COM，那么通常会直接重启，如果 NTDETECT 发现系统缺少必须的硬件
或固件支持，比如 ACPI 支持，那么会显示因为硬件配置问题而无法启动，也就是我们上
一期所提问的问题。对于这样的问题，可以尝试更改 BIOS 选项来解决，或者通过调试
NTLDR 来进一步定位错误原因。 
恢复缺失文件
恢复缺失文件
恢复缺失文件
恢复缺失文件 
可以使用如下方法之一来尝试恢复丢失或者损坏的系统文件： 
15. 启动时按 F8，调出高级启动菜单，尝试选择 Last Known Good Configuration（LKG）。 
16. 启动时按 F8，在高级启动菜单中选择安全模式（Safe Mode），如果成功启动后，那么
可以尝试执行 CHKDSK 命令检查和修复磁盘，或者从安装光盘中恢复缺失的文件。 
17. 使用 Windows 安装光盘引导，并记入到恢复控制台（Recovery Console）界面。对于
Windows XP，在安装程序的主界面中按 R 键进入文本界面的恢复控制台，进入时输
入管理员密码。对于 Windows Vista，从安装光盘启动后，可以进入图形界面的系统
恢复向导（图 3）。如果是 MBR 或者引导分区损坏，那么 Windows XP 的恢复控制台
中提供了 FIXMBR 和 FIXBOOT 命令。而 Vista 的恢复向导中包含了自动修复功能。 
《软件调试》补编 
- 165 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
图 3 Windows Vista 安装光盘上的系统恢复程序 
18. 如果系统硬盘的个数或者有所变化，那么可能是因为分区编号变化而导致系统无法找
到文件，这时可以考虑恢复旧的磁盘和分区配置，或者启动到恢复控制台来修改系统
的启动配置文件，对于 Vista，需要修改 BCD，对于 Vista 之前的系统，也就是修改
BOOT.INI 文件。 
对于第 11 期的问题，天津的黄小非读者给出了非常好的答案，他的来信中给出了多
种方法，包括使用控制台，使用 Windows Preinstallation Environment（WinPE）以及修改
BOOT.INI。其实 Vista 的恢复界面就是运行在 WinPE 中的。从黄小非的来信中，我们可以
看出他的实践经验很丰富。 
下一期的问题： 
系 统 启 动 后 很 快 出 现 蓝 屏 ， 其 中 含 有
STOP 
0x0000007B 
INACCESSABLE_BOOT_DEVICE，哪些原因会导致这样的问题，该如何来解决？ 
《软件调试》补编 
- 166 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
百废待兴——如何调试内核初始化阶段
的故障 
上一期我们介绍了加载操作系统的过程。简单来说，负责加载操作系统的加载程序
（OS Loader）会把系统内核模块、内核模块的依赖模块、以及引导类型的驱动程序加载
到内存中，并为内核开始执行准备好基本的执行环境。这些工作做好后，加载程序会把执
行权移交给内核模块的入口函数，于是操作系统的内核模块就开始执行了。在今天的软件
架构中，操作系统承担着统一管理系统软硬件资源的任务，可以说是整个系统的统帅。内
核模块是操作系统的核心部分，像任务调度、中断处理、输入输出等核心功能就是实现在
内核模块中的。因此，内核模块开始执行，标志着“漫长的”启动过程进入到了一个新的
阶段，系统的统帅走马上任了。虽然前面已经做了很多准备工作，但是对于一个典型的多
任务操作系统来说，要建设出一个可以运行各种应用程序的多任务环境来，还有很多事情
要做，可谓是百废待兴。本期我们仍以 Windows 操作系统为例谈一谈系统内核和执行体
初始化（简称内核初始化）的过程以及如何调试这一阶段的问题。 
入口函数
入口函数
入口函数