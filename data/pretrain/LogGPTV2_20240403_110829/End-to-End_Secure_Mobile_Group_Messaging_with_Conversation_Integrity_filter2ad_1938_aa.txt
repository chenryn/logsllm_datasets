title:End-to-End Secure Mobile Group Messaging with Conversation Integrity
and Minimal Metadata Leakage
author:Michael Schliep and
Nicholas Hopper
End-to-End Secure Mobile Group Messaging
with Conversation Integrity and Deniability
Michael Schliep
University of Minnesota
PI:EMAIL
Nicholas Hopper
University of Minnesota
PI:EMAIL
Abstract
In this paper, we describe Mobile CoWPI, a deployable, end-to-end secure mobile group messaging application
with proofs of security. Mobile CoWPI allows dynamic groups of users to participate in, join, and leave private,
authenticated conversations without requiring the participants to be simultaneously online or maintain reliable network
connectivity. We identify the limitations of mobile messaging and how they affect conversational integrity and
deniability. We deﬁne strong models of these security properties, prove that Mobile CoWPI satisﬁes these properties,
and argue that no protocol that satisﬁes these properties can be more scalable than Mobile CoWPI. We also describe
an implementation of Mobile CoWPI and show through experiments that it is suitable for use in real-world messaging
conditions.
I.
INTRODUCTION
Texting and social media-based messaging applications have become nearly as common as face-to-face commu-
nications for conversation between individuals and groups. The popularity of these messaging applications stems in
part from their convenience, allowing users to communicate even in a mobile and asynchronous setting, where
their network availability may be unreliable and they may come online and go ofﬂine at different times. In
response to increasing privacy concerns, some of the most widely deployed messaging applications, including
WhatsApp [24], Google Allo [15], Facebook [14], and Signal [21], have been deploying end-to-end encryption to
protect the conﬁdentiality and integrity of messages in users’ conversations.
However, message conﬁdentiality and integrity are not sufﬁcient to protect a conversation. While current
applications protect the integrity of individual messages — an adversary cannot modify a message while in transit
from Alice to Bob — they do not protect the integrity of the conversation. Consider the following conversation
between Alice and Bob, in which the order that messages are displayed can drastically affect the meaning of the
conversation, even if the individual messages cannot be modiﬁed:
Alice’s View:
Alice: Are you going to the protests?
Alice: Have you had lunch yet?
Bob: No... Yes.
Bob’s View:
Alice: Have you had lunch yet?
Alice: Are you going to the protests?
Bob: No... Yes.
We refer to the security property that a conversation must be displayed consistently to all participants as
conversation integrity. This is an example of an additional security property we deem necessary for any future
protocols to achieve end-to-end secure messaging.
Another example of such a property we focus on in this work is deniability. Consider the following conversation:
Reporter: What is your company doing illegally?
Whistleblower: They are dumping poison into the water.
Message deniability guarantees there is no cryptographic proof to a third party that the whistleblower authored the
message. Now consider the following conversation:
Whistleblower: My SSN is 123-45-6789.
Reporter: What is your company doing illegally?
Whistleblower: They are dumping poison into the water.
A protocol that provides message deniability allows the whistleblower to argue that they did not author the messages.
But only the whistleblower knows their social security number so a protocol must also provide message unlinkability,
guaranteeing there is no cryptographic proof to a third party that both messages were authored by the same
participant.
Finally, most deployed secure messaging applications are based on the Signal two-party protocol, which is non-
trivial to extend to group settings. Recently, multiple vulnerabilities [18], [19] have been discovered in the way these
applications implement end-to-end secure messaging for groups. These vulnerabilities allow an adversary to drop
or reorder messages in two-party and group conversations. Other messaging applications ignore end-to-end security
of group conversations entirely. We consider group conversations just as important as two-party conversations and
future deployable protocols must be designed with that in mind.
On the other hand, secure messaging protocols appearing in the research literature [3], [8], [13], [20], [5]
make assumptions that are not realistic in the modern mobile internet which makes them unrealistic for practical
deployments. Most of these works require synchronous communication or provide little to no guarantees about
conversation integrity.
In this paper we address the problem of designing a deployable, end-to-end secure mobile group messaging
application. Our contributions include:
• We identify key constraints of the mobile end-to-end secure messaging model as well as describe the
security properties a protocol should provide. We also identify a real-world threat model a protocol must
provide these properties under (Section II).
• We describe a relatively simple and provably secure protocol for Mobile Conversations With Privacy and
Integrity (Mobile CoWPI) in Section III. We show in Section IV that Mobile CoWPI provides the desired
security properties.
• We then analyze the security properties of our mobile messaging model and show the restrictions they
impose on any mobile end-to-end secure messaging protocol (Section VI). We argue that under these
restrictions, Mobile CoWPI is within a constant factor of optimal in terms of message size.
• We implement Mobile CoWPI as a Java server and library and show that it performs well in a realistic
internet environment (Section V).
II. BACKGROUND
In this section we layout the system model of modern secure messaging applications and show how this model
is insufﬁcient to provide conversation integrity. We then detail our system model and discuss how it enforces
conversation integrity. We also overview all of the security properties we provide in our protocol along with the
threat model used for each property.
A. Mobile Messaging Model
All popular mobile messaging applications provide the same core features using a consistent system model.
The key feature is providing a conversation for two or more participants. These applications allow participants to
start a new conversation and send messages even while other participants are ofﬂine. When the ofﬂine participants
return they are updated with all missed messages in the conversation. To improve conversation ﬂow with ofﬂine
participants the members of the conversation are notiﬁed when other participants have received the messages. This
informs the author of a message not to expect a response until the recipients have received the message.
To provide these conversation properties the service provider handles routing and caching messages in the
conversation. The messages are cached for delivery to ofﬂine participants. All popular secure messaging applications
rely on a single service provider to perform the message routing and caching. This single service provider can break
the conversation integrity property of a protocol that allows a conversation to progress while some participants are
ofﬂine. The service provider simply needs to fork the conversation after a target message and can partition the
group into multiple views of the same conversation. We illustrate this with an example. Consider a conversation
between Alice, Bob, Charlie, and Dave. The service provider forks the conversation after Alice’s second message.
The group is partitioned into two views, one where Alice and Bob believe they are the only participants online and
the other where Charlie and Dave believe they are the only participants online.
2
Alice’s and Bob’s View:
Alice: Lets go to the protest if 3 people want to?
Alice: I want to go.
Bob: I cannot make it.
Charlie’s and Dave’s View:
Alice: Lets go to the protest if 3 people want to?
Alice: I want to go.
Charlie: I am in.
Dave: Yes, me too.
To avoid this conversation integrity attack the system model of Mobile CoWPI consists of a routing/caching
service provider with multiple mirror service providers. Users register with the service providers out-of-band. The
users register long-term and single use pre-keys with the providers. The single use pre-keys allow for conversation
setup while some users are ofﬂine. When sending a message in a conversation the user uploads it to the routing
service provider. The routing provider sends the message to the mirror providers. After that, the routing and mirror
providers send the message to the participants. The participants wait until they have received the message from the
routing provider and all mirror providers before processing it and only process messages if it has been received
in the same order from all providers. The routing provider is asked to send protocol messages in the same order
to all mirrors and all providers are asked to send all messages to the participants in the same order. The protocol
enforce that messages are handled in an order that preserves the integrity of the conversation. It is only important
that at least one provider send all messages in the same order to all participants. Since this is an any trust model
we believe a single routing provider and a single mirror provider is sufﬁcient to provide practical conversation
integrity. We discuss some limitations of this model in Section VI.
B. Service Availability
Service availability is not a security goal of Mobile CoWPI. When discussing the protocol we describe multiple
service providers. We do not necessarily expect each service to be provided by a single machine, but require each
service to be provided by a separate entity. Standard techniques for achieving high availability can be deployed to
ensure the service is reliably available.
Denial of Service protection is also a non-goal of Mobile CoWPI. It is trivial for a service provider to deny
service to a client by not forwarding messages to the victim. It is possible for a malicious provide to behave
incorrectly and send malformed or incorrect messages to a client and cause a denial of service. This is equivalent
to not sending the messages at all. All messaging applications that rely on a service provider are vulnerable to this
type of denial of service. We discuss this in more detail in Section VI. Additionally, if any participants are ofﬂine
or cannot process a message, all other participants can still progress the conversation. They are not blocked on the
ofﬂine/denial of serviced participants.
C. Security Properties
Besides the system goals of ofﬂine users and message receipts we now discuss the security goals of secure mobile
messaging. Unger et. al. [23] provide a comparison of security goals of different secure messaging applications.
We relate our security goals to the goals of their work where appropriate. In Section IV we provide sketches of
the security proofs for these properties and provide the full proofs in Appendix A.
Message Conﬁdentiality: Only conversation participants can read a message.
Message Integrity: Messages are guaranteed to not have been modiﬁed in transit.
Message Authentication: Conversation participants can verify the author of a message. Message authentication
implies message integrity.
Forward Secrecy: Past messages are conﬁdential even if future key material is revealed.
Backward Secrecy: Future messages are conﬁdential if past key material is revealed, also know as future secrecy
or post-compromise secrecy.
Participant Authentication: Participants can verify other participants are really who they claim to be.
Participant Consistency: All participants of a conversation agree on all the participants of the conversation.
3
Conversation Integrity: All participants see the same conversation. This includes the order of messages in a
conversation and the order of participant changes in a conversation. In relation to Unger et. al. this goal implies
speaker consistency, causality preservation, and a global transcript.
Deniability: Participants must be able to deny taking part in a conversation. Unger et. al. refer to this as participant
repudiation. They also discuss two additional deniability properties; message repudiation and message unlinkability.
Participant repudiation implies message repudiation. Message unlinkability is the property that if a distinguisher
can be convinced a user authored one message this should not prove the authorship of any other message.
Anonymity Preserving: The protocol should not undermine the anonymity features of the underlying transport.
Computation and Trust Equality: All users perform similar computations and no user is trusted more than any
other.
Untrusted Service Provider: Any individual service provider is not trusted to provide any of the security properties.
Dynamic Groups: Participants can be added and removed from conversations without restarting the protocol.
D. Threat Model
The security provided by Mobile CoWPI needs to withstand strong adversaries. We consider an adversary that
may compromise multiple service providers and multiple users. The adversary also has full network control and
may drop, modify, and reorder the network trafﬁc. Each security property is provided under the strongest adversary
that cannot trivially break the property. We now detail the exact capabilities of the adversary for each security
property.
Message Conﬁdentiality: The adversary has full network control and can insert, drop, and reorder network mes-
sages. The adversary is allowed to compromise any or all of the service providers. The adversary may compromise
any participant in a non-target session. The adversary is not allowed to compromise any participant in the target
session as that would trivially allow them to trivially reveal the plaintext of the message.
Message Integrity and Authentication: The adversary considered for message integrity and authentication is the
same as for message conﬁdentiality.
Forward and Backward Secrecy: The adversary for forward and backward secrecy is similar to the message con-
ﬁdentiality adversary. This adversary is also allowed to compromise any or all participant in the target conversation
but is not allowed to impersonate a participant in the target conversation. The adversary is also not allowed to
compromise a participant at the time a target message is being processed as this would trivially break the secrecy.
Participant Authentication: The adversary is allowed to compromise the service providers and has full network
control. The adversary is allowed to compromise non-target participants. We assume there is an authenticated side-
channel between the target participants. This may be pre-shared secrets or in person face-to-face communication.
Participant Consistency: The adversary has full network control and is allowed to compromise all of the service
providers. The adversary is allowed to compromise any participant in any session. The adversary is not allowed to
compromise all of the service providers and a participant in the target session. This would allow the adversary to
forge and deliver inconsistent participant changes to participants.
Conversation Integrity: The adversary has full network control and is allowed to compromise any participant in any
session. The adversary is allowed to compromise all but one of the service providers. If the adversary compromised
all service providers, the adversary could then fork the conversation as discussed earlier.
Anonymity Preserving: The adversary is a passive network adversary such as an Internet Service Provider. The
adversary is not allowed to compromise any of the service providers or users of the messaging service. The goal
of the adversary is to link a session to the long-term key or identity of a participant. The goal of Mobile CoWPI
is to not reduce the anonymity provided by the underlying transport, e.g. Tor [22].
Deniability: We model deniability similar to Di Raimondo et. al. [6]. A protocol is said to be deniable if a
distinguisher can not distinguish between a real protocol transcript and a simulated transcript. We only consider
the protocol deniable if any user can produce a simulated transcript that is indistinguishable from a real transcript.
The simulator must only take as input information that is known to a user, e.g. identities, long-term public keys,
the users secret keys. The distinguisher is given access to the long-term private information of users, i.e. long-term
secret keys.
When considering message unlinkability the distinguisher and simulator are also given a part of a real transcript
and ephemeral state relating to a single message. The simulated transcript must contain this partial information and
still be indistinguishable from the real transcript.
4
A. Overview
III. DESIGN
At a high level Mobile CoWPI is designed as follows. Users register with the routing service provider out-of-
band. This registration links a user identity, a long-term public key, and multiple single use pre-keys. The routing
provider shares this registration information with the mirror service providers. When messages are sent as part of a
conversation they are uploaded to the routing provider and distributed to the mirror providers. All service providers
then send the messages to the participants. The participants do not process a message until it has been received
from the routing service provider and all mirror providers in the same order. As long as a single provider is honest
conversation integrity and participant consistency are enforced.
Users of Mobile CoWPI communicate with each provider using a two-party secure channel. The two party
channels provide all of the security properties described in the previous section. We describe this channel in
Section III-K.
When Alice wishes to set up a new conversation with Bob and Charlie she ﬁrst fetches Bob’s and Charlie’s
long-term public keys and a single use public pre-key for each of Bob and Charlie. She then uploads a setup
message of the form:
Sid, “SET U P ”, Alice, P, cab, cac, authas1, . . . , authasm
to the routing provider. Sid is a unique session identiﬁer for the session. P is the set of participants. ca∗ are per-user
ciphertext blocks that authenticate the message and contain future key material for Bob and Charlie, described in
Section III-E. The autha∗ blocks are authentication blocks for the providers detailed in Section III-F. The providers
then distribute the following to Alice, Bob and Charlie respectively.
Sid, “SET U P ”, Alice, P
Sid, “SET U P ”, Alice, P, cab
Sid, “SET U P ”, Alice, P, cac
Alice, Bob, and Charlie do not process a message until they have received it from every provider. All protocol
messages have a similar form, with a data block followed by per-user and per-provider blocks. This allows sending
only the data block and a single per-user block to the participants.