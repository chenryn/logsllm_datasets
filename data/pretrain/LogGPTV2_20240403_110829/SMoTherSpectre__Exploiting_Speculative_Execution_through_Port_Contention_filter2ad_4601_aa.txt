title:SMoTherSpectre: Exploiting Speculative Execution through Port Contention
author:Atri Bhattacharyya and
Alexandra Sandulescu and
Matthias Neugschwandtner and
Alessandro Sorniotti and
Babak Falsafi and
Mathias Payer and
Anil Kurmus
9
1
0
2
p
e
S
6
2
]
R
C
.
s
c
[
3
v
3
4
8
1
0
.
3
0
9
1
:
v
i
X
r
a
SMoTherSpectre: Exploiting Speculative Execution
through Port Contention
Atri Bhattacharyya ∗
EPFL
Alessandro Sorniotti †
IBM Research – Zurich
Alexandra Sandulescu †
IBM Research – Zurich
Matthias Neugschwandtner†
IBM Research – Zurich
Babak Falsafi∗
EPFL
Anil Kurmus †
IBM Research – Zurich
Mathias Payer∗
EPFL
ABSTRACT
Spectre, Meltdown, and related attacks have demonstrated that
kernels, hypervisors, trusted execution environments, and browsers
are prone to information disclosure through micro-architectural
weaknesses. However, it remains unclear as to what extent other
applications, in particular those that do not load attacker-provided
code, may be impacted. It also remains unclear as to what extent
these attacks are reliant on cache-based side channels.
We introduce SMoTherSpectre, a speculative code-reuse attack
that leverages port-contention in simultaneously multi-threaded
processors (SMoTher) as a side channel to leak information from a
victim process. SMoTher is a fine-grained side channel that detects
contention based on a single victim instruction. To discover real-
world gadgets, we describe a methodology and build a tool that
locates SMoTher-gadgets in popular libraries. In an evaluation on
glibc, we found hundreds of gadgets that can be used to leak infor-
mation. Finally, we demonstrate proof-of-concept attacks against
the OpenSSH server, creating oracles for determining four host key
bits, and against an application performing encryption using the
OpenSSL library, creating an oracle which can differentiate a bit of
the plaintext through gadgets in libcrypto and glibc.
CCS CONCEPTS
• Security and privacy → Side-channel analysis and counter-
measures.
KEYWORDS
side-channel; simultaneous multithreading; speculative execution;
attack; microarchitecture
∗PI:EMAIL
†{asa, eug, aso, kur}@zurich.ibm.com
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
CCS ’19, November 11–15, 2019, London, United Kingdom
© 2019 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-6747-9/19/11...$15.00
https://doi.org/10.1145/3319535.3363194
ACM Reference Format:
Atri Bhattacharyya, Alexandra Sandulescu, Matthias Neugschwandtner,
Alessandro Sorniotti, Babak Falsafi, Mathias Payer, and Anil Kurmus . 2019.
SMoTherSpectre: Exploiting Speculative Execution through Port Contention.
In 2019 ACM SIGSAC Conference on Computer & Communications Security
(CCS ’19), November 11–15, 2019, London, United Kingdom. ACM, New York,
NY, USA, 16 pages. https://doi.org/10.1145/3319535.3363194
1 INTRODUCTION
Spectre [23, 24, 29] and Meltdown [26] form a new class of micro-
architectural attacks. These attacks leverage weaknesses in specu-
lative execution (Spectre) or separation between privileged and un-
privileged code (Meltdown) to leave micro-architectural traces [5].
Both Spectre and Meltdown leverage a side channel based on the
memory architecture to leak data from the address space of a target
(e.g. from another process or from the kernel).
While micro-architectural side channels were known before the
discovery of Meltdown and Spectre, their applicability was mostly
limited to targets applying data-dependent control flow patterns or
memory accesses. In this older class of vulnerabilities, an attacker
would observe the micro-architectural changes to shared resources
caused by the execution of a victim. For example, in a cache-based
attack, the adversary would prime the cache, let the victim execute,
and then detect which locations have been evicted from the cache.
Such a side channel leaks addresses and allows the adversary to
learn information from data-dependent execution. An effective
mitigation strategy is to eliminate data-dependent control flow
over sensitive data, such as cryptographic material.
In contrast, Spectre and Meltdown render this class of attacks
generic and significantly harder to mitigate through software changes
only. The side channel is now used indirectly, in a way that – cru-
cially – does not rely on poor choices in the development of the tar-
get application. In Spectre, for instance, the attacker first primes the
speculation engine (e.g., by preparing the branch target buffers) as
well as the cache-based side channel; the victim then misspeculates
at an attacker-controlled location and thereby leaks information [5].
The attacker can then read out the cache-based side channel. In
light of these new attack vectors, architectural, system-wide de-
fenses such as Kernel Page-Table Isolation [15], retpolines [33], or
microcode updates must be rolled out to protect the system against
attacks. One proposed microarchitectural defense is to revert all
side effects of speculative execution [21].
One mitigating factor is that so far, with the exception of
Netspectre-AVX [29], all existing attacks rely on side channels that
are invariably cache-based to read out information. This in turn
requires the presence of specific gadgets in the victim, which are
often hard to find. Consider the example of Branch Target Injection
(BTI), the technique used in Spectre v2 [23]: in the initial exploit,
no suitable gadget was identified in the kernel. The attack was suc-
cessful because it redirected speculative control flow to externally
provided code, in the form of eBPF kernel code. This observation
justifies why mitigations such as retpoline are not employed at
large by user-space programs.
In this paper, we show that speculation attacks (e.g., through
branch target injection) can leak arbitrary secrets from generic
user-space programs through a side channel that is not based on
the memory architecture. In particular, we show that branch target
injection can be used on existing program code, without requir-
ing the injection of attacker code. To this end, we first show that
port contention can be used as a powerful side channel when ex-
ecuting with simultaneous multi-threading (SMoTher). We then
exploit port contention as a side channel to transmit information
during speculative execution (SMoTherSpectre). This shows that,
because the transmission occurs before speculative execution ends,
reverting side effects of speculative execution would not be suffi-
cient as a defense. Finally, we show how suitable portions of code
can be found in target binaries automatically.
Other related work has looked at execution-unit-sharing as a
side channel [1, 2, 11, 35]. Portsmash [2], concurrently developed to
our work, demonstrates that port sharing leaks code access patterns
and successfully extracts secrets from a known vulnerable version
of OpenSSL. We are, however, the first to characterize this side
channel and leverage it for a speculative execution attack, providing
a full working proof of concept that leaks data from an up-to-date
OpenSSL version. Further, we attack the OpenSSH server, leaking
bits from the host’s RSA key.
nel (SMoTher);
This paper makes the following contributions:
• A precise characterization of the port-contention side chan-
• A speculative execution attack (SMoTherSpectre) that
demonstrates the suitability of non-cache-based side chan-
nels to leak information. We show an end-to-end attack
using speculation based on BTI by combining it with the
port contention side channel;
• An automated technique to find target speculative gadgets
• Real world attacks where we target BTI gadgets in the
OpenSSH server and in the latest version of OpenSSL, along
with a SMoTher gadget from the libc.
in programs; and
2 BACKGROUND
The work in this paper relies on the complex interplay between soft-
ware and hardware. In the following, we provide the background
information necessary to understand SMoTher and SMoTherSpec-
tre.
CPU Microarchitecture. A modern CPU is typically split into
two main components: the frontend and the backend (or execution
engine). The frontend predicts where to fetch instructions from
Figure 1: Instructions from the window are scheduled to ports
shared by sets of execution units. A single instruction may be sched-
uled per port per cycle.
and creates a program-order stream of instructions to be executed
by the backend. The instructions are either decoded and executed
“as-is” in RISC ISAs (e.g., IBM POWER or ARM) or broken down
into RISC-like instructions called µops in CISC ISAs (e.g., x86 or
IBM Z). For brevity we refer to all instructions executed by the
backend as µops. Once fetched and decoded, the µops are placed in
an instruction window (also referred to as issue queue or reservation
stations) to be scheduled and dispatched to execution units when
their operands are ready. Every cycle, the scheduler searches the
instruction window to identify which µops are ready for execution
and which execution unit is available to dispatch them to. µops can
execute out of program order (e.g., a later µop in program order can
execute earlier) if their operands are ready and a relevant execution
unit is available. Ideally, all execution units would be designed to
handle every type of operation to maximize throughput. In prac-
tice, execution units are specialized and only the more commonly
used ones are replicated. A group of execution units share a port,
indicating their availability in a given cycle. Contention for a port
leads to delays in execution. Figure 1 demonstrates scheduling in-
structions from an execution window containing three µops, where
contention for port 3 prevents the second µop from being scheduled
in the same cycle as the other two.
Speculative Execution. Because the stream of µops is predicted
but is not guaranteed to execute, complete and make its state visible
to software, the backend also contains a re-order buffer that commits
the state of each completed µop in program order to the software
visible structures (i.e., register file and memory). This execution of
µops is speculative because the frontend may have mispredicted the
direction and/or the target address of a branch operation. Upon mis-
prediction, the pipeline flushes all µops in the re-order buffer and
restarts fetching and decoding µops. While executing on the mis-
predicted path, the processor accesses the cache hierarchy leaving
side-effects which lead to cache-based side channels even though
the values accessed are discarded and do not impact the executing
software.
Simultaneous Multithreading. Out-of-order processors pro-
vision a large fraction of silicon area to mechanisms that exploit
speculation and parallelism in execution. While these mechanisms
are designed for peak parallelism, most structures (e.g., execution
units, branch tables, physical registers, instruction window, re-order
buffer) remain underutilized on average. Simultaneous MultiThread-
ing (SMT) is a technique to improve utilization of these structures
by allowing µops from multiple threads (e.g., two in x86 and eight
in IBM POWER) to execute simultaneously on a single core. In-
dividual SMT threads maintain their own architectural state, but
share many microarchitectural structures in the processor pipeline
simultaneously. SMT (or HyperThreading as Intel brands its im-
plementation) is entirely transparent to software to which a single
core appears as multiple logical cores. Besides the execution units,
physical registers and instruction window, it is an implementation’s
choice as to which other structures SMT threads share. Experiments
have proven that the branch predictor can be shared between hy-
perthreads [6, 18] on Intel CPUs.
Speculative Execution Attacks. Speculative execution can be
exploited by priming the branch predictor with sufficient history
such that it is tricked into predicting the wrong target for a branch.
Because branch direction history (i.e., taken or not taken) is a shared
resource, an attacking process can prime the branch predictor of
its victim. Similarly, a branch target buffer predicting the target
address for a branch can be primed by an attacking process. This
works for both conditional branches as well as indirect branches.
In a conditional branch, such as an array-size check in Spectre
V1, the CPU can be tricked into speculatively executing an out-
of-bounds array access in spite of the failing length check. If the
target address of the length check is not in the cache then the
memory fetch will take longer than the following speculatively
executed instructions. In an indirect branch, the CPU can be tricked
into speculatively executing arbitrary code in a victim process
by providing a malicious branch history through a temporally or
spatially (in the case of SMT) co-located attacker process. We discuss
related work in Section 7.
Cache-timing Side Channel. Speculative execution attacks,
such as Spectre, exploit the fact that a speculatively executed
and then discarded operation does have side effects on the micro-
architectural state, even if it has none on the architectural state. For
example, an instruction that operates on a value stored in memory
will need to fetch that value and cause the corresponding memory
region to be pulled into the cache. The side-effect that the mem-
ory region is now cached is not undone when the instruction is
discarded instead of retired, and can be measured using cache side
channels. For example, in Spectre V1 the victim code uses two de-
pendent array lookups, where the result of the lookup of the first
array is used as an index into the second array. This index can
be leaked by measuring access times to the second array through
a flush and reload attack. By ensuring that the second array has
been flushed from the cache before the victim code executes, and
measuring the access times afterwards, only the lookup of the index
that has been used by the victim code will be significantly faster.
3 SMOTHER
In this section, we describe and evaluate SMoTher, a side channel
based on port-contention, present in SMT architectures. SMoTher
is based on the following observation: two co-located (i.e., running
on the same physical core) hardware threads of execution share
execution units. Instructions that are scheduled to execute on the
same execution port will contend for the available resources. We
show how this contention can be measured, at first in a coarse-
grained way, i.e., with large sequences of instructions scheduled
on the same port on both threads, and then in a fine-grained way,
i.e., with minimal sequences of instructions. The result is that an
unprivileged attacker process can detect whether a co-located victim
process is running an instruction on a given port.
3.1 Ideal covert channel
In this experiment, we demonstrate port contention between two
threads running simultaneously on the same physical core and
describe how it can be measured in ideal conditions.
3.1.1 Experiment design. Executing instructions that occupy a spe-
cific port and measuring their timing enables inference about other
instructions executing on the same port. We first choose two in-
structions, each scheduled on a single, distinct, execution port. One
thread runs and times a long sequence of single µop instructions
scheduled on port a, while simultaneously the other thread runs
a long sequence of instructions scheduled on port b. We expect
that, if a = b, contention occurs and the measured execution time
is longer compared to the a (cid:44) b case.
3.1.2 Experimental setup. We run experiments on an Intel Core
i7-6700K CPU running Ubuntu 16.04.4 stock kernel, version 4.15.0.
Both attacker and victim are pinned to different hardware threads
on the same physical core. The CPU governor is set to Performance
for a constant clock frequency. The “performance” state is config-
ured below the turbo frequency range to lower non-deterministic
factors in the environment. Apart from these changes, all other set-
tings are kept to their defaults. Most notably, speculative-execution-
related mitigations are left enabled.
In the measuring thread, we execute and time a sequence of
1,200 shl, a single µop instruction that executes on port 0 or port 6,
which we denote port 06, on this CPU. The colocated thread runs a
sequence of either 1,200 shl or popcnt instructions: the shl instruc-
tions directly contend for port 06 while the popcnt instructions will