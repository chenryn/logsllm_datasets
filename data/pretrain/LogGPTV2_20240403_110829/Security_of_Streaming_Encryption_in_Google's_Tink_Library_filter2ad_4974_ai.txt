2ğ‘› âˆ’ ğ‘–
ğ‘ˆ(ğ½)âˆ’1âˆï¸
ğ‘—=0
In the real world, since ğœ is good,
Pr[ğ’¯1 = ğœ] = 2âˆ’ğ‘¢(ğ‘˜+ğ‘›) âˆï¸
ğ½âˆˆ{0,1}ğ‘˜
ğ‘‰ (ğ½)âˆ’1âˆï¸
ğ‘–=0
1
2ğ‘› âˆ’ ğ‘–
Hence
Pr[ğ’¯1 = ğœ]
Pr[ğ’¯0 = ğœ] â‰¥ 1 .
1
2ğ‘› âˆ’ ğ‘‰ (ğ½) âˆ’ ğ‘—
.
(4)
Wrapping up. From Lemma 5 with ğœ– = 0, Eq. (3), and Eq. (4),
AdvÂ±prp
ğº (ğ’œ) â‰¤ 2ğ‘ğ‘ + ğ‘2
2ğ‘˜+ğ‘›
.
as claimed.
D Proof of Theorem 2
Our proof relies on the Chi-Squared method of Dai, Hoang, and Tessaro [10], and the well-known
Azumaâ€™s inequality, which we will review below.
The Chi-squared method. Suppose that we want to bound the advantage of a computationally
unbounded adversary ğ’œ in distinguishing a â€œrealâ€ system S1 from an â€œidealâ€ system S0. Without
loss of generality, assume that ğ’œ is deterministic and makes exactly ğ‘ queries. Since the adversary
is deterministic, for any ğ‘– â‰¤ ğ‘ âˆ’ 1, the answers for the first ğ‘– queries completely determine the
first ğ‘– + 1 queries. For a system S âˆˆ {S1, S0} and strings ğ‘§1, . . . , ğ‘§ğ‘–, let pS,ğ’œ(ğ‘§1, . . . , ğ‘§ğ‘–) denote the
probability that the answers for the first ğ‘– queries that ğ’œ receives when interacting with S are
ğ‘§1, . . . , ğ‘§ğ‘–. If pS,ğ’œ(ğ‘§1, . . . , ğ‘§ğ‘–) > 0, let pS,ğ’œ(ğ‘§ğ‘–+1 | ğ‘§1, . . . , ğ‘§ğ‘–) denote the conditional probability that
28
the answer for the (ğ‘– + 1)-th query when ğ’œ interacts with system S is ğ‘§ğ‘–+1, given that the answers
for the first ğ‘– queries are ğ‘§1, . . . , ğ‘§ğ‘– respectively.
For each ğ‘ = (ğ‘§1, . . . , ğ‘§ğ‘), let ğ‘ğ‘– = (ğ‘§1, . . . , ğ‘§ğ‘–) and let ğ‘0 be the empty string. We write pS,ğ´(Â· | ğ‘ğ‘–)
and pS,ğ´(Â· | ğ‘0) to refer to probabilities pS,ğ´(Â· | ğ‘§1, . . . , ğ‘§ğ‘–) and pS,ğ´(Â·) respectively. We require that
if pS1,ğ’œ(ğ‘ğ‘–) > 0 then so is pS0,ğ’œ(ğ‘ğ‘–). For each ğ‘– â‰¤ ğ‘ and each vector ğ‘ğ‘–âˆ’1 = (ğ‘§1, . . . , ğ‘§ğ‘–âˆ’1), define
ğœ’2(ğ‘ğ‘–âˆ’1) =âˆ‘ï¸
ğ‘§ğ‘–
(ï¸€pS1,ğ’œ(ğ‘§ğ‘– | ğ‘ğ‘–âˆ’1) âˆ’ pS0,ğ’œ(ğ‘§ğ‘– | ğ‘ğ‘–âˆ’1))ï¸€2
pS0,ğ’œ(ğ‘§ğ‘– | ğ‘ğ‘–âˆ’1)
,
statistical distance SD(ï¸€pS0,ğ´(Â·), pS1,ğ´(Â·))ï¸€ between pS0,ğ´(Â·) and pS1,ğ´(Â·), namely the best possible
where the sum is taken over all ğ‘§ğ‘– such that pS0,ğ’œ(ğ‘§ğ‘– | ğ‘ğ‘–âˆ’1) > 0. Lemma 6 below bounds the
distinguishing advantage of ğ’œ between S1 and S0.
Lemma 6 (The Chi-Squared Lemma). [10, Lemma 3] Suppose whenever pS1,ğ’œ(ğ‘ğ‘–) > 0 then
pS0,ğ’œ(ğ‘ğ‘–) > 0. Then
SD(ï¸€pS0,ğ´(Â·), pS1,ğ´(Â·))ï¸€ â‰¤(ï¸1
E[ğœ’2(ğ‘‹ ğ‘–âˆ’1)])ï¸1/2
,
ğ‘âˆ‘ï¸
ğ‘–=1
2
where the expectation is taken over vectors ğ‘‹ ğ‘–âˆ’1 of the ğ‘–âˆ’ 1 first answers sampled according to the
interaction with S1.
Azumaâ€™s inequality. We now briefly recall the Azumaâ€™s inequality; a more detailed exposition
can be found in a standard textbook of probability theory, for example, [25, Chapter 4.4].
Let ğ‘‡0, ğ‘‡1, . . . , ğ‘‡ğ‘š be a sequence of random variables. We say that (ğ‘‡0, . . . , ğ‘‡ğ‘š) is a martingale if
E[ï¸€|ğ‘‡ğ‘–|]ï¸€  0,
Pr[ï¸€|ğ‘‡ğ‘š âˆ’ ğ‘‡0| â‰¥ ğ‘ğœ†
ğ‘š]ï¸€ â‰¤ ğ‘’âˆ’ğœ†2/2 .
âˆš
The proof. Consider games ğ‘ƒ1â€“ğ‘ƒ4 in Fig. 15. Game ğ‘ƒ1 corresponds to game Gprf
XOR[ğ¸] with chal-
lenge bit ğ‘ = 1, and game ğ‘ƒ4 corresponds to game Gprf
XOR[ğ¸] with challenge bit ğ‘ = 0. Game ğ‘ƒ2 is
similar to game ğ‘ƒ1, but it samples a truly random permutation ğœ‹ğ‘– for each user ğ‘–, and for each
call to ğ¸(ğ¾ğ‘–,Â·), it calls ğœ‹ğ‘–(Â·) instead. Game ğ‘ƒ3 is similar to game ğ‘ƒ4, but instead of picking a truly
random function ğ‘“ğ‘– for each user ğ‘–, it imposes a constraint that ğ‘“ğ‘–(ğ‘‹) Ì¸= 0ğ‘› for every ğ‘¥ âˆˆ {0, 1}ğ‘›âˆ’1.
To bound the gap between games ğ‘ƒ1 and ğ‘ƒ2, we construct an adversary â„¬ attacking the PRP
security of ğº as follows. Adversary â„¬ runs ğ’œ and simulates game ğ‘ƒ1. However, for each call to
ğº(ğ¾ğ‘–,Â·), it instead makes a corresponding query to its oracle Eval(ğ‘–,Â·). Thus
Pr[ğ‘ƒ1(ğ’œ)] âˆ’ Pr[ğ‘ƒ2(ğ’œ)] = Advprp
ğº (â„¬) .
29
procedure Initialize//Game ğ‘ƒ1
ğ¾1, ğ¾2, . . . â†$ ğ’¦
procedure Eval(ğ‘–, ğ‘€)
ğ‘Œ â† ğº(ğ¾ğ‘–, ğ‘€ â€– 0) âŠ• ğº(ğ¾ğ‘–, ğ‘€ â€– 1)
return ğ‘Œ
procedure Initialize//Games ğ‘ƒ3
Dom â† {0, 1}ğ‘›âˆ’1
Rng â† {0, 1}ğ‘›âˆ–{0ğ‘›}
ğ‘“1, ğ‘“2,Â·Â·Â· â†$ Func(Dom, Rng)
procedure Eval(ğ‘–, ğ‘€)
ğ‘Œ â† ğ‘“ğ‘–(ğ‘€); return ğ‘Œ
procedure Initialize//Game ğ‘ƒ2
ğœ‹1, ğœ‹2, . . . â†$ Perm(ğ‘›)
procedure Eval(ğ‘–, ğ‘€)
ğ‘Œ â† ğœ‹ğ‘–(ğ‘€ â€– 0) âŠ• ğœ‹ğ‘–(ğ‘€ â€– 1)
return ğ‘Œ
procedure Initialize//Games ğ‘ƒ4
Dom â† {0, 1}ğ‘›âˆ’1
Rng â† {0, 1}ğ‘›
ğ‘“1, ğ‘“2,Â·Â·Â· â†$ Func(Dom, Rng)
procedure Eval(ğ‘–, ğ‘€)
ğ‘Œ â† ğ‘“ğ‘–(ğ‘€); return ğ‘Œ
Fig. 15: Games ğ‘ƒ1â€“ğ‘ƒ4 in the proof of Theorem 2. The games share a common Finalize(ğ‘â€²) that
returns (ğ‘â€² = 1).
procedure Eval(ğ‘–, ğ‘€) //Games ğ‘ƒ3 , ğ‘ƒ4
ğ‘Œ â†$ {0, 1}ğ‘›
if ğ‘Œ = 0ğ‘› then bad â†$ true; ğ‘Œ â†$ {0, 1}ğ‘›âˆ–{0ğ‘›}
return ğ‘Œ
Fig. 16: Rewritten games ğ‘ƒ3 and ğ‘ƒ4 in the proof of Theorem 2. Procedure Initialize is empty and
thus omitted. Game ğ‘ƒ3 contains the boxed statement but game ğ‘ƒ4 does not.
For games ğ‘ƒ2â€“ğ‘ƒ4, we will consider even a computationally unbounded adversary ğ’œ, and thus we
can assume that ğ’œ is deterministic and never repeats a prior query. We claim that
Pr[ğ‘ƒ2(ğ’œ)] âˆ’ Pr[ğ‘ƒ3(ğ’œ)] â‰¤
âˆš
50ğ‘› Â· ğ‘
2ğ‘›
;
the proof is postponed until further below. For games ğ‘ƒ3 and ğ‘ƒ4, due to the assumption that ğ’œ does
not repeat a prior query, instead of sampling functions ğ‘“ğ‘– eagerly, we can sample them lazily, and
thus the two games can be rewritten as shown in Fig. 16. In particular, in game ğ‘ƒ4, each query will
receive a truly random answer, and in game ğ‘ƒ3, each query will receive a random, non-zero answer.
The two games are identical until the flag bad is set, and thus from the Fundamental Lemma of
Game Playing [3],
Pr[ğ‘ƒ3(ğ’œ)] âˆ’ Pr[ğ‘ƒ4(ğ’œ)] â‰¤ Pr[ğ‘ƒ4 sets bad] .
If ğ’œ makes ğ‘ queries then the chance that one of the truly random answers becomes 0ğ‘› is at most
ğ‘/2ğ‘›. Hence
Pr[ğ‘ƒ3(ğ’œ)] âˆ’ Pr[ğ‘ƒ4(ğ’œ)] â‰¤ ğ‘
2ğ‘› .
Summing up,
Advprf
XOR[ğº](ğ’œ) = Pr[ğ‘ƒ1(ğ’œ)] âˆ’ Pr[ğ‘ƒ4(ğ’œ)]
3âˆ‘ï¸
ğ‘–=1
=
Pr[ğ‘ƒğ‘–(ğ’œ)] âˆ’ Pr[ğ‘ƒğ‘–+1(ğ’œ)] â‰¤ Advprp
ğº (â„¬) + 8
30
âˆš
ğ‘› Â· ğ‘
2ğ‘›
.
We now bound the gap between ğ‘ƒ2 and ğ‘ƒ3 via the Chi-Squared method. Let S1 be the system that
implements game ğ‘ƒ2, and S0 be the system that implements game ğ‘ƒ3. Without loss of generality,
suppose that ğ’œ makes exactly ğ‘ queries. Let ğ‘‹ = (ğ‘‹1, . . . , ğ‘‹ğ‘) be the random variable for the ğ‘
answers in S1, and let ğ‘‹ ğ‘– = (ğ‘‹1, . . . , ğ‘‹ğ‘–) for every ğ‘– â‰¤ ğ‘. Fix ğ‘– â‰¤ ğ‘ and fix ğ‘¥ âˆˆ {0, 1}ğ‘›âˆ–{0ğ‘›}. Let
ğ‘Œğ‘–,ğ‘¥ be the following random variable. If ğ‘‹ ğ‘–âˆ’1 takes values (ğ‘§1, . . . , ğ‘§ğ‘–âˆ’1) then ğ‘Œğ‘–,ğ‘¥ takes the value
pS1,ğ´(ğ‘¥ | ğ‘§1, . . . , ğ‘§ğ‘–âˆ’1). Recall that
We claim that
This claim will be justified later. From Eq. (5) and Eq. (6),
ğœ’2(ğ‘‹ ğ‘–âˆ’1) = âˆ‘ï¸
â‰¤ âˆ‘ï¸
)ï¸2]ï¸ â‰¤ 100ğ‘–ğ‘›
ğ‘¥âˆˆ{0,1}ğ‘›âˆ–{0ğ‘›}
(ğ‘Œğ‘–,ğ‘¥ âˆ’ 1/(2ğ‘› âˆ’ 1))2
1/(2ğ‘› âˆ’ 1)
ğ‘¥âˆˆ{0,1}ğ‘›âˆ–{0ğ‘›}
1
24ğ‘›
ğ‘Œğ‘–,ğ‘¥ âˆ’
(2ğ‘› âˆ’ 1
E[ï¸(ï¸
E[ğœ’2(ğ‘‹ ğ‘–âˆ’1)] â‰¤ âˆ‘ï¸
(ï¸€Pr[ğ‘ƒ2(ğ’œ)] âˆ’ Pr[ğ‘ƒ3(ğ’œ)])ï¸€2 â‰¤ SD(ï¸€pS0,ğ´(Â·), pS1,ğ´(Â·))ï¸€2
E[ğœ’2(ğ‘‹ğ‘–âˆ’1)] â‰¤ 1
2
ğ‘¥âˆˆ{0,1}ğ‘›âˆ–{0ğ‘›}
â‰¤ 1
2
ğ‘âˆ‘ï¸