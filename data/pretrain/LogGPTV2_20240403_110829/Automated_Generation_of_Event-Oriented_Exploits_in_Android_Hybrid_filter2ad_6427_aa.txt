title:Automated Generation of Event-Oriented Exploits in Android Hybrid
Apps
author:Guangliang Yang and
Jeff Huang and
Guofei Gu
Automated Generation of Event-Oriented Exploits in
Android Hybrid Apps
Guangliang Yang, Jeff Huang, and Guofei Gu
Texas A&M University
{ygl, jeffhuang, guofei}@tamu.edu
Abstract—Recently more and more Android apps integrate the
embedded browser, known as “WebView”, to render web pages
and run JavaScript code without leaving these apps. WebView
provides a powerful feature that allows event handlers deﬁned
in the native context (i.e., Java in Android) to handle web events
that occur in WebView. However, as shown in prior work, this
feature suffers from remote attacks, which we generalize as Event-
Oriented Exploit (EOE) in this paper, such that adversaries
may remotely access local critical functionalities through event
handlers in WebView without any permission or authentication.
In this paper, we propose a novel approach, EOEDroid, which
can automatically vet event handlers in a given hybrid app using
selective symbolic execution and static analysis. If a vulnerability
is found, EOEDroid also automatically generates exploit code to
help developers and analysts verify the vulnerability. To support
exploit code generation, we also systematically study web events,
event handlers and their trigger constraints.
We evaluated our approach on 3,652 most popular apps. The
result showed that our approach found 97 total vulnerabilities in
58 apps, including 2 cross-frame DOM manipulation, 53 phishing,
30 sensitive information leakage, 1 local resources access, and 11
Intent abuse vulnerabilities. We also found a potential backdoor
in a high proﬁle app that could be used to steal users’ sensitive
information, such as IMEI. Even though developers attempted
to close it, EOEDroid found that adversaries were still able to
exploit it by triggering two events together and feeding event
handlers with well designed input.
I.
INTRODUCTION
More and more Android apps leverage the power of the
embedded browser, known as “WebView”, to render web pages
and run JavaScript code. In contrast to regular web browsers
(such as desktop browsers), WebView is more powerful by
providing a unique feature that allows event handlers deﬁned in
the native context (i.e., Java in Android) to handle web events
that occur in WebView.
This powerful feature of WebView signiﬁcantly enriches
the functionalities of Android apps. However, as shown in prior
work [19], [26], such a feature also introduces potential security
ﬂaws. More specially, it opens a bridge that links web code to
Network and Distributed Systems Security (NDSS) Symposium 2018
18-21 February 2018, San Diego, CA, USA
ISBN 1-1891562-49-5
http://dx.doi.org/10.14722/ndss.2018.23236
www.ndss-symposium.org
Figure 1: Attack Model
native code, but the bridge is not protected in WebView.
However, up to now it still remains unclear how adversaries
involve the event handler feature in their attack vectors in
practice. A possible attack scenario is that an adversary may
trigger an event handler with appropriate input to leverage its
internal critical functionalities. More details are shown in Figure
1. First, the adversary injects malicious HTML/JavaScript code
into WebView through web or network attacks (Step 1). Then,
the malicious code is executed and triggers a web event (Step
2). After that, the corresponding event handler in the native
code is called (Step 3). Finally, the event handler is guided by
the injected input to execute its internal critical functionalities
(Step 4).
The above possibility is conﬁrmed by our small-scale
empirical study of 100 popular hybrid apps collected from
Google Play. We found that an event handler in an old
but still popular advertisement (ad) library, “millennialmedia”
(version 5), contains rich and powerful functionalities, such as
reading Android ID, recording audio and opening the camera.
However, the access control on that event handler is weak. The
internal critical functionalities can be utilized by triggering
the associated web event and feeding it with appropriate input
that follows the format “mmsdk://c1.c2?args=...&call
back=...”, where c1 and c2 are the native functions to be
accessed, args are the function’s parameters and callback is a
JavaScript function name to receive the execution result of the
native function.
In addition to the above scenario, another potential attack
scenario is that a path to a critical functionality inside an event
^ĞƌǀĞƌŶĚƌŽŝĚĞǀŝĐĞĞŶŝŐŶ,ǇďƌŝĚƉƉtĞďǀĞŶƚƐ͙͙͘͘ĞϭĞϮ,dD>ͬ:ĂǀĂ^ĐƌŝƉƚŽĚĞ,dD>ZĞŶĚĞƌΘ:^ŶŐŝŶĞĞŶ:ĂǀĂ;EĂƚŝǀĞͿǀĞŶƚ,ĂŶĚůĞƌƐ͙͙͘͘ĞŚϭĞŚϮĞŚŶtĞďsŝĞǁϭϮϯϰϭtĞďͲEĂƚŝǀĞƌŝĚŐĞƌŝƚŝĐĂů&ƵŶĐƚŝŽŶĂůŝƚŝĞƐ;Ğ͘Ő͕͘ƵƚŚ͕͘ZĞƐŽƵƌĐĞƐĐĐĞƐƐ͕:^ǆĞĐƵƚŝŽŶͿhandler may be executed only under a speciﬁc program state,
but such state may not be simply reached by only feeding that
event handler with arbitrary input. Instead, similar to return
oriented programming based attacks [32], it is possible for
adversaries to play web events as “gadgets” and change an
app’s state. Assume the target program state is St. It may be
reached through the transitions [S1→S2→ ... →St], which
could be achieved by triggering the sequence of web events
[E1→E2→ ... →Et]. Hence, by following the above web event
chain, adversaries can still change the program state to St and
execute the target critical functionality.
For convenience, in this paper, we generalize all above
attacks as Event-Oriented Exploit (EOE). Due to EOE’s
powerful capabilities to access critical functionalities through
event handlers, serious consequences may be caused, such
as local resource access, users’ private data leakage and web
cross-frame DOM manipulation.
Compared with existing attacks on Android (such as Trojan
Attack [7]), EOE has multiple advantages. First, EOE does not
require any extra permissions. The malicious web code injected
by adversaries fully inherits the target apps’ permissions.
Second, EOE does not require malicious payloads. Instead,
the functionalities contained in event handlers are utilized.
Furthermore, compared with existing attacks on WebView
(such as sidewinder targeted attack [38], fracking attack
[19], and code injection attack [24]), EOE is more practi-
cal and feasible. Existing attacks usually require JavaScript
and JavaScript-bridge to be enabled, but EOE has no such
requirements (Section V-A). Even only through HTML code
and special HTTP(s) responses, adversaries can still trigger
and leverage many event handlers, including the popular event
handlers shouldOverrideUrlLoading(), which handles the URL
navigation event.
The impact of EOE to smartphone security is serious
considering the pervasive deployment of hybrid apps today.
However, exiting techniques face signiﬁcant challenges in
detecting and verifying apps against EOE. Static analysis suffers
from high false positives due to the lack of real data and
context. In addition, the limitation of static analysis for handling
Java reﬂection is exacerbated when the reﬂection operation is
combined with array-indexing type implicit ﬂows, which occur
frequently when parsing the gadgets’ inputs. Dynamic analysis
may have low false positives, but is prone to low code coverage.
Moreover, generating the required sequence of gadgets to reveal
an EOE vulnerability is inherently challenging.
Our Approach. In this paper, we present a systematic study
of EOE in Android hybrid apps together with a novel technique,
EOEDroid, which can automatically analyze event handlers,
detect exploitable critical functionalities, and further generate
exploit code. EOEDroid can be applied to help developers detect
and verify the EOE security issues before publishing their apps.
The basic idea behind EOEDroid is that a critical functionality
f can be leveraged by adversaries if there is a program state
s that makes f’s corresponding path p to be feasible. Since
state s can be inﬂuenced or determined by all conditional
statements [c0, c1, ..., cn] along p, if adversaries can affect the
path selection of each ci, the program may be executed along
p. To cover each ci, adversaries have two ways: (1) feeding
the event handler with appropriate input, and (2) changing
execution orders of event handlers. Our goal is to explore these
two ways to cover every ci to reach f. For convenience, we
refer to the second case as event handler dependency, which
is deﬁned as follows. If operands of a condition c0 in the path
p0 of an event handler eh0 can be inﬂuenced by the path p1 of
another event handler eh1, we say eh0 depends on eh1 on c0
(i.g., (cid:104)eh1, p1(cid:105) c0−→ (cid:104)eh0, p0(cid:105)). This means that if adversaries
ﬁrst guide the app to execute p1, the program state related to
c0 may be inﬂuenced, and then, the expected branch behind
c0 may be taken.
The design of EOEDroid is depicted in Figure 2. Given a
target app, EOEDroid ﬁrst employs selective symbolic execution
to analyze all its event handlers, actively explore all interesting
paths and identify critical functionalities. The path constraints
of each interesting path are collected for further analysis. A
signiﬁcant difference with existing symbolic execution based
techniques is that EOEDroid carefully handles all conditional
statements, including those whose associated operands are not
symbolic (i.e., concrete or constant). This is because those
conditional statements can provide hints to generate gadgets’
execution orders.
To mitigate the notorious “path explosion” problem in
symbolic execution, we use several heuristics (e.g., scanning
“interesting” APIs and instructions to discover interesting paths
in Section V-B1). While these heuristics might cause over-
approximation and/or inaccuracy to our analysis, they help us
make a good tradeoff between performance and accuracy. In
addition, we propose new solutions to address the analysis
challenges raised by array-indexing type implicit ﬂows as well
as Android features and speciﬁcations such as unsupported
fork() [1] and inter-component communication (e.g., Android
Intent).
Based on the results of selective symbolic execution,
EOEDroid then applies static analysis to discover program
states that can lead to the execution of a critical functionality,
and generates input and execution order of event handlers to
reach the program state. The input of an event handler can be
generated by solving its path constraints, and the execution
order of event handlers can be constructed by solving the event
handler dependency problem on those conditional statements
whose operands are not symbolic.
Finally, EOEDroid generates exploit code by converting
event handlers’ input and execution orders to gadgets’ (i.e.,
web events). If JavaScript code is required as gadgets’ input,
EOEDroid is also aware of its syntax and generates the required
code.
Along with this, we conduct a systematic study of events,
event handlers, and their triggering code and constraints in
WebView. We ﬁnd that 37 web events are exposed to adversaries,
and the constraints on triggering events and event handlers are
mainly caused by the status of JavaScript and the level of the
web frame the malicious code is injected into. We also ﬁnd
that ﬁve event handlers have extra trigger constraints caused
by predetermined execution orders of event handlers, and we
identify 29 channels that can pass data from web code to native
code.
Evaluation. We have implemented EOEDroid based on the
Android framework and the Dalvik virtual machine (DVM),
and evaluated it with 3,652 most popular apps collected from
Google Play. EOEDroid found 97 total vulnerabilities in 58
2
Figure 2: The Design of EOEDroid.
apps, including 2 cross-frame DOM manipulation, 53 phishing,
30 sensitive information leakage, 1 local resources access,
and 11 Intent abuse vulnerabilities. We also found a potential
backdoor in a high-proﬁle app that may be used by adversaries
to steal users’ sensitive information, such as IMEI. Even though
the developers of the app attempted to close the backdoor,
EOEDroid found that adversaries were still able to exploit it by
triggering two events together and feeding event handlers with
appropriate inputs. We show more details in our case study in
Section VI-C2 to illustrate this vulnerability.
We have reported all our ﬁndings to app developers, and
are working with them to ﬁx the vulnerabilities.
To sum up, we make the following contributions:
• We present a systematic study of Event-Oriented
Exploits (EOE) in Android hybrid apps and a novel
technique EOEDroid to automatically generate exploits
that reveal security vulnerabilities.
• We thoroughly study events and event handlers as well
• We evaluate EOEDroid using 3,652 hybrid apps.
EOEDroid identiﬁed 97 vulnerabilities in 58 apps that
can cause critical attacks.
as their triggering constraints in WebView.
II. BACKGROUND: ANDROID APPS, WEBVIEW, AND
EVENT HANDLERS
Android apps are typically written in Java and compiled
to Dalvik bytecode [5]. At runtime, bytecodes are interpreted
and executed by Dalvik virtual machine (DVM) [4]. Generally,
an app consists of four components: activity (i.e., the user
interface), background service, content providers (i.e., database),
and Android native event receivers. Intent can be used in
interactions among components and apps.
WebView is a small UI component in Android, which can
be integrated into apps to display web pages. WebView can
also execute JavaScript code if developers enable JavaScript
in WebView’s settings, which is disabled by default. WebView
settings can also be used to disable local ﬁles, database, and
GPS location access.
The event handler feature makes WebView more powerful.
Usually, the function prototypes of event handlers are pre-
deﬁned by the Android system in the native (i.e., Java in
Android) language. Hence, to implement an event handler,
developers need to override the corresponding Java function,
and then register the implementation in WebView. When
the corresponding event is triggered in the web context, the
event handler implemented by developers is called to handle
it. For instance, developers can override the event handler
shouldOverrideUrlLoading() to handle the URL navigation
event. If an event handler is not implemented by developers,
the default implementation in the Android system will be called.
WebView manages event handlers by either itself or event
handler classes. An event handler class is a collection of event
handlers. There are mainly two types of event handler classes.
One is WebViewClient, which manages the event handlers that
are relevant to URL navigation. The other is WebChromeClient,
which manages the event handlers that are relevant to UI display,
such as handling the alert dialog opened by JavaScript alert().
Through the API loadUrl(), WebView renders content in its
UI component. The parameter format supported by loadUrl()
is diverse. It can be a URL, a local HTML ﬁle, or JavaScript
code. If the parameter is JavaScript code, 1) it must start with
the special string “javascript:”, and 2) it is executed in the
main web frame. For instance, the following code will popup
an alert window to show current cookie in the main frame:
WebView.loadUrl("javascript:alert(document.cookie);").
III. PROBLEM STATEMENT
A. Motivating Example
To illustrate event-oriented exploits, we walk through a real-
world vulnerable app with relevant code shown in Figure 3. In
the activity “WebViewActivity”, the app initializes a webview
component by a class “MyClient”, which implements an event
handler “shouldOverrideUrlLoading()”. In the event handler,
the input url is ﬁrstly parsed by a class “URI”, which is
commonly used to analyze URI’s syntax and extract useful
information, such as URI’s scheme and host. Then, the url’s
content is analyzed, which determines the event handler’s
behaviors. If the url’s scheme is “market”, “tel”, or “sms”,
the corresponding external apps (such as Google Play, default
phone call app, or default text message app) will be opened to
handle the input (Path1). If the url’s host is “developer.com”
(which means WebView connects to a remote server), the event
handler may approve the connection (Path2).
Meanwhile, the event handler implements supports for the
customized scheme “sdk”. If the url’s host h is “init”, WebView
executes JavaScript code to perform initialization (Path3). If
h’s format is “c0.c1.c2”, the app calls the Java method whose
class name is determined by c0, method name c1, and execution
result is transferred to the JavaScript method c3 (Path4). Note
that resolving the Java method relies on the content of the
variable “hashmap”, which converts c0 (i.e., commands[0])
to the real class name (i.e., className). Such an operation
introduces an implicit ﬂow from c0 to className. “Class2” is
one of classes whose methods can be invoked by the event
3
,ĞƵƌŝƐƚŝĐ'ĞŶĞƌĂƚŝŽŶ/ŶƚĞŶƚ,ĂŶĚůĞƌ/ŵƉůŝĐŝƚ&ůŽǁ,ĂŶĚůĞƌ;ĂƌƌĂǇͲŝŶĚĞǆŝŶŐƚǇƉĞͿǀĞŶƚ,ĂŶĚůĞƌƐǀĞŶƚ,ĂŶĚůĞƌǆĞĐƵƚŝŽŶKƌĚĞƌ'ĞŶĞƌĂƚŝŽŶǀĞŶƚ,ĂŶĚůĞƌŶĂůǇƐŝƐŶĂůǇƐŝƐ^ĂŶĚďŽǆǇŶĂŵŝĐŶĂůǇƐŝƐ^ƚĂƚŝĐŶĂůǇƐŝƐǀĞŶƚ,ĂŶĚůĞƌ/ŶƉƵƚ'ĞŶĞƌĂƚŝŽŶWƌŽŐƌĂŵ^ƚĂƚĞŶĂůǇƐŝƐ:ĂǀĂ^ĐƌŝƉƚŽĚĞ^ǇŶƚĂǆŶĂůǇƐŝƐǆƉůŽŝƚŽĚĞ'ĞŶĞƌĂƚŝŽŶ^ĞůĞĐƚŝǀĞ^ǇŵďŽůŝĐǆĞĐƵƚŝŽŶƌŝƚŝĐĂů&ƵŶĐƚŝŽŶĂůŝƚŝĞƐ/ŶƚĞƌĞƐƚŝŶŐWĂƚŚƐΘWĂƚŚŽŶƐƚƌĂŝŶƚƐǀĞŶƚ,ĂŶĚůĞƌ/ŶƉƵƚΘǆĞĐƵƚŝŽŶKƌĚĞƌƐsƵůŶĞƌĂďŝůŝƚŝĞƐǆƉůŽŝƚŽĚĞWŚĂƐĞϭWŚĂƐĞϮWŚĂƐĞϯFigure 3: Vulnerable Code From A Real-World App.
handler. In its method getId(), the device ID is transferred to
the web space. In its method login(), the activity “LoginActivity”
is started through an Intent message to ask users to login. In the
Intent message, part of the url’s content (i.e., c2) is contained