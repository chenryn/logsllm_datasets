JavaScript中的异常捕获与其他大多数语言类似：try语句可以聚合语句，并能够让你拦截这些语句中的异常。
14.2.1 throw
throw的语法如下：
你可以抛出任何的JavaScript值。简单起见，许多JavaScript程序只抛出字符串错误：
但是不要像上面这样做。在JavaScript中，有专门用于异常处理的对象（详情可见14.3“Error构造器”）。我们可以使用它们及其子类（详见第28章）。这样做的好处是，大多数JavaScript引擎会自动加上栈跟踪，并且错误对象会提供更丰富的上下文信息。要使用它们的最简单的方式是使用内置的Error()构造器：
14.2.2 try-catch-finally
下面是try-catch-finally语句的语法。try是必选的，而catch和finally两者至少要有其一：
其工作原理是这样的：
catch会捕获到try_statements中抛出的任何的异常，无论是直接抛出的异常还是其中函数调用抛出的异常。提示：如果你想区分这两种异常，你可以使用其构造器属性来区分（可参考17.10.3小节的“constructor属性的用例”）。
而不论try_statements中发生了什么，finally会永远执行。不管try_statements的执行情况，往往我们都会在finally里面做一些清理工作：
如果try_statements中存在return，那么try的代码块将会延后执行（在函数或者方式执行之后再立即执行，我们可以看看下面的例子）。
14.2.3 例子
任何值都可以被抛出来：
我们来运行一下代码：
finally总是执行的：
我们再来运行一下代码：
finally在return语句之后执行：
执行一下：
在执行finally之前，返回值被放入了队列：
在语句（1）执行的时候，count的值已经被存入队列等待返回：
14.3 Error构造器
ECMAScript标准化了以下错误构造函数。描述引用自ECMAScript 5的规范。
Error是通用异常构造器。所有其他的异常构造器都是它的子构造器。
EvalError“在标准中未使用，它只是为了兼容上一版本的标准”。
RangeError“表示一个数值超出了允许的范围”。例如：
ReferenceError“表示发现了一个非法的引用值”，通常这是一个未知的变量。例如：
SyntaxError“表示产生了一个语法解析错误”。例如，当你使用eval来解析以下代码：
TypeError“表示一个被操作值的实际类型与其期望的类型不一致”。例如：
URIError“表示某个全局的URI控制函数的使用不兼容其定义”。例如：
以下则是异常的属性值。
message
是异常的信息。
name
是异常的名称。
Stack
是栈跟踪。它不是标准的，但很多平台都在使用。例如，Chrome、Node.js和Firefox。
14.4 栈跟踪
通常情况下，异常来自外部（错误的输入、无法找到文件等）或内部（程序中的bug）。而后一种情况尤为常见，你往往会得到预期之外的异常，并需要debug。通常你没有debugger可用。对于“手动的”debug，有两种信息很有效：
（1）数据：变量可以有哪些值？
（2）执行：异常发生于哪一行，哪些函数是可以执行到的？
你可以把第一种信息（数据）放入异常对象的信息或者属性中。而后一种则在许多JavaScript引擎中都有支持。
通过栈跟踪，会创建异常对象的调用栈快照。下面的例子会输出一个调用栈：
这是运行的结果：
14.5 实现一个自己的异常构造器
如果你要进行栈跟踪，你就需要内置的错误构造器。你可以使用已有的构造器并将你自己的数据传递给它。或者你可以创建一个子构造器。这样它的实例可以通过instanceof来区别于其他的错误构造器。当然了，这样做还是挺复杂的；要学习如何做，你可以参考第28章。
第15章 函数
函数是可以被调用的值。一种定义函数的方式叫作函数声明。例如，下面的代码定义了一个叫id的函数，它具有一个参数x：
return语句使得id会返回一个值。你可以通过函数名，同时加上括号中的参数，来调用一个函数：
如果一个函数没有任何东西返回，那么默认会返回undefined：
这一节我们先为你展示了定义函数和调用函数的其中一种方式。后面我们还会介绍更多。
15.1 JavaScript中函数的3种形式
一旦你定义了一个函数，就像下面这样，它就拥有了多种调用形式：
非方法的函数(“普通函数”)
你可以直接调用函数，那么它会像一个普通函数一样运行。下面是一个例子：
通常，函数的命名以小写字母开头。
构造器
你也可以通过new操作符来调用一个函数。这时候函数将是一个构造器，一个创建对象的工厂。下面是对应的例子：
通常，函数作为构造器，其命名都以大写字母开始。
方法
你可以将一个函数存储为一个对象的属性，这时候它将变成一个方法，而你可以通过对象来调用它。例如：
按照惯例，方法的名称也是以小写字母开头。
非方法函数我们会在本章进行讲解，其余构造器和方法我们会在第17章进行讲解。
15.2 术语：“形参”和“实参”
在英文中，术语形参（parameter）和实参（argument）经常会混用。但实际上，因为其上下文关系，我们往往都可以很清楚地区分具体的哪个是形参，哪个是实参。下面是一些区分它们的准则。
形参被用在定义函数时。在下面的例子中，param1和param2都是形参：
实参在函数调用时被使用。下面的例子中，3和7为实参：
15.3 定义函数
本节我们来看看三种创建函数的方式：
通过函数表达式；
通过函数声明；
通过Function()构造器。
所有的函数都是对象、Function构造器的实例：
因此，函数从Function.prototype上继承了方法。
15.3.1 函数表达式
函数表达式会产生一个值——函数对象，例如：
上面的代码中，我们将一个函数表达式的结果赋值给了变量add，并通过这个变量名来调用函数。函数表达式的值可以赋给一个变量（正如上面例子中的），可以作为传入别的函数的参数等。由于普通的函数表达式没有名字，它们也被称为匿名函数表达式。
具名函数表达式
你可以给函数表达式一个名字，具名的函数表达式使得函数表达式可以引用它自己，这对于递归很有用：
注解：
 具名函数表达式的名字只能在函数表达式内部被访问：
15.3.2 函数声明
下面是一个函数声明：
上面的代码看着像是一个函数表达式，但是它是一个语句（可见7.3“表达式与语句”）。它与下面的代码基本是等价的：
换句话说，函数声明定义了一个新的变量，创建了一个函数对象，并将函数对象赋值给这个新的变量。
15.3.3 Function构造器
Function()构造器执行传给它的JavaScript代码字符串。例如，下面的例子就等同于前面的例子：
然而，这种定义函数的方式相对比较慢，并且把代码放在了字符串中(对于工具是不可访问的)。因此，我们还是要尽可能地使用函数表达式或者是函数声明。对于这点，23.4.2“通过new Function()执行代码”做了详细的解释;函数构造器的方式有点类似于eval()。
15.4 函数提升
函数提升表示“将函数的声明放到作用域的开始”。函数声明是做了完全提升的，而变量声明则是部分提升。
由于函数声明是完全提升的。这允许你在函数声明前进行函数的调用：
上面的代码是可以正常工作的，这是由于JavaScript引擎会将foo函数的声明放到其作用域最前面。因此代码实际上是这样执行的：
使用var的定义也是会进行代码提升的，但是只对于声明有效，对于赋值过程是无效的。因此，使用var来定义会导致下面的错误：
我们可以看到只有变量的定义被提升了。引擎实际会像这样解析上面的代码：
15.5 函数的名称
大多数的JavaScript引擎对于函数对象都会提供一个非标准的name属性。函数的声明会创建这样的一个属性：
而匿名函数表达式的name则是一个空字符串：
具名函数表达式也有一个name：
函数的名称对于debug是非常有用的。正因如此，有一些开发者往往会给函数表达式加上名字。
15.6 哪个更好，函数声明还是函数表达式
我们应该使用如下的函数声明：
还是使用等价的var声明+函数表达式的方式：
它们基本是一样的，但是函数声明相比函数表达式有两个优势：
函数声明会做代码提升（可见15.4“函数提升”），因此你可以在源码中先于函数的定义来调用函数。
它们具有名字（可见15.5“函数的名称”）。不过，JavaScript引擎也在对匿名函数表达式的名字引用做优化。
15.7 控制函数调用：call(), apply()和bind()
所有的函数(记住这里说的函数是指对象以及对象的方法)都具有call(), apply()和bind()方法。它们可以在执行方法时用一个值指向this，并改变面向对象的作用域(关于这点可以参考17.3.1“在调用函数时设置this:call(),apply()和bind()”)。这一节我们来看看两种对于非方法函数的调用例子。
15.7.1 func.apply(thisValue, argArray)
此方法在调用函数func时，argArray参数将作为函数的arguments传递给函数，以下的两种表达式是等价的：
而thisValue这个参数则可以指定执行func时的this值。在非面向对象的调用中它不是必要的，因此这里我们将它设定为null。
apply()往往用在一个函数需要以类似数组（但又不是数组）的形式接受多个参数。
多亏有了apply()，我们可以使用Math.max()（详情可见21.4“其他函数”）来获得一个数组中最大的元素：
15.7.2 func.bind(thisValue, arg1, ..., argN)
这个方法会执行部分的函数功能，它会创建一个新的函数，这个函数会调用func，并会将thisValue指定为this，同时应用以下参数：arg1直到argN，紧随其后的是新函数的实际参数。在下面的非面向对象的调用中，我们将thisValue设定为了null。
下面，我们使用bind()来创建一个新的plus1()函数，它类似add()函数，但是由于我们指定x始终为1，我们只需要传入参数y：
事实上，我们用类似以下代码创建了一个新的函数：
15.8 参数缺失或者超出时的处理
JavaScript中并不限制一个函数的参数数量：因此你事实上可以抛开函数定义的参数限制，向一个函数传入任意数量的实参。这就导致了实参和形参可能出现两种差异：
（1）实参数量多于形参
对此，多余的参数是会被忽略的，但是能在类数组的arguments中被获取到。
（2）实参数量少于形参
缺失的形参都会被赋予undefined的值。
15.8.1 通过索引访问所有参数：神奇的arguments变量
arguments变量非常特别，并且它只存在于函数中（包括方法）。它是一个类数组的对象，包含了当前函数调用的所有实参。我们来看看下面的代码：
下面是调用的结果：
arguments有以下的特征：
它是类数组的，但又非数组。一方面，它有一个length属性，所有的参数都可以通过索引值来进行读写。
    另一方面，arguments不是一个数组，它仅仅是类似。它并没有数组的方法（slice(),forEach()等）。谢天谢地，我们可以借用数组的方法或者将arguments转化为数组，这个方式在17.15.3“类似数组的对象和泛型方法”中有讨论。
它是一个对象，因此它支持所有的对象方法和操作。例如，你可以使用in操作符（详情可见17.5“遍历和检测属性”）来检测arguments是否包含有指定索引位的参数。
你也可以用类似的方式使用hasOwnProperty()（同样详情可见17.5“遍历和检测属性”）。
arguments的废弃特性
在JavaScript的严格模式中，禁用了arguments的一些非常用特性。
arguments.callee指向了当前调用的函数。它一般用于匿名函数的自递归调用，但是它在严格模式中是禁用的。相对应的，我们推荐使用具名函数表达式(详情可参见15.3.1小节的“具名函数表达式”)，它可以用函数名来自引用。
在非严格模式中，当你改变了一个参数，arguments会实时地变化：
      但是在严格模式中，并不支持这一特性：
严格模式禁用了对变量arguments的分配（例如，通过arguments++）。对元素和属性的分配还是允许的。
15.8.2 强制性参数，限制参数数量的最小值
要判断一个参数是否缺失，我们有三种方式。第一种，你可以检测它的值是否为undefined：
第二种方式，你可以将参数转化为布尔值。undefined会被认为false。不过这种方式有一个漏洞：还有一些其他的值也会被认为是false（详情可见10.1.2“真值和假值”），因此这种方式不能区分例如0和一个缺失参数的情况：
最后一种方式，你可以用arguments.length来检测并强制指定参数数量的最小值：
最后一种方式相比前两种有一些区别：
前两种方式无法区分foo()和foo(undefined)。它们对于两种情况会抛一样的错误。
第三种方式会对foo()抛错，而对于foo(undefined)会正常使用undefined传入函数并调用。
15.8.3 可选参数
如果参数是可选的，这意味着当你没有指定这个参数，它将会使用默认值。类似于强制性参数，我们有四种处理可选参数的选择。
第一种，检测undefined：
第二种，将可选参数转换为布尔值：
第三种，你可以使用或运算符（详情可见10.2.3“逻辑或(||)”），如果左侧操作数不是false值，则返回左侧的操作数，否则将返回右侧的操作数：
第四种，你可以使用arguments.length来检测函数支持的最小数量的参数。
同样的，最后一种方式有别于其他的方式：
前三种方式无法区分bar(1,2)和bar(1,2,undefined)。这两种情况下，optional的值都是默认值。
第四种方式对于bar(1,2)会使用默认值，而对于bar(1,2,undefined)会保留undefined的传入。
还有一种处理可选参数的方式是使用具名参数，通过对象字面量的属性的方式（详情可见15.9“具名参数”）。
15.8.4 模拟参数的引用传递
在JavaScript中，你不能传递参数的引用；因此，当你将一个变量传递给一个函数，它的值会被复制一份并传递给函数（值传递）。因此，在函数中，你无法改变变量。如果你想要这么做，你必须将变量的值包装到一个数组中。
下面的例子展示了在函数中如何递增一个变量：
15.8.5 陷阱：非预期的可选参数