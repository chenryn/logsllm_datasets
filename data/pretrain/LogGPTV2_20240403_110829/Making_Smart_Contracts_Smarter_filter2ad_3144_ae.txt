dled exceptions ﬂagged by Oyente, which account for 27.9%
of the contracts in our benchmark. Out of these 5, 411 con-
tracts, 1, 385 are found to be distinct and 116 contracts have
source code available. By manual analysis, we verify that
all these 116 contracts are true positives. In order to con-
ﬁrm, we identify if any external calls (SEND, CALL instruc-
tions) are present and not followed by any checks for failures.
These failure checks are implemented by verifying if the re-
turn value is non-zero.
The prevalence of this problem is explained by the follow-
ing observation. In the ﬁrst 1, 459, 999 blocks on the public
blockchain, 180, 394 cross-contract calls were processed. For
each contract invocation, there may be additional calls to
other contracts, thus increasing the call-stack depth. These
can be due to function or library calls, external account
transactions, or nested recursive contract calls. We plot the
call-stack depths of these contract invocations in Figure 14,
which shows that most of them involve some level of nesting
(e.g., invoking other contracts). Further, all contract invo-
cations do not exceed the call-stack depth of 50 in benign
runs, which is far below the call-stack depth’s limit of 1, 024.
This explains why exceptions are commonly unexpected and
unhandled in benign invocations.
Transaction-ordering dependence. The TOD contracts
are less common with 3, 056 contracts, or 15.7% of the con-
tracts in our benchmarks. Of these contracts, there are 135
distinct contracts and 32 have source code available. We
manually verify that 9 of them are false positives and 23
are true positives. In order to conﬁrm, we look for diﬀerent
ﬂows of Ether wherein the outcome depends on the order of
the input transactions.
Several true positive cases, where this dependence is ex-
ploitable, are discussed later. As an example of a false pos-
itive, Figure 15 shows a case where there are two separate
ﬂows of Ether, but the order of their execution does not
change the outcome of the contract. The ﬁrst ﬂow (send
ExceptionTODReentrancyTimestamp02,0004,0005,4113,056340831,38513518652No.ofcontractsNo.ofuniquecontracts051015202530354045500200040006000800010000120001400002000400060008000100001200014000160001800020000Distinct InstructionsTotal instructionsContracts (numbered from 1 to 19, 366)No. of instructionsNo. of distinct instructionsuint amount = msg . value ;
if (( amount  0)
}}
owners may not receive the payment and still have to trans-
fer the ownership of their ID to the buyers. There is no way
for the owners to claim the payment later on. The Ether
value is locked in the contract forever.
6.4 Public Veriﬁcation
Verifying the above attack on the public blockchain is fea-
sible, but for ethical reasons we do not conduct our attack
conﬁrmation on contracts [22, 25, 26] where users may lose
funds. Instead, we perform our veriﬁcation on EtherID con-
tract on which the attack has less severity. More impor-
tantly, EtherID allows us to target our own accounts, other
accounts are not aﬀected in the experiments.
We verify the problem of EtherID by creating our own IDs
and self-purchasing them. We show that the registers of our
IDs do not receive the intended payments when the registers
use contract wallets, or when the buyers are malicious and
conduct the call-stack exceeding attack.
Our two IDs are dummywallet and foowallet registered by
two addresses 0x33dc532ec9b61ee7d8adf558ﬀ248542c2a2a62e
and 0x62ec11a7fb5e35bd9e243eb7f867a303e0dfe08b respectively.
The price to buy either of the ID is 0.01 Ether. The address
0x33dc532...
is a contract address, which performs some
computation (thus burning gas) on receiving any payment.
We then send two transactions from diﬀerent addresses to
buy the two IDs. The ﬁrst transaction 6 purchases dummy-
wallet. However, 0x33dc532... is a contract address, which is
implemented to burn all the provided gas on receiving any
payment without doing anything else. Thus the send func-
tion in Line 4 of EtherID to 0x33dc532... will fail. As a result,
0x33dc532... sells it ID without receiving any payment. The
fund 0.01 Ethers is kept in the contract EtherID forever.
The second transaction 7 sent from a contract, which calls
itself 1023 times before sending a buy request to EtherID to
buy foowallet. The code snippet to perform such attack is
in Figure 16. When EtherID executes send in Line 4, the
call stack already has 1024 frames, so send fails regardless
of how much gas is used. Hence, the address 0x62ec11a7...
does not receive the payment of 0.01 Ethers as it should.
7. RELATED WORK
Smart Contract Security. Delmolino et al. [14] show that
even a simple self-construct contract (e.g., “Rock, Paper,
6TX hash:
4c1216cd659350f83ef44ba071b4
7TX
986cc1050c850481f79b1a862bb10a
hash:
0xb169b07c274a71727ecfe9d0610d09917c45-
0x0c10fafe0cdbﬀf32abfe53d57ec861d09-
. send ( p r o f i t F r o m C r a s h );
owner . send ( this . balance );
block . t i m e s t a m p ) {
msg . sender . send ( amount );
// Sends jacpot to the last c r e d i t o r
c r e d i t o r A d d r e s s e s [ c r e d i t o r A d d r e s s e s . length - 1]
returns ( bool ) {
uint amount = msg . value ;
// check the c o n d i t i o n to end the game
if ( l a s t T i m e O f N e w C r e d i t + T W E L V E _ H O U R S >
1 f u n c t i o n l e n d G o v e r n m e n t M o n e y ( address buddy )
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
Figure 17: PonziGovernmentMental contract, with over 1000
Ether, allows users to participate/proﬁt from the creation/fall
of a government.
// Reset c o n t r a c t state
l a s t C r e d i t o r P a y e d O u t = 0;
l a s t T i m e O f N e w C r e d i t = block . t i m e s t a m p ;
p r o f i t F r o m C r a s h = 0;
c r e d i t o r A d d r e s s e s = new address [](0);
c r e d i t o r A m o u n t s = new uint [](0);
round += 1;
return false ;
}}
Scissors”) can contain several logic problems, including:
• Contracts do not refund. Some contracts proceed further
only if users send a certain amount of Ether. However,
these contracts sometimes “forget” to refund users if users
send less than what is required.
• Lack of cryptography to achieve fairness. Some contracts
perform computation based on users’ inputs to decide the
outcome (e.g., rolling a die). However, those contracts
store users’ input in plaintext on the blockchain. Thus,
malicious users can submit inputs biased in their favor.
• Incentive misalignment. Some contracts do not incen-
tivize users to follow intended behavior. Consider a gam-
bling game that uses a commit-reveal scheme in which
participants ﬁrst submit their encrypted move along with
a deposit before later revealing it. After the ﬁrst move is
revealed, the second user may realize his move will lose.
Since his deposit lost, he may not be willing to spend gas
to reveal his choice.
These security problems are more about logical ﬂaws in the
implementation of contracts. In contrast, our paper docu-
ments new security bugs stemming from semantic misunder-
standings of smart contract developers. We suggest improve-
ments to the semantics and introduce Oyente to detect
these bugs in existing contracts in the Ethereum blockchain.
Our evaluation showed that 8, 519 existing contracts con-
tain at least one of the new bugs. The call-stack problem
of Ethereum was reported previously in a security audit by
Miller et al. [24]. The bug, however, still remains unﬁxed.
Other work also studies security and/or privacy concerns
in designing smart contracts [6, 27, 39, 40]. For instance,
Hawk [27] provides conﬁdential execution for contracts by
leveraging cryptographic techniques and Town Crier [39]
feeds reliable, trustworthy data from trusted web servers to
smart contracts via hardware rooted trust.
Distributed Systems and Programming Languages.
Security problems in smart contracts are often related to
problems in traditional distributed systems. For example,
concurrency control in multiuser distributed database sys-
tems (DBMS) [41] is superﬁcially similar to the transaction-
order dependency problem. However, transaction-ordering
problems in permissionless distributed systems like cryp-
if ( d . price > 0)
msg . value >= d . price ){
address ( d . owner ). send ( d . price );
1 // ID on sale , and enough money
2 if ( d . price > 0 &&
3
4
5
6
7
8
9
d . owner = msg . sender ; // Change the o w n e r s h i p
d . price = price ;
d . t r a n s f e r = t r a n s f e r ;
d . expires = block . number + expires ;
D o m a i n C h a n g e d ( msg . sender , domain , 0 );
// New price
// New t r a n s f e r
10 }
Figure 18: EtherID contract, which allows users to register, buy
and sell any ID. This code snippet handles buy requests from
users.
tocurrencies are more complex than in traditional systems
because adversaries can manipulate the order.
Many previous works attempt to build a global times-
tamp in distributed systems, in both asynchronous and syn-
chronous settings [42–44]. Time in distributed systems tra-
ditionally forms a partial order rather than the the total
order given by the blockchain. As we discussed in Section 3,
having access to the block timestamp (in addition to the
block id) is redundant and invites attack. Lastly, propagat-
ing exceptions is inspired by the exception handling mecha-
nism in modern languages [45, 46].