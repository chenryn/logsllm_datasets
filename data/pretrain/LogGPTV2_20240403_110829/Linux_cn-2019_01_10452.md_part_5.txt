```
Sending ARP announcement...
Waiting for packets...
e1000: index 0: 0x26dea0 : 900002a 0
e1000: unicast match[0]: 52:54:00:12:34:56
input: 0000 5254 0012 3456 5255 0a00 0202 0806 0001
input: 0010 0800 0604 0002 5255 0a00 0202 0a00 0202
input: 0020 5254 0012 3456 0a00 020f 0000 0000 0000
input: 0030 0000 0000 0000 0000 0000 0000 0000 0000
```
“input:” 打头的行是一个 QEMU 的 ARP 回复的十六进制转储。
你的代码应该会通过 `make grade` 的 `testinput` 测试。注意，在没有发送至少一个包去通知 QEMU 中的 JOS 的 IP 地址上时，是没法去测试包接收的，因此在你的发送代码中的 bug 可能会导致测试失败。
为彻底地测试你的网络代码，我们提供了一个称为 `echosrv` 的守护程序，它在端口 7 上设置运行 `echo` 的服务器，它将回显通过 TCP 连接发送给它的任何内容。使用 `make E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER run-echosrv` 在一个终端中启动 `echo` 服务器，然后在另一个终端中通过 `make nc-7` 去连接它。你输入的每一行都被这个服务器回显出来。每次在仿真的 E1000 上接收到一个包，QEMU 将在控制台上输出像下面这样的内容：
```
e1000: unicast match[0]: 52:54:00:12:34:56
e1000: index 2: 0x26ea7c : 9000036 0
e1000: index 3: 0x26f06a : 9000039 0
e1000: unicast match[0]: 52:54:00:12:34:56
```
做到这一点后，你应该也就能通过 `echosrv` 的测试了。
> 
> **问题 2**、你如何构造你的接收实现？在实践中，如果接收队列是空的并且一个用户环境要求下一个入站包，你怎么办？
> 
> 
> 
.
> 
> 小挑战！在开发者手册中阅读关于 EEPROM 的内容，并写出从 EEPROM 中加载 E1000 的 MAC 地址的代码。目前，QEMU 的默认 MAC 地址是硬编码到你的接收初始化代码和 lwIP 中的。修复你的初始化代码，让它能够从 EEPROM 中读取 MAC 地址，和增加一个系统调用去传递 MAC 地址到 lwIP 中，并修改 lwIP 去从网卡上读取 MAC 地址。通过配置 QEMU 使用一个不同的 MAC 地址去测试你的变更。
> 
> 
> 
.
> 
> 小挑战！修改你的 E1000 驱动程序去使用 零复制 技术。目前，数据包是从用户空间缓存中复制到发送包缓存中，和从接收包缓存中复制回到用户空间缓存中。一个使用 ”零复制“ 技术的驱动程序可以通过直接让用户空间和 E1000 共享包缓存内存来实现。还有许多不同的方法去实现 ”零复制“，包括映射内容分配的结构到用户空间或直接传递用户提供的缓存到 E1000。不论你选择哪种方法，都要注意你如何利用缓存的问题，因为你不能在用户空间代码和 E1000 之间产生争用。
> 
> 
> 
.
> 
> 小挑战！把 “零复制” 的概念用到 lwIP 中。
> 
> 
> 一个典型的包是由许多头构成的。用户发送的数据被发送到 lwIP 中的一个缓存中。TCP 层要添加一个 TCP 包头，IP 层要添加一个 IP 包头，而 MAC 层有一个以太网头。甚至还有更多的部分增加到包上，这些部分要正确地连接到一起，以便于设备驱动程序能够发送最终的包。
> 
> 
> E1000 的发送描述符设计是非常适合收集分散在内存中的包片段的，像在 lwIP 中创建的包的帧。如果你排队多个发送描述符，但仅设置最后一个描述符的 EOP 命令位，那么 E1000 将在内部把这些描述符串成包缓存，并在它们标记完 EOP 后仅发送串起来的缓存。因此，独立的包片段不需要在内存中把它们连接到一起。
> 
> 
> 修改你的驱动程序，以使它能够发送由多个缓存且无需复制的片段组成的包，并且修改 lwIP 去避免它合并包片段，因为它现在能够正确处理了。
> 
> 
> 
.
> 
> 小挑战！增加你的系统调用接口，以便于它能够为多于一个的用户环境提供服务。如果有多个网络栈（和多个网络服务器）并且它们各自都有自己的 IP 地址运行在用户模式中，这将是非常有用的。接收系统调用将决定它需要哪个环境来转发每个入站的包。
> 
> 
> 注意，当前的接口并不知道两个包之间有何不同，并且如果多个环境去调用包接收的系统调用，各个环境将得到一个入站包的子集，而那个子集可能并不包含调用环境指定的那个包。
> 
> 
> 在 [这篇](http://pdos.csail.mit.edu/papers/exo:tocs.pdf) 外内核论文的 2.2 节和 3 节中对这个问题做了深度解释，并解释了在内核中（如 JOS）处理它的一个方法。用这个论文中的方法去解决这个问题，你不需要一个像论文中那么复杂的方案。
> 
> 
> 
#### Web 服务器
一个最简单的 web 服务器类型是发送一个文件的内容到请求的客户端。我们在 `user/httpd.c` 中提供了一个非常简单的 web 服务器的框架代码。这个框架内码处理入站连接并解析请求头。
> 
> **练习 13**、这个 web 服务器中缺失了发送一个文件的内容到客户端的处理代码。通过实现 `send_file` 和 `send_data` 完成这个 web 服务器。
> 
> 
> 
在你完成了这个 web 服务器后，启动这个 web 服务器（`make run-httpd-nox`），使用你喜欢的浏览器去浏览 `http://host:port/index.html` 地址。其中 host 是运行 QEMU 的计算机的名字（如果你在 athena 上运行 QEMU，使用 `hostname.mit.edu`（其中 hostname 是在 athena 上运行 `hostname` 命令的输出，或者如果你在运行 QEMU 的机器上运行 web 浏览器的话，直接使用 `localhost`），而 port 是 web 服务器运行 `make which-ports` 命令报告的端口号。你应该会看到一个由运行在 JOS 中的 HTTP 服务器提供的一个 web 页面。
到目前为止，你的评级测试得分应该是 105 分（满分为 105）。
> 
> 小挑战！在 JOS 中添加一个简单的聊天服务器，多个人可以连接到这个服务器上，并且任何用户输入的内容都被发送到其它用户。为实现它，你需要找到一个一次与多个套接字通讯的方法，并且在同一时间能够在同一个套接字上同时实现发送和接收。有多个方法可以达到这个目的。lwIP 为 `recv`（查看 `net/lwip/api/sockets.c` 中的 `lwip_recvfrom`）提供了一个 MSG\_DONTWAIT 标志，以便于你不断地轮询所有打开的套接字。注意，虽然网络服务器的 IPC 支持 `recv` 标志，但是通过普通的 `read` 函数并不能访问它们，因此你需要一个方法来传递这个标志。一个更高效的方法是为每个连接去启动一个或多个环境，并且使用 IPC 去协调它们。而且碰巧的是，对于一个套接字，在结构 Fd 中找到的 lwIP 套接字 ID 是全局的（不是每个环境私有的），因此，比如一个 `fork` 的子环境继承了它的父环境的套接字。或者，一个环境通过构建一个包含了正确套接字 ID 的 Fd 就能够发送到另一个环境的套接字上。
> 
> 
> **问题 3**、由 JOS 的 web 服务器提供的 web 页面显示了什么？
> 
> 
> 
.
> 
> **问题 4**、你做这个实验大约花了多长的时间？
> 
> 
> 
**本实验到此结束了。**一如既往，不要忘了运行 `make grade` 并去写下你的答案和挑战问题的解决方案的描述。在你动手之前，使用 `git status` 和 `git diff` 去检查你的变更，并不要忘了去 `git add answers-lab6.txt`。当你完成之后，使用 `git commit -am 'my solutions to lab 6’` 去提交你的变更，然后 `make handin` 并关注它的动向。
---
via: 
作者：[csail.mit](https://pdos.csail.mit.edu) 选题：[lujun9972](https://github.com/lujun9972) 译者：[qhwdw](https://github.com/qhwdw) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出