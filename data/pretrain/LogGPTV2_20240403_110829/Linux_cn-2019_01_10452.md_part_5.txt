### 优化后的文本

---

#### 发送 ARP 公告...

- **等待数据包...**
- **e1000: 索引 0: 0x26dea0 : 900002a 0**
- **e1000: 单播匹配[0]: 52:54:00:12:34:56**
- **输入: 0000 5254 0012 3456 5255 0a00 0202 0806 0001**
- **输入: 0010 0800 0604 0002 5255 0a00 0202 0a00 0202**
- **输入: 0020 5254 0012 3456 0a00 020f 0000 0000 0000**
- **输入: 0030 0000 0000 0000 0000 0000 0000 0000 0000**

以“input:”开头的行是 QEMU 的 ARP 回复的十六进制转储。

你的代码应该能够通过 `make grade` 中的 `testinput` 测试。请注意，在未向 QEMU 中的 JOS 通知其 IP 地址之前，无法测试数据包接收功能。因此，发送代码中的错误可能会导致测试失败。

为了彻底测试你的网络代码，我们提供了一个名为 `echosrv` 的守护程序，它在端口 7 上运行一个 `echo` 服务器，该服务器将回显通过 TCP 连接发送给它的任何内容。使用以下命令在一个终端中启动 `echo` 服务器：

```sh
make E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER run-echosrv
```

然后在另一个终端中使用以下命令连接到它：

```sh
make nc-7
```

你输入的每一行都将被服务器回显。每次在仿真的 E1000 上接收到一个数据包时，QEMU 将在控制台上输出类似以下的内容：

```
e1000: unicast match[0]: 52:54:00:12:34:56
e1000: index 2: 0x26ea7c : 9000036 0
e1000: index 3: 0x26f06a : 9000039 0
e1000: unicast match[0]: 52:54:00:12:34:56
```

完成这些步骤后，你应该能够通过 `echosrv` 的测试。

**问题 2**: 你是如何实现接收功能的？在实践中，如果接收队列为空且用户环境请求下一个入站数据包，你会如何处理？

**小挑战**:
1. 阅读开发者手册中关于 EEPROM 的内容，并编写从 EEPROM 中加载 E1000 MAC 地址的代码。目前，QEMU 的默认 MAC 地址是硬编码在你的接收初始化代码和 lwIP 中的。修复你的初始化代码，使其能够从 EEPROM 中读取 MAC 地址，并添加一个系统调用将 MAC 地址传递给 lwIP。修改 lwIP 以从网卡上读取 MAC 地址。通过配置 QEMU 使用不同的 MAC 地址来测试你的更改。
2. 修改你的 E1000 驱动程序以使用零复制技术。当前，数据包是从用户空间缓存复制到发送缓存中，再从接收缓存复制回用户空间缓存中。一个使用零复制技术的驱动程序可以通过让用户空间和 E1000 直接共享数据包缓存内存来实现。有许多不同的方法可以实现零复制，包括将分配的结构映射到用户空间或将用户提供的缓存直接传递给 E1000。无论选择哪种方法，请注意缓存管理，以避免在用户空间代码和 E1000 之间产生竞争条件。
3. 将零复制的概念应用到 lwIP 中。典型的包由多个头部组成。用户发送的数据被发送到 lwIP 中的一个缓存中。TCP 层添加一个 TCP 包头，IP 层添加一个 IP 包头，而 MAC 层有一个以太网头。E1000 的发送描述符设计非常适合收集分散在内存中的包片段。如果你排队多个发送描述符，但仅设置最后一个描述符的 EOP 命令位，E1000 将在内部把这些描述符串成一个包缓存，并在标记完 EOP 后仅发送串联起来的缓存。因此，独立的包片段不需要在内存中合并。修改你的驱动程序，使其能够发送由多个缓存片段组成的包，并修改 lwIP 以避免合并包片段。
4. 扩展你的系统调用接口，以便为多个用户环境提供服务。如果有多个网络栈（和多个网络服务器）并且它们各自都有自己的 IP 地址运行在用户模式中，这将非常有用。接收系统调用将决定需要哪个环境来转发每个入站数据包。当前的接口并不知道两个包之间的区别，如果多个环境调用包接收系统调用，每个环境将得到一个入站包的子集，而这个子集可能不包含调用环境指定的包。在 [这篇](http://pdos.csail.mit.edu/papers/exo:tocs.pdf) 外内核论文的 2.2 节和 3 节中对此进行了深入解释，并解释了在内核中（如 JOS）处理这个问题的一种方法。使用论文中的方法解决这个问题，不需要像论文中那样复杂的方案。

#### Web 服务器

最简单的 web 服务器类型是将文件内容发送到请求的客户端。我们在 `user/httpd.c` 中提供了一个非常简单的 web 服务器框架代码。该框架代码处理入站连接并解析请求头。

**练习 13**: 实现 `send_file` 和 `send_data` 完成这个 web 服务器。

完成这个 web 服务器后，启动它（`make run-httpd-nox`），使用你喜欢的浏览器访问 `http://host:port/index.html` 地址。其中 `host` 是运行 QEMU 的计算机的名字（如果你在 athena 上运行 QEMU，使用 `hostname.mit.edu`，其中 `hostname` 是在 athena 上运行 `hostname` 命令的输出，或者如果你在运行 QEMU 的机器上运行 web 浏览器的话，直接使用 `localhost`），而 `port` 是 web 服务器运行 `make which-ports` 命令报告的端口号。你应该会看到一个由运行在 JOS 中的 HTTP 服务器提供的 web 页面。

到目前为止，你的评级测试得分应该是 105 分（满分为 105）。

**小挑战**: 在 JOS 中添加一个简单的聊天服务器，允许多个人连接到该服务器，并且任何用户输入的内容都会被发送到其他用户。为此，你需要找到一种同时与多个套接字通信的方法，并在同一时间在一个套接字上同时实现发送和接收。有多种方法可以实现这一点。lwIP 为 `recv` 提供了一个 `MSG_DONTWAIT` 标志（查看 `net/lwip/api/sockets.c` 中的 `lwip_recvfrom`），以便你可以不断轮询所有打开的套接字。注意，虽然网络服务器的 IPC 支持 `recv` 标志，但通过普通的 `read` 函数无法访问它们，因此你需要一种方法来传递这个标志。更高效的方法是为每个连接启动一个或多个环境，并使用 IPC 来协调它们。碰巧的是，对于一个套接字，在结构 `Fd` 中找到的 lwIP 套接字 ID 是全局的（不是每个环境私有的），例如，一个 `fork` 的子环境继承了其父环境的套接字。或者，一个环境可以通过构建一个包含正确套接字 ID 的 `Fd` 将消息发送到另一个环境的套接字上。

**问题 3**: 由 JOS 的 web 服务器提供的 web 页面显示了什么？

**问题 4**: 你完成这个实验大约花了多长时间？

**本实验到此结束**。一如既往，不要忘记运行 `make grade` 并写下你的答案和挑战问题的解决方案的描述。在提交之前，使用 `git status` 和 `git diff` 检查你的更改，并确保 `git add answers-lab6.txt`。完成后，使用 `git commit -am 'my solutions to lab 6’` 提交你的更改，然后 `make handin` 并关注其进度。

---

作者：[csail.mit](https://pdos.csail.mit.edu)  
选题：[lujun9972](https://github.com/lujun9972)  
译者：[qhwdw](https://github.com/qhwdw)  
校对：[wxy](https://github.com/wxy)

本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出。