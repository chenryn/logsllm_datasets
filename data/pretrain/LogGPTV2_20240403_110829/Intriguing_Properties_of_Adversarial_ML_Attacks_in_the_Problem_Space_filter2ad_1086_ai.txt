a
l
i
c
i
o
u
s
t
e
s
t
e
d
b
y
s
e
m
a
n
t
i
c
s
e
m
u
l
a
t
o
r
.
t
r
a
n
s
p
l
a
n
t
a
t
i
o
n
.
(
i
i
)
M
u
t
a
t
e
d
a
p
p
s
a
u
t
o
m
a
t
e
d
s
o
f
t
w
a
r
e
i
n
s
t
a
l
l
a
n
d
s
t
a
r
t
o
n
a
n
b
y
(
i
)
t
h
r
o
u
g
h
u
s
e
o
f
c
o
n
s
t
r
u
c
t
i
o
n
C
o
d
e
i
s
r
e
a
l
i
s
t
i
c
i
n
s
t
r
u
c
t
i
o
n
s
.
n
a
m
e
c
o
n
ﬂ
i
c
t
s
,
n
o
-
o
p
u
n
d
e
ﬁ
n
e
d
r
e
f
e
r
e
n
c
e
s
,
u
n
l
i
n
k
e
d
r
e
s
o
u
r
c
e
s
,
u
n
d
e
c
l
a
r
e
d
v
a
r
i
a
b
l
e
s
,
r
e
d
u
n
d
a
n
t
R
o
b
u
s
t
t
o
:
c
o
d
e
,
r
e
m
o
v
a
l
o
f
r
u
n
t
i
m
e
)
.
i
s
n
o
t
e
x
e
c
u
t
e
d
a
t
(
n
e
w
l
y
o
p
a
q
u
e
p
r
e
d
i
c
a
t
e
s
i
n
s
e
r
t
e
d
c
o
d
e
c
o
n
s
t
r
u
c
t
i
o
n
w
i
t
h
p
r
e
s
e
r
v
e
d
M
a
l
i
c
i
o
u
s
b
y
s
e
m
a
n
t
i
c
s
s
o
f
t
w
a
r
e
t
r
a
n
s
p
l
a
n
t
a
t
i
o
n
.
t
h
r
o
u
g
h
a
u
t
o
m
a
t
e
d
t
h
e
s
a
m
e
p
r
o
g
r
a
m
)
C
o
d
e
a
d
d
i
t
i
o
n
a
n
d
m
o
d
i
ﬁ
c
a
t
i
o
n
(
w
i
t
h
i
n
s
o
f
t
w
a
r
e
t
r
a
n
s
p
l
a
n
t
a
t
i
o
n
.
C
o
d
e
a
d
d
i
t
i
o
n
t
h
r
o
u
g
h
a
u
t
o
m
a
t
e
d
D
e
e
p
l
e
a
r
n
i
n
g
(
M
a
l
C
o
n
v
[
5
9
]
)
.
(
e
.
g
.
,
R
F
,
S
V
M
)
.
t
r
a
d
i
t
i
o
n
a
l
c
l
a
s
s
i
ﬁ
e
r
s
a
n
d
t
r
a
n
s
f
e
r
a
b
i
l
i
t
y
t
o
/
R
N
N
L
S
T
M
v
a
r
i
a
n
t
s
,
V
i
r
u
s
T
o
t
a
l
k
N
N
,
D
T
,
[
7
0
]
)
.
S
V
M
(
a
n
d
(
S
e
c
-
S
V
M
[
2
3
]
)
.
h
a
r
d
e
n
e
d
v
e
r
s
i
o
n
L
i
n
e
a
r
S
V
M
(
D
R
E
B
N
I
[
8
]
)
a
n
d
i
t
s
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:16:38 UTC from IEEE Xplore.  Restrictions apply. 
1339
(cid:5)
(cid:5)
(cid:5)
any referenced classes (organ o), and all statements necessary
to construct intent with its parameters (vein v). There is
a special case for Activities which have no corresponding
vein in the bytecode (e.g., a MainActivity or an Activity
triggered by an intent ﬁlter declared in the Manifest); here,
we provide an adapted vein, a minimal Intent creation and
startActivity() call adapted from a previously mined
benign app that will trigger the Activity. Note that organs with
original veins are always prioritized above those without.
Organ Implantation. In order to implant some gadget
ρ into a host, it is necessary to identify an injection point
LH where v should be inserted. Implantation at LH should
fulﬁll two criteria: ﬁrstly, it should maintain the syntactic
validity of the host; secondly, it should be as unnoticeable as
possible so as not to contribute to any violation of plausibility.
To maximize the probability of fulﬁlling the ﬁrst criterion,
we restrict LH to be between two statements of a class
deﬁnition in a non-system package. For the second criterion,
we take a heuristic approach by using Cyclomatic Complexity
(CC)—a software metric that quantiﬁes the code complexity of
components within the host—and choosing LH such that we
maintain existing homogeneity of CC across all components.
Finally, the host entry point LH is inserted into a randomly
chosen function among those of the selected class, to avoid
creating a pattern that might be identiﬁed by an analyst.
during a static analysis. We refer the reader to Appendix D
for a detailed description of how we generate strong opaque
predicates and make them look legitimate.
E. Plausibility
In our model, an example is satisfactorily plausible if it
resembles a real, functioning Android application (i.e., is a
valid member of the problem-space Z). Our methodology
aims to maximize the plausibility of each generated object by
injecting full slices of bytecode from real benign applications.
There is only one case in which we inject artiﬁcial code: the
opaque predicates that guard the entry point of each gadget
(see Appendix D for an example). In general, we can conclude
that plausibility is guaranteed by construction thanks to the use
of automated software transplantation [10]. This contrasts with
other approaches that inject standalone API calls and URLs
or no-op operations [e.g., 60] that are completely orphaned
and unsupported by the rest of the bytecode (e.g., an API call
result that is never used).
We also practically assess that each mutated app still
functions properly after modiﬁcation by installing and run-
ning it on an Android emulator. Although we are unable to
thoroughly explore every path of the app in this automated
manner, it sufﬁces as a smoke test to ensure that we have not
fundamentally damaged the structure of the app.
C. Preserved Semantics
F. Search Strategy
Given an application z and its modiﬁed (adversarial) version
(cid:3) lead to the same dynamic
(cid:3), we aim to ensure that z and z
z
execution, i.e., the malicious behavior of the application is
preserved. We enforce this by construction by wrapping the
newly injected execution paths in conditional statements that
always return False. This guarantees the newly inserted code
is never executed at runtime—so users will not notice anything
odd while using the modiﬁed app. In §III-D, we describe how
we generate such conditionals without leaving artifacts.
To further preserve semantics, we also decide to omit
intent-filter elements as transplantation candidates. For
example, an intent-filter could declare the app as an
eligible option for reading PDF ﬁles; consequently, whenever
attempting to open a PDF ﬁle, the user would be able to choose
the host app, which (if selected) would trigger an Activity
deﬁned in the transplanted benign bytecode—violating our
constraint of preserving dynamic functionality.
D. Robustness to Preprocessing
Program analysis techniques that perform redundant code
elimination would remove unreachable code. Our evasion
attack relies on features associated with the transplanted code,
and to preserve semantics we need conditional statements that
always resolve to False at runtime; so, we must subvert static
analysis techniques that may identify that this code is never ex-
ecuted. We achieve this by relying on opaque predicates [51],
i.e., carefully constructed obfuscated conditions where the
outcome is always known at design time (in our case, False),
but the actual truth value is difﬁcult or impossible to determine
We propose a gradient-driven search strategy based on a
greedy algorithm, which aims to follow the gradient direction
by transplanting a gadget with benign features into the mali-
cious host. There are two main phases: Initialization (Ice-Box
Creation) and Attack (Adversarial Program Generation). This
section offers an overview of the proposed search strategy, and
the detailed steps are reported in Appendix F.
Initialization Phase (Ice-Box Creation). We ﬁrst harvest
gadgets from potential donors and collect them in an ice-
box G, which is used for transplantation at attack time. The
main reason for this, instead of looking for gadgets on-the-ﬂy,
is to have an immediate estimate of the side-effect features
when each gadget is considered for transplantation. Looking
for gadgets on-the-ﬂy is possible, but may lead to less optimal
solutions and uncertain execution times.
For the initialization we aim to gather gadgets that move
the score of an object towards the benign class (i.e., negative
score), hence we consider the classiﬁer’s top nf benign
features (i.e., with negative weight). For each of the top-nf
features, we extract nd candidate gadgets, excluding those that
lead to an overall positive (i.e., malicious) score. We recall that
this may happen even for benign features since the context
extracted through forward and backward slicing may contain
many other features that are indicative of maliciousness. We
empirically verify that with nf = 500 and nd = 5 we are
able to create a successfully evasive app for all the malware
in our experiments. To estimate the side-effect feature vectors
for the gadgets, we inject each into a minimal app, i.e., an
Android app we developed with minimal functionality (see
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:16:38 UTC from IEEE Xplore.  Restrictions apply. 
1340
Appendix F). It is important to observe that the ice-box can
be expanded over time, as long as the target classiﬁer does not
change its weights signiﬁcantly. Algorithm 1 in Appendix F
reports the detailed steps of the initialization phase.
(cid:3)
Attack Phase. We aim to automatically mutate z into z
(cid:3)
so that it is misclassiﬁed as goodware, i.e., h(ϕ(z