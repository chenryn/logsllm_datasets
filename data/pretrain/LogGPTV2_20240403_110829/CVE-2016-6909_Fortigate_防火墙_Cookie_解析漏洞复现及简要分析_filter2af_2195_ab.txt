      }
      snprintf(name, 0x200u, "/%s.tar", a1);
      v3 = fork();
      if ( v3 )
      {
        //..
        if ( v3  /bin/init
    lrwxrwxrwx  1 root     root            9 Aug 10 19:35 alarmd -> /bin/init
    lrwxrwxrwx  1 root     root            9 Aug 10 19:35 alertmail -> /bin/init
    lrwxrwxrwx  1 root     root            9 Aug 10 19:35 authd -> /bin/init
    lrwxrwxrwx  1 root     root            9 Aug 10 19:35 bgpd -> /bin/init
    lrwxrwxrwx  1 root     root            9 Aug 10 19:35 cardctl -> /bin/init
    lrwxrwxrwx  1 root     root            9 Aug 10 19:35 cardmgr -> /bin/init
    lrwxrwxrwx  1 root     root           11 Aug 10 19:35 cat -> /bin/sysctl
    lrwxrwxrwx  1 root     root            9 Aug 10 19:35 cauploadd -> /bin/init
    lrwxrwxrwx  1 root     root            9 Aug 10 19:35 chassis5000d -> /bin/init
    lrwxrwxrwx  1 root     root            9 Aug 10 19:35 chassisd -> /bin/init
    lrwxrwxrwx  1 root     root            9 Aug 10 19:35 chat -> /bin/init
    lrwxrwxrwx  1 root     root            9 Aug 10 19:35 chlbd -> /bin/init
    lrwxrwxrwx  1 root     root           11 Aug 10 19:35 chmod -> /bin/sysctl
    ...
**III. /bin/init 逆向分析**
拖入 IDA 进行分析：
首先会执行 `/bin/initXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX` 替换自身，该文件其实是 `/bin/init`
的软链接，故这里本质上只是更改了 pid 与 argv[0]
随后会关闭三个标准文件描述符并改变当前工作目录为 `/`，打开 `/dev/null` 并创建三个指向其的文件描述符（0、1、2）
> 笔者后续曾经一度认为利用失败就是因为没有注意到输入输出被重定向至 null 而无法在屏幕上打印出任何信息
启动后的界面如下：
###  poc
首先为我们的虚拟机配置一个本地 ip
接下来我们还需要获取到一个 cookie num：
    $ curl -X HEAD -v http://192.168.116.100/login  2>&1 | grep 'APSCOOKIE'
     由于一些特殊原因，笔者本地无法直接启动其 init 程序
>
> 笔者本想将 gdb 等打包进其文件系统中直接在虚拟机内进行调试，奈何文件系统实在太老，重打包后没有一次启动成功的，只好作罢…
我们首先根据这个报错信息进行栈回溯：
    .text:08C38A77                 call    sub_8C389B7
    .text:08C38A7C                 mov     ebx, [ebp+var_4]
    .text:08C38A7F                 leave
    .text:08C38A80                 retn
    .text:08C38A80 sub_8C38A61     endp
找到 `sub_8C389B7()` 函数，我们发现其最终会调用 `sub_8C38440()` 函数，简单分析我们不难知道该调用链仅仅是用于打印报错信息
继续分析其调用链，libc offset 0x1d218 处代码如下，该段代码位于 libc 中函数 `__libc_sigaction()`，用以进行
`sigreturn` 系统调用：
    .text:0001D210 loc_1D210:                              ; DATA XREF: __libc_sigaction+CA↓o
    .text:0001D210                 mov     eax, 0ADh
    .text:0001D215                 int     80h             ; LINUX - sys_rt_sigreturn
    .text:0001D217                 nop
    .text:0001D218 loc_1D218:                              ; DATA XREF: __libc_sigaction+D9↓o
    .text:0001D218                 pop     eax
    .text:0001D219                 mov     eax, 77h ; 'w'
    .text:0001D21E                 int     80h             ; LINUX - sys_sigreturn
继续回溯，`0x8204F8D` 的上一条指令调用了 `sub_820483B()` 函数，通过逆向我们发现该函数会调用 `sub_820429D()`：
    int __cdecl sub_820429D(int *a1, _BYTE *a2)
    {
      const char *v2; // esi
      const char *v3; // eax
      int **v4; // edi
      int *v5; // eax
      int v6; // esi
      void *v7; // eax
      void *v8; // esi
      int v10; // [esp+4h] [ebp-14h]