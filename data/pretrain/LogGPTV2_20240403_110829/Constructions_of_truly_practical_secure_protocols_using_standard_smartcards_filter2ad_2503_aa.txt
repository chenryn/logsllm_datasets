title:Constructions of truly practical secure protocols using standard smartcards
author:Carmit Hazay and
Yehuda Lindell
Constructions of Truly Practical Secure Protocols using
Standard Smartcards∗
Carmit Hazay
Department of Computer Science,
Bar-Ilan University, Israel.
PI:EMAIL
Yehuda Lindell
Department of Computer Science,
Bar-Ilan University, Israel.
PI:EMAIL
ABSTRACT
In this paper we show that using standard smartcards it is
possible to construct truly practical secure protocols for a
variety of tasks. Our protocols achieve full simulation-based
security in the presence of malicious adversaries, and can
be run on very large inputs. We present protocols for secure
set intersection, oblivious database search and more. We
have also implemented our set intersection protocol in order
to show that it is truly practical: on sets of size 30,000 ele-
ments takes 20 seconds for one party and 30 minutes for the
other (where the latter can be parallelized to further reduce
the time). This demonstrates that in settings where physi-
cal smartcards can be sent between parties (as in the case
of private data mining tasks between security and govern-
mental agencies), it is possible to use secure protocols with
proven simulation-based security.
Categories and Subject Descriptors
F.1.2 [Modes of computation]: Interactive and reactive
computation—cryptographic protocols
General Terms
Algorithms, Security
Keywords
Secure computation, smartcards, provable security
1.
INTRODUCTION
In the setting of secure multiparty computation, a set of
parties with private inputs wish to jointly compute some
functionality of their inputs. Loosely speaking, the security
requirements of such a computation are that (i) nothing is
learned from the protocol other than the output (privacy),
(ii) the output is distributed according to the prescribed
∗
This research was supported by the israel science foundation
(grant No. 781/07). The ﬁrst author is also supported by an Eshkol
scholarship from the Israel Ministry of Science.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’08 October 27–31, 2008, Alexandria, Virginia, USA.
Copyright 2008 ACM 978-1-59593-810-7/08/10 ...$5.00.
functionality (correctness), and (iii) parties cannot make
their inputs depend on other parties’ inputs. The standard
deﬁnition of security is based on comparing a real proto-
col execution to an ideal execution where a trusted party
carries out the computation for the parties. This notion
is typically called simulation-based security. Secure multi-
party computation forms the basis for a multitude of tasks,
including those as simple as coin-tossing and agreement,
and as complex as electronic voting and auctions, electronic
cash schemes, anonymous transactions, remote game playing
(a.k.a. “mental poker”), and privacy-preserving data mining.
The security requirements in the setting of multiparty
computation must hold even when some of the participating
parties are adversarial.
In this paper, we consider mali-
cious adversaries that can arbitrarily deviate from the pro-
tocol speciﬁcation.
It has been shown that, with the aid
of suitable cryptographic tools, any two-party or multiparty
function can be securely computed [23, 14, 13, 4, 7] in the
presence of malicious adversaries. However, protocols that
achieve this level of security are rarely eﬃcient enough to be
used in practice, even for relatively small inputs.
Recently, there has been much interest in the data mining
and other communities for secure protocols for a wide vari-
ety of tasks. This interest exists not only in academic circles,
but also in industry, in part due to the growing conﬂict be-
tween the privacy concerns of citizens and the homeland se-
curity needs of governments. Unfortunately, however, truly
practical protocols that also achieve proven simulation-based
security are currently far out of reach. This is especially the
case when security in the presence of malicious adversaries
is considered (see related work for other models).
Smartcard-aided secure computation.
In this paper,
we construct protocols that use smartcards in addition to
standard network communication. Speciﬁcally, in addition
to sending messages over a network, the participating par-
ties may initialize smartcards in some way and send them
to each other. Of course, such a modus operandi is only rea-
sonable if this is not over-used. In all of our protocols, one
party initializes a smartcard and sends it to the other, and
that is all. Importantly, it is also suﬃcient to send a smart-
card once, which can then be used for many executions of
the protocol (and even for diﬀerent protocols). This model is
clearly not suitable for protocols that must be run by ad hoc
participants over the Internet (e.g., for secure eBay auctions
or secure Internet purchases). However, we argue that it is
suitable whenever parties with non-transient relationships
need to run secure protocols. Thus, this model is suitable
for the purpose of privacy-preserving data mining between
commercial, governmental and security agencies. We con-
struct practical two-party protocols for the following tasks:
• Secure set intersection: This problem is of great interest
in practice and has many applications. Some examples
are: ﬁnding out if someone is on two security agencies’
list of suspects, ﬁnding out if someone illegally receives
social welfare from two diﬀerent agencies, ﬁnding out
what patients receive medical care at two diﬀerent med-
ical centers, and so on. This problem has received a
lot of attention due to its importance; see [21, 11, 17]
for some examples. We present a protocol that is far
more eﬃcient than any known current solutions, and
provides the highest level of security (full-simulation in
the presence of malicious adversaries, and even univer-
sal composability). Our protocol is surprisingly simple,
and essentially requires one party to carry out one 3DES
or AES computation on each set element (using a reg-
ular PC), while the other party carries out the same
computations using a smartcard. Thus, for sets com-
prised of 30,000 elements, the ﬁrst party’s computation
takes approximately 20 seconds and the second party’s
computation takes approximately 30 minutes (but can
be parallelized, meaning that using 10 smartcards, the
computation would take approximately 3 minutes). In
our protocol, only the second party receives output.
• Oblivious database search: In this problem, a client is
able to search a database held by a server so that: (a)
the client can only carry out a single search (or a prede-
termined number of searches authorized by the server),
and learns nothing beyond the result of the authorized
searches; and (b) the server learns nothing about the
searches carried out by the client. We remark that searches
are as in the standard database setting: the database has
a “key attribute” and each record has a unique key value;
searches are then carried out by inputting a key value –
if the key exists in the database then the client receives
back the entire record; otherwise it receives back a “non-
existent” reply. This problem has been studied in [8,
10] and has important applications to privacy. For ex-
ample, consider the case of homeland security where it is
sometimes necessary for one organization to search the
database of another. In order to minimize information
ﬂow (or stated diﬀerently, in order to preserve the “need
to know” principle), we would like the agency carrying
out the search to have access only to the single piece of
information it is searching for. Furthermore, we would
like the value being searched for to remain secret. An-
other, possibly more convincing, application comes from
the commercial world. The LexisNexis database is a paid
service provided to legal professionals that enables them
– among other things – to search legal research and pub-
lic records, for the purpose of case preparation. Now, the
content of searches made for case preparation is highly
conﬁdential ; this information reveals much about the le-
gal strategy of the lawyers preparing the case, and would
allow the other side to prepare counter-arguments well
ahead of time. It is even possible that revealing the con-
tent of some of these searches may breach attorney-client
privilege. We conclude that the searches made to Lex-
isNexis must remain conﬁdential, and even LexisNexis
should not learn them (either because they may be cor-
rupted, or more likely, a breach to their system could be
used to steal this conﬁdential information). Oblivious
database search can be used to solve this exact prob-
lem. We present a protocol for oblivious database search
that reaches a level of eﬃciency that is almost equiva-
lent to a non-private database search. Once again, we
achieve provable security (under full simulation-based
deﬁnitions) in the presence of malicious adversaries.
• Oblivious document search: A similar, but seemingly
more diﬃcult, problem to that of oblivious database
search is that of oblivious document search. Here, the
database is made up of a series of unstructured docu-
ments and a keyword query should return all documents
that contain that query. This is somewhat more diﬃcult
than the previous problem because of the dependence
between documents (the client should not know if dif-
ferent documents contain the same keyword if it has not
searched them both). Nevertheless, using smartcards,
we present a highly eﬃcient protocol for this problem,
that is provably secure in the presence of malicious ad-
versaries. We remark that in many cases, including the
LexisNexis example above, what is really needed is the
unstructured document search here.
We stress that our protocols are all proven secure under the
standard simulation-based deﬁnition of security (cf.
[5, 13]
following [15, 3, 20]), and for the case of malicious adver-
saries that may follow any arbitrary polynomial-time strat-
egy. Thus, the highest level of security is achieved. As we
have mentioned, however, we use a smartcard to aid in the
computation, unlike the standard model of computation. As
will become clear, this gives extraordinary power and makes
it possible to construct protocols that are far more eﬃcient
than anything previously known.
Composability. One criticism of attempts to construct
secure protocols that are to be used in practice is that the
stand-alone model (where security is proven for only a single
execution of a protocol in isolation – or equivalently when
the adversary is assumed to attack only a single execution)
is not the real-world model of computation. Thus, why does
it make sense to insist on a full proof of security when the
proof is for an unrealistic model? Fortunately, all of our pro-
tocols are secure under concurrent general composition (or
equivalently, universal composability), and thus their proven
security is guaranteed in the real-world setting that they
may be used.
Standard smartcards – what and why. We stress that
our protocols are designed so that any standard smartcard
can be used. Before proceeding we explain why it is impor-
tant for us to use standard – rather than special-purpose –
smartcards, and what functionality is provided by such stan-
dard smartcards. The reason for our insistence on standard
smartcards is twofold:
1. Ease of deployment: It is much easier to actually de-
ploy a protocol that uses standard smartcard technol-
ogy. This is due to the fact that many organizations
have already deployed smartcards, typically for au-
thenticating users. However, even if this is not the
case, it is possible to purchase any smartcard from es-
sentially any smartcard vendor.1
1
Of course, the notion of a “standard” smartcard is somewhat prob-
lematic because diﬀerent vendors construct smartcards with diﬀerent
properties. We therefore rely on properties that we know are in the
widely-used smartcards sold by Siemens.
2. Trust: If a special-purpose smartcard needs to be used
for a secure protocol, then we need to trust the ven-
dor who built the smartcard. This trust extends to
believing that they did not incorrectly implement the
smartcard functionality on purpose or unintentionally.
In contrast, if standard smartcards can be used then
it is possible to use smartcards constructed by a third-
party vendor (and possibly constructed before our pro-
tocols were even designed).
In addition to reducing
the chance of malicious implementation, the chance of
an unintentional error is much smaller, because these
cards have been tried and tested over many years.
We remark that Javacards can also be considered for the
application that we are considering. Javacards are smart-
cards with the property that special-purpose Java applets
can be loaded onto them in order to provide special-purpose
functionality. We remark that such solutions are also rea-
sonable. However, it does make deployment slightly more
diﬃcult as already-deployed smartcards (that are used for
smartcard logon and VPN authentication for example) can-
not be used. Furthermore, it is necessary to completely trust
whoever wrote the applet; this can be remedied by having
an open-source applet which can be checked before loaded.
Therefore, protocols that do need smartcards with some
special-purpose functionality can be used, but are slightly
less desirable.
A trusted party? At ﬁrst sight, it may seem that we have
essentially introduced a trusted party into the model, and
so of course everything becomes easy. We argue that this
is not the case. First, a smartcard is a very speciﬁc type of
trusted party, with very speciﬁc functionality (especially if
we focus on standard smartcards). Second, due to it being
weak hardware, a smartcard cannot carry out a computation
on large inputs. Thus, even a special-purpose smartcard
cannot directly compute set intersection on inputs of size
30,000. Finally, smartcards are used in practice and are
becoming more and more ubiquitous. Thus, our model truly
is a realistic one, and our protocols can easily be deployed
in practice.
Trusting smartcards. In our protocols, we assume that
the smartcard is uncorrupted. We base this assumption on
the fact that modern smartcards are widely deployed today –
mostly for authentication – and are rarely broken (we stress
that we refer to smartcards that have passed certiﬁcation
like FIPS or Common Criteria, and not microprocessors with
basic protection). We discuss the security of smartcards in
more detail at the end of Section 2.
Smartcard authenticity. As we have mentioned, our pro-
tocols require one party to initialize a smartcard and send
it to the other. Furthermore, the recipient of the smart-
card needs to trust that the device that it receives is really
a smartcard of the speciﬁed type. Since our protocols rely
on standard smartcard technology only, this problem essen-
tially reduces to identifying that a given device was manu-
factured by a speciﬁed smartcard vendor. In principle, this
problem is easily solved by having smartcard manufacturers
initialize all devices with a public/private key pair, where
the private key is known only to the manufacturer. Then,
given a device and the manufacturer’s public key it is pos-
sible to verify that the device is authentic using a simple
challenge/response mechanism. This solution is not perfect
because given the compromise of a single smartcard, it is
possible to manufacture multiple forged devices. This is
highly undesirable because it means that the incentive to
carry out such an attack can be very high. This can be im-
proved by using diﬀerent public keys for diﬀerent batches
(or even a diﬀerent key for every device, although this is
probably too cumbersome in practice). To the best of our
knowledge, such a mechanism is typically not implemented
today (rather, symmetric keys are used instead). Neverthe-
less, it could be implemented without much diﬃculty and so
is not a serious barrier.
Related work. Secure computation has been studied at
great length for over two decades. However, the study of
highly-eﬃcient protocols for problems of interest has re-
cently been intensively studied under the premise of “privacy-
preserving data mining”, starting with [19]. Most of the se-
cure protocols for this setting have considered the setting