nisms relying on anterior veriﬁcation. The solution utilizes a
TPM for veriﬁcation, nonetheless, concrete veriﬁcation mech-
anism were not published. Moreover, the role and exact tasks
of the TPM were not explained.
Furthermore, hardware-backed solutions were also used
for the similar introspection mechanisms. Speciﬁcally,
SPROBES [11] utilized ARM TrustZones to enforce invari-
ants detecting malicious modiﬁcations to Linux kernel code
during runtime. The invariants are used to evaluate diﬀerent
meta-data to deduce whether the system was maliciously
altered or not. Consequently, the invariants are chosen and
designed such that unintended modiﬁcation may not occur
undetected.
7. CONCLUSION AND FUTURE WORK
In this work we presented DRIVE – a novel approach com-
plementing MF and System Integrity Veriﬁcation concepts
in order to produce evidence of a system state and attest the
reliability of a measured system’s runtime conﬁguration. The
described approach enables continuous monitoring of long
running OS components, and thus reduces the attack surface
for sophisticated adversaries by detecting attacks aiming the
volatile memory. Our presented architecture is ﬂexible and
can be adapted in varied ways. We demonstrated an exem-
plary instantiation of our proposed architecture and provided
a security evaluation and metrics that demonstrate DRIVE’s
applicability.
Currently, we are in the process of enhancing the concept
and technical details of DRIVE. Our current research tar-
gets the following major challenges: (1) Implementation and
integration of DRIVE’s MA into an isolated environment for
secure measurement acquisition. At present, an ARM Trust-
Zone based implementation and a LKM for extended hyper-
visor introspection is developed and evaluated; (2) Support
and integration of kernels hot-patching and runtime code
patching mechanisms; (3) Measurement and veriﬁcation of
738kernel critical data-structures targeted in DKOM based at-
tacks; (4) Mechanisms to trigger measurement on security
critical events; (5) Performance improvements reducing the
computational eﬀort and time, especially during the measure-
ment acquisition process.
8. REFERENCES
[1] S. Andersen and V. Abella. Data Execution Prevention.
Changes to Functionality in Microsoft Windows XP
Service Pack 2, Part 3: Memory Protection Technologies.
2004.
[2] A. M. Azab et al. “HIMA: A hypervisor-based integrity
measurement agent”. In: Computer Security Applications
Conference, 2009. ACSAC’09. Annual. IEEE. 2009,
pp. 461–470.
[3] A. Baliga, V. Ganapathy, and L. Iftode. “Detecting
kernel-level rootkits using data structure invariants”. In:
Dependable and Secure Computing, IEEE Transactions on
8.5 (2011), pp. 670–684.
[4] T. Bletsch et al. “Jump-oriented Programming: A New
Class of Code-reuse Attack”. In: Proceedings of the 6th
ACM Symposium on Information, Computer and
Communications Security. ASIACCS ’11. Hong Kong,
China: ACM, 2011, pp. 30–40. i s b n: 978-1-4503-0564-8.
d o i: 10.1145/1966913.1966919. u r l:
http://doi.acm.org/10.1145/1966913.1966919.
[5] C. Chang et al. “Research on Dynamic Integrity
Measurement Model Based on Memory Paging
Mechanism”. In: Discrete Dynamics in Nature and Society
2014 (2014).
[6] S. Checkoway et al. “Return-oriented programming
without returns”. In: Proceedings of the 17th ACM
conference on Computer and communications security.
ACM. 2010, pp. 559–572.
[7] T. Committee et al. “Tool Interface Standard (TIS)
Executable and Linking Format (ELF) Speciﬁcation
Version 1.2”. In: TIS Committee (1995).
J. Criswell et al. “Secure virtual architecture: A safe
execution environment for commodity operating systems”.
In: ACM SIGOPS Operating Systems Review. Vol. 41. 6.
ACM. 2007, pp. 351–366.
[8]
[9] CVEdetails.com. Linux Kernel Vulnerabilities.
https://www.cvedetails.com/product/47/Linux-Linux-
Kernel.html?vendor id=33.
[10] T. Garﬁnkel et al. “Terra: A virtual machine-based
platform for trusted computing”. In: ACM SIGOPS
Operating Systems Review. Vol. 37. 5. ACM. 2003,
pp. 193–206.
[11] X. Ge, H. Vijayakumar, and T. Jaeger. “Sprobes:
Enforcing kernel code integrity on the trustzone
architecture”. In: arXiv preprint arXiv:1410.7747 (2014).
[12] M. Gorman. Understanding the Linux virtual memory
manager. Prentice Hall Upper Saddle River, 2004.
[13] N. L. P. Jr et al. “Copilot-a Coprocessor-based Kernel
Runtime Integrity Monitor.” In: USENIX Security
Symposium. San Diego, USA. 2004, pp. 179–194.
[14] V. Katoch. Whitepaper on Bypassing ASLR/DEP.
http://www.exploit-db.com/wp-
content/themes/exploit/docs/17914.pdf.
[15] C. H. Kim et al. “CAFE: A Virtualization-Based Approach
to Protecting Sensitive Cloud Application Logic
Conﬁdentiality”. In: Proceedings of the 10th ACM
Symposium on Information, Computer and
Communications Security. ASIA CCS ’15. Singapore,
Republic of Singapore: ACM, 2015, pp. 651–656. i s b n:
978-1-4503-3245-3. d o i: 10.1145/2714576.2714594. u r l:
http://doi.acm.org/10.1145/2714576.2714594.
[16] T. Kittel et al. “Code validation for modern os kernels”. In:
[17]
[18]
Workshop on Malware Memory Forensics (MMF). 2014.
ld(1) Linux User’s Manual.
J. R. Levine. Linkers and Loaders. 1st. San Francisco, CA,
USA: Morgan Kaufmann Publishers Inc., 1999. i s b n:
1558604960.
[19] M. H. Ligh et al. The art of memory forensics: detecting
malware and threats in windows, linux, and Mac memory.
John Wiley & Sons, 2014.
[20] P. A. Loscocco et al. “Linux Kernel Integrity Measurement
Using Contextual Inspection”. In: Proceedings of the 2007
ACM Workshop on Scalable Trusted Computing. STC ’07.
Alexandria, Virginia, USA: ACM, 2007, pp. 21–29. i s b n:
978-1-59593-888-6. d o i: 10.1145/1314354.1314362. u r l:
http://doi.acm.org/10.1145/1314354.1314362.
[21] C. S. Ltd. Whitepaper on Quadrooter. u r l:
https://www.checkpoint.com/resources/quadrooter-
vulnerability-enterprise/.
[22] C. Mitchell. Trusted computing. Springer, 2005.
[23]
J. A. Pendergrass and K. N. McGill. “LKIM: The Linux
Kernel Integrity Measurer”. In: Johns Hopkins APL
technical digest 32.2 (2013), p. 509.
[24] N. L. Petroni et al. “FATKit: A framework for the
extraction and analysis of digital forensic data from
volatile system memory”. In: Digital Investigation 3.4
(2006), pp. 197–210.
[25] A. Prakash et al. “On the Trustworthiness of Memory
Analysis—An Empirical Study from the Perspective of
Binary Execution”. In: Dependable and Secure Computing,
IEEE Transactions on 12.5 (2015), pp. 557–570.
[26] A. Rein et al. “Trust Establishment in Cooperating
Cyber-Physical Systems”. In: Cybersecurity of Industrial
Control Systems, Security of Cyber Physical Systems. 2015.
[27] R. Roemer et al. “Return-oriented programming: Systems,
languages, and applications”. In: ACM Transactions on
Information and System Security (TISSEC) 15.1 (2012),
p. 2.
[28] G. Roglia et al. “Surgically Returning to Randomized
lib(c)”. In: Computer Security Applications Conference,
2009. ACSAC ’09. Annual. 2009, pp. 60–69. d o i:
10.1109/ACSAC.2009.16.
[29] R. Sailer et al. “Design and Implementation of a
TCG-based Integrity Measurement Architecture.” In:
USENIX Security Symposium. Vol. 13. 2004, pp. 16–16.
[30] A. Seshadri et al. “SecVisor: A Tiny Hypervisor to Provide
Lifetime Kernel Code Integrity for Commodity OSes”. In:
Proceedings of Twenty-ﬁrst ACM SIGOPS Symposium on
Operating Systems Principles. SOSP ’07. Stevenson,
Washington, USA: ACM, 2007, pp. 335–350. i s b n:
978-1-59593-591-5. d o i: 10.1145/1294261.1294294. u r l:
http://doi.acm.org/10.1145/1294261.1294294.
[31] R. Shapiro, S. Bratus, and S. W. Smith. “Weird Machines
in ELF: A Spotlight on the Underappreciated Metadata”.
In: Presented as part of the 7th USENIX Workshop on
Oﬀensive Technologies. Washington, D.C.: USENIX, 2013.
u r l:
https://www.usenix.org/conference/woot13/workshop-
program/presentation/Shapiro.
[32] U. Steinberg and B. Kauer. “NOVA: a
microhypervisor-based secure virtualization architecture”.
In: Proceedings of the 5th European conference on
Computer systems. ACM. 2010, pp. 209–222.
J. Sylve. “Lime-linux memory extractor”. In: Proceedings
of the 7th ShmooCon conference. 2012.
[33]
[34] P. Team. PaX address space layout randomization (ASLR).
http://pax.grsecurity.net/docs/aslr.txt. 2003.
[35] Volatility Foundation. Volatility Framework. u r l:
http://www.volatilityfoundation.org.
[36] P. Wagle, C. Cowan, et al. “Stackguard: Simple stack
smash protection for gcc”. In: Proceedings of the GCC
Developers Summit. Citeseer. 2003, pp. 243–255.
[37] Z. Wang and X. Jiang. “Hypersafe: A lightweight approach
to provide lifetime hypervisor control-ﬂow integrity”. In:
Security and Privacy (SP), 2010 IEEE Symposium on.
IEEE. 2010, pp. 380–395.
[38] W. Xu et al. “From Collision To Exploitation: Unleashing
Use-After-Free Vulnerabilities in Linux Kernel”. In:
Proceedings of the 22Nd ACM SIGSAC Conference on
Computer and Communications Security. CCS ’15. Denver,
Colorado, USA: ACM, 2015, pp. 414–425. i s b n:
978-1-4503-3832-5. d o i: 10.1145/2810103.2813637. u r l:
http://doi.acm.org/10.1145/2810103.2813637.
739APPENDIX
A. MICRO-BENCHMARK
MENTS
EXPERI-
Table AT1 shows the detailed results we discussed in Sec-
tion 5.4. The metrics consists of multiple measurements that
were taken from the implemented DRIVE LKM conduction
a measurement process.
B. TECHNICAL BACKGROUND
This section provides an overview of related technical prin-
ciples used in DRIVE. DRIVE measures system memory
content and meta-data. For this reason, it is deeply related
to core low level functionalities provided by the OS kernel’s
Memory Management (MM). Hence, basic MM concepts are
brieﬂy introduced. In particular, we describe how the loading
process utilizes the MM and how this aﬀects the memory
contents and meta-data. Furthermore, access permissions of
Virtual Address Space (VAS) segments will be shown, basic
memory sharing concepts described, and static and dynamic
behavior of individual VAS segment sections discussed.
B.1 Loading Principle in Modern Operating
Systems
Every component, meant to be executed on a computer
system, follows a certain well-known approach. Leaving aside
the concrete software components, every CPU based compu-
tation relies on data existent in the systems main memory.
Even so, every diﬀerent architecture comes with diﬀerent
concrete implementations for the process, all modern archi-
tectures follow the same principle and are based on similar
organization of the involved data.
B.1.1 Organization of Object Code
In Unix based systems, the Executable and Linkable For-
mat (ELF) standard deﬁnes the organizational structures
of executables, shared libraries, and core dumps, referenced
as object code during this work. Inside the ELF, diﬀerent
components of the object code are represented by diﬀerent
sections. Most notable sections are (1) the .text, .init,
and .plt sections, encapsulating executable instructions, (2)
the .data, .rodata and .bss sections, holding initialized and
uninitialized data, and (3) .got, a table organizing data struc-
tures to related function symbols. Additionally, there exist
more sections in the ELF, for example, representing program
and section headers, procedures, and symbols resolution ta-
bles. A comprehensive overview is given in [7]. Figure AF1
shows a user-space process ELF to VAS mapping example.
Please note, once the section is loaded and resides inside
memory in VAS, we will use the term segment to identify
ELF content loaded into memory. As shown, multiple related
sections from the ELF are organized in a single segment. This
relation is speciﬁed in the section-to-segment mapping in the
ELF header and can be diﬀerent for every ELF.
B.1.2 Object Code Loading
Before object code instructions can be executed by the
CPU all necessary object code must reside in memory. De-
pending on the object code, diﬀerent loaders are responsible
for the loading process. Following the boot process, we brieﬂy
describe the loading process of ELF beginning with the sys-
tems’ Bootloader. The result of the loading mechanism is
depicted in Figure AF1.
ELF
File
ELF header
.plt
.ini
.text
.rodata
...
.got
.data
.bss
...
ELF library
ELF header
...
...
Section to Segment
mapping
ELF
VAS
0x00000000
.text (r-x)
.text (r-x)
.data (rw-)
.data (rw-)
...
heap
...
.text (r-x)
lib .text (rw-)
.data (rw-)
lib .data (rw-)
...
User-space (3GB)
Kernel-space (1GB)
...
stack
Kernel .text
Kernel .data
...
LKM .text
LKM .data
...
0x7FFFFFFF
0x80000000
0xFFFFFFFF
Figure AF1: ELF-ﬁle to VAS mapping with aid of
Section to Segment Mappings
Bootloader and Kernel Setup. The Bootloader instructs
the CPU to load the OS Kernel object code into memory at
a ﬁxed location. From this point onwards, the Kernel takes
complete control over the MM. If present, in a very ﬁrst step
the Kernel initializes the Memory Management Unit (MMU)
and sets up internal structures to organize the mappings
between the physical and virtual memory (VM) that is the
Page Table [12]. Most importantly, the VM is separated into
Kernelspace and Userspace in this process. Afterwards, the
Kernel continues with its execution until a Loadable Kernel
Module (LKM) needs to be loaded.
Kernel Module Loader. The Kernel Module Loader
(KML) loads the requested LKM ELF object code into
memory and transforms the LKM into a ready-to-run state.
During this process, dependencies between diﬀerent LKMs
are resolved. More precisely, the KML (1) inspects every
unresolved symbol, either referencing procedures or data
from the LKM itself, the Kernel or other LKMs; (2) resolves
the symbol by determining the targeted Virtual Memory
Address (VMA) and (3) patches the determined target VMA
directly into the in-memory object code instructions (reloca-
tion), present in LKMs’ .text segment. After all executed
transformations, the LKM is in a ready-to-run state and can
be used as intended. It has to be noted, that the relocation
processes are architecture dependant. They rely on the archi-
tecture speciﬁc relocation types, deﬁned in the architecture’s
speciﬁcations found at http://refspecs.linuxbase.org/elf/.
Still, only certain relocation types are relevant for the KML.
For instance, for X86 6419: R_X86_64_64, R_X86_64_32,
R_X86_64_32S, R_X86_64_PC32 and PPC3220: R_PPC_ADDR32,
R_PPC_ADDR16_LO,
R_PPC_ADDR16_HA,
R_PPC_REL24. For ARM32, ARM64 and PPC64 there are
too many relevant relocation types to list them.