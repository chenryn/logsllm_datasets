    }
从逆向得到的代码可以看出，BHB首先向左移2位，然后与src的低6位和dst的低20位进行异或运算  
BHB总长为58位，每次左移2位，所以能记录总共29次的分支信息。  
**BHB如何索引IBTB表项：**  
从图2可以看到，首先PC会与BHB作XOR运算，运算结果进入哈希函数计算哈希值，根据哈希值来检索IBTB表项。因为在不同的地址处可能产生相同的BHB，这种情况称之为“混叠”（aliasing）。为了消除混叠，采用Gshare两级预测算法，将BHB与PC异或运算得到全局唯一的模式。  
计算索引值的哈希函数则一直没有被Intel公开并且也未被成功逆向。它的意义是将分支模式精确匹配到IBTB的表项，产生预测地址。  
**Indirect Branch Predictor Buffer的作用是什么：**  
IBPB实际上是一个两位的饱和计数器组成的表，他的作用是记录预测结果被采纳的情况。如果预测正确被成功提交，那么计数器会+1，否则会被-1。如果从IBHB出来的结果对应的计数器值为11或者10，那么这个预测结果会被采纳并传递给流水线进行预测执行，否则不会被采纳。  
 IBP复杂的执行流程是为了提高预测精度，因为在程序中有许多分支之间存在关联并且有模式可循，如果按照GBP那样只使用一个BTB来做预测那么显然效果会很差，因为它的预测过程是孤立的。
  * **函数返回地址预测器（Return Predictor ）**  
RP是用来为ret这类返回指令做地址预测的，我这里没有用到因此不做研究。
以上介绍了Haswell平台分支目标预测器的三种预测机制，CPU实际上更加倾向于采纳基于分支历史的预测器的结果[4][p6]，只有当间接分支预测器无法解析的时候才会采纳通用预测器的结果[3][p21]。双峰选择器（Bi-modal selector）判断采纳哪一种机制产生的预测结果并产生最终的预测地址。  
根据分支最终实际的执行情况更新BHB、BTB和BPB。  
每个CPU核心都有独立的分支目标预测器，CPU核心之间是不存在相互影响的。但即使是开启了超线程，运行在同一个核心上的多个进程之间也会通过分支目标预测器产生相互的影响[2][p8]。预测器工作在虚拟地址层面，他的输入和输出都是虚拟地址，与指令的实际物理地址无关[2][p9]，因此我要在受害者进程中找到一条间接跳转指令，它的虚拟地址为src，在训练进程相同虚拟地址处布置一条jmp指令来模拟受害者在src处的跳转，如下图所示:  
训练进程在dst2处跳回src，如此形成一个无限循环。这么做有两点考虑：1.毒化通用分支预测器的BTB，使之在src处指向dst2。2.往BHB中填充大量的规则数据，破坏受害者进程在src之前形成的分支历史，使间接分支预测器失效并强制使用通用分支预测器[3][p29]。  
经过训练可以使受害者在src处预测执行gadget。
# **五、基于时间测量的缓存侧信道攻击**
## **5.1 内存页面共享**
为了减少内存的开销，现代操作系统普遍使用共享内存页面技术在不同的进程之间共享相同的页面，例如动态链接库技术。操作系统会在内存中搜索并合并具有相同内容的页面，而这么做的依据是页面对应的数据块在磁盘中的位置[5][p2]。  
共享对象只占用一份物理内存页面，它被两个进程分别映射到各自的虚拟地址空间。  
操作系统通过写时复制（copy-on-write）技术来保护共享页面。对共享页面的读操作是被允许的，当进程试图修改共享页面时会触发缺页异常（Page-fault），操作系统内存管理模块会将共享页面复制一份后对复制的页面进行修改，并将后者的指针返回给试图修改它的进程。
## **5.2 FLUSH + RELOAD攻击手段**
运行在同一个CPU核心上的不同进程之间可以通过缓存相互产生影响，进而造成进程信息的泄露，而内存页面的共享则为跨进程信息泄露提供了隐蔽通道。FLUSH +
RELOAD是一种缓存侧信道攻击手段，它利用了上述的CPU缺陷可以跨进程碰撞出敏感信息。如上图所示，在两个进程中对addr1～addr2和addr3～addr4这两个内存段进行访问最终是对共享物理页面的访问。  
第三节中提到缓存用来加速访存的原理，缓存的加载是以缓存行（64字节）为单位进行的，每一小格代表一个缓存行。FLUSH +
RELOAD的基本思想是首先对共享物理页面进行刷新确保不在缓存中，让进程2访问共享页面，然后进程1再对共享页面逐个缓存行进行扫描，访问时间最短的表示刚刚被进程2访问过。如果进程2中的某个字符可以被映射为共享页面中的位置，访问这个位置的内容。进程1发现这个位置被访问过，并将这个位置还原为字符，由此可以泄露进程2的信息。
    ProbeTable:
                 db     0x10000 dup (0)          #定义一个可被探测的数组，大小为256 × 256  
    secret: 
                 db     'a'                                 # 0x61
    xor eax, eax                                       # eax = 0
    mov ah, [secret]                                 # ax = 0x6100
    mov ebx, ProbeTable[eax]                 #字符转化为位置并访问
## **5.3 特定位置缓存的刷新与访存时间测量**
在多核CPU中，每个核心都有独立的L1、L2缓存，共享L3缓存，这些缓存可以通过缓存一致协议确保各级缓存的同步。Li是Li+1的一个子集，也就是L2包含了L1中的所有内容，而L3则包含了所有的缓存内容。  
x86架构提供了clflush指令，该指令可以在用户态调用，将特定虚拟地址处的缓存行从L1、L2、L3中全部刷新掉。  
rdtsc指令的作用是将CPU时钟计数器的值读入到edx:eax中，常用作测量一条指令的执行时间。下面这段代码用于粗略测量访存延迟。地址adrs当做参数被传递进来并保存在ecx寄存器中（13行），第7行从adrs地址处读取4字节到eax中。第4行rdtsc将访存前的CPU时间戳记录下来，低32位放在eax寄存器中，高32位放在edx寄存器中。实际上由于这个时间间隔很短，这里只需要用到eax寄存器，因此在第6行将eax内容暂存到esi中。第9行访存完毕再次记录CPU时间戳，并且将低32位与前面保存在esi中的值相减得到运行的时钟周期数。最后clflush指令将adrs缓存行从各级缓存中刷新以还原到测试之前的状态。mfence和lfence指令避免了乱序执行，确保了指令原有的顺序。
    asm __volatile__ (
                         " mfence\n"
                         " lfence\n"
                         " rdtsc\n"
                         " lfence\n"
                         " movl %%eax, %%esi \n"
                         " movl (%1), %%eax\n"
                         " lfence\n"
                         " rdtsc\n"
                         " subl %%esi, %%eax \n"
                         " clflush 0(%1)\n"
                         : "=a" (time)
                         : "c" (adrs)
                         : "%esi", "%edx");
                         return (time < THRESHOLD);
# **六、代码实现**
## **6.1 调试环境**
硬件以及操作系统信息供参考：
    Architecture:          x86_64
    CPU op-mode(s):        32-bit, 64-bit
    Byte Order:            Little Endian
    CPU(s):                8
    On-line CPU(s) list:   0-7
    Thread(s) per core:    2
    Core(s) per socket:    4
    Socket(s):             1
    NUMA node(s):          1
    Vendor ID:             GenuineIntel
    CPU family:            6
    Model:                 60
    Model name:            Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz
    Stepping:              3
    CPU MHz:               800.000
    BogoMIPS:              7183.94
    Virtualization:        VT-x
    L1d cache:             32K
    L1i cache:             32K
    L2 cache:              256K
    L3 cache:              8192K
    NUMA node0 CPU(s):     0-7
    CentOS release 6.9 (Final)
    Linux qiutianshu 2.6.32-696.el6.x86_64 #1 SMP Tue Mar 21 19:29:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
编译时关掉了位置无关，在makefile文件中要 **加入 -fno-pie选项** 。  
代码一共由3部分组成：train.c、attack.c、victim.c。攻击对象victim中保存着一个secret字符串，需要我们通过attack跨进程提取。victim通过套接字与攻击者attack进行简单的通信，victim接收attack发过来的字符串，提取其中的整数并将整数格式化为字符串返回给attack。针对攻击对象的特点对照目标逐一实现。
    /*
    *   victim.c