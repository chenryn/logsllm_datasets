 与y
 对应，因为y
 由➐处的arg_4
 初始化。
局部变量z
 与var_60
 对应，因为它由➑处的值10 初始化。
64 字节的字符数组buffer
 从var_58
 处开始，因为buffer[0]
 由➒处的A （ASCII 0x41）初始化。
调用bar
 的两个变量被转移到➌处的栈中，而非压入栈。这是当前版本（3.4及更高版本）的gcc的典型做法。IDA 认可这一约定并选择不为栈帧顶部的两项创建局部变量引用。
除摘要栈视图外，IDA 还提供一个详细栈帧视图，这种视图会显示一个栈帧所分配到的每一个字节。双击任何与某一给定的栈帧有关的变量名称，即可进入详细视图。在前一个列表中，双击var_C将打开如图6-6所示的栈帧视图（按ESC 键关闭该窗口）。
图6-6 IDA 栈帧视图
由于详细视图显示栈帧中的每一个字节，它占用的空间会比摘要视图（仅列出被引用的变量）多许多。图6-6中显示的栈帧部分一共跨越32 字节，但它仅占整个栈帧的一小部分。注意，函数仅为直接引用的字节分配了名称。例如，与arg_0
 对应的参数a
 ，在demo_stackframe
 中从未被引用。由于没有内存引用可供分析，IDA 选择不处理栈中的对应字节，它们的偏移量由+00000008
 至+0000000B
 。另一方面，在反汇编代码清单中，arg_4
 在➐处被直接引用，且其内容被加载到32 位EAX 寄存器中。基于有32 位数据被转移这一事实，IDA 得出推断，arg_4
 是一个4字节变量，并将其标记如此（db
 定义一个存储字节，dw
 定义两个存储字节，也叫做字；dd
 定义4个存储字节，也叫做双字
 ）。
图6-6中显示的两个特殊值分别为s
 和r
 （前面均带有空格）。这些伪变量是IDA 表示被保存的返回地址（r
 ）和被保存的寄存器值（s
 ，在本例中，s
 仅代表EBP ）的特殊方法。由于需要显示栈帧中的每一个字节，为体现完整性，这些值也包含在栈帧视图中。
栈帧视图有利于我们深入分析编译器的内部工作机制。在图6-6中，很明显，编译器在保存的帧指针s
 与局部变量x（var_C）
 之间额外插入了8字节。在栈帧中，这些字节的偏移量为-00000001
 至-00000008
 。另外，对与摘要视图中列出的每一个变量有关的偏移量进行几次算术运算，即可发现：编译器给位于var_58
 的字符缓冲区分配了76字节（而非源代码中的64字节）。如果你是一名编译器开发者，或者愿意深入分析gcc的源代码，否则，你只能推测编译器如此分配这些额外字节的原因。多数情况下，你可以将分配这些额外字节的原因归结成为对齐所做的填补，而且这些字节通常不会影响程序的行为。毕竟，如果程序员要求64 字节，却得到76 字节，程序应该不会表现出不同的行为，特别是程序员使用的字节没有超出所请求的64 字节的情况下。另一方面，如果你是一名破解程序开发人员，并且知道可以使这个特殊的缓冲区溢出；那么，你应该认识到，你至少得提供76 字节（就编译器而言，这是缓冲区的有效大小），否则你希望看到的事就不会发生。在第8 章中，我们将再次讨论栈帧视图，以及它在处理数组和结构体等更加复杂的数据类型时的用法。
6.3 搜索数据库
在IDA 中，你可以轻松导航到你知道的位置。IDA 设计了许多类型的数据显示来总结特定类型的信息（名称、字符串、导入等），以方便你查找这些信息。但是，哪些功能可帮助你对数据库进行更一般的搜索呢？如果仔细查看一下搜索菜单，你会发现大量选项，它们绝大多数都要求你选择某个类别中的下一个选项。例如，Search ▶Next Code命令将光标移动到下一个包含指令的位置。你可能还希望了解跳转菜单中的选项，这其中许多选项提供了大量位置供你选择。例如，使用Jump▶Jump to Function 命令可以打开所有函数，你可以迅速选择一个函数并导航到该函数所在的位置。虽然这些扫描搜索功能通常非常有用，但下面这两种通用搜索功能更值得详细讨论：文本搜索和二进制搜索。
6.3.1 文本搜索
IDA 文本搜索相当于对反汇编列表窗口进行子字符串搜索。通过Search▶Text（热键：ALT+T）命令启动文本搜索，即打开如图6-7所示的对话框。许多直观的选项规定了与搜索有关的细节。如图所示，IDA 允许你搜索POSIX 类型的正则表达式。这里的标识符
 （Identifier ）搜索有些用词不当。实际上，它将搜索限制于仅查找完整的词，并且能够匹配反汇编行中的任何完整的词，包括操作码助记符或常量。对401116
 进行标识符搜索将无法找到名为loc_401116
 的符号。
图6-7 Text Search （文本搜索）对话框
选择Find all occurences （查找所有结果），IDA 将在一个新的窗口中显示搜索结果，你可以根据搜索条件轻松导航到任何一个匹配结果。最后，使用CTRL＋T或Search▶Next Text （搜索▶下一个文本）命令可重复前一项搜索，以找到下一个匹配结果。
6.3.2 二进制搜索
如果需要搜索特定的二进制内容，如已知的字节序列，这时就不能使用文本搜索功能，而应使用IDA 的二进制搜索工具。文本搜索针对反汇编窗口进行搜索，但是，你可以认为二进制搜索仅搜索十六进制视图窗口。根据你指定搜索字符串的方式，你可以搜索十六进制或ASCII字符串。使用Search ▶Sequence of Bytes（搜索▶字节序列）或ALT+B即可启动二进制搜索。Binary Search（二进制搜索）对话框如图6-8所示。要搜索一个十六进制字节序列，应将搜索字符串指定为以空格分隔的两位十六进制值组成的列表，如CA FE BA BE
 ，这与搜索ca fe ba be
 的结果相同，无论你是否选中Case-sensitive （区分大小写）选项都是如此。
图6-8 Binary Search 对话框
要搜索内嵌的字符串数据（有效搜索十六进制窗口中的ASCII字符串），你必须将搜索字符串用引号括起来。使用Unicode Strings选项可以搜索你所搜索的字符串的Unicode版本。
Case-sensitive 选项可能会引起混淆。在搜索字符串时，它的作用相当简单。如果没有选中Case-sensitive 选项，则搜索hello 时会出现HELLO。但是，在进行十六进制搜索时，如果没有选中Case-sensitive 选项，情况会有所不同。如果对E9 41 C3
 进行不区分大小写的搜索，你会惊奇地发现，E9 61 C3
 出现在了搜索结果中。这是因为，0x41 对应于字符A，而0x61 则对应于字符a，所以IDA 认为这两个字符串相互匹配。所以，即使你指定了进行十六进制搜索，但0x41 却等同于0x61 ，因为你并没有指定进行区分大小写的搜索。
说明
  在进行十六进制搜索时，如果希望将搜索限定为完全匹配，你必须选中Case-sensitive 选项。在你搜索特定的操作码序列而非ASCII文本时，这点尤为重要。
使用CTRL＋B或Search ▶Next Sequence of Bytes（搜索▶下一个字节序列）可以搜索随后的二进制数据。最后，你并没有必要在十六进制视图窗口中进行二进制搜索。IDA 允许你在活动的反汇编窗口中指定二进制搜索条件，如果你成功找到与搜索条件相匹配的字符串，反汇编窗口将跳转对相应的位置。
6.4 小结
本章介绍了帮助你高效浏览反汇编代码的最基本的技巧。到目前为止，我们已经讨论了与IDA 进行交互所涉及的绝大多数操作。了解如何导航后，下一步我们将学习如何修改IDA 数据库，以满足用户的特殊要求。在下一章中，我们将学习如何对反汇编代码进行最基本的修改，从而在了解二进制文件内容和行为的基础上掌握新的知识。
第7章 反汇编操作
继导航之后，IDA 提供的另一项重要功能是让你根据需要修改反汇编代码。由于IDA 基础数据库的本质，你对反汇编代码所做的更改将迅速“扩散”到IDA 的所有子窗口中，以使反汇编代码保持一致，而这正是本章要向读者展示的内容。IDA 提供的一项最强大的功能能够帮助你轻松操作反汇编代码，在其中添加新的信息，或重新格式化一个代码清单，以满足你的特殊要求。在必要时，IDA 能够自动处理各种操作，如全局搜索和替换，并可轻易对指令和数据重新格式化（或将格式化后的指令和数据还原），这些都是其他反汇编工具所不具备的功能。
说明
  记住，IDA 不提供撤销功能。在操纵数据库时，请一定记住这一点。你所能做的，就是经常保存数据库，并恢复到最近保存的数据库版本。
7.1 名称与命名
到现在为止，我们已经在IDA 反汇编窗口中遇到了两类名称：与虚拟地址（已命名的位置）有关的名称和与栈帧变量有关的名称。在绝大多数情况下，IDA 会根据前面讨论的指导原则，自动生成所有这些名称。IDA 把这些自动生成的名称叫做哑名
 。
遗憾的是，这些名称很少能够帮助我们了解一个位置或变量的用途，因此也无法帮助我们了解程序的行为。在分析一个程序时，操作反汇编代码清单的最主要和最常使用的一个方法，是将默认名称更改为更有意义的名称。好在IDA 允许你随意修改任何名称，并处理在整个反汇编代码清单中扩散名称变更的所有细节。多数情况下，要修改一个名称，只需单击你希望修改的名称（使其突出显示），并使用热键N 打开更名对话框。另外，右击需要修改的名称，并在出现的上下文菜单中选择Rename选项（如图6-5所示），也可以更改名称。栈变量和已命名的位置的更名过程稍有不同，我们将在后续几节中详细说明这些差异。
7.1.1 参数和局部变量
与栈变量有关的名称是反汇编代码清单中最简单的名称，这主要是因为它们与特定的虚拟地址无关，因而从未出现在名称窗口中。和在许多编程语言中一样，根据给定栈帧所属的函数，这类名称的作用域会受到限制。因此，程序中的每个函数可能都有一个名为arg_0
 的栈变量，但没有一个函数拥有一个以上的arg_0
 变量。图7-1所示的对话框用于重命名栈变量。
图7-1
  重命名栈变量
提供一个新名称后，IDA 会对当前函数上下文中的每一个旧名称进行修改。在demo_stackframe
 中，将var_5C
 更名为y
 ，将得到如下所示的新代码清单，➊处的名称已发生变化。
.text:00401090 ; =========== S U B R O U T I N E =========================  
.text:00401090  
.text:00401090 ; Attributes: bp-based frame    
.text:00401090  
.text:00401090 demo_stackframe proc near      ; CODE XREF: sub_4010C1+41↓p  
.text:00401090  
.text:00401090 var_60          = dword ptr -60h   
.text:00401090 ➊y             = dword ptr -5Ch  
.text:00401090 var_58          = byte ptr -58h  
.text:00401090 var_C           = dword ptr -0Ch  
.text:00401090 arg_4           = dword ptr  0Ch  
.text:00401090 arg_8           = dword ptr  10h  
.text:00401090  
.text:00401090                 push    ebp  
.text:00401091                 mov     ebp, esp  
.text:00401093                 sub     esp, 112  
.text:00401096                 mov     eax, [ebp+arg_8]  
.text:00401099                 mov     [ebp+var_C], eax  
.text:0040109C                 mov     eax, [ebp+arg_4]  
.text:0040109F                 mov     [ebp+y], eax  
.text:004010A2                 mov     [ebp+var_60], 0Ah  
.text:004010A9                 mov     [ebp+var_58], 41h  
.text:004010AD                 mov     eax, [ebp+➊y]  
.text:004010B0                 mov     [esp+4], eax  
.text:004010B4                 mov     eax, [ebp+var_60]  
.text:004010B7                 mov     [esp], eax  
.text:004010BA                 call    bar  
.text:004010BF                 leave  
.text:004010C0                 retn  
.text:004010C0 demo_stackframe endp  
如果你希望恢复某个变量的默认名称，打开更名对话框，在输入框中输入一个空白名称，IDA将为你生成默认的名称。
7.1.2 已命名的位置
重命名一个已命名的位置或给一个未命名的位置取名，这个过程与修改栈变量的名称略有不同。打开更名对话框的方法（利用热键N）完全相同，但随后的操作则明显不同。与已命名的位置有关的更名对话框如图7-2所示。
图7-2
  重命名某个位置
该对话框显示你命名的具体地址，以及一些与该名称有关的特性。最大名称长度对应于IDA的一个配置文件（/cfg/ida.cfg）中的某个值。你可以使用任何超出这个长度的名称，这时，IDA 会显示警告消息，提醒你已经超出了最大名称长度，并要求为你增加最大名称长度设置。如果你选择这样做，IDA 将仅在当前数据库中采用新设置的最大名称长度值，而你创建的任何新数据库仍将继续采用配置文件中指定的最大名称长度。
下面的特性可能与某个已命名的位置有关。
Local names （局部名称）
 。局部名称的作用域仅限于当前函数，因此，局部名称的唯一 性仅在某个给定的函数中有效。与局部变量一样，两个不同的函数可能含有完全相同的 局部名称，但一个函数不可能包含两个完全相同的局部名称。在函数边界以外的已命名 的位置不能被指定为局部名称，这包括表示函数及全局变量的名称。局部名称最常用于 为函数中的跳转目标提供符号名称，如那些与分支控制结构有关的名称。
Include in names list （包含在名称列表中）
 。选择这个选项将有一个名称被添加到名称窗 口中，这样，当你需要返回该名称所在位置时，就更容易找到这个名称。默认情况下， 自动生成的名称（哑名）不包含在名称窗口中。
Public name（公共名称）
 。通常，公共名称是指由二进制文件（如共享库）输出的名称。 在最初加载数据库的过程中，IDA 的解析器会在解析文件头的同时查找公共名称。选择这 个特性，你可以强制IDA 将一个符号看成是公共名称。一般来说，这样做除了给反汇编代 码清单和名称窗口中的名称添加公共注释外，不会对反汇编代码造成任何影响。
Autogenerated name（自动生成的名称）
 。这个特性似乎不会对反汇编代码产生任何明显 的影响。选择它并不会使IDA 自动生成一个名称。
Weak name（弱名称）
 。弱符号（weak symbol）是公共符号的一种特殊形式，只有没有 找到相同名称的公共符号来重写时，才会使用弱符号。将一个符号标记为弱符号对汇编 器有一定意义，但对IDA 反汇编代码却没有任何意义。
Create name anyway （无论如何都要创建名称）
 。如前所述，一个函数中不会有两个位 置使用相同的名称。同样，在函数以外（全局范围内），也不能有两个位置使用相同的名 称。这个选项比较容易引起混淆，因为你创建的名称的类型不同，它的行为也不一样。
如果你正在全局范围内编辑一个名称（如函数名称或全局变量），并且尝试分配一个数据库中已经存在的名称，这时，IDA 将会显示名称冲突对话框，如图7-3所示。同时，IDA 会自动生成一个唯一的数字后缀，以解决冲突。无论你是否选择Create name anyway选项，这个对话框都会出现。
但是，如果你正编辑某个函数中的一个局部名称，并且尝试分配一个已经存在的名称，这时，默认情况下，IDA 会拒绝这种尝试。如果你决心要使用这个名称，必须选择Create name anyway选项，以强制IDA 为局部名称生成一个唯一的数字后缀。当前，解决名称冲突的最简单方法，是选择一个从未使用的名称。
图7-3
  名称冲突对话框
7.1.3 寄存器名称
第三类常被忽略的名称为寄存器名称。在函数边界内，IDA 允许对寄存器进行重命名。如果编译器选择将变量分配到寄存器中，而不是程序栈上，并且你希望使用一个比EDX更恰当的名称来引用这个变量，这时重命名寄存器才有用处。重命名寄存器与重命名其他位置的方法几乎完全相同。使用热键N，或右击寄存器名称并在出现的菜单中选择Rename，打开“寄存器重命名”对话框。重命名寄存器时，你实际上是提供了一个别名，并使用它在当前函数执行期间引用该寄存器（IDA 甚至在函数开始部分用alias=register
 语法来表示这个别名）。然后，IDA 会用你提供的别名替代该寄存器的名称。如果一段代码不属于某个函数，那么，重命名这段代码中的寄存器是不可能的。
7.2 IDA 中的注释
IDA 的另一项有用功能是它能够在数据库中嵌入注释。在分析程序时，添加注释特别有用，因为它可帮助你随时掌握分析进程。具体来说，注释有助于以一种更高级的方式描述汇编语言指令序列。例如，你可以选择使用C语言语句添加注释，以总结某个特殊函数的行为。在随后的函数分析过程中，这些注释有助于你迅速回忆起该函数的作用，而不需要重新分析汇编语言语句。
IDA 提供了几种不同类型的注释，每种注释适用于不同的目的。使用Edit▶Comments命令提供的选项，可以为反汇编代码清单中的任何一行代码添加注释。通过热键或上下文菜单，同样可以使用IDA 的注释功能。为帮助你理解IDA 的注释功能，我们下面以函数bar