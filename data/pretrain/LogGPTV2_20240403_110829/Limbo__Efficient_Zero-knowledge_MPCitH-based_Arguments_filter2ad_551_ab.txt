signing/verification run times comparable with those of Picnic and
signature size only 30% larger (for a 10x bigger circuit), assuming
the same number of parties. We can reduce the signature size by
running the protocol with larger number of parties at the cost of
slower signing and verification. More details about our concrete
measures can be found in Section 7.
Other related works. A recent line of work [4, 22, 40, 41], based
on subfield vector oblivious linear evaluation (sVOLE), provides ZK
proofs with very small memory footprint and extremely good effi-
ciency. Our system, like other MPCitH protocols, allows streaming
and can potentially achieve small memory overhead. Although we
cannot accomplish the same performance of sVOLE-based proto-
cols, our approach does not require an interactive preprocessing.
Moreover, LPZK [22] and Macâ€™nâ€™Cheese [4] are currently designed
only for large fields, whereas our protocol naturally works for both
arithmetic and Boolean circuits.
2 PRELIMINARIES
We denote by ğœ… (resp. ğœ†) the computational (resp. statistical)
security parameter. We say that a function ğœ‡ : N â†’ N is negligible
if, for every positive polynomial ğ‘(Â·) and all sufficiently large inte-
ger ğ‘˜, it holds that ğœ‡(ğ‘˜) < 1
ğ‘(ğ‘˜) . We also use the abbreviation PPT
to denote probabilistic polynomial-time algorithms. We use bold
letters to denote vectors, e.g. a, and use brackets to denote entries,
e.g. (a)ğ‘–; the operator âˆ— denotes the inner product of two vectors.
We denote by [ğ‘‘] the set of integers {1, . . . , ğ‘‘}, and by [ğ‘’, ğ‘‘] the set
of integers {ğ‘’, . . . , ğ‘‘} with 1 < ğ‘’ < ğ‘‘.
MPC notation. The notation âŸ¨Â·âŸ© stands for additively secret-shared
values with full threshold, and âŸ¨Â·âŸ©ğ‘– for the share held by party ğ‘ƒğ‘–.
Languages and relations. We denote by â„› a relation consisting
of pairs (ğ‘¥, ğ‘¤), where ğ‘¥ is the instance and ğ‘¤ is the witness. We
denote by â„’(â„›) the language corresponding to â„›.
2.1 Zero-knowledge Arguments of Knowledge
An argument of knowledge for an NP relation â„› is a protocol
between a prover ğ’« and a verifier ğ’±. We let view(âŸ¨ğ’«(ğ‘¥, ğ‘¤), ğ’±(ğ‘¥)âŸ©)
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3024denote the transcript generated by ğ’« and ğ’± when interacting on in-
puts (ğ‘¥, ğ‘¤) and ğ‘¥, respectively. Also, we say that âŸ¨ğ’«(ğ‘¥, ğ‘¤), ğ’±(ğ‘¥)âŸ© =
ğ‘ âˆˆ {0, 1} depending on whether ğ’± accepts, ğ‘ = 1, or rejects ğ‘ = 0.
Definition 2.1. The pair (ğ’«, ğ’±) is called an argument of knowledge
for the relation â„› if the following properties are satisfied.
Completeness: âˆ€(ğ‘¥, ğ‘¤) âˆˆ â„›, âŸ¨ğ’«(ğ‘¥, ğ‘¤), ğ’±(ğ‘¥)âŸ© = 1.
Soundness: For any PPT prover ğ’«âˆ—, there exists a PPT extractor â„°
such that, for any ğ‘¥, the probability
Pr[âŸ¨ğ’«(ğ‘¥, ğ‘¤), ğ’±(ğ‘¥)âŸ© = 1 âˆ§ (ğ‘¥, ğ‘¤) âˆ‰ â„› | ğ‘¤ â† â„°ğ’«âˆ—(ğ‘¥)]
is negligible, where the extractor â„°ğ’«âˆ— has access to the entire exe-
cution, including the randomness of ğ’«âˆ—.
Definition 2.2. An argument of knowledge (ğ’«, ğ’±) is public coin
if the verifier samples its messages uniformly at random and inde-
pendently of the messages sent by ğ’«. This is equivalent to say that
ğ’±â€™s messages correspond to ğ’±â€™s randomness.
Definition 2.3. A public coin argument of knowledge is (honest
verifier) zero-knowledge for a relation â„› if there exists a simulator ğ’®
such that, for any (ğ‘¥, ğ‘¤) âˆˆ â„›, the view of an honest verifier in the
interaction âŸ¨ğ’«, ğ’±âŸ© and the output of ğ’® are indistinguishable, i.e.
view(âŸ¨ğ’«(ğ‘¥, ğ‘¤), ğ’±(ğ‘¥)âŸ©) â‰ˆ ğ’®ğ’±(ğ‘¥),
where ğ’®ğ’± denotes access to the public coin randomness used by
the verifier.
2.2 Interactive Oracle Proofs
Interactive oracle proofs (IOPs) simultaneously extend probabilis-
tic checkable proofs (PCPs) and interactive proofs (IPs) by allowing
more rounds of interaction and using point-wise queries from the
verifier to the oracles, instead of linear queries. IOPs also differ
from IPCPs which can be viewed as special IOPs where the verifier
has oracle access to the first prover messages, but must read in full
subsequent proverâ€™s messages.
Definition 2.4. A ğœŒ-round public-coin IOP for the relation â„›
consists of a ğœŒ-round interactive protocol between ğ’« and ğ’±, with
ğœŒ â‰¥ 2, such that in each round ğ‘– â‰¥ 2, after an initial ğœ‹1 created
by ğ’«, the verifier ğ’± sends a uniformly random message ğ‘£ğ‘–âˆ’1 to
ğ’« and the prover replies with ğœ‹ğ‘–. The verifier has oracle access
to ğœ‹ = {ğœ‹1, . . . , ğœ‹ğœŒ} and ğ’«â€™s last message in response to ğ‘£ğœŒ and,
based on the responses from the oracles, either accepts or rejects.
It satisfies the following two properties:
Completeness: As in Definition 2.1.
Soundness: For all ğ‘¥ âˆ‰ â„’, and for all (computationally unbounded)
ğ’«âˆ—
Pr[âŸ¨ğ’«(ğ‘¥, ğ‘¤), ğ’±ğœ‹ (ğ‘¥)âŸ© = 1] is negligible.
This definition can be extended with the knowledge and honest
verifier zero-knowledge properties [9]. Beyond soundness we can
consider other complexity measures, in particular the query com-
plexity, i.e. the number of queries asked by ğ’± to any of the oracles
during the ğœŒ rounds, and the proof complexity, i.e. the number of
bits communicated during the interactions.
2.3 MPC-in-the-Head
In [28], Ishai, Kushilevitz, Ostrovsky and Sahai introduced the
MPC-in-the-Head (MPCitH) paradigm that uses any MPC protocol
with honest majority to construct a zero-knowledge proof for an
arbitrary NP relation â„›. The high level idea of this powerful tech-
nique is as follows. A zero-knowledge protocol can be viewed as
an instance of secure function evaluation, and hence as two-party
computation between a prover ğ’« and a verifier ğ’±, with common
input the statement ğ‘¥, and ğ’«â€™s private input ğ‘¤, which is a witness
to the assertion that ğ‘¥ belongs to a given NP language â„’. The func-
tion they want to compute is then ğ‘“ğ‘¥ (ğ‘¤) = â„›(ğ‘¥, ğ‘¤), which checks
if ğ‘¤ is a valid witness or not. The verifier ğ’± will accept the proof if
ğ‘“ğ‘¥ (ğ‘¤) = â„›(ğ‘¥, ğ‘¤) = 1.
In the MPCitH paradigm the zk-PCP prover ğ’« emulates an ğ‘›-
party MPC protocol Î  in â€œits headâ€: ğ’« generates a sharing âŸ¨ğ‘¤âŸ©
of the witness and distributes the corresponding shares as private
inputs to the parties, and then simulates the evaluation of ğ‘“ğ‘¥ (âŸ¨ğ‘¤âŸ©) =
â„›(ğ‘¥, âŸ¨ğ‘¤âŸ©) by choosing uniformly random coins ğ‘Ÿğ‘– for each party
ğ‘ƒğ‘–, ğ‘– âˆˆ [ğ‘›]. Once the inputs and random coins are fixed, for each
round ğ‘— of communication of the protocol Î  and for each party ğ‘ƒğ‘–,
the messages sent by ğ‘ƒğ‘– at round ğ‘— are deterministically specified
as a function of the internal state of ğ‘ƒğ‘–, i.e. ğ‘ƒğ‘–â€™s private inputs and
randomness, and the messages that ğ‘ƒğ‘– received in previous rounds.
The set with the state and all messages received by party ğ‘ƒğ‘– during
the execution of the protocol constitutes the view of ğ‘ƒğ‘–, denoted as
viewğ‘–.
After the evaluation, the prover sets ğœ‹ = (view1, . . . , viewğ‘›) and
sends it to an oracle ğ’ª. At this point, the verifier queries ğœ‹ on some
points and finally verifies that the computation was done correctly
by checking that the opened views are all consistent with each
other and that the protocol outputs a positive result.
3 MPC-IN-THE-HEAD BASED IOPâ€”GENERAL
CONSTRUCTION
In this section we describe a general interactive proof system
based on the MPC-in-the-Head paradigm which can be instanti-
ated with different MPC protocols that respect a specific network
topology. While IKOS [28] presents a general transformation of
information-theoretic MPC protocols to a ZK proof in a â€œblack-
boxâ€ way, we follow Ligeroâ€™s blueprint and precisely define the
MPC model we use to build our system. We extend the general
proof system defined in [2] by allowing arbitrary number of rounds.
Then, we instantiate the MPC component with a different and yet
very simple protocol which will allow the verifier to open a bigger
number of views (or, equivalently, to query the oracles at a larger
number of points).
3.1 MPC Model
Here we describe the MPC model that can be used to implement
our general interactive proof system. This model can in turn be
instantiated with MPC protocols with different security properties,
leading to systems with different soundness, communication and
computational complexity.
First we recall the following basic definition.
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3025Definition 3.1 (Correctness, privacy and robustness [28]). Let Î ğ‘“
be an MPC protocol for a functionality ğ‘“ .
- We say that the protocol Î ğ‘“ realizes ğ‘“ with perfect (resp.
statistical) correctness if for all inputs ğ‘¥, the probability that
the output of some party is different from ğ‘“ (ğ‘¥) is 0 (resp.
negligible in ğœ†), where the probability is over the random
inputs of each party.
- Let 1 â‰¤ ğ‘¡ < ğ‘›, the protocol Î ğ‘“ has ğ‘¡-privacy if it is correct
and for all ğ¼ âŠ† [ğ‘›] such that |ğ¼| â‰¤ ğ‘¡, there exists a PPT
algorithm ğ’® such that the joints views (viewğ¼ (ğ‘¥)) of parties
in ğ¼ has the same distribution as ğ’®(ğ¼, ğ‘¥ğ¼ , ğ‘“ğ¼ (ğ‘¥)). We will talk
of perfect, statistical or computational ğ‘¡-privacy accordingly.
- Let 0 â‰¤ ğ‘Ÿ < ğ‘›, the protocol Î ğ‘“ has perfect (resp. statistical) ğ‘Ÿ-
robustness if it is correct and for all ğ¼ âŠ† [ğ‘›] such that |ğ¼| â‰¤ ğ‘Ÿ,
even assuming that all the parties in ğ¼ have been adaptively
corrupted, if there does not exists any random input such
that ğ‘“ (ğ‘¥) = 1, then the probability that Î ğ‘“ outputs 1 and the
views of honest parties are consistent is zero (resp. negligible
in ğœ†).
We now describe our MPC model.
Definition 3.2 (Client-server ğœŒ-phase protocol). Let Î ğ‘“ be an MPC
protocol for a functionality ğ‘“ . We say that Î ğ‘“
is in the client-
server model if its parties can be divided into a distinguished â€œinput
(sender) clientâ€ ğ‘ƒğ‘†, ğ‘› â€œcomputation serversâ€ ğ‘ƒ1, . . . , ğ‘ƒğ‘›, and (option-
ally) a distinguished â€œoutput (receiver) clientâ€ ğ‘ƒğ‘…. Additionally, ğ‘ƒğ‘†
receives the entire input ğ‘¥ and only sends at most one message to
each of the computation servers at the beginning of each phase,1
and ğ‘ƒğ‘… only receives a single message from each of the servers at
the end of the protocol. The servers can only communicate with
each other via a broadcast.
We then say that Î ğ‘“
is a client-server ğœŒ-phase protocol if the
computation of the ğ‘› servers can be divided into ğœŒ consecutive
phases each separated by the sampling of a public random string
via a call to RandomCoin from all the servers.
The following three stages summarise the execution of a client-
server ğœŒ-phase protocol.
(1) In the first phase, the servers receive the input message m1
from ğ‘ƒğ‘† and start their local computation of the circuit. More
precisely, m1 is a vector of messages, where each server gets
one entry of the vector.
(2) For each phase ğ‘— âˆˆ [2, ğœŒ âˆ’ 1]:
(a) The servers call RandomCoin and obtain a public random
string ğ‘… ğ‘—âˆ’1, along with at most a single message mğ‘— from
ğ‘ƒğ‘†. Again, each party ğ‘ƒğ‘– only receives (âŸ¨mğ‘—âŸ©)ğ‘–, for ğ‘– âˆˆ [ğ‘›].
(b) The servers use the random string (and mğ‘—) to continue
their local computation.
(3) In phase ğœŒ, the servers obtain a public random string ğ‘…ğœŒ and
each sends a single message to the receiver client ğ‘ƒğ‘….
In our model we consider a threshold (ğ‘ƒğ‘, ğ‘¡ğ‘ )-adversary which
corrupts at most one client ğ‘ƒğ‘, up to ğ‘¡ğ‘  servers, or both. In particular,
we extend Definition 3.1 as follows.
1Ligero allows only one message from ğ‘ƒğ‘† to the servers in the entire computation, i.e.
it cannot send another message even after the public coin sampling that takes place
between the two phases.
Protocol Î ğœŒâˆ’ZKIOP
Let Î ğ‘“ a ğœŒ-phase MPC protocol in the client/server model. Common
Input: A statement ğ‘¥ and a circuit description ğ¶ğ‘“ that realizes the
relation â„›.
Private Input: ğ’« holds the witness ğ‘¤ such that â„›(ğ‘¥, ğ‘¤) = 1
First Oracle ğœ‹1. ğ’« runs the MPC protocol Î ğ‘“ in its head: it samples
a random ğ‘Ÿğ‘† , {ğ‘Ÿğ‘– }ğ‘–âˆˆ[ğ‘›] âˆˆ {0, 1}âˆ— âˆª âˆ… and invoke the sender client ğ‘ƒğ‘†
on input (ğ‘¥, ğ‘¤; ğ‘Ÿğ‘†). and the servers on random input ğ‘Ÿğ‘–. The prover
computes the views (view1
It sets the oracle ğœ‹1 = (view1
Interactive protocol.
- For ğ‘— âˆˆ [2, ğœŒ]:
ğ‘›) of the servers in phase 1.
1, . . . , view1
ğ‘›)
1, . . . , view1
- ğ’± picks a random challenge ğ‘… ğ‘—âˆ’1 and sends to ğ’«
- ğ’« continues to run the protocol in its head.
It invokes the sender client and the servers on input
ğ‘… ğ‘—âˆ’1 obtained in the previous step and produces views
(viewğ‘—
1, . . . , viewğ‘—
1, . . . ,
ğ‘›).
viewğ‘—
ğ‘›). It sets the oracle ğœ‹ ğ‘— (ğ‘… ğ‘—âˆ’1) = (viewğ‘—
- ğ’± picks a random challenge ğ‘…ğœŒ and sends to ğ’«.
- ğ’« computes and sends viewğ‘… of the receiver client
- ğ’± rejects if ğ‘ƒğ‘… outputs ğ¶ğ‘“ = 0; if not, ğ’± asks to open a subset
of server views. More precisely ğ’± picks random subsets ğ‘‰ğ‘— âŠ‚
[ğ‘›], ğ‘— âˆˆ [ğœŒ], such that | âˆªğ‘— ğ‘‰ | â‰¤ ğ‘¡ğ‘ ,ğ‘.
- ğ’« open the views in âˆªğ‘—ğ‘‰ğ‘—
- Final verification: ğ’± aborts if the views in ğ‘‰ğ‘— are inconsistent
with each other and/or with viewğ‘…, otherwise it accepts.
Figure 1: General description of the ğœŒ-round IOP
Definition 3.3. We say that a protocol Î ğ‘“ realizes ğ‘“ with (ğ‘ƒğ‘, ğ‘¡ğ‘ ,ğ‘)-
privacy (resp. (ğ‘ƒğ‘, ğ‘¡ğ‘ ,ğ‘Ÿ)-robustness) if the properties in Definition 3.1
hold with respect to a semi-honest (resp. adaptive malicious) adver-
sary ğ’œ that corrupts all the parties in ğ¼ = {ğ‘ƒğ‘} Ã— ğ¼ğ‘  âŠ‚ {ğ‘ƒğ‘†, ğ‘ƒğ‘…} Ã—
{ğ‘ƒğ‘–}ğ‘–âˆˆ[ğ‘›], such that |{ğ‘ƒğ‘}| â‰¤ 1 and |ğ¼ğ‘ | â‰¤ ğ‘¡ğ‘ ,ğ‘ (resp. ğ‘¡ğ‘ ,ğ‘Ÿ ).
Note that this definition allows (âˆ…, ğ‘¡ğ‘ )-adversaries that only cor-
rupt server parties.
3.2 Interactive Proof System - General
Description
Given an MPC protocol Î ğ‘“ as described in Definition 3.2, we
show a ğœŒ-round interactive protocol, Î ğœŒâˆ’ZKIOP (Figure 1), verifying
the properties in Definition 2.4.
Let â„’(â„›) be an NP-language with relation â„›, and let ğ‘“ğ‘¥ (ğ‘¤) =
â„›(ğ‘¥, ğ‘¤). Our ğœŒ-round systems starts with the prover ğ’« emulating
a ğœŒ-round MPC protocol Î ğ‘“ (meeting Definition 3.2 ) that real-
izes the functionality ğ‘“ . As done in Ligero, we further restrict the
MPC model and assume that the servers ğ‘ƒğ‘– never communicate
with each other. The first round of Î ğœŒâˆ’ZKIOP provides to an or-
acle ğ’ª the string ğœ‹1 = (view1
ğ‘›) , corresponding to the
views of the ğ‘› servers at the end of the first round. After this, we
have the interactive steps, which exactly correspond to the rounds
[2, ğœŒ] of the underlying MPC protocol, with the randomness ob-
tained by the RandomCoin functionality being replaced by the veri-
fierâ€™s challenges ğ‘…1, . . . , ğ‘…ğœŒ. We can pictorially represent the oracles
ğœ‹1, . . . , ğœ‹ğœŒ as a ğœŒ Ã— ğ‘› matrix ğ‘„, where the rows are ğ‘„ ğ‘— = ğœ‹ ğ‘— , ğ‘— âˆˆ [ğœŒ],
and the columns, ğ‘„ğ‘–, ğ‘– âˆˆ [ğ‘›], correspond to the â€œglobalâ€ view of the
parties, i.e. ğ‘„ğ‘– = {view1
1, . . . , view1
ğ‘– }, for ğ‘– âˆˆ [ğ‘›].
ğ‘– , . . . , view
ğœŒ
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3026Note that if we instantiate Î ğœŒâˆ’ZKIOP with ğœŒ = 1, we obtain the
system described in [2], which only allows one single message from
ğ‘ƒğ‘† to the servers ğ‘ƒğ‘–, ğ‘– âˆˆ [ğ‘›].
Restricting the model. We now specialize the MPC model Î ğ‘“ used
in Î ğœŒâˆ’ZKIOP with a protocol achieving (ğ‘ƒğ‘…, ğ‘› âˆ’ 1)-privacy in the
semi-honest model and (ğ‘ƒğ‘†, 0)-robustness in the malicious model.
In particular, this latter property means that the MPC protocol
does not allow any collusion between a malicious client sender and
servers.
Moreover, we restrict ğ’±â€™s queries (and hence also our IOP system)
to the columns of the matrix ğ‘„, assuming that the verifier only
opens up to ğ‘› âˆ’ 1 of these â€œglobalâ€ views.
If we now consider the security of our construction, it is very
important to distinguish between the randomness used to ensure
privacy and that used for robustness. The former is generated by ğ’«
when it samples the randomness for the MPC parties. The latter is
given by ğ’± and the crucial point is that each string generated in the
middle of the protocol must be unpredictable for ğ’« during previous
phases. Intuitively, the prover ğ’« can cheat either by â€œcorrupting
ğ‘ƒğ‘†â€ and computing the mğ‘— messages wrongly, or by â€œcorruptingâ€
one or more of the servers ğ‘ƒğ‘–, ğ‘– âˆˆ [ğ‘›], and computing their message
to ğ‘ƒğ‘… wrongly.
More formally, we obtain the following result.
Theorem 3.4. Let ğ‘¥ be a public statement and ğ‘¤ an additional
input, let ğ‘“ be the functionality for ğ‘ƒğ‘†, ğ‘ƒ1, . . . , ğ‘ƒğ‘› and ğ‘ƒğ‘… that outputs
â„›(ğ‘¥, ğ‘¤) to ğ‘ƒğ‘…. Let Î ğ‘“ be a ğœŒ-phase MPC protocol in the client/server
model that correctly realizes ğ‘“ with (ğ‘ƒğ‘…, (ğ‘› âˆ’ 1))-privacy in the semi-
honest model and (ğ‘ƒğ‘†, 0)-robustness (in the malicious model) with
robustness error ğ›¿. The protocol Î ğœŒâˆ’ZKIOP described in Fig. 1 is a
ZKIOP for NP relation â„›, with soundness error
(cid:18)
(cid:19)
.
1 âˆ’ 1
The proof is given in the full version.
+ ğ›¿
ğœ– =
1
ğ‘›
ğ‘›
A very common solution to achieve the desired soundness in
zero-knowledge systems, is to run the base protocol a certain num-
ber of times ğœ. Obviously, this approach increases the complexity of
the system both computationally and in communication by a mul-
tiplicative factor ğœ. In the next section we describe a better strategy
that allows to reach better soundness with less overhead.
3.3 Improving Soundnessâ€”More MPC
Evaluations
We improve the soundness of the IOP construction of Figure 1
by having multiple sets of server parties execute the underlying
MPC protocol in parallel. This improvement comes from the ability
to open multiple sets of ğ‘› âˆ’ 1 views to the verifier, each picked
independently at random thus reducing the limiting 1/ğ‘› term of
Theorem 3.4.
By having the public randomness of RandomCoin shared across