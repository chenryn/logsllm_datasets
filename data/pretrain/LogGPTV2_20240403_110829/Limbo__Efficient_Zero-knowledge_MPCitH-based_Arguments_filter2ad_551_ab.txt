signing/verification run times comparable with those of Picnic and
signature size only 30% larger (for a 10x bigger circuit), assuming
the same number of parties. We can reduce the signature size by
running the protocol with larger number of parties at the cost of
slower signing and verification. More details about our concrete
measures can be found in Section 7.
Other related works. A recent line of work [4, 22, 40, 41], based
on subfield vector oblivious linear evaluation (sVOLE), provides ZK
proofs with very small memory footprint and extremely good effi-
ciency. Our system, like other MPCitH protocols, allows streaming
and can potentially achieve small memory overhead. Although we
cannot accomplish the same performance of sVOLE-based proto-
cols, our approach does not require an interactive preprocessing.
Moreover, LPZK [22] and Mac’n’Cheese [4] are currently designed
only for large fields, whereas our protocol naturally works for both
arithmetic and Boolean circuits.
2 PRELIMINARIES
We denote by 𝜅 (resp. 𝜆) the computational (resp. statistical)
security parameter. We say that a function 𝜇 : N → N is negligible
if, for every positive polynomial 𝑝(·) and all sufficiently large inte-
ger 𝑘, it holds that 𝜇(𝑘) < 1
𝑝(𝑘) . We also use the abbreviation PPT
to denote probabilistic polynomial-time algorithms. We use bold
letters to denote vectors, e.g. a, and use brackets to denote entries,
e.g. (a)𝑖; the operator ∗ denotes the inner product of two vectors.
We denote by [𝑑] the set of integers {1, . . . , 𝑑}, and by [𝑒, 𝑑] the set
of integers {𝑒, . . . , 𝑑} with 1 < 𝑒 < 𝑑.
MPC notation. The notation ⟨·⟩ stands for additively secret-shared
values with full threshold, and ⟨·⟩𝑖 for the share held by party 𝑃𝑖.
Languages and relations. We denote by ℛ a relation consisting
of pairs (𝑥, 𝑤), where 𝑥 is the instance and 𝑤 is the witness. We
denote by ℒ(ℛ) the language corresponding to ℛ.
2.1 Zero-knowledge Arguments of Knowledge
An argument of knowledge for an NP relation ℛ is a protocol
between a prover 𝒫 and a verifier 𝒱. We let view(⟨𝒫(𝑥, 𝑤), 𝒱(𝑥)⟩)
Session 11B: Zero Knowledge II CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea3024denote the transcript generated by 𝒫 and 𝒱 when interacting on in-
puts (𝑥, 𝑤) and 𝑥, respectively. Also, we say that ⟨𝒫(𝑥, 𝑤), 𝒱(𝑥)⟩ =
𝑏 ∈ {0, 1} depending on whether 𝒱 accepts, 𝑏 = 1, or rejects 𝑏 = 0.
Definition 2.1. The pair (𝒫, 𝒱) is called an argument of knowledge
for the relation ℛ if the following properties are satisfied.
Completeness: ∀(𝑥, 𝑤) ∈ ℛ, ⟨𝒫(𝑥, 𝑤), 𝒱(𝑥)⟩ = 1.
Soundness: For any PPT prover 𝒫∗, there exists a PPT extractor ℰ
such that, for any 𝑥, the probability
Pr[⟨𝒫(𝑥, 𝑤), 𝒱(𝑥)⟩ = 1 ∧ (𝑥, 𝑤) ∉ ℛ | 𝑤 ← ℰ𝒫∗(𝑥)]
is negligible, where the extractor ℰ𝒫∗ has access to the entire exe-
cution, including the randomness of 𝒫∗.
Definition 2.2. An argument of knowledge (𝒫, 𝒱) is public coin
if the verifier samples its messages uniformly at random and inde-
pendently of the messages sent by 𝒫. This is equivalent to say that
𝒱’s messages correspond to 𝒱’s randomness.
Definition 2.3. A public coin argument of knowledge is (honest
verifier) zero-knowledge for a relation ℛ if there exists a simulator 𝒮
such that, for any (𝑥, 𝑤) ∈ ℛ, the view of an honest verifier in the
interaction ⟨𝒫, 𝒱⟩ and the output of 𝒮 are indistinguishable, i.e.
view(⟨𝒫(𝑥, 𝑤), 𝒱(𝑥)⟩) ≈ 𝒮𝒱(𝑥),
where 𝒮𝒱 denotes access to the public coin randomness used by
the verifier.
2.2 Interactive Oracle Proofs
Interactive oracle proofs (IOPs) simultaneously extend probabilis-
tic checkable proofs (PCPs) and interactive proofs (IPs) by allowing
more rounds of interaction and using point-wise queries from the
verifier to the oracles, instead of linear queries. IOPs also differ
from IPCPs which can be viewed as special IOPs where the verifier
has oracle access to the first prover messages, but must read in full
subsequent prover’s messages.
Definition 2.4. A 𝜌-round public-coin IOP for the relation ℛ
consists of a 𝜌-round interactive protocol between 𝒫 and 𝒱, with
𝜌 ≥ 2, such that in each round 𝑖 ≥ 2, after an initial 𝜋1 created
by 𝒫, the verifier 𝒱 sends a uniformly random message 𝑣𝑖−1 to
𝒫 and the prover replies with 𝜋𝑖. The verifier has oracle access
to 𝜋 = {𝜋1, . . . , 𝜋𝜌} and 𝒫’s last message in response to 𝑣𝜌 and,
based on the responses from the oracles, either accepts or rejects.
It satisfies the following two properties:
Completeness: As in Definition 2.1.
Soundness: For all 𝑥 ∉ ℒ, and for all (computationally unbounded)
𝒫∗
Pr[⟨𝒫(𝑥, 𝑤), 𝒱𝜋 (𝑥)⟩ = 1] is negligible.
This definition can be extended with the knowledge and honest
verifier zero-knowledge properties [9]. Beyond soundness we can
consider other complexity measures, in particular the query com-
plexity, i.e. the number of queries asked by 𝒱 to any of the oracles
during the 𝜌 rounds, and the proof complexity, i.e. the number of
bits communicated during the interactions.
2.3 MPC-in-the-Head
In [28], Ishai, Kushilevitz, Ostrovsky and Sahai introduced the
MPC-in-the-Head (MPCitH) paradigm that uses any MPC protocol
with honest majority to construct a zero-knowledge proof for an
arbitrary NP relation ℛ. The high level idea of this powerful tech-
nique is as follows. A zero-knowledge protocol can be viewed as
an instance of secure function evaluation, and hence as two-party
computation between a prover 𝒫 and a verifier 𝒱, with common
input the statement 𝑥, and 𝒫’s private input 𝑤, which is a witness
to the assertion that 𝑥 belongs to a given NP language ℒ. The func-
tion they want to compute is then 𝑓𝑥 (𝑤) = ℛ(𝑥, 𝑤), which checks
if 𝑤 is a valid witness or not. The verifier 𝒱 will accept the proof if
𝑓𝑥 (𝑤) = ℛ(𝑥, 𝑤) = 1.
In the MPCitH paradigm the zk-PCP prover 𝒫 emulates an 𝑛-
party MPC protocol Π in “its head”: 𝒫 generates a sharing ⟨𝑤⟩
of the witness and distributes the corresponding shares as private
inputs to the parties, and then simulates the evaluation of 𝑓𝑥 (⟨𝑤⟩) =
ℛ(𝑥, ⟨𝑤⟩) by choosing uniformly random coins 𝑟𝑖 for each party
𝑃𝑖, 𝑖 ∈ [𝑛]. Once the inputs and random coins are fixed, for each
round 𝑗 of communication of the protocol Π and for each party 𝑃𝑖,
the messages sent by 𝑃𝑖 at round 𝑗 are deterministically specified
as a function of the internal state of 𝑃𝑖, i.e. 𝑃𝑖’s private inputs and
randomness, and the messages that 𝑃𝑖 received in previous rounds.
The set with the state and all messages received by party 𝑃𝑖 during
the execution of the protocol constitutes the view of 𝑃𝑖, denoted as
view𝑖.
After the evaluation, the prover sets 𝜋 = (view1, . . . , view𝑛) and
sends it to an oracle 𝒪. At this point, the verifier queries 𝜋 on some
points and finally verifies that the computation was done correctly
by checking that the opened views are all consistent with each
other and that the protocol outputs a positive result.
3 MPC-IN-THE-HEAD BASED IOP—GENERAL
CONSTRUCTION
In this section we describe a general interactive proof system
based on the MPC-in-the-Head paradigm which can be instanti-
ated with different MPC protocols that respect a specific network
topology. While IKOS [28] presents a general transformation of
information-theoretic MPC protocols to a ZK proof in a “black-
box” way, we follow Ligero’s blueprint and precisely define the
MPC model we use to build our system. We extend the general
proof system defined in [2] by allowing arbitrary number of rounds.
Then, we instantiate the MPC component with a different and yet
very simple protocol which will allow the verifier to open a bigger
number of views (or, equivalently, to query the oracles at a larger
number of points).
3.1 MPC Model
Here we describe the MPC model that can be used to implement
our general interactive proof system. This model can in turn be
instantiated with MPC protocols with different security properties,
leading to systems with different soundness, communication and
computational complexity.
First we recall the following basic definition.
Session 11B: Zero Knowledge II CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea3025Definition 3.1 (Correctness, privacy and robustness [28]). Let Π𝑓
be an MPC protocol for a functionality 𝑓 .
- We say that the protocol Π𝑓 realizes 𝑓 with perfect (resp.
statistical) correctness if for all inputs 𝑥, the probability that
the output of some party is different from 𝑓 (𝑥) is 0 (resp.
negligible in 𝜆), where the probability is over the random
inputs of each party.
- Let 1 ≤ 𝑡 < 𝑛, the protocol Π𝑓 has 𝑡-privacy if it is correct
and for all 𝐼 ⊆ [𝑛] such that |𝐼| ≤ 𝑡, there exists a PPT
algorithm 𝒮 such that the joints views (view𝐼 (𝑥)) of parties
in 𝐼 has the same distribution as 𝒮(𝐼, 𝑥𝐼 , 𝑓𝐼 (𝑥)). We will talk
of perfect, statistical or computational 𝑡-privacy accordingly.
- Let 0 ≤ 𝑟 < 𝑛, the protocol Π𝑓 has perfect (resp. statistical) 𝑟-
robustness if it is correct and for all 𝐼 ⊆ [𝑛] such that |𝐼| ≤ 𝑟,
even assuming that all the parties in 𝐼 have been adaptively
corrupted, if there does not exists any random input such
that 𝑓 (𝑥) = 1, then the probability that Π𝑓 outputs 1 and the
views of honest parties are consistent is zero (resp. negligible
in 𝜆).
We now describe our MPC model.
Definition 3.2 (Client-server 𝜌-phase protocol). Let Π𝑓 be an MPC
protocol for a functionality 𝑓 . We say that Π𝑓
is in the client-
server model if its parties can be divided into a distinguished “input
(sender) client” 𝑃𝑆, 𝑛 “computation servers” 𝑃1, . . . , 𝑃𝑛, and (option-
ally) a distinguished “output (receiver) client” 𝑃𝑅. Additionally, 𝑃𝑆
receives the entire input 𝑥 and only sends at most one message to
each of the computation servers at the beginning of each phase,1
and 𝑃𝑅 only receives a single message from each of the servers at
the end of the protocol. The servers can only communicate with
each other via a broadcast.
We then say that Π𝑓
is a client-server 𝜌-phase protocol if the
computation of the 𝑛 servers can be divided into 𝜌 consecutive
phases each separated by the sampling of a public random string
via a call to RandomCoin from all the servers.
The following three stages summarise the execution of a client-
server 𝜌-phase protocol.
(1) In the first phase, the servers receive the input message m1
from 𝑃𝑆 and start their local computation of the circuit. More
precisely, m1 is a vector of messages, where each server gets
one entry of the vector.
(2) For each phase 𝑗 ∈ [2, 𝜌 − 1]:
(a) The servers call RandomCoin and obtain a public random
string 𝑅 𝑗−1, along with at most a single message m𝑗 from
𝑃𝑆. Again, each party 𝑃𝑖 only receives (⟨m𝑗⟩)𝑖, for 𝑖 ∈ [𝑛].
(b) The servers use the random string (and m𝑗) to continue
their local computation.
(3) In phase 𝜌, the servers obtain a public random string 𝑅𝜌 and
each sends a single message to the receiver client 𝑃𝑅.
In our model we consider a threshold (𝑃𝑐, 𝑡𝑠)-adversary which
corrupts at most one client 𝑃𝑐, up to 𝑡𝑠 servers, or both. In particular,
we extend Definition 3.1 as follows.
1Ligero allows only one message from 𝑃𝑆 to the servers in the entire computation, i.e.
it cannot send another message even after the public coin sampling that takes place
between the two phases.
Protocol Π𝜌−ZKIOP
Let Π𝑓 a 𝜌-phase MPC protocol in the client/server model. Common
Input: A statement 𝑥 and a circuit description 𝐶𝑓 that realizes the
relation ℛ.
Private Input: 𝒫 holds the witness 𝑤 such that ℛ(𝑥, 𝑤) = 1
First Oracle 𝜋1. 𝒫 runs the MPC protocol Π𝑓 in its head: it samples
a random 𝑟𝑆 , {𝑟𝑖 }𝑖∈[𝑛] ∈ {0, 1}∗ ∪ ∅ and invoke the sender client 𝑃𝑆
on input (𝑥, 𝑤; 𝑟𝑆). and the servers on random input 𝑟𝑖. The prover
computes the views (view1
It sets the oracle 𝜋1 = (view1
Interactive protocol.
- For 𝑗 ∈ [2, 𝜌]:
𝑛) of the servers in phase 1.
1, . . . , view1
𝑛)
1, . . . , view1
- 𝒱 picks a random challenge 𝑅 𝑗−1 and sends to 𝒫
- 𝒫 continues to run the protocol in its head.
It invokes the sender client and the servers on input
𝑅 𝑗−1 obtained in the previous step and produces views
(view𝑗
1, . . . , view𝑗
1, . . . ,
𝑛).
view𝑗
𝑛). It sets the oracle 𝜋 𝑗 (𝑅 𝑗−1) = (view𝑗
- 𝒱 picks a random challenge 𝑅𝜌 and sends to 𝒫.
- 𝒫 computes and sends view𝑅 of the receiver client
- 𝒱 rejects if 𝑃𝑅 outputs 𝐶𝑓 = 0; if not, 𝒱 asks to open a subset
of server views. More precisely 𝒱 picks random subsets 𝑉𝑗 ⊂
[𝑛], 𝑗 ∈ [𝜌], such that | ∪𝑗 𝑉 | ≤ 𝑡𝑠,𝑝.
- 𝒫 open the views in ∪𝑗𝑉𝑗
- Final verification: 𝒱 aborts if the views in 𝑉𝑗 are inconsistent
with each other and/or with view𝑅, otherwise it accepts.
Figure 1: General description of the 𝜌-round IOP
Definition 3.3. We say that a protocol Π𝑓 realizes 𝑓 with (𝑃𝑐, 𝑡𝑠,𝑝)-
privacy (resp. (𝑃𝑐, 𝑡𝑠,𝑟)-robustness) if the properties in Definition 3.1
hold with respect to a semi-honest (resp. adaptive malicious) adver-
sary 𝒜 that corrupts all the parties in 𝐼 = {𝑃𝑐} × 𝐼𝑠 ⊂ {𝑃𝑆, 𝑃𝑅} ×
{𝑃𝑖}𝑖∈[𝑛], such that |{𝑃𝑐}| ≤ 1 and |𝐼𝑠| ≤ 𝑡𝑠,𝑝 (resp. 𝑡𝑠,𝑟 ).
Note that this definition allows (∅, 𝑡𝑠)-adversaries that only cor-
rupt server parties.
3.2 Interactive Proof System - General
Description
Given an MPC protocol Π𝑓 as described in Definition 3.2, we
show a 𝜌-round interactive protocol, Π𝜌−ZKIOP (Figure 1), verifying
the properties in Definition 2.4.
Let ℒ(ℛ) be an NP-language with relation ℛ, and let 𝑓𝑥 (𝑤) =
ℛ(𝑥, 𝑤). Our 𝜌-round systems starts with the prover 𝒫 emulating
a 𝜌-round MPC protocol Π𝑓 (meeting Definition 3.2 ) that real-
izes the functionality 𝑓 . As done in Ligero, we further restrict the
MPC model and assume that the servers 𝑃𝑖 never communicate
with each other. The first round of Π𝜌−ZKIOP provides to an or-
acle 𝒪 the string 𝜋1 = (view1
𝑛) , corresponding to the
views of the 𝑛 servers at the end of the first round. After this, we
have the interactive steps, which exactly correspond to the rounds
[2, 𝜌] of the underlying MPC protocol, with the randomness ob-
tained by the RandomCoin functionality being replaced by the veri-
fier’s challenges 𝑅1, . . . , 𝑅𝜌. We can pictorially represent the oracles
𝜋1, . . . , 𝜋𝜌 as a 𝜌 × 𝑛 matrix 𝑄, where the rows are 𝑄 𝑗 = 𝜋 𝑗 , 𝑗 ∈ [𝜌],
and the columns, 𝑄𝑖, 𝑖 ∈ [𝑛], correspond to the “global” view of the
parties, i.e. 𝑄𝑖 = {view1
1, . . . , view1
𝑖 }, for 𝑖 ∈ [𝑛].
𝑖 , . . . , view
𝜌
Session 11B: Zero Knowledge II CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea3026Note that if we instantiate Π𝜌−ZKIOP with 𝜌 = 1, we obtain the
system described in [2], which only allows one single message from
𝑃𝑆 to the servers 𝑃𝑖, 𝑖 ∈ [𝑛].
Restricting the model. We now specialize the MPC model Π𝑓 used
in Π𝜌−ZKIOP with a protocol achieving (𝑃𝑅, 𝑛 − 1)-privacy in the
semi-honest model and (𝑃𝑆, 0)-robustness in the malicious model.
In particular, this latter property means that the MPC protocol
does not allow any collusion between a malicious client sender and
servers.
Moreover, we restrict 𝒱’s queries (and hence also our IOP system)
to the columns of the matrix 𝑄, assuming that the verifier only
opens up to 𝑛 − 1 of these “global” views.
If we now consider the security of our construction, it is very
important to distinguish between the randomness used to ensure
privacy and that used for robustness. The former is generated by 𝒫
when it samples the randomness for the MPC parties. The latter is
given by 𝒱 and the crucial point is that each string generated in the
middle of the protocol must be unpredictable for 𝒫 during previous
phases. Intuitively, the prover 𝒫 can cheat either by “corrupting
𝑃𝑆” and computing the m𝑗 messages wrongly, or by “corrupting”
one or more of the servers 𝑃𝑖, 𝑖 ∈ [𝑛], and computing their message
to 𝑃𝑅 wrongly.
More formally, we obtain the following result.
Theorem 3.4. Let 𝑥 be a public statement and 𝑤 an additional
input, let 𝑓 be the functionality for 𝑃𝑆, 𝑃1, . . . , 𝑃𝑛 and 𝑃𝑅 that outputs
ℛ(𝑥, 𝑤) to 𝑃𝑅. Let Π𝑓 be a 𝜌-phase MPC protocol in the client/server
model that correctly realizes 𝑓 with (𝑃𝑅, (𝑛 − 1))-privacy in the semi-
honest model and (𝑃𝑆, 0)-robustness (in the malicious model) with
robustness error 𝛿. The protocol Π𝜌−ZKIOP described in Fig. 1 is a
ZKIOP for NP relation ℛ, with soundness error
(cid:18)
(cid:19)
.
1 − 1
The proof is given in the full version.
+ 𝛿
𝜖 =
1
𝑛
𝑛
A very common solution to achieve the desired soundness in
zero-knowledge systems, is to run the base protocol a certain num-
ber of times 𝜏. Obviously, this approach increases the complexity of
the system both computationally and in communication by a mul-
tiplicative factor 𝜏. In the next section we describe a better strategy
that allows to reach better soundness with less overhead.
3.3 Improving Soundness—More MPC
Evaluations
We improve the soundness of the IOP construction of Figure 1
by having multiple sets of server parties execute the underlying
MPC protocol in parallel. This improvement comes from the ability
to open multiple sets of 𝑛 − 1 views to the verifier, each picked
independently at random thus reducing the limiting 1/𝑛 term of
Theorem 3.4.
By having the public randomness of RandomCoin shared across