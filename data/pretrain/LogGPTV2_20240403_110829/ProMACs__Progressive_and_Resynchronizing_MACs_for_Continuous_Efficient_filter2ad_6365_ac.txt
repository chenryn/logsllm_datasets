and so on.
Definition 4.2 (Area of Dependency). Consider a ProMAC with an
update function Upd. We say that Upd has (ğ‘¢ + 1)-independence if
the following holds: for any state ğ‘  âˆˆ S, any key ğ‘˜ given by Gen,
and any packets ğ‘š2, . . . , ğ‘šğ‘¢+1, there exists a state ğ‘ â€², such that
Updğ‘¢+1
(ğ‘ , ğ‘šâ€², ğ‘š2, . . . , ğ‘šğ‘¢+1) = ğ‘ â€² âˆ€ğ‘šâ€² âˆˆ M.
(2)
The Area of Dependency of Upd, denoted by ad(Upd), is defined to
be smallest ğ‘¢ such that Upd has ğ‘¢ + 1-independence. If all previous
packets might impact the current state, we write ad(Upd) = âˆ.
ğ‘˜
Note that this definition requires that the condition must hold for
any state ğ‘  and is not restricted to states sampled by Init. The intent
of this definition is that an update function Upd with ad(Upd) = ğ‘¢
has the property that the current state is independent from the
(ğ‘¢ + 1)th-last packet. Consequently, each state depends on (at most)
last ğ‘¢ packets, the initial state, and the current index, as we show
next:
Proposition 4.3. Consider a ProMAC with an update function
Upd with ad(Upd) = ğ‘¢. Let ğ‘– > ğ‘¢ and
Updğ‘–
ğ‘˜(ğ‘ 0, ğ‘š1, ğ‘š2, . . . , ğ‘šğ‘–) = ğ‘ ğ‘– .
(3)
for some arbitrary initial state ğ‘ 0 given by Init, arbitrary key ğ‘˜ given
by Gen, and arbitrary packets ğ‘š1, . . . , ğ‘šğ‘–. Then, it holds that ğ‘ ğ‘– and
all follow-up states ğ‘ ğ‘–+1, ğ‘ ğ‘–+2, . . . are independent from the content
of the packets ğ‘š1, . . . , ğ‘šğ‘–âˆ’ğ‘¢. In other words, the current state ğ‘ ğ‘– can
depend only on the initial state, the key, the last ğ‘¢ âˆ’ 1 packets and
the index ğ‘–. That is, the current state is independent of the last-but-ğ‘¢
packets, and depends only on the initial state and the last ğ‘¢âˆ’1 packets
(or less).
Proof. We show the claim by induction over ğ‘–.
Now let ğ‘— â‰¥ 1 be arbitrary. Since ğ‘ ğ‘–+ğ‘— = Updğ‘—
this state is independent from from ğ‘š1 as well.
Let ğ‘– := ğ‘¢+1. Following Definition 4.2, ğ‘ ğ‘– is independent from ğ‘š1.
ğ‘˜(ğ‘ ğ‘–, ğ‘šğ‘–+1, . . . , ğ‘šğ‘–+ğ‘—),
Now assume that the claim holds for some ğ‘– â‰¥ ğ‘¢+1, i.e., all states
ğ‘ ğ‘–, ğ‘ ğ‘–+1, . . . are independent from packets: ğ‘š1, . . . , ğ‘šğ‘–âˆ’ğ‘¢. It suffices
to show that states: ğ‘ ğ‘–+1, . . . are independent from ğ‘šğ‘–âˆ’ğ‘¢+1. The fact
that ğ‘ ğ‘–+1 is independent from ğ‘šğ‘–âˆ’ğ‘¢+1 follows from Definition 4.2
(note that the definition is not restricted to states sampled by Init)
and the fact that ğ‘ ğ‘–+2, . . . are independent from ğ‘šğ‘–âˆ’ğ‘¢+1 can be shown
as above for ğ‘– = ğ‘¢ + 1.
â–¡
A consequence of Proposition 4.3 is that for each ğ‘– â‰¥ 1, there
exists a procedure Upd[ğ‘–], such that for all initial states ğ‘ 0 given
by Init, all keys ğ‘˜ given by Gen, and all packets ğ‘š1, . . . , ğ‘šğ‘–, it holds
that:
ğ‘˜(ğ‘ 0, ğ‘š1, . . . , ğ‘šğ‘–) = Upd
[ğ‘–]
ğ‘˜ (ğ‘ 0, ğ‘–, ğ‘šmax{1,ğ‘–âˆ’ğ‘¢+1}, . . . , ğ‘šğ‘–).
(4)
Updğ‘–
That is, Upd[ğ‘–] gets as input only the initial state ğ‘ 0, the index ğ‘–,
and the last ğ‘¢ âˆ’ 1 packets (or less if ğ‘–  ğ‘¢.
ğ‘– â‰¤ ğ‘¢: The attacker sends a query ğ‘„ := [ğ‘ , ğ‘–, ğ‘š1, . . . , ğ‘šğ‘–] âˆˆ S Ã—
N Ã— Mğ‘– to O where N denotes the set of positive integers
and ğ‘  is some initial state. The oracle O first computes ğ‘ â€² :=
Updğ‘–âˆ’1
(ğ‘ , ğ‘š1, . . . , ğ‘šğ‘–âˆ’1) where we set ğ‘ â€² := ğ‘  in case of ğ‘– = 1.
Afterwards, it computes ğ‘¡ := Sigğ‘˜(ğ‘ â€², ğ‘šğ‘–), appends it to ğ‘„,
and returns ğ‘¡ to A.
ğ‘– > ğ‘¢: The attacker sends a query ğ‘„ := [ğ‘ , ğ‘–, ğ‘š1, . . . , ğ‘šğ‘¢] to O. The
oracle determines ğ‘ â€² := Upd
(ğ‘ , ğ‘š1, . . . , ğ‘šğ‘¢âˆ’1) and then
ğ‘¡ := Sigğ‘˜(ğ‘ â€², ğ‘šğ‘¢). Finally, it appends ğ‘¡ to the query ğ‘„ and
returns ğ‘¡ to the attacker.
In both cases, the sequence ğ‘„ is inserted into Q, i.e., Q := Q âˆª {ğ‘„}.
We call the elements stored in Q the query sequences.
Eventually, the attacker A outputs potential forgery, in the form
of a sequence: ğ‘„âˆ— := [ğ‘ âˆ—
ğ‘Ÿ ] for ğ‘Ÿ â‰¥ 1. The attacker
wins the game if the tags are accepted while not all of them have
been previously queried in this form by the attacker. To make â€œin
this formâ€ more precise, we need to take a look at all subsequences
from ğ‘„âˆ—. These are defined as follows, where ğ‘¢ := ad(Upd):
ğ‘¢, ğ‘¡âˆ—
ğ‘¢],
1, . . . , ğ‘šâˆ—
1, . . . , ğ‘šâˆ—
[ğ‘¢âˆ’1]
ğ‘˜
0, ğ‘šâˆ—
1, ğ‘¡âˆ—
ğ‘˜
ğ‘Ÿ , ğ‘¡âˆ—
0, 1, ğ‘šâˆ—
Qâˆ— := {[ğ‘ âˆ—
1, ğ‘¡âˆ—
[ğ‘ âˆ—
0, ğ‘¢ + 1, ğ‘šâˆ—
[ğ‘ âˆ—
0, ğ‘Ÿ, ğ‘šâˆ—
0, ğ‘¢ âˆ’ 1, ğ‘šâˆ—
ğ‘¢+1, ğ‘¡âˆ—
ğ‘¢+1], . . . ,
ğ‘Ÿ , ğ‘¡âˆ—
ğ‘Ÿ ]}.
2The case of ad(Upd) = âˆ will be discussed at the end.
1], . . . , [ğ‘ âˆ—
2, . . . , ğ‘šâˆ—
ğ‘Ÿâˆ’ğ‘¢+1, . . . , ğ‘šâˆ—
We call the elements of Qâˆ— the forgery sequences. Note that for each
Qâˆ— that also appears in Q, it holds that the attacker already knew
that this combination of initial state, index, and packets leads to
the respective tag. Thus, the attacker wins if at least one of these
forgery sequence has not been asked before, i.e., is not equal to a
query sequence stored in Q. We denote forgery sequences that are
not part of Q as fresh forgery sequence. Thus, the winning condition
can be reformulated to mean that an attacker produces a packet
stream with associated tags, such that: (i) all tags are accepted, and
(ii) at least one forgery sequence is fresh, i.e., Qâˆ— âŠˆ Q.
We define a progressive MAC to be (ğ‘, Î”, ğœ–)-secure if no adver-
sary that makes at most ğ‘ Sig-queries can succeed in the above
experiment to generate Î” fresh forgery sequences with probability
above ğœ–, i.e.,
ğ‘ƒğ‘Ÿ [A wins] â‰¤ ğœ€.
(5)
We say that the scheme is (ğ‘, ğœ–)-secure if the attacker can freely
choose the number Î” â‰¥ 1 of fresh sequences.
The Case of ad(Upd) = âˆ. The treatment of the case ad(Upd) =
âˆ is quite similar. In a nutshell, the difference is that the queries
contain all ğ‘– packets and not the last ğ‘¢ packets only. For instance,
the forgery sequences are [ğ‘ âˆ—
ğ‘– ] for ğ‘– = 1, . . . , ğ‘Ÿ.
1, . . . , ğ‘šâˆ—
0, ğ‘–, ğ‘šâˆ—
ğ‘– , ğ‘¡âˆ—
4.4 Relation to Classical MACs and
Duplex-based Constructions
Before discussing concrete ProMACs instantiations of ProMACs in
the next section, we note that the definition (including the notion
of security) extends the concept of classical MACs that operates on
M and also stateful MACs as duplex-based constructions.
essentially ignoring the internal state. That is we set S = {ğ‘ 0} for
some dummy value ğ‘ 0 and define Updğ‘˜(ğ‘ 0, ğ‘š) := ğ‘ 0 for any packet
More precisely, let (cid:101)ğ‘€ denote a classical MAC with algorithms
(cid:101)ğ‘€.Gen, (cid:101)ğ‘€.Sig, and (cid:101)ğ‘€.Vrfy. We define a ProMAC ğ‘€ based on (cid:101)ğ‘€ by
ğ‘š. Finally, we set ğ‘€.Gen := (cid:101)ğ‘€.Gen, ğ‘€.Sigğ‘˜(ğ‘ 0, ğ‘š) := (cid:101)ğ‘€.Sigğ‘˜(ğ‘š),
and ğ‘€.Vrfyğ‘˜(ğ‘ 0, ğ‘š, ğ‘¡) := (cid:101)ğ‘€.Vrfyğ‘˜(ğ‘š, ğ‘¡) for all keys ğ‘˜ and all packets
equivalent to (cid:101)ğ‘€.
ğ‘š. Note that ad(Upd) = 1, i.e., current state depends only on the
current packet. Consequently, all query sequences stored during
the security game have the form [ğ‘ 0, ğ‘š, ğ‘¡] where ğ‘ 0 can be ignored.
Thus, both the working principle and security of ğ‘€ is effectively
On the other hand, if we set ad(Upd) = âˆ, i.e., each tag de-
pends on all packets so far, we have a stateful MAC similar to the
duplex-based constructions. In that sense, ProMACs can be seen as
a tradeoff between both constructions.
Finally, we stress that a ProMAC can be expressed as a classical,
deterministic MAC with packets of the form: [ğ‘ , ğ‘–, ğ‘š1, . . . , ğ‘šmin{ğ‘¢,ğ‘–}]
(see Definition of Sig-queries in Section 4.3.3). In particular, for each
such query the resulting tag there exists exactly one tag. Using
the notions and arguments from [5] (which also considers MACs
that operate on packets of varying lengths), it follows that: (i) the
security definition given in Section 4.3 captures SUF-1 (strong un-
forgeability with single access to a verification algorithm), and (ii)
SUF-1 implies SUF-m (strong unforgeability with multiple access
to a verification algorithm). Therefore, it is unnecessary to define
verification queries in the security game.
ğ‘¡ğ‘–
sig
ğ‘˜â€²â€²
ğ¹
ğ‘šğ‘–
]
ğ‘¢
,
ğ‘–
[
Ëœğ‘ 
ğ‘–
ğ‘ 
0
Ëœğ‘ 
upd
ğ‘˜â€²
ğ¹
++
ğ‘–
ğ‘¡ğ‘–+1
sig
ğ‘˜â€²â€²
ğ¹
ğ‘šğ‘–+1
]
ğ‘¢
,
1
+
ğ‘–
[
Ëœğ‘ 
1
+
ğ‘–
ğ‘ 
0
Ëœğ‘ 
upd
ğ‘˜â€²
ğ¹
++
1
+
ğ‘–
0
Ëœ
ğ‘ 
ğ‘–
Figure 3: Core concept of the ProMAC instantiation Whips, with state update Upd and tag generation Sig realised through one
PRF each.
5 WHIPS
In this section, we present a concrete ProMACs instantiation, dubbed
sig
Whips 3. It uses two pseudorandom functions (PRFs) ğ¹
ğ‘˜â€²â€²
as building blocks and allows one to freely choose the tag size. This
makes them compelling candidates for wireless communication.
To achieve high bandwidth efficiency, the practical constructions
employ a small tag space, i.e., the tag length ğœ is small (which re-
sembles simple truncation). Moreover, it allows re-synchronization
after ğ‘¢ packets.4 To this end, the current state is composed of a
counter and ğ‘¢ so-called substates where one packet determines one
substate.
and ğ¹
upd
ğ‘˜â€²
5.1 Specification
We start by defining the sets:
â€¢ M := {0, 1}ğœ‡ - the packet space
â€¢ K := {0, 1}ğœ…upd+ğœ…sig - the key space
â€¢ S := {0, 1}ğ›¾+(ğ‘¢+1)Â·ğœ - the state space with ğ›¾ being the length
â€¢ T := {0, 1}ğœ - the tag space
of a counter and ğœ being the length of substates
Whips maintains internal state ğ‘ ğ‘– composed of: counter ğ‘–, initial
substate Ëœğ‘ 0 âˆˆ {0, 1}ğœ, and ğ‘¢ previous substates Ëœğ‘ ğ‘–âˆ’ğ‘¢, . . . , Ëœğ‘ ğ‘–âˆ’ğ‘¢ âˆˆ
{0, 1}ğœ. To simplify the description, we define the term Ëœğ‘ [ğ‘–,ğ‘¢] âˆˆ
{0, 1}ğ‘¢Â·ğœ for ğ‘– â‰¥ 0 as:
Ëœğ‘ [ğ‘–,ğ‘¢] :=
(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)
Ëœğ‘ ğ‘–âˆ’ğ‘¢+1, Ëœğ‘ ğ‘–âˆ’ğ‘¢+1, . . . , Ëœğ‘ ğ‘–
Ëœğ‘ 0, . . . , Ëœğ‘ 0
ğ‘¢âˆ’(ğ‘–+1) times
, Ëœğ‘ 0, Ëœğ‘ 1, . . . , Ëœğ‘ ğ‘–
, ğ‘– âˆ’ ğ‘¢ + 1 â‰¥ 0
, else
.
(6)
Using this, internal state is defined as:
ğ‘ ğ‘– = (ğ‘–, Ëœğ‘ 0, Ëœğ‘ [ğ‘–,ğ‘¢]),
(7)
where ğ‘ 0 is the initial state. In each round, the next packet ğ‘šğ‘–+1 is
processed to compute: (i) the next state ğ‘ ğ‘–+1, and (ii) the next tag
sig