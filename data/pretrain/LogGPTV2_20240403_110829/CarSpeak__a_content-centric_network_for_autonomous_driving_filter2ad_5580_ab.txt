perception modules and publishes a global map incorporated
with locations of obstacles.
◦ Path planner subscribes to the vehicle’s location and the global
obstacle map and publishes a path for the vehicle to travel along.
Figure 4—Information Flow in CarSpeak. CarSpeak has three
components: A Multi-Resolution Naming and Addressing system,
A Loss-Resilient Compression system and a Content-Centric MAC
• Controller: The controller subscribes to the vehicle’s path and
issues steering and velocity-control commands to the vehicle, so
that it navigates along the computed path. In many cases, the con-
troller may execute emergency maneuvers if there is substantial
change in the obstacle map due to moving obstacles.
4. CARSPEAK’S ARCHITECTURE
CarSpeak’s design aims to interface effectively with the ROS
(Robotic Operating System) architecture for autonomous vehicles.
From the perspective of the ROS planner, CarSpeak looks like a lo-
cal sensor that streams sensory information obtained from other ve-
hicles and static infrastructure sensors.1 CarSpeak receives requests
from the car’s planner by subscribing to /query_region topic. It
propagates these requests over the network to CarSpeak modules
on other vehicles to direct them to transmit information from the
requested region. When it receives sensory data in response to re-
quests it sent, like other sensors, CarSpeak publishes this data as a
stream of 3D point-cloud data (under the topic /car_speak). The
planner may now subscribe to the information from the requested
regions. Unless refreshed, a subscription (as well as the correspond-
ing requests broadcast on the medium) expires after one minute.
Timing out subscriptions is done for efﬁcient use of bandwidth as
cars are expected to lose interest in some regions and gain interest
in others, as they move around.
CarSpeak’s guarantees are best effort, i.e. CarSpeak aims to
make the best use of the available bandwidth to send as much
relevant information as possible, in a loss-resilient manner. Car-
Speak has three components: A Content-Centric MAC, a Multi-
Resolution Naming and Addressing system, and a Loss-Resilient
Compression system. Fig. 4 illustrates how these components in-
teract with each other, the planner, and the wireless channel.
The MAC receives region requests from the planner and broad-
casts these requests on the medium. It also keeps track of requests
received from other cars over the wireless medium. It evaluates the
importance of different regions based on how many requests they
have recently received and tries to satisfy these requests by working
with the other CarSpeak components.
The multi-resolution naming and addressing system subscribes
to 3D-point cloud information published by local sensors and builds
an Octree-representation of this data. The Octree is read by the
compression module whenever CarSpeak sends data packets in re-
sponse to outside requests, and is written by the compression mod-
ule whenever CarSpeak receives data packets in response to re-
quests generated by the car. The multi-resolution naming and ad-
1Sharing information requires a notion of trust. One option is to use the
IEEE 1609.2 security standard for inter-vehicular networks to digitally sign
and verify all messages. However, the details are beyond the scope of this
paper.
Sensor 1Sensor 2Sensor nPerceptionMappingLocalizationPathPlannerControllerSensor DataGlobal MapVehicleStatePathgear, speed, steering  anglesensorsMulti-resolutionNamingLoss-resilientCompressionContent-CentricMACWireless MediumPlannerControllerVehicleSensorDataR/W  OctreeRegion IDPacketsData packetsRequestsPointCloud DataRequestsPathCommandCarSpeakdressing system also publishes updates to the Octree caused by
the arrival of external data as a 3D-point cloud under the topic
/car_speak, which is subscribed to by the planning system of the
autonomous vehicle.
The loss-resilient compression is triggered by the MAC to gen-
erate compressed data packets for transmission on the medium or
to decode received data packets and insert them in the Octree.
In the following sections, we discuss the design and functioning
of each of these modules in more detail.
5. MULTI-RESOLUTION NAMING
In autonomous vehicles, sensory information is typically repre-
sented as a 3D-point cloud. The point-cloud representation however
is unstructured, and hence does not facilitate requesting information
about a speciﬁc region. It is also inefﬁcient because it does not com-
press the information by leveraging the fact that points close to each
in space other tend to have similar properties: empty or occupied.
Sharing information across vehicles requires a naming scheme in
which a car can name a speciﬁc region of interest. It also requires
an efﬁcient representation that compresses the exchanged data and
reduces bandwidth consumption.
5.1 Information Naming and Representation
CarSpeak uses the Octree naming system to identify and repre-
sent sensor information from the environment. Speciﬁcally, CarS-
peak divides the world recursively to cubes. It starts with a known
bounding cube that encompasses all points observed by vehicles in
the environment. Thus this bounding cube, or root cube, is known
and agreed upon by all vehicles . Each cube is then recursively di-
vided into 8 smaller cubes as shown in Figure 5. A cube is set to
be either: (1) occupied, if the point cloud representation has points
within it (i.e., the cube has some object and the car should not drive
through it); (2) unoccupied, if there are no points within it (i.e., the
cube is vacant and the car may drive through it); and (3) unknown if
there is no sufﬁcient sensory information about it (i.e., the cube may
have some object but the car does not yet have sensor data to iden-
tify it). We note that a parent is occupied if any of its descendants
are occupied. A parent is unoccupied only if all of its descendants
are unoccupied. Otherwise the parent is unknown.
CarSpeak maintains this recursive structure in an Octree, where
each vertex in the Octree represents a cube, and the sub-tree rooted
at that vertex refers to the recursive divisions of the cube. The Oc-
tree representation allows CarSpeak to name road regions at dif-
ferent resolutions and according to their locations in the world.
Speciﬁcally, in CarSpeak a region is an encompassing cube, which
is nothing but a sub-tree in the Octree, truncated to L levels, where
L is the resolution at which the region is described. In principle, one
can allow regions of any size to have any resolution. This would al-
low a car to request the whole world at the ﬁnest resolution. Such a
design is both inefﬁcient and unnecessary.
Thus, CarSpeak expresses large regions at coarse resolutions and
smaller regions at ﬁner resolutions. Speciﬁcally, CarSpeak parti-
tions the Octree into mutually disjoint sub-trees, where each sub-
tree is truncated to L levels. Each of these truncated sub-trees de-
notes a region and forms a hierarchy, as shown in Fig. 5. All regions
are described completely by their corresponding truncated sub-tree,
which contain up to 8L − 1 vertices, labeled either “occupied”, “un-
occupied”, or “unknown”. Regions at a higher-level in the hierar-
chy provide a zoom-out view and are represented at a coarser spa-
tial granularity, whereas regions at a lower level in the hierarchy
provide a zoom-in view and are represented at a ﬁner spatial granu-
larity. A key point to note is that truncated sub-trees corresponding
to any pair of regions, regardless of their hierarchy, do not overlap.
Figure 5—Naming Regions in CarSpeak. The ﬁgure on the left
shows four different regions at different hierarchies with L = 2. The
ﬁgure on the right depicts the truncated sub-trees corresponding to
these regions in the Octree.
To assign regions globally unique names, we number them in
ascending order in a top-down, breadth-ﬁrst manner starting from
the region containing the root of the Octree (that provides a coarse
view of the entire environment). The number of regions and L are
design parameters that can be chosen to ﬁt the speciﬁc application.
Beneﬁts: CarSpeak Octree-based naming system has two advan-
tages. First, it facilitates requesting and accessing sensory data at
different resolutions. Second, it compresses the data both for stor-
age and transmission. In particular, while the world may be huge,
each vertex need not expand regions that are far from its location.
Further, when exchanging information, a large subtree can be sent
as one vertex if all vertices in the subtree have the same value (e.g.,
if a whole subtree has occupied vertices, CarSpeak sends a single
value expressing the fact that the whole subtree is occupied).
5.2
Information Retrieval and Maintenance
The multi-resolution naming and addressing module subscribes
to information from local sensors and incorporates this data into its
Octree. It also populates its Octree using sensor data received from
other vehicles over the wireless medium. This octree provides infor-
mation to other nodes that may failed to obtain it from the original
sender due to packet loss or disconnectivity. Further, it publishes the
data it receives from other vehicles through the topic /car_speak
after converting it to the 3D point cloud representation. (Note that
data from local sensors is already published by the sensors them-
selves.)
Garbage Collection. Each vertex of the the Octree data-
structure is annotated with a time_stamp ﬁeld that is set to the
timestamp of the most recent sensor information stored in this cube.
CarSpeak runs a thread to periodically traverse the Octree and re-
moves vertices which are outdated. If time_stamp is older than the
current time by over a ﬁxed threshold, then the entire sub-tree is
dropped. We note that in CarSpeak, all cars use NTP to synchro-
nize their time to within tens of milliseconds, which is sufﬁcient
for the purpose of the application.
5.3
Information Quality
The 3D stream of a region contains data from multiple nodes that
sense that region. On average, for each region, CarSpeak aims to
provide each node a share of the medium proportional to the quality
of information it possesses about that region. Let Q(i, r) denote the
quality of information that node i has regarding region r. CarSpeak
evaluates this function based on the following metrics:
• Time: Sensor information gathered more recently is of greater
value, than sensor information gathered in the past. CarSpeak de-
creases the quality of sensor information Q(i, r) based on delay,
by a factor of µ(tcurr−tsense); where tcurr is the current timestamp,
L Regions Octree tsense denotes the timestamp at which sensor information was last
obtained from the region and 0 < µ < 1 is a constant.
• Completeness: The more complete the information a node has
about a region, the higher the value of its information. Hence,
CarSpeak linearly increases the quality of sensor information
based on its completeness, i.e., Q(i, r) ∝ C(i, r), where C(i, r) is
a measure of completeness of information that node i possesses
about region r. The Octree presents an effective metric for mea-
suring C(i, r). Let C(i, r) denote the number of vertices not la-
beled unknown in the section of the Octree, possessed by node i,
representing region r divided by the number of possible vertices
in region r. Hence, C(i, r) represents the fraction of region r that
node i has sensed.
Thus, CarSpeak’s multi-resolution naming and addressing sys-
tem on node i keeps track of the quality of sensor information,
Q(i, r), possessed by its node for each region r, as:
Q(i, r) = C(i, r)µ(tcurr−tsense),
(1)
where tsense, tcurr, and C(i, r) are as deﬁned above and 0 < µ < 1 is
a constant (µ = 0.5 in our implementation).
6. LOSS-RESILIENT COMPRESSION
3D streams of region data are highly redundant. The informa-
tion at each node is correlated because occupied cubes tend to be
co-located. The same applies to unoccupied and unknown cubes.
Further, different nodes that sense the same region may have over-
lapping information (though the overlap is typically not complete
due to differences in perspective and viewing distances). Thus, efﬁ-
cient transmission requires compressing the data. A good compres-
sion scheme however should deal with the following issues: 1) The
compression algorithm should have a low computational overhead
to maintain the realtime nature of the data; 2) It should not require
the cars to track how their information relate to each other; and 3) It
should be resilient to packet loss. We describe how CarSpeak meets
these requirements below.
State-of-the-art compression schemes in the graphics community
for 3D-point clouds leverage the fact that the corresponding Octrees
can be efﬁciently encoded to provide a compressed high-entropy
representation [28, 11]. Similarly, CarSpeak exploits this compres-
sion capability of the Octree.
The standard Octree encoding technique is as follows: Let each
vertex in the Octree be represented by a tuple of length 8 represent-
ing the occupancy of each of its children. We traverse the tree in a
top-down and breadth-ﬁrst fashion and read off the corresponding
tuples to obtain the compressed data. The root vertex can always be
assumed to be occupied. Then, for each vertex, its occupied and un-
known children are recursively encoded. In contrast, no further in-
formation needs to be encoded for unoccupied vertices (as they are
assumed to be entirely unoccupied). Additionally, vertices whose
descendants are entirely occupied or unknown are terminated by a
special 8-tuple (with all entries marked occupied or unknown re-
spectively) and are not further encoded, as shown in Fig. 6. The de-
coder can then faithfully recover the Octree by following the same
traversal rules as the encoder.
This algorithm is very efﬁcient since it simply walks the Octree
representation. The problem however with using traditional Octree
compression is that the loss of even a single byte in the Octree rep-
resentation affects the correctness of all data following that byte.
Consequently, Octree based compression frameworks are highly
sensitive to packet loss. Furthermore, the above algorithm cannot
deal with data overlap across nodes that sense the same region.
We introduce a new algorithm that leverages the above standard
Octree compression, but deals with packet loss and overlap. Specif-
Figure 6—Octree Representation Representation of 3D-point
cloud using a 2-level Octree. Vertices that are unoccupied are not
expanded; vertices that are completely occupied or unknown are
terminated by special leaf vertices; these have been omitted for clar-
ity.
Figure 7—Picking tree T for compression Tree T picked with j
initialized to 0 is highlighted by red contours.
within the maximum size of a packet.
the way up to the root of Or.
ically: Let r be the region from which a packet is requested by the
Content-Centric MAC. Let Or denote the truncated sub-tree in the
Octree corresponding to this region. Let v0, v1, . . . , vK−1 denote the
leaf vertices of this sub-tree. The algorithm to generate a packet
proceeds as follows: Let variable j be set to a random integer be-
tween 0 and K − 1, and variable T be set to an empty tree.
(1) Add vertex vj to the tree T as well as all its ancestors tracing all
(2) Set j ← j + 1 and repeat step (1), while the encoding of T ﬁts
The algorithm writes the Octree encoding of T to a packet and
transmits it. Note that all packets are not generated in one shot, i.e.
even if two packets are describing the same region, the one with
the more recent time stamp will have more current information. As
nodes pick different random seeds, it is highly probable that differ-
ent nodes that sense the same region do not transmit overlapping
information, at any point in time.
The compression algorithm can be further improved by using
predictive coding techniques [28, 11] as the sub-graph T preserves
edges between parents and children in the original Octree Or (Our
current implementation however does not use predictive coding).
The resulting compression algorithm has the following desirable
properties: 1) it is computationally efﬁcient because it is linear in
the size of the region’s Octree; 2) it is robust to losses because each
packet is self-contained; 3) packets received from different cars that
sense the same region have minimal overlap because at any point
in time, they transmit different parts of the region’s Octree; and 4)
it supports a form of unequal error protection because the transmit-