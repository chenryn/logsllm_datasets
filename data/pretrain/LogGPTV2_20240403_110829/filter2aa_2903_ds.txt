（编译为(void) 0）。
合理地使用调试信息输出有利于提高软件的可调试性，但应该注意
以下几点。
因为可能有很多个进程和线程都向调试器输出调试信息，使得很多
信息混杂在一起，并且难以辨认，所以输出调试信息时应该附加上
必要的上下文信息（线程、函数名等），以提高信息的价值。
合理安排输出信息的代码位置，认真选择要输出的内容（变量值、
位置等），不要输出含糊不清的信息。要适当控制输出信息的数
量，如果输出的信息太多，有时反而适得其反。例如，在手机等嵌
入式设备的开发中，输出的信息通常显示在很小的屏幕上，新的信
息会将旧的信息覆盖掉，所以，如果输出的信息过于频繁，那么有
用的信息很可能被后来没什么价值的信息所掩盖掉。
因为调试信息输出通常是不保存的，而且TRACE宏在发布版本中
是自动移除的，所以不能因为输出调试信息而忽视了记录日志。
在软件的架构设计阶段，应该根据软件产品的实际情况选择合适的
方法，并将决定写入项目的开发规范中。
16.2.3 转储
所谓转储（dump）就是将内存中的软件状态输出到文件或者其他
设备（如屏幕等）上。常见的转储有以下几种。
对象转储，对某个内存对象的状态（属性值）进行转储。
应用程序转储，对应用程序用户空间中的关键状态信息进行转储，
包括每个线程的栈、进程的环境信息、进程和线程的状态等。使用
Windows的MiniDumpWriteDump API可以很方便地将一个进程的当
前状态转储到一个文件中。当应用程序发生严重错误时，系统会自
动为其产生转储文件，但是也可以在其他时候产生转储，产生转储
并不意味着程序就要终止（本书后续分卷将详细讨论该内容）。
系统转储，即对整个系统的状态进行转储，比如发生蓝屏时所产生
的转储（详见本书后续分卷）。
可以把转储视为软件的拍照，它记录了被转储对象在转储那一瞬间
的真实情况。完全的系统转储包含了内存中的所有数据，可以为调试提
供丰富的信息。转储的另一个有用特征就是它可以将某一瞬间的状态永
远保存下来，然后发送和传递到任何地方，这对于产品期调试和那些无
法亲临现场进行调试的情况非常有价值。另外，转储操作非常适合软件
来自动生成，因此，在设计崩溃处理或自动错误报告功能时可以将其作
为收集错误现场的一种方法。
MFC的基类CObject定义了Dump方法用于实现对象转储，该方法的
默认实现如下。
void CObject::Dump(CDumpContext& dc) const
{
    dc m_lpszClassName  dd 0019fee8 L1
0019fee8  0019ff40
结果是0019ff40，那么地址0019ff40就是上一个函数（Main函数）
的栈帧基准地址。依此类推，可以逐级找到前一个函数的栈帧。
0019fee8 004011b4 LocalVar!FuncC
0019ff40 00401509 LocalVar!main+0x34
0019ff80 761d8674 LocalVar!mainCRTStartup+0xe9
0019ff94 777a4b47 KERNEL32!BaseThreadInitThunk+0x24
0019ffdc 777a4b17 ntdll!__RtlUserThreadStart+0x2f
0019ffec 00000000 ntdll!_RtlUserThreadStart+0x1b
影响栈回溯的一个因素就是帧指针省略，即通常所说的FPO。因为
在栈上保存帧指针至少需要执行一条压入操作（push ebp），所以作为
一项优化措施，编译器在编译某些短小的函数时，可能不更新EBP寄存
器，不为这个函数建立独立的栈帧。对于这样被FPO优化的函数，尽管
栈上还有它的返回地址信息和可能的局部变量等数据，但是由于它的栈
帧基准地址没有保存到栈上，也没有EBP寄存器指向它，所以就给栈回
溯带来了困难。这时就需要符号文件中FPO数据的帮忙，否则关于这个
函数的调用就会被跳过。不过，因为现代CPU的强大性已经大大淡化了
FPO优化的意义，所以很多新的软件都不再启用这种优化方法，这使得
因为FPO带来的栈回溯问题会慢慢减少。
了解了上面的知识后，可以归纳出栈回溯的基本算法。该算法的具
体步骤如下。
（1）取得标识线程状态的上下文（CONTEXT）结构。当有异常发
生时，系统会创建这样的结构记录发生异常时的状态。使用
RtlCpatureContext和GetThreadContext API可以在没有发生异常时取得线
程的CONTEXT结构。
（2）通过CONTEXT结构或直接访问寄存器，取得程序指针寄存器
（EIP）的值，通过它可以知道线程的当前执行位置。然后搜索这个位
置附近的符号（SymFromAddr），可以知道所在函数的名称。
（3）通过CONTEXT结构或者直接访问寄存器取得当前栈帧的基准
地址，在x86系统中，如果没有使用FPO，那么EBP寄存器的值就是栈帧
基准地址。
（4）栈帧基准地址向上偏移一个指针宽度（对于32位系统，是4字
节）的位置是函数的返回地址。紧接着便是放在栈上的参数，具体个数
因为函数原型和调用规范而不同。
（5）搜索函数返回地址的邻近符号，可以找到父函数的函数名对
应的源文件名等信息。
（6）当前栈帧基准地址处保存的是前一个栈帧的值，取出这个值
便得到上一个栈帧的基准地址，回到第（4）步循环，直到取得的栈帧
基准地址等于0。
根据上面的算法，可以自己编写代码来实现栈回溯，也可以借助
Windows的API。下面分别介绍使用DbgHelp函数和RTL函数的方法。
16.3.2 利用DbgHelp函数库回溯栈
DbgHelp系列的函数是Windows平台中用来辅助调试和错误处理的
一个函数库，其主要实现位于DbgHelp.DLL文件中，因此通常称为
DbgHelp函数库。DbgHelp函数库为实现栈回溯提供了如下支持。
StackWalk64和StackWalk函数，用于定位栈帧和填充栈帧信息，包
括函数返回值、参数等。
调试符号，包括初始化调试符号引擎，加载符号文件，设置符号文
件搜索路径，寻找符号等。
模块和映像文件，包括枚举进程中的所有模块，查询某块的信息
等。
为了演示如何使用DbgHelp函数库来回溯栈，编写了一个名为
CCallTracer的C++类，完整的代码位于code\chap16\D4D目录中。清单
16-1给出了CCallTracer类的WalkStack方法的源代码。
清单16-1 WalkStack方法
1    HRESULT CCallTracer::WalkStack(PFN_SHOWFRAME pfnShowFrame,
2                                   PVOID pParam,int nMaxFrames)
3    {