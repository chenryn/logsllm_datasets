modification in its data structures, but ignores one in heap
because it is hard to distinguish a legitimate one (e.g., modi-
fying metadata in deallocation) from an abusing one (i.e., a
heap exploit technique) without a deep understanding of an
allocator. This is semantically equivalent to monitoring the
violence of the implicit invariant of an allocator — it should
not modify memory that is not under its control.
ARCHEAP distinguishes AW from RW based on the heap
actions that introduce divergence. If a divergence occurs in
allocation or deallocation, it concludes RW, otherwise (i.e.,
in heap or buffer write), it concludes AW. The underlying
intuition is that parameters in the former actions are hard to
control arbitrarily, but not in the latter ones. After detect-
ing divergence, ARCHEAP copies the original memory to its
shadow to stop repeated detections.
A running example. Figure 6 shows the state of the shadow
memory when executing Figure 5. 1 After the first alloca-
tion, ARCHEAP updates its heap container and corresponding
shadow memory to maintain their consistency, which might
be affected by the action. 2 It performs two more allocations
so updates the heap container and shadow memory accord-
ingly. 3 After deallocation, p[1] is changed into ⋆ due to
unlink() in ptmalloc2 (Figure 2a). At this point, ARCHEAP
detects divergence of the shadow memory from the original
heap container. Since this divergence occurs during dealloca-
tion, the impact of exploitation is limited to restricted writes
in the heap container. 4 In this case, since the heap write
causes the divergence, the actions can trigger arbitrary writes
in the heap container. 5 Since this heap write introduces di-
vergence in the global buffer, the actions can lead to arbitrary
write in the global buffer.
5.4 Generating PoC via Delta-Debugging
To find the root cause of exploitation, ARCHEAP refines
test cases using delta-debugging [76], as shown in Algo-
rithm 1. The algorithm is simple in concept: for each action,
ARCHEAP re-evaluates the impact of exploitation of the test
cases without it. If the impacts of the original and new test
cases are equal, it considers the excluded action redundant
(i.e., no meaningful effect to the exploitation). The intuition
behind this decision is that many actions are independent (e.g.,
buffer writes and heap writes) so that the delta-debugging can
clearly separate non-essential actions from the test case. Our
current algorithm is limited to evaluating one individual ac-
tion at a time. It can be easily extended to check with a
sequence or a combination of heap actions together, but our
evaluation shows that the current scheme using a single action
is effective enough for practical uses—it eliminates 84.3% of
non-essential actions on average (see §8.3).
Algorithm 1: Minimize actions that result in an im-
pact of exploitation
Input
:actions – actions that result in an impact
1 origImpact ← GetImpact(actions)
2 minActions ← actions
3 for action ∈ actions do
4
5
6
7
8
9 end
tempActions ← minActions− action
tempImpact = GetImpact(tempActions)
if origImpact = tempImpact then
minActions ← tempActions
end
Output :minActions – minimized actions that result in the
same impact
Implementation
Once minimized, ARCHEAP converts the encoded test case
to a human-understandable PoC like that in Figure 5 using
one-to-one mapping between each action and C code (e.g., an
allocation action → malloc()).
6
We extended American Fuzzy Lop (AFL) to run our heap
action generator that randomly executes heap actions. The
generator sends a user-defined signal, SIGUSR2, if it finds
actions that result in an impact of exploitation. We also
modified AFL to save crashes only when it gets SIGUSR2 and
ignores other signals (e.g., segmentation fault), which are not
interesting in finding techniques. We carefully implemented
the generator not to call heap APIs implicitly except for the
pre-defined actions for reproducing the actions. For example,
the generator uses the standard error for its logging instead of
standard out, which calls malloc internally for buffering. To
prevent the accidental corruption of internal data structures,
the generator allocates its data structures in random addresses.
Thus, the bug actions such as overflow cannot modify the data
structures since they will not be adjacent to heap chunks.
7 Applications
7.1 New Heap Exploitation Techniques
This section discusses the new exploitation techniques in
ptmalloc2 during our evaluation. Compared to the old tech-
niques, we determine their uniquenesses in two aspects: root
causes and capabilities, as shown in Table 6. More informa-
tion (e.g., elapsed time or models) can be found in section
§8. To share new attack vectors in ptmalloc2, the techniques
are reported and under review in how2heap [61], the de-facto
standard for exploitation techniques. Most PoC codes are
available in Appendix A.
Unsorted bin into stack (UBS). This technique overwrites
the unsorted bin to link a fake chunk so that it can return the
address of the fake chunk (i.e., an arbitrary chunk). This is
similar to house of lore [7], which corrupts a small bin to
USENIX Association
29th USENIX Security Symposium    1119
New
UBS
HUE
UDF
OCS
FDO
Old
HL
HE
FD
OC
FD
Root Causes
Unsorted vs. Small
Unsorted vs. Free
Small vs. Fast
Small vs. Unsorted
Consolidation vs. Fast
New Capability
Only need one size of an object
Does not require a heap address
Can abuse a small bin with more checks
Does not need a controllable allocation
Can allocate a non-fast chunk
Table 6: New techniques found by ARCHEAP in ptmalloc2, which
have different root causes and capabilities from old ones.
Allocators
dlmalloc-2.7.2
dlmalloc-2.8.6
musl-1.1.9
musl-1.1.24
jemalloc-5.2.1
tcmalloc-2.7
mimalloc-1.0.8
mimalloc-secure-1.0.8
DieHarder-5a0f8a52
mesh-a49b6134
Impacts of exploitation
RW
P
AC
✓ ✓ OV, WF, DF (N) AF, OV, WF AF, OV, WF AF, OV, WF
✓ ✓ OV, WF, DF (N) OV (N)
✓ ✓ OV, WF, DF (N) AF, OV, WF AF, OV, WF AF, OV, WF
✓ ✓ OV, WF, DF
AF, OV, WF AF, OV, WF AF, OV, WF
AW
OV
OV, WF, DF OV
OV, WF
OV
WF
I
OC
DF
✓ OV, DF
✓ OV, WF, DF
✓ DF
DF
DF, NO
achieve the same attack goal. However, the unsorted bin into
stack technique requires only one kind of allocation, unlike
house of lore, which requires two different allocations, to
move a chunk into a small bin list. This technique has been
added to how2heap [61].
House of unsorted einherjar (HUE). This is a variant of
house of einherjar, which uses an off-by-one NULL byte
overflow and returns an arbitrary chunk. In house of einher-
jar, attackers should have prior knowledge of a heap address
to break ASLR. However, in house of unsorted einherjar, at-
tackers can achieve the same effect without this pre-condition.
We named this technique house of unsorted einherjar, as it
interestingly combines two techniques, house of einherjar
and unsorted bin into stack, to relax the requirement of the
well-known exploitation technique.
Unaligned double free (UDF). This is an unconventional
technique that abuses double free in a small bin, which is
typically considered a weak attack surface thanks to compre-
hensive security checks. To avoid security checks, a victim
chunk for double free should have proper metadata and is
tricked to be under use (i.e., P bit of the next chunk is one).
Since double free doesn’t allow arbitrary modification of
metadata, existing techniques only abuse a fast bin or tcache,
which have weaker security checks than a small bin (e.g.,
fast-bin-dup in Table 4).
Interestingly, unaligned double free bypasses these security
checks by abusing the implicit behaviors of malloc(). First,
it reuses the old metadata in a chunk since malloc() does
not initialize memory by default. Second, it fills freed space
before the next chunk to make the P bit of the chunk one. As
a result, the technique can bypass all security checks and can
successfully craft a new chunk that overlaps with the old one.
Overlapping chunks using a small bin (OCS). This is a
variant of overlapping-chunks (OC) that abuses the unsorted
bin to generate an overlapping chunk, but this technique crafts
the size of a chunk in a small bin. Unlike OC, it requires more
actions — three more malloc() and one more free()— but
doesn’t require attackers to control the allocation size. When
attackers cannot invoke malloc() with an arbitrary size, this
technique can be effective in crafting an overlapping chunk
for exploitation.
Fast bin into other bin (FDO). This is another interest-
ing technique that allows attackers to return an arbitrary ad-
dress: it abuses consolidation to convert the type of a vic-
tim chunk from the fast bin to another type. First, it cor-
rupts a fast bin free list to insert a fake chunk. Then, it
calls malloc_consolidate() to move the fake chunk into the
N: New techniques compared to the related work, HeapHopper [17]; only top three
allocators matter. NO: No bug is required, i.e., incorrect implementations. I: In-place
metadata, P: ptmalloc2-related allocators.
Table 7: Summary of exploit techniques found by ARCHEAP in
real-world allocators with their version or commit hash.
unsorted bin during the deallocation process. Unlike other
techniques related to the fast bin, this fake chunk does not
have to be in the fast bin. We exclude this PoC due to space
limits, but it is available in our repository.
7.2 Different Types of Heap Allocators
We also applied ARCHEAP to the 10 different allocators with
various versions. First, we tested dlmalloc 2.7.2, dlmalloc
2.8.6 [41], and musl [59] 1.1.9, which were used in the re-
lated work, HeapHopper [17]. Moreover, we tested other
real-world allocators: the latest version of musl (1.1.24), je-
malloc [19], tcmalloc [26], Microsoft mimalloc [43] with
its default and secure mode (noted as mimalloc-secure), and
LLVM Scudo [45]. Furthermore, we evaluated allocators
from academia: DieHarder [49], Mesh [56], FreeGuard [64],
and Guarder [65]. Applying ARCHEAP to other allocators
was trivial; we leveraged LD_PRELOAD to use a new allocator.
Under the assumption that internal details of the allocators
are unknown, we ran ARCHEAP with four models specify-
ing each impact (i.e., OC, AC, RW, and AW) one by one to
exhaustively explore possible techniques. After 24 hours of
evaluation, it found several exploit techniques among seven
out of 10 allocators except for Scudo, FreeGuard, and Guarder
due to their secure design. We also tested ARCHEAP with cus-
tom allocators from DARPA Cyber Grand Challenge, whose
results can be found in §A.1.
As shown in Table 7, ARCHEAP discovers various exploita-
tion techniques for ptmalloc2-related allocators: dlmalloc—
the ancestor of ptmalloc2 and musl—a libc implementation
in embedded systems inspired by dlmalloc.
In dlmalloc
2.7.2, dlmalloc 2.8.6, and musl 1.1.9, ARCHEAP not only
re-discovered all techniques found by HeapHopper, but also
newly found the following facts: 1) these allocators are all
vulnerable to double free, and 2) an arbitrary chunk is still
achievable through overflow in dlmalloc-2.8.6. This was hid-
den in HeapHopper due to its limitation to handle symbolic-
size allocation. Note that we merged special cases of overflow
(O1, O1N) into OV to be consistent with HeapHopper [17],
and our claims for new techniques are very conservative; we
claim discovery of new techniques only when HeapHopper
cannot find equivalent or more powerful ones (e.g., AC is
more powerful than OC). We further compare ARCHEAP
with HeapHopper in §8.1. ARCHEAP also found that musl
1120    29th USENIX Security Symposium
USENIX Association
Figure 7: The number of working PoCs from one source LTS in
various Ubuntu LTS. For example, 56 PoCs were generated from
precise, 49 of them work in trusty and xenial, and 45 of them
work in bionic.
has no security improvement in the latest version; all tech-
niques in musl 1.1.9 are still working in 1.1.24.
ARCHEAP also successfully found several heap exploit
techniques in allocators that are dissimilar to ptmalloc2 (see
Table 7) for the following reasons. First, ARCHEAP’s model,
which is based on the common designs in allocators (§2.1),
is generic enough to cover non-ptmalloc allocators. For ex-
ample, tcmalloc [26] is aiming at high performance comput-
ing, resulting in very different design from ptmalloc2’s (e.g.,
heavy use of thread-local cache). However, tcmalloc still
follows our model: its metadata are placed in the head of a
chunk (in-place metadata) and consist of linked list pointers
(cardinal data). Thus, ARCHEAP can find several techniques
in tcmalloc including one that can lead to an arbitrary chunk
using overflow (see Figure A.2). It is worth emphasizing that
our model only depends on metadata’s appearance, not on
their generation or management, which introduce more vari-
ety in design, making generalization difficult. Second, thanks
to standardized APIs, ARCHEAP can find exploit techniques
even in allocators that are deviant from our model (e.g., je-
malloc). In particular, ARCHEAP discovered techniques that
are reachable only using APIs (e.g., double free) although the
allocators have removed in-place metadata for security.
ARCHEAP helps to find implementation bugs in allocators
by showing unexpected exploit primitives in secure alloca-
tors or that can be invokable without a bug. Accordingly,
ARCHEAP found three bugs in mimalloc-secure, DieHarder,
and Mesh. We reported our findings to the developers; two of
them got acknowledged and are patched. It is worth mention-
ing that our auto-generated PoC has been added to mimalloc
as its regression test. In the following, we discuss each issue
that ARCHEAP found.
DieHarder, mimalloc-secure: memory duplication in
large chunks using double free.
ARCHEAP found the
technique that allows the duplication large chunks (more than
64K bytes) in the well-known secure allocators, DieHarder
and mimalloc-secure. Interestingly, even though the alloca-
tors have no direct relationship according to the developer of
mimalloc [43], ARCHEAP found that both allocators are vul-
nerable to this technique. Their root causes are also distinct:
DieHarder misses verifying its chunk’s status when allocat-
ing large chunks, unlike for smaller chunks, and mimalloc
checked the status of an incorrect block. ARCHEAP success-
fully found this corner case without having any hint about the
internals of the allocators using its randomized exploration.
PoC is available in Figure A.3.
Mesh: memory duplication using allocations with nega-
tives sizes. ARCHEAP found that if an attacker allocates an
object with negative size, Mesh will return the same chunk
twice (i.e., duplication) instead of NULL.
7.3 Evolution of Security Features
We applied ARCHEAP to four versions of ptmalloc2 dis-
tributed in Ubuntu LTS: precise (12.04, libc 2.15), trusty
(14.04, libc 2.19), xenial (16.04, libc 2.23), and bionic
(18.04, libc 2.27).
In trusty and xenial, a new security
check that checks the integrity of size metadata (refer (1) in
Figure 2a) is backported by the Ubuntu maintainers. To com-
pare each version, we perform differential testing: we first
apply ARCHEAP to each version and generate PoCs. Then,
we validate the generated PoCs from one version against other
versions. (see Figure 7).
We identified three interesting trends that cannot be eas-
ily obtained without ARCHEAP’s automation. First, a new
security check successfully mitigates a few exploitation tech-
niques found in an old version of ptmalloc2: likely, the libc
maintainer reacts to a new, popular exploitation technique.
Second, an internal design change in bionic rendered the
most PoCs generated from previous versions ineffective. This
indicates the subtleties of the generated PoCs, requiring pre-
cise parameters and the orders of API calls for successful
exploitation. However, this does not particularly mean that a
new version, bionic, is secure; the new component, tcache,
indeed makes exploitation much easier, as Figure 7 shows.
Third, this new component, tcache, which is designed to im-
prove the performance [15], weakens the security of the heap
allocators, not just making it easy to attack but also introduc-
ing new exploitation techniques. This is similarly observed
by other researchers and communities [17, 37].
8 Evaluation
This section tries to answer the following questions:
1. How effective is ARCHEAP in finding new exploitation
techniques compared to the state-of-the-art technique,
HeapHopper?
2. How exhaustively can ARCHEAP explore the security-
3. How effective is delta-debugging in removing redundant
critical state space?
heap actions?
Evaluation setup. We conducted all the experiments on
Intel Xeon E7-4820 with 256 GB RAM. For seeding, we used
256 random bytes that are used to indicate a starting point of
the state exploration and are not critical, as ARCHEAP tends
to converge during the state exploration.
8.1 Comparison to HeapHopper
HeapHopper [17] was recently proposed to analyze existing