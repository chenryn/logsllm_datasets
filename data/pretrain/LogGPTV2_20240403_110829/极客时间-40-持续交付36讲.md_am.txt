## 重新定义交付标准没有容器之前，交付标准包括软件环境（也就所谓的机器）和软件代码两部分。交付系统更关注的是软件代码，环境一旦产生后，我们就不再关心或者很难再干预用户后期是如何对其做变更的了。也就是说，环境的变更没有版本，没有记录，甚至当事人也会忘记当时变更了什么，不言而喻，这会带来很多未知的安全隐患。**而，容器技术统一了软件环境和软件代码，交付产物中既包括了软件环境，又包括了软件代码。也就是说，容器帮我们重新定义了交付标准。**那么，容器技术到底是如何做到的呢？被重新定义后的交付，又有哪些特点呢？**第一，交付结果一致**容器镜像可以把软件的运行环境以及代码打包在一起，因此可以基于同一个镜像，在不同的地方生成一模一样的运行环境，也就是说**单个镜像的交付结果不可变**。当然，单个容器只能提供一个服务，而实际场景下，应用都是跑在 SOA或微服务的框架下的。所以，还需要利用如 Mesos 或 Kubernetes这样的编排系统，将多个容器组织起来，并**固化编排过程**。基于这两个特性，一旦形成了固定的容器镜像和对应的编排（也成为应用模板），那在不同的环境下，一定可以重复部署，且部署结果保持一致。**第二，交付自动化**容器镜像及容器编排技术很好地解决了 CI 和 CD 问题：-   CI    方面，与传统方式的不同只在于，原先交付的是安装包或软件包，而容器交付的则是镜像；-   CD 方面，与传统方式相比则有了长足的进步。\    对传统方式而言，部署和安装方式与软件类型、开发方式有直接关系，存在多种多样的可能。\    而容器技术则没有这样的问题，唯一的方式就是拉起容器镜像。这就大大简化了部署的复杂度，而且在编排系统的支持下，完成    CD 越来越容易了。**第三，交付个性化**传统的交付模式，往往因为环境的初始化问题，只能完成有限种类的交付。运维部门很难为所有的应用做出统一的环境模板，比如需要哪些软件依赖、需要哪些系统配置、部署的步骤是怎样的等等，要统一这些模板，就需要协调多个部门共同完成，难度可想而知。对于一些受众比较少的程序语言，或者一个仅仅想部署一套开源软件的需求是很难满足的，大多数情况下，需要用户自己去申请虚拟机，然后按照官方提供的文档一步一步安装环境。这样操作，非常麻烦，更别提后续的更新了。但是，有了容器之后，我们可以使用统一的接口完成任何应用的部署，几乎可以很好地满足所有的个性化需求。**第四，交付版本控制**对于容器来说，遵循的是不可变基础设施（ImmutableInfrastructure）的理念，也就是说任何变化，包括代码、环境、配置的变更，都需要重新制作镜像，产生一个新的版本。这与版本往往只和代码变更有关的传统方式有所不同。那么，这样的变化到底是好是坏呢？
## 变还是不变，这是个问题不可变基础设施（Immutable Infrastructure），是 Chad Fowler 在 2013年提出的一个很有前瞻性的构想：> 在这种模式中，任何基础设施的实例（包括服务器、容器等各种软硬件）一旦创建之后便成为一种只读状态，不可对其进行任何更改。如果需要修改或升级某些实例，唯一的方式就是创建一批新的实例来替换它。这种思想与不可变对象的概念完全相同。而容器相比于虚拟机体积小和启动快的优势，正好符合了不可变基础设施这一模式的核心思想。不可变基础设施模式的好处显而易见，主要包括以下三个方面：1.  很多与 runtime    相关的配置工作都可以被简化，这让持续集成与持续部署过程变得更流畅。2.  它也更易于应对部署环境间的差异及版本，进行更有效、全面的管理。3.  对回滚来说，更是得到了充分的保证，只要原先版本的镜像存在，它就一定能被恢复。虽然不可变基础设施模式能够带来非常多的好处，但是其实现的难度也很高，你需要一套完全不同的版本管理系统，纳入所有的变更，重新定义版本、变更和发布。如何做到这些，我会在后续的文章中为你详细介绍。但是，这种模式在我看来也是略微违反人性的（人们往往是想怎么简单怎么来）。试想如果你仅有一台机器，只是想升级一下cURL 的版本，你觉得是直接在容器里更新方便，还是更改 Dockerfile重打镜像走完一整套发布流程更方便呢？
## 容器不是银弹正如上面所说，不可变基础设施模式对运维人员来说绝对是福音，为企业实现持续交付保驾护航。但是，对普通用户来说，这种模式有时候却是一种折磨，不可能有完美的标准化容纳所有的个性化，我们必须为个性化需求做准备。目前，很多业务开发人员的观念还停留在使用虚拟机的阶段，从虚拟机迁移到容器时，我们也是拼了命地把容器的使用体验向虚拟机靠近，尽量让用户感觉就是在用虚拟机。初衷是好的，但是这种做法却不能让用户真正认识并理解容器。在迁移前期，我们经常会遇到这样的案例：由于个别应用对环境的个性化需求，用户需要登录虚拟机安装一些软件，或者更新一些配置。迁到容器后，他们依然这么做，但是结果让他们失望，因为每次应用部署后，之前的环境变更就都消失了。这无疑让他们非常沮丧，就好比写了几个小时的代码忘记了保存。我们虔诚地遵循了不可变基础设施模式，但是又没有很好地告知用户这一原则。因此，我们不得不提供各种各样的方式让用户完成"不可变中的可变" 与"标准化中的个性化"，甚至我们必须在不同的环境使用不同的镜像。而这，与我们认为的容器交付的理想状态是有差距的。虽然如此，但如何达成这样的目的，我也会在之后的文章中为你具体介绍。
## 总结在这篇文章中，我介绍了容器如何代替虚拟机帮助我们应对持续交付的新挑战，但也阐述了使用容器技术实施持续交付的一些不足。首先，容器是一种轻量级、可移植、自包含的软件打包技术，使应用程序几乎可以在任何地方以相同的方式运行。然后，我分别从交付结果一致、交付自动化、交付个性化和交付版本控制这 4个方面重新定义了基于容器的交付标准。最后，我又从变和不变两个方向，阐述了容器能解决一些已有的问题，但它并不是银弹，它同样会带来问题，而这些问题，则需要改造和重新设计既有的持续交付模式来解决。
## 思考题你所在的公司是否已经容器化了？如果已经容器化了，是如何平衡应用标准化与个性化的？对于有状态应用，又该如何使用容器进行交付呢？欢迎你给我留言。![](Images/69e5b7a8ed8eecd006aa3ce5f76f78af.png){savepage-src="https://static001.geekbang.org/resource/image/55/0a/55b7b7cb930ca733523be64e3a720d0a.jpg"}
# 14 \| 如何做到构建的提速，再提速！在前面几篇文章中，我分享了很多关于构建的观点，然而天下武功唯为快不破，构建的速度对于用户持续交付的体验来说至关重要。在实施持续交付的过程中，我们经常会遇到这样的情况：只是改了几行代码，却需要花费几分钟甚至几十分钟来构建。而这种情况，对于追求高效率的你我来说，是难以容忍的。那么，今天我就带你一起看看，还有哪些手段可以帮助构建提速。
## 升级硬件资源构建是一个非常耗时的操作，常常会成为影响持续交付速度的瓶颈。原因是，构建过程，会直接消耗计算资源，而且很多构建对硬件的要求也非常高。那么，升级硬件资源就是构建过程提速的最为直接有效的方式。需要注意的是，这里的硬件资源包括CPU、内存、磁盘、网络等等，具体升级哪一部分，需要具体情况具体分析。比如，你要构建一个 C 语言程序，那么 CPU 就是关键点。你可以增加 CPU的个数或者提升 CPU 主频以实现更快的编译速度。再比如，你要用 Maven 构建一个 Java 应用，除了 CPU 之外，Maven还会从中央仓库下载依赖写在本地磁盘。这时，网络和磁盘的 I/O就可能成为瓶颈，你可以通过增加网络带宽提升网络吞吐，使用 SSD代替机械硬盘增加磁盘 I/O ，从而到达提升整个构建过程速度的目的。``{=html}**总之，当你使用成熟的构建工具进行构建时，如果无法通过一些软件技术手段提升软件本身的构建速度，那么根据构建特点，有针对性地升级硬件资源，是最简单粗暴的方法。**
## 搭建私有仓库构建很多时候是需要下载外部依赖的，而网络 I/O通常会成为整个构建的瓶颈。尤其在当前网络环境下，从外网下载一些代码或者依赖的速度往往是瓶颈，所以在内网搭建各种各样的私有仓库就非常重要了。目前，我们需要的依赖基本上都可以搭建一套私有仓库，比如：-   使用 createrepo 搭建 CentOS 的 yum 仓库；-   使用 Nexus 搭建 Java 的 Maven 仓库；-   使用 cnpm 搭建 NodeJS 的 npm 仓库；-   使用 pypiserver 搭建 Python 的 pip 仓库；-   使用 GitLab 搭建代码仓库；-   使用 Harbor 搭建 Docker 镜像仓库-   ......除了提升构建时的下载速度外，更重要的是，你还可以用这些工具存储辛勤工作的成果，保护知识产权。总之，搭建私有仓库一定物超所值。当然，维护和管理这一大批工具需要投入不少人力和经济成本，在公司/ 团队没有成一定规模的前提下，会有一定的负担。所以，**如果你的团队暂时没有条件自己搭建私有仓库的话，可以使用国内已有的一些私有仓库，来提升下载速度。当然，在选择私有仓库时，你要尽量挑选那些被广泛使用的仓库，避免安全隐患。**