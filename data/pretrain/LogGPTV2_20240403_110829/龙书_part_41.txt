T后面的全部符号，因此FOLLOW（E）中的所有符号都在FOLLOW（T)中。这解释了符号$
5）FOLLOW（T）=FOLLOW（T"）=”+，），$}。请注意,T在产生式体中出现时只有E'跟在
2）FIRST(E'）=”+，e}。理由是E'的两个产生式中，一个产生式的体以终结符号+开头，
3）如果存在－个产生式 A-→αB，或存在产生式 A→→αBβ 且 FIRST（β）包含ε，那么
语法分析
预测分析器的转换图和词法分析器的转换图是不同的。分析器的转换图对每个非终结符
对于称为LL(1)的文法，我们可以构造出预测分析器，即不需要回溯的递归下降语法分析
1）FIRST（F）=FIRST（T）=FIRST(E）=（，id}。要知道为什么，请注意F 的两个产生式的
6）FOLLOW（F）=}+，＊，），$}。论证过程和第5点中对T的论证过程类似。
4）FOLLOW（E）=FOLLOW（E'）=↓），$}。因为E是开始符号，FOLLOW（E）一定包含
3）FIRST（T）=*，∈”。它的论证过程和FIRST（E'）的论证过程类似。
2)如果存在--个产生式A-→αBB，那么FIRST（β）中除ε之外的所有符号都在
1）将$放到 FOLLOW（S)中，其中S是开始符号，而$是输人右端的结束标记。
2）对于每个产生式A-→X,X2…·Xn,创建--个从初始状态到结束状态的路径,路径中各条
1）创建一个初始状态和-一个结束(返回)状态。
转换图有助于将预测分析器可视化。比如,图4-16a中显示了文法(4.28）中非终结符号E
再次考虑非左递归的文法(4.28)。那么：
预测分析器的转换图
口
品
---
## Page 158
算法4.31
择A一→α。
FOLLOW(A）中，或者已经到达输人中的$符号且$在FOLLOW（A）中，那么我们仍应该选
有当α=ε时，或更加一般化的α→ε时，情况才有些复杂。在这种情况下，如果当前输入符号在
是一个二维数组，其中A 是一个非终结符号,α是一个终结符号或特殊符号$，即输人的结束标
配成功的。
那么关键字f、while 和符号告诉我们：如果在输人中找到一-个语句,哪个产生式是唯一可能匹
满足 LL(1)的约束。比如，如果我们有如下产生式
非终结符号选择正确的产生式。因为有关控制流的各个语言构造带有不同的关键字，它们通常
结论成立。
在 FIRST(β)中，那么 FIRST(α)和 FOLLOW(A)是不相交的集合，并且当ε在 FIRST(α)中时类似
如果αe，那么β不能推导出任何以FOLLOW（A)中某个终结符号开头的串。
都能够推导出以α开头的串。
A→α”β满足下面的条件：
义性的文法都不可能是LL(1)的。
多加小心。比如，左递归的文法和二
法类似于2.5.4节所述的方法。在该节中,我们使用尾递归消除和过程体替代的方法来优化
标号为非终结符号 A 的边替换为 A 的转换图。图 4-16a 和图 4-16b 中的转换图是等价的:如果
A 的过程的一-次调用。
前两个条件等价于说 FIRST(α)和 FIRST(β)是不相交的集合。第三个条件等价于说如果∈
G的任意两个不同的产生式
组成了形如T+T+·…+T的串。图4-16b中的图可以从图4-16a通过转换而得到。转换的方
我们跟踪从E到结束状态的路径,并替换E,那么在这两组图中,沿着这些路径的文法符号都
接下来给出的算法把FIRST 和FOLLOW 集合中的信息放到一个预测分析表 M[A，a］中。这
之所以能够为LL(1)文法构造预测分析器，原因是只需要检查当前输人符号就可以为一个
3）如果β→e，那么α不能推导出任何以 FOLLOW（A）中某个终结符号开头的串。类似地，
1）不存在终结符号α 使得α和β
一个文法G是LL(1)的，当且仅
 LL(1)文法已经足以描述大部分程序设计语言构造，虽然在为源语言设计适当的文法时需要
-个非终结符号的相应过程。
142
输出：预测分析表 M。
输入：文法 G。
2）α和β中最多只有一个可以推导出空串。
转换图可以化简,前提是各条路径上的文法符号序列必须保持不变。我们也可以将一条
对于--个 LL(1)文法,将ε边作为默认选择可以解决是否选择一个ε边的二义性问题。
构造一个预测分析表。
stmt -→if (expr) stmt else stmt
!stmt_list}
Iwhile (expr) stmt
E:
图4-16文法4.28 的非终结符号E和E'的转换图
b）
第4章
---
## Page 159
7
例4.33
一些这样的文法，它们不存在等价的LL(1)文法。
个多重定义的条目。虽然可以轻松对其进行消除左递归和提取左公因子的操作，但是仍然存在
中可能会有一些多重定义的条目。比如，如果G是左递归的或二义性的，那么M至少会包含-
表中的每个条目都唯一地指定了一个产生式，或者标明一个语法错误。然而，对于某些文法，M
M[E'，$]中。
人到M[E'，+］中。因为 FOLLOW（E"）=“)，$”，产生式 E'→ε被加人到M[E'，）”和
这个产生式被加到 M[E，（］和M[E,id]中。因为 FIRST（+TE'）=+}，产生式E'-→+TE'被加
误条目；非空白的条目中指明了应该用其中的产生式来扩展相应的非终结符号。
例4.32对于表达式文法(4.28)，算法4.31生成了图4-17中的预测分析表。空白条目表示错
常在表中用一个空条目表示)。
M[A，6］中。如果ε在FIRST(α)中，且$在FOLLOW(A)中，也将A→α加人到M[A，$］中。
算法4.31可以应用于任何文法G，生成该文法的语法分析表M。对于每个LL(1)文法，分析
在完成上面的操作之后，如果 M[A，a］中没有产生式，那么将 M[A，a]设置为 error(我们通
语法分析
这个文法的语法分析表显示在图 4-18中。M[S"，e]的条目同时包含了 S"→eS 和 S"→。
下面例子中的语言根本没有相应的 LL(1)文法。
考虑产生式 E→TE'。因为
2）如果∈在FIRST（α）中，那么对于FOLLOW（A）中的每个终结符号b，将A→α 加人到
1）对于FIRST(α）中的每个终结符号α，将A→α加人到M[A，α］中。
方法：对于文法G的每个产生式A→α，进行如下处理：
下面重复一下例子 4.22 中的文法。该文法抽象地表示了悬空－else 的问题。
非终结符号
非终结符号
U2
S
FIRST(TE'） = FIRST(T) = i(,id}
S
←
图 4-17
图4-18例4.33的分析表 M
↑
E'→ +TE'
例4.32 的预测分析表 M
S
S→iEtSS'| a
-→eS 1 ∈
S
↑
→E
输入符号
→
3
输人符号
S
→iEtSS"
F →(E)
-→TE
[T'→<T" →c
E'→eE→
口
L
---
## Page 160
例4.35
的下面是$。图 4-20 中的程序使用预测分析表 M生成了处理这个输人的预测分析过程。
算法4.34
余下的输入。
的代码。)否则，它检查终结符号X和当前输人符号α是否匹配。
M[X，a］来选择一个X产生式。（这里可以执行一些附加的代码，比如构造一个语法分析树结点
栈顶符号X和当前输人符号α。如果X是一个非终结符号，该分析器查询分析表 M中的条目
标记栈底。在开始时刻，栈中$的上方是开始符
串，串后面跟有结束标记＆。我们复用符号$
出流。它的输人缓冲区中包含要进行语法分析的
一个由算法4.31构造得到的分析表，以及一个输
个输人缓冲区，一个包含了文法符号序列的栈，
配完成的输人部分，那么栈中保存的文法符号序列α满足
的方式隐式地维护栈。这样的语法分析器可以模拟最左推导的过程。如果 w是至今为止已经匹
4.4.4非递归的预测分析
者从输人中被消除，因此选择这个产生式一定是错误的。
当于把 else 和前面最近的 then 关联起来。请注意,选择 S'→e 将使得e 永远不可能被放到栈中或
会显露出此文法的二义性。解决这个二义性问题时，我们可以选择产生式S'→eS。这个选择就相
S。
我们可以构造出一个非递归的预测分析器，它显式地维护一个栈结构，而不是通过递归调用
方法:最初，语法分析器的格局如下：输人缓冲区中是w$，而G的开始符号S位于栈顶，它
这个语法分析器的行为可以使用它的格局（configuration)来描述。格局描述了栈中的内容和
语法分析器由一个程序控制。该程序考虑
这个文法是二义性的。当在输人中看到e(代表else)时，解决选择使用哪个产生式的问题就
144
输出：如果 u在 L(G)中，输出 w的一个最左推导；否则给出－-个错误指示。
输入：一个串w，文法G的预测分析表 M。
图4-19 中的由分析表驱动的语法分析器有一
表驱动的预测语法分析。
下面的算法描述了如何处理格局。
while ( X
令X=栈顶符号；
else i
M[X,a]是一个报错条目）error();
图4-20
）压人栈中、其中Y位于栈顶。
号
预测分析算法
来
图4-19
栈
输人
一-个分析表驱动的预测分析器的模型
预测
1a1+16]s
——输出
第4章
□ 
它
口
---
## Page 161
的各个构造之间常常存在某个层次结构。比如，表达式出现在语句内部，而语句出现在块内部，
在一个赋值语句之后遗漏分号可能会使得语法分析器忽略下一个语句开头的关键字。一个语言
束，那么语句开头的关键字可能不会出现在代表表达式的非终结符号的FOLLOW 集合中。因此，
语法分析过程就能够继续进行。
略一些词法单元，直到碰到了FOLLOW（A)中的某个元素，然后再将A从栈中弹出，那么很可能
选取这个集合的原则是应该使得语法分析器能够从实践中可能遇到的错误中快速恢复。下面是
出现由设计者选定的同步词法单元集合中的某个词法单元。它的有效性依赖于同步集合的选取。
输人符号，且 M[A，a]为 error（即相应的语法分析表条目为空)时，预测语法分析过程就可以检
语法分析过程中使用。
语法分析器期望用哪些终结符号及非终结符号来匹配余下的输入。这个技术也可以在递归下降
4.4.5预测分析中的错误恢复
指向“输入”列中的串的最左边的符号。
示
的内容。我们显示已匹配输人就是为了强调这种对应关系。因为同样的原因，在图中将栈顶虽
左推导(完整的推导过程见图 4-12)：
到语法错误。
在左边。当我们考虑自底向上语法分析时，将栈顶显示在右边会更加自然。分析器的输入指
语法分析
2）只使用FOLLOW(A)作为A的同步集合是不够的。比如，C语言用分号表示一个语句结
1）首先将 FOLLOW(A)中的所有符号都放到非终结符号A 的同步集合中。如果我们不断
当栈顶的终结符号和下一个输人符号不匹配时，或者当非终结符号A处于栈顶，α是下一
在讨论错误恢复时要考虑一个由分析表驱动的预测分析器的栈，因为这个栈明确地显示
启发式规则：
恐慌模式的错误恢复是基于下面的思想。语法分析器忽略输入中的一些符号，直到输人中
恐慌模式
请注意,这个推导中的各个句型对应于已经被匹配的输入部分(见图中的已匹配列)加上栈中
图4-21对输人 id+id*id 进行预测分析时执行的步骤
十.
巴匹配
+
+