        memcpy(&dest, (char *)global_buf[idx] + (signed __int16)addr, size);
      return dest;
    }
可以看到`(addr & 0xF0000u)`为idx，`addr`的低16位为`offset`。当`(addr & 0xF00000u) >>
20`不为15时，将`global_buf[idx] +
offset`中的数据拷贝出来赋值给`dest`，否则`dest`为`0x42069`，返回`dest`。
接着看`ooo_mmio_write`函数，代码如下：
    void __fastcall ooo_mmio_write(struct_a1 *opaque, __int64 addr, __int64 value, unsigned int size)
    {
      unsigned int cmd; // eax MAPDST
      int n[3]; // [rsp+4h] [rbp-3Ch]
      __int16 v8; // [rsp+22h] [rbp-1Eh]
      int i; // [rsp+24h] [rbp-1Ch]
      unsigned int idx; // [rsp+2Ch] [rbp-14h] MAPDST
      *(_QWORD *)n = value;
      cmd = ((unsigned int)addr & 0xF00000) >> 20;
      cmd = ((unsigned int)addr & 0xF00000) >> 20;
      switch ( cmd )
      {
        case 1u:
          free(global_buf[((unsigned int)addr & 0xF0000) >> 16]);
          break;
        case 2u:
          idx = ((unsigned int)addr & 0xF0000) >> 16;
          v8 = addr;
          memcpy((char *)global_buf[idx] + (signed __int16)addr, &n[1], size);
          break;
        case 0u:
          idx = ((unsigned int)addr & 0xF0000) >> 16;
          if ( idx == 15 )
          {
            for ( i = 0; i : mov BYTE PTR
[rdx],al`，是访存错误。意识到是我一开始mmap文件`/sys/devices/pci0000:00/0000:00:04.0/resource0`的size过小，导致`mmio_write`的时候访存越界，所以在`mmap`时分配size大些就可以了，我最后映射的size为mmio空间的大小`0x1000000`（一开始也是像之前其它的题一样mmap的size为0x1000）。
同时题目当时的环境是ubuntu16，由于没有tcache，利用起来比较复杂。根据已有的wp，有两种解法：
  1. 根据[DefconQuals 2018 - EC3](https://uaf.io/exploitation/2018/05/13/DefconQuals-2018-EC3.html)解法：申请0x70大小的堆块，利用fastbin attack将fd改到`global_buf`地址处，因为堆指针地址开头会为`0x7f`，所以可以绕过size检查，从而将`global_buf`申请出来，覆盖地址实现任意读写，再修改got地址即可。
  2. 根据[EC3 write-up (DEF CON CTF 2018 Quals)](https://blog.bushwhackers.ru/defconquals2018-ec3/)解法：利用堆溢出，将堆中内容都覆盖成后门的地址，再利用命令`echo mem > /sys/power/state`将虚拟机休眠，唤醒的时候会劫持控制流拿到flag。
感觉如果没有后门以及开了PIE的话，也可以利用`mmio_read`先泄露libc地址和堆地址，再做利用也是可行的。
还有一点是如何将exp传入到虚拟机中，一种方式是将exp编译好后base64编码，粘贴到虚拟机中再解码。另一种是看到文件系统是`initramfs-busybox-x86_64.cpio.gz`，我们可以用下面文件解压出来。
    gunzip initramfs-busybox-x86_64.cpio.gz
    cpio -idmv  ../initramfs-busybox-x86_64.cpio
            cd .. && gzip initramfs-busybox-x86_64.cpio
## 小结
第一次看没有符号的题，还是有一定的挑战的，修复运行环境也搞了半天，学到了不少。
最后在github里面找到了题目的[源码](https://github.com/o-o-overflow/chall-ec-3/tree/de0e64563fc9890ce81bfe5fe107afb107d719b7)，逆了半天有点儿尴尬，不过看完没符号的反编译代码并尽量把它修复也是对自己的一点挑战吧。
相关脚本和文件[链接](https://github.com/ray-cp/vm-escape/tree/master/qemu-escape/DefconQuals-2018-EC3)
## 参考链接
  1. [DefconQuals 2018 - EC3](https://uaf.io/exploitation/2018/05/13/DefconQuals-2018-EC3.html)
  2. [EC3 write-up (DEF CON CTF 2018 Quals)](https://blog.bushwhackers.ru/defconquals2018-ec3/)
  3. [oooverflow.c](https://github.com/o-o-overflow/chall-ec-3/blob/de0e64563fc9890ce81bfe5fe107afb107d719b7/src/oooverflow.c)
  4. [linux系统的休眠与唤醒简介](https://www.cnblogs.com/sky-heaven/p/4561374.html)