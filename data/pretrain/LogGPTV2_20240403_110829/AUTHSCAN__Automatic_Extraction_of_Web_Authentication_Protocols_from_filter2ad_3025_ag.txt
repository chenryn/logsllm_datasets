Section 4.2), AUTHSCAN ﬁnds that
is a signature
by IDP S over four data elements occurring previously:
{U SER, spkU ser, p, expire}k
. Similarly, in mes-
sage (6), AUTHSCAN identiﬁes that function sign() is
used to generate signature {j, expire1}spkU ser−1 and this
it
−1
IDP S
signature is concatenated with IDP’s signature (i.e., cert)
with function bundle(). Afterwards, this concatenation
is sent by invoking function Window.postMessage().
B.2
Inferred Protocols
Figure 6 demonstrates the protocols inferred using
AUTHSCAN; the inferred models are simpliﬁed for read-
ability.
B.3 Precision of Inferred Protocols
We investigate the precision of our inferred protocol,
which is possible for two of our case studies, to available
documentation and manually-crafted speciﬁcations. We
ﬁnd that our protocols are fairly precise, subject to our qual-
itative analysis.
BrowserID Precision. We compare our inferred speciﬁ-
cation to the documented description of the protocol on-
line [2]. Our inferred protocol matches closely to the de-
scription in the documentation.
In some cases, it reveals
useful information that is unspeciﬁed in the documentation.
For instance, the documentation says that, the IDP returns a
signed structure containing expiration time in the Step 5 of
Figure 6-(a)), but documentation does not precisely specify
the duration of the “expiration time”. AUTHSCAN ﬁnds that
the duration is large enough to permit replay attacks that are
longer than 726 seconds. This intermediate result is useful
for further analysis, such as veriﬁcation on time sensitive
protocols [23].
We ﬁnd the protocol to match the documentation exactly
(subject to our manual interpretation), except for one ad-
ditional difference. The document states that the SPs are
allowed to send the signed data to BrowserID for veriﬁca-
tion in the speciﬁcation rather than local veriﬁcation. Since
this message is sent between SP and IDP servers rather than
been relayed in the browser, it is not represented in our in-
ferred speciﬁcation.
Facebook Connect Precision. Facebook Connect origi-
nates from OAuth 2.0 authorization protocol [25]. In Ebay-
Classiﬁed case, our inferred protocol consists of 11 rounds
and 65 parameters (including cookies and GET/POST pa-
rameters), comparing to 7 rounds and 11 parameters in
the speciﬁcation. The extra rounds and parameters, which
shows our inferred protocol is more precise, may be vul-
nerable to the protocol and have been analyzed by AUTH-
SCAN. Furthermore, compared to recent work which man-
ually extracts the Facebook Connect protocol, our model
has deﬁned more precisely the terms exchanged in the pro-
tocol [33]. Our inferred speciﬁcation is also more detailed
than the prior work of Hanna et al. [27]. Finally, we ﬁnd
that our Facebook Connect model is different from the de-
scription in Wang et al.’s recent work [42]— this is because
Figure 5: The HTTP trace of BrowserID and the corresponding TML statements (The full messages are available at [1].)
Figure 6: The sequence diagrams inferred from implementations of BrowserID and Facebook Connect
their work considers the Flash implementation whereas we
analyze the JavaScript-based implementation which works
in today’s web browsers by default.
C TML to ProVerif Inputs
TML is an high-level abstract model language, which
can be directly translated into applied pi-calculus. We do
not present the formal semantics translation between these
two languages, but intuitively explain the mapping between
them. The applied pi-calculus model of the running exam-
ple (Figure 1 and 3) is shown in Figure 7.
Conversion. Most syntax and semantics can be directly
mapped to applied pi-calculus. The initial conditions (ini-
tial knowledge of the participants) are represented with
a set of global variables (line 17-21), where the terms
initially unknown to Z is labeled as private, such as
k IDP s (line 18), the private key of IDP S. The crypto-
graphic functions are translated into constructor (fun) and
destructor (reduc) (line 6-15). The local protocols are
  # Input TML (2) HTTP Messages Javascript code snippet Initial Conditions r has csrf ˄ p has csrf  IDP_C( r )      NewAssoc({r,p},  assoc (USER, PWD))     Send( p, {assoc(USER, PWD ), csrf }) IDP_S( p )     Receive( r, { assoc( M, N ),  csrf } ) POST https://login.persona.org/wsapi/authenticate_user  Host: login.persona.org "email":"PI:EMAIL",  "pass":"alice",  "csrf":"UaZWfqrQmYwemitM1U8nUw==" NONE (4) POST  https://login.persona.org/wsapi/cert_key  Host: login.persona.org "email":"PI:EMAIL", "pubkey":"{\"algorithm\":\"DS\"……6233397a\"}",  "csrf":"UaZWfqrQmYwemitM1U8nUw==" syncEmailKeypair:function(…){…, d.withContext(function(){  a.generateKeypair({ algorithm:"DS", keysize:c.KEY_LENGTH}, …)})} IDP_C ( r )     NewKeyPair( spkUser,  spkUser -1)      Send( p, USER, spkUser, csrf ) IDP_S( p )     Receive( r, M, Y, csrf ) (5) GET https://login.persona.org/wsapi/cert_key Host: login.persona.org "cert":"eyJhbGciOiJSUzI1NiJ9.eyJwdW....SfqAt5…" NONE IDP_C( r )     Receive( p, X  ) IDP_S( p )     NewNonce( expire ) Send( r, { M, Y, p, expire }         )    (6) NONE assertion.sign( {},{audience:c,expiresAt:j},g, function(d,g){ k=a.cert.bundle([f.cert],g),…}) b.window.postMessage( JSON.stringify(a), b.origin)  IDP_C( i ) NewNonce( expire1 ) Send( j, [X, { j, expire1 }                ] )   SP_C( j ) Receive( i, R) —1 IDP_S k  spkUser -1 SP_S SP_C IDP_S (3) {Ack} Key(IDP_C, IDP_S)  (8) Ack IDP_C (1) {SP_domain} K_B (7) {USER, Ki, expire, IDP_domain}Ks-1, {expire1, SP_domain}Ki-1 (2) {assoc(USER, PWD), csrf} Key(IDP_C, IDP_S) (4) {USER, Ki, csrf} Key(IDP_C, IDP_S) (5) {{USER, Ki, expire, IDP_domain}Ks-1} Key(IDP_C, IDP_S) SP_C IDP_C IDP_connect IDP_rp IDP_login IDP_OAuth (1)assoc(SID, Domain) (2) assoc(SID, Domain) (3) {SID, assoc(SID, Domain), assoc(Email, password)}Key(IDP_C, IDP_login) (4) assoc(SID,Domain), assoc(Email, c_user), xs) (6) {access_token, signed_request, Domain}Key(IDP_C, IDP_rp) (8) {access token, signed_request, Domain}Key(IDP_C, IDP_connect) (5) assoc(SID,Domain), assoc(Email, c_user), xs) (7) {access_token, signed_request, Domain}Key(IDP_C, IDP_connect) (9) {access token, signed_request, Domain}K_B (a) the Sequence Diagram of BrowerID (b) the Sequence Diagram of Facebook Connect    IDP (6) {{USER, Ki, expire, IDP_domain}Ks-1, {expire1, SP_domain}Ki-1}K_B represented with the processes (line 33-82), whose iden-
tifers are represented with i,j,r,p (line 17) of Host
the Begin* and
type (line 1). For the action schema,
End* are mapped to event (line 67 and 57); the Send
and Receive are mapped to out and in;
the assoc is
represented with the table (line 22), and NewAssoc is
mapped to insert a tuple into the table (line 34). How-
ever, one problem is that ProVerif does not scale as the
number of tables increases. To solve this problem, we
also can model the assoc using functions.
In particular,
AUTHSCAN uses the same modeling method as model-
ing symmetric cryptographic primitives. For example, the
assoc(i, authtoken) in Figure 3 is modeled as mysenc
at line 13-15. Specially, if this assoc happens to be a
long-lived or guessable token which needs to be added
into Z’s knowledge set, AUTHSCAN just casts the encryp-
tion key to the attacker (addattackerknow at line 77-
78). The checking action is mapped to the matching ac-
tion, for example, let(=M, =N) = checksign(P,
spk(k IDP s)) (line 42) checks whether P is a signa-
ture over (M, N) using the private key K IDP s. The
channel is slightly different from TML because ProVerif
supports both public and private channels. AUTHSCAN
translates HTTP into public channel (ch at line 23, 38 and
46) which is readable and writable to the attacker; HTTPS
and cross-domain communication is translated as private
channels (https at line 25 and 48, and browser at line
24 and 40).
For the syntax or semantics not supported by ProVerif,
AUTHSCAN models them in alternative ways. For ex-
ample, ProVerif does not support a writable but non-
readable (for the attacker) or a readable but non-writable
channel. When AUTHSCAN ﬁnds that the sender origin
of postMessage is not checked (such as Step y in Fig-
ure 1), which means this channel becomes an attacker-
writable channel (but remains unreadable),
it turns the
browser channel writable by adding an input before out
messages to browser, as shown at line 38-40. Conversely,
if it ﬁnds that the channel is readable, it adds an out after
in message from the channel. Finally, after we ﬁxing all the
vulnerabilities, ProVerif reports that the protocol is veriﬁed.
Detected vulnerabilities. ProVerif detects three attacks in
this model. First, it reports that the attacker can derive
the token using the key k i j com cast to his knowl-
edge set (line 77-78). After “ﬁxing” this ﬂaw (Here ﬁx-
ing means correcting the ﬂaw in the model instead of in
the implementation) as shown at line 74-78, it reports a re-
play attack where the attacker can obtain the token from
line 46, and then replay it to line 54. After “ﬁxing” this
ﬂaw using HTTPS to replace HTTP as shown at line 48 and
55, ProVerif reports the MITM attack shown in Section 2.1.
The attacker replaces mynext at line 38 and ﬁnally gets the
token from line 63.
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
51
52
53
54
55
1 type Host.
2 type key.
3 type spkey.(*public key*)
4 type sskey.(*pivate key*)
(*symentric key*)
5
6 (* Shared key encryption *)
7 fun senc(bitstring, key):bitstring.
8 reduc forall x:bitstring,y:key;sdec(senc(x,
y),y)=x.
9 (* Signatures *)
10 fun spk(sskey):spkey.
11 fun sign(bitstring, sskey):bitstring.
12 reduc forall x:bitstring,y:sskey; checksign
(sign(x,y), spk(y)) = x.
13 (*fun*)
14 fun mysenc(Host, key):bitstring.
15 reduc forall x:Host,y:key;mysdec(mysenc(x,y
),y) = x.
16
17 free i, j, r, p:Host.
18 free k_IDP_s:sskey [private].
19 free k_i_j_com:key [private].
20 free sp:bitstring.
21 free sessionID, CSRFToken:bitstring[private
].
22 table sp_table(Host, bitstring).
23 channel ch.
24 free browser:channel [private].
25 free https:channel [private].
26
27 event BeginInit(Host).
28 event EndResponse(Host).
29
30 query x:Host, y:Host; inj-event(EndResponse
(x)) ==> inj-event(BeginInit(y)).
31 query attacker(mysenc(i, k_i_j_com)).
32
33 let SP_C = (*i*)
insert sp_table(j, sp);
(*******************************
3. Fix postmessage flaw
*******************************)
(*in(ch,(j:Host,sp:bitstring,mynext:
channel)); *)
new mynext:channel;
out(browser,((j,sp),mynext));(*Step 1*)
in(mynext,(M:Host,N:bitstring,P:bitstring)
); (*Step 4*)
let(=M, =N) = checksign(P, spk(k_IDP_s))
in
(*******************************
2. Fix HTTP replay attack
*******************************)
(*out(ch, (M,N))*)
in(ch, (M:bitstring, N:bitstring));
out(https, (M,N))(*step 5*).
50 let SP_S = (*j*)
(*******************************
2. Fix HTTP replay attack
*******************************)
(*in(ch,(M:Host,token:bitstring))*)
in(https,(M:Host,token:bitstring));(*step5
*)
let (=M) = mysdec(token, k_i_j_com) in
event EndResponse(i).
56
57
59 let IDP_C = (*r*)
in(browser,(X:bitstring,Y:channel));(*step
1*)
*)
out(https,(X,sessionID,CSRFToken));(*step2
in(https,(M:Host,N:bitstring,P:bitstring))
58
60
61
62
63
64
66
67
68
69
70
71
72
73
74
75
;(*step 3*)
out(Y, (M,N,P)). (*step 4*)
65 let IDP_S = (*p*)
in(https, (X:bitstring, =sessionID, =
CSRFToken));
(*step 2*)
event BeginInit(j);
let(M:Host, Mdomain:bitstring) = X in
get sp_table(=M, =Mdomain) in
let token = mysenc(i, k_i_j_com) in
let idpsign = sign((i, token), k_IDP_s) in
out(https, (i, token, idpsign)).(*step 3*)
(*******************************
1. Fix guessable token
*******************************)
76
77 let addattackerknow =
78
(*out(ch, k_i_j_com)*)
new padding:bitstring.
79
80
81 process
82
(!SP_C|!SP_S|!IDP_C|!IDP_S|!
addattackerknow)
Figure 7: Applied pi-calculus model of the running example
D CSRF Attack Script
The following script can be used by the attacker to com-
mit a CSRF attack, which modiﬁes the content on the web
pages of Myfavoritebeer without the user’s approval.
formFrame.document.body.innerHTML=
’ ’;
formFrame.document.all.tfm.submit();