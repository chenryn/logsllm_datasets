### Section 4.2: AUTHSCAN Analysis

In message (4), AUTHSCAN identifies a signature generated by the IDP over four previously occurring data elements: `{USER, spkUser, p, expire}`. Similarly, in message (6), AUTHSCAN determines that the `sign()` function is used to generate the signature `{j, expire1}spkUser-1`. This signature is then concatenated with the IDP's signature (i.e., `cert`) using the `bundle()` function. The resulting concatenation is transmitted via the `Window.postMessage()` function.

### B.2 Inferred Protocols

Figure 6 illustrates the protocols inferred by AUTHSCAN. For clarity, the inferred models have been simplified.

### B.3 Precision of Inferred Protocols

We evaluated the precision of our inferred protocols for two case studies, comparing them to available documentation and manually crafted specifications. Our analysis indicates that the inferred protocols are highly accurate, as per our qualitative assessment.

#### BrowserID Precision
Our inferred specification closely matches the documented description of the protocol [2]. In some instances, AUTHSCAN uncovers useful details not specified in the documentation. For example, the documentation states that the IDP returns a signed structure containing an expiration time in Step 5 of Figure 6-(a). However, it does not specify the exact duration of this expiration time. AUTHSCAN reveals that the duration is sufficiently long to allow replay attacks lasting more than 726 seconds. This finding is valuable for further analysis, such as verifying time-sensitive protocols [23].

Overall, our inferred protocol aligns well with the documentation, with one notable exception. The documentation allows SPs to send signed data to BrowserID for verification, rather than performing local verification. Since this communication occurs between SP and IDP servers and not through the browser, it is not represented in our inferred specification.

#### Facebook Connect Precision
Facebook Connect is derived from the OAuth 2.0 authorization protocol [25]. In the Ebay-Classified case, our inferred protocol consists of 11 rounds and 65 parameters (including cookies and GET/POST parameters), compared to 7 rounds and 11 parameters in the specification. The additional rounds and parameters indicate that our inferred protocol is more detailed and may reveal potential vulnerabilities. Compared to recent work that manually extracts the Facebook Connect protocol, our model more precisely defines the terms exchanged [33] and is more detailed than the prior work by Hanna et al. [27]. Finally, our Facebook Connect model differs from the description in Wang et al.'s recent work [42], as their study focuses on the Flash implementation, while we analyze the JavaScript-based implementation, which is the default in modern web browsers.

### C. TML to ProVerif Inputs

TML is a high-level abstract model language that can be directly translated into applied pi-calculus. We do not provide a formal semantics translation but offer an intuitive explanation of the mapping between these languages. The applied pi-calculus model of the running example (Figures 1 and 3) is shown in Figure 7.

#### Conversion
Most TML syntax and semantics can be directly mapped to applied pi-calculus. Initial conditions (initial knowledge of participants) are represented as global variables (lines 17-21), where unknown terms to Z are labeled as private, such as `k_IDP_s` (line 18), the private key of the IDP. Cryptographic functions are translated into constructors (`fun`) and destructors (`reduc`) (lines 6-15). Local protocols are represented as processes (lines 33-82), with identifiers `i, j, r, p` (line 17) of type `Host`. The `Begin*` and `End*` actions are mapped to events (lines 67 and 57); `Send` and `Receive` are mapped to `out` and `in` respectively. The `assoc` is represented as a table (line 22), and `NewAssoc` is mapped to inserting a tuple into the table (line 34).

However, ProVerif does not scale well with an increasing number of tables. To address this, we can model `assoc` using functions. For example, `assoc(i, authtoken)` in Figure 3 is modeled as `mysenc` at lines 13-15. If `assoc` involves a long-lived or guessable token, AUTHSCAN adds the encryption key to the attacker's knowledge set (lines 77-78). The `checksign` action (line 42) verifies whether `P` is a signature over `(M, N)` using the private key `k_IDP_s`.

Channels in ProVerif support both public and private types. AUTHSCAN translates HTTP into a public channel (line 23, 38, and 46) accessible to the attacker, while HTTPS and cross-domain communication are translated as private channels (lines 25 and 48, and 40).

For unsupported syntax or semantics, AUTHSCAN uses alternative modeling. For instance, if the sender origin of `postMessage` is not checked (Step y in Figure 1), the channel becomes writable by the attacker. AUTHSCAN adds an input before `out` messages to the browser (lines 38-40). Conversely, if the channel is readable, it adds an `out` after `in` messages from the channel. After fixing all vulnerabilities, ProVerif confirms the protocol's security.

#### Detected Vulnerabilities
ProVerif detected three attacks in the model:
1. **Token Derivation Attack**: The attacker can derive the token using the key `k_i_j_com` added to their knowledge set (lines 77-78).
2. **Replay Attack**: The attacker can obtain the token from line 46 and replay it to line 54.
3. **MITM Attack**: The attacker replaces `mynext` at line 38 and ultimately obtains the token from line 63.

### D. CSRF Attack Script

The following script can be used by an attacker to perform a CSRF attack, modifying the content on the Myfavoritebeer web pages without user approval:

```javascript
formFrame.document.body.innerHTML = '';
formFrame.document.all.tfm.submit();
```

This script clears the form frame and submits the form, effectively altering the page content.