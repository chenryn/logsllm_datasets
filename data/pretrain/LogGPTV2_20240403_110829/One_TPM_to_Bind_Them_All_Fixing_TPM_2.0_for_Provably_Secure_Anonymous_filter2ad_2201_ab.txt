Roughly, for signing a message m via a signature proof of
knowledge (SPK) of tsk w.r.t. a basename bsn L, the host ﬁrst
invokes TPM.Commit on input a group element g and basename
bsn L upon which the TPM outputs (commitId , E, K, L) with
K ← HG1
(bsn L)tsk , and the t-values of the SPK, denoted
E ← gr and L ← HG1 (bsn L)r. The TPM also internally
stores (commitId , r). The host then calls TPM.Hash to obtain
a hash c on the message (m, (E, L)). If the TPM wants to
sign this message, it marks c as safe to sign. The proof gets
completed by invoking the TPM.Sign command on input a
safe-to-sign hash c and a reference commitId to the random-
ness r upon which the TPM outputs s ← r + c · tsk.
Due to this generic interface, the TPM 2.0 can be used to
construct multiple DAA schemes. Chen and Li [5] show that
the TPM 2.0 supports both LRSW-based DAA [23] and q-
SDH-based DAA [3], whereas the TPM 1.2 only supported
the original RSA-based DAA scheme [1]. Unfortunately, the
current TPM 2.0 interfaces have some drawbacks: the signa-
ture proofs of knowledge the TPM makes cannot be proven to
be unforgeable and there exists a static Difﬁe-Hellman oracle
leaking information about the TPM key.
3.1 Unforgeability Flaw for TPM 2.0-based SPKs
The SPKs that are created via the TPM commands should
be unforgeable, i.e., a host must not be able to compute an
SPK on message m without calling TPM.Sign on a hash
c that was previously cleared via a TPM.Hash call on m.
Chen and Li [5] aim to prove this property, but the proof
is incorrect, as pointed out by Xi et al. [8]. In the proof,
the authors simulate the TPM without knowing its secret key
tsk. To simulate an SPK on message m, the authors use the
standard approach of randomly choosing the c, s values, and
then derive the t-values E, L in TPM.Commit based on c, s,
and tpk. For the reduction to go through, one must ensure
that the randomly chosen c becomes the hash value of (m, t)
(via TPM.Hash and modeling the hash as random oracle), and
then let TPM.Sign respond with s whenever that c is given as
input. However, given that an adversary has arbitrary access to
the TPM interfaces, it can query TPM.Hash on many different
messages (m1, t), . . . , (mn, t) containing the same t value.
The reduction does not know which of these queries the
adversary will later use to complete the signature, and thus
only has a 1/n chance to correctly simulate the proof.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
Unforgeability Fix Breaks Privacy. This problem is inherent
in the current TPM interface, but could be solved by a simple
modiﬁcation to the TPM.Sign method as proposed by Xi et
al. [8]: when signing, the TPM ﬁrst chooses a nonce nt and
(cid:3) · tsk. This allows
computes c
to prove the unforgeability of TPM generated SPKs, as the
(cid:3) only when
reduction can now program the random oracle on c
the TPM.Sign query is made.
(cid:3) ← H(nt, c) and s ← r + c
However, this would also introduce a subliminal channel
for the TPM, as nt would be part of the ﬁnal signature
and a subverted TPM can embed arbitrary information in
that nonce, breaking the anonymity without a host noticing.
Recent revelations of subverted cryptographic standards and
tampered hardware indicate that such attacks are very realistic.
We propose changes to the TPM that provably prevent such
subliminal challenges and at the same time allow to prove the
unforgeability of the SPKs, as we will show in Sec. 4.
3.2 Static Difﬁe-Hellman Oracle
Another problem in the TPM 2.0 interface is the static
Difﬁe-Hellman (DH) oracle, as pointed out by Acar et al. [25].
For any chosen point g ∈ G1, the host can learn gtsk by
calling (commitId , E, K, L) ← TPM.Commit(g, bsn), s ←
TPM.Sign(commitId , c) and computing gtsk ← (gs · E
−1)1/c.
This leaks a lot of information about tsk, Brown and Gal-
lant [26] and Cheon [27] show that the existence of such an
oracle makes ﬁnding the discrete log much easier. The reason
is that the oracle can be used to compute a q-SDH sequence
q for very large q, which in turn allows
gtsk , gtsk
to recover tsk faster than had one been given only ¯gtsk . On
Barreto-Naehrig (BN) curves [13], one third of the security
strength can be lost due to a static DH oracle. For example,
a 256 bit BN curve, which should offer 128 bits of security,
only offers 85 bits of security with a static DH oracle.
, . . . , gtsk
2
The static DH oracle also prevents forward anonymity.
Forward anonymity guarantees that signatures made by an
honest platform remain anonymous, even when the host later
becomes corrupted. In existing schemes, even anonymous
signatures contain a pair (gi, Ui,k) where gi
is a random
generator and Ui,k = gtsk k
. With a static DH oracle, a host
(cid:3)
i = gtsk
upon becoming corrupt can use the TPM to compute U
(cid:3)
i = Ui,k, breaking
for all previous signatures, test whether U
the anonymity of these signatures.
i
i
Cleared Generators for LRSW-based Schemes. Xi et al. [8]
propose an approach to remove the static DH oracle while
preserving the support for the both LRSW- and q-SDH-based
DAA schemes. They introduce a new TPM.Bind command that
takes as input two group elements P and K and a proof πP ←
SPK{α : P = ¯gα ∧ K = tpk
α}. The TPM veriﬁes the proof
and, if correct, stores P as cleared generator. The TPM.Commit
interface will then only accept such cleared generators as input
for g. This removes the static DH oracle because the proof πP
shows that P tsk = K is already known. A similar approach
was also used in the recent LRSW-DAA scheme by Camenisch
et al. [9].
904
However, this approach has two crucial problems. First, it
is very hard to implement this functionality on a TPM. The
TPM stores only a small number of root keys due to the very
limited amount of storage available. For all other keys, the
TPM creates a “key blob” that contains the public part of the
key in the clear and the private part of the key encrypted with
one of the root keys. The TPM would have to similarly store
an authenticated list of generators which have been cleared via
the TPM.Bind interface. However, this would be a new type
of key structure, which is a signiﬁcant change to the current
TPM 2.0 speciﬁcation.
Second,
this interface does not support signature-based
revocation, which is an important extension to anonymous sig-
natures. This type of revocation was introduced in EPID [28]
and allows one to revoke a platform given a signature from
that platform. Roughly, for signature-based revocation, every
signature includes a pair (B, nym) where B ←$ G1 and
nym ← Btsk . The signature revocation list SRL contains tuples
{(Bi, nymi)} from signatures of the platforms that are revoked.
When signing, the TPM must also prove that it is not the
producer of any of these revoked signatures. To do so, it proves
πSRL,i ← SPK
i } for each
tuple in SRL. Using the changes proposed by Xi et al. [8], a
host cannot input the generators Bi to the TPM anymore as
it is not able to produce proofs πBi that are required in the
TPM.Bind interface.
∗{(tsk ) : nym = Btsk ∧ nymi (cid:4)= Btsk
Random Generators via Hashing. Another approach to
remove the static DH oracle is to determine the base g by
hashing. That is, instead of inputing g in TPM.Commit, the
host provides a basename bsn E upon which the TPM derives
g ← HG1
(bsn E). By assuming that the hash function is a
random oracle, g is now enforced to be a random instead of
a chosen generator which avoids the static DH oracle, as the
host can no longer create the large q-SDH sequences that are
the basis of the static DH attacks.
Interestingly, this approach was included in the revision
from TPM 1.2 to TPM 2.0 to avoid another static DH oracle
that was present in the earlier standard. In TPM 1.2, the
TPM.Commit interface received a generator j instead of bsn L
and directly computed K ← jtsk and L ← jr, whereas
TPM 2.0 now receives bsn L and ﬁrst derives j ← HG1 (bsn L).
While applying the same idea on g would solve the prob-
lem, it would also signiﬁcantly limit the functionality of the
TPM interface. Recall that TPM 2.0 was designed to support
both, LRSW- and q-SDH-based DAA schemes. While q-SDH
schemes could be easily ported to these new interfaces, no
current LRSW-based scheme would be supported. All existing
LRSW-based schemes require the TPM to prove knowledge of
d = btsk for a generator b ← ay chosen by the DAA issuer. As
the issuer must be privy of the discrete logarithm y, it cannot
produce a basename bsn E such that b = HG1 (bsn E) holds at
the same time.
Another protocol that would, in its current forms, not be
compatible with this change is the aforementioned signature-
based revocation [28], which needs the TPM to use basenames
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
Bi deﬁned in the revocation list SRL. Camenisch et al. [10]
recently proposed to use B ← HG1 (bsn) instead of B ←$ G
to avoid the DH oracle, i.e., the TPM gets bsn as input and
the SRL has the form {(bsn i, nymi)}. However, the authors
did not detail how the TPM interfaces have to be changed
to support this approach. In fact, their protocol is not easily
instantiable, as their proposed computations by the TPM for
generating the proofs πSRL,i would require the TPM to keep
state, which in turn would require new TPM commands.
1
Our Approach.
In this work we follow the idea of using
hash-based generators but thoroughly describe the necessary
changes to the TPM 2.0 speciﬁcation and, in addition, are
very conscious to optimize our solutions. Most importantly,
our proposed modiﬁcations do not require any new TPM
commands, but modify the existing ones only slightly. To
demonstrate the ﬂexibility of our TPM interface we present a
generic protocol that allows to create a wide class of signature
proofs of knowledge using these TPM commands. The existing
LRSW-based DAA and signature-based revocation protocols
cannot be used with our interface due to the aforementioned
issues. We therefore also propose new protocols for signature-
based revocation and LRSW-based DAA that are compatible
with the proposed TPM interfaces and provably secure.
4. THE REVISED TPM 2.0 INTERFACE
This section introduces new TPM 2.0 interfaces for creating
signature proofs of knowledge. The TPM creates keys with
the TPM.Create command. Messages can be signed by ﬁrst
calling TPM.Commit, followed by a TPM.Hash and a TPM.Sign
command. We ﬁrst discuss our proposed modiﬁcations to these
commands and how they address the problems mentioned
in Sec. 3. Indeed, we are able to do that by making only
minor modiﬁcations to the commands. The description of our
revised TPM interfaces is presented in Fig. 1. We again use a
simpliﬁed notation and refer for the full speciﬁcation of our
TPM 2.0 interfaces to the full version of this paper.
Avoiding a Subliminal Channel. To solve the unforgeability
problem discussed in Sec. 3, a nonce to which the TPM
contributed needs to be included in the computation of the
(cid:3). Thereby, a malicious TPM must not
Fiat-Shamir challenge c
be able to alter the distribution of the signature proofs of
knowledge, as this would break the privacy, which is the key
goal of anonymous attestation. For this reason, the nonce needs
to be computed jointly at random by the TPM and the host. In
TPM.Commit, the TPM chooses a nonce nt and commits to that
nonce by computing ¯nt ← H(“nonce”, nt). The host picks
another nonce nh, and gives that as input to TPM.Sign. The
TPM must use nt⊕nh in the Fiat-Shamir hash. An honest host
takes nh uniformly at random, which guarantees that nt ⊕ n
h
is uniform random, preventing a malicious TPM from hiding
messages in the nonce.
Avoiding the DH Oracle. The TPM.Commit command is
changed to prevent a static Difﬁe-Hellman oracle. The oracle
exists in the current TPM 2.0 interface because therein a host
can pass any value g to the TPM and obtain gtsk . Our revised
TPM prevents this as it will only use a generator ˜g that is
either ˜g ← HG1
(bsn E) for some bsn E it receives, or set to
˜g ← ¯g if bsn E = ⊥ where ¯g denotes the ﬁxed generator used
within the TPMs.
Clearly, the host can no longer abuse this interface to learn
information about the TPM secret key tsk. If ˜g = ¯g, the
(bsn E)
host receives tpk which it already knows. If ˜g = HG1
and we model the hash function as a random oracle, the host
receives a random element raised to power tsk, which does not
give the host useful information. More precisely, the proof of
Lemma 2 shows that we can simulate a TPM without knowing
tsk, which proves that the TPM does not leak information
on tsk. Although our changes limit the generators that the
host can choose, Sec. 5.2 shows that we can still build DAA
schemes based on q-SDH and LRSW on top of this interface,
including support for signature-based revocation.
4.1 Zero-knowledge Proofs with the TPM
We now describe how our proposed TPM interfaces can be
used to create a wide class of signature proofs of knowledge.
To demonstrate the ﬂexibility of our interface we propose a
generic proof protocol Prove that orchestrates the underlying
TPM commands. We then show that proofs generated by Prove
are unforgeable, device-bound and remain zero-knowledge
even if the TPM is subverted. Thus, protocol designers can
use our Prove protocol as generic building block for more
complex protocols instead of having to use the TPM command
and proving these security properties from scratch. Our DAA
protocols presented in Sec. 5 use exactly that approach.
A Generic Prove Protocol. Using the proposed TPM inter-
faces, a host can create signature proofs of knowledge of the
following structure:
i
b
y3 =
(1)
for values δ, hsk , tsk, and γ in Zp, strings bsn L, mh, mt ∈
{0, 1}∗, group elements y1, y2, y3, ˆg, and set {(αi, bi, b
i )}i,
(cid:3)
(cid:3)(cid:3)
i, b
with αi ∈ Zp. Either y1, ˆg, and all bi’s are in G1 or they are
i values and y2 must be in G1. If bsn L = ⊥,
(cid:3)
all in GT . All b
the second equation proving a representation of y2 is omitted
from the proof. We could also lift this part of the proof to GT
but as we do not require such proofs, we omit this to simplify
(cid:3)(cid:3)
the presentation. The values y3 and b
i must either all be in
G1, in G2, or in GT .
In addition we require that the TPM works with a cleared
generator, meaning either ˆg = ˜g or ˆg = e(˜g, ˆg2) with ˜g
denoting the cleared generator being either ¯g, i.e., the ﬁxed
generator or it is HG1
(bsn E) for some bsn E.
905
SPK
y1 = (ˆg
∗{(γ · (tsk + hsk ), α1, . . . , αl) :
(cid:4)
αi ∧
δ)γ·(tsk +hsk ) ·
bi
(cid:4)
(bsn L)γ·(tsk +hsk ) ·
(cid:4)
y2 = HG1
i
i
(cid:3)
i
αi ∧
b
αi}(mh, mt) ,
(cid:3)(cid:3)
i
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
Session system parameters: G1 = (cid:5)¯g(cid:6) of prime order q, nonce bit
length ln, random oracles H : {0, 1}∗ → Zp and HG1 : {0, 1}∗ →
G1. Initialize Committed ← ∅ and commitId ← 0.
Init. On input TPM.Create():
• If this is the ﬁrst invocation of TPM.Create, choose a fresh
secret key tsk ←$ Zp and compute public key tpk ← ¯gtsk .
• Store tsk and output tpk.
Hash. On input TPM.Hash(mt, mh):
• If mt (cid:4)= ⊥, the TPM checks whether it wants to attest to mt.
• Compute c ← H(“TPM ”, mt, mh).
• Mark c as “safe to sign” and output c.
(bsn E), otherwise set ˜g ← ¯g.
Commit. On input TPM.Commit(bsn E, bsn L):
• If bsn E (cid:4)= ⊥, set ˜g ← HG1
• Choose r ←$ Zp, nt ←$ {0, 1}ln and store (commitId , r, nt) in
Committed.
• Set ¯nt ← H(“nonce”, nt), E ← ˜gr, and K, L ← ⊥.
• If bsn L (cid:4)= ⊥, set j ← HG1 (bsn L), K ← jtsk and L ← jr.
• Output (commitId , ¯nt, E, K, L) and increment commitId.
Sign. On input TPM.Sign(commitId , c, nh):
• Retrieve
record (commitId , r, nt)
and remove
Committed, output an error if no such record was found.
• If c is safe to sign, set c