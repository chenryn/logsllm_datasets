匹配嵌套结构..
1\(（??( $NestedStuffRegex )）\)
}x;
sub SimpleConvert（$);#
递归调用，必须预声明
sub SimpleConvert($)
1
my Sre = shift;
要处理的表达式
$re =~ s{
）。#\）\
\w+））>
#S1是标识符
（$NestedStuffRegex)
#S2-可能出现的嵌套结构
\)
（。#
my $id= $1;
my $guts = SimpleConvert($2);
#把
#(?guts)
#改为
#(?:
Snb#（sn6）
#(?(
#
（（#
#）
·（？:（$guts）（？（1ocal（\ST{'$id'}）=\SN }））"
)xeog:
return $re;
#返回处理结果
sub MungeRegexLiteral(S)
my（SRegexLiteral）=@_;
#参数为字符事
#print "BEFORE:$RegexLiteral\n*;
调试时取消注释
my Snew = SimpleConvert($RegexLiteral);
if (Snew ne $RegexLiteral)
---
## Page 373
效率
347
{
my Sbefore=q/（?（1ocal（&~T）=（）3)/:#本地化临时hash变量
mySafter = q/(?($^N= ^T }）/;
#把它们拷贝到"真正的"hash变量
SRegexLiteral = *$before(?:$new) Safter";
#print“AFTER:$RegexLiteral\n";
#调试时取消注释
return $RegexLiteral;
）
1 ;
效率
Perl Efficicucy Issues
在大多数情况下，Perl中正则表达式的效率问题与任何使用传统NFA的工具一样。第6章
介绍的技巧-—内部优化、消除循环，以及“开动你的大脑”，都适用于Perl。
当然，Perl也有专属于自己的问题，这一节我们就来看看：
·办法不止一种Perl就像一个工具箱，同一种问题可以用许多办法来解决。理解了Perl
的思维方式，就会明白哪些问题是钉子，但是选择合适的锤子还需要花很多工夫来编
写高效而易于理解的程序。有时候，效率和易于理解似乎是不相容的，不过一旦理解
深人了，就能做出更好的选择。
·表达式编译、qr/…/、/o修饰符和效率正则运算符的编译和插值，做得好的话能节
省大量的时间。/o修饰符还没有详细讲解，它配合regex对象(qr/…/)，能够调控耗
费时间的重编译过程。
$&的负面影响伴随效应设定的变量S、S&和S'，也许很方便，但存在不易发现的效率
陷阱，哪怕只出现了一次，也可能带来麻烦。所以并不是非得使用它们-一只要脚本
中出现了任意一个变量，负面影响就不可避免。
Study函数近年来，Perl提供了study（.)函数。按照预期，它能提高正则表达式的
速度，但是似乎没有人真正知道它是否能提高速度，以及背后的原因。
性能测试性能测试的规矩就是，越快的程序终止得越早（你可以引用我的话）。无论
小型函数、大型函数，还是处理真实数据的整个程序，性能测试都是判断速度的最终
标准。尽管性能测试有各种各样的办法，Perl中的性能测试却是简单而轻松的。我会
给出我用的办法，这个办法在写作本书时做过数百次性能测试。
正则表达式调试Perl的正则表达式调试标识位（debugflag）可以告诉我们，正则引擎
和传动装置对正则表达式进行了哪些优化。下面会讲解如何查看这些信息，以及Perl
包含了哪些秘密。
---
## Page 374
348
第7章：Perl
办法不只一种
Tlicres More Than One Way to Do It "
通常，一个问题总是有许多种解法，所以在权衡效率和可读性时，应该做的就是了解所有
的办法。来看个简单的问题，修改个IP地址，例如‘18.181.0.24'，保证每一段都包含
三位数字：“018.181.000.024。简单的办法是：
Sip = sprintf(*$03d.03d.$03d.$03d*,split(/\./，$ip));
这办法当然没错，但显然还有其他的解决办法。表7-6列出了好几种办法，比较了它们的效
率（按照效率排序，最上面的效率最高)。这个例子的目的很简单，本身也没有太多价值，
但是它能代表简单的文本处理任务，所以我鼓励你花一点时间理解各种办法。可能有些技
巧你没见过。
如果输入格式正确的IP，每个办法都能到正确的结果，但是如果输入别的数据则可能会出
错。如果数据是不规范的，可能就需要多花点心思。除此之外，实际差别在于效率和可读
性。就可读性而言，#1和#13似乎是最好理解的（尽管效率上存在巨大的差异）。同样易于
理解的是#3和#4（类似#1），以及#8（类似#13）。其他解法都太过复杂了。
那么效率呢？为什么不同的解法有不同的效率？原因在于NFA的工作原理（第4章），Perl
的各种正则优化措施（第6章），以及其他Perl结构的处理速度（例如sprintf，以及
substitution运算符的机制)。substitution运算符的/e修饰符，有时候虽然不可或缺，但效率
低的解法似乎都使用了它。
比较#3和#4，#8和#14很有意义。这两对正则表达式的区别只是在于括号—没有括号的
表达式要比有括号的稍快一点。#8使用S&来避免括号带来的高昂代价，性能测试却无法体
现这-点（355）。
表达式编译、/o修饰符、qr//和效率
RegexCompilation,thefoModifier.qd/,and Efficiency
Perl中与表达式效率相关的另一个重点是，程序遇到正则运算符之后，在实际应用正则表达
---
## Page 375
效率
349
表7-6：填补IP地址的若干解法
排名
耗时
解法
1
1.0X
$ip = sprintf("$03d.$03d.$03d.$03d*, split(m/\./, $ip));
substr($ip,0, 0）=*0·if substr($ip,1, 1）eq'.′;
substr($ip，0,0）=*0′if substr($ip,2，1）eq'.′;
substr($ip,4,0）=*0if substr($ip,5,1）eq'.′;
2
1.3X
substr($ip，4，0）=*0·if substr($ip, 6, 1）eq'.;
substr($ip,8,0)='0′if substr($ip,9,1）eq'.';
substr($ip，8,0）='0·if substr($ip,10,1）eq'.′;
substr($ip,12,0）=0′while length($ip）)[(localtime)[6]];
#Stoday保存的是星期数（"Mon”，"Tue"之类）
while()(
if (m/^$today:/i）{
m/^Stoday：/中的正则表达式需要插值，虽然在循环中使用，但每轮循环的插值结构是相
同的。所以一再重复编译同样的表达式的效率很低，所以Perl会自动进行简单的字符串检
查，比较本次和上次插值的结果。如果相同，就使用上次的缓存。如果不同，就重新编译
正则表达式。所以，对比缓存值并重新插值尽可能避免了相对更耗时的编译。
这样究竟能节省多少时间呢？非常多。举例来说，我测试了第303页的SHttpUr1（使用扩
展的SHostnameRegex）的三种预处理方式。设计的性能测试能准确体现预处理的开销（使
用插值、字符串检查、编译，以及其他后台任务），而不是表达式应用的整体开销，因为在
任何情况下这种应用的时间都是一样的。
结果非常有意思。我运行了没有插值的版本（整个正则表达式都硬编码在m//中），用它
作为比较的基础。如果正则表达式每轮循环不会改变，比较并插值大概需要25倍的时间。
完整的预处理（每轮循环都要重新编译）大概需要1000倍的时间，这数字真惊人！
应用到实际场合就会发现，完整的预处理即使比静态正则文字预处理要慢1000倍，在我的
的速度是每秒370方次）。当然，不使用插值能够节省的时间非常可观，不进行重编译节省
的时间显然也很可观。下面几节，我们会考察如何在更多情况下使用这些技巧。
---
## Page 378
352
第7章：Perl
表示“一次性编译”的/修饰符
简单地说，如果正则文字运算元中使用了/o修饰符，它就会只会检查和编译一次，而无论
是否包含插值。如果没有插值，添加/不会有任何改变，因为没有插值的表达式总是会自
动缓存。但如果使用了插值，程序执行第一次遇到正则文字时，会进行正常的完整的预处
理，但因为/o的存在，内在状态会存储下来。如果之后又遇到这个正则运算元，就会直接