title:Language-based Defenses Against Untrusted Browser Origins
author:Karthikeyan Bhargavan and
Antoine Delignat-Lavaud and
Sergio Maffeis
Language-based Defenses against  
Untrusted Browser Origins
Karthikeyan Bhargavan and Antoine Delignat-Lavaud, INRIA Paris-Rocquencourt;  
Sergio Maffeis, Imperial College London
Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14‚Äì16, 2013 ‚Ä¢ Washington, D.C., USAISBN 978-1-931971-03-4Language-based Defenses against Untrusted Browser Origins
Karthikeyan Bhargavan
INRIA Paris-Rocquencourt
Antoine Delignat-Lavaud
INRIA Paris-Rocquencourt
Sergio Maffeis
Imperial College London
Abstract
We present new attacks and robust countermeasures for
security-sensitive components, such as single sign-on
APIs and client-side cryptographic libraries, that need to
be safely deployed on untrusted web pages. We show
how failing to isolate such components leaves them vul-
nerable to attacks both from the hosting website and
other components running on the same page. These
attacks are not prevented by browser security mecha-
nisms alone, because they are caused by code interact-
ing within the same origin. To mitigate these attacks,
we propose to combine Ô¨Åne-grained component isola-
tion at the JavaScript level with cryptographic mecha-
nisms. We present Defensive JavaScript (DJS), a subset
of the language that guarantees the behavior integrity of
scripts even when loaded in a hostile environment. We
give a sound type system, type inference tool, and build
defensive libraries for cryptography and data encodings.
We show the effectiveness of our solution by implement-
ing several applications using defensive patterns that Ô¨Åx
some of our original attacks. We present a model extrac-
tion tool to analyze the security properties of our appli-
cations using a cryptographic protocol veriÔ¨Åer.
1 Defensive Web Components
Web users increasingly store sensitive data on servers
spread across the web. The main advantage of this dis-
persal is that users can access their data from browsers on
multiple devices, and easily share this data with friends
and colleagues. The main drawback is that concentrat-
ing sensitive data on servers makes them tempting targets
for cyber-criminals, who use increasingly sophisticated
browser-based attacks to steal user data.
In response to these concerns, web applications now
offer users more control over who gets access to their
data, using authorization protocols such as OAuth [23]
and application-level cryptography.
These security
mechanisms are often implemented as JavaScript com-
ponents that may be included by any website, where they
mediate a three-party interaction between the host web-
site, the user (represented by her browser), and a server
that holds the sensitive data on behalf of the user.
Website	
  (W)	
Data	
  Server	
  (S)	
Db	
u‚Äôs Browser 
Web Page (HTML) 
Security	
Component	
(JavaScript)	
API 
Cookies 
Local  
Storage 
Figure 1: JavaScript Security Component
The typical deployment scenario that concerns us is
depicted in Figure 1. A website W wishes to access sen-
sitive user data stored at S. So, it embeds a JavaScript
component provided by S. When a user visits the web-
site, the component authenticates the user and exposes
an API through which W may access the user‚Äôs data, if
the user has previously authorized W at S. For authenti-
cated users on authorized websites, the component typ-
ically holds some client-side secret, such as an access
token or encryption key, which it can use to validate data
requests and responses. When the user closes or navi-
gates away from the website, the component disappears
and the website can no longer access the API.
A popular example of this scenario is single sign-on
mechanism, such as Login with Facebook (detailed in
Section 2). Facebook (S) provides a JavaScript compo-
nent that websites like Pinterest (W ) may use to request
the identity and social proÔ¨Åle of a visiting user, via an
API that obtains a secret OAuth token for the current user
and attaches it with each request to Facebook.
Other examples include payment processing APIs like
Google Checkout, password manager bookmarklets like
Lastpass, anti-CSRF protections like OWASP CSRF-
Guard, and client-side encryption libraries for cloud stor-
age services like Mega. More generally, a website may
host a number of components from different providers,
each keeping its own secrets and protecting its own API.
What we Ô¨Ånd particularly interesting is that the data
and functionality of these JavaScript components is of-
ten of higher value that the website that hosts it. This is
contrary to the usual web security threat model where
USENIX Association  
22nd USENIX Security Symposium  653
1
a website tries to defend itself from third-party com-
ponents. Instead, we consider components that are de-
signed to increase security of a website by delegating
sensitive operations (e.g. password storage, credit card
approval) to trusted third-party servers. For the data han-
dled by such components, we seek to offer a limited se-
curity guarantee to the user. If a user temporarily vis-
its (and authorizes) a compromised website W , any data
read by the website during the visit may be leaked to the
adversary, but the user can still expect the component to
protect long-term access to her data on S. Our aim is
not to prevent compromises in W or to prevent all data
leaks. Instead, we enable a robust defense-in-depth strat-
egy, where the security mechanisms of a website do not
completely break if it loads a single malicious script.
Goals, Threats, and Attacks. Our goal is to design
hardened JavaScript components that can protect sensi-
tive user data and other long-term secrets such as access
tokens and encryption keys from unauthorized parties.
So far, such goals have proven surprisingly hard to guar-
antee for components written in JavaScript that run in
the browser environment and interact with standard web-
sites (e.g. see [1, 5, 6, 10, 41, 42]). What makes such
components so hard to secure?
In Section 2, we survey the state of the art in three
categories of security components: single sign-on mech-
anisms, password managers, and client-side encryption
libraries used for cloud storage. We Ô¨Ånd that these com-
ponents must defend against three kinds of threats. First,
they may be loaded into a malicious website that pretends
to be a trusted website. Second, even on a trusted web-
site they may be loaded alongside other scripts that may
innocently (or maliciously) modify the JavaScript builtin
objects in a way that changes the runtime behavior of the
component. Third, some webpage on the same domain
(or subdomain) as W may either host malicious user-
provided content or might contain a cross-site scripting
(XSS) attack or any number of web vulnerabilities.
We found that the defenses against these threats prove
inadequate for many of the components in our survey.
We report previously-unknown attacks on widely-used
components that completely compromise their stated se-
curity goals, despite their use of sophisticated protocols
and cryptographic mechanisms. Our attacks exploit a
wide range of problems, such as bugs in JavaScript com-
ponents, bugs in browsers, and standard web vulnerabili-
ties (XSS, CSRF, open redirectors), and build upon them
to fool components into revealing their secrets. Eliminat-
ing speciÔ¨Åc bugs and vulnerabilities can only be a stop-
gap measure. We aim instead to design JavaScript com-
ponents that are provably robust against untrusted hosts.
Same Origin Policy (SOP). Most browser security
mechanisms (including new HTML5 APIs, such as




Browser 
Web Page (HTML) 
age
API 













Cookies 
Local  
Storage 
DJS checker 
no 
defensive? 
yes 
	


secu
?
secure? 
yes 
no 
nono 
ProVerif 
Figure 2: DJS Architecture
postMessage, localStorage, and WebCrypto) are based
on the origin from which a webpage was loaded, deÔ¨Åned
as the domain of the website and the protocol and port
used to retrieve it (e.g. https://facebook.com:443). The
SOP isolates the JavaScript execution environments of
frames and windows loaded from different origins from
each other.
In contrast, frames from the same origin
can directly access each other‚Äôs variables and functions,
across a page and even across windows.
The SOP does not directly apply to our scenario since
our components run in the same origin as the host web-
site. To use the SOP, components must open new frames
or windows on a separate origin and implement a mes-
saging protocol between them and the host website. As
we show in Section 2, such components are difÔ¨Åcult to
get right and the JavaScript programs that implement
them require close analysis.
Our Proposal. We advocate a language-based approach
that is complementary to the SOP and protects scripts
running in the same origin from each other. This enables
a defense-in-depth strategy where the functionality and
secrets of a component can be protected even if some
page on the host origin is compromised.
We propose a defensive architecture (Figure 2) that en-
ables developers to write veriÔ¨Åed JavaScript components
that combine cryptography and browser security mecha-
nisms to provide strong formal guarantees against entire
classes of attacks. Its main elements are:
DJS: A defensive subset of JavaScript, with a static type
checker, for writing security-critical components.
DJS Library: A library written (and typechecked) in
DJS, with cryptographic and encoding functions.
DJS2PV: A tool that automatically analyzes the compo-
sitional security of a DJS component by translating
it to the applied pi calculus for veriÔ¨Åcation when
combined with models of the browser and DJS li-
brary, using the ProVerif protocol analyzer.
Script Server: A veriÔ¨Åed server for distributing defen-
sive scripts embedded with session-speciÔ¨Åc encryp-
tion keys.
654  22nd USENIX Security Symposium 
USENIX Association
2
Our architecture relies on the willingness of devel-
opers to program security-critical code in DJS, a well-
deÔ¨Åned restricted subset of JavaScript.
In return, they
obtain automated analysis and strong security guarantees
for their code. Moreover, no restriction is enforced on
untrusted code. In order to verify authentication and se-
crecy properties of the defensive components once em-
bedded in the browser, we rely on ProVerif [13], a stan-
dard protocol veriÔ¨Åcation tool that has been used exten-
sively to analyze cryptographic mechanisms, with the
WebSpi library [6], a recent model for web security
mechanisms. Unlike previous works that use WebSpi,
we automatically extract models from DJS code.
As we show in Section 6, DJS can signiÔ¨Åcantly im-
prove the security of current web applications with min-
imal changes to their functionality. Emerging web se-
curity solutions, such as Content Security Policy, EC-
MAScript 5 Strict, and WebCryptoAPI, offer comple-
mentary protections, and when they become widespread,
they may enable us to relax some DJS restrictions, while
retaining its strong security guarantees.
Towards Defensive JavaScript. A cornerstone of our
defensive architecture is the ability of trusted scripts
to resist same-origin attacks, because requiring that all
scripts on an origin be trusted is too demanding. We
investigate language-based isolation for such trusted
scripts, and identify the defensive JavaScript problem:
DeÔ¨Åne a defensive subset of JavaScript to write state-
ful functions whose behavior cannot be inÔ¨Çuenced (be-
sides by their arguments) by untrusted code running in
the same environment, before or after such functions are
deÔ¨Åned. Untrusted code should not be able to learn se-
crets by accessing the source code of defensive functions
or directly accessing their internal state.
This problem is harder than the one tackled by
JavaScript subsets such as ADsafe [16] or Caja [40],
which aim to protect trusted scripts by sandboxing un-
trusted components. In particular, those subsets assume
the initial JavaScript environment is trusted, and that all
untrusted code can be restricted. In our case, defensive
code must run securely in a JavaScript engine that is run-
ning arbitrary untrusted code.
Contributions. Our main contributions are:
1. We identify common concerns for applications that
embed secure components in arbitrary third party
websites, and new attacks on these applications;
2. We present DJS, a defensive subset of JavaScript for
programming security components. DJS is the Ô¨Årst
language-based isolation mechanism that does not
restrict untrusted JavaScript and does not rely on a
Ô¨Årst-running bootstrapper;
3. We develop tools to verify that JavaScript code is
valid DJS, and to extract ProVerif models from DJS;
4. We deÔ¨Åne DJCL, a defensive crypto library with en-
coding and decoding utilities that can be safely used
in untrusted JavaScript environments. DJCL can be
included as is on any website;
5. We identify general patterns that leverage DJS and
cryptography to enforce component isolation in the
browser, and in particular, we propose Ô¨Åxes to sev-
eral broken web applications.
Supporting materials for this paper, including code,
demos, and a technical report with proofs are available
online [11].
2 Attacks on Web Security Components
We survey a series of web security components and in-
vestigate their security; Table 1 presents our results. Our
survey focuses on three categories of security compo-
nents that implement the pattern depicted in Figure 1.
Single Sign-On Buttons:(e.g. Facebook login on Hulu)
W loads a script from S that allows it to access the
veriÔ¨Åed identity of u at S, and possibly other social
data (photo, friend list, etc.).
Password Managers: (e.g. LastPass, 1Password)
u installs a browser plugin or bookmarklet from S;
when the browser visits W , the plugin retrieves an