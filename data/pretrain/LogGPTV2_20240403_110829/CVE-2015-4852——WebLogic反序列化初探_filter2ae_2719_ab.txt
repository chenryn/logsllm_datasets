[@SuppressWarnings](https://github.com/SuppressWarnings "@SuppressWarnings") –
指示编译器去忽略注解中声明的警告。
作用于其他注解的注解(又称元注解)是如下4个，
[@Retention](https://github.com/Retention "@Retention") –
标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问；
[@Documented](https://github.com/Documented "@Documented") – 标记这些注解是否包含在用户文档中；
[@Target](https://github.com/Target "@Target") – 标记这个注解应该是哪种 Java 成员，即指定
Annotation 的类型属性；
[@Inherited](https://github.com/Inherited "@Inherited") – 标记这个注解是继承于哪个注解类(默认
注解并没有继承于任何子类)。
###  6.Java 代理
代理模式是一种设计模式，提供了对目标对象额外的访问方式，即设置一个中间代理，通过代理对象访问目标对象，提供了对目标对象额外的访问方式，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能，以达到增强原对象的功能和简化访问方式。
Java提供了三种代理模式：静态代理、动态代理和cglib代理。  
静态代理方式需要代理对象和目标对象实现一样的接口。  
优点：可以在不修改目标对象的前提下扩展目标对象的功能；  
缺点：①冗余由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。②不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。  
动态代理利用了JDK API，动态地在内存中构建代理对象，从而实现对目标对象的代理功能。动态代理又被称为JDK代理或接口代理。  
静态代理与动态代理的区别主要在于静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件，而动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中。  
特点：动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。
## 三、漏洞 CVE-2015-4852
###  1.概述
​ CVE-2015-4852在10.3.6.0, 12.1.2.0, 12.1.3.0和12.2.1.0版本的WebLogic
Server上均可被利用，此漏洞允许攻击者通过T3协议和TCP协议服共用的7001端口进行远程命令执行。
漏洞产生的原因是org.apache.commons.collections组件存在潜在的远程代码执行漏洞，实际上触发漏洞应用的是Java正常的反序列化部分机制，只是在这个Java反序列化中，对于传入的序列化数据没有进行安全性检查，将恶意的对象反序列化，有可能导致RCE。
调用栈：
    transform:125, InvokerTransformer (org.apache.commons.collections.functors)
    transform:122, ChainedTransformer (org.apache.commons.collections.functors)
    get:157, LazyMap (org.apache.commons.collections.map)
    invoke:51, AnnotationInvocationHandler (sun.reflect.annotation)
    entrySet:-1, $Proxy57 (com.sun.proxy)
    readObject:328, AnnotationInvocationHandler (sun.reflect.annotation)
    invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
    invoke:39, NativeMethodAccessorImpl (sun.reflect)
    invoke:25, DelegatingMethodAccessorImpl (sun.reflect)
    invoke:597, Method (java.lang.reflect)
    invokeReadObject:969, ObjectStreamClass (java.io)
    readSerialData:1871, ObjectInputStream (java.io)
    readOrdinaryObject:1775, ObjectInputStream (java.io)
    readObject0:1327, ObjectInputStream (java.io)
    readObject:349, ObjectInputStream (java.io)
    readObject:66, InboundMsgAbbrev (weblogic.rjvm)
    read:38, InboundMsgAbbrev (weblogic.rjvm)
    readMsgAbbrevs:283, MsgAbbrevJVMConnection (weblogic.rjvm)
    init:213, MsgAbbrevInputStream (weblogic.rjvm)
    dispatch:498, MsgAbbrevJVMConnection (weblogic.rjvm)
    dispatch:330, MuxableSocketT3 (weblogic.rjvm.t3)
    dispatch:387, BaseAbstractMuxableSocket (weblogic.socket)
    readReadySocketOnce:967, SocketMuxer (weblogic.socket)
    readReadySocket:899, SocketMuxer (weblogic.socket)
    processSockets:130, PosixSocketMuxer (weblogic.socket)
    run:29, SocketReaderRequest (weblogic.socket)
    execute:42, SocketReaderRequest (weblogic.socket)
    execute:145, ExecuteThread (weblogic.kernel)
    run:117, ExecuteThread (weblogic.kernel)
###  2.原理
在开始之前我们先理一下反序列化漏洞的大体攻击流程：
​ 1.客户端先构造可在服务端执行的payload，并进行多环（或层）的封装，形成可以在服务端使用的exp；
​ 2.
exp发送到服务端，进入一个服务端的readObject函数（一般是被重写过的，可能是服务端程序自己重写的，也可能是引入的某个库重写的），在此过程中若是顺利进入某个点即可触发整个链，进而会反序列化恢复我们构造的exp中的对象；
​ 3.如果exp构造正确，则会逆着我们构造、封装的顺序一层层解封（触发）；
​ 4.最终在一个可执行任意命令的函数中执行最后的payload，完成RCE。
我们可以推断，完成这些需要三个必要条件：
​ 1. payload：我们要让服务端执行的代码；
​ 2.构造好的反序列化利用链：服务端中触发的构造好的的反序列化利用链，会一层层剥开我们的exp，最后执行payload；
​ 3. 服务端的readObject重写点：在服务端对某个类重写的readObject中，可能会调用我们需要的函数，能够触发整个链的起点。
在网上的资料中，我了解到Commons
Collections中有几个常用的类，在ysoserial中多有体现，比如四个Tranformer（ChainedTransformer、InvokerTransformer、ConstantTransformer、InstantiateTransformer），三个Map（lazyMap、TiedMapEntry、HashMap），和五个反序列化利用基类（AnnotationInvocationHandler、PriorityQueue、BadAttributeValueExpException、HashSet、Hashtable）。
这里面对于CVE-2015-4852来说，大概的流程是这样的，
用到的是上面提到的类中的一小部分，下面的三个小节中会慢慢讲到。
对我这样一个修为不够且刚接触Java反序列化漏洞的初学者来说，CVE-2015-4852的整个利用链是比较复杂的，我根据个人的理解，将其再分为3个段，构造时按1、2、3的顺序构造，利用时按3、2、1的顺序触发。接下来将对这三段做个简述，至于段内每个对象和类的特性、分段的依据和段与段之间的衔接点等细节会在下面的三个小节中讲到。
（一）段1：
Runtime.getRuntime().exec(“calc”);
​ Runtime类是这一段的起点；exec(“calc”)是此段的终点，也是整个利用链的终点。
想要触发这一段，只需要在构造好段内对象的前提下，调用ChainedTransformer.transform。
（二）段2：
段2有几种思路，都可行，挑两种介绍一下，
一是以TransformedMap为起点，链为  
setValue ()-> checkSetValue() -> valueTransformer.transform(value);
二是以LazyMap为起点，链为  
get(Object key)->this.factory.transform(key);
（三）段3：
对应上面的段2，段3也有两种差别不大的走法，
一是以TransformedMap为终点，链为  
AnnotationInvocationHandler（以构造好的
TransformedMap为成员变量）->readObj->TransformedMap.setvalue;
二是以LazyMap为终点，链为
AnnotationInvocationHandler.invoke -> LazyMap.get()
####  2.1 段1
先构造第一段，这一段是和PHP中反序列化相似度比较高的一段，相对而言理解起来比较简单、老套，只是环节比较多，再加上Java语言的一些特性，一开始看理解起来稍有费力。
先介绍这一段的几个主角：Apache Commons
Collections中的Transformer类。这一众类的功能就是将一个对象转换为另外一个对象，我们这里会用到的有：
invokeTransformer（通过反射，返回一个对象），  
ChainedTransformer（把多个transformer连接成一条链，对一个对象依次通过链条内的每一个transformer进行转换），  
ConstantTransformer（把一个对象转化为常量，并返回）。
首先是invokeTransformer类和transform方法，
可以看到，transform方法会通过反射机制调用input的method函数，调用transform需要的参数只有一个input，其余的参数均可控，我们可以在构造InvokerTransform时写好。  
我们前面提到，要想调用exec函数，需要当前进程的Runtime对象，我们无法直接得到，只能通过getRuntime()方法获取当前Runtime对象的引用，再调用invoke()和exec()函数。
这里写个demo看下，
    import org.apache.commons.collections.functors.InvokerTransformer; 
    public class InvokerTransformerTest 
    { 
        public static void main(String[] args){ 
            InvokerTransformer InvokerTransformer = new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{new String("calc")});                  InvokerTransformer.transform(Runtime.getRuntime()); 
       } 
     }
这里只是个demo，我们可以直接通过Runtime类调用getRuntime函数，进而执行Runtime对象的exec(“calc”)函数。但实际上，CC里没有重写InvokerTransformer.readObject()，更不要说内部InvokerTransformer.transform了，所以根据我们前面所说，这样的payload必须经过封装改写才能利用。想要找到InvokerTransformer在利用链中的上一级，就要找到InvokerTransformer.
transform可能的调用点。
这就用到ChainedTransformer了，
ChainedTransformer以一个Transformer数组为成员变量，并在ChainedTransformer.transform中调用了每个Transformer的transform函数。