title:DroidCap: OS Support for Capability-based Permissions in Android
author:Abdallah Dawoud and
Sven Bugiel
DroidCap: OS Support for Capability-based
Permissions in Android
Abdallah Dawoud
Sven Bugiel
CISPA Helmholtz Center for Information Security
CISPA Helmholtz Center for Information Security
abdallah.dawoud@cispa.saarland
bugiel@cispa.saarland
Abstract—We present DROIDCAP, a retroﬁtting of Android’s
central Binder IPC mechanism to change the way how per-
missions are being represented and managed in the system.
In DROIDCAP, permissions are per-process Binder object-
capabilities. DROIDCAP’s design removes Android’s UID-based
ambient authority and allows the delegation of capabilities
between processes to create least-privileged protection domains
efﬁciently. With DROIDCAP, we show that object-capabilities
as underlying access control model
integrates naturally and
backward-compatible into Android’s stock permission model and
application management. Thus, our Binder capabilities provide
app developers with a new path to gradually adopting app com-
partmentalization, which we showcase at two favorite examples
from the literature, privilege separated advertisement libraries
and least privileged app components.
I.
INTRODUCTION
Android, like other mobile platforms, employs an access
control model in which applications (apps) have to request
privileges—permissions in Android’s jargon—to access user
data and system resources. Once granted, those permissions
are assigned to app sandboxes, deﬁned by each apps’ UID in
the system. Thus, the permissions associated with the UID of
each process constrain the process’ access to (system) services,
other apps, or ﬁle-system objects.
This design decision to attribute permissions to app sand-
boxes at
the level of UIDs combines characteristics from
capability-based access control systems (i.e., the attributes of
the subject and not its identity matter) with those of list-
based access control models (i.e., the UID forms an ambient
authority for all processes executing under the UID). The
existence of an ambient authority on Android has been shown
problematic for the users’ privacy when app developers mix
app code with non-trustworthy code from other origins, where
particularly advertisement libraries have repeatedly exhibited
privacy-intrusive behavior [25], [12], [21], [62], [61] that
exploits the fact that the library code inherits all privileges
from its host app’s UID, i.e., its ambient authority. Moreover,
permissions enforced by the Linux kernel through Linux GIDs,
such as internet or Bluetooth access [6], are statically assigned
at app install-time to the app UID and are hence particularly
hard to manage in a ﬂexible manner that allows easy delegation
Network and Distributed Systems Security (NDSS) Symposium 2019
24-27 February 2019, San Diego, CA, USA
ISBN 1-891562-55-X
https://dx.doi.org/10.14722/ndss.2019.23398
www.ndss-symposium.org
or revocation. We argue that this combination of characteristics
that retains an ambient authority generally impedes efﬁciently
separating privileges on Android and makes it unnecessarily
hard for developers to efﬁciently create new, least-privileged
protection domains and adopting app compartmentalization
best-practices. For instance, every component of an app in-
herits its app’s full permission set and also prior works on
privilege separation [52], [59], [71], [29], [18] necessarily have
to set up new UIDs with separate permissions. There exist
some works that reﬁne the authority: for instance, SEAndroid’s
type enforcement [60] assigns security contexts to processes;
different solutions on information ﬂow control (e.g., [45], [46],
[70]) assign security labels to processes; few solutions make
app components the principal for permission enforcement [64],
[57]; and app virtualization [9], [11] can enforce policies per-
process on IPC and syscalls. However, the status quo is amiss
with the practical needs for efﬁciently enabling privilege sepa-
ration and providing developers with a path for least-privilege
code compartmentalization, as commonly adopted by security-
critical apps [54], [35]. Per-process privileges alone are not
sufﬁcient, but also efﬁciently creating new protection domains
through delegation and revocation of privileges is key and is
currently not sufﬁciently supported (see also Section VI).
In this paper, we propose object-capabilities as a way to
achieve per-process permissions together with the efﬁcient
delegation of privileges between processes. Drawing from
past and current experiences on object-capability systems,
we shift Android’s permission model closer to an object-
capability system. Capability-based access control has been
historically around [19], [23], [68], [37], [38], [49]—where it
found use in high-assurance and distributed systems, such as
EROS [58], IBM System/38 [28], iMAX 432 [33], CAP [48],
or Amoeba [43]—and has recently been proposed for modern
end-user systems, such as a new security feature for conven-
tional systems like UNIX/Linux [65], [20], hybrid systems like
CHERI [66], or new microkernel-based systems like Google’s
Fuchsia [24]. Our solution adds to this recent developments.
We show that an object-capability system not only ﬁts well
to Android’s system model and realizing permissions, but
also how such a model supports app developers in adopt-
ing privilege separation and ﬁne-grained, dynamic permission
management for least-privilege operation on Android more
efﬁciently.
At the heart of our paradigm shift for representing per-
missions in Android is an extension to Android’s Binder
IPC mechanism. Binder IPC is the primary IPC channel for
communication among all apps and between system services
and apps. Binder allows processes to hold kernel-managed
references (or handles) to remote processes that
they can
call via Binder IPC. The fundamental idea of our solution,
called DROIDCAP, is to extend those Binder references to
reﬂect the privileges against the remote process—a form of
”extended Binder attributes” akin to the concept of ”extended
ﬁle attributes.” Since Binder references are process-speciﬁc,
just like ﬁle handles, every reference forms a unique, kernel-
managed ”token” that associates a caller process with a remote
process and the caller’s privileges for that particular remote
process. By default, Android allows a free delegation of
Binder references between processes via the Binder kernel
module. We augment
this vanilla delegation with 1) poli-
cies that govern how processes can delegate references to
other processes in order to prevent leakage of privileges, and
2) management functionality to support delegation of subsets
of permissions as well as efﬁcient revocation of permissions
from a (delegated) Binder reference. We integrate our Binder-
based capabilities into Android’s app life-cycle management,
permission management, and permission enforcement (e.g.,
within Android’s system services). As a result, in DROIDCAP
we have a permission enforcement that relies entirely on the
Binder references (or tokens) a calling process holds instead
of the caller’s UID (i.e., no UID-based ambient authority).
We also have a clear permission delegation hierarchy between
system and app processes that reﬂects the stock permission
granting on Android but allows an efﬁcient (re-)delegation
of permissions between processes to create new protection
domains (i.e., new processes with delegated permissions).
To also cater for permissions enforced through Linux’ GIDs
facility, we explain the integration of Capsicum for Linux [20]
into DROIDCAP to represent ﬁle-system-related permissions as
Capsicum capabilities for ﬁle-handles. In particular, we discuss
the peculiarities of Android’s Zygote that had to be overcome
to put app processes into Capsicum’s capability mode.
As a result, DROIDCAP occupies a previously unexplored
niche in Android security extensions: By blending permissions
with Binder capabilities, we enable efﬁcient least-privilege
operation of processes while preserving existing Android
APIs and the application model. This backward compatibil-
ity presents developers with a path for gradually adopting
capability-oriented permissions and decomposing apps into
components that form a logical app but run with individual
rights. We demonstrate these beneﬁts at the concrete examples
of retroﬁtting an open source messaging app, called Kontalk.
Evaluation of our solution shows a minimal performance
impact compared to vanilla Android and full backwards com-
patibility to legacy apps.
II. BACKGROUND: ANDROID OS
Android OS uses a modiﬁed Linux kernel that supports
an efﬁcient Inter-Process Communication (IPC), called Binder.
Binder is the primary channel for inter-app communication
and talking to (system) services (see Section IV for an in-
depth discussion on the Binder framework). On top of the
kernel exists Android’s application framework, which manages
a wide range of system services and facilitates data sharing
across apps. The system services enrich apps with a variety of
features, such as retrieving GPS location and capturing photos.
Pre-installed system apps extend those features with APIs
that, for example, make phone calls and manage the Contacts.
Fig. 1. Android’s default security architecture.
Users can further extend their devices’ functionality with third-
party apps. For this work, the most related system services
are: ActivityManagerService (AMS), which controls app’s
life cycle; PackageManagerService (PMS), which maintains
app’s metadata including privileges; LocationManagerService
(LMS), which provides access to the device’s GPS information.
All apps, including the system apps, are composed of four
basic components: 1) Activities are interfaces that manage
user interactions; 2) Services execute long running operations
and can be bound to and invoked by other apps; 3) Content
Providers manage access to data repositories stored in apps;
and 4) Broadcast Receivers receive and handle broadcast
messages from the system and other apps.
Android’s Security Model
Android’s security architecture is depicted in Figure 1. In
Android, all apps and system services/apps are sandboxed.
Each app runs in its (set of) processes and has a private data di-
rectory. This sandbox is deﬁned by the app’s Linux UID, which
is assigned at app install-time, under which the app’s processes
execute and for which Linux discretionary access control
ensures protection of the private directory. Android further
applies the principle of least-privilege per app sandbox. Thus,
to access resources outside their sandbox, apps have to request
and been granted the necessary privileges (”permissions”).
A handful of permissions protect system resources that the app
processes can directly access with syscalls, such as Internet
and Bluetooth sockets. Those permissions are enforced by the
Linux kernel using GIDs, i.e., the UID of an app holding,
for instance, the Internet permission is assigned at install-time
to a Linux GID [6] that has the rights to create/read/write
Internet sockets. The bulk of the permissions—more than 100
for Android Oreo [2]—however, are enforced by the system
services and apps (see top-right corner of Figure 1). Android
applies privilege separation between third party apps and
system apps/services, where access to certain system resources,
e.g., the radio interface layer daemon (rild), is only allowed to
particular system services, like the TelephonyService. Those
services, in turn, expose Binder IPC-callable methods to apps
as part of the application framework API. Thus, apps that want
to make use of those managed system resources, e.g., initiating
a phone call, have to make an RPC via Binder to the service
API, which then checks if the calling app is privileged enough
to request the service, and if so execute on the calling app’s
behalf (i.e., an intentional deputy). The cornerstone of this
2
LooperthreaduserspacekernelIPCthreadApp (UID=42)System Service/App(e.g., TelephonyService)Proc (PID=23)Activity_1Service_1NativeLibProc (PID=24)Activity_2AdLibBinder Kernel ModuleService APIPermission checkPrivileged functionalityKernel API (e.g., virtual ﬁlesystem)Private/Public Resource (e.g., SDCard)Discretionary (UID) & Mandatory Access Control (SELinux)Privileged Resource (e.g., rild)RPCRPC, UID=42, PID=24syscallsyscallenforcement is Binder IPC, which provides the callee with the
UID and PID of the caller. The called service can then consult
the PMS whether the calling UID has the required permission.
Mandatory Access Control: Android’s domain isolation
and privilege separation has been reinforced with SELinux
type enforcement [60], a realization of mandatory access
control. With type enforcement, all subjects (e.g., processes)
and objects (e.g., ﬁles) are labeled with a security type and
the allowed interactions between types are deﬁned in a set
of policy rules. On Android, all app and system service
processes execute in distinct domains deﬁned by an assigned
security type, which reinforces Android’s sandboxing and
least-privilege, and hardens the system against exploits. In
contrast to permissions, which are directly exposed to app
developers, who must request them in the app’s manifest ﬁle,
and to end users, who must approve the permission requests by
apps, type enforcement is not directly exposed to developers
nor users. The SELinux policies are usually static and can only
be managed through administrative intervention.
Isolated process: Starting from Android v4.1, app
developers are provided limited support for privilege separation
via isolated processes [1]. Isolated processes are Service
components that run under a separate, transient Linux UID
that differs from any existing UID and has a separate SELinux
type. Hence, this service has no access to the app’s private data
directory, does not hold any permissions, and cannot access
any resources on the ﬁle-system. Also the middleware services
refuse serving RPC by an isolated process (due to absence of
permissions). To allow the host app to still communicate with
its isolated process, the app can bind to the isolated process
service component to invoke the service’s operation. Isolated
processes only provide an all-or-nothing privilege separation,
i.e., there are no means to ﬁne-tune the privileges of an isolated
process or to grant additional privileges after running it.
Permission delegation: Android supports simple forms
of delegating permissions between apps. First, URI permis-
sions; Data entries in Content Providers are addressed using
URIs (e.g., content://com.android.contacts for data
in the Contacts app) and access to individual entries can be
granted on per-URI basis. Second, Pending Intents; Intents are
the most abstract form of inter-app and intra-app communica-
tion. A Pending Intent is a pre-populated Intent object that can
be passed to another app, similar to a token. An app holding
a Pending Intent can populate the remaining attributes of that
Intent (e.g., payload, receiver) and then send it. The Intent
will be sent with the permissions of its creator app, effectively
allowing apps to temporarily delegate their permissions in a
controlled way to other apps via Intents.
III. RELATED WORK AND MOTIVATION
We present selected works that extended Android’s security
policy and provide an overview of systems using object-
capabilities. We then relate those concepts to Android’s current
permission enforcement to motivate the design of DROIDCAP.
A. Android Security Extensions
Over the last decade, a variety of security solutions for
Android have been brought forward [7], including retroﬁtting
Android’s permission system and compartmentalizing apps.
Retroﬁtting Android’s Permissions: Research has early
on investigated Android’s permissions and inter-app commu-
nication [22] and a range of extensions to or retroﬁttings
of the stock permission system have been proposed. For
instance, Apex [47], Saint [51], CRePE [17], TISSA [72],
and Porscha [50] extend the permission enforcement with
more ﬁne-grained, dynamic, or context-sensitive permissions
to enable better privacy-protection, DRM, or developer-centric
permissions. TrustDroid [14] and XManDroid [13] establish
security domains that are isolated from each other within the
system services/apps and the ﬁle-system.
Information Flow Control: A few works added information
ﬂow control (IFC) to Android, which we also pick up again
in our discussion in Section VI. Aquifer [46] allows app
developers to deﬁne secrecy restrictions that protect shared
data along user interface ﬂows across apps and uses a custom