# 13 \| 分布式调度架构之共享状态调度：物质文明、精神文明多手协商抓你好，我是聂鹏程。今天，我来继续带你打卡分布式核心技术。在上一篇文章中，我们一起学习了两层调度。在两层调度架构中，第二层调度只知道集群中的部分资源，无法进行全局最优调度。那么，是否有办法解决全局最优调度的问题呢？答案是肯定的，解决办法就是我今天要带你打卡的共享状态调度。接下来，我们就一起看看共享状态调度到底是什么，以及它的架构和工作原理吧。
## 什么是共享状态调度？通过我们前两篇文章的讲述，不难发现，集群中需要管理的对象主要包括两种：-   一是，资源的分配和使用状态；-   二是，任务的调度和执行状态；在单体调度中，这两种对象都是由单体调度器管理的，因此可以比较容易地保证全局状态的一致性，但问题是可扩展性较差（支持业务类型受限），且存在单点瓶颈问题。而在两层调度中，这两种对象分别由第一层中央调度器和第二层 Framework调度器管理，由于 Framwork调度器只能看到部分资源，因此不能保证全局状态的一致性，也不容易实现全局最优的调度。为了解决这些问题，一种新的调度器架构被设计了出来。这种架构基本上沿袭了单体调度器的模式，通过将单体调度器分解为多个调度器，每个调度器都有全局的资源状态信息，从而实现最优的任务调度，提供了更好的可扩展性。``{=html}也就是说，这种调度架构在支持多种任务类型的同时，还能拥有全局的资源状态信息。要做到这一点，这种调度架构的多个调度器需要共享集群状态，包括资源状态和任务状态等。因此，这种调度架构，我们称之为**共享状态调度器**。如果我们继续把资源比作物质文明、把任务比作精神文明的话，相对于单体调度和两层调度来说，共享状态调度就是"物质文明与精神文明多手协商抓"。共享状态调度架构的示意图，如下所示：![](Images/166b0397547b751ed084a782a8b200a8.png){savepage-src="https://static001.geekbang.org/resource/image/4e/5b/4ec7d31cf93905fdb5a6d81afa60105b.png"}可以看出，**共享状态调度架构为了提供高可用性和可扩展性，将集群状态之外的功能抽出来作为独立的服务。**具体来说就是：-   State Storage 模块（资源维护模块）负责存储和维护资源及任务状态，以便    Scheduler 查询资源状态和调度任务；-   Resource Pool 即为多个节点集群，接收并执行 Scheduler 调度的任务；-   而 Scheduler    只包含任务调度操作，而不是像单体调度器那样还需要管理集群资源等。共享状态调度也支持多种任务类型，但与两层调度架构相比，主要有两个不同之处：-   存在多个调度器，每个调度器都可以拥有集群全局的资源状态信息，可以根据该信息进行任务调度；-   共享状态调度是乐观并发调度，在执行了任务匹配算法后，调度器将其调度结果提交给    State    Storage，由其决定是否进行本次调度，从而解决竞争同一种资源而引起的冲突问题，实现全局最优调度。而，两层调度是悲观并发调度，在执行任务之前避免冲突，无法实现全局最优匹配。看到这里，我再和你说说**乐观并发调度和悲观并发调度的区别**吧。乐观并发调度，强调事后检测，在事务提交时检查是否避免了冲突：若避免，则提交；否则回滚并自动重新执行。也就是说，它是在执行任务匹配调度算法后，待计算出结果后再进行冲突检测。悲观并发调度，强调事前预防，在事务执行时检查是否会存在冲突。不存在，则继续执行；否则等待或回滚。也就是说，在执行任务匹配调度算法前，通过给不同的Framework 发送不同的资源，以避免冲突。现在，我们已经对共享状态调度有了一个整体印象，知道了它可以解决什么问题。那么接下来，我们再看看这种调度架构是如何设计的吧。
## 共享状态调度设计共享状态调度的理念最早是 Google针对两层调度器的不足，提出的一种调度架构。这种调度结构的典型代表有Google 的 Omega、微软的 Apollo，以及 Hashicorp 的 Nomad 容器调度器。作为 Google 公司的第二代集群管理系统，Omega 在设计时参考了 Borg的设计，吸收了 Borg 的优点，并改进了其不足之处。所以接下来，我就以 Omega为例和你讲述共享状态调度的架构和工作原理吧。这样一来，你可以对照着[第 11篇文章](https://time.geekbang.org/column/article/150811)中 Borg的调度设计一起理解。
### Omega 调度架构Omega 集群中有一个"Cell"的概念，每个 Cell管理着部分物理集群，一个集群有多个Cell。实际上，你可以直接将这里的"Cell"理解为一个集群的子集群或子节点的集合。Omega 集群的调度架构示意图，如下所示。![](Images/892783d2b074281c7dec66503f83afaa.png){savepage-src="https://static001.geekbang.org/resource/image/28/d9/2865c041745b3cd70aa369710e3799d9.png"}我在介绍共享状态调度的架构时提到，State Storage模块负责存储和维护资源及任务状态，里面有一个 Cell State文件，记录着全局共享的集群状态。实际上，State Storage组件中的集群资源状态信息，就是主本，而 Cell State就是以主副本的形式存在的。每个调度器都包含一个私有的 Cell State副本，也就是拥有了一个集群资源状态信息的副本，进而达到了共享集群资源状态信息的目的。在 Omega系统中，没有中央资源分配器，所有资源分配决策都在调度器（Scheduler）中进行。每个调度器都可以根据私有的Cell State 副本，来制定调度决策。调度器可以查看 Cell的整个状态，并申请任何可用的集群资源。一旦调度器做出资源调度决策，它就会在原子提交中更新本地的Cell State 的资源状态副本。若同时有多个调度器申请同一份资源，StateStorage 模块可以根据任务的优先级，选择优先级最高的那个任务进行调度。可以看出，在 Omega系统中的每个调度器，都具有对整个集群资源的访问权限，从而允许多个调度器自由地竞争空闲资源，并在更新集群状态时使用乐观并发控制来调解资源冲突问题。这样一来，Omega 就有效地解决了两层调度中 Framework只拥有局部资源，无法实现全局最优的问题。接下来，我们看一下 Omega 共享调度的工作原理吧。