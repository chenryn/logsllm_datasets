Core Module 
Code Coverage 
Analysis Module 
Manul Network 
Module 
Shared Memory 
Fuzzer 
Volatile Paths Detection 
56 
Run & Calibrate 
ABAAAAAAA 
Volatile Paths Detection 
57 
Run & Calibrate 
ABAAAAAAA 
Volatile Paths Detection 
58 
Run & Calibrate 
ACAAAAAAA 
https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-schumilo.pdf 
Parallel fuzzing. Python Multiprocessing 
59 
Main Process 
Corpus: 
Parallel fuzzing. Python Multiprocessing 
60 
Main Process 
Corpus: 
Instance #1 
Instance #2 
Instance #3 
Parallel fuzzing. Python Multiprocessing 
61 
Main Process 
Instance #1 
Instance #2 
Instance #3 
Corpus: 
Parallel fuzzing. Python Multiprocessing 
62 
Main Process 
Instance #1 
Instance #2 
Instance #3 
Corpus: 
Parallel fuzzing. Python Multiprocessing 
63 
Main Process 
Instance #1 
Instance #2 
Instance #3 
Remote Instance 
(Main Process) 
Remote 
Instance #1 
Remote 
Instance #2 
Parallel fuzzing. Python Multiprocessing 
64 
Main Process 
Instance #1 
Instance #2 
Instance #3 
Remote Instance 
(Main Process) 
Remote 
Instance #1 
Remote 
Instance #2 
65 
Main Process 
Instance #1 
Instance #2 
Instance #3 
Remote Instance 
(Main Process) 
Remote 
Instance #1 
Remote 
Instance #2 
Target 
Target 
Target 
Target 
Target 
SHM 
SHM 
SHM 
SHM 
SHM 
Global shared memory 
66 
Main Process 
Instance #1 
Instance #2 
Instance #3 
Remote Instance 
(Main Process) 
Remote 
Instance #1 
Remote 
Instance #2 
Target 
Target 
Target 
Target 
Target 
SHM 
SHM 
SHM 
SHM 
SHM 
Global shared memory 
Third Party Mutators 
●
AFL strategy (ported to Python) and Radamsa (as a shared 
library) 
Custom Python Mutator: 
●
def init(fuzzer_id) 
●
def mutate(data_to_mutate) 
67 
Network Application Fuzzing (Experimental) 
68 
Manul 
Target 
TCP|UDP 
Manul 
Target 
Test case 
(TCP|UDP) 
Connect 
Client mode 
Server mode 
Blackbox Binaries Fuzzing 
Windows: DynamoRIO: ~x30 overhead 
Linux: Intel Pin: ~x45 overhead 
       DynamoRIO: ~x20 overhead 
69 
Manul 
Target binary 
Instrumentation lib 
SHM 
Coverage 
Coverage 
Test 
70 
Interface & Logo 
71 
Command Line Arguments 
72 
DEMO  
(Manul) 
73 
74 
Case Study I. Poppler 
● Poppler 
is 
an 
open-source 
library 
for 
rendering PDF documents on GNU/Linux  
●
Millions of users across the world. Default package on 
Ubuntu 
●
Integrated with Evince, LibreOffice, Inkscape and many 
other applications 
● Written in C++ 
● Participate in OSS-Fuzz program (tough target) 
75 
Case Study I. Poppler. Fuzzing Setup 
● 491 PDF files (same corpus used by OSS-Fuzz) 
● 24 hours, 78 parallel jobs 
● AFL ver. 2.52b & Manul ver. 0.2 
● Intel Xeon CPU E5-2698 v4 @2.20GHz 1TB RAM 
76 
Case Study I. Execution Speed 
77 
Case Study I. Paths Found 
78 
Case Study I. Why Manul outperformed AFL 
● Manul 
corpus 
parallelization 
algorithm 
demonstrates 
better 
performance 
on 
large 
targets 
● Radamsa + AFL is better than only AFL 
● Volatile paths suppression seems to work 
79 
Case Study I. Manul Findings 
CVE-2019-9631. 9.8 Critical. Poppler 0.74.0 has a heap-based buffer over-read in the 
CairoRescaleBox.cc downsample_row_box_filter function. 
CVE-2019-7310. 8.8 High. Poppler 0.74.0. A heap-based buffer over-read (due to an 
integer signedness error in the XRef::getEntry function in XRef.cc) allows remote 
attackers to cause a denial of service (application crash) or possibly have 
unspecified other impact via a crafted PDF document, as demonstrated by pdftocairo.  
CVE-2019-9959 (X.X. High) In Poppler (latest), JPXStream::init doesn’t have a check 
for negative values of stream length thereby making it possible to allocate large 
memory chunk on heap with size controlled by an attacker. 
Non-security related: 
1.Division by zero in CairoRescalBox::downScaleImage 
2.Null-pointer dereference in ExtGState 
3.Stack-overflow (recursion) in libcairo 
80 
Case Study I. Poppler. CVE 2019-9631  
81 
Case Study I. Poppler. CVE 2019-9631  
82 
Case Study I. Poppler. CVE 2019-9959  
83 
Case Study I. Poppler. CVE 2019-9959  
84 
Case Study I. Poppler. CVE 2019-7310  
85 
Case Study I. Poppler. CVE 2019-7310  
86 
Case Study II. Zeek IDS 
●
Zeek (former Bro) is a world’s most powerful open-source 
network analysis framework 
○
Thousand of companies use Zeek as IDS 
○
JA3 plugin for Zeek is a very powerfull tool to detect 
suspicious connections of malware with C2 
●
BroCon happens in Arlington, VA every October 
●
Written in C++, very high-quality code, fuzzing was done using 
libfuzzer by development team in the past 
87 
Zeek Fuzzing Wrapper Example 
●
Implemented for HTTP, IRC, KRB, DNP3, SSH, DNS, ICMP, LOGIN, FTP, IMAP 
88 
Case Study II. Findings 
CVE-2018-17019 (7.5. High). In Zeek IDS through 2.5.5, there is a 
DoS 
in 
IRC 
protocol 
names 
command 
parsing 
in 
analyzer/protocol/irc/IRC.cc 
CVE-2018-16807 (7.5. High). In Zeek IDS through 2.5.5, there is a 
memory 
leak 
potentially 
leading 
to 
DoS 
in 
scripts/base/protocols/krb/main.bro 
in 
the 
Kerberos 
protocol 
parser. 
CVE-2019-12175. (X.X High). In Zeek IDS, there is a DoS in 
Kerberos protocol parser in analyzer/protocol/krb/KRB.cc 
89 
CVE-2018-16807 
#1 0x16d0f10 in binpac::KRB_TCP::proc_krb_kdc_req_arguments(binpac::KRB_TCP::KRB_KDC_REQ*, 
analyzer::Analyzer*)  
#2 0x16d0994 in binpac::KRB_TCP::KRB_Conn::proc_krb_kdc_req_msg(binpac::KRB_TCP::KRB_KDC_REQ*)  
#3 0x16f6038 in binpac::KRB_TCP::KRB_AS_REQ::Parse(unsigned char const*, unsigned char const*, 
binpac::KRB_TCP::ContextKRB_TCP*, int) 
90 
IRC Protocol 
91 
CVE 2018-16807. Packet Example 
Send packet that contains: “353 “ on IRC port 6666 
92 
CVE-2019-12175 
==103310==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x55a797d15b75 bp 
0x7ffe14590cb0 sp 0x7ffe14590330 T0) 
#0 0x55a797d15b74 in binpac::KRB_TCP::proc_padata(binpac::KRB_TCP::KRB_PA_Data_Sequence const*, 
analyzer::Analyzer*, bool)  
#1 0x55a797d3d36a in binpac::KRB_TCP::proc_krb_kdc_req_arguments(binpac::KRB_TCP::KRB_KDC_REQ*, 
analyzer::Analyzer*) 
#2 0x55a797d3f61b in binpac::KRB_TCP::KRB_Conn::proc_krb_kdc_req_msg(binpac::KRB_TCP::KRB_KDC_REQ*)  
#3 0x55a797d65032 in binpac::KRB_TCP::KRB_AS_REQ::Parse(unsigned char const*, unsigned char const*, 
binpac::KRB_TCP::ContextKRB_TCP*, int)  
#4 0x55a797d65032 in binpac::KRB_TCP::KRB_PDU::Parse(unsigned char const*, unsigned char const*, 
binpac::KRB_TCP::ContextKRB_TCP*)  
#5 0x55a797d69717 in binpac::KRB_TCP::KRB_PDU_TCP::ParseBuffer(binpac::FlowBuffer*, 
binpac::KRB_TCP::ContextKRB_TCP*)  
#6 0x55a797d69717 in binpac::KRB_TCP::KRB_Flow::NewData(unsigned char const*, unsigned char const*) 
93 
DEMO 
(example of CVE 2019-12175 DoS in Zeek) 
94 
95 
List of Bugs Found 
96 
Bugs 
Project 
CVE-2019-6931, CVE-2019-7310, CVE-2019-9959 
Poppler for Linux 
CVE-2018-17019, CVE-2018-16807, CVE-2019-12175 
Zeek for Linux 
CVE-2019-XXXX, CVE-2019-XXXX 
Awaiting assignment from MITRE and fix from 
maintainer 
7-Zip 19.00 for Windows 
CVE-2019-XXXX, CVE-2019-XXXX, CVE-2019-XXXX 
Awaiting assignment from MITRE and fix from 
maintainer 
p7zip 16.02 for Linux 
CVE-2019-XXXX, CVE-2019-XXXX 
Awaiting assignment from MITRE and fix from 
maintainer 
Unarchiver for MacOS 
Discussion & Future Work 
●
AFL’s forkserver is strongly required 
●
Add Intel PTrace support 
●
More mutation algorithms 
●
+ structure-aware fuzzing 
●
Better MacOS support 
●
Better network fuzzing support 
●
CLANG-based instrumentation 
97 
Conclusion 
●
Fuzzing is #1 technique for vulnerability research in memory-unsafe 
languages 
●
Manul is a fully functional tool for efficient coverage-guided 
fuzzing. 
○
Multiple third-party mutators, volatile paths suppression, 
efficient parallelization algorithm, blackbox binaries fuzzing 
●
13 new bugs in 4 widely-used open-source projects. 
●
Pull & try! https://github.com/mxmssh/manul 
●
pip install psutil & git clone https://github.com/mxmssh/manul 
98 
Thank you! 
99 
https://github.com/mxmssh/manul  
Twitter: https://twitter.com/MShudrak 
Linkedin: https://www.linkedin.com/in/mshudrak/