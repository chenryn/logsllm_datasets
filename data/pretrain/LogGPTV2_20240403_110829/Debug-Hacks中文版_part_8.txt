堆栈段
数据段
代码段
通用寄存器
www.TopSage.com
5
段寄存器
0
0
B
ESP
EDX
ECX
EBX
EAX
48
---
## Page 66
图2-6FPU 寄存器
（）（）
存器（DR0/DR1/DR2/DR3/DR6/DR7)、内存类型范围寄存器 MTRR、MSR
其他寄存器有控制寄存器（CRO～CR4）、GDTR、IDTR、TR、LDTR、调试寄
EIP（Instruction Pointer）寄存器是32位指令指针。
图 2-5EFLAGS 寄存器
48 1 第 2章调试前的必知必会
（Model Specific Register）寄存器、机器检查寄存器（Machine Check Register）、
保战链的之不能伤理。
ss
X中断许可标志
C
S溢出标志
xx
盘标志
辅助标志
零标志（ZF）
方向
制标志
状态标志
标志
90
(AF)
(OF)
(IOPL)
(IF)
(NT)
(VM)
www.TopSage.com
48位FPU数据指针寄存器1个
48位FPU指令指针寄存器1个
11位 opcode 寄存器1个
16 位控制寄存器1个
16位控制寄存器1个
16 位控制寄存器1个
80位浮点寄存器8个
AC
o
---
## Page 67
到64位。
器也可以扩展到64位，GDTR、IDTR 可以扩展到10字节，LDTR、TR可以扩展
栈指针和控制寄存器都可以扩展到64位，并增加了CR8寄存器。而且，调试寄存
图2-864位环境寄存器
存器。RIP 寄存器是64位指令指针（图2-8)。
EDI/ESI/EBP/ESP/R8D～R15D来使用。处理64位操作数时，可以使用RAX/RBX/
64 位模式下的通用寄存器在处理32位操作数时，可以通过EAX/EBX/ECX/EDX/
支持的物理地址空间。
这些寄存器支持的地址空间为 2"字节。利用 CPUID 指令可以查看运行中的处理器
64位环境中的寄存器
图 2-7MMX寄存器和XMM 寄存器
32位 MXCSR
128位XMM16个
XMM寄存器
64 位 MMX寄存器8个
MMX寄存器
128位XMM寄存器8个
64位通用寄存器16个
64位RFLAGS1个
64位RIP1个
www.TopSage.com
寄存器1个
HACK#8Intel 架构的基本知识1 49
低32位同 EFLAGS
商32位保留
64位模式的指令指针
#include 
#include
$catsum.c
Intel 64 and IA-32Architectures SoftwareDeveloper's Manual (in five volumes)
http://developer.intel.com/products/processor/manuals/index.htm
第2章调试前的必知必会
本hack说明调试时不可或缺的栈的基本知识。
调试时必需的栈知识
www.TopSage.com
(1UL MAX I| max_addend = 0) {
if ((argc = 2) & isdigit(*(argv[1])))
u64 sum = 0; 
return sum;
if (n :
0x08048546 :
0x08048544 :
：
(gdb) disas main
我的延伸方向
第2章
在 man gcc 中搜索-mno-red-zone 可以看到有关 red zone 的内容。
main()
工作空间使用。这是AMD64的ABI规格定义的内容。
再次扩展128字节，这部分空间称为red zone（“危险区”），可以当做自动变量和
x86_64中自动变量和工作空间有可能会超过栈指针。从栈指针指向的地址开始,
(a)
调试前的必知必会
栈帧A
www.TopSage.com
add
call
push
FP+8
C
$0x8,&esp
0x8048458 
$0x0
参数（u32 n）
返回地址
1层FP
u64sum)
自动变量
工作空间
栈顿A
人
FP
SP
main()
注1
参数（u32n）
返回地址
(u64 sum）
上层FP
白动变量
工作空间
栈帧B
—译者注
?
---
## Page 73
回给调用者。
存的返回地址 POP 到程序计数寄存器（program counter register）中，将控制权返
行与③和④完全相反的处理，以释放当前的栈。@为子程序返回指令，将栈中保
数n的值，因此可知相当于 sum=n;。⑧的leave指令为删除栈帧的指令，它执
但是，由于变量 sum是 64 位的，③中只表示 sum的低 32 位。%eax 中保存的是参
写成汇编代码即为如此。②为帧指针-8字节的地址，表示自动变量（u64 sum)。
址，根据图2-12 可知，它指向传递给函数的参数（u32 n)。也就是说，n++;部分
从③开始为 sum_til1_MAX()函数的处理过程。θx8(%ebp)指向帧指针十8字节的地
分配用于保存自动变量的空间③。到此为止，图2-12 所示的栈帧就准备好了。
首先在栈上保存上层帧的帧指针③，然后将新的栈帧赋给帧指针④。接下来在栈上
下面来看看被调用的 sum_til_MAX()函数。
指令自动把返回地址（0x0804854b）压入栈中②。
调用函数时首先把传递给函数的参数压入栈中①，然后 sum_till_MAX()函数的 call
End of assembler dump.
0x08048494 :
0x08048493:
0x08048490 :
0x0804848d :
0x0804848a :
0x08048487:
0x0804847f 
0x0804847c :
0x08048479
0x0804846f
0x0804846c
0x08048469 
0x08048464
0x08048461
9x0804845e
0x0804845b :
0x08048459 :
0x08048458 :
(gdb) disas sum_till_MAX
7 :
1 :
:
:
: