### Preliminary Results

To determine the ground truth for data structure usage, we utilized the source code (in C/C++) available at [https://github.com/ytisf/theZoo](https://github.com/ytisf/theZoo). This repository contains a variety of malware samples, including Carberp and MyDoom, which we analyzed to understand their data structures.

#### Carberp
Carberp is designed to target bank accounts and employs the HVNC component to construct a hidden desktop that can be accessed via VNC. The VNC server uses a complex data structure consisting of nested lists. Additionally, Carberp uses the LwIP component to create a hidden TCP/IP stack for communication, which utilizes multiple independent lists. LwIP is also a component in the scareware malware Rovnix.

#### MyDoom
MyDoom is a worm that enables remote control by opening a backdoor. It uses a singly linked list (SLL) that implements a priority queue to store email addresses and an SLL of child SLLs to cache DNS MX records. Similar functionality is present in HellBot. In the spam botnet Grum, we observed partial reuse of the DNS cache.

#### AgoBot
AgoBot is a modular IRC bot with an IRC proxy component to obfuscate connections. It employs STL lists from the C++ Standard Template Library (STL).

### Analysis Results

We applied our prototype to a DLL of child DLLs extracted from HVNC in Carberp (approximately 800 lines of code) and the C++ STL lists in the IRC proxy of AgoBot (approximately 100 lines of code). Both data structures are challenging to implement, and DSI's rich heap abstraction is essential for accurate interpretation.

#### HVNC DLLs
In the case of HVNC, a single memory chunk is allocated to hold both the head and tail nodes of the list. While the structs of the other list nodes are used normally, the head and tail nodes are nested into an enclosing struct. Howard correctly identifies the nested tail struct but fails to discover the nested head struct. This is because Howard recognizes nested structs by observing patterns in the offsets applied to base addresses. However, since the nested head struct resides at the beginning address of the enclosing outer struct, it is never accessed by a unique base address and is not distinguished from the enclosing outer struct. Furthermore, Howard cannot determine that the middle nodes and the tail node are of the same type. Consequently, DSI only recognizes DLLs comprised of the middle nodes, as the head effectively does not exist, and the tail node is of a different type. This prevents the detection of the nesting relationship.

#### AgoBot STL Lists
The C++ STL lists employed by AgoBot are cyclic doubly linked lists (DLLs). The implementation inherits from a base struct providing the DLL linkage to produce a specialized list node encapsulating the list payload. However, the head node remains of the base struct type, making it essential to identify the base struct that runs through all nodes. Unfortunately, since the base struct resides at the start of the specialized list type, Howard does not find it. As such, DSI detects the DLL without its head node, preventing the identification of the cyclic property.

In both cases, with correct type information, DSI could perform accurate identification. Therefore, the analysis precision is lacking only in the binary front-end.

### Type Inference

The problems reported above are twofold: first, Howard misses nested structs that start at the same address as their enclosing struct, and second, some struct types that it infers should be grouped into a single type. The second issue is that of type merging, a well-known problem with various solutions surveyed in [4].

Howard types a memory chunk by its allocation site and then refines this by grouping types that are all touched by a shared sequence of instructions, as is typical during list traversal. However, no approach can handle the correct grouping of types when they appear both in isolation and within an enclosing struct, as seen in HVNC.

Our solution to both problems involves including DSI's rich heap abstraction in the type inference process. DSI functions by first discovering the atomic building blocks of data structures and then identifying the relationships formed between combinations of them. These building blocks correspond to SLLs, which we term strands, and a strand consists of a sequence of cells, which are subregions of memory chunks. This understanding of data structure nodes in terms of subregions of memory chunks, rather than as whole memory chunks, allows DSI to handle the complex implementations observed in Carberp and AgoBot.

To begin, we will obtain memory chunk sizes from monitoring allocations and memory locations holding pointers from Howard. We are interested in discovering the types and locations of cells, the building blocks of strands. Essentially, we wish to frame type inference as a machine learning problem, where a hypothesis is an assignment of types to memory chunks, and our evaluation measure is based on DSI's heap abstraction. For example, one measure could be to look for hypotheses that maximize the length of discovered strands, with the intuition being that the best type assignment is the one that allows the discovery of the largest data structures.

However, allowing arbitrary assignments of types to memory chunks would result in an explosion of the search space. To make the proposed approach feasible, we will use Howard's type information to guide the search, where type assignments compatible with Howard's output are preferred but not enforced. Additionally, we will enforce hard requirements for cells, e.g., a memory chunk subregion may be a cell only if it has an incoming pointer to the cell start address and an outgoing pointer originating within the cell (with exceptions made for the first and last cells in a strand). We will also exploit requirements over combinations of cells, as it is not interesting to discover strands of length one.

Ultimately, by allowing cells at arbitrary locations and promoting useful type groupings via combinations of cells, we expect to discover the common linkage elements that proved problematic in the above examples. Furthermore, we would be able to group types over any combination of stack and heap memory, a challenge noted in [4] that currently has no solution. This is necessary in practice to group a stack-allocated head node with the remainder of the heap-allocated list.

### Conclusions

We described our vision to identify dynamic data structures in malware, based on the proven techniques of DSI and Howard. As a first step, we used Howard to perform the type recovery integral to DSI's rich heap abstraction. However, as evidenced by the complex data structure implementations in Carberp and AgoBot, the types often require further refinement. To remedy this, we proposed a new type inference approach framed as a machine learning problem, which will employ Howard's types to guide the search and DSI's heap abstraction to evaluate hypotheses. The resulting identified data structures will aid reverse engineering and improve malware classification by enhancing the signatures of [5].

### Acknowledgments

This work is supported in part by DFG grant LU 1748/4-1 and the Research Fund KU Leuven.

### References

[1] E. E. Aftandilian, S. Kelley, C. Gramazio, N. Ricci, S. L. Su, and S. Z. Guyer. Heapviz: Interactive Heap Visualization for Program Understanding and Debugging. In SOFTVIS 2010, pages 53–62. ACM, 2010.
[2] S. Bhatkar and R. Sekar. Data Space Randomization. In DIMVA 2008, volume 5137 of LNCS, pages 1–22. Springer, 2008.
[3] J. Caballero, G. Grieco, M. Marron, Z. Lin, and D. Urbina. ARTISTE: Automatic Generation of Hybrid Data Structure Signatures from Binary Code Executions. Technical Report TR-IMDEA-SW-2012-001, IMDEA, Spain, 2012.
[4] J. Caballero and Z. Lin. Type Inference on Executables. ACM Comput. Surv., 48(4):65:1–65, May 2016.
[5] A. Cozzie, F. Stratton, H. Xue, and S. King. Digging for Data Structures. In OSDI 2008, pages 255–266. USENIX Association, 2008.
[6] I. Haller, A. Slowinska, and H. Bos. Scalable Data Structure Detection and Classification for C/C++ Binaries. Empirical Softw. Eng., pages 1–33, 2015.
[7] C. Jung and N. Clark. DDT: Design and Evaluation of a Dynamic Program Analysis for Optimizing Data Structure Usage. In MICRO 2009, pages 56–66. IEEE, 2009.
[8] J. Lee, T. Avgerinos, and D. Brumley. TIE: Principled Reverse Engineering of Types in Binary Programs. In NDSS 2011. The Internet Society, 2011.
[9] Z. Lin, R. D. Riley, and D. Xu. Polymorphing Software by Randomizing Data Structure Layout. In DIMVA 2009, volume 5587 of LNCS, pages 107–126. Springer, 2009.
[10] Z. Lin, X. Zhang, and D. Xu. Automatic Reverse Engineering of Data Structures from Binary Execution. In NDSS 2010. The Internet Society, 2010.
[11] M. Marron, C. Sanchez, Z. Su, and M. Fähndrich. Abstracting Runtime Heaps for Program Understanding. IEEE Trans. Softw. Eng., 39(6):774–786, 2013.
[12] J. T. Mühlberg, D. H. White, M. Dodds, G. Lüttgen, and F. Piessens. Learning Assertions to Verify Linked-List Programs. In SEFM 2015, volume 9276 of LNCS, pages 37–52. Springer, 2015.
[13] E. Raman and D. August. Recursive Data Structure Profiling. In MSP 2005, pages 5–14. ACM, 2005.
[14] A. Slowinska, T. Stancescu, and H. Bos. Howard: A Dynamic Excavator for Reverse Engineering Data Structures. In NDSS 2011. The Internet Society, 2011.
[15] D. H. White, T. Rupprecht, and G. Lüttgen. DSI: An Evidence-based Approach to Identify Dynamic Data Structures in C Programs. In ISSTA 2016, pages 259–269. ACM, 2016.