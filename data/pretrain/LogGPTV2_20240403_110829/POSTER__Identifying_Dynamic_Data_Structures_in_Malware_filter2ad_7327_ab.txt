to describe our preliminary results. To determine the ground
Malware Samples.
truth for data structure usage, we employ the source code
(in C/C++) available at https://github.com/ytisf/theZoo.
Carberp is designed to target
bank accounts and employs the component HVNC to con-
struct a hidden desktop to which one may connect via VNC.
The VNC server uses a complex data structure consisting of
nested lists. In addition, Carberp employs the component
LwIP to construct a hidden TCP/IP stack to hide communi-
cation, which makes use of multiple independent lists. LwIP
also forms a component of the scareware malware Rovnix.
MyDoom is a worm designed to enable remote control
by opening a backdoor. It uses an SLL that implements a
priority queue to store mail addresses and an SLL of child
SLLs to cache DNS MX records. Identical functionality is
also present in HellBot. Additionally, in the spam botnet
Grum, we have found partial reuse of the DNS cache.
AgoBot is a modular IRC bot with an IRC proxy compo-
nent to obfuscate connections, which employs STL lists.
Results. We have applied our prototype to a DLL of
child DLLs extracted from HVNC in Carberp (∼800 LOC)
and the C++ STL lists present in the IRC proxy of AgoBot
(∼100 LOC). The implementations of both data structures
are challenging, and DSI’s rich heap abstraction is required
to provide a correct interpretation.
We ﬁrst consider the DLLs of HVNC, where, on creation,
a single memory chunk is allocated to hold both the head
and tail nodes of the list. Thus, while the structs of the other
list nodes are used normally, those for the head and tail are
nested into an enclosing struct. Howard correctly identiﬁes
the nested tail struct, but fails to discover the nested head
struct. This is because Howard recognizes nested structs by
observing patterns in the oﬀsets applied to base addresses;
however, as the nested head struct resides at the beginning
address of the enclosing outer struct, it is never accessed
by a unique base address and is not distinguished from the
enclosing outer struct. Furthermore, Howard is not able
to determine that the middle nodes of the DLL and the tail
node are of the same type. Hence, DSI only recognizes DLLs
comprised of the middle nodes, since the head eﬀectively
does not exist and the tail node is of a diﬀerent type. This
in turn prevents detection of the nesting relationship.
The C++ STL lists employed by AgoBot are cyclic DLLs.
The implementation inherits from a base struct providing
the DLL linkage to produce a specialized list node encapsu-
lating the list payload. However, the head node of the list
remains of the base struct type and, thus, it is essential to
identify the base struct that runs through all nodes. Un-
fortunately, since the base struct resides at the start of the
specialized list type, Howard does not ﬁnd it. As such, DSI
detects the DLL without its head node, which prevents the
cyclic property from being identiﬁed.
In both cases, with correct type information DSI could
perform a correct identiﬁcation. Therefore, the analysis pre-
cision is lacking only in the binary front-end.
3. TYPE INFERENCE
The problems reported above are two-fold: ﬁrstly, Howard
misses nested structs that start at the same address as their
enclosing struct, and secondly, some struct types that it in-
fers should be grouped into a single type. The second issue
is that of type merging, which is a well known problem with a
variety of solutions surveyed in [4]. As an example, Howard
types a memory chunk by its allocation site and then re-
1773ﬁnes this by grouping types that are all touched by a shared
sequence of instructions, as is typical during list traversal.
However, no approach is able to handle the correct grouping
of types when they appear both in isolation and within an
enclosing struct, as seen in HVNC.
Our solution to both problems will be to include DSI’s
rich heap abstraction in the type inference process. DSI
functions by ﬁrst discovering the atomic building blocks of
data structures and then identifying the relationships formed
between combinations of them. The building blocks essen-
tially correspond to SLLs, which we term strands, and a
strand consists of a sequence of cells, which are subregions
of memory chunks. It is this understanding of data struc-
ture nodes in terms of subregions of memory chunks, rather
than as whole memory chunks, that allows DSI to handle the
tricky implementations observed in Carberp and AgoBot.
To begin with, we will obtain memory chunk sizes from
monitoring allocations, and memory locations holding point-
ers from Howard. Furthermore, we are only interested in
discovering the types and locations of cells, i.e., the build-
ing blocks of strands. Essentially, we wish to frame type
inference as a machine learning problem, where a hypoth-
esis is an assignment of types to memory chunks and our
evaluation measure is based oﬀ DSI’s heap abstraction. For
example, one measure could be to look for hypotheses that
maximize the length of discovered strands, with the intu-
ition being that the best type assignment is the one that
allows the discovery of the largest data structures.
However, if we would allow arbitrary assignments of types
to memory chunks, then the search space would explode.
To make the proposed approach feasible, we will employ
Howard’s type information to guide the search, where type
assignments compatible with Howard’s output are preferred,
but not enforced. In addition, we will enforce hard require-
ments for cells, e.g., a memory chunk subregion may be a cell
only if it has an incoming pointer to the cell start address
and an outgoing pointer originating within the cell (with ex-
ceptions made for the ﬁrst and last cells in a strand). We will
also exploit requirements over combinations of cells, since it
is not interesting to discover strands of length one.
Ultimately, by allowing cells at arbitrary locations, and
then promoting useful type groupings via combinations of
cells, we expect the discovery of the common linkage ele-
ments that proved so problematic in the above examples to
be possible. Furthermore, we would be able to group types
over any combination of stack and heap memory, a challenge
noted in [4] which currently has no solution. This is neces-
sary in practice to group a stack-allocated head node with
the remainder of the heap-allocated list.
4. CONCLUSIONS
We described our vision to identify dynamic data struc-
tures in malware, which is based on the already proven tech-
niques of DSI and Howard. As a ﬁrst step, we employed
Howard to perform the type recovery integral to DSI’s rich
heap abstraction; however, as evidenced by the complex data
structure implementations of the Carberp and AgoBot mal-
ware, often the types require further reﬁnement. To remedy
this, we proposed a new type inference approach framed
as a machine learning problem, which will employ Howard’s
types to guide the search and DSI’s heap abstraction to eval-
uate hypotheses. The resulting identiﬁed data structures
will aid reverse engineering and improve malware classiﬁca-
tion by, e.g., enhancing the signatures of [5].
5. ACKNOWLEDGMENTS
This work is supported in part by DFG grant LU 1748/4-1
and the Research Fund KU Leuven.
6. REFERENCES
[1] E. E. Aftandilian, S. Kelley, C. Gramazio, N. Ricci,
S. L. Su, and S. Z. Guyer. Heapviz: Interactive Heap
Visualization for Program Understanding and
Debugging. In SOFTVIS 2010, pages 53–62. ACM,
2010.
[2] S. Bhatkar and R. Sekar. Data Space Randomization.
In DIMVA 2008, volume 5137 of LNCS, pages 1–22.
Springer, 2008.
[3] J. Caballero, G. Grieco, M. Marron, Z. Lin, and
D. Urbina. ARTISTE: Automatic Generation of
Hybrid Data Structure Signatures from Binary Code
Executions. Technical Report
TR-IMDEA-SW-2012-001, IMDEA, Spain, 2012.
[4] J. Caballero and Z. Lin. Type Inference on
Executables. ACM Comput. Surv., 48(4):65:1–65, May
2016.
[5] A. Cozzie, F. Stratton, H. Xue, and S. King. Digging
for Data Structures. In OSDI 2008, pages 255–266.
USENIX Association, 2008.
[6] I. Haller, A. Slowinska, and H. Bos. Scalable Data
Structure Detection and Classiﬁcation for C/C++
Binaries. Empirical Softw. Eng., pages 1–33, 2015.
[7] C. Jung and N. Clark. DDT: Design and Evaluation of
a Dynamic Program Analysis for Optimizing Data
Structure Usage. In MICRO 2009, pages 56–66. IEEE,
2009.
[8] J. Lee, T. Avgerinos, and D. Brumley. TIE: Principled
Reverse Engineering of Types in Binary Programs. In
NDSS 2011. The Internet Society, 2011.
[9] Z. Lin, R. D. Riley, and D. Xu. Polymorphing
Software by Randomizing Data Structure Layout. In
DIMVA 2009, volume 5587 of LNCS, pages 107–126.
Springer, 2009.
[10] Z. Lin, X. Zhang, and D. Xu. Automatic Reverse
Engineering of Data Structures from Binary
Execution. In NDSS 2010. The Internet Society, 2010.
[11] M. Marron, C. Sanchez, Z. Su, and M. F¨ahndrich.
Abstracting Runtime Heaps for Program
Understanding. IEEE Trans. Softw. Eng.,
39(6):774–786, 2013.
[12] J. T. M¨uhlberg, D. H. White, M. Dodds, G. L¨uttgen,
and F. Piessens. Learning Assertions to Verify
Linked-List Programs. In SEFM 2015, volume 9276 of
LNCS, pages 37–52. Springer, 2015.
[13] E. Raman and D. August. Recursive Data Structure
Proﬁling. In MSP 2005, pages 5–14. ACM, 2005.
[14] A. Slowinska, T. Stancescu, and H. Bos. Howard: A
Dynamic Excavator for Reverse Engineering Data
Structures. In NDSS 2011. The Internet Society, 2011.
[15] D. H. White, T. Rupprecht, and G. L¨uttgen. DSI: An
Evidence-based Approach to Identify Dynamic Data
Structures in C Programs. In ISSTA 2016, pages
259–269. ACM, 2016.
1774