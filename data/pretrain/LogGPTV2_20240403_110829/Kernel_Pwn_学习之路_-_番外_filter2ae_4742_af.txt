        return 0;
    }
`uevent_helper`å®šä¹‰äº`/v4.6-rc1/source/lib/kobject_uevent.c#L32`
        #ifdef CONFIG_UEVENT_HELPER
    char uevent_helper[UEVENT_HELPER_PATH_LEN] = CONFIG_UEVENT_HELPER_PATH;
    #endif
åœ¨`CONFIG_UEVENT_HELPER`è¢«è®¾ç½®çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åªéœ€è¦åŠ«æŒ`uevent_helper`ç„¶åæ‰§è¡Œ`kobject_uevent_env`å³å¯
  3. `ocfs2_leave_group`å‡½æ•°å‡½æ•°å®ç°äº`/v4.6-rc1/source/fs/ocfs2/stackglue.c#L426`
        /*
     * Leave the group for this filesystem.  This is executed by a userspace
     * program (stored in ocfs2_hb_ctl_path).
     */
    static void ocfs2_leave_group(const char *group)
    {
        int ret;
        char *argv[5], *envp[3];
        argv[0] = ocfs2_hb_ctl_path;
        argv[1] = "-K";
        argv[2] = "-u";
        argv[3] = (char *)group;
        argv[4] = NULL;
        /* minimal command environment taken from cpu_run_sbin_hotplug */
        envp[0] = "HOME=/";
        envp[1] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
        envp[2] = NULL;
        ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);
        if (ret name,
            entry_name,
            NULL
        };
        int ret = -EACCES;
        if (nfs_cache_getent_prog[0] == '')
            goto out;
        ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);
        /*
         * Disable the upcall mechanism if we're getting an ENOENT or
         * EACCES error. The admin can re-enable it on the fly by using
         * sysfs to set the 'cache_getent' parameter once the problem
         * has been fixed.
         */
        if (ret == -ENOENT || ret == -EACCES)
            nfs_cache_getent_prog[0] = '';
    out:
        return ret > 0 ? 0 : ret;
    }
`nfs_cache_getent_prog`å®šä¹‰äº`/v4.6-rc1/source/fs/nfs/cache_lib.c#L23`
        static char nfs_cache_getent_prog[NFS_CACHE_UPCALL_PATHLEN] = "/sbin/nfs_cache_getent";
æˆ‘ä»¬åªéœ€è¦åŠ«æŒ`nfs_cache_getent_prog`ç„¶åæ‰§è¡Œ`nfs_cache_upcall`å³å¯
  5. `nfsd4_umh_cltrack_upcall`å‡½æ•°å‡½æ•°å®ç°äº`/v4.6-rc1/source/fs/nfsd/nfs4recover.c#L1198`
        static int nfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)
    {
        char *envp[3];
        char *argv[4];
        int ret;
        if (unlikely(!cltrack_prog[0])) {
            dprintk("%s: cltrack_prog is disabledn", __func__);
            return -EACCES;
        }
        dprintk("%s: cmd: %sn", __func__, cmd);
        dprintk("%s: arg: %sn", __func__, arg ? arg : "(null)");
        dprintk("%s: env0: %sn", __func__, env0 ? env0 : "(null)");
        dprintk("%s: env1: %sn", __func__, env1 ? env1 : "(null)");
        envp[0] = env0;
        envp[1] = env1;
        envp[2] = NULL;
        argv[0] = (char *)cltrack_prog;
        argv[1] = cmd;
        argv[2] = arg;
        argv[3] = NULL;
        ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);
        /*
         * Disable the upcall mechanism if we're getting an ENOENT or EACCES
         * error. The admin can re-enable it on the fly by using sysfs
         * once the problem has been fixed.
         */
        if (ret == -ENOENT || ret == -EACCES) {
            dprintk("NFSD: %s was not found or isn't executable (%d). "
                "Setting cltrack_prog to blank string!",
                cltrack_prog, ret);
            cltrack_prog[0] = '';
        }
        dprintk("%s: %s return value: %dn", __func__, cltrack_prog, ret);
        return ret;
    }
`cltrack_prog`å®šä¹‰äº`/v4.6-rc1/source/fs/nfsd/nfs4recover.c#L1069`
        static char cltrack_prog[PATH_MAX] = "/sbin/nfsdcltrack";
æˆ‘ä»¬åªéœ€è¦åŠ«æŒ`cltrack_prog`ç„¶åæ‰§è¡Œ`nfsd4_umh_cltrack_upcall`å³å¯
  6. `mce_do_trigger`å‡½æ•°å‡½æ•°å®ç°äº`/v4.6-rc1/source/arch/x86/kernel/cpu/mcheck/mce.c#L1328`
        static void mce_do_trigger(struct work_struct *work)
    {
        call_usermodehelper(mce_helper, mce_helper_argv, NULL, UMH_NO_WAIT);
    }
`mce_helper`å®šä¹‰äº`/source/arch/x86/kernel/cpu/mcheck/mce.c#L88`
        static char            mce_helper[128];
    static char            *mce_helper_argv[2] = { mce_helper, NULL };
æˆ‘ä»¬åªéœ€è¦åŠ«æŒ`mce_helper`ç„¶åæ‰§è¡Œ`mce_do_trigger`å³å¯ã€‚
### ç¬¬ä¸‰ç§ææƒå§¿åŠ¿-åŠ«æŒ`tty_struct`ç»“æ„ä½“
#### å…³äº`tty_struct`ç»“æ„ä½“
å½“æˆ‘ä»¬åœ¨ç”¨æˆ·ç©ºé—´æ‰§è¡Œ`open("/dev/ptmx", O_RDWR)`æ—¶ï¼Œå†…æ ¸å°±ä¼šåœ¨å†…å­˜ä¸­åˆ›å»ºä¸€ä¸ª`tty`ç»“æ„ä½“
`tty`ç»“æ„ä½“åœ¨`/v4.6-rc1/source/include/linux/tty.h#L259`å¤„å®šä¹‰
    struct tty_struct {
        int    magic;
        struct kref kref;
        struct device *dev;
        struct tty_driver *driver;
        const struct tty_operations *ops;
        int index;
        /* Protects ldisc changes: Lock tty not pty */
        struct ld_semaphore ldisc_sem;
        struct tty_ldisc *ldisc;
        struct mutex atomic_write_lock;
        struct mutex legacy_mutex;
        struct mutex throttle_mutex;
        struct rw_semaphore termios_rwsem;
        struct mutex winsize_mutex;
        spinlock_t ctrl_lock;
        spinlock_t flow_lock;
        /* Termios values are protected by the termios rwsem */
        struct ktermios termios, termios_locked;
        struct termiox *termiox;    /* May be NULL for unsupported */
        char name[64];
        struct pid *pgrp;        /* Protected by ctrl lock */
        struct pid *session;
        unsigned long flags;
        int count;
        struct winsize winsize;        /* winsize_mutex */
        unsigned long stopped:1,    /* flow_lock */
                  flow_stopped:1,
                  unused:BITS_PER_LONG - 2;
        int hw_stopped;
        unsigned long ctrl_status:8,    /* ctrl_lock */
                  packet:1,
                  unused_ctrl:BITS_PER_LONG - 9;
        unsigned int receive_room;    /* Bytes free for queue */
        int flow_change;
        struct tty_struct *link;
        struct fasync_struct *fasync;
        int alt_speed;        /* For magic substitution of 38400 bps */
        wait_queue_head_t write_wait;
        wait_queue_head_t read_wait;
        struct work_struct hangup_work;
        void *disc_data;
        void *driver_data;
        spinlock_t files_lock;        /* protects tty_files list */
        struct list_head tty_files;
    #define N_TTY_BUF_SIZE 4096
        int closing;
        unsigned char *write_buf;
        int write_cnt;
        /* If the tty has a pending do_SAK, queue it here - akpm */
        struct work_struct SAK_work;
        struct tty_port *port;
    };
è¿™é‡Œæ¯”è¾ƒé‡è¦çš„æ˜¯å…¶ä¸­çš„`tty_operations`ç»“æ„ä½“ï¼Œé‡Œé¢æœ‰å¤§é‡çš„å‡½æ•°æŒ‡é’ˆ
    struct tty_operations {
        struct tty_struct * (*lookup)(struct tty_driver *driver, struct inode *inode, int idx);
        int  (*install)(struct tty_driver *driver, struct tty_struct *tty);
        void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
        int  (*open)(struct tty_struct * tty, struct file * filp);
        void (*close)(struct tty_struct * tty, struct file * filp);
        void (*shutdown)(struct tty_struct *tty);
        void (*cleanup)(struct tty_struct *tty);
        int  (*write)(struct tty_struct * tty, const unsigned char *buf, int count);
        int  (*put_char)(struct tty_struct *tty, unsigned char ch);
        void (*flush_chars)(struct tty_struct *tty);
        int  (*write_room)(struct tty_struct *tty);
        int  (*chars_in_buffer)(struct tty_struct *tty);
        int  (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg);
        long (*compat_ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg);
        void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
        void (*throttle)(struct tty_struct * tty);
        void (*unthrottle)(struct tty_struct * tty);
        void (*stop)(struct tty_struct *tty);
        void (*start)(struct tty_struct *tty);
        void (*hangup)(struct tty_struct *tty);
        int (*break_ctl)(struct tty_struct *tty, int state);
        void (*flush_buffer)(struct tty_struct *tty);
        void (*set_ldisc)(struct tty_struct *tty);
        void (*wait_until_sent)(struct tty_struct *tty, int timeout);
        void (*send_xchar)(struct tty_struct *tty, char ch);
        int (*tiocmget)(struct tty_struct *tty);
        int (*tiocmset)(struct tty_struct *tty, unsigned int set, unsigned int clear);
        int (*resize)(struct tty_struct *tty, struct winsize *ws);
        int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);
        int (*get_icount)(struct tty_struct *tty, struct serial_icounter_struct *icount);
    #ifdef CONFIG_CONSOLE_POLL
        int (*poll_init)(struct tty_driver *driver, int line, char *options);
        int (*poll_get_char)(struct tty_driver *driver, int line);
        void (*poll_put_char)(struct tty_driver *driver, int line, char ch);
    #endif
        const struct file_operations *proc_fops;
    };
å¦‚æœæˆ‘ä»¬èƒ½å¤ŸåŠ«æŒå…¶ä¸­çš„æŒ‡é’ˆï¼Œæˆ‘ä»¬å°±å¯ä»¥æ‰§è¡Œä»»æ„æŒ‡ä»¤äº†ã€‚
ç”±äºæ­¤ç§æ–¹æ³•å…¶å®æ˜¯å°†ä»»æ„åœ°å€è¯»å†™è½¬æ¢ä¸ºäº†ä»»æ„åœ°å€æ‰§è¡Œï¼Œå¹¶æ²¡æœ‰çœŸæ­£è¿›è¡Œææƒï¼Œå› æ­¤å¯ä»¥å‚è€ƒç¬¬äºŒç§å§¿åŠ¿å®Œæˆåç»­åˆ©ç”¨ã€‚
### ç¬¬å››ç§ææƒå§¿åŠ¿-åŠ«æŒ`VDSO`å†…å­˜åŒº
ğŸš«ï¼šæ­¤åˆ©ç”¨è·¯å¾„å·²è¢«ä¿®å¤ï¼Œä»…èƒ½åœ¨`Linux Kernel 2.x`åŠä»¥ä¸‹ç‰ˆæœ¬åˆ©ç”¨ï¼Œæ•…æ­¤å¤„ä»…é˜è¿°åŸç†ï¼Œä¸åšåˆ©ç”¨æ¼”ç¤ºã€‚
#### å…³äº`VDSO`å†…å­˜æ˜ å°„
`VDSO(Virtual Dynamic Shared
Object)`å†…å­˜æ˜ å°„æ˜¯ç”¨æˆ·æ€çš„ä¸€å—å†…å­˜æ˜ å°„ï¼Œè¿™ä½¿å¾—å†…æ ¸ç©ºé—´å°†å¯ä»¥å’Œç”¨æˆ·æ€ç¨‹åºå…±äº«ä¸€å—ç‰©ç†å†…å­˜ï¼Œä»è€ŒåŠ å¿«æ‰§è¡Œæ•ˆç‡ï¼Œè¿™ä¸ªå†…å­˜æ˜ å°„ä¹Ÿå«å½±å­å†…å­˜ã€‚å½“åœ¨å†…æ ¸æ€ä¿®æ”¹æ­¤éƒ¨åˆ†å†…å­˜æ—¶ï¼Œç”¨æˆ·æ€æ‰€è®¿é—®åˆ°çš„æ•°æ®åŒæ ·ä¼šæ”¹å˜ï¼Œè¿™æ ·çš„æ•°æ®åŒºåœ¨ç”¨æˆ·æ€æœ‰ä¸¤å—ï¼Œåˆ†åˆ«æ˜¯`vdso`å’Œ`vsyscall`ã€‚
`vsyscall`å’Œ`VDSO`éƒ½æ˜¯ä¸ºäº†é¿å…äº§ç”Ÿä¼ ç»Ÿç³»ç»Ÿè°ƒç”¨æ¨¡å¼`INT
0x80/SYSCALL`é€ æˆçš„å†…æ ¸ç©ºé—´å’Œç”¨æˆ·ç©ºé—´çš„ä¸Šä¸‹æ–‡åˆ‡æ¢è¡Œä¸ºã€‚`vsyscall`åªå…è®¸`4`ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œä¸”åœ¨æ¯ä¸ªè¿›ç¨‹ä¸­é™æ€åˆ†é…äº†ç›¸åŒçš„åœ°å€ï¼›`VDSO`æ˜¯åŠ¨æ€åˆ†é…çš„ï¼Œåœ°å€éšæœºï¼Œå¯æä¾›è¶…è¿‡`4`ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œ`VDSO`æ˜¯`glibc`åº“æä¾›çš„åŠŸèƒ½ã€‚
`VDSO`æœ¬è´¨å°±æ˜¯æ˜ å°„åˆ°å†…å­˜ä¸­çš„`.so`æ–‡ä»¶ï¼Œå¯¹åº”çš„ç¨‹åºå¯ä»¥å½“æ™®é€šçš„`.so`æ¥ä½¿ç”¨å…¶ä¸­çš„å‡½æ•°ã€‚
**åœ¨`Kernel 2.x`ä¸­ï¼Œ`VDSO`æ‰€åœ¨çš„é¡µï¼Œåœ¨å†…æ ¸æ€æ˜¯å¯è¯»ã€å¯å†™çš„ï¼Œåœ¨ç”¨æˆ·æ€æ˜¯å¯è¯»ã€å¯æ‰§è¡Œçš„ã€‚**
`VDSO`åœ¨æ¯ä¸ªç¨‹åºå¯åŠ¨æ—¶åŠ è½½ï¼Œæ ¸å¿ƒè°ƒç”¨çš„æ˜¯`init_vdso_vars`å‡½æ•°ï¼Œåœ¨`/v2.6.39.4/source/arch/x86/vdso/vma.c#L38`å¤„å®ç°ã€‚
    static int __init init_vdso_vars(void)
    {
        int npages = (vdso_end - vdso_start + PAGE_SIZE - 1) / PAGE_SIZE;
        int i;
        char *vbase;
        vdso_size = npages << PAGE_SHIFT;
        vdso_pages = kmalloc(sizeof(struct page *) * npages, GFP_KERNEL);
        if (!vdso_pages)
            goto oom;
        for (i = 0; i < npages; i++) {
            struct page *p;
            p = alloc_page(GFP_KERNEL);
            if (!p)
                goto oom;
            vdso_pages[i] = p;
            copy_page(page_address(p), vdso_start + i*PAGE_SIZE);
        }
        vbase = vmap(vdso_pages, npages, 0, PAGE_KERNEL);
        if (!vbase)
            goto oom;
        if (memcmp(vbase, "177ELF", 4)) {
            printk("VDSO: I'm broken; not ELFn");
            vdso_enabled = 0;
        }
    #define VEXTERN(x) 
        *(typeof(__ ## x) **) var_ref(VDSO64_SYMBOL(vbase, x), #x) = &__ ## x;
    #include "vextern.h"
    #undef VEXTERN
        vunmap(vbase);
        return 0;
     oom:
        printk("Cannot allocate vdson");
        vdso_enabled = 0;
        return -ENOMEM;
    }
    subsys_initcall(init_vdso_vars);
åœ¨`VDSO`ç©ºé—´åˆå§‹åŒ–æ—¶ï¼Œ`VDSO`åŒæ—¶æ˜ å°„åœ¨å†…æ ¸ç©ºé—´ä»¥åŠæ¯ä¸€ä¸ªè¿›ç¨‹çš„è™šæ‹Ÿå†…å­˜ä¸­ï¼Œå‘è¿›ç¨‹æ˜ å°„æ—¶ï¼Œå†…æ ¸å°†é¦–å…ˆæŸ¥æ‰¾åˆ°ä¸€å—ç”¨æˆ·æ€åœ°å€ï¼Œç„¶åå°†è¯¥å—åœ°å€çš„æƒé™è®¾ç½®ä¸ºVM_READ|VM_EXEC|VM_MAYREAD|VM_MAYWRITE|VM_MAYEXECï¼Œç„¶ååˆ©ç”¨`remap_pfn_range`å°†å†…æ ¸é¡µæ˜ å°„è¿‡å»ã€‚
è‹¥æˆ‘ä»¬èƒ½è¦†ç›–`VDSO`çš„ç›¸åº”åˆ©ç”¨åŒºï¼Œå°±èƒ½æ‰§è¡Œæˆ‘ä»¬è‡ªå®šä¹‰çš„`shellcode`ã€‚
æ­¤å¤„åˆ©ç”¨å¯å‚è€ƒ[Bypassing SMEP Using vDSO
Overwrites(ä½¿ç”¨vDSOé‡å†™æ¥ç»•è¿‡SMEPé˜²æŠ¤)](https://hardenedlinux.github.io/translation/2015/11/25/Translation-Bypassing-SMEP-Using-vDSO-Overwrites.html)
## å‚è€ƒé“¾æ¥
[ã€åŸã€‘Heap SprayåŸç†æµ…æ â€“
magictong](https://blog.csdn.net/magictong/article/details/7391397)
[ã€åŸã€‘linuxå†…æ ¸ææƒç³»åˆ—æ•™ç¨‹ï¼ˆ1ï¼‰ï¼šå †å–·å°„å‡½æ•°sendmsgä¸msgsendåˆ©ç”¨ â€“
bsauce](https://xz.aliyun.com/t/6286)
[ã€åŸã€‘linuxå†…æ ¸ææƒç³»åˆ—æ•™ç¨‹ï¼ˆ2ï¼‰ï¼šä»»æ„åœ°å€è¯»å†™åˆ°ææƒçš„4ç§æ–¹æ³• â€“ bsauce](https://xz.aliyun.com/t/6296)