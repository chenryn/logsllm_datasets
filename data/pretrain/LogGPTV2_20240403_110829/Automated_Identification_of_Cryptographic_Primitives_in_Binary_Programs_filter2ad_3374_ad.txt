### 7.2 Results of the Signature Matching Using (Mnemonic, Constant)-Tuples

The results of the signature matching using (mnemonic, constant)-tuples are shown in Figure 4. The overall performance is generally good when considering unique signatures. Since the signatures are partially generated from the testing applications, their matching performance appears to be successful in the evaluation. However, if we evaluate against slightly different code, we expect that the detection rate might decrease. Therefore, a fuzzy matching algorithm for the mnemonic sequence comparison could mitigate this problem, and we will investigate such a method as part of our future work.

The (mnemonic, constant)-tuple matching method is the most successful among the signature identification methods. The details of the results are presented in Figure 4: the signatures are displayed on the y-axis, and the testing applications are shown on the x-axis. Each highlighted field links the testing application to the respective signature. If we apply a threshold of 70%, all implementations are correctly identified.

### 7.3 Verifier Heuristic

The verifier heuristic, which also verifies the existence and parameters of symmetric encryption, is capable of detecting cryptographic primitives within a given program. Table 4 shows that the method can detect nearly every instance of symmetric encryption algorithms (RSA and MD5 are marked as n/a). The only undetected trace is Gladman’s AES implementation. By design, the method does not yield false-positive results. The success of this method is closely tied to the memory reconstruction method described in Section 3.2. In the case of the Gladman AES implementation, the memory reconstruction method is unable to reconstruct the cryptographic parameters, leading to the failure of the method. Although the memory reconstruction often leads to up to 2000 candidates for encryption key, plaintext, and ciphertext each, the time for the candidate check is feasible. For AES, our non-optimized AES candidate check function can conduct 400,000 checks per second. If 2000 candidates exist for each parameter, the verification of all candidates would only take \( \frac{2000^2}{400000} = 10 \) seconds.

### 7.4 Off-the-Shelf Application

To demonstrate the generic usage of our approaches, we tested our system implementation against off-the-shelf software. We traced and analyzed an SSL session of the Curl HTTP client, which utilizes the OpenSSL library for establishing an SSL connection. In the testing environment, we used Curl version 7.19.7 with OpenSSL version 0.9.8l. We downloaded a HTML file from a web server using HTTPS and traced the execution as explained in Section 3.2. The remote SSL server and the Curl client negotiated the following SSL cipher suite setting: TLS DHE RSA WITH AES 256 CBC SHA. This means that the cipher suite specifies Diffie-Hellman Key Exchange, with RSA certificates, symmetrically encrypted by AES in CBC mode with 256-bit keys, and integrity checked by SHA1. Thus, we knew that the analysis should at least detect the RSA and AES invocations. The selected cipher was used to encrypt three packets of SSL application data. The first packet was the client HTTP request of 160 encrypted bytes, followed by the server response with 272 bytes for the HTTP header and 5168 bytes of content.

The results are summarized in Table 5. The method by Caballero et al. successfully detected 19 basic blocks in the encryption and key scheduling functions. Lutz’s method revealed 2,121 entropy changes in 26 loop bodies corresponding to 22 functions, including some false-positives. The method by Wang et al. generated no results, possibly because the trace did not start at the beginning of the application.

The chains method, which compares mnemonic sequences, detected both AES and RSA without false-positives. An interesting result was revealed by the signature-based mnemonic-const identification method: since we were not able to generate a unique or intersecting set for the AES algorithm, we only had the implementation signature for OpenSSL AES to match the trace. Among the implementation signatures, the OpenSSL AES signature had a relatively low match of 49%, compared to the results from the previous section. Nevertheless, other implementation signatures followed at about 20-30%, and OpenSSL AES still stood out among them. The intersect and unique signatures (available only for DES, RSA, MD5) detected one high false-positive (intersecting DES with 56%) and some lower false-positives around 35%.

The verifier identification method outperformed all other methods. Of the 350 blocks of encrypted AES data, which we recorded using tcpdump for verification purposes, the identification method was able to find and verify the plaintext, key, and corresponding ciphertext of 331 blocks (success rate of 94.6%). Using the AES reference implementation, the method checked whether 3,395 candidate keys and 4,205 candidate plaintexts correspond to one of 8,037 candidate ciphertexts. The missed 5.4% of AES primitives were caused by the memory reconstruction method, as the identification method only uses data from the reconstruction and verifies it using the reference implementation. Thus, the missing data was not reconstructed and therefore could not be verified.

### 7.5 Distortion with Executable Packers

To test the identification performance against binary modification, such as binary packing and obfuscation, we packed a testing application and analyzed it using our system. The packer used was ASPack version 2.12, and the testing application was a simple XOR application with an input/output of 4096 bytes. We chose ASPack because it is a common, widely used packer and represents a large class of packing programs.

While the trace size increased by a factor of 17 and the analysis took longer, the analysis tool was still able to identify all blocks of XOR-encrypted text. Interestingly, the packer introduced 24 new loops, but the loop analysis was still able to point out the original XOR encryption loop, which was also found in the original testing application. The packed loop still had 32 executions, with 128 iterations each, to encrypt a total of 4096 bytes. Although this evaluation is brief and only one packer was studied, the result indicates that the different heuristics are not significantly perturbed by the introduction of executable packers and can handle packed binaries.

### 7.6 Real-World Malware Sample: GpCode

We also tested the system against a real-world malware sample, GpCode, to demonstrate that we can identify cryptographic primitives in a given binary sample in an automated way. GpCode is a ransomware that encrypts the system's files with a key generated by the malware after infecting the system. The malware then informs the victim of payment methods to obtain a decryption tool. The malware uses a custom executable packer and serves as another test case for distortion introduced via binary obfuscation.

In our tests, we found that only certain document formats, such as .doc, .pdf, and .txt files, were encrypted. For each file, the first three 16-byte blocks were encrypted, and a marker (0x03000000) was appended to the file. Our tool determined that all encryption operations use the same 256-bit key to perform AES in ECB mode and correctly extracted this key. Furthermore, the tool found that the symmetric AES key is encrypted using the malware author's RSA-1024 public key to allow the victim to forward this information to the author. When executing the malware sample in our system, we were able to locate all instances of AES encryptions. Due to the malware's iteration over the complete filesystem, the tracing took 14 hours, and the analysis phase took 8 hours. No manual intervention was necessary, and the tool extracted the relevant information automatically. A victim could use our tool to discover the AES key and decode all files accordingly.

### 7.7 Limitations

The heuristics presented in this paper have several drawbacks and limitations. Dynamic analysis has the general constraint that if code is not executed, it cannot be analyzed. Thus, we rely on the fact that the binary executable unconditionally executes the cryptographic code that we want to analyze. Otherwise, the code would not be incorporated into the trace and cannot be used by the later identification methods. A drawback of our current implementation is that the DBI framework Pin cannot handle all kinds of malicious software, as the malware might detect the presence of the instrumentation code. However, we could implement the same heuristics based on other, more robust DBI or malware analysis frameworks.

The signature-based heuristics rely on the knowledge of the cryptographic algorithm to generate the signatures. If the attacker implements a custom cryptographic protocol, these heuristics cannot detect it. Several modifications to the internal functions of cryptographic algorithms can be performed, often to gain a space or time advantage. Common forms include lookup tables and loop unrolling. Since the correct and efficient implementation of cryptographic algorithms is a non-trivial task, many public code libraries exist to support application developers. We expect that cryptographic code is often reused from libraries such as OpenSSL or interfaces like the Microsoft Cryptography API.

A compiler could generate code with characteristics not caught by our heuristics. To address this, our testing applications were created using two different compilers, each with a different approach to optimizing assembly code. Additionally, the results might depend on the compiler settings and optimizations used when creating the binary. Hence, we varied the compiler settings for the different evaluation programs. A related problem is interpreted code; during our analysis, we mainly considered C/C++ compiled code. However, an attacker could use an interpreted language like Python to implement cryptographic routines, complicating analysis. Although an intermediate language can be well suited for heuristic identification, this is out of the scope of this work.

### 7.8 Conclusion

In this paper, we presented several methods to identify cryptographic code in binary programs. We pointed out the drawbacks of state-of-the-art approaches in this area and evaluated available tools and techniques. Based on the insights and characteristics of cryptographic implementations, we developed three improved heuristics to enhance the detection accuracy. The implemented system was evaluated, and we showed that our approach outperforms existing methods.

**Availability:** To foster research in this area, we publish our implementation of the different techniques and the datasets used for the evaluation. All information is available at http://code.google.com/p/kerckhoffs.

**Acknowledgements:** This work has been supported by the Ministry of Economic Affairs and Energy of the State of North Rhine-Westphalia (Grant 315-43-02/2-005-WFBO-009). We also thank the anonymous reviewers for their valuable insights and comments.

### References

1. Beaucamps, P., Filiol, E.: On the Possibility of Practically Obfuscating Programs Towards a Unified Perspective of Code Protection. Journal in Computer Virology 3(1), 3–21 (2007)
2. Caballero, J., Poosankam, P., Kreibich, C., Song, D.: Dispatcher: Enabling Active Botnet Infiltration using Automatic Protocol Reverse-Engineering. In: ACM Conference on Computer and Communications Security, CCS (2009)
3. Caballero, J., Poosankam, P., McCamant, S., Babić, D., Song, D.: Input Generation via Decomposition and Re-stitching: Finding Bugs in Malware. In: ACM Conference on Computer and Communications Security (2010)
4. Caballero, J., Yin, H., Liang, Z., Song, D.: Polyglot: Automatic Extraction of Protocol Message Format Using Dynamic Binary Analysis. In: ACM Conference on Computer and Communications Security, CCS (2007)
5. Holz, T., Steiner, M., Dahl, F., Biersack, E., Freiling, F.: Measurements and Mitigation of Peer-to-Peer-based Botnets: A Case Study on Storm Worm. In: First USENIX Workshop on Large-Scale Exploits and Emergent Threats, LEET (2008)
6. Kruegel, C., Balzarotti, D., Robertson, W.K., Vigna, G.: Improving Signature Testing through Dynamic Data Flow Analysis. In: Annual Computer Security Applications Conference (ACSAC), pp. 53–63. IEEE Computer Society, Los Alamitos (2007)
7. Leder, F., Werner, T.: Know Your Enemy: Containing Conficker - To Tame A Malware. Know Your Enemy Series of the Honeynet Project (2009)
8. Lengauer, T., Tarjan, R.: A Fast Algorithm for Finding Dominators in a Flowgraph. ACM Transactions on Programming Languages and Systems 1(1), 121–141 (1979)
9. Lin, Z., Jiang, X., Xu, D., Zhang, X.: Automatic Protocol Format Reverse Engineering through Context-Aware Monitored Execution. In: Network and Distributed System Security (NDSS). The Internet Society (2008)
10. Linn, C., Debray, S.: Obfuscation of Executable Code to Improve Resistance to Static Disassembly. In: ACM Conference on Computer and Communications Security, CCS (2003)
11. Luk, C., Cohn, R., Muth, R., Patil, H., Klauser, A., Lowney, G., Wallace, S., Reddi, V., Hazelwood, K.: Pin: Building Customized Program Analysis Tools with Dynamic Instrumentation. In: ACM SIGPLAN Conference on Programming Language Design and Implementation, pp. 190–200. ACM, New York (2005)
12. Lutz, N.: Towards Revealing Attackers’ Intent by Automatically Decrypting Network Traffic. Master’s thesis, ETH Zürich (2008)
13. Moser, A., Kruegel, C., Kirda, E.: Limits of Static Analysis for Malware Detection. In: Annual Computer Security Applications Conference, ACSAC (2007)
14. Newsome, J., Song, D.X.: Dynamic Taint Analysis for Automatic Detection, Analysis, and Signature Generation of Exploits on Commodity Software. In: Network and Distributed System Security, NDSS (2005)
15. Popov, I.V., Debray, S.K., Andrews, G.R.: Binary Obfuscation Using Signals. In: USENIX Security Symposium (2007)
16. Porras, P., Saidi, H., Yegneswaran, V.: Conficker C P2P Protocol and Implementation. Tech. rep., SRI International (2009)
17. Stewart, J.: Inside the Storm: Protocols and Encryption of the Storm Botnet. Black Hat USA (2008)
18. Tubella, J., González, A.: Control Speculation in Multithreaded Processors through Dynamic Loop Detection. In: 4th International Symposium on High-Performance Computer Architecture (1998)
19. Vigna, G.: Static Disassembly and Code Analysis. Malware Detection (2006)
20. Wang, Z., Jiang, X., Cui, W., Wang, X., Grace, M.: ReFormat: Automatic Reverse Engineering of Encrypted Messages. In: Backes, M., Ning, P. (eds.) ESORICS 2009. LNCS, vol. 5789, pp. 200–215. Springer, Heidelberg (2009)
21. Werner, T., Leder, F.: Waledac Isn’t Good Either! InBot (2009)
22. Wondracek, G., Comparetti, P., Kruegel, C., Kirda, E.: Automatic Network Protocol Analysis. In: Network and Distributed System Security, NDSS (2008)
23. Young, A., Yung, M.: Cryptovirology: Extortion-Based Security Threats and Countermeasures. In: IEEE Symposium on Security and Privacy. pp. 129–141 (1996)