72(cid:1)%
76(cid:1)% 100(cid:1)%
74(cid:1)%
22(cid:1)%
11(cid:1)%
34(cid:1)%
66(cid:1)%
49(cid:1)%
53(cid:1)%
71(cid:1)%
41(cid:1)%
55(cid:1)%
25(cid:1)% 37(cid:1)% 41(cid:1)% 100(cid:1)% 27(cid:1)% 45(cid:1)%
9(cid:1)%
9(cid:1)%
Fig. 4. Results of the signature matching using (mnemonic, constant)-tuples
overall good if we consider the unique-signatures. Since the signatures are par-
tially generated from the testing applications, their matching performance seems
successful in the evaluation. But if we evaluate against slightly diﬀerent code,
we expect that the detection rate might decrease. Therefore, a fuzzy matching
algorithm for the mnemonic sequence comparison could mitigate the problem
and we will investigate such a method as part of our future work.
The performance of the (mnemonic, constant)-tuple matching method is the
most successful of the signature identiﬁcation methods. The details of the results
are presented in Figure 4: the signatures are displayed on the y-axis and the
testing applications are shown on the x-axis. Each highlighted ﬁeld links the
testing application to the respective signature. If we apply the threshold of 70%,
all implementations are correctly identiﬁed.
Third, the verifier heuristic, which also veriﬁes the existence and the param-
eters of a symmetric encryption, is also capable of detection the cryptographic
primitives within a given program. Table 4 shows that the method is able to
detect nearly every instance of the symmetric encryption algorithms (RSA and
MD5 are thus marked as n/a). The only undetected trace is Gladman’s AES im-
plementation. By design, the method does not yield false-positive results. The
success of this method is closely bound to the memory reconstruction method de-
scribed in Section 3.2. In case of the Gladman AES implementation, the memory
reconstruction method is unable to reconstruct the cryptographic parameters.
Thus, the method has no success. Although the memory reconstruction often
leads up to 2000 candidates for encryption key, plaintext, and ciphertext each,
the time for the candidate check is feasible. For AES, our non-optimized AES
candidate check function is able to conduct 400,000 checks per second. If 2000
candidates for each parameter exist, the veriﬁcation of all the candidates would
only need 2000
2
400000 = 10s.
56
F. Gr¨obert, C. Willems, and T. Holz
Table 4. Analysis results for our improved identiﬁcation methods
mnemonic-const verifier
Implementation Algorithm chains
success
success
success
success
success
success
success
success
success
success
success
success
success
success
success
success
success
success
success
success
success
success
success
success
success & FP success
Beecrypt AES
Brian Gladman AES
Cryptopp AES
OpenSSL AES
Cryptopp DES
OpenSSL DES
Cryptopp RC4
OpenSSL RC4
Beecrypt MD5
Cryptopp MD5
OpenSSL MD5
Cryptopp RSA
OpenSSL RSA
success
no success
success
success
success
success
success
success
n/a
n/a
n/a
n/a
n/a
4.3 Oﬀ-the-Shelf Application
To show the generic usage of our approaches, we tested our system implemen-
tation against oﬀ-the-shelf software. We traced and analyzed a SSL session of
the Curl HTTP client. Curl itself utilizes the OpenSSL library for establishing
a SSL connection. In the testing environment, we used Curl version 7.19.7 with
OpenSSL version 0.9.8l. We downloaded a HTML ﬁle from a webserver using
HTTPs and traced the execution as explained in Section 3.2. We observed that
the remote SSL server and the Curl client negotiated the following SLL cipher
suite setting: TLS DHE RSA WITH AES 256 CBC SHA. This means that the cipher
suite speciﬁes Diﬃe-Hellman Key Exchange, with RSA certiﬁcates, symmetric
encrypted by AES in CBC mode with 256 bit keys, and integrity checked by
SHA1. Thus, we knew that the analysis should at least detect the RSA and
AES invocation. The selected cipher was used to encrypt three packets of SSL
application data. Obviously, the ﬁrst packet was the client HTTP request of 160
encrypted bytes, and then followed the server response with 272 bytes for the
HTTP header and 5168 bytes of content.
The results are summarized in Table 5. The method by Caballero et al. suc-
cessfully detected 19 basic blocks in the encryption and key scheduling functions
AES set decrypt key, AES set encrypt key, AES decrypt, and AES encrypt.
Lutz’s method revealed 2,121 entropy changes in 26 loop bodies corresponding to
22 functions, for example in the AES encryption and decryption functions, but
also in false-positive functions like ASN1 OBJECT it or OBJ NAME do all sorted.
The method by Wang et al. generated no results, probably due to the fact that
the trace did not start at the beginning of the application.
The chains method, which compares mnemonic sequences, detected both
AES and RSA without false-positives. An interesting result was revealed by the
signature-based mnemonic-const identiﬁcation method: since we were not able
to generate an unique or intersecting set for the AES algorithm, we only had
Automated Identiﬁcation of Cryptographic Primitives in Binary Programs
57
Table 5. Analysis performance for the Curl trace
Method
Caballero et al.
Lutz
Wang et al.
chains
mnemonic-const
verifier
Results
detected core AES basic blocks
detected core AES loops, few FPs
no results
detected AES and RSA, including implementation
detected AES implementation, one false-positive
detected 94.6% of AES instances including parameters
the implementation signature for OpenSSL AES to match the trace. Among the
implementation signatures, the OpenSSL AES signature had a relatively low
match of 49%, compared to the results from the previous section. Nevertheless,
other implementation signatures followed at about 20-30% and OpenSSL AES
still stood out among them. The intersect and unique signatures (available only
for DES, RSA, MD5) detected one high false-positive (intersecting DES with
56%) and some lower false-positives around 35%.
The verifier identiﬁcation method outperformed all other methods. Of the
350 blocks of encrypted AES data, which we recorded using tcpdump for veriﬁca-
tion purposes, the identiﬁcation method was able to ﬁnd and verify the plaintext,
key, and corresponding ciphertext of 331 blocks (success rate of 94.6%). Using
the AES reference implementation, the method checked whether 3395 candi-
date keys and 4205 candidate plaintexts correspond to one of 8037 candidate
ciphertexts. The missed 5.4% of AES primitives were caused by the memory
reconstruction method, because the identiﬁcation method only uses data from
the reconstruction and veriﬁes it using the reference implementation. Thus, the
missing data has not been reconstructed and therefore could not be veriﬁed.
4.4 Distortion with Executable Packers
In order to test the identiﬁcation performance against binary modiﬁcation, e.g.,
binary packing and obfuscation, we packed a testing application and analyzed it
using our system. The used packer was ASPack in version 2.12 and the testing
application was a simple XOR application with an input/output of 4096 bytes.
We chose ASPack since it is a common, widely used packer and the tool represent
a large class of packing programs.
While the trace size increased by factor 17 and the analysis took longer,
the analysis tool was still able to identify all blocks of XOR encrypted text.
Interestingly, the packer introduced 24 new loops, but the loop analysis was still
able to point out the original XOR encryption loop, which was also found in the
original testing application. The packed loop still had 32 executions, with 128
iterations each, to encrypt a total of 4096 bytes. While this evaluation is only
brief and we studied only a single packer, the result nevertheless indicates that
the diﬀerent heuristics are not perturbed by introducing executable packers and
can thus also handle packed binaries.
58
F. Gr¨obert, C. Willems, and T. Holz
4.5 Real-World Malware Sample: GpCode
We also tested the system against a real-world malware sample to demonstrate
that we can indeed identify cryptographic primitives of a given binary sample in
an automated way. The ransomware GpCode is a prime example for the applica-
tion of cryptography in malware: after having infected a system, the malware’s
intend is not to hide its presence on the machine. Instead, GpCode encrypts the
system’s ﬁles with a key generated by the malware. Afterwards, the malware
informs the victim of payment methods in order to obtain a decryption tool.
The malware uses a custom executable packer and serves as another test case
for distortion introduced via binary obfuscation.
In our tests, we found that only certain document formats are encrypted, e.g.,
.doc, .pdf, .txt ﬁles. For each ﬁle, the ﬁrst three 16 byte blocks were encrypted
and a marker (0x03000000) was appended to the ﬁle. Our tool determined that
all encryption operations use the same 256-bit key to perform AES in ECB
mode and the tool correctly extracted this key. Furthermore, the tool found that
the (symmetric) AES key is encrypted using the malware author’s RSA-1024
(asymmetric) public key in order to let the victim forward this information to
the author. When executing the malware sample in our system, we were able to
locate all instances of AES encryptions. Due to the malware’s iteration over the
complete ﬁlesystem, the tracing took 14 hours and the analysis phase 8 hours.
Note that no manual intervention was necessary, the tool extracted the relevant
information in an automated way. A victim could use our tool to discover the
AES key and then decode all ﬁles accordingly.
5 Limitations
The heuristics presented in this paper also have several drawbacks and limita-
tions which we discuss next. Obviously, dynamic analysis has the general con-
straint that if code is not executed, it cannot be analyzed. Thus, we rely on the
fact that the binary executable unconditionally executes the cryptographic code
that we want to analyze. Otherwise, the code would not be incorporated in the
trace and thus cannot be used by the later identiﬁcation methods. A drawback of
our current implementation is the fact that the DBI framework Pin cannot han-
dle all kinds of malicious software since the malware might detect the presence
of the instrumentation code. However, we could implement the same heuristic
based on other, more robust DBI or malware analysis frameworks.
The signature-based heuristics we introduced in this paper rely on the knowl-
edge of the cryptographic algorithm such that we can generate the signatures.
If the attacker implements his own cryptographic protocol, then these heuristics
can not detect this fact. Several modiﬁcations to the internal functions of crypto-
graphic algorithms can be performed, mostly to gain a space or time advantage.
A very common form is a lookup table, which can be employed instead of bitwise
addition and shifting. Another common programming technique is loop unrolling
to avoid the ﬂushing of the CPU’s instruction pipeline and to save the loop’s
Automated Identiﬁcation of Cryptographic Primitives in Binary Programs
59
control instructions, e.g., JMP or INC. Since the correct and eﬃcient implementa-
tion of cryptographic algorithms is a non-trivial task, many public code libraries
exist to support application developers. Since the implementation is hard and
even small changes can break the strength of the software, we expect that cryp-
tographic code is often reused from cryptographic libraries such as OpenSSL or
interfaces such as the Microsoft Cryptography API.
A compiler could generate code that has other characteristics not caught by
our heuristics. To address this problem, our testing applications are created using
two diﬀerent compilers, because each compiler has a diﬀerent approach towards
optimizing the assembly code and thus produces diﬀerent results. Furthermore,
the results might depend on the compiler settings and optimizations used when
creating the binary. Hence, we varied the compiler settings for the diﬀerent
evaluation programs. A related problem is interpreted code: during our analysis,
we consider mainly C/C++ compiled code. However, an attacker could also
use an interpreted language such as Python to implement his cryptographic
routines which complicates analysis. Although an intermediate language can be
well suited for heuristic identiﬁcation, this is out of the scope of this work.
6 Conclusion
In this paper, we presented several methods to identify cryptographic code in
binary programs. We pointed out the drawbacks of state-of-the art approaches
in this area and evaluated available tools and techniques. Based on the insights
and characteristics of cryptographic implementations, we developed three im-
proved heuristics to enhance the detection accuracy. The implemented system
was evaluated and we showed that our approach outperforms existing methods.
Availability. We believe that the interest in security analysis of cryptographic
code will increase in the future. To foster research in this area, we publish our im-
plementation of the diﬀerent techniques and the data sets we used for the evalu-
ation. All information is available at http://code.google.com/p/kerckhoffs.
Acknowledgements. This work has been supported by the the Ministry of
Economic Aﬀairs and Energy of the State of North Rhine-Westphalia (Grant
315-43-02/2-005-WFBO-009). We also thank the anonymous reviewers for their
valuable insights and comments.
References
1. Beaucamps, P., Filiol, E.: On the Possibility of Practically Obfuscating Programs
Towards a Uniﬁed Perspective of Code Protection. Journal in Computer Virol-
ogy 3(1), 3–21 (2007)
2. Caballero, J., Poosankam, P., Kreibich, C., Song, D.: Dispatcher: Enabling Ac-
tive Botnet Inﬁltration using Automatic Protocol Reverse-Engineering. In: ACM
Conference on Computer and Communications Security, CCS (2009)
3. Caballero, J., Poosankam, P., McCamant, S., Babi´c, D., Song, D.: Input Gener-
ation via Decomposition and Re-stitching: Finding Bugs in Malware. In: ACM
Conference on Computer and Communications Security (2010)
60
F. Gr¨obert, C. Willems, and T. Holz
4. Caballero, J., Yin, H., Liang, Z., Song, D.: Polyglot: Automatic Extraction of
Protocol Message Format Using Dynamic Binary Analysis. In: ACM Conference
on Computer and Communications Security, CCS (2007)
5. Holz, T., Steiner, M., Dahl, F., Biersack, E., Freiling, F.: Measurements and Mit-
igation of Peer-to-Peer-based Botnets: A Case Study on Storm Worm. In: First
USENIX Workshop on Large-Scale Exploits and Emergent Threats, LEET (2008)
6. Kruegel, C., Balzarotti, D., Robertson, W.K., Vigna, G.: Improving Signature Test-
ing through Dynamic Data Flow Analysis. In: Annual Computer Security Appli-
cations Conference (ACSAC), pp. 53–63. IEEE Computer Society, Los Alamitos
(2007)
7. Leder, F., Werner, T.: Know Your Enemy: Containing Conﬁcker - To Tame A
Malware. Know Your Enemy Series of the Honeynet Project (2009)
8. Lengauer, T., Tarjan, R.: A Fast Algorithm for Finding Dominators in a Flowgraph.
ACM Transactions on Programming Languages and Systems 1(1), 121–141 (1979)
9. Lin, Z., Jiang, X., Xu, D., Zhang, X.: Automatic Protocol Format Reverse Engi-
neering through Context-Aware Monitored Execution. In: Network and Distributed
System Security (NDSS). The Internet Society (2008)
10. Linn, C., Debray, S.: Obfuscation of Executable Code to Improve Resistance to
Static Disassembly. In: ACM Conference on Computer and Communications Se-
curity, CCS (2003)
11. Luk, C., Cohn, R., Muth, R., Patil, H., Klauser, A., Lowney, G., Wallace, S.,
Reddi, V., Hazelwood, K.: Pin: Building Customized Program Analysis Tools with
Dynamic Instrumentation. In: ACM SIGPLAN Conference on Programming Lan-
guage Design and Implementation, pp. 190–200. ACM, New York (2005)
12. Lutz, N.: Towards Revealing Attackers’ Intent by Automatically Decrypting Net-
work Traﬃc. Master’s thesis, ETH Z¨urich (2008)
13. Moser, A., Kruegel, C., Kirda, E.: Limits of Static Analysis for Malware Detection.
In: Annual Computer Security Applications Conference, ACSAC (2007)
14. Newsome, J., Song, D.X.: Dynamic Taint Analysis for Automatic Detection, Anal-
ysis, and SignatureGeneration of Exploits on Commodity Software. In: Network
and Distributed System Security, NDSS (2005)
15. Popov, I.V., Debray, S.K., Andrews, G.R.: Binary Obfuscation Using Signals. In:
USENIX Security Symposium (2007)
16. Porras, P., Saidi, H., Yegneswaran, V.: Conﬁcker C P2P Protocol and Implemen-
tation. Tech. rep., SRI International (2009)
17. Stewart, J.: Inside the Storm: Protocols and Encryption of the Storm Botnet. Black
Hat USA (2008)
18. Tubella, J., Gonz´alez, A.: Control Speculation in Multithreaded Processors through
Dynamic Loop Detection. In: 4th International Symposium on High-Performance
Computer Architecture (1998)
19. Vigna, G.: Static Disassembly and Code Analysis. Malware Detection (2006)
20. Wang, Z., Jiang, X., Cui, W., Wang, X., Grace, M.: ReFormat: Automatic Reverse
Engineering of Encrypted Messages. In: Backes, M., Ning, P. (eds.) ESORICS 2009.
LNCS, vol. 5789, pp. 200–215. Springer, Heidelberg (2009)
21. Werner, T., Leder, F.: Waledac Isn’t Good Either! InBot (2009)
22. Wondracek, G., Comparetti, P., Kruegel, C., Kirda, E.: Automatic Network Pro-
tocol Analysis. In: Network and Distributed System Security, NDSS (2008)
23. Young, A., Yung, M.: Cryptovirology: Extortion-Based Security Threats and Coun-
termeasures. In: IEEE Symposium on Security and Privacy. pp. 129–141 (1996)