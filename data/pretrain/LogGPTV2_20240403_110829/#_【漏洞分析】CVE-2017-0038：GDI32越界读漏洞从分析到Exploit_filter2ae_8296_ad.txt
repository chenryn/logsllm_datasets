    00007ffd`cf88e104 ff1596ee0300    call    qword ptr [gdi32full!_imp_StretchDIBits (00007ffd`cf8ccfa0)] ds:00007ffd`cf8ccfa0={GDI32!StretchDIBits (00007ffd`d1143370)}
    0:026> dd 29606a4a0dc+74
    00000296`06a4a150  00ed1c24 0000000e 00000014 00000000
    00000296`06a4a160  00000010 00000014 18abea8b 90018400
而本来图像大小是取决于BITMAPINFOHEADER和EMRSETIDIBITSTODEVICE共同决定,在BITMAPINFOHEADER中的很多因素决定了图像bitmap的性质,比如bicompression决定了图像的压缩算法或者是否压缩(本实例中为0x0,no
compression,这样才能正常泄露内存),而图像内容的偏移和bitmap内容保存在EMRSETDIBITSTODEVICE,但在上述的分析过程中,bplay处理逻辑并没有对要拷贝的内容的大小和图像本身大小bBitsSrc进行比较，而直接拷贝了，导致拷贝了cxSrc*cySrc*3的内存空间，造成了内存泄露。这里为了4字节对齐，会对泄露的内存空间的3字节补上一个0xFF。（笔者注：感谢@程序人生对文章的质疑，这里笔者在进行分析的过程中，在最后这个过程直接参照了0patch文章中的漏洞成因，而没有详细分析StrechToDIB函数的逻辑）
下面我贴出这个函数的伪代码，相关注释已经写在伪代码中。
    __int64 __fastcall MRSETDIBITSTODEVICE::bPlay(MRSETDIBITSTODEVICE *this, void *a2, struct tagHANDLETABLE *a3)
    {
      HDC v3; // r15@1
      MRSETDIBITSTODEVICE *v4; // rbx@1
      struct tagHANDLETABLE *v5; // r14@1
      unsigned int v6; // edi@1
      __int64 v7; // rax@1
      __int64 v8; // rbp@1
      signed int v10; // eax@9
      BITMAPINFO *v11; // rax@11
      const BITMAPINFO *v12; // rsi@11
      signed int v13; // eax@12
      int v14; // eax@14
      unsigned __int32 v15; // er9@16
      char *v16; // r8@19
      struct tagPOINT pt; // [sp+A0h] [bp+18h]@6
      v3 = (HDC)a2;
      v4 = this;
      v5 = a3;
      v6 = 0;
      LODWORD(v7) = pvClientObjGet(a3->objectHandle[0], 4587520i64);//a3是头部，判断ENHMETA_SIGNATURE是不是EMF
      v8 = v7;
      if ( !v7 || !(unsigned int)MRSETDIBITSTODEVICE::bCheckRecord(v4, v5) )//满足v6是EMF，且bCheckRecord会对EMRSETDIBITSTODEVICE结构体成员变量的大小作检查（仅仅是对结构体各自成员变量大小，而没有检查bitmap整体size）
        return 0i64;
      if ( MF::bClipped((MF *)v8, (MRSETDIBITSTODEVICE *)((char *)v4 + 8)) )//这个函数会check MF和ERECTL的上下左右值，是否在满足范围内
        return 1i64;
      pt.x = *((_DWORD *)v4 + 6);//对EMF的xDest和yDest进行传递
      pt.y = *((_DWORD *)v4 + 7);
      if ( !LPtoDP(*(HDC *)(v8 + 728), &pt, 1)//将逻辑坐标转换成HDC的坐标
        || !SetWorldTransform(v3, (const XFORM *)(v8 + 704))//建立用于转换，输出图形的二维线形变换
        || !(unsigned int)MR::bValidOffExt(v4, v5, *((_DWORD *)v4 + 12), *((_DWORD *)v4 + 13)) )//检查bitmap信息正确性
      {
        return 0i64;
      }
      v10 = 1272;
      if ( *((_DWORD *)v4 + 13) > 0x4F8u )
        v10 = *((_DWORD *)v4 + 13);
      v11 = (BITMAPINFO *)LocalAlloc(0x40u, (unsigned int)v10);//开辟一个V10（4f8）大小的空间
      v12 = v11;
      if ( v11 )
      {
        memcpy(v11, (char *)v4 + *((_DWORD *)v4 + 12), *((_DWORD *)v4 + 13));//拷贝bitmapinfo到目标内存
        v13 = 248;
        if ( v12->bmiHeader.biSize bmiHeader.biSize;//小于f8则当前值
        v12->bmiHeader.biSize = v13;//大于f8则f8，限定bisize最大值
        v14 = *((_DWORD *)v4 + 18);//
        if ( v12->bmiHeader.biHeight bmiHeader.biHeight = v14;
        v12->bmiHeader.biSizeImage = *((_DWORD *)v4 + 15);//设定bitmapinfoheader中biSizeImage值为cbBitsSrc
        v15 = *((_DWORD *)v4 + 15);//cbBitSize交给v15
        if ( !v15 || (unsigned int)MR::bValidOffExt(v4, v5, *((_DWORD *)v4 + 14), v15) )
        {
          if ( *((_DWORD *)v4 + 15) )//如果cbBitSize不为0
            v16 = (char *)v4 + *((_DWORD *)v4 + 14);//则v16为EMRSETDIBSITODEVICE结构+偏移14，也就是offBitsSrc
          else
            v16 = 0i64;
          LOBYTE(v6) = StretchDIBits(//拷贝目标像素到指定矩形中,没有判断，产生漏洞
                         v3,
                         pt.x,
                         pt.y,
                         *((_DWORD *)v4 + 10),
                         *((_DWORD *)v4 + 11),
                         *((_DWORD *)v4 + 8),
                         *((_DWORD *)v4 + 9) - *((_DWORD *)v4 + 17),
                         *((_DWORD *)v4 + 10),
                         *((_DWORD *)v4 + 11),
                         v16,//指向要拷贝bitmap的指针
                         v12,
                         *((_DWORD *)v4 + 16),
                         0xCC0020u) != 0;
        }
      }
      LocalFree((HLOCAL)v12);
      MF::bSetTransform((MF *)v8, v3);
      return v6;
    }
**JS Exploit与Web Safe Color**
到此，我们分析了这个漏洞的成因，可能读到这里大家都会有一些和我当时一样的疑问，就是为什么我们要打印的内容是0x00ED1C24，也就是说，这里不管内存如何泄露，固定不变的值应该是0x00ED1C24，但是像诸如0patch文章中所说的，固定的值却是0xFF3333FF呢。
首先我们一起来把这个PoC修改成Exploit，用JS在网页中打印泄露的内存地址，在之前我们将cxSrc和cySrc修改回泄露内存的PoC，接下来，通过getImageData的方法，来获得图像的像素，之后将这个值打印。打印的Length实际上我输出多了，这里只需要1024（0x10*0x10*4）足以表示整个poc.emf图像。
可以看到，我们泄露了内存地址的信息，这些信息其实在本质上是包含着很多内容的。比如一些关键的内存地址信息等等。但是在测试的过程中，我没有发现有关浏览器的一些信息，比如cookie之类的，不知道是不是因为我的浏览器比较干净，内存驻留的信息较少。
但这里有几个问题，第一个就是我多次调试之后，发现内存泄露的信息位置很不稳定，也就是说，它可以用来泄露浏览器信息，但是用来做稳定的info
leak来bypass ASLR似乎不太可行，其次，我们来对比一下泄露内存的内容和我之前在浏览器中打印的图像泄露的内容是不同的。
这也是为什么无论是我调试还是0patch文章中都会在浏览器打印0xFF3333FF的原因，Web Safe Color！Web Safe
Color是一种安全颜色的表示，开发者认为在256种颜色中，只需要216种颜色就能保证浏览器稳定输出图像，而不会让图像产生抖动，而这216种颜色用0x00,0x33,0x66,0x99,0xcc,0xff组合就能表示了，也就是说我们的内存在图像打印的时候，会被web
safe color强制转换。
下面我修改poc.emf中bitmap的像素值，来看看在浏览器中图像强制转换打印的内容。
所以可以看到这个过程不可逆，因此，至少在IE11浏览器，由于Web Safe
Color导致我们内存泄露方法获取一些敏感数据的思路似乎不太可行，接下来，我们通过C语言来写一个Exploit，来看一下真正的内存泄露。
**CVE-2017-0038 Out-of-bound Read Exploit**
重新回过头看一下之前的bplay函数断点，实际上，这里调用了一个GDI32的API，叫做PlayEnhMetaFile，正是这个API内层函数调用到了bplay，因此我们在C中通过PlayEnhMetaFile来调用MRSETDIBITSTODEVICE::bplay。这个过程会将EMF文件转储到hdc上，这样，我们就构建了一个基本的Exploit思路：
通过GetDC函数来获取一个HDC
通过GetEnhMetaFile来加载poc.emf
通过PlayEnhMetaFile来将hemf转储到hedc中
通过GetPixel来从hedc中读取像素值，这个像素值泄露了内存信息，保存到一个DWORD数组里。
可以看到，我们的DWORD
color[]数组读取到了更多的内存信息，但其实在我们当前的进程空间里，这样的内存信息还是太少了，换句话说当前进程太单纯2333，我们可以正常打印PJ0提供的一个poc.emf，由于这个GetDC是Null，图像将会打印在左上角。
可以看到，除了左下角的0x00241ced，其他的都是0x00（#00000000表示黑色），也就是初始化的内存空间（这里0x00241ced也是红色），到此我们完成了对于这个漏洞的分析和利用，如有不当之处，还望大家多多包含，多多交流，谢谢！
最后我把exploit地址放在末尾：