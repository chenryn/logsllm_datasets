To formally deﬁne the notion we introduce a distinguishing
game FINbM(ν),I(ν),I(ν),A(η) where an adversary A tries to
distinguish between the case when he interacts with the real
implementation, or with an alternative implementation that
is oblivious with respect to all of the forgetful arguments.
We say that an implementation is forgetful, if there exists an
oblivious implementation such that no adversary succeeds
in this task. Due to lack of space the formal deﬁnition of
FIN is in the Appendix.
Definition 4
(forgetful implementation). We say
that an implementation I = (M, [[·]], len, open, valid) is a
forgetful implementation of a forgetful symbolic model M
if there is an oblivious implementation I = (M , [[·]], len,
open, valid) such that for all for all parametrized trans-
parent symbolic models Mtran(ν) and for all parametrized
transparent implementations Itran(ν) of Mtran(ν) such that
(M(ν),Itran(ν)) compatible with (M,I) we have that
0M∪Mtran(ν),I∪Itran(ν),I∪Itran(ν),A(η) = 1]
1M∪Mtran(ν),I∪Itran(ν),I∪Itran(ν),A(η) = 1]
Prob[FIN
−Prob[FIN
is negligible for every p.p.t. adversary A.
The intuition that encryption schemes are forgetful with
respect to their plaintexts is captured by the lemma below.
Consider the forgetful symbolic model MPKE as the symbolic
symbolic model MPKE from Section 7.4 where we mark the
message m for honest encryptions ench(ek , m) as forgetful.
Lemma 1. IPKE from Section 7.4 is a forgetful implemen-
tation of MPKE.
Sending keys around. To be able to consider the case
when symmetric keys are sent encrypted we introduce an
extension of the model for symmetric key encryption of
Section 7.2. The extension is that the validity predicate
(which controls the valid queries by the adversary) can now
depend on a signature Σ that contains functions with forget-
ful positions. The new validity predicate allows for standard
generation of keys for symmetric encryption (with the same
restrictions as those in Section 7.2), but in addition it also
allows for generate requests that contain occurrences of sym-
metric keys under functions from signature Σ, as long as the
occurrences are on forgetful positions. For concreteness, let
validSKE[Σ] be the predicate obtained from valid as described
above.
The composition theorem that we prove in this case is that
any deduction sound implementation of Σ that is forgetful
can be extended with symmetric key encryption. We em-
phasize that the added value over the results of Section 7.2
is that the validity predicate is more relaxed, and allows for
keys to occur in non-key positions. We therefore prove the
following theorem.
Theorem 7. Let M be a forgetful symbolic model and I
be a forgetful deduction sound implementation of M. Let
Σ be the signature of M, and let validSKE[Σ] be the validity
predicate for ISKE. If (MSKE,ISKE) and (M,I) are compati-
ble and the valid predicate of I does not depend on function
symbols from ΣSKE, then I ∪ ISKE is a deduction sound im-
plementation of M ∪ MSKE.
As an application of the above theorem we have the follow-
ing. Since the implementation for public key encryption IPKE
from Section 7.4 is a forgetful deduction sound implementa-
tion for the forgetful symbolic model MPKE (by Lemma 1),
(MPKE,IPKE) can be composed with (MSKE,ISKE). The va-
lidity predicate for the resulting composition allows for ad-
˜l
versary queries of the form “generate enc
h())”. In-
tuitively, this corresponds to sending around symmetric keys
encrypted under asymmetric keys in a protocol.
ˆl
h(ek l
h(), k
Next, we show that the composition of a forgetful de-
duction sound implementation with a secret-key encryption
preserves forgetfulness (Theorem 8). Let MSKE be the for-
getful symbolic model based on MSKE when we mark the
message m for honestly generated encryptions under honest
h(), m) as a forgetful position and let ISKE[Σ] be
keys E
an implementation of MSKE. Then the following holds:
ˆl
h(k l
Theorem 8. Let M be a forgetful symbolic model and I
be a forgetful deduction sound implementation of M. Let
1270Σ be the signature of M and validSKE[Σ] be the predicate for
(MSKE,ISKE).
If (MSKE,ISKE) and (M,I) are compatible
then I ∪ ISKE is a forgetful implementation of M ∪ MSKE
Since Theorems 7 and 8 hold for the particular case when
(M,I) = (MSKE,ISKE), by successive applications we obtain
a framework in which we include, incrementally, multiple
encryption schemes. In the resulting framework symmetric
keys can be encrypted under other symmetric keys in a hi-
erarchical fashion. The hierarchy is imposed by the order
in which schemes are added (the keys of the latter can be
encrypted under the keys of the former, but not the other
way around).
A related important observation is that it seems diﬃcult
to consider more ﬂexible predicates that allow for the occur-
rence of keys on arbitrary forgetful positions.
The reason is that if we do not make the predicate for the
symmetric encryption scheme depend on the signature of
the model to which we add symmetric encryption, it would
be impossible to detect the occurrence of encryption cycles.
For instance, assume that Σ contains a function symbol f
with a forgetful second position. Do the terms f
h())
and E
) contain a key cycle? We cannot tell without
(cid:2)
knowing the implementation of f and t
˜l
h(k l
h(), t
(cid:2)
(cid:2)
ˆl(t
, k l
.
9. ACKNOWLEDGEMENTS
The research leading to these results has received fund-
ing from the European Research Council under the Euro-
pean Union’s Seventh Framework Programme (FP7/2007-
2013) / ERC grant agreement number 258865 (ERC ProSe-
cure project). This work was additionally supported in part
by ERC Advanced Grant ERC-2010-AdG-267188-CRIPTO.
Florian B¨ohl was supported by MWK grant “MoSeS”.
10. REFERENCES
[1] M. Abadi and P. Rogaway. Reconciling two views of
cryptography (the computational soundness of formal
encryption). In Proc. 1st IFIP International
Conference on Theoretical Computer Science
(IFIP–TCS’00), volume 1872 of LNCS, pages 3–22,
2000.
[2] M. Backes and B. Pﬁtzmann. Symmetric encryption in
a simulatable Dolev-Yao style cryptographic library.
In Proc. 17th IEEE Computer Science Foundations
Workshop (CSFW’04), pages 204–218, 2004.
[3] M. Backes, B. Pﬁtzmann, and M. Waidner. A
composable cryptographic library with nested
operations (extended abstract). In Proc. of 10th ACM
Conference on Computer and Communications
Security (CCS’05), pages 220 – 230, 2003.
[4] M. Backes, B. Pﬁtzmann, and M. Waidner. Symmetric
authentication within simulatable cryptographic
library. In Proc. 8th European Symposium on Research
in Computer Security (ESORICS’03), Lecture Notes
in Computer Science, pages 271–290, 2003.
[5] M. Bellare, O. Goldreich, and A. Mityagin. The power
of veriﬁcation queries in message authentication and
authenticated encryption. IACR Cryptology ePrint
Archive, 2004:309, 2004.
[6] M. Bellare and C. Namprempre. Authenticated
encryption: Relations among notions and analysis of
the generic composition paradigm. J. Cryptology,
21(4):469–491, 2008.
[7] M. Bellare and P. Rogaway. Random oracles are
practical: A paradigm for designing eﬃcient protocols.
In D. E. Denning, R. Pyle, R. Ganesan, R. S. Sandhu,
and V. Ashby, editors, ACM Conference on Computer
and Communications Security, pages 62–73. ACM,
1993.
[8] F. B¨ohl, V. Cortier, and B. Warinschi. Deduction
soundness: Prove one, get ﬁve for free. Cryptology
ePrint Archive, Report 2013/457, 2013. Full version of
this paper. http://eprint.iacr.org/.
[9] H. Comon-Lundh and V. Cortier. Computational
soundness of observational equivalence. In Proceedings
of the 15th ACM Conference on Computer and
Communications Security (CCS’08), Alexandria,
Virginia, USA, Oct. 2008. ACM Press.
[10] V. Cortier, S. Kremer, R. K¨usters, and B. Warinschi.
Computationally sound symbolic secrecy in the
presence of hash functions. In Proceedings of the 26th
Conference on Fundations of Software Technology and
Theoretical Computer Science (FSTTCS’06), volume
4337 of LNCS, pages 176–187, Kolkata, India, 2006.
Springer.
[11] V. Cortier, S. Kremer, and B. Warinschi. A survey of
symbolic methods in computational analysis of
cryptographic systems. J. Autom. Reasoning,
46(3-4):225–259, 2011.
[12] V. Cortier and B. Warinschi. Computationally sound,
automated proofs for security protocols. In European
Symposium on Programming (ESOP’05), volume 3444
of LNCS, pages 157–171, Edinburgh, UK, 2005.
Springer.
[13] V. Cortier and B. Warinschi. A composable
computational soundness notion. In 18th ACM
Conference on Computer and Communications
Security (CCS’11), pages 63–74, Chicago, USA,
October 2011. ACM.
[14] A. Datta, A. Derek, J. C. Mitchell, V. Shmatikov, and
M. Turuani. Probabilistic Polynomial-time Semantics
for a Protocol Security Logic. In Proc. of 32nd
International Colloquium on Automata, Languages
and Programming, ICALP, volume 3580 of LNCS,
pages 16–29. Springer, 2005. Lisboa, Portugal.
[15] Y. Dodis, S. Goldwasser, Y. T. Kalai, C. Peikert, and
V. Vaikuntanathan. Public-key encryption schemes
with auxiliary inputs. In D. Micciancio, editor, TCC,
volume 5978 of Lecture Notes in Computer Science,
pages 361–381. Springer, 2010.
[16] F. D. Garcia and P. van Rossum. Sound and complete
computational interpretation of symbolic hashes in the
standard model. Theoretical Computer Science,
394:112–133, 2008.
[17] R. Janvier, Y. Lakhnech, and L. Mazar´e. Completing
the picture: Soundness of formal encryption in the
presence of active adversaries. In European Symposium
on Programming (ESOP’05), volume 3444 of LNCS,
pages 172–185. Springer, 2005.
[18] M. Naor and G. Segev. Public-key cryptosystems
resilient to key leakage. SIAM J. Comput.,
41(4):772–814, 2012.
1271[19] C. Rackoﬀ and D. R. Simon. Non-interactive
zero-knowledge proof of knowledge and chosen
ciphertext attack. In J. Feigenbaum, editor, CRYPTO,
volume 576 of Lecture Notes in Computer Science,
pages 433–444. Springer, 1991.
APPENDIX
openHASH(c, L)
if c ∈ [[THASH]] ∩ dom(L) then
else if c = (cid:14)h, τHASH(cid:15) then
return (c, L(c))
else
return (c, gl(c)
τHASH )
return (c, gl(c)(cid:3) )
FINbM(ν),I(ν),I(ν),A(η):
let S := ∅
let L := ∅
let T := ∅
R ← {0, 1}∗
(set of requested terms)
(library)
(trace of queries)
(random tape)
if b = 0 then
let generate := generateFIN
M ,R
else
let generate := generateM,R
Receive parameter ν from A
Figure 6: Open function for hash functions.
on request “init T, H” do
openSKE(c, L)
if c ∈ [[TSKE]] ∩ dom(L) then
return (c, L(c))
else if c = (cid:14)k, τ kx
return (c, gl(c)
τ kx
SKE
(cid:15) then
)
SKE
else if c = (cid:14)c
(cid:2)
SKE
for each (ˆk, k h
(cid:15) then
x ()) ∈ L do
(cid:15)
, τ ciphertext
parse ˆk as (cid:14)k, τ kx
let m := SKE.Dec(k, c
if m (cid:8)= ⊥ then
SKE
(cid:2)
)
return (c, E l(c)
(ˆk, m))
return (c, gl(c)
τ ciphertext
SKE
x
)
else
return (c, gl(c)(cid:3) )
Figure 7: Open function for secret key encryption.
generateFIN
M,R(t, L):
if for some c ∈ dom(L) we have L[[c]] = t then
else
return c
for i ∈ {1, n} do
if i is a forgetful argument then
let ci := len(ti)
let ai := ti
else
let (ci, L) :=generate M,R(ti, L)
let ai := ci
let r := R(t)
let c := (M f )(c1, . . . , cn; r)
let L(c) :=f l(a1, . . . , an)) (l ∈ labelsH)
return (c, L)
add “init T ” to T
if valid(T) then
let S := S ∪ T
let C := ∅
for each t ∈ T do
(list of replies)
let (c, L) := generate(t, L)
let C := C ∪ {c}
let (c, L) := generate(t, L)
for each t ∈ H do
send C to A
return 0 (A is invalid)
else
on request “sgenerate t” do
if valid(T+“sgenerate t”) then
let (c, L) := generate(t, L)
on request “generate t” do
add “generate t” to T
if valid(T) then
let S := S ∪ {t}
let (c, L) := generate(t, L)
send c to A
return 0 (A is invalid)
else
on request “parse c” do
let (t, L) := parse(c, L)
if S (cid:10)D t then
send t to A
return 1 (A produced non-Dolev-Yao term)
else
(cid:2)
on request “guess b
(cid:2)
if b = b
then
” do
return 1 (A wins)
return 0 (A looses)
else
Figure 8: The generate function for an oblivious im-
plementation (t is of the form f l(t1, . . . , tn) (with pos-
sibly n = 0 and no label l for deterministic function
symbols f )). The requirements for the input t are
those of the normal generate function.
Figure 9: Indistinguishability game for forgetful im-
plementations.
1272