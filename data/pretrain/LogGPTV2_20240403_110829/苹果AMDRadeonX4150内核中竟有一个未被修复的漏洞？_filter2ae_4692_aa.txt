# 苹果AMDRadeonX4150内核中竟有一个未被修复的漏洞？
|
##### 译文声明
本文是翻译文章，文章原作者 objective-see，文章来源：objective-see.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
> 苹果的AMDRadeonX4150 kext竟然会触发一个内核漏洞？这又是为何？
## 写在前面的话
在2018年的1月21日，我在ShmooCon跟大家演讲了关于“OpenBSM审计”方面的内容，感兴趣的同学可以回顾一下我的演讲文稿【[传送门](http://shmoocon.org/speakers/#theugly)】。
我当时在准备演讲内容的过程中，其实也就是期间休息的时候，我对自己的New
MacBook进行了一番安全分析。而在几分钟之后，我的苹果笔记本竟然奇迹般地崩溃了。这就非常奇怪了，因为我只是在用户模式下进行的操作。但是这确实让我非常兴奋，因为谁不想发现一个macOS的内核漏洞呢？
那么在这篇文章中，我将会跟大家分析内核panic报告，并尝试找到引发内核panic的直接原因以及错误指令。从表面上看，可能这个漏洞并不能向我们展示出非常有价值的安全问题，从某种程度上来说这还算是幸运的了。但对于某些比较精通内核安全以及显卡kext的人来说，他们也许可以利用这个漏洞来实现更多的东西。无论怎样，我希望在这篇文章中可以通过分析内核panic报告来给大家提供一些有价值的思路。
## 分析内核panic情况
首先，我们一起来了解一下目标设备的系统信息：
#####  macOS版本：10.13.2
    $ uname -a
      Darwin Patricks-MacBook-Pro.local 17.3.0 Darwin Kernel Version 17.3.0:
      root:xnu-4570.31.3~1/RELEASE_X86_64 x86_6
##### 内核panic报告：
    $ /Library/Logs/DiagnosticReports/Kernel_2018-01-15-185538_Patricks-MacBook-Pro.panic
内核panic报告的部分内容如下所示，如需获取完整的内核panic报告，请点击【[这里](https://objective-see.com/downloads/Kernel_%20AMDRadeonX4150.panic)】：
    $ less Kernel_2018-01-15-185538_Patricks-MacBook-Pro.panic
      *** Panic Report ***
      panic(cpu 6 caller 0xffffff8008b6f2e9): Kernel trap at 0xffffff7f8c7ba8b1, type 14=page fault
      registers:
      CR0: 0x000000008001003b, CR2: 0xffffff80639b8000, CR3: 0x0000000022202000, CR4: 0x00000000003627e0
      RAX: 0x0000000000000564, RBX: 0x0000000000000564, RCX: 0x0000000000000020, RDX: 0x000000000000002a
      RSP: 0xffffff92354ebc80, RBP: 0xffffff92354ebce0, RSI: 0x00000000000fbeab, RDI: 0xffffff92487b9154
      R8:  0x0000000000000000, R9:  0x0000000000000010, R10: 0x0000000000000010, R11: 0x0000000000000000
      R12: 0xffffff80639b6a70, R13: 0xffffff92354ebdc0, R14: 0xffffff92354ebdd4, R15: 0x0000000000000000
      RFL: 0x0000000000010297, RIP: 0xffffff7f8c7ba8b1, CS:  0x0000000000000008, SS:  0x0000000000000010
      Fault CR2: 0xffffff80639b8000, Error code: 0x0000000000000000, Fault CPU: 0x6, PL: 0, VF: 1
      Backtrace (CPU 6), Frame : Return Address
      0xffffff92354eb730 : 0xffffff8008a505f6
      0xffffff92354eb780 : 0xffffff8008b7d604
      0xffffff92354eb7c0 : 0xffffff8008b6f0f9
      0xffffff92354eb840 : 0xffffff8008a02120
      ....
      Kernel Extensions in backtrace:
      com.apple.iokit.IOAcceleratorFamily2(376.6) @0xffffff7f8b2b0000->0xffffff7f8b345fff
      com.apple.kext.AMDRadeonX4150(1.6) @0xffffff7f8c7b4000->0xffffff7f8cf20fff
      BSD process name corresponding to current thread: kernel_task
      Mac OS version:
      17C88
      Kernel version:
      Darwin Kernel Version 17.3.0: Thu Nov  9 18:09:22 PST 2017; root:xnu-4570.31.3~1/RELEASE_X86_64
      Kernel slide:     0x0000000008600000
没错，panic报告中确实包含了很多信息，但是这些信息就是可以帮助我们立刻定位到内核崩溃原因的必要信息。
我们先从报告的第二行内容（第一行是标题）开始分析：
      panic(cpu 6 caller 0xffffff8008b6f2e9): Kernel trap at 0xffffff7f8c7ba8b1, type 14=page fault
内核panic报告的第二行信息告诉我们，系统之所以会出现panic，主要是由一个页面错误（‘type 14=page
fault’）所导致的。而这种错误通常代表的是一次无效的读取操作或者是向内存中未映射页面的写入操作，这部分内容我们待会儿再讲。请大家先注意报告中RIP的值，这个寄存器（即程序计数器）中存储的就是错误指令的地址：0xffffff7f8c7ba8b1。
顺着这条信息往下分析，我们就会发现内核panic报告中包含了访问和触发页面错误的内存地址：0xffffff80639b8000。
      Fault CR2: 0xffffff80639b8000, Error code: 0x0000000000000000, Fault CPU: 0x6 ...
除此之外，Panic报告中还包含了回溯信息（backtrace），这样一来我们就可以跟踪方法调用或函数调用的顺序。并进一步确定错误指令的执行情况：
    Backtrace (CPU 6), Frame : Return Address
      0xffffff92354eb730 : 0xffffff8008a505f6
      0xffffff92354eb780 : 0xffffff8008b7d604
      0xffffff92354eb7c0 : 0xffffff8008b6f0f9
      0xffffff92354eb840 : 0xffffff8008a02120
      0xffffff92354eb860 : 0xffffff8008a5002c
      0xffffff92354eb990 : 0xffffff8008a4fdac
      0xffffff92354eb9f0 : 0xffffff8008b6f2e9
      0xffffff92354ebb70 : 0xffffff8008a02120
      0xffffff92354ebb90 : 0xffffff7f8c7ba8b1
      0xffffff92354ebce0 : 0xffffff7f8c7ba40f
      0xffffff92354ebd60 : 0xffffff7f8c7b85e8
      0xffffff92354ebda0 : 0xffffff7f8c7b9db2
      0xffffff92354ebe00 : 0xffffff7f8b2b3873
      0xffffff92354ebe50 : 0xffffff7f8b2bd473
      0xffffff92354ebe90 : 0xffffff7f8b2bcc7d
      0xffffff92354ebed0 : 0xffffff8009091395
      0xffffff92354ebf30 : 0xffffff800908fba2
      0xffffff92354ebf70 : 0xffffff800908f1dc
      0xffffff92354ebfa0 : 0xffffff8008a014f7
一旦我们确定了这些地址所属的kext，我们就能够映射出实际被调用的函数名称。根据回溯信息所提供的内容，panic报告中还包含了内核扩展以及相应的加载地址。这也就意味着，上述地址中的某一条很可能包含了触发页面错误并导致内核panic的指令，大致内容如下：
1. kext: com.apple.iokit.IOAcceleratorFamily2
地址：0xffffff7f8b2b0000
2. kext: com.apple.kext.AMDRadeonX4150
地址：0xffffff7f8c7b4000
在panic报告的结尾部分还包含一些“看似无用“的元数据（对我们来说可能没多大意义），例如内核版本信息等等。但是，其中的Kernel
Slide(0x0000000008600000)是比较重要的，因为它包含了内核镜像信息以及转移到内存中的数据。
那么接下来，我们总结一下我们从内核panic报告中收集到的数据：
1. 内核panic是由一个页面错误访问内存地址0xffffff80639b8000所导致的。