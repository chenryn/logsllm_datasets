      print("ADDRESS: 0x" . dechex($p) . "n");
      return $p;
    }
    get_aslr();
这里有一个PHP对象的UAF：即使我们无法设置$y[0](X的一个实例)，我们也可以利用$this。
UAF的读写权限
我们想要实现两个目标：读取内存地址来找到all_buckets的位置，修改SHM来改变bucket的值，从而加上我们自己的结构。
好在PHP的堆正好在这两片地址区域的前面。
PHP堆的内存地址，ap_scoreboard_image->*和all_buckets
    root@apaubuntu:~# cat /proc/6318/maps | grep libphp | grep rw-p
    7f4a8f9f3000-7f4a8fa0a000 rw-p 00471000 08:02 542265 /usr/lib/apache2/modules/libphp7.2.so
    (gdb) p *ap_scoreboard_image
    $14 = {
      global = 0x7f4a9323e008,
      parent = 0x7f4a9323e020,
      servers = 0x55835eddea78
    }
    (gdb) p all_buckets
    $15 = (prefork_child_bucket *) 0x7f4a9336b3f0
考虑到我们触发了PHP对象中的UAF，对象中的任意属性都属于UAF漏洞的范围。我们可以将zend_object
UAF改为zend_string，从而获得一个zend_string结构。
    (gdb) ptype zend_string
    type = struct _zend_string {
        zend_refcounted_h gc;
        zend_ulong h;
        size_t len;
        char val[1];
    }
len属性包括了字符串的长度，通过增加它，我们可以读写之后的内存空间，也就是说能访问到我们感兴趣的两个内存空间：SHM和Apache的all_buckets
找到bucket的index值和all_bucket
我们需要改变ap_scoreboard_image->parent[worker_id]->bucket来获得特定的worker_id。好在这个结构每次都在共享内存空间的头部位置，很方便我们去定位。
共享内存空间和目标process_socre结构
    root@apaubuntu:~# cat /proc/6318/maps | grep rw-s
    7f4a9323e000-7f4a93252000 rw-s 00000000 00:05 57052                      /dev/zero (deleted)
    (gdb) p &ap_scoreboard_image->parent[0]
    $18 = (process_score *) 0x7f4a9323e020
    (gdb) p &ap_scoreboard_image->parent[1]
    $19 = (process_score *) 0x7f4a9323e044
要定位all_bucket，我们需要充分利用prefork_child_bucket结构，所以我们需要：
导入bucket值的结构
    prefork_child_bucket {
        ap_pod_t *pod;
        ap_listen_rec *listeners;
        apr_proc_mutex_t *mutex; mutex会定位在同一个all_buckets[0]的内存区域，考虑到meth是一个静态结构，它会定位到libapr的data上，又因为meth指向了libapr的函数，所以每一个函数的指针都在libapr的text内。
到这里我们通过/proc/self/maps有了整片内存区域的地址信息，我们可以通过修改Apache内存的指针来找到all_buckets[0]对应的结构位置。
和我之前说的一样，all_bucket的地址在每次重启都会发生变化。所以说每次触发我们的exp，all_buckets的地址都会发生变化。之后我们会研究如何解决这问题。
###  2\. 向共享内存空间（SHM）写入假的prefork_child_bucket结构
实现函数的调用
如下是构造的调用函数的过程：
    bucket_id = ap_scoreboard_image->parent[id]->bucket
    my_bucket = all_buckets[bucket_id]
    mutex = &my_bucket->mutex
    apr_proc_mutex_child_init(mutex)
    (*mutex)->meth->child_init(mutex, pool, fname)
调用适合的函数
要实现漏洞利用，我们需要让(*mutex)->meth->child_init指向zend_object_std_dtor(zend_object
*object)，也就是下面的利用过程：
    mutex = &my_bucket->mutex
    [object = mutex]
    zend_object_std_dtor(object)
    ht = object->properties
    zend_array_destroy(ht)
    zend_hash_destroy(ht)
    val = &ht->arData[0]->val
    ht->pDestructor(val)
pDestructor指向system, &ht->arData[0]->val是一个字符串.
###  3.令all_bucket[bucket]指向结构
问题和解决思路
到这里为止，如果all_bucket的地址每次重启不会改变，那么我们的利用过程就完成了。
  * 通过PHP的堆获取内存的读写权限
  * 通过结构匹配来找到all_bucket
  * 找到SHM中需要的结构
  * 改变SHM中的process_score.bucket，使得all_bucket[bucket]->mutex指向我们的paylaod
但考虑到all_bucket地址的变化，我们还需要做两件事情来提高我们的执行成功率：喷射SHM内存区域，用上每一个PID对应的process_socre结构。
喷射共享的内存区域
如果all_bucket的新地址距离旧的地址不远，my_bucket会指向最近的结构，从而喷射获得整个SHM中未被使用的空间，而不是仅仅获得一个指向SHM的指针。这里存在一个问题，结构在zend_object中也使用着，所以其中有(5*8=)40位属于zend_object.properties，导致用一个大的结构来占用这个小的空间也不行。所以我们采用两个结构apr_proc_mutex_t和zend_array占用剩余的共享内存，令prefork_child_bucket.mutex和zend_object.properties指向同一个地址，来解决这一问题。现在如果all_bucket在原始地址不远的地方，my_bucket就会喷射到这一范围。
利用所有的process_score
每一个Apache
Worker进程都会有一个关联的process_score结构和对应的bucket的index值。无需改变process_score.bucket值，我们就能改变他们占用的内存范围，比如说：
ap_scoreboard_image->parent[0]->bucket = -10000 -> 0x7faabbcc00 parent[1]->bucket = -20000 -> 0x7faabbdd00 parent[2]->bucket = -30000 -> 0x7faabbff00 <= all_buckets
<= 0x7faabc0000
这意味着我们的成功率随着Apache
Worker进程数量的增多而变大。每次重新生成Worker进程的时候，都只有一个Worker进程会获得buckek编号，但考虑到其他Worker进程会报错而立刻重新生成，因此这不是什么问题。
复现成功率
不同的Apache服务器有着不同数量的Worker进程，有更多的Worker进程意味着我们可以用更少的内存来喷射互斥锁的地址，也就是说可以获取到更多的all_buckets函数的index信息。因此越多的Worker进程数量能够提高我们测试的成功率。在我的测试服务器（默认使用了4个Worker进程）上有80%的成功率。
如果exp触发失败的话，它会在第二天重启的时候重新运行，Apache的错误日志中不会包含Worker进程的错误信息。
###  4\. 等到早上6.25查看exp是否成功触发
这里只需要等待就好了。
## 漏洞时间线
  * 2019-02-22 [发送邮件给PI:EMAIL](mailto:%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E7%BB%PI:EMAIL)，提交了漏洞描述和Poc。
  * 2019-02-25 收到漏洞致谢，Apache安全团队正在修复漏洞。
  * 2019-03-07 Apache安全团队发送修复补丁进行测试，并提交CVE编号。
  * 2019-03-10 补丁测试通过。
  * 2019-04-01 发布新的Apache HTTP version 2.4.39版本。
Poc地址：
https://github.com/cfreal/exploits/tree/master/CVE-2019-0211-apache