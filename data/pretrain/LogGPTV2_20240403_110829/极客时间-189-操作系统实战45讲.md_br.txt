# 45 \| ARM新宠：苹果的M1芯片因何而快？你好，我是 LMOS。 前面两节课，我们一起学习了虚拟机和容器的原理，这些知识属于向上延展。而这节课我们要向下深挖，看看操作系统下面的硬件层面，重点研究一下CPU 的原理和它的加速套路。 有了这些知识的加持，我还会给你说说，为什么去年底发布的苹果 M1芯片可以实现高性能、低功耗。你会发现，掌握了硬件的知识，很多"黑科技"就不再那么神秘了。 好，让我们正式开始今天的学习！ CPU 的原理初探经过前面的学习，我们已经对操作系统原理建立了一定认知。从操作系统的位置来看，它除了能够向上封装，为软件调用提供API（也就是系统调用），向下又对硬件资源进行了调度和抽象。我们通常更为关注系统调用，但为了更好地设计实现一个OS，我们当然也要对硬件足够了解。 接下来，我们一起看一看硬件中最重要的一个硬件------CPU是怎么工作的。让我们拆开 CPU 这个黑盒子，看一看一个最小的 CPU应该包含哪些部分。不同架构的CPU，具体设计还是有很大差异的。为了方便你理解，我这里保留了 CPU里的共性部分，给你抽象出了 CPU的最小组成架构。 ![](Text)savepage-src="https://static001.geekbang.org/resource/image/c2/d1/c2d0b75dffcfbdb5e72011013a6cd2d1.jpg?wh=2323x1528"}CPU架构图对照上图描绘的基本模块，我们可以把 CPU 运行过程抽象成这样 6步。 1. 众所周知，CPU的指令是以二进制形式存储在存储器中的（这里把寄存器、RAM统一抽象成了存储器），所以当 CPU执行指令的时候，第一步就要先从存储器中取出（fetch）指令。 2.CPU将取出的指令通过硬件的指令解码器进行解码。 3.CPU根据指令解码出的功能，决定是否还要从存储器中取出需要处理的数据。 4.控制单元（CU）根据解码出的指令决定要进行哪些相应的计算，这部分工作由算术逻辑单元（ALU）完成。 5.控制单元（CU）根据前边解码出的指令决定是否将计算结果存入存储器。 6.修改程序计数器（PC）的指针，为下一次取指令做准备，以上整体执行过程由控制单元（CU）在时钟信号的驱动之下，周而复始地有序运行。 看了 CPU 核心组件执行的这 6个步骤，不知道你有没有联想到第一节课的图灵机的执行原理？没错，现代 CPU架构与实现虽然千差万别，但核心思想都是一致的。 ALU 的需求梳理与方案设计通过研究 CPU 核心组件的运行过程，我们发现，原来 CPU也可以想象成我们熟悉的软件，一样能抽象成几大模块，然后再进行模块化开发。 因为从零开始实现一款 CPU 的工程量还是不小的，所以在这里我带你使用Verilog 语言实现一个可以运行简单计算的 ALU，从而对 CPU具体模块的设计与实现加深一下认知。 首先，我们来思考一下，对于一个最简单的 ALU这个模块，我们的**核心需求**是什么？ 没错，聪明的你可能已经脱口而出了，我需要能**对两个 N位的二进制数进行加减、比较运算**。等等，为啥这里没有乘除？还记得学生时代初学乘除法的时候，老师也同样先简化为加减法，方便我们理解。 这里也一样，因为乘除也可以转换为循环的加减运算，比如 2\*3 可以转换成2+2+2，6/2 可以转换成6-2-2-2。所以，只需要实现了加减运算之后，我们就可以通过软件操作CPU，让它实现更复杂的运算了，这也正是软件扩展硬件能力的魅力。 好了，搞清楚需求之后，先不用着急编码，我们先来根据需求梳理一下 ALU模块功能简图。 ![](Text)savepage-src="https://static001.geekbang.org/resource/image/1c/03/1c53d14ef766154fb8a4627490f1ba03.jpg?wh=2445x1410"}ALU模块功能简图首先，我们在模块左侧（也就是输入侧）抽象出了 5根引脚，这五根引脚的作用分别是： 1.  ena：表示使能信号，它的取值是 0 或 1 可以分别控制 ALU    关闭或开启。        2.  clk：表示时钟信号，时钟信号也是 01    交替运行的方波，时钟信号会像人的心跳一样驱动 ALU    的电路稳定可靠地运行。        3.  opcode：表示操作码，取值范围是 00、01、10    这三种值，用来区分这一次计算到底是加法、减法还是比较运算。        4.  data1、data2：表示参与运算的两个 N    位数据总线。        现在我们再来看图片右侧，也就是输出侧的y，它表示输出结果，如果是加减运算，则直接输出运算后的数值，而比较运算，则要输出0、1、2，分别表示等于、大于、小于。 好了，有了方案，接下来就让我们想办法把方案变成可落地的实践吧。 自己动手用 Verilog 实现一个 ALUVerilog 是一种优秀的硬件描述语言，它可以用类似 C语言的高级语言设计芯片，从而免去了徒手画门电路的烦恼。 目前 Intel 等很多著名芯片公司都在使用 Verilog进行芯片设计。我们为了和业界保持一致，也采用了这种 Verilog 来设计我们的ALU。 在开发之前，你需要先进行一些准备工作，安装 VSCode 的 Verilog语言支持插件、iverilog、gtkwave，这些工具安装比较简单，你可以自行 Google搜索。 接下来，我们就来实现一下 ALU 的代码，也就是alu.v，代码如下。     /*----------------------------------------------------------------    Filename: alu.v    Function: 设计一个N位的ALU(实现两个N位有符号整数加 减 比较运算)    -----------------------------------------------------------------*/    module alu(ena, clk, opcode, data1, data2, y);        //定义alu位宽        parameter N = 32; //输入范围[-128, 127                //定义输入输出端口        input ena, clk;        input [1 : 0] opcode;        input signed [N - 1 : 0] data1, data2; //输入有符号整数范围为[-128, 127        output signed [N : 0] y; //输出范围有符号整数范围为[-255, 255                //内部寄存器定义        reg signed [N : 0] y;                //状态编码        parameter ADD = 2'b00, SUB = 2'b01, COMPARE = 2'b10;                //逻辑实现        always@(posedge clk)        begin            if(ena)            begin                casex(opcode)                    ADD: y  data2) ? 1 : ((data1 == data2) ? 0 : 2); //data1 = data2 输出0; data1 > data2 输出1; data1  6 y = 1                        //第二组测试            #10 data1 = 8'd127; data2 = 8'd127; opcode = 2'b00; //y = 127 + 127 = 254            #20 opcode = 2'b01; //y = 127 - 127 = 0            #20 opcode = 2'b10; // 127 == 127 y = 0                        //第三组测试            #10 data1 = -8'd128; data2 = -8'd128; opcode = 2'b00; //y = -128 + -128 = -256            #20 opcode = 2'b01; //y = -128 - (-128) = 0            #20 opcode = 2'b10; // -128 == -128 y = 0                        //第四组测试            #10 data1 = -8'd53; data2 = 8'd52; opcode = 2'b00; //y = -53 + 52 = -1            #20 opcode = 2'b01; //y = -53 - 52 = -105            #20 opcode = 2'b10; //-53   > 什么都舍弃不了的人，什么也改变不了！> > >这是《巨人》里面有名的金句。我之所以放到这里和你分享，是因为我觉得把这句话放在学习上同样很有效。聊到这里，我想说说我自己的学习思路，其实也很简单。那就是，**二八定律，80% 的功利主义，学对工作最有帮助的，20%的情怀主义，学自己最感兴趣的。**结合你自身的工作情况和个人爱好，选择那么几门去开始学习，不要贪多，不要把买了就当成学了，用这样的方式来缓解自己的焦虑。以我个人为例，我自校招入职以来，主要在学习与工作相关的知识，但也没有放弃个人兴趣。这里我把我正在学习探索的方向整理成了一张导图，也分享给你做参考。![](Images/1345f59e72060fcd6150f78b3a337404.png)savepage-src="https://static001.geekbang.org/resource/image/e5/36/e5f19cce3ff3fc5660d50153b6df7836.jpg?wh=1522x772"}我的学习二八法则在我看来，功利主义和情怀主义二者并不冲突，相反二者是相得益彰的，可以共同帮助你成长。因为工作以后，解决工作问题是最主要的事情，所以把大部分时间花在上面是值得的，这属于功利主义。但是，工作内容并不一定只是为了解决工作问题，在工作中也可以找到有趣的事情。比如Go语言底层的调度实现其实是非常有意思的，也可以本着情怀主义来学习，但同时在未来这部分知识又可以帮你解决更多的工作问题。其实我也是出于情怀来学习操作系统的。操作系统可以说是打开技术底层大门的钥匙，一方面可以开拓视野，另一方面恰好也能在工作需要的时候帮助我们解决困难。学习方法输出是学习的最佳途径！光有学习思路是不够的，我曾遇到过这些问题：一个 Bug遇到了两次，可是每次都得去 Google上搜，下次遇到了还是忘了。或者明明看了相关的视频，可是一到用的时候，突然发现自己好像只记得几个名词。你看，明明花费了时间，却收获极小，这会严重打击我们的学习积极性。究其根本，是因为**学习方法不对，导致学不到东西。**几年前，我刚步入这行的时候，由于原来没有接触过计算机，每次都是对着黑框框终端一顿操作，遇到问题到处百度（后来才转向Google），虽然稀里糊涂地解决了问题，可是下次遇到这个问题的时候，又得再百度，知识毫无积累，水平毫无提升，成了名副其实的面向"浏览器"工程师。后面，我发现记笔记是一个有效的学习方法，可以直接提高对知识的熟练度。因为在记笔记的过程里，我们会思考步骤、流程的合理性，重新审视这个知识点，同时记笔记也需要我们在内心里面揉碎这个知识点，加以消化，然后重新写出来。这是极佳的思考和输出的过程，有了这个过程，你不再是走马观花，而是经过了自己大脑的"解码"和"编码"，学习自然就会变得高效起来。我记笔记最开始使用纸来写，但是效率太低，容易丢失；再后来，我学会了Markdown，开始在 Markdown上记下自己踩坑的过程，写下自己的心得体会；可是很多时候我一会儿在笔记本上，一会儿又在台式机上，也有时候我需要和别人分享，甚至邀请别人一起来协作记笔记，于是我又将记笔记的地方转向了云端，开始使用石墨文档。石墨文档支持多人协作，而且个人就算多PC、终端也可以登录，很好地解决了我的问题。下面附上我石墨文档的桌面截图，也推荐你使用。![](Images/042dfd8d9f2f6315fec01a3d977f3adb.png)savepage-src="https://static001.geekbang.org/resource/image/75/ab/753dfa1a115f22153fa20f202d367aab.png?wh=3736x1888"}我的石墨文档慢慢地，我开始有了自己的积累，因为输出是更深层次的理解过程，很多坑点，我都能记下来，下次直接解决，即使遗忘了，我也能搜索自己的笔记。渐渐地我开始有了自己的知识库。**从面向浏览器工程师变成了面向知识库工程师。**这样的成长蜕变绝非朝夕之功，但我相信点滴的积累，终会聚沙成塔。当然记笔记只是输出的一种，你也可以选择其它方式，比如技术分享，和同事、同学之间进行讨论，**甚至给专栏留言**。这里我就不得不骄傲一把了，操作系统专栏每一个小节，我都认真阅读了，思考和回答了问题，并且做了输出------留言，所以这个专栏让我收获巨大。你也可以借鉴！收获技术能力应该是最基础的收获，收获更多的应该是生态！开始时，我把学习和工作的目标定为提升技术能力，一路坚持下来，我的技术确实有了进步，但是我更大的收获是生态。这个生态可能你不太理解，我来详细解释一下，我把因为学习和工作而结交到的**朋友**、**业务理解**、**商业模式**和**思考方式**等等统称为生态。拿这个专栏来说，我重新对操作系统进行了梳理和复盘，把很多原来一知半解的知识彻底弄懂了，这只是第一层的收获。更上层的是，我认识了大佬东哥（作者）和他的一些朋友，可爱又有责任心的小编Sara，人美心善的小运营洁仔，还有一堆天天在群里吹水的小伙伴，他们在群里分享了很多实用的知识，我也订阅了好几个公众号。我们因为这个专栏而认识，我们志同道合，我们一起努力来完善这个专栏，用反馈去给专栏增值，这个因大家一起努力贡献而组建起来的生态，才是我本次最大的收获。我希望你在学习和工作的时候，不要仅仅着眼于技术本身，而是要试着切换视角，跳脱出固有的框架，并且尝试鸟瞰全局，这样你才能收获更多。同时也建议你把专栏当作学习交友的平台，希望你能在本次专栏的学习中能够与我们成为好朋友，鼓励更多的人加入进来。除了课程正文的干货，我总是能在课程留言区发现惊喜。其实我们才是专栏真正的主人，也是专栏增值的核心力量，专栏是我们跟作者共同的作品。还是拿我自己来说吧，加入专栏成为助教后，我的学习激情一下子就"膨胀"了。认真学习专栏不仅仅只是兴趣，还有责任感与使命感，仿佛不追完就觉得白来了一趟。也正因如此，我才能收获如此巨大，相信你也可以。写在最后今天的分享，我从思路、方法和收获三个方面跟你聊了聊学习这件事情，下面我来谈一谈我对操作系统的看法。操作系统是我个人认为**最应该掌握的计算机必修课**！因为我们的每个程序、每个应用以及每个服务都跑在操作系统这个地基上面，可以说现代互联网完全构建在了操作系统上。操作系统是计算机软件的集大成者，是架构的极致！无论是 Windows、Linux还是 macOS都有几百万行代码，在保证高效运行的同时，又能将各种能力通过开放接口提供给我们，这是优良架构才能带来的能力。东哥将操作系统的精华浓缩，并将其实现为Cosmos，用专栏的形式提供给我们，让我们有机会去一睹操作系统的风采，去汲取最有营养的养料，让你在学习操作系统的路上少走弯路，少走弯路就是走捷径。希望每个看到这篇用户故事的小伙伴，重新拿起这个专栏。行百里者半九十，很多人行了十里就落下了，专栏行程虽然过半，但仍然可以赶上，大家，加油！