target vulnerability.
â€¢ Step-4: Based on the aligned cross-version execution traces,
VulScope performs execution detours reasoning to locate the
critical variables that cause these execution detours.
â€¢ Step-5: VulScope uses fuzzing-based detours correction to mutate
â€¢ Step-6: All the mutated inputs are evaluated with the crash triage
and given scores based on the similarity between their traces
and ğ‘‡ğ‘Ÿğ‘’ ğ‘“ . If none of the seeds triggers the target vulnerability,
they are inserted into a prioritization queue according to their
scores. The seed with the highest score will be selected for the
next round of mutation (goto Step-4).
the input bytes that are related to the critical variables.
3 CROSS-VERSION TRACE ALIGNMENT
To correlate functions between two cross-version execution traces,
this section first identifies function-level code refactoring changes
(i.e., function renaming, function merging/splitting) between two
versions of a program (Â§3.1); then introduces a tree-based data
structure to represent the execution trace which naturally provides
the running context for every invoked function (Â§3.2); and finally
presents a context-sensitive tree alignment algorithm by incorpo-
rating the cross-version function map (Â§3.3).
3.1 Cross-version Function Mapping
As introduced in Â§2, we choose to leverage the guidance of the
reference trace at the function-level. Thus, a precondition step is
to construct a function map between two versions which should
be resilient to common code refactoring changes. As summarized
in [36], function-level code refactoring changes mainly include func-
tion merging/splitting and function renaming. Since functions that
share same names between two versions can be directly mapped, we
focus on the mapping for those renamed/merged/split functions. In
particular, since function-level code similarity [2, 42, 43, 60] is well-
studied, we resort to existing works to identify function renaming.
Thereafter, we further enhance existing similarity calculation
methods to identify function merging/splitting.
Function Renaming Identification. Function renaming is com-
mon during version updates to improve code readability. In
practice, renamed functions across versions are considered to share
similar code semantics with the original ones. To identify â€œsimilarâ€
functions with different function names as function renaming
pairs, we use existing works in function-level similarity calculation
(e.g., [2, 10, 42]). Based on these works, we can set up a â€œone-to-
one function mappingâ€ between two sets of functions by seeking
an optimal global matching and identify the matched pairs in
the function map as function renaming. The detailed similarity
calculation method is presented in Appendix A.
Function Merging/Splitting Identification. As described in [36],
function merging/splitting are widely used to avoid code du-
plication, minimize the number of unnecessary methods, etc.
Different from the renamed functions, the relationship between
the merged/split functions and the original ones is a kind of
â€œone-to-many function mappingâ€, which is rather complicated.
Existing works [22, 49] in recognizing function merging/splitting
either require manual workload or complete commit history, thus
they are hard to apply in our scenario. To this end, we propose
to enhance existing function similarity calculation methods for
function merging/splitting identification.
For simplicity, we use how to identify functions that should
be merged in the target version to elaborate our approach. First,
based on the functions that share same names and those are
identified as renamed pairs, we construct a one-to-one function
mapping between the reference version and the target version.
Second, we construct a call graph for each version and label the
matched functions in the graph. Third, we identify the unmatched
functions in the target version whose callers/callees have already
been matched, named as ğ‘†ğ‘¢ğ‘›ğ‘šğ‘ğ‘¡ğ‘â„ğ‘’ğ‘‘. Specifically, for each function
ğ‘‹ in ğ‘†ğ‘¢ğ‘›ğ‘šğ‘ğ‘¡ğ‘â„ğ‘’ğ‘‘, we collect its matched callers and callees, which
are named as ğ‘†ğ‘ğ‘ğ‘›ğ‘‘ğ‘–ğ‘‘ğ‘ğ‘¡ğ‘’ğ‘ . We try to merge ğ‘‹ with every function
ğ‘Œ in ğ‘†ğ‘ğ‘ğ‘›ğ‘‘ğ‘–ğ‘‘ğ‘ğ‘¡ğ‘’ğ‘  at the corresponding callsite ğ‘ğ‘ , and compute the
similarity between the merged function ğ‘‹ + ğ‘Œ and the matched
pair of ğ‘Œ in the reference version (named ğ‘Œ â€²). If the similarity score
between ğ‘‹ + ğ‘Œ and ğ‘Œ â€² is higher than the similarity score between
ğ‘Œ and ğ‘Œ â€², we identify ğ‘‹ and ğ‘Œ should be merged at the callsite
ğ‘ğ‘ . At last, we iteratively look for all possible function merging
relations in this way. Similarly, the function merging relations in
the reference version (aka. function splitting relations in the target
version) are identified.
3.2 Tree-structured Execution Trace
Since we need to correlate the execution traces that are generated
under different inputs on different versions of software, it is
quite challenging to guarantee the accuracy of function alignment.
Therefore, we propose to use a tree-based structure to represent
the execution trace and perform the trace alignment between two
trees. The rationale here is that the context information of a tree
node can help to align functions. To be specific, we consider two
kinds of context information for a function call:
â€¢ Call Path: Since a function may have multiple callers, we should
â€¢ Callsite: Furthermore, since two identical function calls may
share the same call path, we also use the callsites (i.e., return
address) of a function call in its context.
keep track of its caller in the context information.
Definition of Tree-structured Trace. For a program version ğ›¼,
we record all the function calls in an execution with a tree-based
data structure ğ‘‡ğ›¼(ğ‘‰ğ›¼, ğ¸ğ›¼). In general, ğ‘‡ğ›¼(ğ‘‰ğ›¼, ğ¸ğ›¼) is a connected
graph which consists of a set of vertices (ğ‘‰ğ›¼={ğ‘£1, ğ‘£2, ğ‘£3...}) and edges
(ğ¸ğ›¼={ğ‘’1, ğ‘’2, ğ‘’3...}), which can be defined as follows:
â€¢ Vertex: Each vertex ğ‘£(ğ‘“ , ğµğµğ‘ ) âˆˆ ğ‘‰ğ›¼ represents a two-tuple
function trace entry, consisting of the called function ğ‘“ and the
basic-block trace within this function (ğµğµğ‘  = [ğ‘ğ‘1, ğ‘ğ‘2, ğ‘ğ‘3...]).
Session 12B: Analyzing Crashes and Incidents CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3303Figure 2: An example to illustrate the tree-structured execution trace and the transformations of function merging/splitting.
A basic block might be executed multiple times (e.g., basic blocks
in loops) within a called function.
â€¢ Edge: Each edge ğ‘’(ğ‘£ğ‘–, ğ‘£ ğ‘— , ğ‘ğ‘ ) âˆˆ ğ¸ğ›¼ is a three-tuple which refers
to a function call, consisting of a vertex ğ‘£ğ‘– âˆˆ ğ‘‰ğ›¼ for the caller
function, a vertex ğ‘£ ğ‘— âˆˆ ğ‘‰ğ›¼ for the callee function, and the callsite
ğ‘ğ‘  âˆˆ ğ‘£ğ‘– .ğµğµğ‘ .
We use the example presented in Figure 2 (a) to illustrate the
constructed trace tree when ğ‘–ğ‘›ğ‘ğ‘¢ğ‘¡ is taken as 1.
Note that ğ‘‡ğ›¼ is a rooted tree, whose root vertex always calls
the main() function. Each vertex ğ‘£ except for the root vertex has a
single incoming edge and single parent ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡(ğ‘£). If two vertices
share the same parent vertex, they are called siblings. Besides, ğ‘‡ğ›¼
is also an ordered tree, whose siblings are ordered according to
the execution. For a given vertex ğ‘£ğ‘–, we can obtain both its caller
ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡(ğ‘£ğ‘–) and its callsite, named as ğ‘ğ‘ğ‘™ğ‘™ğ‘ ğ‘–ğ‘¡ğ‘’(ğ‘£ğ‘–), from such trace
tree. Therefore, we can perform a context-sensitive trace alignment
(see Â§3.3). Further, its intra-function execution trace ğ‘£ğ‘– .ğµğµğ‘  helps to
reason fine-grained unaligned parts between two traces (see Â§4.1).
3.3 Tree-based Trace Alignment
Function Merging/Splitting Transformation. Based on the
constructed trace trees, we first try to eliminate the effects of
function merging/splitting on the execution traces, so as to ease
the cross-version trace alignment. To be specific, we transform the
trace tree by merging the functions that are identified as should-be-
merged (see Â§3.1) in both the reference trace and the target trace.
We illustrate the detailed procedure as follows:
Suppose that we identify function ğ‘Œ (which is called by ğ‘‹ at
the callsite ğ‘ğ‘ ) should be merged with ğ‘‹ on the version ğ›¼, we first
traverse all the edges ğ¸ğ›¼ in the trace tree to locate every edge
ğ‘’(ğ‘£ğ‘–, ğ‘£ ğ‘— , ğ‘ğ‘ ) âˆˆ ğ¸ğ›¼ that satisfies ğ‘’.ğ‘£ğ‘– .ğ‘“ = ğ‘‹, ğ‘’.ğ‘£ ğ‘— .ğ‘“ = ğ‘Œ and ğ‘’.ğ‘ğ‘  = ğ‘ğ‘ .
We take three steps to merge the vertex ğ‘£ ğ‘— (split function) into the
vertex ğ‘£ğ‘– (caller of split function):
â€¢ Merge intra-function execution trace. We record the offset ğ‘œ of ğ‘’.ğ‘ğ‘ 
in ğ‘£ğ‘– .ğµğµğ‘  and then insert ğ‘£ ğ‘— .ğµğµğ‘  into ğ‘£ğ‘– .ğµğµğ‘  at the offset of ğ‘œ + 1.
â€¢ Migrate child calls of split function. We record the index ğ‘– of ğ‘£ ğ‘—
among all its siblings and delete ğ‘£ ğ‘— from the child vertices of ğ‘£ğ‘–.
Then, we migrate all vertices of ğ‘£ ğ‘— to be new child vertices of ğ‘£ğ‘–
at index ğ‘–.
â€¢ Update new call relations. For each migrated vertex of ğ‘£ ğ‘—, we add
new edges to connect it with ğ‘£ğ‘–.
Taking Figure 2 as an example, function init() is identified as a split
function from function main() during version update. Figure 2 (b)
shows the transformed trace tree after merging init() into main().
After merging the related function entries in a trace tree, we
describe how to align ğ‘‡ğ‘Ÿğ‘’ ğ‘“ (ğ‘‰ğ‘Ÿğ‘’ ğ‘“ , ğ¸ğ‘Ÿğ‘’ ğ‘“ ) to ğ‘‡ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡(ğ‘‰ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡, ğ¸ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡).
First, we introduce the matching criterion for vertices, and then
present the alignment algorithm.
Matching Criterion for Vertices. To guarantee the accuracy
of aligning function calls across versions, we perform a context-
sensitive trace alignment. For the context-sensitiveness, it means
we not only check whether a pair of executed functions are identical
across versions, but also check whether they share identical running
context. Specifically, we set the matching criterion between vertex
ğ‘£ğ‘– âˆˆ ğ‘‰ğ‘Ÿğ‘’ ğ‘“ and vertex ğ‘£ ğ‘— âˆˆ ğ‘‰ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡ as follows:
â€¢ Identical Function: ğ‘£ğ‘– .ğ‘“ is matched with ğ‘£ ğ‘— .ğ‘“ .
â€¢ Identical Call Path: ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡(ğ‘£ğ‘–) is matched with ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡(ğ‘£ ğ‘—).
â€¢ Identical Callsite: ğ‘ğ‘ğ‘™ğ‘™ğ‘ ğ‘–ğ‘¡ğ‘’(ğ‘£ğ‘–) is matched with ğ‘ğ‘ğ‘™ğ‘™ğ‘ ğ‘–ğ‘¡ğ‘’(ğ‘£ ğ‘—).
Cross-version Callsite Mapping. As described in the above
matching criterion, the trace alignment requires to not only match
cross-version functions (see Â§3.1), but also to match their basic
blocks to determine whether two callsites are identical across
versions. To be specific, we need to match the basic blocks between
ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡(ğ‘£ğ‘–).ğ‘“ and ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡(ğ‘£ ğ‘—).ğ‘“ to determine whether a ğ‘ğ‘ğ‘™ğ‘™ğ‘ ğ‘–ğ‘¡ğ‘’(ğ‘£ğ‘–)
in ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡(ğ‘£ğ‘–).ğ‘“ is identical to a ğ‘ğ‘ğ‘™ğ‘™ğ‘ ğ‘–ğ‘¡ğ‘’(ğ‘£ ğ‘—) in ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡(ğ‘£ ğ‘—).ğ‘“ . To this
end, we leverage existing basic-block-level similarity calculation
methods (e.g., [42, 43, 60]) for basic blocks matching. The detailed
similarity calculation method is presented in Appendix A.
Layered Tree Alignment Algorithm. To perform tree alignment,
an intuitive approach is to use a tree edit distance algorithm.
However, the state-of-art algorithm [41] has a time complexity
of ğ‘‚(ğ‘›3) that could hardly scale to trees with a large number
of vertices. Besides, it does not consider the context information
of a vertex during the comparison. Therefore, we design a new
tree alignment algorithm that aligns two trees layer by layer. Our
approach is feasible for the following two characteristics of our trace
tree: â¶ the precondition of two vertices to be matched is that they
share identical context (i.e., parent vertices should be matched first);
â· there would be no cross-layer vertex matching pairs, since we
have transformed the tree to eliminate the merged/split functions.
We present the detailed tree alignment procedure as follows:
We first directly match the root vertex of ğ‘‡ğ‘Ÿğ‘’ ğ‘“ (ğ‘‰ğ‘Ÿğ‘’ ğ‘“ , ğ¸ğ‘Ÿğ‘’ ğ‘“ ) and
void main(){  init();  //split from main()  if(input)    a();}void init(){  if(input ğ‘¡ğ‘‘ğ‘–ğ‘Ÿ_ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡) of line 6 are viewed
as critical variables that cause this detour.
3) Unintended Call Reasoning. Similarly, for an unintended call
ğ‘£ğ‘¡ âˆˆ ğ‘ˆğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡, we first determine whether ğ‘£ğ‘¡ can be avoided on the
target version, by checking whether ğ‘£ğ‘¡ .ğ‘“ is unconditionally called
Session 12B: Analyzing Crashes and Incidents CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3305Figure 3: An example of reasoning missed calls. Note that
the arrows indicate the control flows of the two traces.
by ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡(ğ‘£ğ‘¡).ğ‘“ . If true, such an execution detour could not be
corrected.
Otherwise, we perform a backward dominator analysis from
the callsite of ğ‘£ğ‘¡ (aka. ğ‘ğ‘ğ‘™ğ‘™ğ‘ ğ‘–ğ‘¡ğ‘’(ğ‘£ğ‘¡)) in the target trace. Through the
dominator analysis, we determine the basic block in ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡(ğ‘£ğ‘¡).ğµğµğ‘ 
whose branching condition controls the reachability of ğ‘ğ‘ğ‘™ğ‘™ğ‘ ğ‘–ğ‘¡ğ‘’(ğ‘£ğ‘¡).
We deem the condition variables of this basic block as the critical
variables for this unintended call. To illustrate this process, we
give an example in Figure 4. The unintended call is the function
call exit() (line 13) called by read_samples_pcm() in Figure 4 (a).
Through backward dominator analysis, we first locate line 10 on
the target version. While the branch taken at line 10 on the target
version cannot help to avoid calling exit(). We finally identify its
predecessor basic block at line 2 (Figure 4 (a)) which dominates the
call of exit(). We then determine the condition variable at line 2
(ğ‘”ğ‘™ğ‘œğ‘ğ‘ğ‘™ .ğ‘ğ‘ğ‘šğ‘ğ‘–ğ‘¡ğ‘¤ğ‘–ğ‘‘ğ‘¡â„) as the critical variable that causes this detour.
4.2 Fuzzing-based Detours Correction
After associating the identified execution detours with the respon-
sible critical variables in the target trace, we adopt a fuzzing-based
method to adjust the original input to mitigate these detours and
make the generated execution trace more similar to the reference
trace than before.
Fuzzing Loop. Similar to traditional fuzzers, we maintain an input
queue to store interesting testcases discovered during the fuzzing
process. Initially, we put the reference PoC input into the queue. For