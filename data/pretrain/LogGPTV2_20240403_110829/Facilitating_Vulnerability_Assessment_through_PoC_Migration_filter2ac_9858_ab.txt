target vulnerability.
• Step-4: Based on the aligned cross-version execution traces,
VulScope performs execution detours reasoning to locate the
critical variables that cause these execution detours.
• Step-5: VulScope uses fuzzing-based detours correction to mutate
• Step-6: All the mutated inputs are evaluated with the crash triage
and given scores based on the similarity between their traces
and 𝑇𝑟𝑒 𝑓 . If none of the seeds triggers the target vulnerability,
they are inserted into a prioritization queue according to their
scores. The seed with the highest score will be selected for the
next round of mutation (goto Step-4).
the input bytes that are related to the critical variables.
3 CROSS-VERSION TRACE ALIGNMENT
To correlate functions between two cross-version execution traces,
this section first identifies function-level code refactoring changes
(i.e., function renaming, function merging/splitting) between two
versions of a program (§3.1); then introduces a tree-based data
structure to represent the execution trace which naturally provides
the running context for every invoked function (§3.2); and finally
presents a context-sensitive tree alignment algorithm by incorpo-
rating the cross-version function map (§3.3).
3.1 Cross-version Function Mapping
As introduced in §2, we choose to leverage the guidance of the
reference trace at the function-level. Thus, a precondition step is
to construct a function map between two versions which should
be resilient to common code refactoring changes. As summarized
in [36], function-level code refactoring changes mainly include func-
tion merging/splitting and function renaming. Since functions that
share same names between two versions can be directly mapped, we
focus on the mapping for those renamed/merged/split functions. In
particular, since function-level code similarity [2, 42, 43, 60] is well-
studied, we resort to existing works to identify function renaming.
Thereafter, we further enhance existing similarity calculation
methods to identify function merging/splitting.
Function Renaming Identification. Function renaming is com-
mon during version updates to improve code readability. In
practice, renamed functions across versions are considered to share
similar code semantics with the original ones. To identify “similar”
functions with different function names as function renaming
pairs, we use existing works in function-level similarity calculation
(e.g., [2, 10, 42]). Based on these works, we can set up a “one-to-
one function mapping” between two sets of functions by seeking
an optimal global matching and identify the matched pairs in
the function map as function renaming. The detailed similarity
calculation method is presented in Appendix A.
Function Merging/Splitting Identification. As described in [36],
function merging/splitting are widely used to avoid code du-
plication, minimize the number of unnecessary methods, etc.
Different from the renamed functions, the relationship between
the merged/split functions and the original ones is a kind of
“one-to-many function mapping”, which is rather complicated.
Existing works [22, 49] in recognizing function merging/splitting
either require manual workload or complete commit history, thus
they are hard to apply in our scenario. To this end, we propose
to enhance existing function similarity calculation methods for
function merging/splitting identification.
For simplicity, we use how to identify functions that should
be merged in the target version to elaborate our approach. First,
based on the functions that share same names and those are
identified as renamed pairs, we construct a one-to-one function
mapping between the reference version and the target version.
Second, we construct a call graph for each version and label the
matched functions in the graph. Third, we identify the unmatched
functions in the target version whose callers/callees have already
been matched, named as 𝑆𝑢𝑛𝑚𝑎𝑡𝑐ℎ𝑒𝑑. Specifically, for each function
𝑋 in 𝑆𝑢𝑛𝑚𝑎𝑡𝑐ℎ𝑒𝑑, we collect its matched callers and callees, which
are named as 𝑆𝑐𝑎𝑛𝑑𝑖𝑑𝑎𝑡𝑒𝑠. We try to merge 𝑋 with every function
𝑌 in 𝑆𝑐𝑎𝑛𝑑𝑖𝑑𝑎𝑡𝑒𝑠 at the corresponding callsite 𝑐𝑠, and compute the
similarity between the merged function 𝑋 + 𝑌 and the matched
pair of 𝑌 in the reference version (named 𝑌 ′). If the similarity score
between 𝑋 + 𝑌 and 𝑌 ′ is higher than the similarity score between
𝑌 and 𝑌 ′, we identify 𝑋 and 𝑌 should be merged at the callsite
𝑐𝑠. At last, we iteratively look for all possible function merging
relations in this way. Similarly, the function merging relations in
the reference version (aka. function splitting relations in the target
version) are identified.
3.2 Tree-structured Execution Trace
Since we need to correlate the execution traces that are generated
under different inputs on different versions of software, it is
quite challenging to guarantee the accuracy of function alignment.
Therefore, we propose to use a tree-based structure to represent
the execution trace and perform the trace alignment between two
trees. The rationale here is that the context information of a tree
node can help to align functions. To be specific, we consider two
kinds of context information for a function call:
• Call Path: Since a function may have multiple callers, we should
• Callsite: Furthermore, since two identical function calls may
share the same call path, we also use the callsites (i.e., return
address) of a function call in its context.
keep track of its caller in the context information.
Definition of Tree-structured Trace. For a program version 𝛼,
we record all the function calls in an execution with a tree-based
data structure 𝑇𝛼(𝑉𝛼, 𝐸𝛼). In general, 𝑇𝛼(𝑉𝛼, 𝐸𝛼) is a connected
graph which consists of a set of vertices (𝑉𝛼={𝑣1, 𝑣2, 𝑣3...}) and edges
(𝐸𝛼={𝑒1, 𝑒2, 𝑒3...}), which can be defined as follows:
• Vertex: Each vertex 𝑣(𝑓 , 𝐵𝐵𝑠) ∈ 𝑉𝛼 represents a two-tuple
function trace entry, consisting of the called function 𝑓 and the
basic-block trace within this function (𝐵𝐵𝑠 = [𝑏𝑏1, 𝑏𝑏2, 𝑏𝑏3...]).
Session 12B: Analyzing Crashes and Incidents CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea3303Figure 2: An example to illustrate the tree-structured execution trace and the transformations of function merging/splitting.
A basic block might be executed multiple times (e.g., basic blocks
in loops) within a called function.
• Edge: Each edge 𝑒(𝑣𝑖, 𝑣 𝑗 , 𝑐𝑠) ∈ 𝐸𝛼 is a three-tuple which refers
to a function call, consisting of a vertex 𝑣𝑖 ∈ 𝑉𝛼 for the caller
function, a vertex 𝑣 𝑗 ∈ 𝑉𝛼 for the callee function, and the callsite
𝑐𝑠 ∈ 𝑣𝑖 .𝐵𝐵𝑠.
We use the example presented in Figure 2 (a) to illustrate the
constructed trace tree when 𝑖𝑛𝑝𝑢𝑡 is taken as 1.
Note that 𝑇𝛼 is a rooted tree, whose root vertex always calls
the main() function. Each vertex 𝑣 except for the root vertex has a
single incoming edge and single parent 𝑝𝑎𝑟𝑒𝑛𝑡(𝑣). If two vertices
share the same parent vertex, they are called siblings. Besides, 𝑇𝛼
is also an ordered tree, whose siblings are ordered according to
the execution. For a given vertex 𝑣𝑖, we can obtain both its caller
𝑝𝑎𝑟𝑒𝑛𝑡(𝑣𝑖) and its callsite, named as 𝑐𝑎𝑙𝑙𝑠𝑖𝑡𝑒(𝑣𝑖), from such trace
tree. Therefore, we can perform a context-sensitive trace alignment
(see §3.3). Further, its intra-function execution trace 𝑣𝑖 .𝐵𝐵𝑠 helps to
reason fine-grained unaligned parts between two traces (see §4.1).
3.3 Tree-based Trace Alignment
Function Merging/Splitting Transformation. Based on the
constructed trace trees, we first try to eliminate the effects of
function merging/splitting on the execution traces, so as to ease
the cross-version trace alignment. To be specific, we transform the
trace tree by merging the functions that are identified as should-be-
merged (see §3.1) in both the reference trace and the target trace.
We illustrate the detailed procedure as follows:
Suppose that we identify function 𝑌 (which is called by 𝑋 at
the callsite 𝑐𝑠) should be merged with 𝑋 on the version 𝛼, we first
traverse all the edges 𝐸𝛼 in the trace tree to locate every edge
𝑒(𝑣𝑖, 𝑣 𝑗 , 𝑐𝑠) ∈ 𝐸𝛼 that satisfies 𝑒.𝑣𝑖 .𝑓 = 𝑋, 𝑒.𝑣 𝑗 .𝑓 = 𝑌 and 𝑒.𝑐𝑠 = 𝑐𝑠.
We take three steps to merge the vertex 𝑣 𝑗 (split function) into the
vertex 𝑣𝑖 (caller of split function):
• Merge intra-function execution trace. We record the offset 𝑜 of 𝑒.𝑐𝑠
in 𝑣𝑖 .𝐵𝐵𝑠 and then insert 𝑣 𝑗 .𝐵𝐵𝑠 into 𝑣𝑖 .𝐵𝐵𝑠 at the offset of 𝑜 + 1.
• Migrate child calls of split function. We record the index 𝑖 of 𝑣 𝑗
among all its siblings and delete 𝑣 𝑗 from the child vertices of 𝑣𝑖.
Then, we migrate all vertices of 𝑣 𝑗 to be new child vertices of 𝑣𝑖
at index 𝑖.
• Update new call relations. For each migrated vertex of 𝑣 𝑗, we add
new edges to connect it with 𝑣𝑖.
Taking Figure 2 as an example, function init() is identified as a split
function from function main() during version update. Figure 2 (b)
shows the transformed trace tree after merging init() into main().
After merging the related function entries in a trace tree, we
describe how to align 𝑇𝑟𝑒 𝑓 (𝑉𝑟𝑒 𝑓 , 𝐸𝑟𝑒 𝑓 ) to 𝑇𝑡𝑎𝑟𝑔𝑒𝑡(𝑉𝑡𝑎𝑟𝑔𝑒𝑡, 𝐸𝑡𝑎𝑟𝑔𝑒𝑡).
First, we introduce the matching criterion for vertices, and then
present the alignment algorithm.
Matching Criterion for Vertices. To guarantee the accuracy
of aligning function calls across versions, we perform a context-
sensitive trace alignment. For the context-sensitiveness, it means
we not only check whether a pair of executed functions are identical
across versions, but also check whether they share identical running
context. Specifically, we set the matching criterion between vertex
𝑣𝑖 ∈ 𝑉𝑟𝑒 𝑓 and vertex 𝑣 𝑗 ∈ 𝑉𝑡𝑎𝑟𝑔𝑒𝑡 as follows:
• Identical Function: 𝑣𝑖 .𝑓 is matched with 𝑣 𝑗 .𝑓 .
• Identical Call Path: 𝑝𝑎𝑟𝑒𝑛𝑡(𝑣𝑖) is matched with 𝑝𝑎𝑟𝑒𝑛𝑡(𝑣 𝑗).
• Identical Callsite: 𝑐𝑎𝑙𝑙𝑠𝑖𝑡𝑒(𝑣𝑖) is matched with 𝑐𝑎𝑙𝑙𝑠𝑖𝑡𝑒(𝑣 𝑗).
Cross-version Callsite Mapping. As described in the above
matching criterion, the trace alignment requires to not only match
cross-version functions (see §3.1), but also to match their basic
blocks to determine whether two callsites are identical across
versions. To be specific, we need to match the basic blocks between
𝑝𝑎𝑟𝑒𝑛𝑡(𝑣𝑖).𝑓 and 𝑝𝑎𝑟𝑒𝑛𝑡(𝑣 𝑗).𝑓 to determine whether a 𝑐𝑎𝑙𝑙𝑠𝑖𝑡𝑒(𝑣𝑖)
in 𝑝𝑎𝑟𝑒𝑛𝑡(𝑣𝑖).𝑓 is identical to a 𝑐𝑎𝑙𝑙𝑠𝑖𝑡𝑒(𝑣 𝑗) in 𝑝𝑎𝑟𝑒𝑛𝑡(𝑣 𝑗).𝑓 . To this
end, we leverage existing basic-block-level similarity calculation
methods (e.g., [42, 43, 60]) for basic blocks matching. The detailed
similarity calculation method is presented in Appendix A.
Layered Tree Alignment Algorithm. To perform tree alignment,
an intuitive approach is to use a tree edit distance algorithm.
However, the state-of-art algorithm [41] has a time complexity
of 𝑂(𝑛3) that could hardly scale to trees with a large number
of vertices. Besides, it does not consider the context information
of a vertex during the comparison. Therefore, we design a new
tree alignment algorithm that aligns two trees layer by layer. Our
approach is feasible for the following two characteristics of our trace
tree: ❶ the precondition of two vertices to be matched is that they
share identical context (i.e., parent vertices should be matched first);
❷ there would be no cross-layer vertex matching pairs, since we
have transformed the tree to eliminate the merged/split functions.
We present the detailed tree alignment procedure as follows:
We first directly match the root vertex of 𝑇𝑟𝑒 𝑓 (𝑉𝑟𝑒 𝑓 , 𝐸𝑟𝑒 𝑓 ) and
void main(){  init();  //split from main()  if(input)    a();}void init(){  if(input 𝑡𝑑𝑖𝑟_𝑐𝑜𝑢𝑛𝑡) of line 6 are viewed
as critical variables that cause this detour.
3) Unintended Call Reasoning. Similarly, for an unintended call
𝑣𝑡 ∈ 𝑈𝑡𝑎𝑟𝑔𝑒𝑡, we first determine whether 𝑣𝑡 can be avoided on the
target version, by checking whether 𝑣𝑡 .𝑓 is unconditionally called
Session 12B: Analyzing Crashes and Incidents CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea3305Figure 3: An example of reasoning missed calls. Note that
the arrows indicate the control flows of the two traces.
by 𝑝𝑎𝑟𝑒𝑛𝑡(𝑣𝑡).𝑓 . If true, such an execution detour could not be
corrected.
Otherwise, we perform a backward dominator analysis from
the callsite of 𝑣𝑡 (aka. 𝑐𝑎𝑙𝑙𝑠𝑖𝑡𝑒(𝑣𝑡)) in the target trace. Through the
dominator analysis, we determine the basic block in 𝑝𝑎𝑟𝑒𝑛𝑡(𝑣𝑡).𝐵𝐵𝑠
whose branching condition controls the reachability of 𝑐𝑎𝑙𝑙𝑠𝑖𝑡𝑒(𝑣𝑡).
We deem the condition variables of this basic block as the critical
variables for this unintended call. To illustrate this process, we
give an example in Figure 4. The unintended call is the function
call exit() (line 13) called by read_samples_pcm() in Figure 4 (a).
Through backward dominator analysis, we first locate line 10 on
the target version. While the branch taken at line 10 on the target
version cannot help to avoid calling exit(). We finally identify its
predecessor basic block at line 2 (Figure 4 (a)) which dominates the
call of exit(). We then determine the condition variable at line 2
(𝑔𝑙𝑜𝑏𝑎𝑙 .𝑝𝑐𝑚𝑏𝑖𝑡𝑤𝑖𝑑𝑡ℎ) as the critical variable that causes this detour.
4.2 Fuzzing-based Detours Correction
After associating the identified execution detours with the respon-
sible critical variables in the target trace, we adopt a fuzzing-based
method to adjust the original input to mitigate these detours and
make the generated execution trace more similar to the reference
trace than before.
Fuzzing Loop. Similar to traditional fuzzers, we maintain an input
queue to store interesting testcases discovered during the fuzzing
process. Initially, we put the reference PoC input into the queue. For