title:Towards Generating High Coverage Vulnerability-Based Signatures with
Protocol-Level Constraint-Guided Exploration
author:Juan Caballero and
Zhenkai Liang and
Pongsin Poosankam and
Dawn Song
Towards Generating High Coverage
Vulnerability-Based Signatures with Protocol-Level
Constraint-Guided Exploration
Juan Caballero2,1, Zhenkai Liang3, Pongsin Poosankam2,1, and Dawn Song1
1 UC Berkeley
2 Carnegie Mellon University
3 National University of Singapore
Abstract. Signature-based input ﬁltering is an important and widely deployed de-
fense. But current signature generation methods have limited coverage and the gen-
erated signatures often can be easily evaded by an attacker with small variations of
the exploit message. In this paper, we propose protocol-level constraint-guided ex-
ploration, a new approach towards generating high coverage vulnerability-based
signatures. In particular, our approach generates high coverage, yet compact, vul-
nerability point reachability predicates, which capture many paths to the vulnera-
bility point. In our experimental results, our tool, Elcano, generates compact, high
coverage signatures for real-world vulnerabilities.
1 Introduction
Automatic signature generation remains an important open problem. According to
Symantec’s latest Internet Security Threat Report hundreds of new security-critical vul-
nerabilities were discovered in the second half of 2007 [1]. For many of these vulner-
abilities, the exploit development time is less than a day, while the patch development
time is often days or months [1]. In addition, the patch deployment time can be long
due to extensive testing cycles.
To address these issues, signature-based input ﬁltering has been widely deployed in
Intrusion Prevention (IPS) and Intrusion Detection (IDS) systems. Signature-based in-
put ﬁltering matches program inputs against a set of signatures and ﬂags matched inputs
as attacks. It provides an important means to protect vulnerable hosts when patches are
not yet available or have not yet been applied. Furthermore, for legacy systems where
patches are no longer provided by the vendor, or critical systems where any changes to
the code might require a lengthy re-certiﬁcation process, signature-based input ﬁltering
is often the only practical solution to protect the vulnerable program.
The key technical challenge to effective signature-based defense is to automatically
and quickly generate signatures that have both low false positives and low false nega-
tives. In addition, it is desirable to be able to generate signatures without access to the
source code. This is crucial to wide deployment since it enables third-parties to generate
signatures for commercial-off-the-shelf (COTS) programs, without relying on software
vendors, thus enabling a quick response to newly found vulnerabilities.
Due to the importance of the problem, many different approaches for automatic sig-
nature generation have been proposed. Early work proposed to generate exploit-based
E. Kirda, S. Jha, and D. Balzarotti (Eds.): RAID 2009, LNCS 5758, pp. 161–181, 2009.
c(cid:2) Springer-Verlag Berlin Heidelberg 2009
162
J. Caballero et al.
signatures using patterns that appeared in the observed exploits, but such signatures
can have high false positive and negative rates [2, 3, 4, 5, 6, 7, 8, 9, 10]. More recently,
researchers proposed to generate vulnerability-based signatures, which are generated
by analyzing the vulnerable program and its execution and the actual conditions needed
to exploit the vulnerability and can guarantee a zero false positive rate [11, 12].
Automatic vulnerability signature generation. A vulnerability is a point in a program
where execution might “go wrong”. We call this point the vulnerability point. A vulner-
ability is only exploited when a certain condition, the vulnerability condition, holds on
the program state when the vulnerability point is reached. Thus, to exploit a vulnerabil-
ity, the input needs to satisfy two conditions: (1) it needs to lead the program execution
to reach the vulnerability point; (2) the program state needs to satisfy the vulnerability
condition at the vulnerability point. We call the condition that denotes whether an input
message will make the program execution reach the vulnerability point the vulnerability
point reachability predicate (VPRP). Thus, the problem of automatically generating a
vulnerability-based signature can be decomposed into two: identifying the vulnerability
condition and identifying the vulnerability point reachability predicate. A vulnerability-
based signature is simply the conjunction of the two. While both problems are impor-
tant, the space limitations makes trying to cover both in a single paper unrealistic. Thus,
in this paper we focus on how to generate vulnerability point reachability predicates
with high coverage and compact size, and we refer the reader to [13] for details on the
vulnerability condition extraction. In this paper, we use optimal signature to refer to a
vulnerability signature that has no false positives and no false negatives.
Coverage is a key challenge. One important problem with early vulnerability-based
signature generation approaches [11, 12] is that the signatures only capture a single
path to the vulnerability point (i.e., their VPRP contains only one path). However, the
number of paths leading to the vulnerability point can be very large, sometimes inﬁnite.
Thus, such signatures are easy to evade by an attacker with small modiﬁcations of the
original exploit message, such as changing the size of variable-length ﬁelds, changing
the relative ordering of the ﬁelds (e.g., HTTP), or changing ﬁeld values that drive the
program through a different path to the vulnerability point [14, 15].
Acknowledging the importance of enhancing the coverage of vulnerability-based
signatures, recent work tries to incorporate multiple paths into the VPRP either by static
analysis [16], or by dynamic analysis [17,18]. However, performing precise static anal-
ysis on binaries is hard due to issues such as indirection, pointers and loops.
ShieldGen takes a probing-based approach using protocol format information [18]—
using the given protocol format, it generates different well-formed variants of the original
exploit using various heuristics and then checks whether any of the variants still exploits
the vulnerability. The advantage of this approach is that by using protocol format infor-
mation, the ﬁnal signature is expressed at the protocol level (which we call protocol-level
signature) instead of the byte level. Compared to signatures at the byte-level (which do
not understand the protocol format), protocol-level signatures have two advantages: they
are more compact and they naturally cover variants of the exploits caused by variable-
length ﬁelds and ﬁeld re-ordering (See more detail in Section 2.2). The disadvantage of
the approach used by ShieldGen is that the exploration uses heuristics to ﬁgure out what
Towards Generating High Coverage Vulnerability-Based Signatures
163
test inputs to generate. Such heuristics can introduce false positives and do not use the
information from the execution of the program, which would increase the coverage of
the program execution space. As a result, the exploration is inefﬁcient and has various
limitations (See Section 2.3).
Bouncer extends previous approaches using symbolic execution to generate sym-
bolic constraints on inputs as signatures [17]. Even though Bouncer makes improve-
ments in increasing the coverage of the generated signatures, it still suffers from
several limitations. First, it generates byte-level signatures instead of protocol-level sig-
natures. As a result, it is difﬁcult for Bouncer to handle evasion attacks using variable-
length ﬁelds and ﬁeld re-ordering. Second, Bouncer’s exploration is inefﬁcient and
largely heuristic-based. As mentioned in their paper, the authors tried to use symbolic-
constraint-guided exploration to explore the program execution space to identify dif-
ferent paths reaching the vulnerability point, but couldn’t make the approach scale to
real-world programs and thus had to resort to heuristics such as duplicating or removing
parts of the input message or sampling certain ﬁeld values to try to discover new paths
leading to the vulnerability point. Thus, a key open problem for generating accurate and
efﬁcient signatures is how to generate vulnerability point reachability predicates with
high coverage.
Our approach. In this paper, we propose protocol-level constraint-guided exploration,
a new approach to automatically generate vulnerability point reachability predicates
with high coverage, for a given vulnerability point and an initial exploit message. Our
approach has 3 main characteristics: 1) it is constraint-guided (i.e., instead of heuristics-
based exploration as in ShieldGen and Bouncer), 2) the constraint-guided exploration
works at the protocol-level and generates protocol-level signatures at the end, and 3) it
effectively merges explored execution paths to remove redundant exploration. The three
points seamlessly weave together and amplify each other’s beneﬁt. By using constraint-
guided exploration, our approach signiﬁcantly increases the effectiveness and efﬁciency
of the program execution space exploration. By lifting the symbolic constraints from the
byte level to the protocol level, our constraint-guided exploration is done at the protocol
level, which makes the exploration feasible for real-world programs, addressing the
problem that Bouncer couldn’t solve. By merging paths in the exploration, we further
reduce the exploration space.
Elcano. We have designed and developed Elcano, realizing the aforementioned ap-
proach. We have evaluated the effectiveness of our system using real-world vulnerable
programs. In our experiments, Elcano achieved optimal or close-to-optimal results in
terms of coverage. In addition, the generated signatures are compact. In fact, most of
the signatures are so compact that they can be understood by a human.
Compared to Bouncer, Elcano produces higher coverage signatures. For example,
for the GHttpd vulnerability Bouncer run for 24 hours, exploring only some fraction of
all possible paths, and produced a partial signature with signiﬁcant false negatives. In
contrast, Elcano generates an optimal signature for the same vulnerability in 55 seconds.
Compared to ShieldGen, Elcano produces more accurate signatures, both in terms of
less false negatives (i.e., higher coverage) and less false positives.
164
J. Caballero et al.
In addition to signature generation, extracting a high coverage vulnerability point
reachability predicate is useful for other applications such as exploit generation [19]
and patch testing. For example, the Microsoft patch MS05-018 missed some paths
to the vulnerability point and as a result left the vulnerability still exploitable after
the patch [20]. This situation is not uncommon. A quick search on the CVE database
returns 13 vulnerabilities that were incorrectly or incompletely patched [21]. Our tech-
nique could assist software developers to build more accurate patches. Furthermore, our
protocol-level constraint-guided approach can increase the effectiveness of generating
high-coverage test cases and hence be very valuable to software testing and bug ﬁnding.
2 Problem Deﬁnition and Approach Overview
In this section, we ﬁrst introduce the problem of automatic generation of protocol-level
vulnerability point reachability predicates, then present our running example and ﬁnally
give the overview of our approach.
2.1 Problem Deﬁnition
Automatic generation of protocol-level vulnerability point reachability predicates.
Given a parser implementing a given protocol speciﬁcation, the vulnerability point, and
an input that exploits the vulnerability at the vulnerability point in a program, the prob-
lem of automatic generation of protocol-level vulnerability point reachability predicates
is to automatically generate a predicate function F , such that when given some input
mapped into ﬁeld structures by the parser, F evaluates over the ﬁeld structures of the
input: if it evaluates to true, then the input is considered to be able to reach the vulner-
ability point, otherwise it is not.
Parser availability and speciﬁcation quality. The problem of automatic generation of
protocol-level vulnerability point reachability predicates assumes the availability of a
parser implementing a given protocol or ﬁle speciﬁcation. Such requirement is identical
to previous approaches such as ShieldGen [18]. The parser given some input data can
map it into ﬁelds, according to the speciﬁcation, or fail if the input is malformed. In the
latter case, the IDS/IPS could opt to block the input or let it go through while logging
the event or sending a warning. Such parser is available for common protocols (e.g.,
Wireshark [22]), and many commercial network-based IDS or IPS have such a parser
built-in. In addition, recent work has shown how to create a generic parser that takes as
input multiple protocol speciﬁcations written in an intermediate language [23, 24].
The quality of the speciﬁcation used by the parser matters. While obtaining a high
quality speciﬁcation is not easy, this is a one time effort, which can be reused for mul-
tiple signatures, as well as other applications. For example, in our experiments we ex-
tracted a WMF ﬁle format speciﬁcation. According to the CVE Database [21] the WMF
ﬁle format appears in 21 vulnerabilities, where our speciﬁcation could be reused. Sim-
ilarly, an HTTP speciﬁcation could be reused in over 1500 vulnerabilities. Also, recent
work has proposed to automatically extract the protocol speciﬁcation from the program
binary [25,26,27,28]. Such work can be used when the protocol used by the vulnerable
program has no public speciﬁcation.
Towards Generating High Coverage Vulnerability-Based Signatures
165
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
void service() {
char msgBuf[4096];
char lineBuf[4096];
int nb=0, i=0, sockfd=0;
nb=recv(sockfd,msgBuf,4096,0);
for(i = 0; i  127, and the conjunction of the
two is an optimal protocol-level signature.
166
J. Caballero et al.
2.3 Approach
In this paper we propose a new approach to generate high coverage, yet compact, vul-
nerability point reachability predicates, called protocol-level constraint-guided explo-
ration. Next, we give the motivation and an overview of the three characteristics that
comprise our approach.
Constraint-guided. As mentioned in Section 1, previous approaches such as ShieldGen
and Bouncer use heuristics-based exploration [17,18]. Heuristic-based exploration suf-
fers from a fundamental limitation: the number of probes needed to exhaustively search
the whole space is usually astronomical. In addition, an exhaustive search is inefﬁcient
as many probes end up executing the same path in the program. Thus, such approaches
often rely on heuristics that are not guaranteed to signiﬁcantly increase the signature’s
coverage and can also introduce false positives.
For example, ShieldGen [18] ﬁrst assumes that ﬁelds can be probed independently,
and then for ﬁxed-length ﬁelds it samples just a few values of each ﬁeld, checking
whether the vulnerability point is reached or not for those values. Probing each ﬁeld in-
dependently means that conditions involving multiple ﬁelds cannot be found. Take the
condition SIZE1 + SIZE2 ≤ MSG SIZE, where SIZE1 and SIZE2 are length
ﬁelds in the input, and MSG SIZE represents the total length of the received message.
The authors of ShieldGen acknowledge that their signatures cannot capture this type of
conditions, but such conditions are commonly used by programs to verify that the input
message is well-formed and failing to identify them will introduce either false positives
or false negatives, depending on the particular heuristic. Probing only a few sample val-
ues for each ﬁeld is likely to miss constraints that are satisﬁed by only a small fraction
of the ﬁeld values. For example, a conditional statement such as if (FIELD==10)
|| (FIELD==20) then exploit, else safe, where FIELD is a 32-bit in-
teger, creates two paths to the vulnerability point. Finding each of these paths would
require 230 random probes on average to discover. Creating a signature that covers both
paths is critical since if the signature only covers one path (e.g., FIELD == 10), the
attacker could easily evade detection by changing FIELD to have value 20.