Veeralakshmi and Sindhuja designed a system that identi-
ﬁes and eliminates unsafe dynamic component loadings [48].
Based on the work conducted by Kwon and Su [2],
the
authors built a system that removes possible unsafe component
loadings on a system.
Application whitelisting is a defensive technique that al-
lows only whitelisted applications to be executed on a system,
is built-in Microsoft Windows as a feature called
and it
AppLocker [49]. Even though it
improves the security of
certain use cases of client computing platforms, e.g. as a static-
role terminal for SCADA controller, HMI or some corporate
systems, it may result too much restriction on the capability
of general-purpose platforms. It also cannot prevent malicious
component loading attacks. Moreover, it usually requires the
user or the administrator to conﬁgure the whitelist. On the
contrary,
the proposed mechanism permits any application
to be executed as long as it is signed by a vendor that is
included in the operating system’s trusted vendor list. Also,
our mechanism does not require any user intervention since
trusted vendor list is maintained by software vendors. As appli-
cation whitelisting and the cross veriﬁcation are not conﬂicting
mechanisms, they can be used together in order to maximise
the protection against unsafe execution and component loading
cases; application whitelisting can compliment our mechanism
by blocking execution of standalone malware.
Code signing itself has been recommended in multiple
studies. Gong suggested the use of code signing in Java [24].
Rubin and Daniel extended this recommendation to mobile/-
portable code [27], and McGraw and Morrisett listed code
signing as one of major defensive techniques that can be
applied to any computing platform [23].
B. Origin Check of Digital Signature
Android checks the code authors of package ﬁles, and uses
digital signatures for inter-application trust management [18].
However, the purpose and the mechanism are different from
our proposed cross veriﬁcation. First, Android uses digital
signatures for different purposes from our proposal and other
platforms such as Microsoft Windows, Apple OS X and iOS.
Instead of using digital signatures for run-time code validity
veriﬁcation, Android uses them for checking the code author
of a JAR ﬁle at package installation time. The reason for
this is two-fold. First it is to check if an update is from the
same author as that of the currently installed version. For this
reason, self-signed signatures are allowed and widely used.
In other words,
the signer can be anyone, not a certiﬁed
vendor. The second use of digital signatures in Android is
to manage permissions. Android checks requested permissions
at
installation time by comparing the code author of the
requesting package and that of the package declaring the
requested permission. For instance, if a package that is being
installed requests Google account credentials, the package has
to be signed by the Google Login Service. Although this
is a form of inter-application veriﬁcation (like a part in our
scheme), the way it works is very different from our cross
veriﬁcation in that: (1) it is performed only once, and (2) it is
one-way veriﬁcation.
C. Detection of Unsafe Component Loading
Detection of unsafe component
loading has been well
explored [50], [2], [3], [51]. Kwon and Su suggested a method
that detects possible unsafe component loadings [2], [3]. Their
tool proﬁles applications’ dynamic loading behaviour, then
checks for possible unsafe loadings that can be exploited by
DLL hijacking.
These studies on malicious component loading provide
beneﬁts to developers, not users, since it is best to use detection
techniques at the time of development, not at the time of use.
VIII. CONCLUDING REMARKS
Code signing is an important security mechanism on mod-
ern client computing platforms, and many software vendors
have already adopted it. However, it has turned out to be insuf-
ﬁcient for thwarting various attacks since the adversaries have
started to arm their malware with legitimate signatures. In this
paper, we have proposed a new security mechanism for secure
execution and dynamic component loading, which is based on
code signing and same-origin policy. We have shown that our
mechanism successfully prevents a wide range of attacks such
as DLL hijacking, DLL side-loading, binary hijacking, typical
DLL injection, and drive-by download attack, even when
malicious binaries have valid digital signatures. Our scheme
also prevents loading of infected or newly installed malicious
components, and protects proprietary software components so
that unauthorised use of them is blocked. We investigated
application execution and dynamic component loading cases,
and have shown the effectiveness of the proposed mechanism,
and then implemented a prototype to conﬁrm its validity in
practice.
Although we have focused on the development and eval-
uation of our security mechanism on Microsoft Windows, the
underlying principle is general, and hence can be applied
to other client platforms including Linux, Mac OS X and
Android. Because component-based software engineering is
widely deployed in the software industry, the beneﬁts on these
platforms will be as signiﬁcant as on Microsoft Windows. We
are especially interested in the application of our technique
on mobile platforms, since the number of mobile malware has
been surging [52], and it is important to implement appropriate
defences against this emerging threat.
REFERENCES
[1] B. Blunden, The Rootkit Arsenal: Escape and Evasion in the Dark
Corners of the System. Jones & Bartlett Publishers, Mar. 2012.
[2] T. Kwon and Z. Su, “Automatic detection of unsafe component load-
ings,” in ISSTA ’10: Proceedings of the 19th international symposium on
Software testing and analysis, (Trento, Italy), pp. 107–118, July 2010.
123123
[3] T. Kwon and Z. Su, “Static Detection of Unsafe Component Loadings,”
in Compiler Construction, (Tallinn, Estonia), pp. 122–143, 2012.
[31] D. Tarakanov, “Shamoon the Wiper in details.” http://www.securelist.
com/en/blog/208193795/Shamoon the Wiper in details, Aug. 2012.
[4] Microsoft SWI, “MS14-019 – Fixing a binary hijacking via .cmd or
.bat ﬁle.” http://blogs.technet.com/b/srd/archive/2014/04/08/ms14-019-
ﬁxing-a-binary-hijacking-via-cmd-or-bat-ﬁle.aspx, Apr. 2014.
[5] A. Stewart, “DLL Side-loading: A Thorn in the Side of the Anti-Virus
Industry,” tech. rep., FireEye, Mar. 2014.
[6] B. Min and V. Varadharajan, “Feature-Distributed Malware Attack: Risk
and Defence,” in 19th European Symposium on Research in Computer
Security (ESORICS), (Wroclaw, Poland), pp. 457–474, 2014.
[7] Anity Labs, “Analysis Report on Flame Worm Samples,” tech. rep.,
Anity Labs, July 2012.
[8] E. Chien, L. O. Murchu, and N. Falliere, “W32.Duqu The precursor to
the next Stuxnet,” tech. rep., Symantec, Nov. 2011.
[9] N. Falliere, L. O. Murchu, and E. Chien, “W32.Stuxnet dossier,” tech.
rep., Symantec, 2011.
[10] Kaspersky Lab, “Gauss: Abnormal Distribution,” tech. rep., Kaspersky
Lab, Aug. 2012.
[11] Kaspersky Lab, “Unveiling ”Careto” - The Masked APT,” tech. rep.,
Kaspersky Lab, Feb. 2014.
[12] M. Fossi, G. Egan, E. Johnson, T. Mack, T. Adams, J. Blackbird,
B. Graveland, and D. McKinney, “Symantec Report on Attack Kits
and Malicious Websites,” tech. rep., Symantec, 2011.
[13] C. Grier, L. Ballard, J. Caballero, N. Chachra, C. J. Dietrich,
K. Levchenko, P. Mavrommatis, D. McCoy, A. Nappa, and A. Pitsillidis,
“Manufacturing compromise: the emergence of exploit-as-a-service,” in
CCS’12, (Raleigh, North Carolina, USA), pp. 821–832, 2012.
[14] L. Lu, V. Yegneswaran, P. Porras, and W. Lee, “Blade: an attack-
agnostic approach for preventing drive-by malware infections,” in
CCS’10, (Chicago, Illinois, USA), pp. 440–450, 2010.
[15] Apple, “iOS Security,” tech. rep., Apple, Feb. 2014.
[16] Microsoft, “Code signing best practices,” tech. rep., Microsoft, July
2007.
[17] Microsoft, “Windows Authenticode Portable Executable Signature For-
mat,” tech. rep., Microsoft, July 2008.
[18] Android Ofﬁcial Web Page, “Signing Your Applications.” http://
developer.android.com/tools/publishing/app-signing.html.
[19] P. Roberts, “Accountability -Not Code Quality- Makes iOS Safer
Than Android.” https://threatpost.com/accountability-not-code-quality-
makes-ios-safer-android-042012/76463, Apr. 2012.
[20] C. Miller, “Don’t Hassle The Hoff: Breaking iOS Code Signing,” in
SyScan, (Taipei, Taiwan), Oct. 2011.
[21] H. Shinotsuka, “How Attackers Steal Private Keys from Digital Cer-
tiﬁcates.” http://www.symantec.com/connect/blogs/how-attackers-steal-
private-keys-digital-certiﬁcates, Jan. 2014.
[22] McAfee Labs, “McAfee Labs threats report 4th quarter 2013,” tech.
rep., McAfee Labs, Apr. 2014.
[23] G. McGraw and G. Morrisett, “Attacking Malicious Code: A Report to
the Infosec Research Council,” IEEE Software, vol. 17, no. 5, pp. 33–41,
2000.
[24] L. Gong, “Secure Java class loading,” IEEE Internet Computing, vol. 2,
no. 6, pp. 56–61, 1998.
[25] B. Hashi, M. Lal, R. Pandey, and S. Samorodin, “Securing systems
against external programs,” IEEE Internet Computing, vol. 2, no. 6,
pp. 35–45, 1998.
[26] B. Morton, “Code Signing,” tech. rep., CASC, Oct. 2013.
[27] A. D. Rubin and D. E. Geer, “Mobile code security,” IEEE Internet
Computing, vol. 2, no. 6, pp. 30–34, 1998.
[28] W3C, “Same Origin Policy.” http://www.w3.org/Security/wiki/Same
Origin Policy.
[29] B. Min, V. Varadharajan, U. K. Tupakula, and M. Hitchens, “Antivirus
security: naked during updates,” Software: Practice and Experience,
vol. 44, pp. 1201–1222, Oct. 2014.
[30] A. Rastogi, A. Chaudhuri, and R. Johnson, “Types and Access Controls
for Cross-Domain Security in Flash,” in Asian Symposium on Program-
ming Languages and Systems 2012, (Kyoto, Japan), pp. 82–97, 2012.
124124
[32] B. Arkin, “Inappropriate Use of Adobe Code Signing Certiﬁcate.”
https://blogs.adobe.com/security/2012/09/inappropriate-use-of-adobe-
code-signing-certiﬁcate.html, Sept. 2012.
J. Cannell, “Tools of the Trade: Exploit Kits.” http://blog.malwarebytes.
org/intelligence/2013/02/tools-of-the-trade-exploit-kits/, Feb. 2013.
contagio, “An Overview of Exploit Packs (Update 19.1) April 2013.”
http://contagiodump.blogspot.com, Apr. 2013.
J. Jones, “The State of Web Exploit Kits,” in Black Hat USA, (Las
Vegas, Nevada, USA), 2012.
[33]
[34]
[35]
[36] Microsoft, “New Low-Level Binaries.” http://msdn.microsoft.com/en-
us/library/windows/desktop/dd371752(v=vs.85).aspx.
[37] D. Artz and Y. Gil, “A survey of trust in computer science and the
Semantic Web,” Web Semantics: Science, Services and Agents on the
World Wide Web, vol. 5, pp. 58–71, June 2007.
[38] S. Balfe, A. D. Lakhani, and K. G. Paterson, “Trusted computing:
providing security for peer-to-peer networks,” in 5th IEEE International
Conference on Peer-to-Peer Computing, (Konstanz, Germany), pp. 117–
124, 2005.
[39] E. Damiani, D. C. di Vimercati, S. Paraboschi, P. Samarati, and
F. Violante, “A reputation-based approach for choosing reliable re-
sources in peer-to-peer networks,” in CCS’12: the 9th ACM conference
on Computer and communications security, (Washington, DC, USA),
pp. 207–216, Nov. 2002.
[40] A. Jøsang, R. Ismail, and C. Boyd, “A survey of trust and reputa-
tion systems for online service provision,” Decision Support Systems,
vol. 43, pp. 618–644, Mar. 2007.
[41] A. A. Selcuk, E. Uzun, and M. R. Pariente, “A reputation-based
trust management system for P2P networks,” in IEEE International
Symposium on Cluster Computing and the Grid, (Chicago, Illinois,
USA), pp. 251–258, 2004.
[42] S. Song, K. Hwang, R. Zhou, and Y.-K. Kwok, “Trusted P2P trans-
actions with fuzzy reputation aggregation,” IEEE Internet Computing,
vol. 9, no. 6, pp. 24–34, 2005.
[43] S. Chari, S. Halevi, and W. Venema, “Where Do You Want to Go
Today? Escalating Privileges by Pathname Manipulation,” in Network
& Distributed System Security Symposium (NDSS), (San Diego, CA,
USA), 2010.
[44] M. Payer, T. Hartmann, and T. R. Gross, “Safe Loading - A Foundation
for Secure Execution of Untrusted Programs,” in IEEE Symposium on
Security and Privacy (S&P) 2012, (San Fransisco, CA, USA), Apr.
2012.
I. Goldberg, D. Wagner, and R. Thomas, “A secure environment for
untrusted helper applications: Conﬁning the wily hacker,” in USENIX
Security Symposium 1996, (San Jose, CA, USA), 1996.
[45]
[46] C. Grier, S. Tang, and S. T. King, “Secure Web Browsing with the OP
Web Browser,” in IEEE Symposium on Security and Privacy, (Oakland,
CA, USA), pp. 402–416, 2008.
[47] H. J. Wang, C. Grier, A. Moshchuk, and S. T. King, “The Multi-
Principal OS Construction of the Gazelle Web Browser.,” in USENIX
Security Symposium 2009, (Montreal, Canada), 2009.
[48] S. Veeralakshmi and M. Sindhuja, “A Secure Environment for Unsafe
Component Loading,” International Journal of Engineering and Com-
puter Science, vol. 2, pp. 1111–1116, Apr. 2013.
[49] S. Dery, “Using Whitelisting to Combat Malware Attacks at Fannie
Mae,” IEEE Security & Privacy, vol. 11, no. 4, pp. 90–92, 2013.
[50] N. Geethanjali, S. Priyadarshini, and S. Karthik, “Detection Of Unsafe
Component Loadings Using Dynamic Analysis Technique,” Interna-
tional Journal of Advanced Research in Computer Engineering &
Technology, vol. 2, pp. 3247–3251, Dec. 2013.
[51] T. Ramesh, K. Prabhakar, and G. Ramesh, “Dynamic Component Safety
Analysis: A Regression Based Code Coverage Approach,” International
Journal of Electronics Communication and Computer Engineering,
vol. 4, no. 6, pp. 88–92, 2013.
[52] Y. Zhou and X. Jiang, “Dissecting android malware: Characterization
and evolution,” in IEEE S&P, (San Francisco, CA, USA), 2012.