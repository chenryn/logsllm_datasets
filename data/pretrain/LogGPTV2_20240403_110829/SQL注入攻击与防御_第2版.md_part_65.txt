只能调用存储过程，从而限制了攻击者能够访问或修改的数据。在很多情况下，这么做可以
319
---
## Page 334
SQL注入攻击与防御（第2版）
防止攻击者访问数据库中的敏感信息。
损害与防御.
存储过程中的SQL注入
通常假设只能在应用层（例如，在Web应用中）发生SQL注入，这是不正确的，因
为SQL注入可以出现在任何使用动态SQL的层，包括数据库层，如果将未经审查的用
户输入提交给数据库（例如，作为存储过程的参数），然后在动态SQL中使用该输入，那
么数据库层也可以像其他层郡样很客易出现SQL注入，
因此，在数据库层处理不可信的输入时应该格外小心，而且应该尽可能迎免使用动
态SQL.对于使用存储过程的情况，使用动态SQL通常意味着应该在数据库层定义附
加的存储过程来封装缺少的逻辑，这样才能在数据库中完全避免使用动态SQL。
8.8.2使用抽象层
设计商业应用时，常见的做法是为表示、业务逻辑和数据访间定义不同的层，从而将每一
层的实现从总体设计中抽象出来。根据使用技术的不同，这种做法可能涉及Hibemate、
ActiveRecord或Entity Framework这样的附加数据访问抽象层，对于这些框架，开发人员在应
用程序中无须编写一行SQL代码，其他类型的抽象层还包括使用ADO.NET、JDBC或PDO这
样的数据库访问框架。这些抽象层非常有助于那些意识到安全性的设计者们加强数据的安全访
问行为。这些行为之后会被用在架构的其他位置。
确保使用参数化语句来执行所有数据库调用的数据访问层是这种抽象层的一个很好的例
子。本章前面的8.3节“使用参数化语句”提供了很多借助多种技术（包括之前提到的技术）来使
用参数化语句的例子。假设应用程序除了以数据访问层方式访问数据库之外，不存在其他访问
方式，面且之后没有使用数据库层的动态SQL提供的信息，那么基本不可能出现SQL注入。
更强有力的做法是将这种访问数据库的方法与使用存储过程结合起来，这样可以进一步减轻
SQL注入的风险。这种方法还具有简化实现的效果，因为它已经定义了访问数据库的所有方法，
所以在设计良好的数据访间层中更容易实现。
损害与防御
抽象层提供的查询语言
某些抽象层引入了自己的查询语言，这些结构也可能造到注入攻击，比如Hibematc
具有一种名为HQL的查询语言，开发人员可以使用HQL创建复杂的查询、从多个表中
连接（join）数据、筛选数据，下面是一个用Java编写的简单例子：
session.createQuery (*from Users u where u.username - *- + username + **#)
显然，很容易使用单引号对这个例子中的代码进行注入攻击，在8.3节“使用参数
化语句”中曾经介绍过这种语句容易遗到攻击的原因，在使用HQL时也可以使用参数
化查询，可以在查询中使用命名参数，并在随后的语句中设置参数的值：
320
---
## Page 335
第8章代码层防御
Query query * session.createQuery("from Users user where
query.setString ("usernane*, username) ;
在上面的例子中，使用Hibermate框架对数据进行编码一就像在SQL中使用参数
化语句一样
8.8.3处理敏感数据
最后一种减轻SQL注入严重影响的技术是考虑数据库中敏感信息的存储和访问。攻击者的
目标之一是获取对数据库所存储数据的访问权，这些数据通常包含某种形式的货币值。攻击者
有兴趣获取的信息包括用户名和口令、个人信息或信用卡明细这样的财务信息。因为这个原因，
我们有必要对敏感信息进行附加的控制。下面给出一些控制示例或者需要考虑的设计决策：
口令：如果可能的话，不应该在数据库中存储用户口令。比较安全的做法是存储每个用户
口令的加盐（salted）单向哈希（使用SHA256这样的安全哈希算法）而不是口令本身。接下来比较
理想的做法是将salt（一种附加的少量随机数据）与哈希口令分开保存。对于这种情况，登录时
不要比较用户口令和数据库中保存的口令，而应将通过用户提供的信息计算出来的加盐哈希与
数据库中保存的哈希值进行比较。请注意，这样可防止应用向忘记口令的用户发送包含口令的
c-mail。如果用户忘记了口令，就应该为他生成一个新的安全口令并将新口令提供给用户。
信用卡及其他财务信息：应该使用认可的（比如FIPS认证过的）加密算法来对信用卡等信息进
行加密，然后存储加密后的明细数据。这是PCI-DSS（支付卡行业数据安全标准）对信用卡信息作出
的一个要求。不过还应该考虑对应用程序中的其他财务信息（比如银行账户明细）进行加密。
存档：如果未要求应用程序保存提交给它的所有敏感信息（例如个人可识别的信息）的完整
历史记录，就应考虑每隔一段合理的时间就存档或清除这些不需要的信息。如果初始处理后应
用程序不再需要这些信息，就应该立即存档或清除它们。对于这种情况，清除信息可以降低未
来安全破坏（其中暴露是主要的隐私破坏途径）带来的影响，它通过减少攻击者能够访问的顾客
信息量来实现该目的。
秘密手记
来自一个事件响应的启示
我曾经碰到过一个有趣的事件响应预约，它涉及美国东北部地区一个很大的地方银
行，有一天，客户（银行）的服务器管理员发现服务器日志比平常期望的大小大了数倍，
与此同时，客户也注意到出现了一些异常情况，为找到原因，他们查看了日志并很快断
定他们成了SQL注入利用的牺牲品
这种情况下利用的要素可谓无伤大雅：它是一种标识符，应用使用它来确定用户想
读取该Web站点中“News”模块的哪篇新闻稿.遗憾的是，对于客户来说，数据库中
不只保存了该新闻稿的明细信息，它还保存了银行中每个通过Web站点申请抵押的顾
客在抵押方面的应用明细，其中包括将近10000个顾客完整的用户名、社会保险号、电
话号码、历史地址记录和工作履历等，换言之，进行身份盗窃需要的所有信息。
321
---
## Page 336
SQL注入攻击与防御（第2版）
毫无疑问，银行向每位顾客写了一封道款信，并为所有受到影响的顾客提供了免费
的身份盗窃保护，这样才算平息了此事。如果当初银行在利用发生之前适当地关注那些
存储敏感信息的地方，那么这种利用可能就不会像现在这样严重。
8.8.4避免明显的对象名
出于安全方面的原因，在为关键对象（比如加密函数、口令列和信用卡列）选取名称时应该
格外小心
多数应用程序开发人员会使用意思非常明显的列名，比如password或kennwort（德语）这样
的词汇。从另一方面来说，大多数攻击者也会意识到这种命名方法，从而能够在恰当的数据库
视图中搜索他们感兴趣的列名(比如 password)。下面是Oracle 中的一个例子：
SELECT owner1I*.*I1column_name FROM a11_tab_columns WHERE upper (column_name)
LIKE '$PASSWS*)
接下米的攻击步骤会从表中选出那些包含口令或其他敏感信息的数据。请参考表8-8以了解
应该避免哪些命名类型。该表列出了password这个词常见的变体和翻译成其他语言后的形式。
表8-8不同语言中的password单词
用于password的词
语言
password、 pwd、passw
英语
passwort、 kennwort
德语
Motdepasse、 mdp
法语
Wachtwoord
荷兰语
Senha
葡萄牙语
Haslo
波兰语
为使攻击变得困难，使用不明显的表名和列名来保存口令信息是个不错的主意。虽然这无
法阻止攻击者寻找并访问数据，但却可以确保攻击者无法很快识别这种信息。
8.8.5创建honeypot
如果希望在有人尝试从数据库读取口令时收到警告，可以创建一种带password列（包含假
数据）的附加honeypot(蜜罐）表。如果假数据被选中，那么应用管理员将会收到一封e-mail。在
Oracle中，可以使用虚拟专用数据库(VirtualPrivate Database，VPD）来实现这种解决方案，如
下面示例中所示：
-创建蜜罐表
create table app_user,tblusers (is number, name varchar2(30), password
varchar2 (30) ;
--创建向管理员发送e-mai1的策略函数
--必须用另外一个模式来创建该函数，比如secuser
create or replace secuser,function get_cust_id
322
---
## Page 337
第8章代码层防御
P_schema in varchar2,
p_tab1e in varchar2
return varchar2
V_connection UTL_SMTP,CONNECTION;
begin
V_connection := UTL_SMTP,OPEN_CONNECTION (*mai1host ,victim,com*, 25) ;
UTL_SMTP .MAIL (v_connection, *app8victim. com*) ;
UTL_SMTP.HELO (v_connection, *mailhost.victim.com′) ;
UTL_SMrP , RCPT (v_connection, *admin@victim, com′) ;
UTL_SMTP .DATA (v_COnnection, *WARNING! SELECT PERFORMED ON HONEYPOT′) ;
UTL_SMTP , QUIT (v_connection) ;
return*1=1';--总是显示整个表
end;
--将策略函数赋值给蜜罐表TBLUSERS
exec dbms_rls.add_policy (
'APP_USER',
'GET_CUST_ID′,
'SECUSER',
"",
′SELECT, INSERT, UPDATE, DELETE′):
8.8.6附加的安全开发资源
可借助很多现有的资源来向编写应用程序的开发人员提供工具、资源、培训和知识，从而
提高应用程序的安全性。下面是本书作者们认为最有用的资源列表：
●OWASP(Open Web Application Security Project，开放式 Web 应用安全项目：www.owasp.
org）是一个开放的、致力于提高Web应用安全性的团队。OWASP拥有很多项目，它们
提供了资源、指导手册和工具来辅助开发人员理解、寻找并定位代码中的安全问题。
其中非常有名的项目包括 ESAPI(Enterprise Security API，企业安全API)和 OWASP 开
发指南。前者提供了一批API方法来实现像输入验证这样的安全需求，后者则为安全
开发提供了全面指导。
●CWE/SANS 2009 年度 25 大最危险编程错误(htp://cwe.mitre.org/top25/index.html)是MITRE
(SANS协会）和许多高级安全专家通力合作的成果，其目的是为开发人员提供一种有教
育意义的常识性工具。它另外还提供了很多与项目中定义的25大编程错误（其中有一种
为SQL注入)相关的明细信息。
·SANS软件安全协会（www.sans-ssi.org)提供了安全开发方面的培训和证书，以及大量由
SANS认证检验员提供的参考信息和研究资料。
●Oracle 的 SQL 注入攻击防御指南(htp:/st-curriculum.oracle.com/tutorial/SQLInjection/index.
htm）介绍了很多有助于免受SQL注入攻击的工具和技术。
●SQLSecurity.com（www.sqlsecurity.com）是个致力于Microsof SQL Server 安全的站点，
它包含了很多解决SQL注入及其他SQLServer安全问题的资源。
323
---
## Page 338
SQL注入攻击与防御（第2版）
●Red-Database-Security(www.red-database-security.com)是个专门研究Oracle 安全的公
司。它的网站上包含了很多可供下载的关于Oracle安全的报告和白皮书。
●Pete Finnegan Limited(http:/petefinnigan.com)也提供了大量用于保证 Oracle数据库安全
的信息。
8.9本章小结
本章介绍了几种为保证应用程序免受SQL注入攻击而建议使用的技术，这些技术对减轻
某些注入攻击问题非常有效。不过，要想实现有效的保护，则需要实现本章介绍的多种技术。
出于上述原因，读者应该了解所有可用的解决方案并确定如何将它们集成到应用程序中。
如果无法集成某一解决方案，就应确定是否可使用其他技术来提供正在寻找的覆盖范围。请记
住，本章讨论的每种技术只能代表深层防御策略的一个子部分，它们可在每一层上对应用程序
进行保护。请思考在哪些地方对应用程序的输人集合使用白名单输入验证，在层间和数据库前
的哪些地方使用输出编码，如何对来自数据库的信息进行编码，如何在验证数据之前进行规范
化和（或）标准化，如何构建并实现数据对数据库的访问。将上述内容结合起来将有助于您免遭
SQL注入攻击。
8.10快速解决方案
1.领域驱动的安全性
·SQL注入之所以发生，是因为我们的应用程序不正确地将数据在不同表示方式之间进
行映射。
·通过将数据封装到有效的值对象中，并限制对原始数据的访问，我们就可以控制对数
据的使用。
2.使用参数化语句
·动态SQL（或者将SQL查询组装成包含受用户控制的输入的字符串并提交给数据库）是
引发SQL注入漏洞的主要原因。
·应该使用参数化语句（也称为预处理语句）而非动态SQL来安全地组装SQL查询。
·在提供数据时可以只使用参数化语句，但却无法使用参数化语句来提供SQL关键字或
标识符(比如表名或列名)。
3.验证输入
·尽可能坚持使用白名单输入验证（只接收期望的已知良好的输入)。
·确保验证应用收到的所有受用户控制的输入的类型、大小、范围和内容。
·只有当无法使用白名单输入验证时才能使用黑名单输入验证（拒绝已知不良的或基于
签名的输入）。
·绝不能单独只使用黑名单检验数据。至少应该总是将它与输出编码技术一起结合使用。
324
---
## Page 339
第8章代码层防御
4.编码输出
·确保对包含用户可控制输入的查询进行正确编码以防止使用单引号或其他字符来修改
查询。
·如果正在使用LIKE子句，请确保对LIKE中的通配符恰当地编码。
·在使用从数据库接收到的数据之前确保已经对数据中的敏感内容进行了恰当的输入验
5.规范化
●将输入解码或变为规范格式后才能执行输入验证过滤器和输出编码。