# 工控安全入门（九）——工控协议逆向初探
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
在工控领域，我们会遇到许多协议，为了进行安全研究，经常需要对协议的具体内容进行探索，今天我们就来聊聊关于工控协议逆向的问题。
在接下来的几篇文章中，我会简单介绍一下常用的协议逆向方法并配合一些实战，当然，从未知到已知的探索过程不仅仅需要代码上的实践，还需要数学上的分析与建模，所以在这几篇文章中不仅会有工控、协议的知识，还有大量的数学内容，因为我本身不是搞学术研究的，所以一些东西也只是略微了解而已，如果大佬们发现有什么错误请在评论中指出，我一定仔细查看。还要感谢[@bitpeach](https://github.com/bitpeach
"@bitpeach")大佬的文章让我了解到了很多知识。
按照分类，工控协议一般可以分为以下两种：
  * 公开协议，这里的公开主要是说它是公开发表并且无版权要求的，我们介绍的modbus就属于这一种。
  * 私有协议，顾名思义就是厂家自有的，为正式公开的，我们介绍过的西门子S7comm就属于这一种。
但不论是公开协议还是私有协议往往都具有一定的未知性。像是modbus，虽说大部分信息我们都是了解的，但是还有很多function
code是厂商自己偷偷用的，像是施耐德我们之前就提过，有自己的0x5a来实现一堆高权限操作；S7comm这类的私有协议就更不用说了，要不是前辈们的逆向工程，我们其实是对协议内容一无所知的。我们今天要聊的就是对于这类未知的逆向过程。
对于协议的逆向我们也是分成两类方法：
  * 基于网络轨迹的逆向，即对抓取的流量包进行分析，利用各类数学分析、推理，对数据进行切分、关系预测、生成状态机等等，从而推断出协议的部分内容、进行fuzz等操作。
  * 基于接收端程序的逆向，即对协议数据的接收端程序进行逆向分析，从而得到协议的内容，这也是现在常用的方法，像是最近S7commPlus的逆向就是借助分析上位机的OMSp_core_managed.dll组件来实现的。
当然，这两种逆向方式都需要结合相应的设备进行调试来完成，也完全可以两种方式结合，先基于网络轨迹大致判断协议格式、关系，再通过逆向程序加以完善。这篇文章我们就首先看看基于网络轨迹的逆向。
## 基于网络轨迹的逆向
考虑到我们为入门教程，所以我们选用的数据包并不是真正的”未知“协议，我们使用系列第一篇文章的modbus数据包来进行分析，我们将其TCP以上均视为未知部分
如图的包，我们将modbus部分的数据视作
    x00x00x00x00x00x04x00Zx00x02
现在看上去还是毫无头绪？没关系，我们一点点来
###  确定协议字段的基本知识
确定协议字段说白了就是根据流量包中的大量流量对比，”猜“出来哪些数据应该是一个字段，这个过程中涉及到协议分析算法，而这些算法又是由一些重要的数学模型、算法构成的，我选取了《Network
Protocol Analysis using Bioinformatics
Algorithms》、《基于网络协议逆向分析的远程控制木马漏洞挖掘》两篇论文中的某些部分进行简要说明，来大致了解一下这部分理论知识（因为我们是要做实际分析，所以涉及到研究部分的算法等理论我就不再细化了）。
LD（LevenShtein
Distance），假设我们有A、B两个字符串，A经过插入、删除、替换字符的最短过程变为B，经过的步骤表示两个字符串的差异。如：
    A = "modbus"
    B = "modicon"
显然我们需要把子串”bus“换为”ico“，然后添加字符”n“，所以LD(A,B)=4，python实现代码如下：
    def normal_leven(str1, str2):
        len_str1 = len(str1) + 1
        len_str2 = len(str2) + 1
        # 创建矩阵
        matrix = [0 for n in range(len_str1 * len_str2)]
        # init x轴
        for i in range(len_str1):
            matrix[i] = i
        # init y轴
        for j in range(0, len(matrix), len_str1):
            if j % len_str1 == 0:
                matrix[j] = j // len_str1
        for i in range(1, len_str1):
            for j in range(1, len_str2):
                if str1[i - 1] == str2[j - 1]:
                    cost = 0
                else:
                    cost = 1
                # 若ai=bj，则LD(i,j)=LD(i-1,j-1)   取矩阵对角的值
                # #若ai≠bj，则LD(i,j)=Min(LD(i-1,j-1),LD(i-1,j),LD(i,j-1))+1   在对角，左边，上边，取最小值+1
                matrix[j * len_str1 + i] = min(matrix[(j - 1) * len_str1 + i] + 1, matrix[j * len_str1 + (i - 1)] + 1,matrix[(j - 1) * len_str1 + (i - 1)] + cost)
        return matrix[-1]
    str1 = ''
    str2 = ''
    a = normal_leven(str1, str2)
    print(1-a/max(len(str1), len(str2)))
    print(type(1-a/max(len(str1), len(str2)))
LCS（Longest common
subsequence），这个和大家理解的两个字符串求最大子序列有些不同，这里的字符并不一定要连续出现。如：A与B的最长子序列为”mod“，所以LCS(A,B)=3，而我们将A变为”m
o d b u
s“，LCS(A,B)仍然为3，所以，如果LCS(X,Y)=0，那么立即推，X、Y没有任何一个字符相同。在论文中包括了GSA（全局序列对比）与LSA（局部序列对比），GSA用在对协议域的理解上，而LCS则是对相似序列进行聚类。编程中，我们可以使用Needleman/Wunsch算法来求解。我们还是以上面的两个字符串为例
|  | m | o | d | b | u | s  
---|---|---|---|---|---|---|---  
| 0 | 0 | 0 | 0 | 0 | 0 | 0  
m | 0 |  |  |  |  |  |  
o | 0 |  |  |  |  |  |  
d | 0 |  |  |  |  |  |  
i | 0 |  |  |  |  |  |  
c | 0 |  |  |  |  |  |  
o | 0 |  |  |  |  |  |  
n | 0 |  |  |  |  |  
首先我们将矩阵初始化，即上述表格，接着按照公式进行填充
若ai=bj，则LCS(i,j)=LCS(i-1,j-1)+1
若ai≠bj，则LCS(i,j)=Max(LCS(i-1,j-1),LCS(i-1,j),LCS(i,j-1))
该公式其实非常简单，如果行列字符一样，则填充的值为它左上角的值加1，如果不一样就是左上角、上边、左边的最大值。按照这个标准我们从第一行开始填，得到如下结果
|  | m | o | d | b | u | s  
---|---|---|---|---|---|---|---  
| 0 | 0 | 0 | 0 | 0 | 0 | 0  
m | 0 | 1 | 1 | 1 | 1 | 1 | 1  
o | 0 | 1 | 2 | 2 | 2 | 2 | 2  
d | 0 | 1 | 2 | 3 | 3 | 3 | 3  
i | 0 | 1 | 2 | 3 | 3 | 3 | 3  
c | 0 | 1 | 2 | 3 | 3 | 3 | 3  