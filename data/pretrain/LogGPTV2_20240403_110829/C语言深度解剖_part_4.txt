产生溢出。另外还要清楚的就是负数的补码怎么表示。弄明白了这两点，这个问题其实就很
简单了。
- 18 -
留三个问题：
1），按照我们上面的解释，那-0 和+0 在内存里面分别怎么存储？
2），int i = -20;
unsigned j = 10;
i+j 的值为多少？为什么？
3）， 下面的代码有什么问题？
unsigned i ;
for (i=9;i>=0;i--)
{
printf("%u\n",i);
}
1.7 if、else 组合
if 语句很简单吧。嗯，的确很简单。那我们就简单的看下面几个简单的问题：
1.7.1 bool 变量不“零值”迕行比较
bool 变量与“零值”进行比较的if 语句怎么写？
bool bTestFlag = FALSE;//想想为什么一般初始化为FALSE 比较好？
A), if(bTestFlag == 0); if(bTestFlag == 1);
B), if(bTestFlag == TRUE); if(bTestFlag == FLASE);
C), if(bTestFlag); if(!bTestFlag);
哪一组或是那些组正确呢？我们来分析分析：
A)写法：bTestFlag 是什么？整型变量？如果要不是这个名字遵照了前面的命名规范，
恐怕很容易让人误会成整型变量。所以这种写法不好。
B)写法：FLASE 的值大家都知道，在编译器里被定义为0；但TRUE 的值呢？都是1吗？
很不幸，不都是1。Visual C++定义为1，而它的同胞兄弟Visual Basic 就把TRUE 定义
为-1.那很显然，这种写法也不好。
大家都知道if 语句是靠其后面的括号里的表达式的值来进行分支跳转的。表达式如果
为真，则执行if 语句后面紧跟的代码；否则不执行。那显然，本组的写法很好，既不会引
起误会，也不会由于TRUE 或FLASE 的不同定义值而出错。记住：以后写代码就得这样写。
1.7.2 float 变量不“零值”迕行比较
float 变量与“零值”进行比较的if 语句怎么写？
float fTestVal = 0.0；
A), if(fTestVal == 0.0); if(fTestVal != 0.0);
B), if((fTestVal >= -EPSINON) && (fTestVal <= EPSINON)); //EPSINON 为
定义好的精度。哪一组或是那些组正确呢？我们来分析分析：
float 和double 类型的数据都是有精度限制的，这样直接拿来与0.0 比，能正确吗？
明显不能，看例子：兀 的值四舍五入精确到小数点后10位为：3.1415926536，你拿它减
- 19 -
去0.00000000001，然后再四舍五入得到的结果是多少?你能说前后两个值一样
吗?EPSINON 为定义好的精度，如果一个数落在[0.0-EPSINON,0.0+EPSINON] 这个闭区
间内，我们认为在某个精度内它的值与零值相等；否则不相等。扩展一下，把0.0 替换为
你想比较的任何一个浮点数，那我们就可以比较任意两个浮点数的大小了，当然是在某个精
度内。
同样的也不要在很大的浮点数和很小的浮点数之间进行运算，比如：
10000000000.00 + 0.00000000001
这样计算后的结果可能会让你大吃一惊。
1.7.3 挃针变量不“零值”迕行比较
指针变量与“零值”进行比较的if 语句怎么写？
int* p = NULL;//定义指针一定要同时初始化，指针与数组那章会详细讲解。
A), if(p == 0); if(p != 0);
B), if(p); if(!p);
C) , if(NULL == p); if(NULL != p);
哪一组或是那些组正确呢？我们来分析分析：
A)写法：p 是整型变量？容易引起误会，不好。尽管NULL 的值和0 一样，但意义不同。
B)写法：p 是bool 型变量？容易引起误会，不好。
C)写法：这个写法才是正确的，但样子比较古怪。为什么要这么写呢？是怕漏写一个
“=”号:if(p = NULL)，这个表达式编译器当然会认为是正确的，但却不是你要表达
的意思。所以，非常推荐这种写法。
1.7.4 else 到底不哪个 if 配对呢？
else 常常与if 语句配对，但要注意书写规范，看下面例子：
if（0 == x）
if（0 == y） error（）；
else{
//program code
}
这个else 到底与谁匹配呢？让人迷糊，尤其是初学者。还好，C 语言有这样的规定：
else始终与同一括号内最近的未匹配的if 语句结合。虽然老手可以区分出来，但这样的代
码谁都会头疼的，任何时候都别偷这种懒。关于程序中的分界符‘{’和‘}’，建议如下：
【建议1-16】程序中的分界符‘{’和‘}’对齐风格如下：
注意下表中代码的缩进一般为4 个字符，但不要使用Tab 键，因为不同的编辑器Tab 键
定义的空格数量不一样，别的编辑器打开Tab 键缩进的代码可能会一片混乱。
- 20 -
- 21 -
1.7.5 if 语句后面的分号
关于if-else 语句还有一个容易出错的地方就是与空语句的连用。看下面的例子：
if(NULL != p) ;
fun();
这里的fun()函数并不是在NULL != p 的时候被调用，而是任何时候都会被调用。问
题就出在if 语句后面的分号上。在C 语言中，分号预示着一条语句的结尾，但是并不是每
条C 语言语句都需要分号作为结束标志。if 语句的后面并不需要分号，但如果你不小心写
了个分号，编译器并不会提示出错。因为编译器会把这个分号解析成一条空语句。也就是上
面的代码实际等效于：
if(NULL != p)
{
else
{
//program code
}
}
或：
if (condition)
//program code
else
//program code
或：
if (width < height) dosomething();
for (initialization; condition; update)
{
//program code
}
for (initialization;condition; update){
//program code
}
while (condition)
{
//program code
}
while (condition){
//program code
}
do
{
//program code
}
while (condition);
do{
- 22 -
//program code
}while (condition);
;
}
fun();
这是初学者很容易犯的错误，往往不小心多写了个分号，导致结果与预想的相差很远。
所以建议在真正需要用空语句时写成这样：
NULL;
而不是单用一个分号。这就好比汇编语言里面的空指令，比如ARM 指令中的NOP 指令。
这样做可以明显的区分真正必须的空语句和不小心多写的分号。
1.7.6 使用 if 语句的其他注意事项
【规则1-17】先处理正常情况，再处理异常情况。
在编写代码是，要使得正常情况的执行代码清晰，确认那些不常发生的异常情况处理代
码不会遮掩正常的执行路径。这样对于代码的可读性和性能都很重要。因为，if 语句总是
需要做判断，而正常情况一般比异常情况发生的概率更大（否则就应该把异常正常调过来
了），如果把执行概率更大的代码放到后面，也就意味着if 语句将进行多次无谓的比较。
另外，非常重要的一点是，把正常情况的处理放在if 后面，而不要放在else 后面。当然
这也符合把正常情况的处理放在前面的要求。
【规则1-18】确保if 和else 子句没有弄反。
这一点初学者也容易弄错，往往把本应该放在if 语句后面的代码和本应该放在else
语句后面的代码弄反了。
1.8 switch、case 组合
既然有了if、else 组合为什么还需要switch、case 组合呢？
1.8.1 丌要拿青龙偃月刀去削苹果
那你既然有了菜刀为什么还需要水果刀呢？你总不能扛着云长的青龙偃月刀（又名冷艳
锯）去削苹果吧。如果你真能做到，关二爷也会佩服你的。^_^。
if、else 一般表示两个分支或是嵌套表示少量的分支，但如果分支很多的话……还是用
switch、case 组合吧。其基本格式为:
switch(variable)
{
case Value1:
//program code
break;
case Value2:
//program code
break;
- 23 -
…
default:
break;
}
很简单，但有两个规则：
【规则1-19】每个case 语句的结尾绝对不要忘了加break，否则将导致多个分支重叠
（除非有意使多个分支重叠）。
【规则1-20】最后必须使用default 分支。即使程序真的不需要default 处理，也应
该保留语句：
default :
break;
这样做并非画蛇添足，可以避免让人误以为你忘了default 处理。
1.8.2 case 关键字后面的值有什么要求吗？
好，再问问：真的就这么简单吗？看看下面的问题：
Value1 的值为0.1 行吗？-0.1 呢？-1 呢？0.1+0.9 呢？ 1+2 呢？3/2 呢？‘A’
呢？“A”呢？变量i（假设i 已经被初始化）呢？NULL 呢？等等。这些情形希望你亲自上
机调试一下，看看到底哪些行，哪些不行。
记住：case 后面只能是整型或字符型的常量或常量表达式（想想字符型数据在内存里
是怎么存的）。
1.8.3 case 语句的排列顺序
似乎从来没有人考虑过这个问题，也有很多人认为case 语句的顺序无所谓。但事实却
不是如此。如果case 语句很少，你也许可以忽略这点，但是如果case 语句非常多，那就
不得不好好考虑这个问题了。比如你写的是某个驱动程序，也许会经常遇到几十个case 语
句的情况。一般来说，我们可以遵循下面的规则：
【规则1-21】按字母或数字顺序排列各条case 语句。
如果所有的case 语句没有明显的重要性差别，那就按A-B-C 或1-2-3 等顺序排列
case语句。这样做的话，你可以很容易的找到某条case 语句。比如：
switch(variable)
{
case A:
//program code
break;
case B:
//program code
break;
case C:
//program code
break;