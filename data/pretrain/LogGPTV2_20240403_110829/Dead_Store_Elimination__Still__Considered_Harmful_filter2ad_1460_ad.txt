resulting in a score of inconsistent, denoted(cid:71)(cid:35) in Table 1.
As the results in Table 1 show, only three of the eleven
projects had a scrubbing function that was effective
and used consistently.
We notiﬁed the developers of each project that we
scored ﬂawed or inconsistent. For our report to the devel-
opers, we manually veriﬁed each instance where a scrub-
bing operation was removed, reporting only valid cases
to the developers. Generally, as described below, devel-
opers acknowledged our report and ﬁxed the problem.
Note that none of the issues resulted in CVEs because
to exploit, they must be used in conjunction with a sepa-
rate memory disclosure bug and these types of bugs are
outside the scope of this work.
In the remainder of this section, we report on the open
source projects that we analyzed. Our goal is to iden-
tify common trends and understand how developers deal
with the problem of compilers removing scrubbing oper-
ations.
5.1 OpenVPN
OpenVPN is an TLS/SSL-based user-space VPN [21].
We tested version 2.3.12. OpenVPN 2.3.12 does not have
a reliable memory scrubbing implementation since it
uses a CLEAR macro which expands to memset. We found
8 scrubbing operations that were removed, all of which
deal with sensitive data. Each of the removed operations
used CLEAR, which is not effective.
Sample case. Function key_method_1_read in Fig-
ure 2 is used in OpenVPN’s key exchange function to
process key material received from an OpenVPN peer.
However, the CLEAR macro fails to scrub the key on the
stack since it is a call to plain memset.
Developer response. The issues were reported, al-
though OpenVPN developers were already aware of the
problem and had a ticket on their issue tracker for it that
was opened 12 days prior to our notiﬁcation [26]. The
patch does not change the CLEAR macro since it is used
extensively throughout the project, but it does replace
many CLEAR calls with our recommended ﬁx discussed
in Section 6 [7].
5.2 Kerberos
Kerberos is a network authentication protocol that pro-
vides authentication for client/server applications by us-
ing secret-key cryptography [12]. We tested Kerberos re-
lease krb5-1.14.4. The Kerberos memory scrubbing im-
1034    26th USENIX Security Symposium
USENIX Association
tls_session *session) {
1 /* From openvpn-2.3.12/src/openvpn/basic.h */
2 #define CLEAR(x) memset(&(x), 0, sizeof(x))
3
4 /* From openvpn-2.3.12/src/openvpn/ssl.c */
5 static bool key_method_1_read (struct buffer *buf, struct
6
7
8
9
10
11
12
13
14
15 }
struct key key;
/* key is allocated on stack to hold TLS session key */
...
/* Clean up */
CLEAR (key);
ks->authenticated = true;
return true;
Figure 2: A removed scrubbing operation in OpenVPN
2.3.12.
plementation, zap, is unreliable. First, it defaults to Win-
dows’ SecureZeroMemory, which is effective. Other-
wise it uses a memory barrier that may not prevent the
scrubbing operation from being removed when the code
is compiled with Clang (see Section 3.4.3). Finally, if the
compiler is not GCC, it uses a function that calls memset.
While this is more reliable than a macro, memset may
be removed if LTO is enabled (see Section 3.3.1). Fur-
thermore, even though zap is available (and reliable on
Windows), plain memset is still used throughout the code
to perform scrubbing. We found 10 sites where scrubbing
was done using memset, which is not effective; 2 of these
sites deal with sensitive data.
Sample case. Function free_lucid_key_data in Fig-
ure 3 is used in Kerberos to free any storage associated
with a lucid key structure (which is typically on the heap)
and to scrub all of its sensitive information. However it
does so with a call to plain memset, which is then re-
moved by the optimizer.
Developer response. The issues have been patched with
calls to zap. In addition, zap has been patched according
to our recommended ﬁx discussed in Section 6.
if (key) {
if (key->data && key->length) {
memset(key->data,0,key->length);
xfree(key->data);
memset(key,0,sizeof(gss_krb5_lucid_key_t));
1 static void free_lucid_key_data(gss_krb5_lucid_key_t *key) {
2
3
4
5
6
7
8
9 }
Figure 3: A removed scrubbing operation in Kerberos re-
lease krb5-1.14.4.
}
}
5.3 Tor
Tor provides anonymous communication via onion
routing [25]. We tested version 0.2.8.8. Tor de-
scrubs memory:
ﬁnes memwipe, which
it uses Windows’ SecureZeroMemory if
avail-
able,
then
BSD’s explicit_bzero,
then memset_s, and then
OPENSSL_cleanse, which is described below. Despite
then RtlSecureZeroMemory if available,
reliably
the availability of memwipe, Tor still uses memset to
scrub memory in several places. We found 4 scrubbing
operations that were removed, however none dealt with
sensitive data.
Sample case. Function MOCK_IMPL in Figure 4 is used
to destroy all resources allocated by a process han-
dle. However, it scrubs the process handle object with
memset, which is then removed by the optimizer.
Developer response. The bugs were reported and have
yet to be patched.
*process_handle, int also_terminate_process)) {
/* process_handle is passed in and allocated on heap to
1 MOCK_IMPL(void, tor_process_handle_destroy,(process_handle_t
2
3
4
5
6
7
8
9 }
...
memset(process_handle, 0x0f, sizeof(process_handle_t));
tor_free(process_handle);
* hold process handle resources */
Figure 4: A removed scrubbing operation in Tor 0.2.2.8.
5.4 OpenSSL
OpenSSL is a popular TLS/SSL implementation as well
as a general-purpose cryptographic library [20]. We
tested version 1.1.0b. OpenSSL uses OPENSSL_cleanse
to reliably scrub memory. OPENSSL_cleanse defaults
to its own assembly implementations in various archi-
tectures unless speciﬁed otherwise by the no-asm ﬂag
at conﬁguration. Otherwise, starting with version 1.0.2,
it uses the volatile function pointer technique to call
memset. Prior to version 1.0.2, it used the complicated
computation technique. We found no removed scrubbing
operations in version 1.1.0b.
5.5 NSS
Network Security Services (NSS) is an TLS/SSL imple-
mentation that traces its origins to the original Netscape
implementation of SSL [18]. We tested version 3.27.1.
NSS does not have a reliable memory scrubbing imple-
mentation since it either calls memset or uses the macro
PORT_Memset, which expands to memset. We found 15
scrubbing operations that were removed, 9 of which deal
with sensitive data. Of the 15 removed operations, 6 were
calls to PORT_Memset and 9 were calls to plain memset.
Sample case. Function PORT_ZFree is used through-
out the NSS code for freeing sensitive data and is based
on function PORT_ZFree_stub in Figure 5. However
PORT_ZFree_stub’s call to memset fails to scrub the
pointer it is freeing.
Developer response. The bugs have been reported and
Mozilla Security forwarded them to the appropriate
team, however they have not yet been patched.
5.6 Libsodium
Libsodium is
li-
brary [15]. We tested version 1.0.11. Libsodium deﬁnes
cross-platform cryptographic
a
USENIX Association
26th USENIX Security Symposium    1035
STUB_SAFE_CALL2(PORT_ZFree_Util, ptr, len);
memset(ptr, 0, len);
return free(ptr);
1 extern void PORT_ZFree_stub(void *ptr, size_t len) {
2
3
4
5 }
Figure 5: A removed scrubbing operation in NSS 3.27.1.
sodium_memzero, which does not reliably scrub mem-
ory. First, it defaults to Windows’ SecureZeroMemory,
then memset_s, and then BSD’s explicit_bzero if
available, which are all reliable. Then if weak symbols
are supported,
it uses a technique based on weak
linkage, otherwise it uses the volatile data pointer
technique. Techniques based on weak linkage are not
reliable, because they can be removed during link-
time optimization. All memory scrubbing operations
used sodium_memzero, and since Libsodium is not
compiled with link-time optimization, no scrubbing
operations using sodium_memzero were removed.
5.7 Tarsnap
Tarsnap is a online encrypted backup service whose
client
source code is available [24]. We tested
version 1.0.37. Tarsnap’s memory scrubbing im-
plementation, called insecure_memzero, uses
the
volatile data pointer scrubbing technique. Although
insecure_memzero is an effective scrubbing function,
Tarsnap does not use it consistently. We found 10 cases
where memset was used to scrub memory instead of
insecure_memzero in its keyfile.c, which handles
sensitive data.
Sample case. Function read_encrypted in Figure 6
attempts to scrub a buffer on the heap containing a de-
crypted key. It is used throughout the project for reading
keys from a Tarsnap key ﬁle. However, instead of using
insecure_memzero, it uses plain memset, and is thus
removed by the optimizer.
Developer response. Out of the eleven reported issues,
the 10 in keyfile.c were already patched on July 2,
2016 but were not in the latest stable version. The one
non-security issue does not require a patch, since the re-
moved memset was redundant as insecure_memzero is
called right before it.
keylen, uint64_t * machinenum, const char * filename,
int keys) {
1 static int read_encrypted(const uint8_t * keybuf, size_t
2
3
4
5
6
7
8
9
10
11
12
13
14 }
uint8_t * deckeybuf;
/* deckeybuf is allocated on heap to hold decrypted key */
...
/* Clean up */
memset(deckeybuf, 0, deckeylen);
free(deckeybuf);
free(passwd);
free(pwprompt);
return (0);
Figure 6: A removed scrubbing operation in Tarsnap
1.0.37.
5.8 Libgcrypt
Libgcrypt is a general purpose cryptographic library used
by GNU Privacy Guard, a GPL-licensed implementa-
tion of the PGP standards [13]. We tested version 1.7.3.
Libgcrypt deﬁnes wipememory, which is a reliable way
of scrubbing because it uses the volatile data pointer
technique. However, despite wipememory’s availability
and reliability, memset is still used to scrub memory in
several places. We found 2 cases where scrubs were re-
moved, and for both, memset is used to scrub sensitive
sensitive data instead of wipememory.
Sample case. Function invert_key in Figure 7 is used
in Libgcrypt’s IDEA implementation to invert a key for
its key setting and block decryption routines. However,
invert_key uses memset to scrub a copy of the IDEA
key on the stack, which is removed by the optimizer.
Developer response. The bugs have been patched with
calls to wipememory.
u16 temp[IDEA_KEYLEN];
/* temp is allocated on stack to hold inverted key */
...
memcpy(dk, temp, sizeof(temp));
memset(temp, 0, sizeof(temp));
1 static void invert_key(u16 *ek, u16 dk[IDEA_KEYLEN]) {
2
3
4
5
6
7 }
Figure 7: A removed scrubbing operation in Libgcrypt
1.7.3.
5.9 Crypto++
Crypto++ is a C++ class library implementing sev-
eral cryptographic algorithms [8]. We tested version
5.6.4. Crypto++ deﬁnes SecureWipeBuffer, which re-
liably scrubs memory by using custom assembly if the
buffer contains values of type byte, word16, word32, or
word64; otherwise it uses the volatile data pointer tech-
nique. Despite the availability of SecureWipeBuffer,
we found one scrubbing operation dealing with sensi-
tive data that was removed because it used plain memset
rather than its own SecureWipeBuffer.
Sample case. The UncheckedSetKey function, shown
in Figure 8, sets the key for a CAST256 object.
UncheckedSetKey uses plain memset to scrub the user
key on the stack, which is removed by the optimizer.
Developer response. The bug was patched with a call to
SecureWipeBuffer.
unsigned int keylength, const NameValuePairs &) {
AssertValidKeyLength(keylength);
word32 kappa[8];
/* kappa is allocated on stack to hold user key */
...
memset(kappa, 0, sizeof(kappa));
1 void CAST256::Base::UncheckedSetKey(const byte *userKey,
2
3
4
5
6
7
8
9 }
Figure 8: A removed scrubbing operation in Crypto++
5.6.4.
1036    26th USENIX Security Symposium
USENIX Association
5.10 Bitcoin
Bitcoin is a cryptocurrency and payment system [5]. We
tested version 0.13.0 of the Bitcoin client. The project
deﬁnes memory_cleanse, which reliably scrubs mem-
ory by using OPENSSL_cleanse, described below. The
source code uses memory_cleanse consistently; we
found no removed scrubbing operations.
5.11 OpenSSH
OpenSSH is a popular implementation of the SSH pro-
tocol [19]. We tested version 7.3. OpenSSH deﬁnes its
own explicit_bzero, which is a reliable way of scrub-
bing memory: it uses BSD’s explicit_bzero if avail-
able, then memset_s if available. If neither are avail-
able, it uses the volatile function pointer technique to call
bzero. We found no removed scrubbing operations.
5.12 Discussion
Our case studies lead us to two observations. First, there
is no single accepted scrubbing function. Each project
mixes its own cocktail using existing scrubbing tech-
niques, and there is no consensus on which ones to use.
Unfortunately, as we discussed in Section 3, some of the
scrubbing techniques are ﬂawed or unreliable, making
scrubbing functions that rely on such techniques poten-
tially ineffective. To remedy this state of affairs, we de-
veloped a single memory scrubbing technique that com-
bines the best techniques into a single function, described
in Section 6.
Second, even when the project has reliable scrubbing
function, developers do not use their scrubbing func-
tion consistently. In four of the eleven projects we exam-
ined, we found cases where developers called memset in-
stead of their own scrubbing function. To address this, we
developed a scrubbing-safe dead-store elimination pass
that defensively compile bodies of code, as discussed in
Section 7.
6 Universal Scrubbing Function
As we saw in Section 3, there is no single memory
scrubbing technique that is both universal and guaran-
teed. In the next section, we propose a compiler-based
solution based on Clang, that protects scrubbing opera-
tions from dead-store elimination. In many cases, how-
ever, the developer can’t mandate a speciﬁc compiler
and must resort to imperfect techniques to protect scrub-
bing operations from the optimizer. To aid developers in
this position, we developed our own scrubbing function,
called secure_memzero, that combines the best effec-
tive scrubbing techniques in a simple implementation.
Speciﬁcally, our implementation supports:
O Platform-provided scrubbing functions
(SecureZeroMemory and memset_s) if available,
O The memory barrier technique if GCC or Clang
are used to compile the source, and
O The volatile data pointer technique and the
volatile function pointer technique.
Our secure_memzero function is implemented in a
single header ﬁle secure_memzero.h that can be in-