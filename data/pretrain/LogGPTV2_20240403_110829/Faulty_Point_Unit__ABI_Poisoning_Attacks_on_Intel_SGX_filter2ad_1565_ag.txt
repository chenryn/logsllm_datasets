tions may propagate into subtle corruptions of the expected result.
The exact impact of such attacks will always be application-specific,
however, and require careful analysis by the attacker depending on
the x87 or SSE processor features used in the victim application.
7 CONCLUSIONS AND LESSONS LEARNED
With the wide availability of SGX in mainstream Intel processors,
an emerging software ecosystem of enclave shielding runtimes
has developed in recent years to ease the adoption process and
enable developers to largely transparently enjoy SGX protection
guarantees. But despite the considerable advances and developer
efforts behind these runtimes, API and ABI-level issues continue
11
ACSAC 2020, December 7–11, 2020, Austin, USA
Alder et al.
interesting focus of future work could be to extend vulnerability as-
sessment tools such as TEEREX [8] that are predominantly focused
on API-level attack surfaces thus far, to ABI-level vulnerabilities.
Our analysis reveals that the high level of complexity and the large
amount of interconnected instructions in modern x86 architectures
make it particularly challenging to evaluate, investigate, and finally
mitigate ABI-level attacks. We urge the research community and
industry players to deepen their efforts of exploring TEE solutions
for alternative processor architectures, such as RISC-V, that are not
unnecessarily complex for historic reasons.
ACKNOWLEDGMENTS
This research was partially funded by the Engineering and Physical
Sciences Research Council (EPSRC) under grants EP/R012598/1,
EP/S030867/1, by the European Union’s Horizon 2020 research
and innovation programme under grant agreement No. 779391
(FutureTPM), by the Research Fund KU Leuven, and by a gift from
Intel Corporation. Fritz Alder and Jo Van Bulck are supported by a
grant of the Research Foundation – Flanders (FWO).
REFERENCES
[1] Fritz Alder, N Asokan, Arseny Kurnikov, Andrew Paverd, and Michael Steiner.
2019. S-faas: Trustworthy and accountable function-as-a-service using Intel SGX.
In Proceedings of the 2019 ACM SIGSAC Conference on Cloud Computing Security
Workshop. 185–199.
[2] Andrew Baumann, Marcus Peinado, and Galen Hunt. 2014. Shielding applications
from an untrusted cloud with Haven. In Proceedings of the 11th USENIX conference
on Operating Systems Design and Implementation. USENIX Association, 267–283.
[3] Andrea Biondo, Mauro Conti, Lucas Davi, Tommaso Frassetto, and Ahmad-Reza
Sadeghi. 2018. The Guard’s Dilemma: Efficient Code-Reuse Attacks Against Intel
SGX. In Proceedings of the 27th USENIX Security Symposium. 1213–1227.
[4] Mike Bursell. 2019. Trust No One, Run Everywhere—Introducing Enarx.
[5] S. Checkoway and H. Shacham. 2013. Iago attacks: Why the system call API is a
bad untrusted RPC interface. In International Conference on Architectural Support
for Programming Languages and Operating Systems (ASPLOS). 253–264.
[6] Guoxing Chen, Sanchuan Chen, Yuan Xiao, Yinqian Zhang, Zhiqiang Lin, and
Ten H Lai. 2019. SgxPectre Attacks: Stealing Intel Secrets from SGX Enclaves via
Speculative Execution. In 4th IEEE European Symposium on Security and Privacy
(Euro S&P). IEEE.
[7] Haogang Chen, Yandong Mao, Xi Wang, Dong Zhou, Nickolai Zeldovich, and
M. Frans Kaashoek. 2011. Linux kernel vulnerabilities: State-of-the-art defenses
and open problems. In Proceedings of the Second Asia-Pacific Workshop on Systems.
ACM, 5:1–5:5.
[8] Tobias Cloosters, Michael Rodler, and Lucas Davi. 2020. TeeRex: Discovery
and Exploitation of Memory Corruption Vulnerabilities in SGX Enclaves. In
Proceedings of the 29th USENIX Security Symposium. 841–858.
[9] Intel Corporation. 2017. Intel software guard extensions SDK for Linux OS: Devel-
oper reference.
Archive 2016, 086 (2016), 1–118.
[10] V. Costan and S. Devadas. 2016. Intel SGX explained. IACR Cryptology ePrint
[11] J. Edge. 2008. CVE-2008-1367: Kernel doesn’t clear DF for signal handlers.
https://bugzilla.redhat.com/show_bug.cgi?id=437312.
[12] A. Fog. 2018. Calling conventions for different C++ compilers and operating
systems. http://www.agner.org/optimize/calling_conventions.pdf.
[13] Fortanix. 2019. Fortanix Enclave Development Platform — Rust EDP. https:
[14] Free Software Foundation. 2020. GCC, the GNU Compiler Collection. https:
//edp.fortanix.com/.
//gcc.gnu.org/.
[15] Adrien Ghosn, James R Larus, and Edouard Bugnion. 2019. Secured routines:
language-based construction of trusted execution environments. In 2019 USENIX
Annual Technical Conference (USENIX ATC 19). 571–586.
[16] Google. 2019. Asylo: An open and flexible framework for enclave applications.
https://asylo.dev/.
[17] Jago Gyselinck, Jo Van Bulck, Frank Piessens, and Raoul Strackx. 2018. Off-limits:
Abusing legacy x86 memory segmentation to spy on enclaved execution. In
International Symposium on Engineering Secure Software and Systems (ESSoS ’18).
Springer, 44–60.
[18] IBM. [n.d.]. Data-in-use protection on IBM cloud. https://www.ibm.com/blogs/
bluemix/2017/12/data-use-protection-ibm-cloud-ibm-intel-fortanix-partner-
keep-enterprises-secure-core/.
en-us/cpp/.
[19] Intel Corporation. 2019. Intel Software Guard Extensions – Get Started with the
SDK. https://software.intel.com/en-us/sgx/sdk.
[20] Intel Corporation. 2020. Intel 64 and IA-32 architectures software developer’s man-
ual – Combined volumes. Reference no. 325462-062US.
[21] Andrej Karpathy. 2014. Convnetjs: Deep learning in your browser (2014). URL
http://cs.stanford.edu/people/karpathy/convnetjs (2014).
[22] Mustakimur Rahman Khandaker, Yueqiang Cheng, Zhi Wang, and Tao Wei.
2020. COIN Attacks: On Insecurity of Enclave Untrusted Interfaces in SGX. In
Proceedings of the Twenty-Fifth International Conference on Architectural Support
for Programming Languages and Operating Systems. 971–985.
[23] J. Lee, J. Jang, Y. Jang, N. Kwak, Y. Choi, C. Choi, T. Kim, M. Peinado, and
B. Byunghoon Kang. 2017. Hacking in darkness: Return-oriented programming
against secure enclaves. In Proceedings of the 26th USENIX Security Symposium.
523–539.
[24] S. Lee and T. Kim. 2017. Leaking uninitialized secure enclave memory via structure
padding. arXiv preprint arXiv:1710.09061 (2017).
[25] Sangho Lee, Ming-Wei Shih, Prasun Gera, Taesoo Kim, Hyesoon Kim, and Marcus
Peinado. 2017.
Inferring fine-grained control flow inside SGX enclaves with
branch shadowing. In Proceedings of the 26th USENIX Security Symposium. 557–
574.
[26] H.J. Lu, David L Kreitzer, Milind Girkar, and Zia Ansari. 2015. System V appli-
cation binary interface. Intel386 Architecture Processor Supplement, Version 1.1 (7
December 2015).
[27] A. Machiry, E. Gustafson, C. Spensky, C. Salls, N. Stephens, R. Wang, A. Bianchi,
Y. Ryn Choe, C. Kruegel, and G. Vigna. 2017. BOOMERANG: Exploiting the
semantic gap in trusted execution environments. In NDSS 2017.
[28] P. Maene, J. Götzfried, R. de Clercq, T. Müller, F. Freiling, and I. Verbauwhede. 2017.
Hardware-based trusted computing architectures for isolation and attestation.
IEEE Trans. Comput. 99 (2017).
[29] Microsoft. [n.d.]. https://azure.microsoft.com/en-us/blog/introducing-azure-
confidential-computing/.
[30] Microsoft. 2019. Open Enclave SDK. https://openenclave.io/sdk/.
[31] Microsoft Corporation. 2020. Microsoft Visual C++. https://docs.microsoft.com/
[32] Daniel Moghimi, Jo Van Bulck, Nadia Heninger, Frank Piessens, and Berk Sunar.
2020. CopyCat: Controlled Instruction-Level Attacks on Enclaves. In Proceedings
of the 29th USENIX Security Symposium. USENIX Association, 469–486.
[33] Kit Murdock, David Oswald, Flavio D. Garcia, Jo Van Bulck, Daniel Gruss, and
Frank Piessens. 2020. Plundervolt: Software-based fault injection attacks against
Intel SGX. In Proceedings of the 41th IEEE Symposium on Security and Privacy
(S&P’20).
[34] S. Pinto and N. Santos. 2019. Demystifying ARM TrustZone: A Comprehensive
Survey. ACM Computing Surveys (CSUR) 51, 6 (2019), 130.
[35] Christian Priebe, Divya Muthukumaran, Joshua Lind, Huanzhou Zhu, Shujie Cui,
Vasily A Sartakov, and Peter Pietzuch. 2019. SGX-LKL: Securing the Host OS
Interface for Trusted Execution. arXiv preprint arXiv:1908.11143 (2019).
[36] The Apache Software Foundation. 2020. Apache Teaclave (Incubating). https:
//teaclave.incubator.apache.org/.
[37] Florian Tramer, Fan Zhang, Huang Lin, Jean-Pierre Hubaux, Ari Juels, and Elaine
Shi. 2017. Sealed-glass proofs: Using transparent enclaves to prove and sell
knowledge. In 2nd IEEE European Symposium on Security and Privacy (Euro S&P).
IEEE.
[38] Chia-Che Tsai, Donald Porter, et al. 2017. Graphene-SGX library OS — A library
OS for Linux multi-process applications with Intel SGX support. https://github.
com/oscarlab/graphene.
[39] Chia-Che Tsai, Donald E Porter, and Mona Vij. 2017. Graphene-SGX: A practical
library OS for unmodified applications on SGX. In 2017 USENIX Annual Technical
Conference (USENIX ATC). USENIX Association.
[40] Sami Vaarala. 2020. Duktape embeddable Javascript engine. URL https://duktape.
[41] J. Van Bulck, M. Minkin, O. Weisse, D. Genkin, B. Kasikci, F. Piessens, M. Sil-
berstein, T. F. Wenisch, Y. Yarom, and R. Strackx. 2018. Foreshadow: Extracting
the keys to the Intel SGX kingdom with transient out-of-order execution. In
Proceedings of the 27th USENIX Security Symposium.
[42] Jo Van Bulck, Daniel Moghimi, Michael Schwarz, Moritz Lipp, Marina Minkin,
Daniel Genkin, Yarom Yuval, Berk Sunar, Daniel Gruss, and Frank Piessens.
2020. LVI: Hijacking transient execution through microarchitectural load value
injection. In 41st IEEE Symposium on Security and Privacy (S&P’20).
[43] Jo Van Bulck, David Oswald, Eduard Marin, Abdulla Aldoseri, Flavio D. Garcia,
and Frank Piessens. 2019. A tale of two worlds: Assessing the vulnerability
of enclave shielding runtimes. In Proceedings of the 26th ACM Conference on
Computer and Communications Security (CCS’19). ACM.
[44] Jo Van Bulck, Frank Piessens, and Raoul Strackx. 2017. SGX-Step: A practical
attack framework for precise enclave execution control. In 2nd Workshop on
System Software for Trusted Execution (SysTEX 2017). ACM, 4:1–4:6.
[45] N. van Ginkel, R. Strackx, and F. Piessens. 2017. Automatically generating
secure wrappers for SGX enclaves from separation logic specifications. In Asian
Symposium on Programming Languages and Systems. 105–123.
org/ (2020).
12
Faulty Point Unit: ABI Poisoning Attacks on Intel SGX
ACSAC 2020, December 7–11, 2020, Austin, USA
However, if desired, these algorithm could be likely re-written (al-
though in a less clear manner) using the binary representation of
the double operands instead.
Algorithm 2: Binary search algorithm to recover a secret
value based on overflow exceptions for operands > 1
Result: recovered_secret
// Maximum representable double
max_double = 1.7976931348623157e308;
low = 1;
high = max_double;
cnt = 0;
while cnt  1. It functions analogous to Algorithm 1 described
in Section 4. We note that for brevity, both Algorithm 1 and Algo-
rithm 2 use standard floating-point variables for secret recovery.
13
FaultyPointUnit:ABIPoisoningAttacksonIntelSGXACSAC2020,December7–11,2020,Austin,USAComputerandCommunicationsSecurity(CCS’19).ACM.[44]JoVanBulck,FrankPiessens,andRaoulStrackx.2017.SGX-Step:Apracticalattackframeworkforpreciseenclaveexecutioncontrol.In2ndWorkshoponSystemSoftwareforTrustedExecution(SysTEX2017).ACM,4:1–4:6.[45]N.vanGinkel,R.Strackx,andF.Piessens.2017.AutomaticallygeneratingsecurewrappersforSGXenclavesfromseparationlogicspecifications.InAsianSymposiumonProgrammingLanguagesandSystems.105–123.[46]HuiboWang,PeiWang,YuDing,MingshenSun,YimingJing,RanDuan,LongLi,YulongZhang,TaoWei,andZhiqiangLin.2019.TowardsMemorySafeEnclaveProgrammingwithRust-SGX.InProceedingsofthe2019ACMSIGSACConferenceonComputerandCommunicationsSecurity.2333–2350.[47]Wikipediacontributors.2020.Double-precisionfloating-pointformat—Wikipedia,TheFreeEncyclopedia.https://en.wikipedia.org/w/index.php?title=Double-precision_floating-point_format&oldid=960696001[Online;accessed16-June-2020].[48]YuanzhongXu,WeidongCui,andMarcusPeinado.2015.Controlled-channelattacks:Deterministicsidechannelsforuntrustedoperatingsystems.In2015IEEESymposiumonSecurityandPrivacy.IEEE,640–656.APROOF-OF-CONCEPTENCLAVECODEThisappendixliststheCsourcecode(Listing2)andcompiledas-sembly(Listing3)forthebenchmarktoyexampleenclavediscussedinSection3.2andTable1.TheassemblycodeinListing3wasout-putbygccv7.4.0underUbuntu18.04.1andtheIntelSGX-SDKv2.7.1usingthedefaultcompilationflags.1#include2#include34longdoubleecall_acosf(inta){5returnacosl(a);6}7longdoubleecall_mul(longdoublea,longdoubleb){8returna*b;9}Listing2:Codetoperformbasicfloating-pointoperationsinsidetheenclave.1:2push%rbp3mov%rsp,%rbp4sub$0x20,%rsp5mov%edi,-0x4(%rbp)6fildl-0x4(%rbp)7lea-0x10(%rsp),%rsp8fstpt(%rsp)9callq445010add$0x10,%rsp11fstpt-0x20(%rbp)12mov-0x20(%rbp),%rax13mov-0x18(%rbp),%edx14mov%rax,-0x20(%rbp)15mov%edx,-0x18(%rbp)16fldt-0x20(%rbp)17leaveq18retq1920:21push%rbp22mov%rsp,%rbp23fldt0x10(%rbp)24fldt0x20(%rbp)25fmulp%st,%st(1)26pop%rbp27retqListing3:CompiledassemblyofListing2.BSEARCHALGORITHMBASEDONOVERFLOWEXCEPTIONSThisappendixliststheadditionalAlgorithm2torecoversecretsforoperands>1.ItfunctionsanalogoustoAlgorithm1describedinSection4.Wenotethatforbrevity,bothAlgorithm1andAlgo-rithm2usestandardfloating-pointvariablesforsecretrecovery.However,ifdesired,thesealgorithmcouldbelikelyre-written(al-thoughinalessclearmanner)usingthebinaryrepresentationofthedoubleoperandsinstead.Algorithm2:Binarysearchalgorithmtorecoverasecretvaluebasedonoverflowexceptionsforoperands>1Result:recovered_secret//Maximumrepresentabledoublemax_double=1.7976931348623157e308;low=1;high=max_double;cnt=0;whilecnt2#include34longdoubleecall_acosf(inta){5returnacosl(a);6}7longdoubleecall_mul(longdoublea,longdoubleb){8returna*b;9}Listing2:Codetoperformbasicfloating-pointoperationsinsidetheenclave.1:2push%rbp3mov%rsp,%rbp4sub$0x20,%rsp5mov%edi,-0x4(%rbp)6fildl-0x4(%rbp)7lea-0x10(%rsp),%rsp8fstpt(%rsp)9callq445010add$0x10,%rsp11fstpt-0x20(%rbp)12mov-0x20(%rbp),%rax13mov-0x18(%rbp),%edx14mov%rax,-0x20(%rbp)15mov%edx,-0x18(%rbp)16fldt-0x20(%rbp)17leaveq18retq1920:21push%rbp22mov%rsp,%rbp23fldt0x10(%rbp)24fldt0x20(%rbp)25fmulp%st,%st(1)26pop%rbp27retqListing3:CompiledassemblyofListing2.BSEARCHALGORITHMBASEDONOVERFLOWEXCEPTIONSThisappendixliststheadditionalAlgorithm2torecoversecretsforoperands>1.ItfunctionsanalogoustoAlgorithm1describedinSection4.Wenotethatforbrevity,bothAlgorithm1andAlgo-rithm2usestandardfloating-pointvariablesforsecretrecovery.However,ifdesired,thesealgorithmcouldbelikelyre-written(al-thoughinalessclearmanner)usingthebinaryrepresentationofthedoubleoperandsinstead.Algorithm2:Binarysearchalgorithmtorecoverasecretvaluebasedonoverflowexceptionsforoperands>1Result:recovered_secret//Maximumrepresentabledoublemax_double=1.7976931348623157e308;low=1;high=max_double;cnt=0;whilecnt<100domid=low/2+high/2;secret_mul(mid);recovered_secret=max_double/mid;cnt++;ifoverflowexceptionraisedthen//continuesearchinlowerhalfhigh=mid;else//continuesearchinupperhalflow=mid;endend13