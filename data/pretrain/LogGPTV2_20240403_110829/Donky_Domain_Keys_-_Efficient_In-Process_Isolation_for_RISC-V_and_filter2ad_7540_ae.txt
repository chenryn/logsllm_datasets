### Verification of Host Data Structure Access

We have verified that any unauthorized access to host data structures results in the immediate termination of the application. Consequently, the library cannot execute return-oriented programming (ROP) attacks on the host, a capability that is otherwise possible from within Intel SGX enclaves [71].

### 7.3 Case Study 3: Library as a Vault

In this case study, we explore a different threat model where DonkyLib protects a library from the rest of the application by isolating it in a vault. We use Mbed TLS, a cryptographic library, with cryptographic keys as the assets to be protected. The threat model assumes a vulnerability in the host application that allows arbitrary memory reads, similar to the Heartbleed bug [93].

We isolate Mbed TLS in its own domain and expose all functions as dcalls. The host application can provide a custom memory allocator to Mbed TLS. By using DonkyLib's memory management functions, we ensure that all internal data structures and states of the library are protected with the same domain key. Additionally, all cryptographic secrets are allocated using DonkyLib, ensuring they are protected with the same key as the library. These secrets are shielded from the host application and can only be modified through the API, providing robust protection.

### Evaluation

To evaluate the performance impact of isolation using DonkyLib, we utilized Mbed TLS’s integrated benchmarking suite [5]. We added 95 lines of code (LoC) to the benchmark, which then uses the unmodified Mbed TLS library.

**Figure 9** shows the overhead when using cryptographic functions on a 1 KiB block of input data, the default choice. Internally, the benchmark runs for 1000 iterations for each cipher. We conducted this experiment 10 times, resulting in a total of 10,000 repetitions. We plotted the mean values and standard deviations across the 10 runs. As a baseline, we used the performance of the unprotected Mbed TLS library. We grouped similar cryptographic functions (e.g., same algorithm but different key sizes) by summing their respective runtimes. With a throughput of 96% (geomean) compared to the unprotected version, the performance impact of Donky is minimal. Even the fastest operation (Poly1305), which requires the most domain switches, has only a small throughput reduction of 15%.

To account for different block sizes, we compared Donky with process-based isolation by isolating Poly1305 using both techniques. We chose Poly1305 because it involves the most domain switches. Other algorithms would show significantly less overhead. For process isolation, we used a semaphore and shared memory for synchronization and pinned both processes to the same CPU core. **Figure 10** shows that at a block size of 16 bytes, process-based isolation runs 42–118x slower, while Donky is only 2.9–4.7x slower.

### 8. Discussion

#### 8.1 Limitations and Future Work

- **Static Limits**: Our prototype uses statically allocated arrays to store metadata, imposing an upper limit on the number of domains, memory regions, and keys. To overcome these limits, one could dynamically allocate Donky Monitor’s memory. Additionally, Donky is limited to 16 protection keys for x86 and 1024 for RISC-V. If an application requires more keys, one could schedule protection keys, as done by [64]. Alternatively, one could use weaker probabilistic protection by reusing protection keys. We prototyped a virtualization scheme that hands out protection keys marked for virtualization multiple times. Another approach is to increase the number of keys supported by the hardware, as mentioned in Section 5.
- **Availability**: DonkyLib is designed for security and, like related shielding technologies (e.g., Intel SGX), is susceptible to denial-of-service attacks. One could enhance DonkyLib with safety guarantees, such as limiting the number of protection keys a domain can allocate or rate-limiting API calls.
- **Thread-Local Storage (TLS)**: Previous work largely ignores the security of TLS across domain switches. While Intel SGX is an exception, we believe more research is needed. SGX switches the TLS at enclave entry and exit, and Donky could similarly swap the TLS pointer for dcalls. However, SGX enclaves are standalone libraries without external dependencies, and code is never shared across domains. It is unclear whether and how secure code reuse across domains is possible if the code uses TLS.

#### 8.2 Related Work

- **Software-based Approaches**: Software Fault Isolation (SFI) schemes [24, 26, 53, 72, 86, 95, 98] use Control Flow Integrity (CFI) and binary rewriting to confine sandboxes to a restricted memory area. Compared to SFI, our context-switching overheads are higher, but the overhead within a domain is lower. Furthermore, Donky’s threat model is stronger, as it can isolate unmodified code without enforcing CFI. CFI typically requires W⊕X, making it difficult to support self-modifying code, a clear advantage for Donky. Some CFI schemes offer only probabilistic protection [42].
- **NaClJIT [3]**: Adds SFI to a JIT compiler with a runtime overhead of 50 to 60% for V8. Other works [7, 10, 35, 50, 74] rely on substantial kernel modifications to provide isolation between domains, such as separate address spaces for threads [35, 87].
- **NaCl [95] and Dune [7]**: Provide similar software-based system call filtering as Donky. However, unlike NaCl, Donky enforces these filters even if the application breaks out of its SFI/CFI sandbox. Compared to Dune, Donky addresses multiple in-process compartments not only on a thread boundary. Donky’s syscalls are also significantly faster than Dune’s.
- **Hardware Protection Key Approaches**: ERIM [82] uses Memory Protection Keys (MPK) for in-process isolation. Unlike Donky, they require binary scanning and rewriting, alongside W⊕X. While they defer setting up private stacks to the developer, DonkyLib provides them by default. ERIM’s binary rewriting could be integrated into a JIT compiler, but it may lead to crashes if the compiler emits unsafe WRPKRU instructions. The performance and implementation costs to adapt JIT compilers accordingly are unclear. Koning et al. [41] survey different hardware isolation mechanisms such as Intel MPK and isolate safe regions (e.g., shadow stacks) atop them. libmpk [64] schedules protection keys for Intel MPK via expensive Page Table Entry (PTE) updates if more than 16 keys are used.
- **ARMLock [99]**: Implements an in-process isolation framework using ARM’s Memory Domains [4]. Binary scanning is not required on ARM, as their protection key policy register cannot be written in userspace. ARMLock implements domains in the kernel, increasing the attack surface and likely impeding wide adoption. ARM removed Memory Domains on 64-bit architectures. In contrast, Donky manages domain metadata and domain transitions entirely in userspace, allowing for faster inter-domain calls.
- **Shreds [15]**: Uses ARM’s Memory Domains to isolate so-called shreds from the rest of an application. They do not support the sandboxing scenario, require recompilation of in-shred code, and enforce a coarse-grained CFI policy. Different shreds cannot easily share data. Protection keys are lazily switched during context switches using an expensive page-table walk. Apart from [41, 64, 82], others have not open-sourced their code, hindering further research. We open-source both DonkyLib and our RISC-V hardware.
- **Trusted Execution Environments (TEEs)**: Intel SGX [20], ARM TrustZone [60], Sancus [62], and proposed RISC-V extensions [23, 43] protect against a malicious operating system. However, they require extensive hardware modifications, and communication between domains is typically slow. Intel SGX runs code in enclaves, which allow an asymmetric trust model [90], where an enclave has access to the entire process. They also have a higher performance overhead [91]. Recent work has used MPK to protect the host application from the enclave [90] or to provide additional privilege separation within an enclave [55].
- **Compartmentalization**: Decomposing software to run in isolated compartments is an orthogonal problem. Previous work aids in finding suitable isolation boundaries, but splitting up existing software remains challenging [11, 34, 51, 83, 84]. Choosing an isolation boundary is a trade-off between fine isolation granularity and minimizing switching overhead, often making it difficult to fully automate. RLBox [59] identifies compartmentalization boundaries in Firefox and designs secure interfaces. Furthermore, they automatically sanitize pointers across compartments to prevent confused deputy attacks. In contrast, Donky provides a strong, generic isolation framework that RLBox could use to enforce their compartmentalization.

### 9. Conclusion

In this paper, we introduced Donky, a hardware-software co-design solution for secure and efficient in-process isolation. It provides strong isolation guarantees with minimal performance impact. Donky is fully backward-compatible with existing software libraries and dynamically generated code (e.g., JIT). It relies on a small hardware extension of memory protection keys to back the security guarantees of our software framework, DonkyLib. We presented a fully working implementation on a RISC-V processor and showed that Donky can be implemented on top of commodity x86 processors with a minimal hardware extension. Our trusted monitor runs entirely in userspace, minimizing switching overhead and kernel complexity. DonkyLib works on both x86 and RISC-V CPUs and provides pure userspace domains atop protection keys through an intuitive API.

Donky combines the high performance of MPK with the security of kernel-based schemes. Donky cross-domain switches are 16–116x faster than process context switches and have only 4% overhead compared to fully unprotected mbedTLS cryptographic operations. We support self-modifying code, just-in-time compilation, and in-process third-party binary sandboxing without scanning or rewriting instructions. This addresses recent challenges in JavaScript sandboxing, ranging from browsers and desktop applications to the cloud.

### Acknowledgments

We thank the anonymous reviewers, the artifact evaluators, and especially our shepherd, Nathan Dautenhahn, for their valuable suggestions and comments, which helped improve the paper. This work has been supported by the Austrian Research Promotion Agency (FFG) via the competence center Know-Center (grant number 844595), funded in the context of COMET – Competence Centers for Excellent Technologies by BMVIT, BMWFW, and Styria, and via the project ESPRESSO, funded by the province of Styria and the Business Promotion Agencies of Styria and Carinthia. This project has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement No 681402). Additional funding was provided by generous gifts from Intel and Cloudflare. Any opinions, findings, and conclusions or recommendations expressed in this paper are those of the authors and do not necessarily reflect the views of the funding parties.

### References

[References are listed as provided, with no changes made.]