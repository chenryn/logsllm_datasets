veriﬁed that any such access to host data structures leads to
an immediate abortion of the application. Hence, the library
cannot mount return-oriented programming attacks on the
host, as this can be done from SGX enclaves [71], for example.
7.3 Case Study 3: Library as a Vault
In this case study, we show a different threat model, where
DonkyLib protects a library from the rest of the application in
a vault. We use Mbed TLS, a cryptographic library, with cryp-
tographic keys as the assets to protect. In the threat model, we
assume a vulnerability in the host application, which allows
arbitrary memory reads, similar to the Heartbleed bug [93].
We isolate Mbed TLS in its own domain and expose all
functions as dcalls. The host application can provide a custom
1688    29th USENIX Security Symposium
USENIX Association
KrakenSunspiderOctane0.91.01.1Xeon 8275CLXeon 42083DESAESARC4BlowfishCamelliaChaCha20DHE-2048HMAC_DRBGPoly1305RSA-2048SHA-256SHA-512geomean0.80.91.0Xeon 8275CLXeon 4208RISC-V1632641282565121K2K4K8K16K32K64K128K256K512K100101102Xeon 8275CLXeon 4208RISC-Vmemory allocator to Mbed TLS. By providing the memory
management functions from DonkyLib, we ensure that all
internal data structures and states of the library are protected
with the same domain key. Furthermore, all cryptographic
secrets are allocated using DonkyLib to protect them with the
same key as the library. Cryptographic secrets are protected
from the host application and are only modiﬁed through the
API, resulting in a strong protection of these assets.
Evaluation. To evaluate the performance impact of the iso-
lation using DonkyLib, we use Mbed TLS’s integrated bench-
marking suite [5]. We added 95 LoC to the benchmark, which
then uses the unmodiﬁed Mbed TLS library.
Figure 9 shows the overhead when using the cryptographic
functions on a 1 KiB block of input data, which is the default
choice. Internally, the benchmark runs for 1000 iterations for
each cipher. We ran this experiment 10 times, resulting in a to-
tal number of 10 000 repetitions, and plotted their mean values
as well as the standard deviations across the 10 runs. As a base-
line, we use the performance of the unprotected Mbed TLS
library. We group similar cryptographic functions (e.g., same
algorithm but different key size) by summing up their respec-
tive runtimes. With a throughput of 96 % (geomean) com-
pared to the unprotected version, the performance impact of
Donky is minimal. Even the fastest operation (Poly1305), i.e.,
the function requiring the most domain switches, has only a
small throughput reduction of 15 %.
To account for different block sizes, we compared Donky
with process-based isolation by isolating Poly1305 using
both techniques. We chose Poly1305 as it does most domain
switches. Other algorithms would show signiﬁcantly less over-
head. For process isolation, we used a semaphore and shared
memory for synchronization and pinned both processes to the
same CPU core. As shown in Figure 10, at a block size of
16 Bytes, process-based isolation runs 42–118x slower, while
Donky is only 2.9–4.7x slower.
8 Discussion
In this section, we discuss limitations as well as future work
and elaborate on related work.
8.1 Limitations and Future Work
Static Limits. Our prototype uses statically allocated ar-
rays to store its metadata, which poses an upper limit on the
number of domains, memory regions, and keys. To overcome
these limits, one could dynamically allocate Donky Monitor’s
memory. Moreover, Donky is limited to 16 protection keys
for x86 and 1024 for RISC-V. If an application needs more
keys, one could schedule protection keys, as done by [64]. Al-
ternatively, one could resort to weaker probabilistic protection
by reusing protection keys. We prototyped a virtualization
scheme that hands out protection keys marked for virtualiza-
tion multiple times. One could also increase the number of
keys supported by the hardware, as mentioned in Section 5.
Availability. DonkyLib is designed for security and, in-line
with related shielding technologies, e.g., Intel SGX, denial-of-
service attacks are possible. One could retroﬁt DonkyLib with
safety guarantees, e.g., by limiting the number of protection
keys a domain can allocate, or rate-limiting the API calls.
Thread-Local Storage. Previous work largely ignores the
security of the TLS across domain switches. While Intel SGX
is a notable exception, we believe more research is needed.
SGX switches the TLS at enclave entry and exit, and Donky
could similarly swap the TLS pointer for dcalls.6 However,
SGX enclaves are built as standalone libraries without exter-
nal dependencies, and code is never shared across domains. It
is unclear whether and how secure code reuse across domains
is possible, should this code make use of TLS.
8.2 Related Work
Software-based Approaches. Software Fault Isolation
(SFI) schemes [24, 26, 53, 72, 86, 95, 98] use CFI and binary
rewriting to conﬁne sandboxes to a restricted memory area.
In comparison to SFI, our context-switching overheads are
higher, but the overhead within a domain is lower. Further-
more, Donky’s threat model is stronger. We can isolate un-
modiﬁed code without enforcing the control-ﬂow integrity of
isolated code. Because CFI usually requires W⊕X, it cannot
easily support self-modifying code. This is a clear advantage
for Donky. Also, some CFI schemes only offer probabilistic
protection [42].
NaClJIT [3] adds SFI to a JIT compiler with a runtime
overhead of 50 to 60 % for V8. Other works [7, 10, 35, 50, 74]
rely on substantial kernel modiﬁcations to provide isolation
between domains, such as, e.g., separate address spaces for
threads [35, 87].
NaCl [95] and Dune [7] can provide similar software-based
system call ﬁltering as Donky. However, in contrast to NaCl,
Donky provides a mechanism to enforce these ﬁlters even
when the application manages to break out of its SFI/CFI
sandbox. Compared to Dune, Donky addresses multiple in-
process compartments not only on a thread boundary. Also,
Donky’s syscalls are signiﬁcantly faster than Dune’s.
Hardware Protection Key Approaches. ERIM [82] uses
MPK for in-process isolation. Unlike Donky, they demand
binary scanning and rewriting, alongside W⊕X. While they
defer setting up private stacks to the developer, DonkyLib
provides them by default. ERIM’s binary rewriting could be
integrated into a JIT compiler. However, it may lead to crashes
if the compiler accidentally emits unsafe WRPKRU instructions.
Also, the performance and implementation costs to adapt JIT
compilers accordingly is unclear. However, NaClJIT [3] could
serve as a starting point for further research. Koning et al. [41]
6E.g., Donky Monitor could update the RISC-V tp register, which is
otherwise protected by the monitor bit in DKRU.
USENIX Association
29th USENIX Security Symposium    1689
survey different hardware isolation mechanisms such as Intel
MPK and isolate safe regions (e.g., shadow stacks) atop of
them. libmpk [64] schedules protection keys for Intel MPK
via expensive PTE updates if more than 16 keys are used.
ARMLock [99] implements an in-process isolation frame-
work using ARM’s Memory Domains [4]. Binary scanning is
not required on ARM, as their protection key policy register
cannot be written in userspace. ARMLock implements do-
mains in the kernel, which increases the attack surfaces and
likely impedes wide adoption. Also, ARM removed Memory
Domains on 64-bit architectures. In contrast, Donky manages
domain metadata and domain transitions entirely in userspace,
which allows for faster inter-domain calls.
Shreds [15] uses ARM’s Memory Domains to isolate so-
called shreds from the rest of an application. They do not
support the sandboxing scenario, demand recompilation of in-
shred code, and a coarse-grained CFI policy. Different shreds
cannot easily share data. Protection keys are lazily switched
during context switches using an expensive page-table walk.
Apart from [41, 64, 82], others did not open-source their
code, hindering further research. We open-source both
DonkyLib and our RISC-V hardware.
Trusted Execution Environments.
Intel SGX [20], ARM
TrustZone [60], Sancus [62], and proposed RISC-V exten-
sions [23, 43] protect against a malicious operating system.
However, they require extensive hardware modiﬁcations, and
communication between domains is typically slow.
Intel SGX [20] runs code in so-called enclaves, which only
allow an asymmetric trust model [90], in which an enclave
has access to the entire process. Furthermore, they have a
higher performance overhead [91]. Recent work used MPK
to also protect the host application from the enclave [90] or to
provide additional privilege separation within an enclave [55].
Compartmentalization. Decomposing software to run in
isolated compartments is an orthogonal problem. Previous
work aids in ﬁnding suitable isolation boundaries, but splitting
up existing software is still a hard problem [11, 34, 51, 83, 84].
Choosing an isolation boundary is always a trade-off between
ﬁne isolation granularity and minimizing switching overhead
and, hence, it often cannot be fully automated. RLBox [59]
identiﬁes such compartmentalization boundaries in Firefox
and designs secure interfaces. Furthermore, they automati-
cally sanitize pointers across compartments to prevent con-
fused deputy attacks. In contrast, Donky provides a strong,
generic isolation framework RLBox could use to enforce their
compartmentalization.
9 Conclusion
In this paper, we proposed Donky, a hardware-software co-
design solution for secure and efﬁcient in-process isolation.
It provides strong isolation guarantees with a negligible per-
formance impact. It is fully backward compatible with exist-
ing software libraries and dynamically generated code (e.g.,
JIT). Donky relies on a small hardware extension of mem-
ory protection keys to back the security guarantees of our
software framework called DonkyLib. We presented a fully
working implementation on a RISC-V processor and showed
that Donky can be implemented on top of commodity x86
processors with a minimal hardware extension. Our trusted
monitor runs entirely in userspace, thus minimizing switch-
ing overhead as well as kernel complexity. DonkyLib works
on both x86 and RISC-V CPUs and provides pure userspace
domains atop protection keys through an intuitive API.
Donky combines the high performance of MPK with the se-
curity of kernel-based schemes. Donky cross-domain switches
are 16–116x faster than process context switches and have
only 4 % overhead compared to fully unprotected mbedTLS
cryptographic operations. We support self-modifying code,
just-in-time compilation, and in-process third-party binary
sandboxing without scanning or rewriting instructions. This
addresses recent challenges in JavaScript sandboxing, ranging
from browsers and desktop applications to the cloud.
Acknowledgments
We thank the anonymous reviewers, the artifact evaluators,
and especially our shepherd, Nathan Dautenhahn, for their
valuable suggestions and comments, which helped in improv-
ing the paper. This work has been supported by the Austrian
Research Promotion Agency (FFG) via the competence cen-
ter Know-Center (grant number 844595), which is funded in
the context of COMET – Competence Centers for Excellent
Technologies by BMVIT, BMWFW, and Styria, and via the
project ESPRESSO, which is funded by the province of Styria
and the Business Promotion Agencies of Styria and Carinthia.
This project has received funding from the European Re-
search Council (ERC) under the European Union’s Horizon
2020 research and innovation programme (grant agreement
No 681402). Additional funding was provided by generous
gifts from Intel and from Cloudﬂare. Any opinions, ﬁndings,
and conclusions or recommendations expressed in this paper
are those of the authors and do not necessarily reﬂect the
views of the funding parties.
References
[1] Ariane RISC-V CPU. https://github.com/pulp-
platform/ariane, 2019.
[2] A Collection of Chrome Sandbox Escape POCs/Exploits
for learning. https://github.com/allpaca/chrome-
sbx-db, 2019.
[3] Jason Ansel, Petr Marchenko, Úlfar Erlingsson, Elijah
Taylor, Brad Chen, Derek L. Schuff, David Sehr, Cliff
Bifﬂe, and Bennet Yee. Language-independent sandbox-
1690    29th USENIX Security Symposium
USENIX Association
ing of just-in-time compilation and self-modifying code.
In PLDI, pages 355–366, 2011.
[4] ARM. ARM Developer Suite Developer Guide. http:
//infocenter.arm.com/help/index.jsp?topic=
/com.arm.doc.dui0056d/BABBJAED.html, 2001.
[5] ARM.
Mbed TLS Benchmark.
https:
//github.com/ARMmbed/mbedtls/blob/master/
programs/test/benchmark.c, 2019.
[6] ARM. SSL Library Mbed TLS / PolarSSL. https:
//tls.mbed.org/, 2019.
[7] Adam Belay, Andrea Bittau, Ali José Mashtizadeh,
David Terei, David Mazières, and Christos Kozyrakis.
Dune: Safe User-level Access to Privileged CPU Fea-
tures. In OSDI, pages 335–348, 2012.
[8] Daniel J. Bernstein. Cache-Timing Attacks on AES,
2004.
[9] Andrea Biondo, Mauro Conti, Lucas Davi, Tommaso
Frassetto, and Ahmad-Reza Sadeghi. The Guard’s
Dilemma: Efﬁcient Code-Reuse Attacks Against Intel
SGX. In USENIX Security Symposium, 2018.
[10] Andrea Bittau, Petr Marchenko, Mark Handley, and Brad
Karp. Wedge: Splitting Applications into Reduced-
Privilege Compartments. In NSDI, 2008.
[11] David Brumley and Dawn Xiaodong Song. Privtrans:
Automatically Partitioning Programs for Privilege Sepa-
ration. In USENIX Security Symposium, 2004.
[12] Jo Van Bulck, David Oswald, Eduard Marin, Abdulla
Aldoseri, Flavio D. Garcia, and Frank Piessens. A Tale
of Two Worlds: Assessing the Vulnerability of Enclave
Shielding Runtimes. In CCS, 2019.
[13] Claudio Canella, Jo Van Bulck, Michael Schwarz,
Moritz Lipp, Benjamin von Berg, Philipp Ortner, Frank
Piessens, Dmitry Evtyushkin, and Daniel Gruss. A Sys-
tematic Evaluation of Transient Execution Attacks and
Defenses. In USENIX Security Symposium, 2019.
[14] Miguel Castro, Manuel Costa, Jean-Philippe Martin,
Marcus Peinado, Periklis Akritidis, Austin Donnelly,
Paul Barham, and Richard Black. Fast byte-granularity
software fault isolation. In SOSP, 2009.
[15] Yaohui Chen, Sebassujeen Reymondjohnson, Zhichuang
Sun, and Long Lu. Shreds: Fine-Grained Execution
Units with Private Memory. In S&P, 2016.
[16] Cloudﬂare.
Introducing
service workers
cloudﬂare workers:
edge.
at
javascript
Run
https://blog.cloudflare.com/introducing-
cloudflare-workers/, 2017.
the
[17] Bart Coppens, Ingrid Verbauwhede, Koen De Bosschere,
and Bjorn De Sutter. Practical Mitigations for Timing-
Based Side-Channel Attacks on Modern x86 Processors.
In S&P, 2009.
[18] Jonathan Corbet. Deferring seccomp decisions to user
space. https://lwn.net/Articles/756233/, 2018.
[19] Intel Corporation.
Intel 64 and IA-32 Architectures
Software Developers Manual, October 2019.
[20] Intel Corporation.
Intel Software Guard Extensions
(Intel SGX). https://software.intel.com/en-us/
sgx.
[21] Intel Corporation. Intel Software Guard Extensions (In-
tel SGX) SDK. https://software.intel.com/sgx-
sdk.
[22] Intel Corporation.
Intel IA-64 architecture software
developer’s manual, revision 1.1. 2000.
[23] Victor Costan, Ilia A. Lebedev, and Srinivas Devadas.
Sanctum: Minimal Hardware Extensions for Strong Soft-
ware Isolation. In USENIX Security Symposium, 2016.
[24] Liang Deng, Qingkai Zeng, and Yao Liu. ISboxing: An
Instruction Substitution Based Data Sandboxing for x86
Untrusted Libraries. In SEC, volume 455 of IFIP Ad-
vances in Information and Communication Technology,
2015.
[25] Will Drewry.
prctl/seccomp_ﬁlter.
475049/, 2012.
[RFC,PATCH 2/2] Documentation:
https://lwn.net/Articles/
[26] Bryan Ford and Russ Cox. Vx32: Lightweight User-
level Sandboxing on the x86. In USENIX ATC, 2008.
[27] RISC-V Foundation. The RISC-V Instruction Set
Manual, Volume II: Privileged Architecture, version
1.10.
https://content.riscv.org/wp-content/
uploads/2017/05/riscv-privileged-v1.10.pdf,
2017.
[28] RISC-V Foundation. The RISC-V Instruction Set
Manual, Volume I: User-Level ISA, document version
20191213. https://riscv.org/specifications/,
2019.
[29] RISC-V Foundation. The RISC-V Instruction Set