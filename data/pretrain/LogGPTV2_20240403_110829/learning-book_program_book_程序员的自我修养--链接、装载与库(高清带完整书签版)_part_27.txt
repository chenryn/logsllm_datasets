·-fno-builtinGCC编译器提供了很多内置函数（Built-inFunction）.它会把一些常用的
C库函数替换成编译器的内置函数，以达到优化的功能。比如GCC会将只有字符市参
数的printf函数替换成puts，以节省格式解析的时间。exitO函数也是GCC的内置参数
之一，所以我们要使用-fno-builtin参数来关闭GCC内置函数功能。
·-static这个参数表示Id将使用静态链接的方式来链接程序，而不是使用默认的动态
链接的方式。
·-e nomain表示该程序的入口函数为nomain，还记得ELF文件头Elf32_Ehdr的e_entry
成员吗？这个参数就是将ELF文件头的e_entry成员赋值成nomain函数的地址。
·-oTinyHelloWorld表示指定输出可执行文件名为TinyHelloWorld。
我们得到了一个924字节（依赖于系统环境）的ELF可执行文件，运行它以后能够正
这个文件时，会发现它有4个段：lext、.rodata、.data和.comment。通过前面的介绍我们可
以猜到：
程序员的自我修养一链接、装载与库
---
## Page 150
4.6链接过程控制
127
·ltexi肯定保存的是程序的指令，它是只读的。
rodata 保存的是字符串“Hello World!n”，它也是只读的。
·.data保存的是str全局变量，看上去它是可读写的，但我们并没有在程序中改写该变量，
所以实际上它也是只读的。
·.comment保存的是编译器和系统版本信息，这些信息也是只读的。由于.comment里面
保存的数据并不关键，对于程序的运行没有作用，所以可以将其丢弃。
签于这些段的属性如此相似，原则上讲，我们可以把它们合并到一个段里面，该段的属
性是可执行、可读的，包含程序的数据和指令，为了达到这个目的，我们必须使用d链接
脚本米控制链接过程。
4.6.3使用ld链接脚本
如果把整个链接过程比作一台计算机，那么Id链接器就是计算机的CPU，所有的目标
文件、库文件就是输入，链接结果输出的可执行文件就是输出，而链接控制脚本正是这台计
算机的“程序”，它控制CPU的运行，以“程序”要求的方式将输入加工成所须要的输出结
果。链接控制脚本“程序”使用一种特殊的语言写成，即ld的链接脚本语言，这种语言并
不复杂，只有为数不多的几种操作。
无论是输出文件还是输入文件，它们的主要的数据就是文件中的各种段，我们把输入文
件中的段称为输入段（Input Sections），输出文件中的段称为输出段（Output Sections）。
简单来讲，控制链接过程无非是控制输入段如何变成输出段，比如哪些输入段要合并一个输
出段，哪些输入段要丢弃：指定输出段的名字、装载地址、属性，等等。我们先来看看
TinyHelloWorld的链接脚本TinyHelloWorlid.lds（一般链接脚本名都以Ids作为扩展名ld
script)，有个感性的认识：
ENTRY (nonain)
SECTIONS
:= 0x08048000 + SIZEOF_HEADERS;
((esepo2*) 。(eep*) 。(axa′) 。):axoAu
/DISCARD/ : ( *(.comment) )
F
这是一个非常简单的链接脚本，第一行的ENTRY（nomain）指定了程序的入口为nomain0)
函数：后面的SECTIONS命令一般是链接脚本的主体，这个命令指定了各种输入段到输出段
的变换，SECTIONS后面紧跟着的一对大括号里面包含了SECTIONS变换规则，其中有三条
语句，每条语句一行。第一条是赋值语句，后面两条是段转换规则，它们的含义分别如下：
程序员的自我修养一链接、装载与库
---
## Page 151
128
第4章静态链接
，=Ox08048000+SIZEOF_HEADERS第一条赋值语句的意思是将当前虚拟地址设
置成0x08048000+SIZEOF_HEADERS，SIZEOF_HEADERS 为输出文件的文件头大
小。“.”表示当前虚拟地址，因为这条语句后面紧跟着输出段“tinytext”，所以“tinytex”
段的起始虚拟地址即为0x08048000+SIZEOF_HEADERS.它将当前虚拟地址设置成一
个比较巧妙的值，以便于装载时页映射更为方便。具体请参考本书第2部分关于装载
的章节。
·tinytext：{“（.text)“（.data）“（.rodata)）第二条是个段转换规则，它的意思即为所有输
·/DISCARD/：（“（.comment)）第三条规则为：将所有输入文件中的名字为“.comment”
的段丢弃，不保存到输出文件中。
通过上述两条转换规则，我们就达到了TinyHelloWorld程序的第三个要求：最终输出的
可执行文件只有一个叫“tinytext”的段。我们通过下面的命令行来编译TinyHeloWorld，并
且启用该链接控制脚本：
$ gcc -c -fno-builtin TinyHelloWorld.c
$ 1d -8tatic -7 TinyHelloWorld.1de -o TinyHelloWorld rinyelloWorld.o
我们得到了一个588字节的 ELF可执行文件：TinyHelloWorld，并且执行这个程序能够
在终端上正确显示“Hello World!"。如果你使用objdump查看TinyHelloWorld 的段，你会很
高兴地发现，我们达到了目的：整个程序只有一个段“tinytext”。但是兴奋之余你可能又想
用readelf工具查看一下，发现程序除了tinytext 之外居然还有其他3个段：shstrtab、symtab
和.stab。这3个段我们在前面已经介绍过了，它们分别是段名字符串表、符号表和字符串
表。在默认情况下，d链接器在产生可执行文件时会产生这3个段。对于可执行文件来说，
符号表和字符串表是可选的，但是段名字符串表用户保存段名，所以它是必不可少的。
你可以通过Id的-s参数禁止链接器产生符号表，或者使用strip命令来去除程序中的符
号表，去掉符号表后的TinyHelloWorld只有340个字节，但它仍然是一个有效的 ELF可执
行文件，能够正确执行并输出结果。
有人专门研究了如何得到一个最小的ELF可执行文件，最后成果是最小的ELF可执行
文件为45个字节。这个程序的功能是以42为进程退出码正常退出进程，没有任何输入和输
出。上面的TinyHelloWorld 也是以这个特殊的值 42作为退出码。
的关于生命、宇宙及万物的终极答案是42。
4.6.4ld链接脚本语法简介
ld链接器的链接脚本语法继承与AT&T链接器命令语言的语法，风格有点像C语言，
程序员的自找修养一链接、装载与库
---
## Page 152
4.6链接过程控制
129
它本身并不复杂。链接脚本由一系列语句组成，语句分两种，一种是命令语句，另外一种是
赋值语句。我们前面的链接脚本里面的ENTRY（nomain）就是命令语句：面.=0x08480000+
SIZEOF_HEADERS则是一个经典的赋值语句。之所以说链接脚本语法像C语言，主要有如
下几点相似之处。
语句之间使用分号“：”作为分割符原则上讲语句之间都要以“；“作为分割符，但是
表达式与运算符脚本语言的语句中可以使用C语言类似的表达式和运算操作符，比
如+、-、*、/、+=、-=、*=等，甚至包括&、1、>>、
#include *bfd.h*
int main()
const char** t = bfd_target_1ist (1;
Mhile(*c)(
printf(*$s\n*, *t);
++1
编译运行：
$gcc -o target target.c -lbfd
$./target
a,out-1386-11nux
elf32-1386
elf32-1ittle
efi-app-ia32
elf64-x8664
e1f32-big
efi-app-x86_64
e1f64-big
elf64-1ittle
srec
symbolsrec
tekhex
binary
ihex
trad-core
关于BFD的具体资料可以参考binutils 网站的文格：http:/sources.redhat.com/binutils/。
4.8
本章小结
本章我们首先介绍了静态链接中的第一个步骤，即目标文件在被链接成最终可执行文件
时，输入目标文件中的各个段是如何被合并到输出文件中的，链接器如何为它们分配在输出
文件中的空间和地址。一且输入段的最终地址被确定，接下来就可以进行符号的解析与重定
位，链接器会把各个输入目标文件中对于外部符号的引用进行解析，把每个段中须重定位的
指令和数据进行“修补”，使它们都指向正确的位置。
在本章里，我们还对几个静态链接中的问题进行了分析，比如为什么未初始化的全局/
静态变量要使用COMMON块、C++会对链接器和目标文件有什么样的要求、如何使用脚本