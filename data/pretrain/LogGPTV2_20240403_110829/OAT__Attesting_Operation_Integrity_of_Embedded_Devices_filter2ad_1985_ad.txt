### Pointers and Control-Flow Attestation

In the control-flow part of OEI (Open Execution Integrity) attestation, pointers are a key focus. OAT (Open Attestation Technology) relies on programmers to annotate semantically critical variables because the identification of such variables is subjective and specific to the program's semantics.

#### Critical Variables
The initial set of critical variables consists of:
- **Control-dependent variables**: Automatically detected by the system.
- **Semantically critical variables**: Annotated by programmers.

Our compiler then expands this set to include direct and indirect pointers to these variables and their dependencies. Pointers to a critical variable allow for indirect definition or use of the variable, making them special critical variables, referred to as **critical pointers**. The compiler iteratively identifies these critical pointers using a global points-to map generated by the standard Anderson pointer analysis.

#### Dependencies
Dependencies of a critical variable \( V \) are the variables that may influence the value of \( V \). Verifying the integrity of \( V \) implies verifying the integrity of both \( V \) and its dependencies. Our compiler finds all dependencies by constructing the program dependence graph and performing a backward traversal along data dependence edges. Newly discovered variables during the traversal are added to the critical variable set. The iterative search for dependencies stops when the set reaches a fixpoint. This automatic dependency discovery simplifies critical variable annotation: programmers only need to annotate one variable for each piece of critical data.

### Value-Based Define-Use Check

The OAT compiler instruments all define- and use-sites for each variable in the expanded critical variable set. During runtime, the instrumentation at each define-site captures the identity of the critical variable (a compiler-generated label) and the value to be assigned to the variable. This information is sent to the measurement engine in the Secure World via trampolines. Similarly, the use-site instrumentation captures the variable identity and the current value of the variable and sends them to the measurement engine.

For array-typed critical variables, each array element access is instrumented. The OAT compiler identifies and instruments every memory access whose target address is calculated as an offset relative to a critical variable. This design uniformly covers multi-dimensional and nested arrays, as array element access is based on a memory address calculated from the array’s name or base address. From the measurement engine’s perspective, it only sees critical variables or critical array elements identified by their addresses, rather than entire array objects. The integrity of each element is checked independently during runtime.

The measurement engine maintains a hashmap that stores pairs of `VariableID` and `Value`. `VariableID` is the address of a variable or an array element. The measurement engine updates the hashmap at each instrumented define-site and checks the value at each instrumented use-site. Regardless of whether a variable is on the stack (local) or the heap (global), its define-use sites should always have matching values. A value mismatch indicates a corrupted critical variable. The measurement engine finally sends the CVI (Critical Variable Integrity) checking result along with the control-flow measurements in a signed blob to the remote verifier.

### Pointer-Based Access to Critical Variables

Consider an example: `*(P+n) = x`, where `P` is the base address of a critical array `A` and `n` is the dynamic index. This is a legitimate critical variable define-site. If, due to a program bug, the dereference `*(P+n)` goes out of bounds of `A` and reaches another critical variable `B`, the measurement engine would mistakenly update the value of `B` to `x` in its hashmap.

To solve this issue, we enforce dynamic bounds checking on critical pointers. When a critical pointer is dereferenced, the measurement engine checks if the pointer dereference breaches the bounds of the current pointee. This check relies on dynamic bounds information collected by the measurement engine for each critical pointer. If a bounds breach is found, the measurement engine performs CVI check only on the overlapping bytes between the accessed memory region and the initially pointed variable. This design ensures CVI check correctness while allowing intentional out-of-bounds pointer dereferences in normal programs.

### Implementation

Our OAT prototype implementation includes:
- 6,017 lines of C++ code for the compiler (an LLVM module).
- 440 lines of C and assembly code for the trampoline library.
- 476 lines of C code for the measurement engine.
- 782 lines of Python code for the verification engine.

#### Hardware & Software Choices
We selected the HiKey board (ARM Cortex-A53) as our reference device for prototyping due to its unlocked/programmable TrustZone, full compatibility with open-source TEE OS, and reliable debugging tools. Although the board has a relatively powerful processor compared to some low-end embedded devices, no development board currently available comes with a low-end ARM processor and an unlocked TrustZone. OAT’s design and implementation are not specific to this board and do not depend on powerful processors. The only hardware requirement is the TrustZone extension, which is available on many commercial embedded ARM SoCs.

We used OP-TEE as our TEE OS (the OS for the Secure World). Although OAT is designed for bare-metal embedded devices, we used vendor-customized Linux as the Normal World OS solely for easy booting and debugging. OAT itself does not assume the presence of a Normal World OS. Even though OAT’s performance can be negatively affected by the unnecessary OS, our evaluation shows that the overhead under this configuration is still acceptable.

### Discussion

#### Multithreading
Our current prototype only supports single-thread programs. To attest multi-thread programs, we need to augment the OAT compiler to instrument threading-related events and have the measurement engine collect measurements and perform checks on a per-thread basis. We consider multithreading support out-of-scope for this paper as it does not require any change to the design of OEI attestation but requires significant engineering efforts to implement.

#### Interrupt Handling
Interrupt handling poses a challenge to control flow verification due to its asynchronous nature. When an interrupt occurs in the middle of an attested operation, the interrupted location is unknown. If the measurement engine cannot recognize and process interrupts, they may introduce out-of-context control flow events that can fail or confuse the verification.

OAT overcomes this challenge by treating each interrupt handler invoked during an operation as an execution of a sub-program. It instruments the handler at both the entry and exit points, notifying the measurement engine of the beginning and end of the sub-program. Thus, the control flow events of the handler are recorded in a separate trace and hash and verified independently. OAT also checks if an invoked interrupt handler matches the interrupt that triggered it.

#### Annotation
OAT allows programmers to optionally annotate semantically critical variables for CVI attestation. However, this annotation is not required for detecting data-oriented programming, control-flow bending, or similar data-only attacks, whose target data (control-dependent variables) are automatically detected by the OAT compiler and included in CVI verification. The annotation process for semantically critical variables is simple and facilitated by the compiler’s automatic dependency analysis.

### Evaluation and Analysis

We conducted:
- Micro performance tests to measure the overhead of each step in OEI attestation.
- Macro performance tests on 5 real embedded programs to examine OAT’s overall overhead.
- Tests against possible attacks.
- Analysis on how OAT defends against evasions.

#### Micro Performance Tests
The runtime overhead of OEI attestation can be broken down into three parts:
- **Attestation Initialization (Oat init)**: Takes place at the entry of an attestation scope.
- **Trampoline Invocation (Otramp)**: Includes a direct SMC call to initiate the world switch and a return from the Secure World.
- **Attestation Exit (Oat exit)**: Happens at the end of an attestation scope.

We created a test program that incurs each type of overhead exactly once. Running this program 1,024 times, we obtained the average overhead in terms of CPU cycles and time used. Oat init and Oat exit are orders of magnitude larger than Otramp due to the establishment and termination of the attestation session and communication between the Normal and Secure worlds. Since initialization and exit happen only once per attestation, their overhead tends to blend into the longer operation execution time and is unnoticeable.

#### Tests on Real Embedded Programs
We selected 5 open-source embedded programs to evaluate the end-to-end overhead of OAT:
- **Syringe Pump (SP)**: A remotely controlled liquid-injection device.
- **House Alarm System (HA)**: An IoT device that takes a picture and triggers an alarm.
- **Remote Movement Controller (RM)**: An embedded device for remote physical movement.
- **Rover Controller (RC)**: Controls the motor on a rover.
- **Light Controller (LC)**: A smart lighting controller.

**Compile-time Overhead**: We instrumented the OAT compiler to measure binary size increase and compilation delay. The absolute increase in code size ranges from 1 to 3 KB, which is acceptable even for embedded devices. The compilation delay caused by attestation-related code analysis and instrumentation averages 62%, but in absolute terms, the delay is less than 1 second for the tested programs.

**Operation Execution Time & Instrumentation Statistics**: For each test program, we measured the execution times with and without OEI attestation enabled for the selected operation. The relative delay caused by OAT to operation executions averaged 2.7%, which is unnoticeable and blends into the much longer end-to-end execution time.

### Conclusion

OAT provides a robust and efficient solution for ensuring the integrity of critical variables in embedded systems. By leveraging automatic dependency analysis and dynamic bounds checking, OAT minimizes the burden on programmers while providing comprehensive protection against various types of attacks.