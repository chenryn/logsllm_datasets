title:deDacota: toward preventing server-side XSS via automatic code and
data separation
author:Adam Doup&apos;e and
Weidong Cui and
Mariusz H. Jakubowski and
Marcus Peinado and
Christopher Kruegel and
Giovanni Vigna
deDacota: Toward Preventing Server-Side XSS
via Automatic Code and Data Separation
Adam Doupé
UC Santa Barbara
PI:EMAIL
Marcus Peinado
Microsoft Research
PI:EMAIL
Weidong Cui
Microsoft Research
PI:EMAIL
Christopher Kruegel
PI:EMAIL
UC Santa Barbara
Mariusz H. Jakubowski
PI:EMAIL
Microsoft Research
Giovanni Vigna
UC Santa Barbara
PI:EMAIL
ABSTRACT
Web applications are constantly under attack. They are
popular, typically accessible from anywhere on the Internet,
and they can be abused as malware delivery systems.
Cross-site scripting ﬂaws are one of the most common
types of vulnerabilities that are leveraged to compromise a
web application and its users. A large set of cross-site script-
ing vulnerabilities originates from the browser’s confusion
between data and code. That is, untrusted data input to
the web application is sent to the clients’ browser, where it
is then interpreted as code and executed. While new appli-
cations can be designed with code and data separated from
the start, legacy web applications do not have that luxury.
This paper presents a novel approach to securing legacy
web applications by automatically and statically rewriting
an application so that the code and data are clearly sep-
arated in its web pages. This transformation protects the
application and its users from a large range of server-side
cross-site scripting attacks. Moreover, the code and data
separation can be eﬃciently enforced at run time via the
Content Security Policy enforcement mechanism available
in modern browsers.
We implemented our approach in a tool, called deDa-
cota, that operates on binary ASP.NET applications. We
demonstrate on six real-world applications that our tool is
able to automatically separate code and data, while keeping
the application’s semantics unchanged.
Categories and Subject Descriptors
D.2.5 [Testing and Debugging]
Keywords
Static Analysis; Cross-Site Scripting; XSS; Content Security
Policy; CSP
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516708.
1.
INTRODUCTION
Web applications are prevalent and critical in today’s com-
puting world, making them a popular attack target. Looking
at types of vulnerabilities reported in the Common Vulnera-
bilities and Exposures (CVE) database [11], web application
ﬂaws are by far the leading class.
Modern web applications have evolved into complex pro-
grams. These programs are no longer limited to server-side
code that runs on the web server. Instead, web applications
include a signiﬁcant amount of JavaScript code that is sent
to and executed on the client. Such client-side components
not only provide a rich and fast user interface, they also
contain parts of the application logic and typically commu-
nicate with the server-side component through asynchronous
JavaScript calls. As a result, client-side scripts are an inte-
gral component of modern web applications, and they are
routinely generated by server-side code.
There are two kinds of cross-site scripting (XSS) vulnera-
bilities: server-side and client-side. The latter is essentially
caused by bugs in the client-side code, while the former is
caused by bugs in the server-side code. In this paper we fo-
cus on server-side XSS vulnerabilities (unless speciﬁed oth-
erwise, we will use XSS to refer to server-side XSS). XSS
vulnerabilities allow attackers to inject client-side scripting
code (typically, JavaScript) into the output of web appli-
cations. The scripts are then executed by the browser as
it renders the page, allowing malicious code to run in the
context of the web application. Attackers can leverage XSS
attacks to leak sensitive user information, impersonate the
victim to perform unwanted actions in the context of the
web application, or launch browser exploits.
There has been a signiﬁcant amount of research eﬀort on
eliminating XSS vulnerabilities. The main line of research
has focused on sanitizing untrusted input [3, 13, 18, 22, 25,
27, 34, 38, 40, 44, 46, 48–50]. Sanitization attempts to identify
and “clean up” untrusted inputs that might contain Java-
Script code. Performing correct sanitization is challenging,
for a number of reasons. One reason is that it is diﬃcult
to guarantee coverage for all possible paths through the ap-
plication [3, 48]. As part of this problem, it is necessary to
ﬁnd all program locations (sources) where untrusted input
can enter the application, and then verify, along all program
paths, the correctness of all sanitization functions that are
used before the input is sent to the client (sinks). Further-
more, it is not always clear how to properly sanitize data,
because a single input might appear in diﬀerent contexts in
the output of the application [40].
1205The root cause of XSS vulnerabilities is that the current
web application model violates the principle of code and data
separation. In the case of a web page, the data is the HTML
content of the page and the code is the JavaScript code.
Mixing JavaScript code and HTML data in the same channel
(the HTTP response) makes it possible for an attacker to
convince a user’s browser to interpret maliciously crafted
HTML data as JavaScript code. While sanitization tries to
turn untrusted input, which could potentially contain code,
into HTML data, we believe the fundamental solution to
XSS is to separate the code and data in a web page—the
way HTML and JavaScript should have been designed from
the start. Once the code and data are separated, a web
application can communicate this separation to the browser,
and the browser can ensure no code is executed from the data
channel. Such communication and enforcement is supported
by the new W3C browser standard Content Security Policy
(CSP) [42].
While new web applications can be designed with code
and data separated from the start, it has been a daunting
task to achieve code and data separation for legacy applica-
tions. The key challenge is to identify code or data in the
output of a web application. Previous solutions have relied
on either developers’ manual annotations or dynamic analy-
sis. For example, BEEP [20] requires developers to manually
identify inline JavaScript code. Blueprint [28] requires de-
velopers to manually identify the data by specifying which
application statements could output untrusted input. XSS-
GUARD dynamically identiﬁes application-intended Java-
Script code in a web page by comparing it with a shadow
web page generated at run time [4]. The main problem
preventing these solutions from being adopted is either the
signiﬁcant manual eﬀort required from application develop-
ers or the signiﬁcant runtime performance overhead. In fact,
Weinberger et al. [47] showed how diﬃcult it is to manually
separate the code and data of a web application.
In this paper, we present deDacota, the ﬁrst system that
can automatically and statically rewrite an existing web ap-
plication to separate code and data in its web pages. Our
novel idea is to use static analysis to determine all inline
JavaScript code in the web pages of an application. Specif-
ically, deDacota performs static data-ﬂow analysis of a
given web application to approximate its HTML output.
Then, it parses each page’s HTML output to identify in-
line JavaScript code. Finally, it rewrites the web applica-
tion to output the identiﬁed JavaScript code in a separate
JavaScript ﬁle.
The problem of statically determining the set of (HTML)
outputs of a web application is undecidable. However, as we
observe in our evaluation, the problem is typically tractable
for real-world web applications. These applications are writ-
ten by benign developers and tend to have special proper-
ties that allow us to compute their outputs statically. For
instance, the majority of the inline JavaScript code is static
in the web applications we tested.
Dynamic inline JavaScript presents a second-order prob-
lem. Here, the JavaScript code itself (rather than the HTML
page) is generated dynamically on the server and may de-
pend on untrusted inputs. Again, the potential for XSS
vulnerabilities exists. deDacota provides a partial solution
to this problem by producing alerts for all potentially dan-
gerous instances of dynamic JavaScript generation in the
application and by safely sanitizing a large subclass of these
instances.
We implemented a prototype of deDacota to analyze and
rewrite ASP.NET [31] web applications. We then applied
deDacota to six open-source, real-world ASP.NET appli-
cations. We veriﬁed that all known XSS vulnerabilities are
eliminated. We then performed extensive testing to ensure
that the rewritten binaries still function correctly. We also
tested deDacota’s performance and found that the page
loading times between the original and rewritten applica-
tion are indistinguishable.
The main contributions of this paper are the following:
• A novel approach for automatically separating the code
and data of a web application using static analysis
(Section 4).
• A prototype implementation of our approach, deDa-
cota, applied to ASP.NET applications (Section 5).
• An evaluation of deDacota, showing that we are able
to apply our analysis to six real-world, open-source,
ASP.NET applications. We show that our implemen-
tation prevents the exploitation of know vulnerabili-
ties and that the semantics of the application do not
change (Section 6).
2. BACKGROUND
In this section, we provide the background necessary for
understanding the design of deDacota.
2.1 Cross-Site Scripting
Modern web applications consist of both server-side and
client-side code. Upon receiving an HTTP request, the
server-side code, which is typically written in a server-side
language, such as PHP or ASP.NET, dynamically generates
a web page as a response, based on the user input in the
request or data in a backend database. The client-side code,
which is usually written in JavaScript and is executed by
the browser, can be either inline in the web page or external
as a standalone JavaScript ﬁle.
Cross-site scripting (XSS) vulnerabilities allow an attacker
to inject malicious scripts into web pages to execute in the
client-side browser, as if they were generated by the trusted
web site. If the vulnerability allows the attacker to store ma-
licious JavaScript on the server (e.g., using the contents of
a message posted on a newsgroup), the vulnerability is tra-
ditionally referred to as “stored” or “persistent XSS.” When
the malicious code is included in the request and involun-
tarily reﬂected to the user (copied into the response) by the
server, the vulnerability is called “reﬂected XSS.” Finally, if
the bug is in the client-side code, the XSS vulnerability is
referred to as “DOM-based XSS” [24]. We call the ﬁrst two
types of vulnerabilities “server-side XSS vulnerabilities” and
the latter “client-side XSS vulnerabilities.”
The root cause for server-side XSS is that the code (i.e.,
the client-side script) and the data (i.e., the HTML content)
are mixed together in a web page. By crafting some mali-
cious input that will be included into the returned web page
by the server-side code, an attacker can trick the browser
into confusing his data as JavaScript code.
12062.2 Code and Data Separation
The separation of code and data can be traced back to
the Harvard Architecture, which introduces separate stor-
age and buses for code and data. Separating code and data
is a basic security principle for avoiding code injection at-
tacks [19]. Historically, whenever designs violate this prin-
ciple, there exists a security hole. An example is the stack
used in modern CPUs. The return addresses (code point-
ers) and function local variables (data) are co-located on
the stack. Because the return addresses determine control
transfers, they are essentially part of the code. Mixing them
together with the data allows attackers to launch stack over-
ﬂow attacks, where data written into a local variable spills
into an adjacent return address. In the context of web ap-
plications, we face the same security challenge, this time
caused by mixing code and data together in web pages. To
fundamentally solve this problem, we must separate code
and data in web pages created by web applications.
2.3 Content Security Policy
Content Security Policy (CSP) [42] is a mechanism for
mitigating a broad class of content injection vulnerabilities
in web applications. CSP is a declarative policy that allows a
web application to inform the browser, via an HTTP header,
about the sources from which the application expects to load
resources such as JavaScript code. A web browser that im-
plements support for CSP can enforce the security policy
declared by the web application.
A newly developed web application can leverage CSP to
avoid XSS by not using inline JavaScript and by specifying
that only scripts from a set of trusted sites are allowed to
execute on the client. Indeed, Google has required that all
Chrome browser extensions implement CSP [1]. However,
manually applying CSP to a legacy web application typi-
cally requires a non-trivial amount of work [47]. The reason
is that the authors of the web application have to modify
the server-side code to clearly identify which resources (e.g.,
which JavaScript programs) are used by a web page. More-
over, these scripts have to be separated from the web page.
CSP essentially provides a mechanism for web browsers
to enforce the separation between code and data as speci-
ﬁed by web applications. Our work solves the problem of
automatically transforming legacy web applications so that
the code and data in their web pages are separated. The
transformed web applications can then directly leverage the
browser’s support for CSP to avoid a wide range of XSS
vulnerabilities.
3. THREAT MODEL
Before discussing the design of deDacota, we need to
state our assumptions about the code that we are analyzing
and the vulnerabilities we are addressing.
Our approach involves rewriting a web application. This
web application is written by a benign developer—that is,
the developer has not intentionally obfuscated the code as a
malicious developer might. This assumption also means that
the JavaScript and HTML are benign and not intentionally
taking advantage of browser parsing quirks (as described in
Blueprint [28]).
deDacota will only prevent server-side XSS vulnerabil-
ities. We deﬁne server-side XSS vulnerabilities as XSS vul-
nerabilities where the root cause of the vulnerability is in
server-side code. Speciﬁcally, this means XSS vulnerabili-
ties where unsanitized input is used in an HTML page. We