the certiﬁcate along with a time after which the revocation is guar-
anteed to be present in the log’s certiﬁcate tree.
6.3 Certiﬁcate Validation
Before an MSC can be validated, a client must ﬁrst read the pa-
rameters in the domain’s SCP PA which contain the list of trusted
CAs and logs needed for the rest of the validation process. Recall
that policy ﬁelds can be inheritable (§5.2) and that a proof for a do-
main’s policy contains all policies of parent domains from which
ﬁelds can be inherited (§5.3). Therefore, we can extract from this
proof a list Plist of the parent domains’ SCPs. However, since al-
most all ﬁelds in an SCP are optional, it is possible that some policy
ﬁelds will not be speciﬁed by any applicable policy. In this case, the
browser will determine a default value for any unspeciﬁed parame-
ters as browsers do today. We call this “default policy” Pbrowser.
Once we have the above we can determine the appropriate pa-
rameters for each TLS connection. We achieve this through Algo-
rithm 1, which returns the set of parameters as a dictionary. The
algorithm treats each policy as a dictionary in which values corre-
sponding to a key can be accessed as P[key]. The dictionary that
will eventually be returned starts as Pbrowser, which usually contain
the least conservative parameter values. These default values are
then overwritten by the ﬁelds speciﬁed in PA. Next for each pol-
icy in Plist , the client checks whether the ﬁelds are inheritable (i.e.,
the corresponding bit in the SCP’s inheritance mask is set to 1). If
so, the inherited value overwrites the current one, but only if the
new value is more conservative. For example, if a domain’s policy
speciﬁes a high security level for TLS connections, and a parent
domain’s policy speciﬁes a medium level that is inheritable, then
the parent domain’s security level is not inherited because it could
result in a lower security level in the domain’s TLS connections.
Algorithm 1: Determine appropriate SCP parameters from the
SCP hierarchy.
PA - policy of domain contacted by a browser
Plist - list of policies of parent domains (with respect to PA)
sorted by level (from the most speciﬁc domain name to TLD)
Pbrowser - default browser policy
policyInheritance(PA, Plist ):
d = Pbrowser
for attr ∈ PA
d[attr] = PA[attr]
for P ∈ Plist
for attr ∈ {LOG_LIST, CA_LIST}
if P[attr].isInherited
d[attr] = d[attr] ∩ P[attr]
for attr ∈ {CERT_TH, CERT_SEC, TLS_SEC,
FAIL_CERT_TH, FAIL_TLS, FAIL_EXP,
FAIL_POL, FAIL_*, UP_CA_MIN, UP_CA_TH,
UP_COP_UNTRUSTED, UP_COP_UNLINKED}
if P[attr].isInherited and d[attr]  P[attr]
d[attr] = P[attr]
for attr ∈ {EV_ONLY, WILDCARD_FORBIDDEN}
if P[attr].isInherited and P[attr]
d[attr] = P[attr]
return d
Once the policy parameters have been determined, the domain’s
MSC must be “pre-validated.” The client checks whether the X.509
certiﬁcates within the MSC are issued for the correct domain and
whether the certiﬁcates all authenticate the same public key. The
client browser also checks that the version number of the policy ob-
tained from Algorithm 1 matches the version number in the MSC’s
policy binding, and that the hash of each certiﬁcate appears in the
CERTS ﬁeld of the policy binding. The client browser then veriﬁes
the signature on the policy binding, which is signed by the domain’s
policy private key.
With pre-validated MSC and SCP parameters, the client browser
can then validate the MSC by following Algorithm 2. The most im-
portant parameter for this validation is CERT_TH, which describes
how many standard certiﬁcates must be valid in a multi-signature
certiﬁcate in order for the MSC to be valid. A certiﬁcate is classi-
ﬁed as valid and counts toward CERT_TH if 1. its signature is suc-
cessfully veriﬁed, 2. the private key used to sign the certiﬁcate has
not already signed another certiﬁcate counting towards CERT_TH,
and 3. the certiﬁcate meets the constraints set by the SCP parame-
ters. If CERT_TH is met, then the client browser proceeds to validate
the log proofs for the MSC.
6.4 Log Proof Validation
After a successful SCP or MSC registration, the log returns a
registration receipt promising that the certiﬁcate or policy will be
added to its database within a certain amount of time. This registra-
tion receipt can be used as a short-term conﬁrmation that an SCP or
MSC is in the log, but log proofs are more commonly used for this
purpose. To successfully establish a connection to the domain, the
client requires proofs that the policy is registered, as well as proofs
that the MSC is registered and not yet revoked.
Algorithm 2: MSC validation.
Algorithm 3: TLS connection establishment.
d - dictionary generated by policyInheritance() execution
isLegacyValid() - standard validation for single certiﬁcate
isMSCValid(d, {CertCA1
A ,CertCA2
A
, ...,CertCAN
A
,CertPA
A }):
S = {}
for CertCAx
A ∈ {CertCA1
A
,CertCA2
, ...,CertCAN
}
A
A
if (CAx ∈ d[CA_LIST] and isLegacyValid(A,CertCAx
A ))
A )  d[MAX_PATH_LEN]) or
A ) > d[MAX_LIFETIME]) or
A .isEV and d[EV_ONLY]) or
A .isWildcard and d[WILDCARD_FORBIDDEN])
if (getCertSec(CertCAx
(getPathLen(CertCAx
(getLifetime(CertCAx
(not CertCAx
(CertCAx
continue
S = S ∪ {CAx}
return |S| ≥ d[CERT_TH]
While anyone can request such proofs from a log, proofs are
often periodically retrieved from the log by the domain and stapled
to the MSC and SCP during connection setup. To request a log
proof, the domain sends a proof request to the log containing a
hash of its MSC. The log uses this hash to locate the appropriate
leaf node in its certiﬁcate tree and generates a proof of presence or
absence (as in Equation 2) for this node.2 The log also produces a
proof of presence for the domain’s policy (following Equation 9),
as well as a proof that the policy and certiﬁcate trees’ root hashes
is the most recent one recorded in the consistency tree. The log
then sends these three proofs along with a signed root hash of the
consistency tree to the domain. The domain can pass these proofs
and hashes on to the client.
There is also a possibility that the log does not have a proof for
an SCP or MSC. It may be the case that the MSC, SCP, or both
does not have a corresponding log proof because the log has not
yet updated its database to reﬂect a registration.
In this case, a
registration receipt from the log sufﬁces as a proof of presence so
that domains who newly register a certiﬁcate and policy can begin
serving customers as soon as possible. It may also be the case that
the domain has not yet adopted PoliCert. In this case, the client
can request a proof of absence for the domain’s SCP from one or
more of the log servers. This prevents an adversary from obtaining
a bogus certiﬁcate for a domain and suppressing the log proofs to
make it seem as though the domain has not yet deployed PoliCert.
When requesting a proof of absence, the client may want to proxy
the request through another log [1] or request several decoy proofs
to preserve the privacy of its queries.
6.5 Connection Establishment
The client initiates a TLS connection with a domain using Algo-
rithm 3. In the ﬁrst ClientHello message, the client browser sends
the latest seen version numbers of domain’s policy and all parent
domain policies it has from the previous connections. The domain
then sends its multi-signature certiﬁcate, subject certiﬁcate policy
(if the browser does not have the latest version), and the appro-
priate log proofs or registration receipts showing that the MSC is
valid and compliant with appropriate policies. The browser vali-
dates the proofs, determines the policy parameters, and validates
2If a revocation request for an MSC has been accepted but the log
has not yet updated its database, the log returns the revocation re-
ceipt for the certiﬁcate.
preValidation() - pre-validates MSC, policies, and
proofs (§6.3). If pre-validation fails and the browser has a
stored policy for the domain, then FAIL_POL and FAIL_LOG
from this policy can be applied in the appropriate scenario.
Otherwise, it hard fails.
getSec() - evaluates security level of TLS parameters
f ail(S) - if S 6= {} fails with max(S) failure scenario (0 - soft
fail, 1 - hard fail) and shows all occurred errors to client
Client
ClientHello
(indicates stored policies)
Log
A’s Server
proofs request −→
(every
LOG_TIMEOUT)
←− proofs
−→
←− MSCA, PA, Plist , proofs
S = {}
preValidation(...)
d = policyInheritance(PA, Plist )
if not isMSCValid(d, MSCA)
S = S ∪ {d[FAIL_CERT_TH]}
if getSec(TLSParams) < d[TLS_SEC]
S = S ∪ {d[FAIL_TLS]}
if proofs are expired
S = S ∪ {d[FAIL_EXP]}
if Log 6∈ d[LOG_LIST]
S = S ∪ {d[FAIL_LOG]}
f ail(S)
the domain’s MSC. The browser negotiates the TLS connection
with the appropriate security level and, if all other operations are
successful, accepts the connection.
7.
IMPLEMENTATION AND EVALUATION
In order to evaluate the deployment feasibility and performance
of PoliCert, we implemented each of the parties in the architecture.
The client-side code, which includes Algorithms 1 and 2 as well as
part of Algorithm 3, was implemented by extending the Chromium
web browser. We deployed our domain on both Apache and Nginx
HTTP servers, which were equipped with special scripts to send
proof requests and periodically process responses from the log.
The domain sends these proofs to clients during the TLS handshake
protocol. Because CAs have a similar role in PoliCert as they cur-
rently do, we used standard tools such as OpenSSL to handle CA
certiﬁcate operations, and created multi-signature certiﬁcates and
policies with several trusted CAs of our making. We used elliptic
curve cryptography for our keypairs, with ECDSA [18] as our sig-
nature scheme. We selected the elliptic curve secp521r [5, 7] from
OpenSSL 1.0.1f, and also used this version for all cryptographic
operations. We implemented our log servers in C++ (gcc 4.8.2)
using SHA-512 as the hash function for the Merkle-hash trees. Au-
ditors compare the signed root hash value from the logs with those
they have stored to detect potential misbehavior.
For our evaluation we deployed three machines running Linux
3.13.0-24-generic x86_64, representing a log (Intel i5-3210M, 2.50
GHz, 4GB of RAM), a domain/server (Intel i5-3210M, 2.50 GHz,
4GB of RAM), and a client browser (Intel i5-3470, 3.20 GHz, 8GB
of RAM). Since the log serves many types of requests, we sent 500
of each type of request (policy registration, policy update, certiﬁ-
cate registration, certiﬁcate revocation, and proof request) to the
Action
Policy Registration
Policy Update
Certiﬁcate Registration
Certiﬁcate Revocation
Proof Request
Avg. Median Min. Max.
16.33
10.02
10.75
14.52
12.58
7.35
9.37
4.90
8.99
18.00
9.79
10.27
6.73
4.57
8.58
6.50
7.70
5.84
2.69
5.64
Table 1: Log’s processing time (in ms) for different requests.
employing n trusted entities, and the system prevents attacks even
when an adversary controls n − 1 of these entities. In our proposal,
we deﬁne n ≥ 3 to be a system parameter, where the log contacted
by the domain is one of the n trusted parties along with n − 1 audi-
tors. We show an overview of the architecture and general message
ﬂow in Figure 6. The logs’ operation is similar to that described
in §6, but their correctness is asserted by additional trusted parties
(auditors). Auditors3, as in ARPKI, can detect log’s misbehaving
and disseminate that information among each other.
Action
MSC Pre-validation
SCP Processing (Alg. 1)
MSC Validation (Alg. 2)
Proof Validation
Complete Validation
Avg. Median Min. Max.
1.40
0.79
0.50
1.05
1.22
0.60
1.78
1.45
3.34
4.84
0.78
0.49
0.59
1.44
3.32
0.75
0.45
0.55
1.39
3.17
Table 2: Browser’s processing time (in ms) in details.
log. We show the average, median, minimum, and maximum pro-
cessing times for each request type in Table 1.
The synchronization protocol, required for global logs’ coor-
dination in the case of policy registration and update, was real-
ized with a two-phase commit protocol [3], where all messages are
signed by participants.
To evaluate the computational effort required by the browser, we
executed the browser’s side of veriﬁcation 500 times. In this sce-
nario the browser was connecting to localhost.net serving an
MSC, its own policy, and a policy of .net. Each multi-signature
certiﬁcate consisted of three standard certiﬁcates. The total time
taken by the browser was divided into several categories as shown
in Table 2: pre-validation of MSCs, SCP parameter processing,
MSC validation, and log proof validation.
The MSC with policies was sent in the Server Certiﬁcate mes-
sage of the TLS Handshake, allowing us to deliver the multi-signature
certiﬁcate and policies without any changes to the browser. The
log proofs were sent to the browser via the OCSP Stapling exten-
sion [6], saving the client the need to fetch the proofs separately.
Since the applicable policies were already sent for SCP processing
(Algorithm 1), the SCPs of the domain and its parent domains do
not have to be included with the proof. Rather, for better efﬁciency
the domain can omit this information and instead have the client
browser ﬁll in the gaps with the policies, signiﬁcantly decreasing
message overhead.
However, the highest message overhead is due to the structure of
MSCs, which contain multiple X.509 certiﬁcates for the same key.