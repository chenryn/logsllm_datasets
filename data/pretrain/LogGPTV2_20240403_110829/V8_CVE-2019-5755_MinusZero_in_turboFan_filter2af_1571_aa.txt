# V8 CVE-2019-5755 MinusZero类型缺失漏洞 in turboFan
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 一、前言
  * CVE-2019-5755 是一个位于 v8 turboFan 的类型信息缺失漏洞。该漏洞将导致 SpeculativeSafeIntegerSubtract 的计算结果缺失 MinusZero （即 -0）这种类型。这将允许 turboFan 计算出错误的 Range 并可进一步构造出越界读写原语，乃至执行 shellcode。
  * 复现用的 v8 版本为 `7.1.302.28` （或者commit ID `a62e9dd69957d9b1d0a56f825506408960a283fc` 前的版本也可）
## 二、环境搭建
  * 切换 v8 版本，然后编译： 
        git checkout 7.1.302.28
    gclient sync
    tools/dev/v8gen.py x64.debug
    ninja -C out.gn/x64.debug
  * 启动 turbolizer。如果原先版本的 turbolizer 无法使用，则可以使用在线版本的 [turbolizer](https://v8.github.io/tools/head/turbolizer/index.html)
        cd tools/turbolizer
    npm i
    npm run-script build
    python -m SimpleHTTPServer 8000&
    google-chrome http://127.0.0.1:8000
## 三、漏洞细节
  * turboFan 的 Typer 将 SpeculativeSafeIntegerSubtract 的类型设置为与 kSafeInteger 的交集， **但这里没有考虑到`-0` （即 MinusZero）的情况。** 例如：算式 `((-0) - 0)` 应该返回 `-0`，但是由于 Typer 取的是两 个类型的交集，因此 typer 将忽略 MinusZero (-0) 的这种情况。而这种 wrong case 可以用来执行错误的范围计算。以下是 SpeculativeSafeIntegerSubtract 函数（漏洞函数）以及 SpeculativeSafeIntegerAdd 函数（对照函数）的源码： 
        Type OperationTyper::SpeculativeSafeIntegerAdd(Type lhs, Type rhs) {
      Type result = SpeculativeNumberAdd(lhs, rhs);
      // If we have a Smi or Int32 feedback, the representation selection will
      // either truncate or it will check the inputs (i.e., deopt if not int32).
      // In either case the result will be in the safe integer range, so we
      // can bake in the type here. This needs to be in sync with
      // SimplifiedLowering::VisitSpeculativeAdditiveOp.
      return Type::Intersect(result, cache_.kSafeIntegerOrMinusZero, zone());
    }
    Type OperationTyper::SpeculativeSafeIntegerSubtract(Type lhs, Type rhs) {
      Type result = SpeculativeNumberSubtract(lhs, rhs);
      // If we have a Smi or Int32 feedback, the representation selection will
      // either truncate or it will check the inputs (i.e., deopt if not int32).
      // In either case the result will be in the safe integer range, so we
      // can bake in the type here. This needs to be in sync with
      // SimplifiedLowering::VisitSpeculativeAdditiveOp.
      /* 
        给左右操作数相减的结果（即变量 result）与 `kSafeInteger`类型 相交，返回 **交集** 。
        !!! 注意这里，使用的是 cache_.kSafeInteger
        与上面SpeculativeSafeIntegerAdd函数使用的cache_.kSafeIntegerOrMinusZero不一致
      */
      return result = Type::Intersect(result, cache_.kSafeInteger, zone());
    }
  * 以下是该漏洞的 PoC： 
        function foo(trigger) {
        var idx = Object.is((trigger ? -0 : 0) - 0, -0);
        return idx;
    }
    console.log(foo(false));
    %OptimizeFunctionOnNextCall(foo);
    console.log(foo(true)); // expected: true, got: false
正常来说，`foo(true)`应该始终返回 true （因为 $-0 – 0 = -0$），但优化后产生的结果却是 false。
我们可以观察一下 turbolizer 中的信息：
可以看到，对于 {MinusZero | Range(0,0)} – Range(0,0)
这种情况，SpeculativeSafeIntegerSubtract 的 Type 中并没有 MinusZero 这种类型。
因此，turboFan 将始终在 `TypedLoweringPhase -TypedOptimization::ReduceSameValue`中，把SameValue 结点优化成 false，因为 $MinusZero \ne
Range(0, 0)$。
  * SameValue 结点是通过 JS 中`Object.is` 函数调用来生成的，其目的是用于判断左右操作数是否相同。具体来说是通过以下调用链生成： 
        void InliningPhase::Run(...)
        Reduction JSCallReducer::ReduceJSCall(...)
          Reduction JSCallReducer::ReduceObjectIs(Node* node)
其中，函数 ReduceObjectIs 的源码如下:
        // ES section #sec-object.is
    Reduction JSCallReducer::ReduceObjectIs(Node* node) {
      DCHECK_EQ(IrOpcode::kJSCall, node->opcode());
      CallParameters const& params = CallParametersOf(node->op());
      int const argc = static_cast(params.arity() - 2);
      Node* lhs = (argc >= 1) ? NodeProperties::GetValueInput(node, 2)
                              : jsgraph()->UndefinedConstant();
      Node* rhs = (argc >= 2) ? NodeProperties::GetValueInput(node, 3)
                              : jsgraph()->UndefinedConstant();
      // 生成 SameValue Node
      Node* value = graph()->NewNode(simplified()->SameValue(), lhs, rhs);
      ReplaceWithValue(node, value);
      return Replace(value);
    }
Typer 将在 TyperPhase 阶段试着计算出 SameValue 结点的类型，它将沿着以下调用链
        Type Typer::Visitor::TypeSameValue(Node* node)
      Type Typer::Visitor::SameValueTyper(Type lhs, Type rhs, Typer* t)
        Type OperationTyper::SameValue(Type lhs, Type rhs)
调用到`OperationTyper::SameValue`函数并计算其类型：
        Type OperationTyper::SameValue(Type lhs, Type rhs) {
      if (!JSType(lhs).Maybe(JSType(rhs))) return singleton_false();
      if (lhs.Is(Type::NaN())) {
        if (rhs.Is(Type::NaN())) return singleton_true();
        if (!rhs.Maybe(Type::NaN())) return singleton_false();
      } else if (rhs.Is(Type::NaN())) {
        if (!lhs.Maybe(Type::NaN())) return singleton_false();
      }
      if (lhs.Is(Type::MinusZero())) {
        if (rhs.Is(Type::MinusZero())) return singleton_true();
        if (!rhs.Maybe(Type::MinusZero())) return singleton_false();
       // 如果左右操作数不同时为 MinusZero，则返回 false。
      } else if (rhs.Is(Type::MinusZero())) {
        if (!lhs.Maybe(Type::MinusZero())) return singleton_false();
      }
      if (lhs.Is(Type::OrderedNumber()) && rhs.Is(Type::OrderedNumber()) &&
          (lhs.Max()  rhs.Max())) {
        return singleton_false();
      }
      return Type::Boolean();
    }
当 SameValue 结点计算出 确定性的类型（即 true / false）后，turboFan 将在 TypedLoweringPhase 阶段中的
ConstantFoldingReducer 对 SameValue 进行结点替换，用之前计算出的 HeapConstant 替换当前的 SameValue
结点：
        Reduction ConstantFoldingReducer::Reduce(Node* node) {
      DisallowHeapAccess no_heap_access;
    // Check if the output type is a singleton.  In that case we already know the
      // result value and can simply replace the node if it's eliminable.
      // 如果当前结点的 type 是 singleton，即确定只有一种类型，则开始优化
      if (!NodeProperties::IsConstant(node) && NodeProperties::IsTyped(node) &&
          node->op()->HasProperty(Operator::kEliminatable)) {
        // ...
        // We can only constant-fold nodes here, that are known to not cause any
        // side-effect, may it be a JavaScript observable side-effect or a possible
        // eager deoptimization exit (i.e. {node} has an operator that doesn't have
        // the Operator::kNoDeopt property).
        // 获取当前结点的类型
        Type upper = NodeProperties::GetType(node);
        if (!upper.IsNone()) {
          Node* replacement = nullptr;
          // 如果当前结点是 HeapConstant
          if (upper.IsHeapConstant()) {
            replacement = jsgraph()->Constant(upper.AsHeapConstant()->Ref());
          } else if // ...
          // ...
          if (replacement) {
            // Make sure the node has a type.
            // 使用新类型进行替换
            if (!NodeProperties::IsTyped(replacement)) {
              NodeProperties::SetType(replacement, upper);
            }
            ReplaceWithValue(node, replacement);
            return Changed(replacement);
          }
        }
      }
      return NoChange();
    }
若 SameValue 无法得到确定性的类型，则将在 TypedLoweringPhase 中通过
`TypedOptimization::ReduceSameValue` 函数进行另一种优化。以下是该函数的源码，在该源码中我们可以了解到
ReduceSameValue 的详细执行过程：
        Reduction TypedOptimization::ReduceSameValue(Node* node) {
      DCHECK_EQ(IrOpcode::kSameValue, node->opcode());
      Node* const lhs = NodeProperties::GetValueInput(node, 0);
      Node* const rhs = NodeProperties::GetValueInput(node, 1);
      Type const lhs_type = NodeProperties::GetType(lhs);
      Type const rhs_type = NodeProperties::GetType(rhs);
      if (lhs == rhs) {
        // SameValue(x,x) => #true
        return Replace(jsgraph()->TrueConstant());
      } else if (lhs_type.Is(Type::Unique()) && rhs_type.Is(Type::Unique())) {
        // SameValue(x:unique,y:unique) => ReferenceEqual(x,y)
        NodeProperties::ChangeOp(node, simplified()->ReferenceEqual());
        return Changed(node);
      } else if (lhs_type.Is(Type::String()) && rhs_type.Is(Type::String())) {
        // SameValue(x:string,y:string) => StringEqual(x,y)
        NodeProperties::ChangeOp(node, simplified()->StringEqual());
        return Changed(node);
      } else if (lhs_type.Is(Type::MinusZero())) {
        // SameValue(x:minus-zero,y) => ObjectIsMinusZero(y)
        node->RemoveInput(0);
        NodeProperties::ChangeOp(node, simplified()->ObjectIsMinusZero());
        return Changed(node);
      } else if (rhs_type.Is(Type::MinusZero())) {
        // SameValue(x,y:minus-zero) => ObjectIsMinusZero(x)
        node->RemoveInput(1);
        NodeProperties::ChangeOp(node, simplified()->ObjectIsMinusZero());
        return Changed(node);
      } else if (lhs_type.Is(Type::NaN())) {
        // SameValue(x:nan,y) => ObjectIsNaN(y)
        node->RemoveInput(0);
        NodeProperties::ChangeOp(node, simplified()->ObjectIsNaN());
        return Changed(node);
      } else if (rhs_type.Is(Type::NaN())) {
        // SameValue(x,y:nan) => ObjectIsNaN(x)
        node->RemoveInput(1);
        NodeProperties::ChangeOp(node, simplified()->ObjectIsNaN());
        return Changed(node);
      } else if (lhs_type.Is(Type::PlainNumber()) &&
                 rhs_type.Is(Type::PlainNumber())) {
        // SameValue(x:plain-number,y:plain-number) => NumberEqual(x,y)
        NodeProperties::ChangeOp(node, simplified()->NumberEqual());
        return Changed(node);
      }
      return NoChange();
    }
  * 我们再简单了解一下 SpeculativeSafeIntegerSubtract 和 SpeculativeNumberSubtract 结点的生成方式。这两种结点的生成都将通过以下调用链： 
        bool PipelineImpl::CreateGraph()
      void GraphBuilderPhase::Run(...)
        void BytecodeGraphBuilder::CreateGraph(...)
          void BytecodeGraphBuilder::VisitBytecodes(...)
            void BytecodeGraphBuilder::VisitSingleBytecode(...)
              void BytecodeGraphBuilder::VisitSubSmi()
                void BytecodeGraphBuilder::BuildBinaryOpWithImmediate(...)
                  void BytecodeGraphBuilder::BuildBinaryOp(...)
                    BytecodeGraphBuilder::TryBuildSimplifiedBinaryOp(...)
                      JSTypeHintLowering::LoweringResult JSTypeHintLowering::ReduceBinaryOperation(...)
                        Node* TryBuildNumberBinop()
                          const Operator* SpeculativeNumberOp(NumberOperationHint hint)
调用到最终的目标函数 `SpeculativeNumberOp`：
        const Operator* SpeculativeNumberOp(NumberOperationHint hint) {
        switch (op_->opcode()) {
          // ...
          case IrOpcode::kJSSubtract:
            if (hint == NumberOperationHint::kSignedSmall ||
                hint == NumberOperationHint::kSigned32) {
              return simplified()->SpeculativeSafeIntegerSubtract(hint);
            } else {
              return simplified()->SpeculativeNumberSubtract(hint);
            }
          // ...
        }
        UNREACHABLE();
      }
在 TryBuildNumberBinop 函数中，turboFan 试图从 feedback_vector
中获取操作数的相关信息。操作数信息一共有以下五种类型：
        // A hint for speculative number operations.
    enum class NumberOperationHint : uint8_t {
      kSignedSmall,        // Inputs were Smi, output was in Smi.
      kSignedSmallInputs,  // Inputs were Smi, output was Number.
      kSigned32,           // Inputs were Signed32, output was Number.
      kNumber,             // Inputs were Number, output was Number.