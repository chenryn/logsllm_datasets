**原文：[Twenty Years of Attacks on the RSA
Cryptosystem](https://www.ams.org/notices/199902/boneh.pdf)**
**作者：Dan Boneh@Stanford
University([PI:EMAIL](mailto:PI:EMAIL))**
**译者：Jing Ling@360ESG A-Team([PI:EMAIL](mailto:PI:EMAIL))**
### 1 介绍
由Ron Rivest，Adi Shamir和Len
Adleman发明的RSA密码系统首次在1977年8月的"科学美国人"杂志上发表（译者注：本文于1999年2月在美国数学学会的Notices杂志首次发布）。密码系统最常用于提供隐私保护和确保数字数据的真实性。目前，RSA部署在许多商业系统中。Web服务器和浏览器使用它来保护Web流量，它可以用于保障电子邮件的隐私和真实性，还可以用于保护远程登录会话，同时它也是电子信用卡支付系统的核心。简而言之，RSA常用于需要考虑数字数据安全性的应用中。
自最初发布以来，RSA系统已被许多研究人员分析认为是易受攻击的。尽管二十年的研究出了许多引人入胜的攻击，但其中没有一个攻击是毁灭性的。这些攻击主要说明了不当使用RSA的危险，可见安全地实施RSA确实也是一项非常重要的任务。我们的目标是使用基础数学的知识分析其中的一些攻击，在整个分析过程中，我们遵循标准命名约定，使用Alice和Bob表示希望彼此通信的两个正常通信方，使用Marvin来表示希望窃听或篡改Alice和Bob之间通信的恶意攻击者。
![
](https://images.seebug.org/content/images/2018/10/6eb2d812-e353-4f52-9595-2d2852d05328.png-w331s)
我们首先介绍一下RSA加密的简化版本。令是比特位长度相同(位)的两个大素数的乘积。常见的长度大小是=1024位（即：309个十进制数字），质因子=512位。令为满足的两个整数，其中是乘法群的阶数。我们称为RSA模数，为加密指数，为解密指数。为公钥。顾名思义，公钥是公开的，并用于加密消息。称为密钥或私钥，一般情况下只有加密消息的接收者知道，私钥能够解密密文。
消息是一个整数且满足，要加密，计算，要解密密文合法接受者计算。（译者注：下面是译者添加的的证明）
> 欧拉定理：若为正整数，且互素（即），则。
>
> 已知，，，，求证。
>
> 证明：
>
> 等式左边为
>
> 等式右边为
等式右边等于等式左边，证毕。
定义一个RSA函数，如果已知，很容易使用等式求出，我们称为求解函数的陷门。在本次课题研究在没有陷门的情况下求解RSA函数，更准确的说，给一个三元组，我们知道在不知道的因子想计算模的根是非常困难的。因为是有限集，因此可以枚举的所有元素直到找到。遗憾的是，这将导致算法具有阶的运行时间，即其输入大小的指数，其为的阶数。我们对运行时间更低的算法感兴趣，即的阶数（其中）或者是一些小的常数（比如说小于5）。实践表明这些算法通常在所讨论的输入情况表现良好，在整篇论文中，我们将此类算法称为高效算法。
此次课题我们主要研究RSA函数而不是RSA密码系统。笼统地说，随机输入上求解RSA函数的应该是非常困难的，也就是意味着给定攻击者无法计算出明文。这还不够，密码系统必须抵御更微妙的攻击。如果给出，想从中计算出任何信息应该是非常难的，这被称为语义安全。我们不讨论这些微妙的攻击，但是必须指出的是如上所述的RSA在语义上是不安全的：给定，可以容易地推导出关于明文的一些信息（例如，可以容易地从推导出上的的雅可比符号）。通过向加密过程添加随机处理流程，可以保障RSA在语义上的安全性。
RSA函数是一个单向陷门函数，正向它可以很容易地计算，但是（据我们所知）除非在特殊情况下，否则在没有陷门的情况下不能有效地反向求解的。单向陷门函数可用于数字签名，数字签名可以保障电子文件的真实性和不可否认性。例如，它们用于签署数字支票或电子采购订单。为了使用RSA对消息进行签名，Alice使用其私钥签名并获得签名。给定之后任何人都可以验证上的Alice签名通过。因为只有Alice可以生成，人们可能会认为攻击者无法伪造Alice的签名。然而事情并非如此简单，为了保障签名的安全还需要一些额外的措施。数字签名是RSA的重要应用，此次课题我们也会研究一些针对RSA数字签名的攻击。
RSA密钥对可以这样生成，选取两个随机位素数并将它们相乘以获得来生成。然后，对于给定的加密指数，使用扩展欧几里德算法计算。由于素数集是足够密集的，因此可以通过重复选择随机位整数并使用概率素性测试对每个素数进行素性测试来快速生成随机位素数。
#### 1.1 大数分解
给了RSA公钥，首先想到的攻击就是分解模数，给了的因子攻击者可以计算得到，从而也可以计算得到解密指数，我们称这种分解模数的方法为针对RSA的暴力攻击。虽然分解算法已经稳步改进，但是在正确使用RSA情况下，当前的技术水平仍远未对RSA的安全性构成威胁。大整数分解是计算数学之美，不过本文研究主题并不是大整数分解。为完整起见，我们顺便提一下，目前普通数字域筛法是效率最高的分解方法。分解位整数需要时间为其中，对RSA进行攻击的方法花费时间超过这个范围就那么吸引人了，比如暴力搜索方法，还有一些RSA发布不久后的旧方法。
我们的目的是研究在不直接分解RSA模数情况下解密消息的攻击方法，值得注意的是，一些RSA模数的稀疏集，可以很容易地被分解，举个例子，如果是乘积的质因子且小于，那么在小于时间内分解。
如上所述，如果存在有效的因式分解算法，则RSA是不安全的，反之亦然。这是一个由来已久的公开问题：必须要有一个的因子才能有效地计算模的根数？破解RSA和因式分解一样难吗？我们在下面提出了具体的开放性问题。
**开放性问题 1**
给定和满足，定义函数：，。是否有多项式时间算法来计算给定的因子以及对于某个求得的一个谕言？
的谕言用于评估在单位时间内任何输入的函数，最近Boneh和Venkatesan提供的证据表明，在比较小的情况下，上述问题的答案可能是否定的。换句话说，在比较小的情况下，可能不存在从分解到破解RSA的多项式时间缩减。他们通过实验表明在某个模型中对小的问题的肯定答案会产生一个有效的因式分解算法。我们注意到，对开放问题1的肯定回答会引起对RSA的"选择密文攻击"。因此，否定的回答可能才是大家喜闻乐见的。
接下来，我们证明公开私钥和分解是等价的。由此可见，对于知道的任何一方来说，隐藏的因式分解是没有意义的。
**事实1**
为RSA的公钥，给定私钥可以有效地分解模数。相反地，给定的因式分解，可以有效地算出私钥。
**证明**
的因式分解得到，因为已知的，那么可以算出，反之亦然。我们现在证明给定可以分解。给定，计算。根据和的定义我们知道是的倍数。由于是偶数，其中为奇数且。对于每个都有，因此是单位模的平方根。根据中国剩余定理，1有四个平方根模。其中两个平方根是，另外两个是，其中满足和。用这最后两个平方根中的任意一个，通过计算来揭示的因式分解。一个直截了当的论证表明，如果从中随机选择，那么序列中的一个元素，,...，是统一平方根的概率至少为1/2，从而揭示了的分解，序列中的所有元素可以在时间内有效地计算，其中。
### 2 基本攻击
我们首先描述一些老的基本攻击，这些攻击说明了RSA的公然滥用情况。虽然存在许多这样的攻击，但我们仅举两个例子。
#### 2.1 共模
为了避免为每个用户生成不同的模数，人们可能希望一劳永逸地固定使用一个，所有用户都使用相同的。可信的中央机构可以向用户提供唯一的一对，，用户从其中生成公钥和私钥。
乍一看，这似乎行得通：为Alice准备的密文无法由Bob解密，因为Bob不知道。但是，这是不正确的，由此产生的系统是不安全的。事实上，Bob可以使用他自己的指数，来分解。一旦被分解，Bob就可以从她的公钥中计算出Alice的私钥。Simmons的这一观察结果表明，RSA模不应被一个以上的实体使用。
#### 2.2 盲化
设是Bob的私钥，而是他相应的公钥。假设攻击者Marvin想要Bob在消息上签名。当然Bob不是傻瓜，他拒绝签署。但是Marvin可以尝试以下方法：他随机选择一个并设。然后他让Bob在随机消息上签名。Bob可能愿意在看上去没什么问题的上签名，但是回想一下，Marvin现在简单地计算就得到Bob在初始上的签名。
这种称为盲化的技术使Marvin能够在他选择的消息上获得有效的签名，方法是让Bob在随机的"盲化"消息上签名。Bob不知道他实际在签名的是什么消息。由于大多数签名方案在签名之前对消息应用"单向散列"算法，因此此种攻击倒不是一个严重的问题。尽管我们将盲化描述为一种攻击，但它实际上是实现匿名数字现金所需的一个有用属性(可以用来购买商品的现金，但不会透露购买者的身份)。
### 3 低私钥指数
为了减少加密时间（或签名生成时间），人们可能希望使用小值而不是随机。由于模幂运算需要花费线性时间为，所以小可以使性能提高至少10倍(对于1024位模数而言)。不幸的是，由M.Wiener发现的一种巧妙的攻击表明，一个小的会导致密码系统完全被攻破。
**定理2（M. Wiener）**
令且，，给定且满足，攻击者可以有效计算出。
**证明**
证明基于使用连分数的逼近，由于，那么存在一个满足。所以，
因此，是的逼近，尽管Marvin不知道，但是他可能会使用去近似。因为（译者注：），（译者注：因为，所以，所以），我们有。
使用替换，我们得到：
现在，，因为，我们知道（译者注：可以得到和）。因此我们得到：
这是一个经典的逼近关系，分数且在约束内非常逼近。实际上，所有类似这样的分数都是的连分数展开的收敛。因此我们首要做的便是计算的连分数的收敛，其中一个连分数就等于。因为，我们有，因此是一个最简分数。这是可以算出密钥的线性时间算法。
由于通常都是1024位，因此必须至少256位长才能避免这种攻击。这对于诸如"智能卡"之类的低功耗设备来说是不幸的，因为小就能节省大量能耗。
然而，并不是毫无办法。Wiener提出了许多能够实现快速解密并且不易受其攻击影响的技术：
**使用大** **：** 假设不是减小模，而是使用作为公钥，其中对于某些大有。
显然，可以代替用于消息加密，当使用大的值时，上述证明中的不再小。一个简单的计算表明，如果，那么无论多小，都无法实施上述攻击。然而，大的值将导致加密时间的增加。
**使用CRT：**
另一种方法是使用中国剩余定理（CRT）。假设选择使得和都很小，比如都是128位。则可以进行如下密文的快速解密：首先计算和。