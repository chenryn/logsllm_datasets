title:HoVer Erasure Codes For Disk Arrays
author:James Lee Hafner
HoVer Erasure Codes For Disk Arrays
∗
James Lee Hafner
Abstract
We present a new family of XOR-based erasure codes
primarily targeted for use in disk arrays. These codes have
a unique data/parity layout, with both horizontal and ver-
tical parity arrangements giving rise to the name HoVer
codes. We give constructions that tolerate up to four disk
failures. Though the codes are only approximately maxi-
mum distance separable (MDS), they have performance ad-
vantages over other codes at many common array sizes. In
addition, they have fewer parameter constraints than many
other codes which enables greater choices and ﬂexibility in
efﬁciency and performance trade-offs.
1. Introduction
Disk array systems have, for the most part, depended on
the fault tolerance of RAID5 to provide reliability for cus-
tomer data in the presence of single-point-of-failure mod-
els. Continuing increases in disk capacity along with lit-
tle improvement in constant bit error rate have reduced the
overall reliability of RAID5 systems to unacceptable levels.
(Other factors also contribute as is noted in [6].) Many era-
sure codes have been proposed over the last 40 years (and
the last 15 years in particular – see Section 2.1) in anticipa-
tion of such a need (and also for their purely scientiﬁc and
theoretical value). However, none of the proposed codes
has become even a de facto standard in the storage industry.
Each code requires some trade-offs and may not be suitable
within a given system’s constraints and requirements.
We introduce a new family of XOR-based erasure codes
for disk arrays or perhaps other reliable storage systems.
They are called HoVer codes because the unique data and
parity layout has both “horizontal” and “vertical” character-
istics not found in (almost) any other code. Within a stripe,
most codes either place all the parity on separate disks from
the data (that is, horizontally aligned across the disks, as in
Reed-Solomon [19] or EVENODD [2]) or they place parity
on the same disks with the data of the stripe (that is, ver-
tically aligned within the disks, as in the X-code [22] and
ZZS [23] codes). The HoVer codes have parity in both hor-
izontal and vertical positions giving rise to their name.
The unique layout of HoVer codes provides some advan-
tages over exclusively horizontal or vertical codes. These
∗
IBM Almaden Research Center, 650 Harry Road, San Jose, CA 95120,
PI:EMAIL
advantages are detailed in Section 4. One key disadvan-
tage of these new codes is that they are not MDS codes (in
coding theory, MDS stands for “maximum distance sepa-
rable” which for our purposes implies maximum storage
efﬁciency for the given fault tolerance). However, as we
will show, the unique layout provides a range of imple-
mentation options that cover a large portion of the perfor-
mance/efﬁciency trade-off space.
We have developed four different constructions of HoVer
codes (see Section 3) that can tolerate two, three (two ver-
sions) and four disk failures. Our 2-fault tolerant con-
struction is completely described theoretically. For the
ﬁrst of our 3-fault tolerant constructions, we provide some
“negative” theoretical results (parameter choices which fail
to provide a valid code) and some incomplete “positive”
results. However, the results of our extensive computer
searches for HoVer constructions yield conﬁgurations that
can be applied in most practical systems where array sizes
are modest (see Section 3 for more on our searches). Our
second 3-fault tolerant construction and our 4-fault tolerant
construction are omitted for brevity – see [9] for the details.
Other constructions within the HoVer layout are possible
and we mention some alternatives in passing.
The paper is organized as follows. We close the introduc-
tion with deﬁnitions of key terms. Section 2 contains a de-
scription of general HoVer codes and their relation to other
work. In Section 3 we give our constructions, focusing on
the 2-fault tolerant case. Section 4 is where we detail some
of the key advantages and trade-offs of the HoVer codes.
Open problems are brieﬂy outlined in Section 5. Finally,
we close with a brief summary and acknowledgements.
1.1. Vocabularly and notations
We present our terminology here to prevent confusion as
many terms have inconsistent usage in the literature.
element: a fundamental unit of data or parity; this is the
building block of the erasure code. In coding theory,
this is a bit within a symbol. For XOR-based codes,
this is the maximally sized data unit of an XOR for-
mula (e.g., a set of sequential sectors).
stripe: a complete (connected) set of data and parity ele-
ments that are dependently related by parity computa-
tion relations. In coding theory, this is a code word; we
use “code instance” synonymously.
strip: (or stripe unit) a unit of storage consisting of all
contiguous elements (data, parity or both) from the
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
X(r− 1,0) X(r− 1,1) ··· X(r− 1, n− 1) H(r− 1,0) ··· H(r− 1, h− 1)
V (0,0)
V (0, n− 1)
2
X(0, n− 1)
X(1, n− 1)
H(0,0)
H(1,0)
h h-parity disks
...
··· H(0, h− 1)
··· H(1, h− 1)
···
···
···
···
2
2
...
...
...
2
X(0,0)
X(1,0)
...
...
...
n-data disks
···
X(0,1)
···
X(1,1)
···
···
···
V (0,1)
...
...
...
V (v− 1,0) V (v− 1,1) ··· V (v− 1, n− 1)
r data
rows
v v-parity
rows
[r, n] codes. X(i, j) represents data elements, H(i, j)
Figure 1: General data layout for HoVert
and V (i, j) represent horizontal and vertical parity elements, respectively. The 2 symbol represents
unused blocks or possibly other h-parity elements. Each column represents a strip (on a disk).
v,h
same disk and stripe. In coding theory, this is asso-
ciated with a code symbol. The set of strips in a code
instance form a stripe. Typically, the strips are all of
the same size (contain the same number of elements).
vertical code: an erasure code in which a (typical) strip
contains both data elements and parity elements (e.g.,
X-code [22]).
horizontal code: an erasure code in which each strip con-
tains either data elements or parity elements, never
both (e.g., EVENODD [2]).
The number of elements in a strip is referred to as the
number of “rows” in the code (in coding theory, this is the
number of bits per symbol). A code with more than one row
is called two-dimensional (see Section 2). The array size is
the total number of strips in a stripe. We use the abbre-
viations v-parity and h-parity for “vertical parity” (aligned
vertically with respect to data elements in a stripe) and “hor-
izontal parity” (aligned horizontally with respect to data el-
ements in a stripe).
2. HoVer codes – data/parity layout
The HoVer codes are two-dimensional codes:
the dia-
gram in Figure 1 shows their general data/parity layout. We
[r, n] where t is
parameterize the HoVer codes as HoVert
the fault tolerance, v is the number of rows of v-parity el-
ements (exclusively), h is the number of strips of h-parity
elements (exclusively), r is the number of data elements per
strip (not on an h-parity strip), and n is the number of strips
containing data elements. The user data substripe is the
r× n upper-left block with entries labeled X(i, j), 0 ≤ i < r,
0 ≤ j < n.
v,h
For symmetry reasons, the 2 elements in the array are
ideally left unused. Alternatively, the space on disk may be
used for meta-data, or by data or parity from other stripes
with appropriate rotations, packing and logical addressing.
It is possible to also use these spaces for additional data or
parity elements, but we do not consider such constructions
here. However, since we have v and h small (see inequal-
ity (1)), wasting this space is insigniﬁcant in practice.
Clearly, any erasure code can be put in this form, with
perhaps an additional set of strips that contain data ex-
clusively. Purely horizontal codes have v = 0 and purely
v + h ≤ t,
[1,n], EVENODD is HoVer2
0,2
vertical codes have h = 0. As examples, RAID4 is
[p − 1, p], the X-
HoVer1
0,1
[p− 2, p] but the ZZS code with v = 1,h =
code is HoVer2
0,t = 2,r = (p−3)/2,n = p−1 requires an additional data-
2,0
only strip with r + 1 data elements. (We use the symbol p
exclusively to represent a prime number.)
The novelty of the HoVer codes occurs when both v and h
are non-zero, so we reserve the name HoVer for these cases.
In all our constructions, each data element “touches” (or
contributes to the parity formula for) exactly t parity ele-
ments. This is the theoretical minimum for erasure codes of
t-fault tolerance (and implies optimal bit update complex-
ity). With this restriction, we also make the assumption
(1)
since the most efﬁcient use of the parity element space puts
each data element in each parity strip and each parity row
at least once (for a total of exactly t times). Consequently, a
true HoVer code must have t ≥ 2 (the interesting case!).
This general description of HoVer codes is incomplete
since we have only speciﬁed data and parity element place-
ment; we have not speciﬁed how the parity values are com-
puted.
It turns out that only certain combinations of the
parameters can provide for a valid code regardless of how
the parity values are computed (see Section 2.2). In Sec-
tion 3 we give formal deﬁnitions for parity XOR formulas
that yield valid codes under certain additional necessary and
in some cases sufﬁcient conditions.
In addition, we assume that the ﬁrst h-parity strip is the
simple XOR of the data substrips (that is, we assume a
RAID4 subcode). So, for 0 ≤ i ≤ r− 1, we set
H(i,0) = n−1(cid:1)
j=0
X(i, j).
(2)
This is not strictly required but is a reasonable assumption in
practice, as it extends a standard RAID4 code. When there
is only one h-parity strip, we abbreviate H(i) = H(i,0).
2.1. Related work – other codes
There are many erasure codes that have been presented in
the literature for application to disk arrays. For ease of com-
parison to HoVer codes, we divide the set of known erasure
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
codes into different categories and give (non-exhaustive)
examples in each category.
In a category by themselves
are the Reed-Solomon codes [19], which are MDS but re-
quire complex ﬁnite ﬁeld arithmetic. Second are XOR-
based codes that are MDS. These come in two types: ver-
tical codes such as the X-code [22], BCP [1] or the B-
codes [21] (which superset the ZZS codes [23]) and hori-
zontal codes such as EVENODD [2, 3], Blaum-Roth [4], or
Row-Diagonal Parity [6] (XOR-based implementations for
Reed-Solomon codes ﬁt in this group as well – see [5]).
Finally, there are non-MDS codes that are XOR-based.
These subdivide into three categories based on the storage
efﬁciency, that is, on the ratio of amount of user data to the
total amount of data plus redundancy in a stripe. The cat-
egories are exempliﬁed by the following: (a) the Gibson et
al codes [8] with efﬁciency larger than 50%; (b) codes with
efﬁciency exactly 50% such as the LSI [20], the Blaum-
Roth [4] 3-fault tolerant code and some of the WEAVER
codes [10, 11]; and (c) codes with efﬁciency below 50%
such as N-way mirroring (trivially XOR-based) or the dual
B-codes [21]. The dual B-codes [21] are in fact MDS, and
have high fault tolerance but extremely low efﬁciency (ap-
proximately 2/N for array size N). For even N, these codes
are purely vertical with r = 1 and v = (N − 2)/2; for odd N,
they are in fact HoVer-like with r = 1 and v = (N − 1)/2.
There are WEAVER codes [10, 11] of efﬁciency less than
50% but we ignore them here.
We mention also LDPC codes [7, 15] (or see [17, 18] in
the context of storage systems) which technically belong in
the class of non-MDS, XOR-based, efﬁciency larger than
50% codes. These codes have highly irregular graph struc-
tures but can have near optimal efﬁciency and high aver-
age fault-tolerance – minimum fault tolerance, t, is not dis-
cussed. They are suggested for use in distributed, wide-area
network storage systems, where the erasure model is delay
or loss of packets. It is our opinion (and open to debate) that
these codes are not well-suited to controller-based storage
systems (to which we target HoVer codes) where minimum
fault-tolerance goals must be achieved.
With the exception of the Reed-Solomon codes, some
WEAVER codes, LDPC codes, N-way mirroring or the dual
B-codes, none of the codes have exceptionally high fault
tolerance. There are extensions of EVENODD [3] that are
3 and 4 fault tolerant; the Blaum-Roth [4] binary code of ef-
ﬁciency 50%, the STAR code [14] (a variation on extended
EVENODD) and two codes in [8] are 3 fault tolerant. As
far as we know, none of the other codes have variants that
can tolerate more than 2 failures.
Throughout the paper, we highlight the features (both
positive and negative) of the HoVer codes when compared
against these categories (typically by speciﬁc example). We
disregard a comparison with Reed-Solomon, since we are
concerned primarily with XOR-based codes. Similarly,
since the HoVer codes are high efﬁciency and approxi-
mately MDS (see Section 4.1), we do not do comparisons