some adjacent encoded input, or (ii) the original message
mi, if message exchange did not take place for ui because
there was no matching dead drop or due to conﬂict (three
or more equal dead drops). As already mentioned, the
LSB of two exchanged messages is set to 1. In the special
conﬂict case where three or more values share the same
dead drop t, an arrangement would be as follows:
. . . , (t(cid:48),mk,k), (t,m j, j), (t,mi,i), (t,mi(cid:48),i(cid:48)), . . .
In this case, the messages of ui and u j will be exchanged
and ui(cid:48) will obtain back his message at the end of the
protocol, notifying him to resubmit.
5. Sorting by wire IDs: As in the Dialing protocol
(Step 5), the Conversation protocol performs a Quicksort
on the processed requests according to their mutually dis-
tinct wire IDs in order for the correct requests to be for-
warded to each user. The result is a vector (cid:104)ˆb1, . . . , ˆbn(cid:105)
where ˆbi is a pair (ˆbi[1], ˆbi[2]) that corresponds to ui and
is either (i) a message m j from some user u j or (ii) the
original message mi, in both cases indexed by widi.
6. Forwarding messages: At the end, the protocol dis-
cards the wire IDs and creates the output vector y =
(cid:104)y1, . . . ,yn(cid:105) := (cid:104)ˆb1[1], . . . , ˆbn[1](cid:105). Thus, each yi is either
(i) a message m j from some user u j or (ii) the self-
generated message mi. Finally, the users u1, . . . ,un are
delivered the values y1, . . . ,yn.
Remark 3. In reality, the dead drop value ti of some user
ui is not exactly the value she received from a dialing
protocol execution. For conversation round r it is com-
puted as ti := H(t(dialing)i,r), where t(dialing)i is the dead
drop for ui, generated by the dialing protocol and acts as
the seed for the creation of an ephemeral dead drop for
each conversation round.
Remark 4. Due to the size of dead drops values, the
probability that a collision on randomly generated dead
drop values will occur can be made very small. Even in
the case of a collision, the client of the user that was af-
fected would just resend that message in the next round,
as it would know that a collision occurred because it re-
ceived a message it could not decrypt.
The Conversation program CNVsort .
The program
USENIX Association
26th USENIX Security Symposium    1227
CNVsort implementing the Conversation protocol is pre-
sented in Fig. 5.
The Conversation Program CNVsort
Input: a sequence (cid:104)x1, . . . ,xn(cid:105) where xi
is either a
(CONV,ti,mi) request, or ⊥. All ⊥ inputs are stacked
last.
Output: a sequence of messages (cid:104)yi(cid:105)xi(cid:54)=⊥.
1. For each i ← 1, . . . ,n
if xi = ⊥ then
Set act := i− 1 ;
Break loop ;
end if
if xi = (CONV,ti,mi) then
Set a := (ai[1],ai[2],ai[3]) ← (ti,mi,0) ;
end if
2. For each i ← 1, . . . , act
Set widi as ai[3] ← i ;
3. Sort tuples (cid:104)ai(cid:105)xi(cid:54)=⊥ according to ﬁrst coordinate
ai[1] using Quicksort;
4. For each i ← 1, . . . , act− 1
if ai[1] = ai+1[1] AND LSB(ai[2]) = LSB(ai+1[2]) = 0
then
Set the LSB of ai[2] and ai+1[2] to 1 ;
Set bi ← (ai+1[2],ai[3]) ;
Set bi+1 ← (ai[2],ai+1[3]) ;
end if
5. Sort tuples (cid:104)bi(cid:105)i:xi(cid:54)=⊥ according to second coordi-
nate (which is the wire id) using Quicksort;
6. For each i ← 1, . . . , act
Set yi ← bi[1] ;
return y := (cid:104)yi(cid:105)i:xi(cid:54)=⊥ .
Figure 5: The Conversation program CNVsort realizing the
Conversation program CNVabs for conversation round r,
dead drop size κ ≥ 64 and users u1, . . . ,un with messages
taken from space M.
Following Section 3, we show that CNVsort realizes the
member of the Conversation program family CNVabs that
corresponds to our sorting process. Namely, in Step 3 of
CNVsort (Sorting by dead drops), the inputs are arranged
according to an ordering of their ﬁrst coordinate. Thus,
we set the index z that parameterizes the family CNVabs to
be the string zqs1 as follows: zqs1 is parsed as the deter-
ministic program Rzqs1
CNV that takes as input an index i and
array of triples x in encoded form, and outputs the index
j so that when the array is sorted according to Quicksort
ordering on the ﬁrst coordinate, the encoded triple of ui
(or resp. u j) has no neighbors on the left of the sorted
array and the encoded triple of u j (or resp. ui) is the right
neighbor of the encoded triple of ui (or resp. u j). For-
mally, we state the following theorem and provide the
proof in the full version of the paper.
Theorem 2. Let n be the number of users and κ ≥ 64 be
the dead drop string length. The Conversation program
CNVsort described in Fig. 5 implements the member of the
Conversation program family CNVabs described in Fig. 3
for parameter zqs1.
7 The MCMix Anonymous Messaging Sys-
tem
Having presented the general architecture of our system
in Section 4 and the Dialing and Conversation protocols
and programs in Sections 5 and 6 respectively, we now
show how these programs are implemented in our archi-
tecture. Our system consists of two MPC instances of the
general architecture in Section 4, executing one after the
other or independently in parallel. One implements the
Dialing protocol and the other the Conversation protocol.
Below, we specify the operations of general architecture
for each of our two protocols. We note with the prime
symbol, e.g. 1’. , the speciﬁcation of the respective step,
e.g. 1. , of the general architecture.
Dialing. The execution of the Dialing protocol for round
r follows the steps of section 4 with the following partic-
ularities:
1’. Encoding: The input of user ui is encoded as ai =
(UNi, UN j,0), in the case of a dial to user u j, or as ai =
(C, UNi,0) in the case of a dial request, as speciﬁed by
Step 1 of the Dialing program DLNsort in Fig. 4.
6’. MPC algorithm: The MPC server secure computa-
tion consists of Steps 2-6 of DLNsort.
8’. Decryption and reconstruction: The recon-
structed value bi received by user ui is the output bi of
Step 6 of DLNsort.
9’. Dead drop calculation: As an extra step, the dead
drop value ti is calculated by each user by performing
Step 7 of DLNsort.
Conversation. The execution of the conversation pro-
tocol for round r follows the steps of Section 4 with the
following particularities:
1’. Encoding: Input is encoded as ai = (ti,mi,0), with
ti being a dead drop calculated by the ﬁnal step of a pre-
vious dialing round in the case of a real conversation re-
quest (also taking into account Remark 3), or a random
value in the case the user does not want to send a mes-
sage (but still wants to protect her privacy), according to
the Conversation program CNVsort in Fig. 5.
1228    26th USENIX Security Symposium
USENIX Association
6’. MPC algorithm: The MPC server secure computa-
tion consists of Steps 2-6 of CNVsort.
8’. Decryption and reconstruction: The recon-
structed value bi received by the user that provided input
i is the output yi of Step 6 of CNVsort and is the message
intended for this user.
Security of MCMix. We prove our security theorem
for the general θ-out-of-m case, as in Deﬁnition 1, using
the parameters zqs2 and zqs1 deﬁned in Sections 5 and 6
respectively. We provide the proof in the full version.
Theorem 3. Let κ be the dead drop size, n be the num-
ber of users, m be the number of servers and q the size
of the underlying Difﬁe-Hellman group, where n,m are
polynomial in λ , κ = Θ(λ ) and q = Ω(2λ ). Let P be a
(θ ,m)-secure MPC protocol with n users w.r.t.
(i) the
Server Computation Steps 2-6 of the Dialing program
DLNsort described in Fig. 2 and (ii) the Server Compu-
tation Steps 2-6 of the Conversation program CNVsort de-
scribed in Fig. 3. Then, MCMix implemented over P is
an anonymous messaging system by securely realizing
the program families DLNabs and CNVabs for parameters
zqs2 and zqs1 respectively.
Remark 5 (On forward security of MCMix). MCMix
in its current form does not offer forward security. Nev-
ertheless it is possible to provide forward security as fol-
lows. First, clients could refresh their exchanged keys
with the servers in regular time intervals, e.g., once a
day. Alternatively to avoid interaction, forward secure
encryption can be used, e.g., see [9]. With respect to the
dead drop calculation we can obtain forward security by
applying our second ID-KA construction with forward
secrecy (cf. Section 2 and the full version). The addi-
tional communication cost to the Dialing protocol would
be one extra random group element per user as now the
active inputs x1, . . . ,xn for dialing need to be used for
the ﬁrst round of the exchange; they are of the form of
(DIAL,ui,u j,ri) and (DIALCHECK,ui,r j), where ri,r j
are random elements from the ID-KA cyclic group. Sort-
ing would still be executed on the users’ usernames and
the wire IDs as before thus incurring no additional over-
head. We omit further details.
8
Implementation and Benchmarking
We implemented a prototype of our system using the
Sharemind platform and performed extensive evaluation.
Experiment setting. Benchmarks were run on a cluster
of three machines with point-to-point 1 Gbps network
connections using various proﬁles for network latency
aiming to simulate WAN behavior. Each machine has
a 12-core 3 GHz Hyper-Threading CPU and 48 GB of
RAM. However, even though the hardware supports it,
Sharemind MPC protocols are not optimized to use mul-
tiple CPU cores or network layer in a parallel manner.
The servers running Sharemind employ only 2 cores, one
for executing the computations and another for pseudo-
random number generation. To simulate real-world envi-
ronment, we use the tc tool to manipulate operating sys-
tem’s network trafﬁc control settings. This tool is used
to both cap the available network bandwidth, as well as
introduce communication latency by adding round-trip
delay (ping).
L = 0ms
L = 2ms
L = 10ms
L = 20ms
103
102
101
100
]
s
c
e
s
[
e
m
i
t
i
g
n
n
n
u
R
102
103
104
No. of users
105
Figure 6: Running time in secs of the Dialing protocol
implementation for a number of n = 100, 500, 1K, 5K,
10K, 50K, 100K, 500K users and latency L = 0, 2, 10,
20 ms. The benchmarks were run with message size 8
Bytes and 1 Gbps network bandwidth.
Dialing protocol. We benchmarked our dialing protocol
for various numbers of users and various latency values.
The results are presented in Fig. 6. As we can see, the
dialing protocol has a runtime for each round of around
one minute for 100,000 users and around 300 seconds
for 500,000 users, considering the worst case of 20 ms of
latency. The latter value might still be considered accept-
able for some settings, as dialing rounds need not be exe-
cuted very often. Another interesting observation is that
the effect of latency diminishes as the number of users
increases, due to the fact that the number of communica-
tion rounds of our algorithm scales logarithmically to the
number of inputs. This in turn happens because Quick-
sort needs O(log(n)) steps to sort n inputs when executed
in parallel. The vectorized nature of our implementation
succeeds in taking advantage of the parallelizable nature
of the algorithm. The time a user needs to encode her
request and send it, as well as the time required by each
MPC server to decrypt the requests it received have no
effect on the per round runtime of our system. This is be-
USENIX Association
26th USENIX Security Symposium    1229
cause these operations are performed in a pipelined fash-
ion. This means that the encoding, encryption and de-
cryption of the requests for round r + 1 takes place while
the MPC servers perform the computations for round r.
In the dialing protocol this is acceptable as a user’s in-
tent on whether to dial or perform a dial check might not
depend on the output of the previous dialing round.
Conversation protocol. For the conversation protocol we
made extensive benchmarks considering the number of
users, the latency of the network, as well as the message
size. In Fig. 7, we can see that the running time of the
conversation protocol with a very small message size of
8 Bytes (B) is similar to the running time of the dialing
protocol. That is, the system can serve 100,000 users
with in around one minute for maximum latency of 20
ms. Again, we see that latency is a minor performance
factor for a large number of users. This fact enables us
to claim that our system will have similar running times
even with greater latency values.
i.e. bytes sent and received and to both other computing
nodes. We observe that in both protocols the bandwidth
consumption remains at a low level of less than 100Mbps
for the Dialing protocol for (usernames of 64bits) as well
as the Conversation protocol for messages of up to SMS
size. For bigger message sizes and 100,000 users, we
get that the total consumption is roughly 150Mbps and
300Mbps for messages of 256B and 1KB respectively,
which can be realistic for a large scale setting.
|M| =8B
|M| =144B
|M| =256B
|M| =1KB
102
101
100
]
s
c
e