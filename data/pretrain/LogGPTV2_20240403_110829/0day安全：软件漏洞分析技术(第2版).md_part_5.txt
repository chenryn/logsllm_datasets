变成一件多么困难的事情！
PE文件格式把可执行文件分成若干个数据节（section），不同的资源被存放在不同的节中。
一个典型的PE文件中包含的节如下。
软件漏洞分析技术
.text由编译器产生，存放着二进制的机器代码，也是我们反汇编和调试的对象。
.data初始化的数据块，如宏定义、全局变量、静态变量等。
idata可执行文件所使用的动态链接库等外来函数与文件的信息。
rsrc存放程序的资源，如图标、菜单等。
题外话：如果是正常编评出的标准PE文件，其节信息往往是大致相同的。但这些
section的名字只是为了方使人的记忆与使用，使用MicrosoftVisualC++中的编译指示
（第2版）
符#pragmadata6egO可以把代码中纳任意部分脑译到PE的任意节中，节名也可以自
已定义。如果可执行文件经过了加壳”处理，PE的节信息就会变得非常“古怪”。
在Crack和反病毒分析中富安经常处理这类古怪的PE文件
1.2.2虚拟内存
Windows的内存可以被分为两个层面：物理内存和虚拟内存。其中，物理内存比较复杂，
需要进入Windows内核级别ringO才能看到。通常，在用户模式下，我们用调试器看到的内存
地址都是虚拟内存。
如图1.2.1所示，Windows让所有的进程都“相信”自己拥有独立的4GB内存空间。但是，
我们计算机中那根实际的内存条可能只有512MB，怎么可能为所有进程都分配4GB的内存呢？
这一切都是通过虚拟内存管理器的映射做到的。
属于进程1
属千进程2
属于进程3
的虚拟内存
的虚报内存
的虚报内存
(4GB)
(4GB)
(4GB)
用户态
Ring3
核心志
Ringo
真正的物理内存
512MB
图1.2.1Windows虚拟内存与物理内存示意图
---
## Page 32
第
虽然每个进程都“相信”自己拥有4GB的空间，但实际上它们运行时真正能用到的空间
1
根本没有那么多。内存管理器只是分给进程了一片“假地址”，或者说是“虚拟地址”，让进程
章
们“认为”这些“虚拟地址”都是可以访问的。如果进程不使用这些“虚拟地址”，它们对进
基
础
拟地址”和“物理地址”联系起来。
知
Windows的内存管理机制在很大程度上与日常生活中银行所起的金融作用有一定的相似
识
性，我们可以通过一个形象的比方来理解虚拟内存。
●进程相当于储户。
●内存管理器相当于银行。
●物理内存相当于钞票。
●虚拟内存相当于存款。
·进程可能拥有大片的内存，但使用的往往很少：储户拥有大笔的存款，但实际生活中
的开销并没有多少。
·进程不使用虚拟内存时，这些内存只是一些地址，是虚拟存在的，是一笔无形的数字财富。
·进程使用内存时，内存管理器会为这个虚拟地址映射实际的物理内存地址，虚拟内存
地址和最终被映射到的物理内存地址之间没有什么必然联系：储户需要用钱时，银行
才会兑换一定的现金给储户，但物理钞票的号码与储户心自中的数字存款之间可能并
没有任何联系。
·操作系统的实际物理内存空间可以远远小于进程的虚拟内存空间之和，仍能正常调度：
银行中的现金准备可以远远小于所有储户的储蓄额总和，仍能正常运转，因为很少会
出现所有储户同时要取出全部存款的现象：社会上实际流通的钞票也可以远远小于社
会的财富总额。
题外话：实际上，金融学、经济学、管理学中有很多概念和理论与计算机科学中的知
识出奇相似。有时将这些知识互相类比一下会获符一种融会责通的清美。
进程所拥有的4GB虚拟内存中包含了程序运行时所必需的资源，比如代码、栈空间、堆
空间、资源区、动态链接库等。在后面的章节中，我们将不停地辗转于虚拟内存中的这些区域。
注意：操作系统原理中也有“虚拟内存”的概念，那是指当实际的物理内存不够时，
本书除第4篇内核安全外，其余所述之“内存”均指Windows用户态内存映射机制下
的虚拟内存。
1.2.3PE文件与虚拟内存之间的映射
在调试漏洞时，可能经常需要做这样两种操作。
（1）静态反汇编工具看到的PE文件中某条指令的位置是相对于磁盘文件而言的，即所谓
---
## Page 33
0
day
的文件偏移，我们可能还需要知道这条指令在内存中所处的位置，即虚拟内存地址（VA）。
安
（2）反之，在调试时看到的某条指令的地址是虚拟内存地址，我们也经常需要回到PE文
全
件中找到这条指令对应的机器码。
：
为此，我们需要弄清楚PE文件地址和虚拟内存地址之间的映射关系。首先，我们先看几
软件漏
个重要的概念。
（1）文件偏移地址（FileOffset）
洞分析技
数据在PE文件中的地址叫文件偏移地址，个人认为叫做文件地址更加准确。这是文件在
磁盘上存放时相对于文件开头的偏移。
（2）装载基址（ImageBase）
术
PE装入内存时的基地址。默认情况下，EXE文件在内存中的基地址是0x00400000，DLL
（第
文件是0x10000000。这些位置可以通过修改编译选项更改。
（3）虚拟内存地址（VirtualAddress，VA）
2
版
PE文件中的指令被装入内存后的地址。
（4）相对虚拟地址（RelativeVirtualAddress，RVA）
相对虚拟地址是内存地址相对于映射基址的偏移量。
虚拟内存地址、映射基址、相对虚拟内存地址三者之间有如下关系。
VA= Image Base+ RVA
如图1.2.2所示，在默认情况下，一般PE文件的0字节将对映到虚拟内存的0x00400000
位置，这个地址就是所谓的装载基址（ImageBase)。
内存
PE文件
其他
0200字节
ep
千
0200字节
rdata节
t节
1十
1
00x0
tet节
PE文件起始
文件头、节表等
节
文件头、节表等
图1.2.2PE文件与虚拟内存的映射关系
文件偏移是相对于文件开始处0字节的偏移，RVA（相对虚拟地址）则是相对于装载基址
---
## Page 34
第
0x00400000处的偏移。由于操作系统在进行装载时“基本”上保持PE中的各种数据结构，所
1
以文件偏移地址和RVA有很大的一致性。
章
基
位与内存数据存放单位不同而造成的。
础
（1）PE文件中的数据按照磁盘数据标准存放，以0x200字节为基本单位进行组织。当一
知
个数据节（section）不足0x200字节时，不足的地方将被0x00填充：当一个数据节超过0x200
识
字节时，下一个0x200块将分配给这个节使用。因此PE数据节的大小永远是0x200的整数倍。
（2）当代码装入内存后，将按照内存数据标准存放，并以0x1000字节为基本单位进行组
织。类似的，不足将被补全，若超出将分配下一个0x1000为其所用。因此，内存中的节总是
0x1000的整数倍。
差异”
表1-2-1文件偏移地址和RVA之间的对应关系
节（section）
相对虚拟偏移量RVA
文件偏移量
.text
0x00001000
0x0400
.rdata
0x00007000
0x6200
.data
0x00009000
0x7400
.rsrc
0x0002D000
0x7800
由于内存中数据节相对于装载基址的偏移量和文件中数据节的偏移量有上述差异，所以进
行文件偏移到虚拟内存地址之间的换算时，还要看所转换的地址位于第几个节内。
我们把这种由存储单位差异引起的节基址差称做节偏移，在上例中：
text节偏移=0x1000-0x400=0xc00
rdata节偏移=0x7000-0x6200=0xE00
.data节偏移=0x9000-0x7400=0x1C00
rsrc节偏移=0x2D000-0x7800=0x25800
那么文件偏移地址与虚拟内存地址之间的换算关系可以用下面的公式来计算。
文件偏移地址=虚拟内存地址（VA）-装载基址（ImageBase）-节偏移
=RVA-节偏移
以表1-2-1为例，如果在调试时遇到虚拟内存中0x00404141处的一条指令，那么要换算出
这条指令在文件中的偏移量，则有：
文件偏移量=0x00404141-0x00400000--（0x1000-0x400)=0x3541
一些PE工具提供了这类地址转换，LordPE就是其中出色的一款，如图1.2.3所示。
单击“PEEditor”按钮，选择需要查看的PE文件，如图1.2.4所示。
---
## Page 35
day 安全：软件漏洞分析技术
0
PO
00000000
00000004
00000000
00000000
00000000
000003OC
48580000
0000000o
0000F000
000003eC
4AG80000
00005000
图1.2.3LordPE使用1
查看节信息
（第2版）
0002
C004
3E746734
00000400
查看导入
导出表等
]
FLC
500
00000200
0OEO
TOSC
NnORvs
L
地址换算
图1.2.4LordPE使用2
用这个工具可以方便地查看PE文件中的节信息，对应于前面表格中的例子，如图1.2.5
所示。也可以方便地换算虚拟内存地址，文件偏移地址和RVA，如图1.2.6所示。
虚拟内存地址
文件偏移地址
00001000
VOse
000050CA
00007000
000011D4
00000400
00006200
00005E0O
dale
00007400
00001200
0002D000
0000S000
00003000
000238FC
00000400
00002200
000200
SaeoiOptondHeader
3010
NunORvsAndSonr
0000
图1.2.5
5LordPE使用3
VA
504141
FVA:
00004141
OiCad
0003541
1Da4
Seciort
00000080FF359C924000
Bytes:
图1.2.6LordPE使用4
10
---
## Page 36
第
1.3必备工具
1
真
1.3.1OllyDbg简介
基
础
Ollydbg是一个集成了反汇编分析、十六进制编辑、动态调试等多种功能于一身的功能强
知
大的调试器。它安装简单，甚至不需要点击安装文件就能直接运行：它扩展性强，您甚至可以
识
为自己写出有特殊用途的插件；它简单易用，初学者只需要知道几个快捷键就能立刻上手
Olldbg的优点实在是数不胜数，现在已经成为主流调试器之一。
与SoftICE和WinDbg相比，Ollydbg虽然无法调试内核，但其人性化的GUI界面省去了
初学者往往望而却步的调试命令，您需要的只是掌握五六个快捷键，然后用鼠标click，click，
click.....
OllyDbg并非浪得虚名，在用户态调试中，真的只要有它“onlyone”，就可以走退天下都
不怕了。它的主功能界面在默认情况下分为5个部分，让您在调试过程中轻松掌握指令、内存、
栈、寄存器等重要信息。除此以外，如果您是习惯于在SofuICE和WinDbg上敲调试命令的程
序员，OllyDbg也体贴地为您保留了调试命令的debug方式。
这里只介绍6个最基本的功能快捷键，知道它们就可以基本用起这个调试器了，如表1-3-1
所示。
表1-3-1基本功能快捷键
快捷键
功能
说明
F8
单步执行
遇到函数调用指令不跟入（Stepover）
F7
单步执行
遇到函数调用指令跟入（Stepin）
F2
设置断点
在一条指令上按F2键将设置断点，再按一次将取消断点
F4
执行到当前光标所选中的指令
在遇到循环时可以方便地用F4键执行到循环结束后的指令
F9
运行程序
运行程序直到遇到断点
Ctrl+G
这个功能键非常有用，在指令区、栈区、内存区都可以使用，
查看任意位置的数据
能方便地查看任意位置的指令和数据
其调试界面如图1.3.1所示。
本书中绝大部分调试实验都将使用OllyDbg，您会在后面章节中频繁见到这个调试器。相
信您在跟随我们完成几个调试实验之后，一定会对这款调试器有一个较深层次的掌握，甚至爱
不释手。
OllyDbg博大精深，其内存断点、内存跟踪（trace）、条件断点和众多插件的功能将在后续
章节中陆续进行介绍。
1.3.2SoftlCE简介
SoftICE可能是最德高望重的调试器了，它功能强大，工作在ringO级，因此可调试驱动
等内核对象。
1
---
## Page 37
0
day
代码区：可显示指令地址、机器码、指令、注释、对于寄存器区：可以实时查看所
常用函数的调用.OtyObg其至可直接将函数名翻译出来有寄存器的变化情况
安
Aavh tosnt]
全
：
软
件
预执行区：提输计算出当前
漏
指令的运算结果提示所需
寄存器中的值，这个功能对
洞分析技
于掌抛条件跳转类指令的去
向非常有用
技
术
2
版
内存区：可以用快捷键Ctr+G方便地查看和修改内存
栈区：除了地址和内容的显示外，
还会在注释区自动标注返回地址、
外，注释区还可以按照ASC和Unicode两种形式对十六
进制数据进行评码，方使您发现字符申等敏感数据