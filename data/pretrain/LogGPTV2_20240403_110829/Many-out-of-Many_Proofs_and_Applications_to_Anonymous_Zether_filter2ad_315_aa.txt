title:Many-out-of-Many Proofs and Applications to Anonymous Zether
author:Benjamin E. Diamond
6
2
0
0
0
.
1
2
0
2
.
1
0
0
0
4
P
S
/
9
0
1
1
.
0
1
:
I
O
D
|
E
E
E
I
1
2
0
2
©
0
0
.
1
3
$
/
1
2
/
5
-
4
3
9
8
-
1
8
2
7
-
1
-
8
7
9
|
)
P
S
(
y
c
a
v
i
r
P
d
n
a
y
t
i
r
u
c
e
S
n
o
m
u
i
s
o
p
m
y
S
E
E
E
I
1
2
0
2
2021 IEEE Symposium on Security and Privacy (SP)
Many-out-of-Many Proofs and Applications to
Anonymous Zether
Benjamin E. Diamond
J.P. Morgan AI Research
New York, United States
PI:EMAIL
Abstract—Anonymous Zether, proposed by B¨unz, Agrawal,
Zamani, and Boneh (FC’20), is a private payment design whose
wallets demand little bandwidth and need not remain online;
this unique property makes it a compelling choice for resource-
constrained devices. In this work, we describe an efﬁcient
construction of Anonymous Zether. Our protocol features proofs
which grow only logarithmically in the size of the “anonymity
sets” used, improving upon the linear growth attained by prior
efforts. It also features competitive transaction sizes in practice
(on the order of 3 kilobytes).
Our central tool
is a new family of extensions to Groth
and Kohlweiss’s one-out-of-many proofs (Eurocrypt 2015), which
efﬁciently prove statements about many messages among a list
of commitments. These extensions prove knowledge of a secret
subset of a public list, and assert that the commitments in the
subset satisfy certain properties (expressed as linear equations).
Remarkably, our communication remains logarithmic; our com-
putation increases only by a logarithmic multiplicative factor.
This technique is likely to be of independent interest.
We present an open-source, Ethereum-based implementation
of our Anonymous Zether construction.
Index Terms—Applied cryptography, blockchains and dis-
tributed ledger security, privacy technologies and mechanisms.
I. INTRODUCTION
Blockchain-based cryptocurrencies like Bitcoin [1] allow
their mutually distrustful participants to maintain shared com-
putational state. These systems generally encode this state—as
well as the transactions which incrementally modify it—“in
the clear”, and so afford to these participants only cursory
privacy (we refer to, e.g., Ron and Shamir [2]).
This deﬁciency has impelled the development of “privacy-
preserving” alternatives, most notably Zcash [3] and Mon-
ero [4]. These systems encode their state cryptographically,
and deﬁne transactions which privately and securely modify
this state (frequently with recourse to non-interactive zero-
knowledge proofs).
Fauzi, Meiklejohn, Mercer, and Orlandi’s Quisquis [5]
identiﬁes an issue with these latter systems, whereby their
computational state grows linearly over time. Indeed, these
systems must store all TXOs (even those which have been
spent); in fact, it is impossible to discern which have been
consumed. Though Quisquis’ state size scales linearly in its
user-base, it scales only constantly in time.
A subtler issue prevents the use even of Quisquis in the
most resource-constrained devices. In fact, all three systems
feature a property whereby each wallet—in order to determine
in practice,
its user’s account state—must scan through the entirety of the
cryptocurrency’s present state. This computational requirement
demands,
that wallets be stateful, and remain
synchronized—so as to “amortize” this cost incrementally—
as well as that they “catch up” after each period of inactivity
(expending computational effort proportional to the throughput
processed by the network during the period of inactivity). This
burden imposes a prohibitive cost on resource-limited wallets.
A. Anonymous Zether
Anonymous Zether is a paradigm for private payment, pro-
posed in B¨unz, Agrawal, Zamani, and Boneh [6, §D]. Anony-
mous Zether features an intriguing property whereby a wallet
(which, we assume, has reliable access to the blockchain’s cur-
rent state) may determine its user’s own account state in only
constant bandwidth, and using only constant computational
effort; in fact, this effort is independent of the system’s overall
state size, as well as of the time elapsed since the wallet last
synchronized. This property distinguishes Anonymous Zether
from Zcash and Monero—as well as from Quisquis—and
makes Anonymous Zether a compelling candidate for use in
low-bandwidth and low-power devices.
We pause to review the approach of Anonymous Zether.
The system maintains a global table of “accounts”, which as-
sociates, to each public key, an El Gamal ciphertext under that
key (encrypting that key’s account balance “in the exponent”).
This table, we emphasize, can be queried in constant time.
To send funds, a user selects a ring containing herself and
the recipient, and encrypts, under the ring’s respective keys, the
amounts by which she intends to alter each account’s balance.
The administering environment (e.g., smart contract) applies
these adjustments homomorphically. Finally, the user proves
that her transaction preserves all monetary invariants. These
invariants are captured by the relation [6, (8)] (see also (1)
below), which encodes, in particular, that value is conserved,
and ﬂows only from some account whose secret key the prover
knows, as well as that no overdrafts occur.
An illustration of the key relation (1) is given in Fig. 1
below. Given 8 public keys (y0, . . . , y7), each with a standing
account balance of 100, the two statements of Fig. 1 do and
do not, respectively, have a valid witness in the sense of (1). In
particular, in the latter statement, y1 overspends, excessively
credits the recipient y6, alters the balance of the decoy party
y4, and encrypts y7’s adjustment under the wrong key.
© 2021, Benjamin E. Diamond. Under license to IEEE.
DOI 10.1109/SP40001.2021.00026
1800
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:00 UTC from IEEE Xplore.  Restrictions apply. 
{
}
y0 : Ency0 (g0; r),
y1 : Ency1 (g−60; r),
y2 : Ency2 (g0; r),
y3 : Ency3 (g0; r),
y4 : Ency4 (g0; r),
y5 : Ency5 (g0; r),
y6 : Ency6 (g60; r),
y7 : Ency7 (g0; r),
{
}
y0 : Ency0(g0; r),
y1 : Ency1(g−120; r),
y2 : Ency2(g0; r),
y3 : Ency3(g0; r),
y4 : Ency4(g10; r),
y5 : Ency5(g0; r),
y6 : Ency6(g150; r),
y7 : Ency2(g0; r),
this setting, the wallet must download 2·N ciphertexts for each
transaction whose anonymity set intersects its subscription list.
This contrasts favorably with Zcash and Monero, for which an
entity possessing the user’s viewing key must process every
transaction posted to the blockchain.
Though the problem of reliably obtaining blockchain state
in the ﬁrst place is out of scope for our purposes, we men-
tion in particular B¨unz, Kiffer, Luu, and Zamani’s FlyClient
[7]. FlyClient—together with standard Merkle-based proofs—
could make obtaining convincingly correct state from an
untrusted full node highly efﬁcient. Our protocol could be used
fruitfully in conjunction with FlyClient.
Valid statement.
Invalid statement.
C. Choice of anonymity sets
Fig. 1: Illustration of the Anonymous Zether relation (1).
B. Anonymous Zether as a “mobile cryptocurrency”
Wallets and “light clients” in Zcash, Monero, and Quisquis
present serious challenges. In these systems, account main-
tenance requires continual work proportional
to network’s
throughput; worse still, this work itself requires access to the
user’s secrets, and cannot be easily outsourced. For example,
Zcash’s reference wallet must entrust to an external server its
user’s secret viewing key; this server in turn must continually
ﬁlter for relevant transactions remotely (and, in the process,
access the wallet’s full plaintext transaction activity). A similar
issue affects Monero, in that—in order to identify relevant
transactions—each wallet must obtain and scan through each
new transaction, using its user’s private “view key”. Finally,
Zcash and Monero additionally demand that each wallet store
linearly accumulating secret state (i.e., to remember which
TXOs it owns, and which among these it has spent). In effect,
each wallet in these systems must either assume a substantial
resource burden (in both computation and bandwidth), or else
outsource the task to an external entity (and forego its privacy).
An Anonymous Zether wallet, by contrast, need only query
a constant amount of state from an untrusted full node for
each payment it makes, and moreover is essentially stateless.
Speciﬁcally, to determine its user’s own account balance (at
any given time), a wallet need only retrieve two 64-byte
ciphertexts from an untrusted full node;
to send
funds, the wallet need only retrieve 2 · N ciphertexts, where
N is the size of the transaction’s anonymity set (the doubling
is due to “pending” transfers; see [6, §3.1]). This is true
regardless of network’s overall throughput and size, and of
ofﬂine periods of arbitrary duration. Finally, the wallet—while
ofﬂine—must remember only its user’s 32-byte secret key (or
solicit it freshly for each payment).
likewise,
Each wallet must reveal to its full node only what it also
reveals to the rest of the network, except when it makes
balance queries; these too can be disguised within “anonymity
sets” for extra protection. To asynchronously receive funds,
the wallet must share, with the full node, a list of accounts to
which it would like to “subscribe”. If this list is expanded so as
to include the user’s anonymity sets, then no privacy is lost; in
Abstractly, Anonymous Zether furnishes Zether’s RAM-like
global accounts table with an atomic “multi-write” operation,
which disguises 2 simultaneous logical writes within N si-
multaneous physical writes (and also obscures the respective
roles of the sender and receiver). It is the responsibility of each
consuming application—a responsibility out of scope for this
paper—to select each such set of N locations in such a way as
to effectively disguise the application’s logical write behavior.
It remains an interesting open question whether the techniques
of oblivious RAM (see e.g., Stefanov et al. [8]) could be
applied towards the generation of such selection strategies,
which in principle could convey formal privacy guarantees.
D. Technical challenges
We turn to our cryptographic contribution. An efﬁcient proof