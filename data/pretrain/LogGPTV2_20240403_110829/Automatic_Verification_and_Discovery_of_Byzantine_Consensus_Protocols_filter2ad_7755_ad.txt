Not all correct OTC algorithms are listed; I omit those
that can be obtained from others by permuting the set of
processes, and those that are dominated by others. (A set T
iff every OT condition in T is dominated
is dominated by T (cid:3)
.) All considered OT (X, C, k) have k ≤ 3.
by some in T (cid:3)
In a normal round, processes wait for the coordinator’s
proposal to propose to OTC (Figure 2). However, in the ﬁrst
round, processes can propose their proposals to the OTC di-
rectly (Figure 9) [30]. This incorporates the ﬁrst step into
the OTC, allowing for multi-coordinator algorithms and jus-
tifying the distinction between X and C in OT (X, C, k).
This also implies that, as in the Validity property of Con-
sensus, the valid(x) predicate of the ﬁrst-round OTC can
assume all processes to be honest. Therefore, as far as the
ﬁrst round is concerned, valid(x) becomes true once a pro-
cess receives one event (cid:6)x : pi(cid:7), making Permanent Valid-
ity easily satisﬁed. All OTCs presented in section are ﬁrst-
round OTCs to which processes propose directly; complete
Consensus algorithms can be constructed as shown in [30].
Crash-stop 3 processes with 1 failure. We have:
F = {∅,{p1},{p2},{p3}}, M = {∅}.
The generated OTC algorithms correspond to the following
two sets of OT conditions (X, C, k):
(cid:6){p1, p2},{p1, p2}, 1(cid:7)
(cid:6){p1},{p1, p2}, 2(cid:7)
(cid:6){p1},{p1, p3}, 2(cid:7)
 and
(cid:6){p1, p2},{p1, p2}, 1(cid:7)
(cid:6){p1, p3},{p1, p3}, 2(cid:7)
(cid:6){p2, p3},{p2, p3}, 2(cid:7)
 ,
which can be depicted as (Section 2.4):
and
n
3
4
5
5
4
5
failures
algs tested
found
time
1 crash-stop
1 crash-stop
1 crash-stop
2 crash-stop
1 malicious
1 malicious
360
8,512
341,312
32,620,109
47,990
11.9 billion
1
2
3
6
7
6
0.03 sec
0.33 sec
0.83 sec
61.52 sec
0.41 sec
39.4 hours
As many standard algorithms [10], the ﬁrst one decides
in two steps if the leader p1 and a majority of processes are
correct. Additionally, it decides in one step if p1 and p2
propose the same value. Such an algorithm was presented
in [9] for general n.
The second algorithm decides if two processes proposed
the same value; in one step if the processes are p1 and p2,
and in two steps otherwise.
If all processes are correct,
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:33:25 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007but propose different values, this algorithm will not decide.
Next sections exclude such algorithms by requiring at least
one OT (X, C, k) to have X = {p1}.
Crash-stop 4 processes with 1 failure.
following two OTCs have been generated:
In this case, the
and
Both algorithms decide in two steps if the leader p1 and
at least one other process are correct. The ﬁrst decides in
one step if p1 and p2 propose the same value, the second if
at least three processes including p1 propose the same value.
Note that this protocol can sometimes decide if two pro-
cesses are faulty, even though we assume at most one fail-
ure.
In practice, this means that, in some situations, the
algorithm might not need to wait for response from some
slow, but formally correct, processes.
Crash-stop 5 processes with 2 failures.
following two OTCs have been generated:
In this case, the
Both decide in two steps if a majority of processes, in-
cluding the leader, are correct. The ﬁrst additionally decides
in one step if p1, p2, p3 propose the same value; the other, if
at least four processes, including p1 propose the same value.
Byzantine 4 processes with 1 failure. The algorithm by
Castro and Liskov [3] decides in three steps if the leader p1
is correct and at most one other process is faulty. Later pa-
pers observed [6, 30] that if all processes are correct, then
the decision can be made in two steps:
In this case, seven OTCs have been generated, two of
which are extensions of the above protocol:
In addition to the original properties, these two algo-
rithms can also decide in two steps in some runs with one
process faulty and two processes proposing the same value.
Byzantine 5 processes with 1 failure. This case gener-
ated six variants of the following:
The ﬁrst three OT conditions correspond to the 4-process
algorithm [3]. They decide if the leader p1 is correct, and
at most one of p1, ..., p4 is faulty; p5 is completely ignored.
The next four conditions decide in two steps if at most one
process is faulty (not p1). Finally, the algorithm can some-
times decide if two processes propose the same and at most
two are faulty or slow.
6. Conclusion
This paper presented a method for automatic veriﬁcation
and discovery of low-latency Consensus protocols through
model checking. The main challenge here is the enormous
size of the state and solution spaces. My method reduces
the state space by focusing on the latency-determining ﬁrst
round only, ignoring the order of messages in this round,
and distinguishing between state-modifying actions and
state-preserving predicates.
In addition, monotonicity of
the predicates and veriﬁed properties allows one to use a
Tarski-style ﬁxpoint algorithm, which results in an expo-
nential veriﬁcation speed-up.
While no ground-breaking protocols have been discov-
ered, the method described here generated interesting im-
provements to the existing algorithms. In particular, sev-
eral combinations of fast one-step protocols and resilient
leader-based algorithms have been discovered. Because of
the number of cases involved, such composite algorithms
are difﬁcult to design and check manually.
I believe that automated protocol design is an interesting
paradigm that can be successfully used together with the tra-
ditional manual process. From the practical point of view,
it allows one to quickly analyze intricate interplays as well
as discover subtle errors and improvements to existing pro-
tocols. This is especially useful in custom failure models
with malicious participants. From the theoretical point of
view, generated protocols as well as counterexample states
can provide useful insights for general n-process protocols
and lower bounds.
Security protocol research community recognized some
time ago that automated correctness testing is ideal for short
algorithms that are difﬁcult to get right. It seems to me that
distributed agreement protocols would greatly beneﬁt from
a similar treatment. Atomic broadcast, atomic commitment,
etc., especially in the crash-recovery model, are interesting
problems to tackle in this way.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:33:25 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007References
[1] Y. Bar-David and G. Taubenfeld. Automatic discovery
of Mutual Exclusion algorithms. In Proc. of the 17th
Int. Symposium on Distributed Computing, 2003.
[2] M. Burrows, M. Abadi, and R. Needham. A logic of
authentication. ACM Transactions on Computer Sys-
tems, 8(1):18–36, 1990.
[3] M. Castro and B. Liskov. Practical Byzantine fault
tolerance. In Proceedings of the Third Symposium on
Operating Systems Design and Implementation, pages
173–186, New Orleans, Louisiana, Feb. 1999.
[4] T. D. Chandra, V. Hadzilacos, and S. Toueg. The
weakest failure detector for solving Consensus. Jour-
nal of the ACM, 43(4):685–722, 1996.
[5] E. M. Clarke, S. Jha, and W. Marrero. Verifying se-
curity protocols with Brutus. ACM Trans. on Software
Engineering and Methodology, 9(4):443–487, 2000.
[6] P. Dutta, R. Guerraoui, and M. Vukolic. Asynchronous
Byzantine Consensus: Complexity, resilience and au-
thentication. TR 200479, EPFL, Sept. 2004.
[7] E. Gafni and L. Lamport. Disk Paxos. In Int. Sympo-
sium on Distributed Computing, pp. 330–344, 2000.
[8] J. Gray and L. Lamport. Consensus on Transaction
Commit. TR 2003-96, Microsoft, Jan. 2004.
[9] R. Guerraoui and M. Raynal. The information struc-
ture of indulgent Consensus. TR 1531, IRISA, 2003.
[10] R. Guerraoui, M. Hurﬁn, A. Most´efaoui, R. Oliveira,
M. Raynal, and A. Schiper. Consensus in asyn-
chronous distributed systems: A concise guided tour.
In LNCS 1752, pages 33–47. Springer, 2000.
[11] M. P. Herlihy.
Impossibility and universality results
for wait-free synchronization. In Proc. of the 7th An-
nual ACM Symposium on Principles of Distributed
Computing, pages 276–290, New York, USA, 1988.
[12] P. Kellomaki. An annotated speciﬁcation of the Con-
sensus protocol of Paxos using superposition in PVS.
TR 36, Tampere University of Technology, 2004.
[13] L. Lamport. Paxos made simple. ACM SIGACT News,
32(4):18–25, December 2001.
[14] L. Lamport.
Specifying systems:
the TLA+ lan-
guage and tools for hardware and software engineers.
Addison-Wesley Professional, 2002.
[15] L. Lamport. Fast Paxos. Technical Report MSR-TR-
2005-112, Microsoft Research (MSR), July 2005.
[16] L. Lamport. The part-time parliament. ACM Transac-
tions on Computer Systems, 16(2):133–169, 1998.
[17] G. Lowe. Breaking and ﬁxing the Needham-Schroeder
public-key protocol using FDR.
In Proc. of the 2nd
Int. Workshop on Tools and Algorithms for Construc-
tion and Analysis of Systems, pp. 147–166, UK, 1996.
[18] J. C. Mitchell, M. Mitchell, and U. Stern. Automated
In
analysis of cryptographic protocols using Murφ.
Proc. of the 1997 Symposium on Security and Privacy,
pages 141–153, Washington, DC, USA, 1997.
[19] A. Most´efaoui and M. Raynal. Solving Consensus us-
ing Chandra-Toueg’s unreliable failure detectors: A
general quorum-based approach. In Proceedings of the
13th International Symposium on Distributed Com-
puting, pages 49–63, London, UK, 1999.
[20] L. C. Paulson. The inductive approach to verifying
cryptographic protocols. Journal of Computer Secu-
rity, 6:85–128, 1998.
[21] Pogosyants, Segala, and Lynch. Veriﬁcation of the
randomized Consensus algorithm of Aspnes and Her-
lihy: A case study. DISTCOMP, 13, 2000.
[22] R. D. Prisco, B. W. Lampson, and N. A. Lynch. Revis-
iting the Paxos algorithm. In Workshop on Distributed
Algorithms, pages 111–125, 1997.
[23] M. Raynal. Consensus in synchronous systems: a con-
cise guided tour. TR 1497, IRISA, Jul 2002.
[24] A. Schiper. Early Consensus in an asynchronous sys-
tem with a weak failure detector. Distributed Comput-
ing, 10(3):149–157, Apr. 1997.
[25] A. Tarski. A ﬁxed point theorem and its applications.
Paciﬁc Journal of Mathematics, pages 285–309, 1955.
[26] T. Tsuchiya and A. Schiper. Model Checking of Con-
sensus Algorithms. Technical report, EPFL, 2006.
[27] T. N. Win and M. D. Ernst. Verifying distributed algo-
rithms via dynamic analysis and theorem proving. TR
841, MIT Lab for Computer Science, May 2002.
[28] T. N. Win, M. D. Ernst, S. J. Garland, D. Kırlı, and
N. Lynch. Using simulated execution in verifying dis-
tributed algorithms. Software Tools for Technology
Transfer, 6(1):67–76, July 2004.
[29] P. Zieli´nski. Minimizing latency of agreement proto-
cols. PhD thesis, Computer Laboratory, University of
Cambridge, UK, 2006. TR 667.
[30] P. Zieli´nski. Optimistically Terminating Consensus. In
Proc. of the 5th Int. Symposium on Parallel and Dis-
tributed Computing, Timisoara, Romania, July 2006.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:33:25 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007