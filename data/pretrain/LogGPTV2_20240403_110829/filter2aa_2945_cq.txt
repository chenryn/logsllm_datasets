cancellation in
a PLINQ
query
Use the WithCancellation method of the ParallelQuery
class in the PLINQ query and specify a cancellation token.
For example:
Click here to view code image
CancellationToken tok = ...;
...
var orderInfoQuery =
  from c in CustomersInMemory.Customers.
      AsParallel().WithCancellation(tok)
Download from finelybook PI:EMAIL
882
  join o in OrdersInMemory.Orders.AsParallel()
  on ...
Synchronize
one or more
tasks to
implement
thread-safe
exclusive
access to
shared data
Use the lock statement to guarantee exclusive access to the
data. For example:
Click here to view code image
object myLockObject = new object();
...
lock (myLockObject)
{
    // Code that requires exclusive access
    // to a shared resource
    ...
}
Synchronize
threads and
make them
wait for an
event
Use a ManualResetEventSlim object to synchronize an
indeterminate number of threads.
Use a CountdownEvent object to wait for an event to be
signaled a specified number of times.
Use a Barrier object to coordinate a specified number of
threads and synchronize them at a particular point in an
operation.
Synchronize
access to a
shared pool of
resources
Use a SemaphoreSlim object. Specify the number of items
in the pool in the constructor. Call the Wait method prior to
accessing a resource in the shared pool. Call the Release
method when you have finished with the resource. For
example:
Click here to view code image
SemaphoreSlim semaphore = new SemaphoreSlim(3);
...
semaphore.Wait();
// Access a resource from the pool
...
semaphore.Release();
Provide
exclusive
write access to
a resource but
shared read
access
Use a ReaderWriterLockSlim object. Prior to reading the
shared resource, call the EnterReadLock method. Call the
ExitReadLock method when you have finished. Before
writing to the shared resource, call the EnterWriteLock
method. Call the ExitWriteLock method when you have
completed the write operation. For example:
Download from finelybook PI:EMAIL
883
Click here to view code image
ReaderWriterLockSlim readerWriterLock = new
ReaderWriterLockSlim();
Task readerTask = Task.Factory.StartNew(() =>
    {
        readerWriterLock.EnterReadLock();
        // Read shared resource
        readerWriterLock.ExitReadLock();
    });
Task writerTask = Task.Factory.StartNew(() =>
    {
        readerWriterLock.EnterWriteLock();
        // Write to shared resource
        readerWriterLock.ExitWriteLock();
    });
Cancel a
blocking wait
operation
Create a cancellation token from a
CancellationTokenSource object, and specify this token as
a parameter to the wait operation. To cancel the wait
operation, call the Cancel method of the
CancellationTokenSource object. For example:
Click here to view code image
CancellationTokenSource cancellationTokenSource = new
CancellationTokenSource();
CancellationToken cancellationToken =
cancellationTokenSource.Token;
...
// Semaphore that protects a pool of 3 resources
SemaphoreSlim semaphoreSlim = new SemaphoreSlim(3);
...
// Wait on the semaphore, and throw an
// OperationCanceledException if
// another thread calls Cancel on
// cancellationTokenSource
semaphore.Wait(cancellationToken);
Download from finelybook PI:EMAIL
884
CHAPTER 25
Implementing the user interface for
a Universal Windows Platform app
After completing the chapter, you will be able to:
Describe the features of a typical Universal Windows Platform app.
Implement a scalable user interface for a Universal Windows Platform
app that can adapt to different form factors and device orientations.
Create and apply styles to a Universal Windows Platform app.
Recent versions of Windows have introduced a platform for building and
running highly interactive applications with continuously connected, touch-
driven user interfaces and support for embedded device sensors. An updated
application security and life-cycle model changed the way that users and
applications work together. This platform is called the Windows Runtime
(WinRT), and I have referred to it occasionally throughout this book. You
can use Visual Studio to build WinRT applications that can adapt themselves
to a variety of device form factors, ranging from handheld tablets to desktop
PCs with large, high-resolution screens. Using Windows 8 and Visual Studio
2013, you could also publish these applications in the Windows Store as
Windows Store apps.
Separately, you could use the Windows Phone SDK 8.0 (integrated into
Visual Studio) to design and implement applications that run on Windows
Phone 8 devices. These applications share many similarities with their tablet
and desktop-oriented siblings, but they operate in a more restricted
environment, typically with fewer resources and a requirement to support a
Download from finelybook PI:EMAIL
885
different user interface layout. Consequently, Windows Phone 8 applications
use a different version of the WinRT, called the Windows Phone Runtime,
and you can market Windows Phone 8 applications as Windows Phone Store
apps. You could create a class library with which to share application and
business logic between a Windows tablet/desktop application and a Windows
Phone 8 application by using the Portable Class Library template in Visual
Studio, but Windows Store apps and Windows Phone Store apps are distinct
beasts with differences in the features that they can make available.
Subsequently, Microsoft sought to converge these platforms and reduce
the number of differences. This strategy has culminated in Windows 10 with
Universal Windows Platform apps. A Universal Windows Platform app uses
an amended version of WinRT called the Universal Windows Platform
(UWP). Using the UWP, you can build applications that will run on the
widest range of Windows 10 devices without the need to maintain separate
code bases. In addition to many phones, tablets, and desktop computers,
UWP is also available on Xbox.
Note The UWP defines a core set of features and functionality. The
UWP divides devices into device families: the desktop device family,
the mobile device family, the Xbox device family, and so on. Each
device family defines the set of APIs and devices on which those APIs
are implemented. Additionally, the Universal device family defines a
core set of features and functionality that is available across all device
families. The libraries available for each device family include
conditional methods that enable an app to test on which device family it
is currently running.
The purpose of this chapter is to provide a brief description of the
concepts that underpin the UWP and to help you get started using Visual
Studio 2017 to build apps that operate in this environment. In this chapter,
you will learn about some of the features and tools included with Visual
Studio 2017 for building UWP apps, and you will construct an app that
conforms to the Windows 10 look and feel. You will concentrate on learning
Download from finelybook PI:EMAIL
886
how to implement a user interface (UI) that scales and adapts to different
device resolutions and form factors, and how to apply styling to give the app
a distinctive look and feel. Subsequent chapters will focus on the
functionality and other features of the app.
Note There is not enough space in a book such as this to provide a
comprehensive treatise on building UWP apps. Rather, these final
chapters concentrate on the basic principles of building an interactive
app that uses the Windows 10 UI. For detailed information on writing
UWP apps, visit the “Guide to Universal Windows Platform (UWP)
apps” page on the Microsoft website at
https://msdn.microsoft.com/library/dn894631.aspx.
Features of a Universal Windows Platform app
Many modern handheld and tablet devices make it possible for users to
interact with apps by using touch. You should design your UWP apps based
on this style of user experience (UX). Windows 10 includes an extensive
collection of touch-based controls that also work with a mouse and keyboard.
You don’t need to separate the touch and mouse features in your apps; simply
design your apps for touch, and users can still operate them by using the
mouse and keyboard if they prefer or when they are using a device that does
not support touch interaction.
The way in which the graphical user interface (GUI) responds to gestures
to provide feedback to the user can greatly enhance the professional feel of
your apps. The UWP app templates included with Visual Studio 2017 include
an animation library that you can use in your apps to standardize this
feedback and blend in seamlessly with the operating system and software that
Microsoft provides.
Download from finelybook PI:EMAIL
887
Note The term gesture refers to the manual touch-oriented operations
that a user can perform. For example, a user can tap an item with a
finger, and this gesture typically responds in the same way that you
would expect a mouse click to behave. However, gestures can be far
more expressive than the simple operations that can be captured by
using a mouse. For example, the rotate gesture involves the user placing
two fingers on the screen and tracing the arc of a circle with them; in a
typical Windows 10 app, this gesture should cause the UI to rotate the
selected object in the direction indicated by the movement of the user’s
fingers. Other gestures include pinching to zoom in on an item to
display more detail, pressing and holding to reveal more information
about an item (similar to right-clicking the mouse click), and sliding to
select an item and drag it across the screen.
The UWP is intended to run on a wide range of devices with varying
screen sizes and resolutions. Therefore, when you implement a UWP app,
you need to construct your software so that it adapts to the environment in
which it is running, scaling automatically to the screen size and orientation of
the device. This approach opens your software to an increasingly broad
market. Additionally, many modern devices can also detect their orientation
and the speed at which the user changes this orientation through the use of
built-in sensors and accelerometers. UWP apps can adapt their layout as the
user tilts or rotates a device, making it possible for the user to work in a mode
that is most comfortable for that individual. You should also understand that
mobility is a key requirement for many modern apps, and with UWP apps,
users can roam and their data can migrate through the cloud to whatever
device they happen to be running your app on at a particular moment.
The lifetime of a UWP app is somewhat different from that of a traditional
desktop app. You should design apps that can run on devices such as
smartphones to suspend execution when the user switches focus to another
app and then to resume running when the focus returns. This approach can
help to conserve resources and battery life on a constrained device. Windows
might actually decide to close a suspended app if it determines that it needs to
Download from finelybook PI:EMAIL
888
release system resources such as memory. When the app next runs, it should
be able to resume where it left off. This means that you need to be prepared
to manage app state information in your code, save it to hard disk, and restore
it at the appropriate juncture.
Note You can find more information about how to manage the life cycle
of a UWP app at the page “Guidelines for app suspend and resume” on
the Microsoft website at
https://msdn.microsoft.com/library/windows/apps/hh465088.aspx.
When you build a new UWP app, you can package it by using the tools
provided with Visual Studio 2017 and upload it to the Windows Store. Other
users can then connect to the Store, download your app, and install it. You
can charge a fee for your apps, or you can make them available at no cost.
This distribution and deployment mechanism depends on your apps being
trustworthy and conforming to security policies specified by Microsoft.
When you upload an app to the Windows Store, it undergoes a number of
checks to verify that it does not contain malicious code and that it conforms
to the security requirements of a UWP app. These security constraints dictate
how your app accesses resources on the computer on which it is installed. For
example, by default, a UWP app cannot write directly to the file system or
listen for incoming requests from the network (two of the behaviors
commonly exhibited by viruses and other malware). However, if your app
needs to perform restricted operations, you can specify them as capabilities in
the app’s manifest data held in the Package.appxmanifest file. This
information is recorded in the metadata of your app and signals Microsoft to
perform additional tests to verify the way in which your app uses these
features.
The Package.appxmanifest file is an XML document, but you can edit it in
Visual Studio by using the Manifest Designer. The following image shows an
example. Here, the Capabilities tab is being used to specify the restricted
operations that the application can perform.
Download from finelybook PI:EMAIL
889
In this example, the application declares that it needs to:
Receive incoming data from the Internet but cannot act as a server and
has no local network access.
Access GPS information that provides information about the location
of the device.
Read and write files held in the user’s Pictures folder.
The user is made aware of these requirements, and in all cases, the user
can disable the settings after installing the app; the application must detect
when this has occurred and be prepared to fall back to an alternative solution
or disable the functionality that requires these features.
Note You can find more information about the capabilities that UWP
apps support on the “App capability declarations” page on the Microsoft
Download from finelybook PI:EMAIL
890
website at
http://msdn.microsoft.com/library/windows/apps/hh464936.aspx.
Enough theory; let’s get started building a UWP app.
Using the Blank App template to build a Universal
Windows Platform app
The simplest way to build a UWP app is to use the UWP app templates
included with Visual Studio 2017 on Windows 10. Many of the GUI-based
applications implemented in earlier chapters have made use of the Blank App
template, and this is a good place to start.
In the following exercises, you will design the user interface for a simple
app for a fictitious company called Adventure Works. This company
manufactures and supplies bicycles and associated paraphernalia. The app
will enable a user to enter and modify the details of Adventure Works’s
customers.
Create the Adventure Works Customers app
1. Start Visual Studio 2017 if it is not already running.
2. On the File menu, point to New, and then click Project.
3. In the New Project dialog box, in the left pane, expand Visual C#, and
then click Windows Universal.
4. In the middle pane, click the Blank App (Universal Windows) icon.
5. In the Name field, type Customers.
6. In the Location field, type \Microsoft Press\VCSBS\Chapter
25 in your Documents folder.
7. Click OK.
8. In the New Universal Windows Project dialog box, accept the default
values for the Target Version and Minimum Version drop-down list
boxes, and then click OK.
Download from finelybook PI:EMAIL
891
The new app is created, and the Overview page is displayed. This page
contains links to information that you can use to start creating,
configuring, and deploying Universal Windows apps.
9. In Solution Explorer, double-click MainPage.xaml.
The Design View window appears and displays a blank page. You can
drag controls from the Toolbox to add the various controls required by
the app, as demonstrated in Chapter 1, “Welcome to C#.” However, for
this exercise, it is more instructive to concentrate on the XAML markup
that defines the layout for the form. If you examine this markup, it
should look like this:
Click here to view code image
The form starts with the XAML  tag and finishes with a closing
 tag. Everything between these tags defines the content of the
page.
The attributes of the  tag contain a number of declarations of the
form xmlns:id = “…”. These are XAML namespace declarations, and
they operate similarly to C# using directives since they bring items into
scope. Many of the controls and other items that you can add to a page
are defined in these XAML namespaces, and you can ignore most of
these declarations. However, there is one rather curious-looking
declaration to which you should pay attention:
xmlns:local="using:Customers"
This declaration brings the items in the C# Customers namespace into
scope. You can reference classes and other types in this namespace in
your XAML code by prefixing them with local. The Customers
namespace is the namespace generated for the code in your app.
10. In Solution Explorer, expand MainPage.xaml, and then double-click
MainPage.xaml.cs to display it in the Code and Text Editor window.
11. Remember from the exercises earlier in this book that this is the C# file
that contains the app logic and event handlers for the form. It looks like
this (the using directives at the top of the file have been omitted to save
space):
Click here to view code image
// The Blank Page item template is documented at  
http://go.microsoft.com/fwlink/?LinkId=402352&clcid=0x409
namespace Customers
{
    /// 
    /// An empty page that can be used on its own or navigated
to within a Frame.
    /// 
    public sealed partial class MainPage : Page
    {
Download from finelybook PI:EMAIL
893
        public MainPage()
        {
            this.InitializeComponent();
        }
    }
}
This file defines the types in the Customers namespace. The page is
implemented by a class called MainPage, and it inherits from the Page
class. The Page class implements the default functionality of an XAML
page for a UWP app, so all you have to do is write the code that defines
the logic specific to your app in the MainPage class.
12. Return to the MainPage.xaml file in the Design View window. If you
look at the XAML markup for the page, you should notice that the
 tag includes the following attribute:
x:Class="Customers.MainPage"
This attribute connects the XAML markup that defines the layout of the
page to the MainPage class that provides the logic behind the page.
That’s the basic plumbing of a simple UWP app. Of course, what makes a
graphical app valuable is the way in which it presents information to a user.
This is not always as simple as it sounds. Designing an attractive and easy-to-
use graphical interface requires specialist skills that not all developers have (I
know, because I lack them myself). However, many graphic artists who do
have these skills are not programmers, so although they might be able to
design a wonderful user interface, they might not be able to implement the
logic required to make it useful. Fortunately, Visual Studio 2017 makes it
possible for you to separate the user interface design from the business logic
so that a graphic artist and a developer can cooperate to build a really cool-
looking app that also works well. All a developer has to do is concentrate on
the basic layout of the app and let a graphic artist provide the styling.
Implementing a scalable user interface
The key to laying out the user interface for a UWP app is to understand how
to make it scale and adapt to the different form factors available for the
devices on which users might run the app. In the following exercises, you
will investigate how to achieve this scaling.
Download from finelybook PI:EMAIL
894
Lay out the page for the Customers app
1. In the toolbar at the top of the Design View window, notice the drop-
down list box that enables you to select the resolution and form factor of
the design surface and a pair of buttons that enable you to select the
orientation (portrait or landscape) for devices that support rotations
(tablets and phones do; desktops, Xbox, Surface Hub, IoT devices, and
HoloLens devices don’t). The intent is that you can use these options to
quickly see how a user interface will appear on different devices.
The default layout is for a Surface Book with a 13.5-inch screen in the
landscape orientation; this form factor does not support portrait mode.
2. In the drop-down list box, select 8” Tablet (1280 x 800). This is the
Download from finelybook PI:EMAIL
895
form factor for a tablet device that supports rotations, and both
landscape and portrait modes are available.
Finally, click 13.3” Desktop. This is the form factor that you will use for
the Customers application. This form factor defaults to the landscape
orientation.
Note You might find that the page layout in the Design View