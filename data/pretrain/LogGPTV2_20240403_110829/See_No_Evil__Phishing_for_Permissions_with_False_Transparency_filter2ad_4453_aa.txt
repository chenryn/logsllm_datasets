title:See No Evil: Phishing for Permissions with False Transparency
author:G&quot;uliz Seray Tuncay and
Jingyu Qian and
Carl A. Gunter
See No Evil: Phishing for Permissions with 
False Transparency
Güliz Seray Tuncay, Google, University of Illinois at Urbana-Champaign; 
Jingyu Qian and Carl A. Gunter, University of Illinois at Urbana-Champaign
https://www.usenix.org/conference/usenixsecurity20/presentation/tuncay
This paper is included in the Proceedings of the 29th USENIX Security Symposium.August 12–14, 2020978-1-939133-17-5Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX.See No Evil: Phishing for Permissions with False Transparency
Google, University of Illinois at Urbana-Champaign
University of Illinois at Urbana-Champaign
Güliz Seray Tuncay
PI:EMAIL
Jingyu Qian
PI:EMAIL
Carl A. Gunter
University of Illinois at Urbana-Champaign
PI:EMAIL
Abstract
Android introduced runtime permissions in order to provide
users with more contextual information to make informed
decisions as well as with ﬁner granularity when dealing with
permissions. In this work, we identiﬁed that the correct op-
eration of the runtime permission model relies on certain
implicit assumptions which can conveniently be broken by
adversaries to illegitimately obtain permissions from the back-
ground while impersonating foreground apps. We call this
detrimental scenario false transparency attacks. These attacks
constitute a serious security threat to the Android platform as
they invalidate the security guarantees of 1) runtime permis-
sions by enabling background apps to spoof the context and
identity of foreground apps when requesting permissions and
of 2) Android permissions altogether by allowing adversaries
to exploit users’ trust in other apps to obtain permissions.
We demonstrated via a user study we conducted on Ama-
zon Mechanical Turk that mobile users’ comprehension of
runtime permissions renders them susceptible to this attack
vector. We carefully designed our attacks to launch strategi-
cally in order to appear persuasive and veriﬁed the validity
of our design strategies through our user study. To demon-
strate the feasibility of our attacks, we conducted an in-lab
user study in a realistic setting and showed that none of the
subjects noticed our attacks. Finally, we discuss why the ex-
isting defenses against mobile phishing fail in the context of
false transparency attacks. In particular, we disclose the secu-
rity vulnerabilities we identiﬁed in a key security mechanism
added in Android 10. We then propose a list of countermea-
sures to be implemented on the Android platform and on app
stores to practically tackle false transparency attacks.
1 Introduction
Be transparent. When you make a permissions
request, be clear about what you’re accessing, and
why, so users can make informed decisions. – App
permissions best practices by Google [1]
Android’s permission system enables access control on sen-
sitive user data and platform resources based on user consent.
In an effort to foster meaningful consent, Android 6 intro-
duced runtime permissions to help users understand why a
permission is needed by an app by asking for it in a relevant
use context. In particular, the runtime permission model war-
rants certain security guarantees to achieve this goal. First,
it provides a contextual guarantee to ensure that users will
always be given the necessary contextual information to make
informed decisions, by enforcing apps to be in the foreground
when requesting permissions. Second, it provides an identity
guarantee to ensure that users are well-aware of the identity
of the app owning the current context during a permission re-
quest, by clearly displaying the name of the requesting app in
permission dialogs. In line with its ultimate goal of providing
context, the model also relies on the cooperation of app de-
velopers to be transparent regarding their need of permissions
during permission requests.
In this work, we have identiﬁed that the security guaran-
tees of runtime permissions are broken due to some implicit
assumptions made by the platform designers. To this end, we
show how our ﬁndings can be used by adversaries to stealthily
obtain runtime permissions. First, Android assumes that an
app in the foreground will always present a meaningful and
legitimate context. However, we show that background apps
can surreptitiously move to the foreground to request permis-
sions without being noticed by users by utilizing Android
APIs and invisible graphical displays. Second, we observed
that the naming scheme utilized in the permission dialogs
assumes that the app name will uniquely identify a single app
installed on the user device for its secure operation; however,
the Android ecosystem does not readily enforce any rules on
these names. As a consequence, apps can spoof the names
of other apps or use irrelevant names that have the poten-
tial to mislead users regarding the true source of the request.
The combination of these ﬁndings indicate the possibility of
phishing-based privilege escalation on runtime permissions;
a background app (adversary) can now request and obtain
permissions while leading the user to believe the request
USENIX Association
29th USENIX Security Symposium    415
was triggered by the foreground app (victim), an insidious
phishing scenario which we call false transparency attacks
on runtime permissions.
In false transparency attacks, a permission request from an
app is not transparent in the sense of the quote above. Instead,
its context is literally transparent as a graphical display to en-
sure that the user only sees the victim app at the time of the re-
quest. In addition, its origin is intentionally set to mislead the
user into thinking the request was triggered by the foreground
app. Hence, the adversary can take advantage of both the con-
text and the identity of a victim app for its own requests to
more conveniently obtain permissions. To illustrate, suppose
Vibr is an attack app that launches a false transparency attack
from the background while the widely-used communication
app Viber is in the foreground. If, for example, Vibr requests
permission to access the user’s contacts, then an unwary user
may grant this if they think the request comes from Viber,
as users would generally feel comfortable granting contacts
permission to a popular communication app that needs it for
its utility [2]. In particular, we argue that these attacks con-
stitute a notable security hazard for the Android platform for
two reasons. First, they allow background apps to stealthily
obtain permissions while providing a spoofed context and
identity, which clearly defeats the purpose of using runtime
permissions to provide meaningful contextual information to
users. Second, they create an opportunity for malicious apps
to exploit the user’s trust in another, possibly high-proﬁle
app to obtain permissions that they would normally not be
able to acquire, breaking the security guarantees of Android
permissions altogether.
False transparency attacks serve as a platform for adver-
saries to obtain any set of dangerous permissions by exploit-
ing user’s trust in other apps. In order to proﬁtably mislead
users to grant permissions, the permission dialogs triggered
by adversaries should appear plausible, justifying the need for
a permission, as users have a strong tendency towards deny-
ing requests that seem irrelevant to the app’s use [2, 3]. We
ﬁrst show via a user study we conduct on Amazon Mechani-
cal Turk that users indeed demonstrate susceptibility to false
transparency attacks due to a lack of complete understanding
of the runtime permission model (e.g., security guarantees of
runtime permissions). We then propose various key schemes
to launch our attacks strategically and implement them after
verifying with our user study that they would indeed lead to
more stealthy and effective attacks. Furthermore, we conduct
an in-lab user study in a realistic setting to verify the feasibil-
ity of our attacks and show that none of the subjects noticed
they had been attacked.
Additionally, we study the existing defense mechanisms
against mobile phishing and discuss why they fall short in
the context of false transparency attacks. A noteworthy one
among these defenses is the strategy recently introduced by
Google in Android 10. We have found that this security mech-
anism suffers from serious security vulnerabilities and de-
sign issues, which rendered our attacks still effective on this
Android version and onward. Finally, we propose a list of
countermeasures that can be practically implemented on the
Android platform and on app stores such as Google Play to
defend against false transparency attacks.
Our contributions can be summarized as follows:
• We uncovered design shortcomings in Android’s runtime
permissions which inadvertently lead to a violation of the
essential security guarantees of this permission model.
• By utilizing these shortcomings, we built false trans-
parency attacks, which enable adversaries to illegiti-
mately obtain permissions using a victim app’s context
and identity.
• We conducted a user study to understand if users’ com-
prehension of runtime permissions created susceptibility
to this attack vector as well as to verify the validity of
our design strategies for stealthy attacks.
• We conducted a user study to demonstrate the feasibility
of our attacks in a realistic setting.
• We discovered serious issues in the new security mecha-
nism that addresses phishing in Android 10 and later and
showed the feasibility of our attacks on these versions.
• We proposed practical countermeasures that can effec-
tively tackle false transparency attacks.
2 Background
2.1 Android Permissions
Previously, permissions were permanently granted to apps at
installation time on Android. With the introduction of Android
6.0 (API level 23), Android switched to runtime permissions
where permissions for high-risk resources (e.g., camera, con-
tacts etc.) are requested dynamically and could be revoked
by the user at any time. This was done in an effort to provide
users more context while making decisions [4]. In this permis-
sion model, users are presented with a permission dialog on
or before the ﬁrst use of a sensitive resource that is protected
with a dangerous permission and are given the ability to allow
or deny a permission request. Furthermore, users can adjust
app permissions at any time through the system settings.
The PackageManager class can be queried to ob-
tain permission information of apps.
In particular, the
getInstalledPackages() API can be used with the
PackageManager.GET_PERMISSIONS ﬂag to obtain the per-
missions requested by apps as stated in their manifests and
the current states of these permissions (i.e., granted or not).
2.2 App Components and Task Organization
Apps can contain four main components on Android: ac-
tivities, services, broadcast receivers, and content providers.
An Activity presents the user with a single-purpose user
416    29th USENIX Security Symposium
USENIX Association
interface. A Fragment is an activity subcomponent that is
utilized to represent certain behavior or a portion of UI. A
Service performs long-running tasks in the background. A
BroadcastReceiver enables receiving messages from other
apps or the system. Finally, a ContentProvider provides
apps with a relational database interface to enable storing
and sharing data. Android provides the Intent messaging
scheme as a part of its Binder IPC mechanism to enable com-
munication between these components.
On Android, a task is a collection of activities that collab-
oratively perform a speciﬁc job. Android arranges activities
forming a task into a stack, in the reverse order of their initia-
tion. Pressing the back button removes the top activity from
the stack and brings forth the activity underneath to the fore-
ground. In addition, recently-accessed tasks can be obtained
via clicking the recents button to view a system-level UI called
the recents screen. Normally, the system handles the addition
and removal of activities and tasks to/from the recents screen;
however, this behavior can be overridden. For instance, tasks
can be excluded by setting android:excludeFromRecents
or by calling the finishAndRemoveTask() API in the activ-
ity creating the task.
3 Runtime Permissions in the Wild
Our attacks constitute a notable threat to the security of run-
time permissions. Here, we study the adoption of runtime
permissions to demonstrate the extent of our attacks. First, we
investigate the adoption of Android versions that support run-
time permissions (Android 6-11). As reported by Google, the
cumulative adoption of these Android versions is 74.8% [5].
This means that the majority of users are using Android de-
vices that support runtime permissions and are vulnerable to
our attacks by default. Next, we investigate the prevalence of
apps that adopted runtime permissions. For this purpose, we
collected the 80 top free apps of each app category on Google
Play (with some failures) and obtained a ﬁnal dataset with
2483 apps. We collected this dataset in December 2018, when
runtime permissions had already been released for a few years.
Table 1 summarizes our results. 83% of the apps in our dataset
have a target API level 23 or more, indicating they utilize run-
time permissions. Out of these apps, 85% of them (71% of
all apps) request at least one permission of protection level
dangerous. This shows that runtime permissions are highly
adopted by app developers and users are already accustomed
to dealing with runtime permissions as the majority of the
apps request permissions at runtime.
4 Attacking Runtime Permissions
Android’s runtime permission model provides essential se-
curity guarantees in order to reliably and securely deliver
contextual information. In this section, we will discuss these
Table 1: Adoption of permission models and use of dangerous
permissions by apps (# of apps (% of apps)).
Requesting dangerous
permissions?
Using Runtime
permissions
Yes
No
Total
1755 (71%)
309 (13%)
2064 (83%)
Using
Install-time
permissions
357 (14%)
62 (2%)
419 (17%)
guarantees and explain how they can be broken to launch
phishing-based privilege escalation attacks that we call false
transparency attacks on runtime permissions. We will then
discuss the internals of our attacks in detail.
Threat model. We assume an adversary that can build An-
droid apps and distribute them on app markets, such as Google
Play (GP) store; however, the adversary is not necessarily a
reputable developer on GP. They provide an app with some
simple and seemingly useful functionality (e.g., QR code scan-
ner etc.) to lure the users into installing the app. Their goal
is to obtain a desired set of dangerous permissions, which is
relatively difﬁcult to achieve for non-reputable app developers
and is especially harder if their app does not have a convincing
reason to why it requires a speciﬁc permission [2].
4.1
(Breaking) the Security Guarantees of
Runtime Permissions
Runtime permissions strive to provide contextual information
to users to help them make conscious decisions while granting
or denying permissions. In order to reliably and securely
deliver this contextual information, Android warrants some
security guarantees: 1) users will always be provided with the
necessary contextual information, 2) users will be informed
about the identity of the app owning the current context at
the time of a permission request. Here, we discuss how these
guarantees rely on the validity of certain implicit assumptions
and present ways to invalidate them, undermining the security
of runtime permissions.
Contextual guarantee. This security guarantee states that
users should always be provided with context during requests.
Android attempts to achieve this by allowing apps to request
permissions only from the foreground. The runtime permis-
sion model aims to provide users with increased situational
context to help them with their permission decisions. Cur-
rently, Android provides contextual information to dynamic
permission requests in the form of graphical user interfaces.
That is, when the user is presented with a permission dialog,
they have the knowledge of what was on the screen and what
they were doing prior to the request to help them understand
how this permission might be used by the app. In order to
ensure users are always provided with contextual information
at the time of permission requests, Android allows permis-
sions to be requested only from the context of UI-based app
USENIX Association
29th USENIX Security Symposium    417
components such as activities and fragments and the request-
ing component has to be in the foreground at the time of the
request. The assumption here is that since apps are allowed to
request permissions only from the foreground, users will al-
ways be provided with a meaningful context. In our work, we
show that this assumption is conceptually broken as we can
utilize the existing features offered to developers by the An-