⚫ A：Automatic（自动化） 
⚫ I：Independent（独立性） 
⚫ R：Repeatable（可重复） 
2. 【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，
执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。
单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。 
3. 【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之
间决不能互相调用，也不能依赖执行的先后次序。 
反例：method2 需要依赖 method1 的执行，将执行结果作为 method2 的输入。 
4. 【强制】单元测试是可以重复执行的，不能受到外界环境的影响。 
说明：单元测试通常会被放到持续集成中，每次有代码 check in 时单元测试都会被执行。如果单测对外部
环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。 
正例：为了不受外界环境影响，要求设计代码时就把 SUT 的依赖改成注入，在测试时用 spring 这样的 DI
框架注入一个本地（内存）实现或者 Mock 实现。 
5. 【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类
级别，一般是方法级别。 
说明：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，
那是集成测试的领域。 
6. 【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。 
说明：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。 
7. 【强制】单元测试代码必须写在如下工程目录：src/test/java，不允许写在业务代码目录下。 
说明：源码编译时会跳过此目录，而单元测试框架默认是扫描此目录。 
8. 【推荐】单元测试的基本目标：语句覆盖率达到 70%；核心模块的语句覆盖率和分支覆盖率
都要达到 100% 
说明：在工程规约的应用分层中提到的 DAO 层，Manager 层，可重用度高的 Service，都应该进行单元
测试。 
Java 开发手册 
  29/44 
9. 【推荐】编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。 
⚫ B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。 
⚫ C：Correct，正确的输入，并得到预期的结果。 
⚫ D：Design，与设计文档相结合，来编写单元测试。 
⚫ E：Error，强制错误信息输入（如：非法数据、异常流程、业务允许外等），并得到预期的结果。 
10. 【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，
或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。 
反例：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数
据并不符合业务插入规则，导致测试结果异常。 
11. 【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者
对单元测试产生的数据有明确的前后缀标识。 
正例：在企业智能事业部的内部单元测试中，使用 ENTERPRISE_INTELLIGENCE _UNIT_TEST_的前缀来
标识单元测试相关代码。 
12. 【推荐】对于不可测的代码在适当的时机做必要的重构，使代码变得可测，避免为了达到测
试要求而书写不规范测试代码。 
13. 【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好
覆盖所有测试用例。 
14. 【推荐】单元测试作为一种质量保障手段，在项目提测前完成单元测试，不建议项目发布后
补充单元测试用例。 
15. 【参考】为了更方便地进行单元测试，业务代码应避免以下情况： 
⚫ 构造方法中做的事情过多。 
⚫ 存在过多的全局变量和静态方法。 
⚫ 存在过多的外部依赖。 
⚫ 存在过多的条件语句。 
说明：多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。 
16. 【参考】不要对单元测试存在如下误解： 
⚫ 那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。 
⚫ 单元测试代码是多余的。系统的整体功能与各单元部件的测试正常与否是强相关的。 
⚫ 单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。 
⚫ 单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。 
Java 开发手册 
  30/44 
四、安全规约 
1. 【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。 
说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容、修改
他人的订单。 
2. 【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。 
说明：中国大陆个人手机号码显示为:137****0969，隐藏中间 4 位，防止隐私泄露。 
3. 【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注
入，禁止字符串拼接 SQL 访问数据库。 
4. 【强制】用户请求传入的任何参数必须做有效性验证。 
说明：忽略参数校验可能导致： 
⚫ page size 过大导致内存溢出 
⚫ 恶意 order by 导致数据库慢查询 
⚫ 任意重定向 
⚫ SQL 注入 
⚫ 反序列化注入 
⚫ 正则输入源串拒绝服务 ReDoS 
说明：Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻
击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。 
5. 【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。 
6. 【强制】表单、AJAX 提交必须执行 CSRF 安全验证。 
说明：CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在 CSRF 漏洞的应用
/网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户不知情的情况下对数据库中
用户参数进行相应修改。 
7. 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的
机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。 
说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并
造成短信平台资源浪费。 
8. 【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词
过滤等风控策略。 
Java 开发手册 
  31/44 
五、MySQL 数据库 
(一) 建表规约 
1. 【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned 
tinyint（1 表示是，0 表示否）。 
说明：任何字段如果为非负数，必须是 unsigned。 
注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在设置从 is_xxx
到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取
值含义与取值范围。 
正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。 
2. 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间
只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重
考虑。 
说明：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表
名、字段名，都不允许出现任何大写字母，避免节外生枝。 
正例：aliyun_admin，rdc_config，level3_name 
反例：AliyunAdmin，rdcConfig，level_3_name 
3. 【强制】表名不使用复数名词。 
说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合
表达习惯。 
4. 【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。 
5. 【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。 
说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。 
6. 【强制】小数类型为 decimal，禁止使用 float 和 double。 
说明：在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的
结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。 
7. 【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 
8. 【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长
度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索
引效率。 
9. 【强制】表必备三字段：id, create_time, update_time。 
说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。create_time, update_time
的类型均为 datetime 类型。 
Java 开发手册 
  32/44 
10. 【推荐】表的命名最好是遵循“业务名称_表的作用”。 
正例：alipay_task / force_project / trade_config 
11. 【推荐】库名与应用名称尽量一致。 
12. 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。 
13. 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循： 
 1） 不是频繁修改的字段。 
 2） 不是 varchar 超长字段，更不能是 text 字段。 
    3） 不是唯一索引的字段。 
正例：商品类目名称使用频率高，字段长度短，名称基本一不变，可在相关联的表中冗余存储类目名
称，避免关联查询。 
14. 【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 
说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 
15. 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检
索速度。 
正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。 
对象 
年龄区间 
类型 
字节 
表示范围 
人 
150 岁之内 
tinyint unsigned 
1 
无符号值：0 到 255 
龟 
数百岁 
smallint unsigned 
2 
无符号值：0 到 65535 
恐龙化石 
数千万年 
int unsigned 
4 
无符号值：0 到约 42.9 亿 
太阳 
约 50 亿年 
bigint unsigned 
8 
无符号值：0 到约 10 的 19 次方 
(二) 索引规约 
1. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 
说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，
即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 
2. 【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询
时，保证被关联的字段需要有索引。 
说明：即使双表 join 也要注意表索引、SQL 性能。 
3. 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据
实际文本区分度决定索引长度即可。 
Java 开发手册 
  33/44 
说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达
90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。 
4. 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 
说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 
5. 【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合
索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。 
正例：where a=? and b=? order by c; 索引：a_b_c 
反例：索引如果存在范围查询，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引 a_b 无