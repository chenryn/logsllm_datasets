A. Creating Contention on CPU Components
As any shared resource can potentially lead to an ex-
ploitable side channel, we wish to map out as many different
sources of contention as possible within a given CPU core.
This later allows us to ﬁnd the best performing side channel
for a given a software target.
Similar to the Covert Shotgun’s blog post [20], our ap-
proach tries to ﬁnd whether two instructions create observ-
able contention on various CPU components. Unlike Covert
Shotgun’s handful of carefully picked instructions, however,
ABSynthe’s blackbox strategy covers the entire x86_64 ISA
and synthesizes side-channel attacks rather than much simpler
covert channels. For this purpose, we need to ﬁnd instruction
sequences that create the largest possible observable con-
tention. To approach this in a principled way, we investigate
measurable contention caused by any single instruction. We
design an experiment that runs on a single physical core and
measures interference CCB,A, which can be read as “Interfer-
ence factor that instruction B experiences under inﬂuence of
instruction A.” We call B the reader instruction (we observe
its latency), A the writer instruction (it causes the latency
difference, if any), and the CCB,A matrix the leakage map
for a certain microarchitecture.
To make this possible for all instructions, we build on
the XML ﬁle containing an exhaustive list of the instructions
available of each microarchitecture of the uops.info [21]
project to generate an implementation of Algorithm 1 auto-
matically. Our reasoning is that any element CCB,A > 1.0 is
evidence of contention generated by A and experienced by B.
To visualize the results, we group the rows and columns of
CC by execution port usage of the corresponding instruction,
again obtained from [21]. There are two reasons for this.
First, since execution ports can be a source of contention,
we wish to group this inﬂuence in contiguous bands in the
visualization. Second, this ordering serves to group together
instructions with similar functions and utilizing the same
sets of execution units. We construct the CCB,A matrix by
measuring the latency of instruction B while instruction A
Algorithm 1: Constructing Covert Channel matrix CCB,A
is executing (denoted LAT (B, A)) concurrently on a sibling
thread, and express this latency as a factor of NOP executing
concurrently: CCB,A = LAT (B, A)/LAT (B, N OP ). The
full procedure is described in Algorithm 1.
We perform Algorithm 1 on two different Intel microarchi-
tectures, Skylake and Broadwell Xeon, and one AMD microar-
chitecture, ZEN+, using the EPYC platform. Figure 2 shows
the leakage maps for these microarchitectures. A column repre-
sents the signature of a single instruction A running on SMT1,
composed of many observations of different instructions B
running on SMT2.
B. Discussion of the Results
Our measurements show that while execution ports are
indeed a source of contention [10, 11], they are hardly unique
and also interfere in more intricate ways than previously
thought. Firstly, the contention pattern is not purely a function
of execution port sets. In particular, instructions that share
execution port sets may equally well show no contention
or high contention. Secondly, instructions that do not share
execution ports show overall low contention, but there are
clusters and streaks of high contention patterns here also—
implying shared microarchitectural resources between SMTs
that are not purely execution ports or even execution units.
Signiﬁcantly, we note that
the contention signature of
4
Fig. 3: High-level overview of ABSynthe.
every instruction (shown as a single column in the CC
matrix), is different from that of other instructions. In other
words, the CC matrix does not lend itself for simpliﬁcation by
grouping together instructions with identical signatures. Even
when already grouped together according to execution ports,
the interference signature is generally different each time,
implying that there are many different causes for contention.
Lesson 1: There are multiple independent sources of
contention.
Examining the CC matrices further, we notice the structure
of resource contention is very different for each leakage map.
Even microarchitectures
same manufacturer
(Intel) have a different leakage map. This suggests that a
contention-based side-channel attack in one microarchitecture
may not work well in another and this process may need to
be repeated, unless it can be done in a fully black-box manner.
from the
Lesson 2: A contention-based side channel on one
microarchitecture may not work as well on another.
We further see clusters which correspond to shared
resources used by one set of instructions interfering with
other sets of instructions. For instance, the Skylake results
exhibit a small number of clusters in the P0,P0 cell, whereas
Broadwell Xeon shows a large number of clusters in the
P0,P0 cell, and smaller clusters in other cells. Every row
(corresponding to one reader
instruction) with a small
number of high contention values on writer instructions,
will show reliable detection for those writer instructions.
These ﬁndings suggest
the best possible (within the
possibilities of ABSynthe) side channel may be obtained by
creating contention on many different resources and possibly
on multiple resources at the same time.
that
Lesson 3: The best contention-based side channel may
require contention from multiple instructions.
V. AUTOMATED SIDE-CHANNEL SYNTHESIS
Given our earlier observations, we designed ABSynthe, an
automated system that synthesizes, within parameters, the best
possible contention-based side channel for a given software
target by trying different sequences of instructions and creating
the appropriate contention on different microarchitectural com-
ponents. Figure 3 presents a high-level overview of ABSynthe.
In the analysis phase, ABSynthe takes a given microarchi-
tecture and the target software as input. It then automatically
generates an instrumented binary that synchronizes with a
spy program whenever it performs a secret operation. The
spy code is initially based on instructions from the target
microachitecture’s leakage map. For every well-performing
instruction in the leakage map, ABSynthe communicates the
raw contention-based measurements to the synthesis engine.
The synthesis engine aims to improve the quality of the
signal by generating new sequences of instructions based on
the contention-based measurements. These new instruction
sequences repeatedly reﬁne the spy code until the synthesized
side channel can detect the secret information with sufﬁcient
conﬁdence. We ﬁnd in our evaluation that
in many cases
single instructions can achieve an acceptable performance for
side-channel synthesis. In other cases, however, reﬁning the
instruction sequence signiﬁcantly improves the results.
After the analysis phase, in which ABSynthe uses synchro-
nized steps to classify secret bits, the attack phase uses the spy
code and ABSynthe’s secret recovery engine to leak the secret
information with no synchronization with the victim software
(making it suitable for practical attacks). To realize these two
phases in ABSynthe, we need to address three challenges:
C1 In the analysis phase, ABSynthe needs to automatically
instrument the target software to synchronize the mea-
surements with the spy code for collecting ground truth.
C2 In the analysis phase, ABSynthe needs to automatically
reﬁne the side channel for a given microarchitecture.
C3 In the attack phase, ABSynthe needs to recover secret
information with a non-cooperating victim binary using
the reﬁned side channel.
We conclude that ﬁnding a sequence of instructions that
optimally distinguishes a particular subset of target instruc-
tions, may require particular and non trivial combinations of
reader instructions. Furthermore, the leakage maps for different
microarchitectures do not generalize, and we have to repeat our
black-box synthesis for each microarchitecture separately. We
use these insights in the design of ABSynthe discussed next.
Section VI describes how we addressed these challenges
in the design of ABSynthe. In summary, to address C1, we
use a combination of taint analysis and a novel technique
that makes use of performance counters. To address C2, we
use a differential evolutionary genetic algorithm relying on a
Gaussian Naive Bayes classiﬁer as its ﬁtness function. Finally,
to address C3, we use an RNN classiﬁer for unsynchronized
key bit stream recovery.
5
          Attack Phase                                  Ground Truth       Analysis Phase MicroarchitectureGround TruthEngineTarget CodeSecretRecovery Engine Reﬁnement LogicMeasurementsSpy codeTarget BinaryMeasurementsOptimizedSpy codeSynthesisEngineInstrumentedTarget Binaryfor (j=nbits-1; j >= 0; j--) {
CRYPTLOOP_START(0);
_gcry_mpi_ec_dup_point(result,result,ctx);
_gcry_mpi_ec_add_points(&tmppnt,result,point,ctx);
if (mpi_test_bit (scalar, j)) {
CRYPTLOOP_VALUE(1); // bit == 1? pattern: ’01’
point_set (result, &tmppnt);
}
Fig. 6: Secret-dependent control ﬂow of hardened ED25519
algorithm. We present a simpliﬁed sketch.
CRYPTLOOP_START(0);
_gcry_mpih_sqr_n (xp, rp, rsize, tspace);
if ((mpi_limb_signed_t)e  0; i--) {
CRYPTLOOP_START(0);
_gcry_mpi_ec_dup_point (result, result, ctx);
if(mpi_test_bit(h,i)==1 && mpi_test_bit(k,i)==0) {
CRYPTLOOP_VALUE(1); // NAF == 1? pattern: ’01’
point_set(&p2,result);
_gcry_mpi_ec_add_points(result,&p2,&p1,ctx);
}
if(mpi_test_bit(h,i)==0 && mpi_test_bit(k,i)==1) {
CRYPTLOOP_VALUE(2); // NAF == -1? pattern: ’02’
point_set(&p2, result);
point_set(&p1inv, &p1);
ec_subm(p1inv.y, ctx->p, p1inv.y, ctx);
_gcry_mpi_ec_add_points(result,&p2,&p1inv,ctx);
Fig. 4: Collecting ground truth information. The spy process is
connected to the target through shared memory and is running
on the same physical core.
1
2
3
4
5
6
7
8
for (j=nbits-1; j >= 0; j--) {
CRYPTLOOP_START(0); // pattern start, record ’0’
_gcry_mpi_ec_dup_point (result, result, ctx);
if (mpi_test_bit (scalar, j)) {
CRYPTLOOP_VALUE(1); // bit == 1? pattern: ’01’
_gcry_mpi_ec_add_points(result,result,point,ctx);
}
}
Fig. 5: Secret-dependent control ﬂow: EdDSA 25519 elliptic
curve multiplication, annotated for use in ABSynthe. If the
ABSynthe pattern is ‘01’, the bit value was 1, and if it is ‘0’,
the bit value was 0). The code is simpliﬁed.
VI. ABSYNTHE
At a high level, ABSynthe works by ﬁnding secret-
dependent control ﬂow in the target program during the
analysis, and then detecting those secret-dependent code paths
being executed, using a tuned measurement algorithm in a spy
process. To do so, we ﬁrst collect signals with known ground
truth and use them to classify unknown signals. Speciﬁcally, as
shown in Figure 4, we collect the ground truth by automatically
instrumenting the target program at places where it processes
a secret bit in order to collect the value of that bit, and then
combine these values with measurements of the contention-
based signal to determine how differently the signal looks
for different values. In this section we discuss how we ﬁnd
the secret-dependent branches and collect the ground truth
(Section VI-A), synthesize a tuned instruction sequence for
measurements (Section VI-B), and ﬁnally map the measured
signals to the secret (Section VI-C).
A. C1: Automatically ﬁnding secret-dependent branches
}
}
While executing the target program during the analysis
phase, ABSynthe’s Ground Truth Engine explicitly signals the
ground truth about the secret to the spy program. For this
purpose, ABSynthe needs to instrument the target program at
relevant secret-dependent program points. In the common case,
Fig. 8: Secret-dependent control ﬂow: elliptic curve multiplica-
tion NIST P-256. The scalar is represented with NAF, causing
3 cases instead of 2. The code is simpliﬁed.
6
Target Process+InstrumentationSMT Thread 0 Spy Process   SMT Thread 1 GroundTruthSecrets SignalMicroarchitecturalBackend ProbeOperationsSignalSecretOperations TABLE I: ABSynthe branch analysis. Number of unique
branches executed by the target code (Executed), selected to
be analyzed using Data Flow Analysis (DFA) for tainting,
found to be tainted (Taint), and ﬁnally selected for ABSynthe
instrumentation (Instrumented).
.
Target
ED25519
ED25519-hardened
RSA
ECDSA P-256
Executed
353
353
472
596
DFA
70
70
86
114
Taint
1
1
6
3
Instrumented
1
1
1
2
hold for crypto software. First, we assume that the operation
executes the secret-dependent branches for a substantial part of
the execution time in a number of iterations that is related to
the key size. Second, the branch instructions should depend
on the secret. As the public-key algorithms that we target
iterate in multiple rounds over the bits that make up the key,
taking up signiﬁcant time, and few other algorithms will do
so in a secret-dependent way, these properties hold for most
of the crypto code that is not explicitly designed to not have
secret dependent branches. ABSynthe ﬁnds the instrumentation
points by proﬁling using dynamic taint analysis (in our current
implementation by means of LLVM’s DFSan [22]), while just
requiring an analyst to taint the secret once in the source code.
For example, let us assume, that our target program ex-
ecutes the popular EdDSA 25519 elliptic curve cryptogra-
phy algorithm from libgcrypt. In the implementation, the
secret key is represented by a variable called scalar and
Figure 5 shows the relevant
loop with a secret-dependent
branch in line 4. Lines 2 and 5 are part of the ABSynthe
instrumentation and should be ignored for now. Figure 9 shows
a ﬂame graph breakdown for the EdDSA 25519 algorithm,
representing the occurrences of stack traces, of the target
execution as gathered using perf record. The key intuition
behind branch selection revolves around the transition from
gcry_mpi_ec_mul_point, which has nearly full cumu-
lative execution time, to gcry_mpi_ec_add_points, and
gcry_mpi_ec_dup_point. These two functions split the
execution time in a way that depends on the secret key (as
conﬁrmed by the snippet in Figure 5). While we illustrated this
for EdDSA 255519, it is a typical pattern: secret-dependent
branches divide the execution time between themselves. We
show annotated examples for the hardened version of EdDSA
25519 (Figure 6), RSA (Figure 7), and the NIST-P256 curve
(Figure 8).
We now combine the ﬂame graph with taint analysis to
ﬁnd the secret-dependent branches automatically, as follows:
1) We ﬁrst build the code using LLVM with DFSan enabled
and let ABSynthe taint all the data in the key ﬁle.
2) ABSynthe
proﬁles
program using
perf record to ﬁnd all functions with signiﬁcant
cumulative execution time, and instruments them with
code that tests if the condition of the branch is tainted.
the
target
3) For the ﬁnal ground-truth instrumentation, ABSynthe
selects all branches that are tainted and that executed a
signiﬁcant number of times with respect to the key size