(cid:3)(cid:5)(cid:6)(cid:4)
(cid:3)(cid:5)(cid:6)(cid:4)
(cid:3)(cid:5)(cid:6)(cid:4)
(cid:3)(cid:5)(cid:6)(cid:4)
…
…
…
(cid:3)(cid:5)(cid:6)(cid:4)
(cid:3)(cid:5)(cid:6)(cid:4)
(cid:3)(cid:5)(cid:6)(cid:4)
(cid:3)(cid:5)(cid:6)(cid:4)
(cid:9)(cid:23)(cid:14)(cid:12)(cid:17)(cid:11)(cid:19)(cid:1)(cid:5)(cid:10)
(cid:9)(cid:23)(cid:14)(cid:12)(cid:17)(cid:11)(cid:19)(cid:1)(cid:5)(cid:10)
(cid:9)(cid:23)(cid:14)(cid:12)(cid:17)(cid:11)(cid:19)(cid:1)(cid:5)(cid:10)
(cid:9)(cid:16)(cid:11)(cid:24)(cid:14)(cid:13)(cid:1)(cid:7)(cid:14)(cid:20)(cid:22)(cid:24)(cid:28)(cid:1)(cid:29)
(cid:9)(cid:16)(cid:11)(cid:24)(cid:14)(cid:13)(cid:1)(cid:7)(cid:14)(cid:20)(cid:22)(cid:24)(cid:28)(cid:1)(cid:29)(cid:1)
(cid:6)(cid:30)(cid:1)(cid:3)(cid:11)(cid:12)(cid:16)(cid:14)
(cid:6)(cid:30)(cid:1)(cid:3)(cid:11)(cid:12)(cid:16)(cid:14)
(cid:4)(cid:7)(cid:10)
(cid:3)(cid:5)(cid:7)(cid:2)(cid:1)(cid:4)(cid:9)(cid:8)(cid:11)(cid:10)(cid:9)(cid:6)(cid:6)(cid:5)(cid:10)
Streaming Multiprocessor
Streaming Multiprocessor
RTL model
SW Fault Injection
CUDA  core
CUDA  core
(cid:11)(cid:18)(cid:21)(cid:16)(cid:19)(cid:18)(cid:20)(cid:16)(cid:1)(cid:12)(cid:16)(cid:17)(cid:2)
(cid:11)(cid:18)(cid:21)(cid:16)(cid:19)(cid:18)(cid:20)(cid:16)(cid:1)(cid:12)(cid:16)(cid:17)(cid:2)
(cid:8)
(cid:4)
(cid:13)
(cid:6)
(cid:7)
(cid:6)
(cid:5)
(cid:10)
(cid:4)
(cid:6)
(cid:5)
(cid:2)
(cid:5)
(cid:3)
(cid:6)
(cid:12)
(cid:4)
(cid:6)
(cid:15)
(cid:6)
(cid:9)
(cid:6)
(cid:13)
(cid:12)
(cid:14)
(cid:3)(cid:7)(cid:28)(cid:27)
(cid:3)(cid:7)(cid:28)(cid:27)
(cid:3)(cid:10)
(cid:3)(cid:10)
(cid:4)(cid:6)(cid:9)
(cid:4)(cid:6)(cid:9)
(cid:3)(cid:10)
(cid:3)(cid:10)
(cid:12)(cid:20)(cid:19)(cid:23)(cid:21)(cid:20)(cid:17)
(cid:12)(cid:20)(cid:19)(cid:23)(cid:21)(cid:20)(cid:17)
(cid:8)(cid:14)(cid:15)(cid:17)(cid:25)(cid:26)(cid:14)(cid:24)(cid:1)(cid:5)(cid:17)(cid:19)(cid:14)
(cid:27)(cid:14)(cid:17)(cid:21)(cid:22)(cid:20)(cid:23)(cid:8)(cid:22)(cid:14)(cid:18)(cid:17)(cid:1)(cid:18)(cid:19)(cid:8)(cid:18)(cid:9)(cid:10)
(cid:27)(cid:14)(cid:17)(cid:21)(cid:22)(cid:20)(cid:23)(cid:8)(cid:22)(cid:14)(cid:18)(cid:17)(cid:1)(cid:18)(cid:19)(cid:8)(cid:18)(cid:9)(cid:10)
(cid:27)(cid:14)(cid:17)(cid:19)(cid:23)(cid:22)(cid:1)(cid:24)(cid:6)(cid:15)(cid:23)(cid:10)(cid:1)(cid:20)(cid:6)(cid:17)(cid:12)(cid:10)
(cid:27)(cid:14)(cid:17)(cid:19)(cid:23)(cid:22)(cid:1)(cid:24)(cid:6)(cid:15)(cid:23)(cid:10)(cid:1)(cid:20)(cid:6)(cid:17)(cid:12)(cid:10)
(cid:27)(cid:2)(cid:4)(cid:5)(cid:1)(cid:16)(cid:18)(cid:9)(cid:23)(cid:15)(cid:10)(cid:1)
(cid:27)(cid:2)(cid:4)(cid:5)(cid:1)(cid:16)(cid:18)(cid:9)(cid:23)(cid:15)(cid:10)
(cid:10)(cid:11)(cid:11)(cid:10)(cid:8)(cid:22)(cid:1)(cid:18)(cid:17) (cid:14)(cid:17)(cid:21)(cid:22)(cid:20)(cid:23)(cid:8)(cid:22)(cid:14)(cid:18)(cid:17)(cid:26)(cid:1)
(cid:10)(cid:11)(cid:11)(cid:10)(cid:8)(cid:22)(cid:1)(cid:18)(cid:17)(cid:1)(cid:14)(cid:17)(cid:21)(cid:22)(cid:20)(cid:23)(cid:8)(cid:22)(cid:14)(cid:18)(cid:17)(cid:26)(cid:1)
(cid:27)(cid:20)(cid:10)(cid:15)(cid:6)(cid:22)(cid:14)(cid:24)(cid:10)(cid:1)(cid:18)(cid:23)(cid:22)(cid:19)(cid:23)(cid:22)(cid:1)(cid:10)(cid:20)(cid:20)(cid:18)(cid:20)
(cid:27)
(cid:20)(cid:10)(cid:15)(cid:6)(cid:22)(cid:14)(cid:24)(cid:10)(cid:1)(cid:18)(cid:23)(cid:22)(cid:19)(cid:23)(cid:22)(cid:1)(cid:10)(cid:20)(cid:20)(cid:18)(cid:20)
(cid:27)(cid:30)(cid:1)(cid:18)(cid:11)(cid:1)(cid:8)(cid:18)(cid:20)(cid:20)(cid:23)(cid:19)(cid:22)(cid:10)(cid:9)(cid:1)(cid:22)(cid:13)(cid:20)(cid:10)(cid:6)(cid:9)(cid:21)
(cid:27)(cid:30)(cid:1)(cid:18)(cid:11)(cid:1)(cid:8)(cid:18)(cid:20)(cid:20)(cid:23)(cid:19)(cid:22)(cid:10)(cid:9)(cid:1)(cid:22)(cid:13)(cid:20)(cid:10)(cid:6)(cid:9)(cid:21)
(cid:27)(cid:21)(cid:19)(cid:6)(cid:22)(cid:14)(cid:6)(cid:15)(cid:1)(cid:9)(cid:14)(cid:21)(cid:22)(cid:20)(cid:14)(cid:7)(cid:23)(cid:22)(cid:14)(cid:18)(cid:17)(cid:1)(cid:28)(cid:3)(cid:25)(cid:3)(cid:29)
(cid:27)(cid:21)(cid:19)(cid:6)(cid:22)(cid:14)(cid:6)(cid:15)(cid:1)(cid:9)(cid:14)(cid:21)(cid:22)(cid:20)(cid:14)(cid:7)(cid:23)(cid:22)(cid:14)(cid:18)(cid:17)(cid:1)(cid:28)(cid:3)(cid:25)(cid:3)(cid:29)
(cid:4)(cid:1)(cid:9)(cid:5)(cid:8)
(cid:6)(cid:7)(cid:2)(cid:3)(cid:5)
(cid:2)(cid:5)(cid:3)(cid:4)
(cid:2)(cid:5)(cid:3)(cid:4)
(cid:11)(cid:13)(cid:13)(cid:1)(cid:21)(cid:27)(cid:1)(cid:21)(cid:28)
(cid:11)(cid:13)(cid:13)(cid:1)(cid:21)(cid:27)(cid:1)(cid:21)(cid:28)
(cid:18)(cid:24)(cid:17) (cid:21)(cid:29)(cid:1)(cid:21)(cid:27)
(cid:18)(cid:24)(cid:17) (cid:21)(cid:29)(cid:1)(cid:21)(cid:27)
(cid:25)
(cid:25)
(cid:25)
(cid:25)
(cid:22)(cid:23)(cid:11) (cid:21)(cid:30)
(cid:22)(cid:23)(cid:11) (cid:21)(cid:30)
(cid:12)(cid:4)(cid:7)(cid:11)(cid:10)(cid:9)(cid:8)
(cid:12)(cid:4)(cid:7)(cid:11)(cid:10)(cid:9)(cid:8)
(cid:12)(cid:5)(cid:2)(cid:1)
(cid:12)(cid:5)(cid:2)(cid:1)
(cid:12)(cid:2)(cid:6)(cid:3)
(cid:12)(cid:2)(cid:6)(cid:3)
Fig. 2. Scheme of the proposed two-level fault injection framework. Using the RTL model we characterize the effects that faults in GPU modules (we do not
inject in the modules depicted as white boxes) have on the SASS instructions output. Based on the instruction opcode, its input, and the module of interest
we pick the fault model (syndrome) to inject in software on a real GPU that executes a code.
common GPU SASS instructions (or simply instructions),
gathering the syndrome induced by faults in the instruction
output value, i.e., we produce an accurate fault model for the
most common machine operations. As all GPU modules are
accessible in the RTL model, we can provide deeper insights
on GPU faults source and characterize also the faults effects on
multiple threads. Then, using an updated software framework
(NVBitFI), we inject the syndrome that comes from our RTL
analysis (rather than a simplistic fault model as all previous
works on GPU software fault injection do). The high speed
of software fault injection allows us to observe the effect of
fault syndromes in the execution of real-world applications,
while the few previous works on GPU RTL fault injection are
limited to naive workloads.
While the proposed strategy can effectively allow a more
detailed and accurate GPU reliability analysis, we acknowl-
edge some intrinsic limitations. (1) RTL is not the lowest
possible abstraction layer (see Figure 1). We choose RTL
fault
injection because the circuit or gate models are not
available for GPUs and their characterization would, in any
case, take too long. As shown in previous work, though, RTL
evaluation accuracy is very close to gate level simulation [14].
(2) Our evaluation shares with any other research work based
on open source models the limitation of being based on mature
architectures. FlexGripPlus, which is the only RTL open-
source GPU model currently available, is based on NVIDIA
G80 architecture. While we cannot guarantee that the observed
fault syndrome is representative of cutting-edge GPUs, the
G80 is still CUDA compliant and is based on the same
Instruction Set Architecture (ISA) of modern NVIDIA GPUs
such as Kepler, Volta, and Turing (with the exception of tensor
core and few other instructions based on updated modules).
As the hidden structures of a GPU, such as the scheduler and
the pipeline registers, are also supposed to be present even in
modern architectures, given the CUDA compatibility we made
the decision to use the RTL description we have available,
even if from a different generation. Also, while probably the
FlexGripPlus intrinsic limitation might impact the precision
of our evaluation, it does not undermine the impact of the
proposed strategy, that is directly adaptable to other GPU RTL
models, as they become available. (3) The syndrome imposed
by a fault could depend on the operation input. Testing all
inputs combination is obviously impossible. We decided to
limit the characterization to three input ranges.
III. OVERVIEW OF THE IDEA
The proposed reliability evaluation framework for GPUs is
divided in two main steps: RTL fault simulation and software
fault injection, as depicted in Figure 2.
Using a GPU RTL model (details in Section IV-A), we
inject faults in the GPU main computing modules. We consider
Pipeline Registers, Warp Scheduler, FP32 and INT functional
units, Special Function Units (SFUs), and control signals.
We do not
inject errors in memories (caches and register
ﬁle) as we assume that GPUs employed in applications with
strict reliability requirements feature ECC. Moreover, as a
fault
in a memory cell(s) affects a software visible state
directly (it translates into a corrupted value with no further
operations), its syndrome is already well known (single/double
bit-ﬂip) and depends just on the memory technology [24]. On
the contrary, a fault inside a computing resource during an
operation’s execution has a not-obvious impact on the output
(syndrome) [18], which we intend to characterize.
Rather than executing an application in the RTL model,
we characterize the effect of faults in a subset of GPU ISA
SASS instructions. A SASS instructions is the simplest, atomic,
two-inputs machine operation that form the NVIDIA GPU
compiled code, and is directly translated into hardware signals
inside the device. We choose to characterize the instruc-
tions that, based on GPU code proﬁling, are more common
in applications taken from universally adopted benchmark
suites for HPC and safety-critical applications (Rodinia [32],
NVIDIA SDK [33], CNNs [20], [21]). The chosen instruc-
tions, described in details in [34], are: Floating point opera-
tions (FADD, FMUL, FFMA - Fused Mul and Add), Integer
operations (IADD, IMUL, IMAD - Mul and Add), Trascen-
dental functions (SIN, EXP), Load/Store (GLD, GST), Branch
(BRA), and Integer set predicate/register (ISET). While these
the ≈200
instructions represent only a small part of all
different opcodes in a GPU ISA [34], they account for more
Authorized licensed use limited to: Tsinghua University. Downloaded on October 11,2021 at 08:56:48 UTC from IEEE Xplore.  Restrictions apply. 
295
(cid:14)(cid:22)(cid:7)(cid:6)
(cid:17)(cid:20)(cid:26)(cid:7)(cid:6)
(cid:14)(cid:25)(cid:17)(cid:20)(cid:3)(cid:14)(cid:13)(cid:29)(cid:22)
(cid:18)(cid:41)(cid:31)(cid:33)(cid:3)(cid:25)(cid:45)(cid:41)(cid:43)(cid:34)(cid:3)(cid:11)(cid:41)(cid:40)(cid:45)(cid:43)(cid:41)(cid:39)
(cid:21)(cid:26)(cid:16)(cid:13)(cid:24)(cid:25)
EVALUATED MODULES, SIZES AND INSTRUCTIONS USED PER MODULE
TABLE I
(cid:44)
(cid:40)
(cid:41)
(cid:37)
(cid:45)
(cid:32)
(cid:46)
(cid:43)
(cid:45)
(cid:44)
(cid:40)
(cid:37)
(cid:1)
(cid:35)
(cid:41)
(cid:1)
(cid:34)
(cid:36)
(cid:31)
(cid:45)
(cid:40)
(cid:34)
(cid:32)
(cid:43)
(cid:34)
(cid:22)
(cid:5)(cid:4)(cid:4)(cid:2)
(cid:10)(cid:4)(cid:2)
(cid:9)(cid:4)(cid:2)
(cid:8)(cid:4)(cid:2)
(cid:6)(cid:4)(cid:2)
(cid:4)(cid:2)
(cid:15)(cid:31)(cid:46)(cid:44)(cid:44)(cid:37)(cid:31)(cid:40)
(cid:18)(cid:31)(cid:47)(cid:31) (cid:23)(cid:46)(cid:37)(cid:32)(cid:38)(cid:44)(cid:41)(cid:43)(cid:45) (cid:16)(cid:41)(cid:45)(cid:44)(cid:42)(cid:41)(cid:45)
(cid:18)(cid:27)(cid:12)
(cid:19)(cid:48)(cid:19)
(cid:18)(cid:34)(cid:20)(cid:13)(cid:26) (cid:30)(cid:41)(cid:39)(cid:41)(cid:28)(cid:7)
Fig. 3. Applications instruction proﬁle. We characterize, with RTL injections,
FP32 (FADD, FMUL, FFMA), INT32 (IADD, IMUL, IMAD), Special Fun-
tions (FSIN, FEXP), Control (GLD, GST, Branch, ISET) SASS instructions.
”Others” are the instructions we do not characterize.
than 70% of the executed instructions in common codes for
GPUs, as shown in Figure 3. Our framework allows future
updates, to add additional instructions that are of interest. We
also characterize a mini-app (tiled MxM) to highlight possible
scheduler corruption effects that could be hidden in the SASS
instructions characterization (details in Section V-A).
A perfect RTL fault injection would require one to test
each instruction with the exact input values it receives when
executed in the code being characterized, which is clearly
unfeasible. We decide to limit the analysis to three input ranges
(Small, Medium, Large, as detailed in Section IV). Previous
work has shown that software fault injection results for GPUs
do not depend on the input value (with unbiased values) [35].
Part of our contribution is to understand if this result still holds
for RTL fault injection and how much the fault effect on the
instruction output depends on the input value.
With the RTL fault injection we have measured both the
probability for the fault to reach a software visible state (i.e.,
the Architectural Vulnerability Factor, AVF [36]) and the fault
impact on the instruction output value. We built a database
of possible fault syndromes based on: the instruction opcode,
the input range, and the injection site (the corrupted module).
To quantify the syndrome we built a statistical distribution
of the relative difference (i.e., absolute difference between
the expected and the faulty instruction output, divided by the
expected value). In other words, we track how much, in per-