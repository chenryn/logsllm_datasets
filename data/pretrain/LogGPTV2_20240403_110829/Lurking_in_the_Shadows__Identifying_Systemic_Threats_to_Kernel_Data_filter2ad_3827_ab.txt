0.143452
0.467953
0.010857
0.754544
0.003450
0.014060
0.115478
0.138635
0.212463
cnt1s
0.000000
0.000000
0.000000
0.000000
0.000000
0.000000
0.000000
0.000000
0.000000
0.000000
parkinglot mindist
0.000000
0.159241
0.000000
0.012559
0.000000
0.132155
0.400118
0.000000
0.000000
0.065416
0.000000
0.004431
0.000000
0.002061
0.192544
0.000000
0.000000
0.311526
0.072483
0.000000
sphere
0.893287
0.055361
0.001550
0.000258
0.212797
0.021339
0.000010
0.001535
0.071177
0.212785
squeeze
0.423572
0.769919
0.190808
0.573443
0.276961
0.047575
0.044232
0.024058
0.296367
0.338967
osum
0.641313
0.002603
0.032007
0.051299
0.009343
0.139662
0.068223
0.000078
0.003107
0.122016
craps
0.147407
0.066102
0.468605
0.057709
0.389614
0.082087
0.836221
0.214631
0.679244
0.710536
Table 3. Results of running the Diehard battery of tests after contamination of the entropy pool
erable.
Impact: This attack resembles a stealthier version of
the resource exhaustion attack, which traditionally has been
carried out over the network [17, 12, 11]. We try to achieve
a similar goal i.e to overwhelm the compromised system
subtly by creating artiﬁcial memory pressure. This leads to
a considerable performance overhead on the system. This
also causes a large amount of memory to be unused all
the time to maintain the high number of pages in the free
pool, leading to resource wastage. The attacker could keep
the degradation subtle enough to escape detection over ex-
tended periods.
2.3. Entropy Pool Contamination
This attack contaminates the entropy pool and the poly-
nomials used by the Pseudo-Random Number Generator
(PRNG) to stir the pools. The goal of this attack is to de-
grade the quality of the pseudo random numbers that are
generated by the PRNG. The kernel depends on the PRNG
to supply good quality pseudo random numbers, which are
used by all security functions in the kernel as well as by
applications for key generation, generating secure session
id’s, etc. All applications and kernel functions that depend
on the PRNG are in turn open to attack.
Background: The PRNG provides two interfaces to user
applications namely /dev/random and /dev/urandom. The
PRNG depends on three pools for its entropy requirements:
the primary pool, the secondary pool and the urandom pool.
The /dev/random is a blocking interface and is used for very
secure applications. The device maintains an entropy count
and blocks if there is insufﬁcient entropy available. Entropy
is added to the primary pool from external events such as
keystrokes, mouse movements, disk activity and network
activity. When a request is made for random bytes, bytes
are moved from the primary pool to the secondary and the
urandom pools. The /dev/urandom interface on the other
hand is non-blocking. The contents of the pool are stirred
when the bytes are extracted from the pools. A detailed
analysis of the Linux random number generator is available
in [6].
Attack Description: This attack constantly contami-
nates the entropy pool by writing zeroes into all the pools.
This is done by loading an attack module that consists of a
kernel thread. The thread constantly wakes up and writes
zeroes into the entropy pools. It also attacks the polynomi-
als that are used to stir the pool. Zeroing out these polyno-
mials nulliﬁes a part of the extraction algorithm used by the
PRNG. The location of the entropy pool is not exported by
the Linux kernel. We can ﬁnd the location by simply scan-
ning kernel memory. Entropy pool has the cryptographic
property of being completely random [15]. Since we know
the size of the entropy pools, this can be found by running
a sliding window of the same sizes through memory and
calculating the entropy of the data within the window. Ker-
nel code and data regions are more ordered than the entropy
pools and have a lower entropy value. The pool locations
can therefore be successfully located.
We measured the quality of the random numbers gener-
ated by using the diehard battery of tests [2]. The results are
summarized in Table 3. Diehard is the suite of tests used to
measure the quality of random numbers generated. Any test
that generates a value extremely close to 0 or 1 represents a
failing sequence. More about the details of these tests can
be found in [2]. We run the tests over ten different 10MB
ﬁles that were generated by reading from the /dev/random
device. The table shows that the sequence that is generated
after attack, fails miserably in two of the tests: cnt1s and
mindist and partially in the others. A failure in any one of
the tests means that the PRNG is no longer cryptographi-
cally secure.
Impact: After the attack, the generated pseudo random
numbers are of poor quality, leaving the system and appli-
cations vulnerable to cryptanalysis attacks.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:54:06 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 20072.4. Disable Pseudo-Random Number Gen-
erator (PRNG)
data structures that are vulnerable to a given category of at-
tacks.
This attack overwrites the addresses of the device func-
tions registered by the PRNG with the function addresses of
the attack code. The original functions are never invoked.
These functions always return a zero when random bytes are
requested from the /dev/random or /dev/urandom devices.
Note that though this appears similar to the attack by tra-
ditional rootkits that hook into function pointers, there is a
subtle difference. Since this particular device does not af-
fect user-level view of objects, this is not a target for achiev-
ing hiding behavior and hence, not monitored by kernel in-
tegrity monitors.
Attack Description: The kernel provides functions for
reading and writing to the /dev/random and /dev/urandom
devices. The data structures used to register the device func-
tions are called random state ops and urandom state ops
for the devices /dev/random and /dev/urandom respectively.
These symbols are exported by the 2.4 kernel but are not
exported by the 2.6 kernel. We could ﬁnd this data structure
by ﬁrst scanning for function opcodes of functions present
within random state ops and urandom state ops. We then
used the function addresses in the correct order to ﬁnd the
data structure in memory. Once these data structures are
located in memory, the attack module replaces the genuine
function provided by the character devices with the attack
function. The attack function for reading from the device
simply returns a zero when bytes are requested. After the
attack, every read from the device returns a zero.
Impact: All security functions within the kernel and
other security applications rely on the PRNG to supply
pseudo random numbers. This attack stealthily compro-
mises the security of the system, without raising any sus-
picions from the user.
3. Categorizing Attacks
We have identiﬁed several attack categories based on the
tampering techniques employed. The categories are derived
from the techniques used by rootkits in existence as well as
the new class of attacks that we have designed. These at-
tacks span across static as well as dynamic data in the ker-
nel. The ﬁrst two categories described, namely control hi-
jacking and control interception, involve directly changing
the control path in the kernel by manipulating jump tables
or function pointers. The last three categories, namely con-
trol tapping, data value manipulation and inconsistent data
structures, work solely by manipulating non-control data.
Our motivation behind creating these categories is to
identify the broader systemic problem in the kernel, rather
than the individual attacks themselves. This helps in build-
ing defense techniques that are generic and that can be ap-
plied comprehensively throughout the kernel to protect all
3.1. Control Hijacking
Control hijacking attack is a form of manipulating the
control ﬂow within a kernel control path. This attack redi-
rects the control ﬂow to the attack code and the original
code is never actually invoked. The attacks that we designed
in this category are (a) disable ﬁrewall attack and the (b) dis-
able PRNG attack. All layers in the kernel, originally put in
for extensibility and to provide a common interface, can be
abused to perform such an attack. All jump tables and func-
tion pointers are also susceptible to this form of attack.
3.2. Control Interception
Control interception was the technique used by most tra-
ditional rootkits that changed the system call table, IDT and
the kernel code. These attacks intercept the kernel control
path in such a way that control ﬁrst ﬂows to the attack code.
The attack code then calls the original code. This way, the
attacker is able to ﬁlter requests to and responses from the
original code. Control interception is typically used for hid-
ing the attacker’s ﬁles, processes and network connections.
All layers, jump tables and function pointers are susceptible
to this form of attack as well.
3.3. Control Tapping
Control tapping ensures that the attack code is invoked
en route to the original function. In other words, the inter-
ception takes place in such a way that the attack code is not
able to manipulate the arguments and results of the original
function being called. The only assurance for this type of
interception is that the attack code will be invoked on every
call to the original function. One example of this form of
attack is the attack hooking to the execve system call done
by registering a new binary format. This attack is discussed
in [3].
3.4. Data Value Manipulation
These attacks rely on manipulating values of critical
variables, which in turn directly or indirectly inﬂuence the
algorithms used by the kernel. Defending from such an at-
tack requires a close analysis of data structure values and
some form of value based monitoring. The attacks that we
developed that fall in this category are (a) resource wastage
attack and (b) entropy pool contamination attack.
3.5. Inconsistent Data Structures
This class of attacks makes kernel data structures incon-
sistent, which are otherwise supposed to be consistent dur-
ing normal operation. Two common known methods used
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:54:06 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007are process hiding and module hiding. Process hiding is
achieved by the fact that the kernel uses separate lists for
scheduling and accounting. The malicious process is re-
moved from the accounting list but not from the scheduler
list, so the process is still scheduled. Module hiding is done
by removing the module entry from the module list after the
module is loaded in memory, making it invisible accounting
commands.
4. Related Work
Garﬁnkel et al [5] proposed to use virtual machine based
introspection. Zhang et al
[18] proposed the use of a se-
cure coprocessor that can verify the integrity of the ker-
nel. Petroni et al [7] demonstrated a prototype that could
successfully monitor the integrity of kernel code and static
tables from a secure coprocessor. In another recent work
[8], they also built a speciﬁcation based compiler that could
compile high-level manually speciﬁed constraints and mon-
itor for those constraints within kernel dynamic data. This
work however requires the user to either know the attack
signature or anticipate it and generate a speciﬁcation. Sev-
eral attestation based approaches have been proposed to ver-
ify the integrity of running code [14, 9, 16, 13]. These ap-
proaches use a secure chip as the trusted computing base
to bootstrap trust. The veriﬁcation procedure is based on
comparing hashes with known good values or timing calcu-
lations. While these approaches work well for checking the
integrity of code, they cannot check the integrity of data.
5. Conclusion and Future Work
In this paper, we have demonstrated a new class of stealth
attacks that do not employ the traditional hiding behavior
used by rootkits. We have designed attack prototypes to
demonstrate that such attacks are realistic and indicative
of a more systemic problem in the kernel. Furthermore,
they cannot be detected by currently known monitoring ap-
proaches without prior knowledge of the attack signatures.
We have also classiﬁed the data tampering techniques used
by all known kernel tampering malware. As part of future
work, our goal is to design an automated comprehensive in-
tegrity monitor for kernel data.
Acknowledgments
We would like to thank Joe Kilian for his insightful com-
ments and discussions on this work and early drafts of the
paper. We would also like to thank Trent Jaegar (shepherd)
and the anonymous reviewers for their feedback in reﬁning
the paper. This work has been supported in part by the NSF
CAREER grant CCR-0133366.
References
[1] Advanced
intrusion
detection
environment.
http://sourceforge.net/projects/aide.
binary
ker-
nel’s
See
http://www.packetstormsecurity.org/papers/general/binfmt-
en.pdf, 2006.
linux
Shellcode
weakness
formats.
-
[4] D. Beck, B. Vo, and C. Verbowski. Detecting stealth soft-
ware with strider ghostbuster.
In Proceedings of the 2005
International Conference on Dependable Systems and Net-
works (DSN’05).
[5] T. Garﬁnkel and M. Rosenblum. A virtual machine in-
trospection based architecture for intrusion detection.
In
Proc. Network and Distributed Systems Security Sympo-
sium, 2003.
[6] Z. Gutterman, B. Pinkas, and T. Reinman. Analysis of the
linux random number generator. In Proceedings of the 2006
IEEE Symposium on Security and Privacy. IEEE Computer
Society, 2006.
[7] N. L. P. Jr., T. Fraser, J. Molina, and W. A. Arbaugh. Copilot
- a coprocessor-based kernel runtime integrity monitor. In
USENIX Security Symposium, 2004.
[8] N. L. P. Jr., T. Fraser, A. Walters, and W. A. Arbaugh. An
architecture for speciﬁcation-based detection of semantic in-
tegrity violations in kernel dynamic data. In USENIX Secu-
rity Symposium, 2006.
[9] R. Kennell and L. H. Jamieson. Establishing the genuinity
of remote computer systems. 12th USENIX Security Sym-
posium, Washington DC, 09 2003.
[2] The marsaglia random number cdrom including the diehard
G Marsaglia - See
battery of tests of randomness.
http://stat.fsu.edu/pub/diehard, 1996.
in
[3] Registration
[10] G. H. Kim and E. H. Spafford. The design and implementa-
tion of tripwire: a ﬁle system integrity checker. In Proceed-
ings of the 2nd ACM Conference on Computer and commu-
nications security, 1994.
[11] D. Moore, C. Shannon, D. J. Brown, G. M. Voelker, and
S. Savage. Inferring internet denial-of-service activity. ACM
Trans. Comput. Syst., 24(2):115–139, 2006.
[12] C. L. Schuba, I. V. Krsul, M. G. Kuhn, E. H. spafford,
A. Sundaram, and D. Zamboni. Analysis of a denial of ser-
vice attack on tcp. sp, 00:0208, 1997.
[13] A. Seshadri, M. Luk, E. Shi, A. Perrig, L. van Doorn, and
P. K. Khosla. Pioneer: verifying code integrity and enforcing
untampered code execution on legacy systems.
In SOSP,
pages 1–16, 2005.
[14] A. Seshadri, A. Perrig, L. van Doorn, and P. Khosla.
Swatt: Software-based attestation for embedded devices. sp,
00:272, 2004.
[15] A. Shamir and N. van Someren. Playing ”hide and seek”
with stored keys. In FC ’99: Proceedings of the Third In-
ternational Conference on Financial Cryptography, pages
118–124, London, UK, 1999. Springer-Verlag.
[16] E. Shi, A. Perrig, and L. van Doorn. Bind: A ﬁne-grained
attestation service for secure distributed systems. In IEEE
Symposium on Security and Privacy, pages 154–168, 2005.
[17] H. Wang, D. Zhang, and K. Shin. Detecting syn ﬂooding
attacks. 2002.
[18] X. Zhang, L. van Doorn, T. Jaeger, R. Perez, and R. Sailer.
Secure coprocessor-based intrusion detection. In Proceed-
ings of the 10th workshop on ACM SIGOPS European work-
shop: beyond the PC, 2002.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:54:06 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007