tablet). When only errors are present, 85%
of them) had all bits of the exponent recovered correctly,
except for the most signiﬁcant 4 bits. These 4 bits are
processed before entering the code in Figure 3 to leave a
whole number of 5-bit windows for that code, so we do
not attempt to recover them and treat them as erasures.
Among the OLinuXino decryption instances that had any
other reconstruction errors, nearly all had only one addi-
tional incorrectly recovered bit (error, not erasure), and a
few had two.
The results for the Samsung phone were slightly worse
– in addition to the 4 most signiﬁcant bits, several de-
cryption instances had one additional bit that was left
unknown (erasure) because of an interrupt that occurs be-
tween the derivative-of-moving-median peak and the end
of the snippet that follows it, which either obliterates the
peak or prevents the snippet from correctly being cate-
gorized according to its control ﬂow. In addition to these
unknown (but known-to-be-unknown) bits, for the Sam-
sung phone the reconstruction also produced between 0
and 4 incorrectly recovered (error) bits.
Finally, for the Alcatel Ideal phone most instances of
the encryption had between 13 and 16 unknown bits in
each of the two exponents, mostly because activity on
the other three cores interferes with the activity on the
core doing the RSA decryption), and a similar number of
incorrectly recovered bits (errors).
USENIX Association
27th USENIX Security Symposium    597
95%96%97%98%99%100%Samsung GalaxyCentura PhoneAlcatel IdealPhoneOLinuXinoBoardMaxMedianMinFigure 10: Success rate for recovery of secret exponent
dp’s bits during only one instance of RSA-2048 decryp-
tion that uses that exponent, when training on OLin-
uXino board #1 and then using that training data for
unknown exponent recovery on the same board and on
seven other boards. For each device, the maximum, me-
dian, and minimum success rate among decryption in-
stances (each with a different randomly generated key)
is shown.
To examine how the results would be affected when
training using signals collected on one device and then
recovering exponent bits using signals obtained from an-
other device of the same kind, we use eight OLinuXino
boards1, which we label #1 through #8. Our training
uses signals obtained only from board #1, and then the
unknown keys are used on each of the eight boards and
subjected to analysis using the same training data (from
board #1). The results of this experiment are shown in
Figure 10, where the leftmost data points correspond to
training and recovery on the same device, while the re-
maining seven sets of data points correspond to training
on one board and recovery on another.
These results indicate that training on a different de-
vice of the same kind does not substantially affect the
accuracy of recovery.
Finally, for each RSA decryption instance, the recov-
ered exponent bits, using both the recovered dp and the
recovered dq, were supplied to our implementation of the
full-key reconstruction algorithm. For each instance, the
correct full RSA private key was reconstructed within
one second on the Core i7-based Surface Pro 4 tablet,
including the time needed to ﬁnd the kp and kq coefﬁ-
cients that were not known a priori. This is an expected
result, given that even the worst bit recovery rates (for
the Alcatel phone) correspond to a an error rate of about
1.5%, combined with an erasure rate of typically 1.5%
but sometimes as high as 3% (depending on how much
system activity occurs while RSA encryption is execu-
1The OLinuXino boards are much less expensive than the phones,
so we could easily obtain a number of OLinuXino boards
Figure 11: Success rate for recovery of secret exponent
dp’s bits during only one instance of RSA-2048 decryp-
tion that uses that exponent for sliding-window exponen-
tiation. The maximum, median, and minimum success
rate among decryption instances (each with a different
randomly generated key) is shown for recovery that only
uses the snippet-type sequence (S-M-Z Sequence), and
for recovery that also recovers window bits from U-S and
Z-S snippets (Overall).
tion on the phone), which is well withing the range for
which our full-key reconstruction is extremely efﬁcient.
4.4 Results for the Sliding-Window
Implementation
To improve our understanding of the implications for
this new attack approach, we also apply it to RSA-
2048 whose implementation uses OpenSSL’s sliding-
window exponentiation – recall that this was the de-
fault implementation used in OpenSSL until it switched
to a ﬁxed-window implementation in response to at-
tacks that exploit sliding-window’s exponent-dependent
square-multiply sequence.
In these experiments we use 160 MHz of bandwidth
and target the OLinuXino board. Recall that in a sliding-
window implementation our method can categorize the
snippets according to their beginning/ending point to
recover the sequence of zero-squaring (Z), window-
squaring (S), and result update (M) occurrences. The
fraction of the exponent’s bits recovered by this se-
quence reconstruction (shown as “S-M-Z Sequence” in
Figure 11) is in our experiments between 51.2% and
57.7% with a median of 54.5%. This sequence-based re-
covery has produces no errors in most cases (keys), and
among the few encryptions that had any errors, none had
more than one.
In our attack approach, after this sequence-based re-
construction, the U-S and Z-S snippets are subjected to
further analysis to recover the remaining bits of the win-
dow computed in each U-S and Z-S snippet. At the end
598    27th USENIX Security Symposium
USENIX Association
98.0%98.5%99.0%99.5%100.0%#1(Self)#2#3#4#5#6#7#8MaxMedianMin50%60%70%80%90%100%S-M-Z SequenceOverallMaxMedianMinof this analysis, the fraction of the exponent’s bits that are
correctly recovered (“Overall” in Figure 11) is between
97.7% and 99.6%, with a median of 98.7%.
This rate of recovery for exponent bits provides for
very rapid reconstruction of the full RSA key. How-
ever, we note that it is somewhat inferior to our results on
ﬁxed-window exponentiation on the same device (OLin-
uXino board), in spite of using more bandwidth for at-
tacks on sliding-window (160MHz bandwidth) than on
ﬁxed-window (40MHz bandwidth) implementation. The
primary reason for this is that in the ﬁxed-window im-
plementation each analyzed snippet corresponds to ex-
amining only one bit of the exponent, whereas in the
sliding-window implementation wmax = 6 bits of the
exponent are examined in a single U-S or Z-S snippet,
while the exponent-dependent variation in the snippet is
not much larger. Since sliding-window recovery tries to
extract several times more information from about the
same amount of signal change, its recovery is more af-
fected by noise and thus slightly less accurate.
5 Mitigation
We focus our mitigation efforts on the ﬁxed-window
implementation, which is the implementation of choice
in the current version of OpenSSL, and which already
mitigates the problem of exponent-dependent square-
multiply sequences and timing variation. We iden-
tify three key enablers for this attack approach, which
roughly correspond to discussion in Sections 3.1, 3.2,
and 3.3. Successful mitigation requires removing at least
one of these enablers, so we now discuss each of the at-
tack enablers along with potential mitigation approaches
focused on that enabler.
The ﬁrst enabler of the speciﬁc attack demonstrated
in this paper is the existence of computational-activity-
modulated EM signals around the processor’s clock fre-
quency, and the attacker’s ability to obtain these signals
with sufﬁcient bandwidth and signal-to-noise ratio. Po-
tential mitigation thus include circuit-level approaches
that reduce the effect the differences in computation have
the signal, additional shielding that attenuates these sig-
nals to reduce their signal-to-noise ratio outside the de-
vice, deliberate creation of RF noise and/or interference
that also reduces the signal-to-noise ratio, etc. We do not
focus on these mitigation because all of them increase the
device’s overall cost, weight, and/or power consumption,
all of them are difﬁcult to apply to devices that are al-
ready in use, and all of them may not provide protection
against attacks that use this attack approach but through
a different physical side channel (e.g. power).
The second enabler of our attack approach is the at-
tacker’s ability to precisely locate, in the overall signal
during an exponentiation operation, those brief snippets
of signal that correspond to examining the bits of the ex-
ponent and constructing the value of the window. A sim-
ple mitigation approach would thus insert random addi-
tional amounts of computation before, during, and/or af-
ter window computation. However, additional computa-
tion that has signiﬁcant variation in duration would also
have a signiﬁcant mean of that duration, i.e.
it would
slow down the window computation. Furthermore, it
is possible (and indeed likely) that our attack can be
adapted to identify and ignore the signal that corresponds
to this additional activity.
The ﬁnal (third) enabler of our attack approach is
the attacker’s ability to distinguish between the signals
whose computation has the same control ﬂow but uses
different values for a bit in the exponent. In this regard,
the attack beneﬁts signiﬁcantly from 1) the limited space
of possibilities for value returned by BN is bit set –
there are only two possibilities: 0 or 1, and from 2) the
fact that the computation that considers each such bit is