此规则的操作是`MASQUERADE`，它将根据主机路由表隐藏其中一个主机接口后面的流量。
采用同样的方法，您可以轻松验证与 Docker 相关的其他`iptables`流。诚然，随着容器数量的增加，这将成为一项更加艰巨的任务。但是，由于大多数规则是基于每个容器编写的，命中计数器对于每个容器都是唯一的，因此更容易缩小范围。
### 注
更多关于`iptables`表和链的处理顺序的信息，请看这个`iptables`网页和[http://www.iptables.info/en/structure-of-iptables.html](http://www.iptables.info/en/structure-of-iptables.html)的相关流程图。
# 验证名称解析
容器的 DNS 解析一直相当简单。容器接收到与主机相同的 DNS 配置。然而，随着用户定义的网络和嵌入式域名系统服务器的出现，这现在变得有点棘手。我见过的许多域名系统问题中的一个常见问题是不理解嵌入式域名系统服务器是如何工作的，以及如何验证它是否正常工作。在这个食谱中，我们将逐步通过一个容器 DNS 配置来验证它正在使用哪个 DNS 服务器来解析特定的名称空间。
## 做好准备
在本食谱中，我们将使用单个 Docker 主机。假设 Docker 已安装并处于默认配置。您还需要根级访问权限，以便检查和更改主机的网络和防火墙配置。
## 怎么做…
没有用户定义网络的 Docker 的标准 DNS 配置是简单地将 DNS 配置从主机复制到容器中。在这些情况下，域名解析非常简单:
```
user@docker1:~$ docker run -dP --name web1 jonlangemak/web_server_1
e5735b30ce675d40de8c62fffe28e338a14b03560ce29622f0bb46edf639375f
user@docker1:~$
user@docker1:~$ docker exec web1 more /etc/resolv.conf
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 
search lab.lab
user@docker1:~$
user@docker1:~$ more /etc/resolv.conf
nameserver 
search lab.lab
user@docker1:~$
```
在这种情况下，所有的域名系统请求将直接转到定义的域名系统服务器。这意味着我们的容器可以解析任何 DNS 记录，我们的主机可以:
```
user@docker1:~$ docker exec -it web1 ping docker2.lab.lab -c 2
PING docker2.lab.lab (10.10.10.102): 48 data bytes
56 bytes from 10.10.10.102: icmp_seq=0 ttl=63 time=0.471 ms
56 bytes from 10.10.10.102: icmp_seq=1 ttl=63 time=0.453 ms
--- docker2.lab.lab ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.453/0.462/0.471/0.000 ms
user@docker1:~$
```
再加上 Docker 会将这些流量伪装成主机本身的 IP 地址，使得这成为一个简单且易于维护的解决方案。
然而，当我们开始使用用户定义的网络时，这就变得有点棘手了。这是因为用户定义的网络提供了容器名称解析。也就是说，一个容器可以解析另一个容器的名称，而无需使用静态或手动主机文件条目和链接。这是一个很好的特性，但是如果您不理解容器是如何接收其 DNS 配置的，它会引起一些混乱。例如，现在让我们创建一个新的用户定义网络:
```
user@docker1:~$ docker network create -d bridge mybridge1
e8afb0e506298e558baf5408053c64c329b8e605d6ad12efbf10e81f538df7b9
user@docker1:~$
```
现在让我们在这个网络上开始一个名为`web2`的新容器:
```
user@docker1:~$ docker run -dP --name web2 --net \
mybridge1 jonlangemak/web_server_2
1b38ad04c3c1be7b0f1af28550bf402dcde1515899234e4b09e482da0a560a0a
user@docker1:~$
```
现在，如果我们将现有的`web1`容器连接到该桥，我们应该会发现`web1`可以通过名称解析容器`web2`:
```
user@docker1:~$ docker network connect mybridge1 web1
user@docker1:~$ docker exec -it web1 ping web2 -c 2
PING web2 (172.18.0.2): 48 data bytes
56 bytes from 172.18.0.2: icmp_seq=0 ttl=64 time=0.100 ms
56 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.086 ms
--- web2 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.086/0.093/0.100/0.000 ms
user@docker1:~$
```
这里的问题是，为了促进这一点，Docker 不得不更改`web1`容器的 DNS 配置。这样做时，它会将嵌入式域名系统服务器注入到容器域名系统请求的中间。以前，当我们直接与主机 DNS 服务器对话时，我们现在与嵌入式 DNS 服务器对话:
```
user@docker1:~$ docker exec -t  web1 more /etc/resolv.conf
search lab.lab
nameserver 127.0.0.11
options ndots:0
user@docker1:~$
```
这是容器的域名解析工作所需的，但它有一个有趣的副作用。嵌入式域名系统服务器读取主机的`/etc/resolv.conf`文件，并使用该文件中定义的任何名称服务器作为嵌入式域名系统服务器的转发器。这样做的净效果是，您不会注意到嵌入式域名系统服务器，因为它仍在转发无法应答主机域名系统服务器的请求。然而，它只对这些转发器进行编程，如果它们被定义的话。如果它们不存在或设置为`127.0.0.1`，那么 Docker 会将转发器编程为谷歌的公共域名系统服务器(`8.8.8.8`和`8.4.4.4`)。
虽然这很有道理，但很少有你的本地 DNS 服务器恰好是`127.0.0.1`的情况。例如，您碰巧在同一台主机上运行某种类型的本地 DNS 解析器，或者使用 DNS 转发器应用，如**DNS sq**。在这些情况下，Docker 会将容器的 DNS 请求转发到前面提到的外部 DNS 服务器，而不是本地定义的服务器，这可能会导致一些复杂情况。也就是说，内部域名系统区域将不再是可解析的:
```
user@docker1:~$ docker exec -it web1 ping docker2.lab.lab
ping: unknown host
user@docker1:~$
```
### 注
这也可能导致一般的解决问题，因为通常会阻止到外部 DNS 服务器的 DNS 流量，而宁愿强制内部端点使用内部 DNS 服务器。
在这些场景中，有几种方法可以解决这个问题。您可以通过在容器运行时传递 DNS 标志，使用特定的 DNS 服务器运行容器:
```
user@docker1:~$ docker run -dP --name web2 --net mybridge1 \
--dns  jonlangemak/web_server_2
```
否则，您可以将 DNS 服务器设置为 Docker 服务级别，然后嵌入式 DNS 服务器会将其用作转发器:
```
ExecStart=/usr/bin/dockerd --dns=
```
无论是哪种情况，如果您有容器解析问题，请总是检查并查看容器在其`/etc/resolv.conf`文件中配置了什么。如果是`127.0.0.11`，说明你使用的是 Docker 嵌入式 DNS 服务器。如果是，并且仍然有问题，请确保验证主机 DNS 配置，以确定嵌入式 DNS 服务器正在为转发器消耗什么。如果没有定义一个或者它是`127.0.0.1`，那么确保你告诉 Docker 服务它应该以前面定义的两种方式之一传递什么 DNS 服务器到容器。
# 构建测试容器
建造 Docker 容器的租户之一是保持容器的小而瘦。在某些情况下，这可能会限制您的故障排除选项，因为容器的映像中不会包含许多常见的 Linux 网络工具。虽然不理想，但有时安装这些工具的容器映像会很好，这样您就可以从容器的角度对网络进行故障排除。在本章中，我们将回顾如何专门为此目的构建 Docker 映像。
## 做好准备
在本食谱中，我们将使用单个 Docker 网络主机。假设 Docker 已安装并处于默认配置。您还需要根级访问，以便检查和更改主机网络和防火墙配置。
## 怎么做…
Docker 映像是通过定义 Docker 文件构建的。Dockerfile 定义了要使用的基本映像以及要在容器内部运行的命令。在我的示例中，我将如下定义 Dockerfile:
```
FROM ubuntu:16.04
MAINTAINER Jon Langemak PI:EMAIL
RUN apt-get update && apt-get install -y apache2 net-tools \
inetutils-ping curl dnsutils vim ethtool tcpdump
ADD index.html /var/www/html/index.html
ENV APACHE_RUN_USER www-data
ENV APACHE_RUN_GROUP www-data
ENV APACHE_LOG_DIR /var/log/apache2
ENV APACHE_PID_FILE /var/run/apache2/apache2.pid
ENV APACHE_LOCK_DIR /var/run/apache2
RUN mkdir -p /var/run/apache2
RUN chown www-data:www-data /var/run/apache2
EXPOSE 80
CMD ["/usr/sbin/apache2", "-D", "FOREGROUND"]
```
这个形象的目标是双重的。首先，我希望能够以分离模式运行容器，并让它提供服务。这将允许我定义容器，并验证诸如端口发布之类的事情是否在主机上运行。这个容器映像为我提供了一个已知良好的容器，它将在端口`80`上发布服务。为此，我们使用 Apache 来托管一个简单的索引页面。
索引文件在构建时被拉入映像中，并且可以由您自定义。我使用一个简单的 HTML 页面，`index.html`，它显示大红色字体，如下所示:
```