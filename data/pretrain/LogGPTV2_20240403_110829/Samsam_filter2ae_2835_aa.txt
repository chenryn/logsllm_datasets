# 对恶意勒索软件Samsam多个变种的深入分析
|
##### 译文声明
本文是翻译文章，文章来源：www.crowdstrike.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
##
## 一、概述
本文主要对恶意软件Samsam进行深入分析，该恶意软件是由BOSS SPIDER开发和运营，这一组织的活动被CrowdStrike® Falcon
Intelligence™持续追踪。该恶意软件不同变种的感染链和执行流都不尽相同，我们会在本文中进行详细分析。该恶意软件使用外部工具（例如批处理脚本、Mimikatz和包括PsExec、Sdelete在内的系统内部实用程序）来实现勒索软件的传播和清除工作。在某些情况下，勒索软件会将加密方式与运行程序文件一同投递，其中的运行程序文件用于加载和执行内存中的恶意软件。此外，该恶意软件还具有反取证功能，分析人员如果想要从被感染的系统中恢复勒索软件Payload是有一定难度的。尽管恶意软件采取了一些措施来逃避检测，但使用Falcon
Prevent可以在该恶意软件家族对系统中文件进行加密之前及时地检测到这一行为并进行阻止。
## 二、感染过程
这种勒索软件家族的投递方法发生过多次变化。早期的勒索软件变种会使用凭据自动收集程序（例如Mimikatz）从活动目录（Active
Directory）中收集凭据，为列表中的每个用户生成RSA公钥，并将Payload与以下文件一起部署：  
1、PSExec：系统内部实用工具中的一个合法工具，用于在远程系统上执行应用程序；  
2、备份删除帮助程序：该文件负责遍历所有连接到被感染主机的驱动器，在这里（
对其进行了详细分析；  
3、暴露的账户列表；  
4、包含每个账户的唯一RSA公钥的文件夹；  
5、四个批处理脚本，负责将文件复制到每台被感染主机，并加载Payload：  
(1) 第一个文件：将Samsam的Payload和相应的公钥复制到%WINDIR%system32中，并执行命令“vssadmin delete
shadows /all /quiet”；  
(2) 第二个文件：将备份删除帮助程序复制到C:Windows目录下；  
(3) 第三个文件：利用psexec远程执行删除帮助程序；  
(4) 第四个文件：利用psexec远程执行Payload，提供相应的公钥作为Payload的参数。  
如上所述，公钥和备份删除命令都没有保存在Payload之中。在Samsam恶意软件的其他变种中，密钥和备份删除命令都嵌入在Payload之中。后者的投递机制与前者有很大不同。后者的变种并没有使用大量文件来部署Payload，而是使用了运行程序和批处理脚本来进行相应的加密和部署，具体如下：  
1、运行程序：负责解密和加载Payload，在这里（
）对其进行了详细分析；  
2、批处理脚本：加载运行程序文件，并向其提供以下参数：  
(1) ：用于解密和加密Payload；  
(2) ：被解密的Payload用于投放附加文件；  
(3) ：被解密的Payload使用，动态生成启动画面；  
(4) ：被解密的Payload使用，动态生成启动画面。  
在一些Samsam变种中，也有独立的Payload，不需要任何参数或帮助程序。  
如前所述，Payload可以通过多种方式传递并加载到系统中。我们后面将更加详细地对Payload和一些帮助程序文件展开分析。
## 三、技术分析
###  备份删除帮助程序
该文件负责对被感染计算机上的文件系统进行遍历，并将其目标放在与数据备份相关扩展名的文件上（详见附录A）。该程序的目的是确保系统上的文件被加密后，无法使用备份来恢复文件。在这里需要注意，如果计算机连接了任何共享驱动器，该程序也将删除这些文件夹中的相应程序。  
在被批处理脚本加载之后，该文件将递归遍历全部驱动器中的每个目录。如果目录名称包含字符串“backup”，程序就将会进一步遍历该目录中的所有文件，并执行以下操作：  
1、将文件属性设置为FILE_ATTRIBUTE_NORMAL，这样就能确保文件可以被删除，而不会引发异常；  
2、在设置文件属性后，逐一删除文件；  
3、在所有文件都被删除后，删除目录本身。  
对于所有其他目录，一旦找到目标文件，程序就会通过执行以下操作，来确保它可以删除该文件：  
1、检查文件是否被锁定，确保没有句柄到进程访问的文件，这样文件可以在READ模式下打开。如果检查通过，就将该文件删除。  
2、如果上述检查失败，程序将结束与该文件关联的进程。  
(1) 通过以下命令，调用tasklist.exe，在系统上生成正在运行进程的列表：tasklist /v /fo csv  
(2) 查找列表，寻找与该文件名相同的进程。如果找到，将使用以下命令调用taskkill.exe来终止进程：taskkill /f /pid
一旦该进程被终止，相应的文件就会被删除。  
以下是tasklist命令输出的部分结果：  
### 运行程序
运行程序负责解密并加载内存中的Payload。该文件需要密码作为参数，用于解密过程。一旦由批处理脚本加载后，运行程序将在当前工作目录内查找扩展名为“.stubbin”的文件。该文件是实际加密后的Payload，一旦找到后，运行程序将读取内存中的内容，并立即从磁盘上删除加密的.stubbin文件。事实上，Payload会被解密，并完全加载到内存中，这样就导致难以恢复解密的勒索软件Payload。  
一旦内容被读取，运行程序会使用Rijndael算法对其进行解密。该算法需要首先输入密码和盐（Salt），从而生成解密密钥和初始化向量（IV）。其中，盐的值为“Ivan
Medvedev”，该值在使用此算法的多个二进制文件（包括合法文件和恶意文件）中都有出现过。有了这两个输入，运行程序会生成一个32字节的密钥和16字节的初始化向量（IV），然后使用它来对Payload进行解密。需要注意的是，从批处理文件传递的任何附加参数都将传递给解密的Payload。运行程序随后负责调用Payload的入口点，从而在内存中执行。
我们分析了多个变种中的Payload，其中的一个主要区别是RSA公钥是否嵌入在Payload之中。如前所述，负责加载Payload的批处理脚本会将公钥以参数的方式传递给它，然后将其读取到变量之中，以备后续在执行过程中使用。本节将详细解释勒索软件是如何加密被感染主机上的文件的。
### 提取资源
在加载后，Samsam首先解析其自身的资源部分，并提取资源名称。针对每个名称，它会确保扩展名为“.exe”，并检查当前目录中是否有与资源名称相同的文件。如果存在，它将从磁盘中删除该文件，并以4096字节的块为单位，读取资源部分的内容并将其写入到当前目录之中。截至目前，在完成提取过程后，我们最多可以看到两个不同的文件：selfdel.exe和del.exe。在这里需要注意，在击杀链的早期阶段，我们可以将当前目录下具有静态名称的这两个文件作为检测目标，检测其投放的特定活动。  
在文件被写入磁盘后，Payload会启动一个新的线程来执行selfdel.exe，我们稍后在“自我删除”这一节中会进行更详细地分析。接下来，Payload将递归遍历所有连接到被感染主机的驱动器中的所有目录。
### 文件系统遍历
Payload在进行遍历搜索文件时，会跳过如下目录：
    C:Windows
    Reference AssembliesMicrosoft
    Recycle.bin
其原因是为了确保执行流的顺畅。由于C:Windows目录下都是系统文件，.NET框架所需的文件都在Reference
AssembliesMicrosoft目录下，因此就无需再对这些文件夹进行搜索。而至于回收站Recycle.bin，我们推测可能是因为绝大多数勒索软件首先都会对该目录进行遍历搜索，因此一些安全防护产品会通过检测对该目录的遍历来发现恶意软件行为，所以在该恶意软件中就跳过了这一目录。通过跳过Recycle.bin，Samsam可以避开这种检测方法，并继续对文件进行加密。  
附录A中列出了Samsam的目标文件扩展名列表。当恶意软件找到列表中扩展名的文件时，会判断文件大小。如果文件不大于100MB（104857600字节），那么Payload会立即调用加密子例程。如果文件大于100MB，会进行如下判断和操作：  
1、如果文件>100MB且250MB且500MB且1GB，它会将文件的完整路径附加到列表mylistbig中。  
所有不大于100MB的目标文件会首先被加密，随后Payload再对这些列表中的文件进行加密。这一设计可能是为了防止勒索软件进程被提早终止，希望能够尽可能多地加密文件。在加密完所有不大于100MB的文件后，恶意软件也会按照列表的先后顺序，先加密mylist250中的文件，然后是mylist500，之后是mylist1000，最后是mylistbig。一旦上述所有文件都成功被加密，Payload将会清除内存中的这些列表。  
在Samsam的其他一些变种中，不存在这种按照文件大小分批加密的行为。这些变种只使用一个列表，来记录连接到被感染主机的所有驱动器中的所有目标文件。随后，会调用文件加密子例程，对其进行加密。
### 文件加密过程
对于每个文件，Payload会执行以下检查：  
1、当前文件的大小是否小于驱动器的可用空间，如果小于，Payload将会跳过此文件，开始处理下一个文件；  
2、当前文件的大小是否大于0；  
3、公钥变量是否为空，如果没有公钥，那么就无法进行加密。  
如果上述的任何一个检查不符合条件，Payload都会跳到处理下一个文件。  
接下来，我们发现有两类不同的变种，它们的加密方式也有所不同。
### 变种A
对于每个文件，子例程首先检查当前目录中是否存在名为.的文件，加密后文件的扩展名始终是“.encryptedRSA”。如果存在，则执行以下步骤：  
(1)
检查.encryptedRSA文件的大小。如果该文件大小大于目标文件，则子例程将会删除目标文件，并开始处理下一个文件。在这里，如果满足条件，就假设该文件已经被Samsam加密，因此就删除了原始目标文件。  
(2)
如果.encryptedRSA文件大小小于或等于目标文件，子例程将删除.encryptedRSA文件。由于实际加密会导致生成的文件大小大于原始文件，因此.encryptedRSA文件大小必然会大于目标文件。在这里，如果满足条件，就假设该.encryptedRSA文件不是实际加密的文件，并对其进行删除。在删除之后，目标文件会立即被加密。
### 变种B
如果子例程找到名为.encryptedRSA的文件，则立即跳过该目标文件。它不会对加密后文件的大小进行检查，也没有尝试删除任何目标文件。请注意，子例程会跳到下一个文件，从而让当前文件保持不变，这一点非常重要。也就意味着，如果系统中每个文件，都相应创建了扩展名为“.encryptedRSA”的任意大小文件，那么恶意软件就不会对其进行加密，而是直接跳过。我们在分析过程中进行了实际测试，并确认了这一结论的正确性。
### 文件加密方式