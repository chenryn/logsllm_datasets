chitectures. Our analysis in this section extends the re-
sults we presented in a short paper at a recent work-
shop [39]. On Intel, we found that Intel’s Page-Structure
Caches or split translation caches are implemented by
Intel Core and Xeon processors since at least the Ne-
halem microarchitecture. On Intel Core and Xeon pro-
USENIX Association
27th USENIX Security Symposium    945
knowledgements for each word sent, the sender monitors
a different set of cache lines. For our implementation,
we built a bidirectional channel that is able to transfer
19-bit words at a time. To synchronize both the sender
and the receiver, we dedicated 6 bits of the 19-bit word
to sequence numbers. Furthermore, we use 4-bit Berger
codes to detect simple errors and to prevent zero from
being a legal value in our protocol, as it could be intro-
duced by tasks being interrupted by the scheduler. We
used our framework to compare the raw bandwidth, the
(correct) bandwidth, and the bit error rate between hard-
ware threads on the same CPU core and between differ-
ent CPU cores. Figure 4 presents our results.
Our results show that FLUSH + RELOAD was able to
achieve a bandwidth of around 40 KiB/s with the least
noise. PRIME + PROBE performs slightly worse, with
a bandwidth of about 8 KiB/s. While FLUSH + FLUSH
performs quite well on the cross-core setup with a band-
width of about 4 KiB/s, it performs much worse on
the cross-thread setup with a bandwidth of a mere 500
bytes/s. This is due to the timing difference of ﬂushing a
cache line depending on the cache slice hosting it. Com-
pared to the other covert channels, XLATE + PROBE only
reaches a bandwidth of 900 bytes/s. While this is slower
than other covert channels, the low error rate indicates
this is only due to the higher latency of indirect MMU-
mediated memory accesses, rather than noisier condi-
tions. This experiment demonstrates XLATE provides a
reliable channel and can hence be used to mount side-
channel attacks in practical settings as we show next.
7.3 Effectiveness
To evaluate the effectiveness of XLATE, we mounted
a side-channel attack against a real-world security-
sensitive application. To compare our results against
state-of-the-art cache attacks, we focus our attack on
the OpenSSL’s T-table implementation of AES, using
OpenSSL 1.0.1e as a reference. This attack scenario has
been extensively used to compare the performance of
cache side-channel attacks in prior work (e.g., recently
in [8]).
The implementation of AES in our version of
OpenSSL uses T-tables to compute the cipher text based
on the secret key k and plain text p. During the ﬁrst
round of the algorithm, table accesses are made to en-
tries Tj [pi ⊕ ki] with i ≡ j mod 4 and 0 ≤ i < 16. As
these T-tables typically map to 16 different cache lines,
we can use a cache attack to determine which cache line
has been accessed during this round. Note that in case
pi is known, this information allows an attacker to derive
pi ⊕ ki, and thus, possible key-byte values for ki.
More speciﬁcally, by choosing pi and using new ran-
dom plain text bytes for p j, where i (cid:54)= j, while triggering
Figure 4: Reliability comparison of different cache side-
channel attacks using a reference covert channel implementa-
tion on both cross-thread and cross-core setups.
cessors, we also found translation caches available for
32 Page Directory Entries (PDEs) and 4 Page Directory
Pointer Table Entries (PDPTEs). In contrast, Intel Sil-
vermont has only a single translation cache for 16 PDEs.
On AMD, we found that AMD K10 employs a 24-entry
dedicated and uniﬁed page table cache and AMD Bobcat
employs an 8 to 12 entries variant, respectively. Since
AMD Bulldozer, the L2 TLB has been re-purposed to
also host page table entries, allowing it to store up to
1024 PDEs on AMD Bulldozer and Piledriver and up to
1536 PDEs on AMD Zen. We also found that AMD Zen
introduces another L2 TLB with 64 entries dedicated to
1G pages, allowing it to store up to 64 PDPTEs. On
ARM, we found that the low-power variants implement
uniﬁed page table caches with 64 entries.
In contrast,
we found that performance-oriented variants implement
a translation cache with 16 PDEs on ARMv7-A and one
with 6 PDPTEs on ARMv8-A. Overall, our results show
that translation caches take very different and complex
forms across contemporary microarchitectures. As such,
our reverse engineering efforts are both crucial and ef-
fective for devising practical MMU-based attacks and
defenses.
7.2 Reliability
To evaluate the reliability of XLATE and compare against
that of state-of-the-art cache attacks, we implemented an
LLC-based covert channel framework, where the sender
and the receiver assume the roles of the victim and the
attacker respectively. The receiver mounts one of the
cache attacks to monitor speciﬁc cache lines, while the
sender accesses the cache line to transmit a one and does
nothing to send a zero otherwise. In order to receive ac-
946    27th USENIX Security Symposium
USENIX Association
FLUSH+RELOADFLUSH+FLUSHPRIME+PROBEXLATE+PROBE102103104105Bandwidth(bytes/sec)FLUSH+RELOADFLUSH+FLUSHPRIME+PROBEXLATE+PROBE101102103104Biterrors(bits/sec)Cross-Thread(correct)Cross-Thread(raw)Cross-Core(correct)Cross-Core(raw)Table 3: Our reverse engineering results for the translation caches of 26 different microarchitectures.
CPU
Intel Core i7-7500U (Kaby Lake) @ 2.70GHz
Intel Core m3-6Y30 (Skylake) @ 0.90GHz
Intel Xeon E3-1240 v5 (Skylake) @ 3.50GHz
Intel Core i7-6700K (Skylake) @ 4.00GHz
Intel Celeron N2840 (Silvermont) @ 2.16GHz
Intel Core i7-4500U (Haswell) @ 1.80GHz
Intel Core i7-3632QM (Ivy Bridge) @ 2.20GHz
Intel Core i7-2620QM (Sandy Bridge) @ 2.00GHz
Intel Core i5 M480 (Westmere) @ 2.67GHz
Intel Core i7 920 (Nehalem) @ 2.67GHz
AMD Ryzen 7 1700 8-Core (Zen) @ 3.3GHz
AMD Ryzen 5 1600X 6-Core (Zen) @ 3.6GHz
AMD FX-8350 8-Core (Piledriver) @ 4.0GHz
AMD FX-8320 8-Core (Piledriver) @ 3.5GHz
AMD FX-8120 8-Core (Bulldozer) @ 3.4GHz
AMD Athlon II 640 X4 (K10) @ 3.0GHz
AMD E-350 (Bobcat) @ 1.6GHz
AMD Phenom 9550 4-Core (K10) @ 2.2GHz
Rockchip RK3399 (ARM Cortex A72) @ 2.0GHz
Rockchip RK3399 (ARM Cortex A53) @ 1.4GHz
Allwinner A64 (ARM Cortex A53) @ 1.2GHz
Samsung Exynos 5800 (ARM Cortex A15) @ 2.1GHz
Nvidia Tegra K1 CD580M-A1 (ARM Cortex A15) @ 2.3GHz
Nvidia Tegra K1 CD570M-A1 (ARM Cortex A15; LPAE) @ 2.1GHz
Samsung Exynos 5800 (ARM Cortex A7) @ 1.3GHz
Samsung Exynos 5250 (ARM Cortex A15) @ 1.7GHz
1 4K and 2M pages are shared by the L2 TLB.
r
a
e
Y
2016
2015
2015
2015
2014
2013
2012
2011
2010
2008
2017
2017
2012
2012
2011
2010
2010
2008
2017
2017
2016
2014
2014
2014
2014
2012
d
1
L
32K
32K
32K
32K
24K
32K
32K
32K
32K
32K
32K
32K
64K
64K
16K
64K
32K
64K
32K
32K
32K
32K
32K
32K
32K
32K
Caches
2
L
256K
256K
256K
256K
1M
256K
256K
256K
256K
256K
512K
512K
2M
2M
2M
512K
512K
512K
1M
512K
512K
2M
2M
2M
512K
1M
3
L
4M
4M
8M
8M
N/A
4M
6M
6M
3M
8M
16M
16M
8M
8M
8M
N/A
N/A
2M
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
TLBs
s
e
g
a
p
M
2
32
32
32
32
16
32
32
32
32
32
1600 1
1600 1
1088 2
1088 2
1056 2
176
8-12
176
512 1
512 1
512 1
512 1,3
512 1,3
512 1,3
256 1,3
512 1,3
s
e
g
a
p
K
4
1600
1600
1600
1600
128
1088
576
576
576
576
1600
1600
1088
1088
1056
560
552
560
544
522
522
544
544
544
266
544
0
0
0
0
0
0
0
0
0
0
0
16
0
0
0
0
0
0