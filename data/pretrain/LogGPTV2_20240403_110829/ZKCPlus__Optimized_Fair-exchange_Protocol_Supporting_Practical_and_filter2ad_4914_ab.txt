knowledge argument Arg can be transformed into a non-interactive
zero-knowledge (NIZK) argument of knowledge, where Vâ€™s mes-
sages are replaced by outputs of a cryptographic hash function
over the transcript up to the point. We model the resulting NIZK
argument as a tuple of algorithms Î  = (KeyGen, Prove, Verify) s.t.
â€¢ KeyGen(1ğœ†) â†’ ğœ generates the CRS ğœ on input parameter ğœ†;
â€¢ Prove(ğœ, s, w) â†’ ğœ‹ outputs proof ğœ‹ for R(s, w) = 1;
â€¢ Verify(ğœ, s, ğœ‹) â†’ b accepts (b = 1) or rejects (b = 0) the proof ğœ‹.
In random oracle model, the resulting Î  has perfect completeness,
computational knowledge soundness and zero-knowledge (formal defi-
nitions in Appendix A.4), provided that the original interactive argu-
ment Arg has perfect completeness, computational witness-extended
emulation, and special honest-verifier zero-knowledge [4].
In Appendix B, we describe an argument for inner products for
vectors from [31], a basic building block that we use repeatedly on
various occasions throughout this work.
2.4 Commit-and-prove arguments
We adopt the notion of commit-and-prove non-interactive argu-
ments from LegoSNARK [12]. For a relation R and a commitment
scheme Com with message space Mpp, a commit-and-prove NIZK
(CP-NIZK) argument of knowledge proves the knowledge of a wit-
ness w for a statement s s.t. R(s, w) = 1, where w = (u, aux) splits into
a message part u âˆˆ Mpp which opens a specified commitment c, and
an auxiliary part aux. More specifically, it demonstrates a relation
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3004Figure 1: Block cipher in CTR mode
RCom defined over pairs (s, w) where s = (s, c) and w = (u, r, aux),
s.t. RCom(s, w) = 1 iff
Com.Check(pp, c, u, r) = 1 âˆ§ R(s, (u, aux)) = 1.
(1)
s = (s, c) and witness w = (u, r, aux);
eters of the commitment scheme pp â† Com.Setup(1ğœ†);
We model the CP-NIZK argument of knowledge as a tuple of algo-
rithms Î Com = (KeyGen, Prove, Verify) where
â€¢ KeyGen(1ğœ†) â†’ ğœ generates ğœ, which includes the public param-
â€¢ Prove(ğœ, (s, c), (u, r, aux)) â†’ ğœ‹ outputs proof ğœ‹ for statement
â€¢ Verify(ğœ, (s, c), ğœ‹) â†’ b accepts (b = 1) or rejects (b = 0).
It should satisfy the notion of completeness, knowledge soundness,
and zero-knowledge as a usual NIZK argument of knowledge. In
practice, u may split into many segments. Informally, we write
u = {ui}, and they are committed as c = {ci} with blinders r = {ri}.
Correspondingly, RCom holds iff
Com.Check(pp, ci, ui, ri) = 1 âˆ§ R(s, ({ui}, aux)) = 1.
(2)

i
The notion of commit-and-prove allows a â€œbottom-upâ€ approach
to build arguments for composed relations. The base case is the
conjunction of relations with shared inputs. For two CP-NIZK argu-
ments of knowledge Î Com
1 which respectively attesting
relations R0(s0, (u, aux0)) = 1 and R1(s1, (u, aux1)) = 1, with shared
input u. It is proved that for a computationally binding commitment
scheme Com, there exists a CP-NIZK argument of knowledge Î Comâˆ§
for conjunction of R0 and R1. More specifically, Î Comâˆ§ works for
relation Râˆ§ s.t Râˆ§((s0, s1), (u, aux0, aux1)) = 1 iff
and Î Com
0
R0(s0, (u, aux0)) = 1 âˆ§ R1(s1, (u, aux1)) = 1.
(3)
Extension to conjunctions of more than two relations is trivial. Dis-
junctions and sequential composition of functions can be reduced
to this base case as well. Refer to Appendix C for more details.
and Î Com
link . Let Î Com
Herein we single out a special type of CP-NIZK argument de-
be CP-NIZK arguments of
noted as Î Com
1
knowledge for relation R0 and R1 s.t. R0(s0, (u0, aux0)) = 1, and
R1(s1, (u1, aux1)) = 1. Argument Î Com
link shares input u0 with Î Com
,
input u1 with Î Com
, and proves that u0 and u1 are related by an in-
terlinking function f s.t. f (u0, u1) = 0. By composability of CP-NIZK
arguments, Î Com
R0(s0, (u0, aux0)) = 1 âˆ§ R1(s1, (u1, aux1)) = 1 âˆ§ f (u0, u1) = 0. (4)
link jointly prove the relation
and Î Com
, Î Com
0
0
1
0
1
0
1
and Î Com
link acts as an adaptor between Î Com
Therefore, Î Com
. With
link , it is possible to assemble small CP-NIZK arguments together,
Î Com
and build an argument that works for very complicated relations.
2.5 Rank-1 constraint system
Rank-1 Constraint System (R1CS) extends the notion of Quadratic
Arithmetic Program (QAP) [27], and offers a convenient description
for arithmetic circuits. For a circuit of size m (containing m multi-
plication gates), its corresponding R1CS is written as {A, B, C, s; w},
where A, B, C âˆˆ FmÃ—l
are the coefficient matrices, s represents the
p
public input, and w the witness for the circuit. An assignment
x = (1, s, w) âˆˆ Fl
p satisfies the circuit iff
Ax â—¦ Bx = Cx.
(5)
For simplicity, in the following we shall assume m = l.
2.6 MiMC block cipher
MiMC [1] is a family of symmetric cryptographic primitives that
works natively in finite fields. In particular, MiMC-p/p is a block
cipher Ck(Â·) operating over a prime field Fp, constructed by embed-
ding a non-linear permutation F(x) = xd for x âˆˆ Fp in its round func-
tion, where the exponent d satisfies the condition gcd(d, p â€“ 1) = 1.
For each round, the round function is defined as Fi(x) = F(x + k + ci),
where k denotes the encryption key, and ci a round constant. The
number of rounds should be sufficiently large to thwart the interpo-
lation attacks [36]. The block cipher is arithmetic circuit friendly;
for example, it promises 129-bit security with only 82 multiplica-
tions in Fp.
We use the MiMC-p/p block cipher in the counter (CTR) mode.
An arbitrary input message x is encoded as a vector over Fp of
length n. With key k, x âˆˆ Fn
p is encrypted into ciphertext z âˆˆ Fn
p,
whose i-th element is computed by
zi = xi + Ck(ctri),
(6)
where counter ctri is offset by a random nonce, ctri = nonce+ i, and
the operation + is defined in Fp. Collectively, we write z = Enck(x).
2.7 Blockchain and smart contract
Bitcoin [44] is a decentralized ledger system jointly maintained
by indefinite number of nodes via a peer-to-peer consensus pro-
tocol. If a majority of the nodes honour the protocol, the ledger
is ensured correctness without any centralized coordination. On
Bitcoin blockchain, usersâ€™ currencies and transactions are managed
by simple Bitcoin scripts with limited functionalities.
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3005Going one step further, Ethereum [54] extends the ledger to
a â€œworld stateâ€ consisting of rich variables, which can be modi-
fied by code called â€œsmart contractsâ€. A smart contract consists of
global variables and functions, and the functions can be invoked by
Ethereum users or other contracts reactively. The miners execute
the invoked functions to update the global state of the ledger. In con-
trast with the limited Bitcoin scripts, smart contracts on Ethereum
support Turing complete language. In particular, it allows elliptic
curve operations, so on-chain Pedersen commitment opening is
made easy.
3 Building block: CP-NIZK argument for data-parallel
computations
In this section, we focus on the construction of an efficient CP-NIZK
argument for data-parallel circuits. We say an arithmetic circuit is
data-parallel if it consists of multiple copies of identical sub-circuits
running on separated inputs. This argument is a core building block
for our ZKCPlus protocol.
3.1 Argument construction
Consider a data-parallel circuit consisting of n identical sub-circuits,
and each sub-circuit is of size m. Instead of constructing a large
R1CS for the whole circuit of size n Ã— m, we use R1CS for the sub-
circuit of size m and apply it to n assignments. Specifically, we
define matrix
X = [x1, . . . , xn] âˆˆ FmÃ—n
(9)
where xk is the assignment to the k-th sub-circuit. The satisfiability
relation for the whole circuit can be stated concisely as
p
,
AX â—¦ BX = CX.
(10)
Instead of interpreting X as a collection of n columns of xk âˆˆ Fm
p ,
each of length m, henceforth we view it as a stack of m row vectors
each of length n. We denote the row vectors as vj âˆˆ Fn
p for j âˆˆ [m].
They are divided into two categories, those corresponding to public
inputs (statement) with j âˆˆ pub, and those for Pâ€™s private inputs
(witness) with j âˆˆ priv, where pub âˆª priv = [m]. We reformulate
the satisfiability relation of (10) as m identities about Hadamard
products, namely
,
p
(A, B, C) âˆˆ FmÃ—m
{vj âˆˆ Fn
p}jâˆˆpub;
{vj âˆˆ Fn
p}jâˆˆpriv
ai =
bi =
ci =

jâˆˆ[m] Aij Â· vj,
jâˆˆ[m] Bij Â· vj,
jâˆˆ[m] Cij Â· vj,
iâˆˆ[m] ai â—¦ bi = ci
 ,
(11)
where Mij denotes an element of matrix M with row and column
indices i and j for M âˆˆ {A, B, C}. We build an interactive protocol for
this relation using techniques in [11, 31]. The details are in Figure 2.
The protocol relies on the Pedersen commitment scheme Com
as described in Section 2.2. In a nutshell, it involves a prover P com-
mitting vj as Vj. With Vj the verifier V can compute commitments
to ai, bi, ci utilizing the homomorphic property of Com as
Cij Â· Vj.
Bij Â· Vj, Ci = 
Ai = 
Bi = 
Aij Â· Vj,
(12)
jâˆˆ[m]
jâˆˆ[m]
jâˆˆ[m]
Then P contrives to convince V that for i âˆˆ [m] the vectors ai, bi, ci
satisfy the equations ai â—¦ bi = ci. It is in turn converted into an
equation for inner product âŸ¨ai, bi â—¦ ynâŸ© â€“ âŸ¨ci, ynâŸ© = 0, where yn =
Public input: R1CS instance A, B, C âˆˆ FmÃ—m
Pâ€™s private input: {vj âˆˆ Fn
p
.
p}iâˆˆ[m].
(Vj, ğœˆj) â† Commit(pp, vj).
P : for i âˆˆ [m]
P â†’ V : {Vj}jâˆˆ[m].
$â† Fp.
V â†’ P : w, y
P : for i âˆˆ [m]
li = wi Â·(cid:0)
ri =(cid:0)
ğœ„i = wi Â·(cid:0)
ğœŒi =(cid:0)
j
j
j
Bij Â· vj
Aij Â· vj
(cid:1),
(cid:1) â—¦ yn,
(cid:1),
(cid:1),
Aij Â· ğœˆj
li+m = wi Â·(cid:0)
ğœ„i+m = wi Â·(cid:0)
ri+m = â€“yn,
j
ğœŒi+m = 0.
(cid:1),
(cid:1),
Cij Â· vj
Cij Â· ğœˆj
j
p}iâˆˆ[2m], {ğœ„i, ğœŒi âˆˆ Fp}iâˆˆ[2m], ğœ = 0.
Bij Â· ğœˆj
Pâ€™s private input: {li, ri âˆˆ Fn
j
d
i=1
Repeat for k in [log m . . . 0]:
t+
k =
âŸ¨li, ri+dâŸ©,
P : d = 2k,
k ) â† Commit(pp, t+
(T +
k , ğœ+
k ),
P âˆ’â†’ V : T +
k , T â€“
k .
$â† Fp.
V âˆ’â†’ P : uk
P : for i âˆˆ [d]
d
tâ€“
k =
i=1
(T â€“
k , ğœâ€“
âŸ¨li+d, riâŸ©,
k ) â† Commit(pp, tâ€“
k ).
(7)
(8)
k
li â† uk Â· li + uâ€“1
ğœ„i â† uk Â· ğœ„i + uâ€“1
ğœ â† ğœ + u2
k Â· ğœ+
Â· li+d,
Â· ğœ„i+d,
k
k + uâ€“2
k
ri â† uâ€“1
ri â† uâ€“1
Â· ğœâ€“
k .
k
k
Â· li + uk Â· ri+d,
Â· ğœŒi + uk Â· ğœŒi+d,
l = 
ğœ„ = 
Reduced : z = (u0u1 Â· Â· Â· uk, u0u1 Â· Â· Â· uâ€“1
k , . . . , uâ€“1
zâ€“1
i
zâ€“1
i
Â· ğœâ€“
k .
zi Â· li,
zi Â· ğœ„i,
k Â· ğœ+
u2
iâˆˆ[2m]
k + uâ€“2
k
Â· ri,