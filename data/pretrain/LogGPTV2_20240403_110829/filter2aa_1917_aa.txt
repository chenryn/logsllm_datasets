{
Breaking the x86 ISA
domas / @xoreaxeaxeax / DEF CON 2017
 Christopher Domas
 Cyber Security Researcher @
Battelle Memorial Institute
./bio
 We don’t trust software.
 We audit it
 We reverse it
 We break it
 We sandbox it
Trust.
 But the processor itself?
 We blindly trust
Trust.
 Why?
 Hardware has
all the same problems as software
 Secret functionality?
 Appendix H.
 Bugs?
 F00F, FDIV, TSX, Hyperthreading, Ryzen
 Vulnerabilities?
 SYSRET, cache poisoning, sinkhole
Trust.
 We should stop
blindly trusting our hardware.
Trust.
 What do we need to worry about?
 Historical examples
 ICEBP (f1)
 LOADALL (0f07)
 apicall (0ffff0)
Hidden instructions
So… 
what’s 
this??
 Find out what’s really there
Goal: Audit the Processor
 How to find hidden instructions?
The challenge
 Instructions can be one byte …
 inc eax
 40
 … or 15 bytes ...
 lock add qword cs:[eax + 4 * eax + 07e06df23h], 0efcdab89h
 2e 67 f0 48 818480 23df067e 89abcdef
 Somewhere on the order of
1,329,227,995,784,915,872,903,807,060,280,344,576
possible instructions
The challenge
https://code.google.com/archive/p/corkami/wikis/x86oddities.wiki
 The obvious approaches don’t work:
 Try them all?
 Only works for RISC
 Try random instructions?
 Exceptionally poor coverage
 Guided based on documentation?
 Documentation can’t be trusted (that’s the point)
 Poor coverage of gaps in the search space
The challenge
 Goal:
 Quickly skip over bytes that don’t matter
The challenge
 Observation:
 The meaningful bytes of 
an x86 instruction impact either
its length or its exception behavior
The challenge
 A depth-first-search algorithm
Tunneling
Guess an instruction:
Tunneling
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Execute the instruction:
Tunneling
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   
Observe its length:
Tunneling
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   
Increment the last byte:
Tunneling
00 01 00 00 00 00 00 00 00 00 00 00 00 00 00   
Execute the instruction:
Tunneling
00 01 00 00 00 00 00 00 00 00 00 00 00 00 00   
Observe its length:
Tunneling
00 01 00 00 00 00 00 00 00 00 00 00 00 00 00  
Increment the last byte:
Tunneling
00 02 00 00 00 00 00 00 00 00 00 00 00 00 00
Execute the instruction:
Tunneling
00 02 00 00 00 00 00 00 00 00 00 00 00 00 00   
Observe its length:
Tunneling
00 02 00 00 00 00 00 00 00 00 00 00 00 00 00  
Increment the last byte:
Tunneling
00 03 00 00 00 00 00 00 00 00 00 00 00 00 00   
Execute the instruction:
Tunneling
00 03 00 00 00 00 00 00 00 00 00 00 00 00 00   
Observe its length:
Tunneling
00 03 00 00 00 00 00 00 00 00 00 00 00 00 00  
Increment the last byte:
Tunneling
00 04 00 00 00 00 00 00 00 00 00 00 00 00 00   
Execute the instruction:
Tunneling
00 04 00 00 00 00 00 00 00 00 00 00 00 00 00   
Observe its length:
Tunneling
00 04 00 00 00 00 00 00 00 00 00 00 00 00 00  
Increment the last byte:
Tunneling
00 04 01 00 00 00 00 00 00 00 00 00 00 00 00   
Execute the instruction:
Tunneling
00 04 01 00 00 00 00 00 00 00 00 00 00 00 00   
Observe its length:
Tunneling
00 04 01 00 00 00 00 00 00 00 00 00 00 00 00  
Increment the last byte:
Tunneling
00 04 02 00 00 00 00 00 00 00 00 00 00 00 00   
000000000000000000000000000000
000100000000000000000000000000
000200000000000000000000000000
000300000000000000000000000000
000400000000000000000000000000
000401000000000000000000000000
000402000000000000000000000000
000403000000000000000000000000
000404000000000000000000000000
000405000000000000000000000000
000405000000010000000000000000
000405000000020000000000000000
000405000000030000000000000000
000405000000040000000000000000
When the last byte is FF…
Tunneling
C7 04 05 00 00 00 00 00 00 00 FF 00 00 00 00 
… roll over …
Tunneling
C7 04 05 00 00 00 00 00 00 00 00 00 00 00 00 
... and move to the previous byte
Tunneling
C7 04 05 00 00 00 00 00 00 00 00 00 00 00 00 
This byte becomes the marker
Tunneling
C7 04 05 00 00 00 00 00 00 00 00 00 00 00 00 
Increment the marker
Tunneling
C7 04 05 00 00 00 00 00 00 01 00 00 00 00 00 
Execute the instruction
Tunneling
C7 04 05 00 00 00 00 00 00 01 00 00 00 00 00 
Observe its length
Tunneling
C7 04 05 00 00 00 00 00 00 01 00 00 00 00 00 
If the length has not changed…
Tunneling
C7 04 05 00 00 00 00 00 00 01 00 00 00 00 00 
Increment the marker
Tunneling
C7 04 05 00 00 00 00 00 00 02 00 00 00 00 00 
And repeat.
Tunneling
C7 04 05 00 00 00 00 00 00 02 00 00 00 00 00 
Continue the process…
Tunneling
C7 04 05 00 00 00 00 00 00 FF 00 00 00 00 00 
… moving back on each rollover
Tunneling
C7 04 05 00 00 00 00 00 00 00 00 00 00 00 00 
… moving back on each rollover
Tunneling
C7 04 05 00 00 00 00 00 FF 00 00 00 00 00 00 
… moving back on each rollover
Tunneling
C7 04 05 00 00 00 00 00 00 00 00 00 00 00 00 
…
Tunneling
C7 04 05 00 00 00 00 FF 00 00 00 00 00 00 00 
…
Tunneling
C7 04 05 00 00 00 00 00 00 00 00 00 00 00 00 
…
Tunneling
C7 04 05 00 00 00 FF 00 00 00 00 00 00 00 00 
…
Tunneling
C7 04 05 00 00 00 00 00 00 00 00 00 00 00 00 
…
Tunneling
C7 04 05 00 00 FF 00 00 00 00 00 00 00 00 00 
…
Tunneling
C7 04 05 00 00 00 00 00 00 00 00 00 00 00 00 
…
Tunneling
C7 04 05 00 FF 00 00 00 00 00 00 00 00 00 00 
…
Tunneling
C7 04 05 00 00 00 00 00 00 00 00 00 00 00 00 
…
Tunneling
C7 04 05 FF 00 00 00 00 00 00 00 00 00 00 00 
…
Tunneling
C7 04 05 00 00 00 00 00 00 00 00 00 00 00 00 
When you increment a marker…
Tunneling
C7 04 06 00 00 00 00 00 00 00 00 00 00 00 00 
… execute the instruction …
Tunneling
C7 04 06 00 00 00 00 00 00 00 00 00 00 00 00 
… and the length changes …
Tunneling
C7 04 06 00 00 00 00 00 00 00 00 00 00 00 00 
… move the marker to 
the end of the new instruction …
Tunneling
C7 04 06 00 00 00 00 00 00 00 00 00 00 00 00 
Tunneling
C7 04 06 00 00 00 01 00 00 00 00 00 00 00 00 
… and resume the process.
 Tunneling through the instruction space 
lets us quickly skip over the bytes
that don’t matter, 
and exhaustively search the bytes that do…
Tunneling
 … reducing the  search space 
from 1.3x1036 instructions 
to ~100,000,000
(one day of 
scanning)
Tunneling
 Catch: 
requires knowing the instruction length
Instruction lengths
 Simple approach: trap flag
 Fails to resolve the length of faulting instructions
 Necessary to search privileged instructions:
 ring 0 only: mov cr0, eax
 ring -1 only: vmenter
 ring -2 only: rsm
Instruction lengths
 Solution: page fault analysis
Instruction lengths
 Choose a candidate instruction
 (we don’t know how long this instruction is)
Page fault analysis
0F 6A 60 6A 79 6D C6 02 6E AA D2 39 0B B7 52
 Configure two consecutive pages in memory
 The first with read, write, and execute permissions
 The second with read, write permissions only
Page fault analysis
 Place the candidate instruction in memory
 Place the first byte at the end of the first page
 Place the remaining bytes at the start of the second
Page fault analysis
0F  6A 60 6A 79 6D C6 02 …
 Execute (jump to) the instruction.
Page fault analysis
0F  6A 60 6A 79 6D C6 02 …
 The processor’s instruction decoder checks 
the first byte of the instruction.
Page fault analysis
0F  6A 60 6A 79 6D C6 02 …
 If the decoder determines that another byte is 
necessary, it attempts to fetch it.
Page fault analysis
0F  6A 60 6A 79 6D C6 02 …
 This byte is on a non-executable page,
so the processor generates a page fault.
Page fault analysis
0F 6A 60 6A 79 6D C6 02 …
 The #PF exception provides 
a fault address in the CR2 register.
Page fault analysis
0F 6A 60 6A 79 6D C6 02 …
 If we receive a #PF, with CR2 set
to the address of the second page,
we know the instruction continues.  
Page fault analysis
0F 6A 60 6A 79 6D C6 02 …
 Move the instruction back one byte.
Page fault analysis
0F 6A  60 6A 79 6D C6 02 …
 Execute the instruction.
Page fault analysis
0F 6A  60 6A 79 6D C6 02 …
 The processor’s instruction decoder checks 
the first byte of the instruction.
Page fault analysis
0F 6A  60 6A 79 6D C6 02 …
 If the decoder determines that another byte is 
necessary, it attempts to fetch it.
Page fault analysis
0F 6A 60 6A 79 6D C6 02 …
 Since this byte is in an executable page, 
decoding continues.
Page fault analysis
0F 6A 60 6A 79 6D C6 02 …
 If the decoder determines that another byte is 
necessary, it attempts to fetch it.
Page fault analysis
0F 6A 60 6A 79 6D C6 02 …
 This byte is on a non-executable page,
so the processor generates a page fault.
Page fault analysis
0F 6A 60 6A 79 6D C6 02 …
 Move the instruction back one byte.
Page fault analysis
0F 6A 60  6A 79 6D C6 02 …
 Execute the instruction.
Page fault analysis
0F 6A 60  6A 79 6D C6 02 …
 Continue the process while
we receive #PF exceptions 
with CR2 = second page address
Page fault analysis
0F 6A 60  6A 79 6D C6 02 …
 Move the instruction back one byte.
Page fault analysis
0F 6A 60 6A  79 6D C6 02 …