# 【漏洞分析】CVE-2017-11826漏洞分析、利用及动态检测
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
作者：[银雁冰](http://bobao.360.cn/member/contribute?uid=314174049)
预估稿费：600RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**  
**
**简介**
****
北京时间2017年10月11日，微软在10月的安全公告中公开致谢奇虎360，后者在9月底向其秘密报告了一个在野office
0day并积极协助修复。该漏洞的成因是标签没有正确闭合，造成用OLEObject的数据结构解析了font提供的数据。攻击者通过在font的name属性中提供精心构造的数据，覆写了一个函数指针，从而实现控制流劫持。该漏洞是和CVE-2015-1641一样经典的类型混淆漏洞。这篇文章中，我将分析该漏洞的触发原理，并在此基础上尝试构造该漏洞的一个简单利用，最后给出该漏洞的动态检测方案。
分析所用样本的MD5: **b2ae500b7376044ae92976d9**********
**静态分析**
****
原始样本为一个rtf文档，初步观察后发现该漏洞最后有一段乱码字符，初步判断是一段payload。进一步观察发现该样本为常见的rtf文档利用方式，于是在内容中搜索可能被嵌入的word对象，搜索“Word.Document.12”，得到如下结果：
证明该rtf文件里面嵌入有word文档对象，于是用[rtfobj.py](https://github.com/decalage2/oletools/blob/master/oletools/rtfobj.py)工具进行提取，结果如下：
可以发现该样本内嵌三个对象，其中两个为Word.Document.12对象，另外一个暂时未知。联想到之前分析过的CVE-2015-1641漏洞，于是猜测该样本由3部分构成：一个用于堆喷射文档，用于绕过ASLR的控制语句，一个漏洞触发文件。于是我把编号为1、2的两个对象的后缀名改为.zip，并用压缩软件打开，果不其然，看到了如下目录结构：
类比CVE-2015-1641，我在提取出来的2号文档的document.xml文件里面看到了如下语句：
可以看到标签缺乏这一闭合标签，而且中间存在特殊字符，猜测这就是漏洞触发点，等待后面验证。
到这里，还没有找到Bypass ASLR的关键字。我尝试在rtf文档中搜索类似如下的文本内容(该类型漏洞用来Bypass
ASLR的常见方式，最终会导致加载msvcr71.dll从而Bypass ASLR)：
有点意外，没有发现类似的内容，而且看rtfobj.py提取出的0号对象也不像。不过我注意到在Word.Document.12对象嵌入前存在下面的语句：
里面有一个CLSID：D5DE8D20-5BB8-11D1-A1E3-00A0C90F2731，查询得知该CLSID对应的模块为msvbvm60.dll，读过《Bypassing
Windows ASLR in Microsoft Office using ActiveX
controls》这篇文章的人应该都知道这个模块是可以用来Bypass ASLR的。分析到这里，前面猜测的3部分已经都定位到了，下面进行动态验证。
(工具为James Forshaw的OleViewDotNet)
**动态分析**
****
为了方便动态分析，需要构造一个crash样本。依据之前对CVE-2015-1641的调试经验，只要在rtf文档中把堆喷射部分移除，就可以造成可控的crash。具体来说，就是在原始样本中把上面提取出来的编号1的内容和最后的乱码部分(乱码部分一般是该类型漏洞利用方式的第二阶段payload)给移除，或者构造一个最简crash，如下：
我的调试环境为windows7_sp1_x86 + office2007，具体的文件版本如下：
将上述最简crash拖进虚拟机，用windbg打开winword.exe，然后打开该crash文件，发现在如下位置产生一个访问违例：
且此时的寄存器状态如下：
可以看到这是一个call调用，且eax寄存器的值为0x88888ec，在有堆喷射的情况下，该地址处应该为布控好的内存，因为现在没有进行堆喷射，所以此处是一个无效值。
计算得到崩溃点在wwlib中的偏移为3d30e9：
从IDA的反汇编视图中可以猜测出崩溃函数的第二个参数的+0x1c处的值为一个长度，+0x18处的值为一个宽字字符串：
对崩溃函数的首地址下断点，调试验证上面的猜测，输出如下：
对照静态分析得到的文件，可以发现，崩溃函数的第二参数中存有每次解析的标签，崩溃函数应该是在解析每一个标签的内容。从上图可以看到，当解析到idmap标签时发生了crash，并且在上图中并没有发现font标签。猜测font标签是在其他函数中进行解析的。
于是追溯到崩溃函数的父函数，父函数为sub_3D3FB，崩溃函数在父函数的调用处如下：
观察发现父函数的逻辑是对更大范围标签进行派发。现在来下断点验证一下父函数是否解析到了font标签。从IDA视图中可看出，崩溃函数的第一参数为父函数调用处[esi+b10]存的值，崩溃函数的第二参数即为父函数的第二参数，于是对父函数的首部下断点，得到如下的调试结果，可以看到父函数是可以解析到font的：
现在对崩溃函数和父函数首部同时下断点，看父函数把标签派发给崩溃函数的情况：
可以看到OLEObject和idmap标签父函数都派发给了崩溃函数处理，但font标签父函数没有派发给崩溃函数。
调试到这里，已经知道是wwlib在解析漏洞文件中的OLEObject及其子标签时引发的漏洞。接下来的问题是，漏洞文件中的数据是如何被传递到漏洞触发处的？
注意到崩溃点的上面不远处有一个 **call(sub_9DA0)**
，对该call下断点，多次调试之后发现该call的返回值对应的[[ret_value+44]+44]处固定为0x88888ec，猜测该值为漏洞文件所提供。对sub_9DA0函数进行分析后，发现该函数的作用是计算返回一个地址，分析时我的IDA注释显示该函数在CVE-2015-1641的触发过程中也被用到(因为也要解析标签获取数据)。在IDA中发现该函数会通过ecx提供的值计算得到一个地址，如下：
地址计算公式为 edx × [ecx + 8] + [ecx + c] + ecx。
如下图所示：在崩溃函数中发现调用前ecx的值源自esi，edx的值也来自esi，而esi进一步源自arg0，所以地址计算公式可以表示为：([[[arg0+b14]]]
– 2) × [[[arg0+b14]]+ 8] + [[[arg0+b14]]+ c] + [[arg0+b14]]：
此时对崩溃函数开始处的断点输出进行补充，使标签名和每个标签对应的公式数据一并输出。调试后得到如下结果(输出中第一个值并没有减2，后面在计算公式需要手动减2，其实后面会发现这个值在函数中是固定的)：
从上图的输出中可猜到，紫色框圈出的输出应该为xml文件中标签解析的嵌套层级，可以看到漏洞触发时OLEObject对应的level为4，idmap对应的level为6。从上图中也可得知：在崩溃函数中，公式第一项的右乘数和公式第二项的值在每次计算时都固定保持不变，分别为0x4c和0x10，且公式的第四项在解析OLEObject标签及其子标签时保持不变。所以公式可以简化为：(current_level-2)×
0x4c + 0x10 + [[arg0+0xb14]]
由上面的分析可知崩溃前的sub_9DA0返回值的[[ret_value+44]+44]处的值固定为0x88888ec，且此时传入sub_9DA0的 edx
= 6–2 =
4。重启windbg，在解析OLEObject标签时，用上面推导的公式计算得到崩溃点前sub_9DA0会返回的值calc_addr。先查看[[calc_addr+44]+44]处的值，发现访问违例，再退一步查看[calc_addr+44]处的值，发现全为0，于是对[calc_addr
+44]处下一个内存写入断点，调试及输出如下：
6字节数据在内存中变成了4字节数据，猜测用到了utf-8编码，验证一下果然是这样。如下图：可以看到原文件中的非ASCII码字符通过utf-8编码后到达了内存中的指定地方，从而在漏洞触发后被获取：
由栈回溯发现，该拷贝过程发生在父函数的另一处逻辑里，如下。该逻辑应该就是解析font标签的逻辑，这里不再深入追踪：