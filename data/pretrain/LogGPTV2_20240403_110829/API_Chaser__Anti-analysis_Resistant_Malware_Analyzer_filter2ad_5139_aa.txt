title:API Chaser: Anti-analysis Resistant Malware Analyzer
author:Yuhei Kawakoya and
Makoto Iwamura and
Eitaro Shioji and
Takeo Hariu
API Chaser:
Anti-analysis Resistant Malware Analyzer
Yuhei Kawakoya, Makoto Iwamura, Eitaro Shioji, and Takeo Hariu
NTT Secure Platform Laboratories
3-9-11 Midori-Cho Musashino-Shi Tokyo, Japan
Abstract. API (Application Programming Interface) monitoring is an
eﬀective approach for quickly understanding the behavior of malware. It
has been widely used in many malware countermeasures as their base.
However, malware authors are now aware of the situation and they de-
velop malware using several anti-analysis techniques to evade API mon-
itoring. In this paper, we present our design and implementation of an
API monitoring system, API Chaser, which is resistant to evasion-type
anti-analysis techniques, e.g. stolen code and code injection. We have
evaluated API Chaser with several real-world malware and the results
showed that API Chaser is able to correctly capture API calls invoked
from malware without being evaded.
Keywords: Malware, Taint Analysis, Anti-analysis, Evasion, WinAPI
1
Introduction
Malware threats have become one of the largest problems on the Internet over the
past decade. Malicious activities on the Internet, such as massive spam-emailing
and denial-of-service attacks, have arisen from botnets composed of countless
malware-infected machines. To combat malware, analysts utilize various tech-
niques and tools to reveal details on malware activities.
Dynamic analysis is one of the major techniques for malware analysis. API
monitoring especially is an eﬀective and eﬃcient technique for rapidly under-
standing malware activities because an API has rich semantic information. A
sequence of API calls provides us more high-level behavioral views of malware
activities than other dynamic analysis approaches, such as system service call or
resource access monitoring. It is also used in many research and industrial areas
as part of an important countermeasure to malware, e.g. in malware detection
and automatic signature generation [1]. That is, API monitoring has become an
important approach in both research and industrial security communities.
However, since malware developers are now familiar with malware analy-
sis techniques, they embed anti-analysis functions into their malware to evade
API monitoring [2][3]. Many anti-analysis techniques that evade API monitor-
ing have currently been adopted in malware in the wild. There are mainly two
types of evasion techniques used in current malware: hook evasion and target
evasion. Hook evasion is a technique to evade hooks set on the entry of APIs for
monitoring. Target evasion is used for obfuscating the caller instruction of APIs.
2
These anti-analysis have become a serious issue for anti-malware research,
especially for practical malware analysis systems. However, this issue has not
been extensively discussed. As a result, existing API monitors give a chance for
malware to evade their monitoring. In this paper, we focus on this issue and
present design and implementation of a practical API monitor, API Chaser,
which is resistant to various evasion-type anti-analysis techniques.
API Chaser has been built on a whole system emulator, Qemu[4] (actually
Argos[5]), and executes monitored malware in a guest operating system (OS)
running on it. In API Chaser, we use code tainting technique to precisely identify
the execution of monitored instructions. The procedure of code tainting is as
follows. First, we set taint tags on target instructions before executing them.
Then, we begin to run the executable containing the monitored instructions. At
the virtual CPU of an emulator, we conﬁrm whether a fetched instruction has
the taint tag targeted for analysis. If it does, it is executed under analysis. If
not, it is executed normally.
We apply code tainting technique to API monitoring. Its mechanism is as
follows. We use three types of taint tag for three diﬀerent types of instructions:
the instructions of APIs, the ones of malware, and the ones of benign programs.
First, we set the three types of taint tags on their target instructions respec-
tively. Then, when the CPU fetches an instruction and the instruction has the
taint tag for API, it conﬁrms which types of taint tags the caller instruction
has. There are three cases: a taint tag for malware, benign, and API. Each case
respectively corresponds to the following situations: an API call from malware,
a benign process, and other API(nested call). Our target for monitoring is the
call only from malware and we exclude the others from our target to monitor
API calls directly invoked from malware. Our API monitoring approach is resis-
tant to evasion techniques because it is able to distinguish between the target
instructions and others at byte granularity even when they exist in the same
process memory space. In addition, malware cannot escape from our monitoring
because our approach is able to track the movement of monitored instructions by
propagating taint tags set on them. Furthermore, our approach is independent
from the OS semantic information, such as virtual addresses, Process ID (PID)
or Thread ID (TID), and ﬁle names. So, it is no longer inﬂuenced by the changes
of these information by malware for evading analysis systems.
In API Chaser, we use two additional techniques for enhancing the resistance
against anti-analysis used in malware: pre-boot disk tainting and code taint prop-
agation. Pre-boot disk tainting is an approach to set taint tags on target in-
structions in a disk image ﬁle before booting a guest OS. It makes it possible to
conduct taint tag setting for analyzing malware without being interfered by mal-
ware. Code taint propagation is a set of additional rules for propagating the taint
tag of an instruction of malware to the code generated by the malware’s instruc-
tion. It prevents malware from evading our monitoring by generating code with
implicit-ﬂow like code extraction, which is code ﬂow disabling taint propagation
over it.
3
API Chaser has been implemented on Argos [5], which is a honeypot for
detecting zero-day exploits with taint tracking. We reuse a part of the source
code of Argos and extended some of its components, e.g. the virtual CPU, the
shadow memory and the virtual DMA (Direct Memory Access) controller. In
addition, we added a shadow disk and its controller into Argos.
To show the eﬀectiveness of API Chaser, we have conducted some experi-
ments using several real-world malware with a wide range of anti-analysis tech-
niques. We executed these malware on API Chaser and comparative environ-
ments which are API monitors using existing techniques for API monitoring.
Then we compared the logs output by each environment. If captured API calls
were diﬀerent, we manually investigated and revealed the causes of the diﬀer-
ence to determine whether the fault was in API Chaser or in the comparative
environments. The experimental results indicated that API Chaser is able to
precisely capture the API calls from all sample malware without being evaded.
In summary, we make the following contributions in this paper.
– Firstly, we introduce our API monitoring approach using code tainting. It
makes it possible to correctly identify API calls even from malware using
evasion-type anti-analysis techniques.
– Secondly, we present API Chaser, which is a practical API monitoring sys-
tem. We describe the design and detailed implementation of API Chaser
including pre-boot disk tainting and code taint propagation.
– Finally, we show the evaluation result of API Chaser using real world mal-
ware. These malware contain various anti-analysis techniques related to evad-
ing API monitoring. The results showed that API Chaser is able to correctly
capture APIs called from malware.
2 Anti-analysis Resistance of Existing Approaches
In this section, we explain several anti-analysis techniques used in malware for
evading API monitoring, and we also explain problems of existing approaches
against them. We categorized evasion-type anti-analysis techniques into two
types depending on their purpose. The ﬁrst is hook evasion, which is used for
evading API hooks. The second is target evasion, which is used for obfuscating
the API caller.
2.1 Hook Evasion
Hook evasion is a technique to evade being hooked by an analysis system. We
explain three major hook-evasion techniques: stolen code, sliding call, and name
confusion.
Fig.1 (a) shows the behavior of stolen code. Stolen code copies some instruc-
tions from the entry of an API to allocated memory areas in the malware process
at runtime. When malware attempts to call the API, it ﬁrst executes the copied
instructions and then jumps to the address of the instruction in the API follow-
ing the copied instructions. Some existing API monitors [6][7][8] identify their
target API calls by the execution of the instructions at the virtual addresses
4
Fig. 1. Stolen Code and Sliding Call Mechanism
where these APIs are expected to be located. The expected addresses are com-
puted from the base address of the loaded module containing these APIs and
the oﬀsets to them, which are written in PE (Portable Executable) header of the
module. If the instructions of these APIs are copied to addresses diﬀerent from
the expected ones, existing API monitors may miss to capture the execution of
these APIs.
Fig.1 (b) shows the behavior of sliding call. Sliding call behaves like almost
the same as stolen code. The diﬀerence is that malware originally has a few
instructions of the entry of a speciﬁc API in its body and calls the API after
executing those instructions. Almost all existing API monitors focus on, e.g.
place a hook at, the entry of each API[9][8][6][7], causing their monitoring to
be evaded because the instruction at the head of the API is not executed by
malware using sliding call.
Name confusion involves copying a system dynamic link library (DLL) to
another ﬁle path while changing its ﬁle name. The copied DLL exports the
same functions as the original DLL, so the malware loading the copied DLL can
still call the same functions as the ones in the original DLL. If the name has
been changed, some analysis systems [6][10][7] that depend on the names of the
module to identify their target can be evaded. In addition, name confusion is
also often used for target evasion, e.g. malware changes its name to the one of
system executables installed as default, such as svchost.exe or winlogon.exe.
2.2 Target Evasion
Target evasion is a technique in which malware attempts to evade being the
target of analysis. We explain two target evasion techniques: code injection and
ﬁle infection.
Code injection injects a piece of malicious code into another process, and en-
ables that code to be executed in that process. If an API monitor distinguishes
its monitoring target based on PID or TID, which is very common in most of
existing systems [8][6][7][10], it needs to set hooks on speciﬁc APIs in advance
or monitor DLL loading events in order to extract the destination of the injec-
tion. The traceability in existing systems is tightly bound to a speciﬁc injection
method. Even if it succeeds in identifying the injected process as a monitoring
target, it would be diﬃcult to correctly distinguish APIs called from malicious
code injected into the process and those called from the original code in the
process.
mov  edi, edipush ebpmov  ebp, esp...aaaaaapush ebpjmpAPI+3API:API+3:(malware.exe)mov  edi, edicall   sliding_APImov  edi, edipush ebpapush ebpAPI:API+3:mov  ebp, esp...jmp   API+3(malware.exe)stolen_API:mov  edi, ediControl flowCopied data flowcall   stolen_APICopying(a) Stolen Code(b) Sliding Codesliding_API:5
File infection is another target evasion technique. It basically adds a piece of
code to an executable ﬁle and modiﬁes pointers in its PE header to make the
added code executed after the program begins to run. Similar to code injection,
it is also diﬃcult to distinguish between API calls from malicious code and those
from the original benign code if the API monitor tries to identify its target with
PIDs or TIDs.
3 Our API Monitoring
To solve the evasion problems which existing API monitors have, we propose
our API monitoring approach using code tainting for precisely identifying the
execution of APIs. First, we deﬁne some terms and the scope of this paper.
Second, we present code tainting. Third, we describe the types of monitored
instructions. Last, we present how to capture API calls invoked from malware
and exclude the ones invoked from benign processes and nested API calls.
3.1 De(cid:12)nitions and Scope
We deﬁne the three important terms used in this paper: API, API call, and API
monitoring.
– API is a function composed of more than one instruction to conduct a
speciﬁc purpose and we use it interchangeably with a user-land Windows
API(WinAPI), which is a function provided from Windows operating sys-
tem and libraries.
– API call is a control transfer with valid arguments from an instruction out-
side of an API to an instruction within the API.
– API monitoring is an approach to detect the ﬁrst execution of an instruc-
tion of monitored APIs immediately after control has been passed from an
instruction outside of the API.
We explain the scope of this paper. The anti-analysis techniques in the scope
are the ones which we mentioned in the previous section, those used for hiding
API calls which malware has actually invoked. We exclude the anti-analysis
techniques designed to use conditional execution to evade analysis systems, e.g.
trigger-based ones[11] and stalling code[12], from the scope of this paper. Another
limitation is the inability to detect invocations of statically linked functions
which do not execute any instructions of system modules we prepared in our
analysis environment.
3.2 Code Tainting
Code tainting is an application of taint analysis and it is a technique used for
identifying the execution of monitored instructions based on taint tags set on
them. It sets taint tags on the target instructions before executing them. After
that, when the CPU fetches an instruction, it conﬁrms if the instruction (actually
the opcode of the instruction) has a taint tag. If the instruction has the taint tag
targeted for analysis, it will be executed under analysis. If not, it will be executed
normally. When monitored instructions are operated as data, taint tags set on
6
Fig. 2. Our API Monitoring Mechanism
the instructions are propagated by the same way as data tainting. That is, we
can track the movement of monitored instructions based on the taint tags.
There are three eﬀects of code tainting for monitoring malware activities.
First, it becomes possible to conduct ﬁne-grained monitoring. This property is
eﬀective against malware using target evasion techniques. Code tainting is able
to distinguish the target instructions and others at byte granularity based on
taint tags, even though there are both injected malicious instructions and benign
ones mixed together in a same process space or a same executable. Second, it
allows to track the movement of the target instruction by propagating taint
tags set on them. This property is eﬀective against both target evasion and
hook evasion techniques. For example, when malware injects its malicious code
into other processes or other executables, code tainting can track the injection by
propagating taint tags set on the malicious code. Third, it is no longer inﬂuenced
by changing of the semantic information of an OS, e.g. virtual addresses, PID or
TID, and ﬁle names. This property is also eﬀective against both target evasion