title:Fault Attacks on Efficient Pairing Implementations
author:Pierre-Alain Fouque and
Chen Qian
Fault Attacks on Efﬁcient Pairing Implementations
Pierre-Alain Fouque
Rennes 1 University & IUF & IRISA
France
PI:EMAIL
Chen Qian
École normale supérieure de Rennes
France
PI:EMAIL
ABSTRACT
This paper studies the security of eﬃcient pairing imple-
mentations with compressed and standard representations
against fault attacks. We show that these attacks solve
the Fixed Argument Pairing Inversion and recover the ﬁrst
or second argument of the pairing inputs if we can inject
double-faults on the loop counters. Compared to the ﬁrst at-
tack of Page and Vercauteren on supersingular elliptic curves
in characteristic three, these are the ﬁrst attacks which ad-
dress eﬃcient pairing implementations.
Most eﬃcient Tate pairings are computed using a Miller loop
followed by a Final Exponentiation. Many papers show how
it is possible to invert only the Miller loop and a recent
paper of Lashermes et al. at CHES 2013 shows how to in-
vert only the ﬁnal exponentiation. During a long time, the
ﬁnal exponentiation was used as a countermeasure against
the inversion of the Miller loop. However, the CHES attack
cannot be used to invert this step on eﬃcient and concrete
implementations.
Indeed, the two ﬁrst steps of the Final
Exponentiation use the Frobenius map to compute them ef-
ﬁciently. The drawback of the CHES 2013 attack is that it
only works if these steps are implemented using very expen-
sive inversions, but in general, these inversions are computed
by using a conjugate since elements at the end of the ﬁrst
exponentiation are unicity roots. If this natural implemen-
tation is used, the CHES 2013 attack is avoided since it
requires to inject a fault so that the faulted elements are
not unicity roots. Consequently, it is highly probable that
for concrete implementations, this attack will not work. For
the same reasons, it is not possible to invert the Final Ex-
ponentiation in case of compressed pairing and both meth-
ods (conjugate and compressed) were proposed by Lasher-
mes et al. as countermeasures against their attack. Here,
we demonstrate that we can solve the FAPI-1 and FAPI-2
problems for compressed and standard pairing implementa-
tions. We demonstrate the eﬃciency of our attacks by using
simulations with Sage on concrete implementations 1.
1http://perso.eleves.ens-rennes.fr/˜cqian/implementation/
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
ASIA CCS’16, May 30–June 3, 2016, Xi’an, China.
c(cid:13) 2016 ACM. ISBN 978-1-4503-4233-9/16/05. . . $15.00
DOI: http://dx.doi.org/
1.
INTRODUCTION
Pairing-based cryptography is an important research area
in public-key cryptography since many cryptosystems have
been deﬁned. In practice, pairing schemes are deployed since
they have many appealing properties. Many papers have
proposed eﬃcient implementations for pairing in various en-
vironments (software, hardware, constrained hardware) with
diﬀerent pairings: Tate, Eta, Ate pairings [3]. Implementa-
tions are nowadays eﬃcient and other features have been
presented such as representations which enable to reduce
the size of elements. Consequently, it is important to study
the resistance of these schemes against physical attack since
smartcard implementations have also been proposed in [11].
A pairing is a bilinear function e(·,·) that maps two ellip-
tic curve groups to a ﬁnite subgroup of a ﬁnite ﬁeld, so that
e(aP, bQ) = e(P, Q)ab. It was ﬁrst introduced in cryptogra-
phy to attack the discrete log problem in some elliptic curves
by Menezes et al.
in [20]. Later, Joux and others showed
that it can also be used for building eﬃcient cryptographic
protocols, e.g. tripartite Diﬃe-Hellman protocols in [17] and
to solve the Identity-Based Encryption (IBE) problem by
Boneh and Franklin [8]. Since then, many papers propose
eﬃcient cryptosystems with interesting characteristics [7, 9,
6]. There are not many pairing-based cryptosystems that
can be attacked using fault attacks.
Indeed, pairings are
usually used for checking computations in signature schemes
and the exponentiation with the secret elements is performed
once the pairing is computed or before its computation. The
ﬁxed argument pairing inversion problem (FAPI) has been
deﬁned by Galbraith et al.
in [14]. The main application
is for attacking pairing scheme in the IBE scheme. In [8],
to decrypt ciphertexts, users compute the pairing e(dID, u)
between the secret key dID = sQID, where QID = H1(ID),
and the ﬁrst element of the ciphertext (u, v), where u = rP .
Depending on the implementation, the secret input dID is
the ﬁrst or the second argument.
In [8], the Weil pairing has been used with superelliptic
curves in characteristic three, but today, more eﬃcient pair-
ings have been proposed and IBE can be implemented very
eﬃciently with these pairings. The most eﬃcient pairings
are variants of the Tate pairing which are computed in two
steps. During the ﬁrst one, the Miller loop is performed fol-
lowed by a so-called ﬁnal exponentiation. Diﬀerent pairings
have been deﬁned Weil, Tate, Ate, Eta, Optimal Ate, and
many eﬃcient implementations in [21, 13, 3, 10, 16, 2, 31] in
addition to pairing-friendly elliptic curves, culminating with
the Barreto-Naehrig curves [4].
http://dx.doi.org/10.1145/2897845.2897907641Related Work.
In 2006, Page and Vercauteren in [27]
proposed the ﬁrst fault attack for inverting pairing com-
putations. This attack allows us to completely invert the
pairing and solves the FAPI-1 and FAPI-2 problems when
the Duursma and Lee implementation of the pairing [12] is
used for supersingular curve. Since then, many attacks have
been described on the Miller Loop and El Mrabet proposed
diﬀerent techniques to invert the Miller loop [23, 25]. In a
nutshell, these attacks work as follows: consider a square-
and-multiply implementation from the most signiﬁcant bits
to the least signiﬁcant ones which is closely related to the
Miller loop. Then, during the computation of M d if the
exponent bit is set to one, the following computation is per-
formed: f 2 × M with f the current variable storing the
output f = M d.
If we stop the loop before the end, we
denote by fi the value corresponding to M to the power the
integer representing the last bits of the binary representa-
tion of d. If we have the outputs for two consecutive values
of the loop counter i and i + 1, then we will have fi and
fi+1 and if the ith bit of d is one, then we have the following
i × M . In this case, it is easy to recover
equation: fi+1 = f 2
M . Inverting the Miller loop works similarly with diﬀerent
operations.
However, these attacks have some limitations and namely,
it was not possible to invert the Final Exponentiation which
seems to be the more diﬃcult part of the inversion accord-
ing to Wheelan and Scott [32]. In their article, Whelan and
Scott conclude that the ﬁnal exponentiation is not easy to
invert and protect the output of the Miller Loop from in-
verting the pairing in the case of Tate pairing. The Final
Exponentiation has to compute f (qk−1)/r and eﬃcient com-
putations split this exponentiation into the three following
exponentiations in the case of BN curves with embedding
degree 12:
(cid:18) p4 − p2 + 1
(cid:19)
.
p12 − 1
r
= (p6 − 1)(p2 + 1)
r
The two ﬁrst exponentiations, namely to the powers (p6− 1)
and (p2+1), can be eﬃciently performed using the Frobenius
and only the ﬁnal exponent (p4−p2 +1)/r is computed using
a square-and-multiply algorithm. The two last exponentia-
tions require to compute inverse and usually this operation
is expensive but in our case, since f p6−1 is in the group of
elements µp6+1 = {x ∈ F
p12 : xp6+1 = 1}, we can compute
x−1 by taking its conjugate. This will be explained in details
in the section 2.2.
Recently, Lashermes et al. at CHES 2013 show a tech-
nique which allows to invert the ﬁnal exponentiation. How-
ever, they do not explain how it is possible to invert the
full pairing in [18]. As an open problem, they ask whether
it is possible to invert the whole pairing by using their at-
tack and propose some countermeasures against their attack.
Their attack is based on a very simple and not eﬃcient im-
plementation of the ﬁnal exponentiation. Since Barreto et
al.’s eﬃcient implementations in [3] and very eﬃcient im-
plementation of Devegili et al. in [11], the Final Exponen-
tiation in the case of Tate pairing is computed using the
Frobenius map for the ﬁrst two exponentiations: e.g.
to
compute f p6−1 can be seen as 6 Frobenius followed with an
inversion. As we previously mentioned inversion is easy to
compute in this case by using the conjugate of the element.
However, in the CHES attack they add an error to the el-
ement and there is no reason that (f + e)p6−1 ∈ µp6+1 if e
is the error introduced. Lashermes et al. attack uses a non-
eﬃcient square-and-multiply algorithm to compute f (p6−1)
and f (p6−1)(p2+1). Consequently, their work is interesting,
as it is the ﬁrst work to address this problem, but it has
no practical interest. As a countermeasure, they propose
to use an eﬃcient implementation with Frobenius or com-
pressed pairing developed in [28, 15, 26] to avoid their at-
tack. Finally, in [19], Lashermes et al. propose a practical
fault attack using multiple faults to attack the Miller algo-
rithm. Their main results is that the multiple fault attack
they propose cannot invert the whole pairing but only the
Miller loop algorithm. In a survey of fault attacks in Pairing
Based Cryptography, El Mrabet et al. propose to study the
problem to invert the entire pairing using many faults, but
they never attack eﬃcient computations with Frobenius.
A recent work on the fault attack by Bl¨omer, Gomes da
Silva, G¨unther, Kr¨amer and Seifert [5] shows that they invert
the pairing computation a fault to skip the ﬁnal exponenti-
ation. However, their fault model are realized on their own
implementation, it is not clear that their methode can be
applied to a real implementation of pairing.
Our Contributions. In this paper, we attack two coun-
termeasures proposed by Lashermes et al. that correspond
to eﬃcient and compressed implementations. We describe
fault attacks that are able to fully invert the Tate pairing
and the Final Exponentiation for standard and compressed
representations. The ﬁrst attack is on the compressed pair-
ing implementation. To attack the standard representation
implementation, we show a reduction to the problem of in-
verting pairing with compressed representations. The main
idea for this reduction is that when we try to invert some
value f after the two ﬁrst exponentiations of the Final expo-
nentiations, the exponentiation to the power p6 − 1 kills the
elements in F
p6 that multiply f . Consequently, it is impossi-
ble to invert these exponentiations. Our idea is to compute a
compressed version of f , and then we can apply our previous
attack. We implement this idea and we show that we can
recover the secret elements. We solve the FAPI-1 and FAPI-
2 problem in general and in the case of BN-curves, we have
more eﬃcient attacks. To demonstrate the eﬃciency of our
attacks, we put in appendix the Sage program. It is amazing
to note that attacking directly the standard pairing seems
to be diﬃcult, while after our ﬁrst attack on compressed
implementations, it becomes easy thanks to our reduction.
In our attack, the fault model is diﬀerent from Lashermes
et al. attack and is very similar to Page and Vercauteren
model, where the adversary can inject a fault in the loop
counter to stop the Miller loop and the Final Exponentia-
tion loop before its expected end. We use also a double fault,
since we need to inject a fault in the counter for the Miller
Loop and another one in the counter for the Final Exponen-
tiation. Such double faults are nowadays recognized to be
eﬃcient in practice and much work have shown them [19].
In Lashermes et al.
fault model, the adversary injects a
small fault in the intermediate representation of a value.
Then, the adversary must be able to perform an exhaustive
search on this small value. If small 8-bit registers are used,
the attack can be eﬃcient, but if 32-bit registers are used,
the attack becomes less eﬃcient. Finally, we would like to
highlight that in this work we target concrete implemen-
tations of the compressed pairing as developed by Naehrig
642et al.
in [26] that use the most eﬃcient Barreto-Naehrig
curves [4]. Moreover, for this particular implementation,
we have an inversion of the ﬁnal exponentiation that uses
speciﬁc features of the concrete implementation and which
allows a more eﬃcient attack.
Organization of the paper. In section 2, we recall prelim-
inaries about pairing and their eﬃcient implementations in-
cluding compressed pairing and BN curves. In section 3, we
describe two fault attacks on compressed pairing, a generic
one and a more eﬃcient one in the case of BN-curves. In
section 4, we show some simulations of these attacks and
we give our implementations in appendix with Sage code.
In section 5, we extend our fault attack to standard (non-
compressed representation) and show that the most eﬃcient
pairing implementation is also vulnerable to our attack. Fi-
nally, in appendix we recall Lashermes et al. attack.
2. PRELIMINARIES
Here we recall some deﬁnitions about pairing based cryp-
tography and introduce the deﬁnition of compressed pairing
proposed by Naehrig et al. [26]. We consider the elliptic
curve E(Fp) deﬁned over the ﬁnite ﬁeld Fp of large charac-
teristic p > 5. Let n be the order of E(Fp), r be a large
prime divisor of n, and k be the smallest integer such that r
divides pk − 1. The integer k is called the embedding degree
of E with respect to r.
2.1 Pairing on the elliptic curve
P (caP )(P ). Let f : E(F
P aP (P ) is the sum(cid:80)
The degree of a divisor A =(cid:80)
sum; in particular cA = (cid:80)
pk be a function on the curve and A =(cid:80)
sor of degree 0. We deﬁne f (A) =(cid:81)
that since (cid:80)
pk . The divisor of a function f is (f ) =(cid:80)
It is well-known that a divisor A = (cid:80)
pal iﬀ the degree of A is zero and (cid:80)
Let G1, G2 and G3 be three ﬁnite groups. Usually in cryp-
tography, G1, G2 are additive groups and G3 is a multiplica-
tive group. Let [a]P be the scalar multiplication between
P ∈ E and a ∈ Z, ∞ be the inﬁnity point in the elliptic curve
E. A divisor is a formal sum of points on a curve E(F
pk ).
P aP .