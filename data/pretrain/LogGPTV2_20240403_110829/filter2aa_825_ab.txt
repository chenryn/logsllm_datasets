Focus on system/nfc of AOSP
• 协定叠实现在此 Protocol stack implements here
• 大量直接操作raw buffer   Raw buffer manipulations
• 用户可控资料 User-controlled data
聚焦于AOSP的system/nfc资料夹
Focus on system/nfc of AOSP
Java Wrapping
JNI implementation
Mifare 
Stack
NDEF 
processing 
impl.
card 
emulati
on impl.
P2P 
impl.(LL
CP)
t1t
t2t
t4t
i93
R/W 
impl.
t3t
t4t
Public basis: GKI buffer/msg 
managing, NFA, checksum, HAL 
Adaptation
com.android.nfc
t3t
User App
NFC HAL impl.
Binder IPC
with the 
help of
ServiceM
gr, APIs
HwBinder IPC
with the help
of hwSvrMgr
android.hardwar
e.nfc@1.1-
service
Kernel NFC driver
NFC SoC
聚焦于AOSP的system/nfc资料夹
Focus on system/nfc of AOSP
基础概念 Necessary Basic Concepts
• gki
• nfa
• type of tags
gki
• 缓冲区记忆体分配器，基于ring buffer
(buffer) memory allocator based on ring buffer
• 讯息传递 message delivery
• 计时器 timer
gki
• 缓冲区记忆体分配器，基于ring buffer
难以破坏heap, 较少出现“double free”
消除了大量潜在的不安全缓冲区操作威胁
• 讯息传递
在不同的“任务（task）”之间传递讯息
• 计时器
Hard to corrupt heap; no 
“double free”
This nullify tons of unsafe 
buffer manipulations
Deliver msg between different “tasks”
nfa
• 系统管理器 system manager
• 设备管理器 device manager
• 状态机管理器 state machine manager
• 初始化和释放资源 resource init/release
• 在协定叠之间切换 switch between protocols
• 消息收发 messaging
• 与上层组件进行通讯 communicate with upper layer
• 总之，nfa可以理解为“管家程序”
In conclusion, housekeeper
type of tags
• 重申，命名方式很“随性” Again, naming is unbridled
• Reader/Writer支援: t1t, t2t, t3t, t4t, t5t, i93(ISO-15693), Mifare
Reader/Writer supports
• 卡片模拟支援: t3t(with limited functionality), t4t
Card emulation supports
模糊测试还是代码审计 Fuzz or Audit?
• 大量线程，大量状态机，大量状态
Many threads, many state machines, many states 
• 多阶段输入，顺序不定 Multi-stage input, causality
• 代码耦合度高，难以分解 Coupling, not easy to dismantle
• 约束条件多，从程序中间触发子模组crash不意味著能够依赖用户
输入实现同样效果
Constrains, crash in a sub module doesn’t mean reachable from user input
• 结论：审计优于模糊测试 Conclusion: Just audit it
Proxmark 3
• 如何写PoC   How to write a PoC
• 买张卡片恶意修改? ×通常卡片不支援发送异形资料包 Malicious card? 
Normal card don’t support malformed parcel
• 使用另一台Android设备模拟攻击卡片? ×Android支援的卡片模拟协定有
限
Simulate a card with another Android device? Limited support
• Proxmark 3√
Proxmark 3
Proxmark 3
• “The proxmark3 is a powerful general purpose RFID tool, the size of a 
deck of cards, designed to snoop, listen and emulate everything from 
Low Frequency (125kHz) to High Frequency (13.56MHz) tags.”
• 文档丰富 Well documented
• 晶片, 高频率天线,低频率天线（非必须）, USB线
Chip, HF antenna, LF antenna(not indispensable), USB cable
• 当然，也有集成好的版本 Also integrated versions
Proxmark 3
Proxmark 3
• 官方代码分支(Proxmark/proxmark3)和
Iceman代码分支(iceman1001/proxmark3) 不够稳定但是功能更
强劲(Unstable but flavored)
Official fork(Proxmark/proxmark3) and Iceman fork(iceman1001/proxmark3) 
• 请遵守当地法律，不要做出snoop等行为
Comply with the law, don’t snoop
Proxmark 3
以iso 15693协定模拟为例
• 仅支援一条指令……
Only support one command …
• 预编译到设备中，结构包
含主体循环，指令分发
Pre-compile, main loop, cmd dispatch
• Let’s write some code!
void SimTagIso15693(uint32_t parameter, uint8_t *uid)
{
LEDsoff();
LED_A_ON();
FpgaDownloadAndGo(FPGA_BITSTREAM_HF);
SetAdcMuxFor(GPIO_MUXSEL_HIPKD);
FpgaWriteConfWord(FPGA_MAJOR_MODE_HF_SIMULATOR | 
FPGA_HF_SIMULATOR_NO_MODULATION);
FpgaSetupSsc(FPGA_MAJOR_MODE_HF_SIMULATOR);
StartCountSspClk();
uint8_t cmd[ISO15693_MAX_COMMAND_LENGTH];
// Build a suitable response to the reader INVENTORY command
BuildInventoryResponse(uid);
// Listen to reader
while (!BUTTON_PRESS()) {
uint32_t eof_time = 0, start_time = 0;
int cmd_len = GetIso15693CommandFromReader(cmd, sizeof(cmd), 
&eof_time);
if ((cmd_len >= 5) && (cmd[0] & ISO15693_REQ_INVENTORY) && 
(cmd[1] == ISO15693_INVENTORY)) { // TODO: check more flags
bool slow = !(cmd[0] & ISO15693_REQ_DATARATE_HIGH);
start_time = eof_time + DELAY_ISO15693_VCD_TO_VICC_SIM -
DELAY_ARM_TO_READER_SIM;
TransmitTo15693Reader(ToSend, ToSendMax, start_time, slow);
}
Dbprintf("%d bytes read from reader:", cmd_len);
Dbhexdump(cmd_len, cmd, false);
}
FpgaWriteConfWord(FPGA_MAJOR_MODE_OFF);
LEDsoff();
}
Proxmark 3
• PoC的基本结构
Skeleton of PoC
void calcRspAsTag(uint8_t* rsp, size_t len, uint8_t* toSend){
uint16_t crc;
crc = Crc(rsp, len - 2);
rsp[len - 2] = crc & 0xff;
rsp[len - 1] = crc >> 8;
CodeIso15693AsTag(rsp, len);
if(ToSendMax != len * 2 + 2){
Dbprintf("Fatal error");
}
memcpy(toSend, ToSend, ToSendMax);
}
....
#define UID 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x04, 0xe0,
//data get uid
static uint8_t CMD_GET_UID[] = {
0x26, 0x01, 0x00
};
static uint8_t RSP_GET_UID[] = {
0x00, 0x00, // flags dsfid
UID
0xff, 0xff // crc-16
};
static uint8_t TSND_GET_UID[sizeof(RSP_GET_UID) * 2 + 2] = {0};
while (!BUTTON_PRESS()) {
uint32_t eof_time = 0, start_time = 0;
int cmd_len = GetIso15693CommandFromReader(cmd, sizeof(cmd), 
&eof_time);
// read ndef only when the check is finished
if(sendData && (!memcmp(cmd, CMD_READ_NDEF, 
sizeof(CMD_READ_NDEF) - 1))){
bool slow = !(cmd[0] & ISO15693_REQ_DATARATE_HIGH);
start_time = eof_time + DELAY_ISO15693_VCD_TO_VICC -
DELAY_ARM_TO_READER;
TransmitTo15693Reader(TSND_READ_NDEF, 
sizeof(TSND_READ_NDEF), start_time, slow);
Dbprintf("recv cmd:");
Dbhexdump(cmd_len, cmd, false);
Dbprintf("send rsp:");
Dbhexdump(sizeof(RSP_READ_NDEF), (uint8_t*)RSP_READ_NDEF, 
false);
Dbprintf("\n");
continue;
}
......
}
实例分析 Case Study
实例分析涵盖NFC协定叠的3个模组
The case study covers three module of NFC stack 
• 一个卡片模拟例子 A Card Emulation Case
• 一个Reader/Writer例子 A Reader/Writer Case
• 一个nfa例子 An nfa Case
CVE-2019-9358
• CVE-2019-9358, Google评级为中危
• 位于卡片模拟(Host-based Card Emulation) 协定叠中
• https://developer.android.com/guide/topics/connectivity/nfc/hce
CVE-2019-9358
CVE-2019-9358
NDEF check
read in num_services
without validation
out of bound write 480 
bytes at most to global 
segment
CVE-2019-9358
• 看起来还不错……    Looks good ……
• 等一下，为什么我的PoC没有效果? 
Wait, why my PoC isn’t working?
• 通过更深入的阅读有关代码与除错，我发现Android系统限用了
自身的Felica模拟能力。或许出于法律问题角度考虑？
After some code reading/debugging, I found Android restricts its own FeliCa
emulation ability. Maybe for legal concerns? 
CVE-2019-9358
• System code定义了“service provider” 也就是服务
的种类
System code defines service provider, a.k.a. ‘type’ of this card
• Sony的规定: 
https://www.sony.net/Products/felica/business/tech-
support/index.html
CVE-2019-9358
NDEF check
read in num_services
without validation
out of bound write 480 
bytes at most to global
variable segment 