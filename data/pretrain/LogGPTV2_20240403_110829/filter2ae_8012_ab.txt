printf（“％i”，intvar）  
在上面，％i被称为格式说明符，它只是指定要打印的变量的格式。虽然有许多有用的格式说明符，例如％s，它指定字符串值（一般文本，即“hello”，“123”等等（只要是双引号（“”）中的文本））。但是，在这种情况下，对我们来说最重要的两个格式说明符是：  
％x - 十六进制值的格式说明符  
％n - 一种特殊格式说明符，它允许我们将实际的数据写入变量，而不是从变量中读取数据  
你们中的一些人可能知道我要说什么了，但让我们来看一个小例子：  
_Bob刚刚通过UHB注册了一些网上银行（代表UnHackable
Bank）当Bob进入UHB网站时，他看到了“输入你的账号”提示。当Bob输入他的账号时，银行会显示他的账户信息，他可以自由查看并转移他的钱。有一天，鲍勃登录了银行的网站，但当提示“输入你的账号”时，Bob意外的输入了错误的账号。网站没有提示“不正确的帐户”，而是进入了另一个客户的帐户，并能够查看并转移这个客户的钱。_  
能够显示任意信息是一个巨大的安全漏洞。如果能够显示和操纵任意信息则是一个灾难性的安全漏洞，而格式化字符串漏洞正是如此。  
如果用户能够直接将字符串输入到printf语句而不进行任何类型的检查，他们只需输入％x即可显示堆栈上的信息，因为正如我们从上一篇文章中所知，堆栈上存储了变量和其他数据。此外，如果恶意用户继续输入％x，最终可能会泄漏极其敏感的信息，例如异常处理程序指针（重定向进行处理错误的函数的内存地址），甚至是Stack
Canaries。  
此外，能够从内存中查看任意数据是一个大问题，但如果恶意用户具有对printf调用的完全访问权限，他们也可以使用％n这种格式说明符覆盖数据。这意味着恶意用户可以复制并使用自己想要的值覆盖Stack
Canaries，然后执行ret2libc攻击（在第一篇文章中讨论过）或覆盖函数返回指向其他恶意payload的指针。  
我们来看一个小例子：  
让我们将上图分解为几个部分。  
_请注意：在上面的示例中堆栈被删除了，并没有显示_  
首先看代码：  
首先，我们设置了两个字符串类型变量inputvar和stackvar 。  
接下来，我们通过readuserinput函数读取用户的输入，并将所述输入存储在inputvar变量中。然后，我们使用格式说明符为％s的printf语句并传入inputvar。  
上述代码中的漏洞源于用户能够无需检查格式说明符直接影响printf语句。  
现在，看看上面的整个攻击图。如您所见，当用户输入常规的，非格式说明符时，输入不会发生任何特殊情况。但是，当用户输入“
％x％x％x”时，程序输出堆栈的内容（请注意：％x以十六进制格式输出堆栈的内容。在此示例中，我只使用基本文本和数字，以便它更容易理解）。此外，如果用户使用％n来覆盖堆栈的cookie和返回指针，他/她将能够将程序重定向到恶意的payload。
# **0x04 - 攻击：SEH Overwrites**
与ret2libc攻击非常相似，SEH（结构化异常处理程序）Overwrites是覆盖指向不同函数指针的攻击。但是，虽然ret2libc攻击基于覆盖返回指针以将程序重定向到特定的libc函数，SEH
Overwrites通过覆盖异常处理程序指针函数，然后触发异常，以便程序重定向到我们恶意的payload。  
你可以想象SEH溢出类似保险欺诈：  
_Bob拥有一艘有大量保险单的船，保单的价值远远超过了这艘船本身。Bob作为罪犯，他决定试图通过燃气泄漏把船炸飞来欺骗保险公司，这样他就可以索赔保险金。经过几周的策划，Bob炸了他的船。经过一番调查后，保险公司无法明确证明Bob的船燃气泄漏但实际上没有爆炸，因此支付了索赔。_  
与Bob的保险欺诈非常相似，SEH
Overwrite攻击强制异常处理程序指向到恶意用户的payload，而不是正确的异常处理程序。这些攻击可以利用格式字符串漏洞或一般堆栈缓冲区溢出攻击来完成，因为异常处理程序指针也是存储在堆栈中的。要执行此漏洞，恶意代理需要覆盖异常处理程序指针以指向恶意payload，而不是实际的异常处理程序，然后用户需要触发异常。一旦捕获到该异常，它将被重定向到恶意函数，然后恶意函数可以丢弃异常并执行它的payload。  
# **0x05 - 防御：DEP/NX**
到目前为止，您可能已经意识到不受限制地访问堆栈是一件非常危险的事情。此外，即使Stack
Canaries充当防御，恶意用户也可以在格式字符串漏洞的帮助下轻松地重定向程序的执行，甚至可以轻松地将恶意函数和功能添加到程序中。然而，随着我们在这个系列的进展，你会很快发现虽然有很多攻击，但也有很多防御措施。在本节中，我们将谈论Data
Execution Prevention(DEP)和Non-Executable memory(NX)。  
能够联想到DEP和NX的好方法可能是原来的[点格棋](https://zh.wikipedia.org/wiki/%E9%BB%9E%E6%A0%BC%E6%A3%8B
"点格棋")游戏。  
在点和方框中，两个玩家以点网格开始。在每个回合中，玩家可以绘制一条连接两个点的线。两个玩家会用红色（玩家一）和绿色（玩家二）在点中着色，当画线使一个正方形封闭时，在区域内画一该玩家符号，表示占领。在游戏结束时，哪个玩家占领的区域大就会获胜。  
现在，想象一下你脑袋里的那个盒子（或者从wikihow看下面的图片）：  
我们假设每个正方形都是计算机上的内存区域，而不是点和框的网格。在红色区域是允许数据执行的，绿色区域则不允许数据执行。  
这正是DEP和NX的意思。它们只是阻止在不同的内存区域中执行写入内存操作（即恶意代码）的机制。例如，大多数现代程序在堆栈上启用了DEP，因此恶意用户无法通过堆栈执行payload。  
在理想的世界中，计算机可以在所有内存使用W^X(write xor
execute)策略，但是有几个很大的原因无法这样做。W^X策略是一种内存可以专门写入或可以独占执行的策略，但是不能两者同时进行。由于多种原因所有存储器中部分不能按照这个策略进行工作，这些将在以后的文章中介绍。但是对于某些内存区域例如堆栈，DEP和NX的使用让使用这个策略成为可能。
# **0x05 - 第2部分结论**
在本文中，我们讨论了：  
0×01.内核和特权环  
0x02.异常和结构化异常处理程序  
0x03.结构化异常处理程序覆盖攻击  
0x04.格式化字符串和printf命令  
0x05.格式字符串漏洞和利用  
0x06. DEP/NX  
我希望这篇文章很有帮助。请密切注意本系列的下一部分，我们将讨论更多的攻击和防御。  
如果您还没有开始阅读，请阅读本系列的第一篇文章：  
[白话二进制漏洞攻击方式第一部分](https://xz.aliyun.com/t/3980 "白话二进制漏洞攻击方式第一部分")