occurs at some point in the execution, it will never disappear
afterward. For instance in Figure 7, we have a memory leak
of 288 KB in the middle of execution which exists until the
end of execution. Fortunately, the amount of wasted memory
due to memory leaks is negligible in comparison with the total
program memory space, for all the benchmarks we tested.
Although memory leaks are not the major cause of memory
overhead in our experiments, they may be a serious problem
with long-running programs like server applications where
leaks can stack up indeﬁnitely over a long period of program
execution. One promising way to cope with the problem
is to integrate to CRCount a garbage collection mechanism
for reclaiming the leaked memory. Whenever the amount of
memory occupied by the undeleted objects exceeds certain
limit, we can scan the entire memory of a program and mark all
the objects that are referred to by pointers. At this time, all the
undeleted objects that have not been marked while scanning the
memory obviously correspond to the memory leaks. Now we
can reclaim the memory occupied by the identiﬁed memory
leaks by releasing forcibly. Since CRCount already has a
bitmap that pinpoints the pointers from the vast program
memory, the garbage collection can be performed more efﬁ-
ciently and accurately than conservative garbage collectors. We
have implemented a simple garbage collector to measure how
much performance overhead it incurs. The garbage collection
starts from the pointers in the stack, the global variables,
13
288050,000100,000150,000200,000250,000300,000350,000400,000450,000500,00041220283644526068768492100108116Memory(KB)Time(sec)all objectsundeleted objectsmemory leaksobject. In our experiments, CRCount-det could detect all the
UAF attempts we tested, which also implies that CRCount
would properly delay freeing of the object to prevent malicious
attempts utilizing the tested vulnerabilities.
B. Security considerations
One of the concerns about the security guarantee of CR-
Count is how effective a delayed-memory-reuse based mitiga-
tion is against UAF exploits. Recall that one key condition in
exploiting an UAF exploit is to locate an attacker-controlled
object into the freed memory region pointed to by dangling
pointers in order to arbitrarily control the results caused by
dangling pointer dereferences. However, in a victim process
that CRCount is applied, when an object is freed, no objects
are allocated until the reference count becomes zero. At this
point, the objects can be accessed only through the existing
links (pointers), maintaining their original semantics. Namely,
the attacker can no more implant any controllable object into
the freed memory region where dangling pointers still point to.
As a result, the attackers’ capabilities are limited to performing
the actions that are originally allowed for the object in the
program, unless the attackers use another kind of vulnerability.
This makes it impossible, or makes it signiﬁcantly complicated
at least, for the attackers to achieve their goal. It is noteworthy
that CRCount nulliﬁes any heap pointers inside the object
when the object is freed, so the attackers are further restricted
from reusing the heap pointer inside the object.
IX. LIMITATIONS
Custom Memory Allocator. While applying CRCount to
the benchmark programs, we encountered some cases (i.e.,
gcc in SPEC CPU2006 and freqmine in PARSEC) where
the program had to be patched in order for our technique
to work correctly. Speciﬁcally, the problem occurred mainly
due to the use of a custom memory allocator that internally
allocates objects from a reserved chunk of memory without
going through the expensive heap management functions. If
different types of objects are allocated to the same memory
region, the pointers that were stored in the previous object
can be overwritten by a non-pointer-type value in the newly
allocated object. Had CRCount been able to identify the
custom deallocator paired with the custom allocator, it would
insert a runtime library call to handle the pointers enclosed in a
freed region. Since it was not, we needed to manually identify
these custom memory deallocators and explicitly insert the
CRCount’s runtime library calls to update the pointer bitmap
and the reference counts. Speciﬁcally, we added 2 lines to
gcc and 1 line to freqmine to call crc_free upon custom
memory deallocation.
Unaligned Pointer. Another problem we met in the experi-
ments is that some of the programs stored pointers in 4-byte
aligned addresses, which is ﬁner than the assumed alignment
(i.e. 8-byte) in the pointer bitmap. Speciﬁcally, PARSEC’s
freqmine benchmark used a custom allocator that aligns
objects at a 4-byte boundary. We addressed this by modifying
the custom memory allocator to align objects at a 8-byte
boundary. Also, Apache web server used epoll_event
struct deﬁned with __attribute__((packed)), which
made the pointer inside the struct to be located at a 4-byte
boundary. We addressed this by wrapping the struct so that the
pointer is located with an 8-byte alignment. Note that CRCount
could just ignore the unaligned pointer store by not increasing
the reference count for the stored pointer. We chose to patch
the code for more complete protection. 12 lines were modiﬁed
in freqmine and 10 lines in apache to ensure pointers are
stored at aligned addresses.
Vectorization Support. Our prototype CRCount implemen-
tation currently does not support vectorization in LLVM IR.
DangSan also does not support vectorization—it simply ig-
nores the stores of vector types. Even though vector operations
rarely have to do with pointer values, as ignoring the vector
types could adversely affect reference counter management,
we instead turned off vectorization in all the experiments. It is
our future work to correctly deal with the vector types in our
analysis and instrumentations.
Limitations of Pointer Footprinting. There are cases where
our static analysis fails to determine whether a particular store
instruction should be instrumented or not. We perform only
intra-procedural backward data ﬂow analysis. Thus, if a pointer
is cast before being passed to a function, we cannot analyze
how the pointer is cast, and thus we may fail to correctly
decide whether to instrument
the store instruction or not.
However, since we used LLVM link-time optimization (LTO),
many functions are inlined to their caller, which enabled us to
get much information from the backward data ﬂow analysis.
Another problem regarding static analysis is that we cannot
track type unsafe pointer propagation through memory. For
example, a pointer could be cast to an integer, stored in some
integer ﬁeld of a struct
type variable, and passed around
the program through memory as an integer. The pointers
stored as an integer data in this process will not increase
the reference counts of their corresponding objects. This is a
common limitation faced by every approach based on pointer
tracking [36], [17], [40], [23], [24]. Like all the approaches
based on source code, we cannot
the libraries
distributed as a binary ﬁle. This can cause errors in reference
counter management if a pointer stored in the instrumented
program is killed in such uninstrumented binary libraries.
instrument
X. CONCLUSION
CRCount is our novel solution to cope with UAF errors in
legacy C/C++. For efﬁciency, CRCount employs the implicit
pointer invalidation scheme that avoids the runtime overhead
for explicit invalidation of dangling pointers by delaying the
freeing of an object until its reference count naturally reduces
to zero during program execution. The accuracy of reference
counting greatly inﬂuences the effectiveness of CRCount.
Therefore in our work, we have developed the pointer foot-
printing technique that helps CRCount to precisely track down
the location of every heap pointer along the execution paths
in the legacy C/C++ code with abusive uses of type unsafe
operations. CRCount
in handling
UAF errors in legacy C/C++. It
incurs 22% performance
overhead and 18% memory overhead on SPEC CPU2006 while
attaining virtually the same security guarantee as other pointer
invalidation solutions. In particular, CRCount has been more
effective for programs heavily using pointers than other solu-
tions. We claim that this is an important merit because UAF
vulnerabilities are more likely prevalent in those programs.
is effective and efﬁcient
14
ACKNOWLEDGMENT
by
supervised
funded by the Korea government(MSIT)
The authors would like to thank Lucas Davi
for
shepherding the paper. This work was partly supported
by MSIT(Ministry of Science and ICT), Korea, under the
support
ITRC(Information Technology Research Center)
program(IITP-2018-2015-0-00403)
the
IITP(Institute for Information & communications Technology
Promotion), the National Research Foundation of Korea(NRF)
grant
(NRF-
NRF-2018R1D1A1B07049870),
2017R1A2A1A17069478,
IITP grant
by
the Korea
government(MSIT)
(No.2016-0-00078, Cloud
Intelligence
Technology Development for the Customized Security Service
Provisioning; No.2018-0-00230, Development on Autonomous
Trust Enhancement Technology of IoT Device and Study on
Adaptive IoT Security Open Architecture based on Global
Standardization [TrusThingz Project]). The ICT at Seoul
National University provides research facilities for this study.
based
Security
funded
REFERENCES
[1] P. Akritidis, “Cling: A memory allocator to mitigate dangling pointers.”
in USENIX Security Symposium, 2010, pp. 177–192.
[2] A. Alexandrescu, Modern C++ design: generic programming and
design patterns applied. Addison-Wesley, 2001.
[3] E. D. Berger and B. G. Zorn, “Diehard: probabilistic memory safety
for unsafe languages,” in Acm sigplan notices, vol. 41, no. 6. ACM,
2006, pp. 158–168.
[4] C. Bienia, S. Kumar, J. P. Singh, and K. Li, “The parsec benchmark
suite: Characterization and architectural implications,” in Proceedings
of
the 17th international conference on Parallel architectures and
compilation techniques. ACM, 2008, pp. 72–81.
[5] H. Boehm, A. Demers, and M. Weiser, “A garbage collector for c and
c++,” 2002.
J. Caballero, G. Grieco, M. Marron, and A. Nappa, “Undangle: early
detection of dangling pointers in use-after-free and double-free vul-
nerabilities,” in Proceedings of the 2012 International Symposium on
Software Testing and Analysis. ACM, 2012, pp. 133–143.
[6]
[7] T. H. Dang, P. Maniatis, and D. Wagner, “Oscar: A practical page-
permissions-based scheme for thwarting dangling pointers,” in 26th
{USENIX} Security Symposium ({USENIX} Security 17), 2017, pp.
815–832.
[8] M. Daniel, J. Honoroff, and C. Miller, “Engineering heap overﬂow
exploits with javascript.” WOOT, vol. 8, pp. 1–6, 2008.
[11]
[9] D. Gay, R. Ennals, and E. Brewer, “Safe manual memory manage-
ment,” in Proceedings of the 6th international symposium on Memory
management. ACM, 2007, pp. 2–14.
[10] S. Ghemawat and P. Menage, “Tcmalloc: Thread-caching malloc, 2007,”
URL {http://goog-perftools. sourceforge. net/doc/tcmalloc. html}, 2005.
I. Haller, E. Van Der Kouwe, C. Giuffrida, and H. Bos, “Metalloc: Ef-
ﬁcient and comprehensive metadata management for software security
hardening,” in Proceedings of the 9th European Workshop on System
Security. ACM, 2016, p. 5.
J. L. Henning, “Spec cpu2006 benchmark descriptions,” ACM
SIGARCH Computer Architecture News, vol. 34, no. 4, pp. 1–17, 2006.
[13] M. Hertz and E. D. Berger, “Quantifying the performance of garbage
collection vs. explicit memory management,” in ACM SIGPLAN No-
tices, vol. 40, no. 10. ACM, 2005, pp. 313–326.
[12]
[14] M. Hirzel and A. Diwan, “On the type accuracy of garbage collection,”
ACM SIGPLAN Notices, vol. 36, no. 1, pp. 1–11, 2001.
[15] K. Koning, X. Chen, H. Bos, C. Giuffrida, and E. Athanasopoulos,
“No need to hide: Protecting safe regions on commodity hardware,” in
Proceedings of the Twelfth European Conference on Computer Systems.
ACM, 2017, pp. 437–452.
[16] P. Larsen, A. Homescu, S. Brunthaler, and M. Franz, “Sok: Automated
software diversity,” in 2014 IEEE Symposium on Security and Privacy
(SP).
IEEE, 2014, pp. 276–291.
15
[17] B. Lee, C. Song, Y. Jang, T. Wang, T. Kim, L. Lu, and W. Lee, “Pre-
venting use-after-free with dangling pointers nulliﬁcation.” in NDSS,
2015.
[18] K. Lee, “Memory management,” in Pro Objective-C. Springer, 2013,
pp. 53–74.
[19] A. Mazzinghi, R. Sohan, and R. N. Watson, “Pointer provenance in a
capability architecture,” in 10th {USENIX} Workshop on the Theory
and Practice of Provenance (TaPP 2018), 2018.
[20] S. Nagaraju, C. Craioveanu, E. Florio, and M. Miller, “Software
vulnerability exploitation trends,” Microsoft Corporation, 2013.
[21] S. Nagarakatte, M. M. Martin, and S. Zdancewic, “Watchdog: Hardware
for safe and secure manual memory management and full memory
safety,” in ACM SIGARCH Computer Architecture News, vol. 40, no. 3.
IEEE Computer Society, 2012, pp. 189–200.
[22] ——, “Watchdoglite: Hardware-accelerated compiler-based pointer
checking,” in Proceedings of Annual IEEE/ACM International Sympo-
sium on Code Generation and Optimization. ACM, 2014, p. 175.
[23] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic, “Softbound:
Highly compatible and complete spatial memory safety for c,” ACM
Sigplan Notices, vol. 44, no. 6, pp. 245–258, 2009.
[24] ——, “Cets: compiler enforced temporal safety for c,” in ACM Sigplan
Notices, vol. 45, no. 8. ACM, 2010, pp. 31–40.
[25] N. Nethercote and J. Seward, “How to shadow every byte of memory
used by a program,” in Proceedings of the 3rd international conference
on Virtual execution environments. ACM, 2007, pp. 65–74.
J. Newsome and D. X. Song, “Dynamic taint analysis for automatic
detection, analysis, and signaturegeneration of exploits on commodity
software.” in NDSS, vol. 5. Citeseer, 2005, pp. 3–4.
[26]
[27] G. V. Nishanov and S. Schupp, “Garbage collection in generic libraries,”
ACM SIGPLAN Notices, vol. 34, no. 3, pp. 86–96, 1999.
[28] G. Novark and E. D. Berger, “Dieharder: securing the heap,” in Pro-
ceedings of the 17th ACM conference on Computer and communications
security. ACM, 2010, pp. 573–584.
[29] M. Olsson, “Smart pointers,” in C++ 17 Quick Syntax Reference.
Springer, 2018, pp. 157–160.
J. Rafkind, A. Wick, J. Regehr, and M. Flatt, “Precise garbage collection
for c,” in Proceedings of the 2009 international symposium on Memory
management. ACM, 2009, pp. 39–48.
[30]
[31] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov, “Address-
sanitizer: A fast address sanity checker.” in USENIX Annual Technical
Conference, 2012, pp. 309–318.
[32] S. Silvestro, H. Liu, C. Crosser, Z. Lin, and T. Liu, “Freeguard: A
faster secure heap allocator,” in Proceedings of the 2017 ACM SIGSAC
Conference on Computer and Communications Security. ACM, 2017,
pp. 2389–2403.
[33] M. S. Simpson and R. K. Barua, “Memsafe: ensuring the spatial and
temporal memory safety of c at runtime,” Software: Practice and
Experience, vol. 43, no. 1, pp. 93–128, 2013.
[34] P. Sobalvarro, “A lifetime-based garbage collector for lisp systems
on general-purpose computers.” MASSACHUSETTS INST OF TECH
CAMBRIDGE ARTIFICIAL INTELLIGENCE LAB, Tech. Rep., 1988.
[35] A. Sotirov, “Heap feng shui in javascript,” Black Hat Europe, 2007.
[36] E. van der Kouwe, V. Nigade, and C. Giuffrida, “Dangsan: Scalable use-
after-free detection,” in Proceedings of the Twelfth European Conference
on Computer Systems. ACM, 2017, pp. 405–419.
[37] P. R. Wilson, “Uniprocessor garbage collection techniques,” in Memory
Management. Springer, 1992, pp. 1–42.
[38] W. Xu, J. Li, J. Shu, W. Yang, T. Xie, Y. Zhang, and D. Gu, “From
collision to exploitation: Unleashing use-after-free vulnerabilities in
linux kernel,” in Proceedings of the 22nd ACM SIGSAC Conference
on Computer and Communications Security. ACM, 2015, pp. 414–
425.
[39] T. Yamauchi and Y. Ikegami, “Heaprevolver: Delaying and randomizing
timing of release of freed memory area to prevent use-after-free attacks,”
in International Conference on Network and System Security. Springer,
2016, pp. 219–234.
[40] Y. Younan, “Freesentry: protecting against use-after-free vulnerabilities
due to dangling pointers.” in NDSS, 2015.