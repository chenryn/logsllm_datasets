---
author: Alex Chadwick
category: 树莓派
comments_data: []
count:
  commentnum: 0
  favtimes: 0
  likes: 0
  sharetimes: 0
  viewnum: 5639
date: '2019-03-10 20:59:01'
editorchoice: false
excerpt: 屏幕04 课程基于屏幕03 课程来构建，它教你如何操作文本。
fromurl: https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen04.html
id: 10605
islctt: true
largepic: /data/attachment/album/201903/10/205749u4a13q8agzb58auz.jpg
permalink: /article-10605-1.html
pic: /data/attachment/album/201903/10/205749u4a13q8agzb58auz.jpg.thumb.jpg
related:
- displayorder: 0
  raid: 10585
- displayorder: 0
  raid: 10676
reviewer: wxy
selector: lujun9972
summary: 屏幕04 课程基于屏幕03 课程来构建，它教你如何操作文本。
tags:
- 树莓派
thumb: false
title: 计算机实验室之树莓派：课程 9 屏幕04
titlepic: true
translator: qhwdw
updated: '2019-03-10 20:59:01'
---
![](/data/attachment/album/201903/10/205749u4a13q8agzb58auz.jpg)
屏幕04 课程基于屏幕03 课程来构建，它教你如何操作文本。假设你已经有了[课程 8：屏幕03](/article-10585-1.html) 的操作系统代码，我们将以它为基础。
### 1、操作字符串
能够绘制文本是极好的，但不幸的是，现在你只能绘制预先准备好的字符串。如果能够像命令行那样显示任何东西才是完美的，而理想情况下应该是，我们能够显示任何我们期望的东西。一如既往地，如果我们付出努力而写出一个非常好的函数，它能够操作我们所希望的所有字符串，而作为回报，这将使我们以后写代码更容易。曾经如此复杂的函数，在 C 语言编程中只不过是一个 `sprintf` 而已。这个函数基于给定的另一个字符串和作为描述的额外的一个参数而生成一个字符串。我们对这个函数感兴趣的地方是，这个函数是个变长函数。这意味着它可以带可变数量的参数。参数的数量取决于具体的格式字符串，因此它的参数的数量不能预先确定。
> 
> 变长函数在汇编代码中看起来似乎不好理解，然而 ，它却是非常有用和很强大的概念。
> 
> 
> 
这个完整的函数有许多选项，而我们在这里只列出了几个。在本教程中将要实现的选项我做了高亮处理，当然，你可以尝试去实现更多的选项。
函数通过读取格式化字符串来工作，然后使用下表的意思去解释它。一旦一个参数已经使用了，就不会再次考虑它了。函数的返回值是写入的字符数。如果方法失败，将返回一个负数。
表 1.1 sprintf 格式化规则
| 选项 | 含义 |
| --- | --- |
| 除了 `%` 之外的任何支付 | 复制字符到输出。 |
| `%%` | 写一个 % 字符到输出。 |
| `%c` | 将下一个参数写成字符格式。 |
| `%d` 或 `%i` | 将下一个参数写成十进制的有符号整数。 |
| `%e` | 将下一个参数写成科学记数法，使用 eN，意思是 ×10 N。 |
| `%E` | 将下一个参数写成科学记数法，使用 EN，意思是 ×10 N。 |
| `%f` | 将下一个参数写成十进制的 IEEE 754 浮点数。 |
| `%g` | 与 `%e` 和 `%f` 的指数表示形式相同。 |
| `%G` | 与 `%E` 和 `%f` 的指数表示形式相同。 |
| `%o` | 将下一个参数写成八进制的无符号整数。 |
| `%s` | 下一个参数如果是一个指针，将它写成空终止符字符串。 |
| `%u` | 将下一个参数写成十进制无符号整数。 |
| `%x` | 将下一个参数写成十六进制无符号整数（使用小写的 a、b、c、d、e 和 f）。 |
| `%X` | 将下一个参数写成十六进制的无符号整数（使用大写的 A、B、C、D、E 和 F）。 |
| `%p` | 将下一个参数写成指针地址。 |
| `%n` | 什么也不输出。而是复制到目前为止被下一个参数在本地处理的字符个数。 |
除此之外，对序列还有许多额外的处理，比如指定最小长度，符号等等。更多信息可以在 [sprintf - C++ 参考](http://www.cplusplus.com/reference/clibrary/cstdio/sprintf/) 上找到。
下面是调用方法和返回的结果的示例。
表 1.2 sprintf 调用示例
| 格式化字符串 | 参数 | 结果 |
| --- | --- | --- |
| `"%d"` | 13 | 13 |
| `"+%d degrees"` | 12 | +12 degrees |
| `"+%x degrees"` | 24 | +1c degrees |
| `"'%c' = 0%o"` | 65, 65 | ‘A’ = 0101 |
| `"%d * %d%% = %d"` | 200, 40, 80 | 200 \* 40% = 80 |
| `"+%d degrees"` | -5 | +-5 degrees |
| `"+%u degrees"` | -5 | +4294967291 degrees |
希望你已经看到了这个函数是多么有用。实现它需要大量的编程工作，但给我们的回报却是一个非常有用的函数，可以用于各种用途。
### 2、除法
虽然这个函数看起来很强大、也很复杂。但是，处理它的许多情况的最容易的方式可能是，编写一个函数去处理一些非常常见的任务。它是个非常有用的函数，可以为任何底的一个有符号或无符号的数字生成一个字符串。那么，我们如何去实现呢？在继续阅读之前，尝试快速地设计一个算法。
> 
> 除法是非常慢的，也是非常复杂的基础数学运算。它在 ARM 汇编代码中不能直接实现，因为如果直接实现的话，它得出答案需要花费很长的时间，因此它不是个“简单的”运算。
> 
> 
> 
最简单的方法或许就是我在 [课程 1：OK01](/article-10458-1.html) 中提到的“除法余数法”。它的思路如下：
1. 用当前值除以你使用的底。
2. 保存余数。
3. 如果得到的新值不为 0，转到第 1 步。
4. 将余数反序连起来就是答案。
例如：
表 2.1 以 2 为底的例子
转换
| 值 | 新值 | 余数 |
| --- | --- | --- |
| 137 | 68 | 1 |
| 68 | 34 | 0 |
| 34 | 17 | 0 |
| 17 | 8 | 1 |
| 8 | 4 | 0 |
| 4 | 2 | 0 |
| 2 | 1 | 0 |
| 1 | 0 | 1 |
因此答案是 10001001 2
这个过程的不幸之外在于使用了除法。所以，我们必须首先要考虑二进制中的除法。
我们复习一下长除法
> 
> 假如我们想把 4135 除以 17。
> 
> 
> 
> ```
>    0243 r 4
> 17)4135
>    0        0 × 17 = 0000
>    4135     4135 - 0 = 4135
>    34       200 × 17 = 3400
>    735      4135 - 3400 = 735
>    68       40 × 17 = 680
>    55       735 - 680 = 55
>    51       3 × 17 = 51
>    4        55 - 51 = 4
> ```
> 
> 答案：243 余 4
> 
> 
> 首先我们来看被除数的最高位。我们看到它是小于或等于除数的最小倍数，因此它是 0。我们在结果中写一个 0。
> 
> 
> 接下来我们看被除数倒数第二位和所有的高位。我们看到小于或等于那个数的除数的最小倍数是 34。我们在结果中写一个 2，和减去 3400。
> 
> 
> 接下来我们看被除数的第三位和所有高位。我们看到小于或等于那个数的除数的最小倍数是 68。我们在结果中写一个 4，和减去 680。
> 
> 
> 最后，我们看一下所有的余位。我们看到小于余数的除数的最小倍数是 51。我们在结果中写一个 3，减去 51。减法的结果就是我们的余数。
> 
> 
> 
在汇编代码中做除法，我们将实现二进制的长除法。我们之所以实现它是因为，数字都是以二进制方式保存的，这让我们很容易地访问所有重要位的移位操作，并且因为在二进制中做除法比在其它高进制中做除法都要简单，因为它的数更少。
```
        1011 r 1
1010)1101111
     1010
      11111
      1010
       1011
       1010
          1
```
这个示例展示了如何做二进制的长除法。简单来说就是，在不超出被除数的情况下，尽可能将除数右移，根据位置输出一个 1，和减去这个数。剩下的就是余数。在这个例子中，我们展示了 1101111 2 ÷ 1010 2 = 1011 2 余数为 1 2。用十进制表示就是，111 ÷ 10 = 11 余 1。
你自己尝试去实现这个长除法。你应该去写一个函数 `DivideU32` ，其中 `r0` 是被除数，而 `r1` 是除数，在 `r0` 中返回结果，在 `r1` 中返回余数。下面，我们将完成一个有效的实现。
```
function DivideU32(r0 is dividend, r1 is divisor)
  set shift to 31
  set result to 0
  while shift ≥ 0
     if dividend ≥ (divisor  计数前导零   count leading zeros ）的指令，它能计算一个二进制表示的数字的前导零的个数。这样我们就可以在溢出发生之前，可以将寄存器中的值进行相应位数的左移。你可以找出的另一个优化就是，每个循环我们计算 `divisor  
> `clz dest,src` 将第一个寄存器 `dest` 中二进制表示的值的前导零的数量，保存到第二个寄存器 `src` 中。
> 
> 
> 
```
.globl DivideU32
DivideU32:
result .req r0
remainder .req r1
shift .req r2
current .req r3
clz shift,r1
clz r3,r0
subs shift,r3
lsl current,r1,shift
mov remainder,r0
mov result,#0
blt divideU32Return$
divideU32Loop$:
  cmp remainder,current
  blt divideU32LoopContinue$
  add result,result,#1
  subs remainder,current
  lsleq result,shift
  beq divideU32Return$
divideU32LoopContinue$:
  subs shift,#1
  lsrge current,#1