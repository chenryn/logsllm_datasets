# 表1：不同攻击面识别和漏洞发现方法的运行时影响

| 应用程序 | PrinterControl | ImageSuite | GameServer | IndDesign |
| --- | --- | --- | --- | --- |
| 加载的DLL数量 | 104 | 165 | 59 | 289 |
| 污染的DLL数量 | 30 | 33 | 18 | 55 |
| 唯一执行指令数 | 712,134 | 603,922 | 242,671 | 2,811,259 |
| 唯一污染指令数 | 5,908 | 25,263 | 12,575 | 94,598 |

# 表2：实际加载的DLL与执行指令 vs. 受攻击者输入影响的DLL与指令

```c
int res;
size_t next_read;
char buf[12];
...
res = read_data(&buf, 12);
if (!res)
    return;
...
next_read = get_size(buf + 6);
res = read_data(&buf, next_read);
...
```

## 图3：PrinterControl远程溢出漏洞

```c
int process_segment(char *data, size_t data_sz) {
    size_t decompressed_sz = *(size_t*) data;
    if (decompressed_sz > 0x1000)
        return -1;
    
    char *decompressed_data = malloc(decompressed_sz);
    decompress(data, data_sz, decompressed_data, decompressed_sz);
}
```

```c
void decompress(char *compressed_data, size_t compressed_sz, char *decompressed_data, size_t decompressed_sz) {
    char *cur_byte = compressed_data;
    size_t copy_counter = 0;
    while (*cur_byte++ == CONSTANT1)
        copy_counter += CONSTANT2;
    
    while (copy_counter > 0) {
        expand_data(cur_byte, &decompressed_data);
        cur_byte++;
        copy_counter--;
    }
}
```

## 图4：IndDesign堆溢出漏洞

PINNACLE通过提供查找方向和数据流信息，简化了识别过程和调用函数的工作。我们还发现，PINNACLE使验证Net.dll!Read的非漏洞使用变得更加容易。通过在IDA中高亮显示相关代码，减少了每个案例所需的时间，从而可以处理更多有趣的案例。

### 4.2.2 IndDesign中的堆溢出漏洞

IndDesign应用程序使用了一种需要大量处理才能解压和解析的压缩文件格式。利用PINNACLE，我们能够快速定位解压缩算法，并发现相关函数中的堆溢出漏洞。此漏洞的影响是，打开攻击者提供的设计文件可能导致任意代码执行。

该文件格式由多个段组成，并包含一个表，提供每个段的大小和校验和。我们通过搜索基于该表中的校验和的条件语句，识别了负责完整性检查和解压缩的函数。由于PINNACLE提供了每个被处理的污染字节在文件中的索引，这种搜索可以通过一个小脚本自动化。完整性检查后立即进行解压缩。

...

```c
recv_len = recvfrom(s, buf, len, flags, from, fromlen);
...
computed = compute_checksum(buf, recv_len);
sent = (*(char*)(buf + recv_len - 2)) << 8 | (*(char*)(buf + recv_len - 1));
if (computed != sent)
    checksum_err();
...
```

## 图5：GameServer中未检查的返回值使用

对malloc函数的污染参数发出的警报将我们的注意力引向图4所示的process_segment函数。通过检查数据流信息，我们可以看到decompressed_sz是一个32位字段，来自攻击者提供的文件。它的范围限制在0到0x1000之间，并根据这些信息分配了一个缓冲区来存储解压缩的数据。

通过在IDA中跟踪decompress调用，我们可以看到第一个while循环基于与攻击者提供的数据的比较而受到限制。通过控制输入字节等于CONSTANT1，我们可以操纵copy_counter持有远大于0x1000的值。调用expand_data的循环则使用copy_counter变量而不是decompressed_sz作为边界。在这种情况下，复制循环没有使用相同的攻击者控制的值来限制目标缓冲区的大小，这是显而易见的。

通过检查expand_data，我们可以立即看出，基于数据流信息，它要么直接将攻击者控制的字节复制到输出缓冲区，要么将其解压缩为更长的序列。最终结果是我们可以操纵解压缩算法，以可控的数据量溢出decompressed_data堆缓冲区。即使没有完整的跟踪信息，PINNACLE也使得追踪此类问题并理解周围代码的过程比仅使用调试器、反汇编器和覆盖率信息更容易。

### 4.2.3 GameServer中未检查的recvfrom返回值使用

GameServer应用程序展示了当使用间接污染时，很快就能发现的一个漏洞。GameServer的主要处理循环首先从套接字读取数据，然后计算该数据的校验和，并将其与接收数据的最后两个字节中的值进行比较。

图5显示了此初始函数的伪代码。在此函数执行期间，读入buf的数据将被标记为直接污染，而recv_len的值将被标记为间接污染。在计算sent变量的值时，如果启用了基于内存读/写操作的警报，PINNACLE会创建一个警报。处理并加载到IDA中的警报将被赋予高优先级，因为攻击者间接控制的值未经检查地用于内存引用。如果攻击者向服务器提供长度为0或1的数据，则计算sent将访问buf缓冲区之前的2个或1个字节。此缺陷不会导致恶意代码执行，但在某些情况下，如果buf位于页面边界的附近且前一页未映射，则可能导致拒绝服务状况。

尽管此缺陷本身并不严重，但这个例子说明了确保我们全面记录和跟踪攻击者的间接影响的重要性。

## 5. 结论

理解软件，尤其是二进制形式的软件，既耗时又困难。然而，这也是解决各种问题的必要要求。本文介绍了旨在提高逆向工程师工作流程效率的攻击面发现和漏洞检测技术。我们的结果表明，自动解决部分问题并在使用数据时依赖人类的创造力和决策是有用的。

还有很多工作要做，包括如何最有效地向用户呈现自动化分析的结果，以及如何最好地提取他们的领域特定知识并将其与自动生成的模型集成。我们认为，在开发建模技术的同时，也需要解决这些问题的可用性和工作流程集成。

除了所展示的数据用途外，我们还设想它可以在指导自动化动态和静态测试算法方面发挥作用。路径和代码区域优先级化是大多数分析方法下的挑战，优先处理已知受攻击者影响的代码是有意义的。此外，这些数据可能允许从代码的更深处开始分析，而不必从文件或套接字访问等通用影响点开始。

## 6. 参考文献

[略]

---

优化后的文本更加清晰、连贯和专业，结构更加合理，便于读者理解和参考。