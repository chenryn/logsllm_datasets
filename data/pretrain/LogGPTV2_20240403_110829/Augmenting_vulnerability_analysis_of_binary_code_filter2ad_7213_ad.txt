Table 1: Runtime impact of various approaches to attack surface identiﬁcation and vulnerability discovery
Application
PrinterControl
ImageSuite
GameServer
IndDesign
30
33
18
55
# Loaded DLLs # Tainted DLLs # Unique Exec. Instrs. # Unique Tainted Instrs.
104
165
59
289
712134
603922
242671
2811259
5908
25263
12575
94598
Table 2: Actual loaded DLLs and executed instructions versus those inﬂuenced by attacker input
int res;
size_t next_read;
char buf[12];
...
res = read_data(&buf, 12);
if (!res)
return;
...
next_read = get_size(buf + 6);
res = read_data(&buf, next_read);
...
int process_segment(char *data, size_t data_sz)
{
size_t decompressed_sz = *(size_t*) data;
if (decompressed_sz > 0x1000)
return -1;
Figure 3: PrinterControl remote overﬂow vulnera-
bility
char *decompressed_data = malloc(decompressed_sz);
decompress(data, data_sz, decompressed_data,
decompressed_sz);
}
void decompress(char *compressed_data,
size_t compressed_sz,
char *decompressed_data,
size_t decompressed_sz)
{
char *cur_byte = compressed_data;
size_t copy_counter = 0;
while (*cur_byte++ == CONSTANT1)
copy_counter += CONSTANT2;
while (copy_counter > 0) {
expand_data(cur_byte, &decompressed_data);
cur_byte++;
copy_counter--;
}
}
Figure 4: IndDesign heap overﬂow vulnerability
tiﬁed and the work performed by the called functions is ﬁg-
ured out. PINNACLE makes both of these processes easier by
providing direction on where to look and data ﬂow informa-
tion that can give intuition as to the sources and sinks for
tainted data. We also found that PINNACLE made it easier
to verify the non-vulnerable uses of Net.dll!Read. By high-
lighting the relevant code in IDA less time needed to be spent
on each case and thus we could move on to more interesting
cases.
4.2.2 Heap Overﬂow in IndDesign
The IndDesign application uses a compressed ﬁle format
that requires extensive processing to decompress and parse.
Using PINNACLE we were able to quickly locate the decom-
pression algorithms and then discover a heap overﬂow in a
related function. The impact of this bug is that opening an
attacker provided design can lead to arbitrary code execu-
tion.
The ﬁle format used consists of multiple segments and
a table that provides a size and checksum for each seg-
ment. We identiﬁed the functions responsible for the in-
tegrity checks and decompression by searching the tainted
instructions for conditionals based on the checksums located
in this table. As PINNACLE provides the index into the ﬁle of
each tainted byte processed by each instruction, this search
can be automated using a small script. Immediately after
the integrity checks the decompression takes place.
206
...
recv_len = recvfrom(s, buf, len, flags, from,
fromlen);
...
computed = compute_checksum(buf, recv_len);
sent = (*(char*)(buf + recv_len - 2)) << 8 |
(*(char*)(buf + recv_len - 1))
if (computed != sent)
checksum_err();
...
Figure 5: GameServer unchecked return value usage
An alert on a tainted argument to the malloc function
directs our attention towards the process_segment function
shown in Figure 4. By inspecting the data ﬂow information
we can see that decompressed_sz is a 32-bit ﬁeld, taken from
the attacker provided ﬁle. Its range is restricted to values
between 0 and 0x1000 and a buﬀer is allocated to store the
decompressed data based on this information.
By following the decompress call in IDA we can see, via
the taint information, that the ﬁrst while loop is bounded
based on comparisons with attacker provided data. By con-
trolling the input bytes to equal CONSTANT1 we can manip-
ulate copy_counter to hold values far larger than 0x1000.
The loop calling expand_data is then bounded using the
copy_counter variable instead of decompressed_sz. In this
case it is the fact that the copy loop is not bounded by the
same attacker controlled value used to allocate the destina-
tion buﬀer that is conspicuous.
By inspecting expand_data we can immediately tell, based
on the data ﬂow information, that it either copies attacker
controlled bytes directly to the output buﬀer or decom-
presses them into a longer sequence. The end result of this
is that we can manipulate the decompression algorithm to
overﬂow the decompressed_data heap buﬀer with a control-
lable amount of data. Even with out the full tracing informa-
tion available PINNACLE makes the process of tracking down
such issues and understanding the surrounding code much
easier than doing so using just a debugger, disassembler and
coverage information.
4.2.3 Unchecked Use of recvfrom Return Value in Game-
Server
The GameServer application serves as a useful demonstra-
tion of a bug that is quickly uncovered when indirect tainting
is used. The main processing loop of GameServer begins by
reading data from a socket, then computes a checksum of
this data and compares it against a value stored in the last
two bytes of the received data.
Figure 5 shows pseudo-code for this initial function. Upon
execution of this function the data read into buf will be
marked as directly tainted while the value in recv_len will
be marked as indirectly tainted. On the computation of the
value of the sent variable PINNACLE creates an alert, if mem-
ory read/write based alerts are enabled. When the alerts
are processed and loaded into IDA this will be assigned a
high priority as a value indirectly controlled by an attacker
is used, unchecked, in a memory dereference. If an attacker
provides data of length 0 or 1 to the server the computation
of sent will access 2 or 1 bytes before the buf buﬀer. This
ﬂaw will not result in malicious code execution but under
certain circumstances could lead to a denial-of-service con-
dition if buf is located within a byte of a page boundary and
the previous page is unmapped.
While the ﬂaw itself is not serious this example provides
motivation for ensuring we are thorough in noting and track-
ing indirect sources of attacker inﬂuence.
5. CONCLUSION
Understanding software, especially software in binary form,
can be both time consuming and diﬃcult. However, it is
also a necessary requirement in order to solve a diverse set
of problems.
In this paper we have presented techniques
for attack surface discovery and vulnerability detection that
are designed to increase eﬃciency in the work ﬂow of a re-
verse engineer. Our results demonstrate the usefulness of
attempting to solve just enough of a problem automatically,
while relying on a human for creativity and decisions in the
use of that data.
Much remains to be done in discovering the most eﬀec-
tive ways to present users with the results of automated
analysis and, likewise, on how best to extract their domain
speciﬁc knowledge and integrate it with automatically gen-
erated models. We believe that in tandem with the develop-
ment of modeling techniques it is also important to address
these issues of usability and work ﬂow integration.
Alongside the presented use of the data gathered, we also
envisage it being beneﬁcial in providing guidance to auto-
mated dynamic and static testing algorithms. Path and code
region prioritisation is a challenge under most analysis ap-
proaches and it makes sense to prioritize code that is known
to be subject to attacker inﬂuence. Furthermore, this data
may allow one to begin analysis deeper in the code than
necessarily starting from generic points of inﬂuence, such as
ﬁle or socket access.
6. REFERENCES
[1] T. Avgerinos, S. K. Cha, B. L. T. Hao, and
D. Brumley. Aeg: Automatic exploit generation. In
Network and Distributed System Security Symposium,
pages 283–300, Feb. 2011.
[2] D. Blazakis. Diﬀerential reversing (or some better
name). http://dion.t-rexin.org/notes/2009/09/
29/differential-reversing/, 2009.
[3] D. Brumley, I. Jager, T. Avgerinos, and E. J.
Schwartz. Bap: a binary analysis platform. In
Proceedings of the 23rd international conference on
Computer aided veriﬁcation, CAV’11, pages 463–469,
Berlin, Heidelberg, 2011. Springer-Verlag.
[4] D. Brumley, P. Poosankam, D. Song, and J. Zheng.
Automatic patch-based exploit generation is possible:
Techniques and implications. In Proceedings of the
2008 IEEE Symposium on Security and Privacy, SP
’08, pages 143–157, Washington, DC, USA, 2008.
IEEE Computer Society.
[5] J. Caballero, H. Yin, Z. Liang, and D. Song. Polyglot:
automatic extraction of protocol message format using
dynamic binary analysis. In Proceedings of the 14th
ACM conference on Computer and communications
207
security, CCS ’07, pages 317–329, New York, NY,
USA, 2007. ACM.
[6] C. Cadar, D. Dunbar, and D. Engler. Klee: unassisted
and automatic generation of high-coverage tests for
complex systems programs. In Proceedings of the 8th
USENIX conference on Operating systems design and
implementation, OSDI’08, pages 209–224, Berkeley,
CA, USA, 2008. USENIX Association.
[7] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and
D. R. Engler. Exe: Automatically generating inputs of
death. ACM Trans. Inf. Syst. Secur., 12(2), 2008.
[8] V. Chipounov and G. Candea. Reverse engineering of
binary device drivers with revnic. In EuroSys, pages
167–180, 2010.
byte of memory used by a program. In Proceedings of
the 3rd international conference on Virtual execution
environments, VEE ’07, pages 65–74, New York, NY,
USA, 2007. ACM.
[21] A. Slowinska, T. Stancescu, and H. Bos. Howard: A
dynamic excavator for reverse engineering data
structures. In NDSS, 2011.
[22] D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager,
M. G. Kang, Z. Liang, J. Newsome, P. Poosankam,
and P. Saxena. BitBlaze: A new approach to
computer security via binary analysis. In Proceedings
of the 4th International Conference on Information
Systems Security. Keynote invited paper., Hyderabad,
India, Dec. 2008.
[9] V. Chipounov, V. Kuznetsov, and G. Candea. The s2e
[23] Zynamics. BinNavi.
http://www.zynamics.com/binnavi.html, 2010.
platform: Design, implementation, and applications.
ACM Trans. Comput. Syst., 30(1):2, 2012.
[10] D. Duran, M. Miller, and D. Weston. Security defect
metrics for targeted fuzzing. In CanSecWest,
Vancouver, Canada, Mar. 2011.
[11] P. Godefroid, N. Klarlund, and K. Sen. Dart: directed
automated random testing. In Proceedings of the 2005
ACM SIGPLAN conference on Programming language
design and implementation, PLDI ’05, pages 213–223,
New York, NY, USA, 2005. ACM.
[12] P. Godefroid, M. Y. Levin, and D. Molnar. Sage:
Whitebox fuzzing for security testing. Queue,
10(1):20:20–20:27, Jan. 2012.
[13] S. Heelan. Automatic generation of control ﬂow
hijacking exploits for software vulnerabilities. Msc.
dissertation, University of Oxford, September 2009.
[14] Hex-Rays. IDA. http:
//www.hex-rays.com/products/ida/index.shtml,
2005.
[15] M. G. Kang, S. McCamant, P. Poosankam, and
D. Song. DTA++: Dynamic taint analysis with
targeted control-ﬂow propagation. In Proceedings of
the 18th Annual Network and Distributed System
Security Symposium, San Diego, CA, Feb. 2011.
[16] J. Koret. MyNav, A Python plugin for IDA Pro.
http://joxeankoret.com/blog/2010/05/02/
mynav-a-python-plugin-for-ida-pro/, May 2010.
[17] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,
G. Lowney, S. Wallace, V. J. Reddi, and
K. Hazelwood. Pin: building customized program
analysis tools with dynamic instrumentation. In
Proceedings of the 2005 ACM SIGPLAN conference
on Programming language design and implementation,
PLDI ’05, pages 190–200, New York, NY, USA, 2005.
ACM.
[18] L. Martignoni, S. McCamant, P. Poosankam, D. Song,
and P. Maniatis. Path-exploration lifting: Hi-ﬁ tests
for lo-ﬁ emulators. In Proceedings of the 17th
International Conference on Architectural Support for
Programming Languages and Operating Systems
(ASPLOS), London, UK, Mar. 2012.
[19] D. Molnar, X. C. Li, and D. A. Wagner. Dynamic test
generation to ﬁnd integer bugs in x86 binary linux
programs. In Proceedings of the 18th conference on
USENIX security symposium, SSYM’09, pages 67–82,
Berkeley, CA, USA, 2009. USENIX Association.
[20] N. Nethercote and J. Seward. How to shadow every
208