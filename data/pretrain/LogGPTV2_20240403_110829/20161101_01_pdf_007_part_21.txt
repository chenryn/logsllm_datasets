 Time: 48.680 ms
指定表的关联顺序配置参数
 digoal=# explain select t1.info, t5.info from
 tbl_join_1 t1 join tbl_join_2 t2 on (t1.id=t2.id)
 join tbl_join_3 t3 on (t2.id=t3.id)
 join tbl_join_4 t4 on (t3.id=t4.id)
 join tbl_join_5 t5 on (t4.id=t5.id)
 join tbl_join_6 t6 on (t5.id=t6.id)
 join tbl_join_7 t7 on (t6.id=t7.id)
 join tbl_join_8 t8 on (t7.id=t8.id)
 join tbl_join_9 t9 on (t8.id=t9.id)
 where t9.id=10000;
 QUERY PLAN
 --------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop (cost=2.35..68.82 rows=1 width=65)
 -> Nested Loop (cost=1.92..60.36 rows=1 width=69)
 -> Nested Loop (cost=1.49..51.90 rows=1 width=69)
 -> Nested Loop (cost=1.19..43.57 rows=1 width=69)
 -> Nested Loop (cost=0.89..35.25 rows=1 width=69)
 -> Nested Loop (cost=0.59..26.93 rows=1 width=36)
 -> Nested Loop (cost=0.31..18.61 rows=1 width=36)
指定表的关联顺序配置参数
 -> Nested Loop (cost=0.16..10.44 rows=1 width=36)
 -> Index Scan using tbl_join_1_pkey on tbl_join_1 t1 (cost=0.16..8.18 rows=1 width=36)
 Index Cond: (id = 10000)
 -> Seq Scan on tbl_join_2 t2 (cost=0.00..2.25 rows=1 width=4)
 Filter: (id = 10000)
 -> Index Only Scan using tbl_join_3_pkey on tbl_join_3 t3 (cost=0.15..8.17 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_4_pkey on tbl_join_4 t4 (cost=0.29..8.30 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Index Scan using tbl_join_5_pkey on tbl_join_5 t5 (cost=0.29..8.31 rows=1 width=37)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_6_pkey on tbl_join_6 t6 (cost=0.30..8.32 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_7_pkey on tbl_join_7 t7 (cost=0.30..8.32 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_8_pkey on tbl_join_8 t8 (cost=0.43..8.45 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_9_pkey on tbl_join_9 t9 (cost=0.43..8.45 rows=1 width=4)
 Index Cond: (id = 10000)
 (26 rows)
 Time: 23.650 ms
指定表的关联顺序配置参数
 digoal=# set join_collapse_limit=9;
 digoal=# explain select t1.info, t5.info from
 tbl_join_1 t1 join tbl_join_2 t2 on (t1.id=t2.id)
 join tbl_join_3 t3 on (t2.id=t3.id)
 join tbl_join_4 t4 on (t3.id=t4.id)
 join tbl_join_5 t5 on (t4.id=t5.id)
 join tbl_join_6 t6 on (t5.id=t6.id)
 join tbl_join_7 t7 on (t6.id=t7.id)
 join tbl_join_8 t8 on (t7.id=t8.id)
 join tbl_join_9 t9 on (t8.id=t9.id)
 where t9.id=10000;
 Time: 51.591 ms
指定表的关联顺序配置参数
 digoal=# set geqo_threshold=9;
 digoal=# explain select t1.info, t5.info from
 tbl_join_1 t1 join tbl_join_2 t2 on (t1.id=t2.id)
 join tbl_join_3 t3 on (t2.id=t3.id)
 join tbl_join_4 t4 on (t3.id=t4.id)
 join tbl_join_5 t5 on (t4.id=t5.id)
 join tbl_join_6 t6 on (t5.id=t6.id)
 join tbl_join_7 t7 on (t6.id=t7.id)
 join tbl_join_8 t8 on (t7.id=t8.id)
 join tbl_join_9 t9 on (t8.id=t9.id)
 where t9.id=10000;
 Time: 18.359 ms
 因为geqo_threshold和join_collapse_limit设置为相等, 所以这个SQL在生成join list时, 会达到geqo限制, 触发geqo plan.
 因此只需计划的时间也缩短了.
 后面会讲geqo.
指定表的关联顺序配置参数
 digoal=# set join_collapse_limit=1;
 digoal=# explain select t1.info, t5.info from
 tbl_join_1 t1 join tbl_join_2 t2 on (t1.id=t2.id)
 join tbl_join_3 t3 on (t2.id=t3.id)
 join tbl_join_4 t4 on (t3.id=t4.id)
 join tbl_join_5 t5 on (t4.id=t5.id)
 join tbl_join_6 t6 on (t5.id=t6.id)
 join tbl_join_7 t7 on (t6.id=t7.id)
 join tbl_join_8 t8 on (t7.id=t8.id)
 join tbl_join_9 t9 on (t8.id=t9.id)
 where t9.id=10000;
 Time: 5.605 ms
 设置join_collapse_limit=1后, 按照SQL写法进行关联. 执行计划的时间也缩短了.
GEQO
 表关联是执行计划最耗时的部分, 特别是表多的情况下, 关联顺序指数增长.
 例如9个表关联最多有9*8*7*6*5*4*3 = 181440种关联顺序,
 如果再乘上连接方法(nestloop, hashjoin, mergejoin)和扫描方法(indexscan, seqscan, indexonlyscan, bitmapscan等)则最多有181440*(3^(9-
1))*(n^9-1)种组合.
 所以执行计划的开销会随着关联表的数量而指数级的增加.
 GEQO是一种利用遗传算法解决穷举法随着关联表的增加而带来的执行计划耗费暴增的问题.
 src/backend/optimizer/geqo
 geqo得到的执行计划也许不是最优的, 但是可以降低执行计划耗费的时间.
 相关参数
 geqo (boolean) -- geqo开关, 默认打开
 geqo_threshold (integer) -- JOIN表数量, 大于或等于这个值时, 将启用GEQO. 默认12.
 geqo_effort (integer) -- 优化倾向, 值越大, 得出的路径越多, 越有可能得到更优的执行计划, 但是带来更多的开销. 默认5. (1-10)
 geqo_pool_size (integer) -- 默认0, 从geqo_effort得出合适的值, 含义同上.
 geqo_generations (integer) -- 默认0, 从geqo_pool_size得出合适的值, 含义同上.
 geqo_selection_bias (floating point) -- GEQO选择性偏差, 默认2.0 (1.5-2.0)
 geqo_seed (floating point) -- 随机数初始值, 默认0.
GEQO
 例子:
 digoal=# set geqo_threshold=8;
 digoal=# explain select t1.info, t5.info from
 tbl_join_1 t1 join tbl_join_2 t2 on (t1.id=t2.id)
 join tbl_join_3 t3 on (t2.id=t3.id)
 join tbl_join_4 t4 on (t3.id=t4.id)
 join tbl_join_5 t5 on (t4.id=t5.id)
 join tbl_join_6 t6 on (t5.id=t6.id)
 join tbl_join_7 t7 on (t6.id=t7.id)
 join tbl_join_8 t8 on (t7.id=t8.id)
 join tbl_join_9 t9 on (t8.id=t9.id)
 where t9.id=10000;
 QUERY PLAN
 Nested Loop (cost=2.35..68.82 rows=1 width=65)
 -> Nested Loop (cost=1.92..60.36 rows=1 width=69)
 -> Nested Loop (cost=1.61..52.03 rows=1 width=73)
 -> Nested Loop (cost=1.46..43.85 rows=1 width=81)
 -> Nested Loop (cost=1.03..35.39 rows=1 width=77)
 -> Nested Loop (cost=0.74..27.08 rows=1 width=44)
 -> Nested Loop (cost=0.74..24.82 rows=1 width=44)
 -> Nested Loop (cost=0.44..16.49 rows=1 width=40)
GEQO
 -> Index Only Scan using tbl_join_4_pkey on tbl_join_4 t4 (cost=0.29..8.30 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Index Scan using tbl_join_1_pkey on tbl_join_1 t1 (cost=0.16..8.18 rows=1 width=36)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_6_pkey on tbl_join_6 t6 (cost=0.30..8.32 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Seq Scan on tbl_join_2 t2 (cost=0.00..2.25 rows=1 width=4)
 Filter: (id = 10000)
 -> Index Scan using tbl_join_5_pkey on tbl_join_5 t5 (cost=0.29..8.31 rows=1 width=37)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_8_pkey on tbl_join_8 t8 (cost=0.43..8.45 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_3_pkey on tbl_join_3 t3 (cost=0.15..8.17 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_7_pkey on tbl_join_7 t7 (cost=0.30..8.32 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_9_pkey on tbl_join_9 t9 (cost=0.43..8.45 rows=1 width=4)
 Index Cond: (id = 10000)
 (26 rows)
 Time: 16.694 ms -- 因为join_collapse_limit=8, 所以join list长度为8, 达到使用geqo的阈值, 执行计划耗时16.694毫秒
GEQO
 digoal=# set geqo_threshold=9;
 digoal=# explain select t1.info, t5.info from
 tbl_join_1 t1 join tbl_join_2 t2 on (t1.id=t2.id)
 join tbl_join_3 t3 on (t2.id=t3.id)
 join tbl_join_4 t4 on (t3.id=t4.id)
 join tbl_join_5 t5 on (t4.id=t5.id)
 join tbl_join_6 t6 on (t5.id=t6.id)
 join tbl_join_7 t7 on (t6.id=t7.id)
 join tbl_join_8 t8 on (t7.id=t8.id)
 join tbl_join_9 t9 on (t8.id=t9.id)
 where t9.id=10000;
 QUERY PLAN
 Nested Loop (cost=2.35..68.82 rows=1 width=65)
 -> Nested Loop (cost=1.92..60.36 rows=1 width=69)
 -> Nested Loop (cost=1.49..51.90 rows=1 width=69)
 -> Nested Loop (cost=1.19..43.57 rows=1 width=69)
 -> Nested Loop (cost=0.89..35.25 rows=1 width=69)
 -> Nested Loop (cost=0.59..26.93 rows=1 width=36)
 -> Nested Loop (cost=0.31..18.61 rows=1 width=36)
 -> Nested Loop (cost=0.16..10.44 rows=1 width=36)
GEQO
 -> Index Scan using tbl_join_1_pkey on tbl_join_1 t1 (cost=0.16..8.18 rows=1 width=36)
 Index Cond: (id = 10000)
 -> Seq Scan on tbl_join_2 t2 (cost=0.00..2.25 rows=1 width=4)
 Filter: (id = 10000)
 -> Index Only Scan using tbl_join_3_pkey on tbl_join_3 t3 (cost=0.15..8.17 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_4_pkey on tbl_join_4 t4 (cost=0.29..8.30 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Index Scan using tbl_join_5_pkey on tbl_join_5 t5 (cost=0.29..8.31 rows=1 width=37)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_6_pkey on tbl_join_6 t6 (cost=0.30..8.32 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_7_pkey on tbl_join_7 t7 (cost=0.30..8.32 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_8_pkey on tbl_join_8 t8 (cost=0.43..8.45 rows=1 width=4)
 Index Cond: (id = 10000)
 -> Index Only Scan using tbl_join_9_pkey on tbl_join_9 t9 (cost=0.43..8.45 rows=1 width=4)
 Index Cond: (id = 10000)
 (26 rows)
 Time: 23.407 ms -- join_collapse_limit=8时, join list长度为8, 小于geqo阈值9, 采用穷举法, 执行计划耗时23.407毫秒.
GEQO
 digoal=# set geqo_threshold=12;
 digoal=# set join_collapse_limit=9; -- join list长度到9.
 digoal=# explain select t1.info, t5.info from
 tbl_join_1 t1 join tbl_join_2 t2 on (t1.id=t2.id)
 join tbl_join_3 t3 on (t2.id=t3.id)
 join tbl_join_4 t4 on (t3.id=t4.id)
 join tbl_join_5 t5 on (t4.id=t5.id)
 join tbl_join_6 t6 on (t5.id=t6.id)
 join tbl_join_7 t7 on (t6.id=t7.id)
 join tbl_join_8 t8 on (t7.id=t8.id)
 join tbl_join_9 t9 on (t8.id=t9.id)
 where t9.id=10000;
 ...
 Time: 54.376 ms -- 采用穷举法
GEQO
 digoal=# set geqo_threshold=9; -- geqo阈值也调到9
 digoal=# explain select t1.info, t5.info from
 tbl_join_1 t1 join tbl_join_2 t2 on (t1.id=t2.id)
 join tbl_join_3 t3 on (t2.id=t3.id)
 join tbl_join_4 t4 on (t3.id=t4.id)
 join tbl_join_5 t5 on (t4.id=t5.id)
 join tbl_join_6 t6 on (t5.id=t6.id)
 join tbl_join_7 t7 on (t6.id=t7.id)
 join tbl_join_8 t8 on (t7.id=t8.id)
 join tbl_join_9 t9 on (t8.id=t9.id)
 where t9.id=10000;
 ...
 Time: 18.506 ms -- 采用geqo.
 digoal=# set geqo_effort =10; -- 把effort改到10, 则geqo的耗时增加. 执行计划有所变化.
 Time: 32.341 ms
目录
授课环境
SQL优化基础
如何让数据库输出好的执行计划
压力测试工具的使用和建模
性能分析工具的使用
综合优化案例