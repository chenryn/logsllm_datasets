Section 6.2 into account, we see that a tainted string consists
– on average – of about three tainted substrings. Thus, an
attacker has on average three possible injection points in
order to leverage the techniques presented by Nikiforakis.
Therefore, we have good reasons to believe that the numbers
presented in this Section must rather be seen as a lower
bound.
To the best of our knowledge, DOMinator [7] was the ﬁrst
browser-based tool to test for DOM-based XSS via dynamic
taint-tracking. For this purpose, DOMinator instruments
Firefox’s SpiderMonkey JavaScript engine. Unlike our tech-
nique, DOMinator does not track data ﬂows on a byte level.
Instead, it employs a function tracking history to store the
operations which were called on the original, tainted input
to result into the ﬁnal, still tainted, string ﬂowing into a
sink. Also, it does not feature a fully automated vulnerabil-
ity validation.
FLAX [25] is the conceptionally closest approach to our
work. Similar to our system, FLAX also utilizes byte-level
taint-tracking to identify insecure data ﬂows in JavaScript.
However, there are several key diﬀerences in which we im-
prove over FLAX: For one, FLAX’s taint analysis is not
fully integrated in the JavaScript engine. Instead, the actual
analysis is done on program slices which are translated into
JASIL, a simpliﬁed version of JavaScript, which expresses
the operational semantics of only a subset of JavaScript.
In contrast, through extending JavaScript’s low-level string
type, we achieve full language and API coverage. Further-
more, FLAX employs fuzzing for vulnerability testing, while
our approach leverages the precise source and sink context
information to create validation payloads that determinis-
tically match the respective data ﬂows speciﬁcs. Finally,
using a large scale study we successfully demonstrated that
our system is compatible with the current code practices in
today’s Web. In contrast, FLAX was only practically eval-
uated on a set of 40 Web applications and widgets.
Criscione [5] presented an automatic tool to ﬁnd XSS
problems in a scalable black box fashion. Similar to our
approach, they also use actual browser instances for test ex-
ecution and vulnerability validation. However, they don’t
utilize taint propagation or precise payload generation. In-
stead, the tests are done in a fuzzing fashion.
Finally, a related approach was presented by Vogt et.
al. [30], which utilizes a combination of static analysis and
dynamic information ﬂow tracking to mitigate XSS exploits.
However, instead of following the ﬂow of untrusted data, the
focus is on security sensitive values, such as the user’s cookie,
and the potential exﬁltration of those.
Server-side approaches and static taint analysis:
On the server-side various approaches using dynamic taint-
tracking to detect and mitigate XSS vulnerabilities have
been proposed [20, 23, 4, 27, 19, 33, 2]. Furthermore, as
an alternative to dynamic taint-tracking, static analysis of
source code to identify insecure data ﬂows is a well estab-
lished tool [9, 28, 31, 14, 32, 10].
Attack generation: In order to decrease false positive
rates several approaches have been studied to automatically
generate a valid exploit payloads for validation purposes.
In 2008, Martin et al. [18] presented a method to gener-
ate XSS and SQL injection exploits based on goal-directed
model checking. Thereby, their system QED is capable of
performing a goal-directed analysis of any Java Web appli-
cation, which adheres to the standard servlet speciﬁcation.
Based on the constructed model, a model checker is able
to generate a valid exploit that can be used to validate the
ﬁnding. As opposed to our approach the system operates
on the server-side code and thus focuses on server-side in-
jection vulnerabilities. Similar to this approach, Kieyzun et
al. [15] also focus on the automatic generation of attacks
1202targeting server-side injection vulnerabilities. In order to do
so, the authors use symbolic taint-tracking and input mu-
tations to generate example exploits. Thereby, several test
inputs are transmitted to the target service and depending
on the registered data ﬂows, inputs are mutated to generate
malicious payloads. As opposed to our approach, their tool
Ardilla also only works on server-side code and thus rather
targets traditional XSS vulnerabilities. As it requires sev-
eral HTTP requests for generating a valid exploit, scaling is
far more diﬃcult than with our approach. In [6], d’Amore
et al. present the tool snuck that is capable of automati-
cally evading server-side XSS ﬁlters. To function, however,
the tool needs input from a human tester that identiﬁes the
application’s intended workﬂows and possible injection vec-
tors. The tool then automatically veriﬁes whether the ﬁlter
functions works in a correct manner. In order to do so the
system identiﬁes the exact injection context by using XPath
queries.
Empirical studies on JavaScript security: Due to its
ever growing importance in the Web application paradigm,
several security-relevant aspects of client-side JavaScript ex-
ecution have been studied empirically. For one, Yue and
Wang [34] examined the commonness of JavaScript prac-
tices that could lead to unauthorized code execution, namely
cross-domain inclusion of external JavaScript ﬁles and usage
of APIs that could lead to XSS. Their study is purely statis-
tically and no real vulnerability validation was conducted.
Zooming in on eval, Richards et al. [24] study how this
problematic API is used in the wild, identifying both usage
patterns that could be solved with safe alternatives as well as
instances, in which replacing eval would not be a straight
forward task. Furthermore, selected “HTML5” JavaScript
APIs have been studied in detail: Lekies & Johns [17] sur-
veyed the Alexa top 500,000 for potentially insecure usage
of JavaScript’s localStorage for code caching purposes and
Son & Shmatikov [26] examined the Alexa top 10,000 for vul-
nerabilities occurring from unsafe utilization of the postMes-
sage API.
8. CONCLUSION
In this paper, we presented a fully automated approach
to detect and validate DOM-based XSS vulnerabilities. By
direct integration into the browser’s JavaScript engine, we
achieve reliable identiﬁcation of potentially insecure data
ﬂows while maintaining full compatibility with productive
JavaScript code. Furthermore, the precise, byte-level con-
text informations of the resulting injection points enables us
to create attack payloads which are tailored to the vulnera-
bility’s speciﬁc conditions, thus, allowing for robust exploit
generation.
Using our system, we conducted a large scale empirical
study, resulting in the identiﬁcation of 6,167 unique vulner-
abilities distributed over 480 domains, demonstrating that
9,6% of the Alexa top 5000 carry at least one DOM-based
XSS problem.
Acknowledgments
This work was in parts supported by the EU Projects Web-
Sand (FP7-256964) and STREWS (FP7-318097). The sup-
port is gratefully acknowledged.
9. REFERENCES
[1] Bates, D., Barth, A., and Jackson, C. Regular
expressions considered harmful in client-side XSS
ﬁlters. In WWW ’10: Proceedings of the 19th
international conference on World wide web (New
York, NY, USA, 2010), ACM, pp. 91–100.
[2] Bisht, P., and Venkatakrishnan, V. N.
XSS-GUARD: Precise dynamic detection of cross-site
scripting attacks. In Detection of Intrusions and
Malware & Vulnerability Assessment (DIMVA’08)
(2008).
[3] CERT. Advisory ca-2000-02 malicious html tags
embedded in client web requests, February 2000.
[4] Conti, J. J., and Russo, A. A taint mode for
python via a library. In NordSec (2010), T. Aura,
K. J¨arvinen, and K. Nyberg, Eds., vol. 7127 of Lecture
Notes in Computer Science, Springer, pp. 210–222.
[5] Criscione, C. Drinking the Ocean - Finding XSS at
Google Scale. Talk at the Google Test Automation
Conference, (GTAC’13), http://goo.gl/8qqHA, April
2013.
[6] d’Amore, F., and Gentile, M. Automatic and
context-aware cross-site scripting ﬁlter evasion.
Department of Computer, Control, and Management
Engineering Antonio Ruberti Technical Reports 1, 4
(2012).
[7] Di Paola, S. DominatorPro: Securing Next
Generation of Web Applications. [software],
https://dominator.mindedsecurity.com/, 2012.
[8] Google Developers. Chrome Extensions -
Developer’s Guide. [online], http://developer.
chrome.com/extensions/devguide.html, last access
06/05/13, 2012.
[9] Guarnieri, S., Pistoia, M., Tripp, O., Dolby, J.,
Teilhet, S., and Berg, R. Saving the world wide
web from vulnerable javascript. In ISSTA (2011),
M. B. Dwyer and F. Tip, Eds., ACM, pp. 177–187.
[10] Guha, A., Krishnamurthi, S., and Jim, T. Using
static analysis for Ajax intrusion detection. In
Proceedings of the 18th international conference on
World wide web (WWW’09) (New York, NY, USA,
2009), ACM, pp. 561–570.
[11] Hanna, S., Chul, E., Shin, R., Akhawe, D.,
Boehm, A., Saxena, P., and Song, D. The
emperor’s new apis: On the (in) secure usage of new
client-side primitives. In Web 2.0 Security and Privacy
(W2SP 2010) (2010).
[12] Heiderich, M., Nava, E., Heyes, G., and Lindsay,
D. Web Application Obfuscation:
-/WAFs..Evasion..Filters//alert (/Obfuscation/)-.
Elsevier/Syngress, 2010.
[13] Heyes, G. Bypassing XSS Auditor. [online],
http://www.thespanner.co.uk/2013/02/19/
bypassing-xss-auditor/, last accessed 08/05/13,
February 2013.
[14] Jovanovic, N., Kruegel, C., and Kirda, E. Pixy:
A Static Analysis Tool for Detecting Web Application
Vulnerabilities. In IEEE Symposium on Security and
Privacy (May 2006).
[15] Kieyzun, A., Guo, P. J., Jayaraman, K., and
Ernst, M. D. Automatic creation of sql injection and
cross-site scripting attacks. In Proceedings of the 31st
1203International Conference on Software Engineering
(Washington, DC, USA, 2009), ICSE ’09, IEEE
Computer Society, pp. 199–209.
[16] Klein, A. Dom based cross site scripting or xss of the
third kind. Web Application Security Consortium,
Articles 4 (2005).
[17] Lekies, S., and Johns, M. Lightweight Integrity
Protection for Web Storage-driven Content Caching.
In 6th Workshop on Web 2.0 Security and Privacy
(W2SP 2012) (May 2012).
[18] Martin, M., and Lam, M. S. Automatic Generation
of XSS and SQL Injection Attacks with Goal-Directed
Model Checking. In Usenix Security (2008).
[19] Nadji, Y., Saxena, P., and Song, D. Document
Structure Integrity: A Robust Basis for Cross-site
Scripting Defense. In Network & Distributed System
Security Symposium (NDSS 2009) (2009).
[20] Nguyen-Tuong, A., Guarnieri, S., Greene, D.,
Shirley, J., and Evans, D. Automatically hardening
web applications using precise tainting. In 20th IFIP
International Information Security Conference (May
2005).
[21] Nikiforakis, N. Bypassing Chrome’s Anti-XSS ﬁlter.
[online], http://blog.securitee.org/?p=37, last
access 08/05/13, September 2011.
[22] Nikiforakis, N., Invernizzi, L., Kapravelos, A.,
Acker, S. V., Joosen, W., Kruegel, C., Piessens,
F., and Vigna, G. You Are What You Include:
Large-scale Evaluation of Remote JavaScript
Inclusions. In 19th ACM Conference on Computer and
Communications Security (CCS 2012) (2012).
[23] Pietraszek, T., and Berghe, C. V. Defending
against Injection Attacks through Context-Sensitive
String Evaluation. In Recent Advances in Intrusion
Detection (RAID2005) (2005).
[24] Richards, G., Hammer, C., Burg, B., and Vitek,
J. The eval that men do - a large-scale study of the
use of eval in javascript applications. In ECOOP
(2011), M. Mezini, Ed., vol. 6813 of Lecture Notes in
Computer Science, Springer, pp. 52–78.
[25] Saxena, P., Hanna, S., Poosankam, P., and
Song, D. FLAX: Systematic Discovery of Client-side
Validation Vulnerabilities in Rich Web Applications.
In NDSS (2010), The Internet Society.
[26] Son, S., and Shmatikov, V. The Postman Always
Rings Twice: Attacking and Defending postMessage
in HTML5 Websites. In Network and Distributed
System Security Symposium (NDSS’13) (2013).
[27] Su, Z., and Wassermann, G. The Essence of
Command Injection Attacks in Web Applications. In
Proceedings of POPL’06 (January 2006).
[28] Tripp, O., Pistoia, M., Fink, S. J., Sridharan,
M., and Weisman, O. TAJ: Eﬀective Taint Analysis
for Java. In ACM SIGPLAN 2009 Conference on
Programming Language Design and Implementation
(PLDI 2009) (June 2009).
[29] Vikram, K., Prateek, A., and Livshits, B. Ripley:
Automatically securing distributed Web applications
through replicated execution. In Conference on
Computer and Communications Security (Oct. 2009).
[30] Vogt, P., Nentwich, F., Jovanovic, N., Kruegel,
C., Kirda, E., and Vigna, G. Cross Site Scripting
Prevention with Dynamic Data Tainting and Static
Analysis. In 14th Annual Network and Distributed
System Security Symposium (NDSS 2007) (2007).
[31] Wassermann, G., and Su, Z. Sound and Precise
Analysis of Web Applications for Injection
Vulnerabilities. In Proceedings of Programming
Language Design and Implementation (PLDI’07) (San
Diego, CA, June 10-13 2007).
[32] Xie, Y., and Aiken, A. Static Detection of Security
Vulnerabilities in Scripting Languages. In 15th
USENIX Security Symposium (2006).
[33] Xu, W., Bhatkar, S., and Sekar, R.
Taint-Enhanced Policy Enforcement: A Practical
Approach to Defeat a Wide Range of Attacks. In 15th
USENIX Security Symposium (August 2006).
[34] Yue, C., and Wang, H. Characterizing insecure
javascript practices on the web. In WWW (2009),
J. Quemada, G. Le´on, Y. S. Maarek, and W. Nejdl,
Eds., ACM, pp. 961–970.
1204