第 1 章 理解微服务................................1
请求................................30
2.2.2
1.1 SOA的起源..............................2
响应................................32
2.2.3
1.2 单体架构...................................2
2.3 Flask的内置特性...................33
1.3 微服务架构...............................5
Session对象.....................34
2.3.1
1.4 微服务的益处...........................7
全局值.............................34
2.3.2
分离团队的关注点.............7
1.4.1
信号................................35
2.3.3
更小的项目........................8
1.4.2
扩展和中间件..................37
2.3.4
扩展和部署........................8
1.4.3
模板................................38
2.3.5
1.5 微服务的缺陷...........................9
配置................................40
2.3.6
不合理的拆分....................9
1.5.1
Blueprint..........................42
2.3.7
更多的网络交互.................9
1.5.2
错误处理和调试...............43
2.3.8
数据的存储和分享...........10
1.5.3
2.4 微服务应用的骨架................47
兼容性问题......................10
1.5.4
2.5 本章小结.................................49
测试................................10
1.5.5
1.6 使用Python实现微服务.......11 第 3 章 良性循环：编码、测试和
WSGI标准......................12 写文档.....................................51
1.6.1
1.6.2 greenlet和gevent模块......13 3.1 各种测试类型的差异............52
Twisted和Tornado模块....15 单元测试.........................53
1.6.3 3.1.1
asyncio模块.....................16 功能测试.........................56
1.6.4 3.1.2
语言性能.........................18 集成测试.........................58
1.6.5 3.1.3
1.7 本章小结.................................20 3.1.4 负载测试.........................59
端到端测试......................61
3.1.5
第 2 章 Flask框架...............................21
3.2 使用WebTest..........................62
2.1 选择Python版本...................22
3.3 使用pytest和Tox..................64
2.2 Flask如何处理请求...............23
3.4 开发者文档.............................67
Python微服务开发
3.5 持续集成.................................71 5.3.1 模拟同步调用................123
Travis-CI..........................72 模拟异步调用................124
3.5.1 5.3.2
3.5.2 ReadTheDocs...................73 5.4 本章小结...............................127
Coveralls..........................73
3.5.3
第 6 章 监控服务...............................129
3.6 本章小结.................................75
6.1 集中化日志...........................129
第 4 章 设计Runnerly........................77 6.1.1 设置Graylog..................131
4.1 Runnerly应用.........................77 6.1.2 向Graylog发送日志......134
4.2 单体设计.................................79 6.1.3 添加扩展字段................136
4.2.1 模型................................80 6.2 性能指标...............................137
视图与模板......................80 系统指标.......................138
4.2.2 6.2.1
后台任务.........................84 代码指标.......................140
4.2.3 6.2.2
身份验证和授权...............88 Web服务器指标............142
4.2.4 6.2.3
4.2.5 单体设计汇总..................92 6.3 本章小结...............................143
4.3 拆分单体.................................93
第 7 章 保护服务...............................145
4.4 数据服务.................................94
7.1 OAuth2协议.........................146
4.5 使用Open API 2.0..................95
7.2 基于令牌的身份验证..........147
4.6 进一步拆分.............................97
JWT标准......................148
7.2.1
4.7 本章小结.................................98
PyJWT...........................150
7.2.2
第 5 章 与其他服务交互...................101 7.2.3 基于证书的X.509
5.1 同步调用...............................102 身份验证.......................151
5.1.1 在Flask应用中使用 7.2.4 TokenDealer微服务........154
Session...........................103 使用TokenDealer...........157
7.2.5
5.1.2 连接池...........................107 7.3 Web应用防火墙..................160
5.1.3 HTTP缓存头.................108 7.4 保护代码...............................166
改进数据传输................111 断言传入的数据.............166
5.1.4 7.4.1
同步总结.......................115 限制应用的范围.............170
5.1.5 7.4.2
5.2 异步调用...............................116 7.4.3 使用Bandit linter............171
5.2.1 任务队列.......................116 7.5 本章小结...............................174
主题队列.......................117
5.2.2
第 8 章 综合运用...............................175
发布/订阅模式...............122
5.2.3
8.1 构建ReactJS仪表盘...........176
AMQP上的RPC............122
5.2.4
JSX语法.......................176
8.1.1
异步总结.......................122
5.2.5
React组件.....................177
8.1.2
5.3 测试服务间交互...................123
XIV
目 录
8.2 ReactJS与Flask...................181 10.6 本章小结.............................233
8.2.1 使用 bower、npm和
第 11 章 在AWS上部署...................235
babel..............................182
11.1 AWS总览...........................236
跨域资源共享................185
8.2.2
11.2 路由：Route53、ELB和
8.3 身份验证与授权...................188
AutoScaling.........................237
与数据服务交互.............188
8.3.1
11.3 执行：EC2和Lambda......237
获取Strava令牌.............189
8.3.2
11.4 存储：EBS、S3、
JavaScript身份验证........191
8.3.3
RDS、ElasticCache和
8.4 本章小结...............................192
CloudFront..........................238
第 9 章 打包和运行Runnerly.........195 11.4.1 消息：SES、SQS和
9.1 打包工具链...........................196 SNS...........................240
9.1.1 一些定义.......................196 11.4.2 初始化资源和部署：
9.1.2 打包..............................197 CloudFormation和
版本控制.......................204 ECS...........................241
9.1.3
9.1.4 发布..............................206 11.5 在AWS上部署简介..........242
分发..............................208 创建AWS账号..........242
9.1.5 11.5.1
9.2 运行所有微服务...................210 11.5.2 使用CoreOS在EC2上
9.3 进程管理...............................213 部署..........................244
9.4 本章小结...............................216 11.6 使用ECS 部署..................247
11.7 Route53................................251
第 10 章 容器化服务.........................217
11.8 本章小结.............................253
10.1 何为Docker？....................218
10.2 Docker简介........................219 第 12 章 接下来做什么？................255
10.3 在Docker中运行Flask.....221 12.1 迭代器和生成器................256
10.4 完整的栈——OpenResty、 12.2 协同程序.............................259
Circus和Flask....................223 12.3 asyncio库............................260
10.4.1 OpenResty..................224 12.4 aiohttp框架.........................262
10.4.2 Circus........................226 12.5 Sanic....................................262
10.5 基于Docker的部署...........228 12.6 异步和同步.........................264
10.5.1 Docker Compose.........230 12.7 本章小结.............................265
集群和初始化简介.....231
10.5.2
XV
1
第 章
理解微服务
软件行业一直在尝试改良软件构建方式。不用说，与穿孔卡片时代相比，当今的
软件构建过程已改良了很多。
微服务是过去几年里涌现出的一种改良方法，部分原因是很多公司想缩短发布周
期。他们希望能尽快向客户交付新产品或新特性，希望通过迭代达到“敏捷”目的，
希望能做到交付、交付、再交付。
如果有大量客户正使用你的服务，相对于发布之前反复测试产品，直接在运行的
产品上推送一个试验性功能或移除一项无用的功能是更好的实践方法。
现在，Netflix等公司正在倡导持续交付技术，这是一种可让小改动频繁上线，然
后在一小部分用户中进行测试的技术。他们开发了很多工具，例如
Spinnaker(http://www.spinnaker.io/)就是通过自动执行尽可能多的步骤来更新生产环境，
改动的特性通过相互独立的微服务发布到云上。
但如果阅读Hacker News或Reddit，你会发现，梳理出哪些概念真正有用，哪些
概念只是随波逐流的新闻体裁是非常困难的。
“写一篇承诺救赎的论文，使它成为‘结构化’或‘虚拟化’的东西，或使用抽
象、分布式、高阶、可适用等概念，你几乎肯定在宣扬一门新邪教。”
——Edsger W. Dijkstra
本章将讲解什么是微服务，然后重点介绍多个使用Python实现微服务的方法。本
章要点如下：
● 面向服务架构
● 使用单体方式构建应用
● 使用微服务方式构建应用
Python微服务开发
● 微服务的益处
● 微服务的缺陷