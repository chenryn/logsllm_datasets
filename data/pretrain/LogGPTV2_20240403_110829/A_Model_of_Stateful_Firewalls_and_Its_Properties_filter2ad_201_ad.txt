ii. If f is stateless, then f.a = f.b.
stateful section empty and removing the “insert” command
from every rule in its stateless section.
As an example, consider the ﬁrewall in Figure 9(a). This
ﬁrewall accepts each packet where S ∈ {0} and D ∈ {1}
in each reachable state, and discards all other packets in
each reachable state. Thus, this ﬁrewall is truly stateless
(although it is syntactically stateful). Therefore, this ﬁre-
wall can be simpliﬁed as shown in Figure 9(b).
(cid:1) ∧ D = S
Stateful Section:
R1 : S = D
Stateless Section:
r1 : S ∈ {0} ∧ D ∈ {1} ∧ tag ∈ all→ accept; insert
r2 : S ∈ all ∧ D ∈ all ∧ tag ∈ all→ discard
(cid:1) → tag := 1
(a)
Stateful Section:
Stateless Section:
r1 :S ∈ {0} ∧ D ∈ {1} ∧ tag ∈ all→ accept
r2 :S ∈ all ∧ D ∈ all ∧ tag ∈ all→ discard
(b)
Figure 9. A truly stateless ﬁrewall and its sim-
pliﬁed version
5.2 Stateless Derivatives
It is important that if a ﬁrewall designer designs a stateful
ﬁrewall f, then he should verify that f is truly stateful. This
is because if f is truly stateless, then f can be simpliﬁed into
a stateless ﬁrewall. In this section, we identify a sufﬁcient
condition for verifying that a ﬁrewall is truly stateful. But
ﬁrst we introduce the concept of a stateless derivative of a
ﬁrewall.
The stateless derivative of a ﬁrewall f is the ﬁrewall ob-
tained after making the stateful section of f empty and re-
moving the “insert” command from every rule in the state-
less section of f. For example, Figure 9(b) shows the state-
less derivative of the ﬁrewall in Figure 9(a).
The relationship between a ﬁrewall and its stateless
derivative is stated in the following theorem, whose proof
is presented in the appendix.
A ﬁrewall f is truly stateful iff f.a is a proper subset
of f.b; i.e., f.a ⊂ f.b. A ﬁrewall f is truly stateless
iff f.a = f.b. Clearly, a stateless ﬁrewall is truly state-
less, but a stateful ﬁrewall can either be truly stateful or be
truly stateless. A stateful ﬁrewall that is truly stateless can
be simpliﬁed, without changing its function, by making its
Theorem 2 Let f be a ﬁrewall and g be its stateless deriva-
tive,
i. f.a ⊆ g.a
ii. g.a = g.b
iii. g.b ⊆ f.b
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Michigan State University. Downloaded on October 21, 2009 at 22:54 from IEEE Xplore.  Restrictions apply. 
8
Recall that a ﬁrewall f is truly stateful iff f.a ⊂ f.b.
By Theorem 2, one way to prove that a ﬁrewall f, whose
stateless derivative is denoted g, is truly stateful is to prove
that the following two conditions hold:
i. f.a = g.a;
ii. g.b ⊂ f.b
We call ﬁrewalls that satisfy the ﬁrst condition conforming
ﬁrewalls; and call ﬁrewalls that satisfy the second condition
proper ﬁrewalls.
6 Firewall Properties
In this section, we discuss how to verify that a ﬁrewall is
conforming or proper.
6.1 Conforming Firewalls
Before we give a theorem on how to verify that a ﬁrewall
is conforming, we need to introduce the two concepts of
complementary rules and accepting rules.
Let rule r, that appears in the stateless section of some
ﬁrewall, be of the form
F1 ∈ S1 ∧ ··· ∧ Fd ∈ Sd ∧ tag ∈ St → (cid:4)decision(cid:5)
Rule r is complementary iff the set St does not contain the
value 0. Rule r is accepting iff the (cid:4)decision(cid:5) of r contains
the command “accept”.
The following theorem can be used to verify that a ﬁre-
wall is conforming. The proof of this theorem is presented
in the appendix.
Theorem 3 A ﬁrewall f is conforming if every comple-
mentary rule in the stateless section of f is accepting.
As an example, we use Theorem 3 to prove that the ﬁre-
wall in Figure 2 is conforming as follows. This ﬁrewall
has only one complementary rule, which is rule r3 : I ∈
{0} ∧ P ∈ {icmp} ∧ T ∈ {pong} ∧ tag ∈ {1} → accept.
And rule r3 is an accepting rule. Therefore, this ﬁrewall is
conforming.
6.2 Proper Firewalls
Based on our experience in designing ﬁrewalls, most
ﬁrewalls are conforming. By Theorem 2, a conforming ﬁre-
wall is truly stateful iff it is proper. Next we discuss how to
verify that a ﬁrewall is proper.
A ﬁrewall is proper iff its acceptable set is a proper su-
perset of the acceptable set of its stateless derivative. For
a ﬁrewall to be proper, we ﬁrst need to make sure that its
state does not remain empty forever. We call such ﬁrewalls
grounded. More precisely, grounded ﬁrewalls are deﬁned
as follows.
rules r1, r2,··· , rn:
Let f be a ﬁrewall whose stateless section consists of n
r1 : P1 → (cid:4)decision 1(cid:5)
r2 : P2 → (cid:4)decision 2(cid:5)
···
rn : Pn → (cid:4)decision n(cid:5)
A rule rk, where 1 ≤ k ≤ n, is called a ground rule iff the
following three conditions hold:
i. rk is non-complementary;
ii. (cid:4)decision k(cid:5) is “accept; insert” or “accept; insert;
iii. ∼ P1∧ ∼ P2 ∧ ···∧ ∼ Pk−1 ∧ Pk is satisﬁable by at
remove”;
least one packet.
A ﬁrewall is grounded iff it has a ground rule.
A ground rule of a grounded ﬁrewall guarantees that in
the initial state of the ﬁrewall, there exists at least one packet
that can be accepted and inserted into the state of the ﬁre-
wall.
To test whether a ﬁrewall is grounded, we can go through
each rule and test whether it is a ground rule according
to the above deﬁnition. Once we ﬁnd a ground rule in a
ﬁrewall, we know that the ﬁrewall is grounded. For ex-
ample, consider the ﬁrewall in Figure 4. The second rule
in the stateless section of this ﬁrewall is a ground rule
because (1) it is non-complementary; (2) its decision is
“accept; insert”; and (3) ∼ P1 ∧ P2 is satisﬁable. Note that
∼ P1 ∧ P2 = I ∈ {1}∧ S ∈ [0, α− 1]∪ [α + 1, 232)∧ D ∈
all ∧ DP ∈ all ∧ P ∈ all ∧ tag ∈ all, where α denotes the
integer formed by the four bytes of the IP address 192.1.2.3.
Therefore, this ﬁrewall is grounded.
For a grounded ﬁrewall to be proper, we need to show
that there exists at least one packet, denoted p, such that
(1) p is discarded by the stateless derivative of the ﬁrewall,
(2) p can be accepted by the ﬁrewall in some state. As an
example, we show how to verify that a grounded ﬁrewall is
proper by examining the ﬁrewall example in Figure 2 as fol-
lows. For this ﬁrewall, we assume that each packet consists
of the ﬁelds of I, S, D, P, T, ID, and SN. Consider the two
(cid:1) and p in the following table. It is straightforward
packets p
to verify that packet p is discarded by the stateless deriva-
tive of this ﬁrewall (because of rule r4). At any state of this
(cid:1) is accepted and inserted into the state because
ﬁrewall, p
of rule r1. Because of the stateful rule R1 and the stateless
(cid:1) is in the state, packet p is accepted.
rule r3, as long as p
Therefore, this ﬁrewall is proper.
p(cid:1)
p
I
1
0
S
192.1.2.4
192.32.1.2
D
192.32.1.2
192.1.2.4
P
icmp
icmp
T
ping
pong
ID
10
10
SN
200
200
9
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Michigan State University. Downloaded on October 21, 2009 at 22:54 from IEEE Xplore.  Restrictions apply. 
7 Conclusions and Future Work
We consider our paper to be the ﬁrst step in designing
and analyzing stateful ﬁrewalls. Our contributions in this
paper are two-fold. First, we propose the ﬁrst model for
specifying stateful ﬁrewalls, which henceforth opens doors
to new research on stateful ﬁrewalls. Our model of stateful
ﬁrewalls has several favorable properties. It is simple but
can express a variety of state tracking functionalities. It al-
lows us to inherit the rich results in stateless ﬁrewall design
and analysis. Moreover, it provides backward compatibility
such that a stateless ﬁrewall can also be speciﬁed using our
model. Second, we present methods for analyzing stateful
ﬁrewalls that are speciﬁed using our model. We outline a
method for verifying whether a ﬁrewall is truly stateful.
Several issues related to our stateful ﬁrewall model are
left for future work, for example, how to efﬁciently imple-
ment this model and how to use it to analyze other proper-
ties of stateful ﬁrewalls.
References
[1] E. Al-Shaer and H. Hamed. Discovery of policy anoma-
lies in distributed ﬁrewalls. In IEEE INFOCOM’04, pages
2605–2616, March 2004.
[2] Y. Bartal, A. J. Mayer, K. Nissim, and A. Wool. Firmato:
A novel ﬁrewall management toolkit. Technical Report
EES2003-1, Dept. of Electrical Engineering Systems, Tel
Aviv University, 2003.
[3] CheckPoint FireWall-1. http://www.checkpoint.com/. Date
of access: March 25, 2005.
[4] Cisco PIX Firewalls. http://www.cisco.com/. Date of access:
March 25, 2005.
[5] Cisco Reﬂexive ACLs. http://www.cisco.com/. Date of ac-
cess: March 25, 2005.
[6] M. Frantzen, F. Kerschbaum, E. Schultz, and S. Fahmy. A
framework for understanding vulnerabilities in ﬁrewalls us-
ing a dataﬂow model of ﬁrewall internals. Computers and
Security, 20(3):263–270, 2001.
[7] M. G. Gouda and A. X. Liu. Firewall design: consis-
tency, completeness and compactness. In Proc. of the 24th
IEEE International Conference on Distributed Computing
Systems (ICDCS’04), pages 320–327.
[8] J. D. Guttman. Filtering postures: Local enforcement for
In Proc. of IEEE Symp. on Security and
global policies.
Privacy, pages 120–129, 1997.
[9] S. Kamara, S. Fahmy, E. Schultz, F. Kerschbaum, and
M. Frantzen. Analysis of vulnerabilities in internet ﬁrewalls.
Computers and Security, 22(3):214–232, 2003.
[10] A. X. Liu and M. G. Gouda. Diverse ﬁrewall design. In Proc.
of the International Conference on Dependable Systems and
Networks (DSN’04), pages 595–604, June 2004.
[11] A. X. Liu, M. G. Gouda, H. H. Ma, and A. H. Ngu. Fire-
wall queries. In Proc. of the 8th International Conference
on Principles of Distributed Systems (OPODIS-04), pages
124–139, December 2004.
[12] A. Mayer, A. Wool, and E. Ziskind. Fang: A ﬁrewall analy-
sis engine. In Proc. of IEEE Symp. on Security and Privacy,
pages 177–187, 2000.
[13] Netﬁlter/IPTables. http://www.netﬁlter.org/. Date of access:
March 25, 2005.
[14] J. Postel. Internet control message protocol. RFC 792, 1981.
[15] J. Postel and J. Reynolds. File transfer protocol. RFC 959,
1985.
[16] A. Wool. Architecting the lumeta ﬁrewall analyzer. In Proc.
of the 10th USENIX Security Symposium, pages 85–97, Au-
gust 2001.
Appendix
A Proof of Theorem 2
Proof of i: This assertion holds because f.a is the set of
all the packets where each packet can be accepted in every
reachable state of f and g.a is the set of all the packets that
can be accepted in the initial state of f.
Proof of ii: Note that g is a stateless ﬁrewall. By
Theorem 1, this assertion holds.
Proof of iii: This assertion holds because g.b is the set of
all the packets that can be accepted in the initial state of f,
and f.a is the set of all the packets where each packet can
be accepted in some reachable state of f.
B Proof of Theorem 3
Given a ﬁrewall f and its stateless derivative g, we know
f.a ⊆ g.a according to Theorem 2. Next we prove that if
every complementary rule of f is accepting, then g.a ⊆ f.a.
For any packet p ∈ g.a, there is an accepting rule r whose
predicate is of the form
F1 ∈ S1 ∧ ··· ∧ Fd ∈ Sd ∧ tag ∈ St
such that 0 ∈ St, and the packet p with tag value being 0
matches r but does not match any rule listed above r. Be-
cause every complementary rule is an accepting rule, every
packet with a certain tag value that satisﬁes
F1 ∈ S1 ∧ ··· ∧ Fd ∈ Sd ∧ tag ∈ (D(tag) − St)
is accepted by the ﬁrewall. Here D(tag) denotes the domain
of tag. So, no matter what the tag value of p is, p is accepted
by f. Therefore, p ∈ f.a.
Acknowledgements
We would like to thank David Taylor and the anonymous
reviewers for their constructive comments on the early ver-
sion of this paper.
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Michigan State University. Downloaded on October 21, 2009 at 22:54 from IEEE Xplore.  Restrictions apply. 
10