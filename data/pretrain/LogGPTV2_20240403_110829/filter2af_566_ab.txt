第二次反序列化得到的即为proxy对象，为Templates类，这里的map.put即使新的入口点  
跟进map.put看看，我们知道一个Map中不能包含相同的key，每个key只能映射一个value，那么能不能插入新的值，put内部肯定是有一定的判断逻辑的，那么这里面就包含了动态代理的触发点  
put函数首先要对要放入的key计算一个hash，此时key为proxy对象，跟进此函数看看  
其将会调用key.hashCode函数，那么我们知道当调用proxy对象的函数时将触发动态代理类的invoke函数，因此此时此时从下图①或②中都能够看到已经成功通过proxy对象进入到动态代理类AnnotationInvocationHandler当中  
此时判断我们调用的是hashcode函数，将会进一步调用hashCodeImpl函数  
在这个函数内部才是真正对map的key进行一个hash的计算  
这里实际上将用127乘对AnnotationInvocationHandler的memberValues的键计算的hash以及值计算的hash，那么之前我们分析yso的payload时知道赋值给membervalue的键为键为f5a5a608，值为恶意的templateImpl对象，那么此时这个循环将执行一次并且计算key的hascode为0，那么实际上var1的值即为membervalue的键对应值的hascode，其值为恶意的TemplatesImpl对象  
此时计算得到的hash为106298691，那么为什么要这么设置呢，之后就可以明白  
计算完的hash还要经过移位操作然后得到最终的hash值为104622798  
回到map.put函数的if判断，那么此时e.hash就是计算map第一个键的hash，而map第一个键就是恶意的TemplatesImpl对象，因此计算其hash肯定为104622798  
所以之所以yso的payload要这么设置正是因为如此，也就是map的键为什么要设置为f5a5a608的原因,继续往下看  
这里用Entry来对要放入的map的中的键进行遍历，其Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为`Entry`,它表示Map中的一个实体(一个key-value对),接着看这个判断：  
其中有&&连接两部分  
① e.hash == hash  
② ((k = e.key) == key || key.equals(k))  
那么此时先理清key和k都是什么，这里的key和k如下图所示，这里的key就是Templates类型的proxy对象，k就是之前第一次放入map中的恶意的Templates对象，此时作为equals函数的入口参数，实际上调用的被代理对象的equals方法，那么这里正和我们的思路，那么想要触发动态代理，我们知道e.key是TemplatesImpl的对象，key是Templates类型的proxy对象，那么判断肯定不成立，那么就能够执行或逻辑右边的表达式，那么此时条件①的已经满足，因此直接调用key.equals(k)  
那么实际上这里就跳又到annotation这里了，就是我们之前设置的动态代理类，直接到invoke函数处，判断调用的是equals函数  
这里将会又再次跳到equalsImpl函数，其中入口参数var3[0]为传入的TemplateImpl恶意类，继续跟进  
此时1处templateImpl肯定不等于annotation并且2处这里this.type在yso的payload中设置为下图所示，通过反射令其type为Templates类  
所以这里就是判断templateImpl是不是Templates类的对象，因为Templates是TemplatesImpl的父类，那么这肯定为true  
**  
注:  
class.inInstance(obj)  
这个对象能不能被转化为这个类  
1.一个对象是本身类的一个对象  
2.一个对象能被转化为本身类所继承类（父类的父类等）和实现的接口（接口的父接口）强转  
3.所有对象都能被Object的强转  
4.凡是null有关的都是false ，即class.inInstance(null)**  
此时将会调用getMemberMethods()函数，这个函数内部实际上就是返回annotation这个类的type变量对象的类的所有方法，那么这里实际上返回的就是Templates这个类的两个方法了  
①.Transformer newTransformer()  
②.Properties getOutputProperties()  
接下来就到了最终的漏洞触发点，我感觉叫链接点比较好，在这里通过反射机制来调用newTransformer(),其中var1就是我们之前构造的恶意的TemplatesImpl类  
这里我们来回顾一下getOutputProperties处，其中下面的newTransformer和上面反射的newTransformer完美的符合在一起  
此时由函数调用栈也可以看到此时回到了TemplateImpl这个类中，至此利用链分析结束  
# 3.从jdk7u25和jdk7u21的对比中分析修复
jdk7u25是jdk7u21的后一个版本，运行后结果如下图所示  
那么上面分析的利用AnnotationInvocationHandler作为动态代理打到newTransformer在jdk7u25中已经被修复，运行时将会报错如上图所示，其中是在反序列化的过程中有一步是通过反射机制调用了AnnotationInvocationHandler的readObject函数  
我们知道在yso的payload中通过反射机制来给AnnotationInvocationHandler的type赋值为Templates类  
那么再次执行下图代码：  
当执行hashset中第二个proxy对象的readObject时，实际上将会在其中调用AnnotationInvocationHandler的readObject函数来恢复动态代理，最终到readObject函数处  
此时的type为javax.xml.transform.Templates，进一步调用AnnotationType.getInstance  
跟进看看getInstance函数  
此时进一步调用Templates.getAnnotationType()函数  
此时返回为null，继续返回getInstance中  
此时var1为null，那么将Templates实例传入Annotationtype的构造函数  
此时在AnnotationType的构造函数将调用isAnnotation对var1进行判断  
那么明显Templates类跟annotation没关系，可以看到annotation和其他两种数据类型就是java类类型里面定义的，属于class类，即引用数据类型。比如最常见的枚举，枚举类型是Java
5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。这里实际getModifiers()就是取Templates的修饰符，而Templates是接口类型的，所以两者无关，所以二进制位不可能有所重合，即肯定&&后为0。  
所以此处必定进入if抛出错误  
所以回到AnnotationInvocationHandler的readObject中将捕获到该错误从而抛出`Non-annotation type in
annotation serial stream`  
再回到jdk7u21里面，我们可以看到这里虽然在annotationtype中也捕获到了type不满足条件，并抛出了错误  
但是catch以后直接retuen了，并没有再次抛出错误，让上层捕获，因此流程将继续走下去  
所以反序列化将会继续执行，并且能够恢复我们的动态代理Templates，感觉是个逻辑错误，开发人员可能一不注意就会犯错，要发现这些点对于安全研究人员来说开发技能也是必备的。
# 总结
前前后后分析下来也花了几个晚上，真是学到了不少。整个漏洞利用中包含了很多java中的技术点，最大的感受就是Java的反射特性真的是太重要了，可以说是无处不在2333。挖掘漏洞需要大量调试和分析，补漏洞在这里抛出一个错误就可以让漏洞消失，当然调试的过程中也更加熟悉了java这门语言。