# 【技术分享】关于HTTP Security Headers，你需要了解的一切
|
##### 译文声明
本文是翻译文章，文章来源：appcanary.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
翻译：[myswsun](http://bobao.360.cn/member/contribute?uid=2775084127)
预估稿费：200RMB
投稿方式：发送邮件至[linwei#360.cn](mailto:PI:EMAIL)，或登陆[网页版](http://bobao.360.cn/contribute/index)在线投稿
**  
**
**0x00 前言**
28年前，一些物理学家需要一种简单的分享实验数据的方法，因此网络诞生了。这被普遍认为是一个好的进步。不幸的是，物理学家接触的一切——从三角学到强大的核能，最终都被武器化了。超文本传输协议协议也是如此。
本文解释了什么是安全头和怎么在Rails、Django、Express.js、Go、Nginx和Apache中实现这些头。
请注意一些头最好是在你的HTTP服务器中配置，另外一些应该在应用层中设置。在这里由你自己权衡。你能使用Mozilla's
[Observatory](https://observatory.mozilla.org/analyze.html?host=appcanary.com)来测试你的实现。
**  
**
**0x01 HTTP Security Headers内容**
X-XSS-Protection
Content Security Policy
HTTP Strict Transport Security(HSTS)
HTTP Public Key Pinning(HPKP)
X-Frame-Options
X-Content-Type-Options
Referer-Policy
Cookie Options
**0x02 X-XSS-Protection**
    X-XSS-Protection: 0;
    X-XSS-Protection: 1;
    X-XSS-Protection: 1; mode=block
**为什么？**
跨站脚本通常的简写是XSS，是一种攻击手段，攻击者使一个页面加载一些恶意的javascript。X-XSS-Protection是Chrome和IE中的一个特性，被设计用来防御反射型XSS攻击——攻击者将恶意的payload作为请求的一部分发送。
X-XSS-Protection：0 关闭。
X-XSS-Protection：1 过滤来自请求的脚本，但是还是会交给页面。
X-XSS-Protection：1；mode=block 触发时，将阻止整个页面的呈现。
**是否该使用它？**
是的。需要设置X-XSS-Protection：1；mode=block
。但是有时过滤有问题的脚本是有问题的，查看[这里](http://blog.innerht.ml/the-misunderstood-x-xss-protection/)了解为什么。
**怎么做？**
**了解更多**
[X-XSS-Protection – MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection)
**0x03 Content Security Policy**
    Content-Security-Policy: 
**为什么？**
内容安全策略可以认为是X-XSS-Protection的高级版本。尽管X-XSS-Protection能阻止来自请求的脚本，但是它不能阻止一些XSS攻击，如在你服务器上面存储恶意脚本或者使用恶意脚本加载额外的资源。
CSP提供了一种语言，来定义浏览器能加载来自哪的资源。你能以非常详细的方式来列出原始的脚本、图片、字体和样式等的白名单列表。你还能使用哈希和特征来比较任何加载的资源。
**是否该使用它？**
是的。虽然它不能阻止所有的XSS攻击，但是它是缓解XSS攻击的一个重要的措施，并且是深度防御的重要的一个环节。它可能很难实现。如果你是一个勇敢的读者并继续阅读，校验[appcanary.com](https://appcanary.com/)返回的头，你将会看到我们并没有实现CSP。有一些rails开发插件可以使用，避免了自己实现CSP，但也能有实际的安全作用。
**怎么做？**
写一个CSP策略可能是个挑战。参考[此处](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)，是你能使用的所有指令的列表。从[这里](https://csp.withgoogle.com/docs/adopting-csp.html)开始比较好。
**了解更多**  
[Content-Security-Policy – MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)
[CSP Quick Reference Guide](https://content-security-policy.com/)
[Google’s CSP Guide](https://csp.withgoogle.com/docs/index.html)
**  
**
**0x04 HTTP Strict Transport Security(HSTS)**
    Strict-Transport-Security: max-age=
    Strict-Transport-Security: max-age=; includeSubDomains
    Strict-Transport-Security: max-age=; preload
**为什么？**
当我们想与一些人安全通信时，我们面对了两个问题。第一个问题是隐私：我们想确保我们发送的消息只能接收者看到。另一个问题是认证：我们如何知道接收者是他们自己说的那个人？
HTTPS使用加密解决了第一个问题，但是还有个认证问题（稍后详述，参见Public Key
Pinning）。HSTS头解决了元问题：你如何知道与你通信的人是否支持加密？
HSTS缓解了一种成为[sslstrip](https://moxie.org/software/sslstrip/)的攻击。假设你使用的是恶意攻击者控制的WIFI路由器提供的网络。攻击者可以禁用你和你访问的网站之间的加密机制。即使你访问的网站只能通过HTTPS访问，攻击者还是可以使用中间人攻击HTTP流量，来使得网站看起来工作在未加密的HTTP上。不需要SSL证书，只要禁用加密就可以。
通过让你的浏览器知道它必须总是使用加密访问网站，Strict-Transport-Security头解决了这个问题，除非你的浏览器看到了HSTS头并且没有过期，否则将无法访问未加密的网站，并且如果不经过HTTPS则会出错。
**是否应该使用它？**
是的。你的应用只能通过HTTPS访问，对吗？尝试通过老的HTTP访问将重定向到安全站点，对吗？（提示：如果你想避免商业证书颁发机构的证书可以使用[letsencrypt](https://letsencrypt.org/)。）
HSTS头的一个缺点是，它允许使用一种[聪明的技术](http://www.radicalresearch.co.uk/lab/hstssupercookies)来创建supercookies来作为用户的指纹。作为一个网站的运营者，你可能已经有些方式跟踪了你的用户，但是尝试只使用HSTS是更好的方式并且不使用supercookies。
**怎么做？**
有两个选项：
includeSubDomains——HSTS适用于子域名
preload——谷歌维护了一个服务，在浏览器中硬编码你的网站为HTTPS访问。通过这种方式，一个用户甚至不得不访问你的网站：他们的浏览器已经知道了它应该拒绝未加密的连接。顺便说一句，选择列表是很困难的，因此最好仅在你知道你的所有的子域名都永久支持HTTPS的情况下才开启它。
**了解更多**
[RFC 6797](https://tools.ietf.org/html/rfc6797)
[Strict-Transport-Security – MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security)
**0x05 HTTP Public Key Pinning(HPKP)**
    Public-Key-Pins: pin-sha256=; max-age=;
    Public-Key-Pins: pin-sha256=; max-age=; includeSubDomains
    Public-Key-Pins: pin-sha256=; max-age=; report-uri=
**为什么？**