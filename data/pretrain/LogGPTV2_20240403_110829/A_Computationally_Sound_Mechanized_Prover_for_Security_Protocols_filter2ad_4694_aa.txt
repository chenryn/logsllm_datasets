title:A Computationally Sound Mechanized Prover for Security Protocols
author:Bruno Blanchet
A Computationally Sound Mechanized Prover for Security Protocols
Bruno Blanchet
CNRS, ´Ecole Normale Sup´erieure, Paris
PI:EMAIL
Abstract
We present a new mechanized prover for secrecy proper-
ties of cryptographic protocols. In contrast to most previous
provers, our tool does not rely on the Dolev-Yao model, but
on the computational model. It produces proofs presented
as sequences of games; these games are formalized in a
probabilistic polynomial-time process calculus. Our tool
provides a generic method for specifying security properties
of the cryptographic primitives, which can handle shared-
and public-key encryption, signatures, message authentica-
tion codes, and hash functions. Our tool produces proofs
valid for a number of sessions polynomial in the security
parameter, in the presence of an active adversary. We have
implemented our tool and tested it on a number of examples
of protocols from the literature.
1 Introduction
There exist two main frameworks for studying cryp-
In the computational model, mes-
tographic protocols.
sages are bitstrings, and the adversary is a probabilistic
polynomial-time Turing machine. This model is close to
the real execution of protocols, but the proofs are usually
manual and informal. In contrast, in the formal, Dolev-Yao
model, cryptographic primitives are considered as perfect
blackboxes, modeled by function symbols in an algebra of
terms, possibly with equations. The adversary can compute
using these blackboxes. This abstract model makes it pos-
sible to build automatic veriﬁcation tools, but the security
proofs are in general not sound with respect to the compu-
tational model.
Since the seminal paper by Abadi and Rogaway [3],
there has been much interest in relating both frameworks
(see for example [1, 8, 11, 21, 25, 26, 35, 36]), to show the
soundness of the Dolev-Yao model with respect to the com-
putational model, and thus obtain automatic proofs of pro-
tocols in the computational model. However, this approach
has limitations: since the computational and Dolev-Yao
models do not correspond exactly, additional hypotheses are
necessary in order to guarantee soundness. (For example,
key cycles have to be excluded, or a speciﬁc security deﬁni-
tion of encryption is needed [5].)
In this paper, we propose a different approach for au-
tomatically proving protocols in the computational model:
we have built a mechanized prover that works directly in
the computational model, without considering the Dolev-
Yao model. Our tool produces proofs valid for a number of
sessions polynomial in the security parameter, in the pres-
ence of an active adversary. These proofs are presented as
sequences of games, as used by cryptographers [15, 42, 43]:
the initial game represents the protocol to prove; the goal is
to show that the probability of breaking a certain security
property (secrecy in this paper) is negligible in this game;
intermediate games are obtained each from the previous one
by transformations such that the difference of probability
between consecutive games is negligible; the ﬁnal game
is such that the desired probability is obviously negligible
from the form of the game. The desired probability is then
negligible in the initial game.
We represent games in a process calculus. This calculus
is inspired by the pi-calculus, and by the calculi of [31, 32,
37] and of [30]. In this calculus, messages are bitstrings,
and cryptographic primitives are functions from bitstrings
to bitstrings. The calculus has a probabilistic semantics,
and all processes run in polynomial time. The main tool for
specifying security properties is observational equivalence:
Q is observationally equivalent to Q(cid:2), Q ≈ Q(cid:2), when the
adversary has a negligible probability of distinguishing Q
from Q(cid:2). With respect to previous calculi mentioned above,
our calculus introduces an important novelty which is key
for the automatic proof of cryptographic protocols: the val-
ues of all variables during the execution of a process are
stored in arrays. For instance, x[i] is the value of x in the
i-th copy of the process that deﬁnes x. Arrays replace lists
often used by cryptographers in their manual proofs of pro-
tocols. For example, consider the deﬁnition of security of
a message authentication code (mac). Informally, this def-
inition says that the adversary has a negligible probability
of forging a mac, that is, that all correct macs have been
computed by calling the mac oracle. So, in cryptographic
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
proofs, one deﬁnes a list containing the arguments of calls
to the mac oracle, and when checking a mac of a message
m, one can additionally check that m is in this list, with a
negligible change in probability. In our calculus, the argu-
ments of the mac oracle are stored in arrays, and we perform
a lookup in these arrays in order to ﬁnd the message m. Ar-
rays make it easier to automate proofs since they are always
present in the calculus: one does not need to add explicit
instructions to insert values in them, in contrast to the lists
used in manual proofs. Therefore, many trivially sound but
difﬁcult to automate syntactic transformations disappear.
Our prover relies on a collection of game transforma-
tions, in order to transform the initial protocol into a game
on which the desired security property is obvious. The most
important kind of transformations comes from the deﬁni-
tion of security of cryptographic primitives. As described
in Section 3.2, these transformations can be speciﬁed in
a generic way: we represent the deﬁnition of security of
each cryptographic primitive by an observational equiva-
lence L ≈ R, where the processes L and R encode func-
tions: they input the arguments of the function and send its
result back. Then, the prover can automatically transform
a process Q that calls the functions of L (more precisely,
contains as subterms terms that perform the same computa-
tions as functions of L) into a process Q(cid:2) that calls the func-
tions of R instead. We have used this technique to specify
several variants of shared- and public-key encryption, sig-
nature, message authentication codes, and hash functions,
simply by giving the appropriate equivalence L ≈ R to the
prover. Other game transformations are syntactic transfor-
mations, used in order to be able to apply the deﬁnition of
cryptographic primitives, or to simplify the game obtained
after applying these deﬁnitions.
In order to prove protocols, these game transformations
are organized using a proof strategy based on advice: when
a transformation fails, it suggests other transformations that
should be applied before, in order to enable the desired
transformation. Thanks to this strategy, protocols can often
be proved in a fully automatic way. For delicate cases, our
prover has an interactive mode, in which the user can man-
ually specify the transformations to apply. It is usually suf-
ﬁcient to specify a few transformations coming from the se-
curity deﬁnitions of primitives, by indicating the concerned
cryptographic primitive and the concerned secret key if any;
the prover infers the intermediate syntactic transformations
by the advice strategy. This mode is helpful for proving
some public-key protocols, in which several security deﬁ-
nitions of primitives can be applied, but only one leads to
a proof of the protocol. Importantly, our prover is always
sound: whatever indications the user gives, when the prover
shows a security property of the protocol, the property in-
deed holds assuming the given hypotheses on the crypto-
graphic primitives.
Our prover CryptoVerif has been implemented in Ocaml
(9700 lines of code) and is available at http://www.di.
ens.fr/˜blanchet/cryptoc-eng.html.
Related Work Results that show the soundness of the
Dolev-Yao model with respect to the computational model,
e.g. [21, 26, 36], make it possible to use Dolev-Yao provers
in order to prove protocols in the computational model.
However, these results have limitations, in particular in
terms of allowed cryptographic primitives (they must satisfy
strong security properties so that they correspond to Dolev-
Yao style primitives), and they require some restrictions on
protocols (such as the absence of key cycles).
Several frameworks exist for formalizing proofs of pro-
tocols in the computational model. Backes, Pﬁtzmann,
and Waidner [6, 8, 9] have designed an abstract crypto-
graphic library including symmetric and public-key en-
cryption, message authentication codes, signatures, and
nonces and shown its soundness with respect to compu-
tational primitives, under arbitrary active attacks. Backes
and Pﬁtzmann [7] relate the computational and formal no-
tions of secrecy in the framework of this library. Recently,
this framework has been used for a computationally-sound
machine-checked proof of the Needham-Schroeder-Lowe
protocol [44]. Canetti [19] introduced the notion of uni-
versal composability. With Herzog [20], they show how
a Dolev-Yao-style symbolic analysis can be used to prove
security properties of protocols within the framework of
universal composability, for a restricted class of protocols
using public-key encryption as only cryptographic prim-
itive. Then, they use the automatic Dolev-Yao veriﬁca-
tion tool Proverif [16] for verifying protocols in this frame-
work. Lincoln, Mateus, Mitchell, Mitchell, Ramanathan,
Scedrov, and Teague [31, 32, 34, 37, 41] developed a proba-
bilistic polynomial-time calculus for the analysis of crypto-
graphic protocols. They deﬁne a notion of process equiva-
lence for this calculus, derive compositionality properties,
and deﬁne an equational proof system for this calculus.
Datta, Derek, Mitchell, Shmatikov, and Turuani [22] have
designed a computationally sound logic that enables them
to prove computational security properties using a logical
deduction system. These frameworks can be used to prove
security properties of protocols in the computational sense,
but except for [20] which relies on a Dolev-Yao prover, they
have not been mechanized up to now, as far as we know.
Laud [28] designed an automatic analysis for proving se-
crecy for protocols using shared-key encryption, with pas-
sive adversaries. He extended it [29] to active adversaries,
but with only one session of the protocol. This work is the
closest to ours. We extend it considerably by handling more
primitives, and a polynomial number of sessions.
Recently, Laud [30] designed a type system for proving
security protocols in the computational model. This type
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
system handles shared- and public-key encryption, with an
unbounded number of sessions. This system relies on the
Backes-Pﬁtzmann-Waidner library. Type inference has not
been implemented yet, and we believe that it would not be
obvious to automate.
Barthe, Cerderquist, and Tarento [10, 45] have formal-
ized the generic model and the random oracle model in
the interactive theorem prover Coq, and proved signature
schemes in this framework. In contrast to our specialized
prover, proofs in generic interactive theorem provers require
a lot of human effort, in order to build a detailed enough
proof for the theorem prover to check it.
Halevi [24] explains that implementing an automatic
prover based on sequences of games would be useful, and
suggests ideas in this direction, but does not actually imple-
ment one.
Outline The next section presents our process calculus for
representing games. Section 3 describes the game trans-
formations that we use for proving protocols. Section 4
gives criteria for proving secrecy properties of protocols.
Section 5 explains how the prover chooses which transfor-
mation to apply at each point. Section 6 presents our ex-
perimental results, and Section 7 concludes. The compan-
ion technical report [17] contains additional formal details,
proof sketches, and details on the modeling of some crypto-
graphic primitives.
Notations We recall the following standard notations. We
denote by {M1/x1, . . . , Mm/xm} the substitution that re-
places xj with Mj for each j ≤ m. The cardinal of a set or
multiset S is denoted |S|. If S is a ﬁnite set, x R← S chooses
a random element uniformly in S and assigns it to x. If A is
a probabilistic algorithm, x ← A(x1, . . . , xm) denotes the
experiment of choosing random coins r and assigning to x
the result of running A(x1, . . . , xm) with coins r. Other-
wise, x ← M is a simple assignment statement.
2 A Calculus for Games
2.1 Syntax and Informal Semantics
The syntax of our calculus is summarized in Figure 1.
We denote by η the security parameter, which determines in
particular the length of keys.
This calculus assumes a countable set of channel names,
denoted by c. There is a mapping maxlenη from channels
to integers, such that maxlenη(c) is the maximum length
of a message sent on channel c. Longer messages are trun-
cated. For all c, maxlenη(c) is polynomial in η. (This is
key to guaranteeing that all processes run in probabilistic
polynomial time.)
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
M, N ::=
i
x[M1, . . . , Mm]
f (M1, . . . , Mm)
terms
replication index
variable access
function application
input process
Q ::=
0
Q | Q(cid:2)
!i≤nQ
newChannel c; Q
c[M1, . . . , Ml](x1[(cid:2)i] : T1, . . . , xk[(cid:2)i] : Tk); P
nil
parallel composition
replication n times