Comp,∆(K, ω) to compute Comp(FK(∆, τ1), . . . , FK (∆,
τn), ~z) for many diﬀerent ∆. Second, the eﬃciency property
puts a restriction only on the running time of CFEvalon. This
is related to the previous remark, and it captures the idea
of achieving eﬃciency in an amortized sense when consider-
ing many evaluations of Comp(FK (∆, τ1), . . . , FK(∆, τn), ~z),
each with a diﬀerent data set identiﬁer ∆. More concretely,
this means that one can precompute ω once, and then use it
to run CFEvalon as many times as he needs, almost for free.
It is worth noting that the structure of Comp may en-
force some constraints on the range R of the PRF, and
that due to the pseudorandomness property, the output dis-
tribution of CFEvalon
Comp, ˜τ (K, ~z)) (over the
random choice of K) is computationally indistinguishable
from the output distribution of Comp(R1, . . . , Rn, ~z) (over
the random choices of the Ri ∈ R).
Comp,∆(K, CFEvaloﬀ
4.3 A PRF with Amortized Closed-Form Efﬁ-
ciency for GroupEval
We propose an eﬃcient construction of a pseudorandom
function which satisﬁes amortized closed-form eﬃciency for
the algorithm GroupEval, given in Section 4.1.
Our PRF construction uses two generic pseudorandom
functions which map binary strings to integers in Zp (where
p is a suﬃciently large prime number), together with a weak
PRF whose security relies on the Decision Linear assump-
tion, ﬁrst introduced by Boneh, Boyen, and Shacham [11].
Our pseudorandom function. Here we describe our PRF
with amortized closed-form eﬃciency:
KG(1λ). Let bgpp = (p, G, GT , e, g) be a bilinear group de-
scription. The key generation chooses two seeds K1, K2 for
a family of PRFs F′
p. Finally, it outputs
K = (bgpp, K1, K2) and pp = bgpp. The parameters de-
ﬁne a function F with domain X = {0, 1}∗ × {0, 1}∗ and
range G, as described below.
K1,2 : {0, 1}∗ → Z2
FK (x). Let x = (∆, τ ) ∈ X be the input value. To compute
the corresponding output R ∈ G, the algorithm generates
values (u, v)←F′
K2 (∆), and then out-
puts R = gua+vb.
K1 (τ ) and (a, b)←F′
We ﬁrst show that the above function is pseudorandom,
and then we will show that it admits amortized closed-form
eﬃciency for GroupEval.
Theorem 1. If F′ is a pseudorandom function and the
Decision Linear assumption holds for G, then the function
(KG, F) described above is a pseudorandom function.
For lack of space, the proof of Theorem 1 appears only in
the full version of this work. Here we notice that the pseudo-
randomness essentially follows from the security of the PRF
F′, and the fact that R = gua+vb = U aV b = fa,b(U, V ) is a
weak pseudorandom function under the Decision Linear as-
sumption. To prove the weak pseudorandomness of fa,b(·, ·)
we use the random self-reducibility property of the Decision
Linear problem, shown in Lemma 7 in [34].
Amortized Closed-Form Efficiency. Here we show that
the pseudorandom function described before satisﬁes amor-
tized closed-form eﬃciency for (GroupEval, ~L).
CFEvaloﬀ
GroupEval, ˜τ (K, f ). Let K = (bgpp, K1, K2) be a secret
key as generated by KG(1λ). For i = 1 to n, compute
(ui, vi)←F′
K1 (τi), and set ~ρi = (0, ui, vi): ~ρi are essentially
the coeﬃcients of a degree-1 polynomial ρi(z1, z2) in two
(unknown) variables z1, z2.
Next, run ~ρ←PolyEval(2, f, ρ1, . . . , ρn) to compute the co-
eﬃcients ~ρ of a polynomial ρ(z1, z2) such that ∀z1, z2 ∈ Zp
it holds ρ(z1, z2) = f (ρ1(z1, z2), . . . , ρn(z1, z2)).
Finally, output ωf = ~ρ.
CFEvalon
GroupEval,∆(K, ωf ). Let K = (bgpp, K1, K2) be a se-
cret key and let ωf = ~ρ be as computed by the previous
algorithm. The online evaluation algorithm ﬁrst generates
(a, b)←F′
K2 (∆), and then it uses the coeﬃcients ~ρ to com-
pute w = ρ(a, b), and it ﬁnally outputs W = e(g, g)w.
We observe that the complexity of the online algorithm de-
pends on the size of ~ρ, hence on the number of coeﬃcients
of a two-variate polynomial whose degree is the same as
In general, for f of degree d, this would
the degree of f .
be |~ρ| = (cid:0)d+2
d (cid:1). Considering our speciﬁc case of GroupEval
which evaluates arithmetic circuits of degree at most 2, and
by observing that the degree-0 coeﬃcient is always 0, we ob-
tain a vector ~ρ which can be represented with 5 elements of
Zp. Moreover, we observe the interesting fact that, due to
the bound deg(f ) ≤ 2 and due to having only m = 2 vari-
ables, the computation of ~ρ using PolyEval(2, f, ρ1, . . . , ρn)
can be done at roughly the same cost of running f .
It is not hard to check that the above algorithms satisfy
the properties of correctness and amortized eﬃciency given
871in Deﬁnition 3. In particular, correctness follows from the
the correctness properties of PolyEval and GroupEval. A for-
mal proof of this property appears in the full version.
5. HOMOMORPHIC MACS WITH
EFFICIENT VERIFICATION
In this section, we describe our construction of homomorphic
MACs with eﬃcient veriﬁcation for multi-labeled programs
as introduced in Section 3.3.
In particular, the following
theorem summarizes the main result of this work which is
obtained by combining the EVH−MAC construction (see be-
low) and our concrete instantiation of the PRF with amor-
tized closed-form eﬃciency based on the Decision Linear as-
sumption (Section 4.3).
Theorem 2. If the Decision Linear assumption holds, then
EVH−MAC is a secure homomorphic message authentica-
tor which supports evaluations of any arithmetic circuit f
of degree at most 2, and achieves eﬃcient veriﬁcation, i.e.,
EVH−MAC has amortized eﬃciency in which the oﬄine ver-
iﬁcation VerPrep takes time O(|f |), and the online veriﬁca-
tion EﬀVer takes time O(1).
Our construction works for circuits whose additive gates
do not get inputs labeled by constants. As mentioned in [15],
this can be done without loss of generality as one can use an
equivalent circuit with a special variable/label for the con-
stant 1 and publish the MAC of 1. Our scheme EVH−MAC
is deﬁned as follows:
KeyGen(1λ). Run bgpp ←R G(1λ) to generate the descrip-
tion of bilinear groups. Let bgpp = (p, G, GT , e, g) as de-
ﬁned above. Let the message space M be Zp. Choose
a random value α ←R Zp, and run (K, pp) ←R KG(1λ)
to obtain the seed K of a pseudorandom function FK :
{0, 1}∗ × {0, 1}∗ → G. Output the secret key sk = (bgpp,
pp, K, α), and the evaluation key ek = (bgpp, pp).
Auth(sk, L, m). To authenticate a message m ∈ Zp with
multi-label L = (∆, τ ) where ∆ ∈ {0, 1}λ is the identi-
ﬁer of a data set and τ ∈ {0, 1}λ is an input identiﬁer,
proceed as follows. First, compute R←FK(∆, τ ) and then
compute values (y0, Y1) ∈ Zp × G by setting: y0 = m and
Y1 = (R · g−m)1/α. Finally, output the tag σ = (y0, Y1).
If we let y1 ∈ Zp be the (unique) value such that Y1 =
gy1 , then (y0, y1) are basically the coeﬃcients of a degree-
1 polynomial y(x) that evaluates to m on the point 0 (i.e.,
y(0) = m) and it evaluates to r = φ−1
g (R) on a hidden
random point α (i.e., y(α) = r).
p → Zp, and a vector ~σ of tags (σ1, . . . , σn).
Eval(ek, f, ~σ). The homomorphic evaluation algorithm takes
as input the evaluation key ek = (bgpp, pp), an arithmetic
circuit f : Zn
Eval proceeds gate-by-gate as follows. At every gate fg,
given two tags σ1, σ2 (or a tag σ1 and a constant c ∈ Zp),
it runs the algorithm σ←GateEval(ek, fg, σ1, σ2) described
below that returns a new tag σ, which is in turn passed
on as input to the next gate in the circuit. When the
computation reaches the last gate of the circuit f , Eval
outputs the tag vector σ obtained by running GateEval on
such last gate. To complete the description of Eval we thus
describe the subroutine GateEval:
GateEval(ek, fg, σ(1), σ(2)). Let σ(i) = (y(i)
2 ) ∈
Zp × G × GT for i = 1, 2 (see below for the special case
1 , ˆY (i)
0 , Y (i)
2
(1)
· Y (2)
1
1
(1) + y0
(2), Y1 = Y (1)
when one of the two inputs is a constant c ∈ Zp). For
ease of description, whenever ˆY (i)
is not deﬁned, we as-
sume ˆY (i)
2 = 1 ∈ GT . The goal is to compute (y0, Y1, ˆY2)
as follows. For an addition with gate f+, compute y0 =
y0
. For
(2),
a multiplication with gate f× compute y0 = y0
Y1 = (Y (1)
). Be-
cause of our assumption that deg (f ) ≤ 2, we can assume
that σ(i) = (y(i)
1 ) ∈ Zp × G for both i = 1, 2. For a
multiplication with a constant, where one of the two
(1),
inputs, say σ2, is a constant c ∈ Zp, compute y0 = c · y0
Y1 = (Y (1)
)c. Return σ = (y0, Y1, ˆY2).
0 , and ˆY2 = e(Y (1)
)c, and ˆY2 = (Y (1)
, and ˆY2 = ˆY (1)
2
(1) · y0
0 , Y (i)
· (Y (2)
)y
1
, Y (2)
1
(2)
0
)y
1
1
2
· ˆY (2)
2
1
Ver(sk, P∆, m, σ). Let sk = (bgpp, pp, K, α) be a secret key.
Let P∆ = (P, ∆) be a multi-labeled program for P =
(f, τ1, . . . , τn) and data set ∆. Let m ∈ Zp be the re-
sult to be veriﬁed, and let σ = (y0, Y1, ˆY2) be a tag. The
veriﬁcation proceeds as follows. For i = 1 to n, compute
Ri←FK (∆, τi). Then run W ←GroupEval(f, R1, . . . , Rn) ∈
GT , as described in Section 4.1. Finally, check the follow-
ing equations:
m = y0
W = e(g, g)y0 · e(Y1, g)α · ( ˆY2)α2
(2)
(3)
If both checks are satisﬁed, then output 1, and 0 otherwise.
Finally, to complete the description of EVH−MAC we give
the algorithms for eﬃcient veriﬁcation:
VerPrep(sk, P). Let P = (f, ~τ ) be a labeled program where
f ∈ Zn
p → Zp is an arithmetic circuit and ~τ = (τ1, . . . , τn)
is a vector of input identiﬁers for f . The algorithm com-
putes concise veriﬁcation information VKP = ω where ω is
obtained by using the oﬄine closed-form eﬃcient algorithm
of F for GroupEval, i.e., ω←CFEvaloﬀ
GroupEval, ˜τ (K, f ).
EﬀVer(sk, VKP , ∆, m, σ). Let sk = (bgpp, pp, K, α) be a se-
cret key. Let VKP = ω be the concise veriﬁcation infor-
mation for P. Let m ∈ Zp be the result to be veriﬁed
and let σ = (y0, Y1, ˆY2) be a tag. The online veriﬁcation
proceeds as follows. First, it runs the online closed-form
eﬃcient algorithm of F for GroupEval, in order to com-
pute W ←CFEvalon
GroupEval,∆(K, ω). Finally, it runs the same
checks (2) and (3) as in standard veriﬁcation.
If both
checks are satisﬁed, then output 1. Otherwise output 0.
Eﬃciency Analysis. We discuss the concrete eﬃciency
of our scheme when implemented with speciﬁc security pa-
rameters of 80 and 128 bits. In particular, we consider the
bandwidth costs for sending the MACs over the network,
and the computational timings of the various algorithms at
both the client and the server. The timings are obtained
by evaluating the most signiﬁcant operations performed by
our algorithms, namely modular exponentiations and pair-
ing computations. For our evaluation, we consider an imple-
mentation of Type-A (symmetric) pairings using the PBC
library [35], on an 2.5 GHz Intel Core i5 workstation run-
ning Mac OS X 10.8.3. The timings of all basic operations
needed by our scheme are summarized in Table 1. In addi-
tion, we note that by using 80 (resp. 128) bits of security, an
element of Zp can be represented with 160 (resp. 256) bits,
an element of G with 512 (resp. 1536) bits, and an element
of GT with 1024 (resp. 3072) bits. Most clients’ costs are
872Operation
Pairing