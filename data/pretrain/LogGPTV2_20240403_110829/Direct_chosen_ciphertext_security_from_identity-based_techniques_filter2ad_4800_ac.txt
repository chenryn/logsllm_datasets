such as CHK [11] and BK [8]. This is the reason why our
system is based on adaptive-identity secure IBE (although
we will see in Section 4 that selective-identity secure IBE is
enough if we forgo direct encryption and meander through
key encapsulation).
Formally, we have the following result, stated for the ﬁxed
injective encoding implementation for simplicity. Since the
formal argument for CCA2 security very much resembles
that of Waters [27] for adaptive-ID security, we defer the
proof to the full paper [9].2
Theorem 3.1. Suppose the (t0, 0)-Decision BDH assump-
tion holds in (G, ˆG), and assume that H0 : GT ×G → {0, 1}n
is an eﬃciently computable injection for some n. Then
the encryption system of Section 3.1 is (t, q, )-chosen ci-
phertext (IND-CCA2) secure for any q < p provided that
 ≥ 32(n + 1)q0 and t ≤ t0 − Θ(−2 ln(−1)λ−1 ln(λ−1)),
8(n+1)q , and where it is assumed that each ex-
where λ =
ponentiation, pairing, and evaluation of H0 takes constant
time.
3.4 Efﬁciency
1
Encryption in our scheme requires requires one exponen-
tiation in GT , two exponentiations in G, and an average of
n/2 (at most n) group operations in G which amount to
much less than an exponentiation. If the encryption party
is to send multiple messages under the same public key, then
all but one of the above exponentiations can be greatly ac-
celerated by using many well-known pre-computation tech-
niques for ﬁxed-base exponentiation. (In the same vein, the
can also be pre-computed and cached factor-
productQ uwi
by-factor or using ﬁxed-sized windows.)
Decryption requires one exponentiation in G and one bi-
i
linear pairing into GT .
2Instead, we give a formal proof for the simpler and equally
informative KEM construction of the next section.
4. TIGHT KEY ENCAPSULATION
FROM SELECTIVE-ID IBE
It is easy to turn our CCA2-secure encryption system
into a CCA2-secure Key Encapsulation Mechanism (KEM).
However, we can get a simpler construction with a tight secu-
rity reduction if we take the lesser requirements of the KEM
to our advantage and start from the Boneh-Boyen IBE [3].
4.1 KEM Construction
As before, we let G and ˆG be cyclic groups of prime order,
p, generated by g and h, and equipped with a bilinear map
e : G × ˆG → GT . We also assume the availability of either
a collision resistant family Hs : G → Zp or a ﬁxed injective
encoding H0 : G → Zp. Notice that unlike in Section 3
this time the domain of Hs or H0 is just G, and the range
is now Zp. As before we assume that the elements of G
have at least as small a representation as those of ˆG. The
key encapsulation scheme is described by the following three
algorithms.
Key Generation: A user’s public/private key pair gener-
ation algorithm proceeds as follows. First, a secret
α ∈ Zp is chosen at random, from which the values
h0 = hα and Z = e(g, h0) are calculated. Next, the
algorithm chooses y1 and y2 at random from Zp.
It
then calculates u1 = gy1 and u2 = gy2 . Finally, a
random seed s for the collision resistant family is cho-
sen, if needed (for convenience, we assume that s = 0
whenever the ﬁxed encoding H0 is used).
The published public key is
` s, Z = e(g, h)α, u1 = gy1 ,
u2 = gy2 ´ ∈ {s} × GT × G2,
` h0 = hα, y1, y2
´ ∈ ˆG × Z2
p.
and the private key is
Encapsulation: The generation and encapsulation of a ran-
dom session key works as follows. First, a value t ∈ Zp
is randomly chosen, and the algorithm computes the
ﬁrst element of the ciphertext: C1 = gt. Next, it com-
putes w ∈ Zp as w = Hs(C1), and then the second
2 )t. The com-
ciphertext element: C2 = ut
plete ciphertext, or encapsulated key, C, consists of
the two group elements
2 = (u1uw
1utw
` gt, ut
1utw
2
´ ∈ G2.
The session key, K, is calculated by the sender as the
group element K = Z t = e(g, h)αt ∈ GT .
Decapsulation: Let C = (C1, C2) be a ciphertext encap-
sulating some session key K. Before recovering K,
the algorithm must verify that the ciphertext is legit-
imate. To do so, the algorithm computes w = Hs(C1)
and w0 = y1 + y2 · w (mod p). It then computes C w0
and compares it with C2. If these two values are un-
equal, then (g, C1, u1uw
2 , C2) is not a Diﬃe-Hellman
tuple and the ciphertext is invalid. In this case, the
algorithm outputs ⊥ and halts. Otherwise, the algo-
rithm outputs the session key, K, which it obtains by
computing
1
e(C1, h0) = K ∈ GT .
4.2 Analogy to the Boneh-Boyen IBE
The encapsulation algorithm may be viewed as a vari-
ant of encryption where the message to be encrypted is the
constant M = 1 ∈ GT . With M = 1, the ﬁrst ciphertext
component would be C0 = M · Z t, which reduces to the ran-
dom blinding factor Z t. For key encapsulation, we suppress
this component from the ciphertext output, and instead use
it as the randomly generated session key K.
Aside from the fact that the above algorithms provide only
key encapsulation rather than true encryption, the system
bears the same relation to Boneh and Boyen’s selective-ID
semantically secure IBE [3] as the system of Section 3.1 did
to Waters’ IBE. The two diﬀer mainly in the construction of
the checksum component C2, and the related changes to the
public and private keys, as in one case the hashed identity
is used bit by bit and all at once in the other case.
It is easy to hash elements of G to Zp using a family of
collision resistant functions Hs. A diﬃculty arises in the case
where we wish to use a ﬁxed injective encoding H0. Since
|G| = |Zp| = p, it follows that H0 should be an (eﬃciently
computable) bijection, which might not be easy to come
by.
In reality, we only need H0 to be injective on most
of its domain, as long as we exclude the rest by using an
iterated hashing strategy until we hit the adequate portion
of the domain. We describe how to do this in a couple of
concrete elliptic curve implementations in the full version of
our paper [9].
4.3 Generalized Identity Hashing
2,1uw2
2 ) by (u1 · uw1
A more general way to enable the use of a ﬁxed injective
encoding H0 is to generalize the identity-dependent function
in the underlying Boneh-Boyen IBE. Speciﬁcally, we can re-
2,2 ··· uwν
place all occurrences of (u1 · uw
2,ν ),
where w = (w1, w2, . . . , wν )b is the representation of the
“identity” w in base p (or some ﬁxed base p0 ≤ p), and
u2,1, . . . , u2,ν are random elements of G we add to the public
key. We then select an injection H0 : G → (Zp)ν , which for
large enough ν is trivial to construct. The modiﬁcations to
the scheme and the security reduction are straightforward.
Note that the number ν of group elements intervening in
the above expression is signiﬁcantly smaller than the number
n of group elements that appear in the scheme of Section 3
(and the underlying Waters IBE scheme); speciﬁcally, we
save a factor n
4.4 Security and Efﬁciency
ν ≈ log2 p.
The security reasoning is similar to that of the encryp-
tion system, with one important diﬀerence. Since with key
encapsulation there is no message to encrypt, the challenge
ciphertext given to the adversary in the attack game does
not depend on input from the adversary. Since the simulator
can choose ahead of time the randomization value t∗ to be
used in the challenge ciphertext, it can therefore determine
(in IBE parlance) the challenge “identity” w∗ = Hs(C1) =
Hs(gt∗
) before interacting with the adversary. This brings
us in a similar situation as in the selective-identity IBE proof
of security of the Boneh-Boyen system, which is the reason
why we are able to construct a KEM using just the equiva-
lent of a selective-ID IBE system.
The security of the KEM follows from that C2 is func-
tionally dependent on C1 via w. The ﬁrst role of C2 is thus
to act as a checksum preventing the adversary from making
decryption queries on algebraic transformations of the C1
component of the challenge ciphertext. As before, C2 has a
second role, which is to help the simulator answer decryp-
tion queries (except on the challenge ciphertext), by way of
the underlying IBE system.
A crucial point to note is that, in the Boneh-Boyen IBE,
C1 is based on a generator g that in the simulation is passed
on unchanged to the adversary, and is independent of the
target identity.3 In the KEM, this translates into a chain of
maps C1 7→ w 7→ C2 that are preserved in the simulation,
and allow the challenge ciphertext to be constructed without
cyclic dependencies.4
Precisely, we have the following result, stated in the con-
text of a ﬁxed encoding for simplicity. The formal proof of
security in the full version of our paper [9].
Theorem 4.1. Suppose the (t0, 0)-Decision BDH assump-
tion holds in (G, ˆG), and let H0 : G → Zp be an eﬃciently
computable injection. Then the KEM system of Section 4.1
is (t, q, )-chosen ciphertext (KEM-CCA2) secure for any
q < p, any  ≥ 0 + q/2p, and any t ≤ t0 − Θ(q), where
it is assumed that each exponentiation, pairing, and evalua-
tion of H0 takes unit time.
In terms of eﬃciency, the encapsulation algorithm requires
one exponentation in G and one multi-exponentiation in G.
Decapsulation requires one exponentiation in G and one bi-
linear map.
In summary, compared to the encryption system, the key
encapsulation scheme beneﬁts from these advantages:
• Tight security reduction from the BDH assumption,
since the Boneh-Boyen IBE has tight security in selective-
identity attacks;
• Shorter public and private keys, requiring only O(1)
components, by contrast to the O(n) group elements
needed in the encryption system.
4.5 From KEM to Full Encryption
Naturally, once we have a KEM, it is easy to obtain a full
encryption system, where the sending party can choose the
message it wishes to transmit. This can be done with a hy-
brid system where the KEM key is used as a session key for
a symmetric cipher with a chosen ciphertext secure mode
of operation (itself possibly constructed using a MAC). The
beneﬁt of this construction is that it retains the tight secu-
rity reduction of our KEM. The drawback is that the sym-
metric cipher requires additional randomness, and for short
messages will result in longer ciphertexts overall than our
direct encryption system of the previous section.
5. PRACTICAL EXTENSIONS
We now describe a few extensions to the encryption and
encapsulation schemes of Sections 3 and 4.
3This would not be true of the second Boneh-Boyen IBE
(based on the BDHI assumption) [3, §5], in which the simu-
lator alters the generator given to the adversary in function
of the challenge identity.
4Stated diﬀerently, our KEM exploits the fact that the ﬁrst
Boneh-Boyen IBE (based on BDH) is secure against an ad-
versary that postpones the choice of a target ID until the
challenger has output “some” of the public parameters. In
the selective-ID attack model the adversary much make that
choice at the onset of the attack.
5.1 Public Validity Testing
Recall that in both systems, the decryptor needs to verify
the ciphertext before attempting to decrypt or decapsulate
it. In our descriptions, this test is eﬃciently performed using
a single exponentiation in G, but requires knowledge of the
private key (the exponents y0, y1, . . . , yn in the encryption
system, or the exponents y1, y2 in the KEM).
In the encryption system of Section 3.1, for example, if the
public key had included the ˆG-elements hy0
, hy1 , . . . , hyn in
addition to the G-elements u0, u1, . . . , un, then the validity
test could have been performed publicly, using additional
applications of the bilinear map, by testing whether the fol-
lowing ratio of bilinear pairings equals the identity element
in GT :
e`C1, (hy0
i=1(hyi )wi´
)Qn
e(C2, h)
?= 1.
Since under such modiﬁcation the ciphertext validity test
does no longer require the private key, we refer to it as the
public validity testing variant. The principle is the same for
the KEM scheme.
Public validity testing still results in chosen ciphertext
security,5 but it requires a lengthier public key. It also in-
creases the decryption burden by an amount of work com-
parable to a pairing computation (the public test depends
on the computation of a ratio of two pairings, which, in the
case of the Weil and Tate pairings can be done almost as ef-
ﬁciently as a single pairing, by modifying Miller’s algorithm
in a manner akin to multi-exponentiation [22]). Public va-
lidity testing is used below in the direct construction of a
provably CCA2-secure non-interactive threshold system.
5.2 Threshold Decryption
A k-out-of-m threshold public key encryption system is
one that allows the private key to be divided up into m
shares; each share can then be used to obtain a partial de-
cryption of any given ciphertext, in such a way that the
decrypted message can be reconstituted using any k partial
decryptions. In a non-interactive threshold system, no com-
munication is needed amongst the k parties performing the
partial decryptions, other than their (independent) trans-
mission of the decryption shares to the entity that performs
the ﬁnal reconstitution.
Existing CCA2-secure threshold systems in the standard
model, due to Canetti and Goldwasser [12], are based on
the Cramer-Shoup system [13]; their system requires inter-
action between the decryption parties, due to the fact that
in the Cramer-Shoup system only parties possessing the pri-
vate key can check ciphertext validity, which makes thresh-
old decryption non-trivial.
Boneh and Boyen [3] and Canetti, Halevi, and Katz [11]
recently suggested (without details) to use the BB scheme
in combination with the CHK transformation to construct
non-interactive CCA2 threshold cryptosystems without ran-
dom oracles; the details of such a construction were recently
worked out in [5]. Their approach starts from the Boneh-
Boyen IBE system, suitably modiﬁed to provide threshold
private key generation; it is then generically transformed