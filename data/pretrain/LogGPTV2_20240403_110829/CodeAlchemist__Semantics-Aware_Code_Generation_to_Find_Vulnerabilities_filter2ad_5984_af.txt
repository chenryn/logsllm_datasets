The ﬁrst statement declares an Object that has both
(1) a property p and (2) the corresponding getter for the
property. The second statement deﬁnes a function, and the third
statement deﬁnes a property named “0” for the Object s0.
After the property is deﬁned, the JS engine traverses an internal
dictionary that stores the mapping from a property name to a
property object, and creates a new object that contains both the
property 0 and p. At this point, the engine incorrectly judges
the type of the property p as a ‘getter’ function type even
though it is an integer value. Due to this incorrect type casting,
a type confusion vulnerability triggers. Next, when the function
s1 is called, it accesses the property p of s0. However, due to
the type confusion, this access tries to dereference an invalid
getter function pointer, which causes a segmentation fault.
Note that generating such a code snippet is not trivial
as each statement is deeply related to each other. The vari-
able s0 is used by both the function call statement and
the defineProperty method. The function s1 should be
deﬁned ﬁrst and then be invoked with s0 as its parame-
ter. CodeAlchemist used the four code bricks annotated in
Figure 10 to generate the test case: a code brick for the
variable declaration statement (Var1), a code brick for the
function declaration statement (Func2), and two code bricks
for the expression statements (Expr3, Expr4). They have
the following assembly constraints.
1)
2)
3)
4)
{} → Var1 → {s0: Object}
{} → Func2 → {s1: Function}
{s0: Object} → Expr3 → {s0: Object}
{s0: Object, s1: Function}
→ Expr4 → {s0: Object, s1: Function}
CodeAlchemist successfully assembled the code bricks based
on their assembly constraints to generate the test case trigger-
ing the vulnerability.
VII. DISCUSSION
Seed Selection. Semantics-aware assembly is essentially
a seed-based fuzzing approach. Thus, collecting and selecting
good seeds may substantially affect the performance of fuzzing
as it does not create object types that are never seen in seeds.
In our experiments, we obtained a set of seeds from existing
JS test suites, but we believe CodeAlchemist can beneﬁt by
adopting state-of-the-art seed selection strategies [23], [25].
Additionally, automated seed generation techniques such as
Skyﬁre [35] may help expand our seed pool.
Code Brick Selection. CodeAlchemist currently selects
code bricks to be used next at random for every iteration.
However, we believe that devising an intelligent code brick
selection strategy can improve the fuzzing effectiveness. Al-
though our current design choice is to follow a complete black-
box approach as in LangFuzz [17], it is possible to employ a
grey-box approach where the code brick selection is directed
by code coverage or similar metrics. In addition, selecting
the next code brick with probabilistic language models as in
Skyﬁre [35] and TreeFuzz [24] can be effective in terms of
bug ﬁnding. We believe this is an interesting future work.
Supporting Other Targets. It is straightforward to apply
semantics-aware assembly to test other language interpreters
or compilers because the core idea of our approach in assem-
bling code bricks is indeed language agnostic. Furthermore,
semantics-aware assembly can be more effective if it is used
with statically-typed languages such as C and C++, because we
can easily infer types of a variable without instrumenting the
code. We leave it as future work to extend our algorithm to test
compilers of other programming languages. We also believe
we can apply our technique to ﬁnd bugs in JS bindings [5],
which input is allowed to contain JS code snippets, such as
Node.js and PDF readers.
13
VIII. RELATED WORK
A. Fuzzing
Fuzzing is a software testing technique for ﬁnding security
vulnerabilities. It has been used by many security practitioners
and researchers due to its signiﬁcant practical impact. Fuzzing
is typically divided into two major categories: mutation-based
and generation-based fuzzing. Mutation-based fuzzers such as
AFL [40] typically take in a set of seeds, and output test
cases by mutating the seeds. There has been a surging interest
on improving the effectiveness of mutation-based fuzzers [6],
[25], [36]. On the other hand, generation-based fuzzers produce
test cases based on a model, e.g., a grammar [17], [38].
IMF [14], for instance, automatically infers a model between
system calls, and uses the model to produce a sequence of
system calls to fuzz kernel code. CodeAlchemist is also in the
category of generation-based fuzzing.
There are several previous generation-based fuzzers for
testing interpreters and compilers. Most of them focus on
generating syntactically valid programs based on a model to
traverse deep in the interpreter (compiler). Since the very ﬁrst
thing that interpreters (compilers) do is to check whether a
given program is syntactically valid, generating syntactically
valid programs help traverse deep execution paths of the
interpreter (compiler) under test.
There are several existing JS engine fuzzers that gener-
ate test cases based on pre-deﬁned generation rules rather
than relying on a complete language grammar. For example,
domato [11] generates HTML, CSS, JS code to test DOM
renderers of web browsers, and esfuzz [10] generates tests
for ECMAScrirpt parsers. In addition, jsfunfuzz [27], which
is a state-of-the-art JS engine fuzzer maintained by Mozilla,
contains a huge number of generation rules that are manually
built into the fuzzer.
Unfortunately, such fuzzers cannot create context-sensitive
test cases by its design. Recall from §III, jsfunfuzz mainly
focuses on syntactic, but not semantic validity of test cases it
generates. It tries to heuristically mitigate runtime errors by
variable renaming, but it still suffers from a high error rate
based on our study. As such, ﬁnding new security vulnerabil-
ities with jsfunfuzz is becoming difﬁcult as our experimental
results show.
In addition, Dewey et al. [8] address the problem of
reducing runtime errors. Speciﬁcally, they propose a novel
generation-based fuzzing algorithm that leverages constraint
logic programming. The idea is to drive the test case gen-
eration towards speciﬁc language features with user-provided
constraints. However, their approach requires an analyst to
manually provide such constraints prior to fuzzing.
Several JS engine fuzzers try to generate test cases based
on a set of given seeds. They fragmentize the seeds and re-
assemble the fragments to generate test cases. LangFuzz [17],
the most successful JS engine fuzzer in this category, gen-
erates fragments by parsing down a given set of seeds into
code fragments. It then mutates the seeds by replacing AST
subtrees with the generated fragments. GramFuzz [13] and
BlendFuzz [37] use the same intuition as LangFuzz, but they
focus on other languages such as HTML, CSS, as well as JS.
IFuzzer [33] improves upon LangFuzz by employing genetic
programming to generate unseen JS test cases. TreeFuzz [24]
and Skyﬁre [35] construct probabilistic language models from
a given set of seeds in order to generate valid JS code snippets.
None of the seed-based JS engine fuzzers deal with runtime
errors while generating test cases.
B. JavaScript Analysis
JavaScript has become one of the most popular program-
ming languages because of its ﬂexibility, which enables pro-
grammers to write simple code fast. In contrast, the ﬂexibility
of the language raises the bar for traditional program analy-
ses [26]. For example, the dynamic type system and the use
of eval make analyzing JS painful as we discussed in §II-A.
Thus, there has been much research on JS program analysis.
Dynamic instrumentation forms a basis for dynamic anal-
yses, and there are several attempts that use dynamic instru-
mentation on JS code. Yu et al. [39] rewrite and instrument
JS code to detect security policy violation. Sen et al. [28]
present a dynamic analysis framework for JS, which provides a
general-purpose dynamic JS code instrumentation mechanism.
CodeAlchemist also employs the similar technique in order to
obtain types of variables in code bricks.
Many researchers have built static type systems for JS
starting from the seminal works by Anderson et al. [2]
and Thiemann et al. [32]. Their approaches support only
limited language features. Guha et al. [12] present λJS, a
core language that embodies essential JS features including
prototypes and ﬁrst-class functions. Lerner et al. [18] propose
a general framework for building JS type systems based upon
λJS. Chandra et al. [7] handle a rich subset of JS, which
can compute types for uninvoked functions. Our approach
can beneﬁt from the above approaches as we can make our
assembly constraints more precise. We refer to recent survey
papers [3], [29] for a more detailed overview of this area.
IX. CONCLUSION
We have presented CodeAlchemist, the ﬁrst fuzzing system
that generates semantically valid test cases for JS engines.
CodeAlchemist learns the language semantics from a corpus
of JS seed ﬁles, and generates a pool of code bricks that
can be assembled later to construct semantically valid JS
code snippets. We leverage both static and dynamic analysis
technique to infer types of variables in each code brick, and
use the information to build assembly constraints for each code
brick, which help CodeAlchemist in judging which code bricks
can be put together in which order. This simple approach
signiﬁcantly reduced runtime errors for JS engine fuzzing
while producing highly-constructed test cases. CodeAlchemist
found 19 bugs in the four major JS engines. We have reported
all our ﬁndings to the vendors.
ACKNOWLEDGEMENT
We thank our shepherd, Deian Stefan, and the anonymous
reviewers for their helpful feedback. We also would like
to thank Jaeseung Choi for fruitful discussion. This work
was supported by Institute for Information & communications
Technology Promotion (IITP) grant funded by the Korea gov-
ernment (MSIT) (No.B0717- 16-0109, Building a Platform for
Automated Reverse Engineering and Vulnerability Detection
with Binary Code Analysis).
14
REFERENCES
[1] A. V. Aho, M. S. Lam, R. Sethi, and J. D. Ullman, Compilers:
Principles, Techniques, and Tools. Addison Wesley, 2006.
[2] C. Anderson, P. Giannini, and S. Drossopoulou, “Towards type inference
for javascript,” in Proceedings of the ACM European Conference on
Object-Oriented Programming, 2005, pp. 428–452.
[3] E. Andreasen, L. Gong, A. Møller, M. Pradel, M. Selakovic, K. Sen,
and C.-A. Staicu, “A survey of dynamic analysis and test generation for
JavaScript,” ACM Computing Surveys, vol. 50, no. 5, pp. 66:1–66:36,
2017.
[4] Apple Inc., “WTFCrash in JavaScriptCore,” https://github.com/WebKit/
webkit/blob/82bae82cf0f329dbe21059ef0986c4e92fea4ba6/Source/
WTF/wtf/Assertions.cpp#L261.
[5] F. Brown, S. Narayan, R. S. Wahby, D. Engler, R. Jhala, and D. Stefan,
“Finding and preventing bugs in javascript bindings,” in Proceedings of
the IEEE Symposium on Security and Privacy, 2017, pp. 559–578.
[6] S. K. Cha, M. Woo, and D. Brumley, “Program-adaptive mutational
the IEEE Symposium on Security and
fuzzing,” in Proceedings of
Privacy, 2015, pp. 725–741.
[7] S. Chandra, C. S. Gordon, J.-B. Jeannin, C. Schlesinger, M. Sridharan,
F. Tip, and Y. Choi, “Type inference for static compilation of javascript,”
in Proceedings of the ACM SIGPLAN International Conference on
Object Oriented Programming Systems Languages & Applications,
2016, pp. 410–429.
[8] K. Dewey, J. Roesch, and B. Hardekopf, “Language fuzzing using
the International
constraint
Conference on Automated Software Engineering, 2014, pp. 725–730.
logic programming,” in Proceedings of
[9] Ecma International, “ECMAScript 2015 language speciﬁcation,” https:
//www.ecma-international.org/ecma-262/6.0/, 2015.
I. Fratric, “domato,” https://github.com/google/domato.
[10] M. Ficarra and B. Zhang, “esfuzz,” https://github.com/estools/esfuzz.
[11]
[12] A. Guha, C. Saftoiu, and S. Krishnamurthi, “The essence of JavaScript,”
in Proceedings of the ACM European Conference on Object-Oriented
Programming, 2010, pp. 126–150.
[13] T. Guo, P. Zhang, X. Wang, and Q. Wei, “GramFuzz: Fuzzing testing
of web browsers based on grammar analysis and structural mutation,”
in Proceedings of the International Conference on Informatics Appli-
cations, 2013, pp. 212–215.
[14] H. Han and S. K. Cha, “IMF: Inferred model-based fuzzer,” in Pro-
ceedings of the ACM Conference on Computer and Communications
Security, 2017, pp. 2345–2358.
[15] A. Hidayat, “Esprima,” http://esprima.org/.
[16] C. Holler, “Security testing at Mozilla,” http://issta2016.cispa.saarland/
security-testing-at-mozilla/, keynote at ISSTA 2016.
[17] C. Holler, K. Herzig, and A. Zeller, “Fuzzing with code fragments,” in
Proceedings of the USENIX Security Symposium, 2012, pp. 445–458.
[18] B. S. Lerner, J. G. Politz, A. Guha, and S. Krishnamurthi, “TeJaS:
Retroﬁtting type systems for JavaScript,” in Proceedings of the Sympo-
sium on Dynamic Languages, 2013, pp. 1–16.
[19] H. Li and J. Tang, “Cross the wall: Bypass all modern mitigations of
Microsoft Edge,” in Proceedings of the Black Hat Asia, 2017.
[20] M. Molinyawe, A.-A. Hariri, and J. Spelman, “$hell on Earth: From
browser to system compromise,” in Proceedings of the Black Hat USA,
2016.
[21] Mozilla,
“Inheritance
and
the
prototype
chain,”
https:
//developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance and
the prototype chain.
[22] Node.js Foundation, “Node.js,” https://nodejs.org.
[23] S. Pailoor, A. Aday, and S. Jana, “MoonShine: Optimizing OS fuzzer
seed selection with trace distillation,” in Proceedings of the USENIX
Security Symposium, 2018, pp. 729–743.
J. Patra and M. Pradel, “Learning to fuzz: Application-independent
fuzz testing with probabilistic, generative models of input data,” TU
Darmstadt, Tech. Rep. TUD-CS-2016-14664, 2016.
[24]
[25] A. Rebert, S. K. Cha, T. Avgerinos, J. Foote, D. Warren, G. Grieco, and
D. Brumley, “Optimizing seed selection for fuzzing,” in Proceedings of
the USENIX Security Symposium, 2014, pp. 861–875.
[26] G. Richards, S. Lebresne, B. Burg, and J. Vitek, “An analysis of the
dynamic behavior of JavaScript programs,” in Proceedings of the ACM
Conference on Programming Language Design and Implementation,
2010, pp. 1–12.
[27] M. Security, “funfuzz,” https://github.com/MozillaSecurity/funfuzz.
[28] K. Sen, S. Kalasapur, T. Brutch, and S. Gibbs, “Jalangi: A selective
record-replay and dynamic analysis framework for JavaScript,” in
Proceedings of the International Symposium on Foundations of Software
Engineering, 2013, pp. 488–498.
[29] K. Sun and S. Ryu, “Analysis of JavaScript programs: Challenges and
research trends,” ACM Computing Surveys, vol. 50, no. 4, pp. 59:1–
59:34, 2017.
[30] Y. Suzuki, “escodegen,” https://github.com/estools/escodegen.
[31] TC39, “Test262: ECMAScript conformance test suite,” https://github.
com/tc39/test262.
[32] P. Thiemann, “Towards a type system for analyzing javascript pro-
grams,” in Proceedings of the ACM European Conference on Program-
ming Languages and Systems, 2005, pp. 408–422.
[33] S. Veggalam, S. Rawat, I. Haller, and H. Bos, “IFuzzer: An evolutionary
interpreter fuzzer using genetic programming,” in Proceedings of the
European Symposium on Research in Computer Security, 2016, pp.
581–601.
[34] W3Techs, “Usage statistics of javascript for websites, July 2018,” https:
//w3techs.com/technologies/details/cp-javascript/all/all.
J. Wang, B. Chen, L. Wei, and Y. Liu, “Skyﬁre: Data-driven seed
generation for fuzzing,” in Proceedings of the IEEE Symposium on
Security and Privacy, 2017, pp. 579–594.
[35]
[36] M. Woo, S. K. Cha, S. Gottlieb, and D. Brumley, “Scheduling black-
box mutational fuzzing,” in Proceedings of the ACM Conference on
Computer and Communications Security, 2013, pp. 511–522.
[37] D. Yang, Y. Zhang, and Q. Liu, “BlendFuzz: A model-based framework
for fuzz testing programs with grammatical inputs,” in Proceedings of
the IEEE International Conference on Trust, Security and Privacy in
Computing and Communications, 2012, pp. 1070–1076.
[38] X. Yang, Y. Chen, E. Eide, and J. Regehr, “Finding and understanding
bugs in C compilers,” in Proceedings of
the ACM Conference on
Programming Language Design and Implementation, 2011, pp. 283–
294.
[39] D. Yu, A. Chander, N. Islam, and I. Serikov, “JavaScript instrumentation
the ACM Symposium on
for browser security,” in Proceedings of
Principles of Programming Languages, 2007, pp. 237–249.
[40] M. Zalewski, “American Fuzzy Lop,” http://lcamtuf.coredump.cx/aﬂ/.
15