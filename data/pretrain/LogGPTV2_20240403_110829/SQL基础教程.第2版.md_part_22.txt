执行结果
product_id | product_name | sale_price
------------+-------------+-----------
0003 | 运动T恤 | 4000
0004 | 菜刀 | 3000
0005 | 高压锅 | 6800
前一节我们已经介绍过，使用子查询的SQL会从子查询开始执行。
因此，这种情况下也会先执行下述计算平均单价的子查询（图5-5）。
-- ① 内层的子查询
SELECT AVG(sale_price)
FROM Product；
子查询的结果是2097.5，因此会用该值替换子查询的部分，生成如
下SELECT语句。
-- ② 外层的查询
SELECT product_id, product_name, sale_price
FROM Product
WHERE sale_price > 2097.5
大家都能看出该SQL没有任何问题可以正常执行，结果如上所述。
图5-5 SELECT语句的执行顺序（标量子查询）
① 首先执行内层的子查询。结果
是“2097.5”
SELECT product_id, product_name, sale_price
FROM Product
WHERE sale_price > (SELECT AVG(sale_price)
FROM Product);
将①的结果代入到②中，执行外层的查询
SELECT product_id, product_name, sale_price
FROM Product
WHERE sale_price > 2097.5;
● 166 第5章 复杂查询
标量子查询的书写位置
标量子查询的书写位置并不仅仅局限于WHERE子句中，通常任何可
以使用单一值的位置都可以使用。也就是说，能够使用常数或者列名的
地方，无论是SELECT子句、GROUP BY子句、HAVING子句，还是
ORDER BY子句，几乎所有的地方都可以使用。
例如，在SELECT子句当中使用之前计算平均值的标量子查询的
SQL语句，如代码清单5-13所示。
代码清单5-13 在 子句中使用标量子查询
SELECT
SELECT product_id,
product_name,
sale_price,
(SELECT AVG(sale_price)
FROM Product) AS avg_price 标量子查询
FROM Product;
执行结果
product_id | product_name | sale_price | avg_price
----------+---------------+------------+----------------------
0001 | T恤衫 | 1000 | 2097.5000000000000000
0002 | 打孔器 | 500 | 2097.5000000000000000
0003 | 运动T恤 | 4000 | 2097.5000000000000000
0004 | 菜刀 | 3000 | 2097.5000000000000000
0005 | 高压锅 | 6800 | 2097.5000000000000000
0006 | 叉子 | 500 | 2097.5000000000000000
0007 | 擦菜板 | 880 | 2097.5000000000000000
0008 | 圆珠笔 | 100 | 2097.5000000000000000
从上述结果可以看出，在商品一览表中加入了全部商品的平均单价。
有时我们会需要这样的单据。
此外，我们还可以像代码清单5-14中的SELECT语句那样，在HAVING
子句中使用标量子查询。
代码清单5-14 在HAVING子句中使用标量子查询
SELECT product_type, AVG(sale_price)
FROM Product
GROUP BY product_type
HAVING AVG(sale_price) > (SELECT AVG(sale_price)
FROM Product); 标量子查询
5-2 子查询 167 ●
执行结果
product_type | avg
--------------+----------------------
衣服 | 2500.0000000000000000
厨房用具 | 2795.0000000000000000
该查询的含义是想要选取出按照商品种类计算出的销售单价高于全部
商品的平均销售单价的商品种类。如果在SELECT语句中不使用
HAVING子句的话，那么平均销售单价为300日元的办公用品也会被选
取出来。但是，由于全部商品的平均销售单价是2097.5日元，因此低于
该平均值的办公用品会被HAVING子句中的条件排除在外。
使用标量子查询时的注意事项
最后我们来介绍一下使用标量子查询时的注意事项，那就是该子查询
绝对不能返回多行结果。也就是说，如果子查询返回了多行结果，那么它就
不再是标量子查询，而仅仅是一个普通的子查询了，因此不能被用在=或
者<>等需要单一输入值的运算符当中，也不能用在SELECT等子句当中。
例如，如下的SELECT子查询会发生错误。
-- 由于不是标量子查询，因此不能在SELECT子句中使用
SELECT product_id,
product_name,
sale_price,
(SELECT AVG(sale_price)
FROM Product 子查询
GROUP BY product_type) AS avg_price
FROM Product;
发生错误的原因很简单，就是因为会返回如下多行结果。
avg
----------------------
2 500.0000000000000000
300.0000000000000000
2 795.0000000000000000
注A
在1行SELECT子句之中当然不可能使用3行数据。因此，上述
例如，使用PostgreSQL时会返回
如下错误。 SELECT语句会返回“因为子查询返回了多行数据所以不能执行”这样
“ERROR：副查询中使用了返回
的错误信息A。
多行结果的表达式”
● 168 第5章 复杂查询
第5章 复杂查询
5-3
关联子查询
● 关联子查询会在细分的组内进行比较时使用。
学习重点
● 关联子查询和GROUP BY子句一样，也可以对表中的数据进行切分。
● 关联子查询的结合条件如果未出现在子查询之中就会发生错误。
普通的子查询和关联子查询的区别
按此前所学，使用子查询就能选取出销售单价（sale_price）高
于全部商品平均销售单价的商品。这次我们稍稍改变一下条件，选取出各
商品种类中高于该商品种类的平均销售单价的商品。
■按照商品种类与平均销售单价进行比较
只通过语言描述可能难以理解，还是让我们来看看具体示例吧。我们
以厨房用具中的商品为例，该分组中包含了表5-1所示的4种商品。
表5-1 厨房用具中的商品
商品名称 销售单价
菜刀 3000
高压锅 6800
叉子 500
擦菜板 880
因此，计算上述4种商品的平均价格的算术式如下所示。
(3000 + 6800 + 500 + 880) / 4 = 2795 (日元)
这样我们就能得知该分组内高于平均价格的商品是菜刀和高压锅了，
这两种商品就是我们要选取的对象。
我们可以对余下的分组继续使用同样的方法。衣服分组的平均销售单
价是：
5-3 关联子查询 169 ●
(1000 + 4000) / 2 = 2500 (日元)
因此运动T恤就是要选取的对象。办公用品分组的平均销售单价是：
(500 + 100) / 2 = 300 (日元)
因此打孔器就是我们要选取的对象。
这样大家就能明白该进行什么样的操作了吧。我们并不是要以全部商
品为基础，而是要以细分的组为基础，对组内商品的平均价格和各商品的
销售单价进行比较。
按照商品种类计算平均价格并不是什么难事，我们已经学习过了，
只需按照代码清单5-15那样，使用GROUP BY子句就可以了。
代码清单5-15 按照商品种类计算平均价格
SELECT AVG(sale_price)
FROM Product
GROUP BY product_type;
但是，如果我们使用前一节（标量子查询）的方法，直接把上述
SELECT语句使用到WHERE子句当中的话，就会发生错误。
-- 发生错误的子查询
SELECT product_id, product_name, sale_price
FROM Product
WHERE sale_price > (SELECT AVG(sale_price)
FROM Product
GROUP BY product_type);
出错原因前一节已经讲过了，该子查询会返回3行结果（2795、
2500、300），并不是标量子查询。在WHERE子句中使用子查询时，该子
查询的结果必须是单一的。
但是，如果以商品种类分组为单位，对销售单价和平均单价进行比较，
除此之外似乎也没有其他什么办法了。到底应该怎么办才好呢？
■使用关联子查询的解决方案
KEYWORD 这时就轮到我们的好帮手——关联子查询登场了。
●关联子查询
只需要在刚才的SELECT语句中追加一行，就能得到我们想要的结
● 170 第5章 复杂查询
注A 果了A。事实胜于雄辩，还是让我们先来看看修改之后的SELECT语句
事实上，对于代码清单5-16中的
吧（代码清单5-16）。
SELECT语句，即使在子查询中不
使用GROUP BY子句，也能得到正
确的结果。这是因为在WHERE子 代码清单5-16 通过关联子查询按照商品种类对平均销售单价进行比较
句中追加了“P1.product_
type=P2.product_type” SQL Server DB2 PostgreSQL MySQL
这个条件，使得AVG函数按照商 SELECT product_type, product_name, sale_price
品种类进行了平均值计算。但是 FROM Product AS P1 ①
WHERE sale_price > (SELECT AVG(sale_price)
为了跟前面出错的查询进行对
比，这里还是加上了GROUP BY FROM Product AS P2 ②
子句。 该 条 件 就 是 成 功 的 关 键 ! WHERE P1.product_type = P2.product_type
GROUP BY product_type);
特定的SQL
Oracle中不能使用AS（会发生错误）。因此，在Oracle中执行代码清单5-16时，
请大家把①中的FROM Product AS P1变为FROM Product P1，把②中的
FROM Product AS P2变为FROM Product P2。
执行结果
product_type | product_name | s ale_price
---------------+---------------+------------
办公用品 | 打孔器 | 500
衣服 | 运动T恤 | 4000
厨房用具 | 菜刀 | 3000
厨房用具 | 高压锅 | 6800
这样我们就能选取出办公用品、衣服和厨房用具三类商品中高于该类
商品的平均销售单价的商品了。
这里起到关键作用的就是在子查询中添加的WHERE子句的条件。该条
件的意思就是，在同一商品种类中对各商品的销售单价和平均单价进行比较。
这次由于作为比较对象的都是同一张Product表，因此为了进行区
别，分别使用了P1和P2两个别名。在使用关联子查询时，需要在表所
对应的列名之前加上表的别名，以“.”的形式记述。
在对表中某一部分记录的集合进行比较时，就可以使用关联子查询。
因此，使用关联子查询时，通常会使用“限定（绑定）”或者“限制”这
样的语言，例如本次示例就是限定“商品种类”对平均单价进行比较。
法则5-8
在细分的组内进行比较时，需要使用关联子查询。
5-3 关联子查询 171 ●
关联子查询也是用来对集合进行切分的
换个角度来看，其实关联子查询也和GROUP BY子句一样，可以对
集合进行切分。
大家还记得我们用来说明GROUP BY子句的图（图5-6）吗？
图5-6 根据商品种类对表进行切分的图示
衣服(2条)
厨房用具(4条)
T恤衫
菜刀
运动T恤
高压锅
叉子
擦菜板 办公用品(2条)
打孔器
圆珠笔
上图显示了作为记录集合的表是如何按照商品种类被切分的。使用关
联子查询进行切分的图示也基本相同（图5-7）。
图5-7 根据关联子查询进行切分的图示
衣服
厨房用具 平均单价=2500
平均单价=2795
办公用品
平均单价=300
我们首先需要计算各个商品种类中商品的平均销售单价，由于该单价
会用来和商品表中的各条记录进行比较，因此关联子查询实际只能返回1
行结果。这也是关联子查询不出错的关键。关联子查询执行时，DBMS内
部的执行情况如图5-8所示。
● 172 第5章 复杂查询
图5-8 关联子查询执行时DBMS内部的执行情况
SELECT 衣服, T恤衫, 1000 FROM Product WHERE 1000 > 2500;
SELECT 衣服, 运动T恤, 4000 FROM Product WHERE 4000 > 2500;
-------------------------------------------------------------------
SELECT 厨房用具, 菜刀, 3000 FROM Product WHERE 3000 > 2795;
SELECT 厨房用具, 高压锅, 6800 FROM Product WHERE 6800 > 2795;
SELECT 厨房用具, 叉子, 500 FROM Product WHERE 500 > 2795;
SELECT 厨房用具, 擦菜板, 880 FROM Product WHERE 880 > 2795;
-------------------------------------------------------------------
SELECT 办公用品, 圆珠笔, 100 FROM Product WHERE 100 > 300;
SELECT 办公用品, 打孔器, 500 FROM Product WHERE 500 > 300;
满足条件
如果商品种类发生了变化，那么用来进行比较的平均单价也会发生变
化，这样就可以将各种商品的销售单价和平均单价进行比较了。关联子查
询的内部执行结果对于初学者来说是比较难以理解的，但是像上图这样将
其内部执行情况可视化之后，理解起来就变得非常容易了吧。
结合条件一定要写在子查询中
下面给大家介绍一下SQL初学者在使用关联子查询时经常犯的一个
错误，那就是将关联条件写在子查询之外的外层查询之中。请大家看一下
下面这条SELECT语句。
-- 错误的关联子查询书写方法
SELECT product_type, product_name, sale_price
FROM Product AS P1 将关联条件移到子
WHERE P1.product_type = P2.product_type 查询之外
AND sale_price > (SELECT AVG(sale_price)
FROM Product AS P2
GROUP BY product_type);
上述SELECT语句只是将子查询中的关联条件移到了外层查询之中，
其他并没有任何更改。但是，该SELECT语句会发生错误，不能正确执行。