title:MACE: Detecting Privilege Escalation Vulnerabilities in Web Applications
author:Maliheh Monshizadeh and
Prasad Naldurg and
V. N. Venkatakrishnan
MACE: Detecting Privilege Escalation Vulnerabilities in
Web Applications
Maliheh Monshizadeh
Department of Computer Science
University of Illinois at Chicago
Chicago, IL
PI:EMAIL
Prasad Naldurg
IBM Research India
Bangalore, India
PI:EMAIL
V. N. Venkatakrishnan
Department of Computer Science
University of Illinois at Chicago
Chicago, IL
PI:EMAIL
ABSTRACT
We explore the problem of identifying unauthorized privilege es-
calation instances in a web application. These vulnerabilities are
typically caused by missing or incorrect authorizations in the server
side code of a web application. The problem of identifying these
vulnerabilities is compounded by the lack of an access control pol-
icy speciﬁcation in a typical web application, where the only sup-
plied documentation is in fact its source code. This makes it chal-
lenging to infer missing checks that protect a web application’s sen-
sitive resources. To address this challenge, we develop a notion of
authorization context consistency, which is satisﬁed when a web
application consistently enforces its authorization checks across the
code. We then present an approach based on program analysis
to check for authorization state consistency in a web application.
Our approach is implemented in a tool called MACE that uncov-
ers vulnerabilities that could be exploited in the form of privilege
escalation attacks. In particular, MACE is the ﬁrst tool reported
in the literature to identify a new class of web application vulner-
abilities called Horizontal Privilege Escalation (HPE) vulnerabil-
ities. MACE works on large codebases, and discovers serious,
previously unknown, vulnerabilities in 5 out of 7 web applications
tested. Without MACE, a comparable human-driven security audit
would require weeks of effort in code inspection and testing.
Categories and Subject Descriptors
D.2.4 [Software Engineering]: Software/Program Veriﬁcation; D.2.8
[Access Control]: Metrics—Software Engineering,
General Terms
Security Languages
Keywords
Access Control, Web Security, Authorization
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660337.
1.
Introduction
Web applications are powerful engines that drive modern soci-
eties, as they play a pivotal role in e-commerce, social networking
and ﬁnance. Due to their open nature and wide deployment, they
make appealing targets to criminals who want to gain access to
users’ data and resources. Security of web applications therefore
has become an important concern.
To protect from such threats, web applications implement ac-
cess control (a.k.a. authorization) policies. A typical authorization
check in a web application involves verifying whether a given au-
thenticated user with an associated functional role has the required
privilege to access a given resource such as a database table. Since
authorization is expected to be performed before every resource ac-
cess, it therefore forms the basis for security of the web application.
Several high-proﬁle data breaches were caused due to the au-
thorization errors in web applications. A most notable one is the
Citibank data breach [1], wherein more than 360k credit card num-
bers were stolen. Such breaches suggest that web application au-
thorization errors could be disastrous for organizations. Further-
more, such vulnerabilities appear to be widespread, as a recent
Cenzic technical report [6] listed that authorization vulnerabilities
occurred in 56% of the applications that were tested in the 2013
study.
There are several reasons why such authorization errors are nu-
merous. First, unlike conventional operating systems, web appli-
cations (such as those written using PHP) do not come with built-
in support for access control. The access control policy is often
coded by a developer into the application. Developers often focus
on other key functionalities of the applications, and often make er-
rors in programming authorization code, as illustrated by the 2011
CWE / SANS report [3], in which missing authorization and im-
proper authorization are ranked 6th and 15th in the top 25 most
dangerous software errors. Second, a web application (such as one
written using PHP and SQL) often connects directly to the database
resource as a superuser who enjoys all administrative privileges on
the database, and any ﬂaws in the authorization logic often lead
to catastrophic data breaches. Further, web application develop-
ers often implement roles [16] as a privilege management solu-
tion. However, the unavailability of a standard framework, and the
lack of developer’s knowledge of access control design, have led to
buggy and inconsistent role implementations in applications [24].
The academic and industrial communities have identiﬁed sev-
eral solutions to the problem. Virtual private databases [5] provide
a way for applications to execute queries on behalf of users, and
provide effective privilege separation. Web application frameworks
such as Rails [23] provide software engineering solutions to struc-
ture the access control logic of an application effectively. Despite
these advances, a vast majority of web applications continue to be
developed in languages such as ASP, Java and PHP where the onus
of developing and enforcing the access control policy largely falls
on developers.
In this landscape, we take a closer look at the problem of iden-
tifying whether an existing web application contains authorization
errors. This vulnerability analysis problem is often a challenge for
open source web applications that come with almost no documenta-
tion (except their code) of their access control policies. It is indeed
possible for a vulnerability analyst to look for errors by understand-
ing the access control policy, inspecting the source for missing au-
thorizations. However, in order to arrive at the access control policy
of the application by studying its source in detail, the manual effort
involved is signiﬁcant and could be time-consuming and tedious for
large web applications. Therefore automated solutions that identify
authorization errors are desirable, and we present one such strong
approach in this paper.
The crux of our approach to vulnerability analysis is rather than
try to uncover the unwritten access control policy of a given ap-
plication, to instead turn our focus towards identifying whether the
application enforces its policy consistently across various resource
accesses. For example, consider a banking web application that
enforces a complex policy based on principals such as managers,
tellers, and customers.
Instead of trying to uncover the applica-
tion’s intended authorizations, we examine if it consistently en-
forces the same authorization rules for accesses to a resource by
the same principal. When such authorization checks are inconsis-
tently checked along two different paths of an application, it is a
strong indication that access control may be incorrect in one, lead-
ing to privilege escalation vulnerabilities and resulting in loss of
sensitive data to outside attackers or malicious insiders.
Our technical approach to ﬁnd authorization inconsistencies in
applications involves deﬁning a notion of authorization context for
web applications that is associated with every program point in the
application. We then develop a notion called authorization context
consistency, which is satisﬁed when the application uses the same
authorization context in order to access the same resource along
different paths of a web application. When there is a mismatch in
authorization contexts along two different paths, we ﬂag that as an
potential access control violation.
We develop algorithms for computing authorization contexts
and checking for authorization context consistency. These algo-
rithms involve a variety of program analysis techniques that in-
clude control ﬂow analysis, data ﬂow analysis and symbolic eval-
uation. These algorithms are implemented in a tool that we call
MACE (Mining Access Control Errors). These algorithms are
bootstrapped by a small set of annotations provided by the vul-
nerability analyst, and we show that the effort for providing these
annotations is small.
Using our approach, we are able to detect two kinds of privilege
escalation vulnerabilities:
the conventional (1) Vertical Privilege
Escalation (VPE) when an attacker (outsider) or a malicious user
(insider) tries to change her privilege level (access more than they
are entitled to, say according to their role) and (2) Horizontal Priv-
ilege Escalation (HPE) when a malicious user tries to access the
system resources of other users. In particular, our modeling of au-
thorization context and our detection algorithms facilitate the detec-
tion of the latter kind of privilege escalation, thus making MACE
the ﬁrst tool in the literature that is capable of identifying HPE vul-
nerabilities in web applications.
Evidence of the usability and usefulness of MACE is demon-
strated by running it against a large number of open-source code-
bases. We test our tool against 7 applications and detect both hor-
izontal and vertical privilege escalations in 5 of them. Without
MACE, a security audit would have to manually inspect hundreds
of thousands of lines of code.
The rest of the paper is organized as follows: Section 2 describes
the problem with a running example. In Section 3, we explain the
key ideas behind our approach, including the notion of the autho-
rization state, as well as computing authorization contexts. We
present implementation details and related challenges in Section
4. Section 5 presents results of our analysis on our testbed of web
applications. Section 6 is related work, and we summarize our con-
tributions in Section 7.
2. Running Example
In this section, we illustrate the key aspects of the authorization
problem for web applications with the help of an extended exam-
ple. The traditional authorization or privilege escalation problem is
tied to the functional role of a user in this context. If this user can
exercise privileges that are not usually associated with their func-
tional role, a vertical privilege escalation vulnerability is detected.
In addition, as described in CWE-639 [2] the horizontal authoriza-
tion problem describes a situation where two users may have the
same role or privilege level, and must be prevented from accessing
each other’s resources.
Listings 1 to 7 present the source of a running example that illus-
trates these authorization vulnerabilities. The example is a simpli-
ﬁed version of real-world code samples analyzed by our tool, and
describes typical vulnerabilities that were discovered. The partic-
ular web application here is a blog that permits its registered users
to insert, edit, delete, or comment on blog articles. There are two
functional roles: admin and user, with the admin having control
over all posts in the blog, whereas the individual users should only
be able to insert, edit, or delete their own blog, and comment on
other blogs.
Listings 1, 2 and 3 refer to a secure implementation of the ap-
plication. Function verifyUser, shown in Listing 1, checks if
the request is coming from an authenticated user. In Listing 2, an
article is being added to the articles table in the database. The
user name of the current logged-in user speciﬁes the owner of the
article, and the request includes the article text that is inserted into
the database. Note that this insert implementation is secure, as the
user is veriﬁed, and is found to have the required permission. List-
ing 3 refers to the delete operation, where the user can delete any
post that she owns. Additionally, an admin user, as speciﬁed by the
role userLevel, can delete all entries in a blog as shown by the
second DELETE operation.
Listings 4, 5, 6 and 7 show example PHP ﬁles that implement
the delete operation. Each implementation of the delete operation
is vulnerable as described below:
• No authorization In Listing 4, the application performs a delete
In Listing 5, the application does not
• Improper permissions.
check if the user has the appropriate permissions to delete an ar-
ticle.
without checking if the user is authorized.
• Improper Delete-all In Listing 6, the application does not check
if the user trying to delete-all belongs to the Admin role, and
therefore permits a privilege escalation attack.
• Improper Delete In Listing 7, the application does not check
whether the user requesting the delete is the owner of the article,
and is authorized to delete it. It therefore allows the currently
logged in user to delete articles owned by any other user in the
system, as long as the (public) article-ID is supplied as query
argument.
1
2
3
4
5
6
1
2
3
4
5
6
1
2
3
4
5
6
7
2.a
3.a
1.b
2.b
3.b
1.c
...
6.c
7.c
1.d
2.d
3.d
The last two examples in the above list deserve special mention.
Listing 6 is the conventional form of privilege escalation allowing
an ordinary user to assume admin privileges, i.e., vertical privilege
escalation (VPE). In contrast, Listing 7 allows for an ordinary user
to assume privileges of any other ordinary user in the system, a
form of privilege escalation known as horizontal privilege escala-
tion (HPE) [4]. To the best of our knowledge, this paper is the ﬁrst
to discuss an approach for detecting HPE vulnerabilities automati-
cally, in addition to detecting VPEs.
function verifyUser(){
if(!isset($_SESSION[’userID’]))
header(’Location: /login.php’);
else $userID = $_SESSION[’userID’];
return;
}
Listing 1: verifyUser.php
verifyUser();
if($permission[’canWrite’]&&$action == ’insert’)
query("INSERT INTO tbl_articles VALUES (
sanit($_GET[’article_code’]),
$_SESSION[’userID’],
sanit($_GET[’article_msg’]))");
Listing 2: insert.php
verifyUser();
if($permission[’canWrite’]&&$action==’delete’)
query("DELETE FROM tbl_articles WHERE
article_ID = ’" + sanit($_GET[’article_ID’]) + "’
and
author_ID = ’" + $userID + "’");
else if($_SESSION[’userLevel’] == ’Admin’ && $action ==
’deleteAll’)
query("DELETE FROM tbl_articles");
Listing 3: delete.php
if($action == ’delete’)
query("DELETE FROM tbl_articles WHERE article_ID =
’" + sanit($_GET[’article_ID’]) + "’");
Listing 4: delete1.php (vulnerable version)
verifyUser();
if($action == ’delete’)
query("DELETE FROM tbl_articles WHERE article_ID =
’" + sanit($_GET[’article_ID’]) + "’");
Listing 5: delete2.php (vulnerable)
verifyUser();
...
if($permission[’canWrite’] && $action == ’deleteAll’)
query("DELETE FROM tbl_articles");
Listing 6: delete3.php (vulnerable)
verifyUser();
if($permission[’canWrite’] && $action == ’delete’)
query("DELETE FROM tbl_articles WHERE article_ID =
’" + sanit($_GET[’article_ID’]) + "’");
Listing 7: delete4.php (vulnerable)
Lack of Policy Speciﬁcation Note that our techniques are designed
to work directly on the source code of our target applications, with-
out relying on the existence of a well-articulated policy manifest to
clarify these functional roles. In order to know whether the web
application is implementing its access control correctly, one needs
to know what access control policy is implemented. Unfortunately,
the only documentation of this policy is in fact the source code of
the web application. Furthermore, we also face the problem that
this policy implementation can be incomplete or incorrect. This
makes the problem of checking for access control errors quite chal-
lenging.
3. Approach
To reason about a web application’s authorization correctness,
one must examine each sensitive operation (e.g. each SQL query
execution) of the program and examine the authorization informa-
tion required to perform that operation. Recall from Section 2,
the running example identiﬁes what can go wrong in the imple-
mentation of access control, including the absence of any autho-
rization checks, improper ownership or privileges corresponding to
user role, and untrusted session variables.
Authorization state Applications should ideally have a well-
deﬁned policy manifest of what authorizations should be granted
to what users, taking into account the session context, but unfortu-
nately this is not always explicit. Even in applications that manage
to have policy documents, the implementation may not match the
speciﬁcation. The best understanding of access policy therefore
is the operating context of each access request in the implementa-
tion. For each access request in a user session, corresponding to
a particular control and dataﬂow in the program execution, we ar-
gue that the four tuple hU,R,S,Pi represents the associated access