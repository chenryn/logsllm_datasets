# CVE-2019-13272 'PTRACE_TRACEME' 本地提权漏洞分析（一）
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 漏洞信息
这个漏洞是 jannh 在今年 7月份发现的  
[漏洞来源](https://bugs.chromium.org/p/project-zero/issues/detail?id=1903)
  * 影响版本 Linux Kernel 5.1.17
  * 本地提权
## 漏洞补丁
[漏洞补丁](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6994eefb0053799d2e07cd140df6c2ea106c41ee)
    diff --git a/kernel/ptrace.c b/kernel/ptrace.c
    index 8456b6e..705887f 100644
    --- a/kernel/ptrace.c
    +++ b/kernel/ptrace.c
    @@ -79,9 +79,7 @@ void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,
      */
     static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
     {
    -    rcu_read_lock();
    -    __ptrace_link(child, new_parent, __task_cred(new_parent));
    -    rcu_read_unlock();
    +    __ptrace_link(child, new_parent, current_cred());
     }
漏洞的补丁十分的简单，  
不使用 rcu 机制，`__task_cred(new_parent))` 变成`current_cred()`
jannh 发布的信息中提出了两个问题，在这里我们先对第一个问题做分析
## 前置知识
这里是代码分析的时候涉及的一些知识点, 只做简单的描述，不做太详细的介绍
###  linux rcu 机制
rcu (Read-Copy Update) 是linux 中用的比较多的同步机制，它保护的是指针  
rcu 使用在 读多写少的情况下，允许多个读者和写者  
读者之间不需要同步，但如果存在多个写者时，在写者把更新后的“副本”覆盖到原数据时，写者与写者之间需要利用其他同步机制保证同步。
**常用函数**  
rcu_read_lock()  
rcu_read_unlock()
在读取rcu指针的时候需要加上，例如前面的
        rcu_read_lock();
        __ptrace_link(child, new_parent, __task_cred(new_parent));
        rcu_read_unlock();
读者是可以嵌套的，也就是说rcu_read_lock()可以嵌套调用.  
rcu_read_lock()和rcu_read_unlock()用来保持一个读者的RCU临界区. 该临界区上不允许上下文切换（禁止和启用抢占）
rcu_dereference()  
有 rcu 标签的指针不能直接使用，读者要调用rcu_dereference来获得一个被RCU保护的指针.
synchronize_rcu()  
用来等待之前的读者全部退出，读端临界区的检查是全局的，系统中有任何的代码处于读端临界区，synchronize_rcu()
都会阻塞，直到所有读端临界区结束才会返回，用在可睡眠的环境下.
call_rcu()  
用在不可睡眠的条件中,如果中断环境,禁止抢占环境等.
###  linux ptrace 机制
这个应该都是比较熟悉的，gdb的实现就是用的ptrace系统调用  
它的实现原型如下
    #include  
    int ptrace(int request, int pid, int addr, int data);
它提供了父进程控制子进程的方法，用户可以借助它实现断点和调试  
request参数决定了系统调用的功能  
它只能调试属于自己用户的进程，种显而易见的限制就是普通用户的ptrace不能调试root进程
`PTRACE_ATTACH` trace指定 pid 对应的进程  
`PTRACE_DETACH` 结束 trace  
`PTRACE_TRACEME` 本进程将被父进程trace(告诉别人，来trace我呀)  
`PTRACE_SYSCALL, PTRACE_CONT` 重新运行。  
`PTRACE_PEEKTEXT, PTRACE_PEEKDATA` 从内存地址中读取一个字节，内存地址由addr给出。  
`PTRACE_PEEKUSR`从USER区域中读取一个字节，偏移量为addr。  
`PTRACE_POKEUSR` 往USER区域中写入一个字节。偏移量为addr。
###  setresuid 函数实现
setresuid 函数原型`int setresuid(uid_t ruid, uid_t euid, uid_t suid);`  
设置程序运行的 ruid, euid 和 suid,  
执行的条件有
    1.当前进程的euid是root
    2. 三个参数，每一个等于原来某个id中的一个
满足以上条件的任意一个，setresuid()都可以正常调用，并执行  
例如，如果原来 ruid = 100,euid =300, suid =200  
那么 `setresuid(200,300,100)` 可以成功，但是`setresuid(100,200,400)` 就会失败，当然 euid = 0
的时候就是 root 权限了，要设置成其他的用户id 也是没有问题的
setresuid 函数实现在
[kernel/sys.c](https://elixir.bootlin.com/linux/v5.1.16/source/kernel/sys.c#L621)  
主要逻辑如下, 省略了一些代码
     long __sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)
    {
        struct user_namespace *ns = current_user_ns();
        const struct cred *old;
        struct cred *new;
    ....
        new = prepare_creds();
    ...
        old = current_cred();
    ...// some check
        return commit_creds(new);
    ...
    }
可以看到，它会调用 prepare_creds 生成一个新的 cred, 然后 根据old cred和检查传进来的参数是否合法，合法机会运行
commit_creds 替换成新的  
commit cred 在
[kernel/cred.c](https://elixir.bootlin.com/linux/v5.1.16/source/kernel/cred.c#L425)
    int commit_creds(struct cred *new)
    {
        struct task_struct *task = current;
        const struct cred *old = task->real_cred;
    ...
        BUG_ON(task->cred != old);
    ...
        BUG_ON(atomic_read(&new->usage) real_cred, new);
        rcu_assign_pointer(task->cred, new);
    ...//some check
        /* release the old obj and subj refs both */
        put_cred(old);
        put_cred(old);
        return 0;
    }
    EXPORT_SYMBOL(commit_creds);
commit_creds 主要将传入的 new_cred 替换原来的 task->real_cred 和 task->cred, 然后调用了 两次
put_cred 解除 old cred 的引用
put_cred 实现在
[kernel/cred.c](https://elixir.bootlin.com/linux/v5.1.16/source/kernel/cred.c#L136)
    static inline void put_cred(const struct cred *_cred)
    {
        struct cred *cred = (struct cred *) _cred;
        if (cred) {
            validate_creds(cred);
            if (atomic_dec_and_test(&(cred)->usage))
                __put_cred(cred);
        }
    }
    static inline int atomic_dec_and_test(atomic_t *v)
    {
        return __sync_sub_and_fetch(&v->counter, 1) == 0;
    }
`atomic_dec_and_test` 会将 cred 的引用 减 1，并返回结果是否为0  
结果为0 时表示 这个cred已经没有被引用了，会调用 `__put_cred` 函数
    void __put_cred(struct cred *cred)
    {
        kdebug("__put_cred(%p{%d,%d})", cred,
               atomic_read(&cred->usage),
               read_cred_subscribers(cred));
        BUG_ON(atomic_read(&cred->usage) != 0);
    #ifdef CONFIG_DEBUG_CREDENTIALS
        BUG_ON(read_cred_subscribers(cred) != 0);
        cred->magic = CRED_MAGIC_DEAD;
        cred->put_addr = __builtin_return_address(0);
    #endif
        BUG_ON(cred == current->cred);
        BUG_ON(cred == current->real_cred);
        call_rcu(&cred->rcu, put_cred_rcu);
    }
    EXPORT_SYMBOL(__put_cred);
前面做了一堆的检查，从前面我们知道`call_rcu` 是用在不可中断的环境中，最终调用的是 `put_cred_rcu` 函数
    static void put_cred_rcu(struct rcu_head *rcu)
    {
        struct cred *cred = container_of(rcu, struct cred, rcu);
        kdebug("put_cred_rcu(%p)", cred);
    #ifdef CONFIG_DEBUG_CREDENTIALS
        if (cred->magic != CRED_MAGIC_DEAD ||
            atomic_read(&cred->usage) != 0 ||
            read_cred_subscribers(cred) != 0)
            panic("CRED: put_cred_rcu() sees %p with"
                  " mag %x, put %p, usage %d, subscr %dn",
                  cred, cred->magic, cred->put_addr,
                  atomic_read(&cred->usage),
                  read_cred_subscribers(cred));
    #else
        if (atomic_read(&cred->usage) != 0)
            panic("CRED: put_cred_rcu() sees %p with usage %dn",
                  cred, atomic_read(&cred->usage));
    #endif
        security_cred_free(cred);
        key_put(cred->session_keyring);