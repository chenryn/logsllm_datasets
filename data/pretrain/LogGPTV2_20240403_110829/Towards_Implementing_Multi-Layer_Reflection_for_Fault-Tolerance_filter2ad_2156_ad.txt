b
(17) 4:upcallEndReply
(5) 1:Create
Thread 3
Middleware
GIOPServerWorker
(9) 8:invoke
ReceiverThread
(18) 4:upcallReturn
c
a
(6) 3: Create
Thread 8
(7) 8:receiverRun
GIOPServerWorkerThreaded
b
d
(8) 8:recv
(19) 4:send
recv
send
OS Kernel
Network
Figure 4: Request Dispatching using a Thread Pool in Orbacus  
From the analysis of the control and data path followed 
by  a  request,  we  identify  two  places  corresponding  to 
RequestContentionPoints, namely RCP1 and RPC2:  
• RCP1:  A  lock protects  the object  ThreadPool  and 
serializes  accesses  to  the  request  queue by both  receiver-
threads  and  pool-threads  in  ThreadPool::add()  and 
ThreadPool::get().
• RCP2: A second contention point in the application 
code, which uses the this->_object_lock mutex.  
Quite  interestingly,  controlling  those  two  contention 
points appears to be necessary and sufficient to control the 
non-determinism  introduced  by  the  request  dispatching 
within 
the  above  meta-
information, non-deterministic decisions can be identified 
and propagated to a replica. 
the  ORB.  According 
• RCP1  controls  the  order  in  which  the  pool-threads 
to 
extract requests from the request queue within the ORB, 
• RCP2 enables controlling in which order requests are 
processed within the application objects. 
This is a nice example of MLR as RCP1 belongs to the 
ORB and RCP2 to the application. Both contention points 
are needed to control non-determinism and solve PB1 and 
PB2. RCP1 only cannot ensure the order in which requests 
are processed by the application object. RCP2 only cannot 
ensure that the same set of requests is extracted from the 
queue.  Both  have  an  impact  on  the  results  returned  the 
clients (i.e. the value of the counter _count).
5.3. State Related Meta-Model 
Passive  replication  requires  a  state-related  meta-model 
to  be  able  to  capture  and  restore  a  consistent  server  state 
(platform and application). This can be done in two steps: 
first restoring the ORB/OS state, then the application state 
in  a  consistent  way.  The  request  life  cycle  presented 
previously is used to restore the ORB state.  
Indeed,  once  we  control  how  requests  and  their 
associated  threads  interleave  within  the  ORB,  we  can 
restore  an  ORB  state  by  simply  "re-injecting"  requests  at 
the  communication  interface.  This  can  be  seen  as  an 
adaptation  of  log-based  checkpointing  techniques  [16]. 
Actually, the aim is not to restore the entire ORB state but 
the relevant state driving the execution of our application. 
This is the key benefit of our approach. This implies subtle 
re-execution of the ORB parts related to the processing of 
on-going requests thanks to meta-models information. The 
objective  of  this  re-execution  is  to  reach  a  state  that  is 
equivalent (not necessarily identical) for the application.  
From  the  point  of  view  of  the  ORB,  request  can  be 
pending  in  the  ORB  for  execution,  in  progress  at  the 
application  level  (limited  by  the  pool  size)  or  pending  in 
the  ORB  for  termination.  The  following  ORB  level 
intercession actions are thus required: 
• (i) Insertion of pending requests for execution, 
• (ii) Insertion of requests in progress in the pool, 
• (iii) Insertion of pending requests for termination. 
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:28:40 UTC from IEEE Xplore.  Restrictions apply. 
intercession 
function.  As  we 
In  order  to  perform  these  operations  in  a  portable  and 
disciplined manner, intercession facilities are required (see 
ORB meta-interface in Figure 5). All requests are inserted 
using  the  InjectRequestAtCommLevel  ORB  meta-
interface 
control 
RequestContentionPoints  reified  events,  we  can 
block the execution of pending requests for execution (i). 
For  requests  pending  for  termination  (iii),  we  bypass  the 
execution of the request by forcing the continuation of the 
execution  within  the  ORB  by  means  of  the  ORB  meta-
interface function  SkipCallToApplication. To trigger 
this  bypass  operation,  we  intercept  the  execution  flow 
before it reaches the application, thanks to the reification 
of event RequestBeforeApplication (cf. Section 5.2). 
the 
application level (ii) implies complementary state recovery 
actions at both the OS and the application layers: 
• Update threads related data structures (OS); 
• Update application state variables (Application); 
• Resume execution of application objects (OS) 
Similar meta-interface and reification facilities are thus 
required at the OS level. Numerous techniques can be used 
to  restore  thread  execution  stacks,  for  instance  [8]  that  is 
portable,  or  [3,  4]  for  platform  specific  solutions 
(respectively on Java and Linux/i386). 
The  management  of  request 
in  progress  at 
The update of application state variables (here _count)
can be done in many ways, including reflective approaches 
(already proposed as in [9]) that are very portable.  
5.4. Towards Implementation of the Meta-Models 
Figure  5  summarizes  in  a  Java-like  format  the  meta-
interface  we  have  obtained.  This  meta-interface  is  quite 
generic, and can be applied on any ORB that follows the 
assumptions  we  made  on 
this  example.  Its  design 
synthesizes the requirement analysis of the fault-tolerance 
mechanisms,  and  the  Multi-layer  analysis  we  proposed. 
Implementation  using  Orbacus  and  Linux  is  in  progress 
today.  
6. Conclusion and Future Work 
The  rapid  evolution  of  system  platforms  and  the 
variability  of 
their  configurations  and  surrounding 
environments  induces  an  increasing  need  for  adaptive 
systems at both functional and non functional levels. In the 
particular  case  of 
fault-tolerance,  many  attractive 
algorithms  have  been  proposed  to  generically  provide 
fault-tolerance  to  a  wide  range  of  system  classes.  These 
algorithms  are  based,  however,  on  the  availability  of 
specific observation and control features in the underlying 
system  platform  that  are  often  difficult  to  obtain  in 
practice.  The  difficulty  arises  from 
the  multi-layer 
structure  of  the  considered  platforms,  and  the  increasing 
use  of  off-the-shelf  software  components.  These  control 
and  observability  features  are,  however,  essential  to  the 
correctness of these algorithms and cannot be ignored. 
In  this  paper  we  proposed  an  approach  that  provides 
public Request reifiedRequest ; 
public Thread  reifyingThread ; 
class Request ; 
class Thread ; 
class StackChunk ; 
class ReifiedEvent ; 
class RequestLifeCycleEvent extends ReifiedEvent { 
}
class BeginOfRequestReception 
extends RequestLifeCycleEvent ; 
class EndOfRequestReception 
extends RequestLifeCycleEvent ; 
class RequestBeforeApplication  extends RequestLifeCycleEvent ; 
class RequestAfterApplication 
extends RequestLifeCycleEvent ; 
class BeginOfRequestResultSend  extends RequestLifeCycleEvent ; 
class EndOfRequestResultSend 
extends RequestLifeCycleEvent ; 
class RequestContentionPoints 
extends RequestLifeCycleEvent ; 
class IntercessionCommand ; 
class ContinueExecution 
class SkipCallToApplication 
interface MetaLevel { 
}
interface BaseLevel { 
}
State captureApplicationState (); 
void  restoreApplicationState (State s); 
StackChunk captureApplicationStack (Thread t); 
void       restoreApplicationStack (Thread t, StackChunk stack) ; 
void  InjectRequestAtCommuncationLevel(Request r); 
IntercessionCommand reifyEventToMetaSynchronous(ReifiedEvent e); 
extends IntercessionCommand ; 
extends IntercessionCommand ; 
Figure 5: The resulting meta-interface 
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:28:40 UTC from IEEE Xplore.  Restrictions apply. 
early  answers  to  the  above  problems  by  using  Reflection 
to  make  platform  assumptions  easier  to  address.  After 
analyzing  several conventional replication techniques, we 
factorized  the  requirements  of  these  techniques  into  a 
high-level meta-model. We illustrated on a case study how 
this meta-model can be mapped to a given system platform 
by analyzing the structural and behavioral elements across 
several 
levels.  Multi-Layer  Reflection 
aggregates the meta-model of several abstraction levels in 
order  to  select  the  most  appropriate  location  to  obtain 
relevant meta-information.  
abstraction 
tend 
to 
In  many  works,  people  often 
ignore 
implementation  details  raising  the  argument  of  standard 
interfaces. As far as fault-tolerant computing is concerned, 
this kind of argument does not hold and we showed how 
Multi-Layer  Reflection  could  overcome  this  problem. 
However, implementing MLR, although possible on open-
source  executive  layers,  is  very  complex.  The  reason  is 
that,  even  when  complying  with  standard  interfaces,  the 
implementation  of  middleware  and  operating  systems  is 
difficult  to  master  for  the  development  of  fault-tolerance 
strategies.  The  implementation  of  cross-cutting  concerns 
definitely 
implementation 
frameworks,  and  to  some  extent,  a  new  generation  of 
components, namely reflective components. This is one of 
our  long  term  objectives  for  a  better  mastering  and 
adaptation of fault-tolerance in complex component-based 
systems.  
appropriate 
calls 
for 
Acknowledgements:  This  work  was  partially  supported  by  the 
European IST Project DSoS “Dependable Systems of Systems”
n°1999-11585.  We  also  would  like  to  thank  our  colleagues 
Gordon  Blair  at  Lancaster  University  (UK)  and  Jean-Bernard 
Stefani at INRIA (F) that helped us in bootstrapping these ideas. 
Anonymous referees are also deeply acknowledged. 
7. References 
for  Dynamic  Composition 
[1]  G.  Agha,  S.  Frølund,  R.  Panwar,  and  D.  Sturman,  “A 
Linguistic  Framework 
of 
Dependability  Protocols,”  presented  at  the  IFIP  Conference  on 
Dependable  Computing  for  Critical  Applications  (DCCA-3),
Palermo (Sicily), Italy, 1992. 
[2]  C.  Basile,  Z.  Kalbarczyk,  and  R.  Iyer,  “A  Preemptive 
Deterministic  Scheduling  Algorithm 
for  Multithreaded 
Replicas,”  presented  at  The  International  Conference  on 
Dependable  Systems  and  Networks  (DSN-2003), San  Francisco, 
CA, 2003. 
[3]  S.  Bouchenak,  “Making  Java  Applications  Mobile  or 
Persistent,”  presented  at  6th  USENIX  Conference  on  Object-
(COOTS'2001),  San 
Oriented  Technologies  and  Systems 
Antonio, Texas, USA, 2001. 
[4] W. R. Dieter and J. E. Lumpp Jr., “User-level Checkpointing 
for  LinuxThreads  Programs,”  presented  at  2001  USENIX 
Technical Conference, Boston, Massachusetts, USA, 2001. 
[5]  J.-P.  Fassino,  J.-B.  Stefani,  J.  Lawall,  and  G.  Muller, 
“THINK:  A  Software  Framework 
for  Component-based 
Operating  System  Kernels,”  presented  at  Usenix  Annual 
Technical Conference, Monterey (USA), 2002. 
[6]  B.  Garbinato,  R.  Guerraoui,  and  K.  R.  Mazouni, 
“Implementation  of  the  GARF  Replicated  Objects  Platform”, 
Distributed  Systems  Engineering  Journal,  vol.  2,  pp.  14-27, 
1995. 
[7]  R.  Jiménez-Peris,  M.  Patiño-Martínez,  and  S.  Arévalo, 
“Deterministic  Scheduling  for  Transactional  Multithreaded 
Replicas,”  presented  at  19th  IEEE  Symposium  on  Reliable 
Distributed Systems (SRDS), Nürmberg, Germany, 2000. 
[8] F. Karablieh and R. A. Bazzi, “Heterogeneous Checkpointing 
for Multithreaded Applications,” presented at 21st Symposium on 
Reliable Distributed Systems (SRDS'02), Osaka, Japan, 2002. 
[9]  M.-O.  Killijian,  Ruiz-Garcia  Juan-Carlos,  and  J.-C.  Fabre, 
“Portable  serialization  of  CORBA  objects:  a 
reflective 
approach,”  presented  at  18th  Annual  ACM  Conference  on 
Object-Oriented  Programming,  Systems,  Languages  and 
Applications (OOPSLA 2002), Seattle, Washington, USA, 2002. 
[10] F. Kon, F. Costa, G. Blair, and R. H. Campbell, “The case 
for reflective middleware”, Communications of the ACM, vol. 45, 
pp. 33-38, 2002. 
[11]  P.  Maes,  “Concepts  and  Experiments  in  Computational 
Reflection,”  presented  at  Conference  on  Object-Oriented 
Programming Systems, Languages, and Applications (OOPSLA),
Orlando, Florida, 1987. 
[12]  P.  Narasimhan,  L.  E.  Moser,  and  P.  M.  Melliar-Smith, 
“Enforcing  Determinism  for 
the  consistent  replication  of 
Multithreaded  CORBA  Applications,”  presented  at  18th 
Symposium  on  Reliable  Distributed  Systems  (SRDS),  Lausanne, 
Switzerland, 1999. 
[13] T. Pérennou and J.-C. Fabre, “A Metaobject Architecture for 
Fault-Tolerant  Distributed  Systems  :  the  FRIENDS  Approach”, 
IEEE  Trans.  on  Computer,  Special  Issue  on  Dependability  of 
Computing Systems, vol. 47, pp. 78-95, 1998. 
[14] D. Powell, “Delta-4: A Generic Architecture for Dependable 
Distributed Computing,” : Springer-Verlag, 1991, pp. 484. 
[15]  J.-C.  Ruiz-García,  M.-O.  Killijian,  J.-C.  Fabre,  and  P. 
Thévenod-Fosse,  “Reflective  Fault-Tolerant  Systems:  From 
Experience  to  Challenges”,  IEEE  Transactions  on  Computers, 
Special Issue on Reliable Distributed Systems, 2003. 
[16]  R.  E.  Strom  and  S.  Yemini,  “Optimistic  Recovery  in 
Distributed Systems”, ACM Transactions on Computer Systems,
vol. 3, pp. 204-226, 1985. 
[17]  F.  Taïani,  J.-C.  Fabre,  and  M.-O.  Killijian,  “Principles  of 
Multi-Level  Reflection 
for  Fault-Tolerant  Architectures,” 
presented  at  2002  Pacific  Rim  International  Symposium  on 
Dependable Computing (PRDC 2002), Tsukuba (Japan), 2002. 
[18]  Y.  Yokote,  F.  Teraoka,  and  M.  Tokoro,  “A  Reflective 
Architecture  for  an  Object-Oriented  Distributed  Operating 
System.,”  presented  at  Third  European  Conference  on  Object-
Oriented Programming (ECOOP'89), Nottingham, UK, 1989. 
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:28:40 UTC from IEEE Xplore.  Restrictions apply.