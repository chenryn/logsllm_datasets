### 优化后的文本

#### 图4：使用线程池在Orbacus中调度请求

通过对请求的控制和数据路径进行分析，我们确定了两个与请求竞争点（RequestContentionPoints, RCP）相对应的位置，即RCP1和RCP2：

- **RCP1**：一个锁保护了`ThreadPool`对象，并在`ThreadPool::add()`和`ThreadPool::get()`方法中对请求队列的访问进行了序列化。
- **RCP2**：应用程序代码中的第二个竞争点，使用`this->_object_lock`互斥锁。

有趣的是，控制这两个竞争点对于控制由请求调度引入的非确定性是必要且充分的。根据上述元信息，非确定性决策可以被识别并传播到副本中。

- **RCP1** 控制了池线程从ORB内的请求队列中提取请求的顺序。
- **RCP2** 使控制应用程序对象内处理请求的顺序成为可能。

这是一个很好的多层反射（MLR）的例子，因为RCP1属于ORB，而RCP2属于应用程序。两个竞争点都是控制非确定性和解决PB1和PB2所必需的。仅靠RCP1无法确保请求被应用程序对象处理的顺序，而仅靠RCP2无法确保从队列中提取相同的请求集。两者都对返回给客户端的结果（即计数器`_count`的值）有影响。

### 5.3 状态相关的元模型

被动复制需要一个状态相关的元模型来捕获和恢复一致的服务器状态（包括平台和应用程序）。这可以通过以下两个步骤完成：首先恢复ORB/OS状态，然后以一致的方式恢复应用程序状态。前面介绍的请求生命周期用于恢复ORB状态。

一旦我们控制了请求及其相关线程在ORB中的交织方式，我们就可以通过简单地在通信接口“重新注入”请求来恢复ORB状态。这可以看作是对基于日志的检查点技术[16]的一种适应。实际上，我们的目标不是恢复整个ORB状态，而是驱动应用程序执行的相关状态。这是我们的方法的关键优势。这意味着需要利用元模型信息重新执行与正在进行的请求处理相关的ORB部分。重新执行的目标是达到一个对应用程序来说等效（但不一定相同）的状态。

从ORB的角度来看，请求可能处于以下几种状态：
- 在ORB中等待执行，
- 在应用程序级别正在处理（受限于池大小），
- 在ORB中等待终止。

因此，需要以下ORB级别的干预操作：
- (i) 插入等待执行的请求，
- (ii) 将正在处理的请求插入池中，
- (iii) 插入等待终止的请求。

为了以可移植和规范的方式执行这些操作，需要干预设施（参见图5中的ORB元接口）。所有请求都使用`InjectRequestAtCommLevel` ORB元接口插入。通过控制`RequestContentionPoints`具体化的事件，我们可以阻止等待执行的请求(i)的执行。对于等待终止的请求(iii)，我们通过强制ORB内部继续执行来绕过请求的执行，使用ORB元接口函数`SkipCallToApplication`。为了触发这个绕过操作，我们在执行流到达应用程序之前拦截它，感谢`RequestBeforeApplication`事件的具体化（参见第5.2节）。

管理正在应用程序级别(ii)处理的请求需要在操作系统和应用程序层面上补充状态恢复操作：
- 更新线程相关数据结构（操作系统）；
- 更新应用程序状态变量（应用程序）；
- 恢复应用程序对象的执行（操作系统）。

因此，在操作系统层面也需要类似的元接口和具体化设施。有许多技术可以用来恢复线程执行堆栈，例如[8]中的可移植技术，或[3, 4]中的特定平台解决方案（分别针对Java和Linux/i386）。

更新应用程序状态变量（此处为`_count`）可以通过多种方式进行，包括反射方法（如[9]中已经提出的），这种方法非常可移植。

### 5.4 元模型的实现

图5以类似Java的格式总结了我们获得的元接口。该元接口相当通用，可以应用于任何遵循我们在本例中所做的假设的ORB。其设计综合了容错机制的需求分析和我们提出的多层分析。目前，使用Orbacus和Linux的实现正在进行中。

### 结论与未来工作

系统平台的快速演变及其配置和周围环境的多样性增加了对功能和非功能层面自适应系统的需求。特别是在容错方面，已经提出了许多吸引人的算法，以通用方式为广泛的系统类别提供容错。然而，这些算法依赖于底层系统平台中特定的观察和控制特性，这些特性在实际中往往难以获得。困难在于所考虑平台的多层次结构以及越来越多地使用现成的软件组件。尽管如此，这些控制和可观测性特性对于这些算法的正确性至关重要，不能忽视。

在本文中，我们提出了一种利用反射来简化平台假设的方法。通过分析几种传统的复制技术，我们将这些技术的要求分解为一个高层元模型。我们通过一个案例研究说明了如何将此元模型映射到给定的系统平台，通过分析多个层次的结构和行为元素。多层反射聚合了多个抽象层次的元模型，以便选择最合适的位置来获取相关的元信息。

在许多工作中，人们常常忽略实现细节，以标准接口为由。但在容错计算方面，这种理由并不成立，我们展示了多层反射如何克服这个问题。然而，即使在开源执行层上，实现MLR也是非常复杂的。原因在于，即使符合标准接口，中间件和操作系统的实现也很难掌握，尤其是在开发容错策略时。交叉关注点的实现明确要求适当的实现框架，甚至某种程度上的新一代组件，即反射组件。这是我们长期目标之一，旨在更好地掌握和适应复杂组件系统中的容错。

### 致谢
这项工作得到了欧洲IST项目DSoS“可靠的系统系统”（编号1999-11585）的部分支持。我们还要感谢兰卡斯特大学（英国）的Gordon Blair和INRIA（法国）的Jean-Bernard Stefani在启动这些想法方面的帮助。匿名审稿人也深表感谢。

### 参考文献
[略]

---

这样修改后，文本更加清晰、连贯和专业。希望这对你有所帮助！