our  genetic  algorithm  is  capable  of  evolving  tftp 
packets 
that  successfully  reach  the  basic  blocks 
containing  the  vulnerable  strcpy()  functions  in  the 
control flow graph.  Tftpd.exe performs several checks 
and  validations  on  a  packet  before  it  reaches  these 
functions.    This  demonstrates  that  our  algorithm  is 
capable of learning to navigate the program’s internal 
logic 
  Second,  we 
demonstrated the superiority of our approach to fuzzing 
with  random  input.    Figure  7  shows  a  control  flow 
graph generated by our tool during one of our test runs.  
Figure 6 shows a comparison of the performance of the 
genetic  algorithm  to  a  random  search.    The  GA 
outperforms  the  random  fuzzing  approach.    The  first 
vulnerable strcpy() function was reached by the GA in 
224  generations  on  average  compared  to  a  random 
search  which  took  an  equivalent  of  2294  generations 
on  average. 
  The  GA’s  superiority  was  more 
pronounced  on  the  second  strcpy()  function  situated 
deeper in the logic structure.  The GA reached it in an 
average  227  generations  compared  to  9,106  for  the 
random brute force.  
4.2. Code Coverage Selectivity 
locations. 
these 
to 
reach 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:40:16 UTC from IEEE Xplore.  Restrictions apply. 
     While  security  researchers  may  want  to  target  a 
specific  vulnerability  to  discover  whether  or  not  it  is 
exploitable,  they  also  investigate  the  overall  behavior 
of an application.  They do this by trying to cover as 
much  of  its  code  as  possible.    In  other  words,  they 
attempt  to  exercise as many  different  execution  paths 
as  possible.   This  can reveal previously  undiscovered 
bugs, or it can increase the developer’s confidence that 
the application is robust. 
state 
large 
Figure  6:  Comparison  between  GA  driven  and 
random  search  of  tftp  packet  parsing  logic.    The 
node  address  corresponds 
to  basic  block 
addresses on paths from the beginning to the end 
of the packet parsing logic.   
     Many current code coverage tools are inadequate and 
inefficient  for  vulnerability  analysis.    Many  of  these 
tools  focus  upon  achieving  global  coverage  of  the 
application  state  space  (i.e.  reaching  all  nodes  in  its 
control  flow  graph).    Because  all  but  the  most  trivial 
applications  have  extremely 
spaces, 
achieving  such  extensive  coverage  can  be 
time 
consuming  and  resource  intensive.    This  may  be 
justifiable for a software tester attempting to ensure the 
correctness  or 
robustness  of  a  mission  critical 
application.    However,  software  security  researchers 
may wish to focus their resources on the specific subsets 
of the state space most likely to be targeted by malicious 
users  (e.g.  a  security  analyst  should  examine  parsing 
logic  for  a  packet  received  off  of  an  open  port  more 
closely 
input.).  
Because  our  fitness  function  drives  execution  toward 
less  explored  regions  within  a  subset  of  the  overall 
control flow graph, code coverage is a natural extension.  
Rather than trying to achieve coverage of the entire state 
space, our tool focuses upon achieving coverage within 
localized  program  regions.  This  is  a  second  area  we 
evaluated our methodology.   
     During our investigation of the tftpd server’s strcpy() 
vulnerabilities, we collected code coverage data for the 
program  region  corresponding  to  the  protocol  parsing 
than  GUI  code  accepting  mouse 
logic.  We compared the coverage obtained with input 
selection  driven  by  our  genetic  algorithm  against  the 
coverage  obtained  by  the  random  selection  process.  
Averaged over 50 runs, the genetic algorithm achieved 
84.81%  coverage  of  the  region  compared  to  49.54% 
coverage  achieved  during  the  same  number  of  inputs 
using the random selection.  Furthermore, coverage was 
not  appreciably  improved  by  continuing  the  random 
selection process for another 7000 generations worth of 
input  data.    It  slightly  increased  to  54.51%.  We 
suspected  that  the  natural  tendency  of  our  fitness 
function  to  drive  exploration  toward  less  explored 
regions  of  the  graph  would  improve  how  quickly  we 
were able to achieve specific penetration depths in the 
control logic structure.  The usage of elitism by our GA 
also ensured that we would never lose the information 
learned during previous generations.   
     In  another  experiment,  we  assigned  a  penetration 
depth value to each node corresponding to the minimum 
number of edges  between it and the source node.  We 
then  tabulated  the  average  number  of  generations 
required to reach each depth in the control flow graph 
between  the  beginning  and  end  of  the  tftp  protocol 
parsing  logic.    Figure  8  shows  the  results  of  this 
experiment.    As  you  can  see,  the  GA  once  again 
outperforms a random search.  Its behavior is also more 
consistent.    We  can also  observe  that nodes  at  greater 
depths ( > 10 edges ) become increasing difficult for the 
both  the  GA  and  the  random  search  to  reach.  The 
increase in difficulty is, however, much more linear for 
the  genetic  algorithm.  No  doubt,  this is a result  of  the 
natural  tendency  for  the  GA  to  leverage  what  it  has 
learned  from  the  previous  observation  of  dynamic 
execution response to the inputs it has tried. Finally, we 
note  that  although  we  ran  this  experiment  for  input 
equivalent  to  10,000  generations  consisting  of  50  trial 
inputs  apiece,  the  random  search  never  hit  any  of  the 
nodes  deeper  than  13  edges  away  from  the  source.  
Thus, we should view the data points for these depths as 
setting a lower bound on the search  performance.  We 
expect 
to 
exponentially increase with greater depths. 
4.3. Automatic Input Format Learning 
     Because  many  programs  erroneously  trust  that  user 
input  will  conform  to  well  behaved  published  or  
implied  standards,  protocol  parsing  bugs  abound.  
Protocol parsing code, furthermore, typically has a rich 
and deep control flow structure.  This makes it ideal for 
testing  our  genetic  algorithm’s  ability  to  explore  the 
boundaries  imposed  by  parsing  logic  on  a  program’s 
input  space.    Once  again,  we  applied  it  to  the  tftpd 
server program.  By setting the destination node to the  
basic  block  indicating  acceptance  of  a  valid  read  or 
that  performance  will  continue 
that 
482482
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:40:16 UTC from IEEE Xplore.  Restrictions apply. 
1. Extract program control flow graph using pida_dump.py (provided in PAIMEI    
   framework 
2. Extract subgraph (source, destination) and set of reject nodes 
3. Load program & attach debugger 
4  Register breakpoint handler 
5. Set breakpoints on subgraph and reject node basic blocks 
6. Register exception handler 
7. Initialize GA parameters 
8. Initialize random population 
8. Inject input 
9. While destination node not yet reached: 
a. When a breakpointed node is hit: 
i. 
Update code coverage information if this is the first time we've visited 
this node 
ii.  Update the visit count for this node 
iii. Add this node to the path taken by the current input 
iv.  If (the node is a reject state) 
a. If (we have not yet ran all inputs in the population for the current 
generation) 
b. Else we have ran all inputs in the population for the current 
i.  Inject next input 
ii. Return 
generation: 
v.   Else node is not a reject state: 
i.   Calculate fitness 
ii.  Build new population via crossover and mutation 
iii. Inject new input 
iv.  Return 
i. Return 
Figure 5. Pseudocode for our prototype fuzz testing tool 
)
s
n
o
i
t
a
r
e
n
e
g
(
e
m
Ti
10000
9000
8000
7000
6000
5000
4000
3000
2000
1000
0
Generation 
1.  
2.  
3.  
4.  
5.  
6.  
7.  
8.  
0 
1 
51 
72 
78 
111 
393 
547 
GA Search
Random Search
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
Figure 8. Average # of Generations for CFG Penetration Depth 
Depth
string 
Filename 
2 bytes 
Opcode 
  2326 
  626F637465741B7B6225 
  0005 
  0002 
  0002 
  0001 
  0002 
  0001 
  367D 
  36060628791E32 
  36060128 
  NULL 
  187566 
  2E027D1C02006F63746574 
Figure 9. Evolution of a TFTP Packet
  0A2A3606 
  0A057C0561 
  266F6374657464 
  6E6574617363696964 
string 
Mode 
1 
byte 
0 
  00 
  00 
  00 
  00 
 1 
byte 
0 
00 
00 
483483
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:40:16 UTC from IEEE Xplore.  Restrictions apply. 
that  the  first  check 
tftp  packet.    The  strings  included  in  this  figure 
represent the best genomes found by our GA at specific 
points during the evolutionary process. Note also that 
these  strings  are  in  hexadecimal.    Therefore  a  single 
byte consists of 2 hexadecimal digits. Because we have 
also  manually  reverse  engineered  the  tftp  protocol 
parsing  logic,  we  know 
is 
performed  on  the  length  and  that  the  packet  parsing 
logic  proceeds  from  left  to  right.  We  outline  the 
evolutionary steps below: 
Generation  0:  Consists  of  an  initial  population  of 
random  strings  generated  by  the  GA.  The  “best 
genome”  evolved  at  the  0th  generation  (i.e.  “2326”), 
failed to evolve a string capable of satisfying tftp’s first 
check for a minimum length string.   
Generation  1: Here, the grammar generated a longer 
string  that  was  accepted  and  enabled  the  program  to 
progress  deeper  into  the  parsing  logic.    This  longer 
string  was  rewarded  by  the  GA  with  a  better  fitness 
and was allowed to reproduce more. 
Generation  51: We note that the GA has evolved its 
first valid opcode (remember valid opcodes range from 
1  to  5).  The  “0005”  corresponds  to an  “error”.  The 
remaining characters in the genome are interpreted as a 
filename string, however, the required null terminator 
is still missing. 
Generation 72: We can see that the GA has evolved a 
different,  valid  opcode  (a  write  request).    It  is  still, 