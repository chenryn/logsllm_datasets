3.4什么是浮点数
表3-1中，十进制数0的下一位是0.0625。因此，这中间的小数，
就无法用小数点后4位数的二进制数来表示。同样，0.0625的下一位
数一下子变成了0.125。这时，如果增加二进制数小数点后面的位
数，与其相对应的十进制数的个数也会增加，但不管增加多少位，
2的-OO次幂怎么相加都无法得到0.1这个结果。实际上，十进制数
0.1转换成二进制后，会变成0.00011001100（1100循环）这样的循
环小数。这和无法用十进制数来表示1/3是一样的道理。1/3就是
0.3333.，同样是循环小数。
至此，大家应该明白了为什么用代码清单3-1的程序无法得到正确
结果了吧。因为无法正确表示的数值，最后都变成了近似值。计算机
这个功能有限的机器设备，是无法处理无限循环的小数的。因此，在
遇到循环小数时，计算机就会根据变量数据类型所对应的长度将数值
从中间截断或者四舍五人。我们知道，将0.3333…这样的循环小数从
中间截断会变成0.333333，这时它的3倍是无法得出1的（结果是
0.999999），计算机运算出错的原因也是同样的道理。
3.4什么是浮点数
像1011.0011这样带小数点的表现形式，完全是纸面上的二进制数
表现形式，在计算机内部是无法使用的。那么，实际上计算机是以什
么样的表现形式来处理小数的呢？我们一起来看一下。
很多编程语言中都提供了两种表示小数的数据类型，分别是双精
度浮点数和单精度浮点数。双精度浮点数类型用64位、单精度浮点数
①像0.3333这样相同数值无限循环的值称为措环小数。计算机是功能有限
的机器，无法直接处理循环小数。
---
## Page 62
随3章计算机进行小数运算时出错的原因
类型用32位来表示全体小数。在C语言中，双精度浮点数类型和单精
度浮点数类型分别用double和float来表示。不过，这些数据类型都采
用浮点数”来表示小数。那么，浮点数究竞采用怎样的方式来表示小数
呢？接下来就让我们一起来看一下。
浮点数是指用符号、尾数、基数和指数这四部分来表示的小数（图
3-3）。因为计算机内部使用的是二进制数，所以基数自然就是2。因
此，实际的数据中往往不考虑基数，只用符号、尾数、指数这三部分
即可表示浮点数。也就是说，64位（双精度浮点数）和32位（单精度
浮点数）的数据，会被分为三部分来使用（图3-4）
±mxn
特号尾数
基数指数
图3-3浮点数的表现形式。由符号、尾数、基数、指数四部分构成
①双精度浮点数能够表示的正数范围是4.94065645841247×10-
1.79769313486232×10，负数范周是-1.79769313486232×10
 4.94065645841247 × 10
单精度浮点数能够表示的正数范国是
1.401298×10~3.402823×10，负截范围是3.402823×10”~1.401298×10
不过，正如正文中所介绍的那样，在这些范国中，有些数值是无法正确表
示的。
②像0.12345×10和0.12345×10这样使用与实际小数点位置不同的书写方法
来表示小数的形式称为浮点数。与浮点数相对的是定点数，使用定点数表示
小数时，小数点的实际位置因定不变。例如，0.12345×10和0.12345×10用
定点数来表示的话即为123.45和0.012345。
---
## Page 63
3.4什么是浮点数
双精度浮点数（共64位）
1位
11位
52位
符号部分指数部分
尾数部分
单精度浮点数（共32位】
8位
23位
符号部分指数部分
尾数部分
围34浮点数的内都构造（IEEE的规定）
浮点数的表现方式有很多种，这里我们使用最为普遍的IEEE标
准。双精度浮点数和单精度浮点数在表示同一个数值时使用的位数不
同。此外，双精度浮点数能够表示的数值范围要大于单精度浮点数。
符号部分是指使用一个数据位来表示数值的符号。该数据位是1
时表示负，为0时则表示“正或者0”。这和用二进制数来表示整数时
的符号位是同样的。数值的大小用尾数部分和指数部分来表示。例如，
小数就是用“尾数部分×2的指数部分次幂”这样的形式来表示的。讲
到这里，大家是不是多少有点概念了呢。
下面的内容可能稍微有点复杂，因为尾数部分和指数部分并不只
的值固定为1的正则表达式”，面指数部分用的则是“EXCESS系统表
现”。此外，接下来还会涉及大量的新术语，大家可能会因此产生逃避
心理。不过，这些其实并不难，因此请大家一定要耐心地阅读下去。
①IEEE（Institute of Electrical and Electronics Engineers）是指美国电气和电子
工程师协会。该协会制定了计算机领域的各种规定。读作“eye-triple-e，I-3E”。
---
## Page 64
题3章计算机进行小路运其时出错的原因
3.5
正则表达式和EXCESS系统
尾数部分使用正则表达式”，可以将表现形式多样的浮点数统一为
一种表现形式。例如，十进制数0.75就有很多种表现形式，如图3-5
所示。虽然它们表示的都是同一个数值，但因为表现方法太多，计算
机在处理时会比较麻烦。因此，为了方便计算机处理，需要制定一个
统一的规则。例如，十进制数的浮点数应该遵循“小数点前面是0，小
数点后面第1位不能是0”这样的规则。根据这个规则，0.75就是
“0.75×10的0次幂”，也就是说，只能用尾数部分是0.75、指数部分
是0这个方法来表示。根据这个规则来表示小数的方式，就是正则表
达式。
0.75 = 0.75 × 100
0.75 = 75 ×10=2
0.75 = 0.075 × 101
图3-5浮点数可以用不同的形式来表现同一个数值
刚才以十进制数为例进行了说明，二进制数也是同样的道理。在
二进制数中，我们使用的是“将小数点前面的值固定为1的正则表达
式”。具体来讲，就是将二进制数表示的小数左移或右移（这里是逻辑
移位。因为符号位是独立的）数次后，整数部分的第1位变为1，第2
①按照特定的规则来表示数据的形式即为正则表这式。除小数之外，字符事
以及数据库等，也都有各自的正则表达式。
②整数是指使用包含表示符号的最高位在内的全体来表示的一个数值。而浮
点数是由符号部分、尾数部分和指数部分这三部分独业的数值组合而成的。
---
## Page 65
3.5正则表达式和EXCESS系统
位之后都变为0（这样是为了消除第2位以上的数位）。面且，第1位的
1在实际的数据中不保存。由于第1位必须是1，因此，省略该部分后就
节省了一个数据位，从而也就可以表示更多的数据范围（虽不算太多）。
单精度浮点数的正则表达式的具体例子如图3-6所示。单精度浮
点数中，尾数部分是23位，但由于第1位的1被省略了，所以实际上
可以表示24位的数值。双精度浮点数的表示方法也是如此，只是位数
不同而已
1011.0011
原始数值
0001.0110011
右移使整数部分的第1位变成1
0001.01100110000000000000000
确保小数点以后的长度为23位
01100110000000000000000
仅保留小数点后面的部分，完成正则表达式
图3-6单精度浮点数尾数部分的正则表达式
接下来，让我们一起来看一下指数部分中使用的EXCESS系统，
使用这种方法主要是为了表示负数时不使用符号位。在某些情况下，
在指数部分，需要通过“负OO次幂”的形式来表示负数。EXCESS
系统表现是指，通过将指数部分表示范围的中间值设为0，使得负数不
需要用符号来表示。也就是说，当指数部分是8位单精度浮点数时，
最大值11111111=255的1/2，即01111111=127（小数部分舍弃）表示
的是0，指数部分是11位双精度浮点数时，11111111111=2047的1/2，
即01111111111=1023（小数部分舍弃）表示的是0。
EXCESS系统可能不太好理解，下面举例来说明。假设有这样
个游戏，用1~13（A~K）的扑克牌来表示负数。这时，我们可以把
---
## Page 66
3章计算视进行小数运算时出铺的原因
中间的7这张牌当成0。如果扑克牌7是0，10就表示+3，3就表
示-4。事实上，这个规则说的就是EXCESS系统。
作为单精度浮点数的示例，表3-2中列出了指数部分的实际值和用
EXCESS系统表现后的值。例如，指数部分为二进制数11111111（十
进制数255），那么在EXCESS系统中则表示为128次幂。这是因为
255-127=128。因此，8位的情况下，表示的范围就是-127次
8Z1~
表3-2单精度浮点数指数部分的EXCESS系统表现
实际的值（二进制数）
实际的值（十造制数）EXCESS系统表现（十进制数）
11111111
255
128 ( = 255  127 )
11111110
254
127 ( = 254 - 127 )
01111111
127
0 [ = 127 - 127]
01111110
126
-1[=126-127]
00000001
L
126 [ = 1 - 127 ]
0000000
0
- 127 ( = 0 - 127)
3.6
在实际的程序中进行确认
读到这里，有人额角冒汗吗？上述内容不是仅仅读一遍就能马上
理解的，最好能够在实际的程序中加以确认。因此，我们准备了一个
试验用的程序，如代码清单3-2所示。接下来，就让我们一起看一下如
何用单精度浮点数来表示十进制数0.75吧。
代码清单3-2用于确认单精度浮点数表示方法的C语言程序
#include 
#inelude cstring.h>
void nain(){
float data;
unsigned long buff;
---
## Page 67
3.6在实际的程序中进行确认
int i;
char s[34] :
//将0.75以单精度浮点数的形式存储在变量date中。
data = (f1oat)0.75;
//把数据复制到4字节长度的整数变量buft中以逐个提取出每一位。
mencpy (&buff, data, 4) )
for （1=33;>=0;1-）{
//逐一提取出每一位
if(1 --11--10）(
//加入破折号来区分符号部分、指数部分和尾数部分。
=[i]-*-1;
}else{
//为各个字节赋值，0或者*1
f(buff 2 = 1){
s[1] -'1';
s[1] - *0′;
buff/-2:
s[34]=*\0′;
//显示结果。
printf (*4a\n*, s) /
该程序执行后，十进制数0.75用单精度浮点数来表示就变成了
0-01111110-10000000000000000000000（图3-7）。加人破折号（-）是为
了区分符号部分、指数部分、尾数部分。这里，符号部分为0，指数部
分为01111110，昆数部分为10000000000000000000000。因为0.75是
正数，所以符号位是0。指数部分的01111110是十进制数126，用
EXCESS系统表现就是-1（126-127=-1）。根据正则表达式的规则，
小数点前面的第1位是1，因此尾数部分10000000000000000000000实
际上表示的是1.10000000000000000000000这个二进制数。将尾数部分
的二进制数转换成十进制数，结果就是（1×2的0次幂）+（1x2的-1
---
## Page 68
第3章计算机进行小数运算时出铺的原因
次幂）=1.5。因此，0-01111110-10000000000000000000000这个单精度
浮点数，表示的就是“+1.5×2的-1次幂”。2的-1次幂是0.5，+1.5
×0.5=+0.75。正好吻合，结果正确。
-Yaza
0000000000
.exe
图3-7代码清单3-2的运行结果
接下来，我们继续使用该程序来看一下如何用单精度浮点数表示十进
制数0.1。运行后就会发现结果为0-01111011-10011001100110011001101
（只需将data=（float）0.75;的部分变成data=（float）0.1:即可）。这时，
如果反过来计算一下这个数值的十进制数，估计大家又要冒汗了，结
果居然不是0.1
符号部分--0表示正数
指数部分--转换成十进制数后是126。
在EXCESS系下，表示的是126-127=-1的意思
0-01111110-10000000000000000000000
尾数部分表示的是1.以后的邮分，
也就是1.10000000000000000000000
该数据用二进制数表示为1.1x2、用十进制数表示为1.5×2-0.75
图38用单精度浮点数表示的数据
---
## Page 69
3.7如何题免计算机计算出键
3.7
如何避免计算机计算出错
计算机计算出错的原因之一是，采用浮点数来处理小数（另外，也
有因“位溢出”而造成计算错误的情况）。作为程序的数据类型，不管
是使用单精度浮点数还是双精度浮点数，都存在计算出错的可能性。
接下来将介绍两种避免该问题的方法。
首先是回避策略，即无视这些错误。根据程序目的的不同，有时
一些微小的偏差并不会造成什么问题。例如，假设使用计算机设计工
业制品。将100个长0.1毫米的零件连接起来后，其长度并非一定要是
10毫米，10.000002毫米也没有任何问题。一般来讲，在科学技术计算
领域，计算机的计算结果只要能得到近似值就足够了。那些微小的误