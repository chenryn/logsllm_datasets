N3
[user@localhost~]$ runlevel
runlevel6.target-
runlevel5.target
runlevel4.target
cunlevel3.target
cunlevel2.target
runlevel1.target
runlevel0.target->
第6章使用systemd管理Linux系统服务131
->reboot.target
graphical.target
multi-user.target
multi-user.target
multi-user.target
rescue.target
会根据配置文件的关
---
## Page 148
现这种循环依赖关系的时候，systemd会尝试去掉Wants 依赖，看能否正常进行引导。如果
种呢？通常用于来解决一种极端情况下的依赖关系——循环依赖，即A→B→C→A，出
务即可，而不再需要分析各个默认的 target之间的依赖关系。那么依赖关系为什么会分为两
制依赖关系，Wants表示目标之间是非强制依赖关系，运维工程师只需要关注需要启动的服
Requires/Wants 关键字来确认各个target 之间的依赖关系。其中 Requires表示目标之间是强
的 target 可通过基本target 文件中的依赖形成树形结构，继续进行引导。
系。介绍了这么多，接下来让我们看一个完整的目标配置文件的实例。
RequiredBy、Conflicts、ConflictedBy、Before、After等。我们会在后面陆续用到这些依赖关
下的命令：
依然无法打破依赖关系，则会报错。
132运维前线：一线运维专家的运维方法、技巧与实践
如果我们自己编写一个target，那么怎样才能知道一个目标需要哪些服务呢？可使用如
所有的 target都可以通过如下命令来查看：
除了Wants，还可以有其他各种形式的依赖和被依赖关键字，如WantedBy、Requires、
Alias=default.target
AllowIsolate=yes
After=basic.target rescue.service rescue.target
Description=Multi-User System
这里需要重点关注一个参数，它是涉及依赖关系的，打开这些target会发现它们使用了
[Install]
Conflicts=rescue.service rescue.target
Requires=basic.target
[Unit]
[root@localhost~]# cat /lib/systemd/system/multi-user.target
>reboot.target
lrwxrwxrwx.1root
->graphical.target
->multi-user.target
lrwxrwxrwx.1rootroot
user.target
rw-r--r--
[user@localhost ~]s 1s-1/lib/systemd/system/*.target
>multi-user.target
1root
root
root
130ct 29 17:20/1ib/systemd/system/runlevel6.target
16 0ct 29 17:20 /lib/systemd/system/runleve15.target
17 0ct 29 17:20 /1ib/systemd/system/runlevel3.target
170ct 29 17:20/1ib/systemd/system/runlevel4.target
---
## Page 149
键字，以避免人为失误导致系统无法加载。
果要自定义启动逻辑，除了启动时激活必要的[Unit]，自定义的启动过程建议使用 Wants 关
个[Unit]才会被引导；如果有任何一个没有被激活，那么启动的时候会跳过这个[Unit]。如
basic.target 是否还有依赖，直到所有的 Requires 都检测完，当依赖的[Unit]都被激活后，
才能继续加载服务。
动哪个服务器的功能是相同的。在这里第一个引导的 target 必须为Alias=default.target 固定值
都是表示依赖关系，但是会在依赖冲突的时候暂时解除依赖关系。
是起引导顺序的功能，我们还会在[Unit]里面见到“Wants=”的设置项，它和Requires一样
的“Requires=”表示强制依赖关系，即 multi-user.target若要正常启动则需要先调用basic.
后会读取multi-user.target，主要内容如下：
systemd/system/default.target 命令，我们这里以 multi-user.target 为例，systemd 找到默认级别
用multi-user.target 和 graphical.target，即 sysVinit 的级别3和级别5：
第一个目标会加载/etc/systemd/system/default.target配置文件；default.target文件通常是符号
lib/systemd/systemd，它被作为1号进程，替代了sysVinit方式的/sbin/init：
systemd在内核加载完成之后，第一个引导的程序称为 systemd命令。命令的绝对路径为/usr/
继续跟踪引导过程，由于存在Requires=basic.target 的设置项，因此 systemd会读取
oiv[Install]关键字在这里表示开机是否需要加载，和 sysVinit的chkconfigon设置开机时启
这是一个标准的目标文件内容，格式上一般会有[Unit] 和[Insta] 两部分，[Unit]部分
[Unit]
如果需要更改默认的目标则可以使用 In-sf /lib/systemd/system/.target /etc/
systemd已经使用目标替代了运行级别，所以在/etc/inittab中是看不到默认启动级别的。
Alias=default.target
[Install]
After=basic.target rescue.service rescue.target
Requires=basic.target
lib/systemd/system/multi-user.target
[root@localhost~]#1s-l/etc/systemd/system/default.target
-rwxr-xr-x.1 root root 1230912 Sep 15 21:21 /usr/lib/systemd/systemd
[root@localhost]# ls -1/usr/lib/systemd/systemd
-- --- 5    0 
[root@localhost~]# ps -ef | grep systemd
下面以CentOS 7.0系统自带的NTP服务为大家分析一下 systemd引导的全过程。
-deserialize 21
第6章使用systemd管理Linux系统服务133
---
## Page 150
务单元来为大家分析一下：
单元，这就是之前我们提到的 systemd兼容 sysVinit脚本的方式了。i鼠弥
systemd会在／etc/init.d中寻找同名的sysVinit脚本，并且根据同名脚本自动创建一个service
确的结束，然后将缓存数据刷新到磁盘中。如果手工启动或停止某个不存在的 service，那么
文件中）。通常情况下service文件会隐含地包含以下4个设置：
务。可以简单地将其理解为 sysVinit时代的启动脚本（它们通常被放在/etc/init.d下的可执行
里称作服务单元配置文件，特点是以.service结尾，service文件用来封装真正需要启动的服
的符号链接。它们在我的测试机上面的格式如下：
multi-user.target 文件，还有multi-user.target.wants/目录，里面还包含了其他 target 和 service
件夹，并在里面写人其他target或服务来表示依赖，例如在/lib/systemd/system下，不但有
134运维前线：一线运维专家的运维方法、技巧与实践
具体应该怎么引导呢？接下来我们看一个.service文件，这里是通过一个简单的NTP服
这4个设置用于保证该服务是在基础环境加载完成之后才开始加载的，在系统关机前正
 Requires=basic.target 
我们可以看到 multi-user.target 的依赖关系中除了其他的 target 还有 service，service 在这
After=syslog.target network.target nss-lookup.target
Description=Set time via NTP
[Unit]
ntp.service
Before=shutdown.target
Conflicts=shutdown.target
After=basic.target
systemd-user-sessions.service
lrwxrwxrwx.1 root root 32 Mar 24 16:05 systemd-user-sessions.service ->
logind.service
lrwxrwxrwx.1root root 25 Mar 24 16:05 systemd-1ogind.service ->../systemd-
systemd-ask-password-wall.path
rwxrwxrwx.
plymouth-quit-wait.service
lrwxrwxrwx.
quit.service
lrwxrwxrwx.
rwxrwxrwx
rwxrwxrwx
rwxrwxrwx.1 rootroot16Mar2416:06brandbot.path->
total0
[root@localhost system]#pwd
1 root root 33 Mar 24 16:05 systemd-ask-password-wall.path ->
root
root
root15
Mar
2415:34
dbus.service
../getty.target
./dbus.service
./brandbot.path
---
## Page 151
6.3
可用来方便我们进行运维工作。
的引导过程就为大家介绍到这里了，接下来我们来看看systemd提供了哪些系统管理的命令，
Shell脚本的情况下就可以配置各个服务之间的依赖关系了，而且还是并行引导的。systemd
sync 这个target之前就加载。这就是sytemd解决引导顺序的方法。
加载完成之后才能加载，但不必考虑依赖关系，而 Before-time-sync.target则要求它在 time-
这两个关键字用于保证这个服务的加载顺序，要在syslog.target network.target nss-lookup.target
文件的[Socket] 来指定socket通信的位置。
的时候，就会检测到这个BusName，进而通过 socket通信。这个隐含选项调用了 dbus.socket
service，使用 Dbus 类型不但要指定类型，还要设置一个BusName，后续启动的进程有依赖
持这个 service 是 active 状态，以供其他的 service进行检测。
是否存在还是无法确定程序是否成功执行过，那么通过这个参数就可以确定，systemd会保
程序，特别是这种典型的网络程序的时候，程序执行一次后就会退出了，如果通过检查进程
service下所有的执行文件都执行完退出之后，状态是否还是active 状态。因为在使用一次性
wrapper会退出，而“RemainAfter=”参数一般会作为 onshot类型的补充，用来表示这
务是onshot类型，因此在这个 servie文件启动成功之后，“ExecStart=”后面跟着的 ntpdate
束。而oneshot 则表示 systemd启动后续的服务之后这个程序会退出。在这个例子中NTP服
服务的主进程，会一直运行下去，直到systemd结束为止，或者运维工程师手动将此服务：
型包括 simple 和 oneshot 两种，当 Type=simple的时候，“ExecStart=”指定的进程就是该
部分用于对允许程序的行为进行管理，其中“Type=”设置的是进程启动的类型，常见的类
systemd就是利用这些关键字完成了复杂的启动依赖关系，运维工程师甚至可以在不懂
另外，我们再介绍一种Type类型：Type=Dbus，它最典型的应用就是NetworkManager.
从这个文件里面我们看到还有[Unit]小节，这里有两个关键字“Before=”和“Wants=”
systemd 兼容了 sysVinit的进程控制类命令，同时还把需要修改配置文件才能生效的功
首先我们来看[Service]部分，每个.service配置文件都必须包含[Service]部分，这个
WantedBy=multi-user.target
[Install]
RemainAfterExit=yes
ExecStart=/usr/libexec/ntpdate-wrapper
Type=oneshot
Wants=time-sync.target
[Service]
Before=time-sync.target
systemd的进程控制命令
第6章使用systemd管理Linux系统服务135
---
## Page 152
如下：
提供的hostnamectl命令可以只用一条命令就能完成上述操作，hostnamectl命令的执行方法
hostname命令设置当前的主机名，为避免主机名失效还需要将主机名写入配置文件；通过systemd
6.3.2
因此更方便使用。
的对应关系，如表6-1所示：
命令和service命令的常用方法：
置开机自动加载的服务，service可用于控制服务当前的运行状态。这里先来看下chkconfig
6.3.1
loginctl、timedatectl命令。
能也封装成了新的命令。这里介绍一下 systemd新增加的 systemctl、hostnamectl、localectl、
136
在CentOS5.x/6.x的工作环境中，设置主机名往往需要多步操作才能完成，首先要通过
通过表6-1的对比，
systemctl disable network.service
systemctl enablenetwork.service
systemctl stop network.service
systemctl startnetwork.service
service 和chkconfig这两个命令可被 systemctl替代，以 network服务为例，来看下它们
sysVinit 环境下最常使用的命令是 service 和chkconfig，chkconfig命令可用于查看和设
[root@localhost ~]#hostnamectl
[root@localhost ~]#hostnamectl set-hostname host1
Usage:/etc/init.d/network{start|stop|status|restart|reloadlforce-reload}
[root@localhost ~]# service network help
network
[root@localhost~]# chkconfig
hostnamectl 命令
systemctI命令
Operating System: Centos Linux 7 (Core)
运维前线：一线运维专家的运维方法、技巧与实践
Virtualization: kvm
Static hostname:host1
systemd
BootID:4084e70ebc8047d3ae7eb01f5a41dbdc
Machine ID:9f9558a2a43914e8b079acbdbe9804c7
，大家应该很容易理解systemctl命令，它将两个命令整合到了一起
表6-1systemd与 sysVinit 服务管理命令对照表
Icon name: host1
0:off
Chassis: n/a
1:off
--listnetworklgrep network
status
chkconfig network off
chkconfig network on
servicenetwork stop
servicenetworkstart
sysVinit
2:on
3:on
4:on
开机不加载network服务
开机加载network服务
立即停止network服务
立即运行network服务
功
5:on
聘
6:off
---
## Page 153
命令的执行方法如下：
看当前系统的用户 sessionID，通过指定的 session ID可以查看某一会话的详细信息。loginctl
使用命令的情况，loginctl 命令常用的参数有 list-sessions 和 session-status, list-sessions 可以查
6.3.4loginctl 命令
要立即生效，可以使用如下命令进行修改：
置文件来确保下次启动时生效。systemd 提供了 localectl命令来进行设置，通常的用法是：
的方式查看当前系统的语言和字符集，为持久化语言和字符集，通常设置/etc/locale.conf配
6.3.3
loginctl是一个会话状态控制命令，它能够列出用户的会话信息，帮助管理员定位用户
打开新的终端和重启之后再查询字符集会发现它已经变成新的状态了，
，修改字符集，这也是管理员在服务器初始化时经常要做的事情，通常使用echo SLANG
3 sessions listed.
export
[root@localhost ~]# localectl  set-locale LANG=zh_CN.gbk
例如将系统改为简体中文GBK字符集，可以使用如下命令：
[root@localhost~]# loginctl
[root@localhost~]# loginct]
localectl
localectl
localectl 命令
Leader:3596
SESSION
LANG=zh_CN.gbk
Service:
200
Architecture:x86_64
Remote:remote.kvm.vt
Since: Thu 2015-12-10 17:47:15 CST; 38min ago
State:active
set-localeLANG=设置字符集
list-locales 查看系统支持的字符集
Unit: session-200.scope