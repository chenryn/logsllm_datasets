workﬂows may be exploitable too by changing values that
each module expects in input during a redirection. For in-
stance, in our running example, the execution of the vulnera-
ble query in module addcat.php depends on the execution of
module room.php, which sets the value of the PHP variable
$_SESSION[‘room_name’], which is checked in addcat.php
(line 1). To be able to generate non-trivial exploits, an
approach must take into account a wide range of possible
workﬂows both intended and unintended.
Data Sanitization and Path Sensitivity. To generate a
working exploit, the transformations and sanitizations of user
input along diﬀerent paths to the sinks must be precisely
modeled. For instance, even though the example contains
several queries, only two of them are vulnerable because of
insuﬃcient sanitization on some paths leading to them. For
example, the path going through line 6 in Listing 4 is not
vulnerable, while the path going through line 4 is vulnerable.
Our approach must therefore take into account the diﬀerent
3. APPROACH
In order to successfully generate exploits, we need to tackle
the challenge of scale: what are the paths that we must
explore to make opportunistic exploit generation successful?
Our approach makes the observation that it is possible to
rank the paths based on their constraint solving costs, and
proceeds to construct exploits starting from those that require
least analysis and solving complexity.
Our overall approach, as shown in Figure 1, is to gain
greater coverage in an initial analysis step and construct
working exploits in three subsequent steps. The ﬁrst step,
called Seed Generation, considers each module in isolation,
and builds a precise model of the computation on its inputs.
Speciﬁcally, the approach generates exploit seeds, which are
a veriﬁed set of inputs that direct the execution to a vul-
nerable sink inside a module. Seed generation is local to a
module and is guided by a detailed attack speciﬁcation and
database schema speciﬁcation In the subsequent stages of
the approach (i.e. Workﬂow Inference and Workﬂow Re-
ﬁnement), we use a conﬁned exploration strategy focused
at deriving a sequence of HTTP requests that navigates the
attacker along a sequence of modules to reach one of the ex-
ploit seeds generated in the prior step. This is done through
methods that selectively explore a subset of paths through
the application in order to generate exploits. In the next
subsections, we provide a detailed view of these steps.
3.1 Seed Generation
The goal of this phase is to identify sinks that are feasible
targets for exploits and to prune out sensitive sinks that
are not vulnerable. Speciﬁcally, an exploit seed is a pair
(S, I), where S denotes a sensitive sink that is vulnerable and
I = {(i1, v1), ...(in, vn)} is the set of variable-value pairs that
must be sent in input to the module containing S in order
to exploit S. The output of this phase is a list of exploit
seeds present in various modules of the application. Since
this phase represents only the starting point of our approach,
we keep its discussion brief.
For every sink inside a module, Chainsaw explores sym-
bolically all execution paths from sources (i.e. user input to
that module) to that sink (i.e. mysql query() and echo-like
functions) and, for each sink, it builds a symbolic sink ex-
pression and a symbolic formula FP . In the symbolic sink
expression, the data arguments are represented as program
constants or symbolic values computed from the operations
performed on variables used in the sink. In other words,
the symbolic execution constructs a symbolic expression for
643Figure 1: Approach Overview.
static (data arguments are constants) and dynamic sinks
(data arguments are variables).
The formula FP represents the (1) path conditions, (2)
input transformations along the paths to the sink and (3)
constraints arising out of the sink context. Finally, each
symbolic formula FP is joined with an attack speciﬁcation
FA, which contains constraints over the variable values at the
sinks. For instance, the symbolic formula FP related to the
sink at line 13 in Listing 3, and a possible attack speciﬁcation
FA are as follows:
FP : isset($ SESSION[‘username’]) ∧ isset($ SESSION[‘room name’])
∧ $room name==$ SESSION[‘room name’] ∧ $accesslevel== 1 ∧
isset($ GET[‘cat desc’]) ∧ $cat desc==htmlspecialchars($ GET[‘cat
desc’])
FA: $cat desc==”foo’ OR ’1’==’1”
Our analysis to obtain the symbolic sink and formula is
based on our past work [6]. It is inter-procedural, path sen-
sitive as well as context sensitive, based on performing inter-
procedural slicing of system dependency graphs (SDGs) [14].
For each sink, the corresponding SDG captures all program
statements that construct the queries (data dependencies)
and control ﬂows among these statements. We then compute
backward slices for sinks such that each slice represents a
unique control path from a source to the sink along with
path conditions. When this path contains statements in the
static-single-assignment (SSA) form (which is the ﬁrst step
in our analysis), constructing components (1) and (2) above
of the symbolic formula is straightforward (a discussion of
component (3) above appears in section 4.1).
One important detail to mention at this point is that any
PHP superglobal present in a module is left unconstrained in
this phase, making the analysis local to the module. These
superglobals may be constrained in this module, but may
be assigned values in other modules. For example, in mod-
ule room.php the superglobal $_SESSION[‘username’] is con-
strained, but is set in login.php. To make a successful exploit
out of an exploit seed, Chainsaw must ﬁnd a sequence of
module executions that produce appropriate assignments to
superglobals in order to direct the execution to the seed sink.
We explain this procedure in the next section.
3.2 Navigation Problem
This problem can be stated as follows: Given an exploit
seed in a module MN , is there an execution path along a
navigation sequence of modules (M1, ..., MN ) that satisﬁes
the constraints of the exploit seed? In the rest of the paper
we call such execution path that spans a navigation sequence
(M1, ..., MN ) global execution path. A global execution path
is essentially composed as a concatenation of local execution
paths belonging to each of the modules Mi. For instance, to
trigger an exploit in line 13 in addcat.php, a local execution
path from room.php must be executed ﬁrst, followed by a
local execution path from dashboard.php, which is ﬁnally
followed by the local execution path in addcat.php.
One of the main challenges of this problem, indeed the main
bottleneck for Chainsaw, is the number of global execution
paths that need to be considered for every exploit seed. This
number depends on the number of navigation sequences
that lead to the module containing that exploit seed and
on the number of local execution paths inside each module.
More speciﬁcally, given an exploit seed inside a module
MN , every navigation sequence (M1, ..., MN ), contains a
number of global execution paths equal to the product of
the numbers of local execution paths in each module. In
the worst case, these global paths must all be computed and
processed during the search. For this reason, to optimize
the search for feasible paths, Chainsaw eﬃciently ranks the
possible navigation sequences according to their number of
global execution paths, in an increasing order and chooses
the next possible navigation sequence based on this order.
The intuition behind this choice is to be able to process as
many navigation sequences as possible per unit of time.
Speciﬁcally, Chainsaw ﬁrst builds a navigation graph
called General Workﬂow Graph (GWFG), which represents
all possible navigation sequences and derives the ranking of
the navigation sequences from this graph. Next, for each
navigation sequence, Chainsaw builds a Reﬁned Workﬂow
Graph (RWFG) whose goal is to enable the search for global
execution paths that satisfy the exploit seed. We explain the
two steps below.
3.2.1 Workﬂow Inference
The General Workﬂow Graph (GWFG) is a weighted di-
graph G = (V, E) where each vertex v ∈ V represents a
module of the web application and each edge e = (vi, vk) ∈ E
represents a navigation from vi to vk. The weight on each
edge e = (vi, vk) represents the cost (as the increase in the
number of global execution paths) incurred by Chainsaw
if it were to explore that edge in the navigation sequence.
Speciﬁcally, to build a list of navigation sequences ranked by
the number of global execution paths, we use the k shortest
paths algorithm [11] on the GWFG, which, given a weighted
digraph ﬁnds the k shortest paths between two nodes ranked
by path cost. To reconcile the k shortest paths algorithm
cost deﬁnition as the sum of the weights along the edges
with the Chainsaw’ s cost deﬁnition as the product of the
execution paths along the edges, in the GWFG we assign to
each edge e = (vi, vk) a weight equal to log2(nk), where nk
is the number of execution paths in vk.
For instance, in Figure 2, which represents our example
(with one additional module: check.php), there are two navi-
gation sequences between room.php and create.php, one via
dashboard.php with a total cost of 10 (= 210 = 1024 global
SolverSeed GenerationExploit SeedWorkﬂow InferenceWorkﬂow ReﬁnementNavigationSequencesLocal PathConstraintsSolverWorking ExploitsGlobal Path ConstraintsDB DataAttack Spec.Application644collects a set of preconditions for every vertex vj. This
set contains the conditions that are checked along the path
represented by vj. Using these two sets, Chainsaw does not
connect vi and vj if there are inconsistencies between the
path summary of vi and the preconditions of vj. When we
cannot determine any inconsistencies, we connect the two
vertices. As an example, the table in Figure 3 shows the
summaries and preconditions of one possible global execution
path that leads to the vulnerable sink in addcat.php.
For every global execution path that leads to an exploit
sink, Chainsaw creates a symbolic formula that represents
the computations and conditions along that global path.
Next, it adds the constraints of the attack speciﬁcation to
this symbolic formula using the context of the exploit seed
(See section 4.1 for details on context awareness), and uses
the solver to look for a solution. The solver solution, if found,
contains the values to all local and superglobal variables that
need to be sent to every module in the navigation sequence
in order to reach the exploit seed.
3.3 Second Order Exploits
The backend database of a web application is an important
component that contains a large portion of that application’s
state. Such state often drives the control and data ﬂow
inside the application. When creating the symbolic formulas,
Chainsaw includes the state of the database by adding
constraints representing the database values. The main
challenge in dealing with the database state is that it is always
evolving, thus exploits may become feasible or unfeasible
depending on it.
In addition, the database can be used as a channel in second
order attacks, such as second-order SQLI and stored XSS.
In these attacks, speciﬁc content is entered in the database
using a SQL sensitive sink with the goal of reaching a second
sensitive sink after it is retrieved from the database. This
second sink can be another SQL query sink or an XSS sink.
One of the main strengths of Chainsaw is its ability to
precisely model the database state. This capability enables
a more precise generation of ﬁrst and second-order exploits.
We describe the techniques used by Chainsaw next.
Static Input Generation. Often, the feasibility of an
exploit at a sensitive sink relies on conditions along the path
to that sink that depend on the database state. For instance,
the execution of the query in line 13 of Listing 3 depends on
the value of the PHP variable $accesslevel, which in turn is
retrieved from the database by the query in Line 5. Clearly,
if the database does not contain a value equal to 1 for the
room level, then execution will not proceed further.
To ensure that the generated exploits are feasible, Chain-
saw generates new values for the database, when needed.
More speciﬁcally, Chainsaw ﬁrst builds (during analysis) a
mapping between writes to a database (insert and update
queries) and the select queries that read from the same
table. Using this mapping, Chainsaw identiﬁes the write
statement that can be used to insert the needed values in
the database. For instance, the insert query that inserts
the value of the column level, is in Listing 4.
As a next step, Chainsaw constructs inputs that will take
the application to insert the desired value in the database.
More speciﬁcally: (i) it sets that write operation as a sink and
derives the formula FP relative to that sink, (ii) a constraint
formula FD that represents the desired value to insert, and
(iii) sends the formula FP ∧ FD to the solver. In our example,
Figure 2: A simpliﬁed version of the running example General
Workﬂow Graph. For simplicity, some modules are not shown
such as delcat.php.
execution paths), and one via check.php with a total cost of
12 (212 = 4096 global execution paths). Therefore Chainsaw
processes the former ﬁrst, since it has a smaller number of
global execution paths.
The GWFG is constructed by identifying statements in
the code responsible for navigation (e.g. HTML forms, links,
PHP redirection, etc.) and their targets, and adding ver-
tices and edges to the graph correspondingly. In short, the
GWFG represents all possible navigation sequences in the
application.
The output of the workﬂow inference module is a set of
navigation sequences ranked by the total number of possi-
ble global execution paths. The next phase processes each
sequence to ﬁnd the global execution paths that satisfy the
constraints of the exploit seed.
3.2.2 Reﬁned Workﬂow Graph
Once a navigation sequence (M1,...,MN ) is selected, the
next task of Chainsaw is to ﬁnd a global execution path
inside that sequence that leads to an exploit seed. We note
that this global execution path is composed as the concate-
nation of execution paths inside each of the modules in the
navigation sequence.
To extract the global execution paths, Chainsaw builds
a reﬁned workﬂow graph (RWFG) for every navigation se-
quence. The RWFG is a directed graph G = (V, E) where
each vertex represents a local execution path from one of the
modules in the sequence and each edge e = (vi, vj) ∈ E rep-
resents a transition from one local execution path to another,
that is the fact that the execution path vj (in module Mj)
follows the execution path vi (in module Mi). Thus, a global
execution path corresponds to a path on the RWFG.
An instance of the RWFG, representing the navigation
sequence (room.php, dashboard.php, addcat.php), is shown
in the left half of Figure 3. In this ﬁgure, every module is
represented by a set of nodes, where each node represents a
local execution path (for space constraints we do not show
all local execution paths). A global execution path for this
sequence is represented by the RWFG path (L2, A3, D2).
As mentioned before, the number of global execution paths
that needs to be considered for every exploit seed is the
main bottleneck of Chainsaw. We can reduce this number
signiﬁcantly by removing from the RWFG those edges that
are clearly unfeasible. In other words, if we can show that a
local execution path Ai in a module cannot follow another
local execution path Li in another module, then we can
remove the corresponding edge from the RWFG. To do this,
Chainsaw ﬁrst builds a path summary for every vertex vi of
the RWFG. This summary includes the assignments to the
superglobals in the path represented by vi. Next, Chainsaw
    room.php functions.php include dashboard.php redirect form redirect redirect redirect create.php check.php redirect redirect link addcat.php 8 4 4 7 7 7 4 6 dashboard.php addcat.php redirect room.php redirect form L1 L2  D2 redirect A2 A1 A3  D1 Node Preconditions Summary   L2 1.isset($_GET[‘mode’])(cid:154) 2.isset($_SESSION[‘username’] (cid:154) 3.isset($_POST[‘room_name’]) (cid:154) 4.isset($_POST[‘category’]) (cid:154) 5.isset($mode) (cid:154) $mode==”enter”   $_SESSION[‘room_name’]    A3 1.isset($_SESSION [‘username’] (cid:154) 2.isset($_SESSION  [‘room_name’])  (cid:154) 3.isset($_GET[‘mode’])  (cid:154) 4.isset($_GET[‘cat_desc’])  (cid:154) 5.isset($mode) (cid:154) $mode==”addcat” (cid:135)    D2 1.isset($_SESSION [‘username’] (cid:154) 2.isset($_SESSION  [‘room_name’]) (cid:154) 3.isset($_GET[‘cat_desc’]) (cid:154) 4.$accesslevel==1 (cid:135)     645Figure 3: A Simpliﬁed Reﬁned Workﬂow Graph for the running example (on the left). The table (on the right) shows the
preconditions and the summary of the global execution path (nodes: L2, A3 and D2) to the vulnerable sink in addcat.php
we ask the solver to provide the input values needed, in order
to have the value 1 for the variable $level in the insert
query in line 10 of Listing 4.
For generating second order exploits, the procedure is
similar. Note that, for a second order exploit, there are
generally two sensitive sinks of interest. The ﬁrst sink is a
write query, which inserts a payload in the database. The
second sink is another query or statement, which uses the
payload data without proper sanitization (e.g., in a second-
order SQLI, or a stored XSS). For second order exploit
generation, the small addition from the above procedure
is that, Chainsaw uses an attack speciﬁcation FA that is
suitable to generate an exploit at the second sink.
Dynamic Auditing. In addition to static input generation,
which inserts data in the database, Chainsaw is also able to
use existing database data of a live system by including con-
straints arising from the its state in the symbolic execution.
We call this capability dynamic auditing. More speciﬁcally,
Chainsaw augments the symbolic formulas in three steps:
(1) DB-PHP mapping: by analyzing the symbolic query a
mapping is created between PHP variables and column names
of the corresponding table. In some cases these mappings
can be inferred directly from the WHERE clause construc-
tion, which concatenates a database column name with a
PHP variable name (e.g., WHERE room_name=‘$room_name’ in
room.php), while in other cases these mappings can be in-
ferred from the code that processes the query’s result set
(e.g., the PHP variable $room_row[’level’] is mapped to
the database column level in addcat.php). (2) Data re-
trieval: once a mapping is created, the query is modiﬁed by
removing the WHERE clause and by running a (Select *) query
over the same table. This ensures that all possible values
are retrieved from the database. (3) Constraints creation: a
new term TD is added to the current path formula FP repre-
senting the constraints on the PHP variable values derived
from the database.
To illustrate the above procedure, let us consider the query
in Listing 3: SELECT room_name,level FROM ROOM_TABLE WHE-
RE room_name=‘$room_name’. Suppose that ROOM_TABLE has
the following records for the attributes (level, room name):
(1, room1) and (2, room2).
In this case, we obtain the
following terms:
TD = C1 ∨ C2 where
C1 = $room row[(cid:48)level(cid:48)] == 1 ∧ $room name == ”room1”
C2 = $room row[(cid:48)level(cid:48)] == 2∧ $room name == ”room2”
Static Input Generation vs. Dynamic Auditing.
While the static input generation is a general technique, it
may create a large overhead. Consider, for instance, the
common problem of generating inputs for an insert query
Q1 in order to generate one feasible exploit for each query Qi
in a set, each dependent on Q1. With static input generation,
the input generation procedure (that is, path exploration,
symbolic evaluation, and constraint solving), for Q1 must
be repeated for as many times as the number of the Qi-
s, while with dynamic auditing, such input generation is
not needed, since the data can be directly retrieved from