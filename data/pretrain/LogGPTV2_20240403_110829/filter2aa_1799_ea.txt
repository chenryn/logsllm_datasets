Caching and file systems
611
Windows relies on the Common Internet File System (CIFS) protocol to format messages exchanged 
between the redirector and the server. CIFS is a version of Microsoft’s Server Message Block (SMB) 
protocol. (For more information on SMB, go to https://docs.microsoft.com/en-us/windows/win32/fileio 
/microsoft-smb-protocol-and-cifs-protocol-overview.)
Like local FSDs, client-side remote FSDs usually use cache manager services to locally cache file data 
belonging to remote files and directories, and in such cases both must implement a distributed locking 
mechanism on the client as well as the server. SMB client-side remote FSDs implement a distributed cache 
coherency protocol, called oplock (opportunistic locking), so that the data an application sees when it 
accesses a remote file is the same as the data applications running on other computers that are accessing 
the same file see. Third-party file systems may choose to use the oplock protocol, or they may implement 
their own protocol. Although server-side remote FSDs participate in maintaining cache coherency across 
their clients, they don’t cache data from the local FSDs because local FSDs cache their own data.
It is fundamental that whenever a resource can be shared between multiple, simultaneous acces-
sors, a serialization mechanism must be provided to arbitrate writes to that resource to ensure that only 
one accessor is writing to the resource at any given time. Without this mechanism, the resource may 
be corrupted. The locking mechanisms used by all file servers implementing the SMB protocol are the 
oplock and the lease. Which mechanism is used depends on the capabilities of both the server and the 
client, with the lease being the preferred mechanism. 
Oplocks The oplock functionality is implemented in the file system run-time library (FsRtlXxx
functions) and may be used by any file system driver. The client of a remote file server uses an oplock to 
dynamically determine which client-side caching strategy to use to minimize network traffic. An oplock 
is requested on a file residing on a share, by the file system driver or redirector, on behalf of an applica-
tion when it attempts to open a file. The granting of an oplock allows the client to cache the file rather 
than send every read or write to the file server across the network. For example, a client could open a 
file for exclusive access, allowing the client to cache all reads and writes to the file, and then copy the 
updates to the file server when the file is closed. In contrast, if the server does not grant an oplock to a 
client, all reads and writes must be sent to the server.
Once an oplock has been granted, a client may then start caching the file, with the type of oplock 
determining what type of caching is allowed. An oplock is not necessarily held until a client is finished 
with the file, and it may be broken at any time if the server receives an operation that is incompatible with 
the existing granted locks. This implies that the client must be able to quickly react to the break of the 
oplock and change its caching strategy dynamically.
Prior to SMB 2.1, there were four types of oplocks:
I 
Level 1, exclusive access This lock allows a client to open a file for exclusive access. The client
may perform read-ahead buffering and read or write caching.
I 
Level 2, shared access This lock allows multiple, simultaneous readers of a file and no writers.
The client may perform read-ahead buffering and read caching of file data and attributes. A
write to the file will cause the holders of the lock to be notified that the lock has been broken.
612
CHAPTER 11
Caching and file systems
I 
Batch, exclusive access This lock takes its name from the locking used when processing
batch (.bat) files, which are opened and closed to process each line within the file. The client
may keep a file open on the server, even though the application has (perhaps temporarily)
closed the file. This lock supports read, write, and handle caching.
I 
Filter, exclusive access This lock provides applications and file system filters with a mecha-
nism to give up the lock when other clients try to access the same file, but unlike a Level 2 lock,
the file cannot be opened for delete access, and the other client will not receive a sharing viola-
tion. This lock supports read and write caching.
In the simplest terms, if multiple client systems are all caching the same file shared by a server, 
then as long as every application accessing the file (from any client or the server) tries only to read the 
file, those reads can be satisfied from each system’s local cache. This drastically reduces the network 
traffic because the contents of the file aren’t sent to each system from the server. Locking information 
must still be exchanged between the client systems and the server, but this requires very low network 
bandwidth. However, if even one of the clients opens the file for read and write access (or exclusive 
write), then none of the clients can use their local caches and all I/O to the file must go immediately 
to the server, even if the file is never written. (Lock modes are based upon how the file is opened, not 
individual I/O requests.) 
An example, shown in Figure 11-19, will help illustrate oplock operation. The server automatically 
grants a Level 1 oplock to the first client to open a server file for access. The redirector on the client 
caches the file data for both reads and writes in the file cache of the client machine. If a second client 
opens the file, it too requests a Level 1 oplock. However, because there are now two clients accessing 
the same file, the server must take steps to present a consistent view of the file’s data to both clients. 
If the first client has written to the file, as is the case in Figure 11-19, the server revokes its oplock and 
grants neither client an oplock. When the first client’s oplock is revoked, or broken, the client flushes 
any data it has cached for the file back to the server.
Time
File open
Cached read(s)
Cached write(s)
Flushes cached
modified data
Noncached read(s)
Noncached write(s)
Client 1
Client 2
Grant Level 1
oplock to Client 1
File open
Oplock request
Oplock
request
Level 1 grant
Oplock break
to none
Data flush
No oplock
granted
Noncached read(s)
Noncached write(s)
Break Client 1
to no oplock
Do not grant
Client 2 oplock
Server
FIGURE 11-19 Oplock example.
CHAPTER 11
Caching and file systems
613
If the first client hadn’t written to the file, the first client’s oplock would have been broken to a 
Level 2 oplock, which is the same type of oplock the server would grant to the second client. Now both 
clients can cache reads, but if either writes to the file, the server revokes their oplocks so that non-
cached operation commences. Once oplocks are broken, they aren’t granted again for the same open 
instance of a file. However, if a client closes a file and then reopens it, the server reassesses what level of 
oplock to grant the client based on which other clients have the file open and whether at least one of 
them has written to the file.
EXPERIMENT: Viewing the list of registered file systems
When the I/O manager loads a device driver into memory, it typically names the driver object 
it creates to represent the driver so that it’s placed in the \Driver object manager directory. The 
driver objects for any driver the I/O manager loads that have a Type attribute value of SERVICE_
FILE_SYSTEM_DRIVER (2) are placed in the \FileSystem directory by the I/O manager. Thus, using 
a tool such as WinObj (from Sysinternals), you can see the file systems that have registered on a 
system, as shown in the following screenshot. Note that file system filter drivers will also show up 
in this list. Filter drivers are described later in this section.
Another way to see registered file systems is to run the System Information viewer. Run 
Msinfo32 from the Start menu’s Run dialog box and select System Drivers under Software
Environment. Sort the list of drivers by clicking the Type column, and drivers with a Type attri-
bute of SERVICE_FILE_SYSTEM_DRIVER group together.
EXPERIMENT: Viewing the list of registered file systems
When the I/O manager loads a device driver into memory, it typically names the driver object 
it creates to represent the driver so that it’s placed in the \Driver object manager directory. The 
driver objects for any driver the I/O manager loads that have a Type attribute value of SERVICE_
FILE_SYSTEM_DRIVER (2) are placed in the \FileSystem directory by the I/O manager. Thus, using 
a tool such as WinObj (from Sysinternals), you can see the file systems that have registered on a 
system, as shown in the following screenshot. Note that file system filter drivers will also show up 
in this list. Filter drivers are described later in this section.
Another way to see registered file systems is to run the System Information viewer. Run 
Msinfo32 from the Start menu’s Run dialog box and select System Drivers under Software
Environment. Sort the list of drivers by clicking the Type column, and drivers with a Type attri-
bute of SERVICE_FILE_SYSTEM_DRIVER group together.
614
CHAPTER 11
Caching and file systems
Note that just because a driver registers as a file system driver type doesn’t mean that it is 
a local or remote FSD. For example, Npfs (Named Pipe File System) is a driver that implements 
named pipes through a file system-like private namespace. As mentioned previously, this list will 
also include file system filter drivers.
Leases
Prior to SMB 2.1, the SMB protocol assumed an error-free network connection between 
the client and the server and did not tolerate network disconnections caused by transient network 
failures, server reboot, or cluster failovers. When a network disconnect event was received by the cli-
ent, it orphaned all handles opened to the affected server(s), and all subsequent I/O operations on the 
orphaned handles were failed. Similarly, the server would release all opened handles and resources 
associated with the disconnected user session. This behavior resulted in applications losing state and in 
unnecessary network traffic.
Note that just because a driver registers as a file system driver type doesn’t mean that it is 
a local or remote FSD. For example, Npfs (Named Pipe File System) is a driver that implements 
named pipes through a file system-like private namespace. As mentioned previously, this list will 
also include file system filter drivers.
CHAPTER 11
Caching and file systems
615
In SMB 2.1, the concept of a lease is introduced as a new type of client caching mechanism, similar to 
an oplock. The purpose of a lease and an oplock is the same, but a lease provides greater flexibility and 
much better performance. 
I 
Read (R), shared access
Allows multiple simultaneous readers of a file, and no writers. This
lease allows the client to perform read-ahead buffering and read caching.
I 
Read-Handle (RH), shared access
This is similar to the Level 2 oplock, with the added
benefit of allowing the client to keep a file open on the server even though the accessor on the
client has closed the file. (The cache manager will lazily flush the unwritten data and purge the
unmodified cache pages based on memory availability.) This is superior to a Level 2 oplock be-
cause the lease does not need to be broken between opens and closes of the file handle. (In this
respect, it provides semantics similar to the Batch oplock.) This type of lease is especially useful
for files that are repeatedly opened and closed because the cache is not invalidated when the
file is closed and refilled when the file is opened again, providing a big improvement in perfor-
mance for complex I/O intensive applications.
I 
Read-Write (RW), exclusive access
This lease allows a client to open a file for exclusive ac-
cess. This lock allows the client to perform read-ahead buffering and read or write caching.
I 
Read-Write-Handle (RWH), exclusive access
This lock allows a client to open a file
for exclusive access. This lease supports read, write, and handle caching (similar to the
Read-Handle lease).
Another advantage that a lease has over an oplock is that a file may be cached, even when there are 
multiple handles opened to the file on the client. (This is a common behavior in many applications.) This 
is implemented through the use of a lease key (implemented using a GUID), which is created by the client 
and associated with the File Control Block (FCB) for the cached file, allowing all handles to the same file to 
share the same lease state, which provides caching by file rather than caching by handle. Prior to the in-
troduction of the lease, the oplock was broken whenever a new handle was opened to the file, even from 
the same client. Figure 11-20 shows the oplock behavior, and Figure 11-21 shows the new lease behavior.
Prior to SMB 2.1, oplocks could only be granted or broken, but leases can also be converted. For 
example, a Read lease may be converted to a Read-Write lease, which greatly reduces network traffic 
because the cache for a particular file does not need to be invalidated and refilled, as would be the case 
with an oplock break (of the Level 2 oplock), followed by the request and grant of a Level 1 oplock.
616
CHAPTER 11
Caching and file systems
Client
Windows
Network
    Server
Application A
opens a file on
a server
Application A
receives a handle
to the file on
the server
Application A
issues a read
to the file
Application A
receives only the
amount of data
it requested
Application A
issues a read to
the file within
the area cached
Application B
opens the same
file on the server
for read access
Application A
issues a write to
the file within
the area cached
Application B
receives a handle
to the file on
the server
Application A
issues a read to
the file for an
area that was
previously cached
Application A
issues a write to
the file in an
area that was
previously
cached
First handle
on the 
file opened
Data read
from file
Server 
opens
second
handle
to file
Data read
from file
Data
written
to file
Batch oplock granted
Read data returned
Server unaware
Server unaware
No network packets
No network packets
Batch oplock broken
Read data returned
Write data to server
Read data from server
Cache flushed and no more
caching allowed on the file
Read-ahead data written
to cache
Read data and 
read-ahead from server
CreateFile (with
FILE_GENERIC_READ and
FILE_GENERIC_WRITE)
CreateFile (same file with
FILE_GENERIC_READ)
I/O complete
Data given to application
I/O complete
WriteFile
WriteFile
ReadFile
ReadFile
ReadFile
Handle
Handle
I/O complete
Data given to application
I/O complete
Cached data given to application
I/O complete
FIGURE 11-20 Oplock with multiple handles from the same client.
CHAPTER 11