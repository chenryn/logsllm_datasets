如果客户系统不充许修改原有类或不充许访问其上下文，那么该解
决方案甚至可能是不可用的。这在实践中是很常见的场景，特别是
当这些类被归入到一个程序库中，例如将其放在一个金融契约程序
库中。这样就不可能允许使用该程序库的应用程序作者修改它。
对此，基本的面向对象技术（Meyer1997）并不够用。针对该问
题，厂泛应用的标准的面向对象解决方案是访问者模式（Gamma等
1994）。在下面只是对该模式的概略描述，并不是标准的介绍，但
1252
---
## Page 1254
也足够对该观点做一总结。（它是Meyer的《Touchofclass：An
IntroductiontoProgrammingWell[2008]》一书中所作的总结，它说明
了这些基础概念是如何出现的，这本书可以选作第一学期的编程教
科书。）图13-5列出了该模式所涉及的角色。
CLIENT
访问者模式参与者
.accept(u)
客户（调用）
客户（了解信息）
A
T_TARGET
F_VISITOR
u.T_uisit(Current)
图13-5：访问者模式的参与者
该模式在应用程序（诸如CLIENT之类的类）和原有类型（诸如针
对特定类型T的T_TARGET，在我们的示例中就是PUDDING或
CONTRACT）跳“双人芭蕾舞”，并且通过为每个可应用的操作F引
入一个访问者类FVISITOR，使其演变成"三角家庭”。诸如CLIENT
之类的应用程序类在调用目标类的操作时，将会把相应的访问者作
为参数传入，例如：
my_fruit_salad.accept (cost_visitor)
accept（v：VISITOR）命令将通过调用其参数v（在本例中就是
cost_visitor）来执行该操作，它是诸如FRUIT_SALAD_visit类的一
个特性，该名称中体现了目标类型。该特性是类描述的一部分，在
此是FRUIT_SALAD：它将应用于相应类型的一个对象上（在此是
fruitsalad对象），它将作为参数传给特性Tvisit。Current是Eiffel中
针对当前对象的表示法（类似于大家所知道的"this"或“self"）。调
用的目标，也就是图中的v，表示该操作将使用相应访问者类型的
一个对象，诸如COST_VISITOR。当我们评价可扩展性时，对于软
件架构最为关键的问题始终是“知识分发”（distributionof
knowledge）。有一种方法能够实现可扩展性，那就是限制模块必须
拥有的与其他模块相关的知识总量（这样当添加或修改某个模块
时，对原有结构的影响就将最少）。为了让大家理解访问者模式的
精妙之处，看看每个参与者必须知道什么、不需要知道什么是十分
有必要的：
1253
---
## Page 1255
目标类知道某种特定的类型，同时也知道类型层次结构中的上下文
（例如，FRUITSALAD从COMPOSITEPUDDING中继承，而
COMPOSITEPUDDING又从PUDDING中继承）。它无需知道外部
所需要的新操作，诸如获取生产某种布丁所需的成本。
访问者类必须知道与特定操作相关的所有信息，诸如成本，并为一
组相关的类型提供相应的变量，以及通过参数指示相应的对象：在
本例中，我们将发现诸如fruit_salad_cost、flan_cost、tart_cost等例
程。
客户类需要对特定类型的对象应用一个指定的操作，因此必须知道
这些类型（只需知道它们存在，而不关心它们的其他属性）和操作
（只要它们存在并且适用于指定类型，无需知道每个的特定算
法）。
某些所需的操作，诸如accept和T_visit特性，必须是源于其祖先类
的。图13-6展示了带继承关系（FRUIT_SALAD将简写为SALAD）
的完整图。
tram_uisir*
PUDDING_
Ouerall
NIOOnd
faxi_uisir*
structure
uisitor
VISITOR
TARGETCLASSES
v.T_visit
VISITORCLASSES
(Current)
TARGET
COST
SUGAR
VISITOR
VISITOR
alad_uisir*
salad_uisir+
saiad_uisir*
flan_ulsir+
flan_uisir*
flan_uisit+
accept（u）
客户（调用）
延期
客户（了解信息）
已实现
CLIENT
继承（直接或
间接）
图13-6：整合在一起：构建布丁程序的架构
像这样的架构，经常用来解决在带有许多继承关系的原有结构中添
加新操作的问题，它无需针对每个操作修改整个结构。语言处理程
序（在集成开发环境中的编译及其他工具）就是存在这种情况的常
见应用程序，它的底层结构是一个抽象语法树（AST）：每当新工
具有需要时，更新AST类都是很麻烦的，根据其意图，需要在该树
1254
---
## Page 1256
上执行一个遍历操作，对每个节点应用该工具选择的操作。（这也
就是“访问"节点，同时解释了“访问者"这一术语和Tvisit这一特性
名称的来源。）
对于所有这些操作，客户必须能够针对任何目标类型的任何执行
t.accept（v）操作。这也就假定所有目标类型都是从公共类（在此
就是PUDDING）中派生出来的，能够接受该特性的地方将以延期实
现的形式声明它。这一需求很精妙，因为整个示例的目标正好是避
免对现有的目标类进行修改。设计师在使用访问者模式时，通常会
认为该需求是可接受的，也就是意味着我们关心的类必须有相同的
祖先类，这是很常见的场景，它们是用来表示相同概念的不同类
型，诸如PUDDING或CONTRACT，我们只需要在其祖先类中添加
一个延期特性accept即可。
访问者模式应用十分广泛。读者可能已经知道它“美"在什么地方。
但在我们的视角中，这并不是最终定论。评价标准包括：
带有特定accept功能的领域特定类需要拥有共同的祖先类，不应该
受到与应用领域无关的概念的影响，无论是布丁、金融契约还是其
他东西。
更令人不安的是，随着表示每种特定知识（基于特定类型的特定操
作）的、小型的F_VISITOR类的大量增加，最终将出现“类爆炸"现
象。不过，对于整个软件架构而言，这只是一个小污点。
要清除这个污点，需要在基本的面向对象框架中添加一个新的概
念：代理。
13.6代理：将操作封装到对象中
代理（Eiffe1语言在1997年就在其基本的面向对象框架中添加了代
理；C#中的“委托"和它是等价的）的基本想法可以用函数式编程相
关论文中类似的话表述：我们将操作（函数式编程中的函数，面向
对象编程中的特性）视为“一等公民”。在面向对象上下文中，在运
行时的一等公民应该是对象，它和静态结构中的类相对应。
13.6.1代理机制
代理是一个对象，用来表示特定类的一个特性，以使被调用。一个
名为x.f（u，...）的特性的完整定义包括特性名f、目标对象x以及
1255
---
## Page 1257
参数u，......而代理表达式则将指定f，并指定一部分或全部目标对
象和参数，也可以都不指定，全部指定的代理称为已封闭的。对于
那些未提供完整信息的代理定义，则称为开放的。该表达式将指定
一个对象；该对象指定了该特性，并且包括设置指定值的参数。对
于代理对象而言，其中一个可执行的操作是call，用来表示对f的一
次调用：如果该代理还有未指定的参数，那么还必须将相应值作为
参数传给call1（对于已封闭的参数，则将使用代理定义中指定的
值）。
最简单的代理表达式是agentf。在该例子中，所有参数都是开放
的，但目标对象是已封闭的。因此，如果该代理表示式是a（它是
执行赋值语句a：=agentf的结果，或者在调用p（agentf）中，形式
变量p的值是a），那么a.call（[uv]）的效果与x.f（uv）是等价的。
当然，它们之间也是有区别的，f（uv）直接命名了该特性（尽管
动态绑定意味着可能会使用不同的已知特性），而采用代理的形
式，a只是一个名称，它是从其他程序单元中获取的。因此，在程
序的这个位置上，对于特性而言除了其签名（或者是契约）之外是
一无所知的。由于call是通用的程序库例程，它需要的参数类型只
有一种。其解决方案是使用tuple，在此是两元素的tuple[uv]。当采
用这种格式时，agentf的目标对象是封闭的（它就是当前对象），
而所有的参数都是开放的。
在此还有一个变体，agentxf，其参数是开放的，目标对象是封闭
的：它的目标对象是x而非当前对象。如果想让目标对象是开放
的，那么可以使用agentT}.f，其中T是x的类型。然后调用时就需要
使用三个参数的tuple：a.call（[x,u，v]）。为了使某些参数是开放
的，你可以使用相同的表示法，诸如agentxf（{U}，v）（其典型
的调用是a.call（[u）），但由于u的类型U是可以清晰地从上下文
中获得的，因此无需显式指定：在此只需使用问号，诸如agent
x.f（?，v）。这同时也说明最初表示所有参数均是并放的格式的表
达式agentfagentx.f，实际上就是表达式agentf（？，？）和agent
x.f（？，？）的缩写。
call机制就应用了动态绑定：f版本也应用了动态绑定，正如非代理
的调用一样，它取决于动态的目标类型。
如果f表示的是一个查询而非命令，那么你可以获取相应的代理，其
结果是用item来代替调用，也就是a.item（[x,u，v]）（它将执行一
个调用，并获得其执行结果）；你也可以先调用它然后再访问
1256
---
## Page 1258
a.last_result，这样就遵从了命令-查询分离原则，它将返回相同的
值，在连续调用时无需执行后续的调用。
对于更高级的应用，它不仅是基于一个针对原有特性的代理，你也
可以在同一行中使用代理，例如
editor_window.set_mouse_enter_action(agent do text.hightlight end），
它展示了图形用户界面上的典型应用；这是EifelVision程序库
（Eiffel软件：EiffelVision文档）中事件驱动编程的基本风格。内联
的代理提供了与函数式语言中lambda表达式相同的机制：编写操
作，使它们在软件中像数值一样直接可用，就像其他“一等公民”一
样。
总而言之，代理使面向对象框架能够定义更高等级的功能模块，就
像在函数式语言中那样，并提供了功能相当的表达式。
13.6.2代理的应用范围