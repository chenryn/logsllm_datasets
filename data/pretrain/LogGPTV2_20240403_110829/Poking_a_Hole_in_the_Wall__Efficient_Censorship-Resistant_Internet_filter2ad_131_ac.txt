gateway server, encoder service, decoder service, and SOCKS proxy
server. Both client and proxy run the gateway server and the en-
coder and decoder services. The proxy also runs the SOCKS proxy
server. Both endpoints leverage network namespaces for transpar-
ent interception and manipulation of IP packets. All these compo-
nents cooperate in forwarding covert IP trac by implementing
three cross-cutting functional layers. Next, we explain how these
layers operate by introducing them in a bottom-up fashion.
1. WebRTC layer: This layer is responsible for the setup and man-
agement of a point-to-point WebRTC covert channel between two
parties, and it is implemented by the gateway servers running on
each communication endpoint. The covert channel is piggybacked
on a WebRTC media stream instantiated by a carrier web stream-
ing application. This channel supports full-duplex bidirectional
communication and exchanges Protozoa messages dened in a spe-
cic format. These messages can contain arbitrary IP payload. The
gateway server is built out of a modied Chromium browser, and
instrumented with the placement of two hooks – upstream and
downstream – in the WebRTC stack. We leverage Chromium’s func-
tionality to provide a web browsing UI and runtime environment
which will allow for the execution of the client-side WebRTC ap-
plication code. The hooks intercept the WebRTC streams so as to
replace the payload of the WebRTC video frames with covert Pro-
tozoa messages. The gateway server opens two pipes for receiving
upstream and downstream messages from the codec layer.
2. Codec layer: This layer performs two complementary encoding
and decoding operations. The former is responsible for encoding
streams of IP packets generated by local networked applications.
Packets are read from a libnetfilter queue [56], and encapsulated
into Protozoa messages, which are forwarded to the local gateway
server and then delivered to the remote endpoint. Decoding per-
forms the reverse operation, i.e., reads incoming Protozoa messages
from the local gateway server, extracts the enclosed IP packets, and
writes them to a raw socket to be routed to their nal destination.
These operations are coordinated by the encoder and decoder at
both endpoints to sustain simultaneously two IP packet ows, i.e.,
upstream and downstream. Internally, these components maintain
packet and message queues, and implement packet fragmentation
and reassembly so as to eciently use the covert channel capacity.
3. SOCKS layer: This layer enables the exchange of IP packets
between the networked applications running on the client, and a
remote Internet host through a SOCKS v5 proxy server running on
the proxy. This is achieved by the use of Linux’s network names-
paces and conguration of iptables. Namespaces are implemented
by the Linux kernel and allow for the creation of virtual network
interfaces. In our context, we use namespaces for creating a virtual
network environment for the client application and a second one
for the SOCKS proxy server. Each environment features a virtual
network interface that is exposed to the local processes with a spe-
cic IP address, e.g., 10.10.10.10, or 20.20.20.20, respectively (see
Figure 3). Protozoa then congures the local iptables so as to route
all (upstream) IP packets with destination address 20.20.20.20 to
the namespace of the proxy, and all (downstream) IP packets with
destination address 10.10.10.10 to the namespace of the client. Thus,
by conguring a client application to use the IP address 20.20.20.20
as SOCKS proxy, all its IP connections will be transparently de-
livered to the SOCKS server proxy, which in turn will deliver the
packets to its remote destination. So, for instance, the web request
to cnn.com depicted in Figure 3 can be performed by running the
curl command on a Linux terminal as follows:
$ ip netns exec PROTOZOA_ENV_CLIENT
curl -x socks5h://20.20.20.20:1080 https://cnn.com
This means that, in order to use Protozoa’s covert tunnels, the
user must congure the client application to use a SOCKS proxy. For
client applications that do not natively support the use of SOCKS
proxy servers, the user can use an additional tool, proxychains [62],
which provides the client application with SOCKS proxy support.
4.2 Execution Workow
This section describes the execution workow involved in a com-
plete communication using Protozoa covert tunnels. Using the ex-
ample depicted in Figure 3, we describe the full message exchange
sequence that takes place in order for Alice to fetch a web page
from cnn.com through a WebRTC covert tunnel facilitated by Bob,
who is an individual volunteer trusted by Alice. This tunnel is cre-
ated through a WebRTC video call between Alice and Bob using
Whereby in the course of a Protozoa covert session, which is di-
vided into two stages: covert session establishment, and covert data
transmission. Figure 4 represents the messages exchanged.
Session 1A: Anonymous Routing and Censorship CCS '20, November 9–13, 2020, Virtual Event, USA381. Covert session establishment: The covert tunnel is set up
between client and proxy, requiring both participants to agree on
a common rendezvous point for a WebRTC media connection. In
our example, Alice and Bob use the web browsing interface of their
Protozoa gateway to join a common video chatroom. They begin by
bootstrapping the Protozoa software: Alice in client mode (A1), and
Bob in proxy mode (B1). Then, Alice accesses whereby.com, creates
a password-protected chatroom, and obtains the chatroom URL
(A2). Similarly to using alternative MCS tools [3, 46], Alice uses an
out-of-band channel, e.g., email, social network web site, or mobile
app (e.g., Whatsapp) to share the chatroom URL and password with
Bob (A3 and B2). Both users can now join the chatroom (A4 and B3)
and initiate a video call by feeding a carrier video stream from their
local cameras or (optionally) from a prerecorded video; this video
will be replaced by covert payload. As the WebRTC video stream is
initiated, Protozoa hooks into it, and sets up the covert tunnel.
2. Covert data transmission: Once the covert tunnel is ready,
Alice can access remote Internet services. For instance, to access
cnn.com, Alice can simply run the curl command listed in the sec-
tion above to issue an HTTP GET request to cnn.com. The IP trac
generated from this request will be transparently tunneled through
the covert channel. Protozoa will continuously stream video until
the termination of the covert session, even when there is no covert
trac to be transmitted; in this case, dummy payload (cha) is sent.
4.3 Network-level Security of Covert Sessions
At covert data transmission, standard WebRTC ensures that all
exchanged packets are integrity-protected and the message payload
containing sensitive video data is encrypted. Thus, an adversary
cannot read its content, or modify it without detection. Nevertheless,
we must ensure that the covert session has been securely established.
In particular, an adversary may attempt a man-in-the-middle or
an impersonation attack during the session negotiation phase (see
Figure 4) enabling it to decrypt the message payload and inspect
the covert data. To prevent these attacks, Protozoa leverages the
security mechanisms implemented by WebRTC and by the carrier
WebRTC web streaming application, namely the following ones:
a) HTTPS: Client and proxy run client-side code of the WebRTC
web application which connects to its backend servers through
HTTPS. This means that all messages involving interactions with
the backend (i.e., A2, A4, B3) will be exchanged over TLS-enabled
secure channels. In particular, this prevents an adversary from
obtaining the URL that would allow it to join the chatroom, or to
mount a MITM by advertising dierent URLs to client and proxy.
b) SIP / DTLS-SRTP: To establish a media session, WebRTC lever-
ages the Session Initiation Protocol (SIP) to signal one endpoint’s
intention (e.g., the client’s) to connect to its corresponding peer
(e.g., the proxy). This protocol involves the communication between
each endpoint (client/proxy) and a SIP server run by the WebRTC
application provider (see Figure 3). This server is used to exchange
media session parameters between endpoints, and it is combined
with the DTLS-SRTP protocol [48, 83] to perform an initial key
exchange so as to oer protection against man-in-the-middle at-
tacks. The WebRTC application provider also runs a STUN server
which helps the endpoints located behind a NAT to determine their
respective public (NAT’ed) IP addresses, and share them with their
Ce(cid:81)(cid:86)(cid:82)(cid:85)ed Regi(cid:82)(cid:81)
F(cid:85)ee Regi(cid:82)(cid:81)
A(cid:79)ice
C(cid:79)ie(cid:81)(cid:87)
B(cid:82)b
P(cid:85)(cid:82)(cid:91)(cid:92)
WebRTC (cid:86)e(cid:85)(cid:89)ice
O(cid:83)e(cid:81) I(cid:81)(cid:87)e(cid:85)(cid:81)e(cid:87)
A1. S(cid:87)a(cid:85)(cid:87) P(cid:85)(cid:82)(cid:87)(cid:82)(cid:93)(cid:82)a c(cid:79)ie(cid:81)(cid:87)
A2. Regi(cid:86)(cid:87)e(cid:85) 
cha(cid:87)(cid:85)(cid:82)(cid:82)(cid:80) URL
A3. Sha(cid:85)e cha(cid:87)(cid:85)(cid:82)(cid:82)(cid:80) URL
A4. Acce(cid:86)(cid:86) cha(cid:87)(cid:85)(cid:82)(cid:82)(cid:80) URL
B3. Acce(cid:86)(cid:86) 
cha(cid:87)(cid:85)(cid:82)(cid:82)(cid:80) URL
Sig(cid:81)a(cid:79)(cid:79)i(cid:81)g
Sig(cid:81)a(cid:79)(cid:79)i(cid:81)g
Media Se(cid:86)(cid:86)i(cid:82)n
P(cid:85)(cid:82)(cid:87)(cid:82)(cid:93)(cid:82)a C(cid:82)(cid:89)e(cid:85)(cid:87) Cha(cid:81)(cid:81)e(cid:79)
A5. GET h(cid:87)(cid:87)(cid:83)(cid:86)://(cid:90)(cid:90)(cid:90).c(cid:81)(cid:81).c(cid:82)(cid:80)
(cid:87)
n
e
m
h
(cid:86)
i
l
b
a
(cid:87)
(cid:86)
E
n
o
(cid:86)
(cid:86)
e
S
i
(cid:87)
r
e
(cid:89)
o
C
i
i
n
o
(cid:86)
(cid:86)
m
(cid:86)
n
a
r
T
a
(cid:87)
a
D
(cid:87)
r
e
(cid:89)
o
C
200 OK
P(cid:85)(cid:82)(cid:87)(cid:82)(cid:93)(cid:82)a C(cid:82)(cid:89)e(cid:85)(cid:87) Cha(cid:81)(cid:81)e(cid:79)
Media Se(cid:86)(cid:86)i(cid:82)n
(cid:172)B1. S(cid:87)a(cid:85)(cid:87) P(cid:85)(cid:82)(cid:87)(cid:82)(cid:93)(cid:82)a (cid:83)(cid:85)(cid:82)(cid:91)(cid:92)
B2. Lea(cid:85)(cid:81) cha(cid:87)(cid:85)(cid:82)(cid:82)(cid:80) URL
GET h(cid:87)(cid:87)(cid:83)(cid:86)://c(cid:81)(cid:81).c(cid:82)(cid:80)
200 OK
Figure 4: Covert session: gear symbol denotes user actions.
peers. To ensure that the media sessions between endpoints are not
hijacked and pointed to dierent IP locations, the connection at-
tempts to the IP addresses of target endpoints are secured by a MAC,
which is computed using the key exchanged in the signaling chan-
nel [63]. Once a WebRTC session has been established, WebRTC
leverages the Secure Real-time Transport Protocol (SRTP) [5, 83] for
encrypting and authenticating the content of the media in transit.
4.4 Encoded Media Tunneling
Protozoa uses the video streams generated by client and proxy as
a medium for carrying covert IP packet data in both directions.
To this end, we employ a new approach named encoded media
tunneling. Similar to existing raw media tunneling techniques [3,
46], our method replaces carrier video information with a covert