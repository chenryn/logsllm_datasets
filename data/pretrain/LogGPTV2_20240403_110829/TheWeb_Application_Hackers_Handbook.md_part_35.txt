attacker who obtains a large sample of tokens from the application be able to
extrapolate tokens issued to other users? Using the formula described here, in
general this is highly unlikely, even with full knowledge of the algorithm used.
The source IP, port number, User-Agent header, and time of request together
generate a vast amount of entropy. And even with full knowledge of these, the
attacker will be unable to produce the corresponding token without knowing
the secret string used by the server.
cc0077..iinndddd 224499 88//1199//22001111 1122::0077::4444 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 250
250 Chapter 7 n Attacking Session Management
Protect Tokens Throughout Their Life Cycle
Now that you’ve created a robust token whose value cannot be predicted, this
token needs to be protected throughout its life cycle from creation to disposal, to
ensure that it is not disclosed to anyone other than the user to whom it is issued:
n The token should only be transmitted over HTTPS. Any token transmit-
ted in cleartext should be regarded as tainted — that is, as not providing
assurance of the user’s identity. If HTTP cookies are being used to transmit
tokens, these should be fl agged as secure to prevent the user’s browser
from ever transmitting them over HTTP. If feasible, HTTPS should be used
for every page of the application, including static content such as help
pages, images, and so on. If this is not desired and an HTTP service is still
implemented, the application should redirect any requests for sensitive
content (including the login page) to the HTTPS service. Static resources
such as help pages usually are not sensitive and may be accessed without
any authenticated session. Hence, the use of secure cookies can be backed
up using cookie scope instructions to prevent tokens from being submit-
ted in requests for these resources.
n Session tokens should never be transmitted in the URL, because this pro-
vides a simple vehicle for session fi xation attacks and results in tokens
appearing in numerous logging mechanisms. In some cases, developers
use this technique to implement sessions in browsers that have cookies
disabled. However, a better means of achieving this is to use POST requests
for all navigation and store tokens in a hidden fi eld of an HTML form.
n Logout functionality should be implemented. This should dispose of all
session resources held on the server and invalidate the session token.
n Session expiration should be implemented after a suitable period of inac-
tivity (such as 10 minutes). This should result in the same behavior as if
the user had explicitly logged out.
n Concurrent logins should be prevented. Each time a user logs in, a differ-
ent session token should be issued, and any existing session belonging to
the user should be disposed of as if she had logged out from it. When this
occurs, the old token may be stored for a period of time. Any subsequent
requests received using the token should return a security alert to the
user stating that the session has been terminated because she logged in
from a different location.
n If the application contains any administrative or diagnostic functional-
ity that enables session tokens to be viewed, this functionality should be
robustly defended against unauthorized access. In most cases, there is no
need for this functionality to display the actual session token. Rather, it
should contain suffi cient details about the owner of the session for any
cc0077..iinndddd 225500 88//1199//22001111 1122::0077::4444 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 251
Chapter 7 n Attacking Session Management 251
support and diagnostic tasks to be performed, without divulging the ses-
sion token being submitted by the user to identify her session.
n The domain and path scope of an application’s session cookies should be
set as restrictively as possible. Cookies with overly liberal scope are often
generated by poorly confi gured web application platforms or web serv-
ers, rather than by the application developers themselves. No other web
applications or untrusted functionality should be accessible via domain
names or URL paths that are included within the scope of the application’s
cookies. Particular attention should be paid to any existing subdomains
to the domain name that is used to access the application. In some cases,
to ensure that this vulnerability does not arise, it may be necessary to
modify the domain- and path-naming scheme employed by the various
applications in use within the organization.
Specifi c measures should be taken to defend the session management mecha-
nism against the variety of attacks that the application’s users may fi nd them-
selves targets of:
n The application’s codebase should be rigorously audited to identify and
remove any cross-site scripting vulnerabilities (see Chapter 12). Most such
vulnerabilities can be exploited to attack session management mechanisms.
In particular, stored (or second-order) XSS attacks can usually be exploited
to defeat every conceivable defense against session misuse and hijacking.
n Arbitrary tokens submitted by users the server does not recognize should
not be accepted. The token should be immediately canceled within the
browser, and the user should be returned to the application’s start page.
n Cross-site request forgery and other session attacks can be made more dif-
fi cult by requiring two-step confi rmation and/or reauthentication before
critical actions such as funds transfers are carried out.
n Cross-site request forgery attacks can be defended against by not rely-
ing solely on HTTP cookies to transmit session tokens. Using the cookie
mechanism introduces the vulnerability because cookies are automati-
cally submitted by the browser regardless of what caused the request to
take place. If tokens are always transmitted in a hidden fi eld of an HTML
form, an attacker cannot create a form whose submission will cause an
unauthorized action unless he already knows the token’s value. In this
case he can simply perform an easy hijacking attack. Per-page tokens can
also help prevent these attacks (see the following section).
n A fresh session should always be created after successful authentication, to
mitigate the effects of session fi xation attacks. Where an application does
not use authentication but does allow sensitive data to be submitted, the
threat posed by fi xation attacks is harder to address. One possible approach
cc0077..iinndddd 225511 88//1199//22001111 1122::0077::4444 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 252
252 Chapter 7 n Attacking Session Management
is to keep the sequence of pages where sensitive data is submitted as short
as possible. Then you can create a new session at the fi rst page of this
sequence (where necessary, copying from the existing session any required
data, such as the contents of a shopping cart). Or you could use per-page
tokens (described in the following section) to prevent an attacker who
knows the token used in the fi rst page from accessing subsequent pages.
Except where strictly necessary, personal data should not be displayed
back to the user. Even where this is required (such as a “confi rm order”
page showing addresses), sensitive items such as credit card numbers and
passwords should never be displayed back to the user and should always
be masked within the source of the application’s response.
Per-Page Tokens
Finer-grained control over sessions can be achieved, and many kinds of session
attacks can be made more diffi cult or impossible, by using per-page tokens in
addition to session tokens. Here, a new page token is created every time a user
requests an application page (as opposed to an image, for example) and is passed
to the client in a cookie or a hidden fi eld of an HTML form. Each time the user
makes a request, the page token is validated against the last value issued, in
addition to the normal validation of the main session token. In the case of a
non-match, the entire session is terminated. Many of the most security-critical
web applications on the Internet, such as online banks, employ per-page tokens
to provide increased protection for their session management mechanism, as
shown in Figure 7-12.
Figure 7-12: Per-page tokens used in a banking application
The use of per-page tokens does impose some restrictions on navigation (for
example, on use of the back and forward buttons and multiwindow browsing).
cc0077..iinndddd 225522 88//1199//22001111 1122::0077::4444 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 253
Chapter 7 n Attacking Session Management 253
However, it effectively prevents session fi xation attacks and ensures that the
simultaneous use of a hijacked session by a legitimate user and an attacker
will quickly be blocked after both have made a single request. Per-page tokens
can also be leveraged to track the user’s location and movement through the
application. They also can be used to detect attempts to access functions out of
a defi ned sequence, helping protect against certain access control defects (see
Chapter 8).
Log, Monitor, and Alert
The application’s session management functionality should be closely integrated
with its mechanisms for logging, monitoring, and alerting to provide suitable
records of anomalous activity and to enable administrators to take defensive
actions where necessary:
n The application should monitor requests that contain invalid tokens.
Except in the most predictable cases, a successful attack that attempts
to guess the tokens issued to other users typically involves issuing large
numbers of requests containing invalid tokens, leaving a noticeable mark
in the application’s logs.
n Brute-force attacks against session tokens are diffi cult to block altogether,
because no particular user account or session can be disabled to stop the
attack. One possible action is to block source IP addresses for an amount
of time when a number of requests containing invalid tokens have been
received. However, this may be ineffective when one user’s requests origi-
nate from multiple IP addresses (such as AOL users) or when multiple
users’ requests originate from the same IP address (such as users behind
a proxy or fi rewall performing network address translation).
n Even if brute-force attacks against sessions cannot be effectively prevented
in real time, keeping detailed logs and alerting administrators enables
them to investigate the attack and take appropriate action where they can.
n Wherever possible, users should be alerted to anomalous events relating
to their session, such as concurrent logins or apparent hijacking (detected
using per-page tokens). Even though a compromise may already have
occurred, this enables the user to check whether any unauthorized actions
such as funds transfers have taken place.
Reactive Session Termination
The session management mechanism can be leveraged as a highly effective
defense against many kinds of other attacks against the application. Some
security-critical applications such as online banking are extremely aggressive in
terminating a user’s session every time he or she submits an anomalous request.
cc0077..iinndddd 225533 88//1199//22001111 1122::0077::4455 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 254
254 Chapter 7 n Attacking Session Management
Examples are any request containing a modifi ed hidden HTML form fi eld or
URL query string parameter, any request containing strings associated with
SQL injection or cross-site scripting attacks, and any user input that normally
would have been blocked by client-side checks such as length restrictions.
Of course, any actual vulnerabilities that may be exploited using such requests
need to be addressed at the source. But forcing users to reauthenticate every
time they submit an invalid request can slow down the process of probing the
application for vulnerabilities by many orders of magnitude, even where auto-
mated techniques are employed. If residual vulnerabilities do still exist, they
are far less likely to be discovered by anyone in the fi eld.
Where this kind of defense is implemented, it is also recommended that it
can be easily switched off for testing purposes. If a legitimate penetration test
of the application is slowed down in the same way as a real-world attacker, its
effectiveness is dramatically reduced. Also, it is very likely that the presence
of the mechanism will result in more vulnerabilities remaining in production
code than if the mechanism were absent.
HACK STEPS
If the application you are attacking uses this kind of defensive measure, you
may fi nd that probing the application for many kinds of common vulnerabili-
ties is extremely time-consuming. The mind-numbing need to log in after each
failed test and renavigate to the point of the application you were looking at
would quickly cause you to give up.
In this situation, you can often use automation to tackle the problem.
When using Burp Intruder to perform an attack, you can use the Obtain
Cookie feature to perform a fresh login before sending each test case, and
use the new session token (provided that the login is single-stage). When
browsing and probing the application manually, you can use the extensibility
features of Burp Proxy via the IBurpExtender interface. You can create an
extension that detects when the application has performed a forced logout,
automatically logs back in to the application, and returns the new session
and page to the browser, optionally with a pop-up message to tell you what
has occurred. Although this by no means removes the problem, in certain
cases it can mitigate it substantially.
Summary
The session management mechanism provides a rich source of potential vulner-
abilities for you to target when formulating your attack against an application.
Because of its fundamental role in enabling the application to identify the same
user across multiple requests, a broken session management function usually
cc0077..iinndddd 225544 88//1199//22001111 1122::0077::4455 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 255
Chapter 7 n Attacking Session Management 255
provides the keys to the kingdom. Jumping into other users’ sessions is good.
Hijacking an administrator’s session is even better; typically this enables you
to compromise the entire application.
You can expect to encounter a wide range of defects in real-world session
management functionality. When bespoke mechanisms are employed, the
possible weaknesses and avenues of attack may appear to be endless. The most
important lesson to draw from this topic is to be patient and determined. Quite
a few session management mechanisms that appear to be robust on fi rst inspec-
tion can be found wanting when analyzed closely. Deciphering the method an
application uses to generate its sequence of seemingly random tokens may take
time and ingenuity. But given the reward, this is usually an investment well
worth making.
Questions
Answers can be found at http://mdsec.net/wahh.
1. You log in to an application, and the server sets the following cookie:
Set-cookie: sessid=amltMjM6MTI0MToxMTk0ODcwODYz;
An hour later, you log in again and receive the following:
Set-cookie: sessid=amltMjM6MTI0MToxMTk0ODc1MTMy;
What can you deduce about these cookies?
2. An application employs six-character alphanumeric session tokens and
fi ve-character alphanumeric passwords. Both are randomly generated
according to an unpredictable algorithm. Which of these is likely to be
the more worthwhile target for a brute-force guessing attack? List all the
different factors that may be relevant to your decision.
3. You log in to an application at the following URL:
https://foo.wahh-app.com/login/home.php
and the server sets the following cookie:
Set-cookie: sessionId=1498172056438227; domain=foo.wahh-
app.com; path=/login; HttpOnly;
You then visit a range of other URLs. To which of the following will your
browser submit the sessionId cookie? (Select all that apply.)
(a) https://foo.wahh-app.com/login/myaccount.php
(b) https://bar.wahh-app.com/login
(c) https://staging.foo.wahh-app.com/login/home.php
(d) http://foo.wahh-app.com/login/myaccount.php
cc0077..iinndddd 225555 88//1199//22001111 1122::0077::4455 PPMM
Stuttard c07.indd V3 - 07/22/2011 Page 256
256 Chapter 7 n Attacking Session Management
(e) http://foo.wahh-app.com/logintest/login.php
(f) https://foo.wahh-app.com/logout
(g) https://wahh-app.com/login/
(h) https://xfoo.wahh-app.com/login/myaccount.php
4. The application you are targeting uses per-page tokens in addition to the
primary session token. If a per-page token is received out of sequence, the
entire session is invalidated. Suppose that you discover some defect that
enables you to predict or capture the tokens issued to other users who are
currently accessing the application. Can you hijack their sessions?
5. You log in to an application, and the server sets the following cookie:
Set-cookie: sess=ab11298f7eg14;
When you click the logout button, this causes the following client-side
script to execute:
document.cookie=”sess=”;
document.location=”/”;
What conclusion would you draw from this behavior?
cc0077..iinndddd 225566 88//1199//22001111 1122::0077::4455 PPMM
Stuttard c08.indd V3 - 07/28/2011 Page 257
CHAPTER
8
Attacking Access Controls
Within the application’s core security mechanisms, access controls are logically
built on authentication and session management. So far, you have seen how an
application can fi rst verify a user’s identity and then confi rm that a particular
sequence of requests that it receives originated from the same user. The primary
reason that the application needs to do these things — in terms of security, at
least — is because it needs a way to decide whether it should permit a given
request to perform its attempted action or access the resources it is requesting.
Access controls are a critical defense mechanism within the application because
they are responsible for making these key decisions. When they are defective, an
attacker can often compromise the entire application, taking control of adminis-
trative functionality and accessing sensitive data belonging to every other user.
As noted in Chapter 1, broken access controls are among the most commonly
encountered categories of web application vulnerability, affecting a massive 71
percent of the applications recently tested by the authors. It is extremely com-
mon to encounter applications that go to all the trouble of implementing robust
mechanisms for authentication and session management, only to squander that
investment by neglecting to build effective access controls on them. One reason
that these weaknesses are so prevalent is that access control checks need to be
performed for every request and every operation on a resource that particular
user attempts to perform, at a specifi c time. And unlike many other classes of
control, this is a design decision that needs to be made by a human; it cannot
be resolved by employing technology.
257
cc0088..iinndddd 225577 88//1199//22001111 1122::0088::3311 PPMM
Stuttard c08.indd V3 - 07/28/2011 Page 258
258 Chapter 8 n Attacking Access Controls
Access control vulnerabilities are conceptually simple: The application lets you
do something you shouldn’t be able to. The differences between separate fl aws
really come down to the different ways in which this core defect is manifested and
the different techniques you need to employ to detect it. This chapter describes all