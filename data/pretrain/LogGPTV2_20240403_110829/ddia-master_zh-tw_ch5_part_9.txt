为了最终达成一致，副本应该趋于相同的值。如何做到这一点？有人可能希望复制的资料库能够自动处理，但不幸的是，大多数的实现都很糟糕：如果你想避免丢失资料，你（应用程式开发人员）需要知道很多有关资料库冲突处理的内部资讯。
在 “[处理写入冲突](#处理写入冲突)” 一节中已经简要介绍了一些解决冲突的技术。在总结本章之前，让我们来更详细地探讨这个问题。
#### 最后写入胜利（丢弃并发写入）
实现最终收敛的一种方法是宣告每个副本只需要储存 **“最近”** 的值，并允许 **“更旧”** 的值被覆盖和抛弃。然后，只要我们有一种明确的方式来确定哪个写是 “最近的”，并且每个写入最终都被复制到每个副本，那么复制最终会收敛到相同的值。
正如 **“最近”** 的引号所表明的，这个想法其实颇具误导性。在 [图 5-12](../img/fig5-12.png) 的例子中，当客户端向资料库节点发送写入请求时，两个客户端都不知道另一个客户端，因此不清楚哪一个先发送请求。事实上，说这两种情况谁先发送请求是没有意义的：既然我们说写入是 **并发（concurrent）** 的，那么它们的顺序就是不确定的。
即使写入没有自然的排序，我们也可以强制进行排序。例如，可以为每个写入附加一个时间戳，然后挑选最大的时间戳作为 **“最近的”**，并丢弃具有较早时间戳的任何写入。这种冲突解决演算法被称为 **最后写入胜利（LWW, last write wins）**，是 Cassandra 唯一支援的冲突解决方法【53】，也是 Riak 中的一个可选特征【35】。
LWW 实现了最终收敛的目标，但以 **永续性** 为代价：如果同一个键有多个并发写入，即使它们反馈给客户端的结果都是成功的（因为它们被写入 w 个副本），也只有一个写入将被保留，而其他写入将被默默地丢弃。此外，LWW 甚至可能会丢弃不是并发的写入，我们将在 “[有序事件的时间戳](ch8.md#有序事件的时间戳)” 中进行讨论。
在类似快取的一些情况下，写入丢失可能是可以接受的。但如果资料丢失不可接受，LWW 是解决冲突的一个很烂的选择。
在资料库中使用 LWW 的唯一安全方法是确保一个键只写入一次，然后视为不可变，从而避免对同一个键进行并发更新。例如，Cassandra 推荐使用的方法是使用 UUID 作为键，从而为每个写操作提供一个唯一的键【53】。
#### “此前发生”的关系和并发
我们如何判断两个操作是否是并发的？为了建立一个直觉，让我们看看一些例子：
* 在 [图 5-9](fig5-9.png) 中，两个写入不是并发的：A 的插入发生在 B 的递增之前，因为 B 递增的值是 A 插入的值。换句话说，B 的操作建立在 A 的操作上，所以 B 的操作必须后发生。我们也可以说 B **因果依赖（causally dependent）** 于 A。
* 另一方面，[图 5-12](fig5-12.png) 中的两个写入是并发的：当每个客户端启动操作时，它不知道另一个客户端也正在对同样的键执行操作。因此，操作之间不存在因果关系。
如果操作 B 了解操作 A，或者依赖于 A，或者以某种方式构建于操作 A 之上，则操作 A 在操作 B 之前发生（happens before）。一个操作是否在另一个操作之前发生是定义并发含义的关键。事实上，我们可以简单地说，如果两个操作中的任何一个都不在另一个之前发生（即，两个操作都不知道对方），那么这两个操作是并发的【54】。
因此，只要有两个操作 A 和 B，就有三种可能性：A 在 B 之前发生，或者 B 在 A 之前发生，或者 A 和 B 并发。我们需要的是一个演算法来告诉我们两个操作是否是并发的。如果一个操作发生在另一个操作之前，则后面的操作应该覆盖前面的操作，但是如果这些操作是并发的，则存在需要解决的冲突。
> #### 并发性、时间和相对性
>
> 如果两个操作 **“同时”** 发生，似乎应该称为并发 —— 但事实上，它们在字面时间上重叠与否并不重要。由于分散式系统中的时钟问题，现实中是很难判断两个事件是否是 **同时** 发生的，这个问题我们将在 [第八章](ch8.md) 中详细讨论。
>
> 为了定义并发性，确切的时间并不重要：如果两个操作都意识不到对方的存在，就称这两个操作 **并发**，而不管它们实际发生的物理时间。人们有时把这个原理和物理学中的狭义相对论联络起来【54】，该理论引入了资讯不能比光速更快的思想。因此，如果两个事件发生的时间差小于光透过它们之间的距离所需要的时间，那么这两个事件不可能相互影响。
>
> 在计算机系统中，即使光速原则上允许一个操作影响另一个操作，但两个操作也可能是 **并发的**。例如，如果网路缓慢或中断，两个操作间可能会出现一段时间间隔，但仍然是并发的，因为网路问题阻止一个操作意识到另一个操作的存在。
#### 捕获"此前发生"关系
我们来看一个演算法，它可以确定两个操作是否为并发的，还是一个在另一个之前。简单起见，我们从一个只有一个副本的资料库开始。一旦我们知道了如何在单个副本上完成这项工作，我们可以将该方法推广到具有多个副本的无主资料库。
[图 5-13](../img/fig5-13.png) 显示了两个客户端同时向同一购物车新增专案。（如果这样的例子让你觉得无趣，那么可以想象一下两个空中交通管制员同时把飞机新增到他们正在跟踪的区域。）最初，购物车是空的。然后客户端向资料库发出五次写入：
1. 客户端 1 将牛奶加入购物车。这是该键的第一次写入，伺服器成功储存了它并为其分配版本号 1，最后将值与版本号一起回送给客户端。
2. 客户端 2 将鸡蛋加入购物车，不知道客户端 1 同时添加了牛奶（客户端 2 认为它的鸡蛋是购物车中的唯一物品）。伺服器为此写入分配版本号 2，并将鸡蛋和牛奶储存为两个单独的值。然后它将这两个值 **都** 返回给客户端 2 ，并附上版本号 2。
3. 客户端 1 不知道客户端 2 的写入，想要将面粉加入购物车，因此认为当前的购物车内容应该是 [牛奶，面粉]。它将此值与伺服器先前向客户端 1 提供的版本号 1 一起传送到伺服器。伺服器可以从版本号中知道 [牛奶，面粉] 的写入取代了 [牛奶] 的先前值，但与 [鸡蛋] 的值是 **并发** 的。因此，伺服器将版本号 3 分配给 [牛奶，面粉]，覆盖版本 1 的值 [牛奶]，但保留版本 2 的值 [鸡蛋]，并将所有的值返回给客户端 1。
4. 同时，客户端 2 想要加入火腿，不知道客户端 1 刚刚加了面粉。客户端 2 在最近一次响应中从伺服器收到了两个值 [牛奶] 和 [鸡蛋]，所以客户端 2 现在合并这些值，并新增火腿形成一个新的值 [鸡蛋，牛奶，火腿]。它将这个值传送到伺服器，带著之前的版本号 2 。伺服器检测到新值会覆盖版本 2 的值 [鸡蛋]，但新值也会与版本 3 的值 [牛奶，面粉] **并发**，所以剩下的两个值是版本 3 的 [牛奶，面粉]，和版本 4 的 [鸡蛋，牛奶，火腿]。
5. 最后，客户端 1 想要加培根。它之前从伺服器接收到了版本 3 的 [牛奶，面粉] 和 [鸡蛋]，所以它合并这些，新增培根，并将最终值 [牛奶，面粉，鸡蛋，培根] 连同版本号 3 发往伺服器。这会覆盖版本 3 的值 [牛奶，面粉]（请注意 [鸡蛋] 已经在上一步被覆盖），但与版本 4 的值 [鸡蛋，牛奶，火腿] 并发，所以伺服器将保留这两个并发值。
![](../img/fig5-13.png)
**图 5-13  在同时编辑购物车时捕获两个客户端之间的因果关系。**
[图 5-13](../img/fig5-13.png) 中的操作之间的资料流如 [图 5-14](../img/fig5-14.png) 所示。箭头表示哪个操作发生在其他操作之前，意味著后面的操作知道或依赖于较早的操作。在这个例子中，客户端永远不会完全拿到伺服器上的最新资料，因为总是有另一个操作同时进行。但是旧版本的值最终会被覆盖，并且不会丢失任何写入。
![](../img/fig5-14.png)
**图 5-14 图 5-13 中的因果依赖关系图。**
请注意，伺服器可以只通过检视版本号来确定两个操作是否是并发的 —— 它不需要对值本身进行解释（因此该值可以是任何资料结构）。该演算法的工作原理如下：
* 伺服器为每个键维护一个版本号，每次写入该键时都递增版本号，并将新版本号与写入的值一起储存。
* 当客户端读取键时，伺服器将返回所有未覆盖的值以及最新的版本号。客户端在写入前必须先读取。
* 当客户端写入键时，必须包含之前读取的版本号，并且必须将之前读取的所有值合并在一起（针对写入请求的响应可以像读取请求一样，返回所有当前值，这使得我们可以像购物车示例那样将多个写入串联起来）。
* 当伺服器接收到具有特定版本号的写入时，它可以覆盖该版本号或更低版本的所有值（因为它知道它们已经被合并到新的值中），但是它必须用更高的版本号来储存所有值（因为这些值与正在进行的其它写入是并发的）。
当一个写入包含前一次读取的版本号时，它会告诉我们的写入是基于之前的哪一种状态。如果在不包含版本号的情况下进行写操作，则与所有其他写操作并发，因此它不会覆盖任何内容 —— 只会在随后的读取中作为其中一个值返回。
#### 合并并发写入的值
这种演算法可以确保没有资料被无声地丢弃，但不幸的是，客户端需要做一些额外的工作：客户端随后必须合并并发写入的值。Riak 称这些并发值为 **兄弟（siblings）**。
合并并发值，本质上是与多主复制中的冲突解决问题相同，我们先前讨论过（请参阅 “[处理写入冲突](#处理写入冲突)”）。一个简单的方法是根据版本号或时间戳（最后写入胜利）来选择一个值，但这意味著丢失资料。所以，你可能需要在应用程式程式码中额外做些更聪明的事情。