## 关于native层的调试-so
首先介绍一下什么是native层。接下来会介绍so层的patch，调试及基于so层简单的反调试和pass技巧。
##### native
一般指android的底层的，这个层的代码大部分由c/c++实现，具体的机制为JNI，齐为双向机制通过JNI，java代码可以访问c/c++代码，而c/c++代码也可以可以访问java。（理解比较浅薄欢迎大家一起交流）
### so文件的简单patch破解
参考链接：
上面的链接包括简单调试阶段所需要的文件。这里就是简单log打印一个字符串。
#### apk反编译及so文件查找
这里的步骤大家应该比较熟悉，就是`apktools d
xxx.apk`加上`-o`可以指定输入的文件名，然后查找到文件所在位置。`/lib/x86`这里看大家的机器机用的什么架构，我本地虚拟机的架构为x86.
#### ida反编译及patch
关于ida的下载和使用这里就不多说了，其实也可以用NASA的那个工具，因为平时打CTF，ida用的比较熟这里就用它进行一个简单的破解。找到主要函数，这里名称很明显。。。
接下来就是进行patch,将界面切换到hex数据位置
找到我们需要更改的字符串然后右键`edit`或者按f2
改成我们需要的字符即可,然后再按f2或者`Apply changes`
然后导出文件即可，然后`apktools d ./xxx.apk`接着进行一个签名即可。
成功后效果
##### 总结
这是一个简单的demo，让大家大概有个patch的了解，接下来进入so层的调试。
### so层签名验证及静态绕过与动态绕过
参考链接：
这里主要讲一个简单的在so层的验证，绕过的方法有patch判断流程及动态更改寄存器。（ps：当你反编译再打包什么都没改，再按登陆程序会自动退出。
#### ida分析so层
之前的反编译，寻找步骤这里就都跳过了。查看一下全局变量字符串。根据交叉引用定位函数所在位置
此处为验证逻辑,v5为apk的签名，这里很明显是利用一个if语句进行判断，接下来我们进行一个汇编的查看。
汇编查看,这里利用的是jnz跳转，那么思路一样我们进行patch让其可以进行一个我想要的转跳，改成jz即可。
更改的相关说明，因为打CTF的原因用keypatch比较多，但是尝试过在arm下用这个插件可能会不成功，这里x86是成功的，读者可以像之前上文一样hex下更改ascii。
运行程序查看log信息看我们是否成功。
##### 总结
这个实验我们又成功啦！恭喜你已经会简单的反二次打包啦
#### 动态调试改寄存器
接下来讲第二种方法，对其进行绕过。利用的程序还是我们二次打包的程序但是并不进行patch。
#### ida断点
先对文件下一个断点，就断在之前我们patch的位置，因为之前的CTF基础对ida用起来还是很顺手（又安利一波CTF）
#### ida动态调试前准备
首先讲ida安装文件下的server文件放在你的安卓设备目录下，只要是一个有权限的目录即可`./data/local/tmp`这是我的目录。然后运行
进行一个端口转发`adb forward tcp:23946 tcp:23946`
#### ida选项设置
option选项选择地址
attach
因为进程太多所以可以进行一个search来进行搜索。
#### modify the register
这里进行一个进程的attach后，会运行到我们之前下断点的地方。修改zf寄存器为1即可。
成功后的结果
##### 总结
又成功的绕过了签名的检查啦。回顾下这些签名绕过方法，本质就是劫持了一段程序流，让他跳转到了我们想去的地方。
### 总结
下一篇讲会更深入的讲解so层的反调试实现和绕过，还有xpose模块的使用。