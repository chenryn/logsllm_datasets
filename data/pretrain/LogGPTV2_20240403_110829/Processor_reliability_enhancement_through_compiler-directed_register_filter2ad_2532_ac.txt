**授权使用限制：清华大学。下载时间：2021年3月20日 09:58:58 UTC，来源：IEEE Xplore。适用相关限制。**

### 寄存器名称调整
寄存器名称调整的代码片段如下：
```assembly
loop:
    ldbu  a5, -1(t10)       ; 读取a5
    add   t9, t8, R1        ; 加法操作
    lld   R2, 0x1, t10      ; 加载链接
    astb  R1, t10           ; 存储原子
    xor   t10, a5, t8, t9   ; 异或操作
    bne   loop              ; 分支不等于时跳转
```
在连续迭代中，可以相应地确定寄存器名称调整。由于逻辑寄存器的映射在每次迭代中都会变化，在循环体内的第一次赋值之前和之后的读访问应该指向不同的物理寄存器。具体来说，所有在首次写入操作后的读访问（该操作重新映射了逻辑寄存器）应指向新分配的物理寄存器。相反，所有在首次写入操作之前的读访问应该获取上一次迭代产生的值，因此需要编译器额外调整寄存器名称。

以bzip2循环中的逻辑寄存器`a5`为例，如表I的第一列所示，`a5`的名称被编译器调整为`B1O(2)`。因为`a5`在指令2中被重新映射，所以在循环体内对`a5`的所有后续读访问都应指向`B1O(2)`。另一方面，指令1在`a5`被重新映射之前读取它，因此应获取上一次迭代中`a5`的值，此时`a5`的名称不是`B1O(2)`而是`B2O(2)`。因此，编译器应在指令1中将`a5`的名称额外调整`O(2)`，以保持这种跨迭代的依赖关系。

通过在进入循环之前插入额外的移动指令来传递寄存器值，可以使活变量（如`a5`、`t8`和`t10`）正确初始化。这些很少在循环体外执行的寄存器移动指令实际上不会带来任何性能或能耗上的开销。

为了具体说明上述目标和源寄存器名称调整策略，将其应用于图3中bzip2循环的非展开版本。利用表I中的模加运算作为调整函数，图3展示了转换后代码前两次迭代中的寄存器名称。可以看出，编译器根据它们作为目标出现的顺序全局调整了寄存器名称。相邻但不同的寄存器目标名称相差`O(2)=-1`的偏移量，而每个活变量读引用（指令1、2、3和4中显示）则额外增加了`O(2)`的偏移量。同时，在指令7（循环分支）中插入了一个提示，以便一旦分支被采取，除了只读寄存器`ra`之外，每个寄存器名称都将额外增加`O=1`的偏移量。最后，在进入循环之前插入了三个寄存器移动指令，分别初始化活变量`a5`、`t8`和`t10`。

### 可移动逻辑寄存器识别
所提出的寄存器调整方案要求对寄存器访问模式进行详细检查，以确定循环体内访问的逻辑寄存器是否可移动。一般而言，该方案的特性排除了两类逻辑寄存器的应用。首先，由于逻辑寄存器在首次赋值时会被重新映射，只读寄存器（例如bzip2示例中的`ra`）变得不可移动。更复杂的情况是，循环体内具有条件定义的寄存器；由于编译器需要为每次读访问确定产生值的确切迭代次数，如果逻辑寄存器在每次循环迭代中没有可靠更新，即仅在有条件执行的基本块中有写访问但在这些块外部有读访问，则不能对该寄存器进行调整。

条件定义的寄存器会产生不确定的跨迭代依赖问题，这可以通过检查图4中的四个案例来更清楚地说明。这四个案例共享相同的控制流，但在循环体内对寄存器`R1`的访问模式各不相同。在图4a中，基本块`B2`中的写访问构成了一个条件定义。然而，`R1`仍然是可移动的，因为它在同一基本块内跟随写访问被读取，从而允许为这两个访问分配相同的寄存器名称。类似地，在图4b中，`R1`也是可移动的，因为`B1`中的写访问构成无条件定义，表明`B1`中的读访问总是应获取前一次迭代中定义的值。同样，在图4c中，尽管`B2`和`B3`中的写访问都不能保证被执行，但这两个访问结合在一起构成了无条件定义，使`R1`成为可移动的。相比之下，在图4d中，`R1`仅在分支的直通路径上被写入，导致读访问获取的值可能是在前一次迭代或更早的迭代中定义的，取决于分支的结果。因此，对于`B1`中的这种读访问，编译器无法静态确定产生值的确切迭代次数，从而使`R1`不可移动。

不可移动的逻辑寄存器如果在循环体内不频繁访问，则不需要重新映射。然而，在极端情况下，如果不可移动寄存器被频繁访问，可以采用两种方法防止局部热积聚。一种硬件导向的方法是将该寄存器的值复制到专用缓冲区进行访问，而不是耗电的寄存器文件。另一种软件导向的方法是在循环体内插入额外的移动指令使其可移动。如果这个寄存器恰好是一个条件定义的寄存器（例如图4d中的`R1`），可以在分支另一路径执行的基本块（图4d中的`B3`）中插入这样的移动指令。如果频繁访问但不可移动的寄存器恰好是只读寄存器，则需要在无条件执行的基本块中插入额外的移动指令。

### 物理寄存器重新分配分析
第IV-A节中的示例表明，所提出的确定性调整方法至少需要一个空闲的额外寄存器，如图2c中的`t12`，用于循环体内的第一个目标寄存器的调整。大多数热点执行通常由包含有限数量指令的嵌套循环组成，因此只需要访问部分寄存器即可满足这一需求。图2a中的bzip2示例清楚地证实了这一点，因为在循环体内仅访问了总共32个寄存器中的6个。理论上，调整窗口只需要包括一个额外的空闲寄存器以及可移动的目标寄存器，但由于追求更加平衡的寄存器访问分布，最大化调整窗口中的空闲寄存器数量是有利的。

详细检查表明，根据访问模式，所有逻辑寄存器及其对应的物理寄存器可以分为三类：可移动、不可移动和未访问。对于第三类，循环体内未访问的物理寄存器可以直接重新映射，前提是它不在整个循环执行期间持有生命周期有限的活变量。例如，在bzip2循环中，除了保留的备用寄存器外，所有未访问的寄存器都可以重新映射。寄存器`sp`在整个循环中直接读取后退出循环，因此其生命周期跨越整个循环。然而，即使这类未访问但存活的寄存器也可以通过在循环入口和出口处插入额外的存储和加载指令来释放，从而在循环执行过程中保存和恢复原始值。这种检查点和恢复过程实际上不会带来性能开销，因为它们在循环执行之外执行。通过检查点和恢复存活但未访问的寄存器值，所有循环体内未访问的寄存器都可以用于重新映射。

因此，在表II列出的三类寄存器中，可移动和空闲寄存器都包含在调整窗口中，只有不可移动寄存器需要放置在调整窗口之外。这样可以最大化调整窗口的大小，从而实现更均衡的访问分布，进一步降低峰值温度。已识别的可移动和空闲寄存器可能分散在整个寄存器文件中。由于调整窗口应由一组连续的寄存器组成，因此在每个频繁执行的循环入口和出口处，需要交换一些寄存器值，以便将已识别的可移动和空闲寄存器放置在连续位置。此过程在图5中具体展示。在循环入口处，需要保存活入寄存器的值，这意味着调整窗口内的不可移动寄存器需要被交换出去，而调整窗口外的可移动但活入寄存器需要被交换进来。另一方面，在循环出口处，需要执行寄存器重新交换过程以保存活出寄存器的值，无论这些寄存器位于调整窗口内还是外。这两种寄存器交换和重新交换过程都是通过编译器插入额外的移动指令完成的，由于它们在循环体外执行，实际上不会带来开销。

### 功能评估
我们从三个方面讨论了所提出的确定性寄存器调整技术：动态调整函数、逻辑寄存器名称调整以及可移动和空闲寄存器的识别。由于该技术仅在循环迭代之间重新映射寄存器名称，因此可以独立应用于每个热点执行区域，即频繁执行的循环。由于每个循环的迭代性质和相对较短的静态代码长度，该技术能够以最小的成本提供最大的收益，只需分析大约10%的代码即可实现90%执行时间内的均衡寄存器访问。与现有的热感知寄存器重分配方法[20][18]相比，所提出的确定性寄存器调整技术不需要重新解决NP难的寄存器分配问题来进行生存范围重分配。因此，逻辑寄存器名称调整可以作为常规寄存器分配阶段之后的一个步骤来实施，从而保留后者的所有伴随优势。此外，详细检查表明，这两种技术都无法在每次循环迭代中完全平衡对每个单独寄存器的访问。相反，这两种技术都实现了相对粗粒度的访问平衡，但一种利用空间域，另一种利用时间域。热感知寄存器重分配方法在寄存器子银行的粒度上实现空间平衡，因此仅适用于多银行寄存器文件。相比之下，所提出的技术旨在以循环迭代的粒度实现时间上的平衡。由于温度上升0.1°C需要至少0.1百万个周期[6]，这种迭代平衡的访问活动即使在单银行寄存器文件中也能有效降低峰值温度。由于所提出的技术在迭代之间确定性地重新映射寄存器，当应用于没有显式寄存器重命名支持的单处理器架构时，可靠性增强方面的收益最大。对于纯动态寄存器重命名的架构（如传统的超标量处理器），需要维护一个大型硬件映射表以消除伪寄存器名称依赖。由于该映射表需要以不低于寄存器文件访问频率的速度使用逻辑寄存器名称进行访问，因此它会成为一个具有倾斜访问分布的“热点”。在这种情况下，可以使用所提出的技术均匀分布对映射表不同条目的访问。此外，未来的计算机系统预计将广泛使用多核架构，其中热引起的可靠性方面已被确认为一个重大挑战。由于此类系统通常在核心数量上向上扩展，但不一定在每个核心的复杂性上扩展，因此即使缺乏重命名逻辑，所提出的技术仍可用于有效降低每个核心的寄存器文件峰值温度，从而提高整个系统的可靠性。

### 实现
所提出的确定性寄存器调整技术的实现包括两部分：一部分是编译过程，将规则性嵌入到静态寄存器名称中；另一部分是硬件实现，动态确定每次迭代中寄存器的名称。

#### 静态寄存器名称调整
算法1概述了调整逻辑寄存器名称的伪代码。该过程仅依赖于关于每个基本块执行计数的分析信息，并基于此开发了一组功能来完成静态寄存器名称调整。具体来说，每个频繁执行的循环经过以下五个步骤进行转换：

- 划分可移动和不可移动寄存器（第3-7行）；
- 释放未访问但存活的寄存器（第8行）；
- 确定调整函数（第9行）；
- 依次调整目标和源寄存器的名称（第10-13行）；
- 在循环入口初始化活入变量，在循环出口恢复活出变量（第14行）。

由于寄存器调整技术的目标是通过迭代地将热点逻辑寄存器映射到不同的物理寄存器来防止局部热积聚，因此如果检测到频繁访问的寄存器是不可移动的（第5行），算法会插入额外的移动指令进行调整（第6行）。这些移动指令，加上释放未访问但存活寄存器的存储和加载指令（第8行）以及初始化活入变量和恢复活出变量的移动指令（第14行），构成了所提出技术的开销。由于大部分额外指令都在循环体外执行，因此执行时间开销可以忽略不计。通过在转换后的代码上执行额外的寄存器合并步骤（第16行），可以进一步减少这种开销，从而消除冗余的移动指令。

#### 动态寄存器名称调整
使用算法1中概述的代码转换支持，只要硬件在进入频繁执行的循环之前由编译器告知调整向量`v`，就可以在执行过程中完成确定性的寄存器调整过程。使用表I中的GF(2^3)乘法作为调整函数，其中向量`v`为`[1, 0, 0]`，可以使用图6所示的电路将逻辑寄存器名称转换为物理寄存器名称。