# cybrics2021逆向walker
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## ida分析
###  1.初次分析
看到有一个start_check函数，跟进分析
看到有一个global_flag数组，不过可以发现是个假flag。
###  2.再分析
再函数栏里有一些名字比较可疑的函数
看到这里可以确定这里才是真正的验证入口
## gdb调试
在这里对每个函数的单独分析的时候可能会有点不完整，在写的时候我想尽可能保留本人当时做题时分析的思路和理由，而不是以一个上帝视角去分析。
###  check_substr函数
这个函数名看着就很可疑，就先那它开刀了
第一时间看到这个(v5^a1[a2+i]!=v7[i])再结合函数名，十有八九是验证逻辑了。  
有2个比较用到的数组一个是map[]，一个是strings[]
这里一开始的时候也不知道要输入什么，就输入cybrics{aaaa试一下。现在看回来这个尝试的输入，成为了破局的关键。  
断点下在比较逻辑之前，这样可以在调试的时候看到v5,a1[a2+i],v7[]的值。
可以知道a1[]就是’c’之后的字符串了，v5的值可以通过异或后再异或来倒推，这里求出v5为0x61，刚好为map[]的第一个值，而v7[]为字符串数组的第二个值。  
然后继续运行程序，程序就结束了，证实了确实是验证逻辑。并且有个T5Excrption的函数，猜测这个函数跟退出有关，并且上面也有一个T5Excrption的函数。
利用py求出正确的字符串”REUaG”，再次输入。几次运行后发现比较完后需要继续输入。
输入”caaaa”测试
发现v5的值还是0x61，但是v7[]的字符串变成了字符串数组的第三个值。
可以得到以下猜测：  
1.v5=map[10 * x_pos + y_pos]中的x和y是可以通过某些操作改变的。  
2.而MOVES的值在每次进入这个函数的时候会加一。  
3.T5Excrption的函数跟程序退出有关。  
4.利用ida的函数关联功能，发现函数是从make_move函数调用的。
###  process_move函数
首先有4个对应关系：  
u:T6Exception(x_pos-1,y_pos)  
r:T6Exception(x_pos,y_pos+1)  
d:T6Exception(x_pos+1,y_pos)  
l:T6Exception(x_pos,y_pos-1)
看到这3个if的判断，立刻有感觉了。当时认为是一个10×10的迷宫，并且题目名walker。  
再结合check_cubstr函数中对map[]的判断，得出以下迷宫。
把map[x_pos * 10 + y_pos]&1==1的值都标出来。
然后在根据那4个对应关系，u代表up(想上移动一格)，d代表down(向下移动一格)，l代表left(向左移动一格)，r代表right(向右移动一格)。
但是这个迷宫也没有什么规律可言，于是就进入了苦逼的人工爆破时间，顺便找规律。
最终得到以下路径：dddrruurrrrddddllllddrrrrrddlllllll。(还好在每一个点只有唯一选择，不然也没耐心爆下去了，并且最后map[]移动到0x66的时候输入什么会退出程序，又把思路断了)
利用ida的函数关联功能，发现函数也是从make_move函数调用的。
###  make_move函数
反汇编码给的信息有点少，所以打算通过gdb和汇编码来分析函数的功能。  
不过看到++MOVES;更加肯定进入check_substr函数要经过make_move函数。并且有个jmp rax的汇编，猜测应该是实现了一个选择器功能。
选择在check_substr函数和process_move函数的入口下断点，并进行调试。
发现程序断在了check_substr函数入口。  
继续运行
程序断在了process_move函数入口。  
这时候可以肯定make_move函数根据输入的字符来跳转到不同的函数。
分析jmp rax附近的汇编
发现一个类似偏移的表，由1个0xffffe7f7,4个0xffffe7b7,若干个0xffffe861,1个0xffffe82f构成。
调试分析表的作用
可以看到表的取值是根据输入字符减去0x63后的值决定的，这里输入字符c，返回的值是表的第一个值。  
那可以通过调试分析得到以下对应关系  
0xffffe7f7：check_substr  
0xffff7b7：process_move  
0xffff861：什么都不做，需要继续输入(但是每输入一次MOVES都会自加一)  
0xffff82f：不清楚什么功能，但是程序会退出
在看汇编的时候发现在make_move函数有一个这种东西。
提示输入即为flag的内容。
## 综合分析
###  迷宫路径和check函数
把路径和符合check函数的map[]值结合
得到其中红色字为二者重合的地方，猜测flag的逻辑为当移动到map的值为0x61,0x45,0x49,0x71时执行check_substr函数和路径的结合
到这里为止还有一个当输入为字符f的时候的功能还没有弄明白，试一下。
成功get flag。
## 感想
当时做出来这道题的时候，可以说是激动到不行。学了这么久，有一种守得云开见月明的感觉，感觉自己一直以来的努力终于有了结果。可能这种通过一步一步调试分析程序，对程序的感觉从一开始什么都不知道的黑盒，到最后清楚明白程序怎么运行的白盒，才是逆向这个方面吸引我的魅力