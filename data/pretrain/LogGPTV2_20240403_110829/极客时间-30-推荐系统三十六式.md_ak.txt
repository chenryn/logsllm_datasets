## Simhash {#09.html#simhash}内容重复检测，是搜索引擎公司最先遇到的，所以 Google 在 07年公开了他们内部的内容重复检测算法，这个算法简单有效，甚至造福了今天的信息流推荐产品。对于很长的内容，如果只是检测绝对重复，也就是说完全一模一样的那种情况，那么使用MD5这样的信息指纹方法非常高效，无需再去分词、提取关键词和计算关键词向量之间的距离。我们直接将原始的内容映射为一个短字符串，这个短字符串就是原始内容的指纹，虽然不是绝对保证和原始内容一一映射，但是不同内容能得到相同指纹的概率非常小。只是这种信息指纹的方法有个非常明显的坏处就是，哪怕原始内容改一个字，得到的信息指纹就会截然不同。这就没法愉快地玩耍了，你一定希望的是只要主要内容不变，就算一些不太重要的词句不同，也仍然可以得到相近甚至相同的指纹。这才能更加灵活地进行内容重复检测。是否有这样的算法？有，就是Simhash。Simhash核心思想也是为每个内容生成一个整数表示的指纹，然后用这个指纹去做重复或者相似的检测。下面这个示意图说明了Simhash 如何把一个原始内容表示成一个整数指纹。![](Images/ebb543beb5bfea6eb512f8624f56e1f4.png){savepage-src="https://static001.geekbang.org/resource/image/de/4e/de7491eede4275a68a5ab8af17d6294e.png"}好，现在详细说明一下这个过程。1.  首先，对原始内容分词，并且计算每个词的权重；2.  对每个词哈希成一个整数，并且把这个整数对应的二进制序列中的 0 变成    -1，1 还是 1，得到一个 1 和 -1 组成的向量；3.  把每个词哈希后的向量乘以词的权重，得到一个新的加权向量；4.  把每个词的加权向量相加，得到一个最终向量，这个向量中每个元素有正有负；5.  把最终这个向量中元素为正的替换成 1，为负的替换成    0，这个向量变成一个二进制位序列，也就是最终变成了一个整数。最终这个整数就代表了原始的内容。这个 Simhash 奇妙在哪呢？看这个示意图中，我故意加了一个不太重要的词"了"，它的权重是1，对应的加权向量元素不是 1 就是-1，在上述的第四步中，如果这个词对应的向量缺少了，其实根本不影响最终得到那个整数，因为它很难改变最终向量元素的正负。这就是为什么那些不太重要的词不影响内容之间的重复检测。Simhash为每一个内容生成一个整数指纹，其中的关键是把每个词哈希成一个整数，这一步常常采用Jenkins 算法。这里简单示意的整数只有 8 个二进制位，实际上可能需要 64个二进制位的整数，甚至范围更大。得到每个内容的 Simhash指纹后，可以两两计算汉明距离，比较二进制位不同个数，其实就是计算两个指纹的异或，异或结果中如果包含3 个以下的 1，则认为两条内容重复。为了高效，也可以直接认为指纹相同才重复，视情况而定。
## Bloomfilter {#09.html#bloomfilter}除了内容重复检测，还有一个需求是防止已经推荐的内容被重复推荐。这个刚需和上述内容重复相比，最大的不同就是过滤对象不同，上述Simhash 过滤对象是内容本身，而这里则一般是内容的 ID。内容的 ID 一般是用一个 UUID 表示，是一个不太长的字符串或者整数。对于这类形如模式串的去重，显然可以用单独专门的数据库来保存，为了高效，甚至可以为它建上索引。但对于用户量巨大的情况下，这个做法对存储的消耗则不可小看。实际上，解决这类看一个字符串在不在一个集合中的问题，有一个有点老但很好用的做法，就是Bloomfilter，有时候也被称为布隆过滤器。布隆过滤器的原理也要用到哈希函数。它包含两部分：一个很长的二进制位向量，和一系列哈希函数。Bloomfilter是一个很巧妙的设计，它先把原始要查询的集合映射到一个长度为 m的二进制位向量上去，它映射的方法是：1.  设计 n 个互相独立的哈希函数，准备一个长度为 m    的二进制向量，最开始全是 0；2.  每个哈希函数把集合内的元素映射为一个不超过 m 的正整数 k，m    就是二进制向量的长度；3.  把这个二进制向量中的第 k 个位置设置为    1；也就是一个元素会在二进制向量中对应 n 个位置为 1。我放了一个示意图。![](Images/817358938957a2872f5ecdf86ad3bd98.png){savepage-src="https://static001.geekbang.org/resource/image/ef/4f/ef000d86f72ca2341f95d8bc74ab854f.png"}这个示意图中，原始的模式串经过三个互相独立的哈希函数，映射到 8位二进制向量中的三个位置了。原始的模式串集合经过这样的处理后，就得到一个很大的二进制向量。在应用阶段时，假如来了一个模式串s，需要查询是否在这个集合中，也需要经过同样的上述步骤。每个哈希函数对这个模式串 s哈希后都得到一个整数，看看这个整数在二进制向量中所指示的位置是不是1，如果每个哈希函数所指示的位置都是 1，就说明模式串 s 已经在集合中了。需要说明的是，Bloomfilter也并不是百分之百保证的，有很小的概率把原本不存在集合中的模式串判断为存在。这样就会造成那些明明还没有推荐给用户的内容ID 就再也不会推荐给用户了，当然，这个小概率是可以承受的。
## 总结 {#09.html#-}好了，今天介绍了两种去重算法。在推荐系统中，虽然我们十分关心推荐匹配的效果，但是别忘了，对原始内容的挖掘和清洗往往更加重要。这其中就包括对重复内容的检测。两种去重策略都是牺牲一点误伤的概率换得大幅度的效率提升，具体的做法都是要借助哈希函数。只是哈希函数的结果在两个算法中有不同的处理手段，Simhash是加权，Bloomfilter 则是用来做寻址。最后，留给你一个思考题，由于今天的内容比较简单，留给你思考题也简单，请你想一想，如果要从Bloomfilter 中去掉一个元素，该怎么做？欢迎给我留言，我们一起讨论。感谢你的收听，我们下次再见。![](Images/ea1ba4af4ca076827688b4d742ebc395.png){savepage-src="https://static001.geekbang.org/resource/image/76/02/76de8928fe8206b0467b8c773d6ced02.jpg"}
# 【其他应用算法】构建一个科学的排行榜体系前面的专栏文章中，我从最常见的内容推荐开始讲起，直到讲到了最复杂的深度学习在推荐系统中的应用原理，这些推荐算法都有一个特点：智能。所谓智能，就是带有学习性质，能够和复杂的用户端形成互动，在互动过程中，算法参数得到更新和进化。但是，智能这个高大上的词语，一定要以数据为前提的，我在专栏的第二篇文章中就和你透露过，推荐系统中有一个顽疾就是冷启动，冷启动就是没有数据，没有数据怎么和用户玩呢？一个新用户来了，什么数据都还没有，推荐系统对其一无所知。这时候，你就需要一个排行榜了。
## 为什么要排行榜排行榜，又名热门榜，听上去似乎是一个很常见的东西，原来它也算是推荐算法的一员？是的，它不但是，并且非常重要，而且其中也有不少的学问。那么说排行榜到底有哪些用处呢？1.  排行榜可以作为解决新用户冷启动问题的推荐策略。这个不难理解，当一个新用户刚注册时，可以把最近产品中热门的物品推荐给他。2.  排行榜可以作为老用户的兴趣发现方式。即使是老用户，也可以在享受个性化推荐的同时去浏览热门的物品，从中看看哪些感兴趣，哪些不感兴趣，这些行为都是补充或者更新用户兴趣的数据来源。3.  排行榜本身就是一个降级的推荐系统。推荐系统本身是一个软件，因此也会有出现问题的时候，也会有推荐不出来的时候，这个时候考虑到服务的可用性，用排行榜作为一种兜底策略，可以避免推荐位开天窗。今天，我就和你聊聊如何根据自己的产品特点构建一个合理的排行榜。