proﬁle information and services (e.g., authentication, policy
service). However, the usability of the OpenID identiﬁer
scheme could be improved as Web users perceive a URI
as a “web address” instead of a personal identiﬁer. In the
context of Web content sharing, users rarely know the URIs
of those with whom they want to share their content with,
but they tend to know each other’s e-mail addresses.
Users are often prompted to use an email address as their
user ID [14]. For instance, major service providers (e.g.,
Google, Yahoo, AOL) use email addresses as user accounts
to associate provided services. Our solution OpenIDemail
enables Web users to use their email to login CSPs while
transparently using OpenID identiﬁer
identiﬁcation.
Thus, the user experience for registering and entering CSPs
that support OpenIDemail would be the same as they expe-
rience today.
for
C. Distributed Authorization and Background of RT
In decentralized environments such as the Web, the con-
tent owner and the requestor often are unknown to each
other (e.g., Alice does not know Mary and Jenny). There
is a substantial body of literature addressing the problem of
authorization within distributed environments.
PolicyMaker [15] coined the term “trust management”
to denote an access control model in which authorization
decisions are based on locally stored security policies and
distributed credentials (signed statements), without explicit
authentication of a requestor’s identity and a centralized
repository of access rules. Policies and credentials in Policy-
Maker consist of programs written in a general programming
language such as AWK. Although general, it is very hard
to understand the overall access policy for a protected
resource. KeyNote [2], the next version of PolicyMaker,
uses a C-like notation and regular expression syntax for
describing conditions. SPKI/SDSI [3] is a digital certiﬁcate
scheme for authorization, which provides methods for bind-
ing authorization privileges to keys and for localized name
spaces and linked local names. A credential in KeyNote
and SPKI/SDSI delegates certain permissions from an issuer
to a subject. A chain of credentials can be viewed as a
capability which authorizes the subject at the end of the
chain. KeyNote and SPKI/SDSI do not support attribute
inferencing and attribute-based delegation. RT [4] is a family
of languages that add the notion of RBAC to the concept of
trust management systems such as KeyNote and SPKI/SDSI.
In our approach, RT [4] is employed for expressing
access-control policies. The RT language is a family of role-
based trust-management languages for representing policies
411
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:09:09 UTC from IEEE Xplore.  Restrictions apply. 
and credentials in distributed environments. RT combines
the strength of role-based access control (RBAC) [16] and
trust-management (TM) [15] systems to form a concise and
expressive language.
All policy statements and credentials in RT take the form
A.r ←− exp, where A is an entity, r is a role, and exp is
a role expression (a sequence of entities and roles). In this
paper, we capitalize the ﬁrst character of entities and use
lower-case to represent roles. An entity in RT is a uniquely
identiﬁed individual or process that can issue credentials
and make requests, and a role is a set of entities who are
members of this role. The above credential A.r ←− exp
means that members(A.r) ⊇ members(exp) (i.e., exp is a
member of A.r).
There are four types of credentials in RT , each corre-
sponding to a different way of deﬁning role membership
and a different level of delegation:
• Type 1 A.r ←− B : An A deﬁnes an entity B to
be the member of role r. For example, CCA certiﬁes
Alice as its Girl Scout member (CCA.scout ←−
Alice), or Jenny asserts that Mary is her parent
(Jenny.parent ←− M ary).
• Type 2 A.r ←− B.r1 : The role A.r is deﬁned to
contain every entity that is a member of B.r1 role. This
statement can be used to represent a simple delegation
from A to B, since B may affect the members of
A.r by issuing new credentials. For instance, Alice
deﬁnes all Girl Scouts in CCA as her scout friends
Alice.scout ←− CCA.scout. The members of the
Alice.scout role will dynamically change as CCA re-
vokes or issues new credentials for its Scout members.
• Type 3 A.r ←− A.r1.r2 : The role A.r is deﬁned to
contain B.r2 for every B that is a member of A.r1.
This represents a delegation from A to the members of
A.r1. For example, Alice trusts CCA to deﬁne its scout
members (Alice.scout ←− CCA.scout), and then
delegates the authority over “parent” to those member
scouts (Alice.scout parent ←− Alice.scout.parent).
• Type 4 A.r ←− B1.r1 ∩ ··· ∩ Bk.rk : A.r is
deﬁned to contain the intersection of all
the roles
B1.r1,··· , Bk.rk. This represents partial delegation
from A to B1 ··· Bk. For instance, Alice may share
certain content with her close friends who are class-
mates Lake-Side Elementary School (LSES), and are
from the same scout troop (Alice.close f riend ←−
CCA.scout ∩ LSES.class 2006).
D. Related Work
Microsoft Live Mesh [17] aims to provide a centralized
Web location for a user to store personal content that can
be accessed and synchronized across multiple devices (e.g.,
computers and mobile phones). The user is able to access
the uploaded content through a Web-based Live Desktop
or her own devices with Live Mesh software installed.
Dropbox [18] offers a similar personal content sharing
solution. When a user joins a shared folder,
the folder
appears inside their Live Desktop (or Dropbox), and syncs
to their computers and devices automatically. Both solutions
are easy to use, however, they accept only users within their
own administrative domain and the sharing is explicit for
each individual user (i.e., no grouping or delegation).
YouServ [19] enables users to share their content using
their personal computers by leveraging technologies in per-
sonal Web servers, dynamic DNS, proxies, and replications.
A user’s YouServ content remains available and accessible
even if they are using a dynamically-assigned IP address,
or when the user’s PC is ofﬂine (through a peer replicated
site) or ﬁrewalled (through a proxy site). All YouServ-hosted
content is publicly accessible unless it is contained within
private folders. To control access, YouServ provides a single-
sign-on authentication service for the YouServ community,
and content owners whitelist other users in a ﬁle named
access.txt to grant accesses. ScoopFS [20] is another per-
sonal Web server-based content sharing solution. The user-
interface provided by ScoopFS resembles an email client,
and each user has an unique mailbox identiﬁed by a Web-
Key [21] (similar to a secret-link). ScoopFS is designed for
ease of use. The main limitation of ScoopFS is that content
recipients need to install a copy of ScoopFS and manually
exchange their Web-Keys in order to receive the shared
content. Mannan et al. [7] proposed a scheme for personal
web content sharing by leveraging the existing “circle of
trust” in Instant Messaging (IM) networks. This scheme
enables an owner’s personal data to be accessible only to
her IM contacts. However, both content owner and requester
must be on the same IM network and the proposed system
does not support trust and delegation.
Relationships between a content user and a content owner
are intuitive to Web users and are commonly used to
derive authorization decisions by CSPs. Carminati et al. [22]
proposed an access control mechanism for web-based social
networks, where policies are expressed as constraints on the
type, depth, and trust level of existing social relationships.
The proposed system requires a special software module
running on an end-user’s machine in order to derive access
decisions, and delegation is supported in a limited way (only
through the same relationships along relationship paths).
Lockr [23] is another access control mechanism based on
social relationships. The main limitation of Lockr is the
expressive power of access policies as it simply uses value
matching to derive access decisions. Thus, it cannot express
delegation of relationship authority (i.e., friend’s friend), and
cannot denote authorized users using shared attributes (e.g.,
friends from a university). In addition, credentials have to
be manually sent from issuer to recipient; to get access,
users have to manually ﬁnd/search appropriate credentials
to construct the proof.
412
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:09:09 UTC from IEEE Xplore.  Restrictions apply. 
Figure 1. The system architecture of the proposed Web 2.0 content sharing solution. OpenIDemail provider enables Web users to use their email to login
CSPs while remain using OpenID URI for identiﬁcation. OpenPolicy provider offers services for internet users to organize their credentials and polices,
and for CSPs to make authorization decisions. Users are free from choosing their OpenIDemail and OpenPolicy providers.
III. APPROACH
Figure 1 illustrates the system architecture of our pro-
posed solution and data ﬂows among main actors in the
system. Its design is framed and guided by our previously
proposed Web 2.0 content sharing model [24]. In this model,
a user is not only a content owner and consumer, but a
credential issuer as well. A user enrolls a set of identities
(e.g., user name/password) from multiple identity providers
to represent themselves when accessing shared content and
constructing access polices. A content owner creates per-
sonal content on CSPs and associates that content with
access-control polices that are hosted by a policy provider.
To access shared content, a content consumer chooses an
appropriate identity to make a request. Each request contains
the identity provided by the consumer and a corresponding
set of context information. Context information is the meta-
data of a request, such as user-speciﬁc proﬁle attributes,
current location, date/time of the request, and user creden-
tials. A credential is an assertion of certiﬁed user-attribute
from another individual user or an organization authority.
To mediate accesses, a CSP requests authorization decisions
from a policy provider to protect shared content. The policy
provider then acts as a policy decision point (PDP), which
responds with authorization decisions based on the context
of the request and a set of pre-deﬁned credentials and access
policies.
A. System Architecture and Data Flows
As shown in Figure 1, our proposed solution contains
two additional players—an OpenPolicy provider and an
OpenIDemail provider, in addition to the existing actors
(Owner, User, CSP) from the secret-link sharing scenario.
An OpenPolicy provider provides policy-hosting services
for Internet users to organize their credentials and polices,
and a set of web services for CSPs to make authorization
decisions. An OpenIDemail provider is an existing email
provider that is augmented with both an OpenID identity
413
to URL Translation (EAUT) [25]
service and an Email
service. By combining these two services, our approach
allows Web users to use their email to login to CSPs while
using OpenID identiﬁer for identiﬁcation. Both OpenPolicy
and OpenIDemail are user-centric, users are free to choose
their favorite providers. The following steps illustrate the
sequence for a user to login to a CSP using the OpenIDemail
protocol:
1) User U presents her email e to CSP C.
2) C parses the domain d from e (as an email is in the form
of user@domain) and prepends the string “http://” to
d to form an EAUT Discovery Endpoint URL u.
3) C retrieves an XRDS-Simple document [26] on u,
and lookups values representing an EAUT Template or
Mapping Service Endpoint URL m.
4) C translates or maps e to an OpenID identiﬁer i via m.
5) Once C gets back the corresponding OpenID identiﬁer
i, the rest of the steps are the same as the original
OpenID protocol.
Assume a content owner has logged into her OpenPolicy
provider using OpenIDemail protocol and has organized a
set of credentials and access polices. To share content, the
content owner clicks on the link of the content on a CSP.
The CSP generates a secret-link based on the content and
redirects the content owner to her OpenPolicy provider to
specify a set of roles as the recipient of the shared content.
The OpenPolicy provider then sends out the link to each
member of the designated roles and calls back the CSP with
the designated roles to construct an access-control list of the
shared content. Figure 2 illustrates the sequence of steps for
sharing content as explained below:
1) Content owner W speciﬁes that content c residing on
CSP C should be shared.
2) C generates a secret-link l based on content c.
3) C redirects W to her OpenPolicy provider P with
secret-link l and a post-back URL b as part of payload.
4) P presents a role-selection user interface to W.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:09:09 UTC from IEEE Xplore.  Restrictions apply. 
Figure 2. Flow for sharing content, assuming Owner W has logged into
her OpenPolicy provider P.
5) W speciﬁes a set of
roles R as the recipients
of c. For instance, Alice speciﬁes Alice.scout and
Alice.scout.parent as the roles for recipients.
6) For each role r ∈ R, P sends out l to a set of destination
email addresses E = { e | e ∈ members(r)} (e.g.,
the members of the Alice.scout role) by performing a
distributed mailing with other OpenPolicy providers.
The details of the distributed mailing protocol are
discussed in Section III-B.
7) Once the distributed mailing is completed, P calls b on
C with R and l in the payload.
8) C ﬁnds content c based on l and then stores the tuple
(l, c, R) to serve as an access-control list of c.
We now provide the data ﬂow for accessing shared
content. A user requests access by presenting a secret-
link to a CSP. The CSP prompts the user for an email
account and redirects the user to her OpenIDemail provider
for authentication. Once authenticated,
the OpenIDemail
provider redirects the user back to the CSP with a claimed
OpenID identiﬁer and a token that the CSP can verify. After
the claimed OpenID identiﬁer is veriﬁed, the CSP retrieves
the roles associated with the shared content and requests an
access decision from the owner’s OpenPolicy provider. For
each authorization request, the CSP provides the OpenPolicy
provider with the user’s OpenID identiﬁer and the associated
role to determine whether the request should be permitted.
Figure 3 illustrates the ﬂows for accessing shared content as
explained below:
Figure 3. Flow for accessing a shared content.
1) To access a shared resource, user U presents l to CSP