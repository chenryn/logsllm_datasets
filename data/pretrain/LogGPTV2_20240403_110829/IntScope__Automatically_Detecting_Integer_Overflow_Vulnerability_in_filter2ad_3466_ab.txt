PANDA, whose grammar is shown in Figure 2. We convert
x86 assembly into our PANDA representation based on our
previous work [51, 52].
=
:
e
var
val
var
|
τ
:: [ ] |
va
l
rr = function e e
1
Δ
vval e
( ,
e
|
=
e
|
 if
(
Δ
e
e
b
)
tthen  
l
1
 else  
l
2
|
,...) |
 return
statement
=
::
var
                           goto 
e
 num| 
τ
b
op
| 
 qword|dword|word|byte
=
::
=
::
= == =  ≥  ≥
::
=
::
Δ
Δ
val var functioon ::=  string (value,variable and function’s name)
 +   , *, /, &, |, 
, >
,
⊕
, -
,!
op
,
s
,
s
,
s
,
u
,
u
,
u
,
,
,
s
u
Figure 2. PANDA grammar.
There are six basic statements in PANDA: (1) deﬁnition
statement: var:: τ[e] is used to deﬁne a variable, where var
is the name of a variable, τ is var’s bit length (e.g., qword,
dword, word, byte) and eis var’s memory address; (2) refer-
encestatement: val(cid:2) var, similar to the Phi node in standard
SSA form [28], it generates a new variable valwhen varhas
an unknown value or multiple possible values; (3) assign-
ment statement: var = e assigns variable var with value e;
(4) branch statement: if(eΔbe) then l1 else l2, where
Δb stands for comparison operators; (5) call statement, var
=function(e1,...) and (6) returnstatement, which means func-
tion exit.
In PANDA, we differentiate signed comparisons from
unsigned comparisons.
For example, JG is a condi-
tion jump instruction for signed comparisons, whereas
JA is for unsigned comparisons; instructions cmp eax,
1; JG label are translated into if(eax >s 1) then
label in PANDA, whereas instructions cmp eax, 1;
JA label are translated into if(eax >u 1) then
label, where >s and >u stand for signed greater and un-
signed greater, respectively.
We model the semantics of the original x86 instructions,
and translate x86 assembly into our PANDA representation.
We build variable-like entities in binary code according to
memory access expressions. There are two kinds of variables
in PANDA: mem type and val type. A mem type variable,
corresponding to a register or a memory location, could be
assigned multiple times and only used as an l-value. A val
type variable can only be used as an r-value and stands for
the value in a memory location. A reference statement, a
special statement in PANDA, will generate a valtype variable
when the program uses a mem type variable which has an
unknown value or multiple possible values. Although a mem
type variable could be assigned multiple times, each use of a
memtype variable will be replaced by a speciﬁc value which
is the latest assignment.
3.2.2 Component Extractor and Proﬁle Constructor
To reduce path explosion, IntScope only analyzes certain
parts of the program that may be relevant to integer over-
ﬂow vulnerabilities. Based on the observation that most in-
teger overﬂow vulnerabilities are caused by the misuse of
tainted data in sinks without proper checks, IntScope only
scans those program paths which pass through source func-
tions (e.g., read, recv, fread) and reach a sink function
(e.g., malloc, alloca, LocalAlloc).
The Component Extractor is responsible for selecting
those candidate functions that may invoke both source func-
tions and sink functions directly or indirectly. The call graph
C is a directed graph C=(N,E) that represents calling re-
lationships between functions in a program. Each node ni 
Nrepresents a function and each edge (ni, n j)  Eindicates
that function ni calls function n j. Since each function corre-
sponds to a node in C, the Component Extractor selects the
common ancestors of a taint source function node and a sink
function node in Cas candidates. For example, the Compo-
nent Extractor would operate on the call graph in Figure 3
by selecting function read_and_malloc as a candidate
since it may invoke both source function fread and sink
function malloc indirectly.
read_and_malloc
fopen
alloc_page
read_file
malloc
fread
Figure 3. A simple call graph.
Given the candidate functions, the Proﬁle Constructor is
used to compute the “chop” graphs G’. A control ﬂow graph
is a directed graph G=(N,E)where ni  Nrepresents a state-
ment iand (ni, n j)  Erepresents a possible transfer of control
ﬂow from statement ni to n j. For the control ﬂow graph of
each candidate function, there is a unique entry point called
nentry and exit point called nexit. Let S r be the set of nodes
that invoke a source function, and let S k be the set of nodes
that invoke a sink function. The Proﬁle Constructor com-
putes the nodes in G’ by (a) computing the set Esr, which
includes all nodes on the paths from nentry to a node in S r;
(b) computing the set Esk, which includes all nodes on the
paths from nentry to a node in S k; (c) computing the set S e,
which includes all nodes on the paths from a node in S r to
nexit; (d) if (S e
Esk) (cid:3) φ, the set of nodes in G’ is: Esr
(cid:3)
Esk). Figure 4 shows the intuition graphically.
There are three simple control ﬂow graphs in Figure 4, and
read_and_malloc is the candidate function. The Proﬁle
Constructor produces the chop graphs which only include the
shaded nodes.
(S e
(cid:2)
(cid:2)
CFG of read_and_malloc
CFG of read_file
...
...
...
call read_file
...
call fread
...
...
...
call alloc_page
...
CFG of alloc_page
...
...
call malloc
...
Figure 4. A graphical depiction of the chop
graphs.
3.2.3 Modeling Memory
Because IntScope simulates program execution, it needs to
build a symbolic memory space to maintain a large number
of symbolic memory addresses and symbolic values. Ac-
cording to the design of PANDA, our virtual memory has
three mapping relationships (shown in Figure 5):
M: a mapping from symbolic addresses to variable names.
ST: a mapping from variable names to symbolic values
and other information, such as bit length (e.g., qword, dword,
word, byte), and type (e.g., a memtype variable or a valtype
variable). For a memtype variable, its name also maps to its
Figure 5. Memory mapping relationships.
symbolic address.
VT: a mapping from symbolic values to value properties
(e.g., whether the value is tainted).
In our memory model, the taint property is bounded with a
value, i.e., whether or not a variable is tainted depends on its
current value. When multiple variables have the same tainted
value, all the variables are trusted once a variable among
them is completely checked. We take a source code exam-
ple to illustrate it:
L1 x=y=read_from_net(); //x and y are tainted
L2 if(x==c)
L3
//x is sanitized
//y is sanitized
p = malloc(y);
Variable x and y share the same tainted value because of
the assignment statement at L1. In our memory model, the
use of y at L3 is safe because x has been sanitized at L2.
3.2.4 Execution Strategies
Given the chop graphs G’, IntScope tries to explore each
feasible path from the entry point. IntScope maintains the
symbolic memory space and updates the symbolic memory
according to the semantics of PANDA statements. In partic-
ular,
• At each branch point, IntScope will fork an additional
execution. Along with the original “process”, the two
branch “processes” will check the feasibility of their
current path. If the path is feasible, they will constrain
themselves to their current path and continue to simu-
late the program execution.
• At each indirect jump statement such as goto eax,
IntScope will evaluate the current value of eax. If the
value is an address label, IntScope continues to simulate
the code from that address; otherwise, if the value in
eax is a symbolic value, IntScope cannot determine the
target address and will terminate.
• At each call statement, if the target function is an inter-
nal function of the program, IntScope performs an inter-
procedural analysis. IntScope simulates a function call
stack. Before entering a function, IntScope pushes the
return address on the stack, and then simulates the target
function; after exiting from the target function, IntScope
reloads the return address from the stack and continues
simulating.
With regards to the functions that are related to the prop-
agation of taint data, IntScope will directly apply function
summaries. For example, IntScope will mark the parameter
buffer in functions read, fread, recv and recvfrom
with a taint tag.
LOOPS. It is hard to model the number of loop execu-
tions in static analysis. In our approach, for a loop with a
symbolic variable as a bound, IntScope traverses all branches
in the loop only once; for a loop with a constant bound,
IntScope tries to simulate the loop as accurately as possi-
ble, rather than simulate a ﬁxed number of times. When a
path re-enters the loop, IntScope checks whether the value of
the loop variable is closer to the loop bound. If so, IntScope
continues to simulate the path. For example, consider the
instruction sequence shown below which is actually an id-
iomatic expression generated by Visual Studio C compiler.
lea
mov
mov
rep
edi, [ebp+var_DC]
ecx, 37h
eax, 0h
stosd
The preﬁx rep causes the instruction stosd to be repeated
until ecx is decremented to 0. The idiomatic expression is
used to initialize a large block of memory. In this case, the
loop bound is a constant (37h), and IntScope will repeat the
loop 37h times.
Block Memory Operation. Block memory operations
(e.g., strncpy, memcpy, memmove) bring us a challenge
if the parameter size in these functions is a symbolic value.
For example,
the function memcpy(dst, src, n)
copies n bytes from memory area src to memory area dst.
If n is a symbolic value, we are not sure how many bytes are
copied. Subsequent memory accesses taking dst as a base
address will be undecided. It is too expensive for static anal-
ysis to accurately simulate such functions. As such, IntScope
only cares about the taint property propagation, but ignores
the value propagation between dst and src. If src is a
tainted buffer, IntScope will treat dst as a tained buffer as
well, and all data from dst will be assigned a new tainted
value.
3.2.5 Lazy Checking
The lack of type information and benign overﬂow operations
in binary code signiﬁcantly affect integer overﬂow detection.
For example, a 32-bit memory location can be used as ei-
ther an int type value or an unsigned int type value,
and hence 0xffffffff+1 could be interpreted as -1+1
or 4294967295+1. Moreover, since benign overﬂow op-
erations are prevalent in binaries, we cannot simply treat all
overﬂow operations as vulnerabilities.
Whether or not an integer overﬂow is harmful depends
on where and how the program uses the overﬂowed value.
As a result, we do not check whether each arithmetic op-
eration could overﬂow, but track how the program uses un-
trusted data; when a tainted value is used in sinks, we check
whether it overﬂows or not. In addition, as described in Sec-
tion 2, most sinks have already provided some hints on the
type inference.
• For most memory allocation functions, since the type of
parameter size is unsigned int, the value used as
parameter size should not be greater than 232 − 1 (for
32-bit architectures).
• A symbolic value used as an array index should not be
negative, i.e., if an expression of form x-y is used as an
array index, IntScope will check whether the formula
x-y>=0 is valid under current path constraints; if not,
IntScope generates an alarm.
• As an overﬂowed value used in a predicate may lead to
a bypass of security checks or result in an unexpected
execution, we should pay attention to the tainted value
in predicates. In particular, at each branch point, if there
is a tainted value used in the predicate, IntScope will
query whether or not the tainted value could overﬂow
under current path constraints.
We can get some type information from x86 conditional
jump instructions, e.g., JG, JNLE, JGE, JNL, JNGE, JLE,
JNG, JE and JNE are jump instructions for signed compar-
isons; JA, JNBE, JAE, JNB, JB, JNAE, JBE, JNA, JE and
JNE are jump instructions for unsigned comparisons. We
have preserved this information in PANDA. For example, >s
and >u stand for signed greater and unsigned greater, respec-
tively.
If tainted symbolic expressions of the form x+y or x*y
appeared in unsigned comparisons, IntScope will check
whether the expressions are greater than 232 − 1. Similarly,
symbolic expressions of the form x-y that appear in an un-
signed comparison should be greater than 0.
For tainted symbolic expressions of the form x+y that ap-
pear in signed comparisons, IntScope performs a check sim-
ilar to __addvsi3 (shown in Figure 6), a function in GCC
run-time library to catch signed addition overﬂow errors. If
a term (x or y) in x+y is positive/negative, we will check
whether the sum is greater/less than the other term (x or y).
const SItype w = a + b;
96 __addvsi3 (SItype a, SItype b){
97
98
100 if (b >= 0 ? w  a)
101