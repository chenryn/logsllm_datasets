### References

1. M. Rinard, C. Cadar, D. Dumitran, D. Roy, T. Leu, and J. W. Beebee. Enhancing Server Availability and Security Through Failure-Oblivious Computing. In Proceedings of the 6th Symposium on Operating Systems Design and Implementation (OSDI), December 2004.

2. S. Sidiroglou, J. Ioannidis, A. D. Keromytis, and S. J. Stolfo. An Email Worm Vaccine Architecture. In Proceedings of the 1st Information Security Practice and Experience Conference (ISPEC), April 2005.

3. S. Sidiroglou and A. D. Keromytis. A Network Worm Vaccine Architecture. In Proceedings of the IEEE International Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises (WETICE), Workshop on Enterprise Security, pages 220–225, June 2003.

4. S. Sidiroglou, M. E. Locasto, S. W. Boyd, and A. D. Keromytis. Building a Reactive Immune System for Software Services. In Proceedings of the USENIX Annual Technical Conference, pages 149–161, April 2005.

5. S. Singh, C. Estan, G. Varghese, and S. Savage. Automated Worm Fingerprinting. In Proceedings of the Symposium on Operating Systems Design and Implementation (OSDI), 2004.

6. A. Smirnov and T. Chiueh. DIRA: Automatic Detection, Identification, and Repair of Control-Hijacking Attacks. In The 12th Annual Network and Distributed System Security Symposium, February 2005.

7. A. Somayaji and S. Forrest. Automated Response Using System-Call Delays. In Proceedings of the 9th USENIX Security Symposium, August 2000.

8. R. Sommer and V. Paxson. Enhancing Byte-Level Network Intrusion Detection Signatures with Context. In Proceedings of the ACM Conference on Computer and Communications Security (CCS), pages 262–271, 2003.

9. A. Stig, A. Clark, and G. Mohay. Network-based Buffer Overflow Detection by Exploit Code Analysis. In AusCERT Conference, May 2004.

10. S. Stolfo. Worm and Attack Early Warning: Piercing Stealthy Reconnaissance. IEEE Privacy and Security, May/June 2004.

11. G. E. Suh, J. W. Lee, D. Zhang, and S. Devadas. Secure Program Execution Via Dynamic Information Flow Tracking. SIGOPS Operating Systems Review, 38(5):85–96, 2004.

12. T. Toth and C. Kruegel. Accurate Buffer Overflow Detection via Abstract Payload Execution. In Proceedings of the Symposium on Recent Advances in Intrusion Detection (RAID), 2002.

13. K. Wang and S. J. Stolfo. Anomalous Payload-based Network Intrusion Detection. In Proceedings of the 7th International Symposium on Recent Advances in Intrusion Detection (RAID), pages 203–222, September 2004.

---

### Towards Software-Based Signature Detection for Intrusion Prevention on the Network Card

**H. Bos<sup>1</sup> and Kaiming Huang<sup>2</sup>**

<sup>1</sup> Vrije Universiteit, Amsterdam, The Netherlands  
<sup>2</sup> Xiamen University, Xiamen, China

**Abstract:** CardGuard is a signature detection system for intrusion detection and prevention that scans the entire payload of packets for suspicious patterns and is implemented in software on a network card equipped with an Intel IXP1200 network processor. One card can be used to protect either a single host or a small group of machines connected to a switch. CardGuard is non-intrusive in the sense that no cycles of the host CPUs are used for intrusion detection, and the system operates at Fast Ethernet link rate. TCP flows are first reconstructed before they are scanned with the Aho-Corasick algorithm.

**Keywords:** distributed firewall, network processors.

### 1. Introduction

Intrusion detection and prevention systems (IDS/IPS) are increasingly relied upon to protect network and computing resources from unauthorized access, such as through worms, viruses, or Trojans. To protect computing resources on fast connections, it is often desirable to scan packet payloads at line rate. However, scanning traffic for attack signatures is challenging, even with today's networks. As the growth of link speed sometimes exceeds Moore's law, the problem is likely to worsen. Worms, in particular, are difficult to stop manually due to their self-replicating nature and rapid spread. For example, the Slammer worm infected 90% of all vulnerable hosts on the internet in just 10 minutes [1].

In this paper, we explore the feasibility of implementing a complete signature detection system (SDS) in software on the network card rather than performing signature scanning at a centralized firewall or on the end-host's CPU. The concept of a distributed firewall, proposed by Bellovin in 1999, has gained popularity in recent years [2, 3]. However, most of these systems do not implement payload inspection. Recently, Clark et al. proposed using FPGAs for signature detection [4], but the disadvantage of FPGAs and other hardware solutions is their complexity in modification. Therefore, we explore what rates can be sustained in a software-only solution running entirely on a network card equipped with a network processor introduced half a decade ago. This is one of the extremes in the design space for where to perform signature detection and, to our knowledge, has not been explored before.

The resulting SDS, known as CardGuard, is intended to protect either a single end-user's host or a small set of hosts connected to a switch. Our goal has been to make the SDS an inexpensive device while ensuring it is fast enough to handle realistic loads. We assume that the bandwidth requirements of individual users do not exceed a few hundred Mbps. Under normal circumstances, when the number of intrusion attempts compared to regular traffic is reasonably small, the system should handle such loads. In exceptional circumstances, when the system is under heavy attack, we consider gradual degradation in performance acceptable. In such cases, the integrity of the node is more important than the ability to handle high speeds. We focus on the computationally hard problem of network payload pattern matching rather than the less compute-intensive problems of header inspection and anomaly detection. The latter domain is a well-established field of research whose results can even be found in commercial network equipment [5, 6, 7, 8, 9].

The contributions of this paper fall into several categories. First, we demonstrate that network processors can be used for inspecting every single byte of the payload at realistic rates. Second, in a low-end configuration, we present a software-based SDS complete with TCP stream reconstruction and an advanced scanning algorithm (primarily Aho-Corasick [10], although regular expression matching can also be supported) that scales to thousands of signatures. Third, we employ a novel way of using the memory hierarchy of the Intel IXP network processor to exploit locality of reference in the scanning algorithm.

### 1.1 Distributing the Firewall

Most current approaches to IDS/IPS involve a high-performance firewall/IDS at the edge of the network. All internal nodes are assumed to be safe, and all external nodes are considered suspect. The firewall closes all but a few ports and may scan individual packets for attack patterns. Compared to a distributed firewall, this approach has several drawbacks:

1. **Internal Node Protection:** It does not protect internal nodes from attacks originating within the intranet. Once an internal node is compromised, all nodes in the intranet are at risk.
2. **Traffic Volume:** The volume of traffic at the firewall can be very large, making payload scans difficult or infeasible. Managing per-flow state is also an issue. Some researchers suggest that it is difficult to keep per-flow state in the firewall [7], while others propose keeping per-flow state but admit that more work on state management is needed (Bro [11] and TRW [12]). Some approaches use aggregate behavior to avoid maintaining per-flow state [13], or limit themselves to per-packet scans rather than full TCP streams [14]. However, attacks may span multiple packets, each harmless on its own, making flow reconstruction necessary for reliable signature detection. While this is expensive at a centralized firewall, it can be easily done at the end-host.
3. **Heterogeneous Machines:** A centralized firewall often protects a heterogeneous collection of machines, including webservers, mailservers, databases, and workstations. There is no reason to subject traffic to security checks for a particular vulnerable version of a service if it is destined for hosts that do not run that service or have a patched version. Centralized firewalls cannot discriminate among the hosts and services behind them.
4. **Port Limitation:** Centralized firewalls tend to close all ports except a select few, such as those used for web traffic. This leads to new protocols being implemented on top of port 80, defeating the purpose. It also inconveniences users who experience problems with software (e.g., video-conferencing tools) that require additional ports. Per-host firewall configuration is possible but complex, especially with dynamic IP addresses in the intranet.

### 1.2 The IXP1200 Network Processor

In the remainder of this paper, we describe CardGuard, an SDS (and crude IPS) implemented on an IXP1200 network processor unit (NPU). The choice of the IXP1200 was motivated by its potential cost-effectiveness, as it may now be considered yesterday's technology. Despite this, CardGuard performs payload scanning at realistic rates, irrespective of the size or number of patterns, and its presence is transparent to end-applications.

NPUs emerged in the late 1990s to cope with increasing link speeds. The idea is to push packet processing to the lowest possible level in the processing hierarchy, e.g., before traffic hits a host's PCI bus. The Intel IXP1200 used for this work contains one general-purpose StrongARM processor and six independent RISC cores, known as microengines. NPUs have been successfully employed in many network devices, such as routers and monitors. While previous work has shown that they can be used for other tasks [15], there have been few attempts to use them for the computationally intensive task of intrusion detection. Often, such attempts have been limited to header processing (e.g., [16]). A notable exception is [4], which uses the IXP for port filtering and TCP stream reconstruction, feeding the streams into a string matching engine implemented in hardware (FPGA) on a separate card. In contrast, we use a single IXP1200 to handle all tasks, and all processing is in software. Even so, the performance is comparable to the approach with two cards and hardware-based matching. Additionally, the system in [4] is not able to protect more than one host.

CardGuard employs the well-known Aho-Corasick algorithm for performing high-performance pattern searches [10]. The same algorithm is used in the latest versions of the Snort intrusion detection tool [14]. In our work, the algorithm runs entirely on the microengines of the network processor. Moreover, as we verified experimentally that Aho-Corasick exhibits locality of reference, CardGuard uses a hierarchical memory model where frequently accessed data is in faster memory.

On the surface, CardGuard shares some characteristics with "TCP offload," i.e., the implementation of TCP protocol processing on the NIC. TCP Offload Engines (TOEs) have recently come under criticism for being a poor match for the application domain and because TCP processing is not necessarily a very expensive task [17]. While the debate on TOEs continues, we argue that the problem domain for CardGuard is very different (e.g., payload scanning is much more expensive than processing TCP headers). If successful, offloading full payload pattern matching would be very beneficial. Similarly, whereas TOEs try to alleviate the burden on host processors and may introduce scalability problems, CardGuard addresses scalability issues caused by performing all intrusion detection at a central point (the firewall). Additionally, CardGuard provides functionality not equivalent to a centralized firewall, as it also protects hosts from attacks originating within the intranet. Still, it resembles a stand-alone firewall in that traffic is scanned before it arrives at a host, potentially reducing dependency on the correct configuration of the end host.

Most importantly, this paper explores for the first time one of the extremes in the design space for in-band signature detection: a software-only solution on the NIC. Centralized solutions, implementations on the host processor, and even hardware solutions on the NIC have already been studied with some success. CardGuard will help developers evaluate different design options better.

### 1.3 Constraints

Programming in a resource-constrained environment close to the actual hardware is considerably harder than writing equivalent code in user space. Before discussing the SDS in detail, we want to point out that we envision our work as a component (albeit an important one) in a full-fledged intrusion prevention system. Although we achieved a fully functional implementation of CardGuard, this work is a research study that explores an extreme solution to intrusion detection rather than a production-grade IPS. While IDSs and IPSs may be more complex than what can be offered by a single tool like Snort [14], we aim for functionality similar to Snort's signature detection. In essence, CardGuard explores how much processing can be performed on packet payloads using a cheap software-only solution running entirely on the network card. To make the solution cost-effective, the card is equipped with an Intel IXP1200, which may be considered outdated technology. By limiting ourselves to an instruction store per microengine of just 1K instructions, we are forced to code as efficiently as possible. Complex solutions like regular expression matching on the chip's microengines are out of the question. Instead, we try to establish (i) a bound on the link rate that can be sustained when the payload of every single packet is scanned for thousands of strings, while (ii) using hardware that is not state-of-the-art. All packets corresponding to rules with regular expressions are therefore handled by the on-chip StrongARM processor (using almost the same regular expression engine as Snort). Fortunately, the vast majority of patterns in current Snort rules do not contain regular expressions [2].

Even though CardGuard is an SDS and not a complete IDS or IPS, we configured it as an IPS for testing purposes. The card automatically generates alerts and drops connections for flows that contain suspect patterns. The resulting IDS/IPS is crude, but this is acceptable for our purposes, as we are interested mainly in the rates that can be sustained with full payload inspection. In the remainder of the paper, we sometimes refer to CardGuard as an IDS/IPS.

In this paper, we consider only the SDS on the card. The control and management plane for installing and removing rules on the cards is beyond the scope of this paper. We are working on a management plane that allows sysadmins to schedule automatic updates for CardGuard (e.g., to load new signatures). These updates require the system to be taken offline temporarily and may best be scheduled during quiet hours. The system itself is modeled after the control architecture for distributed firewalls proposed in [3]. Note that since management traffic also passes through CardGuard, the management messages are encoded to prevent them from triggering alarms.

### 1.4 Outline

The remainder of this paper is organized as follows. In Section 2, the use of Aho-Corasick in intrusion detection is discussed. Section 3 presents the hardware configuration, while Section 4 provides both an overview of the software architecture and implementation details. In Section 5, experimental results are discussed. Related work is discussed throughout the text and summarized in Section 6. Conclusions are drawn in Section 7.

### 2. SDS and Aho-Corasick

While increasing network speed is one of the challenges in intrusion detection, scalability is another equally important one. As the number of worms, viruses, and Trojans increases, an SDS must check every packet for more and more signatures. The signature of an attack may range from a few bytes to several kilobytes and may be located anywhere in the packet payload. Existing approaches that operate at high speed but only scan packet headers (as described in [16]) are insufficient. Similarly, fast scans for a small number of patterns will not be good enough in the face of a growing number of threats with unique signatures. While it is crucial to process packets at high rates, it is equally imperative to be able to do so for thousands of signatures, small and large, that may be hidden anywhere in the payload.

For this purpose, CardGuard employs the Aho-Corasick algorithm, which has the desirable property that the processing time does not depend significantly on the size or number of patterns. Given a set of patterns to search for in the network packets, the algorithm constructs a deterministic finite automaton (DFA), which is used to match all patterns at once, one byte at a time. It is beyond the scope of the paper to repeat the explanation of how the DFA is constructed (interested readers are referred to [10]). However, for a better understanding of some of the design decisions in CardGuard, it is useful to consider the code that performs the matching in more detail.

#### 2.1 Aho-Corasick Example

As an example, consider the DFA in Figure 1. Initially, the algorithm is in state 0. A state transition is made whenever a new byte is read. If the current state is 0 and the next byte in the packet is a 'Q', the new state will be 36, and the algorithm proceeds with the next byte. If this byte is 'Q', 'h', or 't', we will move to state 36, 37, or 43, respectively. If it is none of the above, we move back to state 0. We continue in this way until the entire input is processed. For every byte in the packet, a single state transition is made (although the new state may be the same as the old state). Some states are special and represent output states. Whenever an output state is reached, we know that one of the signatures has matched. For example, if the algorithm ever reaches state 35, this means that the data in the traffic contains the string 'hws2'.

The DFA in Figure 1 is able to match the five different patterns simultaneously. The patterns, shown beneath the figure, are chosen for illustration purposes, but the first four also represent the patterns that make up the real signature of the Slammer worm [1]. This worm was able to spread and infect practically every susceptible host in thirty minutes by using a buffer overflow exploit in Microsoft SQL Server, allowing the worm to execute code on remote hosts. The fifth pattern was added to show what happens if patterns partly overlap and has no further meaning.

If the initial state is 0 and the input stream consists of these characters: XYZQQhsockfA, we will incur transitions to the following states: 0, 0, 0, 36, 36, 37, 38, 39, 40, 41, 42, and 0. The underlined states represent output states, so after processing the input sequence, we know that we have matched the patterns Qhsoc and Qhsockf. By making a single transition per byte, all present patterns contained in the packet are found.