件作用域。
通常，typedef定义中用大写字母表示被定义的名称，以提醒用户这个类
型名实际上是一个符号缩写。当然，也可以用小写：
typedef unsigned char byte;
typedef中使用的名称遵循变量的命名规则。
为现有类型创建一个名称，看上去真是多此一举，但是它有时的确很有
用。在前面的示例中，用BYTE代替unsigned char表明你打算用BYTE类型的
变量表示数字，而不是字符码。使用typedef还能提高程序的可移植性。例
1099
如，我们之前提到的sizeof运算符的返回类型：size_t类型，以及time()函数
的返回类型：time_t类型。C标准规定sizeof和time()返回整数类型，但是让实
现来决定具体是什么整数类型。其原因是，C 标准委员会认为没有哪个类型
对于所有的计算机平台都是最优选择。所以，标准委员会决定建立一个新的
类型名（如，time_t），并让实现使用typedef来设置它的具体类型。以这样
的方式，C标准提供以下通用原型：
time_t time(time_t *);
time_t 在一个系统中是 unsigned long，在另一个系统中可以是 unsigned
long 
long。只要包含time.h头文件，程序就能访问合适的定义，你也可以在
代码中声明time_t类型的变量。
typedef的一些特性与#define的功能重合。例如：
#define BYTE unsigned char
这使预处理器用BYTE替换unsigned char。但是也有#define没有的功能：
typedef char * STRING;
没有typedef关键字，编译器将把STRING识别为一个指向char的指针变
量。有了typedef关键字，编译器则把STRING解释成一个类型的标识符，该
类型是指向char的指针。因此：
STRING name, sign;
相当于：
char * name, * sign;
但是，如果这样假设：
#define STRING char *
1100
然后，下面的声明：
STRING name, sign;
将被翻译成：
char * name, sign;
这导致只有name才是指针。
还可以把typedef用于结构：
typedef struct complex {
float real;
float imag;
} COMPLEX;
然后便可使用COMPLEX类型代替complex结构来表示复数。使用typedef
的第1个原因是：为经常出现的类型创建一个方便、易识别的类型名。例
如，前面的例子中，许多人更倾向于使用 STRING 或与其等价的标记。
用typedef来命名一个结构类型时，可以省略该结构的标签：
typedef struct {double x; double y;} rect;
假设这样使用typedef定义的类型名：
rect r1 = {3.0, 6.0};
rect r2;
以上代码将被翻译成：
struct {double x; double y;} r1= {3.0, 6.0};
1101
struct {double x; double y;} r2;
r2 = r1;
这两个结构在声明时都没有标记，它们的成员完全相同（成员名及其类
型都匹配），C认为这两个结构的类型相同，所以r1和r2间的赋值是有效操
作。
使用typedef的第2个原因是：typedef常用于给复杂的类型命名。例如，
下面的声明：
typedef char (* FRPTC ()) [5];
把FRPTC声明为一个函数类型，该函数返回一个指针，该指针指向内含
5个char类型元素的数组（参见下一节的讨论）。
使用typedef时要记住，typedef并没有创建任何新类型，它只是为某个已
存在的类型增加了一个方便使用的标签。以前面的STRING为例，这意味着
我们创建的STRING类型变量可以作为实参传递给以指向char指针作为形参
的函数。
通过结构、联合和typedef，C提供了有效处理数据的工具和处理可移植
数据的工具。
1102
14.13 其他复杂的声明
C 允许用户自定义数据形式。虽然我们常用的是一些简单的形式，但是
根据需要有时还会用到一些复杂的形式。在一些复杂的声明中，常包含下面
的符号，如表14.1所示：
表14.1 声明时可使用的符号
下面是一些较复杂的声明示例：
int board[8][8];    // 声明一个内含int数组的数组
int ** ptr;      // 声明一个指向指针的指针，被指向的指针指向int
int * risks[10];   // 声明一个内含10个元素的数组，每个元素都是一
个指向int的指针
int (* rusks)[10];  // 声明一个指向数组的指针，该数组内含10个int类
型的值
int * oof[3][4];   // 声明一个3×4 的二维数组，每个元素都是指向int
的指针
int (* uuf)[3][4];  // 声明一个指向3×4二维数组的指针，该数组中内含
int类型值
int (* uof[3])[4];  // 声明一个内含3个指针元素的数组，其中每个指针
都指向一个内含4个int类型元素的数组
要看懂以上声明，关键要理解*、()和[]的优先级。记住下面几条规则。
1103
1.数组名后面的[]和函数名后面的()具有相同的优先级。它们比*（解引
用运算符）的优先级高。因此下面声明的risk是一个指针数组，不是指向数
组的指针：
int * risks[10];
2.[]和()的优先级相同，由于都是从左往右结合，所以下面的声明中，
在应用方括号之前，*先与rusks结合。因此rusks是一个指向数组的指针，该
数组内含10个int类型的元素：
int (* rusks)[10];
3.[]和()都是从左往右结合。因此下面声明的goods是一个由12个内含50
个int类型值的数组组成的二维数组，不是一个有50个内含12个int类型值的数
组组成的二维数组：
int goods[12][50];
把以上规则应用于下面的声明：
int * oof[3][4];
[3]比*的优先级高，由于从左往右结合，所以[3]先与oof结合。因此，
oof首先是一个内含3个元素的数组。然后再与[4]结合，所以oof的每个元素
都是内含4个元素的数组。*说明这些元素都是指针。最后，int表明了这4个
元素都是指向int的指针。因此，这条声明要表达的是：foo是一个内含3个元
素的数组，其中每个元素是由4个指向int的指针组成的数组。简而言之，oof
是一个3×4的二维数组，每个元素都是指向int的指针。编译器要为12个指针
预留存储空间。
现在来看下面的声明：
int (* uuf)[3][4];
圆括号使得*先与uuf结合，说明uuf是一个指针，所以uuf是一个指向3×4
1104
的int类型二维数组的指针。编译器要为一个指针预留存储空间。
根据这些规则，还可以声明：
char * fump(int);     // 返回字符指针的函数
char (* frump)(int);   // 指向函数的指针，该函数的返回类型为char
char (* flump[3])(int);  // 内含3个指针的数组，每个指针都指向返回
类型为char的函数
这3个函数都接受int类型的参数。
可以使用typedef建立一系列相关类型：
typedef int arr5[5];
typedef arr5 * p_arr5;
typedef p_arr5 arrp10[10];
arr5 togs;  // togs 是一个内含5个int类型值的数组
p_arr5 p2;  // p2 是一个指向数组的指针，该数组内含5个int类型的值
arrp10 ap;  // ap 是一个内含10个指针的数组，每个指针都指向一个
内含5个int类型值的数组
如果把这些放入结构中，声明会更复杂。至于应用，我们就不再进一步
讨论了。
1105
14.14 函数和指针
通过上一节的学习可知，可以声明一个指向函数的指针。这个复杂的玩
意儿到底有何用处？通常，函数指针常用作另一个函数的参数，告诉该函数
要使用哪一个函数。例如，排序数组涉及比较两个元素，以确定先后。如果
元素是数字，可以使用>运算符；如果元素是字符串或结构，就要调用函数
进行比较。C库中的 
qsort()函数可以处理任意类型的数组，但是要告诉
qsort()使用哪个函数来比较元素。为此， qsort()函数的参数列表中，有一个
参数接受指向函数的指针。然后，qsort()函数使用该函数提供的方案进行排
序，无论这个数组中的元素是整数、字符串还是结构。
我们来进一步研究函数指针。首先，什么是函数指针？假设有一个指向
int类型变量的指针，该指针储存着这个int类型变量储存在内存位置的地址。
同样，函数也有地址，因为函数的机器语言实现由载入内存的代码组成。指
向函数的指针中储存着函数代码的起始处的地址。
其次，声明一个数据指针时，必须声明指针所指向的数据类型。声明一
个函数指针时，必须声明指针指向的函数类型。为了指明函数类型，要指明
函数签名，即函数的返回类型和形参类型。例如，考虑下面的函数原型：
void ToUpper(char *); // 把字符串中的字符转换成大写字符
ToUpper()函数的类型是“带char * 类型参数、返回类型是void的函数”。
下面声明了一个指针pf指向该函数类型：
void (*pf)(char *);  // pf 是一个指向函数的指针
从该声明可以看出，第1对圆括号把*和pf括起来，表明pf是一个指向函
数的指针。因此，(*pf)是一个参数列表为(char *)、返回类型为void的函数。
注意，把函数名ToUpper替换为表达式(*pf)是创建指向函数指针最简单的方
式。所以，如果想声明一个指向某类型函数的指针，可以写出该函数的原型
后把函数名替换成(*pf)形式的表达式，创建函数指针声明。前面提到过，由
于运算符优先级的规则，在声明函数指针时必须把*和指针名括起来。如果
1106
省略第1个圆括号会导致完全不同的情况：
void *pf(char *); // pf 是一个返回字符指针的函数
提示
要声明一个指向特定类型函数的指针，可以先声明一个该类型的函数，
然后把函数名替换成(*pf)形式的表达式。然后，pf就成为指向该类型函数的
指针。
声明了函数指针后，可以把类型匹配的函数地址赋给它。在这种上下文
中，函数名可以用于表示函数的地址：
void ToUpper(char *);
void ToLower(char *);
int round(double);
void (*pf)(char *);
pf = ToUpper;   // 有效，ToUpper是该类型函数的地址
pf = ToLower;   //有效，ToUpper是该类型函数的地址
pf = round;    // 无效，round与指针类型不匹配
pf = ToLower();  // 无效，ToLower()不是地址
最后一条语句是无效的，不仅因为 
ToLower()不是地址，而且
ToLower()的返回类型是 
void，它没有返回值，不能在赋值语句中进行赋
值。注意，指针pf可以指向其他带char *类型参数、返回类型是void的函数，
不能指向其他类型的函数。
既然可以用数据指针访问数据，也可以用函数指针访问函数。奇怪的
是，有两种逻辑上不一致的语法可以这样做，下面解释：
1107
void ToUpper(char *);
void ToLower(char *);
void (*pf)(char *);
char mis[] = "Nina Metier";
pf = ToUpper;
(*pf)(mis);  // 把ToUpper 作用于（语法1）
pf = ToLower;
pf(mis);   // 把ToLower 作用于（语法2）
这两种方法看上去都合情合理。先分析第1种方法：由于pf指向ToUpper
函数，那么*pf就相当于ToUpper函数，所以表达式(*pf)(mis)和ToUpper(mis)
相同。从ToUpper函数和pf的声明就能看出，ToUpper和(*pf)是等价的。第2
种方法：由于函数名是指针，那么指针和函数名可以互换使用，所以pf(mis)
和ToUpper(mis)相同。从pf的赋值表达式语句就能看出ToUpper和pf是等价
的。由于历史的原因，贝尔实验室的C和UNIX的开发者采用第1种形式，而
伯克利的UNIX推广者却采用第2种形式。K&R C不允许第2种形式。但是，
为了与现有代码兼容，ANSI 
C认为这两种形式（本例中是(*pf)(mis)和
pf(mis)）等价。后续的标准也延续了这种矛盾的和谐。
作为函数的参数是数据指针最常见的用法之一，函数指针亦如此。例
如，考虑下面的函数原型：
void show(void (* fp)(char *), char * str);
这看上去让人头晕。它声明了两个形参：fp和str。fp形参是一个函数指
针，str是一个数据指针。更具体地说，fp指向的函数接受char * 类型的参
数，其返回类型为void；str指向一个char类型的值。因此，假设有上面的声
明，可以这样调用函数：
1108
show(ToLower, mis);  /* show()使用ToLower()函数：fp = ToLower */
show(pf, mis);    /* show()使用pf指向的函数： fp = pf */
show()如何使用传入的函数指针？是用fp()语法还是(*fp)()语法调用函
数：
void show(void (* fp)(char *), char * str)
{
(*fp)(str); /* 把所选函数作用于str */
puts(str);    /* 显示结果 */
}
例如，这里的show()首先用fp指向的函数转换str，然后显示转换后的字
符串。
顺带一提，把带返回值的函数作为参数传递给另一个函数有两种不同的
方法。例如，考虑下面的语句：
function1(sqrt);   /* 传递sqrt()函数的地址 */
function2(sqrt(4.0)); /* 传递sqrt()函数的返回值 */
第1条语句传递的是sqrt()函数的地址，假设function1()在其代码中会使
用该函数。第2条语句先调用sqrt()函数，然后求值，并把返回值（该例中是
2.0）传递给function2()。
程序清单14.16中的程序通过show()函数来演示这些要点，该函数以各
种转换函数作为参数。该程序也演示了一些处理菜单的有用技巧。
程序清单14.16 func_ptr.c程序
1109
// func_ptr.c -- 使用函数指针
#include 
#include 
#include 
#define LEN 81
char * s_gets(char * st, int n);
char showmenu(void);
void eatline(void);    // 读取至行末尾
void show(void(*fp)(char *), char * str);
void ToUpper(char *);   // 把字符串转换为大写
void ToLower(char *);   // 把字符串转换为小写
void Transpose(char *);  // 大小写转置
void Dummy(char *);    // 不更改字符串
int main(void)
{
char line[LEN];
char copy[LEN];
char choice;
void(*pfun)(char *); // 声明一个函数指针，被指向的函数接受char *类型
1110