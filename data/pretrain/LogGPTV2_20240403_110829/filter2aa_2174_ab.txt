• DDB / GDB 
• Source code
– Introduction to the bug
• Mbuf  pointer overflow / arbitrary MFREE()
NetBSD mbuf Overflow
•
mbufs
– Basic kernel memory unit
– Stores socket buffers and packet data
– Data can span several mbufs (linked list) 
NetBSD mbuf Overflow
•
Developing the exploit
– MFREE() allow for an arbitrary 32-bit value to be written to an 
arbitrary address (Normal unlinking stuff)
– mbuf can have external storage
• And their own free routine!
– This is what I'm using in my exploit
– Exploited mbuf is freed in sbdrop()
NetBSD mbuf Overflow
NetBSD mbuf Overflow
sbdrop(struct sockbuf *sb, int len)
{
struct mbuf     *m, *mn, *next;
next = (m = sb->sb_mb) ? m->m_nextpkt : 0;
while (len > 0) {
if (m == 0) {
if (next == 0)
panic("sbdrop");
m = next;
next = m->m_nextpkt;
continue;
}
if (m->m_len > len) {
m->m_len -= len;
m->m_data += len;
sb->sb_cc -= len;
break;
}
len -= m->m_len;
sbfree(sb, m);
MFREE(m, mn);
•
Unlink technique
– Remove mbuf from chain and link remaining neighboring mbufs 
together
– “Arbitrary” write operations takes place
#define _MCLDEREFERENCE(m)  \ 
do {
    (m)->m_ext.ext_nextref->m_ext.ext_prevref =(m)->m_ext.ext_prevref;
    (m)->m_ext.ext_prevref->m_ext.ext_nextref =(m)->m_ext.ext_nextref;
} while (/* CONSTCOND */ 0)
NetBSD mbuf Overflow
•
Unlink technique example
– Unlinking an mbuf with these values
• m_ext.ext_nextref == 0xdeadbeef
• m_ext.ext_prevref == 0xbadc0ded
– Can be expressed as
• *(unsigned *)(0xbadc0ded+NN) = 0xdeadbeef;
• *(unsigned *)(0xdeadbeef+PP) = 0xbadc0ded;
– Where NN and PP are the offsets to ext_nextref and ext_prevref in 
the mbuf structure respectively.
NetBSD mbuf Overflow
•
Targets to overwrite
– Return address
– “Random” function pointer
– sysent – function pointers to syscalls
•
Cleaning up
– Memory pools, messy and changes between releases
– mbinit()
NetBSD mbuf Overflow
•
External free() technique
– Some mbufs holds a reference to their own free() routine
– No unlinking is done if ext_nextref references its own mbuf
– Point ext_free to your payload – Job done!
– Bonus – No mess to clean up
NetBSD mbuf Overflow
•
Payload
– How to find your process
• I have used allproc and %fs 
– Changing credentials 
• Credential structure pointer found in proc structure
• Change UID 0
– “Cheating” my way out of the loop
• I'm lazy – Return from payload with an extra leave
– Placing the payload
• Return to userland
NetBSD mbuf Overflow
Demonstration
NetBSD mbuf Overflow
•
Finding the vulnerability
– Wrote ~50 line fuzzer
• Not Itchy this time, I actually had to work to find this vuln :)
– Kernel crash in a matter of minutes
•
Debugging it
– KDB
• Easy to set up – Just followed some online guides
• Uses reverse polish notation – Yuck!
• And AT&T syntax...
– Switched to IDA Pro instead (the kernel is just an ELF file)
Unixware Exploitable
NULL Pointer Dereference
•
Vulnerability
– Breaks down to (where edi == 0)
– mov eax, [edi + 0xCh]
– call [eax + 4]
– In other words...
• *(unsigned *)(0xc) = 0x0;
• *(unsigned *)(0x4) = 0x10;
– Would call function at 0x10
Unixware Exploitable
NULL Pointer Dereference
•
Exploiting it
– mmap() address 0x0
• Address 0xc controls eax
• call [eax + 4] == Arbitrary code execution in kernel context
• I put my payload in mmap():ed area and call that
Unixware Exploitable
NULL Pointer Dereference
•
Payload
– Find PID
– Find credentials for PID
– Modify credentials
– Enjoy root...
Unixware Exploitable
NULL Pointer Dereference
•
Developing the payload
– Back to IDA Pro – Looked for something that needs proc ptr or similar
– prfind() looks like a good candidate
• Indeed it takes a PID and returns a proc pointer
– Getting prfind()?
• getksym() is a system call that looks up a kernel symbol :)
– Lookup proc struct in /usr/include/sys/proc.h
• Credential structure pointer at offset 0x78 in struct proc
– Lookup cred struct in /usr/include/sys/cred.h
• Change UID/GID etc – Root shell woohoo!
Unixware Exploitable
NULL Pointer Dereference
Payload listing (why bother to optimize):
push 0xaaaaaaaa
mov  eax, 0xbbbbbbbb
call eax
mov  eax, [eax + 0x78]
mov  dword [eax + 4], 0
mov  dword [eax + 8], 0
mov  dword [eax + 12], 0
mov  dword [eax + 16], 0
add  esp, 4
ret
Unixware Exploitable
NULL Pointer Dereference
Demonstration
Unixware Exploitable
NULL Pointer Dereference
•
Bug found and researched by Alfredo Ortega
•
PoC code was released to execute a breakpoint
•
I successfully tested the vulnerability against OpenBSD 4.0, 3.9, 3.8, 3.7, 
3.6, 3.5, 3.4, 3.3, 3.2, 3.1 (older releases with support for IPv6 might be 
vulnerable too)
•
Code is different in OpenBSD  and then jmp backwards to reach stage 1
OpenBSD IPv6
Remote mbuf Overflow
Payload in 3 stages
•
Stage 1 – Backdoor installation, icmp6_input wrapper
•
Stage 2 – Backdoor
•
Stage 3 – Command(s)
OpenBSD IPv6
Remote mbuf Overflow
Stage 1 (1/2)
•
Find stage 2
– Last mbuf in chain for previous packet (%esp-108)
•
Make sure backdoor is not already installed
– Compare the first four bytes of the backdoor with the corresponding 
bytes in the input function (starts with a call instead of push %ebp)
OpenBSD IPv6
Remote mbuf Overflow
OpenBSD IPv6
Remote mbuf Overflow
Stage 1 (2/2)
•
Wrap icmp6_input with stage 2
– Use ELF symbol resolver part of stage 2 to resolve inet6sw and 
replace inet6sw[4].pr_input with pointer to stage 2
•
Clean up stack and return
Stage 2 (1/4)
•
Listen for ICMPv6 packets with magic bytes
– Copy stage 3 code to allocated memory
– Wrap system call with stage 3 command
•
Call the real icmp6_input routine and return
OpenBSD IPv6
Remote mbuf Overflow
Stage 2 (2/4) – ELF symbol resolver
•
Find ELF header, which is mapped after .bss
– Scan for ”\x7FELF” from Interrupt Descriptor Table
•
Search for hash of symbol string in the .dynsym section
OpenBSD IPv6
Remote mbuf Overflow
Stage 2 (3/4) – Syscall wrapper
•
Exploit will be more portable if system calls are used
•
Need process context to use system calls
•
fork1() from initproc inside an interrupt does not work (anymore)
•
Wrap a system call, wait for it to be called, fork1() from that process
OpenBSD IPv6
Remote mbuf Overflow
Stage 2 (4/4) – Syscall wrapper
•
Wrap gettimeofday() with stage 3, since it is called quite frequently
•
Store address of the real gettimeofday() and its index (116) at the 
beginning of the stage 3 command
OpenBSD IPv6
Remote mbuf Overflow
Stage 3 (1/3) – Commands
•
Connect-back
•
Set secure level
•
Shell commands (/bin/sh -c)
•
Uninstall backdoor
OpenBSD IPv6
Remote mbuf Overflow
OpenBSD IPv6
Remote mbuf Overflow
Stage 3 (2/3) – Initialization
•
Use stage 2 resolver to resolve symbols
•
Reset the wrapped system call to the original function pointer
•
Call the real system call and save the return value
•
fork1() from the calling process
Stage 3 (3/3) – Command process
•
Make sure we run as root
.macro setuid_root proc
    movl 16(\proc), %eax  # struct pcred pointer
    movl $0, 4(%eax)      # Real User ID
.endm
•
Terminate the process on failure
OpenBSD IPv6
Remote mbuf Overflow
Demonstration
OpenBSD IPv6
Remote mbuf Overflow
•
Kernel vulnerability in the IEEE 802.11 subsystem of FreeBSD
– Auditing the code
– Implementing the exploit
– Vulnerability found and exploited by Karl Janmar
FreeBSD 802.11
Remote Integer Overflow
•
Auditing the IEEE 802.11 stack of FreeBSD
– The IEEE 802.11 code in its current shape is relatively new in 
FreeBSD
•
Problems faced when auditing the code
– IEEE 802.11 has a complex link-layer protocol
• Rough metric, source-code of input functions
– ieee80211_input() - 437 lines
– ether_input() - 107 lines
– ip_input() - 469 lines
FreeBSD 802.11
Remote Integer Overflow
•
(cont.) Problems faced when auditing the code
– Code is not written to be easily read (not by me at least)
• Huge recursive switch-statements
• Macros that include return statements etc
•
Lots of user-controlled data
– Link-layer management is unauthenticated and unencrypted
•
Found a local issue
– Ioctl which had a logic error, only kernel-memory disclosure
•
Found another interesting issue:
FreeBSD 802.11
Remote Integer Overflow
Code for function called by ioctl[SCAN_RESULTS] (1/3):
static int
ieee80211_ioctl_getscanresults(struct ieee80211com *ic, struct ieee80211req *ireq)
{
union {
struct ieee80211req_scan_result res;
char data[512];
/* XXX shrink? */
} u;
struct ieee80211req_scan_result *sr = &u.res;
struct ieee80211_node_table *nt;
struct ieee80211_node *ni;
int error, space;