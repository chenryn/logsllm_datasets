452          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Association6.1 Developer-assisted Vulnerability Analysis
Developer-supplied Input. While the automated syntactic
analysis has provided a large number of inputs, not all of
them are of interest to attackers. For instance, in the PNG ex-
ample, not all input correspond to valid images; it is not very
interesting to determine the errors in the PNG ﬁle formats. In
practice, only software developers are able to identify the true
secretive set of input that they would like to make indistin-
guishable. This is called semantic-level analysis. Developers
may select the set of inputs I that she wishes to be indistin-
guishable from the execution traces and use ANABLEPS to
analyze E(p,I ).
The steps to perform such an analysis is similar to auto-
mated analysis described in §4. The only difference is that the
Input Generation step and “determining input spaces for G i”
of the Vulnerability Identiﬁcation step can be skipped, as the
set of input of interest is now provided by the developers. The
output of the analysis would be |G i ↔ Ii| that can be differ-
entiated by order or time information of the execution traces.
Locating Vulnerabilities. Given a secretive set of input I , if
|E(p,I )| > 1, we would like to ﬁnd the set of nodes in G that
can be used to learn the inputs. That is, we would like to locate
the vulnerabilities (i.e., vulnerable node) in the graph and the
program. With the method discussed in §4, we can differenti-
ate order-based vulnerable nodes and time-based vulnerable
nodes. The capability to easily locate vulnerabilities is one
beneﬁt of adopting ED-CFG to represent execution traces.
c and G i
With the input set of Isyntactic, the statistics of the vulner-
able nodes are shown in Table 4. The cache-level statistics
are listed in the column 3 to 5, and the page-level statistics
are reported in column 6 to 8. The total numbers of nodes
in G i
p are shown in column 3 and 6; the numbers of
order-based vulnerable nodes are listed in column 4 and 7;
and the numbers of time-based vulnerable nodes are listed in
column 5 and 8, respectively. In the Table 4, the time-based
vulnerable nodes are mutually exclusive with the order-based
vulnerable nodes. According to the results presented in Ta-
ble 4, ANABLEPS narrows down the number of nodes to be
examined for side-channel vulnerabilities dramatically. On
average, the number of order-based vulnerable nodes is only
18% of all nodes in Gc, and 37% of all nodes in Gp; the num-
ber of time-based vulnerable nodes is only 6% of all nodes
in Gc, and 13% of all nodes in Gp. The fraction of vulnerable
nodes can be further reduced with a developer-supplied input
set that is of interest.
6.2 Case Studies of the Exploitability Analysis
In this section, we brieﬂy summarize three interesting cases
to show how ANABLEPS can help enclave developers identify
side-channel vulnerabilities that can be exploited to extract
sensitive information.
1
2
3
4
5
6
7
8
11
12
13
14
15
16
17
18
19
20
i n t binomial ( i n t n , double p )
{
. . .
f o r ( i =0;
i n _ v i s i b l e ;
i ++) {
i f ( x [ i ] == 0)
{
t i l d e _ x [ i ] = 0;
} e l s e {
t i l d e _ x [ i ] = binomial ( x [ i ] , p ) ;
}
}
}
Figure 2: The deep learning vulnerable code
6.2.1 Deep Learning Algorithms
According to Table 2, there are 214 different inputs for algo-
c ↔ Ii. Therefore, poten-
rithm dA that has unique Gc, i.e., G i
tially the vulnerabilities in dA may lead to exploitable infor-
mation leakage. In order to start analyzing the vulnerabilities
in dA algorithm, we ﬁrst manually selected inputs that might
be of interest to attackers: a set of |I| training data that differ
only in values. Then, we feed these inputs to ANABLEPS. The
output of ANABLEPS indicates that all selected inputs have
unique cache-level execution traces, i.e., |E(p,I )| = |I|.
After locating the vulnerable nodes and some man-
ual effort
to examine the identiﬁed vulnerable nodes,
we ﬁnd the leakage primarily comes from function
dA_get_corrupted_input(), which has a for loop that
enumerates every element of array x and calls function
binomial() if the element is not 0. The code snippet is shown
in Figure 2.
The execution of dA_get_corrupted_input() and
binomial() may be exploited to leak training data infor-
mation. Whether or not function binomial() is called by
dA_get_corrupted_input() reveals the value of array x.
The function call sequence can be learned through cache-
level side channels. The two functions are located in the same
page but different cachelines. After compilation, the for loop
in dA_get_corrupted_input() is compiled into two cache-
lines, denoted m1 and m2, function binomial() is compiled
into two consecutive cachelines. We denote the ﬁrst cache-
line as m3. Therefore, if the ith element of array x is 0, the
order of the executed cachelines is [m1,m2]; otherwise, the
execution order becomes [m1,m2,m3,m2]. This order-based
side-channel vulnerability on the cache-level can completely
leak the training data of the deep learning algorithm.
6.2.2 Freetype Font Engine
According to Table 2, there are 206 inputs that have unique G i
p.
To validate the page-level vulnerability, we generated some
printable characters as input and fed them to ANABLEPS. The
result indicates that every input corresponds to a unique G i
p.
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 453Programs
Functionalities
Under Test
#Nodes
Cache Level
#Order-Based
Vulnerable Nodes
Page Level
#Order-Based
Vulnerable Nodes
Deep Learning
gsl
Hunspell
PNG
Freetype
Bio-rainbow
QRcodegen
Genometools
dA
SdA
DBN
RBM
Sort
LogisticRegression
Permutation
Spell checking
PNG Image Render
Character Render
Bioinfo Clustering
Generatee QR
bed to gff3 convertion
69
109
126
68
48
31
99
302
640
1054
214
176
1901
9
12
17
8
2
12
30
48
170
263
16
32
231
#Time-Based
Vulnerable Nodes
#Nodes
4
21
81
27
16
0
0
9
90
18
0
18
9
13
22
14
13
11
11
29
47
53
82
24
15
147
#Time-Based
Vulnerable Nodes
3
3
10
7
7
0
0
10
2
13
1
3
5
Table 4: Locating vulnerable nodes in Gc and Gp
2
3
3
2
0
5
15
27
39
20
2
6
53
mov
add
c a l l
cmp
jne
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
s t a t i c void p s h _ g l y p h _ i n t e r p o l a t e _ s t r o n g _ p o i n t s ( . . . ) {
. . .
f or
( ; count >0; count −−, point ++) {
. . .
i f
( psh_point_is_edge_min ( point ) )
point −>cur_u = . . . ;
point −>cur_u = . . . ;
( psh_point_is_edge_max ( point ) )
i f
e l s e
e l s e {
data = . . . ;
i f
i f
( d e l t a >= hint −>org_len )
( delta cur_u = FT_MulFix ( . . . ) + . . . ;
point −>cur_u = FT_MulFix ( . . . ) + . . . ;
point −>cur_u = FT_MulDiv ( . . . ) + . . . ;
e l s e
e l s e
}
p s h _ p o i n t _ s e t _ f i t t e d ( point ) ;
}
}
Figure 3: The freetype vulnerable functions
ANABLEPS has helped us identify the vulnerable nodes.
In fact, there are more than one vulnerable nodes. To
illustrate these vulnerabilities, we explain the leakage
through function psh_glyph_find_strong_points() at
the page level. The code snippet
is shown in Fig-
ure 3. psh_glyph_interpolate_strong_points() in-
cludes a loop to interpolate every strong point into the
glyph. Adversaries can recover the strong points po-
sition according to the page sequence. More speciﬁ-
cally, function psh_point_is_edge_min() is placed in
page m1. Functions FT_MulFix() and FT_MulDiv() are
placed in another page, denoted m2. The page of func-
tion psh_glyph_interpolate_strong_points() is de-
noted m3. The access order of these pages leaks informa-
tion of the interpolated point: When a point is not marked
as a strong point, the order of page access is [m3]; when
the strong point is located in the edge, the order of page ac-
cess is [m3,m1,m3,m1,m3]; otherwise, the sequence would be
[m3,m1,m3,m2,m3,m1,m3]. Given the sequence of this func-
tion, the attacker can learn whether each point is strong or not.
Though the example does not completely leak the content of
the data, it illustrates how leakage can be identiﬁed.
1
2
3
4
5
6
7
8
11
12
13
14
15
16
17
18
19
20
21
22
23
24
8050920 :
. . .
8050 b05 :