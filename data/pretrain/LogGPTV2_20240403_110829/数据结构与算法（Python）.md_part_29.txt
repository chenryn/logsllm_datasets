误。
现在我们已经建立了一个解析树,我们能用它来干什么呢？首先,我们将写一个函数来计算解析树
的值，并返回该计算结果。为了实现这个函数,我们将利用树的分层结构。重新看一下图 6.11 回想
一下我们能够将原始的树替换为化简后的树(图 6.12)。这提示了我们可以写一个能够通过计算每个子
树的值从而算出整个解析树值的递归算法。
就像我们以前实现递归算法那样，我们将从识别基本问题开始来设计递归计算表达式值的函
数。这个递归算法的最小基本问题是检查一个操作符是否为叶节点。在解析树中，叶节点总是操作
数。因为数字变量如整数和浮点数不需要更复杂的分析，evaluate函数只需要简单地返回叶节点中储
存的数字就可以。使函数朝向基本情形前进的递归过程就是调用evaluate函数获取当前节点的左子
树、右子树的值。递归调用使我们有效地朝叶节点移动。
为了将两个递归调用的结果整合在一起，我们只需简单地使储存在父节点中的操作符应用到两
个子节点返回的运算结果上。在图 6.12 中，我们能看到两个子节点的值分别为 10 和 3。对它们使
用乘法运算就能得到最终结果30。
递归函数evaluate的代码如 Listing1 所示。首先，我们会得到当前节点的左子节点、右子节点
的参数值。如果左右子节点的值都是None,那么我们就能知道这个当前节点是一个叶节点。这个检查
在第 7 行。如果当前节点不是一个叶节点,那么就会查看当前节点中的操作符,并将它运用到通过递
归求值得到的左右子节点结果的计算上来。
为了实现这个算法，我们使用了键值分别为’+’,’-‘,’*’和’/’的字典(dictionary)。存在
字典里的值是 Python 的操作符模块(operator module)中的函数。这个操作符模块为我们提供了很多
常用操作符的函数。当我们在字典中查找一个操作符时，相应的函数功能会被取回。因为这个取回
的变量是一个函数,我们按通常函数调用的方式来调用它们，如函数名(变量
1, 变量 2)。所以查找操作符‘+’(2,2)就等价于operator.add(2,2)。
def evaluate(parseTree):
opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}
leftC = parseTree.getLeftChild()
rightC = parseTree.getRightChild()
if leftC and rightC:
fn = opers[parseTree.getRootVal()]
return fn(evaluate(leftC),evaluate(rightC))
else:
return parseTree.getRootVal()
代码 6.16 解析树的生成函数
最后，我们将通过图 6.13 创建的解析树对evaluate函数进行具体分析。当我们第一次调用
evaluate函数时，我们传递了整个解析树的根节点作为parseTree参数。然后我们获得了其左右子树
的参数值，并得知它们的存在。递归调用发生在第 9 行。我们从查看根节点中的操作符开始——
'+'。’+’操作符对应了有两个参数变量的函数operator.add。通常对一Python 函数调用而言。
Python第一件做的事情就是评估传递给函数的参数。这里，这两个参数都是evaluate函数的递归调
用值。通过从左到右的求值过程,第一个递归调用从左边开始。在第一个递归调用中，evaluate函数
被赋予了左子树的值。我们发现这个节点没有左、右子节点,所以我们在一个叶节点上。当我们在叶
节点上时，我们返回这个叶节点存储的数值作为求值的结果即可。因此我们返回整数3。
现在，为了完成顶层调用operator.add函数的计算，我们已经有了其中一个参数了。但是我们
还没有全部完成。继续从左到右计算参数,现在递归调用用来计算根节点的右子节点。我们发现这个
节点既有左子节点又有右子节点，所以我们查找这个节点中存储的操作符为‘*’ ，然后调用明白这
个操作符函数并将它的左右子节点作为函数的两个参数。此时,递归调用都将去往叶节点，各自的值
分别为整数 4 和 5。得到这两个参数值后，我们返回 operator.mul(4,5)的值。此时，我们已经计算
好了顶层操作符‘+’的两个操作数了，我们所需要做的只是完成调用函数 operator.add(3,20)即
可。这个结果就是整个表达式树(3+(4*5))的值，为23。
6.7 树的遍历
之前我们已经了解了树数据结构的基本功能了，现在我们来看一看树的一些其他使用模式。这
些使用模式按照访问节点的方式不同可以分为 3 种。这是三种访问树中的所有节点的常用模式,它们
之间的不同在于访问每个节点的次序不同。我们称这种对所有节点的访问为遍历(traversal)。这三种
遍历分别叫做前序遍历(preorder)，中序遍历(inorder)和后序遍历(postorder)。我们先来给出它们的
具体定义，然后举例看看它们的应用。
前序遍历(preorder)：在前序遍历中，我们先访问根节点，然后递归地前序遍历访问左子树，再
递归地前序遍历访问右子树。
中序遍历(inorder)：在中序遍历中，我们递归地中序遍历访问左子树，然后访问根节点，最后
再递归地中序遍历访问右子树。
后序遍历(postorder)：在后序遍历中，我们先递归地后序遍历访问左子树和右子树，最后访问
根节点。
现在我们用几个例子来说明这三种不同的遍历方式。首先我们先看看前序遍历。我们通过用树
结构呈现一本书的例子来看看前序遍历的方式。书是树的根节点，每一章是根节点的子节点，每一
节是章的子节点，每一小节是每一节的子节点,以此类推。图 6.14 是一本只取了两章的书。虽然遍
历的算法适用于含有任意多子节点的树结构，但暂时我们只关注二叉树。
图 6.14 用树结构来表示一本书
设想你要从头到尾阅读这本书。前序遍历恰好符合这种顺序。从根节点(书)开始我们按照前序遍
历的顺序来阅读。我们递归地调用preorder到其左子节点,在这里是第一章，我们继续递归地调用
preorder到左子节点第一节 1.1。第一节 1.1 没有子节点,我们不再递归下去。当我们阅读完 1.1 节
后我们回到第一章，这时我们还需要递归地访问第一章的右子树 1.2 节。由于我们先访问左子树，
所以我们先看 1.2.1 节，再看 1.2.2 节。当 1.2 节读完后,我们又回到第一章。之后我们再返回根节
点(书)然后按照上述步骤访问第二章。
由于用递归来编写，前序遍历的代码异常的简洁优美。代码 6.17 给出了一个二叉树前序遍历的
Python 代码。
你可能想知道，什么是写类似前序遍历算法的最佳方式？应该是简单地使用作为数据结构的
树，还是应该作为树数据结构的一种方法？表代码 6.17 展示了一个需要二叉树作为参数的作为外部
函数的前序遍历的算法版本。由于我们的基本情况是简单地检查是否存在树，这个外部函数就显得
非常简介优美。如果树参数为None，则函数就会返回而不采取任何行动。
def preorder(tree):
if tree:
print(tree.getRootVal())
preorder(tree.getLeftChild())
preorder(tree.getRightChild())
代码 6.17 二叉树的前序遍历函数
我们也可以让preorder作为二叉树类中的内置方法，这部分代码如代码 6.18 所示。注意这一
代码从外部移到内部所产生的变化。概括的说,我们我们只是将“tree”换成了“self”。但是我们也
要修改代码基本情况。内置的方法在递归调用preorder之前必须检查左右子节点是否存在。
def preorder(self):
print(self.key)
if self.leftChild:
self.leftChild.preorder()
if self.rightChild:
self.rightChild.preorder()
代码 6.18 二叉树类中的前序遍历方法
内置和外置这两种方法哪种更好一些呢？一般来说外置函数更好。原因在于你很少需要单纯遍
历整个树。多数情况下你只是想利用基本的遍历方法来实现其他的事情。事实上我们马上就会看到
后序遍历的算法和我们之前写的解析树求值的代码关系紧密。因此我们接下来将都按照外部函数的
形式书写遍历的代码。
后序遍历的代码如代码 6.19 所示,它除了将 print 语句移到末尾之外和前序遍历的代码几乎一
样。
def postorder(tree):
if tree != None:
postorder(tree.getLeftChild())
postorder(tree.getRightChild())
print(tree.getRootVal())
代码 6.19 二叉树的后序遍历函数
我们已经见过了后序遍历的一种一般应用，也就是解析树求值。我们再来看代码 6.15 ，先求左
子树的值，再求右子树的值，然后再利用操作符的函数调用将它们在根节点处结合。假设我们的二
叉树只储存表达式树的数据。我们可以改写求值函数并尽量模仿后序遍历的代码代码 6.18 ），代码
6.20 所示。
def postordereval(tree):
opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}
res1 = None
res2 = None
if tree:
res1 = postordereval(tree.getLeftChild())
res2 = postordereval(tree.getRightChild())
if res1 and res2:
return opers[tree.getRootVal()](res1,res2)
else:
return tree.getRootVal()
代码 6.20 采用后序遍历法重写表达式求值代码
我们发现代码 6.20 的形式和代码 6.19 是一样的，区别在于在代码 6.19 中我们输出键而在代
码 6.20中 我们返回键。这使我们可以通过第 6 行和第 7 行将递归得到的值储存起来。之后我们
利用这些保存起来的值和第 9 行的运算符一起运算。
本节的最后一种遍历方式为中序遍历。在中序遍历中，我们先访问左子树，之后是根节点，最
后访问右子树。代码 6.21 给出了中序遍历的代码。我们发现这三种遍历的函数代码只是改变了
print语句相对于递归函数调用的位置。
def inorder(tree):
if tree != None:
inorder(tree.getLeftChild())
print(tree.getRootVal())
inorder(tree.getRightChild())
代码 6.21 二叉树的中序遍历函数
如果我们对解析树进行一个简单的中序遍历，我们将得到没有圆括号的原始表达式。我们可以
修改基础的中序遍历的算法使我们复原全括号表达式。只要做如下修改：在递归访问左子树之前输
出左括号，然后在访问右子树之后输出右括号。修改的代码见代码 6.22 。
def printexp(tree):
sVal = ""
if tree:
sVal = '(' + printexp(tree.getLeftChild())
sVal = sVal + str(tree.getRootVal())
sVal = sVal + printexp(tree.getRightChild())+')'
return sVal
代码 6.22 采用中序遍历递归算法来生成全括号中缀表达式
我们发现 printexp 函数对每个数字也加了括号，这些括号显然没必要加。在本章最后的练习中
会有练习要求你修改 printexp 函数来去除这些括号。
6.8 二叉堆 BINARY HEAP 实现的优先队列
在前面的章节里我们学习了“先进先出”(FIFO)的数据结构：队列(Queue)。队列一种重要的变
体叫做“优先队列”(Priority Queue)。优先队列的出队(Dequeue)操作和队列一样，都是从队首出
队。但在优先队列内部,数据项的次序是由它们的“优先级”来确定的:有最高优先级的数据项排在队
首,而优先级最低的数据项则排在队尾。这样，优先队列的入队(Enqueue)操作就可能需要将数据项挤
到队列前方。我们将会发现,对于下一章要学的一些图算法，优先队列是很有用的一种数据结构。
你可能很自然地会想到用排序函数和队列的一些简单方法来实现优先队列。但是，在列表里插
入一个数据项的复杂度是O(n)，列表排序的复杂度是O(nlogn)。我们可以用别的方法来降低复杂
度。一个实现优先队列的经典的方法便是采用二叉堆(Binary Heap)数据结构。二叉堆能将优先队列
的入队和出队复杂度都保持在 O(logn).。
二叉堆的有趣之处在于，其逻辑结构用图形表示很像二叉树，但我们却可以仅仅用一个列表来
实现它。二叉堆通常有两种:最小成员key排在队首的称为“最小堆(min heap)”，反之，最大 key
排在队首的是“最大堆(max heap)”。在这一节里我们会使用最小堆。我们把最大堆的使用留作练
习题。
6.8.1 二叉堆操作
数据结构二叉堆的基本操作定义如下：
• BinaryHeap():创建一个新的空二叉堆对象
• insert(k):加入一个新数据项到堆中
• findMin():返回堆中的最小项,最小项仍保留在堆中
• delMin():返回堆中的最小项,同时从堆中删除
• isEmpty():返回堆是否为空
• size():返回堆中数据项的个数
• buildHeap(list):从一个 key 列表创建新堆
如代码 6.23 所示是一些二叉堆方法使用的示例。可以看到无论我们以哪种顺序把数据项添加到
堆里，每次都会移除最小的数据项。我们接下来就要实现这种想法。
from pythonds.trees.binheap import BinHeap
bh = BinHeap()
bh.insert(5)
bh.insert(7)
bh.insert(3)
bh.insert(11)
print(bh.delMin())
print(bh.delMin())
print(bh.delMin())
print(bh.delMin())
代码 6.23 二叉堆方法使用的示例
6.8.2 二叉堆实现
6.8.2.1 二叉堆的结构性质
为了使堆操作高效运行，我们将利用二叉树的操作复杂度为对数级这一性质来实现堆操作。同
时，为了使堆操作的复杂度始终保持在对数水平上，就必须始终保持二叉树的“平衡”。平衡的二
叉树树根左右子树有着相同数量的节点。在我们的堆实现中，我们采用“完全二叉树”的结构来近
似实现“平衡”。完全二叉树，指每个内部节点都有两个子节点，最多可有一个节点例外。图6.15
所示是一个完全二叉树。
图 6.15：完全二叉树
完全树的另一个有趣的特性是我们能用单个列表来实现完全树而不需要使用节点，引用或嵌套
列表。因为对于完全树，如果节点在列表中的位置为p，那么其左子节点的位置为2p，类似的，其