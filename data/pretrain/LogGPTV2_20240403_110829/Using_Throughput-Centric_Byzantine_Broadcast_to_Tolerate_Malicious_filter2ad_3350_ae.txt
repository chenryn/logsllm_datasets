the coin distribution immediately after block y (i.e., when we
apply all the transactions in blocks 1 through y). For the kth
slot in epoch i, every honest node uses hash1(k|beaconi) as
randomness to select m coins (with replacement) from D. The
holders (in D) of these coins then become the committee for
the OVERLAYBB invocation corresponding to that slot. The
holder of the ﬁrst coin selected will be the broadcaster. Since
beaconi, k, and D are all public information in epoch i, all
honest nodes will select the same broadcaster/committee, if
their have the same sequences of blocks prior to epoch i.
Generating beacons: Overview. Beacon generation is a cen-
tral issue in PoS blockchains, and there have been a number
of prior approaches [7], [11], [16]. Some of these [11], [16]
do not work well under malicious majority. We build upon
the approach in [7]. Roughly speaking, they [7] observe that
the beacon is eventually only used to select a committee.
Assuming that a random oracle is used to select the com-
mittee based on the beacon, the committee will be bad (e.g.,
having no honest committee member) with only exponentially
Fig. 3: Generating the beacon in an epoch. The number of
slots in each portion is not to scale.
small probability. Hence a computationally-bounded adversary
simply will have a hard time ﬁnding a bad beacon, even if it
can choose any beacon it wants.
Directly adopting this idea in BCUBE does not lead to a
practical solution, since the number of beacons the adversary
can try is still huge. To make it work, we use a simple idea
of weak Proof-of-Work (weak PoW), so that generating a valid
beacon takes some computational effort. Recall that Section II
assumed that the adversary’s computational power is at most
100 times of the computational power of the honest nodes.
Generating beacons: Details. To facilitate beacon generation,
each block in BCUBE contains two additional ﬁelds: nonce
and candidate. The nonce ﬁeld is just some uniformly
random bits locally generated by the broadcaster, who is also
the creator, of that block. A block is called an honest block if
its broadcaster/creator is an honest node.
Recall that the nodes generate beaconi during epoch i− 1.
Let T1 and T5 be the start and end time, respectively, of epoch
i − 1 (Figure 3). Let T2 be the time when the ﬁrst τ slots in
epoch i − 1 have been conﬁrmed. At time T2, all the nonce
values in these τ blocks are concatenated (not XOR-ed), and
used as the fresh challenge for the weak PoW in this epoch.
Here τ is chosen such that with high probability, there is at
least one honest block (and hence one honest nonce) among
those τ blocks. This ensures that the adversary cannot pre-
compute PoW solutions before the beginning of epoch i − 1.
The honest nodes will try solving the weak PoW, starting
from time T2 and until time T3, where T3 can be any value
no larger than T4 − dδ. Here T4 is the latest time such that
there are still τ slots (called candidate-holding slots) whose
OVERLAYBB invocations have not yet started at time T4, but
will end by time T5. To solve the weak PoW, a node needs to
ﬁnd x such that hash2(challenge|x) has a certain number
of leading zeroes. We also call such x as a PoW solution.
At time T3, every node will ﬂood/multicast whatever PoW
solution (if any) it has found. To avoid unnecessary bandwidth
consumption, each node only sends/relays the very ﬁrst PoW
solution it ﬁnds/receives, and ignores all other PoW solutions.
Since all the honest nodes form a connected component, if
they collectively ﬁnd at least one PoW solution by T3, then
every honest node B must see some PoW solution by T4. But
different honest nodes may see different PoW solutions.
The period from T4 to T5 serves to enable the honest nodes
to agree on one PoW solution. To achieve this, from time T4
to T5, whenever a node is chosen as the broadcaster, it sets the
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:36:30 UTC from IEEE Xplore.  Restrictions apply. 
91271
slots𝑇𝑇4𝑇𝑇3𝑇𝑇2𝑇𝑇5𝑇𝑇19×60min(6×60−2)min2min9×60mincombinenoncesto form challengeCompute the beaconusing these blockssolve weak PoWin [𝑇𝑇2,𝑇𝑇3]flood PoWsolution in [𝑇𝑇3,𝑇𝑇4]candidate ﬁeld in its block to be the single PoW solution
that it previously sent/relayed, or null if it does not have
any. Finally, at time T5, a node examines all the τ candidate-
holding slots, and picks the ﬁrst block with a candidate value
that is not null. It then uses hash2(challenge|candidate)
as beaconi. Note that most likely, this candidate is from
a malicious block and is set by the adversary. This is not a
problem — all we need is that i) the adversary do not have
too many candidates to choose from, and ii) the honest nodes
agree on this candidate.
If all the τ candidate-holding slots have candidate =
null, then a node will set beaconi to be beaconi−1, which
means that the system simply reuses the old beacon and the
corresponding old coin distribution D. Note that this can only
occur when either there is no honest block in the τ candidate-
holding slots (whose probability can be tuned by adjusting τ),
or the honest nodes have found no PoW solution. Our analysis
next will fully take into account all such possibilities.
VII. SECURITY ANALYSIS
This section analyses the security guarantees, or more
speciﬁcally, safety and liveness/throughput, of BCUBE.
A. Safety of BCUBE
Recall that in BCUBE, each node maintains an append-
only sequence of blocks. The ith block is simply the return
value from the ith invocation of OVERLAYBB. A node invokes
OVERLAYBB periodically (e.g., every 98 seconds), and each
invocation takes the same amount of time to complete. Hence
a node adds blocks, one by one, to the sequence.
Safety of BCUBE essentially means that for each i ≥ 1 and
after the ith invocation of OVERLAYBB returns, the ith block
on all honest nodes should always be the same. This is also
sometimes called the consistency or agreement property of
the blockchain. To eventually prove such safety guarantee of
BCUBE, the following lemma ﬁrst summarizes the properties
of OVERLAYBB, whose proof is deferred to Appendix V:
Theorem 1. [guarantees of OVERLAYBB] In Algorithm 1, if
the committee has at least one honest member, then
• All honest nodes must return the same object.
• If the broadcaster is honest, then all honest nodes must
return the object broadcast by the broadcaster.
Finally, regardless of
returns within 2dm + s rounds.
the committee, Algorithm 1 always
Part of Theorem 1 requires the committee to contain some
honest member. Consider any slot in epoch i. Recall that the
committee for that slot is chosen using beaconi. This beaconi
is generated in epoch i− 1, and may be biased and inﬂuenced
by the adversary: i) the adversary may ﬁnd multiple PoW
solutions in epoch i − 1, and cherry-pick the one that it likes;
ii) if the τ broadcasters in the ﬁrst τ slots of epoch i−1 are all
malicious, then the adversary can predict the PoW challenge
before time T1, and can pre-compute many PoW solutions;
iii) if the honest nodes fail to ﬁnd any PoW solution in epoch
i−1 or if the τ broadcasters in the τ candidate-holding slots in
epoch i − 1 are all malicious, then beaconi−1 may be reused
as beaconi, and beaconi−1 may already be biased; iv) if the
committee for some slot in epoch i − 1 contains no honest
members, then the honest nodes may not even agree on the
PoW challenges and on what beaconi is.
We will
later reason about
the probabilities of various
random events, such as whether the committee in Theorem 1
contains some honest member. The adversary may inﬂuence
such probabilities, by for example, biasing the beacons as
explained above. The amount of such inﬂuence will depend
on what strategy the adversary uses. We will carefully ensure
that all our analyses (e.g., regarding the probabilities) hold,
even under the worst-case adversary that uses the optimal
strategy. In particular, our analyses will not make claims such
as Pr[X] = y, but only make claims such as Pr[X] ≤ y. This
just means that while Pr[X] may be different under different
strategies of the adversary, it can never be above y.
We now introduce some random variables. Consider all the
slots in the blockchain. Let ρ be the number of slots in each
epoch. For all integer j ∈ [1,∞) and all λ ≥ 1, let random
variable Zλ(j) denote the event that all of the following events
happen in the execution of BCUBE:
• For each slot j(cid:48) where 1 ≤ j(cid:48) ≤ j, the committee for that
slot contains at least one honest member.
ρ (cid:101) − 1, no more
• For each epoch i(cid:48) where 1 ≤ i(cid:48) ≤ (cid:100) j+1
than λ different PoW solutions are seen by honest nodes
in epoch i(cid:48).
For all λ ≥ 1, deﬁne Zλ(0) to be an event that always occurs.
the execution is
“good” up to slot j. The ﬁrst part in Zλ(j) corresponds to
the requirement in Theorem 1, and the second part serves to
facilitate later reasoning about Pr[Zλ(j)] via a recursion. In
this second part, the λ solutions “seen by honest nodes” can be
i) PoW solutions for epoch i(cid:48) found by honest nodes, ii) PoW
solutions for epoch i(cid:48) found by malicious nodes in epoch i(cid:48),
and iii) PoW solutions for epoch i(cid:48) found by malicious nodes
before epoch i(cid:48) started (if the PoW challenge is not fresh).
We now formally state the safety guarantee of BCUBE:
Roughly speaking, Zλ(j) means that
Theorem 2. [safety guaranteed in “good” execution] For
any given λ ≥ 1 and j ≥ 1, if Zλ(j) occurs, then for each
j(cid:48) where 1 ≤ j(cid:48) ≤ j, all honest nodes in BCUBE must
always have the same block in slot j(cid:48) once the OVERLAYBB
invocation for slot j(cid:48) has completed.
Proof. Consider any given j(cid:48) where 1 ≤ j(cid:48) ≤ j. Then Zλ(j)
occurring means that the committee for slot j(cid:48) has some honest
member. For any given node, the j(cid:48)-th block in its blockchain
is simply the return value of the OVERLAYBB invocation on
that node for the j(cid:48)-th slot. By Theorem 1, such return value
must be the same on all honest nodes.
Theorem 2 guarantees the safety of BCUBE in “good”
executions, but does not tell us the likelihood of the execution
being “good”. Theorem 3 next shows that conditioned upon the
execution being “good” up to slot j − 1, with high probability,
it continues to be “good” up to slot j. Theorem 3 is based on
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:36:30 UTC from IEEE Xplore.  Restrictions apply. 
101272
the weak PoW difﬁculty so that
the following parameterization of BCUBE: We set T1 through
T5 to match the respective durations in Figure 3, and we
set
the honest nodes on
expectation obtain two PoW solutions from T2 to T3. Changing
these parameters will only affect the two constants “0.86”
and “807” in the theorem. Also, Theorem 3 assumes that the
adversary cannot adaptively corrupt honest nodes. Appendix I
will explain that the negative effect of adaptive corruption is
easily bounded, as long as the adaptivity is sufﬁciently “mild”.
Theorem 3. [“good” execution occurs w.h.p.] Consider any
constant f ≤ 0.99, and any positive integers λ and j. If
Pr[Zλ(j − 1)] > 0.9, then conditioned upon Zλ(j − 1), we
must have:7
0.9(0.86−f τ ) − Pois(807, λ)
Pr[Zλ(j)] ≥ 1−
λf τ
0.9(0.86−f τ ) −
λf m
= 1 − λe−Ω(m) − λe−Ω(τ ) − e−Ω(λ)
Here Pois(807, λ) is deﬁned to be Pr[X > λ], where X
follows a Poisson distribution with mean 807.
Proof. See Appendix I.
Asymptotically, the error probability in the above theorem is
exponentially small with respect to m, τ, and λ, which can all
be viewed as security parameters. As a concrete example, with
f = 0.7, λ = 1000, m ≥ 79, and τ ≥ 91, the above theorem
gives8 Pr[Zλ(j)] ≥ 1− 2−30. Hence we use a committee size
of m = 80 in our later experiments when f = 0.7.
B. Liveness and Throughput of BCUBE
For any given slot, liveness of BCUBE means that BCUBE
should always eventually conﬁrm a block for
that slot.
Throughput simply equals block size times the average number
of blocks conﬁrmed per second. In some sense, throughput
captures the “rate of liveness”, in terms of the number of bits
conﬁrmed per second. Note that each slot in BCUBE has a
corresponding OVERLAYBB invocation, which starts at a pre-
determined time. The following theorem shows that once the
invocation starts, within some well-deﬁned time, we will have
a conﬁrmed block in that slot:
Theorem 4. [liveness guaranteed] At most 2dm + s rounds
(or (2dm + s)δ time with δ being the round duration) after
the start of the corresponding OVERLAYBB invocation for a
given slot in BCUBE, all honest nodes in BCUBE must have
a conﬁrmed block in that slot.
Proof. Trivially follows from the fact that Algorithm 1 has
exactly 2dm + s rounds.
Due to space constraint, we defer our throughput analysis
of BCUBE to Appendix II. Appendix II ﬁrst derives an upper
bound on the total number of bits that each honest node
needs to send in each round. This upper bound will hold
7We use Poisson distribution to approximate binomial distributions here.
8Conceptually, Theorem 2 focuses on the error probability of a given
committee (i.e., for the jth slot) in BCUBE. This is consistent with other
analysis in the literature [18], [19], [21], [35]. If needed, one can easily
translate such guarantees to the entire execution.
under all possible strategies of the adversary and all possible
randomness outcomes. Using this upper bound, Appendix II
then shows that, under practical parameters, BCUBE has a
w ) and a TTB ratio of R ≈ Θ( 1
throughput of T ≈ B
B
w ).
VIII. IMPLEMENTATION AND EXPERIMENTAL RESULTS
2w = Θ(
Implementation. We have implemented BCUBE in Go and
using TCP, except the following parts that have no effects
on our experimental results: Since beacon generation from
the weak PoW takes one epoch (e.g., one day), we did not
implement the weak PoW or propagate the PoW solutions.
(Propagating the PoW solutions has negligible cost, since
each node only sends/relays one 20-byte PoW solution in
each epoch.) We instead directly inject a random beacon. We
still properly determine various parameters, such as committee
size, based on our weak PoW design. We did not implement
transactions, and we ﬁll each block with random bits. There
is no stake transfer, and each node always holds one stake
(coin). Finally, we will run up to 500 BCUBE nodes on
each physical machine. Due to CPU constraint, we did not
implement aggregate signature signing/validation, and also did
not implement secure hash function. We replace all of these
with dummy functions. Appendix III will show, via a careful
calculation, that regardless of the strategy of the adversary
and regardless of what messages the malicious nodes may
send to the honest nodes, under all settings in this section,
in every second each honest BCUBE node only needs to do
at most 152 aggregate signature signing/validation operations,
and at most 610 secure hashes (for Merkle proof veriﬁcation).
Similarly, due to memory constraint, the 500 BCUBE nodes
on the same machine are implemented as separate threads in
one Go process, instead of as 500 separate Go processes. Of
course, these threads do not interact with each other via the
shared heap space.
Experimental settings. We run our experiments on 21 high-
end PCs, each with 10Gbps bandwidth, in a local-area net-
work. The ﬁrst PC runs a single BCUBE node (with the maxi-
mum degree of 42 — see later). Each of the remaining 20 PCs
run 500 BCUBE nodes (with the last PC running 499 nodes),
so that each BCUBE node has about 20Mbps bandwidth.