本地和远程图像库及其相关文件传输机制变成了一项相当艰难的任
务。但当它完成之后，整个系统向服务器上传图像的速度比从存储
卡中读取的速度更快。下载到另一台机器的速度也相当快，用户根
本注意不到背后的操作。在从一个屏幕转到另一个屏幕时，客户可
以下载整个相册的所有缩略图。
下载屏幕大小的图片尺寸的图像进行完整显示是在点击鼠标时进行
的。这样的速度让用户不必费时等待“加载中"对话框。
4.3.5数据库迁移
想象一下操作600个远程数据库服务器，它们跨了4个时区。它们也
可能在一个荒凉的小岛上，而且从数字化的角度来说，它们就是如
此。如果数据库管理员需要手工进行变更，他就必须走遍儿百个地
方。
在这种情况下，一种选择就是在第一次发布之前将数据库设计做得
完美无缺，然后再也不改动它。也许还有一些人认为这是可能做到
953
---
## Page 955
的，但我们团队中的成员肯定都不是这样想的。我们预期在各个层
面上都会发生变更，包括数据库，我们甚至盼望着这些变更。
另一种选择就是将发行版声明送到现场。在执行安装时，照相馆经
理总是会打电话到服务台，要求一步步的电话指导。也许我们可以
将SQL脚本包含在发行版的CD中，让他们输入或复制/粘贴。想到
指导他们输入命令时要从“现在输入mysqladmin-uroot-p..."开始，
我就感到背脊发凉。
最后，我们决定进行自动化数据库更新。RubyonRails称之为“数据
库迁移”，但在2005年，这还不是一项常见的技术。
将更新作为对象
照相馆的服务器定义了一个bean，名为“数据库更新器”。它保存了
一组数据库更新对象，每个对象代表了对数据库的一次原子变更。
每个数据库更新对象知道它自己的版本，也知道如何作用于数据
库。
在启动时，数据库更新器检查一个表，得知数据库当前的版本。如
果它没有找到该表，它就认为没有更新或更新还没有执行。因此，
第一次更新将建立这个版本表，并在其中填入一行数据。这行数据
包含了一个版本号和一个锁字段。为了避免并发更新，数据库更新
器首先会更新这一行，设置锁字段。如果不能设置，那它就认为网
络中有别的机器止在执行更新。
我们使用这个迁移功能来执行一些简单的更新和复杂的更新。有一
次简单的更新只是为一些影响性能的列加上索引。有一次更新让我
们很紧张，它要将所有表的类型从MyISAM改为InnoDB。
（MyISAM是默认的表类型，不支持事务和引用完整性。而ImnoDB
支持。如果我们在发布第一个版本之前就知道这一点，我们并始就
会使用InnoDB。）由于我们已经部署了带有生产数据的数据库，所
以必须使用一系列的"altertable"语句。它工作得很好。
在送到现场的几个发行版中，我们大约进行了10次更新。没有一次
失败。
日常工作
954
---
## Page 956
每次我们执行构建时，都会将本地开发数据库恢复到版本0，然后
向后升级。这意味着我们每天都会将升级机制执行数十次。
我们还对每次数据库更新进行单元测试。每个测试都会在更新之前
对数据库的状态做出一些断言。然后它执行更新，再对之后的状态
做出一些断言。
当然，这些测试都是针对“好行为"的数据进行的。但现场会发生奇
怪的事情，真实的数据总是比任务测试数据集更乱。我们的更新会
创建表，添加索引，填充数据行，以及创建新列。如果数据不是我
们期望的那样，有时候这些变更会导致糟糕的结果。由于我们担心
更新时的这种风险，所以要寻找一些方法让这个过程更可靠。
安全特性
假定在一次更新中出了一些问题。照相馆就会关门歇业，直到经营
者找到一种方法来恢复数据库。如果更新真出了问题，就会让数据
库处于某种冲突状态或中间状态。这样照相馆甚至都不能回到应用
的前一个版本。为了避免这种灾难性的场景，数据库更新器在开始
执行升级之前会先对数据库进行备份。如果不能够完成备份，它就
会停止更新过程。如果在更新时发生错误，更新器会自动尝试装入
原来的备份。如果这一步也失败了，那么至少还留有一个备份，技
术支持人员会告诉照相馆经理进行手工恢复。
实际上，在最坏的情况下，打印工厂总有数据库的一份副本，它与
最新数据库的差异不会超过一天。我们使用每日DVD的空闲空间来
发送数据库的完整副本。这要求数据库较小而存储空间很多。
现场效果
我们花在自动化数据库更新上的时间有几个方面的回报。首先，我
们通过一些早期的更新改进了性能和可靠性。在那个发行版之后，
用户的积极反馈马上就来了。其次，运维小组非常喜欢容易部署新
版本这个特征。以前的系统要求照相馆来回寄送可移动硬盘，这自
然会伴随所有物流方面的问题。最后，有了这种更新机制，我们就
可以关注于“刚好够”的数据库设计。我们不会预测未来，也不会过
度设计数据库schema。相反，我们只设计足够的schema，支持当前
的开发选代。
4.3.6不可修改的数据和处处使用的GUID
955
---
## Page 957
照相馆合伙人与客户一起，创建一些构图，利用多张照片插入某个
设计之中。这些设计来自于公司总部的一个设计小组。一些设计是
长期的，另一些设计是季节性的。各种设计的圣诞卡销量很大，至
少在圣诞节之前的几周内。一旦过了圣诞节，需求就直线下降了。
一个具体的设计包含了一些作为背景的图像，还包含了一段描述，
说明有多少空位放基本的图像以及这些空位的几何形状。合伙人可
以非常创造性地用照片或其他构图来填充这些空位。
在处理这些设计和放入其中的基本图像时，我们遇到了一些有趣的
挑战。例如，在客户下了订单之后，该设计的新版本又发到了照相
馆，会产生什么情况？从较小的范围来说，如果合伙人将一个设计
嵌套在另一个设计之中（例如将一张深褐色调的照片放在一个边框
里），然后又改变或删除了原来的设计，你会怎么办？
最初，这看起来像是一个引用计数或隐式链接的梦。我们考虑的
每一个创建对象引用网的策略都会导致间断丢失图像或让人吃惊的
变化。作为一个团队，我们都相信“最小吃惊法则”，而隐式链接会
导致变更从一个产品波及另一个产品，所以不会有好结果。当我们
得到了大家的一致赞同。这个解决方案包括两条规则：
1.在创建之后就不要改变。设计和构图是不可修改的。
2.复制原来的设计，不要引用。
把这两条规则结合在一起，这意味着选择一个设计实际上就是把这
个设计复制到了工作空间。如果合伙人把由此产生的构图加到了相
册中，那么它就是添加的设计的一个完整的、自包含的副本。同
样，将一张处理过的图像嵌套在另一个图像中也会将原来的图像复
制并组合到新的构图中。从组合发生之时开始，原来的构图和新的
构图就是完全相互独立的。这些副本不只是内存中对象引用的一个
技巧。对构图的实际XML描述也包含了完整的设计副本或嵌入的构
图。这个描述存在于照相馆的数据库中，与DVD中发送的描述是一
样的。当照相馆经理将当天的订单刻成DVD时，StudioServer就将创
建最终效果所需的全部内容都进行打包：源图像、背景、alpha遮
罩，以及如何将它们组合成最终图像的指令。在DVD上包含整个构
图的完整描述（包括设计本身）为生产带来了很大的好处。
956
---
## Page 958
以前的系统将设计保存在一个库中，订单通过ID来引用设计。这意
味着设计者必须同步照相馆和集中式打印工厂的所有设计ID。所
以，设计必须先在生产系统中"注册”，然后才能分发到照相馆。一
旦ID没有同步（这种情况有时会发生），错误的设计就会打印出
来，客户就不会拿到他们期望的照片。同样，不论设计者何时更新
一个设计，可能有几关的DVD使用了该设计的老版本。有时候效果
很好，有时候不好。
在新系统中，设计永远不需要注册。进入XML中的内容就会打印出
来，这让设计者可以自由地进行更频紧的更改，并随时分发设计。
新版本的设计不会影响到已有的订单，因为每份订单都是自包含
的。当新版本到达照相馆时，它就会开始出现在订单流程中。唯一
不复制的是图像文件本身。它们太大了，所以我们为每个图像（不
论是设计的一部分还是照相馆中拍摄的图像）分配了一个GUID。作
为一项规定，当图像得到一个GUID后，它就不可修改了。在准备将
订单刻录到DVD上时，StudioServer会遍历订单收集GUID（利用有
争议的Visitor模式）。它将找到的每个图像添加到DVD中，包括客
户的照片和设计背景。
4.3.7渲染工厂
StudioClient帮助合伙人利用基本图像创建增强的肖像。这些增强的
肖像可以是简单的深褐色效果或黑白效果，目的是让肖像看起来更
戏剧化，也可以是复杂的多层结构，带有alpha遮罩的背景、文字和
柔焦。不论是哪种效果，照相馆的工作站都不会得到最终渲染的图
像。打印工厂拥有各种打印机，支持不同尺寸和分辨率。他们可以
自由地更换打印机或在任何时候将任务移到其他打印机上。照相馆
对于如何得到打印好的图像了解得并不多。
当那些每日生成的DVD到达时，它们被载入生产控制系统
（PCS）。PCS负责做出所有决定，包括何时为订单渲染图像，何
时打印，使用哪一台打印机打印等。另一个独立的团队负责开发
PCS，他们处于另一个时区的某个地点。以前的项目试图与PCS紧
密集成，这导致了大量的冲突。所有团队都怀着良好的意图在工
作，但沟通的困难让各个团队都慢了下来。我们需要避免这种冲
突，所以我们决定主动应用Conway法则（在下一节中定义），在软
件中明确创建一个接口，让大家知道团队工作的边界在哪里。
增量式架构
957
---
## Page 959
在敏捷社区中一个反复出现的问题就是：“你应该事先创建多少架
构？”某些杰出的敏捷思想家会告诉你：“一点也不需要。无情地重
构，然后架构就会出现。"我还没有达到这个境界。
重构在不改变代码功能的前提下改进了代码的设计。但是，要通过
重构得到更好的设计，首先你必须知道好的设计和不好的设计。我
们有一组不错的“代码味道”来指导我们，但我们不知道相应的“架构
味道”。其次，必须有可能持续地改进，甚至跨越接口边界。这总
是让我相信系统的基本架构必须在开始开发时就确定好。
现在，在CreationCenter项目之后，我对这个答案的信心减弱了不
少。我们在项目较晚的时候加入了一些主要的架构组成部分。下面
是一些例子：
Hibermate：在两三次迭代之后加入。在此之前我们不需要数据库。
Spring：在第一个发行版进行到大约三分之一时加入。它很快就成
为了我们架构的中心。我不记得在没有它时我们是如何工作的，但
情况确是如此。
FIT：在第一个发行版进行到大约一半时加入。
DVD刻录软件：在初始开发快结束时购买并加入。
支持分窗口的UI：在发布前最后两次选代中加入。
在每一种情况下，我们都会先探索所有可能性，然后再做决定。我
们会在“最后可能的时刻”做出决定，即不做决定的代价超过了实现
该特征的代价。尽管如果一开始就用Spring，有些事情我们可能会
做得不一样，但在后来加入它也没有让我们受苦。在早期的选代
中，我们关注的是发现应用想成为什么样子，而不是Spring希望我
们如何构建应用。
应用Conway法则
Conway法则常常在事后被人提起，来解释那些产品中看起来似乎很
随意的决定。它说出了有关开发团队的基本事实：在所有团队的边
界，你会发现软件的边界。这是因为需要沟通接口而导致的。
958
---