具前已有全面测试的测试套件来检测到它的问题。在从Python2过渡
到Python3的大规模混乱代码改动中，我们定期运行Valgrind，以确
保在每一个阶段没有太多错误。由于我们已经运行这些工具并修复
其发现的问题，稳定性和巩固性对Python不是问题。由于我们长期着
眼于测试和使用工具，尽管Python的使用以数量级增加，用户报告的
问题却没有随之按数量级增长。
有儿个重度使用Python的大公司有自己的独立运行的代码审计系统来
保证安全问题。他们每次发现少数的问题。这归功于Python使用静态
和动态分析工具来保证质量，以及Python社区提供的测试。
在2008年，Fusil[LZ]出现了。Fusil是一个模糊测试工具，它调用公
共函数时根据接口的限制使用半随机的参数。基于这些API参数，压
力测试会使用可能导致问题的参数值，并验证系统在此情况下会不
会崩溃。例如，audioop.findmaxO由于没有检查其第二个参数为负
值，而导致崩溃。Fusil会按如下方式调用此接口：
1947
---
## Page 1949
audioop.fndmax("join(chr(x)for x in xrange(256)),-2392392)
并发现了崩溃，这是在r64775。[8]Fusil可以不费力就能找到这样的
情况，这带给我们的好处是我们可以把时间用来修改代码，而不是
用来审计代码以发现问题。模糊测试工具不能替代安全审查，但它
可以提供有价值的信息，以确定可能对应用程序产生的威胁。
静态分析
静态分析9是一种技术，它使用程序来对源代码进行分析，以找
到潜在的问题。它类似于一个自动的代码审查。[20]Lint和编译器警
告是静态分析的两个例子。静态分析可以用来寻找代码格式问题，
但主要使用它的原因是找到微妙的问题。通常，这些问题都发生在
罕见的情况下，如错误条件（即在最坏情况下，使问题变得更糟
糕）。
例如，静态分析可以在错误处理代码中找到无效的内存使用或内存
泄漏。很多时候，它能发现很少出现的崩溃的问题，或很难重现的
崩溃。相比之下，动态分析有利于在代码中发现已经有测试用例的
问题。静态分析是一个很好的补充和在代码中发现不会被执行的问
题。这可以使系统更健壮，即使在意外情况出现。静态分析也可用
于查找执行不到的代码。除了它能发现过程内部编译器警告的问题
外，它还通常着眼于过程间的问题。
Python使用许多不同的静态分析工具。编译器的警告已被长期使用，
它们帮助避免平台依赖，并确保Python能支持尽可能多的平台。
有些工具，像grep、awk、cut[2L]和（gasp!）Perl，可以用来发现问
题。Python有一个C的APII22]，允许程序调用它。它是这样运作的，
CAPI用"Py"前缀的所有标识符，以避免名称冲突。每隔一段时间，
一些内部使用的API，并不具备"Py"为前缀已被错误地作为公共
API。这种错误命名的功能调用可以通过查看生成库函数很容易地发
现，命令是：nmlibrarylegrep-vPy..。这比解析代码要简单得多。
有几种静态分析工具，包括开源工具和专有工具，可用于许多语
言。Python主要运用在C和Python中。Coverity和Klocwork已经运行它
们的工具在Python代码库中的C的代码部分。我们还使用pychecker
1948
---
## Page 1950
[23]和pylint[24]来针对Python代码部分，因此能在任何人注意到问题
之前发现并解决问题。
有人可能会觉得浪费或多余使用多种工具来做同样的事情。但是我
们发现，尽管约一半的问题被两个工具同时发现，但是其他一半是
不同的。在运行Coverity并修复约50个问题之后，另外50个不同的问
题是通过Klocwork发现的。运用多种工具有利于帮助寻找尽可能多
的问题。当从Python调用C函数时，Python把参数包装在一个元组
里。C函数然后需要解析此元组为C本身的可操作的整数和字符。为
了使这一过程更方便，我们提供了一个叫PyArg_ParseTuple([25]的
函数，它操作起来很像C里的scanf)[26功能。一个例子调用如下所
示：
Py_ssize_t count=-1;
PyObject *from,*to;
if(!PyArg_ParseTuple(args,"OO(n:replace",& from, & to, & count)
return NULL;
1
如果from、to或count有与格式字符串不同的类型，PyArg_ParseTuple
可把垃圾（无效值）写入内存，并导致崩溃，或者更糟地造成一个
安全漏洞。我们应该有足够的单元测试，以支持任何特定平台，但
类型可以在不同的平台上变化，这将使代码移植很困难。例如，在
32位平台，Py_ssize_t是32位，所以即使有人使用格式字符串的字符
为一个整数或长整数，程序仍会工作。在64位平台，Py_ssize_t将是
64位，但是整数仍然是32位，而长整数可以是32或64位。这些不一
致会导致Python在某些开发人员的机器上出错，或者更糟的是，在我
们发布Python后，只在一些用户的机器上出错。为了确保Python不论
在什么平台上都工作，我们也可以使用静态分析来检查
PyArg_ParseTuple使用完全正确的类型。幸运的是，gcc已经有一个
1949
---
## Page 1951
类似的分析检查工具来确认printfO和scanfO的参数。其中一位Python
开发人员修改这个gcc工具使它同时也检查PyArg_ParseTuple，结果
发现了几个问题，这使我们确信类似问题不再在代码库隐藏。
[1] http://docs.python.org/dev/reults.
[2] http://www.python.org/dev/faq/#how-to-test-a-patch.
[3] http:/buildbot.net/trac
[4] http://www.python.org/dev/buildbot/.
[5] http:/snakebite.org/.
[6] http:/mail.python.org/pipermail/python-checkins/.
[Z] http://gcc.gnu.org/
[8] http:/mail.python.org/pipermail/python-checkins/2008-
January/064885.html.
[9] http:/mail.python.org/pipermail/python-checkins/2008-
January/065197.html.
[1Q] http:/mail.python.org/pipermail/python-checkins/2008-
January/065228.html.
[11] http://docs.python.org/extending/extending.html#refcounts.
[12] http://www.python.org/dev/faq/#how-do-i-create-a-debug-build-of-
python.
[13] http://docutils.sourceforge.net/rst.html.
[14] http://www.python.org/dev/peps/pep-0101/.
[15]http://www.python.org/dev/peps/pep-0006/和
[16]http://en.wikipedia.org/wiki/Dynamic_code_analysis.
[1Z] http://pypi.python.org/pypi/fusil/.
[18]http://svn.python.org/view?view=rev&revision=64775
[12]http:/en.wikipedia.org/wiki/Static_code_analysis.
[20]http://en.wikipedia.org/wiki/Code_review.
[21]http://en.wikipedia.org/wiki/Unix_utilities.
[22] http://docs.python.org/extending/index.html.
[23]http://pychecker.sourceforge.net/.
[24]http://www.logilab.org/857.
[25] http://docs.python.org/c-api/arg.html.
[26]http://en.wikipedia.org/wiki/Scanf
结论
随着Python从一个规模较小的、不知名的程序语言演变为被全球公司
在生产中使用的语言，我们一直致力维持一个稳定可靠的产品，尽
1950
---
## Page 1952
管Python的开发人员增长和语言本身复杂性的增长都很巨大。没有一
套高质量的测试套件，Python不可能能处理这样大规模的增长，同时
保持高标准的稳定性。很幸运的是，我们在早期就采取了强有力的
检测方法。有了这个前提，就更容易鼓励新人在加入Python社区时写
全面测试代码，因为测试已经是Python文化的重要组成部分。我们
Python社区就是要求这样做的。
我们认为我们已经取得了很好的平衡，从而加强全面的测试方法无
须增加可能阻碍贡献者的不必要的障碍，但这种平衡在整个Python的
生命周期里在发生必要的发展和变化。我们现在在后台运行大量的
测试，责献者可能并不意识到。我们的buildbot帮助我们捕捉不太常
见的平台上的问题，持续地引用泄漏检查器帮助及早发现这些问
题。我们同时运行的静态分析工具（如Coverity和Klocwork）和动态
分析工具（如Valgrind和Fusil）以获得更全面的覆盖。这当中的每一
个测试工具都已经证明自已的价值，能发现那些会被用户发现的问
题。尽管有这些复杂的工具，然而我们仍然依赖于基本的单元测
试。它让一整套的不同类型的测试组合在一起以让我们保持Python的
稳定性。
我们一直在寻找更多的感兴趣的人帮助和加入Python社区开发。总有
一系列的错误需要修复凹或一些用户想要的功能需要增加。如果你
有兴趣，你可以给我们一个补丁。不过，别忘了包括一个测试。
[1] http://bugs.python.org/
第10章测试随机数发生器
JohnD.Cook
根据美的古典定义，能同时展现复杂性和统一性的事物是美丽的，
GeneVeith教授在其著作中通过形容两种绘画来诠释这样的观点山]：
一幅全黑的画具有统一性，但缺乏复杂性；相反地，一幅随意的涂
鸦具有复杂性，却缺之统一性。
米开朗基罗在西斯廷教堂天花板的壁画既具有丰富的内容又不失条
理，同时展现出复杂性和统一性，所以是美的。
1951
---
## Page 1953
很多美的作品由于其复杂性和统一性是比较明显的，所以容易理
解。我认为西斯廷教堂壁画就属于这类作品。但是也有一些作品需
要知识和技巧才能发现其中的复杂性或者统一性。现代爵士乐可能
就属于后一种，它的复杂性是显而易见的，但对于一对没有受过训
练的耳朵，它的统一性则不容易被察觉。随机数发生器的测试更类
似于现代爵士乐，复杂性比统一性更明显。但通过本章节的一些介
绍，其统一性也应当能够被大家所理解。
什么使随机数发生器的测试这么微妙
技术上讲，软件的随机数发生器实际上是“伪"随机数发生器，因为
家都已理解，就把“伪"字去掉直接称之为随机数发生器（Random
NumberGenerator,RNG）。虽然RNG产生的随机数并不是真正意义上
随机的，但还是有一些RNG确实能为各种目的生成几乎与真正的随
机类似的、非常好的随机数序列。但你怎么知道什么时候一个RNG
的输出是一个足够相似于从你所期望的真实随机源中得到的输出
呢？
一个好的RNG能让我们相信它的输出是随机的，只要我们光看输出
而不去让它重新计算。这是我们得到的关于RNG的测试是微妙的第
一个暗示：对于RNG的需求要有度。从一方面讲它的输出应该是不
可预测的，但另一方面讲又是完全可以预测的。测试必须要从用户
应用程序的角度来验证发生器具有正确的特性，而不能被附带的特
性所干扰。
一个好的RNG形成是取决于它怎么被使用。这就是为什么一个发生
器可能从仿真角度讲质量很高但是从加密角度讲非常差。本章将着
眼于统计意义的质量测试，而非加密安全意义的质量测试。
假设我们需要产生位于3和4之间的随机数。如果我们编写一个总是
返回3的程序会怎样？那将不能满足随便一个人对于随机序列的理
解，因为在某种意义上“随机"序列至少应该是不可预测的。随机值
应该是在一定区间内浮动的。那么接下来我们编写一个程序可以输
出这个迁回序列：3，3.1，3.2，..，4，3，3.1，3.2，.。这次
输出有所变化，但仍是可预测的。我们不应该有能力预测到该序列
的下一个值。输出值应当分散在3和4之间，但不是以这么一种简单
方式。这可以被理解为RNG的测试是微妙的另一个原因：不该有办
1952
---
## Page 1954