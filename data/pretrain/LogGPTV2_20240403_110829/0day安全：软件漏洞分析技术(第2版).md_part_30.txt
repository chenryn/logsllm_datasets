---
## Page 177
day
0
5.2.2
2堆的调试方法
安全
想写出漂亮的堆溢出exploit，仅仅知道堆分配策略是远远不够的，我们需要对堆中的重要
：
数据结构掌握到字节级别。
软
本小节将通过调试一段简单的程序，教会您调试堆的方法，并消除您对堆的神秘感，同时
件
验证上节中所讲的部分堆管理策略。
漏
用于调试的代码如下。
洞
分
#include
析
main()
技
术
HL0CALh1,h2,h3,h4,h5,h6;
HANDLE hp:
（第
hp=HeapCreate（0,0x1000,0x10000);
2
_asmint3
版
h1=HeapAlloc（hp,HEAP_ZERO_MEMORY,3);
h2=HeapA11oc（hp,HEAP_ZERO_MEMORY,5);
h3=HeapA11oc（hp,HEAP_ZERO_MEMORY,6);
h4=HeapA11oc（hp,HEAP_ZERO_MEMORY,8);
h5=HeapAl1oc（hp,HEAP_ZERO_MEMORY,19);
h6=HeapA11oc（hp,HEAP_ZERO_MEMORY,24);
//free block and prevent coaleses
HeapFree（hp,0,h1);//freetofreelist[2]
HeapFree(hp,0,h3);//freetofreelist[2]
HeapFree(hp,0,h5);//freetofreelist[4]
HeapFree（hp.0,h4);//coalese h3,h4,h5,1ink the 1arge block to
//freelist[8]
return0;
实验环境如表5-2-1所示。
表5-2-1实验环境
推荐使用的环境
备注
操作系统
Windows 2000虚拟机
请注意分配策略对操作系统非常敏感
编译器
Visual C++ 6.0
编译选项
默认编译选项
VS2003、VS2005的GS编译选项将使实验失败
build版木
release版木
如果使用debug版本，实验将会失败
说明：堆分配算法依赖于操作系统版本、编译器版本、编译选项、build类型等因素，甚至还与虚拟机版本有关。请在实验
前务必确定实验环境是否恰当，否则将得到不同的调试结果。本实验指导中的所有步骤是在一台Windows2000的虚拟机上完成的。
152
---
## Page 178
第
调试堆与调试栈不同，不能直接用调试器Ollydbg、Windbg来加载程序，否则堆管理函数
5
会检测到当前进程处于调试状态，而使用调试态堆管理策略。
喜
调试态堆管理策略和常态堆管理策略有很大差异，集中体现在：
（1）调试堆不使用快表，只用空表分配。
堆
溢
出
攻击），这包括8个字节的0xAB和8个字节的0x00。
利
（3）块首的标志位不同。
用
调试态的堆和常态堆的区别就好像debug版本的PE和release版本的PE一样。如果您做
堆溢出实验，发现在调试器中能够正常执行shellcode，但单独运行程序却发生错误，那很可能
就是因为调试堆和常态堆之间的差异造成的。
断点：_asmint3，然后让程序单独执行。当程序把堆初始化完后，断点会中断程序，这时再用
调试器attach进程，就能看到真实的堆了。
在Windows2000平台下，使用VC6.0编译器的默认选项将上述代码build成release版本。
直接运行，程序会自动中断，如图5.2.3所示。
×
应用程序发生异常urinownsotwa
定取消
图5.2.3通过人工断点中断程序
现在您可以用调试器attach运行中的进程。如果您的默认调试器是Ollydbg，那么直接单
击“取消”按钮将自动打开Ollydbg并attatch进程，并在断点处停下。
debugging”，将会出现如图5.2.4所示的对话框。
单击“MakeOllyDbgjust-in-time debugger”按钮后，再单击“Done”按钮确认操作，这样，
您的默认调试器就会从VC6.0改成OllyDbg了。
如果您偏爱使用VC6.0调试，那也无妨。现在单击程序弹出来的“取消”按钮，Ollydbg
153
---
## Page 179
0
day安全：
Just-in-time debugging
OObgiaJITdebuo
软件漏洞分析技术
MakeOtyObo
Restore oldjutin-time debugo
Altachwthout confmaion
Done
图5.2.4将OllyDbg设置成默认调试器
所有的堆块分配函数都需要指明堆区的句柄，然后在堆区内进行堆表修改等操作，最后完
（第2版）
成分配工作。
注意：malloc虽然在使用时不用程序员明确指出使用哪个堆区进行分配，但如果您逆
向了malloc的实现，您会发现这是因为它已经使用HeapCreateO函数为自己创建了堆区。
通常情况下，进程中会同时存在若干个堆区。其中包括开始于0x00130000的大小为0x4000
的进程堆，可以通过GetProcessHeap（函数获得这个堆的句柄并使用：另外，我们熟悉的内存
分配函数malloc（也有属于自己的堆区，大多数情况下（本例中为0x00410000），这是一个紧
接着PE镜像处0x00430000的大小为0x8000字节的堆。单击Ollydbg中的“M”按钮，可以
得到当前的内存映射状态，如图5.2.5所示。
OlyDhg-heap_debeke-[Mernutyaee]
Mox
lax
oumerSectionCentaing
进程境，可用GetProcassHeep0获得
malloc0函数使用的堆
实验中HeapCroateO所剑建的堆
图5.2.5进程空间中同时存在的多个堆
154
---
## Page 180
第
5.2.3识别堆表
5
章
在程序初始化过程中，malloc使用的堆和进程堆都已经经过了若干次分配和释放操作，里
边的堆块相对比较“凌乱”。因此，我们在程序中使用HeapCreate(）函数创建一个新的堆，通过
堆
溢
调试这个比较“整齐”的堆来理解前边介绍的堆管理策略。
出
当HeapCreateO成功地创建了堆区之后，会把整个堆区的起始地址返回给EAX，在这里是
利
0x00520000。
用
PedramAmini曾经为OllyDbg写过一个用于查看堆块的插件heap_vis，您可以在本章的附
带电子资料中找到这个插件。将“olly_heap_vis.dll”复制到OllyDbg的plugin目录下，重新启
动OllyDbg后，在“Plugins”菜单下就可以使用这个插件了，如图5.2.6所示。
HeapVis
→
图5.2.6用OllyDbg插件观察堆块
heap_vis能够显示出当前内存中的所有堆块及其状态，但似乎这个插件没有很好的区分
freelist和lookaside两种堆表。另外，heap_vis似乎不很稳定，当我们在WindowsXPSP2下使
用时总是存在问题。
我们建议还是直接参照数据结构来观察内存吧，不妨直接在内存区按快捷键Ctrl+G去
0x00520000看看，如图5.2.7所示。
如图5.2.7所标，从0x00520000开始，堆表中包含的信息依次是段表索引（SegmentList）、
虚表索引l（VirtualAllocationlist)、空表使用标识（freelistusagebitmap）和空表索引区。
我们最关心的是偏移0x178处的空表索引区，其余的堆表一般与堆溢出利用关系不大，这
里暂不讨论。
当一个堆刚刚被初始化时，它的堆块状况是非常简单的。
（1）只有一个空闲态的大块，这个块被称做“尾块”。
（2）位于堆偏移0x0688处（启用快表后这个位置将是快表），这里算上堆基址就是
0x00520688。
（3）Freelist[O]指向“尾块”
（4）除零号空表索引外，其余各项索引都指向自己，这意味着其余所有的空闲链表中都没
有空闲块。
155
---
## Page 181
day安全：
段表（eogmenttable）
等信息，这里不讨论
这些是虚分配家
软件漏洞分析技术
引，因为堆刚刚
初始化，没有任
何虚分配记录，
所以全部为0
32字节的
ueagebitmap
（第2版）
Freells0]指向目前堆中唯一的一个
块，即位于偏移0x0688处的（尾块）
空表索引区，总共128对指针用来索引128条空闲双向链表，目前除了零号
空表reeto之外，所有的案引指向自身，也献是说这些空闲链表都为空
图5.2.7在内存浏览器中查看堆块
在观察堆块之前，要向大家介绍一下堆块的块首中数据的含义，这里要感谢Matthew
Conover的共享精神和对我们研究的热情帮助。占用态堆块的结构如图5.2.8所示。
Ox01(bin:00000001)-Busy
0x02(bin:00000010) - Extra present
0x04(bin:00000100)-Fill pattem
Ox0B(bin:00001000)  Virtual Alloc
BUSYHEAPBLOCK
STRUCTURE
0x20(bin:00100000)-FFU1
0x40(bin:01000000)-FFU2
Ox80(bin:10000000)-No coalesce
byte
0
3
Self Size
Previous chunk
utudes
Flags
Unused
Tag
size
Index
bytes
inder
Blockh
(Dobug)
Block body
Data
图5.2.8
占用态堆块的数据结构
156
---
## Page 182
第
空闲态堆块和占用态堆块的块首结构基本一致，只是将块首后数据区的前8个字节用于存
5
放空表指针了，如图5.2.9所示。这8个字节在变回占用态时将重新分回块身用于存放数据。
章
现在直接按快捷键Ctrl+G去0x00520688处看看尾块的状态，如图5.2.10所示。
堆
对照块首结构的解释，我们可以得到以下信息。
溢
（1）实际上这个堆块开始于0x00520680，一般引用堆块的指针都会跃过8字节的块首，直
接指向数据区。
利
用
byte
0
1
2
3
6
7
SellSize
Previouschunk
Flags
Unused
Tag
Block head
size
index
bytes
(00g)
(tngea)
Flink in freelist
Blink in freelist
Block body
Data
图5.2.9空闲态堆块的数据结构
指向freellst[0]
空闲块块首
构成双向链表
（尾块）
图5.2.10在内存中识别堆块
（2）尾块目前的大小为0x0130，计算单位是8个字节，也就是0x980字节。
（3）注意：堆块的大小是包含块首在内的。
注意：如果您足够细心，可能会发现在我们的调试环境中，快表始终为空。按照堆表数
据结构的规定，指向快表的指针位于偏移0x584字节处，在本章所有的实验中，这个指
针均为NULL。这似乎与本章第一节中介绍的堆管理策略有点出入。这是因为只有堆是
可扩展的时候快表才会启用，要想启用快表我们在创建堆的时候就不能使用HeapCreate
（0.0x1000.0x10000）来创建堆了，而要使用HeapCreate（0,0.0）创建一个可扩展的堆。
157
---
## Page 183
day
5.2.4堆块的分配
安全
经过调试，对于堆块的分配我们应该了解以下细节。
（1）堆块的大小包括了块首在内，即如果请求32字节，实际会分配的堆块为40字节：8
软
字节块首十32字节块身。
件漏
（2）堆块的单位是8字节，不足8字节的部分按8字节分配。
（3）初始状态下，快表和空表都为空，不存在精确分配。请求将使用“次优块”进行分配。
洞
分析
这个“次优块”就是位于偏移0x0688处的尾块。
（4）由于次优分配的发生，分配函数会陆续从尾块中切走一些小块，并修改尾块块首中的
技
size信息，最后把freelist[O]指向新的尾块位置。
术
所以，对于前6次连续的内存请求，实际分配情况如表5-2-2所示。
（第
表5-2-2内存请求分配情况
2
堆句柄
版
请求字节数
实际分配（堆单位）
实际分配（字节）
H1
2
16
H2
5
2
16
H3
6
2
16
H4
8
2
16
H5
19
4
32
H6
24
4
32
现在，在OllyDbg中单步运行到前6次分配结束，堆中情况如图5.2.11所示。
h1的块首，大小
%0x0002
h5的块首，大小
为0x0004
尾块的块首
Size=0x0130-0x2*4-0x4*2=0x0120
图5.2.11在内存中识别堆块
为0x120。如果您去0x00520178查看freelist[0]中的空表指针，会发现现在已经指向新尾块的
位置，而不是从前的0x00520688了。
158
---
## Page 184
第
5.2.5堆块的释放
5
章