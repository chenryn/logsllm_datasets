# 33 \| 传统的可扩展架构模式：分层架构和SOA相比于高性能、高可用架构模式在最近几十年的迅猛发展来说，可扩展架构模式的发展可以说是步履蹒跚，最近几年火热的微服务模式算是可扩展模式发展历史中为数不多的亮点，但这也导致了现在谈可扩展的时候必谈微服务，甚至微服务架构都成了架构设计的银弹，高性能也用微服务、高可用也用微服务，很多时候这样的架构设计看起来高大上，实际上是大炮打蚊子，违背了架构设计的"合适原则"和"简单原则"。为了帮助你在实践中更好的进行可扩展架构设计，我将分别介绍几种可扩展架构模式，指出每种架构模式的关键点和优缺点。今天我来介绍传统的可扩展模式，包括[分层架构和SOA]{.orange}，后面还会介绍微服务架构。
## 分层架构分层架构是很常见的架构模式，它也叫 N 层架构，通常情况下，N 至少是 2层。例如，C/S 架构、B/S 架构。常见的是 3 层架构（例如，MVC、MVP架构）、4 层架构，5层架构的比较少见，一般是比较复杂的系统才会达到或者超过 5层，比如操作系统内核架构。按照分层架构进行设计时，根据不同的划分维度和对象，可以得到多种不同的分层架构。1.  C/S 架构、B/S 架构划分的对象是整个业务系统，划分的维度是用户交互，即将和用户交互的部分独立为一层，支撑用户交互的后台作为另外一层。例如，下面是C/S 架构结构图。``{=html}![](Images/a886dceab47930d476d8acf6490261d4.png){savepage-src="https://static001.geekbang.org/resource/image/46/f2/4648b7ffd305afcc34d5f1414f8298f2.png"}\（[http://www.bkjia.com/uploads/allimg/150507/0424434N3-0.png）](http://www.bkjia.com/uploads/allimg/150507/0424434N3-0.png%EF%BC%89)2.  MVC 架构、MVP 架构划分的对象是单个业务子系统，划分的维度是职责，将不同的职责划分到独立层，但各层的依赖关系比较灵活。例如，MVC架构中各层之间是两两交互的：![](Images/156dae928ca619765b0837e52fc0371d.png){savepage-src="https://static001.geekbang.org/resource/image/38/54/380007d08617ff7b212dad52032d6d54.png"}\（[http://upload-images.jianshu.io/upload_images/749674-a1f018df5d05d3b0.png?imageMogr2/auto-orient/strip\|imageView2/2/w/1240）](http://upload-images.jianshu.io/upload_images/749674-a1f018df5d05d3b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240%EF%BC%89)3.  逻辑分层架构划分的对象可以是单个业务子系统，也可以是整个业务系统，划分的维度也是职责。虽然都是基于职责划分，但逻辑分层架构和MVC 架构、MVP架构的不同点在于，逻辑分层架构中的层是自顶向下依赖的。典型的有操作系统内核架构、TCP/IP架构。例如，下面是 Android 操作系统架构图。![](Images/578ef44053b5009c0f4df8cfc6d4b955.png){savepage-src="https://static001.geekbang.org/resource/image/28/eb/28a0789dc7b125fffa36cb1524ff28eb.png"}\（）典型的 J2EE 系统架构也是逻辑分层架构，架构图如下：![](Images/58df96b9c9f2e2e4dba87d5a7bdd9f53.png){savepage-src="https://static001.geekbang.org/resource/image/f6/7a/f696be773849a8a1bd6cd6c6ed86587a.png"}针对整个业务系统进行逻辑分层的架构图如下：![](Images/f56b6a786992d71ceb64a5fa8180d359.png){savepage-src="https://static001.geekbang.org/resource/image/bc/4a/bc3978127300373b919b282e9f37c94a.png"}无论采取何种分层维度，分层架构设计最核心的一点就是**需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构**，这也是分层不能分太多层的原因。否则如果两个层的差异不明显，就会出现程序员小明认为某个功能应该放在A 层，而程序员老王却认为同样的功能应该放在 B层，这样会导致分层混乱。如果这样的架构进入实际开发落地，则 A 层和 B层就会乱成一锅粥，也就失去了分层的意义。分层架构之所以能够较好地支撑系统扩展，本质在于**隔离关注点**（separationofconcerns），即每个层中的组件只会处理本层的逻辑。比如说，展示层只需要处理展示逻辑，业务层中只需要处理业务逻辑，这样我们在扩展某层时，其他层是不受影响的，通过这种方式可以支撑系统在某层上快速扩展。例如，Linux内核如果要增加一个新的文件系统，则只需要修改文件存储层即可，其他内核层无须变动。当然，并不是简单地分层就一定能够实现隔离关注点从而支撑快速扩展，分层时要保证层与层之间的依赖是稳定的，才能真正支撑快速扩展。例如，Linux内核为了支撑不同的文件系统格式，抽象了 VFS 文件系统接口，架构图如下：![](Images/7c454bfcd5a01bad33a6014dbe60dcde.png){savepage-src="https://static001.geekbang.org/resource/image/90/33/9091efc1ffdd034435943ff63c257e33.png"}\（）如果没有 VFS，只是简单地将 ext2、ext3、reiser等文件系统划为"文件系统层"，那么这个分层是达不到支撑可扩展的目的的。因为增加一个新的文件系统后，所有基于文件系统的功能都要适配新的文件系统接口；而有了VFS 后，只需要 VFS 适配新的文件系统接口，其他基于文件系统的功能是依赖VFS 的，不会受到影响。对于操作系统这类复杂的系统，接口本身也可以成为独立的一层。例如，我们把VFS 独立为一层是完全可以的。而对于一个简单的业务系统，接口可能就是 Java语言上的几个 interface定义，这种情况下如果独立为一层，看起来可能就比较重了。例如，经典的 J2EE分层架构中，Presentation Layer 和 Business Layer之间如果硬要拆分一个独立的接口层，则显得有点多余了。分层结构的另外一个特点就是层层传递，也就是说一旦分层确定，整个业务流程是按照层进行依次传递的，不能在层之间进行跳跃。最简单的C/S 结构，用户必须先使用 C 层，然后 C 层再传递到 S层，用户是不能直接访问 S 层的。传统的 J2EE 4层架构，收到请求后，必须按照下面的方式传递请求：![](Images/0df4546c68473482488d228c6aece6d7.png){savepage-src="https://static001.geekbang.org/resource/image/2e/b0/2e6f4df2f1cb215a9c819368103545b0.png"}分层结构的这种约束，好处在于强制将分层依赖限定为两两依赖，降低了整体系统复杂度。例如，BusinessLayer 被 Presentation Layer 依赖，自己只依赖 PersistenceLayer。但分层结构的代价就是冗余，也就是说，不管这个业务有多么简单，每层都必须要参与处理，甚至可能每层都写了一个简单的包装函数。我以用户管理系统最简单的一个功能"查看头像"为例。查看头像功能的实现很简单，只是显示一张图片而已，但按照分层分册架构来实现，每层都要写一个简单的函数。比如：\Presentation Layer：    package layer; /** * Created by Liyh on 2017/9/18. */public class AvatarView {   public void displayAvatar(int userId){       String url = AvatarBizz.getAvatarUrl(userId);        // 此处省略渲染代码       return;   }}Business Layer：    package layer; /** * Created by Liyh on 2017/9/18. */public class AvatarBizz {   public static String getAvatarUrl(int userId){       return AvatarDao.getAvatarUrl(userId);   }}Persistence Layer：    package layer; /** * Created by Liyh on 2017/9/18. */public class AvatarDao {   public static String getAvatarUrl(int userId) {     // 此处省略具体实现代码，正常情况下可以从 MySQL 数据库中通过 userId 查询头像 URL 即可       return "http://avatar.csdn.net/B/8/3/1_yah99_wolf.jpg";   }}可以看出 Business Layer 的 AvatarBizz 类的 getAvatarUrl 方法和Persistence Layer 的 AvatarDao 类的 getAvatarUrl方法，名称和参数都一模一样。既然如此，我们是否应该自由选择是否绕过分层的约束呢？例如，"查看头像"的示例中，直接让AvatarView 类访问 AvatarDao 类，不就可以减少 AvatarBizz 的冗余实现了吗？答案是不建议这样做，分层架构的优势就体现在通过分层强制约束两两依赖，一旦自由选择绕过分层，时间一长，架构就会变得混乱。例如，PresentationLayer 直接访问 Persistence Layer，Business Layer 直接访问 DatabaseLayer，这样做就失去了分层架构的意义，也导致后续扩展时无法控制受影响范围，牵一发动全身，无法支持快速扩展。除此以外，虽然分层架构的实现在某些场景下看起来有些啰嗦和冗余，但复杂度却很低。例如，样例中AvatarBizz 的 getAvatarUrl 方法，实现起来很简单，不会增加太多工作量。分层架构另外一个典型的缺点就是性能，因为每一次业务请求都需要穿越所有的架构分层，有一些事情是多余的，多少都会有一些性能的浪费。当然，这里所谓的性能缺点只是理论上的分析，实际上分层带来的性能损失，如果放到20 世纪 80年代，可能很明显；但到了现在，硬件和网络的性能有了质的飞越，其实分层模式理论上的这点性能损失，在实际应用中，绝大部分场景下都可以忽略不计。
## SOASOA 的全称是 Service OrientedArchitecture，中文翻译为"面向服务的架构"，诞生于上世纪 90 年代，1996 年Gartner 的两位分析师 Roy W. Schulte 和 Yefim V. Natis 发表了第一个 SOA的报告。2005 年，Gartner 预言：到了 2008 年，SOA 将成为 80%的开发项目的基础（）。历史证明这个预言并不十分靠谱，SOA虽然在很多企业成功推广，但没有达到占有绝对优势的地步。SOA更多是在传统企业（例如，制造业、金融业等）落地和推广，在互联网行业并没有大规模地实践和推广。互联网行业推行SOA最早的应该是亚马逊，得益于杰弗·贝索斯的远见卓识，亚马逊内部的系统都以服务的方式构造，间接地促使了后来的亚马逊云计算技术的出现。SOA 出现 的背景是企业内部的 IT 系统重复建设且效率低下，主要体现在：-   企业各部门有独立的 IT    系统，比如人力资源系统、财务系统、销售系统，这些系统可能都涉及人员管理，各    IT    系统都需要重复开发人员管理的功能。例如，某个员工离职后，需要分别到上述三个系统中删除员工的权限。-   各个独立的 IT    系统可能采购于不同的供应商，实现技术不同，企业自己也不太可能基于这些系统进行重构。-   随着业务的发展，复杂度越来越高，更多的流程和业务需要多个 IT    系统合作完成。由于各个独立的 IT    系统没有标准的实现方式（例如，人力资源系统用 Java 开发，对外提供    RPC；而财务系统用 C
# 开发，对外提供 SOAP    协议），每次开发新的流程和业务，都需要协调大量的 IT    系统，同时定制开发，效率很低。为了应对传统 IT 系统存在的问题，SOA 提出了 3 个关键概念。1.  服务所有业务功能都是一项服务，服务就意味着要对外提供开放的能力，当其他系统需要使用这项功能时，无须定制化开发。服务可大可小，可简单也可复杂。例如，人力资源管理可以是一项服务，包括人员基本信息管理、请假管理、组织结构管理等功能；而人员基本信息管理也可以作为一项独立的服务，组织结构管理也可以作为一项独立的服务。到底是划分为粗粒度的服务，还是划分为细粒度的服务，需要根据企业的实际情况进行判断。2.  ESBESB 的全称是 Enterprise ServiceBus，中文翻译为"企业服务总线"。从名字就可以看出，ESB参考了计算机总线的概念。计算机中的总线将各个不同的设备连接在一起，ESB将企业中各个不同的服务连接在一起。因为各个独立的服务是异构的，如果没有统一的标准，则各个异构系统对外提供的接口是各式各样的。SOA使用 ESB来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。3.  松耦合松耦合的目的是减少各个服务间的依赖和互相影响。因为采用 SOA架构后，各个服务是相互独立运行的，甚至都不清楚某个服务到底有多少对其他服务的依赖。如果做不到松耦合，某个服务一升级，依赖它的其他服务全部故障，这样肯定是无法满足业务需求的。但实际上真正做到松耦合并没有那么容易，要做到完全后向兼容，是一项复杂的任务。典型的 SOA 架构样例如下：![](Images/e3b4aae7a2a9890ba131c07699fb2977.png){savepage-src="https://static001.geekbang.org/resource/image/16/ac/16bea450ce18ad08b7f12c38608850ac.png"}\（[http://images.cnitblog.com/blog/33907/201406/282330448671388.png）](http://images.cnitblog.com/blog/33907/201406/282330448671388.png%EF%BC%89)SOA 架构是比较高层级的架构设计理念，一般情况下我们可以说某个企业采用了SOA 的架构来构建 IT 系统，但不会说某个独立的系统采用了 SOA架构。例如，某企业采用 SOA架构，将系统分为"人力资源管理服务""考勤服务""财务服务"，但人力资源管理服务本身通常不会再按照SOA 的架构拆分更多服务，也不会再使用独立的一套ESB，因为这些系统本身可能就是采购的，ESB本身也是采购的，如果人力资源系统本身重构为多个子服务，再部署独立的 ESB系统，成本很高，也没有什么收益。SOA 解决了传统 IT系统重复建设和扩展效率低的问题，但其本身也引入了更多的复杂性。SOA最广为人诟病的就是 ESB，ESB需要实现与各种系统间的协议转换、数据转换、透明的动态路由等功能。例如，下图中ESB 将 JSON 转换为 Java（摘自《Microservices vs. Service-OrientedArchitecture》）。![](Images/adbeba919c96c08cd49fb3db0264d02e.png){savepage-src="https://static001.geekbang.org/resource/image/5b/97/5b8ac0909b37cdca82a3b4a7f344fa97.png"}下图中 ESB 将 REST 协议转换为 RMI 和 AMQP 两个不同的协议：![](Images/aea1f349e25f244b62e3207370998636.png){savepage-src="https://static001.geekbang.org/resource/image/27/f5/271f451df87883c0a45cceff8a7fbff5.png"}ESB 虽然功能强大，但现实中的协议有很多种，如 JMS、WS、HTTP、RPC等，数据格式也有很多种，如 XML、JSON、二进制、HTML 等。ESB要完成这么多协议和数据格式的互相转换，工作量和复杂度都很大，而且这种转换是需要耗费大量计算性能的，当ESB 承载的消息太多时，ESB 本身会成为整个系统的性能瓶颈。当然，SOA 的 ESB 设计也是无奈之举。回想一下 SOA的提出背景就可以发现，企业在应用 SOA 时，各种异构的 IT系统都已经存在很多年了，完全重写或者按照统一标准进行改造的成本是非常大的，只能通过ESB 方式去适配已经存在的各种异构系统。
## 小结今天我为你讲了传统的可扩展架构模式，包括分层架构和 SOA架构，希望对你有所帮助。这就是今天的全部内容，留一道思考题给你吧，为什么互联网企业很少采用 SOA架构？欢迎你把答案写到留言区，和我一起讨论。相信经过深度思考的回答，也会让你对知识的理解更加深刻。（编辑乱入：精彩的留言有机会获得丰厚福利哦！）![](Images/f2eae62fce5bba3ca5ee38d11da01862.png){savepage-src="https://static001.geekbang.org/resource/image/ba/37/ba6fcd186893b8cc9977d18e1fa5ab37.jpg"}