// Pick the next random μi,0, μi,1 and
// compute random linear combination (§3.2)
μi,0, μi,1
ai ← X
μ
(q
(cid:16)
i
SendToProver(μi,0, μi,1)
// Receive commitments to the rows of the matrix T
(T0, . . . , T|w|1/ι ) ← ReceiveFromProver()
b N ← log N, bG ← log G
(q
, q0, L) R←− Fb N × FbG
(cid:16)
0
μ0,0 ← 1, μ0,1 ← 0, q0, R ← q0, L
a0 ← Com( ˜Vy(q
, q0,0); 0)
(cid:16)
0
SendToProver((q
, q0,0))
(cid:16)
0
d ← c.depth
1: function Hyrax-Verify(ArithCircuit c, input x, output y, parameter ι)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33:
34:
35:
36:
37:
(cid:16)
38: function ZK-SumCheckV(layer i,ai−1, q
i−1
(cid:16), rL, rR) R←− Flog N × Flog G × Flog G
(r
39:
r ← (r
40:
41:
for j = 1, . . . , log N + 2 log G do
αj ← ReceiveFromProver()
42:
SendToProver(r[j])
43:
(X, Y, Z) ← ReceiveFromProver()
44:
// X = Com(v0), Y = Com(v1), Z = Com(v0v1)
45:
// V computes {Mj } as deﬁned in Equation (5)
46:
proof-of-sum-check (ai−1, {αj }, {Mj }, X, Y, Z) // see Figure 1
47:
return (Com(v0), Com(v1), r
48:
Figure 10—Pseudocode for V in Hyrax-I (§7). P’s work is described
in Figures 9 and 11. For notational convenience, we assume |x| = |w|,
as in Section 6.1.
// For the ﬁnal check, reduce from two points to one point (§3.2)
(Com(H0), . . . , Com(HbG
for i = 0, . . . , bG do
proof-of-opening (Com(Hi))
proof-of-equality (Com(H0), X)
proof-of-equality (Com(HbG
τ R←− F
SendToProver(τ)
qd ← (r
(cid:16) ←|w|1/ι−1
ζ = Com(HbG
R ← ( ˆχ0, ˆχ|w|1/ι , . . . , ˆχ|w|1/ι·(|w|1/ι−1))
(1−qd
prooflog-of-dot-prod (T
return accept
// ˆχb is deﬁned in Section 6
[0]) ˜Vx (qd
−1]), R)
// αj is Com(sj); see Lines 19,47 of Figure 11
−1)τlog G−1 (cid:14) . . . (cid:14) Com(H0)
)τlog G (cid:14) Com(HbG
(cid:16), (1 − τ) · rL + τ · rR)
) (cid:14) . . . (cid:14) Com(H0), Y)
// ˇχb is deﬁned in Section 6
// see Lines 20,48 of Figure 11
// see Line 52 of Figure 11
// see Line 23 of Figure 9
// see Line 18 of Figure 9
, qi−1, L, qi−1, R)
(cid:16), rL, rR)
(cid:16), rL, rR)
[0], ζ (cid:19) g
[1, ..., b N
ˇχ
T
i
(cid:16)qd
+bG
i=0
T
i
− j
, r
r
r

(cid:16)
i−1
// notation
(cid:16) ← (r
(cid:16)[b N])
(cid:16)[1], . . . , r
, qi−1, L, qi−1, R
μi−1,0, μi−1,1, q
// see Line 43 of Figure 10
// see Line 42 of Figure 10
for j = 1, . . . , b N do
sj[k] ←
g∈{0,1}bG sj[σ, g][k]
// gL, gR are labels of g’s layer-i inputs in subcircuit
if g is an add gate then
else if g is a mult gate then
for k ∈ {−1, 0, 1, 2} do
σ∈{0,1}b N
μi−1,0 · χg(qi−1, L) + μi−1,1 · χg(qi−1, R)(cid:15)
// Compute coeﬃcients of sj and create a multi-commitment (§5)
SendToVeriﬁer(Com(sj))
(cid:16)[j] ← ReceiveFromVeriﬁer()
(cid:16)[j − 1], k, σ[1], . . . , σ[b N − j]) ·
(cid:16)[j − 1], k, σ[1], . . . , σ[b N − j], gL)
(cid:16)[j − 1], k, σ[1], . . . , σ[b N − j], gR)
sj[σ, g][k] ← termP · (termL + termR)
sj[σ, g][k] ← termP · termL · termR
for j = 1, . . . , 2bG do
// In these rounds, prover sends commitment to degree-2 polynomial sb N
for all gates g ∈ {0, 1}bG and k ∈ {−1, 0, 1} do
s ← (g, gL, gR)
uk,0 ← (qi−1, L[1], . . . , qi−1, L[bG], r[1], . . . , r[j−1], k)
uk,1 ← (qi−1, R[1], . . . , qi−1, R[bG], r[1], . . . , r[j−1], k)
termP ← (cid:17)eq(q
// In these rounds, prover sends commitment to degree-3 polynomial sj
for all σ ∈ {0, 1}b N
− j and g ∈ {0, 1}bG and k ∈ {−1, 0, 1, 2} do
s ← (g, gL, gR)
termP ← (cid:17)eq(q
// gL, gR are labels of g’s layer-i inputs in sub-circuit.
(cid:14)
(cid:16)[1], . . . , r
(cid:16)
, r
i−1
termL ← ˜Vi (r
(cid:16)[1], . . . , r
termR ← ˜Vi (r
(cid:16)[1], . . . , r
1: function ZK-SumcheckP(ArithCircuit c, layer i, ai−1,)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33:
34:
35:
36:
37:
38:
39:
40:
41:
42:
43:
44:
45:
46:
47:
48:
49:
50:
51:
52:
53:
54:
55:
56:
Figure 11—P’s side of the zero-knowledge sum-check protocol in
Hyrax-I (§7).
r0 ← (r[1], . . . , r[bG])
v0 ← ˜Vi(r
SendToVeriﬁer(X, Y, Z)
// P computes {Mk } as deﬁned in Equation (5).
proof-of-sum-check (ai−1, {Com(sj)}, {Mk }, X, Y, Z) // see Figure 1
return (Com(v0), Com(v1), r
(cid:16), r[1], . . . , r[j − 1], k, gL[j+1], . . . , gL[bG])
(cid:16), gR)
// bG < j ≤ 2bG
(cid:16), r[1], . . . , r[bG])
(cid:16), r[bG +1], . . . , r[j−1], k, gR[j−bG +1], . . . , gR[bG])
if j ≤ bG then
termL ← ˜Vi (r
termR ← ˜Vi (r
else
termL ← ˜Vi(r
termR ← ˜Vi (r
+ j[g][k] ← termP · (termL + termR)
+ j[g][k] ← termP · termL · termR
sb N
// Compute coeﬃcients of sb N
SendToVeriﬁer(Com(sb N
+ j))
r[j] ← ReceiveFromVeriﬁer()
if g is an add gate then
else if g is a mult gate then
// see Line 42 of Figure 10
// see Line 43 of Figure 10
μi,0 ·bG
μi,1 ·bG
s[(cid:3)](uk,1[(cid:4)])(cid:15)
+ j and create a multi-commitment (§5)
+ j[k] ←
for k ∈ {−1, 0, 1} do
(cid:16), r0) v1 ← ˜Vi(r
// see Line 44 of Figure 10
s[(cid:3)](uk,0[(cid:4)]) +
g∈{0,1}bG sb N
+ j[g][k]
(cid:16)) · (cid:14)
(cid:16), r0, r1)
(cid:16)
i−1
sb N
+ j
χ
+ j
χ
(cid:3)=1
(cid:3)=1
+ j .
sb N
r1 ← (r[bG + 1], . . . , r[2bG])
(cid:16), r1) // X = Com(v0), Y = Com(v1), Z = Com(v0v1)
// notation
943
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:29:14 UTC from IEEE Xplore.  Restrictions apply.