read i i r i l r ~ w  
read  vnlee\ec 
Mapped File 
cih  - 
crh  - 
[heap1 - 
me1hodr.k  so  I 
methods-Lo  SQ I 
llbi IO I 
llbcso I 
[anon 1 
L anM 1 
Lo sa I 
loro I 
Iibc.prrso  I 
llbmapmallocro I 
libmapmallocro  I 
libdl so  I 
Id  so I 
Id io I __ 
[ s l a c i ]  - 
Fig 1 : Process map 
,,,~,,, J 
272 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:05:53 UTC from IEEE Xplore.  Restrictions apply. 
I 
Resewed 
I 
\
I
I 
I 
I 
New Procedure  +-*.I 
Unmapped  Area 
Stack 
Address space 
I 
i  OidProcedure 
I 
Old euecutable file 
1  New Procedure 
I 
I  .IS  I  - 
New executable file 
Fig 2:  Concept of dynamic procedure update 
Consider an environment in which  a process executes an 
(old  version)  executable  file  (Figure  2).  Suppose that  the 
vendor  of  the  software  changes  the  source  code  of  a 
procedure  ("Old  Procedure"  in  the  figure) to add a feature 
and subsequently releases a new version  of executable file 
to users. Now  a user wants to  update the running software 
dynamically  to  incorporate  this  change.  Since the  size  of 
the procedure to update can increase or decrease as a result 
of the change, what we can do is to extract the new version 
of the procedure and map the procedure into the unmapped 
area  of  the  running  process.  (The  unmapped  area,  which 
lies between heap and stack in Solaris as shown in  Figure  1, 
is an area not  used  by  a process.)  We  can then  modify the 
old  version  procedure  so that  it  simply jumps to the  new 
version  procedure's  location  when  it  is  called  (Figure  2). 
Once  such  an  update  is  made,  when  the  old  version 
procedure  is  called,  the  new  version  procedure  will  be 
executed. 
We can observe a few things. First, the method  is rather 
low-level  and  involves  dealing  with  the  internals  of  a 
running process.  Second, the method  intends to incorporate 
changes in text and local data dynamically. That is, it is not 
applicable (at least now) when static data structures change. 
Third, an update may not  be permanent  in the sense that, if 
a  process  is  stopped  and  restarted,  previous  dynamic 
updates are forgotten and an  off-line software upgrade may 
be necessary. Also, after a number of dynamic updates, the 
memory  image may  become  messy,  and  again  an  off-line 
upgrade  may be necessary. That is exactly what we expect 
to happen. Note that the purpose of the method  is to reduce 
the number  of off-line upgrades. 
To  make  the  above-described  method  work  correctly, 
we  must  address  two  important  issues.  First,  because  the 
sizes  of  old  and  new  procedures  are  not  necessarily  the 
same, the address of an  external  symbol  in the old version 
executable  file  (or  in  old  version  address  space)  can  be 
different  from  that  in  the  new  version.  Note  that,  even  if 
global  data  structures  do  not  change,  the  location  of  a 
global variable  changes as the size of the text area changes 
(Figure  2).  Therefore,  when  the  new  version  procedure 
in  the  old  version  address  space  accesses  an 
mapped 
external  symbol (e.g.,  calls a procedure or accesses a static 
variable),  it will be unable to find a correct one, because it 
uses the address of the symbol  in the new  version  address 
space.  To  make  the  mapped  new  version  procedure  work 
correctly,  we  must  alter  the  external  symbol  references  in 
the new version procedure so that they are compatible with 
the  old  version  address  space.  This  issue  is  discussed  in 
Section 3.3. 
The  second  issue  to  consider  is  that  a  method  for 
dynamic  procedure  update  must  ensure  correct  operation 
and  incur  small  performance  loss. This  issue  is  discussed 
in the next subsection. 
3.2. Update sequence 
Dynamic software update must ensure correct  operation 
of  the  target  software  during  an  update  and  incur  small 
performance  loss.  With  this  requirement 
in  mind,  we 
develop  a  specific  sequence 
to  perform  a  dynamic 
procedure  update  in  this  section.  The  entire  sequence 
consists of four steps (Figure 3). 
The  first  step  of  the  dynamic  update  is  to  extract  the 
information  about  the  locations and  sizes  of  old  and  new 
version  procedures  from the symbol  tables of old and new 
executable files,  respectively.  We also extract  new  version 
I  step  I  : extiact new version procedure 
I 
. check infomiation  in symbol table 
extract new procedure into separate file 
I 
step 2  : map new version procedure 
place  iiew procedure in unmapped area 
get mapped location 
I 
step 3  correct external symbol references 
identify extemal  symbol references 
make them compatable  with old version 
I 
enslire collect Operation 
Fig 3:  Update sequence 
273 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:05:53 UTC from IEEE Xplore.  Restrictions apply. 
[TO] 
[NI 
0110af8 
O\llcd! 
1833  O\IIJ18 
1851 
O\IIflO 
116 
71 
M) 
28 
FUNC 
FUNC 
FUNC 
FUNC 
GLOB 
GLOB 
GLOB 
GLOB 
0 
0 
0 
0 
8 
8 
8 
9 
start 
-regster_frame_infa 
nproc 
j n t l  
Fig 4:  Symbol table 
procedure  into  a  separate  file;  this  file  is  called  a  new 
version procedure file. 
Figure  4  shows  an  example  of  the  symbol  table  in 
Solaris. In the figure, the last column shows symbol  names, 
and  the  second  column  shows  each  symbol's  location  in 
the process  address space (virtual  address value). The third 
and fourth columns show a symbol's size and the type of a 
symbol, respectively. For example, in  Figure 4, we can see 
that  "getloc"  represents  a  procedure,  because  the  fourth 
column says "FUNC." The "getloc"  procedure  is located at 
the  address  of  Ox10da4, and  the  size  of  "getloc"  is  1064 
bytes.  The actual  location  of a procedure  in an executable 
file  can  also  be  determined.  For  example,  since  the  text 
area  in  the  Solaris  process  address  space  starts  at  the 
virtual  address of OxlOOOO (an address range  between  Ox0 
and Oxffff is reserved), the starting address of the "getloc" 
procedure in the executable file is OxOda4. 
The second step of the dynamic update  is  to map a new 
version  procedure  file  to  the  unmapped  area  of  an  old 
version  process  address  space.  In  Solaris,  mapping  a  file 
into  a  process  address  space  can  be  performed  by  the 
mmap  system  call  [12].  However,  the  mmap  system  call 
must  be  made  by  the  process  to  be  mapped.  That  is,  an 
external  process cannot request the service on behalf of the 
target  process.  This  means  that  a  function  to  perform  the 
mapping must be added to the target program. 
We  use  the  signal  mechanism  for the  mapping  (Figure 
lnrgel  process 
signal(int SIGNALI, void'  mem-mapping), 
mem-mappind) 
I 
I* initialize signal '1 
/*  signal handler *I 
addr=mmap((caddr-t)0,  sizet len, (PROT-READ  1  PROT-LXEC) 
, MAP-PRIVATE,  int tildes, O), 
/* mapping between process address space  and  the memory object ' I  
signal(int SIGNALI, void'  mem-mapping), 
f 
t l  
send signal 
8
1
kill(pid_t  pid. Int SIGNALI), 
/'  send signal to  target process ' I  
c0"irOl  process 
I 
Fig 5: Procedure mapping using signals 
5). We set a signal  into the target  program  using the signal 
C library function, and define a signal handler  routine that 
performs  the  actual  mapping.  Once  the  signal  is  set,  an 
external  control  process,  which  is  a  part  of  the  dynamic 
update  environment,  sends  a  signal  to  the  target  process 
when  it  wants  to  map  a  new  procedure  file.  When  the 
mapping  is  completed,  the  signal  handler  implemented in 
the target  program  sends the location  of the newly  mapped 
procedure  ("addr"  value  in  the  figure)  back  to the  control 
process using another signal. Note that the target program's 
operation is stopped temporarily while the signal handler  is 
executing.  Therefore,  it  is  important  to  minimize  the 
amount of work to be performed  by the signal handler. The 
signal 
and 
straightforward, and the size of the library that includes all 
functions for signal initialization  and procedure mapping is 
about  60  source  lines  in  C.  The  library  is  added  to  the 
target program. 
handler's 
function 
simple 
fairly 
is 
After the mapping, using the information on the location 
of the mapped  new  version  procedure,  we  correct external 
symbol  references.  Details  of the  correction  are  discussed 
in Section 3.3. 
The last step of the dynamic update  is to change the old 
version  procedure.  We  must  be  cautious  because  the  old 
version  procedure  is  a  part  of  the  running  process.  Thus, 
there  is  a  chance  that  the  procedure  may  be  executing 
when  we  attempt  to  change  it.  In  other  words,  the  target 
procedure  might  have  been  activated.  (An  activated 
procedure  is  a  procedure  that  is  currently  called  by  the 
process; all activated procedures are listed in the procedure 
activation record  in the run-time stack of the process [ 131.) 
Dynamically updating an  activated procedure  may cause a 
mixture of old and new version  procedures to be executed, 
which  can lead to incorrect software operation. 
An  easy  way  to get  around  this  problem  is to  update  a 
procedure  when  it  is  not  activated.  We  use  the  pstack(1) 
command to  check  a process's run-time  stack  in  Solaris. If 
the  target  procedure  is  not  activated,  we  can  move to  the 
next  step; otherwise, we  can either  recheck the stack  after 
waiting  for  a  certain  amount  of  time  or  keep  monitoring 
the run-time  stack until  the procedure  is deactivated.  Since 
the  latter  requires  more  work  and  dynamic  procedure 
update  is  usually  not  something  that  must  be  finished 
urgently  (the  software  has  been  running  so  far  anyway), 
we use the former  approach. Note that  our  method  cannot 
be  used  for  updating  procedures  that  are  always  running 
(e.g., the  "main"  procedure).  However,  in a large software 
system,  the  proportion  of such  procedures  is  usually  very 
small. 
Even 
the  target 
procedure  is  not  activated, the  procedure  can  be  activated 
during  an  update,  which  may  cause  incorrect  software 
execution. This is not  a problem  if we suspend the process 
if  a'  dynamic  update  starts  when 
274 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:05:53 UTC from IEEE Xplore.  Restrictions apply. 
. 
/'. 
-. 
-
6
Taget Procedure ' 
p. 
1 
I 
'I 
1-  Watched 
arca 
Fig 6: Watched area 
execution during an update. However, doing so will  incur 
performance  loss.  To  reduce  such  performance  loss,  we 
use the concept of watched area (Figure 6). In  Solaris, we 
can  set the target  procedure area as a  watched  area  using 
the watchpoint trap. Since the process  is trapped  when the 
code in  a watched  area is  fetched, the approach allows us 
to stop the process only when the target procedure is about 
to  be  activated  during  an  update.  The  probability  of  a 
specific procedure being activated during a short period of 
time  for  update  is  quite  low  in  a  large  software  system. 
Therefore,  the  watched  area  approach  can  efficiently 
reduce  the  performance  loss  during  an  update  while 
ensuring correct operation. 
The  watchpoint  trap  was  originally  developed  for 
debugging.  We  can  set a  watchpoint  trap  using  the  "ctl" 
file of the  process  file system  in  Solaris.  Specifically,  we 
can  set a watched  area by sending a control  message with 
the information about the starting location and the size of a 
code area to watch. Figure 7 shows a piece of pseudo code 
that represents the steps for setting a watchpoint trap. First, 