meld V:8,I:31 3500 meld(1) 比较和移植文件(GTK)
wiggle V:0,I:0 176 wiggle(1) 应用被拒绝的补丁
diffutils V:865,I:996 1735 diff(1) 逐行比较两个文件
diffutils V:865,I:996 1735 diff3(1) 逐行比较和合并三个文件
quilt V:2,I:23 871 quilt(1) 管理系列补丁
wdiff V:7,I:52 648 wdiff(1) 在文本文件中，显示单词的不同
diffstat V:13,I:122 74 diffstat(1) 通过diff生成一个改变柱状图
patchutils V:15,I:120 232 combinediff从(1)两个增量补丁创建一个积累补丁
patchutils V:15,I:120 232 dehtmldiff(1从) 一个HTML页面提取出一个diff
patchutils V:15,I:120 232 filterdiff(1从) 一个diff文件里面提取或者排除diff文件
patchutils V:15,I:120 232 fixcvsdiff(1修) 复由CVSpatch(1)错误创建的diff文件
patchutils V:15,I:120 232 flipdiff(1) 交换两个补丁的顺序
patchutils V:15,I:120 232 grepdiff(1) 显示哪些文件是由匹配正则表达式的补丁修改
显示在两个统一格式diff文件（基于同一个文件的
patchutils V:15,I:120 232 interdiff(1)
两个不同diff文件）之间的差异
patchutils V:15,I:120 232 lsdiff(1) 显示哪些文件由补丁修改
patchutils V:15,I:120 232 recountdiff重(1)新计算通用内容diff文件的数量和偏移
patchutils V:15,I:120 232 rediff(1) 修复手工编辑diff文件的数量和偏移
patchutils V:15,I:120 232 splitdiff(1)隔离出增量补丁
patchutils V:15,I:120 232 unwrapdiff(1识) 别已经被分词的补丁
dirdiff V:0,I:1 167 dirdiff(1) 显示目录树之间的不同并移植改变
docdiff V:0,I:0 553 docdiff(1) 逐词逐字地比较两个文件
makepatch V:0,I:0 100 makepatch(1)生成扩展补丁文件
makepatch V:0,I:0 100 applypatch(1应) 用扩展补丁文件
Table10.10: 源代码合并工具列表
Debian参考手册 192/233
10.4.1 从源代码文件导出差异
下面的操作，导出两个源文件的不同，并根据文件的位置，创建通用diff文件”file.patch0”或”file.patch1”.
$ diff -u file.old file.new > file.patch0
$ diff -u old/file new/file > file.patch1
10.4.2 源代码文件移植更新
diff文件（通常被叫作patch补丁文件），用于发送一个程序更新。通过下面的方式，接收到的部分，应用这个更新到
其它文件。
$ patch -p0 file < file.patch0
$ patch -p1 file < file.patch1
10.4.3 交互式移植
如果一个源代码，你有两个版本，你可以通过下面的方式，使用imediff(1)执行两方交互式移植。
$ imediff -o file.merged file.old file.new
如果一个源代码，你有三个版本，你可以通过下面的方式，使用imediff(1)执行交互式三方移植。
$ imediff -o file.merged file.yours file.base file.theirs
10.5 Git
Git是这些天选择的用于版本控制系统versioncontrolsystem(VCS)的工具，因为Git能够同时在本地和远程源代码管
理上，做任何事情。
通过DebianSalsa服务，Debian能够提供免费的Git服务。在https://wiki.debian.org/Salsa能找到它的说明文档。
下面是一些Git相关软件包。
软件包 流行度 大小 命令 说明
git V:345,I:542 46734 git(7) Git快速、可扩展、分布式的版本控制系统
gitk V:5,I:34 1838 gitk(1) 有历史功能的Git图形仓库浏览器
git-gui V:2,I:18 2429 git-gui(1) Git图形界面（无历史功能）
git-email V:0,I:10 1087 git-send-em从aiGl(i1t)用电子邮件发送收集到的补丁
git-buildpackage
V:1,I:9 1988 git-buildpa用ckGagite自(1动) 制作Debian包
dgit V:0,I:1 484 dgit(1) Debian档案库的git交互操作
imediff V:0,I:0 169 git-ime(1) 交互式的分开git提交的辅助工具
stgit V:0,I:0 601 stg(1) 封装的git(Python)
git-doc I:12 13208 N/A Git官方文档
gitmagic I:0 721 N/A ”Git魔术”，易于理解的Git手册
Table10.11: git相关包和命令列表
Debian参考手册 193/233
10.5.1 配置 Git 客户端
你可以在”~/.gitconfig”里面设置几个Git接下来需要使用的全局配置，比如说你的名字和电子邮件地址。
$ git config --global user.name ”Name Surname”
$ git config --global user.email PI:EMAIL
你也可以按如下所示定制Git的默认行为。
$ git config --global init.defaultBranch main
$ git config --global pull.rebase true
$ git config --global push.default current
如果你习惯使用CVS或Subversion命令，你也许希望设置如下几个命令别名。
$ git config --global alias.ci ”commit -a”
$ git config --global alias.co checkout
你能够通过如下方式检查你的全局配置：
$ git config --global --list
10.5.2 基本的 Git 命令
Git操作涉及几个数据。
• 工作树目录保持面向用户的文件，你可以对这些文件做修改。
– 需要被记录的改变，必须明确的被选择并暂存到索引。这是git add和git rm命令。
• 索引保持暂存文件。
– 在接下来的请求之前，暂存文件将被提交到本地仓库。这个是git commit命令。
• 本地仓库保持已经提交的的文件。
– Git记录提交数据的链接历史并在仓库里面将它们作为分支组织。
– 本地仓库通过git push命令发送数据到远程仓库。
– 本地仓库能够通过git fetch和git pull命令从远程仓库接收数据。
* git pull命令在git fetch后执行git merge或git rebase命令。
* 这里，git merge联合两个独立分支的历史结尾到一个点。（在没有定制的git pull，这个是默认的，同时
对上游作者发布分支到许多人时，也是好的）
* 这里，git rebase 创建一个远程分支的序列历史的单个分支，跟着本地分支。（这是定制 pull.rebase
true的情况，对我们其余的用途有用。）
• 远程仓库保持已经提交的文件。
– 到远程仓库的通信，使用安全的通信协议，比如SSH或HTTPS。
工作树是在.git/目录之外的文件。在.git/目录里面的文件，包括索引、本地仓库数据和一些git配置的文本文件。
这里是主要的Git命令概览。
Debian参考手册 194/233
Git命令 功能
git init 创建(本地)存储库
git clone URL 克隆远程存储库到本地仓库工作目录树
git pull origin main 通过远程仓库origin更新本地main分支
git add . 增加工作树里面的文件仅作为预先存在的索引文件
git add -A . 增加工作树里面的所有文件到索引（包括已经删除的）
git rm filename 从工作树和索引中删除文件
git commit 提交在索引中的暂存改变到本地存储库
添加工作树里的所有的改变到索引并提交它们到本地仓库（添加
git commit -a
+提交）
git push -u origin branch_name 使用本地branch_name分支更新远程仓库origin（初始启用）
git push origin branch_name 使用本地branch_name分支更新远程仓库origin（随后调用）
git diff treeish1 treeish2 显示treeish1提交和treeish2提交的不同
gitk VCS存储库分支历史树的图形界面显示
Table10.12: 主要的Git命令
10.5.3 Git 技巧
下面是一些Git技巧。
警告
不要使用带空格的标签字符串。即使一些工具，如gitk(1)允许你使用它，但会阻碍其它git命令。
小心
如果一个本地分支推送到一个已经变基或者压缩过的仓库，推送这样的分支有风险，并要求--force选项。
这通常对main分支来说不可接受，但对于一个移植到main分支前的特定分支，是可以接受的。
小心
从命令行通过”git-xyz”直接调用git子命令的方式，从2006年早期开始就被取消。
提示
如果有一个可执行文件git-foo在路径环境变量$PATH里面,在命令行输入没有中划线的”git foo”，则将调用
git-foo.这是git命令的一个特性。
10.5.4 Git 参考
参见下面内容。
• man手册：git(1)(/usr/share/doc/git-doc/git.html)
• Git用户手册(/usr/share/doc/git-doc/user-manual.html)
• git介绍教程(/usr/share/doc/git-doc/gittutorial.html)
• git介绍教程：第二部 (/usr/share/doc/git-doc/gittutorial-2.html)
• GIT每一天20个左右的命令(/usr/share/doc/git-doc/giteveryday.html)
• Git魔术(/usr/share/doc/gitmagic/html/index.html)
Debian参考手册 195/233
Git命令行 功能
参看完整的Git历史和操作，比如重置HEAD到另外一个提交、
gitk --all
挑选补丁、创建标签和分支……
git stash 得到一个干净的工作树，不会丢失数据
git remote -v 检查远程设置
git branch -vv 检查分支设置
git status 显示工作树状态
git config -l 列出git设置
git reset --hard HEAD; git
反转所有工作树的改变并完全清理它们
clean -x -d -f
git rm --cached filename 反转由git add filename改变的暂存索引
git reflog 获取参考日志（对从删除的分支中恢复提交有用）
git branch new_branch_name
从reflog信息创建一个新的分支
HEAD@{6}
git remote add new_remote URL 增加一个由URL指向的远程仓库new_remote
git remote rename origin
远程仓库的名字从origin重命名到upstream
upstream
git branch -u 设置远程跟踪到远程仓库upstream和它的分支名
upstream/branch_name branch_name。
git remote set-url origin
改变origin的URL
https://foo/bar.git
git remote set-url --push
禁止推送到upstream（编辑.git/config来重新启用）
upstream DISABLED
git remote update upstream fetchupdatesofallremotebranchesintheupstreamrepository
git fetch upstream createalocal(possiblyorphan)upstream-foobranchasacopyof
foo:upstream-foo foobranchintheupstreamrepository
git checkout -b topic_branch ;
制作一个新的topic_branch并把它推送到origin
git push -u topic_branch origin
git branch -m oldname newname 本地分支改名
git push -d origin
删除远程分支（新的方式）
branch_to_be_removed
git push origin
删除远程分支（老的方式）
:branch_to_be_removed
git checkout --orphan
创建一个新的unconnected分支