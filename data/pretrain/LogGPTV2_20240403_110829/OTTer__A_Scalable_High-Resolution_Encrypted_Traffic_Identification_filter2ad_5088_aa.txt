title:OTTer: A Scalable High-Resolution Encrypted Traffic Identification
Engine
author:Eva Papadogiannaki and
Constantinos Halevidis and
Periklis Akritidis and
Lazaros Koromilas
OTTer: A Scalable High-Resolution
Encrypted Traﬃc Identiﬁcation Engine
Eva Papadogiannaki(B), Constantinos Halevidis, Periklis Akritidis,
and Lazaros Koromilas
{papadogiannaki,halevidis,akritid,koromilas}@niometrics.com
Niometrics, Singapore, Singapore
Abstract. Several security applications rely on monitoring network
traﬃc, which is increasingly becoming encrypted. In this work, we pro-
pose a pattern language to describe packet trains for the purpose of
ﬁne-grained identiﬁcation of application-level events in encrypted net-
work traﬃc, and demonstrate its expressiveness with case studies for
distinguishing Messaging, Voice, and Video events in Facebook, Skype,
Viber, and WhatsApp network traﬃc. We provide an eﬃcient implemen-
tation of this language, and evaluate its performance by integrating it
into our proprietary DPI system. Finally, we demonstrate that the pro-
posed pattern language can be mined from traﬃc samples automatically,
minimizing the otherwise high ruleset maintenance burden.
Keywords: Traﬃc analysis · OTT applications · Network monitoring
1 Introduction
Over the years, the adoption of network traﬃc encryption has been continually
growing. Mobile applications are using the SSL/TLS protocols to secure their
communications, and some implement end-to-end encryption to protect the pri-
vacy of their users. Studies have shown that more than 60% of mobile application
traﬃc is now using SSL/TLS [25].
Internet traﬃc analysis is commonly based on techniques like deep packet
inspection (DPI). The core of traditional DPI implementations is based on pat-
tern matching, that enables searching for speciﬁc strings or regular expressions
inside the packet content. Applications of DPI include but are not limited to ﬁre-
walls, intrusion detection and prevention systems, antivirus systems, L7 ﬁltering
and packet forwarding [33–35]. With the widespread adoption of network encryp-
tion, DPI tools that rely on plain text pattern matching become less eﬀective,
demanding the development of more sophisticated techniques.
In this work, we focus exclusively on analysing encrypted traﬃc generated
by so called Over-The-Top (OTT) mobile applications—one of the most secu-
rity critical (exﬁltration, policy enforcement) sources of traﬃc. Traditional DPI
c(cid:2) Springer Nature Switzerland AG 2018
M. Bailey et al. (Eds.): RAID 2018, LNCS 11050, pp. 315–334, 2018.
https://doi.org/10.1007/978-3-030-00470-5_15
316
E. Papadogiannaki et al.
implementations can only extract very coarse-grained information for the major-
ity of such traﬃc. Its analysis, however, is an integral operation for many net-
work systems and needs to be improved to oﬀer detailed traﬃc metrics for OTT
applications. To this end, we implement a system that is able to extract essen-
tial information from encrypted traﬃc generated by mobile applications. Packets
contain metadata usable even with encrypted traﬃc, such as packet timestamps
and sizes—information that can be extracted from the packet headers or timed.
In this work we focus on using patterns of packet size trains to identify OTT
application events such as messaging, voice and video calls over encrypted traf-
ﬁc. We provide a full implementation as part of a DPI engine supporting rule-
sets with packet train patterns—matched using an automaton consuming packet
sizes—on top of traditional substring and port number patterns, to eﬃciently
match and report events in encrypted network traﬃc. Figure 1 shows a high-level
overview of our approach.
Network Flow 
Generation 
- Tra c trace
- Netstat log
- Flow-to-Process 
matching
Signatures
Automaton
DPI Engine
Application 
Event 
Reporting
Fig. 1. High-level overview: Traﬃc samples are collected oﬄine and then signatures
are created either manually or using data mining. The signatures are fed to our DPI
engine and compiled into an automaton for execution on live traﬃc keeping only usage
statistics.
In this work, we make the following contributions:
– We discuss a practical methodology to collect, label, and analyse encrypted
traﬃc generated by popular mobile OTT applications (e.g. Skype, WhatsApp,
Facebook Messenger and Viber) to identify usage events such as messaging,
voice and video calls
– We propose a pattern language to identify such events that is suitable for DPI
systems, yet expressive enough to describe packet metadata patterns, and we
conﬁrm this experimentally
– We discuss a high-performance implementation of our pattern language, and
integrate our implementation with a DPI engine to evaluate its performance
against high-volume real network traﬃc
– We demonstrate that our pattern language is amenable to automated mining
from ground truth samples.
2 Encrypted Traﬃc Pattern Language
During our analyses, we observed that speciﬁc sequences of packet payload sizes
reliably signify discrete events inside an application. In this section we describe
our proposed pattern language to express such patterns in network traﬃc.
OTTer: A Scalable High-Resolution Encrypted Traﬃc Identiﬁcation Engine
317
2.1 Design Goals
We aim for an expressive yet simple enough language to facilitate the auto-
mated mining of rules. While oﬄine mining techniques can be involved during
the construction of the rules, we need to support very eﬃcient and low-latency
evaluation of the rules at runtime on live traﬃc for use in a production quality
DPI system. Another consideration for a practical system is to minimize the
amount of state information that a DPI engine needs to maintain per ﬂow in
order to evaluate patterns across packets of the same ﬂow. These requirements
led us to a simple regex-inspired formulation applied on trains of observed packet
sizes. The advantage of our approach is that it can be implemented with an
automaton without the need to retain previously observed packet sizes to sup-
port backtracking, and that it is expressive enough to capture the traﬃc features
of interest.
2.2 Pattern Language Speciﬁcation
Table 1 displays some examples of rules that we extracted during our analy-
sis phase. The proposed pattern language uses a regex-inspired syntax, and is
easy to follow, since it resembles standard regular expressions. When a network
ﬂow contains such sequences of these pre-deﬁned payload packet sizes, expressed
through a rule and in conjunction with any other traﬃc characteristics such as
port numbers or substrings, then the application event is reported. For instance,
when a captured network ﬂow contains a series of two packets with payload sizes
3 bytes and 52 bytes respectively, then our system reports the existence of an
outgoing chat message.
Table 1. Examples of application event rules.
Event
Voice call
Video call
Chat message WhatsApp 3{1,3}, 52
Application Rule
WhatsApp 3{1,3}, 56-60{1,3}, 400-800
WhatsApp 3{1,3}, 56-60{1,3}, 3{1,3}, 117 OR
3{1,3}, 56-60{1,3}, 3{1,3}, 144
Informally, a rule expression consists of one or more comma-separated pieces.
Each piece is an atom with an optional bound. The atom is either a single number
or a range of numbers, where number is a positive integer. The bound speciﬁes
an exact or relaxed (with min and max inclusive limits) number of repetitions
of the atom. A formal deﬁnition can be found in Table 2.
Our proposal can be extended for additional expressiveness, for example by
adding other regular expression constructs such as groups or disjunctions. In this
work we kept the pattern language complexity to a minimum to avoid compli-
cating the mining process. Disjunction, in particular, is handled by providing a
318
E. Papadogiannaki et al.
disjunctive set of rules, instead of extending the language syntax with an embed-
ded disjunctive operator. The downside is that a larger set of patterns may be
required. We did not ﬁnd this to be a problem in practice.
Table 2. Rule language speciﬁcation; number is a positive integer.
expr ::= piece | piece, expr
piece ::= atom | atom{bound}
atom ::= number | number-number
bound ::= number | number,number
In order to deal with retransmitted TCP packets we could either (i) nor-
malize traﬃc before applying the rule by discarding such packets or (ii) form
the expression to handle the retransmitted packets, accordingly (like the rules
in Table 1). The displayed expressions are able to handle retransmitted packets
having a repeat range {1,3}, where 3 is the upper bound (the maximum num-
ber of retransmissions). However, handling retransmissions through the expres-
sion might be risky. Having retransmitted packets is an unpredictable network
behaviour, so we might lose an application event reporting solely due to a not
properly deﬁned upper bound in the repeat range of an expression. Thus, we
choose to handle retransmitted TCP packets by discarding them in a packet
ﬁltering phase.
3 Eﬀectiveness Evaluation
In this section we demonstrate the expressiveness of the proposed pattern lan-
guage by manually generating pattern signatures for a set of application events
and evaluating their accuracy. We used 25% (randomly chosen) of the ground
truth samples as a reference for the human analyst, and the remaining 75% for
the accuracy evaluation (Sect. 3.3).
3.1 Flow Sample Collection Mechanism
We divide the mobile application network traﬃc into ﬂows. A network ﬂow is
represented by the standard 5-tuple containing (i) the source IP address, (ii) the
source port number, (iii) the destination IP address, (iv) the destination port
number and (v) the protocol. A network ﬂow then, consists of the packets match-
ing a certain 5-tuple. To categorise the ﬂows generated by diﬀerent mobile appli-
cations, we need further information. This information should include either the
domain, the process name or the process id that relates to the speciﬁc net-
work connection. There are multiple ways to achieve this. For instance, other
approaches, like [12], do domain ﬁltering, leveraging the WHOIS protocol. We
chose to employ the process id in order to obtain the required information about
each network ﬂow. In the following section we present how we implemented the
network ﬂow ﬁltering.
OTTer: A Scalable High-Resolution Encrypted Traﬃc Identiﬁcation Engine
319
Flow-to-Process Matching. Netstat [3] is a command-line network utility
that can display among others, information about network connections. Having
superuser privileges, someone can use netstat to determine the process id (PID)
and process name of the process that owns the connection socket. In Android
devices, netstat is available via the BusyBox application [2].
To collect all necessary information about each connection established dur-
ing the network traﬃc trace collection, we continually invoke netstat and store
the output to a ﬁle that will be later used for the ﬂow-to-process characterisa-
tion phase (ﬂow/process correlation), during which ﬂows are assigned to their
process and (and the corresponding PID), generating a 7-tuple, with the follow-
ing format: {process name, process id, source IP address, source port number,
destination IP address, destination port number, protocol}.
Packet Filtering. In order for the TCP protocol to deliver data reliably, it
oﬀers many mechanisms to detect and avoid unpredictable network behaviour,
like packet loss, duplication or reordering. In the proposed methodology, we
choose to discard packets that do not oﬀer substantial information to the ﬂow
(e.g. retransmitted packets). In our proposed method, we focus entirely on han-
dling and processing packet metadata. This means that we do not take into
consideration the packet payload, since we assume that it is encrypted. The
information that we handle lays solely on packet metadata, such as the packet
direction and payload size. Thus, packets lacking payload do not provide any
valuable information to our method. To this end, we ﬁlter out ACK-ﬂagged
packets1.
3.2 Sample Traﬃc Generation
To avoid extracting overly speciﬁc application event patterns, we analysed traﬃc
traces generated during realistic usage of such applications. In addition, we used
devices on both ﬁxed and mobile networks.
Device Variations. To ensure variation, we make use of diﬀerent devices,
vendors, Android and kernel versions. We used four diﬀerent Android mobile
devices, a Sony Xperia D5503 (Android v.5.1.1, kernel v.3.4.0-gd26777b), a
Xiaomi Redmi 3s (Android v.6.0.1, kernel v.3.18.20-g76f906f), a Xiaomi MI Note
LTE (Android v.6.0.1, kernel v.3.4.0-gf4b741d), and ﬁnally a Xiaomi Redmi
Note 3 Pro (Android v.6.0.1, kernel v.3.10.84-gda78349). In order to obtain full
functionality and privileges, we used exclusively rooted Android devices, with
developer options enabled. Thus, we were able to install the BusyBox application
from Google Play store and take advantage of Unix utilities provided through
a single executable [2], as well as the Android tcpdump tool to locally capture
network traﬃc on the device [1]. In addition, we used Android Debug Bridge
1 We discard the TCP packets with only the ACK ﬂag set. PUSH/ACK packets are