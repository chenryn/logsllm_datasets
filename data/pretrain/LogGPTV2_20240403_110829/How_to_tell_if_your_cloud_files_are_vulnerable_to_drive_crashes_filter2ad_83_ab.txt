isn’t.) We also show how to smooth out read-time variance by con-
structing RAFT queries Q that consist of multiple blocks per drive.
Queries with multiple blocks per drive. (“How can Eeta Pizza
Pie place multiple, unpredictable orders without phoning Cheap-
skate multiple times?”) A naïve way to construct a challenge Q
consisting of multiple blocks per drive (say, q) is simply for the
client to specify cq random blocks in Q. The problem with this
approach is that the server can then schedule the set of cq block ac-
cesses on its drives to reduce total access time (e.g., exploiting drive
efﬁciencies on sequential-order reads). Alternatively, the client
could issue challenges in q steps, waiting to receive a response be-
fore issuing a next, unpredictable challenge. But this would require
c rounds of interaction.
We instead introduce an approach that we call lock-step chal-
lenge generation. The key idea is for the client to specify query
Q in an initial step consisting of c random challenge blocks (one
per drive). For each subsequent step, the set of c challenge blocks
depends on the content of the ﬁle blocks accessed in the last step.
The server can proceed to the next step only after fully completing
the last one. Our lock-step technique is a kind of repeated appli-
cation of a Fiat-Shamir-like heuristic [12] for generating q inde-
pendent, unpredictable sets of challenges non-interactively. (File
blocks serve as a kind of “commitment.”) The server’s response to
Q is the aggregate (hash) of all of the cq ﬁle blocks it accesses.
3. FORMAL DEFINITIONS
A Remote Assessment of Fault Tolerance RAFT (t) aims to
enable a service provider to prove to a client that it has stored ﬁle
F with tolerance against t drive failures. In our model, the ﬁle is
ﬁrst encoded by adding some redundancy. This can be done by ei-
ther the client or the server. The encoded ﬁle is then stored by the
server using some number of drives. Periodically, the client issues
challenges to the server, consisting of a subset of ﬁle block indices.
If the server replies correctly and promptly to challenges (i.e., the
answer is consistent with the original ﬁle F , and the timing of the
response is within an acceptable interval), the client is convinced
that the server stores the ﬁle with tolerance against t drive failures.
The client can also reconstruct the ﬁle at any time from the encod-
ing stored by the server, assuming at most t drive failures.
3.1 System deﬁnition
To deﬁne our system more formally, we start by introducing
some notation. A ﬁle block is an element in B = GF [2ℓ]. For
503convenience we also treat ℓ as a security parameter. We let fi de-
note the ith block of a ﬁle F for i ∈ {1, . . . , |F |}.
The RAFT system comprises these functions:
• Keygen(1ℓ) R→ κ: A key-generation function that outputs
key κ. We denote a keyless system by κ = φ.
• Encode(κ, F = {fi}m
i=1, t, c) → G = {gi}n
i=1: An en-
coding function applied to an m-block ﬁle F = {fi}m
i=1; it
takes as additional input fault tolerance t and a number of c
logical disks. It outputs encoded ﬁle G = {gi}n
i=1, where
n ≥ m. The function Encode may be keyed, e.g., encrypt-
ing blocks under κ, in which case encoding is done by the
client, or unkeyed, e.g., applying an erasure code or keyless
cryptographic operation to F , which may be done by either
the client or server.
• Map(n, t, c) → {Cj}c
j=1: A function computed by both the
client and server that takes the encoded ﬁle size n, fault tol-
erance t and a number c of logical disks and outputs a logical
mapping of ﬁle blocks to c disks or ⊥. To implement Map
the client and server can agree on a mapping which each can
compute, or the server may specify a mapping that the client
veriﬁes as being tolerant to t drive failures. (A more general
deﬁnition might also include G = {gi}n
i=1 as input. Here
we only consider mappings that respect erasure-coding struc-
ture.) The output consists of sets Cj ⊆ {1, 2, . . . , n} denot-
ing the block indices stored on drive j, for j ∈ {1, . . . , c}. If
the output is not ⊥, then the placement is tolerant to t drive
failures.
• Challenge(n, G, t, c) → Q: A (stateful and probabilistic)
function computed by the client that takes as input the en-
coded ﬁle size n, encoded ﬁle G, fault tolerance t, and the
number of logical drives c and generates a challenge Q con-
sisting of a set of block indices in G and a random nonce ν.
The aim of the challenge is to verify disk-failure tolerance at
least t.
• Response(Q) → (R, T ): An algorithm that computes a
server’s response R to challenge Q, using the encoded ﬁle
blocks stored on the server disks. The timing of the response
T is measured by the client as the time required to receive
the response from the server after sending a challenge.
• Verify(G, Q, R, T ) → b ∈ {0, 1}: A veriﬁcation function
for a server’s response (R, T ) to a challenge Q, where 1 de-
notes “accept,” i.e., the client has successfully veriﬁed cor-
rect storage by the server. Conversely 0 denotes “reject.” In-
put G is optional in some systems.
• Reconstruct(κ, r, {g∗
i }r
i }m
i=1) → F ∗ = {f ∗
i=1: A recon-
struction function that takes a set of r encoded ﬁle blocks and
either reconstructs an m-block ﬁle or outputs failure sym-
bol ⊥. We assume that the block indices in the encoded
ﬁle are also given to the Reconstruct algorithm, but we omit
them here for simplicity of notation. The function is keyed if
Encode is keyed, and unkeyed otherwise.
Except in the case of Keygen, which is always probabilistic, func-
tions may be probabilistic or deterministic. We deﬁne RAFT (t) =
{Keygen, Encode, Map, Challenge, Response, Verify, Reconstruct}.
3.2 Client model
In some instances of our protocols called keyed protocols, the
client needs to store secret keys used for encoding and reconstruct-
ing the ﬁle. Unkeyed protocols do not make use of secret keys for
ﬁle encoding, but instead use public transforms.
If the Map function outputs a logical layout {Cj}c
j=1 6=⊥, then
we call the model layout-speciﬁed. We denote a layout-free model
one in which the Map function outputs ⊥, i.e., the client does not
know a logical placement of the ﬁle on c disks. In this paper, we
only consider layout-speciﬁed protocols, although layout-free pro-
tocols are an interesting point in the RAFT design space.
For simplicity in designing the Verify protocol, we assume that
the client keeps a copy of F locally. Our protocols can be extended
easily via standard block-authentication techniques, e.g., [25], to a
model in which the ﬁle is maintained only by the provider and the
client deletes the local copy after outsourcing the ﬁle.
3.3 Drive and network models
The response time T of the server to a challenge Q as measured
by the client has two components: (1) Drive read-request delays
and (2) Network latency. We model these two protocol-timing com-
ponents as follows.
Modeling drives.
We model a server’s storage resources for F as a collection of
d independent hard drives. Each drive stores a collection of ﬁle
blocks. The drives are stateful: The timing of a read-request re-
sponse depends on the query history for the drive, reﬂecting block-
retrieval delays. For example, a drive’s response time is lower
for sequentially indexed queries than for randomly indexed ones,
which induce seek-time delays [30]. We do not consider other
forms of storage here, e.g., solid-state drives3.
We assume that all the drives belong to the same class, (e.g. en-
terprise class drives), but may differ in signiﬁcant ways, including
seek time, latency, and even manufacturer. We will present disk
access time distributions for several enterprise class drive models.
We also assume that when retrieving disk blocks for responding to
client queries in the protocol, there is no other workload running
concurrently on the drive, i.e. the drive has been "reserved" for the
RAFT4. Alternatively, in many cases, drive contention can be over-
come by issuing more queries. We will demonstrate the feasibility
of both approaches through experimental results.
Modeling network latency.
We adapt our protocols to handle variations in network latency
between the client and cloud provider. Based on the results pre-
sented in [24] and our own small-scale experiments, we set an up-
per bound threshold on the variability in observed latency between
the vast majority of host pairs. We design our protocol so that the
difference in timing to reply successfully to a challenge between an
3At the time of this writing, SSDs are still considerably more ex-
pensive than rotational drives and have much lower capacities. A
typical rotational drive can be bought for roughly $0.07/GB in ca-
pacities up to 3 TBs, while most SSDs cost more than $2.00/GB are
are only a few hundred GBs in size. For an economically rational
adversary, the current cost difference makes SSDs impractical.
4Multiple concurrent workloads could skew disk-access times in
unexpected ways. This was actually seen in our own experiments
when the OS contended with our tests for access to a disk, causing
spikes in recorded read times.In a multi-tenant environment, users
are accustomed to delayed responses, so reserving a drive for 500
ms. to perform a RAFT test should not be an issue.
504adversarial and an honest server is at least the maximum observed
variability in network latency.
3.4 Adversarial model
We now describe our adversarial model, i.e., the range of behav-
iors of S. In our model, the m-block ﬁle F is chosen uniformly
at random. This reﬂects our assumption that ﬁle blocks are already
compressed by the client, for storage and transmission efﬁciency,
and also because our RAFT constructions beneﬁt from random-
looking ﬁle blocks. Encode is applied to F , yielding an encoded
ﬁle G of size n, which is stored with S.
Both the client and server compute the logical placement {Cj}c
j=1
by applying the Map function. The server then distributes the
blocks of G across d real disks. The number of actual disks d used
by S might be different than the number of agreed-upon drives c.
The actual ﬁle placement {Dj}d
j=1 performed by the server might
also deviate arbitrarily from the placement speciﬁed by the Map
function. (As we discuss later, sophisticated adversaries might even
store something other than unmodiﬁed blocks of G.)
At the beginning of a protocol execution, we assume that no
blocks of G are stored in the high-speed (non-disk) memory of S.
Therefore, to respond to a challenge Q, S must query its disks to
retrieve ﬁle blocks. The variable T denotes the time required for
the client, after transmitting its challenge, to receive a response R
from S. Time T includes both network latency and drive access
time (as well as any delay introduced by S cheating).
The goal of the client is to establish whether the ﬁle placement
implemented by the server is resilient to at least t drive failures.
Our adversarial model is validated by the design and implemen-
tation of the Mozy online backup system, which we will discuss
further in Section 6.2. We expect Mozy to be representative of
many cloud storage infrastructures.
Cheap-and-lazy server model.
For simplicity and realism, we focus ﬁrst on a restricted adver-
sary S that we call cheap-and-lazy. The objective of a cheap-and-
lazy adversary is to reduce its resource costs; in that sense it is
“cheap.” It is “lazy” in the sense that it does not modify ﬁle con-
tents. The adversary instead cuts corners by storing less redundant
data on a smaller number of disks or mapping ﬁle blocks unevenly
across disks, i.e., it may ignore the output of Map. A cheap-and-
lazy adversary captures the behavior of a typical cost-cutting or
negligent storage service provider.
To be precise, we specify a cheap-and-lazy server S by the fol-
lowing assumptions on the blocks of ﬁle F :
• Block obliviousness: The behavior of S i.e., its choice of
internal ﬁle-block placement (d, {Dj}d
j=1) is independent
of the content of blocks in G.
Intuitively, this means that
S doesn’t inspect block contents when placing encoded ﬁle
blocks on drives.
• Block atomicity: The server handles ﬁle blocks as atomic
data elements, i.e., it doesn’t partition blocks across multiple
storage devices.
A cheap-and-lazy server may be viewed as selecting a mapping
from n encoded ﬁle blocks to positions on d drives without knowl-
edge of G. Some of the encoded ﬁle blocks might not be stored to
drives at all (corresponding to dropping of ﬁle blocks), and some
might be duplicated onto multiple drives. S then applies this map-
ping to the n blocks of G.
General adversarial model.
It is also useful to consider a general adversarial model, cast in
an experimental framework. We deﬁne the security of our sys-
tem RAFT (t) according to the experiment from Figure 1. We
let O(κ) = {Encode(κ, ·, ·, ·), Map(·, ·, ·), Challenge(·, ·, ·, ·),
Verify(·, ·, ·, ·), Reconstruct(κ, ·, ·)} denote a set of RAFT-function
oracles (some keyed) accessible to S.
Experiment ExpRAFT (t)
(m, ℓ, t):
S
i=1 ←R Bm ;
i=1 ← Encode(κ, F, t, c);
j=1) ← S O(κ)(n, G, t, c, “store ﬁle”);
κ ← Keygen(1ℓ);
F = {fi}m
G = {gi}n
(d, {Dj}d
Q ← Challenge(n, G, t, c);
(R, T ) ← S {Dj }d
if AccS and NotFTS
j=1 (Q, “compute response”);
then output 1,
else output 0
Figure 1: Security experiment
S
We denote by AccS the event that Verify(G, Q, R, T ) = 1 in
a given run of ExpRAFT (t)
(m, ℓ, t), i.e., that the client / veriﬁer
accepts the response of S. We denote by NotFTS the event that
there exists {Dij }d−t
Reconstruct(κ, |{Dij }d−t
j=1) 6= F, i.e, the allocation of
blocks selected by S in the experimental run is not t-fault tolerant.
j=1 s.t.
j=1|, {Dij }d−t
j=1 ⊆ {Dj}d
S
We deﬁne AdvRAFT (t)
(m, ℓ, t) = Pr[ExpRAFT (t)
(m, ℓ, t) = 1]
= Pr[AccS and NotFTS ]. We deﬁne the completeness of RAFT (t)
as CompRAFT (t)(m, ℓ, t) = Pr[AccS and ¬NotFTS ] over exe-
cutions of honest S (a server that always respects the protocol spec-
iﬁcation) in ExpRAFT (t)
(m, ℓ, t).
S
S
Our general deﬁnition here is, in fact, a little too general for prac-
tical purposes. As we now explain, there is no good RAFT for a
fully malicious S. That is why we restrict our attention to cheap-
and-lazy S, and later, in Section 7, brieﬂy consider a “rational” S.
Why we exclude malicious servers.
A malicious or fully Byzantine server S is one that may expend
arbitrarily large resources and manipulate and store G in an arbi-
trary manner. Its goal is to achieve ≤ t − 1 fault tolerance for F
while convincing the client with high probability that F enjoys full
t fault tolerance.
We do not consider malicious servers because there is no efﬁ-
cient protocol to detect them. A malicious server can convert any
t-fault-tolerant ﬁle placement into a 0-fault-tolerant ﬁle placement
very simply. The server randomly selects an encryption key λ, and
encrypts every stored ﬁle block under λ. S then adds a new drive
and stores λ on it. To reply to a challenge, S retrieves λ and de-
crypts any ﬁle blocks in its response. If the drive containing λ fails,
of course, the ﬁle F will be lost. There is no efﬁcient protocol that
distinguishes between a ﬁle stored encrypted with the key held on
a single drive, and a ﬁle stored as speciﬁed, as they result in nearly
equivalent block read times.5
3.5 Problem Instances
A RAFT problem instance comprises a client model, an adver-
sarial model, and drive and network models. In what follows, we
5The need to pull λ from the additional drive may slightly skew the
response time of S when ﬁrst challenged by the client. This skew
is modest in realistic settings. And once read, λ is available for any
additional challenges.
505propose RAFT designs in an incremental manner, starting with a
very simple problem instance—a cheap-and-lazy adversarial model
and simplistic drive and network models. After experimentally
exploring more realistic network and drive models, we propose a
more complex RAFT. We then consider a more powerful (“ratio-
nal”) adversary and further reﬁnements to our RAFT scheme.
4. THE BASIC RAFT PROTOCOL
In this section, we construct a simple RAFT system resilient
against the cheap-and-lazy adversary. We consider very simple disk
and network models. While the protocol presented in this section
is mostly of theoretical interest, it offers a conceptual framework