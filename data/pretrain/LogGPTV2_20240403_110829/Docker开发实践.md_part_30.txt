 Kubernetes的架构和组件。Kubernetes是一种主从架构的集群管理工具，主控节点包含
apiserver、调度器和控制器，从属节点包含kubelet和服务代理等组件。 8
 Kubernetes实战。
10
16.1 Kubernetes 简介
10
Kubernetes是Google公司开源的大规模容器集群管理系统。利用Kubernetes，能方便地管理跨
机器运行的容器化应用。它为容器化应用提供资源调度、部署、服务发现、扩展机制等功能，具 11
体如下：
 使用Docker对应用进行打包、实例化和运行； 13
 以集群的方式运行和管理跨主机的容器；
 解决跨主机容器的通信问题； 14
 提供自我修复功能，保证系统运行的健壮性。
15
Kubernetes目前处于快速迭代开发之中，几乎每周都会推出新的版本。作为一个容器管理框
架，Kubernetes可以被部署在物理集群和各类云环境中，例如GCE、vSphere、CoreOS、OpenShift、
16
Azure等。
接下来，我们将会从Kubernetes的核心概念、设计框架等入手，让读者更好地理解它。等有
17
了相关基础之后，我们将会在CentOS 7上实验Kubernetes。
18
190 第16章 Kubernetes
16.2 核心概念
Kubernetes的核心概念包含节点（Node）、Pod、服务（Service）、备份控制器（Replication
Controller）、卷（Volume）和标签（Label）。鉴于备份控制器和卷比较简要，这里不再详细介绍，
后面介绍架构时一起说明。
16.2.1 节点
节点是Kubernetes系统中的一台工作机器，常被称为Minion，即从属主机。它可以是物理机，
也可以是虚拟机。每一个节点都包含了Pod运行所需的必要服务，例如Docker、kubelet和网络代
理（proxy）。节点受Kubernetes系统中的主节点控制。和Pod、服务不一样，节点本身并不属于
Kubernetes的概念，它是云平台中的虚拟机或者实体机。所以，当一个节点加入到Kubernetes系统
中时，它将会创建一个数据结构来记录该节点的信息。另外，不是所有节点都能够加入到
Kubernetes系统中的，只有那些通过验证的节点才能够成为Kubernetes节点。
目前，节点的管理有两种方式：节点管理器（Node Controller）和通过命令手动管理。
 节点管理器。它是Kubernetes主控节点上管理集群节点的组件，主要包含两个功能：集群
节点的同步和单个节点生命周期的管理。当有节点加入到Kubernetes中时，节点管理器将
会创建节点信息；当有节点需要从Kubernetes中删除时，节点管理器则会删除该节点的节
点信息。需要注意的是，节点管理器并不会真正创建节点本身，而仅仅创建节点的元数
据，用于跟踪节点的状态。所以，节点上的服务需要用户自己安装。单个节点的生命周
期的管理目前尚在开发之中。
 手动管理节点。Kubernetes的管理员可以通过kubectl命令来管理节点。和节点管理器一样，
使用kubectl命令创建和删除节点时，也只是删除节点的配置信息。
16.2.2 Pod
在Kubernetes中，Pod是最小的可创建、调度和管理的部署单元。它是容器化环境中的“逻辑
主机”，可以包含一个或多个有关联的容器，并且容器之间可以共享数据卷。例如，一个Web站
点应用由前端、后端和数据库组成，这三个组件运行在各自的容器中，我们可以创建包含这三个
容器的Pod。
可以看出，容器存在于Pod之中，而Pod又存在于节点之中。那么，为什么需要抽象出Pod这
个概念呢？下面从资源共享和通信、管理这两个方面介绍一下。
 资源共享和通信。同一Pod中的容器拥有相同的网络命名空间、IP地址和端口区间，它们
之间可以直接用localhost来发现和通信。在无层次的共享网络中，每个Pod都有一个IP地
址，用于跟其他物理主机和容器进行通信，Pod的名字也被用作主机名。此外，同一Pod
的容器可以共享数据卷。在将来，Pod内的容器还可以共享IPC命名空间、CPU和内存等。
16.2 核心概念 191
 管理。从管理的角度来看，Pod比容器站在更高的层面，它简化了应用的部署和管理。Pod 1
可以自动处理主机托管、资源共享、协调复制和依赖管理等问题。
虽然可以将Pod用在垂直依赖的应用栈中，但它更适合用在多个应用的横向协作部署中，为 2
多个容器提供集中的辅助功能。具体的使用用例有：
3
 内容管理系统、文件和数据的装载和本地缓存管理等；
 日志和检出点备份、压缩、轮换和快照；
4
 数据变更监控、日志末端数据读取、日志和监控适配器和事件打印；
 代理、桥接和适配器；
5
 控制器、管理器、配置编辑和更新。
为什么不在一个容器中直接运行多个应用而采用在一个Pod中运行多个容器呢？主要原因如
6
下所示。
 透明性。底层系统可以获取到Pod内的容器，这样底层系统就可以为容器提供诸如进程管 7
理和资源监控等服务，这会给用户带来不少便利。
 解耦软件依赖。分为多个容器后，每个容器都可以单独存在，并且当其中某个应用需要 9
升级时，只影响到一个容器。后续Pod将会支持单个容器的在线升级。
 易用性。用户不需要使用自己的进程管理程序，直接用Docker管理容器即可。此外，用 8
户也不用再担心信号量和退出码的传递等问题。
 高效性。因为底层系统提供了更多的管理，这使得容器更加轻便。 10
16.2.3 服务
10
Kubernetes的服务是一系列Pod以及这些Pod的访问策略的抽象。
11
Kubernetes中的Pod是具有时效性的，它会随着时间而变化。虽然每个Pod都有一个单独的IP地
址，但是该IP地址却不是静态不变的。例如，当系统触发RepliController对Pod进行备份时，Pod的地
13
址很可能会发生改变。这将会导致一个问题。我们试想，在Kubernetes系统中，有一群Pod作为后端
给前端提供服务，如果后端的IP地址是变动的，那么前端又如何去发现和使用后端的服务呢？
14
Kubernetes的服务也叫作微服务（micro-service），它用于定义一系列Pod的逻辑关系以及它们
的访问规则。服务的目标是为了隔绝前端和后端的耦合性，让前端透明地使用该项服务，而不需 15
要知道该项服务具体由哪些后台机器提供。Kubernetes会为一个服务分配一对，该IP和端口并不
是真实的地址和端口，而是一个虚拟IP，当前端通过该对访问服务时，服务代理将会将请求重定 16
向到合适的后端机器。
1. 定义服务 17
Kubernetes中的服务是一个REST（Representational State Transfer，表述性状态转移）对象。
18
下面演示了一个服务的定义：
192 第16章 Kubernetes
{
"id": "myapp",
"selector": {
"app": "MyApp"
},
"containerPort": 9376,
"protocol": "TCP",
"port": 8765
}
上述示例定义了一个id为myapp的服务，它通过选择器选择那些带有app=MyApp标签的Pod作为
服务的提供者。所有被选择的Pod都将9376端口暴露，用于监听该项服务的请求。前端客户可以
通过$MYAPP_SERVICE_PORT和$MYAPP_SERVICE_HOST来访问该项服务。
2. 工作原理
在Kubernetes中，每个节点都运行着一个服务代理（service proxy），它监控来自Kubernetes
主控节点的消息，主控节点会向其传递诸如添加和删除服务以及服务的端点列表等信息。服务代
理维护着一个映射表，表中每一项是服务和该服务的提供者列表的映射关系，服务代理还会为每
一个服务在本地开放一个端口，当节点需要使用某项服务时，将请求发送至该端口，然后由服务
代理通过某种策略（例如轮换策略）安排服务的具体提供节点。
当一个Pod加入到Kubernetes集群中时，主控节点会在它上面为每一个已经存在的服务分配一
系列环境变量。变量的命名形如SVCNAME_SERVICE_HOST，其中SVCNAME是服务名称的大写。例如，
服务redis-master在端口6379上提供TCP服务，其虚拟IP地址为10.0.0.11，那么该项服务对应的环
境变量就有：
REDIS_MASTER_SERVICE_HOST=10.0.0.11
REDIS_MASTER_SERVICE_PORT=6379
REDIS_MASTER_PORT=tcp://10.0.0.11:6379
REDIS_MASTER_PORT_6379_TCP=tcp://10.0.0.11:6379
REDIS_MASTER_PORT_6379_TCP_PROTO=tcp
REDIS_MASTER_PORT_6379_TCP_PORT=6379
REDIS_MASTER_PORT_6379_TCP_ADDR=10.0.0.11
这些环境变量主要说明服务的地址、端口和协议。需要注意的是，既然一个Pod加入到
Kubernetes集群时，会被设置这些跟服务相关的环境变量，这意味着一个Pod只能发现在它加入之
前就已经存在的服务。当然，如果服务支持了DNS，该条限制将会失效。
如图16-1所示，在前端Pod加入到该Kubernetes集群时，主控节点的apiserver会将MyApp服务
的服务信息推送给该Pod，这些信息包含了服务及其对应的端点（Endpoint）列表。前端Pod需要
使用后端Pod提供的MyApp服务，它并不直接联系后端Pod，而是将请求发给本地的服务代理，
服务代理会将该服务请求分配给这三个后端Pod中的一个。服务可以动态地增加和删除提供服务
的Pod，而前端Pod感知不到这些细节的变化，除非是正在为它提供服务的Pod状态发生了改变。
在Kubernetes服务的工作原理背后，还有两个细节需要注意：冲突避免和Portal。
16.2 核心概念 193
1
2
3
4
图16-1 前端通过服务代理来访问后端提供的服务
5
3. 冲突避免
Kubernetes的一个设计理念就是不能随便让用户去承受服务的失败，特别是用户根本就没有
6
犯错的情况下。这里我们考虑一下服务端口冲突的问题：假如第一项服务选取了80端口作为服务
端口，那么其他服务就不能再选该端口作为服务端口了。为了避免这种冲突问题，Kubernetes不
7
仅选择了为每一个服务分配端口，同时也配置了一个IP。这样每一个服务都拥有自己的IP和端口
对应，从而避免了服务端口冲突。
9
4. Portal
Portal就是前面提到的服务的二元组。这里的IP是虚拟IP，它并不是一台特定机器的真实IP。 8
用户访问某个服务，就是访问某个服务的Portal。当请求投递到该Portal之后，该请求会根据规则
重定向到某个特定的服务提供者Pod。下面我们举例说明该问题。如图16-2所示，每一个节点都 10
会有一个服务代理，当节点加入到Kubernetes集群中时，主控节点的apiserver程序会将服务的配
置信息投递给服务代理，服务代理保存服务配置信息，并根据Portal信息设置iptables的网络规则， 10
这里我们假设Portal为10.0.0.1:1234。前端通过链接Portal来访问服务，iptables监听到该请求，将
该请求重定向到配置好的代理端口上，服务代理从该端口接过服务请求，然后根据策略选取一个 11
后端Pod，最后由选中的后端Pod来给前端Pod提供服务。
13
14
15
16
17
18
图16-2 服务代理响应服务的过程
194 第16章 Kubernetes
16.2.4 标签
标签（Label）是一组附加在对象上的键值对。标签常用来从一组对象中选取符合条件的对
象，这也是Kubernetes中目前为止最重要的节点分组方法。标签的本质是附属在对象上的非系
统属性类的元数据，即它不是名字、Id以及对象的硬件属性，而是一些附加的键值对，这些键
值对对对象本身没什么影响，但对我们操作对象却极为有用。例如，下面是一个Pod节点的配
置文件：
{
"id": "redis-master",
"kind": "Pod",
"apiVersion": "v1beta1",
"desiredState": {
"manifest": {
"version": "v1beta1",
"id": "redis-master",
"containers": [{
"name": "master",
"image": "dockerfile/redis",
"cpu": 100,
"ports": [{
"containerPort": 6379,
"hostPort": 6379
}]
}]
}
},
"labels": {
"name": "redis-master"
}
}
可以看到，除了id、kind等这些系统属性外，还有labels属性，它是这个Pod的标签，它的
键值对为"name":"redis-master"。有了这个标签，我们就可以在部署服务时，通过标签来指定只
有包含该标签的Pod才可以部署该服务。例如，我们定义如下服务：
{
"id": "redis-master",
"kind": "Service",
"apiVersion": "v1beta1",
"port": 6379,
"containerPort": 6379,
"selector": {
"name": "redis-master"
},
"labels": {
"name": "redis-master"
}
}
16.3 架构和组件 195
这个redis-master服务通过selector（选择子）来选择标签为"name":"redis-master"的Pod
1
来部署服务。当然，该服务自己又定义了一个标签，其中的键值对为"name":"redis-master"，这
样需要使用该服务的应用又可以根据该标签来过滤服务。 2
16.3 架构和组件 3
Kubernetes的架构如图16-3所示。
4
5
6
7
9
8
10
10
11
13
图16-3 Kubernetes的架构
14
在Kubernetes集群中，主要包含主控节点（Master）和从属节点（Minion），前者负责整个集
群的管理工作，后者是集群的工作节点群。 15
16.3.1 主控节点 16
主控节点包含apiserver、调度器（Scheduler）和控制器管理器（Controller Manager）。
17
1. apiserver
在apiserver中，我们定义了诸多Kubernetes的核心对象以及它们的操作。这些核心对象包含 18
196 第16章 Kubernetes
Pod注册表（Pod Registry）、控制器注册表（Controller Registry）、服务注册表（Service Registry）、
端点注册表（Endpoint Registry）、从属注册表（Minion Registry）、绑定注册表（Binding Registry）。
在分别说明这些注册表之前，我们先来看看主控节点是如何处理客户端请求的，具体如图16-4
所示。
图16-4 主控节点处理客户端请求的流程
(1) kubectl将用户命令发送给Kubernetes客户端。
(2) Kubernetes客户端将请求发送给apiserver。
(3) apiserver根据请求类型，选择具体的REST存储API对请求进行处理。例如创建Pod，那么
则是Pod Registry存储，并将该值存储于Etcd中。
(4) 在apiserver响应请求之后，调度器会去Kubernetes客户端收集从属节点的节点信息以及Pod