title:Towards Practical Reactive Security Audit Using Extended Static Checkers
author:Julien Vanegue and
Shuvendu K. Lahiri
2013 IEEE Symposium on Security and Privacy
Towards practical reactive security audit using
extended static checkers
Julien Vanegue
Bloomberg L.P.
New York, NY, USA
PI:EMAIL
Shuvendu K. Lahiri
Microsoft Research
Redmond, WA, USA
PI:EMAIL
Abstract—This paper describes our experience of performing
reactive security audit of known security vulnerabilities in core op-
erating system and browser COM components, using an extended
static checker HAVOC-LITE. We describe the extensions made
to the tool to be applicable on such large C++ components, along
with our experience of using an extended static checker in the
large. We argue that the use of such checkers as a conﬁgurable
static analysis in the hands of security auditors can be an effective
tool for ﬁnding variations of known vulnerabilities. The effort has
led to ﬁnding and ﬁxing around 70 previously unknown security
vulnerabilities in over 10 millions lines operating system and
browser code.
Keywords-security audit; program veriﬁcation; static analysis;
extended static checkers
I. INTRODUCTION
Ensuring security of software has become of paramount im-
portance to the software industry. Every software development
group, representing either a small team of developers or an
entire company, mandates extensive testing and analysis to
safeguard against security breaches. However, security ﬂaws
will remain a part of life, at
in the case of legacy
applications that cannot be redesigned from scratch. In such
cases, effective defense mechanisms are required to mitigate
the impact of security vulnerabilities. In particular, ﬁnding all
possible variants of a known security vulnerability can go
a long way in safeguarding the known attack surface of a
software system.
least
The Microsoft Security Response Center (MSRC) identiﬁes,
monitors, resolves, and responds to security incidents and Mi-
crosoft software security vulnerabilities. The following quote
summarizes some of the activities that the team performs in
conjunction with product teams to mitigate future occurrences
of known vulnerabilities that merit security bulletins:1
”...The MSRC engineering team investigates the
surrounding code and design and searches for other
variants of that threat that could affect customers.”
This is an expensive and arduous process that involves a mix
of manual testing, fuzzing and a large amount of manual
security audit. Such audits need to be responsive and timely in
order to prevent attackers from crafting similar attacks in the
near future. We deﬁne the term reactive security audit as this
1http://www.microsoft.com/security/msrc/whatwedo/updatecycle.aspx
process of performing effective audit for variants of known
vulnerabilities, over a large code base. Although the current
practices are effective, they leave a lot to be desired in terms
of scalability and conﬁdence obtained after the reviews.
In this work, we explore the use of extended static checking
tools towards improving the productivity of auditors perform-
ing reactive security audit, and increasing the conﬁdence of the
audit2. Extended static checking tools (such as ESC/Java [1],
HAVOC [2]) offer a potential to develop conﬁgurable static
analysis tools with high coverage guarantees. These tools
provide the user the ability to write contracts (speciﬁcations
of procedures) in the form of preconditions, postconditions,
assertions and discharge them using modern Satisﬁability
Modulo Theories (SMT) solvers [3]. The semantics of the
source language is precisely deﬁned once by the tool (and does
not vary by the property being checked), and the assumptions
are well documented. Many such tools are also equipped
with simple yet robust user-guided contract inference tools
(such as Houdini [4]) to reduce the manual overhead of
writing simple intermediate contracts. Unlike full functional
correctness veriﬁers (such as VCC [5]), they make pragmatic
assumptions to reduce the complexity of proofs, and provide
a lot more automation in the form of inference. Although the
use of extended static checkers had been proposed for ensuring
security a decade back [6], not much success has been reported
in practical usage. Our conjecture is that the absence of a
usable, robust and scalable tool for the space of core operating
system and browser implementations has been one of the main
causes for the lack of adoption.
In this paper, we present a case study of using an extended
static checker HAVOC-LITE3 for checking variants of security
vulnerabilities in Microsoft Windows and Internet Explorer.
We document the challenges encountered in deploying the pre-
vious version of the tool (henceforth called HAVOC) and the
extensions needed to apply the tool in a realistic setting. The
extensions include modeling most common C++ language fea-
tures used typically in such applications, scaling the contract
inference to be applicable to modules with several hundred
thousand procedures, and early annotation validation. We then
2The work was done when the ﬁrst author was employed at Microsoft.
3HAVOC-LITE is the new version of HAVOC [2] developed to meet the
needs of this deployment.
1081-6011/13 $26.00 © 2013 IEEE
DOI 10.1109/SP.2013.12
33
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:54:10 UTC from IEEE Xplore.  Restrictions apply. 
typedef
s t r u c t
s t r u c t
tagVARIANT {
tagVARIANT {
VARTYPE v t ;
union {
. . .
SAFEARRAY ∗ p a r r a y ;
BYTE ∗ pbVal ;
. . .
PVOID b y r e f ;
. . .
} ;
} ;
} VARIANT ;
bool
t1good ( ) {
VARIANT v ;
v . v t = VT ARRAY;
v . p a r r a y = 0 ;
return true ;
bool
t 1 b a d ( ) {
VARIANT v ;
v . v t = VT ARRAY;
v . pbVal = 0 ;
return true ;
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
present our experience of security engineers using the tool on
several properties devised as a response to several existing
vulnerabilities. Over the course of one year, the effort led to
discovering and ﬁxing around 70 previously unknown security
vulnerabilities in over 10 million lines of production code. We
discuss the effort involved in modeling, performing inference
of annotations and dealing with false alarms encountered along
the way. We conclude that in spite of the current limitations,
such a tool can be (and already is) quite cost-effective in
complementing existing efforts based on fuzzing and manual
audit. We conjecture that it can improve the productivity of
security auditors who invest in implementing ad-hoc tools to
aid their manual audit.
The rest of the paper is organized as follows:
1) In Section II, we present an overview of our approach
using two simpliﬁed examples. The examples illustrate
some of the challenges posed when analyzing low-level
systems code, a brief summary of the modeling effort,
dealing with object-oriented features and the use of
annotation inference.
2) In Section III, we provide a brief description of the
existing tool HAVOC that has been applied to large
Windows modules to ﬁnd errors. In Section IV, we
describe the main shortcomings of HAVOC that limited
its application for our problem domain. We describe
the design of HAVOC-LITE that includes modeling an
expressive subset of C++ features, scaling the annotation
inference by using a two-level algorithm that avoids
memory blowup for large modules, along with other
features required for making the tool robust and usable
in the hands of security auditors.
3) In Section V, we describe the effort of applying
HAVOC-LITE on the core OS and browser compo-
nents. We discuss the properties that were modeled as
variants of existing security vulnerabilities, candidate
annotations required for inferring intermediate annota-
tions, and some representative errors. We show the need
for various pragmatic decisions (such as dealing with
unsound modiﬁes clause) to trade off soundness for cost-
effectiveness of the analysis. We highlight the effort
required in devising the inference to reduce false alarms
and the payoff over the different properties.
4) In Section VI, we discuss other related static analysis
tools, and ﬁnally conclude in Section VII.
II. MOTIVATING EXAMPLES
In this section, we introduce two concrete examples con-
taining commonly found programming style in C++ and COM
(Component Object Model [7]) applications. These examples
can only be precisely analyzed if the semantics of bit-level
manipulations are properly modeled,
the common object-
oriented and interface-oriented programming are well handled
by the extended static checker.
34
}
}
}
bool
t2good ( ) {
VARIANT v ;
v . v t = VT BYREF | VT UI1 ;
f u n c u s e v f i e l d (&v ) ;
return true ;
}
void f u n c u s e v f i e l d (VARIANT ∗v ) {
}
v−>pbVal = 0 ;
bool
t2good2 ( ) {
VARIANT v ;
f u n c s e t v t (&v ) ;
v . pbVal = 0 ;
return true ;
}
void f u n c s e t v t (VARIANT ∗v ) {
v−>v t = VT BYREF ;
v−>v t
|= VT UI1 ;
Fig. 1. Example of analysis requiring inter-procedural bit-level reasoning
A. Example 1: Inter-procedural and bit-precise reasoning
The ﬁrst example shows a generic container data structure
called a VARIANT and commonly used in C++/COM applica-
tions. This structure contains a special ﬁeld vt and a union of
data attributes. The value of the vt ﬁeld indicates the union
ﬁeld that is correctly initialized. Failure to check the value
of the vt ﬁeld can lead to using the wrong union ﬁeld and
therefore may use a pointer ﬁeld with an invalid integer value.
Such mistake is likely to lead to a security vulnerability (such
as in functions t1bad). The check for the vt ﬁeld and the
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:54:10 UTC from IEEE Xplore.  Restrictions apply. 
use of the associated union ﬁeld are often done in separate
functions (such as in t2good and t2good2). Therefore,
constraints must be adequately propagated inter-procedurally
to avoid false positives from static analysis warnings. In
addition, since the vt attribute is a bit ﬁeld, bit-level program
semantics needs to be supported by the static checker. Finally,
a user needs to be able to document the desired property
by checking each dereference of the set of ﬁelds (such as
pbarray, pbVal) under consideration. Such features are
supported by HAVOC-LITE and was used to ﬁnd multiple
security vulnerabilities in a critical browser component.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
# i n c l u d e 
# i n c l u d e "havoc.h"
/∗ F i e l d i n s t r u m e n t a t i o n s ∗ /
r e q u i r e s ( v−>v t == VT ARRAY)
i n s t r u m e n t w r i t e p r e ( v−>p a r r a y )
void
i n s t r u m e n t w r i t e a r r a y (VARIANT ∗v ) ;
r e q u i r e s ( v−>v t == (VT BYREF| VT UI1 ) )
i n s t r u m e n t w r i t e p r e ( v−>pbVal )
i n s t r u m e n t w r i t e p b v a l (VARIANT ∗v ) ;
void
/∗ Func i n s t r u m e n t a t i o n s w i t h c a n d i d a t e s ∗ /
c a n d r e q u i r e s ( v−>v t == (VT BYREF| VT UI1 ) )
c a n d r e q u i r e s ( v−>v t == VT ARRAY)
c a n d e n s u r e s ( v−>v t == (VT BYREF| VT UI1 ) )
c a n d e n s u r e s ( v−>v t == VT ARRAY)
i n s t r u m e n t u n i v e r s a l
i n s t r u m e n t u n i v e r s a l
t y p e ( v )
i n c l u d e ( "*" )
i n s t r u m e n t c a n d v a r i a n t (VARIANT ∗v ) ;
void
Fig. 2. Annotations for the ﬁrst example.
Figure 2 shows the annotations written by the user to
create a checker for this property. There are two parts to the
annotations: (a) devising the property and (b) creating an inter-
procedural inference.
are
reads
The
“Field
instrumentations”
the method can be arbitrary except
instrumentations
to particular
provided to insert an assertion at
the instrumentation provided using
ﬁelds. For example,
name
__instrument_write_array method
the preﬁx
of
__instrument_)
to the
ﬁeld parray in the structure VARIANT is preceded
by (“write_pre”) an assertion that
the vt ﬁeld in
the structure equals the value VT_ARRAY. There is a
similar check before writes to the pbVal ﬁeld using the
instrumentation __instrument_write_pbVal. These
two instrumentations allow the user to document the property
to be checked.
every write
speciﬁes
(the
for
that
We now look at how the user can conﬁgure the inter-
procedural annotation inference. The “Func instrumentations”
are used to write annotations on a set of methods, instead
35
a
takes
that
instrumented.
any method
is
that
VARIANT *
of
listing each individual method. The instrumentation
primitive
__instrument_universal_type
speciﬁes
parameter
of
type
ﬁlter
__instrument_universal_include can
used
to restrict
the instrumentation to only methods whose
names match a particular pattern — in this case, the wild-
card pattern “*” matches any method. The annotations in
__cand_requires and __cand_ensures are candidate
preconditions and postconditions. These candidates are fed to
the inter-procedural annotation inference engine that infers
a subset of them as annotations that actually hold on every
context.
The