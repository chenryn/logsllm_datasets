## 总结今天我主要和你分享了移动 App的持续交付生命周期的几个主要部分，包括代码及依赖管理、项目信息管理、静态代码检查、构建管理、发布管理、运营管理，以及热修复。然后，我分享了相比于后端服务，移动 App的持续交付体系有哪些不同的地方。比如，项目信息管理、运营管理和热修复，在移动App的交付过程中被提到了更重要的位置；而其他几个主要过程，代码、构建、发布这三部分都因为移动App开发的特性与后端服务相比有所区别，这些区别也是我要在下一篇文章中和你重点分享的内容。
## 思考题对于移动 App的交付来说，版本和信息管理非常重要。你所在的公司是如何管理这些信息的，有哪些可以优化的可能吗？感谢你的收听，欢迎你给我留言。![](Images/69e5b7a8ed8eecd006aa3ce5f76f78af.png){savepage-src="https://static001.geekbang.org/resource/image/55/0a/55b7b7cb930ca733523be64e3a720d0a.jpg"}
# 32 \| 细谈移动APP的交付流水线（pipeline）你好，我是王潇俊。今天我和你分享的主题是：细谈移动 APP的交付流水线（pipeline）。在上一篇文章[《了解移动 App的持续交付生命周期》](https://time.geekbang.org/column/article/23611)中，我和你分享了移动App的整个交付生命周期，并把移动客户端的交付与后端服务的交付方式进行了对比。从中，我们发现移动App 自身的特点，使得其持续交付流程与后端服务存在一定的差异。所以，今天我会在上一篇文章的基础上，和你分享移动 App持续交付中的个性化内容。这些个性化的内容，主要表现在流水线的三个重要环节上：1.  采用与发布快车（Release Train）模式匹配的代码分支管理策略；2.  支持多项目、多组件并行的全新构建通道；3.  自动化发布，完全托管的打包、发布、分发流程。接下来，我就从这三个角度，和你详细聊聊移动 App 的持续交付吧。
## 发布快车模式首先，我先和你说说什么是发布快车。顾名思义，发布快车，就像一列由多节车厢组成的火车，每一节车厢代表一个发布版本，整个火车以一节节车厢或者说一个个版本的节奏，定期向前发车。而工程师们，则会把自己开发完成的功能集成到一节节的车厢上，这样集成在一节车厢的功能代码，就形成了一个新的版本。如图 1 所示，就很好地展示了发布快车的含义。![](Images/10d7ab06069538ae9c00a2ab0a33c295.png){savepage-src="https://static001.geekbang.org/resource/image/c8/d2/c802a0f8f0cf4e57e4854b4e227918d2.png"}```{=html}```图 1 发布快车详解图```{=html}`````{=html}从这张图上，我们可以看到，每个版本（也就是每节车厢）都由多个功能组成。关于发布快车还有三个关键点，容易被误解或者疏忽。**第一个关键点是，并不是说所有开发的功能，都一定要集成到最近的那节车厢、最近的那个版本中**。任何功能都应该按照既定计划，规划纳入到适合的那节车厢、那个版本中。这也是为什么移动端App 的持续交付需要良好的信息管理的原因。**第二个关键点是，我们必须要保证固定间隔的发车时间，每周、每两周都可以，但必须保证每个车厢到点即发**。只有这样，我们才能保证持续交付流水线的持续运行，以及不间断地产出。这里需要注意的是，对于一些特殊的、不规则的发布，我们要把它们归类到热修复的流程，而不是在发布快车中处理。**第三个关键点是，这个过程的最终产物是可以发布到市场的版本，而不是发布到用户侧的版本**。虽然我们把这个发布模式叫作发布快车，但其实它的最终产物是可以发布的待发布版本。所以这个流程完成后的版本没有被正式发布，或出现了部分缺陷无法发布的情况是很正常的，可以被接受。我们并不需要保证每个版本都一定能发布到用户手上。发布快车的发布模式，特别是以上说的三个特性，非常符合移动 App对持续交付的需求，即：分散开发，定期集成，控制发布。所以绝大部分的移动App 团队，都选择采用发布快车的发布方式。那么，如何才能实现这个发布快车模式的真实落地呢？1.  选择与发布快车模式匹配的代码分支策略；2.  改造出与发布快车模式匹配的构建通道；3.  实现发布流程的全自动化。
## 选择与发布快车模式匹配的代码分支策略首先，选择一套与之匹配的代码分支管理策略，否则整个发布快车的实施会非常别扭。我们先一起回顾一下专栏的第4篇文章[《一切的源头，代码分支策略的选择》](https://time.geekbang.org/column/article/10858)。我在这篇文章中介绍的代码分支策略中，Gitlab Flow 与发布快车模式的思想看上去非常接近。那我们不妨推演一下，这个分支策略是否符合我们的需要。首先，项目仓库的初始状态如图 2 所示。这里有一个版本 V1，代码仓库中有 2个分支：Master，是集成分支；Production，是发布分支。![](Images/3a24a98b45d9e62e2cdc6f2ac576c47b.png){savepage-src="https://static001.geekbang.org/resource/image/ad/9c/adc587c19ca50248a589639e3439019c.png"}```{=html}```图 2 项目仓库的初始状态```{=html}```然后，以 V1 的 commit 为基准，建立功能分支 1，并进行开发，如图 3 所示。![](Images/76ae2e064d74c0210dde8aeb050066be.png){savepage-src="https://static001.geekbang.org/resource/image/00/24/006d004b8f4c2fa2d12451ff2de76524.png"}```{=html}```图 3 引入功能分支 1```{=html}```如图 4 所示，功能分支 1 开发完成后，合并入 Master。测试通过之后形成版本V2，V2 就可以作为待发布的产物了。另外，在形成 V2之前，我们可以看到，另外一个功能分支 2也被建立了，但这个功能分支并没有被合并到 Master，所以不会出现在版本 V2中。![](Images/44cf0f3b2a66f0ecc01cc4ddbaf2e3a4.png){savepage-src="https://static001.geekbang.org/resource/image/78/cb/789bece7976130a9722a0ca90acccbcb.png"}```{=html}```图 4 形成版本 2，并引入功能分支 2```{=html}```从图 5 中，我们可以看到，V2 版本后，又出现了一个新的功能分支3，它与功能分支 2 并行开发。这两个功能分支合并入 Master之后，被同时附加到版本 V3 中。![](Images/f4880b569e188182dbc2830cac1072f1.png){savepage-src="https://static001.geekbang.org/resource/image/df/45/dfb010fd678e02dc9065659657c6c745.png"}```{=html}```图 5 引入功能分支 3，并形成版本 3```{=html}```正如以上的几个步骤，如果每个版本都是定时进行构建和打包，那么这样的代码分支管理模型就是一个典型的符合发布快车的物理实现了。
## 全新的构建通道当然，为了发布快车模式的落地，我们只是建立与之配套的代码分支管理策略还远远不够，还需要有配套的构建通道。你可能会问，发布快车模式的落地，为什么还要选择特定的构建通道呢？我先和你说说发布快车，以及与之配套的代码分支策略的弱点都有哪些吧。如果功能分支合入 Master 分支的过程缺乏校验，以及必要的构建检查的话，那么Production分支在进行自动定期构建时，就很容易产生问题，而一旦产生问题，就会错过这个要定期发布的版本。如果这只会影响到一个或少数几个功能的话，还好；但设想一下，如果你要发布一个大版本，由于某个小功能而影响了所有的其他功能，是不是就得不偿失了呢？所以，为了高效的持续交付，我们就必须对构建通道进行一定的改造。![](Images/71c453e084dda3c476704729d335a2f7.png){savepage-src="https://static001.geekbang.org/resource/image/ae/f4/aeb7a2ab53ecb8e2a4d9ebefa63d5bf4.png"}```{=html}```图 6 被改造后的构建通道```{=html}```如图 6 所示，我们会在功能分支合并入 Master 分支前，增加一次构建（MergeCIService），这次构建的作用是保证功能分支的集成是成功的，否则不允许合并；同时，对于一个代码仓库来说，增加的这次构建过程要保证是串行的，即如果这个仓库正有一个合并构建在进行，则后续的合并构建需要等待。这个合并构建过程，保证了 Master 分支上的任何 commit随时都可以成功构建。之后再根据发布快车的要求定期启动版本构建（Auto CIService），就能顺利地得到可测试版本了。构建测试版本之后，流水线还可以继续处理，在 production 分支上打上对应的tag。
## 自动化的发布构建通道建立之后，就是发布了。我在上一篇文章中提到，移动 App的发布与后端服务有所区别。移动 App 的发布，需要特别注意这两点需求：1.  通常在发布到市场之前，会先发布内部，进行针对新功能的内测；2.  通常，为了节省调试信息带来的额外开销，内部发布会采用 debug    包，而正式发布则采用 release 包。但是，从另一方面看，相比于后端服务的发布，移动 App的发布步骤固定，且逻辑相对简单。-   iOS 系统的发布步骤为：构建，导出 ipa 包，记录符号表，备份，上传至    iTC；-   Android 系统的发布步骤为：构建打包，更新渠道标识，签名，保存 mapping    文件，备份，上传至发布点。理解了 iOS 和 Android系统各自的发布步骤，我们就可以很容易地做到发布自动化了。比如，针对 iOS 的版本发布来说，在构建和打包之后，我们可以获取到对应的ipa 包，关联对应的版本信息元数据后，就可以上传到内部的发布站点，供 QA下载测试了；或者上传到 Apple TestFlight 进行公测；当然也可以部署到 AppStore 了。接下来，我就和你详细说说如何做到发布的自动化。你可以使用 Fastlane等类似的工具完成整个发布过程，还可以根据不同发布的渠道定义各自的lane。当然 Fastlane 也可以提供打包等一系列 Action，帮助你完成自动化。    lane :release do 
# 发布到 AppStore  increment_build_number  