●
0 -> IFn.invoke() @ 1
FnEval.invoke()
●
1 -> Runtime.exec() @ 1
Chain
Automated Discovery of Deserialization Gadget Chains
Ian Haken
Step 5: BFS on Call Graph for Chains
Sources
●
AbstractTableModel$ff19274a.hashCode() @ 0
Call Graph
AbstractTableModel$ff19274a.hashCode()
●
0 -> IFn.invoke() @ 1
●
0 -> IFn.invoke() @ 0
FnCompose.invoke()
●
1 -> IFn.invoke() @ 1
●
0 -> IFn.invoke() @ 0
●
0 -> IFn.invoke() @ 1
FnEval.invoke()
●
1 -> Runtime.exec() @ 1
Chain
●
AbstractTableModel...hashCode() @ 0
Automated Discovery of Deserialization Gadget Chains
Ian Haken
Step 5: BFS on Call Graph for Chains
Sources
●
AbstractTableModel$ff19274a.hashCode() @ 0
Call Graph
AbstractTableModel$ff19274a.hashCode()
●
0 -> IFn.invoke() @ 1
●
0 -> IFn.invoke() @ 0
FnCompose.invoke()
●
1 -> IFn.invoke() @ 1
●
0 -> IFn.invoke() @ 0
●
0 -> IFn.invoke() @ 1
FnEval.invoke()
●
1 -> Runtime.exec() @ 1
Chain
Assumption #3: Any method implementation can be jumped to (as long as its 
class is “serializable”)
●
AbstractTableModel...hashCode() @ 0
Automated Discovery of Deserialization Gadget Chains
Ian Haken
Step 5: BFS on Call Graph for Chains
Sources
●
AbstractTableModel$ff19274a.hashCode() @ 0
Call Graph
AbstractTableModel$ff19274a.hashCode()
●
0 -> IFn.invoke() @ 1
●
0 -> IFn.invoke() @ 0
FnCompose.invoke()
●
1 -> IFn.invoke() @ 1
●
0 -> IFn.invoke() @ 0
●
0 -> IFn.invoke() @ 1
FnEval.invoke()
●
1 -> Runtime.exec() @ 1
Chain
Assumption #3: Any method implementation can be jumped to (as long as its 
class is “serializable”)
●
AbstractTableModel...hashCode() @ 0
●
FnCompose.invoke() @ 0
Automated Discovery of Deserialization Gadget Chains
Ian Haken
Step 5: BFS on Call Graph for Chains
Sources
●
AbstractTableModel$ff19274a.hashCode() @ 0
Call Graph
AbstractTableModel$ff19274a.hashCode()
●
0 -> IFn.invoke() @ 1
●
0 -> IFn.invoke() @ 0
FnCompose.invoke()
●
1 -> IFn.invoke() @ 1
●
0 -> IFn.invoke() @ 0
●
0 -> IFn.invoke() @ 1
FnEval.invoke()
●
1 -> Runtime.exec() @ 1
Chain
Assumption #3: Any method implementation can be jumped to (as long as its 
class is “serializable”)
●
AbstractTableModel...hashCode() @ 0
●
FnCompose.invoke() @ 0
●
FnEval @ 1
Automated Discovery of Deserialization Gadget Chains
Ian Haken
Step 5: BFS on Call Graph for Chains
Sources
●
AbstractTableModel$ff19274a.hashCode() @ 0
Call Graph
AbstractTableModel$ff19274a.hashCode()
●
0 -> IFn.invoke() @ 1
●
0 -> IFn.invoke() @ 0
FnCompose.invoke()
●
1 -> IFn.invoke() @ 1
●
0 -> IFn.invoke() @ 0
●
0 -> IFn.invoke() @ 1
FnEval.invoke()
●
1 -> Runtime.exec() @ 1
Chain
Assumption #3: Any method implementation can be jumped to (as long as its 
class is “serializable”)
●
AbstractTableModel...hashCode() @ 0
●
FnCompose.invoke() @ 0
●
FnEval @ 1
●
Runtime.exec() @ 1
Automated Discovery of Deserialization Gadget Chains
Ian Haken
Step 5: BFS on Call Graph for Chains
Sources
●
AbstractTableModel$ff19274a.hashCode() @ 0
Call Graph
AbstractTableModel$ff19274a.hashCode()
●
0 -> IFn.invoke() @ 1
●
0 -> IFn.invoke() @ 0
FnCompose.invoke()
●
1 -> IFn.invoke() @ 1
●
0 -> IFn.invoke() @ 0
●
0 -> IFn.invoke() @ 1
FnEval.invoke()
●
1 -> Runtime.exec() @ 1
Chain
Assumption #3: Any method implementation can be jumped to (as long as its 
class is “serializable”)
●
AbstractTableModel...hashCode() @ 0
●
FnCompose.invoke() @ 0
●
FnEval @ 1
●
Runtime.exec() @ 1
Limitation #2: Chain discovery relies on a list of known “interesting” sinks
Automated Discovery of Deserialization Gadget Chains
Ian Haken
Gadget Inspector supports some customization on the analysis
● What is considered “serializable”?
○
For JRE deserialization, anything implementing java.lang.Serializable
○
For XStream, it depends on the convertors that are enabled
■
And when using custom convertors, it gets even more subtle
○
For Jackson, any class with a no-arg constructor
● What are the deserialization sources (i.e. magic methods)?
○
For Jackson we only start in constructors
● What method implementations should we consider?
○
For JRE deserialization, all implementations in a serializable class
○
For Jackson, depends on annotations and configuration
Deserialization Library Flexibility
OSS Library Results
Automated Discovery of Deserialization Gadget Chains
Ian Haken
Ran Gadget Inspector against the 100 most popular java 
libraries (according to mvnrepository.com and javalibs.com) 
looking for exploits against standard Java deserialization
● It did rediscover several known gadget chains
● Not that many libraries actually have classes implementing 
java.io.Serializable...
○ But there were some interesting new findings!
● Had a handful of false positives but not as many as you’d expect
○ Mostly because reflection is hard to reason about
Results: OSS Library Scans
Automated Discovery of Deserialization Gadget Chains
Ian Haken
commons-collections » commons-collections
38th most popular maven dependency
1. ....corba.se.spi.orbutil.proxy.CompositeInvocationHandlerImpl
  invoke(Object, Method, Object[]) (0)
2. org.apache.commons.collections.map.LazyMap.get(Object) (0)
3. org.apache.commons.collections.functors.InvokerTransformer
  transform(Object) (0)
4. java.lang.reflect.Method.invoke(Object, Object[]) (0)
Results: Old Gadget Chains
https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections1.java
Automated Discovery of Deserialization Gadget Chains
Ian Haken
New Gadget Chains: Clojure
org.clojure » clojure
6th most popular maven dependency
1.
clojure.inspector.proxy$javax.swing.table.AbstractTableModel$ff19274a.hashCode() (0)
2.
clojure.main$load_script.invoke(Object) (1)
3.
clojure.main$load_script.invokeStatic(Object) (0)
4.
clojure.lang.Compiler.loadFile(String) (0)
5.
FileInputStream.(String) (1)
Tweaked this result to invoke clojure.main$eval_opt instead of 
clojure.main$load_script to invoke arbitrary code.
Reported to clojure-dev July 2017, affecting 1.8.0 and all earlier versions. 
Serialization of AbstractTableModel$ff19274a disabled in 1.9.0 release 
(Dec, 2017).
https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Clojure.java
Automated Discovery of Deserialization Gadget Chains
Ian Haken
New Gadget Chains: Scala
org.scala-lang » scala-library
3rd most popular maven dependency
1.
scala.math.Ordering$$anon$5.compare(Object, Object) (0)
2.
scala.PartialFunction$OrElse.apply(Object) (0)
3.
scala.sys.process.processInternal$$anonfun$onIOInterrupt$1
  applyOrElse(Object, scala.Function1) (0)
4.
scala.sys.process.ProcessBuilderImpl$FileOutput$$anonfun$$lessinit$greater$3.apply() (0)
5.
java.io.FileOutputStream.(File, boolean) (1)
Allows you to write/overwrite a file with 0 bytes. 
Possible DoS? Zero-out a blacklist?
https://github.com/JackOfMostTrades/ysoserial/blob/master/src/main/java/ysoserial/payloads/Scala.java
Automated Discovery of Deserialization Gadget Chains
Ian Haken
New Gadget Chains: Scala
1. scala.math.Ordering$$anon$5.compare(Object, Object) (0)
2. scala.PartialFunction$OrElse.apply(Object) (0)
3. scala.sys.process.processInternal$$anonfun$onIOInterrupt$1
  applyOrElse(Object, scala.Function1) (0)
4. scala.sys.process.ProcessBuilderImpl$URLInput$$anonfun$
$lessinit$greater$1.apply() (0)
5. java.net.URL.openStream() (0)
SSRF: Causes application to perform a GET on 
an arbitrary URL.
https://github.com/JackOfMostTrades/ysoserial/blob/master/src/main/java/ysoserial/payloads/Scala.java
Automated Discovery of Deserialization Gadget Chains
Ian Haken
New Gadget Chains: Clojure2
In rerunning Gadget Inspector on the latest release (1.10.0-alpha4) in 
preparation for this presentation, a different entry point was 
discovered:
1. clojure.lang.ASeq.hashCode() (0)
2. clojure.lang.Iterate.first() (0)
3. clojure.main$load_script.invoke(Object) (1)
4. clojure.main$load_script.invokeStatic(Object) (0)
5. clojure.lang.Compiler.loadFile(String) (0)
6. FileInputStream.(String) (1)
Confirmed the same tweak to clojure.main$eval_opt works for 
arbitrary code execution. Affects all releases since 1.8.0.
https://github.com/JackOfMostTrades/ysoserial/blob/master/src/main/java/ysoserial/payloads/Clojure2.java
Netﬂix App Results
Automated Discovery of Deserialization Gadget Chains
Ian Haken
Results: Netﬂix Internal Webapp 1
Potentially dangerous use of Jackson deserialization:
public void doSomething(String body, String queryParam) {
   Object requestObject = objectMapper.readValue(
           body, Class.forName(queryParam));
●
Can only deserialize classes with no-arg constructors
●
The only entry points are no-arg constructors
But still, the app has ~200MB classpath. So maybe there’s something 
there...
Automated Discovery of Deserialization Gadget Chains
Ian Haken
Results: Netﬂix Internal Webapp 1
Potentially dangerous use of Jackson deserialization:
public void doSomething(String body, String queryParam) {
   Object requestObject = objectMapper.readValue(
           body, Class.forName(queryParam));
●
Can only deserialize classes with no-arg constructors
●
The only entry points are no-arg constructors
But still, the app has ~200MB classpath. So maybe there’s something 
there...
Result: A few false positives and nothing very interesting.
Take-away: Remediation is a low priority
Automated Discovery of Deserialization Gadget Chains
Ian Haken
Results: Netﬂix Internal Webapp 2
Used a non-standard deserialization library, 
subject to some unique constraints
● Invokes readResolve() but not readObject()
● Serialized objects do not need to implement Serializable
● Member fields of serialized objects cannot have a $ in the 
name.
○
Non-static inner classes always have an implicit $outer member name.
● No serialization support for arrays or generic maps
● No null member values
Automated Discovery of Deserialization Gadget Chains
Ian Haken
1. com.thoughtworks.xstream.mapper.AbstractAttributeAliasingMapper.readResolve() (0)
2. org.apache.commons.configuration.ConfigurationMap$ConfigurationSet.iterator() (0)
3. ...configuration.ConfigurationMap$ConfigurationSet$ConfigurationSetIterator.() (0)
4. org.apache.commons.configuration.CompositeConfiguration.getKeys() (0)
5. clojure.lang.APersistentMap$KeySeq.iterator() (0)
6. com.netflix.internal.utils.collections.IteratorWrapper$CallableWrapper.iterator() (0)
7. java.util.concurrent.Executors$RunnableAdapter.call() (0)
8. org.apache.commons.exec.StreamPumper.run() (0)
9. org.eclipse.core.internal.localstore.SafeFileOutputStream.close() (0)
10. org.eclipse.core.internal.localstore.SafeFileOutputStream.commit() (0)
11. org.eclipse.core.internal.localstore.SafeFileOutputStream.copy(File, File) (2)
12. java.io.FileOutputStream.(File) (1)
Results: Netﬂix Internal Webapp 2
Automated Discovery of Deserialization Gadget Chains
Ian Haken
Results: Netﬂix Internal Webapp 2
1. com.thoughtworks.xstream.mapper.AbstractAttributeAliasingMapper.readResolve() (0)
2. org.apache.commons.configuration.ConfigurationMap$ConfigurationSet.iterator() (0)
3. ...configuration.ConfigurationMap$ConfigurationSet$ConfigurationSetIterator.() (0)
4. org.apache.commons.configuration.CompositeConfiguration.getKeys() (0)
5. clojure.lang.APersistentMap$KeySeq.iterator() (0)
6. com.netflix.internal.utils.collections.IteratorWrapper$CallableWrapper.iterator() (0)
7. java.util.concurrent.Executors$RunnableAdapter.call() (0)
8. org.apache.commons.exec.StreamPumper.run() (0)
9. org.eclipse.core.internal.localstore.SafeFileOutputStream.close() (0)
10. org.eclipse.core.internal.localstore.SafeFileOutputStream.commit() (0)
11. org.eclipse.core.internal.localstore.SafeFileOutputStream.copy(File, File) (2)
12. java.io.FileOutputStream.(File) (1)
com.thoughtworks.xstream:xstream
commons-configuration:commons-configuration
org.clojure:clojure
netflix:netflix-utils
JRE
org.apache.commons:commons-exec
org.aspectj:aspectjtools
Automated Discovery of Deserialization Gadget Chains
Ian Haken
1. com.thoughtworks.xstream.mapper.AbstractAttributeAliasingMapper.readResolve() (0)
2. org.apache.commons.configuration.ConfigurationMap$ConfigurationSet.iterator() (0)
3. ...configuration.ConfigurationMap$ConfigurationSet$ConfigurationSetIterator.() (0)
4. org.apache.commons.configuration.CompositeConfiguration.getKeys() (0)
5. clojure.lang.APersistentMap$KeySeq.iterator() (0)
6. com.netflix.internal.utils.collections.IteratorWrapper$CallableWrapper.iterator() (0)
7. java.util.concurrent.Executors$RunnableAdapter.call() (0)
8. org.apache.commons.exec.StreamPumper.run() (0)
9. org.eclipse.core.internal.localstore.SafeFileOutputStream.close() (0)
10. org.eclipse.core.internal.localstore.SafeFileOutputStream.commit() (0)
11. org.eclipse.core.internal.localstore.SafeFileOutputStream.copy(File, File) (2)
12. java.io.FileOutputStream.(File) (1)
Results: Netﬂix Internal Webapp 2
Automated Discovery of Deserialization Gadget Chains
Ian Haken
1. com.thoughtworks.xstream.mapper.AbstractAttributeAliasingMapper.readResolve() (0)
2. org.apache.commons.configuration.ConfigurationMap$ConfigurationSet.iterator() (0)
3. ...configuration.ConfigurationMap$ConfigurationSet$ConfigurationSetIterator.() (0)
4. org.apache.commons.configuration.CompositeConfiguration.getKeys() (0)
5. clojure.lang.APersistentMap$KeySeq.iterator() (0)
6. com.netflix.internal.utils.collections.IteratorWrapper$CallableWrapper.iterator() (0)
7. java.util.concurrent.Executors$RunnableAdapter.call() (0)
8. org.apache.commons.exec.StreamPumper.run() (0)
○ is = java.io.StringBufferInputStream
■ buffer = 
○ os = org.eclipse.core.internal.localstore.SafeChunkyOutputStream
■ isOpen = false
■ filePath = /webappdir/foo.jsp
Results: Netﬂix Internal Webapp 2
Automated Discovery of Deserialization Gadget Chains
Ian Haken
● Reflection
○
Most reflection calls are being treated as interesting, leading to FPs
■
E.g. you can control the class but not the method name, or vice-versa
○
Blind spots for call graph enumeration
■
foo.getClass().getMethod(“bar”).invoke(...)
● Assumptions
○
Even minor improvements would allow Gadget Inspector to make better decisions 
around condition satisfiability or virtual method call resolution, leading to fewer 
FPs.
● Limitations
○
Entry points are enumerated using “known tricks.” Original research can still help 
us find lots of other clever ways to construct gadget chains.
○
Sinks with “interesting behavior” are hard-coded. Lots of room to discover and add 
sinks.
Room for Improvement
Automated Discovery of Deserialization Gadget Chains
Ian Haken
      @ianhaken
      https://github.com/JackOfMostTrades
● Automatic discovery for gadget chains is new territory
○ Gadget Inspector is a functional prototype; room for lots of improvement!
○ Gadget Inspector written for Java but techniques apply to other languages
● Gadget Inspector is open source
○ Fork it, submit PRs, or just check it out for more details about how it works
○ https://github.com/JackOfMostTrades/gadgetinspector
● Deserialization vulnerabilities aren’t going away yet
○ Exploits can and will be more complex as time goes on
○ Better tools will help us understand the risk of vulnerabilities
Final Thoughts