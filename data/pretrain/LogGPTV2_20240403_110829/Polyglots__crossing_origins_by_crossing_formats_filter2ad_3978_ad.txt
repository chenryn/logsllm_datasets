pabilities of the format can be extended even further. The
Flash runtime supports bidirectional communication in ac-
cordance with SOP. The embedded Flash inherits the origin
of the PDF document, thus it can request and read any doc-
ument from the originating server. Unlike the XML method,
there are no restrictions on what content can be requested,
thus making it the most versatile of the available communi-
cation methods. The only drawback using this approach is
the signiﬁcant increase in terms of ﬁle size. Even the com-
pact Flash code in Listing 5 will result in a 6 kB Flash ﬁle.
This suggests that this method might be better suited for
the content smuggling scenario in Section 2.3.2, rather than
the syntax injection scenario.
Cross-origin communication in Flash adheres to the same-
origin policy. However, this is not a restriction, since Flash
also supports cross-origin communication via cross-origin re-
source sharing. Using CORS, a web server can relax the SOP
to allow access to speciﬁed content. An attacker can set an
allow-all cross-origin policy, such as in Listing 6, that open
up for two way communication.
Listing 4: PDF using XML for communication
%PDF−
1 0 obj>stream
xml = ’ ]>&x;  ’;
var doc = XMLData . p a r s e ( xml ) ;
getURL ( ’ a t t a c k e r . com/? s e c r e t =’+
doc . saveXML ( ) )
endstream
t r a i l e r >
/ OpenAction
>
>>
>>
Listing 5: Flash code for communication
package {
import
import
p u b l i c
f l a s h . n e t . ∗ ;
f l a s h . d i s p l a y . S p r i t e ;
c l a s s S e c r e t e x t e n d s S p r i t e {
var u : S t r i n g ;
var
var
p u b l i c f u n c t i o n S e c r e t ( ) {
r : URLRequest ;
l : URLLoader ;
u = ’ v u l n e r a b l e . com/ s e c r e t ’ ;
r = new URLRequest ( u ) ;
l = new URLLoader ( r ) ;
l . a d d E v e n t L i s t e n e r ( ’ complete ’ ,
f u n c t i o n ( ) : v o i d {
u = ’ a t t a c k e r . com / ? ’ + r . data ;
r = new URLRequest ( u ) ;
l = new URLLoader ( r ) ;
} ) ;
}}}
Listing 6: Allow-all crossdomain.xml
7604. EVALUATION
This section details the evaluation performed to investi-
gate the prevalence of the vulnerabilities from Section 3. The
evaluation covers various instances of aﬀected components,
such as browsers and PDF interpreters, content sanitization
ﬁlter, and a study of the Alexa top 100 web sites.
4.1 Instances
To better understand how this problem presents itself, a
comparison of browser and reader instances is presented. We
compare all major browsers and two of the most common
readers.
4.1.1 Readers
Section 3 focuses on the Adobe PDF Reader as the at-
tack surface, due to its standing as the most commonly used
reader. To give a comparison, the Google Chrome built-in
PDF reader was selected as it is the default reader to users
of the browser.
As mentioned in Section 2, the browser rely on the reader
plug-in to implement correct security measures, in order to
prevent cross-domain leakage. Unlike Adobe Reader, the
Chrome browser built-in PDF reader refuses to render con-
tent that was served with an inappropriate MIME-type if
the content is delivered across origins. This eﬀectively pre-
vents the attacks in Section 3.
If the Chrome browser is
conﬁgured to use the Adobe Reader plug-in, it will behave
the same as in other browsers and the content will be inter-
preted as PDF.
4.1.2 Browsers
The behavior of cross-domain embedding of PDF resources
is studied in the major browsers, i.e., Firefox, Safari, Opera,
Google Chrome and Internet Explorer. The study shows
that all major browsers are susceptible to the attacks out-
lined in Section 3, with some minor diﬀerences detailed be-
low and summarized in Table 1. In Table 1, ”Yes” for the
columns ”object” and ”embed” indicates that the correspond-
ing tag can be used to embed a PDF document, and for the
column ”Adobe is default” it indicates that Adobe Reader is
commonly the default PDF reader.
Firefox, Safari and Opera.
The browsers, Firefox, Safari and Opera, are all suscep-
tible to the attacks outlined as per Section 3, without any
restrictions or modiﬁcations.
Google Chrome.
Google’s browser, Chrome, has built-in support for dis-
playing PDF documents. The built-in PDF reader is used
by default by the browser, unless it has been explicitly dis-
abled by the user. Certain complex PDF documents can
not be handled by the built-in reader. The built-in reader
will then prompt the user to open the document in Adobe
Reader. As previously noted in Section 4.1.1, the built-in
reader is not vulnerable to attacks. Hence, Chrome is only
susceptible when the Adobe Reader plug-in is used to render
the document.
Internet Explorer.
Microsoft’s browser, Internet Explorer, is susceptible to
the attacks. However, it seems to only support embedding
of PDF documents using the embed tag. This is not a major
object
embed Adobe is default
Firefox
Chrome
Safari
Opera
Internet Explorer
Yes
Yes
Yes
Yes
No
Yes
Yes
Yes
Yes
Yes
Yes
No
Yes
Yes
Yes
Table 1: Comparison of browsers
obstacle in exploiting the vulnerability, as the embed and
object tags are interchangeable in this respect.
4.2 Alexa top 100
We have conducted two studies to evaluate the prevalence
of the problem on popular sites, covering the Alexa top 100
web sites. Because of their dominance on the web, these web
sites are also the most exposed to security threats. The ﬁrst
study covers PDF-based polyglot attacks using syntax in-
jection as the inﬁltration method; the second covers content
smuggling. We refrain from mentioning names of individual
web sites to prevent exploitation before the issues have been
properly dealt with. We are in contact with the maintainers
of the web sites to help mitigate the vulnerabilities.
Syntax injection.
The study is based on supplying the web sites with the
benign minimal PDF in Listing 2, and examining the corre-
sponding responses to this input. The sample contains the
essential keywords and tokens required to perform a syntax
injection based polyglot attack. If these tokens pass through
unaltered, the web site is considered vulnerable. The pro-
cess has been conducted manually and only input parame-
ters on publicly accessible pages, those that do not require
authentication, were tested. Considering that most inputs
are available only to authenticated users, the results sug-
gests that more web sites are likely vulnerable in input that
do require authentication.
The conclusion is that nine web sites out of the hundred
apply insuﬃcient content ﬁltering with respect to the PDF
format. Out of the nine found to be vulnerable; ﬁve were
susceptible to PDF based polyglot attacks, and four applied
insuﬃcient content ﬁltering, but the input was reﬂected in
a way that prevented exploitation, e.g. the header appeared
after 1024 bytes.
Three of the ﬁve vulnerable web sites could also be de-
termined to be vulnerable to traditional XSS attacks in the
same input parameters. The remaining two web sites found
susceptible only to polyglot attacks and not XSS attacks are
of particular interest since they employ proper measures to
protect against XSS attacks, and yet fall short in defeating
this new breed of attacks.
1. The ﬁrst web site reﬂected user input in an inline
JavaScript context, inside a string. To prevent cross-
site scripting in this context, the following measures
were taken: the JavaScript string delimiters and the
backslash character were properly escaped, and the
string ”” was removed. These measures are
suﬃcient to protect against XSS attacks, but do not
prevent an attacker from injecting valid PDF syntax.
2. The second web site reﬂected the user input in an
HTML-comment context. The only measure taken
761to prevent XSS attacks in this context was removing
any occurrence of the character sequence ”–>”. Again,
while successfully preventing XSS attacks, this mea-
sure is ineﬀective in preventing an attacker from in-
jecting PDF syntax.
Content smuggling.
Further, a smaller study was conducted, not covering the
full Alexa top 100, but targeting popular cloud storage ser-
vices. This study is based on polyglot content being up-
loaded to the service and subsequently analyzed to deter-
mine which origin it was served under. We have found two
major enterprise cloud storage services to be susceptible to
attacks. Both services make an eﬀort to follow current best
practices, see Section 5.2.1, but fail to cover certain scenarios
for content upload.
The ﬁrst service serves almost all uploaded content from
a sandboxed origin; the exception being the user’s avatar
image that are served under the sensitive origin. An attacker
could upload a specially crafted avatar image that, when
embedded as PDF on the attackers web site, can access and
modify the contents of the victim’s cloud storage.
The second service lets the user publish a public link to an
HTML representation of the content. The content is served
under the sensitive origin and is therefore carefully processed
to prevent generation of malicious HTML, but fails to take
other formats into account. A specially crafted ﬁle will result
in the generation of valid PDF syntax that, when embedded
as PDF on the attackers web site, can access and modify the
contents of the victim’s cloud storage.
We are currently advising both service providers to help
mitigate these vulnerabilities.
5. MITIGATION
This section gives advice on various mitigation approaches
available for each of the aﬀected components, both server-
side and client-side. We provide one general mitigation ap-
proach that covers a signiﬁcant segment of the potential at-
tack vectors, and provide speciﬁc mitigation suggestions for
aﬀected components.
Although some of the mitigation suggestions below are
already in place (e.g., the Chrome builtin PDF reader), the
state of the art is far from being satisfactory. As our paper
demonstrates, the polyglot attacks are a real threat. It is
the paper’s main value to bring attention to polyglot attacks
and the importance of mitigation against them.
5.1 General approach
It should be noted that preventing polyglots, and thereby
polyglot attacks, in the general case is a complex task, as
one would need to take all potentially malicious formats in
to account. Mitigating instances of polyglot attacks based
on particular formats are signiﬁcantly more straightforward.
Our approach is not attempting to prevent polyglots as such,
but provide details about the context in which the content
will be interpreted, such that an informed decision can be
made on whether rendering the content constitutes a secu-
rity risk or not.
The relation between web server and the browser is central
in a web environment, but there is no common agreement on
the type of content communicated between server and client.
As mentioned in Section 2.1, in each response the web server
sends a header representing its view on the type of content
delivered, however, the browser is free to ignore the provided
type and can even be instructed to do so. Often the browser
knows precisely the context in which the content will be
rendered and the types suitable for these contexts. As an
example, when content is loaded in an object tag with a type
attribute, as is the case throughout the paper, the browser
already has exact knowledge as to which types the requested
content can be interpreted as in this context. A natural
defense technique is to send the expected types along with
the request. The web server then compares the expected
types to the assumed type and react accordingly, e.g., if the
assumed type is HTML and the expected type is PDF, an
error can be sent back to the client. On the client side,
the browser veriﬁes the type in the response matches any
of the expected types, possibly alerting the user if there
is a mismatch. This mutual agreement between client and
server can help mitigate both syntax injection and content
smuggling. Furthermore, this approach can be implemented
in the web server itself, as opposed to a web application,
since the web server makes the ﬁnal decision on the supplied
content-type.
The expected type is useful also to a web application that
performs content ﬁltering on the ﬂy. At the point when
the content is being requested, it only requires veriﬁcation
against the expected type.
There are limitations to this technique; If a context has