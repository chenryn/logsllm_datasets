Sender ğ‘ƒ2â€™s Inputs: Sets {ğ‘‹ ğ‘—} ğ‘— âˆˆ[ğ›½], where |ğ‘‹ ğ‘— (ğ‘–) | = ğœ for
Output:
â€¢ For each ğ‘— âˆˆ [ğ›½], sample ğ‘¤ ğ‘— uniformly from {0, 1}ğœ.
â€¢ For each ğ‘— âˆˆ [ğ›½], if ğ‘ ğ‘— âˆˆ ğ‘‹ ğ‘—, set ğ‘¦ ğ‘— = ğ‘¤ ğ‘—, else sample ğ‘¦ ğ‘—
uniformly from {0, 1}ğœ.
â€¢ Return {ğ‘¦ ğ‘—} ğ‘— âˆˆ[ğ›½] to ğ‘ƒ1 and {ğ‘¤ ğ‘—} ğ‘— âˆˆ[ğ›½] to ğ‘ƒ2.
Figure 1: Weak PSM Functionality F ğ›½,ğœ,ğ‘
wPSM
We consider three instantiations of this functionality using prim-
itives considered in the line of OPPRFs [51]. We provide details on
instantiations in Appendix B and summarize their costs below.
â€¢ Polynomial-based batch-OPPRF [65]: Instantiating using the
polynomial-based OPPRF from [65] has the concrete communi-
cation cost of 3.5ğœ†ğ›½ + ğ‘ ğœ and round complexity of 2.
â€¢ Table-based OPPRF [51]: The instantiation using table-based
OPPRF [51] assumes an upper-bound on the size of the individual
sets, which is derived specific to its application. Let ğ‘‘ âˆˆ N be
the minimum value such that the aforementioned upper-bound
is bounded by 2ğ‘‘. When we instantiate using the table-based
OPPRF, the concrete communication cost is (4.5ğœ† + 2ğ‘‘ğœ)ğ›½ and
round complexity is 2.
â€¢ Relaxed batch OPPRF: We can instantiate F ğ›½,ğœ,ğ‘
wPSM
functionality
by invoking relaxed batch OPPRF [13] followed5 by an invocation
of table-based OPPRF [51]. The concrete communication of this
case is (8ğœ† + 4ğœ)ğ›½ + 1.31ğ‘ ğœ and round complexity is 4.
Execution Cost: Instantiations of the F ğ›½,ğœ,ğ‘
wPSM
functionality using
the above 3 approaches provide trade-offs between computation
and communication [13, 51, 65]. Due to this, different protocols are
more efficient in different experimental settings as is evident from
the empirical results given in Section 6.
2.5 Multiparty Functionalities
Our protocols invoke several ğ‘›-party functionalities (described
below) in the honest majority setting. The protocols from [21, 52]
can be used to realize these functionalities. Let F(+, Â·) be a finite
field. Let ğ‘› be the number of parties and ğ‘¡  2ğœ is a prime.
Additions and multiplications in the protocol are over the field Fğ‘. Let ğ‘¡ < ğ‘›/2 be the corruption threshold.
Input: Each party ğ‘ƒğ‘– has input set ğ‘‹ğ‘– = {ğ‘¥ğ‘–1, Â· Â· Â· , ğ‘¥ğ‘–ğ‘š}, where ğ‘¥ğ‘– ğ‘— âˆˆ {0, 1}ğœ. Note that element size can always be made ğœ bits by first
hashing the elements using an appropriate universal hash function.
Protocol:
(1) Pre-processing (Randomness generation required for Step (4)): ğ‘ƒ1, Â· Â· Â· , ğ‘ƒğ‘› compute ([ğ‘ 1], Â· Â· Â· , [ğ‘ ğ›½]) â† RandomFğ‘›,ğ‘¡ (ğ›½).
(2) Hashing: Parties agree on hash functions â„1, â„2, â„3 : {0, 1}ğœ â†’ [ğ›½].
(3) Invoking the F ğ›½,ğœ,ğ‘
ğ‘ƒ1 does stash-less cuckoo hashing on ğ‘‹1 using â„1, â„2, â„3 to generate Table1 and inserts dummy elements into empty bins.
For ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}, ğ‘ƒğ‘– does simple hashing of ğ‘‹ğ‘– using â„1, â„2, â„3 into Tableğ‘–, i.e., stores each ğ‘¥ âˆˆ ğ‘‹ğ‘– at locations â„1(ğ‘¥), â„2(ğ‘¥) and
â„3(ğ‘¥). If the three locations are not distinct, insert dummy elements in Tableğ‘–.
â€¢ ğ‘ƒğ‘– is the sender with input {Tableğ‘–[ ğ‘—]} ğ‘— âˆˆ[ğ›½] .
â€¢ ğ‘ƒ1 is the receiver with input {Table1[ ğ‘—]} ğ‘— âˆˆ[ğ›½].
â€¢ ğ‘ƒ1 receives the outputs {ğ‘¦ğ‘– ğ‘—} ğ‘— âˆˆ[ğ›½] and ğ‘ƒğ‘– receives {ğ‘¤ğ‘– ğ‘—} ğ‘— âˆˆ[ğ›½].
wPSM functionality: For each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›} , ğ‘ƒ1 and ğ‘ƒğ‘– invoke the F ğ›½,ğœ,ğ‘
functionality for ğ‘ = 3ğ‘š as follows:
wPSM
(4) Evaluation: For ğ‘— âˆˆ [ğ›½],
â€¢ ğ‘ƒ1 computes âŸ¨ğ‘ ğ‘—âŸ©1 =ğ‘›
ğ‘–=2(âˆ’ğ‘¦ğ‘– ğ‘— mod ğ‘) and for ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}, ğ‘ƒğ‘– sets âŸ¨ğ‘ ğ‘—âŸ©ğ‘– = (ğ‘¤ğ‘– ğ‘— mod ğ‘).
â€¢ ğ‘ƒ1, Â· Â· Â· , ğ‘ƒğ‘› compute [ğ‘ ğ‘—] â† ConvertSharesğ‘›,ğ‘¡ (âŸ¨ğ‘ ğ‘—âŸ©).
â€¢ ğ‘ƒ1, Â· Â· Â· , ğ‘ƒğ‘› invoke the following multiparty functionalities:
â€“ [ğ‘£ ğ‘—] â† MultFğ‘›,ğ‘¡ ([ğ‘ ğ‘—], [ğ‘  ğ‘—]).
â€“ ğ‘£ ğ‘— â† Revealğ‘›,ğ‘¡ ([ğ‘£ ğ‘—]).
(5) Output: ğ‘ƒ1 computes the intersection as ğ‘Œ =

ğ‘— âˆˆ[ğ›½]:ğ‘£ğ‘— =0
Table1[ ğ‘—] , permutes its elements and announces to all parties.
Figure 4: MULTIPARTY PSI PROTOCOL
such that ğ‘ƒ1â€™s output for bin ğ‘— is 0 if and only if Table1[ ğ‘—] belongs
to the intersection. The circuit is as follows: For each ğ‘— âˆˆ [ğ›½], ğ‘ƒ1
adds the negation of the query outputs from its interaction with
each ğ‘ƒğ‘– (for each ğ‘– = 2, Â· Â· Â· , ğ‘›) in Step 3 to get its additive share
âŸ¨ğ‘ ğ‘—âŸ©1 and for each ğ‘– = 2, Â· Â· Â· , ğ‘›, ğ‘ƒğ‘– sets its additive share âŸ¨ğ‘ ğ‘—âŸ©ğ‘– as its
response from the same interaction of Step 3. Observe that, ğ‘ ğ‘— = 0