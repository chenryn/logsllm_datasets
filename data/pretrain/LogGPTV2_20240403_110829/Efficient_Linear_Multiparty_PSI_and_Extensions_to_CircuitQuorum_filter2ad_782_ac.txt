Sender 𝑃2’s Inputs: Sets {𝑋 𝑗} 𝑗 ∈[𝛽], where |𝑋 𝑗 (𝑖) | = 𝜎 for
Output:
• For each 𝑗 ∈ [𝛽], sample 𝑤 𝑗 uniformly from {0, 1}𝜎.
• For each 𝑗 ∈ [𝛽], if 𝑞 𝑗 ∈ 𝑋 𝑗, set 𝑦 𝑗 = 𝑤 𝑗, else sample 𝑦 𝑗
uniformly from {0, 1}𝜎.
• Return {𝑦 𝑗} 𝑗 ∈[𝛽] to 𝑃1 and {𝑤 𝑗} 𝑗 ∈[𝛽] to 𝑃2.
Figure 1: Weak PSM Functionality F 𝛽,𝜎,𝑁
wPSM
We consider three instantiations of this functionality using prim-
itives considered in the line of OPPRFs [51]. We provide details on
instantiations in Appendix B and summarize their costs below.
• Polynomial-based batch-OPPRF [65]: Instantiating using the
polynomial-based OPPRF from [65] has the concrete communi-
cation cost of 3.5𝜆𝛽 + 𝑁 𝜎 and round complexity of 2.
• Table-based OPPRF [51]: The instantiation using table-based
OPPRF [51] assumes an upper-bound on the size of the individual
sets, which is derived specific to its application. Let 𝑑 ∈ N be
the minimum value such that the aforementioned upper-bound
is bounded by 2𝑑. When we instantiate using the table-based
OPPRF, the concrete communication cost is (4.5𝜆 + 2𝑑𝜎)𝛽 and
round complexity is 2.
• Relaxed batch OPPRF: We can instantiate F 𝛽,𝜎,𝑁
wPSM
functionality
by invoking relaxed batch OPPRF [13] followed5 by an invocation
of table-based OPPRF [51]. The concrete communication of this
case is (8𝜆 + 4𝜎)𝛽 + 1.31𝑁 𝜎 and round complexity is 4.
Execution Cost: Instantiations of the F 𝛽,𝜎,𝑁
wPSM
functionality using
the above 3 approaches provide trade-offs between computation
and communication [13, 51, 65]. Due to this, different protocols are
more efficient in different experimental settings as is evident from
the empirical results given in Section 6.
2.5 Multiparty Functionalities
Our protocols invoke several 𝑛-party functionalities (described
below) in the honest majority setting. The protocols from [21, 52]
can be used to realize these functionalities. Let F(+, ·) be a finite
field. Let 𝑛 be the number of parties and 𝑡  2𝜎 is a prime.
Additions and multiplications in the protocol are over the field F𝑝. Let 𝑡 < 𝑛/2 be the corruption threshold.
Input: Each party 𝑃𝑖 has input set 𝑋𝑖 = {𝑥𝑖1, · · · , 𝑥𝑖𝑚}, where 𝑥𝑖 𝑗 ∈ {0, 1}𝜎. Note that element size can always be made 𝜎 bits by first
hashing the elements using an appropriate universal hash function.
Protocol:
(1) Pre-processing (Randomness generation required for Step (4)): 𝑃1, · · · , 𝑃𝑛 compute ([𝑠1], · · · , [𝑠𝛽]) ← RandomF𝑛,𝑡 (𝛽).
(2) Hashing: Parties agree on hash functions ℎ1, ℎ2, ℎ3 : {0, 1}𝜎 → [𝛽].
(3) Invoking the F 𝛽,𝜎,𝑁
𝑃1 does stash-less cuckoo hashing on 𝑋1 using ℎ1, ℎ2, ℎ3 to generate Table1 and inserts dummy elements into empty bins.
For 𝑖 ∈ {2, · · · , 𝑛}, 𝑃𝑖 does simple hashing of 𝑋𝑖 using ℎ1, ℎ2, ℎ3 into Table𝑖, i.e., stores each 𝑥 ∈ 𝑋𝑖 at locations ℎ1(𝑥), ℎ2(𝑥) and
ℎ3(𝑥). If the three locations are not distinct, insert dummy elements in Table𝑖.
• 𝑃𝑖 is the sender with input {Table𝑖[ 𝑗]} 𝑗 ∈[𝛽] .
• 𝑃1 is the receiver with input {Table1[ 𝑗]} 𝑗 ∈[𝛽].
• 𝑃1 receives the outputs {𝑦𝑖 𝑗} 𝑗 ∈[𝛽] and 𝑃𝑖 receives {𝑤𝑖 𝑗} 𝑗 ∈[𝛽].
wPSM functionality: For each 𝑖 ∈ {2, · · · , 𝑛} , 𝑃1 and 𝑃𝑖 invoke the F 𝛽,𝜎,𝑁
functionality for 𝑁 = 3𝑚 as follows:
wPSM
(4) Evaluation: For 𝑗 ∈ [𝛽],
• 𝑃1 computes ⟨𝑎 𝑗⟩1 =𝑛
𝑖=2(−𝑦𝑖 𝑗 mod 𝑝) and for 𝑖 ∈ {2, · · · , 𝑛}, 𝑃𝑖 sets ⟨𝑎 𝑗⟩𝑖 = (𝑤𝑖 𝑗 mod 𝑝).
• 𝑃1, · · · , 𝑃𝑛 compute [𝑎 𝑗] ← ConvertShares𝑛,𝑡 (⟨𝑎 𝑗⟩).
• 𝑃1, · · · , 𝑃𝑛 invoke the following multiparty functionalities:
– [𝑣 𝑗] ← MultF𝑛,𝑡 ([𝑎 𝑗], [𝑠 𝑗]).
– 𝑣 𝑗 ← Reveal𝑛,𝑡 ([𝑣 𝑗]).
(5) Output: 𝑃1 computes the intersection as 𝑌 =

𝑗 ∈[𝛽]:𝑣𝑗 =0
Table1[ 𝑗] , permutes its elements and announces to all parties.
Figure 4: MULTIPARTY PSI PROTOCOL
such that 𝑃1’s output for bin 𝑗 is 0 if and only if Table1[ 𝑗] belongs
to the intersection. The circuit is as follows: For each 𝑗 ∈ [𝛽], 𝑃1
adds the negation of the query outputs from its interaction with
each 𝑃𝑖 (for each 𝑖 = 2, · · · , 𝑛) in Step 3 to get its additive share
⟨𝑎 𝑗⟩1 and for each 𝑖 = 2, · · · , 𝑛, 𝑃𝑖 sets its additive share ⟨𝑎 𝑗⟩𝑖 as its
response from the same interaction of Step 3. Observe that, 𝑎 𝑗 = 0