# 恶意代码分析之动静结合第一节
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
###  0x00 前言
经过了前面几节的静态分析，相信大家已经对静态分析已经有了比较深刻的理解。
应该可以比较熟练的阅读一些恶意代码中常见的汇编指令了。
在这一小节继续看一个新样本，尝试动静结合的方式来进行分析。
首先，样本还是上传到了app.any.run上：
样本hash：ae986dd436082fb9a7fec397c8b6e717
app.any.run地址：
## 0x01 行为分析
将样本下载到本地之后，首先我们在虚拟机中将样本添加exe的后缀，发现样本的图标显示如下：
在本次行为分析中，我选择使用的是火绒剑
启动火绒剑之后，开启监控，然后选择进程过滤
将我们的进程名称添加进去
接着选择动作过滤，暂时不显示注册表操作：
接着运行该恶意样本，样本运行后，会弹出如下的对话框进行提示
该对话框告诉用户，啊我是杀毒软件ESET的更新程序，我现在更新完成了，你的电脑安全啦。
BUT，经验告诉我们，未知程序运行后的对话框、提示框啥的，一个标点符号都不要信。
本样本模仿了ESET杀软弹框，主要目的就是为了迷惑用户，让用户误以为启动的是一个干净的应用程序
除了伪装成杀软迷惑用户，恶意软件还尝尝会伪装成微软官方、office官方等权威机构进行提示以迷惑用户，在分析的时候需要注意此类提示信息。
此时，在火绒剑窗口中，已经显示本程序的所有行为：
蓝色部分很醒目，火绒剑自动标识出了三个可疑行为。
第一个是BA_extract_pe 根据缩写我们可以知道，这个动作表示释放PE文件。
结合上面的file_touch、file_open、file_write、file_chmod等操作，我们可以知道程序会在C:UsersxxxAppDataRoaming这个路径下释放一个名为eset_update.exe的PE文件。
第二个是BA_self_copy 表示自我复制
第三个是BA_register_autorun 表示应用程序通过注册表将自己写入了开机自启动。
我们可以在这个目录下找到对应的文件
顺便说一句，这个目录是一个系统环境变量路径，可以通过%appdata%访问到
除了文件相关的行为，我们继续往下看，还可以看到网络请求相关行为：
根据火绒剑和Fakenet的监控显示，本地主机(192.168.74.128:53)正在不断的向目标主机general-second.org-help.com发起请求。
这是一个非常关键的网络行为，general-second.org-help.com应该就是攻击者服务器的地址。
上次已经使用过了微步，这次我们使用奇安信的查询试试
通过奇安信的情报平台([https://ti.qianxin.com)对该地址进行查询：](https://ti.qianxin.com\)%E5%AF%B9%E8%AF%A5%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%EF%BC%9A)
可以看到，确实是恶意的C2地址，且被打上了很多标签
根据标签显示，该域名很有可能被APT组织KimSuky所使用，所以该样本，很有可能来源以APT组织KimSuky。
通过行为分析，我们已经可以基本确定样本的一个行为信息：
  1. 样本会将自身复制到%appdata%路径下并且重命名为eset_update.exe
  2. 样本会向general-second.org-help.com进行请求。  
我们可以根据这些信息，在IDA中进行快速定位。
## 0x02 完整分析
行为分析之后，一般会通过IDA对样本进行一个整体的分析，毕竟在IDA中看代码，还是会比在调试器中看代码要快很多。
我们在IDA中对样本进行概要的标注之后，即可通过调试器对标注的地方进行快速的验证。
IDA分析的流程主要还是
  1. 导入表分析
  2. 字符串分析
  3. 代码分析（通常从Start函数或者WinMain开始）
###  导入表分析
使用IDA加载样本，然后切换到Imports窗口中：
导入表中一共有124个API函数，我这里圈出了一些可疑的API。
首先是Reg操作相关的API，恶意软件通常会通过注册表实现一系列的恶意操作，如设置开机自启动、获取一些计算机的基本信息。
除了注册表相关的API，还有CreateFile、GetFileSize、ReadFile等文件操作的API。
这里应该就是通过这些API实现文件的拷贝。
CreateProcessA通常用于创建新进程。
在最下面还有一系列用于网络请求的API
同样的，我们可以对觉得可疑的API双击跟进去，然后交叉引用查找调用位置。
比如我对InternetOpen进行交叉引用，一层一层往上找，最后可以发现通过WinMain函数中StartAddress的sub_401AA0调用，可以来到网络请求的地方。我们可以对sub_401AA0进行初步的标注：
我们可以对导入表中可疑的API进行交叉引用并标注上层、上上层、上上上层的调用位置。
使用同样的方法，对文件操作的API也进行交叉引用。
经过交叉引用发现，文件操作也在sub_401AA0函数中，说明sub_401AA0是一个大函数，等会会是我们分析的重点。
###  字符串分析
通过shift + f12打开字符串窗口
字符串表一共203个字符串，其中大部分看起来都比较正常。
在字符串表后半部分，可以看到如下与网络请求相关的信息。
以及重命名的文件名称：eset_updata.exe
我们可以对eset_update.exe进行交叉引用，最后确定在WinMain的sub_403600中进行了引用。
同时，我们可以尝试在字符串窗口中搜索我们先前看到的URL地址。但是没有结果，说明该地址是动态解密出来进行请求的。
字符串分析基本上也可以告一段落，接下来开始看代码。
###  WinMain分析
默认情况下，vc编译的应用程序入口点在WinMain函数。
通过IDA加载的时候，如果程序有WinMain，也会默认停留在该函数。
按下空格键将其转换为正常汇编代码显示
程序最开始会通过CreateMutex尝试创建一个名为的互斥体，接着通过GetLastError获取最后一次错误，这里如果获取到的值不是563h(十进制1379)则跳转到后面的loc_40336C继续执行，否则就退出WinMain，结束进程。
通过查询，我们可以得知GetLastError获取到1379表示本地组已经存在：
我猜这里是攻击者写错了，按道理来讲，这里会判断GetLastError的值是否等于ERROR_ALREADY_EXISTS
这里判断是否等于1379没有实际的意义，不能起到防多开的作用。
经过后来的测试也可以发现，该样本的确可以在本地主机进行多开。
跳转到loc_40336C之后，程序首先会执行call sub_4011E0。
###  sub_4011E0
进入到sub_4011E0，程序会先判断dword_41F924的值是否为0，如果等于0则跳转到loc_40120F继续执行，且这里我们可以看到，在下面0040121F的地方，程序通过mov
dword_41F924,1的方式给dword_41F924赋值为1。所以我们可以知道这里是程序首次运行的时候才会执行的代码。
接着往下看，我们可以直接看下一个跳转的条件，这里是判断LoadLibraryA是否成功加载了制定的库文件。
库文件来源于[ebp+LibFileNmae]
而[ebp+LibFileNmae]在上面赋值给了edx，和ecx一起传到了sub_401040这个函数中。
我们看到ecx的值来源于后面的”NSNSJY3iqq”
所以我们可以猜测sub_401040是一个解密函数，会将后面这个参数解密之后存放到前面那个参数的地址中。
直接上调试器验证一下，我们在win7中使用x32dbg加载该程序。
程序加载之后，会默认停留在ntdll.dll模块中，也就是系统代码中，这里我们直接F9跑到程序的默认入口点