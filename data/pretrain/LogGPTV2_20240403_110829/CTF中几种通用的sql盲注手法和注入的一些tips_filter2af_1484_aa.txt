# CTF中几种通用的sql盲注手法和注入的一些tips
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
在ctf比赛中难免会遇到一些比较有(keng)趣(die)的注入题，需要我们一步步的绕过waf和过滤规则，这种情况下大多数的注入方法都是盲注。然而在盲注过程中由于这些过滤规则不太好绕过，这时候就会无从下手，下面分享一下自己在比赛中总结几种比较通用的盲注手法和一些小tips，希望能在今后大家的比赛或者实战中带来一些实质性的帮助。
## 0x01 XOR注入
> 因为这种方法利用了异或符号，所以给它取名为xor注入
###  1、基本注入payload
    admin'^(ascii(mid((password)from(i)))>j)^'1'='1'%23
    或者
    admin'^(ascii(mid((password)from(i)for(1)))>j)^'1'='1'%23
我们来分析一下这个语句的格式：
首先我们先根据^符号来分割开语句：
    admin'
    ascii(mid((password)from(i)))>j
    '1'='1'%23
最前面和最后面的语句都固定为真（逻辑结果都为1），只有中间的语句不确定真假  
 **那么整个payload的逻辑结果都由中间的语句决定** ，我们就可以用这个特性来判断盲注的结果了
    0^1^0 --> 1 语句返回为真
    0^0^0 --> 0 语句返回为假
这里mid函数的使用方法：
正常的用法如下，对于str字符串，从pos作为索引值位置开始，返回截取len长度的子字符串
    MID(str,pos,len)
这里的用法是， **from(1)表示从第一个位置开始截取剩下的字符串，for(1)表示从改位置起一次就截取一个字符**
    mid((str)from(i))
    mid((str)from(i)for(1))
看下图的查询结果应该就知道用法了：  
这里可能还会有疑问：为什么这里不加for可以正常运行呢？
> 因为这里的ascii函数是默认取字符串中第一个字符的ascii码做为输出
###  2、使用场景
> 过滤了关键字：and、or  
>  过滤了逗号，  
>  过滤了空格
**如果这里过滤了=号的话，还可以用 >或者j)^('2'>'1')%23
**如果这里过滤了%号和注释符的话，那就把最后一个引号去掉就可以和后面的引号匹配了 ‘1’=’1**
## 0x02 regexp注入
###  1、基本注入payload
`select (select语句) regexp '正则'`
下面举一个例子来说明一下用法：
首先正常的查询语句是这样：
`select user_pass from users where user_id = 1`
接着进行正则注入，若匹配则返回1，不匹配返回0
    select (select user_pass from users where user_id = 1) regexp '^a'
这里的^表示pattern的开头
接着一步步判断
或者regexp这个关键字还可以代替where条件里的=号
    select * from users where user_pass regexp '^a9'
###  2、使用场景
> 过滤了=、in、like
这里的^如果也被过滤了的话，可以使用$来从后往前进行匹配
详细的正则注入教程可以看这里：  
## 0x03 order by盲注
###  1、基本注入payload
    select * from users where user_id = '1' union select 1,2,'a',4,5,6,7 order by 3
首先先看看order by的使用方法：
    order by 'number' (asc/desc)
即对某一列进行排序， **默认是升序排列** ，即后面默认跟上asc，那么上面一句就相当于
    select * from users order by 3 asc
我们在注入时经常会使用order by来判断数据库的列数，那我们这里使用他配合union select来进行注入
###  2、原理分析
首先正常的注入是蓝色那部分的字符串，这里我们的目的是要注出test用户的user_pass值  
 **接着我们在语句后面加上order by 3，即对第三列进行升序排列(按照ascii码表)**  
这里的user_pass列中的3是我们union select里面的第三列，这里就把’3’替换为’a’  
这里可能看不出什么变化，那么把他改成’b’看看  
看到用户test跑到第一行来了，所以这里经常用来判断有返回差异的注入，且返回只有一列的输出，根据差异来判断我们盲注的值是否正确
当然这里也可以使用order by desc降序排列来注入，所以这里要根据使用场景来进行选择
###  3、使用场景
> 过滤了列名  
>  过滤了括号  
>  适用于已知该表的列名以及列名位置的注入
## 0x04 实例讲解
1、ascii盲注来自skctf login3的一道题，bugku上也有：
题目链接：  
是标准的登陆框，因为存在注入，先fuzz一下过滤了什么字符。使用bp的intruder模块载入字典进行fuzz(字典在后面会分享给大家)。  
可以看到这里的=，空格、and、or都被过滤了，但是>、1)^('2'>'1')%23
**网鼎杯第二场的一道注入题sqlweb的其中一种解法也是用到这种ascii盲注**  
这个payload和我们上面说的是一样的，所以这个就靠你们自己慢慢消化了。
2、regexp盲注是来自实验吧一道注入题
题目链接：  
writeup链接：  
当初也是看着p牛的wp做的，发现这道虽然难了点，但是里面的sql的知识点考的倒是不错，是练习过waf的一道好题目。
这道题只有一个id作为输入点，id存在注入点，但是过滤了很多东西，前面的步骤就不详细说了，去看p牛的详细解答  
看到这里，过滤了^，但是没过滤$，所以xor注入就无效了，这边选择regexp注入使用$符号从后往前注入
    0' or (select (select fl$4g from fiag limit 1) regexp '%s$') or 'pcat'='
这里是用python写的脚本，一个一个的对字符串的正则匹配得到最后flag
3、union盲注利用起来比较简单，就是利用上面说的那些条件进行注入，例子是来自蓝鲸ctf的一道ctf题目：
题目链接：
题目好像进不去了，但是可以看[我的writeup](http://note.youdao.com/noteshare?id=94ae1c287b7d49a55a7590f1b826df17&sub=4621B6951500439F8D75AF9E8A77A0E2)  