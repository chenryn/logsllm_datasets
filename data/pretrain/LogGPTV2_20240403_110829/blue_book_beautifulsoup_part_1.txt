---
title: BeautifulSoup
date: 20220518
author: Lyz
---
[BeautifulSoup](https://beautiful-soup-4.readthedocs.io/en/latest/) is a Python
library for pulling data out of HTML and XML files. It works with your favorite
parser to provide idiomatic ways of navigating, searching, and modifying the
parse tree.
```python
import requests
from bs4 import BeautifulSoup
request = requests.get('{{ url }}')
soup = BeautifulSoup(request.text, "html.parser")
```
Here are some simple ways to navigate that data structure:
```python
soup.title
# The Dormouse's story
soup.title.name
# u'title'
soup.title.string
# u'The Dormouse's story'
soup.title.parent.name
# u'head'
soup.p
# The Dormouse's story
soup.p['class']
# u'title'
soup.a
# Elsie
soup.find_all('a')
# [Elsie,
#  Lacie,
#  Tillie]
soup.find(id="link3")
# Tillie
```
# Installation
```bash
pip install beautifulsoup4
```
The default parser `html.parser` doesn't work with HTML5, so you'll probably
need to use the `html5lib` parser, it's not included by default, so you might
need to install it as well
```bash
pip install html5lib
```
# Usage
## [Kinds of objects](https://beautiful-soup-4.readthedocs.io/en/latest/#kinds-of-objects)
Beautiful Soup transforms a complex HTML document into a complex tree of Python
objects. But you’ll only ever have to deal with about four kinds of objects:
`Tag`, `NavigableString`, `BeautifulSoup`, and `Comment`.
### Tag
A `Tag` object corresponds to an XML or HTML tag in the original document:
```python
soup = BeautifulSoup('Extremely bold')
tag = soup.b
type(tag)
# 
```
The most important features of a tag are its `name` and `attributes`.
#### Name
Every tag has a `name`, accessible as `.name`:
```python
tag.name
# u'b'
```
If you change a tag’s name, the change will be reflected in any HTML markup
generated by Beautiful Soup:.
```python
tag.name = "blockquote"
tag
# Extremely bold
```
#### Attributes
A tag may have any number of attributes. The tag `` has an
attribute `id` whose value is `boldest`. You can access a tag’s attributes by
treating the tag like a dictionary:
```python
tag['id']
# u'boldest'
```
You can access that dictionary directly as `.attrs`:
```python
tag.attrs
# {u'id': 'boldest'}
```
You can add, remove, and modify a tag’s attributes. Again, this is done by
treating the tag as a dictionary:
```python
tag['id'] = 'verybold'
tag['another-attribute'] = 1
tag
# 
del tag['id']
del tag['another-attribute']
tag
# 
tag['id']
# KeyError: 'id'
print(tag.get('id'))
# None
```
#### Multi-valued attributes
HTML 4 defines a few attributes that can have multiple values. HTML 5 removes
a couple of them, but defines a few more. The most common multi-valued attribute
is `class` (that is, a tag can have more than one CSS class). Others include
`rel`,
`rev`, `accept-charset`, `headers`, and `accesskey`. Beautiful Soup presents the
value(s) of a multi-valued attribute as a list:
```python
css_soup = BeautifulSoup('')
css_soup.p['class']
# ["body"]
css_soup = BeautifulSoup('')
css_soup.p['class']
# ["body", "strikeout"]
```
If an attribute looks like it has more than one value, but it’s not
a multi-valued attribute as defined by any version of the HTML standard,
Beautiful Soup will leave the attribute alone:
```python
id_soup = BeautifulSoup('')
id_soup.p['id']
# 'my id'
```
When you turn a tag back into a string, multiple attribute values are consolidated:
```python
rel_soup = BeautifulSoup('Back to the homepage')
rel_soup.a['rel']
# ['index']
rel_soup.a['rel'] = ['index', 'contents']
print(rel_soup.p)
# Back to the homepage
```
If you parse a document as XML, there are no multi-valued attributes:
### NavigableString
A string corresponds to a bit of text within a tag. Beautiful Soup uses the
`NavigableString` class to contain these bits of text:
```python
tag.string
# u'Extremely bold'
type(tag.string)
# 
```
A `NavigableString` is just like a Python Unicode string, except that it also
supports some of the features described in Navigating the tree and Searching the
tree. You can convert a `NavigableString` to a Unicode string with `unicode()`:
```python
unicode_string = unicode(tag.string)
unicode_string
# u'Extremely bold'
type(unicode_string)
# 
```
You can’t edit a string in place, but you can replace one string with another,
using `replace_with()`:
```python
tag.string.replace_with("No longer bold")
tag
# No longer bold
```
### BeautifulSoup
The `BeautifulSoup` object represents the parsed document as a whole. For most
purposes, you can treat it as a `Tag` object. This means it supports most of the
methods described in Navigating the tree and Searching the tree.
## [Navigating the tree](https://beautiful-soup-4.readthedocs.io/en/latest/#navigating-the-tree)
### Going down
Tags may contain strings and other tags. These elements are the tag’s children.
Beautiful Soup provides a lot of different attributes for navigating and
iterating over a tag’s children.
Note that Beautiful Soup strings don’t support any of these attributes, because
a string can’t have children.
#### Navigating using tag names
The simplest way to navigate the parse tree is to say the name of the tag you
want. If you want the `` tag, just say `soup.head`:
```python
soup.head
# The Dormouse's story
soup.title
# The Dormouse's story
```
You can do use this trick again and again to zoom in on a certain part of the
parse tree. This code gets the first `` tag beneath the `` tag:
```python
soup.body.b
# The Dormouse's story
```
Using a tag name as an attribute will give you only the first tag by that name:
```python
soup.a
# Elsie
```
If you need to get all the `` tags, or anything more complicated than the first
tag with a certain name, you’ll need to use one of the methods described in
Searching the tree, such as `find_all()`:
```python
soup.find_all('a')
# [Elsie,
#  Lacie,
#  Tillie]
```
#### `.contents` and `.children`
A tag’s children are available in a list called `.contents`:
```python
head_tag = soup.head
head_tag
# The Dormouse's story
head_tag.contents
[The Dormouse's story]
title_tag = head_tag.contents[0]
title_tag
# The Dormouse's story
title_tag.contents
# [u'The Dormouse's story']
```
Instead of getting them as a list, you can iterate over a tag’s children using
the `.children` generator:
```python
for child in title_tag.children:
    print(child)
# The Dormouse's story
```
#### `.descendants`
The `.contents` and `.children` attributes only consider a tag’s direct
children. For instance, the `` tag has a single direct child–the ``
tag:
```python
head_tag.contents
# [The Dormouse's story]
```
But the `` tag itself has a child: the string `The Dormouse’s story`.
There’s a sense in which that string is also a child of the `` tag. The
`.descendants` attribute lets you iterate over all of a tag’s children,
recursively: its direct children, the children of its direct children, and so
on:.
```python
for child in head_tag.descendants:
    print(child)
# The Dormouse's story
# The Dormouse's story
```
#### `.string`
If a tag has only one child, and that child is a `NavigableString`, the child is
made available as `.string`:
```python
title_tag.string
# u'The Dormouse's story'
```
If a tag’s only child is another tag, and that tag has a `.string`, then the
parent tag is considered to have the same `.string` as its child:
```python
head_tag.contents
# [The Dormouse's story]
head_tag.string
# u'The Dormouse's story'
```
If a tag contains more than one thing, then it’s not clear what `.string` should
refer to, so `.string` is defined to be `None`:
```python
print(soup.html.string)
# None
```
#### `.strings` and `.stripped_strings`
If there’s more than one thing inside a tag, you can still look at just the
strings. Use the `.strings` generator:
```python
for string in soup.strings:
    print(repr(string))
# u"The Dormouse's story"
# u'\n\n'
# u"The Dormouse's story"
# u'\n\n'
```
These strings tend to have a lot of extra whitespace, which you can remove by
using the `.stripped_strings` generator instead:
```python
for string in soup.stripped_strings:
    print(repr(string))
# u"The Dormouse's story"
# u"The Dormouse's story"
# u'Once upon a time there were three little sisters; and their names were'