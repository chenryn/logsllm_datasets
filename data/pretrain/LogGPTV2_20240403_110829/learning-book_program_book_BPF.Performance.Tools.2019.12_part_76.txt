ava/lang/ath,nin
580CLT
jdk/internal/mise/Unsafe-getByte
201047
ava/lang/AbstractatxingBullder.putStringμt
252367
java/lang/AbstractStringBui1der-getCoder
252367
ava/1ang/String- getBytes
b8155Z
java/lang/AbstractStringBui1der sppend
258491
java/lang/0bject., 
258601
java/lang/AbstractStringBui1der -en.sureCapacityInterna]
258611
Java/lang/String.1sLatin1
09559Z
jara/lang/StringBuilder append
286637
Jdk/internal/mlsc/Unsafe -putInt 
361 628
java/lang/Systen, arraycopy
399118
ava/1ang/String. length
427242
jdk/internal/mise/Unsafe -getInt
700137
java/lang/String, coder
1268791
The most frequent method while tracing was java/lang/String.code(), which was called 1,268,791
times.
This works by using Java USDT probes with XX: +ExtendedDTraceProbes, which comes with
a high performance cost. As described earliet, an application may run 10 times slower with this
enabled and instrumented.
BCC
Command line usage:
javacalls [options]pid [interval]
bpfrace version for this book on 11-Mar2019. 1 created a similer tool for DTrace called _calls.d on 9-Sep-2007,
---
## Page 603
566
Chapter 12 Languages
Options include:
■ L: Show method latency instead of call counts
m: Report method latency as milliseconds
javacalls(8) is really a wrapper to a ucalls(8) tool in BCC's tools/lib directory, which handles multi-
ple languages
bpftrace
Here is the source for the bpftrace version:
+1/usx/local/bin/bpftrace
BEGIN
printf (*Tracing Java method calls. Ctrl-C to end. n*);
usdt:/.../llbvn,so:hotapot:nethod_entxy
 [atr (argl, arg21, st(azg3, azg4)] = count (1
The key to the map is two strings: the class and then the method name. As with the BCC version,
this tool will only work with xX : +ExtendedoTraceProbes, and an expected high performance
cost. Also note that the full path to libjvm.so has been truncated, and will need to be replaced by
your libjvm.so path.
12.3.13 javaflow
javaflow(8) is a BCC tool that shows the flow of Java method calls. For example:
+ javaflov 16914
Tracing nethod calls In java process 16914... Ctz1-C to qult.
GOHI3N (2n|3NII GIL IIa 0
5
62.2
652
0.135
> sun/avt/SunToo1k1t- ,avtUnlock
5
622 6520.135
->java/util/concurrent/locks/ReentrantLock.unLock
5
S5190 259 229
=> Java/ut11/concuxrent/1ocks/AbstractQueuedSynchzonize
5622 652 0.135
> javs/uti1/concurrent/locks/ReentrantLock$Sync teyR.. 
17 Origin: This wss created by Sasha Goldshtein as 8 wrapper to his uflow(8) tool from 27-0et-2016. I created a simils
tool for DTrace called _flowtime.d on 9-Sep-2007,
---
## Page 604
12.3Java 567
5
622 652 0.135
->java/uti1/ceecurrent/locks/AbstractQuevedSynchro...
5 
622
SE1*0 259
 Java/lang/Th.read. currentThread
S51*0 259 229
 java/uti1/concurrent/locks/AbstractomableSynch. ...
S5190 259 229
 Java/util/concurrent/locks/AbstractguevedSynchro. .
5
6226520.135
 sun/avt/SunToo1kit-,avtUnlock
[..-]
1622 654 4.159
[.--]
This shows the code flow: which method calls which other method and so on. Each child method
call increases the indentation in the METHOD column.
This works by using Java USDT probes with XX: +ExtendedDTraceProbes, which comes
with a high performance cost. As described earlier, an application may run 10 times slower
with this enabled and instrumented. This example also shows *Possibly lost 9 samples"
messages: BPF tooling cannot keep up with the events, and as a safety valve is letting
events be missed rather than blocking the application, while informing the user that this 
happened.
Command line usage:
javaflox[options]p1d
Options include:
 METHop: Only trace calls to methods with this prefix
javaflow(8) is really a wrapper to a uflow(8) tool in BCC's tools/lib directory, which handlles
multiple languages.
---
## Page 605
568
Chapter 12 Languages
12.3.14
javagc
javagc(8) is a BCC tool that shows JVM garbage collection events. For example:
+ javagc 16914
Tracing gazbage eollections In java procesa 16914... Ctx1-C to qult,
START
TIME (us)DESCRIFTI08
5,586
1330,00  Bone
5,586
1339,00
Hone
5.586
1340,.00
None
5,586
1342.00
None
5.586
1344,00  Bone
...]
This shows when the GC event occurred as an offset from when javagc(8) began running (the
START column, which is in seconds), and then the duration of the GC event (TIME column, in
microseconds).
This works by using the standard Java USDT probes.
Command line usage:
pTd [auotqdo] obexe[
Options include:
•-m: Report times in milliseconds
javagc(8) is really a wrapper to a ugc(8) tool in BCC’s tools/lib directory, which handles multiple
languages.
12.3.15
javaobjnew
javaobjnew(8)° is a BCC tool that counts Java object allocations. For example, running it with
C 1 0 to show the top 10 allocations by count:
javaobjnew 25102
Tracing allocations in process 25102 1language: javal.., Ctr]-C to quit,
°C
KAME/TYPE
 ALL0CS
BYTES
java/uti1/AxrayList
429837
434980
D
[java./lang/0bject.
0
Java/ut11/AxrayList5Itr
458430
D
jara/uti1/HashMap$KeySet
545194
0
18 0rigin: This wss crested by Sasha Goldshein as 8 wrt
rapper to his uge(8) tool from 1.9-0et-2016.
19 0rigin: This wss crested by Sasha Goldshtein as 8 wrapper to his uobjnew(8) tool from 25-0et-2016. I created a
similar tool for DTrace called J_objnew.d on 9-Sep-2007.
---
## Page 606
12.3Java569
550624
ava/ut11/HashMapSode
572089
net/sf/freeco1/conmon/model/Msp-$Position
663721
Java/uti1/HashSet
696829
714633
D
jara/uti1/HashMap
0
java/ut11/HashMapSKeyIterator
904244
The most frequent new object while tracing was java/util/HashMapSKeylterator, which was
created 904,244 times. The BYTES column is zero as it is not supported for this language type.
This works by using Java USIDT probes with XX: +ExtendedDTraceProbes, which comes with
a high performance cost. As described earlier, an application may run 10 times slower with this
enabled and instrumented.
Command line usage:
javaobjnev [options] pid [interval]
Options include:
· -C roP_courr: Show this many objects by count
 S roP_sIzE: Show this many objects by size
javaobjnew(8) is really a wrapper to a uobjnew(8) tool in BCCs tools/lib directory, which handles
multiple languages (some of which do support the BYTES column).
12.3.16 Java One-Liners
These sections show BCC and bpftrace one-liners. Where possible, the same one-liner is implemented
using both BCC and bpftrace.
BCC
Count JNI events beginning with *jni_Call°:
funccount '/.../1ibjvn.so:ni_Cal1**
Count Java method events:
+povyeuros un[art/*** /:n,(ene[ goptd) s d-1unosoung
Profile Java stack traces and thread names at 49 Hertz:
6b n- (ese zoptdls d-otTgoxd
bpftrace
Count JNI events beginning with *jni_Call°:
(/unoo -eqoxd]8]Treuosusart/**/n8-eoexdg
---
## Page 607
570
Chapter 12 Languages
Count Java method events:
1f(tunoo - [oqoxd] 8 1poyseu:os*us[att/***/:apen,8- eoexagdg
Profile Java stack traces and thread names at 49 Hertz:
(()aunco =[moo*yoessm]e 1 /ese[ *= eueuoexe/ 6fizqieTgoxd, 8eoexadg
Trace method compilation:
1ut6ogetrduoopoaeu:osua[art/***/1n, o- (ene( u- deabd) s d eoexagdg
printf(*conpiling: ls`n*, str(arg4, arg5)): 1*
Trace class loads:
1 papeotssvto:os*ua[qrt/**+/=n, a- (eaef u- daabd) s d- aoeaagdq
pxinte (*loaded: s′,n*, stz(azg0, azgl)): 1*
Count object allocation (needs ExtendedDTraceProbes):
 ootte—oe[qo:os"ua[art/*-*/+n, e- (eae[ u- deabd) s d- eoexngdg
B[str (argl, arg2)] = count(1: )*
12.4
Bash Shell
ate saSenSue paqaudaagu] aus qseq au :aen?uel pasaadaqu ue s aduexa a8en?ue[ leug atLL
typically much slower than compiled languages, due to the way they run their own functions to
execute each step of the target program. This makes them an uncommon target for performance
analysis, since other languages are usually chosen for performance sensitive workloads. BPF
tracing may be performed, but the need may be for troubleshooting program errors, rather than
finding performance wins.
How interpreted languages are traced is dlifferent for each language, reflecting the internals of
the software that runs them. This section will show how I approach an unknown interpreted 
other languages.
language and determine out how to trace it for the first time: an approach that you can follow for
The bash readlline() function was traced earlier in this chapter, but I have not traced bash in depth
beyond that. For this chapter I will determine out how to trace bash function and built-in calls,
and develop some tools to automate this. See Table 12-4.
Table 12-4  Bash ShellRelated Tools
Tool
Source
Description
bashfunc
Book
bash
Trace bash function calls
bashfunclat
Book
bash
Trace bash function call latency
As mentioned earlier, how bash is built affects the location of symbols. Here is bash on Ubuntu
showing its dynamic library usage with the ldd(1) tool: 
---
## Page 608
12.4 Bash Shell
571
$ 1dd /bin/bash
1inuxvdso.so.1(0x00007ffe7197b000)
libtinfo.so.5 => /lilb/xB6_641inux=gnu/libtinfo.so.5 (0x00007f08aeb86000)
1ibd1,so.2 => /11b/x86_641inux-gnu/11bdl.so -2 (0x0000Tf08ae982000)
1.ibc-so. 6 => /1ib/x86_641inux=gnu/1ibc.so.6 (0x00007f08ae591000)
/11b64/1d1.nux=x86-64, so . 2 (0×0000TE08af0ca000)
The targets to trace are /bin/bash and the shared libraries listed above. As an example of how this
can cause differences: on many distributions, bash uses a readline() function from /bin/bash, but
some distributions link to libreadline and call it from there.
Preparation
In preparation, I have built the bash software with these steps:
CFLAGS==fno=omit-frane-pointer /configure
make
This honors the frame pointer register so that I can use frame pointerbased stack walking during
my analysis. It also provides a bash binary with local symbol tables, unlike /bin/bash which has
been stripped.
Sample Program
The following is a sample bash program I wrote for analysis, welcome.sh:
+1 /hone/bgregg/Bui.1d/bash=4 . 4 18/bash
function welcone [
echo “Hello, Morld!*
echo *He1lo, Mor1d!*
echo "Hello, Bozld!*
velcone
ve1cone
velcone
ve 1cone
velcone
ve1cone
sleep 60
m,  o se uaas sa uod au pmq usq u  ed a m suaq s
function, where each function call makes three calls to echo(1) (which I expect is a bash built-in)
---
## Page 609
572
Chapter 12 Languages
for a total of 21 echo(1) calls. I choose these numbers hoping they stand out more from other
activity while tracing.3
12.4.1 Function Counts
Using funccount(8) from BCC, I will guess that the function call is executed by an internal bash
function containing the string “func*:
+ funccount *p: /hone/bgregg/Bui1d/bash-4. 4. 18/bash: *func*
Tracing 55 functions foz p:/hone/bgxegg/Bul1d/bash=4.4. 18/bash:*func**... Hit Ctr1-C
to end.
C
FUBIC
COUNT
gopuooun,doo
sv_funcnest
dispose_function_def
1
bind_function
1
make_function_def
1
execute_intern_function
in1t_funcnane_var
1
bind_function_def
2
dispose_function_def_content.s
2
msap_over_funcs
2
copy_function_def_content.s
2
ere"xodxaounaxeu
restoxe_funcazray_state
7
execute_function
find_function_def
9
make_funcnane_visible
1.4
execute_builtin_ox_functlon
28
ge t_funcn.ame
29
find_function
31
Detach.ing- ..
While tracing, I ran the welcome.sh program, which calls the welcome function seven times.
It looks like my guess was good: there were seven calls to restore_funcarray_state() and
execute_function(), and the latter sounds most promising, just based on its name.
The name execute_function() gives me an idea: what other calls begin with “execute_*? Checking
using funccount(8):
---