15 check secret and email
check secret and email
16 ia := sig((cid:104)tag,email, FWDDomain(cid:105),kIdP)
ia := sig((cid:104)tag,email, FWDDomain(cid:105),kIdP)
18 eia = encs(ia,iaKey)
eia = encs(ia,iaKey)
19 create
tag, eia
FWDdoc
21 ready
parent.opener
22 tagKey
to origin: https : //FWDDomain
23
(cid:104)r(cid:48),n(cid:48)(cid:105) = decs(tag,tagKey)
(cid:104)r(cid:48),n(cid:48)(cid:105) = decs(tag,tagKey)
(r(cid:48) = RPDomain)
(r(cid:48) = RPDomain)
24 eia
to origin: https : //RPDomain
25 POST /login
eia, loginSessionToken
20 GET /.well-known/spresso-proxy
26
ia(cid:48) := decs(eia,iaKey)
ia(cid:48) := decs(eia,iaKey)
e := (cid:104)tag,email,FWDDomain(cid:105)
e := (cid:104)tag,email,FWDDomain(cid:105)
checksig(e,ia(cid:48), pub(kIdP))?
checksig(e,ia(cid:48), pub(kIdP))?
27 serviceToken ← N
serviceToken ← N
/RPdoc
/IdPdoc
/FWDdoc
/RP
/IdP
/FWD
28 HTTP Response
login successful, serviceToken
HTTPS messages,
XHRs (over HTTPS),
Figure 1: SPRESSO Login Flow.
postMessages,
browser commands
1360Adherence to Web Standards. SPRESSO is based solely on stan-
dard HTML5 and web features and uses no browser extensions,
plug-ins, or other client-side executables. This guarantees that
SPRESSO can be used across browsers, platforms and devices, in-
cluding both desktop computers and mobile platforms, without in-
stalling any software (besides a browser). Note that on smartphones,
for example, browsers usually do no support extensions or plug-ins.
2.2 Login Flow
We now explain SPRESSO by a typical login ﬂow in the system.
SPRESSO knows three distinct types of parties: relying parties
(RPs), i.e., web sites where a user wishes to log in, identity providers
(IdPs), providing to RPs a proof that the user owns an email address
(identity), and forwarders (FWDs), who forward messages from
IdPs to RPs within the browser. We start with a brief overview of
the login ﬂow and then present the ﬂow in detail.
Overview. On a high level, the login ﬂow consists of the following
steps: First, on the RP web site, the user enters her email address.
RP then creates what we call a tag by encrypting its own domain
name and a nonce with a freshly generated symmetric key. This
tag along with the user’s email address is then forwarded to the IdP.
Due to the privacy requirement, this is done via the user’s browser in
such a way that the IdP does not learn from which RP this data was
received. Note also that the tag contains RP’s domain in encrypted
form only. The IdP then signs the tag and the user’s email address
(provided that the user is logged in at the IdP, otherwise the user ﬁrst
has to log in). This signature is called the identity assertion (IA).
The IA is then transferred to the RP (again via the user’s browser),
which checks the signature and consistency of the data signed and
then considers the user with the given email address to be logged
in. We note that passing the IA to the RP is done using an FWD
(the RP determines which one is used) as it is important that the
IA is delivered to the correct RP (RP document). The IdP cannot
ensure this, because, again due to the privacy requirements, IdP is
not supposed to know the intended RP.
Detailed Flow. We now take a detailed look at the SPRESSO login
ﬂow. We refer to the steps of the protocol as depicted in Figure 1.
We use the names RP, IdP, and FWD for the servers of the respec-
tive parties. We use RPdoc, RPRedirDoc, IdPdoc, and FWDdoc
as names for HTML documents delivered by the respective par-
ties. The login ﬂow involves the servers RP, IdP, and FWD as
well as the user’s browser (gray background), in which different
windows/iframes are created: ﬁrst, the window containing RPdoc
(which is present from the beginning), second, the login dialog cre-
ated by RPdoc (initially containing RPRedirDoc and later IdPdoc),
and third, an iframe inside the login dialog where the document
FWDdoc from FWD is loaded.
As the ﬁrst step in the protocol, the user opens the login page
at RP 1 . The actual login then starts when the user enters her
email address 2 . RPdoc sends this address in a POST request to
RP 3 . RP identiﬁes the IdP (from the domain in the email address)
and retrieves a support document from IdP 4 . This document is
retrieved from a ﬁxed URL https://IdPdomain/.well-known/
spresso-info and contains a public (signature veriﬁcation) key
of the IdP. RP now selects new nonces/symmetric keys rpNonce,
iaKey, tagKey, and loginSessionToken 5 and creates the tag tag by
encrypting RP’s domain RPDomain and the nonce rpNonce under
tagKey 6 . Using standard Dolev-Yao notation (see also Section 3),
we denote this term by
tag := encs((cid:104)RPDomain,rpNonce(cid:105),tagKey) .
RP further selects an FWD (e.g., a ﬁxed one from its settings). Now,
RP stores tag, iaKey, the FWD domain, and the email address in
its session data store under the session key loginSessionToken and
sends tagKey, FWDDomain, and loginSessionToken as response to
the POST request by RPdoc 7 .
RPdoc now opens the login dialog. Ultimately, this window con-
tains the login dialog from IdP (IdPdoc) so that the user can log in
to IdP (if not logged in already). However, to preserve the user’s pri-
vacy (see the discussion in Section 2.4), RPdoc does not launch the
dialog with the URL of IdPdoc immediately. Instead, RPdoc opens
the login dialog with the URL of RPRedirDoc and attaches the
loginSessionToken 8 . RPRedirDoc is loaded from RP ( 9 and 10 )
and redirects the login dialog to IdPdoc ( 11 and 12 ), passing the
user’s email address, the tag, the FWD domain, and the iaKey from
RP, as stored under the session key loginSessionToken, to IdPdoc.1
After the browser loaded IdPdoc from IdP, the user enters her
password2 matching her email address 13 . The password, the email
address, the tag, and the FWD domain are now sent to IdP 14 . After
IdP veriﬁed the user credentials 15 , it creates the identity assertion
as the signature
ia := sig((cid:104)tag,email,FWDDomain(cid:105),kIdP)
using its private signing key kIdP 16 and then returns ia to IdPdoc 17 .
We note that ia contains the signature only, not the data that was
signed.
To avoid that the FWD learns the IA (we discuss this further in
Section 2.4), IdPdoc now encrypts the IA using the iaKey 18 :
eia := encs(ia,iaKey) .
Then, IdPdoc opens an iframe with the URL of FWDdoc, pass-
ing the tag and the encrypted IA to FWDdoc. After the iframe is
loaded 20 , FWDdoc sends a postMessage3 to its parent’s opener
window, which is RPdoc 21 . This postMessage with the sole con-
tent “ready” triggers RPdoc to send the tagKey to FWDdoc, where
in the postMessage the origin4 of FWD with HTTPS is declared to
be the only allowed receiver of this message 22 . FWDdoc uses the
key to decrypt the tag and thereby learns the intended receiver (RP)
of the IA 23 . As its last action, FWD forwards the encrypted IA eia
via postMessage to RPdoc (using RP’s HTTPS origin as the only
allowed receiver) 24 .
RPdoc receives eia and sends it along with the loginSessionToken
to RP 25 . RP then decrypts eia, retrieves ia(cid:48) and checks whether ia(cid:48)
is a valid signature for (cid:104)tag,email,FWDDomain(cid:105) under the veriﬁca-
tion key pub(kIdP) of the IdP, where tag, email, and FWDDomain
are taken from the session data identiﬁed by loginSessionToken 26 .
Now, the user identiﬁed by the email address is logged in. The
mechanism that is used to persist this logged-in state (if any) at this
point is out of the scope of SPRESSO. In our analysis, as a model for
a standard session-based login, we assume that RP creates a session
for the user’s browser, identiﬁed by some freshly chosen token (the
RP service token) 27 and sends this token to the browser 28 .
2.3
Implementation Details
We developed a proof-of-concept implementation of SPRESSO
in about 700 lines of JavaScript and HTML code. It contains all
1This data is passed to IdPdoc in the fragment identiﬁer of the
URL (a.k.a. hash), and therefore, it is not necessarily sent to IdP.
2In fact, the IdP can as well offer any other form of authentica-
tion, e.g., TLS client authentication or two-factor authentication.
3postMessages are messages that are sent between different win-
dows in one browser.
4An origin is deﬁned by a domain name plus the information
whether the connection to this domain is via HTTP or HTTPS.
1361presented features of SPRESSO itself and a typical IdP. The imple-
mentation (source code and online demo) is available at [22]. Our
model presented in Section 5 closely follows this implementation.
The three servers (RP, IdP and FWD) are written in JavaScript
and are based on node.js and its built-in crypto API. On the client-
side we use the Web Cryptography API. For encryption we employ
AES-256 in GCM mode to provide authenticity. Signatures are
created/veriﬁed using RSA-SHA256.
2.4 Discussion
In order to provide more intuition and motivation for the design
of SPRESSO, and in particular its security and privacy properties,
we ﬁrst informally discuss some potential attacks on our system
and what measures we took when designing and implementing
SPRESSO to prevent these attacks. These attacks also illustrate
the complexity and difﬁculty of designing a secure and privacy-
respecting web-based SSO system. In Sections 6 and 7, we formally
prove that SPRESSO provides strong authentication and privacy
properties in a detailed model of the web infrastructure. We also
discuss other aspects of SPRESSO, including usability and perfor-
mance. We conclude this section with a comparison of SPRESSO
and BrowserID.
Malicious RP: Impersonation Attack. An attacker could try to
launch a man in the middle attack against SPRESSO by playing the
role of an RP (RP server and RPdoc) to the user. Such an attacker
would run a malicious server at his RP domain, say, RPa, and also
deliver a malicious script (instead of the honest RPdoc script) to the
user’s browser. Now assume that the user wants to log in with her
email address at RPa and is logged in at the IdP corresponding to
the email address already. Then, the attacker (outside of the user’s
browser) could ﬁrst initiate the login process at RPb using the user’s
email address. The attacker’s RP could then create a tag of the form
encs((cid:104)RPb,rpNonce(cid:105),tagKey) using the domain of an honest RP
RPb, instead of RPa. The IdP would hence create an IA for this tag
and the user’s email address and deliver this IA to the user’s browser.
If this IA were now indeed be delivered to the attacker’s RP window
(which is running a malicious RPdoc script), the attacker could use
the IA to ﬁnish the log in process at RPb (and obtain the service
token from RPb), and thus, log in at RPb as the honest user.
However, assuming that FWD is honest (see below for a discus-
sion of malicious FWDs), FWD prevents this kind of attack: FWD
forwards the (encrypted) IA via a postMessage only to the domain
listed in the tag (so, in this case, RPb), which in the attack above
is not the domain of the document loaded in the attacker’s RP win-
dow (RPa). The IA is therefore not transmitted to the attacker. The
same applies when the attacker tries to navigate the RP window to
its own domain, i.e., to RPa, before Step 24 . Our formal analysis
presented in the following sections indeed proves that such attacks
are excluded in SPRESSO. We note that in order to make sure that
the postMessage is delivered to the correct RP window (technically,
a window with the expected origin), FWD uses a standard feature
of the postMessage mechanism which allows to specify the origin
of the intended recipient of a postMessage.
Malicious IdP. A malicious IdP could try to log the user in under
an identity that is not her own. An attack of this kind on BrowserID
was shown in [10]. However, in SPRESSO, the IdP cannot select
or alter the identity with which the user is logged in. Instead, the
identity is ﬁxed by RP after Step 6 and checked in Step 26 . Again,
our formal analysis shows that such attacks are indeed not possible
in SPRESSO.
The IdP could try to undermine the user’s privacy by trying to
ﬁnd out which RP requests the IA. However, in SPRESSO, the IdP
cannot gather such information: From the information available
to it (email, tag, FWDDomain plus any information it can gather
from the browser’s state), it cannot infer the RP.5 It could further
try to corellate the sources and times of HTTPS requests for the
support document with user logins. To minimize this side channel,
we suggest caching the support document at each RP and automatic
refreshing of this cache (e.g., an RP could cache the document for
48 hours and after that period automatically refresh the cache). Ad-
ditionally, RPs should use the Tor network (or similar means) when
retrieving the support document in order to hide their IP addresses.
Assuming that support documents have been obtained from IdPs in-
dependently of speciﬁc login requests by users, our formal analysis
shows that SPRESSO in fact enjoys a very strong privacy property
(see Sections 4 and 6).
In BrowserID, malicious IdPs (in fact, any party who can run
malicious scripts in the user’s browser) can check the presence or
absence of certain iframes in the login process, leading to the pri-
vacy break mentioned earlier. Again, our formal analysis implies
that this is not possible for SPRESSO.
Malicious FWD. A malicious FWD could cooperate with or act
as a malicious RP and thereby enable the man in the middle attack
discussed above, undermining the authentication guarantees of the
system. Also, a malicious FWD could collaborate with a malicious
IdP and send information about the RP to the IdP, and hence, under-
mine privacy.
Therefore, for our system to provide authentication and privacy,
we require that FWDs behave honestly. Below we discuss ways to
force FWD to behave honestly. We suspect that there is no way to
avoid the use of FWDs or other honest components in a practical
SSO system which is supposed to provide not only authentication
but also privacy: In our system, after Step 17 of the ﬂow, IdPdoc
must return the IA to the RP. There are two constraints: First, the
IA should only be forwarded to a document that in fact is RP’s doc-
ument. Otherwise, it could be misused to log in at RP under the
user’s identity by any other party, which would break authentica-
tion. Second, RP’s identity should not be revealed to IdP, which is
necessary for privacy. Currently, there is no browser mechanism to
securely forward the IA to RP without disclosing RP’s identity to
IdP (but see below).
Enforcing Honest FWDs. Before we discuss existing and upcom-
ing technologies to enforce honest behavior of FWDs, we ﬁrst note
that in SPRESSO, an FWD is chosen by the RP to which a user
wants to log in. So the RP can choose the FWD it trusts. The RP
certainly has a great interest in the trustworthiness of the FWD: As
mentioned, a malicious FWD could allow an attacker to log in as
an honest user (and hence, misuse RP’s service and undermine con-
ﬁdentiality and integrity of the user’s data stored at RP), something
an RP would deﬁnitely want to prevent. Second, we also note that
FWD does not learn a user’s email address: the IA, which is given
to FWD and which contains the user’s email address, is encrypted
with a symmetric key unknown to FWD.6 Therefore, SPRESSO
does not provide FWD with information to track at which RP a
5If only a few RPs use a speciﬁc FWD, FWDDomain would
reveal some information. However, this is easy to avoid in practice:
the set of FWDs all (or many) RPs trust should be big enough and
RPs could randomly choose one of these FWDs for every login
process.
6We note that IA is a signature anyway, so typically a signed