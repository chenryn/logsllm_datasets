112112
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:15:56 UTC from IEEE Xplore.  Restrictions apply. 
decide branches. Arguments a and n are therefore too live to
be useful in injecting a vulnerability. Argument b, on the other
hand, has a TCN of 0 and the bytes from which it derives,
4..7 are completely dead, making it an ideal trigger to control
a vulnerability.
Precisely which DUAs should be included, based on their
liveness and TCN, is a conﬁgurable threshold of LAVA. We
explore the impact (in terms of whether the bug can be
successfully injected and veriﬁed) of various thresholds in
Section VI-A.
B. The attack point
Attack point selection is a function of the type of vulner-
ability to be injected. All that is required is that it must be
possible to inject a bug at the attack point by making use
of dead data. This data can be made available later in the
trace via new dataﬂow. Obviously, this means that the attack
point must be temporally after an appearance of a DUA in the
trace. If the goal is to inject a read overﬂow, then reads via
pointer dereference, array index, and bulk memory copy, e.g.,
are reasonable attack points. If the goal is to inject divide-
by-zero, then arithmetic operations involving division will be
attacked. Alternately, the goal might be to control one or more
arguments to a library function. For instance, in the running
example, on line 7, the call to memcpy can be attacked since
it is observed in the trace after a usable DUA, the argument
b, and any of its arguments can be controlled by adding b,
thus potentially triggering a buffer overﬂow.
C. Data-ﬂow bug injection
The third and ﬁnal step to LAVA bug injection is introducing
a dataﬂow relationship between DUA and attack point. If the
DUA is in scope at the attack point then it can simply be
used at the attack point to cause the vulnerability. If it is not
in scope, new code is added to siphon the DUA off into a
safe place (perhaps in a static or global data structure), and
later retrieve and make use of it at the attack point. However,
in order to ensure that the bug only manifests itself very
occasionally (one of our requirements from Section I), we
add a guard requiring that the DUA match a speciﬁc value
if it is to be used to manifest the vulnerability. In the running
example, the DUA b is still in scope at the memcpy attack
point and the only source code modiﬁcation necessary is to
make use of it to introduce the vulnerability if it matches a
particular value. If we replace the ﬁrst argument to the call to
memcpy, d, with d+(b==0x6c617661)*b then there will
be an out of bounds write only when bytes 4..7 of the input
exactly match 0x6c617661.
Although this mechanism for ensuring that each bug is only
triggered for one speciﬁc input has worked well for us so far,
there are other ways we could accomplish the same task. For
example, we could instead guard the call to the buggy code
with an if statement, or perform a comparison with the input
bytes that make up the DUA one by one. Although these
are functionally equivalent, the exact mechanism used may
make it easier for certain tools to ﬁnd the bug. Comparing the
input bytes one by one, for example, would allow coverage-
maximizing fuzzers to incrementally discover the bug by
guessing one byte at a time, rather than having to guess the
entire 32-bit trigger at once. For a full-scale tool evaluation, it
would be best to inject bugs with a variety of different trigger
mechanisms; however, for our current prototype we use only
the one described in this section.
IV. ROADS NOT TAKEN
Given the goal of adding bugs to real-world programs in an
automated way, there are a large number of system designs
and approaches. In order to clarify our design for LAVA, in
this section we will brieﬂy examine alternatives.
First, one might consider compiling a list of straightforward,
local program transformations that reduce the security of the
program. For example, we could take all instances of the
strlcpy and strncpy functions and replace them with the
less secure strcpy, or look for calls to malloc and reduce
the number of bytes allocated. This approach is appealing
because it is very simple to implement (for example, as an
LLVM transformation pass), but it is not a reliable source of
bugs. There is no easy way to tell what input (if any) causes the
newly buggy code to be reached; and on the other hand, many
such transformations will harm the correctness of the program
so substantially that it crashes on every input. In our initial
testing, transforming instances of strncpy with strcpy in
bash just caused it to crash immediately. The classes of bugs
generated by this approach are also fundamentally limited and
not representative of bugs in modern programs.
sophisticated
approach
is
[6]:
A more
suggested
targeted symbolic
by
Keromytis
execution could be
used to ﬁnd program paths that are potentially dangerous but
currently safe; the symbolic path constraints could then be
analyzed and used to remove whatever input checks currently
prevent a bug. This approach is intuitively promising:
it
involves minimal changes to a program, and the bugs created
would be realistic in the sense that one could imagine them
resulting from a programmer forgetting to correctly guard
some code. However, each bug created this way would come
at a high computational cost (for symbolic execution and
constraint solving), and would therefore be limited in how
deep into the program it could reach. This would limit the
number of bugs that could be added to a program.
By contrast, the approach taken by LAVA is computationally
cheap—its most expensive step is a dynamic taint analysis,
which only needs to be done once per input ﬁle. Each validated
bug is guaranteed to come with a triggering input. In our
experiments, we demonstrate that even a single input ﬁle can
yield thousands of bugs spread throughout a complex program
such as tshark.
V. IMPLEMENTATION
The LAVA implementation operates in four stages to inject
and validate buffer overﬂow vulnerabilities in Linux C source
code.
113113
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:15:56 UTC from IEEE Xplore.  Restrictions apply. 
Clang 
Instrument Source 
with Taint Queries 
Run Instrumented 
Program on Inputs 
PANDA & 
FIB 
Clang 
Find Dead, 
Uncomplicated Data 
and 
Attack Points 
Inject Bug into 
Program Source, 
Compile and Test 
Injectable 
Bugs 
Crash 
Fig. 5: LAVA Implementation Architecture. PANDA and
Clang are used to perform a dynamic taint analysis which
identiﬁes potential bug injections as DUA attack point pairs.
Each of these is validated with a corresponding source code
change performed by Clang as well. Finally, every potentially
buggy binary is tested against a targeted input change to
determine if a buffer overﬂow actually results.
1) Compile a version of the target program which has been
instrumented with taint queries.
2) Run the instrumented version against various inputs,
tracking taint, and collecting taint query results and
attack point information.
3) Mine the taint results for DUAs and attack points, and
collect a list of potential injectable bugs.
4) Recompile the target with the relevant source code mod-
iﬁcations for a bug, and test to see if it was successfully
injected.
These stages are also depicted in Figure 5.
A. Taint queries
LAVA’s taint queries rely on the PANDA dynamic analysis
platform [5], which is based on the QEMU whole-system
emulator. PANDA augments QEMU in three important ways.
First, it introduces deterministic record and replay, which can
be used for iterated and expensive analyses (e.g. taint) that
often cannot be performed online. Second, it has a simple but
powerful plugin architecture that allows for powerful analyses
to be built and even built upon one another. Third, it integrates,
from S2E [4], the ability to lift QEMU’s intermediate language
to LLVM for analysis.
The main feature of PANDA used by LAVA is a fast
and robust dynamic taint analysis plugin that works upon
the LLVM version of each basic block of emulated code.
This LLVM version includes emulated versions of every x86
instruction that QEMU supports. QEMU often implements
tricky processor instructions (e.g. MMX and XMM on x86)
in C code. These are compiled to LLVM bitcode using Clang,
and, thereby made available for taint analysis by PANDA
114114
as well. This process ensures that PANDA’s taint analysis is
complete in the sense that it can track dataﬂow through all
instructions.
simple PANDA plugin
a
is able to apply taint
LAVA employs
named
file_taint that
labels to bytes
read from ﬁles in Linux. The plugin,
leverages
operating system introspection and system call plugins in
PANDA to determine the start ﬁle offset of the read as well
as the number of bytes actually read. This allows LAVA to
make use of taint information that maps internal program
quantities back to ﬁle offsets.
in turn,
Before running a target program under PANDA, LAVA ﬁrst
invokes a custom Clang tool to insert taint queries into the
source before and after function calls. Each function argument
is deconstructed into its constituent lvalues, and Clang adds a
taint query for each as a hypervisor call which notiﬁes PANDA
to query the taint system about a speciﬁc source-level variable.
The function return value also gets a taint query hypercall.
LAVA also uses Clang to insert source hypervisor calls at
potential attack points. It should be noted that the query points
employed by LAVA are by no means exhaustive. There is every
reason to expect that querying at pointer dereferences, e.g.,
might yield a number of additional DUAs.
B. Running the program
Once the target has been instrumented with taint queries,
we run it against a variety of inputs. Since our approach to
gathering data about the program is fundamentally dynamic,
we must take care to choose inputs to maximize code coverage.
To run the program, we load it as a virtual CD into a PANDA
virtual machine and send commands to QEMU over a virtual
serial port to execute the program against the input.
As the hypervisor calls in the program execute, PANDA
logs results from taint queries and attack point encounters to
a binary log ﬁle, the pandalog. Information about control ﬂow
transfers that depend on tainted data is also recorded in the
pandalog so that it can be used to compute the liveness of each
input byte. Note that because the pandalog is generated by
hypercalls inserted into program source code, it can connect
source-level information like variable names and source ﬁle
locations to the taint queries and attack points. This allows
bug injection, later, to make use of source-level information.
C. Mining the Pandalog
Taint
query
We then analyze the pandalog in temporal order, matching
up DUAs with attack points to ﬁnd potentially injectable bugs.
The program that does this is called FIB for “ﬁnd injectable
bugs”, and is detailed in Figure 6. FIB considers the pandalog
entries in temporal order.
entries
function
collect_duas which maintains
currently
viable DUAs. Viable DUAs must have enough tainted bytes,
and those bytes must be below some threshold for taint set
cardinality and TCN. Additionally,
the liveness associated
with all
the DUA must be
below a threshold. Note that a DUA is associated with a
the input bytes which taint
handled
a
by
the
set of
are
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:15:56 UTC from IEEE Xplore.  Restrictions apply. 
1 def check_liveness(file_bytes):
for file_byte in file_bytes:
if (liveness[file_byte]
protected int
2 file_encoding(struct magic_set *ms,
..., const char **type) {
3
5
7
9
11
13
15
17
19
> max_liveness):
return False
return True
def collect_duas(taint_query):
retained_bytes = []
for tainted_byte in taint_query:
if tainted_byte.tcn <= max_tcn
and
len(tainted_byte.file_offsets) <= max_card
and
check_liveness(tainted_byte.file_offsets)):
4 ...
6
8
10
12
14
retained_bytes += tainted_byte.file_offsets
16 ...
duakey = (taint_query.source_loc,
taint_query.ast_name)
duas[duakey] = retained_bytes
else if
(({int rv =
if (buf) {
looks_extended(buf, nbytes, *ubuf, ulen);
int lava = 0;
lava |= ((unsigned char *)(buf))[0]<<(0*8);
lava |= ((unsigned char *)(buf))[1]<<(1*8);
lava |= ((unsigned char *)(buf))[2]<<(2*8);
lava |= ((unsigned char *)(buf))[3]<<(3*8);
lava_set(lava);
}; rv;})) {
by
7:
Code
Clang
injected
Fig.
ﬁle’s