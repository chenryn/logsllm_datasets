channel attacks was increased through an attack exploiting
legacy memory segmentation [47], which is also managed
by the OS. While the attack only works under uncommon
circumstances (32 bit enclaves and smaller than 1 MiB), it
can observe memory accesses at 1 byte granularity.
Our attack can trace the control-ﬂow of an enclave with
instruction granularity, thus increasing the resolution of PT-
based controlled channel attacks. Like other controlled chan-
nel attacks [21, 23], the Frontal attack relies on interrupts to
observe instructions and control-ﬂow within a page. How-
ever, it differs from them on the kind of branches that it can
exploit. Nemesis [21] can distinguish between branches that
have instructions with measurable timing differences, either
because they have different kinds of instructions in their paths,
or because they have a different number of instructions. Copy-
Cat [23] can track the control-ﬂow in branches with a different
number of instructions. The Frontal attack allows differen-
tiating any branch, even if both paths contain the very same
instructions and are hence not vulnerable to other controlled
channel attacks. The only requirement for our attack is that the
branch contains at least a memory store in it. Such higher reso-
lution hence defeats previous defenses that rely on controlled
channels being limited to observe only at a page resolution.
9.2 Microarchitectural Side-channel Attacks
Microarchitectural attacks exploit information leakage due to
shared microarchitectural resources across different privilege
domains. Among these shared resources, the ones that have
been exploited the most are the cache and the branch predic-
tion unit (BPU). We examine side-channel attacks based on
these and other shared microarchitectural components below.
BPU Attacks The BPU records the outcome of recent
branches and jumps, to aid the CPU speculation. As it is
shared among different execution contexts running in the
same core, it can leak information about the control-ﬂow of
another context. The BPU was the focus of recent attacks,
and particularly against SGX [14, 19, 20]. BPU attacks
require either SMT [20] or time multiplexing at a ﬁne
granularity between the victim and the attacker in the same
physical CPU core [20, 19, 14]. These attacks are, in general,
very sophisticated, and require reverse-engineering the BPU.
Given how hard this is to achieve, BPU attacks are not easy
to generalize to different microarchitectures and to pull off
in practice [50]. These attacks are also limited to the type
of branches they can exploit. For instance, they cannot leak
the target virtual address of indirect jumps [14]. As these
attacks give ﬁne-grained information to the attacker, there
have been a few defenses proposed against them [14, 20, 22].
Most notably, some defenses call for a holistic approach by
ﬂushing the BPU accross context switches [14, 20]. Other
defenses propose spot defenses such as replacing every
branch with indirect jumps [22]. BPU attacks are particularly
related to the Frontal attack, as they both exploit secret-
dependent branches. However, as the Frontal attack exploits a
fundamentally different mechanism, any spot-defense against
BPU attacks is not effective against our attack.
Attacks on caches and other shared resources Because
caches are a resource shared across different execution
contexts, an attacker thread can infer which accesses a victim
recently made in another context by obtaining information
about the cache state. While cache attacks often exploit
timing variations in access latency to probe the state of
the cache [51], state changes can also be detected by using
instructions’ side effects [52, 53]. Cache attacks target
USENIX Association
30th USENIX Security Symposium    675









If paths in different CLs
If paths virtual addresses are known
If different data pages accessed based on path
If data > 4B apart is accessed based on path
If paths issue different µops
If paths in different pages
If paths have different instructions
If paths have a different instruction count
Any branch (Must have a store)
Data CF Resolution
Attack type / Name
64 B (CL)
Cache [41, 9, 10, 11]

Branch
BPU [14, 19, 20]

4 KiB (Page)
TLB [42, 16]

4 B
False Dependency [43, 44]

µops
Port contention [45, 46]

4 KiB (Page)
PT Controlled-Channel [12, 17, 16, 47] 
Instruction type and count
*
Nemesis [21]
Instruction count
CopyCat [23]

Frontal attack
Instruction VA

* Leaks instruction operands (if they induce different execution time). E.g., multiplication to 1 vs. multiplication with big numbers.
Table 3: Overview and comparison of related SGX side-channel attacks. The ﬁrst two columns indicate whether the attack
can leak data-dependent or control-ﬂow (CF) dependent secrets. The Frontal attack is the only attack that can leak the decision
made for any type of branch (as long as they contain a memory store in them), even if they are based on indirect unconditional
jumps (e.g., as a mitigation against BPU attacks), or if both paths are contained within the same CL (e.g., as a mitigation against
cache and controlled-channel attacks).
Synchronization with Victim Vulnerable branches
Interrupt / SMT / Multicore
Interrupt / SMT
SMT
SMT
SMT
Page-Fault / Interrupt / SMT
Interrupt
Interrupt
Interrupt
different levels of the cache hierarchy – from core-local
data cache [54, 55, 56, 57, 58, 9, 10, 41, 11] and core-local
instruction cache [54, 57], to the last level cache (LLC) which
is shared amongst all cores [59, 60, 61]. As code and data
are shared in the upper levels of cache (from L2), attacks that
exploit them can leak both control-ﬂow-dependent and data-
dependent secrets [59, 60, 61]. Attacks on core-local caches
require to be co-located with the victim and thus usually
rely on simultaneous multithreading (SMT) or on accurate
time-multiplexing. On the other hand, attacks that exploit the
LLC can be run at the same time as the victim in another core.
The TLB is a shared buffer that stores the translation infor-
mation from virtual addresses (VA) to physical addresses. It
can be exploited to detect whether a victim recently accessed
a data memory page [42, 16]. Since the TLB is shared only
among processes in the same core, it has been exploited only
using SMT so far. It can leak data accesses at a 4 kB gran-
ularity. CacheBleed [43] was the ﬁrst attack to demonstrate
intra-CL leakage for data accesses, achieving a resolution of
8B. It exploited cache bank conﬂicts and write-after-read false
dependencies. Since the adversary is not in the same address
space, they induce a false memory dependency by making use
of 4k page aliasing - where an address x is considered the same
as x + 4096 by the hazard detection in the processor. Cache
banks are only present in older Intel architectures and there-
fore cannot be exploited on newer CPUs. Moghimi et al. [44]
ported the CacheBleed attack to newer CPU and SGX while
improving the resolution to 4B in their MemJam attack. They
exploit read-after-write false dependencies in the processor
memory subsystem using 4k aliasing. The PortSmash [45] at-
tack extended the resolution available to the attacker even fur-
ther, by being able to detect issued microops in SGX enclaves.
It works by keeping speciﬁc CPU execution ports busy and
monitoring their execution latency. Execution in these ports
becomes slower when another context is using them, thus
leaking information about their control-ﬂow to the attacker.
10 Conclusions
In this work, we observed a dependency between instructions
execution time and their alignment modulo 16. We attributed
these differences to the CPU frontend and its fetch and
pre-decode module. We leveraged these time dependencies
to construct the Frontal attack, which can leak the instruction
pointer of an SGX enclave at the byte level granularity. The
Frontal attack works against any kind of branch, as long as it
contains at least a memory write. It can attack perfectly bal-
anced branches, even when they ﬁt within one cacheline. We
showed that the Frontal attack achieves a success rate of more
than 99%, depending on the target victim code. We tested
every modern CPU microarchitecture that currently supports
SGX (up to 10th gen) and found them all to be vulnerable
to our attack. We demonstrated the practicality of our attack
by exploiting two commonly used cryptographic libraries,
mbedTLS, and the Intel IPP Cryptography library. We
discussed relevant defenses to the attack, such as aligning all
branch targets to the same offset modulo 16. While we show
that this defense has tiny size and performance overheads,
we stress that, in general, secret-depending branching should
be avoided to guarantee conﬁdentially in SGX enclaves.
Availability
A proof of concept of the attack is available online at
https://github.com/dn0sar/frontal_poc.
Acknowledgements
We would like to thank Kaveh Razavi for insightful discus-
sions about the root causes of the Frontal attack and Kari
Kostiainen for his feedback on early drafts of this paper.
We thank our shepherd Yuval Yarom and the anonymous
USENIX reviewers for their valuable suggestions.
676    30th USENIX Security Symposium
USENIX Association
References
[1] Cisco Systems,
Inc.
Cisco Annual Internet Report
(2018–2023). https : / / www . cisco . com / c / en / us /
solutions / collateral / executive - perspectives /
annual-internet-report/white-paper-c11-741490.
pdf. Accessed: May 2020.
[2] V. Costan and S. Devadas. Intel SGX Explained. Cryptology
ePrint Archive, Report 2016/086.
[3] S. Pinto and N. Santos. “Demystifying Arm TrustZone: A
Comprehensive Survey”. ACM Computing Surveys (2019).
[5]
[4] D. Lee, D. Kohlbrenner, S. Shinde, K. Asanovi´c, and D. Song.
“Keystone: An Open Framework for Architecting Trusted Exe-
cution Environments”. Proceedings of the Fifteenth European
Conference on Computer Systems (EuroSys ’20).
J. Noorman, P. Agten, W. Daniels, R. Strackx, A. V. Her-
rewege, C. Huygens, B. Preneel, I. Verbauwhede, and F.
Piessens. “Sancus: Low-cost Trustworthy Extensible Net-
worked Devices with a Zero-software Trusted Computing
Base”. 22nd USENIX Security Symposium (USENIX Security
’13).
[6] V. Costan, I. Lebedev, and S. Devadas. “Sanctum: Minimal
Hardware Extensions for Strong Software Isolation”. 25th
USENIX Security Symposium (USENIX Security ’16).
[7] A. Ferraiuolo, A. Baumann, C. Hawblitzel, and B. Parno.
“Komodo: Using Veriﬁcation to Disentangle Secure-Enclave
Hardware from Software”. Proceedings of the 26th Sympo-
sium on Operating Systems Principles (SOSP ’17).
[8] Advanced Micro Devices Inc. AMD Secure Encrypted Vir-
tualization (SEV). https://developer.amd.com/sev/.
Accessed: January 2020.
[9] F. Brasser, U. Müller, A. Dmitrienko, K. Kostiainen, S. Cap-
kun, and A.-R. Sadeghi. “Software Grand Exposure: SGX
Cache Attacks Are Practical”. 11th USENIX Workshop on
Offensive Technologies (WOOT ’17).
[10] A. Moghimi, G. Irazoqui, and T. Eisenbarth. “CacheZoom:
How SGX Ampliﬁes the Power of Cache Attacks”. Crypto-
graphic Hardware and Embedded Systems – CHES 2017.
J. Götzfried, M. Eckert, S. Schinzel, and T. Müller. “Cache
Attacks on Intel SGX”. Proceedings of the 10th European
Workshop on Systems Security (EuroSec ’17).
[11]
[12] Y. Xu, W. Cui, and M. Peinado. “Controlled-Channel At-
tacks: Deterministic Side Channels for Untrusted Operating
Systems”. 2015 IEEE Symposium on Security and Privacy.
[13] S. P. Johnson. Intel SGX and Side-Channels. https : / /
software.intel.com/content/www/us/en/develop/
articles/intel- sgx- and- side- channels.html. Ac-
cessed May 2020.
S. Lee, M.-W. Shih, P. Gera, T. Kim, H. Kim, and M. Peinado.
“Inferring Fine-grained Control Flow Inside SGX Enclaves
with Branch Shadowing”. 26th USENIX Security Symposium
(USENIX Security ’17).
[14]
[15] M.-W. Shih, S. Lee, T. Kim, and M. Peinado. “T-SGX:
Eradicating Controlled-Channel Attacks Against Enclave Pro-
grams”. Proceedings 2017 Network and Distributed System
Security Symposium (NDSS ’17).
[17]
[16] W. Wang, G. Chen, X. Pan, Y. Zhang, X. Wang, V. Bind-
schaedler, H. Tang, and C. A. Gunter. “Leaky Cauldron on the
Dark Land: Understanding Memory Side-Channel Hazards
in SGX”. Proceedings of the 2017 ACM SIGSAC Conference
on Computer and Communications Security (CCS ’17).
J. Van Bulck, N. Weichbrodt, R. Kapitza, F. Piessens, and R.
Strackx. “Telling Your Secrets without Page Faults: Stealthy
Page Table-Based Attacks on Enclaved Execution”. 26th
USENIX Security Symposium (USENIX Security ’17).
Intel Corporation. Protection from Side-Channel Attacks.
https : / / software . intel . com / content / www / us /
en/develop/documentation/sgx- developer- guide/
top / protection - from - sidechannel - attacks . html.
Accessed May 2020.
[18]
[19] D. Evtyushkin, R. Riley, N. C. Abu-Ghazaleh, ECE, and D.
Ponomarev. “BranchScope: A New Side-Channel Attack on
Directional Branch Predictor”. Proceedings of the Twenty-
Third International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS
’18).
[21]
[20] T. Huo, X. Meng, W. Wang, C. Hao, P. Zhao, J. Zhai, and
M. Li. “Bluethunder: A 2-level Directional Predictor Based
Side-Channel Attack against SGX”. IACR Transactions on
Cryptographic Hardware and Embedded Systems (2019).
J. Van Bulck, F. Piessens, and R. Strackx. “Nemesis: Study-
ing Microarchitectural Timing Leaks in Rudimentary CPU
Interrupt Logic”. Proceedings of the 2018 ACM SIGSAC Con-
ference on Computer and Communications Security (CCS
’18).
S. Hosseinzadeh, H. Liljestrand, V. Leppänen, and A. Paverd.
“Mitigating Branch-Shadowing Attacks on Intel SGX Using
Control Flow Randomization”. Proceedings of the 3rd Work-
shop on System Software for Trusted Execution (SysTEX ’18).
[23] D. Moghimi, J. Van Bulck, N. Heninger, F. Piessens, and
B. Sunar. “CopyCat: Controlled Instruction-Level Attacks
on Enclaves”. 29th USENIX Security Symposium (USENIX
Security ’20).
[22]
[24] A. Limited. mbedTLS (formerly known as PolarSSL). https:
[25]
//tls.mbed.org/. Accessed March 2020.
Intel Corporation. Cryptography for Intel Integrated Per-
formance Primitives Developer Reference.
https : / /
software.intel.com/content/www/us/en/develop/
documentation/ipp-crypto-reference/top.html. Ac-
cessed October 2020.
[26] B. Coppens, I. Verbauwhede, K. D. Bosschere, and B. D. Sut-
ter. “Practical Mitigations for Timing-Based Side-Channel
Attacks on Modern x86 Processors”. 2009 30th IEEE Sympo-
sium on Security and Privacy.
USENIX Association
30th USENIX Security Symposium    677
[27]
Intel Corporation. Guidelines for Mitigating Timing Side
Channels Against Cryptographic Implementations. https://
software.intel.com/security-software-guidance/
insights / guidelines - mitigating - timing - side -
channels-against-cryptographic-implementations.
Accessed March 2020.
[29]
[28] P. Kocher, J. Horn, A. Fogh, D. Genkin, D. Gruss, W. Haas,
M. Hamburg, M. Lipp, S. Mangard, T. Prescher, M. Schwarz,
and Y. Yarom. “Spectre Attacks: Exploiting Speculative
Execution”. 2019 IEEE Symposium on Security and Privacy.
J. Van Bulck, F. Piessens, and R. Strackx. “SGX-Step: A
Practical Attack Framework for Precise Enclave Execution
Control”. Proceedings of the 2nd Workshop on System Soft-
ware for Trusted Execution (SysTEX’17).
Intel Corporation. Intel 64 and IA-32 Architectures Software
Developer Manuals.
[30]