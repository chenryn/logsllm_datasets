instead being added in smaller groups as they arrive. However,
some entries will still be in the stash locally and therefore will
not be read from the index. These two issues appear to roughly
cancel out.
500
We show a 94% percent reduction in the reads required
by the server for a search query for our scheme vs. simply
10
Fig. 6: Experimental and simulated results. IO savings for IO-DSSE vs existing approach and vs an obliviously updatable index
constructed with PATH ORAM.
construction an obliviously updatable index with ORAM. This
shows that optimizations stemming from the relaxation of
ORAM’s security properties are effective.
This is both an important cost saving and a large reduction
in the latency of serving the ﬁrst page results. These results
are exactly as predicted, since we do one read instead of 17
(the length of a full path for the chosen parameters) and save
17−1
17 = .941. Finally, our experiments show a 20% to 82%
reduction in the IO needed to return a search result. Since search
terms are selected uniformly at random from the set of results,
many searches have only 1 or 2 documents associated with them,
needing only the small corresponding number of reads from the
naive index vs. one read from the obliviously updatable index
in our scheme. For those, our scheme offers little advantage. As
we increase the number of received messages, the total number
of indexed documents and therefore the expected number of
results per search increases and our scheme becomes more
efﬁcient. The variance in the number of results per search term
also accounts for the variance in the measured results. We again
note that, given the relative infrequence of searches against the
index compared to updates, this is not the crucial metric to
optimize for.
C. Simulated Long-term Storage Usage
We now examine the storage requirements for IO-DSSE
both on the server side (i.e. how large the obliviously updatable
index needs to be) and on the client side in terms of stored
metadata. The necessary size of the obliviously updatable index
is a function of the distribution of keywords, the rate of arrival
of keywords, and the amount of available local storage that
can be used to buffer results on the client.
Client storage Because the local client is trusted, we are under
no constraints as to how the storage is laid out and need not
obscure its access pattern. As a result, it does not make a
difference if all of the storage is used holding an entry for a
single keyword appearing in two million emails or one million
keywords each in one email. To a ﬁrst approximation, client
storage is directly proportional to the number of documents
keyword pairs (as we store less than 8 bytes per unique
keyword). As shown in Figure 6, we use 62.7M B ± 13.2KB
for a 95th percentile user and 33.4M B ± 11.8KB for a 50th
percentile user.
Server storage for partial-block index Of course, once the
client’s storage is full, we must evict entries into the obliviously
updatable index, starting with the most full. For OUI, keyword
distribution comes into play. At some point the index will be
full of infrequent words and we will be forced to evict partial
blocks into the full-block index. The main questions we need
to answer are 1) how often does this happen and 2) how large
of a partial-block index we need to ensure it does not happen
too soon.
To measure this directly would involve experiments span-
ning the expected lifetime of a user’s mail account, which
is prohibitive to evaluate with a real implementation. Instead,
we conduct a Monte Carlo style simulation. We draw words
at random, according to the measured distribution of tokens
described in the previous section and measure how long it
takes before we are forced to evict a partially full block from
the OUI. Our simulator merely keeps track of how space is
allocated locally (client-side) and in the OUI and at what point
each becomes full and forces an eviction. The simulator does
not provide actual search results as the intention here is to
assess storage requirements.
We assume a local store of 128MB and 64-bit email
identiﬁers. We assume the cost of adding a new keyword
to the index is 100 bits. Rather than specifying a ﬁxed size
for the OUI, we simply measure how many blocks would be
needed to ﬁt the entire index.
11
Fig. 7: Simulated long term storage for IO-DSSE. Left: the size of the obliviously updatable index needed (i.e. server side storage)
as time goes on for users of different activity levels. Right: the size of the client’s storage under the same conditions.
Our simulation validates that
the general approach of
splitting the index into a partial-block and full-block index
is viable, showing that even for a 95th percentile user, 2GB
of partial-block index is sufﬁcient to hold ten years worth of
email or nearly 100 years of email for the average user.
As the graph in Figure 6 shows, however, there appears
to be no upper bound on the size of the index, short of the
total number of observed words. This validates the following
intuition: evicting frequent words from the OUI when the block
is full ultimately does not free enough space for infrequent
words. That space will immediately be occupied by (in many
cases the same) frequent word. The long tail of keywords
causes problems. To accommodate this, providers must either
(1) limit the number of indexed words (e.g. to English words),
or (2) limit the amount of indexed email. In the case of a
limited set of keywords, the obliviously updatable index would
have a ﬁxed size.
Deletes Recall, we can only delete emails from the obliviously
updatable index, so any index entries that have been evicted
from the OUI are permanent. How long does this give us to
fully delete a message (i.e. all index entries resulting from
that message’s arrival)? For a 95th percentile user, the most
frequent word is evicted 6724.8 ± 3.22490 times in 3650 days
or 2 evictions per day. For such a user, all index entries for an
email can only be deleted within a day of arrival. For the 50th
percentile user, on the other hand, where the most frequent
word is evicted 319.4± 0.843274 times in 3650 days, all index
entries for an email can be removed if the email is deleted
within an expected 11 days of arrival.
V. RELATED WORK AND ATTACKS
A. Related work on searchable encryption
Searchable encryption has been studied in an extensive line
of works [5, 7, 8, 10, 15, 19]. Very few works have focused
on efﬁciency or locality. Cash et al. [5] provide the best
such approach. As we stressed in the introduction, however,
this approach does not help in the dynamic case: all existing
techniques insert each document ID associated with a given
keyword into a random location in the index.
B. Attacks
Recently Zang et al. [22] construct a highly effective query
recovery attack on SSE schemes. The attack leverages the
fact that an attacker who can insert entries into the index can
construct them such that the subset of attacker ﬁles returned
uniquely identiﬁes the queried keyword. Effectively, this is a
more efﬁcient version of the attacker inserting one unique ﬁle
per possible keyword which contains only that single keyword.
As this attack requires an adversary to insert ﬁles into the index,
it cannot be mounted by an adversary who wishes to passively
surveil many users. None-the-less, our scheme is subject to the
attack, and indeed if used for email, highly susceptible due to
the ease with which an attacker can insert ﬁles. This makes
the scheme useful for end-to-end encryption settings which
protect against dragnet surveillance. However, it should not be
used in scenarios where greater protection against an actively
malicious mail server is needed. Also, as the attack depends
only on observing retrieved ﬁles, there appears to be no simple
countermeasures. Forward private SSE schemes [3] do thwart
the adaptive version of the attack that requires injecting fewer
ﬁles, but again at a large locality cost. Moreover as Zang et
al. make clear, the non-adaptive attack still works even with
forward privacy and that attack is readily mountable in the
setting of email.
We are hopeful that some method of injecting noise into the
results or merely detecting when this attack has been mounted
will be developed. As these techniques likely operate over
the logical structure of the index, our scheme should be fully
compatible with them. But absent such countermeasures, SSE
in the email setting is only secure against passive adversaries
regardless of its IO efﬁciency.
VI.
EXTENSIONS AND CONCLUSIONS
Encrypted search for email or similar messaging systems
represents a major obstacle for E2E encrypted applications. All
12
existing built solutions place a prohibitively high IO cost on
updating the index on message arrival: requiring one random
write per document-keyword pair and one random read per
search. Using a hybrid approach where updates are done to
a dynamic ORAM-like index and then evicted to a chunked
index typically used for static searchable encryption, we are
able to reduce the total IO usage by 99%, and by building a
dynamic index that does not protect read privacy, we are able
to achieve a 94% reduction in the upfront costs of search.
Our approach, of course, is still more expensive than non-
encrypted search, and deploying for email is, in the end, a cost-
beneﬁt analysis between the value of protecting user privacy
and the operating cost. But this is at least now a trade-off that is
far easier to make given our performance improvements. Indeed,
without such a reduction in IO cost, the cost of encrypted search
for email is too high.
Achieving this comes at some cost. First, we must slightly
relax the leakage function for searchable encryption: an attacker
learns when entries are moved from the partial to full-block
index, and we leak slightly more to an active attacker. Second, at
present, we only support deletes from the obliviously updatable
index, and third, we only provide single keyword search.
Future work and extensions The techniques of Cash et. al [5]
can readily be applied to our approach to get conjunctive search.
We can simply use their (or any other similar) scheme directly
for the full-block index. In their scheme, a keyword is associated
with a key used speciﬁcally for computing intersection tags
xtag based on indexes and set of all such tags xSET is stored
by the server. Because no additional data is associated with
the index entries on the server, and tags can safely be added
to xSET without additional leakage, this technique can be
applied to our approach simply by having the server store the
tag set.
To deal with deletes, it is possible to incrementally rebuild
the index. Instead of appending to the full index on eviction,
we can with some small probability overwrite a block in the
full index with one evicted from the partial index, storing
the overwritten block locally and then incrementally feeding
the non-deleted entries back. Thus the entire index would
periodically be refreshed. However, careful analysis of the
speciﬁc rate of deletion is needed to check if this approach
provides any practical beneﬁt.
Finally, it is an interesting question whether similar relax-
ations to ORAM security can be used to build an obliviously
updatable index with something other than Path ORAM and
with even better efﬁciency.
ACKNOWLEDGMENTS
This work was supported in part by The National Science
Foundation under award CNS-1228443. We would also like to
thank David Cash, Seny Kamara, Charalampos Papamanthou
and the anonymous reviewers for discussions and helpful
comments.
REFERENCES
[1] BLASS, E.-O., MAYBERRY, T., NOUBIR, G., AND ONARLIOGLU, K.
Toward robust hidden volumes using write-only oblivious ram.
In
Proceedings of the 2014 ACM SIGSAC Conference on Computer and
Communications Security (2014), ACM, pp. 203–214.
13
[2] BONEH, D., MAZIERES, D., AND POPA, R. A. Remote oblivious
storage: Making oblivious ram practical.
[3] BOST, R. Sophos - forward secure searchable encryption. Cryptology
ePrint Archive, Report 2016/728, 2016. http://eprint.iacr.org/2016/728.
[4] CASH, D., JAEGER, J., JARECKI, S., JUTLA, C., KRAWCZYK, H.,
ROSU, M.-C., AND STEINER, M. Dynamic searchable encryption in
very-large databases: Data structures and implementation. In Network
and Distributed System Security Symposium (NDSS’14) (2014).
[5] CASH, D., JARECKI, S., JUTLA, C., KRAWCZYK, H., ROS¸ U, M.-C.,
AND STEINER, M. Highly-scalable searchable symmetric encryption
with support for boolean queries. In Advances in Cryptology–CRYPTO
2013. Springer, 2013, pp. 353–373.
[6] CASH, D., AND TESSARO, S. The locality of searchable symmetric
encryption. In Advances in Cryptology–EUROCRYPT 2014. Springer,
2014, pp. 351–368.
[7] CHASE, M., AND KAMARA, S. Structured encryption and controlled
disclosure. In Advances in Cryptology-ASIACRYPT 2010. Springer, 2010,
pp. 577–594.
[8] CURTMOLA, R., GARAY, J., KAMARA, S., AND OSTROVSKY, R.
Searchable symmetric encryption: improved deﬁnitions and efﬁcient
constructions. In Proceedings of the 13th ACM conference on Computer
and communications security (2006), ACM, pp. 79–88.
[9] DAMG ˚ARD, I., MELDGAARD, S., AND NIELSEN, J. B. Perfectly secure
In Theory of Cryptography.
oblivious ram without random oracles.
Springer, 2011, pp. 144–163.
[10] GOH, E.-J., ET AL. Secure indexes. IACR Cryptology ePrint Archive
2003 (2003), 216.
[11] GOLDREICH, O. Towards a theory of software protection and simulation
In Proceedings of the nineteenth annual ACM
by oblivious rams.
symposium on Theory of computing (1987), ACM, pp. 182–194.
[12] GOLDREICH, O., AND OSTROVSKY, R.
Software protection and
Journal of the ACM (JACM) 43, 3
simulation on oblivious rams.
(1996), 431–473.
[13] KAMARA, S., AND PAPAMANTHOU, C. Parallel and dynamic searchable
symmetric encryption. In Financial cryptography and data security.
Springer, 2013, pp. 258–274.
[14] KAMARA, S., PAPAMANTHOU, C., AND ROEDER, T. Dynamic
In Proceedings of the 2012 ACM
searchable symmetric encryption.
conference on Computer and communications security (2012), ACM,
pp. 965–976.
[15] NAVEED, M., PRABHAKARAN, M., AND GUNTER, C. A. Dynamic
searchable encryption via blind storage. Cryptology ePrint Archive,
Report 2014/219, 2014. http://eprint.iacr.org/.
[16] PAPPAS, V., KRELL, F., VO, B., KOLESNIKOV, V., MALKIN, T., CHOI,
S. G., GEORGE, W., KEROMYTIS, A., AND BELLOVIN, S. Blind seer:
In Security and Privacy (SP), 2014 IEEE
A scalable private dbms.
Symposium on (2014), IEEE, pp. 359–374.
[17] POPA, R. A., REDFIELD, C., ZELDOVICH, N., AND BALAKRISHNAN,
H. Cryptdb: protecting conﬁdentiality with encrypted query processing.
In Proceedings of the Twenty-Third ACM Symposium on Operating
Systems Principles (2011), ACM, pp. 85–100.
[18] SHI, E., CHAN, T.-H. H., STEFANOV, E., AND LI, M. Oblivious
In Advances in Cryptology–
ram with o ((logn) 3) worst-case cost.
ASIACRYPT 2011. Springer, 2011, pp. 197–214.
[19] SONG, D. X., WAGNER, D., AND PERRIG, A. Practical techniques for
searches on encrypted data. In Security and Privacy, 2000. S&P 2000.
Proceedings. 2000 IEEE Symposium on (2000), IEEE, pp. 44–55.
[20] STEFANOV, E., PAPAMANTHOU, C., AND SHI, E. Practical dynamic
IACR Cryptology ePrint
searchable encryption with small leakage.
Archive 2013 (2013), 832.
[21] STEFANOV, E., VAN DIJK, M., SHI, E., FLETCHER, C., REN, L., YU,
X., AND DEVADAS, S. Path oram: An extremely simple oblivious ram
In Proceedings of the 2013 ACM SIGSAC conference on
protocol.
Computer & communications security (2013), ACM, pp. 299–310.
[22] ZHANG, Y., KATZ, J., AND PAPAMANTHOU, C. All your queries
are belong to us: The power of ﬁle-injection attacks on searchable
encryption. Cryptology ePrint Archive, Report 2016/172, 2016. http:
//eprint.iacr.org/2016/172.