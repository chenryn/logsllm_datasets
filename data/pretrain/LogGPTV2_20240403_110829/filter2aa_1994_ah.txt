else { 
printf("error2\n"); 
} 
} 
else { 
printf("error1\n"); 
} 
} 
} 
Reverse200(200) 
可执行文件是个 install4j 的程序，用 procmon 监控进程文件操作能够提取出一个
trustme.jar，用 jd-gui 打开发现 jar 经过混淆，静态分析发现得出的算法是错误的。于是用
IDEA 设置 Path to jar 进行调试，发现动态加载了一个类，里面是关键函数，然后写脚本倒推
即可。 
脚本： 
#!/usr/bin/env python2 
# -*- coding:utf-8 -*- 
from ctypes import * 
def u8(x): 
    return c_uint8(x).value 
result = [-81, 52, 52, -39, -64, 43, 49, -116, -100, -115, -81, -119, 
34, -7, 56, 92, 23, 78, 115, -120, 77, 83, -22] 
sbox = [1, 3, 8, -55, 21, 27, 35, 67, -14, -111, -49, 89, 92, 109, 
31, -112, 7, -74, 55, -15, -32, -1, -20, 83, 39, -103, -36, -116, -
93, -50, -19, -128, 96, 46, 99, 26, -86, -46, -34, 105, -21, 0, -88, 
68, 16, -42, 94, 5, 120, -53, -2, -109, 11, -121, -62, -6, 29, 112, -
82, -79, -71, -37, 52, 119, 102, 60, 111, 87, -3, 41, -114, -43, 49, 
-118, 54, 44, -7, 100, 98, -16, 78, 116, 91, 23, 97, -58, -23, -75, -
97, -81, 76, 6, 61, -119, 124, -54, 79, 57, 50, -113, 84, -107, 86, 
4, -108, 40, -87, 34, -102, -18, -115, -57, -85, -77, 118, 103, 53, -
98, -96, 37, -72, 2, -80, -35, -92, 122, -83, 18, -60, -68, 14, -64, 
115, 108, 63, 81, 114, -69, 117, -39, -33, 36, -89, 125, 59, 65, -99, 
101, 93, -105, 38, 43, 126, -126, 30, 75, 77, -45, 13, -76, -61, 104, 
51, 85, 64, 127, -65, -48, 74, 123, -117, -95, -9, 33, 80, 56, -91, -
26, -31, -73, 69, 48, -8, -22, -104, 113, -100, -38, -101, -4, -27, -
17, -29, 17, 82, -25, -51, -127, -110, -122, 28, 12, -66, 66, -78, -
24, -56, -11, 110, 107, 15, -84, -13, -125, -94, 121, 70, -12, 20, 
106, -124, 71, 25, -120, -44, -10, 47, -106, 45, 95, 73, 32, 62, -90, 
-41, 58, 24, 19, -67, -123, 72, -28, 42, 10, -40, 90, -47, 22, -5, -
30, -52, -59, -63, 9, -70, 88] 
for i in xrange(len(sbox)): 
    sbox[i] = u8(sbox[i]) 
length = 0x17 
for i in xrange(23): 
    result[i] = u8(result[i]) 
# step1 
for i in xrange(23): 
    if i % 2 == 0: 
        result[i] = u8(result[i]-1) 
    else: 
        result[i] = u8(result[i]+1) 
for i in xrange(23): 
    result[i] = u8(result[i] ^ 0x82) 
for i in xrange(23): 
    result[i] = u8(result[i] -4) 
t = [] 
for i in xrange(23): 
    t.append(sbox.index(result[i])) 
xor_seed = [58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 
12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 
57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 
45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7] 
for i in xrange(23): 
    t[i] = u8(t[i] ^ xor_seed[i]) 
print ''.join([chr(c) for c in t]) 
Reverse500(500) 
这是一个 64 位 VM 的题，checker 是 main 函数，mod1、mod2 和 mod3 是三个子函数，
先是加载程序，然后分配寄存器和栈的空间 
下面是指令对应的操作 
80 mov reg, immediate 
81 xor reg1, reg2 | xor reg1, immediate 
82  push reg 
83 pop reg 
9A je 
9B jmp 
9C jne 
9D call 
A5 mov reg1, reg2+reg3 
A6  mov reg1, [reg2] 
A7 mov reg1, cs+[cs+0x20]+immediate 
B0 mov [reg1], byte ptr [reg2] 
B1 mov reg1, [reg2] & immediate 
B2 mov reg1, [reg2] | immediate 
B3 mov reg1, [reg2] / immediate 
C5 cmp 
C6 ret 
C7 mov reg1, reg2 
E0 syscall 
E1 malloc 
第一个子函数 mod1 是输入，然后在 checker 也就是 main 函数验证输入的长度是不是 0x1D，
通过后调用 mod3 函数对输入做了三次处理，先是以输入值的每个字符为索引到
mod3_base_addr+0x600 的位置查表替换，然后再跟 mod3_base_addr+0x700 处的四个值循环
异或，之后把结果中每个值的高 4 位除以 0x10 之后再或 0x30，低 4 位或 0x30，最后与
mod3_base_addr+0x730 处的值比较，得到 flag 代码如下 
#include  
#include  
int main() { 
unsigned char table[256] = { 
0x49, 0xB6, 0x2C, 0x2D, 0xAB, 0x8F, 0x36, 0x11, 0x32, 0xE7, 0x73, 0xF8, 
0xF9, 0x4C, 0x26, 0xA3, 0x5B, 0xBB, 0xBC, 0xBD, 0xBE, 0x98, 0x99, 0x97, 
0x9A, 0x9F, 0xA0, 0xDD, 0xE0, 0x74, 0x8A, 0x8B, 0x8C, 0xDE, 0xDF, 0x08, 
0x62, 0xE5, 0xF1, 0xDB, 0x23, 0xF7, 0xA4, 0xCC, 0xCD, 0xC9, 0xC4, 0x75, 
0xD6, 0xD3, 0x0C, 0x0D, 0x91, 0x1D, 0x1E, 0x0B, 0x14, 0xB2, 0x66, 0x67, 
0x9D, 0x30, 0xEE, 0x53, 0x6B, 0x05, 0x6F, 0x70, 0x71, 0x76, 0x93, 0xEF, 
0xF0, 0x51, 0x52, 0xC3, 0x58, 0xFA, 0xD8, 0x5F, 0x79, 0x7A, 0x7B, 0x7C, 
0x7D, 0x7E, 0x7F, 0x00, 0x80, 0x0E, 0x0F, 0x10, 0xEC, 0xED, 0x35, 0x13, 
0x21, 0xA2, 0x65, 0xB7, 0x4A, 0x57, 0xB5, 0x6D, 0x5C, 0x89, 0x5E, 0xAE, 
0xAF, 0xB0, 0x12, 0xD5, 0x72, 0xC6, 0xD7, 0xE1, 0xA5, 0x46, 0x15, 0x16, 
0x44, 0x43, 0xB4, 0x60, 0xE4, 0xC7, 0xC8, 0xBF, 0x85, 0x87, 0x09, 0x0A, 
0x86, 0xC1, 0xAA, 0xC5, 0xC2, 0xD9, 0xDA, 0x94, 0x95, 0xD2, 0xFB, 0x1A, 
0xFC, 0x19, 0x1B, 0xCB, 0x61, 0xE3, 0xCE, 0xCF, 0xD0, 0x3C, 0xF4, 0xF5, 
0xE6, 0xD4, 0x68, 0x56, 0xAD, 0xCA, 0xD1, 0x96, 0x90, 0xB1, 0x22, 0xE8, 
0xA6, 0x69, 0x83, 0x84, 0x31, 0xE9, 0x2A, 0x9E, 0xE2, 0x6A, 0x37, 0x2B, 
0x33, 0x20, 0xAC, 0x54, 0x42, 0x45, 0x34, 0x81, 0x82, 0xEA, 0xEB, 0x38, 
0x2E, 0x2F, 0x5A, 0x4E, 0x4F, 0x50, 0x1F, 0x8E, 0xF2, 0xF3, 0x3A, 0x3B, 
0x07, 0x63, 0x5D, 0x9B, 0x24, 0x02, 0x04, 0x47, 0xB8, 0xB9, 0xBA, 0x6C, 
0x48, 0x25, 0xC0, 0x92, 0x4B, 0x59, 0x77, 0x78, 0x4D, 0xA1, 0x39, 0x3D, 
0x3E, 0x3F, 0x40, 0x41, 0x55, 0xB3, 0x01, 0xFD, 0xFE, 0xFF, 0x06, 0x03, 
0x17, 0x18, 0xF6, 0x9C, 0x88, 0x64, 0x6E, 0x29, 0x8D, 0xDC, 0xA7, 0xA8, 
0xA9, 0x27, 0x28, 0x1C 
}; 
unsigned char final[58] = { 
0x3D, 0x38, 0x31, 0x36, 0x30, 0x34, 0x31, 0x33, 0x3C, 0x34, 0x31, 0x3A, 
0x37, 0x34, 0x3F, 0x30, 0x37, 0x33, 0x33, 0x31, 0x36, 0x34, 0x39, 0x33, 
0x3F, 0x3C, 0x30, 0x3D, 0x36, 0x3B, 0x3E, 0x3D, 0x3E, 0x32, 0x36, 0x33, 
0x31, 0x34, 0x38, 0x3D, 0x3B, 0x37, 0x3F, 0x37, 0x36, 0x3D, 0x39, 0x3E, 
0x3A, 0x3F, 0x37, 0x35, 0x3A, 0x37, 0x35, 0x3E, 0x36, 0x33 
}; 
unsigned char xor[4] = { 
0xA4, 0x66, 0x79, 0x80 
}; 
for (int j = 0; j < 29; j++) { 
unsigned char i; 
for (i = 32; i < 127; i++) { 
unsigned char key = table[i] ^ xor[j % 4]; 
unsigned char high = ((key & 0xF0) / 0x10) | 0x30; 
unsigned char low = (key & 0x0F) | 0x30; 
if (high == final[j * 2] && low == final[j * 2 + 1]) { 
printf("%c", i); 
} 
} 
} 
printf("\n"); 
return 0; 
}