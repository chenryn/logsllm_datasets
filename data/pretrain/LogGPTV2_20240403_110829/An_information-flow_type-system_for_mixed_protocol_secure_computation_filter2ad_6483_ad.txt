/ / r e a d k e y s
1 : {
/ / k e y
v a r i a b l e s
1 : prvk priv Key ;
pubk pubKey ;
1 i n t m u l t i p l y ( i n t s ,
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60 }
}
/ /
2 : z = r + x ∗ y ;
return ( i n t ) z ;
send ( 2 ,
send ( 2 ,
}
/ /
2 : {
}
/ /
1 : {
send ( 1 ,
c o m p u t e
r e c e i v e
r e c e i v e
a l s o
s h a r e s
c i p h e r t e x t s
cipher e ,
cipher∗
f , g ;
f ;
e ,
cipher e ,
cipher∗
share r ;
f , g ;
g ;
/ / s e n d 1 s t m e s s a g e
1 : {
e = encrypt ( privKey , x ) ;
f = encrypt ( privKey , y ) ;
e = rerandomize ( e , nul l ) ;
f = rerandomize ( f , nul l ) ;
e , ”E A( x A ) ”) ;
f , ”E A( y A ) ”) ;
1 s t m e s s a g e ,
s e n d 2 n d
e = read ( ”E A( x A ) ”) ;
f = read ( ”E A( y A ) ”) ;
g = modPow( e , y , n ) ;
g ∗= modPow( f , x , n ) ;
g = rerandomize ( g ,
r ) ;
g , ”E A( c ) ”) ;
s t r i n g i n ) {
share s ,
share t ) {
sub ;
s t r i n g a , b ,
1 s t r i n g s u b s t r i n g ( s t r i n g x ,
2
3
4
5
6
7
8
9
10
11
12
13
14 }
sub = r o t a t e ( x ,
sub . l e n = t ;
1 : a = mask send ( sub ) ;
2 : a = mask recv ( sub ) ;
1 : b = mask recv ( sub ) ;
2 : b = mask send ( sub ) ;
return add ( a , b ) ;
s ) ;
Listing 13: Substring: Composed Protocol
x = r e r a n d o m i z e s h i f t ( x ,
e = e n c r y p t s t r i n g ( x ) ;
s e n d s t r i n g ( ”1 ” ,
e ) ;
y = r e c v s t r i n g p u b ( ”1 ”) ;
r o t a t e l e f t ( y ,
y = r e r a n d o m i z e s t r i n g ( y ,
r o t a t e r i g h t ( r ,
x = add ( x ,
s e n d s t r i n g ( ”2 ” ,
e = e n c r y p t s t r i n g ( x ) ;
s e n d s t r i n g ( ”3 ” ,
y ) ;
e ) ;
s ) ;
r ) ;
r ;
e ;
x ;
y ;
s ) ;
}
2 : {
s t r i n g
s t r i n g x ,
s t r i n g p u b
s t r i n g p r i v
s t r i n g p u b y ;
x = i n ;
1 : {
s t r i n g p r i v e ;
1 s t r i n g r o t a t e ( share s ,
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41 }
return x ;
}
1 : {
}
2 : {
s ) ;
}
e = r e c v s t r i n g p r i v ( ”2 ”) ;
x = d e c r y p t s t r i n g ( e ) ;
r o t a t e l e f t ( x ,
y = r e c v s t r i n g p u b ( ”3 ”) ;
r o t a t e l e f t ( y ,
y = r e r a n d o m i z e s t r i n g ( y ,
s e n d s t r i n g ( ”4 ” ,
y ) ;
s ) ;
e = r e c v s t r i n g p r i v ( ”4 ”) ;
x = d e c r y p t s t r i n g ( e ) ;
r o t a t e l e f t ( x ,
s ) ;
s ) ;
r ) ;
x ) ;
2 n d m e s s a g e ,
c o m p u t e
r e s u l t
g = read ( ”E A( c ) ”) ;
z = decrypt ( g ) + x ∗ y ;
r e s u l t
a t Bo b
Listing 12: Secure Multiplication
because they need its properties in a subsequent protocol. In
this paper we do not implement this subsequent protocol and
can therefore use the more eﬃcient Naccache-Stern encryp-
tion system. There are also some helper functions for adding
(secret shares), rotating strings, re-randomization functions
for the diﬀerent string types, en-/decryption functions and
message sending functions – all not shown for brevity.
Next we consider the sub-protocols of the substring pro-
tocol. The complete rotation protocol is presented in List-
ing 14. The rotation protocol rotates the string, such that
the initial character is at position 0. This is achieved us-
Listing 14: Substring: Rotation
s t r i n g r e r a n d o m i z e s h i f t
s t r i n g
s t r i n g r ;
x ;
( s t r i n g x ,
share s ) {
x = r o t a t e r i g h t ( x ,
s ) ;
x = r e r a n d o m i z e s t r i n g ( x ,
r ) ;
x = r ;
x = r o t a t e l e f t ( x ,
return x ;
s ) ;
1
2
3
4
5
6
7
8
9
10
11 }
Listing 15: Substring: Initial Re-randomization
ing the following technique: Each share is encrypted and
sent to the other parties which then rotates it by its share
of the initial position.
It then re-randomizes it and re-
turns it before it is rotated by the local share of the ini-
tial position. This requires a particular interlocking tech-
nique. Before Alice can send her share to Bob she needs to
re-randomize it with the re-randomization values for Bob’s
share (these will cancel out). She cannot do this after she
receives the returned ciphertexts from Bob, since they are
then already rotated. Therefore, in order to implement this
protocol Alice needs to choose the re-randomization param-
eters for Bob’s share before she sends her share. This is
achieved by re-randomization using untainted variables cre-
ated in the rerandomize shift function (Listing 15). This
function creates an untainted variable containing a random
share that is already rotated by the local share of the initial
position.
We have implemented the entire protocol in one function
where each party’s code is implemented using player-speciﬁc
code. We chose this type of implementation, since the two
sides of the protocol are quite asymmetric. In line 11 (List-
ing 14) there is the call of the initial re-randomization creat-
ing the untainted variable. This untainted variable is then
used for re-randomization in line 31 (Listing 14) complet-
ing the interlock technique. Bob can simply add his re-
randomization to his share in line 20 (Listing 14).
i ++)
i f
r ;
e ;
y ;
i  b ;
s t r i n g m, y ,
m. l e n = n ;
f o r ( i n t i = 0 ;
( i < x . l e n )
m. c h a r s [ i ] = 1 ;
1 s t r i n g mask send ( s t r i n g x ) {
2
3
4
5
6