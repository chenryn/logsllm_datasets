of the passed (shell) commands. Clearly, this is outside of
the scope of this paper.
2009, Apple
In November
More precisely,
Phone Number.
re-
moved all applications developed by Storm8 due to
privacy concerns.
these applica-
tions were found to access the user’s phone number
via
the SBFormattedPhoneNumber key in the
standardUserDefaults properties. Once retrieved,
the phone number was then transmitted to Storm8’s servers.
Shortly after the ban of all
their applications, Storm8
developers released revised versions that did not contain
the offending behavior. This incident prompted Apple to
change their vetting process, and now, all applications that
access this key are rejected. Thus, to validate PiOS against
this known malicious behavior, we obtained a version of
Vampires Live (a Storm8 application) that predates this
incident, and hence, contains the offending code. PiOS
correctly and precisely identiﬁed that the phone number is
read on program startup and then sent to Storm8.
are hosted on Cydia, an unofﬁcial repository that can only
be accessed with a jailbroken phone. However, the unique
device ID of the phone is treated differently, and more than
half of the applications leak this information (often because
of advertisement and tracking libraries that are bundled with
the application). While these IDs cannot be directly linked
to a user’s identity, they allow third parties to proﬁle user
behavior. Moreover, there is always the risk that outside
information can be used to eventually make the connection
between the device ID and a user.
7 Limitations
that
Recall
Statically determining the receiver and selector for ev-
ery call to the objc_msgSend function is not always
possible.
the selector is the name of a
method. Typically, this value is a string value stored in
the __objc_selref section of the application. How-
ever, any string value can be converted to a selector, and
it is possible to write programs that receive string values
whose value cannot be statically determined (e.g., as a re-
sponse to a networking request, or as a conﬁguration value
chosen by the user). This limitation is valid for all static
analysis approaches and not speciﬁc to PiOS.
is,
. . . )
For example,
Furthermore, aggregate types in Objective-C (e.g.,
are not generic.
NSArray, NSDictionary,
That
the types of objects in such containers can-
not be speciﬁed more precisely than id (which is of
type NSObject).
the delegate method
touchesEnded:withEvent of the UIResponder
class is called whenever the user ﬁnishes a touch interac-
tion with the graphical user interface (e.g., click an element,
swipe an area, . . . ). This method receives as the ﬁrst argu-
ment a pointer to an object of type NSSet. Although this
set solely contains UITouch elements, the lack of generic
support in Objective-C prohibits the type information to be
stored with the aggregate instance. Similarly, any object can
be added to an NSArray. Thus, PiOS has to treat any value
that is retrieved from an aggregate as NSObject. Never-
theless, as described in Section 4.2.1, PiOS might still be
able to reason about the type of such an object if a subse-
quent call to the objc_msgSend function uses a selector
that is implemented by exactly one class.
8 Related Work
6.6 Discussion
With the exception of a few bad apples, we found that
a signiﬁcant majority of applications respects the personal
user information stored on iOS devices. While this could
be taken as a sign that Apple’s vetting process is successful,
we found similar results for the unchecked programs that
Clearly, static analysis and program slicing have been
used before. Weiser [19] was the ﬁrst to formalize a tech-
nique called program slicing. As outlined in Section 4.2.1,
PiOS makes use of this technique to calculate program
slices that deﬁne receiver and selector values at call-sites
to the objc_msgSend dynamic dispatch function.
Also, static binary analysis was used in the past for vari-
ous purposes. Kruegel et al. [15] made use of static analysis
to perform mimicry attacks on advanced intrusion detection
systems that monitor system call invocations. Christodor-
escu and Jha [6] present a static analyzer for executables
that is geared towards detecting malicious patterns in bina-
ries even if the content is obfuscated. Similarly, the work
described in Christodorescu [7] et al. is also based on bi-
nary static analysis, and identiﬁes malicious software using
a semantics-aware malware detection algorithm. However,
some of the obfuscation techniques available on the x86 ar-
chitecture cannot be used on ARM based processors. The
RISC architecture of ARM facilitates more robust disas-
sembly of binaries, as instructions cannot be nested within
other instructions. Furthermore, the strict memory align-
ment prohibits to jump to the middle of ARM instructions.
Thus, disassembling ARM binaries generally produces bet-
ter results than disassembling x86 binaries.
Note that while static binary analysis is already challeng-
ing in any domain, in our work, the analysis is further com-
plicated by the fact that most iOS applications are devel-
oped in Objective-C. It is not trivial to obtain a meaningful
program control ﬂow graph for iOS applications.
In [4], Calder and Grunwald optimize object code of
C++ programs by replacing virtual function calls with di-
rect calls if the program contains exactly one implementa-
tion that matches the signature of the virtual function. This
is possible because the mangled name of a function stored in
an object ﬁle, contains information on the class and param-
eter types. PiOS uses a similar technique to resolve the type
of a receiver of a message. However, PiOS only follows this
approach if the type of the receiver cannot be determined by
backwards slicing and constant propagation.
In another work, Dean et al. [9] present an approach that
performs class hierarchy analysis to statically resolve vir-
tual function calls and replace them with direct function
calls. In PiOS, we do not use the class hierarchy to resolve
the invoked method. However, we do use this information to
verify that the results of the backwards slicing and forward
propagation step are consistent with the class hierarchy, and
thus sensible.
PiOS is also related to existing approaches that perform
static data ﬂow analysis. Livshits and Lam [16], for exam-
ple, use static taint analysis for Java byte-code to identify
vulnerabilities that result from incomplete input validation
(e.g., SQL injection, cross site scripting). The main focus of
Tripp et al. [18] is to make static taint analysis scale to large
real-world applications. To this end, the authors introduce
hybrid thin-slicing and combine it with taint analysis to ana-
lyze large web applications, even if they are based on appli-
cation frameworks, such as Struts or Spring. Furthermore,
Pixy [14] performs inter-procedural, context-sensitive data-
ﬂow analysis on PHP web-applications, and also aims to
identify such taint-style vulnerabilities.
There has also been some related work in the domain
of mobile devices: Enck et al. [10] published TaintDroid, a
system that shares a similar goal with this work; namely, the
analysis of privacy leaks in smart phone applications. Dif-
ferent to our system, their work targets Android applications
and performs dynamic information-ﬂow tracking to identify
privacy leaks. Most Android applications are executed by
the open source Dalvik virtual machine. The information-
ﬂow capabilities of TaintDroid were build into a modiﬁed
version of this VM. iOS applications, in contrast, are com-
piled into native code and executed by the device’s CPU
directly. TaintDroid was evaluated on 30 popular Android
applications. The results agree quite well with our ﬁndings.
In particular, many of the advertising and statistics libraries
that we identiﬁed in Section 6.2 also have corresponding
Android versions. As a result, TaintDroid raised alerts when
applications transmitted location data to AdMob, Mobclix,
and Flurry back-end servers.
Furthermore, Enck et al. [11] present an approach named
Kirin where they automatically extract the security manifest
of Android applications. Before an application is installed,
this manifest is evaluated against so-called logic invariants.
The result is that the user is only prompted for her con-
sent to install the application if these invariants are violated.
That is, only applications that violate a user’s assumption
of privacy and security are prompted for the user agreement
during installation. The concept of a security manifest pro-
vides the user basic information on which she can base her
decision on whether to install an application or not. Unfor-
tunately, the iOS platform does not provide such amenities.
To take a decision, the user can only rely on the verbal de-
scription of the application and Apple’s application vetting
process.
Another work that focuses on Android is the formal lan-
guage presented by Chaudhuri [5]. Together with opera-
tional semantics and a type system, the author created the
language with the aim of being able to describe Android
applications with regard to security properties. However,
the language currently only supports Android-speciﬁc con-
structs. That is, the general Java constructs that build the
majority of an application’s code cannot currently be repre-
sented.
To the best of our knowledge, we are the ﬁrst to propose
an automated approach to perform an in-depth privacy anal-
ysis of iOS applications.
9 Conclusions
The growing popularity and sophistication of smart-
phones, such as the iPhone or devices based on Android,
have also increased concerns about the privacy of their
users. To address these concerns, smartphone OS design-
ers have been using different security models to protect the
security and privacy of users. For example, Android appli-
cations are shipped with a manifest that shows all required
permissions to the user at installation time. In contrast, Ap-
ple has decided to take the burden off its iPhone users and
determine, on their behalf, if an application conforms to
the predeﬁned privacy rules. Unfortunately, Apple’s vet-
ting process is not public, and there have been cases in the
past (e.g., [20]) where vetted applications have been discov-
ered to be violating the privacy rules deﬁned by Apple.
The goal of the work described in this paper is to auto-
matically analyze iOS applications and to study the threat
they pose to user data. We present a novel approach that
is able to automatically create comprehensive CFGs from
binaries compiled from Objective-C code. We can then per-
form reachability analysis on the generated CFGs and iden-
tify private data leaks. We have analyzed more than 1,400
iPhone applications. Our experiments show that most appli-
cations do not secretly leak any sensitive information that
can be attributed to a person. This is true both for vetted
applications on the App Store and those provided by Cy-
dia. However, a majority of applications leaks the device
ID, which can provide detailed information about the habits
of a user. Moreover, there is always the possibility that addi-
tional data is used to tie a device ID to a person, increasing
the privacy risks.
Acknowledgements
The research leading to these results has received
funding from the European Union Seventh Framework
Programme (FP7/2007-2013) under grant agreement no
257007. This work has also been supported in part by
Secure Business Austria and the European Commission
through project IST-216026-WOMBAT funded under the
7th framework program. This work was also partially sup-
ported by the ONR under grant N000140911042 and by
the National Science Foundation (NSF) under grants CNS-
0845559, CNS-0905537, and CNS-0716095.
References
[1] http://thebigboss.org.
[2] AppTrakr, Complete App Store Ranking.
http://
apptrakr.com/.
Developer
[3] iPhone
Program License
Agreement.
http://www.eff.org/files/20100302_
iphone_dev_agr.pdf.
[4] B. Calder and D. Grunwald. Reducing indirect function call
In POPL ’94: Proceedings of
overhead in c++ programs.
the 21st ACM SIGPLAN-SIGACT symposium on Principles
of programming languages, pages 397–408, New York, NY,
USA, 1994. ACM.
[5] A. Chaudhuri. Language-based security on android. In ACM
Workshop on Programming Languages and Analysis for Se-
curity (PLAS), 2009.
[6] M. Christodorescu and S. Jha. Static analysis of executables
In SSYM’03: Proceedings of
to detect malicious patterns.
the 12th conference on USENIX Security Symposium, pages
12–12, Berkeley, CA, USA, 2003. USENIX Association.
[7] M. Christodorescu, S. Jha, S. A. Seshia, D. Song, and R. E.
Bryant. Semantics-aware malware detection. In IEEE Sym-
posium on Security and Privacy (Oakland), 2005.
[8] A. Cohen.
The iPhone Jailbreak: A Win Against
http://www.time.com/time/
Copyright Creep.
nation/article/0,8599,2006956,00.html.
[9] J. Dean, D. Grove, and C. Chambers. Optimization of
object-oriented programs using static class hierarchy anal-
ysis. In European Conference on Object-Oriented Program-
ming, 1995.
[10] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung, P. Mc-
Daniel, and A. N. Sheth. TaintDroid: an information-ﬂow
tracking system for realtime privacy monitoring on smart-
phones. In Proceedings of OSDI 2010, October 2010.
[11] W. Enck, M. Ongtang, and P. McDaniel. Understanding an-
droid security. IEEE Security and Privacy, 7(1):50–57, 2009.
[12] J. Freeman. http://cydia.saurik.com/.
[13] Gartner Newsroom. Competitive Landscape: Mobile De-
vices, Worldwide, 2Q10. http://www.gartner.com/
it/page.jsp?id=1421013, 2010.
[14] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: A static anal-
ysis tool for detecting web application vulnerabilities (short
paper). In IEEE Symposium on Security and Privacy, 2006.
[15] C. Kruegel, E. Kirda, D. Mutz, W. Robertson, and G. Vigna.
Automating mimicry attacks using static binary analysis. In
14th USENIX Security Symposium, 2005.
[16] V. B. Livshits and M. S. Lam. Finding security vulnerabili-
ties in java applications with static analysis. In 14th USENIX
Security Symposium, 2005.
[17] N. Seriot.
iPhone Privacy. http://www.blackhat.
com/presentations/bh-dc-10/Seriot_
Nicolas/BlackHat-DC-2010-Seriot-iPhone%
2dPrivacy-slides.pdf.
[18] O. Tripp, M. Pistoia, S. J. Fink, M. Sridharan, and O. Weis-
In
man. Taj: effective taint analysis of web applications.
ACM Conference on Programming Language Design and
Implementation, 2009.
[19] M. Weiser. Program slicing. In ICSE ’81: Proceedings of the
5th international conference on Software engineering, pages
439–449, Piscataway, NJ, USA, 1981. IEEE Press.
[20] Wired.
Apple
Approves,
Pulls
App with Hidden Tethering Mode.
//www.wired.com/gadgetlab/2010/07/
apple-approves-pulls-flashlight%
2dapp-with-hidden-tethering-mode/.
Flashlight
http: