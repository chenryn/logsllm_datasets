EARs mistakenly reported as vulnerable, and false EARs
(false positives).
As shown in Table 2, the white-box tool generated 45 false
EARs, for a false positive rate of 5.3%. These false positives
came from two main categories. About half of the false posi-
tives were due to impossible paths from the redirect methods
to some code. An example of this is when a redirect method
was called at the end of a branch that checked that the re-
quest was an HTTP GET, while the code executed after a
redirect was in a branch that checked that the request was
an HTTP POST. These two conditions are mutually exclu-
sive, thus, this path is impossible. The other half of false
positives were due to local variables that had the same name
as a redirect method. The parsing library, RIL, mistakenly
identiﬁed the local variable access as a method call to a redi-
rect method. We are currently looking into ﬁxing this issue
in RIL, which will almost halve our false positive rate.
While our false EAR rate was only 5.5%, our vulnerable
EAR detection heuristic had a higher false detection rate of
40.1%. The biggest culprit for false vulnerable EARs (72.9%
of the instances) was due to no feasible path from the redi-
rect to the method that changed the state of the database.
For instance, the redirect method occurred in a branch that
was taken only when a certain object was nil7. Later, the
database method was called on this object. Thus, when the
redirect happens, the object will be nil. Because of the pres-
ence of an EAR ﬂaw, execution will continue and reach the
database access method. However, since the object is nil,
the database will not be aﬀected. Because our heuristics
cannot detect the fact that, after the redirect, the database
function will always be called with a nil object, we report
a vulnerability. The other common false vulnerable EAR
were instances where the redirect method was called before
code was executed, however, it was clear that the developer
was fully aware of the redirect semantics and intended for
the code to be executed.
We also checked that the false EAR rate did not diﬀer
signiﬁcantly among the benign EARs by manually inspect-
ing 200 random EARs reported as benign. We saw 13 false
EARs in the manual inspection, for a false positive rate of
6.5%. Thus, the total false positive rate among the instances
we manually inspected is 5.5%. We also did not see any vul-
nerable EARs among the benign EARs, thus, we did not see
any false negative vulnerable EARs in our experiments.
7nil is Ruby’s null
To evaluate the performance of our tool, we measured the
running time against the 18,127 Ruby on Rails applications.
We ran our experiments on an Intel Core i7 with 12 gigabytes
of RAM. Our algorithm scales linearly with the size of the
CFG and is fast; no project took longer than 2.5 seconds
even with the largest CFG size of 40,217 statements.
5. PREVENTION
The old adage “an ounce of prevention is worth a pound
of cure” is true in software. Boehm showed that the later
in an application’s life-cycle bugs are caught, the more ex-
pensive they are to ﬁx [8]. Thus, preventing certain types
of bugs from even being introduced is attractive from both
an economic standpoint, and a security perspective. Our
recommendation to web frameworks, therefore, is to make
Execution After Redirect vulnerabilities impossible to oc-
cur, by having every invocation of the redirect method halt
execution, which we call halt-on-redirect behavior.
As we have shown in Section 2.4, some frameworks have
already either adopted the approach of making EARs im-
possible, or their approach to generating HTTP responses
makes EARs highly unlikely. For existing frameworks that
wish to decrease the chance of EARs being introduced, such
draconian measures may not be acceptable because they
break backward-compatibility. Our suggestion in these cases
is to make an application-wide setting to enable halt-on-
redirect behavior, along with an argument to the redirect
function to halt execution after the redirect. Of course, we
suggest making halt-on-redirect the default behavior, how-
ever each framework will have to properly balance security
and backward-compatibility.
To improve the security of Ruby on Rails, we are in discus-
sions with the Rails development team about our proposed
change. The diﬃculty with implementing halt-on-redirect
behavior in Rails is that there are no gotos, and Rails appli-
cations run in a single-threaded context. This limits the two
obvious forms of implementing halt-on-redirect: we cannot
use a goto or language equivalent statement to jump from
the end of the redirect_to method to the code after the
controller is called. Moreover, we also cannot, at the end
of the redirect_to method, send the HTTP response and
cause the current thread to stop execution. PHP frameworks
can use the exit function to implement halt-on-redirect be-
havior, because each request spawns a new PHP process.
Our proposed solution is to throw a new type of exception,
RedirectOccuredException, at the end of the redirect_to
body. In the Ruby on Rails framework core, where the con-
troller is called, there is a catch block for this exception.
While this will prevent almost all EARs, there is a possi-
bility for code to be executed in an ensure block, Ruby’s
equivalent of a “ﬁnally” block. Code in this block will be ex-
ecuted regardless of a redirect. However, we believe this is
semantically in line with the way the language should work:
ensure blocks will always be executed, no matter what hap-
pens, and this is clear to the programmer via the language’s
semantics.
6. RELATED WORK
Speciﬁc instances of Execution After Redirect vulnera-
bilities have been previously identiﬁed. Hofstetter wrote a
blog post alerting people to not forget to exit after a redi-
rect when using the PHP framework CakePHP [22]. This
discussion resulted in a bug being ﬁled with the CakePHP
team [9]. This bug was resolved by updating the CakePHP
documentation to indicate the redirect method did not end
execution [10].
Felmetsger et al. presented a white-box static analysis tool
for J2EE servlets to automatically detect logic ﬂaws in web
applications. The tool, Waler, found Execution After Redi-
rect vulnerabilities in a web application called Global In-
ternship Management System (GIMS) [17]. However, nei-
ther Felmetsger nor Hofstetter identiﬁed EARs as a systemic
ﬂaw among web applications.
Wang et al. manually discovered logic ﬂaws in the interac-
tion of Cashier-as-a-Service (CaaS) APIs and the web appli-
cations that use them [35]. This is interesting because there
is a three-way interaction between the users, the CaaS, and
the web application. In our work, we consider one speciﬁc
type of logic ﬂaw across many applications.
Our white-box EAR detection tool uses the Ruby Inter-
mediate Language (RIL) developed by Furr et al. [18]. RIL
was used by An et al. to introduce static typing to Ruby on
Rails [23]. They use the resulting system, DRails, on eleven
Rails applications to statically discover type errors. DRails
parses Rails applications by compiling them to equivalent
Ruby code, making implicit Rails conventions explicit. This
diﬀers from our tool, which operates directly on the Rails
application’s control ﬂow graph. Moreover, we are looking at
a speciﬁc logic ﬂaw, while DRails is looking for type errors.
Chaudhuri and Foster built a symbolic analysis engine on
top of DRails, called Rubyx [13]. They are able to analyze
the security properties of Rails applications using symbolic
execution. Rubyx detected XSS, XSRF, session manipu-
lation, and unauthorized access in the seven applications
tested. Due to the symbolic execution and verifying of path
conditions, false positives are reduced. However, Rubyx re-
quires the developer to manually specify an analysis script
that deﬁnes invariants on used objects, as well as the se-
curity requirements of the applications. Our tool, on the
other hand, operates on raw, unmodiﬁed Rails applications,
and does not require any developer input. This is due to
the diﬀerent focus; we are focusing on one speciﬁc type of
ﬂaw, while Rubyx is broader and can verify diﬀerent types
of security violations.
Our work is also related to numerous white-box tools that
have previously been published. Huang et al. were one
of the ﬁrst to propose a static analysis tool for a server-
side scripting language, speciﬁcally PHP. They implemented
taint propagation to detect XSS, SQL injection, and general
injection [24]. Livshits and Lam proposed a static analysis
technique for Java web applications that used points-to anal-
ysis for improved precision [28]. Their tool detected 29 in-
stances of SQL injection, XSS, HTTP response splitting, and
command injection in nine open-source applications. Jo-
vanovic et al. developed Pixy, an open-source static analysis
tool to discover XSS attacks by performing ﬂow-sensitive,
inter-procedural, and context-sensitive data ﬂow analysis
on PHP web applications [26]. They later improved Pixy,
adding precise alias analysis, to discover hundreds of XSS
vulnerabilities in three PHP applications, half of which were
false positives [25]. Balzarotti et al. used static and dynamic
analysis to develop MiMoSa, a tool that performs inter-
module data ﬂow analysis to discover attacks that leverage
several modules, such as stored XSS. They found 27 data
ﬂow violations in ﬁve PHP web applications [4].
All of these static analysis tools diﬀer from our white box
tool because we are not looking for unsanitized input vul-
nerabilities, but rather for unexpected execution that a de-
veloper did not intend. We also performed our analysis on
a large corpus of real-world applications, and found a corre-
spondingly large number of true vulnerable EARs.
7. CONCLUSIONS
We have described a new type of vulnerability, Execution
After Redirect, and developed a novel static analysis tool to
eﬀectively ﬁnd EARs. We showed that EARs are diﬃcult to
diﬀerentiate between benign and vulnerable. This diﬃculty
is due to vulnerable EARs violating the speciﬁc logic of the
web application. Better understanding of the application’s
logic should help diﬀerentiate vulnerable and benign EARs
and it will be the focus of future work.
Acknowledgments
This work was also partially supported by the ONR under
grant N000140911042, by the National Science Foundation
(NSF) under grants CNS-0820907, CNS-0905537, and CNS-
0716095, and by Secure Business Austria.
8. REFERENCES
[1] ASP.NET MVC. http://www.asp.net/mvc.
[2] Balduzzi, M., Egele, M., Kirda, E., Balzarotti,
D., and Kruegel, C. A Solution for the Automated
Detection of Clickjacking Attacks. In Proceedings of
the ACM Symposium on Information, Computer and
Communications Security (AsiaCCS) (Beijing, China,
April 2010).
[3] Balduzzi, M., Gimenez, C., Balzarotti, D., and
Kirda, E. Automated discovery of parameter
pollution vulnerabilities in web applications. In
Proceedings of the 18th Network and Distributed
System Security Symposium (2011).
[4] Balzarotti, D., Cova, M., Felmetsger, V. V.,
and Vigna, G. Multi-module vulnerability analysis of
web-based applications. In Proceedings of the 14th
ACM conference on Computer and communications
security (New York, NY, USA, 2007), CCS ’07, ACM,
pp. 25–35.
[5] Barth, A., Jackson, C., and Mitchell, J. C.
Robust defenses for cross-site request forgery. In
Proceedings of the 15th ACM Conference on Computer
and Communications Security (CCS 2008) (2008).
[6] Boe, B. UCSB’s International Capture The Flag
Competition 2010 Challenge 6: Fear The EAR.
http://cs.ucsb.edu/~bboe/r/ictf10, December
2010.
[7] Boe, B. Using StackOverﬂow’s API to Find the Top
Web Frameworks. http://cs.ucsb.edu/~bboe/r/
top-web-frameworks, February 2011.
[8] Boehm, B. W. Software Engineering Economics,
1st ed. Prentice Hall PTR, Upper Saddle River, NJ,
USA, 1981.
24th IEEE/ACM Conference on Automated Software
Engineering (ASE’09) (2009), IEEE, pp. 590–594.
[24] Huang, Y.-W., Yu, F., Hang, C., Tsai, C.-H.,
Lee, D.-T., and Kuo, S.-Y. Securing web
application code by static analysis and runtime
protection. In Proceedings of the 13th international
conference on World Wide Web (New York, NY, USA,
2004), WWW ’04, ACM, pp. 40–52.
[9] Include exit with a redirect call. http://replay.web.
[25] Jovanovic, N., Kruegel, C., and Kirda, E. Pixy:
archive.org/20061011152124/https://trac.
cakephp.org/ticket/1076, August 2006.
[10] docs should mention redirect does not ”exit” a script.
http://replay.web.archive.org/20061011180440/
https://trac.cakephp.org/ticket/1358, August
2006.
[11] Cake Software Foundation, Inc. The CakePHP
1.3 Book. http://book.cakephp.org/view/982/
redirect, 2011.
[12] Carettoni, L., and Di Paola, S. HTTP Parameter
Pollution. OWASP AppSec Europe 2009, May 2009.
[13] Chaudhuri, A., and Foster, J. Symbolic security
analysis of ruby-on-rails web applications. In
Proceedings of the 17th ACM Conference on Computer
and Communications Security (CCS’10) (2010), ACM,
pp. 585–594.
[14] Childers, N., Boe, B., Cavallaro, L., Cavedon,
L., Cova, M., Egele, M., and Vigna, G.
Organizing large scale hacking competitions. In
Proceedings of the 7th international conference on
Detection of intrusions and malware, and vulnerability
assessment (Berlin, Heidelberg, 2010), DIMVA’10,
Springer-Verlag, pp. 132–152.
[15] Django Software Foundation. Django shortcut
functions. http://docs.djangoproject.com/en/dev/
topics/http/shortcuts/#django.shortcuts.
redirect, 2011.
[16] EllisLab, Inc. CodeIgniter User Guide Version 2.0.2.
http://codeigniter.com/user_guide/helpers/url_
helper.html, 2011.
[17] Felmetsger, V., Cavedon, L., Kruegel, C., and
Vigna, G. Toward Automated Detection of Logic
Vulnerabilities in Web Applications. In Proceedings of
the USENIX Security Symposium (Washington, DC,
August 2010).
[18] Furr, M., hoon (David) An, J., Foster, J. S.,
and Hicks, M. The Ruby intermediate language. In
Proceedings of the ACM SIGPLAN Dynamic
Languages Symposium (DLS) (Oct. 2009).
[19] GitHub. http://github.com.
[20] Indictment in U.S. v. Albert Gonzalez. http://www.
justice.gov/usao/ma/news/IDTheft/Gonzalez,
%20Albert%20-%20Indictment%20080508.pdf, August
2008.
[21] Hansen, R. Clickjacking. http://ha.ckers.org/
blog/20080915/clickjacking/, September 2008.
[22] Hofstetter, D. Don’t forget to exit after a redirect.
http://cakebaker.wordpress.com/2006/08/28/
dont-forget-to-exit-after-a-redirect/, August
2006.
[23] hoon An, J., Chaudhuri, A., and Foster, J.
Static typing for ruby on rails. In Proceedings of the
A static analysis tool for detecting web application
vulnerabilities (short paper). In IN 2006 IEEE
SYMPOSIUM ON SECURITY AND PRIVACY
(2006), pp. 258–263.
[26] Jovanovic, N., Kruegel, C., and Kirda, E.
Precise alias analysis for static detection of web
application vulnerabilities. In Proceedings of the 2006
workshop on Programming languages and analysis for
security (New York, NY, USA, 2006), PLAS ’06,
ACM, pp. 27–36.
[27] Klein, A. Divide and conquer: HTTP response
splitting, Web cache poisoning attacks, and related
topics. http://www.packetstormsecurity.org/
papers/general/whitepaper/httpresponse.pdf,
2004.
[28] Livshits, V. B., and Lam, M. S. Finding security
vulnerabilities in java applications with static analysis.
In Proceedings of the 14th conference on USENIX
Security Symposium - Volume 14 (Berkeley, CA, USA,
2005), USENIX Association, pp. 18–18.
[29] Open Web Application Security Project
(OWASP). OWASP Top Ten Project. http://www.
owasp.org/index.php/Top_10, 2010.
[30] Ortiz, C. Outcome of sentencing in U.S. v. Albert
Gonzalez. http://www.justice.gov/usao/ma/news/
IDTheft/09-CR-10382/GONZALEZ%20website%20info
%205-11-10.pdf, March 2010.
[31] R. Fielding, J. Gettys, J. M. H. F. L. M. P. L.
T. B.-L. RFC 2616: Hypertext Transfer Protocol –
HTTP/1.1 Status Code Deﬁnitions. http://www.w3.
org/Protocols/rfc2616/rfc2616-sec10.html, June
1999.
[32] R. Fielding, J. Gettys, J. M. H. F. L. M. P. L.
T. B.-L. RFC 2616: Hypertext Transfer Protocol –
HTTP/1.1 Header Field Deﬁnitions. http://www.w3.
org/Protocols/rfc2616/rfc2616-sec14.html#
sec14.30, June 1999.
[33] Reenskaug, T. Models - views - controllers. Tech.
rep., Xerox Parc, 1979.
[34] SpringSource. Contollers - Redirects. http://www.
grails.org/Controllers+-+Redirects, 2010.
[35] Wang, R., Chen, S., Wang, X., and Qadeer, S.
How to shop for free online - security analysis of
cashier-as-a-service based web stores. In Proceedings of
the 32nd IEEE Symposium on Security and Privacy
(Oakland, CA, May 2011), IEEE.
[36] Zend Technologies Ltd. Zend Framework:
Documentation: Action Helpers - Zend Framework
Manual. http://framework.zend.com/manual/en/
zend.controller.actionhelpers.html#zend.
controller.actionhelpers.redirector, 2011.