term session secrets never need to leave this wrapper. The
only secrets that remain outside our wrapper are the long-
term identity keys and medium-term prekeys. These keys are
needed for session setup, but once the ﬁrst two messages have
been exchanged, even a bug that reveals all these long-term
and medium-term keys to the adversary will not reveal the
messaging keys. Hence, our defensive design tries to preserve
Signal’s forward secrecy guarantees even against buggy soft-
ware components. However, note that this protection is partial
and unveriﬁed; to fully protect against malicious JavaScript
applications, we would need further defensive measures, like
those proposed in prior work [27], [42], [43].
Evaluation. LibSignal-JavaScript comes with a comprehen-
sive browser-based test-suite. We ran these tests on our
modiﬁed LibSignal implementation to verify that our veriﬁed
code interoperates correctly with the rest of LibSignal. This
demonstrates that our implementation can be used as a drop-
in replacement for LibSignal-JavaScript in applications like
WhatsApp, Skype and Signal. The performance of our code is
roughly the same as unmodiﬁed LibSignal: any speed improve-
ments we may anticipate by using WebAssembly is offset by
the overhead of encoding and decoding data structures between
JavaScript and WebAssembly. Furthermore, our code has to
use WebAssembly implementations even for cryptographic
algorithms like AES-CBC and HMAC-SHA256 for which fast
native implementations are available in the WebCrypto API but
as async functions that cannot be called from WebAssembly.
Our modiﬁed LibSignal is a useful proof-of-concept appli-
cable to real-world cryptographic applications deployed today.
However, a principled approach when building new Web
applications would be to design the application with clean
WebAssembly-friendly APIs between the JavaScript and ver-
iﬁed WebAssembly components. We advocate that the Web-
Crypto API be extended to cover more modern cryptographic
primitives,
it also provide a synchronous API usable
from WebAssembly, and that mainstream browsers use veriﬁed
crypto code in C or assembly [44]–[48] to implement this API.
When veriﬁed native crypto is unavailable, applications can
fall back to veriﬁed WASM crypto libraries like WHACL∗.
that
1269
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:34 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1] “The lastpass password manager.” [Online]. Available: https://www.
lastpass.com/how-lastpass-works
[2] M. Marlinspike and T. Perrin, “The x3dh key agreement protocol,” 2016,
https://signal.org/docs/speciﬁcations/x3dh/.
[3] T. Perrin and M. Marlinspike, “The double ratchet algorithm,” 2016,
https://signal.org/docs/speciﬁcations/doubleratchet/.
[4] A. Haas, A. Rossberg, D. L. Schuff, B. L. Titzer, M. Holman,
D. Gohman, L. Wagner, A. Zakai, and J. Bastien, “Bringing the web
up to speed with webassembly,” in ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI), 2017, pp.
185–200.
[5] C. Watt, “Mechanising and verifying the webassembly speciﬁcation,”
in Proceedings of the 7th ACM SIGPLAN International Conference on
Certiﬁed Programs and Proofs. ACM, 2018, pp. 53–65.
[6] A. Guha, C. Saftoiu, and S. Krishnamurthi, “The essence of javascript,”
Springer,
in European conference on Object-oriented programming.
2010, pp. 126–150.
[7] M. Bodin, A. Chargu´eraud, D. Filaretti, P. Gardner, S. Maffeis,
D. Naudziuniene, A. Schmitt, and G. Smith, “A trusted mechanised
javascript speciﬁcation,” in ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages (POPL), 2014, pp. 87–100.
[8] J. Renner, S. Cauligi, and D. Stefan, “Constant-time webassembly,”
2018, https://cseweb.ucsd.edu/∼dstefan/pubs/renner:2018:ct-wasm.pdf.
[9] J. Protzenko, J.-K. Zinzindohou´e, A. Rastogi, T. Ramananandro,
P. Wang, S. Zanella-B´eguelin, A. Delignat-Lavaud, C. Hrit¸cu, K. Bhar-
gavan, C. Fournet, and N. Swamy, “Veriﬁed low-level programming
embedded in f*,” Proceedings of the ACM on Programming Languages,
vol. 1, no. ICFP, pp. 17:1–17:29, Aug. 2017.
[10] N. Swamy, C. Hricu, C. Keller, A. Rastogi, A. Delignat-Lavaud,
S. Forest, K. Bhargavan, C. Fournet, P.-Y. Strub, M. Kohlweiss, J.-K.
Zinzindohoue, and S. Zanella-B´eguelin, “Dependent types and multi-
monadic effects in F*,” in ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages (POPL), 2016, pp. 256–270.
[11] “Web cryptography api.” [Online]. Available: https://www.w3.org/TR/
WebCryptoAPI
[12] B. Beurdouche, K. Bhargavan, A. Delignat-Lavaud, C. Fournet,
M. Kohlweiss, A. Pironti, P. Strub, and J. K. Zinzindohoue, “A messy
state of the union: Taming the composite state machines of TLS,” in
IEEE Symposium on Security and Privacy (Oakland), 2015, pp. 535–
552.
[13] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti, and P. Strub,
“Implementing TLS with veriﬁed cryptographic security,” in IEEE
Symposium on Security and Privacy (Oakland), 2013, pp. 445–459.
[14] A. Delignat-Lavaud, C. Fournet, M. Kohlweiss, J. Protzenko, A. Rastogi,
N. Swamy, S. Z. B´eguelin, K. Bhargavan, J. Pan, and J. K. Zinzindo-
houe, “Implementing and proving the TLS 1.3 record layer,” in IEEE
Symposium on Security and Privacy (Oakland), 2017, pp. 463–482.
[15] K. Bhargavan, B. Blanchet, and N. Kobeissi, “Veriﬁed models and
reference implementations for the TLS 1.3 standard candidate,” in IEEE
Symposium on Security and Privacy (Oakland), 2017, pp. 483–502.
[16] N. Kobeissi, K. Bhargavan, and B. Blanchet, “Automated veriﬁcation for
secure messaging protocols and their implementations: A symbolic and
computational approach,” in 2nd IEEE European Symposium on Security
and Privacy (EuroSP), 2017, pp. 435–450.
[17] B. Blanchet, “Modeling and verifying security protocols with the applied
pi calculus and proverif,” Foundations and Trends in Privacy and
Security, vol. 1, no. 1-2, pp. 1–135, Oct. 2016.
[18] J.-K. Zinzindohou´e, K. Bhargavan, J. Protzenko, and B. Beurdouche,
“HACL*: A veriﬁed modern cryptographic library,” in ACM SIGSAC
Conference on Computer and Communications Security (CCS), ser. CCS
’17, 2017, pp. 1789–1806.
[19] D. J. Bernstein, “Curve25519: new difﬁe-hellman speed records,” in
Public Key Cryptography-PKC 2006. Springer, 2006, pp. 207–228.
[20] D. J. Bernstein, B. Van Gastel, W. Janssen, T. Lange, P. Schwabe,
and S. Smetsers, “Tweetnacl: A crypto library in 100 tweets,” in
International Conference on Cryptology and Information Security in
Latin America (LATINCRYPT). Springer, 2014, pp. 64–83.
[21] D. Benjamin, “poly1305-x86.pl produces incorrect output,” https://mta.
openssl.org/pipermail/openssl-dev/2016-March/006161, 2016.
[22] H. B¨ock, “Wrong results with Poly1305 functions,” https://mta.openssl.
org/pipermail/openssl-dev/2016-March/006413, 2016.
[23] A. Zakai, “Emscripten: An llvm-to-javascript compiler,” in ACM In-
ternational Conference Companion on Object Oriented Programming
Systems Languages and Applications Companion (OOPSLA), 2011, pp.
301–312.
[24] A. Taly, ´U. Erlingsson, J. C. Mitchell, M. S. Miller, and J. Nagra, “Auto-
mated analysis of security-critical javascript apis,” in IEEE Symposium
on Security and Privacy (Oakland), 2011, pp. 363–378.
[25] K. Bhargavan, A. Delignat-Lavaud, and S. Maffeis, “Defensive
javascript,” in Foundations of Security Analysis and Design VII.
Springer, 2014, pp. 88–123.
[26] C. Fournet, N. Swamy, J. Chen, P.-E. Dagand, P.-Y. Strub, and
B. Livshits, “Fully abstract compilation to javascript,” in ACM SIGPLAN
Notices, vol. 48, no. 1. ACM, 2013, pp. 371–384.
[27] N. Swamy, C. Fournet, A. Rastogi, K. Bhargavan, J. Chen, P. Strub,
and G. M. Bierman, “Gradual typing embedded securely in javascript,”
in ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages (POPL), 2014, pp. 425–438.
[28] D. Ahman, C. Hrit¸cu, K. Maillard, G. Mart´ınez, G. Plotkin, J. Protzenko,
A. Rastogi, and N. Swamy, “Dijkstra monads for free,” in ACM
SIGPLAN Notices, vol. 52, no. 1. ACM, 2017, pp. 515–529.
[29] X. Leroy, “Formal veriﬁcation of a realistic compiler,” Communications
of the ACM, vol. 52, no. 7, pp. 107–115, 2009.
[30] D. J. Bernstein, T. Lange, and P. Schwabe, “The security impact of a
new cryptographic library,” in International Conference on Cryptology
and Information Security in Latin America (LATINCRYPT). Springer,
2012, pp. 159–176.
[31] “Can i use: Webassembly.” [Online]. Available: https://caniuse.com/
#feat=wasm
[32] A. Jangda, B. Powers, A. Guha, and E. Berger, “Mind the gap: Analyzing
the performance of webassembly vs. native code,” 2019.
[33] J. B. Almeida, M. Barbosa, G. Barthe, F. Dupressoir, and M. Emmi,
“Verifying constant-time implementations,” in USENIX Security Sympo-
sium, 2016, pp. 53–70.
[34] G. Barthe, B. Gr´egoire, and V. Laporte, “Secure compilation of side-
channel countermeasures: The case of cryptographic ”constant-time”,”
in IEEE Computer Security Foundations Symposium (CSF), 2018, pp.
328–343.
[35] C. Watt, J. Renner, N. Popescu, S. Cauligi, and D. Stefan, “Ct-wasm:
Type-driven secure cryptography for the web ecosystem,” arXiv preprint
arXiv:1808.01348, 2018.
[36] K. Cohn-Gordon, C. J. F. Cremers, and L. Garratt, “On post-compromise
security,” in IEEE 29th Computer Security Foundations Symposium
(CSF), 2016, pp. 164–178.
[37] K. Cohn-Gordon, C. J. F. Cremers, B. Dowling, L. Garratt, and D. Ste-
bila, “A formal security analysis of the signal messaging protocol,” in
IEEE European Symposium on Security and Privacy (EuroS&P), 2017,
pp. 451–466.
[38] M. Bellare, A. C. Singh, J. Jaeger, M. Nyayapati, and I. Stepanovs,
“Ratcheted encryption and key exchange: The security of messaging,”
in CRYPTO, 2017, pp. 619–650.
[39] J. Jaeger and I. Stepanovs, “Optimal channel security against ﬁne-
grained state compromise: The safety of messaging,” in CRYPTO, Cham,
2018, pp. 33–62.
[40] B. Poettering and P. R¨osler, “Towards bidirectional ratcheted key ex-
change,” in CRYPTO, Cham, 2018, pp. 3–32.
[41] T. Perrin, “The xeddsa and vxeddsa signature schemes,” 2017, https:
//signal.org/docs/speciﬁcations/xeddsa/.
[42] K. Bhargavan, A. Delignat-Lavaud, and S. Maffeis, “Language-based
defenses against untrusted browser origins,” in Proceedings of the 22th
USENIX Security Symposium, 2013, pp. 653–670.
[43] ——, Defensive JavaScript, 2014, pp. 88–123.
[44] L. Beringer, A. Petcher, K. Q. Ye, and A. W. Appel, “Veriﬁed correctness
and security of openssl HMAC,” in USENIX Security Symposium, 2015,
pp. 207–221.
[45] J. B. Almeida, M. Barbosa, G. Barthe, A. Blot, B. Gr´egoire, V. Laporte,
T. Oliveira, H. Pacheco, B. Schmidt, and P. Strub, “Jasmin: High-
assurance and high-speed cryptography,” in ACM SIGSAC Conference on
Computer and Communications Security (CCS), 2017, pp. 1807–1823.
[46] A. W. Appel, “Veriﬁcation of a cryptographic primitive: Sha-256,”
ACM Transactions on Programming Languages and Systems (TOPLAS),
vol. 37, no. 2, p. 7, 2015.
[47] B. Bond, C. Hawblitzel, M. Kapritsos, K. R. M. Leino, J. R. Lorch,
B. Parno, A. Rane, S. Setty, and L. Thompson, “Vale: Verifying
high-performance cryptographic assembly code,” in Proceedings of the
USENIX Security Symposium, Aug. 2017.
[48] A. Tomb, “Automated veriﬁcation of real-world cryptographic imple-
mentations,” IEEE Security and Privacy, vol. 14, no. 6, pp. 26–33, 2016.
1270
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:34 UTC from IEEE Xplore.  Restrictions apply. 
APPENDIX
A. THE SIGNAL CRYPTOGRAPHIC PROTOCOL
Initiator I
Prior Knowledge:
(i, gi)
Responder R
Prior Knowledge:
(r, gr), (s, gs)[, (o, go)]
Initiate(i, gr, gs[, go]) → (rk0):
generate (e, ge)
dh0 = 0xFF ∣ gsi ∣ gre ∣ gse[∣ goe]
rk0 = HKDF(dh0, 0x00
32, “WhisperText
′′)
SendRatchet(rk0, gs) → (rk1, cki
0, x0):
generate (x0, gx0 )
rk1 ∣ cki
0 = HKDF(gsx0 , rk0, “WhisperRatchet
′′)
(ek0, iv0, mk0) = HKDF(k0, 0x00
cki
1 = HMAC(cki
k0 = HMAC(cki
0, 0x01)
0, 0x00)
32, “WhisperMessageKeys
′′)
Encrypt(gi, gr, gx0 , cki
0, m0) → (cki
1, c0, t0):
c0 = FORMAT(gx0 , 0, 0, AES-CBC(ek0, iv0, m0))
t0 = HMAC(mk0, gr ∣ gi ∣ 0x33 ∣ c0)
MSG0(gi, ge, c0, t0)
Respond(r, s, o, gi, ge) → (rk0):
recompute dh0, rk0 (similarly to I)
ReceiveRatchet(rk0, s, gx0 ) → (rk1, cki
0):
recompute rk1, cki
0 (similarly to I)
Decrypt(cki
recompute cki
0, c0, t0) → (m0, cki
1):
1, k0 (similarly to I)
verify MAC and decrypt (c0, t0) to get m0
SendRatchet(rk1, gx0 ) → (rk2, ckr
0, y0)
Encrypt(gr, gi, gy0 , ckr
0, m1) → (ckr
1, c1, t1)
MSG(c1, t1)
ReceiveRatchet(rk1, x0, gy0 ) → (rk2, ckr
0)
Decrypt(ckr
0, c1, t1) → (m1, ckr
1)
{root key ∶ rk2, send chain ∶ (cki
1, x0), recv chain ∶ (ckr
1, gy0 )}
Session State:
{root key ∶ rk2, send chain ∶ (ckr
1, y0), recv chain ∶ (cki
1, gx0 )}
Session State:
⋯
Fig. 15. Signal Protocol (ﬁrst two messages). These messages set up a bidirectional mutually authenticated channel between I and R, using a series of
Difﬁe-Hellman operations. Each message carries a payload. This protocol is sometimes called X3DH. The ﬁgure does not show the (out-of-band) prekey
message in which R delivers (gs, go) to I (via the server) and I veriﬁes R’s ED25519 signature on gs.
1271
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:34 UTC from IEEE Xplore.  Restrictions apply. 
Initiator I
Responder R
{root key ∶ rk2, send chain ∶ (cki
1, x0), recv chain ∶ (ckr
1, gy0 )}
Session State:
{root key ∶ rk2, send chain ∶ (ckr
1, y0), recv chain ∶ (cki
1, gx0 )}
Session State:
SendRatchet(rk2, gy0 ) → (rk3, cki
2, x1)
Encrypt(gi, gr, gx1 , cki
2, m2) → (cki
3, c2, t2)
Encrypt(gi, gr, gx1 , cki
3, m3) → (cki
4, c3, t3)
Encrypt(gi, gr, gx1 , cki
4, m4) → (cki
5, c4, t4)
MSG(c2, t2)
MSG(c3, t3)
MSG(c4, t4)
ReceiveRatchet(rk2, y0, gx1 ) → (rk3, cki