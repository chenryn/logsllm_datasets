by Szekeres et al. [56].
Requirement
Attack
Information disclosure
Control-ﬂow attacks
Data-only attacks
Arbitrary
Read

()
()
Arbitrary
Write



Arbitrary
EEXIT

()

line of research, as we discuss later. Also, this work does not
focus on microarchitectural side channels, although SGXJail
prevents certain classes of side-channel attacks. Finally, the
CPU hardware is considered trusted.
4 Analyzing the Enclave Malware Threat
In this section, we analyze enclave primitives leading to differ-
ent attack vectors violating memory safety of the application.
This helps us design a proper defense mechanism and solve
the enclave malware threat at the level of memory safety, leav-
ing only high-level API attacks as a resort for the attacker, as
discussed at the end of this section.
4.1 Enclave Primitives
Intel SGX entrusts enclaves with powerful primitives leading
to different attacks violating memory safety, as depicted in
Table 1. We outline these primitives in the following.
Arbitrary read. An enclave can read arbitrary memory of
the host application. This is intended for exchanging data
between enclave and host. Furthermore, an enclave can use
hardware transactions to suppress exceptions stemming from
reading inaccessible memory [53], giving a powerful fault-
resistant arbitrary read primitive.
Arbitrary write. An enclave can write arbitrary writable
host memory, which is intended for data exchange. Further-
more, it can use hardware transactions to suppress excep-
tions while writing inaccessible or non-writable memory [53],
yielding a fault-resistant arbitrary write primitive.
Arbitrary EEXIT. An enclave can choose the precise code
location in the application where execution shall continue
after leaving enclave execution via the EEXIT instruction.
Moreover, the enclave has control over many CPU registers
immediately after an EEXIT, in particular the stack pointer,
which gives enclaves the possibility to conﬁgure the applica-
tion’s CPU state before resuming application execution.
4.2 Attack Vectors
Given the above primitives, a malicious enclave can mount
a broad range of attacks violating memory safety of the host
application. In the following, we cluster them into information
disclosure, control-ﬂow attacks as well as data-only attacks
and give representative examples of these attacks. A detailed
4.2.1
Information disclosure
A malicious enclave can use the arbitrary read primitive to
exﬁltrate sensitive user data like cryptographic keys or pass-
words from the host application. Even if the application con-
tains no such user secrets, an enclave can disclose other sensi-
tive information, e.g., as used in various runtime protection
mechanisms. For example, an enclave can derandomize appli-
cation protection schemes like ASLR [45], stack canaries [14],
code randomization [44] or randomization-based control-ﬂow
integrity schemes [31, 39]. The enclave can furthermore dis-
close the host application’s codebase and, subsequently, gen-
erate targeted exploitation payload like ROP chains on the ﬂy.
Thus, information disclosure is a powerful tool often used for
subsequent exploitation.
4.2.2 Control-ﬂow attacks
A malicious enclave can deliberately tamper with the appli-
cation’s control ﬂow in several ways. For example, it can
directly corrupt code pointers, use rogue EEXITs and bypass
various mitigation mechanisms.
Code pointer corruption. An enclave can manipulate an
arbitrary code pointer of the host using the write primitive.
This can be, e.g., return addresses on the stack or virtual
function pointers on the heap. As soon as the application
fetches a corrupted code pointer, execution is diverted to an
attacker-chosen address. By carefully crafting a so-called
ROP chain (cf. Section 2) and diverting execution to it, the
attacker can gain arbitrary code execution with the privileges
of the application, allowing to execute arbitrary syscalls in
lieu of the application. To prepare a ROP chain, the enclave
scans the host application for ROP gadgets using the arbitrary
read primitive and writes the corresponding addresses on a
fake stack using the arbitrary write primitive [53].
An enclave is by no means restricted to ROP attacks only.
Similar to ROP, it can craft jump-oriented programming (JOP)
attacks, loop-oriented programming (LOP) attacks, or call-
oriented programming (COP) by overwriting indirect function
pointers [5, 9, 10, 18, 32]. COOP attacks are also possible by
overwriting virtual function pointers in C++ applications [51]
or SROP attacks [6], faking a signal handler.
Rogue EEXIT. A malicious enclave can also mount control-
ﬂow attacks without corrupting a single code pointer. By using
the arbitrary EEXIT primitive, the enclave can directly cor-
rupt the CPU state. For example, it can manipulate the stack-
pointer register to point to an attacker-crafted ROP chain. By
doing an EEXIT instruction towards an arbitrary ret instruc-
tion of the host, the enclave can immediately trigger the ROP
chain, leading to the same implications as for ROP.
356          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX AssociationBypassing Defenses. Several defense mechanisms seek to
protect the application’s control ﬂow. Stack canaries [14]
protect against linear buffer overﬂows overwriting return ad-
dresses on the stack. ASLR [45] hides code addresses via
randomization, while others randomize code itself [44], both
making the generation of ROP gadgets hard. More elaborate
mechanisms enforce control-ﬂow integrity (CFI), arguably
at different granularity. CPI [31] hides code pointers in a
shadow stack2 while CCFI [39] encrypts code pointers. As
these mechanisms rely on randomization, they can be eas-
ily broken by the enclave via information disclosure. If CFI
metadata is involved, it can be easily corrupted using the
write primitive. Stronger hardware-enforced CFI schemes
like CET [27] are still unavailable on modern x86 CPUs, and
it is unclear to what extent they consider rogue EEXIT attacks.
4.2.3 Data-only attacks
Apart from control-ﬂow attacks, enclaves can corrupt appli-
cation data other than code pointers or CFI metadata. For
example, they can corrupt loop counters, function arguments
or syscall arguments [8, 28] using the arbitrary read/write
primitives. Typically, data-only attacks are much more re-
stricted than control-ﬂow attacks. For example, they can only
reuse code reachable in the normal control ﬂow. Yet, data-
only attacks are agnostic to CFI protection schemes and can
even achieve Turing-complete computation in many cases by
chaining together valid execution paths [28].
4.3 API attacks
The previous attack vectors all violate memory safety of
the application by reading, writing and executing applica-
tion memory in an illegitimate way. It is clear that defeating
these attacks is paramount to protecting an application from
misbehaving enclaves. Only with such protections in place, it
makes sense to reason about the application’s security on the
API level. Obviously, SGXJail does not defend against too per-
missive OCALLs, e.g., giving an enclave the ability to access
arbitrary ﬁles. Yet, we need to ask to what extent an enclave
can attack its host application purely via the ECALL/OCALL
interface, that is, without relying on the above SGX attack
primitives. For example, an enclave can seek to attack the ap-
plication by crafting invalid API calls or returning malformed
data. For a successful attack, either the API itself needs to be
ﬂawed, or the underlying implementation misses important
validation steps (e.g., confused deputy attacks [22] and Iago
attacks [11]). Since such API-based attacks are highly appli-
cation speciﬁc, they cannot be addressed by a generic defense
mechanism anticipated in this work. We discuss proper miti-
gation strategies in Section 7. Also, we do not address misuse
of computational power (e.g., for cryptocurrency mining).
2This corresponds to the weaker randomization scheme since the stronger
segment-based isolation is unavailable for 64-bit execution mode.
5 SGXJail
In this section, we present SGXJail, a novel mechanism to
protect host applications from untrusted (third-party) enclaves.
SGXJail defeats entire classes of attacks by prohibiting en-
clave primitives outlined in Section 4 at the discretion of the
host application. SGXJail can be implemented purely in user
space and relies on process isolation and syscall ﬁlters, similar
to other sandboxing techniques like Docker [40]. We eval-
uate SGXJail under different workloads to demonstrate its
efﬁciency. Finally, we show how SGXJail can also be imple-
mented via minimal changes to the SGX speciﬁcations and
corresponding hardware, which we call HSGXJail.
5.1 SGXJail via Software Conﬁnement
SGXJail defeats enclave malware by breaking all three en-
clave primitives described in Section 4.1. SGXJail does so by
conﬁning enclave operation to a strict set of memory pages.
Figure 2 illustrates the basic idea of SGXJail. To break
the arbitrary read and write primitives, we rely on the oper-
ating system’s ability to isolate processes.3 Namely, we run
potentially malicious or misbehaving enclaves in a separate
sandbox process which does not have access to the host ap-
plication’s memory. To still allow benign ECALL/OCALL
interaction, we establish shared memory between the sand-
box process and the host application to implement a form of
inter-process communication.
Even with the above process isolation in place, a mali-
cious enclave can perform an attack on the control ﬂow of the
sandbox process to issue arbitrary syscalls on behalf of the
sandbox process. Such an attack can either be a rogue EEXIT
attack, or a code-reuse attack (e.g., ROP) through manipu-
lating the stack [53]. Breaking the primitives that allow an
attacker to change the control ﬂow is not trivial. EEXIT can
jump to any executable page, and the target address cannot be
restricted. Similarly, if the enclave rewrites the saved return
address on the stack, the sandbox process cannot detect this
modiﬁcation. A possible–but rather expensive solution–is to
mark all executable pages of the sandbox process (except
for trampoline code) as non-executable before entering the
enclave. When leaving the enclave, the sandbox immediately
traps to the kernel, which can then assess the legitimacy of
the address at which the sandbox process should resume and
remap the pages as executable. However, this requires fre-
quent and expensive page remapping by updating a majority
of the page tables of a process. Instead of trying to prevent an
attack from hijacking the control ﬂow in the sandbox process,
we conﬁne the damage of such a hijacked control ﬂow. In par-
ticular, we restrict the syscall interface of the sandbox process
by using seccomp syscall ﬁlters [36] to whitelist only abso-
3Conforming with Intel’s and our extended SGX threat model, software-
based side-channel attacks circumventing such isolation, e.g., Meltdown [37]
or Rowhammer [29], are out of scope.
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 357Host application
Application
logic
ECALL
OCALL
Dispatcher
Shared Memory
OCALL
ECALL
Sandbox process
Third-party
Enclave
ECALL
OCALL
Dispatcher
p
m
o
c
c
e
s
Figure 2: With SGXJail, the enclave is isolated within a
separate sandbox process and can communicate with the
host application only via shared memory. Also, the en-
clave is conﬁned using seccomp ﬁlters.
lutely necessary syscalls. Even if a malicious enclave gains
arbitrary code execution inside the sandbox process, it can no
longer perform malicious actions. In contrast to sandboxing
techniques like Docker isolating the entire system (e.g., via
cgroups), we only need to restrict a single user process for
which syscall ﬁlters are the appropriate choice.
Life Cycle. A complete SGXJail life cycle works as follows.
First, SGXJail creates a new process, the sandbox process.
The third-party enclave is then loaded within this sandbox pro-
cess. Moreover, SGXJail creates a shared memory between
host application and sandbox process and installs dispatchers
for routing all ECALLs and OCALLs through this shared
memory. Afterwards, SGXJail activates seccomp ﬁlters to
restrict the syscalls of the sandbox process to an absolute
minimum. Only syscalls required for the communication be-
tween application and sandbox process, as well as syscalls
required to terminate the sandbox process, are whitelisted.
After the initialization, the application can issue ECALLs and
receive OCALLs, as follows. The application dispatcher auto-
matically encapsulates ECALLs into messages and transfers
them via the shared memory to the sandbox process. ECALL
function arguments are copied from the host application to
the shared memory. The sandbox process dispatcher listens
for incoming messages, decapsulates arriving messages and
performs the actual ECALL towards the enclave. Results
are returned back to the application, again via message pass-
ing over shared memory. The application dispatcher ﬁnally
copies ECALL results from the shared memory to application
memory and hands over to the application. In the same way,
OCALLs are routed from the sandbox process through the
shared memory to the application host and vice versa. Upon
termination of the application, the sandbox process is simply
destroyed. Multiple enclaves are isolated via separate sandbox
processes with individual shared memory segments.
Compatibility. SGXJail is a transparent enclave conﬁnement
mechanism. It does not require any changes to third-party en-
claves themselves, i.e., it is binary-compatible with existing
enclaves and their existing cryptographic signatures. Also, no
enclave source code needs to be available. Instead, SGXJail
is tightly integrated within the SGX SDK [25]. All glue code
for dispatching and redirecting ECALLs and OCALLs via
shared memory is automatically generated from an enclave’s
EDL ﬁle [25] which needs to be shipped together alongside
each pre-compiled third-party enclave. Also, code for instanti-
ating the sandbox process, the shared memory and activating
seccomp ﬁlters is provided by SGXJail. For SGXJail, only
the untrusted application code has to be recompiled under the
SGXJail toolchain.
The installation of seccomp ﬁlters is independent of the
enclave itself. Since enclaves are not entitled to issue syscalls,
the selection of proper syscall ﬁlters solely depends on SGX-
Jail and does not affect compatibility with enclaves.
SGXJail enforces benign enclave communication to follow
the ECALL/OCALL interface speciﬁed in the enclave’s EDL
ﬁle. An enclave implementing other communication methods
(e.g., by directly accessing host memory) breaks as soon as
SGXJail is active. This is intentional, as enclave developers
are strongly encouraged to clearly deﬁne the enclave’s API
via ECALLs and OCALLs. In particular, SGXJail breaks un-
safe usage of ECALLs and OCALLs where enclave and host
application exchange and dereference raw, unchecked point-
ers rather than buffered data. For example, if one marks an
ECALL function parameter with the so-called user_check at-
tribute within the EDL ﬁle [25], the SDK passes this function
parameter without further checking and copying into the en-
clave. A quick code inspection revealed usage of user_check
in some Intel architectural enclaves and remote attestation
code, all for performance reasons. They could be updated to
avoid user_check at the cost of slight performance loss. To
yet support user_check, one would need to manually share
(i.e., map) host memory with the sandbox process to which an
enclave shall have unrestricted access. Also, host application
pointers passed to the enclave need to be translated to the
sandbox process due to ASLR. SGXJail could provide sim-
ple helper functions for sharing host memory and translating
pointers.