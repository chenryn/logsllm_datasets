Windows OS. These bots invoke Windows functions through
the API provided to applications, and available in the form
of dynamically-linked libraries (DLLs). Both sequence and
timing for API calls are used for analysis purposes. When
each API call is intercepted, the time (in the execution
history of the program) that the call is intercepted is also
recorded.
Full interception of all API calls might have a perfor-
mance impact that interfered with bot execution. A com-
promise is to intercept only a subset of system calls that
are important for bot command analysis purposes. K. Jain
and R. Sekar [13] developed a system call interposition
infrastructure at the user level (for Linux), and suggested
monitoring only a subset of system calls for intrusion
detection, and showed the performance beneﬁts. Similarly,
we propose to hook only a limited set of Windows API
calls. These calls are referred to as the ComAPI (“Com-
mon API” in Figure 1). The set of calls in ComAPI was
derived by static analysis of actual bot binaries, using the
method of [11]. This analysis identiﬁed approximately 300
commonly-used API functions from 50 real bot instances.
Among them, 153 APIs were in ﬁle kernel32.dll;
the rest were found in user32.dll, advapi32.dll,
ws2_32.dll (Wsock32.dll), etc. ComAPI consists
of the complete set of user-level system calls executed
instances. Note that a user-level API
by these 50 bot
call may result
in the execution of zero, one, or more
than one native API or core system service calls. As an
example, the DeleteFile call in kernel32.dll in-
vokes multiple system service calls, such as NtOpenFile,
NtSetInfoFile, and NtCloseFile.
323
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:10:26 UTC from IEEE Xplore.  Restrictions apply. 
statistical correlation. The motivation for this approach is
based on the following two insights, obtained from inves-
tigation of real bot instances. First, in spite of superﬁcial
differences, if two bot commands have the same purpose, the
API calls issued to perform them will be very similar, and
their execution timing will be correlated. Second, the API
function calls that are executed by the same bot command,
regardless of the bot family, are typically executed with
little variation. This may be due to reuse of code, imitation
of functionality, popularity of widely used compilers and
libraries, and/or the desire to code in an efﬁcient way.
Let X and Y be different bots which execute two bot
commands that have the same purpose. During execution of
each command, many API calls found in ComAPI will be
intercepted from the two bots. Suppose the command iden-
tiﬁer produces two W semantic units from many execution
traces (for a speciﬁed value of γ) for X and Y . In these
W semantic units, let the ith execution trace (semantic unit)
for X be denoted Si(X), and the jth execution trace for Y
be denoted Sj(Y ). For each value of i and j, Si(X) and
Sj(Y ) are execution traces for bot commands executed by
different programs that potentially are the same command.
For each such pair, a standard algorithm [14] is used to
ﬁnd the longest common subsequence (LCS) of the two call
traces. This LCS for traces Si(X) and Sj(Y ) is termed the
common API call trace (CACT) for the pair, and is denoted
Li,j, with length ki,j.
As mentioned, for each call in ComAPI that is intercepted,
the time at which the function was executed is recorded.
Let the timing vector for the CACT Li,j for X be denoted
Ti,j(X), with length ki,j − 1. The tth element in this vector
represents the time interval between the execution of the
tth and the (t + 1)th system calls, occurring in that portion
of Si(X) corresponding to Li,j. Similarly, the timing vector
Ti,j(Y ) corresponds to the intervals between successive API
calls in that portion of Sj(Y ) corresponding to Li,j.
Let the mean and standard deviation for the elements in
Ti,j(X) be denoted μi,j(X) and σi,j(X), and similarly for
Ti,j(Y ). The correlation coefﬁcient ρi,j of these two timing
vectors may be computed in the standard way as
ki,j(cid:2)
(Ti,j (X)[t] − μi,j (X))(Ti,j (Y )[t] − μi,j (Y ))
σi,j (X)σi,j (Y )
ρi,j =
1
ki,j − 1
t=1
(1)
The correlation coefﬁcient has a maximum of 1, which
occurs when the vectors are completely correlated.
Let H1 be the hypothesis that the two commands from
bots X and Y that are being compared are semantically the
same command (i.e., have the same function or purpose).
Deﬁne θ1 as P (ρi,j > δ) | H1), i.e., θ1 is the probability
that the two commands will have a sufﬁciently high corre-
lation coefﬁcient when H1 is true. To decide that the two
commands are the same, we require that θ1 must be greater
than 0.95, with a conﬁdence level of .05, for an appropriately
chosen value of δ.
When two bots that use similar techniques execute the
same bot command, the correlation value of their timing
vectors will be very high (close to 1). Even though attackers
may randomly inject delays for timing obfuscation, it is
unlikely they will be willing to tolerate too high a delay
in the completion of their objective. The injection of extra-
neous system calls to obfuscate command execution is also
possible, and is further investigated in section III-F.
The above scheme applies to pairs of bots, and can be
extended to the analysis of any number of bots. Because the
number of sequences in all of the execution traces for many
bots is constant, the LCS problem is solvable in polynomial
time by dynamic programming [14]. In such a case, if bot
commands that have the same function are executed by
many different bots, the CACT will be the longest common
subsequence that occurs in all of the execution traces for
that command, from all of the bots. The use of the common
subsequence makes our scheme robust even if the execution
traces are obfuscated. The timings for the CACT for all bot
traces from which the template is created are also saved as
part of the template.
Construction of templates is an off-line process that
is conducted on previously-detected bots. These bots are
controlled and monitored in a restricted environment, which
means that commands are issued to them, during which their
system call traces are captured. Therefore, the commands
that are issued to the bots are known. It is further assumed
that manual inspection has revealed which bot commands
have the same purpose. The system call execution traces for
such commands should therefore be considered for pairing
in the construction of a template.
Lastly, the template database, as shown in Figure 1, stores
the semantic templates derived by the correlation engine. For
each bot command that is found to occur in more than one
bot, there is one template. The templates are speciﬁcations
including the CACT for that command and the timing vector
for every execution trace for every bot that was analyzed
that executes that command. The set of templates are used
to identify individual bot behaviors in real time, as described
in the next section.
E. A Real-time Semantic Behavior Matcher
The previous section has described how bot system call
execution is hooked, and how the results are used to create
a set of templates. Each template corresponds to a unique
bot command. A bot that is currently executing may also be
hooked. Its call execution traces can then be compared with
this set of templates. The result will be the identiﬁcation of
bot commands being executed by the bot.
When a bot executes a bot command in real time, the
behavior matcher attempts to match the command with an
entry in the template database, as illustrated in Figure 1. The
324
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:10:26 UTC from IEEE Xplore.  Restrictions apply. 
method of searching for a matching template uses the same
techniques employed for constructing templates.
Suppose the API calls in ComAPI are intercepted during
the execution of a suspected bot program. The trace of
these calls, denoted S, is then processed to identify the
start and stop of execution of possible bot commands, as
described above. The result is a set of semantic units for
this program. For each semantic unit, duplicate consecutive
system calls are removed, under the control of the user-
speciﬁed repetition parameter γ.
The resulting reduced trace for one semantic unit U is
then compared to all of the templates of bot commands.
The comparison between U and a template starts by com-
puting the CACT between the two, using a longest common
subsequence algorithm.
To identify a bot command in the execution trace S of a
bot, using a set of previously-derived templates, a candidate
template must be identiﬁed. We propose for this purpose to
select as a candidate template that one which has the longest
common API call trace (CACT) with U , from among all
templates. In the event of ties, the candidate template is
then the template that has the smallest difference with the
CACT. The difference between a template and the CACT
with U is calculated as the difference between the length of
this CACT with U , and the length of the template.
When a candidate template has been identiﬁed, the timing
vectors of the CACT for U and this template are then created
and correlated, as described by Equation 1. The result is a
correlation coefﬁcient ρ, calculated as follows. The corre-
lation of U ’s timing vector with each timing vector in the
template is computed according to Equation refcorrelation.
ρ is chosen to be the maximum of these individual corre-
lations. If the highest ρ exceeds a user-speciﬁed threshold
δ with high probability (i.e. θ1 ≥ 95%), the semantic
unit U is declared to be an execution of the bot command
represented by the template.
An exception to the above matching process occurs if U
consists solely of routine API calls. A bot installed on a host
and prepared for interaction typically makes continuous API
calls while waiting for commands from the master. These
routine calls are easily identiﬁed during the ﬁrst few seconds
of bot execution. For instance, for SDbot, the routine API
calls were found to be InterlockedDecrement,
InterlockedIncrement,
and
GetLocalTime.
in a captured
semantic unit are exclusively taken from this set of routine
API calls, that semantic unit is regarded as being of lower
importance. It
is classiﬁed simply as belonging to the
general command group (see Table I), and no further
attempt is made to identify its function more precisely.
Examples commands include ‘alias’, ‘nick’, etc.
the system calls
TlsGetValue,
If
Information logging: If desired, for selected bot com-
mands that are identiﬁed (denial of service, spam, etc.),
additional information can be recorded about the arguments
325
of API calls that are hooked. This information may be useful
for the detection of the victims targeted by an attacker, with-
out requiring monitoring of network trafﬁc. For example,
if a bot is identiﬁed as executing a SYN ﬂood attack, the
arguments of the intercepted system calls will identify the
victim, or the C&C server IP address and port number can
be recovered when the bot connects to the master. Previous
research [15], [16] suggested recording such information.
However, BotTee logs and reports the valuable information
only when malicious behavior (bot command) of particular
interest is identiﬁed, rather than for all system calls executed.
Figure 2. A botnet for experiments
III. EXPERIMENTAL EVALUATION
The proposed method was evaluated experimentally. The
conditions of the experiment, and the results (measurements
of overhead, ability to identify bot commands, and robust-
ness to call obfuscation) are presented in this section. The
results demonstrate that BotTee can recognize the execution
of speciﬁc bot commands in real time.
A. Implementation and Experiments
We implemented a prototype of BotTee; the prototype
used the Deviare API [12] for intercepting Windows API
calls on the ﬂy. Deviare provides hook libraries to intercept
any Windows API calls during runtime. BotTee uses this to
obtain API call traces, and to record the arguments of those
system calls. For accurate timing analysis, BotTee uses a
timer function with a 1 microsecond accuracy, employing
performance counter information [17].
A botnet in a private network was deployed, as shown in
Figure 2. All machines ran the Windows OS, which is the
main target of botnets. As shown in Figure 2, the ﬁrst host
was used as a C & C server, for instance by installing an IRC
server like UnrealIRCd.3 The second host was conﬁgured
as a vulnerable host or honeypot, which could be exploited
for bot recruitment purposes. The third host served as an
alternative host, or as a target for an attack. A bot on the
3The botnet is based on the IRC protocol. However, our scheme is
independent of any particular communication protocol. Our focus is to
identify individual bot behavior through execution traces. The conﬁguration
for the experiment is just one typical botnet.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:10:26 UTC from IEEE Xplore.  Restrictions apply. 
second machine immediately connects to the C & C server
and joins a predeﬁned channel. When the botmaster issues
a command through the C & C server, the bot executes the
bot command. BotTee monitors the system call behavior of
the bot as it executes bot commands.
Bots from the bot families Agobot, Sdbot, Spybot, Jr-
bot, Akbot, Dbot, Rbot, and Hellbot were evaluated to
validate BotTee. We used current bot source codes from
http://securitydot.net. Each of the bot instances came from
a different bot family when possible, and we selected one
bot from each different bot family. Among 167 available bot
source codes, there were 103 variants, including the bots we
evaluated. Among them, Agobot, Spybot, Sdbot, and Jrbot
are the most popular bot families, as explained in [3].
)
c
e
s
m
(
d
e
s
p
a
e
e
m
T
l
i
 100000