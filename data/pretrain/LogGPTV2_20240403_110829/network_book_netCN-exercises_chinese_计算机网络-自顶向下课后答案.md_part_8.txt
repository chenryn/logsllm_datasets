P22、
a)这里我们的窗口大小为n=3。假设接收机接收到分组k-1,并且已经将该分组和所有其它之前的分组进行了分组。如果所有这些ACK都已被由发送方接收，则发送方的窗口为[k,kn-1]。假设下一个没有在发送方接收到ACK。在第二种情况下,发送方S窗口包含k-1和n个分组，并包括k-1。因此,发送者的窗口是这样的,[K-N,K-1]。通过这些参数，“发件人”窗口的大小为3，并开始在范围[K-N,K]的某处。
b)如果接收机正在等待分组k，则它已经接收(和被处理)分组k-1和N-1个分组。如果尚未收到这些N个ACK中的任何一个，发送方，然后可以传播具有[k-n,k-1]值的ACK消息由于发送方发送了数据包[k-n,k-1],所以必须是这样的情况:发送方已经接收到用于k-n-1的ACK。一旦接收机发送了ACK,对于k-n-1，它将永远不会发送小于k-n-1的ACK。因此，飞行中的ACK值的范围可以从k-n-1到k-1。
P23、为了避免图3.27中的场景，我们希望避免接收方窗口的前缘(即具有“最高”序列号的窗口)在序列号空间中环绕，并与后面的边缘(发送方窗口中具有“最低”序列号的窗口)重叠。也就是说，序列号空间必须足够大，以适应整个接收方窗口和整个发送方窗口，而不存在这种重叠条件。因此-我们需要确定接收方和发送方窗口在任何给定时间都可以覆盖多大的序列号。
假设接收者等待的最低序列号是包m，在这种情况下，它的窗口是[m，mw-1]，它已经接收到(并加进)包m-1和之前的w-1包，其中w是窗口的大小。如果发送方尚未接收到这些wACK中的任何一个，则值为[m-w，m-1]的ACK消息可能仍在传播。如果发送方没有收到带有这些ACK号的ACK，那么发送方的窗口将是[mw，m-1]。
因此，发送方窗口的下边缘为m-w，接收者窗口的前缘为mw-1。为了使接收方窗口的前缘不与发送方窗口的后缘重叠，序列号空间必须因此，足够大以容纳2w序列号。也就是说，序列号空间必须至少是窗口大小k2w的两倍。
P24、
a)真。假设发送方具有3的窗口大小并且在T0发送分组1、2、3。在T1(T1/T0)接收机ACK1、2、3。在t2(t2，t1)发送方超时，并且重新连接1、2、3。在t3,接收机接收重复并重新确认1、2,3、在T4，发送方接收到在T1发送的接收机并使其前进的ACK。窗口至4、5、6。在t5，发送方接收在T2发送的接收机的ACK1、2、3。这些棚屋在窗户外面。
b)真。实质上与(a)中相同的情形。
c)真。
d)真。请注意，具有1、SR、GBN和交替位协议的窗口大小功能等同。窗口大小1排除了无序分组的可能性(在窗口内)。累积ACK仅仅是普通ACK,这种情况，因为它只能指窗口内的单个分组。
P25、
a)考虑在传输协议上发送应用消息。使用TCP，应用程序将数据写入连接发送缓冲区，TCP将抓取字节必须在TCP段中放置一个消息；TCP可能会或多或少地发送消息而不是在段中的单个消息。另一方面，UDP封装在无论应用程序给出什么，都会分段；因此，如果应用程序提供UDP应用消息，此消息将是UDP段的有效负载。因此,对于UDP，应用程序对数据段中的数据进行了更多控制。
b)由于流量控制和拥塞控制，TCP由于流量控制和拥塞控制，可能会有显著的延迟从应用程序向其发送缓冲器写入数据直到数据被指定给网络层。UDP由于流控制而没有延迟,拥塞控制。
P26、共有$2^{32}= 4294967296$个可能的序列。
a)序列号不随每个段增加一个。相反，它会增加发送的数据字节数。因此，MSS的大小是无关的--从A到B发送的最大大小文件就是可以表示为$2^{32}≈4.19$GBytes的字节数。
(B)分段数为$\left [ \frac{2^{32}}{536} \right ]=8012999$.66字节的标头添加到每个段中，总共生成528857934字节的标头。传输的字节总数为$2^{32}+528857934=4.824\times10^9$字节。因此，在155~Mbps链路上传输文件需要249秒。
P27、
a)在从主机A到B的第二段中，序列号为207，源端口号为302，目的端口号为80。
b)如果所述第一段在所述第二到达段之前到达，则在所述第一到达段的确认中，所述确认号为207，所述源端口号为80，所述目的端口号为302。
c)如果第二段到达第一段之前，在第一个到达段的确认中，确认号为127，表示它仍在等待字节127和以后。d）
d)
![avater](./img/27.png)
P28、由于链路容量只有100 Mbps，所以主机A的发送速率最多可达100 Mbps。不过，主机A向接收缓冲区发送数据的速度比主机B从缓冲区中删除数据的速度要快。接收缓冲区的填充速率约为40 Mbps。当缓冲区已满时，主机B通过设置RcvWindow=0向主机A发送停止发送数据的信号。然后主机A停止发送，直到接收到RcvWindow>0的TCP段为止。主机A将作为RcvWindow值的函数反复停止并开始发送从主机B接收。平均而言，主机A向主机发送数据的长期速率b作为此连接的一部分，不超过60Mbps。
P29、
a)服务器使用特定的初始序列号(从源和目的地IP和端口的散列中获取)来抵御SYN洪水攻击。
b)不，攻击者不能通过向目标发送和ACK数据包来创建半开放或完全打开的连接。半开连接是不可能的，因为在建立完整连接之前，使用SYNcookie的服务器不会维护任何连接的连接变量和缓冲区。为了建立完全开放的连接，攻击者应该从攻击者那里知道与(伪造的)源IP地址对应的特定初始序列号。这个序列号需要每个服务器使用的“秘密”编号。由于攻击者不知道这个秘密号码，她无法猜测初始序列号。
c)不，服务器可以简单地在计算这些初始序列号时加上时间戳，并为这些序列号选择一个存活值，即使攻击者重播，也可以丢弃过期的初始序列号。
P30、
a)如果超时值是固定的，则发送方可能会过早超时。因此，一些包即使没有丢失也被重新传输.
b)如果估计超时值(就像TCP所做的那样)，那么增加缓冲区大小肯定有助于提高该路由器的吞吐量。但可能有一个潜在的问题。排队延迟可能非常大，类似于场景1中所示。
P31、
DevRTT = (1- beta) * DevRTT + beta * | SampleRTT - EstimatedRTT | 
EstimatedRTT = (1-alpha) * EstimatedRTT + alpha * SampleRTT 
TimeoutInterval = EstimatedRTT + 4 * DevRTT 
After obtaining first SampleRTT 106ms: 
DevRTT = 0.75*5 + 0.25 * | 106 - 100 | = 5.25ms 
EstimatedRTT = 0.875 * 100 + 0.125 * 106 = 100.75 ms 
TimeoutInterval = 100.75+4*5.25 = 121.75 ms 
After obtaining 120ms: 
DevRTT = 0.75*5.25 + 0.25 * | 120 – 100.75 | = 8.75 ms 
EstimatedRTT = 0.875 * 100.75 + 0.125 * 120 = 103.16 ms 
TimeoutInterval = 103.16+4*8.75 = 138.16 ms 
After obtaining 140ms: 
DevRTT = 0.75*8.75 + 0.25 * | 140 – 103.16 | = 15.77 ms 
EstimatedRTT = 0.875 * 103.16 + 0.125 * 140 = 107.76 ms 
TimeoutInterval = 107.76+4*15.77 = 170.84 ms 
After obtaining 90ms: 
DevRTT = 0.75*15.77 + 0.25 * | 90 – 107.76 | = 16.27 ms 
EstimatedRTT = 0.875 * 107.76 + 0.125 * 90 = 105.54 ms 
TimeoutInterval = 105.54+4*16.27 =170.62 ms 
After obtaining 115ms: 
DevRTT = 0.75*16.27 + 0.25 * | 115 – 105.54 | = 14.57 ms 
EstimatedRTT = 0.875 * 105.54 + 0.125 * 115 = 106.72 ms 
TimeoutInterval = 106.72+4*14.57 =165 ms 
P32、
a)$EstimatedRTT^{(n)}$表示第n个样本后估计的RTT值。
$EstimatedRTT^{(4)}=xSampleRTT_1+(1-x)[xSampleRTT_2+(1-x)[xSampleRTT_3+(1-x)SampleRTT_4]]=xSampleRTT_1+(1-x)xSampleRTT_2+(1-x)^2xSampleRTT_3+(1-x)^3xSampleRTT_4$
b)$EstimatedRTT^{(n)}=x\sum_{j=1}^{n-1}(1-x)^{j-1}SampleRTT_j+(1-x)^{n-1}SampleRTT_n$
c)$EstimatedRTT^{(\infty)}=\frac{x}{1-x}\sum_{j=1}^{n-1}(1-x)^{j}SampleRTT_j=\frac{1}{9}\sum_{j=1}^{\infty}\cdot9^jSampleRTT_j$
赋予过去样本的权重呈指数衰减。
P33、让我们来看看如果TCP为重新传输的段度量SampleRTT会发生什么错误。假设源发送数据包P1，P1的计时器过期，然后源发送P2，即同一数据包的新副本。此外，假设源度量P2(重发数据包)的SampleRTT。最后，假设在发送P2后不久，对P1的确认到达。源将错误地将此确认视为P2的确认，并计算不正确的SampleRTT值。
让我们看看如果TCP为重新传输的段度量SampleRTT，可能会发生什么错误。假设源发送数据包P1，P1的计时器过期，然后源发送P2，即同一数据包的新副本。此外，假设源度量P2(重发数据包)的SampleRTT。最后，假设在发送P2后不久，对P1的确认到达。源将错误地将此确认视为P2的确认，并计算不正确的SampleRTT值。
P34、在任何给定的时间t，sendBase-1是发送方知道的最后一个字节的序列号，发送方知道该字节已在接收方正确地、有序地接收到。如果管道中有确认，则接收方在时间t处实际接收的最后一个字节(正确和有序)可能更大。因此
SendBase-1=C*2TP。
因此，S>=C*2TP。
P48、
a)让W表示最大窗口大小。当最大发送速率达到链路容量时，当数据包丢弃时，W*MSS/RTT=10 Gbps。因此，我们有W*1500*8/0.15=10*10^9，然后W=125000段。
b)当拥塞窗口大小在W/2到W之间变化时，平均窗口大小为0.75W=93750。平均吞吐量为93750*1500*8/0.1=7.5Gbps。
c)93750/2*0.15/60=117分钟。为了加快窗口增长的速度，我们可以将窗口大小增加一个更大的值，而不是在每个RTT中只增加一个窗口大小。针对这一问题，本文提出了一些协议，如ScalableTCP或高速TCP。
P49、当TCP的平均吞吐量B由下式给出时
$B=\frac{1.22 \cdot MSS}{RTT \cdot \sqrt{L}}$
我们知道，
$L=(1.22\ast MSS/(B\ast RTT))^2$