## 思考题给大家出两道思考题：第一道，你可以查查资料，看看有没有比较著名的程序是使用这样的模式来构建的？第二道，程序中处理 SIGCHLD信号时，使用了一个循环来回收处理终止的子进程，为什么要这么做呢？如果不使用循环会有什么后果？欢迎你在评论区写下你的思考，我会和你一起交流，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。![](Images/5a282807b2a1ff091b7f803e8cef3429.png){savepage-src="https://static001.geekbang.org/resource/image/bf/25/bfc96ae0d8f839919b9d9866cfb8b025.jpg"}
# 26 \| 使用阻塞I/O和线程模型：换一种轻量的方式你好，我是盛延敏，这里是网络编程实战第 26 讲，欢迎回来。在前面一讲中，我们使用了进程模型来处理用户连接请求，进程切换上下文的代价是比较高的，幸运的是，有一种轻量级的模型可以处理多用户连接请求，这就是线程模型。这一讲里，我们就来了解一下线程模型。线程（thread）是运行在进程中的一个"逻辑流"，现代操作系统都允许在单进程中运行多个线程。线程由操作系统内核管理。每个线程都有自己的上下文（context），包括一个可以唯一标识线程的ID（thread ID，或者叫tid）、栈、程序计数器、寄存器等。在同一个进程中，所有的线程共享该进程的整个虚拟地址空间，包括代码、数据、堆、共享库等。在前面的程序中，我们没有显式使用线程，但这不代表线程没有发挥作用。实际上，每个进程一开始都会产生一个线程，一般被称为主线程，主线程可以再产生子线程，这样的主线程 -子线程对可以叫做一个对等线程。你可能会问，既然可以使用多进程来处理并发，为什么还要使用多线程模型呢？简单来说，在同一个进程下，线程上下文切换的开销要比进程小得多。怎么理解线程上下文呢？我们的代码被CPU 执行的时候，是需要一些数据支撑的，比如程序计数器告诉 CPU代码执行到哪里了，寄存器里存了当前计算的一些中间值，内存里放置了一些当前用到的变量等，从一个计算场景，切换到另外一个计算场景，程序计数器、寄存器等这些值重新载入新场景的值，就是线程的上下文切换。``{=html}
## POSIX 线程模型POSIX 线程是现代 UNIX 系统提供的处理线程的标准接口。POSIX定义的线程函数大约有 60多个，这些函数可以帮助我们创建线程、回收线程。接下来我们先看一个简单的例子程序。    int another_shared = 0; void thread_run(void *arg) {    int *calculator = (int *) arg;    printf("hello, world, tid == %d \n", pthread_self());    for (int i = 0; i = 'a' && c = 'A' && c = 'n' && c = 'N' && c  quitConnection closed.
## 构建线程池处理多个连接上面的服务器端程序虽然可以正常工作，不过它有一个缺点，那就是如果并发连接过多，就会引起线程的频繁创建和销毁。虽然线程切换的上下文开销不大，但是线程创建和销毁的开销却是不小的。能不能对这个程序进行一些优化呢？我们可以使用预创建线程池的方式来进行优化。在服务器端启动时，可以先按照固定大小预创建出多个线程，当有新连接建立时，往连接字队列里放置这个新连接描述字，线程池里的线程负责从连接字队列里取出连接描述字进行处理。![](Images/01ce453bf03733175f6fd02f2be72931.png){savepage-src="https://static001.geekbang.org/resource/image/d9/72/d976c7b993862f0dbef75354d2f49672.png"}\这个程序的关键是连接字队列的设计，因为这里既有往这个队列里放置描述符的操作，也有从这个队列里取出描述符的操作。对此，需要引入两个重要的概念，一个是锁 mutex，一个是条件变量condition。锁很好理解，加锁的意思就是其他线程不能进入；条件变量则是在多个线程需要交互的情况下，用来线程间同步的原语。    // 定义一个队列typedef struct {    int number;  // 队列里的描述字最大个数    int *fd;     // 这是一个数组指针    int front;   // 当前队列的头位置    int rear;    // 当前队列的尾位置    pthread_mutex_t mutex;  // 锁    pthread_cond_t cond;    // 条件变量} block_queue; // 初始化队列void block_queue_init(block_queue *blockQueue, int number) {    blockQueue->number = number;    blockQueue->fd = calloc(number, sizeof(int));    blockQueue->front = blockQueue->rear = 0;    pthread_mutex_init(&blockQueue->mutex, NULL);    pthread_cond_init(&blockQueue->cond, NULL);} // 往队列里放置一个描述字 fdvoid block_queue_push(block_queue *blockQueue, int fd) {    // 一定要先加锁，因为有多个线程需要读写队列    pthread_mutex_lock(&blockQueue->mutex);    // 将描述字放到队列尾的位置    blockQueue->fd[blockQueue->rear] = fd;    // 如果已经到最后，重置尾的位置    if (++blockQueue->rear == blockQueue->number) {        blockQueue->rear = 0;    }    printf("push fd %d", fd);    // 通知其他等待读的线程，有新的连接字等待处理    pthread_cond_signal(&blockQueue->cond);    // 解锁    pthread_mutex_unlock(&blockQueue->mutex);} // 从队列里读出描述字进行处理int block_queue_pop(block_queue *blockQueue) {    // 加锁    pthread_mutex_lock(&blockQueue->mutex);    // 判断队列里没有新的连接字可以处理，就一直条件等待，直到有新的连接字入队列    while (blockQueue->front == blockQueue->rear)        pthread_cond_wait(&blockQueue->cond, &blockQueue->mutex);    // 取出队列头的连接字    int fd = blockQueue->fd[blockQueue->front];    // 如果已经到最后，重置头的位置    if (++blockQueue->front == blockQueue->number) {        blockQueue->front = 0;    }    printf("pop fd %d", fd);    // 解锁    pthread_mutex_unlock(&blockQueue->mutex);    // 返回连接字    return fd;}  我在文稿里放置了 block_queue相关的定义和实现，并在关键的地方加了一些蛛丝，有几个地方需要特别注意：第一是记得对操作进行加锁和解锁，这里是通过 pthread_mutex_lock 和pthread_mutex_unlock 来完成的。第二是当工作线程没有描述字可用时，需要等待，第 43 行通过调用pthread_cond_wait，所有的工作线程等待有新的描述字可达。第 32行，主线程通知工作线程有新的描述符需要服务。服务器端程序如下：    void thread_run(void *arg) {    pthread_t tid = pthread_self();    pthread_detach(tid);     block_queue *blockQueue = (block_queue *) arg;    while (1) {        int fd = block_queue_pop(blockQueue);        printf("get fd in thread, fd==%d, tid == %d", fd, tid);        loop_echo(fd);    }} int main(int c, char **v) {    int listener_fd = tcp_server_listen(SERV_PORT);     block_queue blockQueue;    block_queue_init(&blockQueue, BLOCK_QUEUE_SIZE);     thread_array = calloc(THREAD_NUMBER, sizeof(Thread));    int i;    for (i = 0; i  quitConnection closed.和前面的程序相比，线程创建和销毁的开销大大降低，但因为线程池大小固定，又因为使用了阻塞套接字，肯定会出现有连接得不到及时服务的场景。这个问题的解决还是要回到我在开篇词里提到的方案上来，多路I/O 复用加上线程来处理，仅仅使用阻塞 I/O模型和线程是没有办法达到极致的高并发处理能力。
## 总结这一讲，我们使用了线程来构建服务器端程序。一种是每次动态创建线程，另一种是使用线程池提高效率。和进程相比，线程的语义更轻量，使用的场景也更多。线程是高性能网络服务器必须掌握的核心知识，希望你能够通过本讲的学习，牢牢掌握它。
## 思考题和往常一样，给你留两道思考题。第一道，连接字队列的实现里，有一个重要情况没有考虑，就是队列里没有可用的位置了，想想看，如何对这种情况进行优化？第二道，我在讲到第一个 hello-world计数器应用时，说"结果是幸运"这是为什么呢？怎么理解呢？欢迎你在评论区写下你的思考，我会和你一起思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。![](Images/5a282807b2a1ff091b7f803e8cef3429.png){savepage-src="https://static001.geekbang.org/resource/image/bf/25/bfc96ae0d8f839919b9d9866cfb8b025.jpg"}
# 27 \| I/O多路复用遇上线程：使用poll单线程处理所有I/O事件你好，我是盛延敏，这里是网络编程实战第 27 讲，欢迎回来。我在前面两讲里，分别使用了 fork 进程和 pthread线程来处理多并发，这两种技术使用简单，但是性能却会随着并发数的上涨而快速下降，并不能满足极端高并发的需求。就像第24讲中讲到的一样，这个时候我们需要寻找更好的解决之道，这个解决之道基本的思想就是I/O 事件分发。关于文稿中的代码，你可以去[GitHub](https://github.com/froghui/yolanda)上查看或下载完整代码。]{.orange}
## 重温事件驱动