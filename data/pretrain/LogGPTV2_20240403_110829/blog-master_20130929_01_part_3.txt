kernel.statement("tcp_v4_connect@net/ipv4/tcp_ipv4.c:233"), 5847, 3, sk=0xffff81012d2146c0 uaddr=0xffff8100a82d1ec8 addr_len=? inet=? tp=? usin=? rt=0xffff81012dfaf200 daddr=0x270310ac nexthop=0x270310ac tmp=0xffffffffa82d1bd8 err=? inet_opt=?, {.__sk_common={.skc_family=2, .skc_state='\a', .skc_reuse='\000', .skc_bound_dev_if=0, .skc_node={.next=0x0, .pprev=0x0}, .skc_bind_node={.next=0x0, .pprev=0x0}, .skc_refcnt={.counter=1}, .skc_hash=0, .skc_prot=0xffffffff80370780}, .sk_shutdown=0, .sk_no_check=0, .sk_userlocks=0, .sk_protocol='\006', .sk_type=1, .sk_rcvbuf=87380, .sk_lock={.slock={.raw_lock={.slock=1}}, .owner=0x1, .wq={.lock={.raw_lock={.slock=1}}, .task_list={.next=0xffff81012d214718, .prev=0xffff81012d214718}}}, .sk_sleep=0xffff8100b060  
kernel.statement("tcp_v4_connect@net/ipv4/tcp_ipv4.c:245"), 5847, 3, sk=0xffff81012d2146c0 uaddr=0xffff8100a82d1ec8 addr_len=? inet=? tp=? usin=? rt=0xffff81012dfaf200 daddr=0x270310ac nexthop=0x270310ac tmp=? err=0x0 inet_opt=?, {.__sk_common={.skc_family=2, .skc_state='\002', .skc_reuse='\000', .skc_bound_dev_if=0, .skc_node={.next=0x0, .pprev=0xffff81012f0f5c38}, .skc_bind_node={.next=0x0, .pprev=0xffff81012e9843b8}, .skc_refcnt={.counter=1}, .skc_hash=62915, .skc_prot=0xffffffff80370780}, .sk_shutdown=0, .sk_no_check=0, .sk_userlocks=0, .sk_protocol='\006', .sk_type=1, .sk_rcvbuf=87380, .sk_lock={.slock={.raw_lock={.slock=1}}, .owner=0x1, .wq={.lock={.raw_lock={.slock=1}}, .task_list={.next=0xffff81012d214718, .prev=0xffff81012  
kernel.statement("tcp_v4_connect@net/ipv4/tcp_ipv4.c:250"), 5847, 3, sk=0xffff81012d2146c0 uaddr=0xffff8100a82d1ec8 addr_len=? inet=? tp=? usin=? rt=0xffff81012dfaf200 daddr=0x270310ac nexthop=0x270310ac tmp=? err=0x0 inet_opt=?, {.__sk_common={.skc_family=2, .skc_state='\002', .skc_reuse='\000', .skc_bound_dev_if=0, .skc_node={.next=0x0, .pprev=0xffff81012f0f5c38}, .skc_bind_node={.next=0x0, .pprev=0xffff81012e9843b8}, .skc_refcnt={.counter=1}, .skc_hash=62915, .skc_prot=0xffffffff80370780}, .sk_shutdown=0, .sk_no_check=0, .sk_userlocks=0, .sk_protocol='\006', .sk_type=1, .sk_rcvbuf=87380, .sk_lock={.slock={.raw_lock={.slock=1}}, .owner=0x1, .wq={.lock={.raw_lock={.slock=1}}, .task_list={.next=0xffff81012d214718, .prev=0xffff81012  
kernel.statement("tcp_v4_connect@net/ipv4/tcp_ipv4.c:251"), 5847, 3, sk=0xffff81012d2146c0 uaddr=0xffff8100a82d1ec8 addr_len=? inet=? tp=? usin=? rt=0xffff81012dfaf200 daddr=0x270310ac nexthop=0x270310ac tmp=? err=0x0 inet_opt=?, {.__sk_common={.skc_family=2, .skc_state='\002', .skc_reuse='\000', .skc_bound_dev_if=0, .skc_node={.next=0x0, .pprev=0xffff81012f0f5c38}, .skc_bind_node={.next=0x0, .pprev=0xffff81012e9843b8}, .skc_refcnt={.counter=1}, .skc_hash=62915, .skc_prot=0xffffffff80370780}, .sk_shutdown=0, .sk_no_check=0, .sk_userlocks=0, .sk_protocol='\006', .sk_type=1, .sk_rcvbuf=87380, .sk_lock={.slock={.raw_lock={.slock=1}}, .owner=0x1, .wq={.lock={.raw_lock={.slock=1}}, .task_list={.next=0xffff81012d214718, .prev=0xffff81012  
kernel.statement("tcp_v4_connect@net/ipv4/tcp_ipv4.c:253"), 5847, 3, sk=0xffff81012d2146c0 uaddr=0xffff8100a82d1ec8 addr_len=? inet=? tp=? usin=? rt=0xffff81012dfaf200 daddr=0x270310ac nexthop=0x270310ac tmp=? err=? inet_opt=?, {.__sk_common={.skc_family=2, .skc_state='\002', .skc_reuse='\000', .skc_bound_dev_if=0, .skc_node={.next=0x0, .pprev=0xffff81012f0f5c38}, .skc_bind_node={.next=0x0, .pprev=0xffff81012e9843b8}, .skc_refcnt={.counter=1}, .skc_hash=62915, .skc_prot=0xffffffff80370780}, .sk_shutdown=0, .sk_no_check=0, .sk_userlocks=0, .sk_protocol='\006', .sk_type=1, .sk_rcvbuf=87380, .sk_lock={.slock={.raw_lock={.slock=1}}, .owner=0x1, .wq={.lock={.raw_lock={.slock=1}}, .task_list={.next=0xffff81012d214718, .prev=0xffff81012  
kernel.statement("tcp_v4_connect@net/ipv4/tcp_ipv4.c:254"), 5847, 3, sk=0xffff81012d2146c0 uaddr=0xffff8100a82d1ec8 addr_len=? inet=? tp=? usin=? rt=0xffff81012dfaf200 daddr=0x270310ac nexthop=0x270310ac tmp=? err=? inet_opt=?, {.__sk_common={.skc_family=2, .skc_state='\002', .skc_reuse='\000', .skc_bound_dev_if=0, .skc_node={.next=0x0, .pprev=0xffff81012f0f5c38}, .skc_bind_node={.next=0x0, .pprev=0xffff81012e9843b8}, .skc_refcnt={.counter=1}, .skc_hash=62915, .skc_prot=0xffffffff80370780}, .sk_shutdown=0, .sk_no_check=0, .sk_userlocks=0, .sk_protocol='\006', .sk_type=1, .sk_rcvbuf=87380, .sk_lock={.slock={.raw_lock={.slock=1}}, .owner=0x1, .wq={.lock={.raw_lock={.slock=1}}, .task_list={.next=0xffff81012d214718, .prev=0xffff81012  
kernel.statement("tcp_v4_connect@net/ipv4/tcp_ipv4.c:264"), 5847, 3, sk=0xffff81012d2146c0 uaddr=0xffff8100a82d1ec8 addr_len=? inet=? tp=? usin=? rt=0xffff81012dfaf200 daddr=0x270310ac nexthop=0x270310ac tmp=? err=? inet_opt=?, {.__sk_common={.skc_family=2, .skc_state='\002', .skc_reuse='\000', .skc_bound_dev_if=0, .skc_node={.next=0x0, .pprev=0xffff81012f0f5c38}, .skc_bind_node={.next=0x0, .pprev=0xffff81012e9843b8}, .skc_refcnt={.counter=2}, .skc_hash=62915, .skc_prot=0xffffffff80370780}, .sk_shutdown=0, .sk_no_check=0, .sk_userlocks=0, .sk_protocol='\006', .sk_type=1, .sk_rcvbuf=87380, .sk_lock={.slock={.raw_lock={.slock=1}}, .owner=0x1, .wq={.lock={.raw_lock={.slock=1}}, .task_list={.next=0xffff81012d214718, .prev=0xffff81012  
kernel.statement("tcp_v4_connect@net/ipv4/tcp_ipv4.c:262"), 5847, 3, sk=0xffff81012d2146c0 uaddr=0xffff8100a82d1ec8 addr_len=? inet=? tp=? usin=? rt=0xffff81012dfaf200 daddr=0x270310ac nexthop=0x270310ac tmp=0x0 err=0x0 inet_opt=?, {.__sk_common={.skc_family=2, .skc_state='\002', .skc_reuse='\000', .skc_bound_dev_if=0, .skc_node={.next=0x0, .pprev=0xffff81012f0f5c38}, .skc_bind_node={.next=0x0, .pprev=0xffff81012e9843b8}, .skc_refcnt={.counter=2}, .skc_hash=62915, .skc_prot=0xffffffff80370780}, .sk_shutdown=0, .sk_no_check=0, .sk_userlocks=0, .sk_protocol='\006', .sk_type=1, .sk_rcvbuf=87380, .sk_lock={.slock={.raw_lock={.slock=1}}, .owner=0x1, .wq={.lock={.raw_lock={.slock=1}}, .task_list={.next=0xffff81012d214718, .prev=0xffff81012  
```  
其他例子 :   
```  
# Refers to the statement at line 296 within the  
# kernel/time.c file:  
kernel.statement("*@kernel/time.c:296")  
# Refers to the statement at line bio_init+3 within the fs/bio.c file:  
kernel.statement("bio_init@fs/bio.c+3")  
# Refers to all kernel functions with "init" or "exit"  
# in the name:  
kernel.function("*init*"), kernel.function("*exit*")  
# Refers to any functions within the "kernel/time.c"  
# file that span line 240:  
kernel.function("*@kernel/time.c:240")  
# Refers to all functions in the ext3 module:  
module("ext3").function("*")  
```  
下面讲解一下变量 :   
```  
Some of the source-level variables, such as function parameters, locals, or globals visible in the compilation unit, are visible to probe handlers. Refer to these variables by prefixing their name with a dollar sign within the scripts. In addition, a special syntax allows limited traversal of structures, pointers, arrays, taking the address of a variable or pretty printing a whole structure.  
handler中可以看到的源码级的变量一般包含函数参数, 函数内的本地变量, 以及CU(编译单元指一个C文件,)可见的全局变量.  
$var refers to an in-scope variable var. If it is a type similar to an integer, it will be cast to a 64-bit integer for script use. Pointers similar to a string (char *) are copied to SystemTap string values by the kernel_string() or user_string() functions.  
使用$varname或者@var("varname")表示本地变量和参数变量. 数字直接打印, 字符串可使用kernel_string()或者user_string()函数打印.  
@var("varname") is an alternative syntax for $varname. It can also be used to access global variables in a particular compile unit (CU). @var("varname@src/file.c") refers to the global (either file local or external) variable varname defined when the file src/file.c was compiled. The CU in which the variable is resolved is the first CU in the module of the probe point which matches the given file name at the end and has the shortest file name path (e.g. given @var("foo@bar/baz.c") and CUs with file name paths src/sub/module/bar/baz.c and src/bar/baz.c the second CU will be chosen to resolve foo).  
对于全局变量, 必须使用另一种表示方式@var("varname@src/file.c"). 对于有多个文件路径的情况, 匹配短路径.  
例如 given @var("foo@bar/baz.c") and CUs with file name paths src/sub/module/bar/baz.c and src/bar/baz.c the second CU will be chosen to resolve foo  
$var->field or @var("var@file.c")->field traverses a structure's field. The indirection operator may be repeated to follow additional levels of pointers.  
->符号表示结构中的field, 注意不能使用点(.), 因为(.)在systemtap中是字符串连接符号 , 类似SQL中的||连接符 .  
所以在stap中统一使用->.  
例如$var->field or @var("var@file.c")->field  
$var[N] or @var("var@file.c")[N] indexes into an array. The index is given with a literal number.  
数组则这么表示 $var[N] or @var("var@file.c")[N]   
&$var or &@var("var@file.c") provides the address of a variable as a long. It can also be used in combination with field access or array indexing to provide the address of a particular field or an element in an array with &var->field, &@var("var@file.c")[N] or a combination of those accessors.  
取地址和c一样用&, 例如&$var or &@var("var@file.c") provides the address of a variable as a long. 取结构或数组中元素的地址如&var->field, &@var("var@file.c")[N].  
Using a single $ or a double $$ suffix provides a swallow or deep string representation of the variable data type. Using a single $, as in $var$, will provide a string that only includes the values of all basic type values of fields of the variable structure type but not any nested complex type values (which will be represented with {...}). Using a double $$, as in @var("var")$$ will provide a string that also includes all values of nested data types.  
在结构变量末尾加$表示输出结构体内所有field的值, 如果加2个$, $$表示输出结构体内所有field的值以及同样是结构体的field也继续输出, 一直到所有的基本类型都输出为止. 例如$var$, @var("var")$$  
$$vars expands to a character string that is equivalent to sprintf("parm1=%x ... parmN=%x var1=%x ... varN=%x", $parm1, ..., $parmN, $var1, ..., $varN)  
$$vars 将输出所有的本地变量和参数变量名称以及它的值.  
$$locals expands to a character string that is equivalent to sprintf("var1=%x ... varN=%x", $var1, ..., $varN)  
$$locals 将输出所有的本地变量名称以及它的值.  
$$parms expands to a character string that is equivalent to sprintf("parm1=%x ... parmN=%x", $parm1, ..., $parmN)  
$$parms 将输出所有的参数变量名称以及它的值.  
```  
## 参考  
1\. https://sourceware.org/systemtap/langref/Probe_points.html  
2\. https://sourceware.org/systemtap/tapsets/  
3\. /usr/src/debug/kernel-2.6.18/linux-2.6.18-348.12.1.el5.x86_64/net/ipv4/tcp_ipv4.c  
```  
   156  /* This will initiate an outgoing connection. */  
   157  int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)  
   158  {  
   159          struct inet_sock *inet = inet_sk(sk);  
   160          struct tcp_sock *tp = tcp_sk(sk);  
   161          struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;  
   162          struct rtable *rt;  
   163          u32 daddr, nexthop;  
   164          int tmp;  
   165          int err;  
   166          struct ip_options *inet_opt;  
   167    
   168          if (addr_len sin_family != AF_INET)  
   172                  return -EAFNOSUPPORT;  
   173    
   174          nexthop = daddr = usin->sin_addr.s_addr;  
   175          inet_opt = rcu_dereference(inet->opt);  
   176          if (inet_opt && inet_opt->srr) {  
   177                  if (!daddr)  
   178                          return -EINVAL;  
   179                  nexthop = inet_opt->faddr;  
   180          }  
   181    
   182          tmp = ip_route_connect(&rt, nexthop, inet->saddr,  
   183                                 RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,  
   184                                 IPPROTO_TCP,  
   185                                 inet->sport, usin->sin_port, sk, 1);  
   186          if (tmp rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {  
   193                  ip_rt_put(rt);  
   194                  return -ENETUNREACH;  
   195          }  
   196    
   197          if (!inet_opt || !inet_opt->srr)  
   198                  daddr = rt->rt_dst;  
   199    
   200          if (!inet->saddr)  
   201                  inet->saddr = rt->rt_src;  
   202          inet->rcv_saddr = inet->saddr;  
   203    
   204          if (tp->rx_opt.ts_recent_stamp && inet->daddr != daddr) {  
   205                  /* Reset inherited state */  
   206                  tp->rx_opt.ts_recent       = 0;  
   207                  tp->rx_opt.ts_recent_stamp = 0;  
   208                  tp->write_seq              = 0;  
   209          }  
   210    
   211          if (tcp_death_row.sysctl_tw_recycle &&  
   212              !tp->rx_opt.ts_recent_stamp && rt->rt_dst == daddr) {  
   213                  struct inet_peer *peer = rt_get_peer(rt);  
   214    
   215                  /* VJ's idea. We save last timestamp seen from  
   216                   * the destination in peer table, when entering state TIME-WAIT  
   217                   * and initialize rx_opt.ts_recent from it, when trying new connection.  