68
第2章：入门示例拓展
测验答案
67页问题的答案
$text=~8/（\d)（（\d\d\d）+\b)/$1,$2/g：能够在数字中添加退号吗？
结果并非我们的期望。得到的是类似“281,421906”的字符串。这是因为（\d\d\d）+
匹配的数宇属于最终匹配文本，所以不能作为“未匹配的”部分，供/g的下一次匹配
选代使用。
一次送代完成时，下一次的选代会从上一次匹配的终点开始尝试。我们希望的是，在
插入运号以后，还能够继续检查这个数值，以决定是否需要再插入逗号。但是，在这
个例子中，重新开始的起点是整个数值的末尾。使用顺序环视的意义在于，检查某个
实际上，这个表达式仍然可以用来解决这个问题，但正则表达式必须由宿主语言反复
调用，例如通过一个while循环，每次检查的都是上次修改后的宇符串。每次替换操
作都会添加一个追号（对目标宇符串中的每个数值都是如此，因为/g的存在），下面
是一个例子：
while（$text =~s/(\d)((\d\d\d)+\b)/$1,$2/g）{
#循环内不用进行任何操作一我们希望的是重复这个循环，直到匹配失败
}
如果我们的样本文件包含3个短行：
This is a sample file.
It has three lines.
That's al1
变量stext的内容就是：
This is a sample file. It has tt:ee lines.  That's al1 
在某些平台上，也可能是：
This isa sample file.It has three 1ines.国 That's all
这是因为大多数系统采用换行符作为一行的终结符，而某些系统（主要是Windows）使用
回车/换行的结合体。我们会确保这个简单的工具能应付这两种情况。
处理特殊字符
的HTML编码，分别是‘&amp”、‘&1t’和‘&gt”。在HTML中这些字符有特殊的含义，
制
---
## Page 95
使用正则裹达式修改文本
69
编码不正确可能会导致显示错误。我称这种简单的转换为“为HTML而加工（cookingthetext
forHTML）”，它的确非常简单：
Stext=~B/&/&amp:/g：#保证基本的HTML
Stext=~B/…
$text=~B/>/&gt;/g;#转换后不出错
请注意，我们使用了/g来对所有的目标字符进行替换（如果不用/g，就只会替换第一次出
现的特殊字符）。首先转换&是很重要的，因为这三者的replacement中都有&’字符。
分隔段落
接下来我们用HTMLtag中表示分段的来标记段落。识别段落的简单办法就是把空行作
为段落之间的分隔。搜索空行的办法有很多，最容易想到的是：
$text=~8/^s//g;
它可以匹配“行末尾紧随行开头的位置”。确实，我们已经在第10页着到，在egrep之类的
工具中这样行得通，因为其中被检索的文本通常只包含逻辑上的一行文本。在Per中也同
样有效，对于之前看到过的E-mail的例子，我们知道每一个字符串只包含一个逻辑行。
是整个的字符串的开头和结束位置（注5）。所以，既然目标字符串中有多个逻辑行，就需
要采取不同的办法。
幸好，大多数支持正则表达式的语言提供了个简单的办法，即“增强的行锚点”（enhanced
lineanchor）匹配模式，在这种模式下，~和$i会从字符串模式切换到本例中需要的逻辑行
模式。在Perl中，使用/m修饰符来选择此模式：
stext=~B/^s//mg;
我们会看到其他语言是如何处理修饰符的。
 Thus.…。
不过，如果在“空行”中包含空格符或者其他空白字符，这么做就行不通。为了处理空白
字符，我们使用$，或者是{\t\r]*S来匹配某些系统在换行符之前的空格符、制表
注5：实际上，S通常比简单的“字符串结尾”要更复杂些，尽管对本例中这并不重要。详细信
息请阅读第129页关于行结束锚点的讨论。
---
## Page 96
70
第2章：入门示例拓展
符或者回车符。这两个表达式与S是完全不同的，因为它们确实匹配了一些字符，而S
只匹配位置。不过，因为在本例中我们不需要这些空格符、制表符和回车符，匹配（然后
用分段tag来替换）这些字符不会带来任何问题。
如果你还记得第47页的sI，你可能会想到s*$，就像我们在第55页E-mail的例子中
所用的那样。如果用\s取代\t\r]，因为\s能够匹配换行符，所以整个表达式的意
的行的结合”。也就是说，如果我们找到多个连续的这样的文本行，一个\s*$就能够匹
配它们。这样的好处在于，只会留下个，而不是像以前那样有多少空行就留下多少。
所以，如果stext有这样的字符串：
with.·Therefore.
我们用：
$text=-θ/^[\t\r]*$//mg
结果就是
with.Therefore
不过，如果我们用：
Stext=~8/^s*$//mg;
结果要更好看一些：
with. Therefore
所以，在最终的程序中，我们会使用\s*S
将E-mail地址转换为超链接形式
Text-to-HTML转换的下一步是识别出E-mail地址，然后把它们转换为“mailto”链接。例
如，PI:EMAIL会被转换为jfriedl
@oreilly.coms
用正则表达式来匹配或者验证E-mail地址是常见的情况。E-mail地址的标准规范异常紧杂，
所以很难做到百分之百的准确，但是一些简单的正则表达式就可以应付遇到的大多数E-mail
地址。E-mail地址的基本形式是username@hostmame。在思考该用怎样的表达式来匹配各个
部分之前，我们先看看这个正则表达式的具体应用环境：
Stext=~ 8/\b(username regexy@hostnameregex)\b/$1/g;
需要注意的一点是其中两个用下画线标注的反斜线，第一个在正则表达式（@）中，另
---
## Page 97
使用正则表达式修改文本
71
一个在replacement字符串的末尾。使用这两个反斜线的理由各不相同。我会在稍后讨论\@
(77)，现在我们只需要知道，Perl规定作为文本字符的e符号必须转义。
先介绍replacement字符串中在‘/’之前的反斜线比较好。我们已经看到，Perl中查找替换
的基本形式是s/regex/replacement/modifier，用斜线来分隔。所以，如果我们需要在某个部分
中使用斜线，就必须使用转义，否则反斜线会被识别为分隔符，作为字符串的一部分。也
就是说，如果我们希望在replacement字符串中使用，就必须写作。
或者s{regex}（string}modifier。无论采用哪种形式，因为replacement字符串中的斜线不再与
分隔符有冲突，也就不需要转义。第二种形式的分隔符非常明显，所以从现在开始我们采
用这种形式。
回到程序中来，请注意整个地址是处于b\bi之间的。添加这些单词分界符能够避免不
完整匹配的情况，例如‘jfriedl@oreilly.compiler'。尽管遭遇这种无意义的字符串的
几率很小，但使用单词分界符来避免此类匹配一点也不麻烦，所以我会这么做。请注意我
是如何用括号包围整个E-mail地址的，这样我们就能使用replacement字符串
'$1。
匹配用户名和主机名
现在我们来看匹配邮件地址所需要的用户名和主机名的正则表达式。主机名，例如regex，
info或者www.oreilly.com，它们由点号分隔，以‘com'、‘edu'、‘info'、‘uk’或者
其他事先规定的字符序列结尾。匹配E-mail地址的最简单的办法是\w+\\w+（\.\w+）+
用八w+来匹配用户名，以及主机名的各个部分。不过，实际应用起来，我们需要考虑得更
周到一些。用户名可以包含点号和连字符（虽然用户名不会以这两种字符开头）。所以，我
们不应该使用w+，而应该用w[-.\w]*。这就保证用户名以w开头，后面的部分可以
包括点号和连字符。（请注意，我们在字符组中把连字符排在第一位，这样就确保它们被作
为连字符，而不是用来表示范围。对许多流派来说，.-\w表示的范围肯定是错误的，它会
产生一个随机的字母、数字和标点符号的集合，具体取决于程序和计算机所用的字符编码。
Perl能够正确处理.-\w，但是使用连字符时多加小心是个好习惯。）
---
## Page 98
72
第2章：入门示例拓展
主机名的匹配要复杂一些，因为点号只能作分隔符，也就是说两个点号之间必须有其他字
符。所以在前面那个简单的正则表达式中，主机名部分用w+（\.\w+）+i而不是"（\w.]+1。
后者会匹配‘..x..”。但是，即使是前者，也能够匹配‘PI:EMAIL'，所以我们
需要更细心一些。
一个办法是给出末尾部分的可能序列，跟在\w+（\.\w+）*\.（comledulinfo）i之后（实际
上，多选分支应该是gomledulgov|int|mil|net|org|biz|info|name|museum|coopl
aero1[a-z][a-z]，不过为了简洁起见，我在这里只列出几项）。这样就能容许开头的'\w+
部分，然后是可能出现的.\w+部分，最后才是我们指定的可能结尾。
实际上w也不是很合适。w能够匹配ASCII字母和数字，这没有问题，但有些系统中w
能够匹配非ASCII字母，例如a、C、三、&。在大多数流派中，下画线也是可以的。但这些
字符都不应该出现在主机名中。所以，我们或许应该用[a-zA-z0-9]，或者是“[a-z0-9]1
加上/i修饰符（进行不区分大小写的匹配）。主机名可能包括连字符，所以我们用
[[-a-z0-9]：（再次注意，连字符应该放在第一位）。于是我们得到用来匹配主机名的
‘[-a-z0-9]+(\.[-a-z0-9]+)*\.(comledulinfo）J。
无论使用什幺正则表达式，记住它们应用的情境都是很重要的。[-a-20-9]+（\.
[-a-z0-9]+）*\.（comledulinfo）”这个正则表达式本身，可以匹配runC：\\
startup.commandatstartup'，但是把它置入程序运行的环境中，我们就能确认，它会
匹配我们期望的文本，而忽略不期望的内容。实际上，我会把它放人之前提到的。
Stext =~s{\b(usemame regex\@hostmameregex)\b){$1)gi;
（这里用了s{）（…)分隔符，以及/i），但这样就必须折行。当然，Per不关心这个问题，
也不关心表达式是否美观，但我关心。所以我要介绍/x修饰符，它容许我们重新编排这个
表达式：
$text =~B
\b
#把邮件地址存入变量S1…
username regex
hostname regex
\b
}($1)gix;
啊哈，现在看起来大不一样了。语句末尾出现了/x（在/g和/i之后），它对这个正则表达
---
## Page 99
使用正则表达式修改文本
73
式做了两件简单但有意义的事情。首先，大多数空白字符会被忽略，用户能够以“宽松排
列（free-format）”编排这个表达式，增强可读性。其次，它容许出现以#开头标记的注释。
要指出的是，加上/x之后，表达式中的大部分空格符变为“忽略自身”元字符（“ignoreme”
metacharacter），而#的意思是“忽略该字符及其之后第一个换行符之前的所有字符”（1l1）。
它们不是作为字符组内部的元字符（也就是说，即便使用了/x，这些字符组也不是“随意
编排”的）来对待的，而且，同其他元字符一样，如果希望把它们作为普通字符来处理，
也可以对它们加以转义。当然，\si总是能够匹配空白字符，例如m//x。
请注意，/x只能应用于正则表达式本身，而不是replacement字符串。同样，即使我们现在
使用的是s（）（）的格式，修饰符接在最后的‘）’之后（例如‘)x'），但是在文中我们仍
然使用“/x”代表“修饰符x”。
综合起来
现在，我们可以把用户名、主机名的部分，以及之前的开发成果结合起来，得到相对完整
的程序：
undefS/；#进入“文件读取”模式
Stext=<>：#读入命令行中指定的第一个文件名
Stext=~8/&/&amp:/g:
#把基本的HTML….
Stext=~8/…
Stext=~8/>/&gt:/g;
#.进行HTML转义
Stext=~8/~\s*S//mg;
#划分段落
#转换为链接形式
$text =~8{
\b
#把地址保存到S1
(
\w[-.1w]*
username
[-a-z0-9]+(\.[-a-z0-9]+)*\.（comledu1info)#hostname
\b
){S1}gix;
printStext；#最后，显示HTML文本
所有的正则表达式都应用于同一个包含多行文本的字符串，需要注意的是，只有用于划分
段落的正则表达式才使用/m修饰符，因为只有那个正则表达式用到了和'$。对其他正则
表达式使用/m并不会产生影响（只会令看程序的人迷惑）。
---
## Page 100
74
第2章：入门示例拓展
把HTTPURL转换为链接形式
最后，我们需要识别HTTPURL，将它变为链接形式。也就是说把“http:/www.yahoo.com"
转变为http://www.yahoo.com/。
HTTPURL的基本形式是http://hostname/path，其中的/path部分是可选的。于是我们得到
下面的形式：
Stext =~8{
\b
#将URL保存至S1.
http://hostname
(
/path
)？
}{$1}gix;
）
主机部分的匹配可以使用在E-mail例子中用过的子表达式。URL的path部分可以包括各种
字符，在前一章中我们使用的是（-a-z0-9_：@&？=+，.!/~*$S]*（25），它包括了除空
白字符、控制字符和<>（）（）之外的大多数ASCII字符。
在使用Perl解决这个问题之前，我们必须对@和s进行转义。同样，我会在稍后讲解原因
（77）。现在，我们来看hostname和path部分：
$text =~8{
\b
将URL保存至S1
http://[-a-z0-9]+(\.[-a-z0-9]+)*\.(com|edulinfo)\b #hostname
(
/[-a-z0-9_：\@&？=+，.!/~*'8\$]*#path不一定会出现
)?
){$1)gix;
1
你可能注意了，在path之后没有\b，因为URL之后通常都是标点符号，例如本书在O'Reilly
的URL是：
http://www.oreilly.com/catalog/regex3/
如果末尾有bi，就不能匹配。
也就是说，在实际中，我们需要对表示URL结束的字符做一些人为的规定。比如下面的文
本：