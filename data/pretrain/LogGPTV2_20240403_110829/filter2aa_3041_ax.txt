05 import ( 
06 
 "fmt" 
07 
 "sync" 
08 
 "time" 
09 ) 
10 
11 // wg 用来等待程序结束 
12 var wg sync.WaitGroup 
13 
14 // main 是所有 Go 程序的入口 
15 func main() { 
16 
 // 创建一个无缓冲的通道 
17 
 baton := make(chan int) 
18 
19 
 // 为最后一位跑步者将计数加 1 
20 
 wg.Add(1) 
21 
22 
 // 第一位跑步者持有接力棒 
23 
 go Runner(baton) 
24 
25 
 // 开始比赛 
26 
 baton <- 1 
27 
28 
 // 等待比赛结束 
29 
 wg.Wait() 
30 } 
31 
32 // Runner 模拟接力比赛中的一位跑步者 
33 func Runner(baton chan int) { 
34 
 var newRunner int 
35 
6.5  通道
145
36 
// 等待接力棒
37 
 runner := <-baton 
38 
39 
// 开始绕着跑道跑步
40 
 fmt.Printf("Runner %d Running With Baton\n", runner) 
41 
42 
// 创建下一位跑步者
43 
 if runner != 4 { 
44 
 newRunner = runner + 1 
45 
 fmt.Printf("Runner %d To The Line\n", newRunner) 
46 
 go Runner(baton) 
47 
 } 
48 
49 
// 围绕跑道跑
50 
 time.Sleep(100 * time.Millisecond) 
51 
52 
// 比赛结束了吗？
53 
 if runner == 4 { 
54 
 fmt.Printf("Runner %d Finished, Race Over\n", runner) 
55 
 wg.Done() 
56 
 return 
57 
 } 
58 
59 
// 将接力棒交给下一位跑步者
60 
 fmt.Printf("Runner %d Exchange With Runner %d\n", 
61 
 runner, 
62 
 newRunner) 
63 
64     baton <- newRunner 
65 } 
运行这个程序会得到代码清单 6-23 所示的输出。 
代码清单 6-23  listing22.go 的输出 
Runner 1 Running With Baton 
Runner 1 To The Line 
Runner 1 Exchange With Runner 2 
Runner 2 Running With Baton 
Runner 2 To The Line 
Runner 2 Exchange With Runner 3 
Runner 3 Running With Baton 
Runner 3 To The Line 
Runner 3 Exchange With Runner 4 
Runner 4 Running With Baton 
Runner 4 Finished, Race Over 
在 main 函数的第 17 行，创建了一个无缓冲的 int 类型的通道 baton，用来同步传递接力棒。
在第 20 行，我们给 WaitGroup 加 1，这样 main 函数就会等最后一位跑步者跑步结束。在第 23 行
创建了一个 goroutine，用来表示第一位跑步者来到跑道。之后在第 26 行，将接力棒交给这个跑步者，
比赛开始。最终，在第 29 行，main 函数阻塞在 WaitGroup，等候最后一位跑步者完成比赛。 
在 Runner goroutine 里，可以看到接力棒 baton 是如何在跑步者之间传递的。在第 37 行，
goroutine 对 baton 通道执行接收操作，表示等候接力棒。一旦接力棒传了进来，在第 46 行就会
创建一位新跑步者，准备接力下一棒，直到 goroutine 是第四个跑步者。在第 50 行，跑步者围绕
跑道跑 100 ms。在第 55 行，如果第四个跑步者完成了比赛，就调用 Done，将 WaitGroup 减 1，
之后 goroutine 返回。如果这个 goroutine 不是第四个跑步者，那么在第 64 行，接力棒会交到下一
个已经在等待的跑步者手上。在这个时候，goroutine 会被锁住，直到交接完成。 
在这两个例子里，我们使用无缓冲的通道同步 goroutine，模拟了网球和接力赛。代码的流程
与这两个活动在真实世界中的流程完全一样，这样的代码很容易读懂。现在知道了无缓冲的通道
是如何工作的，接下来我们会学习有缓冲的通道的工作方法。 
6.5.2  有缓冲的通道 
有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。这种类
型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的
条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲
区容纳被发送的值时，发送动作才会阻塞。这导致有缓冲的通道和无缓冲的通道之间的一个很大
的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的
通道没有这种保证。 
在图6-7中可以看到两个goroutine分别向有缓冲的通道里增加一个值和从有缓冲的通道里移
除一个值。在第 1 步，右侧的 goroutine 正在从通道接收一个值。在第 2 步，右侧的这个 goroutine
独立完成了接收值的动作，而左侧的 goroutine 正在发送一个新值到通道里。在第 3 步，左侧的
goroutine 还在向通道发送新值，而右侧的 goroutine 正在从通道接收另外一个值。这个步骤里的
两个操作既不是同步的，也不会互相阻塞。最后，在第 4 步，所有的发送和接收都完成，而通道
里还有几个值，也有一些空间可以存更多的值。 
图 6-7  使用有缓冲的通道在 goroutine 之间同步数据 
让我们看一个使用有缓冲的通道的例子，这个例子管理一组 goroutine 来接收并完成工作。
有缓冲的通道提供了一种清晰而直观的方式来实现这个功能，如代码清单 6-24 所示。 
代码清单 6-24  listing24.go 
01 // 这个示例程序展示如何使用 
02 // 有缓冲的通道和固定数目的 
03 // goroutine 来处理一堆工作 
04 package main 
05 
06 import ( 
07 
 "fmt" 
08 
 "math/rand" 
09 
 "sync" 
10 
 "time" 
11 ) 
12 
13 const ( 
14 
 numberGoroutines = 4  // 要使用的 goroutine 的数量 
15 
 taskLoad 
 = 10  // 要处理的工作的数量 
16 ) 
17 
18 // wg 用来等待程序完成 
19 var wg sync.WaitGroup 
20 
21 // init 初始化包，Go 语言运行时会在其他代码执行之前 
22 // 优先执行这个函数 
23 func init() { 
24 
 // 初始化随机数种子 
25 
 rand.Seed(time.Now().Unix()) 
26 } 
27 
28 // main 是所有 Go 程序的入口 
29 func main() { 
30 
 // 创建一个有缓冲的通道来管理工作 
31 
 tasks := make(chan string, taskLoad) 
32 
33 
 // 启动 goroutine 来处理工作 
34 
 wg.Add(numberGoroutines) 
35 
 for gr := 1; gr <= numberGoroutines; gr++ { 
36 
 go worker(tasks, gr) 
37 
 } 
38 
39 
 // 增加一组要完成的工作 
40 
 for post := 1; post <= taskLoad; post++ { 
41 
 tasks <- fmt.Sprintf("Task : %d", post) 
42 
 } 
43 
44 
 // 当所有工作都处理完时关闭通道 
45 
 // 以便所有 goroutine 退出 
46 
 close(tasks) 
47 
48 
 // 等待所有工作完成 
49 
 wg.Wait() 
50 } 
51 
52 // worker 作为 goroutine 启动来处理 
53 // 从有缓冲的通道传入的工作 
54 func worker(tasks chan string, worker int) { 
55 
 // 通知函数已经返回 
56 
 defer wg.Done() 
57 
58 
 for { 
59 
 // 等待分配工作 
60 
 task, ok := <-tasks 
61 
 if !ok { 
62 
 // 这意味着通道已经空了，并且已被关闭 
63 
 fmt.Printf("Worker: %d : Shutting Down\n", worker) 
64 
 return 
65 
 } 
66 
67 
 // 显示我们开始工作了 
68 
 fmt.Printf("Worker: %d : Started %s\n", worker, task) 
69 
70 
 // 随机等一段时间来模拟工作 
71 
 sleep := rand.Int63n(100) 
72 
 time.Sleep(time.Duration(sleep) * time.Millisecond) 
73 
74 
 // 显示我们完成了工作 
75 
 fmt.Printf("Worker: %d : Completed %s\n", worker, task) 
76 
 } 
77 } 
运行这个程序会得到代码清单 6-25 所示的输出。 
代码清单 6-25  listing24.go 的输出 
Worker: 1 : Started Task : 1 
Worker: 2 : Started Task : 2 
Worker: 3 : Started Task : 3 
Worker: 4 : Started Task : 4 
Worker: 1 : Completed Task : 1 
Worker: 1 : Started Task : 5 
Worker: 4 : Completed Task : 4 
Worker: 4 : Started Task : 6 
Worker: 1 : Completed Task : 5 
Worker: 1 : Started Task : 7 
Worker: 2 : Completed Task : 2 
Worker: 2 : Started Task : 8 
Worker: 3 : Completed Task : 3 
Worker: 3 : Started Task : 9 
Worker: 1 : Completed Task : 7 
Worker: 1 : Started Task : 10 
Worker: 4 : Completed Task : 6 
Worker: 4 : Shutting Down 
Worker: 3 : Completed Task : 9 
Worker: 3 : Shutting Down 