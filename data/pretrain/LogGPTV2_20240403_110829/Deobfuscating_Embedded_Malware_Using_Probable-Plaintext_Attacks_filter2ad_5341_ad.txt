781
203
250
25
1,258
180
64
81
9
334
23.1%
31.7%
32.4%
36.0%
26.6%
Deobfuscation of Embedded Malware. We proceed to apply Kandi to the
collected embedded malware. Due to minor modiﬁcations by the malware author,
it is not always possible to extract a valid PE ﬁle. To verify if a deobfuscation
attempt was successful we thus utilize a PE checker based on strings such as
Windows API function (e.g. LoadLibrary, GetProcAddress, GetModuleHandle)
and library names as found in the import table (e.g. kernel32.dll, user32.dll)
Additionally, we look for the MZ and PE header signatures and the DOS stub.
We consider a deobfuscation successful if either a valid PE ﬁle is extracted or at
least ﬁve function or library names are revealed in the document.
We observe that for 359 of the samples no deobfuscation is necessary, as
the embedded malware is present in clear. Kandi identiﬁes such malware by
simply returning an obfuscation key of 0x00. We support this ﬁnding by applying
the PE checker described earlier. The remaining 1,258 samples are assumed
to be obfuscated. Every fourth of those samples contains malware obfuscated
with the Vigen`ere cipher and is deobfuscated by Kandi. That is, our method
automatically cracks the obfuscation of 334 samples and extracts the embedded
malware—possibly multiple ﬁles per sample. Table 3 details the results for the
individual datasets. A manual analysis of the remaining ﬁles on a sample basis
does not reveal obvious indicators for the Vigen`ere cipher and we conclude that
Kandi deobfuscates most variants used in real-world embedded malware.
Figure 8(a) shows the distribution of the key lengths discovered by Kandi.
The majority of samples is obfuscated with a single-byte key and seems to be in
reach for brute-forcing. However, to do so one would need to precisely locate the
encrypted ﬁle, which is not trivial. Moreover, our method also identiﬁes samples
with longer keys ranging from 3 to 8 bytes that would have been missed without
the help of Kandi. Rather surprising are those samples that use 3 bytes as a
key. One would suspect these to be false positives, but we have manually veriﬁed
that these are correctly deobfuscated by our method.
Deobfuscating Embedded Malware Using Probable-Plaintext Attacks
179
l
s
e
p
m
a
s
f
o
r
e
b
m
u
N
300
250
200
150
100
50
0
0
1
2
3
4
5
6
7
8
Key length
l
s
e
p
m
a
s
f
o
r
e
b
m
u
N
10
8
6
4
2
0
0 1 2 3 4 5 6 7 8 9 10111213141516171819
Number of engines
(a) Detected key lengths
(b) VirusTotal detections
Fig. 8. (a) Distribution of key lengths detected by Kandi; (b) Number of anti-virus
scanners detecting the extracted malware binaries.
As the ﬁnal step of this experiment, we analyze the extracted malware binaries
with 46 diﬀerent anti-virus scanners provided by VirusTotal. Since some of these
scanners are prone to errors when it comes to manipulated PE headers, we
consider only those 242 deobfuscated malware binaries that are valid PE ﬁles
(conform to the format speciﬁcation). The number of detections for each of these
ﬁles is shown in Figure 8(b). Several binaries are poorly detected by the anti-
virus scanners at VirusTotal. For instance, 19% (46) of the binaries are identiﬁed
by less than 10 of the available scanners. This result suggests that the extracted
binaries are unkown to a large portion of the anti-virus companies—likely due
to the lack of tools for automatic deobfuscation.
Finally, the analyzed binaries also contain several samples of the MiniDuke
malware discovered in early February 2013 [6]. A few months back, this threat has
been completely unknown, such that we are hopeful that binaries deobfuscated
by Kandi help the discovery of new and previously unknown malware.
5 Limitations
The previous evaluation demonstrates the capabilities of Kandi in automati-
cally deobfuscating embedded malware. Our approach targets a speciﬁc form of
obfuscation and thus cannot uncover arbitrarily obfuscated code in documents.
We discuss limitations resulting from this setting in the following and present
potential extensions of Kandi.
Obfuscation with Other Ciphers. Our approach builds on classic attacks
against Vigen`ere ciphers. If a diﬀerent cryptographic cipher is used for the ob-
fuscation, our method obviously cannot recover the original binary. For example,
the RC4-based obfuscation used in the trojan Taidoor [28] is resistant against
probable-plaintext attacks as used for Kandi. However, the usage of standard
cryptographic primitives, such as RC4 and AES, can introduce detectable pat-
terns in native code and thereby expose the presence of embedded malware in
documents [see 4]. To stay under the radar of detection tools, attackers need to
carefully balance the strength of obfuscation and its detectability, which provides
room for further cryptographic attacks.
180
C. Wressnegger, F. Boldewin, and K. Rieck
Availability of Plaintexts. The eﬃcacy of probable-plaintext attacks criti-
cally depends on a suﬃciently large set of plaintexts. If no or very few plaintexts
are available, the obfuscation cannot be reliably broken. As a result, attackers
might try to eliminate predicable plaintexts from their code, for example, by
removing header information or avoiding common libraries. Designing malware
that does not contain predictable plaintexts is feasible but requires to expend
considerable eﬀort. In practice, many targeted attacks therefore use multiple lay-
ers of obfuscation, where only few indicative patterns are visible at each layer.
Our evaluation demonstrates that this strategy is often insuﬃcient, as Kandi
succeeds in breaking the obfuscation of every fourth sample we analyzed.
Other Forms of Vigen`ere-Based Obfuscation. Our implementation of
Kandiis designed to deobfuscate streams of bytes as generated by native obfus-
cation code. Consequently, the method cannot be directly applied to other encod-
ings, as for example employed in malicious PDF documents using JavaScript code.
However, with only few modiﬁcations, Kandi can be extended to also support
other streams of data, such as unicode characters (16 bit) and integers (32 bit). In
combinations with techniques for detection and normalization of common encod-
ings, such as Base64 and URI encoding, Kandi might thus also help in breaking
Vigen`ere-based obfuscations in PDF documents and drive-by-download attacks.
However, extending the Vigen`ere cipher by, for instance, introducing chaining de-
ﬁnes a diﬀerent (although related) obfuscation and cannot be handled with the
current implemention of Kandi. We leave this to future work.
6 Related Work
The analysis of embedded malware has been a vivid area of research in the
last years, in particular due to the increasing usage of malicious documents
in targeted attacks [e.g., 1, 6, 28]. Several concepts and techniques have been
proposed to locate and examine malicious code in documents. Our approach is
related to several of these, as we discuss in the following.
Analysis of Embedded Malware. First methods for the identiﬁcation of
malware in documents have been proposed by Stolfo et al. [27] and Li et al. [15].
Both make use of content-based anomaly detection for learning proﬁles of regular
documents and detecting malicious content as deviation thereof. This work has
been further extended by Shaﬁq et al. [21], which reﬁne the static analysis of doc-
uments to also locate the regions likely containing malware. Although eﬀective
in spotting suspicious content, these methods are not designed to deobfuscate
code and thus are unsuitable for in-depth analysis of embedded malware.
Another branch of research has thus studied methods for analyzing malicious
documents at runtime, thereby avoiding the direct deobfuscation of embedded
code [e.g., 8, 15, 20]. For this dynamic analysis, the documents under inves-
tigation are opened in a sandbox environment, such that the behavior of the
application processing the documents can be monitored and malicious activities
detected. These approaches are not obstructed by obfuscation and can reliably
Deobfuscating Embedded Malware Using Probable-Plaintext Attacks
181
detect malicious code in documents. The monitoring at run-time, however, in-
duces a signiﬁcant overhead which is prohibitive for large-scale analysis or de-
tection of malware at end hosts.
Recently, a large body of work has focused on malicious PDF documents.
Due to the ﬂexibility of this format and its support for JavaScript code, these
documents are frequently used as vehicles to transport malware [25]. Several con-
trasting methods have been proposed to spot attacks and malware in JavaScript
code [e.g., 5, 13] and the structure of PDF ﬁles [e.g., 23, 29]. While some ma-
licious PDF documents make use of Vigen`ere-based obfuscation, other hiding
strategies are more prominent in the wild, most notably the dynamic construc-
tion of code. As a consequence, we have not considered PDF documents in this
work, yet the proposed deobfuscation techniques also apply to Vigen`ere ciphers
used in this document format.
Deobfuscating and Unpacking Malware. Aside from speciﬁc work on em-
bedded malware, the deobfuscation of malicious code has been a long-standing
topic of security research. In particular, several methods have been developed
to dynamically unpack malware binaries, such as PolyUnpack [18], OmniUn-
pack [17] and Ether [7]. These methods proceed by monitoring the usage of
memory and identifying unpacked code created at runtime. A similar approach
is devised by Sharif et al. [22], which defeats emulation-based packers using
dynamic taint analysis. These unpackers enable a generic deobfuscation of mali-
cious code, yet they operate at runtime and, similar to the analysis of documents
in a sandbox, suﬀer from a runtime overhead.
Due to the inherent limitations of static analysis, only few approaches have
been proposed that are able to statically inspect obfuscated malware. An exam-
ple is the method by Jacob et al. [11] that, similar to Kandi, exploits statistical
artifacts preserved through packing in order to analyze malware. The method
does not focus on deobfuscation but rather eﬃciently comparing malware bina-
ries and determining variants of the same family without dynamic analysis.
Probable-Plaintext Attacks. Attacks using probable and known plaintexts
are among the oldest methods of cryptography. The Kasiski examination used
in Kandi dates back to 1863 [12] and similarly the key elimination of Vigen`ere
ciphers is an ancient approach of cryptanalysis [see 19]. Given this long history
of research and the presence of several strong cryptographic methods, it would
seem that attacks against weak ciphers are largely irrelevant today. Unfortu-
nately, these weak ciphers regularly slip into implementations of software and
thus probable-plaintext attacks based on classic techniques are still successful,
as for instance in the cases of WordPerfect [2] and PKZIP [24].
To the best of our knowledge, Kandi is the ﬁrst method that applies these
classic attacks against obfuscation used in embedded malware. While some high-
proﬁle attack campaigns have already moved to stronger ciphers, such as RC4
or TEA, the convenience of simple cryptography and the risk of introducing
detectable patterns with involved approaches continues to motivate attackers to
use weak ciphers for obfuscation.
182
C. Wressnegger, F. Boldewin, and K. Rieck
7 Conclusion
Malicious documents are a popular infection vector for targeted attacks. For this
purpose, malware binaries are embedded in benign documents and executed by
exploiting vulnerabilities in the program opening them. To limit the chances
of being detected by anti-virus scanners, these embedded binaries are usually
obfuscated. In practice this obfuscation is surprisingly often realized as sim-
ple Vigen`ere cipher. In this paper, we propose Kandi, a method that exploits
well-known weaknesses of these ciphers and is capable of eﬃciently decrypting
Vigen`ere-based obfuscation. Empirically, we can demonstrate the eﬃcacy of this
approach on real malware, where our method is able to uncover the code of every
fourth malware in popular document and image formats.
While our approach targets only one of many possible obfuscation strategies,
it helps to strengthen current defenses against embedded malware. Our method
is fast enough to be applied on end hosts and thereby enables regular anti-virus
scanners to directly inspect deobfuscated code and to better identify some types
of embedded malware. Moreover, by statically exposing details of the obfusca-
tion, such as the key and the operations used, our method can also be applied
for the large-scale analysis of malicious documents and is complementary to
time-consuming dynamic approaches.
Acknowledgments. The authors would like to thank Emiliano Martinez and
Stefano Zanero for support with the acquisition of malicious documents. The
authors gratefully acknowledge funding from the German Federal Ministry of
Education and Research (BMBF) under the project PROSEC (FKZ 01BY1145).
References
1. Bencs´ath, B., P´ek, G., Felegyhazi, L.B., Duqu, M.: Analysis, detection, and lessons
learned. In: European Workshop on System Security (EUROSEC) (2012)
2. Bergen, H.A., Caelli, W.J.: File security in WordPerfect 5.0. Cryptologia 15(1),
57–66 (1991)
3. Boldewin, F.: OﬃceMalScanner, http://www.reconstructer.org/code.html
4. Calvet, J., Fernandez, J.M., Marion, J.Y.: Aligot: Cryptographic function iden-
tiﬁcation in obfuscated binary programs. In: ACM Conference on Computer and
Communications Security (CCS), pp. 169–182 (2012)
5. Cova, M., Kruegel, C., Vigna, G.: Detection and analysis of drive-by-download at-
tacks and malicious JavaScript code. In: International World Wide Web Conference
(WWW), pp. 281–290 (2010)
6. CrySyS Malware Intelligence Team: Miniduke: Indicators. Budapest University of
Technology and Economics (February 2013)
7. Dinaburg, A., Royal, P., Sharif, M., Lee, W.: Ether: Malware analysis via hardware
virtualization extensions. In: ACM Conference on Computer and Communications
Security (CCS), pp. 51–62 (2008)
8. Engelberth, M., Willems, C., Holz, T.: MalOﬃce: Detecting malicious documents
with combined static and dynamic analysis. In: Virus Bulletin Conference (2009)
9. Friedman, W.: The index of coincidence and its applications in cryptology. Tech.
rep., Riverbank Laboratories, Department of Ciphers (1922)
Deobfuscating Embedded Malware Using Probable-Plaintext Attacks
183
10. Friedman, W., Callimahos, L.: Military Cryptanalytics. Aegean Park Press (1985)
11. Jacob, G., Comparetti, P.M., Neugschwandtner, M., Kruegel, C., Vigna, G.: A
static, packer-agnostic ﬁlter to detect similar malware samples. In: Flegel, U.,
Markatos, E., Robertson, W. (eds.) DIMVA 2012. LNCS, vol. 7591, pp. 102–122.
Springer, Heidelberg (2013)
12. Kasiski, F.W.: Die Geheimschriften und die Dechiﬀrir-Kunst. E. S. Mittler und
Sohn (1863)
13. Laskov, P., ˇSrndi´c, N.: Static detection of malicious JavaScript-bearing PDF doc-
uments. In: Annual Computer Security Applications Conference (ACSAC), pp.
373–382 (2011)
14. Lewand, R.: Cryptological mathematics. Classroom Resource Materials, The Math-
ematical Association of America (2000)
15. Li, W.J., Stolfo, S., Stavrou, A., Androulaki, E., Keromytis, A.D.: A study of
malcode-bearing documents. In: H¨ammerli, B.M., Sommer, R. (eds.) DIMVA 2007.
LNCS, vol. 4579, pp. 231–250. Springer, Heidelberg (2007)
16. Malware Tracker Ltd.: Cryptam, http://www.cryptam.com (visited June 2013)
17. Martignoni, L., Christodeorescu, M., Jha, S.: OmniUnpack: Fast, generic, and safe
unpacking of malware. In: Annual Computer Security Applications Conference
(ACSAC), pp. 431–441 (2007)
18. Royal, P., Halpin, M., Dagon, D., Edmonds, R., Lee, W.: PolyUnpack: Automating
the hidden-code extraction of unpack-executing malware. In: Annual Computer
Security Applications Conference (ACSAC), pp. 289–300 (2006)
19. Schneier, B.: Applied Cryptography. John Wiley and Sons (1996)
20. Schreck, T., Berger, S., G¨obel, J.: BISSAM: Automatic vulnerability identiﬁcation
of oﬃce documents. In: Flegel, U., Markatos, E., Robertson, W. (eds.) DIMVA
2012. LNCS, vol. 7591, pp. 204–213. Springer, Heidelberg (2013)
21. Shaﬁq, M.Z., Khayam, S.A., Farooq, M.: Embedded malware detection using
markov n-grams. In: Zamboni, D. (ed.) DIMVA 2008. LNCS, vol. 5137, pp. 88–107.
Springer, Heidelberg (2008)
22. Sharif, M., Lanzi, A., Giﬃn, J., Lee, W.: Automatic reverse engineering of malware
emulators. In: IEEE Symposium on Security and Privacy, pp. 94–109 (2009)
23. Smutz, C., Stavrou, A.: Malicious PDF detection using metadata and structural
features. In: Annual Computer Security Applications Conference (ACSAC), pp.
239–248 (2012)
24. Stay, M.: ZIP attacks with reduced known plaintext. In: Matsui, M. (ed.) FSE
2001. LNCS, vol. 2355, p. 125. Springer, Heidelberg (2002)
25. Stevens, D.: Malicious PDF documents explained. IEEE Security & Privacy 9(1),
80–82 (2011)
26. Stevens, D.: XORSearch, http://blog.didierstevens.com/programs/xorsearch/
(visited June 2013)
27. Stolfo, S., Wang, K., Li, W.J.: Towards stealthy malware detection. In: Christodor-
escu, M., Jha, S., Maughan, D., Song, D., Wang, C. (eds.) Malware Detection.
Advances in Information Security, vol. 27, pp. 231–249. Springer, US (2007)
28. The Taidoor campaign: An in-depth analysis. Trend Micro Incorporated (2012)
29. ˇSrndi´c, N., Laskov, P.: Detection of malicious PDF ﬁles based on hierarchical docu-
ment structure. In: Network and Distributed System Security Symposium (NDSS)
(2013)