b. `内部随机化(Internal randomization)`:
攻击者还可以利用指令彼此的相对位置或与基地址的可预测偏移量。一些应对措施旨在使JIT代码布局多样化，包括：随机化不同指令对之间的相对偏移量[126]、[144]、[225]，以及在第一个代码单元之前随机插入空闲空间
[106]，[144]。
`当前状态`:
虽然有一些试验可以防止某些类型的漏洞(§IV-D)，但很难涵盖所有这些漏洞。因此，JS引擎中的应对措施侧重于消除攻击原语。最近，Edge团队添加了一个名为Super
Duper Secure
Mode(SDSM)[17]、[19]的新安全功能，它基本上禁用了JIT编译。用户可以选择在访问频率较低的网站上禁用JIT。虽然要牺牲一些性能，但它是减少攻击面的好方法。尽管已经引入了多种应对措施，JCRA仍然是有用的[87]、[106]，因为供应商没有投入很多资源来实施或维护应对措施。
    Lesson 4: 应对JS引擎漏洞很困难。
    JavaScript引擎漏洞，尤其是JIT编译器漏洞，非常强大，因为攻击者可以发出存在内存损坏问题的代码。因为处理逻辑漏洞通常很难，许多应对措施目的是防止利用原语升级。因此，供应商经常部署打破利用路径的缓解措施，并不断增强它们以防止未来的攻击。
### E. SOP-Bypass 和 UXSS 漏洞
同源策略(SOP)[94]由Web浏览器强制执行，以保持不同源之间的安全边界。SOP绕过漏洞可用于在不同程度上破坏SOP，从泄漏一比特到窃取整页数据。UXSS漏洞是最强大的SOP绕过漏洞类型，可用于促进跨域JavaScript代码执行。在UXSS攻击中，攻击者可以通过利用Web浏览器[13]、[14]或第三方扩展[31]、[35]中的漏洞将脚本注入任何受影响的上下文，达到与在目标网站利用XSS漏洞相同的效果。
`当前状态`:
站点隔离[39]、[186]是针对UXSS攻击的最重要的应对措施之一。站点隔离在进程级别强制执行SOP，这使得大多数现有的UXSS漏洞无法利用。2017年后逐步应用站点隔离后，报告的UXSS漏洞数量明显减少，如图6所示。但第三方扩展中的UXSS漏洞仍然存在；在流行的扩展[31]、[35]中发现了多个UXSS漏洞，这些漏洞使攻击者能够绕过站点隔离并窃取用户的凭据。
    Lession 5: UXSS漏洞主要通过站点隔离来缓解。
    站点隔离是针对UXSS漏洞的有效缓解措施。然而，只有Chrome和Firefox部署了站点隔离，因为它需要大量的工程工作（附录 D）。
### F. 总结
由于威胁研究和改进的补丁部署，1-day漏洞利用的影响减小，并且在野0-day漏洞利用一旦被捕获就会迅速修补。然而，供应商的进攻性研究仍然远远不足。尽管供应商正在努力，但他们在这场军备竞赛中始终落后。供应商的缓解措施大多是被动的，这意味着它们是在每一波攻击之后很久才行动。当攻击面最终关闭时，攻击者已经想出了更好的利用方式。这是一项艰巨的任务，但供应商应该更加主动，并在考虑安全隐患的情况下实施新功能，例如，在部署新功能之前研究潜在的新攻击。
## IV. 浏览器中的更多安全措施
在本节中，我们将介绍浏览器供应商实施的更通用的应对措施，这些措施未在前几节中介绍。我们对过去十年在四种主流浏览器中实施的应对措施以及它们的应用和停用日期进行了纵向研究，见表IV。在本节中，我们将详细讨论其中的部分。
表IV: 浏览器中的应对措施
### A. 沙箱
沙箱对浏览器安全至关重要，因为它限制了渲染器进程中漏洞的影响，其中包含各种容易出问题的组件。除了像UXSS这样的情况，攻击者需要利用内核、系统服务或浏览器进程的漏洞来逃离渲染器沙箱。因此，它显著提高了攻击的门槛，因为攻击者需要破解利用这两个组件（渲染器和沙箱）才能进行全链0-day攻击。
`Win32k锁定`: 由于大多数Windows内核漏洞都存在于Win32k系统调用中，因此Microsoft引入了系统调用禁用策略---2012年针对Windows的Win32k锁定[130]。Windows应用程序的开发人员可以完全阻止对Win32k系统调用表的访问，从而显著减少攻击面。Edge、Chrome和Firefox已经采用这种机制来保护浏览器。因此，从渲染器进程中实现沙箱逃逸变得更加复杂。
`基于Hypervisor的沙盒`: Windows
Defender应用程序防护(WDAG)[161]由微软引入，用于隔离企业场景中不受信任的网站或资源（例如文件）。WDAG使用Hyper-V在硬件层创建新的Windows实例，其中包括单独的内核副本和最低限度的Windows平台服务，以确保Edge浏览器正常运行。WDAG在Edge中实施，以防止可以绕过浏览器沙箱的高级攻击。使用WDAG，攻击者需要逃离沙盒和Hyper-V虚拟机。
### B. 强化分配器
出于性能和安全原因，浏览器对许多对象使用专门的堆分配器[96]，[150]。这些分配器使用特定的设计，通过限制攻击原语来帮助减少损害。
`堆隔离(Isolated heap)`: 堆隔离是一种有效的防御措施，可以防止UAF攻击升级为类型混淆攻击。通过基于: 1)类型;
2)安全风险级别(例如嵌入v-table指针);
3)JavaScript可达性（例如ArrayBuffer）来隔离对象，堆隔离有效地提高了UAF漏洞利用的门槛。隔离可防止攻击者使用具有不同布局的对象重新声明已释放的对象，这在浏览器UAF利用中是经典操作。
现代浏览器在JavaScript可达对象(JavaScript-reachable
objects)和其他对象之间实现了基本级别的堆分离[83]、[85]、[100]、[123]。但是，仍然有可能通过
UAF在同一堆中但其他类型的对象之间造成类型混淆。为了防止这种攻击，Safari[73]和Firefox[98]为特定类别中的每种类型引入了单独的堆，这提供了更细粒度的隔离。因此，没有公开的、通用的利用方法来利用所有浏览器中的UAF漏洞。
`延迟释放(Delayed free)`:
另一种应对措施，延迟释放，有效地增加了利用UAF漏洞的难度，但这种方法不能限制垂悬指针的回收。浏览器使用各种垃圾回收(GC)算法来释放没有引用的堆上对象。GC算法的一些变体额外扫描栈和堆[96]、[150]区域以查找可能被忽略的引用，这被称为保守扫描(conservative
scanning)[80]或延迟释放[123]。值得注意的是，Firefox放弃了这一策略，转而支持exact
rooting，并编写了一个静态分析工具来查找堆栈中引用的不安全使用[99]、[167]。Chrome也有一个类似的工具[15]，但它只在特定区域强制执行。然而，延迟释放引入了侧通道原语，可被用于击溃ASLR机制，因为它无法通过设计[41]、[81]、[104]、[123]来区分指向堆的指针和用户控制的整数。
`堆元数据保护(Heap metadata protection)`:
堆元数据保护是一种检查堆块的元数据部分以防止堆损坏和堆中的静默漏洞传播的方法。例如，堆分配器可能会在危险数据结构之前放置一个随机值[151]以检测堆漏洞。Chrome中的PartitionAlloc删除了内联元数据并放置了保护页面以防止线性堆溢出覆盖元数据[85]。在元数据保护方面也有一些操作系统级别的努力[148]、[151]。
`堆上的其他缓解措施`:Firefox 中的`Frame
poisoning`会释放地址指向不可访问内存页面的内存块[98]。类似地，在Edge中，这是通过在释放堆块时填充零来完成的[228]。Chrome中的GWP-ASan[115]在保护页面之前/之后随机放置一小部分分配的对象，并在释放块时释放整个页面以检测在野的堆错误。
### C. 控制流完整性
由于攻击者经常操纵指令指针的值来实现代码执行，因此强制控制流完整性以防止他们劫持控制流，从而使攻击更加困难。编译器基础设施、操作系统和硬件支持提供了这一类别中的大多数缓解措施，例如通过引入canary
value[165]来保护虚拟函数表，并允许通过检查目标地址来列出间接分支[159]、[177]。
正在进行的工作是防止任意内存写入修改攻击者可执行的代码区域（§III-D）。基于硬件支持，浏览器可以在不显著降低性能的情况下应用额外的应对措施，例如在ARM64
[149]上使用PAC添加指针完整性检查，还有使用Intel MPK[118]对JIT编译的代码添加额外的W ⊕ X保护和APRR[198]。
### D. 侧信道
浏览器也容易受到侧信道攻击。迄今为止的研究表明，浏览器中的敏感信息可以通过以下方式推断: 1\.
微架构状态[137]、[147]、[157]、[179]、[197]; 2\. GPU[142]、[178]; 3\. 浮点时序通道 [64]; 4\.
特定于浏览器的测信道[201]、[216]-[218]
研究人员引入了防御机制[84]、[138]、[194]、[202]来保护浏览器免受侧信道攻击，例如DeterFox[84]和FuzzyFox[138]。此外，浏览器供应商已经实施的防御[97]、[114]、[127]，可分为以下两类：
`降低定时器的分辨率`:
由于大多数攻击依赖于精确计时，为了阻碍对微小计时差异的检测，浏览器供应商降低了精确计时器的分辨率（例如，performance.now()）并引入了随机抖动来防止分辨率恢复[22],[66],[168]。在Spectre[137]和Meltdown[147]的发现之后，供应商进一步降低了计时器的精度[86]、[171]、[209]。由于SharedArrayBuffer可用于创建高分辨率计时器，因此在Spectre[137]发现后不久，SharedArrayBuffer在所有现代浏览器中都被禁用[88]。
`防止资源共享`: 另一种应对技术是防止受害者和攻击者之间的资源共享。站点隔离[39]、[186]
(§II-B)有效地处理了基于Javascript的瞬态执行。引入了Cross-Origin-Opener-Policy(COOP)和Cross-Origin-Embedder-Policy(COEP)[131]来建立跨域隔离环境。COOP允许网站在顶级document中包含响应头，确保跨域文档不与自身共享相同的浏览上下文组，从而防止直接DOM访问。COEP阻止页面加载任何未明确授予该页面权限的跨域资源。这些都是使用HTTP头强制执行的，并且它们在Chrome
83、Firefox 79和Edge 83[92]、[93]中提供，而截至2021年11月，Safari还不支持它们。
在引入站点隔离和COOP/COEP之后，Chrome和Firefox重新启用了SharedArrayBuffer[27]、[172]的使用。然而，一项研究表明，重新引入SharedArrayBuffer使隐蔽通道容量分别增加了2,000倍和800,000倍[187]。最近的两篇论文[63]、[135]表明，尽管Chrome中存在站点隔离，攻击者仍然可以获取跨域的敏感信息。
### E. 其他应对措施
`UAF缓解`:
为了从根本上解决垃圾回收或其他安全措施未涵盖的UAF问题，Chrome团队引入了一个名为`MiraclePtr`[184]、[185]的术语，它代表一组可以在C/C++中包装原始指针的算法，这样它们就不能通过UAF被利用。MiraclePtr预计将很快投入使用[79]。
`提高内存安全性`:
Chrome团队已经探索了他们的C＋＋代码库的改进，通过限制特定语言特性的使用（例如，C＋＋异常[112]）和围绕整数运算引入包装类[212]，可以消除或减少特定类型的漏洞。
`改进JIT编译器`: 已有许多努力用于保护JIT编译器内部的危险优化操作。例如，许多漏洞利用边界检查消除(bounds check
elimination)[192]来消除"看似多余"的边界检查。为了处理这种情况，Chrome团队引入了一个补丁，将此类检查标记为"中止(aborting)"，而不是简单地删除它们[133]。因此，攻击者最多只能触发一个SIGTRAP。此外，为了使标准JS函数的字节码生成更不容易出错，Chrome团队制作了一种特定领域的语言Torque[113]，它取代了现有的C++实现并减少了很多LoC。
    Lession 6：在应对方面的协作努力是有益的。
    当一个供应商部署应对措施时，其他供应商可能会效仿。在表IV中，我们看到众多应对措施已被多个浏览器采用。如果在一个浏览器中发现漏洞，供应商可以快速与其他供应商共享信息，他们可以一起使用集体知识构建更好的解决措施。在Spectre/Meltdown攻击[137]、[147]的情况下，浏览器供应商共同制定了减轻直接威胁的计划[86]、[171]、[209]，这是协作努力的一个很好的例子。
## V. 案例研究: 全链利用
由于现代浏览器具有不同的安全功能，因此浏览器利用通常需要链接多个攻击以最终执行恶意操作。结合所有这些步骤通常被称为全链利用(full-chain
exploitation)。作为全链浏览器利用的代表性案例研究，我们分析了2020年Pwn2Own竞赛中针对Safari[134]的成功攻击，即图2所示的漏洞利用示例。
这种攻击渗透到渲染器进程，从JIT编译器优化漏洞[37]开始：当满足有关代理对象的特殊条件时，Safari
JavaScript渲染器中的DFG编译器错误地模拟了"in"运算符的副作用。这个漏洞允许攻击者构建标准addrof/fakeobj原语，从而产生任意内存读/写，并最终产生任意代码执行。为了使用fakeobj构造一个有效的对象，攻击者利用一种众所周知的技术[221]绕过对象形状认证(object
shape authentication, §III-D中的结构ID随机化)。在伪造一个JavaScript对象后，他们使用已知技术[183]绕过地址空间隔离（第III-D节中的Gigacage）并在渲染器进程中获得任意读/写原语。
一旦渲染器进程受到破坏，沙盒逃逸就是下一步，并且更具挑战性。在这次攻击中，攻击者巧妙地将多个逻辑/内存漏洞拼接在一起以逃出沙盒。攻击者首先额外从CVMServer
XPC服务（内置OpenGL框架的一部分）获得任意代码执行，该服务虽然是沙盒，但具有创建符号链接的能力，而渲染器进程不具备这种能力。此外，Safari中有一个IPC方法，didFailProvisionalLoad()，如果提供了指向应用程序文件夹的符号链接，它可以启动任意应用程序。通过组合它们，攻击者可以通过Safari启动任意应用程序。至此，沙箱被成功攻破，因为他们可以在渲染器沙箱之外执行任意应用程序，类似于启动Safari的用户。
我们总结的Pwn2Own示例是具体但有影响力的。基于此，我们以更通用的方式描述全链浏览器利用。首先，要找到渲染器中的漏洞，可以利用模糊测试技术[122]、[125]、[182]或手动审核浏览器源代码。发现可利用的错误将是最具挑战性的步骤之一。发现此类漏洞后，下一步是在渲染器进程上下文中实现任意代码执行原语。然而，控制渲染器只是一个开始，因为渲染器受到沙盒机制的限制。为了突破沙盒，攻击者通常针对浏览器进程、操作系统内核或IPC协议中的缺陷。与攻击渲染器不同，沙盒逃逸通常需要针对多个系统组件链接高级逻辑漏洞。一旦沙盒逃逸，攻击者就可以执行与浏览器同等安全级别的任意程序，实现全链攻击。
## VI. 讨论
在本节中，我们将讨论与浏览器安全相关的几个方面。附录中有更多讨论。
### A. 补丁间隙问题
由于存在公共存储库和问题跟踪器，开源浏览器中的补丁可以先公开，早于新版本完成发布并提供给最终用户，从而使攻击者能够评估补丁的可利用性。例如，iOS
Safari由于1.5个月的补丁间隙而被利用[193]。为了缩小间隙，Chrome引入了每两周一次的安全更新，并将发布周期从六周缩短到四周[78]。Firefox在发布[173]、[193]之前阻止将安全修复推送到存储库，并建议不要在补丁提交中包含漏洞信息[173]。
### B. 浏览器引擎的同质性
许多"次级浏览器"使用与领先浏览器相同的浏览器引擎（例如，Chrome
V8）。因此，一个浏览器引擎中的漏洞可能会影响公用引擎的其他浏览器。在最受欢迎的15款浏览器
[206]中，有11款基于Chrome的引擎（包括Microsoft
Edge[136]），如表V所示。当新版本的Chrome发布并修复bug时，它不会立即应用于次级浏览器，次级浏览器融合它们之前存在一个时间间隔。
表V: 浏览器引擎的同质性。一些浏览器提供多个引擎以确保网页的兼容性，或顺应特定平台要求（例如iOS上的WebKit）[69]。
根据次级浏览器的发布历史，在应用发布的安全补丁之前存在时间间隔，这为攻击者提供了一个攻击窗口。例如，一个WebKit漏洞在被报告给WebKit错误跟踪器[29]数月后还可以在PlayStation固件上被利用。这也是Android中的一个问题，其中应用程序附带捆绑的渲染引擎，例如，在向Chromium[7]报告大约一个月后，三星浏览器(Samsung
Internet)[6]上报告了一个UXSS漏洞。Apple通过强制所有应用程序使用操作系统提供的WebKit库并拒绝其App
Store[69]中的不合规应用程序来解决iOS中的这个问题。