以我们称其为经典架构图。
这幅架构图里包含的三大功能块至今没变，即3D、媒体（Media）
和GPGPU。因为GPGPU部分相对独立，所以图中称其为子系统，这个
名字在后来的PRM中依然使用。子系统部分既可以直接对外提供计算服
务，也可以供媒体和3D部分使用。
图11-8 GEN GPU的经典架构图（从G965开始）
从软件接口的角度来看，命令流处理器（Command Streamer）负责
接收来自软件的命令，然后分发给内部的流水线。有一条特殊的命令，
用来选择要使用的流水线，这条命令称为PIPELINE_SELECT，其详细
定义可以在PRM文档中找到。这条命令的最低两位代表要选择的流水
线：00b代表3D，01b代表Media，10b代表GPGPU。
11.3 寄存器接口
如第8章所述，设备寄存器是CPU与显卡和GPU沟通的一种经典方
式，始于VGA时代，一直使用到今天。对英特尔集成显卡而言，虽然硬
件的“住所”几经变迁，从AGP设备到北桥，又从北桥搬迁到CPU中，但
对软件而言，访问寄存器的方式都是一样的。
11.3.1 两大类寄存器
按照访问方式，可以把显卡的寄存器分成两大类。一类是以I/O端
口方式访问的，或者说是通过x86 CPU的in/out指令来访问的。这种方式
比较陈旧，速度较慢，因此只有早期VGA标准的寄存器还使用这种方
式。另一类是内存映射方式，也叫“映射到内存空间的输入输
出”（Memory Mapped Input/Output，MMIO）。
打开设备管理器，找到显卡设备，双击打开“属性”对话框。在资源
部分，就可以观察它的输入/输出资源，以下是作者写作本书内容时所
用笔记本电脑上HD 620（Gen9.5）GPU的资源使用情况。
内存地址  0xD4000000～0xD4FFFFFF
内存地址  0xB0000000～0xBFFFFFFF
内存地址  0xA0000～0xBFFFF
I/O 端口  0x0000F000～0x0000F03F
I/O 端口  0x000003B0～0x000003BB
I/O 端口  0x000003C0～0x000003DF
上面的地址都是物理地址。前三行是MMIO空间，后三行是I/O空
间。在前三行中，第1行是处理器显卡的寄存器空间，大小为16MB。第
2行是用来与GPU交换其他数据的，CPU通过读写这个空间来访问显卡
的显存。如果显存很大，超过了这个空间的大小，那么要把需要访问的
部分映射到这个空间。形象地说，这个空间就好像一个窗口，让CPU可
以瞭望到GPU的显存空间，也有些像照相机的光圈，光圈打开，让光线
通过，便可以看到景物。同时因为这个空间是通过PCI标准来动态商定
的，所以又叫“PCI光圈”（PCI Aperture），其最大值受PCI标准的限
制。第3行是VGA标准定义的帧缓冲区（Frame Buffer）空间，其内容与
屏幕上的内容（字符或者像素）是一一对应的。DOS时代的直接写屏技
术就是直接写这段内存，根据显示模式写不同的地址区间。
11.3.2 显示功能的寄存器
显示是显卡最初的功能，已经非常成熟和稳定。显示功能主要是通
过寄存器接口来配置的。
虽然后来版本的 PRM 也用较长的篇幅介绍显示功能，但从学习的
角度来讲，经典的G965 PRM卷3是非常好的入门资料。
该卷的标题叫“显示寄存器”（Display Registers），共有6章，第1章
是简介，后面5章分门别类地描述了不同功能的显示寄存器。
本着以点带面的思想，我们选取著名的PIPEACONF寄存器来教读
者阅读PRM，理解显示寄存器的工作原理。
打开PDF格式的PRM，搜索PIPEACONF，找到该寄存器的定义页
面。寄存器的描述信息大多包含两部分，首先是概要描述，然后是位定
义表格，其中包含寄存器每一位的详细定义。比如，下面是
PIPEACONF寄存器的概要信息。
PIPEACONF—Pipe A Configuration Register
Memory Offset Address: 70008h
Default: 00000000h
Normal Access: Read/Write double buffered
第一行的前半部分是寄存器名（简称），然后是简单描述，意思是
显示通道A的配置寄存器。通道是英特尔显卡显示模块中的一个重要概
念，是Plane – Pipe – Port三级架构的中间一级。简单地说，Plane代表显
示平面，Port是显示端口，比如VGA、DVI等。平面和端口都可能是多
![H:\wxd版式-2\YDS\18-1089-陈冀康\图标3.tif{20%
个，管道的作用是把显示平面上的数据传输到显示端口，好像一个管道
一样。因为每一级都可能有多个对象，所以需要软件来做配置。上面这
个寄存器就是用来配置通道A的。
第二行是这个寄存器的偏移地址，它是相对于上面介绍的寄存器空
间基地址的偏移量。第三行是默认值。第四行是允许的访问方式，这个
寄存器可以读也可以写，而且是双重缓存的，意思是软件可以随时写这
个寄存器，写的是寄存器的一份（软）拷贝，硬件单元正在使用的是另
一份。当某一事件发生时，会把软件写的内容同步到硬件中。常见的触
发事件是VBLANK，有时也称垂直同步信号（VSync），一般在显示电
路刷新好一帧内容后产生，通知更新下一帧画面。
]
(/api/storage/getbykey/original?key=1811aa8b7b8736ac09bf) 格物致知!!} 下面通过一个试
验来深入理解这个寄存器的功能。因为这个试验有些“危险”，可能导致计算机无法显
示，所以不建议模仿。倘若打算模仿，请先通读本节以下内容并深刻理会每个步骤。
在作者写作本书时使用的一台台式机上，首先记下处理器显卡
（HD 630，与上面的笔记本所用显卡略有不同）寄存器空间的起始地址
0xF6000000，然后在本地内核调试会话中观察PIPEACONF寄存器，结
果如下。
lkd> !dd f6000000+70008 L4
#f6070008 c0000000 00000000 00000000 00000000
#f6070018 00000000 00000000 04000000 00000000
第一列是地址。第二列便是PIPEACONF寄存器的值，即
c0000000。参考PRM，第31位为1，代表该通道是启用的（Pipe A
Enable），第30位也为1，代表该通道的实际状态（Pipe State）确实是
已经启用的。
接下来，到了惊险的时刻（对于大胆的模仿者，请保存工作文件，
做好显示器无法显示而要强制重启计算机的准备）。使用!ed命令来直
接编辑物理内存，修改寄存器，禁止通道A。
!ed f6000000+70008 00000000
通过键盘输入上述命令，眨眼之间，显示器变得一团漆黑。再按什
么键，都不知道是什么结果了，因为显示器无法正常显示了。
接下来，最简单的恢复方法就是长按电源按钮重启系统了。在几年
前的软硬件环境下，屏幕暗了一会儿后，会再变亮，因为有某事件触发
显卡驱动重新启用显示管道，不知何时，那部分执行重复操作的代码被
优化掉了。
在写作本书内容的时候，作者想出了一种使屏幕重新变亮的方法。
在执行上述写0的命令前，先执行几次下面的启用命令。
!ed f6000000+70008 80000000
然后执行禁止写0的命令，待屏幕关掉后，要在黑暗中沉着冷静地
按两次向上的方向键，调出前面执行过的启用命令，然后按Enter键。这
样，屏幕便变亮了。
 老雷评点 
古有读书之乐，穿越时光，悟古人心境；今有调试之乐，电
波传语，与硅片对谈。
11.4 命令流和环形缓冲区
上一节介绍的寄存器接口具有简单直接的优点，但是也有一些局限
性，比如每次传递的数据有限。另外，每次一般只能执行一个操作，不
能成批提交任务。为了弥补这些不足，今天的GPU都支持以命令流
（Command Stream）的形式来接收任务。运行在CPU上的软件先把命令
写到命令缓冲区（Command Buffer），然后再把准备好的缓冲区提交给
GPU执行。因为GPU一般通过DMA（直接内存访问）方式读取命令
流，所以命令缓冲区一般也称为DMA缓冲区。另外，因为缓冲区里一
般包含多条命令，像批处理文件一样，所以它也称为“批缓冲
区”（Batch Buffer）。
11.4.1 命令
在经典的G965 PRM卷1中，第4章介绍了GEN GPU的命令格式。
首先，命令的长度是不固定的，但都是DWORD（双字，32位）的
整数倍。其次，命令的格式也是不固定的，但第一个DWORD总是命令
头（header）。命令头的最高3位是统一定义的，是唯一的公共字段，这
个字段的名字在G965 PRM中称为用户（client）字段，后来的手册把它
称为指令类型（instruction type）字段，本书将其称为命令类型，以便
与GEN EU的指令相区分。
命令类型字段一共有三位，最多支持8种类型（对应数字0～7）。
G965定义了4种，分别表示为0～3，其中，0代表内存接口（Memory
Interface，MI），1代表杂项，2代表2D渲染和位块操作，简称BLT，3
代表3D、媒体和GPGPU，简称GFXPIPE。在这些类型中，4～7保留未
用。
举例来说，在公开的i915驱动中，代表PIPELINE_SLECT命令的常
量是这样定义的。
#define PIPELINE_SELECT  ((0x3virtual_start =
        ioremap_wc(dev_priv->gtt.mappable_base + i915_gem_obj_ggtt_offset(
obj),
               ring->size);
其中，mappable_base是可映射到CPU端的MMIO基地址（物理地
址），obj是函数i915_gem_object_create_stolen或者
i915_gem_alloc_object创建的环形缓冲区对象。
从数据结构的角度来讲，除了用于存放命令流的线性内存区之外，
环形缓冲区还有一个描述缓冲区状态的数据结构，包括环形缓冲区的起
始地址、长度，以及当前有效部分的头尾偏移量，如图11-9所示。
图11-9 环形缓冲区示意图（来自G965 PRM 12.3.4节）
环形缓冲区结构体的具体定义大同小异，下面是Linux源代码树中
i810驱动（名字源于Gen0）的定义。
typedef struct _drm_i810_ring_buffer {
    int tail_mask;
    unsigned long Start;
    unsigned long End;
    unsigned long Size;
    u8 *virtual_start;
    int head;
    int tail;
    int space;
    drm_local_map_t map;
} drm_i810_ring_buffer_t;
其中，Start和End用于描述环形缓冲区的起始和结束位置，是相对
于MMIO空间基地址的偏移量。以下语句用于给Start字段赋值。
dev_priv->ring.Start = init->ring_start;
其中，init是初始化用的结构体指针参数。
接下来的virtual_start是映射后的虚拟地址，也就是把物理地址