**作者：蚂蚁安全非攻实验室  
公众号：[蚂蚁安全实验室](https://mp.weixin.qq.com/s/FxAKuX9IY6dLuhMuWjJMqQ)**

## 特别推荐
**诸葛建伟 清华大学网络科学与网络空间研究院副研究员**

“对非可信数据的反序列化”一直是应用安全领域中常见且高危的安全漏洞类型，在各种不同Web开发语言、分布式架构及中间件框架中广泛存在。攻击者经常利用这些漏洞进行远程代码执行（RCE）攻击，从而对业务应用造成严重威胁。尽管网络安全研究领域已对此类漏洞进行了大量研究，并发表了诸多技术文章，甚至学术界也给予了关注，但仍有新的发现不断涌现。

正如本文标题所示，蚂蚁安全实验室揭示了反序列化安全风险中的一个“隐秘角落”——Java分布式应用中广泛使用的CORBA架构。这一领域直到2019年才被公开探讨。本文采用由浅入深、案例驱动的方式，详细介绍了CORBA的基本架构及其应用细节，并从多个角度全面分析了CORBA架构面临的反序列化漏洞风险。本文的技术内容详尽且行文风格友好，对于Web安全研究人员和技术爱好者来说具有很高的参考价值，有助于理解Java CORBA架构的最新安全风险。

## 一、背景

在移动互联网时代，为了服务海量用户和支持高并发业务场景，服务端分布式架构已成为主流的应用部署方式。CORBA、JAVA RMI、DCOM等分布式技术相继诞生并得到广泛应用，其安全性也成为影响互联网生态的重要因素。以CORBA为例，目前该协议仍被许多JAVA中间件和基础设施支持，如weblogic、websphere、glassfish等。因此，研究其协议实现的安全性对于保障互联网基础设施安全具有重要意义。

在JAVA分布式架构中，大量的序列化与反序列化操作引发了人们对安全风险的担忧。然而，并非所有的反序列化框架都存在安全问题。为此，我们提出了开放动态反序列化（ODD，Open Dynamic Deserialization）的概念，以揭示真正的反序列化安全风险。ODD的核心在于“开放”和“动态”，旨在提高应用开发的灵活性和效率。但从安全角度来看，“开放”和“动态”本质上是不安全的，容易导致程序行为失控，使非安全输入能够任意劫持程序行为，从而形成集中式的RCE突破点。

虽然我们在今年的fastjson应急响应中总结并明确了ODD漏洞的本质，但这种类型的漏洞历史上已经引发了许多安全问题，对各类分布式技术和系统造成了巨大挑战。2015年，Gabriel Lawrence和Chris Frohoff在AppSecCali上发表了一份著名安全报告"Marshalling Pickles"，提出了属性导向编程（POP, Property-Oriented Programming）攻击链，利用JAVA体系中的ODD设计缺陷实现RCE，进一步扩大了ODD类型反序列化漏洞的影响范围。报告中明确警告应避免开放式反序列化，但显然业界并未充分重视这一警告，ODD安全漏洞愈发严重，尤其是针对JAVA RMI及其相关应用系统的攻击。@pwntester在2016年的Black Hat黑客大会上提出了一系列针对JAVA RMI技术的攻击方法，至今仍被各红队广泛引用。

近年来，关于CORBA安全性的公开分享并不多。直到2019年，@An Trinh在当年的Black Hat黑客大会上首次公开讨论了针对IIOP协议的反序列化攻击方法，而IIOP正是用于CORBA对象请求代理之间通信的协议。此后，RMI-IIOP相关的漏洞数量激增，2020年就有超过20个CVE编号，其中大部分都能导致RCE，例如经典的CVE-2020-4450和CVE-2020-2551。

基于此，我们的JAVA安全研究工作早已覆盖CORBA。为抛砖引玉，我们将研究过程中积累的经验和思路整理成两篇文章分享如下：

- **《隐秘的角落--JDK CORBA 安全性研究（上）》**：介绍CORBA基本架构及其实现细节，为后续安全风险分析奠定基础。
- **《隐秘的角落--JDK CORBA 安全性研究（下）》**：从客户端、服务端和通信协议三个层面全方位分析CORBA安全风险，并讨论防范措施。

## 二、基础概念

### 什么是 CORBA？

CORBA（Common Object Request Broker Architecture）是一种面向对象的RPC（Remote Procedure Call）扩展。与传统的面向过程的RPC不同，CORBA应用是面向对象的。

### 什么是RPC？

RPC（远程过程调用协议）允许程序像访问本地系统资源一样访问远端系统资源。简单来说，RPC是从一台机器（客户端）通过参数传递的方式调用另一台机器（服务器）上的函数或方法，并获取返回结果。

### CORBA 流程设计

CORBA体系结构包括以下几个主要组件：

- **IOR**（可互操作对象引用）：类似于JDBC数据库连接信息或JNDI连接信息对象，用于传输对象之间的操作信息。
- **ORB**（对象请求代理）：作为中间件，建立客户-服务器关系。ORB截获客户端的方法调用，找到服务端方法实现并传递参数，最后将执行结果返回给客户端。
- **ORBD**（ORB守护程序）：负责查找IOR指定的对象实现，并建立客户端和服务器之间的连接。
- **GIOP**（通用ORB间协议）：定义了一组标准传输语法和ORB之间通信的信息格式集。
- **IIOP**（Internet ORB间协议）：是CORBA的通信协议，用于CORBA对象之间的RPC请求交流。
- **IDL**（接口定义语言）：用来描述软件组件接口的一种规范语言，用户可以定义模块、接口、属性、方法和输入输出参数。

### 关系说明

- **CORBA与ORB的关系**：CORBA的分布式对象调用能力依赖于ORB，而ORB之间通过GIOP协议进行通信。
- **IIOP与GIOP的关系**：IIOP是GIOP的具体实现，定义了如何通过TCP/IP协议交换GIOP消息。GIOP是一个抽象协议，而IIOP是其具体实现。

## 三、环境准备

首先，尝试构建一个简单的CORBA应用。我们已经准备好了一套JDK CORBA环境，您可以直接通过git clone获取并在IDEA中打开。所有代码均在JDK 8u221环境中运行过。

## 四、IDL 简单编写以及idlj 使用

首先，编写一个简单的hello.idl文件，如下所示：

```idl
module com {
    interface Hello {
        string sayHello();
    };
};
```

然后使用JDK自带的idlj工具生成客户端和服务端代码，命令如下：

```sh
idlj -fall hello.idl
```

注：`idlj -fall hello.idl` 可以生成客户端和服务端所需的所有类。如果只需要客户端或服务端代码，可以分别使用 `-fclient` 或 `-fserver` 选项。

命令执行完成后，会在当前目录下生成 `com` 目录，包含以下六个文件：

## 五、本地尝试

为了方便观察，我们将服务端运行在本地。

首先启动ORBD服务器，运行以下命令，监听本地1050和1049端口：

```sh
orbd -port 1050 -ORBInitialPort 1049 -ORBInitialHost localhost
```

随后运行 `HelloServer` 和 `HelloClient`，效果如下：

## 六、通信过程

通过抓包分析，得出整个通信过程如下图所示：

1. 启动ORBD作为命名服务的服务器，创建命名服务。
2. CORBA服务端向ORBD获取命名服务，协商通信格式。
3. ORBD返回保存的命名服务。
4. CORBA服务端拿到命名服务后，将自己的CORBA服务绑定到命名服务上。
5. CORBA客户端向ORBD发起请求，获取命名服务。
6. ORBD返回保存的命名服务给客户端。
7. CORBA客户端利用命名服务查找到某个CORBA服务端提供的服务（客户端获得的是stub），然后发起RPC请求。
8. CORBA服务端监听到客户端请求后，执行相应操作并将结果返回给客户端。

使用Wireshark抓取通信流量，如下图所示：

## 七、客户端解析

客户端主要是通过stub远程调用服务端。stub类是客户端调用ORB的媒介，通过stub封装客户端的调用请求并发送给ORB。ORB根据服务端注册信息分派请求，服务端处理请求并将结果返回给ORB，最终由stub传递给客户端调用者。

简单流程如下：

1. 客户端发起调用 `sayHello()`。
2. stub封装客户端的调用请求并发送给ORBD。
3. ORB接收请求，根据服务端注册信息分派给服务端处理。
4. 服务端接受调用请求，执行 `sayHello` 并将结果封装后传递给ORBD。
5. ORBD收到服务端返回的结果后，将其传递给stub。
6. stub解析返回的二进制流，提取服务端的处理结果。
7. 最终结果返回给客户端调用者。

## 八、Stub的生成

stub类存在于客户端，作为服务端的句柄。生成方法有多种，列举三种如下：

1. 使用代码先获取NameServer，然后resolve_str。
2. 使用ORB.string_to_object。
3. 使用javax.naming.InitialContext.lookup。

### 1. 通过NameServer获取

... （此处继续补充详细步骤）