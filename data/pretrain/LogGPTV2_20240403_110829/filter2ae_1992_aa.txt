**作者：p0n1@安比实验室  
公众号：[安比实验室](https://mp.weixin.qq.com/s/ZmpS97QOcd7vcibBFIS7Iw "安比实验室")**
大量零知识证明项目由于错误地使用了某个 zkSNARKs 合约库，引入“输入假名 (Input Aliasing)
”漏洞，可导致伪造证明、双花、重放等攻击行为发生，且攻击成本极低。众多以太坊社区开源项目受影响，其中包括三大最常用的 zkSNARKs 零知开发库
snarkjs、ethsnarks、ZoKrates，以及近期大热的三个混币（匿名转账）应用 hopper、Heiswap、Miximus。这是一场由
Solidity 语言之父 Chris 两年前随手贴的一段代码而引发的血案。
### 双花漏洞：最初暴露的问题
semaphore 是一个使用零知识证明技术的匿名信号系统，该项目由著名开发者 barryWhiteHat 此前的混币项目演化而来。
俄罗斯开发者 poma 最先指出该项目可能存在双花漏洞[1]。
![
](https://images.seebug.org/content/images/2019/07/d9f20add-4582-4867-9fa8-fd4cc26aadcf.jpg-w331s)
问题出在第 83 行代码[2]，请仔细看。
![
](https://images.seebug.org/content/images/2019/07/f07e75d6-e6d7-4fce-913d-ea09b29af976.jpg-w331s)
该函数需要调用者构造一个零知识证明，证明自己可从合约中提走钱。为了防止“双花”发生，该函数还读取“废弃列表”，检查该证明的一个指定元素是否被标记过。如果该证明在废弃列表中，则合约判定校验不通过，调用者无法提走钱。开发者认为，这样一来相同的证明就无法被重复提交获利，认为此举可以有效防范双花或重放攻击。
然而事与愿违，这里忽视了一个致命问题。攻击者可根据已成功提交的证明，利用“输入假名”漏洞，对原输入稍加修改便能迅速“伪造证明”，顺利通过合约第 82
行的零知识证明校验，并绕过第 83 行的防双花检查。
该问题最早可追溯到 2017 年，由 Christian Reitwiessner 大神，也就是 Solidity 语言的发明者，提供的 zkSNARKs
合约密码学实现示例[3]。 **其后，几乎以太坊上所有使用 zkSNARKs 技术的合约，都照用了该实现。因此都可能遭受以下流程的攻击。**
### 混币应用：该安全问题的重灾区
零知识证明技术在以太坊上最早和最广泛的应用场景是混币合约，或匿名转账、隐私交易。由于以太坊本身不支持匿名交易，而社区对于隐私保护的呼声越来越强烈，因此涌现出不少热门项目。这里以混币合约的应用场景为例，介绍“输入假名”漏洞对零知项目的安全威胁。
混币合约或匿名转账涉及两个要点：
  1. 证明自己有一笔钱
  2. 证明这笔钱没有花过
为了方便理解，这里简单描述一下流程：
  1. A 要花一笔钱。
  2. A 要证明自己拥有这笔钱。A 出示一个 zkproof，证明自己知道一个 hash (HashA) 的 preimage，且这个 hash 在以 root 为标志的 tree 的叶子上，且证明这个 preimage 的另一种 hash 是 HashB。其中 HashA 是 witness，HashB 是 public statement。由于 A 无需暴露 HashA，所以是匿名的。
  3. 合约校验 zkproof，并检查 HashB 是否在废弃列表中。若不在，则意味着这笔钱未花过，可以花（允许 A 的此次调用）。
  4. 如果可以花，合约需要把 HashB 放入废弃列表中，标明以 HashB 为代表的钱已经被花过，不能再次花了。
上面代码中的第 82 行 `verifyProof(a, b, c, input)`用来证明这笔钱的合法性，input[]是 public
statement，即公共参数。第 83 行通过`require(nullifiers_set[input[1]] == false)`
校验这笔钱是否被花过。
**很多 zkSNARKs 合约尤其是混币合约，核心逻辑都与第 82 行和 83 行类似，因此都存在同样的安全问题，可利用“输入假名”漏洞进行攻击。**
### 漏洞解析：一笔钱如何匿名地重复花 5 次？
上面`verifyProof(a, b, c,
input)`函数的作用是根据传入的数值在椭圆曲线上进行计算校验，核心用到了名为`scalar_mul()`的函数，实现了椭圆曲线上的标量乘法[4]。
![
](https://images.seebug.org/content/images/2019/07/6a2b15d6-44e0-4427-9c56-c562c289e0f0.jpg-w331s)
我们知道以太坊内置了多个预编译合约，进行椭圆曲线上的密码学运算，降低 zkSNARKs 验证在链上的 Gas
消耗。函数`scalar_mul()`的实现则调用了以太坊预编译 7 号合约，根据 EIP 196 实现了椭圆曲线 `alt_bn128`
上的标量乘法[5]。下图为黄皮书中对该操作的定义，我们常称之为 `ECMUL` 或 `ecc_mul`。
密码学中，椭圆曲线的{x,y}的值域是一个基于 mod p 的有限域，这个有限域称之为 Zp 或 Fp。也就是说，一个椭圆曲线上的一个点{x,y}中的
x,y 是 Fp
中的值。一条椭圆曲线上的某些点构成一个较大的循环群，这些点的个数称之为群的阶，记为q。基于椭圆曲线的加密就在这个循环群中进行。如果这个循环群的阶数（q）为质数，那么加密就可以在
mod q 的有限域中进行，该有限域记作Fq。
一般选取较大的循环群作为加密计算的基础。在循环群中，任意选定一个非无穷远点作为生成元G（通常这个群的阶q是个大质数，那么任选一个非零点都是等价的），其他所有的点都可以通过
G+G+....产生出来。这个群里的元素个数为q，也即一共有q个点，那么我们可以用 0,1,2,3,....q-1 来编号每一个点。在这里第 0
个点是无穷远点，点1 就是刚才提到的那个G，也叫做基点。点2就是G+G，点3就是G+G+G。
于是当要表示一个点的时候，我们有两种方式。第一种是给出这个点的坐标 {x,y}，这里x,y属于Fp。第二种方式是用 n*G 的方式给出，由于 G
是公开的，于是只要给出 n 就行了。n 属于Fq。