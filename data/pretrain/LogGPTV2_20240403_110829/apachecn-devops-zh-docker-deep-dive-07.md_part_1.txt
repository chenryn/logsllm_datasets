## 七、容器
现在我们对映像有所了解，是时候进入容器了。由于这是一本关于 Docker 的书，我们将具体讨论 Docker 容器。然而，Docker 实现了 https://www.opencontainers.org 开放容器倡议(OCI)发布的映像和容器规范。这意味着您在这里学到的很多内容将适用于其他符合 OCI 标准的容器运行时。此外，如果你需要学习和使用 Kubernetes，你将学到的东西会对你有所帮助。
我们将把这一章分成通常的三个部分:
*   TLDR
*   深潜
*   命令
### 对接容器 tldr
容器是映像的运行时实例。就像您可以从虚拟机模板启动虚拟机一样，您可以从单个映像启动一个或多个容器。虚拟机和容器之间的最大区别是容器更快、更轻——容器与运行它们的主机共享操作系统/内核，而不是像虚拟机一样运行成熟的操作系统。容器基于极简映像也很常见，极简映像只包含应用所需的软件和依赖项。
图 7.1 显示了一个用于启动多个 Docker 容器的 Docker 映像。
![Figure 7.1](img/figure7-1.png)
Figure 7.1
启动容器最简单的方法是使用`docker container run`命令。这个命令可以有很多参数，但是最基本的形式是告诉它要使用的映像和要运行的应用:`docker container run  `。以下命令将启动一个 Ubuntu Linux 容器，运行作为其应用的 Bash shell。
`$ docker container run -it ubuntu /bin/bash`
您可以使用以下命令启动运行 PowerShell 应用的窗口容器。
`> docker container run -it mcr.microsoft.com/powershell:nanoserver pwsh.exe`
在每个例子中，`-it`标志将把你当前的终端窗口连接到容器的外壳。
容器一直运行，直到它们正在执行的应用退出。在前面的例子中，当 Bash shell 退出时，Linux 容器将退出，当 PowerShell 进程终止时，Windows 容器将退出。
演示这一点的简单方法是启动一个新的容器，并告诉它运行 sleep 命令 10 秒钟。容器将启动，抓住你的终端 10 秒钟，然后退出。下面是在 Linux Docker 主机上演示这一点的简单方法。
```
$ docker container run -it alpine:latest sleep 10 
```
 `您可以使用以下命令对 Windows 容器执行同样的操作。
```
> docker container run microsoft/powershell:nanoserver pwsh -c "Start-Sleep -s 10" 
```
 `您可以使用`docker container stop`命令手动停止正在运行的容器。然后可以用`docker container start`重启。要永久删除一个容器，你必须用`docker container rm`明确删除它。
这就是电梯推销！现在让我们进入细节…
### Docker 容器-深潜
我们将在这里讨论的第一件事是容器和虚拟机之间的基本区别。在这一点上主要是理论，但这是重要的东西。
> **平视:**作为作者，在我们进一步讨论之前，我要先说这些。我们很多人都对我们所做的事情和我们拥有的技能充满热情。你还记得*大 Unix* 们抵制 Linux 的崛起。您可能还记得早期抵制 VMware 的人。在这两种情况下**的抵抗都是徒劳的**。在本节中，我将重点介绍我认为容器模型相对于虚拟机模型的一些优势。但我猜你们中的许多人将会是虚拟机专家，在虚拟机生态系统中投入了大量资金。我也在猜测，你们中的一两个人可能会因为我说的一些话而和我争吵。所以让我说清楚…我是个大家伙，我会在肉搏战中击败你:-D 开玩笑。然而，我并不是想摧毁你的帝国或说你的宝宝丑。容器和虚拟机将在未来许多年内并行运行。
开始了。
#### 容器与虚拟机
容器和虚拟机都需要一个主机来运行。这可以是任何东西，从您的笔记本电脑、数据中心的裸机服务器，一直到公共云中的实例。事实上，许多云服务现在提供了在短暂的无服务器后端上运行容器的能力。如果这听起来像是技术胡言乱语，不要担心，这只是意味着后端高度虚拟化，主机或节点的概念不再有任何意义——您的容器只是运行，您不需要关心*如何*或*在哪里*。
总之，让我们假设一个需求，即您的企业有一台物理服务器，需要运行 4 个业务应用。
在虚拟机模型中，物理服务器通电，虚拟机管理程序启动(我们跳过了基本输入输出系统和引导加载程序代码等)。).一旦启动，虚拟机管理程序就可以控制系统上的所有物理资源，如中央处理器、内存、存储和网卡。然后，它将这些硬件资源雕刻成虚拟版本，看起来、闻起来、感觉起来都和真实的一样。然后，它将它们打包成一个称为虚拟机的软件结构。我们获取这些虚拟机，并在每个虚拟机上安装操作系统和应用。
假设单个物理服务器需要运行 4 个业务应用，我们将创建 4 个虚拟机，安装 4 个操作系统，然后安装 4 个应用。当它全部完成时，它看起来有点像图 7.2。
![Figure 7.2](img/figure7-2.png)
Figure 7.2
容器模型中的情况有点不同。
服务器已通电，操作系统启动。在 Docker 世界中，这可以是 Linux，或者支持其内核中的容器原语的现代版本的 Windows。与虚拟机模型类似，操作系统要求所有硬件资源。在操作系统之上，我们安装了一个容器引擎，比如 Docker。容器引擎然后获取**操作系统资源**，如*进程树*、*文件系统*和*网络栈*，并将它们切割成称为*容器*的独立结构。每个容器看起来、闻起来和感觉起来都像一个真正的操作系统。在每个*容器*中，我们运行一个应用。
如果我们假设单个物理服务器需要运行 4 个业务应用，我们会将操作系统分成 4 个容器，并在每个容器中运行一个应用。这如图 7.3 所示。
![Figure 7.3](img/figure7-3.png)
Figure 7.3
在高级别上，虚拟机管理程序执行**硬件虚拟化** —它们将物理硬件资源分割成称为虚拟机的虚拟版本。另一方面，容器执行**操作系统虚拟化** —它们将操作系统资源分割成称为容器的虚拟版本。
#### 虚拟机税
让我们在刚才介绍的基础上，深入探讨虚拟机管理程序模型的一个问题。
我们从一台物理服务器开始，要求运行 4 个业务应用。在这两种型号中，我们都安装了操作系统或虚拟机管理程序(一种专门针对虚拟机进行高度调整的操作系统)。到目前为止，模型几乎完全相同。但这就是相似之处。
虚拟机模型将**低级硬件资源**雕刻成虚拟机。每个虚拟机都是包含虚拟处理器、虚拟内存、虚拟磁盘等的软件结构。因此，每个虚拟机都需要自己的操作系统来声明、初始化和管理所有这些虚拟资源。可悲的是，每个操作系统都有自己的包袱和开销。例如，每个操作系统消耗一片中央处理器、一片内存、一片存储等。有些需要自己的许可证，以及人员和基础设施来修补和升级它们。每个操作系统也呈现出相当大的攻击面。我们经常把这一切称为 ***OS 税*** ，或者 ***VM 税***——你安装的每一个 OS 都会消耗资源！
容器模型有一个运行在主机上的操作系统/内核。可以在一台主机上运行几十个或几百个容器，每个容器共享同一个操作系统/内核。这意味着单个操作系统会消耗 CPU、内存和存储。需要许可的单一操作系统。需要更新和修补的单一操作系统。以及呈现攻击面的单个操作系统内核。总之，一个单一的操作系统税单！
在我们的单个服务器运行 4 个业务应用的例子中，这似乎并不多。但是当你开始谈论成百上千的应用时，它就变成了一个游戏规则的改变者。
另一个需要考虑的问题是应用的启动时间。由于容器不是成熟的操作系统，它启动的速度比虚拟机快得多。请记住，容器中没有需要定位、解压缩和初始化的内核，更不用说与普通内核引导相关的所有硬件枚举和初始化了。启动容器时，这些都不需要。运行在主机上的单个共享内核已经启动。最终结果是，容器可以在不到一秒钟的时间内启动。唯一影响容器启动时间的是启动它正在运行的应用所需的时间。
所有这些都意味着容器模型比虚拟机模型更精简、更高效。您可以将更多的应用打包到更少的资源上，更快地启动它们，并支付更少的许可和管理成本，同时减少对黑暗面的攻击。有什么不喜欢的！？
容器模型不太好的一点是安全性。与虚拟机相比，开箱即用的容器安全性较低，提供的工作负载隔离也较少。存在保护容器并将其锁定的技术，但是在撰写本文时，其中一些技术非常复杂。
抛开理论不谈，我们来玩一些容器。
#### 运行容器
按照这些例子，你需要一个工作的 Docker 主机。如果你还没有，我建议在你的 Mac 或 PC 上安装 Docker Desktop(只需谷歌“Docker Desktop”并遵循简单的下一步，下一步，下一步安装)。
我们将展示 Linux 和 Windows 容器的例子。但是，如果您在 Windows 10 上运行 Docker Desktop，您可以通过在`Linux containers`模式下运行 Docker Desktop 来跟随 Linux 示例。
#### 检查 Docker 是否正在运行
当我登录到 Docker 主机时，我总是做的第一件事是检查 Docker 是否正在运行。
```
$ docker version
Client: Docker Engine - Community
 Version:           19.03.8
 API version:       1.40
 OS/Arch:           darwin/amd64
 Experimental:      true
Server: Docker Engine - Community
 Engine:
  Version:          19.03.8
  API version:      1.40 (minimum version 1.12)
  OS/Arch:          linux/amd64
  Experimental:     true
```
 `只要你在`Client`和`Server`中得到回复，你就应该可以走了。如果您在`Server`部分得到一个错误代码，很有可能 Docker 守护程序(服务器)没有运行，或者您的用户帐户没有访问它的权限。
如果您在 Linux 机器上，并且您的用户帐户没有访问守护程序的权限，您需要确保它是本地`docker` Unix 组的成员。如果不是，你可以用`usermod -aG docker `添加它，然后你必须注销并重新登录到你的 shell 中，更改才会生效。
如果您的用户帐户已经是本地`docker`组的成员，问题可能是 Docker 守护程序没有运行。要检查 Docker 守护程序的状态，请根据 Docker 主机的操作系统运行以下命令之一。
不使用 Systemd 的 Linux 系统。
```
$ service docker status
docker start/running, process 29393 
```
 `使用 Systemd 的 Linux 系统。
```
$ systemctl is-active docker
active 
```
 `Windows 系统(从 PowerShell 终端运行)。
```
> Get-Service docker
Status    Name      DisplayName
------    ----      -----------
Running   Docker    Docker Engine 
```
 `如果 Docker 守护程序正在运行，您可以继续。
#### 启动简单的容器
如果你正在使用 Docker Desktop，你可以跟随 Linux 或 Windows 的例子。只需确保 Docker Desktop 设置为正确的模式。
启动容器最简单的方法是使用`docker container run`命令。