OCSP-stapling is another practical design for CR checking in IoT
scenarios as it does not rely on server access upon verification and
can protect user’s privacy. The major difference between TinyCR
and OCSP-stapling is that TinyCR requires the device who verifies
the other device to maintain DASS, while OCSP-stapling requires
the device who is under verification to provide the time-stamped
OCSP response extension. These OCSP-stapling devices have high
bandwidth overhead. Thus, in IoT scenarios, if the device who
needs to authenticate the other device has more memory/network
resource (for example, a smartphone is required to authenticate
a sensor), TinyCR is a better choice as it only requires the inquir-
ing device to maintain an up-to-date DASS. On the contrary, if
devices to be authenticated are more powerful (for example, a sen-
sor needs to authenticate a smartphone), then OCSP-stapling can
be used. If bi-directional authentications are necessary, we can
use a hybrid method of DASS and OCSP-stapling to optimize the
resource-security trade-off.
8 SECURITY ANALYSIS
We discuss the following attacking behaviors for TinyCR.
(1) The attacker attempts to masquerade as a legitimate IoT client
by using a revoked certificate. Since the synchronization latency of
TinyCR is only on the millisecond level plus the network latency, the
attacker has very limited time to conduct such attacks. Compared
to prior work that synchronize the devices on daily basis [19, 29],
TinyCR significantly reduces the chance of this attack. Note that it
is also important for a CA to detect a comprised certificate as early
as possible, although this topic is not the focus of this paper.
(2) The attacker performs the MitM attacks between the IDM server
and the IoT devices. The current methods are sufficient to defend
against MitM attacks between the IDM servers and the IoT devices.
Each device can get the public keys of the IDM servers and CAs
using offline methods during manufacturing or installation. With
the public keys, the device can build trusted TLS sessions to IDM
servers. Hacking an IDM server or a CA requires much more attack-
ing power than hacking a device. In this paper, we do not consider
the scenario where the IDM server is hacked.
(3) The attacker attempts to manipulate the CRL, DASS or a delta
message. Since the CA-IDM channel can use trust TLS sessions,
the integrity of the CRL can be protected. In addition, since the
DASS messages are signed by the IDM servers, the attacker cannot
manipulate the DASS installation or updating patches.
(4) The attacker wants to infer private information of other devices,
servers, or CAs from the TinyCR install and update messages. An
attacker can easily obtain the TinyCR install and update messages
by compromising just one device. However, knowing these mes-
sages give the attacker no advantage because the CR information
is public. DASS is not constructed for each particular device hence
there is no device private information in the DASS messages.
(5) The attacker can block the update messages between an IoT
device and the IDM server, then use a revoked certificate to attack
that device. TinyCR has no specific design to prevent the attacks of
blocking the communication to a device – and no other CR method
does. However, it is possible to detect such attacks. For example, the
IDM server can send heartbeat packets to the devices periodically
with the digest of the up-to-date DASS verifier and the current time.
If the device does not hear the heartbeat after a period of time, it
may detect such communication-blocking attack.
(6) A compromised IDM server sends wrong DASS information and
update messages. All DASS install and update messages can be easily
audited by another IDM server that knows all certificates and the
revoked ones. “Auditable” means any party who knows the entire
CRL can verify if another DASS version is maliciously modified.
The device can forward the DASS messages with signatures to other
IDM servers for auditing. The IDM servers can use their maintained
certificate universe and the CRL to test the integrity of the DASS.
If the DASS information is tempered, the other IDM servers can
easily find the malicious IDM server by the signature.
(7) The adversary acquires and causes a revocation with a strategy
to trigger frequent rebuilds of DASS. An attacker could learn which
certificate revocation will trigger a rebuild of DASS (by running a
simulation experiment) and then attacks that particular certificate
and causes it to be revoked by the CA. To defend against such an
attack, we can preallocate extra space in DASS to make it capa-
ble of learning more updates without rebuilding and reduce the
probability to find a certificate that triggers a rebuild. From our
analysis in Fig.14, we find this strategy is effective to defend the
attacker with limited power. For example, by doubling the size of
DASS upon initialization, it becomes more than 20 times harder to
find a certificate that will trigger a rebuild.
9 CONCLUSION
TinyCR is a new system and protocol to allow on-device CR check-
ing for IoT. We develop DASS, a compact and dynamic data struc-
ture, to maintain the CR status of the entire IoT network, which
costs each device very small memory. We also implement the two
communication components of TinyCR: the tracker that run on an
IDM server to construct and update DASS and sends the update
messages to devices, and the verifier that can synchronize with the
tracker and be queried for the CR status on IoT devices. The experi-
ments show that TinyCR costs small memory, short CR checking
time, low network bandwidth, and low synchronization latency.
10 ACKNOWLEDGMENTS
The authors were partially supported by NSF Grants 1717948, 1750704,
1932447, and 2114113. C. Qian was partially supported by the
Army Research Office and was accomplished under Grant Number
W911NF-20-1-0253. The views and conclusions contained in this
document are those of the authors and should not be interpreted as
representing the official policies, either expressed or implied, of the
Army Research Office or the U.S. Government. The U.S. Government
is authorized to reproduce and distribute reprints for Government
purposes notwithstanding any copyright notation herein. We thank
all CCS reviewers for providing the valuable comments that help
us improve the paper.
Session 4B: Wireless, Mobile, and IoT CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1130REFERENCES
[1] 2016. An Internet of Things Reference Architecture. White Paper, Symantec.
[2] 2019. Why Digital Certificates Are Essential for Managing Mobile Devices. White
Paper, DigiCert, Symantec’s Website Security business.
[3] 2020. TinyCR source code. https://github.com/jonnekaunisto/TinyCR.
[4] 2021. Censys. https://censys.io/certificates. Accessed: 2019.
[5] 2021. Google BigQuery. https://cloud.google.com/bigquery. Accessed: 2019.
[6] Arwa Alrawais, Abdulrahman Alhothaily, Xiuzhen Cheng, Chunqiang Hu, and
Jiguo Yu. 2018. Secureguard: A Certificate Validation System in Public Key
Infrastructure.
IEEE Transactions on Vehicular Technology 67, 6 (2018), 5399–
5408.
[7] Luigi Atzori, Antonio Iera, and Giacomo Morabito. 2010. The Internet of Things:
A Survey. Computer Networks 54, 15 (2010), 2787–2805.
[8] Burton H Bloom. 1970. Space/Time Trade-offs in Hash Coding With Allowable
Errors. Commun. ACM 13, 7 (1970), 422–426.
[9] Denis Charles and Kumar Chellapilla. 2008. Bloomier Filters: A Second Look. In
In Proceedings of the European Symposium on Algorithms (ESA).
[10] Bernard Chazelle, Joe Kilian, Ronitt Rubinfeld, and Ayellet Tal. 2004. The Bloomier
Filter: An Efficient Data Structure for Static Support Lookup Tables. In In Pro-
ceedings of the ACM-SIAM Symposium on Discrete Algorithms (SODA). 30–39.
[11] Donald Eastlake et al. 2011. Transport Layer Security (TLS) Extensions: Extension
Definitions. Technical Report. RFC 6066, January.
[12] Bin Fan, Dave G Andersen, Michael Kaminsky, and Michael D Mitzenmacher.
2014. Cuckoo Filter: Practically Better Than Bloom. In In Proceedings of the
10th ACM International on Conference on Emerging Networking Experiments and
Technologies (CoNEXT).
[13] Mark Goodwin. 2015. Revoking Intermediate Certificates: Introducing Onecrl.
[14] Phillip Hallam-Baker. 2015. X. 509v3 Transport Layer Security (TLS) Feature
Mozilla Security Blog (2015).
Extension. RFC 7633 (2015).
[30] John Solis and Gene Tsudik. 2006. Simple and Flexible Revocation Checking with
Privacy. In International Workshop on Privacy Enhancing Technologies. Springer,
351–367.
[31] Pawel Szalachowski, Laurent Chuat, Taeho Lee, and Adrian Perrig. 2016. RITM:
Revocation in the Middle. In 2016 IEEE 36th International Conference on Distributed
Computing Systems (ICDCS).
[32] Samuel Tanner Lindemer. 2019. Digital Certificate Revocation for the Internet of
Things. Master’s thesis. KTH Royal Institute of Technology.
[33] Yang Tong, Dongsheng Yang, Jie Jiang, Siang Gao, Bin Cui, Lei Shi, and Xiaoming
Li. 2019. Coloring Embedder: a Memory Efficient Data Structure for Answering
Multi-set Query. In In Proceedings of the IEEE 35th International Conference on
Data Engineering (ICDE). IEEE, 1142–1153.
[34] Daryl Walleck, Yingjiu Li, and Shouhuai Xu. 2008. Empirical Analysis of Certifi-
cate Revocation Lists. In In Proceedings of the IFIP Annual Conference on Data and
Applications Security and Privacy. Springer, 159–174.
[35] Minmei Wang, Chen Qian, Xin Li, and Shouqian Shi. 2019. Collaborative Valida-
tion of Public-key Certificates for IoT by Distributed Caching. In In Proceedings
of the IEEE International Conference on Computer Communications (INFOCOM).
IEEE, 847–855.
[36] Minmei Wang, Mingxun Zhou, Shouqian Shi, and Qian Chen. 2020. Vacuum
Filters: More Space-Efficient and Faster Replacement for Bloom and Cuckoo
Filters. In In Proceedings of International Conference on Very Large Databases
(PVLDB).
[37] Ye Yu, Djamal Belazzougui, Chen Qian, and Qin Zhang. 2018. Memory-
Efficient and Ultra-fast Network Lookup and Forwarding using Othello Hashing.
IEEE/ACM Transactions on Networking 26, 3 (2018), 1151–1164.
[38] Liang Zhang, David Choffnes, Dave Levin, Tudor Dumitraş, Alan Mislove, Aaron
Schulman, and Christo Wilson. 2014. Analysis of SSL Certificate Reissues and
Revocations in The Wake of Heartbleed. In In Proceedings of the Conference on
Internet Measurement Conference (IMC). 489–502.
[39] Peifang Zheng. 2003. Tradeoffs in Certificate Revocation Schemes. ACM SIG-
COMM Computer Communication Review (2003).
[40] Dong Zhou, Bin Fan, Hyeontaek Lim, David G Andersen, Michael Kaminsky,
Michael Mitzenmacher, Ren Wang, and Ajaypal Singh. 2015. Scaling Up Clustered
Network Appliances with ScaleBricks. In Proceedings of the 2015 ACM Conference
on Special Interest Group on Data Communication.
(blog) (2012).
[15] Russell Housley, Warwick Ford, William Polk, and David Solo. 1999. Internet X.
509 Public Key Infrastructure Certificate and CRL Profile. Technical Report. RFC
2459, January.
[16] Qinwen Hu, Muhammad Rizwan Asghar, and Nevil Brownlee. [n.d.]. Certifi-
cate Revocation Guard (CRG): An Efficient Mechanism for Checking Certificate
Revocation. In 2016 IEEE 41st Conference on Local Computer Networks (LCN).
[17] D. Kumar, M. Bailey, Z. Wang, M. Hyder, J. Dickinson, G. Beck, D. Adrian, J. Mason,
Z. Durumeric, and J. A. Halderman. 2018. Tracking certificate misissuance in the
wild. In In Proceedings of the IEEE Symposium on Security and Privacy (SP).
[18] Adam Langley. 2012. Revocation Checking and Chrome’s CRL. ImperialViolet
[19] James Larisch, David Choffnes, Dave Levin, Bruce M Maggs, Alan Mislove, and
Christo Wilson. 2017. CRLite: A Scalable System for Pushing All TLS Revocations
to All Browsers. In In Proceedings of the IEEE Symposium on Security and Privacy
(SP). IEEE, 539–556.
[20] Xin Li, Minmei Wang, Huazhe Wang, Ye Yu, and Chen Qian. 2019. Toward Secure
and Efficient Communication for the Internet of Things. IEEE/ACM Transactions
on Networking (2019).
[21] Yabing Liu, Will Tome, Liang Zhang, David Choffnes, Dave Levin, Bruce Maggs,
Alan Mislove, Aaron Schulman, and Christo Wilson. 2015. An End-to-end Mea-
surement of Certificate Revocation in the Web’s PKI. In In Proceedings of the
Internet Measurement Conference (IMC). ACM, 183–196.
[22] Michael Myers, Rich Ankney, Ambarish Malpani, Slava Galperin, and Carlisle
Adams. 1999. X. 509 Internet Public Key Infrastructure Online Certificate Status
Protocol-OCSP. Technical Report. RFC 2560.
[23] Alma Oracevic, Selma Dilek, and Suat Ozdemir. 2017. Security in Internet of
Things: A Survey. In In Proceedings of the International Symposium on Networks,
Computers and Communications (ISNCC). IEEE, 1–6.
[24] Rasmus Pagh and Flemming Friche Rodler. 2001. Cuckoo Hashing. In In Proceed-
ings of the European Symposium on Algorithms (ESA). Springer, 121–133.
[25] Colin Percival. 2003. Binary Diff/Patch Utility. URL: http://www. daemonology.
net/bsdiff (2003).
[26] Sanaz Rahimi Moosavi, Tuan Nguyen Gia, Amir-Mohammad Rahmani, Ethiopia
Nigussie, Seppo Virtanen, Jouni Isoaho, and Hannu Tenhunen. 2015. SEA: A
Secure And Efficient Authentication And Authorization Architecture for IoT-
based Healthcare Using Smart Gateways. In Procedia Computer Science, Vol. 52.
Elsevier, 452–459.
[27] Eric Rescorla and Nagendra Modadugu. 2012. Datagram Transport Layer Security
Version 1.2. (2012).
[28] Shouqian Shi and Chen Qian. 2020. Ludo Hashing: Compact, Fast, and Dy-
namic Key-value Lookups for Practical Network Systems. In Abstracts of the
2020 SIGMETRICS/Performance Joint International Conference on Measurement
and Modeling of Computer Systems.
[29] Trevor Smith, Luke Dickinson, and Kent Seamons. 2020. Let’s Revoke: Scalable
Global Certificate Revocation. In In Proceedings of the Network and Distributed
System Security Symposium (NDSS).
Session 4B: Wireless, Mobile, and IoT CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1131A APPENDICES
A.1 Preliminaries
A.1.1 Cuckoo Filters. Cuckoo Filter is inspired by Cuckoo Hashing
Table [24], in which a key can be stored in two candidate buck-
ets of a hash table, whose positions are calculated with two hash
functions. We take a (2, 4)-Cuckoo Filter as an example to illustrate
the algorithm. As shown in Fig 15, the Cuckoo Filter maintains
a cuckoo hashing table with two hash functions h1 (x) and h2 (x).
Each bucket of the table has four slots.
Insert(k): To insert a key k into the Cuckoo Filter, the operation
can be accomplished by inserting the fingerprint of k, i.e., f p (k),
into either one of the two candidate buckets of cuckoo hashing
table. Specifically, the two candidate positions, i.e., h1 (k) and h2 (k),
can be calculated using a single uniform hash function h (x) by:
h1 (k) = h (k) mod m,
h2 (k) = h1 (k) ⊕ (h (f p (k)) mod m) ,
(3)
where ⊕ is the bit-wise xor operation, m is the size of buckets.
Since it is easy to show h1 (k) = h2 (k) ⊕ (h (f p (k)) mod m), the
cuckoo filter can find the alternate bucket position of k by simply
calculating the xor of one bucket position and the hash of the
fingerprint, i.e.,
hj (k) = hi (k) ⊕ (h (f p (k)) mod m) , {i, j} = {1, 2} .
(4)
If either of the two candidate buckets contains an empty entry,
then the fingerprint f p (k) is safely inserted to the empty entry.
Otherwise, the insertion algorithm chooses a random entry of the
two buckets and reallocate the stored fingerprint F P′ into its alter-
nate buckets in the hashing table, then insert f p (k) to that entry.
When reallocating F P′, if the alternate bucket of F P′ is also full,
the algorithm will repeat randomly kick off another fingerprint
from the table and reallocate the other fingerprint until an empty
entry is found, or until the maximal number kicking-off operations
is reached, which implies the filter is too full to insert the new key
k and the filter should be rebuilt with extra buckets.
Query(k): To lookup whether a key k is a member, we only need
to visit the two candidate buckets of the cuckoo filter using Eq. 3. If
either of the buckets contains f p (k), then we conclude k is in the
set; otherwise it is not.
Delete(k): Similarly, the deletion of a key k from the membership
set can be accomplished by simply removing one copy of f p (k)
from the found bucket entry.
One limitation of Cuckoo Filter is that the number of buckets m
in the Cuckoo Hashing table has to be an exact power of two [36] to
support the xor operation. Hence, cuckoo filter can hardly achieve