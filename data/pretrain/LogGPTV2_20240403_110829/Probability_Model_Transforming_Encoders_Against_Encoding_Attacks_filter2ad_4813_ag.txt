2lnmax
n
∏
i=1
n
∏
i=1
1
|encode(ri|r1r2 . . .ri−1)|
1
2lP(d)(ri|r1r2 . . .ri−1)
1
P(d)(ri|r1r2 . . .ri−1)
2lnmaxP(d)(RS)
P(d)(RS)
P(d)(M) ·
P(d)(RS)
P(d)(M) ·
P(d)(RS)
P(d)(M) ·
P(d)(RS)
P(d)(M) ·
1
=
=
=
=
=
2lnmaxP(d)(M)
.
Therefore, IS-PMTE is seed-uniform.
to
the
IS-CDTEX, PrIS-CDTEX (Mi) = Pr(d)
Proof of Theorem 4. According
deﬁnition
realX (Mi) =
of
roundl(Fi) − roundl(Fi−1) and PrrealX (Mi) = Fi − Fi−1,
so that |PrIS-CDTEX (Mi) − PrrealX (Mi)| ≤ 1
2l . To summa-
rize, Advdte
IS-CDTEX ,realX (A) ≤ ∑M∈M |PrIS-CDTEX (M) −
PrrealX (M)| ≤ m
2l .
Proof of Theorem 5. PrIS-PMTE is
the discretization of
PrGPM. Similarly, discretizing the ﬁrst i levels of the generat-
ing graph (and keeping the rest levels unchanged) gets a GPM,
denoted as GPMi. Therefore, PrGPMi(r j|r1r2 . . .r j−1) =
PrGPMi−1(r j|r1r2 . . .r j−1) for
j (cid:54)= i and by Theorem 4
|PrGPMi(ri|r1r2 . . .ri−1) − PrGPMi−1(ri|r1r2 . . .ri−1)| ≤ 1
2l ,
then
GPMi,GPMi−1(A)
Advgpm
≤ ∑
M∈M |PrGPMi(M)− PrGPMi−1(M)|
(cid:12)(cid:12)∏
≤ ∑
RS∈R S |PrGPMi(RS)− PrGPMi−1(RS)|
= ∑
PrGPMi(r j|r1r2 . . .r j−1)
(r j) j∈R S
−∏
∏
PrGPMi(r j|r1r2 . . .r j−1)×
j(cid:54)=i
j
j
PrGPMi−1(r j|r1r2 . . .r j−1)
= ∑
(r j) j∈R S
|PrGPMi(ri|r1r2 . . .ri−1)−PrGPMi−1(ri|r1r2 . . .ri−1)|
≤ ∑
(r j) j∈R S
m
2l .
PrGPMi(r j|r1r2 . . .r j−1)
∏
j(cid:54)=i
1
2l
=
(cid:12)(cid:12)
Advgpm
Moreover, Advdte
Advgpm
Because PrGPM0 = PrGPM and PrGPMn = PrIS-PMTE,
GPMi,GPMi−1(A) ≤ nm
IS-PMTE,GPM(A) ≤ ∑n
2l .
IS-PMTE,GPM(A) +
GPM,real(A) ≤ Advgpm
GPM,real(A) + nm
2l .
IS-PMTE,real(A) ≤ Advgpm
i=1 Advgpm
Figure 6: Average rank vs. pseudocount for Golla et al.’s
PMTEs [14]
B The Security of Golla et al.’s PMTEs [14]
with Different Pseudocounts
We ﬁnd out that pseudocounts (smoothing parameter) of
Markov models with Laplace smoothing in Golla et al.’s
PMTEs [14] have a signiﬁcant inﬂuence on the security of
PMTEs. As shown in Figure 6 and Table 3, the average rank
r increases as pseudocount increases under both the KL di-
vergence attack and the strong encoding attacks, and mean-
while, the accuracy α decreases. This means that Golla et al.’s
PMTEs [14] achieve the best security when pseudocount is 1.
Other metrics in Table 3 also support this conclusion.
Further, when pseudocount is 1, α of the KL divergence at-
tacks are 51.74% and 46.42% on Golla et al.’s static and adap-
tive PMTEs, respectively. This means Golla et al.’s PMTEs/
GPMs almost achieve the expected security (α = 50%) under
the best-reported distribution difference attacks.
C The Complexity of IS-PMTEs and Opti-
mization for Encoding
The complexity of an IS-PMTE is of the same order as that
of the corresponding GPM. The IS-PMTE stores the CDF
table as well as the GPM stores the PDF (probability density
function) table. These two tables are of the same size, which
means the PMTE and the GPM have the same order of space
complexity. When encoding a message, the IS-PMTE needs
to obtain all generating sequences for the message and calcu-
late the probability of each sequence, which also needs to be
done when the GPM calculates the (total) probability of the
message. Moreover, encoding/decoding a sequence needs to
do binary search on CDF tables, and meanwhile, calculating
the probability of the sequence needs to do binary search on
PDF tables. Therefore, the IS-PMTE and the GPM have the
same order of time complexity (for encoding messages and
calculating message probabilities, respectively).
However, it suffers from high time complexity to obtain all
generating paths for some GPMs with great ambiguity. As
USENIX Association
28th USENIX Security Symposium    1589
KLdivergenceattack(static)KLdivergenceattack(adaptive)Strongencodingattack(static)Strongencodingattack(adaptive)10-810-710-610-510-410-310-210-110.00.10.20.30.40.5PseudocountAveragerankTable 3: Golla et al.’s PMTEs [14] with different pseudocounts
Pseudo-
count
1
10−1
10−2
10−4
10−6
10−8
1
10−1
10−2
10−4
10−6
10−8
Attack
KL diver-
gence
attack
Strong
encoding
attack
Golla et al.’s static PMTE [14]
Golla et al.’s adaptive PMTE [14]
r
F−1(1)
F(0)
0.00% 98.70% 53.58% 46.42%
0.00% 99.50% 43.42% 56.58%
2.46% 99.40% 39.55% 60.45%
α
r
α
F−1(1)
F(0)
0.00% 100.00%
48.26% 51.74%
0.00% 100.00%
37.13% 62.87%
33.59% 66.41%
2.87% 100.00%
31.11% 68.89% 11.89% 99.20% 36.71% 63.29% 11.89% 100.00%
30.11% 69.89% 14.75% 99.00% 35.91% 64.09% 14.75% 100.00%
29.42% 70.58% 17.21% 99.50% 34.62% 65.38% 16.80% 100.00%
17.22%
0.48% 99.52% 80.74% 16.12%
9.81%
0.22% 99.78% 87.30% 10.11%
7.81%
0.12% 99.88% 90.57%
9.51%
6.41%
0.12% 99.88% 92.21% 10.51%
0.11% 99.89% 91.80%
7.91%
8.41%
9.51%
8.61%
0.11% 99.89% 91.80%
0.58% 99.42% 77.87%
0.23% 99.77% 82.38%
0.14% 99.86% 90.16%
0.10% 99.90% 92.21%
0.11% 99.89% 90.98%
0.13% 99.87% 92.62%
discussed in Section 4.4, in Chatterjee et al.’s GPM [10], a
vault can be generated by numerous sub-grammars in Chat-
terjee et al.’s GPMs. In Golla et al.’s [14] GPMs, a vault can
be generated by different base passwords, different cardinali-
ties of subsets and different modiﬁed characters. Fortunately,
some generating paths can be pruned to reduce the time com-
plexity of encoding. In some models, the dependency of some
rules is ignored (by assuming the rules are independent). This
triggers some unnecessary paths which can be pruned. For
example, in Golla et al.’s GPMs [14], the modiﬁed character
bi of passwords in Vi (1 ≤ i ≤ 4) and the corresponding char-
acter ai of the base password are assumed to be independent.
In other words, the character of the base password can be
modiﬁed to itself, i.e., ai = bi. This yields signiﬁcant ambi-
guity. By prohibiting this, we can prune the branch of the
original character ai when generating the modiﬁed character
bi. More speciﬁcally, the steps of the pruned encoding are as
follows: 1) copy a CDF table and delete ai in the new table;
2) renormalize remaining characters; 3) encode bi through
the renormalized CDF table; 4) abandon the copied CDF
table (use the original table for encoding other characters).
From the view of the generating graph, the branch of ai on
the node of generating bi are pruned, resulting in a decrease
of time complexity. Besides, the following branches can also
be pruned: 1) the character of passwords in V5 which is the
same as the corresponding character of the base password; 2)
the cardinality of Vi which is larger than the number of rest
passwords. By pruning unnecessary branches on some nodes
in the generating graph, we greatly reduce the ambiguity of
Golla et al.’s GPMs [14]. For the vaults V , there are only n(cid:48)
generating paths left, where n(cid:48) is the number of unique pass-
words in V . Each path corresponds to a different password
for generating the vault as the base password.
In Chatterjee et al.’s GPM [10], some unnecessary branches
can also be pruned efﬁciently, e.g., the branches of duplicate
rules. However, the branches of unused rules are difﬁcult
to be pruned. For example, a vault V of size 2 is generated
by the sub-grammar SG = {S → D, S → W, D → 123456,
W → password}. If the ﬁrst password in V is “123456”, then
the second one must be “password” to avoid unused rules, i.e.,
the branch of the rule S → D should be pruned when gener-
ating the second password. In addition, some sub-grammars
cannot generate a vault of size 2 without unused rules, for
example, the sub-grammars consist of three rules with the
lefthand-side S. It also needs to be pruned the branches of
all these sub-grammars and renormalize the rest branches.
Therefore, in order to prune the branches of unused rules, it
is necessary to prune and renormalize branches on almost all
nodes in the generating graph. This pruning is difﬁcult be-
cause of the high time complexity, especially for the vaults of
large sizes. Another simple and straightforward method is to
add extra rules in the sub-grammar randomly when encoding.
It seems to address this problem. However, the Chatterjee et
al.’s GPM [10] with this rule-adding method resists the weak
encoding attack but still suffers from the strong encoding at-
tack unless the probability of adding extra rules is equal to the
probability of the generating path. This is because the DTE
must be seed-uniform in order to resist the strong encoding
attack. Moreover, calculating the probability of adding extra
rules has the same order of time complexity as calculating
the probability of the generating path. Therefore, if this rule-
adding method guarantees the property of seed-uniformity, it
is equivalent to our method which randomly chooses a gener-
ating path with its probability. In other words, the rule-adding
method does not perform efﬁciently in resisting the strong
encoding attack. To conclude, we state that a secure DTE of
the sub-grammar approach does have high time complexity.
To get rid of the high time complexity of encoding
sub-grammars, we propose a design principle for GPMs—
minimizing the ambiguity of the GPM—to reduce the time
complexity of encoding in the corresponding PMTEs. Instead
of optimizing the encoding algorithm after designing a GPM
with great ambiguity, it may be better to minimize the ambi-
guity when designing the GPM.
1590    28th USENIX Security Symposium
USENIX Association