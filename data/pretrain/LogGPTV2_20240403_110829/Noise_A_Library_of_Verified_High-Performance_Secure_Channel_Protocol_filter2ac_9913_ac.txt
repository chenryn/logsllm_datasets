disappears, meaning we ignore the symmetric key generation
induced by PSK patterns. Once partial evaluation is done, the
code contains only the bare minimum set of operations needed
for the ﬁrst token E of the X protocol, and all compile-time
parameters are gone.
C. Hybrid Embeddings
Looking back at §II, we can think of our earlier speciﬁcation
as an interpreter for Noise patterns; or, dually, as an evaluator
deﬁning the semantics of a deeply embedded domain-speciﬁc-
language (DSL), in our case the language of Noise patterns.
The match in the above function is a compile-time match
that operates on the deeply embedded representation of Noise
patterns, and gets partially evaluated away. We dub this style a
hybrid embedding: the code evaluated at compile-time operates
over a deep embedding (the Noise patterns), but after partial
evaluation, all that is left is a shallow embedding (the Low*
code, which executes at runtime).
The hybrid style allows us to stage and automate the
production of Low* code; rather than writing Low* code by
hand, we embed a protocol compiler that executes on F*’s
compile-time reduction facilities. This style is already useful for
send message token; but there is no reason to limit ourselves
to simple matches and ifs. We now show how to execute
arbitrary pure F* code at compile-time, including recursion,
to completely automate the production of a specialized Noise
protocol instance.
[@@ strict on arguments [5]] inline for extraction
let rec send message tokens (nc: iconﬁg) ssi initiator
is psk tokens st outlen out =
match tokens with
| [] → success
| tk :: tokens’ →
[@inline let] let tk outlen = token message vs nc ssi tk in
let tk out = sub out 0ul tk outlen in
let r1 = send message token ssi initiator is psk tk st tk out in
if is success r1 then
let outlen’ = outlen −! tk outlen in
let out’ = sub out tk outlen outlen’ in
[@inline let] let ssi’ = send token update ssi is psk tk ssi in
let r2 = send message tokens ssi’ initiator
is psk tokens’ st outlen’ out’ in
compose return type ssi is psk true tokens’ tk r2
else
compute return type ssi is psk true tk tokens’ r1
The function above now operates over a list of tokens; that is,
it generates Low* code for an entire Noise handshake message.
Naturally, the function cannot extract as-is: operating over pure,
persistent lists in low-level efﬁcient, idiomatic C is a no-go. The
goal is to ensure that the subset of send message tokens that
performs a (pure) recursion over the argument pattern (denoted
in bold) is always evaluated away at compile-time when applied
to constant arguments. To this end, we allow F* to unfold
recursive deﬁnitions (elided); to prevent inﬁnite compile-time
recursion, we restrict the unfolding to applications where the
ﬁfth argument (tokens) is concrete, via the strict on arguments
keyword. The inline let attribute indicates pure computations
to be inlined at extraction-time. (We use extraction-time
and compile-time interchangeably.) We use the keyword for
compile-time parameters or constants computed from such
parameters.
The function is veriﬁed once and for all, meaning that we
now have a veriﬁcation statement for any list of noise tokens.
At extraction-time, the user applies the function to ﬁve concrete
arguments. If pattern is [ E; ES; S; SS ], then after a few steps
of reduction, we obtain:
let r1 = send message token ... E ... in
if is success r1 then ...
let r2 = send message tokens ... [ ES; S; SS ] ... in ...
As computing E always succeeds, is success r1 reduces to true,
in turn eliminating the else branche entirely. Partial evaluation
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:36:00 UTC from IEEE Xplore.  Restrictions apply. 
113
then continues until all compile-time code has disappeared;
structural recursion over the list of tokens is over; and all that
is left is a sequence of efﬁcient Low* calls that implements
the speciﬁcation for the given list of tokens.
We use this style of hybrid embedding all throughout our
low-level protocol code implementation, which allows us
to substantially reduce the veriﬁcation effort. The following
section (§IV) shows how to extend this style to generate the
entire state machine of a Noise protocol.
D. Hybrid Type Deﬁnitions And Function Signatures
We use hybrid embeddings further to optimize internal type
deﬁnitions and user-facing functions.
For type deﬁnitions, we insist on generating C code that
contains no superﬂuous ﬁelds. This is useful not only in case
the code’s internals are audited; but also to ensure that no extra
space is consumed in e.g., the internal state of the handshake.
To that end, our types reduce at compile-time; e.g., consider:
type handshake state t nc ssi ... is psk ... = { ...
psk: if is psk then lbuﬀer ... else unit; ... }
If the chosen Noise protocol requires it, the psk ﬁeld is an
array of bytes. If the Noise protocol does not use a PSK, the
generic type reduces to unit, which is then guaranteed to be
eliminated by KReMLin [25], the Low*-to-C compiler. This
eliminates an always-NULL, superﬂuous ﬁeld.
For user-facing functions, we apply a similar design pattern
and ensure that no “dummy” arguments are ever offered in the
public API: such arguments cause user confusion, make code
reviews more difﬁcult, and generally diminish trust in our API.
Anticipating slightly, consider this initialization function that
we present as part of our user-facing API (§IV):
let session p create (idc: idconﬁg) (initiator: bool) ...
(dvp: device p idc) (peer id: opt pid t idc initiator): ST ... = ...
As mentioned in §II, we may not immediately know a peer’s
identity: whether peer id is needed at initialization-time depends
on the protocol. Rather than rely on an implicit invariant that
peer id will be ignored for some patterns, we instead rely on a
generic type opt pid t. In the case of XX, the type opt pid t
becomes unit. In the case of IKpsk2 for the initiator, the
type becomes lbuﬀer uint8. KreMLin guarantees that function
arguments of type unit are eliminated: this means we offer a
custom API for each Noise protocol. This directly supports
our goal of generating robust user-facing APIs that leave no
room for user error.
IV. A COMPLETE VERIFIED NOISE LIBRARY STACK & API
Section III describes the core handshake actions, as captured
by the Noise Protocol Framework. Yet, this forms only a small,
core part of a Noise library. We now review the remainder of
our Noise Protocol implementation and describe the many APIs
and library features we wrote in order to provide a complete,
self-contained, user-proof, veriﬁed Noise protocol stack.
A Generic State Machine. The core handshake actions
(§III) each implement a single line of a Noise Pattern. We
now tie together these individual protocol actions into two
state machines: one for the initiator and the responder. These
basic state machines are trivially induced by the steps of the
handshake: they are linear, and each valid transition advances
the initiator or responder to their next step.
The send message tokens function from §III takes many run-
time parameters; we group them in a single type deﬁnition,
dubbed state t. The state also holds the current step in the hand-
shake, i.e., the current state of the machine. Continuing with
hybrid embeddings, a generic function state t handshake write
advances the state machine, and returns a fresh state t, for any
choice of pattern, step i, or initiator vs. responder.
(* The low-level state machine type: encapsulates keypair, chaining
hash state, symmetric state, current handshake step, psk, etc. *)
val state t: isconﬁg → initiator:bool → Type0
(* Simpliﬁed signature *)
val state t handshake write (isc: isconﬁg) (ssi: static info)
(i: nat { i < isc.pattern.messages })
(payload len: size t) (payload: lbuﬀer uint8)
(st: state t isc (i%2=0) { ... })
(outlen: size t) (out: lbuﬀer uint8):
Stack (s result code (st:state t isc (i%2=0) { ... }))
The signature of the function is familiar; the earlier iconﬁg
is now wrapped in an “implementation state conﬁg” isc, which
contains the entire noise pattern, along with compile-time
parameters that determine the shape of the ﬁnal C struct
(§III-D). The function is once again written in the hybrid
embedding style; the compile-time parameter i allows the caller
to specialize the function for the i-th step of the handshake; this
in turns allows us to compute, at compile-time, whether the
message originates from the initiator (i%2=0) or the responder
(i%2=1). The compile-time parameters also determine the
nature of the return type, which is derived from the series
of return types for each token. The function returns a fresh
state st1 under the successful Res case. In a fashion similar to
send message tokens, the low-level stateful function coincides
with the outcome st1’ v of the spec-level interpreter. (Full
deﬁnitions can be found in [33].)
The parameter i represents the current step of the handshake
at compile-time; but this information is also carried at run-time
within the state st. A static precondition requires the compile-
time i to be consistent with the step stored at run-time within
st. This key technical trick enables compile-time computations
over the step i, which allows us to write a single transition
function. The function can be specialized at compile-time for
any step i; doing so produces a Low* function that can only
be called when the current run-time step coincides with the
compile-time i.
Equipped with this extremely generic function, we now
use the hybrid embedding style to generically program state
machine management: at compile-time, we generate a series
of run-time tests for each (statically-known) possible state of
the handshake; if a run-time test succeeds, the code proceeds
to execute state t handshake write, specialized at compile-time
for the speciﬁc step of the handshake. The result is a higher-
level function that can generate the state machine of either
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:36:00 UTC from IEEE Xplore.  Restrictions apply. 
114
the initiator or the responder, for any Noise pattern. We have
effectively embedded at compile-time within F* a compiler
that, from a deeply embedded Noise pattern, generates the
corresponding shallowly-embedded Low* state machine.
A User-Proof State Machine. As it stands, the state machine
cannot be exposed to the user. First, it returns a new state,
rather than modifying a heap-allocated state through a pointer;
second, it does not record stuck states, meaning that the user
can make a mistake by ignoring the Failure and calling the
function a second time.
We now transform this low-level state machine into a user-
proof one. In the process, we also enrich the API with features
for device, peer and key management. We dub this second
API layer the “device API”. We encapsulate the earlier state t
in a device state dstate t, which handles Low* region-based
memory management and ownership (elided), holds session
and peer names (provided by the user), and maintains a device
state for peer management.
[@CAbstractStruct] type dstate t idc =
| Initiator: state:state t idc.isc true → session name:name t
→ peer name: name t → device: device t → ...
→ dstate t ...
| Responder: state:state t idc.isc false → (∗ similar ∗)
type dstate p ... = B.pointer or null dstate t
Introducing dstate p, a potentially-null pointer, serves several
purposes: the C code becomes more idiomatic, now manip-
ulating a pointer to a structure instead of passing structures
by value; we can now have a NULL case which accounts
for errors, e.g., a point at inﬁnity showing up at initialization
time; and we can introduce a modicum of abstraction, by using
the CAbstractStruct keyword which instructs KreMLin to only
emit a typedef in the generated header, thus preventing clients
from directly allocating or accessing a dstate t.
Unlike state t handshake write, this state machine from the
device layer is safe to use from C. If an error happens during the
handshake, we modify the step number to a special value that
indicates that the machine is stuck, before returning an error.
Any further attempt to use this state will leave the machine in
the error (stuck) state.
Device API and Session Management.
In addition to the
state machine, the device state dstate t also encapsulates device
management. A device holds a set of peers, along with a table
that indexes them by a unique (integer) identiﬁer; it also holds
the local static identity, and provides a high-level API which
enables the user to add, lookup, update or remove peers. Each
peer contains detailed information, such as their remote static
and pre-shared keys. The library is written from scratch, since
the existing Low* libraries for e.g., linked lists were proof-
of-concept-quality and not intended to be used within a large
development. The result is a relatively simple API, wherein
the user provides a private key, an implementation-speciﬁc
prologue and a C string for the device name.
device t ∗device create(uint32 t prologue len,
peer t ∗device add peer(device t ∗dvp,
uint8 t ∗prologue, const char ∗name, uint8 t ∗spriv);
const char ∗name, uint8 t ∗rs, uint8 t ∗psk);
Given a device, the user can create a new session with a
chosen peer, in the role of either the initiator or the responder.
session t ∗create IKpsk2 initiator(device t ∗d, uint32 t peer id);
session t ∗create IKpsk2 responder(device t ∗d);
We mention at the end of §II that different Noise protocols
handle identity management very differently; and that mis-
handlings can lead to serious vulnerabilities. We rule out these
errors by construction in our API, using hybrid embeddings
(§III-D) to generically program the signature of the API
functions. For instance, IKpsk2 demands a peer identity at
initiator-creation time; this is reﬂected by the presence of the
peer id identiﬁer argument above. Conversely, for XX, both
parties learn the remote’s identity during the handshake, and
the peer id argument is absent from the C function signature.
This in turn begs the question of what should be an
acceptable policy to deal with receiving a peer’s public static
key over the network, when the key is currently unknown to the
device. The answer varies, and generally requires application-
speciﬁc error handling. For instance, in the case of WireGuard,
an unknown user simply cannot connect and the handshake is
aborted. For WhatsApp, conversely, the application registers
the peer with the device, and proceeds with the conversation.
In Noise*, we delegate these decisions to the user of
our library via a policy function and a certiﬁcation function.
The former is a constant in practice, and simply determines
whether unknown keys may be accepted. The latter receives
the decrypted payload of the message which should contain a
certiﬁcate for the key, and from it determines whether to certify
or invalidate a key. This behavior is triggered upon receiving
an S token without a corresponding entry in the peer table.
Long-Term Key Storage. To make sure our library is self-
contained and ready to be used, Noise* incorporates a veriﬁed
long-term (e.g., on-disk) key storage feature. Concretely, the
device state can be serialized and deserialized, which includes
peer list and static key. We use an AEAD construction, with the
device and peer names as authenticated data. In order to avoid
nonce reuse, each serialization generates a fresh nonce to be
fed into the AEAD construction; the nonce is stored on disk, so
that it can be reloaded at decryption-time. Our implementation
comes with proofs of correctness for the parser and serializer,
namely that they are the inverse of each other. Whether on-disk
storage is enabled is up to the user; should they enable it via
a compile-time parameter, the resulting C code will contain,
among other things, a create device from secret that takes an
encryption key, encrypted data, and returns a fresh device (or
NULL if decryption failed). We delegate the handling of the
on-disk encryption key to the user of our library.
A High-Level API with Message Encapsulation. To provide
an industrial-grade, error-proof Noise library, there remains one
last issue to address: right now, the user might inadvertently
send messages at a lower level of conﬁdentiality or authenticity
than intended. This may happen either because the user has
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:36:00 UTC from IEEE Xplore.  Restrictions apply. 
115
misunderstood the guarantees provided by a given Noise
pattern; or because they sent early data in the handshake,
before the full guarantees were established (Figure 2).
We revisit the Noise conﬁdentiality levels (Figure 2) and
expose an informative subset of them to the user: “public”
(C0), “known remote replayable” (C2), “known remote weak
forward” (C3) and “known remote strong forward” (C5). Then,
we abstract away the type of messages and impose that the
user go through a constructor and a destructor. These not only
require the user to specify a level, but also to commit to a
session and a peer, which rules out improper handling of data.
encap message t ∗pack with conf level(
uint8 t requested conf level,
const char ∗session name, const char ∗peer name,
uint32 t msg len, uint8 t ∗msg);
bool unpack message with auth level(
uint32 t ∗out msg len, uint8 t ∗∗out msg,
char ∗session name, char ∗peer name,
uint8 t requested auth level, encap message t ∗emp);
Encapsulated messages can then be sent through an API that
wraps handshake write and takes care of packing and unpacking.
When sending, we check that the session sn has reached at
least the desired conﬁdentiality level; when receiving, we check
that the requested authentication level is at most the session’s
current level. The high-level rcode captures both state machine
errors (stuck), and authenticity or conﬁdentiality errors.
rcode session write(encap message t ∗input, session t ∗sn,
rcode session read(encap message t ∗∗out, session t ∗sn,
uint32 t ∗out len, uint8 t ∗∗out);
uint32 t ∗inlen, uint8 t ∗input);
This ends our tour of our Noise protocol implementation, the
ﬁrst veriﬁed implementation for a full secure channel protocol
stack, from cryptographic primitives to its user-facing API.
V. SYMBOLIC SECURITY PROOFS FOR NOISE*
As explained in Section II, the Noise speciﬁcation [20]
describes the expected security guarantees for each Noise
protocol in terms of authentication (A0-A2) and conﬁdentiality
levels (C0-C5). Several analyses have shown that various Noise
protocols meet these guarantees against classic Dolev-Yao-style
active network adversaries [34], using symbolic analysis tools
like ProVerif [22] and Tamarin [21]. Although these analyses
provide comprehensive results for the protocol messaging code,
they do not cover important details like message formats,
protocol state machines, or key management, which are crucial
to the security of full Noise implementations. In this section,
we close this gap by proving the symbolic security of our F*
Noise speciﬁcation, relying on a framework called DY* [27].
DY* Framework. DY* is a set of F* libraries that enables
the symbolic security veriﬁcation of protocol code written in
F* [27]. In effect, we take our Noise protocol speciﬁcation from
Section II and replace all calls to concrete cryptography, random
number generation, and state storage with the symbolic libraries
provided by DY*, to obtain a symbolic security speciﬁcation in
F* that is functionally equivalent to our original speciﬁcation.
We then use the proof patterns provided by DY* to prove
that our speciﬁcation satisﬁes the security guarantees expected
by Noise. Our proofs account for an unbounded number of
protocol sessions and an active Dolev-Yao adversary [34].
DY* has previously been used to verify various protocols
(including Signal [27]) but a key novelty of our approach is
that we build a generic security proof for a Noise protocol
interpreter to obtain security guarantees for all Noise protocols
in one go. This kind of parameterized inductive proof is out of
reach of tools like ProVerif and Tamarin, which instead have
to rely on per-instance veriﬁcation of each Noise protocol [22],
[21]. The trade-off is that DY* is not as automated as these
tools, and it does not yet support the veriﬁcation of equivalence
properties, needed to state goals like identity privacy.
We refer the reader to the DY* paper [27] and public code
repository [35] for its detailed presentation. Below, we brieﬂy
discuss the main elements used in our Noise security proof.
Trace-Based Semantics. A DY* program consists of
a set of stateful protocol
functions (e.g., session create,
handshake write) that can be executed by each protocol partic-
ipant or principal (e.g., ”alice”,”bob”) to initiate or continue
any number of protocol sessions, where each session is locally
identiﬁed by an integer sid. Each principal can store session-
speciﬁc state as well as long-term state shared between sessions.
The interleaved distributed execution of protocol sessions
across multiple principals is modeled by an append-only global
trace that records every message sent between principals,
every freshly generated random value, every long-term and
session state stored by each principal, and every security event
triggered by a principal to mark the progress of a protocol
session. The index of an entry in the global trace can be
seen as a unique immutable timestamp, so we can state for
example, that an event was triggered at a particular trace index
(event at i (Send A B M)) and that this occurred before another
event (event at j (Recv B A M) ∧ i < j).
The attacker is modeled as an F* program that acts as a
global scheduler: it drives the execution of all protocol sessions
by calling protocol functions at different principals. It has
all the capabilities of an active network attacker: it can read
and write messages between any two principals in the global
trace, it can generate its own fresh random values, and it can
call cryptographic functions using values it has learned. The
attacker can also dynamically compromise any state stored at
any principal to obtain its contents. Hence, by compromising
the long-term state at a principal (indicated by the event
corrupt principal i ”alice”), the attacker can learn the principal’s
static Difﬁe-Hellman and pre-shared keys. Alternatively, by
compromising a session state corresponding to an ongoing
Noise session at a principal (corrupt session i ”alice” sid), the
attacker can learn the current handshake state, including any
private ephemeral keys. However, the attacker cannot guess
random values, or invert encryption unless it either has the key
or has explicitly compromised it. The attacker’s knowledge at
a particular timestamp in the global trace is formalized by an
inductive predicate: attacker knows at i m.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:36:00 UTC from IEEE Xplore.  Restrictions apply. 
116
Formalizing Payload Security Properties. We formalize each
of the 3 authentication levels (A0-A2) and 6 conﬁdentiality
levels (C0-C5) of Noise as trace properties, i.e., predicates
over the global trace.
Level A0 provides no guarantees. For A1, suppose that before
sending an authenticated payload, each Noise participant A
triggers an event of the form AuthSent A B M L indicating that
it is sending a message M to B at authentication level L. After
successfully processing an authenticated payload M in a session
sid, the recipient B triggers an event AuthReceived B sid A M L.
Then, the authentication goal for messages sent at Noise
authentication level A1 can be written as a trace property:
1 ∀i sid A B M. event at i (AuthReceived B sid A M 1) =⇒
2 (∃ j. j < i ∧ event at j (AuthSent A B M 1)) ∨
3 (∃ k. k < i ∧ (corrupt principal k A ∨ corrupt session k B sid ∨
4
corrupt principal k B))
This trace property says that whenever B accepts a message
M from A at time i (with authentication level A1), either this
must be an authentic message sent by A at time j < i, or else
the long-term state of A, the session state at B or the long-term
state of B must have been compromised before i.
The disjunct on line 4 indicates the possibility of a KCI
attack: i.e., the loss of message authenticity when the recipient
B’s static key is compromised. To obtain the trace property
for authentication level A2, we simply remove this disjunct
(i.e. line 4) to require the absence of KCI attacks.