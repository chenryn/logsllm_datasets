observation shows that the assumption “less than a third of
the processes can crash” is not really constraining. This
section shows that this stronger assumption allows to design
a more efﬁcient protocol, namely, a second phase made up
of a single communication step.
The assumption f > n/3 actually allows to design a
second (commit) phase made up of a single communication
step. The resulting protocol is shown in Figure 5 (where
reci is now a bag of values. A bag -or multiset- is a collec-
tion of elements in which an element may occur any ﬁnite
number of times, e.g., {a, a, b} is a bag containing twice the
element a, and once the element b). As (n − f) > n/2, let
us ﬁrst observe that, during a round r, no two processes can
decide different values at lines 4-5. Let us now consider the
case where, during a round r, a process pi decides a value v
at line 5. We conclude that at most f PHASE2 messages car-
ry a value different from v (in the worst case they carry the
same value v(cid:3)
). As any process pj that executes the second
phase receives at least (n− f) PHASE2 messages, it follows
that at least (n−f)−f of those PHASE2 messages carry the
value v. Moreover, it follows from (n − 2f) > f (assump-
tion n > 3f ) that even if the f PHASE2 messages that carry
a value different from v do carry the same v(cid:3)
, that value v(cid:3)
is carried by less than (n− 2f) messages. Hence, pj adopts
v as estimate at line 6. Consequently, as soon as a process
decides v, all estimate values are set to v: agreement can-
not be violated. The proof of the termination property is the
same as before.
Table 1 gives the number of phases (communication
steps) per round when the implementation of the function
comp est(r) is the RO (resp. LO/COND) module for each
value of r. Interestingly, the general protocol described in
Figure 1 has instantiations that include existing protocol-
s. ∀r: comp est(r)= RO gives Ben-Or’s protocol [3]. ∀r:
comp est(r)= LO gives the protocol described in [17].
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:08:23 UTC from IEEE Xplore.  Restrictions apply. 
(1)
(2)
(3)
(4)
(5)
(6)
(7)
(8)
∀j : send PHASE2(ri, esti) to pj;
wait until (PHASE2(ri, est) received from ≥ (n − f ) processes);
let reci be the bag of est values received in PHASE2(ri, est) messages;
case (∃v that appears ≥ (n − f ) times in reci)
then R Broadcast DECIDE(v);
return(v)
(∃v that appears ≥ (n − 2f ) times in reci) then esti ← v
then esti ← ⊥
other cases
endcase
Figure 5. The Second Phase when f < n/3
RO
LO
COND
f < n/2
f < n/3
2 (see [3])
3 (see [17])
1
2
3
2
Table 1. Nb of Comm. Steps per Round
7 The Case of Failure Detector Oracles
The class of failure detectors denoted ✸S is one of
the classes of failure detectors introduced by Chandra and
Toueg in [5] (where it is shown that f < n/2 is a neces-
sary requirement to solve consensus with failure detectors
of this class7). Several ✸S-based consensus protocols have
been proposed. More generally, a general framework to de-
ﬁne consensus protocols based on Chandra-Toueg’s failure
detectors is presented in [9].
A failure detector of the ✸S class is deﬁned as fol-
lows. Each process pi is provided with a set suspectedi
that contains processes suspected to have crashed. If pj ∈
suspectedi, we say “pi suspects pj”. A failure detector pro-
viding processes with such sets belongs to the class ✸S if it
satisﬁes the following properties:
• Strong Completeness: Eventually, every process
that crashes is permanently suspected by every correct
process.
• Eventual Weak Accuracy: There is a time after
which some correct process is never suspected by the
correct processes.
If the underlying system is equipped with a failure de-
tector of the class ✸S, it is possible to provide the protocol
with an additional module beneﬁting from this failure de-
tector. This module is described in Figure 6. In order to
beneﬁt from the failure detector properties, each round s-
elects a predetermined process pc that tries to impose its
estimate on all processes8. Due to the completeness prop-
erty of the failure detector, no process can deadlock in the
7As already noticed, ✸S and Ω are equivalent from a computational
power point of view [4].
8When considering the sequence of rounds, each process has to be re-
peatedly selected.
module FD ES. Moreover, due to the eventual weak accu-
racy property, the property phase 1 tries to provide (namely,
all estimates are equal) will eventually be satisﬁed. More
generally, the module FD ES satisﬁes the properties stated
in Section 4.4.
Let FD ES’ be the same module as FD ES, except for
line 405 that becomes: if PHASE1 FDO(ri, v) received then
esti ← v else esti ← ⊥ endif.
Let us now consider the generic protocol (Figure 1) in-
stantiated with ∀r: I(comp est(r)) =FD ES’. As we have
now esti ∈ {v,⊥} at the end of the ﬁrst phase of a round
(where v is the estimate of the current pc), the ﬁrst step of
the second phase of the round (lines 5-8 in Figure 1) be-
comes useless. The resulting protocol, that requires two
steps per round, is actually the ✸S-based protocol deﬁned
in [16].
This improvement has been made possible because a ✸S
failure detector allows to design a rotating coordinator-
there is an a priori agreement that dur-
based protocol:
the coordinator process is pc, with c =
ing round r,
(r mod n) + 1 (9). The rotating coordinator paradigm is as
follows (line 403, Figure 6): during round r, the round co-
ordinator feeds the other processes with its current estimate
v. This use of the round coordinator has the noteworthy
property that at the end of the ﬁrst phase of round r, any
process pi considers as its current estimate either the cur-
rent estimate v of pc or ⊥; the important point is that no
other value v(cid:3) (cid:13)= v can be considered as an estimate. This
allows to suppress the ﬁltering phase (namely, the ﬁrst step
of the second phase of the round: lines 5-8 in Figure 1).
Remark. The rotating coordinator paradigm allows to de-
sign consensus protocols that need only two communica-
tion steps per round (which has been shown to be optimal
[10]). This advantage is counterbalanced by the fact that a
decision cannot be obtained until a round whose coordina-
tor is not suspected is attained. This means that the decision
can be delayed according to the pattern of failures and erro-
neous suspicions. This is not the case when a leader oracle
is used: when all processes do propose the same value at the
9It is important to notice that the protocol described in Figure 1 does
not assume such an a priori agreement.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:08:23 UTC from IEEE Xplore.  Restrictions apply. 
FD ES
(401)
(402)
(403)
(404) wait until ( (PHASE1 FDO(ri, v) received from pc) ∨ (pc ∈ suspectedi) );
(405)
if (esti = ⊥) then esti ← vi endif;
let c = (ri mod n) + 1; % pc: process selected during that round (coordinator) %
if (i = c) then ∀j : send PHASE1 FDO(ri, esti) to pj endif;
if PHASE1 FDO(ri, v) received then esti ← v endif
Figure 6. ✸S-Based Module
beginning of a round, this value is decided by the end of the
round whatever the behavior of the leader oracle (i.e., even
if different processes have distinct leaders). This shows an
additional tradeoff relating the number of communication
steps per round and the number of rounds.
8 Conclusion
This paper has investigated a modular and versatile ap-
proach to solve the consensus problem in asynchronous dis-
tributed systems in which up to f processes may crashes
(f < n/2), but equipped with appropriate oracles. It has
presented a generic protocol that proceeds by consecutive
asynchronous rounds. Each round follows a “two-phase”
pattern. Its ﬁrst phase is a selection phase that allows to
use any combination merging random oracle, leader oracle
and condition; and its second phase aims to ensure termina-
tion while guaranteeing the agreement property cannot be
violated. The behavior of the ﬁrst phase is ruled by the sys-
tem additional equipment (oracles), while the behavior of
the second phase depends on the value of f . It follows that
the proposed protocol can be instantiated in different ways
according to the oracles the system is equipped with and the
actual value of f .
References
[1] Aguilera M.K. and Toueg S., Failure Detection and Ran-
domization: a Hybrid Approach to Solve Consensus. SIAM
Journal of Computing, 28(3):890-903, 1998.
[2] Attiya H. and Welch J., Distributed Computing: Fundamen-
tals, Simulations and Advanced Topics, McGraw–Hill, 451
pages, 1998.
[3] Ben-Or M., Another Advantage of Free Choice: Com-
pletely Asynchronous Agreement Protocols. Proc. 2nd ACM
Symposium on Principles of Distributed Computing, ACM
Press, pp. 27-30, Montr´eal, 1983.
[4] Chandra T., Hadzilacos V. and Toueg S., The Weakest Fail-
ure Detector for Solving Consensus. Journal of the ACM,
43(4):685–722, July 1996.
[5] Chandra T. and Toueg S., Unreliable Failure Detectors
the ACM,
for Reliable Distributed Systems. Journal of
43(2):225-267, 1996.
[6] Dwork C., Lynch N.A. and Stockmeyer L., Consensus in
the Presence of Partial Synchrony. Journal of the ACM,
35(2):288–323, 1988.
[7] Fischer M.J., Lynch N.A. and Paterson M.S., Impossibility
of Distributed Consensus with One Faulty Process. Journal
of the ACM, 32(2):374-382, 1985.
[8] Hadzilacos V. and Toueg S., Reliable Broadcast and Related
Problems. In Distributed Systems, ACM Press (S. Mullender
Ed.), New-York, pp. 97-145, 1993.
[9] Hurﬁn M., Mostefaoui A. and Raynal M., A Versatile Fami-
ly of Consensus Protocols Based on Chandra-Toueg’s Unre-
liable Failure Detectors. IEEE Transactions on Computers,
51(4), April 2002.
[10] Keidar I. and Rajsbaum S., On the Cost of Fault-Tolerant
Consensus When There Are No Faults - A Tutorial. SIGACT
News (Dist Comp Column), 32(2):45-63, 2001.
[11] Lamport L., The Part-Time Parliament. ACM Transactions
on Computer Systems, 16(2):133-169, 1998.
[12] Lynch N.A., Distributed Algorithms. Morgan Kaufmann
Pub., San Fransisco (CA), 872 pages, 1996.
[13] Mostefaoui A., Rajsbaum S. and Raynal M., Conditions on
Input Vectors for Consensus Solvability in Asynchronous
Distributed Systems. Proc. 33rd ACM Symposium on The-
ory of Computing, pp. 153-162, July 2001.
[14] Mostefaoui A., Rajsbaum S., Raynal M. and Roy M., A Hi-
erarchy of Conditions for Consensus Solvability. Proc. 20th
ACM Symposium on Principles of Distributed Computing,
pp. 151-160, Newport (RI), 2001.
[15] Mostefaoui A., Rajsbaum S., Raynal M. and Roy M., Ef-
ﬁcient Condition-Based Consensus. 8th Int. Colloquium
on Structural Information and Communication Complexity
(SIROCCO’01), Carleton Univ. Press, pp. 275-293, Val de
N`uria, Catalonia (Spain), June 2001.
[16] Mostefaoui A. and Raynal M., Solving Consensus Using
Chandra-Toueg’s Unreliable Failure Detectors: a General
Quorum-Based Approach. 13th Symp. on DIStributed Com-
puting, LNCS #1693, pp. 49-63, 1999.
[17] Mostefaoui A. and Raynal M., Leader-Based Consensus.
Parallel Processing Letters, 11(1):95-107, 2001.
[18] Mostefaoui A., Raynal M. and Tronel F., From Bina-
ry Consensus to Multivalued Consensus in Asynchronous
Message-Passing Systems. IPL, 73:207-213, 2000.
[19] Mostefaoui A., Raynal M. and Tronel F., The Best of Both
Worlds: a Hybrid Approach to Solve Consensus. Proc. D-
SN’00, pp. 513-522, June 2000.
[20] Rodrigues L. and Ver`ıssimo P., Topology-Aware Algorithms
for Large Scale Communication. Advances in Dist. Systems,
LNCS #1752, pp.1217-1256, 2000.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:08:23 UTC from IEEE Xplore.  Restrictions apply.