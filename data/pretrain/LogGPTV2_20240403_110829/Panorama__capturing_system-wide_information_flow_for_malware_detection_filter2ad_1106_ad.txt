∃v ∈ g.V, v.type = module)
→ V iolate(v, “No Excessive Access
(cid:2)(cid:2)
)
(3)
In addition to manually specifying the policies, it is pos-
sible to automatically generate policies by using machine
learning techniques. First, we can gather a representative
collection of malware and benign samples as our training
set. Using this training set, Panorama will extract the cor-
responding taint graphs. Then, we need to develop a mecha-
nism to transform a taint graph into a feature vector. Based
on the feature vectors for the benign and malicious samples,
standard classiﬁcation algorithms can be applied to deter-
mine a model. Using this model, novel samples can then
be classiﬁed. We will further explore this approach in our
future work.
4.2 Taint-Graph-Based Malware Analysis
Given a taint graph, the ﬁrst step is to check this graph
for the presence of a node that corresponds to the sample
under analysis. If such a node is present, we obtain the in-
formation that the sample has accessed certain tainted input
data. This is already suspicious, because the test cases are
designed such that input data is sent to trusted applications,
but never to the sample under analysis. Once we determine
that a sample has accessed certain input, the sample’s suc-
cessor nodes in the graph can be examined. This indicates
what has been done with the data that was captured. Such
insights can be instrumental for system administrators and
analysts to understand the behavior and actions of malware.
As an example, recall the taint graph previously shown in
Figure 2. This taint graph has been produced by automati-
cally analyzing the behavior of the password thief program
GINA spy [16]. Note that the entered password is received
by the Windows Logon process (Winlogon.exe). This pro-
cess passes the password on to lsass.exe for subsequent
authentication. Interestingly, the password data is also ac-
cessed by the sample under analysis (mscad.dll), which is
loaded by Winlogon.exe. This code module reads the pass-
word and saves it to a ﬁle called c:\ginalog.log. The
graph correctly reﬂects how the user password is processed
by Windows, and how the password thief intercepts it. In
Category
Keyloggers
Password thieves
Network sniﬀers
Stealth backdoors
Spyware/adware
Rootkits
Browser plugins
Multi-media
Security
System utilities
Oﬃce productivity
Games
Others
Sum
Total FNs FPs
5
2
2
3
22
8
16
9
10
9
4
4
4
98
0
0
0
0
0
0
-
-
-
-
-
-
-
0
-
-
-
-
-
-
1
0
2
0
0
0
0
3
Table 2: Summary of detection results against mal-
ware and benign samples.
Section 5.2, we discuss a more complex real-world example
that we investigated during our experiments.
5. EVALUATION
In this section, we present details on the experimental
evaluation of our Panorama system. Our evaluation con-
sisted of three parts. First, we investigated the eﬀective-
ness of our taint-graph-based malware detection approach
using a large body of real-world malware and benign sam-
ples. Then, by using Google Desktop as a case study (i.e., a
sample from a vendor whose privacy policy we believed we
could trust), we explored the amount of detailed information
that we could extract from the taint graph of an unknown
sample. Third, we performed tests to evaluate the perfor-
mance overhead of our prototype. In all our experiments, we
ran Panorama on a Linux machine with a dual-core 3.2 GHz
Pentium 4 CPU and 2GB RAM. On top of Panorama, we
installed Windows XP Professional with 512M of allocated
RAM.
5.1 Malware Detection
Our malware collection consisted of 42 real-world malware
samples, including 5 keyloggers, 2 password thieves, 2 net-
work sniﬀer, 3 stealth backdoors, and 22 spyware BHOs, and
8 rootkits. Some of these samples were publicly available on
the Internet (e.g., from web sites such as www.rootkit.com),
while others were collected from academic researchers and
an Austrian anti-virus company. Furthermore, we down-
loaded 56 benign, freely-available samples from a reputable
and trustworthy web site (www.download.com). These be-
nign samples were freeware programs from a wide range of
diﬀerent application domains (such as browser plug-ins, sys-
tem utilities, and oﬃce productivity applications), with the
size up to 3MB.
To further facilitate the experiments, we developed a tool
using Python to run the samples and automatically perform
the installation procedure (if required) using several heuris-
tics. The tool can handle 70% of the samples in our test set.
For the remaining samples, some required manual conﬁgu-
ration (they were all malware samples), and the others were
not properly handled by the heuristics. We then manually
installed the remaining samples. We installed up to 3 sam-
ples each time. After that, we ran the test cases. We set
the test engine to wait for 5 minutes before shutting down
the guest machine. Depending on the installation delay, the
whole procedure lasts 15 to 25 minutes.
Table 2 summarizes the results of this experiment. We
can see that Panorama was able to correctly identify all
malware samples, but falsely declared three benign samples
to be malicious.
Two of these false positives were personal ﬁrewall pro-
grams. The third false positive was a browser accelerator.
By checking the taint graphs related to these three sam-
ples, we observed that the information access and processing
behaviors of these benign samples closely resemble that of
malware. In fact, the two personal ﬁrewalls install packet
ﬁlters and monitor all network traﬃc. Hence, their behav-
ior resembles that of a malicious network sniﬀer.
In the
case of the browser accelerator, we observed that the appli-
cation prefetches web pages on behalf of the browser and
stores them into its own cache ﬁles. This behavior resem-
bles that of spyware that monitors the web pages that a
user is surﬁng. The reason for our false positives is that
our taint-graph-based detection approach can only identify
the information access and processing behavior of a given
sample, but not its intent. In real-life, the taint graphs are
invaluable for human analysts, as they help them to quickly
determine and understand whether an unknown sample is
indeed malicious, or whether it is benign software that is
exhibiting malware-like behavior.
5.2 Malware Analysis
In order to determine how well we are able to perform
detailed analysis on an unknown sample, we chose Google
Desktop for a case study. This application claims in its
privacy policy [19] that it will index and store data ﬁles,
mail, chat logs, and the web history of a user while the
user is working on her system. Furthermore, if the special
conﬁguration setting “Search Across Computers” is enabled,
Google Desktop will securely transmit copies of the user’s
index ﬁles to Google servers. Hence, Google Desktop, in
fact, exhibits some malware-like behavior, as the index ﬁles
may contain sensitive information about a user (e.g., a list
of web sites that the user has visited), and these ﬁles are
sent to an external server.
First, we downloaded the installation ﬁle (GoogleDesk-
topSetup.exe). Before installing the tool, we marked the
installation ﬁle such that we could track which components
would be installed into the system. After the installation
was complete, we observed that 18 executables and shared
libraries, as well as a dozen data ﬁles were installed.
Second, we ran the test cases, using the default settings
of Google Desktop (in which “Search Across Computers”
is disabled). After performing the test cases, we observed
that some components extracted from the installation ﬁle
accessed the tainted inputs, including HTTPS, HTTP and
document. All of this information was later saved into the
index ﬁles in the local installation directory. To determine
if the information is sent out to remote hosts, we kept the
system alive for 12 hours. However, we did not observe this
behavior.
Third, we changed the settings of Google Desktop and en-
abled the feature “Search Across Computers”. Then, we ran
the test cases again and kept the system alive for another
30 minutes. It was evident from the generated taint graphs
that, in this mode, Google Desktop did leak the collected
information via HTTPS connections to Google servers. We
picked a representative taint graph, which clearly illustrates
how the components of Google Desktop process the incom-
ing traﬃc of an HTTP connection from the QEMU web site
we visited, (see Figure 3).
By examining this taint graph, we can draw several con-
clusions: (1) the incoming web page was ﬁrst received and
processed by the Internet Explorer (IEXPLORE.EXE), which
later saved the content into a cache ﬁle (qemu[1].htm) un-
der the temporary Internet ﬁle folder; (2) a component from
Google Desktop (GoogleDesktopAPI2.dll) was loaded into
the IEXPLORE.EXE, obtained the web page, and passed it
over to a stand-alone program also from Google Desktop
(GoogleDesktopIndex.exe); (3) GoogleDesktopIndex.exe
further processed this information and saved it into two data
ﬁles (rpm1m.cf1 and fiih.ht1) in its local installation di-
rectory; and (4) it sent some information derived from the
web page to a remote Google server (72.14.219.147) through
an HTTPS connection.
With the capability provided by Panorama, we could con-
ﬁrm that Google Desktop really sends some sensitive infor-
mation if a special feature is activated (as it also claims in
its privacy policy).
5.3 Performance Overhead
We measured Panorama’s performance overhead using sev-
eral utilities in Cygwin, such as curl, scp, gzip, and bzip2.
When running these tools, we tainted ﬁle and network in-
puts accordingly. We found that the current unoptimized
implementation of Panorama suﬀers a slowdown of 20 times
on average. Since Panorama aims to support oﬀ-line mal-
ware detection and analysis, we believe that this overhead
is not a severe limitation for our intended application sce-
narios. When one considers that unknown malware samples
are currently mostly analyzed manually, it is clear that an
automated system such as Panorama signiﬁcantly simpliﬁes
and speeds up this task. Also, note that some research has
been done to explore more eﬃcient means for dynamic taint
analysis. Ho et. al. proposed Demand Emulation, in which
a running system dynamically switches between virtualized
and emulated execution, and emulation is only used when
tainted data is being processed by the CPU [20]. Explor-
ing ﬁner-grained hardware protection provided by ECC may
further improve the performance signiﬁcantly [30]. Recently,
Qin et. al. explored several optimizations on dynamic binary
instrumentation to minimize the run-time overhead [31].
6. DISCUSSION
In this section, we discuss several potential evasion tech-
niques that malware writers may attempt to use in order to
thwart the current implementation of Panorama. Further-
more, we discuss the countermeasures that we can employ.
Breaking the propagation of taint information.
As mentioned in Section 3.1, a malware author can at-
tempt to design his code such that the taint engine fails to
properly keep track of tainted information. For example, by
exploiting indirect dependencies (dependencies encoded us-
ing control ﬂow decisions), a malicious program could con-
ceal the fact that sensitive information is leaked. This is
a limitation of our current implementation. We will en-
hance the implementation to keep track of taint propaga-
tion via control ﬂow in the future, as in our earlier imple-
[tcp]212.27.63.117:80:1047
IEXPLORE.EXE
explorer.exe
IEXPLORE.EXE!GoogleDesktopAPI2.dll
GoogleDesktopCrawl.exe!GoogleDesktopCrawl.exe
c:\$LogFile
%TEMP%\Content.IE5\0JBRMNI7\qemu[1].htm
GoogleDesktopIndex.exe!GoogleDesktopAPI2.dll
GoogleDesktopIndex.exe!GoogleDesktopIndex.exe
GoogleDesktopIndex.exe!gzlib.dll
GoogleDesktopIndex.exe!GoogleDesktopSSD.dll
%INST_DIR%\577eef2d8a09\rpm1m.cf1
%INST_DIR%\577eef2d8a09\fiih.ht1
[tcp]72.14.219.147:1068:443
Figure 3: A taint graph that presents how Google Desktop handles incoming web pages. Here, %INST DIR%
represents “c:\Program Files\Google\Google Desktop Search”, and %TEMP% is “c:\Documents and
Settings\user\Local Settings\Temporary Internet Files”.
mentation [14]. Moreover, it is important to note that the
current system observes all instances in which the sample
under analysis accesses tainted data. That is, a malware
sample can only hide the fact that it leaks information (as
well as the operating system resources that this information