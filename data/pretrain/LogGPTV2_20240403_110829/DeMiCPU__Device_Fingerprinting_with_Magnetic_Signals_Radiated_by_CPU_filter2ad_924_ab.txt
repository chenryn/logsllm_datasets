whether the CPU module emits the strongest MI signals among
all components, we execute a while(1) loop (in C++) to generate
a CPU utilization of 100%, and measure the MI signal strength by
placing the sensor on various spots (33 spots in total) of a Lenovo
ThinkPad T440p laptop’s surface (device No. 31 in Tab. 3). We plot
the heatmap of the MI signals measured across the laptop’s surface
in Fig. 3(a), from which we can find that the strongest MI signals are
observed at “S” and “D” keys. Dismantling the laptop reveals that
two inductors of the DC/DC converter that powers the CPU chip
are located right below these two keys, as shown in Fig. 3(b). This
indicates that the CPU module, specifically the DC/DC converter,
produces the strongest MI signals when the CPU is under a high
load.
Does the CPU load affect the MI Signals? To understand
whether the variation of the CPU load affects MI signals emitted
from the CPU module, we force the CPU to work in a duty-cycle
mode at a frequency of 5 Hz, i.e., alternating between a 100% uti-
lization and an idle mode at an interval of 100 ms. Throughout the
experiments, the sensor was placed above the CPU module, i.e., on
S and D keys, to measure the emitted MI signals. The results shown
in Fig. 4 confirm that the CPU load does affect the MI signals. Thus,
it is important to create a consistent software stimulation to ensure
the same CPU load such that the fingerprints generated from the
CPU module are consistent for the same device.
Do other components affect the MI Signals? Modifying the
status of other computer components may lead to variation of the
MI signals. However, MI signals generated by others attenuate
rapidly with distance due to the near field effect. We observe no
noticeable difference between the MI signals collected right above
the CPU module when the fan was turned on and off. As a re-
sult, DeMiCPU does not control other components during device
fingerprinting.
e
d
u
t
i
l
p
m
A
6000
4500
3000
1500
0
100
T440p-1
T440p-2
XPS13
R720
XPS14
101
103
102
Frequency(Hz)
104
105
Figure 8: Histograms of MI signals from 5 laptops. Even for
the two laptops of the same model, i.e., T440p-1 and T440p-2,
the MI signals show discrepancies.
3.2 Evidence of CPU Fingerprint
To explore the existence of CPU fingerprint, we conduct an ex-
periment with 5 laptops, which are two Lenovo ThinkPad T440p
(T440p-1 and T440p-2, for short), Dell XPS 13, Lenovo R720, and
Dell XPS 14. Detailed specifications of these laptops (Device No. 31,
No. 32, No. 61, No. 49 and No. 62) are summarized in Tab. 3, among
which two laptops (T440p-1 and T440p-2) are from the same model
and installed with the same operating system and the rest are of
different models.
We execute the while(1) program to keep the CPU at a 100%
utilization and measure MI signals above the CPU module of each
laptop. We then perform Fast Fourier Transform (FFT) on the col-
lected MI signals and plot their one-dimensional histograms in
Fig. 8, with a logarithmic bin size of 100.1. The histogram repre-
sents the frequency distribution of the MI signals, from which we
can observe distinct “patterns” for the 5 laptops in the frequency
range from 20 Hz to 10 kHz. Especially, laptops of different models
show more discrepancies compared with those of the same model.
Nevertheless, the two T440p laptops remain distinguishable even
only with one histogram feature.
The above findings shed light on the existence of CPU finger-
prints. However, to make the fingerprint robust and accurate, es-
pecially for devices from the same model, more features in both
time and frequency domains should be investigated to enhance the
fingerprint.
3.3 What Contributes to CPU Fingerprint?
To understand whether the fingerprint is created by the CPU chip,
the DC/DC converter, or the combination of both, we exchange
the CPUs of the two T440p laptops and obtain two “new” laptops
(T440p-1 with CPU from T440p-2 and T440p-2 with CPU from
T440p-1). Similar to previous experiments, the CPU utilization is
set to 100% during collection and MI signals are measured above the
CPU module before and after swapping the CPUs. The results in
Fig. 5 show that MI signals for four configurations are all different,
which indicates that the fingerprint originates from the combination
of the CPU chip and its affiliated DC/DC converter, i.e., the CPU
module.
3.4 Temporal and Spatial Consistency
The MI signal from a device should be consistent across time and
space to serve as a robust fingerprint. To investigate the temporal
consistency, we collect 30 MI signals from the T440p-1 laptop at 5
time instants across two days, i.e., the first three instants are within
one day (morning, afternoon and evening) and the other two are
in the next day (morning and evening). The T440p-1 laptop is set
to 100% utilization and one-second MI signals are collected each
time. The results depicted in Fig. 6 indicate that MI signals remain
consistent regardless of time.
To investigate the spatial consistency, we collect 30 MI signals
from the T440p-1 laptop at 3 locations (one in a lab, two at home;
and the two places are about 3 kilometers apart). Note that we
do not intentionally avoid or remove metal and magnetic materi-
als around the collecting device during experiments. As a result,
due to the impact of the earth’s magnetic field and ambient noise
(especially in the lab, with numerous electronic devices surround-
ing), the initial magnetic magnitude of the sensor is geo-spatial
dependent. However, the strength of the earth’s magnetic field and
ambient noise is relatively static at a specific spot and thus mainly
contributes to the constant part of the collected MI signals. As a
result, the FFT operation shall have eliminated the impact of the
earth’s magnetic field as well as the ambient noise. The results in
Fig. 7 also validate that the frequency-domain MI signals remain
consistent regardless of locations.
All these experiments provide strong evidence that CPU modules
can produce strong MI signals that maintain good distinguishability
and consistency, and the MI signals from CPU modules serve as
promising device fingerprints.
4 THREAT MODEL
In this paper, we have the following assumptions.
Impersonation. Although it is feasible for attackers to launch
a Denial-of-Service (DoS) attack by emitting EMI or even placing a
strong magnet close to the DeMiCPU sensor, the goal of the attackers
is to impersonate a legitimate device. Thus, we focus on replay or
mimic attacks.
Preamble
(cid:41)(cid:76)(cid:81)(cid:74)(cid:72)(cid:85)(cid:83)(cid:85)(cid:76)(cid:81)(cid:87)(cid:76)(cid:81)(cid:74)
15
0
−15
)
T
u
(
B
−30
0
0.1
0.2
0.3
t(s)
0.4
0.5
0.6
Figure 9: Structure of the MI signal, including a 0.1 s pream-
ble and a 0.5 s fingerprinting sample.
Acquisition of Similar Device. We assume the adversary can
obtain similar devices as the target one, e.g., a device of the same
model, to imitate the target device and have full control of them.
Secure Communication. We assume that the communication
between the DeMiCPU sensor and the DeMiCPU server and between
the server and the software (application) is secure. For instance,
DeMiCPU can package the MI measurements or matching results
with encryption, by the well-known secure communication pro-
tocols [3, 31, 32]. As a result, the attacker cannot create forged
measurements or modify the measurements/matching results.
5 DESIGN
In this section, we describe the 3 sub-modules of the overall DeMiCPU
system: (1) Fingerprint generation; (2) Fingerprint extraction; (3)
Fingerprint matching.
5.1 DeMiCPU Fingerprint Generation
To obtain MI measurements that produce consistent fingerprints, it
is important to solve the following two challenges.
• How to stimulate the CPU such that it generates the MI
signal that can produce a consistent device fingerprint?
• How to collect and identify the MI signal segment that maps
to the one under stimulation even if an attacker may disturb
the communication between the stimulation program and
the trusted capturing sensor?
To address these two challenges, we design the stimulation program
such that it produces the MI signal trace in Fig. 9, which is composed
of a preamble and a fingerprinting signal that are both generated
by controlling the CPU load in a proactive way. As thus, DeMiCPU
only needs to transmit a signal as short as 0.6 s for fingerprinting.
5.1.1 Preamble. To identify the MI signal segment that is under
stimulation, a preamble is used for the trusted capturing sensor to
detect the start of the fingerprinting signal. DeMiCPU stimulates the
device such that a unique MI pattern is generated as a preamble,
thereby allowing the sensor to identify it with cross-correlation. We
realize the preamble by manipulating the CPU load and generate a
sequence of [1,0,1,0] (“1” for full-utilization mode and “0” for idle
mode) as shown in Fig. 9, which lasts for 100 ms in total.
Stimulating CPU. The strength of the MI signals emitted
5.1.2
from the CPU module depends on the current, which is related to
Algorithm 1: DeMiCPU Stimulation
1 CPU _Frequency ← Get_Current_CPU_Freqency()
2 if CPU _Frequency > threshold_1 then
3
C_priority ← Get_Current_Highest_Priority()
//get the highest priority level of running user threads
DeMiCPU _priority ← Gen_Priority(C_priority)
cpunum ← Get_CPU_Core_Num()
// get the number of CPU logical processors
for i ∈ ranдe(1, cpunum) do
hThread(i) ← CreateThread()
// create the it h DeMiCPU stimulating thread
SetThreadPriority(hThread(i), DeMiCPU _priority)
// set the it h DeMiCPU stimulating thread with the
generated DeMiCPU priority level
C_Thread ← GetCurrentThread ()
C_Mask = 0x0001 ∗ 2
SetThreadAffinityMask (C_Thread, C_Mask)
// bind the it h DeMiCPU stimulating thread to the it h
CPU logical processor
i −1
preamble_gen()
fingerprinting_signal_gen()
Stim_U til ← Get_Util_Feedback()
Stim_Freq ← Get_Freq_Feedback()
if Stim_U til < threshold_2 then
DeMiCPU Stimulation
if Stim_Freq < threshold_1 then
sleep(5)
DeMiCPU Stimulation
25 else
26
sleep(5)
DeMiCPU Stimulation
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
27
the CPU load. In order to obtain stable MI signals to produce CPU
fingerprints, we stimulate the CPU by controlling its utilization
ratio. Without loss of generality, the total CPU utilization is the
sum of CPU utilization from all running processes, including both
system and user processes, which can be modeled as follows:
CPU _util = Sys_processes + U ser _processes
(3)
Utilization Ratio. One intuitive question is what utilization
ratio to use, 100%, 50%, or other values? In fact, it is difficult to
precisely control the utilization since 1) it is hard to accurately
restrict system and user processes to a certain level, and 2) the CPU
scheduling policy further worsens the problem. For instance, 50%
CPU utilization means that the CPU works in 5 clock cycles and
is idle in the remaining 5. Without inspecting and modifying the
scheduling algorithm, it is almost impossible to ensure that the
CPU behaves the same in all clock cycles.
To address it, we choose to keep the CPU running in the full-
utilization (100%) mode to obtain an identical output. Another ben-
efit of such an implementation is that higher CPU utilization gen-
erates stronger MI signals, which helps to lighten the impact of
ambient noise. We achieve the full-utilization mode by invoking
CPU-consuming instructions, such as while(1) in our implemen-
tation. As thus, system processes, DeMiCPU stimulation process, and
other user processes together compose the 100% utilization.
DeMiCPU Priority. During fingerprinting, however, other user
processes, i.e., background applications, are not likely to be the same,
which may render the stimulation nonidentical. To eliminate the
influence of other user processes, we assign a superior priority to
the DeMiCPU stimulation program, which is higher than the base one
of other user processes yet lower than that of the system processes
since they only account for 1-2% CPU utilization on average.
Mainstream operating systems such as Windows, Linux, and Mac
OS X, are all able to support such an implementation. For instance,
Windows implements a priority-driven, preemptive scheduling sys-
tem, where the highest priority runnable threads are executed first.
Each thread, which is the smallest unit of program execution flow,
has a base priority as a function of its process priority class and
relative thread priority. Normally, user applications and services
start with a base priority level 8, i.e., both process and thread pri-
orities are normal [37]. Thus, we shall at least assign the DeMiCPU
stimulation program with a priority level higher than that.
In particular, we examine the highest priority of the user threads,
which is usually a priority level 8 as mentioned before. Then, we
assign a higher priority to the DeMiCPU thread, e.g., a normal pro-
cess priority but an above normal thread priority, i.e., a priority
level 9, to eliminate the impact of other user processes. In addition,
since modern CPU chips support multi-core and multi-thread, we
bind a stimulation thread to each available logical processor core,
including the virtual ones created by Hyper-Threading [30]. As
thus, the CPU utilization under stimulation is as follows:
CPU _util_stimu = Sys_processes + DeMiCPU = 100% (4)
Feedback. In general, such a design is able to generate an iden-
tical stimulation. However, in a rare case, a thread with a higher
priority may be launched during fingerprinting, making the stimu-
lation different than planned. To further guarantee the validity of
the DeMiCPU stimulation, we introduce a feedback mechanism, i.e.,
examining system logs after stimulation to confirm that DeMiCPU
exclusively uses the CPU during fingerprinting. If not, DeMiCPU
abandons the current measurements and triggers a second collec-
tion. Moreover, the CPU frequency may drop due to a high CPU
temperature or low battery. Thus, the feedback mechanism exam-
ines the CPU working frequency before and during stimulation. If a
previous or midway frequency drop is detected, DeMiCPU abandons
the current measurements and defers its collection till the CPU
recovers from the low frequency mode, as revealed in Algorithm 1.
In this way, we minimize the influence of software environment
and output stable fingerprinting signals as shown in Fig. 9.
5.2 DeMiCPU Fingerprint Extraction
5.2.1 Pre-processing. Preliminary analysis confirms the temporal
and spatial consistency of the MI signals in the frequency domain.
However, the time-domain MI signal is geo-spatial dependent due
to the impact of the earth’s magnetic field and ambient noise. As
the strength of the earth’s magnetic field and ambient noise is
relatively static at a specific spot, we assume it mainly contributes
to the constant part of the collected MI signals. To eliminate its
impact, we normalize the raw MI signal, i.e., the measured signal
in Fig. 9, before extracting features.
Denote the measured signal as B, we normalize B to obtain the
pre-processed MI signal M for feature extraction as follows:
M =
B − min(B)
max(B) − min(B)
(5)
Note that although the above solution is designed for scenarios
where ambient MI signals are relatively static, we argue it also
works with time-varying magnetic signals such as power frequency
interference from nearby electrical equipment, because that the
time-varying MI signals from other devices quickly attenuate and
thus have little influence.
Feature Selection. For each pre-processed signal M, we ex-
5.2.2
tract 30 scalar features from both time and frequency domains. We
exploit LibXtract [7], a lightweight feature extraction library for
time series, which can output a number of statistical feature can-
didates. Besides the features offered by LibXtract, we investigate
the physical meaning of the MI signal, and manually select fea-
tures, e.g., Spectrum Kurtosis and Spectrum Smoothness, on which
remarkable distinctions can be observed in Fig. 8.
To further determine critical features, we rank them with the
help of FEAST toolbox [6], which is a commonly used feature rank-
ing tool in machine learning. From the results, we obtain the top
15 features in time and frequency domains and construct a feature
set as: F ={Spectrum Roll Off, Spectrum Kurtosis, Average Deviation,
Spectrum Spread, Spectrum Smoothness, RMS Amplitude, Spectrum
Standard Deviation, Spectrum Irregularity-K, Spectrum Skewness,
Spectrum Flatness, Standard Deviation, Spectrum Irregularity-J, Mean,
Skewness, Spectrum Mean}. The orders in the set indicate their rank-
ing orders with Spectrum Roll Off giving the largest information
gain.
For a fingerprinting signal i from a device, hereafter we define
the feature set Fi as the fingerprint of the device.
5.3 DeMiCPU Fingerprint Matching
The DeMiCPU cloud server utilizes supervised learning to classify
each trace with the extracted feature set F. To select the appropriate
classification algorithm, we compare 10 commonly-used classifiers
and the detailed results can be found in Fig. 11(a). For the sake of
high classification accuracy and robustness over a single classifi-
cation algorithm, we employ an ensemble classification approach
ExtraTrees [19], which fits a number of randomized decision trees
on various sub-samples of the dataset and uses averaging to im-
prove prediction accuracy and avoid over-fitting.
Training. During the training process, for a specific device, k
traces from it are utilized as the positive class, and k traces from
each of the rest devices serve as the negative class to train a binary
classifier. Therefore, for j devices, j binary classifiers are trained in
total. In real-world deployment, we may need to extend the clas-
sification system when a new device comes and registers. Under
that circumstance, the feature sets of the new device are extracted
and trained to obtain a new binary classifier without the need of
retraining the original j classifiers. The new classifier is finally
Figure 10: Experimental setup. The magnetic sensor is verti-
cally placed on the surface of the target laptop for MI signal
collection.
incorporated with the existing classifiers to constitute a new classi-
fication system.
Matching. When matching, the server analyzes the fingerprint
signal from the device to be identified and extracts its feature set F.
Then, the server feeds it to the classifier of which class the device
claims to be, to verify its identity.
6 EVALUATION
To evaluate the performance of DeMiCPU, we have conducted ex-
periments with 70 laptops and 20 phones across 30 days, among
which 30 laptops are of the same model. The detailed information
of each device is shown in Tab. 3 (in Appendix A.1). In summary,
the performance of DeMiCPU is:
• DeMiCPU achieves 99.1% precision and recall for both laptops
and phones, and more than 98.6% precision and recall for
30 identical devices with one-round fingerprinting, and the
performance can be further improved to 99.9% with multi-
round fingerprinting.
• DeMiCPU can operate with little influence from operating
systems, background applications, fan on/off states or CPU
temperature.
• DeMiCPU supports low sampling rate which makes it a uni-
versal approach running on ubiquitous smart devices.
6.1 Experiment Setup
With the experiment setup described in Tab. 3 and Fig. 10, we collect
100 MI traces for each of the 90 devices and each trace lasts for
0.5 s (excluding the preamble). The settings for the laptops and
smartphones are as follows.
Stimulation Program Setup. We implement the stimulation
program in Algorithm 1 on five operating systems, i.e., Windows
(in C++), Linux (in C++), Mac OS (in Java), Android (in Java), and
iOS (in C++), to stimulate the CPU and generate a fingerprinting
e
c
n
a
m
r
o
f
r
e
P
1
0.9
0.8
0.7
0.6