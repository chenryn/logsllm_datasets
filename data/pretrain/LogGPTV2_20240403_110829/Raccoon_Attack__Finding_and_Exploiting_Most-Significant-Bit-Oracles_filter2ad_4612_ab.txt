containing a selected cipher suite and version, a nonce (called
ServerRandom), as well as other TLS features, which should
be used in this session. The server follows this message
up with a Certificate message, which contains an X.509
certiﬁcate of the server.
In static-DH cipher suites, this
certiﬁcate contains a long-lived Difﬁe-Hellman public key
(g, p,gb mod p), while in TLS-DHE cipher suites the cer-
tiﬁcate contains an RSA or DSA public signature key. If a
DHE cipher suite is selected, the server sends a server key
exchange message, containing the ephemeral public DH key
(g, p,gb mod p), as well as a signature, generated with the pri-
vate key corresponding to the server’s certiﬁcate. The server
then sends a ServerHelloDone message, which signals to the
client that the server has ﬁnished sending this ﬂight of mes-
sages. The client then sends a ClientKeyExchange message,
containing the client public key ga. Both parties now have
the cryptographic material to compute a shared secret called
the premaster secret (PMS) as gab = (ga)b = (gb)a (mod p).
The PMS is then used to derive the master secret using a key
derivation function (which we describe below); the master se-
cret is used to derive the individual symmetric keys. The client
then sends a ChangeCipherSpec message, indicating to the
server that the following messages sent from the client to the
server will be encrypted. The last message sent by the client
within the handshake is a Finished message, which contains
a cryptographic checksum over the transcript of the connec-
tion. The server answers this with its own ChangeCipherSpec
USENIX Association
30th USENIX Security Symposium    215
message, indicating that from now on, all messages are en-
crypted, followed by the server’s Finished message.
2.2 Hash Functions
Hash functions are mappings h : {0,1}∗ → {0,1}N which are
one-way, collision-free and do not allow to compute second
preimages [24]. A real-world hash function with close to
unbounded input length cannot be evaluated in constant time;
rather, for any reasonable implementation, the running time
for an input of length k is O(k). This can result in a timing side
channel in real-world applications if the hash function is used
with secret inputs of varying lengths [6]. Most common cryp-
tographic hash functions are built using a Merkle-Damgård
construction [24]. In this construction, the input is split into
ﬁxed-size blocks, and each block is mixed into a state of the
computation using a compression function, until all blocks
have been processed. Prior to feeding the blocks to the com-
pression function, the input is extended by a length ﬁeld, and
then padded to a multiple of the block size of the hash func-
tion; the extension and padding may necessitate creating an
additional input block. In some constructions, the output is
fed to a ﬁnalization function, which compresses the internal
state to the ﬁnal output.
Hash
function
MD5
SHA-1
SHA-256
SHA-384
Input
block
size
64
64
64
128
Output
size
16
20
32
48
Length
and
padding
8+1
8+1
8+1
16+1
Input block
borders
55, 119, 183, ...
55, 119, 183, ...
55, 119, 183, ...
111, 239, 367, ...
Table 1: Properties of common hash functions. The second
and third columns indicate the input and output block sizes.
The fourth column indicates the minimum size of the length
ﬁeld and padding in the last block. The last column indicates
the maximum input sizes ﬁtting into one, two, and three
blocks, respectively. All values are denoted in bytes.
which then arbitrary many pseudorandom bytes are derived.
TLS (and other typical cryptographic protocols) use a KDF
based on HMAC [41].
HMAC is a mechanism to compute message authentication
codes based on hash functions. The HMAC can be instanti-
ated with any hash function H and then inherits the parameters
of this function. For example, HMAC-SHA1 has an internal
block size of 64 bytes and an output size of 20 bytes.
(cid:16)
(K ⊕ opad)||H(cid:0)(K ⊕ ipad)||M(cid:1)(cid:17)
HMACH (K,M) = H
Figure 2: Merkle-Damgård construction of common hash
functions, such as MD5, SHA-1 and SHA-256.
Table 1 gives an overview of hash functions relevant to this
work. The second and third columns indicate the input and
output block size, respectively.4 The fourth column provides
the minimum number of bytes appended to the input. For
example, when using SHA-256 (which uses a block size of
64 bytes), at least 9 bytes have to be appended to the input
message. Therefore, messages of up to 55 bytes will be
processed as one block, using two calls to the compression
function (due to the ﬁnalization function). Messages of length
between 56 and 128− 9 = 119 bytes will be processed as two
input blocks, using three calls to the compression function.
Table 1 provides further examples for input block boundaries.
2.3 Key Derivation
Modern DHKE based protocols do not use the shared cryp-
tographic secret K = gab (or parts of it) directly as the key to
symmetric algorithms. Instead, K is used as the input to a
KDF which uses a ﬁxed-size intermediate value seed, from
4Technically all presented hash functions operate on bits instead of bytes.
However, they are almost universally only used with bit lengths that are a
multiple of 8. Therefore our analysis only focuses on these cases.
Here K is a secret key, and opad and ipad are byte arrays
of hash input block size B ﬁlled with bytes 0x36 and 0x5C,
respectively. The secret key K must also have a ﬁxed length B.
Therefore, before computing the HMAC, K is either padded
with zeros (if |K|  B). This additional hash function invocation on the
secret key K can result in measurable timing differences.
HMAC provides a foundational mechanism to design a
pseudorandom function (PRF) for key derivation and key
expansion. The PRF in TLS uses a single hash function
H, a secret K, a label, and a seed to expand cryptographic
material [28]:
PRF(K,label,seed) =HMACH (K,A1 || label || seed) ||
HMACH (K,A2 || label || seed) ||
HMACH (K,A3 || label || seed) || ...
where A0 = label || seed and Ai = HMACH (K,Ai−1). Here
the label is a distinguishing ASCII string constant deﬁned in
the TLS standard. The number of PRF iterations depends on
the desired output length. For example, three iterations can
be used to produce up to 96 output bytes if SHA-256 is used.
2.4 The Hidden Number Problem
To solve the Hidden Number Problem (HNP) [17], an adver-
sary must compute a secret integer α (in our case the premas-
ter secret of the TLS-DHE session under attack) modulo a
public prime p with bit-size n, given information about the
216    30th USENIX Security Symposium
USENIX Association
m1m2mn-1mnffff...........ﬁnalHashk most signiﬁcant bits (MSBs) of the n-bit representation of
random multiples α·ti mod p of this secret value. From these
MSBs the adversary can construct integers yi (e.g., by setting
the MSBs of yi as the known bits, and all other bits to 0) such
that for each i we have 0 ≤ α·ti mod p− yi  0. Each triple (ti,yi, (cid:96)) contains (cid:96) bits of information on α.
The number (cid:96) := k−n+log2(p) ∈ [k−1,k] can be considered
the effective number of given MSBs. This number can also
be written as (cid:96) = k− ε, where ε = n− log2(p) represents the
bias of the modulus (see Table 3 for the ε of some well-known
DH groups). If (cid:96) is not too small and we have a moderate
number of equations, the hidden number α can be recovered
by solving an instance of the Closest Vector Problem (CVP)
in a lattice [17, 34, 50]. If (cid:96) is small and a large number of
equations is available, Fourier analysis is considered more
promising [3, 47].
3 Raccoon Length Distinguishing Oracles
In this section we describe length distinguishing side channel
oracles which may be used in the Raccoon attack. All of these
oracles exploit the following fact:
The key derivation function KDF strips leading ze-
ros from the computed DH secret gab and performs
further computations based on the modiﬁed secret
string.
These computations can result in different timing behaviors
based on the number of removed bits or different error behav-
ior. An attacker observing the timing behavior can construct
an oracle from the behavior of an application using Difﬁe-
Hellman (DH) key exchange and use it to leak some of the
most signiﬁcant bits (MSB) of the shared secret. This already
invalidates the standard indistinguishability assumption of the
cryptographic primitives used (DDH, PRF-ODH).
We deﬁne Ok,b(x) as an oracle that reveals if the k most
signiﬁcant bits of the n-bit number xb mod p are zero:
(cid:40)
Ok,b(x) =
if MSBk(xb mod p) = 0 ,
True
False otherwise .
(1)
The effective number of bits leaked from this oracle de-
pends on the modulus length and bias, the underlying KDF
properties, as well as implementation details, and can range
from a fraction of a bit to several bytes in case the result is
True. In the following subsections, we give four different
constructions OH, OC, OP, and OD for such oracles. Then
in Section 4, we instantiate such oracles in the context of TLS
servers, and show in Section 5 how they can be used to run a
full attack to uncover the complete premaster secret.
3.1 OH: Hash Function Invocation
In HMAC constructions (RFC 2104 [41]), the shared secret
key gab may either be used directly in the HMAC computation
(if |gab| is smaller than the maximal HMAC key size), or it
must be hashed to a smaller size.
Consider a server that uses a DH prime modulus p with
|p| = 1025 bits and a PRF based on HMAC-SHA384. For this
PRF, the secret key k can at most be 128 bytes long, which is
the input block size of the hash function SHA-384 (Table 1).
For this purpose, the KDF ﬁrst strips leading zero bits and
then converts K to a byte sequence. Now the KDF program
branches:
1. If the length of the byte sequence is at most 128 bytes,
this byte sequence is used directly as the HMAC key k.
2. If the length of the byte sequence is bigger than 128
bytes, the SHA-384 hash function is invoked once on this
byte sequence, and the resulting hash value, padded with
80 zero bytes, is used as the HMAC key: k = h||0x0...0.
Now assume that a man-in-the-middle (MitM) attacker
observed a DH key exchange. The goal of the attacker is
to learn the ﬁrst bit of K = gab mod p. As described above,
there are two possibilities for a server-side KDF to process
the shared secret K = gab:
• The most signiﬁcant bit of K is 0. The server strips the
leading zero bit and converts K to a byte array which
will consist of 128 bytes. Since the byte array is 128
bytes long, it is directly used in the HMAC computation:
HMACSHA−384(K, seed).
• The most signiﬁcant bit of K is 1. The server converts
K to a byte array, which will consist of 129 bytes. A
129-byte long shared secret cannot be directly used in the
HMAC computation (see also Subsection 2.3); before
computing HMAC, the server needs to compute SHA-
384 over K. It can then use the SHA-384 output as an
input for the HMAC computation.
Observe how a shared secret K starting with 1 results in
an additional SHA-384 hash function invocation over K. In
the previous example, the modulus was exactly one bit bigger
than the block size of the hash function and leaked only the
most signiﬁcant bit of the PMS. If the modulus is k bits bigger
than the block size, the attacker has a chance of 1/2(cid:96) to leak
the top k bits of the PMS. As we show in Section 6, this
timing difference is observable by a remote attacker.
3.2 OC: Compression Function Invocations
This oracle exploits the number of invocations of the internal
compression function if the second branch in OH occurs, i.e.,
if the shared DH secret K = gab is bigger than the input block
length of the HMAC hash function.
As mentioned in Subsection 2.2, hash functions based on
the Merkle-Damgård scheme operate on blocks. The number
of blocks a hash function has to process depends on the input
length (see Table 1). If the DH shared secret K is used as a
key for an HMAC computation, it can have distinct timing
proﬁles depending on its length.
USENIX Association
30th USENIX Security Symposium    217
To give an example for HMAC-SHA384, consider a 1913-
bit DH modulus p, which is encoded in 240 bytes. The server-
side KDF implementation now has to invoke the hash function
over the shared key K, since K is much larger than the allowed
128 bytes. We now get a MSBs oracle from the number of
compression function invocations:
1. If the most signiﬁcant bit of K is 0, K will be coded into
239 bytes. Even with the 17 bytes added for length and
padding (cf. Table 1), it will ﬁt into two blocks. Thus,
the server will execute three hash compressions.
2. If the most signiﬁcant bit of K is 1, K will be decoded
into 240 bytes. Appending padding and the length ﬁeld
will ﬁt into three blocks; the server will execute four
hash compressions.
Analogously to the previous oracle, if the modulus is k bits
bigger than a critical block border, the attacker has a chance
of 1/2(cid:96) to leak the top k bits of the PMS, where (cid:96) = k− ε (see
Subsection 2.4).
3.3 OP: Key Padding
Another side channel arises based on the number of padding
bytes used to pad the DH shared key. The HMAC inter-