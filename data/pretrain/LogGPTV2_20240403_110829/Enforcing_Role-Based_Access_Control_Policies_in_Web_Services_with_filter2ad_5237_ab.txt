constraint  to  be  an  invariant.  Invariants  are  conditions 
that must be true during the lifetime of a system for all 
instances of a given type. The following line shows an 
example of an OCL invariant describing a role with at 
most one user: 
context Role inv:self.user->size()” followed by the name of the property. A property 
of  the  set  of  users  is  expressed  using  the  size 
operation in this example. 
Furthermore,  OCL  has  several  built-in  operations 
that  iterate  over  the members of a collection (set, bag, 
sequence) such as forAll and iterate [2].  
3.   Authorization framework 
We  have  designed  and  implemented  an  advanced 
Web  Services-based  authorization  framework  for  the 
enforcement  of  organization-wide  RBAC  policies.  In 
our  authorization  framework,  the  authorization  engine 
and  the  application(s)  are  exported  as  Web  Services. 
The  authorization  engine  implements  organization-
wide RBAC policies and makes access decisions.  
The  authorization  framework  is  based  on  the 
concept of an interceptor (Access Decision Handler), a 
middleware  component.  Specifically,  the  interceptor 
259259
the  access  decisions  on  behalf  of 
the 
enforces 
applications. This way, the applications do not need to 
implement 
their  own  authorization  mechanisms. 
Instead,  they  can  employ  the  authorization  engine  to 
conduct the job accordingly. As a consequence, RBAC 
policies  such  as  SOD  need  not  be  implemented  in  the 
application  itself,  i.e.,  applications  can  rely  on  our 
framework  for  this  purpose.  Furthermore,  if  RBAC 
policies  are  changed,  the  applications  need  not  be 
adjusted. This leads to a separation of the authorization 
logic  (integrated 
the 
application  logic.  Since  the  organizations  may  be 
running 
the  Web  Services 
approach is suitable to implement interceptors even for 
legacy  applications,  while  still  using  the  centralized 
authorization engine.  
the  middleware)  from 
legacy  applications, 
into 
In  Figure  2,  an  overview  of  the  authorization 
framework  is  given.  The  communication  between  the 
framework  components  is  based  on  SOAP  messages. 
The  Authorization  Engine  is  a  policy  decision  point 
(PDP),  whereas  the  Access  Decision  Handler  is  a 
policy  enforcement  point  (PEP)  [15].  The  PDP 
evaluates  client  requests  against  relevant  RBAC 
policies  to  return  an  authorization  decision.  The  PEP 
enforces  the  PDP’s  decisions.  Details  are  discussed 
subsequently. 
Fig. 2. Authorization Framework. 
3.1. Details of the authorization framework 
and 
Figure  3  shows  a  sequential  view  of 
communication  between 
the 
authorization 
the 
interacting  components.  When  an  Application  Client 
calls  a  security-critical  operation  such  as  “debit 
account”  on  the  Application  Web  Service,  the  Access 
Decision Handler intercepts the request and forwards it 
to  the  Authorization  Engine  in order to check whether 
the  request  from 
or  not  the  client  has  the  permission  to  perform  the 
current  operation.  The  Authorization  Engine,  on 
receiving 
the  Access  Decision 
Handler, decides if the client has a permission to carry 
out the current operation, and sends the response back 
to  the  Access  Decision  Handler.  In  turn,  the  Access 
Decision  Handler  enforces  the  access  decision  of  the 
Authorization  Engine  by  allowing  or  rejecting  the 
client’s request to perform the current operation on the 
Application Web Service. This way, the interceptor can 
be  seen  as  a  mediator  [17]  between  the  Web-Service-
based applications and the Authorization Engine. 
Fig. 3. Authorization flow and communication 
path. 
the  Application  Web  Service  and 
the  Application  Web  Service  and  of 
The Access Decision Handler (interceptor) has been 
realized  in  the  following  way:  For  the  Application 
Client, it acts as a Web Service (exposing the interfaces 
of 
the 
Authorization Engine to the Application Client). At the 
same time, the interceptor acts as a Web Service client 
for  both 
the 
Authorization Engine.  
A  further  aspect 
is  session 
management. We use the session management provided 
by the Web container (Apache’s Axis) for this purpose: 
When a user logs in via the Application Client, an http 
session  ID  is  then  communicated  to  the  PDP,  which 
uses  this  information  for  creating  its  own  internal 
representation of RBAC sessions (cf. Section 4).  
to  be  discussed 
are  used  by 
One  remark  should  be  made  on  the  mapping 
between the Application Web Service interface and the 
RBAC  permissions,  which 
the 
Authorization  Engine  for  the  access  decision.  We 
define  the  remote  interfaces  for  the  Application  Web 
Service  in  a  way  that  all  methods  have  exactly  one 
parameter,  namely,  the  object  (in  the  sense  of  access 
control)  to  which  the  operation/method is applied. For 
example,  if  a  debit  operation  is  to  be  executed  on  an 
account  object,  we  have  a  Java  method  debit  with  the 
260260
parameter  account.  This  way,  we  can  create 
corresponding  RBAC  permissions  such  as  (debit, 
account) and thus have a mapping from the Application 
Web  Service  interface  to  RBAC  permissions.  The 
interceptor  then  extracts  the  operation  (method  call) 
and object (parameter). We assume that the Application 
Web  Service  interface  is  defined  by  domain  experts 
knowing the organization’s internal rules and processes 
in  detail.  The  same  applies  to  the  definition  of  the 
RBAC permissions.  
3.2. Trust considerations   
Strictly  speaking,  the  communication  channel  from 
the  Application  Client  to  the  Application  Web  Service 
must  be  secured.  This  can  be  done  by  means  of  XML 
Digital  Signature  [27].  In  particular,  we  need  a  secure 
channel  between  the  PDP  (Authorization  Engine)  and 
the  PEP(s).  At  least,  the  Access  Decision  Handler 
(PEP) and the PDP must trust each other. Furthermore, 
the  Application  Web  Services  must  trust  the  PEP  and 
by  transitivity  the  PDP.  The  Application  Client, 
however, is not trustworthy because it is under control 
of the user (and possibly under control of an attacker). 
If 
the 
Application  Web  Service,  then  a  trust  relationship  in 
that direction must also exist. This, for instance, is the 
case  if  the  access  history  (needed  for  implementing 
History-based  SOD  [9])  must  be  updated  after  an 
operation  has  been  successfully  carried  out  by  the 
Application Web Service.  
the  PEP  and  PDP  need  feedback  from 
4. Authorization engine functionality 
framework,  which 
The  authorization  engine  is  the  core  component  of 
the  authorization 
implements 
organization-wide  RBAC  policies.  Such  policies  are 
eventually  enforced  by  means  of  the  authorization 
framework.  We  have 
implemented  an  advanced 
authorization  engine,  which  is  based  on  the  Java  API 
provided by the USE system, a validation tool for UML 
models and OCL constraints [16]. 
We  use  the  UML/OCL  specifications  provided  by 
USE  to  formulate  RBAC  policies.  Specifically,  the 
RBAC  element  sets  and  relations  are  modeled  in 
textual  UML,  and  the  authorization  constraints  are 
specified  in  OCL.  Owing  to  the  fact  that  OCL  can  be 
used  to  express  the  authorization  constraints  formally 
and  precisely,  a  validation  tool  such  as  USE  can  be 
applied 
to  analyze  RBAC  policies.  Hence,  one 
advantage  of  our  approach  is  that  USE  can  be 
employed  both  for  validation  and  enforcement  of 
RBAC policies. 
261261
The  USE  system 
is  based  upon  a  so-called 
animation-based  validation  approach,  i.e.,  the  OCL 
constraints  are  checked  against  system  states,  which 
are  represented  as  UML  object  diagrams  [1].  Beyond 
syntax  checks,  USE  supports  the  modeler  in  detecting 
missing  or  conflicting  constraints.  This  validation  of 
RBAC policies, however, is not topic of this paper. The 
interested reader may be referred to another paper [22]. 
In Figure 4, we show a simple RBAC policy, which 
is represented as a USE specification. It consists of the 
RBAC-related  classes  and  association  definitions 
formulated  in  textual  UML,  and  a  set  of  domain-
specific  authorization  constraints  formulated  in  OCL. 
We  define  three  constraints.  The  first  is  a  prerequisite 
role  constraint  between 
two  roles  “Banking 
Employee” and “Cashier”, i.e., a user must be assigned 
to  the  “Banking  Employee”  role  if  she  is  assigned  to 
the  “Cashier”  role.  The  second  one  is  an  SSOD-CU 
constraint  (Static  SOD-Conflict  Users)  meaning  that 
conflicting  users  cannot  be  assigned  to  conflicting 
roles.  A  typical  example  of  conflicting  users  is  family 
members who could collude to commit fraud. The third 
constraint  is  the  Simple  Dynamic  SOD  (SDSOD) 
constraint [9], which states that a user must not activate 
the “Customer” and the “Cashier” role simultaneously. 
Technically,  CU  and  CR  denote  sets  of  conflicting 
users and roles, respectively. 
the 
The  RBAC  policy  shown  in  Figure  4  is  only  for 
didactic  purposes,  which  by  no  means  is  a  complete 
policy  that  the  authorization  engine  implements.  In 
general, the authorization engine is independent of any 
specific  UML/OCL-based  RBAC  model,  and,  as 
pointed  out  before, 
engine 
implements  all  authorization  constraints  expressible  in 
OCL.  The  RBAC  policy  is  saved  in  a  file  in  the  USE 
format,  which  is  processed  when  the  authorization 
engine is started. This way, a security officer specifies 
the  RBAC  policy  in  UML/OCL  and  the  USE  system 
takes over the job of implementing the policy.  
authorization 
the 
The specification in Figure 4 has the drawback that 
the concrete entities (such as users and roles) are hard-
coded  into  the  specification.  In  addition,  the  policy 
designer  might  not  be  an  expert  in  OCL.  To  address 
these  problems,  a  macro/template  mechanism  can  be 
provided  in  order to make available recurring types of 
authorization  constraints  for  a  policy  designer.  These 
macros  are  then  instantiated  with  the  concrete  entities 
on  which  the  authorization  constraints  are  to  be 
applied.  This 
the  macro  mechanism 
introduced  into  the  C  programming  language.  Let  us 
take  the  prerequisite  role  constraint  as  an  example. 
macro 
the 
Then, 
PrereqRole(_r1_,_r2_) as follows: 
resembles 
we 
can 
define 
model RBAC 
--classes 
class Role 
attributes 
name:String 
end 
class User 
attributes 
name:String 
end 
class Permission 
attributes 
op:Operation 
o:Object 
end 
class Object 
attributes 
name:String 
end 
class Operation 
attributes 
name:String 
end 
class Session 
attributes 
name:String 
end 
-- associations 
association UA 
between 
User[*] role user 
Role[*] role role_ 
end 
association PA between 
Permission[*] role permission 
Role[*] role role_ 
end 
association establishes between 
User[1] role user 
Session[*] role session 
end 