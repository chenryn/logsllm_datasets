and E is an AE-secure encryption scheme, then Scheme 2 satisfies
tree-unlinkable confidentiality.
Theorem 5.2. Assuming the correctness of the MAC’s blind presen-
tation protocol [5] and the completeness of the zero-knowledge proof
system, Scheme 2 satisfies accountability.
Theorem 5.3. Assuming that the MAC presentation and issuance
protocols of [5] satisfy unforgeability, the proof of knowledge system
satisfies a strong extractability property, and the discrete log problem
is hard in G, then Scheme 2 is unforgeable.
Theorem 5.4. Assuming that the El Gamal encryption scheme P is
CPA-secure and E is deniable, Scheme 2 is deniable.
6 IMPLEMENTATION AND EVALUATION
We implemented both our constructions in Rust using the double-
ratchet crate, an implementation of Signal’s Double Ratchet proto-
col, as a baseline implementation of a messaging scheme [38]. The
implementation of our tree-linkable scheme relies on the ed25519-
dalek crate, which provides an implementation of ed25519 sign-
ing and verification [20]. For the tree-unlinkable scheme, we used
curve25519-dalek’s implementation of curve25519 [21] to imple-
ment the algebraic MAC of Chase et al. [5], El-Gamal encryption and
verification, and the necessary zero-knowledge proofs, which we im-
plemented using the zkp crate [9]. The zkp crate does not currently
provide functionality to prove disjunctions of statements, so to
implement the receive proof (Figure 5), we modified the zkp prover
and verifier to support the OR-protocol for Schnorr proofs [2]. Only
our tree-linkable implementation includes report metadata, which
we set to be a UNIX timestamp.
We evaluated our implementations on a variety of message
lengths, ranging from 10 to 8000 bytes. Because we found that in-
creased message lengths impacted runtime by <1% over this range,
we only provide data for 1KB messages. Evaluation was performed
using Criterion on an Intel i7-6700 processor @ 3.40GHz running
Ubuntu Linux, and all estimates are computed from the average of
at least 300 trials, where the number of iterations was determined
by the number sufficient to achieve a <1% margin of error (p = 0.05).
We conclude that our tree-linkable scheme does not significantly
increase computation or communication costs in comparison to
schemes deployed today that do not support source-tracking.
We compare our schemes to a baseline messaging scheme with-
out source-tracking in Table 1. The times for server-side computa-
tion and reporting reflect the additional computations incurred by
our scheme. We do not include a baseline time for a scheme with
no tracking for these values, as there are no server-side operations
to support source-tracking in the baseline.
While our tree-linkable scheme results in increased client-side
costs, the overall client-side cost is still on the same order of mag-
nitude as a scheme without source-tracking, and costs remain con-
cretely very low. The costs on the server-side, where cost increases
are much more sensitive, are minimal by comparison. The majority
of the cost of sending messages in this scheme is the necessary cost
of delivering a message in the underlying messaging scheme. Note
that we separately report receiving times for fresh and forwarded
messages. The different times do not open a timing side channel, as
the components of each protocol that involve interaction with the
server are identical. A constant-time implementation would incur
the greater of the two costs for each message.
Our tree-unlinkable scheme has costs that are an order of magni-
tude higher than the linkable scheme, but concrete costs still remain
on the order of milliseconds for each operation.
Table 2 Shows the additional communication we incur com-
pared to a standard double ratchet end-to-end encrypted messaging
scheme that does not use source-tracking. The increase in com-
munication costs across our two schemes mirrors the increase in
computation costs. Although the greatest communication increase
Session 5C: Messaging and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1495No Tracking
Tree-Linkable
Tree-Unlinkable
Send
Rec. (fresh)
Rec. (forward)
Server
Report
175 𝜇s
116 𝜇s
116 𝜇s
N/A
N/A
201 𝜇s
181 𝜇s
237 𝜇s
20 𝜇s
57 𝜇s
2.7 ms
6.4 ms
6.3 ms
4.1 ms
2.6 ms
Table 1: Computation time for using our constructions to send
1KB messages compared to a standard double ratchet end-to-end
encrypted message. Although the cost of sending a message in-
creases with message size, we found that the increase was always
less than 1% when going from 10B to 1KB messages.
Tree-Unlinkable
Tree-Linkable
Send
Rec.
Report
256B
320B
160B
712B
1688B
648B
Table 2: Additional communication incurred to send a message
using our constructions compared to sending the message via a
standard double ratchet end-to-end encrypted message.
is in the process of receiving a message, the data that clients must
keep in order to report a message is only 128 Bytes in the tree-
linkable scheme and 136 Bytes in the tree-unlinkable scheme.
Comparison to prior work. The only prior work that considers
finding the source of a forwarded message is the traceback scheme
of Tyagi et al. [32]. Whereas their work considers the setting where
the system wishes to reveal all the users who received a particu-
lar message, we explicitly aim to prevent leaking this information.
Despite the difference in security properties, it is worthwhile to com-
pare our tree-linkable scheme to the path-traceback of Tyagi et al.
(their more efficient scheme) to understand the performance trade-
offs between the two approaches.
Traceback incurs lower client overhead than our scheme, re-
quiring less than 8𝜇s overhead to send a message and less than
2𝜇s to receive one, meaning their client-side sending and receiving
costs almost match the performance of a messaging scheme with
no tracking as shown in Table 1. Per-message communication costs
for traceback are also lower. Sending and receiving a message re-
quire an additional 64 and 48 bytes of communication, respectively
(compared to 256 and 320 bytes for tree-linkable tracing), while a
report consists of only 16 bytes in addition to the message plaintext.
A report in our tree-linkable scheme requires 160 additional bytes.
The lower client costs to support message traceback come at the
cost of increased server side storage and report verification costs.
First, finding the source of a reported message using traceback
requires computation linear in the length of the forwarding chain.
At approximately 90𝜇s per forward, the report verification cost is
comparable to ours (57𝜇s on a slightly faster processor) for a fresh
message but becomes worse if a message is forwarded several times.
The time to find the source of a reported message in our schemes
is constant, regardless of the number of forwards.
More importantly, the traceback scheme requires the server to
store 36 Bytes per message sent. The server cannot know when a
client has read or deleted a message, so it must conservatively store
tracing information for as long as the message should be traceable.
At the scale of a messaging system like WhatsApp that delivers
on the order of 100 billion messages a day [29], this requires an
additional 3.6 Terabytes of storage per day. On the other hand, our
source-tracking schemes require no persistent server-side storage.
ACKNOWLEDGMENTS
This work was funded by NSF, DARPA, a grant from ONR, and the
Simons Foundation. Opinions, findings and conclusions or recom-
mendations expressed in this material are those of the authors and
do not necessarily reflect the views of DARPA.
REFERENCES
[1] Joël Alwen, Sandro Coretti, and Yevgeniy Dodis. 2019. The double ratchet: Se-
curity notions, proofs, and modularization for the signal protocol. In Annual
International Conference on the Theory and Applications of Cryptographic Tech-
niques. Springer, Springer, Cham, Darmstadt, 129–158.
[2] Dan Boneh and Victor Shoup. 2020. A Graduate Course in Applied Cryptography.
[3] Jan Camenisch and Markus Stadler. 1997. Proof systems for general statements
about discrete logarithms. Technical Report/ETH Zurich, Department of Computer
Science 260 (1997).
[4] Melissa Chase, Sarah Meiklejohn, and Greg Zaverucha. 2014. Algebraic MACs
and keyed-verification anonymous credentials. In Proceedings of the 2014 ACM
SIGSAC Conference on Computer and Communications Security. ACM, Scottsdale,
1205–1216.
[5] Melissa Chase, Trevor Perrin, and Greg Zaverucha. 2020. The Signal Private
Group System and Anonymous Credentials Supporting Efficient Verifiable En-
cryption. In Proceedings of the 2020 ACM SIGSAC Conference on Computer and
Communications Security (Virtual Event, USA) (CCS ’20). Association for Comput-
ing Machinery, New York, NY, USA, 1445–1459. https://doi.org/10.1145/3372297.
3417887
[6] David Chaum. 1985. Security without identification: Transaction systems to
make big brother obsolete. Commun. ACM 28, 10 (1985), 1030–1044.
[7] Katriel Cohn-Gordon, Cas Cremers, Benjamin Dowling, Luke Garratt, and Dou-
glas Stebila. 2020. A formal security analysis of the signal messaging protocol.
Journal of Cryptology 33, 4 (2020), 1914–1983.
[8] Henry Corrigan-Gibbs, Dan Boneh, and David Mazières. 2015. Riposte: An
Anonymous Messaging System Handling Millions of Users. In 2015 IEEE Sympo-
sium on Security and Privacy, SP 2015, San Jose, CA, USA, May 17-21, 2015. IEEE
Computer Society, San Jose, 321–338.
[9] Henry de Valence. 2019. zkp: Experimental zero-knowledge proof compiler in
Rust macros. https://github.com/hdevalence/zkp.
[10] Mario Di Raimondo and Rosario Gennaro. 2009. New Approaches for Deniable
Authentication. Journal of Cryptology 22, 4 (Oct. 2009), 572–615. https://doi.org/
10.1007/s00145-009-9044-3
[11] Mario Di Raimondo, Rosario Gennaro, and Hugo Krawczyk. 2005. Secure Off-the-
Record Messaging. In Proceedings of the 2005 ACM Workshop on Privacy in the
Electronic Society. Association for Computing Machinery, New York, NY, United
States, 81–89.
[12] Yevgeniy Dodis, Peul Grubbs, Thomas Ristenpart, and Joanne Woodage. 2018.
Fast message franking: From invisible salamanders to encryptment. In Annual
International Cryptology Conference. Springer, Springer, Cham, Santa Barbara,
155–186.
[13] Marc Fischlin and Sogol Mazaheri. 2015. Notions of Deniable Message Authen-
tication. In Proceedings of the 14th ACM Workshop on Privacy in the Electronic
Society (WPES ’15). Association for Computing Machinery, New York, NY, USA,
55–64. https://doi.org/10.1145/2808138.2808143
[14] Paul Grubbs, Jiahui Lu, and Thomas Ristenpart. 2017. Message Franking via
Committing Authenticated Encryption. IACR Cryptol. ePrint Arch. 2017 (2017),
664.
[15] Seny Kamara, Mallory Knodel, Emma Llansó, Greg Nojeim, Lucy
Qin, Dhanaraj Thakur, and Caitlin Vogus. 2021.
Outside looking
in: Approaches to content moderation in end-to-end encrypted sys-
tems.
https://cdt.org/insights/outside-looking-in-approaches-to-content-
moderation-in-end-to-end-encrypted-systems/
[16] Anunay Kulshrestha and Jonathan Mayer. 2021. Identifying Harmful Media in
End-to-End Encrypted Communication: Efficient Private Membership Computa-
tion. In USENIX Security. USENIX, Virtual Event.
[17] Albert Kwon, Henry Corrigan-Gibbs, Srinivas Devadas, and Bryan Ford. 2017.
Atom: Horizontally Scaling Strong Anonymity. In Proceedings of the 26th Sym-
posium on Operating Systems Principles, Shanghai, China, October 28-31, 2017.
Association for Computing Machinery, New York, NY, United States, 406–422.
[18] Albert Kwon, David Lu, and Srinivas Devadas. 2020. XRD: Scalable Messaging
System with Cryptographic Privacy. In 17th USENIX Symposium on Networked
Session 5C: Messaging and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1496Systems Design and Implementation, NSDI 2020, Santa Clara, CA, USA, February
25-27, 2020. USENIX, Santa Clara, 759–776.
[19] David Lazar, Yossi Gilad, and Nickolai Zeldovich. 2018. Karaoke: Distributed Pri-
vate Messaging Immune to Passive Traffic Analysis. In 13th USENIX Symposium
on Operating Systems Design and Implementation, OSDI 2018, Carlsbad, CA, USA,
October 8-10, 2018. USENIX, Carlsbad, 711–725.
[20] Isis Lovecruft. 2020. ed25519-dalek: Fast and efficient ed25519 signing and verifi-
cation in Rust. https://github.com/dalek-cryptography/ed25519-dalek.
[21] Isis Lovecruft and Henry de Valence. 2020. curve25519-dalek: A pure-Rust
implementation of group operations on Ristretto and Curve25519. https://github.
com/dalek-cryptography/curve25519-dalek.
[22] Moxie Marlinspike. 2013. Simplifying OTR Deniability.
[23] Movie Marlinspike and Trevor (ed.) Perrin. 2016. Signal » Specifications » The
X3DH Key Agreement Protocol. https://signal.org/docs/specifications/x3dh/.
(Accessed on 09/03/2020).
[24] Torben Pryds Pedersen. 1992. Non-Interactive and Information-Theoretic Secure
Verifiable Secret Sharing. In Advances in Cryptology — CRYPTO ’91 (Lecture
Notes in Computer Science), Joan Feigenbaum (Ed.). Springer, Berlin, Heidelberg,
129–140. https://doi.org/10.1007/3-540-46766-1_9
[25] Trevor Perrin and Moxie Marlinspike. 2016. The Double Ratchet Algorithm.