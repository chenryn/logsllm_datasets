free to send unsolicited email to
is urgent try beneurgent,forta.com. Feel
spameforta.con (wouldn’t it be nice if
it were that sinple, huh?).
分析
这个正则表达式匹配到了5个电子邮件地址，但其中有两个不够完
---
## Page 48
38
第5章重复匹配
整。为什么会这样？因为我们在构造这个正则表达式的时候只想到在@字
符的后面会有一个，字符分开两个字符串的情况，没有想到在@字符的前
面还会有，字符。因此，虽然PI:EMAIL是一个完全合法的电
子邮件地址，但这个正则表达式只能匹配forta（而不是ben.forta）。
别忘了，w只能匹配字母和数字字符，不能匹配出现在字符串中间的。
字符。
要想干净彻底地解决这个问题，我们需要匹配\w或，。用正则表达式
的术语来说，我们需要匹配字符集合[\.]。下面是上面那个例子的改进
版本：
文本
Send personal emai1 to beneforta.com or
ben,fortaeforta.com. For questions about a
book use supporteforta.con. If your message
free to send unsolicited enai1 to 
is urgent try ben@urgent.forta.com. Feel
spaneforta.com (wouldn’t it be nice if
it were that simple, huh7) .
正则表达式
[1w, ]+e[ \w, ]+1 , 1m+
结果
Send personal enail to beneforta.con or
book use supporteforta.com. If your message
ben.fortaeforta.com. For questions about a
free to send unsolicited email to
is urgent try beneurgent.forta.con. Feel
spameforta.com (wouldn’t it be nice if
it were that simple, huh?) -
分析
问题似乎得到了圆满解决。[\w.]+将匹配字符集合[\w.]（字母数字
字符、下划线和.）的一次或多次重复出现，ben.forta完全符合这一条
件。考虑到有些电子邮件地址会有多层域名（或主机名），我们在@字符
的后面也使用了一个[\w，]+
---
## Page 49
5.1有多少个匹配
39
注意这个正则表达式的最后一部分是w+而不是[w.]+，你
如道这是为什么吗？把[\w.]用作这个模式的最后一部分会在
第2、第3和第4个匹配上出问题，你不妨试试看。
注意细心的读者可能已经注意到了：我们没有对字符集合
[w.]里的，字符进行转义。尽管如此，它还是把原始文本里的。
字符匹配出来了。一般来说，当在字符集合里使用的时候，像
和+这样的元字符将被解释为普通字符，不需要被转义，但转
义了也没有坏处。[\w.]的使用效果与[w\.]是一样的
5.1.2匹配零个或多个字符
+匹配一个或多个字符，但不匹配零个字符，+最少也要匹配一个字符。
那么，如果你想匹配一个可有可无的字符，也就是该字符可以出现零次或
多次的情况，你该怎么办呢？
这种匹配需要用*元字符来完成。*的用法与+完全一样，只要把它放
在一个字符（或一个字符集合）的后面，就可以匹配该字符（或字符集
合）连续出现零次或多次的情况。比如说，模式B.*Forta将匹配BForta、
B.Forta、BenForta和其他有类似规律的组合。
为了演示+和*的区别，我们来看两个匹配电子邮件地址的例子。先
看第一个：
文本
Hello .beneforta.com is my enail address.
正则表达式
[\w. ]+Φ[ 1w. +1 , 1m+
结果
Hello beneforta.con is my enail address.
分析
[\w.]+将匹配字符集合[\w.]（字母数字字符、下划线和，）的一次
---
## Page 50
第5章重复匹配
或多次重复出现，而.ben完全符合这一条件。这显然是一个打字错误（原
始文本里多了一个，），但这并不是我们这里最关心的问题。问题的关键
在于：虽然，是电子邮件地址里的合法字符，但把它用作电子邮件地址的
第一个字符就不合法了。
一个电子邮件地址可以有任意多个字符，但它的第一个字符必须是
一个字母或数字字符。根据这一要求，我们真正需要的是一个如下例所
示的模式：
文本
Hello -beneforta.com is my enail address,
正则表达式
+81*1+  *×\]e[α\ ]+#]
结果
Hello -beneforta.comi is my email address.
分析
这个模式看起来相当复条，但并不难理解。开头的\w负责匹配电子
邮件地址里的第一个字符（一个字母数字字符，不包括.字符）。接下来
的[\w.]*负责匹配电子邮件地址里第一个字符之后、@字符之前的所有字
符，这个部分可以包含零个或多个字母数字字符和.字符。至于这个模式
的其他部分，我们已经在第4章里解释过了。在这个例子里，解决问题的
关键是能不能想到用[\w.]*来匹配字符集合[\w.]（字母数字字符、下划
线和.）的零次或多次重复出现。
注意可以把*理解为一个用来表明这样一种含又的元字符：
“在我前面的字符（或字符集合）是可选的”。“与+的区别是：
+匹配一个或多个字符（或字符集合），最少要匹配一次：*医
配零个或任意多个字符（或字符集合），可以没有匹配。
提示·是一个元字符、如果需要压配*本身，就必须使用它的
转义序列\*
---
## Page 51
5.1有多少个匹配
41
5.1.3匹配零个或一个字符
另一个非常有用的元字符是？。？只能匹配一个字符（或字符集合）
的零次或一次出现，最多不超过一次，请仔细体会？与+和*的相似和区别
之处。如果需要在一段文本里匹配某个特定的字符（或字符集合）而该
字符可能出现、也可能不出现，？无疑是最佳的选择。
请看下面这个例子：
文本
The URL is http://www.forta.com/, to connect
securely use https: / /ew, forta.com/ instead.
正则表达式
http: //[ \w / ]+
结果
The URL is http://ww.forta.com/. to connect
securely use https:/ /www.forta.con/ instead.
分析
这是一个用来匹配URL地址的模式：http://是普通文本，只能匹配
它本身：随后的[\w./]+匹配字符集合[\w./]（字母数字字符、，和/）的
一次或多次重复出现。这个模式只匹配到了第一个URL地址（以http：//
开头的那个），没能匹配到第二个（以https：//开头的那个）。简单地在
http的后面加上一个s*（s的零次或多次重复）并不能真正解决这个问题，
因为那会使得httpsssss://（如此开头的URL地址显然是不合法的）也
被认为是一个合法的匹配。
怎么办？看看下面这个例子就知道了—在http的后面加上一个
5 ?:
文本
The URL is http://www.forta.com/, to connect
securely use https: //www, forta.com/ instead.
---
## Page 52
42
第5章重复匹配
正则表达式
+[ /*1//:sd4
结果
The URL is http://ww.forta.com/, to connect
securely use https://mww.forta.com// instoad.
分析
这个模式的开头部分是https？。?在这里的含义是：我前面的字符（s）
要么不出现，要么最多出现一次。换句话说，https?：//既可以匹配
http://，也可以匹配https://.但也就仅此而已。
在4.3.3节里有一个用模式\r\n\r\n去匹配空白行的例子。我在分析
完那个例子后说过这样的话：在Unix或Linux系统上匹配空白行只使用
\n\n即可，不需要加上\r：同时适用于Windows和Unix/Linux系统的正则
表达式应该包含一个可选的\r和一个必须被匹配的\n。现在，你应该想
到可以用？来解决这个问题了吧？下面还是那个例子，但我们这次将使用
一个略有不同的正则表达式：
文本
“1@1′,*Ben°,*Forta”
*1e2′,°Jim*,°James′
*1e3′,*Roberta*, *Robertson*
*1e4′,*Bob*,*Bobson*
正则表达式
[1]7n[\]7n
结果
*101′,“Ben°,*Forta′
*1e2',*Jim*,*Janes*
*1e3′,*Roberta′,*Robertson*
*104′,*Bob′,*Bobson*
分析
[\r]？\n匹配一个可选的\r和一个必不可少的\n。
---
## Page 53
5.2匹配的重复次数
提示细心的读者可能已经注意到了，上面这个例子里的正则
表达式使用的是[\r]？而不是\r？。[\r]定义了一个字符集合，
该集合只有元字符\r这一个成员，因而[\r]?在功能上与\r？
完全等价。【]的常规用法是把多个字符定义为一个集合，但
有不少程序员喜欢把一个字符也定又为一个集合，这么做的好
处是可以增加可读性和避免产生误解，让人们一眼就可以看出
哪个字符与哪个元字符相关联。这里必须提醒大家注意这样一
个细节：如果你打算网时使用[]和？，千万记得应该把？放在
字符集合的外面。具体到刚才那个匹配URL地址的例子，写成
http[s]？://是正确的，若是写成http[s?]://可就并巧成拙
了.
提示？是一个元字符，如果需要匹配？本身，就必须使用它的
转义序列\？。
5.2
匹配的重复次数
正则表达式里的+、*和?解决了许多问题，但有些问题光靠它们还不
够。请思考以下间题。
+和*匹配的字符个数没有上限。我们无法为它们将匹配的字符个
数设定一个最大值。
口+、*和？至少匹配零个或一个字符。我们无法为它们将匹配的字符
个数另行设定一个最小值。
口如果只使用+和*，我们无法把它们将匹配的字符个数设定为一个
精确的数字。
为了解决这些问题并让程序员对重复性匹配有更多的控制，正则表
达式语言提供了一个用来设定重复次数（interval）的语法。重复次数要
用（和}字符来给出，把数值写在它们之间。
---
## Page 54
44第5章重复匹配
它们进行转义。不过，即使你没有对《和）进行转义，大部分正
则表达式实现也能正确地处理它们（根据具体情况把它们解释
为普通字符或元字符）。话虽如此，为了避免不必要的麻烦，
你最好不要依赖这种行为：在需要把（和]当作普通字符来医配
的场合，还是使用它们的转义序列\和\}比较稳妥
5.2.1为重复匹配次数设定一个精确的值
如果你想为重复匹配次数设定一个精确的值，把那个数字写在\{和
)之间即可，比如说，（3}意味着模式里的前一个字符（或字符集合）必
须在原始文本里连续重复出现3次才算是一个匹配：如果只重复了两次，
则不算是一个匹配。
为了演示这种用法，我们再来看一下匹配RGB值的例子（请对照第3
章和第4章里的类似例子）。你应该记得，RGB值是一个十六进制数值，
这个值分成3个部分，每个部分包括两位十六数字。下面是我们在第3章
里用来匹配RGB值的模式：
[e-9A-Fa-f][e-9A-Fa -f][0 -9A-Fa -f][0-9A-Fa -f][0-9A-Fa -f]
[0 -9A·Fa -f]
下面是我们在第4章里用来匹配RGB值的模式，它使用了POSIX字符类：
[[:xdigit: 11t[ :xdigit: 11[[:xdigit: ]1[[:xdigit : 111[:xdigit: ]1[[
 :xdigit : 1]
这两个模式本身并无不妥，但美中不足的是你不得不重复写出6次相
同的字符集合（或POSIX字符类）。下面是一个同样的例子，但我们这次
将使用（}语法来明确指定一个重复次数：
文本
 0 , IHOI3HNI08VW -0 , =HLOIANI9HVI
<,0., =NI08VA1337 .0,NI08MNd01
正则表达式
#[[ :xdigit: 11(6)
---
## Page 55
5.2匹配的重复次数
45
结果
<BODY BGC0L0R*W336633*TEXT-*#FFFFFE
MARGINWIDTH=*e* MARGINHEIGHT=*@*
分析
[：xdigit：]匹配一个十六进制数字，（6}要求这个POSIX字符类必须连
续出现6次。类似地，使用模式#[0-9A-Fa-f]{6}也可以解决这个间题。
5.2.2为重复匹配次数设定一个区间
0语法还可以用来为重复匹配次数设定一个区间，也就是为重复匹配
次数设定一个最小值和一个最大值。这种区间必须以（2，4}这样的形式
给出，（2，4}的含义是最少重复2次、最多重复4次。在下面的例子里，
我们将使用一个这样的正则表达式来检查日期的格式：
文本
4/8/63
10 ·6 ·2004
01-01-01
正则表达式
{[/\-1()p\[/\-1()p
结果
4/8/03
10-6-2004
01-01-01
分析
这里列出的日期是一些由用户通过某个表单字段输入的值，在对这
些日期值做进一步处理之前，我们需要先检查它们的格式是否正确。\d{1