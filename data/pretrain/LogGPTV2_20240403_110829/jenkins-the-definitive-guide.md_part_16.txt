“Configuring a Grails build step”). Here, you provide the Grails target, or targets, you want to execute.
Unlike the command line, you can execute several targets in the same command. However, if you need
to pass any arguments to a particular target, you should enclose the target and its arguments in double
quotes. In Figure 5.50, “Configuring a Grails build step”, for example, we run grails clean, followed
by grails test-app -unit -non-interactive. To get this to work properly, we enclose the
options of the second command in quotes, which gives us grails clean "test-app -unit -
non-interactive".
12 http://wiki.jenkins-ci.org/display/HUDSON/Grails+Plugin
128
Figure 5.50. Configuring a Grails build step
The Grails build step takes many optional parameters. For example, Grails is finicky about versions—
if your project was created by an older version, Grails will ask you to upgrade it. To be on the safe side,
for example, you may want to tick the Force Upgrade checkbox, which makes sure that runs a grails
upgrade --non-interactive before it runs the main targets.
You can also specify the server port (useful if you are executing web tests), and any other properties
you want to pass to the build.
5.10.2. Building Projects with Gradle
Contributed by Rene Groeschke
In comparison to the build tool veterans Ant and Maven, Gradle13 is a relatively new open source build
tool for the Java Virtual Machine. Build scripts for Gradle are written in a Domain Specific Language
(DSL) based on Groovy. Gradle implements convention over configuration, allows direct access to Ant
tasks, and uses Maven-like declarative dependency management. The concise nature of Groovy scripting
lets you write very expressive build scripts with very little code, albeit at the cost of loosing the IDE
support that exists for established tools like Ant and Maven.
There are two different ways to run your Gradle builds with Jenkins. You can either use the Gradle
plugin for Jenkins or the Gradle wrapper functionality.
13 http://gradle.org
129
5.10.2.1. The Gradle plugin for Jenkins
You can install the Gradle plugin in the usual way—just go to the Manage Plugins screen and select the
Jenkins Gradle plugin. Click Install and restart your Jenkins instance.
Once Jenkins has restarted, you will need to configure your new Gradle plugin. You should now find a
new Gradle section in your Configure System screen. Here you will need to add the Gradle installation
you want to use. The process is similar to that used for the other tool installations. First, click the
Add Gradle button to add a new Gradle installation, and enter an appropriate name (see Figure 5.51,
“Configuring the Gradle plugin”). If Gradle has already been installed on your build server, you can
point to the local Gradle home directory. Alternatively, you can use the “Install automatically” feature
to download a Gradle installation, in the form of a ZIP or GZipped TAR file, directly from a URL. You
can use a public URL (see http://gradle.org/downloads.html), or may prefer to make these installations
available on a local server instead.
Figure 5.51. Configuring the Gradle plugin
You typically use Freestyle build jobs to configure your Gradle builds. When you add a build step to a
Freestyle build job, you will now have a new option called “Invoke Gradle script”, which lets you add
Gradle specific settings to your build job.
As an example, here is a very simple Gradle build script. It is a simple Java project that uses a
Maven directory structure and a Maven repository manager. There is a customizable task, called
uploadArchives, to deploy the generated archive to the local Enterprise repository manager:
apply plugin:'java'
apply plugin:'maven'
version='1.0-SNAPSHOT'
group = "org.acme"
repositories{
mavenCentral()
mavenRepo urls: 'http://build.server/nexus/content/repositories/public'
}
130
dependencies{
testCompile "junit:junit:4.8.2"
}
uploadArchives {
repositories.mavenDeployer {
configuration = configurations.archives
repository(url: "http://build.server/nexus/content/repositories/snapshots") {
authentication(userName: "admin", password: "password")
}
}
}
In Figure 5.52, “Setting up a Gradle build job”, we use the just configured “Gradle-0.9RC2” instance
to run this Gradle build. In this case, we want to run the JUnit tests and upload the build artifacts to our
local Maven repository. Furthermore we configure our job to collect the test results from **/build/
test-results, the default directory for storing test results in Gradle.
5.10.2.2. Incremental builds
While running a Gradle build job with unchanged sources, Gradle runs its builds incremental. If the
output of a Gradle task is still available and the sources haven’t changed since the last build, Gradle
is able to skip the task execution and marks the according task as up-to-date. This incremental build
feature can decrease the duration of a running build job considerably.
If Gradle evaluates the test task as up-to-date even the execution of your unit tests is skipped. This
can cause problems when running your Gradle build with Jenkins. In our sample build job above we
configured a post build action to publish the JUnit reports of our build. If the test task is skipped by
Gradle, the Jenkins job will be marked as failed with the following message:
Test reports were found but none of them are new. Did tests run?
You can easily fix this by invalidating the output and force a re-execution of your tests by adding the
following snippet to your Gradle file:
test {
outputs.upToDateWhen { false }
}
131
Figure 5.52. Setting up a Gradle build job
After adding the snippet above to your build file, your job console output should look like the one in
Figure 5.53, “Incremental Gradle job”.
Figure 5.53. Incremental Gradle job
As you can see, all of the tasks except test and uploadArchives have been marked as up-to-date and
not executed.
5.10.3. Building Projects with Visual Studio MSBuild
Jenkins is a Java application, but it also provides excellent support for .NET projects.
To build .NET projects in Jenkins, you need to install the MSBuild plugin14.
14 http://wiki.jenkins-ci.org/display/HUDSON/MSBuild+Plugin
132
You may also want to install the MSTest plugin15 and the NUnit plugin16, to display your test results.
Once you have installed the .NET plugins and restarted Jenkins, you need to configure your .NET build
tools. Go to the Configure System page and specify the path of the MSBuild executable (see Figure 5.54,
“Configuring .NET build tools in Jenkins”).
Figure 5.54. Configuring .NET build tools in Jenkins
Once you have this set up, you can return to your freestyle project and add your .NET build step
configuration.
Go to the Build section and choose “Build a Visual project or solution using MSBuild” option in the
Add Build Step menu. Then enter the path to your MSBuild build script (a .proj or .sln file), along
with any command-line options your build requires (see Figure 5.55, “A build step using MSBuild”).
Figure 5.55. A build step using MSBuild
5.10.4. Building Projects with NAnt
Another way to build your .NET projects is to use NAnt. NAnt is a .NET version of the Ant build
scripting tool widely used in the Java world. NAnt build scripts are XML files (typically with a .build
extension), with a very similar format to Ant build scripts.
To build with NAnt in Jenkins, you need to install the Jenkins NAnt plugin17. Once you have installed
the plugin and restarted Jenkins, go to the Configure System page and specify the NAnt installation
directory in the Nant Builders section (see Figure 5.54, “Configuring .NET build tools in Jenkins”).
15 http://wiki.jenkins-ci.org//display/HUDSON/MSTest+Plugin
16 http://wiki.jenkins-ci.org//display/HUDSON/NUnit+Plugin
17 http://wiki.jenkins-ci.org/display/HUDSON/NAnt+Plugin
133
Now go to the Build section of your freestyle project and choose “Execute NAnt build” (see Figure 5.56,
“A build step using NAnt”). Here you specify your build script and the target you want to invoke. If you
click on the “Advanced...” option, you can also set property values to be passed into the NAnt script.
Figure 5.56. A build step using NAnt
5.10.5. Building Projects with Ruby and Ruby on Rails
Jenkins makes an excellent choice when it comes to integrating CI into your Ruby and Ruby on Rails
projects. The Rake Plugin lets you add Rake build steps to your build jobs. You can also use the Ruby
Plugin lets you run Ruby scripts directly in your build job. Finally, the Ruby Metrics Plugin provides
support for Ruby code quality metrics tools such as RCov, Rails stats, and Flog.
Another invaluable tool in this area is CI:Reporter. This library is an add-on to Test::Unit, RSpec,
and Cucumber that generates JUnit-compatible XML reports for your tests. As we will see, JUnit-
compatible test results can be used directly by Jenkins to report on your test results. You would install
CI:Reporter using Gem as illustrated here:
$ sudo gem install ci_reporter
Successfully installed ci_reporter-1.6.4
1 gem installed
Next, you will need to set this up in your Rakefile, by adding the following:
require 'rubygems'
gem 'ci_reporter'
require 'ci/reporter/rake/test_unit' # use this if you're using Test::Unit
In Chapter 9, Code Quality, we discuss integrating code quality metrics into your Jenkins builds. Jenkins
also provides support for code coverage metrics in Ruby. The Ruby Metrics Plugin supports code
coverage metrics using rcov as well as general code statistics with Rails stats. To install the rcov-
plugin, you will first need to run something along the following lines:
$ ./script/plugin install http://svn.codahale.com/rails_rcov
Once this is set up, you will be able to display your test results and test result trend in Jenkins.
Finally, you can configure a Rake build simply by using a Rake build step, as illustrated in Figure 5.57,
“A build step using Rake”.
134
Figure 5.57. A build step using Rake
You also need to configure Jenkins to report on the test and quality metrics results. You can do this by
activating the “Publish JUnit test result report”, “Publish Rails stats report”, and “Public Rcov report”
options (see Figure 5.58, “Publishing code quality metrics for Ruby and Rails”). The JUnit XML reports
will be found in the results directory (enter results/*.xml in the “Test report XMLs” field), and
the Rcov date in the coverage/units directory.
135
Figure 5.58. Publishing code quality metrics for Ruby and Rails
5.11. Conclusion
In this chapter we have covered the basics of creating new build jobs for the most common cases you are
likely to encounter. Later on in the book, we will build on these foundations to discuss more advanced
options such as parameterized builds, matrix builds, and build promotion strategies.
136
Chapter 6. Automated Testing
6.1. Introduction
If you aren’t using automated tests with your Continuous Integration setup, you’re really missing out
on something big. Believe me—CI without automated tests is really just a small improvement on
automatically scheduled builds. Now don’t get me wrong, if you’re coming from nothing, that’s already a
great step forward—but you can do much better. In short, if you are using Jenkins without any automated
tests, you are not getting anywhere near as much value out of your Continuous Integration infrastructure
as you should.
One of the basic principles of Continuous Integration is that a build should be verifiable. You have to be
able to objectively determine whether a particular build is ready to proceed to the next stage of the build
process, and the most convenient way to do this is to use automated tests. Without proper automated
testing, you find yourself having to retain many build artifacts and test them by hand, which is hardly
in the spirit of Continuous Integration.
There are many ways you can integrate automated tests into your application. One of the most efficient
ways to write high quality tests is to write them first, using techniques such as Test-Driven Development
(TDD) or Behavior-Driven Development (BDD). In this approach, commonly used in many Agile
projects, the aim of your unit tests is to both clarify your understanding of the code’s behavior and
to write an automated test that the code does indeed implement this behavior. Focusing on testing the
expected behavior, rather than the implementation, of your code also makes for more comprehensive
and more accurate tests, and thus helps Jenkins to provide more relevant feedback.
Of course, more classical unit testing, done once the code has been implemented, is also another
commonly-used approach, and is certainly better than no tests at all.
Jenkins is not limited to unit testing, though. There are many other types of automated testing that
you should consider, depending on the nature of your application, including integration testing, web
testing, functional testing, performance testing, load testing and so on. All of these have their place in
an automated build setup.
Jenkins can also be used, in conjunction with techniques like Behavior-Driven Development and
Acceptance Test Driven Development, as a communications tool aimed at both developers and other
project stakeholders. BDD frameworks such as easyb, fitnesse, jbehave, rspec, Cucumber, and many
others, try to present acceptance tests in terms that testers, product owners, and end users can understand.
With the use of such tools, Jenkins can report on project progress in business terms, and so facilitate
communication between developers and non-developers within a team.
For existing or legacy applications with little or no automated testing in place, it can be time-consuming
and difficult to retro-fit comprehensive unit tests onto the code. In addition, the tests may not be very
effective, as they will tend to validate the existing implementation rather than verify the expected
business behavior. One useful approach in these situations is to write automated functional tests
(“regression”) tests that simulate the most common ways that users manipulate the application. For
example, automated web testing tools such as Selenium and WebDriver can be effectively used to test
web applications at a high level. While this approach is not as comprehensive as a combination of good
quality unit, integration and acceptance tests, it is still an effective and relatively cost-efficient way to
integrate automated regression testing into an existing application.
In this chapter, we will see how Jenkins helps you keep track of automated test results, and how you
can use this information to monitor and dissect your build process.
6.2. Automating Your Unit and Integration Tests
The first thing we will look at is how to integrate your unit tests into Jenkins. Whether you are practicing
Test-Driven Development, or writing unit tests using a more conventional approach, these are probably
the first tests that you will want to automate with Jenkins.
Jenkins does an excellent job of reporting on your test results. However, it is up to you to write the
appropriate tests and to configure your build script to run them automatically. Fortunately integrating
unit tests into your automated builds is generally relatively easy.
There are many unit testing tools out there, with the xUnit family holding a predominant place. In
the Java world, JUnit is the de facto standard, although TestNG is another popular Java unit testing
framework with a number of innovative features. For C# applications, the NUnit testing framework
proposes similar functionalities to those provided by JUnit, as does Test::Unit for Ruby. For C/C+
+, there is CppUnit, and PHP developers can use PHPUnit. And this is not an exhaustive list!
These tools can also serve for integration tests, functional tests, web tests and so forth. Many web testing
tools, such as Selenium, WebDriver, and Watir, generate xUnit-compatible reports. Behaviour-Driven
Development and automated Acceptance-Test tools such as easyb, Fitnesse, Concordion are also xUnit-
friendly. In the following sections we make no distinction between these different types of test, as, from
a configuration point of view, they are treated by Jenkins in exactly the same manner. However, you
will almost certainly need to make the distinction in your build jobs. In order to get the fastest possible
feedback loop, your tests should be grouped into well-defined categories, starting with the fast-running
unit tests, and then proceeding to the integration tests, before finally running the slower functional and
web tests.
A detailed discussion of how to automate your tests is beyond the scope of this book, but we do cover
a few useful techniques for Maven and Ant in the Appendix A, Automating Your Unit and Integration
Tests.
138
6.3. Configuring Test Reports in Jenkins
Once your build generates test results, you need to configure your Jenkins build job to display them.
As mentioned above, Jenkins will work fine with any xUnit-compatible test reports, no matter what
language they are written in.
For Maven build jobs, no special configuration is required—just make sure you invoke a goal that will
run your tests, such as mvn test (for your unit tests) or mvn verify (for unit and integration tests).
An example of a Maven build job configuration is shown in Figure 6.1, “You configure your Jenkins
installation in the Manage Jenkins screen”.
Figure 6.1. You configure your Jenkins installation in the Manage Jenkins screen
For freestyle build jobs, you need to do a little more configuration work. In addition to ensuring that
your build actually runs the tests, you need to tell Jenkins to publish the JUnit test report. You configure
this in the “Post-build Actions” section (see Figure 6.2, “Configuring Maven test reports in a freestyle
project”). Here, you provide a path to the JUnit or TestNG XML reports. Their exact location will
depend on a project—for a Maven project, a path like **/target/surefire-reports/*.xml will
find them for most projects. For an Ant-based project, it will depend on how you configured the Ant
JUnit task, as we discussed above.
139
Figure 6.2. Configuring Maven test reports in a freestyle project
For Java projects, whether they are using JUnit or TestNG, Jenkins does an excellent job out of the box.
If you are using Jenkins for non-Java projects, you might need the xUnit Plugin. This plugin lets Jenkins
process test reports from non-Java tools in a consistent way. It provides support for MSUnit and NUnit
(for C# and other .NET languages), UnitTest++ and Boost Test (for C++), PHPUnit (for PHP), as well
as a few other xUnit libraries via additional plugins (see Figure 6.3, “Installing the xUnit plugin”).
Figure 6.3. Installing the xUnit plugin
Once you have installed the xUnit Plugin, you will need to configure the reporting for your particular
xUnit reports in the “Post-build Actions” section. Check the “Publish testing tools result report”
checkbox, and enter the path to the XML reports generated by your testing library (see Figure 6.4,
“Publishing xUnit test results”). When the build job runs, Jenkins will convert these reports to JUnit
reports so that they can be displayed in Jenkins.
140
Figure 6.4. Publishing xUnit test results
6.4. Displaying Test Results