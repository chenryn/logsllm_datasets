2.3深入理解各个层次
27
●Activity
简单地说，Activity是种面向用户的应用组件或用户界面（UI）。Activity基于Activity
基类，包括一个窗口和相关的UI元素。Activity的底层管理是由被称为Activity管理服务（Activity
Manager）的组件来进行处理的，这一组件也处理应用之间或应用内部用于调用Acivity的发送
Intent。这些Activity在应用的 Manifest文件中定义，具体如下：
2
...
android:name=*com yougetitback,androidapplication.ReportSplashScreen*
android:names*com.yougetitback.androidapp1ication.SplashScreen*
这里，我们可以看到Activity的定义，以及对样式/UI、屏幕方向等信息的指定。其中
1aunchMode属性值得关注，因为它会影响Activity的启动方式。在这种情况下，singleTask
值表示在同一时间只能有一个特定Activity实例存在，面不是每次调用时启动一个单独的实例。
这一应用的当前实例（如果有的话）将接收并处理调用该Activity的Intent。
● Broadcast Receiver
另一种类型的IPC端点是BroadcastReceiver。它们通常会在应用希望接收一个匹配某种特定
标准的隐式Intent时出现。例如，一个应用想要接收与短消息关联的Intent，它需要在Manifest
文件中注册个Receiver，使用Intent Filter 来匹配android.provider.Telephony.SMS_
RECEIVED 动作。
注意Broadcast Receiver也可以使用registerReceiver方法在运行时以编程方式注册，这个
方法可以被重载以对Receiver设置权限。
在BroadcastReceiver上设置权限要求可以限定哪些应用能够往这个端点发送Intent。
·Service
Service是一类在后台运行而无需用户界面的应用组件，用户不用直接与Service所属应用进
---
## Page 44
28第2章Android的安全设计与架构
行交互。Android系统上一些常见的 Service例子包括 SmsReceiverService和 BluetoothOpp
Service。虽然这些 Service 都运行在用户直接可见视图之外，但与其他Android应用组件一样，
它们也可以利用IPC机制来发送和接收Intent。
Service必须在应用的 Manifest文件中声明，例如，以下是一个 Service的简单定义，同时设
置了 Intent Filter:
android:name=*com.yougetitback,androidapplication.FindLocat.ionService*>
cservice
android:name=*com-yougetitback,androidapplicatLon.FindLocationServi.ce* />
该应用声明了一个名为MyProvider的 Content Provider，对应于实现Provider功能的类。
然后，它声明了—个名为com.wiley.example.permission.wRITe 的 writePermission,
表明只有携带这一自定义权限的应用才能写人这个Provider。最后，它指明了Provider将采取动作
的authorities或内容统—资源描述符（URI）。Content URI采用content：//[authorityname]
的格式，可以额外包含路径和参数信息（如content：//com.wiley.example，data/foo），面这
些信息对Provider的底层实现可能非常关键。
在第4章中，我们将展示一系列发现和攻击这些IPC端点的手段。
2.3.2Android框架层
作为应用和运行时之间的连接纽带，Android框架层为开发者提供了执行通用任务的部件
程序包及其类。这些任务可能包括管理UI元素、访问共享数据存储，以及在应用组件中传递消息
等。也就是说，框架层中包含任何仍然在DalvikVM中执行的非应用特定代码。
---
## Page 45
2.3深入理解各个层次29
通用的框架层程序包位于android.*名字空间中，如android.content 或android.
telephony。Android也提供了许多Java标准类（在java.*和的javax，*名字空间中），以及
一些第三方程序包，如Apache HTTP客户端库和SAXXML解析器。Android框架层还包括许多
用于管理内部类所提供功能的服务。这些被称为管理器的服务由system_server（将在2.3.3
节“Zygote”小节中讨论）在系统初始化之后启动。表2-1显示了其中的一些服务器，以及它们
2
在框架层中的描述与角色。
表2-1框架层中的管理器
框架层服务
描述
管理 Imtemt的解析与目标，应用/Activity的启动等
视图系统
管理Activity中的视图（用户可见的 UI组合）
程序包管理器
管理系统上之前或正在进入安装队列的程序包相关信息
电话管理器
管理与电话服务、无线电状态、网络与注册信息相关的信息与任务
资源管理器
为诸如图形、U1布局、字符串数据等非代码应用资源提供访问
位置管理器
提供设置和读取（GPS、手机、Wi-Fi）位置信息的接口，位置信息包括具体定位信息、经纬度等
通知管理器
管理不同的事件通知，比如播放声音，震动，LED闪灯，以及在状态栏中显示图标等
使用ps命令，并指明system_server的PID和-t选项，可以从结果中看到一些管理器是
以system_server进程中的线程运行的。
94C d- 3- sd 8/1oTzeueBe2003
USER
PID
aIdd
NAKE
system
376
2S
- - -
- * *
68E
376
390
94
...
SensorService
system
system
391
96
ActivityManager
system
+ 1 :
66
376
... PackageManager
2.3.3 DalvikVM
DalvikVM是基于寄存器面不是栈的。虽然有人说Dalvik是基于Java的，但它并不是Java，
因为谷歌并不使用Java 的Logo，而且Android的应用模型也与JSR（Java标准规范要求）没有
关系。Android应用开发者要记住，DalvikVM虽然看起来和感觉上都像Java，但实际上并不是。
整体的开发流程大致如下：
(1)开发者以类似Java的语法进行编码；
（2）源代码被编译成class文件（也类似于Java）；
(3）得到的类文件被翻译成Dalvik字节码；
（4）所有类文件被合并为一个Dalvik可执行文件（DEX）文件；
（5）字节码被DalvikVM加载并解释执行。
作为一个基于寄存器的虚拟机，Dalvik拥有大约64000个虚拟寄存器。不过通常只会用到最
---
## Page 46
30第2章Android的安全设计与架构
前16个、偶尔会用到前256个。这些寄存器被指定为虚拟机内存的存储位置，用于模拟微处理
器的寄存器功能。就像实际的微处理器一样，DalviVM在执行字节码时，使用这些寄存器来保
持运行状态，并跟踪一些值。
DalvkVM是专门针对嵌人式系统的约束（如内存小和处理器速度慢）面设计的。因此，在
DalvikVM设计时考虑到了速度和运行效率。但虚拟机毕竞只是对底层CPU寄存器机的一个抽象，
本质上就意味着在运行效率上有所损失，面这也正是谷歌力求减轻这些副作用的原因。
为了在这些约束中发挥更大的能力，DEX文件在被虚拟机解释执行之前会进行优化处理。
对于从一个Android应用中启动的DEX文件，这种优化通常只在应用第一次启动时进行一次。
优化过程的结果是一个优化后的DEX文件（ODEX）。需要注意，ODEX文件是无法在不同版本
的DalvkVM之间或是不同设备之间进行移植的。
与Java虚拟机类似，DalvikVM使用Java Native Interface（JNI）与底层原生代码进行交互。
这一功能允许在Davik代妈和原生代码之间相互调用欲了解DavikVMDEX文件格式以及JNI
onAndroid 的更详细信息，可查阅Dalvik官方文档，网址为http://milk.com/kodebase/dalvik-docs-
mirror/docs/。
Zygote
Android设备启动时，Zygote进程是最先运行的进程之一。接下来，Zygote负责启动其他服
务以及加载Android框架所使用的程序库。然后，Zygote进程作为每个Dalvik进程的加载器，通
过复制自身进程副本（也被称为forking，分支）来创建进程。这种优化方案可以避免重复那些
不必要且消耗大量资源的加载过程，即启动Dalvik进程（包括应用）时加载Android框架及其依
赖库。作为优化结果，核心库、核心类和对应的堆结构会在DalvkVM的所有实例之间共享。这
也给攻击带来了一些有趣的可能性，你会在第12章中阅读到更详细的内容。
Zygote的第二大功能是启动system_server进程，这个进程容纳了所有系统核心服务，并
在system的AID用户环境中以特权权限运行。接下来，system_server进程启动所有在表2-1
中介绍的Android框架层服务。
注意system_server进程是如此重要，以致杀死这一进程会让设备看上去像重新启动了一
样。然而，实际上只是将设备的Dalvik子系统重新启动了。
在初始启动后，Zygote通过RPC和IPC机制为其他Dalvik进程提供程序库访问，这是承载
Android应用组件的进程实际启动的机制。
2.3.4用户空间原生代码层
操作系统用户空间内的原生代码构成了Android系统的一大部分，这一层主要由两大类组件
构成：程序库和核心系统服务。本节将讨论这两大类组件，并详述一些属于这两大类的单独组件。
1.程序库
Android框架层中的较高层次类所依赖的许多底层功能都是通过共享程序库的方式来实现、
---
## Page 47
2.3深入理解各个层次31
并通过JINI进行访问的。在这其中，许多程序库都也是在其他类Unix系统中所使用的知名开源
项目。比如，SQLite提供了本地数据存储功能，Webkit提供了可嵌入的Web 浏览器引擎，FrceType
提供了位图和矢量字体谊染功能。
供应商特定的程序库，即那些为某一设备型号提供硬件支持的代码库，保存在/vendor/lib（或
/system/vendor/lib）路径。其中包括对图形显示设备、GPS收发器或蜂窝式无线电的底层支持库
等。非厂商特定的程序库则保存在/system/lib路径中，通常会包括一些外部项目，比如像下面这
些库。
libexif：一个JPEG EXIF格式的处理库。
 libexpat; Expat 的 XML 解析器。
 libaudioalsa/libtinyalsa:ALSA音频库。
 libbluetooth：BlueZ Linux 蓝牙库。