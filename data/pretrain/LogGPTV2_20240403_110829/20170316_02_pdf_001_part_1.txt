The decNumber C library
23rd January 2010
Mike Cowlishaw
IBM Fellow
IBM UK Laboratories
PI:EMAIL
Version 3.68
Copyright © IBM Corporation 2010. All rights reserved.
Table of Contents
Overview 5
User’s Guide 9
Example 1 – simple addition 11
Example 2 – compound interest 12
Example 3 – passive error handling 13
Example 4 – active error handling 14
Example 5 – compressed formats 16
Example 6 – Packed Decimal numbers 18
Example 7 – Using the decQuad module 19
Example 8 – Using decQuad with decNumber 20
Module descriptions 21
decContext module 22
Definitions 24
Functions 25
decNumber module 30
Definitions 32
Functions 32
Conversion functions 33
Arithmetic and logical functions 34
Utility functions 41
decimal32, decimal64, and decimal128 modules 48
Definitions 48
Functions 49
decFloats modules 52
Definitions 53
Functions 53
decPacked module 67
Definitions 67
Functions 67
Additional options 69
Customization parameters 70
Tuning parameters 71
Print and testing parameters 72
Appendix A – Library performance 73
Description of the tables 73
Version 3.68 3
decDouble performance tables 74
decQuad performance tables 76
Notes 77
Appendix B – Changes 79
Index 87
4 Version 3.68
Overview
The decNumber library implements the General Decimal Arithmetic Specification1 in ANSI C. This
specification defines a decimal arithmetic which meets the requirements of commercial, financial, and
human-oriented applications. It also matches the decimal arithmetic in the IEEE 754 Standard for
Floating Point Arithmetic.2
The library fully implements the specification, and hence supports integer, fixed-point, and floating-
point decimal numbers directly, including infinite, NaN (Not a Number), and subnormal values. Both
arbitrary-precision and fixed-size representations are supported.
The arbitrary-precision code is optimized and tunable for common values (tens of digits) but can be
used without alteration for up to a billion digits of precision and 9-digit exponents. It also provides
functions for conversions between concrete representations of decimal numbers, including Packed
BCD (4-bit Binary Coded Decimal) and the three primary IEEE 754 fixed-size formats of decimal
floating-point (decimal32, decimal64, and decimal128).
The three fixed-size formats are also supported by three modules called decFloats (see page 52), which
have an extensive set of functions that work directly from the formats and provide arithmetical,
logical, and shifting operations, together with conversions to binary integers, Packed BCD, and 8-bit
BCD. Most of the functions defined in IEEE 754 are included, together with other functions outside
the scope of that standard but essential for a decimal-only language implementation.
Library structure
The library comprises several modules (corresponding to classes in an object-oriented
implementation). Each module has a header file (for example, decNumber.h) which defines its data
structure, and a source file of the same name (e.g., decNumber.c) which implements the operations
on that data structure. These correspond to the instance variables and methods of an object-oriented
design.
The core of the library is the decNumber module. This uses an arbitrary-precision decimal number
representation designed for efficient computation in software and implements the arithmetic and
logical operations, together with a number of conversions and utilities. Once a number is held as a
decNumber, no further conversions are necessary to carry out arithmetic.
Most functions in the decNumber module take as an argument a decContext structure, which provides
the context for operations (precision, rounding mode, etc.) and also controls the handling of
exceptional conditions (corresponding to the flags and trap enablers in a hardware floating-point
implementation).
1 See http://speleotrove.com/decimal/ for details.
2 Approved June 2008, expected to be published later in the year.
Version 3.68 Overview 5
The decNumber representation is variable-length and machine-dependent (for example, it contains
integers which may be big-endian or little-endian).
In addition to the arbitrary-precision decNumber format, three fixed-size compact formats are
provided for conversions and interchange.3 These formats are endian-dependent but otherwise are
machine-independent:
decimal32 a 32-bit decimal floating-point representation which provides 7 decimal digits of
precision in a compressed format
decimal64 a 64-bit decimal floating-point representation which provides 16 decimal digits of
precision in a compressed format
decimal128 a 128-bit decimal floating-point representation which provides 34 decimal digits of
precision in a compressed format.
A fourth, machine-independent, Binary Coded Decimal (BCD) format is also provided:
decPacked The decPacked format is the classic packed decimal format implemented by IBM S/360
and later machines, where each digit is encoded as a 4-bit binary sequence (BCD) and a
number is ended by a 4-bit sign indicator. The decPacked module accepts variable
lengths, allowing for very large numbers (up to a billion digits), and also allows the
specification of a scale.
The module for each format provides conversions to and from the core decNumber format. The
decimal32, decimal64, and decimal128 modules also provide conversions to and from character string
format.
The decimal32, decimal64, and decimal128 formats are also supported directly by three modules
which can be used stand-alone (that is, they have no dependency on the decNumber module). These
are:
decSingle a module that provides the functions for the decimal32 format; this format is intended for
storage and interchange only and so the module provides utilities and conversions but no
arithmetic functions
decDouble a module that provides the functions for the decimal64 format; this format is an IEEE
754 basic format and so a full set of arithmetic and other functions is included
decQuad a module that provides the functions for the decimal128 format; this format is an IEEE
754 basic format; it contains the same set of functions as decDouble.4
These modules use the same context mechanism (decContext) as decNumber and so can be used
together with the decNumber module when required in order to use the mathematical functions in that
module or to use its arbitrary-precision capability. Examples are included in the User’s Guide (see
page 9).
Relevant standards
It is intended that, where applicable, functions provided in the decNumber package follow the
requirements of:
• the decimal arithmetic requirements of IEEE 754 except that:
3 See http://speleotrove.com/decimal/decbits.html for details of the formats.
4 Except for two which convert to or from a wider format.
6 Overview Version 3.68
1. the IEEE remainder operator (decNumberRemainderNear) is restricted to those values where
the intermediate integer can be represented in the current precision, because the conventional
implementation of this operator would be very long-running for the range of numbers
supported (up to ±101,000,000,000).
2. the mathematical functions in the decNumber module do not, in general, correspond to the
recommended functions in IEEE 754 with the same or similar names; in particular, the power
function has some different special cases, and most of the functions may be up to one unit
wrong in the last place (note, however, that the squareroot function is correctly rounded)
• the floating-point decimal arithmetic defined in ANSI X3.274-19965 (including errata through
2001); note that this applies to functions in the decNumber module only, with appropriate
context.
Please advise the author of any discrepancies with these standards.
5 American National Standard for Information Technology – Programming Language REXX, X3.274-1996, American
National Standards Institute, New York, 1996.
Version 3.68 Overview 7
User’s Guide
To use the decNumber library efficiently it is best to first convert the numbers you are working with
from strings or another coded representation into decNumber format, then carry out calculations on
them, and finally convert them back into the desired string or coded format.
Conversions to and from the decNumber format are fast; they are usually faster than all but the
simplest calculations (x=x+1, for example). Therefore, in general, the cost of conversions is small
compared to that of calculation.
The coded formats currently provided for in the library are
• strings (ASCII bytes, terminated by '\0', as usual for C)
• three formats of compressed floating-point decimals
• Packed Decimal numbers with optional scale.
However, when arbitrary-precision calculation is not required (that is, up to 34 digits of precision is all
that is required) it is even more efficient to use one of the decFloats modules (see page 52) for
arithmetic and other operations. The decFloats modules work directly from the decimal-encoded
compressed formats and avoid the need for conversions to and from the decNumber format. Tables
comparing the performance of the decFloats modules with decNumber can be found in Appendix A
(see page 73).
The remainder of this section illustrates the use of the coded formats and the decFloats modules in
conjunction with the core decContext and decNumber modules by means of examples.
Notes on running the examples
1. All the examples are written conforming to ANSI C, except that they use “line comment”
notation (comments starting with //) from BCPL and C++ for more concise commentary. Most
C compilers support this; if not, a short script can be used to convert the line comments to
traditional block comments (/* ... */). Note that the decNumber header files use only block
comments so do not require conversion.
2. Some pieces of the decNumber package are sensitive to the whether the underlying platform is
big-endian or little-endian; for a big-endian machine, set the DECLITEND tuning parameter (see
page 70) to 0.
The code provided for the first and seventh examples (example1.c and example7.c) includes
a call to the decContextTestEndian routine, which will display a warning if DECLITEND is set
incorrectly.
3. The header files and Example 6 use the standard integer types from stdint.h described in the
Version 3.68 User’s Guide 9
ANSI C99 standard (ISO/IEC 9899:1999). If your C compiler does not supply stdint.h, the
following will suffice:
/* stdint.h -- some standard integer types from C99 */
typedef unsigned char uint8_t;
typedef char int8_t;
typedef unsigned short uint16_t;
typedef short int16_t;
typedef unsigned int uint32_t;
typedef int int32_t;
typedef unsigned long long uint64_t;
typedef long long int64_t;
You may need to change these if (for example) the int type in your compiler does not describe
a 32-bit integer. If there are no 64-bit integers available with your compiler, set the DECUSE64
tuning parameter (see page 70) to 0; the last two typedefs above are then not needed.
4. One aspect of the examples is implementation-defined. It is assumed that the default handling
of the SIGFPE signal is to end the program. If your implementation ignores this signal, the lines
with set.traps=0; would not be needed in the simpler examples.
10 User’s Guide Version 3.68
Example 1 – simple addition
This example is a simple test program which can easily be extended to demonstrate more complicated
operations or to experiment with the functions available.
1. // example1.c -- convert the first two argument words to decNumber,
2. // add them together, and display the result
3.
4. #define DECNUMDIGITS 34 // work with up to 34 digits
5. #include "decNumber.h" // base number library
6. #include  // for printf
7.
8. int main(int argc, char *argv[]) {
9. decNumber a, b; // working numbers
10. decContext set; // working context
11. char string[DECNUMDIGITS+14]; // conversion buffer
12.
13. if (argc %s\n", argv[1], argv[2], string);
26. return 0;
27. } // main
This example is a complete, runnable program. In later examples we’ll leave out some of the
“boilerplate”, checking, etc., but this one should compile and be usable as it stands.
Lines 1 and 2 document the purpose of the program.
Line 4 sets the maximum precision of decNumbers to be used by the program, which is used by the
embedded header file in line 5 (and also elsewhere in this program).
Line 6 includes the C library for input and output, so we can use the printf function. Lines 8 through
11 start the main function, and declare the variables we will use. Lines 13 through 16 check that
enough argument words have been given to the program.
Lines 17–19 initialize the decContext structure, turn off error signals, and set the working precision to
the maximum possible for the size of decNumbers we have declared.
Lines 21 and 22 convert the first two argument words into numbers; these are then added together in
line 23, converted back to a string in line 24, and displayed in line 25.
Note that there is no error checking of the arguments in this example, so the result will be NaN (Not a
Number) if one or both words is not a number. Error checking is introduced in Example 3 (see page
13).
Version 3.68 User’s Guide 11
Example 2 – compound interest
This example takes three parameters (initial amount, interest rate, and number of years) and calculates
the final accumulated investment. For example:
100000 at 6.5% for 20 years => 352364.51
The heart of the program is:
1. decNumber one, mtwo, hundred; // constants
2. decNumber start, rate, years; // parameters
3. decNumber total; // result
4. decContext set; // working context
5. char string[DECNUMDIGITS+14]; // conversion buffer
6.
7. decContextDefault(&set, DEC_INIT_BASE); // initialize
8. set.traps=0; // no traps
9. set.digits=25; // precision 25
10. decNumberFromString(&one, "1", &set); // set constants
11. decNumberFromString(&mtwo, "-2", &set);
12. decNumberFromString(&hundred, "100", &set);
13.
14. decNumberFromString(&start, argv[1], &set); // parameter words
15. decNumberFromString(&rate, argv[2], &set);
16. decNumberFromString(&years, argv[3], &set);
17.
18. decNumberDivide(&rate, &rate, &hundred, &set); // rate=rate/100
19. decNumberAdd(&rate, &rate, &one, &set); // rate=rate+1
20. decNumberPower(&rate, &rate, &years, &set); // rate=rate**years
21. decNumberMultiply(&total, &rate, &start, &set); // total=rate*start
22. decNumberRescale(&total, &total, &mtwo, &set); // two digits please
23.
24. decNumberToString(&total, string);
25. printf("%s at %s%% for %s years => %s\n",
26. argv[1], argv[2], argv[3], string);
27. return 0;
These lines would replace the content of the main function in Example 1 (adding the check for the