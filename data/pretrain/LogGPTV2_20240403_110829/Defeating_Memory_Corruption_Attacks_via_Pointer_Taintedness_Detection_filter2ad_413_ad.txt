### Synthetic Vulnerable Programs

The effectiveness of the proposed approach is first demonstrated using a set of synthetic functions that are vulnerable to stack buffer overflow, heap corruption, and format string attacks, respectively. These functions and their corresponding attacks were illustrated in Figure 2.

#### Detection of Stack Buffer Overflow
When a string of 24 "a" characters is passed to `exp1()` running on our architecture, an alert is raised at the return instruction (i.e., `JR $31` on SimpleScalar) of `exp1()`. This indicates that the return address has been tainted with `0x61616161`, corresponding to four "a" characters in the input.

#### Detection of Heap Corruption
Function `exp2()` contains a heap overflow vulnerability. An attack is launched by inputting 12 "a" characters into an 8-byte buffer. When the buffer is freed, a load-word instruction `LW $3,0($3)` in `free()` raises an alert. As described in Section 3, a statement executed in `free()` is `B->fd->bk = B->bk`. When the alert is generated, register `$3` equals `B->fd`, which is a tainted word `0x61616161` due to the buffer overflow condition. The detected instruction attempts to dereference register `$3` (i.e., the `0($3)` indirect addressing mode) when its value is tainted, thus raising the alert.

#### Detection of Format String Attack
The effectiveness of detecting format string attacks is demonstrated by `exp3()`. This function receives the string `abcd%x%x%x%n` from the socket. When `printf()` is called, a store-word instruction `SW $21,0($3)` in `vfprintf()` raises an alert. This store instruction is compiled from the statement `*ap = count` described in Section 3, where the value of `ap` is in register `$3` and the value of `count` is in register `$21`. When the alert is raised, the value of register `$3` in `0($3)` dereference is `0x64636261`, corresponding to the first four bytes of the input string, "abcd".

### Real-World Network Applications

The three examples discussed in the previous section demonstrate that pointer taintedness detection can defeat many types of memory corruption attacks. This section presents results from testing real-world attacks against network applications augmented with pointer taintedness detection capability. Additionally, the SimpleScalar processor simulator is extended to support network socket applications, allowing us to run many real-world network server applications. Both control data attacks and non-control data attacks are used for the evaluations. The pointer taintedness detection technique successfully defeats both types of attacks.

#### WU-FTPD Format String Attack
Washington University FTP Daemon (WU-FTPD) is one of the most widely used FTP servers. The Site Exec Command Format String Vulnerability [14] allows attackers to overwrite an arbitrary memory location. We constructed a non-control data attack where the format string vulnerability is exploited to overwrite an integer word representing the ID of the login user. This is sufficient to escalate the attacker's privilege to root, providing full control over the file `/etc/passwd` and enabling the attacker to upload a different version of this file. After writing a malicious entry such as `alice:x:0:0::/home/root:/bin/bash` in the new version, the attacker leaves a backdoor to log in later as Alice, who possesses root privileges. Since the attack does not corrupt any control data, it is undetectable by existing techniques.

WU-FTPD runs on the proposed architecture. Table 2 shows the attack/detection steps. When the FTP server is ready to accept user input, the attacker (the FTP client) first authenticates to the server using `USER` and `PASS` commands, then issues a `SITE EXEC` command to exploit the vulnerability. The target integer word representing the user ID is located at address `0x1002bc20`, so the command used to overwrite this word is:
```
site exec \x20\xbc\x02\x10%x%x%x%x%x%x%n
```
Immediately after the attack sends the malicious `SITE EXEC` command, the pointer taintedness detector raises an alert because the instruction `SW $21,0($3)` dereferences a tainted value in register `$3`. The value of the register is `0x1002bc20`, the same as the one specified by the attacker as the target address to overwrite. The FTP server is stopped when the alert is raised, effectively preventing the attack from succeeding.

#### Null HTTPD Heap Corruption Attack
Null HTTPD is a multithreaded web server for Linux. A heap overflow vulnerability has been reported in this application [14]. This vulnerability is triggered when an attacker sends a `POST` command with a negative `Content-Length` field in its HTTP header. Due to misinterpretation of the negative number, the size of a heap buffer is incorrectly calculated, leading to a buffer overflow attack. Known attack programs overwrite control data when the overflowed heap buffer is freed, hijacking the control flow of the HTTP server. We found an effective non-control data attack that overwrites the CGI-BIN path configuration. In HTTP servers with CGI (Common Gateway Interface) support, the CGI-BIN path specifies the root directory of executables allowed to be run through HTTP requests. The attack overwrites this path configuration to `/bin` so that the command shell executable `/bin/sh` can be started by the attacker with root privileges on the server. Thus, the attacker gets a completely unrestricted command shell. This attack is undetectable by control data protection techniques because only CGI-BIN is a plain-text string.

In our experiment, the server runs on the proposed architecture. A hypothetical attacker attempts to overwrite the CGI-BIN configuration by tainting the heap doubly linked list. Our architecture raises an alert when `free()` is invoked because register `$3` is tainted when an instruction `LW $3,0($3)` inside `free()` is about to run.

#### GHTTPD Stack Overflow Attack
Another HTTP server, GHTTPD, has a stack buffer overflow vulnerability in its logging function [16]. The vulnerable function contains a 200-byte stack buffer, which is used to accommodate the HTTP request received from the client. A traditional way to attack is to send an HTTP request longer than 200 bytes, overwriting the return address following the buffer to run malicious code embedded in the HTTP request.

We constructed a non-control data attack by corrupting a pointer to the URL in the HTTP request. A security policy of the HTTP protocol requires any URL containing the substring `"/.."` to be rejected, to prevent users from accessing files outside the predefined HTML and CGI root directories. We exploit the vulnerability to change the URL pointer to point to an illegitimate URL string containing `"/.."` after the policy is checked.

GHTTPD runs on the proposed architecture while the devised attack is launched. When the server is ready, a malicious request `GET AAAAAAA….AAAAAAAA \x94\x3e\xff\x7f /cgi-bin/../../../../bin/sh` is sent to the server. The first part of the request `AAAAAAA…AAAAAA \x94\x3e\xff\x7f` is parsed as a URL. However, due to the buffer overflow vulnerability, the last four bytes overwrite the pointer of the URL to `0x7fff3e94`, which is the address of the second part of the string, `/cgi-bin/../../../../bin/sh`. Without the protection provided by our architecture, this would force the server to run `/bin/sh` with root privileges. Our mechanism effectively stops the attack when the tainted URL pointer is dereferenced in a load-byte instruction (i.e., `LB`).

#### Traceroute Double Free Attack
Certain versions of LBNL traceroute are vulnerable to an attack involving the freeing of a heap buffer not allocated by `malloc()` [17]. When traceroute is executed with the arguments `-g x -g y`, `savestr()` is called twice to parse arguments `-g x` and `-g y`. `Savestr()` reduces calls to `malloc()` by preallocating heap space and performs self-buffer management when it is invoked subsequently. After `-g x` is parsed and `savestr()` is called, the pointer to the block used by `savestr()` is released using `free()`. When `-g y` is interpreted, `savestr()` is called again, and the result is written to the block of already freed memory. Like for `-g x`, `free()` is called, but this time on a region that has already been released in the first `free()` call. Traceroute crashes because `free()` is using an invalid pointer in an invalid `malloc()` header. A malicious user can take over traceroute using the double free attack method: it corrupts pointers used by `malloc/free`, then forces traceroute to overwrite critical program data or execute malicious code.

In our experiment, we use the command line `traceroute –g 123 –g 5.6.7.8`. Without our detection mechanism, this results in a successful takeover. Due to our detection mechanism, an alert is generated at a store-word instruction inside `free()` because `0x333231` is a tainted value when it is dereferenced as a pointer.

### Evaluation of False Positives

A crucial criterion for defensive systems, along with system security, is the false positive rate, i.e., the likelihood that the system raises an alert when there is no attack. The network applications discussed in Section 5.1 run smoothly on the proposed architecture without generating any alerts when there is no attack. To more thoroughly evaluate the architecture on real applications, we run six integer applications from SPEC 2000, of which only their binary executables are available. These applications are BZIP2, GCC, GZIP, MCF, PARSER, and VPR, and the default test cases are provided by SPEC 2000. Since none of the test cases is a malicious attack, no alert should be generated during the execution of these programs. Table 3 shows the results of this test: the total size of these programs is 6586KB, the total number of input bytes during the execution of the benchmarks is 2186KB, and the total number of instructions executed is 15,139 million. During the execution of these programs, not a single alert is raised. This experiment is a good indicator that one can expect very few (or even no) false positives when the proposed technique is deployed in real systems.

### False Negative Scenarios

False negative scenarios of a defensive technique are situations where an attack escapes detection. Although the pointer taintedness architecture detects a larger set of memory corruption attacks than existing control-flow integrity-based protections, it does not provide 100% security coverage. This section shows some synthetic cases where a certain degree of damage can be done to the system running on top of the proposed architecture.

#### Integer Overflow Attacks Resulting in Out-of-Boundary Array Index
Integer overflow is often due to a programmer's misinterpretations of signed, unsigned, long, and short integers. When a programmer converts integers between types, the resulting values can be inconsistent with the programmer's expectations. Table 4(A) shows a vulnerable function where an unsigned integer `ui` is assigned to a signed integer `i`. Lines 2 and 3 perform an array index boundary check to ensure that `i` does not exceed the array size. This comparison statement untaints `i` because it has been boundary checked. However, an attacker can input a very large unsigned integer `ui` to the function. When `ui` is assigned to the signed integer `i`, `i` becomes negative. Line 4 uses `i` as the array index, allowing the attacker to overwrite any memory address lower than the address of the array. Neither our technique nor existing control data protection techniques stop integer overflow attacks from corrupting memory. The integer overflow vulnerability differs from other memory corruption vulnerabilities because the integer value is intended to be an array index, while in other vulnerabilities, the values being dereferenced are not supposed to be pointer values: they can be embedded in FTP commands, HTTP requests, and IP addresses. To defeat the attack, the bound check must be implemented correctly. Unfortunately, it is very difficult, if not impossible, to transparently perform the check without knowledge of application semantics.

| Program | Size (KB) | Total Input Bytes (KB) | Total Instructions (M) | Alert Generated? |
|---------|-----------|------------------------|------------------------|------------------|
| BZIP2   | 321       | 1048                   | 5,951                  | No               |
| GCC     | 4184      | 77.7                   |                        | No               |