Synthetic Vulnerable Programs 
The  effectiveness  of  the  proposed  approach  is  first 
demonstrated  on  a  number  of  synthetic  functions  that  are 
vulnerable  to  stack  buffer  overflow,  heap  corruption,  and 
format  string  attacks  respectively.  These  functions  and 
attacks were illustrated earlier in Figure 2. 
Detection of stack buffer overflow. When a string of 
“a”  characters  of  24  bytes  is  passed  to  exp1()  running  on 
our  architecture,  an  alert  is  raised at the return instruction 
(i.e., JR  $31  on  SimpleScalar)  of  exp1(),  which  indicates 
that 
tainted  as  0x61616161,
corresponding to four “a” characters in the input. 
the  return  address 
is 
Detection  of  heap  corruption.  Function  exp2()
contains  a  heap  overflow  vulnerability.  An  attack  is 
launched  by  inputting  12  “a”  characters  to  the  8-byte 
buffer.  When  the  buffer  is  freed,  a  load-word  instruction 
LW $3,0($3), which is in function free(), raises an alert. As 
described in Section 3, a statement executed in free() is B-
>fd->bk=B->bk.  When  the  alert  is  generated,  register  $3
equals  B->fd, which is a tainted word 0x61616161 due to 
the  buffer  overflow  condition.  Because  the  detected 
instruction  attempts  to  dereference  register  $3  (i.e.,  the 
0($3)  indirect  addressing  mode)  when  its  value  is  tainted, 
the alert is raised. 
receives 
function 
Detection  of  format  string  attack.  The  effectiveness 
of  detecting  format  string  attacks  is  demonstrated  by 
function  exp3().  The 
the  string 
abcd%x%x%x%n from the socket. When printf() is called, 
a store-word  instruction  SW  $21,0($3)  in  vfprintf()  raises 
an  alert.  This  store  instruction  is  compiled  from  the 
statement  *ap=count  described  in  Section  3,  where  the 
value  of  ap  is  in  register  $3  and  the  value  of  count  is  in 
register $21. When the alert is raised, the value of register 
$3  in  0($3)  dereference  is  0x64636261,  corresponding  to 
the first four bytes of the input string, “abcd”.
5.1.2. Real-World Network Applications 
The  three  examples  discussed  in  the  previous  section 
demonstrate  that  pointer  taintedness  detection  can  defeat 
many  types  of  memory  corruption  attacks.  This  section 
presents  results  from  testing  real-world  attacks  against 
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 22,2021 at 04:19:55 UTC from IEEE Xplore.  Restrictions apply. 
running  on 
the  SimpleScalar
network  applications 
augmented with pointer taintedness detection capability. In 
addition, the SimpleScalar processor simulator is extended 
to  support  network  socket  applications.  The  enhancement 
allows  us 
to  run  many  real-world  network  server 
applications.  Both  control  data  attacks  and  non-control 
data  attacks  are  used  for  the  evaluations.  The  pointer 
taintedness detection technique succeeds in defeating both 
types of attacks.   
format 
WU-FTPD 
string  attack.  Washington 
University  FTP  Daemon  (WU-FTPD)  is  one  of  the  most 
widely used FTP servers. The Site Exec Command Format 
String  Vulnerability  [14]  is  a  vulnerability  in  WU-FTPD 
allowing  attackers  to  overwrite  an  arbitrary  memory 
location.4    We  constructed  a  non-control  data  attack,  in 
which  the  format  string  vulnerability  is  exploited  to 
overwrite an integer word representing the ID of the login 
user. This is sufficient to escalate the attacker’s privilege to 
the root privilege, offering the attacker a full control on the 
file  /etc/passwd  so  that  he/she  can  upload  a  different 
version of this file. After writing a malicious entry such as 
“alice:x:0:0::/home/root:/bin/bash” in the new version, the 
attacker  leaves  a  backdoor  to  login  later  as  Alice,  who 
possesses root privileges. Since the attack does not corrupt 
any control data, it is not detectable by existing techniques. 
 WU-FTPD runs on the proposed architecture. Table 2
shows  the  attack/detection  steps.  When  the  FTP  server  is 
ready  to  accept  user  input,  the  attacker  (the  FTP  client) 
first  authenticates  to  the  server  using  USER  and  PASS
commands, then issues a SITE EXEC command to exploit 
the  vulnerability.  The  target  integer word representing the 
user  ID  is  located  in  the  address  0x1002bc20,  so  the 
command used to overwrite this word is: 
indicating 
site exec \x20\xbc\x02\x10%x%x%x%x%x%x%n 
Immediately  after  the  attack  sends  the  malicious  SITE 
EXEC command, the pointer taintedness detector raises an 
alert 
instruction  SW  $21,0($3)
dereferences a tainted value in register $3. The value of the 
register  is  0x1002bc20,  the  same  as  the  one  specified  by 
the  attacker  as  the  target  address  to  overwrite.  The  FTP 
server is stopped when the alert is raised, which effectively 
prevents the attack from succeeding. 
that 
the 
Table 2: Attacking WU-FTPD on the Proposed 
Architecture 
FTP Server 
FTP Client 
FTP Server 
FTP Client 
FTP Client  
Alert 
220  FTP server (Version wu-2.6.0(60) Mon Nov 29 
10:37:55 CST 2004) ready. 
user user1 
331 Password required for user1 . 
pass xxxxxxx    (the correct password of user1) 
site exec \x20\xbc\x02\x10%x%x%x%x%x%x%n 
44d7b0: sw $21,0($3)           $3=0x1002bc20 
NULL HTTPD heap corruption attack. Null HTTPD 
is  a  multithreaded web server for Linux. A heap overflow 
vulnerability  has  been  reported  in  this  application  [14]. 
This  vulnerability  is  triggered  when  an  attacker  sends  a 
POST  command  with  a  negative  Content-Length  field  in 
its HTTP header. Due to misinterpretation of the negative 
number, the size of a heap buffer is incorrectly calculated, 
resulting  in  the  possibility  of  a  buffer  overflow  attack.5
Known  attack  programs  overwrite  control  data  when  the 
overflowed heap buffer is freed, hijacking the control flow 
of  the  HTTP  server.  We  found  an  effective  non-control 
data  attack 
the  CGI-BIN  path 
configuration.  In  HTTP  servers  with  CGI  (Common 
Gateway  Interface)  support,  a  CGI-BIN  path  specifies  the 
root  directory  of  executables  that  are  allowed  to  be  run 
through  HTTP  requests.  The  attack  overwrites  this  path 
configuration 
the  command  shell 
executable /bin/sh can be started by the attacker with root 
privileges  on  the  server.  Thus,  the  attacker  gets  a 
completely  unrestricted  command  shell.  This  attack  is 
undetectable  by  the  control  data  protection  techniques 
because only CGI-BIN is a plain-text string. 
that  only  corrupts 
to  “/bin”  so 
that 
In  our  experiment,  the  server  runs  on  the  proposed 
architecture. A hypothetical attacker attempts to overwrite 
CGI-BIN configuration by tainting the heap doubly linked 
list. Our architecture raises an alert when function free() is
being  invoked,  because  register  $3  is  tainted  when  an 
instruction LW $3,0($3) inside free() is about to run.  
GHTTPD  stack  overflow  attack.  Another  HTTP 
server, GHTTPD, has a stack buffer overflow vulnerability 
in  its  logging  function  [16].  The  vulnerable  function 
contains  a  200-byte  stack  buffer,  which  is  used  to 
accommodate  the  HTTP  request  received  from  the  client. 
A  traditional  way  to  attack  is  to  send  an  HTTP  request 
longer  than  200  bytes,  overwriting  the  return  address 
following  the  buffer  in  order  to  run  malicious  code 
embedded in the HTTP request.  
We constructed a non-control data attack by corrupting 
a  pointer  to  the  URL  in  the  HTTP  request.  A  security 
policy of the HTTP protocol requires any URL containing 
a  substring  “/..”  be  rejected,  to  prevent  users  from 
accessing files outside the predefined HTML and CGI root 
directories.  We  exploit  the  vulnerability  to  change  the 
URL  pointer  to  point  to  an  illegitimate  URL  string 
containing “/..” after the policy is checked. 
GHTTPD  runs  on  the  proposed  architecture  while  the 
devised  attack  is  launched.  When  the  server  is  ready,  a 
malicious 
AAAAAAA….AAAAAAAA 
\x94\x3e\xff\x7f↵↵/cgi-bin/../../../../bin/sh  is  sent  to  the 
server.  The  first  part  of  the  request  AAAAAAA…AAAAAA
\x94\x3e\xff\x7f  is  parsed  as  a  URL.  However,  due  to  the 
request  GET
4  This  vulnerability (with this application) was also chosen in assessing 
Secure  Program  Execution  and  Minos,  where  the  control  data  attack 
published in [14] was used to test the security coverage. 
5  This  vulnerability  (with  this  application)  was  chosen  in  assessing  the 
Secure Program Execution technique. 
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 22,2021 at 04:19:55 UTC from IEEE Xplore.  Restrictions apply. 
buffer overflow vulnerability, the last four bytes overwrite 
the pointer of the URL to 0x7fff3e94, which is the address 
of  the  second  part  of  the  string,  /cgi-bin/../../../../bin/sh.
Without  the  protection  provided  by  our  architecture,  this 
would  force  the  server  to  run  /bin/sh  with  root  privileges. 
Our  mechanism  effectively  stops  the  attack  when  the 
tainted  URL  pointer  is  dereferenced  in  a  load-byte 
instruction (i.e., LB).
Traceroute  double  free  attack.  Certain  versions  of 
LBNL  traceroute  are  vulnerable  to  an  attack  involving 
free()-ing  of  a  heap  buffer  not  allocated  by  malloc()  [17]. 
When  traceroute  is  executed  with  the  arguments  "-g  x  -g 
y", savestr() is called twice to parse arguments “-g x” and 
“-g y”. Savestr() reduces calls to malloc() by preallocating 
heap space and performs self buffer management when it is 
invoked subsequently. After "-g x" is parsed and savestr()
is  called,  the  pointer  to  the  block  used  by  savestr()  is 
released using free(). When “–g y” is interpreted, savestr()
is  called  again,  and  the  result  is  written  to  the  block  of 
already freed memory. Like for “-g x”, free() is called, but 
this time on a region that has already been released in the 
first free() call. Traceroute crashes because free() is using 
an  invalid  pointer  in  an  invalid  malloc()  header.  A 
malicious  user  can  take  over  traceroute  using  the  double 
free  attack  method: 
it  corrupts  pointers  used  by 
malloc/free,  then  forces  traceroute  to  overwrite  critical 
program data or execute malicious code.  
In our experiment, we use the command line traceroute 
–g  123  –g 5.6.7.8. Without our detection mechanism, this 
results  in  a  successful  takeover.  Due  to  our  detection 
mechanism,  an  alert 
is  generated  at  a  store-word 
instruction  inside  free()  because  0x333231  is  a  tainted 
value when it is dereferenced as a pointer. 
5.2. Evaluation of False Positives 
Along  with  system  security,  a  crucial  criterion  of 
defensive  systems  is  the  false  positive  rate,  i.e.,  the 
likelihood  that  the  system  raises  an  alert  when  there  is no 
attack.  
the  false  positive  rate  of 
The  network  applications  discussed  in  Section  5.1  run 
smoothly  on  the  proposed  architecture  without  generating 
any  alert  when  there  is  no  attack.  In  order  to  more 
thoroughly  evaluate 
the 
architecture  on  real  applications,  we  run  six  integer 
applications  from  SPEC  2000,  of  which  only  their  binary 
executables  are  available.  These  applications  are  BZIP2, 
GCC, GZIP, MCF, PARSER and VPR, and the default test 
cases  are  provided  by  SPEC  2000.  Since  none  of  the  test 
cases  is  a  malicious  attack,  no  alert  should  be  generated 
during the execution of these programs. Table 3 shows the 
results  of  this  test:  the  total  size  of  these  programs  is 
6586KB,  the  total  number  of  input  bytes  during  the 
execution  of  the  benchmarks  is  2186KB,  and  the  total 
number of instructions executed is 15,139 million. During 
the execution of these programs, not a single alert is raised. 
This  experiment  is  a  good  indicators  that  one  can  expect 
very  few  (or  even  no)  false  positive  when  the  proposed 
technique is deployed in real systems. 
5.3. False Negative Scenarios 
False  negative  scenarios  of  a  defensive  technique  are 
the situations where an attack escapes detection. Although 
pointer  taintedness  architecture  detects  a  larger  set  of 
memory  corruption  attacks  than  existing  control-flow 
integrity  based  protections,  it  does  not  provide  100% 
security coverage. This section shows some synthetic cases 
where certain degree of damage can be done to the system 
running on top of the proposed architecture.  
these 
types, 
the 
Integer  overflow  attacks  resulting  in  an  out-of-
boundary array index. Integer overflow is often due to a 
programmer’s misinterpretations of signed, unsigned, long 
and  short  integers.  When  a  programmer  converts  integers 
between 
resulting  values  can  be 
inconsistent  with  the  programmer’s  expectations.  Table 
4(A)  shows  a  vulnerable  function  where  an  unsigned 
integer  ui  is  assigned  to  a  signed  integer  i.  Lines  2  and  3 
perform  an  array  index  boundary  check  to  ensure  that  i
does not exceed the array size. This comparison statement 
untaints i because it has been boundary checked. However, 
an attacker can input a very large unsigned integer ui to the 
function.  When  ui  is  assigned  to  the  signed  integer  i, i
becomes  negative.  Line  4  uses  i  as  the  array  index, 
allowing  the  attacker  to  overwrite  any  memory  address 
lower than the address of array. Neither our technique nor 
the existing control data protection techniques stop integer 
overflow  attacks  from  corrupting  memory.  The  integer 
overflow  vulnerability  differs 
from  other  memory 
corruption  vulnerabilities  because  the  integer  value  is 
intended 
in  other 
vulnerabilities,  the  values  being  dereferenced  are  not 
supposed  to  be  pointer  values:  they  can  be  embedded  in 
FTP  command,  HTTP  request,  and  IP  address.  To  defeat 
the  attack, 
implemented 
correctly.  Unfortunately, 
if  not 
impossible, on the hardware level, to transparently perform 
the check without knowledge of application semantics. 
the  bound  check  must  be 
index,  while 
it 
is  very  difficult, 
the  array 
to  be 
Table 3: Test False Positive Rate Using SPEC 2000 Benchmark Programs 
Program size 
Total number of input bytes  
Total number of instructions 
Alert generated? 
BZIP2 
321KB 
1048KB 
5,951M 
No 
GCC 
4184KB 
77.7K 