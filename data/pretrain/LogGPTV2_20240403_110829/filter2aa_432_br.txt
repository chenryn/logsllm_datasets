}else
{
printf ( “%s was not found. \n”, word ) ;
}
break ;
case ‘q’ :
/* 退出 */
printf ( “program quits \n” ) ;
第十二章  远程过程调用
- 265 -
exit ( 0 ) ;
default :
/* 无法识别的命令 */
printf ( “command %c invalid. \n”, cmd ) ;
break ;
} /* switch 结束 */
}
}
/*****************************************************************
nextin 函数: 读取输入的命令和命令后面跟的单词参数     *
 ******************************************************************/
int nextin ( char* cmd, char* word )
{
int
i, ch ;
ch = getc ( stdin ) ;
while ( isspace(ch) )
{
ch = getc ( stdin ) ;
}
if ( ch == EOF )
{
return -1 ;
}
*cmd = (char) ch ;
ch = getc ( stdin ) ;
while ( isspace(ch) )
{
ch = getc ( stdin ) ;
}
if ( EOF == ch )
{
return -1 ;
}
if ( ‘\n’ == ch )
{
return 0 ;
}
i = 0 ;
while ( !isspace(ch) )
{
if ( MAXWORD 
#include 
#include 
#include 
/* 每一个输入的命令的最大长度 */
#define MAXWORD 50
/* 整个字典中可以包含的最多字数 */
#define DICTSIZ 100
/* 字典的数据存取数组 */
char dict[DICTSIZ][MAXWORD+1] ;
/* 字典中字母数 */
int
nwords = 0 ;
int  nextin ( char* cmd, char* word) ;
int  initw() ;
int  insertw ( const char* word ) ;
int  deletew ( const char* word ) ;
int  lookupw ( const char* word ) ;
/*********************************************************
initw  初始化字典，清空所有数据                    *
 *********************************************************/
int  initw()
{
nwords = 0 ;
return 1 ;
}
/*********************************************************
insertw  将一个单词插入字典                        *
 *********************************************************/
int  insertw ( const char* word )
{
第十二章  远程过程调用
- 267 -
strcpy ( dict[nwords], word ) ;
nwords ++ ;
return nwords ;
}
/*********************************************************
deletew  在字典中删除一个单词                      *
 *********************************************************/
int  deletew ( const char* word )
{
int 
i ;
for ( i=0 ; i i ;i++ )
{
if ( 0 == strcmp(word, dict[i]) )
{
return 1 ;
}
}
return 0 ;
}
注意，对符号常量 MAXWORD 的定义在两个构件中都出现了，因为他们都要声明用
于存储变量。然而，只有 dict2.c 中才含有用与存储字典的数据结构的声明，因为只有远程
过程调用才包含字典的数据结构。
从实际的观点看，将应用程序分为两个文件使得分别编译客户机和服务器成为可能。
编译器检查诸如符号常量之类的问题，而链接程序将检查所有的数据结构同引用它们的过
- 268 -
Linux网络编程
程结合到了一起。在 Linux 下：
gcc –c dict1.c
gcc –c dict2.c
这将产生两个目标文件（并不是完整的程序）。这些构建必须连接到一起以产生一个可
执行的程序。但是，这并不是编译他们的直接原因：我们使用编译器来检查这两个文件是
否语法正确。
在考虑让编译器检查代码这种方法时，我们要记住，大多数分布式程序要比我们的简
单例子复杂的多。一次编译可能会发现一大堆问题，他们会转移程序员的注意力。在插入
其他代码之前抓住这些问题可以使我们以后调试省力的多。
3．创建一个 rpcgen 规格说明
我们现在已经为我们的字典程序选择了一种结构，下面我们将准备一个 rpc 规格说明。
从本质上说，一个 rpcgen 规格说明文件包含了对一个远程程序的声明以及它所使用的数据
结构。
该规格说明文件包含常量，类型定义，以及对客户机和服务器程序的声明。更加准确
的说，这个规格文件包括：
声明在客户机或服务器（远程程序）中所使用的常量。
声明所使用的数据类型（特别是对远程过程的参数）。
声明远程程序，每个程序中所包含的过程，以及它们的参数的类型。
我们知道 RPC 使用一些数字来表示远程程序以及在这些程序中的远程过程。在规格说
明文件中的程序声明定义了诸如程序的 RPC 号，版本号，以及分配给程序中的过程的编号
等细节。
所有这些声明必须用 RPC 编程语言来给出，而不是用 C。尽管他们的区别是微小的，
但它们可能会成为障碍。例如，RPC 用关键字 string 代表以 null 结尾的字符串，而 C 却用
char* 来表示。因此，即使是一个有经验的程序员，要产生一个正确的规范说明，可能也
需要多次反复。
文件 rdict.x 说明了一个 rpcgen 规格说明。它包含了对字典程序的 RPC 版的声明。
/* rdict.x RPC 规格说明 */
const
MAXWORD = 50 ;
const
DICTSIZ = 100 ;
/*******************************************************
RDICTPROG 远程过程,包括 insert, delete 和 lookup  *
 *******************************************************/
/* 远程过程的名字 */
program RDICTPROG
{
/* 远程过程的版本 */
version RDICTVERS
{
/* 第一个过程 INITW */
int INITW ( void ) = 1 ;
/* 第二个过程 INSERTW */
int INSERTW ( string ) = 2 ;
/* 第三个过程 DELETEW */
第十二章  远程过程调用
- 269 -
int DELETEW ( string ) = 3 ;
/* 第四个过程 LOOKUPW */
int LOOKUPW ( string ) = 4 ;
/* 定义了版本号 */
}= 1 ;
/* 远程过程的数字 ( 必须是唯一的 ) */
}= 0x30090949 ;
一个 rpcgen 规格说明文件并没有囊括最初的程序中所能找到的所有声明.它仅仅定义了
那些在客户机和服务器之间要共享的常量和数据类型，或者是那些需要指明的参数。
这个规格说明的例子是由定义常量 MAXWORD 和 DICTSIZE 开始。在最初的应用中，
这两个常量都是用 C 的预处理语句 #define 定义的符号常量。 RPC 不使用 C 的符号常量
声明。取而代之的是，它要求符号常量用关键字 const 声明，赋值时使用等号（=）。
按照约定，规格说明文件使用大写的名字来定义过程和程序。正如我们下面将看到的，
这些名字会成为可以在 C 程序中使用的符号常量。在这里，并不是绝对的有要求要大写，
但是这样做可以有助于避免冲突。
4．运行 rpcgen
在完成了规格说明后，我们可以运行 rpcgen 来检查语法错误，如果没有发生错误，系
统将会产生三个文件。
[zixia@bbs tmp]$ ls
rdict.x
[zixia@bbs tmp]$rpcgen rdict.x
[zixia@bbs tmp]$ ls
rdict.h  rdict.x  rdict_clnt.c  rdict_svc.c
系统生成的文件为 rdict.h rdict_clnt.c rdict_svc.c 。
下面我们先来看看 rdict.h 文件：
/*  Please do not edit this file.
It was generated using rpcgen.  */
#ifndef _RDICT_H_RPCGEN
#define _RDICT_H_RPCGEN
#include 
#ifdef __cplusplus
extern “C” {
#endif
#define MAXWORD 50
#define DICTSIZ 100
#define RDICTPROG 0x30090949
#define RDICTVERS 1
#if defined(__STDC__) || defined(__cplusplus)
#define INITW 1
extern  int * initw_1(void *, CLIENT *);
- 270 -
Linux网络编程
extern  int * initw_1_svc(void *, struct svc_req *);
#define INSERTW 2
extern  int * insertw_1(char **, CLIENT *);
extern  int * insertw_1_svc(char **, struct svc_req *);
#define DELETEW 3
extern  int * deletew_1(char **, CLIENT *);
extern  int * deletew_1_svc(char **, struct svc_req *);
#define LOOKUPW 4
extern  int * lookupw_1(char **, CLIENT *);
extern  int * lookupw_1_svc(char **, struct svc_req *);
extern int rdictprog_1_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
#else /* K&R C */