    'T' : '7',
    'B' : '8',
    'g' : '9'
    }
然后写脚本替换
    for key,value in dict.items():
        N = N.replace(key,value)
        c = c.replace(key,value)
        e = e.replace(key,value)
    n = int(N)
    c = int(c)
    e = int(e)
发现e极大
    18165674577527345773800436360005849487629584246818834218136555374150149407637407524285601002127374055517203100485286275425145721883636036574242949710753834106366928190387866524288552807173498852374689387479028711005571557055252495247965030797704485232834280077859527260792773150470416827810790513797809193767
于是想到winner攻击
###  payload
使用github的winner attack的脚本
    https://github.com/pablocelayes/rsa-wiener-attack
运行
    ➜  rsa-wiener-attack-master python RSAwienerHacker.py
    Hacked!
    noxCTF{RSA_1337_10rd}
## Trinity
题目如下
    Neo, you are the chosen one. The only person who can make sense of these numbers. Do it.
    N = 331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004 
    c = 310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243
    N = 302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114 
    c = 112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344
    N = 332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323 
    c = 10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242
###  题目分析
看到3组(n,c)，第一反应想到的就是低指数广播攻击,即我们有  
 __根据中国剩余定理，可以有通解  
其中  
但是由于这里没有给e，又因为低指数，于是我选择爆破了一下e，但是都没有结果  
发现一直报错
    ZeroDivisionError: invert() no inverse exists
想到题目给的数字可能有问题，仔细观察，发现只有0-4  
于是想到5进制  
转一波以后就正常了
###  Payload
    import gmpy2
    import gmpy
    import libnum
    def boradcast_fuzz(question,e):
        N=1
        for i in range(len(question)):
            N *= question[i]['n']
        N_list = []
        for i in range(len(question)):
            N_list.append(N / question[i]['n'])
        t_list = []
        for i in range(len(question)):
            t_list.append(int(gmpy2.invert(N_list[i], question[i]['n'])))
        sum = 0
        for i in range(len(question)):
            sum = (sum + question[i]['c'] * t_list[i] * N_list[i]) % N
        sum = gmpy.root(sum, e)[0]
        return libnum.n2s(sum)
    n1 = int(str(n1),5)
    n2 = int(str(n2),5)
    n3 = int(str(n3),5)
    c1 = int(str(c1),5)
    c2 = int(str(c2),5)
    c3 = int(str(c3),5)
    question=[
    {'n':n1,'c':c1},
    {'n': n2, 'c': c2},
    {'n':n3,'c':c3},
    ]
    for i in range(2,20):
        res = boradcast_fuzz(question,i)
        if 'noxCTF' in res:
            print res
            print 'e=%d'%(i)
            break
得到结果
    noxCTF{D4mn_y0u_h4s74d_wh47_4_b100dy_b4s74rd!}
    e=3
## 拓展-Boneh and Durfee attack
由于题目中有一道Wiener’s Attack，于是我联想到了最近看的
    Boneh and Durfee attack
我们知道，如果要使用Wiener’s Attack，有一个特征，即e很大，那么到底有多大？  
这里有一个评判标准，即  
那么如果e很大，但d比这里的限定值大怎么办？  
那么可以尝试Boneh and Durfee attack  
其使用标准为  
比如这次题目里
    d=33859466522204630502415021058361047681307615225229354334148022345758288750359
    n=106464658120038110366171046017584728605432723415099799671398095113303220554018149888866005570730116293196252665770382258833879353944414043672822102509840890423260826373058255315521685967807858850204383823245609286166175687064317570157147353365780181201403742497875436372013183350667001942660780839408462806879
我们简单比较下
    N1 = 1.0/3*pow(n,1.0/4)
    N2 = pow(n,0.292)
    print int(N1)-d
    print int(N2)-d
得到结果
    941571295587957309748289456353490745482373040518812393691369
    878909169550944842698019812370775334246473513796204883182700468007058108344282016448403689
明显Boneh and Durfee attack给的空间更大，所以如果我们在不能使用Wiener’s Attack的时候，可以尝试Boneh and
Durfee attack  
利用脚本
    https://github.com/mimoo/RSA-and-LLL-attacks