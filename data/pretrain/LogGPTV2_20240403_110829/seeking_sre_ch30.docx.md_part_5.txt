Google 故障的一项调查表明，二进制问题和配置问题共同构成了几乎
70％导致故障的因素，软件本身和开发过程中的失败导致近 62％的根本原因，"
复杂的系统行为"只有大约
17％的情况会导致系统出错。记住这些数字，或者至少记住要分析故障的原因结构这个实践。
在这里，让我介绍一下在本章其余部分中提到的两个立场：严格抵制轮值（SAOC）和尽量避免轮值（WAOC）。
## 严格抵制轮值（SAOC）
 严格抵制轮值（SAOC）的理念是这样的。
软件系统是确定性的。我们有两种可能的方法来解决故障问题。我们可以排除故障的来源，或者我们可以防止故障造成灾难性后果。由于软件系统是确定性的，如果我们排除所有故障根源，系统就不会失败。（SAOC
不认为同时做这*两件*事情是有意义的。）
让我们花点时间回顾一下构建软件系统时不可靠的来源。我们可能犯一个简单的编程错误、拼写错误或类似其他错误。我们可能犯设计错误，构造一些肯定会出错的东西。我们可能错误地将自身与环境隔离（库、依赖项或是错误地分析数据）。我们可能错误地处理远程依赖项，例如假定它们始终可访问或始终返回正确的数据。
正如前面所讨论的那样，故障之所以令人抓狂，因为其中许多是完全可以避免的。SAOC
的立场在于防止[#underlying_assumptions_driving_on_call_fo](#underlying_assumptions_driving_on_call_fo)那些已识别的错误来源在系统中重现。虽然这里有太多要详细讨论的问题，但好消息是变更管理的许多困难已经得到了很好的理解，而我们正在努力做的是更成功地实现已经相对容易理解的东西。
坏消息是，如果我们一直遇到某个问题，那么可能它是有原因的。
然而，对SAOC而言，这并不重要。因为我们最终会把它弄对的。但是，我们首先需要克服一个障碍，即导致故障的原因可能是相对较高层的问题互相作用，而不一定是系统内部的小故障或简单的小毛病（如导入错误数据）造成的。
因此，我们需要从系统中消除复杂性。实际上，只有两种已知的方法：用经过验证的、已知行为的、以确定的方式集成的简单组件来构建系统；并且运行系统很长一段时间，看看我们是否成功达到了稳定性，然后解决剩下的问题。今天，作为一个新兴行业，我们编写不可靠的软件实在太容易了，因为没有始终如一地利用这两种方法。另外因为软件工程师觉得编写代码比审查代码更容易，所以更容易创建不可靠的代码。
相反，我认为我们需要改变构建软件的基础*平台*。今天所谓的平台不过是POSIX
libc、win32，或逻辑上类似的其他东西；在未来，尤其是分布式系统的未来，我们必须处于更高的层次，并且具有更多的跨云（或至少是跨平台）的功能。要编写服务器，产品开发人员应该采用现成的知名类，类应该*内建*良好的监控、日志记录、危机负载处理、优雅降级机制和避免故障特性，并且这些都应*默认*启用。写一些不好的东西应该是很困难的。很久以前，平台上面投入的努力已经非常可观，但是我们因为坚持从头开始重写的权利付出了太多代价，并且获得的回报如此之少，很难理解为什么我们容忍这种情况。
同时，我们需要更好的方法将不良应用层逻辑与平台的其余部分隔离开来；今天，在整个行业中，这种隔离还几乎没有听说过，这令人震惊。同样，这说明了一个更易于使用的预先存在的工具包。
因此，SAOC
主张采用有条理的方法来消除错误来源，也主张采用设计精良的工具软件，这不是为了提高系统的韧性，而是为了消除了交互的复杂性。这个主张存在许多缺点，其中一个明显的缺点只有在软件系统部署后才会发现哪里需要排除问题；理想情况下，我们只会重复使用已经排除问题的软件。这里再次看到了使用工具包方法的必要，除了已经"确定"为可靠的软件组件。
## 尽量避免轮值（WAOC）
 如果到这一步，如果你还是但觉得自己的案例仍然过于复杂，难以应用这样的强势立场，请允许我向你介绍稍弱势一点（但仍然有用）的立场。
在这种世界观中，你可能真的相信软件是确定性的，但你仍然相信我们永远无法成功地、以编程方式对未知的东西做出反应，任意复杂的系统之间的联系将总是产生某种失败。我们仍然可以在消除轮值方面取得进展，但我们需要以不同的方式看待它。
与 SAOC
不同的是，我们并不是要通过用病房药物来代替急救药（并最终取消急救药）。相反，我们试图采用*无人驾驶*：我们知道我们不能完全控制系统所处的环境，但我们或多或少有一个有用的反应（将个别车辆刹停，从而尽可能避免整个系统停顿），问题是在司机来到之前，我们可以在什么程度上自动停车，而不会危及整个系统。
因此，这种方法没有试图阻止人为干预的发生，而是将人为干预推迟到类似"营业时间"到来之后，因为这样就不需要应急响应人员出现。
在这种世界观中，最重要事情的不是防止故障出现，而是要使系统更好地隔离故障。有趣的是，这个位置实际上看起来与前一个相似：我们需要相同的东西，可重复使用的标准化工具包软件，除了能有效的降低系统复杂性，也能做到类似于无人驾驶的故障避免：我们自动在最安全的状态终止，具体时机取决于我们可以了解的情况。这里有趣的是：工程师为了使软件系统安全失败付出的努力，往往和他们避免失败的投入并不矛盾。在大众的盲目乐观情绪中，经常忽视失败案例的分析，可是如果我们设计的时候有更多安全失败的指引的话，开发出的系统就会有足够韧性。
故障隔离的细节因应用领域而异，因此在这里讨论它们意义不大，但关键原则是，所执行的工作应适合分区，以便将系统中遇到致命问题的组件安全排除，且对系统的处理能力没有显著影响，或至少影响有限；足以让人工操作员在办公室时间处理它。然后，就是要考虑系统可扩展性的问题，以便故障组件进行动态自调整，然后就可以避免轮值，虽然这样会导致你在硬件资源上花费更多，但至少不必因为员工跳槽而带来不必要的损失。
## 二合一
 是的，没有什么可以阻止我们结合两种方法的观点。实际上，即使理论位置完全不同，你已经看到它们都需要相同的补救措施：特别是用于构建软件的标准化工具包，尽管原因不同。
我觉得很明显，业界需要努力制作非常可靠的子组件，从而用于构造大部分的服务；他们甚至可能是被正式验证过的，这并不像你想象的那么荒谬；例如，[AWS
就使用正式的验证机制](http://lamport.azurewebsites.net/tla/formal-methods-amazon.pdf)。回到前面概述的云组件话题。然而，我同意，在一个创业公司在准确捕捉到用户需求的情况下，可以通过一些速成的
Ruby
代码就变得非常成功，因此我的主张会感觉有点不切实际：因为现在驱动消费者的是适合市场的产品，而不是稳定可靠的产品。
此外，只要一家大型跨国公司发现聘请运维工程师来轮值，并通过重启系统来修复，这比解决软件可操作性方面的实际问题更便宜，就不会有任何真正的改变。要想有真正的改变，我们必须在问题的根源来解决问题：我们必须使编写不可靠的软件变得很困难。我们必须做到（如果可能的话），让任何人都难以写出垃圾代码。否则任何其他努力都不会导致根本性的变化。
*云堆栈标准化*的好处是符合了 SAOC
立场的观念：如果不是每次都在公司内部单独面对问题，那么有条不紊地消除错误来源会更容易。由许多眼球检查的单个问题肯定会比更少得到关注的多个问题更快得到解决。 
# 结论
要摆脱轮值的纠缠，需要全行业的努力。因为我们提出的是在明确设计的工具包上进行合作，以便尽可能少地重写，且有尽可能多的人使用这些工具包。
但是，如果我们这样做，其好处将是无法估量的：全行业的一系列架构如此稳定，可以在学校教授；业务逻辑的划分也有了一致的方法；为特殊用户提供更温馨的环境；一套有条不紊地应用的最佳实践和跨公司的一致数据处理模式，显然也可以应用于同一公司的不同团队，更不用说同一团队中的每个人！
这可能听起来不可能，但实质上是一个趋同的任务。作为一个行业，实际上在社会中，我们在过去融合了更奇怪的东西：VHS、x86指令集和英语都经历了重大革新，而且肯定会有更多类似的领域。现在的任务是推动它，因为它对所有人都有好处，即使现在只有我们才能看到未来会是什么。
# 编者介绍
Niall Richard Murphy 在互联网基础设施领域工作了 20多年，目前是 Microsoft
都柏林办公室 Azure
生产基础设施工程软件工程总监。他是公司创始人、作家、摄影师，拥有计算机科学、数学和诗歌研究学位。他是*《网站可靠性工程》*和*《网站可靠性工作手册》*两本书的策划者、合著者和编辑。