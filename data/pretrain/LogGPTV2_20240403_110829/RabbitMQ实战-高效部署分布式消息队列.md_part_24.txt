事实上，设置一个基于负载均衡器的warren是非常简单的，运用到的都是到
目前为止你所掌握的那些概念。首先，在你的开发系统上启动两个RabbitMQ节点，
并将它们分别命名为rabbit_a和rabbit_b，以避免和已经运行的本地集群节点
相冲突（从Rabbit的安装目录运行）：
---
## Page 161
7.2设定负载均衡器一一基于主/从的集群
139
$RABBITMQ_NODE_PORT=5675 RABBITMQ_NODENAME=rabbit_a
./sbin/rabbitmq-server -detached
Activating RabbitMQ plugins ...
$RABBITMQ_NODE_PORT=5676RABBITMQ_NODENAME=rabbit_b
./sbin/rabbitmq-server-detached
Activating RabbitMQ plugins...
在启动主/备节点之后，现在需要设置一个新的HAProxy配置文件，将rabbit_b
设置成备用服务器，只在rabbit_a发生故障时才启动。事实上，这份HAProxy的
warren配置文件（如下列清单所示）看起来非常像集群配置。
清单7.1基于warren的负载均衡器的HAProxy配置
#HAProxy Config for Local RabbitMQ SLB Warren
global
General process information
p402 (1. noc =1)
aclveUp
backup UP
aciveUP.going down
HdeDowNrvus
backupUP.going down
actv DOWN,going up
badkupDOWN,going up
Dabih
Oninemanual
axpipos
active orbaokup DOWNnotcheckad
rabbitrnq_focal_cluster
Senaionrate
Sesslons
Waminoo
RipHoHodo
galus
Frontend
0020000
OPEN
abbiaooo0
0
000
0000
1m
00000000000000
014m40sUPL4OK0mY
1m15
000000000000000070000puo
58s
CurMax LimitlCur MaxLmilCur MaxLlmll Total LbTotIn
Reg Reep Rag Conn Resp Retr Rad
12
16670420716500
OPEN
Bakend0002
012000190018879420715590010000015m57eUP
Toooo
图7.3warren的HAProxy数据统计页面
为了测试一下我们刚构造好的warren，让我们从集群部分启动消费者，运行以
下命令 python cluster_test_consumer.py localhost 5680 :
$ python cluster_test_consumer.py localhost 5680
Ready for testing!
连接成功并准备行动。通过运行pythoncluster_test_producerlocalhost
5680来进行测试：
[producer output]
Sent cluster test message.
[consumer output]
Ready for testing!
Received:Cluster Test!/1301612486
---
## Page 163
7.2设定负载均衡器一一基于主/从的集群
141
看起来一切顺利。现在来测试故障转移。通过停止 rabbit_a上的 Erlang 应
用程序来产生故障。从RabbitMQ安装目录下运行./sbin/rabbitmqctl-n
rabbit_astop_app。现在记得你曾对HAProxy进行过设置，每隔5秒（inter
5000）对后台服务器进行健康检测，然后需要后台服务器失败三次（fa113）之
后才会认为其不可用了。所以需要等待15秒，消费者才会重连成功。一旦HAProxy
故障转移到备用RabbitMQ，你应该看到以下内容：
$ python cluster_test_consumer.py localhost 5680
Ready for testing!
Received: Cluster Test!/1301612486
Traceback(most recent call last):
File "cluster_test_consumer.py", line 58, in 
channel.start_consuming()
File "/Library/Python/2.6/site-packages/pika-0.9.6-py2.6.egg/
pika/adapters/blocking_connection.py",line 293,in start_consuming
self.transport.connection.process_data_events()
File "/Library/Python/2.6/site-packages/pika-0.9.6-py2.6.egg/
pika/adapters/blocking_connection.py",line 87,in process_data_events
raise AMQPConnectionError
AMQPConnectionError
Ready for testing!
如果你查看HAProxy数据统计页面的话（http://localhost:8101/stats），应该会看
用服务器。现在如果你再次使用pythoncluster_test_producerlocalhost
5680发布消息的话，消息仍然会到达消费者吗？
[producer output]
Sent cluster test message.
[consumer output]
Ready for testing!
Received: Cluster Test!/1301612545
是的，成功了！你拥有了全功能的主／备机RabbitMQwarren，并基于负载均衡
器来做故障转移。最重要的是可以确保当故障转移发生时，你无须担心RabbitMQ
无法在备用节点上启动，因为它已经在运行了！由于Rabbit始终在主节点和备用节
点上运行，因此你可以始终对它们进行监控；如果备机在派上用场之前就变为不可
用的话，你在第一时间就能发现。这通过使用共享存储的warren是无法做到的。
在掌握了集群和warren之后，你就能处理故障并在数据中心之上进行扩展了。
---
## Page 164
142
第7章warren和Shovel：故障转移和复制
但是当你需要在不同的数据中心的Rabbit间复制消息时，该怎么办？这时，我们就
需要Shovel了
7.3远距离通信和复制
在只有一个数据中心的时候，RabbitMQ集群对于提升消息通信性能来说是很棒
的方案；但是当需要把消息从一个城市的Rabbit服务器路由到另一个城市的Rabbit
上的时候，它就显得束手无策了。你可能会尝试使用集群来连接地理位置不同的数
据中心，但是这会遇到一些麻烦。首先，你失去了对RabbitMQ选择集群节点放置
队列的控制。所以即使你在芝加哥拥有两个集群节点并在洛杉矶拥有第三个节点，
也仍然无法确保队列A在一个城市而同时队列C在另一个城市。第二点，Erlang
的OTP通信框架无法忍受网络延迟。所以在芝加哥和洛杉矶之间昂贵的WAN连
接开销会导致巨大的问题以及集群各种各样奇怪的行为。事实上，如果WAN连接
发生故障，RabbitMQ没有办法应对网络划分。现在你也许会想：“那该如何使用
RabbitMQ来处理不同地理位置的基础架构呢？”答案是使用Shovel。但在使用之前，
你需要知道Shovel工作机制的背景知识。
7.3.1给Rabbit装备Shovel：Shovel插件介绍
Shovel是RabbitMQ的一个插件，可以使你能够定义RabbitMQ上的队列和
另一个RabbitMQ上的交换器之间的复制关系。Shovel最初是由LShift（Rabbit
Techologies的母公司之一）设计的，现在由RabbitMQ核心开发团队来维护。像
其他绝大多数RabbitMQ插件一样，Shovel是RabbitMQ自有的Erlang应用程
序，会在Rabbit启动时被加载。不同于大部分插件，Shovel没有和Rabbit核心
进行深度集成一当你在Shovel中定义两台服务器间复制关系的时候，你需要指
定两台服务器的完整URL，包括用户名和密码（例如，amqp：//guest:guest@
localhost：5675／）。从某些方面讲，可以将Shovel编写为独立的Erlang应用
而不是一个RabbitMQ插件。但是凭借作为RabbitMQ的插件，你可以依赖每次
RabbitMQ服务器启动时自动启动Shovel和自定义复制关系。
也许真实世界的示例可以更好地展示Shovel是如何工作的。农夫Jacques运营
着AvocadosSupremeLimited，加州南部一个巨大的牛油果养殖公司。Jacques遇到
了一个问题：多年来，AvocadosSupreme运营着在加州的戈利塔（Goleta）市的单
---
## Page 165
7.3远距离通信和复制
143
一仓库。但是最近一段时间，该仓库经营负荷80%，并且有时候库存会告，一
些订单因此遭到了延误。为了解决这个问题，Jacques沿着那条路在卡平特里亚
（Carpinteria）开设了第二间仓库（见图7.4）。卡平特里亚仓库的唯一目的是承载额
外的库存，并在戈利塔仓库不堪重负时运送订单。
网站
仓库
仓库
RabbitMQ
#2
卡平特里亚
图7.4仓库地图拓扑
整个AvocadosSupreme运作中最闪亮的一点是它们的订单处理系统。该系统
使用RabbitMQ将网站和在戈利塔仓库中的订单处理连接起来。现在卡平特里亚仓
库上线运作了，Pierre（AvocadoSupreme的技术架构师）正深陷困境，试图找出如
何连接到新的仓库以接收戈利塔无法满足的订单。由于他无法使用RabbitMQ集群
来桥接这两个仓库，因此Pierre打算更新网站将消息同时发布到戈利塔和卡平特里
亚上的RabbitMQ服务器。但是Pierre的担心之处在于这会减慢网站上的订单接收，
因为在其向客户确认订单之前，网站应用不得不发布消息到戈利塔（网站所处的地
方）和卡平特里亚（一个更长的往返，见图7.5）。更不用提Pierre现在不得不修改
---
## Page 166
144
第7章warren和Shovel：故障转移和复制
Web应用才能完成目标了。想当初他选择消息通信的理由之一就是，不用更改前端
代码就能路由消息。正当Pierre哀叹之际，他发现了Shovel。
牛油果订单
网站
RabbilMQ
RabbitMQ
戈利塔
卡平特里亚
仓库
仓库
图7.5不使用Shovel的订单处理
在做了一些试验之后，Pierre发现他可以使用Shovel在戈利塔创建一个新的队
列，订阅到incoming_orders交换器上，用以接收网站发布的消息。然后他让
Shovel消费这些消息并重新将消息通过WAN连接发布到卡平特里亚的RabbitMQ
上的incoming_orders交换器（见图7.6）。最棒的地方是网站不用放慢确认订单