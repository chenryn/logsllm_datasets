title:Multi-module vulnerability analysis of web-based applications
author:Davide Balzarotti and
Marco Cova and
Viktoria Felmetsger and
Giovanni Vigna
Multi-Module Vulnerability Analysis of Web-based
Applications
Davide Balzarotti, Marco Cova, Viktoria V. Felmetsger, and Giovanni Vigna
Computer Security Group
University of California, Santa Barbara
{balzarot, marco, rusvika, vigna}@cs.ucsb.edu
Santa Barbara, CA, USA
ABSTRACT
In recent years, web applications have become tremendously pop-
ular, and nowadays they are routinely used in security-critical envi-
ronments, such as medical, ﬁnancial, and military systems. As the
use of web applications for critical services has increased, the num-
ber and sophistication of attacks against these applications have
grown as well. Current approaches to securing web applications
focus either on detecting and blocking web-based attacks using
application-level ﬁrewalls, or on using vulnerability analysis tech-
niques to identify security problems before deployment.
The vulnerability analysis of web applications is made difﬁcult
by a number of factors, such as the use of scripting languages, the
structuring of the application logic into separate pages and code
modules, and the interaction with back-end databases. So far, ap-
proaches to web application vulnerability analysis have focused on
single application modules to identify insecure uses of informa-
tion provided as input to the application. Unfortunately, these ap-
proaches are limited in scope, and, therefore, they cannot detect
multi-step attacks that exploit the interaction among multiple mod-
ules of an application.
We have developed a novel vulnerability analysis approach that
characterizes both the extended state and the intended workﬂow of
a web application. By doing this, our analysis approach is able to
take into account inter-module relationships as well as the interac-
tion of an application’s modules with back-end databases. As a re-
sult, our vulnerability analysis technique is able to identify sophis-
ticated multi-step attacks against the application’s workﬂow that
were not addressed by previous approaches. We implemented our
technique in a prototype tool, called MiMoSA, and tested it on sev-
eral applications, identifying both known and new vulnerabilities.
Categories and Subject Descriptors: D.2.4 [Software Engineer-
ing]: Software/Program Veriﬁcation
General Terms: Security
Keywords: Web Applications, Multi-step Attacks, Vulnerability
Analysis, Static Analysis, Dynamic Analysis
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’07, October 29–November 2, 2007, Alexandria, Virginia, USA.
Copyright  2007  ACM  978-1-59593-703-2/07/0010  ...$5.00.
1.
INTRODUCTION
Web applications are growing in popularity. The introduction of
sophisticated mechanisms for the handling of asynchronous events
in web browsers and the availability of a number of frameworks for
the rapid prototyping of server-side components have fostered the
development of new applications and the transition of “traditional”
applications (e.g., mail readers) to web-based platforms.
While new technologies have brought in signiﬁcant advantages
in terms of support to the development process, improved perfor-
mance, and increased interoperability, little has been done to tackle
security issues. Therefore, as the complexity of web applications
increases, the possibility for abuse increases as well. For exam-
ple, a simple analysis of the CVE vulnerability database [4] shows
that the percentage of web-based attacks rose from 25% of the total
number of entries in 2000 to 61% in 2006.
This situation is made worse by the fact that web applications are
usually reachable through ﬁrewalls by design, and, in addition, the
server-side logic is often developed under time-to-market pressure
by developers with insufﬁcient security skills. As a result, vulnera-
ble web applications are deployed and made available to the whole
Internet, creating easily-exploitable entry points for the compro-
mise of entire networks.
To address the security problems associated with web applica-
tions, the research community has proposed a number of solutions.
A ﬁrst class of solutions focuses on detecting (and possibly block-
ing) web-based attacks. This can be done by analyzing the requests
sent to web applications [13, 2, 21, 17, 18] or, in some cases, by an-
alyzing the data delivered by the applications to the clients [11, 8].
These solutions have the advantage that they do not require any
modiﬁcation to the application being protected. However, they
have a signiﬁcant impact on the system’s performance, and, in case
of false positives (i.e., wrong detections), they may block legitimate
trafﬁc.
A second class of solutions focuses on identifying ﬂaws in the
implementation of a web application before the application is de-
ployed. These approaches utilize static and dynamic analysis tech-
niques to identify vulnerabilities in web applications [7,9,14]. Most
of these approaches are based on the assumption that vulnerabilities
in web applications are the result of insecure data ﬂow. Therefore,
these techniques attempt to identify when data originating from
outside the application (e.g., from user input) is used in security-
critical operations without being ﬁrst checked and sanitized.
Even though these approaches are effective at detecting suspi-
cious uses of unsanitized data, they suffer from three main limita-
tions. First, their scope is limited to a single web application mod-
ule, such as a single PHP ﬁle or a single ASP component. There-
fore, these techniques are not able to identify vulnerabilities that
are caused by the interaction of multiple modules. Second, these
25approaches are not able to correctly model the interactions among
multiple technologies, such as the use of multiple languages in the
same application, or the use of back-end databases to store persis-
tent data. Third, and most important, these techniques do not take
into account either the intended workﬂow of a web application or
its extended state.
The intended workﬂow of a web application represents a model
of the assumptions that the developer has made about how a user
should navigate through the application. Web applications are of-
ten designed to guide the user through a speciﬁc sequence of steps.
For example, an e-commerce site could be structured so that the
user ﬁrst logs in, then browses a catalog and chooses some goods,
and eventually checks out and purchases the items. The constraints
among operations (e.g., one has to select some goods before pur-
chasing them) deﬁne the application’s intended workﬂow.
A number of mechanisms have been devised to track the progress
of a user through the intended workﬂow of a web application. These
mechanisms provide ways to store information that survives a sin-
gle client-server interaction and deﬁne the extended state of the
application. For example, in a LAMP application1 the extended
state could include the request variables used in each module and,
in addition, the PHP session data and the database tables, which
are shared between modules. The extended state can also include
information that is sent back and forth between the client and the
server to keep track of a user session, such as hidden form ﬁelds
and application-speciﬁc cookies. Therefore, the extended state of
an application is a distributed collection of session-related infor-
mation, which is accessed and modiﬁed by the modules of a web
application at different times during a user session.
Unfortunately, it is possible that different modules of an applica-
tion have different assumptions on how the extended state is stored
and handled, leading to vulnerabilities in the application. We call
these vulnerabilities multi-module vulnerabilities to emphasize the
fact that they originate from the interaction of multiple application
modules, which communicate by reading and modifying the appli-
cation’s extended state.
In this paper, we present a novel vulnerability analysis approach
that combines several analysis techniques to identify sophisticated
multi-module vulnerabilities in web applications. In our approach,
we ﬁrst leverage dynamic approaches to analyze block-level prop-
erties in the code of web application modules. We then use static
analysis to extract properties at the module level. Finally, we use
model checking techniques to identify possible paths in a web ap-
plication’s workﬂow that could lead to an insecure state.
The contributions of our approach are the following:
• We introduce a novel model of web application extended
state that characterizes permanent storage and is not limited
to the variables and data structures deﬁned in a single proce-
dure or code module.
• We present a novel approach to analyze the interaction be-
tween the application’s code and back-end databases, which
allows for the identiﬁcation of sophisticated data-driven at-
tacks.
• We introduce an approach to derive the intended workﬂow of
a web application and an analysis technique to identify multi-
step attacks that violate the expected inter-module workﬂow
of a web application.
plications, and we evaluated it on a number of real-world appli-
cations, ﬁnding both known and new vulnerabilities. The results
show that our approach is able to identify complex vulnerabilities
that state-of-the-art techniques are not able to identify.
The rest of the paper is structured as follows. In Section 2, we
present some examples of the vulnerabilities that are the focus of
our approach. In Section 3, we introduce the web application model
that is at the basis of our analysis. Section 4 and 5 describe our ap-
proach to the identiﬁcation of multi-module vulnerabilities in web
applications. Then, Section 6 presents the results of applying our
analysis to real-world applications. Finally, Section 7 presents re-
lated work, and Section 8 brieﬂy concludes.
2. MULTI-MODULE ATTACKS
Multi-module attacks can be categorized into two classes: data-
ﬂow attacks and workﬂow attacks. Data-ﬂow attacks exploit the
insecure handling of user-provided information that is stored in the
web application’s state and passed from one module to another. In
workﬂow attacks, an attacker leverages errors in how the state is
handled by the application’s modules in order to use the application
in ways that violate its intended workﬂow.
Data-ﬂow Attacks.
In multi-module data-ﬂow attacks, the attacker uses a ﬁrst mod-
ule to inject some data into the web application’s extended state.
Then, a second module uses the attacker-provided data in an in-
secure way2. Examples of multi-module data-ﬂow attacks include
SQL injection [3] and persistent (or stored) Cross-Site Scripting
attacks (XSS) [12].
A web application is vulnerable to a SQL injection attack when it
uses unsanitized user data to compose queries that are later passed
to a database for evaluation. The exploitation of a SQL injection
vulnerability can lead to the execution of arbitrary queries with the
privileges of the vulnerable application and, consequently, to the
leakage of sensitive information and/or unauthorized modiﬁcation
of data. In a typical multi-module SQL injection scenario, the at-
tacker uses a ﬁrst module to store an attack string containing ma-
licious SQL directives in a location that is part of the application’s
extended state (e.g., a session variable). Then, a second module
reads the value of the same location from the extended state and
uses it to build a query to the database. As a result, the malicious
SQL directives are “injected” into the query.
In cross-site scripting attacks, an attacker forces a web browser
to evaluate attacker-supplied code (typically JavaScript) in the con-
text of a trusted web site. The goal of these attacks is to circumvent
the same-origin policy, which prevents scripts or documents loaded
from one site from getting or setting the properties of documents
originating from different sites. In a multi-module XSS attack, a
ﬁrst module is leveraged to store the malicious code in a location
that is part of the extended state of the application, e.g., in a ﬁeld
of a table in the back-end database. Then, at a later time, the ma-
licious code is presented to a user by a different module. The user
browser executes the code under the assumption that it originates
from the vulnerable application rather than from the attacker, effec-
tively circumventing the same-origin policy.
Workﬂow Attacks.
We implemented our approach in a prototype analysis tool, called
MiMoSA (Multi-Module State Analyzer), for PHP-based web ap-
1A LAMP application is a web application based on the composi-
tion of Linux, Apache, MySQL, and PHP.
Most web applications have policies that restrict how they can
be navigated to ensure that their functionality and data is accessed
2As it will be clear later, this second module can be a second invo-
cation of the module that performed the ﬁrst step of the attack.
in a well-deﬁned and controlled way. Usually, to implement these
restrictions a module stores in the web application’s extended state
the current navigation state, e.g., whether or not the current user
has logged in or has already visited a certain page. Other modules,
then, use this portion of the state information to deny or authorize
access to other parts of the application.
Workﬂow attacks attempt to circumvent these navigation restric-
tions. For example, a workﬂow attack could try to directly access a
page that is not reachable through normal navigation mechanisms,
such as hyper-textual links3. These attacks may allow one to by-
pass authorization mechanisms (e.g., gaining access to restricted
portions of a web application) or to subvert the correct business
logic of the application (e.g., skipping a required step in the check-
out sequence of operations on an e-commerce web site).
3. A FORMAL CHARACTERIZATION OF
MULTI-MODULE VULNERABILITIES
In the previous sections, we described how the state of a web
application can be maintained in a number of different ways. In
order to abstract away from the various language- or technology-
speciﬁc mechanisms, we introduce the concept of state entity. A
state entity E is similar to a variable in a traditional programming
language, in that it can be used to store parts of the application’s
state. Different modules can share information by accessing the
same state entities. The set of all the state entities corresponds to
what we deﬁned in the introduction as the application’s extended
state.
We classify the state entities into two classes: server-side and
client-side. Server-side entities model the part of the extended state
that is maintained on the server. For example, a server-side entity
can represent a ﬁeld in a database or a PHP session variable. Client-
side entities are instead used to model the part of the extended state
stored in and/or generated by the user’s browser. Cookies, GET
and POST parameters are examples of this type of entities.
3.1 Module Views
To summarize the operations that each module performs on the
application’s extended state, we introduce the concept of Module
View (or simply view hereinafter). Each view represents all the
state-equivalent execution paths in a single module, i.e., all the
paths in the control-ﬂow graph (CFG) of a module that perform the
same operations on the state entities. When an application mod-
ule is executed, e.g., as a consequence of a user request, the path
followed by the execution in that module is completely included in
one and only one of its views. In this case, we say that the view that
contains the executed path is “entered” by the user. We describe the
algorithm used to summarize a module into its views in Section 4.3.
Consider, for example, the login module of an application. When
a user provides correct credentials, the module may deﬁne a set of
new session variables (e.g., to track that the user is authenticated
and to load her preferences). On the contrary, the module may
redirect unauthorized users to an error page without changing the
extended state. These two different behaviors depend on the cur-
rent extended state of the application, namely on the values of the
request parameters and the content of the database that stores the
information about the users. The view abstraction allows us to asso-
ciate with each behavior a compact representation that summarizes
its effect on the extended state of the application.
Formally, a view V is represented as a triple (Φ, Π, Σ) where:
• Φ is the view’s pre-condition, which consists of a predicate
3This attack is sometimes referred to as “forceful browsing.”
on the values of the state entities. The program paths mod-
eled by the view can be executed only when the view pre-
condition is true (evaluated in the context of the current ex-
tended state).
• Π is the set of post-conditions of the view. These conditions
model, as a sequence of write operations on state entities, the
way in which the extended state is modiﬁed by the execution
of the program paths represented by the view. Each write
operation has the following form:
write(EL, ER, Ψ).
This operation copies the content of the left entity EL (which
can also be a constant value) to the right entity ER. The
set Ψ contains the sanitization operations applied to the left
entity before its value is transferred to the right entity. If the
sanitization set is empty, no sanitization is applied.
• Σ is the set of sinks contained inside the view. Each sink is
a pair (E, Op) where E is a state entity and Op is a poten-
tially dangerous operation (such as a SQL query or an eval
statement) that uses the entity unsanitized. Note that the un-
sanitized use of an entity is not necessarily a vulnerability,
since the sanitization process may take place inside one of
the other views (belonging to the same module or to another
module).
The extended state of an application may change as the user
moves from one web page to another, clicking on links, submit-
ting forms, following redirects, or just jumping to a new URL. In
fact, when a view is entered, the extended state S is updated by ap-
plying the view’s post-conditions to the extended state in which the
application was before entering the view. Let Vi = (Φi, Πi, Σi) be
the view entered at step i of the user’s navigation process, then:
Sinit = ∅
Si = apply(Πi, Si−1).
In addition to the set of the entity values, the extended state also
keeps track of the current sanitization state of each entity. An en-
tity E is sanitized in the application state Si (represented by the
predicate san(E, Si)) if its value is set by sanitizing write opera-
tions. In this work, we take the standard approach of assuming that
sanitization operations are always effective in removing malicious
content from user-provided data.
3.2 Application Paths
The presence of the pre-condition predicate in each view limits
the possible paths that a user may follow inside the web application.
We say that a path P = (cid:3)V0, V1, . . . , Vn(cid:4), where Vi is a view,
belongs to the set of Navigation Paths N if and only if:
∀i < n, Si |= Φi+1,
that is, if and only if the state at each intermediate step satisﬁes the
pre-condition of the following step.
Since at the beginning of the execution the application state is
empty, it must be ∅ |= Φ0. In order for this to happen, the pre-
condition Φ0 must be empty or it must contain only predicates on
client-side entities. This is justiﬁed by the fact that pre-conditions
containing only client-side entities (for example, those requesting
a particular value for a certain GET parameter) can always be sat-
isﬁed if the user provides the right value. We deﬁne the set of
Application Entry Points η as the subset of views that can be used
as starting points in a navigation path:
Vi ∈ η
iff
∅ |= Φi.
The subset of navigation paths allowed by the application design
is called the Intended Path set, I ⊆ N . These paths represent
the workﬂow of the web application, expressed either through the
use of explicit links provided by the application or through other
common user navigation behaviors. We say that a navigation path
(cid:3)V0, . . . , Vn(cid:4) belongs to the intended path set of the application if
«
and only if:
„
Vi+1 ∈ η∨∃Link(Vi, Vi+1)∨Vi−1 = Vi+1∨Vi = Vi+1
∀i < n
.