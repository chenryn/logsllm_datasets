forcement. PVE also instruments the VMM to intercept
the guest OS when executing call, ret and indirect jmp
instructions.
3.1 System Load and Global Data Structure
Identiﬁcation
Identifying the global data structures is a ﬁrst step to-
wards reconstruction of guest view because most relevant
data structures like process structure, modules list, etc., are
traversable from the globals. PVE refers to certain CPU reg-
isters to identify guest kernel load address and global data.
When the guest OS loads, one of the ﬁrst tasks performed
by the OS is to set up the System Call Table and the In-
terrupt Descriptor Table. We leverage the fact that system
call handlers are located inside the OS kernel to compute
the address where the kernel is loaded. For example in Win-
dows, at the start of the system, we monitor the CPU till
we ﬁnd a valid entry in the sysenter_eip register. Then,
we scan backwards for all the page-aligned addresses till we
313Total CFI
Whitelist 
Cache
CFI Model
CFI  Component
Exploit 
Diagnostic 
Report
Thread
Info
Module
Info
Opcode
Process 
Callback
Info
PVE Component
Emulator
Guest 
HDD
G
u
e
s
t
M
e
m
o
r
y
Guest 
CPU
Guest OS
Figure 1: Architecture Overview of Total-CFI
ﬁnd the MSDOS header - 0x5a4d and the NT signature -
0x00004550.
Using a set of pre-determined addresses to locate the glob-
als may work if ASLR is disabled however, if ASLR is en-
abled, which is the default case in Windows 7, such an ap-
proach does not work. Once the kernel is located, PVE
component parses the kernel binary to extract the exported
kernel symbols. In ﬂavors of Windows OS, when the exe-
cution is in the kernel, the base of the FS register in the
CPU contains the address of a global data structure called
KPCR. Once the KPCR structure is identiﬁed, other kernel
data structures like the process list, thread list, module list,
etc., can be reached by traversing from the KPCR structure.
3.2 Process Identiﬁcation
The value of the CR3 register in the CPU is unique for
every process running in the system. PVE component lever-
ages this fact to identify new processes in the system. With
respect to the CFIC, process information is required for two
reasons. Firstly, it is needed to associate the identiﬁed ex-
ploits to the actual process that is exploited. Secondly, pro-
cess information is needed to associate whitelists with pro-
cesses. When a new module is loaded in a process address
space, the process whitelist is updated with the whitelist
corresponding to the module that was loaded. In modern
x86 CPUs the CR3 control register is unique per process and
is used by the CPU to translate virtual address to physi-
cal address. PVE component monitors the CR3 register for
new entries which have not been previously encountered. A
new value in the CR3 register implies that a new process
has started. When a new entry is found in the CR3 regis-
ter, PVE component traverses the list of processes starting
from the previously identiﬁed global data structure (KPCR
in Windows) to identify the new process that was started.
Furthermore, detecting process exits is necessary to re-
lease the process related shadow memory used by Total-CFI
so as not to result in memory leaks. Both Linux and Win-
dows OSs contain the process exit time as members in the
process data structure. At regular pre-conﬁgured intervals,
PVE component scans the list of process structures for non-
zero process exit time. If found, PVE component deletes the
corresponding process from its records. Whenever a process
starts or a process exits, PVE component appropriately no-
tiﬁes the CFI component of Total-CFI.
3.3 Module Identiﬁcation
A new module executed in the process address space re-
sults in a new entry in code cache of the TLB. PVE compo-
nent maintains a list of already encountered entries in the
code cache of TLB and when a new entry is encountered, it
traverses the process’ module list to retrieve a new module,
if present.
In Total-CFI, we instrument the VMM’s TLB
cache handling code to insert callbacks such that, whenever
a new entry is made into the code cache of the TLB, PVE
component callback handler traverses the process’ module
list2 and identiﬁes new modules, if any.
If no new module is found in the process module list
(which is possible if the new entry corresponds to a new
code page in an already existing module), PVE component
adds the entry to the list of already encountered TLB code
cache entries. When a new module is identiﬁed, PVE com-
ponent extracts the full path of the module
(Eg: LDR DATA TABLE ENTRY. FullDllName in Win-
dows), base address and size of the module.
Module unload.
It is necessary to identify the module
unloads to ensure that there are no redundant entries in the
process whitelist hence reducing the possibilities of dangling
pointer type of attacks. The code cache of TLB can only
indicate if a module is loaded. Capturing the module unload
event is less straightforward. Total-CFI considers a module
unloaded/modiﬁed only if the code pages of the module are
overwritten. Therefore, if an entry is created in the write
cache of the TLB that also exists in the code cache of the
TLB, a module is said to be unloaded. The list of modules
is updated during such an event to precisely identify the
unloaded modules.
3.4 Thread Stack Layout Identiﬁcation
We use a novel technique described in Algorithm 1 to
identify the thread stack layout in the executing guest OS.
Identifying threads is critical in identifying the appropriate
execution stack, which in-turn is correlated to the shadow
stack maintained by the CFIC.
2The process list can be retrieved by traversing PsActive-
ProcessHead in Windows and task_struct.task_list in
Linux
314Algorithm 1 Algorithm to identify the Thread Stack Lay-
out. All actions except † either act upon Total-CFI’s shadow
memory or retrieve information from the guest CPU. † re-
trieves information from guest memory.
1: procedure GetStack(GuestCP U CP U )
P rocess ← ProcFromCR3(CP U.CR3)
2:
T hread ← P rocess.GetCurrThread()
3:
new thread ← FALSE
4:
if PAGE(CP U.ESP ) = PAGE(T hread.StackEnd) then
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
stack ← T hread.GetShadowStack()
T hread ← GetCurrThreadFromGuest()†
if T hread /∈ P rocess then
end if
T hread.StackEnd ← CP U.ESP & PAGE_MASK
stack ← T hread.Stack
P rocess.Add(T hread)
T hread.InitShadowStack()
newT hread ← TRUE
(cid:1) If cpu in kernel, kernel
(cid:1) Slow lookup
else
stack, else user stack.
16:
17:
18:
19:
20:
21:
22:
23:
end if
24:
return stack
25:
26: end procedure
end if
if new thread then
T hread.StackStart ← PAGE(CP U.ESP )
end if
if T hread.StackEnd overlaps with any
thread.StackStart where thread ∈ P rocess then
DeleteThread(thread)
P rocess.Remove(thread)
Based on the context of execution, threads can be classi-
ﬁed into:
(a) User level thread - These threads operate in user priv-
ilege level. They are assigned a stack in user space.
(b) Kernel level thread - These threads operate in kernel
privilege level. They are assigned a stack in the kernel
region.
(c) User managed thread - These threads are optionally
created and managed by the application code. They
operate within the context of a user level thread and
share the thread’s stack.
Identifying each of the above types of threads is challeng-
ing. Speciﬁcally, CFIC is interested in eﬃciently identifying
the precise shadow stack to act upon. In a given thread of
execution, normally the ESP register changes through push,
pop, add, sub instructions to allocate and reclaim stack
space. More importantly, sizes of such allocations and de-
allocations are often small. Moreover, the OS allocates stack
space for threads at page granularity. Therefore, we devise
an algorithm to identify stack space partition by examining
the ESP movement. Algorithm 1 leverages from the above
observations to identify the current thread context. It min-
imizes the performance overhead imposed due to accessing
the guest memory by only accessing the guest memory when
the execution context switches to a diﬀerent thread within
the same process. All other accesses are performed by either
looking up the shadow memory or by directly accessing the
guest CPU, which are both considerably faster. Further-
more, ESP register in the CPU contains the base address of
the current stack frame. As long as the ESP register value
remains in the same page in a given address space, the exe-
cution must be in the same thread context.
By keeping track of a thread’s stack boundaries both in
the kernel and the userland3, PVE component can identify
the thread that is running by referring to the ESP register
at any given point. However, if it encounters a value in
the ESP register that does not belong to any of the known
threads, it is possible that a new thread has started or that
a thread’s stack frame has grown. Every user level thread
structure, irrespective of the OS contains information re-
garding user managed threads (if any). PVE component
determines if the current context of execution is in a user
managed thread by referring to the thread structure.
In
such a case, it obtains the thread ID and the user man-
aged thread ID of the currently executing thread (for ex-
ample in Windows, if the execution is in the kernel, the
thread id can be obtained by traversing through the path,
KPCR→Prcb→CurrentThread→Cid→UniqueThread
and if the execution is in the user level, thread ID can be ob-
tained by directly accessing the CurrentThreadId member
of the Thread Information Block (TIB)).
In ﬂavors of Windows OS, when the execution is in user
mode, the base address of the FS register contains the TIB.
Other than the thread ID, TIB also contains the user man-
aged thread (Fiber) information. Since a majority of ap-
plications do not implement Fibers, in the interest of per-
formance Total-CFI does not support Fibers in the default
setting, however it is conﬁgurable to do so. A thread’s stack
can increase and overlap another thread’s stack base only if
the latter thread has terminated. Therefore, if PVE compo-
nent ﬁnds an overlap, it deletes the thread whose stack base
gets overlapped.
If Total-CFI is conﬁgured to use Fibers,
it uses the combination of thread ID and ﬁber ID as the
shadow stack identiﬁer.
3.5 Dynamically Generated Code
We further PVE to identify dynamically generated code.
Execution of dynamically generated code portray the follow-
ing characteristics:
(i) Firstly, the page containing the dynamically generated
code must be written to memory and made executable
(specially on systems with DEP enabled) before it is
executed.
(ii) Secondly, control transitions from non-dynamic to dy-
namic code follow a ﬁnite pre-set path.
PVE component tracks the entries in the code and the write
caches of TLB to identify dynamically generated code.
If
an entry in the write cache of the TLB were to appear in
the code cache of the TLB, PVE component identiﬁes it as
dynamically generated code. Details on CFI enforcement
for dynamic code can be found in Section 4.3.
4. CONTROL FLOW INTEGRITY ENFORCE-
MENT (CFIC)
CFI enforcement component closely interacts with the
PVE component and enforces a system-wide instruction level
CFI model and diagnoses exploits by detecting violations
to the CFI model. Exploits alter the normal control ﬂow
by manipulating the derived code addresses (e.g., function
pointers).
3Requested Privilege Level of the CS register on the CPU to
determine the Current Privilege Level (CPL). A CPL value
of 0 indicates kernel.
315Total-CFI’s CFI model is based on the following two ob-
servations:
(a) Most of the control ﬂow is restricted by a pre-determined
subset of code that forms the entry point of branch tar-
gets. For example, targets of call, jmp instructions
must adhere to the statically determined call graph.
(b) A ret instruction must return to an address succeeding
a call instruction that was previously encountered.
CFIC requests PVE component to dispatch callbacks when-
ever the guest OS executes instructions with opcodes that
correspond to variants of call, ret instructions or with op-
codes that correspond to variants of indirect jmp instruction.
As per observation (a), when indirect jmp, call instruc-
tions are encountered, CFIC checks if the target address is
in the whitelist.
If not found, the CFI model is violated
and CFIC reports that the instruction is a part of a possi-
ble exploit. Based on observation (b), CFIC maintains two
shadow call stacks per executing thread in the system. One
stack shadows the user level stack of the thread and the
other shadows the kernel level stack. Whenever a call in-
struction is encountered, CFIC pushes the return address to
the corresponding shadow stack (kernel level shadow stack
if operating in kernel mode and user level shadow stack if
operating in user mode) of the currently executing thread.
When a ret instruction is encountered, CFIC pops the
target address of the return instruction from the appropriate
stack of the currently executing thread. If the target address
is not found on the shadow stack and the target address does
not belong to dynamically generated code, CFIC reports the
ret instruction to be a part of a potential exploit.
In the remainder of this section, we present the internal
details and challenges addressed by CFIC.
4.1 Target Whitelist
The addresses within the relocation table and the export
table of the binary constitute the module whitelist. With
compatibility in mind, most modern binaries are compiled
to be relocatable. When the loader cannot load a binary at
its default location, it performs relocation. The loader refers
to the relocation table and ﬁxes the addresses of the entries
in the relocation table. Indirectly addressable code must be
relocatable. Similarly, export table contains the functions