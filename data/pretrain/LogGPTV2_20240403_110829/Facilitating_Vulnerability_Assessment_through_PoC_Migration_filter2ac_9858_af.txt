### Potentially be used for solving our problem. However, directed fuzzing suffers from finding the critical path to trigger the desired bug even though it could find paths to reach the desired code snippet. As such, it cannot be treated as an effective solution for our problem.

**Revised:**
Directed fuzzing, while capable of discovering paths to reach specific code snippets, often struggles to identify the critical path necessary to trigger the desired bug. Consequently, it is not a reliable solution for our problem.

### 8 CONCLUSION
Crowd-sourced software vulnerabilities are usually reported as CVE (Common Vulnerabilities and Exposures) reports and later archived in the National Vulnerability Database (NVD). A recent study has already highlighted the low quality of these reports, such as over-claimed or under-claimed vulnerable versions. In this work, we introduce a systematic, automated approach to assess under-claimed vulnerable versions for a reported vulnerability. Our proposed approach leverages a fuzzing-based method to migrate a Proof-of-Concept (PoC) input to a target version. Through a series of carefully designed experiments, we demonstrate that the fuzzing-based approach can effectively and efficiently migrate a PoC input from one vulnerable version to another. We conclude that our proposed technique can serve as a tool to improve the quality of NVD reports. As part of our future work, we plan to conduct a larger scale of experiments to further explore the utility of our tool.

### ACKNOWLEDGMENT
We would like to thank our shepherd Yajin Zhou and the anonymous reviewers for their insightful comments, which helped improve the paper. This work was supported in part by the National Natural Science Foundation of China (U1836210, U1836213, U1736208, 61972099, 62172105), and the Natural Science Foundation of Shanghai (19ZR1404800). Yuan Zhang was supported in part by the Shanghai Rising-Star Program under Grant 21QA1400700. Min Yang is the corresponding author and a faculty member at the Shanghai Institute of Intelligent Electronics & Systems, Shanghai Institute for Advanced Communication and Data Science, and the Engineering Research Center of Cyber Security Auditing and Monitoring, Ministry of Education, China.

### Session 12B: Analyzing Crashes and Incidents CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea

### REFERENCES
[References remain unchanged as they are already well-formatted and clear.]

### A IMPLEMENTATION DETAILS
#### Trace Collection
We implemented a lightweight trace collector using an LLVM instrumentation pass. For every function call, we log the callee function, caller function, and the corresponding callsite. These logs are used to construct tree-structured execution traces. Additionally, we log the intra-function execution flow by instrumenting each basic block, with each block having a unique intra-function ID.

#### Code Similarity Calculation
We leverage code features widely used in existing works to calculate similarity scores between cross-version functions and basic blocks.

For function-level similarity calculation, we first normalize the source code of a function and then extract various features, including its callers, callees, and constant values. The similarity score \( \text{Sim}(X, Y) \) between function \( X \) and function \( Y \) is defined as follows:

\[
\text{Sim}(X, Y) = \frac{\text{Sim}_c(X, Y) + \text{Sim}_j(X, Y)}{2}
\]

where

\[
\text{Sim}_c(X, Y) = 1 - \frac{\text{edit\_distance}(X, Y)}{\max(\text{len}(X), \text{len}(Y))}
\]

and

\[
\text{Sim}_j(X, Y) = \frac{\text{Sim}_{\text{caller}}(X, Y) + \text{Sim}_{\text{callee}}(X, Y) + \text{Sim}_{\text{const}}(X, Y)}{3}
\]

with

\[
\text{Sim}_{\text{caller}}(X, Y) = \text{Jaccard}(\text{F}_{\text{caller}}(X), \text{F}_{\text{caller}}(Y))
\]

\[
\text{Sim}_{\text{callee}}(X, Y) = \text{Jaccard}(\text{F}_{\text{callee}}(X), \text{F}_{\text{callee}}(Y))
\]

\[
\text{Sim}_{\text{const}}(X, Y) = \text{Jaccard}(\text{F}_{\text{const}}(X), \text{F}_{\text{const}}(Y))
\]

In these equations, \(\text{edit\_distance}()\) calculates the edit distance [45] between the normalized source code of the functions, and \(\text{len}()\) indicates the length of the normalized function code. The functions \(\text{F}_{\text{caller}}(), \text{F}_{\text{callee}}(), \text{F}_{\text{const}}()\) extract the callers, callees, and constant values used in the function, respectively. \(\text{Jaccard}()\) takes two feature sets as input and returns the Jaccard similarity [47] between them.

For basic-block-level similarity calculation, we consider the internal and structural features of a basic block. Given a pair of basic blocks \((b_r, b_t)\), we use \(\text{Sim}_b\) to represent their similarity score on internal features and \(\text{Sim}_s\) to represent their similarity score on structural features. To compute \(\text{Sim}_b\), we collect all the internal features in the basic block, including opcodes, data, and called functions, and use Jaccard similarity to measure the shared features, i.e., \(\text{Sim}_b(b_r, b_t) = \text{Jaccard}(b_r, b_t)\). To compute \(\text{Sim}_s\), we first collect the predecessor basic blocks of \(b_r\) and \(b_t\) as \(\{P_r\}\) and \(\{P_t\}\), and their successor basic blocks as \(\{Q_r\}\) and \(\{Q_t\}\). Then, we define \(\text{Sim}_s\) to measure the similarity of their predecessors and successors with the following equation:

\[
\text{Sim}_s(\{X_r\}, \{X_t\}) = \frac{\max_{x_r \in \{X_r\}, x_t \in \{X_t\}} \text{Sim}_b(x_r, x_t)}{\min(|\{X_r\}|, |\{X_t\}|)}
\]

Finally, we combine the similarity scores of the internal and structural features to calculate the overall similarity score between \(b_r\) and \(b_t\):

\[
\text{Sim}(b_r, b_t) = \frac{\text{Sim}_b(b_r, b_t) + \text{Sim}_s(\{P_r\}, \{P_t\}) + \text{Sim}_s(\{Q_r\}, \{Q_t\})}{3}
\]

A pair of basic blocks \((b_r, b_t)\) is considered a candidate pair for alignment only if their similarity score exceeds a predefined threshold. In this work, we set the threshold to 0.5, consistent with the threshold in [20].

#### Taint Tracking
We correlate the input bytes with critical variables using variable-level taint tracking. Our implementation builds on PolyTracker [6], enhancing its tainting logic on load and store instructions to support fine-grained variable-to-input-bytes mapping. Additionally, we optimized PolyTracker to support language features used in real-world programs, such as variable-length arguments, which were not well-supported in the original version. This enhancement ensures that variables are fully tainted at runtime, addressing potential under-tainting issues.