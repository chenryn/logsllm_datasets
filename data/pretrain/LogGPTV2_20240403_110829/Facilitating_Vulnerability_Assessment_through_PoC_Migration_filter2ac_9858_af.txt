potentially be used for solving our problem. However, directed
fuzzing suffers from finding the critical path to trigger the desired
bug even though it could find paths to reach the desired code snippet.
As such, it cannot be treated as an effective solution for our problem.
8 CONCLUSION
Crowd-sourced software vulnerabilities are usually reported as
CVE reports and later achieved by the National Vulnerability
Database (NVD). A recent study has already unveiled these reportsâ€™
low-quality issues (e.g., over-claimed or under-claimed vulnerable
versions). In this work, we introduce a systematic, automated
approach to assessing the under-claimed vulnerable versions for a
reported vulnerability. Technically, our proposed approach utilizes
a fuzzing-based method to migrate a Proof-of-Concept input to a
target version. We show that the fuzzing-based approach could be
an effective, efficient approach to migrating a PoC input from one
vulnerable version to another through a series of carefully designed
experiments. We conclude that our proposed technique can serve as
a tool to facilitate the improvement of NVDâ€™s report quality. As part
of our future work, we will conduct a larger scale of experiments
further exploring the utility of our tool.
ACKNOWLEDGMENT
We would like to thank our shepherd Yajin Zhou and the anonymous
reviewers for their insightful comments that helped improve the
paper. This work was supported in part by National Natural
Science Foundation of China (U1836210, U1836213, U1736208,
61972099, 62172105), and Natural Science Foundation of Shanghai
(19ZR1404800). Yuan Zhang was supported in part by the Shanghai
Rising-Star Program under Grant 21QA1400700. Min Yang is
the corresponding author, and a faculty of Shanghai Institute of
Intelligent Electronics & Systems, Shanghai Institute for Advanced
Communication and Data Science, and Engineering Research
Center of Cyber Security Auditing and Monitoring, Ministry of
Education, China.
Session 12B: Analyzing Crashes and Incidents CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3312REFERENCES
[1] 2021. American Fuzzy Lop. http://lcamtuf.coredump.cx/afl/.
[2] 2021. BinDiff. https://www.zynamics.com/bindiff.html.
[3] 2021. Common Vulnerabilities and Exposures. https://cve.mitre.org/.
[4] 2021. National Vulnerability Database. https://nvd.nist.gov/.
[5] 2021. PIN Tools. https://software.intel.com/content/www/us/en/develop/article
s/pin-a-dynamic-binary-instrumentation-tool.html.
[6] 2021. PolyTracker. https://github.com/trailofbits/polytracker.
[7] Michael Backes, Sven Bugiel, and Erik Derr. 2016. Reliable Third-party Library
Detection in Android and its Security Applications. In Proceedings of the 23rd ACM
SIGSAC Conference on Computer and Communications Security (CCS), Vienna,
Austria. 356â€“367.
[8] Tim Blazytko, Moritz SchlÃ¶gel, Cornelius Aschermann, Ali Abbasi, Joel Frank,
Simon WÃ¶rner, and Thorsten Holz. 2020. AURORA: Statistical Crash Analysis for
Automated Root Cause Explanation. In Proceedings of the 29th USENIX Security
Symposium (USENIX Security), Virtual Event, USA. 235â€“252.
[9] Marcel BÃ¶hme, Van-Thuan Pham, Manh-Dung Nguyen, and Abhik Roychoudhury.
2017. Directed Greybox Fuzzing. In Proceedings of the 24th ACM SIGSAC
Conference on Computer and Communications Security (CCS), Dallas, TX, USA.
2329â€“2344.
[10] Martial Bourquin, Andy King, and Edward Robbins. 2013. Binslayer: Accurate
Comparison of Binary Executables. In Proceedings of the 2nd ACM SIGPLAN
Program Protection and Reverse Engineering Workshop (PPREW), Rome, Italy. 4:1â€“
4:10.
[11] Sang Kil Cha, Maverick Woo, and David Brumley. 2015. Program-adaptive
Mutational Fuzzing. In Proceedings of the 36th IEEE Symposium on Security and
Privacy (S&P), San Jose, CA, USA. 725â€“741.
[12] Oscar Chaparro, Jing Lu, Fiorella Zampetti, Laura Moreno, Massimiliano Di Penta,
Andrian Marcus, Gabriele Bavota, and Vincent Ng. 2017. Detecting Missing
Information in Bug Descriptions. In Proceedings of the 11th Joint Meeting on
Foundations of Software Engineering (FSE), Paderborn, Germany. 396â€“407.
[13] Hongxu Chen, Yinxing Xue, Yuekang Li, Bihuan Chen, Xiaofei Xie, Xiuheng Wu,
and Yang Liu. 2018. Hawkeye: Towards a Desired Directed Grey-box Fuzzer. In
Proceedings of the 25th ACM SIGSAC Conference on Computer and Communications
Security (CCS), Toronto, ON, Canada. 2095â€“2108.
[14] Kai Chen, Peng Liu, and Yingjun Zhang. 2014. Achieving Accuracy and
Scalability Simultaneously in Detecting Application Clones on Android Markets.
In Proceedings of the 36th International Conference on Software Engineering (ICSE),
Hyderabad, India. 175â€“186.
[15] Yaohui Chen, Peng Li, Jun Xu, Shengjian Guo, Rundong Zhou, Yulong Zhang,
Tao Wei, and Long Lu. 2020. SAVIOR: Towards Bug-Driven Hybrid Testing.
In Proceedings of the 41st IEEE Symposium on Security and Privacy (S&P), San
Francisco, CA, USA. 1580â€“1596.
[16] Jiarun Dai, Yuan Zhang, Zheyue Jiang, Yingtian Zhou, Junyan Chen, Xinyu Xing,
Xiaohan Zhang, Xin Tan, Min Yang, and Zhemin Yang. 2020. BScout: Direct
Whole Patch Presence Test for Java Executables. In Proceedings of the 29th USENIX
Security Symposium (USENIX Security), Virtual Event, USA. 1147â€“1164.
[17] Yaniv David, Nimrod Partush, and Eran Yahav. 2016. Statistical Similarity of
Binaries. In Proceedings of the 37th ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI), Santa Barbara, CA, USA. 266â€“280.
[18] Ying Dong, Wenbo Guo, Yueqi Chen, Xinyu Xing, Yuqing Zhang, and Gang Wang.
2019. Towards the Detection of Inconsistencies in Public Security Vulnerability
Reports. In Proceedings of the 28th USENIX Security Symposium (USENIX Security),
Santa Clara, CA, USA. 869â€“885.
[19] Yue Duan, Xuezixiang Li, Jinghan Wang, and Heng Yin. 2020. DeepBinDiff:
Learning Program-Wide Code Representations for Binary Diffing. In Proceedings
of the 27th Annual Network and Distributed System Security Symposium (NDSS),
San Diego, CA, USA.
[20] Sebastian Eschweiler, Khaled Yakdan, and Elmar Gerhards-Padilla. 2016. discovRE:
Efficient Cross-architecture Identification of Bugs in Binary Code. In Proceedings
of the 23rd Annual Network and Distributed System Security Symposium (NDSS),
San Diego, CA, USA.
[21] Shuitao Gan, Chao Zhang, Peng Chen, Bodong Zhao, Xiaojun Qin, Dong Wu,
and Zuoning Chen. 2020. GREYONE: Data Flow Sensitive Fuzzing. In Proceedings
of the 29th USENIX Security Symposium (USENIX Security), Virtual Event, USA.
2577â€“2594.
[22] Michael W. Godfrey and Lijie Zou. 2015. Using Origin Analysis to Detect Merging
and Splitting of Source Code Entities. In Proceedings of the IEEE Trans. Software
Eng. (TSE). 166â€“181.
[23] Kevin J. Hoffman, Patrick Eugster, and Suresh Jagannathan. 2009. Semantics-
aware Trace Analysis. In Proceedings of the 30th ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI), Dublin, Ireland. 453â€“
464.
[24] Jiyong Jang, Abeer Agrawal, and David Brumley. 2012. ReDeBug: Finding
Unpatched Code Clones in Entire OS Distributions. In Proceedings of the 23rd
IEEE Symposium on Security and Privacy (S&P), San Francisco, CA, USA. 48â€“62.
[25] Zheyue Jiang, Yuan Zhang, Jun Xu, Qi Wen, Zhenghe Wang, Xiaohan Zhang,
Xinyu Xing, Min Yang, and Zhemin Yang. 2020. PDiff: Semantic-based Patch
Presence Testing for Downstream Kernels. In Proceedings of the 27th ACM SIGSAC
Conference on Computer and Communications Security (CCS), Virtual Event, USA.
1149â€“1163.
[26] Toshihiro Kamiya, Shinji Kusumoto, and Katsuro Inoue. 2002. CCFinder: A
Multilinguistic Token-Based Code Clone Detection System for Large Scale Source
Code. In Proceedings of the IEEE Trans. Software Eng. (TSE). 654â€“670.
[27] Ulf KargÃ©n and Nahid Shahmehri. 2017. Towards Robust Instruction-level Trace
Alignment of Binary Code. In Proceedings of the 32nd IEEE/ACM International
Conference on Automated Software Engineering (ASE), Urbana, IL, USA. 342â€“352.
[28] Seulbae Kim, Seunghoon Woo, Heejo Lee, and Hakjoo Oh. 2017. VUDDY: A
Scalable Approach for Vulnerable Code Clone Discovery. In Proceedings of the
38th IEEE Symposium on Security and Privacy (S&P), San Jose, CA, USA. 595â€“614.
[29] Zhen Li, Deqing Zou, Shouhuai Xu, Xinyu Ou, Hai Jin, Sujuan Wang, Zhijun
Deng, and Yuyi Zhong. 2018. VulDeePecker: A Deep Learning-based System for
Vulnerability Detection. In Proceedings of the 25th Annual Network and Distributed
System Security Symposium (NDSS), San Diego, CA, USA,.
[30] Hongliang Liang, Lin Jiang, Lu Ai, and Jinyi Wei. 2020. Sequence Directed Hybrid
Fuzzing. In Proceedings of the 27th IEEE International Conference on Software
Analysis, Evolution and Reengineering (SANER), London, ON, Canada. 127â€“137.
[31] Hongliang Liang, Yini Zhang, Yue Yu, Zhuosi Xie, and Lin Jiang. 2019. Sequence
Coverage Directed Greybox Fuzzing. In Proceedings of the 27th International
Conference on Program Comprehension (ICPC), Montreal, QC, Canada. 249â€“259.
[32] Bingchang Liu, Wei Huo, Chao Zhang, Wenchao Li, Feng Li, Aihua Piao, and Wei
Zou. 2018. ğ›¼diff: Cross-version Binary Code Similarity Detection with DNN. In
Proceedings of the 33rd ACM/IEEE International Conference on Automated Software
Engineering (ASE), Montpellier, France. 667â€“678.
[33] Kangjie Lu and Hong Hu. 2019. Where Does It Go? Refining Indirect-call Targets
with Multi-layer Type Analysis. In Proceedings of the 2019 ACM SIGSAC Conference
on Computer and Communications Security (CCS), London, UK. 1867â€“1881.
[34] Dongliang Mu, Alejandro Cuevas, Limin Yang, Hang Hu, Xinyu Xing, Bing Mao,
and Gang Wang. 2018. Understanding the Reproducibility of Crowd-reported
Security Vulnerabilities. In Proceedings of the 27th USENIX Security Symposium
(USENIX Security), Baltimore, MD, USA. 919â€“936.
[35] Dongliang Mu, Wenbo Guo, Alejandro Cuevas, Yueqi Chen, Jinxuan Gai, Xinyu
Xing, Bing Mao, and Chengyu Song. 2019. RENN: Efficient Reverse Execution
with Neural-network-assisted Alias Analysis. In Proceedings of the 34th IEEE/ACM
International Conference on Automated Software Engineering (ASE), San Diego,
CA, USA. 924â€“935.
[36] Emerson R. Murphy-Hill, Chris Parnin, and Andrew P. Black. 2012. How We
Refactor, and How We Know It. In Proceedings of the IEEE Trans. Software Eng.
(TSE). 5â€“18.
[37] Eugene W. Myers. 1986. An O(ND) Difference Algorithm and its Variations. In
Algorithmica. 251â€“266.
[38] Vijayanand Nagarajan, Rajiv Gupta, Matias Madou, Xiangyu Zhang, and Bjorn
De Sutter. 2007. Matching Control Flow of Program Versions. In Proceedings
of the 23rd IEEE International Conference on Software Maintenance (ICSM), Paris,
France. 84â€“93.
[39] Manh-Dung Nguyen, SÃ©bastien Bardin, Richard Bonichon, Roland Groz, and
Matthieu Lemerre. 2020. Binary-level Directed Fuzzing for Use-After-Free
Vulnerabilities. In Proceedings of the 23rd International Symposium on Research in
Attacks, Intrusions and Defenses (RAID), Virtual Event, USA. 47â€“62.
[40] Sebastian Ã–sterlund, Kaveh Razavi, Herbert Bos, and Giuffrida Cristiano. 2020.
ParmeSan: Sanitizer-guided Greybox Fuzzing. In Proceedings of the 29th USENIX
Security Symposium (USENIX Security), Virtual Event, USA. 2289â€“2306.
[41] Mateusz Pawlik and Nikolaus Augsten. 2016. Tree Edit Distance: Robust and
Memory-efficient. In Proceedings of the Information Systems (Inf. Syst.). 157â€“173.
[42] Jannik Pewny, Behrad Garmany, Robert Gawlik, Christian Rossow, and Thorsten
Holz. 2015. Cross-architecture Bug Search in Binary Executables. In Proceedings
of the 36th IEEE Symposium on Security and Privacy (S&P), San Jose, CA, USA.
709â€“724.
[43] Jannik Pewny, Felix Schuster, Lukas Bernhard, Thorsten Holz, and Christian
Rossow. 2014. Leveraging Semantic Signatures for Bug Search in Binary Programs.
In Proceedings of the 30th Annual Computer Security Applications Conference
(ACSAC), New Orleans, LA, USA. 406â€“415.
[44] John W. Ratcliff and David E. Metzener. 1998. Ratcliff-obershelp Pattern
Recognition. In Dictionary of Algorithms and Data Structures (DADS).
[45] Eric Sven Ristad and Peter N Yianilos. 1998. Learning String-edit Distance. In
Proceedings of the IEEE Trans. Pattern Anal. Mach. Intell. (TPAMI). 522â€“532.
[46] Hitesh Sajnani, Vaibhav Saini, Jeffrey Svajlenko, Chanchal K Roy, and Cristina V
Lopes. 2016.
SourcererCC: Scaling Code Clone Detection to Big-code. In
Proceedings of the 38th International Conference on Software Engineering (ICSE),
Austin, TX, USA. 1157â€“1168.
[47] Pang-Ning Tan et al. 2006. Introduction to Data Mining.
[48] Xin Tan, Yuan Zhang, Chenyuan Mi, Jiajun Cao, Kun Sun, Yifan Lin, and Min
Yang. 2021. Locating the Security Patches for Disclosed OSS Vulnerabilities
with Vulnerability-Commit Correlation Ranking. In Proceedings of the 28th ACM
SIGSAC Conference on Computer and Communications Security (CCS), Virtual
Event, Republic of Korea.
Session 12B: Analyzing Crashes and Incidents CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3313[49] Nikolaos Tsantalis, Matin Mansouri, Laleh Eshkevari, Davood Mazinanian, and
Danny Dig. 2018. Accurate and Efficient Refactoring Detection in Commit History.
In Proceedings of the 40th International Conference on Software Engineering (ICSE),
Gothenburg, Sweden. 483â€“494.
[50] Haijun Wang, Xiaofei Xie, Yi Li, Cheng Wen, Yuekang Li, Yang Liu, Shengchao
Qin, Hongxu Chen, and Yulei Sui. 2020. Typestate-Guided Fuzzer for Discovering
Use-after-Free Vulnerabilities. In Proceedings of the 42nd International Conference
on Software Engineering (ICSE), Seoul, South Korea. 999â€“1010.
[51] Cheng Wen, Haijun Wang, Yuekang Li, Shengchao Qin, Yang Liu, Zhiwu Xu,
Hongxu Chen, Xiaofei Xie, Geguang Pu, and Ting Liu. 2020. MemLock: Memory
Usage Guided Fuzzing. In Proceedings of the 42nd International Conference on
Software Engineering (ICSE), Seoul, South Korea. 765â€“777.
[52] Yang Xiao, Bihuan Chen, Chendong Yu, Zhengzi Xu, Zimu Yuan, Feng Li,
Binghong Liu, Yang Liu, Wei Huo, Wei Zou, and Wenchang Shi. 2020. MVP:
Detecting Vulnerabilities using Patch-enhanced Vulnerability Signatures. In
Proceedings of the 29th USENIX Security Symposium (USENIX Security), Virtual
Event, USA. 1165â€“1182.
[53] Jun Xu, Dongliang Mu, Ping Chen, Xinyu Xing, Pei Wang, and Peng Liu. 2016.
Credal: Towards Locating A Memory Corruption Vulnerability with Your Core
Dump. In Proceedings of the 23rd ACM SIGSAC Conference on Computer and
Communications Security (CCS), Vienna, Austria. 529â€“540.
[54] Jun Xu, Dongliang Mu, Xinyu Xing, Peng Liu, Ping Chen, and Bing Mao. 2017.
Postmortem Program Analysis with Hardware-enhanced Post-crash Artifacts. In
Proceedings of the 26th USENIX Security Symposium (USENIX Security), Vancouver,
BC, Canada. 17â€“32.
[55] Yifei Xu, Zhengzi Xu, Bihuan Chen, Fu Song, Yang Liu, and Ting Liu. 2020. Patch
Based Vulnerability Matching for Binary Programs. In Proceedings of the 29th
ACM SIGSOFT International Symposium on Software Testing and Analysis (ISSTA),
Virtual Event, USA. 376â€“387.
[56] Wei You, Xueqiang Wang, Shiqing Ma, Jianjun Huang, Xiangyu Zhang, XiaoFeng
Wang, and Bin Liang. 2019. ProFuzzer: On-the-fly Input Type Probing for Better
Zero-Day Vulnerability Discovery. In Proceedings of the 40th IEEE Symposium on
Security and Privacy (S&P), San Francisco, CA, USA. 769â€“786.
[57] Hang Zhang and Zhiyun Qian. 2018. Precise and Accurate Patch Presence Test
for Binaries. In Proceedings of the 27th USENIX Security Symposium (USENIX
Security), Baltimore, MD, USA. 887â€“902.
[58] Xiangyu Zhang and Rajiv Gupta. 2005. Matching Execution Histories of Program
Versions. In Proceedings of the 10th European Software Engineering Conference
(ESEC), Lisbon, Portugal. 197â€“206.
[59] Yuan Zhang, Jiarun Dai, Xiaohan Zhang, Sirong Huang, Zhemin Yang, Min Yang,
and Hao Chen. 2018. Detecting Third-party Libraries in Android Applications
with High Precision and Recall. In IEEE 25th International Conference on Software
Analysis, Evolution and Reengineering (SANER), Campobasso, Italy. 141â€“152.
[60] Fei Zuo, Xiaopeng Li, Patrick Young, Lannan Luo, Qiang Zeng, and Zhexin Zhang.
2019. Neural Machine Translation Inspired Binary Code Similarity Comparison
beyond Function Pairs. In Proceedings of the 26th Annual Network and Distributed
System Security Symposium (NDSS), San Diego, CA, USA.
A IMPLEMENTATION DETAILS
Trace Collection. We implement a lightweight trace collector
using an LLVM instrumentation pass. For every function call, we log
the callee function, caller function, and the corresponding callsite.
These logs are used to construct tree-structured execution trace.
We also log the intra-function execution flow by instrumenting
each basic block. Each basic block has a unique intra-function ID.
Code Similarity Calculation. We leverage code features that are
widely used in existing works to calculate similarity scores between
cross-version functions and basic blocks.
For function-level similarity calculation, we first normalize the
source code of a function, and then extract various features from
the function, including its callers, callees and constant values. We
define ğ‘†ğ‘–ğ‘š(ğ‘‹, ğ‘Œ) as the similarity score between function X and
function Y. When performing cross-version function matching, only
those function pairs whose similarity score exceeds a predefined
threshold are considered as matched pairs. As suggested by [46],
this threshold is set to 0.7 in our prototype. Specifically, ğ‘†ğ‘–ğ‘š(ğ‘‹, ğ‘Œ)
is calculated as follows.
ğ‘†ğ‘–ğ‘š(ğ‘‹ , ğ‘Œ) =
ğ‘†ğ‘–ğ‘šğ‘ (ğ‘‹ , ğ‘Œ) + ğ‘†ğ‘–ğ‘š ğ‘— (ğ‘‹ , ğ‘Œ)
2
(2)
ğ‘†ğ‘–ğ‘šğ‘ (ğ‘‹ , ğ‘Œ) = 1 âˆ’ ğ‘’ğ‘‘ğ‘–ğ‘¡_ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘ğ‘›ğ‘ğ‘’(ğ‘‹ , ğ‘Œ)
ğ‘šğ‘ğ‘¥(ğ‘™ğ‘’ğ‘›(ğ‘‹), ğ‘™ğ‘’ğ‘›(ğ‘Œ))
ğ‘†ğ‘–ğ‘šğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘Ÿ (ğ‘‹ , ğ‘Œ) + ğ‘†ğ‘–ğ‘šğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘’ (ğ‘‹ , ğ‘Œ) + ğ‘†ğ‘–ğ‘šğ‘ğ‘œğ‘›ğ‘ ğ‘¡ (ğ‘‹ , ğ‘Œ)
3
ğ‘†ğ‘–ğ‘šğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘Ÿ (ğ‘‹ , ğ‘Œ) = ğ½ ğ‘ğ‘ğ‘ğ‘ğ‘Ÿğ‘‘(ğ¹ğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘Ÿ (ğ‘‹), ğ¹ğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘Ÿ (ğ‘Œ))
ğ‘†ğ‘–ğ‘šğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘’ (ğ‘‹ , ğ‘Œ) = ğ½ ğ‘ğ‘ğ‘ğ‘ğ‘Ÿğ‘‘(ğ¹ğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘’ (ğ‘‹), ğ¹ğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘’ (ğ‘Œ))
ğ‘†ğ‘–ğ‘šğ‘ğ‘œğ‘›ğ‘ ğ‘¡ (ğ‘‹ , ğ‘Œ) = ğ½ ğ‘ğ‘ğ‘ğ‘ğ‘Ÿğ‘‘(ğ¹ğ‘ğ‘œğ‘›ğ‘ ğ‘¡ (ğ‘‹), ğ¹ğ‘ğ‘œğ‘›ğ‘ ğ‘¡ (ğ‘Œ))
(3)
(4)
(5)
(6)
ğ‘†ğ‘–ğ‘š ğ‘— (ğ‘‹ , ğ‘Œ) =
(7)
In the above equations, ğ‘’ğ‘‘ğ‘–ğ‘¡_ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘ğ‘›ğ‘ğ‘’() calculates the edit
distance [45] between the normalized source code of the functions;
ğ‘™ğ‘’ğ‘›() indicates the length of the normalized function code. The
ğ¹ğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘Ÿ (), ğ¹ğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘’() and ğ¹ğ‘ğ‘œğ‘›ğ‘ ğ‘¡ () extract the callers of the function,
the callees of the function, and the constant values used in the
function respectively. ğ½ğ‘ğ‘ğ‘ğ‘ğ‘Ÿğ‘‘() takes two feature sets as input and
returns the Jaccard similarity [47] between them.
For basic-block-level similarity calculation, we consider the
internal features and structural features of a basic block. Given
a pair of basic blocks (ğ‘ğ‘Ÿ , ğ‘ğ‘¡), we use ğ‘†ğ‘–ğ‘šğ‘ to represent their
similarity score on internal features and ğ‘†ğ‘–ğ‘šğ‘  to represent their
similarity score on structural features. To compute ğ‘†ğ‘–ğ‘šğ‘, we collect
all the internal features in the basic block, including the opcodes,
the data, and the called functions, and use Jaccard similarity to
measure how many features are shared between two basic blocks,
i.e., ğ‘†ğ‘–ğ‘šğ‘(ğ‘ğ‘Ÿ , ğ‘ğ‘¡) = ğ½ğ‘ğ‘ğ‘ğ‘ğ‘Ÿğ‘‘(ğ‘ğ‘Ÿ , ğ‘ğ‘¡). To compute ğ‘†ğ‘–ğ‘šğ‘ , we first
collect the predecessor basic blocks of ğ‘ğ‘Ÿ and ğ‘ğ‘¡ as {ğ‘ƒğ‘Ÿ} and {ğ‘ƒğ‘¡}
and their successor basic blocks as {ğ‘„ğ‘Ÿ} and {ğ‘„ğ‘¡}. Then, we define
ğ‘†ğ‘–ğ‘šğ‘  to measure the similarity of their predecessors as well as that
of their successor with the equation below.
ğ‘šğ‘ğ‘¥(ğ‘¥ğ‘Ÿ âˆˆ{ğ‘‹ğ‘Ÿ }
ğ‘¥ğ‘¡ âˆˆ{ğ‘‹ğ‘¡ } ğ‘†ğ‘–ğ‘šğ‘ (ğ‘¥ğ‘Ÿ , ğ‘¥ğ‘¡))
ğ‘†ğ‘–ğ‘šğ‘  ({ğ‘‹ğ‘Ÿ }, {ğ‘‹ğ‘¡ }) =
3
(8)
Finally, we combine the similarity score of the internal features and
the similarity score of the context features to calculate the similarity
score between ğ‘ğ‘Ÿ and ğ‘ğ‘¡.
ğ‘šğ‘–ğ‘›(|{ğ‘‹ğ‘Ÿ }| , |{ğ‘‹ğ‘¡ }|)
ğ‘†ğ‘–ğ‘šğ‘ (ğ‘ğ‘Ÿ , ğ‘ğ‘¡) + ğ‘†ğ‘–ğ‘šğ‘  ({ğ‘ƒğ‘Ÿ }, {ğ‘ƒğ‘¡ }) + ğ‘ ğ‘–ğ‘šğ‘  ({ğ‘„ğ‘Ÿ }, {ğ‘„ğ‘¡ })
ğ‘†ğ‘–ğ‘š(ğ‘ğ‘Ÿ , ğ‘ğ‘¡) =
(9)
By measuring the similarity score, a pair of basic blocks (ğ‘ğ‘Ÿ , ğ‘ğ‘¡)
can be viewed as a candidate pair for alignment only when their
similarity score exceeds a pre-defined threshold. In this work, we
set the threshold to 0.5 which is the same with the threshold in [20].
Taint Tracking. We correlate the input bytes with the critical
variables using variable-level taint tracking. In our implementation,
this component is built on the top of PolyTracker [6]. Since
the official version of PolyTracker provides only a function-to-
input-bytes mapping, we enhance its tainting logic on load and
store instructions to make it support fine-grained variable-to-
input-bytes mapping. Besides, our implementation also optimizes
Polytracker to support some language features that are used
in real-world programs. For example, variable-length argument
is not well-supported in the original version of PolyTracker. This
could result in under-tainted variables at the runtime. To solve