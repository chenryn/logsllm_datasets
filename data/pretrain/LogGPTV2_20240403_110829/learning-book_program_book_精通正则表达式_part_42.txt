（.*？）["]中的（""]，这有点类似前面介绍的开头字符识别优化）。
---
## Page 275
常见优化措施
249
理解本章中的性能测试
本章的大多数性能测试给出的是某种语言的相对结果。例如，第248页我提到一种优
化过结构能比另一种未优化的结构快10%，至少在Sun的Javaregexpackage中是这样。
在.NET中，两者之间的差异是2.5倍，在PCRE中，是150倍。在Perl中，两者是一
样的（也就是，它们的速度是相同的）。
那么，你能够从中推导出不同语言之间的相对速度吗？显然不能。PCRE中150倍的
性能提升意味着优化执行的效果特别好，相对其他语言，或者意味着未优化的版本速
度很慢。在大部分中，我几乎没有提到语言之间的计时问题，因为它们是语言开发人
员争论的话题。
不过还是有一点值得一看，就是JaVa的10%和PCRE的150倍背后的细节。看起来PCRE
中未优化的（？：.)*的速度是Java的1/11，不过优化的.*1要快13倍。Java和Ruby
的优化版本速度相同，但是Ruby的未优化版本比Java的要慢40%。Ruby的未优化版
本只比Python的未优化版本慢10%.但是Python的优化版本比Ruby的优化版本快20
倍。
所有这些都比Perl的要慢。Perl的优化和未优化版本都比Python最快的版本快10%。
请注意，每种语言都有自己的强项，这些数字只是针对某个具体的测试情况而言的。
“过度”回溯检测
第226页的“实测”揭示的问题是，（.+）*之类的量词结合结构，能够制造指数级的回溯。
避免这种情况的简单办法就是限定回溯的次数，在“超限”时停止匹配。在某些实际情况
中这非常有用，但是它也为正则表达式能够应用的文本人为设置了限制。
例如，如果上限是10000次回溯，.*？就不能匹配长于10000的字符，因为每个匹配的字
符都对应一次回溯。这种情况并不罕见，尤其在处理Web页时更是如此，所以这种限制非
常精糕。
---
## Page 276
250
第6章：打造高效正则表达式
出于不同的原因，某些实现方式限制了回溯堆栈的大小（也就是同时能够保存的状态的上
限）。例如，Python的上限是10000。就像回溯上限一样，这也会限制正则表达式所能处理
的文本的长度。
因为存在这个问题，本书中的某些性能测试构建起来非常困难。为了获得最准确的结果，
性能测试中计时部分应该尽可能多地完成正则表达式的匹配，所以我创建了极长的字符事，
比较例如""（.*）"，（.）*"，""（.）*？"和""（{^"}）*？"的执行时间。为了保证结果有意义，
我必须限制字符串的长度，以避免回溯计数或者堆栈大小的限制。你可以在239页看到这
个例子。
避免指数级（也就是超线性super-linear）匹配
避免无休止的指数级匹配的更好办法是，在匹配尝试进人超线性状态时进行检测。这样就
能做些额外的工作，来记录每个量词对应的子表达式尝试匹配的位置，绕过重复尝试。
实际上，超线性匹配发生时是很容易检测出来的。单个量词“选代”（循环）的次数不应该
比目标字符串的字符数量更多。否则肯定发生了指数级匹配。如果根据这个线索发现匹配
已经无法终止，检测和消除余的匹配是更复杂的问题，但是因为多选分支匹配次数太多，
这么做或许值得。
检测超线性匹配井迅速报告匹配失败的副作用（sideeffect）之一就是，真正缺乏效率的正
则表达式并不会体现出效率的低下。即使使用这种优化，避免了指数级匹配，所花的时间
也远远高于真正需要的时间，但是不会慢到很容易被用户发现（不像是等到太阳落山一样
漫长，而可能是多消耗1/100s，对我们来说这很快，但对计算机来说很漫长）。
当然，总的来看可能还是利大于弊。许多人不关心正则表达式的效率一一它们对正则表达
式怀着一种恐惧心理，只希望能完成任务，而不关心如何完成。（你可能没见过这种情况，
但是我希望这本书能够加强你的信心，就像标题说的那样，精通正则表达式）。
使用占有优先量词削减状态
由正常量词约束的对象匹配之后，会保留若干“在此处不进行匹配”的状态（量词每一轮
选代创建一个状态）。占有优先量词（142）则不会保留这些状态。具体做法有两种，一
---
## Page 277
常见优化措施
251
种是在量词全部尝试完成之后抛弃所有备用状态，效率更高的办法是每一轮选代时抛弃上
一轮的备用状态（匹配时总需要保存-个状态，这样在量词无法继续匹配的时候引擎还能
继续运转）。
在选代中即时抛弃状态的做法效率更高，因为所占的内存更少。应用.*会在匹配每个字
符时创造一个状态，如果字符串很长，会占用大量的内存。
自动“占有优先转换”
在第4章中（171），我们用^\w+：来匹配‘Subject’。\w+匹配到字符串末尾时，
最后的留号无法匹配，所以回溯机制会强迫W+逐个交还字符，在每个位置对：进
行徒劳的尝试。在这个例子中，如果使用固化分组（?>\W+）：或者占有优先量词
^\W++：1，能够避免无谓的劳动。
聪明的实现方式应该能自动做到这一点。编译正则表达式时，引擎会检查量词之后的
元素能匹配的字符是否与量词作用元素匹配的字符重叠，如果不重叠，量词就应该自
动转变为占有优先的形式。
就我所知，目前还没有系统采用这种优化，在这里列出来，是鼓励开发人员考虑这个
问题，因为我坚信它能带来实质性的收益。
量词等价转换
有人习惯用d\d\d\d，也有人则习惯使用量词d（4)。两者的效率有差别吗？对NFA来
说，答案几乎是肯定的，但工具不同，结果也不同。如果对量词做了优化，则d（4）会更
快一些，除非未使用量词的正则表达式能够进行更多的优化。听起来有点迷惑？但事实确
实如此。
我的测试结果表明，Perl、Python、PHP/PCRE和.NET中，\d（4)大概要快20%。但是，如
果使用Ruby和Sun的Javaregexpackage，\d\d\d\d;则要快上好几倍。所以，看起来量词
在某些工具中要更好一些，在另一些工具中则要差一些。不过，情况远非如此简单。
比较“====)和"=（4)。这个例子与上面的截然不同，因为此时重复的是确定的文字字符，而
直接使用===引擎更容易将其识别为一个文字字符串。如果是，支持的高效的开头字符/
---
## Page 278
252
第6章：打造高效正则表达式
字符组/子串识别优化（247）就可以派上用场。对Python和Sun的Javaregexpackage来
说，情况正是如此，====比‘={4）快上100倍。
Perl、Ruby和.NET的优化手段更高级，它们不会区分====i和'=（4），结果，两者是-一样
快的（而且都比"\d\a\d\d和"\d(4)的例子快成百上千倍)。
需求识别
另一种简单的优化措施是，引擎会预先取消它认为对匹配结果没有价值的（例如，在不必
捕获文本的地方使用了捕获型括号）工作。识别能力在很大程度上依赖于编程语言，不过
这种优化实现起来也可以很容易，如果在匹配时能够指定某些选项，就能禁止某些代价高
昂的特性。
Tcl就能够进行这种优化。除非用户明确要求，否则它的捕获型括号并不会真正捕获文本。
而.NET的正则表达式提供了一个选项，容许程序员指定捕获型括号是否需要捕获。
提高表达式速度的诀窍
Techniquesfor Faster Expressions
之前的数页介绍了我见过的传统型NFA引擎使用的各种优化。没有任何程序同时其备所有
这些优化，而且无论你爱用的程序目前支持哪些，情况也会随时间而改变。但是，理解可
能进行的各种优化，我们就能写出效率更高的表达式。如果你还理解传统型NFA的工作原
理，把这些知识结合起来，就可以从三方面获益：
·编写适于优化的正则表达式编写适应已知（或者未来会支持的）优化措施的表达式。
举例来说，xx*比x+能适用的优化措施更多，例如检查目标字符串中必须出现的字
符（245），或者开头字符识别（247）。
·模拟优化有时候我们知道所用的程序没有特殊的优化措施，但是通过手工模拟，我们
还是能节省大量的时间。比如在'thisIthati之前添加（?=t），这样即使系统无法预
知任何匹配结果必须以‘t’开头，我们还是能模拟开头字符识别（247），下文还会
深人讨论这个例子。
---
## Page 279
提高表达式速度的诀窍
253
主导引擎的匹配使用关于传统型NFA引擎工作原理的知识，能够主导引擎更快地匹
配。拿this|that来说。每个多选分支都以'th开头，如果第一个多选分支不能匹配
th，第二个显然也不行，所以不必白费工夫。因此，我们可以使用th（？：islat）l。
这样，th就只要检查一遍，只由在确实需要的时候才会用到代价相对高昂的多选结构
功能。而且，th（？：islat）：开头的纯文字字符就是th，所以存在进行其他优化的可
能。
重要的是认识到，效率和优化有时候处理起来比较麻烦。在阅读本节其他内容的时候，请
不要忘记下面几点：
·
进行看来确实有帮助的改动，有时反而事与愿违，因为这样可能禁止了你所不知道的，
已经生效的其他优化。
添加一些内容模拟你知道的不存在的优化措施，可能出现的情况是，处理那些添加内
容的时间多于节省下来的时间。
添加一些内容模拟一个目前未提供的优化，如果将来升级以后的软件支持此优化，反
而会影响或者重复真正的优化。
同样，控制表达式尝试触发某种当前可用的优化，将来某些软件升级之后可能无法进
行某些更高级的优化。
为提高效率修改表达式，可能导致表达式难以理解和维护。
具体的修改带来的好处（或是坏处）的程度，基本上取决于表达式应用的数据。对某
类数据来说有益的修改，可能对另一类数据来说是有害的。
我来举个极端点的例子：你在Perl脚本中找到（0001999）$，并决定把这些捕获型括号替
换为非捕获型括号。你觉得这样速度更快，因为不再需要捕获文本的开销。但是奇怪的是，
这个微小而且看起来有益的改动反而会把表达式的速度降低许多个数量级（比之前慢几千
倍)。怎么会这样呢？原来在这里有若干因素共同作用，使用非捕获型括号时，字符串结束
/行锚点优化（246）会被关闭。我不希望劝阻读者在Perl中使用捕获型括号--绝大多数
情况下，使用他们都是有益的，但是在某些情况下，会带来灾难性的后果。
制
---
## Page 280
254
第6章：打造高效正则表达式
所以，检测并性能测试你期望实际应用的同类型的数据，有助于判断改动是否值得，但是，
你仍然必须自己权衡众多因素。就说这么多，下面我开始讲解一些技巧，你能够用它们来
挖掘引擎效率的最后一点潜能。
常识性优化
Common Sense Techniques
只需要依靠常识，就能进行一些极有成效的优化。
避免重新编译
编译和定义正则表达式的次数应该尽可能的少。在面向对象式处理中（95），用户能够精
确控制这一点。举例来说，如果你希望在循环中应用正则表达式，就应该在循环外创建这
个正则表达式对象，在循环中重复使用。
在函数式处理-一例如GNUEmacs和Tcl——的情况下，应尽量保证循环中使用的正则表
达式的数目少于工具所能缓存的上限（244）。
如果使用的是集成式处理，例如Perl，应尽量避免在循环内的正则表达式中使用变量插值，
因为这样每次循环都需要重新生成正则表达式，即使值没有变化（不过，Perl提供了高效的
办法来避免这个问题348）。
使用非捕获型括号
如果不需要引用括号内的文本，请使用非捕获型括号（？：）（45）。这样不但能够节省
捕获的时间，而且会减少回溯使用的状态的数量，从两方面提高速度。而且能够进行进一
步的优化，例如消除无必要括号（248）。
不要滥用括号
在需要的时候使用括号，在其他时候使用括号会阻正某些优化措施。除非你需要知道.*
匹配的最后一个字符，否则请不要使用（.）*。这似乎很显而易见，但是别忘了，本节的标
题是“常识性优化”。
不要滥用字符组
这一点看起来也很显而易见，但是我经常在缺乏经验的程序员的表达式中看到.*（：。我
---
## Page 281
提高表达式速度的诀窍
255
但并不需要用到字符组提供的多字符匹配功能。我认为，当-个字符是元字符时-例如
“.]或者[*]，可能作者不知道通过转义把它们转换为.和*。我经常在宽松排列模
式（111）下见到它们与空白字符一起出现。
同样，读过本书第-版的Peri用户可能有时候写出[Ff][Rr][Oo][Mm]：，而不是用不区
分大小写的from：。老版本的Perl在进行不区分大小写的匹配时效率很低，所以我推荐
使用字符组。但现在这种做法已不再适用，因为不区分大小写匹配效率低下的问题在好几
年前就修正了。
使用起始锚点
支
（129）。如果这个正则表达式在某个字符串的开头不能匹配，那么显然在其他位置它也
不能匹配。添加锚点（无论是手工添加，还是通过优化自动添加246）都能够配合开头字
符/字符事/字串识别优化，节省大量不必要的工作。
将文字文本独立出来
Expose Literal Texf
我们在本章见过的许多局部优化，主要是依靠正则引擎的能力来识别出匹配成功必须的一
些文字文本。某些引擎在这一点上做得比其他引擎要好，所以这里提供了一些手动优化措
施，有助于“暴露”文字文本，提高引擎识别的可能性，配合与文字文本有关的优化措施。
从量词中“提取”必须的元素
用xx*替代x+i能够暴露匹配必须的‘x'。同样的道理，-（5，7）；可以写作------（0，2）]。
“提取”多选结构开头的必须元素
用'th（?：is|at）替代'（?：this|that），就能暴露出必须的'th。如果不同多选分支的结
尾部分相同，我们也可以从右面“提取”，例如（?：optimlstandard）ization。我们会在
下一节中看到，如果提取出来的部分包括锚点，这么做就非常有价值。
---
## Page 282
256
第6章：打造高效正则表达式
将锚点独立出来
Fxpose Anchors
某些效果明显的内部优化措施是利用锚点（例如、S和Gi)，把表达式“绑定”在目标
字符串的某一端。使用这些优化时，某些引擎的效果不如其他引擎，但是有一些技巧能够
提供帮助。
在表达式前面独立出^和\G
（？：abc123）和~abc|^123在逻辑上是等价的，但是许多正则引擎只会对第·个表达
式使用开头字符/字符串/字串识别优化（246)。所以，第一种办法的效率要高得多。PCRE
（还包括使用它的工具）中两者的效率是一样的，但是大多数其他NFA工具中第一个表达
式的效率更高。
比较（~abc）和（abc）我们能发现另一个区别。前者的设置并不很合适，锚点“藏”在
捕获型括号内，在检测锚点之前，必须首先进人括号，在许多系统上，这样做的效率很低。
某些系统（PCRE、Perl、.NET）中两者的效率相当，但是在其他系统中（Ruby和Sun的
Javaregexpackage）只会对后者进行优化。
Python似乎不会进行锚点优化，所以这些技巧目前不适用于Python。当然，本章介绍的大
多数优化都不适用于Tc1（243）。
在表达式末尾独立出$
此措施与上一节的优化思想非常类似，虽然abc$I123$和（?：abc|123）$在逻辑上是等
价的，但优化的表现可能不同。目前，这种优化还只适用于Perl，因为现在只有Perl提供
了“字符串结束/行锚点优化”（246)。优化只对（…….)S起作用，对（·$|…S）：不起作
用。
忽略优先还是匹配优先？具体情况具体分析
Lay Versus Greedy: Be Specific
通常，使用忽略优先量词还是匹配优先量词取决于正则表达式的具体需求。举例来说，.*：
完全不同于.*？：，因为前者匹配到最后的冒号，而后者匹配到第一个冒号。但是，如果