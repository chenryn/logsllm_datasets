以上输出显示，该文件是为ARM架构的ELF二进制版本。这证实了assetss文件夹内的文件可能是专为Android设备的可执行文件。
现在，让我们切换回JD-GUI，看看下一个方法changefilepermissions()。下面这段代码显示了该方法的定义。
以上方法似乎正在改变被复制到netcat的二进制文件权限“app_files”文件夹前面。“chmod 755 ”命令赋予可执行权限到指定文件。
如果该文件的权限已被更改，我们可以验证。启动我们前面创建的仿真器，安装应用程序并启动它。要安装应用程序，切换到你的终端，并确保你在里面分析，其中目标apk文件所在的文件夹。
然后运行以下命令。
    “adb install bake_the_cake.apk”
一旦安装后，请确保您启动的应用程序使我们看到代码会被执行。
现在，
    $adb shell
切换到使用目标包“CD /data/data/com.infosecinstitute.analyze_me/”并运行“LS”的命令，如下面的图。
正如我们在上面的图中看到，在app_files目录中创建。现在，让我们浏览到该目录，并检查使用的netcat的文件权限“的ls -l”命令，如图下图。
正如你在上图中看到，NC程序得到了可执行的权限。
一旦完成，按Ctrl + C，退出adbshell
最后，还有一个需要研究探索的方法。让我们切换回JD-GUI和检查getReverseShell（）方法，看看它在做什么。
以下是代码片段。
上面的代码片段显示，该应用程序使用调用Runtime.getRuntime().EXEC()，通过端口5555的IP地址10.0.2.2连接，提供一个reverse
shell给攻击者。此连接正在使用的是捆绑在一起的netcat二进制的apk文件的。
给定样品的这种静态分析的结论如下。
该应用程序是恶意的
它配备了APK文件中捆绑的netcat的二进制文件。
当用户打开应用程序，它提供了反向的外壳给攻击者（10.0.2.2）
**动态分析**
当我们试图执行静态分析,可能代码混淆让开发人员很头疼。在这样的情况下，依靠静态分析可能是麻烦的。所以说要用到动态分析。动态分析包括：：分析运行的应用程序的步骤。通常,这个过程检查API调用,网络电话等本节将展示如何使用tcpdump对Android设备进行网络流量分析。
让我们先来安装和启动模拟器上的应用程序。这个应用程序看起来应该如下面：
应用程序运行正常。我们可以把 tcpdump加载程序这可以使用来完成ADB推命令，如下面的图。
上面的命令/data/local/tmp目录是可写在Android设备上的目录的，
现在我们在模拟器上，并检查文件/data/local/tmp
如果您发现上面的输出，tcpdump目前没有可执行的权限。
所以，让我们给tcpdump的可执行权限，如下面的图。
    #chmod 755 tcpdump
现在，tcpdump的二进制文件是可执行的。让我们开始它并使用以下命令捕获的数据包。
    ./tcpdump -v -s 0 -w packets.pcap
正如我们在上面的图中看到，我们捕获的数据包并将其保存到一个文件名为packets.pcap。
现在，通过点击模拟器上的后退按钮关闭该应用程序一次，并启动了回去。这仅仅是保证了应用程序的第一个屏幕运行和tcpdump的通信权。应用程序只有一个页面,所以在我们的案例中是关闭和重新启动就够了一旦这样做，我们可以停止按捕获的数据包CTRL
+ C，如下面的图中的终端。
现在，我们可以在本地计算机，拉这些数据包进行进一步分析。按Ctrl + C，然后用拉他们从adb shell首先退出“adb”命令，如图下图。
    #adb pull /data/local/tmp/packets.pcap
我们拉到捕获的数据包。现在，我们需要分析它。我们将使用Wireshark的分析这些数据包。
在Santoku -> Wireless Analyzers -> Wireshark：
启动Wireshark的，然后进入“File->Open” to open the packets.pcap file。如下图：
你应该看到Wireshark的数据包，如下图所示：
嗯，有分析很多的包，我们需要通过过滤我们不必要的数据包。可以应用以下过滤器除去那些有“PSH ACK”标志的数据包。
因为现在在找一个握手包
在wireshark里面中向下滚动呈现以下两个包
正如你在上图中看到，有一个SYN报文从10.0.2.15（模拟器）到10.0.2.2（(Santoku）。
注：模拟器需要10.0.2.2作为该模拟器运行时主机的地址。恶意软件已与该地址没有互联网，地址是模拟攻击者的IP地址创建。
点击上述分组还示出了端口监听攻击者的机器上是5555这是恶意软件试图连接到该端口。
这给了我们一个思路，应用程序正试图使从IP 10.0.2.2通过TCP端口5555进行远程连接
但是，下一个分组表示连接已被复位（我们得到了RST）。
让我们再次尝试相同的模拟攻击者的服务器使用netcat
如下：
正如我们在上面的图中看到，我们正在监听端口5555。
现在，启动tcpdump在虚拟器上，包保存到一个文件名为packets2.pcap。然后，启动目标应用程序产生的流量。当你这样做，你将收到一份关于netcat的监听器
reverse shell
。
停止捕获，如下：
导出数据试用ADB：
再次，Wireshark中打开PCAP文件，并查找在捕获的数据包的三次握手。下图显示了三次握手。
正如我们在上面的图中看到，10.0.2.15已经开始与一个SYN报文的三次握手。下图显示了该应用程序正在试图建立在端口5555到攻击者的服务器的连接。
点击第二个数据包，你应该看到从Santoku（10.0.2.2）来响应。你要注意到源端口5555。
最后，点击3号包看到注定了Santoku计算机上的端口5555的源发送的ACK包。
这证实了建立了连接攻击者的服务器。
由于我们使用的两面的netcat，它采用明文传输的，我们甚至可以看到通信。
要检查这一点，让我们再一次重复上述过程。
开始santoku netcat的监听器
运行tcpdump和包保存到一个文件名为packets3.pcap
启动和运行产生的流量应用。
下图显示的tcpdump捕获的数据包，并将其写入packets3.pcap。
当在santoku shell 上，通过输入cat /proc/cpuinfo ，如下面的图命令：
停止捕获并导出显示在下面的图中的报文：
    $adb pull /data/local/tmp/packets.pcap
现在，打开在Wireshark的数据包，并寻找我们输入的字符串。这可以如下面的图来完成。Edit -> Find Packet。
现在选择字符串，然后输入“cpuinfo”到文本字段。请确保你选择““packet bytes”中搜索，最后单击“查找”。
现在，我们应该看到了我们正在寻找的内容包。 选择数据包右键单击：
以下选项应显示。点击“Follow TCP Stream”
这会打开下面的窗口在这里将能够看到的恶意软件和攻击者的服务器之间发送的消息。
**结论**
实验基本覆盖了Android的安全分析了恶意软件使用静态和动态分析技术的基本概念。虽然自定义恶意软件的应用已经显示出一个Android恶意软件（reverse
shell）的一个特点，你会发现更多的恶意功能，如窃取数据并将其发送给攻击者的服务器。