### 5.2.1 Dependencies Among Variable Types

Dependencies exist among almost all variable types, including primitive types and strings. Additionally, structure-like and binder-type variables can be generated based on these dependencies, which helps in generating more semantically rich and well-structured inputs. This, in turn, enables deeper fuzzing into Android native system services.

### 5.2.2 Completeness and Precision of the Extracted Interface Model

Since there is no ground truth for the interface model, we randomly selected ten interfaces and manually checked the completeness and precision of the extracted model according to the principles outlined in Section 3.4.1. Our findings indicate that all transaction codes were successfully recovered, ensuring completeness. Most variable patterns, names, and types were also accurately recovered. While the model is not entirely precise, it is sufficiently accurate for our purposes. Furthermore, inter-transaction variable dependencies were calculated using Algorithm 1 from Section 3.5.2.

To our knowledge, no previous work has focused on Android native system services, making direct comparisons challenging. However, we argue that most existing research cannot effectively handle Android native system services. For instance, Chizpurfle [10] focuses on vendor-implemented Java services and does not address native system services. BinderCracker [6], while testing all services in Android, fails to infer a more complete and precise model than FANS when applied to native system services. This is because BinderCracker relies on app traffic, which may miss rarely used RPCs and lose various variable semantics such as names and types.

### 5.3 Vulnerability Discovery

To evaluate the effectiveness of FANS, we ran it intermittently on six smartphones over approximately 30 days. However, obtaining the exact runtime during this period was difficult due to several factors: (1) The fuzzer might crash every few minutes, (2) running the experiment on real devices meant that if the Android system crashed, we had to manually re-flash the devices, and (3) the device could enter recovery mode even if the fuzzer had been running for less than ten minutes. These issues reduced fuzzing efficiency and hindered the collection of runtime statistics. Despite these challenges, we discovered 30 unique bugs from thousands of crashes reported by FANS.

All 30 vulnerabilities are listed in Table 2. Of these, 22 were found in Android native system services, five in the libraries libcutils.so, libutils.so, and libgui.so (which are used in Android native system services), and three in Linux system components. For example, we discovered a stack overflow in iptables-restore, a user-space program for firewall configuration provided by the Linux kernel. These vulnerabilities demonstrate that inputs generated by FANS can drive the control flow into deep paths under complex constraints.

| Component | Vulnerability File (binary or .so) | Android ID | Vulnerability Type | Status |
|-----------|----------------------------------|------------|--------------------|--------|
| Android Native System Service | libaudiopolicymanagerdefault.so | 128919198 | Heap use after free | Reported |
| ... | ... | ... | ... | ... |
| Linux Component | iptables-restore | 143894992 | Stack buffer overflow | Reported |

Moreover, although our primary goal was to discover vulnerabilities in C++-implemented Android native system services, we also encountered Java exceptions such as FileNotFoundException, DateTimeException, NoSuchElementException, and NullPointerException. This is because Java applications sometimes depend on native system services, and some native services invoke Java methods. Since robustness and stability are crucial for Android native system services, these Java exceptions should not occur. Stricter checks need to be enforced to address this issue.

We have reported all native vulnerabilities to Google, with 20 confirmed and 18 Android IDs assigned, three of which are duplicates. Google has assigned moderate severity to Android IDs 143895055 and 143899228, and CVE-2019-2088 to Android ID 143895055. Submission of Java exceptions is ongoing.

### Comparison with Existing Research

Comparing our solution with related work is not straightforward. To our knowledge, BinderCracker [6] is the most relevant. BinderCracker works on Android system services before Android 6.0, including both Java and native system services. However, Android began supporting clang only after Android 7.0, and since we use an LLVM plugin to extract the interface model, porting our approach to lower Android versions is challenging. Additionally, BinderCracker is closed-source, preventing us from testing it on modern Android versions like android-9.0.0_r46. BinderCracker did not provide detailed vulnerability types, so we can only compare the number of vulnerabilities. BinderCracker found 89 vulnerabilities on Android 5.1 and 6.0, including both native and Java exceptions. In contrast, FANS discovered 30 native vulnerabilities and 138 Java exceptions, significantly more than 89. This comparison suggests that FANS outperforms BinderCracker, especially considering the improvements in Android security over the years.

### 5.4 Case Studies

#### 5.4.1 Case Study I: new_capacity Overflow in readVector of IDrm

**Attack:**
There are multiple new_capacity overflow vulnerabilities in IDrm, a second-level interface obtained via IMediaDrmService. These bugs are triggered by the BnDrm::readVector function, which invokes insertAt to allocate a buffer whose size is determined by the variable `size` in the data. While insertAt includes a sanity check on the insertion index, no check is performed on the `size` argument. Using the interface dependency graph, FANS can automatically generate the IDrm interface. When generating the `size` variable, FANS produces dangerous values, such as -1, which can easily trigger the vulnerability. This can lead to a DoS attack, preventing other apps from using necessary services.

**Insight:**
Buffer allocation is a critical and vulnerable step in IPC. If the server trusts the client and skips necessary sanity checks, vulnerabilities can easily arise. This problem is common in Android native system services and is persistent. In BnDrm, the problematic `readVector` function is called over 30 times, making it an easy target for attackers. Proper sanity checks would mitigate this issue, but it is a daunting task given the extensive Android source code. Fortunately, Parcel provides safely implemented deserialization functions that perform input validations. Replacing `readVector` with `Parcel::readByteVector` would neatly fix the vulnerability.

#### 5.4.2 Case Study II: Out-of-bound Access in informAllUidData of statsd

**Attack:**
The native system service `statsd` is a daemon in Android 9. In the transaction `Call::INFORMALLUIDDATA`, `statsd` deserializes items and vectors of `int32_t`, `int64_t`, and `::android::String16` from the parcel. These vectors are passed to the `informAllUidData` method and then forwarded to the `updateMap` method of `UidMap`. The `updateMap` function iterates over the three vectors using the size of the `uid` vector as the loop count. Since items in any one vector should correspond one-to-one with those in the other two vectors, they are expected to have the same length. However, this requirement is left unchecked, allowing out-of-bound access by passing a longer `uid` vector. FANS identifies the variable types from the AST and generates the vectors, but existing tools like BinderCracker [6] might not generate such effective inputs due to their lack of semantic understanding.

**Insight:**
In this case, the same index is used for different vectors, leading to an OOB vulnerability. This bug, like the previous one, arises from a failure in input validation. It is a more interesting bug and, if exploited appropriately, could lead to more than just a DoS attack.