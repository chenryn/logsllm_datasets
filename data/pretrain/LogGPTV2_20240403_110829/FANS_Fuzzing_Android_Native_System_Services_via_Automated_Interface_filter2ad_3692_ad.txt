are dependencies among almost all variable types, in
particular primitive types and the string type. Besides,
structure-like and binder-type variables can also be
generated based on dependency, which helps generate
more semantic and well-structured inputs, resulting in
deep fuzzing into Android native system services.
5.2.2 Completeness and Precision of Extracted Inter-
face Model
As there is no ground truth about the interface model, we ran-
domly select ten interfaces and manually check whether the
extracted model is complete and precise according to the prin-
ciple mentioned in Section 3.4.1. We ﬁnd that we successfully
recover all the transaction codes, fulﬁlling completeness. Al-
most all variable patterns, variable names and variable types
are recovered as well. In conclusion, the model is not entirely
precise but good enough. What’s more, inter-transaction vari-
able dependencies are calculated with Algorithm 1 in Section
3.5.2.
As far as we know, no previous work focuses on Android
native system services, precluding any comparison. However,
we argue that most existing researches cannot handle Android
native system services effectively. Chizpurﬂe [10] focuses
on vendor-implemented Java services and cannot deal with
Android native system services. BinderCracker [6] tests all
services in Android but is unable to infer a more complete
and precise model than FANS when applied to Android native
system services. This is due to the fact that BinderCracker is
based on app trafﬁc, which might miss rarely used RPCs and
lose various variable semantics like variable names and types.
5.3 Vulnerability Discovery
To evaluate how effective FANS is, we intermittently ran
FANS on our six smartphones for around 30 days. However,
we were not able to get the precise run-time of FANS during
the 30 days’ experiment due to the following reasons: (1) The
fuzzer might crash every several minutes. (2) As we ran the ex-
periment on real machines, once the Android system crashed,
we had no choice but to re-ﬂash them manually. Moreover, the
device could enter recovery mode even when the fuzzer had
started less than ten minutes ago. These situations decreased
the fuzzing efﬁciency and also prevented collecting statistics
about run-time. Despite this, we have discovered 30 unique
bugs from thousands of crashes reported by FANS.
All of the 30 vulnerabilities are listed in Table 2. Apart
from the 22 vulnerabilities found in Android native sys-
tem services, there are ﬁve vulnerabilities in the libraries
libcutils.so, libutils.so and libgui.so, which are
used as public libraries in Android native system services.
Furthermore, we found three vulnerabilities in Linux system
components. For instance, we discovered a stack overﬂow in
iptables-restore. This program is a user-space program
for ﬁrewall conﬁguration provided by Linux kernel. These vul-
nerabilities prove that inputs generated by FANS can drive the
control ﬂow into deep paths under complicated constraints.
Primitive TypeEnumerationStringFileDescriptorStructure-LikeBinderArray or VectorFunction100101102103Sequential PatternConditional PatternLoop PatternPrimitive TypeEnumerationStringFileDescriptorStructure-LikeBinderArray or VectorFunction101102103Raw TypeAlias TypePrimitive TypeEnumerationStringFileDescriptorStructure-LikeBinderArray or VectorFunction101102103None DependencyExist DependencyComponent
Vulnerability File (binary or so)
AndroidID
Vulnerability Type
Status
Table 2: Vulnerabilities found by FANS
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
Android Native
System Service
Basic Library
Linux Component
libaudiopolicymanagerdefault.so
libmediaplayerservice.so
libsensor.so
libsensor.so
libsensor.so
libsensor.so
libsensorservice.so
libmediadrm.so
libmediadrm.so
libmediadrm.so
libmediametrics.so
libsurfaceﬂinger.so
libsurfaceﬂinger.so
libaaudioservice.so
installd
installd
installd
installd
statsd
statsd
incidentd
gatekeeperd
libcutils.so
libcutils.so
libutils.so
libgui.so
libgui.so
128919198
128919198
143896234
143897317
143895981
143896237
143896917
143899028
143897162
143895840
143899228
143898908
143897309
143895055
143897849
143894186
143898908
143898343
-
-
-
-
-
-
-
-
-
Heap user after free
Out of Memory
Out of Memory
Assertion failure
Illegal fd
new_capacity overﬂow
new_capacity overﬂow
Null pointer dereference
Null pointer dereference
invalid memory access
invalid memory access
Null pointer dereference
key not found
CHECK failure
Stack buffer overﬂow
incomplete check
CHECK failure
CHECK failure
Null pointer dereference
Out-of-bound access
Null pointer dereference
Null pointer dereference
integer overﬂow
Null pointer dereference
integer overﬂow
mul-overﬂow
Null pointer dereference
Stack buffer overﬂow
Stack buffer overﬂow
heap-buffer-overﬂow
Reported
Conﬁrmed
Conﬁrmed
Reported
Conﬁrmed
Conﬁrmed
Conﬁrmed
Conﬁrmed
Conﬁrmed
Conﬁrmed
Conﬁrmed
Conﬁrmed
Reported
Reported
Conﬁrmed
Conﬁrmed
Reported
Reported
Conﬁrmed
Conﬁrmed
Conﬁrmed
Duplicated
Conﬁrmed
Conﬁrmed
Reported
Reported
Reported
Duplicated
Duplicated
Reported
iptables-restore
ip6tables-restore
fsck.f2fs
143894992
143895407
-
Java
triggered 138
FileNotFoundException,
Moreover, although we aim to discover vulnerabil-
ities in Android native system services implemented
exceptions, such
in C++, we
as
DateTimeException,
NoSuchElementException, and NullPointerException.
This can be attributed to the fact that Java applications
sometimes depend on Android native system services. Some
native services also invoke Java methods. Since robustness
and stability are important for Android native system services,
these Java exceptions should not have occurred. Stricter
checks should be enforced to solve this problem.
We have reported all native vulnerabilities to Google. 20 of
them were conﬁrmed and 18 Android IDs were given, three
of which are duplicate with undisclosed vulnerability report.
Up to now, Google has assigned moderate severity to Android
ID 143895055 and 143899228. Google has also assigned
CVE-2019-2088 to Android ID 143895055 and will put us in
their acknowledgment page in the future. Submission of Java
exceptions is in progress.
Comparison with Existing Research It is not trivial work
to compare our solution with related work. To the best of
our knowledge, BinderCracker [6] is the most relevant one.
BinderCracker works on Android system services before An-
droid 6.0, including Java system services and native system
services. However, Android began to support clang only after
Android 7.0. As we utilize an LLVM plugin to extract the
interface model, it is not easy to port our approach to lower
Android versions. Besides, BinderCracker is closed-source, so
we cannot test it on modern Android, e.g., android-9.0.0_r46.
Moreover, BinderCracker did not show detailed vulnerabil-
ity types. We are thus forced to a simple comparison of the
number of vulnerabilities discovered by the two tools. Binder-
Cracker found 89 vulnerabilities on Android 5.1 and Android
6.0, both native vulnerabilities and java exceptions included.
Although we only focus on Android native system services,
we found 30 native vulnerabilities and 138 Java exceptions,
way more than 89. We believe this comparison is convincing
that FANS is superior over BinderCracker as Android security
has been improving over the years.
5.4 Case Studies
We present three vulnerabilities discovered by FANS. Firstly,
we look into the root causes of these vulnerabilities and
demonstrate how to trigger vulnerabilities. Also, we explain
how design choices (e.g., categorizing variables as sequential,
conditional, and loop ones) help generate inputs that trigger
vulnerabilities. Secondly, we show our insights into these
vulnerabilities and devise mitigation for them.
5.4.1 Case Study I: new_capacity overﬂow Inside read-
Vector of IDrm
Attack There are multiple new_capacity overﬂow vul-
nerabilities in IDrm, a second-level interface obtained via
IMediaDrmService. The bugs are all triggered by the
same function, BnDrm::readVector. The function invokes
insertAt to allocate a buffer whose size is decided by the
variable size in data. Inside insertAt, there is a sanity
check on the insertion index, which will return BAD_INDEX
in case of a lousy index. However, no check is made on the
size argument. According to the interface dependency graph,
FANS could generate IDrm interface automatically. When
it comes to the variable name size, FANS generates some
dangerous values, e.g., -1, which can easily trigger the vulner-
ability. We could further achieve DoS attack through this kind
of vulnerability, preventing other apps from using necessary
services.
Insight Buffer allocation is a core step in IPC, and also
a very vulnerable one. Vulnerabilities can easily occur dur-
ing this process if the server puts any trust in the client and
skips necessary sanity checks. Unfortunately, this problem
is prevalent among Android native system services and is
persistent. In BnDrm alone, the problematic readVector is
called for more than 30 times, making an easy target for at-
tackers. Performing proper sanity checks would effectively
mitigate this problem. Nevertheless, it is not an easy task
considering the mass body of Android source codes. For-
tunately, there are safely implemented deserialization func-
tions provided by Parcel, which perform input validations.
These standard functions are preferable to the error-prone
customized functions. In this case, replacing readVector
with Parcel::readByteVector would ﬁx the vulnerability
neatly.
5.4.2 Case Study II: Out-of-bound Access Inside infor-
mAllUidData of statsd
containing
int32_t, int64_t
These
three vectors
of
respectively.
Attack The native system service statsd is a daemon in
Android 9. In the transaction Call::INFORMALLUIDDATA,
from data par-
statsd deserializes
cel
items
and
vectors
::android::String16
are passed into informAllUidData and then forwarded to
the updateMap method of UidMap. Function updateMap
iterates on the three vectors in a loop. The size of vector uid
out of the three is used as the loop count. Since items in any
one vector are supposed to have a one-to-one correspondence
to those in the other two vectors, the three vectors are
expected to have the same length, so that the iteration
can work normally. Nevertheless, this requirement is left
unchecked. Out-of-bound access can then be achieved by
passing in a longer vector of uid than the rest two. In order
to generate the malformed transaction, FANS ﬁrst identiﬁes
Figure 7: Call Trace of ip(6)tables-restore stack overﬂow
the variable types of these three inputs from AST. Then it
generates these vectors one by one through (1) generating the
vector size; (2) generating the corresponding number and type
of elements. However, existing work like BinderCraker [6]
might not be able to generate such effective inputs as it
ignores the semantics of these variables.
Insight
In this case, the same index is used for different
vectors, resulting in an OOB vulnerability. This bug, just as
the last case, arises from failure in input validation. Never-
theless, it is a more interesting bug. Hopefully it can yield
an exploitation other than DoS if appropriately used. This