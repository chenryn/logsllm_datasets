plorer that generates only minimal scenarios for speciﬁcations
axiomatized in Alloy. Lastly, our policy enforcer (cf. APE
module) leverages the Xposed framework [11] for preventing
event messages violating synthesized policies.
We used the SEPAR apparatus for carrying out the ex-
periments. Our evaluation addresses the following research
questions:
RQ1. What is the overall accuracy of SEPAR in detecting ICC
(i.e., both inter-component and inter-application) vulner-
abilities compared to other state-of-the-art techniques?
RQ2. How well does SEPAR perform in practice? Can it ﬁnd
security exploits and synthesize their corresponding pro-
tection policies in real-world applications?
RQ3. What is the performance of SEPAR’s analysis realized
atop static analyzers and SAT solving technologies?
RQ4. What is the performance of SEPAR’s policy enforcement?
A. Results for RQ1 (Accuracy)
To evaluate the effectiveness and accuracy of our analysis
technique and compare it against the other static analysis tools,
we used the DroidBench [4] and ICC-Bench [8] suites of
benchmarks, two sets of Android applications containing ICC
based privacy leaks for which all vulnerabilities are known
in advance—establishing a ground truth. These test cases
comprise the most frequently used ICC methods found in
Google Play apps. The benchmark apps also include unreach-
able, yet vulnerable components; reported vulnerabilities that
521
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:20:14 UTC from IEEE Xplore.  Restrictions apply. 
involve such unreachable components are thus considered as
false warnings. Using the apps in this benchmark, which is
developed by other research groups, we have attempted to
eliminate internal threats to the validity of our results. Further,
using the same benchmark apps as prior research allows us to
compare our results against them.
We compared SEPAR with existing tools targeted at ICC vul-
nerability detection, namely DidFail [40] and AmanDroid [57].
COVERT [17] only targets a speciﬁc type of inter-app vulnera-
bility, i.e. privilege escalation. We excluded COVERT from our
comparison, as all of the apps in DroidBench and ICC-Bench
are examples of information leakage type of vulnerabilities
that COVERT cannot detect. We also tried to run IccTA [41],
another tool intended to identify inter-app vulnerabilities, but
faced technical difﬁculties. The tool terminated with error
while capturing ICC links. This issue has also been reported by
others [9]. Though we have been in contact with the authors,
we have not been unable to ﬁx it so far.
Table I summarizes the results of our experiments for eval-
uating the accuracy of SEPAR in detecting ICC vulnerabilities
compared to other state-of-the-art techniques. SEPAR succeeds
in detecting all 23 known vulnerabilities in DroidBench bench-
marks, and 7 vulnerabilities out of 9 in ICC-Bench suite. It
correctly ﬁnds both cases of privacy leak in bindService4 and
startActivityForResults4. It also correctly ignores two cases
where there are no leaks, since the code harboring those
vulnerabilities is not reachable, i.e., startActivity{4,5}. The
only missed vulnerabilities are the ones that are caused by
dynamic registration of Broadcast Receivers, which is not
handled by SEPAR’s model extractor.
In addition to missing the vulnerabilities in the bound
services, AmanDroid is unable to examine Content Providers
for security analysis. DidFail does even worse. Based on
the results, DidFail found only the vulnerabilities caused by
implicit Intents, missing the vulnerabilities that are due to
explicit Intents, such as information leak. The results show
that SEPAR outperforms the other two tools in terms of both
precision and recall.
B. Results for RQ2 (SEPAR and Real-World Apps)
To evaluate the implications of our tool in practice, we
collected 4,000 apps from the following four different sources:
(1) Google Play [7]: This repository serves as the ofﬁcial
Android app store. Our Google play collection consists of 600
randomly selected and 1,000 most popular free apps in the
market. (2) F-Droid [5]: This is a software repository that
contains free and open source Android apps. Our collection
includes 1,100 apps from this Android market. (3) Malgenome
[61]: This repository contains malware samples that cover the
majority of existing Android malware families. Our collection
includes all (about 1,200) apps in this repository. (4) Bazaar
[2]: This website is a third-party Android market. We collected
100 popular apps from this repository, distinguished from apps
downloaded from Google Play and F-Droid.
We partitioned the subject systems into 80 non-overlapping
bundles, each comprised of 50 apps, simulating a collection
of apps installed on an end-user device. The bundles enabled
us to perform several independent experiments. Out of 4,000
apps, SEPAR identiﬁed 97 apps vulnerable to Intent hijack, 124
522
TABLE I: Comparison between SEPAR, DidFail, and Aman-
Droid. TP, FP and FN are represented by symbols (cid:2)(cid:3), (cid:2), (cid:3),
respectively. (X#) indicates the number # of detected instances
for the corresponding symbol X.
AmanDroid
SEPAR
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
((cid:2)(cid:3)2)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
((cid:2)(cid:3)2)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:3)
(cid:3)
DidFail
Test Case
ICC bindService1
ICC bindService2
ICC bindService3
ICC bindService4
ICC sendBroadcast1
ICC startActivity1
ICC startActivity2
ICC startActivity3
ICC startActivity4
ICC startActivity5
(cid:2)(cid:3)
(cid:3)
(cid:3)
(cid:2)((cid:3)2)
(cid:2)(cid:3)
(cid:3)
(cid:3)
(cid:3)
(cid:2)
((cid:2)2)
ICC startActivityForResult1 (cid:3)
ICC startActivityForResult2 (cid:3)
ICC startActivityForResult3 (cid:3)
((cid:3)2)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:3)
(cid:3)
(cid:3)
(cid:3)
(cid:2)(cid:3)(cid:2)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:3)
(cid:3)
ICC startActivityForResult4
ICC startService1
ICC startService2
ICC delete1
ICC insert1
ICC query1
ICC update1
IAC startActivity1
IAC startService1
IAC sendBroadcast1
Explicit Src Sink
Implicit Action
Implicit Category
Implicit Data1
Implicit Data2
Implicit Mix1
Implicit Mix2
DynRegisteredReceiver1
DynRegisteredReceiver2
2
h
c
n
e
B
d
i
o
r
D
h
c
n
e
B
C
C
-
I
(cid:3)
(cid:3)
(cid:3)
((cid:3)2)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:3)
(cid:3)(cid:2)
(cid:2)(cid:3)(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:3)
(cid:3)
(cid:3)
(cid:3)
(cid:3)
(cid:3)
(cid:3)
(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:3)
Precision
Recall
F-measure
55%
37%
44%
86%
48%
63%
100%
97%
98%
apps to Activity/Service launch, 128 apps to inter-component
sensitive information leakage, and 36 apps to privilege es-
calation. We then manually inspected the SEPAR’s results to
assess its utility in practice. In the following, we describe
some of our ﬁndings. To avoid leaking previously unknown
vulnerabilities, we only disclose a subset of those that we have
had the opportunity to bring to the app developers’ attention.
Activity/Service Launch. Barcoder is a barcode scanner
app that scans bills using the phone’s camera, and enables
users to pay them through an SMS service. It also stores
the user’s bank account information, later used in paying the
bills. Given details of a bill as payload of an input Intent,
the InquiryActivity component of this app pays it through
SMS service. This component exposes an unprotected Intent
Filter that can be exploited by a malicious app for making an
unauthorized payment.
Intent Hijack. Hesabdar is an accounting app for personal
use and money transaction that, among other things, manages
account transactions and provides a temporal report of the
transaction history. One of its components handles user ac-
count information and sends the information as payload of
an implicit Intent to another component. When a component
sends an implicit Intent, there is no guarantee that it will be
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:20:14 UTC from IEEE Xplore.  Restrictions apply. 
received by the intended recipient. A malicious application
can intercept an implicit Intent simply by declaring an Intent
Filter with all of the actions, data, and categories listed in the
Intent, thus stealing sensitive account information by retrieving
the data from the Intent.
Information Leakage. OwnCloud provides cloud-based ﬁle
synchronization services to the user. By creating an account
on the back-end server, user can sync selected ﬁles on the
device and access synced ﬁles to browse, manage, and share.
Our study indicates that OwnCloud app is vulnerable to leak
sensitive information to other apps. One of its components
obtains the account information and through a chain of Intent
message passing, eventually logs the account information in
an unprotected area of the memory card, which can be read
by any other app on the device.
Privilege Escalation. Ermete SMS is a text messaging app
with WRITE SMS permission. Upon receiving an Intent, its
ComposeActivity component extracts the payload of the given
Intent, and sends it via text message to a number also speciﬁed
in the payload, without checking the permission of the sender.
This vulnerable component, thus, provides the WRITE SMS
permission to all other apps that may not have it.
C. Results for RQ3 (Performance and Timing)
The next evaluation criteria are the performance benchmarks
of static model extraction and formal analysis and synthesis
activities. We used a PC with an Intel Core i7 2.4 GHz CPU
processor and 4 GB of main memory, and leveraged Sat4J as
the SAT solver during the experiments.
Figure 5 presents the time taken by SEPAR to extract app
speciﬁcations for 4,000 real-world apps. This measurement
is done on the data-sets collected from 4 repositories: Google
Play, F-Droid, Malgenome, and Bazaar. The scatter plot shows
both the analysis time and the app size. According to the
results, our approach statically analyzes 95% of apps in less
than two minutes. As our approach for model extraction
analyzes each app independently, the total static analysis time
scales linearly with the size of the apps.
Table II shows the average time involved in compositional
analysis and synthesis of policies for a set of apps. The ﬁrst
three columns represent the average number of Components,
Fig. 5: Scatter plot representing analysis time for model
extraction of Android apps.
523
TABLE II: Experiments performance statistics.
Components
Intents
313
322
Intent
Filters
148
Time (sec)
Construction
Analysis
260
57
Intents, and Intent ﬁlters within each analyzed bundle. The