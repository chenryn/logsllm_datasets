     95     char *val = NULL;
     96     int rc = SUDO_HOOK_RET_NEXT;
     97 
     98     /* First process the hooks. */
     99     SLIST_FOREACH(hook, &sudo_hook_getenv_list, entries) {
    100     rc = hook->u.getenv_fn(name, &val, hook->closure);
    101     if (rc == SUDO_HOOK_RET_STOP || rc == SUDO_HOOK_RET_ERROR)
    102         break;
    103     }
    104     if (val != NULL)
    105     *value = val;
    106     return rc;
    107 }
    ...
​
在process_hooks_getenv函数的第100行执行了函数指针，该函数的第一个参数是一个字符串，如果用execv的函数地址重写getenv_fn的地址，第100行将执行execv(name,
&val, hook->closure)，只要运行sudo程序的当前路径下存在一个与同name同名的可执行程序，便可以实现任意代码执行。
​
当前主流的操作系统大多数开启了alsr机制，因此execv的函数地址、以及process_hooks_getenv实例地址，在每次运行sudo时都是不同，而且在健全的操作系统里，用户只允许查看自己的crash日志。，因此通过对抗alsr来修改函数指针在实战中还是比较困难的。个人觉得实现这个利用方案还要是掺杂一些运气进去的。
###  重写模块加载接口参数
​ 通过修改加载模块接口函数（dlopen、execv、……）的参数也是一个引入自定义代码有效方法。 **Qualys**
团队通过crash日志分析找到struct service_user可以实现任意代码执行的目的，接下来我们根据源码和函数运行内存探究一下这个方案的可行性。
    pwndbg> b set_cmnd        
    Breakpoint 1 at 0x7f40003ebfd0: file ./sudoers.c, line 922.
    pwndbg> r -s xxxxxx\\ xxxxxxxxxxxxx         
    Starting program: /tmp/sudo/bin/sudoedit -s xxxxxx\\ xxxxxxxxxxxxx
    [Thread debugging using libthread_db enabled]
    Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
    Breakpoint 1, set_cmnd () at ./sudoers.c:922
    ...
    pwndbg> b nss_load_library 
    Breakpoint 2 at 0x7fc7b9b8d4c0: file nsswitch.c, line 329.
    pwndbg> c                                                                                                   
    Continuing.
    Breakpoint 2, nss_load_library (ni=ni@entry=0x561ae1533cc0) at nsswitch.c:329
    pwndbg> p ni                                                   
    $1 = (service_user *) 0x56536ec44cc0
    pwndbg> p *ni                                                       
    $2 = {
      next = 0x56536ec44d00,
      actions = {NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_RETURN, NSS_ACTION_RETURN},
      library = 0x0,
      known = 0x56536ec50c60,
      name = 0x56536ec44cf0 "files"
    }
    pwndbg> p sudo_user.cmnd_args
    $3 = 0x56536ed07a0 "xxxxxx"
    pwndbg> heapbase                                                 
    heapbase : 0x56536ec4400
    pwndbg> p (void*) 0x56536ed07a0 - 0x56536ec44cc0                                                             
    $4 = (void *) 0xffffaf11c828bae0
​ 在上述调试窗口中，我的测试方法可以概括为以下几步：
  * 设置可以让set_cmnd堆溢出的参数：”-s xxxxxx\ xxxxxxxxxxxxx”
  * 判断set_cmnd堆溢出后内否执行到nss_load_library
  * 查看ni的地址是否属于堆空间（通过heapbase我们可以判断ni的地址属于堆空间）
  * 计算sudo_user.cmnd_args 和ni的地址偏移量（0xffffaf11c828bae0）
  * 判断ni与ni->name 是否属于同一片内存（这点也是比较关键的，后文我会结合源码会详细解释原因）
经过上诉操作可以得出以下几条结论：
  * set_cmnd溢出后仍然能够执行到nss_load_library，也就是说set_cmnd和nss_load_library之间的代码段没有受到坏内存影响。
  * ni内存是在sudo_user.cmnd_args之前申请的，因为二者偏移量为负数。（heap分配内存是由低址 -> 高地址方向分配，重新运行调试窗口便可以发现nss_load_library在set_cmnd前执行过）
接下来我们接续分析一下nss_load_library的源码实现：
    // glibc-2.31 我的操作系统的libc版本是 GLIBC 2.31-0
    // 通过执行/usr/lib/x86_64-linux-gnu/libc.so.6 查看自己操作系统的libc版本
    // nss/nsswitch.h
    ...
     61 typedef struct service_user
     62 {
     63   /* And the link to the next entry.  */
     64   struct service_user *next;
     65   /* Action according to result.  */
     66   lookup_actions actions[5];
     67   /* Link to the underlying library object.  */
     68   service_library *library;
     69   /* Collection of known functions.  */
     70   void *known;
     71   /* Name of the service (`files', `dns', `nis', ...).  */
     72   char name[0];
     73 } service_user;
    ...
    //nss/nsswitch.c
    ...
    318 /* Load library.  */
    319 static int
    320 nss_load_library (service_user *ni)
    321 {
    322   if (ni->library == NULL)
    323     {
    324       /* This service has not yet been used.  Fetch the service
    325      library for it, creating a new one if need be.  If there
    326      is no service table from the file, this static variable
    327      holds the head of the service_library list made from the
    328      default configuration.  */
    329       static name_database default_table;
    330       ni->library = nss_new_service (service_table ?: &default_table,
    331                      ni->name);
    332       if (ni->library == NULL)
    333     return -1;
    334     }
    335 
    336   if (ni->library->lib_handle == NULL)
    337     {
    338       /* Load the shared library.  */
    339       size_t shlen = (7 + strlen (ni->name) + 3
    340               + strlen (__nss_shlib_revision) + 1);
    341       int saved_errno = errno;
    342       char shlib_name[shlen];
    343 
    344       /* Construct shared object name.  */
    345       __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,
    346                           "libnss_"),
    347                     ni->name),
    348               ".so"),
    349         __nss_shlib_revision);
    350 
    351       ni->library->lib_handle = __libc_dlopen (shlib_name);
    352       if (ni->library->lib_handle == NULL)
    ...
​ 通过观察nss _load_library的实现，我们不难发现当ni- >library ==
NULL时，会触发第351行的dlopen加载一个以”libnss_“开头，”.so.2”结尾的动态库。动态库的完整值取决于ni->name的值。因此我们只要通过堆溢出修改ni->library为NULL，ni->name为遵循nss命名规范的自定义动态库既可以加载自定义的代码了。
​
由上文分析证明只需要修改ni->library和ni->name两处值便可以实现利用漏洞的目的。对于一次性漏洞（一个生命周期中只允许触发一次的漏洞）同时修改两处不同的内存难度是很大的。不过在上文的运行内存分析中我们已经发现ni和ni->name
属于同一片内存。为了证明这两个地址在同一片内存不是偶然的，我们还要继续分一下struct service_user 的结构。
​ nss/nsswitch.h的第 61 – 73行定义了 struct service_user的结构， 第72行的 char
name[0];（柔性数组）决定了ni和ni->name指向的地址是一段连续内存。（这种写法在高性能编程里经常会用到，因为这样会减少一次malloc/free，这里不做过多的讨论，以后有机会可以详细分析一下。）
​ 在上文的运行内存分析时，我提到过：”sudouser.cmnd_args
和ni的地址偏移量是负数“。堆内存是由低地址向高地址分配的，溢出是低地址向高地址溢出的。只有sudo_user.cmnd_args的地址在ni地址之前才能实现修改ni内容。这里我们还要了解一下malloc的缓存机制，为了提高分配内存的速度，以及减少内存碎片。高版本libc中引入了fastbins、largetbins、smallbins、tcachebins等缓存机制。（当前主流操作系统的libc版本都支持这些缓存机制）。因为sudo_user.cmnd_args地址空间长度受我们自己控制，我们只要在ni分配之前申请一块特殊长度的内存，保证在ni之前分配，在set_cmnd前释放且没被其他逻辑再申请走。基于Qualys团队的分析思路，我们可以通过setlocale的方法通过控制LC*的环境变量构造好这个特殊长度的内存碎片。构造内存碎片的过程我会在后文的实战中做进一步演示，这里不做再多的分析。
​
个人经验来看这个利用方案要比对抗alsr的方案实战性高一些，因为它对操作系统没有任何额外要求，构造随机内存碎片的运气成分也可以通过研究内存分配逻辑来解决。
###  篡改权限鉴定配置
​
这种这利用方式属于sudo程序特有逻辑，sudo程序在权限鉴定时首先会查找session，判断session中的权限鉴定是否有效。（一般操作系统sudo的session都会持续一段时间，在这个时间内，再次调用sudo不用输入密码。这种session机制本身就存在缺陷，在某些情况下是可以利用的，不过这里没有用到）
。这个session检查接口（timestamp_lock）有一个小漏洞：timestamp_lock在寻找入口结构（struct
timestamp_entry）时，没有做tlv结构的完整性校验，造成错误的timestamp_entry结构会被写回到session文件中。接下来我们根据源码再研究一下：
    // plugins/sudoers/def_data.h
    ...
     95 #define I_TIMESTAMPDIR          46
     96 #define def_timestampdir        (sudo_defs_table[I_TIMESTAMPDIR].sd_un.str) //"/run/sudo/ts"
     97 #define I_TIMESTAMPOWNER        47
    ...
    // plugins/sudoers/defaults.c
     ...
     583     goto oom;
     584     if ((def_timestampdir = strdup(_PATH_SUDO_TIMEDIR)) == NULL)
     585     goto oom;
     ...    
    // plugins/sudoers/check.h
    ...
     65 struct timestamp_entry {
     66     unsigned short version; /* version number */
     67     unsigned short size;    /* entry size */
     68     unsigned short type;    /* TS_GLOBAL, TS_TTY, TS_PPID */
     69     unsigned short flags;   /* TS_DISABLED, TS_ANYUID */
     70     uid_t auth_uid;     /* uid to authenticate as */
     71     pid_t sid;          /* session ID associated with tty/ppid */
     72     struct timespec start_time; /* session/ppid start time */
     73     struct timespec ts;     /* time stamp (CLOCK_MONOTONIC) */
     74     union {
     75     dev_t ttydev;       /* tty device number */
     76     pid_t ppid;     /* parent pid */
     77     } u;
     78 };
     ...
     // plugins/sudoers/timestamp.c
     ...
     298 static ssize_t
     299 ts_write(int fd, const char *fname, struct timestamp_entry *entry, off_t offset)
     300 {
     ...
     305     if (offset == -1) {
     306     old_eof = lseek(fd, 0, SEEK_CUR);
     307     nwritten = write(fd, entry, entry->size);
     308     } else {
     ...
     398 /*
     399  * Open the user's time stamp file.
     400  * Returns a cookie or NULL on error, does not lock the file.
     401  */
     402 void *
     403 timestamp_open(const char *user, pid_t sid)
     404 {
     ...