"CVE-2015-7036")。  
为什么一个4年多的bug还未被修复？  
只有在允许来自不受信任的源(Web SQL)的任意SQL的程序上下文中，此bug才容易被触发，因此相应地减轻了它的影响。  
然而，SQLite的使用是如此多用途，以至于我们实际上仍然可以在许多场景中触发它。
# Exploitation Game-plan
CVE-2015-7036是一个非常好利用的bug。  
简而言之，易受攻击的fts3_tokenizer()函数在使用单个参数(如“simple”、“porter”或任何其他已注册的tokenizer)调用时返回tokenizer地址。  
当用2个参数调用fts3_tokenizer时，fts3_tokenizer会用第二个参数中的blob提供的地址覆盖第一个参数中的 tokenizer地址。  
在重写某个tokenizer之后，使用该tokenizer的FTS表的任何新实例都允许我们劫持程序的流。  
我们的漏洞利用计划：  
泄漏tokenizer地址。  
计算基地址。  
伪造一个将执行我们的恶意代码的假tokenizer。  
用我们的恶意tokenizer覆盖其中一个tokenizer。  
实例化fts3表来触发恶意代码
## 面向查询编程©
我们很自豪地提出我们自己独特的方法来利用我们熟悉的结构化查询语言进行漏洞开发。  
我们与社区分享QoP，希望鼓励研究人员追求数据库引擎开发的无限可能性。  
下面的每个原语都附带一个来自sqlite3 shell的示例。  
我们的最终目标是将所有这些原语放置在sqlite_master表中，并劫持加载和查询恶意SQLite db文件的目标软件发出的查询。
## 内存泄漏-二进制
诸如ASLR之类的减轻无疑提高了内存破坏利用的门槛。绕过它的一个常见方法是了解我们周围的内存布局。  
这被广泛称为内存泄漏。  
内存泄漏是它们自己的漏洞子类，每个漏洞的设置都略有不同。  
在我们的示例中，泄漏是SQLite返回一个BLOB。  
这些blob是一个很好的泄漏目标，因为它们有时包含内存指针
易受攻击的fts3_tokenizer()使用单个参数调用，并返回请求的令牌化器的 tokenizer. hex()被人们读取。  
我们显然得到了一些内存地址，但由于小字节序而被反转。  
当然，我们可以使用一些SQLite内置的字符串操作来反转它。  
substr()似乎非常适合！我们可以读取小字节序BLOB，但这提出了另一个问题：我们如何存储东西？
## QOP链
自然，在SQL中存储数据需要INSERT语句。由于sqlite_master经过了严格的验证，我们不能使用INSERT，因为所有语句都必须以“create”开头。我们应对这个挑战的方法是简单地将我们的查询存储在一个有意义的VIEW下，并将它们链接在一起。  
这可能看起来没有什么大不同，但是随着我们的链条变得越来越复杂，能够使用伪变量肯定会让攻击链越来越容易。
## 解包64位指针
如果您曾经做过任何pwning CTF，那么指针的打包和解包的概念应该不陌生。  
这个原语应该可以轻松地将十六进制值(就像我们刚刚实现的泄漏)转换为整数。这样做允许我们在接下来的步骤中对这些指针执行各种计算。  
此查询使用substr()以反向方式逐个字符迭代十六进制字符串。  
使用这个聪明的技巧，只需对基于1的instr()进行少量调整，就可以完成这个字符的转换。  
现在所需要的就是`*`符号右边的进行适当移位。
## 指针算法
指针算术是一项相当容易实现的任务，有整数就可以了。例如，从泄漏的tokenizer指针中提取图像库非常简单，如下所示：  
## 打包64位指针
在读取泄漏的指针并按照我们的意愿操作它们之后，将它们打包回它们的little-endian形式是非常有必要的，这样我们就可以在某个地方编写它们。  
SQLite char()在这里应该有用，因为它的文档声明它将“返回由具有整数的Unicode码点值的字符组成的字符串”。  
在有限范围整数内，char()表现的非常完美。  
较大的整数被转换为其2字节的代码点。  
在与SQLite文档发生冲突之后，我们突然有了一个奇秒的想法:我们的漏洞实际上是一个数据库  
我们可以事先准备一个表，将整数映射到它们的期望值。  
现在我们的指针打包查询如下：  
## 在内存中制作复杂的伪对象
编写单个指针肯定有用，但仍然不够。许多内存安全问题利用场景要求攻击者伪造内存中的某些对象或结构，甚至编写ROP链。  
我们将对前面介绍的几个构建块进行字符串处理。  
例如，让我们伪造我们自己的tokenizer，[原因在此](https://www.sqlite.org/fts3.html#custom_application_defined_tokenizers
"原因在此")。  
我们的伪tokenizer应该符合SQLite在这里定义的预期接口：  
使用上面描述的方法和一个简单的连接查询，我们能够很容易地伪造所需的对象。  
在低级调试器中验证结果时，我们看到确实创建了一个假的tokenizer对象。  
## 堆喷射
现在我们制作了这个伪对象，有时候用它来进行堆喷射非常有用。  
不幸的是，SQLite没有像MySQL那样实现REPEAT（）函数。  
然而，[这个](https://stackoverflow.com/questions/11568496/how-to-emulate-repeat-in-sqlite "这个")线程给了我们一个优雅的解决方案。  
[zeroblob(N)](https://www.sqlite.org/lang_corefunc.html#zeroblob
"zeroblob\(N\)")函数返回一个由N个字节组成的blob，而我们使用replace()将这些零替换为我们的伪对象。  
搜索这些0x41表明我们也获得了完美的一致性。注意每0x20字节重复一次。  
## 内存泄漏 - 堆
我们已经知道二值图像的位置，我们能够推断出必要的函数在哪里，并向堆中喷射恶意的tokenizer。  
现在是时候用我们的一个喷射的对象覆盖一个tokenizer。然而，由于堆地址也是随机化的，我们不知道我们的喷射被分配到哪里。  
堆泄漏要求我们有另一个漏洞。  
同样，我们将以虚拟表接口为目标。  
由于虚拟表使用底层影子表，所以在不同的SQL接口之间传递原始指针是很常见的。  
注意:[SQLite 3.20](https://www.sqlite.org/bindptr.html "SQLite
3.20")减轻了这种类型的问题。幸运的是，PHP7是用较早的版本编译的。如果是更新版本，这里也可以使用CVE-2019-8457。  
要泄漏堆地址，我们需要预先生成一个fts3表，并滥用它的MATCH接口。  
正如我们在第一次内存泄漏中看到的那样，指针是小字节序，因此需要反转。幸运的是，我们已经知道如何使用SUBSTR()做到这一点。现在我们知道了堆的位置，并且可以正确地喷射，我们终于可以用我们的恶意tokenizer覆盖一个tokenizer了！
# 把它们放在一起
有了所有想要的漏洞利用原语，是时候回到我们开始的地方了：利用密码窃取器C2。  
如上所述，我们需要设置一个“陷阱”VIEW来启动我们的攻击。因此，我们需要审计我们的目标，准备正确的VIEW。  
如上面的代码片段所示，我们的目标期望我们的数据库有一个名为Notes的表，其中包含一个名为BodyRich的列。为了劫持这个查询，我们创建了以下VIEW.  
在查询Notes之后，执行3个QOP链。我们来分析第一个
# heap_spray
我们的第一个QOP链应该用大量的恶意tokenizer填充堆。  
p64_simple_create、p64_simple_destroy和p64_system本质上都是通过我们的泄漏和打包功能实现的链。  
例如，p64_simple_create构造为：  
由于这些链变得非常复杂,并且非常重复，我们创建了[QOP.py](https://github.com/CheckPointSW/QueryOrientedProgramming/
"QOP.py")。  
通过以pwntools风格生成这些查询，QOP.py使构造链变得更简单。  
创建前面的语句变得非常简单，  
# Demo
# iOS持久性
在iOS上很难实现持久化，因为所有可执行文件都必须作为苹果安全启动的一部分进行签名。幸运的是，SQLite数据库没有签名。  
利用我们的新功能，我们将用恶意版本替换其中一个常用的数据库。在设备重新启动并查询恶意数据库之后，我们将获得代码执行。  
为了演示这个概念，我们替换了Contacts
DB“AddressBook.sqlitedb”。正如在PHP7中利用漏洞一样，我们创建了两个额外的DDL语句。一个DDL语句覆盖默认的
tokenizer“simple”，另一个DDL语句通过尝试实例化被覆盖的
tokenizer来触发崩溃。现在，我们所要做的就是将原始数据库的每个表重写为一个VIEW，该VIEW可以劫持执行的任何查询，并将其重定向到我们的恶意DDL。  
将contacts db替换为我们的恶意contacts db并重新启动，会导致以下iOS 崩溃转储:  
正如预期的那样，contacts进程在0x4141414141414149处崩溃，在那里可以找到我们的伪造tokenizer的xCreate构造函数。此外，contacts
DB实际上在许多进程之间共享。Contacts、Facetime、Springboard、WhatsApp、Telegram和XPCProxy只是查询它的一些进程。其中一些进程比其他进程更有特权。一旦证明我们可以在查询过程的上下文中执行代码，这种技术也允许我们扩展和提升我们的特权。  
我们的研究和方法都已负责任地向苹果披露，并被分配了以下CVE：  
CVE-2019-8600  
CVE-2019-8598  
CVE-2019-8602  
CVE-2019-8577
# 未来展望
考虑到SQLite实际上是几乎所有平台的内置，我认为在挖掘漏洞方面，我们仅仅触及了冰山一角。我们希望安全社区将采取这种创新的研究和发布的工具，并进一步发展它。我认为接下来还可以做以下工作，  
挖掘更多的漏洞，这可以通过使用sqlite_version()或sqlite_Compileoption_used()等函数从预制表中选择相关QoP小工具来动态构建漏洞利用。  
实现更强的漏洞利用原语，如任意R/W。  
寻找查询程序无法验证数据库可靠性的其他场景。
# 总结
我们确定，简单地查询数据库可能并不像您期望的那样安全。使用我们的查询劫持和面向查询编程的创新技术，我们证明SQLite中的内存损坏问题现在可以可靠地被利用。随着权限层次结构比以往任何时候都更加细分，很明显，我们必须重新考虑受信任/不受信任的SQL输入的边界。为了演示这些概念，我们在运行PHP7的密码窃取器后端上实现了远程代码执行，并在IOS上获得了更高权限的持久性。这只是冰山一角。
    原文：https://research.checkpoint.com/select-code_execution-from-using-sqlite/