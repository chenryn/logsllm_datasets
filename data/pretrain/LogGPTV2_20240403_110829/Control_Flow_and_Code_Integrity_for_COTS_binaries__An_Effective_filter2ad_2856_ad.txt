syscall policy
state model
state model
library loading policy
library loading policy
library loading policy
library loading policy
library loading policy
state model
syscall policy
library loading policy
Figure 7: Eﬀectiveness Evaluation of CFCI
(cid:10)(cid:11)(cid:12)
(cid:13)(cid:14)(cid:13)(cid:12)
(cid:9)(cid:3)(cid:3)(cid:4)(cid:3)(cid:3)(cid:5)
(cid:8)(cid:3)(cid:4)(cid:3)(cid:3)(cid:5)
(cid:7)(cid:3)(cid:4)(cid:3)(cid:3)(cid:5)
(cid:6)(cid:3)(cid:4)(cid:3)(cid:3)(cid:5)
(cid:2)(cid:3)(cid:4)(cid:3)(cid:3)(cid:5)
(cid:3)(cid:4)(cid:3)(cid:3)(cid:5)
(cid:1)(cid:2)(cid:3)(cid:4)(cid:3)(cid:3)(cid:5)
Figure 4: Performance of CFCI on SPEC2006
(cid:13)(cid:14)(cid:4)(cid:15)(cid:4)(cid:16)(cid:17)(cid:3)
(cid:18)(cid:19)(cid:18)(cid:20)
(cid:1)(cid:11)
(cid:1)(cid:10)
(cid:1)(cid:9)
(cid:1)(cid:6)
(cid:12)
(cid:11)
(cid:10)
(cid:9)
(cid:6)
(cid:28)
(cid:7)
(cid:25)
(cid:27)
(cid:24)
(cid:26)
(cid:25)
(cid:4)
(cid:21)
(cid:24)
(cid:23)
(cid:22)
(cid:21)
(cid:14)
(cid:17)
(cid:21)
(cid:7)
Figure 5: Micro Benchmark Evaluation of CFCI
(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)
(cid:1)(cid:6)(cid:2)(cid:3)(cid:4)(cid:5)(cid:7)
(cid:8)(cid:6)(cid:2)(cid:3)(cid:4)(cid:5)(cid:7)
(cid:1)(cid:6)(cid:6)(cid:2)(cid:3)(cid:4)(cid:5)(cid:7)
6
it with that for loading the instrumented versions
. Fig-
ure 5 demonstrates that the overhead grows linearly with
the number of libraries loaded. On average, the overhead
of CFCI on a library load is 150%. While this may seem
considerable, it should be kept in mind that this is a mi-
crobenchmark, and the actual overheads, when the overall
execution time is considered, is much smaller.
5.3 Commonly Used Linux Applications
Since only code allocation and deallocation will generate
performance overhead, we focus our evaluation on program
startup when large number of modules get loaded. The re-
sults are shown in Figure 6, where the base load time is
in seconds. Note that PSI has observable startup overhead
(147% on average) because this phase is not optimized. The
6Note that we instrumented all libraries when testing transformed
binary.
97
Program
Name
vim
evince
lyx
lynx
wireshark
nautilus
acroread
Base
load
time
0.140
0.336
0.484
0.052
0.684
0.080
0.972
PSI
overhead
(over base, %)
34
222
89
38
224
900
280
Added CFCI
overhead
(over base, %)
8
8
10
2
18
16
7
# of
loaded
libraries
96
103
152
15
114
178
82
Figure 6: Startup Overhead on Typical Applications
additional overhead generated by CFCI is small — ranging
from 2% to 18%, with an average of 8%. Note that many of
these programs load more than 100 shared libraries each.
5.4 Running with Dynamic Code
To demonstrate compatibility with dynamic code, we used
LibJIT [14], an actively maintained JIT engine similar to the
LLVM backend. To make LibJIT compatible with CFCI,
we force LibJIT to generate only non-writable code. To
evaluate our performance overhead for LibJIT, we reuse an
open source benchmark tool [19]. The benchmark tool is a
simple program that computes the greatest common divisor
(GCD). LibJIT allows dynamic functions to be invoked di-
rectly (LibJIT-fast). Our evaluation shows that CFCI over-
head is 14.6%. This overhead includes about 10% overhead
incurred for runtime code transformation.
5.5 Effectiveness Evaluation
Although CFI bypass technique is emerging as shown in
recent research work [25, 32], real-world exploits have not
been designed with CFI in mind. Therefore, running those
exploits won’t show the beneﬁts of CFCI. For this reason,
our eﬀectiveness evaluation uses a combination of manual
analysis based on studying the relevant CVE reports, and
proof-of-concept exploits that we created ourselves. This
evaluation is summarized in Figure 7.
According to our threat model in Section 2, we classify all
attacks into direct attacks (direct), loader data corruption
attacks (ldr.data), and loader code reuse attacks (ldr.cr).
From Table 7, it is clear that all types of attacks are defeated.
In particular, our system call policy prevents all direct at-
tacks that try to manipulate code permission or launch ma-
licious binaries. For loader subversion attacks such as search
path corruption, our library loading policy properly defeats
Policy for Adobe Reader:
ALLOW
REJECT
ALLOW
REJECT
ALLOW
REJECT
ALLOW
REJECT
*
/lib/i386-linux-gnu/
*
libc.so.6
libc.so.6
libpthread.so.0 /lib/i386-linux-gnu/
libpthread.so.0 *
libselinux.so.1 /lib/i386-linux-gnu/
libselinux.so.1 *
*
/lib/i386-linux-gnu/
/usr/lib/*
/opt/Adobe/Reader9/Reader/
intellinux/lib
/usr/lib/i386-linux-gnu/*
/usr/lib
*
Figure 8: Library Loading Policy for Adobe Reader
all disallowed modules being loaded from unintended paths.
More advanced attacks such as code reuse attacks targeting
the loader are stopped by our loader state model.
5.5.1 Case study: Library policy for Adobe Reader
As described in Section 2, an attacker may attempt to
load a malicious library by specifying it by name, or by
corrupting the load path (“library hijacking”). CFCI blocks
these attacks using policies to limit the load path, as well as
the speciﬁc libraries that may be loaded by an application.
To illustrate these policies, consider Figure 8 which shows
our policy for Adobe Reader, a favorite target for library
loading attacks [8, 6, 7].
In addition, the example also illustrates the ﬂexibility pro-
vided in our policy language. It is possible to allow or deny
loads of speciﬁc libraries, or permission can be granted based
on the directory from which a library is loaded. Moreover,
policies can be stricter for some libraries. Figure 8 uses a
stricter policy for low-level libraries libc.so, libpthread.so
and libselinux.so, forcing them to be loaded from a spe-
ciﬁc ﬁle in a speciﬁc directory.
5.5.2 Case study: Library policy for static binary
It is a common misconception that static binaries won’t
have any ability to load libraries. Our experiments prove
otherwise. We wrote a small, statically-linked program that
contains a traditional buﬀer overﬂow vulnerability. We then
crafted an exploit for this vulnerability. Instead of calling
dlopen, a function that is unavailable in statically linked
binaries, our exploit redirected control to _dl_open, an in-
ternal function statically linked from loader. This function
was passed the name of a library in /tmp. Our exploit re-
sulted in a successful load of this library. Along with the
library, dependent libraries such as libc.so and ld.so were
also loaded! Finally, the initialization function of the mali-
cious library was executed.
Our default policy for library loading stopped this attack,
as it prevents loads of libraries outside standard directories
for libraries.
5.5.3 Case study: Text relocation attack
In order to evaluate code-reuse and data corruption at-
tacks on the loader, we implemented a proof-of-concept ex-
ploit that leverages text relocation.
Our exploit code is implemented as a piece of native code.
This helps us avoid the complications of crafting valid ROP
attacks in the presence of CFI. Full details of the attack is
described in [67]. Our experiments shows that this exploit
is very robust and works on any dynamically linked ELF
98
programs.
We then attempted the exploit in the presence of CFCI.
The attack was detected and blocked by our loader state
model.
5.5.4 Case study: Making stack executable
Similar to relocation attack, we wrote a simple proof-of-
concept exploit that makes the stack executable, and then
jumps to the stack.
In glibc 2.15, the loader function for
making the stack executable makes two sanity checks. The
ﬁrst one checks that the caller’s address is within the loader,
while the second one checks the consistency of __libc_stack
_end. Bypassing the ﬁrst check is easy — simply using a
return address in loader would suﬃce; when the function is
ﬁnished, it will go back to a gadget inside the loader and
can be arranged to jump back to the call site. Bypassing
the second check requires the attacker to corrupt a global
variable in ld.so, which is easy once ASLR is bypassed. In
sum, our exploit code bypassed these two checks and made
the stack executable.
When run in the presence of CFCI, this exploit is blocked
by our policies. Speciﬁcally, the attempt made by the exploit
to make an empty region (ES) executable was denied by this
policy.
Defeating this attack is important despite the fact that
PSI alone could already defeat it. This is because other
underlying CFI implementation may rely on DEP. For in-
stance, Abadi CFI [16] requires stack to be non-executable
to prevent jump-to-stack attack that has valid ID in payload.
6. RELATED WORK
Memory corruption defenses and CFI. Memory cor-
ruption attacks have been the most important targets for
attackers. The most complete defense against these at-
tacks would be based on bounds-checking [34, 59, 61, 17,
39]. Unfortunately, these techniques introduce considerable
overheads, while also raising signiﬁcant compatibility issues.
LBC [33] achieves lower overheads while greatly improv-
ing compatibility by trading oﬀ the ability to detect non-
contiguous buﬀer overﬂows. Code pointer integrity (CPI)
[35] signiﬁcantly reduces overheads by selectively protecting
only those pointers whose corruption can lead to control-ﬂow
hijacks.
The most widely deployed defenses against memory cor-
ruption have been based on randomization [47, 21, 36, 20,
38, 18, 23, 26]. Unfortunately, randomization techniques