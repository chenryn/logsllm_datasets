i
t
p
m
u
s
n
o
c
h
t
d
w
d
n
a
B
i
0
1024
Set size
262144
(b) Bandwidth Consumption: 256-bit security
Figure 5: Bandwidth Consumption Comparison
other semi-honest PSI protocols. The protocols we compared to
are De Cristofaro’s RSA-OPRF protocol (implemented in C) and
Huang’s Sort-Compare-Shufﬂe with Waksman Network protocol
(implemented in Java). They are previously the fastest PSI pro-
tocols and the code has been optimized by the authors. We test
the two protocols on the same hardware and OSes that we use for
testing ours. De Cristofaro’s C implementation is compiled with
OpenSSL 1.0.1e and GMP 5.1.1 using gcc. The RSA public expo-
nent is 3 in all tests. We run Huang’s Java code using Java 1.7.0_12.
The element bit length in Huang’s protocol is set to 32. As it is un-
fair to compare the performance of Huang’s Java code with our C
code, we ported our C code to Java and measured the performance.
We measured the total running time of the protocols. De Cristo-
faro’s code outputs running time so we use the output directly3.
Huang’s code has no such output, and we measure the running time
of the execution() function in the P rogram class.
The comparison in Table 3 shows that in all settings, both modes
of our protocol are faster than the other two protocols. Both De
Cristofaro’s implementation and Huang’s implementation pipeline
the protocol execution, which is exactly what we do in the pipelined
mode. Therefore the performance of these three can be compared
directly4. The performance of De Cristofaro’s protocol is close to
ours at 80-bit security and is faster than Huang’s. But when the se-
3We exclude the running time of the last step in the protocol. In
this step the client searches the hash values received in the protocol
to ﬁnd the intersection. This step is excluded because it uses an
inefﬁcient pairwise comparison and the authors plan to replace it
with a hashtable search.
4De Cristofaro’s code uses two threads on each side for computa-
tion. But this does not affect the comparison result.
798curity parameter increases to 256-bit, it becomes much slower than
our protocol and Huang’s. This is because De Cristofaro’s protocol
is based mainly on public key operations, while ours and Huang’s
protocols rely on mostly symmetric key operations. Put aside dif-
ferences caused by languages and implementation, our protocol is
faster than Huang’s because it requires the same number of pub-
lic key operations but signiﬁcantly less symmetric key operations.
For example, at 80-bit security with 220 input size, our protocol
requires 0.4 billion symmetric key operations, while Huang’s re-
quires 8.5 billion (1.7 billion non-free gates, each requires 4 sym-
metric key operations to build and another 1 to evaluate).
We skip the test with the biggest input size (220) on De Cristo-
faro’s protocol at 256-bit security because it would take too long.
The running time of De Cristofaro’s protocol is linear in the input
size, our estimation is that it would need 131 hours to ﬁnish. This
estimation is based on the result of test with 218-element sets at
the same security level. The JVM on the client computer ran out
of memory (16 GB) when we testing Huang’s protocol with 220-
element sets at 80-bit security. The test was repeated twice and both
times we got the same error. We could not ﬁnish the test but base
on the test result of input size 218, we estimate the test would need
27 hours. This estimation is somehow far from the time reported
by the authors, that is 6 hours. However the test had been running
for more than 24 hours before the JVM threw the error. Therefore
we believe the estimation is reasonable. We observed excessive
paging activities during the test on the client computer because the
JVM occupied all free memory (14 GB). This may account for the
difference between our estimation and the authors’ measurement.
Because at 256-bit security Huang’s protocol requires even more
memory, we skip the test with 220 input size and estimate the run-
ning time to be 51 hours from test result of input size 218.
We also measured bandwidth consumption of the protocols. As
we couldn’t ﬁnish the tests with the other protocols using 220 input
size, the largest input size we used in the experiment was 218. The
results are shown in Figure 5. As we can see, the bandwidth con-
sumption of De Cristofaro’s and our protocol is almost linear. Our
protocol consumes more bandwidth than De Cristofaro’s protocol
but less than Huang’s protocol.
6.4 Further Parallelization
GPGPUs For many personal computers, a readily available mas-
sive parallel computing device is the graphic cards. Modern GPUs
have hundreds of processing cores and can provide ample com-
putation cycles and high memory bandwidth to massively parallel
applications. The computation in our protocol can be easily paral-
lelized and therefore is an ideal application for GPU acceleration.
We have started implementing the protocol on top of OpenCL [3].
A test on our GPU version of SHA-1 shows that on an ATI Radeon
HD 5770 graphic card, it only takes 37.5 milliseconds to perform 1
million hash operations. This is about 5 times faster than a single
2.4 GHz CPU core.
Extremely Big Data Set & Cloud Computing In practice, to pro-
cess extremely big data set, we have to distribute the task on mul-
tiple computers. New computing paradigms such as cloud comput-
ing make it possible to execute such distributed tasks “on demand”.
Our protocol can be easily deployed on cloud platforms. Here we
show how to do it with the semi-honest protocol. The fully se-
cure protocol case is similar. From a high level point of view, the
client and the server throw their elements into bins using an hash
function. Each side has b bins and each bin contains about ⌈ n
b ⌉
elements. Then they build Bloom ﬁlters and garbled Bloom ﬁlters
for each bin. The parameter k is still determined by the desired
false positive probability, the parameter m is determined by k and
input
set
map
shufﬂe
reduce
GBFbin0
GBFbin1
OT
GBFbin2
Figure 6: MapReduce on the server side
the bin size. The ﬁlters are associated with the bin number. Then
for each 0 ≤ i < b, the server uses OT to transfer the garbled
Bloom ﬁlter for bin i to the client, who uses its Bloom ﬁlter for
bin i as the selection string. The client then queries all elements
in its bin i against the received garbled Bloom ﬁlter and adds any
positive elements into the result set. In the end, the client has the
intersection. Conceptually, this splits a big set into b smaller sets
that each can be handled by a single node. It is correct because
the two parties use the same hash function so an element thrown
by the server into bin i will also be threw by the client into bin i.
The idea can be implemented using the MapReduce programming
model [18] easily. For example, ﬁgure 6 depicts the MapReduce
procedure of the ﬁrst step on the server side with 3 bins: the map
function takes a portion of the input set and maps an element into a
key-value pair such that the key is the bin number and the value is
a tuple consists of the element and k index numbers. The MapRe-
duce framework shufﬂes and groups together the values returned
by the map function that have the same key. The reduce function
generates a garbled Bloom ﬁlter of a certain bin and outputs it for
OT. We are currently experimenting with Hadoop [1] to implement
the protocol in MapReduce.
7. CONCLUSION AND FUTURE WORK
In this paper we presented a highly efﬁcient and scalable PSI
protocol based on oblivious Bloom intersection. The protocol de-
pends mostly on efﬁcient symmetric key operations and the op-
erations can be parallelized easily. We presented two variants of
the protocol: the basic one is secure in the semi-honest model and
the enhanced one is secure in the malicious model. The perfor-
mance evaluation and comparison results show that our protocol
is orders of magnitude faster than the previously fastest protocols.
The results also show that our protocol can fully utilize the parallel
processing capability provided by the multicore architecture. The
efﬁciency and scalability make our protocol suitable for large scale
privacy preserving data processing.
As discussed in Section 6.4, we are in the process of prototyp-
ing the protocol on GPGPUs and MapReduce. The preliminary
results of this work is encouraging. We hope more parallelization
options could enable more applications in various computing envi-
ronments.
In the ﬁeld of cryptographic protocols, we have seen many ex-
amples that a new protocol improves performance of previous work
by using a better algorithm. It is different in this work: the perfor-
mance gain comes mainly from a better data structure. We would
like to continue our research along this line. Namely we will inves-
tigate, adapt and design better data structures, so that they can be
used in the design of more efﬁcient cryptographic protocols.
799Acknowledgements
Changyu Dong is supported by a science faculty starter grant from
the University of Strathclyde. Zikai Wen is supported by an un-
dergraduate research internship from the University of Strathclyde.
We thank Emiliano De Cristofaro and Yan Huang for sharing their
PSI source code. We also thank the anonymous reviewers for their
helpful comments.
8. REFERENCES
[1] Hadoop. http://hadoop.apache.org/.
[2] Murmurhash. https://code.google.com/p/smhasher/.
[3] Opencl. http://www.khronos.org/opencl/.
[4] C. C. Aggarwal and P. S. Yu, editors. Privacy-Preserving
Data Mining - Models and Algorithms, volume 34 of
Advances in Database Systems. Springer, 2008.
[5] G. Ateniese, E. De Cristofaro, and G. Tsudik. (If) size
matters: Size-hiding private set intersection. In Public Key
Cryptography, pages 156–173, 2011.
[6] P. Baldi, R. Baronio, E. De Cristofaro, P. Gasti, and
G. Tsudik. Countering gattaca: efﬁcient and secure testing of
fully-sequenced human genomes. In ACM Conference on
Computer and Communications Security, pages 691–702,
2011.
[7] D. Beaver. Correlated pseudorandomness and the complexity
of private computations. In STOC, pages 479–488, 1996.
[8] M. Bellare and P. Rogaway. Random oracles are practical: A
paradigm for designing efﬁcient protocols. In ACM
Conference on Computer and Communications Security,
pages 62–73, 1993.
[9] B. H. Bloom. Space/time trade-offs in hash coding with
allowable errors. Commun. ACM, 13(7):422–426, 1970.
[10] P. Bose, H. Guo, E. Kranakis, A. Maheshwari, P. Morin,
J. Morrison, M. H. M. Smid, and Y. Tang. On the
false-positive rate of bloom ﬁlters. Inf. Process. Lett.,
108(4):210–213, 2008.
[11] E. Bursztein, M. Hamburg, J. Lagarenne, and D. Boneh.
Openconﬂict: Preventing real time map hacks in online
games. In IEEE Symposium on Security and Privacy, pages
506–520, 2011.
[12] J. Camenisch and G. M. Zaverucha. Private intersection of
certiﬁed sets. In Financial Cryptography, pages 108–127,
2009.
[13] D. Dachman-Soled, T. Malkin, M. Raykova, and M. Yung.
Efﬁcient robust private set intersection. In ACNS, pages
125–142, 2009.
[14] Q. Dang. SP 800-107 (rev. 1). recommendation for
applications using approved hash algorithms. Technical
report, Gaithersburg, MD, United States, 2012.
[15] E. De Cristofaro, J. Kim, and G. Tsudik. Linear-complexity
private set intersection protocols secure in malicious model.
In ASIACRYPT, pages 213–231, 2010.
[16] E. De Cristofaro and G. Tsudik. Practical private set
intersection protocols with linear complexity. In Financial
Cryptography, pages 143–159, 2010.
[17] E. De Cristofaro and G. Tsudik. Experimenting with fast
private set intersection. In TRUST, pages 55–73, 2012.
[18] J. Dean and S. Ghemawat. Mapreduce: Simpliﬁed data
processing on large clusters. In OSDI, pages 137–150, 2004.
[19] C. Dong, L. Chen, and Z. Wen. When private set intersection
meets big data: An efﬁcient and scalable protocol.
Cryptology ePrint Archive, Report 2013/515, 2013.
[20] S. Even, O. Goldreich, and A. Lempel. A randomized
protocol for signing contracts. Commun. ACM,
28(6):637–647, 1985.
[21] M. J. Freedman, K. Nissim, and B. Pinkas. Efﬁcient private
matching and set intersection. In EUROCRYPT, pages 1–19,
2004.
[22] O. Goldreich. The Foundations of Cryptography - Volume 2,
Basic Applications. Cambridge University Press, 2004.
[23] C. Hazay and Y. Lindell. Efﬁcient protocols for set
intersection and pattern matching with security against
malicious and covert adversaries. In TCC, pages 155–175,
2008.
[24] C. Hazay and K. Nissim. Efﬁcient set operations in the
presence of malicious adversaries. In Public Key
Cryptography, pages 312–331, 2010.
[25] Y. Huang, D. Evans, and J. Katz. Private set intersection: Are
garbled circuits better than custom protocols? In NDSS,
2012.
[26] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank. Extending
oblivious transfers efﬁciently. In CRYPTO, pages 145–161,
2003.
[27] S. Jarecki and X. Liu. Efﬁcient oblivious pseudorandom
function with applications to adaptive OT and secure
computation of set intersection. In TCC, pages 577–594,
2009.
[28] S. Jarecki and X. Liu. Fast secure computation of set
intersection. In SCN, pages 418–435, 2010.
[29] F. Kerschbaum. Outsourced private set intersection using
homomorphic encryption. In ASIACCS, pages 85–86, 2012.
[30] L. Kissner and D. X. Song. Privacy-preserving set
operations. In CRYPTO, pages 241–257, 2005.
[31] D. Many, M. Burkhart, and X. Dimitropoulos. Fast private
set operations with sepia. Technical Report 345, Mar 2012.
[32] G. Mezzour, A. Perrig, V. D. Gligor, and P. Papadimitratos.
Privacy-preserving relationship path discovery in social
networks. In CANS, pages 189–208, 2009.
[33] S. Nagaraja, P. Mittal, C.-Y. Hong, M. Caesar, and
N. Borisov. Botgrep: Finding P2P bots with structured graph
analysis. In USENIX Security Symposium, pages 95–110,
2010.
[34] M. Naor and B. Pinkas. Efﬁcient oblivious transfer protocols.
In SODA, pages 448–457, 2001.
[35] A. Narayanan, N. Thiagarajan, M. Lakhani, M. Hamburg,
and D. Boneh. Location privacy via private proximity testing.
In NDSS, 2011.
[36] NIST. Recommended elliptic curves for federal government
use, 1999.
[37] O. Papapetrou, W. Siberski, and W. Nejdl. Cardinality
estimation and dynamic length adaptation for bloom ﬁlters.
Distributed and Parallel Databases, 28(2-3):119–156, 2010.
[38] M. O. Rabin. How to exchange secrets by oblivious transfer.
Technical Report TR-81, Harvard Aiken Computation
Laboratory, 1981.
[39] B. Schneier. Applied cryptography - protocols, algorithms,
and source code in C (2. ed.). Wiley, 1996.
[40] A. Shamir. How to share a secret. Commun. ACM,
22(11):612–613, 1979.
800