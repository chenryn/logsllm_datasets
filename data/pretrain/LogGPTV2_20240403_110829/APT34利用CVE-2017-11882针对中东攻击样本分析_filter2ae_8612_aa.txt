# APT34利用CVE-2017-11882针对中东攻击样本分析
|
##### 译文声明
本文是翻译文章，文章原作者 fireeye，文章来源：fireeye.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 一、前言
在2017年11月14日，微软官方发布了[CVE-2017-11882](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-11882)漏洞的补丁，不到一周后，Fireye发现了一名利用Office漏洞攻击中东政府组织的攻击者。我们认为此次攻击活动是由一个疑似在伊朗从事网络间谍活动的黑客组织发起的，我们称之为APT34。他们通过使用自己编写的PowerShell后门实现这次攻击。
**我们了解到
APT34至少从2014年开始就一直在从事长期的网络间谍行动，主要是为了国家的利益而侦察收集信息。这个黑客组织针对的行业十分广泛，包括金融，政府，能源，化工和电信。**并且他们的攻击主要集中在中东地区。我们认为APT34为伊朗政府所做的工作包括以下几个方面，涉及伊朗基础建设的有关细节情报，伊朗基础设施的使用情报，以及针对其他符合伊朗国家利益的目标。
APT34善于使用一些公开的和一些非公开的工具，经常利用盗来的账户进行鱼叉式网络钓鱼，有时还会使用一些社工的手段。在2016年5月，我们在博客中详细描述了一起针对中东地区银行的[钓鱼攻击事件](https://www.fireeye.com/blog/threat-research/2016/05/targeted_attacksaga.html)。事件中攻击者分发带有POWBAT病毒的支持宏的附件。我们认为这次攻击的始作俑者就是APT34。在2017年7月，我们发现了一起APT34针对一个中东组织发起的攻击。在这次攻击中，APT34使用了一个基于PoweShell的后门以及一个具有域名生成算法功能的下载器。我们分别称他们为POWRUNER，BONDUPDATER。后门是利用
[CVE-2017-0199](https://www.fireeye.com/blog/threat-research/2017/04/cve-2017-0199-hta-handler.html)，通过一个恶意的.rtf文件发送的。
在此次最新的攻击活动中， APT34利用近期Microsoft
Office的漏洞CVE-2017-11882来部署POWRUNER和BONDUPDATER。
关于APT34的全部报告可以在[这里](https://www.fireeye.com/products/isight-cyber-threat-intelligence-subscriptions.html)找到。APT34与这篇报告中所提到的组织”[OilRig](https://researchcenter.paloaltonetworks.com/2016/10/unit42-oilrig-malware-campaign-updates-toolset-and-expands-targets/)“有相似的活动行为。由于不同组织在追踪各自对手的时候，所使用的数据集不同。因此，我们对于攻击者活动的分类并不完全一致。
## 二、CVE-2017-11882：Microsoft Office 堆栈内存损坏漏洞
CVE-2017-11882影响Microsoft
Office的多个版本。漏洞被触发时，由于不正确地处理内存中的对象而导致远程用户可以在当前用户的上下文环境中执行任意代码。
微软在2017年11月14日修复了这个漏洞，一个星期后，报告漏洞的人给出了一个完整的POC。
漏洞出现在一个旧的公式编辑器（EQNEDT32.EXE）中，该编辑器是Microsoft
Office用来插入数学公式的一个组件。公式编辑器使用对象链接与嵌入技术（OLE）将公式嵌入在Office文档中。 **它并不会被作为
Office进程（如Word等）的子进程创建，而是以单独的进程形式存在。**如果将写好的公式传递给公式编辑器，由于它在复制数据时不会正确地检查数据长度，所以导致堆栈内存损坏。因为EQNEDT32.exe是使用较旧的编译器编译的，并且不支持地址空间布局随机化（ASLR）技术（该技术可以防范内存损坏漏洞被利用），所以攻击者可以轻松更改程序执行流程。
## 三、APT34攻击流程分析
APT34将恶意的.rtf文件（MD5：a0e6933f4e0497269620f44a083b2ed4）作为鱼叉式网络钓鱼邮件的附件发送给受害组织。恶意文件利用CVE-2017-11882，破坏堆栈内存，然后将恶意数据压栈。之后利用EQNEDT32.EXE现有指令的地址覆盖掉栈上的函数地址。覆盖后的指令（如图1）是用来调用kernel32.dll中的”WinExec”函数。如图1中地址为00430c12，调用”WinExec”的指令所示。
图1：覆盖函数地址
上述内容完成后，”WinExec”函数会在当前登录用户的上下文环境中创建子进程”mshta.exe”。进程”mshta.exe”会从hxxp://mumbai-m[.]site/b.txt下载恶意脚本并执行。如图2
图2：将恶意数据复制到损坏的堆栈缓冲区
###  3.1 攻击流程图
恶意脚本经过一系列步骤才能成功执行，并最终建立与命令和控制（C2）服务器的连接。图3说明了从恶意文件利用漏洞开始的全部流程。
图3：CVE-2017-11882和POWRUNER攻击流程
1. 恶意.rtf文件利用CVE-2017-11882。
2. 利用EQNEDT32.EXE中一个现有的指令的地址覆盖掉栈上的函数地址。
3. 创建”mshta.exe”子进程。它会从hxxp://mumbai-m[.]site/b.txt下载恶意脚本b.txt。
4. b.txt中包含了一条PowerShell命令。这条命令用来从hxxp://dns-update[.]club/v.txt上下载一个dropper。同时，这条命令也把下载下来的v.txt重命名为v.vbs并执行。
5. v.vbs脚本释放4个组件(hUpdateCheckers.base, dUpdateCheckers.base, cUpdateCheckers.bat, and GoogleUpdateschecker.vbs)到如下目录: C:ProgramDataWindowsMicrosoftjava
6. v.vbs使用CertUtil.exe（一个合法的Microsoft命令行程序用作证书服务的一部分）来解码base64编码的文件hUpdateCheckers.base和dUpdateCheckers.base，并将hUpdateCheckers.ps1和dUpdateCheckers.ps1释放到staging目录。
7. 启动cUpdateCheckers.bat，为GoogleUpdateschecker.vbs创建一个任务计划程序使其持续运行。
8. GoogleUpdateschecker.vbs在等待五秒后执行。
9\. 在staging 目录中删除cUpdateCheckers.bat 以及 *.base。
图四包含了v.vbs在执行流程过程中的部分代码
图4：v.vbs部分执行流程
成功执行上述流程提到的步骤之后，任务计划程序将会每分钟启动一次GoogleUpdateschecker.vbs。.vbs脚本会依次执行dUpdateCheckers.ps1
和hUpdateCheckers.ps1。这些PowerShell脚本就是最终的payload—他们包括具有域名生成算法功能的下载器以及一个连接到C2服务器来接受命令，执行其他恶意活动的后门。
### 3.2 hUpdateCheckers.ps1 (POWRUNER)
后门组件POWRUNER是一个PowerShell脚本，用于发送和接收来自C2服务器的命令。任务计划程序每分钟执行一次POWRUNER。
图5包含了POWRUNER后门的部分代码。
图5：POWRUNER 的PowerShell脚本hUpdateCheckers.ps1
POWRUNER首先向C2服务器发送一个随机的GET请求并等待响应。服务器将会返回”not_now”或是一个11位的随机数。如果响应是一个随机数，POWRUNER将向服务器发送另一个随机的GET请求，并将此次服务器回传的响应存储在一个字符串中。然后POWRUNER将检查这个字符串的最后一位，将这一位与下表中的数字匹配，从而执行对应的命令。
表1中是命令值和与之对应的操作。
命令
|
描述
|
对应操作  
---|---|---  
0
|
服务器回传的字符串中包含batch命令
|
执行batch命令，并把结果返回给服务器  
1
|
服务器回传的字符串是一个文件的路径
|
检索文件路径，并将相应文件上传（PUT）到服务器  
2
|
服务器回传的字符串是一个文件的路径
|
检索文件路径，并下载此文件（GET）  
表1：POWRUNER 命令对应表
成功执行命令后，POWRUNER将结果发送回C2服务器并停止执行。
C2服务器还可以通过发送PowerShell命令来捕获并存储受害者系统的屏幕截图。如果发出”fileupload”命令，POWRUNER会将捕获的截图图像文件发送到C2服务器。图6展示了C2服务器发送的PowerShell命令中的”Get-Screenshot”函数。
图6：Powershell截图函数
### 3.3 dUpdateCheckers.ps1 (BONDUPDATER)
APT34最近的一个新进展就是使用DGA生成子域名。基于硬编码字符串”B007″命名的BONDUPDATER脚本使用自定义的DGA算法来生成与C2服务器进行通信的子域名。
####  DGA生成域名过程
图7展示了如何使用BONDUPDATER中自定义的DGA生成示例域名（456341921300006B0C8B2CE9C9B007.mumbai-m[.]site）
图7：细分BONDUPDATER创建子域名过程
1. 这是一串使用以下代码随机生成的数字：$rnd = -join (Get-Random -InputObject (10..99) -Count (%{ Get-Random -InputObject (1..6)}));
2. 该值为0或1。初值设为0。如果解析的第一个域名IP地址是以24.125.X.X开头的，则置为1。
3. 初值设为0。每经过一次DNS请求，该值就加3。
4. 系统UUID的前12个字符。
5. 硬编码字符串”B007″。
6\. 硬编码域名”mumbai-m[.]site”。
BONDUPDATER将尝试解析生成的DGA域名，并根据IP地址解析结果采取以下操作：
1. 在％temp％位置创建一个临时文件。
临时文件的文件名是解析出的IP地址的最后16bit（俩个8bit位组）。
2\. BONDUPDATER 将会根据文件名的最后一个字符与下表中的数字匹配，进而执行相应操作。
字符
|
响应操作描述  
---|---  
0
|
文件包含batch命令，执行这些命令  
1
|
将文件扩展名改为.ps1  
2
|
将文件扩展名改为.vbs  
表2：BONDUPDATER 命令对应表
一些子域名示例：
143610035BAF04425847B007.mumbai-m[.]site
835710065BAF04425847B007.mumbai-m[.]site
376110095BAF04425847B007.mumbai-m[.]site
###  3.4 攻击中的网络通信
图9展示了POWRUNER后门客户端与服务器之间的网络通信。
图9：网络通信示例
在这个示例中，POWRUNER客户端向C2服务器发送一个随机的GET请求，C2服务器返回随机的数字（99999999990）。由于响应是以”0″结尾的随机数，所以POWRUNER会发送另一个随机GET请求来接受附加的命令字符串。C2服务器返回base64编码的响应。
如果服务器发送了字符串”not_now”作为响应，如图10所示，POWRUNER将停止进一步的请求并终止执行。
图10：服务器回传”not now”示例
###  3.5 Batch命令
POWRUNER也可以从C2服务器接受batch命令，从而在系统中收集主机信息。包括当前登录用户信息，主机名，网络配置数据，激活的连接，进程信息，本地和域管理员账户信息，用户目录以及其他数据信息。图11展示了一个batch命令示例。
图11：POWRUNER C2 服务器发送的Batch命令
###  3.6 POWRUNER / BONDUPDATER在其他攻击中的应用
APT34早在2017年7月针对中东组织的攻击中，就已经开始使用POWRUNER和BONDUPDATER。在当时，FireEye Web
MPS设备阻止了一个安装带有APT34 POWRUNER / BONDUPDATER