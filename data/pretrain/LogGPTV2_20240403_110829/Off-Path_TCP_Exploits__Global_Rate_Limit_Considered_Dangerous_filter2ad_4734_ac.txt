ACK this time is stored as n2. If n2 equals 100, the syn-
chronization is done. Otherwise, the attacker proceeds to
round 3.
Round 3: By comparing n1 with n2, the attacker can
determine the ﬁnal move to be synchronized. Specif-
ically, we provide the following reasoning to support
the decision. Assume that in step 1, x RST packets
arrive in the ﬁrst 1-second interval on the server, and
y RST packets arrive in the second 1-second interval;
note that x + y = 200. Similarly, in step 2, there are
(x − 1) and (y + 1) RST packets arrive in the ﬁrst and
second 1-second intervals respectively, since in step 2
the attacker time shifts its probes by a period of 1 sub-
interval. Thus, n1 = min(x,100) + min(y,100) and n2 =
min(x− 1,100) +min(y + 1,100).
(i) If n2 ≥ n1: Let us assume that y ≥ 100 and x ≤ 100;
then n1 = min(x,100) +min(y,100) = x + 100, and n2 =
min(x− 1,100) +min(y + 1,100) = (x− 1) +100  100. With these conditions, n2 = 100 + (y +
1) =100 +(200−x +1), or (x−1) =300 −n2. In step 2,
(x− 1) RST packets arrive in the ﬁrst 1-second interval
on the server; thus, the attacker has to wait for (x − 1)
sub-intervals, i.e., (300−n2). 1
200 seconds to synchronize
her time interval with the server.
(ii) If n2  100.
In this case, n2 =
(x − 1) + 100; thus, the attacker has to wait (n2 − 100)
sub-intervals, or n2−100
seconds to synchronize her time
200
interval with the server.
If no packet loss occurs (which is likely due to the
small number of packets sent every second), then the
three rounds are enough to complete the synchronization
process. To handle the rare event that packet loss may
occur, we double check that the synchronization was suc-
cessful by sending another round of 200 RST packets. If
it is inconsistent with the previous round, we start over.
As will be discussed later, such cases were almost never
seen in our experiments.
214  25th USENIX Security Symposium 
USENIX Association
6
Algorithm 1: Binary search for source port number
mid = (le f t + right)/2
for i = mid to right do
1: le f t = left boundary of the port range
2: right = right boundary of the port range
3: while le f t . The above assumes both the
client and server IP addresses are known. In addition,
the server port is assumed to be publicly known accord-
ing to its service type. Therefore, the only unknown is
the source port the client uses. The maximum possible
port range is 216 = 65536, and the default range on Linux
is only from 32768 to 61000.
A naive approach is to test each port number at a time
per second, as depicted in Figure 4, which, in the worst
case, requires hours to complete. Therefore, a practical
attack requires the attacker to test several port numbers in
a second. Let us denote the maximum number of spoofed
packets that can be sent in one second by n (constrained
by network bandwidth). If n is large, one can search for
the port number using a binary-search-like algorithm, the
pseudo-code of which is shown in Algorithm 1. Speciﬁ-
cally, assuming n is larger than 32767, in the ﬁrst round
the attacker can test the port range from 32768 to 65535
(the most likely half) in a 1-second interval. If the actual
port number falls in the range, then the challenge ACK
observed by the attacker at the end of the interval will
if (!tcp_sequence(tp, TCP_SKB_CB(skb)->seq,
(cid:28)→ TCP_SKB_CB(skb)->end_seq)) {
...
goto discard;
}
if (th->rst) {
if (TCP_SKB_CB(skb)->seq == tp->rcv_nxt
(cid:28)→ )
tcp_reset(sk);
else
tcp_send_challenge_ack(sk, skb)
goto discard;
(cid:28)→ ;
}
Figure 7: Logic of handling an incoming packet with RST ﬂag
in latest Linux kernels
be 99 (one goes to the victim). If the actual port number
does not fall in this range, the observed number of chal-
lenge ACKs will be 100. In either case, the attacker can
narrow down the search space by half and proceed to the
next round of search.
An even better strategy is to divide the search space
into multiple bins and probe them together in the same
round. That way, one can eliminate n−1
n of the search
space. A similar multi-bin search strategy is used for
sequence number inference in (§4.3).
In cases where n is smaller than 32767 (due to band-
width constraints), the best the attacker can do is to sim-
ply try as many port numbers as possible in each round.
The binary search or multi-bin search can be applied later
when the search space becomes small enough.
4.3 Sequence Number Inference
As discussed in §2.2, the receiver generates a challenge
ACK in response to a RST packet that contains an in-
window sequence number which does not match exactly
the expected value. The related Linux kernel code is
shown in Figure 7; the tcp sequence() function re-
turns true if the sequence number is in-window, and false
if it is out-of-window. In the latter case, the packet will
simply be dropped. When the sequence number is in-
window and the packet has the RST ﬂag set, its sequence
number is analyzed further. As we can see, the con-
nection is terminated only when the sequence number
matches RCV.NXT ; otherwise, a challenge ACK is sent.
The main difference between port number inference
and sequence number inference is that the attacker does
not need to check every possible sequence number to
trigger a challenge ACK. Therefore, the attacker can
divide the sequence number space into blocks whose
sizes are equal to the receive window size, and probe
with a guessed sequence number in each block to de-
termine which sequence numbers fall in the receive win-
dow. Theoretically, an attacker can apply the same binary
USENIX Association  
25th USENIX Security Symposium  215
7
1
2G
2G
# of packets:
…...
1
WIN
1
(          )
1
1
(RCV.NXT,   RCV.NXT+WIN)
# of packets:
1
1
(a). First  iteration
1…
1
(          )
3G
(RCV.NXT,   RCV.NXT+WIN)
(b). Second  iteration
4G
4G
# of packets:
1
1
Chunk
start
Bin 1
2
…
2 … 3
)
(
Bin 2
WIN
Bin 3
3
…
Bin 4
Chunk
end
(a). Locating the in-window block
1
1
1
(
Block
start
Bin 1
Bin 4
(b). Locating the left boundary of the window
Bin 3
Bin 2
)
Block
end
Figure 8: Binary search for sequence number illustration
Figure 9: Multi-bin search for sequence number illustration
search algorithm used in connection inference. This pro-
cess is illustrated in Figure 8. In the ﬁrst round of prob-
ing, the attacker can probe the right half of the sequence
number space — (2G, 4G). If any of the spoofed RST
packets triggers a challenge ACK, the attacker will ob-
serve less than 100 challenge ACKs at the end of the 1-
second interval. If there are exactly 100 challenge ACKs
observed, it indicates that the receive window is on the
left side of the search space. In either case, in the second
round, the attacker knows “which half the receive win-
dow belongs to.” Let us say that the receive window is in
the right half. The attacker would then divide the search
space of (2G, 4G) into (2G, 3G) and (3G, 4G). Similar to
the ﬁrst round, only (3G, 4G) needs to be probed in order
to determine the part that contains the receive window.
This search will eventually stop after 32 rounds exactly
(because the sequence number is 32-bit).
However, in practice, the sequence number search
space is signiﬁcantly larger than port number space. Let
us consider a receive window size of 12600. This leaves
the attacker 340870 possible blocks to search through.
If the attacker were to transmit this many packets in
one second, the bandwidth requirement would be around
150Mbps, which is extremely high. Likely, the attacker
will have to perform a linear search by attempting to
search as many blocks as allowed by bandwidth in one
second.
Dealing with unknown window sizes: Ideally, the
block size should be determined by the window size of
the target connection, i.e., the server’s receive window
size. In reality, however, an off-path attacker cannot ob-
serve the window size. If the attacker chooses a smaller
window size (compared to the actual window size), the
attack will send more packets unnecessarily and take
more time. On the other hand, if the guessed value is
larger than the actual value, the attacker might miss the
correct window of sequence numbers while traversing
consecutive blocks. Thus, there is an inherent trade-off
between the success rate and the cost incurred (in terms
of time and bandwidth) of the attack. Even if the attacker
can come up with a correct receive window size at one
particular time, the size can change over time.
Our solution is to use a conservative estimate of the
window size as the block size in the beginning and up-
date it later given proper feedback. The conservative
window size is determined by the initial window size
advertised by the server in the SYN-ACK packet. By
surveying Alexa top 100 websites, we ﬁnd that the aver-
age initial receive window size is 26703. This window
size is the lower bound as the window typically grows
after the connection is established. To observe the initial
window size, the attacker simply attempts to establish
a valid (non-spoofed) TCP connection with the server.
This strategy works because a server typically uses the
same initial receive window size for all clients. Such a
conservative estimate of window size may force the at-
tacker to send more packets, but it at least will guarantee
success. We will also discuss how to update the window
size dynamically during the search process.
Next, we elaborate the design of sequence number in-
ference:
• Step 1 – Identify the approximate sequence
number range. Let us assume that the attacker, in n
blocks, can send n spoofed packets per second (n is on
the order of thousands in our experiments). We call such
n consecutive blocks a chunk. The guessed sequence
number is always chosen to be the ﬁrst sequence number
within a block. If at the end of the 1-second interval, the
attacker observes 100 challenge ACKs, then the attacker
proceeds to the next chunk, i.e., the next n consecutive
blocks. If the attacker observes less than 100 challenge
ACKs, it indicates that the receive window is within the
chunk that was just probed. The attack can now proceed
to step 2. Note that if the number of observed challenge
ACKs is less than 99, it indicates that the initially esti-
mated window size (block size) is too small.
For example, as illustrated in Figure 10(a), if there are
two blocks whose beginning sequence numbers are in-
side the actual receive window, then the number of ob-
served challenge ACKs will be 98; this indicates that
the actual window size should be approximately twice
the estimated window size (initial block size). We there-
216  25th USENIX Security Symposium 
USENIX Association
8
1
1
# of packets:
Block size
…...
1
Block size
(                                )
(RCV.NXT,   RCV.NXT+WIN)
(a) Initial block size (conservative estimate of window size)
1
# of packets:
…...
1
1
New block size
(                                )
(RCV.NXT,   RCV.NXT+WIN)
(b) Updated block size (one possible outcome)
# of packets:
…...
1
1
New block size
(                                )
(RCV.NXT,   RCV.NXT+WIN)
(c) Updated block size (the other possible outcome)
Figure 10: Window size estimate and adjustment
fore update the block size to be twice as much in the
subsequent search steps. The two possible outcomes are
shown in Figure 10(b) and Figure 10(c).