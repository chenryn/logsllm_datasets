During my testing of various methods to compute a quantity over an array, I observed a significant performance degradation when using for loops starting from commit `317a4d1` (which is 16 days old in the master branch). @timholy recommended that I report this issue.

The test code can be found at: [https://github.com/JaredCrean2/julia_tests/tree/master/array_speed2](https://github.com/JaredCrean2/julia_tests/tree/master/array_speed2). The code evaluates the computation using three different approaches: a manually inlined double for loop, ArrayViews, and SubArrays.

Here are the benchmark results for two different versions of Julia:

### Julia Version 0.4.0-dev+5149 (2015-06-01 18:58 UTC) - Commit `317a4d1` (16 days old master)
- **Double Loop**: 592.426 milliseconds (14,232 allocations: 586 KB)
- **ArrayView**: 495.138 milliseconds (14,422 allocations: 599 KB)
- **SubArray (slice)**: 15.753 seconds (300 M allocations: 8,240 MB, 3.39% gc time)

### Julia Version 0.4.0-dev+5439 (2015-06-18 13:48 UTC) - Commit `a23caa0` (0 days old master)
- **Double Loop**: 1.720 seconds (102 k allocations: 3,600 KB)
- **ArrayView**: 566.122 milliseconds (16,237 allocations: 692 KB)
- **SubArray (slice)**: 4.137 seconds (240 M allocations: 8,240 MB, 12.96% gc time)

Upon further investigation, I used `@code_warntype getEulerFlux(q, F)` to compare the generated code between the two commits. The code generated by `a23caa0` was significantly larger, with over 1,100 lines, compared to the approximately 70 lines generated by `317a4d1`. Additionally, the `a23caa0` version included many lines of code that were not present in `317a4d1`, such as:
```julia
(top(throw_boundserror))(q::Array{Float64,3}, GenSym(45))::Union{}
```

These additional lines and the increased code size may be contributing to the performance degradation.