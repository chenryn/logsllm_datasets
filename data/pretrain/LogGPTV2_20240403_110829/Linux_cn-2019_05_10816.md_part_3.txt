但这是在给内部状态引入新的熵，这和阻塞输出没有任何关系。
### random 和 urandom 的 man 页面
这两个 man 页面在吓唬程序员方面很有建树：
> 
> 从 `/dev/urandom` 读取数据不会因为需要更多熵而阻塞。这样的结果是，如果熵池里没有足够多的熵，取决于驱动使用的算法，返回的数值在理论上有被密码学攻击的可能性。发动这样攻击的步骤并没有出现在任何公开文献当中，但这样的攻击从理论上讲是可能存在的。如果你的应用担心这类情况，你应该使用 `/dev/random`。
> 
> 
> 
> > 
> > 实际上已经有 `/dev/random` 和 `/dev/urandom` 的 Linux 内核 man 页面的更新版本。不幸的是，随便一个网络搜索出现我在结果顶部的仍然是旧的、有缺陷的版本。此外，许多 Linux 发行版仍在发布旧的 man 页面。所以不幸的是，这一节需要在这篇文章中保留更长的时间。我很期待删除这一节！
> > 
> > 
> > 
> 
> 
> 
没有“公开的文献”描述，但是 NSA 的小卖部里肯定卖这种攻击手段是吧？如果你真的真的很担心（你应该很担心），那就用 `/dev/random` 然后所有问题都没了？
然而事实是，可能某个什么情报局有这种攻击，或者某个什么邪恶黑客组织找到了方法。但如果我们就直接假设这种攻击一定存在也是不合理的。
而且就算你想给自己一个安心，我要给你泼个冷水：AES、SHA-3 或者其它什么常见的加密算法也没有“公开文献记述”的攻击手段。难道你也不用这几个加密算法了？这显然是可笑的。
我们在回到 man 页面说：“使用 `/dev/random`”。我们已经知道了，虽然 `/dev/urandom` 不阻塞，但是它的随机数和 `/dev/random` 都是从同一个 CSPRNG 里来的。
如果你真的需要信息论安全性的随机数（你不需要的，相信我），那才有可能成为唯一一个你需要等足够熵进入 CSPRNG 的理由。而且你也不能用 `/dev/random`。
man 页面有毒，就这样。但至少它还稍稍挽回了一下自己：
> 
> 如果你不确定该用 `/dev/random` 还是 `/dev/urandom` ，那你可能应该用后者。通常来说，除了需要长期使用的 GPG/SSL/SSH 密钥以外，你总该使用`/dev/urandom` 。
> 
> 
> 
> > 
> > 该手册页的[当前更新版本](http://man7.org/linux/man-pages/man4/random.4.html)毫不含糊地说：
> > 
> > 
> > `/dev/random` 接口被认为是遗留接口，并且 `/dev/urandom` 在所有用例中都是首选和足够的，除了在启动早期需要随机性的应用程序；对于这些应用程序，必须替代使用 `getrandom(2)`，因为它将阻塞，直到熵池初始化完成。
> > 
> > 
> > 
> 
> 
> 
行。我觉得没必要，但如果你真的要用 `/dev/random` 来生成 “长期使用的密钥”，用就是了也没人拦着！你可能需要等几秒钟或者敲几下键盘来增加熵，但这没什么问题。
但求求你们，不要就因为“你想更安全点”就让连个邮件服务器要挂起半天。
### 正道
本篇文章里的观点显然在互联网上是“小众”的。但如果问一个真正的密码学家，你很难找到一个认同阻塞 `/dev/random` 的人。
比如我们看看 [Daniel Bernstein](http://www.mail-archive.com/PI:EMAIL/msg04763.html)（即著名的 djb）的看法：
> 
> 我们密码学家对这种胡乱迷信行为表示不负责。你想想，写 `/dev/random` man 页面的人好像同时相信：
> 
> 
> * (1) 我们不知道如何用一个 256 位长的 `/dev/random` 的输出来生成一个无限长的随机密钥串流（这是我们需要 `/dev/urandom` 吐出来的），但与此同时
> * (2) 我们却知道怎么用单个密钥来加密一条消息（这是 SSL，PGP 之类干的事情）
> 
> 
> 对密码学家来说这甚至都不好笑了
> 
> 
> 
或者 [Thomas Pornin](http://security.stackexchange.com/questions/3936/is-a-rand-from-dev-urandom-secure-for-a-login-key/3939#3939) 的看法，他也是我在 stackexchange 上见过最乐于助人的一位：
> 
> 简单来说，是的。展开说，答案还是一样。`/dev/urandom` 生成的数据可以说和真随机完全无法区分，至少在现有科技水平下。使用比 `/dev/urandom` “更好的“随机性毫无意义，除非你在使用极为罕见的“信息论安全”的加密算法。这肯定不是你的情况，不然你早就说了。
> 
> 
> urandom 的 man 页面多多少少有些误导人，或者干脆可以说是错的——特别是当它说 `/dev/urandom` 会“用完熵”以及 “`/dev/random` 是更好的”那几句话；
> 
> 
> 
或者 [Thomas Ptacek](http://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/) 的看法，他不设计密码算法或者密码学系统，但他是一家名声在外的安全咨询公司的创始人，这家公司负责很多渗透和破解烂密码学算法的测试：
> 
> 用 urandom。用 urandom。用 urandom。用 urandom。用 urandom。
> 
> 
> 
### 没有完美
`/dev/urandom` 不是完美的，问题分两层：
在 Linux 上，不像 FreeBSD，`/dev/urandom` 永远不阻塞。记得安全性取决于某个最一开始决定的随机性？种子？
Linux 的 `/dev/urandom` 会很乐意给你吐点不怎么随机的随机数，甚至在内核有机会收集一丁点熵之前。什么时候有这种情况？当你系统刚刚启动的时候。
FreeBSD 的行为更正确点：`/dev/random` 和 `/dev/urandom` 是一样的，在系统启动的时候 `/dev/random` 会阻塞到有足够的熵为止，然后它们都再也不阻塞了。
> 
> 与此同时 Linux 实行了一个新的 系统调用   syscall ，最早由 OpenBSD 引入叫 `getentrypy(2)`，在 Linux 下这个叫 `getrandom(2)`。这个系统调用有着上述正确的行为：阻塞到有足够的熵为止，然后再也不阻塞了。当然，这是个系统调用，而不是一个字节设备（LCTT 译注：不在 `/dev/` 下），所以它在 shell 或者别的脚本语言里没那么容易获取。这个系统调用 自 Linux 3.17 起存在。
> 
> 
> 
在 Linux 上其实这个问题不太大，因为 Linux 发行版会在启动的过程中保存一点随机数（这发生在已经有一些熵之后，因为启动程序不会在按下电源的一瞬间就开始运行）到一个种子文件中，以便系统下次启动的时候读取。所以每次启动的时候系统都会从上一次会话里带一点随机性过来。
显然这比不上在关机脚本里写入一些随机种子，因为这样的显然就有更多熵可以操作了。但这样做显而易见的好处就是它不用关心系统是不是正确关机了，比如可能你系统崩溃了。
而且这种做法在你真正第一次启动系统的时候也没法帮你随机，不过好在 Linux 系统安装程序一般会保存一个种子文件，所以基本上问题不大。
虚拟机是另外一层问题。因为用户喜欢克隆它们，或者恢复到某个之前的状态。这种情况下那个种子文件就帮不到你了。
但解决方案依然和用 `/dev/random` 没关系，而是你应该正确的给每个克隆或者恢复的镜像重新生成种子文件。
### 太长不看
别问，问就是用 `/dev/urandom` !
---
via: 
作者：[Thomas Hühn](https://www.2uo.de/) 译者：[Moelf](https://github.com/Moelf) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出