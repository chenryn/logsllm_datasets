of Π1 and Π2.
• Party activation for session initiation and message re-
ceiving/sending: This is same in Π1 and Π2 except for
the CSM message sent by C upon receiving the last
message from S (in case C sends the last message in
Π1 then CSM is sent immediately after this last mes-
sage).
• Party corruption: In both cases this includes reveal-
ing to the attacker all secret material of the corrupted
party (and subsequent full control of that party by the
attacker). Note that in the case of Π2, client corrup-
tion includes revealing the signing key of C.
• Reveal queries: This can be applied to any completed
session (other than the test session) at a honest party
and returns the session key (note that the timing of
completion for S may be diﬀerent in Π1 and Π2).
• Session tests:
In Π1 session tests are only allowed
against (C, S, sid) while in Π2 they are also allowed
against (S, C, sid).
5.1 The simulator
For the proof of Theorem 3 we specify a simulator that
given an MA-attacker A2 against protocol Π2 it deﬁnes a
UA-attacker A1 against Π1 such that if Π2 wins a test ses-
sion in Π2 so does A1 in Π1. The simulator SIM acts as
the challenger (i.e., the orchestrator of the protocol run) for
a given MA-attacker A2 against protocol Π2 and uses A2
actions to implement the UA-attacker A1 against Π1. We
think of the parties running Π1 as real parties, with their
own secret keys, and those running Π2 as simulated by SIM
with the same keys as in Π1 except for clients’ signature keys
(that exist in Π2 but not in Π1). The latter are chosen by
SIM for honest clients in Π2 while public keys for corrupted
parties are chosen by the attacker.
SIM implements the CSM message in Π2 as follows. Upon
completion of a session (C, S, sid) by a client C in Π1, SIM
invokes A1 to run a reveal query on that session to obtain
1444the corresponding session key K. From it, SIM derives keys
Ka and Ks, and uses Ka and the signature key of C to com-
pute the CSM message that it hands to A2. Completion of
sessions by honest parties in Π2 is decided by SIM. In the
case of a client, a session is completed if and only if the cor-
responding session completes in Π1. Completion of a session
(S, C, sid) at a honest server in Π2 depends on receiving a
valid CSM message, namely with a valid signature on sid∗
and the MAC under Ka. If this message is not originated
with a honest client (e.g., it is sent by a corrupted client)
then SIM veriﬁes it by invoking A1 to reveal the correspond-
ing completed server’s session (S, sid) in Π1 and deriving Ka
from it. The validity of this action follows from Lemma 4
(c).
The actions of A1 as decided by SIM mostly mimic those
of A2 with some important diﬀerences in the handling of the
corrupt, reveal and test queries that we specify next. After
each action we argue informally the validity of the action
(showing that the attackers’ actions and views are consistent
with the protocol and the attack model). The formal proof
of validity follows from Lemma 4 below. Throughout, we
say that keys Ka, Ks in a session in Π2 are consistent with a
session key K in Π1 if Ka, Ks are derived from K using the
KDF function.
1. When A2 corrupts a party, SIM invokes A1 to do the
same. A2 receives the secret information from this
party as received by A1 and, in the case of clients, it
receives from SIM the party’s signature key.
2. When A2 reveals a session (C, S, sid) at honest client
C in Π2, SIM invokes A1 to reveal (C, S, sid) in Π1;
A1 is handed the session key K from Π1 while A2 is
handed the derived session key Ks from Π2.
• Validity (Lemma 4 (b)): We use the fact that
these two sessions exist and complete together
and have consistent keys.
3. When A2 reveals a session (S, C, sid) at honest server
S in Π2, SIM invokes A1 to reveal session (S, sid) in
Π1; A1 is handed session key K while A2 is handed
the derived key Ks.
• Validity (Lemma 4 (c)): We use the fact that if S
is honest and session (S, C, sid) completes in Π2
then session (S, sid) exists and completed in Π1,
and the two sessions have consistent keys.
4. The processing of the Test query and test sessions is
handled by SIM as follows. At the onset of the protocol
run, SIM selects a random session, called the guess ses-
sion, from all sessions to be created during the run of
protocol Π2 under A2 (this assumes an a-priori bound
on the number of sessions to be created by A2).
If
at any point, A2 issues an action that disqualiﬁes the
guess session as a test session, SIM instructs A1 to
output a random bit b and aborts. The guess session
may be at a client or server:
(a) If the session is at a client, call it (C, S, sid), then
as soon as A2 delivers the last incoming message
to this session (from server S), SIM invokes A1
to deliver this last message (which, if the guess
session is correct, results in C completing) and to
issue a Test query on (C, S, sid) in Π1.
(b) If the session is at a server, call it (S, C, sid), then
as soon as A2 delivers the last message from S
to session (C, S, sid), SIM invokes A1 to deliver
this last message and to issue a Test query on
(C, S, sid) in Π1.
In both cases SIM learns from A1 the value of the
real-or-random key K returned by the Test query in
Π1. SIM derives from K keys Ka and Ks and uses
Ka to compute the outgoing CSM message from C in
Π2 and for checking the validity of a CSM message
delivered by A2 to session (S, C, sid). When A2 issues
a Test query against the guess session (at C or S), SIM
provides Ks as the answer to that query.
• Validity: We will show that the test sessions in-
voked by A1 are valid test sessions under A1’s
run and that Ks is real if K is real and (pseudo)
random otherwise. See Lemma 4 (f).
5. When A2 stops its run with an output bit b, SIM in-
structs A1 to stop with the same bit.
• We need to show that A1 wins whenever A2 wins,
hence proving that the advantage of A2 against
Π2 is bounded (up to a polynomial factor induced
by the probability of a correct test session guess)
by the advantage of A1 against Π1.
5.2 Validity of SIM’s actions
The proof of Theorem 3 uses the following properties of
the simulator’s actions and those induced on attacker A1,
in particular showing the validity of these actions in the
corresponding models.
Lemma 4. The following properties hold based on the sim-
ulation actions.
(a) Π1 and Π2 as run under A1 and A2, respectively, have
the same set of parties, including the same honest and
same corrupted parties.
(b) If C is honest, then when a session (C, S, sid) com-
pletes in Π2, a session (C, S, sid) exists and has com-
pleted in Π1; in particular, the two sessions have con-
sistent session keys.
(c) If S is honest, if a session (S, C, sid) completes in Π2
then session (S, sid) exists and has completed in Π1;
in particular, the two sessions have consistent session
keys.
(d) If (C, S, sid) is a valid test session chosen by A2 in
Π2 then, except for negligible probability, (C, S, sid) is
fresh in Π1 and (by part (b)) the two sessions have
consistent session keys.
(e) Assuming Π1 is treplication-secure, if session (S, C, sid)
is a valid test session chosen by A2 in Π2, then, ex-
cept for negligible probability, session (C, S, sid) exists,
completes and is fresh in Π1 and both sessions have
consistent session keys.
(f ) If the test session chosen by A2 in Π2 is a valid test
session and SIM guessed this session correctly then,
except for negligible probability, the test session chosen
1445by SIM is a valid test session under A1’s run, and if
the key K returned to A1 is real (resp. random) then
Ks is real (resp. pseudo-random).
The next two lemmas, needed to complete the proof of
Lemma 4 (parts (d) and (e)) and Theorem 3, show, respec-
tively, the need to include the identities C and S under the
CSM MAC.
Lemma 5. If C and S are honest, session (C, S, sid) is
complete and unrevealed in Π1, and session (S, sid) is com-
plete in Π1, then in Π2 either S does not complete session
sid or, if it does, it completes it as (S, C, sid) (except for a
negligible probability).
Lemma 6. If Π1 is treplication-secure and (S, C, sid) is
fresh in Π2 then, except for negligible probability, (C, S, sid)
exists and completes in Π2.
5.3 Proof of Theorem 3
Consider simulation executions where SIM does not abort
(i.e., SIM guesses correctly the test session) and in which the
negligible probability events from the proofs of Lemmas 5
and 6 do not happen.
In this case, Lemma 4 shows the
validity of the actions of both adversaries, A1 and A2, as
set by the simulator actions, and their consistency with the
UA and MA models, respectively. In particular, the views of
A1 and A2 under the simulated games are exactly as those
of a real run of protocols Π1 and Π2, respectively. Thus,
the winning probability of A2 is the same as in a real run of
protocol Π2 and by Lemma 4 (part f) A1 wins its test session
whenever A2 does. We conclude that the winning advantage
of A2 is upper bounded by that of A1. In all, we have that
if m is an upper bound on the number of sessions initiated
by A2, then the winning advantage of A2 against Π2 is at
most m times the winning advantage of A1 against Π1 plus
a negligible fraction. Hence, if any UA-attacker A1 against
Π1 has only negligible advantage, then so is the case for any
MA-attacker A2 against Π2. This completes the proof of
MA-security of the compiled protocol Π2.
Note on security quantiﬁcation. The proofs of Lem-
mas 5 and 6 show events where the selection of a test session
for A1 fails due to some adversarial action. The lemmas
show these events to have negligible probability. An exam-
ination of the proof shows this probability to be at most
2 · (n · sig + mac + kdf ) + U A + tr + nc where the  val-
ues denote the security of various elements in the protocol:
the unforgeability of the signature and MAC schemes used
in SIGMAC, the pseudorandomness of the KDF, the UA-
security of protocol Π1, and the treplication security of Π1
(these bounds represent the attackers’ advantage for a given
time bound); nc bounds the probability of nonce collision
among honest clients and n bounds the number of clients
(the latter is needed in the client’s signature-forging reduc-
tion for which one needs to guess the client in the test session
in order to embed the attacked signature key). The above
expression is further multiplied by factor m (denoting an
upper bound on the number of sessions established by ad-
versary A2 running against Π2) to account for the probabil-
ity 1/m that SIM does not abort its run, namely, it guesses
correctly the session that A2 will choose as its test session.6
6This may result in a m·n factor multiplying sig but in this
case one can set m to be the maximal number of sessions
Streamlining the reduction. The above bound contains
the additive term m · U A where U A bounds the advan-
It is likely
tage of the UA-attacker against protocol Π1.
that the bound U A resulting from the analysis of a partic-
ular protocol Π1 already contains a factor of m equal to the
number of sessions, in which case m · U A contains a factor
m2. The following analysis strategy avoids this unnecessary
squared degradation. We consider a “semi-adaptive” adver-
sarial model, for both the UA and MA settings, where the
attacker has to declare its choice of test session as soon as
the session is initiated. In this setting, SIM does not need
to guess A2’s test session but it rather learns the session
when A2 initiates (and declares) it. At this point, SIM in-
structs the semi-adaptive A1 to declare the choice of the
corresponding test session in Π1. Everything else stays the
same as in the current simulation and proof except that here
the reduction is between semi-adaptive UA and MA attack-
ers without incurring the loss of the m factor. This factor
only comes once through a generic reduction from a regular
(adaptive) attacker to a semi-adaptive one. In this generic
reduction the regular attacker acts semi-adaptive by choos-
ing the test session at random among all m sessions and
declaring it upon initiation - hence incurring a (one-time) m
factor advantage degradation.
Note on signing S and C.
Inspection of the proof of
Lemma 6 shows that if the server’s identity S is included
under sid∗, i.e., signed by the client, then there is no need to
include that identity under the MAC or to resort to trepli-
cation security. Yet, our results show that if signing this
identity is omitted (for privacy reasons or simply because
the identity is not part of the signed transcript - as in the
resumption mode of TLS 1.3) its inclusion under the MAC
is suﬃcient. As for the client’s identity, we note that includ-
ing this identity under the client’s signature but not under
a MAC would fail to provide MA security.
6. POST-HANDSHAKE AND ENCRYPTED
AUTHENTICATION
In this section we adapt the analysis of the SIGMAC com-
piler to some speciﬁc settings arising in the ongoing speciﬁ-
cation of TLS 1.3 [33]. We also introduce the functional CK
model which may be of independent interest.
The SIGMAC compiler as analyzed in previous sections
can be readily applied in the context of TLS 1.3 in the case
that the client sends its authentication message (the signa-
ture and Finished message, or CSM in our terminology7)
in the third handshake ﬂight, i.e., immediately upon ver-
iﬁcation of server authentication. However, TLS 1.3 also