### Python Script for Running Malware Sample and Collecting Data

```python
import time
import machine
import disk_tap
import button_clicker

# Constants
OS_BOOT_WAIT = 30  # Time to wait for OS to boot
MALWARE_START_TIME = 10  # Time to allow malware to start
MALWARE_EXECUTION_TIME = 180  # Total execution time for malware (3 minutes)

# Reset the machine using PXE
machine.machine_reset()
machine.power_on()

# Wait for the network to be available
while not machine.network_get():
    time.sleep(1)

# Allow time for the OS to continue loading
time.sleep(OS_BOOT_WAIT)

# Start the disk tap
disk_tap.start()

# Send key presses to initiate the FTP script
machine.key_press('SPECIAL:RETURN')

# Dump memory (clean)
machine.memory_dump('memory_file_clean')

# Start the network tap
network_tap.start()

# Update the list of visible buttons
button_clicker.update_buttons()

# Start the binary and click any buttons
machine.key_press('SPECIAL:RETURN')
button_clicker.click_buttons(new_only=True)

# Move the mouse to imitate human interaction
machine.mouse_wiggle(True)

# Allow the binary to execute (initial)
time.sleep(MALWARE_START_TIME)

# Dump memory (interim)
machine.memory_dump('memory_file_interim')

# Take a screenshot
machine.screenshot('screenshot_one')

# Click any new buttons
button_clicker.click_buttons(new_only=True)

# Allow the binary to execute (total 3 minutes)
time.sleep(MALWARE_EXECUTION_TIME - elapsed_time)

# Take a final screenshot
machine.screenshot('screenshot_two')

# Dump memory (dirty)
machine.memory_dump('memory_file_dirty')

# Shutdown the machine
machine.power_shutdown()
```

### Fig. 3: Python Script for Running a Malware Sample and Collecting the Appropriate Raw Data for Analysis

Our framework allows us to write a single, straightforward script (see Figure 3) that performs the following tasks:
1. Resets the machine to a clean state.
2. Takes memory images before and after execution.
3. Attempts to click any graphical buttons.
4. Captures screenshots.
5. Captures all disk and network activity throughout the execution.

To download and execute an arbitrary binary (Figure 3, line 12), our implementation uses hotkeys to open a command-line interface, executes a recursive FTP download to retrieve the files to be analyzed, and then runs a batch file to execute the binary. This process helps in reconstructing the changes in system memory, as well as capturing complete disk and network activity generated by the binary.

To identify any graphical buttons that the malware may present, we use the Volatility "windows" module to identify all visible windows with an atom class of 0xc061 or an atom superclass of 0xc017, which indicate a button. We then use our actuator to move the mouse to the appropriate location and click it. Our analysis framework also attempts to remove typical analysis-based artifacts by using a random file name and continuously moving the mouse during the binary's execution. When possible, i.e., when the system is not hung, we properly shut down the system at the end of the analysis to force any cached disk activity to be flushed.

### Analysis Setup

Both the physical and virtual environments had a 10 GB partition for the operating system and 1 GB of volatile memory. The operating system was placed into a "hibernate" state to minimize variance between executions and reduce the boot time. To minimize storage requirements, we compress our memory images before storing them in our databases, which adds approximately 2 minutes to the analysis but significantly reduces storage needs. The virtual machine's networks were logically divided to ensure that samples did not interfere with each other, and the physical environment consisted of only one machine.

### Execution Runtimes

The respective runtimes for each portion of our analysis can be seen in Figure 4. We ensured that every binary executed for at least 3 minutes before retrieving the final memory image and resetting the system. Screenshots were obtained using Volatility's screenshot module on physical machines and extracted from the captured memory images. Most of the time taken in the physical case is due to resetting the system state using Clonezilla, waiting for the system to boot, and memory acquisition. These times could be reduced by writing a custom PXE loader or implementing copy-on-write into our FPGA. Similarly, optimizing our PCIe implementation could make memory acquisition times more comparable to the virtual case. System snapshots could further reduce the setup time to mere seconds, though this is still an open problem for physical machines.

### LO-PHI Limitations

LO-PHI may miss temporal memory modifications made by the binary between the clean and dirty memory images. To analyze transient behavior, LO-PHI could continuously poll the system's memory during execution, but this would produce DMA artifacts and may not be practical with current polling rates. Future research will focus on improving memory capture capabilities.

### Evaluation and Analysis

#### Methodology for Semantic Gap Reconstruction

Before conducting any analysis, we must bridge the semantic gap, translating low-level, raw data into high-level, semantically-rich information. This involves:
1. **Memory**: Using Volatility plugins to extract operating-system-level modifications from both clean and dirty memory snapshots.
2. **Disk**: Converting raw SATA captures into disk operations and reconstructing disk events using Sleuthkit and PyTSK.

#### Targeted Experiments

We conducted three experiments to demonstrate:
1. The ability of LO-PHI to detect behaviors elicited by real malware, confirmed with ground truth.
2. The ability to scale and extract meaningful results from unknown malware samples.
3. The ability to analyze malware samples employing anti-analysis and evasion techniques.

For each binary, we determine the system changes by forensically comparing the resulting clean and dirty states. Each dataset contains a clean and dirty raw memory snapshot and a log of raw disk and network activity. We exclude network trace analysis from much of our discussion since it is a well-known technique. Our analysis involves four steps:
1. Bridging the semantic gap for both clean and dirty states.
2. Computing the delta between the two states.
3. Filtering out actions not attributed to the binary.
4. Comparing the delta for physical and virtual execution to determine if the sample employs VM-detection techniques.

#### Semantic Gap Reconstruction

**Memory**: We use Volatility plugins such as `psscan`, `ldrmodules`, `modscan`, and `sockets` to parse kernel structures and objects. Malware-focused plugins like `idt`, `gdt`, `ssdt`, `svcscan`, and `callbacks` examine kernel descriptor tables, registered services, and kernel callbacks.

**Disk**: We convert raw SATA captures into disk operations and reconstruct disk events using Sleuthkit and PyTSK. Our SATA reconstruction module models the SATA protocol to track and restore the semantic ordering of FIS packets, translating them into disk events.

### Example Output

Below is an example output from creating the file `LO-PHI.txt` on the desktop:

| Filename | Allocated | Modified | Accessed | Changed | Created | Size |
|----------|-----------|----------|----------|---------|---------|------|
| /.../Desktop/New Text Document.txt | 0 → 1 | 2014-11-07 20:07:06 → 2015-02-19 15:47:17 | 2014-11-07 20:07:06 → 2015-02-19 15:47:17 | 2014-11-07 20:07:06 → 2015-02-19 15:47:17 | 132 → 0 | ... |
| /.../Desktop/LO-PHI.txt | 2015-02-19 15:47:17 → 2015-02-19 15:47:25 | ... |

This output shows that the filesystem reused an old MFT entry for `drivetable.txt` and updated the filename, allocation flags, size, and timestamps upon file creation. A subsequent filename and timestamp update were observed once the new filename, `LO-PHI.txt`, was entered.

### Conclusion

Our framework, LO-PHI, provides a comprehensive approach to analyzing malware by capturing and reconstructing system state changes. Future work will focus on improving memory capture capabilities and reducing analysis times.