t i m e . s l e e p ( 1 )
c a p t u r e
t h a t appeared
s e n d ( f t p s c r i p t )
c u r r e n t
v i s i b l e b u t t o n s
c o l l e c t i o n n e t w o r k
t r a f f i c
f o r OS t o c o n t i n u e
l o a d i n g
t o download b i n a r y
f o r OS t o appear on n e t w o r k
1 # R e s e t our d i s k u s i n g PXE
2 machine . m a c h i n e r e s e t ( )
3 machine . power on ( )
4 # Wait
5 while not machine . n e t w o r k g e t
6
7 # Allow t i m e
8 t i m e . s l e e p (OS BOOT WAIT)
9 # S t a r t d i s k
10 d i s k t a p . s t a r t ( )
11 # Send key p r e s s e s
12 machine . k e y p r e s s
13 # Dump memory ( c l e a n )
14 machine . memory dump ( m e m o r y f i l e c l e a n )
15 # S t a r t
16 n e t w o r k t a p . s t a r t ( )
17 # Get a l i s t o f
18 b u t t o n c l i c k e r . u p d a t e b u t t o n s ( )
19 # S t a r t our b i n a r y and c l i c k any b u t t o n s
20 machine . k e y p r e s s
s e n d ( ’SPECIAL :RETURN’ )
21 # Move our mouse t o i m i t a t e a human
22 machine . mouse wiggle ( True )
23 # Allow b i n a r y t o e x e c u t e ( I n i t i a l )
24 t i m e . s l e e p (MALWARE START TIME)
25 # Dump memory ( i n t e r i m )
26 machine . memory dump ( m e m o r y f i l e i n t e r i m )
27 # Take a s c r e e n s h o t
28 machine . s c r e e n s h o t ( s c r e e n s h o t o n e )
29 # C l i c k any new b u t t o n s
30 b u t t o n c l i c k e r . c l i c k b u t t o n s ( new only=True )
31 # Allow b i n a r y t o e x e c u t e ( 3 min t o t a l )
32 t i m e . s l e e p (MALWARE EXECUTION TIME−e l a p s e d t i m e )
33 # Take a f i n a l
34 machine . s c r e e n s h o t ( s c r e e n s h o t
35 # Dump memory ( D i r t y )
36 machine . memory dump ( m e m o r y f i l e d i r t y )
37 # Shutdown Machine
38 machine . power shutdown ( )
( B e f o r e
c l i c k i n g b u t t o n s )
s c r e e n s h o t
t w o )
Fig. 3: Python script for running a malware sample and collecting the
appropriate raw data for analysis.
Because of the duality of our framework we were able
to write one simple script (see Figure 3) that will: 1) reset
our machine to a clean state, 2) take a memory image before
and after execution, 3) attempt to click any graphical buttons,
4) capture screenshots, and 5) capture all disk and network
activity throughout the execution. To download and execute an
arbitrary binary (Figure 3, line 12), our implementation uses
hotkeys to open a command line interface, executes a recursive
ﬁle-transfer protocol (FTP) download to retrieve the ﬁles to
be analyzed, and then runs a batch ﬁle to execute the binary.
From this data, we reconstruct the changes in system memory,
in addition to a complete capture of disk and network activity
generated by the binary. To identify any graphical buttons that
the malware may present, we use the Volatility “windows”
module to identify all visible windows that have an atom class
of 0xc061 or an atom superclass of 0xc017, which indicate
a button, and then use our actuator to move the mouse to
the appropriate location and click it. Our analysis framework
also attempts to remove any typical analysis-based artifacts by
using a random ﬁle name and continuously moving the mouse
during the execution of the binary. Similarly, when possible,
i.e., the system is not hung, we also properly shutdown the
system at the end of the analysis to force any cached disk
activity to be ﬂushed.
In our analysis setup, both the physical and virtual envi-
ronments had a 10 GB partition for the operating system and
1 GB of volatile memory. The operating system was placed
7
Fig. 4: Time spent in each step of binary analysis. Both environments
were booting a 10 GB Windows 7 (64-bit) hibernate image and were
running on a system with 1 GB of volatile memory.
into a “hibernate” state to minimize the variance between
executions and also reduce the time required to boot
the
system. To minimize the space requirements of our system,
we compress our memory images before storing them in our
databases. While this adds a signiﬁcant amount of time to our
analysis (approximately 2 minutes), it signiﬁcantly reduces the
storage requirement. Finally, the virtual machine’s networks
were logically divided to ensure that samples did not interfere
with each other, and the physical environment consisted of
only one machine.
The respective runtimes for each portion of our analysis can
be seen in Figure 4. We ensured that every binary executed for
at least 3 minutes before retrieving our ﬁnal memory image
and resetting the system. Screenshots were obtained using
Volatility’s screenshot module on physical machines and were
extracted from the captured memory images. Note that most of
the time taken in the physical case is due to our resetting of the
system state using Clonezilla, waiting for the system to boot,
and memory acquisition. The resetting and boot process could
be decreased signiﬁcantly by writing a custom PXE loader, or
completely mitigated by implementing copy-on-write into our
FPGA. Similarly, the memory acquisition times could be more
comparable to the virtual case, if not faster, by optimizing our
PCIe implementation. Finally, system snapshots could reduce
the time spent setting up the environment to mere seconds.
While snapshots are trivial with virtual machines, it is still an
open problem for physical machines.
We note that LO-PHI may miss any temporal memory
modiﬁcations made by the binary between our clean and
dirty memory images. To analyze the transient behavior of
a binary, LO-PHI could be used to continuously poll
the
systems memory during execution. However, while this has
the potential to produce a lot more ﬁdelity, we do not feel
that our current polling rates are fast enough to warrant the
tradeoff between the produced DMA artifacts and usefulness
of the output. We hope to explore this area of research in
more detail in the future as we improve our memory capture
capabilities.
0246810121416182022Physical AnalysisDisk ResetOS BootOS StabilizeKey PressesMem. (Clean)Compress (Clean)Buttons (Clean)Binary ExecutedMem. (Interim)Screenshot (Interim)Buttons (Click)Extra SleepMem. (Dirty)Screenshot (Final)Compress (Dirty)ShutdownStore Results0123456789Time Elapsed (Minutes)Virtual AnalysisDisk ResetOS BootOS StabilizeKey PressesMem. (Clean)Compress (Clean)Buttons (Clean)Binary ExecutedMem. (Interim)Screenshot (Interim)Buttons (Click)Extra SleepMem. (Dirty)Screenshot (Final)Compress (Dirty)ShutdownStore ResultsRaw SATA
Capture
Disk Reconstruction
(Custom Module)
File System Reconstruction
(PyTSK + Custom Code)
Filter Noise
FS Modiﬁcations
(a) Disk Reconstruction
Memory Image
(Clean)
Semantic Reconstruction
(Volatility)
OS Information
Memory Image
(Dirty)
Semantic Reconstruction
(Volatility)
OS Information
(b) Memory Reconstruction
Extract
Differences
Filter Noise
Memory
Modiﬁcations
Fig. 5: Binary analysis workﬂow. (Rounded nodes represent data and rectangles represent data manipulation.)
VII. EVALUATION AND ANALYSIS
In this section, we explain our methodology for seman-
tic gap reconstruction (Section VII-A) and demonstrate the
practicality of LO-PHI with three targeted experiments. The
experiments were constructed to demonstrate the following:
•
•
•
to detect
The ability of LO-PHI
the behaviors
elicited by real malware, conﬁrmed with ground truth
(Section VII-C)
The ability to scale and extract meaningful results
from unknown malware samples (Section VII-D)
The ability to analyze malware samples that employ
anti-analysis and evasion techniques (Section VII-E)
For each binary, we determine the system changes that
occurred during execution by forensically comparing the re-
sulting clean and dirty states. Each such pair of datasets
contains a clean and a dirty raw memory snapshot respectively
as well as a log of raw disk and network activity that occurred
between clean and dirty states. We exclude the network trace
analysis from much of our discussion since it is a well-known
technique and not the focus of our work. Our analysis of a
binary’s execution involves four steps: 1) bridging the semantic
gap for both the clean and dirty states, 2) computing the delta
between the two states, 3) ﬁltering out actions that are not
attributed to the binary, and 4) comparing the delta for physical
execution and virtual execution to determine if the sample
employs VM-detection techniques (if applicable). The process
taken for each binary is illustrated Figure 5. When appropriate,
we also compare our results to those produce by Anubis [7]
and Cuckoo Sandbox [36].
A. Semantic Gap Reconstruction
As previously mentioned, before any analysis can be con-
ducted, we must ﬁrst bridge the semantic gap, i.e., translate
our memory snapshots and SATA captures, which contain low-
level, raw, data into high-level, semantically-rich, information.
1) Memory: To extract operating-system-level modiﬁca-
tions from our memory captures, we run a number of Volatility
plugins on both clean and dirty memory snapshots to parse
kernel structures and other objects. Some of the general
purpose plugins include psscan, ldrmodules, modscan, and
sockets, which extract
loaded dlls,
kernel drivers, and open sockets resident in memory. Similarly,
we also run more malware-focused plugins such as idt, gdt,
the running processes,
ssdt, svcscan, and callbacks which examine kernel descriptor
tables, registered services, and kernel callbacks.
2) Disk: The ﬁrst step in our disk analysis is to ﬁrst convert
the raw capture of the SATA activity into a 4-tuple containing
the disk operation (e.g., READ or WRITE), starting sector,
total number of sectors, and data. Our physical drives, as
with most modern drives, used an optimization in the SATA
speciﬁcation known as Native Command Queuing (NCQ) [23].
NCQ reorders SATA Frame Information Structure (FIS) re-
quests to achieve better performance by reducing extraneous
head movement and then asynchronously replies based on
the optimal path. Thus, to reconstruct the disk activity, our
SATA reconstruction module must faithfully model the SATA
protocol in order to track and restore the semantic ordering of
FIS packets before translating them to disk operations. Upon
reconstructing the disk operations, these read/write transactions
are then translated into disk events (e.g., ﬁlesystem operations,
Master Boot Record modiﬁcation, slack space modiﬁcation)
using our analysis code which is built upon Sleuthkit and
PyTSK [22]. Since Sleuthkit only operates on static disk
images, our module required numerous modiﬁcations to keep
system state while processing a stream of disk operations.
Intuitively, we build a model of our SUT’s disk drive and
step through each read and write transaction, updating the
state at each iteration and reporting appropriately. This entire
process is visualized in Figure 5a. Unlike previous work [50],
which was designed for NTFS, our approach is generalizable
to any ﬁlesystem supported by Sleuthkit. A sample output from
creating the ﬁle LO-PHI.txt on the desktop can be seen below:
Filename
Allocated
Modiﬁed
Accessed
Changed
Created
Filename
Changed
MFT modiﬁcation (Sector: 6321319)
Unallocated
/WINDOWS/. . . /drivetable.txt→/. . . /Desktop/New Text Document.txt
0 → 1
2014-11-07 20:07:06 (1406250) → 2015-02-19 15:47:17 (3281250)
2014-11-07 20:07:06 (1406250) → 2015-02-19 15:47:17 (3281250)
2014-11-07 20:07:06 (1406250) → 2015-02-19 15:47:17 (3281250)
2014-11-07 20:07:06 (1406250) → 2015-02-19 15:47:17 (3281250)
132 → 0
1 → 0
Size
. . .
MFT modiﬁcation (Sector: 6321319)
/. . . /Desktop/New Text Document.txt →/. . . /Desktop/LO-PHI.txt
2015-02-19 15:47:17 (3281250) → 2015-02-19 15:47:25 (3437500)
Note that we can infer from this output that the ﬁlesystem
reused an old MFT entry for drivetable.txt and updated the
ﬁlename, allocation ﬂags, size, and timestamps upon ﬁle
creation. A subsequent ﬁlename and timestamp update were
then observed once the new ﬁlename, LO-PHI.txt, was entered.
8
Offset
0x86292438
0x86458818
0x86282be0
0x864562a0
Name
AcroRd32.exe
AcroRd32.exe
AdobeARM.exe
$$ rk sketchy server.exe
(a) New Processes (pslist)
PID
1340
1048
1480
1044
PPID
1048
1008
1048
1008
Selector
0x320
Base
0x8003b6da
Limit
0x00000000
(c) GDT Hooks (gdt)
Type
CallGate32
DPL
3
Gr
-
Pr
P
Name
hookssdt.sys
PID
1048
1044
Port
1038
21
Protocol
UDP
TCP
Address
127.0.0.1
0.0.0.0
(b) New Sockets (sockets)
Base
0xf7c5b000
(d) Loaded Kernel Models (modscan)
Size
0x1000
File
C: \. . .\lophi\hookssdt.sys