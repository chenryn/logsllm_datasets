Note that in the last game B simulates SecdelA,E (κ) perfectly
without the knowledge of Mh,0 and Ml,0 using only oracle ac-
cess provided by SecdelB,Eh (κ) and SecdelB,El (κ). Hence, any
adversary A winning SecdelA,E (κ) with non-negligible advantage
implies an adversary B which can break the security of Eh or El.
Therefore, if Eh and El are secure, so is the composed E .
Next, we observe that we can relax the requirement that Eh is a
direct scheme if Eh and El share no attributes; note this implies Vh∩
Vl = ∅ as the composition requires that the nodes of both graphs
are disjoint except for the attributes. Hence, one may compose
an arbitrary policy-based secure deletion scheme Eh with a direct
scheme El.
Theorem 3. Let Eh and El be policy-based secure deletion schemes,
where El is direct. If Vh ∩ Vl = ∅, the two schemes can be com-
posed as described above and the resulting scheme E is complete
and secure.
Proof. The construction above and proof do not utilize the fact that
Eh is direct except for the possibility that Eh and El share attributes.
Thus, if Ah ∩ Al = ∅, the result follows analogously.
3.5 Direct policy-graph construction
One may use the basic secure deletion scheme of Section 3.3
and the composition operation to implement direct secure deletion
schemes for arbitrary policy graphs. Recall that every DAG G =
(V, E) has a topological order, computable in time O(|V | + |E|),
which arranges the nodes of G in a sequence that respects the di-
rection of all edges.
We traverse G in the topological order and gradually build up a
secure deletion scheme for G. Initially we take the ﬁrst encoun-
tered interior node v0 and implement a secure deletion scheme for
v0 according to the basic scheme of Section 3.3. Subsequently,
whenever we encounter the next interior node v, we take the sub-
graph Gv induced by v and its incoming edges, implement a basic
secure deletion scheme for Gv according to Section 3.3, and com-
pose it with the secure deletion scheme realized so far.
The resulting secure deletion scheme for G implicitly contains a
key for every node and a key for certain edges. More precisely, for a
source node (attribute) a, the key Ka is explicitly stored in the mas-
ter key and has one entry for every outgoing edge; for any interior
node (protection class) p with n incoming edges and threshold m,
the key Kp is stored encrypted as follows. For every incoming
edge (v, p), except for those incident to an attribute, the auxiliary
state contains an encryption of a key Kv,p under the key Kv, which
corresponds to node v. In turn, the auxiliary state associated to p
contains a vector (xp,1, . . . , xp,n), where some xp,j is associated
to v and represents an encryption of sp,j under Kv,p. The value
sp,j is a share of Kp in a (m + 1)-out-of-n secret sharing scheme.
Thus, every node in G is associated with one encryption key
and every edge in G not incident to a source is also associated
with one encryption key. The resulting structure is an iterative key-
encrypting key-assignment scheme (IKEKAS) according to Cramp-
ton et al. [6].
The access cost is proportional to the size of G. More precisely,
accessing a node p needs a maximum of two secret-key crypto-
graphic operations for every edge that must be traversed (i.e., set to
TRUE), in order to derive p (i.e., set p to TRUE). The master key
contains one component for every attribute and the total size of the
auxiliary state is in O(|V | + |E|).
Observe that one may eliminate the encryption keys associated to
the edges and encrypt the share of a child node directly with the key
of the parent node. This reduces the number of cryptographic oper-
ations without impacting the security of the construction. However,
the resulting scheme cannot obtained from the modular composi-
tion operation in Section 3.4, and a detailed security proof is left
for future work.
Furthermore, the master key component for an attribute a, the
key Ka, is a tuple of keys with one entry for every outgoing edge.
This is done so that the resulting secure deletion scheme is the
same, regardless of which topological order is used during com-
position, as the edges adjacent to attributes are used in a special
way in the composition. However, once constructed, one can re-
place the tuple Ka with a single key K ′
a, and for every edge (a, p)
store the key Ka,p protected with K ′
a in the auxiliary state of the
edge (a, p), as done for all other edges; this reduces the master-key
size.
3.6 Tree construction
In early work on secure deletion, Di Crescenzo et al. [8] intro-
duce a tree construction that protects data in an arbitrary number of
emulated memory locations. The scheme is realized from persistent
storage exposed to an adversary and allows to overwrite individual
memory locations. Only a small erasable memory of constant size
is needed for maintaining a master key.
266Using our terminology, their scheme permits n protection classes
p1, . . . , pn and each one can be speciﬁed for deletion indepen-
dently of the others. The deletion policy graph consists of n at-
tributes a1, . . . , an, the n protection classes p1, . . . , pn, and n edges
(ai, pi) for i ∈ [n].
A balanced tree with n leaves, labeled by p1, . . . , pn, is con-
structed as follows. First, a key Kv of a secret-key encryption
scheme is generated, ranging over all nodes v in the tree. Next,
for every node v, the keys of all children of v are encrypted with
Kv and the resulting ciphertext is added to the auxiliary state asso-
ciated to v. The key of the root node represents the master key; is
not stored in the auxiliary state.
For protecting or for accessing a ﬁle under protection class pi, all
keys along the path from the root to pi are decrypted, starting from
the root, and Kpi is used to encrypt or decrypt the ﬁle, respectively.
Deletion for attribute ai makes all data protected under pi inac-
cessible. This operation is implemented by generating fresh keys
for all nodes on the path from the root to pi in the tree. More pre-
cisely, the keys of all nodes and their siblings along this path are
ﬁrst decrypted, then a fresh key is generated for every node on the
path except for pi, and ﬁnally all fresh keys are encrypted under
the fresh key of the respective parent node and stored in the auxil-
iary state. The fresh root key is written to the master key and the
previous root key is deleted in the erasable memory.
Clearly, this construction represents a secure deletion scheme,
which can be proved secure assuming a secret-key cryptosystem
along the lines of the existing proof [8]. The access cost of the
scheme as well as its deletion cost are O(log n) secret-key opera-
tions. The erasable memory contains only one key of the secret-key
encryption scheme as the master key and the auxiliary state is of
size O(n).
3.7 Time-tree construction
Our model and the tree construction above make no assumption
about the order in which attributes are deleted. However, one may
sometimes exploit such restrictions. Consider a sequence of at-
tributes a1, . . . , an modeling expiration time such that any ai can
only be deleted if a1, . . . , ai−1 have been deleted beforehand. This
property gives way to build a more efﬁcient scheme.
More precisely, consider a deletion policy graph consisting of at-
tributes a1, . . . , an, protection classes p1, . . . , pn, and edges (ai,
pi) for i ∈ [n], which represent an ordered sequence of time units
from [n]. We want to support deletion only as ordered by time, and
we want to support an efﬁcient operation that deletes multiple sub-
sequent units at once. To this end, we construct a balanced tree over
the leaves p1, . . . , pn, design a master key of size O(log n), but
use no auxiliary storage. The leaves of the tree represent the time
units in a left-to-right order. The key of a node is computed from
its parent’s key using a pseudo-random function (PRF), where the
parent’s key serves as the PRF key and the input denotes whether
the node is a left or right child. The root node’s key is chosen uni-
formly at random. The master key consists of the key of the leaf
corresponding to the earliest non-deleted time unit and the keys of
all right siblings on the path from the root to that leaf. This way,
only the keys for time units following the last deleted one can be
derived. Storing only right-siblings like this is a well-known tech-
nique [18] to achieve forward-secure cryptosystems without chang-
ing the public key of an encryption scheme.
The deletion for the attribute at updates the master key to contain
the key for the leaf pt+1 and the keys of all right siblings on the path
from the root to that leaf; keys for all time periods greater than t can
be derived from the master key in time O(log n) from the stored
right-siblings. Deleting an arbitrary attribute at and all attributes
preceding it takes O(log n) cryptographic operations, though the
amortized cost is only O(1) if the attributes are deleted one by one.
Hence, this tree construction is superior to the previous one both
for deleting time units in order and for deleting in arbitrary incre-
ments.
3.8 Combined construction
Recall that for composing two secure deletion schemes with The-
orem 2, only the lower scheme must be direct. Therefore, we can
combine the tree construction of Section 3.6 with the direct scheme
of Section 3.5 to obtain a secure deletion scheme with some at-
tributes organized in a tree, as described above, whereas the rest
are organized using a direct scheme. This is useful for modeling a
case where many attributes are values from a large set or interval,
such as user identities or dates.
One can further combine two or more such tree constructions
trivially through logical expressions if the attributes in the trees
are all distinct. In this way, we can compose many separate tree
schemes with a direct scheme to obtain an elaborate and practical
secure deletion scheme. The prototype implementation described
later follows this approach.
4. PROPERTIES
4.1 Efﬁciency of the schemes
In Table 1, we present a comparison of the direct graph and tree
schemes described, respectively, in Section 3.5 and Section 3.6;
as well as two obvious “trivial” constructions, discussed next. As
mentioned earlier, the protection cost is the same for all schemes
considered in this paper.
The ﬁrst trivial scheme uses a separate key for each protection
class. This results in a large master secret key but achieves fast
deletion operations. The Ephemerizer [20], for instance, encrypts
all ﬁles with a particular expiration time with the same time-speciﬁc
key, and Vanish [13] encrypts every user-data object with an in-
dependent key. Likewise, the Data Node Encrypted Filesystem
(DNEFS) [22] uses this approach for protecting every data node
of the ﬂash ﬁlesystem independently.
The second trivial scheme implements a tree of depth one:
it
uses a single encryption key as a master key and one encryption
key for each protection class; the master key is used to encrypt the
keys of the protection classes and the ciphertexts are stored in the
auxiliary state. Deletion requires the re-encryption of all remaining
protection-class keys with a new master key. This scheme appears,
e.g., in the extension of DNEFS to an encrypted ﬁlesystem [22].
Note that removing this level of indirection, and using the master
key to protect the ﬁles directly, would result in much worse deletion
performance, as the number of ﬁles is typically much greater than
the number of protection classes.
The operational cost of our direct policy-graph secure deletion
scheme is determined by the parameters of its graph, namely, the
maximum in-degree d of a node and the longest path ℓ. The main
advantages of this scheme are its fast deletion operation coupled
with its high expressibility. Unlike the other schemes, which con-
sider only protection classes mapped one-to-one to attributes, the
policy-graph scheme allows ﬂexible policies formulated through
logical expressions over attributes. In practice, d and ℓ will often
be small numbers, though in O(|A|) and O(|P|), respectively.
4.2 Relation to secret-key encryption
Every secure deletion scheme is also a secret-key cryptosystem
with security against chosen-plaintext attacks. We only sketch this
relation here; adding the formal details is straightforward.
267Scheme
Trivial direct
Trivial tree
Direct graph
Tree
Time-tree∗
Deletion cost Access cost Master-key size
O(1)
O(|P|)
O(1)
O(log |P|)
O(1)
O(1)
O(1)
O(d · ℓ)
O(log |P|)
O(log |P|)
O(|P|)
O(1)
O(|A|)
O(1)
O(log |P|)
Table 1: Efﬁciency comparison. |A| and |P| denote the number
of attributes and protection classes in the policy graph, d is the
maximum in-degree of a node, and ℓ is the longest path in the
graph. ∗ The time-tree supports only deletion going forward in
time; its amortized deletion cost is O(1) and O(log |P|) in the
worst case.
Recall that a secret-key cryptosystem S consists of three algo-
rithms for key generation, encryption, and decryption, respectively.
The following steps emulate S from a secure deletion scheme E :
1. Let G1 be the minimal policy graph with one attribute a,
one protection class p, and one edge from a to p. For key
generation in S, run the initialization algorithm of E with G1
and use its output as the secret key.
2. For encryption of a plaintext m with S, invoke the protection
algorithm of E on p and m, obtain a ciphertext c, and output
(p, c).
3. For decrypting a ciphertext (p, c) of S, invoke the access al-
gorithm of E , and output the response.
We claim that S is a secret-key cryptosystem with indistinguish-
able ciphertexts under chosen-plaintext attacks (IND-CPA secu-
rity). To see this, suppose S is not secure. Then we construct
a simulator SIM that contradicts the security of E in experiment
Secdel, by interacting with an adversary AS that breaks the secu-
rity of S.
The simulator executes the operations of S according the de-
scribed emulation of S from E ; note that SIM does not call Delete.
When AS outputs two plaintexts m0 and m1 such that one is to
be encrypted as challenge, the simulator outputs p, m0, and m1.
Then Secdel responds with a ciphertext c∗ that contains a repre-
sentation of mb, where b ∈ {0, 1}. According to the emulation of
S, the simulator gives (p, c∗) to AS . When AS outputs a bit ˆbS
as its guess for the challenge plaintext, then SIM queries its oracle
for the deletion operation with attribute set {a}, ignores the master
key that it receives, and outputs ˆbS . Note that SIM emulates the
IND-CPA security experiment perfectly. By the assumption that
AS breaks the indistinguishability of ciphertexts of S, it follows
that Pr[SecdelSIM,E (κ) = 1] − 1
2 is not negligible. Hence, E is not
a secure policy-based deletion scheme.
5. PROTOTYPE IMPLEMENTATION
Here we describe a ﬁlesystem prototype of a policy-based secure
deletion scheme according to Sections 2 and 3. The secure-deletion
ﬁlesystem (delfs) is implemented as an extension to EncFS [10], a
virtual cryptographic ﬁlesystem in Linux based on FUSE [12]. As a
virtual ﬁlesystem, delfs does not handle space allocation itself, just
like EncFS, but acts as a transparent protection layer and projects
the stored directories and ﬁles with the same structure onto a lower-
layer (physical) ﬁlesystem.
5.1 Overview
Data stored in delfs seamlessly beneﬁts from secure deletion. To-
gether with every instance of a delfs-mounted directory tree, the
user speciﬁes a deletion policy in the format described later. Every
ﬁle maintained by delfs is associated with a protection class and
Figure 4: delfs architecture.