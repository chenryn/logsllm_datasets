title:Defeating Memory Corruption Attacks via Pointer Taintedness Detection
author:Shuo Chen and
Jun Xu and
Nithin Nakka and
Zbigniew Kalbarczyk and
Ravishankar K. Iyer
Defeating Memory Corruption Attacks via Pointer Taintedness Detection 
Shuo Chen†, Jun Xu‡, Nithin Nakka†, Zbigniew Kalbarczyk†, Ravishankar K. Iyer†
† Center for Reliable and High-Performance Computing,  
University of Illinois at Urbana-Champaign, 
1308 W. Main Street, Urbana, IL 61801 
{shuochen, nakka, kalbar, iyer}@crhc.uiuc.edu 
‡ Department of Computer Science 
North Carolina State University 
Raleigh, NC 27695 
PI:EMAIL 
Abstract 
Most  malicious  attacks  compromise  system  security 
through  memory  corruption  exploits.  Recently  proposed 
techniques  attempt  to  defeat  these  attacks  by  protecting 
program control data. We have constructed a new class of 
attacks that can compromise network applications without 
tampering  with  any  control  data.  These  non-control  data 
attacks  represent  a  new  challenge  to  system  security.  In 
this  paper,  we  propose  an  architectural  technique  to 
defeat  both  control  data  and  non-control  data  attacks 
based  on  the  notion  of  pointer  taintedness.  A  pointer  is 
said to be tainted if user input can be used as the pointer 
value.  A  security  attack  is  detected  whenever  a  tainted 
value  is  dereferenced  during  program  execution.  The 
proposed architecture is implemented on the SimpleScalar 
processor  simulator  and  is  evaluated  using  synthetic 
programs as well as real-world network applications. Our 
technique can effectively detect both control data and non-
control data attacks, and it offers better security coverage 
than  current  methods.  The  proposed  architecture  is 
transparent to existing programs. 
Keywords:  Security,  Attack,  Vulnerability,  Taintedness, 
Hardware Design 
1. Introduction 
Most malicious attacks, viruses, and worms exploit low-
level  programming  errors  to  compromise  the  security  of 
target  systems.  Well-known  examples  include  the  Morris 
Worm  that  exploited  a  buffer  overflow  vulnerability  in 
fingerd,  the  Code  Red  Worm  that  exploited  a  buffer 
overflow  in  Internet  Information  Service  (IIS),  and  the 
format  string  attack  against the WU-FTP daemon. A wide 
spectrum  of  programming  errors  allow  attackers  to  mount 
memory  corruption  attacks,  including  buffer  overflow, 
heap corruption (such as heap buffer overflow and double 
free),  integer  overflow,  format  string,  and  LibC  globbing 
vulnerabilities.  Our  survey  indicates  that  this  type  of 
vulnerability  accounts  for  67%  of CERT advisories in the 
years 2000-2003 [8]. 
Several  means  have  been  proposed  to  defeat  security 
attacks.  Type-safe  languages,  compiler  analyses,  and 
adopted 
formal  methods  have  been 
to  prevent 
programmers  from  writing  insecure  software.  But  despite 
substantial  research  and  investment,  the  state  of  the  art  is 
far from perfect, and as a result, security vulnerabilities are 
constantly  being  discovered  in  the  field.  The  most  direct 
counter-measure  against  vulnerabilities  in  the  field  is 
security patching.  Patching, however, is reactive in nature 
and can only be applied to known vulnerabilities. The long 
latency  between  bug  discovery  and  patching  allows 
attackers  to  compromise  many  unpatched  systems.  An 
alternative  to  patching  is  runtime  vulnerability  masking 
that  can  stop  ongoing  attacks.  Compiler  and  library 
interception  techniques  have  been  proposed  to  mask 
security  bugs,  usually  by 
terminating  a  vulnerable 
application  upon 
the  detection  of  an  attack.  These 
techniques  have  been  successful  in  defeating  a  number  of 
specific types of attacks, in particular stack buffer overflow 
[5][11] and format string attacks [6].  
Recently,  processor  architecture  mechanisms—no-
execute  page-protection  (NX)  processors  developed  by 
AMD and Intel [13], Secure Program Execution [18], and 
Minos  [7]—have  been  proposed  to  thwart  most  types  of 
memory  corruption  attacks.  The  key  assumption  made  in 
these  proposals  is  that,  in  order  to  launch  a  successful 
memory corruption attack, the attacker must either change 
control  data  (code  pointers)  that  are  subsequently  loaded 
into  the  processor’s  program  counter  register  (PC),  or 
execute malicious code supplied by attackers. Examples of 
control data include function pointers and return addresses. 
In  this  paper,  we  refer to these techniques as control-flow 
integrity based protections.   
We  examined  a  number  of  vulnerabilities  in  major 
network applications, and found that these applications can 
also be compromised by corrupting non-control data. Non-
control  data  include  integers  representing  user  identity, 
server  configuration  strings,  and  pointers  to  user  input 
data. We show that many non-control data attacks result in 
the  same  severity  of  security  compromises  as  the  control 
data  attacks,  usually  the  possession  of  root  privileges. 
Since  these  attacks  do  not  corrupt  control  data,  existing 
architectural  protection  mechanisms  are  not  able  to  detect 
the  attacks.  Hence,  non-control  data  attacks  represent  a 
challenge  to  defeating  memory  corruption  attacks.  In  this 
paper, we propose a processor architecture level technique 
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 22,2021 at 04:19:55 UTC from IEEE Xplore.  Restrictions apply. 
that  can  defeat  both  control  data  and  non-control  data 
memory corruption attacks.  
reason 
about  many 
The  basis  of  our  technique  is  the  notion  of  pointer 
taintedness,  which  we  initially  introduced  in  [10]  to 
formally 
types  of  memory 
vulnerabilities  in  software  using  a  static  program  analysis 
technique.1  A  pointer  is  said  to  be  tainted  if  the  pointer 
value  comes  directly  or  indirectly  from  user  input.  A 
tainted pointer allows the user to specify the target memory 
address  to  read,  write,  or  transfer  control  to,  which  can 
lead to system security compromise. The attacker’s ability 
to  specify  a  malicious  pointer  value  is  crucial  to  the 
success of memory corruption attacks.  
We  proposed  in  [10]  an  extended  memory  model  in 
which  each  memory  location  (and  each  register)  is 
associated with a Boolean property taintedness to indicate 
whether  the  data  in  this  location  (and  this  register)  are 
derived  from  user  input.  The  same  memory  model  is 
employed  to  implement  the  runtime  defense  mechanism 
discussed  in  this  paper.  Any  data  received  from  external 
sources  are  marked  tainted.  External  data  sources  include 
network,  file  system,  keyboard,  command  line  arguments, 
and  environmental  variables.  Load,  store,  and  ALU 
instructions  are  responsible  for  propagating  taintedness 
from  register  to  register,  memory  to  register,  and  register 
to  memory.  Anytime  a  data  word  that  has  tainted  bytes  is 
used for memory access or control flow transfer, an alert is 
raised and the application process is terminated.  
is 
to 
transparent 
The  proposed  architecture 
the 
application, and thus existing applications can run without 
recompilation  or  relinking.  For  example,  precompiled 
SPEC 2000 benchmark applications are able to run on the 
simulated  architecture  without  generating  any  false  alerts. 
This  is  an  important  advantage  over  compiler-based 
pointer  protection  methods,  such  as  PointGuard  [6],  that 
need  to  statically  identify  all  data  variables  that  can  be 
used as pointers. Accurate pointer type analysis has proven 
to be a hard problem in practice. The proposed architecture 
requires  no  source  code  access  or  compile-time  type 
information.  Our  technique  is  prototyped  as  an  enhanced 
SimpleScalar processor simulator [20]. 
Attacks that overwrite both control and non-control data 
against  a  number  of  real-world  network  applications  are 
used to evaluate the effectiveness of the proposed defense 
technique.  The  accurate  detection  of  all  these  attacks 
shows  the  strength  of  our  approach  and  indicates  a 
significant improvement in security coverage. 
2. Related Work 
Both  static  compiler  analysis  and  runtime  detection 
to  defeat  memory 
techniques  have  been  developed 
[6] 
to  defeat 
[21].  Although 
corruption  attacks.  Generic  static  techniques  such  as 
SPLINT [12] and Extended Static Checking [9] can check 
if the specified security properties are satisfied in program 
code.  Domain-specific  code  analysis 
techniques  are 
designed  to  uncover  specific  types of vulnerabilities, such 
as  buffer  overflow  vulnerability  [23]  and  format  string 
vulnerabilities 
static  code  analysis 
techniques  are  helpful  in  finding  security  vulnerabilities, 
their  scalability,  analysis  granularity  and  dependency  on 
application-specific  knowledge  have  lead  to  significant 
false positive and false negative rates. Runtime techniques 
defeat  security  attacks  in  the  field.  Earlier  techniques 
provided  protection  against  specific  types  of  attacks. 
Representative  techniques  include  StackGuard  [11]  and 
Libsafe  [5]  to  defeat  stack  buffer  overflow  attacks,  and 
FormatGuard 
format  string  attacks. 
Defensive  techniques  which  randomize  process  memory 
layout  to  defeat  security  attacks  are  proposed  [2][4][24]. 
Although  the  principle  is  generic  against  most  memory 
corruption  attacks, 
the 
implementation and deployment. Randomizing the address 
of  every  object,  especially  objects  in  the  static  data 
segment,  is  a  challenging  issue  that  requires  further 
research.  In  addition,  the  deployment  of  these  techniques 
on 32-bit architectures has been shown to suffer from low 
entropy2  –  they  cannot  provide  more  than  16-20  bits  of 
entropy,  which  is  not  sufficient  to  defeat  brute-force 
attacks [19]. 
Advances 
in  computer  architecture  research  have 
resulted  in  a  number  of  techniques  that  are  considered 
generic  against  all  types  of  memory  corruption  attacks. 
Secure  Program  Execution  [18]  and  Minos  [7]  are 
techniques to protect control data integrity. While effective 
in  defeating  control  data  attacks,  these  techniques  are 
unable to defeat non-control data attacks.  
there  are  still  barriers 
in 
The notion of taintedness was first proposed in the Perl 
programming  language  as  a  security  feature.  Inspired  by 
this,  static  detection  techniques  SPLINT [12] and CQUAL
[21] apply taintedness analysis to guarantee that user input 
data is never used as the format string argument in printf-
like  functions.  In  [10],  we  analyzed  many  categories  of 
security  vulnerabilities  and  concluded  that  their  common 
root cause is the taintedness of pointers. A memory model 
and  the  algorithm  used  to  detect  pointer  taintedness  were 
initially  provided  in  the  paper  as  a  rewriting  logic 
framework to formally reason about security vulnerabilities 
in  programs.  Secure  Program  Execution  [18]  and  Minos
[7]  techniques,  which  were  proposed  more  recently,  rely 
on the definitions of spuriousness and integrity of data. We 
believe 
to 
taintedness. Their memory models and algorithms are also 
these  definitions  bear  certain  similarities 
1 The notion of taintedness has been proposed in Perl and other previous 
literature such as [12] and [21]. Tainted data is defined as data coming 
from external input. The novelty of our work is to view the root cause of 
most memory corruption attacks to be tainted pointers.  
2 In this context, the term entropy means the randomness of the address 
of  each  program  element.  Higher  entropy  implies  that  an  attacker  has 
more difficulty guessing the correct memory layout.  
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 22,2021 at 04:19:55 UTC from IEEE Xplore.  Restrictions apply. 
to  what  we  proposed 
in  [10].  However,  a 
similar 
fundamental  difference  is  that  they  do  not  detect  the 
taintedness of pointers in general, but only the taintedness 
of  control  data.  They  view  control  data  taintedness  as  the 
result of memory corruptions, rather than the root cause of 
memory corruptions. 
3. Pointer Taintedness Based Attacks 
to 
format 
large  signed 
an  unchecked  buffer; 
We  analyze  the  107  CERT  advisories  from  2000 
through 2003. Figure 1 shows a breakdown of the leading 
programming vulnerabilities. Buffer overflow results from 
writing 
string 
vulnerabilities  result  from  incorrect  invocations  of  printf-
like  functions;  integer  overflow  results  from  interpreting 
extremely 
integers  as  negatives;  heap 
corruption results from corruption of the heap structure or 
freeing  a  buffer  twice;  and  globbing  vulnerabilities  result 
from  an  incorrect  invocation  of  LibC  function  glob().
These  categories  collectively  account  for  67%  of  the 
advisories.  Although  attacks  exploiting  these  different 
types  of  vulnerabilities  have  different  appearances,  we 
observe  a  common  characteristic  among  them:  the  attack 
must first taint a pointer and then trick the victim program 
into  dereferencing  that  pointer.  The  attacker’s  ability  to 
specify  a  pointer  value  is  a  crucial  requirement  for  the 
success of a memory corruption attack.  
Figure  2  presents  examples  of  stack  buffer  overflow 
attack,  heap  corruption  attack,  and  format  string  attack, 
illustrating how pointer taintedness enables these attacks.
Buffer 
Overflow
44%
Other
33%
Globbing
2%
Format 
String 
7%
Heap 
Corruption
Integer 
Overflow
8%
6%
Figure 1: Breakdown of Security Vulnerability Categories 
in CERT Advisories (2000–2003)
Stack  buffer  overflow  attack.  Each  function  frame 
consists  of  the  return  address,  the  frame  pointer,  and  the 
local  stack  variables  of  the  function.  Function  exp1()
defines a stack buffer buf with 10 bytes, which is located a 
few words before the return address and the frame pointer. 
The  subsequent  scanf()  call  can  read  an  arbitrarily  long 
input  supplied  by  the user. When the user input data (i.e., 
tainted data) overrun the buffer buf, the memory locations 
of  the  frame  pointer  and  the  return  address  are  tainted  by 
the input data (shown as the grey area). The tainted return 
address  is  used  when  function  exp1()  returns.  The  control 
flow  of  the  program  is  therefore  diverted  to  an  attacker-
specified  location,  usually  the  entry  of malicious code the 
attacker  wants  to execute. More details about stack buffer 