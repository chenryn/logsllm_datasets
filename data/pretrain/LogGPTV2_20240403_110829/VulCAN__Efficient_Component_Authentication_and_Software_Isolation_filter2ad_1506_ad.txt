### MAC Computation

For each secure message, vatiCAN computes a 64-bit Message Authentication Code (MAC) over 112 bits of associated data, including the ID, payload, and nonce. This operation reportedly requires approximately 47,600 clock cycles or 2.95 ms, using an optimized Keccak SHA-3 hash function in the software-only vatiCAN implementation [34]. In contrast, our hardware-assisted solution is over 11 times faster, requiring only 4,222 clock cycles or 0.21 ms to compute a 128-bit MAC. Our vulcanized LeiA implementation, on the other hand, uses 16-bit nonces, reducing the associated data to 96 bits and the MAC computation time to 4,049 cycles (0.20 ms).

### Cryptographic Acceleration

Cryptographic acceleration is essential for meeting real-world automotive safety requirements, such as automated collision avoidance, under benign conditions. For example, at a highway speed of 100 km/h, vatiCAN’s software-based MAC computation corresponds to a traveling distance of 8 cm, whereas VulCAN reduces this distance to just 0.6 cm. The importance of authentication overhead becomes even more pronounced when messages need to be processed by multiple interacting components, such as anti-lock braking, electronic brake force distribution, and electronic stability control systems.

### Message Transmission

We also investigated the overall overhead to send an authenticated message. The first row of Table 1 lists the baseline, which is the time required by our CAN driver to send a plain, unauthenticated message with an 11-bit standard ID (approximately 0.41 ms). However, due to the limited CAN payload length, MACs must be sent in a separate authentication message following the actual message. This inherent CAN limitation means that VulCAN must send two messages for every legacy message to be authenticated. Our baseline measurement in Table 1 includes the time needed by the transceiver chip to initiate transmission and receive acknowledgment from the receiver device. Our driver includes an option to return immediately after loading the relevant device registers without waiting for the transmission to complete successfully. This option is used in our vulcanized vatiCAN/LeiA implementations when sending the legacy message to be authenticated. By unblocking immediately after submitting the legacy payload for transmission, VulCAN can start the MAC computation early and then wait for acknowledgment of both the legacy and authentication messages. This optimization technique ensures that the overall time to send one authenticated message can be slightly less than the time to send two unauthenticated legacy messages.

As a result of Sancus’ hardware-level cryptographic primitives, our vulcanized vatiCAN/LeiA implementations compute MACs in half the time required to send a message, whereas MAC computation in software-only vatiCAN easily outweighs the message transmission time (by almost a factor of 6). Comparing the third and fourth rows of Table 1 reveals that the total relative overhead for sending an authenticated message with Sancus+vatiCAN decreases the relative overhead by 534% compared to the extrapolated software-only vatiCAN case. Regarding LeiA, the second row of Table 1 shows that sending a legacy CAN message with an extended 29-bit identifier is slightly more expensive (about 18%) due to the need to load extra device registers. This explains why the overall overhead for Sancus+LeiA is slightly larger than that of vulcanized vatiCAN.

In the last experiment, we not only use Sancus’ hardware-level encryption but also leverage its software isolation primitive to maintain key secrecy on a partially compromised ECU. Specifically, we construct CAN messages and their corresponding MACs in a Protected Module (PM), ensuring that keys are never exposed to untrusted system software. Compared to the unprotected case, Sancus+vatiCAN/LeiA now also has to transparently copy message memory buffers to and from the unprotected CAN driver. Previous work [30, 44] has shown that such protection domain switches come with a limited performance penalty, which is reflected in a modest 5 to 6% execution time overhead in Table 1.

### Round-Trip Time

To assess authentication delays in a sender/receiver scenario, we performed a round-trip time experiment. One ECU first broadcasts an 8-byte CAN frame, and upon successful reception, the receiver ECU immediately broadcasts a reply message. For a legacy, unauthenticated CAN network, we measured a ping-pong time interval of 1.01 ms to exchange two messages in total. On an authenticated CAN network, four messages have to be exchanged, and both the sender and receiver must compute two MACs, as shown in Fig. 5.

Table 2 lists the results of the round-trip time experiment. Since twice the amount of messages have to be exchanged (to carry the authentication codes), the expected performance overhead is around 100%. However, the relative overhead for vulcanized vatiCAN/LeiA decreased further, down to 74% and 112%, respectively. This reflects the fact that messages now also have to be received and processed by the receiver, making the contribution of MAC computation less significant in the overall timing. Similarly, the induced Sancus software protection overhead amounts to only 3 to 6% and can be expected to drop further if the protected modules spend more time processing the message. The extrapolated measurements for software-only vatiCAN, on the other hand, demonstrate once more that software-level MAC calculation remains dominant, increasing the relative overhead by over 400%.

We acknowledge that the above overheads may be prohibitive for some existing real-world applications. Evaluating this is beyond the scope of this paper. However, in comparison with state-of-the-art software-only solutions, our results show that VulCAN can target a substantially larger class of safety-critical applications where real-time deadlines must be satisfied. Ultimately, the choice of authentication protocol, communication technology, and trusted computing platform remains application-specific.

### Extended Application Scenario

To explore the feasibility of our approach in actual application scenarios, we constructed a moderate-sized automotive test bench. Figure 6 shows a photograph of our setup, which consists of two off-the-shelf automobile instrument clusters from the 2014 Seat Ibiza model and six Sancus-enabled ECUs configured as described in Section 5. We also attached a CAN-to-USB converter to monitor traffic and inject CAN messages from an ordinary laptop computer.

#### Application Overview

Figure 7 provides a simplified schematic of the demo scenario. It involves a central ECU that hosts a protected Sancus software module (PMcs) to securely process commands from the legitimate motorist. We attach a keypad device that abstracts the motorist’s interaction with the vehicle (e.g., steering wheel and braking/accelerator pedals). To gain exclusive access to the keypad peripheral, PMcs securely links to a local PMkey MMIO driver assembly module, as explained in Section 2.2. For demonstration purposes, we also attached a second unprotected keypad, colored red and sensed by attacker code, to represent an adversary with CAN message injection capabilities and arbitrary unprotected code execution on the central ECU.

The setup features four wheel ECUs, each simulating an actuator (brake), abstracted by a peripheral LED display that shows the current wheel RPM. Each wheel ECU hosts a protected software module (PMrpm) that listens to authenticated CAN messages from the central system to update individual wheel RPM on the local LED display via a secure MMIO driver module (PMled).

The two vehicle instrument clusters represent unmodified legacy devices, with one directly connected to the untrusted CAN bus and the other shielded by a Sancus-enabled gateway. The gateway ECU hosts a PMдw component that listens to selected instrument cluster IDs on the global CAN bus, ensuring that only authenticated messages are forwarded. To prevent untrusted software on the gateway ECU from injecting messages directly onto the CAN bus that connects to the shielded dashboard, we include the CAN driver code in the PMдw protection domain and rely on a small PMspi assembly module to secure the interaction with the MMIO-based SPI master peripheral that communicates with the CAN controller.

#### Discussion

An important benefit of our vulcanized vatiCAN/LeiA software libraries is that CAN authentication remains largely transparent to the distributed application components. At the application level, we programmed PMcs to accept keypad commands for speeding up/down and steering left/right. In response to these events, authenticated CAN messages are created that update the instrument cluster's RPM needle and turning light indicators. The distributed wheel ECUs respond to authenticated messages to update their individual wheel RPM, with the central system applying slightly more traction to the outer wheels while turning, as commonly performed in automotive traction control systems. The attacker keypad offers the same functionality and triggers responses on the unprotected instrument cluster. However, critical PM components safely reject attacker-generated messages. Specifically, PMдw does not forward the spoofed CAN message to the secure dashboard but instead creates a message that triggers a warning light indicator to notify the motorist of the ongoing attack.

Our solution encompasses untampered CAN authentication and application-level message processing, as well as secure I/O. We guarantee that any critical actuator event (e.g., wheel LED display change or secure dashboard update) can only be caused by a chain of processing events that can ultimately be traced back to the authenticated component (PMkey) that originally sensed the keypad input provided by the motorist. Importantly, our approach maintains this guarantee even when an attacker compromises the network and the unprotected software stack on participating ECUs.

### Related Work

#### Authentication on the CAN

Besides vatiCAN [34] and LeiA [38], several protocols and approaches for implementing authentication in automotive bus systems have been proposed, though they do not comply with the AUTOSAR [3] industry recommendations. CANAuth [46] and LiBrA-CAN [15] propose authentication protocols for the CAN+ [51] specification. These schemes are backward-compatible, allowing authentication-aware ECUs to co-exist with legacy ECUs. However, upgraded hardware, modified CAN transceivers, and more powerful ECUs are required to implement the protocols and cryptographic algorithms. For example, LiBrA-CAN was evaluated on high-end ECUs and laptop CPUs, showing cryptographic performance comparable to our approach. VulCAN provides similar authenticity while being AUTOSAR-compliant and relying on much lighter ECUs and off-the-shelf CAN hardware.

MaCAN [7, 16] does not require specifically adapted CAN transceivers but divides 8-byte CAN data into a 4-byte payload and a 4-byte MAC. Additionally, the protocol requires network-wide trusted key and time servers. The secrecy of credentials in MaCAN has been proven under a passive attacker model [7]. LCAP [17] requires only 2 bytes of a CAN message to carry authentication information but uses a large number of addresses (IDs) and messages to achieve node synchronization. CaCAN [23] introduces a central monitor node that authenticates other ECUs and destroys unauthorized frames in real-time using custom CAN hardware.

All the above approaches require some form of specialized hardware to efficiently implement cryptography and allow specific operations on the CAN. The challenges of key distribution, software integrity, and key confidentiality in the presence of active ECU attackers remain unaddressed. In contrast, the VulCAN solution aims for strictly stronger security guarantees and implements them using lightweight trusted computing technology.

A recent comprehensive study [12] on the abilities of CAN network-level attackers shows that eavesdropping, message modification, and ECU impersonation are not the only attack vectors in automotive control networks. From an availability perspective, selected target nodes could be muted completely. Such attack vectors cannot be addressed by cryptography alone but require physical isolation of safety-critical control networks and a notion of software security that prevents unauthorized software from abusing existing CAN hardware (cf. Section 6).

#### Trusted Execution Technology in Cars

The idea of relying on trusted computing components to develop secure automotive control systems was first introduced in 2008 [35]. With the goal of attesting vehicular computing infrastructures and providing additional security capabilities such as accelerated cryptography and key management, few implementations leveraging trusted execution technology [20] have been published. One such approach explored by the EVITA project uses the Hardware Security Module (HSM) [49], a secure co-processor for accelerated ciphers, key storage, random number generation, and a secure clock. The HSM runs at several hundred MHz and exhibits significantly better cryptographic performance than Sancus, but it also relies on a substantially larger and more expensive hardware TCB. With Vector’s MICROSAR [14], operating system support and CPU infrastructure for an HSM-like co-processor are commercially available.

Lightweight PMA-based trusted computing architectures such as Sancus provide strictly stronger security guarantees. Most importantly, PMAs are capable of not only attesting software components at boot time but also isolating them at runtime to maintain security guarantees over the entire lifetime of the program. Our choice for Sancus is motivated by a recent exhaustive PMA overview [24] that indicates Sancus is the only embedded architecture with an open-source hardware design and software toolchain.

#### Related PMA Use Cases

Sancus has been previously applied in a secure smart metering infrastructure [29]. The security guarantees that Sancus provides in this distributed application scenario have been generalized and partly formalized [32], and are similar to our approach. However, real-time requirements are relaxed in comparison with automotive applications. An approach to securely share system resources on Sancus has been proposed [44], and subsequent research [45] has provided insight into implementing secure PM interruptability and scheduling to ensure real-time responsiveness on Sancus platforms. We expect these developments to further improve our approach in terms of availability guarantees. Secure interruption of hardware-enforced embedded PMs was first explored in TrustLite [21]. Subsequent work developed TyTAN [6], a minimal software-based root of trust for dynamic attestation of interrupt-protected PMs.