MAC Computation. For each secure message, vatiCAN computes
a 64-bit MAC over 112 bits of associated data (ID, payload, nonce).
This operation reportedly requires about 47,600 clock cycles or 2.95
ms, using an optimized Keccak SHA-3 hash function in the software-
only vatiCAN implementation [34]. Our hardware-assisted solution
on the other hand is over 11 times faster, requiring only 4,222 clock
cycles or 0.21 ms to compute a 128-bit MAC. Our vulcanized LeiA
VulCAN: Vehicular Component Authentication and Software Isolation
ACSAC’17, December 2017, San Juan, Puerto Rico, USA
Table 2: Round-trip (ping-pong) time intervals.
Scenario
Legacy
vatiCAN (extrapolated†)
Sancus+vatiCAN unprotected
Sancus+vatiCAN protected
Sancus+LeiA unprotected
Sancus+LeiA protected
Cycles
20,250
121,992
35,236
36,375
42,929
43,624
Time Overhead
–
1.01 ms
502%
6.10 ms
74%
1.76 ms
80%
1.82 ms
112%
2.15 ms
2.18 ms
115%
implementation, on the other hand, uses only 16-bit nonces, which
reduces associated data to 96 bits and MAC computation time down
to 4,049 cycles (0.20 ms).
Cryptographic acceleration is crucial to fulfil real-world auto-
motive safety requirements (e.g., automated collision avoidance) in
benign conditions. At a highway speed of 100 km/h for instance,
vatiCAN’s software-based MAC computation corresponds to a trav-
elling distance of 8 cm, whereas VulCAN cuts this distance down
to a mere 0.6 cm. Naturally, authentication overhead becomes even
more important when a message has to be processed by multiple
interacting components, such as anti-lock braking, electronic brake
force distribution, and electronic stability control systems.
Message Transmission. We furthermore investigated the overall
overhead to send an authenticated message.4 The first row of Ta-
ble 1 lists the baseline, i.e., the time required by our CAN driver
to send a plain unauthenticated message with an 11-bit standard
ID (about 0.41 ms). Recall, however, that the limited CAN payload
length requires us to send MACs in a separate authentication mes-
sage, following the actual message to be authenticated. Due to this
inherent CAN limitation, VulCAN must send two messages for ev-
ery legacy message to be authenticated. In this respect, our baseline
measurement in Table 1 includes the time needed by the transceiver
chip to initiate transmission and signal acknowledgement from the
receiver device. Our driver also includes an option, however, to
return immediately after loading the relevant device registers, and
without waiting for the transmission to complete successfully. This
option is used in our vulcanized vatiCAN/LeiA implementations
when sending the legacy message that is to be authenticated. By
unblocking immediately after submitting the legacy payload for
transmission, VulCAN can start the MAC computation early on,
and only afterwards wait for acknowledgement of the legacy and au-
thentication messages. This optimization technique makes that the
overall time to send one authenticated message can still be slightly
less than the time to send two unauthenticated legacy messages.
As an important consequence of Sancus’ hardware-level crypto-
graphic primitives, our vulcanized vatiCAN/LeiA implementations
compute MACs in only half the time required to send a message,
whereas MAC computation in software-only vatiCAN easily out-
weighs the message transmission time (with almost a factor 6).
Comparing the third and fourth rows of Table 1 indeed reveals
that the total relative overhead for sending an authenticated mes-
sage with Sancus+vatiCAN decreases the relative overhead with
4 We focus on message sending here, since authenticated message reception delays
inherently rely on the behavior of the sender. We assess overall send/receive overhead
in a round-trip time macro benchmark.
Figure 5: Round-trip time experiment timing overview.
a staggering 534%, as compared to the extrapolated software-only
vatiCAN case. Regarding LeiA, the second row of Table 1 reveals
that sending a legacy CAN message with an extended 29-bit identi-
fier is slightly more expensive (about 18%), as extra device registers
must be loaded. This explains why the overall overhead for San-
cus+LeiA is slightly larger than that of vulcanized vatiCAN.
In the last experiment, we not only use Sancus’ hardware-level
encryption, but also leverage its software isolation primitive to
maintain key secrecy on a partially compromised ECU. More specif-
ically, we construct CAN messages and their corresponding MACs
in a PM, such that keys are never exposed to untrusted system soft-
ware. As compared to the unprotected case, Sancus+vatiCAN/LeiA
now also has to transparently copy message memory buffers to
and from the unprotected CAN driver. Previous work [30, 44] has
demonstrated that such protection domain switches come with
a limited performance penalty, which is indeed reflected with a
modest 5 to 6% execution time overhead in Table 1.
Round-Trip Time. To assess authentication delays in a sender/
receiver scenario, we performed a round-trip time experiment. One
ECU first broadcasts an 8-byte CAN frame and upon successful
reception, the receiver ECU immediately broadcasts a reply mes-
sage. For a legacy, unauthenticated CAN network, we measured a
ping-pong time interval of 1.01 ms to exchange two messages in
total. On an authenticated CAN network, four messages have to
be exchanged, and sender and receiver each have to compute two
MACs, as shown in Fig. 5.
Table 2 lists the results of the round-trip time experiment. Since
twice the amount of messages have to be exchanged (to carry the
authentication codes), the performance overhead to be expected
is again around 100%. As compared to Table 1, however, the rela-
tive overhead for vulcanized vatiCAN/LeiA decreased even further,
down to respectively 74% and 112%. This reflects the fact that mes-
sages now also have to be received and processed by the receiver,
making the contribution of MAC computation less important in
the overall timing. Likewise, the induced Sancus software protec-
tion overhead amounts only 3 to 6%, and can be expected to drop
even further if the protected modules spend more time processing
the message. The extrapolated measurements for software-only
vatiCAN on the other hand, demonstrate once more that software-
level MAC calculation remains dominant, increasing the relative
overhead with over 400%.
We acknowledge that the above overheads may be prohibitive
for some existing real-world applications. Evaluating this is beyond
SenderReceiverpingping_authpongpong_authcomputeMACpinдcomputeMACponдcomputeMACpinдcomputeMACponдround-triptimeACSAC’17, December 2017, San Juan, Puerto Rico, USA
Jo Van Bulck, Jan Tobias Mühlberg, and Frank Piessens
Figure 6: Hardware-in-the-loop application scenario with
original instrument clusters and Sancus-enabled ECUs.
the scope of this paper. However, in comparison with state-of-the-
art software-only solutions, our results show that VulCAN can
target a substantially larger class of safety-critical applications
where real-time deadlines must be satisfied. Ultimately, the choice
of authentication protocol, communication technology, and trusted
computing platform remains application-specific.
6 AN EXTENDED APPLICATION SCENARIO
To explore the feasibility of our approach in actual application
scenarios, we constructed a moderate-sized automotive test bench.
Figure 6 shows a photograph of our setup, which consists of two
off-the-shelf automobile instrument clusters from the 2014 Seat
Ibiza model, and six Sancus-enabled ECUs that were configured
as described in Section 5. We furthermore attached a CAN-to-USB
convertor to be able to monitor traffic and inject CAN messages
from an ordinary laptop computer.
Application Overview. Figure 7 provides a simplified schematic of
the demo scenario. It involves a central ECU that hosts a protected
Sancus software module PMcs to securely process commands from
the legitimate motorist. To this end, we attach a keypad device that
abstracts the motorist’s interaction with the vehicle (i.e., steering
wheel and braking/accelerator pedals). To gain exclusive access to
the keypad peripheral, PMcs securely links to a local PMkey MMIO
driver assembly module, as explained in Section 2.2. For demon-
stration purposes, we also attached a second unprotected keypad,
which is colored red and sensed by attacker code to represent an
adversary with CAN message injection capabilities and arbitrary
unprotected code execution on the central ECU.
The setup further features four wheel ECUs that each simulate
an actuator (brake), abstracted by a peripheral LED display that
displays the current wheel RPM. Each wheel ECU hosts a protected
software module PMrpm that listens to authenticated CAN mes-
sages from the central system to update individual wheel RPM on
the local LED display via a secure MMIO driver module PMled.
Figure 7: Schematic of the demo scenario depicted in Fig. 6.
The two vehicle instrument clusters finally represent unmodified
legacy devices, where one is directly connected to the untrusted
CAN bus, and the other is shielded by means of a Sancus-enabled
gateway. The gateway ECU hosts a PMдw component that listens
to selected instrument cluster IDs on the global CAN bus, making
sure that only authenticated messages are forwarded. To prevent
untrusted software on the gateway ECU from injecting messages
directly on the CAN bus that connects to the shielded dashboard, we
include the CAN driver code in the PMдw protection domain, and
rely on a small PMspi assembly module to secure the interaction
with the MMIO-based SPI master peripheral that communicates
with the CAN controller
Discussion. An important benefit of our vulcanized vatiCAN/LeiA
software libraries, is that CAN authentication remains largely trans-
parent to the distributed application components. At the application
level, we programmed PMcs to accept keypad commands for speed-
ing up/down and steering left/right. In response to these events,
authenticated CAN messages are created that respectively update
the instrument’s cluster RPM needle and turning light indicators.
The distributed wheel ECUs respond to authenticated messages
to update their individual wheel RPM, where the central system
applies slightly more traction to the outer wheels while turning, as
commonly performed in automotive traction control systems. The
attacker keypad offers the same functionality, and indeed triggers
responses on the unprotected instrument cluster. However, criti-
cal PM components safely reject attacker-generated messages. In
particular, PMдw does not forward the spoofed CAN message to
the secure dashboard, but instead creates a message that triggers a
warning light indicator to notify the motorist of the ongoing attack.
Our solution encompasses untampered CAN authentication and
application-level message processing, as well as secure I/O. We
thus guarantee that any critical actuator event (i.e., wheel LED
display change or secure dashboard update) can only be caused by
a chain of processing events that can ultimately be traced back to the
authenticated component PMkey that originally sensed the keypad
input, provided by the motorist herself. Importantly, our approach
maintains this guarantee even when an attacker compromised the
network and the unprotected software stack on participating ECUs.
VulCAN: Vehicular Component Authentication and Software Isolation
ACSAC’17, December 2017, San Juan, Puerto Rico, USA
7 RELATED WORK
Authentication on the CAN. Besides vatiCAN [34] and LeiA [38],
a range of protocols and approaches for implementing authentica-
tion in automotive bus systems have been proposed, however these
do not comply with the AUTOSAR [3] industry recommendations.
CANAuth [46] and LiBrA-CAN [15] propose authentication pro-
tocols for the CAN+ [51] specification. These schemes are back-
wards compatible so that authentication-aware ECUs can co-exist
with legacy ECUs. Upgraded hardware, modified CAN transceivers
and more powerful ECUs, are required to implement the protocols
and cryptographic algorithms, however. For example LiBrA-CAN
was evaluated on high-end ECUs and laptop CPUs, showing cryp-
tographic performance comparable to our approach. VulCAN pro-
vides similar authenticity while being AUTOSAR-compliant, and
relying on much lighter ECUs and off-the-shelf CAN hardware.
MaCAN [7, 16] does not require specifically adapted CAN trans-
ceivers but divides 8-byte CAN data into a 4-byte payload and
a 4-byte MAC. Furthermore, the protocol requires network-wide
trusted key- and time servers. The secrecy of credentials in MaCAN
has been proven in [7] under a passive attacker model. LCAP [17]
requires only 2 bytes of a CAN message to carry authentication
information, but uses a large number of addresses (IDs) and mes-
sages to achieve node synchronization. CaCAN [23] introduces a
central monitor node, which authenticates other ECUs and destroys
unauthorized frames in real-time using custom CAN hardware.
All the above approaches require some form of specialized hard-
ware to efficiently implement cryptography and to allow for specific
operation on the CAN. The challenges of key distribution, software
integrity, and key confidentiality in the presence of active ECU
attackers, remain unaddressed. The VulCAN solution, on the other
hand, aims for strictly stronger security guarantees and implements
those by means of lightweight trusted computing technology.
A recent, comprehensive study [12] on the abilities of CAN
network-level attackers shows that eavesdropping, message mod-
ification and ECU impersonation are not the only attack vectors
in automotive control networks. From an availability perspective,
selected target nodes could for instance be muted completely. Such
attack vectors cannot be addressed by means of cryptography alone,
but require physical isolation of safety-critical control networks,
plus a notion of software security that prevents unauthorized soft-
ware from abusing existing CAN hardware (cf. Section 6).
Trusted Execution Technology in Cars. The idea of relying on
trusted computing components to develop secure automotive con-
trol systems was first coined in 2008 [35]. With the goal of at-
testing vehicular computing infrastructures, and providing addi-
tional security capabilities such as accelerated cryptography and
key management, few implementations that leverage trusted exe-
cution technology [20] have been published. One such approach
explored by the EVITA project, uses the Hardware Security Mod-
ule (HSM) [49], a secure co-processor for accelerated ciphers, key
storage, random number generation, and a secure clock. HSM runs
at several hundred MHz and consequently exhibits significantly
better cryptographic performance than Sancus, yet, it also relies
on a substantially larger and more expensive hardware TCB. With
Vector’s MICROSAR [14], operating system support and CPU infras-
tructure for an HSM-like co-processor is commercially available.
Lightweight PMA-based trusted computing architectures such
as Sancus provide strictly stronger security guarantees. Most impor-
tantly, PMAs are capable of not only attesting software components
at boot time, but also isolating them at runtime to maintain security
guarantees over the entire lifetime of the program. Our choice for
Sancus is motivated by a recent exhaustive PMA overview [24]
that indicates Sancus is the only embedded architecture with an
open-source hardware design and software tool chain.
Related PMA Use Cases. Sancus has been previously applied in a
secure smart metering infrastructure [29]. The security guarantees
that Sancus provides in this distributed application scenario have
been generalized and partly formalized [32], and are similar to our
approach. Yet, real-time requirements are relaxed in comparison
with automotive applications. An approach to securely share sys-
tem resources on Sancus has been proposed [44], and subsequent
research [45] has provided insight into implementing secure PM in-
terruptability and scheduling to ensure real-time responsiveness on
Sancus platforms. We expect these developments to further improve
our approach in terms of availability guarantees. Secure interrup-
tion of hardware-enforced embedded PMs was first explored in
TrustLite [21]. Subsequent work developed TyTAN [6], a minimal
software-based root of trust for dynamic attestation of interrupt-