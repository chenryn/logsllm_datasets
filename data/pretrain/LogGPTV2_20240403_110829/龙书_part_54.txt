&yylval);
第4章
它
口
---
## Page 205
4.10第4 章总结
的单一列表，并且元素顺序和它们在输人中的顺序相同。
元素可以是任意的单个字符，而不仅仅是α)作为输人，并输出这个列表的线性表示，即这些元素
作为输人，并计算出这个表达式的值。
4.9.5 4.9节的练习
自动机的转换表。
且是参数可以是任意字符，而不仅仅是α)作为输人，并输出--个能够识别相同语言的不确定有
-样的字符序列)。
语法分析
！！练习 4.9.4：编写一个 Yacc 程序。它以正则表达式（如练习 4.2.2（4）中文法的定义的,
！练习4.9.3：编写一个 Yacc 程序。它的功能是说明输人是否一个回文（即向前和向后读都
！练习4.9.2：编写一个Yacc 程序。它以列表(如练习4.2.2(5)中的文法所定义的，但是其
！练习 4.9.1：编写一个Yacc 程序。它以布尔表达式(如练习4.2.2(7)中的文法所描述的)
1
●语法分析器。语法分析器的输人是来自词法分析器的词法单元序列。它将词法单元的名
?
个产生式由头部(将被替换的非终结符号)和产生式体(用来替换的文法符号串)组成。
所代表的符号串。这些部件可以是终结符号，也可以是另外一些非终结符号所代表的串。
语法构造的符号）和一组产生式。每个产生式说明了如何从一些部件构造出某个非终结符号
也可以显式生成分析树。
出一棵语法分析树。可以象征性地构造这棵语法分析树（即仅仅遍历相应的推导步骤），
字作为一个上下文无关文法的终结符号。然后，语法分析器为它的词法单元输人序列构造
expr
lines
%left
%token NUMBER
#define YYSTYPE double /* double type for Yacc stack */
#include
ight UMINUS
expr
expr
("outl snotaaid Iaqueaiu)iolia j ,u\, ro1ra
lines
图4-61带有错误恢复的桌面计算器
rdxe
empty */
1
expr
expr
expr
expr
+\n'
yyerrok;}
{ printf("%g\n", $2);}
势
势
》
=$1+
=$2;}
$3：
189
1
---
## Page 206
·推导。从文法的开始非终结符号出发，不断将某个非终结符号替换为它的某个产生式体的过程
190
?
?
®
面。如果没有语法分析动作冲突，那么这个文法就是 SLR 的，就可以应用这个方法。所谓
简单 LR 语法分析器。在一个 SLR 语法分析器中，我们按照某个点在最右端的有效项进行
如果下一个输人符号出现在某个有效项的点的右边，我们就会把向前看符号移入栈中。
语法分析树。一棵语法分析树是--个推导的图形表示。在推导中出现的每一-个非终结符号都在
称为推导。如果总是替换最左(最右)的非终结符号，那么这个推导就称为最左推导(最右推导)。
归约的条件是：向前看符号能够在某个句型中跟在该有效项对应的产生式的头符号的后
人－归约决定。如果项集中某个有效项的点在产生式体的最右端，那么我们就进行归约；
LR 状态)，并且在栈中跟踪每个可行前缀的状态。有效项集合引导语法分析器做出移
包括项中位于点左边的所有符号，但是不包含点右边的任何符号。
有效项。在--个产生式的体中某处加上一个点就得到一个项。一-个项对某个可行前缀有
句型的最右推导过程中在最后一步加入此句型中的子串。
最右句型的前缀，且这个前缀的结尾不会比这个句型的句柄的结尾更靠右。句柄是在这个
可行前缀。在移人－归约语法分析过程中，栈中的内容总是一个可行前缀一
号进行归约。归约步骤将栈顶部的一个产生式体替换为这个产生式的头。
符号(向前看符号)和栈中的内容，选择是将下一个输入移人栈中，还是将栈顶部的某些符
移
式。在某些或所有没有合法产生式的空条目中放置错误处理例程有助于实现错误恢复。
来扩展一个给定的非终结符号，那么这个文法就称为是 LL(1)的。这类文法允许我们构造出一
LL(1)语法分析器。对于一个文法，如果只需要查看下一个输入符号就可以选择正确的产生式
用。当选择了错误的产生式时，有可能需要进行回溯。
的时候和输人中的符号进行匹配，而产生式体中的非终结符号则引发对它们的过程的调
输人并确定应该对它的非终结符号应用哪个产生式。相应产生式体中的终结符号在适兰
递归下降语法分析器。这些分析器对每个非终结符号使用一个过程。这个过程查看它自
有相同的产生式体前缀的多个产生式进行分组。
号开头的符号串的情况。我们还必须提取左公因子一
文法的设计。和自底向上语法分析器使用的文法相比，适合进行自顶向下语法分析的文法
（从文法的开始符号出发，从顶部开始构造语法分析树）和自底向上的（从构成语法分析树叶
自顶向下和自底向上语法分析。语法分析器通常可以按照它们的工作方式分为自顶向下的
然而，有时使用二义性文法并应用一些技巧可以得到更加高效的语法分析器。
我们可以对一个二义性文法进行重新设计，使它变成一个描述相同语言的无二义性文法。
或多个最左推导/最右推导，那么这个文法就称为二义性文法。在实践中的大多数情况下，
二义性。如果一个文法的某些终结符号串有两棵或多棵语法分析树，或者等价地说有两个
法符号串。在同-终结符号串的语法分析树、最左推导、最右推导之间存在---对应关系。
树中有一个对应结点。一个结点的子结点就是在推导中用来替换该结点对应的非终结符号的文
多入－归约语法分析技术。自底向上语法分析器一般按照如下方式运行：根据下一个输
1常较难设计。我们必须要消除文法的左递归，即一个非终结符号推导出以这个非终结符
结点的终结符号串开始，从底部开始构造语法分析树）。自顶向下的语法分析器包括递归
一也就是对同一个非终结符号的具
一也就是某个
第4章
的
---
## Page 207
作。自顶向下语法分析器生成工具包括 Antr[27]和 LGern。Antlir是一个递归下降语法分析器生成工
行性。Yacc 语法分析器生成工具的使用手册可以在[20]中找到。在[10]中描述了Yacc 的开源版本 Bi-
的 LALR[8]和 SLR[9]方法。为二义性文法构造 LR 语法分析表的方法来自[1]和[12]。
出了一个方法来为典型的程序设计语言生成适当大小的语法分析表。DeRemer 发明了现在使用
语法分析表要比当时常用计算机的主存大，所以这个方法被认为不可行的，直到Korenjak[23］给
们可以被看作是使LR 分析技术取得进展的先驱技术。
[29］将这个思想推广到了语言中不包含运算符的部分。现在已经很少使用这些技术了，但是它
的线性时间模拟方法来自[3]。
TMG[25］）所选择的方法。LL文法由Lewis 和 Stearns[24］引人。练习 4:4.5 中的递归下降方法
想来自[6]。［17]中总结了上下文无关文法的理论。
者 Panini 也在公元前400 到200 年之间发明了一种等价的语法表示方法，用来描述梵语文法的规则。
语言的语法描述中也使用了这种思想。这两个语言是Backus 的 Fortran[2]和 Naur 的 Algol 60[26]。学
4. 11 
递归下降语法分析技术是早期编译器（比如［16］）和编译器编写系统（比如 META[28］和
文法二义性现象最早是由 Cantor[4]和 Floyd[13］观察到的。Chomsky 范式（练习 4.4.8)的思
语法分析
LR语法分析器是由 Knuth[22］引入的，该著作首先给出了规范-LR 语法分析表。因为这
由 Floyd[14]提出的最早的一种语法分析技术考虑了运算符的优先级问题。Wirth 和 Weber
上下文无关文法的形式化表示是作为自然语言研究的一部分由 Chomsky[5]提出的。在两个早期
●Yacc。语法分析器生成工具Yacc 以一个（可能的）二义性文法以及冲突解决信息作为输
●规范LR 语法分析器。这是一-种更复杂的LR语法分析器。它使用的项中增加了一个向前
®
第 4 章参考文献
函数。该函数在执行每一个归约动作时都会调用和相应产生式关联的函数。
人，构造出LALR 状态集合。然后,它生成一个使用这些状态来进行自底向上语法分析的
被扩展应用于很多二义性文法中。
时，我们可以使用二义性文法，并利用一些附加的信息，比如运算符的优先级，来解决移
二义性文法的自底向上语法分析。在很多重要的场合下，比如对算术表达式进行语法分析
是实践中经常选择的方法。
析器中出现的某些语法分析动作冲突不会出现在LALR 语法分析器中。LALR 语法分析器
时，我们才可以决定按照这个项的产生式进行归约。一个规范LR语法分析器可以避免某
存在一个点在最右端的有效项，并且当前的向前看符号是这个项允许的向前看符号之
看符号集合。当应用这个产生式进行归约时，下一-个输入符号必须在这个集合中。只有当
没有语法分析动作冲突，就是说对于任意项集和任意向前看符号，都不存在两个要归约的
入和归约之间的冲突，或者两个不同产生式之间的归约冲突。这样，LR 语法分析技术就
合并到一-起。因此，它的状态数量和SLR 语法分析器的状态数量相同，但是在SLR语法
器的很多优点。它将具有相同核心(忽略了相关向前看符号集合之后的项的集合)的状态
向前看 LR 语法分析器。LALR 语法分析器同时具有 SLR 语法分析器和规范 LR 语法分
语法分析器的状态更多。
些在SLR语法分析器中出现的分析动作冲突，但是它的状态常常会比同一个文法的 SLR
产生式，也不会同时存在归约或移入的可选动作。
191
Y
---
## Page 208
的复杂度是 0(n²），但是对于无二义性文法，它的复杂度只有 0(n²)。
通用算法，它以表格的方式给出一-个给定输人的各个子串的LR-项。虽然这个算法在一般情况下
Kasami[21］各自独立发明的，因此被命名为“CYK算法”。Earley[11］还发明了--种更加复杂的
具，它接受以C++、Java 或C#编写的语义动作。LLGen 是一个基于 LL[1]的生成工具。
练习 4.4.9 中描述的通用动态规划语法分析算法是由J. Cocke(未发表)和Younger[30}以及
192
Dain[7]给出了-个关于语法错误处理的文献列表。
15. Grune, D and C. J. H. Jacobs, 
14.
12. Earley, J., “Ambiguity and precedence in syntax description," Acta In-
11. Earley, J., "An eficient context-free parsing algorithm," Commm. ACM
10. Donnelly, C. and R. Stallman, “Bison: The YACC-compatible Parser
8. DeRemer, F., “Practical Translators for LR(k) Languages," Ph.D. thesis
7. Dain, J., “"Bibliography on Syntax Error Handling in Language Transla
6.0
4. Cantor, D. C., “On the ambiguity problem of Backus systems," J. ACM
3. Birman, A. and J. D. Ulman, “Parsing algorithms with backtrack,”" In-
 2. Backus, J.W, *The syntax and semantics of the proposed international
9.
Floyd, R. W., “Syntactic analysis and operator precedence,” J. ACM 10:3
Floyd, R. W., "On ambiguity in phrase-structure languages," Comm.
13:2 (Feb., 1970), pp. 94-102.
 Chomsky, N., “On certain formal properties of grammars,” Information
+
formation and Control 23:1 (1973), pp. 1-34.
ambiguous grammars," Comm. ACM 18:8 (Aug., 1975), pp. 441-452.
(1963), pp. 316-333.
ACM 5:10 (Oct., 1962), Pp. 526-534.
formatica 4:2 (1975), pp. 183-192.
Generator," http: //www .gnu.org/software/bison/manual/ .
pp. 453--460.
MIT, Cambridge, MA, 1969.
http://compilers.iecc.com/comparch/article/91-04-050.
9:4 (1962): pp. 477-479.
Conf. Information Processing, UNESCO, Paris, (1959) pp. 125-132.
algebraic language of the Zurich-ACM-GAMM Conference,"
rasred (1)TT Aipuanu-rauureiaond V,
18:1 (Jan., 1988), pp. 29-
wsgroup;see
Proc. Intl
第 4 章
---
## Page 209
语法分析
18. Hudson, S. E. et al., "CUP LALR Parser Generator in Java," Available
17. Hopcroft, J. E., R. Motwani, and J. D. Ulman, Introduction to Automata
  o g m n  ,    ' 91
29.
8
2