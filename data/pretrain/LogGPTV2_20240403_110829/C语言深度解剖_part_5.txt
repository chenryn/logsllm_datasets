…
- 24 -
default:
break;
}
【规则1-22】把正常情况放在前面，而把异常情况放在后面。
如果有多个正常情况和异常情况，把正常情况放在前面，并做好注释；把异常情况放在
后面，同样要做注释。比如：
switch(variable)
{
////////////////////////////////////////////////////////////////////
///////////////
//正常情况开始
case A:
//program code
break;
case B:
//program code
break;
//正常情况结束
////////////////////////////////////////////////////////////////////
//////////////////
//异常情况开始
case -1:
//program code
break;
//异常情况结束
////////////////////////////////////////////////////////////////////
//////////////////
…
default:
break;
}
【规则1-23】按执行频率排列case 语句把最常执行的情况放在前面，而把最不常执行
的情况放在后面。最常执行的代码可能也是调试的时候要单步执行的最多的代码。如果放在
后面的话，找起来可能会比较困难，而放在前面的话，可以很快的找到。
1.8.4 使用 case 语句的其他注意事项
【规则1-24】简化每种情况对应的操作。
使得与每种情况相关的代码尽可能的精炼。case 语句后面的代码越精炼，case 语句
的结果就会越清晰。你想想，如果case 语句后面的代码整个屏幕都放不下，这样的代码谁
也难看得很清晰吧。如果某个case 语句确实需要这么多的代码来执行某个操作，那可以把
这些操作写成一个或几个子程序，然后在case 语句后面调用这些子程序就ok 了。一般来
说case语句后面的代码尽量不要超过20 行。
【规则1-25】不要为了使用case 语句而刻意制造一个变量。
- 25 -
case 语句应该用于处理简单的，容易分类的数据。如果你的数据并不简单，那可能使
用if else if 的组合更好一些。为了使用case 而刻意构造出来的变量很容易把人搞糊涂，
应该避免这种变量。比如：
char action = a[0];
switch (action)
{
case ‘c’:
fun1（）；
break;
case ‘d’:
…
break;
default:
}
这里控制case 语句的变量是action。而action 的值是取字符数组a 的一个字符。但
是这种方式可能带来一些隐含的错误。一般而言，当你为了使用case 语句而刻意去造出一
个变量时，真正的数据可能不会按照你所希望的方式映射到case 语句里。在这个例子中，
如果用户输入字符数组a 里面存的是“const”这个字符串，那么case 语句会匹配到第一
个case上，并调用fun1（）函数。然而如果这个数组里存的是别的以字符c 开头的任何字
符串（比如：“col”，“can”），case 分支同样会匹配到第一个case 上。但是这也许
并不是要的结果，这个隐含的错误往往使人抓狂。如果这样的话还不如使用if-else if 组
合。比如：
if（0 == strcmp(‚const‛，a））
{
fun1();
}
else if
{
…
}
【规则1-26】把default 子句只用于检查真正的默认情况。
有时候，你只剩下了最后一种情况需要处理，于是就决定把这种情况用default 子句
来处理。这样也许会让你偷懒少敲几个字符，但是这却很不明智。这样将失去case 语句的
标号所提供的自说明功能，而且也丧失了使用default 子句处理错误情况的能力。所以，
奉劝你不要偷懒，老老实实的把每一种情况都用case 语句来完成，而把真正的默认情况的
处理交给default 子句。
1.9 do、while、for 关键字
C 语言中循环语句有三种：while 循环、do-while 循环、for 循环。while 循环：
先判断while 后面括号里的值，如果为真则执行其后面的代码；否则不执行。while（1）
表示死循环。死循环有没有用呢？看下面例子：
比如你开发一个系统要日夜不停的运行，但是只有操作员输入某个特定的字符‘#’才
可以停下来。
- 26 -
while（1）
{
if(‘#’== GetInputChar())
{
break;
}
}
1.9.1 break 不 continue 的区别
break 关键字很重要，表示终止本层循环。现在这个例子只有一层循环，当代码执行
到break 时，循环便终止。如果把break 换成continue 会是什么样子呢？continue 表示
终止本次（本轮）循环。当代码执行到continue 时，本轮循环终止，进入下一轮循环。
while（1）也有写成while(true) 或者while(1==1) 或者while((bool) 1)等形式
的，效果一样。
do-while 循环：先执行do 后面的代码，然后再判断while 后面括号里的值，如果为
真，循环开始；否则，循环不开始。其用法与while 循环没有区别，但相对较少用。
for 循环：for 循环可以很容易的控制循环次数，多用于事先知道循环次数的情况下。
留一个问题：在switch case 语句中能否使用continue 关键字？为什么？
1.9.2 循环语句的注意点
【建议1-27】在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循
环放在最外层，以减少CPU 跨切循环层的次数。
例如：
【建议1-28】建议for 语句的循环控制变量的取值采用“半开半闭区间”写法。半开
半闭区间写法和闭区间写法虽然功能是相同，但相比之下，半开半闭区间写法写法更加直观。
- 27 -
【规则1-29】不能在for 循环体内修改循环变量，防止循环失控。
【规则1-30】循环要尽可能的短，要使代码清晰，一目了然。
如果你写的一个循环的代码超过一显示屏，那会让读代码的人发狂的。解决的办法由两
个：第一，重新设计这个循环，确认是否这些操作都必须放在这个循环里；第二，将这些代
码改写成一个子函数，循环中只调用这个子函数即可。一般来说循环内的代码不要超过20
行。
【规则1-31】把循环嵌套控制在3 层以内。
国外有研究数据表明，当循环嵌套超过3 层，程序员对循环的理解能力会极大的降低。
如果你的循环嵌套超过3 层，建议你重新设计循环或是将循环内的代码改写成一个子函数。
1.10 goto、return 关键字
1.10.1 goto 关键字
一般来说，编码的水平与goto 语句使用的次数成反比。有的人主张慎用但不禁用goto
语句，但我主张禁用。关于goto 语句的更多讨论可以参看Steve McConnell 的名著
《CodeComplete. Second Edition》。
【规则1-32】禁用goto 语句。
自从提倡结构化设计以来，goto 就成了有争议的语句。首先，由于goto 语句可以灵
活跳转，如果不加限制，它的确会破坏结构化设计风格；其次，goto 语句经常带来错误或
隐患。它可能跳过了变量的初始化、重要的计算等语句，例如：
struct student *p = NULL;
…
goto state;
p = (struct student *)malloc(…); //被goto 跳过,没有初始化
{
⋯
}
- 28 -
{
⋯
}
state:
//使用p 指向的内存里的值的代码
⋯
如果编译器不能发觉此类错误，每用一次goto 语句都可能留下隐患。
1.10.2 return 关键字
return 用来终止一个函数并返回其后面跟着的值。
return （Val）；//此括号可以省略。但一般不省略，尤其在返回一个表达式的值时。
return 可以返回些什么东西呢？看下面例子：
char * Func(void)
{
char str[30];
…
return str;
}
str 属于局部变量，位于栈内存中，在Func 结束的时候被释放，所以返回str 将导致
错误。
【规则1-38】return 语句不可返回指向“栈内存”的“指针”，因为该内存在函数体
结束时被自动销毁。
留个问题：
return ；
这个语句有问题吗？如果没有问题，那返回的是什么？
1.11 void 关键字
void 有什么好讲的呢？如果你认为没有，那就没有；但如果你认为有，那就真的有。
有点像“色即是空，空即是色”。
1.11.1 void a？
void 的字面意思是‚空类型‛，void *则为‚空类型指针‛，void *可以指向任何类型
的数据。void 几乎只有‚注释‛和限制程序的作用，因为从来没有人会定义一个void 变量，
看看下面的例子：
void a;
Visual C++6.0 上，这行语句编译时会出错，提示‚illegal use of type 'void'‛。
不过，即使void a 的编译不会出错，它也没有任何实际意义。
void 真正发挥的作用在于：
（1） 对函数返回的限定；
- 29 -
（2） 对函数参数的限定。
众所周知，如果指针p1 和p2 的类型相同，那么我们可以直接在p1 和p2 间互相赋值；
如果p1 和p2 指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的
指针类型转换为左边指针的类型。例如：
float *p1;
int *p2;
p1 = p2;
其中p1 = p2 语句会编译出错，提示‚'=' : cannot convert from 'int *' to 'float
*'‛，必须改为：
p1 = (float *)p2;
而void *则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换：
void *p1;
int *p2;
p1 = p2;
但这并不意味着，void *也可以无需强制类型转换地赋给其它类型的指针。因为‚空类
型‛可以包容‚有类型‛，而‚有类型‛则不能包容‚空类型‛。比如，我们可以说‚男人和女人
都是人‛，但不能说‚人是男人‛或者‚人是女人‛。下面的语句编译出错：
void *p1;
int *p2;