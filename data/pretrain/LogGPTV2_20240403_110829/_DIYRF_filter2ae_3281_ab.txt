            "data": "01100101100110011001100101101001011010010110011010101010101010100101010101101001011010101010101010101010101",
            "header_pos": 103575,
            "preamble_pos": 102895
    }
        ]
      }
    ]
一旦确认，我就会对这些数据进行列表，并将其插入我的电子表格进行进一步处理。不幸的是，每次捕获信号的 bits量已经大到让我失去理智：
我认为如果以曼彻斯特编码方式进行解码可能会有更好的效果。为此，我又写了一个脚本，将原始捕获数据按照曼彻斯特编码进行处理（或其他编码类型）。在将这些数据计入电子表格时，我逐渐得到了更加合理的答案。
观察这些数据，我们立即可以得到这些bits和其用途之间所存在的一些联系：
6bits用于频道（C）
2bits用于动作（A）
6bits用于某些校验和，似乎是动作和频道的一个函数。 F(A, C)
行动改变时发生变化
频道改变时发生变化
没有频道是相同的，因此不能确定是否会因遥控器不同而发生变化。
1bit似乎是动作的一个函数 F(A)
1bit似乎是F(A)的一个函数，于是，G(F(A))。它取决于F(A)的值，有时是1对1映射，有时是反映射。
经过进一步调查，我确定对于同一个遥控器和频道来说，每个不同的动作，会使F(A, C)增加1.（如果你将这些bits看作大端格式）。
再仔细观察这些数据，我同时能够确定，对于相邻的频道，bits与C（Channel）存在递加/递减算法关联（X型遥控器递加计算，R型遥控器递减计算）。另外，F(C)还会一起增加/减少。注意C栏。
由此，我可以确认F(A, C)和C之间的关系，即F(A, C) = F(PAIR, C0) == F(PAIR, C1) ±
1。在有了这个发现之后，我确定F(A, C)和A之间也存在其他的数学联系。
**制作更多数据**
根据我们所收集的现有信息，我们似乎可以通过改变6
bits频道数据，以及按照我们上面发现的数学联系改写校验和，制作新的遥控器。这意味着我们可以从单一源频道生成64个频道。而这已足够控制房间里的所有百叶窗了。但我还是想完全解码校验和字段，从而无限量地制作遥控器。
我编写了一个工具来通过元捕获数据输出所有频道：
    ./remote-gen generate 01000110110100100001010110111111111010101
    ...
我想要生成更多数据的原因是，如果我们可以在同一个频道上查看不同的遥控器，也许我们可以确定校验和的构成方式。即R0CH0，R1CH0，X1CH0，等…
实际上，我想做的是解出下列方程式的函数G：
    F(ACTION_PAIR, CH0) == G(F(ACTION_PAIR, CH0))
然而，在查看所有频道0的PAIR捕获数据后，校验和似乎仍然是以完全混乱和随机的形式表达：
在看这些数据的同时，我又发现了另一种模式。G(F(A))的位置相比F(A)出现了整个字节的偏移（8 bits）。另外，前2 bits的F(A,
C)位于字节边界，并与A（Action）对齐。随着行动增加，F(A, C)也是如此。我们再将所有处于字节边界的bits进行排列，看看其有什么特征：
在这里，我们需要确定基于前4个字节产生的已知校验和的函数。最初，我尝试通过字节进行异或（XOR）运算：
但结果并不成功，输出结果是随机形式的数据，使用校验和与输出结构异或运算后，并没有产生常数键。因此，我推断出校验和不是通过异或运算生成的。那会不会是采用的加法呢？我们从上面已经能看到加法/减法的运算关系。
我们的推测看起来越来越有希望——相同类型遥控器的频道之间存在一个常数差异。因为我制作的项目存在漏洞，会不会不同类型遥控器的常数也存在不同？在频道或校验和变化时，我们是否没有打包正确的位数，或使用错误的字节边界？
事实证明，这就是原因所在。
**分析校验和**
查看原始捕获数据，并执行相同的模加法，我们确定校验和是通过添加前导的4个字节和加3来计算的。我无法确定为什么在这里使用3，除了瑞克斯公司（购买百叶窗的品牌）想要使其校验和的解码过程变得更多困难，或者为了确保正确的传输模式。
我改装了我的遥控器应用来处理这些刚刚识别的边界：
    type RemoteCode struct {
        LeadingBit uint // Single bit
        Channel    uint8
        Remote     uint16
        Action     uint8
        Checksum   uint8
    }
这样的一组数据可以解释我们的问题。事实证明， F(A)不是A（Action）的一个函数，它实际上是被传输的动作数据（action data）的一部分：
    type BlindAction struct {
        Name  string
        Value uint8
    }
    var validActions = []BlindAction{
        BlindAction{Value: 127, Name: "PAIR"},
        BlindAction{Value: 252, Name: "DOWN"},
        BlindAction{Value: 253, Name: "STOP"},
        BlindAction{Value: 254, Name: "UP"},
    }
另外，频道和遥控器之间的拆分或许是没有必要的。相反，这可能只是一个任意的24位整数，但是更容易的是将其拆分为8位int和16位int。基于此，我可以推断，协议可以容纳2
^ 24个遥控器（约1670万）！这将是很多的百叶窗！
最终，我在这里正式写出了校验和的函数：
    func (r *RemoteCode) GuessChecksum() uint8 {
        return r.Channel + r.Remote.GetHigh() + r.Remote.GetLow() + r.Action.Value + 3
    }
**附加工具**
我的“衍生遥控器”（remote-gen）项目是为了通过原有遥控器生成代码，但现在需要一些其他功能。
我需要一种从捕获数据中提取信息的方法，并验证在生成校验和期间，其校验和是否与我们的规则集一致。我写了一个info命令：
    ./remote-gen info 00010001110001001101010111011111101010100 --validate
    Channel:    196
    Remote:     54673
    Action:     STOP
    Checksum:          42
    Guessed Checksum:  42
运行—validate后，如果猜测的校验和！=校验和，则将显示错误并退出。在我们的所有捕获数据中运行这一进程，可以证明我们的校验和函数是正确的。
该工具所需的另一个功能是能够生成任意代码来创建我们自己的遥控器：
好了到这里，我已经可以使用这个工具来生成任何我所需要的遥控器了。
    ./remote-gen create --channel=196 --remote=54654 --verbose
    00010001101111110101010111111111010011001    Action: PAIR
    00010001101111110101010110011111101101000    Action: DOWN
    00010001101111110101010111011111111101000    Action: STOP
    00010001101111110101010110111111100011000    Action: UP
**结语**
这就是我如何逆向出一个完全模式的协议的整个过程。我未来还将和大家分享更多智能家居DIY的文章。