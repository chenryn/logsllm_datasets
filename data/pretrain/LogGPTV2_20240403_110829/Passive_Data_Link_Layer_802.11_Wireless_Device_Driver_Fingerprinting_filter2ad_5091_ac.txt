### Signature Database Optimization

The process of refining the signature database can be automated by removing signatures that do not sufficiently differ from others, based on a predefined similarity threshold. In our dataset, there was only one instance where two drivers from the same manufacturer (Linksys) had indistinguishable signatures. For this case, we retained only one signature in the master signature database. After eliminating all duplicate signatures, 31 unique signatures remained. Each signature was tagged with the corresponding driver name and configuration. The complete master signature database is provided in Appendix A.

### Test Data Collection

For test set 1, we used the unused 30-minute trace from each of the 57 raw signature traces collected during the master signature generation. This scenario verifies that our signature generation adequately captures the probing behavior of the driver and that signatures can identify their associated drivers with a limited amount of traffic. To demonstrate the repeatability and accuracy of our technique in different environments, we repeated the 57 half-hour experiments in two different physical locations. Using multiple environments helps validate the consistency and robustness of our technique, suggesting it works well outside of lab settings.

**Test Set 2:**
- **Arrangement:** The fingerprinter’s antenna was placed 25 feet from the fingerprintees, with one uninsulated drywall between them.
- **Environment:** No other 802.11 wireless traffic was detected except for that generated by the fingerprintees.

**Test Set 3:**
- **Arrangement:** The observer’s antenna was placed ten feet from the fingerprintees, with two desks and other miscellaneous objects between them.
- **Environment:** Four to twelve other wireless devices were communicating during data collection.

Test set 2 simulates a semi-isolated setting, such as a hotel room with wireless access, while test set 3 represents a more congested environment, like a coffee shop or airport.

### Fingerprinting Accuracy

Table 2 shows the accuracy of our technique in correctly identifying the wireless driver operating a NIC for the three test scenarios. These results are based on the full 30 minutes of data points. We will later explore the effects of using fewer data points on the accuracy of our technique. The results also varied based on location. As expected, our technique was most accurate for test set 1 (96%), followed by test set 2 (84%) and test set 3 (77%). These results indicate that different environments affect the accuracy, but our technique remains reliable in all tested environments.

| Test Set | Successful Identifications | Total Drivers | Accuracy |
|---------|---------------------------|---------------|----------|
| 1       | 55                        | 57            | 96%      |
| 2       | 48                        | 57            | 84%      |
| 3       | 44                        | 57            | 77%      |

Figure 4 illustrates that our technique is perfectly accurate for nine wireless drivers and over 60% successful at identifying the other eight drivers. The accuracy of identifying a particular driver depends on how dissimilar its signature is from others in the master signature database. If the correct signature is similar to another, background noise may lead to incorrect fingerprinting. These results show that most wireless drivers have distinct signatures. Even for drivers with less unique fingerprints, we still correctly identified the driver in the majority of test cases.

In cases where the technique cannot uniquely identify a driver, it can narrow down the possibilities to those with similar signatures. Although not currently supported, it is conceivable to list the signatures in the master database that are close to the unidentifiable observed signature.

### Empirical Bin Width Tuning

The bin width for signatures was empirically optimized during experimentation on test set 1 by varying the size and selecting an optimal width based on fingerprinting accuracy. We started with a bin width of 0.1 seconds and incrementally increased it by 0.1 seconds up to 5.0 seconds. Figure 5 shows that a bin width of 0.8 seconds produced the highest accuracy (96%) in test set 1, which was used for the rest of our experiments.

### Time Required to Fingerprint Driver

To address the efficiency of our technique, we investigated the data and time thresholds required to accurately fingerprint a driver. Ideally, a fingerprinter should identify a wireless driver in real-time after a small traffic trace. We measured the fingerprinting accuracy with one minute of collected data and increased the amount in one-minute increments until the full 30-minute trace was used. Figure 6 illustrates the accuracy in each of the three test cases corresponding to the amount of trace data used for fingerprinting.

Since the rate of probe request frames varies among wireless drivers, it is difficult to estimate the number of frames recorded in one minute. On average, 10.79 probe requests were detected across all testing scenarios. Our technique achieved at least 60% accuracy in each of the three test cases after one minute of traffic. These results show that our method converges relatively fast on the correct wireless driver and requires only a small amount of communication traffic.

### Limitations

During our evaluation, we discovered several limitations of our fingerprinting technique:

#### Driver Versions
Our technique was unsuccessful in distinguishing between different versions of the same wireless driver. This is a limitation since a new version might patch previous security vulnerabilities. However, even without version distinction, our fingerprints significantly reduce the number of potential wireless drivers a target system could be running.

#### Hardware Abstraction Layer
An unexpected limitation was found when testing the MadWi-Fi driver for Linux. This driver works with most Atheros chipset-based wireless cards due to the inclusion of a Hardware Abstraction Layer (HAL), creating a more homogeneous driver environment. The lack of driver diversity reduces the appeal of fingerprinting, but a single or small number of HALs magnifies any security vulnerability identified.

### Preventing Fingerprinting

Several methods can prevent our technique from successfully fingerprinting drivers:

#### Configurable Probing
Device drivers could provide options to explicitly disable or enable probe request frames. This would not only prevent fingerprinting but also conserve power and bandwidth. By default, access points transmit beacon frames, so passively listening for beacons could be an effective method of discovering access points. Another solution is to configure wireless device drivers to passively listen for beacons and only send probe requests for available networks when manually triggered by the user.

#### Standardization
Specifying the rate of probe request frame transmission in a future IEEE standard for the 802.11 MAC could prevent driver fingerprinting. However, some manufacturers may resist designing devices that expend the necessary power or bandwidth to transmit probe requests at a standard rate, making standardization unlikely.

#### Automated Noise
Generating noise in the form of cover probe request frames can disguise a driver by masking the true rate of probe request transmission. The cover traffic would need to be sufficiently random and transmit enough to confuse our technique. This approach has limitations, as it wastes bandwidth and reduces battery life, and given enough observation data, the fingerprinter might filter out the noise and successfully fingerprint the driver.