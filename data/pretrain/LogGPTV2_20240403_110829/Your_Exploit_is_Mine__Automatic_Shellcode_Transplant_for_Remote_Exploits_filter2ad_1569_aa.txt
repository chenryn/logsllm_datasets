title:Your Exploit is Mine: Automatic Shellcode Transplant for Remote Exploits
author:Tiffany Bao and
Ruoyu Wang and
Yan Shoshitaishvili and
David Brumley
2017 IEEE Symposium on Security and Privacy
Your Exploit is Mine: Automatic Shellcode
Transplant for Remote Exploits
Tiffany Bao
Ruoyu Wang
Yan Shoshitaishvili
David Brumley
Carnegie Mellon University
PI:EMAIL
UC Santa Barbara
ﬁPI:EMAIL
UC Santa Barbara
PI:EMAIL
Carnegie Mellon University
PI:EMAIL
Abstract—Developing a remote exploit is not easy. It requires
a comprehensive understanding of a vulnerability and delicate
techniques to bypass defense mechanisms. As a result, attackers
may prefer to reuse an existing exploit and make necessary
changes over developing a new exploit from scratch. One such
adaptation is the replacement of the original shellcode (i.e., the
attacker-injected code that is executed as the ﬁnal step of the
exploit) in the original exploit with a replacement shellcode,
resulting in a modiﬁed exploit that carries out the actions desired
by the attacker as opposed to the original exploit author. We call
this a shellcode transplant.
Current automated shellcode placement methods are insufﬁ-
cient because they over-constrain the replacement shellcode, and
so cannot be used to achieve shellcode transplant. For example,
these systems consider the shellcode as an integrated memory
chunk, and require that the execution path of the modiﬁed exploit
must be same as the original one. To resolve these issues, we
present ShellSwap, a system that uses symbolic tracing, with a
combination of shellcode layout remediation and path kneading to
achieve shellcode transplant. We evaluated the ShellSwap system
on a combination of 20 exploits and 5 pieces of shellcode that are
independently developed and different from the original exploit.
Among the 100 test cases, our system successfully generated
88% of the exploits.
I. INTRODUCTION
Remote exploits are extremely dangerous. With the help
of remote exploits against a piece of software running on
a victim computer, an attacker can install backdoors and
exﬁltrate sensitive information without physical access to the
compromised system, leading to real-world impacts on the
ﬁnances and reputation of the victim.
However, developing a remote exploit
is not easy. A
comprehensive understanding of the vulnerability is a must,
and complex techniques to bypass defenses on the remote
system are necessary. When possible, rather than developing
a new exploit from scratch, attackers prefer to reuse existing
exploits in their attacks, making necessary changes to adapt
these exploits to new environments. One such adaptation is
the replacement of the original shellcode (i.e., the attacker-
injected code that is executed as the ﬁnal step of the exploit)
in the original exploit with a replacement shellcode, resulting
in a modiﬁed exploit that carries out the actions desired by
the attacker as opposed to the original exploit author. We
call this a shellcode transplant. Shellcode transplanting has
many applications, including reversing command and control
protocols, understanding captured exploits, and replaying
attacks. Thus, this capability is very helpful in situations ranging
from rapid cyber-response (i.e., quick analysis of and response
to 0-day attacks) and adversarial scenarios (like cyber-security
Capture-The-Flag competitions or cyber warfare in the real
world). Unfortunately, current techniques to transplant shellcode
generally require an analyst to have a decent understanding
of how the original exploit interacts with the program, what
vulnerability it triggers, and how it bypasses deployed exploit
mitigations. As a result, the analyst must put a lot of effort
into development and debugging, which negates much of the
advantage of shellcode transplanting.
In investigating this problem, we identiﬁed three main
challenges to tackling the shellcode transplant problem. First,
it is very difﬁcult to separate the shellcode from the rest of an
exploit, as there is generally no clear boundary separating
one from the other. Second, as an exploit’s shellcode is
commonly constructed through non-trivial data transformations,
even if the bytes representing the original shellcode could
be separated from the exploit, rewriting these bytes to a
replacement shellcode would be non-trivial. Third, the shellcode
and the remainder of the content in an exploit can be mutually
dependent on each other (e.g., a ﬁeld in the exploit payload
may dictate the size of the embedded shellcode). Such relations
can pose potentially complex constraints on any replacement
shellcode that might be transplanted. When those constraints
are violated by replacement shellcode, it is challenging to
modify the exploit and/or the replacement shellcode in order
for the modiﬁed exploit to function properly.
Previous work in the ﬁeld of automated exploit generation
generates exploits by constraining the memory bytes in each
attacker-controlled buffer to the target shellcode. They enumer-
ate all possible offsets in every attacker-controlled buffer until
a solution is found [12, 17]. Such methods are insufﬁcient.
In the worst case, when attempting to compensate for the
case of conﬂicting constraints on the replacement shellcode,
these methods degenerate to a symbolic exploration of the
program, which generally ends in a path explosion problem or
is hampered by the inability of the symbolic execution engine
to efﬁciently reverse complex data transformations. In fact, as
we show in our evaluation, less than a third of the original
exploits in our dataset can be modiﬁed by existing techniques.
In this paper, we present ShellSwap, an automated system
that addresses the shellcode transplant problem. ShellSwap
takes an existing exploit and a user-speciﬁed replacement
shellcode as input and produces a modiﬁed exploit
that
© 2017, Tiffany Bao. Under license to IEEE.
DOI 10.1109/SP.2017.67
824
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
targets the same vulnerability as the original exploit does
but executes the replacement shellcode after exploitation.
ShellSwap tackles the challenges discussed above with a
mix of symbolic execution and static analysis techniques,
applying novel techniques to identify the original shellcode,
recover the data transformation performed on it, and resolve
any conﬂicts introduced by the transplant of the replacement
shellcode. By utilizing information obtained from the original
exploit and creatively transforming the replacement shellcode,
ShellSwap rarely degrades to a pure symbolic exploration,
and is thus more efﬁcient and effective compared to previous
solutions.Additionally, the use of carefully-designed systematic
approaches enables ShellSwap to transplant more shellcode
variants. In our experiment, ShellSwap successfully generates
new exploits for 88% of all cases, which is almost three times
the success rate of prior techniques.
To the best of our knowledge, ShellSwap is the ﬁrst
automated system that modiﬁes exploits based on shellcode
provided by analysts. In terms of offense, ShellSwap greatly
reduces the overhead in attack reﬂection, which enables prompt
responses to security incidents like 0-day attacks, especially
in a time-constrained, competitive scenario such as a hacking
competition or cyber warfare. ShellSwap also makes it possible
for entities to stockpile exploits in bulk, and tailor them to
speciﬁc mission parameters before they are deployed at a later
time. As organizations such as the National Security Agency are
commonly known to be stockpiling caches of vulnerabilities,
such a capability can greatly reduce the overhead in using
weapons from this cache. ShellSwap is also helpful in defense,
where it can be used to debug exploits discovered in the
wild (i.e. by transplanting a piece of shellcode that is benign
or implements monitoring and reporting functionality) and
rediscover vulnerabilities being exploited.
Speciﬁcally, our paper makes the following contributions:
• We design the ShellSwap system, which is the ﬁrst end-
to-end system that can modify an observed exploit and
replace the original shellcode in it with an arbitrary re-
placement shellcode. Our system shows that the automatic
exploit reuse is possible: even a person who has little
understandings about security vulnerabilities can retroﬁt
an exploit for their custom use-case.
• We propose novel, systematic approaches to utilize in-
formation from the original exploit to prevent ShellSwap
from degenerating to inefﬁcient symbolic exploration, and
revise the replacement shellcode without changing its
semantics to ﬁt constraints implicit to the original exploit.
Those approaches are essential to the performance of
ShellSwap.
• We evaluate our system on 100 cases — 20 original
exploits, each with 5 different pieces of shellcode. Our
system successfully generates modiﬁed exploits in 88% of
our test set, and all new exploits work as expected. We
also compare our system with the previous state of the art,
and we ﬁnd that previous methods only work for 31% of
our test set. The fact that ShellSwap exhibits a success rate
almost triple that of the previous solution implies that the
impact of the challenges inherent in shellcode transplant
were under-estimated, and that future work targeting this
problem will be beneﬁcial.
II. OVERVIEW
ShellSwap takes, as an input, a vulnerable program, the
original exploit that had been observed being launched against
this program, and a replacement shellcode that the original
shellcode in the original exploit should be replaced with. Given
these inputs, it uses a combination of symbolic execution and
static analysis to produce a modiﬁed exploit that, when launched
against the vulnerable program, causes the replacement shell-
code to be executed.
Our intuition for solving the shellcode transplant problem
comes from the observation that a successful control ﬂow
hijacking exploit consists of two phases: before the hijack,
where the program state is carefully set up to enable the
hijack, and after the hijack, when injected shellcode carries
out attacker-speciﬁed actions. We call the program state after
the ﬁrst phase the exploitable state, and we call the instruction
sequence that the program executes until the exploitable state
the exploit path. An input that makes the program execute the
same path as the original exploit does will lead the program
to an exploitable state. Therefore, if we ﬁnd an input that
executes the instructions of the original exploit path in the ﬁrst
phase and the new shellcode in the second phase, that input
represents the modiﬁed exploit.
Given these inputs, it proceeds through a number of steps,
as diagrammed in Figure 1. The steps for generating the new
exploit are as follows:
Symbolic Tracing. The path generator replays the exploit
in an isolated environment and records the executed
instructions. The output of the path generator is a sequence
of instruction addresses, which we call the dynamic exploit
path.
The path generator passes the dynamic exploit path to the
symbolic tracing engine. Then tracer sets the input from
the exploit as a symbolic value and starts symbolically
executing the program. At every step of this execution,
the tracer checks if the current program state violates
a security policy. There are two reasons for this: a) we
want to double check that the exploit succeeds, and b) we
need to get the end of the normal execution and the start
of malicious computation, where the exploit diverts the
control ﬂow of the program to the shellcode. When the
tracer detects that the security policy has been violated,
it considers the trace complete and the exploitable state
reached.
The tracing engine records the path constraints introduced
by the program on the exploit input in order to reach
the exploitable state, and the memory contents of the
exploitable state itself. These will be used in the next
step to surmount challenges associated with shellcode
transplanting.
Shellcode Transplant. Shellcode transplant is the critical step
in the ShellSwap system. It takes the exploitable state, the
825
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
Original 
Exploit 
Vulnerable 
Program 
Symbolic Tracing 
Exploitable 
State 
Path 
Constraints 
Replacement 
Shellcode 
Shellcode Transplant 
Modified Exploit 
or 
Not Found 
Fig. 1: The architecture of the ShellSwap system.
path constraints, and the replacement shellcode as input,
and outputs a modiﬁed exploit that takes advantage of
the vulnerability and executes the replacement shellcode.
After this step, the system will output either the modiﬁed
exploit or an error indicating that a modiﬁed exploit could
not be found.
These steps are further described in Section III (for Symbolic
Tracing) and Section IV (for Shellcode Transplant).
ShellSwap focuses on exploits against control-ﬂow hijack-
ing vulnerabilities, which are a type of software bug that
allows an attacker to alter a program’s control ﬂow and
execute arbitrary code (speciﬁcally, the shellcode). Control-
ﬂow hijacking vulnerabilities have been considered as the most
serious vulnerabilities, since the attacker can take control of
the vulnerable system. Unfortunately, control-ﬂow hijacking
vulnerabilities are the most prevalent class of vulnerabilities
in the real world: over the past 18 years, 30.6% of reports in
the Common Vulnerabilities and Exposures database represent
control-ﬂow hijacking vulnerabilities [15]. Thus, while the
ability to reason about other types of exploits would be
interesting, we leave the exploration of this to future work.
A. Motivating Example
To better communicate the concept of shellcode transplant
and demonstrate the challenges inherent to it, we provide a
motivating example. We ﬁrst introduce a vulnerable program
and an original exploit, and then discuss the challenges posed
by two different instances of replacement shellcode.
1) Vulnerable program: Consider a vulnerable program with
source code shown in Listing 1, where the program receives a
string terminated by a newline, checks the ﬁrst character and
calculates the length of the string. Note that the source code is
for clarity and simplicity; our system runs on binary program
and does not require source code.
1
2
3
4
5
6
7
8
9
10
11
int example(){
int len = 0;
char string[20];
int i;
if (receive_delim(0, string, 50, '\n') != 0)
return -1;
if(string[0] == '^')
_terminate(0);
for(i = 0; string[i] != '\0'; i++)
len++;
return len;
12
}
Listing 1: Motivating Example.
%ebp
%
(cid:43)(cid:76)(cid:74)(cid:75)
(cid:86)
(cid:86)
(cid:72)
(cid:85)
(cid:71)
(cid:71)
(cid:68)
(cid:47)(cid:82)(cid:90)
\x00\x00\x00\x00
(cid:54)(cid:68)(cid:89)(cid:72)(cid:71)(cid:1)%eip
(cid:54)(cid:68)(cid:89)(cid:72)(cid:71)(cid:1)%ebp
(cid:54)(cid:68)(cid:89)(cid:72)(cid:71)(cid:1)%esi
int ret
int len
char string[20]
(cid:11)(cid:21)(cid:19)(cid:3)(cid:37)(cid:92)(cid:87)(cid:72)(cid:86)(cid:12)(cid:3)
(cid:171)(cid:3)
Fig. 2: The stack layout of the example function.
This program has a control-ﬂow hijacking vulnerability in the
processing of the received input. The string variable is a 20-
byte buffer deﬁned at line 3. However, the string received from
user input can have up to 50 characters, which will overﬂow
the buffer string and eventually overwrite the return address
stored on the stack if the provided string is long enough.
Figure 2 shows the stack layout of the example function.
The saved return address (shown as saved %eip) is 36 bytes
above the beginning of buffer string. This implies that if
the received input has more than 36 characters, the input will
overwrite the saved return address and change the control ﬂow
of the program when function example returns.
1