title:Seamless kernel updates
author:Maxim Siniavine and
Ashvin Goel
Seamless Kernel Updates
by
Maxim Siniavine
A thesis submitted in conformity with the requirements
for the degree of Master of Applied Science
Graduate Department of Electrical and Computer Engineering
University of Toronto
Copyright Â© 2012 by Maxim Siniavine
Abstract
Seamless Kernel Updates
Maxim Siniavine
Master of Applied Science
Graduate Department of Electrical and Computer Engineering
University of Toronto
2012
Kernel patches are frequently released to x security vulnerabilities and bugs. However,
users and system administrators often delay installing these updates because they require
a system reboot, which results in disruption of service and the loss of application state.
Unfortunately, the longer an out-of-date system remains operational, the higher is the
likelihood of a system being exploited.
Approaches, such as dynamic patching and hot swapping, have been proposed for
updating the kernel. All of them either limit the types of updates that are supported, or
require signicant programming eort to manage.
We have designed a system that checkpoints application-visible state, updates the
kernel, and restores the application state. By checkpointing high-level state, our system
no longer depends on the precise implementation of a patch and can apply all backward
compatible patches. The results show that updates to major kernel releases can be
applied with minimal changes.
ii
Acknowledgements
I would like to express sincere gratitude to my advisor Prof. Ashvin Goel for his patience
and invaluable advice. His guidance helped me all the time during research and writing
of this thesis.
I would also like to extend my thanks to all the committee members:
Professor Angela Brown, Professor Michael Stumm and Professor Raviraj Adve for their
insightful comments and hard questions. I thank my fellow graduate students Vladan
Djeric, Zoe Chow, Isaac Good, Stan Kvasov for providing an intellectually stimulating and
supportive environment. Finally I would like to thank my family for their encouragement
and support.
iii
Contents
1 Introduction
2 Related Work
3 Approach
3.1
Implementation Overview . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Quiescence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 Restarting System Calls
. . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4 Checkpoint Format and Code . . . . . . . . . . . . . . . . . . . . . . . .
4 Implementation
4.1
Implementation of checkpoint and restore . . . . . . . . . . . . . . . . . .
4.1.1 Threads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.2 Address Space . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.3 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.4 Network Sockets
. . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.4.1 UDP Sockets . . . . . . . . . . . . . . . . . . . . . . . .
4.1.4.2 TCP Sockets
. . . . . . . . . . . . . . . . . . . . . . . .
4.1.5 Pipes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.6 Unix Sockets
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.7 Terminals and Keyboard . . . . . . . . . . . . . . . . . . . . . . .
iv
1
6
11
12
14
18
20
24
24
24
25
26
28
29
30
34
36
36
4.1.8 Framebuer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.9 Mouse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2 System Call Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3 Limitations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5 Evaluation
5.1 Code Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2 Experience with Updating Kernels
. . . . . . . . . . . . . . . . . . . . .
5.3 Performance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3.1 Application Benchmarks . . . . . . . . . . . . . . . . . . . . . . .
5.3.1.1 Quake . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3.1.2 MySQL . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3.1.3 Memcached . . . . . . . . . . . . . . . . . . . . . . . . .
5.3.2 Microbenchmarks . . . . . . . . . . . . . . . . . . . . . . . . . . .
6 Conclusions
37
38
39
39
42
42
45
47
48
49
50
50
53
55
v
List of Tables
3.1 Analysis of vm_area_struct . . . . . . . . . . . . . . . . . . . . . . . . .
21
5.1 Kernel structures and checkpoint format
. . . . . . . . . . . . . . . . . .
5.2 New or modied lines of code . . . . . . . . . . . . . . . . . . . . . . . .
5.3 Summary of updates needed for checkpoint code . . . . . . . . . . . . . .
5.4 Per-application checkpoint time and size . . . . . . . . . . . . . . . . . .
5.5 Kernel restart time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43
44
46
52
52
vi
List of Figures
3.1 Timeline for regular and seamless kernel update . . . . . . . . . . . . . .
12
5.1 Quake reboot vs. update . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2 Mysql/sysbench update . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3 Memcached results after reboot vs. update
. . . . . . . . . . . . . . . .
5.4 Mmap checkpoint-restore time . . . . . . . . . . . . . . . . . . . . . . . .
48
50
51
53
vii
Chapter 1
Introduction
Operating system maintainers release kernel patches regularly to x security vulnerabili-
ties and bugs, and to add features. However, users and system administrators often delay
installing these updates because they require a system reboot, which results in disruption
of service and the loss of application state. For example, updating the operating system
for a game server requires all client users to stop playing the game, wait for the server to
come back up, login to the server, and then generally play the game from the beginning,
which is especially annoying for shooter and other real-time games.
Today, operating systems are updated infrequently because the updates have to be
managed carefully. However, the longer an out-of-date system remains operational, the
higher is the risk of a bug being triggered, or a system being exploited, since most exploits
target existing vulnerabilities. In addition, users are unable to use the new features, e.g.,
performance optimizations, available in the kernel updates.
Realizing these problems, application programmers are increasingly designing pro-
grams that can be updated without signicant disruption. For example, users of web
applications are not aware when it is updated and can start using the new version auto-
matically after they reload the page. In fact, users generally have no control over updates,
which helps avoid the need to support several application versions. Similarly, many large
1
Chapter 1.
Introduction
2
applications save and restore their state on an update (e.g., browsers restore web page
tabs), thereby reducing disruption. Operating system kernels are the major remaining
component of the software stack that require signicant time for updates and lose state
after an update.
Existing kernel update systems work at varying granularity. Dynamic patching per-
forms updates at function granularity [6, 3], and hot swapping at object or module gran-
ularity [17, 4]. These techniques require signicant programmer eort for implementing
patch, object or module-specic state transfer functions that synchronize the state of an
updated component with an existing component. For example, hot patching operates
at function granularity and can be applied relatively easily to patches that only change
code. However, carefully crafted state transfer functions are needed for patching up-
dated data structures. Similarly, object and module granularity update systems require
component-specic transfer functions for the updated stateful components, and must be
designed to handle changes to the component interfaces [4].
None of these techniques handle cross-cutting changes due to major restructuring of
code that occurs across major kernel revisions. For example, the Linux kernel is updated
on average with ve patches every hour, and developers release a major kernel release
every 2-3 months [10]. Later in the paper, we show that each of these releases often consist
of over a million lines of modied or new code. Requiring programmers to write state
transfer functions for each of their patches or modules is simply impractical, especially
when kernel patches occur so frequently and major revisions involve millions of lines of
code.
Our goal is to reliably install major kernel updates, with minimal programmer eort,
and without requiring user intervention or any changes to applications. The main insight
is that applying updates at a courser granularity reduces the required programming
eort. At higher level of abstraction implementation details are hidden which reduces
the need to write state transfer functions for each patch. Say that a transfer function
Chapter 1.
Introduction
3
exists for a stateful module. A patch that changes module internal state will not require
an additional transfer function because this state is not exposed, making the patch easier
to apply. For example, Swift et al. update device drivers at multi-module granularity
by using common driver interfaces to automatically capture and transfer state between
driver versions [19, 20].
Taking this idea to the limit, we have designed a system for the Linux kernel that
checkpoints application-visible state, reboots and updates the entire kernel, and restores
the application state. The checkpointed state consists of information exposed by the
kernel to applications via system calls, such as memory layout and open les, and via the
network, such as network protocol state. Our update system requires the least amount
of additional programmer eort for installing a patch, because it hides most kernel im-
plementation details, including interfaces between the kernel components. Furthermore,
the kernel and the applications are strongly isolated from each other by memory man-
agement hardware and communicate by passing messages, i.e., system calls. As a result,
there is no need to detect and update references from old to new data structures, or
determine when this update process can terminate, which poses challenges in dynamic
patching systems. Another signicant benet is that our system can handle all backward
compatible patches because they do not aect application-visible state. Kernel patches
generally provide such compatibility to minimize disruption. The main drawback of
rebooting the kernel is that it is human perceptible, but we believe that the main im-
pediment to applying updates today is loss of application state, rather than brief system
unavailability.
Our focus on designing a reliable and practical update system raises several challenges.
Ensuring that the system will restore applications reliably requires taking a consistent
checkpoint. When kernel data structures are inconsistent, e.g., when a system call is
in progress, a consistent checkpoint cannot be taken. Waiting for system calls to nish
is unreasonable since many system calls can block in the kernel indenitely. A third
Chapter 1.
Introduction
4
solution is to interrupt system calls, but many applications are not designed to handle
interrupted calls. Unlike dynamic patching and hot swapping methods, our solution
guarantees quiescence, allowing consistent checkpoints to be taken for all updates. For
system calls, we start with the POSIX specication for restarting system calls when a
signal occurs, and provide a method for resuming system calls transparent to applications.
A practical system should require minimal programmer eort for applying kernel up-
dates. To achieve this goal, the checkpoint format and the checkpoint/restore procedures
must be made as independent of the kernel implementation as possible. We checkpoint
data in the same format as exposed by the system call API and the network protocols.
Both are standardized, and so our checkpoint format is independent of the kernel version,
and we expect it to evolve slowly over time. An additional benet of this approach is
that we can use existing kernel functionality to convert the data to and from the kernel
to the checkpoint, since this functionality is already needed to perform these conversions
during system calls. When the kernel is updated, the updated functions will perform
the conversion correctly. To minimize changes to the checkpoint procedures, we use ker-
nel API functions as far as possible. These include system call functions and functions
exported to kernel modules, both of which evolve slower than internal kernel functions.
This work makes three contributions. First, we design a reliable and practical kernel