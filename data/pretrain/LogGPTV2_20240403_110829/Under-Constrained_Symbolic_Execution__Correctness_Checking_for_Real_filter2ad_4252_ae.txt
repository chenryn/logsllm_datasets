. . .
ret = gssp alloc receive pages(&arg);
. . .
gssp free receive pages(&arg);
. . .
struct gssp upcall data *data) {
8 :}9 :int gssp alloc receive pages(struct gssx arg accept sec context *arg) {
arg−>pages = kzalloc(. . .);
. . .
return 0;
10:
11:
12:
13: }
14: void gssp free receive pages(struct gssx arg accept sec context *arg) {
15:
16:
17:
18: }
Figure 13: Linux kernel memory leak in RPCSEC GSS proto-
col implementation used by NFS server-side AUTH GSS.
for (i = 0; i npages && arg−>pages[i]; i++)
/* missing: kfree(arg–>pages); */
free page(arg−>pages[i]);
size of 25,000 bytes and a depth bound of 9 objects.
For the Linux kernel, we included functions relevant
to each checker, as described below. Unlike our evalua-
tion in § 3.2, we did not use any manual annotations to
suppress false positives. We ran UC-KLEE for up to ﬁve
minutes on each function from BIND and the Linux ker-
nel, and up to ten minutes on each OpenSSL function.
We used the same machines as in § 3.2.
For BIND, we checked version 9.10.1-P1 (12/2014).
For OpenSSL, we checked version 1.0.2 (1/2015). For
the Linux kernel, we checked version 3.16.3 (9/2014).
Figure 12 summarizes the results. UC-KLEE discov-
ered a total of 67 previously-unknown bugs1: 12 in
BIND, 11 in OpenSSL, and 44 in the Linux kernel. Fig-
ure 14 lists the number of functions that UC-KLEE ex-
haustively veriﬁed (up to the given input bound and with
caveats) as having each property. We omit veriﬁcation
results from the Linux kernel because UC-KLEE skipped
many function calls and inline assembly, causing it to
under-approximate the set of possible execution paths
and preventing it from making any veriﬁcation guaran-
tees. We did link each Linux kernel function with other
modules from the same directory, however, as well as the
mm/vmalloc.c module.
1A complete list of the bugs we discovered is available at:
http://cs.stanford.edu/~daramos/usenix-sec-2015
No leaks No malloc No uninitialized data
BIND
388
OpenSSL 383
Figure 14: Functions veriﬁed (with caveats) by UC-KLEE.
1776
1648
2045
2043
4.4.1 Leak checker
The leak checker was the most effective. It reported the
greatest number of bugs (37 total) and the lowest false
positive rate. Interestingly, only three of the 138 leak re-
ports for BIND were spurious errors, a false positive rate
of only 2.2%. For OpenSSL, we excluded 269 additional
reports involving the library’s obfuscated ASN.1 [25]
parsing code, which we could not understand. Of the
remaining 272 reports, the checker found ﬁve bugs but
had a high false positive rate of 90.1%.
For the Linux kernel, we wrote simple C annotations
(about 60 lines) to intercept calls to kmalloc, vmalloc,
kfree, vfree, and several similar functions, and to for-
ward these to UC-KLEE’s built-in malloc and free func-
tions. Doing so allowed us to track memory management
without the overhead of symbolically executing the ker-
nel’s internal allocators. We then ran UC-KLEE on all
functions that directly call these allocation functions.
Our system discovered 23 memory leaks in the Linux
kernel. One particularly interesting example (Figure 13)
involved the SunRPC layer’s server-side implementation
of AUTH GSS authentication for NFS. Each connection
triggering an upcall causes 512 bytes allocated at line
10 to be leaked due to a missing kfree that should be
present around line 17. Since this leak may be trig-
gered by remote connections, it poses a potential denial-
of-service (memory exhaustion) vulnerability. The NFS
maintainers accepted our patch to ﬁx the bug.
UC-KLEE found that at least 2909 functions in BIND
and at least 3700 functions in OpenSSL (or functions
they call) allocate heap memory. As shown in Figure 14,
UC-KLEE veriﬁed (with caveats) that 388 functions in
BIND and 383 in OpenSSL allocate heap memory but
do not leak it. Our system also veriﬁed that 1776 func-
tions in BIND and 1648 functions in OpenSSL do not
allocate heap memory, making them trivially leak-free.
4.4.2 Uninitialized data checker
The uninitialized data checker reported a total of 19 new
bugs. One illustrative example, shown in Figure 15, in-
USENIX Association  
24th USENIX Security Symposium  59
points = OPENSSL malloc(sizeof (EC POINT*)*(num + 1));
. . .
for (i = 0; i socktype == isc sockettype udp) \
? (&(disp)−>arc4ctx) : (&(disp)−>mgr−>arc4ctx)
. . .
result = dispatch allocate(mgr, maxrequests, &disp);
. . .
if ((attributes & DNS DISPATCHATTR EXCLUSIVE) == 0) {
result = get udpsocket(mgr, disp, . . .);
. . .
1 :# deﬁne DISP ARC4CTX(disp) \
2 :
3 :
4 :static isc result t dispatch createudp(. . ., unsigned int attributes, . . .) {
5 :
6 :
7 :
8 :
9 :
10:
11:
12:
13:
14: }
15: static isc result t get udpsocket(. . ., dns dispatch t *disp, . . .) {
16:
17:
18:
19:
20: }
. . .
/* PRNG selected based on uninitialized ’socktype’ ﬁeld */
prt = ports[dispatch uniformrandom(DISP ARC4CTX(disp), nports)];
. . .
}
disp−>socktype = isc sockettype udp; /* late initialization */
. . .
Figure 16: BIND non-deterministic PRNG selection bug.
age of functions with almost no manual effort is a strong
result not possible with existing tools.
4.4.3 User input checker
The user input checker required us to identify data orig-
inating from untrusted sources. Chou [6] observed that
data swapped from network byte order to host byte or-
der is generally untrusted. We applied this observa-
tion to OpenSSL and used simple annotations (about 40
lines of C) to intercept calls to n2s, n2l, n2l3, n2l6,
c2l, and c2ln, and mark the results fully-symbolic. We
also applied a simple patch to OpenSSL to replace byte-
swapping macros with function calls so that UC-KLEE
could use our annotations. We hope to explore automated
ways of identifying untrusted data in future work.
For BIND, we annotated (about 50 lines) the byte-
swapping functions ntohs and ntohl, along with
isc buffer getuint8 and three other functions that
generally read from untrusted buffers.
For the Linux kernel, we found that many network
protocols store internal state in network byte order, lead-
ing to spurious errors if we consider these to be un-
trusted.
Instead, we annotated (about 40 lines) the
copy from user function and get user macro (which
we converted to a function call). In addition, we used
an option in UC-KLEE to mark all arguments to the sys-
tem call handlers sys * as untrusted. Finally, we used
UC-KLEE to check the 1502 functions that directly in-
voke copy from user and get user, along with the
355 system call handlers in our build.
Reassuringly, this checker did not discover any bugs
in the latest versions of BIND or OpenSSL. We attribute
this both to the limited amount of data we marked as un-
trusted and to our policy of suppressing errors involving
possibly sanitized data (see § 4.3). However, we were
able to detect the 2014 “Heartbleed” vulnerability [1, 11]
when we ran our system on an old version of OpenSSL.
Interestingly, we did discover 11 new bugs in the
Linux kernel. Seven of these bugs were division- or
60  24th USENIX Security Symposium 
USENIX Association
(size t) dg−>payload size, GFP ATOMIC);
/* read length ﬁeld from userspace datagram */
dg size = VMCI DG SIZE(dg);
. . .
dg info = kmalloc(sizeof(*dg info) +
1 :static int dg dispatch as host(. . ., struct vmci datagram *dg) {
2 :
3 :
4 :
5 :
6 :
7 :
8 :
9 : memcpy(&dg info−>msg, dg, dg size);
10:
11: }
Figure 17: Linux kernel VMware Communication Interface
driver unchecked memcpy length (buffer overread) bug.
. . .
/* unchecked memcpy length; read overrun */
. . .
validate layout(. . ., struct ceph ioctl layout *l) {
. . .
/* validate striping parameters */
if ((l−>object size & ˜PAGE MASK) | |
(l−>stripe unit & ˜PAGE MASK) | |
(l−>stripe unit != 0 && /* ← 64-bit check */
((unsigned)l−>object size % (unsigned)l−>stripe unit)))
1 :static long
2 :
3 :
4 :
5 :
6 :
7 :
8 :
9 :
10:
11: }
Figure 18: Linux kernel CEPH distributed ﬁlesystem driver
remainder-by-zero bug in ioctl handler.
return −EINVAL;
/* 32-bit divisor: */
. . .
remainder-by-zero operations that would trigger ﬂoating-
point exceptions and crash the kernel. The remaining
four bugs are out-of-bounds dereferences.
Figure 17 shows a buffer overread bug we discovered
in the kernel driver for the VMware Communication In-
terface (VMCI) that follows a pattern nearly identical to
“Heartbleed.” The userspace datagram dg is read using
copy from user. The code then allocates a destina-
tion buffer on line 5 and invokes memcpy on line 9 with-
out sanitizing the dg size ﬁeld read from the datagram.
An attacker could potentially use this bug to copy up to
69,632 bytes of private kernel heap memory and send it
from the host OS to the guest OS. Fortunately, this vul-
nerability is only exploitable by code running locally on
the host OS. The maintainers quickly patched this bug.
Figure 18 shows an unsanitized remainder-by-zero
bug we found in the kernel driver for the CEPH dis-
tributed ﬁlesystem. The check at line 6 aims to prevent
this bug with a 64-bit comparison, but the divisor at line 8
uses only the low 32 bits of the untrusted stripe unit
ﬁeld (read from userspace using copy from user). A
value such as 0xffffffff00000000 would pass the
check but result in a remainder-by-zero error. An un-
privileged local attacker could potentially issue an ioctl
system call to crash the machine. We notiﬁed the devel-
opers, who promptly ﬁxed the bug.
Because of the ad-hoc nature of this checker, we did
not use it to exhaustively verify any properties about the
functions we checked.
5 Implementation
This section details optimizations and techniques we im-
plemented to scale our framework and address problems
we encountered while applying it to large systems.
5.1 Object sizing
Recall that when an unbound symbolic pointer is deref-
erenced, UC-KLEE must allocate memory and bind the
pointer to it. One challenge in implementing this func-
tionality is picking a useful object size to allocate. If the
size is too small, later accesses to this object may trigger
out-of-bounds memory errors. On the other hand, a size
that is too large can hide legitimate errors. We handled
this tradeoff using two approaches.
The ﬁrst approach, which we used for our experiment
in § 3.2, implemented a form of backtracking. At each
unbound pointer dereference, UC-KLEE checkpoints the
execution state and chooses an initial allocation size us-
ing a heuristic that examines any available type informa-
tion [42]. If the path later reads out-of-bounds from this
object, UC-KLEE (1) emits the error to the user, and (2)
restores the checkpoint and uses an allocation size large
enough to satisfy the most recent memory access. UC-
KLEE records the sequence of branches taken after each
checkpoint, and it forces the path to replay the sequence
of branches after increasing the allocation size. In prac-
tice, replaying branches exposed many sources of non-
determinism in the baseline KLEE tool and its system
modeling code, which we were able to eliminate through
signiﬁcant development effort.
An alternative approach that we recently incorporated
into UC-KLEE is to use symbolically-sized objects, rather
than selecting a single concrete size. Doing so avoids the
need for backtracking in most cases by simultaneously
considering many possible object sizes. At each memory
access, UC-KLEE determines whether the offset could ex-
ceed the object’s symbolic size. If so, it emits an error
to the user. It also considers a path on which the offset
does not exceed this bound and adds a path constraint
that sets a lower bound on the object’s size. We used this
approach for our evaluation in § 4.4.
5.2 Error reporting
With whole program symbolic execution, symbolic in-
puts typically represent unstructured strings or byte ar-
rays from command line arguments or ﬁle contents. In
this case, an error report typically contains a single set
of concrete inputs that trigger the error, along with a
backtrace. With under-constrained symbolic execution,
however, the inputs are often complex, pointer-rich data
structures since UC-KLEE directly executes individual
functions within a program. In this case, a single set of
concrete values is not easily understood by a user, nor
can it be used to trivially reproduce the error outside of
UC-KLEE because pointer inputs expect memory objects
(i.e., stack, heap, and globals) to be located at speciﬁc