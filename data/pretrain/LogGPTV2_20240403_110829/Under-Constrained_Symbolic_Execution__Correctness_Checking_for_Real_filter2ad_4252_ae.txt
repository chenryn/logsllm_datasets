### 优化后的文本

---

#### 内存泄漏示例
```c
...
ret = gssp_alloc_receive_pages(&arg);
...
gssp_free_receive_pages(&arg);
...

struct gssp_upcall_data *data) {
    // 函数体
}

int gssp_alloc_receive_pages(struct gssx_arg_accept_sec_context *arg) {
    arg->pages = kzalloc(...);
    ...
    return 0;
}

void gssp_free_receive_pages(struct gssx_arg_accept_sec_context *arg) {
    for (i = 0; i < npages && arg->pages[i]; i++) {
        free_page(arg->pages[i]);
    }
}
```
**图13：Linux内核中RPCSEC GSS协议实现中的内存泄漏问题，该协议被NFS服务器端AUTH GSS使用。**

在`gssp_alloc_receive_pages`函数中，分配了512字节的内存（第10行），但由于缺少`kfree`调用（应位于第17行附近），导致每次触发upcall时都会发生内存泄漏。由于这种泄漏可能由远程连接触发，因此存在潜在的拒绝服务（内存耗尽）漏洞。NFS维护者接受了我们修复此漏洞的补丁。

---

#### UC-KLEE测试结果

对于Linux内核，我们包含了与每个检查器相关的函数。与我们在§3.2中的评估不同，我们没有使用任何手动注释来抑制误报。我们在BIND和Linux内核的每个函数上运行UC-KLEE最多五分钟，在OpenSSL的每个函数上运行最多十分钟。我们使用了与§3.2相同的机器。

- **BIND版本9.10.1-P1 (12/2014)**
- **OpenSSL版本1.0.2 (1/2015)**
- **Linux内核版本3.16.3 (9/2014)**

**图12总结了结果**。UC-KLEE总共发现了67个以前未知的漏洞：12个在BIND中，11个在OpenSSL中，44个在Linux内核中。**图14列出了UC-KLEE验证（带有条件）为具有每个属性的函数数量**。我们省略了Linux内核的验证结果，因为UC-KLEE跳过了许多函数调用和内联汇编，导致它低估了可能的执行路径集，并且无法提供任何验证保证。然而，我们将每个Linux内核函数与其他相同目录下的模块以及`mm/vmalloc.c`模块链接在一起。

**完整漏洞列表见：** http://cs.stanford.edu/~daramos/usenix-sec-2015

| 属性 | BIND | OpenSSL |
|------|------|---------|
| 无泄漏 | 388 | 383 |
| 无malloc | 1776 | 1648 |
| 无未初始化数据 | 2045 | 2043 |

**图14：UC-KLEE验证（带有条件）的函数数量。**

#### 4.4.1 泄漏检查器
泄漏检查器最为有效。它报告了最多的漏洞（共37个）并且误报率最低。有趣的是，在BIND的138个泄漏报告中，只有三个是误报，误报率为2.2%。对于OpenSSL，我们排除了涉及库中混淆的ASN.1 [25]解析代码的269个额外报告，这些代码我们无法理解。在剩下的272个报告中，检查器找到了五个漏洞，但误报率高达90.1%。

对于Linux内核，我们编写了简单的C注释（约60行）来拦截对`kmalloc`、`vmalloc`、`kfree`、`vfree`等类似函数的调用，并将其转发到UC-KLEE内置的`malloc`和`free`函数。这样做使我们能够跟踪内存管理，而无需符号执行内核内部分配器的开销。然后我们在所有直接调用这些分配函数的函数上运行UC-KLEE。我们的系统在Linux内核中发现了23个内存泄漏。

---

#### 4.4.2 未初始化数据检查器
未初始化数据检查器报告了总计19个新漏洞。一个说明性的例子如**图15**所示，展示了在BIND中发现的一个漏洞。

---

#### 4.4.3 用户输入检查器
用户输入检查器要求我们识别来自不受信任来源的数据。Chou [6]观察到从网络字节序转换为主机字节序的数据通常是不受信任的。我们将这一观察应用于OpenSSL，并使用简单的注释（约40行C代码）拦截对`n2s`、`n2l`、`n2l3`、`n2l6`、`c2l`和`c2ln`的调用，并将结果标记为完全符号化。我们还应用了一个简单的补丁，将OpenSSL中的字节交换宏替换为函数调用，以便UC-KLEE可以使用我们的注释。我们希望在未来的工作中探索自动识别不受信任数据的方法。

对于BIND，我们注释了（约50行）字节交换函数`ntohs`和`ntohl`，以及通常从不受信任缓冲区读取的`isc_buffer_getuint8`和其他三个函数。

对于Linux内核，我们发现许多网络协议以网络字节序存储内部状态，如果我们将这些视为不受信任，则会导致误报。相反，我们注释了（约40行）`copy_from_user`函数和`get_user`宏（我们将其转换为函数调用）。此外，我们使用UC-KLEE选项将系统调用处理程序`sys_*`的所有参数标记为不受信任。最后，我们使用UC-KLEE检查了直接调用`copy_from_user`和`get_user`的1502个函数，以及构建中的355个系统调用处理程序。

令人欣慰的是，这个检查器在最新版本的BIND或OpenSSL中没有发现任何漏洞。我们认为这既是因为我们标记为不受信任的数据量有限，也因为我们抑制了涉及可能已清理数据的错误（见§4.3）。然而，当我们在一个旧版本的OpenSSL上运行我们的系统时，我们能够检测到2014年的“心脏出血”漏洞[1, 11]。

有趣的是，我们在Linux内核中发现了11个新漏洞。其中七个漏洞是除法或余数为零的操作，会触发浮点异常并导致内核崩溃。其余四个漏洞是越界引用。

**图17**显示了我们在VMware通信接口（VMCI）内核驱动程序中发现的一个缓冲区过读漏洞，其模式几乎与“心脏出血”相同。用户空间数据报`dg`通过`copy_from_user`读取。代码在第5行分配了一个目标缓冲区，并在第9行调用`memcpy`，而没有对从数据报读取的`dg_size`字段进行清理。攻击者可能利用此漏洞复制多达69,632字节的私有内核堆内存，并从主机操作系统发送到客户机操作系统。幸运的是，此漏洞仅可由在主机操作系统上本地运行的代码利用。维护者迅速修复了此漏洞。

**图18**显示了我们在CEPH分布式文件系统内核驱动程序中发现的一个未清理的余数为零漏洞。第6行的检查旨在通过64位比较防止此漏洞，但在第8行中，除数只使用了不受信任的`stripe_unit`字段的低32位（通过`copy_from_user`从用户空间读取）。例如，值`0xffffffff00000000`可以通过检查，但会导致余数为零的错误。非特权本地攻击者可能会发出`ioctl`系统调用来使机器崩溃。我们通知了开发者，他们迅速修复了此漏洞。

由于此检查器的临时性质，我们没有使用它来彻底验证我们检查的函数的任何属性。

---

#### 5 实现
本节详细介绍了我们实施的优化和技术，以扩展我们的框架并解决在大型系统应用过程中遇到的问题。

#### 5.1 对象大小
当解引用未绑定的符号指针时，UC-KLEE必须分配内存并将指针绑定到它。实现此功能的一个挑战是选择一个有用的对象大小。如果大小太小，后续对该对象的访问可能会触发越界内存错误。另一方面，如果大小太大，则可能隐藏合法错误。我们使用两种方法来处理这种权衡。

第一种方法是在§3.2实验中使用的回溯形式。在每个未绑定指针解引用时，UC-KLEE检查执行状态并使用启发式方法根据可用类型信息[42]选择初始分配大小。如果稍后从此对象读取越界，UC-KLEE会（1）向用户报告错误，并（2）恢复检查点并使用足够大的分配大小以满足最近的内存访问。UC-KLEE记录每个检查点后的分支序列，并强制路径在增加分配大小后重放该分支序列。实际上，重放分支暴露了基线KLEE工具及其系统建模代码中的许多非确定性来源，我们通过大量开发工作消除了这些问题。

另一种我们最近集成到UC-KLEE中的方法是使用符号大小的对象，而不是选择单个具体大小。这样做通过同时考虑多个可能的对象大小，在大多数情况下避免了回溯的需要。在每次内存访问时，UC-KLEE确定偏移量是否可能超过对象的符号大小。如果是这样，它会向用户报告错误。它还会考虑一条偏移量不超过此边界并添加路径约束以设置对象大小下限的路径。我们在§4.4的评估中使用了这种方法。

#### 5.2 错误报告
在全程序符号执行中，符号输入通常表示来自命令行参数或文件内容的非结构化字符串或字节数组。在这种情况下，错误报告通常包含一组触发错误的具体输入，以及回溯。然而，在欠约束符号执行中，输入往往是复杂、富含指针的数据结构，因为UC-KLEE直接执行程序中的单个函数。在这种情况下，一组具体值不容易被用户理解，也无法在UC-KLEE之外简单地重现错误，因为指针输入期望内存对象（即栈、堆和全局变量）位于特定位置。

---