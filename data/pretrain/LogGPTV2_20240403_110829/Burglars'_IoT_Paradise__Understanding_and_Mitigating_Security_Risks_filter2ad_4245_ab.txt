further implemented end-to-end attacks on all the problems
discovered, with their demos posted online [12]. It is important
to note that all such experiments were conducted in an ethical
way: we always aimed at our own devices, never putting
the cloud services, platforms and other users in danger. Also
importantly, we reported all our ﬁndings to the manufacturers
and IoT cloud providers, sharing our PoC attacks with them
and helping them improve their security protection. This effort
has been well received and acknowledged, and we received
6,700 USD in total from those vendors’ bug bounty programs.
A. Unauthorized MQTT Messages
As mentioned earlier, MQTT was not designed to work
in the diverse scenarios of IoT communication. A prominent
example is device sharing and revocation, in which a party
(hotel dweller, Airbnb tenant, babysitter, etc.) is only trusted
with temporary access to an IoT device and not allowed to get
information from or interfere with the activities of prior and
future users of the same device. This potentially adversarial
situation is completely outside the MQTT protocol. Without
in-depth understanding of the problem, the current IoT cloud
platform just cannot handle it in a secure way. Following we
present the new security risks we discovered in the scenario
due to the insecure management of MQTT messages, including
Will message and Retained message, which leads to unautho-
rized control of IoT devices.
Unauthorized Will Message. Based on the MQTT speciﬁ-
cation, the client can register with the broker a special Will
Fig. 3. Will Message Attack on iRobot Device
Message (in a CONNECT type MQTT message, see Section II)
for a topic. Once the client is accidentally disconnected (i.e.,
not sending a DISCONNECT message to the broker),
the
broker will publish the Will Message to all subscribed clients
of the topic, allowing them to take corresponding actions.
Like other MQTT messages, Will Message can include either
control commands or just text.
However, this exception handling feature was not meant to
work in the adversarial environment, when the access right
on a device is transferred from one party to another. In this
case, a malicious ex-user can strategically register a Will
Message to trigger it later when he no longer has the access
privilege, to stealthily issue commands when the device is
serving other users: for example, a babysitter or a repairman
given access to a smart lock once could open the door for
others later. Speciﬁcally, we found that even after the attacker’s
privilege on a device expires, so he is prevented from direct
communicating with the device by the broker based upon the
owner-speciﬁed policy, on the protocol level, the attacker’s
Will Message will still be issued as soon as his client is
disconnected from the broker. In this way, he can decide when
to unlock the door in the above example by choosing the right
time to go ofﬂine. Note that, the attacker can launch the attack
multiple times leveraging multiple clients to register multiple
Will Messages (e.g., 10 times in our PoC attack below).
The problem can be addressed by removing the Will Mes-
sage registration when one’s access right is revoked. This,
however, is complicated since the IoT cloud platform can no
longer just operate on top of MQTT, by controlling whether
a user should communicate with a device based upon her
platform ID, but needs to get into the protocol to expand its
state machine with the capability to handle revocation (e.g.,
ﬁnding out each state related to the party like registering a
Will Message and cleaning up each of them). This has never
been thought of, up to our knowledge, and does not exist on
all leading IoT clouds we studied (see Section IV).
Attack through Will Message. We implemented a PoC
attack exploiting Will Message on the AWS IoT cloud using
our iRobot Roomba 690 (Fig. 3). Speciﬁcally, we wrote
a script to register a Will Message, including a command
(Command:Start) to start our device with the broker. Then,
when a victim user (like the subsequent guest of the same hotel
room) reset the device and used the robot and our client’s
privilege was completely revoked (e.g., it was denied of pub-
4
CONNECTWill Message:{Command:Start}PUBLISHMessage:{Command:Start}Victim DeviceAttackerAWS IoT CloudRevoke attacker’s permissionReset and used by the victimAcceptDenyGo offlinePUBLISHMessage:{Command:Start}StartWill message triggeredlishing messages to the device), we show that the commands
in the Will Message were still delivered and invoked the robot
when our script went ofﬂine. Such an attack can be ampliﬁed
by exploiting the problem multiple times: we also tried 10
“malicious” clients to register 10 Will Messages at a time, and
each client was able to independently launch an attack.
The same problem has been conﬁrmed on the IoT clouds
of AWS, IBM, Baidu, Tuya Smart, etc. Given the absence of
proper security checks in the clouds and missing of security
advisory for device manufactures,
the problem potentially
affects all devices on these clouds, such as door/window
locks, video doorbells, cardiac devices, security cameras, ﬁre
detectors, etc., which are highly security-, privacy- and even
safety-sensitive.
Discussion. Through our conversation with the MQTT Tech-
nical Committee and inspecting the MQTT speciﬁcation, we
found that the problem comes from the contract-like property
of Will Message: a registered Will Message on a topic is
entitled to deliver to all clients that subscribed to the topic;
whether the message violates the security requirement of
subscribing clients is not a concern of MQTT. Such a contract
assumes a much more trusted environment MQTT is designed
for, not the adversarial environment of the IoT communication
(e.g., the previous device user may attack the subsequent one).
The problem we found indicates that IoT vendors should
understand this gap and extend the protocol to address its
security implications. For the ﬁrst time, our ﬁnding shows
that the importance of covering this gap has been largely
underestimated and the security risks are highly realistic. Also
we found that the problem is not limited to Will Message but
also other MQTT features, as elaborated later.
Unauthorized retained message. When an MQTT client
publishes a message to a topic, and no client is subscribed
to the topic, the message is simply discarded by the broker.
However, this simple treatment also disrupts the publisher’s
communication with its subscribing clients when the clients
are all temporarily ofﬂine. To address the problem, the MQTT
client can register a Retained Message with a topic (by setting
the retained ﬂag in a regular MQTT message), which
allows the broker to keep the last Retained Message on the
topic, and publish it immediately to any future subscribers to
the topic.
Just like Will Message, this feature was not designed to
work in the adversarial IoT environment and again we found
that it can be exploited by a malicious ex-user to stealthily
command a device he no longer has access to. For example, the
malicious ex-user of a device in an Airbnb room can publish a
Retained Message, which includes arbitrary control commands
(e.g., open the door at 3 am), to the associated topic
of a smart lock when he still has an access right. Later when
he checks out and therefore loses the privilege, he can wait
for the device to get back online. When this happens, the lock
will subscribe to the old topic again and receive the unlock
command. Once executed, the door will be open at 3am and
burglars can get in.
PoC Attack. We performed PoC attacks and conﬁrmed that
the IoT cloud of Baidu (one of the top Public Cloud Services
Providers in China [25] and with the fourth largest website
in the world [26]) and the Eclipse Mosquitto (a famous
open-source MQTT broker [13], which was forked more than
950 times [27] and deployed in popular open-source IoT
platforms [28], [29]) were subject to the Retained Message
attack. On both platforms, we ﬁrst ran a “malicious” client
(representing the ex-user) to register a Retained Message onto
a topic, and then revoked its regular permission. Later, when a
“victim” client (representing the device when it is used by the
different user) subscribed to the same topic, both platforms
forwarded the attack messages to the victim, which can lead
to unauthorized control on a device.
Responsible disclosure. We reported the problems to affected
parties including AWS IoT, IBM, Baidu, Tuya Smart, Eclipse
Mosquitto, etc., which all acknowledged their importance.
AWS had an online meeting with us to discuss possible
solutions to mitigate the risks to IoT users.
B. Faults in Managing MQTT Sessions
As introduced earlier, the MQTT communication is through
the established session between the client and the broker
server, and each session is associated with an MQTT client.
Therefore, when a client has a state change (e.g., his/her
access to a device is revoked), the states of its established
session should be updated, which is particularly important
to security sensitive ones such as subscription state (which
topics are subscribed to) and the lifecycle state (whether the
session should last or be terminated) in particular. However,
this expected security property is often not in place on real-
world IoT platforms, as elaborated below.
Non-updated session subscription state. MQTT speciﬁcation
suggests that the server authorizes particular actions of the
client [18]. With this guidance in place, IoT platforms typically
enforce a security policy to govern the client’s operations.
For example, when a device is reset to completely remove
all privileges of an ex-user on the device, in any established
session,
the user’s client becomes no longer permitted to
take any proactive action, such as to SUBSCRIBE to the
device’s topic. However, when we inspect the session’s state
management, we found that the MQTT speciﬁcation provides
no guidance in updating session states in response to the
client’s privilege change. Likely due to such lack of guidance,
session management in real-world IoT systems, particularly
when it comes to a session’s subscription state, was found to
have privacy-critical defects. Speciﬁcally, as long as a client
establishes a session that ever subscribed to a topic (e.g., the
topic of a smart speaker in a hotel room), even when the
user is no longer permitted to subscribe to the topic (e.g.,
after checking out), we found that the broker continuously
delivers messages to the client through the established session.
That is, the subscription state of the session lasts even after
the subscriber lost his privilege, which effectively enables
the malicious ex-user of a device to continuously receive all
5
messages generated by the device for the current user (victim),
such as personal buying history and habits, health conditions
and data (e.g., heartbeats), etc. Such an unsound session state
management is conﬁrmed on major IoT clouds (e.g., IBM,
Tuya, Alibaba, Baidu, see responsible disclosure below).
Non-updated session lifecycle state. The MQTT client in
the IoT environment can represent two different roles, the
device (when the client is authenticated through a device’s
credential) and the user (when the client
is authenticated
through a user’s credential). The two roles are managed
differently by IoT clouds from the security perspective: the
device is treated as the resource to access, and the user is
regarded as the principle to authenticate and authorize. Such
a difference is found to have security implications in the
scenarios of IoT device sharing and revocation. Particularly,
when a device is reset by a new user (for removing ex-
users’ access), permissions of the ex-user (and his/her client)
for accessing the device are revoked (i.e., publish/receive
messages through the device’s topic). In contrast, there is no
concept of revoking the permission of a device for accessing
its topic. Hence, a possible attack is: the ex-user (attacker)
obtains the device credential when he/she is permitted to use
the device (obtaining device credentials is oftentimes trivial,
such as through trafﬁc analysis or reverse engineering, as
demonstrated by a recent study [30] [31]), then even after the
new user removes ex-users, the attacker can always leverage
the device credential to impersonate the device and publish
fake messages to the device’s topic. Such an attack, however, is
found to be mitigated by leading IoT platforms. For example,
Tuya’s IoT cloud ensures (leveraging its device SDK provided
to manufacturers) that device credentials under its cloud are
forced to expire if the owner changes (e.g., when the new user
resets the device). Hence, with an expired device credential,
the ex-user can no longer impersonate the device.
However, in our study, when we look at the problem from
the perspective of MQTT session management, we found a
new weakness on leading IoT platforms that allowed the attack
to proceed. Particularly, through the obtained device credential,
as long as the ex-user (attacker) establishes a session before
the credential expires and keeps the session online, he/she can
always publish fake messages to the device’s topic through the
session, on behalf of the device. Note that, the attack can con-
tinue even after the credential expires and thus can no longer
be used to authenticate new clients or establish new sessions.
This has serious security and even safety implications: for
example, a burglar or criminal can leverage the fake message
to show to the user that the door is locked or the gas valve is
fastened though it is not; the fake message can trigger other
sensitive devices (e.g., unlock a door) of the victim through a
trigger-action IoT platform, such as IFTTT [32].
In this attack, the fault unwittingly made by the platform
its existing
is: when the device is reset for cleaning all
users and more fundamentally, existing states, the lifecycle
state of the established MQTT session is not updated. To be
secure, the session’s state should be cleaned up, e.g., by com-
pletely terminating the established session. However, MQTT
speciﬁcation [4] does not consider the security necessity of
session state update in cases of user privilege change, likely
due to its assumed much simpler and less adversarial usage
environment, compared to IoT. The problem was conﬁrmed
and acknowledged by IBM, Tuya, Alibaba, Baidu, etc. (see
Section IV), and an end-to-end attack was implemented below
to show the feasibility of a real attack.
More fundamentally, the two attack scenarios above indicate
that secure MQTT session state management,
i.e., sound
mechanisms that govern session state updates in response to
IoT users’ privilege changes, is understudied and suffers from
new security risks in IoT environment. Such risks are highly
underestimated by established MQTT development guide and
real-world IoT vendors.
Attack. Exploiting the above weaknesses, we implemented
PoC attacks using our MiKO smart socket which is mediated
on the cloud of Tuya Smart [33] (hosting over 100 million
smart devices). First, to exploit the session subscription state,
acting as the malicious user, we established a session, which
was able to continuously receive messages from the device
even after a second user reset the device for removing all
previous users. Second, to exploit the insecure session lifecycle
management, through reverse engineering the device trafﬁc,
we were able to get the device credentials and established a
“malicious” session. Later, the device was reset by a second
user (victim) for removing ex-users’ access, but the malicious
session was able to continuously publish fake device messages
(e.g., device status of “on”) to the victim’s app that subscribed
to the device’s topic. Through such an attack, a real burglar
or criminal may break into a home, in the mean time publish
fake device updates (impersonating home-safety devices) to
the victim/police and show that the home is still safe.
Responsible disclosure. We reported our ﬁndings to affected
vendors including Tuya, Alibaba, Baidu, IBM, etc. who all
acknowledged the problem.
C. Unauthenticated MQTT Identities
As mentioned earlier (Section II), IoT cloud platforms
authenticate their MQTT clients using their own platform-
layer identities (e.g., Amazon accounts on AWS IoT cloud).
In the meantime, each client is also identiﬁed by its own
protocol-level identity ClientId. The relations between these
two identities can be complicated: one account can have mul-
tiple devices, each with their own ClientId, while one device
could be shared between multiple accounts. Such relations,
if not managed well, could expose MQTT communication to
attacks, as discovered in our research.
ClientId hijacking. The MQTT protocol requires the broker
to disconnect the online client on observing a new client
with the same ClientId. In an adversarial environment, one
would expect that related MQTT protocol states and transitions
(e.g., moving a client to the ofﬂine state under a detected
conﬂicting ClientId) are protected by proper authentication
involving ClientId and the token is kept secret. However, our
6
research shows that such protection is actually not in place
over major IoT cloud platforms. As a result, the attacker can
leverage his/her own authenticated platform identity to connect
to the IoT cloud with an arbitrary ClientId, including the one
belonging to a target device, so as to force the cloud to drop
off the target. In our PoC attack, we show that the threat is
realistic, and can be done in large scale, across most IoT clouds
we studied (Section IV), such as AWS, IBM, Baidu.
The attack on ClientId actually goes beyond DoS. Speciﬁ-
cally, the MQTT protocol allows the broker and the client to
restore the prior session if the client connects with its previous
ClientId (with Clean Session ﬂag checked in CONNECT
message [4]), which allows the client to quickly recover prior
states (e.g., its subscriptions and the pending messages it is
supposed to receive), so as to avoid conﬁguration hassles.
This recovery mechanism, however, can be abused to work
against a target client, once its ClientId is disclosed to the
attacker. Note that the attacker here can carry a completely
legitimate platform identity. In the absence of the security
policies that connect these two identities and regulate one’s
access rights to the related objects, a malicious cloud user
can leverage the target’s ClientId to resume its session and
steal its messages (e.g., health condition, location, personal
habits, etc.). In our research, we successfully executed PoC
attacks on IBM Watson IoT and Baidu Cloud IoT, in which
the attacker could receive the victim’s messages though he
never subscribed to the victim’s topic. We found this is a
realistic problem due to the improper identity management on
real-world IoT clouds, which do not authenticate ClientId as
long as the MQTT client proves its platform identity.
ClientId identiﬁcation. The aforementioned attack is predi-
cated upon the attacker’s knowledge about the target’s Clien-