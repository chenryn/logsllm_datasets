tion), even if two mobile devices know each other’s IP address. We
discovered that with two of the operators, sending SIP messages
directly from UE-A to UE-B was possible; furthermore, the call
session was successfully established. As a result, the communication
could not be accounted as discussed in §2.3. This problem comes
from the inappropriate access control of the default bearer for SIP
signaling in P-GWs of the LTE network.
No authentication. A SIP server should authenticate every SIP
message to determine whether it is from a valid user. However, we
discovered that two of the Korean operators do not perform proper
user authentication. As a result, we could make a call with a fake
phone number by sending a manipulated INVITE.
No session management. In addition, we determined that, apart
from one operator in Korea, none of the operators manages call
sessions correctly. As a result of incorrect session management
in SIP servers, an adversary can create multiple SIP messages to
make a phone call to many people simultaneously. It should be
disallowed, as more than one call sessions should not be established.
Furthermore, this could be used to launch control plane DoS attacks.
Core networks are able to manage a limited number of bearers, and
if compromised phones start sending multiple INVITE messages
which generate a number of bearers, it will deplete the resources
in LTE networks. When UE-A sends an INVITE, the dedicated
bearers are established both for UE-A and UE-B, even if UE-B does
not respond to the call.
332Summary. VoLTE potentially has several security problems as we
discussed in this section. In §5, we discuss how these vulnerabilities
can be exploited among different operators.
4 Exploiting Hidden Data Channels
From the analysis of the accounting policy and VoLTE call ﬂow in
§3.2, we showed the possibility of hidden channels that an adver-
sary can utilize to bypass accounting. These channels are classiﬁed
into channels that reside in the VoLTE call ﬂow (i.e. SIP and RTP
tunneling) and a direct communication channel utilizing a VoLTE
default bearer.
SIP/RTP tunneling are potentially free channels in VoLTE call
service, as in Figure 4. 1 In SIP tunneling, the payload is embedded
in SIP messages, and these messages are sent through the default
bearer. Meanwhile, 2 RTP tunneling carries the payload through
the established dedicated bearer, as explained in §2.2. Strictly speak-
ing, any protocol can be used for data delivery through the media
session. However, we utilize RTP tunneling as all the operators we
tested encapsulated voice data with RTP. Note that the voice data
transmission using this channel is handled in the CP, and most of
the details on its implementation remain proprietary.
Direct communication is another channel that directly sends one
UE’s data to another UE. Figure 5 illustrates the ﬂow of direct com-
munication: 1 phone-to-Internet and 2 phone-to-phone. Since the
default bearer for VoLTE signaling messages is always established
as long as the device is turned on, a UE can easily send data through
this bearer to the Internet or another UE unless P-GW blocks it.
4.1 Exploitation
We implemented our own sending and receiving modules to verify
the hidden channels in operational networks. Figure 6 illustrates
the sending module (left) and receiving module (right), which are
connected through the IMS network.
Sending Module
As 3GPP speciﬁcations give some freedom to operators, and
it is not clear if all operators follow 3GPP speciﬁcations [3, 18]
completely, our modules take this implementation-speciﬁc deviance
into account. For example, for the operator using IPsec, we utilized
the established IPsec tunnel to send our data instead of sending SIP
messages directly. In the case of direct communication, we do not
require any additional implementation since we can open a socket
at each side and transfer packets directly, if possible.
4.1.1
First, our sending module should have more functionality than the
native VoLTE calling application in a mobile phone; it should be
able to vary its parameters such as the sender’s phone number, IP
address, and port number to create arbitrary media sessions. The
sending module consists of SIP Parser, SIP Handler, SIP Tunneling
Sender and RTP Tunneling Sender.
1 SIP Parser extracts common headers and carrier-speciﬁc head-
ers in the packets obtained from native VoLTE apps. For example,
an INVITE message contains the caller’s phone number, IP ad-
dress, and routing information such as IP addresses of SIP servers.
SIP Parser automatically parses this information and stores it in its
database separated by each operator for later recreation of the SIP
message in our sending module.
2 SIP Handler manages the exploitation. When we initiate our
attack, it takes conﬁguration values: operator’s name, phone number,
and phones’ IP address and port number for tunneling. By simply
modifying these conﬁguration values, the SIP Handler can gen-
erate SIP messages for each operator. It also randomly generates
parameters (e.g. branch, tag, and calling ID) that distinguish each
call session to guarantee freshness. SIP Handler triggers either SIP
Tunneling Sender or RTP Tunneling Sender for each test.
3 SIP Tunneling Sender establishes a SIP tunnel when it receives
a signal from SIP Handler. It ﬁrst fragments a ﬁle to be transferred
into several blocks. Then it embeds the fragmented blocks inside the
SIP messages. Since there exists a maximum number that we can
fragment (otherwise blocked by SIP servers in IMS) and the size of
each block cannot exceed the MTU, the SIP Handler may need to
fragment the ﬁle into multiple blocks. For convenience, we place
the data block at the end of the body in INVITE.
4 RTP Tunneling Sender is more complicated than SIP tunnel-
ing. In the case of RTP tunneling, fragmentation of a given ﬁle is
the same as in SIP tunneling. However, we ﬁrst must establish a
media session to transfer data. Therefore, the RTP Tunneling Sender
generates an INVITE and follows the native call ﬂow until it gets
an OK (200) message from the callee. It then extracts the IP ad-
dress and the port number of the callee from the established media
channel. It transfers the data blocks wrapped as an RTP packet to
the extracted IP address and the port number. In native calling apps,
voice is wrapped and sent from the CP. However, as described in
§3.2.2, we discovered that audio packets from the AP to the receiver
are routed correctly as well. To distinguish our packets from oth-
ers, we add an identiﬁer at the beginning of the payload. We also
add the sequence number and timestamp after the identiﬁer for our
performance evaluation.
4.1.2 Receiving Module
The receiving module receives the data blocks in RTP packets sent
from the sending module through the IMS network. Our receiving
module consists of the SIP Tunneling Receiver, RTP Tunneling
Receiver, Measuring Engine, and Data Storage.
1 SIP Tunneling Receiver parses SIP messages and extracts our
data from received RTP packets. Since SIP messages are processed
in the AP, as described in §2.2, the SIP Tunneling Receiver can
capture incoming packets and parse them in real time. As we placed
the data blocks at the end of the body in the INVITE, the receiver
can easily extract the fragmented blocks and reassemble them. The
receiving module opens a raw socket to capture packets because a
SIP daemon is already running on the device. For the operator using
IPsec, we could easily extract SIP messages out of ESP packets
since we changed the encryption algorithm to Null.
2 DIAG is QualComm’s proprietary diagnostic protocol. It has a
command that can be used to mirror every received packet to the
RTP Tunneling Receiver via DIAG interface in the Android kernel
as introduced by Delugre [10]. To initiate mirroring from CP to the
DIAG interface, the mobile device has to be connected to a laptop
once. After this, the laptop can be disconnected.
This step is necessary since the data we sent through the media
channel are only processed in CP, but not forwarded to AP. There-
fore, in order to receive and process packets directly, we need to
utilize the DIAG command.
In addition to the DIAG command, one may consider Android
radio interface layer (RIL) to receive audio data. The problem with
the RIL interface is that some mobile devices do not export incoming
voice to the AP. Instead, it transfers incoming voice directly to a
speaker. Because of this limitation, we chose to use the DIAG
command.
3 RTP Tunneling Receiver utilizes the DIAG interface. After
the mobile device receives the DIAG command, RTP Tunneling
Receiver starts receiving all network packets through the DIAG
interface in the Android kernel. If the received packet is not cor-
rupted and contains the identiﬁer we set in the sending module, it
accepts the packet. Finally, it extracts and sends data blocks to Data
333AP
1
SIP Parser
2
SIP Handler
Config Value
3
4
SIP
Tunneling 
Sender
RTP
Tunneling 
Sender
V
o
L
T
E
I
n
t
e
r
f
a
c
e
IMS
E
T
L
o
V
e
c
a
f
r
e
t
n
I
CP
CP
G
A
D
I
e
c
a
f
r
e
t
n
I
AP
1
SIP 
Tunneling 
Receiver
3
RTP
Tunneling 
Receiver
Data
Storage
4
Measuring
Engine
Audio Data
Speaker
2
Logging DIAG Command
Figure 6: Diagram of Sending and Receiving Module
Storage while a sequence number and timestamp are passed to the
Measuring Engine.
4 Measuring Engine receives a sequence number, timestamp, and
data size from the receivers to evaluate the network performance of
our tunneling. Note that we did not measure the performance for
the SIP tunneling since it might cause denial of service to the SIP
servers in the IMS network (See §5 for more details.)
4.1.3 Challenges and Limitations
During our implementation, we encountered some challenges. First,
many operators do not follow the speciﬁcations [3, 18] for either the
ﬂow or the structure of SIP messages. For example, some operators
do not transfer RINGING or SESSION PROGRESS during call
setup. Some operators even simply modify or remove header ﬁelds
for their own purposes. Consequently, much work had to be done
to ensure our sending module adjusts operators’ individual VoLTE
features and obtain results thereupon.
The second challenge is that at the receiver’s side, the device
automatically closes the calling session by sending a BYE message
when it does not receive RTP packets for a certain period (typically
10 seconds). Therefore, we had to wrap the data blocks into RTP
packets to keep the session alive.
Finally, the receiving module requires a mobile device to be con-
nected with a laptop once to send the DIAG command. However,
once logging setup is complete, the device does not need to be con-
nected with the laptop until it is powered off. We discovered that
the DIAG interface in the Android kernel does not accept DIAG
commands. We tried to send the DIAG command from the kernel
to eliminate the one time connection to a laptop, but it was not
successful. In contrast, from our laptop, we could send DIAG com-
mands through the USB connection. There might be a protecting
mechanisms in the CP that blocks DIAG commands from the mobile
device since they are usually sent from control software in a laptop.
4.2 Evaluation
4.2.1 Media Channel Properties
We ﬁrst measured the characteristics of the media channel during
the call as in Table 2. The experiment is conducted with OPTis-S4
4OPTis-S is a software that enables mobile device manufacturers to
analyze control-plane messages.
Table 2: Media channel characteristics
US-1 US-2 KR-1 KR-2 KR-3
Qos Param. (Kbps)
Bandwidth (Kbps)
Latency (sec)
Loss rate (%)
38
38/49
0.1
1
49
49
0.1
1
41
65
0.1
1
41
65
0.1
1
49
65
0.1
1