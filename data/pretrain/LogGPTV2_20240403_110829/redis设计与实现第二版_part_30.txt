表示服务器没有在进行持久化操作，在这种情况下，程序执行以下三个检查：
程是否有信号发来服务器进程：
两个属性的值，只要其中一个属性的值不为-1，程序就会执行一次wait3 函数，检查子进
BGREWRITEAOF命令是否正在执行：
14.2.9
值为1，那么服务器就会执行之前被推延的 BGREWRITEAOF命令。
令是否正在执行，如果这两个命令都没在执行，并且 aof_rewrite_scheduled 属性的
2）检查服务器的自动保存条件是否已经被满足，如果条件满足，并且服务器没有在执
1）查看是否有BGREWRITEAOF被延迟了，如果有的话，那么开始一次新的
3）检查服务器设置的AOF重写条件是否满足，如果条件满足，并且服务器没有在执行
服务器状态使用rdb_child_pid 属性和 aof_child_pid 属性记录执行 BGSAVE命
每次 serverCron 函数执行时，函数都会检查 BGSAVE 命令或者 BGREWRITEAOF命
另一方面，如果rdb_child_pid 和 aof_child_pid 两个属性的值都为-1，那么
口如果有信号到达，那么表示新的RDB文件已经生成完毕（对于BGSAVE命令来说）,
每次 serverCron 函数执行时，程序都会检查 rdb_child_pid 和 aof_child_pid
 struct redisServer
口
如果没有信号到达，那么表示持久化操作未完成，程序不做动作。
的 AOF 文件替换现有的AOF文件。
相应命令的后续操作，比如用新的 RDB 文件替换现有的 RDB 文件，或者用重写后
或者AOF文件已经重写完毕（对于BGREWRITEAOF命令来说），服务器需要进行
11
pid_t aof_child_pid;
pid_t rdb_child_pid;
NV
检查持久化操作的运行状态
记录执行 BGSAVE 命令的子进程的 ID:
没有石
/* PID if rewriting process */
/* PID of RDB saving child */
---
## Page 195
14.2.12增加 cronloops计数器的值
的说明。
14.2.11
11 章对此有详细的说明。
serverCron 函数会调用相应的程序，将 AOF 缓冲区中的内容写人到AOF 文件里面，第
14.2.10将 AOF 缓冲区中的内容写入 AOF 文件
持久化操作了)。
都可能会引起新的持久化操作，所以在这个检查中，我们要再次确认服务器是否已经在执行
其他持久化操作，那么服务器将开始一次新的 BGREWRITEAOF 操作（因为条件1和条件 2
在这一步，服务器会关闭那些输出缓冲区大小超出限制的客户端，第13章对此有详细
如果服务器开启了AOF持久化功能，并且 AOF 缓冲区里面还有待写人的数据，那么
struct redisServer {
服务器状态的cronloops属性记录了 serverCron函数执行的次数：
图14-9以流程图的方式展示了这个检查过程。
int cronloops;
二
serverCron 函数的运行次数计数器
关闭异步客户端
服务器没有在执行任何持久化操作
有BGREWRITEAOF被延迟？
是
图14-9判断是否需要执行持久化操作
执行 BGREWRITEAOF
执行 BGSAVE
自动保存的条件已经满足？
是
AOF重写的条件已经满足？
明
不做动作
第14章服务器191
---
## Page 196
192第二部分单机数据库的实现
个函数最开头的一部分代码：
server 作为服务器的状态，并为结构中的各个属性设置默认值。
连接等等，本节接下来的内容将对服务器的整个初始化过程进行详细的介绍。
置过程，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络
14.3
serverCron函数N次就执行一次指定代码”的功能，方法如以下伪代码所示：
14.3.1
初始化 server 变量的工作由 redis.c/initServerConfig 函数完成，以下是这
初始化服务器的第一步就是创建一个 struct redisServer 类型的实例变量
void initServerConfig(void)(
一个 Redis 服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设
if cronloops  N == 0:
cronloops 属性目前在服务器中的唯一作用，就是在复制模块中实现“每执行
口设置服务器的默认配置文件路径。
口设置服务器的默认运行频率。
口设置服务器的运行 ID。
以下是initServerConfig 函数完成的主要工作:
getRandomHexChars (server.runid, REDIS _RUN_ID_SIzE) ;
//设置服务器的运行 id
初始化服务器状态结构
1/设置默认服务器端口号
执行指定代码．.·
server.port = REDIS_SERVERPORT;
server.arch_bits = (sizeof(long) =s 8) ? 64 : 32;
//设置服务器的运行架构
server.hz = REDIS_DEFAULT_HZ;
/1设置默认务器频率 
//设置默认配置文件路径
server.runid[REDIS_RUN_ID_SIZE] = '\o';
//为运行 id 加上结尾字符
初始化服务器
---
## Page 197
行修改。
户给定的配置参数和配置文件，并根据用户设定的配置，对 server 变量相关属性的值进
块的压缩功能。
终端中输人：
置。举个例子，如果我们在终端中输人:
14.3.2载入配置选项
构，数据库、慢查询日志、Lua 环境、共享对象这些数据结构在之后的步骤才会被创建出来。
符串属性，除了命令表之外，initServerConfig 函数没有创建服务器状态的其他数据结
毁一
服务器在用initServerConfig 函数初始化完 server 变量之后，就会开始载人用
例如，在初始化 server变量时，程序会为决定服务器端口号的port 属性设置默认值：
那么我们就通过指定配置文件的方式修改了服务器的数据库数量，以及 RDB持久化模
那么我们就通过给定配置参数的方式，修改了服务器的运行端口号。另外，如果我们在
并且redis.conf文件中包含以下内容：
$ redis-server redis.conf
$ redis-server --port 10086
在启动服务器时，用户可以通过给定配置参数或者指定配置文件来修改服务器的默认配
一载人配置选项。
当 initServerConfig 函数执行完毕之后，服务器就可以进人初始化的第二个阶
void initServerConfig(void){
#关闭 RDB文件的压缩功能
#将服务器的数据库数量设置为32个
initServerConfig 函数设置的服务器状态属性基本都是一些整数、浮点数、或者字
rdbcompressionno
databases 32
口创建命令表。
口 初始化服务器的LRU时钟。
口设置服务器的默认RDB持久化条件和AOF持久化条件。
口设置服务器的默认端口号
口设置服务器的运行架构。
!...
server.port = REDIS_SERVERPORT;
/1默认值为6379
！.··
第14章服
务器+193
---
## Page 198
194·第二部分单机数据库的实现
然后才能正确地对数据结构进行初始化。如果在执行initServerConfig函数时就对数据
结构分配内存，并在有需要时，为这些数据结构设置或者关联初始化值。
14.3.3初始化服务器数据结构
进人初始化的第三个阶段一
指定的 32 个。
dbnum属性的值就会被更新为 32，这将使得服务器的数据库数量从默认的16个变为用户
定的10086。
port 属性的值就会被更新为10086，这将使得服务器的端口号从默认的6379 变为用户指
服务器到现在才初始化数据结构的原因在于，服务器必须先载人用户指定的配置选项，
一个数据结构，不过除了命令表之外，服务器状态还包含其他数据结构，比如：
当初始化服务器进行到这一步，服务器将调用 initServer 函数，为以上提到的数据
在之前执行initServerConfig 函数初始化 server 状态时，程序只创建了命令表
口 server.clients 链表，这个链表记录了所有与服务器相连的客户端的状态结构,
服务器在载人用户指定的配置选项，并对 server 状态进行更新之后，服务器就可以
其他配置选项相关的服务器状态属性的情况与上面列举的 port 属性和 dbnum 属性一样:
 用于保存慢查询日志的 server.slowlog 属性。
口用于执行Lua脚本的Lua环境 server.lua。
口用于保存频道订阅信息的 server.pubsub_channels 字典，以及用于保存模式
口如果用户没有为属性的相应选项设置新的值，那么服务器就沿用之前
不过，如果用户在启动服务器时为选项 databases 设置了值32，那么 server.
例如，在初始化 server 变量时，程序会为决定数据库数量的 dbnum 属性设置默认值:
不过，如果用户在启动服务器时为配置选项 port 指定了新值10086，那么 server.
口server.db 数组，数组中包含了服务器的所有数据库。
口如果用户为这些属性的相应选项指定了新的值，那么服务器就使用用户指定的值来
void initServerConfig(void) (
订阅信息的 server.pubsub_patterns 链表。
链表的每个节点都包含了一个redisClient 结构实例。
initServerConfig 函数为属性设置的默认值。
更新相应的属性。
!...
server.dbnum = REDIS_DEFAULr_DBNUM;
11默认值为16
一初始化服务器数据结构。
---
## Page 199
不同：
AOF文件，并根据文件记录的内容来还原服务器的数据库状态。
14.3.4
图标，以及 Redis 的版本号信息：
性，而initServer 函数主要负责初始化数据结构。
将 server 状态的初始化分为两步进行，initServerConfig 函数主要负责初始化一般属
务器就要重新调整和修改已创建的数据结构。为了避免出现这种麻烦的情况，服务器选择了
结构进行初始化，那么一旦用户通过配置选项修改了和数据结构有关的服务器状态属性，服
根据服务器是否启用了AOF持久化功能，服务器载人数据时所使用的目标文件会有所
在完成了对服务器状态 server 变量的初始化之后，服务器需要载人 RDB 文件或者
口如果服务器启用了AOF 持久化功能，那么服务器使用 AOF 文件来还原数据库状态。
当initServer 函数执行完毕之后，服务器将用ASCII字符在日志中打印出 Redis 的
口初始化服务器的后台 I/O 模块（bio），为将来的 I/O 操作做好准备。
口 如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果AOF文件不存在，
口打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正
口创建共享对象：这些对象包含 Redis 服务器经常用到的一些值，比如包含“OK”回复
口为服务器设置进程信号处理器。
那么创建并打开一个新的AOF 文件，为AOF 写人做好准备。
式运行时接受客户端的连接。
为 serverCron 函数创建时间事件，等待服务器正式运行时执行serverCron 函数。
象等等，服务器通过重用这些共享对象来避免反复创建相同的对象。
的字符串对象，包含＂ERR"回复的字符串对象，包含整数1到10000的字符串对
[5244] 21 Nov 22:43:49.084 # Server started, Redis version 2.9.11
还原数据库状态
PID:5244
Redis 2.9.11 (b139a2ac/0) 64 bit
http://redis.io
第14章服务器·195
---
## Page 200
196·第二部分单机数据库的实现
14.4重点回顾
处理客户端发来的命令请求了。
14.3.5执行事件循环
库状态所耗费的时长：
口一个命令请求从发送到完成主要包括以下步骤：1）客户端将命令请求发送给服务器；
至此，服务器的初始化工作圆满完成，服务器现在开始可以接受客户端的连接请求，并
口服务器从启动到能够处理客户端的命令请求需要执行以下步骤：1）初始化服务器状
口serverCron函数默认每隔100 毫秒执行一次，它的工作主要包括更新服务器状态
并开始执行服务器的事件循环（loop）。
[5244] 21 Nov 22:43:49.084 * The server is now ready to accept connections on port 6379
在初始化的最后一步，服务器将打印出以下日志：
[5244] 21 Nov 22:43:49.084 * DB loaded from disk: 0.068 seconds
当服务器完成数据库状态还原工作之后，服务器将在日志中打印出载人文件并还原数据
口相反地，如果服务器没有启用 AOF持久化功能，那么服务器使用 RDB 文件来还原
数据库状态。
行事件循环。
态；2）载人服务器配置；3）初始化服务器数据结构；4）还原数据库状态；5）执
行持久化操作等等。
信息，处理服务器接收的 SIGTERM 信号，管理客户端资源和数据库状态，检查并执
现函数，然后执行实现函数并得出命令回复；4）服务器将命令回复返回给客户端。
2）服务器读取命令请求，并分析出命令参数；3）命令执行器根据参数查找命令的实
---
## Page 201
第17章
第16章Sentinel
第15章复制
集群
多机数据库的实现
第三部分
---
## Page 202
据库状态一致”，或者简称“一致”。
127.0.0.1:6379则会成为127.0.0.1:12345的主服务器。
以下命令：
127.0.0.1:6379和127.0.0.1:12345，如果我们向服务器127.0.0.1:12345发送
的服务器则被称为从服务器（slave），如图15-1所示。
的服务器为主服务器（master），而对主服务器进行复制
器去复制（replicate）另一个服务器，我们称呼被复制
进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“数
假设现在有两个Redis服务器，地址分别为
那么不仅主服务器上的 msg 键会被删除：
另一方面，如果我们在主服务器中删除了键msg：
比如说，如果我们在主服务器上执行以下命令：
在 Redis 中，用户可以通过执行 SLAVEOF命令或者设置 slaveof 选项，让一个服务
127.0.0.1:6379> DEL msg
又可以在从服务器上获取msg键的值：
"hello world"
127.0.0.1:6379> GET msg
那么我们应该既可以在主服务器上获取 msg 键的值：
(integer) 1
127.0.0.1:12345> GET msg
127.0.0.1:12345> SLAVEOF 127.0.0.1 6379
复
第15章
制
图15-1主服务器和从服务器
主服务器
复制
从服务器
---
## Page 203
命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。
服务器执行BGSAVE命令时的数据库状态。
文件发送给从服务器，从服务器接收并载人这个RDB文件，将自己的数据库状态更新至主
用一个缓冲区记录从现在开始执行的所有写命令。
SYNC命令的执行步骤：
状态。
先需要执行同步操作，也即是，将从服务器的数据库状态更新至主服务器当前所处的数据库
15.1.1同步
15.1
器心跳检测机制的实现原理，并对基于心跳检测实现的几个功能进行介绍。
解决旧版复制功能的低效问题的，并说明部分重同步的实现原理。
功能在处理断线后重新连接的从服务器时，会遇上怎样的低效情况。
topics/replication）已经做了很详细的介绍，这里不再赞述。
4）主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写
3）当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB
从服务器对主服务器的同步操作需要通过向主服务器发送 SYNC 命令来完成，以下是
在此之后，本章将列举 SLAVEOF命令的具体实现步骤，并在本章最后，说明主从服务
接着，本章将介绍 Redis 从 2.8版本开始使用的新版复制功能是如何通过部分重同步来
本章首先介绍 Redis 在 2.8版本以前使用的旧版复制功能的实现原理，并说明旧版复制
2）收到 SYNC命令的主服务器执行 BGSAVE命令，在后台生成一个 RDB 文件，并使
1）从服务器向主服务器发送SYNC命令。
当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首
本节接下来将对同步和命令传播两个操作进行详细的介绍。
口命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状
口同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。
Redis 的复制功能分为同步（sync）和命令传播（command propagate）两个操作：
关于复制的特性和用法还有很多，Redis 官方网站上的《复制》文档（http://redis.io/
127.0.0.1:12345> EXISTS msg
从服务器上的 msg 键也应该会被删除：
(integer)0
(integer) 0
127.0.0.1:6379> EXISTS msg
态出现不一致时，让主从服务器的数据库重新回到一致状态。
旧版复制功能的实现
第 15章  复 
制·199