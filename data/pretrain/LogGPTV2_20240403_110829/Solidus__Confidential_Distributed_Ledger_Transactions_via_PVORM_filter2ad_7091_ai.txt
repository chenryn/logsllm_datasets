Hybrid H0 contains a dummy simulator that passes messages be-
tween A and honest parties unchanged. This is identical to the
FLedger-hybrid world.
Hybrid H1 is the same as H0 except that S maintains its own
simulated copy of FLedger that behaves as FLedger except for the
initialization, which it does not emulate. During initialization, S
passes the actual values sent by FLedger to A without modification.
All other operations are emulated faithfully. We note that all non-
initialization operations require only public information (including
public keys). When an honest bank posts to FLedger, S copies the
message to its own copy, and when A posts to FLedger, S first
simulates the behavior on its copy, and if the post is accepted, it
forwards the post to the real FLedger.
Since all posts to FLedger are either dropped silently or broadcast
in their entirety to all banks, S’s faithful simulation of a copy will
result in a view that is identical to real execution.
Hybrid H2 proceeds as in H1 except whenever S receives any
proofs or signatures constructed by an honest party—as part of
20
a request, PVORM update, or “postTxn” message from FLedger—
it stores the real proofs and signatures and replaces them with
forgeries. S sends the forgeries to A (or the simulated FLedger),
and if a message containing those proofs would be sent back to an
honest party (or forwarded to the real FLedger), S puts the original
(real) proofs and signatures back in place.
Note that this forgery and replacement only applies to the spe-
cific proofs and signatures constructed by honest parties. Mes-
sages from honest parties containing proofs and signatures from
A-controlled parties—such as the request signature from an A-
controlled user at an honest bank included with the final transaction—
have only the honest signatures and proofs replaced. The values
computed by A are left exactly in-tact.
As all proofs in the system are cSE NIZKs, S can forge proofs that
A will accept and A still cannot forge proofs with non-negligible
probability. Since the only thing that has changed from H1 is these
forged proofs, H1 and H2 are computationally indistinguishable.
Hybrid H3 is much like H2, but S also replaces the values of all
encryptions generated by honest parties under honest-party keys,
including PVORM values. S replaces these values with randomly-
selected values encrypted under the same keys. Again, it saves
the real values and real proofs when communicating with honest
parties, but it uses the random values with A. Since S only replaces
values that A did not generate and are encrypted under public keys
for which A does not know the secret key, the semantic security
of the encryption scheme guarantees that H3 is indistinguishable
from H2. The proofs do not present a concern as they were already
forged (for the real values) in H2, so they remain forged (for the
random values) in H3.
Hybrid H4 differs from H3 in that S now emulates the initialization
in FInit. It generates fake keys and PVORMs—from the correct
distribution—for all parties and sends those to A instead of those
generated by FInit. Any encrypted values written by A will be
encrypted under the new (fake) keys for which S knows the secret
key, and any values intended to be read by A and written by an
honest party will be encrypted under a key given to S by the real
FInit. In either case, S can decrypt the ciphertext and re-encrypt
the plaintext under the other set of keys before passing an honest
message to A or A’s message to an honest party. The same is true
for signatures and proofs created by A.
For encryptions under honest-party keys written by honest par-
ties as well as proofs and signatures created by honest parties, S
already replaced those in H3 with random values and forgeries,
respectively, so it simply does the same but under the new (fake)
keys.
In this manner, all values, proofs, and signatures viewed by
A in H4 are the same as those in H3, but using different encryp-
tion/signing keys and different randomness. All encryptions, proofs,
and signatures generated by S to an honest party are similarly the
same, but with different randomness. Since the keys and random-
ness are selected faithfully from exactly the original distributions,
H3 and H4 are identically distributed.
Hybrid H5 proceeds as H4, but S separates the transaction IDs
used by A from those used by honest parties. Whenever a new
request comes from A with transaction ID txidA, S generates a
new unique txidF to associate with the transaction with honest
parties. Whenever a message with a previously-unseen transaction
ID txidF comes in from an honest party (or FLedger), S generates
a new unique txidA before forwarding to A (or the simulated
FLedger). If, for an incoming message in either direction, S has seen
the ID before, there must be an associated ID in the other set, so it
simply uses that.
Since only the transaction IDs have changed and the new IDs are
drawn independently from the old IDs using the same methodology,
H4 and H5 are identically distributed.
Hybrid H6 is the same as H5 except S verifies all proofs and signa-
tures generated by A on all messages. If any proof or signature fails
to verify, S drops the message and does not forward it. Because all
proofs are verified in ProtSol (either by the receiving party or by
FLedger) before any other processing is done, and Z dictates that if
an assertion fails, the honest party behaves as if the associated mes-
sage had never arrived, this will not change any message received
by A or the behavior of any honest parties. Similarly, H6 drops
all messages containing transaction IDs which have already been
posted to FLedger, which honest parties will similarly drop. By the
simulation soundness of the NIZKs employed, A has a negligible
probability of forging a proof and thus there is a negligible proba-
bility of passing through a message that will be ignored anyway.
Hence H5 and H6 are computationally indistinguishable.
Hybrid H7 is the most complex step, as we now replace all honest-
party communication with FSol. We now describe what S does in
H7 whenever it would send a message to an honest party in H6 and
whenever it receives a message from FSol in H7.
• When S would send a “requestTxn” request to an honest bank B
on behalf of a compromised userUs in H6, S instead decrypts the
values supplied by A to get the plaintext value $v and receiving
user Ur and sends (“requestTxn”,Ur , $v) to FSol on behalf of
Us. Instead of creating its own txidF to link to the txidA for this
transaction, it uses the one returned by FSol.
• When S would send an “approveSendTxn” message to and hon-
est bank in H6, it first checks if there is an associated txidF from
FSol, or if the message is coming unprompted from A. In the first
case it sends (“approveSendTxn”, txidF ) to FSol. In the second
case, it first decrypts the request included with the transaction
data, which must be from a compromised user U at a compro-
mised bank B—otherwise the request would have come through
FSol or the proofs would fail to verify and H6 would already have
dropped it. It then submits the associated “requestTxn” mes-
sage to FSol from U. Upon receiving an associated txidF and
(“req”, txidF ,Us , Br , $v), S sends (“approveSendTxn”, txidF )
to FSol.
• When S would send an “approveRecvTxn” message to the real
FLedger (after passing through the simulated one), it again checks
for an associated txidF from FSol. If none is found, then the
transaction must entirely be executed by compromised entities
for same reason described above. In this case, S decrypts the
transaction details and executes the entire transaction on FSol.
If an txidF is found and S has seen a “req” response from
FSol but not a “aprv” message, then it must be the case that
both banks are compromised. As with above, S finishes the
21
transaction in order, first sending (“approveSendTxn”, txidF )
and then (“approveRecvTxn”, txidF ).
Finally, if txidF is found and S has seen a “aprv” message
from FSol for txidF , then it simply sends (“approveRecvTxn”, txidF ).
• When S would send an “abortTxn” message to the real FLedger,
it again checks if there is an associated txidF . If there is, it sends
(“abortTxn”, txidF ) to FSol. If not, it generates a random txid
and sends (“abortTxn”, txid) to FSol.
Note that with negligible probability this new txid will conflict
with an existing transaction ID and the abort will not be received,
but except with negligible probability this will appropriately
create an abort for a non-existent transaction.
• We handle S receiving (“req”, txidF ,Us , Br , $v) from FSol in
two cases.
(1) If Br is honest, then S acts as it would in H6 upon receiving a
valid (“requestTxn”, txidF , ePKs , cv , cr , σ ) from Us, noting
that in that case it can decrypt the identity of Us and $v, but
not the identity of the receiving user.
(2) If Br is compromised, while S would have forwarded a
“requestTxn” message in H6, it does not have sufficient in-
formation to create the details of that request correctly. To
acquire that information, S immediately replies to FSol with
(“approveSendTxn”, txidF ).
• When S receives (“aprv”, txidF , Bs ,Ur , $v) from FSol, we again
have three cases.
(1) If Bs is compromised, then we must have been in case 2
above. Thus S now has sufficient information to create a
complete “requestTxn” message as it would in H6, so it does
so and submits that request to A.
(2) If Bs is honest but the user who originally requested this
transaction Us is not, then there must be some txidA as-
sociated with txidF and an associated request. S can thus
manufacture an “approveSendTxn” message to submit to A.
As in H6, S uses the stored request for values created by Us
and falsifies values created by the honest Bs.
(3) If Bs and the sending user Us are both honest, then S must
create a new unique txidA and create an “approveSendTxn”
message as in H6. Note that the values S could decrypt in
H6 were the identity of Ur and $v, so it encrypts the correct
values for those and falsifies other values.
• When S receives (“postTxn”, txidF , Ps → Pr ) from FSol, Since
this proof does not handle asset notaries, we can assume Ps and
Pr are both banks. There are three cases to consider.
First we consider the simplest case: when Pr is a compromised
bank. In this case the transaction will only clear through FSol
after S successfully posts it to (the simulated) FLedger. Thus there
is nothing to do.
Next we consider the case where Ps is a compromised bank
but Pr is honest. Here txidF must correspond to txidA for the
pending transaction in S’s simulation of Pr . In order for the
transaction to be approved by the sender in FSol, S must have
received and verified (“signRecvTxn”, txidA, txdatas ) from A.
At this point S updates Pr ’s simulated PVORM with random
values and forged proofs (as in H6) and posts the full transaction
to FLedger. We note that A cannot have already submitted a
transaction to FLedger with ID txidA since honest banks respond
instantly, so this must be in response to approving the sending of
a transaction and H6 would have dropped that message if txidA
had already been posted to FLedger.
Finally, we consider the case where Ps and Pr are both honest.
In this case S manufactures random updates to the respective
PVORMs and forges all associated proofs. If txidF already cor-
responds to some txidA, that means the requesting user was
compromised, and S simply uses that request. Otherwise S se-
lects a new unique txidA and creates a request specification
(again with random values and forged proofs). It then posts the
result to the simulated FLedger. We note that this is precisely the
value that would have been posted to the simulated FLedger in
H6.
• When S receives (“abortTxn”, txidF , B) from FSol, it first checks
of B is compromised. If so, this must be the response after send-
ing an abort to FSol and there is nothing to do. If not, S checks
if there is a known txidA already linked to txidF and generates
a new unique txidA otherwise. It then generates an abort opera-
tion using random values and forged proofs, as in H6 and posts
it to FLedger. It also clears the simulated pending transactions for
B (which will only happen if txidA already existed).
Thus we see that each hybrid is computationally indistinguish-
able from the next, H0 corresponds to the FLedger-hybrid world,
and H7 corresponds to the ideal world. Thus ProtSol achieves the
desired security.
□
D VARIANTS
We now present three variants on the Solidus system based on
different architectural primitives. They provide different guarantees
and features which we believe are relevant.
D.1 zk-SNARK PVORM
Though GSPs are highly efficient to construct, they can be quite
large and expensive to verify. In circumstances where the size of
proofs or the verification time is more important than generation
time, zk-SNARKs provide a good alternative. While we could im-
plement the Circuit ORAM-based PVORM described in Section 4
and Appendix B using zk-SNARKs, the large numbers of reencryp-
tions would result in very expensive proofs, even if we were to use
symmetric-key primitives. Instead, in Section 7.3 we describe and
evaluated a different construction, based on a Merkle tree, which is
much more efficient for zk-SNARKs than use of Circuit ORAM.
Our evaluation in Table 1 shows the performance for a single
bank update at 128-bit security level, using libsnark [10] as the
back end for computing the zk-SNARK proofs. The Merkle tree has
depth 15 giving the PVORM a capacity of 215 (the same as in our GSP
tests). Our implementation includes zk-SNARK-optimized SHA-256
circuits for the Merkle tree, and optimized circuits for RSA-3072
encryption (RSAES-PKCS1-v1_5) and signatures (RSASSA-PKCS1-
v1_5 with SHA-256). We used PKCS #1 v1.5 primitives instead
of the more up-to-date PKCS #1 v2.2 primitives and alternative
public-key schemes for three reasons: they yield less expensive
zk-SNARK circuits, they are still used in practice, and they provide
a conservative (i.e. competitive) comparison point for GSPs.
When used in Solidus, the zk-SNARK PVORM construction has
the clear drawback that the ledger does not contain each user’s
account balance, even in encrypted form. To compute a user’s bal-
ance, an auditor would need to parse the transaction ciphertexts,
decrypt them and perform all the operations. To reduce such over-
head in practice, however, the bank may periodically checkpoint
balances. Specifically, it may submit an encrypted version of the
Merkle tree leaves, and prove that the encryptions are consistent
with a published Merkle tree digest using another zk-SNARK proof.
Such a proof is quite expensive to construct, and could only be
done periodically, e.g., once per day, without significantly affecting
the system throughput. But as transactions are accompanied by
ciphertexts, an auditor can start at a checkpoint and then decrypt
all subsequent transactions to learn current account balances.
Of course, proof generation times are more important in the appli-
cations targeted by Solidus, and in our discussions with blockchain
industry technologists, the engineering complexity of zk-SNARKs
and trusted setup make them less viable than GSPs today. But zk-
SNARKs offer an interesting alternative construction and illustrate
what could be a valuable point in the PVORM design space.
D.2 Use of Trusted Hardware
Using Intel Software Guard Extensions (SGX) it is possible to con-
struct a much more efficient PVORM. SGX provides a new set of
instructions that permits execution of an application inside an
enclave [4, 43, 52], which protects the application’s control-flow in-
tegrity and confidentiality against even a hostile operating system.
SGX additionally enables generation of attestations that prove to
a remote party that an enclave is running a particular application
(identified as a hash of its build memory).
To reduce the expense of attestations, an enclave can generate a
signing key pair and attest to the integrity of the public key [32, 63].
It can then generate the equivalent of a NIZK by simply signing
an assertion that it knows a witness to the statement. Trust in
SGX then translates to trust in the application and thus its asser-
tions. Verifying an assertion requires only a single digital signature
verification.
Using an SGX-based approach, we can build an extremely fast
PVORM. We replace the public-key encryption with symmetric-
key encryption and all NIZKs with SGX-signed assertions. We can
even employ write-only ORAM to further improve performance.
Additionally, a PVORM constructed in the Sealed-Glass Proof (SGP)
model [58] provides security against arbitrarily strong side-channel
attacks, provided that the secret signing key remains protected—
such as by using a side-channel-resistant crypto library.
While several complications remain to be address (e.g., the need
to share keys across enclaves on different hosts in case of failure),
we believe that this approach is eminently practical—albeit under
the (strong) assumption of trust in Intel and SGX’s implementation.
D.3 Use of Pedersen Commitments
One of the important features of Solidus is auditability, which is
greatly aided by having all account balances encrypted on the
ledger. Many financial companies and regulatory agencies are, how-
ever, wary to include this information, even in encrypted form [12,
22
35, 59]. While we believe it would degrade the functionality signifi-
cantly to omit these encryptions, it is not particularly difficult.
Instead of including encrypted balances on the ledger, banks
could instead represent PVORM elements as Pedersen commit-
ments [51]. Unlike El Gamal ciphertexts, Pedersen commitments
are perfectly hiding and computationally binding. To implement
this, banks would need to retain witnesses for each commitment,
which consists of both the account balance and the randomization
factor. The bank could then reveal this witness to an auditor in
order to prove an account balance, and the proof schemes used
with El Gamal ciphertexts would require only slight modification
to prove information about the known witnesses.
23