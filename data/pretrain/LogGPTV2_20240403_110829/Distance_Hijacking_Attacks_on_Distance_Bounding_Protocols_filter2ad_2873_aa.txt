title:Distance Hijacking Attacks on Distance Bounding Protocols
author:Cas J. F. Cremers and
Kasper Bonne Rasmussen and
Benedikt Schmidt and
Srdjan Capkun
2012 IEEE Symposium on Security and Privacy
Distance Hijacking Attacks on Distance Bounding Protocols
Cas Cremers
ETH Zurich
Kasper B. Rasmussen
University of California, Irvine
Benedikt Schmidt
ETH Zurich
Srdjan ˇCapkun
ETH Zurich
Information Security group
Computer Science Dept.
Zurich, Switzerland
PI:EMAIL
Irvine, California
PI:EMAIL
Information Security group
Systems Security group
Zurich, Switzerland
PI:EMAIL
Zurich, Switzerland
PI:EMAIL
Abstract—After several years of theoretical research on
distance bounding protocols, the ﬁrst implementations of such
protocols have recently started to appear. These protocols are
typically analyzed with respect to three types of attacks, which
are historically known as Distance Fraud, Maﬁa Fraud, and
Terrorist Fraud.
We deﬁne and analyze a fourth main type of attack on
distance bounding protocols, called Distance Hijacking. This
type of attack poses a serious threat in many practical scenarios.
We show that many proposed distance bounding protocols are
vulnerable to Distance Hijacking, and we propose solutions to
make these protocols resilient to this type of attack.
We show that verifying distance bounding protocols using
existing informal and formal frameworks does not guarantee
the absence of Distance Hijacking attacks. We extend a formal
framework for reasoning about distance bounding protocols to
include overshadowing attacks. We use the resulting framework
to prove the absence of all of the found attacks for protocols
to which our countermeasures have been applied.
Keywords-Distance bounding, location veriﬁcation, position
veriﬁcation, attacks, hijacking, multi-prover environment, for-
mal model, formal veriﬁcation
I. INTRODUCTION
By using distance bounding protocols, a device (the
veriﬁer) can securely obtain an upper bound on its distance
to another device (the prover). A number of distance
bounding protocols were proposed in recent years [2], [4],
[5], [12], [14], [15], [19]–[21], [23], [24], [27]–[29]. The
proposed protocols differ in terms of the performance and
security guarantees that they provide. So far, several distance-
bounding protocols were implemented, some using digital
processing and short symbols [9], [16], whereas others rely on
analog processing and use signal streams (operating similarly
to radar systems) [23].
The security of distance-bounding protocols was so far
mainly evaluated by analyzing their resilience to three types
of attacks. For historical reasons, these are known as Distance
Fraud, Maﬁa Fraud and Terrorist Fraud. In Distance Fraud
attacks, a sole dishonest prover convinces the veriﬁer that
he is at a different distance than he really is. In Maﬁa Fraud
attacks, the prover is honest, but an attacker tries to modify
the distance that the veriﬁer establishes by interfering with
their communication. In Terrorist Fraud attacks, the dishonest
prover colludes with another attacker that is closer to the
© 2012, Cas Cremers. Under license to IEEE.
DOI 10.1109/SP.2012.17
113
veriﬁer, to convince the veriﬁer of a wrong distance to
the prover. So far, it was assumed that distance bounding
protocols that are resilient against these three attack types
can be considered secure.
However, we show that many of these protocols, irrespec-
tive of their physical-layer implementation, and including
the classical Brands and Chaum protocol [4] and the recent
CRCS protocol [23], are vulnerable to attacks when used
in environments with multiple provers. We coin this type of
attack Distance Hijacking. In Distance Hijacking attacks, a
dishonest prover convinces the veriﬁer that it is at a different
distance than it actually is, by exploiting the presence of an
honest prover. For example, one of the ways in which the
dishonest prover can achieve this is by hijacking the distance
measurement phase of a distance bounding protocol from
an honest (closer or further) prover. This type of attack can
pose a serious threat in many practical scenarios.
Conceptually, Distance Hijacking can be placed between
Distance Fraud and Terrorist Fraud. Unlike Terrorist Fraud,
in which a dishonest prover colludes with another attacker,
Distance Hijacking involves a dishonest prover interacting
with other honest provers. Unlike Distance Fraud attacks,
which involve only a dishonest prover and a veriﬁer, Distance
Hijacking attacks additionally involve other honest provers.
These differences have signiﬁcant consequences. For example,
the countermeasures proposed against Terrorist Fraud rely
on the assumption that dishonest provers are not willing
to share their keying material with other attackers. Such
countermeasures will therefore not deter the dishonest provers
from executing Distance Hijacking attacks that do not involve
other attackers. Furthermore, Distance Hijacking can occur
even in situations where Terrorist Fraud is not a concern.
In fact, as we will show, protocols that are resilient against
the three classical attack types may still be vulnerable to
Distance Hijacking.
We deﬁne an exhaustive classiﬁcation for attacks on
distance bounding protocols that includes Distance Hijacking.
Our classiﬁcation naturally leads to minor reformulations of
previously known attack types. Instead of using the traditional
attack names for our new deﬁnitions, we propose names that
are more descriptive and less generic.
We perform a case study of existing protocols. All distance
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:50:52 UTC from IEEE Xplore.  Restrictions apply. 
bounding protocols that were proposed in the last years
roughly fall into two categories: those based on the Brands
and Chaum protocol, and those based on the Hancke and
Kuhn protocol. We show that all proposed protocols that
followed the structure proposed by Brands and Chaum are
vulnerable to Distance Hijacking. Protocols that followed the
structure proposed by Hancke and Kuhn are less vulnerable
to this type of attack. We propose two classes of effective
and generic countermeasures that make Brands and Chaum
and related protocols secure against Distance Hijacking in
the above scenario. Our countermeasures are inexpensive:
the protocols can be repaired without introducing additional
messages or cryptographic operations.
Remarkably, none of the existing frameworks for analyzing
distance bounding protocols (e. g., [1], [3], [10], [18], [25])
guarantees the absence of our Distance Hijacking attacks,
even if some instances of Distance Hijacking can be detected
using some of those frameworks. We extend the formal
framework of Basin et al. [3] to capture all known types of
Distance Hijacking attacks and use the resulting framework
to analyze several protocols. The new framework enables us
to model bit-level manipulations of messages by considering
overshadowing parts of a message [22], as well as ﬂipping
some bits of a message. We use our framework to formally
prove for speciﬁc protocols that our ﬁxes indeed prevent the
found attacks.
We show that all distance bounding protocols, including
those based on the Hancke and Kuhn protocol, may be
vulnerable to Distance Hijacking if run alongside another
distance bounding protocol. This can occur if more than one
distance bounding protocol is used in the same environment,
i. e., a multi-protocol environment. In particular, some pro-
tocols, when run by an honest prover, enable a dishonest
prover (running, e. g., a Hancke and Kuhn protocol) to hijack
the distance of the honest prover. Such attacks can be seen
as a variant of the Chosen Protocol Attack [13]. However,
unlike Chosen Protocol attacks, our attacks do not require the
protocols to share any cryptographic material. We discuss
designs of distance bounding protocols that enable such
attacks and show how to mitigate these attacks.
Contributions: First, we identify Distance Hijacking
as a threat for distance bounding protocols that are run in
multi-prover environments, whose absence is not guaranteed
by existing frameworks. Second, we show that prominent
distance bounding protocols are vulnerable to Distance
Hijacking and propose countermeasures. Third, we extend a
formal framework for reasoning about Distance Bounding
protocols to model overshadowing attacks and use the result-
ing framework to prove correctness of our countermeasures
for speciﬁc protocols. Fourth, we address the security of
distance bounding protocols in multi-protocol environments
and propose mitigating measures. Finally, we generalize
Distance Hijacking to Location Hijacking, and show that it is
possible to hijack locations at which no other provers reside.
We proceed as follows. In Section II we provide background
on distance bounding protocols. In Section III we introduce
Distance Hijacking attacks and analyze the resilience of
existing distance bounding protocols against these attacks. We
relate the attacks to the classical attack types and provide an
exhaustive classiﬁcation. In Section IV we show how distance
bounding protocols can be made resilient against Distance
Hijacking. In Section V we present an extended formal
framework and analyze a set of protocols. In Section VI
we analyze the resilience of distance bounding protocols
to Distance Hijacking in multi-protocol environments. We
introduce the notion of Location Hijacking in Section VII,
present the related work in Section VIII, and conclude in
Section IX.
II. BACKGROUND
The goal of a distance bounding protocol is to enable a
veriﬁer to establish an upper bound on its physical distance to
a prover. As a running example, we consider the basic Brands
and Chaum protocol with signatures [4, p. 7], depicted in
Figure 1. In the protocol, the prover P randomly generates
(denoted by ∈R ) a bit string m1, . . . , mk, and sends a
commit of this value to the veriﬁer V . Thus, although the bit
string is not revealed yet, V will be able to check whether
P indeed committed to this particular string when V learns
the string later. The veriﬁer then generates his own random
bit string α1, . . . , αk, and initiates the so-called rapid bit
exchange. In this exchange, bits are sent one-by-one, and
the prover has to respond as quickly as possible with the
exclusive-or (⊕) of the challenge bit string α and his own
bit string. In the end, the veriﬁer will derive an upper bound
on the distance to the prover from the response times. Notice
that the prover can delay messages at will, making himself
appear farther away, but he cannot respond faster than what
is dictated by the time-of-ﬂight of the messages. After this
phase, P concatenates the bits as c, and sends to V a means to
open the commit he sent earlier, as well as the concatenation
c signed with his signature key. Upon receiving this ﬁnal
message, V veriﬁes that the commit previously sent by P
indeed matches with the response (by computing mi =
αi ⊕ βi and opening the commit), concatenates the bits he
has observed, and compares them to the received signature
using the public key of P .
Because the goal of a distance bounding protocol is to
provide a guarantee for the veriﬁer V , V will never participate
in an attack since that would mean V would be attacking
itself. The attacker can of course pretend to be another veriﬁer
V (cid:2), and abuse his location to attack the real veriﬁer V .
As stated in the introduction,
three different classes
of attacks are traditionally considered in the analysis of
distance bounding protocols: Distance Fraud, Maﬁa Fraud
and Terrorist Fraud. All attacks that fall into one of these
three classes have a similar goal, namely to make the veriﬁer
believe that the prover P is physically closer to the veriﬁer
114
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:50:52 UTC from IEEE Xplore.  Restrictions apply. 
msc Signature-based Brands and Chaum protocol
Prover
P
m ∈R {0, 1}k
Veriﬁer
V
commit (m)
α ∈R {0, 1}k
Rapid bit exchange for i = 1 to k
αi
βi
βi ← αi ⊕ mi
c ← α1|β1| · · · |αk|βk
(open commit), sign(c)
Verify commit
c ← α1|β1| · · · |αk|βk
verify sign(c)
Figure 1. Signature-based Brands and Chaum protocol.
V than it really is. The main difference between these attacks
is in the parties that carry out the attack, and their mutual
relationships.
Maﬁa Fraud attacks, also called relay attacks, were ﬁrst
described by Desmedt [8]. In this type of attack, both
the prover P and veriﬁer V are honest, and the attack is
performed by an external attacker A. The attacker attempts
to shorten the distance measured between the honest prover
and the veriﬁer. In Maﬁa Fraud attacks, the physical distance
between the attacker and the veriﬁer is typically small in
order for the attacker to be able to shorten the distance.
In a Distance Fraud attack, a dishonest prover P will
try to shorten the distance measured by the veriﬁer V . This
type of attack is executed by the dishonest prover P alone,
without collusion with other (external) parties. An example
of a Distance Fraud attack occurs if the protocol allows the
prover to send his reply before receiving the challenge. This
enables the prover to reply too early, thereby shortening the
distance measured by the veriﬁer.
The third class of attacks is Terrorist Fraud attacks [8]. In
this type of attack, a dishonest prover P collaborates with
an external attacker A to convince the veriﬁer V that he
is closer than he really is. All countermeasures to Terrorist
Fraud make the assumption that the dishonest prover P is
unwilling to reveal his long-term (private or secret) key to
the attacker A that he collaborates with. Possible reasons
for this unwillingness are impersonation, i. e., the external
attacker can later use the key to impersonate the dishonest
prover, and traceability, i. e., the key may later be used to
implicate the dishonest prover in performing a Terrorist Fraud
attack. Furthermore, from the perspective of the veriﬁer, it is
impossible to distinguish between the external attacker and
the prover if the attacker knows the long term key of the
prover.
III. DISTANCE HIJACKING
In this section we deﬁne a fourth class that has until
now been overlooked in the design of distance bounding
protocols, Distance Hijacking attacks. We relate this class
of attacks to the three classical attack types on distance
bounding protocols, and propose an exhaustive classiﬁcation
of attacks on distance bounding protocols.
A. Distance Hijacking attacks
We say that a prover P is honest if and only if all of P ’s
actions conform to the protocol speciﬁcation.
Deﬁnition 1. A Distance Hijacking attack is an attack in
which a dishonest prover P exploits one or more honest par-
ties P1, . . . , Pn to provide a veriﬁer V with false information
about the distance between P and V .
A protocol is then said to be vulnerable to Distance
Hijacking if it allows P to perform a successful Distance
Hijacking attack. We observe that these attacks do not exclude
the involvement of other attackers with whom the dishonest
prover is colluding or the involvement of other honest veriﬁers
that might enable the execution of the attack.
In the context of distance bounding protocols, the infor-
mation about the distance is the upper bound; hence attacks
involve convincing V that P is closer than it actually is. In
a typical Distance Hijacking attack on a distance bounding
protocol, a dishonest prover P convinces a veriﬁer V that
P has executed a distance measurement phase (e. g., a rapid
bit exchange) with V , whereas this phase has been really
executed by an honest prover P (cid:2). This is done without the
cooperation of the honest prover P (cid:2). Often this type of attack
can be carried out by allowing the honest prover to complete
the distance bounding protocol as he normally would, and
then by replacing all messages that contain signatures or
MACs, with messages signed (or MAC’ed) by the attacker.
Example 1 (Distance hijacking attack on signature-based
Brands and Chaum). Figure 2 depicts a basic Distance
Hijacking attack on the signature-based Brands and Chaum
from Figure 1.
In the attack, V thinks he is communicating with P , where
P is dishonest. When an honest prover P (cid:2) tries to prove his
distance, P initially allows the protocol to proceed as normal
between P (cid:2) and V , waiting until the ﬁnal signature is sent
by P (cid:2). Note that before this point, V has no cryptographic
evidence that the messages it received were indeed sent by
P (cid:2). When P (cid:2) sends the signature, P jams the message and
re-signs the content c with his own signature key, and sends
the result to V . V will successfully verify the commit as well
as the signature, and will falsely conclude that P has also
sent the previous message. Thus, V assumes that P is within
115
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:50:52 UTC from IEEE Xplore.  Restrictions apply. 