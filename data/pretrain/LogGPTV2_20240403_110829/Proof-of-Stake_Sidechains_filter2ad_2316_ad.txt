different parts of the protocol in differing levels of detail.
This level is always chosen with the intention to allow the
reader to easily ﬁll in the details. A graphical depiction of our
construction that can serve as a reference is given in Figure 2.
1) Notation: Where applicable, we denote the analogues
of the mainchain objects on the sidechain with an additional
overline. In our pseudocode, we use the statement “post tx
to L” to refer to the action of broadcasting the transaction
tx to the maintainers of the ledger L so that they include it
147
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:41 UTC from IEEE Xplore.  Restrictions apply. 
DFWLYDWLRQSHULRG
VWDEOHEORFNV5N
N
0&

HSRFKMDGRSW
HSRFKMVWDUW



6&





Fig. 2: Our sidechain construction. Blocks are shown as rect-
angles. Adjacent blocks connect with straight lines. Squiggly
lines indicate some blocks are omitted. MC is at the top, SC
at the bottom. Epochs are separated by dashed lines. ejadopt
is the epoch of ﬁrst signalling; ejstart is the activation epoch.
Blocks of interest: 1. The ﬁrst block signalling SC awareness;
2. The SC genesis block; 3. A txsend transaction for a deposit;
4. A txrec transaction for a deposit; 5. A txsend transaction for
withdrawal; 6. A sc cert transaction signalling trust transition
within SC and certifying pending withdrawals; 7. A txrec
transaction for withdrawal, certiﬁed in a sc cert transaction
e.g. in block 6.
in the ledger eventually as prescribed by the protocol. Unless
indicated otherwise, we also denote by MC (resp. SC) the
current ledger state of the ledger MC (resp. SC) as viewed
by the party executing the protocol. Similarly, we denote by
CMC (resp. CSC) the currently held chain corresponding to
the ledger MC (resp. SC). Hence, for example MC always
represents the state stored in the stable part of the chain CMC.
2) Helper Transactions and Data: The construction uses
a set of helper transactions which can be included in both
blockchains, but do not get reported in the respective ledgers.
These helper transactions store the appropriate metadata which
is implementation-speciﬁc and allow the pegging functionality
to be maintained. The transaction types sidechain support,
sidechain certiﬁcate, sidechain success and sidechain failure,
whose nature will be detailed later, are of this kind. Moreover,
our concrete implementation of pegged ledgers extends certain
transactions with additional information (such as Merkle-tree
inclusion proofs) that are, for convenience, understood to
be stripped off these transactions when the blockchain is
interpreted as a ledger.
3) Initialisation: The creation of a new sidechain SC starts
by any of the stakeholders of the mainchain adopting the code
that implements the sidechain. This action does not require
the stakeholders to put stake on the sidechain but merely
to run the code to support it (e.g. by installing a pluggable
module into their client software). In the following this is
referred to as “adopting the sidechain” and captured by the
predicate SidechainAdoption. The adoption is announced at
the mainchain by a special transaction detailed below. Each
sidechain is identiﬁed by a unique identiﬁer idSC.
Let jadopt denote the epoch on MC when the ﬁrst adoption
transaction has appeared; the sidechain SC – if its activation
succeeds as discussed below – will start at the beginning of
some later epoch jstart and will have its slots and epochs
synchronized with MC. The software module implementing
the sidechain comes with a set of deterministic rules describing
the requirements for the successful activation of the sidechain,
as well as for determining jstart. These rules are sidechain-
speciﬁc and are captured in a predicate ActivationSuccess and
a function ActivationEpoch, respectively. One typical such
example is the following: the sidechain starts at the beginning
of MC-epoch jstart for the smallest jstart that satisﬁes: (i)
jstart − jadopt > c1; (ii) at least c2-fraction of stake on MC
is controlled by stakeholders that have adopted SC; for some
constants c1,c2. Additionally, if such a successful activation
does not occur until a failure condition captured by a predicate
ActivationFailure is met (e.g. until a predetermined period of
c3 > c1 epochs has passed), the sidechain initialization is
aborted.
The activation process then follows the steps outlined
below, the detailed description is given in Algorithm 2 in
Appendix B. First, every stakeholder Ui of MC (holding a
key pair (vk, sk)) that supports the sidechain posts a special
transaction (sidechain support, idSC, vk, vk(cid:5)
), signed by sk
into the mainchain. Here vk(cid:5) is a public key from an ATMS
key pair freshly generated by Ui; its role is explained in
Section IV-C8 below.
If the sidechain activation succeeds, then during the ﬁrst
slot of epoch jstart
the stakeholders of MC that support
SC construct the genesis block G = (idSC, SDjstart , ¯ηjstart (cid:2)
H(idSC, ηjstart ),P, avkjstart ) for SC. ηjstart is the randomness
for leader election on MC in epoch jstart (derived on MC in
epoch jstart − 1). It is reused to compute the initial sidechain
for j(cid:5) > jstart are
randomness ¯ηjstart as well, further ¯ηj(cid:3)
determined independently on SC using the Ouroboros coin-
tossing protocol.5 Furthermore, P and avkjstart are public
parameters and an aggregated public key of an ATMS scheme;
their creation and role is discussed in Section IV-C8 below.
Note that G is deﬁned mostly for notational compatibility, as
SDjstart is empty at this point anyway. G can be constructed as
soon as ηjstart is known and stable.
The stakeholders that adopted SC post into MC a trans-
action sidechain success(idSC) to signify that SC has been
initialized. If the sidechain creation expires, then, after the
the
ﬁrst block of the next epoch after expiration occurs,
stakeholders of MC that supported SC post
the transac-
tion sidechain failure(idSC) to MC. We assume that both
predicates ActivationSuccess and ActivationFailure can be
evaluated based on the state of MC only, and hence spurious
success/failure transactions will be considered invalid.
4) Maintenance: Once the sidechain is created, both the
mainchain and the sidechain need to be maintained by their
respective set of stakeholders (detailed below) running their
respective instance of the Ouroboros protocol.
In the case of the mainchain, the maintenance procedure
is given below, with its exact code shown in Appendix B
5This can be interpreted as using MC to implement the setup functionality
needed to bootstrap SC.
148
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:41 UTC from IEEE Xplore.  Restrictions apply. 
as Algorithm 3. This algorithm is run by all stakeholders
controlling stake that
is recorded on the mainchain. Each
stakeholder, on every new slot, collects all the candidate MC-
chains from the network (modelled via the Diﬀuse function-
ality) and ﬁlters them for both consensus-level validity (using
MC.ValidateConsensusLevel) and transaction validity (using
the VERIFIERMC predicate given in Algorithm 8). Out of the
remaining valid chains, he chooses his new state CMC via
PickWinningChain. Then the stakeholder evaluates whether
he is an eligible leader for this slot, basing its selection on
the stake distribution SDj and randomness ηj, which are
determined once per epoch in accordance with the Ouroboros
protocol. If the stakeholder ﬁnds out he is a slot leader, he
creates a new block B by including all transactions currently
valid with respect to CMC (as per the predicate VERIFYTXMC
given also in Algorithm 8), appends it to the chain CMC and
diffuses the result6 for other parties to adopt.
The maintenance procedure for SC is similar, hence we
only describe here how it differs from Algorithm 3. Most
importantly,
is executed by all stakeholders who have
adopted SC, irrespectively of whether they own any stake on
SC. Recall that the slots and epochs of the SC-instance of
Ouroboros are aligned with the slots and epochs of MC.
it
The ﬁrst difference is that all ocurrences of MC and CMC
are naturally replaced by SC and CSC, respectively. This also
means that the validity of received chains (resp. transactions),
determined on line 13 (resp. 21), is decided based on predicate
VERIFIERSC(·, CMC) (resp. VERIFYTXSC(·)) instead of the
predicate VERIFIERMC(·) (resp. VERIFYTXMC(·)). Addition-
ally, note that VERIFYTXSC must be called with a sequence
of transactions containing both the transactions in SC as
well as the transactions in MC interspersed and timestamped,
similarly to the way done in Line 2 of Algorithm 10. This is
straightforward to implement, as the sidechain maintainers also
directly observe the mainchain. The predicates VERIFYTXSC
and VERIFIERSC are given in Algorithm 10 in Appendix B.
Second, instead of the stake distribution SDj determined on
∗
line 6, a different distribution SD
j is determined to be used
for slot leader selection in the j-th epoch of the sidechain. The
contains all stake belonging to stakeholders
distribution SD
that have adopted SC, irrespectively of whether this stake is
located on MC or SC (we call such stake SC-aware). It can
be obtained by combining the distribution SD as recorded in
SC with the distribution of SC-aware stake on MC (which
is known to SC-maintainers via direct observation of MC).
Note that the distribution used for epoch j reﬂects the stake
distribution of SC-aware stake in the past, namely by slot 4k
of epoch j−1, just as in MC. Naturally, this also implies that
the fourth parameter for the SlotLeader predicate on line 17
is SD
∗
j instead of SDj.
∗
Finally,
the block construction procedure on line 23 is
adjusted so that
the
created blocks on the sidechain also contain an additional
in the last 2k slots of each epoch,
6 As in [11], [18], we simplify our presentation by diffusing the complete
chains, although a practical implementation would only diffuse the block B.
ATMS signature of a so-called sidechain certiﬁcate (how this
certiﬁcate is constructed and used will be described below).
Hence, whenever sl mod R > 10k,
line 23 is replaced
by B ← (prev, (cid:9)txvalid, σ, σsc certj+1 ) where σsc certj+1 =
Sigsk(sc certj+1) and j is the current epoch index.
5) Depositing to SC: Once SC is initialized, cross-chain
transfers to it can be made from MC. A cross-chain transfer
operation in this case consists of two transactions txsend and
txrec that both have send = MC, rec = SC, and all other
ﬁelds are also identical, except that each txi for i ∈ {send, rec}
contains lid = i. The sending transaction txsend is meant to
be included in MC, while the receiving transaction txrec is
meant to be included in SC.
Whenever a stakeholder on MC that has adopted SC wants
to transfer funds to SC, she diffuses txsend with the correct
receiving account on SC and the desired amount. Honest slot
leaders in MC include these transactions into their blocks
just like any intra-chain transfer transactions. Maintainers of
MC keep account of a variable poolSC, initially set to zero.
Whenever a txsend is included into MC, they increase poolSC
by the amount of this transaction.
When txsend becomes stable in MC (i.e., appears in MC,
this happens at most 2k slots after its inclusion), the stake-
holder creates and diffuses the corresponding txrec which
credits the respective amount of coins to rAcc in SC, to
be included into SC. In practice, this is akin to a coinbase
transaction, as the money was not transferred from an existing
SC account.
Note that depositing from MC to SC is relatively fast;
it merely requires a reliable inclusion of txsend into MC and
consequently of txrec into SC, as guaranteed by the liveness of
the underlying Ouroboros instances. The depositing algorithm
code is shown in Algorithm 4 in Appendix B.
6) Withdrawing to MC: The withdrawal operation is more
cumbersome than the depositing operation since not all nodes
of MC have adopted (i.e., are aware of and follow) the
sidechain SC. As transactions, the withdrawals have the same
structure as deposits, consisting of txsend and txrec, with the
only difference that now they both have send = SC and
rec = MC. The sending transaction will be handled in
the same way as in the case of deposits, but the receiving
transaction requires a different certiﬁcate-based treatment, as
detailed below.
Whenever a stakeholder in SC wishes to withdraw coins
from SC to MC, she creates and diffuses the respective
transaction txsend with the correct transfer details as before.
If txsend is included in a block that belongs in one of the
ﬁrst R − 4k slots of some epoch then let jsend denote the
index of this epoch, otherwise let jsend denote the index of the
following epoch. The stakeholder then waits for the end of the
epoch ejsend to pass and ejsend+1 to begin.
At the beginning of ejsend+1, a special transaction called
sidechain certiﬁcate sc certjsend+1 is generated by the main-
tainers of SC. It contains: (i) a Merkle-tree commitment to
all withdrawal transactions txsend that were included into SC
during last 4k slots of epoch jsend − 1 and the ﬁrst R − 4k
149
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:41 UTC from IEEE Xplore.  Restrictions apply. 
slots of epoch jsend (as these all are already stable by slot
R − 2k of epoch jsend); (ii) other information allowing the
maintainers of MC to inductively validate the certiﬁcate in
every epoch. The construction of sc cert is detailed below,
for now assume that the transaction provides a proof that the
included information about withdrawal transactions is correct.
The transaction sc cert is broadcast into the MC network to
be included into MC at the beginning of ejsend+1 by the ﬁrst
honest slot leader.
The stakeholder who wishes to withdraw their money into
MC now creates and diffuses the transaction txrec to be
included in MC. This transaction is only included into MC if
it is considered valid, which means: (1) it is properly signed;
(2) it contains a Merkle inclusion proof conﬁrming its presence
in some already included sidechain certiﬁcate; (3) its amount
is less or equal to the current value of poolSC. If included,
MC-maintainers decrease the value of poolSC by the amount
of this transaction. The code of the withdrawal algorithm is
illustrated in Algorithm 5 in Appendix B.
7) The certiﬁcate transaction: We now describe the con-
struction of the sc cert transaction, also called the sidechain
certiﬁcate, formally described in Algorithm 6 in Appendix B.
The role of the certiﬁcate produced by the end of epoch
j − 1 to be included in MC at the beginning of epoch j
(denoted sc certj) is to attest all the withdrawals that had
their sending transactions included into SC in either the last
4k slots of ej−2 or the ﬁrst R− 4k slots of ej−1. To maintain
a chain of trust for the MC maintainers that cannot verify
these transactions by observing SC, we make use of ad-hoc
threshold multisignatures introduced in Section IV-A. Namely,
the sc certj transaction also contains an aggregate key avkj
of an ATMS, and is signed by the previous aggregate key
avkj−1 included in sc certj−1.
(cid:4)
sc certj is generated by SC-maintainers and contains:
• The epoch index j.
• The pending transactions from SC to MC. Let (cid:9)tx be
the sequence of all transactions which are included in
SC during either the last 4k slots of ej−2 or the ﬁrst
R− 4k slots of ej. All transactions in (cid:9)tx that have SC =
(cid:3)
send (cid:9)= rec = MC are picked up and combined into
a list pendingj (sorted in the same order as in SC). Let
denote a Merkle-tree commitment to this list.
pendingj
• The new ATMS key avkj. The key is created from the
public keys of the slot leaders of the last 2k slots of the
epoch j, using threshold k + 1. Hence, it allows to verify
whether a particular signature comes from k + 1 out of
these 2k keys.
• Signature valid with respect to avkj−1.
(cid:6)
(cid:5)
j,(cid:16)pendingj(cid:17), avkj, σj
,
The full sc certj is therefore a tuple
where σj is an ATMS signature on the preceding elements that
veriﬁes using avkj−1.
The certiﬁcate sc certj+1 is constructed as follows: Both
∗
j+1 and the SC-randomness ¯ηj+1
the stake distribution SD
(and hence also the slot leader schedule for SC in epoch j +1)
are determined by the states of the blockchains MC and SC
by the end of slot 10k of epoch j. Therefore, during the last
2k slots of epoch j, the 2k elected slot leaders for these slots
can already include a (local) signature on (their proposal of)
sc certj+1 into the blocks they create. Given the deterministic
construction of sc certj+1, all valid blocks ending up in the
part of SC-chain belonging to the last 2k slots of epoch j will
contain a local signature on the same sc certj+1, and by the
chain growth property of the underlying blockchain, there will
be at least k + 1 of them. Therefore, any party observing SC
can now combine these signatures into an ATMS that can be
later veriﬁed using the ATMS key avkj, it can hence create the
complete certiﬁcate sc certj+1 and serve it to the maintainers
of MC for inclusion.
Initially, during the setup of
8) Transitioning trust: As already outlined above, our
construction uses ATMS to maintain the authenticity of the
sidechain certiﬁcates from epoch to epoch. We now describe
this inductive process in greater detail.
the sidechain, P ←
PGen(1κ) is ran. Stakeholders generate their keys by invoking
(ski, vki) ← Gen(P). In case Gen(·) is a probabilistic algo-
rithm, it is run in a derandomized fashion with its coins ﬁxed
to the output of a PRNG that is seeded by H(ats init, ηjstart )
where “ats init” is a ﬁxed label and H is a hash function.
This ensures that P will be uniquely determined and will still