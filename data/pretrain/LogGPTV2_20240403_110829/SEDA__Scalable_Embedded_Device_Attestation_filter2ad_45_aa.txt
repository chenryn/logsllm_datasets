title:SEDA: Scalable Embedded Device Attestation
author:N. Asokan and
Ferdinand Brasser and
Ahmad Ibrahim and
Ahmad-Reza Sadeghi and
Matthias Schunter and
Gene Tsudik and
Christian Wachsmann
SEDA: Scalable Embedded Device Attestation
N. Asokan1, Ferdinand Brasser2, Ahmad Ibrahim2, Ahmad-Reza Sadeghi2,
Matthias Schunter3, Gene Tsudik4, and Christian Wachsmann2
1Aalto University and University of Helsinki, Espoo and Helsinki, Finland
2Technische Universität Darmstadt, Germany
3Intel Labs, Portland, OR, U.S.A.
4University of California, Irvine, CA, U.S.A.
{ferdinand.brasser, ahmad.ibrahim, ahmad.sadeghi,
christian.wachsmann}@trust.cased.de,
PI:EMAIL, PI:EMAIL, PI:EMAIL
Abstract
large numbers of smart interconnected devices provide
Today,
safety and security critical services for energy grids, industrial con-
trol systems, gas and oil search robots, home/ofﬁce automation,
transportation, and critical infrastructure. These devices often oper-
ate in swarms – large, dynamic, and self-organizing networks. Soft-
ware integrity veriﬁcation of device swarms is necessary to ensure
their correct and safe operation as well as to protect them against at-
tacks. However, current device attestation schemes assume a single
prover device and do not scale to swarms.
We present SEDA, the ﬁrst attestation scheme for device swarms.
We introduce a formal security model for swarm attestation and
show security of our approach in this model. We demonstrate two
proof-of-concept implementations based on two recent (remote) at-
testation architectures for embedded systems, including an Intel re-
search platform. We assess performance of SEDA based on these
implementations and simulations of large swarms. SEDA can efﬁ-
ciently attest swarms with dynamic and static topologies common
in automotive, avionic, industrial control and critical infrastructures
settings.
Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection
Keywords
remote attestation; device swarms; security
1.
INTRODUCTION
Current and emerging industrial trends envision systems consist-
ing of large numbers of heterogeneous embedded and mobile de-
vices, forming so-called Internet of Things (IoT). Analysts predict
billions of connected devices that will enable many new services
and experiences. Examples include: (1) industrial control systems,
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
c(cid:13) 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813670.
where large numbers of connected autonomously operating devices
collaborate to monitor and control safety-critical processes (e.g.,
smart factories), (2) connected IoT devices in smart environments
(e.g., smart homes and smart buildings) and (3) self-organizing
dynamic networks where a multitude of devices form collectively
intelligent systems (e.g., robots used for oil and gas search). In-
spired by nature, such systems are often referred to as device
swarms [13, 19, 45]. To ensure their correct operation, it is crucial
to maintain their software integrity and protect them against attacks.
For instance, large-scale industrial control systems or robot swarms
are vulnerable to a wide range of attacks [6, 12, 19, 21, 23, 36, 43].
Verifying correct and safe operation of these systems requires an
efﬁcient mechanism to collectively verify software integrity of all
devices in order to detect software modiﬁcations. However, naïve
applications of remote attestation do not scale to these systems. In
particular, device swarms with dynamic topologies, such as vehic-
ular ad-hoc networks, robot swarms, and sensors in ﬂuid environ-
ments, require novel and ﬂexible solutions.
Many approaches to remote attestation have been proposed to-
date. Common to all of them is that the entity (device) to be at-
tested, called prover, sends a status report of its current software
conﬁguration to another party, called veriﬁer, to demonstrate that it
is in a known and, thus trustworthy, state. All existing attestation
techniques consider only a single prover and veriﬁer. Since mali-
cious software on the prover could forge this report, its authenticity
is typically assured by secure hardware [16, 26, 27, 42, 46, 51]
and/or trusted software [2, 24, 27, 29, 47, 48, 52]. Attestation
based on secure hardware is most suitable for advanced comput-
ing platforms, such as smartphones, tablets, laptops, personal com-
puters, and servers. However, underlying security hardware is of-
ten too complex and/or expensive for low-end embedded systems.
In contrast, software-based attestation [24, 29, 47, 48] require nei-
ther secure hardware nor cryptographic secrets. However, security
guarantees of software-based attestation methods rely on strong as-
sumptions, such as the adversary being passive while the attestation
protocol is executed and optimality of the attestation algorithm and
its implementation. They also rely on tight time constraints, on
strict estimation of round-trip time and on the existence of an out-
of-band authentication channel as no secrets are shared between
the prover and the veriﬁer. Such assumptions are hard to achieve in
practice [3] and restrict applicability of software-based attestation
to the one-hop setting. Hence, a secure and practical remote attes-
tation scheme requires minimal security features in hardware such
as read-only memory (ROM) and memory isolation (e.g., memory
protection unit) [16, 17].
Consequently, designing efﬁcient and secure attestation of de-
vice swarms poses several challenges. In particular, in swarms with
dynamic topology, attestation needs to be combined with key man-
agement, network discovery, and routing in a secure and efﬁcient
way. Clearly, it is important to ensure that compromised devices
cannot evade detection during attestation and honest devices must
not be double-counted. Furthermore, computation and communi-
cation costs for the veriﬁer and (possibly many) provers should
be minimized. This requires a cumulative and efﬁcient attestation
scheme that cannot be instantiated by trivial combinations of exist-
ing attestation protocols. Moreover, a swarm attestation protocol
should ideally distribute its burden – including computation, com-
munication, and energy costs – over all devices in the swarm.
Contributions:
First Swarm Attestation Scheme: We design SEDA, Scalable Em-
bedded Device Attestation, which is, to the best of our knowledge,
the ﬁrst attestation scheme for large-scale swarms. SEDA repre-
sents the ﬁrst step in a new line of research on multi-device attesta-
tion. Although SEDA adheres to the common assumption – made
in most (single-prover) attestation techniques – of ruling out phys-
ical attacks on devices, we discuss mitigation techniques for such
attacks in Section 9.
Security Model & Analysis: We present the ﬁrst security model for
swarm attestation and demonstrate security of SEDA in this model.
Two Working Prototypes: We describe two concrete instantiations
of SEDA based on state-of-the-art security architectures for low-
end embedded systems: SMART [16] and TrustLite [25], the latter
based on an Intel research platform [44]. They demonstrate fea-
sibility of SEDA on swarms of low-end embedded devices with
minimal hardware security features.
Performance Analysis: We assess performance of two SEDA in-
stantiations and present simulation results for swarms with up to
1, 000, 000 devices, thus demonstrating SEDA’s scalability. Our re-
sults clearly indicate that SEDA performs signiﬁcantly better than
individually attesting each device separately.
Outline: We begin with an overview of swarm attestation (Sec-
tion 2) and our notation (Section 3). We then describe SEDA proto-
col in detail (Section 4), two implementations of it (Section 5) and
performance results (Section 6). We examine security of SEDA
(Section 7), discuss several extensions (Section 8) and revisit the
question of physical attacks (Section 9). Finally we summarize re-
lated work (Section 10).
2. SWARM ATTESTATION
2.1 Problem Description and System Model
A swarm S is a set of s devices with possibly different hardware
and software conﬁgurations, as shown in Figure 1. Devices are ini-
tialized and deployed by swarm operator OP in a trusted manner.
Table 1 summarizes our notation.
The goal of swarm attestation is to assure a veriﬁer VRF, which
may be different from OP, of S’s overall software integrity or lack
thereof. VRF may be a remote entity. An important property of
swarms is that each device can communicate only with its direct
neighbors [13, 19, 45]. S might be dynamic in terms of both topol-
ogy and membership. Device mobility might be voluntary (i.e.,
self-locomotion) or involuntary (i.e., guided by ambient factors).
Hence, S’s current topology may be unknown to OP and VRF.
The main idea is that S is trustworthy if all of its devices have been
deployed by OP, and are running a software conﬁguration certi-
ﬁed by OP, i.e., S is trustworthy if all its devices are successfully
attested by VRF. SEDA focuses on swarm attestation and leaves
policies to VRF. It guarantees that VRF reliably learns the total
number of participating and correctly operating devices.1 Note that
devices not responding to protocol messages2 cannot be attested
successfully and are considered compromised. When determining
the swarm’s current state, the distinction between compromised and
unreachable devices can be ignored, since, in each case, the device
is not functioning correctly.
2.2 Requirements Analysis
Objectives. A secure swarm attestation scheme must have the fol-
lowing properties:
• Property (1): Support the ability to remotely verify integrity
of S as a whole.
• Property (2): Be more efﬁcient than individually attesting
each device Di in S.
• Property (3): Not require VRF to know the detailed conﬁg-
uration of S (e.g., the type and software version of devices
and network topology).
• Property (4): Support multiple parallel or overlapping attes-
• Property (5): Be independent of the underlying integrity mea-
tation protocol instances.
surement mechanism used by devices in S.
Property (1) is the core objective of swarm attestation. Property (2)
is essential for scalability in large swarms. Property (3) simpliﬁes
attestation and is needed if system conﬁguration must not be dis-
closed to VRF. For example, in smart factories, the maintenance
may be outsourced, and maintenance staff may need to check over-
all trustworthiness of the production system while the exact setup
remains secret [30, 35, 56]. Property (4) is relevant to applica-
tions where multiple veriﬁers need to independently verify system
integrity without coordination. Property (5) is needed for extensibil-
ity, to support a wide range of single-device attestation mechanisms
and to be able to adapt to future attestation schemes, e.g., those that
allow detection of code-reuse attacks.
Adversary model. As common in the attestation literature [16,
24, 47, 48] we consider software-only attacks. This means that,
although the adversary, denoted as ADV, can manipulate the soft-
ware of (i.e., compromise) any device D in S, it cannot physically
tamper with any device. However, ADV can eavesdrop on, and ma-
nipulate, all messages between devices, as well as between devices
and VRF. Furthermore, we rule out denial-of-service (DoS) at-
tacks since ADV typically aims to remain stealthy and undetected
while falsifying the attestation result for VRF. This is also in line
with our primary goal of detecting device compromise that occurs
via remote malware infestations.
Nevertheless, we sketch out several approaches for mitigating phys-
ical attacks in Section 9 and address DoS attack mitigation tech-
niques in Section 7.
Device requirements.
In order to satisfy properties (1), (2) and
(3), a secure swarm attestation scheme should be able to remotely
verify integrity of each D and aggregate the results.These impose
the following requirements on each device D [16, 17]:
• Integrity measurement: It must be infeasible for ADV to tam-
per with the mechanism that attests integrity of D’s software.
• Integrity reporting: It must be infeasible for ADV to forge
the integrity measurement report sent from D to VRF.
1Section 8 describes a more efﬁcient variant of SEDA that uses
sampling.
2These devices are detected via a time-out mechanism at a lower
network layer.
• Secure storage: It must be infeasible for ADV to access any
cryptographic secret(s) used by D as part of attestation.
In Section 5, we demonstrate viability of SEDA implemented on
top of two recent attestation architectures which satisfy the above
requirements with minimal hardware support: SMART [16] and
TrustLite [25].
Assumptions. Following recent literature on attestation of low-
end embedded systems [16, 17, 25], we assume that each D in
S satisﬁes minimal requirements for secure remote attestation, as
discussed above. Furthermore, following swarm robotics litera-
ture [13, 19, 45], we assume that D can communicate with all its
neighboring devices in S, and that the network is connected, i.e.,
each D is reachable, at least while the attestation protocol executes.
We consider all underlying cryptographic primitives and their im-
plementations to be secure. We also assume that OP is trusted.
Finally, we assume that swarm topology remains static for the du-
ration of a given attestation protocol instance. This does not pre-
clude so-called “herd mobility” (entire swarm moving as a whole)
or micro-mobility (devices move while retaining overall topology).
Topology can change between attestation protocol instances.
In
Section 8 we discuss how SEDA can be modiﬁed to allow mobility
of devices even during attestation.
3. PRELIMINARIES AND NOTATION
Let |M| denote the number of elements in a ﬁnite set M. If n
is an integer (or a bit-string) |n| means the bit-length of n. Let
m $← M denote the assignment of a uniformly sampled element
of M to variable m. Furthermore, let {0, 1}(cid:96) be the set of all
bit-strings of length (cid:96).
If E is some event (e.g., the result of a
security experiment), then Pr[E] denotes the probability that E oc-
curs. Probability ((cid:96)) is called negligible if, for all polynomials f,