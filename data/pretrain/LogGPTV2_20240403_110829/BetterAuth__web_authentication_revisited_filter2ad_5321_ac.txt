going HTTP requests. Whenever an authentication with a
BetterAuth-enabled site is initiated or a request is sent to a
domain for which an established BetterAuth authentication
context exist, the extension becomes active.
Initial Authentication
4.1.1
If an HTML form is processed during rendering, which is
marked with the custom attribute data-purpose= "better-
auth" the extension becomes active and the submission pro-
cess of this form is intercepted: Before submitting the form,
the username and password data is retrieved from the re-
quest data and used to initiate the BetterAuth-authentication
handshake. After receiving the 401 response, the extension
removes the password value from the request’s data and sub-
mits the form.
4.1.2 Authentication Tracking
As discussed in Sec. 3.4, the authentication tracking mech-
anism mimics the behavior of Web browsers in respect to
automatically adding cookie headers to requests that are
targeted to the cookie’s domain. The extension keeps track
of currently active authentication contexts. Whenever a re-
quest is targeted towards a domain, for which such an au-
thentication context exists, the extension veriﬁes that the
request originated from within this authenticated context
or whether the target URL is listed in the application’s set
of public interfaces (see Sec. 3.5). If one of these conditions
is satisﬁed, the extension transparently signs the outgoing
request.
4.2 JavaScript Implementation
Our solution is designed in a fashion that allows to create
a pure JavaScript fallback for browsers which do not support
our authentication scheme natively. This way, a transitional
phase can be supported, which allows developers to already
use the mechanism without requiring to provide a separate
authentication scheme for legacy browsers. In this section,
we document the design of the JavaScript implementation
of BetterAuth.
4.2.1 General Approach
The core of the transitional implementation is the replace-
ment of native navigation operations, such as form submis-
sions and page transitions, with a JavaScript initiated load-
ing mechanism. This way, the initial authentication hand-
shake can be executed and all further outgoing requests can
be signed by JavaScript before they are sent to the server.
This approach is realized using four distinct elements: A
dedicated form handling for the initial authentication (see
Sec. 4.2.2), a request signing component (see Sec. 4.2.4),
and a dedicated page loader object for pure page transitions
(see Sec. 4.2.5). Furthermore, we utilize domain isolation to
keep the key material out of reach of potentially untrusted
JavaScript code (see Sec. 4.2.3).
Initial Authentication
4.2.2
Implementing the actual initial authentication handshake
is straightforward: The BetterAuth-enabled HTML form
executes a JavaScript function on form submission which
conducts the key exchange handshake. For this purpose,
the username and password values are read from the DOM
elements. Using the XMLHttpRequest object, the script
creates the OPTIONS request to the server’s authentica-
tion interface. After receiving the server’s encrypted Diﬃe-
Hellman key and the optional password salt in the 401 re-
sponse, JavaScript calculates the browser’s Diﬃe-Hellman
key and encrypts it with the password. In addition, after
sending the key to the server, the script calculates the ses-
sion signing key using the two key fragments.
Isolating the Secure Key Storage
4.2.3
As in Sec. 3.1 stated: It is unacceptable for any aspect
of our technique to introduce security ﬂaws which are not
present in the current state. For this reason, we have to
take measures to separate the key material from potentially
untrusted JavaScript code.
An implementation of the authentication tracking process
requires that the session signing key is handled by standard
JavaScript functions. In consequence, a careless implemen-
tation would lead to a situation in which an XSS-attack
could be used to steal this key and leak it to the adver-
sary. Such an attack would be comparable to XSS-based
cookie stealing, which can eﬀectively be mitigated using the
HTTPonly cookie ﬂag. Hence, to avoid the introduction of
security regression, we have to ensure that the key material
is kept out of reach of untrusted parties.
To achieve this, we leverage the guarantees provided by
the same-origin policy [34] and the postMessage API [38]:
First, we introduce a separate subdomain, which is respon-
sible to handle and store the signing key. This domain only
contains static JavaScript dedicated to this task and noth-
ing else. Based on this, we consider it to be feasible that the
code running in this origin is well audited and XSS-free. An
HTML document hosted on this subdomain which contains
all necessary scripts, is included in the main application’s
pages using an invisible iframe.
The main application communicates with the key han-
dling scripts on the secure subdomain using the postMessage
API
[38]: The postMessage API is a mechanism by which
two browser documents are able to communicate across do-
main boundaries in a secure manner. A postMessage can be
sent by calling the method postMessage(message, targe-
tOrigin). While the message attribute takes a string mes-
sage, the targetOrigin represents the origin of the receiving
page. In order to receive such a message the receiving page
hast to register an event handler function for the message
event. When receiving a message via the event handler func-
tion, the browser passes additional metadata to the receiving
page. This data includes the origin of the sender. Hence,
the postMessage API can be used to verify the authenticity
of the sending page.
After a successful key exchange, the component responsi-
ble for the initial handshake passes the session signing key
via postMessage to the secure subdomain. The receiving
script stores the key, depending on its conﬁgured lifespan,
either via the subdomain’s sessionStorage or localStorage
mechanism [11].
JavaScript-Based Request Signing
4.2.4
Following the initial authentication, all further requests
have to carry a correct HMAC signature to be recognized as
authenticated. In consequence, all outgoing requests have to
be initiated via JavaScript. This is done by replacing hyper-
link targets and form actions with JavaScript event handlers,
which pass the target URL to the signing component of our
implementation. This component normalizes the request’s
data and then passes it, using the browser’s post-message
API, to the secure iframe (see Lst. 1).
As mentioned above, a central feature of the post-message
API is, that the origin domain of the incoming requests is
communicated in an unspoofable fashion. Hence, the request
signing script can verify that the call to the signing function
was created within an authenticated context (see Sec. 3.5),
174
Code Listing 2 Request signing code on the secure subdo-
main (simpliﬁed sketch)
(cid:29)(cid:9)(cid:6)(cid:18)(cid:2)(cid:13)(cid:5)(cid:1)(cid:19)(cid:18)(cid:3)(cid:28)(cid:27)(cid:19)(cid:5)(cid:3)(cid:23)(cid:18)(cid:5)(cid:26)(cid:2)(cid:16)(cid:16)(cid:26)(cid:3)(cid:15)(cid:13)(cid:27)(cid:30)(cid:1)
window . a d d E v e n t L i s t e n e r
(cid:29)(cid:2)(cid:23)(cid:20)(cid:8)(cid:5)(cid:14)(cid:21)(cid:3)(cid:2)(cid:20)(cid:15)(cid:18)(cid:26)(cid:10)(cid:19)(cid:30)(cid:1)
(cid:19)(cid:5)(cid:20)(cid:1)(cid:19)(cid:5)(cid:19)(cid:19)(cid:9)(cid:15)(cid:14)(cid:1)(cid:19)(cid:9)(cid:7)(cid:14)(cid:9)(cid:14)(cid:7)(cid:1)(cid:11)(cid:5)(cid:24)(cid:1)
(cid:29)(cid:16)(cid:2)(cid:7)(cid:5)(cid:12)(cid:15)(cid:2)(cid:4)(cid:5)(cid:18)(cid:26)(cid:10)(cid:19)(cid:30)(cid:1)
(cid:7)(cid:5)(cid:20)(cid:1)(cid:18)(cid:5)(cid:17)(cid:23)(cid:5)(cid:19)(cid:20)(cid:1)(cid:19)(cid:9)(cid:7)(cid:14)(cid:2)(cid:20)(cid:23)(cid:18)(cid:5)(cid:1)
(cid:19)(cid:9)(cid:7)(cid:14)(cid:5)(cid:4)(cid:1)(cid:18)(cid:5)(cid:17)(cid:23)(cid:5)(cid:19)(cid:20)(cid:1)
(cid:1)(cid:1)(cid:11)(cid:5)(cid:24)(cid:1)(cid:19)(cid:20)(cid:15)(cid:18)(cid:2)(cid:7)(cid:5)(cid:1)
( " me s sa ge " , h a n d l e S i g n O r d e r );
// C r e a t e s i g n e d r e q u e s t
f u n c t i o n h a n d l e S i g n O r d e r ( event ){
if ( a u t h C o n t e x t ( event . origin )){
var key = getSSK ( event . origin )
var sig = signReq ( event . data , key )
event . source . p o s t M e s s a g e ( sig ,
event . origin )
}
}
Figure 3: Domain isolated key handling
Code Listing 1 Request initation (simpliﬁed sketch)
and not by an untrusted third party which tries to abuse
the functionality. Then, the signing component retrieves the
signing key from localStorage, conducts the signing process,
and passes the resulting values back to the main application,
again using the postMessage functionality (see Lst. 2).
For apparent reasons, all page transitions and related re-
quest initiating actions of the main application have to uti-
lize the request signing functionality. While for newly writ-
ten applications, this won’t cause a lot of eﬀort, legacy appli-
cations have to be adapted to support the novel functional-
ity. However, as discussed in [1], many applications can eas-
ily be adapted by traversing the application’s pages DOM
on load and patching the encountered links and forms to
use the request signing functions. Alternatively, server-side
rewriting of outgoing HTML could be utilized, modifying
hyperlinks and form-actions to utilize JavaScript page navi-
gation (see Lst. 1). Finally, for applications that mainly rely
on AJAX driven client/server interaction, the request sign-
ing functionality can be introduced transparently replacing
the XMLHttpRequest object with an object wrapper which
implements the necessary actions.
4.2.5 Accessing Public Interfaces
The ﬁnal puzzle piece in the transitional implementation
is a facility that enables external sites to navigate to the
application’s public interfaces (see Sec. 3.5). To recall, a
public interface is a URL to which external sites are allowed
to navigate in an authenticated state (e.g., for posting to
social sharing sites).
For this purpose, we utilize a pageloader object: The page
loader is a small JavaScript that is delivered by the appli-
cation in case an unauthenticated request has been received
for a URL which requires authentication and is contained
in the application’s set of public interfaces. The script is
carried in the body of the initial 401 response during the
key exchange handshake. In consequence, if such a response
is received during a standard Web navigation process (op-
posed to the explicit authentication handshake executed by
the native or transitional implementation), the page loader
is executed in an otherwise blank HTML document.
The pageloader’s source code is created dynamically by
the server to contain the request’s data which needs to be
signed, in most cases mainly consisting of the original re-
quest’s URL. The page loader dynamically includes the iframe
to the secure subdomain and utilizes the standard request
signing functionality of the implementation (see Lst. 1) to
create a second, now authenticated request. The strict ori-
gin checking mechanism of the subdomain’s signing interface
robustly prevents potential abuse.
5. EVALUATION
5.1 Security Evaluation
In this section, we examine how capable BetterAuth is in
mitigating the security threats (see Sec. 2).
Network-based attacks: At no point, passwords nor
authentication tokens are transmitted over the network.
Therefore, sniﬃng attacks are powerless. Also, due to the
mutual authentication properties of the initial authentica-
tion, man-in-the-middle attacks are mitigated. However,
please note, that BetterAuth only proves that the server
indeed possesses the password. Furthermore, the security
properties of BetterAuthdo not rely on the security of an
underlying SSL/TSL connection. In consequence, SSL strip-
ping attacks or CA breaches have no eﬀect.
Issues related to cookie-based authentication track-
ing: There is no authentication cookie anymore, which could
be stolen or manipulated. Hence, session hijacking and ﬁx-
ation attacks do not apply. Furthermore, CSRF attacks are
175
mitigated, as only in-application requests receive a signa-
ture, leading to a situation in which crossdomain requests
are treated as unauthenticated by default. Only, if URLs are
explicitly added to the list of public interfaces, the developer
has to ensure, that crossdomain request to these URLs do
not cause unwanted side eﬀects. Finally, as we will dis-
cuss further in Sec. 5.3, Clickjacking attacks are partially
addressed but still might occur.
Phishing: The password never leaves the browser. Hence,
phishing attacks are bound to fail. However, this property
only holds, if the password is entered only in BetterAuth-
enabled input ﬁelds (see Sec. 5.3 for a further discussion of
this limitation).
Limitations of the JavaScript implementation: Un-
like a native implementation, the transitional implementa-
tion is susceptible to active man-in-the-middle attackers.
The reason for this is, that the cryptographic components,
which are executed in the secure subdomain’s iframe are
transported over the compromised network connection. Hence,
the adversary could alter the transmitted source code in a
fashion that leaks the session signing key or the user’s pass-
word to the outside. Hence, at least the secure subdomain’s
content should be communicated via HTTPS.
5.2 Performance Evaluation
We don’t expect a native implementation to cause consid-
erable overhead. The utilized algorithms are in similar form
already highly eﬃciently implemented both in browsers and
servers as part of the SSL/TLS suite. Hence, the intro-
duced overhead will be at most in the same range as over-
head introduced by HTTPS communication. However, for
the transitional implementation, the client-side component
is implemented in pure JavaScript. Thus, a potential for
noticeable overhead is given. Fortunately, in the last couple
of years the browser vendors were inclined in an arms race
on rapidly improving the performance of their JavaScript in-
terpreters. To evaluate, how a JavaScript realization of the
initial authentication would perform under realistic circum-
stances, we implemented the protocol as outlined in Sec. 4.2.
For the cryptographic operations, we utilized the “Big Inte-
ger Library”2 and the “Stanford Javascript Crypto Library
(SJCL)”3. We benchmarked our implementation on three
diﬀerent machines running diﬀerent operating systems each
(Linux, Mac Os X, and Windows 7) and in total six browsers
(see Tab. 2 for further details). The results of our bench-
marking eﬀorts can be obtained in Tab. 2. Among all con-
ﬁgurations, the best performance could be observed with
the Chrome browser, which reliably stayed below 300 ms,
using a reasonable key length of 1024 Bit. The worst perfor-
mance was exposed by Internet Explorer 9, which consumed
in average 1314 ms for the same operations. Please keep in
mind, that this overhead occurs only once during the whole
process. The HMAC based authentication tracking can be
implemented highly eﬃcient and, thus, causes negligible per-
formance eﬀects.
5.3 Open Issues
The password entry ﬁeld: BetterAuth provides strong
protection against phishing attacks on the protocol level.
However, this protection can be circumvented by the at-
tacker on the GUI-level: As duly observed in [36, 12], if
2
http://leemon.com/crypto/BigInt.html
http://crypto.stanford.edu/sjcl/
3
D-H key length
1536 Bit
Browser
Chromium/Linux1
876.6
Firefox/Linux1
1476.6
Chrome/Mac2
862.6
Safari/Mac2
3069.7