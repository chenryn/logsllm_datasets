In the case of a conﬁdential client, the client authentication
at the token endpoint is done in the same way as for the
Read-Only ﬂow, i.e., by using either JWS Client Assertions
(cf. Section II-C) or Mutual TLS (cf. Section II-D).
C. Overview of Assumptions and Mitigations
In the following, we explain the conditions under which
the FAPI proﬁles and the OAuth extensions aim to be secure
according to their speciﬁcations.
1) Leak of Authorization Response: As described in Sec-
tion II-B in the context of PKCE, there are several scenarios
in which the authorization response (Step 6 of Figure 1), and
hence, the authorization code, can leak to the attacker (in clear),
in particular in the case of app clients. In our model of the
FAPI, we therefore assume that the authorization response is
given to the attacker if the client is an app. At ﬁrst glance,
leakage of the authorization code is indeed mitigated by the
use of PKCE since an attacker does not know the code veriﬁer,
and hence, cannot redeem the code at the AS. However, our
attack described in Section IV-C shows that the protection
provided by PKCE can be circumvented.
2) Leak of Authorization Request: The Read-Only proﬁle
of the FAPI explicitly states that the PKCE challenge should
be created by hashing the veriﬁer. The use of hashing should
protect the PKCE challenge even if the authorization request
leaks (e.g., by leaking HTTP logs, cf. Section II-B), and
therefore, we assume in our model that the authorization
request (Step 2 of Figure 1) leaks to the attacker.
3) Leak of Access Token: In the Read-Write proﬁle, it is
assumed that the access token might leak due to phishing [43,
Section 8.3.5]. In our model, we therefore assume that the
access token might leak in Step 5 of Figure 1. This problem
is seemingly mitigated by using either mTLS or OAUTB,
which bind the access token to the legitimate client, and hence,
only the legitimate client should be able to redeem the access
token at the RS even if the access token leaked. The FAPI
speciﬁcation states: “When the FAPI client uses MTLS or
OAUTB, the access token is bound to the TLS channel, it is
access token phishing resistant as the phished access tokens
cannot be used.” [43, Section 8.3.5]. However, our attack
presented in Section IV-A shows that this is not the case.
4) Misconﬁgured Token Endpoint: An explicit design deci-
sion by the FAPI working group was to make the Read-Write
proﬁle secure even if the token request (Step 7 of Figure 1)
leaks. The FAPI speciﬁcation describes this attack as follows:
“In this attack, the client developer is social engineered into
believing that the token endpoint has changed to the URL that
is controlled by the attacker. As the result, the client sends
the code and the client secret to the attacker, which will be
replayed subsequently.” [43, Section 8.3.2].
Therefore, we make this assumption also in our FAPI
model. Seemingly, this problem is mitigated by code binding
through client authentication or OAUTB, which means that
the attacker cannot use the stolen code at the legitimate token
endpoint. “When the FAPI client uses MTLS or OAUTB, the
authorization code is bound to the TLS channel, any phished
client credentials and authorization codes submitted to the
token endpoint cannot be used since the authorization code is
bound to a particular TLS channel.” [43, Section 8.3.2]. Note
that in the FAPI the client does not authenticate by using the
client secret as a password, but by proving possession (either
using JWS Client Assertions or mTLS), which means that the
attacker cannot reuse credentials.
However, our attack presented in Section IV-B shows that
this intuition is misleading.
IV. ATTACKS
As already mentioned in the introduction, in Section V we
present our rigorous formal analysis of the FAPI based on
the Web Infrastructure Model. Through this formal analysis of
the FAPI with the various OAuth 2.0 extensions it uses, we
not only found attacks on the FAPI but also on some of the
OAuth 2.0 extensions, showing that (1) these extensions do
not achieve the security properties they have been designed
for and (2) that combining these extensions in a secure way is
far from trivial. Along with the attacks, we also propose ﬁxes
to the standards. Our formal analysis presented in Section V
considers the ﬁxed versions.
We start by describing two attacks on Token Binding,
followed by an attack on PKCE, and one vulnerability hidden
in the assumptions of PKCE.
We emphasize that our attacks work even if all communica-
tion uses TLS and even if the attacker is merely a web attacker,
i.e., does not control the network but only certain parties.
As already mentioned in the introduction, we notiﬁed the
OpenID FAPI Working Group of the attacks found by our
analysis and are working together with them to ﬁx the standard.
(cid:21)(cid:23)(cid:17)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:17 UTC from IEEE Xplore.  Restrictions apply. 
A. Cuckoo’s Token Attack
As explained in Section III-C3, the Read-Write proﬁle of the
FAPI aims at providing security even if the attacker obtains an
access token, e.g., due to phishing. Intuitively, this protection
seems to be achieved by binding the access token to the client
via mTLS (see Section II-D) or OAUTB (see Section II-E).
However, these mechanisms prevent the attacker only from
directly using the access token in the same ﬂow. As illustrated
next, in a second ﬂow, the attacker can inject the bound access
token and let the client (to which the token is bound) use this
token, which enables the attacker to access resources belonging
to an honest identity.
This attack affects all conﬁgurations of the Read-Write
proﬁle (see Figure 3). Also, the Read-Only proﬁle is vulnerable
to this attack; this proﬁle is, however, not meant to defend
against stolen access tokens.
We note that the underlying principle of the attack should
be relevant to other use-cases of token binding as well, i.e.,
whenever a token is bound to a participant, the involuntary
use of a leaked token (by the participant to which the token
is bound) should be prevented.
Attacker (User)
Client
Attacker (AS)
1 POST /start
POST /start
2 Response
Response
Redirect to AS (client_id, redirect_uri, state)
Redirect to AS (client_id, redirect_uri, state)
3 GET /redirect_uri
GET /redirect_uri
(code, state, id token1)
(code, state, id token1)
4 POST /token_endpoint
POST /token_endpoint
(code, client_id)
(code, client_id)
5 Response
Response
(access token, id token2)
(access token, id token2)
Attacker (AS)
Resource Server
6 GET /resource
GET /resource
(access token)
(access token)
7 Response
Response
resource
resource
Attacker (User)
Client
Resource Server
Figure 4. Cuckoo’s Token Attack
Figure 4 depicts the attack for the OIDC Hybrid Flow,
i.e., when both responses of the AS contain id tokens (see
Section III-B). The attack works analogously for the code ﬂow
in combination with JARM (see Section III-B).
As explained, we assume that the attacker already obtained
(phished) an access token issued by an honest AS to an honest
client for accessing resources of an honest user. We also
assume that the honest client supports the use of several ASs (a
common setting in practice, as already mentioned in Section II),
where in this case one of the ASs is dishonest.10
First, the attacker starts the ﬂow at the client and chooses his
own AS. Since he is redirected to his own AS in Step 2 , he can
skip the user authentication step and return an authorization
response immediately. Apart from that, the ﬂow continues
normally until Step 4 , where the client sends the code to the
attacker AS. In Step 5 , the attacker AS returns the previously
phished access token together with the second id token.
Until here, all checks done by the client pass successfully,
as the attacker AS adheres to the protocol. The only difference
to an honest authorization server is that the attacker AS returns
a phished access token. In Step 6 , the resource server receives
the (phished) access token and provides the client access to
the honest resource owner’s resources for the phished access
token,11 which implies that now the attacker has access to
these resources through the client.
To prevent the use of leaked access tokens, the client should
include, in the request to the RS, the identity of the AS the
client received the access token from. The client can take
this value from the second id token. Now, the RS would only
continue the ﬂow if its belief is consistent with the one of the
RS. We apply an analogous ﬁx for ﬂows with JARM. These
ﬁxes are included in our model and shown to work in Section V.
B. Access Token Injection with ID Token Replay
As described in Section III-C3, the Read-Write proﬁle aims
to be secure if an attacker acquires an access token for an
honest user. The proﬁle also aims to be secure even if the token
endpoint URI is changed to an attacker-controlled URI (see
Section III-C4). Now, interestingly, these two threat scenarios
combined in this order are the base for the attack described
in the following. In this attack, the attacker returns an access
token at the misconﬁgured token endpoint. While the attack
looks similar to the previous attack at ﬁrst glance, here the
attacker ﬁrst interacts with the honest AS and later replays
an id token at the token endpoint. Both attacks necessitate
different ﬁxes. The outcome, however, is the same, and, just
as the previous attack, this attack affects all conﬁgurations of
the Read-Write proﬁle, even if JARM is used. We explain the
attack using the Hybrid Flow.
Figure 5 shows how the attack proceeds. The attacker
initiates the Read-Write ﬂow at the client and follows the
regular ﬂow until Step 6 . As the authorization response was
10We highlight that we do not assume that the attacker controls the AS that
issued the access token (i.e., the AS at which the honest user is registered). This
means that the (honest) user uses an honest client and an honest authorization
server.
11Which RS is used in combination with an AS depends on the conﬁguration
of the client, which is acquired through means not deﬁned in OAuth. Especially
in scenarios where this conﬁguration is done dynamically, a dishonest AS
might be used in combination with an honest RS. But also if the client is
conﬁgured manually, as is often the case today, it might be misconﬁgured or
social engineered into using speciﬁc endpoints. Recall from Section II-A that
the access token might be a document signed by the (honest) AS containing
all information the RS needs to process the access token. Alternatively, and
more common, the RS performs token introspection, if the access token is
just a nonce. The RS typically uses only one AS (in this case, the honest AS)
to which it will send the introspection request.
(cid:21)(cid:23)(cid:18)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:17 UTC from IEEE Xplore.  Restrictions apply. 
Attacker (User)
Client
Authorization Server
1 POST /start
POST /start
2 Response
Response
Redirect to AS /authorization_endpoint
Redirect to AS /authorization_endpoint
(client_id, redirect_uri, state)
(client_id, redirect_uri, state)
3 GET /authorization_endpoint
GET /authorization_endpoint
(client_id, redirect_uri, state)
(client_id, redirect_uri, state)
4
attacker authenticates
attacker authenticates
5 Response
Response
Redirect to C /redirect_uri (code, state, id token)
Redirect to C /redirect_uri (code, state, id token)
6 GET /redirect_uri
GET /redirect_uri
(code, state, id token)
(code, state, id token)
Authorization Server
Attacker (Token EP)
7 POST /token_endpoint
POST /token_endpoint
(code, client_id, [client authentication])
(code, client_id, [client authentication])
8 Response
Response
(access token, id token)
(access token, id token)
Attacker (Token EP)
Resource Server
9 GET /resource
GET /resource
access token
access token
10 Response
Response
resource
resource
Attacker (User)
Client
Resource Server
Figure 5. Access Token Injection with ID Token Replay Attack
In Step 7 ,
the client sends the token request
created by the honest AS, the state and all values of the id token
are correct and the client accepts the authorization response.
to the
misconﬁgured token endpoint controlled by the attacker. The
value of the code and the checks regarding client authentication
and proof of possession of keys are not relevant for the attacker.
In Step 8 , the attacker sends the token response containing
the phished access token. As the ﬂow is an OIDC Hybrid Flow,
the attacker is required to return an id token. Here, he returns
the same id token that he received in Step 5 , which is signed
by the honest AS. The client is required to ensure that both
id tokens have the same subject and issuer values, which in
this case holds true since they are identical.
The client sends the access token to the honest resource
server, by which the attacker gets read-write access to the
resource of the honest resource owner through the client.
As we show in our security analysis (see Section V), this
scenario is prevented if the second id token is required to
contain the hash of the access token that is returned to the
client, as the attacker cannot create id tokens with a valid
signature of the AS. A similar ﬁx also works for ﬂows with
JARM. The ﬁxes are already included in our model.
C. PKCE Chosen Challenge Attack
As detailed in Section III-C1, the FAPI uses PKCE in
order to protect against leaked authorization codes. This is
particularly important for public clients as these clients, unlike
conﬁdential ones, do not authenticate to an AS when trying to
exchange the code for an access token.
Recall that the idea of PKCE is that a client creates a PKCE
challenge (hash of a nonce), gives it to the AS, and when
redeeming the authorization code at the AS, the client has to
present the correct PKCE veriﬁer (the nonce). This idea works