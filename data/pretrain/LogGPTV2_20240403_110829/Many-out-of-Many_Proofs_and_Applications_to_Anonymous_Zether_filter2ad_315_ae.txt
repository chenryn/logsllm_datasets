D = gr ∧ (y · y)r = C · C∧
.
Rn∧
2) Anonymous Zether: In Anonymous Zether [6, §D], a
sender may hide herself and the recipient in a larger ring
(yi)N−1
i=0 . To an observer, it should be impossible to discern
which among a ring’s members sent or received funds. Speciﬁ-
cally, a sender should choose a list (yi)N−1
i=0 , as well as indices
l0 and l1 for which yl0 and yl1 belong to the sender and
recipient, respectively. The sender should then publish this list,
as well as a list of ciphertexts (Ci, D)N−1
i=0 , for which (Cl0, D)
encrypts g−b∗
under yl1, and
(Ci, D) for each i (cid:54)∈ {l0, l1} encrypts g0 under yi. To apply
the transfer, the contract should homomorphically add (Ci, D)
to yi’s balance for each i; we denote the list of new balances
by (CLn,i, CRn,i)N−1
i=0 .
under yl0, (Cl1, D) encrypts gb∗
Finally, the prover should prove knowledge of:
• l0, l1 ∈ {0, . . . , N − 1} (sender’s and recipient’s secret
indices),
texts encrypt opposite balances),
• sk for which gsk = yl0 (knowledge of secret key),
• r for which:
– gr = D (knowledge of randomness),
– (yl0 · yl1)r = Cl0 · Cl1 (sender’s and receiver’s cipher-
– for each i (cid:54)∈ {l0, l1}, yr
i = Ci (all ciphertexts other
• b∗ and b(cid:48) in {0, . . . , MAX} for which Cl0 = g−b∗ · D and
CLn,l0 = gb(cid:48) · CRn,l0 (overﬂow and overdraft protection).
We group these conditions into a relation, adapting [6, (8)].
than the sender’s and recipient’s encrypt 0),
(cid:1) |
Formally:
gsk = yl0 ∧ Cl0 = g−b∗
(cid:110)(cid:0)(yi, Ci, CLn,i, CRn,i)N−1
D = gr ∧ (yl0 · yl1 )r = Cl0 · Cl1 ∧ (cid:94)
i=0 , D, u, gepoch; sk, b∗, b(cid:48), r, l0, l1
∧
C sk
i = Ci∧
yr
epoch = u ∧ b∗ ∈ {0, . . . , MAX} ∧ b(cid:48) ∈ {0, . . . , MAX}∧
gsk
Dsk ∧ CLn,l0 = gb(cid:48)
(cid:111)
N ≡ 0 mod 2 ∧ l0 (cid:54)≡ l1 mod 2
i(cid:54)∈{l0,l1}
Rn,l0
.
(1)
For technical reasons (discussed in Subsection V-C below),
we treat a slight variant of [6, (8)], in which N is required to
be even and l0 and l1 are required to have opposite parities.
B. Insider and “rogue-key” attacks
We now turn to anonymous payment. We begin with a com-
ment regarding the Anonymous Zether statement; in particular,
this subsection applies equally to this work and to [6, §D].
An important aspect of the statement (1) is that the same
randomness D is used in each El Gamal ciphertext (Ci, D).
Yet the appeal of [6] to Kurosawa [20] (in defense of this
measure) appears to misunderstand the latter work. Indeed,
as Bellare, Boldyreva and Staddon [21, §1.2] observe, Kuro-
sawa’s security deﬁnitions are weak, and assume in particular
that each adversary is an “outsider”.
In contrast, we sketch a plausible insider attack on privacy—
analogous to that described in [21, §4]—on any protocol
following the paradigm of [6, §D] (i.e., regardless of its
proof system). The attacker, targeting some honest user y,
generates a rogue public key y∗ := ysk∗
(for some secret
∗). The attacker then induces some honest
and arbitrary sk
user (possibly, but not necessarily, y) to include both the
attacker and y in the honest user’s anonymity set. The attacker
ﬁnally obtains the quantity b of y’s change in balance (and in
particular, determines whether y was the sender, the recipient,
or neither) using the following procedure. If y and y∗ reside
at the indices l and l∗ (respectively) of the anonymity set
(yi)N−1
(and assuming for simplicity that y∗ was neither the
recipient nor the sender), the attacker simply determines b
. The essential mechanism
is that the Difﬁe–Hellman elements of y and y∗ with respect
to D differ by the same logarithm by which y and y∗ differ
(namely, sk
using gb = Cl ·(cid:16)
(Cl∗ )(sk∗)−1(cid:17)−1
∗).
i=0
We observe that the conduct of the attacker is completely
undetectable to y. We emphasize, moreover, that y is at risk
even during transactions which she does not initiate; indeed,
the sender whom y∗ tricks (i.e., into including y and y∗) may
be arbitrary (say, unknown to y, for example).
We adopt the remedy suggested by [21, §1.2]. That is, we
require each participant to prove knowledge of her own public
key before participating in the contract (i.e., before appearing
in any anonymity set). We implement a “registration” proce-
dure, whereby each public key must sign a speciﬁed, ﬁxed
message before it participates. This requirement is minimally
cumbersome (especially in light of the superﬂuity of multiple-
account use in Anonymous Zether). We suggest the elimina-
tion of this requirement as a problem for future work.
We note that this issue does affect basic Zether, but vacu-
ously so, in that each transaction’s “insiders” (i.e., its sender
and recipient) already know each other’s respective roles, as
well as the amount of funds sent.
C. Cryptographic approach to anonymity
We now summarize our proof protocol for Anonymous
Zether; our approach uses many-out-of-many proofs in a
crucial way. The most signiﬁcant challenge of the Anonymous
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:00 UTC from IEEE Xplore.  Restrictions apply. 
1808
Cl0 · Cl1, but also that (cid:86)
Zether relation (1) is that all N ciphertexts (Ci, D)N−1
appear; in particular, it requires not just that (yl0 · yl1)r =
i = Ci, where gr = D
(and l0 and l1 are the sender’s and receiver’s secret indices,
respectively).
i(cid:54)∈{l0,l1} yr
i=0
i=0
We ﬁrst describe our approach informally. Roughly, using
standard one-out-of-many proofs, the prover may efﬁciently
convey to the veriﬁer two vectors of ﬁeld elements (p0,i)N−1
and (p1,i)N−1
i=0 , each of which provably takes a special form
(i.e., each consists of evaluations of polynomials, exactly
one of which is degree-m and monic; see Subsection III-B).
Using these vectors—and standard one-out-of-many proofs—
the veriﬁer may obtain re-encryptions (i.e., same message,
but different randomness) of the sender’s and receiver’s ci-
phertexts, respectively, without learning the original indices
of these ciphertexts. The prover and veriﬁer may then—using
the techniques of Section IV—run a variant of basic Zether
upon these re-encrypted ciphertexts, in order to certify spend
authority, overdraft protection, and conservation of value (for
these two ciphertexts only).
It remains only for the veriﬁer to ensure that the remaining
ciphertexts are encryptions of 0. This cannot be done na¨ıvely—
say, by using Σ-protocols on these remaining ciphertexts—
as the veriﬁer does not know which two indices to exclude
from the checks (and the prover cannot reveal these indices).
The veriﬁer can, however, “iterate” through the remaining
ciphertexts by circularly rotating the vectors (p0,i)N−1
and
(p1,i)N−1
i=0 , and iteratively re-running the one-out-of-many pro-
cess. The veriﬁer may then conduct simple “proof-of-0” Σ-
protocols on each of these further ciphertexts.
i=0
Importantly, the secret indices represented by these vectors’
rotations relate to the original secret indices in a predictable
way. In fact, in order to produce a perfect re-ordering of the
original list, the veriﬁer uses two-step rotations (and even
N), and also ensures that the original secret indices feature
opposite parities.
Put differently, the prover implicitly sends two rows of a
matrix, each of which contains exactly one 1; by performing
two-step rotations, the veriﬁer constructs the N − 2 remaining
rows. The matrix so constructed is necessarily a permutation
matrix, so long as the top two rows attain the value 1 at indices
of opposite parity (see Fig. 3).
That the parities of l0 and l1 are indeed opposite can be
checked by adapting ideas already present in [9] and [10], as
we argue in Subsection V-E below.
We now express this procedure as a direct application of
many-out-of-many proofs, for which an efﬁcient algorithm ex-
ists (see Theorem III.12). The above procedure is exactly that
of running many-out-of-many proofs twice, using in each case
the free permutation κ = (0, 2, . . . , N − 2)(1, 3, . . . , N − 1).
The veriﬁer in this way iterates over the respective ordered
orbits of two secret indices l0 and l1 under κ. If (and only
if) l0 and l1’s parities are opposite,
then these orbits are
disjoint, and together exhaust {0, . . . , N − 1}. Finally, the
veriﬁer interleaves the respective rows yielded by these two
(cid:123)(cid:122)
(cid:123)(cid:122)
1 only at index l0
1 only at index l1
0, . . . . . . . . . . . . , 1, . . . . . . . . . . . . , 0
0, . . . . . . , 1, . . . . . . . . . . . . . . . . . . , 0
0, . . . . . . . . . . . . . . . . . . . . . , 1, . . . , 0
0, . . . . . . . . . . . . . . . , 1, . . . . . . . . . , 0
...
0, . . . . . . . . . , 1, . . . . . . . . . . . . . . . , 0
0, . . . , 1, . . . . . . . . . . . . . . . . . . . . . , 0
(a) “Prover’s view”.
(p0,i)N−1
i=0
(p1,i)N−1
i=0
(cid:123)(cid:122)
(cid:123)(cid:122)
“1” at unknown even (resp.) or odd index
“1” at unknown odd (resp.) or even index
(p0,i)N−1
(p1,i)N−1
i=0
i=0
...
(p0,i)N−1
(p1,i)N−1
i=0
i=0
(b) “Veriﬁer’s view”.
(cid:125)
(cid:125)
(cid:125)
(cid:125)
 .
(cid:124)
(cid:124)
(cid:124)
(cid:124)
Ξ =
1
0
0
...
0
(cid:40)
Fig. 3: Two views of the “double circulant” matrix.
executions, and sets Ξ as the (N − 1) × N matrix:
1
0
0
...
0
0
1
0
...
0
0
0
1
...
0
. . .
. . .
. . .
...
. . .
0
0
0
...
1
This matrix controls the messages of the permuted ciphertexts
(CK(0), D), (CK(1), D) . . . , (CK(N−1), D), where K sends
i (cid:55)→ K(i) :=
(l0 + 2 · k) mod N if i = 2 · k
(l1 + 2 · k) mod N if i = 2 · k + 1.
Indeed, it encodes exactly that the sum (Cl0 , D) · (Cl1, D) is
an encryption of 0, whereas the ciphertexts (Ci, D) for i (cid:54)∈
{l0, l1} individually encrypt 0. (This matrix has O(N ) nonzero
entries, and so satisﬁes the hypothesis of Theorem III.12.)
A variant of Anonymous Zether supporting transaction fees
immediately follows upon adding an afﬁne part to the matrix
Ξ. Indeed, for any ﬁxed transaction fee f—a nonnegative
integer—one may set:
Ξ : (m0, m1, . . . , mN−1) (cid:55)→ (m0 + m1 + f, m2, . . . , mN−1) ,
and deliver a fee of f into a designated account upon each
transaction. This transformation encodes the fact that (Cl0, D)
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:00 UTC from IEEE Xplore.  Restrictions apply. 
1809
and (Cl1, D) respectively encrypt messages m0 and m1 for
which −m0 = m1 + f, while all other ciphertexts encrypt 0.
D. Reducing prover runtime to O(N log N )
as
that
2 −1
ι,j=0
We
reduce
the
runtime
prover’s
complexity
from
O(N log2 N ) to O(N log N ) using a further trick, which
we presently sketch. We exploit the special structure of the
Anonymous Zether ciphertexts (Ci, D)N−1
i=0 , only O(1) (i.e.,
2) of whose messages are nonzero.
(Ci, yi)
“encryptions” un-
the “public key” D. A direct application of Sec-
der
tion III would prescribe,
the prover
construct—and the veriﬁer eliminate—the entire kth-order part
(cid:17)ξ2·j+ι of the uncorrected many-
(cid:16)(cid:81)N−1