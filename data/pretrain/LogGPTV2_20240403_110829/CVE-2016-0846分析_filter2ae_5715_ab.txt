    reply->writeInt32(size);
    return NO_ERROR;
    } break;
    default:
    return BBinder::onTransact(code, data, reply, flags);
    }
    }
MemoryBase::getMemory函数逻辑十分简单,直接将MemoryBase的成员变量mOffset、mSize、mHeap返回给调用者,而这三个值均是从MemoryBase对象初始化过程中得到的。
    MemoryBase::MemoryBase(const sp& heap,
    ssize_t offset, size_t size)
    : mSize(size), mOffset(offset), mHeap(heap)
    {
    }
    sp MemoryBase::getMemory(ssize_t* offset, size_t* size) const
    {
    if (offset) *offset = mOffset;
    if (size) *size = mSize;
    return mHeap;
    }
**0x04 PoC构造**
实际上,在确认IMemory完全信任server端回传的数据后,我们可以伪造一个IMemory
Service组件,用它与运行在其他service中的IMemory
Client组件进行通信,并利用其他service对我们指定的heap、offset、size的读写操作来达到对service进程的越界读写。
要达到越界读写效果,要求目标service符合以下几个条件:
1\. 该service通过Binder
IPC接收包含IMemory对象的Parcel,并将IMemory中包含的MemoryHeapBase通过mmap映射到了自己的内存空间。
2\. 该service调用IMemory->pointer()函数,并对其所返回的地址进行了读或写操作。
3\. 在读写操作中,未对共享内存的边界作合法性检验,或者检验可以被绕过。
在Forshaw与oldfresher的PoC中,他们使用的是运行在Media Player
Service中的ICrypto。首先看一看BpCrypto::decrypt()函数,该函数允许用户创建一个IMemory强指针对象,作为sharedBuffer参数传入函数中,同时传入的还有subSample,dstPtr等其他参数,decrypt函数的函数原型如下:
    virtual ssize_t decrypt(
    bool secure,
    const uint8_t key[16],
    const uint8_t iv[16],
    CryptoPlugin::Mode mode,
    const sp &sharedBuffer, size_t offset,
    const CryptoPlugin::SubSample *subSamples, size_t numSubSamples,
    void *dstPtr,
    AString *errorDetailMsg) ;
在decrypt函数中,会将key,iv直接写入Parcel类型的data中,并从subSamples计算出一个sizet类型的totalSize、将dstPtr作为一个uint64t、将sharedMemory作为一个StrongBinder写入data中,并通过remote()->transact(DECRYPT,data,&reply)远程调用,将返回结果写入dstPtr中,如下:
    remote()->transact(DECRYPT, data, &reply);
    ssize_t result = reply.readInt32();
    if (isCryptoError(result)) {
    errorDetailMsg->setTo(reply.readCString());
    }
    if (!secure && result >= 0) {
    reply.read(dstPtr, result);
    }
跟进到BnCrypto::onTransact的case DECRYPT分支下,在该分支中,将封装在data
Parcel中的数据重新取出,并做一些简单的check,然后交由serice组件的decrypt()函数最终执行。
    } else if (totalSize > sharedBuffer->size()) {
    result = -EINVAL;
    } else if ((size_t)offset > sharedBuffer->size() - totalSize) {
    result = -EINVAL;
    } else {
    result = decrypt(
    secure,
    key,
    iv,
    mode,
    sharedBuffer, offset,
    subSamples, numSubSamples,
    secure ? secureBufferId : dstPtr,
    &errorDetailMsg);
    }
在以上两个check中,sharedBuffer->size()通过调用IMemory::size()返回结果,由前面分析可知,size()中调用了服务端的getMemory,如果service组件可伪造,则该值是可以任意指定的,因而以上两条check可被绕过。
继续跟进,上面的decrypt函数实际为ICrypto函数所声明的纯虚函数,在BnCrypto中没有实现,而是在BnCrypto的子类Crypto中实现的。Crypto类的实现位于
frameworks/av/media/libmediaplayerservice/Crypto.cpp&Crypto.h中,Crypto::decrypt()函数通过调用sharedBuffer->pointer()函数获取匿名
共享内存,并将其与传入的offset参数相加,作为srcPtr传入mPlugin->decrypt函数中,如下所示:
    const void *srcPtr = static_cast(sharedBuffer->pointer()) + offset;
    return mPlugin->decrypt(
    secure, key, iv, mode, srcPtr, subSamples, numSubSamples, dstPtr,
    errorDetailMsg);
mPlugin是Crypto结构体类型中CryptoPlugin类型的成员变量。CryptoPlugin的实现位于/frameworks/native/include/media/hardware/CryptoAPI.h中,它有两个子类,分别为android::MockCryptoPlugin
与 clearkeydrm::CryptoPlugin,这两者源码在frameworksavdrmmediadrmplugins目录下。
通过查看两个plugin的decrypt代码,我们发现mock plugin的decrypt函数只打了一条LOG,没有做其他事情,而clearkey
plugin的decrypt函数比较有内容:
    ssize_t CryptoPlugin::decrypt(bool secure, const KeyId keyId, const Iv iv,
    Mode mode, const void* srcPtr,
    const SubSample* subSamples, size_t numSubSamples,
    void* dstPtr, AString* errorDetailMsg) {
    if (secure) {
    errorDetailMsg->setTo("Secure decryption is not supported with "
    "ClearKey.");
    return android::ERROR_DRM_CANNOT_HANDLE;
    }
    if (mode == kMode_Unencrypted) {
    size_t offset = 0;
    for (size_t i = 0; i setTo(
    "Encrypted subsamples found in allegedly unencrypted "
    "data.");
    return android::ERROR_DRM_DECRYPT;
    }
    if (subSample.mNumBytesOfClearData != 0) {
    memcpy(reinterpret_cast(dstPtr) + offset,
    reinterpret_cast(srcPtr) + offset,
    subSample.mNumBytesOfClearData);
    offset += subSample.mNumBytesOfClearData;
    }
    }
    return static_cast(offset);
    }else if( mode == kMode_AES_CTR ){
    ....
    }
当secure为假、mode为kMode_Unencrypted时,程序会执行一个memcpy,从共享内存srcPtr中拷贝mNumBytesOfClearData字节的数据至dstPtr,而当服务端被伪造时,srcPtr可以设置成大于共享内存的地址,会造成越界读出共享内存之外的内容,并将内容通过dstPtr会返回给mediaService的Client端。
弄明白上述过程之后,PoC的编写流程即非常清晰了,共需要做两件事情:
1\. 伪造一个实现IMemory接口的service,用以在执行IMemory->pointer()、IMemory->size()时返回指定的值。
2\.
构造调用decrypt函数所需要的各参数,以便最终执行到clearkeydrm::CryptoPlugin::decrypt函数中的memcpy函数。
越界读PoC如下:https://github.com/b0b0505/CVE-2016-0846-PoC/blob/master/mypoc.cpp
在我的PoC中,采用的是如上文中所提到的伪造MemoryBase服务的方法,并重写getMemory函数,参考龚神的地方比较多,Orz膜拜龚神改虚表hook
写PoC的方法。
运行效果如下:
**0x05 参考引用**
1\. 
2\. 
3\. 
4\. 
5\. 《Android 系统源代码情景分析》 Binder通信以及匿名共享内存章节