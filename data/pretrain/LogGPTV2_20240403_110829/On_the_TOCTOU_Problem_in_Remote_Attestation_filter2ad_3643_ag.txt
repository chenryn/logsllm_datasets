23
24
25
void Hacl_HMAC_SHA2_256_hmac_entry ( )
u i n t 8 _ t key [ 6 4 ] = { 0 } ;
u i n t 8 _ t v e r i f i c a t i o n [ 3 2 ] = { 0 } ;
if (memcmp(CHALL_ADDR , CTR_ADDR ,
{
memcpy ( key , KEY_ADDR ,
6 4 ) ;
{
3 2 ) > 0 )
hacl_hmac ( ( u i n t 8 _ t ∗ ) v e r i f i c a t i o n ,
∗ ( ( u i n t 8 _ t ∗ ) CHALL_ADDR)
( u i n t 8 _ t ∗ ) key ,
,
( u i n t 3 2 _ t ) 64 ,
( u i n t 3 2 _ t ) 3 2 ) ;
if ( ! memcmp( VRF_AUTH , v e r i f i c a t i o n ,
{
3 2 )
hacl_hmac ( ( u i n t 8 _ t ∗ ) key ,
( u i n t 8 _ t ∗ ) key ,
( u i n t 3 2 _ t ) 64 ,
( u i n t 3 2 _ t ) 3 2 ) ;
( u i n t 8 _ t ∗ ) v e r i f i c a t i o n ,
hacl_hmac ( ( u i n t 8 _ t ∗ ) MAC_ADDR,
( u i n t 3 2 _ t ) 32 ,
( u i n t 3 2 _ t ) ATTEST_SIZE ) ;
memcpy (CTR_ADDR , CHALL_ADDR ,
3 2 ) ;
( u i n t 8 _ t ∗ ) key ,
( u i n t 8 _ t ∗ ) ATTEST_DATA_ADDR ,
}
}
return ( ) ;
}
Figure 9: SW-Att Implementation with Vrf authentica-
tion [10].
To prevent an adversary from impersonating Vrf and sending
fake attestation requests to Prv, VRASED design supports authenti-
cation of Vrf as part of SW-Att execution. The implementation is
based on the protocol in [59]. In this protocol, Chal is chosen by
Vrf as a monotonically increasing nonce, i.e., consecutive requests
i and i + 1, Chali  negl(l). Therefore, Adv can
contradiction,
a
Session 11A: Attestation and Firmware Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2934produce tLMT ||HAdv such that:
VerifyVrf(HAdv, Chal, M, t0, tLMT ) = 1
and
∃t0≤ti ≤tat t {AR(ti) (cid:44) M}
By definition, Verify in Construction 1 results in 1 only if tLMT  negl(l),
even though tLMT  negl(l)
(20)
□
C PROOF OF THEOREM 6.1
We now show that, if properties in Equations 15, 16 and 17 hold,
existence of Adv that wins the TOCTOU security game against
RAT AB implies the existence of another Adv that wins RA security
game against VRASED, thus contradicting the initial premise.
Proof. By
contradiction,
polynomial Adv
that wins
the game in Definition 4.1 with probability
Pr[Adv,RA-TOCTOU-game] > negl(l). Therefore, Adv can
produce response LMTAdv||HAdv such that:
assume
a
VerifyVrf(HAdv, Chal, M, t0,T , LMTAdv) = 1
and
∃t0≤ti ≤tat t {AR(ti) (cid:44) M}
By definition, in Construction 2, Verify outputs 0 if LMTAdv differs
from ChalP stored by Vrf in the challenge-time association pair
P = (ChalP , tP). If LMTAdv = ChalP , it corresponds to a chal-
lenge value sent before t0 (assuming sensible choices of t0 by Vrf).
Therefore, in order to win, Adv must choose LMTAdv = ChalP .
Since LMT ∈ AR, by claiming a value for LMTAdv fitting the
restriction above, Adv causes the expected memory value M to
also reflect, LMT = LMTAdv. At this point, Adv has two possible
actions: to modify AR to call Attest with AR(tatt) = M; or to obtain
HAdv even with AR(tatt) (cid:44) M. First we show that the latter is
Adv’s only option.
Suppose that Adv attempts to set AR(tatt) = M to call Attest.
In this case, we stress three observations about RAT AB:
(1) By LTL statement 17, any modification to AR in between the
i-th and (i + 1)-th authenticated computations of Attest, will
cause AR to change to reflect LMT = Chali +1 in following
RA responses. Therefore, the premise that:
∃t0≤ti ≤tat t {AR(ti) (cid:44) M}
will necessarily update LMT .
(2) From VRASED authentication (see Appendix A), for subse-
quent RA challenges Chali and Chali +1 that authenticate
successfully, it is always the case that Chali  negl(l).
replies with σ = HAdv.
(3) As a response in step 3 of the game in Definition 3.2, AdvRA
Since VerifyVrf(HAdv, Chal, M, t0,T , LMTAdv) = 1, it follows
that σ = HMAC(KDF(K, Chal), M) (first condition for AdvRA
to win), for expected M containing LMT = LMTAdv. On the other
hand, because memory was modified at time ti, it must be the case
that AR(t) has LMT (cid:44) LMTAdv. Thus satisfying the remaining
condition that AR(t) (cid:44) M implies that AdvRA wins the game in
Definition 3.2 with probability:
Pr[Adv,RA-game] = Pr[Adv,RA-TOCTOU-game] > negl(l)
(21)
□
D RAT A IMPLEMENTATION WITH SANCUS
To demonstrate RAT A generality, we also implemented it atop SAN-
CUS [20]: a hardware-based RA architecture targeting the same
class of embedded devices. To the best of our knowledge, aside
from VRASED (used in our verified implementation), SANCUS is
the only other open-source RA architecture for low-end embedded
systems, which justifies our choice. We note that this implementa-
tion is intended to demonstrate RAT A generality and that provable
security guarantees derived from RAT A-with-VRASED do not ap-
ply here. Since SANCUS does not provide a formal security model
and analysis, provable composition of RATA atop SANCUS is not
currently possible.
Since RAT A operates as a standalone monitor that does not in-
terfere with neither the CPU nor the underlying RA architecture
functionality, adapting RATA to work with SANCUS is almost effort-
less. We describe this implementation in terms of RAT AA, which
is simpler and does not depend on Vrf authentication. The main
difference from the VRASED-based implementation is due to SAN-
CUS support for isolated software modules (SMs), where each SM
is attested individually as an independent program. We note that
even SANCUS’ support for attestation and inter-process isolation is
insufficient to provide TOCTOU-Security, since Prv program mem-
ory could be physically re-programmed or modified via exploits to
vulnerabilities in the code of the isolated application itself, without
Vrf’s knowledge. Hence, similar to VRASED’s RA case, RAT A also
complements SANCUS security guarantees.
To enable RAT A functionality over SANCUS one must be careful
(when programming Prv) to configure the software binary such
that the program memory of a particular SM of interest coincides
with RAT A AR region. As such, program memory of the SM will be
automatically checked by RAT A module and SANCUS attestation of
such SM program memory will also cover LMT (since LMT ∈ AR)
providing an authenticated proof to Vrf of the time of the latest
modification of such SM program memory.
We note that this approach requires one RAT A module per SM,
since multiple SMs imply dividing Prv program memory into mul-
tiple ARs and corresponding LMT regions. Nonetheless, since low-
end devices typically run very few processes, we expect the cost to
remain manageable.
Because SANCUS is implemented on the same MCU as VRASED
(OpenMSP430), no internal modifications are required to RAT A
hardware module, and its additional hardware cost remains con-
sistent with that reported in Table 2. To support TOCTOU-Secure
attestation of multiple SMs, this cost grows linearly, i.e., the cost in-
curred by one RAT A hardware module multiplied by the number of
independent SMs that should support TOCTOU-Secure attestation.
We note that, in RAT AA, the same secure read-only synchronized
clock can be shared by all such modules.
Session 11A: Attestation and Firmware Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2936