# 解密为何树莓派不受SPECTRE或MELTDOWN漏洞影响
##### 译文声明
本文是翻译文章，文章原作者 Eben Upton，文章来源：raspberrypi.org
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 一、前言
过去几天，名为[Spectre以及Meltdown](https://spectreattack.com/)的一组安全漏洞引发了各种讨论。几乎所有的Intel处理器会受到这些漏洞影响，而许多AMD处理器及[ARM核心](https://developer.arm.com/support/security-update)处理器同样也无法幸免于难（特别是Spectre漏洞）。利用Spectre漏洞，攻击者可以绕过软件检查机制，在当前地址空间中从任意位置读取数据；而Meltdown漏洞则可以帮助攻击者从操作系统内核地址空间的任意位置读取数据，即使内核地址空间通常情况下对用户程序透明。
这两个漏洞利用的是现代处理器中常用的性能优化功能（缓存及推测执行），通过侧信道（side-channel）攻击来获取信息。幸运的是，树莓派（Raspberry Pi）并不会受到这次事件影响，原因是树莓派使用了特定版本的ARM核心。
为了理解具体原因，我们需要先介绍一下现代处理器中的一些基本概念。我们通过符合Python语法的几个简单代码来介绍这些概念，示例程序如下所示：
    t = a+b
    u = c+d
    v = e+f
    w = v+g
    x = h+i
    y = j+k
虽然计算机中的处理器不会直接执行Python程序，但上述语句非常简单，大致可以等同于单条机器指令。这里我不会去介绍一些技术细节（比如[流水线处理（pipelining）](https://en.wikipedia.org/wiki/Pipeline_\(computing))以及[寄存器重命名（register
renaming）](https://en.wikipedia.org/wiki/Register_renaming)），虽然这些技术点对处理器设计师来说非常重要，但对理解Spectre以及Meltdown的原理帮助不大。
如果想全面了解处理器设计及现代计算机架构的其他内容，大家可以阅读Hennessy以及Patterson编写的经典参考书：[ _Computer
Architecture: A Quantitative Approach_](https://www.amazon.co.uk/Computer-Architecture-Quantitative-Approach-Kaufmann/dp/012383872X)，这是一本很棒的参考书，几乎无人能出其右。
## 二、标量处理器
所谓的标量处理器（scalar
processor），指的是最为简单的一类现代处理器类型，这类处理器在每个周期（cycle）内只能执行一条指令。前面我们给出的那个例子在标量处理器上需要消耗6个执行周期。
许多处理器属于标量处理器，比如Intel 486、Raspberry Pi 1以及Raspberry Pi Zero所使用的ARM1176核心。
## 三、超标量处理器
如果想要提高标量处理器（或者其他类型的任意处理器）的运行速度，最容易想到的一种方法就是增加处理器的时钟频率。然而，这么做很快就会触碰到处理器内部逻辑门运行速度的天花板，因此处理器设计人员开始寻找可以同时完成多项任务的办法。
有序（in-order）超标量处理器（superscalar
processor）会检查指令流，尝试使用多条流水线一次执行多条指令，但在同一条流水线中必须遵守指令的依赖关系。指令依赖非常重要，比如，在上述例子中，你可能会认为两路超标量处理器可以将6条指令配对（或者
_dual-issue_ ）成如下形式：
    t, u = a+b, c+d
    v, w = e+f, v+g
    x, y = h+i, j+k
但实际上并非如此，在计算`w`之前，我们必须先计算`v`，因此第3及第4条指令没办法同时执行。两路超标量处理器没办法找到与第3条指令配对的其他指令，因此上述指令需要使用4个周期才能执行完毕：
    t, u = a+b, c+d
    v    = e+f                   # second pipe does nothing here
    w, x = v+g, h+i
    y    = j+k
许多处理器属于超标量处理器，如Intel Pentium、Raspberry Pi 2以及Raspberry Pi 3中使用的ARM
Cortex-A7以及Cortex-A53核心等。相比Raspberry Pi 2，Raspberry Pi
3的时钟速率只提升了33%，但整体性能提升了将近一倍，原因在于Cortex-A53比Cortex-A7能够支持更多指令的双路运行。
## 四、乱序处理器
回到这个例子中，我们可以看到，虽然`v`和`w`有依赖关系，但程序后续使用了一些独立指令，我们可以在第二个执行周期中，充分利用这些指令，填满空闲的流水线。乱序（out-of-order）超标量处理器可以输入指令流（当然同样需要遵守依赖关系），使流水线保持忙碌状态。
对于我们那个例子，乱序处理器可以交换`w`以及`x`的定义，以提高工作效率，如下所示：
    t = a+b
    u = c+d
    v = e+f
    x = h+i
    w = v+g
    y = j+k
这样只需3个周期就能完成所有指令的执行：
    t, u = a+b, c+d
    v, x = e+f, h+i
    w, y = v+g, j+k
许多处理器属于乱序处理器，如Intel Pentium
2（Intel及AMD后续生产的x86处理器大多都属于这类处理器，某些Atom以及Quark处理器除外），近期推出的ARM核心也属于这一类别，如Cortex-A9、-A15、-A17以及-A57。
## 五、分支预测器
我们给出的例子是一段非常简单直白的代码，实际程序会复杂得多：这些程序既包括前向分支（用来实现条件判断操作，如`if`语句），也包括后向分支（用来实现循环语句）。分支可以是条件无关的（即始终会被执行），也可以是条件相关的（由计算结果判断是否需要执行）。
在获取指令时，处理器可能会遇到某个条件分支，该分支依赖于某个尚未计算出的值。为了避免任务停滞，处理器必须猜测接下来要获取哪条指令：是按内存顺序（memory
order）获取的下一条指令（不进入该分支），还是进入分支的下一条指令。分支预测器（branch
predictor）可以帮助处理器智能判断是否会进入某条分支，具体方法是收集过去执行过程中进入这些分支的频率，根据统计信息给出结果。
现代分支预测器非常复杂，生成的预测结果也非常准确。Cortex-A7到Cortex-A53的分支预测改进了不少，这也是Raspberry Pi
3性能有所提升的原因所在。然而，攻击者可以精心构造一系列分支，训练分支预测器，使其预测结果非常糟糕。
## 六、推测执行
对顺序指令重新排序的确是非常强大的一种方法，可以提高指令级别的并行处理能力，但随着处理器变得越来越宽（即能够实现3指令、4指令并发指令），想要保持所有流水线处于忙碌状态也变得越来越难。因此现代处理器引入了推测执行（speculate）功能。引入推测执行功能后，处理器可能会执行并不需要的那些指令（如果相应分支被跳过），这样流水线会始终处于忙碌状态（不用就闲置了），如果最终结果是该指令没被执行，处理器只需要丢弃已得结果即可。
为了说明推测执行的优点，我们可以来看一下另一个例子：
    t = a+b
    u = t+c