### Receiver-Side Restoration and Security Intuition

On the receiver side, a pointer allows for the restoration of the original payload. The security intuition behind application-based covert channels (ABCCs) is straightforward: if the messages produced by the application are common in the target environment and the embedding is well-executed, then messages carrying covert bits should not arouse suspicion. Prior work often supports this intuition with empirical analyses comparing normal application messages to those carrying covert bits. However, no prior work provides a formal foundation for the design and analysis of ABCCs—i.e., a formal description of an ABCC as an abstract object and security notions that precisely define adversarial goals and attack models. The primary goal of this work is to provide such a foundation and to evaluate prior works against it.

### Foundations for ABCCs

To achieve this goal, we begin by formalizing ABCCs as a syntactic primitive. Specifically, an ABCC is defined as a tuple of algorithms \(\Pi = (\text{Setup}, \text{Embeduser}, \text{Embedwire}, \text{Extractwire}, \text{Extractuser})\). Figure 1 illustrates a block diagram of these algorithms in use. Our syntactic choices are informed by approaches taken in prior work. We have already provided examples of prior ABCC schemes that embed on the user-side and others that embed on the wire-side. However, we are not aware of any system that leverages both user-side and wire-side embedding. Even without considering new schemes, it seems plausible that systems using the same type of application for overt traffic (e.g., Castle and Rook) could be combined to increase overall system throughput. Our syntax explicitly highlights this possibility.

Our second foundational contribution is to define a notion of security for ABCCs. This notion states that the observable traffic produced by an ABCC should resemble the traffic of the co-opted application under normal use. To capture this, we formalize application channels as a tuple of algorithms \(\text{App} = (\text{Init}, \text{Source}, \text{Sink})\), where \(\text{Source}\) denotes the initiator (e.g., client) and \(\text{Sink}\) denotes the responder (e.g., server). Given an application channel, our security notion requires that messages sent from \(\text{Source}\) to \(\text{Sink}\), and the \(\text{Sink}\)-responses they trigger (i.e., overt communication), should be computationally indistinguishable from messages sent from the \(\text{Source}\)-side of the covert-channel to the \(\text{Sink}\)-side of it, and the \(\text{Sink}\)-responses they trigger.

It is intuitive that overt-channel and covert-channel messages should look alike, but our notion also explicitly requires that the observable behaviors of \(\text{Sink}\) should not noticeably change when the covert channel is in operation. For example, Rook targets this requirement by identifying mutable fields in game packets, and Balboa achieves it by having the server replace covert bits with overt bits before passing them to \(\text{Sink}\).

### Classes of ABCCs and Their Security

As mentioned, prior work on ABCCs can be divided into two categories: those that process covert bits using only \(\text{Embedwire}\) and \(\text{Extractwire}\) (effectively fixing \(\text{Embeduser}\) and \(\text{Extractuser}\) to be pass-throughs), and those that process covert bits using only \(\text{Embeduser}\) and \(\text{Extractuser}\) (i.e., \(\text{Embedwire}\) and \(\text{Extractwire}\) are pass-throughs). We call the former "wire-only" schemes and the latter "user-only" schemes. Within these two classes, we further distinguish between schemes where the overt application-channel messages are protected by a secure channel and those where the application channel messages are sent in the clear. Thus, our work explores four classes of ABCCs; see Table I for examples of how prior work maps to these.

In exploring the security of these classes, we identify several crucial non-cryptographic requirements that systems must meet. For example, consider the class of wire-only schemes where the overt application messages are protected by a secure channel. Here, the ABCC must achieve sink-indistinguishability and shape-preservation, two properties we introduce. Informally, sink-indistinguishability means that the observable output of \(\text{Sink}\) should not signal whether it has received messages from \(\text{Source}\) directly or from \(\text{Extractwire}\). Shape-preservation means that the number and length of messages from \(\text{Embedwire}\) and \(\text{Source}\) must not distinguish the two.

Our security notion also explicitly identifies the user-models that drive the covert (ABCC) and overt (application channel) communication, something often left implicit in prior work. Intuitively, if one has collected traffic to characterize "normal" use of an application, there is some implicit "normal user" model (User0) inducing that traffic. Similarly, there is a process (User1) driving the ABCC, which may be an explicit user-model (e.g., as in Castle) or an implicit model of how a human would interact with the system. By elevating the user-model to an explicit parameter of the security experiment, we surface a non-cryptographic requirement for all four classes of ABCC systems: that overt application traffic should not signal whether it is User1 or User0 driving the application. This is somewhat surprising, as it is more intuitive to compare the ABCC traffic induced by User1 to the overt application traffic induced by User0. Nonetheless, our formalization shows that a more constrained notion of "user indistinguishability" suffices for the constructions considered in this work.

### Benefits of Surfacing Non-Cryptographic Properties

One might reasonably wonder about the benefit of surfacing non-cryptographic properties. After all, these cannot be cryptanalyzed or reduced to some plausible hardness assumption. We believe one important benefit is that it makes explicit the minimal properties a secure ABCC needs to satisfy, even if the cryptographic components are perfect. Our security results point to specific empirical evaluations, a staple of security arguments in the literature. Moreover, by describing these non-cryptographic properties in pseudocode, our abstract experiments are more easily translated into actual experiments for system evaluators. To demonstrate the applicability of this approach, we discuss in §VII-D how two recent systems—Balboa [6] and Protozoa [8]—map to our framework and the necessary empirical analysis our security reductions highlight.

### Scoping and Caveats

While we believe our approach will benefit system developers and enable more principled comparisons of one system to another, it is important to clarify the scope of our framework and security results. We formally analyze abstractions of network-censorship circumvention systems, and our security results for these abstractions do not guarantee the security of a real system in a real deployment. Our abstraction elides the particular implementation details of the application protocol and the specifics of the network over which the application traffic is transmitted. Thus, attacks based on differential timing between ABCC and other factors are not within the scope. Additionally, our security notion considers only passive censors, so active manipulation through traffic modification or injection (e.g., active probing [9]) is not within the notion’s scope.

Among such active attacks, outright blocking of certain application protocols is a tactic commonly observed in real-world environments. Even slight variations in implementation details can enable targeted blocking; for example, Frolov and Wustrow [10] show that systems pinned to a particular application version are vulnerable to blocking when the censor can reliably identify the version. While such application fingerprinting techniques are certainly important to consider in practice, our abstraction starts from the strong assumption that the adversary has perfect knowledge of the application and its implementation.

### Mapping of Existing Covert Channels

Table I maps existing covert channels from the literature to our syntax. MBFTE stands for "model-based format-transforming encryption," RTS stands for "real-time strategy," and FPS stands for "first-person shooter."

| System          | Embedding Style | Secure Channel | Application   |
|-----------------|-----------------|----------------|---------------|
| DeltaShaper [2] | user-only       | ✓              | Skype         |
| Castle [1]      | user-only       | ✓              | RTS           |
| MBFTE [7]       | user-only       | ✗              | multiple      |
| Protozoa [5]    | user-only       | ✓              | browser (WebRTC) |
| Balboa [6]      | wire-only       | ✓              | audio streaming, web browsing |
| Rook [4]        | wire-only       | ✗              | FPS           |

1. The authors demonstrate Balboa for audio streaming and web browsing [6].

### Conclusion

In summary, this work provides a formal foundation for the design and analysis of ABCCs, including a definition of ABCCs as a syntactic primitive and a security notion that captures the adversarial goals and attack models. We explore four classes of ABCCs and identify non-cryptographic requirements that systems must meet. By surfacing these properties, we aim to make the minimal requirements for secure ABCCs explicit and facilitate more principled comparisons and evaluations of ABCC systems.