—_slab_free(s,page,x,addr,c->offset);
[6]
local_irq_restore(flags);
在前面的代码中，kmem_cache_freeO）和kmem_free（）使用virt_to_head_page（[1]
[3]来获取要释放对象所在的slab的相关页结构。长话短说，如果这个地址不在内核态将会发
生错误，这正是如果我们使用用户态的假对象的问题。而且，kfree（）将做一个额外的检查[2]
来查看页是否真的是一个slab页，如果不是那样的，那么情况将会变得很糟糕。为完整起见，
这段代码也显示了释放快速路径，由slab_free（）实现。释放操作非常简单：保存[4]当前
freelist值到返回对象的开始并保存[5]对象地址到freelist（LIFO原则）。如果不能命中快速
路径（若对象与当前活动的对象在不同的slab），则使用_slab_free（）的慢路径，这最终也
能完成相同的任务，但还需要处理额外的东西，比如重插入一个当前的部分slab到部分slab列
表中。
kfreeO（或者kmem_cache_freeO）的指针。换句话说，我们可以设计一个可加载的内核模块
（LoadableKernelModule，LKM）来加载后攻击，它可以：
1）使用假对象地址来找到内存中存放它的变量。
2）从同一个一般或特殊目的缓存中分配一个新的对象。
3）复制旧的假对象的内容到新分配的对象中。
4）用新地址更新追踪对象地址的变量的值。
此时，我们只需要触发该对象的释放执行路径（无论是从LKM还是从用户域中），恢复环
境的工作就完成了。要实现这一目标，仍然需要使用伪造对象的内核执行路径：
·保证对象存在足够的时间以便我们加载用以恢复环境的LKM。许多内核执行路径在运行
·在我们试图恢复环境的时候，已经释放了存在于该对象中的所有同步锁。
·把对象指针保存在一个全局的链表或者类似的数据结构中。这一点并不是强制的（LKM
很明显能够访问到所有的内核内存数据），但是这样做会让我们的工作更方便。
上面的第一项和第二项才是重点。特别的，如果第一项不满足，我们就需要在payload中
实现所有的恢复现场逻辑。这或多或少会给我们带来麻烦（取决于我们所涉及结构的复杂程
度），我们需要许多内核符号（kernelsymbol）来完成这一工作。类似的原则也适用于锁，可以
重建和模拟锁来绕过锁定的临界区。同样，加锁机制的复杂程度也会或多或少地给我们编写环
境恢复代码带来麻烦。
kmem_cache_free（）忽略了一个具有争议的最优选择检查。slab缓存所属的对象将传递给kmem_
cache_free（）作为参数，所以没有必要从它的页结构获取（page->slab）。
---
## Page 147
138第二部分UNIX家族、MacOSX和Windows
时，我们能做什么？
使局部覆盖成功：set_selection（）案例
我们说set_selectionO）问题是一个很有挑战的问题，它是一个内核堆中的off-by-two
溢出漏洞。利用这个漏洞的过程十分复杂，更多深度讨论可以参考www.attackingthecore.com
网站。在本节中，我们只介绍其中的关键部分，以便作为背景知识供读者完整理解代码。这样
做，我们主要的注意力将放在那些可以重用的漏洞利用代码上，因此本节和本章的其他节相比
可能会更偏重理论。
首先，让我们再看一下selection的缓冲区是如何填充的：
bp=kma1loc（(se1_end-se1_start)/2*multip1ier+l,GFP_KERNEL):
[]
*用新的数据填充缓冲区.*
for（i=sel_start;i42/2*3+1=64
128字节缓冲区：（128-1)*2/3=84=>84/2*3+1=127
那么通过选择缓冲区的大小，我们能够控制缓冲区溢出1或者2字节（按照我们的意愿）。
我们下面将会看到，用1字节溢出更加可靠。我们选择的目标是128字节的缓冲区大小。
之所以说1字节溢出更加可靠，原因在于x86架构在保存数据时是数字的低位组放在前面
并且slab页是与页边界对齐的结构（0x1000）。保存数据时数字的低位放在前面意味着我们面
对off-by-n溢出问题时，我们能够破坏一个指向下一个空闲对象地址的n个最低有效字节。在
---
## Page 148
第4章UNIX家族139
面对一个off-by-one的溢出问题时，我们基本上可以修改它最后的8个位，这意味着我们能够
让指针指向其原地址上下255字节范围的任意位置，而对于off-by-two，我们可以修改最后的
16个位，这意味着我们能够让指针指向原地址上下的65565字节范围的任意位置。很明显这两
种都不能让指针寻址到用户域的内存，所以就能否让指针寻址到用户域内存而言，修改16位
（2字节）内存数据并没有比修改8位（一个字节）带来更多便利。
而页面边界对齐则意味着我们能够预测slab页中对象地址的最后12位。我们已经知道，
在一个新分配的slab页中对象是一个挨一个紧凑排列的。基本上，对于每一个分配的对象（地
址），我们能知道最后12位的值，然后通过修改已知的8位数据的值，我们能够控制下一空闲
对象的地址并且让它指向所处slab的任意位置。通过这种方法，我们最终破坏了slab页的对齐
结构。如图4.7所示。
空闲列表
空闲
空闲
已分配
空闲
已分配
已分配
对象
对象
对象
对象
对象
对象
丰
空闲列表
空闲
已
空闲
空闲
对象
分配
空闲
已分配
已分配
对象
对象
对象
对象
对象
对象
用户域
空闲
对象
指向下一个空闲
对象的元数据
重写指向下一个
丰
空闲对象的数据
图4.7溢出并修改指向下一个空闲对象指针最低有效字节的数据来破坏slab的对齐结构
如图4-7所示，我们能够在slab中创建出一个“伪造对象”（fakeobject），伪造对象地址
空间跨越了两个对象的地址，并且由这两个对象的内存组成。我们称这种伪造对象为“in-slab
伪造对象”。有趣的是，一旦为这个伪造对象分配空间，分配器会把指向空闲对象列表的指针
指向对象头部所指的内容，而无论这个内容指向的是什么地方。如果我们能够控制伪造对象的
slab的内容（从根本上说，只要我们能够对潜在的对象有所控制），那么我们现在已经创造了条
---
## Page 149
140第二部分UNIX家族、MacOSX和Windows
件来应用我们之前已经学到的所有东西。
在我们试图控制slab内存空间时，slab对象的另外一项属性能够帮助我们实现。在空闲状
态下，除非明确调用kzfree（），否则不会清理对象内存空间中的内容。换句话说，如果我们
分配一个128字节的缓冲区用来存储一些IOCTL数据，并且这个对象在使用后立即释放，那么
那个死堆将仍然保持它的内容，直到一个新的已分配缓冲区重写到该位置。例如，在前面引用
在控制slab页内容的同时，我们也需要控制slab页的布局。我们通过申请足够数量的占位
对象（placeholderobject）来占满整个slab页。为此我们需要借助sctp_ssnmap结构。
structsctp_stream
u16*ssn;
unsignedintlen:
structsctp_ssnmap
structsctp_streamin:
struct sctp_streamout;
intmalloced;
1：
sctp_ssnmap结构中有两个sctp_stream结构的对象，sctp_stream中包含一个指向短
整数的指针。该指针保存在结构的头部并且在每次接受（对于in结构），或者发送数据（对于
out结构）之后就会增加。这简直就是为我们量身定做的，因为在一次受控的溢出过程中，不
会重写该结构中的其他成员，因而我们也不必理会仿真。
sctp_ssnmap结构的大小是在运行时决定的，因为in和out对象是指向内容长度可变的指
针。大小是通过sctp_ssnmap_size（）来计算的，函数定义可以在/net/sctp/ssnmap.c中找到。
staticinlinesize_tsctp_ssnmap_size（ul6in,-ul6out）
returnsizeof（structsctp_ssnmap)+（in+out)*sizeof（ul6);
我们将在第8章讨论SCTP实现的细节，届时也会讨论利用SCTP子系统进行远程的
Linux内核漏洞利用。因此在这里我们没有讨论细节。到目前为止，我们所关注的事情就是让
项比较简单的工作（好比设置一个套接字属性），就如下面这个辅助漏洞利用函数所示：
staticvoidset_sctp_sock_opt（intfd,-u16in.-_u16out）
structsctp_initmsg msg:
intval=1:
socklen_tlen_sctp=sizeof（structsctp_initmsg):
getsockopt（fd,SOL_SCTP,SCTP_INITMSG,&msg.&1en_sctp);
msg.sinit_num_ostreams=out;
[1]
msg.sinit_max_instreams-in;
[2]
setsockopt(fd,SOL_SCTP,SCTP_INITMSG,&msg.1en_sCtp);
---
## Page 150
第4章UNIX家族141
setsockopt（fd.SOL_SCTP,SCTP_NODELAY.（char*)&val,sizeof（va1)):
我们能够按需要创建足够多的sctp_ssnmap结构体，只需要创建一个本地处于监听状态的
SCTP（StreamControlTransmissionProtocol，流控制传输协议）服务器并且一个接一个地打开
连接到服务器的SCTP链接。好消息是，我们并不需要多少特殊的权限就能做到这件事。我们
基本上通过这样的手法就能够耗尽系统中的任何通用缓存，这种结构体简直就是绝佳的、天生
的占位对象。这样，基于Linux内核的堆内存漏洞利用基本上就完成了50%。您可能会感到
惊奇，但事实就是如此。
好吧，现在让我们继续刚才的话题，看看漏洞利用应该如何设计。
对象的大小，当然也就知道了占位对象的大小（128字节）。
这就意味着我们可以持续地创建SCTP链接，直到完全占满当前的slab页的空间，这时
一个新的slab创建了（我们可以通过监测/proc/slabinfo来监测这一点）。
·此时我们已经具备了应用in-slab重定向技术的先决条件，接下来我们要做的就是：
O再分配一些SCTPssnmap对象。
O在恰当的偏移地址填充这些对象的内容，它们将成为“下一个空闲对象”的伪造对象
中的内容。
O引发这个漏洞，覆盖掉受害对象的指向下一个空闲物体的指针。
0分配3个新的对象。
·第一次分配使得受害对象中已经修改的指针指向下一个可用对象的地址。这个地址指向
slab中的伪造对象（从根本上说，通过这一步我们就破坏了slab的对齐结构）。
·第二次分配使得指向下一个可用对象的指针指向我们在slab页中构建的伪造对象。这个
·第三次分配返回一个位于用户域的对象到内核执行路径。
·此时，我们已经拥有一个用户域的伪造对象，此对象完全在我们的控制之下。通过SCTP的执
行路径，我们驾驭了这个对象的分配，因此我们拥有了一个在控制之下的sctp_ssnmap结构。
·我们把SCTPstream结构的指针ssn指向内存中一些敏感的内核结构。理想状况下，我
们希望它指向一个等于NULL的结构成员。在漏洞利用例子中，我们以timer_1ist
fops结构为目标，劫持未使用的ioctlO）系统调用。timer_list_fops结构的地址可
在tiod_houdini.c代码中，这主要是由start_listener（服务器部分）、create_ancl_initO和connect_peer（客户
端部分）三个函数来实现的。
---
## Page 151
142第二部分UNIX家族、MacOSX和Windows
以从/proc/kallsyms中得到。
·每次通过SCTP通道发送一个数据包，对应的SCTPstream结构的ssn值就增加1。通过
一个单一的数据包我们就能够把未使用的、值为NULL的ioct1（）指针指向地址0x1。
这样的值能够通过经典的检查op！=NULL，该检查常用于检测操作是否已实现。
·执行内核路径以解引l用已经更改过的ioct1）文件操作指针。控制将转到地址0x1，这
是一个我们能够轻易映射到用户域的地址。如果遇到一些保护措施阻止映射低地址，我
们有两个选择：
0可以简单地发送更多的数据包，让地址继续增加直到越过保护限制区域。
O可以让指针指向ioct1O）中NULL指针（0x00000000）内存地址中的第一个0x00处，
此时我们发送一个数据包，那么地址将会变为0x01000000。
警告现在编译器开始把文件操作符和其他类似的关键数据结构放在.rodata段（即
内核的只读区域），以防止攻击者轻易地覆盖它们。当进行漏洞利用开发时，timer_
list_fops仍然是一个好的方向，但是事情往往随着时间改变。在您试图应用（本书）
中的这些东西在您的攻击代码中时，请记得先查看一下结构是否已经定义为常量了。
虽然读者可能不愿相信，但之前提到的漏洞利用步骤实际上是一个相当概括的描述。我们
避免使用成篇累读的代码（通常也是最难弄明白的），set_selection（）漏洞的利用代码在这
里并没有展示，您能够在网上得到它们，网址是www.attackingthecore.com，并且该网站有大量
的注释（基本上每个方法都有注释）。希望我们之前的描述配合这些代码中的注释能够让读者
的（同样的，这个LKM也能在www.attackingthecore.com找到并且配有大量的注释），这个可
加载内核模块主要负责漏洞利用之后的清理工作。
Linux的栈溢出利用
我们在第2章和第3章已经讨论过，内核态的栈和用户态相比并没有太大的区别，而且与