page and allow the user to install an application.
The following is an example of an intent filter within the manifest of a rogue drozer agent's (discussed later)
that allows an activity to be invoked from a browser:
This manifest declaration shows that any web browser that tries to load a URI starting with pwn:// will open
this activity. In the past you could start an application with a BROWSABLE activity by loading an iframe that loads
from the custom scheme. However, launching via an iframe is no longer possible in versions of Chromium
including 25 and later, and so the URI needs to be visited directly by the user or by redirecting through
JavaScript. It now requires invocation that directs the user to the exact resource. If this resource does not exist
on the device, the web page will no longer stay functioning because the browser will throw an invalid URI error.
The later section “BROWSABLE URI Injection” covers the exploitation of BROWSABLE activities.
BROWSABLE activities can also be invoked by making use of an experimental specification supported by Chrome
called web intents. These allow the invocation of BROWSABLE activities in a structured and more useful manner.
This access is achieved through a URI starting with intent:// that supports the use of more attributes of an
Intent object as well as extras. The two ways to invoke the drozer activity are using its defined scheme directly
and using a web intent:
Start drozer - technique 1
Start
Drozer - technique 2
To find more information about the web intents project and the available parameters go to
https://developer.chrome.com/multidevice/android/intents. The implementation of web intents was
attacked at Mobile Pwn2Own 2013 (see http://www.pwn2own.com/2013/11/local-japanese-team-exploits-
mobile-applications-install-malware-samsung-galaxy-s4/). The same team that performed this exploit
created an interesting analysis of the implementation of web intents in different browsers at
http://www.mbsd.jp/Whitepaper/IntentScheme.pdf. Some browsers, such as Chrome, limit the invocation of
activities to only ones that are BROWSABLE and do not allow the component to be explicitly set. However, other
browsers do not enforce this and any activity can be opened with the given intent. You can read about a
technique involving intent selectors to bypass even this restriction in Chrome at http://developer
.android.com/reference/android/content/Intent.html#setSelector(android .content.Intent). This opens a
huge attack vector for finding activities that perform tasks automatically in their onCreate() method using the
supplied bundle. Assuming that all browsers fix the ability to invoke arbitrary activities and only allow
BROWSABLE activities, a significant attack vectors still exists.
A drozer module at scanner.activity.browsable is available to find all BROWSABLE activities on a device. Running
it on a Samsung Galaxy S5 reveals the following snipped output:
dz> run scanner.activity.browsable
...
Package: com.sec.android.app.shealth
Invocable URIs:
shealth://
com.sec.android.app.shealth.sleepmonitor://main
Classes:
com.sec.android.app.shealth.SplashScreenActivity
com.sec.android.app.shealth.sleepmonitor.SleepMonitorActivity_Base
...
Package: com.vodafone.cloud
Invocable URIs:
intent://
http://vodafone.com/cloud (PATTERN_LITERAL)
Classes:
com.newbay.syncdrive.android.ui.gui.activities.SplashLogoActivity
Package: com.sec.android.cloudagent
Invocable URIs:
db-qp95n66cz21kx96://
Classes:
com.dropbox.client2.android.AuthActivity
Package: com.sec.android.app.voicenote
Invocable URIs:
sherif-activity://nuanceinfo
Classes:
com.sec.android.app.voicenote.library.subactivity
.VNPolicyInfoActivity
...
Package: com.samsung.groupcast
Invocable URIs:
groupplay://
http://gp.samsung.com
https://gp.samsung.com
Classes:
com.samsung.groupcast.application.start.StartActivity
...
Package: com.sec.enterprise.knox.cloudmdm.smdms
Invocable URIs:
smdm://
Classes:
.ui.LaunchActivity
...
Package: com.osp.app.signin
Invocable URIs:
samsungaccount://MainPage
Classes:
.AccountView
Package: com.sec.android.app.billing
Invocable URIs:
APKUPReadersHub://
APKUPLearningHub://
APKUPMediaHub://
APKUPVideoHub://
APKUPMusicHub://
APKUPSamsungCloud://
APKUPSamsungApps://
Classes:
com.sec.android.app.billing.UnifiedPaymentPGActivity
...
All the activities shown can be invoked from the web browser by an arbitrary website. This shows a clear set of
possible attack vectors that someone looking to find vulnerabilities in this device could explore. In fact, later in
this chapter in the section “BROWSABLE URI Injection” we explore a vulnerability in the activity that handles
the smdm:// URI scheme.
Custom Update Mechanisms
Applications that hold the INSTALL_PACKAGES permission are immediately a high-value target and should be
investigated. These applications often handle their own updates rather than doing so through the Play Store.
The developers at device manufacturers may feel that it is a hassle for users to go to the Play Store or simply feel
that custom update mechanisms are easier to manage from their side. Whatever the reasons, these applications
can contain vulnerabilities that allow for the arbitrary installation of packages. Thoroughly investigate code that
installs a new package to see whether an external entry point into this code exists that can be abused.
Often when these applications start, they check to see whether an update is available on some remote web
server. If there is, the APK is downloaded and installed. The communication channel used for this download is a
crucial aspect of security for this application. If it is downloading the new APK in clear text, or the SSL certificate
is not properly validated, an attacker could perform a man-in-the-middle attack to replace this APK file in
transit. It is unlikely that an attacker would target an individual on a wireless network and wait for him or her to
open a vulnerable application. However, doing this at an airport or busy wireless hotspot on a larger scale may
prove fruitful.
Remote Loading of Code
Android allows applications to load new code at runtime using the Java Reflection API. Loading entirely new
classes or instantiating new objects and interacting with them is possible. This is the technique drozer uses for
interactions between the console and the agent.
If application developers use these mechanisms, they should be aware of where they are loading new code from.
Loading new code from remote sources over a channel that is not secured is a recipe for enabling remote code
execution.
Usually, developers use the DexClassLoader class to load new code into their application. The constructor of this
class looks like this:
DexClassLoader (String dexPath, String dexOutputDir, String libPath,
ClassLoader parent)
Another problem that is considered a local vulnerability is loading classes specified by the dexPath from a
location on the device that can be overwritten by other applications. Additionally, dexOutputDir is a location
specified by the developer where the ODEX file must be placed. If this ODEX is replaced with a malicious
version, then when the code is loaded again, the attacker's code will also be loaded. If another vector exists to
replace ODEX files that are loaded by an application, and the application can be invoked (for example, through
web intents from the web browser), then executing code remotely could be possible.
WebViews
Chapter 7 looked at issues that can affect WebViews and came to the conclusion that the worst mistake a
developer can make is loading content over HTTP inside a WebView. The following combination is a recipe for
disaster and would allow the application to be exploited for code execution on the device using CVE-2012-6636:
Using a WebView
Defining a JavaScript interface
Loading from a cleartext source or having SSL bypass code
Targeting API versions prior to 17 or using an Android version earlier than 4.2
This combination is the foundation of two of the attacks presented later in this chapter. A warning sign for a
possibly exploitable chain of vulnerabilities on a device that is implementing a custom app store is when it
makes use of a WebView. If at any point you are able to inject your own JavaScript into this WebView, you will
likely be able to invoke the installation functionality and install an arbitrary package.
Listening Services
If you perform a port scan of an Android device, you are unlikely to find any listening ports. If you do, these
would have to be mapped to the application that owns it in order to interrogate the section of code handling the
networking. To find any listening TCP ports on a device that you have connected to your computer, perform the
following command:
$ adb shell netstat -antp | grep LISTEN
For instance, when you use the embedded server from within drozer, the output looks as follows:
$ adb shell netstat -antp | grep LISTEN
tcp6 0 0 :::31415 :::* LISTEN
Finding a listening port on a device is the least likely scenario, but a listening service may be invoked through
another vulnerability. The creation of listening ports on the device also becomes more likely when the user uses
functionality like Android Beam, S-Beam, Bluetooth, or any other Personal Area Network (PAN). When a PAN is
initiated between two devices listening services are commonly started so communications can take place over
the link. Messaging Applications Any application that handles data from external sources is a possible entry
point for attack. The following are some examples of messaging functionality that could be prone to attack:
Short Message Service (SMS)
Multimedia Messaging Service (MMS)
Commercial Mobile Alert System (CMAS)
Email clients
Chat clients
Applications that handle incoming SMS, MMS, or CMAS could contain elements that are performed in native
code (such as parsing of emoticons) or handled by a third-party application. Messages would have to be traced
from their entry point in code through all possible routes in the code. This would likely be an unfruitful task.
However, over the years people have found vulnerabilities in the oldest, most trusted code in existence. So
vulnerabilities could still be uncovered in this functionality on Android.
Third-party email and chat clients would be more likely sources of vulnerabilities. Decompiling these
applications and performing a full review on them as per Chapter 7 could yield many possible vulnerabilities in
these applications. One attack vector that comes to mind is if an email or chat client were loading received
messages in a WebView. This would certainly be interesting behavior and could mean that the application is
prone to attack via a JavaScript injection or misconfigured attributes in the WebView.
Finding Local Vulnerabilities
Chapter 7 explored the many different types of vulnerabilities that can be present inside an Android application.
Finding vulnerabilities in applications on a device is no different. However, to be time efficient a faster
automated approach must be adopted instead of manual review.
A good first step is to download all installed applications on the device and convert them to readable source
code. You can do this using the decompilation techniques discussed in Chapter 6 in the “Reverse Engineering
Applications” section. You could then do simple searches using grep to identify some low-hanging fruit. What
you determine as low-hanging fruit would differ according to your experience in assessing devices. However,
prioritizing the search for vulnerabilities in a calculated way would be wise.
The scanner modules present in drozer can help you identify issues with very little effort. These modules are
designed to be performed on a whole device's worth of applications at one time to look for a particular issue. For
example, using the scanner.provider.injection module to look for SQL injection in all content providers on a
Nexus 7 tablet reveals the following:
dz> run scanner.provider.injection
Scanning com.android.backupconfirm...
Scanning com.android.packageinstaller...
Scanning com.android.providers.userdictionary...
Scanning com.android.providers.downloads.ui...
...
Not Vulnerable:
content://com.android.gmail.ui/
content://com.google.android.libraries.social.stream.content
.StreamUris/activity_view/activity
content://subscribedfeeds/deleted_feeds
...
Injection in Projection:
content://settings/system/notification_sound
content://settings/system/ringtone
content://settings/gservices
content://settings/system/notification_sound/
content://settings/gservices/
content://com.google.settings/partner/
content://settings/system/alarm_alert/
content://com.google.settings/partner
content://settings/system/ringtone/
content://settings/system/alarm_alert
Injection in Selection:
content://com.android.bluetooth.opp/live_folders/received
content://settings/gservices
content://settings/gservices/
content://com.google.settings/partner/
content://com.google.settings/partner
content://com.android.bluetooth.opp/live_folders/received/
These injection points provide no significant advantage to an attacker but are enough to convey the scale of
searches that a scanner module can perform to find vulnerabilities.
Exploiting Devices
It should be abundantly clear that many classes of vulnerabilities can be discovered and exploited on an Android
device. Vulnerabilities can be classed into two generic classes: remote and local.
Typically, a remote exploit allows an attacker to gain a foothold on the target device. Access can occur through a
multitude of attack vectors such as software exploits, man-in-the-middle attacks, or malware. Attacks can come
from any of the inputs into a device, which is an ever-growing number of technologies. Standard wireless
functionality on devices includes cellular services, Wi-Fi, NFC (Near Field Communication), and Bluetooth.
These are all valid attack paths for an attacker to pursue for exploitation. A local exploit is one that requires a
foothold on the device already. Exploits of this type could attempt to escalate the privileges of the malicious
code or perform an action on an application that was not intended.
Using Attack Tools
This section discusses some attack tools that will be useful background knowledge for the rest of the chapter.
These tools and their functionality will be the equivalent of a surgeon's scalpel for finding routes an attacker
might take to compromise a device.
Ettercap
Ettercap is the de facto standard for performing man-in-the-middle attacks on a network. It includes tools for
performing ARP poisoning, DNS spoofing, and many other techniques that allow you to control your victim's
traffic on the same network. The project page is at http://ettercap.github.io/ettercap/. To install it from the
repositories in Ubuntu you can use the following command:
$ sudo apt-get install ettercap-graphical
However, the repositories often lag behind the latest version. We recommend that you compile the latest
version available on the project page from source. After downloading the tarball, install the required
dependencies per the documentation. Then, untar the source directory and perform the compilation of Ettercap:
$ cd ettercap-0.8.1
$ mkdir build
$ cd build
$ cmake ..
-- The C compiler identification is GNU 4.8.2
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check if the system is big endian
-- Searching 16 bit integer
-- Looking for sys/types.h
-- Looking for sys/types.h - found
-- Looking for stdint.h
...
-- Looking for strndup - found
-- Found LIBNET: /usr/lib/x86_64-linux-gnu/libnet.so
-- Found PCRE: /usr/lib/x86_64-linux-gnu/libpcre.so
-- Performing Test HAVE_MUTEX_RECURSIVE_NP
-- Performing Test HAVE_MUTEX_RECURSIVE_NP - Success
-- Found BISON: /usr/bin/bison (found version "3.0.2")
-- Found FLEX: /usr/bin/flex (found version "2.5.35")
-- Configuring done
-- Generating done
-- Build files have been written to: /home/tyrone/ettercap-0.8.1/build