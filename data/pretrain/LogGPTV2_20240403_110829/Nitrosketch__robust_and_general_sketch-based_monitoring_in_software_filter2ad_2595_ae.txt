OVS-DPDK suffer from significant throughput degradation. Among
the four sketches, UnivMon achieves 2.1Gbps and the faster Count-
Min only reaches 5.5Gbps. With NitroSketch, all sketches achieve
10G and 40G line rates under CAIDA and datacenter traces, without
adding an extra thread. We observe that inside this vswitchd thread,
342
SIGCOMM ’19, August 19–23, 2019, Beijing, China
Z. Liu et al.
Figure 8: Throughput (left y-axis) and packet rates (right y-axis) on OVS-DPDK, VPP, and BESS. In (a), OVS-DPDK uses single-
thread inline version while in (b) and (c) use a single-thread NitroSketch and another two threads for the switches.
Figure 9: (a) Throughput vs. memory for varying error targets.
(b) Throughput with different NitroSketch components applied
(Setting: one vswitchd thread with 40GbE NIC).
DPDK, OVS, and NitroSketch modules use all the potential of a
single core.
Throughput with separate-thread. Figures 8(b,c) show the through-
put of the separate-thread version. It is already difficult for virtual
switches to achieve 10G line-rate on a single core with 64B packets.
For 40G, even vanilla DPDK does not reach the line rate with 64B
packets due to the hardware limitation in Intel XL710 NIC [29].
This means that OVS-DPDK, VPP, and BESS cannot reach this
line rate under 64B packet traces. In Figure 8(b), we see that NitroS-
ketch has a negligible throughput impact on the virtual switches.
That is, it achieves 20Gbps+ line rate under any workload. As is
evident from Figure 8(b) and (c), NitroSketch is not the bottleneck
in achieving 40G line rates for 64B packets and for data center
workloads.
Throughput vs. Memory. To guarantee an error budget ϵ (for any
distribution), the sampling probability p in the pre-processing stage
depends on the amount of allocated memory. To illustrate this trade-
off, we set error guarantees 3% and 5% for UnivMon with NitroS-
ketch. Figure 9(a) shows that NitroSketch copes with 40G OVS-
DPDK with an acceptable increase in memory.
Improvement breakdown. While implementing NitroSketch, we
used multiple optimization techniques. Therefore, we evaluate the
gains of each optimization separately for UnivMon with NitroSketch.
Figure 9(b) confirms that the counter array sampling technique offers
the most significant speedup.
Throughput with AlwaysCorrect NitroSketch. To evaluate the
convergence time in this mode, we implement AlwaysCorrect Ni-
troSketch with Count-Sketch and UnivMon in OVS-DPDK with the
AIO version. In Figure 11(c), we report the measured throughput
every 0.1sec (extra measurement overhead added) under 40GbE. We
see that it needs about 0.6s for Count-Sketch and 0.8s for UnivMon
to reach full speed.
Figure 10: CPU usage of the all-in-one version (NitroSketch-
AIO) and the separate-thread version (NitroSketch-ST).
7.2 CPU Utilization
A single DPDK PMD thread is continuously polling packets from
NIC. It “saturates” a core and utilizes 100% CPU reported from a
universal process viewer (e.g., htop). Therefore, we profile the CPU
time of each module.
CPU Time in all-in-one. We measure the CPU time in the same
setting as in Figure 8(a). As shown in Figure 10(a), when vanilla
sketches are running, most of the CPU time is spent on sketching, and
the overall switching performance drops. After applying NitroSketch-
AIO, the switch achieves line-rate while keeping the NitroSketch’s
CPU < 20%.
CPU Time in separate-thread. Figure 10(b) compares the CPU
time between OVS-DPDK and NitroSketch-Separate Thread, in a
setting as in Figure 8(b). When the switch is saturated with min-
sized packets (∼22Mpps), the cores for packet switching are running
at nearly 100% while NitroSketch is not running at full-speed and
would handle higher packet rates, if the virtual switch supports.
7.3 Accuracy and Convergence Time
We evaluate the accuracy of UnivMon, CMS, Count Sketch and
K-ary in NitroSketch with different sized epochs and report in Fig-
ures 11 and 12. Our experiments show that NitroSketch converges
to similar accurate results as vanilla sketches after receiving enough
packets. As depicted in Figure 11(a) and (b), with fixed 0.1 and 0.01
sampling rates, NitroSketch with UnivMon can achieve a similar ac-
curacy as the vanilla UnivMon after receiving 8M packets. As shown
in Figure 12(a) and (b), tested sketches with NitroSketch can achieve
better-than-guaranteed results (< 5% error) after seeing 2-4M pack-
ets and converge to similar accuracy after receiving 8-16M packets.
An interesting finding here is that Count-Min Sketch achieves better-
than-original results when NitroSketch is enabled and converged. We
believe this is because Count-Min Sketch overestimates the counts
(i.e., always +1) and produced “biased” estimates and NitroSketch’s
343
UnivMonCMCSK-ary(a) 40GbE AIO version with CAIDA trace.02040Throughput (Gbps)OVS-DPDK(40G)OriginialNitroSketch w/OVS0246.5Packet Rate (Mpps)UnivMonCMCSk-ary(b) 40GbE with 64B packets.010203040Throughput (Gbps)BESS/40GVPP/40GOVS-DPDK/40GOriginalNitroSketch w/OVSNitroSketch w/VPPNitroSketch w/BESS0204060Packet Rate (Mpps)UnivMonCMCSk-ary(c) 40GbE with Datacenter packets.010203040Throughput (Gbps)BESS/40GVPP/40GOVS-DPDK/40GOriginalNitroSketch w/OVSNitroSketch w/VPPNitroSketch w/BESS0.02.55.07.510.0Packet Rate (Mpps)051015Memory Usage (MB) (a)01020Packet Rate (Mpps)OVS-DPDK(40G)Error Target 5%Error Target 3%01234No. of speedup components applied (b)02040Throughput (Gbps)UnivMon+AVX2 Hashing+Counter Array Sampling+Batched Geometric+Reduce Heap UpdateUnivMonCMCSk-ary(a) CPU usage on 10G NIC 050100CPU Usage (%)OVS-DPDKSketchesNitroSketch-AIOUnivMonCMCSk-ary(b) CPU usage on 40G NIC 050100CPU Usage (%)OVS-DPDKNitroSketch-STNitroSketch: Robust and General Sketch-based Monitoring
SIGCOMM ’19, August 19–23, 2019, Beijing, China
Figure 11: (a),(b) Error rates of vanilla UnivMon and NitroSketch with different fixed sampling rates p (0.1 and 0.01) and memory
settings (8MB and 2MB). (c) Throughput over time for AlwaysCorrect NitroSketch with different sketches.
Figure 12: (a),(b) Error rates of vanilla sketches and NitroSketch with different fixed sampling rates p (0.1 and 0.01) and memory
settings (2MB and 200KB). (c) Proven convergence time on CAIDA traces.
Figure 13: (a) Throughput: SketchVisor vs. NitroSketch. (b)
Memory usage: NetFlow vs. NitroSketch.
sampling procedure actually corrects such an overestimation. Fi-
nally, it is worth noting that the error results are collected based
on fixed-rate NitroSketch. When adopting AlwaysLineRate Mode
with adaptive sampling rates on real-world traffic, NitroSketch will
achieve better accuracy and faster convergence.
Since NitroSketch uses sampling to select packets, it requires a
convergence time to produce a guaranteed accurate result (analyzed
in section 5). For different error targets on CAIDA traces, we study
the trade-off between geo-sampling rate p and the convergence time
(in terms of the number of packets) and report in Figure 12(c).
Further, NitroSketch is expected to converge faster on data center
traffic due to their more skewed workload and expected larger L2
value establishment.
7.4 Comparison with Other Solutions
SketchVisor accelerates sketches using a fast path algorithm in
its front-end. Since the source code of SketchVisor [43] on Open
vSwitch is not publicly available we implement its fast-path algo-
rithm in C and carefully integrate it with UnivMon on OVS-DPDK
using the same FIFO buffer as NitroSketch [16]. SketchVisor’s per-
formance depends on the portion of the traffic that is processed by
the fast path. Thus we evaluate the throughput based on in-memory
testing with manually injecting 20%, 50%, 100% of traffic into the fast
path. We allocate memory for SketchVisor and NitroSketch to detect
top 100 HHs, we use 900 counters for the fast-path and set a 5% error
guarantee on UnivMon.
As reported in Figure 13(a), the throughput of SketchVisor im-
proves when the percentage of traffic handled by the fast-path in-
creases. When the fast-path processes 20% of the traffic, it achieves
2.12Mpps. SketchVisor reaches its maximum packet rate of 6.11Mpps
when 100% traffic goes into the fast-path. Meanwhile, NitroSketch
runs at a dramatically faster speed of 83Mpps. Unsurprisingly, this
explains the situation that SketchVisor uses 100% CPU (not shown in
the figure) while NitroSketch requires less than 50% (shown in Fig-
ure 10(b)) when running in a separate thread on OVS-DPDK.
We observe that to cope with the full 10G speed and avoid packet
drops, the fast-path has to handle 100% of the packets. For a fair
comparison on OVS, we prevent packet drop by using a very large
344
0%5%10%15%HH (UnivMon)NitroSketch w/0.01NitroSketch w/0.1Vanilla0%5%10%15%Change (UnivMon)1M2M4M8M16M64M256M1BEpoch Size (# of packets) (a) Vanilla UnivMon vs. NitroSketch (8MB).0%5%10%15%Mean Relative ErrorEntropy (UnivMon)0%5%10%15%HH (UnivMon)NitroSketch w/0.01NitroSketch w/0.1Vanilla0%5%10%15%Change (UnivMon)1M2M4M8M16M64M256M1BEpoch Size (# of packets) (b) Vanilla UnivMon vs. NitroSketch (2MB).0%5%10%15%Mean Relative ErrorEntropy (UnivMon)0123Time (s)  (c) AlwayCorrect Mode Throughput010203040Throughput (Gbps)AC-NitroSketch(Count-Sketch)AC-NitroSketch(UnivMon)0%5%10%15%HH (Count-Min)NitroSketch w/0.01NitroSketch w/0.1Vanilla0%5%10%15%HH (Count Sketch)1M2M4M8M16M64M256M1BEpoch Size (# of packets) (a) Vanilla sketches vs. NitroSketch (2MB).0%5%10%15%Mean Relative ErrorChange (k-ary)0%5%10%15%HH (Count-Min)NitroSketch w/0.01NitroSketch w/0.1Vanilla0%5%10%15%HH (Count Sketch)1M2M4M8M16M64M256M1BEpoch Size (# of packets) (b) Vanilla sketches vs. NitroSketch (200KB).0%5%10%15%Mean Relative ErrorChange (k-ary)246810Sampling Rate (%) (c) Guaranteed Convergence Rate1M10M100MConvergence Time (packets)Error Target: 1%Error Target: 3%Error Target: 5%SketchVisorNitroSketch(a) In-memory test with CAIDA traces01020406080Packet Rate (Mpps)Fast-path(20,50,100%)UnivMonsFlowNetFlowNitroSketch (b) Memory consumption on virtual switches050100Memory Usage (MB)OVS-DPDKVPPUnivMonSIGCOMM ’19, August 19–23, 2019, Beijing, China
Z. Liu et al.
Figure 14: HH errors of SketchVisor and NitroSketch, in CAIDA, DDoS, and datacenter traces.
Figure 15: HH recalls of NetFlow with different sampling rates vs. NitroSketch with 0.01, using CAIDA, DDoS, and datacenter traces.
buffer. We manually redirect 20%, 50%, and 100% of the packets to
the fast-path. Figure 14(a), (b) and (c) report relative errors on HH
in the three traces. We can see that NitroSketch has larger errors
before convergence (< 3.61M packets) but is more accurate than
SketchVisor after convergence. In a 10G OVS-DPDK switch, this
stabilization time can be as little as 0.24 seconds. Here, SketchVisor
is inaccurate in the CAIDA and DDoS trace in Figure 14(a) and (b)
and is relatively accurate in the data center trace [11]. In contrast,
NitroSketch achieves good accuracy on all traces.
Comparison with NetFlow/sFlow. On OVS-DPDK and VPP, Net-
Flow/sFlow are default monitoring tools. We configure OVS-DPDK
to enable sFlow and VPP to enable NetFlow. We set a polling inter-
val of 10 seconds with sampling rates of 0.001, 0.002, and 0.01 for
NetFlow. For fairness, we configured NitroSketch with a sampling
probability of 0.01. In practice, it is often unreasonable to configure
NetFlow with higher sampling rates because a large sampling rate
can potentially incur huge memory consumption in high line-rate
switches. On the controller, we collect the sampled packets/reports
with Wireshark [24] directly from the port. Figure 13(b) indicates
that NetFlow consumes much more memory with 0.01 sampling
rate. In NetFlow (as in Figure 15), we observe that the recall rates of
100 HHs are low in the CAIDA and DDoS traces and are relatively
good in the UNI2 datacenter trace [11]. This is because UNI2 is
quite skewed while CAIDA and DDoS are heavy tailed. In contrast,
NitroSketch achieves high recall rates in all cases.
8 CONCLUSIONS AND DISCUSSION
Sketching continues to be a promising direction in network measure-
ment. However, its current performance on software switches is far
from ideal to serve as a viable line-rate and low CPU consumption
option. We identify the key bottlenecks and optimizations for soft-
ware sketches. Our optimization is encapsulated into NitroSketch, an
open source high-performance software sketching framework [32].
NitroSketch supports a variety of measurement tasks and provides
accuracy guarantees. Our evaluation shows that NitroSketch achieves
the line rate using multiple software switches, and offers competitive
accuracy compared to the alternatives.
Interestingly, by replacing each Count Sketch instance in Univ-
Mon with AlwaysCorrect NitroSketch, we get an optimized solution
that can provide a (1 + ϵ)-approximation for measurement tasks
which are known to be infeasible to estimate accurately from a
imated better than a Ω(1/√
uniform sample [60]. Specifically, count distinct cannot be approx-
p) factor while Entropy does not admit
any constant factor approximation even if p = 1/2!
In Appendices, this paper has supporting material that has not
been peer reviewed. Finally, we can state that this work does not
raise any ethical issues.
9 ACKNOWLEDGEMENTS
We would like to thank the anonymous SIGCOMM reviewers and
our shepherd Alex C. Snoeren for their thorough comments and feed-
back that helped improve the paper. We thank Omid Alipourfard,
Sujata Banerjee, Minlan Yu, and Intel SPAN center for their helpful
suggestions. This work was supported in part by CONIX Research
Center, one of six centers in JUMP, a Semiconductor Research Cor-
poration program sponsored by DARPA, NSF grants CNS-1565343,
CNS-1700521, NSF CAREER-1652257, ONR Award N00014-18-1-
2364, Israeli Science Foundation grant 1505/16, the Lifelong Learn-
ing Machines program from DARPA/MTO, the Technion HPI re-
search school, the Zuckerman Foundation, the Technion Hiroshi Fu-
jiwara Cyber Security Research Center, the Israel Cyber Directorate,
the Cyber Security Research Center and the Lynne and William
Frankel Center for Computing Science at Ben-Gurion University.
345
4M16M64M256MCAIDA Epoch (# of Packets) (a)0510Error Rate (%)SketchVisor(100%)SketchVisor(50%)SketchVisor(20%)NitroSketch(UnivMon)4M16M64M256MDDoS Epoch (# of Packets)  (b)0510Error Rate (%)SketchVisor(100%)SketchVisor(50%)SketchVisor(20%)NitroSketch (UnivMon)4M16M64M256MDC Epoch (# of Packets)  (c)0510Error Rate (%)SketchVisor(100%)SketchVisor(50%)SketchVisor(20%)NitroSketch (UnivMon)1M4M16M64M256MCAIDA Epoch (# of packets) (a)050100Recall Rate (%)NitroSketch w/0.01NetFlow w/0.01NetFlow w/0.002NetFlow w/0.0011M4M16M64M256MDDoS Epoch (# of packets) (b)050100Recall Rate (%)NitroSketch w/0.01NetFlow w/0.01NetFlow w/0.002NetFlow w/0.0011M4M16M64M256MDC Epoch (# of packets) (c)050100Recall Rate (%)NitroSketch w/0.01NetFlow w/0.01NetFlow w/0.002NetFlow w/0.001NitroSketch: Robust and General Sketch-based Monitoring
SIGCOMM ’19, August 19–23, 2019, Beijing, China
REFERENCES
[1] Omid Alipourfard, Masoud Moshref, and Minlan Yu. 2015. Re-evaluating Mea-
surement Algorithms in Software. In Proc. of ACM HotNets.
[2] Omid Alipourfard, Masoud Moshref, Yang Zhou, Tong Yang, and Minlan Yu.
2018. A Comparison of Performance and Accuracy of Measurement Algorithms
in Software. In Proc. of ACM SOSR.
[3] Mohammad Alizadeh, Tom Edsall, Sarang Dharmapurikar, Ramanan
Vaidyanathan, Kevin Chu, Andy Fingerhut, Vinh The Lam, Francis Ma-
tus, Rong Pan, Navindra Yadav, and George Varghese. 2014. CONGA: Distributed
Congestion-aware Load Balancing for Datacenters. In Proc. of ACM SIGCOMM.
[4] Mohammad Alizadeh, Shuang Yang, Milad Sharif, Sachin Katti, Nick McKe-
own, Balaji Prabhakar, and Scott Shenker. 2013. pFabric: Minimal Near-optimal
Datacenter Transport. In Proc. of ACM SIGCOMM.
[5] Noga Alon, Yossi Matias, and Mario Szegedy. 1996. The Space Complexity of
Approximating the Frequency Moments. In Proc. of ACM STOC.
[6] Eran Assaf, Ran Ben-Basat, Gil Einziger, and Roy Friedman. 2018. Pay for a
sliding bloom filter and get counting, distinct elements, and entropy for free. In
Proc. of IEEE INFOCOM.
[7] Ziv Bar-Yossef, T. S. Jayram, Ravi Kumar, D. Sivakumar, and Luca Trevisan.
2002. Counting Distinct Elements in a Data Stream. In Proc. of RANDOM.
[8] Ran Ben Basat, Gil Einziger, Roy Friedman, Marcelo Caggiani Luizelli, and Erez
Waisbard. 2017. Constant Time Updates in Hierarchical Heavy Hitters. In Proc.
of ACM SIGCOMM and CoRR/1707.06778.
[9] Ran Ben Basat, Gil Einziger, Roy Friedman, Marcelo Caggiani Luizelli, and
Erez Waisbard. 2018. Volumetric Hierarchical Heavy Hitters. In Proc. of IEEE
MASCOTS.
[10] Ran Ben-Basat, Xiaoqi Chen, Gil Einziger, and Ori Rottenstreich. 2018. Efficient
Measurement on Programmable Switches Using Probabilistic Recirculation. In
Proc. of IEEE ICNP.
[11] Theophilus Benson, Aditya Akella, and David A. Maltz. 2010. Network Traffic
Characteristics of Data Centers in the Wild. In Proc. of ACM IMC.
[12] Theophilus Benson, Ashok Anand, Aditya Akella, and Ming Zhang. 2011. Mi-
croTE: Fine Grained Traffic Engineering for Data Centers. In Proc. of ACM
CoNEXT.
[13] Supratik Bhattacharyya, Andre Madeira, S. Muthukrishnan, and Tao Ye. 2007.
How to Scalably and Accurately Skip Past Streams. In Proc. of IEEE ICDE.
[14] CAIDA. 2016. The CAIDA UCSD Anonymized Internet Traces equinix-chicago.
http://www.caida.org/data/passive/passive_2016_dataset.xml
[15] CAIDA. 2018. The CAIDA UCSD Anonymized Internet Traces equinix-chicago.
http://www.caida.org/data/passive/passive_dataset.xml
[16] Cameron. 2015. Fast Concurrent Queue.
https://github.com/cameron314/
readerwriterqueue
[17] Moses Charikar, Kevin Chen, and Martin Farach-Colton. 2002. Finding Frequent
Items in Data Streams. In Proc. of ICALP.
[18] Xiaoqi Chen, Shir Landau Feibish, Yaron Koral, Jennifer Rexford, and Ori Rotten-
streich. 2018. Catching the Microburst Culprits with Snappy. In Proc. of SelfDN
Workshop.
[19] Xiaoqi Chen, Shir Landau Feibish, Yaron Koral, Jennifer Rexford, Ori Rottenstre-
ich, Steven A. Monetti, and Wang Tzuu-Yi. 2019. Fine-Grained Queue Measure-
ment in the Data Plane. In Proc. of ACM CoNEXT.
[20] Kenjiro Cho. 2017. Recursive Lattice Search: Hierarchical Heavy Hitters Revisited.
In Proc. of ACM IMC.
[21] Cisco. 2012.
Introduction to Cisco IOS NetFlow.
https://www.cisco.
com/c/en/us/products/collateral/ios-nx-os-software/ios-netflow/prod_white_
paper0900aecd80406232.html
[22] Cisco. 2015. Cisco Nexus 1000V Switch.
https://www.cisco.com/c/en/us/
products/switches/nexus-1000v-switch-vmware-vsphere/index.html
[23] Yann Collet. 2016. xxHash Library. http://www.xxhash.com/
[24] Gerald Combs. 1998. Wireshark. https://www.wireshark.org
[25] Graham Cormode and Minos Garofalakis. 2007. Sketching Probabilistic Data
Streams. In Proc. of ACM SIGMOD.
[26] Graham Cormode, Flip Korn, S. Muthukrishnan, and Divesh Srivastava. 2008.
Finding Hierarchical Heavy Hitters in Streaming Data. ACM Trans. Knowl. Discov.
Data (2008).
[27] Graham Cormode and S. Muthukrishnan. 2005. An Improved Data Stream Sum-
mary: The Count-Min Sketch and Its Applications. J. Algorithms (2005).
[28] Andrew R. Curtis, Jeffrey C. Mogul, Jean Tourrilhes, Praveen Yalagandula, Puneet
Sharma, and Sujata Banerjee. 2011. DevoFlow: Scaling Flow Management for
High-performance Networks. In Proc. of ACM SIGCOMM.
[29] Intel Ethernet Networking Division. 2018. Intel Ethernet Controller 710 Series
Datasheet. https://www.intel.com/content/dam/www/public/us/en/documents/
datasheets/xl710-10-40-controller-datasheet.pdf
[30] Rick Durrett. 2010. Probability: Theory and Examples (4th ed.). Cambridge
University Press.