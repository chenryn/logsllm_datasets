the space cost
and the performance overhead of ROPecker. For the security
evaluation, we verify our algorithm with real ROP attacks and
those generated by Q. For the space evaluation, we measure
the disk and memory cost consumed by ROPecker. For the per-
formance evaluation, we use the SPEC CPU2006 benchmark
suite [24], which is processor, memory and compiler stressing,
Bonnie++ [25] which is disk I/O stressing and Apache server
httpd-2.4.6 [26] which is network stressing. The source code
of the SPEC CPU2006 benchmark suite is compiled with
gcc, g++ version 4.6.3 with the default Makeﬁle. We run
our experiments on a system with the conﬁgurations shown
in Table III.
A. Security Evaluation
To verify the strength of ROPecker, we conduct several
tests on two real-world examples and a number of payloads
generated from Q. The experiment results show that ROPecker
can detect all these attacks with zero false negatives.
In the ﬁrst test, we use a small program (demonstrated
in ROPEME [27]) that has a simple stack buffer overﬂow
triggered by a long input parameter. We use ROPEME to
Fig. 4. The length of payload measurement results. The number (0 to 5)
is the gadget chain length. In the major cases (84.37%), there is no gadget
identiﬁed at all.
after one attempt. To decide minrop, we also measured the
ROP payload collected from the real world ROP attacks and
generated by the general-purpose ROP compiler Q [17]. The
shortest aligned gadget chain contains 17 gadgets and the
longest one has 30 gadgets. Based on the above results, we
can safely choose a number from 11 to 16 as the threshold for
major applications. Given a speciﬁc application, we can even
choose a smaller threshold. For instance, the longest gadget
chain in Apache server has only 4 gadgets, so the threshold for
Apache can be 5. In this way, any gadget chain that attempts
to use more than 5 gadgets will be detected.
B. Gadget Length
In our implementation, we assume a gadget contains no
more than 6 instructions. This is true for most of gadgets in
the real-world ROP attacks. However, a smart adversary may
attempt to use long gadgets (with more than 6 instructions) to
bypass our ROP detection. Fortunately, long gadgets usually
introduce more side effects, and hence the adversary has less
opportunity to collect enough suitable long gadgets to form a
valid chain for a meaningful ROP attack. If an adversary has
to use consecutive short gadgets, it is likely to be detected
by ROPecker. However, a smarter adversary may carefully
insert long gadgets into consecutive short gadgets to make the
length of each segmented gadget chain not exceed the gadget-
chain threshold, e.g., use a long gadget for every 10 gadgets.
Counting possible gadgets in a single window transition only,
ROPecker cannot reveal this type of ROP attack.
To mitigate long gadget attacks, we propose a solution
to extend ROPecker. When mixing short gadgets with long
gadgets, the adversary creates many segmented gadget chains
though each of them is shorter than the threshold. If we ac-
cumulate their lengths in several consecutive sliding windows,
the accumulated length may longer than the maximum one
collected from the normal execution ﬂows. We evaluated this
extension in the experiment, where we choose to measure three
consecutive sliding windows and count the total number of
gadgets. According to the measurement results, the minimum
accumulated length of the tested ROP attacks collected from
real world samples and generated by Q is 43, while the
maximum accumulated length of the major tested applications
is 13. The gap still tolerates a certain degree of long-gadget
9
84.37% 12.43% 2.10% 0.49% 0.58% 0.02% 0123450.00%10.00%20.00%30.00%40.00%50.00%60.00%70.00%80.00%90.00%Gadget Chain Length analyze the program and generate usable gadgets. We manually
chain them together to craft an ROP attack that causes the
program to start a shell which can facilitate the following
attacks. We then verify our system with a realistic program: a
Linux Hex-editer (htediter) (2.0.20). The ROP example on the
htediter can be found on the web site [28]. An appropriately
chosen long input can trigger a stack overﬂow. The template
of the ROP payload is also available on the website. We only
replace the gadget pointers according to the complied binary
in our system.
At last, we test ROPecker against the gadget chains gen-
erated by Q. Q uses semantic program veriﬁcation techniques
to identify the functionality of gadgets and generates a valid
ROP payload. Speciﬁcally, we generate the payloads for the
applications under directory /bin/ and /usr/bin/. To avoid
manually exploiting each application, we build a new tool as
a simulator to simulate the application execution environment.
We assume that the adversary has compromised the process
and successfully make the execution ﬂow start from the gadget
chain. Once a gadget
jumps out of the simulated sliding
windows, an algorithm will count the number of gadgets in the
rest of chain. If the number is larger than the threshold, an ROP
attack is identiﬁed. Speciﬁcally, the detection algorithm itself
can successfully detect 100% all the payloads generated from
253 applications under directory /bin and directory /usr/bin/.
B. Space Evaluation
The space cost includes disk and memory costs, which are
mainly from the generated databases. In our experiment, the
databases for all 2393 shared libraries under /lib and /usr/lib
of the Ubuntu Linux 12.04 distribution is about 210M B. On
average, a database is 90KB. For example, the database of
libc-2.15 is 832KB, and the ld-2.15 database is 68KB. Note
that the size of a database is only related to the size of the
original binary ﬁle, rather than the detection parameters (i.e.,
gadget length, gadget chain threshold and sliding window
size). To further reduce the space cost on the disk, the database
can be compressed. The experiment results show that all
databases of shared libraries can be compressed to about
19M B using bzip2. The compression rate reaches up to 91%,
which also indicates that the potential gadgets are sparse in
the binary ﬁles.
At run-time, the databases are dynamically loaded into
memory according to the demands of the monitored processes.
To further reduce memory cost, we allow the loaded databases
to be shared by all processes. For instance, if one process has
loaded the libc database, all other monitored processes can
share it without reloading. Thus, the memory cost of ROPecker
is not large. Even if ROPecker loads all databases of the shared
libraries into memory, the memory cost is still acceptable. The
memory space effects from gadget chain threshold, gadget
length and sliding window size are quite small and limited.
To maintain n sliding windows for a process, ROPecker only
needs an n-length list recording the base addresses of the
code pages within the sliding windows. Due to the smallness
of gadget length and gadget chain threshold, they only need
limited data structures temporal available in the gadget chain
identiﬁcation procedure.
TABLE IV.
THE MICRO-BENCHMARK RESULTS FOR SYSTEM CALL
INTERCEPTION.
open
0.03
Operation
Time (µs)
Operation munmap
Time (µs)
0.04
execve mmap mprotect
close
0.04
0.86
pre-exception
0.05
0.03
post-exception
0.03
0.01
TABLE V.
THE TIME COST IN ROP CHECKING.
Operations
Past Gadget Chain Detection
Future Gadget Chain Detection W/o Emulation
W/ Emulation
Time (µs)
0.07
0.91
2.61
C. Performance Evaluation
In this experiment, we use micro- and macro-benchmark
to evaluate the performance of ROPecker. We also evaluate
its performance impact to the target applications and other
applications in the same platform.
1) Micro-Benchmark: The micro-benchmark is used to e-
valuate the time cost of each operation introduced by ROPeck-
er. The time cost
interception
may affect the performance of other applications, but other
operation costs (e.g., database installation) are conﬁned to the
protected application.
introduced by system call
To measure the time cost on the other applications, we
run ROPecker without any target application. The system call
interception code in the execve needs to check the application
name, while others only check the process ID (PID). The
checking costs are listed in Table IV. The experiment results
show that the time overhead introduced to other applications
is quite small.
We then use the htediter as an example to measure the time
cost of loading the IG database. Note that the time is dependent
on the size of the database. For instance, it takes 283µs to
load the database for libc-2.15 (849.93KB), and 51.07µs for
ld-2.15 (65.55kB). Although the loading is relatively high,
it
is only performed once in the whole life cycle of the
protected application. In addition, the database installations
are mostly done in the application initialization stage, before
the application starts execution. Note that the databases of the
shared libraries will not be re-loaded if they have already been
loaded by other protected applications.
We also measured each step of the ROP checking algorith-
m. As shown in Table V, the performance overhead is quite
low. Note that the total time cost for a particular checking is
not the sum of all these steps. The reason is that some branches
(e.g., the payload checking with emulation) may not be taken
in that round. In fact, payload detection (with emulation) is
rarely performed. In our test cases, the emulation is only
invoked in about 1.7% of all detection invocations.
2) Macro-Benchmark: The macro-benchmark tests the
overall performance impacts of ROPecker on the target appli-
cation and the system. We choose three aspects to evaluate:
CPU computation, disk I/O and network I/O. Considering
accuracy, we set the size of the sliding window always under
the upper bound (20KB). Speciﬁcally, we choose 8KB (2
pages) and 16KB (4 pages) as the size of the sliding window
in our experiments.
10
Na.ve"
Monitor"Window"2"pages"
Sliding"Window"2"pages(cid:1)
Monitor"Window"4"pages"
Sliding"Window"4"pages(cid:1)
Time(s)(cid:1)
1000"
900"
800"
700"
600"
500"
400"
300"
200"
100"
0"
Fig. 5. The SPEC INT2006 Benchmark Results.
SPEC CPU Benchmark. We choose the benchmark tool
SPEC CPU2006 benchmark suite to evaluate the computation
performance. Speciﬁcally, we run the testing suits with and
without ROPecker. The results are illustrated in Figure 5,
which shows that ROPecker only introduces 2.60% perfor-
mance loss on average.
Disk I/O Performance Evaluation. We choose the bench-
mark tool Bonnie++ (version 1.96) to evaluate disk I/O perfor-
mance. The tool sequentially reads/writes data from/to a par-
ticular ﬁle in different ways. The read/write granularity varies
from a character to a block (i.e., 8192 Bytes). Furthermore, we
also test the time cost of the random seeking. Figure 6 shows
the disk I/O measurement results which show the performance
overhead on the disk I/O is quite low, i.e., 1.56% overhead on
average.
Sliding$Window$2$pages(cid:1)
Monitor$Window$2$Pages$$
Sliding$Window$4$pages(cid:1)
Monitor$Window$4$Pages$$
%"of"Na've(cid:1)
100.00%$
80.00%$
60.00%$
40.00%$
20.00%$
0.00%$
that the server running HTTP protocol serves the default work
page (45 bytes) and a 4K bytes web page, respectively. ”HTTP-
S” and ”HTTPS-4k” denote that the server running HTTPS
protocol with a 1024 bit RSA key. The test results indicate
that a larger sliding window achieves better performance, and
the performance overhead on network I/O is acceptable. For
example, the performance overhead is 6.33% when the Apache
server delivers the default 45-byte HTTP web pages, and is
only 0.08% when serving 4K byte HTTP web page. Even in
more computation-bound cases, e.g., HTTPS, the ROPecker
overhead is only 9.72%, when choosing the 4-page sliding
window.
%"of"Na've(cid:1)
100.00%$
80.00%$
60.00%$
40.00%$
20.00%$
0.00%$
Sliding$Window$2$pages(cid:1)
Monitor$Window$2$Pages$
Sliding$Window$4$pages(cid:1)
Monitor$Window$4$Pages$
HTTP$
HTTP-4k$
HTTPS$
HTTPS-4k$
Per$Char$
Block$$
Rewrite$$
Per$Char$
Block$$
Sequen>al$Output$
Sequen>al$Input$
Seeks$
Random$
Fig. 7. The network performance results.
Fig. 6. The disk performance results.
Network I/O Performance Evaluation. We choose the
Apache web server httpd-2.4.6 to evaluate the network I/O.
In our experiments,
two machines are directly connected
through a network cable. The tool ab on the client ma-
chine sends network requests (e.g., ab -n 100000 -c 50
http://192.168.1.11/index.html) to retrieve a web page on the
server running with ROPecker. The Apache web server is
conﬁgured to work in mpm-worker mode. It has one worker
process with 40 threads. Figure 7 shows the experiment results
of multiple test scenarios: “HTTP” and “HTTP-4k” represent
IX. DISCUSSIONS
A. Stack Pivoting Attack
The adversary can launch the stack pivoting attack [29] to
evade ROPecker detection. In this attack, the adversary puts
the payload into another memory region (e.g., a heap buffer or
the global data region), and manipulates the stack pointer to
point to that region. Fortunately, the future payload checking
algorithm is able to defeat such attacks, since ROPecker always
follows the execution ﬂow to identify the potential gadget
chain, without relying on the trustworthiness of the stack
information.
11
B. Gadget Gluing Attack
Our payload detection algorithm is designed based on
the assumption that a gadget does not contain direct branch
instructions, which is also used in the many previous work [7]–
[9], [12], [14], [17]. Therefore, the gadget chain detection stops
when a direct branch instruction is encountered. However, the
ROP attack in theory can foil our detection by constructing
a special gadget which consists of two short code sequences
glued together by a direct branch instruction. We call this type
of attack as Gadget Gluing Attack, which has not been found
in real-life to the best of our knowledge.
Gadget gluing attacks are very powerful, as they lead to
high ambiguousness between ROP attacks and normal execu-
tions. The current version of ROPecker can not well defend
against them. To mitigate such attacks, in the future, one
possible extension of ROPecker is to follow the direct branch
at run-time. If its destination is a gadget, ROPecker treats the
whole as a glued gadget. The following step can be repeated
one, two or more times (according to the conﬁguration) until
getting a gadget or reaching the times limit. This approach
may introduce more false positives and/or false negatives.
C. Short Gadget Chain
In certain extreme cases, the gadget chain may only contain
one or two gadgets. For such special ROP attacks, our scheme
can not detect or prevent them because the length of the gadget