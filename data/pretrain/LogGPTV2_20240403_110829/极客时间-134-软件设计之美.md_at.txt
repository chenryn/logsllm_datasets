# 19 \| 函数式编程之不变性：怎样保证我的代码不会被别人破坏？你好！我是郑晔。经过前两讲的介绍，你已经认识到了函数式编程的能力，函数以及函数之间的组合很好地体现出了函数式编程的巧妙之处。不过，我们在讲编程范式时说过，学习编程范式不仅要看它提供了什么，还要看它约束了什么。这一讲，我们就来看看函数式编程对我们施加的约束。在软件开发中，有一类 Bug是很让人头疼的，就是你的代码怎么看都没问题，可是运行起来就是出问题了。我曾经就遇到过这样的麻烦，有一次我用C写了一个程序，怎么运行都不对。我翻来覆去地看自己的代码，看了很多遍都没发现问题，不得已，只能一步一步跟踪代码。最后，我发现我的代码调用到一个程序库时，出现了与预期不符的结果。这个程序库是其他人封装的，我只是拿过来用。按理说，我调用的这个函数逻辑也不是特别复杂，不应该出现什么问题。不过，为了更快定位问题，我还是打开了这个程序库的源代码。经过一番挖掘，我发现在这个函数底层实现中，出现了一个全局变量。分析之后，我发现正是这个全局变量引起了这场麻烦，因为在我的代码执行过程中，有别的程序会调用另外的函数，修改这个全局变量的值，最终，导致了我的程序执行失败。从表面上看，我调用的这个函数和另外那个函数八竿子都打不到，但是，它们却通过一个底层的全局变量，产生了相互的影响。这就是一类非常让人头疼的 Bug。有人认为这是全局变量使用不当造成的，在Java设计中，甚至取消了全局变量，但类似的问题并没有因此减少，只是以不同面貌展现出来而已，比如，static变量。 那么造成这类问题的真正原因是什么呢？**真正原因就在于变量是可变的**。变之殇你可能会好奇，难道变量不就应该是变的吗？为了更好地理解这一类问题，我们来看一段代码：    class Sample1 {      private static final DateFormat format =           new SimpleDateFormat("yyyy.MM.dd");      public String getCurrentDateText() {        return format.format(new Date());      }    }如果你不熟悉 JDK 的SimpleDateFormat，你可能会觉得这段代码看上去还不错。然而，这段代码在多线程环境下就会出问题。正确的用法应该是这样：    public class Sample2 {      public String getCurrentDateText() {        DateFormat format = new SimpleDateFormat("yyyy.MM.dd");        return format.format(new Date());       }    }两段代码最大的区别就在于，SimpleDateFormat在哪里构建。一个是被当作了一个字段，另一个则是在函数内部构建出来。这两种不同做法的根本差别就在于，SimpleDateFormat对象是否共享。为什么这个对象共享会有问题呢？翻看 format方法的源码，你会发现这样一句：    calendar.setTime(date);这里的 calendar 是 SimpleDateFormat 这个类的一个字段，正是因为在format 的过程中修改了 calendar字段，所以，它才会出问题。我们来看看这种问题是怎么出现的，就像下面这张图看到的：![](Images/ab55fce1351717929363dc8e0d7898ec.png)savepage-src="https://static001.geekbang.org/resource/image/d2/db/d267c5c0ec206bef0eeae93f056d50db.jpg"}1.  A    线程把变量的值修改成自己需要的值；        2.  这时发生线程切换，B    线程开始执行，将变量的值修改成它所需要的值；        3.  线程切换回来，A    线程继续执行，但此时变量已经不是自己设置的值了，所以，执行会出错。        回到 SimpleDateFormat 上，问题是一样的，calendar就是那个共享的变量。一个线程刚刚设置的值，可能会被另外一个线程修改掉，因此会造成结果的不正确。而在Sample2 的写法中，通过每次创建一个新的 SimpleDateFormat对象，我们将二者之间的共享解开，规避了这个问题。那如果我还是想按照 Sample1 的写法写，SimpleDateFormat这个库应该怎么改写呢？可能你会想，SimpleDateFormat的作者没写好，如果换我写，我就会给它加上一个同步（synchronized）或者加上锁（Lock）。你甚至都没有注意，你轻易地将多线程的复杂性引入了进来。还记得我在分离关注点那节讨论的问题吗，多线程是另外一个关注点，能少用，尽量少用。一个更好的办法是将 calendar变成局部变量，这样一来，不同线程之间共享变量的问题就得到了根本的解决。但是，这类非常头疼的问题在函数式编程中却几乎不存在，这就依赖于函数式编程的不变性。不变性函数式编程的不变性主要体现在值和纯函数上。值，你可以将它理解为一个初始化之后就不再改变的量，换句话说，当你使用一个值的时候，值是不会变的。纯函数，是符合下面两点的函数：1.  对于相同的输入，给出相同的输出；        2.  没有副作用。        把值和纯函数合起来看，**值保证不会显式改变一个量**，**而纯函数保证的是**，**不会隐式改变一个量**。我们说过，函数式编程中的函数源自数学中的函数。在这个语境里，函数就是纯函数，一个函数计算之后是不会产生额外的改变的，而函数中用到的一个一个量就是值，它们是不会随着计算改变的。所以，在函数式编程中，计算天然就是不变的。正是由于不变性的存在，我们在前面遇到的那些问题也就不再是问题了。一方面，如果你拿到一个量，这次的值是1，下一次它还是1，我们完全不用担心它会改变。另一方面，我们调用一个函数，传进去同样的参数，它保证给出同样的结果，行为是完全可以预期的，不会碰触到其他部分。即便是在多线程的情况下，我们也不必考虑同步的问题，后续一系列的问题也就不存在了。这与我们习惯的方式有着非常大的区别，因为传统方式的基础是面向内存单元的，改来改去甚至已经成为了程序员的本能。所以，我们对counter = counter + 1这种代码习以为常，而初学编程的人总会觉得这在数学上是不成立的。在之前的讨论中，我们说过，传统的编程方式占优的地方是执行效率，而现如今，这个优点则越来越不明显，反而是因为到处可变而带来了更多的问题。相较之下，我们更应该在现在的设计中，考虑借鉴函数式编程的思路，把不变性更多地应用在我们的代码之中。那怎么应用呢？首先是值。我们可以编写不变类，就是对象一旦构造出来就不能改变，Java程序员最熟悉的不变类应该就是 String类，怎样编写不变类呢？1.  所有的字段只在构造函数中初始化；        2.  所有的方法都是纯函数；        3.  如果需要有改变，返回一个新的对象，而不是修改已有字段。        前面两点可能还好理解，最后一点，我们可以看一下 Java String 类的replace 方法签名：    String replace(char oldChar, char newChar);在这里，我们会用一个新的字符（newChar）替换掉这个字符串中原有的字符（oldChar），但我们并不是直接修改已有的这个字符串，而是创建一个新的字符串对象返回。这样一来，使用原来这个字符串的类并不用担心自己引用的内容会随之变化。有了这个基础，等我们后面学习领域驱动设计的时候，你就很容易理解值对象（ValueObject）是怎么回事了。我们再来看纯函数。**编写纯函数的重点是**，**不修改任何字段**，**也不调用修改字段内容的方法**。因为在实际的工作中，我们使用的大多数都是传统的程序设计语言，而不是严格的函数式编程语言，不是所有用到的量都是值。所以，站在实用性的角度，如果要使用变量，就使用局部变量。还有一个实用性的编程建议，就是使用语法中不变的修饰符，比如，Java就尽可能多使用 final，C/C++ 就多写const。无论是修饰变量还是方法，它们的主要作用就是让编译器提醒你，要多从不变的角度思考问题。当你有了用不变性思考问题的角度，你会发现之前的很多编程习惯是极其糟糕的，比如，Java程序员最喜欢写的setter，它就是提供了一个接口，修改一个对象内部的值。不过，纯粹的函数式编程是很困难的，我们只能把编程原则设定为**尽可能编写不变类和纯函数**。但仅仅是这么来看，你也会发现，自己从前写的很多代码，尤其是大量负责业务逻辑处理的代码，完全可以写成不变的。绝大多数涉及到可变或者副作用的代码，应该都是与外部系统打交道的。能够把大多数代码写成不变的，这已经是一个巨大的进步，也会减少许多后期维护的成本。而正是不变性的优势，有些新的程序设计语言默认选项不再是变量，而是值。比如，在Rust里，你这么声明的是一个值，因为一旦初始化了，你将无法修改它：    let result = 1;而如果你想声明一个变量，必须显式地告诉编译器：    let mut result = 1;Java也在尝试将值类型引入语言，有一个专门的Valhalla 项目slate-object="inline"就是做这个的。你也看到了，不变性，是减少程序问题的一个重要努力方向。现在回过头来看编程范式那一讲里说的约束：>  > 函数式编程，限制使用赋值语句，它是对程序中的赋值施加了约束。> > >理解了不变性，你应该知道这句话的含义了，一旦初始化好一个量，就不要随便给它赋值了。总结时刻今天，我们讲了无论是全局变量、还是多线程，变化给程序设计带来了很多麻烦，然后我们还分析了这类问题的成因。然而，这类问题在函数式编程中并不存在。其中，重要的原因就是函数式编程的不变性。函数式编程的不变性主要体现在它的值和纯函数上。深入学习函数式编程时，你会遇到的与之相关的各种说法：无副作用、无状态、引用透明等等，其实都是在讨论不变性。即便使用传统的程序设计语言，我们也可以从中借鉴一些编程的方法。比如，编写不变类、编写纯函数、尽量使用不变的修饰符等等。经过了这三讲的介绍，相信你已经对函数式编程有了很多认识，不过，我只是把设计中最常用的部分给你做了一个介绍，这远远不是函数式编程的全部。就算Java 这种后期增补的函数式编程的语言，其中也包含了惰性求值、Optional等诸多内容，值得你去深入了解。不过我相信有了前面知识的铺垫，你再去学习函数式编程其他相关内容，难度系数就会降低一些。关于编程范式的介绍，我们就告一段落，下一讲，我们开始介绍设计原则。如果今天的内容你只能记住一件事，那请记住：**尽量编写不变类和纯函数。**![](Images/ac364c76982710444e60f9d58c899372.png)savepage-src="https://static001.geekbang.org/resource/image/24/1e/24e5693b11652ff520e01fce5648b11e.jpg"}思考题最后，我想请你去了解一下Event Sourcingslate-object="inline"，结合今天的内容，谈谈你对它的理解。欢迎在留言区写下你的想法。感谢阅读，如果你觉得这一讲的内容对你有帮助的话，也欢迎把它分享给你的朋友。
# 加餐 \| 函数式编程拾遗你好，我是郑晔！我们之前用了三讲的篇幅讲了函数式编程，相信函数式编程在你心目中已经没有那么神秘了。我一直很偏执地认为，想要成为一个优秀的程序员，函数式编程是一定要学习的，它简直是一个待人发掘的宝库，因为里面的好东西太多了。不过，考虑到整个课程的主线，我主要选择了函数式编程在设计上有较大影响的组合性和不变性来讲。但其实，函数式编程中有一些内容，虽然不一定是在设计上影响那么大，但作为一种编程技巧，也是非常值得我们去了解的。所以，我准备了这次加餐，从函数式编程再找出一些内容来，让你来了解一下。相信我，即便你用的不是函数式编程语言，这些内容对你也是很有帮助的。好，我们出发！惰性求值还记得我们第 17讲的那个学生的例子吗？我们继续使用学生这个类。这次简化一点，我只使用其中的几个字段：    class Student {      // 学生姓名      private String name;      // 年龄      private long age;      // 性别      private Gender gender;            public Student(final String name,                      final long age,                      final Gender gender) {        this.name = name;        this.age = age;        this.gender = gender;      }    }然后，我们来看一段代码，你先猜猜这段代码的执行结果会是什么样子：    // 数据准备    Student jack = new Student("Jack", 18, Gender.MALE);    Student rose = new Student("Rose", 18, Gender.FEMALE);     List students = asList(jack, rose);    // 模拟对象    Function function = mock(Function.class);     when(function.apply(jack)).thenReturn("Jack");    // 映射    students.stream().map(function);     // 验证    verify(function).apply(jack);这段代码里，我们用到了一个 mock 框架 mockito，核心就是验证这里的function 变量是否得到了正确的调用，这其中就用到了我们在第 18 讲中提到的map 函数。 也许你已经猜到了，虽然按照普通的 Java 代码执行逻辑，verify的结果一定是 function 得到了正常的调用，但实际上，这里的 function并没有调用。也就是说，虽然看上去 map 函数执行了，但并没有调用到 function的 apply方法。你可以试着执行这段代码去验证一下。为什么会是这样呢？答案就在于这段代码是惰性求值的。什么叫惰性求值呢？**惰性求值（LazyEvaluation）是一种求值策略，它将求值的过程延迟到真正需要这个值的时候**。惰性求值的好处就在于可以规避一些不必要的计算，尤其是规模比较大，或是运行时间比较长的计算。其实，如果你学习过设计模式，惰性求值这个概念你应该并不陌生。有一些设计模式就是典型的惰性求值，比如，Proxy模式，它就是采用了惰性求值的策略，把一些消耗很大的计算延迟到不得不算的时候去做。还有Singleton模式有时也会采用惰性求值的策略，在第一次访问的时候，再去生成对象。在函数式编程中，惰性求值是一种很常见的求值策略，也是因为惰性求值的存在，我们可以做出很多有趣的事情。无限流在传统的编程方式中，我们熟悉的集合类都是有限长度的，因为集合中的每个元素都是事先计算好的。但现在有了惰性求值，我们就可以创造出一个无限长的集合。你可能会有疑问，怎么可能会有无限长的集合呢？内存也存不下啊？如果你这么想的话，说明你的思路还是传统的方式。无限长集合中的元素并不是预置进去的，而是在需要的时候，才计算出来的。**无限长集合真正预置进去的是，元素的产生规则**。这样一来，元素就会像流水一样源源不断地产生出来，我们将这种集合称为无限流（InfiniteStream）。 比如，我们要产生一个自然数的集合，可以这么做：    Stream.iterate(1, number -> number + 1)在这里，我们定义了这个集合的第一个元素，然后给出了后续元素的推导规则，一个无限流就产生了。当然，因为惰性求值的存在，这么定义的一个无限流并不会做真正的计算，只有在我们需要用到其中的一些元素时，计算才会执行。比如，我们可以按需取出一些元素，在下面这段代码中，我们跳过了无限流的前两个元素，然后，取出三个元素，将结果打印了出来：    Stream.iterate(0, number -> number + 1)      .skip(2)      .limit(3)      .forEach(System.out::println); 也许你会关心，什么情况下无限流才会真正的求值呢？其实，我们前面讲组合性时提到过，有一些基础的列表操作，列表操作可以分为两类，中间操作（IntermediateOperation）和终结操作（Terminal Operation），像 map 和 filter这一类的就是中间操作，而像 reduce一类的就属于终结操作。只有终结操作才需要我们给出一个结果，所以，只有终结操作才会引起真正的计算。你可能会好奇，无限流的概念很有意思，但它有什么用呢？如果你对无限流有了认识，很多系统的设计都可以看作成一个无限流。比如，一些大数据平台，它就是有源源不断的数据流入其中，而我们要做的就是给这个无限流提供各种转换，你去看看现在炙手可热的Flink，它使用的就是这种思路。记忆我们再来看另一个关于惰性求值带来的有趣做法：记忆（Memoization）。前面说过，Proxy模式之所以要采用惰性求值的策略，一个重要的原因就是真正的计算部分往往是消耗很大的。所以，一旦计算完成，一个好的策略就是将计算的结果缓存起来，这样，再次调用时就不必重新计算了。其实，这种做法就是记忆。记忆，在 Wikipedia上是这样定义的：>  > 在计算中，记忆是一种优化技术，主要用于加速计算机程序，其做法就是将昂贵函数的结果存储起来，当使用同样的输入再次调用时，返回其缓存的结果。> > >这里的一个重点是，同样的输入。我们已经知道了，函数式编程中的函数是纯函数，同样的输入必然会给出同样的输出。所以，我们就不难理解，记忆这种技术在函数式编程中的作用了。实现记忆这种技术并不难，下面就给出了一个实现，这里用到了 Java并发库中的类AtomicReference，从而消除了可能产生的多线程问题：    public static  Supplier memoize(Supplier delegate) {      AtomicReference value = new AtomicReference<>();      return () -> {        T val = value.get();        if (val == null) {          synchronized(value) {            val = value.get();            if (val == null) {              val = Objects.requireNonNull(delegate.get());              value.set(val);            }          }        }        return val;      };    }这个实现用起来也很简单：    long ultimateAnswer = memoize(() -> {        // 这里有一个常常的计算        // 返回一个终极答案        return 42;    })在这里，memoize是一个通用的实现，它的适用范围很广。我们仔细对比就不难发现，这里我们已经实现了Proxy 模式的能力，换言之，有了它，我们可以不再需要 Proxy模式。后面我们讲到设计模式也会提到，一些设计模式是受限于程序设计语言自身能力不足而出现的，这里也算为这个观点添加了一个注脚。Optional让我们回到学生的例子上，如果想获取一个学生出生的国家，我们该怎么写这段代码呢？直觉上的写法是这样的：    public Country getBirthCountry() {       return this.getBirthPlace() // 获取出生地                  .getCity()      // 获取城市                  .getProvince()  // 获取省份                  .getCountry();  // 获取国家    }然而，在真实项目中，代码并不能这么写，因为这样可能会出现空指针，所以，我们不得不把代码写成这样：    public Country getBirthCountry() {      Place place = this.birthPlace;      if (place != null) {        City city = place.getCity();        if (city != null) {          Province province = city.getProvince();          if (province != null) {            return province.getCountry();          }        }      }      return null;     }这是一段令人作呕的代码，但我们不得不这么写，因为空指针总是一个令人头疼的问题。事实上，作为程序员，我们经常会有忘记做空指针检查的时候。这不是一个人的问题，而是整个行业的问题，IT行业每年都会因此造成巨大的损失。>  > 我将其称为自己犯下的十亿美元错误......> > >>>  > I call it my billion-dollar> mistake...> > >>>  > ------Sir C. A. R.> Hoare，空引用的发明者> > >难道空指针就是一个无解的问题吗？程序员们并不打算束手就擒，于是，一种新的解决方案产生了，就是可选对象。这个解决方案在Java 8 中叫 Optional，在 Scala 中叫 Option。接下来，我们就以 Java 8 中的Optional 为例进行讲解。Optional是一个对象容器，其中可能包含着一个非空的值，也可能不包含。这是什么意思呢？它和直接使用对象的场景是一一对应的，如果包含值，就对应着就是有值的场景；而不包含，则对应着值为空的场景。那该如何去创建一个 Optional对象呢？ 1.  如果有一个非空对象，可以用 of() 将它包装成一个 Optional    对象；    2.  如果要表示空，可以返回一个    empty()；        3.  如果有一个从别处传来的对象，你不知道它是不是空，可以用    ofNullable()。        ```{=html}```    Optional.of("Hello"); // 创建一个Optional对象，其中包含了"Hello"字符串    Optional.empty(); // 创建了一个表示空对象的Optional对象。    Optional.ofNullable(instance); // 创建了一个Optional对象，不知instance是否为空。也许你会好奇，直接使用对象都解决不了问题，把对象放到一个容器里就解决了？还真能。因为你要用这个对象的时候，需要把对象取出来，而要取出对象，你就需要判断一下这个对象是否为空。就像下面这面代码这样：    if (country.isPresent()) {      return country.get();    } 只有 Optional 里包含的是一个非空的对象时， get()方法才能正常执行，否则，就会抛出异常。显然，当你调用 get()的时候，意图是很明显的，我要处理的是一个非空的值，所以，就必须加上一段判断对象是否存在的代码。这比直接访问对象多用了一步，但正是这多出的一步让你的大脑必须想一下，自己是否需要加上判空的处理，而不是像普通对象一样，一下子就滑了过去。而且因为 get()本身是有意图的，用工具也可以扫描出缺失的判断，比如，如果你用 IntelliJIDEA 写程序的话，不加判断，直接 get()的话，它就会给你一个警告。使用Optional，我们还可以给空对象增加一些额外的处理，比如给个缺省值：    country.orElse(china);  // 返回一个缺省的对象也可以生成一个新的对象：    country.orElseGet(Country::new); // 调用了一个函数生成了一个新对象或是抛出异常：    country.orElseThrow(IllegalArgumentException::new); 其实，我们拿到一个值之后，往往要做一些更多的处理。使用了Optional，我们甚至可以不用把其中的值取出来，直接就做一些处理了。比如，它提供map、flatMap、filter 等一些方法，就是当 Optional包含的对象不为空时，调用对应的方法做处理，为空的时候，直接返回表示空的Optional 对象。从下面这张图，你就能够理解这些方法的基本逻辑：![](Images/3f645d656e46fa2b9d96a6b58ab3be44.png)savepage-src="https://static001.geekbang.org/resource/image/56/59/563d937c8cf9e3772a10cf3b34fd4b59.jpg"}好，有了对 Optional的基本了解，我们在日常工作中怎么用它呢？很简单，**在方法需要返回一个值时，如果返回的对象可能为空，那就返回一个Optional**。这样就给了这个方法使用者一个提示，这个对象可能为空，小心处理。比如，获取学生的出生地，方法可以这么写：    Optional getBirthPlace() {      return Optional.ofNullable(this.birthPlace);    }好，回到我们前面的问题上。获取一个学生出生的国家，代码可以怎么写呢？如果相应的方法都改写成Optional，代码写出来会是这个样子：    public Optional getBirthCountry() {      return Optional.ofNullable(this.birthPlace)               .flatMap(Place::getCity)               .flatMap(City::getProvince)               .flatMap(Province::getCountry);    }虽然我们不能说这段代码一定有多优雅，但是至少比层层嵌套的 if判断要整洁一些了。最后，你可能会问，这个 Optional和函数式编程有什么关系呢？其实，Optional将对象封装起来的做法来自于函数式编程中一个叫 Monad的概念，你可以简单地把它理解成一个对象容器。Optional就对应着其中的一种：MaybeMonad。 我们前面也看到了，正是因为这个容器的存在，解决了很多问题。Monad的概念解释起来还有很多东西要说，篇幅所限，就不过多阐述了，有兴趣不妨自己去了解一下。这种对象容器的思想也逐渐在开枝散叶，比如，在 Rust的标准库里，有一个Resultslate-object="inline"，用来定义可恢复的故障。它可以是一个正常值，也可以是一个错误值：    enum Result {       Ok(T),       Err(E),    }下面是一段摘自 Rust 标准库文档的代码，当我们有了前面对于 Optional的讲解，理解起这段代码也就容易多了。    enum Version { Version1, Version2 }    // 定义一个解析版本的函数    fn parse_version(header: &[u8]) -> Result {        match header.get(0) {            None => Err("invalid header length"), // 无法解析，返回错误            Some(&1) => Ok(Version::Version1),  // 解析出版本1            Some(&2) => Ok(Version::Version2),  // 解析出版本2            Some(_) => Err("invalid version"),  // 无效版本，返回错误        }    }    let version = parse_version(&[1, 2, 3, 4]);    // 根据返回值进行处理    match version {        Ok(v) => println!("working with version: {:?}", v),        Err(e) => println!("error parsing header: {:?}", e),    }总结时刻今天，我给你讲了两个比较有用的函数式编程的概念：惰性求值和 Optional。惰性求值是一种求值策略，它将求值的过程延迟到真正需要这个值的时候，其作用就是规避一些不必要的计算。因为惰性求值的存在，还衍生出一些有趣的做法，比如，无限流和记忆。无限流启发了现在的一些大数据平台的设计，而记忆可以很好地替代Proxy 模式。Optional是为了解决空对象而产生的，它其实就是一个对象容器。因为这个容器的存在，访问对象时，需要增加一步思考，减少犯错的几率。正如我在前面课程中讲到，函数式编程中有很多优秀的内容，值得我们去学习借鉴。我在这几讲中讲到的内容，也只能说是管中窥豹，帮助你见识函数式编程一些优秀的地方。如果你想了解更多函数式编程，不妨读读《计算机程序的构造与解释slate-object="inline"》，体会一层一层构建抽象的美妙。如果还想了解更多，那就找一门函数式编程语言去学习一下。如果今天的内容你只能记住一件事，那请记住：**花点时间学习函数式编程。**思考题现在，你已经对函数式编程不陌生了，我想请你谈谈学习函数式编程的感受，无论你是刚刚跟着我学习的，还是之前已经学习过的，欢迎在留言区分享你的想法。感谢阅读，如果你觉得这一讲的内容对你有帮助的话，也欢迎把它分享给你的朋友。