Trace Me If You can:
Bypassing Linux SyscallTracing
Dr. Rex Guo, Lacework
Dr. Junyuan Zeng, Linkedin.com
#BHUSA @BlackHatEvents 
About Rex Guo
• Principal Engineer @ Lacework
• Behavior anomaly detection (Polygraph)
• CSPM
• Engineering Manager @ Startups
• Confluera (XDR)
• Tetration (CWPP, now part of Cisco)
• Conference speaker at Blackhat, DEFCON,…
• @Xiaofei_REX 
About Junyuan Zeng
• Linkedin
• Senior Software Engineer: Kubernetes
• JD.com
• Staff Security Architect/Engineer: 
Cloud native security  
• Samsung Research America & 
FireEye
• Staff Security Software 
Engineer/Researcher: Mobile security
An Incident - An Attacker’s View
Log4shell RCE on 
joe-box and 
executed a reverse 
shell
An Incident - An Attacker’s View
Log4shell RCE on 
joe-box and 
executed a reverse 
shell
Privilege escalation 
using sudo
CVE-2021-3156 
An Incident - An Attacker’s View
Log4shell RCE on 
joe-box and 
executed a reverse 
shell
read /etc/shadow
Privilege escalation 
using sudo
CVE-2021-3156 
An Incident - An Attacker’s View
Log4shell RCE on 
joe-box and 
executed a reverse 
shell
read /etc/shadow
Read ssh process 
environment 
variable
Privilege escalation 
using sudo
CVE-2021-3156 
An Incident - An Attacker’s View
Log4shell RCE on 
joe-box and 
executed a reverse 
shell
read /etc/shadow
Read ssh process 
environment 
variable
Lateral movement 
to alice-box with 
ssh hijacking
Privilege escalation 
using sudo
CVE-2021-3156 
An Incident - An Attacker’s View
Log4shell RCE on 
joe-box and 
executed a reverse 
shell
read /etc/shadow
Read ssh process 
environment 
variable
Lateral movement 
to alice-box with 
ssh hijacking
Privilege escalation 
using sudo
CVE-2021-3156 
An Incident - An Attacker’s View
Log4shell RCE on 
joe-box and 
executed a reverse 
shell
Privilege escalation 
using sudo
CVE-2021-3156 
read /etc/shadow
Read ssh process 
environment 
variable
Lateral movement 
to alice-box with 
ssh hijacking
connect
etc.
execve(at)
open(at)
open(at)
connect, 
etc.
Incident 
Response
Detection Rule Example
rule: untrusted program reads /etc/shadow
condition:
syscall == open(at)
and has read permission
and filename == /etc/shadow
and program is not in allowlist
Agenda
•Syscall Tracing
•Vulnerabilities 
•Exploitations
•Mitigations
•Takeaways
System Call Tracing
System Call Tracing – Tracing Program
• Tracing programs collect system call data, e.g., arguments
• Tracing programs can “attach” to different hooks
●
tracepoints, kprobe, ptrace etc.
• Tracing programs implementations
• Linux native mechanisms: ftrace, perf_events etc.
• Kernel modules, eBPF probe and user space programs
System Call Tracing – tracepoint
• tracepoint
• Kernel static hook
• Linux kernel provides sys_enter and sys_exit
• Low overhead but only static interceptions
System Call Tracing – kprobe
• kprobe
• Dynamic hook in the kernel
• Register tracing programs on
instructions in syscall code path
• Dynamic but slow compared to 
tracepoint and need to know exactly 
how data is placed on the stack and 
registers
System Call Tracing – ptrace
• ptrace
• A static hook
• No Kernel Module/eBPF program are needed
• Performance overhead is high
• Can combine with seccomp to reduce overhead
• Others (LD_PRELOAD etc.)
Cloud Workloads
• Virtual machines
• AWS EC2 instances
• Google VM instances
• Containers on customer-managed VMs
• AWS EC2 tasks
• Standard GKE workloads (e.g. DaemonSet etc.)
• AKS workloads
• Serverless containers: have no access to the host
• AWS Fargate tasks
• GCP Cloud Run services
• Others (AWS Lambda etc.)
System Call Tracing for Cloud Workloads
Workload
System Call Tracing
VMs
•
Hooks: tracepoint, kprobe, ptrace
•
Tracing programs: kernel programs (eBPF, kernel Module), user programs
•
Tools: Falco eBPF/kernel Module, Falco pdig
Containers
•
Hooks: tracepoint, kprobe, ptrace
•
Tracing programs: kernel programs (eBPF, kernel Module), user programs
•
Tools: Falco eBPF/kernel Module, Falco pdig
Serverless 
Containers
•
Hooks: ptrace
•
Tracing programs: user programs
•
Tools: Falco pdig
Open Source Projects
• Falco
●
Open source endpoint security monitoring project in CNCF
●
5K+ github stars
●
Falco supports syscall tracing techniques:
●
tracepoint + kernel module
●
tracepoint + eBPF probe
●
pdig: ptrace + userspace program
• Falco pdig
●
Support syscall tracing of serverless workloads
TOCTOU in Syscall Tracing
• sys_connect(int fd, struct sockaddr
__user * uservaddr, int addrlen)
• TOC (Time-Of-Check): tracing 
programs dereference this user 
space pointer
• TOU (Time-Of-Use): the kernel
dereferences this user space 
pointer
TOCTOU - Connect
ptrace_report_syscall(regs, message)
__secure_computing(struct seccomp_data{regs…})
trace_sys_enter(regs, regs->orig_ax)
User Space
Kernel 5.7.0
syscall enter
trace_sys_exit(regs, regs->ax)
ptrace_report_syscall(regs, message)
syscall exit
Execution Flow
ptrace/seccomp/sysenter tracepoint
Syscall Table (x86_64)
…
42 sys_connect
43 sys_accept
44 sys_sendto
…
long __sys_connect((int fd,
struct sockaddr __user *uservaddr, int addrlen))
{
…
struct filename *tmp;
ret = move_addr_to_kernel
(uservaddr, addrlen, &address);
if (!ret)
ret = __sys_connect_file
(f.file, &address, addrlen, 0);
…
}
TOCTOU - Connect
ptrace_report_syscall(regs, message)
__secure_computing(struct seccomp_data{regs…})
trace_sys_enter(regs, regs->orig_ax)
User Space
Kernel 5.7.0
syscall enter
trace_sys_exit(regs, regs->ax)
ptrace_report_syscall(regs, message)
syscall exit
Execution Flow
Syscall Table (x86_64)
…
42 sys_connect
43 sys_accept
44 sys_sendto
…
long __sys_connect((int fd,
struct sockaddr __user *uservaddr, int addrlen))
{
…
struct filename *tmp;
ret = move_addr_to_kernel
(uservaddr, addrlen, &address);
if (!ret)
ret = __sys_connect_file
(f.file, &address, addrlen, 0);
…
}
TOCTOU - Connect
ptrace_report_syscall(regs, message)
__secure_computing(struct seccomp_data{regs…})
trace_sys_enter(regs, regs->orig_ax)
User Space
Kernel 5.7.0
syscall enter
trace_sys_exit(regs, regs->ax)
ptrace_report_syscall(regs, message)
syscall exit
Execution Flow
ptrace/sysexit tracepoint
Syscall Table (x86_64)
…
42 sys_connect
43 sys_accept
44 sys_sendto
…
long __sys_connect((int fd,
struct sockaddr __user *uservaddr, int addrlen))
{
…
struct filename *tmp;
ret = move_addr_to_kernel
(uservaddr, addrlen, &address);
if (!ret)
ret = __sys_connect_file
(f.file, &address, addrlen, 0);
…
}
TOCTOU - Connect
ptrace_report_syscall(regs, message)
__secure_computing(struct seccomp_data{regs…})
trace_sys_enter(regs, regs->orig_ax)
User Space
Kernel 5.7.0
syscall enter
trace_sys_exit(regs, regs->ax)
ptrace_report_syscall(regs, message)
syscall exit
Execution Flow
Syscall Table (x86_64)
…
42 sys_connect
43 sys_accept
44 sys_sendto
…
long __sys_connect((int fd,
struct sockaddr __user *uservaddr, int addrlen))
{
…
struct filename *tmp;
ret = move_addr_to_kernel
(uservaddr, addrlen, &address);
if (!ret)
ret = __sys_connect_file
(f.file, &address, addrlen, 0);
…
}
Userspace pointer pointing to “socket address”
TOCTOU - Connect
ptrace_report_syscall(regs, message)
__secure_computing(struct seccomp_data{regs…})
trace_sys_enter(regs, regs->orig_ax)
User Space
Kernel 5.7.0
syscall enter
trace_sys_exit(regs, regs->ax)
ptrace_report_syscall(regs, message)
syscall exit
Execution Flow
Userspace pointer pointing to “socket address”
Kernel pointer pointing to “socket address”
Syscall Table (x86_64)
…
42 sys_connect
43 sys_accept
44 sys_sendto
…
long __sys_connect((int fd,
struct sockaddr __user *uservaddr, int addrlen))
{
…
struct filename *tmp;
ret = move_addr_to_kernel
(uservaddr, addrlen, &address);
if (!ret)
ret = __sys_connect_file
(f.file, &address, addrlen, 0);
…
}
TOCTOU - Connect
ptrace_report_syscall(regs, message)
__secure_computing(struct seccomp_data{regs…})
trace_sys_enter(regs, regs->orig_ax)
User Space
Kernel 5.7.0
syscall enter
trace_sys_exit(regs, regs->ax)
ptrace_report_syscall(regs, message)
syscall exit
Execution Flow
Syscall Table (x86_64)
…
42 sys_connect
43 sys_accept
44 sys_sendto
…
TOU by
Linux Kernel
long __sys_connect((int fd,
struct sockaddr __user *uservaddr, int addrlen))
{
…
struct filename *tmp;
ret = move_addr_to_kernel
(uservaddr, addrlen, &address);
if (!ret)