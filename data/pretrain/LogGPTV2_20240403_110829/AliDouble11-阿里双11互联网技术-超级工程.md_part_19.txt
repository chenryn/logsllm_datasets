○
文件级别的保低带宽(下限)
●
允许应用超出保底带宽后使用富余的空闲带宽；
○
Metadata throttle
●
限制特定操作的metadata操作，例如一次性删除大量小文件。
○
4.网络流量控制
带宽隔离
●
隔离本机带宽（TC）。
○
Pouch容器间的带宽隔离
○
带宽共享（金、银、铜）
●
新基础  9年双11：互联网技术超级工程
经历 400 多天打磨，
HSF 的架构和性能有哪些新突破？
思邪
阿里妹导读：2017年的双十一圆满结束了，1682亿的成交额再一次刷新了记
录，而HSF（High Speed Framework，分布式服务框架）当天调用量也突破了3.5
万亿次，调用量是2016年双十一的三倍多。为了这不平凡的一天中，HSF经历了
一年多的磨练，从架构升级到性能优化，从可用性提升到运维提升，完成了从2.1到
2.2的全面升级，截止到双十一开始的一刻，HSF2.2在全网机器占比超过75%，并
成功接受了大促考验。
从HSF2.1到HSF2.2的目标是提升HSF框架的扩展性、易用性和性能，相当
于将原有HSF推倒了重新来过，因此涉及到的内容众多，这里不做展开，我们仅从
架构升级、性能优化和运维提升三个方面来聊一下HSF2.2做了什么，有什么能帮到
大家，以及如何解决了双十一的一些问题。
新基础  9年双11：互联网技术超级工程
HSF2.2是天然支持多应用（或多模块）部署的。每个域中，都有各自的功能组件，
比如：服务域中的InvocationHandler就是对服务调用逻辑的抽象，通过扩展其中的
ClientFilter或者ServerFilter完成对客户端或者服务端的调用处理工作，这里只是
罗列了主要的功能组件和扩展点，以下是对它们的说明：
服务，对应于一个接口，它可以提供服务或者消费服务
应用，对应于一个应用或者一个模块，它管理着一组消费或者发布的服务
框架 ，对应于框架底层支持，它统一管理着线程、链接等资源
新基础  9年双11：互联网技术超级工程
可以看到，HSF2.2定义的调用拦截器不是一个简单的正向invoke过程，它还
具备响应回来时的逆向onResponse过程，这样一来一回很好的诠释了HSF同步
调用异步执行的调用模型。用户可以通过在一次调用中计算invoke和onResponse
之间的时差来获得调用的正确耗时，而不用关心HSF调用是同步还是异步，用户也
可以扩展一个调用拦截器穿插在其中，用于监控HSF的调用内容，而不用让应用方
做任何代码上的改造。
多应用支持
多模块部署一直是业务方同学探索的热点，从合并部署开始，HSF就有限的支
持了多应用部署，但是一直没有将其融入到架构中。在HSF2.2中，应用不仅仅是作
为托管服务的容器而是成为核心领域，多应用序列化的难题，就在应用层解决。
（模块在HSF2.2中也会被认为是一个应用，以下提到模块或者应用可以认为是
一个概念。）
HSF2.2支持多个应用部署的结构如下图所示：
可以看到，HSF2.2框架域处于最底层，它向上为应用提供了线程、连接等多种
资源的支持，而应用能够发布或者订阅多个服务，这些服务能够被应用统一管理，也
支持更加精细化的配置，层与层的司职明确让HSF具有了良好的适应性。
新基础  9年双11：互联网技术超级工程
为针对每次请求的序列化和反序列化，HSF都需要使用全新构造的HessianOutput
和HessianInput。这就导致每次请求都需要重新发送上次请求已经发送过的元数据。
针对限制2，HSF实现了跨请求元数据共享，这样只要发送过一次元数据，以
后就再也不用发送了，进一步减少传输的数据量。实现机制如下：
1.修改hessian代码，将元数据id分配和缓存的数据结构从HessianOutput
和HessianInput剥离出来。
2.修改HSF代码，将上述剥离出来的数据结构作为连接级别的上下文保存起来。
3.每次构造HessianOutput和HessianInput时将其作为参数传入。这样就达
了跨请求复用元数据的目的。
该优化的效果取决于业务对象中，元数据所占的比例，如果“精心”构造对象，
使得元数据所占比例很大，那么测试表现会很好，不过这没有意义。我们还是选取线
上核心应用的真实业务对象来测试。从线上tcp dump了一个真实业务对象，测试同
学以此编写测试用例得到测试数据如下：
1.新版本比老版本CPU利用率下降10%左右
2.新版本的网络流量相比老版本减少约17%
线上核心应用压测结果显示数据流量下降一般在15%~20%之间。
优化2：UTF8解码优化
hessian传输的字符串都是utf8编码的，反序列化时需要进行解码。hessian
现行的解码方式是逐个字符进行。代码如下：
private int parseUTF8Char() throws IOException { int ch = _offset < _length
? (_buffer[_offset++] & 0xff) : read();
if (ch < 0x80)
return ch;
else if ((ch & 0xe0) == 0xc0) {
int ch1 = read();
int v = ((ch & 0x1f) << 6) + (ch1 & 0x3f); return v;
} else if ((ch & 0xf0) == 0xe0) {
int ch1 = read();
新基础 < 173
int ch2 = read();
int v = ((ch & 0x0f) << 12) + ((ch1 & 0x3f) << 6) + (ch2 & 0x3f);
return v;
} else