pears in [7]. There, we show that exploits for some other compli-
cated vulnerabilities are also eliminated under these constraints.
Thus, with EON, we not only ﬁnd vulnerabilities in Windows
Vista’s access control model, but also prove that they can be elimi-
nated by imposing suitable constraints on the model. We conclude
that these constraints encode a formal “discipline" that is required
to safely exploit the ﬂexibilities provided by the model. In fact, a
similar discipline already appears in [6], with manual proofs.
5.2 Asbestos
The goal of Asbestos’s access control model is to dynamically
isolate trusted processes that require protection from less trusted
processes. This isolation is achieved by taint propagation. Speciﬁ-
cally, in Asbestos each process P has two labels: a send label PS,
which is a lower bound on the security of messages that can be
sent by P , and a receive label PR, which is an upper bound on the
security of messages that can be received by P . Further, each com-
munication port C has a port label CL, which is an upper bound
on the security of messages that can be carried by c. Sending a
message from process P to process Q on port C requires that:
PS ⊑ QR ⊓ CL
Further, on communication, Q is tainted by P :
QS ← QS ⊔ PS
In fact, this situation is slightly more complicated with declas-
siﬁcation. Speciﬁcally, there are a small number of security levels
(⋆, 0, 1, 2, 3), with minimum ⋆ and maximum 3. A label is a ﬁ-
nite record of security levels. Labels form a lattice (⊑, ⊔, ⊓), as
follows. (Here L1, L2 range over labels, and ℓ over label ﬁelds.)
L1 ⊑ L2 ⇔ ∀ℓ. L1.ℓ ≤ L2.ℓ
(L1 ⊔ L2).ℓ = max(L1.ℓ, L2.ℓ)
(L1 ⊓ L2).ℓ = min(L1.ℓ, L2.ℓ)
Now, an operation _⋆ is deﬁned as follows.
L⋆.ℓ = ⋆ if L.ℓ = ⋆
3 otherwise
On communication, Q is tainted by P only in ﬁelds that are not ⋆.
QS ← QS ⊔ (PS ⊓ Q⋆
S)
5.2.1 Secrecy on Asbestos
To understand some security consequences of this model, let us
focus on a single ﬁeld ℓ, and the security levels ⋆, 1, 2, and 3.
Below, we present an excerpt of a model of such a system in EON.
Let STAR denote ⋆, and i,j range over {1, 2, 3}. The unary base
relations in the model have the following informal meanings: P
contains processes; LRi and LSj contain processes x such that
xR.ℓ = i and xS.ℓ = j, respectively; LSTAR contains processes
x such that xS.ℓ = ⋆ and xR.ℓ = 3; and Mj contains processes x
that carry messages generated by processes y such that yR.ℓ = j,
respectively. We boot our system with the following clauses; these
clauses create an unbounded number of processes of various kinds,
and let them generate messages accordingly.
new P,LSTAR.
new P,LR1,LS1.
new P,LR2,LS1.
new P,LR3,LS1.
next M2(x),LS2(x),!LS1(x) :- LS1(x),LR2(x).
next M3(x),LS3(x),!LS1(x) :- LS1(x),LR3(x).
...
Next, we specify clauses for communication on unrestricted
ports (i.e., ports C such that CL.ℓ = 3). The requirements and
effects of such communication appear in the bodies and heads of
these clauses, respectively. Note, in particular, how the relations Mj
are augmented on such communication. (The full model contains
several other, similar rules, generated automatically by scripts.)
next M2(x) :- P(x),LSTAR(y),M2(y).
next M3(x) :- P(x),LSTAR(y),M3(y).
next M2(x) :- LSTAR(x),P(y),M2(y).
next M3(x) :- LSTAR(x),P(y),M3(y).
next M2(x),LS2(x),!LS1(x) :-
M2(y),LS2(y),LS1(x),LR2(x).
next M3(x),LS2(x),!LS1(x) :-
M3(y),LS2(y),LS1(x),LR2(x).
...
Finally, we ask some queries. According to [11], in Asbestos
the default security level in any ﬁeld of a receive label is 2.
Thus, having 3 in some ﬁeld of the receive label gives higher
read privileges than default; processes with such labels should
be able to share messages that default processes cannot know.
On the other hand, having 1 in some ﬁeld of the receive label
gives lower read privileges than default; processes with such
labels should not be able to know messages shared by default
processes.
Let ReadWithout3 denote the existence of a
process x for which M3(x) is true despite LRi(x) for some
i  1
despite LR1(x). These queries encode secrecy vulnerabilities.
ReadWithout3 :- M3(x),LR2(x).
ReadWithout3 :- M3(x),LR1(x).
ReadWith1 :- M2(x),LR1(x).
ReadWith1 :- M3(x),LR1(x).
? ReadWithout3.
? ReadWith1.
We ﬁnd exploits for both queries with EON. The derivations for
these queries may be anticipated—messages can be declassiﬁed,
that is, forwarded by processes z for which LSTAR(z) is true, with-
out any constraints or effects.
Now, let BlameReadWithout3 denote the existence of a pro-
cess z for which M3(z) and LSTAR(z) are true. On the other hand,
let BlameReadWith1 denote the existence of a process z for
which Mj(z) and LSTAR(z) are true for some j > 1. We now
ask the following, revised queries that account for declassiﬁcation.
(These queries encode violations of robust declassiﬁcation [21].)
BlameReadWithout3 :- M3(y),LSTAR(y).
BadReadWithout3 :- ReadWithout3,!BlameReadWithout3.
BlameReadWith1 :- M2(y),LSTAR(y).
BlameReadWith1 :- M3(y),LSTAR(y).
BadReadWith1 :- ReadWith1,!BlameReadWith1.
? BadReadWithout3.
? BadReadWith1.
Now EON does not ﬁnd exploits for either query. Note that the
revised queries use negation on non-base relations, and thus take
a long time to run. We can simulate these queries without using
negation, simply by removing the following clauses and asking the
same queries as before.
next M2(x) :- LSTAR(x),M2(y).
next M3(x) :- LSTAR(x),M3(y).
Once again, EON does not ﬁnd exploits for either query; how-
ever, the queries now run much faster. Thus, we have the following
secrecy theorem, proved automatically by EON.
THEOREM 4
that X is
(SECRECY). Assume
either
{P | PR.ℓ = 3} or {P | PR.ℓ 6= 1}.
If Q /∈ X, then Q
can never carry a message generated by a process in X, unless
some declassifying process carries that message as well.
5.2.2 Secrecy in a webserver running on Asbestos
We now present a signiﬁcantly more ambitious example to
demonstrate the scope of our techniques. Speciﬁcally, we apply
EON to verify a webserver running on Asbestos. This webserver is
described in detail in [11]; below, we brieﬂy review its architecture.
We then present an excerpt of a model of this webserver in EON,
and study its key security guarantee. The full model appears in [7].
The relevant principals include a net daemon, a database proxy,
and the users of the webserver. When a user connects, the net dae-
mon spawns a dedicated worker process for that user. The worker
process can communicate back and forth with that user over the net;
further, it can access a database that is common to all users. The
webserver relies on sophisticated protocols for connection handling
and database interaction; the aim of these protocols is to isolate pro-
cesses that run on behalf of different users, so that no user can see
a different user’s data.
In our model, we focus on two users u and v; processes that run
on behalf of these users are tagged as such on creation. We fo-
cus on label ﬁelds that are relevant for secrecy—these include uc
and ut (used for communication and taint propagation by u), and
vc and vt (used for communication and taint propagation by v).
We model labels with unary base relations that specify the secu-
rity levels in each ﬁeld: e.g., for processes x, LSuc1(x) denotes
xS.uc = 1; LRut2(x) denotes xR.ut = 2; and LSvcSTAR(x)
denotes xS.vc = STAR; similarly, e.g., for communication ports
y, Lvt2(y) denotes yL.vt = 2.
The other unary base relations in the model have the follow-
ing informal meanings. Useru and Userv contain processes
run by u and v, respectively; NETd contains processes run by
the net daemon; and Wu and Wv contain worker processes that are
spawned by the net daemon for u and v, respectively. All of these
processes participate in a connection handling protocol. Further,
Ready contains any such process that is ready for communica-
tion, after that protocol is executed. Other processes are run by
the database proxy. In particular, DBproxyRu and DBproxyRv
contain processes that receive database records for u and v, respec-
tively; and DBproxySu and DBproxySv contain processes that
send database records for u and v, respectively.
The processes above communicate on well-deﬁned ports.
Portu and Portv contain ports on which data is sent over the net
by processes running on behalf of u and v, respectively. PortDBu
and PortDBv contain ports on which data is received by the
database proxy from processes running on behalf of u and v, re-
spectively. PortAny contains unrestricted ports that are used for
all other communication.
Finally, to verify secrecy, we let Mu and Mv contain processes
that carry u’s data and v’s data, respectively. We require that no
process that runs on behalf of v is eventually in Mu (and vice versa).
We now outline our model. We describe only clauses that involve
u; the clauses that involve v are symmetrical. Most processes in
the system are created with default send and receive labels. (Any
security level in a default send label is 1, and any security level in a
default receive label is 2.) For instance, user processes are created
as follows.
new Useru,Ready,Mu,
LSuc1,LSut1,LSvc1,LSvt1,
LRuc2,LRut2,LRvc2,LRvt2.
...
Next, we model the connection handling protocol in [11]. When
a user u initiates a connection, the net daemon creates a new pro-
cess, as follows.
new NETd,
LSuc1,LSut1,LSvc1,LSvt1,
LRuc2,LRut2,LRvc2,LRvt2.
This process creates a new port on which data can be sent over
the net to u. The security level in the relevant communication ﬁeld
uc of the port’s label is 0; thus, processes with default send labels
cannot send messages on this port.
new Portu,
Luc0,Lut2,Lvc2,Lvt2.
...
The net daemon now lowers the security level in the ﬁeld uc of
its send label to STAR.
next LSucSTAR(x),!LSuc1(x) :-
NETd(x),LSuc1(x),Portu(y).
...
Next, the net daemon lowers the security level in the relevant
taint propagation ﬁeld ut of its send label to STAR, and becomes
ready for communication.
next LSutSTAR(x),!LSut1(x),Ready(x) :-
NETd(x),LSut1(x),LSucSTAR(x).
...
Eventually, the net daemon can raise the security level in the ﬁeld
ut of its receive label to 3, to receive tainted data from u. It can
similarly raise the security level in the ﬁeld ut of the port’s label,
to allow it to carry tainted data back to u.
next LRut3(x),!LRut2(x) :-
NETd(x),LRut2(x),LSutSTAR(x).
next Lut3(x),!Lut2(x) :-
Portu(x),Lut2(x),NETd(y),LucSTAR(y).
...
Further, the net daemon can spawn a new worker process for u.
new Wu,
LSuc1,LSut1,LSvc1,LSvt1,
LRuc2,LRut2,LRvc2,LRvt2.
...
The security levels in the ﬁelds uc and ut of the worker pro-
cess are lowered and raised to STAR and 3, respectively, before the
worker process becomes ready for communication.
next LSucSTAR(x),LSut3(x),!LSuc1(x),!LSut1(x),
Ready(x) :-
Wu(x),LSuc1(x),LSut1(x),
NETd(y),LSucSTAR(y),LSutSTAR(y).
...
Elsewhere, the database proxy creates the following processes
and ports for receiving and sending records for u.
new DBproxyRu,
LSuc1,LSutSTAR,LSvc1,LSvtSTAR,
LRuc2,LRut3,LRvc2,LRvt3.
new PortDBu,Luc2,Lut3,Lvc2,Lvt2.
new DBproxySu,
LSuc1,LSut3,LSvc1,LSvt3,
LRuc2,LRut3,LRvc2,LRvt3.
...
Unrestricted ports can also be created.
new PortAny,Luc3,Lut3,Lvc3,Lvt3.
We model all valid communication links between the above pro-
cesses, following the implementation described in [11]. Speciﬁ-