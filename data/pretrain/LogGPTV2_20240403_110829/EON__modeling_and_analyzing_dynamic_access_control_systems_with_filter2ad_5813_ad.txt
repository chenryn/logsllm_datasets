### 5.2 Asbestos

The goal of Asbestos's access control model is to dynamically isolate trusted processes that require protection from less trusted processes. This isolation is achieved through taint propagation. Specifically, in Asbestos, each process \( P \) has two labels: a send label \( P_S \), which is a lower bound on the security of messages that can be sent by \( P \), and a receive label \( P_R \), which is an upper bound on the security of messages that can be received by \( P \). Additionally, each communication port \( C \) has a port label \( C_L \), which is an upper bound on the security of messages that can be carried by \( C \).

#### Communication Constraints
Sending a message from process \( P \) to process \( Q \) on port \( C \) requires:
\[ P_S \sqsubseteq Q_R \sqcap C_L \]

On communication, \( Q \) is tainted by \( P \):
\[ Q_S \leftarrow Q_S \sqcup P_S \]

#### Taint Propagation with Declassification
The situation becomes more complex with declassification. There are a small number of security levels (\(\star\), 0, 1, 2, 3), with \(\star\) being the minimum and 3 being the maximum. A label is a finite record of security levels, and labels form a lattice \((\sqsubseteq, \sqcup, \sqcap)\) as follows:

- \( L_1 \sqsubseteq L_2 \Leftrightarrow \forall \ell. L_1.\ell \leq L_2.\ell \)
- \( (L_1 \sqcup L_2).\ell = \max(L_1.\ell, L_2.\ell) \)
- \( (L_1 \sqcap L_2).\ell = \min(L_1.\ell, L_2.\ell) \)

An operation \(_\star\) is defined as:
\[ L_\star.\ell = \begin{cases} 
\star & \text{if } L.\ell = \star \\
3 & \text{otherwise}
\end{cases} \]

On communication, \( Q \) is tainted by \( P \) only in fields that are not \(\star\):
\[ Q_S \leftarrow Q_S \sqcup (P_S \sqcap Q_{S\star}) \]

### 5.2.1 Secrecy in Asbestos

To understand the security consequences of this model, let us focus on a single field \(\ell\) and the security levels \(\star\), 1, 2, and 3. Below, we present an excerpt of a model of such a system in EON.

- Let \( \text{STAR} \) denote \(\star\).
- \( i, j \) range over \(\{1, 2, 3\}\).
- The unary base relations in the model have the following informal meanings:
  - \( P \) contains processes.
  - \( \text{LR}_i \) and \( \text{LS}_j \) contain processes \( x \) such that \( x_R.\ell = i \) and \( x_S.\ell = j \), respectively.
  - \( \text{LSTAR} \) contains processes \( x \) such that \( x_S.\ell = \star \) and \( x_R.\ell = 3 \).
  - \( M_j \) contains processes \( x \) that carry messages generated by processes \( y \) such that \( y_R.\ell = j \).

We initialize the system with the following clauses, creating an unbounded number of processes and letting them generate messages accordingly:

```eon
new P, LSTAR.
new P, LR1, LS1.
new P, LR2, LS1.
new P, LR3, LS1.
next M2(x), LS2(x), !LS1(x) :- LS1(x), LR2(x).
next M3(x), LS3(x), !LS1(x) :- LS1(x), LR3(x).
...
```

Next, we specify clauses for communication on unrestricted ports (i.e., ports \( C \) such that \( C_L.\ell = 3 \)). The requirements and effects of such communication appear in the bodies and heads of these clauses, respectively. Note how the relations \( M_j \) are augmented on such communication:

```eon
next M2(x) :- P(x), LSTAR(y), M2(y).
next M3(x) :- P(x), LSTAR(y), M3(y).
next M2(x) :- LSTAR(x), P(y), M2(y).
next M3(x) :- LSTAR(x), P(y), M3(y).
next M2(x), LS2(x), !LS1(x) :-
    M2(y), LS2(y), LS1(x), LR2(x).
next M3(x), LS2(x), !LS1(x) :-
    M3(y), LS2(y), LS1(x), LR2(x).
...
```

Finally, we ask some queries. According to [11], in Asbestos, the default security level in any field of a receive label is 2. Thus, having 3 in some field of the receive label gives higher read privileges than default; processes with such labels should be able to share messages that default processes cannot know. On the other hand, having 1 in some field of the receive label gives lower read privileges than default; processes with such labels should not be able to know messages shared by default processes.

Let \( \text{ReadWithout3} \) denote the existence of a process \( x \) for which \( M_3(x) \) is true despite \( \text{LR}_i(x) \) for some \( i < 3 \). Similarly, let \( \text{ReadWith1} \) denote the existence of a process \( x \) for which \( M_j(x) \) is true despite \( \text{LR}_1(x) \). These queries encode secrecy vulnerabilities:

```eon
ReadWithout3 :- M3(x), LR2(x).
ReadWithout3 :- M3(x), LR1(x).
ReadWith1 :- M2(x), LR1(x).
ReadWith1 :- M3(x), LR1(x).
? ReadWithout3.
? ReadWith1.
```

EON finds exploits for both queries. The derivations for these queries may be anticipated—messages can be declassified, that is, forwarded by processes \( z \) for which \( \text{LSTAR}(z) \) is true, without any constraints or effects.

Now, let \( \text{BlameReadWithout3} \) denote the existence of a process \( z \) for which \( M_3(z) \) and \( \text{LSTAR}(z) \) are true. On the other hand, let \( \text{BlameReadWith1} \) denote the existence of a process \( z \) for which \( M_j(z) \) and \( \text{LSTAR}(z) \) are true for some \( j > 1 \). We now ask the following, revised queries that account for declassification (these queries encode violations of robust declassification [21]):

```eon
BlameReadWithout3 :- M3(y), LSTAR(y).
BadReadWithout3 :- ReadWithout3, !BlameReadWithout3.
BlameReadWith1 :- M2(y), LSTAR(y).
BlameReadWith1 :- M3(y), LSTAR(y).
BadReadWith1 :- ReadWith1, !BlameReadWith1.
? BadReadWithout3.
? BadReadWith1.
```

EON does not find exploits for either query. Note that the revised queries use negation on non-base relations, and thus take a long time to run. We can simulate these queries without using negation, simply by removing the following clauses and asking the same queries as before:

```eon
next M2(x) :- LSTAR(x), M2(y).
next M3(x) :- LSTAR(x), M3(y).
```

Once again, EON does not find exploits for either query, but the queries now run much faster. Thus, we have the following secrecy theorem, proved automatically by EON.

**THEOREM 4 (SECRECY)**: Assume \( X \) is either \(\{P \mid P_R.\ell = 3\}\) or \(\{P \mid P_R.\ell \neq 1\}\). If \( Q \notin X \), then \( Q \) can never carry a message generated by a process in \( X \), unless some declassifying process carries that message as well.

### 5.2.2 Secrecy in a Webserver Running on Asbestos

We now present a more ambitious example to demonstrate the scope of our techniques. Specifically, we apply EON to verify a webserver running on Asbestos. This webserver is described in detail in [11]; below, we briefly review its architecture and present an excerpt of a model of this webserver in EON.

#### Webserver Architecture
The relevant principals include a net daemon, a database proxy, and the users of the webserver. When a user connects, the net daemon spawns a dedicated worker process for that user. The worker process can communicate back and forth with the user over the network and can access a common database. The webserver relies on sophisticated protocols for connection handling and database interaction to isolate processes that run on behalf of different users, so that no user can see another user's data.

In our model, we focus on two users \( u \) and \( v \); processes that run on behalf of these users are tagged as such on creation. We focus on label fields that are relevant for secrecy—these include \( uc \) and \( ut \) (used for communication and taint propagation by \( u \)), and \( vc \) and \( vt \) (used for communication and taint propagation by \( v \)).

#### Model Representation
- Unary base relations specify the security levels in each field, e.g., \( \text{LSuc1}(x) \) denotes \( x_S.uc = 1 \).
- Other unary base relations have the following informal meanings:
  - \( \text{Useru} \) and \( \text{Userv} \) contain processes run by \( u \) and \( v \), respectively.
  - \( \text{NETd} \) contains processes run by the net daemon.
  - \( \text{Wu} \) and \( \text{Wv} \) contain worker processes spawned by the net daemon for \( u \) and \( v \), respectively.
  - \( \text{Ready} \) contains any process that is ready for communication after the protocol is executed.
  - \( \text{DBproxyRu} \) and \( \text{DBproxyRv} \) contain processes that receive database records for \( u \) and \( v \), respectively.
  - \( \text{DBproxySu} \) and \( \text{DBproxySv} \) contain processes that send database records for \( u \) and \( v \), respectively.

#### Communication Ports
- \( \text{Portu} \) and \( \text{Portv} \) contain ports on which data is sent over the network by processes running on behalf of \( u \) and \( v \), respectively.
- \( \text{PortDBu} \) and \( \text{PortDBv} \) contain ports on which data is received by the database proxy from processes running on behalf of \( u \) and \( v \), respectively.
- \( \text{PortAny} \) contains unrestricted ports used for all other communication.

#### Secrecy Verification
We let \( \text{Mu} \) and \( \text{Mv} \) contain processes that carry \( u \)'s data and \( v \)'s data, respectively. We require that no process that runs on behalf of \( v \) is eventually in \( \text{Mu} \) (and vice versa).

We now outline our model. We describe only clauses that involve \( u \); the clauses that involve \( v \) are symmetrical. Most processes in the system are created with default send and receive labels (any security level in a default send label is 1, and any security level in a default receive label is 2). For instance, user processes are created as follows:

```eon
new Useru, Ready, Mu,
    LSuc1, LSut1, LSvc1, LSvt1,
    LRuc2, LRut2, LRvc2, LRvt2.
...
```

Next, we model the connection handling protocol. When a user \( u \) initiates a connection, the net daemon creates a new process:

```eon
new NETd,
    LSuc1, LSut1, LSvc1, LSvt1,
    LRuc2, LRut2, LRvc2, LRvt2.
```

This process creates a new port on which data can be sent over the network to \( u \):

```eon
new Portu,
    Luc0, Lut2, Lvc2, Lvt2.
...
```

The net daemon lowers the security level in the field \( uc \) of its send label to \(\star\):

```eon
next LSucSTAR(x), !LSuc1(x) :-
    NETd(x), LSuc1(x), Portu(y).
...
```

The net daemon lowers the security level in the field \( ut \) of its send label to \(\star\) and becomes ready for communication:

```eon
next LSutSTAR(x), !LSut1(x), Ready(x) :-
    NETd(x), LSut1(x), LSucSTAR(x).
...
```

Eventually, the net daemon can raise the security level in the field \( ut \) of its receive label to 3, to receive tainted data from \( u \). It can similarly raise the security level in the field \( ut \) of the port's label to allow it to carry tainted data back to \( u \):

```eon
next LRut3(x), !LRut2(x) :-
    NETd(x), LRut2(x), LSutSTAR(x).
next Lut3(x), !Lut2(x) :-
    Portu(x), Lut2(x), NETd(y), LucSTAR(y).
...
```

The net daemon can spawn a new worker process for \( u \):

```eon
new Wu,
    LSuc1, LSut1, LSvc1, LSvt1,
    LRuc2, LRut2, LRvc2, LRvt2.
...
```

The security levels in the fields \( uc \) and \( ut \) of the worker process are lowered and raised to \(\star\) and 3, respectively, before the worker process becomes ready for communication:

```eon
next LSucSTAR(x), LSut3(x), !LSuc1(x), !LSut1(x),
    Ready(x) :-
    Wu(x), LSuc1(x), LSut1(x),
    NETd(y), LSucSTAR(y), LSutSTAR(y).
...
```

Elsewhere, the database proxy creates the following processes and ports for receiving and sending records for \( u \):

```eon
new DBproxyRu,
    LSuc1, LSutSTAR, LSvc1, LSvtSTAR,
    LRuc2, LRut3, LRvc2, LRvt3.
new PortDBu, Luc2, Lut3, Lvc2, Lvt2.
new DBproxySu,
    LSuc1, LSut3, LSvc1, LSvt3,
    LRuc2, LRut3, LRvc2, LRvt3.
...
```

Unrestricted ports can also be created:

```eon
new PortAny, Luc3, Lut3, Lvc3, Lvt3.
```

We model all valid communication links between the above processes, following the implementation described in [11].