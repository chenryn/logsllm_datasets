Illegal 
main.c:33: warning:
，在有些实现中可能会把ap改写成无效值，C标准要求在函数返回前调用va_end。
，实现者只管按格式化字符串的描述从栈上取数据，如果调用者传递的参数类型或个数不
 gcc main.c
a.out
int main(void)
void printlist(int begin, ·..)
 instruction
UT
printlist(0,
 分别是什么类型。保证参数的类型、个数与格式化字符串的描述相匹配是调月
va_end(ap);
d
 function 'myprintf':
d
_Bnd(int，3U)也是4。
 va_arg(ap, char*);
'char'
"hello",
_arg(ap;
code is
将类型或变量 的长度对齐到
*）;
"world", "foo", "bar", NULL);
这是为了与C标准一致，
reached,
va_start(ap，format)使ap指向format参数的下
，我们在第3.1节“nteger
字节的整数倍，例
 char）;
 例 
char *)把第三
用我们这
田
---
## Page 447
5.回调函数
1、实现一个功能更完整的printf,
免错误的。
者应该在文档中说明参数列表必须以NULL结尾，如果调用者不遵守这个约定，实现者是没有办法避
printlist的第一个参数begin的值并没有用到，
上一页
题请点评
return 0;
，能够识别，
全国嵌入式人才培训基地
起始页
上一级
能够处理名d、对应的整数参数。在实现中不许调
但是C语言规定至少要定义一个有名字的参数，
从它的地址开始找可变参数的位置。实现
第25章C标准库
下一页
因
---
## Page 448
在前面的各章中我们已经见过C标准库的一些用法，总结如下：
4.分配内存的函数
3.数值字符串转换函数
2.标准I/O库函数
1.字符串操作函数
第 25 章 C标准库 请点评
目
在第1节“数学函数"中用到了math.h中声明的sin和1og函数，使用这些函数需要动态链
我们最常用的是包含stdio.h，
和time.h中声明的time函数。使用这些函数需要动态链接libc共享库。
头文件中定义的RAND_MAX常量，
在第2 节“数组应用实例：统计随机数"中用到了stdlib.h中声明的rand函数，还提到了这个
接libm共享库。
2.11.本节综合练习
2.10.C标准库的I/O缓冲区
2.9.格式化I/O函数
2.8.以记录为单位的IO函数
2.7.以字符串为单位的I/O函数
 2.2. fopen/fclose
2.1.文件的基本概念
1.7.分割字符串
1.6.搜索字符串
1.1.初始化字符串
1.5.比较字符串
1.4.连接字符串
1.3.拷贝字符串
1.2.取字符串的长度
.6.操作读写位置的函数
使用其中声明的printf函数，这个函数在libc中实现，程序在
全国嵌入式人才培训基地
部分ⅡI. C语言本质
第25章C标准库
---
## Page 449
6.可变参数
讲到的函数有些也不会讲得很细，
Page,
参考手册，
数）
本章介绍另外一些最基本和最常用的库函数（包括一些不属于C标准但在UNIX平台上很常用的函
总结一下，Linux平台提供的C标准库包括：
能
写成一
看懂相关的Man Page了。很多技术书的作者给自己的书太多定位，
·一组头文件，
·在第2节“main函数和启动例程"中用到了stdlib.h中声明的exit函数，使用这个函数需要动
写这一章是为了介绍字符串操作和文件操作的基本概念，而不是为了写一本C标准库函数的
享库中，例如数学函数在libm中。在第4 节“共享库"讲过，
一组库文件，
于/usr/include目录下。C99标准定义的头文件有24个，本书只介绍其中最基本、最常用的
gnu/4.3.2/include目录下,
不同的编译器，在我的系统上，stdarg.h和stddef.h位于/usr/lib/gcc/i486-linux-
宏定义，
在第1节“指针的基本概念"中提到了NULL指针也在stddef.h中定义。
在第 2.4节"sizeof运算符与typedef类型声明"中提到了size_t类型在stddef.h中定义,
这个宏也需要动态链接libc共享库。
们看到了这个宏的一种实现，
态链接libc共享库。
几个。
库
一本参考手册，我觉得这样不好，读者过于依赖技术书就失去了看真正的手册的能力。
而不是把我这-
这一点和assert不同。
Man Page已经是一本很好的手册了，
，提供了库函数的实现。大多数库函数在libc共享库中，有些库函数在另外的共
定义了很多类型和宏，
一章当参考手册来翻，
，stdio.h、stdlib.h、time.h、 math.h、assert.h位
，因为我假定读者经过上一章的学习再结合我讲过的基本概念已经
 使用这些函数需要动态链接libc共享库。
，这些宏定义的实现并没有调用库函数，所以不依赖于某个共享
全国嵌入式人才培训基地
声明了很多库函数。这些头文件放在哪些目录下取决于
所以本章不会面面俱到介绍所有的库函数，
起始页
上一级
，读者学完这一章之后在开发时应该查阅Man 
通常libc共享库
在第4节“其它预处理特性"中我
 既想写成一本入门教程，
1.字符串操作函数
，对于本章
下一页
---
## Page 450
绍memcpy和memmove函数。
1.3.拷贝字符串 请点评
返回，返回的长度不包括o字符在内。例如定义char buf[”="hello";，
strlen函数返回s所指的字符串的长度。该函数从s所指的第一个字符开始找·o'字符，
问越界。
1.2.取字符串的长度 请点评
如果它是函数的局部变量，
零。例如定义char buf[10];，
memset函数把s所指的内存地址开始的n个字节都填充为c的值。
1.1.初始化字符串 请点评
取长度、拷贝、连接、比较、搜索等基本操作。
符号处理都是由各种基本的字符串操作组成的，本节介绍如何用C语言的库函数做字符串初始化、
处理程序无处不在，
程序按功能划分可分为数值运算、符号处理和I/O操作三类，
1.字符串操作函数 请点评
上一页
void *memcpy(void *dest)
 #include  
void
#include 
#include 
反同
.*memmove(void *dest, const void *src, size_t n);
，编译器、浏览器、Ofice套件等程序的主要功能都是符号处理。无论多复杂的
则初值不确定，
 如果它是全局变量或静态变量，
 const void *src,
全国嵌入式人才培训基地
第 25章C标准库
1.字符串操作函数
 size_t n);
，符号处理程序占相当大的比例，符号
，则自动初始化为O（位于.bss段)
，通常c的值为0，
则strlen(buf)的值
，把一块内存区清
一旦找到就
下一
贝
---
## Page 451
果呢？根据这个结果猜测的一种可能的实现是：
果不借助于临时缓冲区能不能正确处理重叠内存区间的拷贝？
在我的机器上运行的结果是hhhlloworrd。如果把代码中的memcpy改成memmove则可以保证正确拷
+ 1，buf，13)是无法保证正确拷贝的：
无法保证正确拷贝,
memmove也是从sre所指的内存地址拷贝n个字节到dest所指的内存地址，
串看待，
以\o结尾的字符串,
是遇到o就结束，
memcpy函数从src所指的内存地址拷贝n个字节到dest所指的内存地址，和strncpy不同，
例 25.1.错误的memcpy调用
，因此参数的指针类型是void*而非char ＊。
返回值：dest指向哪，返回的指针就指向哪
int main(void)
#include
const char *s = src;
char *d = dest; 
return dest;
for (i = 0;
for （i = 0; i 
#include 
关于restrict关键字更详细的解释可以参考[BeganEORTRAN]
样特别说明之外，都表示"不允许"。
如此类的调用都是非法的。本书也遵循这一惯例，除非像memmove这
用sprintf时传进来的格式化字符串和结果字符串的首地址相同，诸
说明，都不应该接收两个指针参数指向重叠的内存区间，例如调
在C89标准的库函数一章开头提到，本章描述的所有函数，
然语言描述哪些函数的参数不允许指向重叠的内存区间，
指针允许指向重叠的内存区间。在
101
，它并不是缓冲区dest的长度,
"bar";
"foo"
(char
 调用者必须确保dest缓冲区足够大,
一个长度，就可以避免缓冲区溢出错误。注意这个参数n的含义
但是用完之后要记得调用free释放新字符串的内存。
 把字符串s拷贝到新分配的内存中然后返回。用这个函数省去
const
，缓冲区a中保存着字符串"foobar"，注意原来"foo"后面
，"bar"后面的"o仍保留。
，包含C标准库的所有函数和很多其它的系统函数，
char *src, size_t n);
关键字出现之前都是用自
 否则会导致缓冲区溢出错
例如
 则取前n个字符再加一
除非特别
---
## Page 454
参考[算法导论]
同。想想这个算法最多需要做多少次比较？其实有比这个算法高效得多的算法，有兴趣的读者可以
依次假定为子串的开头，
搜索子串有一个显而易见的算法,
一根针needle，按中文的说法叫大海捞针，显然haystack是长字符串，needle是要找的子串。
返回值指向子串的开头，
strstr在一个长字符串中从前到后找一个子串（Substring）
位置，
strchr在字符串s中从前到后查找字符c，找到字符c第一次出现的位置时就返回，返回值指向这个
1.6.搜索字符串 请点评
strncmp的比较结束条件是：要么在其中一
strcmp把s1和s2当字符串比较，
返回正值。
memcmp从前到后逐个比较缓冲区s1和s2的前n个字节（不管里面有没有·\o）
一次出现的位置就返回，函数名中间多了-
返回值：如果找到子串，
#include 
char
char *strchr(const char *s,
#include 
int strcasecmp(const char *sl, const char *s2);
#include 
int memcmp(const void *sl, const void *s2, size_t n);
#include 
返
返
回值：如果找到字符c，
in
in
回值：
七
strncasecmp(const 
S
*strrchr(const
........
"ABC"，4)的返回值是正值。
如果找不到就返回NULL。这两个参数名很形象，
，在其中一个字符串中遇到\o时结束，按照上面的比较准
可以用两层的循环，
但在比较过程中忽略大小写,
char
是POSIX标准中定义的。
 int c);
const
，"123A9"比"123B2"小。
一个字母r可以理解为Reverse。
 Strncmp("ABCD",
int
const
char
，如果找不到就返回NULL
正值表示s1大于s2
外层循环把haystack中的每一个字符的位置
*s2）;
"ABC"，3)的返回值
，但是从右向左找字符e，找到字符c第
找到子串第-
 大写字母A和小写字母a认为是相
size_t n);
一次出现的位置就返回
如果s1和s2的前n个
---
## Page 455
结合这个例子，strtok的行为可以这样理解：冒号是分隔符,
个分隔符就会分割字符串。看下面的例子。
参数str是待分割的字符串，delim是分隔符，
这样的字符串需要根据分隔符把字符串分割成几段,
每条记录占一行，
中保存着系统的帐号信息：
很多文件格式或协议格式中会规定一
1.7.分割字符串 请点评