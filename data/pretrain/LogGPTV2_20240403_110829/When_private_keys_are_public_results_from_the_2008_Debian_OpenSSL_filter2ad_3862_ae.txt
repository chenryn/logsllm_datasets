phase followed by levelling oﬀ, certiﬁcates were replaced on
a slower cycle with substantial ﬁxing extending well past ﬁve
months after the announcement. We also ﬁnd that in some
cases certiﬁcate authorities continued to issue certiﬁcates to
weak keys long after the vulnerability was announce. In the
process of this research we have developed extensive tool-
ing and a new SSL survey data set that that allows us to
re-examine existing work on SSL server demographics. Our
dataset is available to other researchers interested in study-
ing questions of real-world SSL deployments.
Acknowledgements
We are grateful to Dan Boneh for discussions on how to at-
tack DHE and to Nagendra Modadugu for advice on method-
ology. Josh Benaloh and David Pickett provided key de-
tails of the behavior of Internet Explorer. Florian Weimer
and Dirk-Willem van Gulik helped identify the variations
possible in key generation. Patrick Nehls and the UC San
Diego security oﬃce provided the original list of hosts with-
out which this study would not have been possible. Thanks
to Terry Therneau for assistance with the Cox proportional
hazards analysis and for providing the survival package.
This document was prepared using Sweave [10]. We would
especially like to thank Jeﬀ Barto and Rick Andrews for
their assistance with obtaining data on VeriSign’s certiﬁ-
cates and notiﬁcation policy.
We also beneﬁted from discussions with Jennifer Granick,
Joe Hall, Candice Hoke, Jim Hughes, Cullen Jennings, Moni
Naor, and Melanie Schoenberg.
Finally, we are grateful for the comments and suggestions
of the anonymous IMC reviewers.
This material is based upon work supported in part by
the National Science Foundation under Grants No. 0831532
and 0831536 and supported in part by a MURI grant admin-
istered by the Air Force Oﬃce of Scientiﬁc Research. Any
opinions, ﬁndings, and conclusions or recommendations ex-
pressed in this material are those of the authors and do not
necessarily reﬂect the views of the National Science Foun-
dation or the Air Force Oﬃce of Scientiﬁc Research.
9. REFERENCES
[1] P. Abeni, L. Bello, and M. Bertacchini. Exploiting
DSA-1571: How to break PFS in SSL with EDH, July
2008. http://www.lucianobello.com.ar/
exploiting_DSA-1571/index.html.
[2] A. Becherer, A. Stamos, and N. Wilcox. Cloud
computing security: Raining on the trendy new
parade. Presented at BlackHat USA 2009, July 2009.
Online: http://www.isecpartners.com/files/
Cloud.BlackHat2009-iSEC.pdf.
[3] I. Goldberg and D. Wagner. Randomness and the
Netscape browser. Dr. Dobb’s Journal, pages 66–70,
Jan. 1996.
[4] S. Kent and K. Seo. Security Architecture for the
Internet Protocol. RFC 4301, Internet Engineering
Task Force, Dec. 2005.
[5] D. G. Kleinbaum. Survival Analysis: A Self-Learning
Text. Springer, 1996.
[6] B. Laurie. Debian and OpenSSL: The aftermath, May
2008. http://www.links.org/?p=328.
[7] B. Laurie. Vendors are bad for security, May 2008.
http://www.links.org/?p=327.
[8] B. Laurie and R. Clayton. OpenID/Debian
PRNG/DNS cache poisoning advisory, Aug. 2008.
www.links.org/files/openid-advisory.txt.
[9] H. Lee, T. Malkin, and E. Nahum. Cryptographic
strength of SSL/TLS servers: Current and recent
practices. In C. Dovrolis and M. Roughan, editors,
Proceedings of IMC 2007, pages 83–92. ACM Press,
Oct. 2007.
[10] F. Leisch. Sweave: Dynamic generation of statistical
reports using literate data analysis. In W. H¨ardle and
B. R¨onz, editors, Compstat 2002 — Proceedings in
Computational Statistics, pages 575–80. Physica
Verlag, Heidelberg, 2002.
[11] M. Mueller. Debian OpenSSL predictable PRNG
bruteforce SSH exploit, May 2008.
http://milw0rm.com/exploits/5622.
[12] E. Murray. SSL server security survey, July 2000.
Archived copy online: http:
//web.archive.org/web/20031005013455/http:
//www.lne.com/ericm/papers/ssl_servers.html.
[13] Netcraft. Netcraft SSL survey.
news.netcraft.com/SSL-Survey/, Jan. 2008.
[14] R Development Core Team. R: A Language and
Environment for Statistical Computing. R Foundation
for Statistical Computing, Vienna, Austria, 2008.
[15] T. Ramos. The Laws of Vulnerabilities. RSA
Conference, 2006. http:
//www.qualys.com/docs/Laws-Presentation.pdf.
[16] E. Rescorla. Security holes. . . who cares? In
V. Paxson, editor, Proc. 12th USENIX Security
Symp., pages 75–90. USENIX, Aug. 2003.
[17] S original by Terry Therneau, ported by Thomas
Lumley. survival: Survival Analysis, including
Penalised Likelihood. R package version 2.34.
[18] The Debian Project. openssl – predictable random
number generator. DSA-1571-1, May 2008.
http://www.debian.org/security/2008/dsa-1571.
[19] W. N. Venables and B. D. Ripley. Modern Applied
Statistics with S. Springer, New York, fourth edition,
2002.
[20] T. Ylonen and C. Lonvick. The Secure Shell (SSH)
Protocol Architecture. RFC 4251, Internet
Engineering Task Force, Jan. 2006.
APPENDIX
A. ATTACKING APACHE WITH DHE
In this appendix, we show how an attacker who observes
every connection to an Apache SSL server can track the
entropy pools of the parent process and its children. This
allows the attacker to decrypt all traﬃc in DHE sessions the
server negotiates. (Ordinary RSA sessions remain secure.)
Only the entropy used in handling connections needs to be
weak for this attack to succeed; the server’s long-lived key
can be strong.
Compared to simple process-per-child servers, Apache in-
troduces a number of complicating factors. First, a sin-
gle worker process will handle multiple connections in se-
quence. Each connection will call RAND_bytes one or more
times, mixing the entropy pool. Even with the Debian bug,
25Figure 13: Apache child entropy-pool state search tree.
then, the random values obtained by the process for the
ﬁrst connection it handles will be diﬀerent from those ob-
tained for the second and subsequent connections. Nor can
an attacker compute the random values for the ﬁrst k con-
nections for each pid, obtaining a table of size 32768 × k:
the pattern of RAND_bytes calls made by the process in han-
dling a connection is diﬀerent depending on whether the
connection requires a full handshake or just a session resume
and whether the cipher suite negotiated in the handshake is
RSA or DHE_RSA. Starting from some initial known entropy
pool, one obtains a ternary tree; the cost of precomputation
is exponential in the depth. Second, initialization, including
the generation of cryptographic parameters, is carried out
in a parent process that forks oﬀ child processes to handle
connections. The entropy pool of a child process has both
parent and child pids mixed in, so an attacker may have
to precompute each of 215 · 215 values — though for lightly
loaded servers the child pids are likely to be near the parent
pids.13 Third, because Apache employs a “thundering herd”
architecture, an attacker will not a priori know which child
process will handle a particular connection.
Attacks against Apache servers are still possible, but they
require the attacker to observe and record all traﬃc to the
server from the moment it starts accepting connections.14
Prior to the attack, the attacker precomputes the entropy
pool for each possible ﬁrst parent, second parent, and child
pid, along with the ServerRandom that would be sent by the
ﬁrst connection; we discuss the computation and storage
this requires in Appendix A.3 below. Now the attacker pro-
cesses the ﬁrst connection to the server. The ServerRandom
will be one of the values listed in the table. The attacker
has identiﬁed the parent pids and the pid of one of the chil-
dren. He will now track the contents of the entropy pool for
13In fact, in an additional perversity, initialization is car-
ried out in each of two parent processes as Apache forks
away from its controlling terminal and session. This does
not mean that the attacker must precompute (215)3 values,
however: The second process is created soon after the ﬁrst,
and Debian’s kernel assigns pids sequentially.
14An attacker who can use a DoS bug to crash child pro-
cesses will have a somewhat easier time mounting the at-
tack, because it is the child processes whose entropy evolves
over time: the attacker will crash each child process, caus-
ing the parent to fork fresh new children; connections from
that point on will be vulnerable even if the attacker did not
observe earlier connections.
the child process he has discovered. Subsequent connections
will either be ﬁrst connections to other children, which the
attacker will look up in his table, or second or later con-
nections to already-known children, for which the attacker
will appropriately update his local copy of that child’s en-
tropy pool. Crucially, all the values that aﬀect the pattern
of RAND_bytes calls made by the server process are trans-
mitted in the clear as part of the SSL handshake. Figure 13
shows the evolution of the attacker’s knowledge.
We have implemented our attack on Ubuntu 7.10 (Gutsy)
running the default Apache2 MPM-Prefork package with
OpenSSL version 0.9.8e-5ubuntu3, which contains the De-
bian SSL vulnerability. Apache2 MPM-prefork, like Apache
1.3, uses processes instead of threads to handle requests.
While the tables we construct are speciﬁc to this version of
Apache and its default Ubuntu conﬁguration, additional ta-
bles could be easily built for other common conﬁgurations.
The remainder of this section describes the details of our
attack.
A.1 Building ServerRandom Tables.
First, we created lookup tables to allow us to determine,
given a session ID or ServerRandom value, the pids of the
Apache parents and worker child. We constructed a simu-
lator for Mod SSL that takes as input three pids pid1, pid2,
and pid3, and executes the exact same calls to the OpenSSL
PRNG that Apache makes when initializing the server with
parent pids pid1 and pid2 and worker pid pid3. Once the
simulated worker process requests 28 bytes for the Server-
Random (after requesting 32 bytes for the session ID), we
record this value and the three pids in our table.
A second table is required to handle the case where the
ﬁrst connection to a new child is a session resume, since in
this case the ServerRandom is the ﬁrst value drawn from the
PRNG, not the second after the session ID. It is possible to
combine both tables by recording both the session ID and
ServerRandom in a single table; in a session resume, the ﬁrst
28 bytes of the ServerRandom will be a preﬁx of what would
otherwise be the session ID.
A.2 Compromising DHE Sessions.
To track each child’s entropy pool as it evolves over mul-
tiple connections, we modify the simulator we used to gen-
erate the ServerRandom table so that simulates connections
of speciﬁed types in the sequence after generating the ini-
tial ServerRandom. Because the number of RAND_bytes calls
parent:        ﬁrst pid 1001second pid 1003childchildchildchildchildchild100410051006201002010120102childchildchildresumeRSADHE_RSAchildchildchildresumeRSADHE_RSAchildchildchildresumeRSADHE_RSAchildchildchildresumeRSADHE_RSAchild pid:26for blinding operations depends on the server’s public key,
this simulator must be tailored to the speciﬁc server we are
attacking.
We use this simulator as follows. We use ssldump15 to ob-
tain a parsed version of all of the connections to the server.
We extract the connection type and other values relevant
to our analysis from the dump using a Perl script. As we
step through the history of connections to the server, we
keep track of the worker processes we have identiﬁed as be-
ing active, and the sequence of connection types each has
encountered thus far.
For each new connection that we examine, we ﬁrst check
if it is handled by a worker process that we already know
about. To do this, we use our simulator to increment the
state of each known worker process and then check if the
ServerRandom emitted matches the ServerRandom of the new
connection we are examining. If there is a match, we have
determined that the connection is handled by an existing
worker process that we are already tracking.
If not, the
connection must have been handled by a new worker process;
we can use our table of ServerRandom values to ﬁnd the new
process’ pid and start tracking its state.
As we sequentially examine sessions in the ssldump, we
can completely determine the PRNG state of every worker
process at each point, so for the DHE sessions we can deter-
mine the ephemeral Diﬃe-Hellman private key, compromis-
ing those sessions.
A.3 Resources Required for the Attack.
Our attack platform was a machine with a single 3.2 GHz
Intel Pentium 4 with 1 GB RAM. We performed a proof-of-
concept attack under controlled conditions, building a sub-
table of the full lookup table discussed above, with ﬁrst par-
ent pid in the range [5000, 5835]; the second server pid either
the next or next-but-one; and worker pids up to one hun-
dred after the second server pid. On our lightly-loaded test
machine, rebooted before each trial, this small table always
suﬃced.
The table, containing approximately 160,000 entries, is
10 MB. We estimate that the full table of 235 entries16 would
take less than 4 TB.
Generating our small lookup table by na¨ıvely simulating
each pid triple took 15 hours. Using this approach to gen-
erate the full table would take several million hours of com-
puter time. However, checkpointing the computation after
the parent initialization has completed can cut this time
down by several orders of magnitude. At 220 cost, this gives
a lookup table of entropy pool states for each pair (pid1,
pid2) of parent pids. One then uses the appropriate check-
point entry to derive the entropy pool of each child pid pid3.
This gives all (pid1, pid2, pid3) entries in the table without
needlessly repeating the most costly part of the computa-
tion. Our experiments show that the two parent initializa-
tions, which require RSA keypair generation and make hun-
dreds of PRNG calls, take 135 ms on average for each par-
ent, whereas the ﬁnal worker process stage is much faster —
about 0.04 ms. This suggests a total cost for computing the
table by this method of`220×2×135 ms´+`235×0.04 ms´ ≈
460 hr, though the actual cost may be somewhat higher due
to IO overhead.
The checkpointed workload, like the na¨ıve one, is highly
parallelizable. The basic subtask is to compute the table
entries for a particular parent pid pair (pid1, pid2) and all
possible child pids. This subtask takes less than 1.6 s and
is totally independent of any other subtask. It would take
a cluster of 20 machines just a day to compute the entire
table.
15http://www.rtfm.com/ssldump/.
16This is any of 215 values for the initial server pid and child
pid, and a smaller 25 range for the second server pid.
27