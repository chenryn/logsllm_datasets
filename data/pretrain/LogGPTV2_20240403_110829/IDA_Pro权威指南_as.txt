.text:00401049            retn  
.text:00401049 _main      endp
数组的起始地址（由 EAX寄存器中的 malloc
 返回）存储在局部变量 heap_array
 中。这个例子与前面两个例子不同，每一次访问数组时，首先必须读取 heap_array
 的内容，以获得数组的基址，然后再在它上面加上一个偏移值，计算出数组中对应元素的地址。引用 heap_array[0]
 、heap_array[1]
 和heap_array[2]
 需要的偏移量分别为 0、4 和8 字节，如➊、➋和➌处所示。引用heap_array[idx]
 ➍处的操作与前面的例子最为相似，它在数组中的偏移量通过将数组索引与数组元素大小相乘计算得出。
堆分配的数组有一个非常有用的特点。如果能够确定数组的总大小和每个元素的大小，我们可以轻松计算出该数组所包含的元素的数量。对堆分配的数组而言，传递给内存分配函数的参数（0x0C
 在➎处传递给了malloc
 ）即表示分配给数组的字节总数，用这个数除以元素大小（本例为4 字节，如➊、➋和➌处的偏移量所示），即可得到数组中元素的个数。前面的例子分配了一个包含3 个元素的数组。
关于数组的使用，我们能够得出的唯一确定的结论是：只有当变量被用作数组的索引时，我们才最容易确定数组的存在。要访问数组中的元素，首先需要用索引乘以数组元素的大小，计算出相应元素的偏移量，然后将得到的偏移量与数组的基址相加，得到数组元素的访问地址。遗憾的是，如我们在下一节所述，在使用常量索引值访问数组元素时，它们很少能够证明数组的存在，并且看起来与用于访问结构体成员的代码非常类似。
8.1.2 结构体成员访问
C 结构体，这里通称为结构体，是异类数据集合，可将数据类型各不相同的项组合到一个复合数据类型中。结构体的一个显著特点在于，结构体中的数据字段是通过名称访问，而不是像数组那样通过索引访问。不好的是，字段名称被编译器转换成了数字偏移量。结果，在反汇编代码清单中，访问结构体字段的方式看起来与使用常量索引访问数组元素的方式极其相似。
如果编译器遇到一个结构体定义，它会计算出结构体中字段所耗用字节的累计值，以确定结构体中每个字段的偏移量。下面的结构体定义将用在随后的例子中：
struct ch8_struct {   //Size     Minimum offset     Default offset  
   int field1;        //  4             0                  0     
   short field2;      //  2             4                  4  
   char field3;       //  1             6                  6  
   int field4;        //  4             7                  8  
   double field5;     //  8             11                 16  
};                //Minimum total size: 19   Default size: 24  
分配结构体所需的最小空间，由分配结构体中的字段所需的空间总和决定。但是，你绝不能因此认为编译器会利用所需的最小空间来分配结构体。默认情况下，编译器会设法将结构体字段与内存地址对齐，以最有效地读取和写入这些字段。例如，4 字节的整数字段将与能够被 4 整除的偏移量对齐，而 8 字节的双字则与能够被 8 整除的偏移量对齐。根据结构体的构成，满足对齐要求可能需要插入填补字节，使结构体的实际大小大于字段大小的总和。前面例子中结构体的默认偏移量和最终的结构体大小位于 Default offset
 一列中。
通过使用编译器选项来要求特定的成员对齐，可将结构体压缩到最小空间。Microsoft Visual C/C++ 和GNU gcc/g++ 都将pack
 杂注（pragma）视为控制结构体字段对齐的一种方法。同时，GNU编译器还使用packed
 属性来控制结构体对齐（在每个结构体的基础上）。要求结构体字段进行1 字节对齐，编译器会将结构体压缩到最小空间。就我们例子中的结构体而言，这样做将得到Minimum offset
 一列中的偏移量和结构体大小。值得注意的是，如果以这种方式对齐数据，一些CPU 的性能更加优良；但是，如果有些边界上的数据并未对齐，CPU 可能会产生异常。
了解这些事实后，我们就可以着手分析编译代码是如何处理结构体的。为了进行比较，要注意，和数组一样，结构体成员的访问是通过将结构体的基址加上将要访问的成员的偏移量来实现的。然而，虽然数组元素的偏移量可在运行时由提供的索引值计算出来（因为每个数组元素的大小相同），但结构体成员的偏移量必须预先计算出来，作为固定偏移量出现在编译代码中，因而看起来与使用常量索引的数组引用几乎完全相同。
1. 全局分配的结构体
和全局分配的数组一样，编译器在编译时可获知全局分配的结构体的地址。这使得编译器能够在编译时计算出结构体中每个成员的地址，而不必在运行时进行任何计算。以下面这个访问全局分配的结构体的程序为例：
struct ch8_struct global_struct;  
int main() {  
   global_struct.field1 = 10;  
   global_struct.field2 = 20;  
   global_struct.field3 = 30;  
   global_struct.field4 = 40;  
   global_struct.field5 = 50.0;   
}
如果使用默认的结构体对齐选项编译这个程序，在反汇编时，我们可能会得到下面的代码清单：
.text:00401000 _main           proc near  
.text:00401000                 push    ebp  
.text:00401001                 mov     ebp, esp  
.text:00401003                 mov     dword_40EA60, 10  
.text:0040100D                 mov     word_40EA64, 20  
.text:00401016                 mov     byte_40EA66, 30  
.text:0040101D                 mov     dword_40EA68, 40  
.text:00401027                 fld     ds:dbl_40B128  
.text:0040102D                 fstp    dbl_40EA70  
.text:00401033                 xor     eax, eax  
.text:00401035                 pop     ebp  
.text:00401036                 retn  
.text:00401036 _main           endp  
可以看到，在这个反汇编代码清单中，访问结构体成员不需要任何算术计算，如果没有源代码，你根本无法断定这个程序使用了结构体。因为编译器在编译时已经计算出所有的偏移量，这个程序似乎引用的是 5 个全局变量，而不是一个结构体中的 5 个字段。你应该能够注意到，这种情况与前面例子中使用常量索引值的全局分配的数组非常类似。
2. 栈分配的结构体
和栈分配的数组一样（参见 8.1.1 节的第 2 小节），仅仅根据栈布局，同样很难识别出栈分配的结构体。对前面的程序进行修改，使其使用一个栈分配的结构体，并在 main
 中进行声明，可得到下面的反汇编代码清单：
.text:00401000 _main           proc near  
.text:00401000  
.text:00401000 var_18          = dword ptr -18h  
.text:00401000 var_14          = word ptr -14h  
.text:00401000 var_12          = byte ptr -12h  
.text:00401000 var_10          = dword ptr -10h  
.text:00401000 var_8           = qword ptr -8  
.text:00401000  
.text:00401000                 push    ebp  
.text:00401001                 mov     ebp, esp  
.text:00401003                 sub     esp, 18h  
.text:00401006                 mov     [ebp+var_18], 10  
.text:0040100D                 mov     [ebp+var_14], 20  
.text:00401013                 mov     [ebp+var_12], 30  
.text:00401017                 mov     [ebp+var_10], 40  
.text:0040101E                 fld     ds:dbl_40B128  
.text:00401024                 fstp    [ebp+var_8]  
.text:00401027                 xor     eax, eax  
.text:00401029                 mov     esp, ebp  
.text:0040102B                 pop     ebp  
.text:0040102C                 retn  
.text:0040102C _main           endp  
同样，访问结构体中的字段不需要进行任何算术计算，因为在编译时，编译器能够确定栈帧内每个字段的相对偏移量。在这种情况下，我们同样会被误导，认为程序使用的是5 个变量，而不是一个碰巧包含 5 个字段的变量。实际上，var_18
 应该是一个大小为 24字节的结构体的第一个变量，其他变量应进行某种格式化，以反映它们是结构体中的字段这一事实。
3. 堆分配的结构体
事实上，关于结构体的大小及其字段的布局，堆分配的结构体体现了更多信息。如果一个结构体在程序堆中分配，那么，在访问其中的字段时，编译器别无选择，只有生成代码来计算每个字段在结构体中的正确偏移量。这是结构体的地址在编译时未知所导致的后果。对于全局分配的结构体，编译器能够计算出一个固定的起始地址。对于栈分配的结构体，编译器能够计算出结构体起始位置与相关栈帧的帧指针之间的固定关系。如果一个结构体在堆中分配，那么对编译器来说，引用该结构体的唯一线索就是指向该结构体起始地址的指针。
再次修改上面的例子，使其使用堆分配的结构体，从而得到下面的反汇编代码清单。与8.1.1节的第3 小节的堆分配的数组示例一样，我们在 main中声明一个指针，并给它分配足够的内存块，以保存我们的结构体：
.text:00401000 _main             proc near  
.text:00401000  
.text:00401000 heap_struct       = dword ptr -4  
.text:00401000  
.text:00401000                   push    ebp  
.text:00401001                   mov     ebp, esp  
.text:00401003                   push    ecx  
.text:00401004                ➏  push    24              ; size_t  
.text:00401006                   call    _malloc  
.text:0040100B                   add     esp, 4  
.text:0040100E                   mov     [ebp+heap_struct], eax  
.text:00401011                   mov     eax, [ebp+heap_struct]  
.text:00401014                ➊  mov     dword ptr [eax], 10  
.text:0040101A                   mov     ecx, [ebp+heap_struct]  
.text:0040101D                ➋  mov     word ptr [ecx+4], 20  
.text:00401023                   mov     edx, [ebp+heap_struct]  
.text:00401026                ➌  mov     byte ptr [edx+6], 30  
.text:0040102A                   mov     eax, [ebp+heap_struct]  
.text:0040102D                ➍  mov     dword ptr [eax+8], 40  
.text:00401034                   mov     ecx, [ebp+heap_struct]  
.text:00401037                   fld     ds:dbl_40B128  
.text:0040103D                ➎  fstp    qword ptr [ecx+10h]  
.text:00401040                   xor     eax, eax  
.text:00401042                   mov     esp, ebp  
.text:00401044                   pop     ebp  
.text:00401045                   retn  
.text:00401045 _main             endp
在这个例子中，与全局和栈分配的结构体示例不同，我们能够辨别出结构体的实际大小和布局。根据➏处malloc
 所需的内存数量，我们推断出：结构体的大小为24 字节。该结构体包含以下字段：
一个4 字节字段（dword
 ），偏移量为 0（➊）；
一个2 字节字段（word
 ），偏移量为 4（➋）；
一个1 字节字段，偏移量为 6（➌）；
一个4 字节字段（dword
 ），偏移量为 8（➍）；
一个8 字节字段（qword
 ），偏移量为 16 （10h）（➎）。
根据浮点指令的用法，我们可以进一步推断出 qword
 字段实际上是double
 类型的。如果要求结构体进行 1 字节对齐，对其进行压缩，则该程序的反汇编代码清单为：
.text:00401000 _main           proc near  
.text:00401000  
.text:00401000 heap_struct     = dword ptr -4  
.text:00401000  
.text:00401000                 push    ebp  
.text:00401001                 mov     ebp, esp  
.text:00401003                 push    ecx  
.text:00401004                 push    19              ; size_t  
.text:00401006                 call    _malloc  
.text:0040100B                 add     esp, 4  
.text:0040100E                 mov     [ebp+heap_struct], eax  
.text:00401011                 mov     eax, [ebp+heap_struct]  