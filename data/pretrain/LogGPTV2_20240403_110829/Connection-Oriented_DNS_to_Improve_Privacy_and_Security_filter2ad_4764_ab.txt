servers from TCP-based DoS attacks [26], [71], and TCP’s
connection establishment precludes source address spooﬁng,
eliminating ampliﬁcation attacks.
We do not have data to quantify the number of DNS ampliﬁ-
cation attacks. However, measurements of source-IP spooﬁng
shows that the number of networks that allow spooﬁng has
been fairly steady for six years [7]. Recent measurement
of distributed reﬂective denial-of-service (DRDoS) shows the
majority of the attacks involve DNS ampliﬁcation [66]. Recent
reports of DoS show that DNS ampliﬁcation is a serious
problem, particularly in the largest attacks [3]. T-DNS suggests
a long-term path to reduce this risk.
Even if TCP reduces DoS attacks, we must ensure it does
not create new risks, as we show experimentally in § V.
Fortunately TCP security is well studied due to the web
ecosystem. We describe our approaches to DoS above, and
most other known attacks have defenses. A more detailed list
of TCP-speciﬁc attacks that do not apply is in our technical
report [86].
II-B3 Need for DNS Privacy: Lack of protection for query
privacy is the ﬁnal problem. Traditionally, privacy of Internet
trafﬁc has not been seen as critical. However, recent trends
in DNS use, deployment and documentation of widespread
eavesdropping increase the need for query privacy [9]. First,
end-user queries are increasingly exposed to possible eaves-
dropping, through use of third-party DNS services such as
OpenDNS and Google Public DNS, and through access on
open networks such as WiFi hotspots. Second, presence of
widespread eavesdropping and misdirection is now well doc-
umented, for government espionage [31], censorship [2], and
criminal gain [51]. Finally, ISPs have recognized the opportu-
nity to monetize DNS typos, redirecting non-existing domain
responses (NXDOMAIN hijacking), a practice widespread
since 2009 (for example [52]). For both corporate or national
observation or interference, we suggest that one must follow
the policies of one’s provider and obey the laws of one’s
country, but we see value in making those policies explicit
by requiring interaction with the operator of the conﬁgured
recursive name server, rather than making passive observation
easy.
DNS is also important to keep private because it is used for
many services. While protecting queries for IP addresses may
seem unnecessary if the IP addresses will then immediately
appear in an open IP header, full domain-names provide
information well beyond just the IP address. For web services
provided by shared clouds, the domain name is critical since
IP addresses are shared across many services. DNS is also
used for many things other than translating names to IP
addresses: one example is anti-spam services where DNS maps
e-mail senders to reputation, exposing some e-mail sources via
DNS [46].
Although DNS privacy issues are growing, most DNS
security concerns have focused on the integrity of DNS replies,
out of fear of reply modiﬁcation. The integrity of DNS replies
has been largely solved by DNSSEC which provides end-to-
end integrity checks.
II-C Threat Model
To understand security aspects of these problems we next
deﬁne our threat model.
For DoS attacks exploiting spoofed source addresses, our
adversary can send to the 30M currently existing open, recur-
sive resolvers that lack ingress ﬁltering [50].
For query eavesdropping and attacks on privacy, we assume
an adversary with network access on the network between the
user and the recursive resolver. We assume aggregation and
caching at the recursive resolver provide effective anonymiza-
tion to authoritative servers; if not it could enable TLS.
We also assume the operator of the recursive resolver is
trusted. Although outside the scope of this paper, this require-
ment can be relaxed by alternating requests across several DNS
providers, implementing a mix network shufﬂing requests from
multiple users, or padding the request stream with fake queries.
Similarly, privacy attacks using cache timing are outside our
scope, but solved by request padding [37].
For fragmentation attacks due to limited packet size, we
assume an off-path adversary that can inject packets with
spoofed source addresses, following Herzberg and Schul-
man [32].
Other attacks on query integrity are already largely pre-
vented by DNSSEC and so they are outside the scope of this
paper. (T-DNS augments DNSSEC, it is not intended to replace
it.)
We depend on existing mechanisms to avoid person-in-the-
middle attacks on T-DNS setup of TLS as discussed in § III-B.
Concurrent with our work, Shulman identiﬁed information
leakage in encrypted DNS [70]. This paper seeks to close the
primary channel; we recognize side channels remain.
T-DNS clients may set their own policy for handling down-
grade attacks, where a request for privacy is declined. An
adversary in control of the network can interfere with TLS
negotiation, preventing its use. A conservative client may retry
other servers or refuse to provide non-private DNS, or it may
alert the user.
174174
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:44 UTC from IEEE Xplore.  Restrictions apply. 
feature
signaling
protocol/port
encryption
stub/recursive
recursive/authoritative
pipelining
out-of-order replies
TCP Fast Open
TLS resumption
unbound
T-DNS
implicit
in-band
TCP/53
TCP/443
negotiable from TLS
yes
yes
yes
yes
yes
yes
yes
no
no*
no*
no
no
system
DNSCrypt
implicit
TCP/443
DNSCurve
per-query
UDP/53
Curve25519
from UDP
from UDP
no
yes
n/a
n/a
yes
no
n/a
n/a
Table II: Design choices in T-DNS as compared to alternatives.
III. DESIGN AND IMPLEMENTATION OF T-DNS
Table II lists design choices for T-DNS; next we describe in-
band TLS negotiation (our protocol addition), and implementa-
tion choices that improve performance (shown in § VI). These
design choice are critical to amortize the cost of connections.
III-A DNS over TCP
Design of DNS support for TCP was in the original
speciﬁcation [53] with later clariﬁcations [5]. However, im-
plementations of DNS-over-TCP have been underdeveloped
because it is not seen today as the common case. We consider
three implementation decisions, two required to to make TCP
performance approach UDP.
Pipelining is sending multiple queries before their re-
sponses arrive. It is essential to avoid round-trip delays that
would occur with the stop-and-wait alternative. Batches of
queries are common: recursive resolvers with many clients
have many outstanding requests to popular servers, such
as that for .com. End-users often have multiple names to
resolve, since most web pages draw resources from multiple
domain names. We examined 40M web pages (about 1.4% of
CommonCrawl-002 [30]) to conﬁrm that 62% of web pages
have 4 or more unique domain names, and 32% have 10 or
more.
Support for receiving pipelined requests over TCP exists
in bind and unbound. However neither sends TCP unless
forced to by indication of reply truncation in UDP; and
although explicitly allowed, we know of no widely used
client that sends multiple requests over TCP. Our custom stub
resolver supports pipelining, and we are working to bring T-
DNS to the getdns resolver.
Out-of-order processing (OOOP) at recursive resolvers is
another important optimization to avoid head-of-line blocking.
TCP imposes an order on incoming queries; OOOP means
replies can be in a different order, as deﬁned and explicitly
allowed by RFC-5966 [5]. Without OOOP, queries to even
a small percentage of distant servers will stall a strictly-
ordered queue, unnecessarily delaying all subsequent queries.
(For UDP, absence of connections means all prominent DNS
servers naturally handle queries with OOOP.)
We know of no DNS server today that supports out-of-order
processing of TCP queries. Both bind and unbound instead
resolve each query for a TCP connection before considering
the next. We have implemented out-of-order processing in our
DNS proxy (converting incoming TLS queries back to UDP at
the server), and have a prototype implementation in unbound.
Finally, when possible, we wish to shift state from server
to client. Per-client state accumulates in servers with many
connections, as observed in the TIME-WAIT state overheads
due to closed TCP connections previously observed in web
servers [28]. Shifting TCP state with DNS is currently being
standardized [83].
These implementation details are important not only
to DNS;
their importance has been recognized before in
HTTP [54], [28]. HTTP/1.1 supports only pipelining, but both
are possible in DNS and proposed HTTP/2 [56].
III-B DNS over TLS
TLS for DNS builds on TCP, with new decisions about trust,
negotiation, and implementation choices.
III-B1 Grounding Trust: TLS depends on public-key cryp-
tography to establish session keys to secure each connection
and prevent person-in-the middle attacks [21]. DNS servers
must be given TLS certiﬁcates, available today from many
sources at little or no cost.
Client trust follows one of several current practices. We pre-
fer DANE/TLSA to leverage the DNSSEC chain of trust [33],
but other alternatives are the current public-key infrastructures
(PKI) or trusted Certiﬁcate Authorities (CAs) provided out-
of-band (such as from one’s OS vendor or company). To
avoid circular dependencies between T-DNS and DANE, one
may bootstrap T-DNS’s initial TLS certiﬁcate through external
means (mentioned above) or with DANE without privacy.
III-B2 Upwards TLS Negotiation: T-DNS must negotiate
the use of TLS. Earlier protocols selected TLS with separate
ports, but IETF now encourages in-protocol upgrade to TLS
to reduce port usage; this approach is the current preference
for many protocols (IMAP, POP3, SMTP, FTP, XMPP, LDAP,
and NNTP, although most of these do have legacy, IANA-
allocated, but not RFC-standardized, ports to indicate TLS,
XMPP,
to indicate
TLS). We therefore propose a new EDNS0 extension [18] to
negotiate the use of TLS. We summarize our proposal below
and have provided a formal speciﬁcation elsewhere [34].
the most recent, being an exception).
Our negotiation mechanism uses a new “TLS OK” (TO)
in the extended ﬂags of the EDNS0 OPT record. A
bit
client requests TLS by setting this bit in a DNS query. A
server that supports TLS responds with this bit set,
then
both client and server carry out a TLS handshake [21]. The
TLS handshake generates a unique session key that protects
subsequent, normal DNS queries from eavesdropping over the
connection.
The DNS query made to start TLS negotiation obviously
is sent without TLS encryption and so should not disclose
information. We recommend a distinguished query with name
“STARTTLS”,
type TXT, class CH, analogous to current
support queries [81].
Once TLS is negotiated, the client and server should retain
the TLS-enabled TCP connection for subsequent requests.
Either can close connections after moderate idle periods (eval-
uated in § IV), or if resource-constrained.
175175
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:44 UTC from IEEE Xplore.  Restrictions apply. 
III-B3 Implementation Optimizations: Two implementation
choices improve performance. TLS connection resumption
allows the server to give all state needed to securely re-create
a TLS connection to the client [67]. This mechanism allows a
busy server to discard state, yet an intermittently active client
can regenerate that state more quickly than a full, fresh TLS
negotiation. A full TLS handshake requires three round-trip
exchanges (one for TCP and two for TLS); TLS resumption
reduces this cost to two RTTs, and reduces server computation
by reusing the master secret and ciphersuite. Experimentally
we see that resumption is 10× faster than a new connection
(§ VI-A).
TLS close notify allows one party to request the other to
close the connection. We use this mechanism to shift TCP
TIME-WAIT management to the client.
III-C Implementation Status
We have several implementations of these protocols. Our
primary client implementation is a custom client resolver that
we use for performance testing. This client implements all
protocol options discussed here and uses either the OpenSSL
or GnuTLS libraries. We also have some functionality in a
version of dig.
We have three server implementations. Our primary im-
plementation is in a new DNS proxy server. It provides
a minimally invasive approach that allows us to test any
recursive resolver. It receives queries with all of the options
described here, then sends them to the real recursive resolver
via UDP. When the proxy and real resolver are on the same
machine or same LAN we can employ unfragmented 9 kB
UDP packets, avoid size limitations and exploiting existing
OOOP for UDP. It uses either the OpenSSL or GnuTLS
libraries.
In the long run we expect to integrate our methods into ex-
isting resolvers. We have implemented subsets of our approach
in BIND-9.9.3 and unbound-1.4.21.
III-D Gradual Deployment
Given the huge deployed base of DNS clients and servers
and the complexity of some implementations [79], any mod-
iﬁcations to DNS will take effect gradually and those who
incur cost must also enjoy beneﬁts. We discuss deployment in
detail elsewhere [86] since the length of full discussion forces
it outside the scope of this paper, but we summarize here.
T-DNS deployment
is technically feasible because our
changes are backwards compatible with current DNS deploy-
ments. TLS negotiation is designed to disable itself when
either the client or server is unaware, or if a middlebox
prevents communication. Approaches analogous to DNSSEC-
trigger [55] may be used to bootstrap through temporarily
interfering middleboxes, and can report long-term interference,
prompting middlebox replacement or perhaps circumvention
using a different port. In the meantime, individuals may select
between immediately correcting the problem or operating
with DNS privacy. DNS already supports TCP, so clients
and servers can upgrade independently and will get better
dataset
DNSChanger
all-to-one
all-to-all
DITL/Level 3
cns4.lax1
cns[1-4].lax1
DITL/B-root
date
2011-11-15
2012-04-18
2013-05-29
client IPs
records
15k
692k
282k
655k
3118k
19M
964M
781M
2412M
1182M
Table III: Datasets used to evaluate connection reuse and
concurrent connections. Each is 24 hours long.
performance with our implementation guidelines. T-DNS ben-
eﬁts from TCP extensions like fast-open that are only very
recently standardized [16], so T-DNS performance depends
their deployment (Fast Open is in Linux-3.7 since December
2012). Gradual deployment does no harm; as clients and
servers upgrade, privacy becomes an option and performance
for large responses improves.
Motivation for deployment stems from T-DNS’s privacy
and DoS-mitigation. Some users today want greater privacy,
making it a feature ISPs or public DNS-operators can promote.
The DoS-mitigation effects of TCP allows DNS operators to
reduce their amount of capacity overprovisioning to handle
DoS. T-DNS’s policy beneﬁts from size require widespread
adoption of TCP, but the penalty of slow adoption is primarily
lower performance, so complete deployment is not necessary.
T-DNS deployment is feasible and motivations exist for
deployment, but the need for changes to hardware and software
suggests that much deployment will likely follow the natural
hardware refresh cycle.
IV. CONNECTION REUSE AND RESOURCES
Connection reuse is important for T-DNS performance to
amortize setup over multiple queries (§ VI). Reuse poses a fun-
damental trade-off: with plentiful resources and strict latency
needs, clients prefer long-lived connections. But servers share
resources over many clients and prefer short-lived connections.
We next examine this trade-off, varying connection timeout
to measure the connection hit fraction, how often an existing
connection can be reused without setup, and concurrent con-
nections, how many connections are active on a server at any
time. We relate active connections to server resource use.
IV-A Datasets
We use three different datasets (Table III) to stand in for
stub clients, recursive resolvers, and authoritative servers in
our analysis. These datasets are derived from server logging
(Level3) or packet capture (the others). While more data
is always better, we believe our data captures very diverse
conditions and more data is very unlikely to change the
conclusions.
DNSChanger: DNSChanger is a malware that redirects
end-users’ DNS resolvers to a third party so they could
inject advertising. This dataset was collected by the working
group that, under government authority, operated replacement
recursive resolvers while owners of infected computers were
informed [51]. It includes timing of all queries from end-user
176176
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:44 UTC from IEEE Xplore.  Restrictions apply. 
IP addresses with this malware as observed at the working
group’s recursive resolvers. We use this dataset to represent
stub-to-recursive trafﬁc, and select trafﬁc to the busiest server
(all-to-one) in § IV-C and the trafﬁc from all sources to all
servers (all-to-all) in § VI-D. (We know of no public sources
of stub-to-recursive data due to privacy concerns.)
DITL/Level 3: Level 3 operates DNS service for their cus-
tomers, and also as an open public resolver [64]. Their
infrastructure supports 9 sites, each with around 4 front-end
recursive resolvers, each load-balanced across around 8 back-
end resolvers, as veriﬁed by the operators. We use their 48-
hour trace hosted by DNS-OARC [22].
We examine two subsets of this data. We ﬁrst select a
random site (lax1, although we conﬁrmed other sites give
similar results). Most client IP addresses (89%) access only
one site, so we expect to see all trafﬁc for each client in the
dataset (cns[1-4].lax1). Many clients (75%) only access
one front-end at a site, so we select the busiest front-end at
this site (cns4.lax1) to provide a representative smaller (but
still large) subset. We use these Level 3 traces to represent a
recursive resolver.