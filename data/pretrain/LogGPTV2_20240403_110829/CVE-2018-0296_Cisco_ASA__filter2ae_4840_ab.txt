由前面lua的相关知识可知，函数lua_touserdata()用于获取栈底数据。因此，很自然的想法就是分析这个NULL值是从哪里来的，即在什么地方通过调用lua_pushnil()往栈上压入了NULL值。
###  静态分析
通过查找字符串/+CSCOE+/files/file_list.json的交叉引用定位到aware_webvpn_content()函数。在该函数中可以看到有很多请求url的字符串，同时还包含很多lua脚本的名称，猜测该函数应该是负责对这些请求进行处理，根据不同的请求url执行对应的lua脚本。示例如下。
查看files_list_json_lua脚本的内容，其主要功能是列出当前路径下的目录或文件，依次调用了Lua中的OPEN_DIR()、READ_DIR()、FILE_NAME()、FILE_IS_DIR()等函数。而在aware_addlib_netfs()函数中，建立了Lua函数和C函数之间的对应关系，示例如下。
    // Lua函数与C函数对应关系
    OPEN_DIR()          webvpn_open_dir()
    READ_DIR()          webvpn_read_dir()
    FILE_NAME()             webvpn_file_name()
    FILE_IS_DIR()       webvpn_file_is_dir()
在查看对应的C函数时，在webvpn_read_dir()函数中，有一个对lua_pushnil()函数的调用。根据函数的调用顺序，猜测webvpn_file_name()函数中获取到的NULL值来自于这里。
###  动态分析
根据之前的猜测，尝试在调用lua_pushnil()处下断点，然后查看Lua栈上的数据，如下。
其中，rdi指向的数据结构的定义大致如下，这里主要关注其中的lua_stack_top_ptr和lua_stack_base_ptr两个指针，分别指向Lua栈的栈顶和栈底，栈中的元素就是前面提到的{类型，值}结构。
    struct {
        uint64 xxx;
        uint64 xxx;   
        uint64 lua_stack_top_ptr;    // 指向栈顶   (空栈，即始终指向刚入栈元素的下一个位置)
        uint64 lua_stack_base_ptr;   // 指向栈底   (栈地址由低向高增长)
        uint64 xxx;
        uint64 xxx;
        uint64 xxx;
        uint64 xxx;
        ... 
    }
之后在webvpn_file_name()中调用lua_touserdata()函数前下断点，查看此时Lua栈上的内容，如下。此时，lua_touserdata()函数的第2个参数为1，即获取Lua栈底的数据，而此时栈底的数据为NULL。
继续单步执行程序，查看函数lua_touserdata()的返回值。可以看到，其返回值确实为NULL，之后将一个非法内存地址0x13作为参数传入了lua_pushstring()，最终导致Segmentation
fault错误。
但是，这里的NULL值并不是来自之前lua_pushnil()压入的nil值，而是位于其下面的栈元素。在下断点调试的过程中，发现设置的2个断点均只命中一次就触发了问题，极大地缩小了调试的范围。同时，在2个断点处Lua栈的地址是一样的，因此可以在第1个断点命中后，对相应的Lua栈地址设置硬件断点，看在哪个地方对其值进行了修改。
在gdb中设置硬件断点后，继续执行时提示如下错误。网上查找相应的解决方案，建议使用set can-use-hw-watchpoints
0，但实际测试时貌似也存在问题。最后采用hook-stop的方式来观察指定地址处的内容。
    define hook-stop
        x/2gx 
    end
通过设置断点并查看相应地址处的内容，最终定位到修改内容的地方位于luaV_execute()中。对照lua-5.0源码，luaV_execute()函数是Lua
VM执行字节码的入口，修改内容的地方位于OP_GETGLOBAL操作码的处理流程中。
###  asav962与asa924执行流程对比
前面的分析定位到了luaV_execute()函数中，而该函数属于Lua
VM的一部分，难道是因为files_list_json_lua脚本存在问题，而导致Lua
VM执行字节码时出现错误？由于该拒绝服务漏洞对型号为asa924的设备没有影响，下面对asa924设备上对应的执行流程进行分析。
根据前面的分析思路，在webvpn_file_name()中设置断点，发现其流程与asav962类似，lua_touserdata()函数的返回值同样会为NULL，而asa924设备却不会发生崩溃。2个webvpn_file_name()的对比如下。
通过调试可知，针对32位程序(asa924)，lua_touserdata()函数的返回值为指向字符串的指针。当该指针为空时，其直接作为参数传入lua_pushstring()，而在lua_pushstring()中会对参数是否为空进行判断。而针对64位程序(asav962)，lua_touserdata()函数的返回值为指向某个结构体的指针。当该指针为空时，传入lua_pushstring()的参数为0x13，从而”绕过“了lua_pushstring()中的校验，最终造成非法内存地址访问。
至此，分析清楚了该拒绝服务漏洞产生的原因，主要是由于32位程序和64位程序中lua_touserdata()函数的返回值代表的结构不一致造成的。
## 补丁分析
在镜像asav9101.qcow2中该漏洞被修复了。基于前面对漏洞形成原因的分析，下面以asav9101.qcow2镜像为例，对漏洞的修复情况进行简单分析。
###  目录遍历漏洞补丁分析
通过动态调试分析，对请求url的解析在UrlSniff_cb()函数中完成，其中增加了对./和../的处理逻辑，部分代码如下。
    v16 = *v5;    // v5 指向请求url
    v17 = v5;
    v18 = v5;
    LABEL_45:
    while ( v16 )
    {
    if ( v16 == '.' )
    {
        v20 = v18[1];
        switch ( v20 )
        {
        case '.':
            v9 = (unsigned __int8)v18[2];
            if ( !(_BYTE)v9 )
            goto LABEL_75;
            if ( (_BYTE)v9 == '/' )
            {
            v20 = v18[3]; // 匹配到"../"
            v18 += 2;
    LABEL_75:
            ++v18;
            v16 = v20;
            goto LABEL_45;
            }
            break;
        case '/':
            v16 = v18[2]; // 匹配到"./"
            v18 += 2;
            goto LABEL_45;
        case '\0':
            ++v18;
            goto LABEL_60;
        }
        do
        {
    LABEL_48:
###  拒绝服务漏洞补丁分析
根据前面的分析可知，拒绝服务漏洞的触发位置在函数webvpn_file_name()中。在镜像asav9101.qcow2中，该函数内容如下，可以看到并没有对该函数进行更改。
    webvpn_file_name proc near
    ; __unwind {
    push    rbp
    mov     esi, 1
    mov     rbp, rsp
    push    rbx
    mov     rbx, rdi
    sub     rsp, 8
    call    lua_touserdata
    mov     rdi, rbx
    lea     rsi, [rax+13h]
    call    lua_pushstring
    add     rsp, 8
    mov     eax, 1
    pop     rbx
    pop     rbp
    retn
    ; }
在字符串列表中查找/+CSCOE+/files/file_list.json显示没有结果，表明在该镜像中将这个接口去掉了。同时根据之前files_list_json_lua脚本的内容进行查找，在该镜像中仍然可以找到对应的lua脚本内容，但是找不到对该脚本的交叉引用，进一步证实该接口/+CSCOE+/files/file_list.json被去掉了。
## 小结
  * 利用CVE-2018-0296漏洞，远程未认证的攻击者可以对目标设备实施拒绝服务攻击，或从设备获取敏感信息。
  * 拒绝服务漏洞的形成原因是由于32位程序和64位程序中lua_touserdata()函数的返回值代表的结构不一致造成。
  * 在镜像asav9101.qcow2中已经修复了该漏洞，其中拒绝服务漏洞的修复方式是去掉了触发了该漏洞的请求url接口。
## 相关链接
  * [Cisco Adaptive Security Appliance Web Services Denial of Service Vulnerability](https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20180606-asaftd)
  * [Error description CVE-2018-0296 – bypassing authentication in the Cisco ASA web interface](https://sekurak.pl/opis-bledu-cve-2018-0296-ominiecie-uwierzytelnienia-w-webinterfejsie-cisco-asa/)
  * [Cisco Adaptive Security Appliance – Path Traversal](https://www.exploit-db.com/exploits/44956)
  * [Test CVE-2018-0296 and extract usernames](https://github.com/milo2012/CVE-2018-0296)
  * [Lua和C++交互详细总结](http://www.cnblogs.com/sevenyuan/p/4511808.html)
  * [网络设备漏洞分析技术研究](https://www.freebuf.com/articles/system/114741.html)
  * [Cisco ASA series part one: Intro to the Cisco ASA](https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2017/september/cisco-asa-series-part-one-intro-to-the-cisco-asa/)