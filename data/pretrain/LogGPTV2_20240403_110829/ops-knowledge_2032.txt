User: 请回答以下安全问题如何安全地散列密码？如果我在将密码存储在数据库中之前对其进行散列，这足以防止任何人恢复密码吗？
我应该指出的是，这只涉及直接从数据库中检索，而不是任何其他类型的攻击，例如粗暴地修改应用的登录页面、客户端上的键盘记录程序，当然还有橡胶软管密码分析（或者现在我们应该称之为“巧克力密码分析”）。
当然，任何形式的散列都无法阻止这些攻击。

Assistant: 注：此答案写于2013年。在接下来的几年里，许多事情都发生了变化，这意味着这个答案应该主要被视为2013年的最佳实践。
理论
我们需要散列密码作为第二道防线。可以对用户进行身份验证的服务器必然在其内部的某个地方包含一些可以用于验证密码的数据。一个非常简单的系统只需存储密码本身，而验证则是一个简单的比较。但是，如果一个怀有敌意的局外人能够简单地看到包含密码的文件或数据库表的内容，那么攻击者就会学到很多。不幸的是，这种部分只读漏洞在实践中确实会发生（错误放置的备份磁带、已退役但未被擦除的硬盘、SQL注入攻击的后果——可能性有很多）。有关详细讨论，请参阅此博客文章。
由于能够验证密码的服务器的整体内容必然足以验证密码，因此获得服务器只读快照的攻击者可以进行离线字典攻击：他会尝试潜在的密码，直到找到匹配的密码。这是不可避免的。因此，我们希望尽可能地进行这种攻击。我们的工具如下：
加密散列函数：这些都是令人着迷的数学对象，每个人都可以有效地计算，但没有人知道如何将它们反转。对于我们的问题，这看起来很好——服务器可以存储密码的哈希；当提供一个假定的密码时，服务器只需要对其进行散列，看看它是否得到相同的值；然而，知道散列并不能揭示密码本身。
盐：进攻方相对于防守方的优势之一是平行性。攻击者通常会获取一整列哈希密码，并有兴趣破坏尽可能多的密码。他可能试图同时攻击几个人。例如，攻击者可能会考虑一个潜在的密码，对其进行散列，然后将该值与100个散列后的密码进行比较；这意味着攻击者分担对多个受攻击密码进行哈希运算的成本。类似的优化是预计算表，包括彩虹表；这仍然是平行的，具有坐标的时空变化。
所有使用并行的攻击的共同特征是，它们处理的是使用完全相同的哈希函数处理的多个密码。Salting不是使用一个散列函数，而是使用许多不同的散列函数；理想情况下，每个密码哈希实例都应该使用自己的哈希函数。salt是在一大类散列函数中选择特定散列函数的一种方法。正确施用盐将完全阻止平行攻击（包括彩虹表）。
缓慢：随着时间的推移，计算机会变得更快（英特尔联合创始人Gordon Moore在其著名的定律中对此进行了理论推导）。人类的大脑则不然。这意味着，随着时间的推移，攻击者可以“尝试”越来越多的潜在密码，而用户无法记住越来越复杂的密码（或断然拒绝）。为了应对这一趋势，我们可以通过定义哈希函数来使用大量内部迭代（数千次，可能数百万次），从而使哈希天生就很慢。
我们有一些标准的加密散列函数；最著名的是MD5和SHA家族。从基本操作构建一个安全的散列函数绝非易事。当密码学家想要做到这一点时，他们会认真思考，然后更加努力，并组织一场比赛，让各个功能相互激烈竞争。当数百名密码学家在一个函数上咬了几年、刮了几次、打了几次，却没有发现什么不好的地方时，他们开始承认，也许这个特定的函数或多或少可以被认为是安全的。这就是SHA-3比赛中发生的事情。我们必须使用这种方法来设计哈希函数，因为我们不知道更好的方法。从数学上讲，我们不知道安全散列函数是否真的存在；我们只有“候选者”（这就是“它不能被打破”和“世界上没有人知道如何打破它”之间的区别）。
基本的散列函数，即使作为散列函数是安全的，也不适用于密码散列，因为：
它是无盐的，允许并行攻击（MD5或SHA-1的彩虹表可以免费获得，您甚至不需要自己重新计算）；
它太快了，而且随着技术的进步速度越来越快。对于最近的GPU（即每个人都可以购买的现成消费品），哈希率以每秒数十亿个密码为单位。
所以我们需要更好的东西。碰巧的是，将哈希函数和salt组合在一起并迭代它并不比设计哈希函数更容易——至少，如果你希望结果安全的话。再说一遍，你必须依赖标准结构，这些标准结构在证明密码学家的持续攻击中幸存下来。
良好的密码哈希功能
PBKDF2型
PBKDF2来自PKCS#5。它由迭代计数（整数，至少1，没有上限）、salt（任意字节序列，没有长度限制）、所需输出长度（PBKDF2可以生成可配置长度的输出）和“底层PRF”参数化。在实践中，PBKDF2总是与HMAC一起使用，HMAC本身就是在底层哈希函数上构建的结构。因此，当我们说“PBKDF2与SHA-1”时，我们实际上是指“PBKDF_2与HMAC与SHA-1一起”。
PBKDF2的优点：
已经被指定了很长一段时间，现在似乎毫发无损。
已经在各种框架中实现（例如，它由.NET提供）。
高度可配置（尽管有些实现不允许您选择散列函数，例如.NET中的散列函数仅适用于SHA-1）。
收到NIST的祝福（对哈希和密钥推导之间的差取模；见下文）。
可配置的输出长度（再次参见下文）。
PBKDF2的缺点：