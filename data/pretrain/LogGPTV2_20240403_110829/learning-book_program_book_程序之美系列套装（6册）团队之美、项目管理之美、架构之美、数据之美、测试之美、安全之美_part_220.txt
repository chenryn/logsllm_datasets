产生副作用的函数，那么这一结论就无法确保了。这对于自动化验
证工具（能够检查函数是否会产生副作用）而言并不困难，实际上
是对于人类读者而言有困难。
确保表达式的引用透明是个很合乎大家希望的目标。不过，这正说
明将与状态相关的表示法从计算模型中分离出来是合理的。在此回
是很重要的。在这个方法中，类的特性（操作）可以清晰地分成两
类：一类是命令，它能够修改目标对象以及它的状态：另一类是查
询，它能够提供与对象相关的信息。命令不会返回结果：查询不会
改变状态，换句话说，它们满足引用透明原则。在先前的列表示例
中，start、forth和finish（针对有限列表）都是命令；item、index、
count、before和after（针对有限列表）都是查询。该规则排除了很
多通过调用函数获取一个结果并修改其状态的太过于常见的模式，
我估计这就是对命令式编程不满意的实际根源，它比先通过一个命
令来修改状态，再通过一个（没有副作用的）查询来获取信息更令
人烦恼。该原则也先可这样描述：“提问时不修改答案。”例如，它
意味着一个典型的输入操作应该写成：
io.read_character
Result: =io.last_character
在此read_character是一个命令，它将从输入中获得一个字符：而
lastcharacter则是一个查询，将返回最后读取的字符（它们都是基
本I/O程序库提供的特性）。紧接着调用last_character将确保返回相
同的结果。不管是哪里提到的，不管是出于理论还是实践的角度
（Meyer1997），命令-查询分离原则都是一种方法性规则，而非语
言本身的特性，但所有慎重的Eiffel软件并发过程中都会遵从这一原
则，以获得引用透明的优点。尽管其他面向对象编程流派未能应用
1241
---
## Page 1243
它（继续采用C风格的函数调用，而没有专门完成修改的程序），
但在我们看来这是面向对象方法中很关键的原则。它看起来也是在
函数式编程中实现引用透明的可行方法，由于只涉及查询的表达式
不会修改状态，因此可以被理解为传统的数学公式可函数式的语
言。而在建模系统和计算中状态的概念，则通过命名表示法来完
成。
13.4面向对象视图
对象的架构。
13.4.1组合子很好，但类型更好
迄今为止，我们处理的都是操作和组合子。操作我们将保留，而关
键的步骤是抛弃组合子，并将它们替换成类型（或者称为类，它们
的区别是由泛型带来的）。它将明显地提升抽象等级：
一种组合子描述了基于原有的机制构建新机制的特定方法。组合是
以很严格的方式定义的：与一个名为take的组合子（如take3
apple）关联的是一个数量元素和一个食物元素。正如前面所说的，
它和数学公式很像，是按照精确的实现过程定义的结构。
一个类定义了一个对象类型，它将列出所有可应用的特性（操
作）。它提供了抽象数据类型意义上的抽象：它不仅定义了由什么
内容构建，还定义了相应对象可应用的操作。我们可以从中领会数
据抽象和面向对象设计的原则，采用这种方法意味着不仅知道对象
是什么，还知道它有什么（它们公共的特性和相关的契约）。这同
样提供了对各种类型继续进行分类的方法，或称之为继承，它一方
面能控制模型的复杂度，同时还能充分发挥不同类型存在共性的优
势。
从第一种方法改成第二种方法，我们并不会丢失任何东西，因为类
可以很容易将组合子当作一种特殊的情况来考虑。它完全能够为指
定要素提供所需的特性，并提供能够构建正确对象的相关创建程序
（构造函数）。我们来看一个例子：
class REPETITION create
1242
---
## Page 1244
ma ke
feature
base: FOOD
quantity: REAL
make (b: FOOD: q: REAL)
-用quantity个base生成该food元素。
ensure
base=b
quantity=g
end
...Other features.
end
这样我们可以通过创建apple_salad.make（6.0，apple）来获取一个
该类型的对象，它和使用组合子的表示式是等价的。
13.4.2使用软件契约和泛型
由于我们只关注设计，因此其效果实际上已经通过后置条件的形式
表示了，但它对于引用实现语句（dobase：=b；quantity：=q）而
言，实际上并不是什么问题。它对于易于理解的面向对象设计而言
是很重要的，它能够缩短实现与设计（以及规约）之间的距离。在
所有这些方面，我们可以自由地使用会修改状态的赋值指令，并仍
然（在此感谢读者的提问）拥有完整的功能。
不过，类和组合子不同，它的功能并不限于这些。例如，它可以拥
有其他创建程序。一种很常见的现象就是将两个相同的东西混合在
一起：
make (r1, r2: REPETITION)
1243
---
## Page 1245
-通过合成r1和r2生成该food元素。
require
r1.base=r2.base
ensure
base=rl.base
quantity=q
后置条件表达式说明了和相同基本食物类型混合的数量。这样的需
求也可以通过该类型系统以静态的形式实现；使用泛型（在类型化
的函数式语言中也实现了，不过其名称会令人感到好奇，即“参数
化多态”）将使类的定义变成：
class REPETITION[FOOD] create
...和之前一样.
feature
make (r1, r2: REPETITION[FOOD])
...在此不一定需要预言.
...其他部分和之前一样
end
类不仅可以有不同类型的创建程序，还可以拥有更多特性。具体来
说，我们之前程序中的操作都可以变成相应类的特性。（读者可能
会猜到，变量名t将变成类型，而f将变成特性。）对于pudding类
（包括用来描述诸如REPETITION等食物类型的类）而言，将拥有
诸如sugar、calorie_content等特性；而对于contract类而言，则将拥有
如horizon、value等特性。在此有两点需要说明：
由于我们是从纯函数式模型开始的，因此迄今为止提到的所有特性
要么是创建程序，要么是查询。虽然也可以在面向对象框架中保留
这种函数式的风格，但在并发中也可能需要引入命令。例如，因响
1244
---
## Page 1246
应特定事件（诸如重新协商）而对金融契约所做的修改。而是否需
要维护状态的问题，实际上与模块化的讨论是不相关的。
·最初，value函数是遵从于一个无限序列的。我们可以通过使用
COUNTABLE类型来保留这一签名，并允许执行延迟计算：或者我
们可以提供一个整型的参数，因此value（i）返回的值将是第i个
值。
13.4.3模块化策略
迄今为止所实现的模块化，阐述了面向对象技术的本质想法（至少
是我们找到的本质想法之一）：将类型和模块的概念合并起来
（Meyer，1997）。用最简单的话来说，那就是面向对象分析、设
计和实现意味着我们基于的每个模块都是系统维护的一种类型的对
象。它与其他方法提供的模块化设施相比，这是一个限制更多的原
则：一个模块不再是一个软件元素（如操作、类型、变量）的简单
结合体，设计师在组合这些时要基于一些合理的标准；它们是一种
类型实例所能接受的属性和操作的集合。
类就是这种类型-模块合并的产物。在诸如Smalltalk、Eifel和
C#（不仅限于这些，例如还有C++或Java）等面向对象语言中，这
种合并是双向的：不仅仅是类定义了一种类型（例如一种类型模
板，或者使用了泛型），反过来任何类型（包括诸如整型之类的类
型）也都被定义成了类。
如果想使类只保留类型的角色，并使其完全与模块化结构分离开，
这也是可能的。诸如OCaml之类的函数式语言是一个特例，它不仅
提供了传统的模块结构，也从面向对象编程中吸纳了类型机制。
（Haskell也类似，只不过对类这一概念提供了更多的限制。）反过
来，也可以去除所有类型都必须定义为类的限制，例如在C++和
Java中，诸如整型（Ininter）之类的基本类型就不是类。从对象技术
的视角上看，是假定它们完全合并了，另外理解更高层面的类分组
机制（诸如Java和.NET中的包，Eiffel中cluster）也是必要的，但这
些机制更多着眼于组织的便利，而非基础性的程序构造。
该方法意味着在定义软件架构时，类型优先于函数。其模块化标准
是类型，每个操作（函数）将放在一个类中，反之则不亦然。不
过，函数也通过抽象数据类型原则的应用反戈一击：当定义了一个
类之后，要理解其他信息，可以通过一个抽象接口（API）列出可
1245
---
## Page 1247
应用的操作，以及其定义的语义属性（契约：前置条件、后置条
件，以及针对整个类的不变量）。
这种模块化策略的基本原理是遵从更好的模块性原则，包括可扩展
性、可复用性以及可靠性（通过使用契约实现）。不过，我们必须
检查这些承诺对于我们的示例而言是正确的。
13.4.4继承
面向对象方法对于模块性目标的最本质贡献是继承。我们预期本书
的读者对该技术很熟悉，在此将只回顾一些基本的观点，并勾画其
在我们示例中可能的应用方法。
继承采用了“分类法"来组织类，大概可以表示为"is-a"关系，类之间
的基本关系还有一种名为"客户”（client）的关系，它表示某类将通
过其API（包括操作、签名、契约）来使用该类。继承通常是不遵
从信息隐藏原则的，它是一种恰好相反的"is-a"视图。尽管有些作
者只针对纯子类型使用继承，但实际上如果用它来实现标准的模块
包含机制也是没有问题的。比董l实际上就提供了“非一致性继承"机
制（EcmaInternational，2006），它失去了多态的支持，但保留了
继承的其他特性。继承的这种双角色与类的双角色（类型和模块）
特性是相吻合的。
不管是哪一种，继承都是用来捕获类之间的共性的。对于与布丁相
关的元素进行分类，可以用如图13-3所示的继承图来表示。
1246
---
## Page 1248
Pudding
PUDDINGPART
inheritance
PUDDING
REPETITION
LIST
客户
FRUIT_SALAD
+