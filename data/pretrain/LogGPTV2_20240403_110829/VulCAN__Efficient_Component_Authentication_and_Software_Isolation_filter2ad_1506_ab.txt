### 3.1 Attacker Model

The adversary's objective is to impersonate a protected component connected to the CAN (Controller Area Network) network. More specifically, the attacker aims to deceive a receiver component into accepting a CAN message with a chosen ID and payload, as if it originated from a legitimate sender component. We address attackers with two critical capabilities: arbitrary message manipulation and arbitrary code execution.

**Arbitrary Message Manipulation.** Consistent with prior research [15, 18, 34, 38, 46], we consider an attacker who has gained remote access to the car's internal network without physical access. For example, the attacker might infiltrate an ECU (Electronic Control Unit) through one of the many wireless interfaces in a modern automobile [8, 10]. This provides the attacker with the ability to:
- Broadcast their own CAN messages with any ID and payload.
- Observe and record all traffic on the CAN bus.
- Intentionally destroy or modify packets as they pass by.

Due to the inherent broadcast nature of the shared CAN bus, denial-of-service attacks are out of scope.

**Arbitrary Code Execution.** Existing CAN authentication proposals and vehicular hardware security modules [49] typically assume that the adversary has not compromised the ECU for which they intend to forge packets. However, it has been repeatedly shown that automotive software and update mechanisms are vulnerable to a wide range of attacks [10, 22], allowing an adversary to execute their own code on individual ECUs. Therefore, we model an attacker with the capability to execute arbitrary code on every ECU in the network. This means the attacker can compromise all software, including privileged operating system support software, except for the trusted authenticated software components explicitly protected by Sancus.

### 3.2 Problem Statement

We clearly define the requirements and challenges for trustworthy component authentication on an unmodified CAN bus. These requirements are divided into protocol and system requirements. The former are reflected in the design of the CAN authentication protocol, while the latter concern the actual ECUs that implement and participate in the authenticated communication. Based on previous research [34, 38], we have identified the following protocol requirements:

**P1: Message Authentication.** A receiver component should have a strong guarantee that a message with a specified ID and payload was indeed sent by a trusted sender component.

**P2: Lightweight Cryptography.** Public key cryptography is not feasible due to the severe computational and storage constraints of typical ECUs.

**P3: Replay Attack Resistance.** The authentication scheme should be immune to replay attacks, even when a large amount of traffic has been captured.

**P4: Backwards Compatibility.** The authentication scheme must be compatible with existing off-the-shelf CAN transceiver chips. Legacy applications without authenticated communication should continue to function.

While the above requirements are met by at least two recent CAN authentication protocols [34, 38], we argue that a practical and trustworthy solution should also offer the following system-level guarantees, which are not achieved by state-of-the-art authentication schemes:

**S1: Real-Time Compliance.** The CAN bus is widely used for safety-critical functions such as brakes and steering, necessitating a fast authentication scheme that preserves stringent real-time deadlines when not under attack.

**S2: Component Isolation.** The integrity of message processing and authentication algorithms, and the confidentiality of key material, should be protected against an attacker with arbitrary untrusted code execution on participating ECUs.

**S3: Component Attestation.** When starting the car and while driving, the driver should have a strong guarantee that critical software components have been loaded on specific ECUs with isolation enabled (S2), and without having been tampered with.

**S4: Dynamic Key Update.** The system should support secure key provisioning at runtime and allow broken ECUs to be replaced by a distrusted automobile repair shop. Extracting keys from one ECU should not compromise message authentication (P1) for uninvolved components.

**S5: Secure Legacy ECU Integration.** Automotive suppliers cannot be expected to adopt hardware/software changes immediately on all ECUs that require authentication. It should be possible to transparently shield unmodified legacy ECUs as a transition measure.

### 3.3 Authenticated CAN Bus

Before explaining how we achieve the strong system-level software security guarantees (S1–S5), we first elaborate on our protocol requirements (P1–P4). We carefully selected these requirements to ensure they can be fulfilled by any AUTOSAR [3] compliant authentication protocol. The VulCAN approach is inspired by and remains largely compatible with two such proposals: vatiCAN [34] and LeiA [38].

**Message Authentication (P1–P4).** As explained in the background section, CAN follows a publish-subscribe broadcast model where prioritized 11-bit IDs (optionally enlarged with an 18-bit extended identifier) are associated with a data payload of up to 64 bits. However, CAN does not reserve bandwidth for authentication metadata. Our requirement for backwards compatibility (P4) with existing CAN transceivers rules out previous research [15, 46] that leverages the extra bandwidth provided by the CAN+ extensions (cf. Section 7).

Following the approach of vatiCAN and LeiA, we decouple the authentication metadata from the actual message to be authenticated. Specifically, we first broadcast the authenticated message in plain text, and then construct and transmit authentication data on a different CAN identifier, to which only authentication-aware receiver components subscribe. This scheme ensures compatibility with unmodified legacy applications that do not rely on message authentication (P4).

To satisfy requirements (P1, P2), we associate a symmetric 128-bit cryptographic key with each authenticated CAN identifier. Like vatiCAN, but in contrast to LeiA, our design allows multiple IDs to share the same key to reduce memory consumption costs, if desired (P2). Valid sender/receiver components use the key to construct a 64-bit Message Authentication Code (MAC) over both ID and payload (P1), including a monotonically increasing counter to protect against replay attacks (P3). Specifically, to authenticate a message with identifier \( i \), payload \( p \), and counter \( c_i \), we compute:

\[
m = \text{MAC}(key_i, (i | p | c_i))
\]

Note that, if \( key_i \) is truly unique per identifier (as in the LeiA specification), \( i \) should not be included in the above message, as it is implicitly authenticated through the key. After calculating the MAC, the sender transmits it as the payload of a separate CAN message with ID \( i + 1 \). This scheme practically avoids priority inversion problems, as CAN identifiers are also used as priority indicators during bus arbitration. If the CAN identifier \( i + 1 \) is already in use by the legacy application (P4), a different application-specific authentication ID must be selected.

**Nonce Initialization (P3, P4).** Requirement (P3) demands that replaying a previously authenticated message should result in its rejection by the receiver. To this end, our authentication scheme includes a monotonically increasing counter or nonce \( c_i \) as a source of freshness in the MAC computation for a message with identifier \( i \). Identical nonce values should never be reused under the same key and associated data, presenting two important challenges: (i) nonce initialization on platform reset or \( c_i \) counter overflow, and (ii) nonce resynchronization on packet loss.

A common way to address the first challenge, nonce initialization, is the use of short-term session keys [38, 46]. At system boot time, or whenever the session counter \( c_i \) overflows, both parties generate a fresh session key based on the long-term pre-shared secret and a larger epoch counter. With this scheme, individual session counters \( c_i \) can safely start from zero. Session keys thus reduce the burden of secure nonce management for multiple sessions to secure persistent storage of a single long-term key and epoch counter per connection per ECU. Our final key provisioning scheme (S4) further relaxes this requirement to secure persistent storage capacity on a single trusted ECU, leveraging trusted computing features as discussed in more detail in Section 3.4.

**Nonce Resynchronization (P3, P4).** Receiver ECUs must handle packet loss, as they may miss a message or authentication frame, for instance, when in sleep mode or under heavy network load. Due to the periodic broadcast nature of typical CAN applications, legacy receivers can easily recover from such failures. On an authenticated CAN bus, subsequent MAC comparisons will fail if sender and receiver nonces get out of sync. Note that nonce values \( c_i \) are not confidential, and receivers can accept MACs generated with any nonce that is strictly higher than the previously authenticated nonce value. As such, packet loss could be anticipated by including the plaintext sender nonce as part of the authentication payload, but our 64-bit MACs (P1) leave no free space in a standard CAN frame. Depending on the application, some unused parts of the message payload might be used to encode (the least significant bits of) the nonce, as suggested by AUTOSAR [3]. As a more general solution, VulCAN leaves nonce resynchronization choices to the underlying protocol being used.

Our vulcanized LeiA [38] implementation encodes relatively small 16-bit nonces in the extended CAN identifier field and re-establishes session keys on nonce counter overflow. This allows receiver components to easily recover after missing one or more authenticated messages. Furthermore, to recover from longer-term network failures, a genuine receiver can send a dedicated error frame that prompts a sender to broadcast its current epoch counter value. Note, however, that LeiA might partially break legacy applications (P4) that rely on the availability of extended CAN identifiers. For example, the vehicle instrument cluster discussed in Section 6 utilizes at least one extended CAN identifier. Our experimental evaluation (Section 5) also reveals that LeiA’s use of extended identifiers comes with a performance penalty.

An alternative approach to dealing with packet loss is provided by the vatiCAN [34] protocol, which uses larger 32-bit nonces but relies on a trusted global Nonce Generator (NG) component to periodically reset nonces in the entire network. Specifically, every few milliseconds, NG broadcasts a randomly chosen value to be used by all participating ECUs as the new initial value for all counters \( c_i \). NG is assumed to use a modified CAN transceiver, equipped with hypothetical (P4) hardware-assisted spoofing prevention, so an attacker cannot inject arbitrary nonce renewal requests. We show in Appendix A, however, that vatiCAN’s frequent random nonce renewal design is vulnerable to advanced replay attacks based on the (generalized) birthday problem from probability theory. Depending on the targeted application, our attacks allow an adversary to start replaying authenticated messages after recording as little as 30 minutes of broadcast CAN traffic. Our vulcanized vatiCAN implementation therefore omits global nonce generation and properly uses session keys, as discussed above, to ensure the same \( c_i \) value is never reused under the same cryptographic key.

**Efficient MAC Computation (S1).** Recall that the payload of an authenticated CAN message is sent first, before the actual authentication frame containing the MAC. The vatiCAN [34] authors leverage this property to compute MACs in parallel at both the sender and receiver ECUs. The sender first broadcasts message \( m \) to be authenticated and subsequently computes and sends the corresponding MACs. As soon as \( m \) has arrived, the receiver starts computing \( \text{MAC}_r \), which is then compared to \( \text{MAC}_s \) to authenticate \( m \). While such parallel MAC computation cuts authentication overheads by half, current software-only solutions still require several milliseconds to compute a single 64-bit MAC [34].

Our Sancus-based VulCAN implementation, on the other hand, computes Eq. (1) using Sancus’ [31, 33] hardware-level authenticated encryption primitive. We configured our Sancus cores with 128 bits of security, resulting in 128-bit message authentication tags. To overcome CAN payload length limitations, we truncate the resulting MAC by discarding the eight least significant bytes. This approach adheres to the relevant AUTOSAR specification that recommends using a key length of at least 128 bits but also states that MAC truncation can be beneficial. In general, MAC sizes of 64 bits and above are considered to provide sufficient protection [3]. An important advantage of using hardware-level cryptography is that MAC computation times decrease by an order of magnitude, as further explored in the evaluation section. We consider such acceleration crucial to meet stringent real-time automotive safety requirements in benign conditions (S1).

### 3.4 Component Isolation and Authentication

In this section, we elaborate on our system-level requirements (S2–S5) that transform a conventional entangled vehicle network into a minimal set of small and robust application components that mutually authenticate and trust each other.

**Software Isolation and Key Storage (S2).** The security of any authentication scheme critically relies on maintaining key confidentiality. Previous automotive security proposals [15, 34, 38, 46] invariably assume uncompromised sender/receiver ECUs, neglecting advanced attacker capabilities. Our strengthened attacker model, on the other hand, considers adversaries with arbitrary ECU code execution, meaning any cryptographic key material that is not explicitly protected against untrusted system software can be trivially extracted. We therefore leverage PMA (Protected Memory Area) protection to create isolated "safe harbors" for constructing and processing authenticated CAN messages.

VulCAN reduces the TCB (Trusted Computing Base) by explicitly distrusting management software, including the CAN driver. Instead, authenticated CAN messages are constructed and verified within a Sancus PM (Protected Module), ensuring connection keys never leave the private data section. Critical application software that reacts upon authenticated messages is further included in the PM protection domain, assuring its untampered execution (S2). Moreover, the protected application logic can integrate dedicated driver PMs to securely sense or actuate I/O devices, as explained in Section 2.2. This setup creates a distributed trusted path from a brake pedal sensor to a brake actuator component, without having to trust any of the unprotected support software that processed the message on sender/receiver ECUs. The unprotected software components involved in relaying the message may be strictly necessary from a functionality and availability perspective, but they are not involved in implementing the security properties of the application. Thus, our solution effectively guarantees that any braking action at the receiver PM can be traced back to the sender PM that originally sensed the driver’s brake pedal. As such, vulcanized CAN components significantly reduce the TCB, making them more suitable for safety and security certification and well within reach of formal software verification techniques [37].

**Software Attestation and Key Provisioning (S3, S4).** The above guarantees are only maintained after PM-authenticated components have been correctly isolated and provisioned with symmetric cryptographic keys. Since PMs are not persisted across reboots, an attacker initially has full control over every ECU in the network when the car is turned on. This presents three closely related challenges: (i) attesting the integrity of critical distributed software components, (ii) establishing session keys over the untrusted CAN bus, and (iii) replacing broken ECUs in an untrustworthy automobile repair shop.

To overcome these challenges, the VulCAN design includes a trusted Attestation Server (AS) that engages in a remote attestation protocol with individual PMs. Specifically, AS possesses the Sancus module-specific 128-bit key \( K_{PM} \) of every authenticated software component in the network, ensuring that a particular PM has been isolated on a specific ECU without having been tampered with.