the desired security guarantees.
3.1 Attacker Model
The adversary’s goal is to impersonate a protected component
connected to the CAN network. More specifically, she wants to trick
a receiver component into accepting a CAN message with chosen ID
and payload, as if it originated from a valid sender component. We
protect against attackers with two important capabilities, namely
arbitrary message manipulation, and arbitrary code execution.
Arbitrary Message Manipulation. Analogous to previous work [15,
18, 34, 38, 46], we consider an attacker without physical access, but
who has successfully gained remote access to the car’s internal
network. She might for instance infiltrate an ECU over one of the
numerous wireless interfaces in a modern automobile [8, 10]. This
gives her the ability to (i) broadcast her own CAN messages with
ACSAC’17, December 2017, San Juan, Puerto Rico, USA
Jo Van Bulck, Jan Tobias Mühlberg, and Frank Piessens
arbitrary ID and payload, (ii) observe and record all traffic on the
CAN bus, and (iii) intentionally destroy or modify packets as they
pass by. Due to the inherent broadcast nature of the shared CAN
bus, denial-of-service attacks are ultimately out-of-scope.
Arbitrary Code Execution. Existing CAN authentication propos-
als (cf. previous paragraph) as well as vehicular hardware security
modules [49] explicitly assume an adversary who has not compro-
mised the ECU for which she intends to fake packets. It has been
repeatedly shown, however, that automotive software and update
mechanisms are vulnerable to a wide range of attacks [10, 22] that
allows an adversary to execute her own code on individual ECUs.
We therefore model an attacker with arbitrary code execution on
every ECU in the network. This means she can compromise all
software (including privileged operating system support software),
except for the trusted authenticated software components that are
explicitly protected by Sancus.
3.2 Problem Statement
We precisely state the requirements and challenges for trustwor-
thy component authentication on an unmodified CAN bus. We
distinguish between protocol and system requirements. The first are
reflected in the design of the CAN authentication protocol, whereas
the latter concern the actual ECUs that implement and participate
in the authenticated communication. Closely following previous
research [34, 38], we identified the following protocol requirements:
P1: Message Authentication. A receiver component should get
a strong guarantee that a message with specified ID and
payload was indeed sent by a trusted sender component.
P2: Lightweight Cryptography. The use of public key cryptog-
raphy is ruled out, for typical ECUs are severely constrained
in computational power and storage space.
P3: Replay Attack Resistance. Packet loss should be anticipated,
but the authentication scheme should be immune to replay
attacks, even when a large amount of traffic was captured.
P4: Backwards Compatibility. The authentication scheme must
be compatible with existing off-the-shelf CAN transceiver
chips. Legacy unmodified applications without authenticated
communication should continue to function.
While the above requirements are mostly met by at least two recent
CAN authentication protocols [34, 38], we argue that a practical
and trustworthy solution should furthermore offer the following
system-level guarantees, which are not achieved by state-of-the-art
authentication schemes:
S1: Real-Time Compliance. While denial-of-service attacks are
explicitly out-of-scope, the CAN bus is widely used to initi-
ate safety-critical functionality such as brakes and steering,
necessitating a fast authentication scheme that preserves
stringent real-time deadlines when not under attack.
S2: Component Isolation. The integrity of message processing
and authentication algorithms, and the confidentiality of
key material should be protected against an attacker with
arbitrary untrusted code execution on participating ECUs.
S3: Component Attestation. When starting her car, and while
driving, the motorist should get a strong guarantee that
critical software components have been loaded on specific
ECUs with isolation enabled (S2), and without having been
tampered with.
S4: Dynamic Key Update. The system should support secure key
provisioning at runtime, and allow broken ECUs to be re-
placed by a distrusted automobile repair shop. Extracting
keys in one ECU should not compromise message authenti-
cation (P1) for uninvolved components.
S5: Secure Legacy ECU Integration. Automotive suppliers can-
not be expected to adopt hardware/software changes imme-
diately on all ECUs that require authentication. It should be
possible to transparently shield unmodified legacy ECUs as
a transition measure.
3.3 Authenticated CAN Bus
Before explaining how we achieve the strong system-level software
security guarantees (S1–S5), we first elaborate on our protocol
requirements (P1–P4). We carefully selected the latter such that
they can be fulfilled by any AUTOSAR [3] compliant authentication
protocol. The VulCAN approach is inspired by, and remains largely
compatible with, two such proposals: vatiCAN [34] and LeiA [38].
Message Authentication (P1–P4). As explained in the background
section, CAN follows a publish-subscribe broadcast model where
prioritized 11-bit IDs (optionally enlarged with an 18-bit extended
identifier) are associated with a data payload of up to 64-bit. How-
ever, CAN does not reserve bandwidth for authentication metadata.
Our requirement for backwards compatibility (P4) with existing
CAN transceivers rules out previous research [15, 46] that lever-
ages the extra bandwidth provided by the CAN+ extensions (cf.
Section 7). Following the approach of vatiCAN and LeiA, we there-
fore decouple the authentication metadata from the actual message
to be authenticated. More specifically, we first broadcast the authen-
ticated message in plain text, and afterwards construct and transmit
authentication data on a different CAN identifier, to which only
authentication-aware receiver components subscribe. This scheme
ensures compatibility with unmodified legacy applications that do
not rely on message authentication (P4).
To satisfy requirements (P1, P2), we associate a symmetric 128-
bit cryptographic key with each authenticated CAN identifier. Like
vatiCAN, but in contrast to LeiA, our design allows multiple IDs to
share the same key to reduce memory consumption costs, if desired
(P2). Valid sender/receiver components use the key to construct
a 64-bit Message Authentication Code (MAC) over both ID and
payload (P1), including a monotonically increasing counter to pro-
tect against replay attacks (P3). More specifically, to authenticate a
message with identifier i, payload p, and counter ci, we compute:
(1)
Note that, when keyi is truly unique per identifier (as in the LeiA
specification), i should not be included in the above message, since
it is implicitly authenticated through the key. After calculating the
MAC, the sender transmits it as the payload of a separate CAN
message with ID i + 1. This scheme practically avoids priority
inversion problems, for CAN identifiers are also used as priority
indicators during bus arbitration. In case, however, that the CAN
identifier i + 1 is already in use by the legacy application (P4), a
different application-specific authentication ID has to be selected.
m = MAC(keyi , (i | p | ci))
VulCAN: Vehicular Component Authentication and Software Isolation
ACSAC’17, December 2017, San Juan, Puerto Rico, USA
Nonce Initialization (P3, P4). Requirement (P3) demands that re-
playing a previously authenticated message should result in that
message being discarded by the receiver. To this end, our authenti-
cation scheme Eq. (1) includes a monotonically increasing counter
or nonce ci as a source of freshness in the MAC computation for a
message with identifier i. Identical nonce values should never be
reused under the same key and associated data, however, which
provides us with two important challenges: (i) nonce initialization
on platform reset or ci counter overflow, and (ii) nonce resynchro-
nization on packet loss.
A common way to address the first challenge, nonce initialization,
is the use of short-term session keys [38, 46]. At system boot time,
or whenever the session counter ci overflows, both parties generate
a fresh session key based on the long-term pre-shared secret and a
larger epoch counter. With this scheme, individual session counters
ci can safely start from zero. Session keys thus reduce the burden of
secure nonce management for multiple sessions to secure persistent
storage of a single long-term key and epoch counter per connection
per ECU. Our final key provisioning scheme (S4) further relaxes
this requirement to secure persistent storage capacity on a single
trusted ECU, by leveraging trusted computing features as discussed
in more detail in Section 3.4.
Nonce Resynchronization (P3, P4). Receiver ECUs have to deal
with packet loss as they may miss a message or authentication
frame, for instance when in sleep mode or under heavy network
load. Due to the periodic broadcast nature of typical CAN applica-
tions, legacy receivers can easily recover from such failures. On an
authenticated CAN bus, subsequent MAC comparisons will fail if
sender and receiver nonces get out-of-sync. Observe that nonce val-
ues ci are not confidential, however, and that receivers can accept
MACs generated with any nonce that is strictly higher than the
previously authenticated nonce value. As such, packet loss could
be anticipated by including the plain text sender nonce as part
of the authentication payload, but our 64-bit MACs (P1) leave no
free space in a standard CAN frame. Depending on the application,
some unused parts of the message payload might be used to en-
code (the least significant bits of) the nonce, as also suggested by
AUTOSAR [3]. As a more general solution, VulCAN leaves nonce
resynchronization choices to the underlying protocol being used.
Our vulcanized LeiA [38] implementation encodes relatively
small 16-bit nonces in the extended CAN identifier field, and re-
establishes session keys on nonce counter overflow. This allows
receiver components to easily recover after missing one or more
authenticated messages. Furthermore, to be able to recover from
longer-term network failures, a genuine receiver can send a ded-
icated error frame that prompts a sender to broadcast its current
epoch counter value. Note, however, that LeiA might partially break
legacy applications (P4) that rely on the availability of extended
CAN identifiers. For example, the vehicle instrument cluster dis-
cussed in Section 6 utilizes at least one extended CAN identifier.
Our experimental evaluation (Section 5) also reveals that LeiA’s
use of extended identifiers also comes with a performance penalty.
An alternative approach to dealing with packet loss, is provided
by the vatiCAN [34] protocol that uses larger 32-bit nonces, but
relies on a trusted global Nonce Generator (NG) component to peri-
odically reset nonces in the entire network. Specifically, every few
milliseconds, NG broadcasts a randomly chosen value to be used
by all participating ECUs as the new initial value for all counters
ci. NG is assumed to use a modified CAN transceiver, equipped
with hypothetical (P4) hardware-assisted spoofing prevention, such
that an attacker cannot inject arbitrary nonce renewal requests.
We show in Appendix A, however, that vatiCAN’s frequent ran-
dom nonce renewal design is vulnerable to advanced replay attacks
based on the (generalized) birthday problem from probability the-
ory. Depending on the targeted application, our attacks allow an
adversary to start replaying authenticated messages after recording
as little as 30 minutes of broadcast CAN traffic. Our vulcanized
vatiCAN implementation therefore omits global nonce generation,
and properly uses session keys, as discussed above, to ensure the
same ci value is never reused under the same cryptographic key.
Efficient MAC Computation (S1). Recall that the payload of an au-
thenticated CAN message is sent first, before the actual authentica-
tion frame containing the MAC. The vatiCAN [34] authors leverage
this property to compute MACs in parallel at both the sender and
receiver ECUs. The sender first broadcasts message m to be authen-
ticated, and subsequently computes and sends the corresponding
MACs. As soon as m has arrived, the receiver starts computing
MACr , which is afterwards compared to MACs to authenticate m.
While such parallel MAC computation cuts authentication over-
heads by half, current software-only solutions still require several
milliseconds to compute a single 64-bit MAC [34].
Our Sancus-based VulCAN implementation on the other hand,
computes Eq. (1) using Sancus’ [31, 33] hardware-level authenti-
cated encryption primitive. We configured our Sancus cores with
128 bits of security, resulting in 128-bit message authentication
tags. To overcome CAN payload length limitations, we truncate
the resulting MAC by discarding the eight least significant bytes.
This approach adheres to the relevant AUTOSAR specification that
recommends to “always use a key length of at least 128 bit”, but
also states that “a MAC truncation can be beneficial. [...] In general,
MAC sizes of 64 bit and above are considered to provide sufficient
protection” [3]. An important advantage of using hardware-level
cryptography is that MAC computation times decrease with an
order of magnitude, as further explored in the evaluation section.
We consider such acceleration crucial to meet stringent real-time
automotive safety requirements in benign conditions (S1).
3.4 Component Isolation and Authentication
In this section, we elaborate on our system-level requirements (S2–
S5) that transform a conventional entangled vehicle network into
a minimal set of small and robust application components that
mutually authenticate and trust each other.
Software Isolation and Key Storage (S2). The security of any au-
thentication scheme critically relies on maintaining key confiden-
tiality. In this respect, previous automotive security proposals [15,
34, 38, 46] invariably assume uncompromised sender/receiver ECUs,
neglecting advanced attacker capabilities. Our strengthened at-
tacker model, on the other hand, considers adversaries with arbi-
trary ECU code execution such that any cryptographic key material
that is not explicitly protected against untrusted system software
can be trivially extracted. We therefore leverage PMA protection
ACSAC’17, December 2017, San Juan, Puerto Rico, USA
Jo Van Bulck, Jan Tobias Mühlberg, and Frank Piessens
Figure 3: Load-time attestation and session key provisioning
protocol between trusted Attestation Server (AS) and indi-
vidual ECUs hosting PM software components.
to create isolated “safe harbors” for constructing and processing
authenticated CAN messages.
VulCAN reduces the TCB by explicitly distrusting management
software, including the CAN driver. Instead, authenticated CAN
messages are constructed and verified within a Sancus PM, such
that connection keys never leave the private data section. Critical
application software that reacts upon authenticated messages is
furthermore included in the PM protection domain, so as to assure
its untampered execution (S2). Moreover, the protected application
logic can integrate dedicated driver PMs to securely sense or actu-
ate I/O devices, as explained in Section 2.2. As such, a distributed
trusted path can be set up from a brake pedal sensor all the way
to a brake actuator component, without having to trust any of
the unprotected support software that processed the message on
sender/receiver ECUs. The unprotected software components in-
volved in relaying the message may be strictly necessary from a
functionality and availability perspective, yet, they are not involved
in implementing the security properties of the application. Thus,
our solution effectively guarantees that any braking action at the
receiver PM can be traced back to the sender PM that originally
sensed the driver’s brake pedal. As such, vulcanized CAN compo-
nents significantly reduce the TCB, making them more suitable for
safety and security certification, and well within reach of formal
software verification techniques [37].
Software Attestation and Key Provisioning (S3, S4). The above
guarantees are only maintained after PM authenticated compo-
nents have been correctly isolated and provisioned with symmetric
cryptographic keys. Since PMs are not persisted across reboots, an
attacker initially has full control over every ECU in the network
when the car is turned on. This confronts us with three closely re-
lated challenges: how to (i) attest the integrity of critical distributed
software components, (ii) establish session keys over the untrusted
CAN bus, and (iii) replace broken ECUs in an untrustworthy auto-
mobile repair shop.
To overcome these challenges, the VulCAN design includes a
trusted Attestation Server (AS) that engages in a remote attestation
protocol with individual PMs. Specifically, AS possesses the Sancus
module-specific 128-bit key KP M of every authenticated software
component in the network, such that it can get assurance that a
particular PM has been isolated on a specific ECU without having