âƒ—ð‘ð‘šâ€² = (ð‘â€²
ð‘–â€²) are indexed by ð‘–â€² âˆˆ ðºâ€² = Z*
74
ð‘š/âŸ¨ð‘âŸ©, the ideal pð‘–ð‘…â€² factors as the product of those pâ€²
each ð‘– âˆˆ ðº = Z*
ð‘–â€² such that ð‘–â€² = ð‘–
(mod ð‘š), i.e., those ð‘–â€² âˆˆ ðœ‘âˆ’1(ð‘–) where ðœ‘ : ðºâ€² â†’ ðº is the natural mod-ð‘š homomorphism.
Therefore,
ð‘â€²
ð‘–â€²
.
(3.3.7)
âˆ‘ï¸
ð‘ð‘– =
ð‘–â€²âˆˆðœ‘âˆ’1(ð‘–)
To deï¬ne âƒ—ð‘ð‘šâ€²,ð‘š, we partition ðºâ€² into a collection â„â€² of |ðºâ€²|/|ðº| equal-sized subsets ð¼â€²,
such that ðœ‘(ð¼â€²) = ðº for every ð¼â€² âˆˆ â„â€². In other words, ðœ‘ is a bijection between each ð¼â€²
and ðº. This induces a bijection ðœ“ : ðºâ€² â†’ â„â€² Ã— ðº, where the projection of ðœ“ onto its second
component is ðœ‘. We index the relative CRT set âƒ—ð‘ð‘šâ€²,ð‘š = (ð‘ð¼â€²) by ð¼â€² âˆˆ â„â€², deï¬ning
âˆ‘ï¸
ð‘–â€²âˆˆð¼â€²
ð‘ð¼â€² :=
ð‘â€²
ð‘–â€²
.
By Equation (3.3.7) and the fact that (ð‘â€²
ð‘–â€²) is the CRT set of ð‘…â€²
ð‘ð‘–â€² = ð‘ð¼â€² Â· ð‘ð‘– for ðœ“(ð‘–â€²) = (ð¼â€², ð‘–), thus conï¬rming Equation (3.3.6).
ð‘, it can be veriï¬ed that
3.4 Sparse Decompositions and Haskell Framework
As shown in section 3.3, the structure of the powerful, decoding, and CRT bases yield sparse
decompositions, and thereby efï¬cient algorithms, for cryptographically important linear
transforms relating to these bases. Here we explain the principles of sparse decompositions,
and summarize our Haskell framework for expressing and evaluating them.
3.4.1 Sparse Decompositions
A sparse decomposition of a matrix (or the linear transform it represents) is a factorization
into sparser or more â€œstructuredâ€ matrices, such as diagonal matrices or Kronecker products.
Recall that the Kronecker (or tensor) product ð´ âŠ— ðµ of two matrices or vectors ð´ âˆˆ
â„›ð‘š1Ã—ð‘›1, ðµ âˆˆ â„›ð‘š2Ã—ð‘›2 over a ring â„› is a matrix in â„›ð‘š1ð‘š2Ã—ð‘›1ð‘›2. Speciï¬cally, it is the
ð‘š1-by-ð‘›1 block matrix (or vector) made up of ð‘š2-by-ð‘›2 blocks, whose (ð‘–, ð‘—)th block is
75
ð‘Žð‘–,ð‘— Â· ðµ âˆˆ â„›ð‘š2Ã—ð‘›2, where ð´ = (ð‘Žð‘–,ð‘—). The Kronecker product satisï¬es the properties
(ð´ âŠ— ðµ)ð‘¡ = (ð´ð‘¡ âŠ— ðµð‘¡)
(ð´ âŠ— ðµ)âˆ’1 = (ð´âˆ’1 âŠ— ðµâˆ’1)
and the mixed-product property
(ð´ âŠ— ðµ) Â· (ð¶ âŠ— ð·) = (ð´ð¶) âŠ— (ðµð·),
which we use extensively in what follows.
A sparse decomposition of a matrix ð´ naturally yields an algorithm for multiplication
by ð´, which can be much more efï¬cient and parallel than the naÃ¯ve algorithm. For example,
multiplication by ð¼ð‘› âŠ— ð´ can be done using ð‘› parallel multiplications by ð´ on appropriate
chunks of the input, and similarly for ð´âŠ— ð¼ð‘› and ð¼ð‘™ âŠ— ð´âŠ— ð¼ð‘Ÿ. More generally, the Kronecker
product of any two matrices can be expressed in terms of the previous cases, as follows:
ð´ âŠ— ðµ = (ð´ âŠ— ð¼height(ðµ)) Â· (ð¼width(ð´) âŠ— ðµ) = (ð¼height(ð´) âŠ— ðµ) Â· (ð´ âŠ— ð¼width(ðµ)).
If the matrices ð´, ðµ themselves have sparse decompositions, then these rules can be applied
further to yield a â€œfully expandedâ€ decomposition. All the decompositions we consider
in this work can be fully expanded as products of terms of the form ð¼ð‘™ âŠ— ð´ âŠ— ð¼ð‘Ÿ, where
multiplication by ð´ is relatively fast, e.g., because ð´ is diagonal or has small dimensions.
3.4.2 Haskell Framework
We now describe a simple, deeply embedded domain-speciï¬c language for expressing
and evaluating sparse decompositions in Haskell. It allows the programmer to write such
factorizations recursively in natural mathematical notation, and it automatically yields fast
evaluation algorithms corresponding to fully expanded decompositions. For simplicity, our
76
implementation is restricted to square matrices (which sufï¬ces for our purposes), but it
could easily be generalized to rectangular ones.
As a usage example, to express the decompositions
ð´ = ðµ âŠ— ð¶
ðµ = (ð¼ð‘› âŠ— ð·) Â· ð¸
where ð¶, ð·, and ð¸ are â€œatomic,â€ one simply writes
transA =
transB @* transC
transB = ( Id n
@* transD) .* transE
transC = trans functionC
-- ðµ âŠ— ð¶
-- (ð¼ð‘› âŠ— ð·) Â· ð¸
-- similarly for transD, transE
where functionC is (essentially) an ordinary Haskell function that left-multiplies its input
vector by ð¶. The above code causes transA to be internally represented as the fully
expanded decomposition
ð´ = (ð¼ð‘› âŠ— ð· âŠ— ð¼dim(ð¶)) Â· (ð¸ âŠ— ð¼dim(ð¶)) Â· (ð¼dim(ð¸) âŠ— ð¶).
Finally, one simply writes eval transA to get an ordinary Haskell function that left-
multiplies by ð´ according to the above decomposition.
Data types. We ï¬rst deï¬ne the data types that represent transforms and their decomposi-
tions (here Array r stands for some arbitrary array type that holds elements of type r)
-- (dim(f), f) such that (f l r) applies ð¼ð‘™ âŠ— ð‘“ âŠ— ð¼ð‘Ÿ
type Tensorable r = (Int, Int -> Int -> Array r -> Array r)
-- transform component: a Tensorable with particular ð¼ð‘™, ð¼ð‘Ÿ
type TransC r = (Tensorable r, Int, Int)
77
-- full transform: a sequence of zero or more components
data Trans r = Id Int
-- identity sentinel
| TSnoc (Trans r) (TransC r)
â€¢ The client-visible type alias Tensorable r represents an â€œatomicâ€ transform (over
the base type r) that can be augmented (tensored) on the left and right by identity
transforms of any dimension. It has two components: the dimension ð‘‘ of the atomic
transform ð‘“ itself, and a function that, given any dimensions ð‘™, ð‘Ÿ, applies the ð‘™ð‘‘ð‘Ÿ-
dimensional transform ð¼ð‘™ âŠ— ð‘“ âŠ— ð¼ð‘Ÿ to an array of r-elements. (Such a function could
use parallelism internally, as already described.)
â€¢ The type alias TransC r represents a transform component, namely, a Tensorable
r with particular values for ð‘™, ð‘Ÿ. TransC is only used internally; it is not visible to
external clients.
â€¢ The client-visible type Trans r represents a full transform, as a sequence of zero or
more components terminated by a sentinel representing the identity transform. For
such a sequence to be well-formed, all the components (including the sentinel) must
have the same dimension. Therefore, we export the Id constructor, but not TSnoc,
so the only way for a client to construct a nontrivial Trans r is to use the functions
described below (which maintain the appropriate invariant).
Evaluation. Evaluating a transform is straightforward. Simply evaluate each component
in sequence:
evalC :: TransC r -> Array r -> Array r
evalC ((_,f), l, r) = f l r
eval :: Trans r -> Array r -> Array r
78
eval (Id _)
= id
-- identity function
eval (TSnoc rest f) = eval rest . evalC f
Constructing transforms. We now explain how transforms of type Trans r are con-
structed. The function trans wraps a Tensorable as a full-ï¬‚edged transform:
trans :: Tensorable r -> Trans r
trans f@(d,_) = TSnoc (Id d) (f, 1, 1)
-- ð¼ð‘‘ Â· ð‘“
More interesting are the functions for composing and tensoring transforms, respectively
denoted by the operators (.*), (@*) :: Trans r -> Trans r -> Trans r. Composition
just appends the two sequences of components, after checking that their dimensions match;
we omit its straightforward implementation. The Kronecker-product operator (@*) simply
applies the appropriate rules to get a fully expanded decomposition:
-- ð¼ð‘š âŠ— ð¼ð‘› = ð¼ð‘šð‘›
(Id m) @* (Id n) = Id (m*n)
-- ð¼ð‘› âŠ— (ð´ Â· ðµ) = (ð¼ð‘› âŠ— ð´) Â· (ð¼ð‘› âŠ— ðµ), and similarly
i@(Id n) @* (TSnoc a (b, l, r)) = TSnoc (i @* a) (b, (n*l), r)
(TSnoc a (b, l, r)) @* i@(Id n) = TSnoc (a @* i) (b, l, (r*n))
-- (ð´ âŠ— ðµ) = (ð´ âŠ— ð¼) Â· (ð¼ âŠ— ðµ)
a @* b = (a @* Id (dim b)) .* (Id (dim a) @* b)
(The dim function simply returns the dimension of a transform, via the expected implemen-
tation.)
79
3.5 Cyclotomic Rings
In this section we summarize Î›âˆ˜ðœ†â€™s interfaces and implementations for cyclotomic rings.
In subsection 3.5.1 we describe the interfaces of the two data types, Cyc and UCyc, that
represent cyclotomic rings: Cyc completely hides and transparently manages the internal
representation of ring elements (i.e., the choice of basis in which they are represented),
whereas UCyc is a lower-level type that safely exposes and allows explicit control over
the choice of representation. Lastly, in subsection 3.5.2 we describe key aspects of the
implementations, such as Cycâ€™s subring optimizations, and how we generically â€œpromoteâ€
base-ring operations to cyclotomic rings.
3.5.1 Cyclotomic Types: Cyc and UCyc
In this subsection we describe the interfaces of the two data types, Cyc and UCyc, that
represent cyclotomic rings.
â€¢ Cyc t m r represents the mth cyclotomic ring over a base ring râ€”typically, one of
Q, Z, or Zð‘žâ€”backed by an underlying Tensor type t (see section 3.3 for details on
Tensor). The interface for Cyc completely hides the internal representations of ring
elements (e.g., the choice of basis) from the client, and automatically manages the
choice of representation so that the various ring operations are usually as efï¬cient as
possible. Therefore, most cryptographic applications can and should use Cyc.
â€¢ UCyc t m rep r represents the same cyclotomic ring as Cyc t m r, but as a
coefï¬cient vector relative to the basis indicated by rep. This argument is one of the
four valueless types P, D, C, E, which respectively denote the powerful basis, decoding
basis, CRT r-basis (if it exists), and CRT basis over an appropriate extension ring of r.
Exposing the representation at the type level in this way allowsâ€”indeed, requiresâ€”
the client to manage the choice of representation. (Cyc is one such client.) This can
lead to more efï¬cient computations in certain cases where Cycâ€™s management may
80
be suboptimal. More importantly, it safely enables a wide class of operations on
the underlying coefï¬cient vector, via category-theoretic classes like Functor; see
sections 3.5.1 and 3.5.2 for further details.
Clients can easily switch between Cyc and UCyc as needed. Indeed, Cyc is just a relatively
thin wrapper around UCyc, which mainly just manages the choice of representation, and
provides some other optimizations related to subrings (see subsection 3.5.2 for details).
Instances
The Cyc and UCyc types are instances of many classes, which comprise a large portion of
their interfaces.
Algebraic classes. As one might expect, Cyc t m r and UCyc t m rep r are instances
of Eq, Additive, Ring, and various other algebraic classes for any appropriate choices of t,
m, rep, and r. Therefore, the standard operators (==), (+), (*), etc. are well-deï¬ned for
Cyc and UCyc values, with semantics matching the mathematical deï¬nitions.
We remark that UCyc t m rep r is an instance of Ring only for the CRT representations
rep = C, E, where multiplication is coefï¬cient-wise. In the other representations, multiplica-
tion is algorithmically more complicated and less efï¬cient, so we simply do not implement
it. This means that clients of UCyc must explicitly convert values to a CRT representation
before multiplying them, whereas Cyc performs such conversions automatically.
Category-theoretic classes. Because UCyc t m rep r for rep = P, D, C (but not
rep =E) is represented as a vector of r-coefï¬cients with respect to the basis indicated
by rep, we deï¬ne the partially applied types UCyc t m rep (note the missing base type r)
to be instances of the classes Functor, Applicative, Foldable, and Traversable. For
example, our instantiation of Functor for f = UCyc t m rep deï¬nes fmap :: (r ->
râ€™) -> f r -> f râ€™ to apply the given r -> râ€™ function independently on each of the
r-coefï¬cients.
81
By contrast, Cyc t m is not an instance of any category-theoretic classes. This is because
by design, Cyc hides the choice of representation from the client, so it is unclear how (say)
fmap should be deï¬ned: using the current internal representation (whatever it happens to
be) would lead to unpredictable and often unintended behavior, whereas always using a
particular representation (e.g., the powerful basis) would not be ï¬‚exible enough to support
operations that ought to be performed in a different representation.
Lattice cryptography classes. Lastly, we â€œpromoteâ€ instances of our specialized lattice
cryptography classes like Reduce, Lift, Rescale, Gadget, etc. from base types to UCyc
and/or Cyc, as appropriate. For example, the instance Reduce z zq, which represents
modular reduction from Z to Zð‘ž, induces the instance Reduce (Cyc t m z) (Cyc t m
zq), which represents reduction from ð‘… to ð‘…ð‘ž. All these instances have very concise and
generic implementations using the just-described category-theoretic instances for UCyc; see
subsection 3.5.2 for further details.
Functions
We now describe the remaining functions that deï¬ne the interface for Cyc; see Figure 3.2
for their type signatures. (UCyc admits a very similar collection of functions, which we omit
from the discussion.) We start with functions that involve a single cyclotomic index m.
scalarCyc embeds a scalar element from the base ring r into the mth cyclotomic ring
over r.
mulG, divG respectively multiply and divide by the special element ð‘”ð‘š in the ð‘šth cyclo-
tomic ring. These operations are commonly used in applications, and have efï¬cient
algorithms in all our representations, which is why we deï¬ne them as special functions
(rather than, say, just exposing a value representing ð‘”ð‘š). Note that because the input
may not always be divisible by ð‘”ð‘š, the output type of divG is a Maybe.
82
scalarCyc :: (Fact m, CElt t r) =>
mulG
divG
liftPow, liftDec
Cyc t m r
r ->
:: (Fact m, CElt t r) => Cyc t m r ->
Cyc t m r
:: (Fact m, CElt t r) => Cyc t m r -> Maybe (Cyc t m r)
:: (Fact m, Lift b a, ...) => Cyc t m b ->
Cyc t m a
advisePow, adviseDec, adviseCRT
:: (Fact m, CElt t r)
=> Cyc t m r ->
Cyc t m r
-- error sampling
tGaussian
(OrdFloat
::
q, ToRational v, MonadRandom rnd, CElt t q, ...)
=> v
errorRounded :: (ToInteger z, ...) => v
errorCoset
:: (ToInteger z, ...) =>
v -> Cyc t m zp -> rnd (Cyc t m z)
-> rnd (Cyc t m q)
-> rnd (Cyc t m z)