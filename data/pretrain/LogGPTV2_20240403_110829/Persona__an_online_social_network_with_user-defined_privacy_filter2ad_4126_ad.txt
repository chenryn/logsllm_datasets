friends to see her data, but she would want to share it with
her doctor. She may even have many doctors, and it may be
helpful for them to collaborate in a central location. There
is no technical diﬀerence between this application and Doc.
However, these applications are uniquely available on Per-
sona because they operate on sensitive private data.
5.
IMPLEMENTATION
Our Persona implementation consists of two Persona ap-
plications (a storage service and a customizable Doc appli-
141cation) and a browser extension for viewing encrypted pages
and managing keys.
5.1 Storage Service Application
Our Persona storage service application is an XML RPC
server using PHP and Apache with a MySQL database back-
end. The service implements the storage API described in
Section 4.1.
5.2 Doc Application
We have implemented a Doc application (Section 4.2) in
PHP with a MySQL backend for storing metadata. Using
the Doc as the base, we implemented Proﬁle and Wall ap-
plications.
Our Proﬁle application presents an interface for the user to
put data onto her proﬁle and read others’ proﬁles. The pro-
ﬁle metadata (stored by the Proﬁle application in a MySQL
database) consists of references to encrypted proﬁle data
items. The Proﬁle application allows only the registered
user to write onto the Doc Page.
Our Wall application is identical in structure to the Pro-
ﬁle, but allows other users to write onto the Doc as well. The
Wall application allows users to post new items and reply
to existing items. The Wall application constructs the Wall
Doc metadata ﬁle threading posts and replies. As with all
applications, the posts and references themselves are stored
on other storage services, and the Wall application operates
using item references only.
5.3 Browser Extension
Users interact with Persona using a Firefox extension.
The extension uses the XPCOM framework in the Mozilla
Build Environment to access the OpenSSL and cpabe [2] li-
braries for cryptographic operations. The extension allows
users to register with applications, encrypt data to groups,
resolve data references, decrypt data using appropriate keys,
and facilitate out-of-band public-key exchange.
The browser extension is a trusted component in Persona;
it is, in fact, the only one. The extension implements a se-
cure keystore, to which users upload their private and public
keys. The extension is given a list of public keys corre-
sponding to the user’s contacts. These keys are also stored
(encrypted with the user’s public key) on a storage service.
When a user uses a new browser, the extension is initialized
with the user’s private key and a reference to the user’s per-
manent keystore. The extension then downloads all of the
other keys from the storage service.
When an encrypted Persona page is loaded, the extension
processes the elements on the page and replaces them in-
line if necessary. There are two main types of replacement:
resolution of data references and replacement of special tags.
Data reference resolution. The extension parses item
references, fetches the items from storage services, decrypts
the items, and veriﬁes any signatures on those items. In our
implementation, all data is signed by the creator and veriﬁed
if the signer’s key is known. Data resolution is recursive:
encrypted data may contain references to more encrypted
data.
Our extension uses an XML-RPC javascript library capa-
ble of sending asynchronous RPCs. During page processing,
all data items are fetched asynchronously using XMLHttpRe-
quest. If the items are encrypted with an unknown key, the
keys are also fetched asynchronously. Once all keys and data
items have been fetched, the extension sequentially decrypts
(and veriﬁes) each item, and replaces the references with the
decrypted text. We are currently extending our implemen-
tation to decrypt items as they arrive rather than waiting
for all fetches to complete.
Replacement of special tags. Persona users may not
want to share their list of contacts (to be precise, their public
keys) with applications. Instead, this list is kept encrypted
with the user’s public key on a storage service, which the ex-
tension downloads upon initialization. The extension recog-
nizes a “friend-form” tag sent by an application, and replaces
this with a drop-down box containing a list of the user’s con-
tacts. This facility is used in our Proﬁle application to allow
a user to view their contacts’ proﬁles.
The extension allows users to encrypt data to groups. It
replaces embedded forms with a text box into which the user
can enter private data. When the submit button is pressed,
the extension prompts the user for a policy under which to
encrypt the data, performs the encryption (constructing and
publishing symmetric keys as necessary), puts the encrypted
data on the user’s storage service, and replaces the form data
with a reference to the encrypted data item.
Caching. To reduce latency, the extension caches vari-
ous keys and contact information. This includes keys the
user has created: an RSA public key (137 bytes for 1024-
bit moduli), RSA private key (680 bytes), APK (888 bytes),
and AMSK (156 bytes). For each friend, the extension caches
their storage service information, RSA public key, and APK .
The extension also stores the ASK (the size varies: 407 bytes
for one attribute and 266 bytes for each additional attribute)
created for that friend along with the attributes associated
with the ASK . For each policy that the user is a part of,
whether it is created by the user or a friend, the extension
caches the RSA keypair and the symmetric key.
This caching and recycling of symmetric keys allows the
extension to pay the cost of an ABE decryption only when
it encounters an item encrypted using a new key reference.
This will occur when the encryption uses a new policy (cor-
responding to a new group) or an existing policy to which
a user has encrypted with a new symmetric key. The latter
might occur if the encrypting user is not part of the group
and is unable to decipher existing symmetric keys for that
policy. The common operation of the extension does not
require expensive ABE operations.
5.4 Integrating Persona with Facebook
Current deployments of OSNs underline their undeniable
popularity.
It is not realistic to assume that Persona (or
some other privacy-enabled network) will replace existing
OSNs. Instead, we expect users to migrate personal infor-
mation onto private networks, while continuing to use exist-
ing OSNs for public data.
We have designed Persona to inter-operate with existing
OSNs, and our prototype integrates with Facebook. Persona
applications are accessible as Facebook applications and can
interact with Facebook’s API, providing privacy-enabled ap-
plications through the familiar Facebook interface. Con-
versely, existing Facebook applications can be made Persona-
aware on a per-application basis. Users protect their private
data by storing it on Persona storage services rather than
on Facebook; only fellow Persona users will be able to access
the data, and only if they are given the necessary keys and
access rights.
142(a)
(b)
(c)
Figure 1: (a) CDF of the size of Facebook proﬁle data items. (b) CDF of the maximum, 95th percentile, and
average of the size of data items per Facebook proﬁle. (c) CDF of the number of data items on Facebook
proﬁles.
Using Persona applications within Facebook. Users
log-in to Persona by authenticating to the browser extension
(which then decrypts and encrypts data transparently), and
then log-in to Facebook as normal. A Facebook-aware Per-
sona application is akin to any third-party Facebook appli-
cation, and can be selected for use as any other Facebook
application. Unlike other applications, Persona applications
use markup that is interpreted by the Persona browser ex-
tension, and are aware of data references.
Traditional Facebook applications may use the Facebook
API to communicate to users by sending notiﬁcations, dis-
playing items on the Facebook wall, and sending application
invitations. The same facilities are available to Persona ap-
plications. We have implemented an abstract OSN interface
that Persona applications use to access OSN APIs. While
our design is general, our current implementation has only
been tested with Facebook. Our Doc-based applications are
accessible via Facebook as Facebook applications.
Using Facebook applications on Persona. Once users
begin to use Persona, existing Facebook applications may
want to provide Persona users with the ability to store pri-
vate data. Minimally, each application has to be ported to
operate using Persona data references, though some appli-
cations that transform user data may require a complete
rewrite. We discuss application porting in Section 8.
6. EVALUATION
In this section, we quantify the processing and storage
requirements of Persona and measure the time to render
Persona-encrypted web pages.
The key parameters of our evaluation are the sizes and
number of distinct data elements that might be stored on
a single Persona page. Each distinct element represents a
request to a storage server and may, if the policy and associ-
ated key are unknown, also imply a request for a group key
and its decryption with ABE. This process represents the
performance cost of Persona. We estimate these parameters
using Facebook as a model, combining real user proﬁles from
Facebook with observations of application-provided limits
on the number of items per page.
User proﬁles can contain hundreds of data items. We use
proﬁle data in our evaluation because it exposes the worst
case performance of Persona, where users must fetch and
decrypt many individually encrypted data items. Our data
is from a crawl of Facebook proﬁles gathered in January,
2009. The crawl contains the HTML of the proﬁle pages of
90,269 users in the New Orleans network; of those pages,
65,324 pages contain visible proﬁles, and 39 pages had mis-
cellaneous errors that left them unusable.
We parse these Facebook proﬁles into data items that
could be individually encrypted. First, we parse the docu-
ment based on ﬁelds such as Name, Birthday, Activities, In-
terests, etc. We then decompose ﬁelds which contain multi-
ple items separated by commas, bullet points, or line breaks.
Under this decomposition, users would be able to, for exam-
ple, individually encrypt every TV show, book, and movie
that they enjoy, if they chose to do so.
Figure 1 (a) shows a CDF of the sizes of all data items and
Figure 1 (b) shows a CDF of the maximum, 95th percentile,
and average data item sizes on a per-proﬁle basis. These
plots show that most of the data items are small, but many
pages also have a few large items. We also present a CDF of
the number of data items per proﬁle in Figure 1 (c). These
ﬁgures provide a backdrop for the performance of Persona:
our results show that the number of data items on a page
determines the page load time.
6.1 Desktop Performance
We evaluate our Persona implementation on a desktop
computer using a 2.00 GHz processor and 2 GB of RAM.
The desktop, storage service, and application server are con-
nected through a router which introduces an artiﬁcial delay,
chosen uniformly between 65ms and 85ms, on each packet.
These values reﬂect high latencies observed by King [15] and
represent a case where the storage service is far away from
the user.
We use two experiment scenarios. The ﬁrst, termed cool ,
represents Persona in its initial state, when group symmet-
ric keys must be retrieved from a storage service and de-
crypted. The second, termed warm, represents Persona us-
age in the steady state, when all symmetric keys associ-
ated with groups have been cached. We repeat the cool ex-
periment scenario three times, varying the number of user-
deﬁned groups between 1, 10, and 100. We run only one
warm experiment scenario since no key fetches and no ABE
decryptions are needed. In each data set, we randomly as-
sign each data item to one of the user-deﬁned groups.
 0 0.2 0.4 0.6 0.8 1 0 200 400 600 800 1000CDFData Size (bytes)Data Sizes 0 0.2 0.4 0.6 0.8 1 0 200 400 600 800 1000CDFData Size (bytes)Average95th PercentileMaximum 0 0.2 0.4 0.6 0.8 1 0 50 100 150 200 250 300CDFNumber of Data ItemsNumber of Data Items143(a)
(b)
(c)
Figure 2: (a) Total time needed, in seconds, to present Facebook proﬁles composed of encrypted data items.
(b) CDF of total time to load Facebook proﬁles. (c) Total time needed, in seconds, to decrypt encrypted
data items in Facebook proﬁles in the cool data set with 100 groups. Note the diﬀerence in scale from (a).
For each Facebook proﬁle, we ﬁrst encrypt and store each
of the data items in Persona. We then retrieve a page that
contains references to all of these data items.
In the cool
data set, we asynchronously fetch the keys needed to decrypt
all of the items in the page. In both cool and warm, we also
asynchronously fetch the encrypted data items themselves.
Once all keys and data items have been fetched, we decrypt
the data items on the page, verify their signatures, and re-
render the page. For eﬃciency, rather than evaluating every
proﬁle, we evaluate a proﬁle page drawn randomly from the
set of all pages that have x items, for all values x for which
there is a proﬁle with x items.
Page load time. Page load times increase linearly with
the number of elements. Figure 2 (a) shows how long it
takes to download, decrypt, and display the proﬁle page for
each of our experiments, as a function of the number of
data items on the page. We extrapolate the distribution of
page load times per Facebook proﬁle in Figure 2 (b). The
median page load time is 2.3 seconds and the maximum is
13.7 seconds. Most pages consist of a few, small entries, so
most are loaded quickly. The cool data sets are comparable
to the warm data set, indicating that retrieving keys is not
too expensive. These times may also represent a worst case;
if users aggregate their data more coarsely there will be fewer
data items, requiring fewer fetches and thus fewer round-trip
times. Another possible improvement would be to cache
commonly retrieved data items, but we have not performed
this optimization.
Encrypted data size. We show how much larger the
encrypted data is for individual data items in Figure 3 and
for entire proﬁle pages in Figure 4. There is a substantial
increase in the size of the stored data, and this will aﬀect
both the storage capacity of the storage services and the
network resources required to transfer data. The storage
services are inherently distributed, so they should be able to
scale to support the needs of the system.
6.2 Mobile Device ABE Performance
Mobile devices are increasingly used for limited access
to OSNs. MySpace, Facebook, and LinkedIn [24] all have
iPhone applications, and there are many twitter and in-
stant messaging clients. Persona, to provide a substitute,
must also be realizable on mobile devices. Enabling mobile
devices with Persona-based security would enable users to
Figure 3: Total size of plaintext and stored (cipher-