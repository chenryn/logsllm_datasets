            if (!pte_write(entry))
                return do_wp_page(fe, entry);
            ...
        }
    }
    do_fault(fe){
        //如果不要求目标内存具有写权限时导致缺页，内核不会执行COW操作产生副本
        if (!(fe->flags & FAULT_FLAG_WRITE))
            return do_read_fault(fe, pgoff);
        //如果要求目标内存具有写权限时导致缺页，目标内存映射是一个VM_PRIVATE的映射，内核会执行COW操作产生副本
        if (!(vma->vm_flags & VM_SHARED))
            return do_cow_fault(fe, pgoff);
    }
    do_cow_fault(fe,pgoff){
        //执行COW， 并更新页表为COW后的页表。
        new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, fe->address);
        ...
        // __do_fault会将内存
        ret = __do_fault(fe, pgoff, new_page, &fault_page, &fault_entry);
        ... 
            copy_user_highpage(new_page, fault_page, fe->address, vma);
        ret |= alloc_set_pte(fe, memcg, new_page);
        ...
        return ret
    }
    do_read_fault(fe,pgoff){
        ...
        //不执行COW，直接映射文件。
        __do_fault(fe, pgoff, NULL, &fault_page, NULL);
        ...
        ret |= alloc_set_pte(fe, NULL, fault_page);
        ...
        ret
    }
    alloc_set_pte(fe,...){
        bool write = fe->flags & FAULT_FLAG_WRITE;
        //如果执行了COW，设置页表时会将页面标记为脏，但是不会标记为可写。
        if (write)
            entry = maybe_mkwrite(pte_mkdirty(entry), vma);
    }
    do_wp_page(fe,entry){
         ....
         //内核通过检查，发现COW操作已经在缺页处理时完成了，所以不再进行COW，而是直接利用之前COW得到的页表项
         return wp_page_reuse(fe, orig_pte, old_page, 0, 0);
    }
    wp_page_reuse(){
         将页面标记为脏，但是不会标记为可写。
         entry = maybe_mkwrite(pte_mkdirty(entry), vma);
    }
    maybe_mkwrite(){
        //这就是maybe_mkwrite不会标记页为可写的原因，因为这个页为只读页。所以不满足if的条件
        if (likely(vma->vm_flags & VM_WRITE))
            pte = pte_mkwrite(pte);
        return pte;
    }
假设我们通过Mappedaddr=mmap(NULL,filesize,PROT_READ,MAP_PRIVATE,fd,0);获取了一个只读文件的只读内存映射，然后创建两个线程，Thread1通过不断写/proc/self/mem来写Mappedaddr指向的位置，Thread2不断调用madvice(Mappedaddr,len,MADV_DONTNEED)来将Mappedaddr的页表项置空。
基于以上假设，我们来分析内核的控制流。这个控制流分析的代码部分是老外写的([原文链接](https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails))，秉持着开源的精神和思想，我引用了过来并加了一下注释。
write系统调用在内核中会执行get_user_pages以获取需要写入的内存页，get_user_pages函数会调用follow_page_mask函数寻找内存页对应的页表项，由于这是mmap后第一次对Mappedmem进行操作，所以Mappedmem所对应的页表为空，pagefault，get_user_pages调用faultin_page函数进行处理，faultin_page函数会调用handle_mm_fault进行缺页处理。缺页处理时，如果页表为空，内核会调用do_fault函数调页，这个函数会检查是否是因为内存写造成的缺页以及该内存是否是以private方式map的内存，如果是，则会进行COW操作，更新页表为COW后的页表。并将返回值的FAULTFLAGWRITE位置为1（正确分词：某某位
置为1，下同）
    faultin_page
      handle_mm_fault
        __handle_mm_fault
          handle_pte_fault
            do_fault vm_flags & VM_WRITE))  different thread will now unmap via madvise
    follow_page_mask
      !pte_present && pte_none
    faultin_page
      handle_mm_fault
        __handle_mm_fault
          handle_pte_fault
            do_fault 
2\. 
3\. 
4\. 
5\. 
6\. 
7\. 
8\. 
9\. 
10\. 