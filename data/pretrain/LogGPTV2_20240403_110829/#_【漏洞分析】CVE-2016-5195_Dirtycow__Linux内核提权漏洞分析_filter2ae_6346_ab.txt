为了使这段文本更加清晰、连贯和专业，我将对其进行优化。以下是优化后的版本：

---

### 内核控制流分析

假设我们通过以下代码获取了一个只读文件的只读内存映射：
```c
Mappedaddr = mmap(NULL, filesize, PROT_READ, MAP_PRIVATE, fd, 0);
```
然后创建两个线程：
- **Thread1**：通过不断写 `/proc/self/mem` 来写 `Mappedaddr` 指向的位置。
- **Thread2**：不断调用 `madvise(Mappedaddr, len, MADV_DONTNEED)` 来将 `Mappedaddr` 的页表项置空。

基于以上假设，我们将分析内核的控制流。这部分代码是基于开源社区的贡献进行引用和注释的（[原文链接](https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails)）。

#### 控制流分析

1. **write 系统调用**
   - `write` 系统调用在内核中会执行 `get_user_pages` 以获取需要写入的内存页。
   - `get_user_pages` 函数会调用 `follow_page_mask` 函数寻找内存页对应的页表项。
   - 由于这是 `mmap` 后第一次对 `Mappedaddr` 进行操作，所以 `Mappedaddr` 所对应的页表为空，触发缺页异常。
   - `get_user_pages` 调用 `faultin_page` 函数进行处理。
   - `faultin_page` 函数会调用 `handle_mm_fault` 进行缺页处理。

2. **缺页处理**
   - 如果页表为空，内核会调用 `do_fault` 函数进行调页。
   - `do_fault` 函数会检查是否是因为内存写造成的缺页以及该内存是否是以 `VM_PRIVATE` 方式映射的内存。
   - 如果不要求目标内存具有写权限时导致缺页，内核不会执行 COW 操作产生副本，而是直接返回 `do_read_fault`。
   - 如果要求目标内存具有写权限时导致缺页，并且目标内存映射是一个 `VM_PRIVATE` 的映射，内核会执行 COW 操作产生副本，返回 `do_cow_fault`。

3. **COW 操作**
   - `do_cow_fault` 函数会分配一个新的页面并复制原页面的内容到新页面。
   - 更新页表为 COW 后的页表，并将页面标记为脏，但不标记为可写。
   - 调用 `__do_fault` 将内存映射到新的页面。
   - 最后调用 `alloc_set_pte` 设置新的页表项。

4. **非 COW 操作**
   - `do_read_fault` 函数直接映射文件，不执行 COW 操作。
   - 调用 `__do_fault` 将内存映射到现有的页面。
   - 最后调用 `alloc_set_pte` 设置新的页表项。

5. **页表更新**
   - `alloc_set_pte` 函数根据 `FAULT_FLAG_WRITE` 标志来决定是否将页面标记为可写。
   - 如果执行了 COW，设置页表时会将页面标记为脏，但不会标记为可写。

6. **写保护页处理**
   - `do_wp_page` 函数用于处理写保护页。
   - 如果 COW 操作已经在缺页处理时完成，则不再进行 COW，而是直接利用之前 COW 得到的页表项。
   - 调用 `wp_page_reuse` 将页面标记为脏，但不标记为可写。

7. **maybe_mkwrite 函数**
   - `maybe_mkwrite` 函数用于判断是否将页表项标记为可写。
   - 如果 `vma->vm_flags` 包含 `VM_WRITE` 标志，则将页表项标记为可写。
   - 否则，页表项保持只读状态。

#### 控制流路径

1. `write` 系统调用
   - `get_user_pages`
     - `follow_page_mask`
       - `!pte_present && pte_none`
     - `faultin_page`
       - `handle_mm_fault`
         - `__handle_mm_fault`
           - `handle_pte_fault`
             - `do_fault`
               - 如果是写操作且为私有映射，调用 `do_cow_fault`
               - 否则，调用 `do_read_fault`

2. `madvise` 系统调用
   - 不断调用 `madvise` 将 `Mappedaddr` 的页表项置空。

通过以上分析，我们可以看到内核如何处理不同类型的内存访问请求，并确保内存的一致性和安全性。

---

希望这个优化后的版本能够帮助你更好地理解内核的控制流。如果有任何进一步的问题或需要更详细的解释，请告诉我。