    int key_size,int value_size, int max_entries)
    {
        union bpf_attr attr;
        memset(&attr, '\0', sizeof(attr));
        attr.map_type = map_type;
        attr.key_size = key_size;
        attr.value_size = value_size;
        attr.max_entries = max_entries;
        return sys_bpf(BPF_MAP_CREATE, &attr, sizeof(attr));
    }
    //lib/bpf.c
    static int sys_bpf(enum bpf_cmd cmd, union bpf_attr *attr,
               unsigned int size)
    {
        return syscall(__NR_bpf, cmd, attr, size);
    }
    //bpf.h
    union bpf_attr {
        struct { /* anonymous struct used by BPF_MAP_CREATE command */
            __u32   map_type;   /* one of enum bpf_map_type */
            __u32   key_size;   /* size of key in bytes */
            __u32   value_size; /* size of value in bytes */
            __u32   max_entries;    /* max number of entries in a map */
        };
        struct { /* anonymous struct used by BPF_MAP_*_ELEM commands */
            __u32       map_fd;
            __aligned_u64   key;
            union {
                __aligned_u64 value;
                __aligned_u64 next_key;
            };
            __u64       flags;
        };
        struct { /* anonymous struct used by BPF_PROG_LOAD command */
            __u32       prog_type;  /* one of enum bpf_prog_type */
            __u32       insn_cnt;
            __aligned_u64   insns;
            __aligned_u64   license;
            __u32       log_level;  /* verbosity level of verifier */
            __u32       log_size;   /* size of user buffer */
            __aligned_u64   log_buf;    /* user supplied buffer */
            __u32       kern_version;   /* checked when prog_type=kprobe */
        };
        struct { /* anonymous struct used by BPF_OBJ_* commands */
            __aligned_u64   pathname;
            __u32       bpf_fd;
        };
    } __attribute__((aligned(8)));
    //bpf.h
    /* BPF syscall commands, see bpf(2) man-page for details. */
    enum bpf_cmd {
        BPF_MAP_CREATE,
        BPF_MAP_LOOKUP_ELEM,
        BPF_MAP_UPDATE_ELEM,
        BPF_MAP_DELETE_ELEM,
        BPF_MAP_GET_NEXT_KEY,
        BPF_PROG_LOAD,
        BPF_OBJ_PIN,
        BPF_OBJ_GET,
    };
之后调用`bpf_prog_load`函数来将用户的eBPF代码加载到内核，我在内核文件中看到了两个同名不同参的函数定义，根据eBPF的调用情况应当是先调用libbpf的这个函数，之后通过系统调用调用后面的函数。
可以看到在使用`BPF_PROG_LOAD`这个命令时，变量的数据类型又会发生改变，其成员包括指令类型，指令起始地址，指令条数，使用的license(要求是GPL)，日志地址，日志大小以及日志等级等。随后使用系统调用`syscall(__NR_bpf,
BPF_PROG_LOAD, &attr, sizeof(attr));`去运行真正的函数。
在第二个函数中添加了部分注释帮助理解，其核心是在运行eBPF代码前使用verifier进行代码检查并对指令进行修正防止产生恶意的代码跳转。
    //libbpf.c
    int bpf_prog_load(enum bpf_prog_type prog_type,
              const struct bpf_insn *insns, int prog_len,
              const char *license, int kern_version)
    {
        union bpf_attr attr = {
            .prog_type = prog_type,
            .insns = ptr_to_u64((void *) insns),
            .insn_cnt = prog_len / sizeof(struct bpf_insn),
            .license = ptr_to_u64((void *) license),
            .log_buf = ptr_to_u64(bpf_log_buf),
            .log_size = LOG_BUF_SIZE,
            .log_level = 1,
        };
        /* assign one field outside of struct init to make sure any
         * padding is zero initialized
         */
        attr.kern_version = kern_version;
        bpf_log_buf[0] = 0;
        return syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
    }
    //syscall.c
    /* last field in 'union bpf_attr' used by this command */
    #define BPF_PROG_LOAD_LAST_FIELD kern_version
    static int bpf_prog_load(union bpf_attr *attr)
    {
        enum bpf_prog_type type = attr->prog_type;
        struct bpf_prog *prog;
        int err;
        char license[128];
        bool is_gpl;
        //检查成员
        if (CHECK_ATTR(BPF_PROG_LOAD))
            return -EINVAL;
        /* copy eBPF program license from user space */
        if (strncpy_from_user(license, u64_to_ptr(attr->license),
                      sizeof(license) - 1) insn_cnt >= BPF_MAXINSNS)
            return -EINVAL;
        //检查指令类型和内核版本
        if (type == BPF_PROG_TYPE_KPROBE &&
            attr->kern_version != LINUX_VERSION_CODE)
            return -EINVAL;
        if (type != BPF_PROG_TYPE_SOCKET_FILTER && !capable(CAP_SYS_ADMIN))
            return -EPERM;
        //创建prog结构体，用来存储eBPF指令和其他参数
        /* plain bpf_prog allocation */
        prog = bpf_prog_alloc(bpf_prog_size(attr->insn_cnt), GFP_USER);
        if (!prog)
            return -ENOMEM;
        //获取锁
        err = bpf_prog_charge_memlock(prog);
        if (err)
            goto free_prog_nouncharge;
        prog->len = attr->insn_cnt;
        //将用户的指令拷贝到prog结构体中
        err = -EFAULT;
        if (copy_from_user(prog->insns, u64_to_ptr(attr->insns),
                   prog->len * sizeof(struct bpf_insn)) != 0)
            goto free_prog;
        //默认的jitd为0
        prog->orig_prog = NULL;
        prog->jited = 0;
        //设置引用计数为1
        atomic_set(&prog->aux->refcnt, 1);
        prog->gpl_compatible = is_gpl ? 1 : 0;
        /* find program type: socket_filter vs tracing_filter */
        err = find_prog_type(type, prog);
        if (err imm field */
        //修正指令中call和jmp的范围
        fixup_bpf_calls(prog);
        /* eBPF program is ready to be JITed */
        //JIT加载代码
        err = bpf_prog_select_runtime(prog);
        if (err aux);
    free_prog:
        bpf_prog_uncharge_memlock(prog);
    free_prog_nouncharge:
        bpf_prog_free(prog);
        return err;
    }
之后调用`setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF,
&prog_fd,sizeof(prog_fd))`来执行eBPF代码，每一个socket数据包都会执行这个检查，从而实现包过滤。
### eBPF指令集
eBPF也有一套自己的指令集，可以想象成实现了一个VM，其中有11个虚拟寄存器，根据调用规则可以对应到我们x86的寄存器中。
    R0 -- RAX
    R1 -- RDI
    R2 -- RSI
    R3 -- RDX
    R4 -- RCX
    R5 -- R8
    R6 -- RBX
    R7 -- R13
    R8 -- R14
    R9 -- R15
    R10 -- RBP
每条指令的格式如下，成员包括操作码，目标寄存器，源寄存器，偏移和立即数。
    struct bpf_insn {
        __u8    code;       /* opcode */
        __u8    dst_reg:4;  /* dest register */
        __u8    src_reg:4;  /* source register */
        __s16   off;        /* signed offset */
        __s32   imm;        /* signed immediate constant */
    };
操作码共有8种大类，以低3bit区分不同操作码，BPF_ALU为计算指令，BPF_MISC为其他指令，其他指令根据名字就可以猜到其含义。
    /* Instruction classes */
    #define BPF_CLASS(code) ((code) & 0x07)
    #define     BPF_LD      0x00
    #define     BPF_LDX     0x01
    #define     BPF_ST      0x02
    #define     BPF_STX     0x03
    #define     BPF_ALU     0x04
    #define     BPF_JMP     0x05
    #define     BPF_RET     0x06
    #define     BPF_MISC        0x07
eBPF指令的编码如下，低三个bits被用来做指令大类的标志。这部分我参考了官方的手册，这里可以看到0x6和0x7两个指令名在源码中命名实际上是用BPF，这里只介绍eBPF。
    +----------------+--------+--------------------+
      |   4 bits       |  1 bit |   3 bits           |
      | operation code | source | instruction class  |
      +----------------+--------+--------------------+
      (MSB)                                      (LSB)
      Classic BPF classes:    eBPF classes:
      BPF_LD    0x00          BPF_LD    0x00
      BPF_LDX   0x01          BPF_LDX   0x01
      BPF_ST    0x02          BPF_ST    0x02
      BPF_STX   0x03          BPF_STX   0x03
      BPF_ALU   0x04          BPF_ALU   0x04
      BPF_JMP   0x05          BPF_JMP   0x05
      BPF_RET   0x06          BPF_JMP32 0x06
      BPF_MISC  0x07          BPF_ALU64 0x07
当指令类型为`BPF_ALU or
BPF_JMP`，第4bit进行编码，BPF_K表示使用32位的立即数作为源操作数，BPF_X表示使用寄存器X作为源操作数。MSB的4bit表示操作数。
    BPF_K     0x00
    BPF_X     0x08
当指令类型为`BPF_ALU or BPF_ALU64`，实际指令类型为以下之一，也就是常见的运算指令。
    BPF_ADD   0x00
      BPF_SUB   0x10
      BPF_MUL   0x20
      BPF_DIV   0x30
      BPF_OR    0x40
      BPF_AND   0x50
      BPF_LSH   0x60
      BPF_RSH   0x70
      BPF_NEG   0x80