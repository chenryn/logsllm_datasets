图10. matchTags函数
matchTags函数会将电影和字幕文件名分解为标签。单个标签通常为文件名中的独立的单词或数字，这些单词或数字通过“.”以及“-”连接形成完整的文件名。
电影文件名与字幕文件名之间的共享标签数会除以电影标签数，再乘上maxScore（具体值为7，这个值代表两个文件名完全匹配时的最大值）。
例如，若一个电影文件名为“Trolls.2016.BDRip.x264-[YTS.AG].mp4”，则标签为：[Trolls, 2016, BDRip,
x264, YTS, AG, mp4]。
由于攻击者非常容易就能获取到应用程序（例如PopcornTime）正在下载的电影文件名（比如通过嗅探方法），因此我们可以将字幕文件设置为相同的名称，且以“srt”作为扩展名，这将在字幕排序中增加7个分值。
**3.2 快速回顾**
现在，我们的字幕已经可以拿到12分了！单单匹配IMDBid获取的得分较少（只有5分），但获得torrent网站以及PopcornTime具体使用的字幕信息则十分简单，因此我们的恶意字幕能够实现完全匹配（加7分）。
这个分数已经不错了，但我们还没有满足。
这里推荐一些最受欢迎的字幕：斯诺登、死侍、盗梦空间、星球大战外传:侠盗一号，以及冰雪奇缘。
图11. 电影字幕排序
上图展示了世界上最为流行的7种语言的得分，同时显示了平均分和最高分。通过对流行字幕的自动分析，我们发现字幕的最高分为14分，而平均分值为10分左右。
再次回顾评分系统，我们意识到，想要在排序评分中获得高分是非常容易的一件事情。
图12. 用户排序标准
显然，上传记录达101次将成为金牌会员。
因此，我们注册成为OpenSubtitles的用户，耗时4分钟、使用一个40行的Python代码后，我们成为了金牌会员。
图13. 我们的用户排名
我们编写了一个脚本，用来显示某部电影的所有可用字幕。如下图所示，我们的字幕拿到了最高得分（15分）！
图14. 我们的恶意字幕排名第一
这也就意味着，对于任意电影，我们都可以强制用户播放器加载我们制作的恶意字幕，并对用户主机实施攻击。
**四、KODI**
KODI的前身是XBMC，是一个深受大家喜爱的开源跨平台项目，同时也是一个大众化的娱乐中心。KOBI支持所有主流平台（Windows、Linux、Mac、Ios以及Android），支持72种语言，有超过4千万用户，可能是世上最常用的家庭影院类软件。与此同时，KODI经常会跟智能电视（SmartTV）以及树莓派（Raspberry-Pis）结合在一起，因此也吸引了众多攻击者的注意。
**4.1 KODI中的字幕**
与KODI的其他功能类似，KODI的字幕也是使用Python插件来管理的。
最为常用的字幕插件是Open-Subtitles，我们对这个插件的API并不陌生，因此让我们直接跳到字幕下载处理流程。
这个插件使用如下函数来搜索字幕：
图15. 搜索函数
searchsubtitles()函数会从OpenSubtitles上检索可用的字幕列表，获取这些字幕的元数据。
之后，应用会在一个for循环中，迭代处理这些字幕，并使用addDirectoryItem()将它们添加到应用界面中，如下图所示：
图16. 字幕菜单（“斯诺登”电影的印尼语字幕）
如图15所示，发往addDirectoryItem()函数的字符串为：
    plugin://%s/?action=download&link=%s&ID=%s&filename=%s&format=%s
正如其名，Open-Subtitles是一个开放式的源，因此攻击者可以控制用户收到的响应包中SubFileName下的文件名参数，如下所示：
图17. API响应
由于文件名在攻击者的完全控制之下，因此攻击者可以向服务器上传如下一个文件名，覆盖前面的参数（如link以及ID参数）：
    Subtitles.srt&link=&ID=
结果如下：
    plugin://%s/?action=download&link=%s&ID=%s&filename=Subtitles.srt&link=&ID=&format=%s
这种覆盖方式能够成功，原因在于程序在解析字符串时使用了split函数。
当用户在字幕菜单中（如图16所示）选择某个可用的选项后，受影响的函数就会运行，因此这些被篡改的参数会造成严重的结果。
当用户在字幕菜单中选择一个字幕后，相关信息会被发送到Download()函数：
图18. Download函数
由于现在我们已经能够控制传给该函数的所有参数，因此我们就能滥用这个函数的功能。
通过提供一个无效的id值（如“-1”），我们就能到达“if not
result”代码分支。程序会在这个分支中下载“原始”的字幕数据，以避免其无法通过Open-Subtitles API获取所需的文件。
通过控制url参数，我们可以根据需要，让程序下载任意zip文件（比如http://attacker.com/evil.zip文件）。
从互联网上下载任意zip文件可能关系不大，但如果这个行为与KOID释放功能中的另一个漏洞结合使用，就会造成致命的后果。
在审计ExtractArchive()函数的代码时，我们注意到该函数会将strPath（文件释放的目的路径）与strFilePath（压缩文件中的文件路径，通过迭代方式生成）组合在一起。
图19. ExtractArchive()函数
我们可以构造一个zip文件，其中递归包含名为“..”的文件夹，这样以来，我们就能控制文件释放的目的路径（CVE-2017-8314）。
利用目录遍历缺陷，我们可以覆盖KODI的字幕插件。
图20. 恶意ZIP文件的结构
覆盖插件意味着KOID很快就会执行我们的文件。我们构造的恶意Python代码可以完全包含原始插件的所有代码，只要根据需求添加其他恶意功能即可。
**五、Stremio**
PopcornTime的流行的确标志着流媒体应用的兴起，但当它被MPAA（美国电影协会）突然关闭时，用户就会寻找其他替代品。
作为半开源内容聚合器，Stremi开始走入用户视野。与PopcornTime类似，Stremio同样易于使用，也提供了类似的用户接口。非常有趣的是，Stremio在某些特点上与PopcornTime类似。对我们而言，最为关键的一点是，Stremio是一个基于web-kit的应用，其字幕源为Opensubtitle.org。
Stem.IO同样会将字幕内容添加到webkit接口中，因此我们猜测XSS对这个应用来说也是个值得关注的攻击点。
然而，对PopcornTime有效的方法在这里并没有任何作用：
图21. Stremio解析包含无效图片的字幕
我们可以在视频底部看到无效的图片（如图21所示），但程序没有执行任何代码。
显然我们的JavaScript代码没有生效，是时候深入挖掘一下了。
Stremio的代码包含在一个[ASAR](https://github.com/electron/asar)文件中，这种文件格式与TAR格式类似，无需压缩就能将所有文件组合在一起。提取并格式化源代码后，我们发现显示在屏幕上的任何文本都会经过程序的[过滤](https://docs.angularjs.org/api/ngSanitize/service/%24sanitize)处理。
过滤服务会对HTML内容进行解析，只允许安全的、在白名单中的标记及属性通过，因此字符串被过滤后不会包含脚本表达式或者危险的属性。程序强制使用静态HTML标签，不提供脚本功能，这的确非常限制我们的可选操作。这种情况下，我们需要创造性的解决方案。
如果你使用过Stremio，那么你对该应用所弹出的“Support us”界面肯定非常熟悉。
图22. Stremio的“Support us”界面
利用HTML中的标签，我们可以在屏幕正中呈现这个界面的图片副本，然后用标签进行封装。这样一来，当用户点击关闭按钮时，就会被重定向到我们的恶意页面：
    1
    00:00:01,000 –> 00:01:00,000
这个页面正是我们前面在攻击PopcornTime中使用的evil.js页面，该脚本可以利用nodejs的功能，在受害者主机上运行代码。
**六、VLC：重头戏**
**6.1 简介**
当我们意识到字幕载体可以作为新型的攻击媒介时，我们接下来的目标就非常明显了。VLC拥有超过1.8亿用户，是世界上最受欢迎的媒体播放器之一。
VLC是一个开源的、便携式的、跨平台的（流）媒体播放器，可以支持各种各样的平台，包括Windows、OS X、Linux、Windows