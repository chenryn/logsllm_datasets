    def re_mixColumn(b):
        res = bytearray()
        for i in range(4):
            for k in range(4):
                r=0
                for j in range(4):
                    # print(len(p),len(b))
                    r=r^GF2multi(p[k*4+j],b[4*i+j])
                res.append(r)
        return res
    def re(c):
        res=c
        for i in range(9):
            res=re_shiftRow(res)
            res=re_subBytes(res)
            res=re_mixColumn(res)
        res=re_shiftRow(res)
        res=re_subBytes(res)
        return res
    f=open("cipher.txt","rb").read()
    c=bytearray(f)
    # print(len(c))
    print(re(c))
###  Rsa?
由$X\equiv ((Z1+inv _{Z1})*inv_2)\ (mod\ n)以及a\equiv ((inv_ {Z1}-X)*inv _Y)\
(mod\ n)$得：  
2X\equiv Z1+inv_{Z1}\ (mod\ n)\ \ \ \ \ \ (1)
X+aY\equiv inv_{Z1}\ (mod\ n)\ \ \ \ \ \ (2)
两式相减得：  
X-aY\equiv Z1\ (mod\ n)\ \ \ \ \ \ (3)  
(2)*(3)得：  
X^2-a^2Y^2\equiv 1\ (mod\ n)  
即:  
X^2-DY^2\equiv 1\ (mod\ n)  
这长得非常像佩尔方程的形式，不过是在模意义下的佩尔方程。同时，根据递推式也可判断应该是佩尔方程，佩尔方程的介绍见这篇文章[佩尔方程](https://zhuanlan.zhihu.com/p/365860557)，自己推了很久也没什么结果，然后去找论文，论文关键字：Pell
equation and Crypto。Google上第一篇论文[A PUBLIC KEY CRYPTOSYSTEM BASED ON PELL
EQUATION](%5B191.pdf%20\(iacr.org)]([https://eprint.iacr.org/2006/191.pdf))就讲了基于佩尔方程的密码系统，根据论文的解密过程：](https://eprint.iacr.org/2006/191.pdf\)\)%E5%B0%B1%E8%AE%B2%E4%BA%86%E5%9F%BA%E4%BA%8E%E4%BD%A9%E5%B0%94%E6%96%B9%E7%A8%8B%E7%9A%84%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%A0%B9%E6%8D%AE%E8%AE%BA%E6%96%87%E7%9A%84%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B%EF%BC%9A)
1.计算$C\equiv f(C_x,C_y)\equiv C_x-aC_y\ (mod\ n)$
2.计算$M\equiv C^d\ (mod\ n)$，其中$d=invert(e,N)，N=lcm(p-1,q-1)$，这里我们用yafu可以很快分解n
3.计算$X\equiv (M+M^{-1})/2\ (mod\ n)和Y\equiv (M^{-1}-M)/(2a)\ (mod\
n)$，注意这里的除法应理解为乘逆元
4.Y即为所求
``\#yafu分解n得p,q`
`from gmpy2 import *`
`from Crypto.Util.number import *`
`p=115718235064789220654263009993128325569382592506655305434488398268608329541037`
`q=115718235064789220654263009993128324769382192706654302434478391267607309966379`
`C_x=5404548088049249951619519701935576492239293254135836357417714329205323074367876875480850741613547220698045360461761929952847796420174204143917852624050110`
`C_y=2110372753170830610718226848526649992911771424441223687775304654852191999130502986109306355582366065947895295520226816523397652918227241733632791793362785`
`a=1762039418842677123086894939949574689744108610561557889235294034870342076452734215004689409493802437034960516295735815195656138656970901855976802991519141`
`n=13390709926509813526471364597371124446888078365567927211781799241724742352679484983709219580483800891886832613684875066109177882219522305348565532970795023`
`C=(C_x-a*C_y)%n`
`N=(p-1)*(q-1)`
`e=65537`
`d=invert(e,N)`
`M=pow(C,d,n)`
`Y=((invert(M,n)-M)*invert(2*a,n))%n`
`print(long_to_bytes(Y))`
###  BIg_RSA
发现n1,n2有公因数,随便解
    from math import *
    from Crytpo.Util.number import *
    from gmpy2 import *
    n1 = 103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061
    n2 = 115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073
    p=gcd(n1,n2)
    q=n1//p
    e=65537
    phi=(p-1)*(q-1)
    d=invert(e,phi)
    flag=long_to_bytes(pow(c,d,n1))
    print(flag)
## MISC
###  0x01 取证
得到raw文件,vol跑一下。cmdscan发现要找git账号，但是我们知道github现在支支持ssh文件登录，于是查找本地文件是否有跟ssh和git有关的内容,发现ssh.txt
拿到邮箱去GitHub搜索找到仓库，然后下载 **APP** 文件然后，找sangfor 编码之后的字符，找到并解码即可
###  0x02 赛博德国人
下载压缩包后，发现内容是德文，flag是正常的flag，而且通信的格式还原历史，传递密钥的方法为二战中后期改进的。流量包中间到处pdf和txt，密码d279186428a75016b17e4df5ea43d080230。然后找到根据信息调整好轮子，然后解密拿到德语，然后16进制。
###  0x03 MISC520
下载得到压缩包套娃,每个压缩保中间有个story文件.开始发现story内容都相同,没怎么在意.直接取出最后一张.lsb之后发现有隐藏文件。提取出flag.pcap,binwalk提出压缩包,爆破得到密码12345.得到flag.pcap,发现是鼠标流量,画图此时
然后发现有一个压缩包中有一个story有一个数字
得到一串数字,易知跟ASCII有关,并且知道flag头是GWHT{,分析。发现得到的数字与flag之间差了一个自己的所在位置.最后得到flag,换头即可)
    flag = [72,89,75,88,128,93,58,116,76,121,120,63,108,130,63,111,94,51,134,119,146]
    new = ''
    for x in rang(len(flag)):
        new = new + chr(flag[x] - x - 1)
    print(new)
###  0x04 SignIN
拿到gif,发现每帧对应一个数字。然后md5加密即可
## Reverse
###  安卓
基本的安卓逆向，程序关键逻辑在activity层，用jeb打开，查看其关键逻辑
分析得关键为base64加密，而且base表通过服务器获得
服务器要对输入进行验证，验证成功才会发送base表
分析知，将输入进行md5加密后，每字节减一，再与固定值比对
直接cmd5解密，得到key为654321，之后进行base变表解密
得到flag为SangFor{212f4548-03d1-11ec-ab68-00155db3a27e}
###  smc
动调调试，让程序自解密得到关键加密判断逻辑如下图所示：
由加密特征猜测是base64
与base64代码进行详细比对，发现就是将明文进行base64加密之后再分别与固定的0xa6,0xa3,0xa9,0xaf进行异或，之后直接从网上撸base变表脚本，得到flag为
SangFor{XSAYT0u5DQhaxveIR50X1U13M-pZK5A0}
###  deltx
将文件拖入ida分析程序
动态调试程序发现输入应该为41位，然后将SangFor{}里面的数据分为八组，每组4byte
之后后面的判断实际都是判断相乘和相加的结果
直接列出方程在线解密
-v16 + v10 = -42564
v16*v10=614340037
得到v16 = 0xD2BF v10 = 0x2C7B
以此类推 得到flag为
SangFor{2C7BD2BF862564baED0B6B6EA94F15BC}