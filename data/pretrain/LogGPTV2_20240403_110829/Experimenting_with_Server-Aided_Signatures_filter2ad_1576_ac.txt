these two values are fairly long-term, it is reason-
able for Alice to store them in more permanent stor-
age. Because of the “amnesia”, Alice will attempt
to obtain the initial signature from the SEM. Since
SEM has retained all relevant state, it will reply
with the last half-signature (including SEM’s signa-
ture counter) generated for Alice’s SAS certiﬁcate.
Once she veriﬁes the reply, Alice will realize her loss
of state and resort to oﬀ-line means. However, if a
malicious SEM is aware of Alice’s loss of state, it can
use this to its advantage by forging with impunity
Alice’s signatures.
If Alice looses her entire storage, including the
SAS certiﬁcate, the consequences are not particu-
larly dire. The SEM will simply keep state of Alice’s
“orphan” certiﬁcate until it eventually expires.
Any loss of SEM’s state is much more serious.
Most importantly, if the SEM looses all state per-
taining to Alice’s SAS certiﬁcate, the SAS Invari-
ant property can no longer be guaranteed. (Con-
sider, for example, malicious Alice re-establishing
state of her SAS certiﬁcate on the SEM and then
obtaining n signatures with the same hash chain.)
7.4 SEM Compromise
SEM compromise is clearly the greatest risk in
SAS. The adversary who gains control of a SEM can
un-revoke or refuse to revoke SAS user certiﬁcates.
Moreover, it becomes possible to produce fraudu-
lent user signatures: since state is kept of all prior
SAS signatures (corresponding to active SAS certiﬁ-
cates), the adversary can sign on behalf of Alice for
each (SK i
A ) pair found in SEM’s storage.
A, SK i−1
Nonetheless, a defrauded SEM user can still have
recourse if she faithfully keeps state of all prior SAS
signatures. Referring to the SAS dispute resolution
procedure, when an arbitrator is presented with two
distinct and veriﬁable SAS signatures for the same
A ) pair, he concludes that the SEM has
(SK i
attempted to cheat.
A, SK i−1
7.5 Suicide in SAS
In order to provide rapid and eﬀective response
to potential attacks, SAS includes a way for the user
to “self-revoke” a SAS certiﬁcate. This is easily ob-
tained by placing a new value (X.509 extension) in
the SAS certiﬁcate. This value, referred to as the
“suicide hash”, is the hash of a randomly selected
secret quantity generated by Alice when composing
her certiﬁcate request. To self-revoke the certiﬁ-
cate, Alice simply communicates the corresponding
suicide pre-image to the SEM and the CA. As a re-
sult, the former simply stops honoring any further
signature requests (pertaining to Alice’s certiﬁcate)
while the latter places a reference to the said cer-
tiﬁcate on the next CRL.
A similar technique has been suggested (with the
value revealed by the CA instead) by Micali [17] as
part of a proposal for an eﬃcient revocation scheme.
8 Implementation and Experiments
To better understand the implications of using
SAS and to obtain valuable experimental and prac-
tical data, we implemented the SAS scheme, ﬁrst as
a limping proof-of-concept prototype and, later, as
a fully functional and publicly available package.
The implementation, for the most part, follows
the protocol as presented in Section 5. The SAS cer-
tiﬁcate issuance is done strictly oﬀ-line: all users ob-
tain their SAS certiﬁcates from the CA as described
in Section 5.1. The newly issued certiﬁcates are
either transferred to SEM oﬀ-line or piggybacked
onto each user’s initial SAS signature request. We
limit our implementation discussion owing to space
limitations; further details, including the SAS sig-
nature and SAS certiﬁcate formats can be found in
Appendix A.
8.1 SAS Application Example: Eudora
Plug-in
To demonstrate the ease and utility of the SAS
signatures, we developed a plug-in (on top of the
SAS user library [18]) for the popular Eudora [19]
mailer.
When composing email, the sender simply clicks
on the plug-in button. When ready to send, the
plug-in reads the user’s SAS certiﬁcate and extracts
the SEM’s address. It then communicates with the
SEM to obtain a SAS signature on the email mes-
sage. The resulting signed email is veriﬁed auto-
matically by the Eudora plug-in on the receiver’s
side. Even if the receiver does not use Eudora, the
SAS-signed email can be veriﬁed by any S/MIME
capable email client such as Netscape Messenger
or Microsoft Outlook. The veriﬁcation, however,
requires the receiver (veriﬁer) to install a stand-
alone SAS email veriﬁer program. This program
is registered as the viewer for the new MIME type
(‘‘x.SAS-signature’’).
Figure 3 shows a screen snapshot of the Eudora
message composition window when the user is ready
to send a signed email. It is essentially the same as
the normal Eudora screen except for the small SAS
button at the toolbar along the top of the window.
Figure 4 depicts a screen snapshot of the Eudora
Figure 3. Snapshot of signer plug-in
mailer showing a SAS-signed email message being
received. The user is presented with a signature
icon on the message screen; clicking on it causes the
mailer to invoke the plug-in’s veriﬁcation function
the output of which is displayed in the Figure 5.
Figure 4. Veriﬁer plug-in: signed email
To conserve space we omit the depiction of a user
trying to sign email with a revoked certiﬁcate. In
this case, the plug-in displays an error message in-
forming the user of his certiﬁcate’s demise. Further
details on the Eudora plug-in can be found in Ap-
pendix A.
8.2 Experimental Results
As emphasized in the introduction, one of the
main goals of SAS is to oﬀ-load the bulk of signature
surements on the four user platforms with the SEM
daemon running on a 933-MHz PIII. All SAS tim-
ings include network transmission time as well as
SEM and user processing times. Finally, Table 8.2
shows the LAN round-trip communication delay be-
tween the user and the SEM, for diﬀerent key sizes.
The size of the signature request is determined by
the digest size of the hash function, whereas, SEM’s
replies vary from roughly 164 bytes for 1024-bit
RSA key to around 1, 060 bytes for an 8K-bit RSA
key.
We purposely used fairly conservative platforms
for both the SEM and test users. The slowest user
platform is a 233-MHz Pentium I laptop which is
signiﬁcantly faster than a typical PDA or a cell
phone. The motivation was to show that, even a
relatively fast user CPU, the speedup from SAS is
appreciable. Clearly, a more realistic scenario would
involve, for example, a 60- to 100-MhZ PDA as the
user platform and a 1.7- to 2-GhZ PIV as a SEM.
As is evident from Table 8.2, all four user plat-
forms experience noticeable speed-up as a result of
using SAS, as compared with plain RSA. It is not
surprising that the two low-end clients (233-MHz
and 500-MHz) obtain a factor 4 to 6 speed-up de-
pending on the key size. It is interesting, however,
that the seemingly most powerful client platform
(1.2-GHz PIV) also experiences a small speed-up.
However, looking at Table 8.2, it becomes clear that
the 1.2-GHz PIV is not the fastest platform after all.
The explanation for this oddity rests with the chip
maker.
Processor
Key length (bits)
PI-233 MHz
PIII-500 MHz
PIII-700 MHz
PIV-1.2 GHz
1024
13.3
9.1
8.5
8.5
2048
52.4
46.3
45.1
45.4
4096
322.5
302.0
299.0
299.0
8192
2,143.4
2,070.2
2,059.6
2,061.0
Table 2. SAS signature timings (ms)
To summarize, as Tables 8.2 and 8.2 illustrate,
despite large variances in the four clients’ CPU
speeds, the diﬀerence in SAS sign time is very small.
Moreover, the SAS sign time is only slightly higher
than the corresponding value for the SEM (PIII-
933 MHz) in Table 8.2, meaning that – communi-
cation delay aside – a SAS client can sign almost
as fast as the SEM. The reason is that, to obtain
a SAS signature, a user’s cryptographic computa-
tion (which dominates the overall time) amounts to
message hashing and signature veriﬁcation. Hash-
Figure 5. Veriﬁer plug-in: veriﬁcation
computation from the weak user to the powerful
SEM. To validate the goals and experiment with
the SAS implementation, we ran a number of tests
with various hardware platforms and diﬀerent RSA
key sizes.
All experiments were conducted over a 100 Mbit
Ethernet LAN in a lab setting with little, if any,
extraneous network traﬃc. All test machines ran
Linux version 2.2 with all non-essential services
turned oﬀ. The hardware platforms ranged from
a measly 233-MHz PI (Pentium I) to a respectable
1.2-GHz PIV (Pentium IV). Note that we selected
the lowest-end platform conservatively: only very
high-end PDAs and palmtops approach 200-MHz
processor speed; most are in the sub-100Mhz range.
Our choice of the SEM platform is similarly conser-
vative: a 933-MHz PIII. (At the time of this writing,
1.7-GHz platforms are available and aﬀordable.)
Processor
Key length (bits)
PI-233 MHz
PIII-500 MHz
PIII-700 MHz
PIII-933 MHz
PIV-1.2 GHz
1024
40.3
14.6
9.2
7.3
9.3
2048
252.7
85.6
55.7
43.9
58.7
4096
1741.7
562.8
377.8
294.7
401.2
8192
12,490.0
3,873.3
2,617.5
2,052.0
2,835.0
Table 1. Plain RSA signature timings
(ms)
First, we present in Table 8.2 plain RSA timings
conducted with OpenSSL on the ﬁve hardware plat-
forms. Table 8.2 illustrates the SAS timing mea-
ing is almost negligible as compared to public key
operations. RSA signature veriﬁcation is also quite
cheap in comparison to signing since we use small
public exponents.
Processor
Key length (bits)
PI-233 MHz
PIII-500 MHz
PIII-700 MHz
PIV-1.2 GHz
1024
0.6
0.4
0.1
0.4
2048
0.7
0.5
0.2
0.5
4096
1.1
0.8
0.2
0.8
8192
1.7
1.2
0.3
1.2
Table 3. Network round-trip delay (ms)
9 Beneﬁts and Drawbacks
In summary, the SAS signature scheme oﬀers
several
important beneﬁts as described below:
Eﬃcient Signatures. As follows from the pro-
tocol description and our experimental results,
the SAS signature scheme signiﬁcantly speeds up
signature computation for slow, resource-limited
devices. Even where speed-up is not as clearly
evident (e.g., with small key sizes), SAS signatures
conserve CPU resources and, consequently, power,
for battery-operated devices.
remark that, with traditional
Fast revocation. To revoke a SAS certiﬁcate, it is
suﬃcient for the CA to communicate to the correct
SEM. This can be achieved, for example, with CA
simply issuing a new CRL and sending it to the
SEM. Thereafter, the SEM will no longer accept
SAS signature requests for the revoked certiﬁcate.
We
signature
schemes, the user who suspects that his key has
been compromised can ask the CA to revoke the
certiﬁcate binding this key to the user. However,
the adversary can continue ad inﬁnitum to use
the compromised key and the veriﬁcation burden
is placed on all potential veriﬁers who must have
access to the latest CRL. With SAS, once the SEM
is notiﬁed of a certiﬁcate’s revocation, the adver-
sary is no longer able to interact with the SEM to
obtain signatures. Hence, potential compromise
damage is severely reduced.
Since only a SEM
More secure signatures.
performs real RSA public key operations (key
generation, signature computation),
it can do so
with stronger RSA keys than would otherwise be
used by the users. Indeed, a small PDA-like device
is much less likely to generate high-quality (or
suﬃciently long) RSA factors (p, q) and key-pairs
than a much more powerful and sophisticated SEM.
Signature Causality. Total order can be imposed
over all SAS signatures produced by a given user.
This is a direct consequence of the hash chain
construction and the SAS Invariant.
In other
total ordering can be performed using
words,
the monotonically increasing signature counter
included in each SAS signature.
Dispute Resolution. Signature Causality can be
used to provide unambiguous dispute resolution in
case of private key compromise. Recall that the
compromise of a private key in a traditional signa-
ture scheme results in chaos. In particular, all prior
signatures become worthless unless the use of a
secure timestamping service is explicitly mandated
for all signer and signatures. In SAS, once the time
of compromise is established, signatures can be
easily sorted into pre- and post-revocation piles.
Attack Detection. As discussed in Section 7,
an adversary can succeed in obtaining a single
fraudulent half-signature (not a full SAS signature)
by substituting a message of its own choosing in
the user’s signature request. This essentially closes
the door for the adversary since it is unable to
obtain further service (short of inverting the hash
function). The real user will detect that an attacks
has taken place the next time when it tries to run
the SAS signature protocol with its SEM.
Limited Damage. Even if the entire SAS hash
chain is compromised (i.e., an adversary obtains
the seed of the hash chain), the damage is con-
tained since the adversary can generate at most
n signatures. Furthermore, a user whose hash
chain is compromised will detect the compromise
the very next time she attempts to contact the
SEM. (This is because the SEM will reply with
its last half-signature ostensibly computed for the
requesting user.)
Alas, the SAS scheme has some notable draw-
backs as well:
• Each SEM is a single point of failure and a
performance bottleneck for the users it serves.
• As discussed in Section 7, a SEM signs (with RSA,
to produce its half-signature) a response to every
well-formed signature request. This feature can be
exploited by an adversary in order to mount a DoS
attack. However, even the best attack can succeed
in making a SEM sign at most once for each user
it serves. Of course, an adversary can still ﬂood