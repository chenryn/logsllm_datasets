# 【技术分享】手把手教你在PE文件中植入无法检测的后门（上）
##### 译文声明
本文是翻译文章，文章来源：haiderm.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
译者：[eridanus96](http://bobao.360.cn/member/contribute?uid=2857535356)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**传送门**
****
[**【技术分享】手把手教你在PE文件中植入无法检测的后门（下）**](http://bobao.360.cn/learning/detail/4748.html)
**1\. 前言**
在渗透的过程中，我们常常希望能在不增加可执行文件大小、不改变其原有功能的前提下，使用自己的Shellcode注入到指定的可执行文件中，同时最好让这一过程完全无法被检测到。
我们举一个具体的场景作为例子。在经过侦查后，我们得知，有许多员工都在使用某个软件。于是，我们就可以采取社工方式，向员工发送一封带有“
**XX软件更新下载**
”链接的钓鱼邮件，实际上点击链接后将会下载在该软件中加入后门的一个更新。一旦有员工受骗下载了这个所谓的“更新程序”，我们就能借助后门进入到目标网络之中。
**本文将介绍如何在不增加大小、不改变功能的前提下，通过添加我们自己的反向TCP Shellcode来植入一个合法的x86 PE（Portable
Executable）文件后门。**
此外，我们还会介绍 **如何使后门PE完全不被发现的多种技术**
。其重点在于要使已经植入后门的文件完全无法被检测到。这里所说的“无法被检测”是针对于扫描时间静态分析而言的。除了上面这些，我们还会
**深入理解PE文件格式、x86汇编以及调试的要求** 。
我们采用相对简洁的语言，循序渐进地讲解了后门植入的方法，为了更好地理解，我建议各位读者应该按照文章顺序来阅读每一小节。
**2\. 我们自行加入的限制**
我们的最终目标是在程序中植入一个后门，并让它完全无法被反病毒软件检测到，同时植入后门的程序功能应该保持完好，不能出现中断或异常。
为了防止被杀软检测到，我们将使用NoDistribute。有很多方法可以使我们植入的后门无法被检测到，例如：使用Crypter编码整个程序并在程序中加入一个解码存根（Decoding
stub）、使用UPX压缩程序、使用Veil框架或者msfvenom进行编码等。然而，我们并不会使用上述的工具，我们希望能尽可能地保持后门植入的简洁和优雅，于是我们对自己做了如下的限制：
**不使用Msfvenom编码方案、Crypter、Veil框架或者其他诸如此类的工具；**
**文件的大小应保持不变，不加入额外的节区或解码存根，也不对程序进行压缩；**
**植入后门之后，程序的原始功能保持不变，不出现中断或异常。**
**3\. 总体思路**
**通过添加新的Section Header来注入Shellcode；**
**使用基于用户交互的Shellcode触发器及Codecave；**
**找到两处Codecave，用于插入定制的编码器和Shellcode触发器。**
**4\. 如何选择用于植入后门的PE文件**
除非是必须使用特定文件来植入后门，否则请牢记以下几点。下面的这些内容并不是强制要求，但强烈建议遵循这些内容，因为这将有助于降低杀毒软件的检测率，使我们植入的后门更加可靠。
第一， **可执行文件的大小最好小于10MB**
。在渗透过程中，更小的文件有助于更轻松地发送给目标用户。你可以将其用ZIP压缩后使用电子邮件发送，也可以采用其他的社会工程学方式。此外，如果可执行文件较小，出现问题后的调试也会变得更加方便。
第二， **在主流产品中植入后门**
，例如Utorrent、Putty、WinRAR、7zip等。我们不一定要利用常见的PE文件，但是请注意，相比于常见的PE文件来说，杀毒软件会更倾向于检测未知PE文件是否存在后门。但对于用户来说，他们对主流的产品有足够的信任，也就有更高概率会选择运行它们。
第三， **选择不受安全功能（例如ASLR和DEP）保护的PE文件**
。如果选择了受保护的PE文件，无疑就大大增加了我们植入后门的难度，但最后的效果却是与在普通PE文件中植入完全一样。
第四， **最好选择C/C++ Native文件** 。直接执行的代码会更方便我们的植入。
第五， **最好选择一个具有网络通信功能的PE文件**
。由于该文件本身就会进行通信，因此一些反病毒软件就将它的所有通信视为合法行为，同时用户也会将恶意通信认为是该应用使用过程中的一个正常行为。
在本文中，我们以7zip压缩软件（GUI版本）为例，尝试在其中植入后门。首先，我们检查该文件的空间布局随机化（ASLR）是否已经启用。
**4.1 空间布局随机化ASLR**
ASLR是一种针对
**缓冲区溢出的安全保护技术，会对程序每次加载到内存中的地址进行随机化，从而增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置。**
根据PowerShell脚本中显示的结果，我们发现其没有使用ASLR或DEP等安全机制：
正如我们所看到的，该文件没有太多的保护。接下来，让我们进一步查看该文件的其他信息。
**4.2 静态分析** **** **  
**
该PE文件为32位，大小约5MB，并且该文件是在本地直接编译执行的。上述信息告诉我们，这个文件就是一个非常合适的目标，我们接下来就开始植入后门。
**5\. 植入后门**
在PE文件中植入后门有两种方法。在具体讲解这两种方法之前，我想和大家强调一下，我们为什么要在PE文件中植入后门。
简单来说，我们希望能有一个合法的Windows可执行文件（比如7zip）里面包含我们的Shellcode。所以，当7zip运行时，我们的Shellcode也随之一起执行，并且用户并不知情、反病毒软件也没有检测到任何恶意行为。该程序（7zip）也应该像以前一样正常工作。我们将要使用的Shellcode是一个Stageless的MSFvenom反向TCP
Shell。
如果你不了解Staged和Stageless载荷的区别，可以参考：
我们介绍的两种方法，其总体过程和目标都是相同的，但在具体实现上是有不同的方法。整个过程如下：
**1\. 在内存中找到合适的位置，来植入我们的Shell代码** **。** 具体可以通过借助Codecave和创建新的Section
Header这两种方式，我们在后文中都会进行演示。
**2\. 在程序开始执行时，从栈中复制操作码** **。**
**3.** 用我们自己的操作码来替代这些指令， **将应用程序的执行流劫持到在内存中我们所需要的位置。**
**4\. 将Shellcode添加到内存中该位置** ****，在这个例子中就是Stageless TCP反向连接Shell。
**5\. 设置寄存器，返回第二步中复制的栈，以允许程序进行正常的执行流** **。**