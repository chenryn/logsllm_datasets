第二部分目标和自动化
相关联，因此目标进程将不会崩溃，面是挂起，并且SPIKE的崩渍特性将不会出现。因此，为
了能够重现崩溃，我们重新启动该进程，允许它在没有监视的情况下运行（不关联到一个调试
器），并依赖于SPIKE崩溃以及受影响的NMAPdaemon程序。我们再次运行测试并等待，再次
观察到了NMAP中的一个崩遗，接着是SPIKE中带有下面输出的一个崩溃：
-snip-
Fuzzing Variab1e 5:1
Variab1esize= 5004
Read first 1ine
Fuzzing Variable 5:2
Couldn't tcp connect to target
Segmentation fault
-snip-
WedoyHeb
xMxwcx口？
区PL
送含
141SFF9
小
图15-2nmapd.exe中的一个可利用栈溢出
该方法对于追查触发NMAP中错误的测试用例而言，无疑是一种最基本的技术。更加科学
的方法包括使用一个噢探器来监视所有的网络通信。NMAP将崩溃，并且不能够再对请求做出
响应。但在另一方面，SPIKE将继续传输测试用例。通过定位最后一次请求响应的传输，我们
就可以确定可能是哪个测试用例触发了该错误。
回到最初所描述的向后追查的技术，来自于SPIKE的最后一次成功的传输标记在“模糊变
量5：1”行中，这告诉我们最后一次成功的连接是关于模糊变量5。发送给该进程的最后一个
---
## Page 186
第15章网络协议模糊测试：UNIX平台上的自动化测试171
模糊字符串是1。为了确定哪一个模糊变量是模糊变量5，我们只要简单地加载我们的SPIKE脚
本，然后从第O行开始统计包含有“变量”这一词的行的个数。在遇到CREA命令中的只能用于
后验证的一个动词参数时停止计数。接下来，我们必须要确定为模糊字符串1，即CREA命令的
参数，使用了什么值。
有许多方法可以实现这一点。一种方法是如前面所提到的使用一个噢探器，另外一种可以
采用的方法是向模糊测试程序line_send_tep.c中添加一个printf（）函数，以命令应用程序输出
当前的模翻字符串，然后再重新运行模糊器。不论使用哪一种方法，我们都发现导致错误的字
符串就是“CREA”.我们立刻就可以重新创建这个后验证崩溃。需要做的所有工
作就是让用户连接到服务器并发送一个恶意的CREA命令参数。这并不很困难：为发现远程漏
洞只要花费很少的时间。这可能会使你产生这样的疑问，为什么许多提供商在正式发布他们的
软件之前不应用这种类型的测试呢？如果我们想要继续对NMAP进行模糊测试，那么可以在关
于CREA命令的SPIKE脚本中删除此部分，以使我们不再用一个已知的问题来破坏测试目标。
15.6小结
当考虑编写你自己的模糊器时，首先对已经存在的模糊器以及模糊测试的体系结构进行评
估是非常重要的。对于一个简单的测试目标如NMAP协议而言，从头开发一个模糊器得到的收
获将会很小。只要花费几个小时的时间，我们就可以掌握一些SPIKE脚本，以有效地执行
NMAPdaemon代码。但是要记住，你所得到的结果的质量将反映出开发模糊器所花费的时间。
在达种特殊的情况下，我们追求的是绝对的最小化。我们的选择是连接到服务器，发山一些命
令请求，然后退出。在NMAP中还可以发现许多其他的函数可以被添加到脚本中，以进行更多
的测试。
---
## Page 187
第16章网络协议模糊测试：Windows平台上的自动化测试
“我无法想像奥萨马·本·拉登等人如何理解光明节的乐趣。则
—GeorgeW.Bush，自宫烛台点火仪式，WashingtonDC.2001年12月10目
尽管UNIX系统在服务器领域可能居于统治地位，但在全世界范围内所安装的更多的操作
系统是微软的Windows操作系统，这也使它成为了易受攻击的目标。影响Windows桌面的漏洞
经常在创建现有的许多被恶意代码感染井控制的计算机网络时被利用。考虑一下Slammer蟠
虫，它利用了微软SQLServer中的一个缓冲区溢出，并被作为说明通过网络导致Windows漏
洞的威力的一个示例。该漏洞被描述在2002年7月24微软发布的安全公告MS02-039中°，而
Slammer蟠虫在2003年1月25日被肤浅地加以描述。该蟠虫实际上并没有有效载荷，它只是简单
地利用被感染的主机来扫描井传播到其他被感染的机器。尽管该螺虫缺乏有效载荷，但这种
人侵式的扫描生成了足够的通信以导致对Intermet、信用卡的处理的破坏，以及在某些情况下造
成了对蜂窝电话网络可用性的破坏。令人感兴趣的是甚至在4年之后，Slammer螺虫仍然位于最
常见的5种通信生成事件之内。显然，在Windows中所暴露的一个网络漏洞具有深远的含义。
在前面的章节中，我们利用了一个已经存在的模糊器框架SPIKE，来构键了在UNIX环境中
面向NovellNetMailNMAPdaemon程序的一个协议模糊器。本章中，我们采用一种不同的方法，
从头至尾构建一个简单的基于Windows的、具有GUI界面以及用户友好的模糊器。尽管名为
ProtoFuzz的最终产品只提供最基本的功能，但是它提供了一个很好的扩展平台，并且为模糊器
的创建提供了一些不同的视角。下面首先来讨论一下该模糊器所具有的特性。
16.1ProtoFuzz的特性
在我们开始开发该工具之前，首先必须要考虑一下所需要的以及所期望的特性。在最基本
的层面上，一个协议模糊器只是简单地在目标上传输变异的包。因此，只要模糊器能够生成并
发送数据包，那么它就满足要求了。然而，如果ProtoFuzz具备理解我们想要模糊的包的结构的
功能，那么将会更好，下面让我们对这个基本的需求进行扩展。
16.1.1包结构
在我们的模糊器可以发送一个数据包之前，需要了解如何来创建一个包。对于现有的模
httc/www.cert.org/advisories/CA-2003-04.html
@ ht:/www.microsoft.com/techne/security/bulleti/MS02-039.mspx
@ http://pedram.openrce.org/_research/slammer/slammer.txt
③http://isc.sans.org/portreport.html?sortstargets
③ http:/atlas.arbor.net/
---
## Page 188
第16章网络协议模测试：Windows平台上的自动化测试173
器而言，在模糊测试中采用下面的三种基本方法之一来组装包：
·技巧性的测试集，PROTOS测试集及其配套的商业工具Codenomicon，都是将用于模
糊测试的数据包的结构进行硬编码。像这样来创建测试集很浪费时间，因为它需要分析
一个协议的规范并开发成百上千个硬编码的测试用例。
·生成模器。正如我们在前面的章节中所看到的，像SPIKE这样的工具需要用户创建一
个描述数据包结构的模板。然后，模糊器就负责在运行时生成并传输单个的测试用例。
·变异模柳器。如果不是从头创建一个包，那么一个可选的方法是从一个已知的好的包开
始，然后连续对该包中的部分进行变异，尽管在强制性测试模式下，该包中的每一个字
节都可以被变异，但该方法通常不适用于协议模糊测试，因为该方法的效率不高，并且
会生成与网络协议不一致的包，甚至会生成无法到达目标的包。可以通过借鉴协议模板
方法的一些技巧来修改该方法。该模糊器从一个已知的好包开始工作，然后用户通过识
别应当被作为测试目标的那部分数据来创建一个模板。该方法将被ProtoFuzz所利用。
没有一个单独的方法要优越于其他方法，每个方法都有其各自的适用情形。ProtoFuzz之所
以选择包变异方法，就是因为它所具有的简洁性。以一个可以从被观察的网络通信中获取的已
知的好包开始，就允许用户可以立即开始模糊测试，面不用花费大量的时间来研究协议并创建
生成模板。
16.1.2捕获数据
由于选择了包变异作为模糊测试的方法，那么ProtoFuzz应当能够在混乱模式下捕获网络数
据，就像一个噢探器一样。我们将在ProtoFuzz中创建一个网络协议分析器，这样，它就可以捕
获从目标应用进出的通信，然后我们就可以选择单独的包来进行模糊测试。为了实现此功能，
我们将利用一个已存在的包捕获库，该库将在“ProtoFuzz的开发”一节中做详细介绍。
16.1.3解析数据
尽管这不是绝对需要的，但我们想要ProtoFuzz除了捕获数据之外，还能够以一种易于理解
的形式将所捕获的包的内容展现出来。这将有助于用户识别包中适于进行模糊测试的部分。网
络包数据只是一系列遵循特定模式的字节，以一种用户易读的格式来显示数据要求利用一个捕
获库，而该库能够理解包结构并将其分解为组成数据流的不同的协议头和数据段。许多人对
Wireshark所使用的表现格式很熟悉，因此我们将其作为显示格式的基础，图16-1显示了被
Wireshark所捕获的一个简单的TCP包。
这个来自于Wireshark的特定的屏幕快照将段在三个窗格中进行了显示。最上面的窗格列出
了被单个捕获的包。选择其中的一个包将把该包的内容加载到下面的两个窗格中。中间的窗格
显示了将该包分解为单独的字段。在这个例子中，我们可以看到Wireshark比较熟悉AOL实例
消息协议，因为它成功地将TCP包的整个数据段进行了解析。最后，底层的窗格显示了被选择
http://www.ee.oulu.fi/research/ouspg/protos/
http://www.codenomicon.com/products/
---
## Page 189
174
第二部分目标和自动化
包的原始十六进制和ASCII字节。
图16-1Wireshark解析一个使AIM生效的包
16.1.4模糊变量
一且网络数据被观测并捕获，我们想要允许用户来确定其中将为模糊测试而进行变异的部
分。为此，我们将使用一种非常简单的格式，即使用开始和结束标签将包的十六进制表示部分
包含起来，不同的标签用来表示运行时模期变量的不同类型。这种简单的格式将允许用户可视
化的识别模糊变量，并且允许ProtoFuzz在解析包结构时来识别将要被模糊数据所替代的区域。
我们将使用下面的标签：
·[XX]强有力模糊变量。被方括号包围起来的字节将使用所有可能的字节值来模糊化。因
此，一个单独的字节将被模糊256次，而一个字值（两个字节）将被模糊65536次。
·字符串模期变量。也可以使用用户控制的文本文件中（String.txt）预定义的变量长
度字符串的十六进制表示来模糊化字节。这种类型的模糊测试通常在包的数据部分进行，
而不是在需要一个已定义结构的头字段中。
下面的模板说明了同时具有强有力模糊变量和字符串模糊变量的TCP包。
903000080882000050090250576 00508  20 00
TT055369E3636T336 5E809V902010SV00 10T08V00068
10 00 09 4E 00 00 01 00 5E 00 00[16]
---
## Page 190
第16章网络协议模糊测试：Windows平台上的自动化测试175
16.1.5发送数据
协议库在发送数据时通常采用两种不同的方法。首先，它们具有一系列的函数允许你设定
数据的特定部分，如目标IP和MAC地址。然而，包结构的大部分内容都是基于适当的RFC已经
给你构建好的。一个.NET框架类如HttpRequest，就是这种类的一个示例。该类允许你定义诸
如方法和URL等属性，但大多数的HTTP头和所有的以太网，TCP以及IP头都是已经给你创建
好的。另外一种可选的方法是创建一个原始数据包以使单个字节可以被指定，并且由程序员来
确保包要遵循定义在适当RFC中的结构。尽管第二种方法需要研究者多做一些工作，但是它提
供了更细的控制粒度，将使模糊协议头具有同数据段一样的功能。
16.2必要的背景知识
在开始讨论ProtoFuzz的开发过程之前，我们首先应当强调一些重要的背景知识。
16.2.1错误检测
对任何类型的模糊测试而言，在目标应用中检测错误等同于发现漏洞。没有一个完美的方
法来实现这一点，但某些方法要优于其他的方法。例如，在协议模糊测试中存在的不同于文件
模糊测试的一个障碍是，模糊器和目标应用可能将被分隔为两个系统。当对网络协议进行模糊
测试时，将一个调试器关联到目标应用是一个好的开端，它将允许你查明已处理和未处理的异
常，否则这些异常可能不会被识别。当使用调试器时，你仍然要面临将模糊包与它们所生成的
异常进行关联的挑战。尽管不是十分的安全，但可做的工作包括在每个包之后发送某种形式的
探针，以确保目标应用仍然是可响应的。例如，你可以向目标应用发送一个ping请求，并确保
在发送下一个模糊包之前接收到一个回应。这不是非常的完美，因为一个异常可能已经发生，
但并不影响目标应用响应ping的能力。然而，你可以针对目标应用来定制探针。少类计
除了监视错误之外，我们也可以监视目标应用所发生的性能下降问题。例如，考虑一个在
目标应用的处理逻辑中导致一个无限循环的病态数据包。在这种情况下，没有实际的错误生成，
但是我们却具备了一个DoS条件。在目标机器上运行性能监视器，如在微软的管理控制台中可
用的PerformanceLogs andAlerts或者SystemMonitor snap-ins，可以帮助识别这些条件。
请求超时和非预期响应
并不是所有被传输的模糊包都将引起一个响应。然而，对大多数包面言都会产生一个响应，
监视响应以确保目标应用仍然正常运转是非常重要的。再进一步，也可以对响应包的内容进行
解析。采用这种方法，你不仅能够识别何时响应没有被接收，而且还可以识别包含非预期数据
的响应。
16.2.2协议驱动程序
D
许多包捕获库需要使用一个定制的协议驱动程序。为ProtoFuzz所选择的MetroPacket
---
## Page 191
176
第二部分目标和自动化
Library包括ndisprot.inf，它是微软作为其驱动程序开发工具包的一部分而提供的网络驱动程
序接口规范（NetworkDriverInterfaceSpecification，NDIS）协议驱动程序的一个示例。NDIS对
于网络适配器而言是一个有效的API，并且为应用程序提供了发送和接收原始以太网包的能力。
在ProtoFuzz可以使用之前，该驱动程序必须被手工安装和启动，这可以通过在命令行运行net