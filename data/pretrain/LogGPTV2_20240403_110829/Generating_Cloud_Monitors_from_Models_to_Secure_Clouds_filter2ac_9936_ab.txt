






*		









Fig. 2. WorkÔ¨Çow in Cloud Monitor (CM)
of different resources to analyse how the request went. HTTP
has a list of status codes [15]. The HTTP response code is
a numeric value that informs the clients whether the request
has been processed successfully. For example, the value 200
means that the request was successful, 404 means the resource
was not found and 403 implies that it is forbidden to make
this request on this resource.
Figure 2 presents the workÔ¨Çow within the Cloud Monitor
(CM). The HTTP method request from CM user is forwarded
to the private cloud if the pre-condition is satisÔ¨Åed. Similarly,
upon receiving the response from the private cloud, the post-
condition for the method request is veriÔ¨Åed. The request is
successful if both the pre- and post-conditions evaluate to true,
otherwise an invalid response specifying the faulty behavior
is given to the CM user.
B. Users of Cloud Monitor
The cloud monitor can be used in a variety of ways. Namely,
the users of cloud monitor can be:
1) a cloud developer, who is implementing the cloud for
his/her organization and interested in validating his/her im-
plementation during the development phase with respect to
functional and security requirements.
2) a tester, who is interested in testing whether the imple-
mentation of the cloud satisÔ¨Åes its design speciÔ¨Åcations and
security requirements.
3) a security expert, who wants to validate whether the
cloud implementation has any security loopholes that may
give access rights to the unauthorised users or prevent the
authorised users to access the resources.
4) an automated testing script, which uses CM as a test
oracle and invokes the cloud implementation through the
cloud monitor to validate the authorization policy for all the
resources. The invocation results can be logged for further
fault localization.
In the next section, we present our design approach to spec-
ifying the behavioral interfaces for the RESTful architectures.
IV. DESIGN APPROACH
Our approach focuses on modelling APIs that are REST
compliant
[35]. We use UML (UniÔ¨Åed Modeling Lan-
guage) [38], which is well accepted both in industry and
academia, and has many associated industrial-strength au-
tomated tools. We brieÔ¨Çy describe the construction of our
resource and behavioral models using Cinder component of
OpenStack introduced in section II as an example.
528
OpenStack services deÔ¨Åne the permitted requests based on
the access rules introduces in their policy.json Ô¨Åles, which
follow Role Based Access Control (RBAC) paradigm [17].
Similarly to the other OpenStack services, Cinder uses Key-
stone service to validate the user‚Äôs credentials and authoriza-
tion requests [6].
The starting point of our approach is Cloud API, i.e., Cinder
API [2]. It gives a textual description of which methods can
be invoked on the cloud service, the request-response pairs,
and the conditions for invoking those methods (if applicable).
We consider volume resource of Cinder Service (a part of
Volumes collection resource) as our example because it is the
central resource offered by Cinder. A collection resource does
not have any attributes on its own. It merely contains a list
of other resources. A normal resource has its own attributes
and represents a piece of information. The users are assigned
to projects in OpenStack. Each project in OpenStack has a
corresponding quota, which limits the number of volumes that
can be created in the project. The quota controls the resource
consumption across the available hardware resources. Figure
3 shows the design models that elaborate on the structural and
stateful behavior of a speciÔ¨Åc project.
A. Resource Model
We use the UML class diagram [38] with the additional
design constraints to represent resources, their properties, and
the relations between each other. We use the term resource
deÔ¨Ånition to deÔ¨Åne a resource entity such that its instances are
called resources. This is analogous to the relationship between
a class and its objects in the object-oriented paradigm.
A collection resource deÔ¨Ånition is represented by a class
with no attributes and a normal resource deÔ¨Ånition has one
or more attributes. Each association has a name as well as
minimum and maximum cardinalities showing the number of
resources that can be part of the association.
Figure 3 (left) shows two collections resource deÔ¨Ånitions ‚Äì
Projects and Volumes. There are also four normal resource
deÔ¨Ånitions ‚Äì project, volume, quota sets and usergroup. A
collection resource deÔ¨Ånition has one outgoing transition with
multiplicity of 0...* for the contained resource deÔ¨Ånition
indicating that a collection resource can have none or many
resources. The GET method on a collection resource returns
a list of all the child resources that it contains.
To form URI addresses, every association should have a
role name. The attributes of classes should be public since
the representation of a resource should be available for the
manipulation. Hence, they must have a type, because they
represent a document containing an information about the
resource, i.e., an XML document or a JSON serialized object.
B. Behavioral Model
The projects are created by the cloud administrator using
Keystone and users or usergroups are assigned the roles in
these projects. It deÔ¨Ånes the access rights of the cloud users
in the project. A volume can be created, if the project has
not exceeded its quota of the permitted volumes and a user
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:49:51 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 3.
(Left) Extract of Cinder Resource Model. (Right) Extract of Cinder Behavioral Model
is authorized to create a volume in the project. Similarly, a
volume can be deleted, if the user of the service is authorized
to do so, and the volume is not attached to any instance, i.e.,
its status is not in-use.
We represent the behavioral interface of the REST API
by a UML state-machine [38]. Figure 3 (right) shows an
interface of Cinder API for
excerpt from the behavioral
a project. It contains the information about
the methods,
which a user can invoke on the volume resource and the
invocation conditions. In the example shown, at any given
time a project can be only in one of three states. A project
initially starts with no volumes attached to it. A volume
is added to the project by the POST request. The re-
quest method can only be triggered, if the user belongs to
the usergroup admin or member. As a result,
the project
transits to the project with volume and not full quota state.
The subsequent POST requests on the project will keep
it either in the same state or transfer to the project with
volume and full quota state, depending on the guard condi-
tions. The DELETE method can only be invoked, if the status
of the volume is not in-use and user belongs to the usergroup
admin. The change of the project state depends on the guard
conditions.
We deÔ¨Åne the invariant of a state using OCL [31] as a
boolean expression over the addressable resources. In this way,
the stateless nature of REST remains uncompromised because
no hidden information about the state of the service gets stored
between the method calls.
3
the
for
shows
Figure
state
state
invariant
project with no volume written as
following OCL
the
expression:
project.id‚àí > size() = 1
project.volumes‚àí >
size() = 0. It means that
the project ID exists and has
no volumes attached to it
in this state. The condition
project.V olumes‚àí > size() = 0 implies that the response
for invoking GET on the Volumes resource for the project
was not 200, meaning either the resource does not exist or is
and
not reachable to infer anything about its state. Similarly, the
OCL expression project.id‚àí > size() = 1 implies that the
response for invoking GET on project resource was 200, i.e.,
the resource exists. The state invariant:
project.id‚àí > size() = 1
project.volumes‚àí >
size() = 0 speciÔ¨Åes that initially a project exists but no
volume is attached to it.
and
C. Authorization
Authorization in OpenStack, and other open source clouds
(e.g., [11], [29]) is based on RBAC model [17]. In RBAC, the
access rights of a user are deÔ¨Åned by his/her role. We assume
that the information about the roles and the corresponding
access rights to the resources is well-deÔ¨Åned and available for
the cloud developer and security analyst.
In the current industrial practice, this information is usually
given in a tabular format. We specify this information as
the guards in the OCL format, which makes it amenable to
an automated translation into the method contracts. In the
behavioural model, each method should be labeled with a
corresponding security requirement represented as a comment
on a transition or state, as shown in Figure 3. When a state or
transition with the requirement annotation is traversed, we get
an indication which security requirement is met. This provides
traceability of security requirements during the validation
phase.
Table I outlines the security requirement of our example
cloud implementation for volume resource. It speciÔ¨Åes three
types of roles implemented in the given project, namely admin,
member, and user. Different user groups can belong to these
roles.
V. CONTRACT GENERATION
The interface of a cloud service advertises the operations
that can be invoked on it. A cloud developer Ô¨Ånds the cloud
service API on the web and integrates it with the other services
by invoking the advertised operations and providing it with the
required parameters.
529
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:49:51 UTC from IEEE Xplore.  Restrictions apply. 
Resource
Volume
SecReq
1.1
Request
GET
1.2
1.3
1.4
PUT
POST
DELETE
Role
admin
member
user
admin
member
admin
member
admin
UserGroup
proj administrator
service architect
business analyst
proj administrator
service architect
proj administrator
service architect
proj administrator
SECURITY REQUIREMENTS FOR CINDER API (EXCERPT)
TABLE I
These operations may imply a certain order of invocation or
assume special conditions under which they can be invoked.
Such conditions, i.e., pre- and post-conditions of a method,
constitute contracts. This information together with the ex-
pected effect of an operation form a part of the behavioral
interface of a service.
When the method m triggers a transition t in a state machine,
the pre-condition for the method m should be true, i.e., the
invariant of the source state of transition t and the guard on t
evaluate to true.
For example, we are interested in generating a pre-condition
to invoke the DELETE method on the volume resource,
as shown in Figure 3 (right). DELETE on volume in-
vokes three transitions in the behavioral model: one from
the state project with volume and full quota and two from
the state project with volume and not full quota. We should
note that while there are three different transitions triggered by
DELETE(volume), the actual implementation should combine
the behavior of these transitions into one method. Therefore, in
order to generate the method contract, we need to combine the