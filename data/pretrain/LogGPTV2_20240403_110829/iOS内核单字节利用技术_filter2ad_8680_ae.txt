最后，是时候将vm_map_copyout_internal()从for循环中断开了。
        for (entry = vm_map_copy_first_entry(copy);
            entry != vm_map_copy_to_entry(copy);
            entry = entry->vme_next) {
vm_map_copy_to_entry(copy) 宏扩展为:
        (struct vm_map_entry *)(&copy->c_u.hdr.links)
因此，为了跳出循环，我们需要处理一个vm_map_entry，其中vme_next
指向最初传递给此函数的已损坏的vm_map_copy中c_u.hdr.links 字段。
该函数目前在“done” vm_map_entry上转换，我们需要链接到一个最终的“overlay”
vm_map_entry中，以解决pmap/vm_map冲突问题。因此，打破循环的最简单的方法是修改“overlay”条目的vme_next，使其指向&copy->c_u.hdr.links。然后更新“done”条目的vme_next，以指向覆盖条目。
问题是前面提到的对vm_map_copy_insert()的调用，它释放vm_map_copy，好像它是ENTRY_LIST类型:
    zfree(vm_map_copy_zone, copy);
但是，传递给zfree()的对象是已破坏的vm_map_copy，它是由kalloc()分配的;尝试将其释放到vm_map_copy_zone将导致panic。因此，我们需要确保将一个不同的、合法的vm_map_copy对象传递给zfree()。
如果您查看了vm_map_copyout_internal（）的反汇编，vm_map_copy指针会在for循环期间溢出到堆栈中!
    FFFFFFF007C599A4     STR     X28, [SP,#0xF0+copy]
    FFFFFFF007C599A8     LDR     X25, [X28,#vm_map_copy.links.next]
    FFFFFFF007C599AC     CMP     X25, X27
    FFFFFFF007C599B0     B.EQ    loc_FFFFFFF007C59B98
    ...                             ; The for loop
    FFFFFFF007C59B98     LDP     X9, X19, [SP,#0xF0+dst_addr]
    FFFFFFF007C59B9C     LDR     X8, [X19,#vm_map_copy.offset]
这样就可以很容易地确保传递给zfree()的指针是从vm_map_copy_zone分配的一个合法的vm_map_copy:只要在vm_map_copyout_internal()线程转换时扫描它的内核堆栈，并将指向破坏的vm_map_copy的指针与合法的指针交换。
最后，我们已经完全修复了状态，允许vm_map_copyout_internal()中断循环并安全返回。
在虚拟内核读/写原语和vm_map_copyout_internal()线程安全返回后，我们实现了我们的目标:通过将一个字节控制的堆溢出直接转换为任意物理地址映射原语。
准确地说，一个几乎任意的物理地址映射原语。正如我们所看到的，PPL保护的地址无法使用此技术进行映射。
单字节技术最初似乎与主流的攻击流相对应。在阅读了vm_map.c和pmap.c中的代码之后，我希望能够简单地将所有DRAM映射到我的地址空间，然后通过使用这些映射执行手动页表遍历来实现内核读/写。但实践证明，PPL通过阻止某些页面被映射来阻止这种技术在目前iOS上应用。
有意思是，类似的研究在几年前也曾被提过，那时这样的研究本是可行的。为这篇文章做背景调查的时候,我遇到了一个由Aximum公司提出的名为“[iOS 6
Kernel Security:A Hacker’s
Guide](https://conference.hitb.org/hitbsecconf2012kul/materials/D1T2%20-%20Mark%20Dowd%20&%20Tarjei%20Mandt%20-%20iOS6%20Security.pdf)”:介绍了至少四个独立的原语，这些原语可以通过破坏vm_map_u
copy_t的各个字段来构建：相邻内存泄漏、任意内存泄漏、扩展堆溢出，以及地址泄漏和已公开地址的堆溢出的组合。
在演示时，KERNEL_BUFFER 类型有一个稍微不同的结构，因此c_u.hdr.links.next 与存储vm_map_copy
的kalloc（）分配大小的字段重叠。在某些平台上，仍然可以将一个字节的溢出转换为物理内存映射原语，但这将更加困难，因为这将需要映射空页和共享地址空间。但是，上述四种技术中使用的更大的溢出肯定会改变type和c_u.hdr.links.next字段。
在OS X
10.11和ios9中，修改vm_map_copy结构，删除KERNEL_BUFFER实例中冗余的分配大小和内联数据指针字段。这样做可能是为了减轻这种结构在利用中被频繁滥用的情况，尽管很难判断，因为这些字段是冗余的，可以简单地删除来清理代码。无论如何，删除这些字段将vm_map_copy更改为当前形式，将执行该技术所需的前提条件演变为单字节溢出。
###  缓解机制
那么，各种iOS内核漏洞攻击缓解措施在阻止单字节技术方面效果如何，如果进一步加强，效果会有多大？
我考虑的缓解措施包括KASLR、PAN、PAC、PPL和zone_Required。还有许多其他的缓解措施，但它们要么不适用于堆溢出类漏洞，要么它们不是缓解这种特定技术的最佳方案。
首先，内核地址随机化(KASLR)。在虚拟内存中移动kernelcache
image，以及kernel_map和submaps(zone_map、kalloc_map等)的随机化，它们统称为“kernel
heap”。内核堆随机化表明确实需要某种方法来确定我们在其中伪造的VM对象的内核/用户共享内存缓冲区的地址。。但是，一旦有了共享缓冲区的地址，两种形式的随机化都不会对该技术产生太大影响，原因有两个：首先，存在通用的iOS内核堆原语，vm_map_copy
之前分配的区域，可用于将所有分配放入目标kalloc中。所以随机化不会阻止初始内存破坏。其次，在破坏发生后，授权的原语是任意物理读/写的，这与虚拟地址随机化无关。
唯一影响exploit的地址随机化是物理内存中的kernelcache加载地址的随机化。当iOS启动时，iBoot以随机地址将内核缓存加载到物理DRAM中。正如第一部分所讨论的，这种物理随机化只有32
MB，但是，改进的随机化不会有帮助，因为AMCC硬件寄存器可以被映射到物理内存中的内核缓存，而不管它位于哪里。
其次考虑PAN，这是一种ARMv8.1安全缓解措施，可防止内核直接访问用户空间虚拟内存，从而防止覆盖指向内核对象的指针，以使它们指向用户空间中的伪造的对象的常见技术。绕过PAN是此技术的前提条件:我们需要在一个已知地址上建立vm_map_entry、vm_object和vm_page对象的结构。虽然对于这个POC来说，对共享缓冲区地址进行硬编码已经足够好了，但要真正利用它，还需要更好的技术。
PAC，即指针身份验证代码，是苹果A12
SOC中引入的ARMv8.3安全特性。iOS内核使用PAC有两个目的:首先是针对常见漏洞的利用缓解措施，其次是作为内核控制流完整性的一种形式，以防止使用内核读/写的攻击者获得任意代码执行。在这个设置中，我们只对PAC作为一种漏洞利用缓解措施感兴趣。
Apple的网站上有一个表格显示了各种类型的指针是如何被PAC保护的，这些指针大部分都是被编译器自动PAC保护的，到目前为止PAC对c++对象的影响最大，尤其是IOKit。同时，单字节利用技术只涉及vm_map_copy、vm_map_entry、vm_object和vm_page对象，这些都是内核Mach部分中的普通C结构，因此不受PAC的影响。
但是，在BlackHat 2019上，苹果公司的Ivan Krstić
将很快用于保护某些“重要的数据结构成员”，包括“进程、任务、代码签名、虚拟内存子系统，IPC结构”。截至2020年5月，增强的PAC保护尚未发布，但如果实施，它可能会有效地阻止单字节技术。
下一个缓解是PPL，它代表页面保护层。PPL在管理页表的代码和XNU内核之间创建了一个安全边界。这是除PAN之外唯一影响该利用技术的缓解措施。
在实践中，PPL在允许将哪些物理地址映射到用户空间进程方面要严格得多。例如，用户空间进程访问内核缓存页面没有合法的用例，因此在kernelcache页面上设置PVH_FLAG_LOCKDOWN这样的标志可能是一个微弱但明智的步骤。一般而言，对于大多数进程而言，可能会使应用处理器的DRAM区域之外的地址（包括用于硬件组件的物理I/O地址）无法映射，可能会有一个特殊情况下逃逸权限。
最后一个缓解是zone_require，这是在iOS
13中引入的一个软件缓解机制，它在使用一些内核指针之前检查它们是否从预期的zalloc区域分配。我认为XNU的区域分配器最初并不是为了降低安全性，在漏洞利用期间经常成为目标，许多对象(特别是ipc_ports、tasks和threads)都是从专属zone分配的。
理论上，zone_require可以用来保护从专属区域分配的几乎所有对象;但事实上，kernelcache中的绝大多数zone_require()检查都是在ipc_port对象上进行的。因为单字节技术避免了使用伪造的Mach
ports，所以现有的zone_require()检查都不适用。
但是，如果扩大了zone_require的使用范围，则有可能缓解该技术。特别是，一旦vm_map_copyout_internal()确定了vm_map_copy的类型为ENTRY_LIST，那么在vm_map_copy中插入一个zone_require()调用，将确保vm_map_copy不会是具有已破坏的KERNEL_BUFFER对象。当然，与所有缓解措施一样，这也不是100%可靠的:在exploit中使用该技术仍然可以，但是与单字节溢出相比，它可能需要更好的原语。
## 0x05 “附录A”：漏洞利用史
在我看来，在这篇文章中介绍的单字节利用技术与至少自iOS
10以来采用的传统方法是有区别的。自从iOS10以来，我发现的24个原始公开漏洞中，有19个使用伪造Mach ports
作为exploitation原语。在iOS10.3 以来公布的20个exploits中，有18个是通过构建一个伪造的内核task port，这使得Mach
ports成为目前iOS内核利用的特性。
在经历了使用单字节技术在模拟堆溢出的基础上构建内核读/写原语的过程之后，，我可以看到使用内核task
port的逻辑。自从iOS10之后，我看到的大多数exploits都有一个相对模块化的设计和流程：获得初始原语，操作状态，采用漏洞利用技术来构建更强大的原语，再次对状态进行操作，然后应用另一种技术，等等，直到最后你有足够的能力来构建一个伪造的内核task
port。整个过程都有所检查：初始破坏、挂起的Mach
port、4字节读原语等等。每一种情况下的具体步骤顺序是不同的，但大体上来讲，不同exploits的设计是一致的。由于这种趋势，最后一个exploits的步骤几乎可以与其他任何exploits的步骤互换。
这种模块化并不适用于这种单字节技术。一旦启动了vm_map_copyout_internal()循环，就会一直执行这个过程，直到获得内核读/写原语为止。并且由于vm_map_copyout_internal（）在循环期间持有
vm_map
锁，因此无法执行任何虚拟内存操作(比如分配虚拟内存)，而这些操作通常是常规漏洞利用中不可缺少的步骤。因此，编写这个exploit感觉有所不同，更麻烦。
话虽如此，单字节方法给我直接的感觉是“技术上更精巧”:它将较弱的前提条件直接转化为非常强大的原语，同时避开了大多数缓解措施，避免了通用iOS漏洞利用中出现的大多数不稳定因素。在我所分析的24个iOS漏洞中，有22个依赖于重新分配一个最近被释放的对象的slot。除了SockPuppet这个例外，这是一个危险操作，因为另一个线程可能会重新分配该slot。此外，自从iOS
11以来的19个exploits中有11个依赖于强制垃圾回收区域，这是一个更危险的步骤，通常需要几秒钟才能完成。
同时，单字节技术没有内在的不稳定因素或大量的时间成本。看起来更像是我认为熟练的攻击者会感兴趣的技术类型。即使在漏洞利用过程中出了点问题，并且内核中取消了错误地址的引用，持有
vm_map
锁的也证明该错误会导致死锁而不是内核崩溃，exploit失败看起来像冷冻过程而不是系统崩溃。你甚至可以在应用切换UI中“kill”死锁应用，然后继续使用该设备。
## 0x06 “附录B”：结论
最后，我将回到本文最开始的三个问题：
  * 1.将内核task port作为目标真的是最好的利用方法吗？
  * 2.还是这种趋势掩盖了其他也许更好的技术？
  * 3.现有的iOS内核缓解措施是否同样有效地防止了其他以前未被发现的漏洞利用方法？
这些问题都太“模糊”，无法给出具体的答案，但是无论如何我都会尝试回答。
对于第一个问题，我认为答案是否定的，内核task
port不是唯一的最佳利用方法。单字节技术在大多数情况下都一样好用，而且在我个人看来，我希望还有其他尚未公布的技术也一样好用。
对于第二个问题，关于内核task
port的趋势是否已经掩盖了其他技术:我认为没有足够公开的iOS研究来给出结论，但我的直觉是肯定的。根据我自己的经验，了解我要寻找的漏洞类型影响了我所发现的漏洞，并且回顾过去的exploits指导了我在漏洞利用过程中的选择。
最后，现有的iOS内核漏洞利用缓解措施是否有效地防止了未被发现的漏洞利用方法？在我为单字节技术开发了POC之后，我认为答案是否定的；但是在这次分析的最后，我不太确定。我不认为PPL是专门设计来防止这种技术的，PAC并没有做任何事情来阻止这种技术，但是将来PAC保护的指针可能会阻止这种技术。虽然zone_require根本没有影响该exploit，但是添加一行代码将是从单字节溢出增强为跨越区域边界的溢出所需的前提条件。因此，即使以目前的形式，Apple的内核漏洞利用缓解措施对于这种未公开的技术也无效。
最后一个想法。在2018年公开的Deja-XNU中，Ian Beer考虑了四年前iOS内核利用的”state-of-the-art” ：
一段时间以来，我一直想尝试的一个想法是，利用我在iOS学习到的知识，重新研究过去的漏洞，然后尝试再次利用它们，我希望这篇文章能让我们了解到几年前最新的iOS漏洞利用是什么样子的，如果我们能进一步思考目前最新的iOS漏洞利用是什么样子的话，这篇文章可能会对我们有所帮助。
这是一个需要考虑的问题，因为作为防守方，我们从来没有看到过最前沿攻击者的能力。如果攻击者在私下使用的技术和防守方所知道的技术之间出现了差距，则防守方可能会浪费资源来缓解这种技术。
我不认为这种技术代表了目前最新的技术。就像Deja-XNU一样，它可能代表了几年前的水平。值得考虑的是，在此期间，最新的技术可能会走向什么方向。