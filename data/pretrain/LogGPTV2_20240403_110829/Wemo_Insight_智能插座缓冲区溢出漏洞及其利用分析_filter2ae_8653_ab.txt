fuzzing期间收集更多有关崩溃的信息。首先，我们需要编译对这个架构进行更深入分析所需的工具。我们使用GPL为设备编译了gdbserver和gdb。Wemo有大量安装工具，例如“wget”，这使得添加文件变得很简单。我们从/tmp目录下载并执行这些工具。
经过大量尝试，我们始终不能让gdb直接或远程地使用该设备运行。于是我们使用gdbserver和Interactive Disassembler
Pro进行调试。连接调试器发送导致崩溃的数据包，我们看到了崩溃的确切位置。地址0x2AC15B98出现段错误。从linux
proc目录中的内存布局，我们确定了它的内存地址驻留在libUPnPHndlr.so库中。
    2abf3000-2ac4d000 r-xp 00000000 1f:02 82 /rom/lib/libUPnPHndlr.so
因为崩溃是由UPnP数据包引起的，所以在这个库中找到崩溃是合乎逻辑的。在基地址0x2abf3000下，我们计算出IDA中静态分析的偏移量为0x22b98。在这个地址，我们发现：
    LOAD:00022B70  # =============== S U B R O U T I N E =======================================
    LOAD:00022B70
    LOAD:00022B70
    LOAD:00022B70                 .globl TokenParser
    LOAD:00022B70 TokenParser:                             # CODE XREF: ProcessEnergyPerunitCostNotify+84↓p
    LOAD:00022B70                                          # DATA XREF: LOAD:00004210↑o …
    LOAD:00022B70                 beqz    $a1, locret_22BC0
    LOAD:00022B74                 move    $a3, $zero
    LOAD:00022B78                 move    $a3, $zero
    LOAD:00022B7C                 b       loc_22BB4
    LOAD:00022B80                 li      $t0, 0x7C  # ‘|’
    LOAD:00022B84  # —————————————————————————
    LOAD:00022B84
    LOAD:00022B84 loc_22B84:                               # CODE XREF: TokenParser+28↓j
    LOAD:00022B84                 addiu   $a1, 1
    LOAD:00022B88                 addiu   $v1, 1
    LOAD:00022B8C
    LOAD:00022B8C loc_22B8C:                               # CODE XREF: TokenParser+48↓j
    LOAD:00022B8C                 lb      $v0, 0($a1)
    LOAD:00022B90                 beql    $v0, $t0, loc_22BA4
    LOAD:00022B94                 sb      $zero, 0($v1)
    LOAD:00022B98                 bnezl   $v0, loc_22B84
    LOAD:00022B9C                 sb      $v0, 0($v1)
    LOAD:00022BA0                 sb      $zero, 0($v1)
    LOAD:00022BA4
    LOAD:00022BA4 loc_22BA4:                               # CODE XREF: TokenParser+20↑j
    LOAD:00022BA4                 beqz    $a1, locret_22BC0
    LOAD:00022BA8                 addiu   $a0, 4
    LOAD:00022BAC                 addiu   $a1, 1
    LOAD:00022BB0                 addiu   $a3, 1
    LOAD:00022BB4
    LOAD:00022BB4 loc_22BB4:                               # CODE XREF: TokenParser+C↑j
    LOAD:00022BB4                 slt     $v0, $a3, $a2
    LOAD:00022BB8                 bnezl   $v0, loc_22B8C
    LOAD:00022BBC                 lw      $v1, 0($a0)
    LOAD:00022BC0
    LOAD:00022BC0 locret_22BC0:                            # CODE XREF: TokenParser↑j
    LOAD:00022BC0                                          # TokenParser:loc_22BA4↑j
    LOAD:00022BC0                 jr      $ra
    LOAD:00022BC4                 move    $v0, $a3
    LOAD:00022BC4  # End of function TokenParser
因为开发人员没有对二进制文件进行处理，所以我们可以把这个函数命名为TokenParser。段错误发生在分支语句上；但是在MIPS中，延迟指令是在分支发生之前执行的。所以0x22B9C上的指令导致了崩溃。在这里，应用程序尝试加载存储在$v1中的地址，并把它放到$v0中。查看寄存器，我们发现XML标记“EnergyPeritCostVersion”中数据包的数据以$v1为单位，导致了“invalid
write access”段错误。
在静态分析该函数之后，它似乎把数据从一个部分复制到另一个部分，而且三次查找0x7C或“”字符。如果没有找到“”，它就会继续复制到静态定义的缓冲区中。为了充分理解为什么会发生覆盖，让我们在遍历函数时查看堆栈：
    2EF17630 2AC692F0 MEMORY:2AC692F0
    2EF17634 00000000 MEMORY:saved_fp
    2EF17638 34333231 MEMORY:34333231 ← 之前复制的数据
    2EF1763C 00000035 MEMORY:retaddr+31  ← 下一字节将被写到0x2EF1763D
    2EF17640 00000000 MEMORY:saved_fp  ← 复制前先清零
    2EF17644 00000000 MEMORY:saved_fp
    2EF17648 00000000 MEMORY:saved_fp
    2EF1764C 00000000 MEMORY:saved_fp
    2EF17650 2EF17638 MEMORY:2EF17638 ← 开始写入; 可能被覆盖
当函数将数据复制到堆栈时，它最终会复制原始缓冲区的地址。一旦这个地址被覆盖，函数将尝试在新值处写入下一个字节，在本例中为无效地址。这个溢出为攻击者提供了两个可利用的向量：write-what-where条件使得攻击者能在内存的任意位置中写入数据；通过继续覆盖堆栈上的数据，攻击者可以覆盖调用函数的$RA寄存器或返回地址，从而控制执行流。
## 编写利用代码
现在我们了解了这个漏洞，我们能利用它吗？因为这是一个标准的缓冲区溢出，我们需要回答两个问题。堆栈上有多少可用空间，是否存在无法放到堆栈上的“坏”字节？为了确定可用的空间，如果我们用有效地址修复覆盖在堆栈上的地址，就可以检查有多少payload使其进入堆栈。我们了解到只有91个字节可以写入堆栈。
下一步是确定是否存在“坏”字节。经过几次测试，我们注意到只有ASCII字符才能进入堆栈。在执行易受攻击的代码之前，数据包将由开源xml解析器“mxml”解析。这个库遵循在标记之间只允许存在ASCII和Unicode字符的标准。
这个标准对于shellcode和ROP技术都是非常困难的，因为内存地址和shellcode都倾向于使用大多数不可读的字符。我们可以使用几种技术来消除堆栈上的空间；但是由于通过XML对字符的严格限制，最好使用已经加载到内存中的函数。一种不需要大量shellcode的方法是使用“return
to
libc”攻击来执行系统命令。因为系统调用通常以字符串作为参数，这可能通过筛选器。因为WEMO不使用ASLR(地址空间布局随机化)，如果我们使用ROP，理论上可以调用系统而不需要通过XML过滤器传递额外的shellcode。
还有一个重大挑战：只有完全包含ASCII字符的地址才能通过XML过滤器。这极大地限制了可用工具的范围。我们使用IDA查看libc和system加载到内存中的位置，发现：libuClibc-0.9.33.2.so在地址0x2B0C0FD4；libpthread-0.9.33.2.so在地址0x2AD104F4。但是，这两个地址都不满足通过XML过滤器的要求。因此，即使我们能够创建一个ROP链，我们也不能只发送数据包中系统的地址。
具有非法字符的地址不是利用开发的新问题。最常见的绕过技术之一是使用加法或减法ROP
gadget在寄存器中创建所需的地址并调用该寄存器。但是，由于XML过滤器，我们还面临着操作数可以用于这个加减方程的限制。
在研究了内存布局之后，我们发现libuClibc-0.9.33.2.so位于一个具有可以绕过XML过滤器的地址。我们很幸运，这是一个大型库，提供了一个不错的地址列表，因为它是这一空间中的唯一库。有了这一发现，我们的团队创建了一个工具来帮助创建此漏洞。这个工具提取具有可用内存地址的所有可能的ROP
garget，并确定只使用能绕过筛选器的值，加法或减法等式是否可以调用内存中找到的两个系统调用之一。libuClibc-0.9.33.2.so的系统地址0x2B0C0FD4中没有任何可用的操作数。但是0x2AD104F4有，我们找到了几个操作数，当它们加在一起时，等于0x2AD104F4。
我们将工具的输出用于所有可能的ROP
garget，这些garget绕过过滤器构建ROP链，使用加法指令为系统创建最终地址，并将其存储在$S0中。加法指令之后，另一个garget将系统地址移动到$t9并调用system。最后一个garget还将可以从堆栈控制的地址移动到寄存器中，保存系统调用的参数。整个ROP链仅由三个garget组成，它们很容易适应缓冲区溢出提供的堆栈空间。
## 组合所有东西
更早的时候，我们发现了两种攻击技术，它们可以和这个漏洞一起使用：write-what-where，以及覆盖堆栈上的返回地址。每种技术每个发送的数据包都可以使用一次。要获得一个参数到系统调用，我们必须使用write-what-where在一个可写内存地址放置参数，并将这个地址传递给系统。幸运的是，这个易受攻击的应用留出了大量从未使用的可写内存，并且在一个可以绕过筛选器的有限地址集可以访问的范围内。不幸的是，调用系统的ROP链要求在ROP
garget中使用write-what-where来处理额外的指令。这意味着执行该漏洞需要两个数据包：一个将系统参数写入内存，另一个将调用系统。因此，重要的是，第一个数据包完全退出而不使程序崩溃。
一种方法是在payload内使用三个“|”，以便在适当的时间停止写入和退出TokenParser。还有同样重要的是，不要覆盖RA指针，这样程序可以在接收到数据包后继续正常执行。然后发送包含ROP链调用系统的第二分组，其中包含由前一个分组写入的参数的地址。
## Payload
发现能够调用系统的有效ROP链后，我们必须决定应该调用哪个系统。因为具有系统根权限，所以我们可以获得对设备的完全控制。我们的研究表明设备安装了许多Linux命令。我们在前面的wget中利用这一点将gdbserver复制到设备上。攻击者还可以从系统调用wget来下载和执行任何脚本。我们还探索了安装的应用，找到了Netcat，它允许攻击者编写脚本来创建反向shell。攻击者可以使用wget下载脚本，并执行包含Netcat命令的脚本来创建反向shell。我们测试并证明了这是一个打开一个反向shell的简单有效的方法。攻击者还可以选择其他许多方法来利用这个漏洞并执行代码。下面的视频演示了这个漏洞如何使用反向shell。
视频地址（失效请看原博）：
作为演示，团队编写了一个攻击场景。在插座被破坏后，它可以使用内置的UPnP库在网络路由器上插入一个后门。这个漏洞为攻击者创建了一个后门通道用于远程连接，而网络上却没有注意到这一点。在下面的视频中，我们使用一个远程shell来控制连接到网络的TCL智能电视。电视的Roku
API使用简单的未加密的HTTP
GET/POST请求来发送命令，并且不对发送这些命令的机器进行身份验证，这使得远程控制变得非常容易。利用Wemo作为中间人，攻击者可以打开或关闭电视，安装或卸载应用，并访问任意在线内容。这只是使用WEMO攻击另一个设备的一个例子。由于攻击者已在网络上站稳脚跟并能够打开任意端口，任何连接到这个网络的计算机都将面临风险。由于可以通过WEMO进行攻击，并且使用此漏洞生成的端口映射在路由器的管理页面中不可见，因此很难检测到攻击者。
演示视频（失效请看原博）：
## 结论
诸如CVE-2018-6692这样的发现证明了在所有设备上进行安全编码实践的重要性。从安全的角度来看，物联网设备经常被忽视；这可能是因为许多设备被用于看似无害的目的，例如简单的家庭自动化。然而，这些设备运行操作系统，需要与桌面计算机一样多的保护。我们发现的漏洞可能成为攻击者需要进入并危及整个业务网络的立足点。
McAfee高级威胁研究小组的一个目标是识别和阐明当今复杂和不断发展的环境中的广泛威胁。通过分析和负责任的披露，我们的目标是指导产品制造商走向更全面的安全态势。