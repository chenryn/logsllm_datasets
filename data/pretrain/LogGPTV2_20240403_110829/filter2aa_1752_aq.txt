程。文程能
或的。
实时然写程的时们及时
。的操作实时程的。
同实时。实上相同的件件
实时更能实时原即
实时进程的。的实时的同操作
时的。的子出的内 SCRAM 
的能。操作的实
时。相能 100ms 内
或出的对操作的实
时。
6.5.2 延时，抖动和截止期限
时的时间时小操作
。实时操作时的以的间
– 186 –
 6 
进程理
时处理。实时时出
内。
时的时间。然给
上时间及时的能。的的方
处理实上们时间的。件间的时间
时。
 10ms 的。性能我们给上
时间 10ms 间的我们的
间的。的时间我们
间的时间即 10ms 我们何时
。或更的时的实
时。以的的的
的。何我们对实
实时出小的们段时间
段时间内。零时操作间。时超
间。
实时对更。理时间操作
间内时。以时作性
能的。
6.5.3 Linux 的实时支持
Linux  IEEE Std 1003.1b-1993(写 POSIX 1993 或 POSIX.1b) 的
调程提实时。
上 POSIX 提的实时。实
上 POSIX 的调操作何时
间操作设。
 Linux 内性能的的实时
提小的时更的。原进能
程 I/O 进程实时进对
Linux 式实时的献。
的式实时对 Linux 内的存
的 Linux 方的方内。的进步
– 187 –
 6 
进程理
时实时的。的方内内
。的实时 POSIX 的
。
6.5.4 Linux 调度策略和优先级
linux 对进程的调进程的调调。 Linux
提实时调作的。文件  的
示:  SCHED FIFO, SCHED RR  SCHED OTHER。
进程 nice 的对程
0对实时程 1  99。 Linux 调的进程
(的进程)。 50 的进程时
 51 的进程调进程新的
进程。相 49 的进程
50 的进程。进程 0以实时进程
实时进程。
6.5.4.1 “先进先出”策略
进出 (FIFO) 时间的单的实时。
进程 FIFO 进程 SCHED FIFO 示。
时间的操作相单:
• 的 FIFO 进程的进程
。的 FIFO 进程进程。
• FIFO 进程或调 sched yield()或进
程。
•  FIFO 进程时调将出。时
相同进程的。或同进程
。
•  FIFO 进程调 sched yield() 时调将同的
同进程。同
进程 sched yield() 将作。
•  FIFO 进程的。
进程的 FIFO 进程。
– 188 –
 6 
进程理
• 进程 FIFO 或进程将相
的。新的 FIFO 进程能同进程。
上我们以 FIFO 进程能
。的同的 FIFO 进程间的。
6.5.4.2 轮转策略
 FIFO 处理同进程的
以 SCHED RR 示。
调给 RR 进程时间。 RR 进程时间
时调将的方式 RR 进程间能
调。进程给上 RR 同 FIFO 
时间然。
我们以 RR 进程同 FIFO 进程时间的时
同的。
 SCHED FIFO 或 SCHED RR 内的操作 RR 
的时间相同的进程间相。 FIFO 进程 RR 进程
给进程间调出进程进程的
。
6.5.4.3 普通调度策略
SCHED OTHER 调的实时进程。
进程的 0 FIFO 或 RR 进程们。
调的 nice 进程的
 nice 的 0。
6.5.4.4 批调度策略
SCHED BATCH 调或空调的程上实时调
的对: 的进程进程时即
进程时间。同进程进程
进程时间。
6.5.4.5 设置 Linux 调度策略
进程以 sched getscheduler()  sched setscheduler() 操作 Linux 调
:
– 189 –
 6 
进程理
#include 
struct sched_param {
/* ... */
int sched_priority;
/* ... */
};
int sched_getscheduler (pid_t pid);
int sched_setscheduler (pid_t pid, int policy,
const struct sched_param *sp);
对 sched getscheduler() 的调将 pid 进程的调
 pid  0   调  进 程 的 调   。          
示 调   :SCHED FIFO  示  进  出   SCHED RR  示    
SCHED OTHER 示进程。 -1(-1 效的调
)同时设。
单:
int policy;
/* get out scheduling policy */
policy = sched_getscheduler (0);
switch (policy) {
case SCHED_OTHER:
printf (”Policy is normal\n”);
break;
case SCHED_RR:
printf (”Policy is round-robin\n”);
break;
case SCHED_FIFO:
printf (”Policy is fist-in, first-out\n”);
break;
case -1:
perror (”sched_getscheduler”);
break;
– 190 –
 6 
进程理
default:
fprintf (stderr, ”Unknown policy!\n”);
}
调 sched setscheduler() 将设 pid 进程的调的
 sp 。 pid  0 时进程将设自的。
 0 -1 设。
sched param     的  效  段    操 作     的 调   。
SCHED RR  SCHED FIFO 段 sched priority 
。 SCHED OTHER 何段然的调能。
的程对的布作出何设。
设进程调单:
struct sched_param sp = { .sched_priority = 1 };
int ret;
ret = sched_setscheduler (0, SCHED_RR, &sp);
if (ret == -1) {
perror (”sched_setscheduler”);
return 1;
}
设调进程调 1。我们设 1 效
 — 上。我们何效
。
设   SCHED OTHER  的 调       CAP SYS NICE 能 
 root 实时进程。 2.6.12 内 RLIMIT RTPRIO 
 root 上内设实时。
。时设:
EFAULT  sp 的内存或。
EINVAL policy 的调效或 sp 给的 (实
sched setscheduler())。
EPERM
调进程备的能。
ESRCH
pid 的进程。
– 191 –
 6 
进程理
6.5.5 设置调度参数
POSIX 的 sched getparam()  sched setparam() 以设
调的相:
#include 
struct sched_param {
/* ... */
int sched_priority;
/* ... */
};
int sched_getparam (pid_t pid, struct sched_param
*sp);
int sched_setparam (pid_t pid, const struct
sched_param *sp);
sched getscheduler() 调 sched getparam() 将 pid 进程
的调存 sp :
struct sched_param sp;
int ret;
ret = sched_getparam (0, &sp);
if (ret == -1) {
perror (”sched_getparam”);
return 1;
}
printf (”Our priority is %d\n”,
sp.sched_priority);
pid  0调进程的。 0 -1设。
 sched setscheduler() 能设何调以 sched setparam() 
:
struct sched_param sp;
int ret;
– 192 –
 6 
进程理
sp.sched_priority = 1;
ret = sched_setparam (0, &sp);
if (ret == -1) {
perror (”sched_setparam”);
return 1;
}
 sp 设 pid 进程的调 0。
-1设 errno。
我们上文段的出:
Our priority is 1
子设 1 时实的程
。我们何效的。
6.5.5.1 错误码
能设:
EFAULT  sp 的内存或。
EINVAL sp 给的 (实 sched getparam())。
EPERM
调进程备的能。
ESRCH
pid 的进程。
6.5.5.2 确定有效优先级的范围
上的子我们调。 POSIX 能
上的调 32 。Linux
调我们提 Linux 实时调提 1 
99  99 。的程实自的然映射
操作的上。同的实时以
。
Linux 提调小
:
#include 
– 193 –
 6 
进程理
int sched_get_priority_min (int policy);
int sched_get_priority_max (int policy);
sched get priority min()
小
sched get priority max()   policy      的    效   。  
调 0调 -1, 能的 policy 时
设 EINVAL。
单:
int min, max;
min = sched_get_priority_min (SCHED_RR);
if (min == -1) {
perror (”sched_get_priority_min”);
return 1;
}
max = sched_get_priority_max (SCHED_RR);
if (max == -1) {
perror (”sched_get_priority_max”);
return 1;
}
printf (”SCHED_RR priority range is %d - %d\n”,
min, max);
 Linux 上:
SCHED_RR priority range is 1 - 99
的。的以设进程
的相的:
/*
* set_highest_priority – set the associated pid’s
scheduling
* priority to the highest value allowed by its
current
– 194 –
 6 
进程理
* scheduling policy. If pid is zero, sets the
current
* process’s priority.
*
* Returns zero on success.
*/
int set_highest_priority (pid_t pid)
{
struct sched_param sp;
int policy, max, ret;
policy = sched_getscheduler (pid);
if (policy == -1)
return -1;
max = sched_get_priority_max (policy);
if (max == -1)
return -1;
memset (&sp, 0, sizeof (struct sched_param));
sp.sched_priority = max;
ret = sched_setparam (pid, &sp);
return ret;
}
程的小或然 1  ( max-1, max-2
)给的进程。
6.5.6 sched rr get interval()
 SCHED RR 进程 时间 SCHED FIFO 进程相
同。 SCHED RR 进程时间的时调将同的
。方式相同的 SCHED RR 进程。
进程时间进程 (同或的 SCHED FIFO 进
程) 。
POSIX 进程时间的:
– 195 –
 6 
进程理
#include 
struct timespec {
time_t tv_sec;
/* seconds */
long
tv_nsec;
/* nanoseconds */
};
int sched_rr_get_interval (pid_t pid, struct
timespec *tp);
sched rr get interval() 的对的调将 pid 
进程的时间存 tp 的 timespec 然 0
-1设 errno。
POSIX 能工作 SCHED RR 进程然 Linux 上
以进程的时间。能工作
 Linux 的程以作的展。子:
struct timespec tp;
int ret;
/* get the current task’s timeslice length */
ret = sched_rr_get_interval (0, &tp);
if (ret == -1) {
perror (”sched_rr_get_interval”);
return 1;
}
/* convert the seconds and nanoseconds to
milliseconds */
printf (”Our time quantum is %.2lf
milliseconds\n”,
(tp.tv_sec * 1000.0f) + (tp.tv_nsec /
1000000.0f));
进程 FIFO  tv sec  tv nsec  0的时间
。
– 196 –
 6 
进程理
6.5.6.1 错误码
能的:
EFAULT  tp 的内存效或。
EINVAL pid 效 ( pid )。
ESRCH
pid 效存的进程。
6.5.7 关于实时进程的一些提醒
实时进程的调程的时
。实时程能。程
实时程何处理的 — 或何的 — 
。
设实时程小的程
。提:
• 何处理的或进程
。将。
• 实时进程的以设的时
的处理时间。
• 小。实时进程进程的
进程处。
• 实时程的时更的进
程。的进程。 (空
的时实时进程。)
• util-linux 工的 chrt 实程以设实时进程属性更
。以单程实时调的或
的实时。
6.5.8 确定性
实时进程性。实时给相同的
作相同的时间内相同的我们作的。
以的集: 存 ()处理
页作时间能。然我们
– 197 –
 6 
进程理
作 (相对) 的同时
我们作的时间。
实时性的时。的
的方。
6.5.8.1 数据故障预测和内存锁定
:ICBM() 件设备
件内。进程件
设备上内进程。内进程实时进程
进程将调实时进
程。调实时进程上文相的空间。进程
程 0.3ms 1ms 的内。
空间实时进程的 ICBM处理。
实时进程。 0.1ms ABM 
。 —  —ABM 的上。页处理
内式 I/O 出的。实时进程
处理页。
然页给实时进程性。
实时或将空间的页提
理内存出。页内将出
何页实时页理内
存。
Linux    方   提    。 Chapter 4        的  
Chapter 8 将内存的。
6.5.8.2 CPU 亲和度和实时进程
实时的。然 Linux 内式的调
能调进程。时进程内的调