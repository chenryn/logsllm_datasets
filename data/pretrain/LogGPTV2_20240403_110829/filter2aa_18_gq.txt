### Windows Vista的安全增强

Windows Vista引入了额外的安全机制，以应对使用访问控制列表（ACL）保护系统时常见的问题。进程令牌中新增了一个必需的完整性级别（Integrity-Level）安全标识符（SID）字段，并且对象在系统访问控制列表（SACL）中指定了一个完整性级别访问控制条目（ACE）。完整性级别阻止对对象的写访问，即使在自由访问控制列表（DACL）中有允许写入的ACE。

特别地，完整性级别方案旨在防止被攻击者控制的Internet Explorer进程破坏系统。例如，当用户接受不妥建议从未知网站下载代码时，低权限的IE进程运行时会被设置为低完整性级别。而系统中的所有文件和注册表项则具有中等完整性级别，因此低完整性级别的IE进程无法修改它们。

近年来，Windows还增加了许多其他安全特性。对于Windows XP Service Pack 2，大部分系统组件在编译时启用了栈缓冲区溢出漏洞检测选项（/GS）。此外，在AMD64架构中，一种称为NX（不可执行）的设施可以限制在栈上执行代码。即使在x86模式下，处理器中的NX位也是可用的。NX标记页面，使其上的代码无法执行，从而即使攻击者利用缓冲区溢出漏洞插入代码，也难以跳转到代码处开始执行。

### Windows Vista的进一步安全特性

Windows Vista引入了更多安全特性来抵御攻击者。加载到内核态的代码需要经过检查（这是x64系统的默认设置），并且只有正确签名的代码才能被加载。每个系统中，动态链接库（DLL）和可执行文件（EXE）的加载地址以及栈分配的地址都进行了随机化处理，这使得攻击者很难利用缓冲区溢出漏洞跳转到已知地址并执行特权提升代码。这样，依赖于标准地址处的二进制数据的攻击将更难成功，系统在受到攻击时更可能只是崩溃，从而将潜在的特权升级攻击转化为危险性较小的拒绝服务攻击。

### 用户账户控制（UAC）

另一个重要的变化是引入了用户账户控制（UAC）。UAC解决了大多数用户以管理员身份运行系统这一长期存在的问题。尽管Windows的设计并不需要用户以管理员身份使用系统，但许多版本中忽视了这一点，导致用户如果不以管理员身份运行就无法顺利使用Windows。始终以管理员身份使用系统是危险的，因为用户的错误可能会轻易破坏系统，而且如果用户被欺骗或攻击而运行恶意代码，这些代码将拥有管理员权限并可能深入嵌入系统。

有了UAC，当尝试执行需要管理员权限的操作时，系统会显示一个特殊的桌面叠加层，并接管控制权，使只有用户的输入才能授权该操作（类似于C2安全中的CTRL-ALT-DEL）。虽然攻击者不需要成为管理员就可以破坏用户的个人文件，但UAC确实可以阻止现有的攻击类型。如果攻击者不能修改任何系统数据或文件，受损的系统恢复起来也会更容易。

### 受保护进程

Windows Vista中的最后一个安全特性是对受保护进程的支持。通常情况下，系统中的用户（由令牌对象表示）定义了权限边界。创建进程后，用户可以通过多种内核设施访问进程，进行进程创建、调试、获取路径名和线程注入等操作。受保护进程关闭了用户的这些访问权限。目前，此功能在Vista中的唯一用途是允许数字版权管理软件更好地保护内容。未来版本中，受保护进程可能会用于更友好的目的，如保护系统免受攻击者的侵害，而不是仅仅保护内容免受系统所有者的攻击。

### 提高Windows安全性

由于全球范围内针对Windows系统的攻击越来越多，微软近年来加大了提高Windows安全性的努力。其中一些攻击非常成功，导致整个国家和主要公司的计算机瘫痪，造成了数十亿美元的损失。这些攻击大多利用了编码中的小错误，这些错误可能导致缓冲区溢出，从而使攻击者通过重写返回地址、异常处理指针和其他数据来控制程序的执行。使用类型安全的语言而不是C和C++可以避免许多此类问题。即使使用这些不安全的语言，通过更好地理解参数和数据验证中的陷阱，也可以避免许多漏洞。毕竟，许多在微软编写代码的软件工程师几年前还是学生，就像正在阅读此研究的许多人一样。有许多书籍详细介绍了基于指针语言中可被利用的小错误类型及其如何避免（例如，Howard和LeBlanc，2007）。

### 小结

Windows Vista的内核态由硬件抽象层（HAL）、NTOS内核和执行体层以及大量实现设备服务、文件系统、网络和图形的设备驱动程序组成。HAL隐藏了硬件上的某些差异。内核层管理CPU以支持多线程和同步，执行体实现大多数内核态服务。

执行体基于内核态的对象，这些对象代表关键的执行体数据结构，包括进程、线程、内存区、驱动程序、设备以及同步对象等。用户进程通过调用系统服务来创建对象并获得句柄引用，以便后续调用执行体组件。操作系统也创建一些内部对象。对象管理器维护一个命名空间，对象可以插入该命名空间以备后续查询。

Windows系统中最重要的对象是进程、线程和内存区。进程拥有虚拟地址空间并且是资源的容器。线程是执行单元，由内核层使用优先级算法调度执行，该算法确保优先级最高的就绪线程始终运行，并在必要时抢占低优先级线程。内存区表示可以映射到进程地址空间的内存对象，如文件。可执行文件（EXE）和动态链接库（DLL）等程序映像用内存区表示，就像共享内存一样。

Windows支持按需分页虚拟内存。分页算法基于工作集的概念。系统维护几种类型的页面列表以优化内存使用。这些页面列表通过调整工作集来填充，调整过程使用复杂的规则试图重用长时间未引用的物理页面。缓存管理器管理内核中的虚拟地址，并将其用于将文件映射到内存，从而提高许多应用程序的I/O性能，因为读操作可以在不访问磁盘的情况下完成。

设备驱动程序遵循Windows驱动程序模型并执行输入/输出。每个驱动程序首先初始化一个驱动程序对象，该对象包含可被系统调用以操控设备的过程地址。实际的设备用设备对象表示，设备对象可以根据系统的配置描述创建，或者由即插即用管理器根据其在枚举系统总线时发现的设备创建。设备组织成一个栈，I/O请求包沿着栈向下传递并由每个设备的驱动程序处理。I/O具有内在的异步性，驱动程序通常将请求排队以便后续处理然后返回到调用者。文件系统卷作为I/O系统中的设备实现。

NTFS文件系统基于一个主文件表（MFT），每个文件或目录在表中有一条记录。NTFS文件系统的所有元数据本身是NTFS文件的一部分。每个文件包含多个属性，这些属性存储在MFT记录中或外部块中。除此之外，NTFS还支持Unicode、压缩、日志和加密等功能。

最后，Windows Vista拥有一个基于访问控制列表和完整性级别的成熟安全系统。每个进程带有一个令牌，表示用户的标识和进程所具有的特殊权限。每个对象有一个与其相关联的安全描述符，指向一个自主访问控制列表，该列表包含允许或拒绝个体或组访问的访问控制条目。Windows在最近的发行版本中增加了大量的安全特性，包括用BitLocker加密整个卷、地址空间随机化、不可执行的堆栈以及其他措施，使缓冲区溢出攻击更加困难。

### 习题

1. **HAL时间跟踪**：HAL可以跟踪从1601年开始的所有时间。举一个例子说明这项功能的用途。
2. **句柄关闭问题**：在多线程应用程序中，一个线程关闭了句柄而另一个线程仍在使用它们会造成问题。解决此问题的一种可能性是插入序列域。请解释该方法是如何起作用的？需要对系统做哪些修改？
3. **信号功能**：Win32系统没有信号功能。如果要引入此功能，我们可以将信号设置为进程所有、线程所有、两者都有或者两者都没有。试着提出一项建议，并解释为什么。
4. **静态链接DLL**：另一种使用DLL的方式是静态地将每个程序链接到它实际调用到那些库函数，既不多也不少。在客户端机器或者服务器机器上引入此方法，哪个更合理？
5. **独立栈的原因**：在Windows中线程拥有独立的用户态栈和内核态栈的原因是什么？
6. **TLB优化**：TLB对性能有重大影响。为了提高TLB的有效性，Windows使用了大小为4MB的页，这是什么？
7. **执行体对象操作数量**：在一个执行体对象上可定义的不同操作的数量有没有限制？如果有，这个限制从何而来？如果没有，请说明为什么。
8. **同步对象组合**：Win32 API的调用`WaitForMultipleObjects`以一组同步对象的句柄为参数，使得线程被这组同步对象阻塞。一旦它们中的任何一个收到信号，调用者线程就会被释放。这组同步对象是否可以包含两个信号灯、一个互斥体和一个临界区？理由是什么？提示:这不是一个恶作剧的问题，但确实有必要认真考虑一番。
9. **线程终止原因**：给出三个可能会终止线程的原因。
10. **句柄表算法**：如11.4节所述，有一个特殊的句柄表用于为进程和线程分配ID。句柄表的算法通常是分配第一个可用的句柄（按照后进先出的顺序维护空闲链表）。在最新发布的Windows版本中，该算法变成了ID表总是以先进先出的顺序跟踪空闲链表。使用后进先出顺序分配进程线ID有什么潜在的问题？为什么UX操作系统没有这个问题？
11. **优先级调度**：假设时间片配额被设置为20毫秒，当前优先级为24的线程在配额开始的时候刚开始执行。突然一个I/O操作完成了并且一个优先级为28的线程变成就绪状态。这个线程需要等待多久才可以使用CPU?
12. **优先级比较**：在Windows Vista中，当前的优先级总是大于或等于基本的优先级。是否在某些情况下当前的优先级低于基本的优先级也是有意义的？若有，请举例。否则请说明原因。
13. **内核线程依附**：在Windows中很容易实现一些设施将运行在内核中的线程临时依附到其他进程的地址空间。为什么在用户态却很难实现？这样做有何目的？
14. **频繁磁盘写操作**：即使有很多空闲的可用内存而且内存管理器也不需要调整工作集，分页系统仍然会经常对磁盘进行写操作。为什么？
15. **物理页面映射**：为什么用来访问进程页目录和页表的物理页面的自身映射数据总是占用同一片4MB的内核虚拟地址空间（在x86上）？
16. **VAD创建**：如果保留了一段虚拟地址空间但是没有提交它，你认为系统会为其创建一个虚拟地址描述符（VAD）吗？请证明你的答案。
17. **策略转移**：在图11-36中，哪些转移是由策略决定的，而不是由系统事件（例如，一个进程退出并释放其页面）所强迫的转移？
18. **共享页面转移**：假设一个页面被共享并且同时存在于两个工作集中。如果它从一个工作集移出，在图11-36中它将会到哪里去？当它从第二个工作集移出时会发生什么？
19. **取消映射处理**：当进程取消对一个页面的映射时，干净的页会进行图11-36中的转移（5），那脏的栈页怎样处理呢？为什么脏的栈页面被取消映射时不会被转移到已修改列表中呢？
20. **互斥锁通知**：假设一个代表某种类型互斥锁（比如互斥对象）的分发对象被标记为使用通知事件而不是同步事件来声明锁被释放。为什么这样是不好的？你的回答在多大程度上依赖于锁被持有的时间、时间片配额的长度和系统是否为多处理器的？
21. **MFT行串**：一个文件存在如下映射。请给出MFT的行串。
22. **MFT记录更新**：考虑图11-43中的MFT记录。假设该文件增长了并且在文件的末尾添加了第10个块。新块的序号是66。现在MFT记录会是什么样子？
23. **压缩块长度**：在图11-46b中，最先的两个行串的长度都为8个块。你觉得它们长度相等只是偶然的，还是跟压缩的工作方式有关？请解释理由。
24. **安全字段简化**：假如您想创建Windows Vista的精简版。在图11-47中可以取消哪些字段而不削弱系统的安全性？
25. **扩展模型**：由许多程序（Web浏览器、Office、COM服务器）使用的一个扩展模型是对程序所包含的DLL添加钩子函数来扩展其底层功能。只要在加载DLL前仔细模拟客户的身份，该模型对基于RPC的服务来说就是合理的，是这样的吗？为什么不是？

希望这些改进后的文本能够帮助你更好地理解和学习Windows Vista的安全特性和相关概念。