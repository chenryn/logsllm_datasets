这个结构（也叫一个SEH记录）大小为8个字节，有两个（4 byte）成员：
一个是指向下一个exception_registration结构的指针（很重要，指向下一条SEH记录，特别
是当当前处理例程无法处理异常的时候）
一个是指向异常处理例程的指针
SEH链在栈中分布大致视图：
在main数据块的顶部（程序“main”函数的数据块，或TEB（线程环境块）/TIB（线程信息
块））放置着一个指向SEH链的指针，SEH链也被叫做FS:[0]链。
所以，在Intel的机器上，我们看反汇编的SEH代码时，你会看到mov eax, dword ptr fs:[0]
这个指令，它的opcode是64A100000000，确保这个线程安装了异常处理例程和当异常发生
时进行捕获。如果没看到这个 opcode，那么这个程序/线程也许根本没有进行异常处理
（moonife：用Win32汇编实现的异常处理安装一般我们并没有使用这个指令，而是直接push
dword ptr fs:[0]，mov eax, dword ptr fs:[0]在push eax这个一般是高级语言编译器生成的）。
或者，你可以使用OllyGraph这个OllyDbg插件生成一个函数流程图。
在SEH链的底部被指定为FFFFFFFF。这会触发一个程序的非正常结束（然后OS的例程开始
接管）。
马上看一个例子：编译下面的源码（sehtest.exe）并用windbg打开，先不要运行，让它挂起：
#include
#include
#include
int ExceptionHandler(void);
int main(int argc,char *argv[]){
char temp[512];
printf("Application launched");
__try {
strcpy(temp,argv[1]);
} __except ( ExceptionHandler() ){
}
return 0;
}
int ExceptionHandler(void){
printf("Exception");
return 0;
}
加载的模块：
Executable search path is:
ModLoad: 00400000 0040c000 c:\sploits\seh\lcc\sehtest.exe
ModLoad: 7c900000 7c9b2000 ntdll.dll
ModLoad: 7c800000 7c8f6000 C:\WINDOWS\system32\kernel32.dll
ModLoad: 7e410000 7e4a1000 C:\WINDOWS\system32\USER32.DLL
ModLoad: 77f10000 77f59000 C:\WINDOWS\system32\GDI32.dll
ModLoad: 73d90000 73db7000 C:\WINDOWS\system32\CRTDLL.DLL
这个程序位于00400000到0040c000之间
在这个区域中找opcode：
0:000> s 00400000 l 0040c000 64 A1
00401225 64 a1 00 00 00 00 55 89-e5 6a ff 68 1c a0 40 00 d.....U..j.h..@.
0040133f 64 a1 00 00 00 00 50 64-89 25 00 00 00 00 81 ec d.....Pd.%......
这个说明了已经注册了异常处理例程，查看TEB的dump：
0:000> d fs:[0]
003b:00000000 0c fd 12 00 00 00 13 00-00 e0 12 00 00 00 00 00 ................
003b:00000010 00 1e 00 00 00 00 00 00-00 f0 fd 7f 00 00 00 00 ................
003b:00000020 84 0d 00 00 54 0c 00 00-00 00 00 00 00 00 00 00 ....T...........
003b:00000030 00 d0 fd 7f 00 00 00 00-00 00 00 00 00 00 00 00 ................
003b:00000040 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
003b:00000050 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
003b:00000060 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
003b:00000070 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
0:000> !exchain
0012fd0c: ntdll!strchr+113 (7c90e920)
这个指针指向0x0012fd0c（SEH链的起点），我们看一下这个区域：
0:000> d 0012fd0c
0012fd0c ff ff ff ff 20 e9 90 7c-30 b0 91 7c 01 00 00 00 .... ..|0..|....
0012fd1c 00 00 00 00 57 e4 90 7c-30 fd 12 00 00 00 90 7c ....W..|0......|
0012fd2c 00 00 00 00 17 00 01 00-00 00 00 00 00 00 00 00 ................
0012fd3c 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
0012fd4c 08 30 be 81 92 24 3e f8-18 30 be 81 18 aa 3c 82 .0...$>..0....$uitxt") ;
print myfile $junk;
打开Soritong MP3 player。这个程序无声的崩掉了（可能是因为异常处理导致的，程序找不
到有效的SEH地址）因为我们已经覆盖了这个地址。
首先，我们可以用Ollydbg清楚的观察栈和SEH链。用Ollydbg打开Soritong MP3 player，F9
运行程序，很快，程序就蹦掉和停止了，看下图：
程序在0x0042E33处崩掉。这时的ESP为0x0012DA14，在栈的底部(0012DA6C)，我们看到
FFFFFFFF，这是SEH链的末尾。跟在0x0012DA14后面的值为7E41882A,这是程序的默认异
常处理例程。这个地址位于user32.dll模块地址空间中。
从栈更高处的几个地址中，我们看到还有其他的异常处理例程，但它们都属于操作系统
（Ntdll）。所以看起来这个程序（或至少是最近发生异常的函数调用）没有自定义的异常
处理例程。
当我们查看线程（View-Threads），并选择第一个线程（这里指的是主线程），右键选择„dump
thread data block‟，我们可以看到指向SEH链的指针了。
所以这个异常例程有起作用。我们触发一个异常（通过构建一个畸形ui.txt文件），程序跳
到了SEH链( 0x0012DF64).。
View菜单打开“SEH chain”：
SE例程地址指向了处理异常的代码处。
SE例程的指针被覆盖为4个字母A，现在变得有趣了。当处理一个异常时，EIP会被异常处理
例程指针覆盖。所以一旦我们控制了这个指针的值，我们就可以执行我们的代码了。
用Windbg动态观察SEH
当我们用Windbg来做同样的事情，会看到：
关掉ollydbg，用Windbg打开soritong.exe文件。
在调试器第一次中断（在执行文件前置一个断点）时，在command中运行G命令（或F5）运
行程序。
Soritong mp3 player 运行不到一会儿就崩了。Windbg已经捕获了“first chance
exception”。这也就是说Windbg会在异常被程序处理之前就监视到产生的异常，Windbg将暂
停程序执行流程：
The message states “This exception may be expected and handled”.
这个消息提示“这个异常也许是被预期的和可处理的”。
查看栈：
00422e33 8810 mov byte ptr [eax],dl ds:0023:00130000=41
0:000> d esp
0012da14 3c eb aa 00 00 00 00 00-00 00 00 00 00 00 00 00 <...............
0012da24 94 da 12 00 00 00 00 00-e0 a9 15 00 00 00 00 00 ................
0012da34 00 00 00 00 00 00 00 00-00 00 00 00 94 88 94 7c ...............|
0012da44 67 28 91 7c 00 eb 12 00-00 00 00 00 01 a0 f8 00 g(.|............
0012da54 01 00 00 00 24 da 12 00-71 b8 94 7c d4 ed 12 00 ....$...q..|....
0012da64 8f 04 44 7e 30 88 41 7e-ff ff ff ff 2a 88 41 7e ..D~0.A~....*.A~
0012da74 7b 92 42 7e af 41 00 00-b8 da 12 00 d8 00 0b 5d {.B~.A.........]
0012da84 94 da 12 00 bf fe ff ff-b8 f0 12 00 b8 a5 15 00 ................
这里的ffffffff 指定SEH链的结束，当我们运行!analyze –v命令，我们得到：