such as Floodlight, ONOS, and OpenDaylight, in contrast,
use an operating-system-like imperative paradigm.
Limitation (L4): Interpretation and analysis Even if the
dependency-related challenges previously described were mit-
igated, it can still be challenge to interpret provenance graphs.
For instance, if the practitioner in our attack scenario from
§ 2.1 wanted to understand how network identiﬁer bindings
(e.g., the network’s bindings between a host’s MAC address
and its location in the data plane) changed over time, the
provenance graph in Figure 2a would not support that; it does
not directly link the host objects because their generation were
not causally related.
PROVSDN and FORENGUARD use backward tracing to
start with a piece of evidence and ﬁnd its information ﬂow
ancestors or set of root causes, respectively. However, if the
practitioner wanted to know the other effects of the spoofed
packet generated by h1, that analysis would require forward
tracing techniques that start at a cause and ﬁnd its progeny
to determine what other data and processes were affected.
As neither PROVSDN nor FORENGUARD performs forward
tracing, the practitioner would not be able to discover other
relevant unexpected artifacts of the attack, such as acl’s failure
to generate ﬂow deny rules.
The practitioner ultimately wants to answer network con-
nectivity questions of the form “Which packet(s) caused
which ﬂow rule(s) to be (or not to be) installed?” However,
the SDN controller’s event-based architecture can be itself
complex [53]. Although the complexity must be recorded to
Figure 3: API-based provenance, based on techniques from
PROVSDN [52], produces dependency explosion. When an
app’s event listener (fwd) is modeled as one long-running
process, all API calls are considered as possible dependencies.
For instance, the API call at time t = 4 may incorrectly appear
to be dependent on all API calls from t = [1,3].
too coarse-grained to enable pinpointing of attribution. Since
existing tools do not account for the data plane as a causal
inﬂuence, the result in Figure 2a is a set of two disconnected
subgraphs. That disconnection prevents the practitioner from
performing a meaningful backward trace. Finally, backward
tracing alone would not provide the practitioner with details
about the attack’s other effects. We generalize those chal-
lenges and consider them in depth below.
Limitation (L1): Dependency explosion Provenance
modeling suffers from the dependency explosion problem in
which long-running processes or widely-used data structures
within a system can create false dependencies. For instance,
PROVSDN [52] uses an API-centric model. Figure 3 shows
the provenance generated from two different calls to fwd’s
event handler, which results in four API calls in total. It is not
obvious that an API call to forward() was initiated by one (and
only one) API call to inPacket(). As a result, the API-centric
model would create many false dependencies because an API
call would be falsely dependent on all previous API calls.
FORENGUARD’s event-centric model uses execution parti-
tioning, but if we apply it as shown in Figure 2a, we see that a
controller that installs default ﬂow rules (i.e., f1) will cause all
unmatched packets (i.e., p1 and p2) to become dependent on
it. As a result, FORENGUARD’s modeling approach can suffer
from data partitioning challenges when too many unrelated
effects of a root cause must also be analyzed.
Limitation (L2): Coarse-grained responsibility and false
attribution A similar challenge exists in the assignment of
responsibility (or agency) in the data plane. In Figure 2a, the
agency traces back to a switch, either s1 or s2. Although this
correctly implies that one of the root causes of the attack is s1
or s2, it is not a particularly useful insight because all other
activities have one of these root causes, too. Instead, should
the responsibility be assigned to a notion of a host? Given that
network identiﬁers (e.g., MAC addresses) are easily spoofable,
3186    30th USENIX Security Symposium
USENIX Association
fwdDefaultInboundPackett=1DefaultForwardingObjectivet=2FlowObjectiveServiceforward()t=2wasGeneratedByDefaultInboundPackett=3DefaultForwardingObjectivet=4FlowObjectiveServiceforward()t=4wasGeneratedByPacketContextinPacket()t=1wasAssociatedWithusedwasAssociatedWithPacketContextinPacket()t=3wasAssociatedWithusedwasAssociatedWithmaintain the necessary dependencies, most of the complex-
ity can be abstracted away to answer a practitioner’s query.
Thus, abstracted summarization is necessary for practitioners
to understand attacks easily and quickly.
2.3 Our Approach
Motivated by the attack presented in § 2.1 and the previ-
ous tools’ limitations noted in § 2.2, we highlight how PI-
COSDN would mitigate the issues. PICOSDN uses a prove-
nance model that accounts for data and execution partitioning
with precise agency, while also incorporating the implicit
data plane effects on the control plane (§ 3). PICOSDN also
provides techniques to aid in analysis (§ 5).
Applying PICOSDN produces the graph shown in Fig-
ure 2b. Rather than rely solely on the default ﬂow rule f1
as a cause, the practitioner can see that packets p1 and p2
originate at a host on switch s1’s port 1 (L1). That also allows
the practitioner to precisely identify agency at the switch port
(rather than switch) level (L2). The previously independent
activities from each switch are linked by the data plane model
that connects p4 with p3 (L3), which allows the practitioner
to backtrace from s2 to s1 (L4). Finally, the practitioner can
see how host h1’s network identiﬁer information evolved over
time (L4) and can summarize the past network state (L4).
3 PICOSDN Provenance Model
In order to reason about past activities and perform causal
analysis, we ﬁrst deﬁne a provenance model that formally
speciﬁes the relevant data, processes, and principal identities
involved in such data’s generation and use.2 Our uniﬁed ap-
proach accounts for app, control, and data plane activities,
which allows us to reason holistically about SDN attacks.
3.1 Deﬁnitions
A provenance graph, denoted by G = (V ,E), is a directed
acyclic graph (DAG) that represents the lineages of objects
comprising the shared SDN control plane state. Informally
stated, the graph shows all of the relevant processes and prin-
cipal identities (i.e., agents) that were involved in the use or
generation of such control plane objects. We use the graph to
analyze past activities to determine root causes (i.e., backward
tracing) and use those root causes to determine other relevant
control plane activities (i.e., forward tracing).
Each node v ∈ V belongs to one of three high-level classes:
Entity, Activity, and Agent. Each high-level node class is ex-
plained with its respective subclasses in Table 1. We detail
the design choices and semantics of these nodes in § 3.2. A
node may also contain a dictionary of key–value pairs.
2Our model is loosely based on the W3C PROV data model [44].
Table 1: Nodes in the PICOSDN provenance graph model.
Node class
Entity
Activity
Agent
Node meaning and node subclasses
A data object within the SDN control plane state, used or
generated through API service calls or event listeners
Subclasses: Host, Packet (subsubclasses: PacketIn, Pack-
etOut), FlowRule, Objective, Intent, Device, Port, Table, Me-
ter, Group, Topology, Statistic
An event listener or a packet processor used by an SDN
app or controller
Subclasses: EventListener, PacketProcessor
An SDN app, an SDN controller core service, a switch
port, or a switch (i.e., device)
Subclasses: App, CoreService, SwitchPort, Switch
Each edge (or relation) e ∈ E belongs to one of the classes
listed in Table 2; rows that are indented show relations that
have more precise subclasses and meanings from their super-
class. Relations form the connections among the control plane
objects, the network activities involved in their generation and
use, and principal identities within the SDN components.
A backward trace path, denoted by tb = (cid:104)v0 → e0 → ··· →
ei → v j(cid:105),e0 . . .ei ∈ Eclass(cid:54)=wasRevisionOf,v0 . . .v j ∈ V , is a path
of alternating nodes and edges that begins at a node of interest
v0 and ends at an ancestry node v j. An ancestry node is a
predecessor of a node of interest. Given that G is a DAG,
nodes v1, . . . ,v j−1 are also ancestry nodes. A backward trace
does not include any wasRevisionOf edges because such edges
represent non-causal relations.
A revision trace path, denoted by tr = (cid:104)v0 → e0 → ··· →
ei → v j(cid:105),e0 . . .ei ∈ Eclass=wasRevisionOf,v0 . . .v j ∈ V , is a path
of edges that begin at a node of interest v0 and show the
revisions of that node’s object starting from an earlier revi-
sion node v j. These revisions are non-causal and are used to
identify changes to objects over time.
3.2 Model design choices
Given the aforementioned deﬁnitions, we now discuss the
design decisions we made in PICOSDN’s provenance model.
We show how these decisions were inﬂuenced by the limita-
tions found in previous work and how these decisions help us
solve the challenges outlined in § 2.2.
Data and execution partitioning We achieve data parti-
tioning with Entity objects by partitioning the data objects
speciﬁed in the controller’s API. For instance, the ONOS con-
troller’s host core service provides the API call getHosts(),
which returns a set of Host objects. Thus, a natural way to
partition data is to identify each Host object as a data partition.
The Entity subclasses are generalizable to common SDN con-
trol plane state objects as found in the representative ONOS,
OpenDaylight, and Floodlight SDN controllers.
Default ﬂow rules can generate dependency explosions
because any incoming packet that does not match other ﬂow
USENIX Association
30th USENIX Security Symposium    3187
Table 2: Edges (relations) in the PICOSDN provenance graph model.
Valid edge (relation) class
Entity wasGeneratedBy Activity
Activity used Entity
EventListener used Entity
PacketProcessor used Packet
Relation meaning
Creation of an SDN control plane state object
Use of an SDN control plane state object
An event listener’s use of the SDN control plane state object
A packet processor’s use of a data plane packet
Entity wasInvalidatedBy Activity
Deletion of a data object within the SDN control plane state
Entity wasDerivedFrom Entity
PacketIn wasDerivedFrom FlowRule
PacketIn wasDerivedFrom PacketOut
Causal derivation of one SDN control plane state object to another object
Causal derivation of an incoming packet based on a previously-installed ﬂow rule (e.g., default ﬂow rule)
Causal derivation of an incoming packet from one switch based on the outgoing packet of another switch
Entity wasRevisionOf Entity
Non-causal revision (i.e., new version) of an SDN control plane state object
Activity wasAssociatedWith Agent
Agency or attribution of an SDN control plane event
Packet wasAttributedTo SwitchPort
Agency or attribution of a data plane packet with the respective switch port on which the packet was received
(a) Data dependency explosion using default ﬂow rules (used in
PROVSDN [52] and FORENGUARD [55]). All packets from switch
s1 that do not match any other ﬂow rules become causally dependent
on the default ﬂow rule, which leads to dependency explosion.
(a) API-based modeling (used in PROVSDN [52]). If one is tracing
o2’s provenance via the API write at time t = 10, it will not be clear
that only the API read of o1 at t = 9 is causally associated with o2.
The other API reads at t = 1 and t = 2 represent false dependencies.
(b) Data partitioning using packets and switch port agents (used
in PICOSDN). All packets per switch port are logically grouped
together.
Figure 4: Data partitioning models for ﬂow rules. Ellipses
represent Entity nodes, and pentagons represent Agent nodes.
rules is sent to the controller for processing. All previously
unseen packets become causally dependent on a generalized
default ﬂow rule, as shown in Figure 4a. To mitigate that
problem, our model links any such packets to the respective
edge ports that generated the packets, as shown in Figure 4b.
We achieve execution partitioning with Activity objects by
partitioning each execution of recurring event listeners and
packet processors into separate activities. Figure 5 shows the
differences between API-based modeling and event-based
modeling. With event-based modeling, we can more clearly
show which Entity objects were used, generated, or invalided
by a given Activity and mitigate the dependency explosion.
(b) Event-based modeling (used in PICOSDN). If one is tracing
o2’s provenance via the event listener, it will be clear that o2 is
causally associated with o1 through App X’s event listener.
Figure 5: Comparison of execution partitioning models. El-
lipses represent Entity nodes, rectangles represent Activity
nodes, and pentagons represent Agent nodes.
Event listening SDN controllers dispatch events to event
listeners. In ONOS, for example, the host service dispatches
a HostEvent event (with the corresponding Host object) to
any HostEvent listener. We model an event’s data object as an
Entity node that was used by EventListener nodes, with each
event listener invocation represented as its own node.
Data plane model Figure 6 shows a diagram of data plane
activities between two switches, s1 and s2. Figure 6a shows
3188    30th USENIX Security Symposium
USENIX Association
(Default) Flow Rulematch=all traﬃc, action=send to controllerswitch=s1, xid=1Packet InMACsrc=h1switch:port=s1:1xid=1, t=1wasDerivedFromPacket InMACsrc=h2switch:port=s1:2xid=1, t=2wasDerivedFromPacket InMACsrc=h1switch:port=s1:1xid=1, t=10wasDerivedFromPacket InMACsrc=h3switch:port=s1:3xid=1, t=100wasDerivedFromSwitch s1Port 1Switch s1Port 2Switch s1Port 3(Default) Flow Rulematch=all traﬃcaction=send to controllerswitch=s1, xid=1Packet InMACsrc=h1switch:port=s1:1xid=1, t=1wasAttributedToPacket InMACsrc=h2switch:port=s1:2xid=1, t=2wasAttributedToPacket InMACsrc=h1switch:port=s1:1xid=1, t=10wasAttributedToPacket InMACsrc=h3switch:port=s1:3xid=1, t=100wasAttributedToApp XAll previousAPI callsfrom App X...wasAssociatedWithControl planeobject o1Control planeobject o2NB API calltype=WRITEt=10wasGeneratedBywasAssociatedWithNB API calltype=READt=9wasAssociatedWithusedNB API calltype=READt=2wasAssociatedWithNB API calltype=READt=1wasAssociatedWithApp XApp YAll other eventlisteners interested in o1...Control planeobject o1usedControl planeobject o2Event Listenerapp=App Xt=9wasGeneratedBywasAssociatedWithusedEvent Listenerapp=App Yt=12wasAssociatedWithuseddetail in § 4) that switches are trusted, we can trust that the
data plane trafﬁc originating in a particular switch port is ac-
tually originating in that port. Whether or not a host claiming
to have a particular identiﬁer (e.g., MAC address) on that port
is legitimately located on that port cannot be veriﬁed from
the data plane alone. To account for that, we model identiﬁer
changes by using the non-causal relation wasRevisionOf. It
allows for a succinct trace of identiﬁer changes over time.
4 PICOSDN Threat Model
We assume that the SDN controller is trusted but that its
services and functionality may be subverted by apps or by
data plane input, which is similar to the threat model found
in related work [52, 55]. Attackers will try to inﬂuence the
control plane via cross-app poisoning attacks [52] or via cross-
plane poisoning attacks [13,24,41,49]. As a result, we assume
that all relevant attacks will make use of the SDN controller’s
API service calls, event dispatches, or both.
We further assume that switches and apps maintain their
own principal identities and cannot spoof their identiﬁers,
and indeed we can enforce that policy using a public-key
infrastructure (PKI) [47]. However, we assume that data plane
hosts can spoof their network identiﬁers (e.g., MAC address).
5 PICOSDN Design
Based on the provenance model described in § 3, we now
present the design of provenance-informed causal observation
for software-deﬁned networking, or PICOSDN. PICOSDN
provides ﬁne-grained data and execution partitioning to aid in
the identiﬁcation of SDN attack causes. PICOSDN’s analysis
capabilities allow a practitioner to identify evidence of mali-
cious behavior, to pinpoint common causes, and to identify
the extent to which other malicious activities have occurred.
Figure 7 shows an overview of the PICOSDN architecture.
PICOSDN has two phases: a runtime phase (§ 5.1) that col-
lects relevant provenance information during execution, and
an investigation phase (§ 5.2) that analyzes the provenance.
PICOSDN is designed with the following goals in mind:
G1 Precise Dependencies. PICOSDN should reduce the units
of execution to remove false execution dependencies that
arise from long-running processes in the SDN control
plane. PICOSDN should also reduce the unit size of data
to remove false data dependencies.
G2 Uniﬁed Network Model. PICOSDN should leverage con-
trol and data plane activities, and thereby mitigate the
incomplete dependency problem.
G3 Iterative Analysis. PICOSDN should perform backward
and forward tracing to enable causal analysis of SDN at-
tacks. It should efﬁciently summarize network activities
and network identiﬁer evolution.
(a) Control plane → data plane → control plane activity.
(b) Resulting control plane provenance graph. The dashed edge
represents the provenance if we include a data plane model. Without
the edge (and the data plane model), the PacketIn from s2 would