plaintext slot. They adapt some DFT-like algorithms to transform a vector of plaintext values into an
element of cyclotomic ring.
Let sk = (1, s) for the secret s ∈ R. A canonical RLWE-based ciphertext is of the form ct = (c0, c1) ∈
q such that the inner product µ = (cid:104)ct, sk(cid:105) (mod q), called the phase, is a randomized encoding of a
R2
plaintext m. For example, the phase of a BFV ciphertext has the form of µ = (q/t)·m+e for the plaintext
modulus t while the phase µ = m + e of CKKS is an approximate value of the plaintext.
For homomorphic computation, we basically perform arithmetic operations between the phases of
given ciphertexts. In particular, homomorphic multiplication of RLWE ciphertexts consists of two steps:
tensor product and relinearization. For input ciphertexts ct1 and ct2, we ﬁrst compute their tensor product
and return the extended ciphertext ct = ct1⊗ct2 that satisﬁes (cid:104)ct, sk⊗sk(cid:105) = (cid:104)ct1, sk(cid:105)·(cid:104)ct2, sk(cid:105). Since sk⊗sk
contains the nonlinear entry s2, it requires to perform the relinearization procedure which transforms the
extended ciphertext to a canonical ciphertext encrypting the same message. Roughly speaking, we publish
a relinerization key which is some kind of ciphertext encrypting s2 under sk and run the key-switching
algorithm for this conversion.
In the multi-key case, a ciphertext related to k diﬀerent parties is of the form ct = (c0, c1, . . . , ck) ∈
which is decryptable by the concatenated secret sk = (1, s1, . . . , sk), i.e., its phase is computed
i=1 ci · si. If we follow the same pipeline for homomorphic operation as in the
single-key setting, the tensor product step returns an extended ciphertext corresponding sk ⊗ sk. Hence,
we need to generate a relinearization key which consists of multiple ciphertexts encrypting the entries
si · sj of sk ⊗ sk. Diﬀerent from the classical HE schemes, it requires some additional computations since
the term si · sj depends on two secret keys which are independently generated by diﬀerent parties. In
the following, we will explain how to eﬃciently generate a relinearization key for multi-key homomorphic
multiplication.
by µ = (cid:104)ct, sk(cid:105) = c0 +(cid:80)k
Rk+1
q
3.2 Basic Scheme
In this section, we present a ring-based scheme which will be used to generate some public material for
relinearization.
• Setup(1λ): For a given security parameter λ, set the RLWE dimension n, ciphertext modulus q, key
distribution χ and error distribution ψ over R. Generate a random vector a ← U (Rd
q ). Return the public
parameter pp = (n, q, χ, ψ, a).
• KeyGen(pp): Sample the secret key s ← χ. Sample an error vector e ← ψd and set the public key as
b = −s · a + e (mod q) in Rd
q .
• UniEnc(µ; s): For an input plaintext µ ∈ R, generate a ciphertext D = [d0|d1|d2] ∈ Rd×3
1. Sample r ← χ.
2. Sample d1 ← U (Rd
3. Sample e2 ← ψd and set d2 = r · a + e2 + µ · g (mod q).
q ) and e1 ← ψd, and set d0 = −s · d1 + e1 + r · g (mod q).
as follows:
q
The public parameter pp contains a randomly generated vector a ∈ Rd
q , so we are assuming the
common reference string model. All parties should take the same public parameter as an input of the key-
generation algorithm to support multi-key homomorphic arithmetic. We note that the same assumption
was made in all the previous researches on MKHE.
An uni-encrypted ciphertext D = [d0|d1|d2] ← UniEnc(µ; s) consists of three vectors in Rd
The uni-encryption algorithm is a symmetric encryption which can encrypt a single ring element.
q so is (3/4)
times as large as an ordinary RGSW ciphertext in R2d×2
. For an uni-encrypted ciphertext D, the ﬁrst
two columns [d0|d1] can be viewed as an encryption of r under the secret s while [d2| − a] forms an
encryption of µ under secret r.
q
Security. We claim that the uni-encryption scheme is IND-CPA secure under the RLWE assumption.
We will show that the distribution
{(a, b, D) : pp = (n, χ, ψ, a) ← Setup(1λ), (s, b) ← KeyGen(pp), D ← UniEnc(µ; s)}
is computationally indistinguishable from the uniform distribution over Rd
µ ∈ R.
q × Rd
q × Rd×3
q
for an arbitrary
First, we can modify b and d0 so that we sample them independently from the uniform distribution
over Rd
q . This step relies on the hardness of RLWE with parameter (n, χ, ψ) and secret s. Second, d2 can
also be changed into the uniform distribution under the same RLWE assumption with secret r. Since the
uniform distribution over Rd
is independent from the plaintext µ, the uni-encryption scheme
is semantically secure.
q × Rd×3
q × Rd
q
3.3 Relinearization
We revisit the relinearization procedure on extended ciphertexts and present two solutions with diﬀerent
advantages. We recall that the tensor product ct = ct1 ⊗ ct2 of two multi-key ciphertexts cti ∈ Rk+1
encrypted under the concatenated secret sk = (1, s1, . . . , sk) can be viewed as a ciphertext corresponding
to the tensor squared secret sk⊗ sk. Note that sk⊗ sk contains some nonlinear entries si · sj related to two
diﬀerent parties. Therefore, the computing server should be able to transform the extended ciphertext
ct ∈ R(k+1)×(k+1)
into a canonical ciphertext by linearization of the non-linear entries si · sj.
q
q
Our relinearization methods require the same public material (evaluation key) that is generated by
individual parties as follows:
• EvkGen(s): For a secret s ∈ R, set the evaluation key D ← UniEnc(s; s).
To be precise, each party i generates its own secret, public, and evaluation keys by running the
algorithms (si, bi) ← KeyGen(pp) and Di ← EvkGen(si), then publishes the pair (bi, Di). In the rest of
this section, we present two relinearization algorithms and explain their pros and cons.
We make an additional circular security assumption since the evaluation key is an uni-encryption
of secret s encrypted by itself. However, we stress that our assumption is no stronger than the same
assumption in HE schemes [27, 22, 17, 16] requiring either bootstrapping or relinearization of ciphertexts.
3.3.1 First Method
This solution includes a pre-processing step which generates a shared relinearization key corresponding
to the set of involved parties. A shared relinearization key consists of encryptions of si · sj for all pairs
1 ≤ i, j ≤ k. Then, we can linearize an extended ciphertext by applying a standard key-switching
technique.
This approach is similar to a method proposed in previous researches [13, 50] which also generates
a shared evaluation key. However, each element of our shared relinearization key is computed from the
public information of at most two parties so consists of three vectors, while previous method based on
the multi-key GSW scheme has O(k) dimensional entries.
• Convert(Di, bj): It takes as the input a pair of an uni-encryption Di = [di,0|di,1|di,2] ∈ Rd×3
and
a public key bj ∈ Rd
q generated by (possibly diﬀerent) parties i and j. Let ki,j,0 and ki,j,1 be the
q such that ki,j,0[(cid:96)] = (cid:104)g−1(bj[(cid:96)]), di,0(cid:105) and ki,j,1[(cid:96)] = (cid:104)g−1(bj[(cid:96)]), di,1(cid:105) for 1 ≤ (cid:96) ≤ d,
vectors in Rd
i.e., [ki,j,0|ki,j,1] = Mj · [di,0|di,1] where Mj ∈ Rd×d is the matrix whose (cid:96)-th row is g−1(bj[(cid:96)]) ∈ Rd. Let
ki,j,2 = di,2 and return the ciphertext Ki,j = [ki,j,0|ki,j,1|ki,j,2] ∈ Rd×3
.
q
q
q
.
= (c(cid:48)
i)0≤i≤k ∈ Rk+1
Algorithm 1 Relinearization method 1
Input: ct = (ci,j)0≤i,j≤k, rlk = {Ki,j}1≤i,j≤k.
(cid:48)
Output: ct
0 ← c0,0
1: c(cid:48)
2: for 1 ≤ i ≤ k do
3:
4: end for
5: for 1 ≤ i, j ≤ k do
j) ← (c(cid:48)
(c(cid:48)
0, c(cid:48)
6:
7: end for
i ← c0,i + ci,0 (mod q)
c(cid:48)
0, c(cid:48)
i, c(cid:48)
i, c(cid:48)
j) + g−1(ci,j) · Ki,j (mod q)
 ki,j,0 ki,j,1
 =
g−1(bj[1])
g−1(bj[d])
...
 ·
di,0 di,1
 ,
ki,j,2
 =
di,2
 .
• Relin(ct;{(Di, bi)}1≤i≤k): Given an extended ciphertext ct = (ci,j)0≤i,j≤k and k pairs of evalua-
tion/public keys {(Di, bi)}1≤i≤k, generate a ciphertext ct
1. Compute Ki,j ← Convert(Di, bj) for all 1 ≤ i, j ≤ k and set the relinearization key as rlk =
(cid:48) ∈ Rk+1
as follows:
q
{Ki,j}1≤i,j≤k ∈ (Rd×3
q
)k2
.
2. Run Alg. 1 to relinearize ct.
We note that the ﬁrst step (generation of rlk) can be pre-computed on public information {(Di, bi)}1≤i≤k
without taking a ciphertext as the input.
Correctness. We ﬁrst claim that, if Di is an uni-encryption of µi ∈ R encrypted by the i-th party and bj
is the public key of the j-th party, then the output Ki,j ← Convert(Di, bj) of the conversion algorithm
is an encryption of µisj with respect to the secret (1, si, sj), i.e., ki,j,0 + si · ki,j,1 + sj · ki,j,2 ≈ µisj · g
(mod q). It is derived from the following formulas:
ki,j,0 + si · ki,j,1 = Mj · (d0 + si · d1) ≈ Mj · rig = ribj
(mod q),
sj · ki,j,2 = sj · d2 ≈ risj · a + µsj · g ≈ −r · bj + µisj · g (mod q).
Note that Mj, sj and ri should be small to hold the approximate equalities. We estimate the size of noise
in Appendix B.
We now show the correctness of our algorithm. Since the evaluation key Di of the i-th party is an
(cid:48)
uni-encryption of µi = si, we obtain that Ki,j · (1, si, sj) ≈ sisj · g (mod q). From the deﬁnition of ct
,
we get
= c0,0 +
(c0,i + ci,0)si +
≈ c0,0 +
(c0,i + ci,0)si +
k(cid:88)
k(cid:88)
i,j=1
i,j=1
g−1(ci,j) · Ki,j · (1, si, sj)
(mod q)
ci,j · sisj = (cid:104)ct, sk ⊗ sk(cid:105)
(mod q),
(cid:48)
(cid:104)ct
, sk(cid:105) = c(cid:48)
0 +
i=1
k(cid:88)
i · si
c(cid:48)
k(cid:88)
k(cid:88)
i=1
as desired.
i=1
Algorithm 2 Relinearization method 2
q
.
= (c(cid:48)
i)0≤i≤k ∈ Rk+1
i ← c0,i + ci,0 (mod q)
c(cid:48)
Input: ct = (ci,j)0≤i,j≤k, {(Di = [di,0|di,1|di,2], bi)}1≤i≤k.
(cid:48)
Output: ct
0 ← c0,0
1: c(cid:48)
2: for 1 ≤ i ≤ k do
3:
4: end for
5: for 1 ≤ i, j ≤ k do
6:
0, c(cid:48)
7:
8:
9: end for
i,j ← (cid:104)g−1(ci,j), bj(cid:105) (mod q)
c(cid:48)
(c(cid:48)
0, c(cid:48)
j ← c(cid:48)
c(cid:48)
i) ← (c(cid:48)
j + (cid:104)g−1(ci,j), di,2(cid:105) (mod q)
i,j) · [di,0|di,1] (mod q)
i) + g−1(c(cid:48)
3.3.2 Second Method
Our second solution does not generate a shared relinearization key diﬀerent from the previous one.
Instead, it directly linearizes each entry ci,j of an extended ciphertext ct = (ci,j)0≤i,j≤k by multiplying
it to bj and Di in a recursive way.
• Relin(ct;{(Di, bi)}1≤i≤k): For given extended ciphertext ct = (ci,j)0≤i,j≤k and k pairs of evalua-
tion/public keys {(Di, bi)}1≤i≤k, generate a ciphertext ct
as described in Alg. 2.
(cid:48) ∈ Rk+1
q
We will analyze and compare two relinearization methods in the following section. In short, the second
method has advantages in storage and noise growth while the ﬁrst method could be faster if a shared
evaluation key is used repeatedly to relinearize multiple ciphertexts corresponding to the same set of
parties. We ﬁrst show the correctness of the second method.