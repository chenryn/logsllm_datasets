### 3. Data Analysis and Results

#### 3.1 Mislabeling and Code Reuse

In our dataset, we identified 17 mislabeled samples, with PowerPC and SPARC (comprising 20.6% of the dataset) having only 7 cases. A closer examination revealed that all instances of incorrect labeling were due to a high degree of code reuse between two or more malware families. For example, in Figure 3, the zoomed region [B] illustrates this type of error. A Tsunami variant that incorporated several utility functions from Mirai was misclassified as Gafgyt by multiple antivirus (AV) vendors.

Another case involves 12 Remaiten samples, which AVClass incorrectly labeled as Gafgyt. Remaiten is a botnet discovered by ESET that reuses both Tsunami and Gafgyt code, extending it with new features. We also observed that some AVs assign different labels to samples with almost identical code. For instance, under PowerPC, a binary was labeled as Pilkah, creating a new family, even though it was a minor variation of Lightaidra.

Additionally, we found that even a simple and well-known packer like UPX can cause issues for AV software. For example, 29 packed MIPS samples did not receive an AVClass label, despite their code being very similar to Gafgyt.

#### 3.2 Variants Identification

The phylogenetic trees generated by our method can be used to identify fine-grained modifications and relationships among variants within the same malware family. To bootstrap the identification of variants, we utilized the binary similarity-based symbol propagation described in Section 3.3. As a first step, we grouped all malware samples based on their unique symbols, which were either present in the original unstripped binary or propagated from other unstripped binaries. This technique, while subject to errors such as noise from symbol extraction and incomplete symbol propagation, provides a first estimate of the number of variants by capturing fine-grained differences like added, removed, or renamed functions.

Table 5 shows the number of identified variants for the top 10 largest malware families in our dataset. Gafgyt, followed by Mirai and Tsunami, appears to have spawned over 2,000 variants. This phenomenon is likely fueled by the availability of source code online for these major malware families. It is important to note that this step excludes all stripped samples for which symbols could not be propagated, such as all samples of the VPNFilter malware.

As a second step, we validated the previously identified variants using the leaked source code collected from online repositories, as described in Section 3.4. By matching symbols found or propagated in the binaries with functions in the source code, we were able to validate more than 200 variants. Interestingly, 50.3% of the samples had at least a partial match to our collected source code, but only 740 samples resulted in a perfect match. This suggests that many malware authors take inspiration from leaked source code but introduce new modifications, creating new independent variants. The high number of variants with available source code is a valuable opportunity for validation and further study. However, validating the remaining variants requires time-consuming manual analysis.

From Table 5, we see that the collected source code enabled us to validate 240 variants, with Gafgyt accounting for 58% of the total, followed by Mirai with 24%. The source code also matched minor families. For example, Hajime, known to come with stripped symbols, had one sample referring to the Gafgyt and Mirai variant Okane, suggesting that the Hajime sample was misclassified by AVs. Similarly, two samples of Pnscan partially matched with a port scanner tool named after the family and available on GitHub, but the authors introduced new functionalities to the original code.

While the availability of IoT malware source code online facilitates the development of variants, it can also be leveraged to identify and validate them. To evaluate the accuracy of the source code matching, we manually verified and confirmed some of the variants that matched the source code.

#### 3.3 Temporal Analysis

To understand the genealogy of IoT malware, we combined binary data with timing information. By measuring the first and last times associated with each variant, we can determine the temporal window in which the samples appeared in the wild (shown in the last two columns of Table 5). Quickly evolving families like Gafgyt and Mirai tend to result in short-lived variants. For example, Gafgyt variants appeared in VirusTotal for an average of 10 months, and Mirai variants for four months. In contrast, Tsunami and Dnsamp variants persisted for longer periods: one year and two months for Tsunami, and almost two years for Dnsamp. Figure 4 shows, in a cumulative graph, the number of new variants that appeared over time for the three main families. It is interesting to observe the almost constant release of Gafgyt variations, the slower increase of Tsunami variants, and the rapid proliferation of Mirai-based malware in 2018.

### 4. Case Studies

After presenting our automated approach for systematic identification of code reuse in Section 3 and providing an overview of the phylogenetic tree in Section 4, we now discuss two detailed case studies. These examples offer a closer look at two individual families and their evolution, including the multitude of internal variants.

#### 4.1 Example I – Tsunami (Medium-Sized Family)

Tsunami is a popular IRC botnet with DDoS capabilities, representing almost 4% of our dataset. Its code is available online, leading to a continuous proliferation of new variants, sometimes with minimal differences and other times with major improvements. Tsunami's primary goal is to compromise as many devices as possible to build large DDoS botnets. Therefore, we obtained samples compiled for less common architectures such as Motorola 68K and SuperH. Overall, 76% of its samples are statically linked but retain the original symbols.

When constructing the genealogy graph of Tsunami, we used extracted symbols from the binaries and cross-correlated them with available source code of multiple variants scraped from online forums, as explained in Section 3.4. This allowed us to color the graph and assign names to different variants.

The top part of Figure 5 shows the mini-graph for six different architectures. The main part of the figure further zooms in on the evolution of 748 ARM 32-bit binaries. These samples share the main functionality of Tsunami, with the DDoS and CnC contact functions remaining consistent across all of them.

On the right side of Figure 5, there is a section where the majority of samples are labeled as Kstd according to AV labels. With only two flooders, Kstd represents one of the oldest and most famous sub-families, serving as a skeleton and inspiration for newer malware strains. Moving left on the graph, we encounter a dynamic area with binaries very similar to each other but with new features such as frequent updates and new flooders. The first samples in this group correspond to the Capsaicin sub-family, for which we performed a manual investigation to identify new functionalities. Capsaicin includes 16 flooders based on TCP, UDP, and amplification attacks. It uses gcc directly on the infected device, assuming its presence. Some Tsunami variants also borrow code from Mirai and Gafgyt. For example, Capsaicin borrows from Mirai the code for random IP address generation used to locate candidate victims.

Moving further left, we encounter the Weebsquad and Uzi variants. Weebsquad spreads via Telnet and SSH, and we could not find any online source code that matched our samples. We named these variants based on the fact that they all included their name in the binaries. Some AVs on VirusTotal mislabeled these samples as Gafgyt, possibly due to the code reuse between Tsunami and Gafgyt.

On the left side of Figure 5, we encounter Kaiten, another popular variant from which many malware writers forked their code to create their own projects. For instance, Zbot (bottom-left on the graph) is a Kaiten fork available on GitHub, with the authors adding two additional flooder components.

Our similarity analysis also recognized Amnesia, a variant discovered by M. Malík of ESET in January 2017. This sub-family includes exploits for CCTV systems and is one of the rare Linux malware adopting Virtual Machine (VM) detection techniques. Unlike most samples in the graph, Amnesia is stripped and dynamically linked. However, our system detected very high code similarity with another unstripped sample using the same CCTV scanner and persistence techniques, but without VM detection capabilities. Thanks to our symbol propagation technique, we managed to connect the Amnesia samples to the rest of the family graph.

#### 4.2 Example II – Gafgyt (Large Family)

Gafgyt is the most active IoT botnet to date, comprising hundreds of variants and representing 50% of the samples in our dataset. It targets home routers and other vulnerable devices, including gaming services.

We visualized the code-similarity analysis of ARM 32-bit samples in Figure 6. Our system identified more than 100 individual variants. Like the Tsunami case study, we often leveraged available source code snippets to validate the identified variants.

The graph is clearly split into two main areas, with binaries compiled with THUMB mode support on the left and ARM mode only on the right. Since the two halves are symmetrical, we labeled variants separately on one or the other side of the graph to improve readability. Bashlite is believed to be one of the first variants of Gafgyt. Its samples are often mistaken for the Qbot variant, but their code presents significant differences. For example, Qbot uses two additional attack techniques, such as DDoS using the GNU utility wget. Our method correctly recognizes them as belonging to the same family but as distinct variants.

The next cluster in our genealogy refers to Razor, which fully reuses the previous source code but adds an additional CnC command to clear log files, delete shell history, and disable iptables. Prometheus, for which we crawled two bundles, is an example of malware versioning. Among its features, we see self-upgrade capabilities and the use of Python scripts (served by the CnC) for scanning. Its maintainer added a Netis3 scanner in V4 to enhance self-propagation through exploitation. Self-propagation and infection are further enhanced in Galaxy with scanners dubbed BCM and Phone, suggesting it targets real phones. Next to Galaxy, we find an almost one-to-one fork we call Remastered, which performs a less intrusive cleanup procedure, cleaning temporary directories and history but without stopping iptables and firewalld.

Finally, in the top left-hand corner of Figure 6, we uncover Angels, which reuses some of Mirai’s code for random IP generation (like other variants) and targets specific subnets hard-coded in the binaries.

### 5. Related Work

#### 5.1 IoT Malware Landscape

Researchers have primarily focused on analyzing the current state of attacks and malware targeting IoT devices, usually by deploying honeypots. Antonakakis et al. [3] provided a comprehensive forensic study of the Mirai botnet, reconstructing its history and tracking its various evolutions. Cozzi et al. [12] conducted a systematic study of Linux malware, describing trends in behavior and sophistication. This work included samples developed for different Linux-based OSes, without a particular focus on IoT systems. Our objective is to study the relationships among IoT malware families, track sub-family variants, and coding practices observed in a dataset an order of magnitude larger (93K samples vs. 10K) collected over a period of 3.5 years.

#### 5.2 Malware Lineage

The concept of malware phylogenetic trees, inspired by the study of biological species, was first introduced in 1998 by Goldberg et al. [18]. Karim et al. [28] presented a code fragment permutation-based technique to reconstruct malware family evolution trees. In 2011, Dumitras et al. [15] provided guidance on malware lineage studies, recommending the use of a combination of static and dynamic features, such as code fragments and dynamic CFGs, and the use of time and source information related to studied samples. Lindorfer et al. [31] developed Beagle, a system designed to track the evolution of a malware family. They rely on dynamic analysis to extract different functionalities in terms of API calls and map these back to disassembled code to identify and characterize mutations.

Calleja et al. recently analyzed the evolution of 456 Windows malware samples observed over 40+ years and identified code reuse between different families and with benign software. The types of code reuse include anti-analysis routines, shellcode, data such as credentials for brute-forcing attacks, and utility functions.

Haq et al. [21] reviewed 61 approaches from the literature on binary code similarity, some of which are used for malware lineage inference. While they focus on academic contributions rather than binary diffing tools, they highlight the diversity, strengths, and weaknesses of these techniques. They also identify several open problems, such as scalability and lack of support for multiple CPU architectures. BinSequence [24] computes the similarity between functions extracted from binaries at the instruction, basic block, and CFG levels. The authors applied their technique to different scenarios, including the identification of code reuse in two Windows malware families.