3
1
2
1
2
-
-
4499
776
544
1394
1
755
4
2
-
-
285.59
39.05
93.59
362.75
1
260.00
1.43
2.00
-
-
1210
661
1261
1444
1
483
299
1
-
-
283.21
103.35
421.63
691.25
1.00
308.33
43.57
1.00
-
-
Figure 4: Appearance of new variants over time.
17 mislabelled samples, while PowerPC and SPARC (20.6% of the
dataset) had only 7 cases.
Looking closer, all cases of wrong labels seemed to be due to
a high portion of code reuse between two or more families. The
zoom region [B] in Figure 3 is an example of this type of errors. A
Tsunami variant that borrows a number of utility functions from
Mirai resulted in few of its samples being misclassified as Gafgyt
by many AV vendors.
Another example, this time related to a smaller family, is a set of
12 Remaiten samples that AVClass reported as Gafgyt (Remaiten is
a botnet discovered by ESET that reuse both Tsunami and Gafgyt
code, that extend with a set of new features). We also observed
that in some cases AVs assign different labels for samples with an
almost full code overlap. For example, under PowerPC, a binary is
assigned the label Pilkah, thus giving birth to a new family, even if
it is only a very minor variation of Lightaidra.
Finally, we found examples of how an extremely simple and well
known packer like UPX can still cause troubles to AV software. For
instance, 29 packed samples for MIPS did not get an AVClass label
even if their code was very close to Gafgyt.
4.3 Variants
The phylogenetic trees produced by our method can also be used
to identify fine-grained modifications and relationships among
variants within the same malware family.
In order to bootstrap the identification of variants we decided to
take advantage of the binary similarity-based symbol propagation
described in Section 3.3. As a first step we identify candidate vari-
ants by grouping all malware samples based on their set of unique
symbols. These symbols were either present in the binary (in case
of an original unstripped binary) or were propagated from other un-
stripped binaries (in case of an original stripped binary). While this
symbol-based variant identification technique is subject to errors –
noise from symbol extraction, incomplete symbol propagation – it
gives a first estimate of the number of variants by capturing fine-
grained differences such as added, removed or renamed functions.
Table 5 provides the number of identified variants for the top 10
largest malware families in our dataset. We can see that Gafgyt, and
to a less extent Mirai and Tsunami appear to have spurred more
than 2,000 variants all together. This phenomenon is supposedly
fueled by the availability of the source code online for these three
major malware families. It is important to note that given that this
step relies on symbols it excludes all stripped samples for which
symbols could not be propagated, e.g., all samples of the VPNFilter
malware were stripped hindering the identification of variants.
As a second step we rely on the leaked source code collected from
online repositories, as described in Section 3.4 to validate previously
identified variants. By matching symbols found or propagated in
the binaries with functions found in the source code we were able
to validate more than 200 variants. It is interesting to see that
as much as 50.3% of the samples had at least a partial match to
our collected source code – but only 740 samples resulted in a
perfect match of the entire code. This suggests that many malware
authors take inspiration from leaked source code, yet they introduce
new modifications, thus creating new independent variants. The
surprisingly high number of variants having their source code
online is a great opportunity for us to validate and better study them.
Validating the others unfortunately require time-consuming manual
analysis. From Table 5 we can see that the collected source code
enabled us to validate 240 variants with Gafgyt taking a slice equal
to 58% of the total, followed by Mirai with a lower share of almost
24%. The source code we collected matched also minor families.
For example Hajime, known to come with stripped symbols, was
found to have one sample referring to the Gafgyt and Mirai variant
Okane, actually suggesting the Hajime sample was misclassified
by AVs. In a similar way, two samples of Pnscan partially matched
with a port scanner tool named like the family and available on
GitHub. However, the authors of these samples introduced new
functionalities to the original code. While the availability of IoT
malware source code online facilitates the development of variants,
it can also be leveraged to identify and validate them. Finally, in
order to evaluate the accuracy of the source code matching we took
an extra step and manually verified and confirmed some of the
variants that matched source code.
Another important aspect to understand the genealogy of IoT
malware is the combination of binary data with timing information.
By measuring the first and last time associated to each variant we
Jan2015Jan2016Jan2017Jan2018Date050100150Number of variantsgafgytmiraitsunamidnsampThe Tangled Genealogy of IoT Malware
ACSAC 2020, December 7–11, 2020, Austin, USA
can get a temporal window in which the samples of each variants
appeared in the wild (shown in the last two columns of Table 5).
Here we can notice how quickly-evolving families like Gafgyt and
Mirai tend to result in short-lived variants. For instance, Gafgyt
variants appeared in VirusTotal for an average of 10 months, and
Mirai variants for four. Instead, Tsunami and Dnsamp variants
persisted for longer periods: respectively one year and two months
the first and almost two years for the second. Figure 4 shows, in a
cumulative graph, the number of new variants that appeared over
time for the three main families. It is interesting to observe the
almost constant new release of Gafgyt variations over time, the
slower increase of Tsunami variants, and the rapid proliferation of
Mirai-based malware in 2018.
5 CASE STUDIES
After showing our automated approach for systematic identifica-
tion of code reuse in Section 3 and presenting an overview of the
phylogenetic tree in Section 4, we now discuss in more details two
case studies. We use these examples as an opportunity to provide a
closer look at two individual families and discuss their evolution
and the multitude of internal variants.
It is important to note that the exact time at which each sample
was developed is particularly difficult to identify as malware could
remain undetected for long periods of time. Since ELF files do not
contain a timestamp of when they were compiled, we can only rely
on public discussions and on the VirusTotal first submission time
as source for our labeling. Some families are only discussed in blog
posts by authors that did not submit their samples to VirusTotal.
Previous research also found that for APT campaigns the initial
VirusTotal collection time often pre-dates the time in which the
samples are “discovered” and analyzed by human experts by months
or even years [19]. Therefore, in our analysis we simply report the
earliest date among the ones we found in online sources and among
all samples submitted for the same variant to VirusTotal. However,
this effort is only performed for presentation purpose, as we believe
that detecting the similarities and changes among samples (the goal
of our analysis) is more important than determining which ones
came first.
Example I – Tsunami (medium-sized family)
Tsunami is a popular IRC botnet with DDoS capabilities whose
samples represent almost 4% of our dataset. Its code is available
online and gives birth to a continuous proliferation of new variants,
sometimes with minimal differences, other times with major im-
provements (i.e., new exploits and new functionalities). Tsunami’s
main goal is to compromise as many devices as possible to build
large DDoS botnets. Therefore, we obtained samples compiled also
for less common architectures such as Motorola 68K or SuperH.
Overall, 76% of its samples are statically linked but with the origi-
nal symbols in place. When constructing the genealogy graph of
Tsunami, we not only took advantage of the extracted symbols
from the binaries but we also cross-correlated them with available
source code of multiple variants we scraped from online forums, as
explained in Section 3.4. This way we were able to color the graph
and assign a name to different variants.
The top part of Figure 5 shows the mini-graph for six different
architectures. The main part of the figure further zooms in on the
evolution of a group of 748 ARM 32-bit binaries. These samples all
share the main functionality of Tsunami and therefore the functions
for DDoSing and contacting the CnC remained the same across all
of them.
On the most right of Figure 5, there is a visible section in which
the vast majority of samples are labeled as Kstd according to the AV
labels. With only two flooders, Kstd represents one of the oldest and
most famous sub-family which acted as a skeleton and inspiration
for newer malware strains. By moving left on the graph, we meet a
fairly high dynamic area with binaries very similar to each other but
with new features such as frequent updates and new flooders. The
first samples in this group correspond to the Capsaicin sub-family,
for which we performed a manual investigation to identify the
new functionalities. Capsaicin includes 16 flooders based on TCP,
UDP and amplification attacks. It uses gcc directly on the infected
device, taking its presence for granted. Some Tsunami variants are
also examples of inter-family code reuse, with code borrowed from
both Mirai and Gafgyt. For example, Capsaicin borrows from Mirai
the code for the random generation of IP addresses that is used
to locate candidate victims to infect. Some Tsunami samples also
perform horizontal movement reusing Mirai’s Telnet scanner or
SSH scanners also found in Gafgyt, while others use open source
code as inspiration (e.g., the Uzi scanner).
Moving left we then encounter the Weebsquad and Uzi variants.
The first is a branch spreading over Telnet and SSH, for which we
could not find any online source code that matched our samples.
We named these variants based on the fact that they all included
their name in the binaries. Interestingly some AVs on VirusTotal
mislabeled these samples as Gafgyt, possibly because of the code-
reuse between Tsunami and Gafgyt we mentioned earlier.
In the left side of Figure 5 we encounter Kaiten, another popular
variant from which many malware writers forked their code to
create their own projects. For instance, Zbot (bottom-left on the
graph) is a Kaiten fork available on GitHub, in which the authors
added two additional flooder components.
Our similarity analysis also recognizes Amnesia, a variant which
was discovered by M. Malík of ESET in January 2017. This sub-
family includes exploits for CCTV systems and it is one of the
rare Linux malware adopting Virtual Machine (VM) detection tech-
niques. Unlike most of the samples in the graph, Amnesia is stripped
and dynamically linked. However, our system detected very high
code similarity with another unstripped sample which uses the
same CCTV scanner and persistence techniques, but without VM
detection capabilities. Thanks to our symbol propagation technique
we also managed to connect the Amnesia samples to the rest of the
family graph.
Example II – Gafgyt (large family)
Gafgyt is the most active IoT botnet to date. It is comprised of
hundreds of variants and is the biggest family in our dataset with
50% of the samples. It targets home routers and other classes of
vulnerable devices, including gaming services [20].
We visualize the code-similarity analysis of samples for ARM
32-bit in Figure 6. Our system identified more than 100 individual
ACSAC 2020, December 7–11, 2020, Austin, USA
Cozzi, et al.
Figure 5: Lineage graph of Tsunami samples for ARM 32-bit.
variants. Like the Tsunami case study, we were often able to leverage
available source code snippets to validate the identified variants.
The graph is clearly split into two main areas, with binaries
compiled with THUMB mode support on the left, and with ARM
mode only on the right. Since the two halves are specular we label
variants separately on one or the other side of the graph to improve
readability. Bashlite is believed to be one of the first variants of
Gafgyt. Its samples are often mistaken for the Qbot variant (the
two are frequently presented as a synonym) but their code presents
significant differences. For example, Qbot uses two additional attack
techniques (e.g., DDoS using the GNU utility wget). Our method
rightfully recognizes them as belonging to the same family but as
distinct variants.
The next cluster in our genealogy refers to Razor, which fully
reuses the previous source code but adds an additional CnC com-
mand to clear log files, delete the shell history, and disable iptables.
Prometheus, for which we crawled two bundles, is an example of
malware versioning. Among the features of Prometheus, we see
self upgrade capabilities and usage of Python scripts (served by the
CnC) for scanning. Its maintainer added a Netis3 scanner in V4 to
reinforce self propagation through exploitation. Self propagation
and infection is further enhanced in Galaxy with a scanner dubbed
BCM and one called Phone suggesting it targets real phones. Next
to Galaxy we find an almost one-to-one fork we call Remastered
3Netis (a.k.a. Netcore in China) is a brand of routers found to contain an RCE vulnera-
bility in 2014 [46].
which does a less intrusive cleanup procedure, cleaning tempo-
rary directories and history but without stopping iptables and
firewalld.
Finally, in the top left-hand corner of Figure 6 we uncover Angels,
reusing some of Mirai’s code for random IP generation (like other
variants) and targeting specific subnets hard-coded in the binaries.
6 RELATED WORK
IoT Malware Landscape. Researchers have so far mostly focused
on analyzing the current state of attacks and malware targeting IoT
devices, usually by deploying honeypots [35, 45]. Antonakakis et
al. [3] provided a comprehensive forensic study of the Mirai bot-
net, reconstructing it history and tracking its various evolutions.
Cozzi et al. [12] carried out a systematic study of Linux malware
describing some of the trends in their behavior and level of so-
phistication. This work included samples developed for different
Linux-based OSes, without a particular focus on IoT systems. Dif-
ferent from this work, our objective is to study the relationships
among IoT malware families (e.g., code reuse) and track sub-family
variants and coding practices observed on a dataset an order of
magnitude larger (93K samples vs. 10K) collected over a period of
3.5 years.
Malware lineage. First introduced in 1998 by Goldberg et al. [18],
the concept of malware phylogenetic trees inspired by the study
of the evolution of biological species. Karim et al.in [28] presented
a code fragment permutation-based technique to reconstruct mal-
ware family evolution trees. In 2011, Dumitras et al. [15] presented
Colors represent a variantStripped samplesBinary similarity          capsaicin- frequent updates- new ﬂooders- upgrade itself using local gcc- Mirai IP generator          uzi- "uzi" Telnet scanner- new CnC commands          kaiten- supposedly used to name  the familyTsunami     "weebsquad"-initialversionsimilar  to kaiten-highcodereuseafter- SSH scanner-Telnetscanner           kstd- very basic- only a couple of ﬂooders       amnesia- CCTV exploit- VM detection- VM wipe- root/user persistenceMIPS ISuperHMotorola 68kARM 32-bitSPARCPowerPC        zbot- initially kaiten-like- then reuse ﬂooders The Tangled Genealogy of IoT Malware
ACSAC 2020, December 7–11, 2020, Austin, USA
Figure 6: Lineage graph of Gafgyt samples for ARM 32-bit.
Colors represent a variantStripped samplesBinary similarityqbotlovesecgalaxy v4"remastered"prometheus v4prometheus angelsrazor"dankmeme"ARM ModeTHUMB ModebashliteACSAC 2020, December 7–11, 2020, Austin, USA
Cozzi, et al.
some guidance on malware lineage studies: (i) use of a combina-
tion of static and dynamic features, e.g., code fragments, dynamic
CFGs, and (ii) use of time and source information related to studied
samples. Lindorfer et al. [31] developed Beagle, a system designed
to track the evolution of a malware family. They rely on dynamic
analysis to extract the different functionalities – in terms of API
calls – exhibited by a piece of malware. They then try to map these
functionalities back to disassembled code so they can identify and
characterise mutations in the malware family. Calleja et al. recently
analyzed in [10] – extending from their previous work [9] – the
evolution of 456 Windows malware samples observed over a period
of 40+ years and identified code reuse between different families as
well as with benign software. The types of code reuse they observed
include essentially anti-analysis routines, shellcode, data such as
credentials for brute-forcing attacks, and utility functions.
Recently, Haq et al. [21] reviewed 61 approaches from the lit-
erature on binary code similarity – some of which are used for
malware lineage inference [24, 26, 33] – published over the last 20
years. While they purposely focus on academic contributions rather
than binary diffing tools, they highlight the diversity, strengths and
weaknesses of all these techniques. They also identify several open
problems, some of which were faced in this work, such as scalability
and lack of support of multiple CPU architectures. BinSequence [24]
computes the similarity between functions extracted from binaries
at the instruction, basic block and CFG levels. Authors applied their
technique on different scenarios, including the identification of code
reuse in two Windows malware families. They also claim a func-