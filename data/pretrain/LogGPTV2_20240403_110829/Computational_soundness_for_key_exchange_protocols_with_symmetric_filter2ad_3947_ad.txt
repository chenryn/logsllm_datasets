In the realization
Penc(Σ) (Penc for short) of Fenc ideal encryption and decryp-
tion is simply replaced by (real) encryption and decryption
according to Σ, no extra randomness or tagging is necessary.
However, Penc(Σ) only realizes Fenc in environments that do
not generate key cycles or cause the so-called commitment
problem. More precisely, environments are required to be
used-order respecting and non-committing: We say that an
unknown key has been used (for encryption) if Fenc has been
instructed to use this key for encryption. Now, an environ-
ment is used-order respecting if an unknown key k, i.e., a
key marked unknown in Fenc, used for the ﬁrst time at some
96point is encrypted itself only by unknown keys that have
been used for the ﬁrst time later than k. An environment is
non-committing if an unknown key that has been used does
not become known later on. A protocol P that uses Fenc is
used-order respecting/non-committing if E |P is used-order
respecting/non-committing for any environment E. As ar-
gued in [26, 4], protocols are typically used-order respect-
ing and non-committing. In fact, in most protocols once a
key has been used to encrypt a message this key is typi-
cally not encrypted anymore in the rest of the protocol. We
call such protocols standard protocols. Provided static cor-
ruption, such protocols can easily be seen to be used-order
respecting and non-committing. Hence, such protocols can
be ﬁrst analyzed using Fenc. Then, by the composition the-
orem, Fenc can be replaced by its realization Penc.
In [26] also a joint state realization of Fenc is provided,
which guarantees that if Fenc is used in multiple sessions,
all sessions can use the same long-term symmetric keys.
6. COMPUTATIONAL INTERPRETATION
OF SYMBOLIC PROTOCOLS
In this section, we brieﬂy describe how a symbolic protocol
is executed in the IITM model. This is done in the expected
way, we highlight only some aspects.
Let P be a symbolic protocol as in Section 3. We assume
an injective mapping τ from global constants, i.e., free names
in P, to bit strings. Then, the protocol system [|P|]τ of P
is a system of IITMs:
[|P|]τ := M | M1 | . . . | Ml |Fenc
The IITMs M1, . . . , Ml are the computational interpreta-
tions [|R1|]τ , . . . , [|Rl|]τ of R1, . . . , Rl, respectively, as ex-
plained below. The machine M is used to provide the same
I/O interface to the environment as Fke and to initialize a
session. It connects to the systems M1, . . . , Ml,Fenc via the
I/O interface. The environment cannot directly communi-
cate with M1, . . . , Ml,Fenc via the I/O interface. Similarly
to Fke, the machine M expects to receive a request for key
exchange, containing the names of the parties involved in
the protocol session. Upon the ﬁrst request, M triggers the
machines M1, . . . , Ml to initialize themselves: nonces are
generated, short-term keys are generated using Fenc, and
long-term keys are exchanged, again using Fenc. In the ini-
tialization phase the adversary can corrupt keys (via Fenc)
or take over machines Mi completely (static corruption).
Again similar to Fke, if asked about the corruption status
by the environment, M reports this status to the environ-
ment: M checks the corruption status of every Mi and every
Mi in turn checks the corruption status of the keys it man-
ages. If one Mi or a key is corrupted, the whole session is
considered corrupted.
An IITM Mi is derived from its symbolic counterpart Ri
in the natural way.
It performs most of the communica-
tion with the adversary via the network interface. The I/O
interface is only used to receive initialization requests and
to report the corruption status, as explained above, or to
output session keys after successful completion of a session.
Encryption and decryption is performed via Fenc. We tag
pairs and keys/pointers in such a way that these objects
cannot be confused with other objects, and that the com-
ponents of pairs can be extracted. We do not require tags
to distinguish names, nonces, or ciphertexts. The atomic
net
formula M (s) is interpreted as true if the computational in-
terpretation of s does not fail. For example, applying π1 to
a bit string that is not a pair would fail. The atomic for-
mula EQ(s1, s2) is interpreted as true if the computational
interpretations of s1 and s2 do not fail and yield the same
bit strings. The output of the constants true and false after
if-then-else statements is not computationally interpreted,
i.e., Mi does not produce such outputs but directly contin-
ues with the execution after this output.
In other words,
the adversary is not given a priori knowledge of the internal
evaluation of if-then-else statements, although this could be
allowed without changing our results.
Let us illustrate the execution of Mi = [|Ri|]τ by the sym-
bolic role Ri = cin,i
net (x) . if EQ(π1(dec(x, sk(n))), a) then
[{(cid:104)n(cid:48), a(cid:105)}r
net (cid:104)true(cid:105) . cout,i
cout,i
π2(dec(x,sk(n)))] . . . else . . ., where
n ∈ Nlt, n(cid:48) ∈ Nnonce, r ∈ Nrand, and a ∈ N is a global con-
stant. In this case, after Mi has ﬁnished its initialization, as
explained above, Mi ﬁrst waits for input from the network
(the adversary). If Mi receives a message m, say, then, Mi
ﬁrst checks whether the evaluation of π1(dec(x, sk(n))) and a
is successful, corresponding to checking M (π1(dec(x, sk(n))))
and M (a). For a, which is τ (a), this is the case. For
the former expression, Mi decrypts m (because m is as-
signed to the input variable x) using Fenc with the long-term
key corresponding to sk(n).
If this succeeds, this should
yield a bit string tagged as a pair; otherwise the evalua-
tion fails, and the else-branch will be executed. Then, ex-
tracting the ﬁrst component of this pair will also succeed.
For EQ(π1(dec(x, sk(n))), a) to be true, it remains to check
whether this component coincides with τ (a). If this is the
net (cid:104)true(cid:105)
case, the then-branch will be executed. For this, cout,i
is skipped. Then, it is ﬁrst checked whether the expres-
sion s = {(cid:104)n(cid:48), a(cid:105)}r
π2(dec(x,sk(n))) can be evaluated success-
fully, which corresponds to checking M (s). The most crit-
ical part here is the evaluation of π2(dec(x, sk(n))). This
is done similarly to the case above. The evaluation should
yield a pointer of the form (Key, ptr ). This pointer is then
used to encrypt, using Fenc, the computational interpreta-
tion of (cid:104)n(cid:48), a(cid:105). Again, cout,i
net (cid:104)true(cid:105) is skipped. The resulting
ciphertext is then output on the network.
We note that Mi might receive keys (Key, k) in plaintext or
might be asked to output (short-term) keys in clear. Before
the actual parsing, such keys are entered into/extracted from
Fenc via store and reveal commands. We remark that storing
the same key twice returns the same pointer.
Finally, we note that Fenc might “fail”, i.e., Fenc returns
an error message, upon an encryption or store request. In
this case we deﬁne Mi to produce empty output and to ter-
minate. See [27] for a discussion of this point.
7. MAIN RESULT
We now present the main result of our paper. As already
mentioned in the introduction, the symbolic criterion for our
computational soundness result consists of two parts: i) We
assume the symbolic protocol to be labeled bisimilar (ob-
servationally equivalent) to its randomized version in which
instead of the actual session key a new nonce is output.
ii) All keys used within one uncorrupted session of the key
exchange protocol remain secret. As mentioned in the intro-
duction, the second condition is a very natural condition to
assume for key exchange protocols. Moreover, it will allow
us to deal with dishonestly generated keys, which have been
97problematic in other works (see also Section 9): Intuitively,
it implicitly guarantees that keys used by honest principals
in a protocol run will be honestly generated.
To formalize the ﬁrst part of our symbolic criterion, we de-
ﬁne the random-world version of a symbolic protocol. The
random-world version rand(P) of a symbolic protocol P as
in Section 3 is the same as P, except that instead of out-
putting the actual session key on channel cout
io , a random key
(i.e., a new nonce) is output. Formally, we deﬁne:
rand(P) := (νn
∗
)Pn∗
where n∗ is a name that does not occur in P and the process
(cid:104)n∗(cid:105)”
Pn∗ is obtained from P by replacing “cout,i
for every term s and i ≤ l. The ﬁrst part of our symbolic
criterion will then simply be P ∼l rand(P). As already
mentioned in the introduction, this condition can be checked
automatically using existing tools, such as ProVerif [11].
(cid:104)s(cid:105)” by “cout,i
io
io
To formulate the second part of our symbolic criterion, we
ﬁrst extend our signature Σ by the encryption and decryp-
tion symbols encsecret(·,·) and decsecret(·,·), respectively,
and add the equation decsecret(encsecret(x, y), y) = x. By
adding these symbols, interference with the other encryption
and decryption symbols will be prevented. We now intro-
duce a protocol secret(P) which is derived from P as follows:
It ﬁrst generates a new nonce n, used as a secret. It now
behaves just as P. However, whenever P uses a term s as a
key for encryption or decryption in the evaluation of a con-
dition in an if-then-else statement or to output a message,
then secret(P) outputs encsecret(n, s).
Now, the second part of our symbolic criterion requires
that, when executing secret(P), n can never be derived by
the adversary, i.e., for every successor Q of secret(P), it
holds that ϕ(Q) (cid:54)(cid:96) n. This exactly captures that all terms
used as keys in P are symbolically secret, i.e., cannot be de-
rived by the adversary. We say that P preserves key secrecy.
There are of course more declarative ways to formulate
this condition. However, from the formulation above it is
immediately clear that this condition can be checked auto-
matically using existing tools, such as ProVerif.
Now, we are ready to formulate the main theorem of this
paper, a computational soundness result for universally com-
posable key exchange. As explained above, the symbolic
criterion that we use can be checked automatically using
existing tools. The proof of this theorem is presented in
Section 8.
Theorem 3. Let P be a symbolic protocol and let τ be
an injective mapping of global constants to bit strings. If P
preserves key secrecy and P ∼l rand(P), then [|P|]τ ≤ Fke.
Recall that [|P|]τ uses Fenc for encryption. Let [|P|]τPenc
denote the system obtained from [|P|]τ by replacing Fenc
by Penc. As explained in Section 5.2,
if [|P|]τ (without
Fenc) is a used-order respecting and non-committing proto-
col, then, by the composition theorem, we can replace Fenc
by its realization Penc. However, we even obtain a stronger
result where we do not have to assume that [|P|]τ is non-
committing:
Corollary 1. Let P and τ be as in Theorem 3. If P
preserves key secrecy, P ∼l rand(P), and [|P|]τ is used-
order respecting, then [|P|]τPenc ≤ Fke.
The condition that [|P|]τ is used-order respecting is not a
symbolic one. However, there is a simple symbolic criterion
which captures the notion of a standard protocol explained
in Section 5.2.
Definition 6. We call a symbolic protocol P symboli-
cally standard if in every symbolic trace of P no short-term
key is encrypted by some other short-term key after it has
been used for encryption.
It is not hard to see that this condition can be checked auto-
matically using, for example, ProVerif: The condition can be
encoded as a secrecy property where a secret is output to the
adversary if the condition is violated. We note that decid-
ability results for detecting key cycles in symbolic protocols
were presented in [19]. We obtain the following corollary.
Corollary 2. Let P and τ be as in Theorem 3. If P
preserves key secrecy, is symbolically standard, and satisﬁes
P ∼l rand(P), then [|P|]τPenc ≤ Fke.
The above theorem and corollaries talk only about a sin-
gle protocol session. However, by the composition theo-
rem, we immediately obtain that the multi-session version of
[|P|]τPenc realizes multiple sessions of the key exchange func-
tionality, i.e., ![|P|]τPenc ≤ !Fke. However, in ![|P|]τPenc every
session of [|P|]τPenc uses new long-term keys. This is imprac-
tical. Fortunately, as already mentioned in Section 5.2, by a
joint state theorem established in [26], !Penc can be replaced
by its joint state realization, in which the same long-term
keys are used across all sessions. In such a realization session
identiﬁers are encrypted along with the actual plaintexts.
Altogether, the above results show that if a protocol sat-
isﬁes our symbolic criterion, which is concerned only with a
single protocol session and can be checked automatically,
then this protocol satisﬁes a strong, computational com-
posability property for key exchange. In particular, it can
be used as a key exchange protocol in every (probabilis-
tic polynomial-time) environment and even if polynomially
many copies of this protocol run concurrently. This merely
assumes that an authenticated encryption scheme is used for
symmetric encryption, which is a standard cryptographic as-
sumption, and that session identiﬁers are added to plaintexts
before encryption. The latter may not be done explicitly in
all protocol implementations, although it is often done im-
plicitly, e.g. in IPsec, and it is, in any case, a good design
technique.
8. PROOF OF THE MAIN THEOREM
Throughout this section, we ﬁx a symbolic protocol P =
net(xl).(R1 (cid:107) . . . (cid:107) Rl)) that preserves key
(νn)(cin
secrecy and satisﬁes P ∼l rand(P). We also ﬁx an injective
mapping τ of global constants to bit strings and an environ-
ment E for [|P|]τ = M | M1 | . . . | Ml |Fenc.
We have to show that there exists a simulator Sim such