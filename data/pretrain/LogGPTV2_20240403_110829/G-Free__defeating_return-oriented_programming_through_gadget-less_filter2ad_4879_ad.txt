functions with RAP
Number of
functions with JCP
6602
410
369
181
86
712
1342
2817
122
174
95
68
271
669
827
10
20
8
3
20
28
Table 2: Statistics on binaries compiled with G-Free (RAP=Return Address Protection, JCP=indirect Jump/Call Protection)
Program Name
gzip
grep
dd
md5sum
ssh-keygen
lame
Test case
Compress a 2GB ﬁle
Search in a 2GB ﬁle
Create a 2GB zero-ﬁlled ﬁle
Compute hash of a 2GB ﬁle
Generate 100 2048-bit RSA keys
Encode a 10 min long wav ﬁle
Execution Time (seconds)
Original Version G-Free Version (Overhead)
68.4 (2.9%)
82.9 (2.0%)
88.9 (2.6%)
82.9 (0.6%)
53.6 (4.6%)
122.0 (5.6%)
66.5
81.3
86.6
82.5
51.2
115.5
Table 3: Performance comparisons when the application and all the linked libraries are compiled with G-Free
against ROP, it is necessary to compile the entire application and
all the linked libraries with our technique. To demonstrate that our
tool can be applied to this more general scenario, we include in our
evaluation a number of common Linux applications.
Table 2 shows statistics about the binaries compiled with G-Free.
Our tool was able to successfully remove all unintended instruc-
tions and protect the aligned ones with an average size increase of
25.9% (more than half of which were caused by redundant nop in-
structions). The last two columns show that most of the functions
can be protected by our very efﬁcient return address encryption
technique while very few of them required the more complex in-
direct jump/call protection block. This is a consequence of the fact
that, according to what we observed in our experiments, programs
rarely use jmp*/call* instructions.
6.2 Performance Measurements
Table 3 shows the performance overheads we measured by run-
ning the different applications compiled with our prototype (this in-
cludes the gadget-free versions of the programs and all their linked
libraries). For each application, we designed a set of program-
speciﬁc test cases, summarized in Column 2 of the table. The av-
erage performance overhead was 3.1% – a value comparable with
the overhead caused by well known stack protection systems such
as StackShield [35] and StackGuard [11].
Since a library cannot be run as a standalone program, we evalu-
ated the performance overhead of our gadget-free version of glibc
using a set of well-known benchmarks.
In particular, we down-
loaded and installed the Phoronix Test Suite [1] which provides one
of the most comprehensive benchmark sets for the Linux platform.
Table 4 lists a sample of the benchmarks that represent different
application categories such as games, mathematical and physical
simulations, 3D rendering, disk and ﬁle system activities, compres-
sion, and well-known server applications. The results indicate that
the performance overhead of an application using our gadget-free
version of glibc is on average 1.09%.
7. CONCLUSIONS
Return-oriented programming is an attack technique that recently
attracted signiﬁcant attention from the scientiﬁc community. Even
though much research has been conducted on the topic, no compre-
hensive defense mechanism has been proposed to date.
In this paper we propose a novel, comprehensive solution to de-
fend against return-oriented programming by removing all gadgets
from a program binary at compile-time. Our approach targets all
possible free-branch instructions, and, therefore, is independent
from the techniques used to link the gadgets together. We im-
plemented our solution in a prototype that we call G-Free, a pre-
processor for the GNU Assembler. Our experiments show that
G-Free is able to remove all gadgets at the cost of a very low per-
formance overhead and an acceptable increase in the ﬁle size.
8. ACKNOWLEDGMENTS
The research leading to these results was partially funded from
the European Union Seventh Framework Programme (FP7/2007-
2013) under grant agreement nˇr 257007. This work has also been
supported in part by the European Commission through project
IST-216026-WOMBAT funded under the 7th framework program.
This publication reﬂects the views only of the authors, and the
Commission cannot be held responsible for any use which may be
made of the information contained therein. We would also like to
thank Secure Business Austria for their support for this research.
9. REFERENCES
[1] Phoronix test suite.
http://www.phoronix-test-suite.com/.
[2] Rop attack against data execution prevention technology, 2009.
http://www.h-online.com/security/news/item/
Exploit-s-new-technology-trick-%
dodges-memory-protection-959253.html.
[3] Symantec: Internet Security Threat Report.
http://www4.symantec.com/Vrt/wl?tu_id=
jLac123913792490340803, 2009.
[4] Intel 64 and IA-32 Architectures Software Developer’s Manuals.
http:
//www.intel.com/products/processor/manuals/,
2010.
[5] Aleph One. Smashing the stack for fun and proﬁt. In Phrack
Magazine n.49, 1996.
[6] E. Buchanan, R. Roemer, H. Shacham, and S. Savage. When Good
Instructions Go Bad: Generalizing Return-Oriented Programming to
RISC. In Proceedings of the 15th ACM Conference on Computer and
Communications Security (CCS), 2008.
[7] S. Checkoway, A. J. Feldman, B. Kantor, J. A. Halderman, E. W.
Felten, and H. Shacham. Can DREs Provide Long-Lasting Security?
The Case of Return-Oriented Programming and the AVC Advantage.
57Benchmark
FS-Mark (Files/s)
IOzone-write (MB/s)
IOzone-read (MB/s)
Dbench (MB/s)
Minion (s)
Sudokut (s)
TSCP (Nodes/s)
GMPbench (Score)
BYTE (Lines/s)
PyBench (s)
PHP Comp (s)
7-Zip (MIPS)
Unpack Linux Kernel (s)
LZMA (s)
BZIP2 (s)
FLAC Audio Encoding (s)
Ogg Encoding (s)
Himeno (MFLOPS)
dcraw (s)
Bullet Physics Engine (s)
Timed MAFFT (s)
PostgreSQL (Trans/s)
SQLite (s)
Apache(Requests/s)
x2642009 (Frames/s)
GtkPerf (s)
x11perf (Operations/s)
Urban Terror (Frames/s)
OpenArena (Frames/s)
C-Ray (s)
FFmpeg (s)
GraphicsMagick (Iter/min)
OpenSSL (Signs/s)
Gcrypt Library (micros)
John The Ripper (Real C/S)
GnuPG (s)
Timed HMMer Search (s)
Bwﬁrt (s)
Average:
Std:
Orig. Libc G-Free (Overhead)
14.9 (1.3%)
22.6 (0.4%)
22.7 (1.4%)
82.0 (2.0%)
250.7 (0.2%)
100.4 (3.5%)
224385.0 (0.1%)
2954.5 (0.03%)
6948792.8 (4.6%)
6959.0 (2.5%)
107.3 (4.3%)
2802 (0.7%)
31.01 (2.3%)
291.86 (0.01%)
65.84 (0.3%)
13.09 (1.0%)
27.20 (0.2%)
151.44 (0.4%)
52.99 (0.6%)
39.74 (0.4%)
52.55 (0.1%)
156.66 (0.9%)
191.78 (1.4%)
6836.24 (4.1%)
13.62 (0.7%)
20.49 (1.9%)
912000 (0.0%)
34.05 (0.9%)
46.67 (0.6%)
554.0 (0.05%)
25.02 (0.4%)
44 (2.2%)
25.28 (0.0%)
6983 (0.3%)
1857333 (0.1%)
20.67 (1.0%)
89.31 (0.4%)
285.3 (0.2%)
1.09%
1.27
Table 4: Performance comparison of the original and G-Free
glibc using benchmarks from the Phoronix Test Suite
15.1
22.8
23.0
83.7
250.2
97.1
224642.0
2955.5
7288371.3
6791.0
102.9
2822.0
30.30
291.67
65.63
12.96
27.14
152
52.68
39.58
52.48
155.24
189.09
7129.05
13.72
20.89
912000
34.20
46.93
553.7
24.93
45
25.28
6963
1854667
20.46
88.93
284.9
In Proceedings of EVT/WOTE 2009. USENIX/ACCURATE/IAVoSS,
2009.
[8] S. Checkoway and H. Shacham. Escape from return-oriented
programming: Return-oriented programming without returns (on the
x86). Technical report, 2010.
[9] P. Chen, H. Xiao, X. Shen, X. Yin, B. Mao, and L. Xie. Drop:
Detecting return-oriented programming malicious code. In Lecture
Notes in Computer Science, 2009.
[10] C. Cowan, S. Beattie, J. Johansen, and P. Wagle. PointGuard:
Protecting Pointers from Buffer Overﬂow Vulnerabilities. In
Proceedings of the 12th Usenix Security Symposium,, 2003.
[11] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beattie, A. Grier,
P. Wagle, Q. Zhang, and H. Hinton. StackGuard: Automatic adaptive
detection and prevention of buffer-overﬂow attacks. In Proceedings
of the 7th USENIX Security Symposium, USA, 1998.
[12] C. Cowan, P. Wagle, C. Pu, S. Beattie, and J. Walpole. Buffer
overﬂows: Attacks and Defenses for the Vulnerability of the Decade.
In Proceedings of the DARPA Information Survivability Conference
and Exposition,, 2000.
[13] L. Davi, A. R. Sadeghi, and M. Winandy. Dynamic integrity
measurement and attestation: Towards defense against
return-oriented programming attacks. In Proceedings ACM workshop
on Scalable trusted computing, 2009.
[14] Felix Lidner. Conﬁdence 2.0,. Developments in Cisco IOS forensics.
[15] A. Francillon and C. Castelluccia. Code injection attacks on
harvard-architecture devices. In Proceedings of CCS, 2008.
[16] A. Francillon, D. Perito, and C. Castelluccia. Defending embedded
systems against control ﬂow attacks. In Proceedings of the ﬁrst ACM
workshop on Secure execution of untrusted code, 2008.
[17] M. Frantsen and M. Shuey. Stackghost: Hardware facilitated stack
protection. In Proceedings of USENIX security, 2001.
[18] Hiroaki Etoh. GCC Extension for Protecting Applications from
Stack-Smashing Attacks (ProPolice). In
http://www.trl.ibm.com/projects/security/ssp/, 2003.
[19] R. Hund, T. Holz, and F. Freiling. Return-Oriented Rootkits:
Bypassing Kernel Code Integrity Protection Mechanisms. In
Proceedings of the 18th USENIX Security Symposium, USA, 2009.
[20] V. Kiriansky, D. Bruening, and S. P. Amarasinghe. Secure execution
via program shepherding. In Proceedings of the 11th USENIX
Security Symposium, pages 191–206, Berkeley, CA, USA, 2002.
USENIX Association.
[21] J. Li, Z. Wang, X. Jiang, M. Grace, and S. Bahram. Defeating
Return-Oriented Rootkits with Return-less Kernels. In Proceedings
of the 5th ACM SIGOPS EuroSys Conference, 2010.
[22] M. W. Lucas Davi, Ahmad-Reza Sadeghi. Ropdefender: A detection
tool to defend against return-oriented programming attacks.
Technical report, Technical Report HGI-TR-2010-001.
[23] Nergal. The advanced return-into-lib(c) exploits. In Phrack Magazine
n.58, 2001.
[24] R. Riley, X. Jiang, and D. Xu. Guest-transparent prevention of kernel
rootkits with vmm-based memory shadowing. In RAID ’08:
Proceedings of the 11th international symposium on Recent
Advances in Intrusion Detection, pages 1–20, Berlin, Heidelberg,
2008. Springer-Verlag.
[25] G. F. Roglia, L. Martignoni, R. Paleari, and D. Bruschi. Surgically
returning to randomized lib(c). In Proceedings of the 25th Annual
Computer Security Applications Conference (ACSAC), Honolulu,
Hawaii, USA., pages 60–69. IEEE Computer Society, Dec. 2009.
[26] Scut, Team Teso. Exploiting format string vulnerabilities. 2001.
[27] Sebastian Krahmer. x86-64 buffer overﬂow exploits and the
borrowed code chunks exploitation technique, 2005.
http://www.suse.de/~krahmer/no-nx.pdf.
[28] A. Seshadri, M. Luk, N. Qu, and A. Perrig. Secvisor: A tiny
hypervisor to provide lifetime kernel code integrity for commodity
oses. In Proceedings of Operating System Symposium SOSP, 2007.
[29] H. Shacham. The Geometry of Innocent Flesh on the Bone:
Return-into-libc without Function Calls (on the x86). In Proceedings
of the 14th ACM Conference on Computer and Communications
Security (CCS), 2007.
[30] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu, and
D. Boneh. On the effectiveness of address-space randomization. In
Proceedings of the 11th ACM Conference on Computer and
Communications Security (CSS), 2004.
[31] Solar Designer. return-to-libc attack. Technical report, bugtraq, 1997.
[32] The PaX Team. Pax address space layout randomization. Technical
report, http://pax.grsecurity.net/docs/aslr.txt.
[33] The PaX Team. Pax non-executable pages. Technical report,
http://pax.grsecurity.net/docs/noexec.txt.
[34] Tim Kornau. Return oriented programming for the arm architecture.
Technical report, Master’s thesis, Ruhr-Universität Bochum, 2010.
[35] Vendicator. Stackshield: A “stack smashing” technique protection
tool for linux. Technical report,
http://www.angelﬁre.com/sk/stackshield/.
[36] Z. Wang, X. Jiang, W. Cui, and P. Ning. Countering kernel rootkits
with lightweight hook protection. In Proceedings of the 16th ACM
Conference on Computer and Communications Security, CCS, 2009.
58