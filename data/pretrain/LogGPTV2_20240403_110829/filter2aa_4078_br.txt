修改以及因传输过程 中 的错误导致的无意修改。
消息完整性通过使用在传输消息时创建的数字签名消息摘要来强制实施。 消息的接收者简单地
对消息摘要和签名的有效性进行验证， 确保消息未在传输过程中修改。 公共和私钥密码系统都能够
强制实施完整性。 在第 7 章的 " 数字签名 " 一节中将对这个概念进行详细讨论。 使用 哈希加密算法
来保护文件完整性将在第 2 1 章 "恶意代码和应用攻击 " 中进行阐述。
3. 身份认证
身份认证对声明 的系统用户身份进行验证， 并且是密码系统的主要功能。 例如， 假设 Alice 希
望与 Bob 建立通信会话， 并且他们都参与到一个共享的保密通信系统。 A1ice 可能使用挑战/响应身
份认证技术确保 Bob 名副其实 。
图 6. 1 显示了挑战/响应协议在实际操作中是如何运行的。 在这个示例中 ， 由 Alice和Bob 使用
的共享秘密代码很简单: 每个词汇的宇母都被简单地颠倒次序。 Bob 首先与 Alice 联系， 并且标识
自 己的身份。 Alice 随后向 Bob 发出挑战信息 ， 要求他使用只 有 Alice 和 Bob 知道的秘密代码对一小
段消息进行加密。 Bob 将加密后的消息回应给 Alice。 在 Alice 验证这段加密消息的正确性之后， 她
相 信 Bob 确 实位于连接的另一端 。
"嗨， 我是 Bob!"
"为了证明是你， 请加密 'apple' 0"
Uelppa"
"嗨. Bob. 很高兴再次与你交谈。 "
图 6. 1 挑战/响应身份认证协议
4. 不可否认性
不可否认性为接收者提供了担保， 保证消息确实来自 发送者而不是来 自伪装成发送者的人。 不
可否认性能够防止发送者宣称原先从未发送过信息(也被称为否认消息)。 秘密密钥(或对称密钥)密码
系统(如简单的替代密码)并不提供对不可否认性的保证。 如果 Jim 和 Bob 都参与了某个密钥通信系
统， 那么他们就能够使用他们的共享密钥生成相同 的加密消息。 只 有公钥(或非对称密钥)密码系统
才提供不可否认性 ， 第 7 章将对 这个问 题进行更详细的讨论。
6.2.2 密码学概念
与任何科学一样 ， 在研究密码学之前， 你必须熟悉某些术语。 下面会介绍一些用于描述编码和
密码的关键术语。 消息在成为编码形式之前， 被称为明文消息， 并且在描述加密函数时使用字母 P
第6章 密码学与对称加密算法
表示。 消息的发送者使用密码学算法将明文消息加密为密文消息， 并且使用字母 C 表示。 消息通过
一些物理的或电子的方式被传送给接收者。 接收者随后使用预先确定的算法对密文消息进行解密，
从而得到 明 文形式的消 息(关于这个过程的详细解释 ， 请参看本章后面的图 6.3) 。
所有密码学算法都依赖密钥来维护其安全性。 在很大程度上， 密钥只不过是一个数字 。 密钥往
往是一个非常大的二进制数， 不过仍然是一个数字。 每种算法都具有一个特定的密钥空间。 密钥空
间是一段值的范围， 此范围 内 的值可作为密钥算法的有效密钥。 密钥空 间 由其位的长度定义。 位的
长度只不过是密钥中 的 比特数或位数(Os 和 Is)。 密钥空间的范围为: 从所有位全部为 0 到所有位全
部为 l 。 如果采用另一种方式表示 ， 那么密钥空间 的范围为 0到2n， 其中 n 是密钥的位的长度。 因
此， 128 位密钥的值可以从 0 到 2128(大约为 3.40282367* 1 038， 这是一个相当大的数字)。 保护密钥的
安全是非常重要的。 事实上， 从密码学获得的所有安全性就只能依赖于保证秘密使用密钥的能力。
Kerchoff 原则
所有密码学都基于算法的思想。 算法通常是一组数学规则 ， 这纽规则规定如何进行加密和解密
过程。 大多数算法都遵循 Kercho:fff#.. ýlJj ， 这条原则 使算法已知和公开， 并且九许任何人检查和测试
算法。 说的 明确一些 ， Kercho:ff 原 则(也被称为 Kercho:ff假设)就是算法应 当 公开， 但是所有密钥都
应 当 保密。 这条原则可归纳为 "敌人知道 了 这个体系"
许多 密码学 家都遵循这条原则 ， 但是并非所有人都女口此。 事实上， 一些人坚持相反的观点， 他
们 坚信算法和密钥都保密能够维护史佳的整体安全性。 Kercho:ff 原则的支持者反驳这种相反的做法
包含 "隐藏式保全" 习 惯， 并且相信公开算法能够产生 更大的活力 ， 能够更容易地暴露更多 的弱点，
从 而使人们 能够放弃不够强壮 的 算法， 并且可以 更快地采用 适合的 算法 。
正如你将在本章和下一章中学到的那样， 不同类型的算法要求不同类型的密钥。 在私钥(或秘密
密钥)密码系统中 ， 所有参与者都使用单个共享的密钥。 在公钥密码系统中， 每个参与者都具有 自 己
的密钥对。 密 钥有时被称为密码变量。
创建和实现秘密编码和密码的技术被称为密码术， 与之对应的技术是密码分析学一-对解码和
解密方法进行的学习研究 。 通常， 密码术与密码分析学一起被称为密码学。 编码或密码在硬件和软
件上的具体实现被称为密码系统。 美国联邦信息处理标准 1 40-2σIPSI40-2)的 " 密码模块的安全需
求 " 为美国联邦政府使用 的密码模块定义 了 硬件和软件需求。
提示 :
在继续学习本章和下一章的 内 容之前， 必须确保理解这些术语的含义。 对于理解接下来要介绍
的 密码学算法的技术细节来说， 理解这些 术语是必 不可少的。
6.2.3 密码学 的数学原理
由于密码学存在数学基础， 因此它与大多数计算机科学学科没有什么区别。 为 了全面理解密码
学 ， 必须首先理解二进制数学的基本知识以及用于操作二进制数值的逻辑操作。 下面将对最基本的
一些概念进行简要介绍 ， 这些概念是你应该熟悉的内容。
1 . 二进制数学
二进制数学定义了一些形成所有计算机神经系统的 比特和字节所使用 的规则。 你非常熟悉十进
1 33
CISSP 官方学习指南(第 7 版)
制系统。 十进制系统是一个以 10 为基础的系统， 其中每一位都是从 0到9 的整数， 并且每一位都是
1 0 的倍数。 我们所依赖的这个十进制系统很可能具有生物学起源一一人类有 10 根手指用来计数。
提示 :
二进制数学一开始可能会很混乱， 但是我们值得花时间来学 习各种逻辑运算是如何工作。 更重
要的是， 为 了 真正理解密码学算法 的 内 在工作原理 ， 你 需要理解这些概念 。
类似的， 计算机依赖的二进制系统起源于 电。 在 电流中 ， 只 有两种可能的状态: 开(代表存在电
流)和关(代表没有电流)。 电子设备执行的所有计算都必须利用这些术语来表达， 这就出现了现代 电
子学中 对二进制的使用 。 总的来说， 计算机科学家将开的状况称为真， 将关 的状况称为假。
2. 逻辑运算
密码学的二进制数学使用多种逻辑函数来操纵数据。 接下来我们将对这些逻辑运算进行简要
介绍 。
AND
AND 运算(用符号〈表示)可以检查两个值是否都为真。 下面的这张真值表说明 了 AND函数的所
有 4 种可能的结果。 需要记住的是， AND 函数只 有两个输入变量。 在二进制数学中 ， 每个变量都只
有两种可能的值， 因而为且也 函数准备了 4 种可能的输入。 正是这种有限的可能性才使得计算机
在硬件上实施逻辑函数变得非常容易。 在下面的真值表中可以看到， 只有一组输入组合(其中两个输
入值都为真)的输出值能够为真值 :
1 34
x y X^ Y
o 0 0
010
。 。
逻辑运算常常在整个二进制代码的基础上执行， 而不是在单一的数值基础上执行。 让我们来看
一看下面的例子:
X: 011011 00
Y: 10100111
X ^ Y: 0 0 1 0 0 1 0 0
可 以看到， AND 函数通过比较每一列上 X和Y 的值进行计算。 只 有在X和Y 的值都为真的列
上 ， 结果才为真。
OR
OR 运算(用符号v来表示)可以检查是否至少有一个输入值为真。 下面的真值表中 列出 了 OR 函
数的所有可能的值。 可 以看到 ， 只 有在两个输入值都为假时 ， OR 函数的结果才会返回假:
第6章 密码学与对称加密算法
X Y XvY
。 。 。
。
。
我们可以利用与上面相同的例子， 如果 X和Y执行 OR 运算而不是AND 运算 ， 输出内容如下
所示:
X:
Y:
o 1 101 100
1 0 100 1 1 1
X v Y: 1 1 1 0 1 1 1 1
NOT
NOT 运算(用符号~或!来表示)简单地将输入值取反。 这个函数每次只对一个变量进行操作。 下
面是 NOT 函数的真值表:
x -X
o 1
。
在下面的例子中 ， 我们对前面示例 中 的 X 值进行 NOT 运算:
X: o 110 1 100
-X : 1 0 0 1 0 0 1 1
XOR
本章要研究的最后一个逻辑函数可能在密码学应用 中最为重要且最常用， 这就是异或仅OR)操
作 。 在数学文献中， 也被称为 XOR 函数， 并且通常用符号 @ 表示。 只 有在一个输入值为真时， XOR
函数的结果才为真。 如果两个输入值都为假或都为真， 那么 XOR 函数的结果为假。 下面是 XOR 运
算 的真值表:
x Y XEBY
。 。 。
。
。