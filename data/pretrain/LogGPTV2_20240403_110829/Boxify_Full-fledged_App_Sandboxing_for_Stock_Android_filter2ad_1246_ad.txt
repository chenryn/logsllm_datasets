manages the packages installed into the Boxify en-
vironment. Every call to a system service that is
not emulated by the Core Logic Layer is passed on
to the Virtualization Layer and thus to the underly-
ing Android system. Other system services, such
as the LocationManager, which are not necessarily
required, can be instantiated at this layer as well,
in case encapsulated apps are supposed to use the
local, Boxify service implementation instead of the
pristine Android service (e.g., servicing sandboxed
apps with fake location data [64]). Hence, this layer
decides whether an Android API call is emulated
using a replicated service or forwarded to the sys-
tem (through the Virtualization Layer). This layer is
therefore responsible for managing the IPC communi-
cation between diﬀerent sandboxed apps (abstractly
like an “ICC switch”).
Furthermore, the Core Logic Layer implements the
policy enforcement points (PEP) for Binder IPC ser-
vices and syscalls. Because the API Layer already
bridges the semantic gap between kernel-level IPC
and Android application framework semantics, this
removes the burden for dealing with low-level seman-
tics in the IPC PEPs. We emulate the integration of
enforcement points into pristine Android services by
700  24th USENIX Security Symposium 
USENIX Association
integrating these points into our mandatory service
proxies. This allows us to instantiate security models
from the area of OS security extensions (see §3.2), but
at the application layer. One default security model
that Boxify provides is the permission enforcement
and same origin model of Android. For instance, the
replicated ActivityManager will enforce permissions
on calls between components of two sandboxed apps.
We present further security models from related work
on OS security extensions that we integrated at this
layer in §5.4 and for future work we consider a pro-
grammable interface for extending Core Logic Layer
security in the spirit of ASM [37] and ASF [14]. For
calls that are not protected by a permission, the Bro-
ker can also choose to enable direct communication
between the target app and the requested Android
system service. This can improve performance for
non-critical services such as the SurfaceFlinger (for
GUI updates) at the cost of losing the ability to me-
diate calls to these services.
The syscall PEP enforces system call policies in the
spirit of [47] with respect to network and ﬁlesystem
operations.
Its responsibilities are twofold: First,
it functions as a transparent compatibility layer by
emulating the ﬁle-system structure of the Android
data partition (e.g., chroot of sandboxed apps by
emulating a home directory for each sandboxed app4
within the home directory of the Boxify app). Second,
it emulates the access control of the Linux kernel, i.e.,
compartmentalization of sandboxed apps by ensuring
that they cannot access private ﬁles of other apps
as well as enforcing permissions (e.g., preventing a
sandboxed app without Internet permission from
creating a network socket).
6) Virtualization Layer. The sandbox environ-
ment must support communication between sand-
boxed apps and the Android application framework,
because certain system resources cannot be eﬃciently
emulated (e.g., SurfaceFlinger for GUI) or not em-
ulated at all (e.g., hardware resources like the cam-
era). However, the sandbox must be transparent to
the Target and all interaction with the application
framework must appear as in a regular app. At the
same time, the sandbox must be completely opaque
to the application framework and sandboxed apps
must be hidden from the framework; otherwise, this
leads to inconsistencies that the framework considers
as runtime (security) exceptions.
In Boxify, the Virtualization Layer is responsible
for translating the bi-directional communication be-
tween the Android application framework and the
4Recall that sandboxed apps are not installed in the system
but only in the Boxify environment, and hence do not have a
native home directory.
Target. It achieves the required semi-transparent com-
munication with a technique that can be abstractly
described as “ICC Network Address Translator”: On
outgoing calls from Target to framework, it ensures
that all ICC appears as coming from the Boxify app
instead of the sandboxed app. As described earlier,
all Binder handles of a Target are substituted with
handles of the Broker, which relays the calls to the
system. During relay of calls, the Virtualization Layer
manipulates the call arguments to hide components
of sandboxed apps by substituting the component
identiﬁers with identiﬁers of components of the Box-
ify app. On incoming calls from the framework, the
Virtualization Layer substitutes the addressed Boxify
component with the actually addressed component
of the sandboxed app and dispatches the call. In
order to correctly substitute addressed components,
the Virtualization Layer maintains a mapping between
Target and Boxify component names, or in case the
Target component is not addressed by a name but a
Binder handle that was given prior to the framework,
the mapping is between the released Binder handle
and its owning Target component.
A concrete example where this technique is applied
is requesting the launch of a Target Activity compo-
nent from the application framework (see Figure 7).
The Virtualization Layer substitutes the Activity com-
ponent with a generic Activity component of Boxify
if a call to the ActivityManager occurs. When the
service calls back for scheduling the Activity launch,
the Virtualization Layer dispatches the scheduling call
to the corresponding Target Activity component.
Lastly, we hook the application runtime of Boxify’s
Broker process (using a technique similar to [55]) in
order to gain control over the processing of incoming
Binder parcels. This enables the Broker to distinguish
between parcels addressed to Boxify itself and those
that need to be forwarded to the Target processes.
4.4 System Integration
Lastly, we discuss some aspects of integrating sand-
boxed apps into the default application framework.
Launcher. Since sandboxed apps have to be started
through Boxify (and are not regularly installed on
the system), they cannot be directly launched from
the default launcher. A straightforward solution is
to provide a custom launcher with Boxify in form
of a dedicated Activity. Alternatively, Boxify could
register as a launcher app and then run the default
launcher (or any launcher app of the user’s choice)
in the sandbox, presenting the union of the regularly
installed apps and apps installed in the sandbox envi-
ronment; or Boxify launcher widgets could be placed
USENIX Association  
24th USENIX Security Symposium  701
Native
Table 2: Microbenchmarks Middleware (200 runs)
API Call
Overhead
1.24ms (1.2%)
Open Camera
0.92 ms (12.0%)
Query Contacts
1.02 ms (1.5%)
Insert Contacts
0.95 ms (0.9%)
Delete Contacts
0.75 ms (0.6%)
Create Socket
on Boxify
104.48 ms
8.55 ms
67.51 ms
76.81 ms
121.58 ms
103.24 ms
7.63 ms
66.49 ms
75.86 ms
120.83 ms
on the regular home screen to launch sandboxed apps
from there.
App stores. Particularly smooth is the integration
of Boxify with app store applications, such as the
Google Play Store. Since no special permissions are
required to install apps into the sandbox, we can
simply run the store apps provided by Google, ven-
dors, and third-parties in Boxify to install new apps
there. For example, clicking install in the sandboxed
Play Store App will directly install the new app into
Boxify. Furthermore, Play Store (and vendor stores)
even take care of automatically updating all apps
installed in Boxify, a feature that IRM systems have
to manually re-implement.
Statically registered resources. Some resources
of apps are statically registered in the system dur-
ing app installation. Since sandboxed apps are not
regularly installed, the system is unaware of their
resources. This concerns in particular Activity com-
ponents that can receive Intents for, e.g., content
sharing, or package resources like icons. However,
some resources like Broadcast Receiver components
can be dynamically registered at runtime and Boxify
uses this as a workaround to dynamically register
the Receivers declared statically in the Manifests of
sandboxed apps.
5 Evaluation
We discuss the prototypical implementation of Boxify
in terms of performance impact, security guarantees,
and app robustness, and present concrete use-cases
of Boxify. Our prototype comprises 11,901 lines of
Java code, of which 4,242 LoC are automatically
generated (API Layer), and 3,550 lines of additional
C/C++ code. All tests described in the following
were performed on an LG Nexus 5 running Android
4.4.4, which is currently the most widely used version
in the Android ecosystem.
5.1 Performance Impact
To evaluate the performance impact of Boxify on
monitored apps, we compare the results of common
Table 3: Microbenchmarks Syscalls (15k runs)
Libc Func.
create
open
remove
mkdir
rmdir
Native
47.2 µs
9.5 µs
49.5 µs
88.4 µs
71.2 µs
on Boxify Overhead
115.2 µs
162.4 µs
122.7 µs
113.2 µs
110.1 µs
159.6 µs
111.0 µs
199.4 µs
180.7 µs
109.5 µs
Table 4: Benchmark Tools (10 runs)
Tool
CF Bench v1.3
Geekbench v3.3.1
PassMark v1.0.4
Quadrant v2.1.1
Native
16082 Pts
1649 Pts
3674 Pts
7820 Pts
on Boxify
15376 Pts
1621 Pts
3497 Pts
7532 Pts
Loss
4.3%
1.6%
4.8%
3.6%
benchmark apps and of custom micro-benchmarks
for encapsulated and native execution of apps.
Table 2 and Table 3 present the results of our micro-
benchmarks for common Android API calls and for
syscall performance. Intercepting calls to the appli-
cation framework imposes an overhead around 1%,
with the exception of the very fast Query Contacts
(12%). For syscalls, we measured the performance of
calls that request ﬁle descriptors for ﬁle I/O in pri-
vate app directories (or external storage) and that are
proxied by the Broker. We observe a constant perfor-
mance overhead of≈ 100µs, which corresponds to the
required time of the additional IPC round trip for the
communication with the Broker on our test platform.
However, the syscall benchmarks depict a worst-case
estimation: The overall performance impact on apps
is much lower, since high-frequent follow up opera-
tions on acquired ﬁle descriptors (e.g., read/write)
need not to be intercepted and therefore run with
native speed. We measured the overall performance
penalty by excecuting several benchmarking apps on
top of Boxify, which show an acceptable performance
degradation of 1.6%–4.8% (see Table 4).
5.2 Runtime Robustness
To assess the robustness of encapsulated apps, we
executed 1079 of the most popular, free apps from
Google Play (retrieved in August 2014) on top of
Boxify. For each sandboxed app we used the mon-
keyrunner tool5 to exercise the app’s functionality by
injecting 500 random UI events. From the 1079 apps,
93 (8.6%) experienced a crash during testing. Man-
ual investigation of the dysfunctional apps revealed
5http://developer.android.com/tools/help/
monkeyrunner_concepts.html
702  24th USENIX Security Symposium 
USENIX Association
Table 5: Android versions supported by Boxify.
Version
5.1
Supported
5.0
4.1
4.2
4.3
4.4


< 4.1
†


: supported; : not supported


†: no isolated proccess
that most errors were caused by apps executing ex-
otic syscalls or rarely used Android APIs which are
not covered by Boxify yet and thus fail due to the
lack of privileges of the Target process (fail-safe de-
faults). This leads to a slightly lower robustness than
reported for related work (e.g., [59, 15]) where by-
passed hooks do not cause the untrusted app to crash
but instead silently circumvent the reference monitor.
The remaining issues were due to unusual applica-
tion logic that relies on certain OS features (e.g., the
process information pseudo-ﬁlesystem proc), which
the current prototype of Boxify does not yet support.
However, all of these are technical and not concep-
tual shortcomings of the current implementation of
Boxify.
5.3 Portability
Table 5 summarizes the Android versions currently
supported by our prototypical Boxify implementa-
tion. Our prototype supports all Android versions
4.1 through 5.1 and can be deployed on nine out of
ten devices in the Android ecosystem [1]. Android
versions prior to 4.1 are not supported due to the
lack of the isolated process feature.
5.4 Use-cases
Boxify allows the instantiation of diﬀerent security
models from the literature on Android security ex-
tensions. In the following, we present two selected
use-cases on ﬁne-grained permission control and do-
main isolation that have received attention before in
the security community.
Fine-Grained Permission Control.
The
TISSA [64] OS extension empowers users to ﬂexi-
bly control in a ﬁne-grained manner which personal
information will be accessible to applications. We
reimplemented the TISSA functionality as an exten-
sion to the Core Logic Layer of the Boxify Broker.
To this end, we instrumented the mandatory prox-
ies for core system services (e.g. LocationManager,
TelephonyService) so that they can return a ﬁl-
tered or mock data set based on the user’s privacy
settings. Users can dynamically adjust their privacy
preferences through a management Activity added
to Boxify. In total, the TISSA functionality required
additional 351 lines of Java code to Core Logic Layer.
Domain Isolation. Particularly for enterprise de-
ployments, container solutions have been brought
forward to separate business apps from other (un-
trusted) apps [56, 17, 53].
We implemented a domain isolation solution based
on Boxify by installing business apps into the sand-
box environment. The Broker provides its own ver-
sion of the PackageManager to directly deliver inter-
component communication to sandboxed applications
without involving the regular PackageManager, en-
abling controlled collaboration between enterprise
apps while at the same time isolating and hiding
them from non-enterprise apps and the OS.
To separate the enterprise data from the user’s
private data, we exploit that the Broker is able to
run separate instances of system services (e.g., Con-
tacts, Calendar) within the sandbox. Our custom
ActivityManager proxy now selectively and trans-
parently redirects ContentProvider accesses by en-
terprise apps to the sandboxed counterparts of those
providers.
Alternatively, the above described domain isolation
concept was used to implement a privacy mode for
end users, where untrusted apps are installed into
a Boxify environment with empty (or faked) system
ContentProviders. Thus, users can test untrusted
apps in a safe environment without risking harm to
their mobile device or private data. The domain
isolation extension required 986 additional lines of
code in the Core Logic Layer of Boxify.
5.5 Security Discussion
Our solution builds on isolated processes as funda-
mental security primitive. An isolated process is the
most restrictive execution environment that stock
Android currently has to oﬀer, and it provides Boxify
with better security guarantees than closest related
work [38].
In what follows, we identify diﬀerent
security shortcomings and discuss potential future se-
curity primitives of stock Android that would beneﬁt
Boxify and defensively programmed apps in general.
Privilege escalation. A malicious app could by-
pass the syscall and IPC interceptors, for instance,
by statically linking libc. For IPC, this does not
lead to a privilege escalation, since the application
framework apps and services will refuse to cooperate
with an isolated process. However, the kernel is un-
aware of the concept of an “isolated process” and will
enforce access control on syscalls according to the
process’ UID. Although the transient UIDs of isolated