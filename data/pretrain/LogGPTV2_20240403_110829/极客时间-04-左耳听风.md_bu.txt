# Prolog 的语言特征逻辑编程是靠推理，比如下面的示例：    program mortal(X) :- philosopher(X). philosopher(Socrates).philosopher(Plato).philosopher(Aristotle). mortal_report:-write('Known mortals are:'), nl, mortal(X),write(X),nl,fail.我们可以看到下面的几个步骤。1.  先定义一个规则：哲学家是人类。2.  然后陈述事实：苏格拉底、亚里士多德、柏拉图都是哲学家。3.  然后，我们问，谁是人类？于是就会输出苏格拉底、亚里士多德、柏拉图。下面是逻辑编程范式的几个特征。-   逻辑编程的要点是将正规的逻辑风格带入计算机程序设计之中。-   逻辑编程建立了描述一个问题里的世界的逻辑模型。-   逻辑编程的目标是对它的模型建立新的陈述。-   通过陈述事实------因果关系。-   程序自动推导出相关的逻辑。
# 经典问题：地图着色问题我们再来看一个经典的四色地图问题。任何一个地图，相邻区域不能用相同颜色，只要用四种不同的颜色就够了。![](Images/2ca729433fe49645536efef0544e0250.png){savepage-src="https://static001.geekbang.org/resource/image/db/cb/db670cfbe7497d71eba70d60d8aa0fcb.png"}首先，定义四种颜色。    color(red).color(green).color(blue).color(yellow).然后，定义一个规则：相邻的两个地区不能用相同的颜色。    neighbor(StateAColor, StateBColor) :- color(StateAColor), color(StateBColor),     StateAColor \= StateBColor. /* \= is the not equal operator */最前面的两个条件：`color(StateAColor)` 和 `color(StateBColor)`表明了两个变量 `StateAColor` 和 `StateBColor`。然后，第三个条件：`StateAColor \= StateBColor` 表示颜色不能相同。接下来的事就比较简单了。我们描述事实就好了，描述哪些区域是相邻的事实。比如，下面描述了 BW 和 BY 是相邻的。`germany(BW, BY) :- neighbor(BW, BY).`下面则描述多个区 BW、 BY、 SL、 RP、 和 ND 的相邻关系：`germany(BW, BY, SL, RP, HE) :- neighbor(BW, BY), neighbor(BW, RP), neighbor(BW, HE).`于是，我们就可以描述整个德国地图的相邻关系了。    germany(SH, MV, HH, HB, NI, ST, BE, BB, SN, NW, HE, TH, RP, SL, BW, BY) :- neighbor(SH, NI), neighbor(SH, HH), neighbor(SH, MV),neighbor(HH, NI),neighbor(MV, NI), neighbor(MV, BB),neighbor(NI, HB), neighbor(NI, BB), neighbor(NI, ST), neighbor(NI, TH),neighbor(NI, HE), neighbor(NI, NW),neighbor(ST, BB), neighbor(ST, SN), neighbor(ST, TH),neighbor(BB, BE), neighbor(BB, SN),neighbor(NW, HE), neighbor(NW, RP),neighbor(SN, TH), neighbor(SN, BY),neighbor(RP, SL), neighbor(RP, HE), neighbor(RP, BW),neighbor(HE, BW), neighbor(HE, TH), neighbor(HE, BY),neighbor(TH, BY),neighbor(BW, BY).最后，我们使用如下语句，就可以让 Prolog 推导到各个地区的颜色。    ?- germany(SH, MV, HH, HB, NI, ST, BE, BB, SN, NW, HE, TH, RP, SL, BW, BY).
# 小结Prolog这种逻辑编程，把业务逻辑或是说算法抽象成只关心规则、事实和问题的推导这样的标准方式，不需要关心程序控制，也不需要关心具体的实现算法。只需要给出可以用于推导的规则和相关的事实，问题就可以被通过逻辑推导来解决掉。是不是很有意思，也很好玩？如果有兴趣，你可以学习一下，这里推荐两个学习资源：-   [Prolog    Tutorial](http://www.doc.gold.ac.uk/~mas02gw/prolog_tutorial/prologpages/)-   [Learn Prolog Now!](http://www.learnprolognow.org)以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。**这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。**-   [编程范式游记（1）-    起源](https://time.geekbang.org/column/article/301)-   [编程范式游记（2）-    泛型编程](https://time.geekbang.org/column/article/303)-   [编程范式游记（3）-    类型系统和泛型的本质](https://time.geekbang.org/column/article/2017)-   [编程范式游记（4）-    函数式编程](https://time.geekbang.org/column/article/2711)-   [编程范式游记（5）-    修饰器模式](https://time.geekbang.org/column/article/2723)-   [编程范式游记（6）-    面向对象编程](https://time.geekbang.org/column/article/2729)-   [编程范式游记（7）-    基于原型的编程范式](https://time.geekbang.org/column/article/2741)-   [编程范式游记（8）- Go    语言的委托模式](https://time.geekbang.org/column/article/2748)-   [编程范式游记（9）-    编程的本质](https://time.geekbang.org/column/article/2751)-   [编程范式游记（10）-    逻辑编程范式](https://time.geekbang.org/column/article/2752)-   [编程范式游记（11）-    程序世界里的编程范式](https://time.geekbang.org/column/article/2754)![](Images/1c1e992cf41f5294df097aabed82f9e4.png){savepage-src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg"}
# 40 \| 编程范式游记（11）- 程序世界里的编程范式这个世界到今天已经有很多很多的编程范式，相当复杂。下面这个图比较好地描绘了这些各式各样的编程范式。这个图越往左边就越是"声明式的"，越往右边就越不是"声明式的"（指令式的），我们可以看到，函数式编程、逻辑编程，都在左边，而右边是指令式的，有状态的，有类型的。![](Images/579235142700b3c69e31fb407584b253.png){savepage-src="https://static001.geekbang.org/resource/image/9d/8d/9d6ac4820cc070a6b567d3f514d9ea8d.png"}上面这个图有点乱，不过总体说来，我们可以简单地把这世界上纷乱的编程范式，分成这几类：**声明式**、**命名式**、**逻辑的**、**函数式**、**面向对象的**、**面向过程的**。于是我们归纳一下，就可以得到下面这个简单的图。简单描述一下，-   中间两个声明式编程范式（函数式和逻辑式）偏向于你定义要什么，而不是怎么做。-   而两边的命令式编程范式和面向对象编程范式，偏向于怎么做，而不是要做什么。![](Images/01f5cdb17508eb0cc2e36d5b3c6177b9.png){savepage-src="https://static001.geekbang.org/resource/image/d6/50/d64bf8275ee9e0eac3112dcd342d9350.png"}我们再归纳一下，基本上来说，就是两大分支，一边是在解决数据和算法，一边是在解决逻辑和控制。``{=html}![](Images/a9583693e7472a21ce6a7f632bbf0445.png){savepage-src="https://static001.geekbang.org/resource/image/bf/ef/bf6945c2ca2ec5564ecbbf1c81503eef.png"}下面再给一张表格说明一下这世界上四大编程范式的类别，它们的特性和主要的编程语言。![](Images/83b2d8d6418323a5ff2df5b932151886.png){savepage-src="https://static001.geekbang.org/resource/image/fc/ab/fcd2780bcb35c17e475eedb94b1f66ab.png"}程序编程范式。一个是左脑，一个右脑。我们程序员基本上是在用左脑，左脑是理性分析，喜欢数据证据，线性思维，陷入细节，具体化的，不抽象。但是实际上玩儿出这些东西的都在右脑，函数式，还有像逻辑式的抽象能力都在右脑。所以我们非线性的想象力都在这边，而标准化教育把我们这边已经全部干掉了，我们只剩左边。我们陷入细节，我一说Java 是最好的程序设计语言，一堆人就来了，找各种各样的细节问题跟你纠缠。离我们最近的是函数式编程，但既然函数式编程这么好，为什么函数式编程火不起来呢？首先，这里有个逻辑上的问题，并不是用的人越多的东西就越好。因为还要看是不是大多数人都能理解的东西。函数式编程或是声明式编程，需要的是用我们的右脑，而指令式的则需要用我们的左脑。参看下图：![](Images/d20f6a322979477fc0d6821eaa1b3a23.png){savepage-src="https://static001.geekbang.org/resource/image/11/c7/11f63d119d5954724b42024f9d6a64c7.png"}我们可以看到，**人的左脑的特性是**：-   理性分析型-   喜欢数据证据-   线性思维-   陷入细节-   具体化的**人的右脑的特性是**：-   直觉型-   想象力-   非线性-   宏观思维-   抽象化的人类社会中，绝大多数人都是左脑型的人，而只有少数人是右脑型的人，比如那些哲学家、艺术家，以及能够创造理论知识的人。这些人在这个世界上太少了。这是为什么很多人理解和使用声明式的编程范式比较有困难，因为这要用你的右脑，但是我们习惯于用我们的左脑，左脑用多了以后右脑就有点跟不上了。说到人类的大脑了，已经到了不是我专长的地方了，这个话题太大了，所以，也是时候结束《编程范式游记》这一系列文章了。希望你能从这一系列文章中有所收获。如果有什么疑问或是我有什么没有讲对的，还希望得到你的批评和指正。先谢谢了。以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。**这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。**-   [编程范式游记（1）-    起源](https://time.geekbang.org/column/article/301)-   [编程范式游记（2）-    泛型编程](https://time.geekbang.org/column/article/303)-   [编程范式游记（3）-    类型系统和泛型的本质](https://time.geekbang.org/column/article/2017)-   [编程范式游记（4）-    函数式编程](https://time.geekbang.org/column/article/2711)-   [编程范式游记（5）-    修饰器模式](https://time.geekbang.org/column/article/2723)-   [编程范式游记（6）-    面向对象编程](https://time.geekbang.org/column/article/2729)-   [编程范式游记（7）-    基于原型的编程范式](https://time.geekbang.org/column/article/2741)-   [编程范式游记（8）- Go    语言的委托模式](https://time.geekbang.org/column/article/2748)-   [编程范式游记（9）-    编程的本质](https://time.geekbang.org/column/article/2751)-   [编程范式游记（10）-    逻辑编程范式](https://time.geekbang.org/column/article/2752)-   [编程范式游记（11）-    程序世界里的编程范式](https://time.geekbang.org/column/article/2754)![](Images/1c1e992cf41f5294df097aabed82f9e4.png){savepage-src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg"}