用的其他字符。域名必须转换为UTF-8，任何非字母、数字、连字符或波浪号的字节
必须编码为%FF，这里FF是该字节的十六进制表示形式。
为了使我们的正则表达式更为简洁，我们不检查每个百分号是否恰好跟着两个十六进
制数。最好在把URL分割成为不同部分之后，再进行类似这样的合法性验证。因此我
们只需要用来匹配主机名，它同样会匹配IPv4地址（在RFC3986
的标准所支持的）。
除了域名或IPv4地址之外，主机也可以采用在两个方括号之间的一个IPv6地址，或者
是未来版本的IP地址的方式进行说明。我们用匹配未来可能的IP地址。尽管不能用还没定
但是这样的任务最好还是应该在把地址从URL中提取出来之后，留给另外一个正则式
来做。实例7.17中会展示对IPv6地址执行合法性验证的确不是一个很简单的任务。
如果指定了端口号，那么端口号就仅仅是一个用冒号和主机名分隔开来的数字。
用：[0-9]+>来表示就足够了。
如果指定了授权，那么它后面必须跟随一个绝对路径，或者完全没有路径。一个绝对
路径以正斜杠开始，之后跟着一个或多个用斜杠分隔的段（segment)。段由一个或多个
字母、数学或标点符号组成。这里不充许出现连续的正斜杠。路径可以以一个正斜杠
作为结束。。
相对URL中并不会指定通信协议方案，因此也不包含授权。路径则是必需的，它可以
是绝对的，也可是相对的。因为URL没有指定通信协议方案，一个相对路径中的第一
段就不能包含任何冒号。否则冒号会被视为通信协议方案的分隔符。这样就需要两个
正则表达式来匹配一个相对URL的路径。我们用[a-z0-9\-._～%!S&'O*+，
@]+(/[a-z0-9\-._～%!$&'O*+,；=:@]+)*/?>匹配相对路径，这和含有通信协议方案但是没
有授权的正则式很接近。唯一的不同是没有使用可选的前导正斜杠；另外一个区别是
第-个字符类中也没有包含冒号。我们用匹配绝
对路径。这和匹配指定了通信协议方案和授权的URL中的路径的正则式是一样的，
除了用来重复路径中的段的星号变成了加号。这是因为相对URL要求至少包含一个
路径段。
URL的查询部分是可选的。如果存在，那么它必须以-个问号作为开始，直到URL的
URL、路径和Internet地址347
www.TopSage.com
---
## Page 364
结尾或者到URL中的第一个井号之前。因为井号不在URL查询部分的合法标点符号
集合中，所以我们可以很容易地用进行匹配。这个
正则式中的两个问号是字面意义上的问号。第一个问号在字符类之外，因此必须被转
义。第二个问号在字符类之内，所以总是被看成字面意义上的问号符。
URL中的最后一部分是信息片段（fragment)，它也是可选的。它以一个井号作为开始，
直到URL结束。会匹配信息片段的部分。
为了更容易地处理URL中的不同部分，我们使用了命名捕获分组。实例2.11解释了在
本书中所讨论的不同的正则流派中如何使用命名捕获。.NET是其中唯一将多个分组用
同一个名字进行处理的，就好像它们是一个分组一样。在现在的情况下这种做法会非
常实用，因为根据是否指定了通信协议方案和/或授权，我们的正则式有多种途径可以
来匹配URL路径。如果我们把3个分组命名为同一名字，就可以简单地查询“path”
分组来获得路径，而不用去管URL是否含有通信协议方案或者授权。
对其他的流派而言，路径的3个捕获分组都会拥有不同的名字。当一个匹配被找到时，
只有其中之一才能真正作为URL的路径。另外两个分组则不会参与到匹配中。
参见
实例2.3、实例2.8、实例2.9和实例2.12。
7.8从URL中提取通信协议方案
问题描述
你要从一个作为URL的字符串中提取其中的URL通信协议方案。例如，你想要从
http://www.regexcookbook.com中抽取到http。
解决方案
从已知是合法的URI中抽取通信协议方案
（[a-2][a-z0-9+\-.1*） :
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
在对URL做合法性验证的同时抽取通信协议方案
LA
([a-z][a-z0-9+\- .] *) :
（授权和路径
//
348第7章
www.TopSage.com
---
## Page 365
（+[=+（），9$i~·-\6-0z-])
#用户名
([a-z0-9\-._~]+
#命名主机
1\[[a-f0-9:.]+\]
#IPv6主机
1\[v[a-f0-9][a=z0-9\-._~g!$&*() *+,=:]+\])
#IPvFuture主机
(:[0-9]+)?
#端口
/（+[@:=+（），9$ig~-·-\6-0z-]/)
路径
1#不包含授权的路径（/？[a-z0-9\-._~$！$&'（）*+，=：@]+（/[a-z0-9\-._~！$&'（）*+，=
（/（+[@：
）
#查询
（[/=+（），si~-\6-0z-]\）
#片段
（[/@:=+（），5Si~-\6-0z-]#\)
正则选项：不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
（[a-z][a-20-9+\-.]*):(//([a-z0-9\-._~$!$α'()*+,=]+@)？([a-z0-9\-._~]+|
\[[a-f0-9:.]+\]1\[v[a-f0-9][a-z0-9\-,_~g!$&'() *+,;=:]+\])(:[0-9]+) ?
（/[a-z0-9\-._~!$&'（)*+,;=:@]+)*/？1(/？[a-20-9\-._~g!$&*（)*+,;=:@]+
(/[a-z0-9\-._~！$6()*+,=:@]+) */?)?)(\？[a-z0-9\-._~!$&() *+,;=:@/？]*)？
S（[/:=+￥（），9Si~·-\6-0z-]#）
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
讨论
如果已知你的目标文本是一个合法的URL，那么从URL中抽取通信协议方案并不难。
假如URL中含有通信协议方案，那么它总是会出现在URL的开端。在这个正则式中
的脱字符（实例2.5）就可以满足这个要求。通信协议方案以字母开始，后面可以跟随
更多的字母、数字、加号、连字符和点号。我们可以用2个字符类来匹配它：
（参见实例2.3）。
通信协议方案和URL的其余部分之间以一个冒号作为分隔。我们把冒号加到正则
式中，以确保在URL真正从一个通信协议方案开始时才会匹配通信协议方案。相
中不能含有任何冒号，除非这些冒号前面出现的是通信协议方案中不充许出现的
字符。这就是为何在实例7.7中我们要把冒号排除在匹配路径的字符类中的原因。
如果你在一个合法但是相对的URL之上使用本实例中的正则式，就不会找到任何
一个匹配。
因为正则式所匹配的不是通信协议方案本身（还包含了冒号），所以我们要在正则表达
式上添加一个捕获分组。当正则式找到一个匹配时，你可以从第一个（也是唯一的一
个）捕获分组中提取所匹配的文本来获得不含有冒号的通信协议方案。实例2.9告诉你
关于捕获分组的所有相关内容。关于如何使用常用的编程语言来获取捕获分组所匹配
URL、路径和Internet地址349
www.TopSage.com
---
## Page 366
到的文本，请参阅实例3.9。
如果还不知道你的目标文本是否是一个合法的URL，那么可以使用实例7.7中的
正则式的一个简化版本。由于我们需要抽取的是通信协议方案，因此就可以排除
不指定通信协议方案的相对URL。这样就可以得到一个稍微简单一些的正则表
达式。
由于正则式匹配到的是整个URL，所以我们在匹配通信协议方案的正则式部分之外需
信协议方案。
参见
实例2.9、实例3.9和实例7.7。
7.9从URL中抽取用户名
问题描述
你要从包含一个URL的字符串中抽取出其中的用户名。例如，你想要从
ftp:/PI:EMAIL中抽取出其中的用户名jan。
解决方案
从已知是合法的URL中抽取用户名
[a-z0-9+\-.]+://([a-z0-9\-._~1$&'() *+,;=]+)@
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
在对URL做合法性验证的同时抽取用户名
\A
//:[·-\+6-02-][z-]
#通信协议方案
@（+[=+（），9$i8~·-\6-0z-e])
用户名
（[a-z0-9\-._~%]+
命名主机
\[[a-f0-9:.]+\]
#IPv6主机
1\[v[a-f0-9][a-z0-9\-._~!$6（)*+,;=:]+\])
#IPvFuture主机
(:[0-9]+}？
#端口
/+（+[：=+（），si~·-\6-0z-]/)
#路径
（[/:=+（）9$ig~-\6-02-]\)
#查询
（￥[/：=+（），9Si~-\6-02-]#\）
#片段
\z
正则选项：不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
350
第7章
www.TopSage.com
---
## Page 367
^[a-z][a-z0-9+\-.]*://([a-z0-9\-._~名1$&（) *+,;=]+)@（[a-z0-9\-._~]+|+
\[[a-f0-9:.]+\] 1\[v[a-f0-9][a-z0-9\-._~!$&'() *+,;=:]+\])(:[0-9]+) ？+
（/[a-20-9\-._~8!$&()*+,;=:θ]+)*/？(\?[a-z0-9\-._~8!$（）*+,=:θ/？]*)？
（#[a-20-9\-._~%!$6'()*+,;=:@/？]*)?$
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
讨论
如果已知你的目标文本是一个合法的URL，那么从URL中抽取用户名并不难。假如在
URL中含有用户名，那么它总是会紧跟在通信协议方案以及以两个斜杠号开始的URL
的“授权”部分的后面。用户名会以一个@符号和紧随其后的主机名分隔开。由于主
机名中不充许出现@符号，因此假如在两个斜杠符和URL中下一个斜杠符号之间找到
了一个@，就可以在URL中抽取出用户名的部分。因为在用户名中不允许出现斜杠，
所以我们不需要对斜杠做特殊处理。
如果已知URL是合法的，以上这些规则意味着抽取用户名会很容易。我们只要用
[a-z0-9+\-.]+>跳过通信协议方案，再跳过：//。然后，就可以找到紧随其后的用户名。
如果我们匹配到了@号，就可以知道在它之前的部分就是用户名。字符
类列出了在用户名中的所有合法字符。
本正则式只能在URL确实指定了用户名的时候可以找到一个匹配。如果它能找到匹配
的话，那幺正则式会同时匹配通信协议方案和URL的用户名部分。因而，我们在正则
表达式中需要加上一个捕获分组。当这个正则式找到一个匹配时，你可以提取第一个
（也是唯一的）捕获分组中所匹配到的文本，从中得到没有任何分隔符和URL其他部
分的用户名。关于捕获分组的知识都可以在实例2.9中找到。关于如何使用习惯的编程
语言提取捕获分组匹配的文本，可以参考实例3.9。
如果尚不明确你的目标文本是否是一个合法的URL，可以使用实例7.7中正则表达式
的一个简化版本。既然想要抽取的只是用户名，我们可以排除不包含授权的URL。在
前面解决方案中的正则式实际上只匹配了指定授权且在授权中包含一个用户名的
URL。如果要求在URL中必须包含授权部分，就会让这个正则表达式简单不少，甚至
比实例7.7中的正则式还要简单。
因为这个正则式匹配了整个URL，所以我们在匹配用户名的正则式部分周围还需要添
加一个捕获分组。提取第一个捕获分组所匹配到的文本可得到URL中的用户名。
如果希望正则式匹配任意的合法URL，其中也要包括那些没有指定用户名的URL，那
么你可以选取实例7.7中的一个正则式。假如URL中存在用户名，该实例中的第一个
正则式的第3个捕获分组就会捕获到用户名。在该捕获分组中会包含@符号。如果你
想捕获不包含@符号的用户名，那么可以向这个正则表达式中再添加一个额外的捕获
分组。
URL、路径和Internet地址351
www.TopSage.com
---
## Page 368
参见
实例2.9、实例3.9和实例7.7。
7.10从URL中抽取主机名
问题描述
你要从包含一个URL的字符串中抽取其中的主机名（域名或IP地址）。例如，你想要
从http://www.regexcookbook.com/中抽取出其中的www.regexcookbook.com。
解决方案
从已知是合法的URL中抽取主机名
\A
[a-2][a-20-9+\-.]*://
#通信协议方案
（[a-z0-9\-._~g!$&'()*+,=]+@）?
#用户名