.B \-funsigned\-char\c
\&\|'.
.TP
.B \-fsigned\-bitfields
.TP
.B \-funsigned\-bitfields
.TP
.B \-fno\-signed\-bitfields
.TP
.B \-fno\-unsigned\-bitfields
如果 没有 明确 声明 `\|\c
.B signed\c
\&\|' 或 `\|\c
.B unsigned\c
\&\|' 修饰符, 这些 选项 用来 定义 有符号位域 (bitfield) 或 无符号位域. 
缺省情况下, 位域 是 有符号 的, 因为 他们 继承的 基本 整数类型, 如
.B int\c
\&, 是 有符号数.
.Sp
然而, 如果 指定了 `\|\c
.B \-traditional\c
\&\|' 选项, 位域 永远 是 无符号数.
.TP
.B \-fwritable\-strings
把 字符串常量 存储到 可写数据段, 而且 不做 特别 对待.
这是 为了 兼容 一些 老程序, 他们 假设 字符串常量 是 可写的. `\|\c
.B \-traditional\c
\&\|' 选项 也有 相同 效果.
.Sp
篡改 字符串常量 是一个 非常 糟糕的 想法; \*(lq常量\*(rq 就应该是 常量.
.SH "预处理器选项 (Preprocessor Option)"
下列 选项 针对 C 预处理器, 预处理器 用在 正式 编译 以前, 对 C 源文件
进行 某种处理.
.PP
如果 指定了 `\|\c
.B \-E\c
\&\|' 选项, GCC 只进行 预处理 工作. 下面的 某些 选项 必须 和 `\|\c
.B \-E\c
\&\|' 选项 一起 才 有意义, 因为 他们的 输出结果 不能 用于 编译.
.TP
.BI "\-include " "file"
在 处理 常规 输入文件 之前, 首先 处理 文件 \c
.I file\c
\&, 其结果是, 文件 \c
.I file\c
\& 的 内容 先得到 编译.  命令行上 任何 `\|\c
.B \-D\c
\&\|'
和 `\|\c
.B \-U\c
\&\|' 选项 永远 在 `\|\c
.B \-include \c
.I file\c
\&\c
\&\|' 之前 处理, 无论 他们 在 命令行上 的 顺序 如何. 然而 `\|\c
.B \-include\c
\&\|' 和 `\|\c
.B \-imacros\c
\&\|' 选项 按 书写顺序 处理.
.TP
.BI "\-imacros " file
在 处理 常规 输入文件 之前, 首先 处理 文件 \c
.I file\c
\&, 但是 忽略 输出结果. 由于 丢弃了 文件
.I file\c
\& 的 输出内容, `\|\c
.B \-imacros \c
.I file\c
\&\c
\&\|' 选项 的 唯一 效果 就是 使 文件 \c
.I file\c
\& 中 的 宏定义 生效, 可以 用于 其他 输入文件. 在 处理 `\|\c
.B \-imacros\c
.I file\c
\&\|' 选项 之前, 预处理器 首先 处理 `\|\c
.B \-D\c
\&\|' 和 `\|\c
.B \-U\c
\&\|' 选项, 并不在乎 他们 在 命令行上 的 顺序. 然而 `\|\c
.B \-include\c
\&\|' 和 `\|\c
.B \-imacros\c
\&\|' 选项 按 书写顺序 处理.
.TP
.BI "\-idirafter " "dir"
把 目录 \c
.I dir\c
\& 添加到 第二包含路径 中. 如果 某个 头文件 在 主包含路径 (用`\|\c
.B \-I\c
\&\|' 添加的 路径) 中 没有 找到, 预处理器 就搜索 第二包含路径.
.TP
.BI "\-iprefix " "prefix"
指定 \c
.I prefix\c
\& 作为 后续 `\|\c
.B \-iwithprefix\c
\&\|'
选项 的 前缀.
.TP
.BI "\-iwithprefix " "dir"
把 目录 添加到 第二包含路径 中. 目录名 由 \c
.I prefix\c
\& 和 \c
.I dir\c
\& 合并 而成, 这里 \c
.I prefix
被 先前的 `\|\c
.B \-iprefix\c
\&\|' 选项 指定.
.TP
.B \-nostdinc
不要 在 标准系统目录 中 寻找 头文件. 只 搜索 `\|\c
.B \-I\c
\&\|' 选项 指定的 目录 (以及 当前目录, 如果 合适).
.Sp
结合 使用 `\|\c
.B \-nostdinc\c
\&\|' 和 `\|\c
.B \-I\-\c
\&\|' 选项, 你 可以 把 包含文件 搜索 限制在 显式 指定的 目录.
.TP
.B \-nostdinc++
不要 在 C++ 专用标准目录 中 寻找 头文件, 但是 仍然 搜索 其他 标准目录.
(当 建立 `\|\c
.B libg++\c
\&\|' 时 使用 这个选项.)
.TP
.B \-undef
不要 预定义 任何 非标准宏. (包括 系统结构 标志).
.TP
.B \-E
仅运行 C 预处理器. 预处理 所有 指定的 C 源文件, 结果 送往 标准输出
或 指定的 输出文件.
.TP
.B \-C
告诉 预处理器 不要 丢弃 注释. 配合 `\|\c
.B \-E\c
\&\|' 选项 使用.
.TP
.B \-P
告诉 预处理器 不要 产生 `\|\c
.B #line\c
\&\|' 命令. 配合 `\|\c
.B \-E\c
\&\|' 选项 使用.
.TP
.B \-M\  [ \-MG ]
告诉 预处理器 输出 一个 适合 \c
.B make
的 规则, 用于 描述 各目标文件的 依赖 关系. 对于 每个 源文件,
预处理器 输出 一个 \c
.B make
规则, 该规则 的 目标项 (target) 是 源文件 对应的 目标文件名, 依赖项
(dependency) 是 源文件中 `\|\c
.B #include\c
\&\| 引用的 所有文件. 生成的 规则 可以是 单行, 但如果 太长, 就用 `\|\c
.B \e\c
\&\|'-换行符 续成 多行. 规则 显示在 标准输出, 不产生 预处理过的 C 程序.
.Sp
`\|\c
.B \-M\c
\&\|' 隐含了 `\|\c
.B \-E\c
\&\|' 选项.
.Sp
`\|\c
.B \-MG\c
\&\|' 要求 把 缺失的 头文件 按 存在 对待, 并且 假定 他们 和 源程序文件
在 同一目录 下. 必须 和 `\|\c
.B \-M\c
\&\|' 选项 一起用.
.TP
.B \-MM\  [ \-MG ]
和 `\|\c
.B \-M\c
\&\|' 选项 类似, 但是 输出结果 仅涉及 用户头文件, 象 这样 `\|\c
.B #include \&"\c
.I file\c
\&"\c
\&\|'.  忽略 系统头文件 如 `\|\c
.B #include \c
\&\|'.
.TP
.B \-MD
和 `\|\c
.B \-M\c
\&\|' 选项 类似, 但是 把 依赖 信息 输出在 文件中, 文件名 通过 把 输出文件名
末尾的 `\|\c
.B .o\c
\&\|' 替换为 `\|\c
.B .d\c
\&\|' 产生. 同时 继续 指定的 编译工作 \(em\&`\|\c
.B \-MD\c
\&\|' 不象 `\|\c
.B \-M\c
\&\|' 那样 阻止 正常的 编译任务.
.Sp
Mach 的 实用工具 `\|\c
.B md\c
\&\|' 能够 合并 `\|\c
.B .d\c
\&\|' 文件, 产生 适用于 `\|\c
.B make\c
\&\|' 命令 的 单一的 依赖文件.
.TP
.B \-MMD
和 `\|\c
.B \-MD\c
\&\|' 选项 类似, 但是 输出结果 仅涉及 用户头文件, 忽略 系统头文件.
.TP
.B \-H
除了 其他 普通 的 操作, GCC 显示 引用过的 头文件 名.
.TP
.BI "\-A" "question" ( answer )
如果 预处理器 做 条件测试, 如 `\|\c
.BI "#if #" question ( answer )\c
\&\|', 该选项 可以 断言 (Assert)
.I question
的 答案 是
.I answer.
.B \-A\-\c
\&\|' 关闭 一般用于 描述 目标机 的 标准 断言.
.TP
.BI \-D macro
定义 宏 \c
.I macro\c
\&, 宏 的 内容 定义为 字符串 `\|\c
.B 1\c
\&\|'.
.TP
.BI \-D macro = defn
定义 宏 \c
.I macro\c
\& 的 内容 为 \c
.I defn\c
\&. 命令行 上 所有的 `\|\c
.B \-D\c
\&\|' 选项 在 `\|\c
.B \-U\c
\&\|' 选项 之前 处理.
.TP
.BI \-U macro
取消 宏 \c
.I macro\c
\&.  `\|\c
.B \-U\c
\&\|' 选项 在 所有的 `\|\c
.B \-D\c
\&\|' 选项 之后 处理, 但是 优先于 任何 `\|\c
.B \-include\c
\&\|' 或 `\|\c
.B \-imacros\c
\&\|' 选项.
.TP
.B \-dM
告诉 预处理器 输出 有效的 宏定义 列表 (预处理 结束时 仍然 有效的 宏定义).
该选项 需 结合 `\|\c
.B \-E\c
\&\|'
选项 使用.
.TP
.B \-dD
告诉 预处理器 把 所有的 宏定义 传递到 输出端, 按照 出现的 顺序 显示.
.TP
.B \-dN
和 `\|\c
.B \-dD\c
\&\|'选项 类似, 但是 忽略 宏的 参量 或 内容. 只在 输出端 显示 `\|\c
.B #define \c
.I name\c
\&\c.
.SH "汇编器选项 (ASSEMBLER OPTION)"
.TP
.BI "\-Wa," "option"
把 选项 \c
.I option\c
\& 传递给 汇编器.  如果 \c
.I option
含有 逗号, 就在 逗号 处 分割成 多个 选项.
.SH "连接器选项 (LINKER OPTION)"
下面的 选项 用于 编译器 连接 目标文件, 输出 可执行文件 的 时候.
如果 编译器 不进行 连接, 他们 就 毫无意义.
.TP
.I object-file-name
如果 某些文件 没有 特别明确的 后缀 a special recognized suffix,
GCC 就 认为 他们 是 目标文件 或 库文件. (根据 文件内容, 连接器 能够 区分
目标文件 和 库文件). 如果 GCC 执行 连接 操作, 这些 目标文件 将 成为
连接器 的 输入文件.
.TP
.BI \-l library
连接 名为 \c
.I library\c
\& 的 库文件.
.Sp
连接器 在 标准搜索目录 中 寻找 这个 库文件, 库文件 的 真正 名字 是 `\|\c
.B lib\c
.I library\c
\&.a\c
\&\|'.  连接器 会 当做 文件名 得到 准确 说明 一样 引用 这个文件.
.Sp
搜索目录 除了 一些 系统标准目录 外, 还包括 用户 以 `\|\c
.B \-L\c
\&\|' 选项 指定 的 路径.
.Sp