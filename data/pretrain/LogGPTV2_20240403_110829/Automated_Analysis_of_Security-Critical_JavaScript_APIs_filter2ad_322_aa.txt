title:Automated Analysis of Security-Critical JavaScript APIs
author:Ankur Taly and
&apos;Ulfar Erlingsson and
John C. Mitchell and
Mark S. Miller and
Jasvir Nagra
2011 IEEE Symposium on Security and Privacy
Automated Analysis of Security-Critical JavaScript APIs
Ankur Taly
Stanford University
PI:EMAIL
´Ulfar Erlingsson
Google Inc.
John C. Mitchell
Stanford University
Mark S. Miller
Google Inc.
Jasvir Nagra
Google Inc.
PI:EMAIL
PI:EMAIL
PI:EMAIL
PI:EMAIL
Abstract—JavaScript is widely used to provide client-side
functionality in Web applications. To provide services ranging
from maps to advertisements, Web applications may incor-
porate untrusted JavaScript code from third parties. The
trusted portion of each application may then expose an API to
untrusted code, interposing a reference monitor that mediates
access to security-critical resources. However, a JavaScript
reference monitor can only be effective if it cannot be circum-
vented through programming tricks or programming language
idiosyncrasies. In order to verify complete mediation of critical
resources for applications of interest, we deﬁne the semantics
of a restricted version of JavaScript devised by the ECMA
Standards committee for isolation purposes, and develop and
test an automated tool that can soundly establish that a given
API cannot be circumvented or subverted. Our tool reveals a
previously-undiscovered vulnerability in the widely-examined
Yahoo! ADsafe ﬁlter and veriﬁes conﬁnement of the repaired
ﬁlter and other examples from the Object-Capability literature.
Keywords-Language-Based Security, Points-to Analysis,
APIs, Javascript
I. INTRODUCTION
JavaScript
is widely used to provide client-side func-
tionality in Web applications. Many contemporary websites
incorporate untrusted third-party JavaScript code into their
pages in order to provide advertisements, Google Maps,
so-called gadgets, and applications on social networking
websites. Since JavaScript code has the ability to manipulate
the page Document Object Model (DOM), steal cookies, and
navigate the page, untrusted third-party JavaScript code may
pose a signiﬁcant security threat to the hosting page.
While third-party code may be isolated by placing it in
an iFrame, this reduces performance and restricts interaction
between the hosting page and third-party code. Instead,
Facebook and other sites rely on language-based techniques
[36] to embed untrusted applications directly into the hosting
page.
A widely used approach combines a language-based
sandbox to restrict the power of untrusted JavaScript with
trusted code that exports an API to untrusted code. In the
API+Sandbox approach, used in Facebook FBJS [36], Ya-
hoo! ADsafe [9], and Google Caja [6], the trusted code must
encapsulate all security-critical resources behind an API that
provides JavaScript methods to safely access these resources.
While there has been signiﬁcant progress [23–25] toward
provably-safe sandboxes for restricting access to the global
object and other critical objects, very little research has been
devoted to rigorously analyzing API conﬁnement.
In this
paper, we therefore study and provide precise semantics for
a subset of JavaScript that supports conﬁnement, present an
automated tool that provably veriﬁes conﬁnement, and use
this tool to analyze code designed to provide conﬁnement.
We consider a variant of a recently-standardized version of
JavaScript that supports static scoping and hiding of nested
local variables. Using this language, our static analysis
method examines trusted code used in a hosting page,
such as security-focused wrapping libraries, and determines
whether it is secure against arbitrary untrusted code in the
same language. Since trusted code enforcing a reference
monitor is written by security-conscious programmers, we
believe the authors of trusted code may be willing to
structure their code to improve the precision of the analysis.
Under these conditions, our automated method is sufﬁcient
to verify that no interleaved sequence of API method calls
returns a direct reference to a security-critical object.
Given an implementation of an API reference monitor
and a set of security-critical objects, our automated tool
ENCAP soundly veriﬁes API conﬁnement. We used this
tool to analyze the Yahoo! ADsafe library [9] under the
threat model deﬁned in this paper and found a previously
undetected security oversight that could be exploited on the
current web to leak access to the document object (and hence
the entire DOM tree). This demonstrates the value of our
analysis, as ADsafe is a mature security ﬁlter that has been
subjected to several years of scrutiny and even automated
analysis [18]. After repairing the vulnerability, our tool is
sufﬁcient to prove conﬁnement of the resulting library under
our threat model.
A. API+Sandbox examples
We illustrate the API+Sandbox approach using a simple
example: a hosting page intends to provide a write only log
facility to untrusted code. It enforces this intent by creating
an array to log data and an API object which has a single
method push that only allows data to be pushed on to the
array. The API object is then provided to untrusted code by
placing it in a global variable api.
var priv = criticalLogArray;
var api = {push: function(x){priv.push(x)}}
1081-6011/11 $26.00 © 2011 IEEE
DOI 10.1109/SP.2011.39
363
Untrusted code is restricted so that the only global variable
accessible to it is api. A necessary requirement in establish-
ing correctness of this mechanism is to verify that the API
object does not leak a direct reference to criticalLogArray as
that would allow reading data from the array.
While the example above may suggest
the API
conﬁnement problem is easily solved, the addition of the
following store method to the API may suggest otherwise:
api.store = function(i,x){priv[i] = x}
While a cursory reading shows that neither API method
returns a reference to the array, the API fails to conﬁne the
array. A client may gain direct access to the criticalLogArray
by calling methods of the API and mutating external state,
as in the following code:
that
var result;
api.store(’push’,function(){result = this[0]});
api.push();
The exploit makes unanticipated use of the store method by
supplying “push” as the ﬁrst argument instead of a numeral.
Our automated analysis detects this problem by effectively
considering all possible invocations of all the API methods.
The foundations of the API+Sandbox approach lie in the
object-capability theory of securing systems (see [20, 29]).
In the context of capabilities, the methods of the API are
capabilities supplied to untrusted code and the sandbox is
the loader that loads untrusted code only with a given set of
capabilities [29]. If API methods are viewed as capabilities,
then the API Conﬁnement Problem is also known as the
Overt Conﬁnement Problem for Capabilities [19].
B. Conﬁnement-friendly JavaScript
One reason why prior work has not focussed on verifying
correctness of APIs is because present JavaScript, based on
the 3rd edition of ECMA-262 standard, is not amenable to
static analysis, for reasons discussed in section 2. Recog-
nizing these difﬁculties, the ECMA Standards Committee
(TC39) developed a strict mode (ES5S) in the 5th edition
of the ECMAScript Standard (ES5) [10], that supports static
lexical scoping and closure-based encapsulation. ES5S, how-
ever, has two remaining limitations for conﬁnement and
static analysis: (1) ambient access to built-in objects may be
used to subvert some of the checks in API implementations,
and (2) eval allows dynamic code execution.
In this paper, we propose a variant SESlight of ES5S that
supports static analysis and conﬁnement by eliminating the
two problems above. As discussed in section 2, SESlight is
comparable to and more expressive than previous JavaScript
sandboxing sublanguages. In SESlight, malicious use of
built-in objects is restricted by making necessary objects
immutable. For dynamic code execution, the language only
supports a restrictive form of eval, which we call variable-
restricted eval, that is amenable to static analysis. While
364
a more permissive sublanguage Secure EcmaScript (SES)
is currently under proposal by the ECMA committee (TC
39), the two languages are relatively close. The main dif-
ference between SES and SESlight is that SES supports
getters/setters and SESlight does not because they are not
amenable to the analysis methods we considered practical in
developing our approach. Since no current browser imple-
ments the SESlight semantics, we describe a way to enforce
the SESlight semantics in an ES5S environment, using an
initialization script that must be run in the beginning and
a static veriﬁer that must be applied to all code that runs
subsequently. While we have implemented this method, our
formal analysis is based on the independent semantics of
SESlight
C. Static analysis method
The main technique used in our veriﬁcation procedure is a
conventional context-insensitive and ﬂow-insensitive points-
to analysis. We analyze the API implementation and gener-
ate a conservative Datalog model of all API methods. We
encode an attacker as a set of Datalog rules and facts, whose
consequence set is an abstraction of the set of all possible
invocations of all the API methods. Our attacker encoding
is similar to the encoding of the conventional Dolev-Yao
network attacker, used in network protocol analysis. We
prove the soundness of our procedure by showing that the
Datalog models for the API and the attacker are sound
abstractions of the semantics of the API and the set of all
possible sandboxed untrusted code respectively. The threat
model is based on arbitrary untrusted SESlight code run with
respect to the SESlight semantics after sandboxing.
D. Contributions and Organization
In summary, the main contributions of this paper are:
• The syntax and semantics of the language SESlight, which
supports a safe sandbox and is amenable to static analysis,
• A Datalog-based procedure for deciding conﬁnement
properties of SESlight APIs,
• A proof of semantic soundness of the procedure under the
SESlight threat model,
• An implementation of the procedure in the form of an
automated tool ENCAP, and
• Applications of the tool
to demonstrate an attack on
Yahoo! Adsafe, conﬁnement properties of repaired Adsafe,
and conﬁnement properties of standard examples from the
object-capability literature.
The remainder of this paper is organized as follows:
section 2 motivates the design of the language SESlight,
section 3 describes its syntax and semantics, section 4
formally deﬁnes the Conﬁnement problem for SESlight
APIs, section 5 presents a static analysis procedure for
verifying API Conﬁnement, section 6 presents applications
of the procedure on certain benchmark examples, 7 describes
related work and section 8 concludes.
II. FROM JAVASCRIPT TO ES5-STRICT TO SESlight
We motivate the design of the language SESlight in two
steps. We ﬁrst describe the restrictions ES5S imposes on
the form of JavaScript implemented in current browsers and
then explain the added restrictions of SESlight over ES5S.
A. JavaScript to ES5S
In Dec 2009,
the ECMA committee released the 5th
edition of the ECMA262 standard [10] which includes
a “strict mode” that is approximately a syntactically and
semantically restricted subset of the full language. Shifting
from normal to strict mode is done by mentioning the “use
strict” directive at the beginning of a function body, as
in function(){”use strict”; .....}. In this paper we analyze the
strict mode of ES5 as a separate programming language
and assume that all code runs under a global “use strict”
directive. Figure 1 summarizes the restrictions enforced by
ES5S on JavaScript. The three language properties that hold
for ES5S as a result are: Lexical Scoping, Safe Closure-based
Encapsulation and No Ambient Access to Global Object. For
each of these properties, we brieﬂy explain why they fail for
JavaScript and hold for ES5S:
Lexical Scoping. Even though variable bindings in ES3 are
almost lexically scoped, the presence of prototype chains on
scope objects (or activation records) and the ability to delete
variable names makes a static scope analysis of variable
names impossible. This makes ordinary renaming of bound
variables (α-renaming) unsound and signiﬁcantly reduces
the feasibility of static analysis. For example in the following
code, it is impossible to decide the value returned by the call
f(), for an arbitrary expression e.
Object.prototype[] = 24;
var x = 42;
var f = function foo(){return x;}; f();
If the evaluation of expression e returns “x” then the call
f() returns 24, else it would return 42. Similar corner cases
arise when code can potentially delete a variable name or
can use the with construct to artiﬁcially insert objects on the
scope chain. Recognizing these issues, ES5S forbids deletion
on variable names and the use of the with construct. Further-
more, the semantics of ES5S models activation records using
the traditional store data structure and therefore without any
prototype inheritance.
Safe Closure-based Encapsulation. JavaScript implemen-
tations in most browsers support the arguments.caller construct
that provides callee code with a mechanism to access
properties of the activation object of its caller function.
This breaks closure-based encapsulation, as illustrated by
the following example: a trusted function takes an untrusted
function as argument and checks possession of a secret
before performing certain operations.
Restriction
No delete on variable names
No prototypes for scope objects
No with
No this coercion
Safe built-in functions
No .callee, .caller on
arguments objects
No .caller, .arguments on
function objects
No arguments and formal
parameters aliasing
Rationale
Lexical Scoping
Lexical Scoping
Lexical Scoping
Isolating Global Object
Isolating Global Object
Safe Encapsulation
Safe Encapsulation
Safe Encapsulation
Figure 1. ES5S restrictions over JavaScript
function trusted(untrusted, secret) {
if (untrusted() === secret) {
}
// process secretObj
}
Under standard programming intuition,
this code should