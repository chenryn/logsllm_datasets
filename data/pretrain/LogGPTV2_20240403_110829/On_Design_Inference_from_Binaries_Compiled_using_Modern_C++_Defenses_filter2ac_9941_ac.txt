time. This prevents compilers from inlining their functions
and makes it necessary to retain all useful information. How-
ever, executables get inlined aggressively since the scope of
their use is visible to the compiler during compilation. For
instance, CaVer and TypeSan embed THTables while FCFI
embeds VTable maps for virtually all classes in a library.
4.6 Callsite Analysis
Callsite analysis is necessary for C2 defenses which implicitly
embed class hierarchy information at callsites. The complete-
ness of our analysis for OVT, for example, depends greatly
on the number of base classes which have at least one cor-
responding callsite. The availability of this information at
callsites makes it possible for us to identify subtrees which
are merged to build the class hierarchy for the entire binary.
4.7 Handling Template Classes
Binaries generated by both GCC and Clang contain sepa-
rate VTables for each template implementation in the binary,
so is the ground truth obtained using GCC’s -fdump-class-
hierarchy. All the compiler-based defenses targeted in this
work modify either GCC or Clang, therefore they also treat
template classes similarly. Since our ground truth matches
the binaries being analyzed, the presence of template classes
does not affect the precision recorded.
4.8 Graph Similarity Measure
To show the effectiveness of our approach, we need to quan-
tify the similarity of the class inheritance recovered from
hardened binaries with the ground truth. This problem can
be reduced to a graph matching problem. Classes in the hi-
erarchy are represented as nodes, while relationships among
them are represented as edges. GEDEVO [14] is an evolu-
tionary algorithm which uses Graph Edit Distance (GED) as
optimization model for ﬁnding the best similarity between
two graphs. GEDEVO produces high quality result even on
large graphs, this makes it appropriate for this work since our
evaluation set includes large programs like Spidermonkey.
GED is a general model for solving graph matching problem,
it is deﬁned as the minimal amount of modiﬁcation needed a
in graph G1 to make it isomorphic to graph G2 [2, 14].
For our evaluation, we modeled class inheritance as a di-
rected graph containing pairs of (baseClass, derivedClass)
interaction networks. Considering two graphs G1 = (V1,E1)
and G2 = (V2,E2) and a one-to-one mapping f between nodes
V1 and V2. The GED between G1 and G2 induced by mapping
f is as follows:
GED f (G1,G2) = | {(u,v) ∈ E1: ( f (u), f (v)) /∈ E2}(cid:83) {(u(cid:48),
v(cid:48)) ∈ E2: ( f (cid:48)(u(cid:48)), f (cid:48)(v(cid:48))) /∈ E1} |
By deﬁnition, GED f (G1,G2) counts inserted or deleted
edges induced by the mapping f, which can be easily ex-
tended to depict node/edge dissimilarities. The raw GED for a
mapping is calculated from the number of removed and added
edges required to transform one graph into the other graph.
The raw counts are summed up and normalized, producing
the actual GED score.
Even though GEDEVO is dedicated to biological network,
it internally utilizes GED for optimization which makes it
applicable to general graph comparison problems outside
computational biology.
Result Interpretation. GED score ranges from 0 to 1, a value
close to 0 shows high similarity while a value close to 1
shows high dissimilarity. GEDEVO also computes the Edge
Correctness (EC) of found edges in the two graphs. An EC
value of 100% is the highest and it is possible when two
graphs are either isomorphic or sub-isomorphic. GED score
and Edge correctness represent the precision of recovery and
accuracy of inheritance direction respectively.
5 Evaluation
We evaluate our solution on both executables and libraries.
Our test suite include SPEC CPU 2006 C++ benchmarks,
Spidermonkey, and four shared libraries — CplusplusThread,
Attic-c-hdfs-client, LibEbml, and LibMatroska. Our choice
24          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Associationof SPEC CPU programs is based on the programs evaluated
by the C++ defenses.
Spidermonkey and the libraries are chosen to show the
impact of our solution on real world complex applications.
For binaries compiled with FCFI and OVT we consider only
polymorphic classes while for CaVer and TypeSan we con-
sider both polymorphic and non polymorphic classes. In our
evaluation, we answer the following questions:
1. How accurate and precise are the class hierarchies ex-
tracted from binaries hardened with compiler-based de-
fenses?
2. How much design information do compiler-based de-
fenses embed within binaries?
3. Can we recover a more complete class hierarchy from
binaries hardened with modern C++ defenses, than state
of the art binary analysis tools?
All evaluation was performed on a system with Intel Core
i7-4790 CPU @ 3.60GHz x 8 and 32GiB of Memory, running
Ubuntu 14.04 LTS with Linux Kernel 4.10.0. All binaries
where compiled using GCC under O0 optimization.
Defenses Evaluated. FCFI, Shrinkwrap and SafeDispatch
use similar techniques, therefore, we chose FCFI to represent
the group. Also, Hextype is only an improvement over CaVer,
therefore, we chose CaVer for this evaluation. We were unable
to evaluate VTrust and VIP because of the unavailability of
their source code.
5.1 Recovery for Polymorphic Classes
Table 2 shows the recovery rate, GED score and Edge cor-
rectness of polymorphic classes compared with the ground
truth. We constructed the ground truth by using -fdump-class-
hierarchy option of g++ which dumps VTables, their layout
and inheritance relationship during compilation.
On the average, we obtained a GED score of 0.08, 0.21,
0.09 and 0.35 and Edge correctness of 98.26%, 89.97%,
96.31% and 81.14% for FCFI, OVT, TypeSan and CaVer re-
spectively. The ground truth graph for Namd has four polymor-
phic classes with only two edges. Classes PairCompute and
SelfCompute have ComputeNonbondedUtil as their base
class. We were unable to recover ComputeNonbondedUtil
from the Namd binary compiled with OVT this is the reason
its GED score is 1 and its Edge correctness 0%. Also, we
could not compile Spidermonkey with TypeSan and DealII,
Libebml and Libmatroska with OVT. The recovery from bi-
naries compiled with CaVer are not as precise and accurate
as the other defenses, this is because CaVer has been shown
to have low coverage [12] [16]. Not all objects are protected,
hence fewer design information is embeded in the binary.
Also, the GED score for Spidermonkey compiled with FCFI
is not as close to zero as other programs, this is because FCFI
omits design information for abstract classes.
5.2 Recovery for Both Polymorphic and Non-
polymorphic Classes
CaVer and TypeSan protect both polymorphic and non-
polymorphic classes, hence we evaluate the precision and
accuracy of our recovery for all classes in the programs com-
piled with these defenses. TypeSan represents class names
with hash values in the binary, while CaVer uses actual names.
To construct the ground truth for TypeSan, we modiﬁed its
source code to output the mapping (className, hashValue)
during compilation. The results tabulated in Table 3 show the
number of THTables recovered from TypeSan and CaVer.
The column "# Keys found" represents the total number
of keys found in all THTables, however, some keys do not
have a speciﬁc THTable in the binary, they are only present
within other THTables. For TypeSan, all keys found have a
corresponding THTable, but that is not the case for CaVer.
CaVer protects only a subset of objects created at runtime,
as a result, it does not dump metadata for those unprotected
objects in the binary.
5.3 Class Hierarchy Tree Recoverable from
the Amount of Information Embedded
Table 4 shows the number of unique classes whose metadata
is present in the binary. The aim of this evaluation is to show
that even though some defenses do not embed a correspond-
ing metadata for every class in the binary, the ones present are
enough to build an accurate class hierarchy. Unlike FCFI and
TypeSan, CaVer and OVT embed metadata for classes depend-
ing on their use in the program. CaVer embeds a THTable
for a class only if at least one instance of that class is created.
Since we rely on callsite for OVT, the metadata of a class is
made available only if an indirect call is made using an object
of that class. However, the absence of metadata for certain
classes will have no impact on our recovery as long as their
keys (for CaVer) or VTables (for OVT) are found in the binary.
For binaries compiled with CaVer, the THTables of classes
with no base class are not necessary to build class hierarchy
since they contain just one key and name. They do not give
any information about inheritance. For binaries compiled with
OVT, callsites for classes with no derived class are also not
necessary since their range is 1. We refer to such classes as
leaf nodes in Table 4. Only the non-leaf nodes are important
for reconstructing class hierarchy. On the average we found
callsites for 66% of non-leaf nodes, except for Namd whose
only non-leaf node has no corresponding callsite. Note that
we only consider polymorphic classes for OVT.
5.4 Comparison Against Marx
Marx [20] is a state-of-the-art reverse engineering tool for
class hierarchy recovery which infers relationship among
classes by heuristics. VTables are taken as classes since they
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 25Table 2: Evaluation result for precision and accuracy of class hierarchy recovered from FCFI, OVT, TypeSan(TS) and CaVer(CV).
GT is the Ground Truth obtained by using GCC’s -fdump-class-hierarchy option. VTS&G is VTable Scanning + Grouping, i.e
the total number of VTables recovered simply by using VTable Scanning and Grouping without relying on information embedded
by the defenses. OVT did not compile DealII.
Programs
Spidermonkey
Xalanc
Soplex
Povray
Omnetpp
dealII
Namd
CplusplusThread
GT(polymorphic)
807
975
29
32
112
874
4
11
Total Recovery
FCFI OVT
780
795
673
958
29
29
26
28
105
110
–
717
0
4
11
9
TS
-
913
29
28
111
687
4
11
CV VTS&G FCFI OVT
521
0.35
0.23
531
22
0.07
0.33
14
110
0.21
98
4
8
805
857
30
30
107
746
3
11
0.09
–
1
0.33
0.02
0.05
0.1
0
0.12
0
0
GED Score
TS
-
Edge Correctness
FCFI OVT
76.98
88.34
94.66
100
100
95.24
91.67
100
100
81.25
97.70
100
100
–
0
100
TS
-
86.76
95.45
100
97.06
94.91
100
100
CV
68.80
68.94
94.12
100
70.59
46.70
100
100
CV
0.38
0.43
0.18
0.45
0.32
0.86
0
0.2
0.15
0.13
0.11
0.1
0.16
0
0
Table 3: Evaluation result for the number of THTables and unique classes extracted from TypeSan(TS) and CaVer(CV) binaries
for both polymorphic and non polymorphic classes. GT is the Ground truth obtained from the (hash, name) mapping which
TypeSan and CaVer generate during compilation. Keys found is the number of unique keys found through the THTables. THTables
recovered is the number of THTables found. TypeSan did not compile Attic-c-hdfs-client. FN and FP represent false negatives
and positives in THTable recovery respectively.
Programs
Xalanc
Deal
Omnetpp
Soplex
Povray
Namd
CplusplusThread
Attic-c-hdfs-client
LibEbml
LibMatroska
TS
3075
2332
244
115
249
21
26
–
92
286
GT
Keys found
CV
1591
448
178
54
33
10
14
651
38
293
TS
3162
2366
236
123
211
29
23
–
85
303
CV
1562
437
171
50
32
10
14
544
35
288
THTables recovered
TS
3162
2366
236
123
211
29
23
–
85
303
CV
1013
263