# 【漏洞分析】搞事的NTP----CVE-2016-7434漏洞分析
|
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
****
****
**作者：**[ **k0pwn_ko**
****](http://bobao.360.cn/member/contribute?uid=1353169030)
**预估稿费：700RMB（不服你也来投稿啊！）**
********投稿方式：发送邮件至**[ **linwei#360.cn**](mailto:PI:EMAIL) **，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿****
**前言**
最近这一段时间，NTP又搞事情了，很多安全媒体也进行了报道，很多NTP漏洞都很有意思，NTP是一个网络时间协议，用来同步各个计算机之间的时间，有一些DDoS就是利用NTP放大攻击来进行的。同样，这段时间连续爆出了多个NTP的拒绝服务漏洞，通过这种漏洞，可以造成NTP服务，甚至NTP服务器拒绝服务，之前Freebuf上面有过一篇关于Windows
NTP拒绝服务漏洞的报道。
讲的是Windows下的一个NTP拒绝服务漏洞CVE-2016-9311，后来我在CNVD也看到了一篇公告，关于NTP拒绝服务漏洞的。
而我选取了其中一个Linux下的NTP拒绝服务漏洞CVE-2016-7434来进行完整分析，这个漏洞在复现的过程中发现不需要进行任何设置即可达到漏洞利用的效果，当然了，在ntp.org11月发布的最新版4.2.8p9中修复了这个漏洞，而4.2.8p8则受此漏洞影响。
**NTP协议浅析与CVE-2016-7434**
关于客户端和NTP服务器之间的NTP协议交互，同步时间的过程我不再详细说明了，用一副图可以简要说明时间同步的过程，在这个过程中，数据采取NTP协议传输，而与服务器交互的端口是123端口。
我们下载NTP 4.2.8p8，通过tar解压之后，用configure、make、make install进行安装，安装后，通过./ntpd -n -c
[ntp.conf path]的方法运行ntpd，很多Linux系统自带NTP，需要切换到NTPD目录下执行该目录下的NTP才能确保版本是有问题的版本。
我们来看一下NTP协议格式。
关于NTP协议每一个字段的含义，网上都有相关解释，这里我就不再赘述，在这中间，涉及到一个Mode，它代表着工作模式，这里值得一提的是，在以前的NTP协议中，通常用Mode7的monlist特性来响应NTP请求，但是由于monlist存在漏洞，可以利用这个漏洞来进行NTP放大攻击，也就是DDoS，后来monlist特性被禁止了，被改成Mode6的mrulist特性，以此避免NTP放大攻击，而这次漏洞，就是由于mrulist导致的。
我们通过CVE-2016-7434的Payload发送一个畸形数据包，同时抓包分析数据。
可以看到，第一个字节是16，转换成二进制就是00010110，根据之前对于NTP协议格式的分析，第0、1比特代表的是Leap
Indicator，当这个值为11的时候是告警状态，代表时间同步出现问题，其他则不处理，这里是00；随后第2、3、4比特是010，代表的是版本，之后的5、6、7比特110代表的是Mode，这里也就是6，代表着mrulist特性处理。
**CVE-2016-7434漏洞分析**
我们在Linux下用gdb attach的方法附加ntpd，发送payload之后，gdb捕获到ntpd崩溃。
通过bt命令，来回溯一下崩溃前的堆栈调用情况
    __strlen_sse2_bsf () at ../sysdeps/i386/i686/multiarch/strlen-sse2-bsf.S:50
    50../sysdeps/i386/i686/multiarch/strlen-sse2-bsf.S: No such file or directory.
    (gdb) bt
    #0  __strlen_sse2_bsf () at ../sysdeps/i386/i686/multiarch/strlen-sse2-bsf.S:50
    #1  0x080948f0 in estrdup_impl (str=0x0) at emalloc.c:128
    #2  0x0805f9b3 in read_mru_list (rbufp=0x89d3dd8, restrict_mask=0)
        at ntp_control.c:4041
    #3  0x0806a694 in receive (rbufp=0x89d3dd8) at ntp_proto.c:659
    #4  0x080598f7 in ntpdmain (argc=0, argv=0xbff16c94) at ntpd.c:1329
    #5  0x0804af9b in main (argc=4, argv=0xbff16c84) at ntpd.c:392
可以看到，在#1位置调用了emalloc.c中的estrdup_impl，参数str的值是0x0，直接看一下emalloc.c中对应部分的代码。
    char *
    estrdup_impl(
    const char *str
    #ifdef EREALLOC_CALLSITE
       ,
    const char *file,
    intline
    #endif
    )
    {
    char *copy;
    size_tbytes;
    bytes = strlen(str) + 1;
这里假如str的值是0x0的话，在strlen的部分会读取0x0地址位置存放的值长度，这个位置是不可读的。
    gdb-peda$ x/10x 0x0
    0x0: Cannot access memory at address 0x0
因此造成了拒绝服务的发生，在estrdup_impl调用之前，调用到了read_mru_list，这个函数就是处理mrulist特性的函数，而在这个函数之前调用了ntpdmain和receive函数用于接收。
来看一下read_mru_list处理mrulist特性的函数内容，在ntp_control.c中第4034行。
    while (NULL != (v = ctl_getitem(in_parms, &val)) &&
           !(EOV & v->flags)) {
    int si;
    if (!strcmp(nonce_text, v->text)) {
    if (NULL != pnonce)
    free(pnonce);
    pnonce = estrdup(val);
这里在pnonce变量赋值位置调用了estrdup，也就是发生问题的函数调用，那么val的值就是0x0，在跟踪read_mru_list中，发现在函数入口处声明了val变量，之后在while循环入口，调用了ctl_getitem函数，其中val作为参数，之后就是estrdup的函数调用，也就是说，ctl_getitem函数中会对val变量进行赋值。
来看一下ctl_getitem的函数内容。
    /*
     * ctl_getitem - get the next data item from the incoming packet
     */
    static const struct ctl_var *
    ctl_getitem(
    const struct ctl_var *var_list,
    char **data
    )
ctl_getitem的函数内容就是从数据包中获取下一个数据块内容，其中，data值就是我们关心的val值，下面我们动态跟踪一下val值获取的过程。首先，在read_mru_list处理mrulist特性的函数逻辑入口下断点跟踪。
在函数入口处，首先对可能在数据包中获取的块的名称进行赋值。
    const charnonce_text[] ="nonce";
    const charfrags_text[] ="frags";
    const charlimit_text[] ="limit";
    const charmincount_text[] ="mincount";
    const charresall_text[] ="resall";
    const charresany_text[] ="resany";
    const charmaxlstint_text[] ="maxlstint";
    const charladdr_text[] ="laddr";
    const charresaxx_fmt[] ="0x%hx";
单步跟踪，可以看到调用了set_var进行一系列赋值
    gdb-peda$ n
    Program received signal SIGALRM, Alarm clock.
     [----------------------------------registers-----------------------------------]
    EAX: 0xbfade1e0 --> 0x99e98d0 --> 0x0 
    EBX: 0xbfade310 --> 0xa ('n')
    ECX: 0x6 
    EDX: 0xbfade1ee ("frags")
    ESI: 0x0 
    EDI: 0x74 ('t')
    EBP: 0xbfade568 --> 0x99e6ddc --> 0x10920002 
    ESP: 0xbfade190 --> 0x0 
    EIP: 0x805f765 (: call   0x805ed90 )
    EFLAGS: 0x282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
    [-------------------------------------code-------------------------------------]
       0x805f753 : lea    eax,[ebp-0x388]
       0x805f759 : mov    ecx,0x6
       0x805f75e : mov    DWORD PTR [esp],0x0
    => 0x805f765 : call   0x805ed90 
       0x805f76a : lea    edx,[ebp-0x374]
       0x805f770 : lea    eax,[ebp-0x388]
       0x805f776 : mov    ecx,0x6
       0x805f77b : mov    DWORD PTR [esp],0x0
    Breakpoint 3, 0x0805f765 in set_var (def=0x0, size=0x6, 
        data=0xbfade1ee "frags", kv=0xbfade1e0) at ntp_control.c:4014
这里赋值的内容是frags，其实这里调用了很多set_var，主要是对in_parms进行初始化。
    /*
     * fill in_parms var list with all possible input parameters.
     */
    in_parms = NULL;
    set_var(&in_parms, nonce_text, sizeof(nonce_text), 0);
    set_var(&in_parms, frags_text, sizeof(frags_text), 0);
    set_var(&in_parms, limit_text, sizeof(limit_text), 0);
    set_var(&in_parms, mincount_text, sizeof(mincount_text), 0);
    set_var(&in_parms, resall_text, sizeof(resall_text), 0);
    set_var(&in_parms, resany_text, sizeof(resany_text), 0);
    set_var(&in_parms, maxlstint_text, sizeof(maxlstint_text), 0);
    set_var(&in_parms, laddr_text, sizeof(laddr_text), 0);
初始化之后，会开始处理数据包中Data部分的数据，其中会分别获取每一个小块。
    gdb-peda$ n
    Program received signal SIGALRM, Alarm clock.
     [----------------------------------registers-----------------------------------]
    EAX: 0x99ea4e0 --> 0x0 
    EBX: 0xbfade310 ("addr.15")
    ECX: 0x0 
    EDX: 0xbfade1e4 --> 0x0 
    ESI: 0x10 
    EDI: 0xbfade550 --> 0x8058ff0 (:mov    eax,DWORD PTR [esp+0x4])
    EBP: 0xbfade568 --> 0x99e6ddc --> 0x10920002 
    ESP: 0xbfade19c --> 0x805f961 (:test   eax,eax)
    EIP: 0x805a440 (:push   ebp)
    EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
    [-------------------------------------code-------------------------------------]
       0x805a43b:xchg   ax,ax
       0x805a43d:xchg   ax,ax
       0x805a43f:nop
    => 0x805a440 :push   ebp
       0x805a441 :push   edi
       0x805a442 :push   esi
       0x805a443 :push   ebx
       0x805a444 :sub    esp,0x1c
    Breakpoint 6, ctl_getitem (var_list=0x99ea4e0, 
        data=data@entry=0xbfade1e4) at ntp_control.c:3083
这里data就是in_parms的值，而var_list就是val的值，来看一下函数进入时值。
    gdb-peda$ x/10s 0xbfade1e4
    0xbfade1e4: ""
    0xbfade1e5: ""
    0xbfade1e6: ""
    0xbfade1e7: ""
    0xbfade1e8: "nonce"
    0xbfade1ee: "frags"
    0xbfade1f4: "limit"