title:Side-Channel Attacks on BLISS Lattice-Based Signatures: Exploiting
Branch Tracing against strongSwan and Electromagnetic Emanations in
Microcontrollers
author:Thomas Espitau and
Pierre-Alain Fouque and
Benoît G&apos;erard and
Mehdi Tibouchi
Side-Channel Attacks on BLISS Lattice-Based Signatures
Exploiting Branch Tracing against strongSwan and Electromagnetic Emanations in Microcontrollers
Thomas Espitau
UPMC
France
PI:EMAIL
Pierre-Alain Fouque
Université de Rennes I
France
PI:EMAIL
Benoît Gérard
DGA.MI
France
PI:EMAIL
Mehdi Tibouchi
NTT Corporation
Japan
PI:EMAIL
ABSTRACT
In this paper, we investigate the security of the BLISS lattice-based
signature scheme, one of the most promising candidates for post-
quantum-secure signatures, against side-channel attacks. Several
works have been devoted to its efficient implementation on various
platforms, from desktop CPUs to microcontrollers and FPGAs, and
more recent papers have also considered its security against certain
types of physical attacks, notably fault injection and cache attacks.
We turn to more traditional side-channel analysis, and describe
several attacks that can yield a full key recovery.
We first identify a serious source of leakage in the rejection
sampling algorithm used during signature generation. Existing
implementations of that rejection sampling step, which is essential
for security, actually leak the “relative norm” of the secret key. We
show how an extension of an algorithm due to Howgrave-Graham
and Szydlo can be used to recover the key from that relative norm,
at least when the absolute norm is easy to factor (which happens for
a significant fraction of secret keys). We describe how this leakage
can be exploited in practice both on an embedded device (an 8-bit
AVR microcontroller) using electromagnetic analysis (EMA), and a
desktop computer (recent Intel CPU running Linux) using branch
tracing. The latter attack has been mounted against the open source
VPN software strongSwan.
We also show that other parts of the BLISS signing algorithm
can leak secrets not just for a subset of secret keys, but for 100%
of them. The BLISS Gaussian sampling algorithm in strongSwan
is intrinsically variable time. This would be hard to exploit using
a noisy source of leakage like EMA, but branch tracing allows to
recover the entire randomness and hence the key: we show that a
single execution of the strongSwan signature algorithm is actually
sufficient for full key recovery. We also describe a more traditional
side-channel attack on the sparse polynomial multiplications car-
ried out in BLISS: classically, multiplications can be attacked using
DPA; however, our target 8-bit AVR target implementation uses re-
peated shifted additions instead. Surprisingly, we manage to obtain
a full key recovery in that setting using integer linear programming
from a single EMA trace.
KEYWORDS
side-channel analysis; digital signatures; postquantum cryptogra-
phy; lattices; BLISS; EMA; branch tracing; number theory
1 INTRODUCTION
As possibly the most promising candidate to replace classical RSA
and ECC-based cryptography in the postquantum setting, lattice-
based cryptography has been the subject of increasing interest in
recent years from an implementation standpoint, including on con-
strained and embedded devices. In particular, in the last five years
or so, numerous papers have been devoted to the implementation of
lattice-based signatures schemes on various such platforms, such as
FPGA and microcontrollers [11, 28, 33, 34, 45, 46]. Concomitantly,
industry-baked open-source librairies implementing lattice-based
schemes have been developed such as Microsoft’s Lattice Cryptog-
raphy Library [41], Google Chrome Canary’s TLS 1.2 [8] or even
OpenSSL 1.0.2g [47], implementing Peikert’s R-LWE key exchange.
This has provided a better understanding of how practical these
schemes are at concrete security levels.
More recently, researchers have started investigating the secu-
rity of these implementations against physical attacks. In particular,
Bruinderink et al. [26] have demonstrated a cache attack against
BLISS at CHES 2016, and two papers by Bindel et al. [6] and Es-
pitau et al. in [20] at FDTC 2016 and SAC 2016 have presented
fault attacks against BLISS and several other lattice-based signa-
ture schemes. Those attacks mainly rely on the idea that lattice
signatures contain some “noise”, and learning partial information
about that noise (either through cache side-channels or because
fault injection allows to fix some of it to a known value) makes it
possible to reduce the dimension of the underlying lattice problems,
and hence the security of the schemes, often allowing to recover
the secret key.
Lattice-based signatures and BLISS. In the early days of lattice-
based cryptography, several signature schemes with heuristic secu-
rity were proposed, most notably GGH [25] and NTRUSign [31],
but despite several attempts to patch them, they turned out to be
insecure: it was found that the distribution of generated signatures
leaks statistical information about the secret key, which can be
exploited to break these schemes and their variants [22, 24, 42].
The most common approach to obtain efficient, provably secure
lattice-based signatures in the random oracle model is the “Fiat–
Shamir with aborts” paradigm introduced by Lyubashevsky [38]
(it coexists with the GPV hash-and-sign paradigm relying on lat-
tice trapdoors [23], which has some theoretical benefits compared
to Fiat–Shamir, but tends to result in less efficient implementa-
tions [16]). Lyubashevsky’s approach is an extension of the usual
Fiat–Shamir transformation which uses rejection sampling to make
sure that generated signatures have a distribution independent
of the secret key, and avoid the statistical pitfalls of schemes like
NTRUSign. More precisely, the underlying identification protocol
achieves its honest-verifier zero-knowledge property by aborting
some of the time, and signatures are produced by re-running that
protocol with random challenges until it succeeds.
Several instantiations of this paradigm have been proposed [4, 28,
32, 39], targeting various output distributions for signatures, but the
most popular among them is certainly the BLISS signature scheme
proposed by Ducas et al. [14]. It is possibly the most efficient lattice-
based signature scheme so far, boasting performance comparable
to common implementations of RSA and ECC-based signatures,
such as the one in OpenSSL. Signature and public-key size are a few
times larger than RSA (and about one order of magnitude bigger
than ECC); signature generation is comparable to ECC and beats
RSA by an order of magnitude; and signature verification is similar
to RSA and faster than ECC by an order of magnitude.
This efficiency is achieved in particular through the use of Gauss-
ian noise, and a target distribution for signature that has a bimodal
Gaussian shape. This makes the rejection sampling step for BLISS
somewhat tricky to implement, particularly on platforms where
evaluating transcendental functions to a high precision is impracti-
cal. However, the authors of [14] proposed an efficient technique to
carry out this rejection sampling based on iterated Bernoulli trials.
This technique is used, in particular, in the embedded implementa-
tions of BLISS described in [33, 46].
Our contributions. Our goal is to look at the security of BLISS
against side-channel analysis. Most of the attacks we describe apply
in particular to the original proof-of-concept implementation of
Ducas et al. [15], but we specifically target two implementations
of a less academic nature: the 8-bit AVR microcontroller imple-
mentation of Pöppelmann et al. [46], as well as the production-
grade implementation included in the open source VPN software
strongSwan [51].
The first source of side-channel leakage that we consider is
the clever algorithm proposed in the original BLISS paper [14] to
perform the rejection sampling, which is intervened in a crucial
way in those embedded implementations. To achieve the correct
output distribution, the signature generation algorithm has to be
restarted with probability:
(cid:32)
(cid:44)(cid:42)(cid:44)M exp
1
− ∥Sc∥2
2σ
2
cosh
(cid:33)
(cid:32)⟨z, Sc⟩
2
σ
(cid:33)(cid:43)(cid:45),
where (z, c) is the signature generated so far, S the secret key, σ the
Gaussian standard deviation and M a scaling factor ensuring that
this probability is always at most 1.
It turns out that the clever algorithm for rejection sampling,
based on iterated Bernoulli trials, traverses the bits of the two
values ⟨z, Sc⟩ and K − ∥Sc∥2 (where K is defined such that M =
(cid:17)) in much the same way as a square-and-multiply
exp(cid:16)
algorithm traverses the bits of its exponent: one can basically read
K/(2σ
2
)
those bits on a power or electromagnetic trace! This makes it possi-
ble to mount a simple power analysis (SPA) or simple electromag-
netic analysis (SEMA) attack on the rejection sampling using either
of these values. Similarly, on a desktop platform using a recent Intel
CPU, one can similarly read out that sequence of bits from the list
of branching instructions executed within the corresponding func-
tion, which is recorded in the CPU branch trace store. On Linux, this
is accessible using perf_events, which are often available to all
userland processes with the same user ID as the program running
the BLISS computation (in our case, strongSwan).
The attack using the scalar product is conceptually quite simple:
given the value ⟨z, Sc⟩ for many known signatures (z, c), one can
recover the secret key S using basic linear algebra. However, in real
BLISS signatures, the component z is not output in full, but in a
shorter, compressed form which loses part of the information. This
makes the attack inapplicable in practice.
On the other hand, in real BLISS implementations, one is actually
able to retrieve the value ∥Sc∥2 using SPA/SEMA, and collecting
sufficiently many such values allows us to compute the relative
norms s1 · ¯s1 and s2 · ¯s2 of the two cyclotomic integers s1, s2 form-
ing the secret key S. Recovering the secret key from those relative
norms is a problem analogous to the one addressed in a 2004 paper
of Howgrave-Graham and Szydlo [35], except for the fact that the
cyclotomic field Q(ζm ) of interest in our case has a conductor m
equal to a power of two, instead of an odd prime as in the original
paper. We are able to extend the Howgrave-Graham–Szydlo algo-
rithm to this power-of-two conductor case, and use it to complete
the key recovery attack.
There is a technical hurdle to overcome, however. Like the origi-
nal Howgrave-Graham–Szydlo algorithm, our method is only ef-
ficient when one knows the factorization of the absolute norm of
cyclotomic integer of interest. But for BLISS parameters, this ab-
solute norm is between 1000 and 2000-bit long, so it is not easy
to factor academically in general. However, for a significant frac-
tion of all keys, the absolute norm is prime, or at least the product
of a large prime with very small prime powers that can be fac-
tored out using trial division; and for those “weak” keys (forming
over 6% of all keys for typical BLISS parameters) our generalized
Howgrave-Graham–Szydlo algorithm runs in full polynomial time.
In addition, we also consider two other sources of side-channel
leakage: the Gaussian sampling algorithm used to generate the
random masks used in BLISS signatures on the one hand, and the
polynomial multiplication s1 · c between the secret key and the
public variable hash value c on the other hand.
Regarding the rejection sampling, the original BLISS paper pro-
poses several techniques to carry it out, and the strongSwan imple-
mentation chooses one which intrinsically runs in variable time.
Like the rejection sampling, it is based on repeated sampling of
Bernoulli trials. It consists of an a priori unbounded number of
iterations, with a complex collection of functions calling one an-
other hundreds of times, and it is carried out to generate each of the
512 coefficients of the random Gaussian polynomial y1. The power
or EM trace of the execution of this algorithm on an embedded
device would likely look gibberish; however, branch tracing allows
to take full advantage of it: since branch tracing records the full list
of branching instructions carried out during this computation, it
2
can be used to reconstruct y1 entirely. That polynomial, together
with the signature elements c and z1 = y + (−1)b s1 · c, is enough to
recover the entire secret key (up to sign, which is enough): branch
tracing of a single execution of the signature generation algorithm
is sufficient for a complete break of all keys!
As for the computation of the product s1 · c, it is relatively clas-
sical that such a multiplication, when implemented in a naive way,
can be attacked using differential power analysis (DPA), correlation
power analysis (CPA) and related techniques. The implementation
of the multiplication in our 8-bit AVR target [46], however, takes
advantage of the special form of c (which is a very sparse polyno-
mial with coefficients in {0, 1}). The product is simply computed as
a sum of signed shifts of the secret key. As a result, a somewhat dif-
ferent attack approach is required. Surprisingly, using integer linear
programming techniques, we describe a method for recovering the
secret key using a single power or EM trace of this multiplication
algorithm. This not only breaks the unprotected implementation
described in [46], but also defeats various blinding countermea-
sures that could be designed to protect it, such as the one recently
proposed by Saarinen [49].
Finally, we conclude the paper by discussing limitations of our
attacks and possible countermeasures. These attacks illustrate a
major problem cryptography engineers often face, namely the diffi-
culty of quantifying the threat due to a leakage. A security aware
programmer would surely have noticed that the norm was eas-
ily readable due to non-constant execution time. But he may also
have thought it was not an exploitable leakage. Our opinion is that
as far as side-channels are concerned, simpler is often better. In
that spirit, we consider the possible merits of using a lattice-based
signature scheme with a simpler mathematical structure, such as
the “ancestor” of BLISS due to Güneysu, Lyubashevsky and Pöp-
pelmann [28]. Our analysis suggests that such a scheme may be
preferable to BLISS when physical attacks are a concern, not only
because its simpler structure thwarts some of the attacks described
in this paper, but also because side-channel countermeasures for
it seem easier to design and implement (keeping in mind that an
unprotected implementation is unlikely to achieve good levels of
side-channel security in any case).
2 DESCRIPTION OF THE BLISS SCHEME
Notation. For any integer q, the ring Zq is represented by the
integers in [−q/2, q/2) ∩ Z. Vectors are considered as column vec-
tors and will be written in bold lower case letters and matrices with
2 Euclidean norm,
upper case letters. By default, we will use the L
2
i )
i v
1/2 and L∞-norm as ∥v∥∞ = maxi |vi|.
∥v∥2 = ((cid:80)
Description of BLISS. The BLISS signature scheme [14] is pos-
sibly the most efficient lattice-based signature scheme so far. It
has been implemented in both software [15] and hardware [45],
and boasts performance numbers comparable to classical factor-
ing and discrete-logarithm based schemes. BLISS can be seen as
a ring-based optimization of the earlier lattice-based scheme of
Lyubashevsky [39], sharing the same “Fiat–Shamir with aborts”
structure [38]. One can give a simplified description of the scheme
as follows: the public key is an NTRU-like ratio of the form aq =
s2/s1 mod q, where the signing key polynomials
s1, s2 ∈ R = Z[X]/(X n + 1) are small and sparse. To sign a message
3
Figure 1: Description of the BLISS signature algorithm. The
random oracle H takes its values in the set of polynomials in
R with 0/1 coefficients and Hamming weight exactly κ, for
some small constant κ.
Z,σ
Z,σ
1: function Sign(µ, pk = a1, sk = S)
2:
3:
4:
5:
6:
7:
8:
, y2 ← Dn
y1 ← Dn
u = ζ · a1 · y1 + y2 mod 2q
c ← H (⌊u⌉d mod p, µ )
choose a random bit b
z1 ← y1 + (−1)b s1c
z2 ← y2 + (−1)b s2c
rejection sampling: restart to step 2 except with probability
M exp(−∥Sc∥2
/(2σ 2
z†
2 ← (⌊u⌉d − ⌊u − z2⌉d ) mod p
return (z1, z†
)) cosh(⟨z, Sc⟩/σ 2
1/
(cid:16)
(cid:17)
)
2, c)
9:
10:
11: end function
Figure 2: Sampling algorithms
the distributions
Bexp(−x /f ) and B1/ cosh(x /f ). The values ci = 2i /f are pre-
computed, and the xi’s are the bits in the binary expansion
for
of x =(cid:80)ℓ−1