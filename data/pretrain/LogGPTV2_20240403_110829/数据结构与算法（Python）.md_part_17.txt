.
12. 扩展Listing 2.15的程序来处理带空格的回文序列。比如，I PREFER PI是一个回文序列，因
为如果忽略空格，它向前和向后读是一样的。
13. 为了实现length方法，我们在链表中计算节点的数目。一种代替的方法是链表中的节点的
数目作为附加的数据片段储存在链表表头中。修改无序列表类，包含这个信息并且重新编写length
方法。
14. 实现remove方法，使得当列表中没有相应数据项的时候它能正常运行。
15. 修改列表使它允许重复。有哪些方法将受到这种变化的影响？
16. 实现无序列表类的__str__方法。对于列表而言，什么是一个好的字符串形式的表现？
17. 实现__str__方法，使列表以Python的形式表现出来（用方括号）。
18. 实现无序列表中的其他操作(append, index, pop, insert)。
19. 实现一个无序列表的切片方法。它包含start和stop两个参数，返回一个从start位置开始向
后到stop位置但不包含stop位置的列表的副本。
20. 实现定义在OrderedList里的其他功能。
21. 考虑无序和有序列表之间的关系。有没有可能将有序列表作为无序列表的一个继承，从而更
有效的实现有序表？实现这个继承体系。
22. 实现一个使用链表的栈。
23. 实现一个使用链表的队列。
24. 实现一个使用链表的双端队列。
25. 设计并实现一个实验，使它可以比较Python内置的list和用链表实现的list的性能。
26. 设计并实现一个实验，使它可以比较用Python内置的list实现的栈、队列和用链表实现的
栈、队列的性能。
27. 上述链表的实现被称为单向链表（singly linked list），因为每个节点在序列中有单一的对下
一个节点的引用。另一种代替的实现方式被称为双向链表（doubly linked list）。在此实现中，每个
节点都有对下一个节点的引用（通常称为“后继”next）和对前一个节点的引用（通常称为“前驱”
back）。链表表头同样有两个引用，一个指向链表的第一个节点，一个指向最后一个。用Python实
现这段代码。
28. 实现一个可以有平均值的队列。
4.递归 RECURSION
4.1 目标
了解某些用其它方法难解的问题或许有简单的递归解法
学会如何用递归的方式写程序
理解和运用递归的三大法则
了解递归是迭代（iteration）的一种形式
实现问题的递归描述
了解递归在计算机系统中如何实现
4.2 什么是递归
递归是一种解决问题的方法，它把一个问题分解为越来越小的子问题，直到问题的规模小到
可以被很简单直接解决。通常为了达到分解问题的效果，递归过程中要引入一个调用自身的函数。
乍一看，递归算法并没有什么特别的地方，但是，利用递归我们能够写出极为简明的解决问题的方
法，而且如果不用递归，这些问题将具有很大的编程难度。
4.2.1 计算数字列表的和
我们先从一个简单的问题开始我们的探究，这个问题不需要递归也可以解决。假如你想对一
个数字列表进行求和（例如[1,3,5,7,9]），代码4.1所示的是一个通过迭代函数（for循环）求和的程
序。这个函数用一个变化着的“累加器”变量（theSum）对列表里面所有的数进行累加求和，也就
是从0开始，依次加上列表中的每个数。
代码4.1 迭代求和
def list_sum(num_list):
the_sum = 0
for i in num_list:
the_sum = the_sum + i
return the_sum
print(list_sum([1,3,5,7,9]))
现在，假设我们不能使用while循环或者for循环，那么你会如何对数字列表中的数进行求和
呢？如果你是个数学家，那么你首先想到的也许是：按照定义，加法是一个有两个参数——两个数
字——的函数。为了将数字列表的问题重新定义为对两个参数求和的问题，我们可以利用全括号的
表达式来重新表示列表，就像下面这种形式：
((((1+3)+5)+7)+9)
我们也可以从另一个方向来加入括号：
(1+(3+(5+(7+9))))
我们注意到最内层的括号中是（7+9），这是不需要任何循环或者特殊的结构就能解决的。事
实上，我们可以用以下一系列简化后的式子来计算最终的加和。
那么我们怎样将这个思想转化为Python代码呢？首先让我们从Python列表的角度来重新叙述
这个问题。由于数字列表的和是列表中的第一个元素（numList[0]）和剩下所有的元素
（numList(1:)）之和的和，求和问题可以归纳成以下的式子：
listSum(numList)=first(numList)+listSum(rest(numList))
在这个等式中，first 代表列表中的第一个元素，而rest 代表的是列表中除了第一个元素以外
的其他所有元素。此式很容易在Python 中用代码4.2 表示出来。
def list_sum(num_list):
if len(num_list) == 1:
return num_list[0]
else:
return num_list[0] + list_sum(num_list[1:])
print(list_sum([1,3,5,7,9]))
代码4.2 递归求和
在这个代码中，有一些关键点需要注意。首先，在第二行中，我们检查这个列表中是否只有一
个元素。这个检查非常关键，因为它是函数能结束运行的必要条件。对一个长度为1 的列表来说，
它的和显然只是这个列表中的数，其次，在第五行中，函数调用了自身！这就是我们把后一个计算
程序称为“递归”的原因。递归函数就是一种调用自身的函数。
图4.1 展示了对列表[1,3,5,7,9]求和的一系列递归调用和返回的过程。你可以将这一系列的
递归调用看做一次次简化问题的过程。每次进行递归调用过程就是在解决一个规模更小的问题，当
问题的规模达到最小时结束递归。
图4.1：数字列表求和中的递归调用
当问题的规模缩小到我们可以轻易解决时，我们开始把每个小规模问题的答案连接起来直到解
决最初提出的问题。图4.2 展示了列表求和在一系列递归调用之后的回溯过程，当子列表的和返回
到最顶端的求和问题时，我们就得到了整个问题的答案。
图4.2：数字列表求和递归函数的返回过程
4.2.2 递归三大定律
就像阿西莫夫（l.Asimov）的“机器人三定律”一样，递归算法也要遵循三条重要的定律：
 递归算法必须有个基本结束条件
 递归算法必须改变自己的状态并向基本结束条件演进
 递归算法必须递归地调用自身
让我们来更加细致地了解每一条定律，并看看它们是怎样在“数字列表求和”这个算法中体现
的。首先，基本结束条件是一种可以让算法的递归操作结束的情况。基本的结束条件通常是一个规
模小到可以直接解决的问题。在数字列表求和算法中，基本结束条件是一个长度为1的列表。
为了遵循第二定律，我们必须改变算法的状态，使之向基本结束条件演进。状态的改变意味着
算法中使用的一些数据被改变了。通常情况下，这些代表着我们问题的数据以某种方式变小了。在
数字列表求和算法中，基本的数据结构是一个列表，所以我们应该专注于在列表上下功夫来改变算
法的状态。由于基本结束条件是长度为1的列表，那么向基本结束条件演进的最自然的过程就是缩
短列表的长度。我们在代码2的第五行中可以看到具体的做法：将列表的长度减少1，再调用求和算
法来计算这个更短的列表。
最后一条定律就是算法必须调用自身，这正是”递归“的定义。递归算法对于许多初学者来说是
个难理解的概念。作为一个初学者，你已经看到了递归函数的优越性了吧，因为你可以把一个大问
题不断分解为更小的问题，解决这些小问题只要分别写一些简单的函数就行了。当我们谈论递归的
时候好像我们把自身置入了循环当中了。我们有一个问题需要用一个函数来解决，但是这个函数需
要调用自身来解决问题!但在逻辑上这是完全不循环的，递归的逻辑就是利用优美的程序把问题分解
为更小更简单的子问题来解决的。
在这个章节的剩余部分我们可以看到更多的关于递归算法的例子，在每个例子中我们将关注如
何根据递归三大定律来设计解决问题的方法。
小试牛刀：
Q-15 用listsum 计算数列求和[2,4,6,8,10]要进行多少次递归调用？
A)6 B)5 C)4 D)3
Q-16 假设你要写一个关于计算某个数阶乘的递归算法。fact(n) return n*n-1*n-2…
规定0！=1，什么将会是最合适的基本结束条件？
a)n==0
b)n==1
c)n>=0
d)n 0: