    [!] Emulation Error
    [-] s0  :    0x41414141
    [-] s1  :    0x41414141
    [-] s2  :    0x41414141
    [-] s3  :    0x41414141
    [-] s4  :    0x41414141
    [-] s5  :    0x41414141
    [-] s6  :    0x41414141
    [-] s7  :    0x41414141
    [-] t8  :    0x8
    [-] t9  :    0x0
    [-] k0  :    0x0
    [-] k1  :    0x0
    [-] gp  :    0x43b6d0
    [-] sp  :    0x7ff3c608
    [-] s8  :    0x41414141
    [-] ra  :    0x41414141
    [-] status  :    0x0
    [-] lo  :    0x0
    [-] hi  :    0x0
    [-] badvaddr    :    0x0
    [-] cause   :    0x0
    [-] pc  :    0x41414140
    [-] cp0_config3 :    0x0
    [-] cp0_userlocal   :    0x0
    [+] PC = 0x41414140
    [+] Start      End        Perm.  Path
    unicorn.unicorn.UcError: Invalid memory read (UC_ERR_READ_UNMAPPED)
可以看到，我们触发了该漏洞！该函数正在解析我们的输入，并以某种方式进行了错误的处理，最终将其复制到错误的位置，并覆盖了之前寄存器的值。检查一下。现在我们已经很清楚了`Bug`的位置，需要找到确切的位置。为此，我尝试了不同方法：
  * 调试！可以使用GDB调试二进制文件。当我第一次尝试时，遇到了一些问题，我打开了一个[issue]（
只需要执行以下操作便可调试：
    ...
    ql.debugger = True
    ...
    $ python emulate_hedwigcgi.py
    debugger> Initializing load_address 0x0
    debugger> Listening on 127.0.0.1:9999
我们需要安装`gdb-multiarch`，执行：
    sudo apt-get install gdb-multiarch
并`Attach`到`Qiling`：
    $ gdb-multiarch
    (gdb) set remotetimeout 100
    (gdb) target remote 127.0.0.1:9999
    Remote debugging using 127.0.0.1:9999
    warning: while parsing target description: no element found
    warning: Could not load XML target description; ignoring
    warning: while parsing target description: no element found
    warning: Could not load XML target description; ignoring
    Reading /lib/ld-uClibc.so.0 from remote target...
    warning: Unable to find dynamic linker breakpoint function.
    GDB will be unable to debug shared library initializers
    and track explicitly loaded dynamic code.
    0x004025c0 in _ftext ()
`Qiling`可以很容易的在触发异常之前打印出每条指令，我们可以定义一个打印所有已执行的指令的回调函数。并将此回调`hook`到`sess_get_uid`的开始。
    ...
    # From https://github.com/qilingframework/qiling/blob/master/examples/hello_x8664_linux_disasm.py
    def print_asm(ql, address, size):
        buf = ql.mem.read(address, size)
        for i in md.disasm(buf, address):
            print(":: 0x%x:\t%s\t%s" %(i.address, i.mnemonic, i.op_str))
    ####
    ...
    def  hook_sess_get_uid(ql):
        ql.hook_code(print_asm)
    ql.hook_address(hook_sess_get_uid, SESS_GET_UID)
当有大量的代码执行时，该功能将不起作用，并且不能帮助找到越界写入发生的准确位置。同样可能产生如内存损坏发生在位置`X`，寄存器在位置`Y`被覆盖这样的情况（执行`ret`指令时）。
然后我提出了第二个想法：我决定检查潜在的不安全函数诸如`strcpy`的用法。同样我们可以[`Qiling
hook`](https://docs.qiling.io/en/latest/hijack/#on-enter-interceptor-on-posix-function-with-qlset_api)函数：
    ...
    # Once strcpy is called we'll print the arguments and pass them to the real strcpy
    def strcpy_hook(ql):
        print("dst: %s" % hex(ql.os.function_arg[0]))
        print("src: %s" % ql.mem.string(ql.os.function_arg[1]))
        #Not sure why I have to return 2 to continue with the call
        #to the strcpy function. This was taken from example:
        #hello_mips32el_linux_function_hook.py
        return 2
    ql.set_api('strcpy', strcpy_hook, QL_INTERCEPT.ENTER)
    ...
检查结果
    ** At [sess_get_uid] **
    dst: 0x437898
    src: b'AAAAAAAAAAAAAAAAAA...AAA'
    ...
    [+] PC = 0x41414140
OK，现在我们知道缓冲区的写入位置（`0x437898`），并且调用了`strcpy`。
当我第一次发现这个我很高兴，我认为`strcpy`是造成崩溃的根本原因。但是，如果检查目标地址（0x437898），该地址为堆内地址。
    ...
    [+] 00437000 - 00438000 - rwx    [brk]
    ...
同样，如果我们看一下strcpy在哪里进行了复制数据的操作，就会发现在`sess_get_uid`函数一开始就会调用`sobj_new`函数。这将返回一个指向用`malloc`(堆)分配的内存的指针。
因此，我的疑问点：如果`strcpy`的目的地址是`0x437898`（即堆），并且是由于`PC`指向无效的地址而导致的程序崩溃，这是怎么回事？不知何故，传入的超长字符串必须最终覆盖堆栈中的某些内容，但显然在`strcpy`之后并没有发生这种情况，我不得不调试好几个小时来完全了解发生了什么。
答案是在地址`0x0040c1c0`处调用了`sprintf`函数。该函数接收三个字符串作为参数，如下面的代码片段所示：
    0040c1b4 21 38 40 00     move       a3,v0
    0040c1b8 21 30 40 02     move       a2=>s_/runtime/session_00420140,s2               = "/runtime/session"
    0040c1bc 2c 08 a5 24     addiu      a1=>s_%s/%s/postxml_0042082c,a1,0x82c            = "%s/%s/postxml"
`$a3`寄存器指向缓冲区：
    gef➤  x/s $a3
    0x437898:   "b'", 'A' , "'"
`sprintf`将使用指定的格式和缓冲区来格式化作为参数传递的字符串，更重要的是目的地是栈中的局部变量
    gef➤  x/s $s1
    0x7ff3c1e0: "/runtime/session/b'", 'A' , "'/postxml"
至此，疑惑已经解开。总结：
  1. 发送包含`COOKIE header`的`HTTP POST`请求
  2. `header`必须包含`uid =(BUFFER)`字符串
  3. `strcpy`将复制`（BUFFER）`到堆中而不检查大小
  4. `sprintf`会将我们的输入`uid =(BUFFER)`作为某些字符串格式的一部分，将结果存储在栈中的变量中。如果`(BUFFER)`足够大，它将最终覆盖先前保存的寄存器，包括返回地址。
为了检查最后一点，我在`hedwigcgi_main`函数的返回指令中下了一个断点：
    Breakpoint 1, 0x0040c594 in hedwigcgi_main ()
    ...
    $s0  : 0x41414141 ("AAAA"?)
    $s1  : 0x41414141 ("AAAA"?)
    $s2  : 0x41414141 ("AAAA"?)
    $s3  : 0x41414141 ("AAAA"?)
    $s4  : 0x41414141 ("AAAA"?)
    $s5  : 0x41414141 ("AAAA"?)
    $s6  : 0x41414141 ("AAAA"?)
    $s7  : 0x41414141 ("AAAA"?)
    $t8  : 0x8       
    $t9  : 0x0       
    $k0  : 0x0       
    $k1  : 0x0       
    $s8  : 0x41414141 ("AAAA"?)
    $pc  : 0x0040c594
    $sp  : 0x7ff3c120
    $hi  : 0x0       
    $lo  : 0x0       
    $fir : 0x0       
    $ra  : 0x41414141 ("AAAA"?)
    ...
    →   0x40c594  jr     ra
显然，`sprintf`复制了`（BUFFER）`并覆盖了先前保存的寄存器的值，这样就很容易稳定的代码执行。
### 结论
最后！我们解决了这个问题。我花了很大的精力将各个部分放在一起，并充分了解了`strcpy`是如何导致崩溃的。我上传了在博文中一直使用的`Python`脚本作为参考。你可以在这里找到[它](https://github.com/nahueldsanchez/blogpost_qiling_dlink_1/blob/master/src/emulate_cgibin.py).。在本系列的下一部分中，我将继续研究如何编写可在`Qiling`中使用的漏洞利用程序。
### 参考资料