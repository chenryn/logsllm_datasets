次在各种博客或者书籍上看到过通过两次翻转字符串的解法，于是很快就
串"I am a student.”，则输出”student. a am I"。
的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符
面试题42：翻转单词顺序VS左旋转字符串
少很多不必要的运算，从而提高代码的效率。
我们可以在前一个序列的和的基础上求操作之后的序列的和。这样可以减
的序列相比大部分数字都是一样的，只是增加或者减少了一个数字，因此
用循环求一个连续序列的和，但考虑到每一次操作之后的序列和操作之前
这个题目流传甚广，很多公司都多次拿来作面试题，很多应聘者也多
题目一：输入一个英文句子，翻转句子中单词的顺序，但单词内字符
本题考点：
本题完整的源代码详见41_2_ContinuesSquenceWithSum 项目。
源代码：
在前面的代码中，求连续序列的和应用了一个小技巧。通常我们可以
printf("\n");
测试用例：
移能力的重要指标。
解决第一个问题的思路应用到新的题目上，是面试官考查知识迁
考查知识迁移的能力。应聘者面对第二个问题的时候，能不能把
例子找到规律，解决这个问题就容易多了。
考查思考复杂问题的思维能力。应聘者如果能够通过一两个具体的
边界值测试（连续序列的最小和3）
的连续序列，如4、0)。
功能测试（存在和为s 的连续序列，如9、100 等；不存在和为 s
一名企面试官精讲典型编程题（纪念版）
---
## Page 233
char* ReverseSentence(char *pData)
这种思路的参考代码如下：
数Reverse可以完成这一功能：
中字符的顺序，就得到了"student.a am I"。这正是符合题目要求的输出。
中单词的顺序，连单词内的字符顺序也被翻转了。第二步再翻转每个单词
可以跟面试官解释清楚解题思路：第一步翻转句子中所有的字符。比如翻
while(*pBegin!=
//翻转句子中的每个单词
Reverse(pBegin, pEnd);
//翻转整个句子
pEnd--;
char *pBegin=pData;
while(pBegin (strlen(pStr));
Reverse(pFirstStart,pSecondEnd);
//翻转整个字符串
Reverse(pSecondstart,
//翻转字符串的后面部分
//翻转字符串的前面n个字符
char*
char*
char*
char*pFirstStart=pStr;
pSecondEnd=pStr +nLength-1;
pSecondstart
pFirstEnd
pStr
=pStr+n；
pFirstEnd);
pSecondEnd);
第6章面试中的各项能力221
---
## Page 236
222剑指Offer-
4
模拟一个圆圈。
王。在面试题45“圆圈中最后剩下的数字”中，我们可以用一个环形链表
个数组表示一副牌，用11、12和13分别表示J、Q、K并且用0表示大小
问题，也就是建立模型。比如在面试题44“扑克牌的顺子”中，我们用一
特点综合考虑性能、编程难度等因素之后，选择最合适的数据结构来表达
问题千变万化，而常用的数据结构却只有有限的几种。我们在根据问题的
和丰富的想象力。
除了需要具备扎实的数学基础和编程能力之外，还需要具有敏锐的洞察力
是否能建立数学模型并解决问题。要想顺利解决这种类型的问题，应聘者
表达出来，因此有些面试官喜欢从日常生活中抽取提炼出问题考查应聘者
程序员的工作就是把各种现实问题抽象成数学模型并用计算机的编程语言
抽象建模能力
建模的第一步是选择合理的数据结构来表述问题。实际生产生活中的
计算机只是一种工具，它的作用是用来解决实际生产生活中的问题。
本题完整的源代码详见 42_2_LeftRotateString 项目。
?
考查对字符串的编程能力。
考查知识迁移的能力。当面试的时候遇到第二个问题，而之前我们
功能测试（把长度为n的字符串左旋转0个字符、1个字符、2个
字符串的思路迁移过来，就能很轻易地解决字符串左旋转的问题。
做过“翻转句子中单词的顺序”这个题目，那如果能够把多次翻转
特殊输入测试（字符串的指针为NULL指针）。
字符、n-1个字符、n个字符、n+1个字符)。
一名企面试官精讲典型编程题（纪念版）
---
## Page 237
int g_maxValue = 6;
存到数组第s-n个元素里。基于这种思路，我们可以写出如下代码：
就是最后只剩下一个般子。
数和。分析到这里，我们不难发现这是一种递归的思路，递归结束的条件
子的点数和这一轮单独骰子的点数相加，再和剩下的n-2个般子来计算点
分成两堆，第一堆只有一个，第二堆有n-2个。我们把上一轮那个单独骰
点数和剩下的n-1个骰子来计算点数和。接下来把剩下的n-1个骰子还是
单独的那一个有可能出现从1到6的点数。我们需要计算从1到6的每一种
点数和，可以先把n个骰子分为两堆：第一堆只有一个，另一个有n-1个。
解法一：基于递归求骰子点数，时间效率不够高
然后把每一个点数出现的次数除以6°，就能求出每个点数出现的概率。
列数为6”。要解决这个问题，我们需要先统计出每一个点数出现的次数，
值为6n。另外根据排列组合的知识，我们还知道n个骰子的所有点数的排
应的是1～6之间的一个数字。所以 n个骰子的点数和的最小值为 n，最大
面试题43：n个般子的点数
决问题。
中删除的数字的规律，从而找到一种不需要辅助环形链表的快速方法来解
最后剩下的数字”中，我们经过严密的数学分析之后才能找到每次从圆圈
然而，并不是所有问题的内在规律都是显而易见的。在面试题45“圆圈中
到这个规律之后，我们就可以分别用递归和循环两种不同的方法去写代码。
问题，其本质是求数列 f(n)=f(n-1)+f(n-2)+f(n-3)+f(n-4)+f(n-5)+f(n-6)。找
题中，它内在的规律是斐波那契数列。再比如面试题43“n个骰子的点数"
律，才有可能编程解决问题。例如在本书2.4.2节提到的“青蛙跳台阶”问
我们只有对现实问题进行深入细微的观察分析之后，才能找到模型中的规
我们可以定义一个长度为6n-n+1的数组，和为s的点数出现的次数保
现在我们考虑如何统计每一个点数出现的次数。要想求出 n 个骰子的
打印出s的所有可能的值出现的概率。
玩过麻将的人都知道，骰子一共6个面，每个面上都有一个点数，对
题目：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入
建模的第二步是分析模型中的内在规律，并用编程语言表述这种规律。
第6章面试中的各项能力223
---
## Page 238
224
剑指Offer-
解法二：基于循环求骰子点数，时间性能好
于递归的性能讨论，详见本书2.4.2节。
很多计算是重复的，从而导致当 number变大时性能慢得让人不能接受。关
voidProbability(intoriginal,
void Probability(int number,
void PrintProbability(int number)
可以换一种思路来解决这个问题。我们可以考虑用两个数组来存储骰
上述思路很简洁，实现起来也容易。但由于是基于递归的实现，它有
if（current == 1)
for（inti
delete[] pProbabilities;
inttotal=pow((double)g_maxValue,
Probability(number,
for(int
if（number<1)
lse
for（int
pProbabilities[sum-original]++;
double ratio = (double)pProbabilities[i - number] / total;
pProbabilities[i
return;
pProbabilities
一名企面试官精讲典型编程题（纪念版）
Probability(original, current -1, i + sum, pProbabilities);
=number;
int*
pProbabilities);
i
=new int[maxSum -number+ 1];
i，
<=
number]
int*pProbabilities)
maxSum;
ratio);
maxSum;
int current, int sum,
++i)
++i）
number);
---