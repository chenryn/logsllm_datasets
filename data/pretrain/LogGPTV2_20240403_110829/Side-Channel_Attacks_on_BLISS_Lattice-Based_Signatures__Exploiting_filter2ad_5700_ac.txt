2%
1.5%
B = 5
6%
3%
2%
B = 65537
B = 655373
B = 6553733
7.6%
4%
3.5%
12%
5.6%
4%
13%
7.4%
5%
Table 3: Average running time of the attack for various field sizes n. The BLISS parameters correspond to n = 256 and n = 512.
Field size n
CPU time
Clock cycles
32
0.6 s
≈ 230
64
13 s
≈ 235
128
256
512
21 min.
≈ 241
17h 22 min.
≈ 247
38 days
≈ 253
condition in the samplerBerExp function. Indeed, it looks like the
call to samplerBer will only be executed if the least significant bit
of the intermediate variable x is one. Of course, after compiling and
scrutenizing the ASM code it turns out that it is precisely what the
compiler did. This is an obvious SPA leakage source that may be
easily recovered as we show now.
In Figure 6, we plotted the EM radiations corresponding to a
norm ∥Sc∥2 = 14404. Thus, the Bernoulli exponential sampler is
called using argument 46539 − 14404 = 32135 = 0x7D87 since the
paraM value is 46539 in the (standard) set of parameter used. The
loop on the norm is performed from the least to the most significant
bit thus we expect the serie of bit { 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 ,
1 , 1 , 1 , 1 } to be visible on the trace in Figure 6 what is obviously
the case.
uint8_t samplerBerExp ( uint32_t x){
uint16_t bit =0;
while (x >0) {
if (( x &1) && ! samplerBer ( bit *16) )
return 0;
x >>= 1;
bit ++;
}
return 1;
}
uint8_t samplerBerExpM ( int32_t x){
return samplerBerExp ( paramM -x);
}
Figure 5: Code snippet of the rejection sampling from BLISS
implementation [46].
2
1.5
1
0.5
0
-0.5
-1
-1.5
1
1
1
1
1
1
1
1
1
1
0 0 0 0
0
150000
200000
250000
300000
350000
400000
Figure 6: Electromagnetic measure of BLISS rejection sam-
pling for norm 14404.
6
3.4 Branch tracing attack against strongSwan
Experimental setup. As discussed in the introduction, our other
target is the open source VPN software strongSwan [51], which
includes a production grade implementation of BLISS for use in
the IKEv2 authentication protocol, as well as for the postquantum-
secure signing of X.509 certificates. The architecture of the BLISS
implementation in strongSwan is described in [50].
We attack the latest stable version of strongSwan as of this
writing (5.5.2) when compiled and run on a Linux x86–64 desktop
platform. We ran our experiments on an Intel Core i7-3770 CPU
from the Ivy Bridge family, but they should apply to all Intel CPUs
from the past ten years at least, with very recent architectures like
Sky Lake providing even greater control. We used Linux kernel
version 4.8.0, but the relevant interfaces have been available since
late iterations of the 2.6.x branch.
Using the CPU branch trace store. Our attack vector is branch
tracing. Modern CPUs like the ones mentioned above provide ex-
tensive, low-overhead instrumentation for performance profiling,
debugging and other applications. On Intel CPUs, this includes the
Precise Event-Based Sampling (PEBS) interface, which provides ac-
curate counters for numerous events related to program execution
(CPU cycles, context switches, page faults, branch misses, etc.), as
well as the Branch Trace Store (BTS), which records various infor-
mation (including origin and destination addresses) of all branching
instructions actually taken during the execution of a process or pro-
cess family in a special area of memory. When PEBS performance
counters overflow, or when the BTS memory area fills up, the CPU
generates interrupts that can be captured by the operating system
to record complete information separately.
Access to those hardware functionalities is normally privileged,
but can be exposed to userland processes by the operation system.
This is in particular the case under Linux through the perf_events
interface and the perf command. Branch tracing of a process (be-
longing to the same user), in particular, can be carried out using
the following instruction:
perf record -e branches:u -c 1 -d -p ⟨pid⟩
which produces a large binary file (perf.data) containing infor-
mation about all branching instructions executed in the process
with PID ⟨pid⟩ between user space addresses, in the correct order
(even if the CPU may execute out-of-order or mispredict branches,
the data in perf.data corresponds to the logical execution, so it is
in the right order and does not include branch misses). The binary
file can then be analyzed using the perf report and perf script
commands. Specifically, perf script -F ip,addr prints a list of
lines of the form:
7fd0a2a48884 =>
7fd0a2a484a8
indicating the source and destination address of each branching
instruction.
The use of perf_events by non-privileged users can be re-
stricted, according to the kernel.perf_event_paranoid sysctl set-
ting: if that parameter is set to 2 (most paranoid), the perf record
command above will fail without root privileges, which makes our
attack rather meaningless. However, at any level below that (1, 0
or −1), the command succeeds, and so does our attack. And the
parameter is often not set to the most paranoid level by default.
Moreover, there can actually be security reasons not to disallow user
space perf_events by ordinary users: for example, the use of PEBS
counters has been recommended as a possible way of detecting
cache attacks [27] and other attacks causing large numbers of cache
misses (such as rowhammer [36]): see for example the discussion
in [30]. Since the detection requires high-frequency polling of per-
formance counters, applying it system-wide could cause significant
slowdowns and lead to false positives, so it should ideally be run
by the user himself on the sensitive process he wants to monitor
against attacks (strongSwan would be a natural candidate!).
An additional issue worty of mention is that, perhaps due to the
fact that perf_events are not always perceived as a possible attack
vector, the relevant part of the Linux kernel does not seem to be
the most scrutinized from a security standpoint. In particular, until
May 2016, a race condition in perf_event_open allowed to bypass
the privilege verification entirely [5], which means that our attack
could be conducted from any userland process (and probably still
can on many live systems).
Recovering the BLISS norm in strongSwan with branch tracing.
The strongSwan implementation of BLISS signature generation
uses a direct implementation of the Bernoulli-based algorithm for
rejection sampling described in Figure 2. In particular, the func-
tion that implements SampleBernExp, called bernoulli_exp in
strongSwan, iterates over each bit of the input value x, and skips to
the next iteration whenever the bit is zero. More precisely, branches
are taken in bernoulli_exp:
7
Figure 7: Disassembled code snippet of the bernoulli_exp
method, as output by the gdb disassemble/m command.
Dump of assembler code for function bernoulli_exp :
46
{
0 x000066f0 :
push
% r15
while ( x_mask > 0)
0 x00006742 :
0 x00006745 :
0 x00006748 :
0 x000067c3 :
0 x000067c6 :
{
0 x0000674a :
0 x0000674d :
test
mov
je
shr
jne
% r13d ,% r13d
% rdx ,% rbp
0 x67c8 
% r13d
0 x674a 
if (x & x_mask )
test
je
{
% r13d ,% r14d
0 x67c0 
}
}
}
...
58
59
60
61
...
78
...
81
...
85
...
0 x000067ad :
retq
(1) to enter into the function;
(2) to iterate over the bits of the input x;
(3) each time the corresponding bit is 0;
(4) to return from the function.
If we can find the addresses corresponding to all of these branch-
ing instructions, the information provided by perf script will
immediately reveal every bit of x, which will let us reconstruct x
and hence mount the attack described in §3.2.
The strongSwan software (and more generally any program
linked against the libstrongswan library) accesses the BLISS-related
functions from the libstrongswan-bliss.so object, which is dy-
namically loaded using dlopen(3). So to find the addresses of rele-
vant branching instructions in the memory space of the attacked
process, it suffices to find the offsets of those instructions within
libstrongswan-bliss.so, as well as the address at which that
library is mapped in the memory space of the process once it is
loaded. The latter can be done by parsing the line corresponding
to the libstrongswan-bliss.so executable segment in the file
/dev/⟨pid⟩/maps.
As for the former, it can be done using a disassembler, such
as the disassemble/m command in gdb, as shown in Figure 7.
We can see from that figure that, in our compiled version of the
libstrongswan-bliss.so object, the four offsets we are interested
in are respectively 0x66f0 (entry point), 0x67c6 (while loop iter-
ation), 0x674d (conditional branch on the bits of x) and 0x67ad
(return). The same method allows us to find the address in the
BLISS signing function sign_bliss at which the bernoulli_exp
method is called (it can be either 0x2de3 or 0x2f51). Then, it suf-
fices to find the corresponding branching event in the output of
perf script and follow from there the branching instructions
carried out inside bernoulli_exp to recover x and hence ∥Sc∥2.
The entire attack has been mounted against a short program
linked against libstrongswan-bliss.so that generates a BLISS
key, computes a BLISS signature with it and verifies it. A short
shell script runs that program, launches perf report on it, and
calls a perl script to parse the output of perf script afterwards.
An example output of the shell script implementing the attack is
shown in Figure 8. We are able to recover the value ∥Sc∥2 correctly
Figure 8: Example output from the run_exploit_rejection
shell script.
Running target ' basic_sign ' as PID 13261 . Launching perf record.
perf record complete. Parsing perf.data.
Recovered x
: 29526
Correct | Sc |^2 : 17013
Should sum to
: 46539
Success !
all the time. The source code of the entire attack is available for
download from https://github.com/mti/bliss-sidechannel.
Features and limitations of the attack. The adversarial use of
perf_events-based branch tracing does not seem to have received
much consideration in the literature, but it is quite similar to the
branch prediction attacks of Acıiçmez et al. [1–3]. The branch trac-
ing side-channel is more robust, however: on most CPUs, branch
prediction is randomized or at least non-deterministic, so that the
information one can get from branch mispredictions and similar
events is noisy. Our attack, on the other hand, produces a complete
and faithful execution trace, and thus succeeds all the time.
It does shares some of the limitations of branch prediction at-
tacks, however. In particular, the attack model is quite strong, as it
requires the ability to run another process on the same platform,
usually with the same UID as the target process (unless privilege
checks can be bypassed as in the perf_event_open security bug
mentioned earlier). As a result, the threat posed by this kind of
attack is normally limited. It cannot be ignored entirely, however,
as modern Linux systems, through security measures like ptrace
protection, will not allow a process to e.g. read from the memory
space of another process from the same user: userland interprocess
spying is usually regarded as a significant security issue. Similarly,
secret keys stored on disk are usually encrypted and passphrase-
protected, so one cannot assume that a process can learn all of a
user’s secrets just by acquiring his UID.
Another limitation of the attack, which is again shared with
branch prediction attacks and many other attacks in the spy-process
paradigm [3, §2.3], is that is has a noticeable effect on overall system
performance, and hence is unlikely to remain undetected when
using the target software interactively. The main performance hit
in our attack is due to the perf record command writing to disk
an exhaustive record of all branching events in the execution of the
target: this amounts to hundreds of megabytes of data, of which we
use only a few dozen bytes. Modifying perf to only write the events
we need would reduce the overhead of the attack by a considerable
extent. Moreover, Sky Lake and newer Intel CPUs allow this filtering
to be carried out directly on-chip using hardware address filters,
reducing the attack overhead to practically zero.
4 ATTACK ON THE GAUSSIAN SAMPLING
The second source of side-channel leakage that we consider is the
Gaussian sampling algorithm used to generate the random masks
y1 and y2 during signature generation. This algorithm samples
from a fixed, centered discrete Gaussian distribution. Numerous
techniques have been proposed to carry out that operation. One
standard approach [18] involves the use of a cumulative distribution
table, as suggested by Peikert [44], combined with the Knuth–Yao
8
algorithm. This is mentioned in the original BLISS paper [14, §6], but
the authors note that this requires storing large tables in memory.
Instead, they propose an alternate iterative approach based on
the repeated sampling of Bernoulli and uniform distributions. Their
algorithm SampleGaussian is described in Figure 9, and relies on
the Bernoulli sampling function SampleBernExp as well a simple
function SamplePosGaussian that samples from the positive part
of the discrete Gaussian distribution that picks the integer i with
probability proportional to 2−i2.