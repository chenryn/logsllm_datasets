31
2
1.03¬∑105
testCand (s)
52,251
1,740
1.53¬∑107
in the algorithm, it is highly parallelizable: if we are given ùêæ + ùêø
processors, we can compute the first ùêæ candidates in a breadth-first
fashion, distribute them across the processors, and run them in
depth-first fashion. The remaining ùêø processors can then be used
to apply the lattice algorithm on all candidates of length ùê∑.
Table 4 contains the experimental results of our algorithm for
different key lengths. In order to obtain these experimental results,
we used idealized inputs to our algorithm, which were generated
by hand, and represent a separate trace for every parameter. Our
experimental results showed that the running time of genCands
and testCand is relatively stable per candidate with at most 0.0006
seconds for genCands and at most 0.07 seconds for testCand. An ex-
trapolation shows that such a non-optimized implementation does
not yet give an algorithm that reconstructs the complete 1024-RSA
key within a week: The generation of all candidates via genCands
would take about 60 CPU years and the reconstruction via testCand
would take about 6,000 CPU years. We estimate a cost of about
1,000,000 dollars on AWS and accordingly a few 100,000 dollars on
cheaper bare-bone clouds if we simply use many copies of small_-
roots. But, as shown by the evolution around the Data Encryption
Standard (DES), the time to brute-force over a search space of 250
(as given in our case for 1024-RSA) can be drastically reduced by
more specialized hardware. More concretely, [47] uses 120 low-cost
FPGAs and can make about 5 ¬∑ 1010 DES calls per second allowing
to break DES within two weeks. We thus expect more specialized
hardware will lead to a reconstruction time of a few weeks.
6 MITIGATIONS
The demonstrated attack and library analysis show that not only
cryptographic implementations themselves need to be protected
against attacks, but that it is equally important to shield utility
functions from side- and controlled-channel attacks, if they process
secret data. We propose two mitigations for the base64 attacks
described in this work: First, we describe a constant-time variant
of the original lookup table-based decoding algorithm, and discuss
the constant-time case decision approach from BoringSSL [14].
Additionally, we highlight how adjusting existing best practices
for key storage can help to reduce the surface for attacks on utility
functions in general.
6.1 Constant-time decoding
6.1.1 LUT-based. A naive mitigation to our attack on the lookup
table would work as follows: In order to make sure that the decoding
of each symbol happens in constant-time, each entry of the lookup
table is accessed for each decoded symbol, and the correct symbol
is selected using a mask. This approach will decrease decoding
performance drastically, since decoding of each symbol does require
128 lookups (the size of the LUT in bytes), instead of only one.
__attribute__ (( aligned (64)))
unsigned char lut [128] = { ... };
uint8_t decode_aligned ( unsigned char b64ch ) {
uint8_t result = 0 x00 , mask = 0 xAA ;
unsigned char idx [2] = { b64ch % 64 , ( b64ch % 64) + 64
};
for ( unsigned char i = 0; i < 2; ++ i) {
mask = 0 xFF ^ (( idx [i] == b64ch ) - 1);
result = result | ( lut [ idx [i ]] & mask );
}
return result ;
}
Figure 8: Optimized constant-time decoding of a single
base64 character, with a 64-byte aligned lookup table. Note
that the LUT only spans two cache lines, so two accesses are
sufficient in our leakage model.
To improve the performance of our naive mitigation, we add
a constraint on the memory alignment as shown in Listing 8. By
instructing the compiler to align the LUT to 64 byte, it is only
necessary to access each line once per symbol, which ensures that
a controlled-channel attacker cannot determine the correct access
in our leakage model. Therefore, we always access the LUT at
b64ch mod 64 and (b64ch mod 64) + 64 and select the correct
lookup with a mask as before. In case the current index is smaller
than 64, the first access correctly decodes the symbol, otherwise
the second. The overhead of the LUT dummy access should be
negligible, compared to operations like asymmetric decryption.
6.1.2 Case decision-based. Google‚Äôs BoringSSL [14] already imple-
ments a constant-time base64 decoding approach. Constant-time
behavior in base64 decoding is achieved by a LUT-free implementa-
tion. In a first step, it is determined to which part of the ASCII table
the currently decoded symbol belongs. Then, the corresponding
binary value is selected using a mask. Listing 10 in the appendix
shows the relevant part of the decoding routine from BoringSSL.
Other examples for constant-time case decision-based base64 de-
coding are libsodium [49] and Nimbus-JOSE-JWT [61].
We believe that using a case decision-based approach has some
advantages over using a LUT: Most cryptographic libraries already
offer well-tested and portable macros for constant-time compar-
ison and selection, so employing a separate technique in utility
functions does not make much sense. Also, the LUT-based tech-
nique highlighted in Listing 8 still makes certain assumptions on
Session 10A: Crypto, Symbols and Obfuscation CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea2467the underlying hardware and leakage behavior, which may not
apply when compiling the same code for different target platforms.
Finally, due to the relatively few calls the performance difference is
negligible. We thus recommend to consider replacing LUT-based
decoding functions by case decision-based implementations.
6.2 Key Storage Practices
Our base64 decoding attack against RSA keys can also be mitigated
by using encrypted PEM files: In this case, the attacker would only
learn parts of the ciphertext, and is not able to derive the contained
key. After base64 decoding, the DER-encoded key is decrypted and
decoded. Assuming that the key loading routine uses the same
symmetric primitives that a given crypto library offers anyway
(and which are thus subject to thorough security evaluation), this
method reduces the attack surface to the key decoder and the key
instantiation in memory. However, from our experience, many
default server configurations use unencrypted key files, especially
when doing automated replacement of keys and certificates (e. g.,
Let‚Äôs Encrypt). Since these files are usually bound to a single system
or instance, and do not leave this environment, a compromise of
such a file would almost certainly also mean a compromise of the
entire system and thus the passphrase needed to decrypt the key.
On the other hand, if those private key files are not intended to be
transmitted over the network or stored in text-based configuration
files, there is no real benefit in using base64 at all, since it just adds
overhead and increases the attack surface: In such cases, simply
storing the binary DER data would be sufficient.
7 RELATED WORK
In general, leakage in key decoding is not a new concept: The au-
thors of DATA [77] briefly mention true positives in OpenSSL‚Äôs
key loading functionality, but did not further investigate the issue.
In [29], the authors use alternative, but mathematically equivalent
key representations to trigger specific non-hardened branches of
the decoding routines, which deal with less common key formats
and have thus been overlooked in prior research. However, they do
not target generic utility functions, but arithmetic aspects of key
decoding. To the best of our knowledge, the only other attack tar-
geting utility functions is Medusa [60]. Medusa is an attack which
leaks key information during base64 decoding in OpenSSL. How-
ever, their focus is on extracting information from the transient
domain and attacking the associated rep mov instruction. Such
attacks are only possible if SMT is enabled and if the SGX enclave
shares the core with a malicious process. Intel advises against such
operations [84]. Our attack, however, does not need simultaneous
access to the neighboring vCores and works fine on enclaves with
disabled hyperthreading. Furthermore, we do not only concentrate
on a single instruction, but present a systematic analysis of key de-
coding functionality in several widely used cryptographic libraries
and show that these utility functions leak sensitive information
despite and because of the mitigation introduced due to other mi-
croarchitectural attacks on SGX and through the transient domain
[18, 19, 22, 46, 50]. We leverage techniques common in the microar-
chitectural attack domain like Prime+Probe and combine them
with a recent attack framework [20] to extract all available leak-
age introduced through non-constant-time behaviour of the base64
decoding process and analyze the leakage with an adapted and gen-
eralized version of the Heninger and Shacham key reconstruction
algorithm [35].
The algorithm of Heninger and Shacham was already general-
ized by Bernstein et al. [11], but only to their special scenario, in
which an observation on the variables of the square-and-multiply
algorithm was used. Our approach is more generic and general. In
the setting of cold-boot attacks, the generalizations by Henecka et
al. and Paterson et al. [34, 65] outperform the algorithm of Heninger
and Shacham [35]. The main reason for this is that, given some
partial information, there are some candidates compatible with
this observation that are much more likely than other candidates.
One can thus prune these unlikely candidates and only introduce a
negligible error probability. In contrast, in our scenario all of the
candidates compatible with our observation are equally likely and
no probabilistic pruning is possible.
8 CONCLUSION
We showed that side-channel resistance is not only relevant for
cryptographic routines, but also for utility functions responsible
for encoding and decoding secret data. Nearly all of the major cryp-
tographic libraries used lookup tables for these decoding purposes,
allowing us to mount a high-resolution cache attack to significantly
weaken the security guarantees provided by the underlying encryp-
tion schemes. We thus believe that it is important to check all parts
of a cryptographic library for side-channel vulnerabilities, e. g., by
using automated analysis tools, especially for the case of strong
attacker models enabled by trusted execution environments.
There are two important parameters making our attack feasible:
First, the high resolution of our attack is possible only due to a
security fix for transient execution attacks, as the serialization of
memory loads greatly improves the signal-to-noise ratio. Second,
while the resulting leakage is quite small, the redundancy in the
storage of the RSA keys allows us to achieve a significant drop
in the security level of the secret key. Both improvements, one
which is intended to mitigate newly emerged attacks and the other
targeting at speeding up RSA computations, come at the cost of
security and in their combination render our attack possible. We
thus believe that studying performance optimizations, security
patches and other improvements for their side effects is a crucial
task and should be conducted continuously and across all functions
which process sensitive data. We also propose to add side-channel
analysis to the continuous integration pipelines, such that existing
and newly introduced vulnerabilities are identified automatically,
and known but minor leakages are re-evaluated depending on new
developments in attack accuracy.
ACKNOWLEDGMENTS
The authors thank Nadia Heninger and Christopher Krebs for
discussing approaches to integrate ùëû‚àí1
ùëù into the key-recovery al-
gorithm and the anonymous reviewers for their valuable com-
ments and constructive feedback. This work has been supported by
Deutsche Forschungsgemeinschaft (DFG) under grants 439797619
and 427774779.
Session 10A: Crypto, Symbols and Obfuscation CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea2468REFERENCES
[1] 2020. Asylo - Mitigations / software hardening for LVI. https://github.com/
google/asylo/issues/59.
[2] 2020. Update to build with SGX SDK v2.9, SGX SSL with CVE-2020-0551 All-
Load-Mitigation, and optionally with p11-kit. https://github.com/intel/crypto-
api-toolkit/commit/9d512fd7f81764b439cadab0f1f58dee1c905cdf.
[3] Alejandro Cabrera Aldaya and Billy Bob Brumley. 2020. When one vulnerable
primitive turns viral: Novel single-trace attacks on ECDSA and RSA. IACR Trans.
Cryptogr. Hardw. Embed. Syst. 2020, 2 (2020), 196‚Äì221.
[4] Alibaba. Accessed: 2021. Inclavare Containers. https://inclavare-containers.io/.
[5] Alibaba. Accessed: 2021.
Inclavare Containers - enclave-tls README.
https://github.com/alibaba/inclavare-containers/blob/master/enclave-
tls/README.md.
[6] Ittai Anati, Shay Gueron, Simon Johnson, and Vincent Scarlata. 2013. Innovative
technology for CPU based attestation and sealing. White Paper.
[7] Gorka Irazoqui Apecechea, Thomas Eisenbarth, and Berk Sunar. 2015. S$A: A
Shared Cache Attack That Works across Cores and Defies VM Sandboxing -
and Its Application to AES. In IEEE Symposium on Security and Privacy. IEEE
Computer Society, 591‚Äì604.
[8] Diego F. Aranha, Felipe Rodrigues Novaes, Akira Takahashi, Mehdi Tibouchi,
and Yuval Yarom. 2020. LadderLeak: Breaking ECDSA with Less than One Bit of
Nonce Leakage. In CCS. ACM, 225‚Äì242.
[9] Asylo Authors. Accessed: 2021. Asylo. https://asylo.dev/.
[10] Daniel J Bernstein. 2005. Cache-timing attacks on AES.
[11] Daniel J. Bernstein, Joachim Breitner, Daniel Genkin, Leon Groot Bruinderink,
Nadia Heninger, Tanja Lange, Christine van Vredendaal, and Yuval Yarom. 2017.
Sliding Right into Disaster: Left-to-Right Sliding Windows Leak. In CHES (Lecture
Notes in Computer Science), Vol. 10529. Springer, 555‚Äì576.
[12] Dan Boneh et al. 1999. Twenty years of attacks on the RSA cryptosystem. Notices
of the AMS 46, 2 (1999), 203‚Äì213.
[13] Dan Boneh, Glenn Durfee, and Yair Frankel. 1998. An Attack on RSA Given a
Small Fraction of the Private Key Bits. In ASIACRYPT (Lecture Notes in Computer
Science), Vol. 1514. Springer, 25‚Äì34.
[14] BoringSSL. Accessed: 2020. https://boringssl.googlesource.com/boringssl/.
[15] Botan: Crypto and TLS for Modern C++. Accessed: 2020. https://github.com/
randombit/botan.
[16] Ferdinand Brasser, Urs M√ºller, Alexandra Dmitrienko, Kari Kostiainen, Srd-
jan Capkun, and Ahmad-Reza Sadeghi. 2017. Software Grand Exposure: SGX
Cache Attacks Are Practical. In 11th USENIX Workshop on Offensive Technolo-
gies (WOOT 17), William Enck and Collin Mulliner (Eds.). USENIX Associa-
tion, Vancouver, BC. https://www.usenix.org/conference/woot17/workshop-
program/presentation/brasser
[17] Samira Briongos, Pedro Malag√≥n, Jos√© Manuel Moya, and Thomas Eisenbarth.
2020. RELOAD+REFRESH: Abusing Cache Replacement Policies to Perform
Stealthy Cache Attacks. In USENIX Security Symposium. USENIX Association,
1967‚Äì1984.
[18] Jo Van Bulck, Marina Minkin, Ofir Weisse, Daniel Genkin, Baris Kasikci, Frank
Piessens, Mark Silberstein, Thomas F. Wenisch, Yuval Yarom, and Raoul Strackx.
2018. Foreshadow: Extracting the Keys to the Intel¬Æ SGX Kingdom with Transient