title:Secure Sampling of Public Parameters for Succinct Zero Knowledge Proofs
author:Eli Ben-Sasson and
Alessandro Chiesa and
Matthew Green and
Eran Tromer and
Madars Virza
2015 IEEE Symposium on Security and Privacy
2015 IEEE Symposium on Security and Privacy
Secure Sampling of Public Parameters
for Succinct Zero Knowledge Proofs
Eli Ben-Sasson§, Alessandro Chiesa∗, Matthew Green†, Eran Tromer¶, Madars Virza‡
∗ETH Z¨urich, PI:EMAIL
†Johns Hopkins University, PI:EMAIL
‡MIT, PI:EMAIL
§Technion, PI:EMAIL
¶Tel Aviv University, PI:EMAIL
are
applications. However,
zero-knowledge
cryptographic
Abstract—Non-interactive
a powerful
proofs
tool, with
(NIZKs)
succinct
numerous potential
NIZKs (e.g., zk-SNARK schemes) necessitate a trusted
party to generate and publish some public parameters, to
be used by all provers and veriﬁers. This party is trusted
to correctly run a probabilistic algorithm (speciﬁed by
the the proof system) that outputs the public parameters,
and publish them, without leaking any other information
(such as the internal randomness used by the algorithm);
violating either requirement may allow malicious parties
to produce convincing “proofs” of false statements. This
trust requirement poses a serious impediment to deploying
NIZKs in many applications, because a party that is
trusted by all users of the envisioned system may simply
not exist.
In this work, we show how public parameters for a class
of NIZKs can be generated by a multi-party protocol, such
that if at least one of the parties is honest, then the result
is secure (in both aforementioned senses) and can be subse-
quently used for generating and verifying numerous proofs
without any further trust. We design and implement such a
protocol, tailored to efﬁciently support the state-of-the-art
NIZK constructions with short and easy-to-verify proofs
(Parno et al. IEEE S&P ’13; Ben-Sasson et al. USENIX
Sec ’14; Danezis et al. ASIACRYPT ’14). Applications
of our system include generating public parameters for
systems such as Zerocash (Ben-Sasson et al. IEEE S&P ’13)
and the scalable zero-knowledge proof system of (Ben-
Sasson et al. CRYPTO ’14).
I. INTRODUCTION
In recent years individuals and enterprises have begun
to migrate large quantities of internal data to outside
providers. This trend raises concerns about the integrity
and conﬁdentiality of computations conducted on this
data. Consider, for example, the following simple illus-
trative scenario. A server owns a private database x,
and a client wishes to learn y := F (x) for a public
function F ; a commitment cm to x is known publicly.
For example, x may be a database containing genetic
data, and F may be a machine-learning algorithm that
uses the genetic data to compute a classiﬁer y. On the
one hand, the client seeks integrity of computation: he
© 2015, Eli Ben-Sasson. Under license to IEEE.
© 2015, Eli Ben-Sasson. Under license to IEEE.
DOI 10.1109/SP.2015.25
DOI 10.1109/SP.2015.25
287
287
wants to ensure that the server reports the correct output
y (e.g., because the classiﬁer y will be used for critical
medical decisions). On the other hand, the server seeks
conﬁdentiality of his own input: he is willing to disclose
y to the client, but no additional information about x
beyond y (e.g., because the genetic data x may contain
sensitive personal information).
Zero-knowledge proofs. Achieving the combination
of the above security requirements seems paradoxical:
the client does not have the input x, and the server
is not willing to share it. Yet, cryptography offers a
powerful tool that is able to do just that: zero-knowledge
proofs [1], [2]. The server, acting as the prover, attempts
to convince the client, acting as the veriﬁer, that the
following NP statement is true: “there is ˜x such that
y = F (˜x) and ˜x is a decommitment of cm”. Indeed:
(a) the proof system’s soundness property addresses the
client’s integrity concern, because it guarantees that, if
the NP statement is false, the prover cannot convince
the veriﬁer (with high probability);1 and (b) the proof
system’s zero-knowledge property addresses the server’s
conﬁdentiality concern, because it guarantees that, if the
NP statement is true, the prover can convince the veriﬁer
without leaking any information about x (beyond what
is leaked by y).
Non-interactivity. While zero-knowledge proofs can
address the above simple scenario, they also apply more
broadly, including to scenarios that involve many parties
who do not trust each other or are not all simultaneously
online. In such cases, it is desirable to use non-interactive
zero-knowledge proofs (NIZKs), where the proof consists
of a single message π that can be veriﬁed by anyone.
For example, such a proof π can be stored for later use,
or it can be veriﬁed by multiple parties without requiring
1Sometimes a property stronger than soundness is required: proof
of knowledge [1], [3], which guarantees that, whenever the veriﬁer is
convinced, not only can he deduce that a witness exists, but also that
the prover knows one such witness.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:37 UTC from IEEE Xplore.  Restrictions apply. 
the prover to separately interact with each of these.
Unfortunately, NIZKs do not exist for languages
outside BPP (even when soundness is relaxed to hold
only computationally) [4]. But, if a trusted party is
available for a one-time setup phase, then, under suitable
hardness assumptions, NIZKs exist for all languages in
NP [5]–[7]. During the setup phase, the trusted party
runs a probabilistic polynomial-time generator algorithm
G (prescribed by the proof system) and publishes its
output pp, called the public parameters; afterwards, the
trusted party is no longer needed, and anyone can use pp
to produce proofs or to verify them. Soundness of the
NIZK depends on this trusted setup: if pp is not correctly
generated, or if secret internal randomness used within
G is revealed, then it may be feasible to convince the
veriﬁer that false NP statements are true. Compromised
soundness can have catastrophic implications, because an
attacker may be able to cause signiﬁcant damage without
being detected.
The problem of parameter generation.
If no trusted
party is available, how should the public parameters pp be
generated? Without some trustworthy method to generate
public parameters, deploying practical systems that rely
on NIZKs (e.g., Zerocash [8]) seems very challenging.
One approach is to look for, in Nature or Society, a
publicly-observable distribution that equals (or is close
to) pp’s distribution. For example, if G merely outputs
a random binary string of a certain length,2 it may be
possible, via suitable measurements and post-processing
of, e.g., data about sun spots or the stock market, to
extract bits that are close to random. (See [9], [10] for
work in this direction, and [11] for a NIST prototype
using quantum randomness sources). However, if G
follows a more complex probabilistic strategy, then there
may be no stochastic process in Nature or Society that
yields a distribution close to pp’s.
An attractive alternative approach to address the
problem of parameter generation is the following:
construct a multi-party protocol for securely generating
the public parameters pp.
The setup phase will then involve a large set of parties
running the multi-party protocol for generating pp, and
for soundness of the NIZK to hold it will sufﬁce that
only a few (ideally, even just one) of these parties are
honest. Clearly, this is a weaker and more realistic trust
assumption then placing ultimate trust in any single party.
Several works have explored this approach for the pa-
rameter distributions of various cryptographic primitives
2NIZKs for which G outputs a random binary string are said to be
in the common random string model.
288288
and, more generally, one can invoke secure multi-party
computation [12], [13] to obtain a feasibility result. Yet,
as discussed in Section II, prior works do not yield
satisfactory efﬁciency in our setting, which we now
introduce.
A. Our focus
The problem of parameter generation has garnered recent
attention due to the development of new and powerful
NIZKs that enable verifying general computation via
proofs that are succinct, i.e., short and easy to verify [14].
The new proofs are known as zero-knowledge succinct
arguments of knowledge (zk-SNARKs) [15]–[17], and
have already found practical applications, e.g., to building
decentralized electronic cash [8]. Most zk-SNARKs
require an involved parameter generation, often with
complexity proportional to the size of the computation
being proved; addressing this parameter generation is
the focus of our work. Concretely, we obtain efﬁcient
multi-party protocols for securely sampling the public
parameters required by zk-SNARKs, as we now explain.
zk-SNARK constructions. There are many zk-SNARK
constructions, with different properties in efﬁciency
and supported languages. In preprocessing zk-SNARKs,
the complexity of sampling public parameters grows
with the size of the computation being proved [17]–
[31]; in fully-succinct zk-SNARKs, that complexity is
independent of computation size [14], [16], [32]–[40].
Working prototypes have been achieved for preprocessing
zk-SNARKs [21], [22], [25], [27], [30] and fully-succinct
ones [39]. Several works have also explored various
applications of zk-SNARKs [8], [41]–[44].
Public parameters of zk-SNARKs. Despite the afore-
mentioned multitude of constructions, Bitansky et al.
[17] showed that essentially all known preprocessing
zk-SNARK constructions can be “explained” as the
combination of a linear interactive proof (LIP) and
a cryptographic encoding that only supports linear
homomorphisms. This yields a uniﬁed view of parameter
generation across preprocessing zk-SNARKs (that are
not fully succinct). Namely, given an NP relation R, the
generator G adheres to the following computation pattern
when producing public parameters for R:
(i) derive
from R a certain circuit C (essentially, C is the multi-
output circuit that computes the LIP’s veriﬁer’s message);
(ii) evaluate C at a random input; (iii) output the encoding
of the evaluation. In other words, public parameters of
preprocessing zk-SNARKs are the encodings of random
evaluations of certain circuits.
The sampling problem. Concretely, for a prime r,
the circuit C is deﬁned over the size-r ﬁeld Fr and
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:37 UTC from IEEE Xplore.  Restrictions apply. 
the encoding of α ∈ Fr is α · G, where G generates
an order-r group G. Moreover, G is a duplex-pairing
group (i.e., G is a subgroup of some G1 × G2 equipped
with a pairing). This discussion motivates the following
multi-party sampling problem:
Let r be a prime, G = (cid:3)G(cid:4) an order-r group, n a
positive integer, and C : Fm
r an Fr-arithmetic
r
circuit. Construct an n-party protocol for securely
sampling pp := C((cid:4)α) · G for random (cid:4)α ∈ Fm.
We thus seek a multi-party protocol such that, even when
all but one of the n parties are malicious, the protocol’s
output is pp sampled from the correct distribution and,
moreover, the n parties, and any others observing the
protocol’s execution, learn nothing beyond pp itself. We
study this problem, and the special case of generating
public parameters for preprocessing zk-SNARKs.
→ Fh
In fact, as the purpose of the multi-party protocol in the
aforementioned application is to convince the systems’
users, which are bystanders to the protocol execution, we
make explicit a transcript veriﬁer, which is an algorithm
that anyone can use to ensure correct execution of the
protocol by examining the broadcast messages.
B. Our contributions
We design, build, and evaluate a multi-party protocol
for securely sampling encodings of random evaluations
of certain circuits. The resulting system enables us, in
particular, to sample the public parameters for a class of
preprocessing zk-SNARKs that includes [21], [25], [31];
we integrated our system with libsnark [45], a C++
zk-SNARK library, to facilitate this application. In more
detail, we present the following two main contributions.
(1) Secure sampling for a class of circuits. We design,
build, and evaluate a multi-party protocol that securely
samples values of the form C((cid:4)α) · G for a random
(cid:4)α, provided that C belongs to a certain circuit class
CS. Roughly, CS comprises the F-arithmetic circuits
C : Fm → Fh for which: (i) the output of each (addition
or multiplication) gate is an output of the circuit; (ii) the
inputs of each addition gate are outputs of the circuit;
(iii) the two inputs of each multiplication gate are,
respectively, a circuit output and a circuit input. (See
Figure 1a for an example of a circuit in CS.)
The multi-party protocol is based on standard cryp-
tographic assumptions, and runs atop a synchronous
network with an authenticated broadcast channel and
a common random string.3 The computation proceeds
in rounds and, at each round, the protocol’s schedule
determines which parties act; a party acts by broadcasting
a message to all others.
When n parties participate, our protocol is secure
against up to n − 1 malicious parties. If even one of
the parties is honest, and assuming the protocol reaches
completion, then the protocol’s output is a sample from
the designated distribution and no other information
leaks.4 Each party runs in time Oλ(size(C)), where
Oλ(·) hides a ﬁxed polynomial in the security parameter
λ. The number of rounds is n · depthS(C) + O(1) and
the number of broadcast messages is O(n · depthS(C)).
Here, depthS(C) denotes the S-depth of C (introduced
later), which is at most the standard circuit depth of C,
but sometimes much smaller, as is (crucially) the case
for the zk-SNARK application discussed below.
While the above results hold for any group G, our
code implementation is specialized to the case when G is
duplex-pairing because, for this case, several additional
optimizations are possible. For this special case, we
additionally rely on random oracles so as to beneﬁt from
the Fiat–Shamir heuristic [47].
Compared to previous results in secure multi-party
computation protocols, our specialized construction
scales up to larger number of parties without incurring
a high round complexity; see Section II.
(2) Application to zk-SNARKs. Our system can
securely sample public parameters of a zk-SNARK,