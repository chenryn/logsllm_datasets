to  monitor 
internal  events  of  a  circuit 
Some  of  the  important  qualitative properties that can 
be  used  to  characterize  fault  injection  methods  are  as 
follow: 
• Ability  to  provide  control  over  where  and  when  a 
fault is injected (Controllability). 
• Ability 
(Observability). 
• Ability  to  evaluate  the  target  system  when  it  is 
connected to the real application environment. 
• The  time,  which  is  needed  for  executing  fault 
injection campaigns. 
• Ability  to  inject  faults  into  a  system  in  the  design 
cycle. 
• Ability  to  save  the  system  from  the  risk  of  costly 
damages. 
• Ability to inject faults into non-synthesizable models.  
• Ability to inject faults into HDL models. 
Based  on  these  properties,  a  comparison  between  the 
different fault injection methods is shown in Table 1. 
3. Overview of FITSEC 
In this paper the FITSEC tool is used to illustrate the 
hybrid fault injection based on simulation and emulation 
co-operation. Figure 1 shows the overview of FITSEC. At 
the first step, fault injector units (FIU) are inserted in the 
target  system  model.  The  tool  analyzes  the  VHDL  (or 
Verilog)  model  of  the  target  system  and  provides 
candidate  fault  injection  target  points  to  the  user.  After 
the  user  specifies  the  target  points,  another  VHDL  (or 
Verilog)  model 
is  automatically  generated.  This 
generated model contains the main target system as well 
as  the  FIUs.  Additional  components,  signals,  variables, 
etc. may be added to the main code in order to insert the 
FIUs  in  the  target  system  model.  The  user  must  also 
specify when to inject faults, when to terminate them and 
which signal traces to be saved.  
In  the  next  step,  the  generated  code,  which  contains 
FIUs, is partitioned into two parts; one part is simulated 
while  the  other  part  is  emulated.  By  the  use  of  an 
interface,  the  simulator  communicates  with  the  external 
emulator. The communication between the simulator and 
the  emulator  has  to  be  done  in  such  a  manner  that  the 
whole  system  resembles  a  unique  simulator  in  results. 
The  partitioning  is  mostly  based  on  the  nature  of  the 
VHDL  (or  Verilog)  model  of  the  target  system  and  the 
user  interactions.  For  example,  those  parts  of  the  code, 
which  are  not  synthesizable,  can  not  be  emulated  and 
should  be  simulated.  Also,  those  parts  of  the  system, 
which  need  high  observability,  should  be  simulated 
because  the  simulator  supports  more  observability  than 
what the emulator does.  
After  the partitioning, the fault injection experiments 
are executed. The faults, which are specified by the user, 
are  automatically  injected  one  after  another  and  signal 
traces  are  saved  for  each  fault  injection  experiment. 
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:07:22 UTC from IEEE Xplore.  Restrictions apply. 
System description 
(VHDL or Verilog)
Addition of fault injector 
units 
System description  
including FIUs 
Partitioning 
Code for emulating 
(VHDL or Verilog)
Code for simulating 
(VHDL or Verilog)
Emulator 
Interface 
Simulator 
Data  
Analysis 
Legend
Input/Output
Steps and Units
Figure 1. Overview of FITSEC 
During these experiments the user-specified faults can be 
injected to both the simulated and emulated parts. 
The  final  step  is  to  extract  the  experimental  results 
from  the  saved  signal  traces.  The  data  analysis  unit 
performs this information extraction automatically. 
4. Fault models and FIUs 
injection:  (i)  use  of  built 
Most of the previous methods, which are presented for 
injecting  faults  into  simulated  HDL  models,  can  not  be 
used  for  injecting  faults  into  emulated  models.  For 
example,  VHDL-based  fault  injection  methods  use  two 
techniques  for  fault 
in 
commands  and  capabilities  of  the  simulator  and  (ii) 
modification  of  VHDL  models  [19].  Obviously,  the  first 
method is highly based on the use of a simulator and can 
not  be  used  for  fault  injection  into  emulated  systems. 
Code modification is generally a method that can be used 
for  fault  injection  into  emulated  systems,  however  some 
modifications may lead to non-synthesizable models. For 
instance,  some  modification  methods  of  MEFISTO  are 
based on resolution function [26]. VHDL allows a signal 
to  have  many  drivers  (signal  sources),  provided  that  a 
resolution  function  is  supplied  to  resolve  the  values 
generated by the multiple sources into a signal value for 
the  signal  [24].  Using  common  synthesis  tools,  it  can 
easily  be  seen  that  the  use  of  resolution  functions  in  a 
VHDL  model  may  lead  to  a  non-synthesizable  model. 
Most  of  the  FPGA  chips  do  not  allow  a  signal  to  have 
several drivers.  
FITSEC  is  a  tool,  which  is  based  on  both  the 
simulation and the emulation. Therefore, if one wants to 
inject faults into the emulated parts of the target system, 
the code should retain its synthesizability.  
In FITSEC, the first step of a fault injection campaign 
is  the  insertion  of  the  FIUs  into the VHDL (or Verilog) 
description  of  the  target  system.  FIUs  are  units,  which 
are added to the target system, in order to inject faults to 
it. Each FIU is activated by a fault injector signal (FIS). 
When  an  FIS  takes  the  value  1,  its  corresponding  FIU 
injects  a  fault  to  its  target.  FIUs  can  be  used  to  inject 
faults  into  both  the  simulated  and  emulated  parts of the 
target system. All of the FIUs, which are specified by the 
user,  are  inserted  to  the  system  model  before  the 
compiling and synthesis steps. Therefore there is no need 
to recompile or re-synthesize the model. All experiments 
in a fault injection campaign share the same model. That 
is, in order to avoid re-synthesizing and recompiling, it is 
not  allowed  to  change  the  target  system  configuration 
during a campaign. It should be noted that the compiling 
and synthesis steps are time-consuming and the repeated 
execution of them may lead to a huge time overhead.  
FITSEC  can  be  used  for  fault  injection  at  different 
their 
levels  of  abstraction.  The  fault  models  and 
corresponding  FIUs,  which  have  been  used  by  FITSEC, 
are explained below. 
4.1. Switch level fault models  
FITSEC can be used to inject transistor-stuck-on [27], 
transistor-stuck-off  [27],  short  [27] and open [27] faults 
to  switch-level  models.  Unlike  Verilog,  VHDL  does  not 
support  the  switch-level  modeling  of  digital  systems 
directly  [24][25].  Therefore,  FITSEC  is  only  able  to 
inject  switch-level  faults 
into  switch-level  Verilog 
models.  Using  common  synthesis  tools,  it  can  be  seen 
that a switch-level Verilog model can not be synthesized 
to  an  FPGA  chip.  Therefore  FITSEC  can  be  used  to 
inject  switch-level  faults  only  to  the  simulated  parts  of 
the target system. 
A transistor is stuck-on if it remains on regardless of 
its gate value. In a similar manner, a transistor is stuck-
off if it remains off regardless of its gate value. 
As  an  example,  Figure  2  shows  the FIUs, which can be 
used to inject transistor-stuck-on and transistor-stuck-off 
faults  into  an  N-switch.  Figure  3  shows  how  FITSEC 
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:07:22 UTC from IEEE Xplore.  Restrictions apply. 
d
s
FIS
g
FIU
(b)
FIU
(a)
d
s
Figure 2. FIUs for injecting faults into an  
N-switch, a) Transistor-stuck-on,  
b) Transistor-stuck-off 
 nmos target_switch(d,s,g);
wire w; 
 nmos target_switch(d,s,w); 
 or (w,g,FIS);
FIS
g
(a)
(b)
Figure 3. FUI addition for transistor-stuck-on  
fault, a) The Verilog code of an N-switch,  
b) The Verilog code after FIU addition
w1
FIU
w2
Figure 4. FIU for injecting short fault 
FIS
between wires w1 and w2
inserts  the  FIU,  shown  in  Figure  2a,  in  a  switch-level 
Verilog model. 
As  another  example,  Figure  4  shows  the  FIU,  which 
can  be  used  to  inject  short  faults  into  the  wires  of  a 
switch-level  model.  As  shown  in  this  figure,  the  FIU  is 
composed  of  a  Verilog  tranif1  switch.  This  switch 
connects  its  two  ports  when  its  control  input  takes  the 
value  1  and  disconnects  them  when  the  control  input 
takes  the  value  0  [25].  Figure  5  shows  how  FITSEC 
inserts  the  FIU,  shown  in  Figure  4,  in  a  switch-level 
Verilog model. In a similar manner, by the use of tranif1 
or tanif0 switches, FITSEC can be used to inject the open 
fault model. 
4.2. Gate level fault models 
 FITSEC  can  be  used  to  inject  stuck-at  [26][27], 
bridging  [26]  and  gate  replacement  [26]  faults  to  gate-
level  models.  Figure  6  shows  the  FIUs  that  are  used  to 
inject stuck-at fault models to the signal s. The insertion 
of an FIU divides the signal s into two parts: s1 and s2. 
As an example, Figure 7 shows how FITSEC inserts the 
FIU,  shown  in  Figure  6a,  in  gate-level  Verilog  and 
VHDL  models.  It  should  be  noted  that  wherever  the 
signal  s  is  used  as  an  output  signal  it  is  replaced  by  s1 
module module_name(...,FIS); 
input FIS; 
...
wire w1, w2; 
...
 tranif1 (w1,w2,FIS); 
...
endmodule
Figure 5. FIU addition for injecting short 
faults into a Verilog model
FIS
s1 
s2
FIS
s1 
FIU
(a)
s2
FIU
(b)
Figure 6. FIUs for injecting stuck-at faults into a 
signal, a) stuck-at-1, b) stuck-at-0 
(a) 
(b) 
...
Signal s1,s2; 
...
s2 <= s1 or FIS;
...
wire s1,s2; 
...
or (s2,s1,FIS);
Figure 7. FUI addition for stuck-at-1 fault,  
a) The VHDL code, b) The Verilog code 
X1 
Y1 
FIU
MUX 
2/1
MUX 
2/1
X2 
Y2 
FIS 
Figure 8. FIU for injecting bridging-
AND faults between signals X and Y 
and  wherever  it  is  used  as an input signal it is replaced 
by s2. 
As  another  example  Figure  8  shows  the  FIU  which 
can  be  used  to  inject  bridging  AND  fault  model  to  the 
signals X and Y. Figure 9 shows how FITSEC inserts the 
FIU, shown in Figure 8, in a VHDL model. It should be 
noted  that  wherever  the  signals  X  and  Y  are  used  as 
output  signals 
they  are  replaced  by  X1  and  Y1, 
respectively.  Also,  wherever  they  are  used  as  input 
signals they are replaced by X2 and Y2, respectively. 
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:07:22 UTC from IEEE Xplore.  Restrictions apply. 
...
Signal X1,X2,Y1,Y2 : bit; 
...
X2 <= X1 when FIS = '0' else
     (X1 and Y1); 
Y2 <= Y1 when FIS = '0' else
     (X1 and Y1);
Figure 9: FUI addition for injecting  
bridging-AND faults into a VHDL model 
A B
(a) 
(b)
if (condition) then
 ... 
else
 ... 
end if;
if (condition) or (FIS='1') then
 ... 
else
 ... 
end if;
Figure 11. FUI addition for stuck-then fault, 
a) The VHDL code of an If construct, 
FIU
O
MUX 
2/1
FIS 
Figure 10: FIU for injecting 
gate replacement fault 
In  a  similar  manner,  FITSEC  can  insert  FIUs  in 
Verilog models in order to inject bridging faults. 