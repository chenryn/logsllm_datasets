### 代码片段
```c
int main(int argc, char **argv) {
    if (check_pw(uid, passwd)) {
        fgets(cmd, sizeof(cmd), f);
        if (enable_logging) {
            do_log(uid);
        }
        setuid(0);
        if (execl(cmd, cmd, 0) == -1) {
            // 处理错误
        }
    }
}
```

### 成功返回地址覆盖
图12展示了通过指针`p`成功覆盖返回地址的情况。上述讨论强调了即使发现了指针赋值，也不总是清楚该赋值是否可以用于覆盖返回地址。在这个例子中，我们的符号执行引擎发现了一种可能性，可以通过准备一个配置来覆盖`do_log()`的返回地址，使`cmds`变量直接指向`do_log()`的返回地址。在将`cmds`的内容赋值给`p`后，`p->uid`与第13行的`uid`参数进行比较。

由于`cmd_entry`记录的结构，这个比较总是为真。如图12所示，当`p`指向函数的返回地址时，`p->uid`指向该地址在内存中的上一个位置。根据x86过程调用约定，这个位置恰好是函数的第一个参数。因此，`p->uid`和`do_log()`函数的`uid`参数引用的是同一个内存位置，所以比较结果总是为真。

为了成功覆盖返回地址，需要将`cmd_id`设置为`t`并启用日志记录（通过将`enable_logging`设置为1）。如果没有自动的符号执行过程，这种覆盖返回地址的机会可能很难被发现。此外，需要注意的是，符号执行引擎中并没有编码关于x86过程调用约定的知识。覆盖返回地址的可能性是通过（符号）执行二进制文件的机器指令直接找到的。如果编译器以不同的方式排列`cmd_entry`结构的字段，或者使用了不同的调用约定，这个漏洞就不会被发现。

### 第二次实验
在第二次实验中，我们使用符号执行工具对三个知名的应用程序进行了分析：apache2、netkit ftpd服务器和华盛顿大学的imapd。实验的目的是分析攻击者在实际程序中恢复控制流的机会。为此，我们随机选择了每个程序的一百个地址，这些地址均匀分布在分析的二进制文件的代码段中。从每个地址开始，启动符号执行过程，以确定是否存在一种配置和一系列指令可以使控制流转移到任意地址。在实际攻击中，恶意代码可以放置在这个地址处。请注意，所有应用程序都是动态链接的（这是现代Unix机器上的默认设置）。

| 程序     | 指令数   | 成功 | 失败  | 返回终止 | 耗尽 |
|----------|---------|------|-------|-----------|--------|
| apache2  | 51,862  | 83   | 5     | 12        | 1      |
| ftpd     | 9,127   | 93   | 0     | 7         | 11     |
| imapd    | 133,427 | 88   | 1     | 11        | 1      |

表1总结了这次实验的结果。对于每个程序，列出了代码指令的数量（“指令”列），以及成功找到配置的测试用例数量（“成功”列）和未能找到配置的测试用例数量（“失败”列）。

在所有成功的测试用例中，只需要修改少数几个内存位置即可获得有效的配置。实际上，在大多数情况下，只需更改一个内存位置（PLT中的函数地址）。执行这些修改所需的代码量约为100字节，并且在大多数情况下可以轻松地由攻击者远程注入。

进一步检查失败的测试用例发现，相当一部分失败发生在符号执行线程到达起始地址所在函数的末尾时（“返回”列）。事实上，在某些情况下，符号执行立即终止，因为随机选择的起始地址恰好是`ret`指令。虽然符号执行引擎模拟运行时堆栈，可以执行函数调用和相应的返回操作，但没有前驱函数调用的返回无法处理。原因是每当符号执行线程进行函数调用时，返回地址会被压入堆栈，并在随后的返回操作中使用。然而，如果符号执行从函数中间开始，当初始函数完成时，返回地址未知，线程终止。

当攻击者实际发起攻击时，通常会掌握额外的信息，这些信息可以提供给分析过程。特别是，可以从程序的调用图或调试运行中的受害者进程中提取可能的函数返回地址。如果提供了这些信息，符号执行过程可以在给定地址继续。因此，剩余的测试用例（“耗尽”列）更值得关注。这些测试实例失败是因为符号执行过程无法识别恢复控制流的可能性。我们为每个线程设置了1,000步的限制。超过此限制后，线程被认为已经耗尽搜索空间并停止。设置此限制有两个原因：首先，我们希望强制分析终止；其次，当达到步数限制时，许多内存位置和寄存器已经包含未知值。

我们的结果表明，只有少量的测试用例因分析引擎无法识别适当的配置而失败。这支持了我们的主张，即提出的规避技术可以成功应用于实际应用程序。

| 程序     | 步数       | 时间（秒） |
|----------|------------|------------|
|          | 平均  最大  最小 |            |
| apache2  | 131        | 12.4       |
| ftpd     | 62         | 0.3        |
| imapd    | 650        | 1.2        |

表2提供了更多关于成功找到配置所需步骤数的详细信息。表中列出了成功线程的平均、最大和最小步骤数。结果显示，在大多数情况下，配置很快就能找到，尽管有一些异常值（例如，imapd的一个测试用例需要650步）。请注意，所有程序至少有一个案例是立即成功的。在这种情况下，随机起始指令通常是间接跳转或间接调用，可以轻松重定向。

表中还列出了符号执行引擎完全检查每个程序一百个起始地址（成功和失败案例结合）所需的时间（秒）。每个单独测试用例的运行时间差异很大，取决于生成的约束数量和程序的分支因子。当程序包含许多分支时，符号执行过程必须跟踪许多不同的执行线程，最坏的情况下可能会产生指数级路径爆炸。总体而言，运行时间不是该工具的主要关注点，结果表明系统在实际输入程序上运行高效。

### 结论
本文介绍了新的技术来规避两个知名的入侵检测系统[4, 14]，这些系统监控系统调用。我们的技术基于以下思想：在攻击者将控制权传递给应用程序以进行系统调用后，可以将应用程序的控制流重定向到恶意代码。通过修改进程环境（数据、堆和栈段），使程序最终跟随一个无效的代码指针（函数返回地址或间接控制转移操作），从而重新获得控制权。为此，我们开发了一个针对x86二进制文件的静态分析工具，该工具使用符号执行。该工具自动识别可用于重定向控制流的指令，并计算必要的环境修改，生成适当的代码。使用我们的系统，我们成功利用了三个示例程序，规避了最先进的系统调用监视器。此外，我们将工具应用于三个实际程序，以证明我们技术的普遍适用性。

本文开发的静态分析机制未来可以应用于更广泛的二进制分析问题。一个可能的应用是识别当前函数返回地址被覆盖的配置。这可能允许我们构建一个工具来识别可执行代码中的缓冲区溢出漏洞。另一个应用领域是病毒搜索。由于恶意代码通常不可作为源代码获得，二进制分析是解决这一问题的一种有前景的方法。此外，我们希望我们的工作能够引起人们对防御机制内在问题的关注，这些机制允许攻击者在其行动中有很大的自由度。

### 致谢
本研究得到了国家科学基金会的资助，资助编号为CCR-0209065和CCR-0238492。

### 参考文献
[略]

---

以上是对原文的优化，使其更加清晰、连贯和专业。希望对你有所帮助！