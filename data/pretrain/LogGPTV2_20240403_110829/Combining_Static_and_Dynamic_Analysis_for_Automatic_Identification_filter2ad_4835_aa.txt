title:Combining Static and Dynamic Analysis for Automatic Identification
of Precise Access-Control Policies
author:Paolina Centonze and
Robert J. Flynn and
Marco Pistoia
23rd Annual Computer Security Applications Conference
23rd Annual Computer Security Applications Conference
Combining Static and Dynamic Analysis for
Automatic Identiﬁcation of Precise Access-Control Policies
Paolina Centonze
IBM Watson Research Center
Hawthorne, New York, USA
PI:EMAIL
Robert J. Flynn
Polytechnic University
Brooklyn, New York, USA
ﬂPI:EMAIL
Marco Pistoia
IBM Watson Research Center
Hawthorne, New York, USA
PI:EMAIL
Abstract
Given a large component-based program, it may be very
complex to identify an optimal access-control policy, allow-
ing the program to execute with no authorization failures
and no violations of the Principle of Least Privilege. This
paper presents a novel combination of static and dynamic
analysis for automatic determination of precise access-
control policies for programs that will be executed on Stack-
Based Access Control systems, such as Java and the Com-
mon Language Runtime (CLR). The static analysis soundly
models the execution of the program taking into account na-
tive methods, reﬂection, and multi-threaded code. The dy-
namic analysis interactively reﬁnes the potentially conser-
vative results of the static analysis, with no need for writing
or generating test cases or for restarting the system if an
authorization failure occurs during testing, and no risk of
corrupting the underlying system on which the analysis is
performed.
We implemented the analysis framework presented by
this paper in an analysis tool for Java programs, called
Access-Control Explorer (ACE). ACE allows for automatic,
safe, and precise identiﬁcation of access-right requirements
and library-code locations that should be made privilege-
asserting to prevent client code from requiring unnecessary
access rights. This paper presents experimental results ob-
tained on large production-level applications.
1
Introduction
Deﬁning the security policy of a program is a challeng-
ing activity, which becomes particularly difﬁcult when the
program is large and complex and consists of multiple com-
ponents.1 Ideally, the security policy should be just sufﬁ-
1As an example, the Eclipse community [9] is currently undergoing a
very expensive process to enable Java security on the Rich Client Platform
(RCP) [10]. This requires determining the authorization and privilege-
cient for the program to run without authorization failures.
Any access right unnecessarily granted to the program or its
users is a violation of the Principle of Least Privilege [31].
Modern component-based software systems, such as
Java [27] and Microsoft .NET Common Language Runtime
(CLR) [13], have adopted a form of authorization checking
called Stack-Based Access Control (SBAC); when access to
a restricted resource is attempted, a stack inspection ensures
that all the code on the call stack is sufﬁciently authorized.
In SBAC systems, when library code is developed, an
important decision that needs to be made is whether the
portion of library code requesting an access right should
be made privilege-asserting. This causes the run-time
stack inspection to stop at the library level. As a result,
client code is exempted from the requirement to exhibit
the access right requested by the library. For example,
a library providing socket connections to its clients may
have been programmed to log the network operations to a
ﬁle. While it is reasonable to impose that the client code
be granted the necessary SocketPermission, it is not
reasonable to impose that any client code be granted the
FilePermission to write to the log ﬁle. If client code
had to be granted that FilePermission, a violation of
the Principle of Least Privilege would arise; a malicious
client could misuse that permission to log false informa-
tion. Clearly, privilege-asserting code should be inserted
cautiously because when client code is above privilege-
asserting code on the stack, its access rights are not veriﬁed.
Traditionally, security policies are deﬁned using a com-
bination of source-code inspection and testing. However,
for large and complex programs, manual code inspections
may be impractical, tedious, time consuming, and error
prone. This type of analysis may even be infeasible if source
code is unavailable, which is the case if the program was
machine generated or written by a third party. On the other
hand, testing requires writing or generating test cases, exe-
assertion requirements of the entire RCP. Part of the static analysis work
described in this paper has been used to facilitate that goal.
1063-9527/07 $25.00 © 2007 IEEE
1063-9527/07 $25.00 © 2007 IEEE
DOI 10.1109/ACSAC.2007.39
DOI 10.1109/ACSAC.2007.39
292
292
cuting them, and logging all the authorization failures. For
each failure, it is necessary to identify the missing access
right, and decide whether that access right should be granted
or not. Since every authorization failure can cause a pro-
gram crash, for each failure occurring during testing it may
be necessary to grant the missing authorization and restart
the program. Furthermore, testing is unsound since some
paths of execution, along with the access rights required
to execute those paths, may remain undiscovered until the
code is deployed. Another problem is that the system on
which the tests are performed can become corrupted if the
program being tested is malicious or behaves incorrectly.
may be unsound for several reasons:
An interesting alternative is static analysis. With static
analysis, a model of the execution of the program is cre-
ated, and the access rights necessary to execute the program
are obtained from the model of the execution rather than
from the execution itself. In general, given a program, the
execution model built by the static analyzer is a conserva-
tive overapproximation of any run-time program execution.
While it guarantees soundness, this also means that a static
analyzer may include in the model infeasible events (false
alarms). Thus, blindly granting to a program all the au-
thorization requirements reported by a static analyzer may
easily generate violations of the Principle of Least Privilege.
While theoretically sound, in practice a static analyzer
• Multi-language Code. Today’s large and complex ap-
plications are likely to comprise components written
in different languages. For example, a Java program
is almost always going to trigger the execution of sev-
eral native methods, written in C and executed directly
on the underlying operating system [33]. A static an-
alyzer purely for Java will not be able to model the
control and data ﬂow generated by those methods. As
a result, the analysis will be incomplete and unsound,
failing to report actual authorization requirements.
• Reﬂection. Reﬂection is a mechanism that enables
code to dynamically discover and manipulate ﬁelds
and methods of loaded classes [33]. Modeling re-
ﬂection through static analysis is potentially unsound
since the type of the objects obtained through reﬂec-
tion is often known and available only at run time [21].
• Callbacks. A library callback is a method invocation
whose receiver is a parameter passed to the library by
a client. Libraries are typically analyzed as incomplete
programs [30] since clients are likely to be available
only at run time. For example, let foo be a library
method taking a parameter of type T and invoking
method bar on that parameter. A client program can
create an object t of type T and pass it to foo by call-
ing foo(t). As a result, foo will execute callback
t.bar. If neither T nor T.bar are ﬁnal, a client pro-
gram could subclass T and override method bar, caus-
ing bar to arbitrary access restricted resources that are
unknown at static-analysis time.
In essence, neither dynamic analysis nor static analysis can
independently guarantee the identiﬁcation of a policy sufﬁ-
cient to execute a program and yet not too permissive. This
paper presents a novel combination of static and dynamic
analysis extending previous work that was completely based
on static analysis [20, 26, 37]. The contribution of this
paper is to achieve precise identiﬁcation of authorization
and privilege-assertion requirements in SBAC systems. The
main characteristics of the static analyzer that contribute to
its precision are the following:
1. A scalable but precise context- sensitivity level [30]
2. An automatic model generator for native methods
based on language transformation and sound with re-
spect to the security analysis described in this paper
3. A sound models for reﬂection and callbacks
4. A complete model of the stack inspection mechanism,
which includes privilege-asserting and multi-threaded
code
The dynamic analysis framework described in this paper
is completely novel and includes the following components:
1. A sandboxing environment that protects the underly-
ing system on which the analysis is performed from
malicious or bad-performing programs
2. A conﬁgurable framework allowing the dynamic
analyzer to automatically detect authorization and
privilege-assertion requirements in the presence of dif-
ferent security subsystems and to automatically form
the security policy of a component-based program
3. An interactive system for authorization decisions, al-
lowing the user to precisely identify the code loca-
tion responsible for each authorization and privilege-
assertion requirement
4. A mechanism for immediate identiﬁcation of the secu-
rity side effects of any method invocation
5. An automatic mechanism for policy minimization that
eliminates redundant policy requirements
The static and dynamic analysis described in this paper
has been implemented in a tool for Java programs called
Access-Control Explorer (ACE). This paper presents the re-
sults obtained by running ACE on production-level code.
2 Motivating Examples
This section motivates the importance of combining
static and dynamic analysis for precise identiﬁcation of au-
thorization and privilege-assertion requirements.
2.1 Authorization Analysis
In Java, access rights are implemented as objects
of class Permission or one of its subclasses. A
293293
Permission object is completely characterized by the
fully-qualiﬁed name of the Permission subclass, along
with the String parameters representing the target and
the mode of access, as in java.io.FilePermission
"C:/log.txt", "read".
Stack inspection is per-
formed by function checkPermission in Java and
Demand in the CLR.
import java.io.*;
import java.net.*;
public class SecurityLibrary {
private String dir = "C:";
private String file = "log.txt";
private String name;
public FileInputStream readLogFile1()
throws Exception {
return new FileInputStream
(dir + File.separator + file);
}
public FileInputStream readLogFile2()
throws Exception {
file = "audit.txt";
return new FileInputStream
(dir + File.separator + file);
}
public FileInputStream readLogFile3
(String fileName)throws Exception {
return new FileInputStream(fileName);
}
public String getSystemProperty1() {
if (Math.sqrt(4) > 0)
return System.getProperty("user.home");
else
return System.getProperty("user.dir");
}
private void changeName() {
name = "user.dir";
}
public String getSystemProperty2() {
name = "user.name";
changeName();
return System.getProperty(name);
}
public void changeClassLoader()
throws Exception {
Thread t = Thread.currentThread();
URL[] urlArray = new URL[] {
new URL("http://abc.xyz.com") };
URLClassLoader loader =
new URLClassLoader(urlArray);
t.setContextClassLoader(loader);
}
}
Figure 1. SecurityLibrary.java
Figure 1 shows the example of a library requesting au-
thorizations. The static analysis framework presented in this
paper can help a developer and system administrator detect
a superset of the library’s authorization requirements but, as
observed in Section 1, a purely static analysis approach is
limited due to conservativeness and unsoundness. For the
294294
example of Figure 1, such limitations would manifest them-
selves as follows:
• The permissions required by readLogFile1 and
readLogFile2 cannot be easily evaluated with just
static analysis; even a static analysis engine that
keeps track of String constants is unable to eval-
uate the expression dir + File.separator +
file, unless it performs String computations.
• For method getSystemProperty1, a path in-
sensitive [30] static analyzer
is unable to com-
pute that java.util.PropertyPermission
"user.home", "read" is the only permission re-
quired to execute getSystemProperty1. Re-
porting a java.util.PropertyPermission
is a false
"user.dir", "read" requirement
alarm.
• To account for multi-threaded applications, static
analyzers
ﬂow
insensitive [30] and do not perform interproce-
dural strong updates [22].
As a consequence,
although
java.util.PropertyPermission
"user.dir", "read" is the only permission
execute getSystemProperty2,
required
an
an-
alyzer will also report an unnecessary require-
ment
for java.util.PropertyPermission
"user.name", "read".
interprocedurally ﬂow-insensitive
interprocedurally
typically
static
• A static analyzer for Java will
the
typically not de-
tect
java.lang.RuntimePermission
of method
"setClassLoader" requirement
changeClassLoader since the receiver of the
setContextClassLoader method call, t,
is
obtained as the return value of the call to method
Thread.currentThread, which is native and, as
such, not modeled by the analyzer. This false negative
leads to unsound results.
are
to
A purely dynamic analysis approach is often limited too for
the unsoundness generated by the absence of a complete
suite of test cases. For example:
is that
• The java.io.FilePermission needed
by
readLogFile3 has the special >
target, indicating the entire ﬁle system. The reason
for this broad requirement
the exact ﬁle
to be read depends from the parameter passed to
readLogFile3 by the client code. While a static
analyzer can correctly model
this requirement, a
dynamic analyzer will show a different target every
time readLogFile3 is invoked with a different
parameter.
• Using dynamic analysis to detect the authorization
requirement for readLogFile1 leads to test-case-
dependent analysis results. In fact, a test case invoking
readLogFile1 before readLogFile2 shows a
java.io.FilePermission "C:/log.txt",
"read" requirement. Conversely, a test case invok-
ing readLogFile1 after readLogFile2 shows
for java.io.FilePermission
a requirement
"C:/audit.txt", "read",
the reason being
that readLogFile2, as a side effect, changes the
value of file from log.txt to audit.txt. This
shows that any dynamic analysis for authorization-
requirement identiﬁcation needs to take side effects
into account.
While it is always possible to improve a static or dynamic
analyzer to identify authorization requirements with higher
precision, static and dynamic analysis are always going to
present limitations leading to imprecise policy deﬁnitions.
The solution presented in this paper eliminates such impre-
cisions by combining the two approaches.
In the CLR, privilege-asserting code is achieved by call-
ing the Assert function, which can be seen as a pa-
rameterized version of doPrivileged.
In fact, unlike
doPrivileged, Assert takes an IPermission ob-
ject as a parameter. The effect is that the stack inspec-
tion is truncated only if the IPermission object being
checked is the same as, or weaker than, the one passed to
Assert. From this point of view, Assert is more se-
cure than doPrivileged, which truncates the stack in-
spection indiscriminately. The static and dynamic analy-
sis algorithms described in this paper can be used to make
doPrivileged equivalent to Assert by precisely con-
trolling the Permission checks from which client code is
shielded and by only recommending insertions of privilege-
asserting code as close to the authorization checks as possi-
ble.
2.2 Privilege-Asserting-Code Analysis
3 Static Analyzer
into a call
A Java developer can make a portion of
library
to
code privilege-asserting by wrapping it
doPrivileged. Method createSocket in Figure 2
opens a socket on behalf of its clients, but upon doing so, it
logs the operation to a ﬁle. To prevent its clients (which will
be on the stack) from requiring the FilePermission
to write to the log ﬁle, the logging operation is wrapped
into a call to doPrivileged. For large and complex li-
braries, it is very difﬁcult to detect manually which portions
of code should be made privilege-asserting, and to identify
the sets of permissions that library code implicitly grants to
its clients by virtue of calling doPrivileged. This paper
shows how a synergy of static and dynamic analysis can be
used to make this process both automatic and precise.
import java.io.*;
import java.net.*;
import java.security.*;
public class SecurityLibrary2 {
private final String logFileName = "C:\\log.txt";