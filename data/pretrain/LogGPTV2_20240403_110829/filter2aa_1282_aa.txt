www.LIFARS.com 
PI:EMAIL  
©2022 SecurityScorecard Inc. 
244 Fifth Avenue, Suite 2035, 
New York, NY 10001 
1.212.222.7061 
Prepared by:     Vlad Pasca, LIFARS, LLC 
Date: 
 02/14/2022 
A Detailed Analysis 
of The LockBit 
Ransomware 
www.LIFARS.com |  1 
Table of Contents 
Executive Summary .............................................................................................................. 2 
Analysis and Findings .......................................................................................................... 2 
Thread activity – sub_4DF310 function ........................................................................ 10 
Thread activity – sub_4C3430 function ....................................................................... 14 
Thread activity – sub_4A2EC0 function ....................................................................... 19 
Thread activity – sub_45C960 function....................................................................... 28 
Thread activity – sub_497060 function ....................................................................... 34 
Thread activity – sub_49E730 function ....................................................................... 39 
Printing ransom notes ...................................................................................................... 44 
LockBit Wallpaper Setup ................................................................................................. 46 
Extract and save the HTA ransom note to Desktop .............................................. 52 
Indicators of Compromise ............................................................................................... 59 
Registry Keys ................................................................................................................................................................................... 59 
Files Created .................................................................................................................................................................................... 59 
Processes spawned ..................................................................................................................................................................... 59 
Mutex ................................................................................................................................................................................................... 60 
LockBit 2.0 Extension ................................................................................................................................................................ 60 
LockBit 2.0 Ransom Note ....................................................................................................................................................... 60 
Appendix ................................................................................................................................. 61 
List of processes to be killed ................................................................................................................................................... 61 
List of services to be stopped ................................................................................................................................................. 61 
www.LIFARS.com |  2 
Executive Summary  
LockBit 2.0 ransomware is one of the most active families in the wild and pretends to implement 
the fastest encryption algorithms using multithreading with I/O completion ports. The malware 
doesn’t encrypt systems from CIS countries and can perform UAC bypass on older Windows 
versions if running with insufficient privileges. A hidden window that logs different actions 
performed by LockBit is created and might be activated using the Shift+F1 shortcut. The 
ransomware mounts all hidden volumes and stops a list of targeted processes and services. The 
malware generates a pair of ECC (Curve25519) session keys, with the private key being encrypted 
using a hard-coded ECC public key and stored in the registry. The binary deletes all Volume 
Shadow Copies using vssadmin and clears the Windows security application and system logs. 
LockBit obtains a list of physical printers used to print multiple ransom notes. The encrypted files 
have the “.lockbit” extension, and only the first 4KB of the file will be encrypted using the AES 
algorithm. A unique AES key is generated for each file, encrypted using the session ECC public 
key, and stored in each encrypted file. 
Analysis and Findings 
SHA256: 9feed0c7fa8c1d32390e1c168051267df61f11b048ec62aa5b8e66f60e8083af 
The malware verifies whether it’s being debugged by checking the NtGlobalFlag field from the 
PEB (process environment block). If the debugger is detected, the process jumps to an infinite 
loop:  
Figure 1 
www.LIFARS.com |  3 
The encrypted strings are stored as stack strings and will be decrypted using the XOR operator. 
An example of a decryption algorithm is shown in figure 2, along with the decrypted DLL name: 
Figure 2 
The binary implements the API hashing technique to hide the API functions used. As we can see 
below, the malware computes a 4-byte hash value and compares it with a hard-coded one 
(0xA3E6F6C3 in this case): 
Figure 3 
The malicious executable loads multiple DLLs into the address space of the process using the 
LoadLibraryA API: 
www.LIFARS.com |  4 
Figure 4 
The following DLLs have been loaded: "gdiplus.dll", "ws2_32.dll", "shell32.dll", "advapi32.dll", 
"user32.dll", "ole32.dll", "netapi32.dll", "gpedit.dll", "oleaut32.dll", "shlwapi.dll", "msvcrt.dll", 
"activeds.dll", "mpr.dll", "bcrypt.dll", "crypt32.dll", "iphlpapi.dll", "wtsapi32.dll", "win32u.dll", 
"Comdlg32.dll", "cryptbase.dll", "combase.dll", "Winspool.drv". 
GetSystemDefaultUILanguage is utilized to retrieve the language identifier for the system default 
UI language of the OS. The return value is compared with multiple identifiers that correspond to 
CIS countries (LockBit doesn’t encrypt these systems): 
Figure 5 
Figure 6 
The following language identifiers have been found: 
• 
0x82c - Azerbaijani (Cyrillic) 
• 
0x42c - Azerbaijani (Latin) 
• 
0x42b – Armenian 
www.LIFARS.com |  5 
• 
0x423 – Belarusian 
• 
0x437 – Georgian 
• 
0x43F – Kazakh 
• 
0x440 – Kyrgyz 
• 
0x819 - Russian (Moldova) 
• 
0x419 – Russian 
• 
0x428 – Tajik 
• 
0x442 – Turkmen 
• 
0x843 - Uzbek (Cyrillic) 
• 
0x443 - Uzbek (Latin) 
• 
0x422 – Ukrainian 
The GetUserDefaultUILanguage routine extracts the language identifier for the user UI language 
for the current user. The extracted value is compared with the same identifiers from above: 
Figure 7 
The NtQuerySystemInformation function is utilized to retrieve the number of processors in the 
system (0x0 = SystemBasicInformation): 
Figure 8 
The binary opens a handle to the current process (0x60000 = WRITE_DAC | READ_CONTROL): 
Figure 9 
www.LIFARS.com |  6 
The GetSecurityInfo API is utilized to retrieve a pointer to the DACL in the returned security 
descriptor (0x6 = SE_KERNEL_OBJECT, 0x4 = DACL_SECURITY_INFORMATION): 
Figure 10 
RtlAllocateAndInitializeSid is used to allocate and initialize a SID (security identifier) structure: 
Figure 11 
The file extracts the ACL size information via a function call to RtlQueryInformationAcl (0x2 = 
AclSizeInformation): 
Figure 12 
The executable allocates memory by calling the ZwAllocateVirtualMemory routine (0x3000 = 
MEM_COMMIT | MEM_RESERVE, 0x4 = PAGE_READWRITE). It’s also important to mention that 
LockBit frees memory previously allocated using ZwFreeVirtualMemory: 
Figure 13 
www.LIFARS.com |  7 
The RtlCreateAcl function is utilized to create and initialize an access control list (0x4 = 
ACL_REVISION_DS): 
Figure 14 
The RtlAddAccessDeniedAce routine is used to add an access-denied access control entry (ACE) 
to the ACL created earlier (0x4 = ACL_REVISION_DS, 0x1 = FILE_READ_DATA): 
Figure 15 
The malicious file obtains a pointer to the first ACE in the ACL via a function call to RtlGetAce: 
Figure 16 
The process adds an ACE to the ACL previously created using RtlAddAce (0x4 = 
ACL_REVISION_DS): 
Figure 17 
LockBit sets the DACL of the current process to the ACL modified earlier by calling the 
SetSecurityInfo API (0x6 = SE_KERNEL_OBJECT, 0x4 = DACL_SECURITY_INFORMATION): 
www.LIFARS.com |  8 
Figure 18 
The malware modifies the hard error mode in a way that some error types are not displayed to 
the user (0xC = ProcessDefaultHardErrorMode, 0x7 = SEM_FAILCRITICALERRORS | 
SEM_NOGPFAULTERRORBOX | SEM_NOALIGNMENTFAULTEXCEPT): 
Figure 19 
The ransomware enables the SeTakeOwnershipPrivilege privilege in the current process token 
(0x9 = SeTakeOwnershipPrivilege): 
Figure 20 
LockBit decrypts a list of processes and services that will be stopped during the infection (the 
entire list can be found in the appendix): 
Figure 21 
www.LIFARS.com |  9 
Figure 22 
The malware calls the ZwOpenProcessToken API in order to open the access token associated 
with the current process (0x8 = TOKEN_QUERY): 
Figure 23 
GetTokenInformation is utilized to extract the user account of the token (0x1 = TokenUser): 
Figure 24 
The AllocateAndInitializeSid routine is used to allocate and initialize a security identifier (SID) with 
a single subauthority: 
Figure 25 
The executable compares two security identifier (SID) values using the EqualSid API: 
www.LIFARS.com |  10 
Figure 26 
There is a recurrent function call to GlobalMemoryStatusEx that retrieves information about the 
current usage of both physical and virtual memory: 
Figure 27 
LockBit creates a new thread using the CreateThread API, which will run the sub_4DF310 
function: 
Figure 28 
ZwSetInformationThread is used to hide the thread from our debugger however, the x32dbg’s 
plugin called ScyllaHide can circumvent its effect (0x11 = HideThreadFromDebugger): 
Figure 29 
Thread activity – sub_4DF310 function 
The shutdown priority for the current process relative to other processes in the system is set to 0, 
which means that it’s set to be the last process to be shut down: 
Figure 30 
www.LIFARS.com |  11 
GetSystemDirectoryW is utilized to retrieve the path of the system directory: 
Figure 31 
The process creates an activation context and activates it using the CreateActCtxW and 
ActivateActCtx routines: 
Figure 32 
Figure 33 
The binary registers and initializes specific common control window classes using the 
InitCommonControls API: 
Figure 34 
GdiplusStartup is used to initialize Windows GDI+: 
Figure 35 
The malicious file initializes the COM library on the current thread: 
Figure 36 
The GetVersion routine is used to retrieve the operating system version: 
www.LIFARS.com |  12 
Figure 37 
CreateStreamOnHGlobal is utilized to create a stream object that uses an HGLOBAL memory 
handle to store the content: 
Figure 38 
The stream content is modified, and the process uses the GdipCreateBitmapFromStream 
function to create a Bitmap object based on the stream: 
Figure 39 
The malware loads the standard arrow cursor resource via a function call to LoadCursorW 
(0x7F00 = IDC_ARROW): 
Figure 40 
GdipAlloc is utilized to allocate memory for a Windows GDI+ object: 
Figure 41 
There is another call to GdipCreateBitmapFromStream followed by a call to GdipDisposeImage, 
which releases resources used by the Image object: 
Figure 42 
www.LIFARS.com |  13 
LockBit registers a window class called “LockBit_2_0_Ransom” using the RegisterClassExW API: 
Figure 43 
CreateWindowExW is used to create a window called "LockBit 2.0 Ransom" that will track the 
progress of the ransomware, such as the identified drives and different logs: 
Figure 44 
The new window is hidden using the ShowWindow routine (0x0 = SW_HIDE): 
Figure 45 
The UpdateWindow function is utilized to update the client area of the specified window by 
sending a WM_PAINT message to the window: 
Figure 46 
The process creates a new thread by calling the CreateThread function: 
Figure 47 
www.LIFARS.com |  14 
LockBit defines a Shift+F1 hot key for the new window that can be used to unhide it (0x70 = VK_F1, 
0x4 = MOD_SHIFT): 
Figure 48 
Figure 49 
GetMessageW is used to retrieve a message from the thread’s message queue: 
Figure 50 
The malicious file translates virtual-key messages into character messages via a call to 
TranslateMessage: 
Figure 51 
DispatchMessageW is utilized to dispatch a message retrieved by the GetMessage function: 
Figure 52 
Thread activity – sub_4C3430 function 
The process sends the LVM_GETITEMCOUNT message to the newly created window (0x1004 = 
LVM_GETITEMCOUNT): 
www.LIFARS.com |  15 
Figure 53 
The malware calls the InvalidateRect API many times to add multiple rectangles to the window’s 
update region: 
Figure 54 
We continue with the analysis of the main thread. 
The CommandLineToArgvW routine obtains an array of pointers to the command line 
arguments: 
Figure 55 
The file tries to see if the access token is elevated by calling the NtQueryInformationToken API 
(0x14 = TokenElevation): 
Figure 56 
Depending on the result, the malware proceeds by decrypting the "[+] Process created with 
admin rights" or "[-] Process created with limited rights" strings. We know that this sample is 
supposed to perform UAC bypass in the case of low-level privileges however, this method wasn’t 
employed on our Windows 10 analysis machine (it’s supposed to be used on older Windows 
versions). 
The process sends the "[+] Process created with admin rights" message to the hidden window by 
calling the SendMessageA API: 
www.LIFARS.com |  16 
Figure 57 
The binary creates a mutex called "\\BaseNamedObjects\\{3FE573D4-3FE5-DD38-399C-
886767BD8875}" to ensure that only one instance of the malware is running at one time 
(0x1F0001 = MUTEX_ALL_ACCESS):  
Figure 58 
The NetBIOS name of the local computer is extracted using GetComputerNameW: 
Figure 59 
The malicious executable retrieves the name of the primary domain controller by calling the 
NetGetDCName function. LockBit has the ability to propagate on the network and kill processes 
and services via malicious GPOs (group policy objects); however, these features weren’t activated 
in this sample: 
Figure 60 
The 
process 
opens 
the 
Run 
registry 
key 
using 
RegCreateKeyExA 
(0x80000001 
= 
HKEY_CURRENT_USER, 0x2001F = KEY_READ | KEY_WRITE): 
www.LIFARS.com |  17 
Figure 61 
The file is looking for a registry value called "{9FD872D4-E5E5-DDC5-399C-396785BDC975}": 
Figure 62 
The malware establishes persistence by creating the above registry value: 
Figure 63 
Figure 64 
CreateThread is used to create a new thread within the address space of the process: 
Figure 65 
www.LIFARS.com |  18 
As in the case of every thread creation, the binary tries to hide it from the debugger using the 
ZwSetInformationThread API. 
A file called "C:\windows\system32\2ED873.ico" is created via a function call to ZwCreateFile 
(0x40000000 
= 
GENERIC_WRITE, 
0x80 
= 
FILE_ATTRIBUTE_NORMAL, 
0x5 
= 
FILE_OVERWRITE_IF): 
Figure 66 
The ICO file is populated using the  ZwWriteFile routine: 
Figure 67 
The executable creates the “HKCR\.lockbit” registry key using ZwCreateKey (0x2000000 = 
MAXIMUM_ALLOWED): 
Figure 68 
www.LIFARS.com |  19 
LockBit creates the DefaultIcon subkey and sets its value to the newly created ICO file, as 
highlighted below: 
Figure 69 
Figure 70 
Thread activity – sub_4A2EC0 function 
The FindFirstVolumeW API is utilized to begin scanning the volumes of the computer: 
Figure 71 
QueryDosDeviceW is used to obtain the current mapping for the above volume: 
Figure 72 
The malware retrieves a list of drive letters for the specified volume via a call to 
GetVolumePathNamesForVolumeNameW: 
Figure 73 
www.LIFARS.com |  20 
The drive type of the volume is extracted using GetDriveTypeW: 
Figure 74 
The malicious process sends a message regarding the identified volume to the LockBit hidden 
window, as displayed in figure 75. 
Figure 75 
The malicious file continues the volume search via a function call to FindNextVolumeW: 
Figure 76 
The purpose of the malware is to find unmounted volumes and mount them. 
LockBit tries to open the BOOTMGR file from the volume (0x80000000 = GENERIC_READ, 0x3 = 
FILE_SHARE_READ 
| 
FILE_SHARE_WRITE, 
0x3 
= 
OPEN_EXISTING, 
0x80 
= 
FILE_ATTRIBUTE_NORMAL): 
Figure 77 
An unmounted volume is mounted by calling the SetVolumeMountPointW routine: 
www.LIFARS.com |  21 
Figure 78 
Figure 79 
LockBit sends a message regarding the successful mount operation to the hidden window (see 
figure 80). After the enumeration is complete, the thread exits by calling the RtlExitUserThread 
function. 
Figure 80 
The binary calls the SHChangeNotify API with the SHCNE_ASSOCCHANGED parameter 
(0x8000000 = SHCNE_ASSOCCHANGED): 
Figure 81 
A new thread is created by the malware using CreateThread: 
Figure 82 
Intel and AMD CPUs implement a functionality called “AES-NI” (Advanced Encryption Standard 
New Instructions), which can be used for high-speed AES encryption processing. The binary uses 
the cpuid instruction in order to retrieve the CPU type of the machine and the vendor of the CPU: 
www.LIFARS.com |  22 
Figure 83 
Whether the CPU supports “AES-NI” the process sends the "[+] AES-NI enabled" message to the 
hidden window using SendMessageA. 
The malicious process generates 16 random bytes by calling the BCryptGenRandom routine (0x2 
= BCRYPT_USE_SYSTEM_PREFERRED_RNG): 