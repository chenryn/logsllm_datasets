7
8
9
10
11
12
13
14
15
Analyze( CurIE, i )
the current isolated execution CurIE, and a basic block BB that will
be analyzed (Line 1). Note that there are multiple isolated execu-
tions, and each isolated execution can start at any basic blocks.
Precisely, MalMax’s analysis can start at any statements (i.e., in-
structions) of a program. In this algorithm, we use basic blocks
for simplicity. CreateIsolatedExecution creates a new isolated
execution which inherits execution contexts (e.g., the instruction
pointer, states of variables) from the current isolated execution.
UpdateIsolatedExecution updates execution state (e.g., values
of global scope artifacts) of an isolated execution.
It executes each instruction from the beginning of the input
basic block (Line 2). When it encounters a branch instruction, it
executes all branches of the instruction (Lines 3-6), running the
taken branch within the same isolated execution (Line 4) and the
not-taken branch in a new isolated execution (Line 5-6). Note that
calling Exercise with the current isolated execution is specially
handled (Line 4). Specifically, it will continue the execution and
analysis without forming a recursion.
Lines 7-14 represent the global resource sharing scheme in co-
operative isolated execution. If an instruction accesses unresolved
artifact (e.g., a function that is not defined, an environment variable
that is not set, etc.) (Line 7), MalMax looks at other available isola-
tions that have resolved the artifact (Lines 8-10). For each resolved
artifact, MalMax creates a new isolation with the resolved artifact
(e.g., function definition) (Lines 12-13) to exercise the path with a
new context with the shared artifact (Lines 14).
Finally, we conduct an analysis for every instruction (Line 15).
B.1 Design Rationale
The rationale behind counterfactual execution and cooperative
isolated execution is the design and behavior of popular, sizable
real-world applications such as Wordpress, Joomla, and several
other PHP applications [10]. In this section, we will review some
of these design patterns.
Autoloading Classes (Autoloaders). Autoloaders [54] are a PHP
feature that enable classes and interfaces to be automatically loaded
if they are not yet defined. Autoloaders find the respective source
code file that contains the class definition and include it into the
program, allowing the class definition to exist prior to object in-
stantiation.
Many real-world PHP applications (e.g., Joomla and Wordpress)
pervasively use autoloaders. As noted in Section 4.4, Joomla has
2,476 PHP source code files, but only 522 are statically loaded via
include and require statements, meaning that the majority of
files are included with a dynamic include call (e.g., autoloaders).
Specifically, Joomla has 4 polymorphic classes for web session han-
dling, respectively relying on files, databases (e.g., MySQL [50]),
in-memory stores (e.g., Memcached [45], Redis [59]) and native
PHP sessions. Depending on application configurations, Joomla
constructs a dynamic class name of one of the 4 polymorphic classes
and instantiates the object for session handling. The constructed
dynamic class name is processed by the autoloader to include a
PHP source code file for the class.
Without knowing the configuration parameter, an analysis en-
gine is likely to miss a large portion of the code (e.g., the session
handler classes), leading to an under-approximation of the analysis
results (e.g., breaking many features of the program).
Pervasiveness of Plugin Architecture. PHP applications such
as Wordpress and Joomla have vast repositories of popular plug-
ins (e.g., 55,137 plugins for Wordpress as of this writing). These
plugins are created and maintained by third-party developers, and
often have various vulnerabilities which are commonly targeted
by malicious attackers. The plugins are simply copied inside the
application directory, and their initialization code is loaded from
the database and dynamically executed as part of the application
initialization on each run.
0510152025303540m1m2m3m4m5m6m7m8m9m10m11m12m13m14m15m16m17m18m19m20m21m22m23m24m25m26m27m28m29m30m31m32m33m34m35m36m37m38m39m40m41m42m43m44m45m46m47m48m49m50m51m52sb1sb2sb3sb4s5sm1sm2sm3sm4sm5PMFR/MS ScoresMalicious and Benign SamplesMSPMFR (scaled: multiplied by 4)Wordpress introduces pluggable functions [75] to facilitate plugin
developments. Pluggable functions let you override certain core
functions via plugins, meaning that their definitions can be overrid-
den by a plugin dynamically. For instance, there are many plugins
that override Wordpress’s email sending functions, allowing users
to modify the contents of emails sent. (cid:3)
The prevalent usage of autoloaders and plugins in PHP appli-
cations motivate us to propose counterfactual execution aided by
cooperative isolation. The dynamic function names, file names and
class names are discovered in different isolated executions (many
of which are counterfactual), and shared with others via cooper-
ative isolation. For example, if an isolated execution attempts to
run a pluggable function wp_mail which is not yet defined, instead
of terminating, MalMax creates a new isolated execution with a
borrowed function definition from another isolated execution to
continue the execution.
B.2 Measuring Code Coverage Improvement
Table 6 shows code coverage results of scanning Wordpress
and Joomla with dynamic analysis, multi-path exploration (our
implementation) and counterfactual execution with cooperative
isolated execution.
In this experiment, code coverage is measured via covered lines
of code divided by total lines of code in the program. If there is
dynamically generated code (e.g., via eval()), we count it. Hence,
code coverage can go beyond 100%.
Observe that cooperative isolated execution is crucial in discov-
ering more code. In particular, it achieves 25.6% and 19% more code
coverage than multi-path exploration scheme without cooperative
isolated execution for Wordpress and Joomla respectively. Cooper-
ative isolated execution increases analysis time by about 10% (57s
and 40s for Wordpress and Joomla respectively), and increases code
coverage by more than 20%.
Note that MalMax did not achieve full code coverage (i.e., 100%).
Our manual inspection reveals that there are many unused code files
in each copy of the application. For example, the session handler
scenario in Joomla mentioned above results in existence of 4 files,
each representing one class for session handling, only one of which
is realistically utilized in each copy of Joomla, leaving the other 3
files unused. These unused files are counted towards total lines of
code as they exist in the same program folder.
Dynamic1 Multi-path2 MalMax 3
T4
C5
T4
579s 81.6%
Wordpress 4.2.2 10.1s
67%
525s
C5
T4
49% 522s
9.5s 21.7% 485s
C5
56%
48%
Joomla 3.5.1
State-
ments
58786
95271
LOC
262K
472K
1: Vanilla dynamic execution. 2: Multi-path exploration.
3: Counterfactual execution + cooperative isolated execution. 4: Time.
5: Coverage. 6: Result includes dynamically generated code (e.g., eval).
Table 6: Coverage of main component (starting from in-
dex.php) of different PHP applications.
C MALWARE DETECTION METRICS
Observations. We observe that malware (including the notorious
c99 [58] and other Webshells) densely utilize functions that inspect
and modify the operating system and execution environment. How-
ever, some of these functions are also used in benign applications.
Moreover, we notice that in practice, malware are injected in the
middle of benign applications to make detection harder.
To minimize false positives caused by functions used by both
malware and benign applications, we assign different maliciousness
scores to a function based on the contents of function’s parameters.
For instance, we consider decompressing data to be malicious only
if the decompressed data includes parseable code.
We also consider functions that are executed as part of dynami-
cally generated code more malicious than those executed outside
dynamic code generation. This is because malware often hides its
payload through obfuscations that are commonly implemented
using dynamic code generation techniques. It is possible for a be-
nign application to obfuscate code blocks with high MS scores for
legitimate reasons. However, in our experience, this is very rare.
Determining Potentially Malicious Functions and Their Ma-
liciousness Scores. As mentioned in Section 3.3, we categorized
PHP functions into two categories: Potentially Malicious Functions
(PMF) and Safe Functions (SF). As listed in Table 7, 294 functions
were categorized as SF manually. SFs do not affect system state
hence they are executed normally and have a maliciousness score
of zero. The remainder of PHP functions are categorized as PMF.
In PHP 7.2 (with default extensions on macOS), there are 1,438
PMFs. To prevent PMFs from affecting the host system, the anal-
ysis replaces them with a function that immediately returns null.
MalMax neutralizes all functionalities that affect the system state.
PMFs have a maliciousness score of 1.
Besides, we have identified 31 functions that are frequently used
in both malicious and benign applications. To better capture the
execution context of these functions (i.e., whether the functions are
used in malware or not), we assign fine-grained scores for each of
the function as shown in Table 8 including reasons for the assigned
scores.
Specifically, functions for encoding/decoding, encryption/de-
cryption, and compression/decompression have different scores
depending on their parameters. For instance, I/O functions have a
higher maliciousness scores when they access the network, com-
pared to when they access the file system.
We assign a maliciousness score of 0 for the functions that initial-
ize or create objects (e.g., curl_init, fopen, and mysqli_init)
as these functions alone do not exhibit malicious behavior but subse-
quent operations on the created objects do. We assign maliciousness
scores 1 or 2 on the subsequent operations.
There are several functions that have a score of 0, including
unlink, getcwd, mkdir, and MySQL functions. As they are perva-
sively used in both malware and benign applications, we assign the
0 scores to avoid false positives. However, as they can affect the
host system state, we sandbox them.
Section 5 includes a sensitivity analysis of fine-grained scoring
on these 31 functions.
Safe Functions
abs, addcslashes, addslashes, apache_getenv, array_change_key_case, array_combine, array_diff, array_diff_assoc, array_fill, array_fill_keys, array_filter, array_flip,
array_intersect, array_intersect_key, array_key_exists, array_keys, array_map, array_merge, array_pop, array_push, array_replace, array_replace_recursive, array_reverse,
array_search, array_shift, array_slice, array_splice, array_unique, array_unshift, array_values, array_walk, array_walk_recursive, asort, assert, basename, bin2hex,
call_user_func, call_user_func_array, ceil, checkdate, chr, class_alias, class_exists, class_implements, closedir, compact, constant, count, create_function, crypt, curl_close,
curl_error, curl_getinfo, curl_setopt, curl_setopt_array, curl_version, current, date, date_create, date_default_timezone_get, date_default_timezone_set, date_format,
debug_backtrace, dechex, define, defined, dirname, dirname, dirname, each, end, error_log, error_reporting, explode, extension_loaded, extract, fclose, file_exists, filegroup,
filemtime, fileowner, fileperms, filesize, filter_var, floor, flush, flush, func_get_arg, func_get_args, func_get_args, func_num_args, function_exists, gd_info, get_class,
get_class_methods, get_defined_vars, get_html_translation_table, get_loaded_extensions, get_magic_quotes_gpc, get_object_vars, get_parent_class, getenv, gethostbyname,
glob, gmdate, hash_equals, hash_hmac, header, header_remove, headers_list, headers_sent, hex2bin, hexdec, html_entity_decode, htmlentities, htmlspecialchars,
http_build_query, iconv_set_encoding, implode, in_array, ini_get, interface_exists, intval, is_a, is_array, is_bool, is_callable, is_dir, is_file, is_float, is_int, is_null, is_numeric,
is_object, is_readable, is_resource, is_scalar, is_string, is_writable, join, json_decode, json_encode, key, krsort, ksort, ltrim, max, mb_check_encoding, mb_convert_encoding,
mb_detect_encoding, mb_internal_encoding, mb_strlen, mb_strpos, mb_strpos, mb_strrpos, mb_strstr, mb_strtolower, mb_substr, md5, memory_get_usage, method_exists,
microtime, min, mktime, move_uploaded_file, mt_rand, mysqli_errno, mysqli_error, mysqli_fetch_array, mysqli_fetch_assoc, mysqli_fetch_object, mysqli_fetch_row,
mysqli_free_result, mysqli_get_client_info, mysqli_get_server_info, mysqli_insert_id, mysqli_more_results, mysqli_num_fields, mysqli_num_rows, mysqli_ping,
mysqli_real_escape_string, mysqli_set_charset, next, nl2br, number_format, ob_end_clean, ob_end_flush, ob_flush, ob_get_clean, ob_get_contents, ob_get_flush, ob_get_level,
ob_implicit_flush, ob_start, openssl_decrypt, openssl_random_pseudo_bytes, ord, parse_ini_string, parse_str, parse_url, pathinfo, php_sapi_name, phpversion, pow, preg_grep,
preg_match, preg_match_all, preg_quote, preg_replace_callback, preg_split, prev, print_r, printf, property_exists, rand, random_byes, range, rawurldecode, rawurlencode,
readdir, readfile, realpath, register_shutdown_function, reset, round, rtrim, scandir, serialize, session_cache_limiter, session_destroy, session_get_cookie_params, session_id,
session_name, session_save_path, session_set_cookie_params, session_set_save_handler, session_start, session_status, session_unset, session_write_close, set_error_handler,
set_exception_handler, setcookie, setlocale, settype, sha1, simplexml_load_file, sizeof, sort, spl_autoload_register, spl_autoload_unregister, spl_object_hash, sprintf, str_ireplace,
str_pad, str_repeat, str_replace, str_split, strcasecmp, strip_tags, stripos, stripslashes, stristr, strlen, strpbrk, strpos, strrev, strrpos, strstr, strtolower, strtotime, strtoupper, strtr,
strval, substr, substr_count, substr_replace, sys_get_temp_dir, time, timezone_identifiers_list, timezone_open, trigger_error, trim, ucfirst, uksort, uniqid, unserialize, urldecode,
urlencode, usort, utf8_encode, var_dump, version_compare, vsprintf
Table 7: Safe functions (SFs) as used in PhpMalScan. These functions are executed normally and incur no maliciousness score
towards malware detection.
Function
base64_decode
base64_encode
chdir
curl_exec
curl_init
file_get_contents, file_put_contents Read/Write file/URL via stream
fopen
fread, fwrite
get_current_user
getmypid
gzcompress, gzdeflate
gzinflate, gzuncompress
mail
getcwd
ini_set
mkdir
mysqli_affected_rows
mysqli_connect
mysqli_init
mysqli_query
mysqli_real_connect
mysqli_select_db
opendir
preg_replace
rmdir
str_rot13
unlink
Table 8: Functions sandboxed in PhpMalScan to preserve correctness and increase detection accuracy. The insight for each
function as well as the respective maliciousness score is included.
Maliciousness Score
Description
2 if result is parseable code, 0 otherwise
Deobfuscate code before dynamic evaluation
2 if parseable code, 0 otherwise
Obfuscate new copies of malware
Change the working directory, commonly used in Webshells 2 if input variable, 0 if constant
2 if input variable, 1 if constant
Send HTTP requests
0
Initiate HTTP requests
2 on URL and other files, 1 on STDIN, 0 on working directory file
0
2 on URL and other files, 1 on STDIN, 0 on working directory file
1
1
2 if parseable code, 0 otherwise
2 if result is parseable code, 0 otherwise
1
0
0
0
0
0
0
0
0
0
0
2 if eval modifier present, 0 otherwise
1
1
0
Open file for reading/writing
Read/Write from file handle
Used by Webshells to determine access
Return the current process id
Compress data
Uncompress data
Send email
Get current working directory
Set PHP configuration parameters
Create directory
Return number of results for a SQL query
Connect to a MySQL server
Initiate a SQL query
Run a SQL query
Persistent connection to MySQL
Select a database
Open a directory for listing
Regular expression search and replace
Remove directory
Simple cipher, commonly used by weak malware
Remove a file