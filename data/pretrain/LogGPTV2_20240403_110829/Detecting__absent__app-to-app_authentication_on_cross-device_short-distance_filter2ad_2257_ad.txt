In this second case study we focus on real-world app that use Wi-Fi
Direct + [4] collected from the Google Play market. This file shar-
ing app has more than 500,000 downloads, it is constantly being
updated, and it has a paid version, Wi-Fi Direct + Pro. This infor-
mation definitely indicates that the app is relevant for our analysis.
Since this apps does not implement and app-to-app authentication
as revealed by our tool we can perform a data injection attack.
App Functionalities. Wi-Fi Direct + offers the possibility to share
file between two Android devices, via Wi-Fi-Direct protocol. After
performing Wi-Fi-Direct pairing, on one device the user should
select the option for receiving files. At this point, his device is
entering in listening mode for incoming connections. When the
user on the other device selects the option for sending a file. A
success dialog is then displayed on the receiving device and the file
is transferred.
Payload running. After pairing has been established, the app on
the receiving device opens a ServerSocket, and accepts connec-
tions on it. If a malicious app on the sending device tries to connect
to the socket, we have a typical CATCH scenario, in which the
receiving app is not able to distinguish legitimate and malicious
data. For the attack to succeed, some technical details have to be
considered. The attacker needs to study the Wi-Fi Direct + protocol
used to send files in order to replicate it without errors, then he
has to build a malicious app for sending files with this protocol. At
this point, by activating the sending of a file from the malicious
app at the right time, as explained in the previous case study, the
attacker is able to inject data in the communication with another
device. With Wi-Fi Direct + in particular, the useful time window
for data injection is reduced in comparison to the BluetoothChat
case study; this is because Wi-Fi Direct + on the receiving device
will accept only one file before closing the communication channel,
as opposed to BluetoothChat, which keeps listening for incoming
messages. This is a problem for the attacker: if the benign app
sends its file first, then the file sent by the malicious app will not
be accepted (race condition). If the opposite happens instead, the
benign file will be rejected, and the sending user will be notified
of an error. Depending on the situation, the users might verbally
communicate and establish that something suspicious happened.
This risk is always present, but it is greatly reduced in cases such as
BluetoothChat, where no error messages are displayed to the users.
Although we recognize this problem for the attacker in some cases,
we have to also consider the situations in which the users are not
able to identify the attack. For instance, the sending user receiving
an error message may think of a bug in the app, especially if the
receiving user confirms that the file has been correctly received
(his app will display the correctly received malicious file). In our
experiments we were able to perform the attack successfully. We
were able to run the malicious app and send a malicious file without
causing any alarm on the target device.
7 DISCUSSION
In this section we discuss about limitations of our analysis along
with impact of the problem that we found out.
7.1 Impact of the problem
From our research, it is clear that high-level, app-to-app authentica-
tion is almost never present in Android apps that communicate on
channels such as Bluetooth. Aside from the results of our algorithm
on the large dataset, we could not manually find apps performing
this type of authentication for the specific channels of our interest.
We postulate that this is due to a lack of awareness in programmers,
who build their code relying on sources such as the official An-
droid documentation, and the network Stack Overflow for learning
how to use a particular technology (e.g. Bluetooth). It is common
to reuse sample code snippets from these sources with minimal
adapting [19]; since they seem not to address the problem we are
stating in any way, the issue is propagated, and any app using these
technology is potentially vulnerable. It is worth noting that the
actual impact of the vulnerabilities, as well as the difficulty of hypo-
thetical attacks, greatly depend on the functionalities of the specific
app being attacked, and need to be evaluated on a case-by-case
basis. The evaluation of the general danger introduced by the lack
of app-to-app authentication on a large scale is out of the scope of
this research. We think that generally, vulnerabilities based on apps
accepting unauthenticated content would be medium-impact (as in
permitting phishing and/or DOS at best), but we cannot exclude the
existence of particular apps where it would be possible to obtain
more severe effects (e.g. arbitrary code execution).
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
Stefano Cristalli, Long Lu, Danilo Bruschi, and Andrea Lanzi
Listing 3: Threads in Bluetooth communication
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
// Main thread code
new ReadThread().start()
...
// ReadThread code
public void run() {
...
if (socket != null) {
InputStream inputStream;
try {
inputStream = socket.getInputStream();
inputStream.read(buffer);
// We expect authentication happening here,
// not in a separate thread
}
7.2 Limitations of our analysis
From the experiments, our system shows excellent performance
in detecting the presence of CATCH vulnerabilities in Android
apps. However, the results have to be considered together with
the limitations of our technique. Our analysis suffers from the gen-
eral limitations of static analysis. One of these limitation concerns
the precision of the model of apps control flow. Argus-SAF is not
able to handle particular intra-component and inter-component
transitions, such as ones performed with reflection, and it cannot
correctly model concurrency [29]. In practice, reflection is not com-
monly used by Android developers to perform normal tasks such
as transitions between Activities. Instead concurrency is definitely
present in peer to peer apps; to avoid blocking input/output, sepa-
rate threads are typically spawned on demand to handle read/write
operations on the channel (this applies to both Bluetooth and Wi-Fi
Direct). In case of authentication, we expect to see controls on data
read from the channel immediately after a read operation, follow-
ing our authentication model. So, while it is true that it would be
a problem to correctly model authentication flows that involved
concurrent operations, there is no reason to expect authentication
occurs in a separate thread in reality (see Listing 3). To further
validate our results (Section 5.2) we manually analyzed 20 Android
apps from 662 dataset apps and we check whether threads func-
tions defined in the apps include any authentication scheme (false
negative results). Our manual analysis shows that no one of the app
functions threads analyzed contained any authentication scheme.
channels of communication in Android (such as Bluetooth, SMS,
Internet and audio) showing that the security model of Android
does not offer adequate measures for protecting certain secrets. To
address this problem, they build a security system, called SEACAT,
to enforce fine-grained protection on the above resources. Our work
continues the exploration of missing security features in Android,
and how apps can be vulnerable if developers make the wrong
assumptions about the security of the underlying system.
Security models of peer-to-peer protocols. Claycomb and Shin
formally studied the problem of authentication in mobile devices
[8], and use BAN logic to prove that device authentication using
a single communication channel is not possible. We consider this
result when building our model: in particular, this justifies our
assumption of the secret exchange happening out-of-band. Shen
et al. focus on Wi-Fi Direct technology, studying its security and
discussing related best practices [26]. Again, importance of out-of-
band channels to obtain authentication is highlighted, and used in
the implementation of a secure Wi-Fi Direct protocol.
Using static analysis for detecting authentication. Static analysis
techniques have been extensively used in previous work, for in-
stance for detecting malicious application logic on Android or Web
application[9, 15, 22], and for detecting privacy leaks in both iOS
[14] and Android [16] apps. Closely related to ours is the work of
Shao et al., which studies the presence of authentication in the use
of Unix domain sockets on Android [25]. We followed the same
choice of tools used to perform the analyses, favoring Argus-SAF
[29] (formerly Amandroid) over FlowDroid [6] because of its supe-
rior handling of inter-component communication. An important
difference is that we could not model our problem with as a standard
taint-analysis reachability search, so we had to build our custom
data dependency analysis on top of the tools provided by Argus-
SAF.
9 CONCLUSION
In this paper, we have shown the extension and potential impact of
CATCH vulnerabilities in Android apps, providing a threat model
and specific definitions for the problem, as well as manual and auto-
mated analysis for experimental evaluation. Our main contribution,
the automated system for APK analysis, is a first line of defense
against human error, and could be used to identify vulnerable apps.
Nevertheless, it is clear that the problem can be effectively solved
only by raising awareness among Android developers, by providing
them with appropriate documentation explaining the dangers of
CATCH, as well as APIs and libraries to correctly perform high-
level app-to-app authentication on peer-to-peer communication
channels.
8 RELATED WORK
To the best of our knowledge, we are the first to explore the potential
dangers associated with the lack of app-to-app authentication in
Android apps. However, previous research has made important
contributions in related areas.
ACKNOWLEDGMENTS
This project has received funding by the Italian Ministry of Foreign
Affairs and International Cooperation (grant number: PGR00814).
The project has also received funding by the US Army Research
Office (grant number: W911NF-17-1-0039).
Security of Android communication channels. Previous work high-
lighted the problems existing in Android device-to-device commu-
nications [11, 20]. In particular, Demetriou et al. [11] studied several
REFERENCES
[1] [n.d.]. Android BluetoothChat Sample. https://github.com/googlesamples/
android-BluetoothChat. Accessed: 2019-01-18.
Detecting (Absent) App-to-app Authentication on Cross-device Short-distance Channels
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
[24] N. Saxena, J. . Ekberg, K. Kostiainen, and N. Asokan. 2006. Secure device pairing
based on a visual channel. In 2006 IEEE Symposium on Security and Privacy (S
P’06). 6 pp.–313. https://doi.org/10.1109/SP.2006.35
[25] Yuru Shao, Jason Ott, Yunhan Jack Jia, Zhiyun Qian, and Z. Morley Mao. 2016. The
Misuse of Android Unix Domain Sockets and Security Implications. In Proceedings
of the 2016 ACM SIGSAC Conference on Computer and Communications Security
(CCS ’16). ACM, New York, NY, USA, 80–91. https://doi.org/10.1145/2976749.
2978297
[26] W. Shen, B. Yin, X. Cao, L. X. Cai, and Y. Cheng. 2016. Secure device-to-device
communications over WiFi direct. IEEE Network 30, 5 (September 2016), 4–9.
https://doi.org/10.1109/MNET.2016.7579020
[27] Dongwan Shin et al. 2006. Using a two dimensional colorized barcode solution
for authentication in pervasive computing. In Pervasive Services, 2006 ACS/IEEE
International Conference on. IEEE, 173–180.
[28] Dirk Balfanz Smetters, Dirk Balfanz, D. K. Smetters, Paul Stewart, and H. Chi
Wong. 2002. Talking To Strangers: Authentication in Ad-Hoc Wireless Networks.
[29] Fengguo Wei, Sankardas Roy, Xinming Ou, and Robby. 2018. Amandroid: A
Precise and General Inter-component Data Flow Analysis Framework for Security
Vetting of Android Apps. ACM Trans. Priv. Secur. 21, 3, Article 14 (April 2018),
32 pages. https://doi.org/10.1145/3183575
[30] Nan Zhang, Kan Yuan, Muhammad Naveed, Xiao yong Zhou, and XiaoFeng Wang.
2015. Leave Me Alone: App-Level Protection against Runtime Information Gath-
ering on Android.. In IEEE Symposium on Security and Privacy. IEEE Computer So-
ciety, 915–930. http://dblp.uni-trier.de/db/conf/sp/sp2015.html#ZhangY0ZW15
cessed: 2018-11-19.
[3] [n.d.]. Shrink your code and resources. https://developer.android.com/studio/
build/shrink-code. Accessed: 2018-11-19.
[2] [n.d.]. ProGuard. https://www.guardsquare.com/en/products/proguard. Ac-
[4] [n.d.]. WiFi Direct +.
https://play.google.com/store/apps/details?id=com.
netcompss_gh.wifidirect. Accessed: 2019-02-15.
[5] Kevin Allix, Tegawendé F. Bissyandé, Jacques Klein, and Yves Le Traon. 2016.
AndroZoo: Collecting Millions of Android Apps for the Research Community. In
Proceedings of the 13th International Conference on Mining Software Repositories
(MSR ’16). ACM, New York, NY, USA, 468–471. https://doi.org/10.1145/2901739.
2903508
[6] Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bartel,
Jacques Klein, Yves Le Traon, Damien Octeau, and Patrick McDaniel. 2014. Flow-
Droid: Precise Context, Flow, Field, Object-sensitive and Lifecycle-aware Taint
Analysis for Android Apps. In Proceedings of the 35th ACM SIGPLAN Conference
on Programming Language Design and Implementation (PLDI ’14). ACM, New
York, NY, USA, 259–269. https://doi.org/10.1145/2594291.2594299
[7] W. R. Claycomb and D. Shin. 2009. Secure device pairing using audio. In 43rd
Annual 2009 International Carnahan Conference on Security Technology. 77–84.
https://doi.org/10.1109/CCST.2009.5335562
[8] William R. Claycomb and Dongwan Shin. 2011. Extending Formal Analysis of
Mobile Device Authentication. J. Internet Serv. Inf. Secur. 1 (2011), 86–102.
[9] Andrea Continella, Michele Carminati, Mario Polino, Andrea Lanzi, Stefano
Zanero, and Federico Maggi. 2017. Prometheus: Analyzing WebInject-based
information stealers. Journal of Computer Security 25 (02 2017), 1–21. https:
//doi.org/10.3233/JCS-15773
[10] Sanjeev Das, Jan Werner, Manos Antonakakis, Michalis Polychronakis, and Fabian
Monrose. 2019. SoK: The challenges, pitfalls, and perils of using hardware
performance counters for security. In Proceedings of 40th IEEE Symposium on
Security and Privacy (S&P’19).
[11] Soteris Demetriou, Xiao-yong Zhou, Muhammad Naveed, Yeonjoon Lee, Kan
Yuan, XiaoFeng Wang, and Carl A Gunter. 2015. What’s in Your Dongle and
Bank Account? Mandatory and Discretionary Protection of Android External
Resources.. In NDSS.
[12] Mianxiong DONG, Takashi Kimata, Komei Sugiura, and Koji ZETTSU. 2014.
Quality-of-Experience (QoE) in Emerging Mobile Social Networks.
IEICE
Transactions on Information and Systems E97.D (10 2014), 2606–2612. https:
//doi.org/10.1587/transinf.2013THP0011
[13] K. Doppler, M. Rinne, C. Wijting, C. B. Ribeiro, and K. Hugl. 2009. Device-to-device
communication as an underlay to LTE-advanced networks. IEEE Communications
Magazine 47, 12 (Dec 2009), 42–49. https://doi.org/10.1109/MCOM.2009.5350367
[14] Manuel Egele, Christopher Kruegel, Engin Kirda, and Giovanni Vigna. 2011. PiOS:
Detecting Privacy Leaks in iOS Applications.. In NDSS. 177–183.
[15] Yanick Fratantonio, Antonio Bianchi, William Robertson, Engin Kirda, Christo-
pher Kruegel, and Giovanni Vigna. 2016. Triggerscope: Towards detecting logic
bombs in android applications. In Security and Privacy (SP), 2016 IEEE Symposium
on. IEEE, 377–396.
[16] Clint Gibler, Jonathan Crussell, Jeremy Erickson, and Hao Chen. 2012. Androi-
dLeaks: automatically detecting potential privacy leaks in android applications
on a large scale. In International Conference on Trust and Trustworthy Computing.
Springer, 291–307.
[17] Y. Li, S. Su, and S. Chen. 2015. Social-Aware Resource Allocation for Device-to-
Device Communications Underlaying Cellular Networks. IEEE Wireless Commu-
nications Letters 4, 3 (June 2015), 293–296. https://doi.org/10.1109/LWC.2015.
2410768
[18] Jiajia Liu, Yuichi Kawamoto, Hiroki Nishiyama, Nei Kato, and Naoto Kadowaki.
2014. Device-to-device communications achieve efficient load balancing in LTE-
Advanced networks. Wireless Communications, IEEE 21 (04 2014). https://doi.
org/10.1109/MWC.2014.6812292
[19] A. Nappa, R. Johnson, L. Bilge, J. Caballero, and T. Dumitras. 2015. The Attack of
the Clones: A Study of the Impact of Shared Code on Vulnerability Patching. In
2015 IEEE Symposium on Security and Privacy. 692–708. https://doi.org/10.1109/
SP.2015.48
[20] Muhammad Naveed, Xiao-yong Zhou, Soteris Demetriou, XiaoFeng Wang, and
Carl A Gunter. 2014. Inside Job: Understanding and Mitigating the Threat of
External Device Mis-Binding on Android.. In NDSS.
[21] Phond Phunchongharn, Ekram Hossain, and Dong In Kim. 2013. Resource alloca-
tion for device-to-device communications underlaying LTE-advanced networks.
IEEE Wireless Communications 20, 4 (2013), 91–100.
[22] Andrea Possemato, Andrea Lanzi, Simon Pak Ho Chung, Wenke Lee, and Yanick
Fratantonio. 2018. ClickShield: Are You Hiding Something? Towards Eradicating
Clickjacking on Android. In Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security (CCS ’18). ACM, New York, NY, USA,
1120–1136. https://doi.org/10.1145/3243734.3243785
[23] M. K. Reiter, J. M. McCune, and A. Perrig. 2005. Seeing-Is-Believing: Using Camera
Phones for Human-Verifiable Authentication. In 2005 IEEE Symposium on Security
and Privacy (S&P’05)(SP), Vol. 00. 110–124. https://doi.org/10.1109/SP.2005.19