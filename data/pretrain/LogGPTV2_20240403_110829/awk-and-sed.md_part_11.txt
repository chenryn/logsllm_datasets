现
司
，将“UNIX System” 换成 “UNIX Operating System”
。脚本中正常的流程是在这一行上执行每个命令知道脚本达到末
读入内存，这将会产生内存溢出或者在处理庞大的文件时速度非常
o
问题。屏幕编辑程序必须将整个文件(或者它的一些庞大的部分)
8
，而且并不总是匹配最初的输入行。这就是本章开始处的
群：
UNIX System
，所以，
换成“horse”
arat
当前行被输出并且输入的下一行被读入模式空间。然
0g Sy
888
50192241
，在输入文件中包含pig和cow，
8808
88
1888
888
888
8888
888
888
88888
8888
70
8
8
888
888
8888
888
反转命令的顺序-
将“Unix”换成“UNIX”
-这就是技巧。
88888
NAXIOS
70x/UNIX
在图 4-1 中是“The Unix
第
8888
四章
88888
它还改变了有
，而输出文件中只
一在将“pig”换成
编写 sed 脚本
(注2)。注
。然后应
1
示
空
用
888
8888
888
---
## Page 71
●
或者行寻址符号的正则表达式。
sed 命令可以指定零个、
由“Sebastopol,CA”组成的输入行将匹配这个地址，并且应用替换命令将它替
非你告诉它不要做）。
非告诉它对哪一行操作，否则它什么事情也不会做；在 sed 将处理每一行，
每一行。行地址用于提供操作（或限制）的上下文环境（简而言之，在vi中除
所有出现。在sed 中，好像每一行都会成为一次当前行，因此命令可以应用于
如果在vi 中从ex命令提示符后输入相同的命令，
是隐式全局的。下面的替换命令将每个“CA”都换成“California”。
要注意的第一件事是 sed 将命令应用于每个输入行。与 ed、ex 或vi 不同，sed 
寻址上的全局透视
注2:
持空间的命令将在第六章讨论。
时缓冲区。可以将模式空间的内容复制到保持空间并在以后检索它们。使用保
测试跨越多行的模式。其他一些命令告诉 sed，在到达脚本的底部之前退出或
?
换
样。例如，N命令将另一个读入读入模式空间但没有删除当前的行，所以可以
配，
为“Sebastopol,California”
-些 sed 命令改变了整个标本的流程，
如果地址后面跟有感叹号（！），那么命令就应该用于不匹配该地址的所
 s/CA/California/g
有的行。
一行和它后面的行，直到匹配第二个地址的行（包括此行），
如果指定了由逗号分隔的两个地址，那么命令应用于匹配第一个地址的第
如果只有一个地址，
如果没有指定地址，那么命令将应用于每一行。
 /Sebastopol/s/CA/Cal ifornia/g 
而且不会应用替换命令。
s/pig/cow/g
s/cow/horse/g
们换成“UNIX Operating System”之前可以使两种情况保持一致。
System”两种情况，因此通过将“Unix”换成“UNIX”,
system"
是的，我们可在第一步就将“Unix System”换成”UNIX Operating
QQ群：
，然而，输入文件也许包含“UNIX System”和“Unix
那么命令应用于与这个地址匹配的任意行。
一个或两个地址。每个地址都是一个描述模式、行号
50192241
’。由“San Francisco，CA”组成的行不会被
-71-
正如我们在后面的章节中将会看到的那
那么它将只替换当前行中的
第四章
编写 sed 脚本 
，从而再将它
除
---
## Page 72
这个示列删除了从第一行直到第一个空行的所有的行，例如，
可以混合使用行地址和模式地址：
一对宏包围的所有行，在这种情况下，.TS和.TE标记了tb1 输入：
如果提供两个地址，那么就指定了命令执行的行范围。下例展示了如何删除由
只删除空行。所有其他行都不会改变。
当正则表达式作为地址提供时，
$符号不应该和正则表达式中使用的$相混淆，
输入的最后一行：
行号指由 sed 维护的内部行数。
它删除了从第一种模式匹配的行开始，
当行号作为一个地址提供时，命令只影响那一行。例如，下面的示列只删除第
由d命令组成并且没有地址的脚本不会产生输出，
同
为了解释寻址是如何工作的，让我们先来看看使用删除命令d的示列。一个只
式必须封闭在斜杠（/）中。
样，
50, $d
不管指定多少个输入文件，
，输入流也只有一个最后的行。可以使用寻址符号$指定。下面的示列删除
1, /~$/d 
/^\. TS/, /~\. TE/d 
?
~$/d
QQ群：
50192241
下面的删除命令：
这个命令只影响与这个模式匹配的行。正则表
在输入流中也只有一行1.
该计数器不会因为多个输入文件而重置。因
- 72
，到由第二种模式匹配的行（包括此行在
在这里表示行的结束。
因为它删除了所有的行：
第四章
可用它来删除保
编写 sed 脚本
---
## Page 73
1．生成输入行的备份。
在前面关于模式空间的讨论中，
测试并保存输出
几个troff 请求。
这个示列不仅删除了tb1 输入块中的空行，而且它还使用替换命令s，改变了
可以使用大括号将编辑命令括起来对某个范围的行应用多个命令，如下所示：
后没有空格。
左大括号必须在行末，而且右大括号本身必须单独占一行。要确保在大括号之
2
可以嵌套地址。
sed 使用大括号（{l）将一个地址嵌套在另一个地址中，
分组命令
实际上，这个脚本从源文件中提取tb1输入。
输入块中的那些行以外的所有行：
跟在地址后面的感叹号会反转匹配的意义。例如，
配。在上例中，如果文件不包含空行，那么将删除所有的行。
就将应用与这些行。于是命令应用于“所有”
没有把法先行决定第二个地址是否会匹配。
你可以把第一个地址看做是启用动作，
存在文件中的Internet 邮件消息中的邮件头。
应
用多个命令。
将备份输出到标准输出。
修改模式空间中的备份。
s/^\. vs 
s/^\. ps 10/.ps 8/
/~$/d 
/~\. TS/, /~\. TE/!d 
/^\. TS/, /^\. TE/↓
/^\. TS/, /~\. TE/I
P/$
12/.vs 10/
。例如，为了只删除tb1 输入块中的空行，使用下面的命令：
，如果想指定行的范围，然后在这个范围内指定另一个地址，
，这些命令只应用于.TS/.TE块中的行。
QQ群：
50192241
可以看到 sed:
并把第二个地址看做是禁用动作。Sed
一旦匹配了第一个地址，
随后的行直到第二个地址被匹
下面的脚本将删除了在tb1
第四章
或者在相同的地址上
编写 sed 脚本
这个动作
则
---
## Page 74
找打脚本文件 sedscr，并将其中的指令应用与在命令行指定的输入文件。这些
shell脚本tested 自动将 sed 的输出保存在临时文件中。它期望在当前目录中
tested
下面两个 shelI脚本对于测试 sed 脚本以及对文件中进行永久性改动非常有
按照本书出现的 she脚本生成你自己的替换。
命令的名字，
由于要如此频繁地重复这些步骤，因此将它们放入一个 sheI脚本是非常有)
地工作。
令来用新文件改写原始文件。在丢弃原始文件之前要确保编辑的脚本可以正确
这个命令将在testfile 特有的行钱买你显示“”
容并于testfile 进行比较。
命令的输出重定向到输入文件，否则会改写输入文件，甚至可能在 sed 处理
令行：
这些意味着 sed 有其内置的安全措施，所以会改变原始的文件。因此，下面的
for x
$ diff testfile newfile
$ sed -f sedscr testfile > newfile
S
：重定向符号“>”将来自 sed 的输出直接送往文件 newfile 中。不要将来
 sed -f sedscr testfile
需要在多个文件上运行同一个脚本时，它们尤其有用。
并且可以在系统提示符下输入它。如果不熟悉 shel脚本，
。当检验了结果后，要生成原始文件的一个备份，然后使用mv 
QQ群：
50192241
如果想要很系统地检查结果（应该这样），可以使
74
．并在 newfile 特有的行前
第四章
编写 sed 脚本
可
以
是
个
使
---
## Page 75
时文件，
这个 shell脚本 runsed 是为了对输入文件实现永久性的改变。
runsed
（opun）
如果你发现脚本没有产生所期望的结果，
diff 命令插入到 shell脚本（在 sed 命令之后添加 diff$x tmp.$x）
想
完
果结果是对的，则可以使用mv 命令来用临时文件改写原始文件。也可以将
“tmp”为前缀的临时文件中。可以检查临时文件以决定编辑工作是否正确。
文件的名字必须在命令行上指定。
让输入文件与输出文件相同时可以使用它。与testsed 类似，
善编辑脚本然后在原始输入文件上再次运行它。不要编写一个新脚本来“取
done
sed -f sedscr $x > tmp.$x
do
#! /bin/sh
done
then
if test -s /tmp/$x$$
elif test -s $x; then 
for x 
else
echo "original file is empty."
echo "editing $x: \c"
但是它随后会执行下一步：用这个文件改写原始文件。
se
echo "done"
else
if cmp -s $x /tmp/$x$$ 
-f /tmp/$x$$
then 
echo
echo "Sed produced an empty file\c"
 echo "file not changed: \c"
mv $x $x.bak # save original, just in case 
”或者改进临时文件中生成的改动。
cp /tmp/$x$$ $x 
QQ群：
50192241
结果，
- 75 -
记住最简单的“修复（fix）”通常是
这个 shelI脚本将输出保存到以
第四章 
。换句话说，
编写 sed 脚本
，它创建一个临
如果
如
---
## Page 76
含行式打印机的格式化输出，
Computer。这个文档必须包括“Horsefeathers Software”产品数名。这个公
本书的以为作者曾经为计算机公司编写了一个项目，这里指BigOne 
第一个示列是将由字处理程序创建的文件转换为用于troff 的编码文件。
sed 脚本的第一种类型示范了在一个文件中进行一系列编程工作。我们使用的
对同一文件的多重编辑
sed 脚本的 4中类型
这个 shell脚本的内容（第9行）本质上与testsed 相同。附加的行用于测试
前
到
runsed 简单地对命名文件使用 sed －f sedscr，
脚
要使用runsed，
分
应
在
变
然
未
用。
本节中，
之前，应该首先使用testsed 检验这些改变。
而，runsed 无法避免产生未完成的编辑脚本。在用 runsed 生成永久性的改
改动，或者看看在改写原始文件之前是否产生了空的输出文件。
成功的运行，
前产生了输出。
一个临时文件中。然后 runsed 测试这个临时文件，以确认在覆盖原始文件之
（在 horsefeathers 文件中保存的用于测试的部分）如下所示：
本，
$ runsed cho?
is a full screen program editor, which also provides the ability
machine with UNIX or MS-DOS operating systems. BASIC Librarian 
Horsefeathers BASIC is BASIC optimized for use on the BigOne 
software customization or development.
fill your requirements for powerful, sophisticated, 
of Horsefeathers software products -- Horsefeathers Business
在命令行上写上要编辑的文件名。ShelI元字符可用于指定一组文件。
echo "all done"
DESCRIPTION
我们将会看到4种类型的脚本，每类脚本都说明了一种典型的 sed
例如，
，在想要进行编辑操作的目录下，创建一个名为 sedser 的 sed 
QQ群：
当没有产生输出时。
50192241