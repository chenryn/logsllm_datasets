.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFORM 1"
.TH PERLFORM 7 "2003-11-25" "perl v5.8.3" "Perl Programmers Reference Guide"
.SH "NAME"
perlform \- Perl 格式
.SH "DESCRIPTION 描述"
.IX Header "DESCRIPTION"
Perl的一些内部机制、可以帮助我们产生一份简单的格式化图表。经过perl的处理，你列印的格式可以接近于你所见的外貌。它可以记录如你现在正处在哪个页面，每个页面的行数与何时列印出页面的标题。关键字，format() 格式函数与write()执行函数是直接引自FORTRAN语法。详情可参阅 perlfunc。幸运的是列印的格式可读性又有所提高。几乎类似BASIC 的PRINT USING。可以把它想象为简单的 \fInroff\fR\|(1).
.PP
有如子程序与包一样，格式只是语句的声明，而不是执行调用。故它可以放在程式的任何位置（一般最好是把它们集中在一块）。与perl的其它变量名字类型不同， 格式命名有别于一般的独自的定义。也就是说，你有一个名为Foo的函数，它与另一个格式名称为Foo的东西是完全不同。但是缺省的格式名称与有关连的文件句柄可用相同的名字。所以缺省的输出格式名称STDOUT，它的文件句柄名称就是STDOUT。而对缺省格式名称TEMP，它的文件句柄名称也可以是TEMP。虽然名称一样但两者并不相同。
.PP
输出格式的语法如下：
.PP
.Vb 3
\&    format NAME =
\&    FORMLIST
\&    .
.Ve
.PP
如省略格式名称，格式名称将以标准输出STDOUT命名。而格式项目将包括了好几个连续横行。每一行属于下列叁种型态之一：
.IP "1." 4
注释（comment), 以符号“#”置于每行的开头。
.IP "2." 4
图案行(picture line)，规定了单一行的格式化外观。
.IP "3." 4
参数行, 提供一些数值以对应前面的图案行。
.PP
图案行的输出效果就与我们看到的一样，除了某些值域栏位会给相对应数值取代外，每个输入栏位都以一个@或 ^ 控制符开头。这些单行内的控制符不能做任何窜改取代(勿与数组变量@混淆)。@栏位是属于正常形态的栏位，而^栏位则用来表示可以输入多行文字。至于该栏位则由 或 | 符号跟随其后指定向左、右、或居中对齐。并同时跟据该符号的数目，输入指定资料的长度。如变量内容超过限定长度、格式列印时会自动删除多余的部份。
.PP
另一种指定向右对齐方式，是使用#符号来指定一个数字栏位。如此可方便小数点定位。如果输入值里还包含一个换行字元(\n)，则仅列印出该换行字元前的资料。最后图案行出现的@*这个特别符号标记，可以用来列印多行并且不被截掉的数值。
.PP
接下来的一行、是跟据图案行里的值域栏位输入相应的数值。如果是利用运算式提供数值的话、必须以逗号分隔。因为所有的表示法都会被当成一个串连内容再行处理。所以一个单一的串列表示法也可产生多个串列资料。如果表示法是利用括号围起，可能会展开好几行。若想如是安排，第一行的第一个单字必须是以左括号开始。如果运算式内有小数点的数字类型须要处理、同时图案行的相关符号也指出小数位须列印出来(除了图案行内的包含小数点"."的数字控制符号#外)。小数点列印出的外貌, 以当地的运行版本决定(LC_NUMERIC locale)。也就是说、在德文地区使用小数格示输出时、小数点的显示将是","而非"."。相关资料请参考 perllocale 与 "警告"  
.PP
图案行里的栏位如果以^控制符开头、格式将会作特殊化处理。如果该栏位是注解栏位又没定义其值、栏位将以空白取代。若是其它型态、则视为一种填补资料的状态。 在此、我们不能随便填入任意表示法进去。相反、必须以相关的变量输入字串内容。perl会尽量将文字放入该栏位、然后把字串的前面部份删去。当你下次使用该字串变量时、可以使用后面的字串部份(换句话说、在执行write函数时、字串变量的内容是会改变的)。正常情况下、你必须使用一类似垂直状的堆块来放置要输入的文字、以便整齐列印出一柱状文字。如你列印的文字太长、想以"..."取代过长的文字时、你可以借由更改 $: 变量值来取代分隔字元。也就是当你使用ENGLISH模块时的 $FORMAT_LINE_BREAK_CHARACTERS的意思。
.PP
使用^符号栏位可产生不定长度的记录栏位。如果要列印的文字很短、你想压缩掉文字后的空白、请在想压缩掉的空白地方加上一个"~"控制符号。如果重复使用两个"~"符号、则该行会被重复列印、直到该栏位的所有文字列印完毕为止 (如你同时使用"@"值域栏位的话、切记每次要输入不同的数值)。
.PP
列印格示标题的缺省处理方法、是将正使用的格式名称后加上_TOP字样既可。其内容将会列印至每页的开头部份。请参考 perlfunc/write 函数
.PP
例如：
.PP
.Vb 10
\& # a report on the /etc/passwd file
\& format STDOUT_TOP =
\&                         Passwd File
\& Name                Login    Office   Uid   Gid Home
\& ------------------------------------------------------------------
\& .
\& format STDOUT =
\& @>>> @>>>> @>>>>>>>>>>>>>>>>>>>>>>
\& $system,                      $%,         $date
\& ------------------------------------------------------------------
\& .
\& format STDOUT =
\& Subject: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&          $subject
\& Index: @<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&        $index,                       $description