> 本文是翻译文章，原文链接： blog/cve-2019-12103-analysis-of-a-pre-auth-rce-on-the-tp-link-m7350-with-> ghidra/>
>
> 译者注：文章的前半篇讲的比较基础...可以适当跳过，后半篇主要讲漏挖
TP-Link M7350 (V3)受到 **预认证(Pre-Auth)** 和 **后认证(Post-Auth)CVE-2019-12104**
命令注入漏洞的影响
如果攻击者位于同一LAN上或者能够访问路由器Web界面，则可以远程利用这些注入。`CVE-2019-12103`也可以通过跨站点请求伪造(CSRF)在任何浏览器中利用，因为在用户登录之前没有CSRF保护
如果您正在运行其中一个设备，请立即更新到[新固件](https://www.tp-link.com/uk/support/download/m7350/v3/#Firmware)（版本190531）。
无论如何，这篇文章是技术性的，关于使用`Ghidra`找到这样的问题，通过逆向工程找到命令注入漏洞很有趣！
# 大多数路由器的安全性都很差
大多数消费级网络硬件都带有嵌入式网络服务器。Web服务器是用户使用GUI访问设备配置的一种非常简单的方法，无需安装专有软件。很多时候，Web服务器会暴露某种API端点
- 有时候是`JSON`或`XML`。这个Web服务器API通常只是shell命令的一个简陋包装器(wrapper)。传递给webserver
API的变量只是传递给shell命令，因为大多数消费级网络硬件只是运行Linux。
当开发人员不是非常非常小心的时候，你会发现某种任意的命令执行是可能的。我很少看到路由器在暴露的接口上没有命令注入或内存相关的漏洞
所以，这是在`TP-Link M7350`中找到一个非常方便的命令注入的故事。
# M7350 它在运行什么？
正如他们声称的“闪电”一样，M7350只是另一个基于`Qualcomm`的蜂窝热点——在这种情况下它正在运行（此时相对古老的）MDM9225。
从我们的角度来看，我们希望看到运行的是什么，以便尝试发现漏洞。幸运的是，[固件](https://www.tp-link.com/de/support/download/m7350/v3/#Firmware)可以从这里被找到
我正在使用硬件版本3.0的M7350，因此我的固件文件名为M7350(EU)_V3_160330_1472438334613t.zip
这个文件本身只是一个ZIP，其中包含PDF安装说明，存在问题的是另一个名为M7350(EU) 3.0_1.1.1 Build 160330
Rel.1002n_User.zip.zip的ZIP。在其中，我们发现：
这看起来非常像 没有尝试混淆或者加密(zero-attempt-at-obfuscation-or encryption) 的固件更新文件
我们甚至可以在`META-INF/com/google/android/updater-script`看到固件更新的脚本
我们已经[在这里](https://www.pentestpartners.com/security-blog/attacking-android-through-custom-updates/)使用Android更新包编写了关于攻击设备的文章。但这有点超出了这个特定的搜索范围——我们想要网络界面中的错误！
那么，首先我们如何确定哪些二进制文件对我们有意义？
## 使用grep
我们可以用grep来找出一些我们可能控制的关键变量，可能是因为我在`WSL`中使用的90%的命令都是`grep`
无论如何，利用burpsuite来获得M7350的主要web界面信息，我们可以看到一些变量名称，这可能有助于我们找到处理它们的二进制文件。
通用配置请求将发送到`/cgi-bin/qcmap_web_cgi`，POST主体是JSON编码的，验证后请求需要`token`值。`module`参数很有意思，因为它表明会有一个很大的`switch
case语句`在某处运行，它基于请求的模块，来用不同的方式处理输入数据。
那么，让我们来留意`webServer`，看看它出现在哪里。
为了避免无关的垃圾输出，我传递了`-o`标志，这只显示我们在文本文件中找到的实际字符串。无论如何，我们只对二进制文件感兴趣，`-r`则表示递归`grep`
`webServer`出现在二进制文件`QCMAP_Web_CLIENT`和`qcmap_web_cgi`中
我们先来看看`qcmap_web_cgi`，如果您记得上面的POST请求，`qcmap_web_cgi`是所有正在POST的端点。因此，它可能负责管理每个请求的处理方式
## Ghidra非常擅长这一点
打开`qcmap_web_cgi`二进制文件，我们可以先从搜索字符串开始进行分析(Search->For Strings)
单击搜索对话框，保留默认设置后，我们可以开始看到很多字符串——包括我们的`webServer`字符串
双击该条目将我们带到`webServer`位于内存中的位置。`Ghidra`指出这个地址在二进制文件的其他地方被交叉引用（使用`XREF`注释）
我们可以双击那个交叉引用，它将把我们带到引用`webServer`的函数。我已经重命名了它——它通常被称为`FUN_xxx`，如FUN_00008ce0。我认为FUN代表“功能”而不仅仅是“有趣”。虽然逆向工程是“有趣的”，但大多数时候我不称之为“有趣”。
`Ghidra`的反编译器`非常`好（我们稍后会介绍），所以我们可以很容易地看到这个函数的逻辑是什么。
字符串传递给函数，如果字符串是`webServer`，则返回1，简单。
然后，我们可以向后跟踪此函数，以弄清楚它是如何被调用的以及为什么。右键单击反汇编视图中的函数名称（在反编译视图中不起作用，我不明白...），然后单击参考
-> 显示调用树
这将给出一个非常简单的可扩展项目符号列表，列出函数的调用位置——以及它调用的内容。
在左侧，您可以看到传入的引用 -由`FUN_00008d78`调用`webServer_or_status`，它本身由main(以及之前的ELF条目)调用。在右侧，显示`webserver_or_Status`仅调用`strcmp`。
然后我们可以开始讨论函数，只关注可能影响输入值的函数。
`FUN_00008d78`对我们来说很无聊，它主要是从环境变量中提取数据，从JSON中提取内容并在适当的地方执行身份验证检查。
那么，让我们来看看主要功能。
因此，这是调用FUN_00008d78的main的一部分——从`webServer_or_status`升级一级。所有其他`if-else`块都是错误处理——如果请求格式错误或不完整，则抛出错误。这个突出显示的代码块可以完成所有有效请求的工作。
您会注意到`FUN_00008d78`没有返回任何内容，然后调用`FUN_000092ec`
# 让乐趣开始
`FUN_000092ec`实际上非常有趣。即使单从调用树看，你也可以看到它调用其他打开套接字的函数，并执行`sendto`和`recv`调用，还至少有一个系统调用。
您可能期望从与Web服务器相邻的二进制文件中出现类似的内容——但请记住，此二进制文件 **根本不处理HTTP服务器套接字活动**
。这个二进制文件本身不是Web服务器——它只是实际Web服务器传递HTTP请求的端点。任何套接字活动都完全在做其他事情。让我们的RE旅程更长一些，但也许会发现有趣的东西。
好的，回到二进制文件。正如您在调用树中看到的那样，`FUN_000092ec`正在调用`FUN_00008f3c`，它正在执行`socket`，`system`和`sendto
syscalls`！让我们看一下（用一点手动变量名称清理）：
二进制文件`bind`到套接字文件`/www/qcmap_cgi_webclient_file`，然后再把请求的数据`sendto`到套接字文件`/www/qcmap_webclient_cgi_file`
对我们来说，所有这些意味着我们现在必须扩大我们的搜索范围。由于数据被推出`qcmap_web_cgi`，我们需要弄清楚它的去向以及发生了什么。
## 我没有选择grep，是grep选择了我
让我们来看看`qcmap_webclient_cgi_file`文件，另一个过程可能就是监听此文件。上帝，我爱`grep`
    $ grep -r qcmap_webclient_cgi_file
    Binary file data/bin/QCMAP_Web_CLIENT matches
    Binary file system/WEBSERVER/www/cgi-bin/qcmap_web_cgi matches
只有2个结果，我们已经分析完了无聊的`qcmap_web_cgi`，现在只有有趣的`QCMAP_Web_CLIENT`，您可能还记得我们之前的`webServer
grep`
现在我们把这个有趣的文件装入`Ghidra`，我们再次检查字符串，这次`webServer`出现了几次
但是，这一次，点击它的地址只显示`webServer`漂浮在`null`的海洋中。
没有直接的交叉引用，然而，向下滚动一点，并且有一些非空字节。你可以通过右键单击第一个->数据 - >`dword`将它们转换为双字
这看起来非常像查找表。如果你双击`dword
15384h`，你会发现自己在binary中的那个偏移量的位置。它看起来非常像函数的开头，目测像是将请求解析到`webServer API模块`的功能。
你能发现漏洞吗？我们将在一秒钟内回到这一点。
您可以通过右键单击FUN_00015384->重命名功能重命名此功能。我选择了名称`API_webServer_function`
如果像我一样，你想确保查找表中指向`0x00015384`的指针实际显示你的新函数名，你可以回到指针，右键单击它->引用->创建内存引用。为了更方便，一旦您知道查找表的结构，只需在单击`dword`的第一个字节时按`p`键即可立即将其转换为