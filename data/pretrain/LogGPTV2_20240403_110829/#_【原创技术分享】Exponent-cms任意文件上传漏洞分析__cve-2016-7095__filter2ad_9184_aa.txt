# 【原创技术分享】Exponent-cms任意文件上传漏洞分析 (cve-2016-7095)
|
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
**作者： Balisong**
**稿费：500RMB**
Exponent
cms是一款国外的cms,功能比较强大。但是在2.3.8版本及以下，存在着一个全版本通杀的任意文件上传漏洞。攻击者可以通过该漏洞直接getshell.
官方最新版2.3.9已经修复([http://www.exponentcms.org)](http://www.exponentcms.org\))
**  
**
**漏洞分析：**
我们首先看一下漏洞触发点在:
/framework/modules/ecommerce/controllers/eventregistrationController.php中第1161行：
          if (!empty($_FILES['attach']['size'])) {
                $dir = 'tmp';
                $filename = expFile::fixName(time() . '_' . $_FILES['attach']['name']);
                $dest = $dir . '/' . $filename;
                //Check to see if the directory exists.  If not, create the directory structure.
                if (!file_exists(BASE.$dir)) expFile::makeDirectory($dir);
                // Move the temporary uploaded file into the destination directory, and change the name.
                $file = expFile::moveUploadedFile($_FILES['attach']['tmp_name'], BASE . $dest);
    //            $finfo = finfo_open(FILEINFO_MIME_TYPE);
    //                $relpath = str_replace(PATH_RELATIVE, '', BASE);
    //            $ftype = finfo_file($finfo, BASE.$dest);
    //            finfo_close($finfo);
                if (!empty($file)) $mail->attach_file_on_disk(BASE . $file, expFile::getMimeType(BASE . $file));
            }
            $from = array(ecomconfig::getConfig('from_address') => ecomconfig::getConfig('from_name'));
            if (empty($from[0])) $from = SMTP_FROMADDRESS;
            $mail->quickBatchSend(array(
                 'headers'=>$headers,
                    'html_message'=> $this->params['email_message'],
                    'text_message'=> strip_tags(str_replace("", "", $this->params['email_message'])),
                    'to'          => $email_addy,
                    'from'        => $from,
                    'subject'     => $this->params['email_subject']
            ));
            if (!empty($file))unlink(BASE . $file);  // delete temp file attachment
            flash('message', gt("You're email to event registrants has been sent."));
            expHistory::back();
    }
然后我们可以看到这里有一个文件上传的操作，我们跟踪一下moveUploadedFile函数，在/framework/modules/file/models/expFile.php中第1508行：
    public static function moveUploadedFile($tmp_name, $dest) {
            move_uploaded_file($tmp_name, $dest);
            if (file_exists($dest)) {
                $__oldumask = umask(0);
                chmod($dest, octdec(FILE_DEFAULT_MODE_STR + 0));
                umask($__oldumask);
                return str_replace(BASE, '', $dest);
            } else return null;
        }
这里没有对后缀名进行一个检测，可以上传任意文件。文件命名的方式是time()+下划线+文件名。
然后我们看到紧跟着就有一个文件删除的操作：
if (!empty($file))unlink(BASE . $file);
看起来是没有问题的，传上去之后立马删除掉了，因为文件存在的时间超级短，并且文件命名的方式里面带有时间戳，导致我们无法利用这个文件。
但是这里有个细节，就是在上传文件到删除文件的过程中，调用了一个函数操作：
也就是
    $mail->quickBatchSend(array(
                 'headers'=>$headers,
                    'html_message'=> $this->params['email_message'],
                    'text_message'=> strip_tags(str_replace("", "", $this->params['email_message'])),
                    'to'          => $email_addy,
                    'from'        => $from,
                    'subject'     => $this->params['email_subject']
            ));
我们开始跟踪一下该函数：
在/framework/core/subsystems/expMail.php中第378行：
    public function quickBatchSend($params = array()) {
           if (empty($params['html_message']) && empty($params['text_message'])) {
               return false;
           }
         // set up the to address(es)
           if (is_array($params['to'])) {
               $params['to'] = array_filter($params['to']);
           } else {
               $params['to'] = array(trim($params['to']));
           }
           if (empty($params['to'])) {
               $params['to'] = array(trim(SMTP_FROMADDRESS)); // default address is ours
           }
            $this->addTo($params['to']);  // we only do this to save addresses in our object
         // set up the from address(es)
           if (is_array($params['from'])) {
               $params['from'] = array_filter($params['from']);
           } else {
               $params['from'] = trim($params['from']);
           }
在这里又调用了一个函数addto()，我们继续跟踪该函数，在该文件的 644行：
    public function addTo($email = null) {
            // attempt to fix a bad to address
            if (is_array($email)) {
                foreach ($email as $address=>$name) {
                    if (is_integer($address)) {
                        if (strstr($name,'.') === false) {
                            $email[$address] .= $name.'.net';
                        }
                    }
                }
            } else {
                if (strstr($email,'.') === false) {
                    $email .= '.net';
                }
            }
            $this->to = $email;
            if (!empty($email)) {
                $this->message->setTo($email);  //fixme this resets the 'to' addresses, unless using $this->message->addTo($email);
    //         $this->message->addTo($email);  //if you need to reset the 'to' addresses, use $this->flushRecipients();
            }
        }
这里又调用了一个setTo()函数，我们继续跟踪该函数，在/external/swiftmailer-5.4.2/lib/classes/Swift/Mime/SimpleMessage.php中第316行：
    public function setTo($addresses, $name = null)
        {   
            if (!is_array($addresses) && isset($name)) {
                $addresses = array($addresses => $name);
            }
            if (!$this->_setHeaderFieldModel('To', (array) $addresses)) {
                $this->getHeaders()->addMailboxHeader('To', (array) $addresses);
            }
            return $this;
    }
这里调用了一个addMailboxHeader函数，我们继续追踪该函数，在/external/swiftmailer-5.4.2/lib/classes/Swift/Mime/SimpleHeaderSet.php中第65行:
      public function addMailboxHeader($name, $addresses = null)
        {
            $this->_storeHeader($name,
            $this->_factory->createMailboxHeader($name, $addresses));
        }
这里又调用了一个createMailboxHeader函数，我们继续跟踪，在/external/swiftmailer-5.4.2/lib/classes/Swift/Mime/SimpleHeaderFactory.php中第54行：
    public function createMailboxHeader($name, $addresses = null)
        {
            $header = new Swift_Mime_Headers_MailboxHeader($name, $this->_encoder, $this->_grammar);
            if (isset($addresses)) {
                $header->setFieldBodyModel($addresses);
            }
            $this->_setHeaderCharset($header);
            return $header;
    }
这里又调用到了一个setFieldBodyModel函数，我们继续跟踪,
/external/swiftmailer-5.4.2/lib/classes/Swift/Mime/Headers/MailboxHeader.php中第61行:
    public function setFieldBodyModel($model)
        {
            $this->setNameAddresses($model);
    }
这里调用了一个setNameAddresses函数，我们继续跟踪该函数，在该文件104行：
    public function setNameAddresses($mailboxes)
        {
            $this->_mailboxes = $this->normalizeMailboxes((array) $mailboxes);
            $this->setCachedValue(null); //Clear any cached value
    }
这里又调用了normalizeMailboxes函数，我们继续跟踪该函数，在该文件的250行：
这里调用了一个_assertValidAddress函数，我们继续跟踪该函数，在该文件的第344行：
    private function _assertValidAddress($address)
        {
        echo $this->getGrammar()->getDefinition('addr-spec');
            if (!preg_match('/^'.$this->getGrammar()->getDefinition('addr-spec').'$/D',
                $address)) {
                throw new Swift_RfcComplianceException(
                    'Address in mailbox given ['.$address.
                    '] does not comply with RFC 2822, 3.6.2.'