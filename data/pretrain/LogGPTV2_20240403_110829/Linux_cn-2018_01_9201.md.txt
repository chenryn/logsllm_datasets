---
**作者**: Jonathan Corbet  
**分类**: 技术  
**评论数据**: 无  
**统计数据**:
- 评论数: 0
- 收藏次数: 1
- 点赞数: 0
- 分享次数: 0
- 浏览量: 11,584
**日期**: 2018年1月4日 10:03  
**编辑推荐**: 否  
**摘要**: 英特尔处理器曝出了一个严重的硬件设计漏洞，迫使包括Linux、Windows在内的主要操作系统和各大云计算服务商都忙着打补丁。由于漏洞信息尚未公开，目前只能通过已发布的补丁反推这个漏洞。本文将对该漏洞进行技术分析。  
**来源链接**: <https://lwn.net/SubscriberLink/741878/eb6c9d3913d7cb2b/>  
**ID**: 9201  
**是否为LCTT翻译**: 是  
**大图**: /data/attachment/album/201801/04/100246p3apbjib33puazpj.jpg  
**永久链接**: /article-9201-1.html  
**图片**: /data/attachment/album/201801/04/100246p3apbjib33puazpj.jpg.thumb.jpg  
**相关文章**:
- 排序: 0, ID: 9226
- 排序: 0, ID: 9237  
**审阅者**: 无  
**选择器**: 无  
**标签**: 内核, 漏洞, KPTI  
**缩略图**: 否  
**标题**: KPTI：内核页表隔离的当前发展  
**标题图片**: 是  
**译者**: qhwdw  
**更新日期**: 2018年1月4日 10:03  
---

英特尔处理器曝出了一个严重的硬件设计漏洞，迫使包括 Linux 和 Windows 在内的主要操作系统以及各大云计算服务提供商纷纷发布补丁以应对这一问题。由于具体的漏洞细节尚未完全披露，目前我们只能通过已发布的补丁来推测其性质。本文旨在对这一漏洞进行详细的技术分析。

![](/data/attachment/album/201801/04/100246p3apbjib33puazpj.jpg)

在十月底，KAISER 补丁集首次亮相。该补丁集的主要工作是将内核空间与用户空间使用的页表进行隔离，以此解决 x86 处理器上向攻击者泄露内核布局的安全隐患。尽管这些补丁自发布以来一直备受关注，但它们似乎正接近最终版本。现在是重新审视这些补丁的好时机。

这项工作后来被重命名为“内核页表隔离”（KPTI），但目标保持不变：分割页表，将原本由用户空间和内核空间共享的单个页表拆分为两套独立的页表。这对内核的内存管理产生了根本性的影响，并且通常情况下，这样的变更需要经过多年的讨论才能决定，尤其是考虑到其性能影响。然而，KPTI 的开发仍在快速推进中。一组预备补丁已被合并到 4.15-rc4 版本之后的主线内核中——这种情况通常只允许重要的修复进入。其余部分预计将在 4.16 版本的合并窗口中完成。许多内核开发者已经投入了大量时间在这个项目上，Linus Torvalds 也要求将这项工作回迁到长期稳定内核中。

简而言之，KPTI 已经准备好作为安全补丁紧急推出。对于使用 ARM 架构的读者来说，值得注意的是，ARM64 平台也有类似的补丁集。

### 51 个补丁及其他

在这篇文章中，x86 补丁系列正处于第 163 版。它包含 51 个补丁，因此我们应该感谢那些未公开的版本。最初的补丁集由 Dave Hansen 发布，并由 Thomas Gleixner、Peter Zijlstra、Andy Lutomirski 和 Hugh Dickins 根据多位其他开发者的建议进行了大量修订。任何现存的缺陷都不是因为缺乏经验丰富的开发者审查所致。

在现代系统中，页表是以树形结构组织的，这使得稀疏内存映射和巨页支持变得更加高效。更多细节及原理可参见 2005 年的一篇文章。大多数大型系统采用四级页面表结构，顶层为页面全局目录（PGD），接下来是页面上层目录（PUD）、页面中层目录（PMD）和页面表条目（PTE）。五级页面表系统在 PGD 下增加了一层（称为 P4D）。

页面故障解析通常遍历整个树以查找所需的 PTE，但巨页可以由更高层级的特定条目表示。例如，一个 2MB 的内存块既可以由 PMD 层的一个单一巨页条目表示，也可以由一系列单页 PTE 条目表示。

在当前内核中，每个处理器有一个单一的 PGD。KPTI 补丁集采取的第一步措施之一是创建第二个 PGD。当内核运行时，原始 PGD 仍在使用；它映射所有的地址空间。当处理器在用户空间运行时，第二个 PGD 被激活。它指向属于该进程的相同目录层次，但通常不包括描述内核空间的部分（位于虚拟地址空间的顶部）。

页表条目包含权限位，用于记录内存访问方式。显然，这些位设置为阻止用户空间访问内核页面，即使这些页面被映射到该地址空间中。不幸的是，某些硬件错误允许用户空间攻击者确定给定内核空间地址是否被映射，而不管该页面上的地址是否可访问。这种信息可以用来绕过内核地址空间布局随机化，从而使本地攻击者更容易得逞。KPTI 的核心思想是切换到没有内核空间映射的 PGD，从而防止基于此漏洞的攻击。

### 细节

虽然这个想法很简单，但实际实现却涉及许多复杂细节，使简单的概念变成了一个由 51 个补丁组成的集合。其中一个问题是，如果处理器在用户模式下响应硬件中断，处理中断所需的内核代码将不在地址空间中。因此，必须有足够的内核代码映射在用户模式中，以便能够切换回内核 PGD，使剩余代码可用。类似的情况也适用于陷阱、非屏蔽中断和系统调用。这部分代码很小且可以与其他部分隔离，但在处理安全有效的切换时涉及复杂的细节。

另一个难题来自 x86 本地描述符表（LDT）的构成，它可以用于改变用户空间的内存布局。可以通过鲜为人知的 `modify_ldt()` 系统调用来调整 LDT。例如，在早期的 POSIX 线程实现中，Linux 使用 LDT 创建本地线程存储区域。尽管 LDT 在现代 Linux 系统中几乎不再使用，但一些应用程序（如 Wine）仍需要它。当 LDT 被使用时，它必须同时可供用户空间和内核空间访问，但必须始终位于内核空间中。KPTI 补丁集扰乱了内核附近的内存，在 PGD 级别为 LDT 保留了一个完整的条目，导致 `vmalloc()` 调用的可用空间减少到仅 12,800TB。这是一个非常大的 LDT 空间，足以满足多 CPU 系统的需求。这种变化的结果之一是 LDT 的位置将是固定的，并且已知用户空间——因此，覆盖 LDT 的能力很容易被用来破坏整个系统。该系列的最后一个补丁是将 LDT 映射为只读，以防止此类攻击。

另一个潜在的安全缺陷是，如果内核可以被操纵至返回用户空间而不切换回过滤后的 PGD。由于内核空间 PGD 也映射了用户空间内存，这种疏忽可能在一段时间内不会被察觉。对此问题的解决方案是将虚拟内存空间中用户空间的部分以不可执行的方式映射到内核 PGD。只要用户空间程序开始从错误的页表执行，它将立即崩溃。

最后，尽管所有现有的 x86 处理器似乎都会受到此信息泄露漏洞的影响，但未来的处理器可能不会。KPTI 带来了可测量的运行时成本，估计约为 5%。有些用户可能不愿意为此付出代价，尤其是在他们获得了不受此问题影响的新处理器之后。为此，将提供一个 `nopti` 内核命令行选项以在启动时禁用该机制。该补丁系列还增加了一个新的“特性”标识（`X86_BUG_CPU_INSECURE`）来标记存在漏洞的 CPU；它目前设置在所有 x86 CPU 上（AMD 表示不背锅），但在未来的硬件上可能不存在。如果没有该特性标识，页面隔离将自动关闭。

距离 4.16 版本的合并窗口打开还有大约一个月的时间。在此期间，针对新发现的问题，KPTI 补丁集无疑会迎来一系列小修订。一旦所有事情敲定，这些代码将被合并并迅速回迁到稳定版本的内核中。显然，我们将收到一个更慢但更安全的内核作为新年礼物。

---
**原文作者**: [Jonathan Corbet](https://lwn.net/SubscriberLink/741878/eb6c9d3913d7cb2b/)  
**译者**: [qhwdw](https://github.com/qhwdw)  
**校对**: [wxy](https://github.com/wxy)  
**本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出**

---