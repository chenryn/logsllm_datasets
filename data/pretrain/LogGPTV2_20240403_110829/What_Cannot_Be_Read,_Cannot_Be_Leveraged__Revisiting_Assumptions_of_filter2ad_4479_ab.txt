tion of Readactor(++) is that ﬁne-grained code diversiﬁ-
cation techniques are in place, such as function permuta-
tion, register allocation randomization, and callee-saved
register save slot reordering.
Despite the fact that Readactor hid code pointers, the
layout of some function tables (e.g., import tables or vta-
bles) stayed the same. This allows an adversary to guess
and reuse the function pointers from these tables [27].
Readactor++ ﬁxed this issue by randomizing these ta-
bles (to get rid of the predictable layout) and randomly
injecting pointers to illegal code (to forbid function ﬁn-
gerprinting by executing it).
Alternative XnR Designs: Gionta et al. [15] proposed
HideM, which, using a split TLB technology, differenti-
ates between memory accesses and only allows instruc-
tion fetches to access code pages. Further, HideM con-
siders the data in the executable memory pages that need
to be read and uses read policies to guarantee their se-
curity. However, although HideM might be used to en-
force non-readable code, it highly depends on the hard-
ware support (e.g., split TLB). Furthermore, HideM does
not hide code pointers. In addition, Pereira et al. [26]
designed a technique similar to Readactor(++) that aims
to get non-readable code for mobile devices in ARM.
One of the advantages of their approach, called Leakage-
Resilient Layout Randomization (LR2), is that it is im-
plemented in software and does not require the under-
lying hardware support. LR2 achieves this by splitting
the memory space in half (into code and data pages) and
instrumenting load instructions to forbid the attacker to
read code. LR2 also optimizes the use of trampolines by
creating only a single trampoline for each callee instead
of encoding one for each callee-caller pair.
Summarizing XnR: Even though the current XnR im-
plementations mark JIT-compiled code as non-readable,
existing prototypes allow to leak JIT code pointers via
JIT-compiled code. We will show that an adversary that
controls the JavaScript code can still run code-reuse at-
tacks on the code generated by the JIT compilers.
of corresponding assembly instructions, making the code
output of the JIT compiler predictable. The deterministic
JIT compilation allows an attacker to inﬂuence the code
output by controlling the JavaScript code. For example,
Blazakis [7] and Athanasakis et al. [1] propose to craft
special JavaScript statements that JIT-compile into gad-
gets. Consider a statement with an immediate value, such
as the assignment var a=0x90909090. The JIT engine
will compile this into a sequence of assembly instruc-
tions, one of them being a mov eax,0x90909090 instruc-
tion that encodes the attacker-chosen immediate value.
After the compilation, the attacker can jump in the mid-
dle of the instruction and use the bytes of the immediate
value as an unaligned gadget, such as four consecutive
nop instructions in our simple example.
JIT Compiler Defenses: Modern JavaScript compil-
ers prevent such unaligned gadgets by constant blind-
ing. Instead of directly emitting constants in native code,
compilers XOR them with randomly generated keys, mak-
ing the resulting constants unpredictable. After constant
blinding, the aforementioned JavaScript statement will
be compiled to the following assembly instructions, ef-
fectively removing the attacker-controlled constant:
mov eax, (0x90909090 ⊕ KEY)
xor eax, KEY
For performance reasons, modern browsers only blind
large constants. For example, Chrome and IE blind
constants containing three or more bytes, giving the
attacker a chance to emit arbitrary two-byte gadgets.
Athanasakis et al. [1] demonstrated that two-byte gad-
gets are sufﬁcient to mount a successful ROP attack, pro-
vided that (i) code sections are readable, and (ii) avail-
able gadgets happen to be followed by a ret instruction.
While constant blinding protects against such gadget
emissions, as we will show, it does not protect against our
novel form of JIT-compiled implicit constant gadgets.
3 Assumptions
We now describe our assumptions that we follow
throughout this paper, detailing a threat model and dis-
cussing defenses that we assume are in place on the tar-
get system. These assumptions are in accordance with
the recently proposed defense mechanisms against JIT-
ROP, such as XnR [2] and Readactor [11].
JIT-Compiled Gadgets
2.4
JIT compilation remains a major challenge for XnR im-
plementations. During JIT compilation, the JIT engine
(e.g., of a browser) compiles JavaScript code into assem-
bly instructions to optimize performance. This is done
by converting each JavaScript statement into a sequence
3.1 Defense Techniques
We assume that the following defense mechanisms of the
operating systems and the target application are in place:
• Non-Executable Data: Data Execution Policy
(DEP) is enabled on the target system, e.g., by us-
142  25th USENIX Security Symposium 
USENIX Association
4
ing the NX-bit support of the hardware, marking
writable memory pages non-executable.
• Address Space Layout Randomization: The tar-
get system deploys base address randomization
techniques such as ASLR, i.e., the attacker cannot
predict the location of a page without a memory dis-
closure vulnerability. In addition, we assume popu-
lar ﬁne-grained ASLR schemes [20, 33, 16, 25, 17],
as suggested by current XnR implementations [11,
12], are applied on the executable, libraries, and JIT-
compiled code.
• Non-Readable Code: We assume that all code
segments are non-readable, with this being either
software- [2] or hardware-enforced [11, 12], no-
tably also assuming that JIT-compiled code is non-
readable.
• Hidden Code Pointers: We assume that all code
pointers, except for JIT-compiled ones, are present
but anonymized, e.g., via pointer indirections such
as trampolines proposed by Readactor. Note that, as
mentioned by Crane et al., Readactor(++) could be
extended to also hide code pointers in JIT-compiled
code. However, there is no implementation that
shows this, neither is the performance impact of
such a scheme clear. In addition, having the com-
piler running in the same process as the attacker
might give the adversary the ability to read code
pointers during the compilation process. We thus
believe that hiding all possible (direct or indirect)
code pointers is a challenging task and the attacker
might still be able to leak the required function ad-
dresses.
• JIT Hardening: We assume modern JIT defenses
such as randomized JIT pages, constant blinding,
and guard pages (i.e., putting an unmapped page be-
tween mapped ones). In our attack, for simplicity,
we assume that sandboxing is either disabled or can
be bypassed via additional vulnerabilities.
In ad-
dition, assessing the security of Control Flow In-
tegrity (CFI) defenses in JIT compilers is out of
scope of this paper, as our core contribution is to
show that an attacker can inject gadgets, and not
to discuss the actual process of diverting control
ﬂow. Instead, we demonstrate the threat of attacker-
controlled code emitted by the JIT compiler.
3.2 Threat Model
In the following, we enumerate our assumptions about
the attacker. This model is consistent with the threat
model of previous attacks such as JIT-ROP [31] and with
the XnR-based defense schemes.
• Memory Disclosure Vulnerability: We assume
that the target program has a memory disclosure
vulnerability, which can be exploited repeatedly by
the attacker to disclose the readable memory space
(i.e., we can read data, but cannot read code).
• Control-Flow Diversion: We assume that the target
program has a control-ﬂow vulnerability, allowing
the attacker to divert the control ﬂow to an arbitrary
location. Note that this by itself does not allow the
attacker to exploit the program, given the lack of
ROP gadgets due to ﬁne-grained ASLR and XnR.
• JavaScript Environment: We assume that the vul-
nerable process has a scripting environment sup-
porting JIT compilation, for which the attacker can
generate arbitrary JavaScript code. This is common
for victims that use a browser to visit an attacker-
controlled web site. Similarly, it applies to other
programs such as PDF readers.
4
JIT-Compiled Displacement Gadgets
In this section, we discuss how an attacker can induce
new JIT-compiled gadgets by crafting special JavaScript
code. Intuitively, we show that an attacker can generate
predictable JIT-compiled code such that she can reuse
the code without searching for it. We introduce new
techniques to trigger predictable gadgets that all mod-
ern JavaScript engines happen to generate. We demon-
strate that an attacker can create and use almost arbi-
trary x86/x64 gadgets in modern browsers and their cor-
responding JavaScript engines, such as Google Chrome
(V8), MS Internet Explorer (Chakra), and Mozilla Fire-
fox (SpiderMonkey).
First,
We introduce two techniques to emit gadgets via im-
plicit constants.
in Section 4.1, we leverage
JavaScript’s control ﬂow instructions and emit condi-
tional jumps (such as je 0x123456) that may encode
dangerous offsets. Second, in Section 4.3, we show how
an attacker can leverage offsets in direct calls, such as
call 0x123456, to create gadgets.
4.1 Conditional Jump Gadgets
Our ﬁrst target is to turn offsets encoded in conditional
jumps (in JIT-compiled code) into gadgets. To this
end, we use JavaScript statements, such as condition-
als (if/else) or loops (for/while), that are compiled
to conditional jumps. Figure 1(A) shows an example.
In js gadget, the body of the if statement contains a
variable-length JavaScript code. After compilation, the
if statement is converted to a sequence of assembly in-
structions containing a conditional jump, which, depend-
ing on the branch condition, either jumps over the body
or falls through (e.g., je ). By varying
USENIX Association  
25th USENIX Security Symposium  143
5
function  js_gadget(arg){
  if (arg)
  {
    /* More JS Code */
  }
  return;
}
test eax, eax
je   0x
c380cd
... ;asm code
ret
(A) JavaScript function
(B) Disassembly
Figure 1: JavaScript function js gadget and its corre-
sponding disassembly
the code size inside the if body, we change the jump
distance and thus the value encoded in the displacement
ﬁeld of the jump instruction in the compiled code. For
example, if we aim for a int 0x80;ret (0xcd80c3) gad-
get, we have to ﬁll the body of the if statement with
JavaScript code that is compiled to 0xc380cd bytes. The
size of the JIT-compiled code for each JavaScript state-
ment is ﬁxed by the corresponding JIT compiler, and thus
an attacker can precisely generate code of any arbitrary
length. Note that the bytes of the size and the emitted
gadget are mirrored because of the little-endian format
used in x86/x64 architectures. The compiled version of
js gadget is shown in Figure 1(B).
Emitting such three-byte gadgets requires large por-
tions of JavaScript code. In case the malicious JavaScript
code has to be loaded via the Internet, this might drasti-
cally increase the time required for all gadgets to be in
place. An attacker could overcome this limitation by uti-
lizing the eval function. Instead of having ready-made
JavaScript code, we thus use a function that constructs
and emits all required gadgets on-the-ﬂy. Such a script
to dynamically generate arbitrary gadgets occupies less
than one kilobyte.
In a na¨ıve attack instantiation, each additional gadget
will increase the overall code size. To counter this poten-
tial limitation, we can also embed smaller gadgets into
the bigger ones by stacking if statements inside the body
of another if statement, ideally reducing the size of the
JavaScript code to the size of the biggest gadget.
Computing addresses of JavaScript functions: In or-
der to use generated gadgets, we have to compute their
addresses. We start by revealing the address of the JIT-
compiled JavaScript function, which contains emitted
gadgets, by employing a memory disclosure vulnerabil-
ity. We can do this, for example, by passing the func-
tion as a parameter to another one, thus pushing its value
on the stack. Afterwards, in the callee, we read the
stack, revealing the pointer to the function’s JavaScript
object, which contains the code pointer to the actual (JIT-
compiled) function. Note that here we assume that we
know the location of the stack. This can be done by
chasing the data pointers in the readable memory, until
we ﬁnd a pointer pointing to the stack.
Because of the predictable code output of JIT compil-
ers, we know the offsets inside the JIT-compiled func-
tion, at which conditional jumps will be emitted and can
thus compute the addresses of emitted gadgets.
4.2 Conditional Jump Gadgets in Browsers
We tested this technique against three modern browsers:
Chrome 33 (32-bit)/Chrome 51(64-bit), Firefox 42 (64-
bit) and IE 11 (64-bit with 32-bit JavaScript engine).
There are some differences that need to be taken into
account for each of them. For example, Chrome com-
piles JavaScript functions the ﬁrst time they are called,
while Firefox and IE interpret them a few times until
they are called too often (e.g., around 50 times for IE
and 10 times for Firefox) and only then JIT-compile the
JavaScript code. Therefore, to trigger the compilation we
just call the function multiple times and then wait until it
is compiled (which takes a few milliseconds).
Chrome: As each browser has its own JIT compiler, an
attacker has to vary the JavaScript code to ﬁll the exact
number of bytes in the if body. This is just a matter of
ﬁnding a mapping between JavaScript statements and the
number of bytes of their JIT-compiled equivalent. We
will demonstrate this by emitting a system call gadget
(int 0x80;ret) in 32-bit Chrome. To this end, we need
to emit 0xcd80c3, i.e., we need to ﬁll the if body with
JavaScript code that is JIT-compiled to 0xc380cd bytes.
We use the following two JavaScript statements:
S1: v=v1+v2, compiling to 0x10 bytes, and
S2: v=0x01010101, compiling to 0xd bytes.
By combining these two statements, we can generate ar-
bitrary gadgets. In our case, we use S1 0x0c 38 0c times
(resulting in 0xc3 80 c0 bytes) and S2 once—summing
up to 0xc3 80 cd, our desired gadget.
Note that the JavaScript statement that compiles to
0x10 bytes allows us to control each hex digit of the emit-
ted jump distance except the last one (i.e., the least sig-
niﬁcant half-byte of the gadgets’ ﬁrst byte). Moreover,
any JavaScript statement that compiles to an odd number
of bytes allows us to control the least signiﬁcant half-
byte of the distance. Combining these two properties,
we can generate any gadget by using these two selected
JavaScript statements multiple times.
The sizes of JIT-compiled JavaScript statements differ
in 64- and 32-bit versions of Chrome. In 64-bit Chrome
we replace S1 with v=v, which is compiled to 0x10 bytes.
Note, however, that even though the size of S2 in 64-bit
is also changed to 0x1b bytes, we can still use it because
it is compiled to an odd number of bytes.
Firefox: To generate arbitrary gadgets for Firefox, we
choose the following two statements:
S1: v=v, compiled to 8 bytes (two of them to 0x10), and
S2: v+=0x1, compiled to 0x21 bytes.
144  25th USENIX Security Symposium 
USENIX Association
6
0x0000: call FUN_1
0x0005: call FUN_1
0x000a: ...