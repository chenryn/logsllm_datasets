is through a fnstenv instruction, which stores the current
F P U environment that includes the program counter of a
preceding F P U instruction, in an area of memory speciﬁed
by the instruction. Then the value of this program counter
can be read by a following instruction and used to compute
the absolute address of the encrypted payload. Examples of
GetP C code are shown in ﬁgure 2.
We term the call or fnstenv seeding instructions. A
seeding instruction stores a program counter (P C) of one
decryption routine instruction as the base address for later
instructions to compute absolute addresses of the encrypted
payload as oﬀsets from the base address. Seeding instruc-
tions are the key instructions for GetP C code to work. The
number of candidate seeding instructions in the Intel in-
struction set is expected to be limited.
By scanning the network packet for the seeding instruc-
tion (call, fnstenv etc.) of GetP C code, the start of a
decryption routine can be coarsely located. Each such in-
struction found is treated as if it belongs to a decryption
routine.
Recursive Traversal To Detect Decryption Loop
Structure.
Recursive traversal is a standard disassembly technology. It
is robust against data-injection attacks, in which code is in-
terleaved with data. The proposed method uses it to ﬁnd
the control ﬂow structure of the decryption routine. Once
a loop is detected during recursive traversal, this is a candi-
date for a decryption routine. However, a recursive traversal
may be hindered by indirect addressing branch instructions,
and the loop structure can be hidden by self-modiﬁcation
techniques. An enhanced approach can address these two
1M. Polychronakis et al.
[19] also mentioned a third form
of GetP C code which is to exploit the structure exception
handling(SEH) mechanism of Windows. However they men-
tioned this technique is not feasible with advanced version
of Windows.
issues. The approach uses (a) two-way traversal and back-
ward data-ﬂow analysis, and (b) a limited emulation of in-
struction execution.
3.2.2 Enhanced Approach
The enhanced approach deals with the two issues when
a self-modifying decryption routine is used and the indirect
addressing branch instruction is used.
Two-way Traversal and Backward Data Flow Anal-
ysis To Find Decryption Instructions.
The enhanced method uses both forward and backward traver-
sal of bytes from the seeding instruction to ﬁnd the rest in-
structions of the decryption routine. Forward traversal, as
usual, recursively decodes the bytes by following the control
ﬂow, starting at the seeding instruction. It can ﬁnd the in-
structions that are data-ﬂow dependent on the GetP C code.
This includes the instructions directly responsible for data
decryption. Backward traversal decodes bytes in a reverse
direction of the control ﬂow, also starting at the seeding in-
struction. Backward traversal is needed since the seeding
instruction may not be the very ﬁrst instruction of the de-
cryption routine, i.e.
the initialization instructions. This
analysis step is quick if the seeding instruction is close to
the start of the decryption routine. Multiple instruction se-
quences could be found during a backward traversal due to
the self-synchronization property of the Intel instruction set
2. The enhanced method uses backward data ﬂow analysis
to determine whether a backward traversal is demanded and
which instruction sequence found during such a traversal ac-
tually belongs to the decryption routine that exists before
the GetP C code.
First, the method performs forward traversal which starts
at the seeding instruction and follows the control ﬂow to
dissemble the byte sequences.
Then, the method triggers a backward data ﬂow analysis
if a target instruction, an instruction that is either (a) an in-
struction that writes to memory, or (b) a branch instruction
with indirect addressing, is encountered during the forward
traversal. When the target instruction is (a), it could be an
instruction used for decrypting the hidden loop or the en-
crypted payload. When the target instruction is (b), it could
2A set of bytes is self-synchronizing if it disassembles to the
same instruction sequence even if slightly diﬀerent starting
points are chosen. Please refer [10] for more detail.
(cid:1)(cid:1)(cid:1)(cid:1)(cid:2)(cid:2)(cid:2)(cid:2)(cid:3)(cid:4)(cid:2)(cid:5)(cid:4)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:6)(cid:7)(cid:8)(cid:2)(cid:9)(cid:5)(cid:10)(cid:11)(cid:2)(cid:9)(cid:5)(cid:10)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:1)(cid:1)(cid:1)(cid:3)(cid:2)(cid:2)(cid:2)(cid:2)(cid:12)(cid:12)(cid:2)(cid:8)(cid:4)(cid:2)(cid:13)(cid:3)(cid:2)(cid:1)(cid:14)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:15)(cid:16)(cid:17)(cid:2)(cid:5)(cid:10)(cid:11)(cid:2)(cid:1)(cid:14)(cid:13)(cid:3)(cid:1)(cid:1)(cid:1)(cid:12)(cid:2)(cid:2)(cid:2)(cid:2)(cid:9)(cid:18)(cid:2)(cid:19)(cid:19)(cid:2)(cid:19)(cid:19)(cid:2)(cid:19)(cid:19)(cid:2)(cid:19)(cid:19)(cid:5)(cid:20)(cid:21)(cid:21)(cid:2)(cid:1)(cid:1)(cid:1)(cid:22)(cid:1)(cid:1)(cid:1)(cid:22)(cid:2)(cid:2)(cid:2)(cid:19)(cid:19)(cid:2)(cid:5)(cid:14)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:23)(cid:24)(cid:5)(cid:2)(cid:9)(cid:5)(cid:10)(cid:1)(cid:1)(cid:1)(cid:25)(cid:2)(cid:2)(cid:2)(cid:26)(cid:9)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:27)(cid:16)(cid:27)(cid:2)(cid:9)(cid:6)(cid:23)(cid:1)(cid:1)(cid:1)(cid:28)(cid:2)(cid:2)(cid:2)(cid:29)(cid:1)(cid:2)(cid:13)(cid:5)(cid:2)(cid:1)(cid:9)(cid:2)(cid:1)(cid:30)(cid:10)(cid:16)(cid:31)(cid:2) (cid:9)(cid:6)(cid:23)!(cid:9)(cid:5)(cid:10)!(cid:1)(cid:30)"(cid:11)(cid:2)(cid:5)(cid:21)(cid:1)(cid:1)(cid:14)(cid:14)(cid:2)(cid:2)(cid:2)(cid:2)(cid:9)(cid:3)(cid:2)(cid:19)(cid:20)(cid:21)(cid:16)(cid:16)(cid:27)(cid:2)(cid:1)(cid:1)(cid:1)(cid:28)#$(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)%(cid:9)(cid:24)(cid:5)(cid:31)&(cid:27)’(cid:9)((cid:2)(cid:27)(cid:20)&(cid:21)(cid:16)(cid:20)()(cid:1)(cid:1)(cid:1)(cid:1)(cid:2)(cid:2)(cid:2)(cid:9)(cid:8)(cid:2)(cid:1)(cid:5)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)*(cid:15)(cid:27)(cid:2)(cid:1)(cid:1)(cid:1)+(cid:1)(cid:1)(cid:1)(cid:3)(cid:2)(cid:2)(cid:2)(cid:26)(cid:9)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:27)(cid:16)(cid:27)(cid:2)(cid:9)(cid:6)(cid:23)(cid:1)(cid:1)(cid:1)(cid:29)(cid:2)(cid:2)(cid:2)(cid:26)(cid:12)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:27)(cid:7)(cid:6),(cid:2)(cid:9)(cid:6)(cid:23)(cid:1)(cid:1)(cid:1)(cid:13)(cid:2)(cid:2)(cid:2)(cid:29)(cid:14)(cid:2)(cid:14)(cid:9)(cid:10)(cid:16)(cid:31)(cid:2) (cid:9)(cid:6)(cid:23)"(cid:11)(cid:2)(cid:9)(cid:8)(cid:10)(cid:1)(cid:1)(cid:1)(cid:12)(cid:2)(cid:2)(cid:2)(cid:20)((cid:21)(cid:16)((cid:6)((cid:1)(cid:1)(cid:1)(cid:30)(cid:2)(cid:2)(cid:2)(cid:1)(cid:14)(cid:2)(cid:5)(cid:29)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:20)(((cid:2)(cid:9)(cid:8)(cid:10)(cid:11)(cid:2)(cid:9)(cid:20)(cid:10)(cid:1)(cid:1)(cid:1)(cid:4)(cid:2)(cid:2)(cid:2)(cid:18)(cid:26)(cid:2)(cid:5)(cid:1)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)’(cid:9)(cid:6)’(cid:2)(cid:9)(cid:20)(cid:10)(cid:11)(cid:2)(cid:9)(cid:20)(cid:10)(cid:1)(cid:1)(cid:1)-(cid:2)(cid:2)(cid:30)(cid:26)(cid:2)(cid:19)(cid:30)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)*(cid:24)(cid:9)(cid:2)(cid:1)(cid:1)(cid:1)(cid:13)(cid:1)(cid:1)(cid:1)(cid:28)(cid:2)(cid:2)(cid:5)(cid:29)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:31)(cid:9)’(cid:1)(cid:1)(cid:1)+(cid:2)(cid:2)(cid:9)(cid:18)(cid:2)(cid:9)(cid:19)(cid:2)(cid:19)(cid:19)(cid:2)(cid:19)(cid:19)(cid:2)(cid:19)(cid:19)(cid:2)(cid:2)(cid:2)(cid:2)(cid:5)(cid:20)(cid:21)(cid:21)(cid:2)(cid:1)(cid:1)(cid:1)(cid:3)#$(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)%(cid:9)(cid:24)(cid:5)(cid:31)&(cid:27)’(cid:9)((cid:2)(cid:27)(cid:20)&(cid:21)(cid:16)(cid:20)().(cid:20)/.(cid:8)/Figure 3: Disassembly of Self-Modifying decryption routine for ShikataGaNai encoder. a) Before Execution b) After
Execution. In each ﬁgure, the leftmost column shows instructions’ addresses represented in hex format; the middle
column shows the actual instruction bytes; the rightmost column shows the decoded instructions. The fnstenv instruc-
tion is the seeding instruction. The xor [ebx+15], edi] is the instruction for decrypting the self-modifying decryption
routine and encrypted exploit payload. Instruction fcmovb st(0), st(7) at address 0002, fnstenv 14/28byte[esp-0c] at
address 0006 and pop ebx at address 000F are the GetP C code of this example. The loop structure is revealed after
execution.
be an instruction to obfuscate the control ﬂow. Either of the
instructions is signiﬁcant. Backwards data-ﬂow analysis is a
popular technique for program analysis [15]. Here we use it
to ﬁnd instructions on which the target instruction has data-
ﬂow dependency (i.e. we follow backwards the def ine− use
chain) in order to determine the operands (i.e. write-to ad-
dress and write-to value) of the target instruction. If all the
required variables have been deﬁned till the seeding instruc-
tion, then there is no non-GetP C decryption routine code
that exists earlier than the seeding instruction. Otherwise,
there must be.
Finally, the method performs backward traversal on de-
mand, determined as described above. Backward traversal
decodes bytes in a reverse direction of the control ﬂow. It
is implemented using breadth ﬁrst search, starting at the
seeding instruction. First the set of instructions that di-
rectly reach the seeding instruction at byte oﬀset i of the
input network traﬃc are found. This set will possibly con-
tain branch instructions whose target is the instruction at
oﬀset i. The set may also contain non-branching instruc-
tions immediately preceding the seeding instruction. Then
instructions reaching instructions in this set are found, etc.
A branch instruction using indirect addressing is unlikely to
appear prior to the seeding instruction in the control ﬂow for
the simple reason that the GetP C code must be executed
ﬁrst. The same is true for self-modifying instructions.
It must be decided which instruction sequence found dur-
ing the backward traversal actually belongs to the decryp-
tion routine and exists before the GetP C code. Backwards
data-ﬂow analysis is used again. To choose which instruc-
tion sequence contains these code, we pick one that deﬁnes
all the rest variables or is the longest of multiple qualiﬁed
instruction sequences.
Figure 3(a) is an example to illustrate this two-way traver-