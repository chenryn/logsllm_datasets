### References

1. **Ivan Damgård and Gert Læssøe Mikkelsen. 2010.**  
   *Constant-Round Distributed RSA Key Generation.*  
   In *TCC 2010 (LNCS, Vol. 5978)*, edited by Daniele Micciancio. Springer, Heidelberg, pp. 183–200.  
   [DOI: 10.1007/978-3-642-11799-2_12](https://doi.org/10.1007/978-3-642-11799-2_12)

2. **Yvo Desmedt. 1994.**  
   *Threshold Cryptography.*  
   *European Transactions on Telecommunications* 5, 4 (July/Aug. 1994), pp. 449–457.

3. **Yvo Desmedt. 1998.**  
   *Some Recent Research Aspects of Threshold Cryptography (Invited Lecture).*  
   In *ISW’97 (LNCS, Vol. 1396)*, edited by Eiji Okamoto, George I. Davida, and Masahiro Mambo. Springer, Heidelberg, pp. 158–173.

4. **Yvo Desmedt and Yair Frankel. 1990.**  
   *Threshold Cryptosystems.*  
   In *CRYPTO’89 (LNCS, Vol. 435)*, edited by Gilles Brassard. Springer, Heidelberg, pp. 307–315.  
   [DOI: 10.1007/0-387-34805-0_28](https://doi.org/10.1007/0-387-34805-0_28)

5. **Yair Frankel, Philip D. MacKenzie, and Moti Yung. 1998.**  
   *Robust Efficient Distributed RSA-Key Generation.*  
   In *17th ACM PODC*, edited by Brian A. Coan and Yehuda Afek. ACM, p. 320.  
   [DOI: 10.1145/277697.277779](https://doi.org/10.1145/277697.277779)

6. **Tore Kasper Frederiksen, Yehuda Lindell, Valery Osheter, and Benny Pinkas. 2018.**  
   *Fast Distributed RSA Key Generation for Semi-honest and Malicious Adversaries.*  
   In *CRYPTO 2018, Part II (LNCS, Vol. 10992)*, edited by Hovav Shacham and Alexandra Boldyreva. Springer, Heidelberg, pp. 331–361.  
   [DOI: 10.1007/978-3-319-96881-0_12](https://doi.org/10.1007/978-3-319-96881-0_12)

7. **Jun Furukawa, Yehuda Lindell, Ariel Nof, and Or Weinstein. 2017.**  
   *High-Throughput Secure Three-Party Computation for Malicious Adversaries and an Honest Majority.*  
   In *EUROCRYPT 2017, Part II (LNCS, Vol. 10211)*, edited by Jean-Sébastien Coron and Jesper Buus Nielsen. Springer, Heidelberg, pp. 225–255.  
   [DOI: 10.1007/978-3-319-56614-6_8](https://doi.org/10.1007/978-3-319-56614-6_8)

8. **Rosario Gennaro, Michael O. Rabin, and Tal Rabin. 1998.**  
   *Simplified VSS and Fast-Track Multiparty Computations with Applications to Threshold Cryptography.*  
   In *17th ACM PODC*, edited by Brian A. Coan and Yehuda Afek. ACM, pp. 101–111.  
   [DOI: 10.1145/277697.277716](https://doi.org/10.1145/277697.277716)

9. **Niv Gilboa. 1999.**  
   *Two Party RSA Key Generation.*  
   In *CRYPTO’99 (LNCS, Vol. 1666)*, edited by Michael J. Wiener. Springer, Heidelberg, pp. 116–129.  
   [DOI: 10.1007/3-540-48405-1_8](https://doi.org/10.1007/3-540-48405-1_8)

10. **Lorenzo Grassi, Christian Rechberger, Dragos Rotaru, Peter Scholl, and Nigel P. Smart. 2016.**  
    *MPC-Friendly Symmetric Key Primitives.*  
    In *ACM CCS 2016*, edited by Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai Halevi. ACM Press, pp. 430–443.  
    [DOI: 10.1145/2976749.2978332](https://doi.org/10.1145/2976749.2978332)

11. **Carmit Hazay, Gert Læssøe Mikkelsen, Tal Rabin, and Tomas Toft. 2012.**  
    *Efficient RSA Key Generation and Threshold Paillier in the Two-Party Setting.*  
    In *CT-RSA 2012 (LNCS, Vol. 7178)*, edited by Orr Dunkelman. Springer, Heidelberg, pp. 313–331.  
    [DOI: 10.1007/978-3-642-27954-6_20](https://doi.org/10.1007/978-3-642-27954-6_20)

12. **Carmit Hazay, Gert Læssøe Mikkelsen, Tal Rabin, Tomas Toft, and Angelo Agatino Nicolosi. 2019.**  
    *Efficient RSA Key Generation and Threshold Paillier in the Two-Party Setting.*  
    *Journal of Cryptology* 32, 2 (April 2019), pp. 265–323.  
    [DOI: 10.1007/s00145-017-9275-7](https://doi.org/10.1007/s00145-017-9275-7)

13. **Lukas Helminger, Daniel Kales, Sebastian Ramacher, and Roman Walch. 2020.**  
    *Multi-Party Revocation in Sovrin: Performance through Distributed Trust.*  
    *Cryptology ePrint Archive, Report 2020/724.*  
    [Link](https://eprint.iacr.org/2020/724)

14. **Jonathan Katz and Yehuda Lindell. 2020.**  
    *Introduction to Modern Cryptography.*  
    CRC Press.

15. **Marcel Keller. 2020.**  
    *MP-SPDZ: A versatile framework for multi-party computation.*  
    In *Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communications Security*. pp. 1575–1590.

16. **Marcel Keller, Emmanuela Orsini, and Peter Scholl. 2016.**  
    *MASCOT: Faster Malicious Arithmetic Secure Computation with Oblivious Transfer.*  
    In *ACM CCS 2016*, edited by Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai Halevi. ACM Press, pp. 830–842.  
    [DOI: 10.1145/2976749.2978357](https://doi.org/10.1145/2976749.2978357)

17. **Marcel Keller, Valerio Pastro, and Dragos Rotaru. 2018.**  
    *Overdrive: Making SPDZ Great Again.*  
    In *EUROCRYPT 2018, Part III (LNCS, Vol. 10822)*, edited by Jesper Buus Nielsen and Vincent Rijmen. Springer, Heidelberg, pp. 158–189.  
    [DOI: 10.1007/978-3-319-78372-7_6](https://doi.org/10.1007/978-3-319-78372-7_6)

18. **Michael Malkin, Thomas D. Wu, and Dan Boneh. 1999.**  
    *Experimenting with Shared Generation of RSA Keys.*  
    In *NDSS'99*. The Internet Society.

19. **Krzysztof Pietrzak. 2019.**  
    *Simple Verifiable Delay Functions.*  
    In *ITCS 2019*, edited by Avrim Blum, Vol. 124. LIPIcs, pp. 60:1–60:15.  
    [DOI: 10.4230/LIPIcs.ITCS.2019.60](https://doi.org/10.4230/LIPIcs.ITCS.2019.60)

20. **Guillaume Poupard and Jacques Stern. 1998.**  
    *Generation of Shared RSA Keys by Two Parties.*  
    In *ASIACRYPT'98 (LNCS, Vol. 1514)*, edited by Kazuo Ohta and Dingyi Pei. Springer, Heidelberg, pp. 11–24.  
    [DOI: 10.1007/3-540-49649-1_2](https://doi.org/10.1007/3-540-49649-1_2)

21. **Tal Rabin. 1998.**  
    *A Simplified Approach to Threshold and Proactive RSA.*  
    In *CRYPTO'98 (LNCS, Vol. 1462)*, edited by Hugo Krawczyk. Springer, Heidelberg, pp. 89–104.  
    [DOI: 10.1007/BFb0055722](https://doi.org/10.1007/BFb0055722)

22. **Ronald L. Rivest, Adi Shamir, and Leonard M. Adleman. 1978.**  
    *A Method for Obtaining Digital Signatures and Public-Key Cryptosystems.*  
    *Communications of the Association for Computing Machinery* 21, 2 (1978), pp. 120–126.

23. **J. Barkley Rosser and Lowell Schoenfeld. 1962.**  
    *Approximate formulas for some functions of prime numbers.*  
    *Illinois Journal of Mathematics* 6, 1 (1962), pp. 64–94.  
    [DOI: 10.1215/ijm/1255631807](https://doi.org/10.1215/ijm/1255631807)

24. **Dragos Rotaru, Nigel P. Smart, Titouan Tanguy, Frederik Vercauteren, and Tim Wood. 2019.**  
    *Actively Secure Setup for SPDZ.*  
    *Cryptology ePrint Archive, Report 2019/1300.*  
    [Link](https://eprint.iacr.org/2019/1300)

25. **Berry Schoenmakers and Pim Tuyls. 2006.**  
    *Efficient Binary Conversion for Paillier Encrypted Values.*  
    In *EUROCRYPT 2006 (LNCS, Vol. 4004)*, edited by Serge Vaudenay. Springer, Heidelberg, pp. 522–537.  
    [DOI: 10.1007/11761679_31](https://doi.org/10.1007/11761679_31)

26. **Adi Shamir. 1979.**  
    *How to Share a Secret.*  
    *Communications of the Association for Computing Machinery* 22, 11 (Nov. 1979), pp. 612–613.

27. **Nigel P. Smart and Younes Talibi Alaoui. 2019.**  
    *Distributing Any Elliptic Curve Based Protocol.*  
    In *17th IMA International Conference on Cryptography and Coding (LNCS, Vol. 11929)*, edited by Martin Albrecht. Springer, Heidelberg, pp. 342–366.  
    [DOI: 10.1007/978-3-030-35199-1_17](https://doi.org/10.1007/978-3-030-35199-1_17)

28. **Benjamin Wesolowski. 2019.**  
    *Efficient Verifiable Delay Functions.*  
    In *EUROCRYPT 2019, Part III (LNCS, Vol. 11478)*, edited by Yuval Ishai and Vincent Rijmen. Springer, Heidelberg, pp. 379–407.  
    [DOI: 10.1007/978-3-030-17659-4_13](https://doi.org/10.1007/978-3-030-17659-4_13)

### Proof Sketch

Let \( A \) be a static malicious adversary who interacts with the parties running \(\Pi_{\text{RSAGen}}\) and can corrupt up to \( n-1 \) parties. We construct a simulator \( S \) that simulates the ideal functionality \( F_{\text{RSAGen}} \) such that no environment \( Z \) can distinguish whether it is interacting with \( A \) and \(\Pi_{\text{RSAGen}}\), or with \( A \) and \( F_{\text{RSAGen}} \). Let \( C \) denote the set of (up to \( n-1 \)) corrupted parties and let \( H \) denote the set of honest parties. The simulator \( S \) proceeds as follows:

#### Sample
The simulator performs all the steps below in parallel for \( p \) and \( q \):

1. For each honest party \( P_j \in H \), \( S \) samples \( \hat{p}(j) \) such that \(\gcd(M_{\text{sample}}, \hat{p}(j)) = 1\).
2. For each honest party \( P_j \in H \), \( S \) calls \( F_{\text{ABBWithErrors}}.\text{Input}(\hat{p}(j)) \).
3. For each corrupt party \( P_j \in C \), \( S \) receives \( p'(j) \) from \( A \).
4. When all parties call \( F_{\text{ABBWithErrors}}.\text{Mult} \), \( S \) waits for \(\Delta_p = \prod_{j=1}^n \hat{p}(j)\).
5. When all parties call \( F_{\text{ABBWithErrors}}.\text{Share}(p') \), \( S \) receives the shares \( p'(j) \) for each corrupt \( P_j \in C \). It then samples and stores the remaining shares \( p'(j) \) for honest \( P_j \in H \) such that \( p' = \Delta_p + \sum_{P_j \in H} p'(j) \). \( S \) then computes \( m_p = \prod_{j} p(j) \mod M_{\text{sample}} \) using its own values.
6. For each honest party \( P_j \in H \), \( S \) samples an appropriate \( r(j) \) such that \( p(j) = p'(j) + r(j) \cdot M_{\text{sample}} \) lies in the range \([2^\lambda, 2^{\lambda + \sigma}]\).
7. When each party calls \( F_{\text{MPC-CRT}}.\text{Input}(p(j), \ell_c) \) in Step 7, \( S \) receives from \( A \) the inputs \((p(j), \ell_c)\) for each corrupt \( P_j \in C \). With these, \( S \) can reconstruct \( p(j) \) for each corrupt \( P_j \) and simulated shares. It then sends `Sample` to \( F_{\text{RSAGen}} \) on behalf of the corrupt parties and, when prompted, submits \( m_p \) and the \( p(j) \) that it reconstructed. To continue simulating the protocol, \( S \) inputs its own simulated \( p(j) \) into \( F_{\text{MPC-CRT}} \) on behalf of the honest parties \( P_j \in H \).

#### Combine
By computing the residue of \( p \) and \( q \) modulo \( M_{\text{sample}} \) as influenced by \( A \) in Step 6 of the protocol, \( S \) ensures that the distribution of \( N \mod M_{\text{sample}} \) produced by \( F_{\text{RSAGen}} \) is identical to the one in the protocol. At this stage of the protocol, there is no transcript for \( S \) to simulate as the parties have only executed calls to other functionalities. We also note that the simulated shares \( p(j) \) are statistically close to the random shares sampled by \( F_{\text{RSAGen}} \), as measured by Lemma A.1, and identically distributed to the honest shares in a real execution.

1. When all parties call \( F_{\text{MPC-CRT}}.\text{Sum}((\mathcal{P}, \ell_c), (\mathcal{P}(1), \ell_c), \ldots, (\mathcal{P}(n), \ell_c)) \) and \( F_{\text{MPC-CRT}}.\text{Sum}((\mathcal{Q}, \ell_c), (\mathcal{Q}(1), \ell_c), \ldots, (\mathcal{Q}(n), \ell_c)) \) in Step 1, \( S \) internally executes the corresponding MPC sums.
2. When all parties call \( F_{\text{MPC-CRT}}.\text{Mult}((\mathcal{N}, \ell_c), (\mathcal{P}, \ell_c), (\mathcal{Q}, \ell_c)) \) in Step 2, \( S \) internally executes the corresponding MPC multiplications.
3. When all parties call \( F_{\text{MPC-CRT}}.\text{Open}((\mathcal{N}, \ell_c)) \) in Step 3, \( S \) sends `Combine` to \( F_{\text{RSAGen}} \) on behalf of the corrupt parties. Once the honest parties also send `Combine` to the functionality, \( S \) receives \( N_i \) for all \( i \in [\ell_c] \). To simulate the \( F_{\text{MPC-CRT}}.\text{Open} \) instruction, \( S \) then sends the \( N_i \) values it received to each corrupt party. \( S \) also updates its internal simulations of the \( F_{\text{MPC-CRT}} \) instances so that they hold the correct values for \( N \).
4. If \( S \) receives `AbortGCD` or `AbortOutOfRange` from \( F_{\text{RSAGen}} \), it makes the simulated honest parties also output the corresponding `Abort` in the protocol.

As the shares input by \( A \) are passed on \( F_{\text{RSAGen}} \) for the generation of \( N \), and as the shares simulated by \( S \) are statistically close to those sampled at random by \( F_{\text{RSAGen}} \), the distribution of \( N \) output by \( F_{\text{RSAGen}} \) is statistically close to the one produced by \( S \), which is itself identically distributed to those of a real execution.

#### Jacobi
1. When parties call \( F_{\text{AgreeRandom}} \), \( S \) simulates the sampling of the public \(\gamma\).
2. The simulator then queries \( F_{\text{RSAGen}}.\text{Jacobi}(\gamma) \) and receives \( y \).
3. To simulate the broadcast calls, \( S \) samples \( r_j \) at random to compute \( y(j) = \gamma^{r_j} \) for the honest parties \( P_j \in H \) and then modifies one of these shares \( y(i) \) for \( P_i \in H \) such that \( y(i) = y \cdot \left(\prod_{j \neq i} y(j)\right)^{-1} \). For corrupt parties \( P_j \in C \), the simulator uses the shares \( p(j), q(j) \) that \( A \) input to \( F_{\text{ABBWithErrors}} \) during sampling. Then \( S \) uses these simulated honest \( y(j) \)'s as the broadcast values of the honest parties.
4. When the corrupt parties call \( F_{\text{Broadcast}}(y(j)) \), \( S \) computes the new value of \( y' = \prod_{j} y(j) \) and sends it to \( F_{\text{RSAGen}} \).
5. If \( S \) receives `Abort` from \( F_{\text{RSAGen}} \), it makes the simulated honest parties also output `Abort`.

Since the simulated \( p(j) \) and \( q(j) \) values that \( S \) holds for \( P_j \in H \) are statistically close to uniform, the distribution of the broadcast \( y(j) \) values are statistically close to the protocol and consistent with the correct Jacobi test result first output by \( F_{\text{RSAGen}} \). If \( A \) cheats by using inconsistent values during its broadcast, then \( S \) correctly updates the result of the Jacobi test by passing the new \( y' \) to \( F_{\text{RSAGen}} \).

#### Consistency Check
1. When all parties call \( F_{\text{AdvMPC-CRT}}.\text{Rand2k} \), \( S \) samples a random \( x < 2^\sigma \) and receives the shares \((x(j), \ell_{\text{Jac}})\) for each corrupt \( P_j \in C \) from \( A \). It then samples the remaining shares \((x(j), \ell_{\text{Jac}})\) for honest \( P_j \in H \), such that \( x = \text{CRTrec}(x, \ell_1) = \sum_{j} x(j) \).
2. When all parties call \( F_{\text{MPC-CRT}}.\text{Mult}((\mathcal{T}, \ell_{\text{Jac}}), (x, \ell_{\text{Jac}}), ((N - p - q + 1)/4, \ell_{\text{Jac}})) \), \( S \) internally executes the MPC multiplication.
3. When all parties call \( F_{\text{AdvMPC-CRT}}.\text{ConvInt}((\mathcal{T}, \ell_{\text{Jac}})) \), \( S \) computes \( t_{\text{Int}} = y \cdot x \cdot \left(\prod_{j \neq i} \gamma^{t(j)}\right)^{-1} \), and broadcasts \( \gamma^{t(j)} \) for \( P_j \in H \).
4. To simulate the broadcast calls, \( S \) modifies one of the honest shares \( \gamma^{t(i)} \) for \( P_i \in H \) such that \( \gamma^{t(i)} = t_{\text{Int}} \). \( S \) then broadcasts \( \gamma^{t(j)} \) for \( P_j \in H \).
5. When all parties call \( F_{\text{MPC-CRT}}.\text{Open}((x, \ell_{\text{Jac}})) \), \( S \) simulates the opening and sends `Consistency Check` to \( F_{\text{RSAGen}} \) on behalf of the corrupt parties.
6. To reply to \( F_{\text{RSAGen}} \) about the abort, \( S \) checks whether \( t_{\text{Int}} = y \cdot x \) using the values that were broadcast. If the equality fails, \( S \) sends `Abort` to \( A \) on behalf of the honest parties.

The values used by \( S \) in Step 2 are identically distributed to those in the protocol, so the distribution of the modified share \( \gamma^{t(i)} \) in Step 4 is statistically close, as measured by Lemma A.1. As \( x \) is sampled at random identically, and the influence of \( A \) in the integer conversion of \( t \) is preserved, then the distribution of the broadcast of Step 4 is statistically close to the distribution of a real transcript.

Finally, the probability of abort when \( A \) behaves honestly remains the same, since Step 4 modifies the honest shares to be consistent with the \( y \) output. When \( A \) acts maliciously in the broadcast of \( \gamma^{t(j)} \), we claim that it has a negligible chance of making the equality hold, if it had already cheated in the Jacobi test. If it successfully makes the equality hold, this creates a difference between the real and ideal world as \( F_{\text{RSAGen}} \) would abort, since it received a modified \( y' \) from \( S \) but \( S \) would not abort. As we assume that \( A \) successfully cheated in the Jacobi test, this ensures that the simulation is indistinguishable from the real execution.