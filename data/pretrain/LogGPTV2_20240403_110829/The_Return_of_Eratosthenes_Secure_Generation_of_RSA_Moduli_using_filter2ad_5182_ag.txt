[12] Ivan Damgård and Gert Læssøe Mikkelsen. 2010.
Efficient, Robust and
In TCC 2010 (LNCS,
5978), Daniele Micciancio (Ed.). Springer, Heidelberg, 183–200.
Constant-Round Distributed RSA Key Generation.
Vol.
https://doi.org/10.1007/978-3-642-11799-2_12
[13] Yvo Desmedt. 1994. Threshold cryptography.
European Transactions on
Telecommunications 5, 4 (July/Aug. 1994), 449–457.
[14] Yvo Desmedt. 1998. Some Recent Research Aspects of Threshold Cryptography
(Invited Lecture). In ISW’97 (LNCS, Vol. 1396), Eiji Okamoto, George I. Davida,
and Masahiro Mambo (Eds.). Springer, Heidelberg, 158–173.
[15] Yvo Desmedt and Yair Frankel. 1990. Threshold Cryptosystems. In CRYPTO’89
(LNCS, Vol. 435), Gilles Brassard (Ed.). Springer, Heidelberg, 307–315.
https://doi.org/10.1007/0-387-34805-0_28
[16] Yair Frankel, Philip D. MacKenzie, and Moti Yung. 1998. Robust Efficient
Distributed RSA-Key Generation. In 17th ACM PODC, Brian A. Coan and Yehuda
Afek (Eds.). ACM, 320. https://doi.org/10.1145/277697.277779
[17] Tore Kasper Frederiksen, Yehuda Lindell, Valery Osheter, and Benny Pinkas.
Fast Distributed RSA Key Generation for Semi-honest and Ma-
2018.
licious Adversaries. In CRYPTO 2018, Part II
(LNCS, Vol. 10992), Hovav
Shacham and Alexandra Boldyreva (Eds.). Springer, Heidelberg, 331–361.
https://doi.org/10.1007/978-3-319-96881-0_12
[18] Jun Furukawa, Yehuda Lindell, Ariel Nof, and Or Weinstein. 2017. High-
Throughput Secure Three-Party Computation for Malicious Adversaries and
an Honest Majority. In EUROCRYPT 2017, Part II (LNCS, Vol. 10211), Jean-
Sébastien Coron and Jesper Buus Nielsen (Eds.). Springer, Heidelberg, 225–255.
https://doi.org/10.1007/978-3-319-56614-6_8
[20] Niv Gilboa. 1999.
[19] Rosario Gennaro, Michael O. Rabin, and Tal Rabin. 1998.
Simplified VSS
and Fast-Track Multiparty Computations with Applications to Threshold
Cryptography. In 17th ACM PODC, Brian A. Coan and Yehuda Afek (Eds.). ACM,
101–111. https://doi.org/10.1145/277697.277716
In CRYPTO’99
(LNCS, Vol. 1666), Michael J. Wiener (Ed.). Springer, Heidelberg, 116–129.
https://doi.org/10.1007/3-540-48405-1_8
[21] Lorenzo Grassi, Christian Rechberger, Dragos Rotaru, Peter Scholl, and Nigel P.
Smart. 2016. MPC-Friendly Symmetric Key Primitives. In ACM CCS 2016, Edgar R.
Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai
Two Party RSA Key Generation.
Halevi (Eds.). ACM Press, 430–443. https://doi.org/10.1145/2976749.2978332
CRC press.
[22] Carmit Hazay, Gert Læssøe Mikkelsen, Tal Rabin, and Tomas Toft. 2012. Efficient
RSA Key Generation and Threshold Paillier in the Two-Party Setting. In
CT-RSA 2012 (LNCS, Vol. 7178), Orr Dunkelman (Ed.). Springer, Heidelberg,
313–331. https://doi.org/10.1007/978-3-642-27954-6_20
[23] Carmit Hazay, Gert Læssøe Mikkelsen, Tal Rabin, Tomas Toft, and Angelo Agatino
Efficient RSA Key Generation and Threshold Paillier in
Journal of Cryptology 32, 2 (April 2019), 265–323.
[24] Lukas Helminger, Daniel Kales, Sebastian Ramacher, and Roman Walch. 2020.
Multi-Party Revocation in Sovrin: Performance through Distributed Trust.
Cryptology ePrint Archive, Report 2020/724. https://eprint.iacr.org/2020/724.
Nicolosi. 2019.
the Two-Party Setting.
https://doi.org/10.1007/s00145-017-9275-7
[25] Jonathan Katz and Yehuda Lindell. 2020. Introduction to Modern Cryptography.
[26] Marcel Keller. 2020. MP-SPDZ: A versatile framework for multi-party com-
putation. In Proceedings of the 2020 ACM SIGSAC Conference on Computer and
Communications Security. 1575–1590.
[27] Marcel Keller, Emmanuela Orsini, and Peter Scholl. 2016. MASCOT: Faster Mali-
cious Arithmetic Secure Computation with Oblivious Transfer. In ACM CCS 2016,
Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and
Shai Halevi (Eds.). ACM Press, 830–842. https://doi.org/10.1145/2976749.2978357
[28] Marcel Keller, Valerio Pastro, and Dragos Rotaru. 2018. Overdrive: Making
SPDZ Great Again. In EUROCRYPT 2018, Part III (LNCS, Vol. 10822), Jes-
per Buus Nielsen and Vincent Rijmen (Eds.). Springer, Heidelberg, 158–189.
https://doi.org/10.1007/978-3-319-78372-7_6
[29] Michael Malkin, Thomas D. Wu, and Dan Boneh. 1999. Experimenting with
Shared Generation of RSA Keys. In NDSS’99. The Internet Society.
[30] Krzysztof Pietrzak. 2019. Simple Verifiable Delay Functions. In ITCS 2019, Avrim
Blum (Ed.), Vol. 124. LIPIcs, 60:1–60:15. https://doi.org/10.4230/LIPIcs.ITCS.2019.
60
[31] Guillaume Poupard and Jacques Stern. 1998. Generation of Shared RSA Keys by
Two Parties. In ASIACRYPT’98 (LNCS, Vol. 1514), Kazuo Ohta and Dingyi Pei (Eds.).
Springer, Heidelberg, 11–24. https://doi.org/10.1007/3-540-49649-1_2
[32] Tal Rabin. 1998. A Simplified Approach to Threshold and Proactive RSA. In
CRYPTO’98 (LNCS, Vol. 1462), Hugo Krawczyk (Ed.). Springer, Heidelberg, 89–104.
https://doi.org/10.1007/BFb0055722
[33] Ronald L. Rivest, Adi Shamir, and Leonard M. Adleman. 1978. A Method for
Obtaining Digital Signatures and Public-Key Cryptosystems. Communications
of the Association for Computing Machinery 21, 2 (1978), 120–126.
[34] J. Barkley Rosser and Lowell Schoenfeld. 1962. Approximate formulas for some
functions of prime numbers. Illinois Journal of Mathematics 6, 1 (1962), 64 – 94.
https://doi.org/10.1215/ijm/1255631807
[35] Dragos Rotaru, Nigel P. Smart, Titouan Tanguy, Frederik Vercauteren, and Tim
Wood. 2019. Actively Secure Setup for SPDZ. Cryptology ePrint Archive, Report
2019/1300. https://eprint.iacr.org/2019/1300.
[36] Berry Schoenmakers and Pim Tuyls. 2006. Efficient Binary Conversion for Paillier
Encrypted Values. In EUROCRYPT 2006 (LNCS, Vol. 4004), Serge Vaudenay (Ed.).
Springer, Heidelberg, 522–537. https://doi.org/10.1007/11761679_31
[37] Adi Shamir. 1979. How to Share a Secret. Communications of the Association for
Computing Machinery 22, 11 (Nov. 1979), 612–613.
[38] Nigel P. Smart and Younes Talibi Alaoui. 2019. Distributing Any Elliptic Curve
Based Protocol. In 17th IMA International Conference on Cryptography and
Coding (LNCS, Vol. 11929), Martin Albrecht (Ed.). Springer, Heidelberg, 342–366.
https://doi.org/10.1007/978-3-030-35199-1_17
[39] Benjamin Wesolowski. 2019. Efficient Verifiable Delay Functions. In EURO-
CRYPT 2019, Part III (LNCS, Vol. 11478), Yuval Ishai and Vincent Rijmen (Eds.).
Springer, Heidelberg, 379–407. https://doi.org/10.1007/978-3-030-17659-4_13
A PROOF OF THEOREM 4.1
Proof Sketch. Let A be a static malicious adversary, who interacts
with the parties running ΠRSAGen and can corrupt up to 𝑛−1 parties.
We construct a simulator S, simulating the ideal functionality
FRSAGen, such that no environment Z can distinguish whether it
is interacting with A and the ΠRSAGen, or with A and FRSAGen. Let
C denote the set of (up to 𝑛−1) corrupted parties and let H denote
the set of honest parties. The simulator S proceeds as follows:
Sample: The simulator performs all the steps below in parallel
for 𝑝 and 𝑞.
(1) For each honest 𝑃 𝑗 ∈ H, S samples ˆ𝑝( 𝑗) such that
gcd(𝑀sample, ˆ𝑝( 𝑗)) =1.
Session 2D: Secure Multiparty Computation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea606𝑃 𝑗
each
corrupt
𝑗=1𝑝′( 𝑗).
∈
For
FABBWithErrors.Input( ˆ𝑝( 𝑗)) from A.
(2) For each honest 𝑃 𝑗 ∈ H, S calls FABBWithErrors.Input( ˆ𝑝( 𝑗)).
C, S receives
(3) When all parties call FABBWithErrors.Mult, S waits for Δ𝑝
𝑗=1 ˆ𝑝( 𝑗).
(4) When all parties call FABBWithErrors.Share(𝑝′), S receives
from A the shares 𝑝′( 𝑗) for each corrupt 𝑃 𝑗 ∈ C. It then
samples and stores the remaining shares 𝑝′( 𝑗) for honest
from A. After receiving Δ𝑝, S computes 𝑝′ = Δ𝑝+𝑛
𝑃 𝑗 ∈H such that 𝑝′ =𝑛
then compute 𝑚𝑝 =𝑗 𝑝( 𝑗) mod 𝑀sample using also its
(5) For each honest 𝑃 𝑗 ∈H, S samples an appropriate 𝑟 ( 𝑗) such
that 𝑝( 𝑗) =𝑝′( 𝑗)+𝑟 ( 𝑗) ·𝑀sample lies in the range [2𝜆,2𝜆+𝜎].
(6) When each party calls FMPC-CRT.Input(𝑝( 𝑗),ℓc) in Step 7, S
receives from A the inputs (𝑝( 𝑗),ℓc) for each corrupt 𝑃 𝑗 ∈C.
With these, S can reconstruct 𝑝( 𝑗) for each corrupt 𝑃 𝑗 and
simulated shares. It then sends Sample to FRSAGen on behalf
of the corrupt parties and, when prompted, submits 𝑚𝑝 and
the 𝑝( 𝑗) that it reconstructed. To continue simulating the
protocol, S inputs its own simulated 𝑝( 𝑗) into FMPC-CRT on
behalf of the honest parties 𝑃 𝑗 ∈H.
Combine:
By computing the residue of 𝑝 and𝑞 modulo 𝑀sample as influenced by
A in Step 6 of the protocol,S ensures that the distribution of 𝑁 mod
𝑀sample produced by FRSAGen is identical to the one in the protocol.
At this stage of the protocol, there is no transcript for S to simulate
as the parties have only executed calls to other functionalities. We
also note that the simulated shares 𝑝( 𝑗) are statistically close to the
random shares sampled by FRSAGen, as measured by Lemma A.1,
and identically distributed to the honest shares in a real execution.
(1) When all parties call FMPC-CRT.Sum((cid:74)𝑝,ℓc(cid:75),(cid:74)𝑝(1),ℓc(cid:75), ... ,
(cid:74)𝑝(𝑛),ℓc(cid:75)) and FMPC-CRT.Sum((cid:74)𝑞,ℓc(cid:75),(cid:74)𝑞(1),ℓc(cid:75), ... ,(cid:74)𝑞(𝑛),ℓc(cid:75))
in Step 1, S internally executes the corresponding MPC sums.
(2) When all parties call FMPC-CRT.Mult((cid:74)𝑁 ,ℓc(cid:75),(cid:74)𝑝,ℓc(cid:75),(cid:74)𝑞,ℓc(cid:75))
in Step 2, S internally executes the corresponding MPC
(3) When all parties call FMPC-CRT.Open((cid:74)𝑁 ,ℓc(cid:75)) in Step 3,
multiplications.
S sends Combine to FRSAGen on behalf of the corrupt
parties. Once the honest parties also send Combine to the
functionality, S receives 𝑁𝑖 for all 𝑖 ∈ [ℓc]. To simulate the
FMPC-CRT.Open instruction, S then sends the 𝑁𝑖 values it
received to each corrupt party. S also updates its internal
simulations of the FMPC-CRT instances so that they hold the
correct values for 𝑁 .
(4) If S receives AbortGCD or AbortOutOfRange from FRSAGen,
it makes the simulated honest parties also output the
corresponding Abort in the protocol.
As the shares input by A are passed on FRSAGen for the generation
of 𝑁 , and as the shares simulated by S are statistically close to those
sampled at random by FRSAGen, the distribution of 𝑁 output by
FRSAGen is statistically close to the one produced by S, which is
itself identically distributed to those of a real execution.
Jacobi:
(1) When parties call FAgreeRandom, S simulates the sampling
of the public 𝛾.
𝑗=1(𝑥 ( 𝑗),ℓJac).
honest parties output Abort.
𝑦·(𝑗≠𝑖𝑦( 𝑗))−1. Here, to compute𝑦( 𝑗) for the corrupt parties
the new value of 𝑦′ =𝑗𝑦( 𝑗) and sends it to FRSAGen.
(2) The simulator then queries FRSAGen.Jacobi(𝛾) and receives 𝑦.
(3) To simulate the broadcast calls, S samples 𝑟 𝑗 at random to
compute 𝑦( 𝑗) = 𝛾𝑟 𝑗 for the honest parties 𝑃 𝑗 ∈ H and then
modifies one of these shares 𝑦(𝑖) for 𝑃𝑖 ∈H such that 𝑦(𝑖) =
𝑃 𝑗 ∈C, the simulator uses the shares 𝑝( 𝑗),𝑞( 𝑗) that A input to
FABBWithErrors during sampling. ThenS uses these simulated
honest 𝑦( 𝑗)’s as the broadcast values of the honest parties.
(4) When the corrupt parties call FBroadcast(𝑦( 𝑗)), S computes
(5) If S receives Abort from FRSAGen, it makes the simulated
Since the simulated 𝑝( 𝑗) and 𝑞( 𝑗) values that S holds for 𝑃 𝑗 ∈ H
are statistically close to uniform, the distribution of the broadcast
𝑦( 𝑗) values are statistically close to the protocol and consistent with
the correct Jacobi test result first output by FRSAGen. If A cheats
by using inconsistent values during its broadcast, then S correctly
updates the result of the Jacobi test by passing the new𝑦′ to FRSAGen.
Consistency Check:
(1) When all parties call FAdvMPC−CRT.Rand2k, S samples
a random 𝑥 < 2𝜎 and receives the shares (𝑥 ( 𝑗), ℓJac)
𝑥 =CRTrec(𝑥,ℓ1) =𝑛
for each corrupt 𝑃 𝑗 ∈ C from A. It then samples the
remaining shares (𝑥 ( 𝑗), ℓJac) for honest 𝑃 𝑗 ∈ H, such that
(2) When all parties call FMPC-CRT.Mult((cid:74)𝑡,ℓJac(cid:75), (cid:74)𝑥,ℓJac(cid:75),
(cid:74)((𝑁 −𝑝−𝑞+1)/4),ℓJac(cid:75)), S internally executes the MPC
(3) When all parties call FAdvMPC−CRT.ConvInt((cid:74)𝑡,ℓJac(cid:75)), S
Int = 𝑦𝑥 · (𝑗≠𝑖 𝛾𝑡 ( 𝑗)
, and
(4) To simulate the broadcast calls, S modifies one of the honest
shares 𝛾𝑡 (𝑖)
Int )−1,
where 𝑦 is the value given to S by FRSAGen during the Jacobi
command and where S uses its internal values of 𝑥 and
𝑝( 𝑗), 𝑞( 𝑗) to compute 𝑡 ( 𝑗)
of the corrupt parties. S then
Int
broadcasts 𝛾𝑡 ( 𝑗)
(5) When all parties call FMPC-CRT.Open((cid:74)𝑥,ℓJac(cid:75)), S simulates
the opening and sends Consistency Check to FRSAGen on
𝑗𝛾𝑡 ( 𝑗)
behalf of the corrupt parties.
(6) To reply to FRSAGen about the abort, S checks whether
Int =𝑦𝑥 usingthevaluesthatwerebroadcast.Iftheequal-
ity fails, S sends Abort to A on behalf of the honest parties.
The values used by S in Step 2 are identically distributed to those
in the protocol, so the distribution of the modified share 𝛾𝑡 (𝑖)
Int in Step
4 is statistically close, as measured by Lemma A.1. As 𝑥 is sampled at
random identically, and the influence of A in the integer conversion
of 𝑡 is preserved, then the distribution of the broadcast of Step 4 is
statistically close to the distribution of a real transcript.
Finally,theprobabilityofabortwhenA behaveshonestlyremains
the same, since Step 4 modifies the honest shares to be consistent
with the 𝑦 output. When A acts maliciously in the broadcast of 𝛾𝑡 ( 𝑗)
Int ,
we claim that it has a negligible chance of making the equality hold,
if it had already cheated in the Jacobi test. If it successfully makes the
for each party 𝑃 𝑗 such that 𝑡 =𝑛
multiplication.
samples 𝑡 ( 𝑗)
Int
sends them.
Int for 𝑃𝑖 ∈ H such that 𝛾𝑡 (𝑖)
Int on behalf of the honest parties.
𝑗=1 𝑡 ( 𝑗)
Int
Session 2D: Secure Multiparty Computation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea607equality hold, this creates a difference between real and ideal world
as FRSAGen would abort, since it received a modified 𝑦′ fromS butS
would not abort. As we assume that A successfully cheated in the Ja-