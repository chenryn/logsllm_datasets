replication factors, we focus on a stream of queries all with a partic-
ular replication factor and study how our results vary as we change
the replication factor.
num nbrs
We begin our simulations with a randomly connected topology.8
The GIA simulations use topology adaptation to reconﬁgure this ini-
tial topology. The algorithms use two pre-conﬁgured parameters:
min nbrs and max nbrs. For all of our experiments, we use min -
nbrs = 3. We set max nbrs to 128. However, there is an additional
constraint on max nbrs. To avoid mid- or low-capacity nodes from
gathering so many neighbors that their capacity is too ﬁnely divided,
≥ some min alloc, where min alloc
we require that
represents the ﬁnest level of granularity into which we are willing to
split a node’s capacity. With this additional constraint, we note that
for each node, max nbrs = min(max nbrs,(cid:10)
(cid:11)). After
some preliminary simulations that tested the performance of the GIA
topology adaptation for different values of min alloc, we settled on
min alloc = 4. All control trafﬁc generated by the topology adap-
tation and other components is modeled as consuming resources:
one unit of capacity per message. Thus, the simulator indirectly
captures the impact of control trafﬁc on the overall performance of
the system.
min alloc
C
C
For RWRT and FLOOD, there is no topology adaptation; we use
a random graph. We know that Gnutella networks, in fact, exhibit
properties similar to power-law graphs [20]. However, there is no
assurance that high-degree nodes in the skewed Gnutella distribu-
tion are also high-capacity nodes. In fact, in the absence of an ex-
plicit congruence of high capacity with high degree, a random walk
will cause the high-degree nodes to get overloaded. Comparing a
random walk on such a topology to GIA would unfairly bias the re-
sults against the random walk. Hence, for RWRT, we choose to use
a purely random topology with uniform degree distributions, which
mitigates this problem. The RWRT performance on such a uniformly
random graph is independent of the degree of the individual nodes;
all nodes will be visited with the same probability. On the other
hand, the performance of FLOOD does depend on degree and in fact
worsens with higher degree. For our experiments, we thus chose
uniformly random graphs with an average degree of eight. This
choice is ad hoc, but reﬂects a decision to avoid unnecessarily bi-
asing against RWRT and FLOOD.
On average, the diameter of our random graphs is 7. Thus, for
FLOOD and SUPER, we set the TTL for queries to 10 to ensure that
queries do not get artiﬁcially limited. For RWRT and GIA, the TTL
is set to a larger value (1024), but in this case setting the right TTL
value is not as crucial because the random walks terminate when
they ﬁnd the required number of responses.
Although the simulator models the behavior of the various pro-
tocols discussed in Section 3, it does not capture individual packet-
level behavior nor does it account for any of the vagaries in network
behavior caused by background trafﬁc. We do this because our point
is not to quantify the absolute performance of the algorithm in real-
world terms, but to evaluate the relative performance of the various
design choices. In Section 5.4, we present some preliminary results
that report on our experiences with implementing and deploying Gia
in the wide-area Internet.
4.2 Performance Metrics
To measure the effect of load on the system, we looked at three as-
pects of the system’s performance as a function of the offered load:
the success rate measured as the fraction of queries issued that suc-
cessfully locate the desired ﬁles9, the hop-count measured as the
number of hops required to locate the requested ﬁles, and the delay
measured as the time taken by a query from start to ﬁnish. Fig-
ure 2 shows the success rate, hop-count and delay under increasing
query load for a 10,000 node network running the Gia system. For
these graphs, as in the remainder of our simulations, when we men-
tion a query load of say 0.1, we mean that every node in the system
issues 0.1 queries per unit time (bounded by the node’s capacity,
of course). As each of the graphs in the ﬁgure shows, when the
query load increases, we notice a sharp “knee” in the curves beyond
which the success rate drops sharply and delays increase rapidly.
The hop-count holds steady until the knee-point and then decreases.
The reason for this decrease is that hop-count is measured only for
successful queries; under increasing load, successful queries tend to
be those where the requested ﬁle is located within a few hops from
the originator of the query. These graphs depict the existence of a
knee in the GIA model; our simulations with RWRT, FLOOD, and
SUPER over a range of replication factors revealed the same kind of
behavior, although at different query loads.
8For the SUPER experiments, we use a topology where supernodes
set up random connections among themselves. In addition, all non-
supernodes connect to one supernode at random.
9A query is deemed unsuccessful if at the end of the simulation it
has generated no responses and is stuck in queues within overloaded
nodes.
GIA; N=10,000
RWRT; N=10,000
FLOOD; N=10,000
SUPER; N=10,000
GIA; N=5,000
RWRT; N=5,000
FLOOD; N=5,000
SUPER; N=5,000
i
)
s
p
q
(
t
n
o
P
e
s
p
a
l
l
o
C
1000
100
10
1
0.1
0.01
0.001
0.0001
0.00001
GIA; N=10,000
RWRT; N=10,000
FLOOD; N=10,000
SUPER; N=10,000
GIA; N=5,000
RWRT; N=5,000
FLOOD; N=5,000
SUPER; N=5,000
10000
1000
100
10
e
s
p
a
l
l
o
C
e
r
o
f
e
B
t
n
u
o
C
p
o
H
0.01
0.05
0.1
0.5
1
Replication Rate (percentage)
Figure 3: Comparison of collapse point for the different algo-
rithms at varying replication rates and different system sizes.
Ideally, we want a system that achieves a high success rate while
maintaining a low hop-count and delay. To do so, the system must
operate before the knee shown in the graphs above. Consequently,
we deﬁne the following metrics for use in our evaluation:
Collapse Point (CP): the per node query rate at the knee, which we
deﬁne as the point beyond which the success rate drops below
90%. This metric reﬂects total system capacity.
Hop-count before collapse (CP-HC): the average hop-count prior
to collapse.
We do not retain delay as a metric since the effect of increasing
delay is effectively captured by the collapse point.
4.3 Performance Comparison
We compare the behavior of GIA, RWRT, SUPER and FLOOD
under varying replication factors and different system sizes up to
10,000 nodes. We measured the CP and CP-HC under increasing
replication factors. In Figures 3 and 4, we plot the results for systems
with 5,000 and 10,000 nodes. Experiments with additional system
sizes yielded results consistent with those presented here; we omit
them from the graphs for clarity. For a 10,000 node system we sim-
ulate down to 0.01% replication since that corresponds to a single
matching answer in the entire system for any query. Likewise, for
5,000 nodes we simulate down to 0.05% replication. We believe that
a replication factor of 0.01% where only one in 10,000 nodes holds
the answer to a query represents a fairly pessimistic test scenario.
Each query in these experiments runs until it ﬁnds one matching an-
swer. This represents the case where the query originator sets the
MAX RESPONSES parameter (see Section 3.2.4) in the query to 1.
In reality, most users expect a query to return multiple answers; we
will look at that scenario later. For GIA and RWRT, we measure
the average hop-count of all of the queries. Since for SUPER and
FLOOD a query gets replicated at each hop, it is hard to deﬁne a
consistent hop-count for the entire query; hence, we measure the
hop-count as the number of hops taken to ﬁnd the ﬁrst answer.
Recall that our ﬁrst goal in designing Gia was to enable it to han-
dle a much higher aggregate query rate than Gnutella. The most
obvious, and important, observation from Figures 3 and 4 is that the
aggregate system capacity (as deﬁned by the collapse point) is 3 to 5
orders of magnitude higher than either FLOOD or RWRT. Even when
compared to the supernode approach, Gia does better especially at
higher replication rates. This is not surprising since the ﬂooding
techniques used within supernodes limit their scalability. Thus, our
goal of improving system capacity with Gia is clearly achieved. Our
second goal was that Gia retain this ability to handle high aggre-
gate query rates for systems of arbitrary sizes. As can be observed
in the graphs, this goal is also satisﬁed. GIA’s (and RWRT’s) scal-
ing behavior is determined by the replication factor. That is, at a
1
0.01
0.05
0.1
0.5
1
Replication Rate (percentage)
Figure 4: Hop-count before collapse.
ﬁxed replication factor, the CP and CP-HC are largely unaffected
by system size. This is to be expected since the replication factor
is the percentage of nodes at which answers are located. Thus, the
performance ﬁgures we show here apply to arbitrarily large system
sizes.
There are several other performance results of note.
• At higher replication factors, RWRT performs better than FLOOD
by approximately two orders of magnitude but is comparable
to FLOOD at lower replication rates. This follows from the
fact that at low replication rates, to ﬁnd a matching answer
RWRT may have to visit all of the nodes in the system just
like FLOOD.
• GIA achieves extremely low hop-counts at higher replication
because, in such cases, high capacity nodes are quite likely
to hold answers and these are quickly discovered by biased
walks. However, at low replication some queries may have to
travel far beyond the high capacity nodes resulting in higher
hop-counts. FLOOD and SUPER achieve consistently low
hop-counts (the number of hops to ﬁnd the ﬁrst matching an-
swer), while the hop-count for RWRT is inversely propor-
tional to the replication factor, since RWRT essentially amounts
to random probing.
• The performance of FLOOD degrades with increasing system
size. This is because, in FLOOD, each query is propagated to
every other node in the system. With increasing number of
nodes, there are more total number of queries in the system,
and hence a greater query load arriving at each node. This
causes the collapse point to fall as the system size increases.
We observed similar effects with SUPER as seen from Fig-
ure 3.
These experiments clearly demonstrate GIA’s scalability relative
to RWRT, SUPER and FLOOD. However, these experiments are lim-
ited to queries where the search terminates after ﬁnding a single
matching answer.
In reality, most users expect a query to return
multiple answers. We now look at (a) how our results generalize be-
yond this single case, and (b) how the different design components
contribute to this enormous performance boost for GIA.
4.4 Multiple Search Responses
In this section we look at how the collapse points (and the as-
sociated hop-counts) change for our different system models based
upon the desired number of responses for a query. Recall from Sec-
tion 3.2.4 that a query includes a MAX RESPONSES parameter that
indicates how many responses should be sent back to the originator
of the query before ending the query. The MAX RESPONSES pa-
rameter is useful only in the context of GIA and RWRT. For FLOOD
and SUPER, queries get ﬂooded through the network, and so MAX -
RESPONSES has no effect on their behavior.
Algorithm
Collapse Point Hop-count
Algorithm
Collapse Point Hop-count
GIA
GIA – OHR
GIA – BIAS
GIA – TADAPT
GIA – FLWCTL
7
0.004
6
0.2
2
15.0
8570
24.0
133.7
15.1
RWRT
RWRT + OHR
RWRT + BIAS
RWRT + TADAPT
RWRT + FLWCTL
0.0005
0.005
0.0015
0.001
0.0006
978
134
997
1129
957
Table 4: Factor analysis for GIA and RWRT with 10,000 modes and 0.1% replication. We measure GIA with each of the following
components removed, and RWRT with each of those components added: one-hop replication (OHR), biased random walks (BIAS),
topology adaptation (TADAPT), and ﬂow-control (FLWCTL)
Repl. MAX
factor RESP.
1%
1
1%
1%
10
20
GIA
RWRT
FLOOD SUPER
CP (CP-HC)
CP (CP-HC)
CP
CP
350
(1.4)
8
(12.5)
2.5
(28)
0.005
(98.7)
0.0004
(1020)
0.00015
(2157)
0.00025
0.015
0.00025
0.015
0.00025
0.015
Table 2: CP decreases with increasing numbers of requested
answers (MAX RESPONSES). The corresponding hop-counts be-
fore collapse for each case are shown in parentheses. Since hop-
counts are ambiguous for FLOOD and SUPER when there are
multiple responses, we ignore CP-HC for those cases.
Repl.
factor
1%
0.1%
1%
0.05%
MAX
RESPONSES
10
1
20
1
GIA
CP
8
7
2.5
2.5
RWRT
FLOOD
SUPER
CP
0.0004