Protocols/rfc2616/rfc2616-sec5.html. The request line is defined as follows:
Request-Line = Method SP Request-URI SP HTTP-Version CRLF
The value of Method can be OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT, 
or any extension method. SP stands for space—to be technically accurate, it’s ASCII code 
32. Request-URI identifies the representation of the resource where the request is sent. 
According to the HTTp specification, there are four ways to construct a Request-URI:
AppEndIx G  OAuTH 2.0 MAC TOkEn pROFILE 
434
Request-URI = "∗" | absoluteURI | abs_path | authority
The asterisk (*) means the request targets not a specific resource but the server itself, for 
example, OpTIOnS * HTTp/1.1.
The absoluteURI must be used when the request is made through a proxy, for example, GET 
https://resource-server/myresource HTTP/1.1.
abs_path is the most common form of a Request-URI. In this case, the absolute path with 
respect to the host server is used. The uRI or the network location of the server is transmitted 
in the HTTp Host header. For example:
GET /myresource HTTP/1.1
Host: resource-server
The authority form of the Request-URI is only used with HTTp CONNECT method. This 
method is used to make a connection through a proxy with tunneling, as in the case of TLS 
tunneling.
After the Request-URI must be a space and then the HTTp version, followed by a carriage 
return and a line feed.
Let’s take the following example:
POST /patient?name=peter&id=10909&blodgroup=bpositive HTTP/1.1
Host: medicare.com
The value of the input-string is
POST /patient?name=peter&id=10909&blodgroup=bpositive HTTP/1.1 \n
1336363200 \n
12323 \n
medicare.com \n
1336363200 is the timestamp, 12323 is the sequence number, and medicare.com is 
the value of the Host header. The value of the Host header is included here because it is 
set in the h parameter of the API request under the HTTP Authorization header. All of 
these entries should be separated by a newline separator character, denoted by \n in the 
example. Once the input string is derived, the MAC is calculated on it using the mac_key 
and the MAC algorithm specified under mac_algorithm.
AppEndIx G  OAuTH 2.0 MAC TOkEn pROFILE 
435
 MAC Validation by the Resource Server
To access any API secured with the OAuth 2.0 MAC Token Profile, the client should send 
the relevant parameters with the API invocation request. If any of the parameters are 
lacking in the request or the provided values are invalid, the resource server will respond 
with an HTTP 401 status code. The value of the WWW-Authenticate header should be set 
to MAC, and the value of the error parameter should explain the nature of the error:
HTTP/1.1 401 Unauthorized
WWW-Authenticate: MAC error="Invalid credentials"
Let’s consider the following valid API request, which comes with a 
MAC header:
GET /patient?name=peter&id=10909HTTP/1.1
Host: medicare.com
Authorization: MAC  kid="22BIjxU93h/IgwEb4zCRu5WF37s=",
                    ts="1336363200",
                    seq-nr="12323",
                    access_token="eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBM",
                    mac="bhCQXTVyfj5cmA9uKkPFx1zeOXM=",
                    h="host",
                    cb="tls-unique:9382c93673d814579ed1610d3"
To validate the MAC of the request, the resource server has to know the mac_key. 
The client must pass the mac_key to the resource server, encoded in the access_token. 
The first step in validation is to extract the mac_key from the access_token in the request. 
Once the access_token is decoded, the resource server has to verify its audience. The 
authorization server encodes the audience of the access_token into the access_token.
Once the access_token is verified and the scopes associated with it are validated, the 
resource server can cache the mac_key by the kid. The cached mac_key can be used in 
future message exchanges.
According to the MAC Token Profile, the access_token needs to be included only 
in the first request from the client to the resource server. The resource server must use 
the cached mac_key (against the kid) to validate subsequent messages in the message 
exchange. If the initial access_token doesn’t have enough privileges to invoke a later 
AppEndIx G  OAuTH 2.0 MAC TOkEn pROFILE 
436
API, the resource server can request a new access_token or a complete authenticator by 
responding with an HTTP WWW-Authenticate header.
The resource server must calculate the MAC of the message the same way the client 
did before and compare the calculated MAC with the value included in the request. If 
the two match, the request can be considered a valid, legitimate one. But you still need 
to make sure there are no replay attacks. To do that, the resource server must verify the 
timestamp in the message by comparing it with its local timestamp.
An attacker that can eavesdrop on the communication channel between the client 
and the resource server can record messages and replay them at a different time to gain 
access to the protected resource. The OAuth 2.0 MAC Token Profile uses timestamps as a 
way of detecting and mitigating replay attacks.
 OAuth Grant Types and the MAC Token Profile
OAuth grant types and token types are two independent extension points introduced in 
the OAuth 2.0 core specification. They don’t have any direct dependency between each 
other. This chapter only talks about the authorization code grant type, but all the other 
grant types work in the same manner: the structure of the access token returning from 
the implicit grant type, the resource owner password credentials grant type, and the 
client credentials grant type is the same.
 OAuth 1.0 vs. OAuth 2.0 MAC Token Profile
Eran Hammer (who was initially the lead editor of the OAuth 2.0 specification) 
submitted the initial OAuth 2.0 MAC Token Profile draft to the OAuth working group 
in May 2011, and the first draft (also submitted by Hammer) followed with some 
improvements in February 2012. Both drafts were mostly influenced by the OAuth 1.0 
architecture. After a long break, and after Hammer’s resignation from the OAuth working 
group, the Internet draft 4 of the MAC Token Profile introduced a revamped architecture. 
This architecture, which was discussed in this chapter, has many architectural 
differences from OAuth 1.0 (see Table G-1).
AppEndIx G  OAuTH 2.0 MAC TOkEn pROFILE 
437
Table G-1. OAuth 1.0 vs. OAuth 2.0 MAC Token Profile
OAuth 1.0
OAuth 2.0 MAC Token Profile
Requires a signature both during the initial 
handshake and during the business ApI 
invocation.
Requires a signature only for the business ApI 
invocation.
The resource server must know the secret 
key used to sign the message beforehand.
The shared secret doesn’t have an 
associated lifetime.
doesn’t have any audience restrictions. 
Tokens can be used against any resource 
server.
The encrypted shared secret used to sign the message 
is passed to the resource server, embedded in the 
access_token.
A lifetime is associated with the mac_key, which is 
used as the key to sign.
The authorization server enforces an audience 
restriction on the issued access_tokens, so that 
those access tokens can’t be used against any 
resource server.
AppEndIx G  OAuTH 2.0 MAC TOkEn pROFILE 
439
© Prabath Siriwardena 2020 
P. Siriwardena, Advanced API Security, https://doi.org/10.1007/978-1-4842-2050-4
Index
A
Access delegation problem, 81
Access token, 86, 93, 251
access_token parameter, 220
Additional authentication data (AAD), 
185, 192, 194, 200
Advanced encryption standard  
(AES), 49, 192
Alert protocol, 365
alias argument, 74
Amazon Web Services (AWS), 3, 51, 52, 103
Apache Directory Server (LDAP)
connections, 415
connecting Apache Tomcat, 417
organizational unit structure,  
creation, 416
test connection, 416
Application programming interface (API)
Amazon, 3, 4
Big Data, 2
Business models, 12
database implementations, 15
definition, 13
Facebook, 6, 7
governments, 9
healthcare industry, 10
IBM Watson technology, 9
IoT, 2
Java RMI, 16
JDBC, 14
kernel, 13, 14
lifecycle, 22
management platform, 23
marshalling/unmarshalling  
technique, 16
Netflix, 7
Open Bank, 10
ProgrammableWeb, 19
reasons, 3
Salesforce, 5
SOAP, 17
swagger, 24
Uber, 5, 6
UDDI, 23
Walgreens, 8
wearable industry, 11
Auditing, 65, 89
Authenticated Encryption with Associated 
Data (AEAD), 191, 192, 194
Authentication, 59
biometric-based, 62
brute-force attack, 60
certificates and smart card–based, 61
identity provider, 59
Authorization, 62
access control list, 63
DAC, 62
MAC, 63
Authorization API, 389, 394, 396
Authorization API token (AAT), 389–391
440
Authorization code grant type
authorize endpoint, 85
callback URL, 85
lifetime, 86
token endpoint, 87
Availability, security triad, 57–58
B
Base64 encoding, 397, 398
Bearer tokens, 427
Brokered authentication
client applications, 258–260
OAuth authorization server, 258
OAuth principles, 259
Brokered delegation, 322–323
Browser-less apps, 237–240
C
Certificate authority (CA), 65, 74
Chained access delegation
API, 313
end user, 314
JWT access token, 314
OAuth 2.0 Token Delegation profile, 314
OpenID Connect, 314
Chain grant type profile, 216, 226
authorization server, 216, 226
resource server, 216
scope parameter, 216
Change Cipher Spec protocol, 365
Claim gathering
authorization policies, 286
claim_redirect_uri, 285
claim_token parameter, 284
HTTP redirect, 285
RPT, 285
client_assertion_type, 271
Client credentials grant type, 91, 92
client_id, 271
Code interception attack, 300, 301
Complete mediation principle, 49, 66
Computer Security Institute (CSI), 42
Content Encryption Key  
(CEK), 189–191
Cross-Site Request Forgery (CSRF)
OAuth 2.0
attacker, 291
authorization code, 291, 293
callback URL, 292
PKCE, 293
state parameter, 293
target web site, 293
victim, 292
victim’s browser, 291
cURL command, 429
D
Database management systems  
(DBMSs), 14
Data breaches, 34, 48, 66
Data Encryption Standard (DES), 49
Delegated access control
identity provider, 309, 310
JWT, 310, 311
no credentials, 318
OAuth 2.0 MAC tokens, 318
resource STS, 316–318
Denial of service (DoS), 21
Design challenges, 37
defense in depth, 41, 42
insider attacks, 42, 43
performance, 39, 40
security by obscurity, 44, 45
Index
441
user experience, 38
weakest links, 40, 41
Design principles, 45
Direct authentication, trusted  
subsystem, 305, 306
Direct vs. brokered delegation, 322, 323
Direct encryption, 194, 203
Direct key agreement, 193, 203
Discretionary Access Control (DAC), 62, 63
Distributed denial of service  
(DDoS), 33, 57, 125
Docker in Action, 78
docker run command, 78
Document type definition (DTD), 58
Domain Name Service (DNS), 76, 109
Dynamic client registration,  
220–224, 226, 227
E
Economy of mechanism  
principle, 48, 66
encryptedkey parameter, 198
Export ciphers, 47, 48
Exported keying material (EKM),  
248, 250, 253
eXtensible Access Control Markup 
Language (XACML), 63, 316
F
Facebook, 6–7, 35
Fail-safe defaults principle, 46–48
Federation
access token, 257
authorization code, 257
identity management systems, 257
Financial-grade API (FAPI), 287
Flickr, 8, 322, 327
Fraud-detection patterns, 65
G
Galois/Counter Mode (GCM), 192
GitHub, 402