crash-resistant code paths become controllable by an attacker
without control-ﬂow hijacking [54].
B. Design Choices, Countermeasures, and Defenses
Several choices can be made to prevent crash-resistance.
Single instances of crash-resistance are ﬁxable. For example,
we do not see any legitimate uses in the crash-resistance of
Internet Explorer. Actually, after cooperation with Microsoft it
was determined that this issue is security relevant and affects
Internet Explorer 7 to 11 and the Microsoft Edge Browser
(see CVE-2015-6161). It was ﬁxed for Microsoft Edge during
the Patch Tuesday cycle in December 2015 and hardening
settings for Internet Explorer were made available [32]. In the
past, a few vulnerabilities had the ability to survive crashes,
and thus, adversaries were able to trigger them several times
in order to bypass ASLR or to increase successful exploit
chances [25, 52]. Hence, Microsoft’s Security Development
Lifecycle (SDL) suggests avoiding global exception handlers
which can catch all violations [29]. Note that single instances
of buffer overﬂow vulnerabilities can be ﬁxed as well, while
the class of buffer overﬂows cannot be easily completely
eliminated. Crash-resistance is similar and we argue that
constructing a memory oracle is possible on every modern
system which has a way for applications to handle faults.
1) Crash Policies: A general countermeasure is to limit the
number of faults that can be caused. This means an attacker
must ﬁnd ways to reduce probing attempts and hit the right
location in one of her ﬁrst scans. However, this only provides
a probabilistic solution as there is a small chance for the ﬁrst
13
probe to succeed. In addition, a hard crash policy can interfere
with use cases where legitimate exceptions can occur and are
expected. As described in Section III-B2, Firefox leverages
exceptions for fast array accesses to avoid bounds checking.
An attempted out of bound read is caught with the help of the
exception handler and returns a default value (undefined).
Removing exception support would decrease the performance,
because additional bound checks for every array access would
have to be performed.
2) Accurately Checking the Exception Information: The
most effective countermeasure against crash-resistance is to
accurately check the exception information of a triggered fault.
The triggered exceptions we used in Internet Explorer for
crash-resistance allow any fault to be used as a side-channel.
Exception handlers should catch only faults which are expected
in guarded code. Therefore,
the exception type should be
inspected carefully as well as the address of the instruction
which caused the fault. This information is necessary to verify
that only the intended faults are caught. Additionally, it is
necessary to make sure that guarded code cannot throw other
exceptions. While it might be difﬁcult to always handle all
faults accurately, unintended faults should always be forwarded
unhandled. This way the operating system can safely terminate
the program and prevent crash-resistance. Note that the fault
handler of Firefox performs rigorous checks on the data pro-
vided by the OS. This includes information about the address
of the instruction causing the fault, the error code, and the
exception type. Thus, we needed to modify metadata in the
process in order trick the checks before triggering a fault.
Exception information is processed differently in Windows
and Linux. Linux can differentiate if a fault occurred due to
unmapped memory or due to an access with wrong permis-
sions. As such, exception handling in the asm.js functionality
of Firefox can utilize this subtlety to prevent crash-resistance.
Actually, this is a good example for ﬁxing a single instance of
crash-resistance. Surprisingly, the Firefox developers added a
check to the asm.js exception handling in Firefox 39. Accesses
to unmapped memory are not handled anymore, but only
accesses with wrong permissions. As a guard region follows
the asm.js heap, bound checks can still be performed with
exceptions. As the ﬁx was not ﬂagged as a security issue, the
developers unintentionally eliminated a security issue. How-
ever, crash-resistance within asm.js remains in the Windows
version of Firefox.
3) Using Guard Pages to Prevent Probing: We realized in
our tests with Firefox in Windows that accesses to guard pages
around the stacks were not crash-resistant. Guard pages around
the stack normally prevent stack overﬂows. An access to a
guard page delivered an error code different to the error code of
a heap guard region access. This was not handled by the asm.js
handler. By placing guard pages around critical structures,
scanning attempts performed by an attacker can be detected.
The program can then be terminated immediately whenever
an illegal access is detected. The difference in the exception
code allows distinguishing potentially intended faults from
exceptions caused by an attacker. However, the same fault in
Internet Explorer still allows complete crash-resistant memory
scanning as any fault is handled. Thus, probing an unmapped
page yields the same result as touching a guard page.
4) Defenses against Crash-Resistance: Softbound [34] and
CETS [35] are memory corruption defenses and memory
safety solutions for C programs. The former provides spatial
safety, while the latter prevents temporal bugs. As memory
corruptions are eliminated, our current approach of crash-
resistance is not possible in C programs. However, most parts
of Firefox and Internet Explorer are written in C++, which
Softbound and CETS do not support.
VIII. CONCLUSION
In this paper, we demonstrated that even client applications
such as web browsers can be resistant to crashes. We showed
that an adversary can safely query the address space, which is
normally not legitimate and should lead to program termina-
tion. We thereby do not rely on control-ﬂow hijacking, code-
injection or code-reuse attacks. To this end, we introduced the
concept of crash-resistance and developed memory oracles.
This enables an adversary to use fault-tolerant functionality as
a side channel to obtain information about the memory layout.
Furthermore, we introduced the concept of Crash-Resistant
Oriented Programming (CROP) that leverages crash-resistance
to execute function chains in a fault-tolerant manner. As a
result, recently proposed information hiding and randomization
defenses are weakened, and control-ﬂow hijacking and code-
reuse attacks can be enabled again.
ACKNOWLEDGMENT
This material is based upon work partially supported by
ERC Starting Grant No. 640110 (BASTION).
REFERENCES
[1] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti. Control-Flow
In ACM Conference on Computer and Communications
Integrity.
Security (CCS), 2005.
[2] M. Backes, T. Holz, B. Kollenda, P. Koppe, S. N¨urnberger, and
J. Pewny. You can run but you can’t read: Preventing disclosure
In ACM Conference on Computer and
exploits in executable code.
Communications Security (CCS), 2014.
[3] M. Backes and S. N¨urnberger. Oxymoron: Making ﬁne-grained memory
randomization practical by allowing code sharing. In USENIX Security
Symposium, 2014.
[4] S. Bhatkar, D. C. DuVarney, and R. Sekar. Address Obfuscation:
An Efﬁcient Approach to Combat a Broad Range of Memory Error
Exploits. In USENIX Security Symposium, 2003.
[5] S. Bhatkar, D. C. DuVarney, and R. Sekar. Efﬁcient techniques for
In USENIX
comprehensive protection from memory error exploits.
Security Symposium, 2005.
[6] A. Bittau, A. Belay, A. Mashtizadeh, D. Mazieres, and D. Boneh.
Hacking blind. In IEEE Symposium on Security and Privacy, 2014.
[7] T. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang.
Jump-oriented
Programming: A New Class of Code-reuse Attack. In ASIACCS, 2011.
[8] E. Bosman and H. Bos. Framing signals-a return to portable shellcode.
In IEEE Symposium on Security and Privacy, 2014.
[9] N. Carlini, A. Barresi, M. Payer, D. Wagner, and T. R. Gross. Control-
ﬂow bending: On the effectiveness of control-ﬂow integrity. In USENIX
Security Symposium, 2015.
[10] N. Carlini and D. Wagner. Rop is still dangerous: Breaking modern
defenses. In USENIX Security Symposium, 2014.
[11] D. Chappell. Understanding ActiveX and OLE: a guide for developers
and managers. Microsoft Press, 1996.
[12] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H. Shacham,
and M. Winandy. Return-oriented programming without returns.
In
ACM Conference on Computer and Communications Security (CCS),
2010.
14
[13] S. Crane, C. Liebchen, A. Homescu, L. Davi, P. Larsen, A.-R. Sadeghi,
S. Brunthaler, and M. Franz. Readactor: Practical code randomization
In IEEE Symposium on Security and
resilient to memory disclosure.
Privacy, 2015.
[14] S. Crane, S. Volckaert, F. Schuster, C. Liebchen, P. Larsen, L. Davi,
A.-R. Sadeghi, T. Holz, B. D. Sutter, and M. Franz. It’s a TRAP: Table
Randomization and Protection against Function Reuse Attacks. In ACM
Conference on Computer and Communications Security (CCS), 2015.
[15] T. H. Dang, P. Maniatis, and D. Wagner. The performance cost of
shadow stacks and stack canaries. In ACM Symposium on Information,
Computer and Communications Security (ASIACCS), 2015.
[16] L. Davi, D. Lehmann, A.-R. Sadeghi, and F. Monrose. Stitching the
gadgets: On the ineffectiveness of coarse-grained control-ﬂow integrity
protection. In USENIX Security Symposium, 2014.
[17] L. Davi, C. Liebchen, A.-R. Sadeghi, K. Z. Snow, and F. Monrose.
Isomeron: Code randomization resilient to (just-in-time) return-oriented
In Symposium on Network and Distributed System
programming.
Security (NDSS), 2015.
[19]
[18] U. Erlingsson, M. Abadi, M. Vrable, M. Budiu, and G. C. Necula.
XFI: Software Guards for System Address Spaces. In Symposium on
Operating Systems Design and Implementation (OSDI), 2006.
I. Evans, S. Fingeret, J. Gonz´alez, U. Otgonbaatar, T. Tang, H. Shrobe,
S. Sidiroglou-Douskos, M. Rinard, and H. Okhravi. Missing the point
(er): On the effectiveness of code pointer integrity. In IEEE Symposium
on Security and Privacy, 2015.
I. Fratric.
ming Attacks.
doc/ropguard.pdf.
Runtime Prevention of Return-Oriented Program-
http://ropguard.googlecode.com/svn-history/r2/trunk/
[20]
[21] E. G¨oktas¸, E. Athanasopoulos, H. Bos, and G. Portokalidis. Out of
In IEEE Symposium on
control: Overcoming control-ﬂow integrity.
Security and Privacy, 2014.
[22] E. G¨oktas¸, E. Athanasopoulos, M. Polychronakis, H. Bos, and G. Por-
tokalidis. Size does matter: Why using gadget-chain length to prevent
code-reuse attacks is hard. In USENIX Security Symposium, 2014.
J. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, and J. W. Davidson. ILR:
Where’d My Gadgets Go? In IEEE Symposium on Security and Privacy,
2012.
[23]
[24] C. Kil, J. Jim, C. Bookholt, J. Xu, and P. Ning. Address space layout
permutation (ASLP): Towards ﬁne-grained randomization of commod-
In Annual Computer Security Applications Conference
ity software.
(ACSAC), 2006.
[25] K. Kortchinsky. Escaping VMware Workstation through COM1. https:
//www.exploit-db.com/docs/37276.pdf, 2015.
[26] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, R. Sekar, and D. Song.
Code-pointer integrity. In Symposium on Operating Systems Design and
Implementation (OSDI), 2014.
[27] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, and D. Song. Poster:
Getting the point(er): On the feasibility of attacks on code-pointer
integrity. In IEEE Symposium on Security and Privacy, 2015.
[28] miasm2 Authors. Miasm2: Reverse Engineering Framework in Python.
https://github.com/cea-sec/miasm, 2015.
[29] Microsoft.
25.
The Microsoft
the CWE/SANS
http://download.microsoft.com/download/C/A/9/
Top
CA988ED6-C490-44E9-A8C2-DE098A22080F/Microsoft%20SDL%
20and%20the%20CWE-SANS%20Top%2025.doc, 2009.
SDL
and
[30] Microsoft.
Bringing asm.js
to the Chakra JavaScript engine
in Windows 10.
http://blogs.msdn.com/b/ie/archive/2015/02/18/
bringing-asm-js-to-the-chakra-javascript-engine-in-windows-10.aspx,
2014.
[31] Microsoft. EMET 5.2 is available.
http://blogs.technet.com/b/srd/
archive/2015/03/16/emet-5-2-is-available.aspx, 2014.
[32] Microsoft. Microsoft Security Bulletin Summary for December
https://technet.microsoft.com/en-us/library/security/ms15-dec.
2015.
aspx, 2015.
[33] Mozilla. asm.js working draft. http://asmjs.org/spec/latest/.
[34] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic. SoftBound:
Highly compatible and complete spatial memory safety for C. In ACM
Sigplan Notices, 2009.
[35] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic. CETS:
In ACM Sigplan Notices,
compiler enforced temporal safety for C.
2010.
[36] V. Pappas. kBouncer: Efﬁcient and Transparent ROP Mitigation. http:
//www.cs.columbia.edu/∼vpappas/papers/kbouncer.pdf.
[37] V. Pappas, M. Polychronakis, and A. D. Keromytis. Smashing the
gadgets: Hindering return-oriented programming using in-place code
randomization. In IEEE Symposium on Security and Privacy, 2012.
[38] PaX Team. Address Space Layout Randomization.
grsecurity.net/docs/aslr.txt, 2001.
https://pax.
[39] PaX Team. Pageexec. https://pax.grsecurity.net/docs/pageexec.txt, 2001.
[40] A. Permamedov. Why it’s not crashing? The Code Project, 2010.
[41] M. Pietrek. A crash course on the depths of Win32 structured exception
handling. Microsoft Systems Journal-US Edition, 12(1):41–66, 1997.
[42] M. Pietrek. New vectored exception handling in Windows XP. MSDN
Magazine, 16(9):131–142, 2001.
[43] M. Polychronakis, K. G. Anagnostakis, and E. P. Markatos. Comprehen-
sive shellcode detection using runtime heuristics. In Annual Computer
Security Applications Conference (ACSAC), 2010.
[44] M. Prandini and M. Ramilli. Return-Oriented Programming. In IEEE
Symposium on Security and Privacy, 2012.
[45] M. Russinovich, D. A. Solomon, and A. Ionescu. Windows Internals,
Part 1. Microsoft Press, 6th edition, 2012.
[46] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, and
T. Holz. Counterfeit object-oriented programming: On the difﬁculty of
preventing code reuse attacks in c++ applications. In IEEE Symposium
on Security and Privacy, 2015.
[47] F. Schuster, T. Tendyck, J. Pewny, A. Maaß, M. Steegmanns, M. Contag,
and T. Holz. Evaluating the effectiveness of current anti-ROP defenses.
In Symposium on Recent Advances in Intrusion Detection (RAID), 2014.
J. Seibert, H. Okkhravi, and E. S¨oderstr¨om. Information leaks without
memory disclosures: Remote side channel attacks on diversiﬁed code.
In ACM Conference on Computer and Communications Security (CCS),
2014.
[48]
[49] H. Shacham. The Geometry of Innocent Flesh on the Bone: Return-
into-libc Without Function Calls (on the x86). In ACM Conference on
Computer and Communications Security (CCS), 2007.
[50] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu, and D. Boneh.
On the effectiveness of address-space randomization. In ACM Confer-
ence on Computer and Communications Security (CCS), 2004.
[51] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko, C. Liebchen, and
A.-R. Sadeghi. Just-in-time code reuse: On the effectiveness of ﬁne-
In IEEE Symposium on
grained address space layout randomization.
Security and Privacy, 2013.
[52] A. Sotirov.
Reverse Engineering and the ANI Vulnerabil-
http://www.phreedom.org/presentations/reverse-engineering-ani/
ity.
reverse-engineering-ani.pdf, 2007.
[53] R. Strackx, Y. Younan, P. Philippaerts, F. Piessens, S. Lachmund, and
T. Walter. Breaking the memory secrecy assumption. In Proceedings
of the Second European Workshop on System Security, 2009.
[54] S. Vogl, R. Gawlik, B. Garmany, T. Kittel, J. Pfoh, C. Eckert, and
T. Holz. Dynamic hooks: Hiding control ﬂow changes within non-
control data. In USENIX Security Symposium, 2014.
[55] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham. Efﬁcient
In ACM SIGOPS Operating Systems
software-based fault isolation.
Review, 1994.
[56] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin. Binary stirring: Self-
randomizing instruction addresses of legacy x86 binary code. In ACM
Conference on Computer and Communications Security (CCS), 2012.
In
[57] T. Yan. The Art of Leaks: The Return of Heap Feng Shui.
CanSecWest, 2014.
[58] Y. Yu. Write Once, Pwn Anywhere. In Black Hat USA, 2014.
[59] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant,
D. Song, and W. Zou. Practical control ﬂow integrity and randomization
for binary executables. In IEEE Symposium on Security and Privacy,
2013.
[60] M. Zhang and R. Sekar. Control ﬂow integrity for COTS binaries. In
USENIX Security Symposium, 2013.
15