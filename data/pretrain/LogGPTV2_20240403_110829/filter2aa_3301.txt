Android Universal Root
Exploiting xPU Drivers
Xingyu Jin
Richard Neal
Jon Bottarini
#BHUSA  @BlackHatEvents 
#BHUSA   @BlackHatEvents
Who are we?
Jon Bottarini
@jon_bottarini
Xingyu Jin
@1ce0ear
Richard Neal
@ExploitDr0id
#BHUSA   @BlackHatEvents
What are we talking about?
●
Rooting exploits on Android
○
In-the-wild
○
Internal research
●
Android Partner Vulnerability Initiative
#BHUSA   @BlackHatEvents
Some old driver vulns
#BHUSA   @BlackHatEvents
mtk-su Exploit
#BHUSA   @BlackHatEvents
XDA Developers
#BHUSA   @BlackHatEvents
XDA Developers
#BHUSA   @BlackHatEvents
6f35a3ff: /dev/ion
4b4ab49b: /dev/mtk_cmdq
6d7a00fc: /proc/mtk_cmdq
Reverse engineering the exploit
#BHUSA   @BlackHatEvents
●
CMDQ_IOCTL_EXEC_COMMAND
○
Send a buffer of opcodes from user -> kernel
○
Opcodes - CMDQ_CODE_ENUM
CVE-2020-0069
#BHUSA   @BlackHatEvents
●
Restrict access via SELinux policy:
●
Can't open device node:
●
SELinux Fix
#BHUSA   @BlackHatEvents
Lessons Learned
#BHUSA   @BlackHatEvents
GPU Driver: Perfect Local Attack Surface
●
It’s impossible to restrict unprivileged users from accessing GPU driver
●
GPU device driver exports a lot of functionality to userspace
●
Mobile GPU
○
ARM: Mali 
○
Qualcomm: Adreno
○
Imagination Technologies: PowerVR
Google received a lot of security reports
Only 1 in 2019
#BHUSA   @BlackHatEvents
PowerVR GPU is everywhere
●
PowerVR may have the biggest market share in numbers (MediaTek / UniSoc)
Use PowerVR GPU
#BHUSA   @BlackHatEvents
Intro to Bridge APIs
●
No surprise, unprivileged user can talk to PowerVR GPU driver
●
PowerVR GPU driver exports hundreds of kernel functions to userspace
○
Exported functions are called “Bridge functions” by PowerVR developers
●
Three steps
○
Open device
○
Send ioctl code and arguments
○
Get response
#BHUSA   @BlackHatEvents
Intro to Bridge APIs
●
Bridge APIs
#BHUSA   @BlackHatEvents
Intro to Bridge APIs
●
Overview of how Bridge APIs work
●
Every step is buggy
#BHUSA   @BlackHatEvents
Heap overflow in Bridge APIs
●
Call Bridge API 
PVRSRVBridgeSyncPrimOpTake
○
Group ID 2, Function ID 9
●
Input data structure 
PVRSRV_BRIDGE_IN_SYNCPRIMOPTAKE
●
Calculate kernel buffer size based on 
user input
○
Integer overflow
#BHUSA   @BlackHatEvents
Heap overflow in Bridge APIs
●
GPU driver does have a a lot of “sanity checks”
○
Always by checking if an unsigned integer is above 0 :-/
●
Massive trouble: every bridge API is written in this way
○
Several CVEs are assigned for this issue.
○
Good news: sometimes integer overflow cancels itself
#BHUSA   @BlackHatEvents
Race Condition in Bridge APIs
●
Invoke internal kernel functions
○
Create object
○
Use object
○
Release object
#BHUSA   @BlackHatEvents
Race Condition in Bridge APIs
●
Bridge API X
○
Create internal kernel object
○
Use kernel object for computation
○
Return a handle to user
●
Bridge API Y
○
Find kernel object by handle
○
Decrement reference count
#BHUSA   @BlackHatEvents
Race Condition in Bridge APIs
#BHUSA   @BlackHatEvents
Race Condition in Bridge APIs
#BHUSA   @BlackHatEvents
Read Uninitialized Heap Memory in Bridge APIs
●
Copy result back to user
○
Initialize the kernel object
○
Copy kernel object data back to user space
#BHUSA   @BlackHatEvents
Read Uninitialized Heap Memory in Bridge APIs
●
Copy result to user back
○
do_something(A)
○
A->data is copy back to user space
Fail early -> A is not initialized
●
Easy leak kernel heap pointer / KASLR bypass (Arbitrary slab size)
#BHUSA   @BlackHatEvents
Bridge APIs: Summary
●
There are other issues
○
Reference count overflow
○
Arbitrary stack overflow
○
Unlink UAF
○
… Please see also our reference slide later
●
Classic memory corruption / race condition bugs
●
These bugs are exploitable for rooting PowerVR devices
○
No more introduction, we have something … much more powerful
#BHUSA   @BlackHatEvents
PowerVR Memory Management: GPU VA  PA
●
CPU VA  PA
●
GPU VA  PA
●
GPU VA  PA  CPU VA
#BHUSA   @BlackHatEvents
PowerVR Memory Management: GPU VA  PA
●
PMR (Physical Memory Resource)
○
Call Bridge APIs => obtain a PMR handle 
○
Use PMR handle for mapping GPU / CPU virtual memory
Create PMR
How many physical pages?
How many virtual pages?
GPU/CPU memory properties
Sparse memory mapping table
…
 -2 pages
BOOM
#BHUSA   @BlackHatEvents
PowerVR Memory Management: GPU VA  PA
●
Corrupt GPU VA mapping
○
Map to arbitrary physical memory we want
GPU VA mapping
All kinds of object handles
The number of mapped pages
Physical page offset
…
Memory properties
Offset = -2
BOOM
#BHUSA   @BlackHatEvents
PowerVR Memory Management: GPU VA  PA
●
If we want to operate ARM64 IOMMU
○
Then operate the IOMMU in an ARM64 way for sure
●
User space can invoke a typical Bridge API and point out to the driver that 
we want to operate the ARM64 IOMMU in…
○
MIPS way first…
New architecture: 
ARMIPS
#BHUSA   @BlackHatEvents
PowerVR Memory Management: GPU VA  PA
●
Now we can operate the IOMMU in MIPS way on ARM64 architecture
●
Completely corrupt the page tables
○
E.g. viewing weird data from mmap syscall immediately
#BHUSA   @BlackHatEvents
PowerVR Memory Management: CPU VA  PA
●
Now let’s take a look at the CPU side
○
CPU VA  PA
#BHUSA   @BlackHatEvents
PowerVR Memory Management: CPU VA  PA
●
Reserve physical pages, get PMR handle hPMR
●
Get mapped CPU virtual memory by mmap
○
mmap(hDev, ..., hPMR iRefCount = 3 
(1 by default)
●
Tracking the number of memory mappings for security purposes by PMR->iRefCount
#BHUSA   @BlackHatEvents
PowerVR Memory Management: Pinned Mem
●
Pinned Memory (According to Nvidia official web page)
○
Pinned memory is used for data transfers from the device to the host.
○
Allocate physical memory => Avoid cost in data transfer
#BHUSA   @BlackHatEvents
PowerVR Memory Management: Pinned Mem
●
“Pinned” physical pages reserved by PMR
○
PVRSRVBridgeDevmemIntPin
●
“Unpinned” physical pages reserved by PMR
○
PVRSRVBridgeDevmemIntUnpin
#BHUSA   @BlackHatEvents
PowerVR Memory Management: Pinned Mem
●
Allocate page A, B, C
●
Unpin page A, B, C
○
g_sUnpinList: {A, B, C}
#BHUSA   @BlackHatEvents
PowerVR Memory Management: Pinned Mem
●
Register Linux kernel shrinker
●
A shrinker is an internal kernel callback routine
○
When memory is tight => free pages from g_sUnpinList
#BHUSA   @BlackHatEvents
PowerVR Memory Management: Pinned Mem
●
Allocate page A, B, C
●
Unpin page A, B, C => g_sUnpinList: {A, B, C}
●
Unpin page A, B, C => g_sUnpinList: {A, B, C, A, B, C}
#BHUSA   @BlackHatEvents
PowerVR Memory Management: Pinned Mem
●
CVE-2022-20122 Free arbitrary page arbitrary time by Unpin API
○
PVR_ASSERT(psOSPageArrayData->bUnpinned == IMG_FALSE)
●
PVR_ASSERT is enabled for code static analysis checker only
○
#if defined(__KLOCWORK__)
○
In production, it does nothing :-/
○
PVR_ASSERT is not enabled in production :-/
#BHUSA   @BlackHatEvents
PowerVR Memory Management: Pinned Mem
●
Let’s visit the existing security checks
○
If physical pages are mapped to somewhere else (PMR->iRefCount > 1)
○
The physical pages are not allowed to be unpinned 
#BHUSA   @BlackHatEvents
PowerVR Memory Management: Pinned Mem
●
The following request is illegal
○
hPMR = create_pmr() // PMR->iRefCount == 1
○
mmap(..., hPMR) // PMR->iRefCount == 2
○
unpin_mem(hPMR) // Failed because iRefCount > 1
#BHUSA   @BlackHatEvents
PowerVR Memory Management: Pinned Mem
●
The following request is legal
○
hPMR = create_pmr() // PMR->iRefCount == 1
○
unpin_mem(hPMR) // Succeed, move pages from PMR to shrinker
○
mmap(..., hPMR  no mmap
●
Who has the privilege to mmap GPU device?
○
allow hal_graphics_composer_default dri_device (chr_file (ioctl read write 
getattr lock append map open watch watch_reads))
●
Create OpenCL project 
○
void* svm_mem = cl::SVMAlloc(...)
○
SVM (Shared Virtual Memory) still works
#BHUSA   @BlackHatEvents
PowerRoot: Bypass SELinux
●
opencl.so
○
Implemented by several vendor 
specific libraries
■
PVR + MTK libraries
●
Reverse engineering these vendor 
libraries
○
Rigorous security checks on user 
space library
#BHUSA   @BlackHatEvents
PowerVR GPU: Bypass SELinux
#BHUSA   @BlackHatEvents
PowerRoot: Root
●
A lot of methods to root devices by CVE-2021-39815
○
Corrupt page tables
○
Corrupt binaries…
○
Attack kernel in a “memory corruption” way
●
Similar to root devices by dirtypipe vulnerability
○
You may load a kernel module (@iGio90) by dirtypipe vulnerability
○
PowerRoot: more powerful than dirtypipe vulnerability
#BHUSA   @BlackHatEvents
PowerRoot: Root
●
Search task_struct by name
○
Find cred by task_struct->cred
●
Spam files for arb R/W
○
Search file structure by file->f_cred
○
E.g. control ashmem file->private_data
#BHUSA   @BlackHatEvents
PowerRoot: Root
●
Dump kernel image
○
PMR->szAnnotation field (char[]) specified by user space
PMR contains .data, .text, .rodata pointers
●
Dumping enough kernel data => find where is the possible address of 
selinux_enforcing (e.g. possible signs of SELinux avc structures)
●
Overwrite cred
○
Write combined page => snoop CPU
#BHUSA   @BlackHatEvents
Android Partner Vulnerability Initiative (APVI)
●
Launched in late 2020 - Google-discovered security issues outside of AOSP code that 
could potentially affect the security posture of an Android device or its users 
●
52 security issues publicly disclosed - https://bugs.chromium.org/p/apvi
●
Any person or team within Google that discovers a Android partner security issue
Android Partner 
Vulnerability 
Initiative (APVI)
Disclosure to Android OEM Partners
Detection of affected Partner builds
Public Disclosure + Patch Advisory
Other Google 
Employees
Android Security & 
Privacy 
Google Threat 
Analysis Group
#BHUSA   @BlackHatEvents
Vendor Patch + Disclosure Process
“Imagination Technologies supports and is appreciative of initiatives to improve our products. We will 
continue to engage with Google’s APVI program, and others in the security community, to benefit our 
whole industry.”
Disclosure to 
Imagination 
Technologies
Disclosure to Android 
OEM Partners
Public Disclosure on 
APVI Issue Tracker
Ensure that partners have 
the ability to implement 
patches
Ensure that ImgTec can 
remediate security issues 
+ issue patches
Ensure that the public is 
aware of these issues, to 
increase transparency
Statement from Imagination Technologies:
#BHUSA   @BlackHatEvents
Driver Developers
●
Security review of the driver purpose and design
●
Fuzz testing and code review
●
Lock down to minimal required access
#BHUSA   @BlackHatEvents
Researchers
●
xPUs introduce CPU/xPU memory-visibility issues
●
PowerVR seems under-researched
●
Vulnerability research is interesting, fun, and frustrating
#BHUSA   @BlackHatEvents
Resources
Find a bug that affects a driver in a Pixel device? 
●
Submit that bug here: https://bughunters.google.com/report
NPU drivers with memory mapping issues
●
CVE-2021-1940, CVE-2021-1968, CVE-2021-1969
●
CVE-2020-28343, blog
Fuzzing Kernel Drivers with Interface Awareness:
●
https://www.blackhat.com/docs/eu-17/materials/eu-17-Corina-Difuzzing-Android-Kern
el-Drivers.pdf