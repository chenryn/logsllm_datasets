𝑎𝑘
2,𝑣
...
𝑎𝑘
𝑣,𝑣
(cid:170)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:172)𝑣,𝑣
𝑡𝑙,𝑖𝑎𝑙,𝛼 + 𝑣∑︁
(cid:40)𝑝𝑘
where 𝛽𝑖,𝑗 = (𝑖 − 1)𝑚 + 𝑗 −𝑖−1
Intermediate 𝑚 × 𝑚 matrix 𝑃𝑘
−𝑇𝑇 𝑃𝑘
𝑃𝑘
3 is
3 (𝑖, 𝑗) =
𝑝𝑘
𝑚× 𝑚(cid:164)(𝑚+1)
It is important to emphasize that 𝑃𝑘
3 (𝑖, 𝑗)
(4)
3 (𝑖, 𝑗) ⊕ 𝑝𝑘
𝑝𝑘
𝛼=0 𝛼, 𝑖, 𝑗, 𝑘 ∈ {1, · · · , 𝑚} and 𝛽𝑖,𝑗 =
binary public key matrix 𝑄2 is generated by Equation 4.
3 constitutes the 𝑘𝑡ℎ row of 𝑄2.
𝑡𝛾,𝑖𝑏𝛾,𝑗 for 𝑖, 𝑗 ∈ {1, · · · , 𝑚}. (3)
3 (2, 1), 𝑝𝑘
3 (1, 2) ⊕ 𝑝𝑘
3 (3, 2), · · · , 𝑝𝑘
3 (1, 3) ⊕ 𝑝𝑘
3 (3, 3), · · · , 𝑝𝑘
1, . . . , 𝑚(𝑚 + 1)/2.
For instance the k𝑡ℎ row of 𝑄2 is of the following form:
3 (3, 1), · · · , 𝑝𝑘
(𝑝𝑘
3 (1, 1), 𝑝𝑘
3 (2, 3) ⊕ 𝑝𝑘
3 (𝑚, 𝑚)).
𝑝𝑘
Key generation algorithm outputs 𝑝𝑟𝑖𝑣𝑎𝑡𝑒_𝑠𝑒𝑒𝑑 as the private key
and 𝑝𝑢𝑏𝑙𝑖𝑐_𝑠𝑒𝑒𝑑 and 𝑄2 as the public key. Public map P needed for
signature verification is the concatenation of 𝐶, 𝐿, 𝑄1 and 𝑄2.
2.3.2 Signature Generation. primitive of LUOV is shown in Fig-
ure 2 and explained in Algorithm 1. The binary linear transfor-
mation T and 𝑝𝑢𝑏𝑙𝑖𝑐_𝑠𝑒𝑒𝑑 are generated by the hash of random
𝑝𝑟𝑖𝑣𝑎𝑡𝑒_𝑠𝑒𝑒𝑑. Then, the hash of public_seed outputs 𝐶, 𝐿 and 𝑄1.
Concatenation of message 𝑀 and a random 𝑠𝑎𝑙𝑡 hashed by H pro-
duces message ℎ to be signed. The solution of the MQ system
F (𝑠′) = ℎ is found by inserting randomly chosen vinegar variables
𝑣 into the system. Since F has a special structure, MQ collapses to
a linear system which can be easily solved which gives oil variables
𝑜 by Gaussian elimination. Finally, the signature 𝑆 is the concate-
nation of 𝑠 = T · 𝑜 + 𝑣, 𝑜 and 𝑠𝑎𝑙𝑡. It is important to note that
𝑜 is publicly available in the signature. Therefore, it is known to
the adversary. Algorithm 1 is divided into four parts, Parameter
Generation, Augmented Matrix Generation, Gaussian Elimination
and Generation of the Signature for the sake of simplicity.
2.3.3 Signature Verification. The verifier generates 𝐶, 𝐿 and 𝑄1
from the 𝑝𝑢𝑏𝑙𝑖𝑐_𝑠𝑒𝑒𝑑 using the hash function G. These parts are
then combined with the publicly available 𝑄2 to form the public
map P. Similar to the signing algorithm, the message 𝑀 and the
𝑠𝑎𝑙𝑡 are concatenated, then hashed using H to form the digest ℎ. If
P(𝑠) = ℎ, then the signature is verified, otherwise rejected.
3 A NOVEL BIT-TRACING ATTACK ON LUOV
In this section we outline a novel fault injection attack on LUOV.
The attack succeeds in efficiently recovering secret key bits from
Figure 1: LUOV public and private key generation processes.
Figure 2: Signature generation algorithm explained in four steps.
Algorithm 1: LUOV Signature Generation
Input: private_seed
Message 𝑀
Output: Signature (S||salt)
1 Parameter Generation: Binary linear transformation T and
𝑝𝑢𝑏𝑙𝑖𝑐_𝑠𝑒𝑒𝑑 are generated by the hash of random
𝑝𝑟𝑖𝑣𝑎𝑡𝑒_𝑠𝑒𝑒𝑑. Then, the hash of 𝑝𝑢𝑏𝑙𝑖𝑐_𝑠𝑒𝑒𝑑 outputs 𝐶, 𝐿
and 𝑄1. Concatenation of the message 𝑀 and a random
𝑠𝑎𝑙𝑡 hashed by H produces message ℎ to be signed.
2 Augmented Matrix Generation: Insert randomly chosen
vinegar variables 𝑣 into the MQ system F (𝑠′) = ℎ which
collapses to a linear system. The augmented matrix
generation algorithm is explained in Appendix A.
3 Gaussian Elimination: Linear system can be easily solved by
Gaussian elimination which gives oil variables 𝑜. Note that,
oil variables depend on ℎ and 𝑣 since the other parameters
are generated by the same 𝑝𝑟𝑖𝑣𝑎𝑡𝑒_𝑠𝑒𝑒𝑑.
4 Generation of the Signature: Signature 𝑆 is the
concatenation of 𝑠 = T · 𝑜 + 𝑣, 𝑜 and 𝑠𝑎𝑙𝑡.
return (𝑆, 𝑠𝑎𝑙𝑡)
faulty signatures whereas faults may be injected through software
only Rowhammer attack. The attack consists of three main phases,
pre-processing, online and post-processing phase.
The pre-processing phase which includes templating, needs to be
carried out on the same machine on which victim will be running.
The purpose of this phase is to collect the physical addresses of
the memory locations susceptible to Rowhammer. The victim does
not need to be present or running in the pre-processing phase. The
victim can then be placed at those addresses in the online phase
when the victim process starts running. In the online phase the
victim is first forced to be placed at the target addresses and then
the Rowhammer attack induces bit flips in a particular area of the
victim while the victim is carrying out the signing operations. This
causes the victim to generate faulty signatures which are public
and collected by the attacker. After collecting a number of faulty
signatures, our novel bit tracing algorithm is carried out in the post-
processing phase which can be done offline on any other machine
or cluster.
The DRAM modules installed in the system are susceptible to
Rowhammer attack. The attacker and victim processes are co-
located on the same DRAM chip. The attacker can induce bit flips in
the linear transformation T of LUOV scheme and is able to collect
the faulty signatures. The attacker has no control or knowledge
over the position of the bit flips within T and the T matrix is huge
e.g. 11,229 bits for LUOV-7-57-197 [44]. Also, the attacker does not
know the value of the flipped bit. The target of the attacker is to
trace back to the position of the flipped bit as well as to recover the
value of the bit by just using the faulty signatures. The attacker has
no knowledge of the correct signatures and can only use the public
parameters to perform the attack. Moreover, the attacker is not
using huge pages for contiguous memory. Also, she does not have
any knowledge of the DRAM mappings which convert physical ad-
dresses to DRAM ranks, banks, rows and columns. The bit-tracing
is summarized in Figure 3 and then each step is explained in detail
along-with results.
3.1 Pre-processing Phase (Templating)
The pre-processing (templating) phase of the attack is carried out
on the machine where the attacker and the victim are co-located,
sharing the same DRAM module. The victim does not need to be
present or running in this phase. As double-sided Rowhammer
requires contiguous chunk of physical memory, we allocate a 256
MBytes buffer and look for an 8 MBytes of contiguous memory
using Spoiler [24]. After that, row conflicts are found to identify the
virtual addresses mapped to the same DRAM bank. This is achieved
using a side channel since the data coming from the same bank
will take longer as compared to the data coming from the other
𝑄(cid:2869)Sponge Type Hash Functionℋ𝑝𝑟𝑖𝑣𝑎𝑡𝑒𝑠𝑒𝑒𝑑𝐶,𝐿 𝒯𝑓𝑖𝑛𝑑𝑃(cid:2869)(cid:3038)𝑓𝑖𝑛𝑑𝑃(cid:2870)(cid:3038)𝑃(cid:2871)(cid:3038)𝑃(cid:2871)(cid:3038)(cid:3404)𝑇(cid:3021)𝑃(cid:2869)(cid:3038)𝑇(cid:3397)𝑇(cid:3021)𝑃(cid:2870)(cid:3038)𝑄(cid:2870)𝑝𝑢𝑏𝑙𝑖𝑐_𝑠𝑒𝑒𝑑𝑝𝑢𝑏𝑙𝑖𝑐𝑠𝑒𝑒𝑑𝒢Private Key𝑝𝑟𝑖𝑣𝑎𝑡𝑒_𝑠𝑒𝑒𝑑Public Key 𝑄(cid:2870)𝑝𝑢𝑏𝑙𝑖𝑐_𝑠𝑒𝑒𝑑Figure 3: Phases of novel bit-tracing attack on LUOV
banks. As the data from the row buffer needs to be copied back
to the original row before the data from another row within the
same bank is loaded into the row buffer, it creates additional delay.
The measurements are shown in Figure 4 and a threshold value of
380 cycles is set in our experiments. This threshold value may vary
from one machine to another.
Figure 5: Number of bit flips increases with the increase in
number of hammers. The experiment is repeated 30 times
for each number of hammers on an 8 MBytes contiguous
chunk of memory and the results are then averaged out.
Figure 4: Row conflicts for the pages from the detected con-
tiguous memory. The higher timings indicate that the pages
are mapped to the same DRAM bank which are the target
for the Rowhammer attack.
Once we find the virtual addresses mapped to the same DRAM
bank, we start the process of double-sided Rowhammer to find
the DRAM rows suitable for Rowhammer. We found 125 rows in
8 MBytes of contiguous memory which are mapped to the same
bank. Our results indicate that the rows in the DRAM are ordered
sequentially if the targeted memory is contiguous. These rows are
then taken 3 at a time with aggressor rows on the sides and the
victim row in the middle and aggressor rows are accessed (ham-
mered) repeatedly to get flips in the victim row. The number of bit
flips found within this contiguous chunk can be seen in Figure 5
against the number of hammers. It is observed that the number
of bit flips increase with the number of hammers. To find the sus-
ceptible memory locations in the pre-processing phase we set a
value for number of hammers as 106. The other observation is that
there is not much difference between the number of 1 −→ 0 flips
and 0 −→ 1 flips. To achieve bidirectional flips, we fill the aggressor
rows with all zeros and the victim row with all ones for 1 −→ 0 flips
and aggressor rows with all ones and the victim with all zeros for
0 −→ 1 flips as explained in Figure 6.
The final step of the pre-processing phase is to free the vulnerable
memory pages from the attacker process so that the victim can be
placed at that location for the online attack. We do this by using
𝑚𝑢𝑛𝑚𝑎𝑝 instruction for every 8 KBytes row. As the bit flips are
Figure 6: Double-sided Rowhammer with different data pat-
terns. If the attacker rows are filled with all zeros, the bit
flips occur in 1 −→ 0 direction and if the attacker rows are
filled with all ones, the bits are flipped from 0 −→ 1. This
strategy helps to recover the values of the bit positions of T
traced by the bit-tracing attack.
highly reproducible, Rowhammer will flip the same bits again but
in the victim process in the online phase.
The experiments are carried out on a Haswell system with DDR3
memory, running Ubuntu OS. 17,129 vulnerable physical addresses
are found in 5.7 hours. These experiments are done repeatedly
Post-processing(offline on any other machine / cluster)1. Bit tracing attackOnline Attack(when the victim is present / signing)1. Placing victim at flippy addresses.2. double-sided Rowhammer.Pre-processing(while co-located on victim machine before the victim is present)1. Contiguous memory detection.2. Finding DRAM row conflicts.3. double-sided Rowhammer.4. Freeing flippy addresses.flippy physicaladdressesfaultysignatureskey bitsPre-processing Phase(Templating)Online Phase(Rowhammer Attack)Post-processing PhaseFaulty signaturesTarget addresses1. Contiguous memory detection2. Finding DRAM row conflicts3. Double-sided Rowhammer4. Freeing target addresses1. Placing victim at flippy addresses2. Double-sided RowhammerKey bits020406080100120140160180200Page Number250300350400450Cycles012345678910Number of Hammers107050100150200250Number of Bit Flips10 flips01 flipsTotal flips0 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 01 1 1 1 01 1 01 1 1 ... 1 1 1 1 1 1 1 01 1 10 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 0......(1→0 bit flips)Aggressor RowAggressor RowVictim Row1 1 1 1 1 1 1 1 1 1 1 ... 1 1 1 1 1 1 1 1 1 1 10 0 0 100 0 0 0 10 ... 0 0 0 0 0 10 0 0 0 01 1 1 1 1 1 1 1 1 1 1 ... 1 1 1 1 1 1 1 1 1 1 1......(0→1 bit flips)Aggressor RowAggressor RowVictim Rowusing a script as 8 MBytes of contiguous memory is not enough
for gathering these many addresses. So, 256 MBytes of memory
is allocated again and again out of which 8 MBytes of contiguous
chunk is detected. Each chunk is then checked for all possible bit
flips. A big single chunk of contiguous memory is hard to find in a
live system running various processes.
3.2 Online Phase (Rowhammer attack)
The pre-processing phase gives a list of vulnerable physical ad-
dresses and the goal of the online phase is to first place the target
linear transformation T of LUOV scheme at one of those physical
addresses and then do the double-sided rowhammer again to get
bit flips in T . For experimental purposes, we achieve this by keep
allocating memory pages for the T with in the victim process until
it either gets in one of the target addresses or one page next to a
target address. This is because one DRAM row comprises 8 KBytes
having two 4 KBytes pages and the size of the T matrix is less
than a 4 KBytes page. For LUOV-7-57-197, the size of the linear
transformation matrix T is (57 × 197)/8 = 1, 404 Bytes. Hence, if
T gets in either of the two pages of the target row, we can start
doing the Rowhammer attack. This process is time consuming as a
large number of memory pages are allocated until T is mapped to
the desired target address.
The placement of victim can also be achieved by using other
techniques present in the literature like spraying [22, 39, 46], groom-
ing [43] and memory-waylaying [21, 31, 47]. Figure 7 shows the
number of T bits flipped against time. The number of bit flips do
not increase linearly with time as we start getting the same bit
flips over and over again. Out of 25,335 bit flips, only 8,902 were
unique in 16 hours of the online phase. We can see that in the first
hour we get 1,334 bit flips, little less than a double in two hours
and after that the bit flips are getting repeated more often. Still, we
are able to recover approximately 80% of the T bits in 16 hours.
Figure 8 indicates the number of bit flips per column of T which
will be used by QuantumHammer in Section 4. The working of the
attack is verified when the victim and attacker process are running
independently in different terminals but due to the system crashes,
memory constraints, disk errors and synchronization problems,
the attacker and the victim process are combined as we needed to
run the experiments for l6 hours continuously. For example, in a
2GB memory in which only 25% memory is available in a running
system, two separate processes start taking the swap partition. This
makes the system slow and unresponsive.
3.3 Post-processing Phase
The post-processing phase takes the faulty signatures collected
in the online phase and is able to recover the key bits of T . We
consider it a weakness of the LUOV scheme because the faulty
public signatures should not lead back to the secret key bits of T .
In the LUOV scheme, if T is recovered, the secret central map F
can be easily computed using the public map P, as P = F ◦ T .
Thus, recovering T is enough to break the scheme and forging any
signature. The bit-tracing algorithm can be executed offline on any
other system or cluster independently.
In the last stage of LUOV, there is a linear transformation T
which gives the signature as the output. The intuition behind the
𝑠1
...