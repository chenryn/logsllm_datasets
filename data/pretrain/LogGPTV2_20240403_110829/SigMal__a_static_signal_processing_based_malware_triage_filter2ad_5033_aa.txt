title:SigMal: a static signal processing based malware triage
author:Dhilung Kirat and
Lakshmanan Nataraj and
Giovanni Vigna and
B. S. Manjunath
SigMal: A Static Signal Processing Based Malware Triage
Dhilung Kirat
University of California,
PI:EMAIL
Santa Barbara
Giovanni Vigna
University of California,
PI:EMAIL
Santa Barbara
Lakshmanan Nataraj
University of California,
Santa Barbara
PI:EMAIL
B.S Manjunath
University of California,
PI:EMAIL
Santa Barbara
ABSTRACT
In this work, we propose SigMal, a fast and precise mal-
ware detection framework based on signal processing tech-
niques. SigMal is designed to operate with systems that pro-
cess large amounts of binary samples. It has been observed
that many samples received by such systems are variants
of previously-seen malware, and they retain some similarity
at the binary level. Previous systems used this notion of
malware similarity to detect new variants of previously-seen
malware. SigMal improves the state-of-the-art by leveraging
techniques borrowed from signal processing to extract noise-
resistant similarity signatures from the samples. SigMal uses
an eﬃcient nearest-neighbor search technique, which is scal-
able to millions of samples. We evaluate SigMal on 1.2 mil-
lion recent samples, both packed and unpacked, observed
over a duration of three months. In addition, we also used a
constant dataset of known benign executables. Our results
show that SigMal can classify 50% of the recent incoming
samples with above 99% precision. We also show that Sig-
Mal could have detected, on average, 70 malware samples
per day before any antivirus vendor detected them.
Keywords
malware similarity, detection, signal processing
1.
INTRODUCTION
The ever-increasing volume of new malware produced ev-
ery day is a challenging problem [16]. The analysis of such
a large quantity of new malware demands scalable analysis
techniques as well as eﬃcient triage systems that can quickly
prioritize the incoming samples. There are three main ap-
proaches to malware analysis in practice: Static Analysis,
Dynamic Analysis, and Statistical Analysis. Static analysis
disassembles the code present in the executable without ex-
ecuting the program, and analyzes diﬀerent static features
of the code, such as the control ﬂow graph,
in order to
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee. Request permissions from Permissions@acm.org.
ACSAC ’13 Dec. 9-13, 2013, New Orleans, Louisiana USA
Copyright 2013 ACM 978-1-4503-2015-3/13/12 ...$15.00.
http://dx.doi.org/10.1145/2523649.2523682
identify malicious behavior. Dynamic analysis runs the ex-
ecutable in a controlled environment, and then analyzes its
runtime behavior. In contrast, statistical analysis is agnostic
to the code semantics and the dynamic behavior of the bi-
nary executable. Instead, it operates directly on the binary
by computing diﬀerent statistical features of the actual con-
tent without disassembly. These statistical features are then
used to identify malware, usually through machine learning
and classiﬁcation. Compared to other malware analysis ap-
proaches, statistical analysis can be relatively fast and scal-
able. While static, dynamic, and statistical analyses all have
trade-oﬀs and limitations, statistical analysis has a distinct
advantage in speed and complexity that makes it suitable for
the goal of this paper: a triage framework that can operate
on a large quantity of daily malware samples.
A large portion of the new malware samples introduced
every day is composed of new variants of already-observed
malware. Two malware samples are considered variants
if they exhibit similar malicious dynamic behavior when
executed. Malware variants usually share large portions
of the code, which is reﬂected in the machine-level code
present in the executable. This notion of binary-content-
level similarity among variants of malware can be used to
detect new variants of previously-seen malware. Diﬀerent
ﬁle similarity-based malware detection techniques have been
proposed [10, 12, 19, 29, 32, 34, 35]. These techniques are
based on the assumption that similar malware share sim-
ilar code and ﬁle structures, and require uncompressed and
unencrypted malware code for eﬀective detection. However,
easily-available polymorphic engines and generic packers are
the most prevalent techniques used for generating new mal-
ware variants. These tools obfuscate the variants of mal-
ware code by adding random modiﬁcations (noise), and pre-
vent the signature-based detection.
It has been observed
that malware packers commonly use weak encryption and
compression algorithms, and such operations preserve cer-
tain statistical and structural properties at the binary level,
which can be used to detect similarity without unpacking [9].
Most of these similarity detection techniques, including [9],
are based on diﬀerent versions of N-gram feature extraction.
The N-gram based operations are computationally expen-
sive, and usually not suitable in large triage systems. Some
of the techniques that only extract features from the exe-
cutable headers (PE structure) are fast, however, they are
less precise because they ignore the content-level similar-
ity of code. Moreover, the N-gram-based approaches are
focused on the matching-substrings, regardless of their posi-
Figure 1: SigMal overview.
tion. They do not detect the similarity of the spatial struc-
ture. However, in case of the executable similarity, detecting
the similarity of the spatial structure of the content is very
important. This is because the executables are inherently
structured, almost a replica of its memory structure, which
includes the spatial structure of the machine-level code re-
siding in the code section. The content-hashing-based tech-
niques, such as peHash [35] and Piecewise-Hash [14], can
capture some level of structural characteristics of an exe-
cutable. However, they are susceptible to small noise in-
troduced into the executables. Specially, while detecting
similarity among malware executables, a robust similarity
detection method needs to be noise resistant because of the
random modiﬁcations introduced by polymorphic engines
and packers. In Image Processing, the image similarity de-
tection techniques deal with a very similar problem, i.e.,
ﬁnding similarity among spatially structured content, while
remaining less susceptible to noise. We apply similar tech-
niques to detect similarity among malware executables.
In this paper, we propose SigMal, a fast and precise sig-
nal processing-based malware similarity detection technique
suitable for a large-scale malware triage. SigMal features
are based on both the PE structure and the binary content
of the executable. Compared to existing similarity detec-
tion features, the signal processing-based features are less
susceptible to the random modiﬁcations (noise) introduced
by a polymorphic or metamorphic engine.
The binary content of the executable can be considered
as a one-dimensional signal. We ﬁrst transform this one-
dimensional signal into a two-dimensional digital image, so
that we can computationally extract robust signatures from
this image. These signatures are then used for the malware
similarity detection. The intuition here is that similar mal-
ware produce similar image texture patterns. A texture is a
set of metrics representing the spatial arrangement of color
or intensities in an image, in our case it is the content of the
executable. The similarity features are extracted from these
texture-patterns. This approach of binary transformation
is similar to the malware visualization technique proposed
in [20], in which the one-dimensional signal of an entire bi-
nary is “reshaped” into a two-dimensional gray-scale image.
However, extracting the feature from the entire binary can
be problematic. If a malware reorders its internal sections,
the resulting features will be signiﬁcantly diﬀerent. In ad-
dition, only the section or the sections of the binary that
contain the malicious code are likely to be similar among
similar malware. Similarity in other sections, such as the re-
source section, does not necessarily imply similar malware.
We will see that this approach, as proposed in [20], per-
forms the worst when compare to existing static malware
detection techniques. Our method takes advantage of the
information available in the PE structure of the executable
to infer the “important” sections that are most likely to con-
tain the malicious code. From these sections, we compute
separate texture features for similarity detection. These fea-
tures are then combined to form a larger feature-set. This
approach considerably increases the dimensionality of the
feature, in our case by three times, which makes it challeng-
ing to make it work in a large-scale triage system. How-
ever, we use a scalable Balltree-based fast nearest-neighbor
technique, which can scale our malware similarity detection
method to millions of malware. In particular, SigMal’s fea-
ture extraction is based on the Gabor wavelets-based ﬁlters,
which are commonly used in the large-scale content-based
image retrieval systems. It has been shown that such sig-
nature features perform well in identifying similar images
in a web-scale dataset of natural images (110 million) [7].
We will show that these features are also eﬀective in ﬁnding
similar malware samples in a large set of executable samples.
An overview of the system is presented in Fig. 1. SigMal
takes sets of known malware samples and known benign sam-
ples, extracts features and builds a classiﬁer model. The sys-
tem performs per-sample analysis of new input executable
samples and identiﬁes them as malware, benign, or unknown.
Our method is suitable in a setting where large numbers of
samples are received every day, and the samples need to be
quickly classiﬁed as either benign or malicious. This is in-
deed a common scenario in the computer security industry,
research organizations, and government institutions. Fast
static detection of similar malware can avoid repeated anal-
ysis, and save large amount of resources required to perform
more complex analysis, such as dynamic analysis. By di-
rectly operating on the packed binary, our technique avoids
the costly operation of preliminary unpacking.
We compared our approach with other static-feature-based
malware detection approaches, speciﬁcally N-gram-based de-
tection, PE-feature-based detection, and control-ﬂow-graph-
based detection. We show that our method outperforms all
of these methods in terms of precision. In the 10-fold cross-
validation experiment on 103,808 samples, SigMal could
achieve average per-sample query response time of 47.95 mil-
liseconds and 99% detection precision. We also performed
a large-scale experiment on a dataset of 1.2 million samples
observed during the period of 3 months.
The main contributions of this paper are the following:
• We propose an eﬃcient and scalable signal processing-
based malware similarity measure that can detect mal-
ware with high speed and precision.
• We evaluated its performance with respect to existing
static malware similarity approaches using a dataset of
51,058 malicious and 52,750 benign samples. We show
that our method outperformed all other methods in
terms of precision.
• We evaluated SigMal on 1.2 million recent samples,
both packed and unpacked, observed over three months.
We demonstrate that SigMal can classify 50% of the
incoming samples with more than 99% precision.
• We show that SigMal could have detected, on aver-
age, 70 malware samples per day before any antivirus
vendor detected them.
2. SIGNAL PROCESSING-BASED
FEATURES
In this section, we describe the signal processing-based
feature extraction. The executable binary content is taken
MalwareDatabaseBenignDatabaseFeature ExtractionDSP featuresMachine LearningClassifierNew SampleMalwareBenignUnknownas a one-dimensional signal, represented as a vector of bytes.
This vector is “reshaped” into a two-dimensional matrix of
ﬁxed width d. In other words, the ﬁrst d bytes go to the
ﬁrst row of the matrix, and the nth group of d bytes goes
to the nth row of the matrix. This approach is similar to
the malware visualization technique proposed in [20]. The
two-dimensional matrix, after a necessary padding, is now
considered as a digital gray-scale image, which is “resized”
into a square image of width s for eﬃcient computation.
Image-texture-based signature features are extracted from
this transformed image. The transformed image captures
the short-range correlations of the signal as the texture with
horizontal orientation, and the long-range correlations as the
texture with vertical orientation. This is because the hori-
zontally adjacent pixels in the image correspond to the ad-
jacent bytes in the binary (short-range), and the vertically
adjacent pixels correspond to the bytes spaced by a multi-
ple of width d in the binary (long-range). Instead of using a
variable width d, as proposed in [20], we use a ﬁxed width
transformation to maintain the consistency in the texture
produced as a result of this transformation. As long as the
same width is used for each executable, the choice of the
width does not aﬀect the similarity of the texture produced
among similar executables. Based on this similarity of the
textures, we would like to computationally obtain a signa-
ture that captures this similarity. This problem has been
widely explored and texture features have been extensively
used in the ﬁeld of image processing for content-based im-
age retrieval [18], scene classiﬁcation [21,33], and large-scale
image search [7]. Even though some sections of the image
look completely random to a human eye, texture features
can capture a signature of the randomness that is suitable
for similarity detection. The methodology for computing the
texture-based features is described in the next section.
2.1 Feature computation
In this section, we review the computation of the texture-
based-features.
We compute the features based on GIST descriptors [21].
The descriptors are computed by ﬁrst ﬁltering the image in
various frequency sub-bands and then computing local block
statistics on the ﬁltered images.
Let I(x, y) be the image on which the descriptor is to be
computed. The GIST descriptor is computed by ﬁltering
this image through a ﬁlter bank of Gabor ﬁlters [6]. These