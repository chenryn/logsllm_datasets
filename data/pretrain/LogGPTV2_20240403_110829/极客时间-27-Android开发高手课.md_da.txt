# 程序员修炼之路 \| 设计能力的提升途径> 你好，我是张绍文，今天我要和你分享我的朋友长元的一篇文章，主题是设计能力的提升途径。专栏已经进入架构演进模块，由于每个人对架构的理解都不同，在工作中也会遇到各种各样的架构设计问题，很多时候我们的架构设计能力都是靠不断的理论学习和在设计实践中不断摸索提高的，因此在成为设计高手的道路上，我们肯定或多或少有些自己的经验和体会，当然也少不了踩坑。今天长元分享的设计能力提升路径，希望可以把他的经验分享给你，你可以参考他的提升路径来强化自己的设计能力，在高手的修炼之路上少走弯路。每当我做完一次内部设计培训以后，经常有同学来问我：如何才能快速提升自己的设计能力？我觉得这个问题非常有代表性，代表了一大波程序员在艰辛修炼路上的心声。今天我就来分享一下我所理解的程序员设计能力的提升路径，也欢迎你留言写写你的思考与体会。**1. 编码历练**代码行经验是个非常重要的东西，当你还没有 1万行代码经验的时候，如果你来问我如何提升设计能力这个问题，我只能告诉你不要太纠结，看看理论就好，老老实实先写代码吧。一个程序员平均每天码代码的速度是 200～300行。你可能会说，我一天怎么也要写上 1000行吧？别忘了，当你码完代码后，你还需要测试、调试、优化、BugFix，这些时间你没法一直码代码的。``{=html}编码规范就不多说了，如果你的代码还是杂乱无章的状态，就先别谈什么设计与架构了，先把基础的工作做好再谈其他的吧。另外，作为"代码洁癖患者"，推荐你不要在写完代码后，再做批量格式化处理，或者手工再去整理代码，而是应该每敲一个字符，都是符合规范的。习惯真的很重要，有时在招聘面试的时候，我真想添加一个环节，现场编写程序完成一个简单但容易出错的任务，考察一下你的代码基本功。**2. 理论学习**简单说就是看书、看博客，学习你能得到的所有资源，但前提是内容质量要高。例如图书，我推荐：《重构改善既有代码的设计》《敏捷软件开发：原则、模式与实践》《UML和模式应用》《设计模式》等，其他你还需要学习面向对象设计原则（五大原则）。《设计模式》是本很古老的书了，只有短短 200页，但是可能这是最难看懂的一本书了，可能一个月都看不完（看小说的话，200页 3个小时也许就看完了吧）。而且就算看完了，也不会全看懂，很可能看懂的内容不超过30%。我想说的是，看不懂没关系，认真看了就行，不用太纠结，因为这不能说明什么问题。另外，我想说一下，多线程技术是程序员必须掌握的，而且需要理解透彻。现在的高级技术例如GCD，会掩盖你对多线程理解不足的问题，因为使用起来实在太简单了。另外，别说你没写过多线程依然完成了复杂的项目，更别说你随手写出的多线程代码好像也没出什么问题啊，你可以试试把你的代码给技术好的同事看看，分分钟写个Demo 让它出错乃至崩溃。**3. 实践**现在，你已经具备了一定的编码经验，而且已经学习了足够的理论知识，接下来就是真正练手的时候了。好好反复思考你学习的这些理论知识，要如何运用到项目中去，通过身体力行的实践，一定要把那些理论搞清楚，用于指导你的实践。在实践的过程中，你要收起从前的自信，首先否定自己以前的做法，保证每次做出的东西相比以前是有进步、有改进的。**4. 重温理论**你已经能看到自己的进步了，发现比以前做得更好了，但是总感觉还不够，好像有瓶颈似的，恭喜你，已经可以看到你未来的潜力了。重新拿起书本，重温一遍之前看的那些似懂非懂的东西，你会发现之前没弄懂的内容，现在豁然开朗了，不再有那种难于理解的晦涩感了。而且就算是以前你觉得自己已经理解的内容，再看一遍的话，通常也会有新的收获。**5. 再实践**这个阶段，你已经掌握了较多的知识，不但实践经验丰富，各种理论也能手到擒来了。但是，你发现你的设计依然不够专业，而且回过头去看以前写的代码，你会惊讶：天啊，这是谁写的代码，怎么能这样干！然后，就不多说了...此时，你已经进入了自省的阶段，掌握了适合自己的学习方法，之后再学习什么新东西，都不会再难住你了。**6. 总结**先别太得意（不信？那你去给团队分享一次讲座试试），你还需要总结，总结自己的学习方法、总结项目经验、总结设计理论的知识。如果你能有自己独到的理解，而不是停留在只会使用成熟的设计模式什么的，能根据自己的经验教训总结出一些设计原则，那自然是极好的。**7. 分享**分享是最好的学习催化剂，当你要准备一次培训分享的时候，你会发现先前以为已经理解的东西其实并没有完全理解透彻，因为你无法把它讲清楚，实际上还是研究得不够透彻。这时会迫使你再重新深入学习，做到融汇贯通，然后你才敢走上讲台。否则，当别人提问的时候，你根本回答不上来。以上，便是我认为的程序员修炼道路的必经阶段。接下来，我再分享几点其他对设计能力提升非常重要的方法。-   **养成先设计，再编码的习惯。**几乎所有的程序员，一开始都不太愿意写文档，也不太愿意去精心设计，拿到需求总是忍不住那双躁动的手，总觉得敲在键盘上，把一行一行的代码飙出来，才有成就感，才是正确的工作姿势。我的建议是，没讨论清楚不要编码，不然你一定会返工。-   **设计重于编码，接口重于实现。**制定接口的过程，本身就是设计过程，接口一定要反复推敲，尽量做减法而不是加法，在能满足需求的情况下越简单越好。另外，不要一个人冥思苦想。可以先简单做一个雏形出来，然后去找使用方沟通，直到对方满意为止。不要完全根据使用需求去设计接口，参考MVVM，ViewModel 就是根据 View 的需要而对 Model进行的再封装，不能将这些接口直接设计到 Model 中。-   **不盲从设计模式。**设计模式只是一种解决问题的套路方法，你也可以有自己的方法，当然设计模式如果用好了，会让你的设计显得专业、优雅，毕竟前辈们的心血结晶是非常有价值的。但是如果滥用的话，也会导致更严重的问题，甚至可能成为灾难。我觉得面向对象设计原则更加重要，有些原则是必须遵守的（如单向依赖、SRP等），而设计模式本身都是遵守这些原则的，有些模式就是为了遵循某原则而设计出来的。抽象不是万能的，在适当的地方使用，需要仔细推敲。当有更好的方案不用抽象就能解决问题时，尽量避免抽象。我见过太多抽象过火、过度设计的案例了，增加了太多维护成本，还不如按照最自然的方式去写。-   **空杯心态，向身边的同学学习，站在巨人的肩上，站在别人的肩上。**有人提意见，先收下它（无论接受与否）。很多程序员都有个"毛病"，就是觉得自己技术牛的不行，不愿意接受别人的意见，尤其是否定意见（文人相轻）。但是无论是理论的学习，还是编码实践，向身边的同学学习是对自己影响最大的（三人行，必有我师）。我自己就经常在跟团队同学讨论中获益，当百思不得其解的时候，把问题抛出来讨论一下，通常都能得到一个最佳方案。另外，跟团队其他人讨论还有一个好处，就是当你的设计有妥协或有些不专业的时候，别人看到代码也不会产生质疑，因为他也参与了讨论，你不用花那么多时间去做解释。设计期间一定要找其他人一起讨论，我一直比较反对一个人把设计做完、把文档写完，然后才找大家开个评审会那种模式，虽然也有效果，但是效果达不到极致。因为大家没有参与到设计中，通过一次会议的时间理解不一定有那么深，最关键的是，如果在会上发现设计有些问题，但不是致命问题的时候，通常并不会打回重新设计。相反，如果前期讨论足够，大家都知道你的思路与方案，而且最后也有设计文档，当其他人阅读你的代码的时候，根本无需你再指引，这样今后在工作交接时都会很顺利，何乐而不为呢？最后，我想呼吁一下，当你去修改维护别人的代码时，最好找模块负责人深入讨论沟通一下，让他明白你的需求以及你的方案，请他帮忙评估方案是否可行，是否会踩坑、埋坑等。如果你恰好是模块的负责人，请行使你的权力，拒绝有问题的不符合要求的代码提交入库。欢迎你点击"请朋友读"，把今天的内容分享给好友，邀请他一起学习。![](Images/0e5461ae1393aa633b672fbee779c7e1.png){savepage-src="https://static001.geekbang.org/resource/image/bf/f1/bf8fdc35ddccb10b1161d8ca7eb8f8f1.jpg"}
# 聊聊Framework的学习方法大家好，我是陆晓明，现在在一家互联网手机公司担任 Android系统开发工程师。很高兴可以在极客时间 Android开发高手课专栏里，分享一些我在手机行业 9 年的经验以及学习 Android的方法。今天我要跟你分享的是 Framework 的学习和调试的方法。首先，Android 是一种基于 Linux的开放源代码软件栈，为广泛的设备和机型而创建。下图是 Android平台的[主要组件](https://developer.android.google.cn/guide/platform)。![](Images/d4fd8a4a09c86c5a99c097ba84d124cd.png){savepage-src="https://static001.geekbang.org/resource/image/90/df/90763fd9662c8a75553dc92a78112ddf.png"}从图中你可以看到主要有以下几部分组成：-   **Linux 内核**-   **Android Runtime**-   **原生 C/C++ 库**-   [Java API 框架（后面我称之为 Framework 框架层）]{.orange}-   **系统应用**我们在各个应用市场看到的，大多是第三方应用，也就是安装在 data区域的应用，它们可以卸载，并且权限也受到一些限制，比如不能直接设置时间日期，需要调用到系统应用设置里面再进行操作。而我们在应用开发过程中使用的四大组件，便是在 Framework框架层进行实现，应用通过约定俗成的规则，在 AndroidMainfest.xml中进行配置，然后继承对应的基类进行复写。系统在启动过程中解析AndroidMainfest.xml，将应用的信息存储下来，随后根据用户的操作，或者系统的广播触发，启动对应的应用。``{=html}那么，我们先来看看 Framework 框架层都有哪些东西。Framework框架层是应用开发过程中，调用的系统方法的内部实现，比如我们使用的TextView、Button 控件，都是在这里实现的。再举几个例子，我们调用ActivityManager 的 getRunningAppProcesses方法查看当前运行的进程列表，还有我们使用 NotificationManager 的 notify发送一个系统通知。让我们来看看 Framework 相关的代码路径。![](Images/a99aefa27dc857ff234446e9f9b4054c.png){savepage-src="https://static001.geekbang.org/resource/image/17/d4/178ef00a181a85e85a3b75d4c60abcd4.jpg"}如何快速地学习、梳理 Framework 知识体系呢？常见的学习方法有下面几种：-   阅读书籍（方便梳理知识体系，但对于解决问题只能提供方向）。-   直接阅读源码（效率低，挑战难度大）。-   打 Log 和打堆栈 （效率有所提升，但需要反复编译，添加 Log    和堆栈代码）。-   直接联调，实时便捷（需要调试版本）。首先可以通过购买相关的书籍进行学习，其中主要的知识体系有 Linux操作系统，比如进程、线程、进程间通信、虚拟内存，建立起自己的软件架构。在此基础上学习Android 的启动过程、服务进程 SystemServer 的创建、各个服务线程（AMS/PMS等）的创建过程，以及 Launcher 的启动过程。熟悉了这些之后，你还要了解 ART虚拟机的主要工作原理，以及 init 和 Zygote的主要工作原理。之后随着在工作和实践过程中你会发现，Framework主要是围绕应用启动、显示、广播消息、按键传递、添加服务等开展，这些代码的实现主要使用的是Java 和 C++ 这两种语言。通过书籍或者网络资料学习一段时间后，你会发现很多问题都没有现成的解决方案，而此时就需要我们深入源码中进行挖掘和学习。但是除了阅读官方文档外，别忘了调试Framework 也是一把利刃，可以让你游刃有余快速定位和分析源码。下面我们来看看调试 Framework 的 Java 部分，关于 C++ 的部分，需要使用 GDB进行调试，你可以在课下实践一下，调试的过程可以参考[《深入 Android源码系列（一）》](https://mp.weixin.qq.com/s/VSVUbaEIfrmFZMB1k49fyA)。我们这里使用 Android Studio 进行调试，在调试前我们要先掌握一些知识。Java代码的调试，主要依据两个因素，一个是你要调试的进程；一个是调试的类对应的包名路径，同时还要保证你所运行的手机环境和你要调试的代码是匹配的。只要这两个信息匹配，编译不通过也是可以进行调试的。我们调试的系统服务是在 SystemServer进程中，可以使用下面的命令验证（我这里使用 Genymotion 上安装 Android对应版本镜像的环境演示）。    ps -A |grep system_server  查看系统服务进程 pidcat /proc/pid/maps |grep services 通过 cat 查看此进程的内存映射，看看是否 services 映射到内存里面。这里我们看到信息：/system/framework/oat/x86/services.odex 。odex 是 Android 系统对于 dex的进一步优化，目的是为了提升执行效率。从这个信息便可以确定，我们的services.jar确实是跑到这里了，也就是我们的系统服务相关联的代码，可以通过调试SystemServer 进程进行跟踪。下来我们来建立调试环境。-   打开 Genymotion，选择下载好 Android 9.0 的镜像文件，启动模拟器。-   找到模拟器对应的 ActivityManagerService.java 代码。    我是从下载 Android 9.0 对应的代码。-   打开 Android Studio，File -\> New -\> New Project 然后直接 Next    直到完成就行。-   新建一个包名，从 ActivityManagerService.java    文件中找到它，这里为`com.android.server.am`，然后把    ActivityManagerService.java 放到里面即可。-   在 ActivityManagerService.java 的 startActivity    方法上面设置断点，然后找到菜单的 Run -\> Attach debugger to Android    process 勾选 Show all process，选中 SystemServer 进程确定。![](Images/ceb84d897452df7b6d7e0f4f81a9c76d.png){savepage-src="https://static001.geekbang.org/resource/image/ba/f0/ba1eb6bded9167f26ae48b34a6d792f0.png"}这时候我们点击 Genymotion 模拟器中桌面的一个图标，启动新的界面。![](Images/ae59bafd9111268a7764239e1467708a.png){savepage-src="https://static001.geekbang.org/resource/image/c9/45/c92b62d1065f967696dbdd2851037b45.png"}会发现这时候我们设定的断点已经生效。![](Images/d6f025372925bb967039c45b389c2ce5.png){savepage-src="https://static001.geekbang.org/resource/image/76/05/763f222e01a30c969024d8cf77dd0705.png"}你可以看到断下来的堆栈信息，以及一些变量值，然后我们可以一步步调试下去，跟踪启动的流程。对于学习系统服务线程来讲，通过调试可以快速掌握流程，再结合阅读源码，便可以快速学习，掌握系统框架的整个逻辑，从而节省学习的时间成本。以上我们验证了系统服务 AMS服务代码的调试，其他服务调试方法也是一样，具体的线程信息，可以使用下面的命令查看。    ps -T 353 这里 353 是使用 ps -A |grep SystemServer 查出 SystemServer 的进程号![](Images/34e3fa1616ea12abf7169df24864be4d.png){savepage-src="https://static001.geekbang.org/resource/image/62/a8/62d0d79e490a14f19422486c5da85fa8.png"}在上面图中，PID = TID 的只有第一行这一行，如果 PID = TID的话，也就是这个线程是主线程。下面是我们平时使用 Logcat 查看输出的信息。    03-10 09:33:01.804   240   240 I hostapd : type=1400 audit(0.0:1123): avc: de03-10 09:33:37.320   353  1213 D WificondControl: Scan result ready event03-10 09:34:00.045   404   491 D hwcomposer: hw_composer sent 6 syncs in 60s这里我还框了一个 ActivityManager的线程，这个是线程的名称，通过查看这行的 TID（368）就知道下面的 Log就是这个线程输出的。    03-10 08:47:33.574   353   368 I ActivityManager: Force stopping com.android.providers学习完上面的知识，相信你应该学会了系统服务的调试。通过调试分析，我们便可以将系统服务框架进行庖丁解牛般的学习，面对大量庞杂的代码掌握起来也可以轻松一些。我们回过头来，再次在终端中输入`ps -A`，看看下面这一段信息。![](Images/31fbfc3a7d5f965c31b2ae7f9d24f09e.png){savepage-src="https://static001.geekbang.org/resource/image/29/4e/298cadbc90a1f04d02e1e116f6db464e.png"}你可以看到这里的第一列，代表的是当前的用户，这里有 system root 和u0_axx，不同的用户有不同的权限。我们当前关注的是第二列和第三列，第二列代表的是PID，也就是进程 ID；第三列代表的是 PPID，也就是父进程 ID。你发现我这里框住的都是同一个父进程，那么我们来找下这个 323进程，看看它到底是谁。    root 323 1 1089040 127540 poll_schedule_timeout f16fcbc9 S zygote这个名字在学习 Android 系统的时候，总被反复提及，因为它是我们 Android世界的孵化器，每一个上层应用的创建，都是通过 Zygote 调用 fork创建的子进程，而子进程可以快速继承父进程已经加载的资源库，这里主要指的是应用所需的JAR 包，比如/system/framework/framework.jar，因为我们应用所需的基础控件都在这里，像View、TextView、ImageView。接下来我来讲解下一个调试，也就是对 TextView 的调试（其他 Button调试方式一样）。如前面所说，这个代码被编译到/system/framework/framework.jar，那么我们通过 ps 命令和 cat/proc/pid/maps 命令在 Zygote 中找到它，同时它能够被每一个由 Zygote创建的子进程找到，比如我们当前要调试 Gallery 的主界面 TextView。我们验证下，使用`ps -A |grep gallery3d`查到 Gallery 对应的进程 PID，使用cat /proc/pid/maps \|grep framework.jar 看到如下信息：    efcd5000-efcd6000 r--s 00000000 08:06 684                                /system/framework/framework.jar这说明我们要调试的应用进程在内存映射中确实存在，那么我们就需要在gallery3d 进程中下断点了。下来我们建立调试环境：-   打开 Genymotion，选择下载好 Android 9.0    的镜像文件，启动模拟器，然后在桌面上启动 Gallery 图库应用。-   找到模拟器对应的 TextView.java 代码。-   打开 Android Studio，File -\> New -\> New Project 然后直接 Next    直到完成就行。-   新建一个包名，从 TextView.java 文件中找到它的包名，这里为    android.widget，然后把 TextView.java 放到里面即可。-   在 TextView.java 的 onDraw 方法上面设置断点，然后找到菜单的 Run -\>    Attach debugger to Android process 勾选 Show all process，选中    com.android.gallery3d 进程（我们已知这个主界面有 TextView    控件）确定。然后我们点击下这个界面左上角的菜单，随便选择一个点击，发现断点已生效，具体如下图所示。![](Images/ce821e82a5cb326e90db95fe6521172d.png){savepage-src="https://static001.geekbang.org/resource/image/c2/85/c2a9a5a71d4bd4a02b5bee113d866b85.png"}然后我们可以使用界面上的调试按钮（或者快捷键）进行调试代码。![](Images/68e034cd402b2fc68f837024b777d834.png){savepage-src="https://static001.geekbang.org/resource/image/c3/f8/c395c9f16a7c057c1076b4619dd1b5f8.png"}今天我讲解了如何调试 Framework 中的系统服务进程的 AMS 服务线程，其他PMS、WMS 的调试方法跟 AMS 一样。并且我也讲解了如何调试一个应用里面的TextView 控件，其他的比如 Button、ImageView 调试方法跟 TextView也是一样的。通过今天的学习，我希望能够给你一个学习系统框架最便捷的路径。在解决系统问题的时候，你可以方便的使用调试分析，从而快速定位、修复问题。![](Images/0e5461ae1393aa633b672fbee779c7e1.png){savepage-src="https://static001.geekbang.org/resource/image/bf/f1/bf8fdc35ddccb10b1161d8ca7eb8f8f1.jpg"}