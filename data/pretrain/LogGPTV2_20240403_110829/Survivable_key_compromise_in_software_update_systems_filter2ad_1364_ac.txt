3. If timestamp.txt indicates that release.txt has
changed, TUF downloads and veri(cid:12)es release.txt.
4. TUF determines which metadata (cid:12)les listed in re-
lease.txt di(cid:11)er from those described in the last re-
lease.txt that TUF has seen. In the case where no
optional metadata (cid:12)les are in use, only root.txt and
targets.txt are listed. If root.txt has changed, the
update process starts over using the new root.txt.
5. TUF provides the software update system with a list
of available (cid:12)les according to targets.txt.
6. The software update system instructs TUF to down-
load a speci(cid:12)c target (cid:12)le.
7. TUF downloads and veri(cid:12)es the (cid:12)le and then makes
the (cid:12)le available to the software update system.
8. The software update system installs the update.
7.2 Signed Metadata Format
All metadata (cid:12)les in TUF use canonical JSON [10] for-
mat2 and are enclosed in the signature structure:
{ "signed" : X,
"signatures" : [
{ "keyid" : K,
"method" : M,
"sig" : S }
, ... ]
}
where X is the signed object, K is the identi(cid:12)er of the key
that created the signature, M is the method used to make
the signature, and S is a signature of the canonical encoding
of X. An example key format is:
{ "keytype" : "rsa",
"keyval" : { "e" : E,
"n" : N }
}
The signed data of each (cid:12)le contains a creation timestamp
and an expiration date. These are the CREATIONTIME
and EXPIRES values shown in Table 4.
2The speci(cid:12)c (cid:12)le format used is not itself important as long
as the format is su(cid:14)ciently expressive and the data can be
represented in a canonical form for signing and signature
veri(cid:12)cation purposes.
7.3 Roles and Responsibilities
We use a root role that is responsible for delegating to
other roles their responsibility for each type of information.
These other top-level roles are the targets role, release role,
and timestamp role as shown in Figure 1.
Root role. The root role is the root of trust for the en-
tire repository. The root role signs the root.txt metadata
(cid:12)le (Table 4). This (cid:12)le indicates which keys are authorized
for each of the top-level roles, including for the root role it-
self. The roles \root", \release", \timestamp", and \targets"
must be speci(cid:12)ed and each has a list of KEYIDs. The sig-
natures of these keys are trusted to sign on behalf of the
corresponding role. The signature threshold for each role is
the value THRESHOLD. The corresponding public key for
each KEYID is speci(cid:12)ed in the \keys" object.
The keys belonging to the root role are intended to be
very well protected and used with the least frequency of any
keys in the framework.
Targets role. Through the targets.txt (cid:12)le, the targets
role is responsible for indicating which target (cid:12)les are avail-
able from the repository. More precisely, the targets role
shares the responsibility of providing information about the
content of updates. The two roles it shares this responsibil-
ity with are the release role and the timestamp role. This
sharing is a result of the release and timestamp roles need-
ing to indicate the latest version of targets.txt in their
metadata (cid:12)les (indirectly in the case of the timestamp role),
as shown in Figure 1. Depending on whether the release
and timestamp roles are used in an automated fashion, the
targets role may have essentially full responsibility for the
content of updates. The automated use of roles will be dis-
cussed in Section 8.
In the format of targets.txt shown in Table 4, each key
of the TARGETS object is a TARGETPATH. A TARGET-
PATH is a path that is relative to a mirror’s location of
target (cid:12)les. Each element of HASHES is the name of a hash
algorithm and the corresponding value is the hex encoded
digest of the (cid:12)le’s contents. LENGTH is the size, in bytes,
of the target (cid:12)le.
If de(cid:12)ned, the information in \custom"
will be made available to the code using the framework; this
optional data can be used to indicate additional information
such as a (cid:12)le’s version number.
The targets role may delegate to other roles the responsi-
bility for providing some or all target (cid:12)les. These delegated
target roles are speci(cid:12)ed in the \delegations" object. The
target paths that a delegated role is given responsibility to
provide are speci(cid:12)ed.
Delegated targets roles (optional). If the top-level targets
role performs delegation, the resulting delegated roles can
then provide their own metadata (cid:12)les. If a delegated role is
named foo, then foo’s metadata (cid:12)le is available on the repos-
itory as targets/foo.txt. The format of the metadata (cid:12)les
provided by delegated targets roles is the same as that of
targets.txt. Delegated targets roles may also further dele-
gate. As with targets.txt, the latest versions of metadata
(cid:12)les belonging to delegated targets roles are described in the
release role’s metadata.
Release role. The release role is responsible for ensur-
ing that clients see a consistent repository state. It provides
repository state information by indicating the latest versions
of all metadata (cid:12)les on the repository in release.txt (Ta-
ble 4), which it signs. The only metadata (cid:12)le not listed in
67{"_type" : "Root",
"ts" : CREATIONTIME,
"expires" : EXPIRES,
"keys" : {
KEYID : KEY
, ... },
"roles" : {
ROLE : {
"keyids" : [ KEYID, ... ] ,
"threshold" : THRESHOLD }
, ... }}
{"_type" : "Targets",
"ts" : CREATIONTIME,
"expires" : EXPIRES,
"targets" : {
TARGETPATH : {
"length" : LENGTH,
"hashes" : HASHES,
("custom" : { ... }) }
, ... },
("delegations" : {
"keys" : {
KEYID : KEY,
... },
"roles" : {
ROLE : {
{"_type" : "Timestamp|Release",
"ts" : CREATIONTIME,
"expires" : EXPIRES,
"meta" : {
METAPATH : {
"length" : LENGTH,
"hashes" : HASHES }
, ... }}
"keyids" : [ KEYID, ... ] ,
"threshold" : THRESHOLD,
"paths" : [ PATHPATTERN, ... ] }
, ... }})}
root.txt
targets.txt
timestamp.txt / release.txt
Table 4: Metadata formats. Each is wrapped in the signature structure described in Section 7.2.
release.txt is timestamp.txt, discussed below, which is
always created after release.txt.
Timestamp role. The timestamp role is responsible for
providing information about the timeliness of available
updates. Timeliness information is made available by fre-
quently signing a new timestamp.txt (cid:12)le that has a short
expiration time. This (cid:12)le indicates the latest version of
release.txt. The format of timestamp.txt is the same as
the format of release.txt. As the timestamp role needs
to frequently sign a (cid:12)le, it lends itself to automated usage
with a single key that is potentially kept on a public-facing
server. By placing only this one responsibility in a role
that has a high likelihood of compromise, we minimize the
resulting risk.
7.4 Key Compromise Analysis
We now consider the ability of this design to survive the
compromise of one or more roles. The summary of this anal-
ysis is shown in Table 5. Based on this analysis, we will
discuss recommendations for signature thresholds for these
roles in Section 8.
In the following analysis of key compromise, one can often
consider the timestamp role and possibly the release role as
not being major obstacles for attackers. That is, they do
present obstacles to attackers, but some projects may choose
to use these roles in an automated fashion and store their
keys less securely.
Root role compromise. If less than the required thresh-
old of root keys is compromised, clients are not at any risk.
The compromised root keys can be replaced through a new
root.txt (cid:12)le.
If more than the required threshold of keys belonging to
the root role is compromised, an attacker who can respond
to client requests can compromise clients. An attacker would
sign a new root.txt that lists their own keys as the keys
belonging to the other roles and provide all of their own
signed metadata to clients.
Targets role compromise.
If a threshold of targets
role keys are compromised, there is no immediate threat to
clients. The attacker cannot cause clients to install mali-
cious software unless the timestamp and release roles are
also compromised. That is, due to the shared responsibility
between these roles for providing update content, all three
roles need to be compromised.
If less than a threshold of targets role keys are compro-
mised and the compromise is noticed, these keys can be se-
curely and reliably revoked by having the root role sign a
new root.txt (cid:12)le that does not list the compromised keys.
The keys of the targets role can also be regularly changed
using this same method to proactively defend against un-
known key compromises.
Delegated targets role compromise. If delegated tar-
gets roles are used, they have essentially the same risk prop-
erties as the top-level targets role. The di(cid:11)erences are that:
(cid:15) It may be the case that a compromised delegated tar-
gets role is only responsible for a subset of the targets
available from the repository. Thus, the role’s com-
promise may result in only a subset of clients (e.g.
those on a speci(cid:12)c operating system) being at risk if
the timestamp and release roles are also compromised.
(cid:15) In addition to revocation by the delegating role, the
compromised keys can also be indirectly revoked by
any other role in the delegation chain. Indirect revo-
cation occurs when a delegating role has itself been
revoked. As a result, all delegations it performed are
revoked.
Release role compromise. If a threshold of release role
keys is compromised, there is no immediate risk of com-
promise or even of attacks on the consistency of repository
contents. An attacker must additionally compromise the
timestamp role in order to perform metadata inconsistency
attacks. Revocation of compromised keys is done through
the root.txt (cid:12)le.
68Role
Compromise
Malicious
Updates
Freeze
Attack
Timestamp
no
Release
Timestamp
+ Release
Targets
Timestamp
+ Targets
Release
+ Targets
Timestamp
+ Release
+ Targets
Root
no
no
no
no
no
yes
yes
Metadata
Inconsistency
Attack
no
no
yes
no
no
no
by
and
limited
by
Rel., Targ.,
and Root
no
limited
Targ.
Root
no
limited
by
Rel.,
Targ.*, and
Root
no
limited
Root
by
yes
yes
yes
Table 5: Vulnerabilities when roles are compromised
in TUF. The duration of freeze attacks is bounded
by the expiration times of metadata signed by un-
compromised roles. *Without the release role com-
promised, the attacker cannot provide their own tar-
gets role metadata.
Timestamp role compromise. The compromise of the
timestamp role allows freeze attacks on clients. Once the
compromise is detected, the duration of freeze attacks is
bounded by the earliest expiration time of any of the meta-
data (cid:12)les. As with the other top-level roles, revocation of
timestamp keys is done through the root.txt (cid:12)le.
to a single repository, PyPI, and end-users run a library
management and update utility, easy install, to download
and install new and updated libraries from PyPI. There is
currently no security in the update discovery and installation
process.
Our prototype integration [55] with PyPI and easy install
makes heavy use of targets delegation and clearly bene(cid:12)ts
from the existence of the release role. In this system, PyPI
owns the root keys and keeps the keys for all top-level roles.
PyPI delegates to each developer a targets role that is only
trusted to provide the individual libraries maintained by
that developer. The developer can provide any version of
these libraries, but is not trusted to provide other libraries.
There are over 8000 libraries on PyPI. Our integration uses a
separate delegated role for each of these libraries. As a result
of the large number of delegated targets roles, the release (cid:12)le
is approximately 1.5MB in size due to listing the hashes and
lengths of each metadata (cid:12)le. The release (cid:12)le changes every
time a developer adds a new version of a library. As a result,
it will be frequently downloaded by clients. We implemented
gzip compression of the release (cid:12)le, which brought its size
down to 460KB. This is similar to the size of the initial meta-
data that the insecure easy install downloads on each run,
which is 446KB. Another option would be to add support
for retrieving deltas (di(cid:11)s) of large metadata (cid:12)les.
Developers create and sign metadata on their own systems
before uploading this metadata and the packaged libraries
to PyPI. Developers have the option of using thresholds and
delegating further. With respect to PyPI’s developer key
management, we envision a system where developers use a
secure web interface to upload their public keys to PyPI.
PyPI may choose to enforce additional security measures
to ensure requested key changes are legitimate and not the
result of compromised account credentials.
8. EXPERIENCE AND DISCUSSION
8.2 Recommendations
In this section, we discuss our preliminary experiences
with TUF. We also discuss recommendations and best prac-
tices that balance the security bene(cid:12)ts of multiple roles and
keys with the practical needs of organizations. Speci(cid:12)cally,
we consider organizations with limited ability to store many
keys securely and independently.
8.1 Integration Experience
We have done prototype integrations of TUF with two
very di(cid:11)erent software update systems. The (cid:12)rst is the
application updater for Seattle [50], an application run-
ning on end-user machines that allows the safe execution
of untrusted code. The second is with PyPI [45] and
easy install
[20], the community repository and library
management system for Python.
Seattle’s application updater is quite simple. It needs to
identify all (cid:12)les for which new versions exist as well as (cid:12)les
that did not previously exist, download these (cid:12)les, save them
to the application’s installation directory, and restart any
processes that are a(cid:11)ected by the changed (cid:12)les. TUF was
integrated such that once all available (cid:12)les were successfully
downloaded and veri(cid:12)ed, the existing application updater is
then given access to these (cid:12)les. The rest of the application
updater’s functionality did not need to be modi(cid:12)ed.
Python’s library management system provides a way for
many mutually distrustful library developers to make their
libraries available to users. Developers upload their libraries
Number of keys. Given the existence of the root role
and three other required top-level roles in our design, many
keys may need to be managed. It is important for keys to
be stored independently|that is, on separate systems and
encrypted with di(cid:11)erent passwords. If too many keys need to
be managed by a small organization, it is likely that many
keys would be stored together and thus have the security
properties of a single key.
The (cid:12)rst consideration is that the timestamp role poses
little immediate risk if compromised. It will also often be