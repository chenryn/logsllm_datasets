，这是lmplementation-defined的。对于x86平台
，编译器可以利用这一点做优化，
其它位依次左移两位。但要注意，
在一定的取值范围内，
，所以我加了个前提“在一定的
 两边操作数的类型不要求-
，如果左移的位数大于等
对负数也成立。
比如看到源代
 移动的位数
将一
一个整
当
---
## Page 248
3、对一个32位无符号整数做循环右移，
2、用位操作实现无符号整数的乘法运算，
1、统计一个无符号整数的二进制表示中1的个数，
习题请点评
3、将8~15位置1。
1.4.异或运算的一些特性 请点评
8）的值应该是Oxefdeadbe。
2、将8~15位清0。
这样也可以达到同样的效果：
如果要对一个整数中的某些位进行操作，
1.3.掩码 请点评
int n);。
1、取出8~15位。
（Mask）来表示。
“格式化IVIO函数”。
、
下面两行printf打印的结果有何不同？请读者比较分析一下。x转换说明的含义详见第2.9节
xorl %eax，eax。不管eax寄存器里的值原来是多少，
一个数和自己做异或的结果是0。
ab
unsigned
q
ab
unsigned
printf(
printf("
int 
 所谓循环右移就是把低位移出去的部分再补到高位上去，
a
（a
&
&mask)
 mask; 
"%x\n"
oxcffffff3;
~mask;
比如掩码0x0000ff00表示对一个32位整数的8~15位进行操作，举例如下。
/* 0x1234ff78 */
i>>2);
 Oxcffffff3>>2);
/* 0x12340078 */
 b， mask = 0x0000ff00;
/￥ 9S000000x0 ￥/ ‘8b) ?a:b;
return 表达式3;
return 表达式2;
而--i等价于i-= 1。
自减运算符时说++i相当于=i＋1，其实更准确地说应该是等价于i
，如果foo（）函数调用有Side Effect，比如会打印一条消息，那么前者
，但对于有Side Effect的表达式则不一定，
 因此它的值必须是标量类型，而表达式2和3相当于同一个函
全国嵌入式人才培训基地
第16 章运算符详解
2.其它运算符
，求值一次和求值两次的效率是不同的，例如a[i+j]
，可以把它想像成这样的函数：
一个三目运算符（Ternary Operator）
一点细微的差别,
，根据组合规则可以写出表达式1，表达式2，
，前者对表达式a只求值一次,
表达式2，
两个表达式
250
带
一边做
下一
贝
---
## Page 251
掉了，结果可能是错的。
如果在一种ILP32平台上定义size_t代表unsigned long long型，这段代码把y赋给x时就把高位截
把size_t类型和它所代表的真实类型混用，例如：
long型，C标准规定size_t这个名字就是为了隐藏这些细节，使代码具有可移植性。所以注意不要
sizeof运算符的结果是size_t类型的，
a/sizeof a[0]替换成常量12了，这是一个常量表达式。
实上在编译时就知道sizeof a的值是48，
在上面这个例子中，由于sizeof表达式中的子表达式不需要求值，所以不需要到运行时才计算，事
比如用sizeof运算符求一个数组的长度：
sizeof是一个很特殊的运算符，
2.4.sizeof运算符与typedef类型声明请点评
那么size_t就代表unsigned long型。不同平台的编译器可能会根据自己平台的具体情况定
必须写的，整个表达式的值也是这种类型所占的字节数。
后把这种类型所占的字节数作为整个表达式的值。有些人喜欢写成"sizeof(表达式)"的形式也可以
特殊，
传给函数r的参数有三个，其中第二个参数的值是表达式t+2的值。
使用逗号运算符：
注意,
表达式的值成为整个表达式的值。
式3的值作为这个更大的表达式的值，依此类推，整个计算过程就是从左到右依次求值，最后一
求表达式2的值作为这个子表达式的值，然后这个值再和表达式3组成一个更大的表达式，求表达
表达式3，
，“sizeof表达式"中的子表达式并不求值，
 函数调用时各实参之间也是用逗号隔开，这种逗号是分隔符而不是逗号运算符。但可以这样
x
typedef unsigned long size_t;
f(a;
··
yi
(t=3，t+2)，c)
7
表达式n这种形式，
，它有两种形式：“sizeof 表达式"和“sizeof(类型名)”。这个运算符很
一样，
表达式1，
这个类型定义在stddef.h头文件中，
不起任何作用。但另外一种形式"sizeof(类型名)"的括号则是
，sizeof a[oj的值是4，所以在编译时就已经把sizeof
表达式2可以看作一个子表达式，
，比如像上面的例子就不用包含这个头文件。C标准
，而只是根据类型转换规则求得子表达式的类型，
有的平台定义为unsigned long 
先求表达式1的值，然后
 不过你的代码中只要不
-------..------.----..
251
---
## Page 252
这相当于声明char a[10];。类型名也遵循标识符的命名规则，并且通常加个_t后缀表示Type。
long，那么加上typedef之后，size_t就是一个类型名，就代表unsigned long类型。再举个例子:
1.位运算
上一页
全国嵌入式人才培训基地
起始页
上一级
3. Side Effect与Sequence Point
252
D
---
## Page 253
其实可以写得更简单（类似于[K&R]的简洁风格）：
能被求值，也可能不被求值。比如例8.5“剪刀石头布"这个程序中的这几句：
逻辑与和逻辑或早在第3节“布尔代数"就讲了，
号运算符也是这样，表达式1求值结束才继续求表达式2的值。
2、条件运算符?:、逗号运算符、逻辑与&&、
Effect哪个先发生哪个后发生则没有规定，编译器可以任意选择各SideEffect的作用顺序。
Effect，如果一个表达式中隐含着多个Side Effect，究竟哪个先发生哪个后发生呢？C标准规定代
我们知道，调用一个函数可能产生Side Effect，使用某些运算符（++--=复合赋值）也会产生Side
据我了解，似乎很多公司都有出这种笔试题的恶趣味。答案应该是Undefined，我甚至有些怀疑出
是有人逼你去钻牛角尖儿。这是我们的学员在找工作笔试时碰到的问题：
3. Side Effect与Sequence Point 请点评
题。这两个运算符和条件运算符类似，
求表达式2还是表达式3的值，如果决定求表达式2的值，
Point。我们刚讲过条件运算符和逗号运算符，
这些Side Effect全部作用完之后才开始调用foo函数。
都求值完了才能做最后的函数调用,
1、调用一个函数时，
细解释各种Sequence Point。
作用完毕,
题人是否真的知道答案。
了Short-circuit比较实用,
如果你只想规规矩矩地写代码，
二
if （scanf("%d", &man）!= 1 ↓l man  2）{
int a=0;
(ret
在此之后的Side Effect必须一个都没发生。
(++a)+(++a)+(++a)+(++a);
return 1;
，在所有准备工作做完之后、函数调用开始之前是Sequence Point。比如调
下面我来解释为什么是Undefined。
其它写法都应该避免使用。
&man）;
，那么基本用不着看这一节。本节的内容基本上是钻牛角尖儿的，
 3. Side Effect与Sequence Point
所以f()和g()的Side Effect按什么顺序发生不一定，但必定在
，先求左操作数的值，
第16 章 运算符详解
全国嵌入式人才培训基地
、逻辑或l的第一个操作数求值之后是Sequence 
条件运算符要根据表达式1的值是否为真决定下一步
，但在初学阶段我一直回避它们的操作数求值顺序问
，但没办法,
，至于两个Sequence Point之间的多个Side 
，表达式3就不会被求值了，反之也一样，
然后根据这个值是否为真，右操作数可
，有时候不是你想钻牛角尖儿，而
下面详
下一页
尚
除
---
## Page 254
2.其它运算符
以这么写。
两个Sequence Point之间既要读一个变量的值又要改它的值，只有在读写顺序确定的情况下才可
写表达式应遵循的原则一：在两个Sequence Point之间,
的不同版本来编译也可能不同。
不确定。这行代码用不同平台的不同编译器来编译结果是不同的，甚至在同一平台上用同一编译器
知道在整个表达式求值结束时一定都发生了。
因为在这个表达式中有五个Side Effect都在改变a的值，
考[C99]的Annex C。
还有两种Sequence Point和某些C标准库函数的执行过程相关，此处从略，有兴趣的读者可参
返回时必然会结束掉一个完整的表达式。而事实上很多库函数是以宏定义的形式实现的（第2.1节
5、在库函数即将返回时是Sequence Point。这条规则似乎可以包含在上一条规则里面，
4、在一个完整的表达式末尾是Sequence Point，
3、在一个完整的声明末尾是Sequence Point，
i ＋1;就没有歧义呢？虽然也是等号左边改i的值，
左边改i的值,
有这一条原则还不够，
用Short-circuit特性简化代码。
b相当于"if a then b",
第
是假，不会再去求b的值；如果a的值是真，则下一步求b的值作为整个表达式的值。所以，
个I运算的左操作数为假，
果man〈o不成立，
值作为整个表达式的值，
值不等于1成立，Ⅱ运算有一个操作数为真则整个表达式为真,
这个控制表达式的求值顺序是：先求scanf（"%d"，
四个++a的Side Effect发生了没有，a的值被加过几次了，
一页
，等号右边读i的值,
return 1; 
printf("Invalid input!\n");
“而a丨丨b相当于“if not a then b"。这种特性称为Short-circuit，很多人喜欢利
例如a[i++”=i;的变量i只改变了
这时变量man的值正是scanf读上来的值，我们判断它是否在[0,2]之间，
 所以最后求右操作数man〉2的值作为整个表达式的值。
，到底是先改还是先读？这个读写顺序是不确定的。但为什么i=
全国嵌入式人才培训基地
第一
起始页
，所谓完整的声明是指这个声明不是另外一个声明的
上一级
，所谓完整的表达式是指这个表达式不是另外一个
，等号右边读i的值，
：这些Side Effect按什么顺序发生不一定，
，则读入的数保存在变量man中,
7一次，
同一个变量的值只允许被改变一次。
，这些都不确定，
但结果仍是Undefined，
，如果a的值是假则整个表达式的值
但你不读出i的值就没法计
 所以第二个++a的值也
也就是第二
4.运算符总结
并且返回值
因为等
因为函数
a&&
下一页
根本不
2
台
---
## Page 255
9、按位与&。左结合。
8、相等性运算符==和!=。左结合。
6、移位运算符>。左结合。
5、加+、减-运算符。左结合。
4、乘*、除I、模%运算符。这三个运算符是左结合的。
址*、正号+、负号-、按位取反～、逻辑非!。如果一个操作数前面有多个前缀，
结合"来说明了。和指针有关的运算符*&->也在这里列出来了，到第 23 章指针再详细解释。
Conversion。
>
到此为止，除了和指针相关的运算符还没讲之外，其它运算符都讲过了，是时候做一个总结了。
4.运算符总结 请点评
13、逻辑或ll。左结合。
12、逻辑与&&。左结合。
11、按位或l。左结合。
10、按位异或^。左结合。
7、关系运算符<>=。左结合。
到远的顺序 
人
而不是把.看成双目运算符。
是从左到右）依次计算,
级，
下面按优先级从高到低的顺序总结一下C语言的运算符，
运算符?:要求后两个操作数类型一致，这些运算符在计算之前都需要做Usual Arithmetic
、单目运算符,
上一页
后缀运算符,
，优先级最高。
，对于同一优先级的多个运算符按什么顺序计算也有说明,
（也就是从右到左）依次计算，比如!-a，先算-a，再求!。
包括前缀自增++、
包括数组取下标、函数调用()、结构体取成员""、指向结构体的指针取成员->、
、字符串和用()括号套起来的表达式是组成表达式的最基本单元，在运算中做操作
比如a.name++，先算a.name，再++，
前缀自减--、
第16 章运算符详解
全国嵌入式人才培训基地
4.运算符总结
sizeof、
，每一条所列的各运算符具有相同的优先
类型转换()
，这里的.name应该看成a的一个后缀，
，按照离操作数从近到远的顺序（也就
双目运算符就简单地用“左结合"或"右
，取地址运算&、指针间接寻
，按照离操作数从近
下一页
---
## Page 256
3. Side Effect与Sequence Point 
1、以下代码得到的sum是Oxfff，对吗？
习题 请点评
细节用优先级和结合性是表达不了的，
可以参考[C99]的Annex A.2,
双目运算符有意义，对于前缀、
[K&R]第2章也有这样一个列表，
16、逗号运算符。左结合。
值是右结合的。
15、赋值=和各种复合赋值（*=/==+=-=>=&=^=｜=）。在双目运算符中只有赋值和复合赋
馨
一页
unsigned
int 
i
int sum = 0;
16; i++)
+ 1U<<i;
其实语法规则并不是用优先级和结合性这两个概念来表述的，有一些
后缀和三目运算符我单独做了说明。C语言表达式的详细语法规则
但是对于结合性解释得不够清楚。
全国嵌入式人才培训基地
只有看C99才能了解完整的语法规则。
起始页
上一级