higher utility values and more working components per-
form much worse than configurations with low utility val-
ues. After examining the data, we realized that this is due to
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:30:39 UTC from IEEE Xplore.  Restrictions apply. 
i
)
s
d
n
o
c
e
s
(
e
m
T
y
r
e
v
i
l
e
D
r
e
g
n
e
s
s
a
P
e
g
a
r
e
v
A
Up-Peak Passenger Profiles
Up-Peak with Redundant First-Floor Buttons
7000
6000
5000
4000
3000
2000
1000
0
Working Dispatcher with
Broken First-Floor Buttons
Config ID #1
Config ID #69
0.00 0.10 0.20 0.30 0.40 0.50 0.60 0.70 0.80 0.90 1.00
Configuration Utility Values
i
)
s
d
n
o
c
e
s
(
e
m
T
y
r
e
v
i
l
e
D
r
e
g
n
e
s
s
a
P
e
g
a
r
e
v
A
7000
6000
5000
4000
3000
2000
Dispatcher Component failed;
These configurations use a default
simple dispatching algorithm
1000
Config ID #1
0
0.00
0.10
0.20
0.30
0.40
0.50
0.60
0.70
0.80
0.90
1.00
Configuration Utility Values
Config ID #69
Figure 5. Average elevator performance vs. model
utility for up-peak traffic profiles.
an unforseen interaction between the characteristics of the
up-peak traffic profiles and the alternative functionality
mechanisms implemented in the system. Since up-peak
traffic is characterized by 90% of the passengers arriving
on the first floor to use the elevator, the drive controller’s
default algorithm for visiting floors is actually better suited
for this traffic than the dispatcher’s normal algorithm, that
was optimized for two-way traffic.
The default drive controller starts at floor 1, stops at ev-
ery floor until it reaches the top floor, and then returns to the
first floor to repeat the process unless it receives an over-
ride destination from the dispatcher. For up-peak traffic,
this will be very efficient since most passengers arrive on
the first floor and exit on other floors. The dispatcher’s al-
gorithm will only perform reasonably well for up-peak traf-
fic if the first-floor hall call button is working.
If the
first-floor hall call button is broken, the dispatcher will visit
floor 1 periodically, but it will not process the first floor as
frequently as it should for maximum performance, given
that 90% of the passengers arrive there. All of the extreme
outlying points in Figure 5 were traced to configurations in
which the dispatcher was working but the first-floor hall
call button was not. We encountered similar discrepancies
with the down-peak passenger profiles, and traced them to
the first-floor car call button.
Our utility specification gave equal weights to the utility
contributions from all hall call buttons. Our experiments
indicate that the utility model was relatively accurate for the
general case of random two-way elevator traffic patterns,
but was less accurate for the down-peak and up-peak traffic
profiles. This was partially due to the fact that efficiently
processing the up-peak and down-peak passenger profiles
heavily depends on processing the first-floor button re-
quests. When the first-floor hall call and car call buttons
fail, the system’s performance is severely degraded, and
our utility model does not account for this. These tests indi-
cate that additional hardware redundancy should be added
Figure 6. Average elevator performance vs. model
utility for up-peak traffic profiles with redundant
first-floor buttons.
to these first-floor buttons since they are critical to system
performance for the up-peak and down-peak passenger
profiles. This result also indicates that a new system objec-
tive that specifies that up-peak and down-peak perfor-
mance should not be sacrificed to optimize two-way traffic
performance might be appropriate.
Figure 6 shows the results of experiments with redun-
dant first-floor buttons for the up-peak traffic profiles.
Once the first-floor buttons are removed from the possible
failure configurations, our model more closely matches the
performance of the elevator on the up-peak and down-peak
passenger profiles. Additionally the performance of nearly
all of the configurations significantly improves, as all of the
average passenger delivery times for all configurations are
less than 1,200 seconds, compared to the previous experi-
ments in which some configurations had average passenger
delivery times as bad as 6,000 seconds.
6. Conclusions
This paper introduces alternative functionality as a
mechanism for improving system dependability without re-
quiring dedicated backup redundancy. Alternative func-
tionality exploits the fact that some system functions that
provide different features may still satisfy the same primary
system objectives, although at different levels of service.
We view functional alternatives as a generalization of re-
dundancy mechanisms, with a focus on exploiting existing
functionality available in the system rather than adding
dedicated backup redundancy. Our system model identifies
subsystems that can represent functional alternatives and
enables analysis and evaluation of the architecture and im-
plemented functional alternatives for dependability im-
provements.
The experiments we performed on a simulated imple-
mentation of an elevator control system revealed that the
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:30:39 UTC from IEEE Xplore.  Restrictions apply. 
original elevator design could only tolerate failures in the
car position indicator and car lanterns without failing to de-
liver passengers. However, our elevator design with func-
tional alternatives could withstand a loss of up to 75% of
the system’s components and still provide service to all pas-
sengers, albeit at reduced performance. Every configura-
tion tested on the improved elevator delivered all
passengers in all tests, satisfying the elevator's primary ob-
jectives despite a loss of system functionality.
Additionally, when we compared experimental results
with our system utility model, we discovered that the
first-floor hall call and car call buttons will have a signifi-
cant
impact on system performance for up-peak and
down-peak traffic profiles. This led to our decision to in-
corporate redundant components in only these buttons for a
significant utility improvement for many component fail-
ure combinations. This indicates that our model and evalu-
ation techniques are useful as a tool for ensuring that a
system implementation provides the level dependability
expected from the architecture design.
We did not explicitly design failure recovery scenarios
for every possible combination of component failures in the
system, but rather built the individual software components
to take advantage of alternative functionality. The individ-
ual components were designed to ignore optional input
variables when they were not available and follow a default
behavior. This is a fundamentally different approach than
brute-force redundancy or explicitly designing fault toler-
ance for all possible failure combinations. Properties of the
software architecture such as the component interfaces and
the identification and partitioning of system functionality
into logical subsystems seem to be key to effectively imple-
menting functional alternatives. This case study demon-
strates the potential of functional alternatives for improving
dependability in distributed embedded system designs.
7. Acknowledgments
This work was supported in part by the General Motors
Collaborative Research Laboratory at Carnegie Mellon
University, the High Dependability Computing Program
from NASA Ames cooperative agreement NCC-2-1298,
the Pennsylvania Infrastructure Technology Alliance, and
Lucent Technologies.
8. References
[1] Avizienis, A., “The N-version approach to fault-tolerant
software,” IEEE Transactions on Software Engineering,
SE-11(12), December 1985, pp. 1491-1501.
[2] Bodson , M., Lehoczky, J., et al., “Control reconfiguration
in the presence of software failures,” Proceedings of the
32nd IEEE Conference on Decision and Control, San
Antonio, TX, USA, December 1993, pp. 2284-2289.
[3] Keeney, R.L., Raiffa, H., Decisions with Multiple
Objectives: Preference and Value Tradeoffs, John Wiley &
Sons, New York, 1976.
[4] Keeney, R.L., Value-Focused Thinking: A Path to Creative
Decisionmaking, Harvard University Press, Cambridge,
MA, 1992.
[5] Knight,
J.C., Sullivan, K.J., “On the Definition of
Survivability,” University of Virginia, Department of
Computer Science, Technical Report CS-TR-33-00, 2000.
[6] Knight, J.C., Strunk, E.A., Sullivan, K.J., “Towards a
Rigorous Definition of Information System Survivability,”
DISCEX 2003, Washington DC, April 2003.
[7] Meyer,
J.F., “On Evaluating the Performability of
Degradable Computing Systems,” The Eighth Annual
International Conference on Fault-Tolerant Computing
(FTCS-8), Toulouse, France, June 1978, pp. 44-49.
[8] Meyer,
J.F.,
Sanders, W.H.,
and
Construction of Performability Models,” Proceedings of
the Second International Workshop on Performability
Modeling of Computer and Communication Systems, Mont
Saint-Michel, France, June 1993.
“Specification
[9] Mittal, A., Manimaran, G., Murthy, C.S.R., “Integrated
Dynamic Scheduling of Hard and QoS Degradable
Real-Time Tasks in Multiprocessor Systems,” Proceedings
of
the Fifth International Conference on Real-Time
Computing Systems and Applications, Hiroshima, Japan,
October 1998, pp. 127-136.
[10] Nace, W.,
“Automatic Graceful Degradation
for
Distributed Embedded Systems,” Ph.D. dissertation, Dept.
of Electrical And Computer Engineering, Carnegie Mellon
University, May 2002.
[11] Patton, R. J., Chen, J., “Advances in Fault Diagnosis Using
Analytical Redundancy,” IEE Colloquium on Plant
Optimisation
Operations
Management and Control), London, UK, January 1993, pp.
6/1 - 6/12.
(Integrated
Profit
for
[12] Randell, B., “System Structure for Software Fault
Tolerance,” IEEE Transactions on Software Engineering,
vol. SE-1, No. 2, June 1975, pp. 220-232.
[13] Ramanathan, P., “Graceful Degradation in Real-Time
Control Applications Using (m, k)-firm Guarantee,” 27th
Annual
international Conferences on Fault-Tolerant
Computing, Seattle, WA, USA, June 1997, pp. 132-141.
[14] Rennels, D., “Fault-Tolerant Computing - Concepts and
Examples”, IEEE Transactions on Computers C-33, No.
12, December 1984, pp. 1116-1129.
[15] Shelton, C., Koopman, P., Nace, W., “A Framework for
Scalable Analysis and Design of System-wide Graceful
Degradation in Distributed Embedded Systems,” Eighth
on Object-oriented
IEEE International Workshop
2003),
Real-time Dependable
Systems
Guadalajara, Mexico, January 2003.
(WORDS
[16] Shelton, C., “Scalable Graceful Degradation for Distributed
Embedded Systems,” Ph.D. dissertation, Dept. of Electrical
And Computer Engineering, Carnegie Mellon University,
August 2003.
[17] Shelton, C., Koopman, P., “Using Architectural Properties
to Model
in
Architecting Dependable Systems, LNCS 2677, pp.
267-289, de Lemos, R. et al. (Eds.), Springer-Verlag,
Berlin, 2003.
and Measure Graceful Degradation,”
[18] Strakosch, G.R.,
ed., The Vertical Transportation
Handbook, Third Edition, John Wiley & Sons, Inc., New
York, 1998.
[19] Verissimo, P., Rodrigues, L., Distributed Systems for
System Architects, Kluwer Academic Publishers, Boston,
2001.
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:30:39 UTC from IEEE Xplore.  Restrictions apply.