      BPF_MOD   0x90
      BPF_XOR   0xa0
      BPF_MOV   0xb0  /* eBPF only: mov reg to reg */
      BPF_ARSH  0xc0  /* eBPF only: sign extending shift right */
      BPF_END   0xd0  /* eBPF only: endianness conversion */
当指令类型为`BPF_JMP or BPF_JMP32`，指令实际类型为以下之一，包括条件跳转和非条件跳转。
    BPF_JA    0x00  /* BPF_JMP only */
      BPF_JEQ   0x10
      BPF_JGT   0x20
      BPF_JGE   0x30
      BPF_JSET  0x40
      BPF_JNE   0x50  /* eBPF only: jump != */
      BPF_JSGT  0x60  /* eBPF only: signed '>' */
      BPF_JSGE  0x70  /* eBPF only: signed '>=' */
      BPF_CALL  0x80  /* eBPF BPF_JMP only: function call */
      BPF_EXIT  0x90  /* eBPF BPF_JMP only: function return */
      BPF_JLT   0xa0  /* eBPF only: unsigned 'len len > BPF_MAXINSNS)
            return -E2BIG;
        /* 'struct verifier_env' can be global, but since it's not small,
         * allocate/free it every time bpf_check() is called
         */
        env = kzalloc(sizeof(struct verifier_env), GFP_KERNEL);
        if (!env)
            return -ENOMEM;
        env->prog = *prog;
        /* grab the mutex to protect few globals used by verifier */
        mutex_lock(&bpf_verifier_lock);
        if (attr->log_level || attr->log_buf || attr->log_size) {
            /* user requested verbose verifier output
             * and supplied buffer to store the verification trace
             */
            log_level = attr->log_level;
            log_ubuf = (char __user *) (unsigned long) attr->log_buf;
            log_size = attr->log_size;
            log_len = 0;
            ret = -EINVAL;
            /* log_* values have to be sane */
            if (log_size  UINT_MAX >> 8 ||
                log_level == 0 || log_ubuf == NULL)
                goto free_env;
            ret = -ENOMEM;
            log_buf = vmalloc(log_size);
            if (!log_buf)
                goto free_env;
        } else {
            log_level = 0;
        }
        /* look for pseudo eBPF instructions that access map FDs and
     * replace them with actual map pointers
     */
        //将伪指令中操作map_fd的部分替换成map地址，注意这个地址是8字节的，因此在实现中用本指令的imm和下一条指令的2个4字节中存储了这个地址
        /* store map pointer inside BPF_LD_IMM64 instruction 
                insn[0].imm = (u32) (unsigned long) map;
                insn[1].imm = ((u64) (unsigned long) map) >> 32;
        */
        ret = replace_map_fd_with_map_ptr(env);
        if (ret explored_states = kcalloc(env->prog->len,
                           sizeof(struct verifier_state_list *),
                           GFP_USER);
        ret = -ENOMEM;
        if (!env->explored_states)
            goto skip_full_check;
        //控制流图检查死循环和不可能到达的跳转
        ret = check_cfg(env);
        if (ret allow_ptr_leaks = capable(CAP_SYS_ADMIN);
        //核心检查函数
        ret = do_check(env);
    skip_full_check:
        while (pop_stack(env, NULL) >= 0);
        free_states(env);
        if (ret == 0)
            /* program is valid, convert *(u32*)(ctx + off) accesses */
            ret = convert_ctx_accesses(env);
        if (log_level && log_len >= log_size - 1) {
            BUG_ON(log_len >= log_size);
            /* verifier log exceeded user supplied buffer */
            ret = -ENOSPC;
            /* fall through to return what was recorded */
        }
        /* copy verifier log back to user space including trailing zero */
        if (log_level && copy_to_user(log_ubuf, log_buf, log_len + 1) != 0) {
            ret = -EFAULT;
            goto free_log_buf;
        }
        if (ret == 0 && env->used_map_cnt) {
            /* if program passed verifier, update used_maps in bpf_prog_info */
            env->prog->aux->used_maps = kmalloc_array(env->used_map_cnt,
                                  sizeof(env->used_maps[0]),
                                  GFP_KERNEL);
            if (!env->prog->aux->used_maps) {
                ret = -ENOMEM;
                goto free_log_buf;
            }
            memcpy(env->prog->aux->used_maps, env->used_maps,
                   sizeof(env->used_maps[0]) * env->used_map_cnt);
            env->prog->aux->used_map_cnt = env->used_map_cnt;
            /* program is valid. Convert pseudo bpf_ld_imm64 into generic
             * bpf_ld_imm64 instructions
             */
            convert_pseudo_ld_imm64(env);
        }
    free_log_buf:
        if (log_level)
            vfree(log_buf);
    free_env:
        if (!env->prog->aux->used_maps)
            /* if we didn't copy map pointers into bpf_prog_info, release
             * them now. Otherwise free_bpf_prog_info() will release them.
             */
            release_maps(env);
        *prog = env->prog;
        kfree(env);
        mutex_unlock(&bpf_verifier_lock);
        return ret;
    }
在这个函数中调用了`do_check`根据不同的指令类型来做具体的合法性判断。使用的核心数据结构是`reg_state`，`bpf_reg_type`枚举变量用来表示寄存器的类型，初始化为`NOT_INIT`
    struct reg_state {
        enum bpf_reg_type type;
        union {
            /* valid when type == CONST_IMM | PTR_TO_STACK */
            int imm;
            /* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |
             *   PTR_TO_MAP_VALUE_OR_NULL
             */
            struct bpf_map *map_ptr;
        };
    };
    static void init_reg_state(struct reg_state *regs)
    {
        int i;
        for (i = 0; i cur_state;
        struct bpf_insn *insns = env->prog->insnsi;
        struct reg_state *regs = state->regs;
        int insn_cnt = env->prog->len;
        int insn_idx, prev_insn_idx = 0;
        int insn_processed = 0;
        bool do_print_state = false;
        init_reg_state(regs);
        insn_idx = 0;
        for (;;) {
            struct bpf_insn *insn;
            u8 class;
            int err;
            //指令条数检查
            if (insn_idx >= insn_cnt) {
                verbose("invalid insn idx %d insn_cnt %d\n",
                    insn_idx, insn_cnt);
                return -EFAULT;
            }
            insn = &insns[insn_idx];
            class = BPF_CLASS(insn->code);
            //运行过的次数上限检查
            if (++insn_processed > 32768) {
                verbose("BPF program is too large. Proccessed %d insn\n",
                    insn_processed);
                return -E2BIG;
            }
            //检测该指令有无visit，主要通过env->explored_states的状态数组保存访问过的指令的状态
            err = is_state_visited(env, insn_idx);
            if (err < 0)
                return err;
            if (err == 1) {
                /* found equivalent state, can prune the search */
                if (log_level) {
                    if (do_print_state)
                        verbose("\nfrom %d to %d: safe\n",
                            prev_insn_idx, insn_idx);
                    else
                        verbose("%d: safe\n", insn_idx);
                }
                goto process_bpf_exit;
            }
            if (log_level && do_print_state) {
                verbose("\nfrom %d to %d:", prev_insn_idx, insn_idx);
                print_verifier_state(env);
                do_print_state = false;
            }
            if (log_level) {
                verbose("%d: ", insn_idx);
                print_bpf_insn(env, insn);
            }
            //计算指令ALU
            if (class == BPF_ALU || class == BPF_ALU64) {
                //检查具体指令的合法性，比如是否使用了保留的field，使用的寄存器编号是否超过了模拟寄存器的最大编号，寄存器是否可读/写，寄存器值是否是指针等