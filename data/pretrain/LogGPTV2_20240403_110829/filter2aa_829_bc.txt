Certificate Issuer: Microsoft Windows Production PCA 2011
Certificate Thumbprint Algorithm: 0x0000800c
Certificate Thumbprint: a22f7e7385255df6c06954ef155b5a3f28c54eec85b6912aaaf4711f7676a073
[ElamProcessInitializeImage] The following boot start driver is about to be initialized:
[ElamProcessInitializeImage] Found a suspected malicious driver (\SystemRoot\system32\drivers\
mimidrv.sys). Marking its classification accordingly
[ElamProcessInitializeImage] The following boot start driver is about to be initialized:
Image name: \SystemRoot\system32\drivers\iorate.sys
Registry Path: \Registry\Machine\System\CurrentControlSet\Services\iorate
Image Hash Algorithm: 0x0000800c
Image Hash: 07478daeebc544a8664adb00704d71decbc61931f9a7112f9cc527497faf6566
Signer: Microsoft Windows
Certificate Issuer: Microsoft Windows Production PCA 2011
Certificate Thumbprint Algorithm: 0x0000800c
Certificate Thumbprint: 3cd79dfbdc76f39ab4855ddfaeff846f240810e8ec3c037146b88cb5052efc08
Listing 11-6: ELAM driver output showing the detection of Mimidrv
Evading EDR (Early Access) © 2023 by Matt Hand
208   Chapter 11
In this example, you can see that the ELAM driver allows other boot-
start drivers to load: the native Universal Naming Convention driver, 
mup.sys, and the Disk I/O Rate Filter driver, iorate.sys, both of which are 
signed by Microsoft. Between these two drivers, it detects Mimidrv using 
the file’s known cryptographic hash. Because it deems this driver to be 
malicious, it prevents Mimidrv from loading on the system before the oper-
ating system is fully initialized and without requiring any interaction from 
the user or other EDR components.
Loading an ELAM Driver
Before you can load your ELAM driver, you must complete a few prepara-
tory steps: signing the driver and assigning its load order.
Signing the Driver
The most headache-inducing part of deploying an ELAM driver, espe-
cially during development and testing, is ensuring that its digital sig-
nature meets Microsoft’s requirements for loading on the system. Even 
when operating in test-signing mode, the driver must have specific certifi-
cate attributes.
Microsoft publishes limited information about the process of test-sign-
ing an ELAM driver. In its demo, Microsoft says the following:
Early Launch drivers are required to be signed with a code-
signing certificate that also contains the Early Launch EKU 
“1.3.6.1.4.1.311.61.4.1” [. . .] and the “1.3.6.1.5.5.7.3.3” Code 
Signing EKU. Once a certificate of this form has been created, 
signtool.exe can be used to sign [the ELAM driver].
In test-signing scenarios, you can create a certificate with these EKUs 
by running makecert.exe, a utility that ships with the Windows SDK, in an ele-
vated command prompt. Listing 11-7 demonstrates the syntax for doing this.
PS > & 'C:\Program Files (x86)\Windows Kits\10\bin\10.0.19042.0\x64\makecert.exe'
>> -a SHA256 -r -pe
>> -ss PrivateCertStore
>> -n "CN=DevElamCert"
>> -sr localmachine
>> -eku 1.3.6.1.4.1.311.61.4.1,1.3.6.1.5.5.7.3.3
>> C:\Users\dev\Desktop\DevElamCert.cer
Listing 11-7: Generating a self-signed certificate
This tool supports a robust set of arguments, but only two are really 
relevant to ELAM. This first is the -eku option, which adds the Early Launch 
Antimalware Driver and Code Signing object identifiers to the certificate. The 
second is the path to which the certificate should be written.
When makecert.exe completes, you’ll find a new self-signed certificate 
written to the specified location. This certificate should have the necessary 
Evading EDR (Early Access) © 2023 by Matt Hand
Early Launch Antimalware Drivers   209
object identifiers, which you can validate by opening the certificate and 
viewing its details, as shown in Figure 11-3.
Figure 11-3: ELAM EKUs included in  
the certificate
Next, you can use signtool.exe, another tool from the Windows SDK, to 
sign the compiled ELAM driver. Listing 11-8 shows an example of doing 
this using the previously generated certificate.
PS > & 'C:\Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x64\signtool.exe'
>> sign
>> /fd SHA256
>> /a
>> /ph
>> /s "PrivateCertStore"
>> /n "MyElamCert"
>> /tr http://sha256timestamp.ws.symantec.com/sha256/timestamp
>> .\elamdriver.sys
Listing 11-8: Signing an ELAM driver with signtool.exe
Like makecert.exe, this tool supports a large set of arguments, some of 
which aren’t particularly important to ELAM. First, the /fd argument speci-
fies the file-digest algorithm to use for signing the certificate (SHA256 in 
our case). The /ph argument instructs signtool.exe to generate page hashes for 
executable files. Versions of Windows starting with Vista use these hashes to 
verify the signature of each page of the driver as it is loaded into memory. 
The /tr argument accepts the URL of a timestamp server that allows the 
certificate to be appropriately timestamped (see RFC 3161 for details about 
the Time-Stamp Protocol). Developers can use a number of publicly avail-
able servers to complete this task. Lastly, the tool accepts the file to sign (in 
our case, the ELAM driver).
Evading EDR (Early Access) © 2023 by Matt Hand
210   Chapter 11
Now we can inspect the driver’s properties to check whether it is signed 
with the self-signed certificate and a countersignature from the timestamp 
server, as shown in Figure 11-4.
Figure 11-4: A signed driver with the  
timestamp included
If so, you may deploy the driver to the system. As for most drivers, the 
system uses a service to facilitate the driver’s loading at the desired time. To 
function properly, the ELAM driver must load very early in the boot pro-
cess. This is where the concept of load-order grouping comes into play.
Setting the Load Order
When creating a boot-start service on Windows, the developer can specify 
when it should be loaded in the boot order. This is useful in cases when the 
driver depends on the availability of another service or otherwise needs to 
load at a specific time.
The developer can’t specify any arbitrary string for the load-order 
group, however. Microsoft keeps a list containing most of the groups 
available in the registry at HKLM:\SYSTEM\CurrentControlSet\Control\
ServiceGroupOrder, which you can retrieve easily, as shown in Listing 11-9.
PS> (Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\ServiceGroupOrder).List
System Reserved
EMS
WdfLoadGroup
Boot Bus Extender
System Bus Extender
SCSI miniport
Port
Primary Disk
SCSI Class
SCSI CDROM Class
Evading EDR (Early Access) © 2023 by Matt Hand
Early Launch Antimalware Drivers   211
FSFilter Infrastructure
FSFilter System
FSFilter Bottom
FSFilter Copy Protection
--snip--
Listing 11-9: Retrieving service-load-order groups from the registry with PowerShell
This command parses the values of the registry key containing the 
load-order group names and returns them as a list. At the time of this writ-
ing, the registry key contains 70 groups.
Microsoft instructs ELAM driver developers to use the Early-Launch 
load-order group, which is notably missing from the ServiceGroupOrder key. 
No other special loading requirements exist, and you can do it simply by 
using sc.exe or the advapi32!CreateService() Win32 API. For example,  
Listing 11-10 loads WdBoot, an ELAM service that ships with Windows 10 
and is used to load Defender’s boot-start driver of the same name.
PS C:\> Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\WdBoot |
>> select PSChildName, Group, ImagePath | fl
PSChildName : WdBoot
Group 
: Early-Launch
ImagePath 
: system32\drivers\wd\WdBoot.sys
Listing 11-10: Inspecting Defender’s WdBoot ELAM driver
This command collects the name of the service, its load-order group, 
and the path to the driver on the filesystem.
If you step inside the process of loading the ELAM drivers, you’ll find 
that it’s primarily the responsibility of the Windows bootloader, winload.
efi. The bootloader, a complex piece of software in its own right, performs 
a few actions. First, it searches the registry for all boot-start drivers on the 
system in the Early-Launch group and adds them to a list. Next, it loads core 
drivers, such as the System Guard Runtime Monitor (sgrmagent.sys) and 
the Security Events Component Minifilter (mssecflt.sys). Finally, it goes over 
its list of ELAM drivers, performing some integrity checking and eventu-
ally loading the drivers. Once the Early-Launch drivers are loaded, the boot 
process continues, and the ELAM vetting process described in “Developing 
ELAM Drivers” on page XX is executed.
N O T E 
This is an oversimplified description of the process of loading ELAM drivers. If you’re 
interested in learning more about it, check out “Understanding WdBoot,” a blog post 
by @n4r1b detailing how Windows loads essential drivers.
Evading ELAM Drivers
Because ELAM drivers mostly use static signatures and hashes to identify 
malicious boot-start drivers, you can evade them in the same way you’d 
Evading EDR (Early Access) © 2023 by Matt Hand
212   Chapter 11
evade user-mode file-based detections: by changing static indicators. 
Doing this for drivers is more difficult than doing it in user mode, however, 
because there are generally fewer viable drivers than user-mode executables 
to choose from. This is due in no small part to the driver signature enforce-
ment in modern versions of Windows.
Driver Signature Enforcement is a control implemented in Windows Vista 
and beyond that requires kernel-mode code (namely drivers) to be signed 
in order to load. Starting in build 1607, Windows 10 further requires that 
drivers be signed with an Extended Validation (EV) certificate and, option-
ally, a Windows Hardware Quality Labs (WHQL) signature if the developer 
would like the driver to load on Windows 10 S or have its updates distrib-
uted through Windows Update. Due to the complexity of these signing 
processes, attackers have a substantially harder time loading a rootkit on 
modern versions of Windows.
An attacker’s driver can serve a number of functions while operating 
under the requirements of driver signature enforcement. For example, the 
NetFilter rootkit, signed by Microsoft, passed all driver signature enforce-
ment checks and can load on modern Windows versions. Getting a rootkit 
signed by Microsoft isn’t the easiest process, however, and it’s impractical 
for many offensive teams.
If the attacker takes the Bring Your Own Vulnerable Driver (BYOVD) 
approach, their options open up. These are vulnerable drivers that the 
attacker loads onto the system, and they’re usually signed by legitimate 
software vendors. As they don’t contain any overtly malicious code, they are 
difficult to detect and rarely have their certificate revoked after their vul-
nerability is discovered. If this BYOVD component is loaded during boot, 
a user-mode component running later in the boot process could exploit 
the driver to load the operator’s rootkit using any number of techniques, 
depending on the nature of the vulnerability.
Another approach involves the deployment of firmware rootkits or 
bootkits. While this technique is exceedingly rare, it can effectively evade 
ELAM’s boot-start protections. For example, the ESPecter bootkit patched 
the Boot Manager (bootmgfw.efi), disabled driver signature enforcement, 
and dropped its driver, which was responsible for loading user-mode com-
ponents and performing keylogging. ESPecter was initialized as soon as the 
system loaded UEFI modules: so early in the boot process that ELAM driv-
ers had no ability to affect its presence.
While the specifics of implementing rootkits and bootkits are outside 
the scope of this book, they’re a fascinating topic for any of those interested 
in “apex” malware. Rootkits and Bootkits: Reversing Modern Malware and Next 
Generation Threats by Alex Matrosov, Eugene Rodionov, and Sergey Bratus is 
the most up-to-date resource on this topic at the time of this writing and is 
highly recommended as a complement to this section.
Thankfully, Microsoft continues to invest heavily in protecting the part of 
the boot process that occurs before ELAM has a chance to act. These protec-
tions fall under the Measured Boot umbrella, which validates the integrity of 
the boot process from UEFI firmware through ELAM. During the boot pro-
cess, Measured Boot produces cryptographic hashes, or measurements, of these 
Evading EDR (Early Access) © 2023 by Matt Hand
Early Launch Antimalware Drivers   213
boot components, along with other configuration data such as the status of 
BitLocker and Test Signing, and stores them in the TPM.
Once the system has completed booting, Windows uses the TPM to 
generate a cryptographically signed statement, or quote, used to confirm the 
validity of the system’s configuration. This quote is sent to an attestation 
authority, which authenticates the measurements, returns a determination 
of whether the system should be trusted, and optionally takes actions to 
remediate any issues. As Windows 11, which requires a TPM, becomes more 
widely adopted, this technology will become an important detective compo-
nent for system integrity inside enterprises.
The Unfortunate Reality
In the vast majority of situations, ELAM vendors don’t meet Microsoft’s rec-
ommendations. In 2021, Maxim Suhanov published a blog post, “Measured 
Boot and Malware Signatures: exploring two vulnerabilities found in the 
Windows loader,” wherein he compared 26 vendors’ ELAM drivers. He 
noted that only 10 used signatures at all; of these, only two used them to 
affect Measured Boot in the way intended by Microsoft. Instead, these ven-
dors use their ELAM drivers nearly exclusively to create protected processes 
and access the Microsoft-Windows-Threat-Intelligence ETW provider dis-
cussed in the next chapter.
Conclusion
ELAM drivers give an EDR insight into portions of the boot process previ-
ously unable to be monitored. This allows an EDR to detect, or potentially 
even stop, an attacker that can execute their code before the primary EDR 
agent even starts. Despite this seemingly massive benefit, almost no vendors 
make use of this technology and instead only use it for its auxiliary function: 
gaining access to the Microsoft-Windows-Threat-Intelligence ETW provider.
Evading EDR (Early Access) © 2023 by Matt Hand
Evading EDR (Early Access) © 2023 by Matt Hand
For years, Microsoft Defender for Endpoint 
(MDE) presented a huge challenge for 
offensive security practitioners because 
it could detect issues that all the other EDR 
vendors missed. One of the primary reasons for its 
effectiveness is its use of the Microsoft-Windows-Threat-
Intelligence (EtwTi) ETW provider. Today, developers 
who publish ELAM drivers use it to access some of the 
most powerful detection sources on Windows.
Despite its name, this ETW provider won’t provide you with attribution 
information. Rather, it reports on events that were previously unavailable 
to EDRs, like memory allocations, driver loads, and syscall policy violations 
to Win32k, the kernel component of the Graphics Device Interface. These 
events functionally replace the information EDR vendors gleaned from 
user-mode function hooking, which attackers can easily evade, as covered in 
Chapter 2.
12
M ICROSOF T-W IN DOW S -T H R E AT-
IN T E L L IG E NCE
Evading EDR (Early Access) © 2023 by Matt Hand
216   Chapter 12
Because events from this provider originate from the kernel, the pro-
vider is more difficult to evade, has greater coverage than user-mode alter-
natives, and is less risky than function hooking, as the provider is integrated 
into the operating system itself. Due to these factors, it is rare to encounter 
mature EDR vendors that don’t use it as a telemetry source.
This chapter covers how the EtwTi provider works, its detection sources, 
the types of events it emits, and how attackers may evade detection.
Reverse Engineering the Provider
Before we cover the types of events emitted by the EtwTi provider, 
you should understand how it gets the information in the first place. 
Unfortunately, Microsoft provides no public documentation about the pro-
vider’s internals, so discovering this is largely a manual effort.
As a case study, this section covers one example of EtwTi’s source: what 
happens when a developer changes the protection level of a memory allocation 
to mark it as executable. Malware developers frequently use this technique; 
they’ll first write shellcode to an allocation marked with read-write (RW) per-
missions and then change these to read-execute (RX) through an API such 
as kernel32!VirtualProtect() before they execute the shellcode.
When the malware developer calls this API, execution eventually flows 
down to the syscall for ntdll!NtProtectVirtualMemory(). Execution is transferred 
into the kernel, where some safety checks and validations occur. Then, 
nt!MmProtectVirtualMemory() is called to change the protection level on the allo-
cation. This is all pretty standard, and it would be reasonable to assume that 
nt!NtProtectVirtualMemory() would clean up and return at this point. However, 
one last conditional block of code in the kernel, shown in Listing 12-1, calls 
nt!EtwTiLogProtectExecVm() if the protection change succeeded.
if ((-1 < (int)status) &&
 (status = protectionMask, ProtectionMask = MiMakeProtectionMask(protectionMask),
 ((uVar2 | ProtectionMask) & 2) != 0)) {
puStack_c0 = (ulonglong*)((ulonglong)puStack_c0 & 0xffffffff00000000 | (ulonglong)status);
OldProtection = param_4;
EtwTiLogProtectExecVm(TargetProcess,AccessMode,BaseAddress,NumberOfBytes);
}
Listing 12-1: The EtwTi function called inside nt!NtProtectVirtualMemory()
The name of this function implies that it is responsible for logging pro-
tection changes for executable regions of memory.
Checking That the Provider and Event Are Enabled
Within the function is a call to nt!EtwProviderEnabled(), which is defined in 
Listing 12-2. It verifies that a given ETW provider is enabled on the system.
BOOLEAN EtwProviderEnabled(
 REGHANDLE RegHandle,
Evading EDR (Early Access) © 2023 by Matt Hand
Microsoft-Windows-Threat-Intelligence   217
 UCHAR 
Level,
 ULONGLONG Keyword
);
Listing 12-2: The nt!EtwProviderEnabled() definition
The most interesting part of this function is the RegHandle parameter, 
which is the global EtwThreatIntProvRegHandle, in the case of this provider. 
This handle is referenced in every EtwTi function, meaning we can use it 
to find other functions of interest. If we examine the cross-reference to the 
global ETW provider handle, as shown in Figure 12-1, we can see 31 other 
references made to it, most of which are other EtwTi functions.
Figure 12-1: Cross-references to ThreatIntProviderGuid
One of the cross-references originates from nt!EtwpInitialize(), a func-
tion called during the boot process that, among other things, is responsible 
for registering system ETW providers. To do this, it calls the nt!EtwRegister() 
function. The signature for this function is shown in Listing 12-3.
NTSTATUS EtwRegister(
 LPCGUID 
ProviderId,
 PETWENABLECALLBACK EnableCallback,
 PVOID 
CallbackContext,
 PREGHANDLE 
RegHandle
);
Listing 12-3: The nt!EtwRegister() definition
This function is called during the boot process with a pointer to a 
GUID named ThreatIntProviderGuid, shown in Listing 12-4.
EtwRegister(&ThreatIntProviderGuid,0,0,&EtwThreatIntProvRegHandle);
Listing 12-4: Registering ThreatIntProviderGuid
The GUID pointed to is in the .data section, shown in Figure 12-2 as 
f4e1897c-bb5d-5668-f1d8-040f4d8dd344.
Figure 12-2: The GUID pointed to by ThreatIntProviderGuid
Evading EDR (Early Access) © 2023 by Matt Hand
218   Chapter 12
If the provider is enabled, the system checks the event descriptor to 
determine if the specific event is enabled for the provider. This check is per-
formed by the nt!EtwEventEnabled() function, which takes the provider handle 