# The difference between Volatility2 and Volatility3
Volatility2 下的 profile 制作过程就不写了，提一句，vol2建议用`CentOS 7`来制作相应文件，不然在其他 Linux
系统（例如Ubuntu），解决软件依赖性得修好长时间（哭~~）
Volatility2：
## Profile
Profile是特定操作系统版本以及硬件体系结构（x86、x64、ARM）中`VTypes`、共用体、对象类型的集合。
> Vtypes 是 Volatility 框架中数据结构定义以及解析的语言，大部分操作系统底层都是使用 C
> 语言编写的，其中大量使用数据结构来组织和管理相关的变量以及属性。
>
> 因为 Volatility 是用 Python 语言编写的，所以我们需要一种方式在Python 源文件中表示 C 语言的数据结构。
>
> VTypes 正是用于实现这一点的。
除了这些组件以外，`Profile` 还包括如下:
  * 元数据：操作系统的名称(例如:“windows”,“mac”,“linux”)，内核版本，以及编译号。
  * 系统调用信息：索引以及系统调用的名称。
  * 常量值：全局变量-在某些操作系统中能够在硬编码的地址处找到的全局变量
  * 系统映射：关键全局变量和函数的地址（仅限 Linux 和 Mac）
但在 Volatility3
中，不再使用配置文件`Profile`，取而代之，vol3自身带有一个扩展的符号表库`Symbols`，并且对于大多数Windows内存镜像，可以基于内存映像本身来生成新的符号表。它允许符号表包含基于该操作系统位置（符号位置）的特定偏移量。
也就是说利用官方调试信息提供的那些结构的已知偏移量，可以更轻松、更快速地识别操作系统中的结构。
## Symbol Tables
用于分析相关操作系统数据的内核符号表压缩包，其所有文件以JSON数据格式存储，可以是纯json文件`.json`，也可以是`.json.gz`或者`.json.xz`，Volatility3在使用它们时会自动解压。此外，Vol3会在用户主目录下的`.cache/volatility3`目录下会缓存他们的压缩内容，当前还无法更改这个缓存目录。
Vol3的symbol tables分为两类，上面的`Windows Symbol
tables`作为一类，由于对Mac和Linux采用相同的识别机制，统分为另外一类。
### Windows
对于WIndows系统，符号表字符串由所需`PDB`文件的`GUID`和`Age`组成，Volatility会搜索windows子目录下配置的所有文件，并与包含`pdb`名称，`GUID`/`Age`（或者其他压缩形式）的所有元数据进行匹配、利用。如果找不到的话，会从
Microsoft 官方的符号表服务器下载相关的`PDB`文件，并自动转化成适当的`JSON`格式，并存储在合适的位置。
可以从适当的 PDB 文件手动构建 Windows 符号表，而执行此操作的主要工具已经内置在 Volatility3了：`pdbconv.py`。
该文件支持从`Volatility3`的根路径运行，命令如下：
    ┌──(kali㉿kali)-[~]
    └─$ python3 ./volatility3/framework/symbols/windows/pdbconv.py
Volatility官方也已经给出了Windows符号表：[Volatility3官方：Windows符号表下载](https://downloads.volatilityfoundation.org/volatility3/symbols/windows.zip)
### Linux/Mac
[Volatility3官方：Mac符号表下载](https://downloads.volatilityfoundation.org/volatility3/symbols/mac.zip)
对于 Mac，它只有特定数量的内核，但我们不会经常更新包，因为它有点耗时。
[Volitility3官方：Linux符号表（不全）](https://downloads.volatilityfoundation.org/volatility3/symbols/linux.zip)
[dwarf2json](https://github.com/volatilityfoundation/dwarf2json) 可以从
`DWARF`文件生成 Linux 和 Mac 符号表。而当前，利用内核中包含的调试符号表，是大多数Volatility3插件恢复信息的唯一合适方法。
值得注意的是，只有`-- elf`的方案在 vol3 中可行,其他使用如`Sysmap` 解析出来的 json
都是不可行的。(在vol2中生成profile会用到 Sysmap )
    ./dwarf2json linux --elf /usr/lib/debug/boot/vmlinux-4.4.0-137-generic > output.json
此外，为什么上面说Linux符号表信息不全呢？因为Linux内核易于编译且唯一，无法区分它们，因此官方提供的Linux符号表并不详尽，因此在面对Linux内存取证时，要自行生成符号表；并且，标准内核是被剥离了调试信息的，若想获取带有调试信息的，则需从文件中单独获取。
# LiME：Linux Memory Extractor
LiME是Linux可加载内核模块（LKM）Linux的内存提取器，它允许从Linux或者基于Linux的设备（如：Android）获取临时性内存（RAM）。LiME成为第一个允许在Android设备上捕获完整内存的工具，并且最大限度地减少了在获取过程中用户和内核空间进程之间的交互，因此LiME能生成比其他工具更可靠的内存捕获。
[基于LiME工具的Android手机动态内存提取](http://xsjs-cifs.com/article/2015/1008-3650-40-6-431.html)
[CentOS 5.5编译LiME](https://xz.aliyun.com/t/2346)
## 编译LiME
    [root@localhost CentOS]# tar -zxvf LiME.tar.gz
    [root@localhost CentOS]# cd /home/yunwei/Desktop/malware/LiME/src/
    [root@localhost src]# make
    make -C /lib/modules/2.6.18-194.el5/build M="/home/yunwei/Desktop/malware/LiME/src" modules
    make[1]: Entering directory `/usr/src/kernels/2.6.18-194.el5-x86_64'
      Building modules, stage 2.
      MODPOST
      LD [M]  /home/yunwei/Desktop/malware/LiME/src/lime.ko
    make[1]: Leaving directory `/usr/src/kernels/2.6.18-194.el5-x86_64'
    strip --strip-unneeded lime.ko
    mv lime.ko lime-2.6.18-194.el5.ko
    [root@localhost src]# ll
    total 1176
    -rw-r--r-- 1 root root   2557 Sep 28  2017 disk.c
    -rw-r--r-- 1 root root 168240 May 20 10:44 disk.o
    -rw-r--r-- 1 root root  41984 May 20 11:46 lime-2.6.18-194.el5.ko
    -rw-r--r-- 1 root root   1920 Sep 28  2017 lime.h
    -rw-r--r-- 1 root root   1151 May 20 10:44 lime.mod.c
    -rw-r--r-- 1 root root  81632 May 20 10:44 lime.mod.o
    -rw-r--r-- 1 root root 505173 May 20 10:44 lime.o
    -rw-r--r-- 1 root root   6614 Sep 28  2017 main.c
    -rw-r--r-- 1 root root 175408 May 20 10:44 main.o
    -rw-r--r-- 1 root root   1661 Sep 28  2017 Makefile
    -rw-r--r-- 1 root root   1722 Sep 28  2017 Makefile.sample
    -rw-r--r-- 1 root root      0 May 20 10:44 Module.markers
    -rw-r--r-- 1 root root      0 May 20 10:44 Module.symvers
    -rw-r--r-- 1 root root   3889 Sep 28  2017 tcp.c
    -rw-r--r-- 1 root root 166152 May 20 10:44 tcp.o
## 抓取内存
`/home/centos/Desktop/forensic/centos5.lime`为自定义路径
    ## 进入内核模式抓取内存
    [root@localhost src]# insmod lime-`uname -r`.ko path=/home/yunwei/Desktop/malware/centos5.lime format=lime
    ## 再次抓取内存前要先运行以下命令退出内核模式
    [root@localhost src]# rmmod lime
## 制作元数据
### `dwarf2dump`使用
安装调试文件导出工具`dwarfdump`：
  * 下载与编译libdwarf
    ## 解压Libdwarf
    [root@localhost src]# git clone https://github.com/tomhughes/libdwarf.git
    [root@localhost src]# tar -zxvf libdwarf.tar.gz
    ## 光盘安装依赖包
    [root@localhost src]# cd /media/CentOS_5.5_Final/CentOS/
    [root@localhost src]# rpm -ivh /media/CentOS_5.5_Final/CentOS/elfutils-libelf-0.137-3.el5.x86_64.rpm 
    [root@localhost libdwarf]# rpm -ivh elfutils-libelf-devel-static-0.137-3.el5.x86_64.rpm elfutils-libelf-devel-0.137-3.el5.x86_64.rpm elfutils-libelf-0.137-3.el5.x86_64.rpm
    ## 编译安装 libdwarf
    [root@localhost CentOS]# cd /home/yunwei/Desktop/malware/libdwarf
    [root@localhost CentOS]# ./configure
    [root@localhost libdwarf]# make
    ### 若没有报错，则表示安装正确。
    [root@localhost libdwarf]# cd dwarfdump/
    [root@localhost dwarfdump]# make install
    cp dwarfdump /usr/local/bin/dwarfdump
    cp ./dwarfdump.conf /usr/local/lib/dwarfdump.conf
    cp ./dwarfdump.1 /usr/local/share/man/man1/dwarfdump.1
    [root@localhost dwarfdump]# dwarfdump -h
    ### 输入dwarfdump -h若没有报错，则表示安装正确。
  * 生成内存镜像
    [root@localhost malware]# tar -zxvf volatility.tar.gz
    [root@localhost malware]# cd volatility/tools/linux/
    ## 错误