we present a protocol that requires only logarithmic communica-
tion. In the spirit of the use of random OT extension as a PRF with
single oblivious evaluation, we can view (ğ‘› âˆ’ 1)-out-of-ğ‘› ROT as a
privately punctured PRF [8] where we can generate a partial PRF
key that enables evaluation of the PRF on all but one point, where
the full PRF key holder does not know the punctured point.
2.1.1 OT-based secure product a.k.a Gilboa multiplication.
Gilboa [31] proposed a two-party secure multiplication protocol
of two ğ‘™-bit numbers. The protocol outputs additive shares, and
requires ğ‘™ 1-out-of-2 OT that can be run in parallel (throughout
this paper we assume ğ‘™ to be a constant, and set it to 64 in our
experiments). Due to the practical efficiency of OT Extension proto-
cols [3, 35], Gilboa multiplication is a common approach to secure
multiplication. In particular, this approach has been considered
in several works as a way to compute Beaver triples for secure
multiplication in the preprocessing model of MPC [22, 28, 44]. In
the context of our work, this protocol is used for scalar vector
multiplications. In terms of practical considerations, one should
note that Gilboa multiplication can be implemented from correlated
OT [3], a more efficient particular case of OT. Moreover, for the
problem of scalar-vector multiplication, one can employ optimiza-
tions based on batching for concrete efficiency (see [44] for details).
We employ these optimizations in our implementation of secure
scalar-vector multiplication based on Gilboaâ€™s protocol, which we
use as a baseline.
2.2 Cuckoo Hashing
Cuckoo hashing [47] is an algorithm to build hash tables for (key,
value) pairs with worst-case constant lookup. A cuckoo hash table
is determined by ğœ… hash functions, where the value corresponding
to a key is guaranteed to reside in one of the ğœ… locations determined
by the hash function evaluations on the key. Hash collisions are
resolved using the cuckoo approach: if a collision occurs when
placing an item in the hash table, the item residing in the location
is evicted and then placed in the table using a different hash func-
tion, potentially evicting another item in the case of collision. This
process continues until all evicted items are placed, if possible. Due
to possible cycles in this graph of evictions, the insertion algorithm
for cuckoo hashing has a chance to fail. For two hash functions,
it is known that inserting ğ‘› items in a cuckoo tables of size ğ‘‚(ğ‘›)
incurs more than ğ‘  insertion failures with probability bounded by
ğ‘‚(ğ‘›âˆ’ğ‘ ) [41]. The exact constants in this asymptotic bound are not
known, but several papers have studied them empirically [1, 15, 21].
This is done by estimating, for any fixed statistical security param-
eter ğœ‚, the number of hash functions and the cuckoo table size such
that inserting ğ‘› items in the table fails with probability at most 2âˆ’ğœ‚.
In cryptography, cuckoo hashing has been used as a probabilistic
bath code to optimize Private Set Intersection (PSI) [15, 42, 48, 49]
and Private Information Retrieval (PIR) [1] protocols. We introduce
these ideas in Section 5, where we apply cuckoo hashing to obtain
an optimized multi-point function secret sharing protocol.
2.3 Function Secret Sharing
Function secret sharing [12, 13] is a primitive that allows a key
generator to distribute the evaluation of a function between two
parties in way that neither of the two parties learns anything about
the evaluated function, but jointly the two parties can recover the
evaluation at any point.
Definition 2.2 (Function Secret Sharing). Let F = {ğ‘“ : ğ¼ â†’ G} be
a class of functions with input domain ğ¼ and output group G, and
let ğœ† âˆˆ N denote a security parameter. A function secret sharing
scheme consists of the following two algorithms:
â€¢ (ğ¾1, ğ¾2) â† FSS.Gen(1ğœ†, ğ‘“ ) â€“ given a description of ğ‘“ : ğ¼ â†’
G, output two keys ğ¾1, ğ¾2.
â€¢ ğ‘“ğ‘(ğ‘¥) â† FSS.Eval(ğ‘, ğ¾ğ‘, ğ‘¥) â€“ given an evaluation key ğ¾ğ‘ for
ğ‘ âˆˆ {1, 2} and an input ğ‘¥, output a share ğ‘“ğ‘(ğ‘¥) of the value
ğ‘“ (ğ‘¥).
We require the following guarantees from the above algorithms:
Correctness. For any ğ‘“ âˆˆ F , and any ğ‘¥ âˆˆ ğ¼, when (ğ¾1, ğ¾2) â†
FSS.Gen(1ğœ†, ğ‘“ ), we have Pr(cid:2)ğ‘âˆˆ{1,2} FSS.Eval(ğ‘, ğ¾ğ‘, ğ‘¥) =
ğ‘“ (ğ‘¥)(cid:3) = 1.
(cid:12)(cid:12)(cid:12) (ğ¾1, ğ¾2) â† FSS.Gen(1ğœ†, ğ‘“ğœ†)(cid:111) ğ‘â‰ˆ
(cid:110)ğ¾ğ‘
(cid:110)ğ¾ğ‘ â† Simğ‘(1ğœ†, Leakğ‘(ğ‘“ğœ†))(cid:111) .
Security. For any ğ‘ âˆˆ {1, 2}, there exists a ppt simulator Simğ‘ such
that for any polynomial-size function sequence ğ‘“ğœ† âˆˆ F ,
(1)
Note that the only difference between this definition and the one
of Boyle et al. [13] is the leakage function is allowed to be differ-
ent for each party. In the standard FSS construction, Leak1(ğ‘“ğœ†) =
Leak2(ğ‘“ğœ†) = (ğ¼, G), i.e., FSS keys must be simulated given only the
input and output domains for ğ‘“ .
While FSS is defined for any function, an FSS instantiation is
non-trivial if the length of the FSS keys is sub-linear in the size of
the function domain. In this regime of operation we have single
point FSS (SPFSS) constructions for point functions which evaluate
to zero on all but one of their domain points. Boyle et al. [12]
introduced an FSS constructions for point functions where the keys
are of length logarithmic in the function domain size.
Multi-point FSS (MPFSS) is a generalization of FSS where the
shared functions has a larger number of non-zero evaluations. How-
ever, for the purposes of Vector-OLE (cf. Section 2.4), we observe
that it is enough to consider a relaxed variant of MPFSS, where
one party knows the where ğ‘“ is nonzero in the clear. We call this
variant known-indices MPFSS, and we provide a reduction to cuckoo
hashing and known-index SPFSS in Section 5.
3
2.4 Vector OLE
Oblivious linear evaluation (OLE) is functionality that enables two
parties to obtain correlated outputs. One party has input values
ğ‘¢, ğ‘£. The second party has input ğ‘¥ and obtains as output ğ‘¤ = ğ‘¢ğ‘¥ + ğ‘£.
Similarly to the use of OT for garbled circuits, OLE is a basic building
block for secure arithmetic computation enabling the generation of
multiplicative triples. Vector OLE (VOLE) [2, 9] is a generalization
of OLE to the setting of vector inputs, i.e., one party has input
vectors u, v, the other party has input value ğ‘¥ and obtains a vector
w = uğ‘¥ + v. Boyle et al. [9] present application of VOLE to secure
computation and zero-knowledge constructions.
Analogously to OT there is a variant of VOLE referred to as pseu-
dorandom VOLE, where the vectors u, v are generated randomly
during the protocol execution. They are then provided as output to
the first party. This primitive suffices for the construction of VOLE
as well as its applications [9]. In Section 6 we present a new pseu-
dorandom VOLE construction that requires a weaker version of the
distributed MPFSS functionality compared to the approach of Boyle
et al. [9], which can be implemented efficiently as we demonstrate
in Section 8.
consists of the following algorithms:
Definition 2.3 (Pseudorandom VOLE). A pseudorandom VOLE
â€¢ (seed1, seed2) â† VOLE.Setup(1ğœ†, ğ‘›, F, ğ‘¥) â€“ this algorithms
takes vector length ğ‘›, field F and value ğ‘¥ and outputs two
seeds.
â€¢ VOLE.Expand(b, seedb) â€“ if ğ‘ = 1, output (u, v) âˆˆ Fğ‘› Ã— Fğ‘›,
else if ğ‘ = 2, then output w âˆˆ Fğ‘›.
The correctness of the protocol guarantees that w = uğ‘¥ + v. The se-
curity property requires that seed1 does not reveal any information
about ğ‘¥ and that seed2 does not allow to distinguish (u, v) from
random vectors subject to the correctness property, i.e., for any ppt
algorithm A the following holds:
(cid:12)(cid:12) Pr[ğ‘ = ğ‘â€²(cid:12)(cid:12) ğ‘â€² â† A(seed1),
(cid:12)(cid:12) Pr[ğ‘ = ğ‘â€²(cid:12)(cid:12) ğ‘â€² â† A(uğ‘, vğ‘, seed2),
(seed1, seed2) â† VOLE.Setup(1ğœ†, ğ‘›, F, ğ‘¥ğ‘),
(F, ğ‘›, ğ‘¥1, ğ‘¥2) â† A(1ğœ†)] âˆ’ 1/2(cid:12)(cid:12)  1 and security
parameter ğœ†, integer ğ‘› = ğ‘˜ğ‘ with ğ‘ > 0
Inputs: P1: âŠ¥; P2: index ğ‘– âˆˆ [ğ‘›]
Outputs:
P1: ğ‘› random values (ğ‘Ÿ ğ‘—)ğ‘— âˆˆ[ğ‘›]
P2: ğ‘› âˆ’ 1 random values (ğ‘Ÿ ğ‘—)ğ‘— âˆˆ[ğ‘›],ğ‘—â‰ ğ‘–
Key Generation (ROT.Gen(1ğœ†, ğ‘›, ğ‘–)):
(1) P1 generates a PRG seed ğ‘ 0
(2) P1 computes a ğ‘˜-ary GGM tree of depth ğ›¼ = logğ‘˜(ğ‘›),
ğ‘…â† {0, 1}ğœ†.
denoted ğ‘‡ = ğ‘‡ (ğ‘ 0, ğ›¼), by associating ğ‘ 0 to ğ‘‡ and, if ğ›¼ > 1,
constructing the ğ‘˜ children of ğ‘‡ recursively as ğ‘‡ (ğ‘  ğ‘— , ğ›¼ âˆ’ 1),
with ğ‘— âˆˆ [ğ‘˜] and seeds ğ‘ 1, . . . , ğ‘ ğ‘˜ computed as
( ğ‘ 1 | ğ‘ 2 |
. . .
| ğ‘ ğ‘˜ ) := G(ğ‘ 0)
(3) P2 computes (ğ‘1, . . . , ğ‘ğ›¼), the ğ‘˜-ary encoding of ğ‘– âˆ’ 1.
(4) The parties execute ğ›¼ instances of (ğ‘˜ âˆ’ 1)-out-of-ğ‘˜ OTs:
â€¢ P1 acts as sender. For the ğ‘™th OT, let (ğ‘1, . . . , ğ‘ğ‘˜ğ‘™) be
the seeds of the ğ‘™th level of ğ‘‡ . The ğ‘—th message in the
OT is set to be

ğ‘š ğ‘— :=
ğ‘ âˆˆ{ğ‘ğ‘¥ : ğ‘¥ â‰¡ ğ‘— mod ğ‘˜}
ğ‘ 
(the ğ‘—th message is the XOR of the seeds of the ğ‘—th
children of trees at level ğ‘™ âˆ’ 1).
â€¢ P2 acts as the chooser and inputs, in the ğ‘™th OT, the
set {0, . . . , ğ‘˜ âˆ’ 1} \ {ğ‘ğ‘™}, and obtains ğ‘˜ âˆ’ 1 seeds ğ‘ğ‘™,ğ‘—
with ğ‘— âˆˆ [ğ‘˜] \ {ğ‘ğ‘™}.
(5) P1 outputs ğ¾1 â† ğ‘ 0
(6) P2 outputs ğ¾2 â† (ğ‘ğ‘™,ğ‘—)ğ‘™âˆˆ[ğ›¼],ğ‘—âˆˆ[ğ‘˜]\{ğ‘ğ‘™ }.
Expansion (ROT.Expand(ğ‘, ğ¾ğ‘)):
(i) If ğ‘ = 1: P1 returns the list of leaves of ğ‘‡ .
(ii) If ğ‘ = 2: P2 uses the seeds ğ‘ğ‘™,ğ‘— to reconstruct ğ‘‡ , except for
the path to the ğ‘–th leaf (recall that (ğ‘1, . . . , ğ‘ğ›¼) is the ğ‘˜-ary