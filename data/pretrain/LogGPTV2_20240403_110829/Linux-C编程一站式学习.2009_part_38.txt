下一页
3
---
## Page 307
可以看到这个地址位于.rodata段:
变量A用const修饰，
我们在全局作用域和main函数的局部作用域各定义了一些变量，并且引入一些新的关键
3.变量的存储布局 请点评
从低到高的顺序重新排列了，
首先看下面的例子:
例 19.2.研究变量的存储布局
Lk
Section Headers:
[Nr]
readelf -a a.out
gcc main.c 
Inf
69:
68:
int main(void)
int c;
#include 
Al
 Name
0804a02c
0804a018
08048540
，表示A是只读的，不可修改，
a
-g
‘( '"u\p% PTIOm OIH)UTxd
return 0;
register int c = 50;
20;
0
 并且只截取我们关心的那几行。
]q
了解各变量的地址分布。注意在下面的清单中我把符号表按地址
OBJECT
134248
OBJECT
OBJECT
第19 章汇编与C之间的关系
Type
全国嵌入式人才培训基地
3.变量的存储布局
，那么这些变量的存储空间是怎么分配的呢？我们编译之
...........
GLOBAL
GLOBAL
GLOBAL
，它被分配的地址是0x8048540，
DEFAULT
DEFAULT
DEFAULT
Addr
53
off
a.1589
Aab
Size
ES Flg
从readelf的输出
---
## Page 308
件链接在一起，LOcAL的符号只能在某一个目标文件中定义和使用，而不能定义在一个目标文件中
里的作用是声明b这个符号为LOCAL的,
a是一个GLOBAL的符号，而b被static关键字修饰了，
从上面readelf的输出可以看到.data段从地址0x804a010开始，
注意，
面只读保护起来，
程序加载运行时，
域定义了-
d\n"分配在.rodata段的末尾，在第4 节“字符串"说过字符串字面值是只读的，相当于在全局作用
之
其中0x540地址处的oa 0o0000就是变量A。我们还看到程序中的字符串字面值"He1lo world
它在文件中的地址是0x538~0x554，我们用nexdump命令看看这个段的内容:
后就不能再改写了，也就是不能再赋值了
 像A这种const变量在定义时必须初始化。因为只有初始化时才有机会给它一个值，一旦定义
·gnu.version
"{.o\.
const char helloworld[].
.rodata
 Section to Segment mapping:
$ hexdump -C a.out
WA
AX
一个const数组：
[24]
[23] .data
L9
5
00
.eh_
.bss
防止意外的改写。这一点从readelf的输出也可以看出来：
0
.ctors .dtors .jcr .dynamic .got
.interp
25 64 0a
.dynamic
.ctors
interp
world 
_frame
..dtors .jcr .dynamic .got .got.plt .data .bss
10000０00000
NOBITS
PROGBITS
PROGBITS
PROGBITS
不被链接器处理，
o`
）00０000000000０000
6f 20 77 6f 72 6c 64 20
0300000001000200
，导致它成为一个LOCAL的符号，
，在下一章我们会看到，
0804a024 001024 00000c 00 WA
0804a010 001010 000014 00
08048538 000538 00001c 00
080483600003600001bc 00
static
 长度是0x14，也就是到地
.init
操作系统将这个Segment的页
'%`
，如果把多个目标文
，所以static在这
308
---
## Page 309
通过三条mov1指令把12个字节写到栈上，这就是b的存储空间，如下图所示。
可见，
上的，b是数组也一样，也是分配在栈上的，我们看main函数的反汇编代码：
现在还剩下函数中的b和c这两个变量没有分析。
则初值也是0，也分配在.bss段。
不初始化则初值为0，
在加载时这个段用0填充。所以我们在第4节“全局变量、局部变量和作用域"讲过，
们讲的局部变量，它并不是在调用函数时分配，
还有一个a.1589是什么呢？它就是main函数中的static int a。函数中的static变量不同于以前我
是LOCAL的。
却在另一个目标文件中使用。
.bss段从地址0x804a024开始（紧挨着.data段）
及
说
其它函数的变量a区分开。
变量a就不是指它了，
样，
，给b初始化用的这个字符串"Hello world"并没有分配在.rodata段，而是直接写在指令里了，
只在函数中起作用，
图19.4.数组的存储布局
0x10(%ebp)
0x14(%ebp)
804844a:
8048445:
804843e:
8048437:
8048430:
 objdump -ds a.out 
register.
同理可以推断
所以编译器给它的符号名加了一
c7 45 f4
c7 45 f0 6f 20 77
int
一个函数定义前面也可以用
9
0
44
斤，static变量（不管是函数里的还是函数外的）如果不初始化
72
04
00
6c
64
00
6f
6c
上一节我们讲过函数的参数和局部变量是分配在栈
 在函数返回时释放，
，长度为0xc，也就是到地址0x804a030结束。
一个后缀，变成a.1589，
mov
mov
movl
movl
movl
$0x32,%eax
$0x646c72,-0xc(%ebp)
$0x6f77206f,-
$0x6c6c6548,-
修饰，表示这个函数名符号
.bss段在文件中不占存储空间，
，而是像全局变量一样静态分
以便和全局变量a以
 全局变量如果
在别的函数中
变
---
## Page 310
作用域（Scope）这个概念适用于所有标识符，而不仅仅是变量，C语言的作用域分为以下几类
念给变量分类太笼统了，需要进一步细分。我们总结一下相关的C语法。
以前我们用"全局变量"和"局部变量"这两个概念，
用时可以看作数组名，
存器里取出c的值当参数压栈,
当n=0时，元素b[0]的地址就是数组的基地址，
数组元素b[n]的地址=数组的基地址（b做右值就表示这个基地址）+n×每个元素的字节数
们以后讲指针还要继续讨论这个问题。
注意,
量c并没有在栈上分配存储空间，而是直接存在eax寄存器里，
·函数原型作用域（Function Prototype Scope）
·函数作用域（Function Scope）
·块作用域（Block Scope）
文件作用域（File Scope）
是一个声明而不是定义（没有函数体）
块作用域的，从声明的位置开始到函数末尾之间有效。
开始到右}括号之间有效。
效。
台
域。
 虽然栈是从高地址向低地址增长的，但数组总是从低地址向高地址排列的，按从低地址到高
低地址
高地址
 被包含到这个程序文件中了，
但仅限于同一个函数之中。
 标号在函数中不需要先声明后使用，
eH
ebp-0x14
ebp-0x10
3x0-dqa
，如果做右值则表示数组首元素的地址（或者说指向数组首元素的指针），我
而不是把整个字符串压栈，
 这就是register关键字的作用，
，标识符位于一对凸括号中（函数体或语句块）
，标识符从它声明的位置开始直到这个程序文件[30]的末尾都有
所以也算文件作用域的。
标识符在整个函数中都有效。
 那么标识符从声明的位置开始到在这个原型末尾之
在前面用-
因此数组下标要从0开始而不是从1开始。
，主要是从作用域上区分的，现在看来用这两个概
，所以在第4节“字符串"中说过，字符串在使
 标识符出现在函数原型中，
一个goto语句也可以跳转到后面的某个标
 指示编译器尽可能分配-
只有语句标号属于函数作用
，这个函数原型只
从它声明的位置
310
---
## Page 311
存储类修饰符（Storage Class Specifier）有以下几种关键字，
标识符的链接属性（Linkage）有三种：
识符，例如局部变量名在它的函数中将覆盖重名的全局变量。命名空间可分为以下几类：
对属于同一命名空间（Name Space）的重名标识符，内层作用域的标识符将覆盖外层作用域的标
· auto,
·内部链接（Internal Linkage）
● static,
·所有其它标识符，
·语句标号单独属于一个命名空间。例如在函数中局部变量和语句标号可以重名，
外部链接（External Linkage）
struct和union的成员名属于一个命名空间。由于成员名总是通过.或->运算符来访问而不会
分类的，extern关键字就用于多次声明同一个标识符，
extern,
register,
作用域的变量。
上例中main函数里的b其实就是用auto修饰的，
有Internal Linkage。
无链接（No Linkage）。
但main函数里面那个a不能算Intermal Linkage的，因为即使在同一个程序文件中，在不同的函
中main函数外面的a和c，main和printf也算。
Linkage。具有External Linkage的标识符编译后在符号表中是GLoBAL的符号。例如上例
层作用域。
编译阶段处理，
单独使用，所以编译器不会把它和别的标识符弄混。
一个命名空间。
另
一个变量或函数,
以及不表示变量和函数的其它标识符。
用它修饰的变量在函数调用时自动在栈上分配存储空间，
上面讲过，
用它修饰的变量的存储空间是静态分配的，用它修饰的文件作用域的变量或函数具
编译器对于用register修饰的变量会尽可能分配一个专门的寄存器来存储，
，除了宏定义之外其它几类标识符按上面所说的规则处理，内层作用域覆盖外
如果有重名的话，
，链接属性是根据一个标识符多次声明时是不是代表同一个变量或函数来
。除以上情况之外的标识符都属于No Linkage的，例如函数的局部变
如果一个标识符在某个程序文件中即使声明多次也都代表同
，如果最终的可执行文件由多个程序文件链接而成，
，宏定义覆盖所有其它标识符，因为它在预处理阶段而不是
，它自己会想办法有效地利用CPU的寄存器，
：只不过auto可以省略不写，auto不能修饰文件
下一章再详细介绍它的用法。
，可以修饰变量或函数声明：
，register不能修饰文件作用域的
函数返回时自动释放,
，互不影响
一个标识
311
但如
例如
有
---
## Page 312
2.main函数和启动例程
准。
单元之外，还有编译器叫Translator，变量叫Object，本书不会采用这些名词，因为我不是在写C标
用链接器链接到一起，
编译单元（Translation Unit）。每个编译单元可以分别编译成一个.o目标文件，
[3] 为了容易阅读，
变量的生存期（Storage Duration，或者Lifetime）分为以下几类:
称为类型限定符（Type Qualifier）。
Specifier是不完全相同的。const和以后要介绍的restrict和volatile关键字属于同一类语法元素
明，但是在以后介绍的更复杂的声明中const在语法结构中允许出现的位置和Storage Class，
·动态分配生存期（Allocated Storage Duration）
·自动生存期（Automatic Storage Duration）
意
· typedef,
·静态生存期（Static Storage Duration）
间中分配内存，调用free函数可以释放这种存储空间。
中main函数里的b和c。
量，这种变量在进入块作用域时在栈上或寄存器中分配，在退出块作用域时释放。例如上例
变量的，而是定义-
，在程序开始执行时分配和初始化一次，
所以从语法（而不是语义）的角度把它和前面几个关键字归类到一起。
在第 2.4 节“sizeof运算符与typedef类型声明"讲过这个关键字，它并不是用来修饰
，这里我用了“程序文件"这个不严格的叫法。
，成为一个可执行文件。C标准中大量使用一些非常不通俗的名词，除了编译
 看这个变量是什么类型的，
全国嵌入式人才培训基地
一节也讲过,
起始页
上一级
，此后便一直存在直到程序结束。这种变量通常位
具有外部或内部链接属性，
链接属性为无链接并且没有被static修饰的变
以后会讲到调用malloc函数在进程的堆空
，如果有文件a.c包含了b.h和c.h,
虽然看起来它也修饰一个变量声
，或者被static修饰的变
4.结构体和联合体
，最后这些目标文件
 在C标准中称为
首先去
一个什么类
312
下一页
那
---
## Page 313
从访问结构体成员的指令可以看出，结构体的四个成员在栈上是这样排列的：
 main函数中几条语句的反汇编结果如下:
我们继续用反汇编的方法研究一下C语言的结构体:
4.结构体和联合体 请点评
上一页
图 19.5.结构体的存储布局
例 19.3.研究结构体
80483e6:
80483df:
80483d9:
80483d5:
int main(int argc, char** argv)
#include 
s.c = 3;
s.b = 2;
S.a=1;
return 0; 
printf("%u\n", sizeof(s));
s
struct {
c6 45 f8 04 
c745 f403000000
66 c7 45 f2 02 00
c6 45 f0 01
char d;
int c;
short b;
char a;
第19 章汇编与C之间的关系
全国嵌入式人才培训基地
4.结构体和联合体
movb
movl
movw
movb
$0x4,-0x8(%ebp)
$0x3,-0xc(%ebp)
$0x2,-0xe(%ebp)
$0x1,-0x10(%ebp)
313
---
## Page 314
此外，gcc提供了一种扩展语法可以消除结构体中的填充字节:
生填充字节：
合理设计结构体各成员的排列顺序可以节省存储空间，例如上例中的结构体改成这样就可以避免产
址+nx元素大小"简单计算出来。
上，C标准规定数组元素必须紧挨着排列，
数
效
护
对
为什么编译器要这样处理呢？有-
（Padding）
似。但有一点和数组不同，
虽然栈是从高地址向低地址增长的，
牛
它的基地址仍然对齐到4字节边界了
s.a的后面也要有填充位填充到4字节边界呢？
两字节的整数倍
。s.a占-
结构体，
率比对齐的指令
不能访问内存，
的整数债
存地址应该是4的整数倍，
于访问内存的指令是有限制的,
读者可以
低地址