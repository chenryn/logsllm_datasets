### 一、前言
我们在前面进行了两讲公式机制（参考链接如下），在前文的讲述中，我们讲解了部分共识的具体流程以及优缺点。本文中，我们补充剩下的共识理念并分析其对应的优缺点。除此之外，我们针对相关的共识漏洞进行分析，为安全爱好者提供更多攻击的参考模型。
[区块链安全—详谈共识攻击（一）](https://xz.aliyun.com/t/3139)  
[区块链安全—详谈共识攻击（二）](https://xz.aliyun.com/t/3160)
### 二、Ripple Consensus—瑞波共识算法
#### 1 协议流程
在介绍协议前，我们简单的介绍下瑞波的由来。简单来说，瑞波是一个基于互联网的全球开放的支付网络，人们可以通过该支付网络转账任意一种货币，交易确认时间很短，一般只需要几秒钟就能完成。所以此支付网络非常简便与快捷，所以交易费用接近于零。
瑞波共识协议（Ripple Consensus
Protocol，RCP）中包括了特殊节点列表并基于此使一组节点达成共识。初始特殊节点列表就像一个俱乐部，如果俱乐部要接纳新成员，必须由俱乐部会员进行投票，一定比例的会员通过才允许接纳新会员。要接纳一个新成员需要该俱乐部51%的会员投票通过，并且外部成员对此没有任何影响力。由于该俱乐部有“中心化”特性，如果其开始腐化那么股东们则无法做任何事情。所以瑞波系统将股东们与其投票权利分隔开，并因此比其他系统更中心化。
在Ripple的共识算法中，参与投票节点的身份是事先知道的，因此，算法的效率比PoW等匿名共识算法要高效，交易的确认时间只需几秒钟。当然，这点也决定了该共识算法适用场景有限的缺陷。
在介绍协议前，我们先交代下其中的节点类型：瑞波共识包括以下几种节点类型： **活跃信任节点、不活跃信任节点、验证节点** 。
下面我们具体的介绍一下RCP协议的具体内容：
①验证节点保存未经验证的交易。
在系统运行的过程中，验证节点会接受系统中发起的交易请求，并保存其在本地，之后等待共识。而在本轮共识过程中新到的交易需要等待，在下次共识时再确认。
②活跃信任节点将合法交易发送至验证节点。
根据我们上面的内容可知，RCP协议中存在“信任节点列表”的概念。而其是验证池中的一部分，其列表中的节点均来自验证池。而跟大多数协议相同，RCP共识机制要求参与共识的信任节点必须处于活跃的状态（否则无法进行下一步的操作）。而那些不活跃的节点将会被踢出列表。
在这里，信任列表中的节点也会收到系统中的各个TXs（交易），包括交易双方额度、交易历史等。之后会对交易进行判断，判定其交易是否合法，并将合法的交易打包成提议发送给验证节点。
③验证节点检验提议来源。
验证节点检查接收到的提议是否来自信任节点列表中的合法信任节点，如果是，则存储；如果不是，则丢弃。
**在这里我们类似于将权利下放，将判定工作下放给员工（信任节点）来做。**
④验证节点根据收到的提议确定出交易清单。
开始的时候，我们需要规定信任列表中的信任节点数量，例如M个。而我们需要规定交易的认可比例N。由此，验证节点就有其依据来判断交易是否可以被认可。当每一个超过M*N个信任节点认可的交易将会被验证节点认可。
**例如M为10个节点，我们可以规定超过百分之60就可以添加为合法，即10×60%=6个节点**
在验证节点本地需要生成认可交易列表。系统为验证节点设置一个计数器，当计数器时间到了之后验证节点就要向信任节点索要交易认可列表。
⑤账本共识达成。
验证节点接受信任节点的各种提议，并计算信任节点针对某个交易所提供的正确与否的消息。在此过程中，节点会持续更新认可交易列表。而
其次，验证节点认可列表的生成并不代表最终账本的形成以及共识的达成，账本共识只有在每笔交易都获得至少超过一定比例（例如 N%）的信任节点列表认可才能达成。
如果账本中每笔交易都获得超过比例N的信任节点认可，则共识达成，交易验证结束，否则继续上述过程。
⑥共识过程结束，形成最新账本。
共识过程结束后，已经形成最新的账本，将上轮剩余的待确认交易以及新交易纳入待确认交易列表，开始新一轮共识过程。
之后将账本发布，供系统中所有节点下载使用。
**总结来说，协议分为以下几个过程：①系统中客户端进行交易、②验证节点接收并存储交易、③信任节点发送提议于验证节点、④验证节点验证列表、⑤达成账本共识并关闭账本**
#### 2 协议安全分析
根据我们对协议具体内容的分析，我们知道瑞波协议就是易于遭受攻击，黑客可以伪造node，甚至可以大量扩散潜伏，并在某个时间突然攻击所有网络。
我们知道，应用此协议的系统能够做到将交易账本几秒钟部署应用到所有节点，效率十分高。所以用此来维护整个网络的有效性以及一致性十分合适。并且这点也决定了该共识算法只适合于权限链（Permissioned
chain）的场景。Ripple共识算法的拜占庭容错（BFT）能力为（n-1）/5，即可以容忍整个网络中20%的节点出现拜占庭错误而不影响正确的共识。
而在整个社区中，共识一旦达成，当前的账本将会保存记录在此之前的所有交易信息，然后关闭成为最后的账本。在这个关闭的账本中所有网络节点维护都是相同的。
## 三、POET—消逝时间量证明
此算法在芯片制造商英特尔(Intel)创立之初就被拿来进行使用，由于其耗能十分低，所以乔布斯也曾将其应用于产品。它是一种算法，通常用于被许可的区块链网络来决定采矿权或网络上的块赢家。它是由英特尔构建在可信执行环境的一种彩票协议。核心是用intel支持SGX技术的CPU硬件，在受控安全环境（TEE）下随机产生一些延时，同时CPU从硬件级别证明延时的可信性，类似于彩票算法，谁的延时最低，谁将获取记账权。
而投票机制是基于CPU的数量，也就是说一个CPU只能进行一次投票。所以增加记账权的唯一方法就是多增加CPU的数量，具备了当初中本聪设想的一个CPU一票的可能，同时增加的CPU会提升整个系统的资源，变相实现了记账权与提供资源之间的正比例关系。
该算法要求网络中的每个参与节点在定时器上等待一个随机的时间量，第一个完成指定等待时间的节点为新块的赢家。网络上的每个节点基本上都是在随机产生的一段时间内进入睡眠状态，而第一个醒来的节点，也就是睡眠时间最短的节点，醒来时向区块链提交一个新的块。
下面我们详细介绍下此共识的大致思路：
  * 1每一个节点均需要从enclave（代表一个可信操作）中获得一个随机的等待时间。
  * 2拥有最短时间的备选人将被选为leader并率先发布块。
  * 3enclave是通过新型的安全CPU指令来实现的。其包括两个函数“CreateTimer”、“CheckTimer”。第三步中使用`CreateTimer`从enclave中产生一个timer。
  * 4之后使用验证函数`CheckTimer`去检验这个timer是不是由enclave产生、是否已经过期。
  * 5如果满足了上述条件就会生成一个attestation凭证。其中包含的信息可以用来校验certificate是否由该encalve产生并已经等待了timer规定的时间。成为leader的概率与捐献的资源成正比。因为是通用处理器而不需要定制的矿机，所以参与门槛较低并且节点较多，整个共识机制更为健壮。
### 四、长程攻击（Long-Range Attacks）分析
根据我们前文提及的知识，Pow由于其浪费资源的原因导致越来越多的区块链项目转变共识为Pos，所以在权益证明已经越来越受关注。而我们这次提及的攻击就是主要针对Pos共识的一种非常巨大的威胁攻击。由于其具有弱主观性并且能进行无代价模拟的特点，所以这种攻击带来的危害更大。
我们知道在区块链系统中，除了主链之外还存在许多与主链并行的其他分支链。而长程攻击就是攻击者创建了一条从创世区块开始的长区块链分支，并试图替换掉当前的合法主链。该分支上可能存有和主链不同的交易和区块，所以这种攻击又被称替换历史攻击或历史覆写攻击。而当保证金被解除绑定，激励不从某个高度区块前进行长距离投票就被取消了。换句话说就是当用户可以不受制裁的进行分叉链的创建时，就有可能导致分叉链超过主链从而代替主链的地位。
#### 1 弱主观性
这里的弱主观性是针对新加入的节点而言。我们知道在系统中总会存在长期不在线或者新加入的节点。当这些节点回归系统或者加入系统后，我们需要为其提供创世区块。这个区块是独一无二被大家共识为首区块的区块。设置好创世区块后，节点接着就会收到当前区块链上所有公开的分支。然而此时问题就来了，作为萌新，新区块并不知道哪个是主链，哪个是分支。而对于离线很久的节点，它也并不知道在它离线的这些日子里主链成为了何模样。对于在线的节点而言，这种情况则不会出现。持在线状态的节点则总能及时地监控并同步主链。除非其它分支链篡位成功成为了合法主链，否则保持在线状态的节点不可能接受其他分支作为主链。
而我们为什么说Pos中存在这种类似的攻击而Pow中很少出现呢？