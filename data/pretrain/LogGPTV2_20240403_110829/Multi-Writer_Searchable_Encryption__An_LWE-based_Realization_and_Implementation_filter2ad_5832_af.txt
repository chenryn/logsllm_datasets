scheme, we generate synthetic data to report the cost and scalability
of each operation. Following the parameter setting of existing work
[3, 6, 21], we set the parameter of LWE n = 256, m = 9753, lm′′ =
256, q = 4093 and n = 320, m = 13133, lm′′ = 256, q = 8191, where
n is the security parameter.
8.1 Experiment Result
Initialization. The Initialize algorithm is to find a short basis
8.1.1
of lattice Λ⊥(A) for an arbitrary matrix A ∈ Zn×m
as the master
secret key [4]. Fig.1 shows the time cost for generating a valid basis
for different size of n. Note that other related parameters are chosen
according to the parameter setting given in Section 5.2. Again, the
requirement is that, all these selected parameters in our experiment
are sufficient to ensure the LWE assumption holds. From Fig.1, we
can see that the average time cost increases with the growth of n.
For example, it takes about 6.34 s to generate a pair of matrix and
its corresponding lattice basis for n = 64 and 750.62 s for n = 320.
8.1.2 Key Derivation. The Key derive algorithm is to generate a
private key for a given user, and the user can be identified via their
tag. In this experiment, we use a 1024-bit string to denote the tag,
which is then transferred to a tag-matrix. Fig.2 shows the time cost
for private key generation for 100 users over different basis size.
This cost is proportional to the number of users. As seen, it spends
about 22606 s and 35203 s on generating private keys for all 100
q
1The source code is published at: https://github.com/Raycrypto/Multi-writer-PEKS
Figure 3: Performance of data encryption
users while n = 256 and n = 320. Note that further evaluations in
Section 8.2 demonstrate that our proposed batch optimization can
further improve the efficiency of the private key generation.
8.1.3 Data Encryption. Fig.3 depicts the time cost for encrypting
1000 keywords. This process consists of 2k +3 matrix multiplicative
transformations and additions, two vector inner product operations,
and two matrix multiplications. As seen, this cost is proportional to
the number of keywords. From Fig. 3, it takes about 467 s to encrypt
1000 keywords for n = 256 and 698 s for n = 320.
Search. The search algorithm includes the token generation
8.1.4
and search (token matching) operation. The user first uses her
private key to generate the token for the keyword she expects to
search and sends it to the server. Then the server performs search
by checking the token with the encrypted keywords. Fig.4 records
the time of performing search test over 1000 encrypted keywords
after removing the token generation cost, which is given later in
Table 4-b. For the search operation, the whole process only contains
one inner product calculation for two vectors. Fig. 4 shows that it
takes 13.4 ms to perform search matching over 1000 keywords for
n = 256 and 16.98 ms for n = 320.
Size of n64128192256320Time cost for generating basis (s)0200400600800Number of users020406080100Time cost of private key deriving (103s)0816243240n=256n=320Number of keywords02004006008001000Time cost for keyword encryption (s)0200400600800n=256n=320Session 2B: Advanced Encryption AlgorithmsAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand131This scheme does not leverage identity for key generation and gen-
erates a pair of public and private keys for each user. For the sake
of fairness, we conduct the experiment under the same parameters
setting as [6]. The tags and keywords are randomly generated with
the size of 128 bits. Note that the scheme is not implemented in [6]
and only simulated results on a high-end machine (with better capa-
bilities than ours) are reported in that paper. Hence, the comparison
on the time cost is based on the evaluation of our implementation
and the simulated results reported in [6].
From the perspective of the storage, Table 4-(a) shows that the
sizes of the private key and the token in our scheme and the basic
scheme are comparable. For example, when n = 256, the size of
private key and token are 547 MB and 113 KB in our scheme, while
these are 519 MB, 110 KB in the basic scheme. However, the storage
cost of the keyword ciphertext in our scheme is much smaller than
the basic scheme. In the case of n = 256, the size of a keyword
ciphertext in our scheme is 113 KB, while it is 9086 KB in the basic
scheme, which is about 80× larger than us. The reason is that we
improve the structure of the ciphertext by removing the redundant
components of their ciphertext. This also affects the computation
cost, which will be given later.
Table 4: Comparison with the scheme in [6]
Figure 4: Performance of search
(a) Time cost for n = 256
[6]
Ours
[6]
Ours
n = 256
n = 320
n = 256
n = 320
Scheme
n = 256
n = 320
n = 256
n = 320
Scheme
Private key
519 MB
942 MB
547 MB
988 MB
Token Ciphertext
9086 KB
110KB
29692 KB
148 KB
113 KB
113 KB
151 KB
151 KB
(a) space cost comparison
TokGen
814.9 ms
1509 ms
6126 ms
8362 ms
Encrypt
2115.12 ms
3727 ms
467 ms
698 ms
Search
643 ms
1214 ms
13.4 ms
16.98 ms
(b) time cost comparison
In terms of time cost, we report the time cost of each algorithm
in our scheme and compare it with the simulated cost in the basic
scheme. From Fig.5, we can find that in the basic scheme, it takes
them almost 524s and 1305s to generate a pair of public key for n =
256 and n = 320 respectively, and the time to generate public/private
key pairs is proportional to the number of users. While in our
scheme, it takes 728s and 1667s to generate the private key for the
first user but average 252.2s and 365.2s for 100 users. Compared
to the average time spent, our scheme is 2× and 3.5× faster than
theirs. This result is due to the fact that we only use the TrapGen
algorithm once to generate a short basis of lattice, and then use
this basis to generate private keys for users. However, the above
process needs to repeat 100 times in the basic scheme, and the cost
will expand rapidly with an increasing number of users. In addition,
as the ExtBasis algorithm shares the same input, master key, our
proposed optimization technique can compute the extended basis
in a batch. The corresponding results can be seen in Fig. 5, which
improves the performance. With the batch processing technique,
(b) Time cost for n = 320
Figure 5: Comparison of Setup and KeyGen
8.2 Comparison with Prior Art
To demonstrate the advantage of our scheme, we perform compari-
son of the storage overhead and time cost with a basic LWE PEKS
scheme proposed by Behnia et al. [6] (denoted as basic scheme).
0200 400 600 800 Number of matchingoperations1000Time cost of  search (ms)05101520n=256n=320Number of users020406080100Time cost of private key deriving (103s)0204060Basic schemeOur schemeBatch processingNumber of users020406080100Time cost of private key deriving (103s)050100150Basic schemeOur schemeBatch processingSession 2B: Advanced Encryption AlgorithmsAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand13277–94.
key derivation can achieve a speed up of is 1.8× and 1.3× compared
to our original algorithm.
In the Table 4, our TokenGen algorithm takes more time to gen-
erate the search token, because the new identity feature introduces
more calculations. But for each keyword, one may execute the to-
ken generation algorithm once and cache this token locally for
subsequent use. While for the efficiency of encryption and search
operations, both algorithms are 80× and 190× faster than the basic
scheme for n = 256 and 320 respectively.
9 CONCLUSION
In this paper, we design and implement a lattice-based search-
able encryption scheme from LWE for applications in multi-writer
scenarios. In particular, our scheme leverages the philosophy of
identity-based encryption and can support users to encrypt data
directly via their identities. This alleviates the bottleneck of key
management in LWE based searchable encryption schemes. We
conduct detailed correctness and security analysis for our scheme
and perform a series of experiments to evaluate the efficiency of
each function. There are still issues remained to be solved, i.e., how
to reduce the size of private key and how to improve the perfor-
mance of key derivation and token generation. Accordingly, we will
explore and design schemes constructed from Ring-LWE [24] or
Module-LWE [20]. Adapting these variants of LWE would further
improve the efficiency but might introduce tradeoff on security. We
leave them as our future work.
ACKNOWLEDGMENTS
This work was supported in part by the Fundamental Research
Funds for the Central Universities (No.30918012204), Research
Grants Council of Hong Kong under Grant CityU 11276816, Grant
CityU 11212717, and Grant CityU C1008-16G, in part by the Innova-
tion and Technology Commission of Hong Kong under ITF Project
ITS/168/17, in part by the National Natural Science Foundation of
China under Grant 61572412.
REFERENCES
[1] Michel Abdalla, Mihir Bellare, Dario Catalano, Eike Kiltz, Tadayoshi Kohno, Tanja
Lange, John Malone-Lee, Gregory Neven, Pascal Paillier, and Haixia Shi. 2008.
Searchable Encryption Revisited: Consistency Properties, Relation to Anonymous
IBE, and Extensions. Journal of Cryptology 21, 3 (2008), 350–391.
[2] Shweta Agrawal, Dan Boneh, and Xavier Boyen. 2010. Efficient Lattice (H)IBE in
the Standard Model. In Proc. of EUROCRYPT. 553–572.
[3] Martin R. Albrecht, Rachel Player, and Sam Scott. 2015. On the concrete hardness
of Learning with Errors. Journal of Mathematical Cryptology 9, 3 (2015), 169–203.
[4] Joël Alwen and Chris Peikert. 2011. Generating Shorter Bases for Hard Random
Lattices. Theory Computing System 48, 3 (2011), 535–553.
[5] Daniela Becker, Jorge Guajardo, and Karl-Heinz Zimmermann. 2018. Revisiting
Private Stream Aggregation: Lattice-Based PSA. In Proc. of NDSS.
[6] Rouzbeh Behnia, Muslum Ozgur Ozmen, and Attila Altay Yavuz. 2018. Lattice-
Based Public Key Searchable Encryption from Experimental Perspectives. IEEE
Trans. on Dependable and Secure Computing (2018).
[7] Dan Boneh, Giovanni Di Crescenzo, Rafail Ostrovsky, and Giuseppe Persiano.
2004. Public Key Encryption with Keyword Search. In Proc. of EUROCRYPT.
506–522.
[8] Dan Boneh and Brent Waters. 2007. Conjunctive, Subset, and Range Queries on
Encrypted Data. In Proc. of TCC. 535–554.
[9] Ahmad Boorghany and Rasool Jalili. 2014. Implementation and Comparison
of Lattice-based Identification Protocols on Smart Cards and Microcontrollers.
IACR Cryptology ePrint Archive (2014), 78.
[10] David Cash, Dennis Hofheinz, and Eike Kiltz. 2009. How to Delegate a Lattice
Basis. IACR Cryptology ePrint Archive 2009 (2009), 351.
[11] David Cash, Dennis Hofheinz, Eike Kiltz, and Chris Peikert. 2012. Bonsai Trees,
or How to Delegate a Lattice Basis. Journal of Cryptology 25, 4 (2012), 601–639.
[12] Reza Curtmola, Juan Garay, Seny Kamara, and Rafail Ostrovsky. 2011. Searchable
symmetric encryption: improved definitions and efficient constructions. Journal
of Computer Security 19, 5 (2011), 895–934.
[13] Craig Gentry, Chris Peikert, and Vinod Vaikuntanathan. 2008. Trapdoors for
Hard Lattices and New Cryptographic Constructions. In Proc. of STOC. 197–206.
[14] Philippe Golle, Jessica Staddon, and Brent R. Waters. 2004. Secure Conjunctive
Keyword Search over Encrypted Data. In Proc. of ACNS. 31–45.
[15] Jeffrey Hoffstein, Jill Pipher, and Joseph H Silverman. 2001. NSS: An NTRU
Lattice-Based Signature Scheme. In Proc. of EUROCRYPT. 211–228.
[16] Stanislaw Jarecki, Charanjit S. Jutla, Hugo Krawczyk, Marcel-Catalin Rosu, and
Michael Steiner. 2013. Outsourced symmetric private information retrieval. In
Proc. of ACM CCS. 875–888.
[17] Jonathan Katz and Vinod Vaikuntanathan. 2009. Smooth Projective Hashing and
Password-Based Authenticated Key Exchange from Lattices. In Proc. of Asiacrypt.
636–652.
[18] Elena Kirshanova. 2014. Proxy Re-encryption from Lattices. In Proc. of PKC.
[19] Shangqi Lai, Sikhar Patranabis, Amin Sakzad, Joseph K. Liu, Debdeep Mukhopad-
hyay, Ron Steinfeld, Shifeng Sun, Dongxi Liu, and Cong Zuo. 2018. Result Pattern
Hiding Searchable Encryption for Conjunctive Queries. In Proc. ACM CCS. 745–
762.
[20] Adeline Langlois and Damien Stehlé. 2015. Worst-case to Average-case Reduc-
tions for Module Lattices. Design Codes Cryptography 75, 3 (2015), 565–599.
[21] Richard Lindner and Chris Peikert. 2011. Better Key Sizes (and Attacks) for
LWE-Based Encryption. In Proc. of CT-RSA. 319–339.
[22] Zhe Liu, Reza Azarderakhsh, Howon Kim, and Hwajeong Seo. 2017. Efficient
Software Implementation of Ring-LWE Encryption on IoT Processors. IEEE Trans.
on Computers PP, 99 (2017), 1–1.
[23] Vadim Lyubashevsky. 2012. Lattice Signatures without Trapdoors. In Proc. of
Asiacrypt. 738–755.
[24] Vadim Lyubashevsky, Chris Peikert, and Oded Regev. 2013. On Ideal Lattices and
Learning with Errors over Rings. Journal of ACM 60, 6 (2013), 43:1–43:35.
[25] Daniele Micciancio and Oded Regev. 2013. Lattice-based Cryptography. Lecture
Notes in Computer Science 4117, 1-2 (2013), 131–141.
[26] T Monz, D Nigg, E. A. Martinez, M. F. Brandl, P Schindler, R Rines, S. X. Wang,
I. L. Chuang, and R Blatt. 2016. Realization of a scalable Shor Algorithm. Science
351, 6277 (2016), 1068–1070.
[27] Chris Peikert et al. 2016. A decade of lattice cryptography. Foundations and
Trends® in Theoretical Computer Science 10, 4 (2016), 283–424.
[28] Oded Regev. 2006. Lattice-Based Cryptography. Springer Berlin Heidelberg.
131–141 pages.
[29] Oded Regev. 2009. On Lattices, Learning with Errors, Random Linear Codes, and
Cryptography. Journal of ACM 56, 6 (2009), 34:1–34:40.
[30] Cédric Van Rompay, Refik Molva, and Melek Önen. 2018. Secure and Scalable
Multi-User Searchable Encryption. In Proc. of SCC@AsiaCCS 2018. 15–25.
[31] Tateaki Sasaki and Hirokazu Murao. 1982. Efficient Gaussian Elimination Method
for Symbolic Determinants and Linear Systems. ACM Trans. on Mathematical
Software 8, 3 (1982), 277–289.
[32] Elaine Shi, John Bethencourt, Hubert T.-H. Chan, Dawn Xiaodong Song, and
Adrian Perrig. 2007. Multi-Dimensional Range Query over Encrypted Data. In
Proc. of IEEE S&P. 350–364.
[33] Peter W. Shor. 1994. Algorithms for Quantum Computation: Discrete Logarithms
and Factoring. In Proc. of IEEE FOCS. 124–134.
[34] Shifeng Sun, Joseph K. Liu, Amin Sakzad, Ron Steinfeld, and Tsz Hon Yuen.
2016. An Efficient Non-interactive Multi-client Searchable Encryption with
Support for Boolean Queries. In Computer Security - ESORICS 2016 - 21st European
Symposium on Research in Computer Security, Heraklion, Greece, September 26-30,
2016, Proceedings, Part I. 154–172.
[35] Shifeng Sun, Xingliang Yuan, Joseph K. Liu, Ron Steinfeld, Amin Sakzad, Viet Vo,
and Surya Nepal. 2018. Practical Backward-Secure Searchable Encryption from
Symmetric Puncturable Encryption. In Proc. of the ACM CCS. 763–780.
[36] Brent Waters. 2005. Efficient Identity-Based Encryption Without Random Oracles.
In Proc. of EUROCRYPT. 114–127.
[37] Brent R Waters, Dirk Balfanz, Glenn Durfee, and Diana K Smetters. 2004. Building
an Encrypted and Searchable Audit Log. In Proc. of NDSS.
[38] Lei Xu, Shifeng Sun, Xingliang Yuan, Joseph K Liu, Cong Zuo, and Chungen
Xu. 2019. Enabling Authorized Encrypted Search for Multi-Authority Medical
Databases. IEEE Transactions on Emerging Topics in Computing (2019).
Session 2B: Advanced Encryption AlgorithmsAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand133