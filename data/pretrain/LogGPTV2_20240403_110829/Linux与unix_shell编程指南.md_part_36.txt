加入java编程群：524621833
307
第27章 几个脚本例子
下载
他脚本共享设置的很好例子。
b a c k u p _ g e n是一个用于备份的脚本，它从一个缺省的配置文件中读入设置，然后根据这
些参数对系统进行备份。用户可以根据自己的需要改变这些缺省设置。这是一个不同脚本如
何使用相同设置或仅在自己运行期间改变相应设置的极好例子。当该脚本执行时，它首先确
认源文件b a c k u p . d e f a u l t s是否存在，如果不存在，则退出。
该脚本在运行时，会显示出一个题头和缺省设置，并询问用户是否需要改变任何缺省设
置。如果用户回答“是”，在他们修改设置之前，该脚本就会提示他们输入一个代码，用户可
以有三次机会；如果输入正确的代码后仍无法改变设置，这就意味着用户必须要使用缺省设
置。一般来说，在输入正确代码后，用户可以改变下列设置（ [ ]中的为缺省设置）：
• 磁带设备[ r m t 0 ] 可以选择r m t 1和r m t 3
• 备份完成后是否向系统管理员发邮件[是] 可以选择否
• 备份的类型[全备份] 可以选择普通备份或s y b a s e备份
脚本中使用了一些临时变量来保存被修改的设置。用户可以按回车键选择缺省设置。下
列设置不能被改变：
备份日志文件名。
用户代码。
接着所有的改变会生效。在这些改变生效之后，相应的临时变量又会被重新赋予缺省值。
在备份进行之前，首先要测试磁带设备。备份过程使用 f i n d和c p i o命令，它们从设置文件中读
入相应变量的缺省值，或使用用户设定的值。
下面就是该脚本。
加入java编程群：524621833
308
第五部分 高级s h e l l编程技巧
下载
加入java编程群：524621833
309
第27章 几个脚本例子
下载
加入java编程群：524621833
310
第五部分 高级s h e l l编程技巧
下载
源文件backup.defaults中包含函数continue_prompt，还有所有缺省设置。下面就是该源文件。
加入java编程群：524621833
311
第27章 几个脚本例子
下载
下面是该脚本运行时的输出，缺省设置被显示在屏幕上，用户被询问是否要改变这些设
置：
加入java编程群：524621833
312
第五部分 高级s h e l l编程技巧
下载
下面是用户改变缺省值的过程。在下面的例子中，备份类型被用户改变，但是该脚本在
检查了相应的磁带设备之后，发现它有点问题。在使用了最后一个状态命令之后，该脚本将
会退出。
27.3 del.lines
之所以要编写这个脚本，是因为应用程序开发者总是问我“用s e d的哪个命令删除空行？”。
我决定写一个小脚本给他们使用，以免他们老是打电话问我这个命令。
这个脚本只是包装了一下s e d命令，但它能够使用户很方便地使用，他们非常喜欢用。
脚本一般都不长。如果你认为写一个脚本能够使某些任务自动化，能够节约时间，那么
你就可以编写一个脚本。
这个脚本可以处理一个或多个文件。每个文件在用 s e d删除空行之前要先核实是否存在。
s e d的输出被导入一个文件名中含有$ $的临时文件，最后这个临时文件又被移回到原来的文件
中。
该脚本使用s h i f t命令取得所有的文件名，用w h i l e循环逐个处理所有的文件，直至处理完
为止。
可以使用del.lines -help获得一个简短的帮助。你也可以创建一个更好的帮助。
下面是该脚本。
加入java编程群：524621833
313
第27章 几个脚本例子
下载
27.4 access.deny
在对系统进行某些更新时，你可能不希望用户登录，这时可以使用 / e t c / n o l o g i n文件，大
多数系统都提供这个文件。一旦在 / e t c目录中使用t o u c h命令创建了一个名为n o l o g i n的文件，
除r o o t以外的任何用户都将无法登录。
如果系统不支持这种方法，你一样还可以做到这点—可以自己创建这个文件，下面就是
具体的做法。
可以在/ e t c / p r o f i l e文件中加入下面的代码：
现在，可以通过在/ e t c目录下创建n o l o g i n文件来阻止除根用户以外的其他用户登录。记住，
该文件要对所有用户可读。
加入java编程群：524621833
314
第五部分 高级s h e l l编程技巧
下载
当决定恢复用户登录时，只要删除该文件即可。
rm /etc/nologin
上述办法可以很方便地组织除根用户外的所有用户登录。如果希望临时禁止某个用户登
录，可以修改/ e t c / p a s s w d文件，把该用户的口令域的第一个字符变成 *。不过，这个问题比较
复杂，在操作之前一定要搞清楚，否则会带来系统性的问题。
L I N U X提供了一个工具，可以通过它在 l o g i n . a c c e s s文件中写入用户名和用户组。该文件
可以用来允许或禁止用户对系统的访问。
这里有一个上述工具的简化版本d e n y. a c c e s s。该脚本从/ e t c / p r o f i l e文件中运行，它读入一
个名为l o c k o u t . u s e r s的文件。该文件包含有禁止登录的用户名。如果该文件中出现了 a l l这个单
词，那么除r o o t以外的所有用户都将被禁止登录。
下面是l o c k o u t . u s e r s文件的一个例子，该文件可以包含注释行。
下面解释该脚本的工作过程。首先，通过设置t r a p忽略所有的信号，这样用户就无法中断它
的执行。如果文件l o c k o u t . u s e r s存在，那么脚本将会继续运行。它首先检查该文件中是否存在单
词a l l，如果存在，就不再检查该文件中的其他用户名，并禁止除根用户以外的所有其他用户登
录。不要使用注释来屏蔽单词a l l，因为这样它仍然有可能起作用。不过你可以注释用户名。
如果单词a l l被找到，那么除r o o t外的所有用户都将无法登录。为了准确起见，在该脚本中
使用了g r e p的精确匹配模式a l l \ >。这时用户将会在屏幕上看到系统不可用的消息。
该脚本中的主要函数是get_users 。它读入文件l o c k o u t . u s e r s，忽略所有以#开头的注释行。
它通过比较用户名来确保用户名r o o t没有出现在该文件中，即使出现也不会禁止 r o o t登录，否
则后果将难以想象。
当前正在登录的用户名可以从变量L O G N A M E中得到，并与变量N A M E S做比较，而变量
N A M E S的内容来自于l o c k o u t . u s e r s文件。如果匹配，相应用户的登录进程将被终止。
我在几个拥有近4 0个用户的系统上运行该脚本，它并没有影响用户登录的速度。当用户
外出超过一周或者用户午餐，而我需要对系统进行更新时，我就使用该脚本临时锁住相应的
帐户。
需要在/ e t c / p r o f i l e文件中加入这样一行。我把它加在该文件的末尾，这样即使用户无法登
录，也可以在此之前看见当前发给他的新消息。
. /apps/bin/deny.access
/ a p p s / b i n目录是我存放全局性脚本的地方—你可能把这些脚本放在另外的目录中，不过
加入java编程群：524621833
315
第27章 几个脚本例子
下载
一定要确保所有用户都对该脚本及存放它的目录具有执行权限。
如果得到“权限不足”的错误提示，那说明该脚本或目录的权限不足。
我的l o c k o u t . u s e r s文件放在/ a p p s / e t c目录下。如果你的系统的目录结构有所不同的话，应
该作出相应的调整。由于该文件在登录时被引用，可以使用 s e t命令看到相应的函数（不过无
法看到l o c k o u t . u s e r s文件）。如果你觉得这不妥，只要在这些函数执行后使用 u n s e t命令去掉它
们即可。可以把u n s e t命令直接放在/ e t c / p r o f i l e文件中该命令行之后，就像这样：
unset getusers
下面就是该脚本。
加入java编程群：524621833
316
第五部分 高级s h e l l编程技巧
下载
27.5 logroll
我的系统中的有些日志文件增长十分迅速，每天手工检查这些日志文件的长度并倒换这
些日志文件（通常是给文件名加个时间戳）是非常乏味的。于是我决定编写一个脚本来自动
完成这项工作。该脚本将提交给 c r o n进程来运行，如果某个日志文件超过了特定的长度，那
么它的内容将被倒换到另一个文件中，并清除原有文件中的内容。
你可以很容易地改编这个脚本用于清除其他的日志文件。我使用另外一个脚本来清除我的
系统日志文件，它每周运行一次，截断相应的日志文件。如果我需要再回头看这些日志文件，
只需在备份中寻找即可，这些日志文件的备份周期为1 6周，这个周期长度应该说是足够了。
该脚本中日志文件的长度限制是由变量 B L O C K _ L I M I T设定的。这一数字代表了块数目，
在本例中是8块（每块大小为4 K字节）。可以按照自己的需求把这一数字设得更高。所有我要
检查的日志文件名都保存在变量L O G S中。
这里使用了一个f o r循环来依次检查每一个日志文件，使用 d u命令来获取日志文件长度。
如果相应的文件长度大于 B L O C K _ L I M I T变量所规定的值，那么该文件将被拷贝到一个文件
名含有时间戳的文件中，并改变这个文件所属的组，原先的文件长度将被截断为 0。
该脚本由c r o n每周运行几次，生成了一些文件名中含有时间戳的日志文件备份，这样如
果系统出现了任何问题，我还可以回到这些备份中查找。
加入java编程群：524621833
317
第27章 几个脚本例子
下载
27.6 nfsdown
如果系统中包含n f s文件系统，你将发现下面的脚本非常实用。我管理着几台主机，不时
地需要在工作时间重启动其中的某台机器。这种重启动过程当然是越快越好。
由于我在好几个机器上都挂接了远程目录，我不想依靠系统的重启动过程来卸载这些 n f s
文件系统，宁愿自己来完成这个工作。这样还可以更快一些。
只要运行这个脚本就可以迅速卸载所有的n f s文件系统，这样就能更快的重新启动机器。
该脚本的L I S T变量中含有提供n f s目录的主机名。使用f o r循环逐一卸载相应的目录，用
g r e p命令在d f命令的结果中查找n f s文件系统。n f s目录的m o u n t形式为：
machine: remote_directory
这一字符串被保存在变量N F S _ M A C H I N E中。在u m o u n t命令中使用了该变量。
下面就是该脚本：
27.7 小结
本章中所提供的脚本都是我最常用的。正如前面所提到的，脚本不一定很长、很复杂，
但是它却不失为一种高效的方法。
加入java编程群：524621833
下载
第28章 运行级别脚本
如果希望在系统启动时自动运行某些应用程序、服务或脚本，或者在系统重启动时能够
正确地关闭这些程序，那么需要创建运行级别脚本。除一种 L I N U X变体外，所有的L I N U X版
本都含有这种基于系统V的运行级别配置目录，就像其他U N I X版本那样。
既然所有的系统都含有这种类型的配置，我们在本章中将会对它加以介绍，但如果你的
系统不含有这种目录，也不要紧。还可以通过其他方法在系统启动时自动运行程序；本章的
后半部分也将介绍这些方法。
本章包含下列内容：
• 运行级别。
• 如何创建r c . s c r i p t s。
• 如何在不同的运行级别实现相应的r c . s c r i p t s。
• 如何从i n i t t a b中启动应用程序。
能够创建运行级别脚本就意味着能够更灵活地控制系统。如果需要在某一个特定的运行
级别启动或停止程序，就得创建运行级别脚本（它们通常被称为 r c . s c r i p t）。
任何用关键字 s t a r t或s t o p调用的、能够启动或停止程序运行的脚本都可以看作是一个
r c . s c r i p t。注意，应当由用户来保证他或她所提交的脚本是一个有效的脚本，能够正确地启动
或停止某一服务。
运行级别配置目录的机制使得r c . s c r i p t只在系统切换运行级别时有效。它不负责检查某一
运行级别中所有的特定服务是否都已经被启动或停止。这是 s h e l l编程者的事。
还可以按照希望运行的服务来控制系统的运行级别，但是这已经超出了本书的讨论范围。
28.1 怎么知道系统中是否含有运行级别目录
r c . s c r i p t s一般保存在 (实际上是个链接，这一点我们将在后面讲述 ) / e t c / r c N . d或
/ e t c / r c . d / r c N . d目录下，
其中，N是一个数字。通常是7个，因为r c N . d目录的序号是从0到6，不过在系统上可能会
有另外几个目录，如r c S . d。这并不重要，这里我们只关心带有数字的目录。