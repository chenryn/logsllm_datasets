户都有不同的IP地址，IP地址（如果会发生变化的话）也很少会发生变化，而且
Web服务器可以判断出每条请求的客户端IP地址的话，这种方案是可行的。通常
在HTTP首部并不提供客户端的IP地址，1但Web服务器可以找到承载HTTP请求
的TCP连接另一端的IP地址。
比如，在Unix系统中，函数调用getpeername就可以返回发送端机器的客户端IP地址：
status = getpeername(tcp_connection_socket,...);
但是，使用客户端IP地址来识别用户存在着很多缺点，限制了将其作为用户识别技
术的效能。
• 客户端IP地址描述的是所用的机器，而不是用户。如果多个用户共享同一台计
算机，就无法对其进行区分了。
• 很多因特网服务提供商都会在用户登录时为其动态分配IP地址。用户每次登录
时，都会得到一个不同的地址，因此Web服务器不能假设IP地址可以在各登录
259 会话之间标识用户。
• 为了提高安全性，并对稀缺的地址资源进行管理，很多用户都是通过网络地址转
换（Network Address Translation，NAT）防火墙来浏览网络内容的。这些NAT
设备隐藏了防火墙后面那些实际客户端的IP地址，将实际的客户端IP地址转换
成了一个共享的防火墙IP地址（和不同的端口号）。
• HTTP代理和网关通常会打开一些新的、到原始服务器的TCP连接。Web服务
器看到的将是代理服务器的IP地址，而不是客户端的。有些代理为了绕过这个
问题会添加特殊的Client-IP或X-Forwarded-For扩展首部来保存原始的IP
地址（参见图11-1）。但并不是所有的代理都支持这种行为。
有些Web站点仍然使用客户端IP地址在会话之间跟踪用户的行为，但这种站点并
不多。无法用IP地址确定目标的地方太多了。
注1：稍后我们会看到，有些代理确实会添加一个Client-IP首部，但这并不是HTTP标准的一部分。
274 ｜ 第11章
代理服务器
客户端 56.41.11.4 服务器
209.172.34.56 Client-ip: 209.172.34.56
X-Forwarded-For: 209.172.34.56
图11-1 代理可以添加扩展首部，来传递原始客户端的IP地址
少数站点甚至将客户端IP地址作为一种安全特性使用，它们只向来自特定IP地址
的用户提供文档。在内部网络中可能可以这么做，但在因特网上就不行了，主要是
因为因特网上IP地址太容易被欺骗（伪造）了。路径上如果有拦截代理也会破坏此
方案。第14章讨论了一些强大得多的特权文档访问控制策略。
11.4 用户登录
Web服务器无需被动地根据用户的IP地址来猜测他的身份，它可以要求用户通过
用户名和密码进行认证（登录）来显式地询问用户是谁。
为了使Web站点的登录更加简便，HTTP中包含了一种内建机制，可以用 WWW-
Authenticate首部和Authorization首部向Web站点传送用户的相关信息。一
旦登录，浏览器就可以不断地在每条发往这个站点的请求中发送这个登录信息了，
这样，就总是有登录信息可用了。我们将在第12章对这种HTTP认证机制进行更加
详细的讨论，现在我们先来简单地看一看。
260
如果服务器希望在为用户提供对站点的访问之前，先行登录，可以向浏览器回送一
条HTTP响应代码401 Login Required。然后，浏览器会显示一个登录对话框，并
用Authorization首部在下一条对服务器的请求中提供这些信息。2图11-2对此
进行了说明。
此图中发生的情况如下所述。
• 在图11-2a中，浏览器对站点www.joes-hardware.com发起了一条请求。
• 站点并不知道这个用户的身份，因此在图11-2b中，服务器会返回401 Login
Required HTTP响应码，并添加WWW-Authentication首部，要求用户登录。
这样浏览器就会弹出一个登录对话框。 261
注2： 为了不让用户每发送一条请求都要登录一次，大多数浏览器都会记住某站点的登录信息，并将登录信
息放在发送给该站点的每条请求中。
客户端识别与cookie机制 ｜ 275
(a)
GET /index.html HTTP/1.0
Host: www.joes-hardware.com
因特网
客户端 服务器
(b)
HTTP/1.0 401 Login Required
WWW-authenticate: Basic realm="Plumbing and Fixtures"
因特网
客户端 服务器
(c)
GET /index.html HTTP/1.0
Host: www.joes-hardware.com
Authorization: Basic am910jRmdW4=
因特网
客户端 服务器
(d)
HTTP/1.0 200 OK
Content-length: 4342
Content-type: text/html
...
因特网
客户端 服务器
图11-2 用HTTP 认证首部注册用户名
• 只要用户输入了用户名和密码（对其身份进行完整性检查），浏览器就会重复原
来的请求。这次它会添加一个Authorization首部，说明用户名和密码。对用
户名和密码进行加密，防止那些有意无意的网络观察者看到。3
• 现在，服务器已经知道用户的身份了。
• 今后的请求要使用用户名和密码时，浏览器会自动将存储下来的值发送出去，甚
至在站点没有要求发送的时候也经常会向其发送。浏览器在每次请求中都向服务
器发送Authorization首部作为一种身份的标识，这样，只要登录一次，就可
以在整个会话期间维持用户的身份了。
注3： 在第14章我们会看到，任何有这种想法的人，不用费多大事就可以轻易地将HTTP基本的认证用户
名和密码破解出来。稍后将讨论一些更安全的技术。
276 ｜ 第11章
但是，登录多个Web站点是很繁琐的。Fred从一个站点浏览到另一个站点的时候，
需要在每个站点上登录。更糟的是，可怜的Fred很可能要为不同的站点记住不同的
用户名和密码。他访问很多站点的时候，他最喜欢的用户名fred可能已经被其他人
用过了，而且有些站点为用户名和密码的长度和组成设置了不同的规则。Fred很快
就会放弃上网，回去看奥普拉（Oprah）的脱口秀了。下一节我们来讨论这个问题
的解决方案。
11.5 胖URL
有些Web站点会为每个用户生成特定版本的URL来追踪用户的身份。通常，会对
真正的URL进行扩展，在URL路径开始或结束的地方添加一些状态信息。用户浏
览站点时，Web服务器会动态生成一些超链，继续维护URL中的状态信息。
改动后包含了用户状态信息的URL被称为胖URL（fat URL）。下面是Amazon.com
电子商务网站使用的一些胖URL实例。每个URL后面都附加了一个用户特有的标
识码（在这个例子中就是002-1145265-8016838），这个标识码有助于在用户浏览商
店内容时对其进行跟踪。 262
...
All Gifts
Wish
List
...
Salute Our Troops
Free Shipping
Easy Returns
...
可以通过胖URL将Web服务器上若干个独立的HTTP事务捆绑成一个“会话”或
“访问”。用户首次访问这个Web站点时，会生成一个唯一的ID，用服务器可以识
别的方式将这个ID添加到URL中去，然后服务器就会将客户端重新导向这个胖
URL。不论什么时候，只要服务器收到了对胖URL的请求，就可以去查找与那个用
户ID相关的所有增量状态（购物车、简介等），然后重写所有的输出超链，使其成
为胖URL，以维护用户的ID。
可以在用户浏览站点时，用胖URL对其进行识别。但这种技术存在几个很严重的问题。
• 丑陋的URL
浏览器中显示的胖URL会给新用户带来困扰。
客户端识别与cookie机制 ｜ 277
• 无法共享URL
胖URL中包含了与特定用户和会话有关的状态信息。如果将这个URL发送给其
他人，可能就在无意中将你积累的个人信息都共享出去了。
• 破坏缓存
为每个URL生成用户特有的版本就意味着不再有可供公共访问的URL需要缓存了。
• 额外的服务器负荷
服务器需要重写HTML页面使URL变胖。
• 逃逸口
用户跳转到其他站点或者请求一个特定的URL时，就很容易在无意中“逃离”
胖URL会话。只有当用户严格地追随预先修改过的链接时，胖URL才能工作。
如果用户逃离此链接，就会丢失他的进展（可能是一个已经装满了东西的购物
车）信息，得重新开始。
• 在会话间是非持久的
除非用户收藏了特定的胖URL，否则用户退出登录时，所有的信息都会丢失。
11.6 cookie
cookie是当前识别用户，实现持久会话的最好方式。前面各种技术中存在的很多问
题对它们都没什么影响，但是通常会将它们与那些技术共用，以实现额外的价值。
cookie最初是由网景公司开发的，但现在所有主要的浏览器都支持它。
cookie非常重要，而且它们定义了一些新的HTTP首部，所以我们要比前面那些技
术更详细地介绍它们。cookie的存在也影响了缓存，大多数缓存和浏览器都不允许
263 对任何cookie的内容进行缓存。后面的小节对此进行了更为详细的介绍。
11.6.1 cookie的类型
可以笼统地将 cookie 分为两类：会话 cookie 和持久 cookie。会话 cookie 是一种
临时cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话
cookie就被删除了。持久cookie的生存时间更长一些；它们存储在硬盘上，浏览器
退出，计算机重启时它们仍然存在。通常会用持久cookie维护某个用户会周期性访
问的站点的配置文件或登录名。
会话cookie和持久cookie之间唯一的区别就是它们的过期时间。稍后我们会看到，
如果设置了Discard参数，或者没有设置Expires或Max-Age参数来说明扩展的
278 ｜ 第11章
过期时间，这个cookie就是一个会话cookie。
11.6.2 cookie是如何工作的
cookie就像服务器给用户贴的“嗨，我叫”的贴纸一样。用户访问一个Web站点
时，这个Web站点就可以读取那个服务器贴在用户身上的所有贴纸。
用户首次访问Web站点时，Web服务器对用户一无所知（参见图11-3a）。Web服
务器希望这个用户会再次回来，所以想给这个用户“拍上”一个独有的cookie，这
样以后它就可以识别出这个用户了。cookie中包含了一个由名字=值（name=value）
这样的信息构成的任意列表，并通过Set-Cookie或Set-Cookie2 HTTP响应（扩
展）首部将其贴到用户身上去。
(a)
GET /index.html HTTP/1.0
Host: www.joes-hardware.com
因特网
客户端 服务器
HTTP/1.0 200 OK
(b) Set-cookie: id="34294"; domain="joes-hardware.com"
Content-type: text/html
Content-length: 1903
Set-Cookie ...
id="34294"
因特网
客户端 服务器
(c)
GET /index.html HTTP/1.0
Host: www.joes-hardware.com Cookie
Cookie: id="34294"
id="34294"
因特网
客户端 服务器
图11-3 给用户贴一个cookie
cookie中可以包含任意信息，但它们通常都只包含一个服务器为了进行跟踪而产
生的独特的识别码。比如，在图11-3b中，服务器会将一个表示 id="34294"的
cookie贴到用户上去。服务器可以用这个数字来查找服务器为其访问者积累的数据
库信息（购物历史、地址信息等）。
客户端识别与cookie机制 ｜ 279
但是，cookie并不仅限于ID号。很多Web服务器都会将信息直接保存在cookie中。
比如：
Cookie: name="Brian Totty"; phone="555-1212"
浏览器会记住从服务器返回的Set-Cookie或Set-Cookie2首部中的cookie内
容，并将cookie集存储在浏览器的cookie数据库中（把它当作一个贴有不同国家贴
纸的旅行箱）。将来用户返回同一站点时（参见图11-3c），浏览器会挑中那个服务
器贴到用户上的那些cookie，并在一个cookie请求首部中将其传回去。
11.6.3 cookie罐：客户端的状态
cookie的基本思想就是让浏览器积累一组服务器特有的信息，每次访问服务器时都
264 将这些信息提供给它。因为浏览器要负责存储cookie信息，所以此系统被称为客户
端侧状态（client-side state）。这个cookie规范的正式名称为HTTP状态管理机制
（HTTP state management mechanism）。
1. 网景的Navigator的cookie