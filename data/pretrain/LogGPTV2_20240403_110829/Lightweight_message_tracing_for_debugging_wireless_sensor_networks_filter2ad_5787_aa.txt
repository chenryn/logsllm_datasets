title:Lightweight message tracing for debugging wireless sensor networks
author:Vinaitheerthan Sundaram and
Patrick Eugster
Lightweight Message Tracing for Debugging
Wireless Sensor Networks
∗School of Electrical and Computer Engineering, †Department of Computer Science
Vinaitheerthan Sundaram∗, Patrick Eugster†
Purdue University, West Lafayette IN 47907 USA
Email: {vsundar, peugster}@purdue.edu
Abstract—Wireless sensor networks (WSNs) deployments are
subjected not infrequently to complex runtime failures that are
difﬁcult to diagnose. Alas, debugging techniques for traditional
distributed systems are inapplicable because of extreme resource
constraints in WSNs, and existing WSN-speciﬁc debugging so-
lutions address either only speciﬁc types of failures, focus on
individual nodes, or exhibit high overheads hampering their
scalability.
Message tracing is a core issue underlying the efﬁcient and
effective debugging of WSNs. We propose a message tracing
solution which addresses key challenges in WSNs — besides
stringent resource constraints, these include out-of-order message
arrivals and message losses — while being streamlined for
the common case of successful in-order message transmission.
Our approach reduces energy overhead signiﬁcantly (up to
95% and on average 59% smaller) compared to state-of-the-
art message tracing approaches making use of Lamport clocks.
We demonstrate the effectiveness of our approach through case
studies of several complex faults in three well-known distributed
protocols.
I. INTRODUCTION
Wireless sensor networks (WSNs) consist of many tiny,
battery-powered sensor nodes equipped with wireless radios
(a.k.a. motes) that sense the physical world and transmit the
sensed information to a central “base station” computer via
multi-hop wireless communication. Their small form factor
and battery powered, wireless nature, makes WSNs suitable
for a multitude of indoor and outdoor applications including
environment monitoring (volcano [1], glacier [2]), structural
monitoring (bridges [3]), border surveillance, and industrial
machinery monitoring (datacenters [4]).
With WSNs being increasingly deployed to monitor phys-
ical phenomena in austere scientiﬁc, military, and industrial
domains, runtime failures of various kinds are observed in
many deployments [5], [1], [6]. In addition to node or link
failures, failures engendered by complex interplay of software,
infrastructure, and deployment constraints exhibiting as data
races, timestamp overﬂows, transient link asymmetry, or lack
of synchronization have been observed in distributed WSN
protocols and applications [7], [8], [9]. Unexpected environ-
mental factors arising from in situ deployment constitute the
major cause for runtime failures occurring in WSNs despite
careful design and validation. Runtime debugging tools con-
stitute a promising approach to detect and diagnose generic
runtime failures in WSNs.
Runtime debugging is a challenging problem even in
“traditional” resource-rich wireline networks. While online
debugging techniques [10], [11] are useful in reducing the
latency of fault detection and diagnosis, they tend to incur
high runtime overhead and are susceptible to Heisenbugs
(faults that disappear when the system is observed). Ofﬂine
debugging techniques [12], [13], [14], [15], [16], [17], [18]
are inapplicable in WSNs as large amounts of data memory
and non-volatile memory are required to store megabytes of
traces generated for subsequent ofﬂine mining.
WSN-speciﬁc online debugging approaches [19], [20], [21],
[22], [8] focus on providing visibility into the network as well
as remote control of it. While these approaches are very useful
for small-scale testbeds, they are not suitable for debugging
after deployment, as they are energy-inefﬁcient and are highly
susceptible to Heisenbugs due to non-trivial
intrusion via
computation and communication overheads. Several WSN-
speciﬁc trace-based ofﬂine debugging techniques have thus
been proposed [23], [24], [25], [26], [27], [9], [28]. Some of
these solutions [23], [24] focus on coarse-grained diagnosis,
where the diagnosis pinpoints a faulty node or link, or net-
work partition. Some approaches achieve automation [28] but
require multiple reproduction of failures to learn the correct
behavior with machine learning techniques. Some other ap-
proaches [26], [27], [9] focus on node-level deadlocks or data
races. While these ofﬂine solutions are useful for diagnosing
various runtime failures, they do not support generic, resource-
friendly distributed diagnosis of complex failures occurring
through sensor node interaction, in end applications as well
as core protocols.
Tracing of message sends and receives is a cornerstone of
distributed diagnostic tracing. To faithfully trace distributed
program behavior, it is of utmost importance to be able to
accurately pair message sends (cause) and receives (effects).
When observing distributed failures in WSNs (see Section IV)
four speciﬁc key constraints for a generic and efﬁcient message
tracing solution emerge:
1) Resource constraints. As stated, WSNs are highly
resource-constrained, and thus mechanisms for tracing
distributed interaction via message sends and receives
must impose only overheads. In particular, traces on
individual nodes should be well compressible to reduce
storage and communication overheads, which dominate
the tracing overhead [9], [27].
978-1-4799-0181-4/13/$31.00 ©2013 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:58:43 UTC from IEEE Xplore.  Restrictions apply. 
2) Message losses. Pairing of message sends and receives
can not simply be inferred from sequences of such
events, when individual messages can get lost. Yet, due
to the inherent dynamic nature of WSNs, best-effort
transmission protocols are commonly used directly.
3) Out-of-order reception. Similarly, basic communication
protocols used directly by end applications and other
protocols do not provide ordered message delivery,
which adds to the difﬁculty of pairing up message sends
and receives.
4) Local purging. When trace storage is full, the decision
to rewrite the trace storage has to be a local decision
for energy efﬁciency purposes. Since external ﬂash is
very limited (about 512KB - 1MB), the traces ﬁll the
storage quickly. Purging traces locally at arbitrary points
of the execution complicates pairing up message sends
and receives.
The state-of-the-art fails in some requirements (see Sec-
tion II-B). This holds in particular for the golden standard
— originating from wireline networks [16], [29], [18], [13],
[30], [14] and then adapted for WSNs [31] — consisting in
identifying messages with Lamport clocks [32] paired with
sender identiﬁers: besides generating false positives at replay
(Lamport clocks being complete but not accurate) this solution
does not inherently support losses and is not as lightweight as
it may seem at ﬁrst glance.
In this paper, we propose a novel message tracing scheme
for WSNs that satisﬁes all the four requirements above. Our
approach exploits restricted communication patterns occurring
in WSNs and consists of three key ideas: (1) use of per-channel
sequence numbers, which enables postmortem analysis to
recover original ordering despite message losses and out-of-
order message arrivals, (2) address aliasing, where each node
maintains a smaller id for other nodes it communicates more
often with, and (3) optimization for the common case of in-
order reliable delivery. We combine our message traces with
the local control-ﬂow trace of all events generated by the state-
of-the-art [9], [27] to get the entire trace of the distributed
system.
Speciﬁcally, this paper makes the following contributions:
• We present a novel distributed message tracing technique
that satisﬁes our four constraints.
• We show the effectiveness of
the distributed traces
achieved by our message tracing technique in combina-
tion with control-ﬂow path encoding for individual sensor
nodes with the open-source TinyTracer [9] framework
via several real-world WSNs distributed protocol faults
described in the literature.
• We analytically demonstrate the signiﬁcant reduction in
trace size and empirically demonstrate the ensuing energy
savings (up to 95% and on average 59%) of our technique
over the state-of-the-art, irrespective of its inconsistencies
in tracing of communication (and thus misdiagnosis) in
the presence of message losses and out-of-order message
arrivals.
Section II deﬁnes the problem with necessary background.
Section III presents the design and implementation of our
approach. Section IV shows the effectiveness of our approach
through case studies of several common distributed protocols
in WSNs. Section V shows space efﬁciency analytically.
Section VI shows energy efﬁciency empirically. Section VII
discusses related work and Section VIII concludes the paper.
II. BACKGROUND AND PROBLEM DEFINITION
In this section, we ﬁrst describe the existing approaches in
trace-based debugging. We then relate these to the challenges
speciﬁc to WSNs and identify key requirements for tracing to
be useful for distributed faults diagnosis in WSNs.
A. Trace-based Debugging of Distributed Systems
Trace-based replay debugging [16], [18] is a promising
approach for debugging distributed systems [12]. A correct
replay is one in which the causal ordering of messages ob-
served in the original execution is maintained. Causal ordering
of messages is deﬁned as follows. A message send causally
precedes its corresponding receive, and any subsequent sends
by the same process. If a message m1 received by a node
before it sends another message m2, then m1 causally precedes
message m2. Causal ordering is transitive, i.e., if m1 causally
precedes m2 and m2 causally precedes m3, then m1 causally
precedes m3.
To obtain the causal ordering of the original execution, the
message dependences have to be recorded in the trace. In
trace-based replay solutions [33], [29] for wired distributed
systems, the message dependences are captured using logical
clocks [32], [34]. Originally proposed for enforcing ordering
of events (including messages) in fundamental distributed
systems problems such as ordered broadcast and mutual ex-
clusion, logical clocks are used here to capture the ordering
during the original execution and recreate it in the replay.
Lamport clocks [32] use a single integer maintained by
each node. While scalable, they are inaccurate meaning some
concurrent events are classiﬁed as causally related. This inac-
curacy can slow down replay of a network because concurrent
events can be replayed in parallel threads, and yield false
positives. To overcome inaccuracy, vector clocks [34] can be
used which precisely capture concurrent and causally related
events. Vector clocks have been used to identify racing mes-
sages and by recording only those racing messages, trace sizes
can be reduced considerably [35]. Since vector clocks maintain
n integers, where n is the number of nodes in the network
they impose high overhead and do not scale well. Between
these two extremes of Lamport clocks and vector clocks,
there are other logical clocks such as plausible clocks [36] or
hierarchical clocks [37]. However, most tracing-based replay
solutions [33], [29] use Lamport clocks because of their ease
of implementation and scalability.
B. Inapplicability of Existing Approaches
Existing trace-based replay solutions for wired distributed
systems work under the assumptions of abundance of energy
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:58:43 UTC from IEEE Xplore.  Restrictions apply. 
(a) Out-of-order message arrivals
(b) Message loss
(c) Local purging
Fig. 1.
Examples showing the shortcomings of Lamport-clock based message tracing when pairing message receive events with the corresponding send
events in the presence of unreliable channels or arbitrary local purging of traces. The traces from processes P 0 and P 1 are shown below the space-time
representation of processes. Figure 1(a) shows a simple example with a same trace being generated in both cases where messages arrive in order and out of
order. It is impossible to correctly identify out-of-order arrivals from the trace during post-mortem analysis, implying that message receive events cannot be
paired with corresponding sends. Figure 1(b) shows an example in which it is impossible to identify which message was lost from the trace during postmortem
analysis. Figure 1(c) shows an example in which it is impossible to tell whether the receive event 7 in process P 1 pairs with send event 2 or 3 in process
P 0 just by looking at the traces. The square black dots represent the points in time where the local traces are purged.
(connected to wall-socket), storage in the order of gigabytes,
and network bandwidth in the order of at least kilobytes per
second. More importantly, these distributed applications are
assumed to run on top of a FIFO reliable communication layer
such as TCP. These assumptions do not hold in WSNs and any
WSN message tracing solution should cope with (1) strin-
gent resource constraints, (2) out-of-order message arrivals,
(3) message losses, and (4) local purging. Furthermore, the
resource constraints in WSNs requires the traces recorded to be
highly compressible, which means newly recorded information
has less variability from previously recorded information. We
show that the existing approaches cannot cope with unrelia-
bility and local purging as well as are not very compressible.
The existing approaches that record logical clocks alone
cannot recreate the causal order correctly in the presence of
unreliability. This is true even for approaches using vector
clocks [38]. Combining Lamport clocks with sender addresses
as proposed by Shea [31] can still lead to inconsistent causal
ordering due to unreliable communication. We show this in the
case for Lamport clocks with the help of counter-examples.
Figure 1 shows the counter-examples as a space-time dia-
gram representation of processes and their message interaction.
The horizontal lines in the space-time diagram represent the
processes with time increasing from left to right and the arrows
represent messages, with the direction of arrow from sender
to receiver. The traces contain the event type (send/receive),
process identiﬁer, and the Lamport clock value. Such traces
cannot correctly pair up message send events with their corre-
sponding receive events when there are out-of-order message
arrivals, message losses or arbitrary local purging of traces.
Figure 1(a) illustrates that the traces cannot correctly pair up
message send events with their corresponding receive events
when the underlying channel can reorder messages. In this
example, it is not possible to pair the receive events 3 and 4
in process P 0 with the corresponding send events.
Figure 1(b) illustrates that the traces cannot identify the
message send event corresponding to a lost message. In this
example, it is impossible to pair the receive event 4 in process
P 0 with the corresponding send event.
Figure 1(c) illustrates that the traces cannot correctly pair up
message send events with their corresponding receive events
when the traces are purged locally to handle full trace buffers.
The black square dots represent the points in time when the
traces are locally purged. The traces shown for process P 0 and
process P 1 are the snapshots of the respective trace buffers.