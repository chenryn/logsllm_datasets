警告信息之后可以看到make以-M选项调用gcc以及执行sed命令的动作。请注意，
make必须调用flex以便创建lexer.c，然后在开始满足默认目标之前删除lexer.c这个
临时文件。
这一节只介绍了自动产生依存关系的功能，还有许多没有谈到，像是如何为其他语言产
生依存关系或是编译树的布局。我们将会在本书的第二部分深入探讨这方面的议题。
管理程序库
程序库（archivelibrary，通常简称为library或archive）是一个特殊的文件，该文件内
含其他被称为成员（member）的文件。程序库可用来将相关的目标文件聚集成较容易操
作的单元。例如，C的标准程序库libc.a就包含了许多低级的C函数。因为程序库如此
常见，所以make对它们的创建、维护以及引用提供了特别的支持。程序库的建立及修
改可通过ar程序来进行。
用的程序库里。这个程序库由两个文件组成：counter.o和lexer.o。我们可以使用ar命
令来创建此程序库：
$ar rv libcounter.acounter.olexer.o
a-counter.o
a-lexer.o
选项r代表我们想要以指定的目标文件来替换（replace）程序库里的成员，而选项v代
表ar必须详细地（verbosely）告诉我们，它做了哪些动作。即使该程序库原本就不存
在，我们还是可以使用r选项。rV选项之后的第一个参数是程序库的文件名，接着是一
串目标文件（如果该程序库不存在，则有些版本的ar必须指定c选项，才会进行创建
（create）程序库的动作，不过对于GNUar不必这么做）。执行ar命令之后所显示的
信息里，你将会看到它以“a”来表示目标文件已被加入程序库里了。
以r选项来使用ar命令，可让我们立即创建或更新一个程序库：
Sarrv1ibcounter.a counter.o
r-counter.o
Sar rv libcounter.a lexer.o
r-1exer.o
执行ar命令之后所显示的信息里，你将会看到它以“r”来表示目标文件已被替换到程
序库中。
---
## Page 56
46
第二章
一个程序库被链接到一个可执行文件的方法有好几种，最简单的方法就是在命令行上直
接指定该程序库。编译器或链接器将会以文件的扩展名来判断命令行上特定文件的类型
并做正确的事情：
cccount_words.o1ibcounter.a/lib/libfl.a-ocount_words
此处，cc将会把libcounter.a和/lib/libfl.a这两个文件视为程序库，并对它们搜索未定
义的符号。在命令行上引用程序库的另一个方法就是使用-1选项：
cc count_words.o-lcounter-lf1-ocount_words
如你所见，使用这个选项可以省略程序库文件名的前缀（prefix）以及扩展名（suffix）。
1选项可让命令行更加紧凑并且较容易阅读，不过它还具有极为有用的功能：当cc看
到-1选项时，就会在系统的标准程序库目录中搜索相应的程序库。这样，程序员就不
必知道程序库的确切位置，而且可以让其所使用的命令行更具可移植性。此外，在支持
共享程序库（在Unix系统上就是以.so为扩展名的程序库）的系统上，链接器在搜索程
序库（archivelibrary）之前，会先搜索共享程序库（sharedlibrary）。这让程序在未指
明的状况下也能得益于共享程序库。这是GNU的链接器/编译器默认的行为模式。较旧
版的链接器/编译器并不会进行此优化动作。
若要变更编译器所使用的搜索路径，你可以使用-L选项来指定所要搜索的目录以及搜
索的次序。这些目录应该被加在系统程序库之前，并且会被应用在命令行中的所有-1选
项上。事实上，前面的那个例子会链接失败，因为当前目录（currentdirectory）并未被
列在cc的程序库搜索路径之中。我们只要以如下的方式加人当前目录就可以修正此错
误：
cccount_words.o-L.-1counter-1f1-ocount_words
程序库为一个程序的编译过程增添了些许的复杂性。make如何协助我们简化此状态呢？
GNUmake为程序库的创建以及链接提供了特别的支持，让我们来看看它的做法。
创建与更新程序库
在makefile里，指定程序库的方式跟指定任何其他文件没有不同，也就是指出它的文件
名。下面就是一个用来创建程序库的简单规则：
libcounter.a:counter.olexer.o
S(AR)S（ARFLAGS)$@ S^
此处使用了AR变量中的对于ar程序的内置定义，以及ARFLAGS变量中的标准选项rV。
这个程序库的文件名会被自动设定到S@里，而必要条件会被自动设定到$^里。
---
## Page 57
规则
47
现在，如果你以libcounter.a作为count_words的一个必要条件，则make在链接可执行
文件之前会更新该程序库。然而，这么做会有一个问题：程序库里的所有成员每次都会
被替换掉，即使它们并未被修改。宝贵的时间就这样浪费了，不过我们可以做得更好：
libcounter.a:counter.olexer.o
$(AR)S(ARFLGS)$9 $?
如果你将s^替换成S？，则make只会把时间戳在工作目标（的时间戳）之后的目标文
件传递给ar。
我们还可以做得更好？或许可以，或许不行。尽管make可让我们更新程序库里的个别
文件以及为每个目标文件成员执行一个ar命令，不过在我们探索相关细节之前，这种
构建程序库的做法中的几点值得我们加以注意。make的主要目标之一，就是只更新过时
（outofdate）的文件，好让处理器的使用更有效率。可惜，这种为每个过时的成员调
用一次ar的做法，很快就会让处理器陷人泥潭。如果程序库所包含的文件超过10个，
此时为每个更新动作调用一次ar，其代价将会比语法是否“精致”还大。通过在一个具
体规则中使用前面的简单方法以及调用ar，我们可以为所有文件执行-次ar编译并省
掉许多的fork/exec调用。此外，以r选项来执行ar在许多系统上是个效率相当差的工
作。例如，在1.9GHzPentium4的机器上，从头开始编译一个大型的程序库（包含14216
个成员，总计55MB）耗时4分24秒。然而，程序库建立之后，若以arr来更新单
一目标文件，则需要28秒的时间。所以，如果我们所要替换的文件超过10个，从头开
始编译程序库反而比较快。在这样的情况下，使用自动变量S？对每个被修改的目标文
件进行程序库的更新，或许应该更谨慎才对。对于较小型的程序库以及速度较快的处理
器来说，你不必为了效能的因素去采用前面的简单做法，而舍弃后面较精致的语法。此
时，使用特殊的程序库支持是比较好的做法。
在GNUmake中，你可以使用如下的符号来引I用程序库里的成员：
libgraphics.a(bitblt.o):bitblt.o
S(AR) S(ARFLAGS) $@ $lexer.c
gcc-I include-c-olexer.o1exer.c
ar rv 1ibcounter.a lexer.o
ar:creating 1ibcounter.a
a-lexer.o
gcc-Iinclude-c-o counter.osrc/counter.c
ar rv libcounter.a counter.o
a-counter.o
gcccount_words.o1ibcounter.a/lib/libf1.a-o count_words
rm lexer.c
注意程序库更的新规则。自动变量S@会被扩展成程序库的文件名称，即使该工作目标
在makefile里是libcounter.a（lexer.o)。
最后，还有一件事应该提到：程序库会为它所包含的符号提供索引。较新版的ar程序
（像GNUar）会在新的成员加人程序库的时候，自动管理此索引l。然而，许多较旧版的
ar并不会这么做，此时你就必须使用另一个程序（像ranlib）来创建或更新程序库的
索引。在这些系统上，隐含规则将无法更新程序库。对于这些系统，你必须使用如下的
规则：
libcounter.a:1ibcounter.a(lexer.o)libcounter.a(counter.o)
$（RANLIB）$@
对于大型的程序库，你可以使用如下的规则：
libcounter.a:counter.o lexer.o
S(RM）$@
S(AR)$(ARFLGS)$@ S^
$(RANLIB)S@
当然，这个用来管理程序库成员的语法也可以使用在隐含规则中。GNUmake随附了一
个用来更新程序库的内置规则。如果使用这个规则，我们的makefile就会变成下面这样：
---
## Page 59
规则
49
VPATH= Src include
CPPFLAGS=-I include
count_words:1ibcounter.a -1f1
1ibcounter.a:1ibcounter.a(lexer.o)1ibcounter.a(counter.o)
count_words.o:counter.h
counter.o:counter.h lexer.h
lexer.o:lexer.h
以程序库为必要条件
当程序库作为必要条件时，可以使用标准的文件名语法或-1语法来引用它们。使用文
件名语法时：
xpong: $(OBJECTS) /1ib/x11/1ibx11.a /1ib/x11/1ibxaw.a
S（LINK)S-O S@
链接器将只会读取命令行上所列出的程序库文件，以及按正常的方式来处理它们。使
用-1语法时，必要条件并非真正的文件名称：
S(LINK) $~-O S@
当-1的语法出现在必要条件上时，make将会搜索相应的程序库（而且会先搜索共享程
序库）以及将它的值（以绝对路径的形式）替换到变量S和S？里。第二种语法的最大
这些工作。它的另一个优点是，因为你可以自定义make的搜索路径，所以make可以
找到应用程序的程序库以及系统程序库。总之、第一种语法将会忽略共享程序库并使用
链接行（linkline）上所指定的程序库。第二种语法会使得make优先选择共享程序库，
也就是说，在make决定使用非共享版本（archiveversion）的Xll程序库之前，会先
搜索共享版本（sharedversion）的Xl/程序库。供-1语法辨别程序库文件名格式的模
式就存放在.LIBPATTERNS变量里，你可以通过它来自定义其他程序库的文件名格式。
可惜，有个小问题。如果makefile已经将程序库文件指定为工作目标，它就不能在必要
条件里对该文件使用-1选项。举例来说，对于下面的makefile：
count_words:count_words.o-icounter -1f1
@SO-S（1
libcounter.a:libcounter.a(lexer.o)1ibcounter.a(counter.o)
运行make，将会显示如下的错误信息：
---
## Page 60
50
第二章
这是因为make不会把-lcounter扩展成libcounter.a并去搜索工作目标，make只会
去搜索程序库。所以，如果要在makefile里进行程序库的编译工作，必须使用文件名的
语法。
要让复杂程序的链接工作没有错误，可能需要使用一些手段。链接器会依次搜索命令行
上所指定的程序库。所以，如果程序库A包含了一个未定义的符号，例如open，而且
该符号定义在程序库B中，那么你就必须在链接命令行（linkcommandline）上于B之
前指定A（也就是A需要B）。否则，一旦链接器读进A并且着到未定义的符号Open，
再回头来读取B就太迟了，链接器并不会回头来读取前面的程序库。如你所见，程序库
在命令行上的顺序相当重要。
一且工作目标的必要条件存放在变量S^和$？之后，它们的顺序就会被保存下来。所以，
如果在前面的例子里使用S^，将会扩展成顺序跟必要条件完全一样的文件列表，即使必
要条件跨越多项规则也是如此。也就是说，每项规则的必要条件会依照它们被看到的顺
序被依次附加到该工作目标的必要条件列表中。
一个比较相关的问题就是程序库之间的相互引I用（mutualreference），这通常称为循环
引用（circularreference，或简称circularity）。假设程序有所变动，使得程序库B现在
引用了程序库A中所定义的符号。我们知道A必须放在B的前面，不过现在B必须放在
A的前面。这个问题的解决方案，就是在B之前与之后使用A：-1A-1B-1A。在大
型且复杂的程序中，通常需要对程序库重复进行此步骤，有时会超过两次。
这么做将会对make造成一个小问题，因为自动变量通常会丢弃重复的部分。举例来说，
假如我们必须重复使用一个程序库必要条件以满足程序库循环引用的需要：
xpong:xpong.o 1ibui.a libdynamics.a libui.a -1x11
@$0-xS.（2）S
这个必要条件列表将会被处理成如下的链接命令：
gcc xpong.o 1ibui.a 1ibdynamics.a/usr/lib/X11R6/1ibx11.a-o xpong
为解决S^的这种行为，make另外提供了S+变量。此变量如同s^，不过它会保留重复
的必要条件。所以，如果使用S+：
$(CC）$+-OS@
那么这个必要条件列表将会被处理成如下的链接命令：
gcc xpong.o 1ibui.a 1ibdynamics.a 1ibui.a /usr/1ib/X11R6/1ibx11.a -o xpong
---
## Page 61
规则
51
双冒号规则
双冒号规则（double-colonrule）是一个模糊的功能，它会依据必要条件的时间戳是否
在工作自标（的时间戳）之后，以不同的命令来更新同一个工作自标。通常，当一个工
作目标多次出现时，所有的必要条件会被衔接成一份列表，而且只让一个命令脚本进行
更新的动作。然而，对双冒号规则而言，相同的工作目标每出现一次就会被视为一个独
立的实体，必须进行独立的处理。这意味着，对同一个工作目标来说，所有的规则必须
是同一个类型，也就是说，它们若非全都是双冒号规则，就应该全都是单冒号规则。
实际上，我们很难为这个功能找到有用的范例（这就是为何我会称它是一个模糊的功
能），下面是一个假造的例子：
file-list:: generate-list-script
>sx+pouy
generate-list-script $（files)>file-list
file-list:: S(files)
generate-list-script $(files)> file-list
我们可以通过两种方式重新产生file-list工作目标。如果产生脚本（generatingscript）被
更新，我们会将该脚本设为可执行，接着加以运行：如果是源文件被变更，我们只会运
行该脚本。尽管这个例子有点牵强，不过你可借此感觉一下如何应用这个功能。
到目前为止，我们只是将焦点放在特定的语法以及功能的行为上，不包括如何将它们应
用在较复杂的情况下一这是本书第二部分的重点。介绍过规则的大部分功能（这是
make的基础）之后，接下来要讲的是变量和命令。
---
## Page 62
第三章
变量与宏
到目前为止，我们已经看过了makefile的变量以及将它们应用在内置和具体规则中的许
多范例。不过这些都只是粗浅的例子。变量和宏越复杂，GNUmake的功能就越强大。
在我们继续任何探讨之前，最好能先了解make所包含的两种语言。第一种语言用来描
述工作目标与必要条件所组成的依存图（此语言的相关说明可参考第二章）。第二种语
言是宏语言，用来进行文字的替换。你可能已经熟悉其他的宏语言，像C预处理器、m4、
TeX以及宏汇编器（macroassembler）。如同这些其他的宏语言，make允许你为较长的