37
Initiator
skI , ai
Receiver
skR, bi
pk(skI ), gai
pk(skR), gbi, sign((gai, gbi, pk(skI )), skR)
sign((gbi, gai, pk(skR)), skI )
Figure 4: ISO 9798-3 Diﬃe Hellman Key Exchange
7 Basic Diﬃe-Hellman Key Exchange
We outline here the application of our framework to the ISO 9798-3 protocol, a variant of the
Diﬃe-Hellman key exchange. It is proven UC composable in [13]. We use our result to extend
the security proof to a context with shared long term secrets (which was not the case in the
UC proof). We present the protocol in Figure 4, and show how to instantiate the required
values and oracles to perform the proof presented in Section 6.2. The formal proofs (using the
CCSA model [11]) are provided in Appendix C.
Our decomposition and subsequent proofs show that the DDH key exchange can be used
to securely derive a secret key for any protocol that does not rely on the long term secret
used in the key exchange. Our proof is also modular, in the sense that it could be adapted to
provide also the security when the continuation protocol uses the long term shared secret as
well.
A high level view of the protocol is given in Figure 4, and it is formally expressed in our
algebra in Figure 5, where _I and _R denote the possible continuations at the end of each
party. We use pattern matching in the inputs to simplify the notations, where for instance
in(c,(cid:104)m, x(cid:105)) with m some constant only accepts inputs whose ﬁrst projection is m, and then
bind the variable x to the second projection.
If the inputs are not of the given form, the
protocols goes to an error branch.
Our goal is to apply the decomposition of Section 6.2, for some abstract continuations P
and Q that are supposed to used the derived key. We need to ﬁnd suitable identities and local
session identiﬁers so that the Conditions from the decomposition of Section 6.2 are fulﬁlled.
As we do not specify P and Q, we only discuss the conditions relative to the security of the
key exchange, e.g., K-1,K-2 and K-3. Remark that those conditions are suﬃcient to derive a
notion similar to the classical security of a key exchange, as for any P and Q that do not share
long term shared secrets with the key exchange. The other conditions are trivial to derive or
only rely on the security of the continuation when using an ideal key.
The identity of each party is its long term secret key, and thus, we use skI and skR as idI
and idR. Each session of the key exchange instantiates a fresh Diﬃe-Hellman share, that can
be seen as a local session identiﬁer. We thus use gai and gbi as lsidI
. These values
i
can also be used as implicit tagging since any signed message either depends on ai or bi.
With those choices, we need to ﬁnd a tagging function T that will provide a tagged oracle
OT such that the Conditions K of Section 6.2 are satisﬁed. Those Conditions, reformulated
with the current notations and with OT standing for Or, are expressed as follow:
K-1) ∀1 ≤ i ≤ N, νai, skI , bi, skR.
and lsidR
i
Ii[out(kI )](cid:107)Ri[out(kR)](cid:107)out((cid:104)gai, gbi(cid:105)) is OT -simulatable.
38
(cid:107)i
(
Ii :=
(cid:107)
Ri :=
)
out((cid:104)pk(skI ), gai(cid:105))
in((cid:104)xpk, xB, xm(cid:105)).
if verify(xm, xpk) = (cid:104)gai, xB, pk(skI )(cid:105) then
out(sign((cid:104)xB, gai, xpk(cid:105), skI ))
let kI = xai
_
I
B in
in((cid:104)xpk, xA(cid:105)).
out((cid:104)pk(skR), gbi, sign((cid:104)xA, gbi, xpk(cid:105), skR)(cid:105))
in(xm).
if verify(xm, xpk) = (cid:104)gbi, xA, pk(skR)(cid:105) then
let kR = xbi
_
A in
R
 if xB = gb0 then out((cid:104)xa0
 if xA = ga0 then out((cid:104)xb0
else if xB /∈ {gbi}i≥1 then ⊥
else out((cid:104)kI , ga0, xB(cid:105))
else if xA /∈ {gai}i≥1 then ⊥
else out((cid:104)kR, ga0, xB(cid:105))
B , ga0, xB(cid:105))
A , gb0, xA(cid:105))
Figure 5: ISO 9798-3 Diﬃe Hellman Key Exchange in the Pi Calculus (omitted channels)
K-2)
I0 [out((cid:104)kI , ga0, xB(cid:105))]
(cid:107)R0 [out((cid:104)kR, gb0, xA(cid:105))]
∼=OT ,OP,Q
I0
(cid:107)R0
K-3) {gai, gbi}i≥1 is disjoint of the support of OP,Q.
K-2 either corresponds to a matching conversation (i.e., all messages received by one were
sent by the other) between the sessions with sids ga0, gb0, in which case the output is (twice)
an ideal key k, or else it is a matching conversation with a simulated session, in which case it
outputs the computed keys. It is neither of those cases, it should not happen, and we raise
a bad event (denoted ⊥). The proof of the K-2 is thus a real-or-random proof of a honestly
produced key. We do not provide the proof of K-2 in this section, it is provided in Appendix C.
We must deﬁne an implicit tagging that allows to both have the simulatability and the
indistinguishability. Remark that ﬁrst, we extend the tagging function T of Deﬁnition 14 so
that it may depend on a second argument of arbitrary length, yielding T (m, s), the corre-
sponding signing oracle being denoted Osign
. This is required so that the implicit tagging
may depend on all the possible local session identiﬁers. The exact deﬁnition of this extension
is given in Section 12.
T,sk,s
We deﬁne the implicit tagging functions T I and T R as
T I (m,{gai, gbi}i≥1) := ∃s ∈ {ai}i≥1,∃m1, m2.m = (m1, gs, m2)
T R(m,{gai, gbi}i≥1) := ∃s ∈ {bi}i≥1,∃m1, m2.m = (m1, gs, m2)
This tagging function will suit our needs, as all messages signed by the two parties follow
this pattern. Moreover, in the protocol, the value sent in the ﬁrst message should match gai in
39
the last message. Therefore, when the protocol of Figure 4 is successfully completed, we can
prove that if xB (cid:54)= gb0, then xB ∈ {gbi|i ≥ 1}, i.e., T R(xB,{gai, gbi}i≥1) is true (and similarly
for R).
T R,skR,s,Os, where Os simply
reveals the elements in s, we do obtain the simulatability of multiple sessions of the key
exchange (Hypothesis 1).
Let s = {gai, gbi}i≥1, we ﬁnally deﬁne OT = Osign
T I ,skI ,s,Osign
To adapt this proof to a concrete example, the security proof of K-2 would be performed
under an oracle OP,Q that allows to simulate the continuation (Condition P-1 of Section 6.2).
The continuation should then be proven secure when using an ideal key (Conditions P of
Section 6.2).
Indeed, let us consider a record protocol
L := LI (xI )(cid:107)LR(xR), that exchanges encrypted messages using the exchanged key, and does
not share any long term secret, i.e., does not use the signing keys of the key exchange. Without
any shared secret, we do not need any oracle to simulate in(k); LI (k)(cid:107)in(k); LR(k), so we can
choose a trivial OP,Q that does nothing.
In some cases, this step is trivial.
8 Extension to Key Conﬁrmations
We present how our compositional framework can be used to prove the security of a key
exchange, in which the key is derived in a ﬁrst part of the protocol and then used (key
conﬁrmation) in the second part. Compared to [8], our method allows in addition sharing of
long term secrets.
i , idI )(cid:107)R(lsidR
i (lsidR
i , idr); R1
i (xI ) and Ri := R0
Consider a key exchange I(lsidI
i , idR). We further split I and R into Ii :=
correspond to the key
i (xR), where I 0
I 0
i (lsidI
exchange up to, but not including, the ﬁrst use of the secret key (xI or xR), and I 1
and R1
i
i
are the remaining parts of the protocol. The intuition behind the proof of security is that at
the end of I 0
, i.e. just before the key conﬁrmation, either the sessions are partnered
i
together and the derived key satisﬁes the real-or-random, or they are not, which means that
the key conﬁrmation performed by I 1
i
will fail. We denote
i , idI ); I 1
and R0
i
and R1
i
and R0
i
i
KEi[_
and
1, _
2] := I 0
i (lsidI
i , idI ); I 1
i (xI ); _
1(cid:107)R0
i (lsidR
i , idR); R1
i (xR); _
2
KE0
i [_
1, _
2] := I 0
i (lsidI
i , idI ); _
1|R0
i (lsidR
j , idR); _
2
We proceed as in Section 6, outlining how we may split the security proof into smaller proofs
using our framework, using the same composition Theorems at each step. We thus provide the
necessary Conditions S-1,S-2,P-1,K-1,K-2,K-3 so that, for some continuation P I
i (xR)
and its idealized version Q,
i (xI )(cid:107)P R
(cid:107)iKEi[P I
i (xI ), P R
i (xR)] ∼= (cid:107)iKEi[QI
i (xI ), QR
i (xR)]
A formal Corollary can be found in Appendix F.2.
8.1 Proofs with Key Conﬁrmations
Key exchange and protocol simulatability We modify slightly the conditions S-1 and
S-2 of Section 6.2 to reﬂect the fact that we now consider the key conﬁrmation to be part of
the continuation:
40
S-1) νp.in(x).I 1(x); P I (x), in(x).R1(x); P R(x), in(x).I 1(x); QI (x),
in(x).R1(x); QR(x) are OP,Q simulatable.
S-2) νp. (cid:107)i≤N I 0
i (lsidI
i , idI );
(cid:107)i≤N R0
i (lsidR
i , idR);
is Oke-simulatable.
j then
j then
1≤i≤N
xI
lsid = lsidR
if
out((cid:104)i, j(cid:105))
i (xI );⊥
else I 1
xR
lsid = lsidI
1≤i≤N
if
out((cid:104)i, j(cid:105))
else R1
i (xR);⊥
Security of the protocol Compared to Section 6.2, the continuation must be secure even
in the presence of the messages produced during the key conﬁrmation:
P-1) (cid:107)i≤N I 1
i (xR) ∼=Or,Ok (cid:107)i≤N I 1
i (xI )(cid:107)R1
i (xI )(cid:107)R1
i (xR); QR
i (xR); P R
i (xI ); QI
i (xI ); P I
i (xR)
We could once again split this goal into a single session proof using Theorem 5. We remark
that to prove the security of the single session, we can further reduce the proof by using an
oracle that may simulate I 1 and R1, as the security of P should not depend on the messages
of the key conﬁrmation.
Security of the key exchange We proceed in a similar way as in Section 6.2 and we use
the same notations. The following Conditions are then suitable:
K-1) ∀i ≤ N, νlsidI
i , idI , lsidR
i , idR.
i , lsidI
i (cid:105)) is OT -simulatable
KE0
i [out(xI ), out(xR)](cid:107)out((cid:104)lsidR
K-2) s is disjoint of the support of OP,Q.
K-3) KE0
0 [if xI
lsid /∈ sR then I 1
0 (xI )
lsid(cid:105)),
else out((cid:104)xI , lsidI
0, xI
lsid /∈ sI then R1
if xR
0(xR)
lsid(cid:105))]
else out((cid:104)xR, lsidR
0 , xR
∼=OKE ,OP,Q KE0
0 [if xI
0 then out((cid:104)k, lsidI
lsid = lsidR
else if xI
else out((cid:104)xI , lsidI
if xR
else if xR
else out((cid:104)xR, lsidR
0, xI
lsid /∈ sR then I 1
0 (xI ); out(⊥)
lsid(cid:105)),
lsid /∈ sI then R1
0 , xR
0 , xR
0(xR); out(⊥)
lsid(cid:105))]
0 then out((cid:104)k, lsidR
lsid = lsidI
0, xI
lsid(cid:105))
lsid(cid:105))
or xR
lsid = lsidI
0
The indistinguishability expresses that, if the two singled out parties are partnered, i.e.,
, then we test the real-or-random of the key. Else, it speciﬁes
xI
lsid = lsidR
0
lsid /∈ sY will
that a party must always be partnered with some honest session, i.e., that xX
lsid /∈ sY we run the key conﬁrmation, and on
never occur. To this end, on one side, when xX
the other side we run the key conﬁrmation followed in case of success by a bad event. Finally,
when two honest parties are partnered, but are not the singled out parties, they leak their
states.
9 Application to SSH
SSH [12] is a protocol that allows users to login onto a server from a remote platform. It is
widely used in the version where signatures are used for authentication. An interesting feature
41
Platform
skP , ai
gai
Server 1