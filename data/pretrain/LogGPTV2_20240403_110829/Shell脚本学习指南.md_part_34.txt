subShell与代码块是组化命令的两种选择。它们的用意各有不同，你可以根据需求选用。
内建命令的存在是因为它们要改变Shell内部状态且必须是内建的（例如cd），有些则
是为了效率（例如test）。命令查找题序允许函数在一般内建命令之前先被找到，结合
commana命令，则可以编写一个能使内建命令生效的Shell函数。在所有内建命令里，set
命令是最复杂的。
www.TopSage.com
---
## Page 204
第8章
产生脚本
在本章中，我们将进一步处理更复杂的工作。我们认为这里举出的例子都是一般用得到
的工具，它们每一个都是全然不同的，且在大多数的UNIX工具集里也没有。
本章中的程序，包括命令行参数分析、在远程主机上运算、环境变量、工作记录、并行
处理、使用eval的运行时语句（runtime statement）执行、草稿文件（scratch file）、
Shell函数、用户定义初始文件，以及安金性议题考虑的范例，程序会运用Shell语言里
的董要语句，并展现传统UNIXShell脚本编写风格。虽然我们是为了这本书而开发的
这些程序，但这些程序的基础稳固，经得起时间考验，你可以在目常工作上使用它们。
8.1路径查找
有些程序支持在目录路径上查找输入文件，有点像UNIXShell查找以冒号隔开的目录
列表，列在PATH内，以找出可执行的程序，这对用户来说很方使，他只要提供较短的
文件名，且不需要知道它们在文件系统里的位置。UNIX并未提供任何特殊命令或系统
调用，可在查找路径下寻找文件，即使在很久以前有其他操作系统支持这种功能，幸好，
要作路径查找不难，只要用对工具就可以。
与其实现路径查找以寻找特定程序，不如做一个新的工具，以环境变量名称为参数，而
环境变量名称展开是预期的查找路径，后面接着零个或更多的文件模式，并报告匹配文
件的位置。我们的程序将在其他需要路径查找支持的软件中，成为一般性工具（这也就
是我们先前在第1章提到的“构建特定工具前，先想想”的原则）。
有时你得知道路径下的某个文件是不是不止一个，因为当路径下存有不同的版本时，你
可能需要调整路径，控制要找到的版本。我们的程序会为用户提供一个命令行选项，以
选择报告第一个找到的文件还是报告所有找到的文件。另外，根据用户要求提供一个可
192
www.TopSage.com
---
## Page 205
产生脚本
识别的版本编号，变成软件的标准实现，而且必须提供简短的在线帮助，让用户不需要OIm1
在每次使用程序时，都重读程序的使用手册才能想起选项名称。我们的程序当然也提供
这样的功能。
完整程序将在例8-1给出，因为这个程序很长，我们在此将它展现为伪码程序（semiliterate
program)，是为了注释与描述Shell程序代码的各个片段的顺序，以便说明。
我们从一般的介绍性注释块开始。首行为识别程序的神奇行，/bin/sh用来执行脚本。
注释块后，接的是程序行为的描述，并说明使用方法：
1/bin/sh -
在查找路径下寻找一个或多个原始文件或文件模式，
查找路经由一个指定的坏境变量所定义。
标准输出产生的结果，通常是在查找路径下找到的每个文件之第一个实体的完整路径，
如果所有文件都找到，则遇出码为0，
（Shel1的遇出码限制为125）。
否则，即为找不到的文件个数-非零值
语法：
pathfind (--al1)(--7] (--help] [--version]  envvar pattern(s)
选项--al1指的是寻找路径下的所有目录，
而不是找到第一个就停止，
在网络的环境下，安全性一直是必须慎重考虑的问题。其中有一种攻击Shell脚本的方
式，是利用输入字段分隔字符：IFS，它会影响Shell接下来对输入数据解释的方式。为
避免此类型的攻击，部分Shel仅在脚本执行前，将IFS重设为标准值：其他则导人该
变量的一个外部设置，我们则是将自己做的预防操作放在脚本的第一步：
IFS=*
很难在屏幕上或是显示的页面上看出位于引号里的内容：它是具有三个字符的字符串，
包括换行字符（newline）、空格，以及定位字符（tab）。IFS的默认值为：空格、定位字
符、换行字符，不过如果我们以这种方式编写，那些会自动修剪空白的编辑器可能会将
结尾的空白截去，让字符串的值减少成只有一个换行字符。比较好的方式应该是更严谨
的使用转义字符，例如IFS="\040\t\n"，可是BourneShell并不支持这样的转义符。
在我们重新定义IFS时有一点请特别留意。当·S*展开以恢复命令行时，IFS值的第
一个字符，会被当成字段分隔符。我们在这个脚本里不使用S*，所以重新安排IFS内
的字符不会有影响。
www.TopSage.com
---
## Page 206
194
第8章
另一种常见的安全性攻击，则是欺骗软件，它执行非我们所预期的命令。为了阻断这种
攻击，我们希望调用的程序是可信任的版本，而非潜伏在用户提供的查找路径下的骗
程序，因此我们将PATH重设为一个最小值，以存储初始值供以后使用：
OLDPATH**$PATH*
PATH=/bin1/u8r/bin
cxport PATH
export语句是这里的关键：它可以确保所有的子进程继承我们的安金查找路径，
程序代码接下来是5个以字母顺序排列的简短函数。
第1个函数为error（）函数，在标准错误输出上显示其参数，再调用一个函数（此部分
稍后有说明），不返回：
error(1
atxapueabesn
第2个函数usage（）会写出简短信息，显示程序的使用方式，并返回给它的调用者。需
留意的是：这个函数需要程序名称，但不是以直接编码模式（hardcode），它是从变量
PROGRAM取得程序名称，这个变量设置为程序被调用的名称，这可以让安装程序在重新
命名程序时，无须修改程序代码，这常发生在与已安装的程序名称产生冲突时，也即具
同样名称但具有不同用途的时候。函数本身很简单：
usage()
1
echo *Usage: $PROGRAM [-al1] [--?][--help1 [--version] envvar pattern(s)*
第3个函数usage_and_exit（)，会产生语法信息，并以它的单一参数所提供的状态码
退出：
ueage_and_exit ()
usage
exit $1
第4个函数version（）是在标准输出上显示程序版本编号，并返回给它的调用者。如同
usage（），它是使用PROGRAM取得程序名称：
www.TopSage.com
---
## Page 207
产生脚本
195
eCho *$PROGRAN version $VERSION*
1
最后一个函数warning（）会在标准错误上显示它的参数，并对变量EXITCoDB加1，可
记录已发出的警告信息的数目，并返回给调用者：
warning()
echo *$8* 1>&2
7.6.3节对expr有较深入的探讨。在这里，它的语法是Shell为变量增值的习惯方式。
较新版的SheII则允许更简单的形式EXITCODE=S（（EXITCODE+1)），不过还是有相
当多系统不认得该POSIX用法。
即使这个程序很短，我们其实完全不需要写函数，除了避免程序代码重复之外，其实它
可以隐藏不相关的细节，这是良好的程序实现方式：告知我们正要做什么，而不是说明
我们要如何作。
这时我们已经到达运行时的第一条被执行的语句了。先初始化5个变量，以记录选项的
选择、用户提供的环境变量名称、退出码、程序名称以及程序版本编号：
all=no
envvar=
EXTTCODE=0
VERSION=1.0
在我们的程序里，将遵循小写（字母）变量为本地函数或主程序代码体所使用，而大写
变量则被整个程序全局性地共享，这里给a11变量一个字符申值，而非一个数字，是因
为这样可以让程序更清楚，而对运行时资源消耗的影响也微乎其微。
注章：basename命令是从完整路径名称中取出文件名称部分的传统工具，它会裁断第一个参数的
开头所有字符，一直到最后一个斜杠（含）.再报告剩余字符到标准输出上：
S basenane resolv.conf
产生仅含文件名的结果
$baaenane /ete/zesolv.conf
resoiv.conf
产生仅含文件名的结果
resolv.conf
BourneShell的后代版本都提供模式匹配运算符，如第6章表6-2所示，可用来完成此目
的，但basename为原始命令，所以可在所有 Shell下运行。
使用第二个参数来表示文件名结尾，则basename从它的结果中载断任何匹配的结尾：
www.TopSage.com
---
## Page 208
196
第8章
sbanename/ete/resolv.conf.conf报告无结尾的文件名
osage.com
reso1v
sbasename/etc/resolv.conf.pid仅报告文件名
resolv.conf
虽然basename的第一个参数通常是路径名称，但basename只简单地认为它是一个文字
字符串，不需要、也不会检查它是否为真正存在的文件。
如省略参数，或参数为空字符申，则basename的行为由运行时定义。
接下来的大型代码块，是在所有的UNIX程序里典型的命令行参数解析：当我们有一个
参数时（由参数计数值S#决定，且必须大于零），会根据参数的字符申值来选择case
语句的程序块，处理该参数：
vhile test S#-gt 0
op
case $1 in
case选择器在不同环境下可能有不同的解读方式。GNU程序风格鼓励使用长的、描述
性的选项名称，而不是长久以来用于UNIX里的那套旧的、隐秘式的单一字符选项。后
者简洁式的微法，在选项数很少且程序使用频紧的时候还让人可以接受，如果不是这种
情况，描述性的名称会比较好，用户只需要提供足够的信息一不要和其他选项重复
即可。然而，当有其他程序提供相同的选项时，则应避免这种简略用法，这么做才能让
用户更容易了解程序，确保日后程序薪版本加入薪选项时，不会产生意外的结果。
在Shell语言里，没有一种简单的方式来通过给名称添加明确的前缓来指定该名称可以
与长名称进行匹配，所以我们必须提供所有的替代用法。
有时长选项名称会通过前置两个连字号经编辑后纳入旧式程序中，这是为了与原始选项
区分。以新式程序代码来说，我们允许一个或两个连字号，它可以通过重复case选择
器里的缩写并加入额外连字号，完成程序改版。
我们也许会使用通配字符编写case选择器以匹配：--a*1-a*）。但我们认为这是
无法接受的松散实现方式，因为它允许匹配和那些写出来的名称全然不同的名称。
针对--al1选项，我们只要通过把变量a11重薪设置为yes来记录找到选项的事实即
可：
--al1 1 --a1 1 --a 1 -a11 1 -a1 1 -a 1
a1l=yes
在每个case块之后的双分号是必备的一除了最后一个case以外。我们也可以将这段
写得更紧凑些：
www.TopSage.com
---
## Page 209
产生脚本
=（-----
上面这种方式，当双分号出现在它们自己的行上时：比较容易验证所有的情况都被适当
地终止，而且对于在块里附加额外的语句也较为容易。适度使用缩进编辑则有助于程序
的解读，还能强调程序逻辑结构，这几平在所有程序语言里都适用。
以GNU处理--help需求的惯例是：在标准输出上，显示如何使用程序的简短摘要，且
立即以或功状态码退出（在POSIX与UNIX都为O）。对大型程序而言，摘要应包含每
个选项的简短说明，不过我们的程序很小，不需要额外的说明，由于问号？是Shel1的
通配字符，所以我们必须在case选择器里，以引I号框起来：
（,-,1y-1eq-1eu-dret-.--,1g--]eqeg--1deu
ussge_and_exit 0
7 
同样地，GNU惯例也会针对--yersion选项，在标准输出上产生一行（通常是这样）
报告结果，并立即以成功状态退出。同样的情形也应用到其他种类的状态要求选项（可
能出现在大型程序里）上，例如--author、--bug-reports、--copyright、
--license,--where-from 等:
version
exit “0
.
case选择器-*会匹配剩下的所有选项：我们会在标准错误输出上推告非法选项，并调
用usage（）函数，提醒用户用法为何，再立即以失败状态码（1）退出：
*)
: 1.32-*, 3
标准错误输出与标准输出的差异在各软件间都不尽相同，且在交互模式下使用命令时，
用户不会感觉到差异，因为两者数据流都流到相同的显示设备。如果程序为过滤器的角
色，则错误信息与状态报告，像--help与-version选项所产生的输出，都应流至标准
错误输出，这么一来才不致让管道有混乱的数据出现：否则，状态报告会流到标准输出。
由于状态报告是GNU世界近期的新产物，程序实现仍在进化中，标准尚未出现。不管
是POSIX还是传统的UNIX文件似平都未对此议题微出任何说明。
最后一个case选择器*）是匹配上述选项以外的所有状态。它有点类似C、C++以及Java
语言里switch语句的default选择器，包括它的做法一直都是个不错的构想，即便它
的内容是空的，也能向读者说明：所有可能出现的状态我们都考虑到了，这里，匹配指
www.TopSage.com
---
## Page 210
198
第8章
出我们已经处理完所有的选项，所以可以退出循环。由于我们已处理完所有可能的情况，
所以这里用终结关键字来结束case语句：
break
J 1
esac
我们现已经到了选项循环的最后。正好在它的最后一条语句之前，我们使用shift以抛
弃现在已被处理的第一个参数，且能移到参数列表的下一个项目。这么做可确保：当参
数计数S#到达零时，最终的循环会结束：
Gone
shift
从循环中退出时，所有选项都已处理，而且参数列表里剩下的就是环境变量名称以及要
寻找的文件了。我们将变量名称存储在envvar中，且如果至少还有一个参数留下来时，
我们就丢弃第一个参数：
test S# -gt 0 4& shift
envvar=*$1*
剩下来的参数可以“Se·取得，我们避免将它们存储在变量内，例如files="se'，因
为文件名中如果有空格将无法正确地被处理：内嵌的空格将成为参数的分隔符。
因为有可能用户提供的环境变量是PATH，我们为了安全性因素会重设，这时我们会检
查该变量，并适当地更新envvar：
开头的x是常见的：此处它是为了避免变量的展开（如果此展开是以一个连字号开头）
与test的选项相混淆。
至此，所有参数都已处理，我们要进人最手的部分：使用Shell的eval语句。我们在
envvar里已经拥有了环境变量的名称，可以*$envvar”取得，但我们现在要的是它
的展开。我们也想要将冒号分隔字符转换成一般的空白分隔字符。如果MYPATH为用户
所提供的名称，我们便会构建参数字符电'$（'Senvvar"}，也就是Shell展开为
'$（MYPATH）·的等同物。两边的单引号是为了避免它更进一步地展开。该字符串之后会
传给eval，eval会将其视为两个参数：eeho与S（MYPATH）。eval在环境下寻找
MYPATH，假设找到/bin:/usr/bin：/home/jones/bin，就执行展开的命令：echo
/bin:/usr/bin:/home/jones/bin, 接着将 /bin:/usr/bin:/home/jones/bin传
给管道直到tr命令将冒号转换空格字符，会产生/bin/usr/bin/home/jones/bin
www.TopSage.com
---