# 【技术分享】你所知道的PHP中的公钥加密是错误的
|
##### 译文声明
本文是翻译文章，文章来源：paragonie.com
原文地址：[https://paragonie.com/blog/2016/12/everything-you-know-about-public-key-encryption-in-php-is-wrong?utm_source=tuicool&utm_medium=referral](https://paragonie.com/blog/2016/12/everything-you-know-about-public-key-encryption-in-php-is-wrong?utm_source=tuicool&utm_medium=referral)
译文仅供参考，具体内容表达以及含义原文为准。
****
****
**翻译：**[ **pwn_361**
****](http://bobao.360.cn/member/contribute?uid=2798962642)
**预估稿费：200RMB（不服你也来投稿啊！）**
******投稿方式：发送邮件至**[ **linwei#360.cn**](mailto:PI:EMAIL) **，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿******
**概述**
去年，我们的安全团队确认了
CVE-2015-7503漏洞，又名ZF2015-10，这是一个在使用RSA过程中，出现的功能上的漏洞，存在于Zend框架的密码库中。
这个实际漏洞（采用PKCS1v1.5 填充方法的RSA密码“填充预言”漏洞）最初是由[Daniel
Bleichenbacher在1998年发布](http://crypto.stackexchange.com/questions/12688/can-you-explain-bleichenbachers-cca-attack-on-pkcs1-v1-5)出来的。“填充预言”漏洞允许攻击者用一个加密的消息，并多次发送修改过的密文到服务器(每一次得到一个填充错误的标识),根据返回的错误标识，有可能恢复出原始信息。
人们可能希望，任何允许攻击者还原出原始信息的漏洞（“填充预言”已经被发现了超过十六年），开发者都应该有所了解，并减小漏洞利用的可能性。
很遗憾，当我们审察PHP软件时（包括开源的和专用的），我们发现，即使在2016年编写的应用层加密协议中，仍然存在这种漏洞，可以通过这种方法去攻击。
我们相信造成这种结果的因素主要有两个方面：
1.大多数开发人员对如何在所有语言中安全的实现公钥加密了解不够。
2.PHP的OpenSSL 扩展在默认配置下是不安全的，但是在实际操作中，没有人会去修改默认配置。
**快速解决方案：使用安全的PHP公钥加密库**
如果你对这么多的“为什么不安全”不感兴趣，你可以直接看这个:“[为你的PHP项目选择一个正确的加密库](https://paragonie.com/blog/2015/11/choosing-right-cryptography-library-for-your-php-project-guide)”。
**RSA是如何变坏的**
当涉及到应用层加密，使用RSA简直是一个错误。这并不意味着你的应该程序是完全失败的。无论如何，你必须避免[很多RSA的实施缺陷(有些是明示的，有些不明显)](http://www.cryptofails.com/post/70059600123/saltstack-rsa-e-d-1)。让我们看一看一些PHP开发人员可能会遇到的情况。
**1.默认安全配置会让每个人都上当**
在PHP中，大多数的RSA在实施过程中都会用到下面的两个函数：
[openssl_public_encrypt()](https://secure.php.net/openssl_public_encrypt)
[openssl_private_encrypt()](https://secure.php.net/openssl_private_decrypt)
来看一个这两个函数的原型，有一个默认配置：
OPENSSL_PKCS1_PADDING 常量告诉OpenSSL 扩展：”我们想用PKCS1填充方法“。但是我们之前已经说过了，[采用PKCS1v1.5
填充方法的RSA密码，存在填充预言的弱点](http://crypto.stackexchange.com/questions/12688/can-you-explain-bleichenbachers-cca-attack-on-pkcs1-v1-5)，这一点从1998年就已经被公开了。由于攻击者为了恢复明文，可能需要一百万个消息的攻击成本，因此这种攻击更多的被普遍称为
"百万消息攻击"。
解决方案是无论你什么时候使用这两个函数，都需要使用OPENSSL_PKCS1_OAEP_PADDING常量。这个常量会强制用OAEP填充方法代替不安全的PKCS1
V1.5填充方法。
在我们的体会中，实际上没有人这么做(除非在我们团队中有某个人帮它[指了](https://www.reddit.com/r/PHP/comments/5h0a5b/rewrote_php_messenger_looking_for_feedback/daxmko7/)[出来](https://github.com/captain-redbeard/php-messenger/commit/e4c207ad8688d9ce98f0fcebf923a64986976448))：
[ZendCrypt didn't](https://github.com/zendframework/zend-crypt/commit/667fda9fdb506fd7569a75a3511621bb254c47c4)
[Sikker (PHP security library)
didn't](https://github.com/NorseBlue/Sikker/issues/2)
[Pikirasa (PHP cryptography library)
didn't](https://github.com/vlucas/pikirasa/issues/8)
[Minds (social network allegedly backed by "Anonymous")
didn't](https://github.com/Minds/mobile/issues/17)
甚至是有经验加密开发人员，在使用RSA加密时，常常都会忘记使用OAEP。
因此，如果你需要强制使用公钥算法(不论作为一个开发者，还是一个渗透测试者)，并且当你们提到RSA算法，还谈论着”2048bit密钥够不够？或者需不需要用4096bit?“时，请先检查你使用的填充方法吧。你很有可能只需要几千条信息就能恢复出明文，从而完全将应用程序的安全性作废。
**2.直接使用RSA加密的危险性**
如果你已经阅读了前面的内容，并且已经思考过，”那好，如果我仅仅记着使用OAEP，我就可以不受阻碍，直接使用RSA加密任何信息吗？”，没有这么快，你最好不要用RSA加密长信息。
当面对加密长信息时，大多数开发者很聪明：他们会将信息分割成214-byte的信息块(对于2048bit的密钥)，并且对每块分别进行加密，可以简单的将RSA的这种模式称为ECB模式。
如果你这样做，攻击者可能不会去恢复出你的明文，但是正如之前所说过的，RSA很慢，罪犯可能会充分利用这个特点，去发动DDOS攻击，从而很容易的扩大DDOS的影响，并且对RSA发动DDOS攻击，不需要用明显的攻击方法，你可能只需要用复制、重新排序或删除214字节块的方法，而不是创建一个解密错误。
**使用混合密码体制**
最好的实现公钥密码的方法是建立一个混合的加密体制。结合对称密码和非对称密码。这样做有如下几个好处：
**效率高：** 对称密码加密速度比非对称密码快很多
**适用性：** 对信息长度没有实际限制
**安全性：** 请看来面
**1.混合RSA+AES**
结合RSA和AES通常很有必要：
(1)用对称密钥，使用[对称密码](https://paragonie.com/blog/2015/05/using-encryption-and-authentication-correctly)加密消息。
(2)使用公钥密码加密(1)中的对称密钥，从而让只有私钥的一方才可以解密出对称密钥，并使用它。
[ZendCrypt](https://github.com/zendframework/zend-crypt)在3.1.0版本以后，就已经支付混合RSA-AES的加密体制了，并采用了[EasyRSA](https://github.com/paragonie/EasyRSA)库。在Zend框架说明文档中，对它采用的混合加密方案的工作原理理解的很好。
由于现有的AES密钥大小一定，你需要加密的数据只有16、24、或者32byte，这远小于2048bit
RSA最大允许的214bytes。实际的数据加密采用的是CBC模式的AES,或者是CTR模式的AES。对于大多数应用程序，这种加密对消息长度没有实践的上限。
**2.混合ECDH+Xsalsa20-Poly1305**
Libsodium
加密库使用基于椭圆曲线的DH密钥交换算法，代替RSA，用于协商共享密钥，该共享密钥被xsalsa20-poly1305用于消息加密和密文鉴定中。
相关功能为 **crypto_box()** 。
当你想用接收者的公钥加密数据时(即发送者无法解密)，Libsodium 的另一功能是对于每条消息，产生一个随机的公私密钥对，并将公钥附在密文后面，名为
**crypto_box_seal(** )。
**针对RSA的模数攻击是一个长期的威胁**
RSA的安全性基于大数分解的困难性，然而，在不久的将来，这一安全保证会面对两个主要威胁：
1.改进的攻击算法有可能比“[通用数域筛法](https://en.wikipedia.org/wiki/General_number_field_sieve)”更快的从公钥中恢复出私钥。[对椭圆曲线密码体制没有效果](http://crypto.stackexchange.com/questions/8301/trying-to-better-understand-the-failure-of-the-index-calculus-for-ecdlp)。
2.量子计算机，这货太强大，连椭圆曲线密码体制都能破。
目前认为，一个老练的攻击者，有可能在短短几个月的时间里破解出1024位RSA，但是2048bit
RSA仍然是安全的，然而，如果有一种方法能突破2048位RSA，那么这种方法对4096位RSA可能也有效。
如果你打算在2016年将加密技术应用到一个新的应用程序中，有可能突破RSA的那些迫在眉睫眉睫的威胁（真正的问题是，这种突破方法对ECDH或ECDSA是不是适用）绝对应该被考虑。实际上，在未来，你最好考虑不要用RSA、DSA、或者传统的Diffie-Hellman算法。
**总结**
如果你需要在你的PHP应用中添加公钥加密算法：
1.不要用RSA。我们甚至没有讲到数字签名，它同样也面临着很多尚未解决的复杂问题([细微的伪造攻击](https://blog.filippo.io/bleichenbacher-06-signature-forgery-in-python-rsa)，假冒安全证明等等)。
2.你果你必须用RSA，不要直接用RSA。最好使用混合的加密体制，结合RSA和下面的一个：
AES-256-GCM
AES-256-CTR + HMAC-SHA256 (in an Encrypt then MAC construction)
3.确保你用了OAEP，而不是PKCS1 V1.5填充。否则，这肯定是一个漏洞。
同时，如果你对漏洞的详细内容感兴趣的话，你可以看一下下面的几篇文章：
“填充预言”攻击：
为什么不要用PKCS1 v1.5填充方法：
Bleichenbacher’s CRYPTO 98 paper revealed a chosen ciphertext attack：
[ftp://ftp.rsa.com/pub/pdfs/bulletn7.pdf](http://ftp://ftp.rsa.com/pub/pdfs/bulletn7.pdf)
CVE-2016-1494 (python – rsa)数字签名漏洞详解：
CVE-2016-1494 (python – rsa)英文数字签名漏洞详解：