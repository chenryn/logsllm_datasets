把命令放到了项目的framework目录下，如图16-12所示。
图16-12 framework目录
然后开始构造命令参数，主要需要用到系统的jar包android.jar：
修改一下入口代码，添加回编译运行参数：
运行程序如下：
回编译成功，得到apk文件，如图16-13所示。
图16-13 回编译之后的apk文件
分析完了apktool工具所有的源码，总结一下其功能，如下所示：
·反编译过程中主要是解析AndroidManifest.xml、resource.arsc、dex文件。
·回编译的时候借助aapt命令完成编译操作。
16.6 Jadx源码分析
下面介绍反编译的另外一个神器Jadx，这个工具也是开源的，可以直接去GitHub上搜索：https://github.com/skylot/jadx。这个工具其实和apktool反编译的功能差不多，但是有一个特色，就是可视化功能，能够高效地分析apk的结构。下面来看一个例子，如图16-14所示。
图16-14 Jadx工具效果图
可以看到结构很清晰，分析起来会比较方便，感觉它是集成了apktool+jd-gui的功能，但是和apktool相比的话，它还是有点缺陷的。首先反编译会比较耗时，其次它不能修改代码，进行回编译，这里为什么分析它呢？因为它是开源的，又借助了asm工具来生成class文件，实现Java代码的可视化。下面就来说说asm这个工具类的用途。这里写了一个demo来看看效果：
运行结果如图16-15所示。
图16-15 asm案例运行结果
这里没有打印“Hello world！的代码”，但是结果却打印了，这就是asm功能，即能够手动构造一个class文件，如图16-16所示。
图16-16 asm运行产生的class文件
大家是否联想到了动态代理模式，会产生一个动态代理类，而且还会生成一个Proxy.class文件？JavaWeb的Spring框架中Cglib也是采用这个功能来实现AOP编程的，它可以通过输入一个字符串来定义类，给这个类添加方法、字段等信息，然后生成类的字节码数组。可以保存成class文件，同时也可以使用ClassLoader来加载字节码数据，然后再反射调用指定的方法。Jadx的可视化功能就是借助这个功能，同时著名的dex2jar工具也是这样的，可以去dex2jar工具的lib目录看看，如图16-17所示。
图16-17 asm工具包
Jadx的反编译步骤是这样的：解析dex文件→smali源码→解析smali指令→借助asm生成class文件→解析class文件得到Java源码。
提示：Apktool+Jadx源码下载地址为http://pan.baidu.com/s/1cHU30M。
16.7 本章小结
本章主要介绍了反编译神器apktool和Jada工具，其中apktoot是逆向工作中的金钥匙，所以本章着重分析了这个工具的实现原理，以便读者在反编译应用遇到问题的时候能够快速定位到问题，让反编译更加顺利。使用apktool是逆向反编译的第一步也是最重要的一步，所以了解它的工作原理是至关重要的。
第17章 Hook神器Xposed
相信大家对Xposed框架应该不陌生，它是Android中Hook技术的一个著名框架，还有一个框架是CydiaSubstrate，但是这个框架是收费的，而Xposed框架是免费的且是开源的，网上已有很多文章介绍Xposed框架的原理实现，本章主要介绍如何使用这个框架。
17.1 安装教程
在安装这个工具之前，要先解决如下几个问题：
·首先知道这个框架的核心点是系统进程注入技术，那么如果要注入系统进程，就必须要root权限，所以如果想用这个框架的话就必须得有一个root的设备。
·然后就是这个框架的适配问题，不是所有的设备、所有的系统都支持这个框架的使用的，本人在实验的过程中就遇到了小米3+MIUI7操作失败了，结果重新刷了一个原生的Android 4.4系统才成功的。
·最后一个问题就是Xposed框架本身的版本问题，它针对不同系统发布了多个版本，所以得针对于自己的设备系统安装正确的Xposed版本。
解决了这三个问题才能成功安装Xposed框架。而在这个过程中还会发现遇到两个问题。
第一个问题是不兼容问题，如图17-1所示。
图17-1 不兼容问题
第二个问题是提示安装框架问题，如图17-2所示。
图17-2 安装框架问题
本人在操作也是遇到了这两个问题，最后也是没有找到合适的答案，所以就刷了一个原生的Android 4.4系统。
17.2 环境搭建
如果上面的问题都解决了，再打开应用，点击安装框架，如图17-3所示。
这里还是提示未激活，点击进入，如图17-4所示。
图17-3 安装框架界面
图17-4 框架激活状态图
这时候看到了正常了，可以点击安装了，直接点击安装即可，如图17-5所示。
图17-5 安装界面
这里是需要root授权的，点击允许，安装成功之后也会提示重启生效的，因为要注入系统进程，必须重启才有效果。
到这里就成功安装了Xposed框架了，在这个过程中肯定有人会遇到问题，个人觉得解决问题的最根本办法就是刷机了，本章操作的环境是：小米3移动版+Android原生4.4系统+Xposed_v33版本。
17.3 编写模块功能
环境搭建好了，下面就开始操作了。上面安装的那个工具其实是一个模块管理器，如果想做一些hook操作还得自己编写模块，然后把这个模块安装到设备中，这个工具就可以检测出来了，会提示加载这模块然后重启设备，模块功能就有效果了。那么下面来看一下如何编写一个Xposed模块。
第一步：新建模块项目
导入Xposed工具包，如图17-6所示。
图17-6 模块工程
这里一定要注意：不能使用libs文件夹而要使用lib文件夹，如果这里使用了libs文件夹，在安装模块成功之后重启，会发现Hook是失败的，通过打印tag为xposed的日志信息会发现这样的错误：
这个错误主要是因为把接口包含到了插件项目中了，那么可以猜想错误问题也是这个Xposed工具导致的。那么只需要把libs文件夹改成lib文件夹，然后用add buildpath命令即可。
注意：在Eclipse中，如果把工具包放到libs文件中，默认是加入到编译路径中的，同时在编译出来的程序中也是包含了这个工具包中的所有类，而对于其他非libs文件夹，添加工具包之后执行add buildpath只是做到了项目引用工具包的功能，而最终并不会把这个工具包包含到程序中。
第二步：编写模块代码
编写模块代码只要新建一个实现IXposedHookLoadPackage接口类，然后在handle-LoadPackage回调方法中进行拦截操作即可，而具体的拦截操作是借助XposedHelpers.findAndHookMethod方法和XposedBridge.hookMethod方法实现的，这两个方法从参数含义可以看到，主要是需要Hook的类名和方法名，还有一个就是拦截的回调方法，一般是拦截之前做什么的beforeHookedMethod方法，以及拦截之后做什么的afterHookedMethod方法，如图17-7所示。
图17-7 模块代码
对于IXposedHookLoadPackage这个接口和回调方法，可以知道，应该是拦截系统中所有应用的运行信息，传递回来的一个LoadPackageParam参数类型就是包括了Hook应用的具体信息，打印应用的包名就可以看到效果了。
注意：如果想Hook一个类的具体方法，那么就必须要清楚地了解到这个方法的详细信息，比如参数类型和个数，返回类型等。因为在拦截的过程中必须要对这个方法进行分析，比如得到方法参数来进行具体参数修改，返回值信息来进行返回值修改。
看到了获取imei值的方法是一个无参数的返回字符串类型的方法，那么如果要拦截它的返回值，就需要修改它的返回值，使用setResult方法即可。所以从这里可以看到不管是Hook系统的方法，还是以后去Hook第三方应用的具体类方法，第一步都得了解到Hook对象的具体信息。关于系统方法可以通过查看源码来得到信息，而对于第三方应用的话只能借助反编译技术了，比如修改游戏金币功能，必须先反编译游戏知道修改金币的类和具体方法才可行。
这里不仅Hook了系统的imei信息，也简单Hook了系统的地理位置信息，在Android中获取经纬度信息有三种方式，这里为了演示简单，用了GPS定位功能，一般获取经纬度信息的代码主要是两处。
第一处是初始化的时候调用getLastKnowLocation方法获取最后一次系统中的地理位置信息，如下代码：
第二处就是监听地理位置变化的回调接口中的onLocationChanged回调方法，如下代码：
如果想Hook系统的地理位置信息进行拦截，就需要操作这两处代码。而它们有一个区别，第一处是通过返回值得到的，第二处是通过回调方法中的参数得到的。下面来看一下具体的Hook代码。
Hook第一处代码比较简单，直接构造一个假的Location对象，然后设置返回值即可，如下代码所示：
Hook第二处代码有点复杂，需要先找到添加位置监听的方法requestLocationUpdates，然后通过反射得到这个回调对象，找到具体的回调方法，再进行操作，因为回调方法是通过参数把Location对象传递回来的，所以这里需要修改参数值。如下代码所示：
到这里就编写好了Hook系统的imei值和地理位置信息的模块了。
第三步：添加模块入口
这一步是非常重要的，也是最容易忘记的，就是要告诉Xposed框架一个模块中Hook的入口，可以看到模块的入口是Main类，所以需要在模块的assets中添加一个xposed_init文件，如图17-8所示。
图17-8 入口文件xposed_init
这里的内容就是模块入口类的全称名称即可，如图17-9所示。
图17-9 xposed_init文件内容
第四步：添加模块的额外信息
最后一步需要在模块的AndroidManifest.xml文件添加额外信息，具体包括模块的描述信息、版本号等，如下所示：
其中：
·xposedmodule：是Android程序作为Xposed中的一个模块，所以值为true。
·xposeddescription：是对本模块的功能的描述，可以自己简单叙述一下就可以了。
·xposedminversion：是本模块开发时用到的Xposed的jar包最低版本号，这里是30，这里所用的Xposed的jar包版本是54。
经过上面4步之后就完成了模块的定义，最后为了验证Hook的结果，再新建一个Activity类，在内部调用一下系统的获取imei方法以及位置信息方法，并且显示在屏幕中，如下代码所示：
17.4 运行模块
下面就来运行一下模块程序，安装到设备之后，Xposed会提示模块未激活，如图17-10所示。
这个XposedInstaller程序工具应该是通过接收安装广播，然后得到这个应用信息分析它是否包含了Xposed模块的特殊属性来判断的。点击进行激活，如图17-11所示。
图17-10 提示未激活信息
图17-11 激活模块
这时候看到激活成功之后，会提示再次重启设备才能生效。每当有新的模块或者模块代码有更新都需要重启设备模块才生效，如图17-12所示。
这一点还是麻烦的。重启设备之后，再运行模块代码看看效果，如图17-13所示。
从这显示结果看到了，Hook成功了，在没有Hook之前的效果是，如图17-14所示。
图17-12 提示模块更新
图17-13 运行结果
图17-14 没有拦截之前的运行效果
这时候来看一下打印的日志信息，如下所示：
百度地图在获取设备的imei和位置信息，当然这是符合正常情况的，从这里可以看到，还可以利用这个技术来观察设备中有哪些应用在获取设备的一些隐私数据。
提示：项目下载地址为https://github.com/fourbrother/xposedhookdemo
17.5 本章小结
本章主要介绍Xposed的基本使用规则和方法，XposedInstaller.apk其实是一个模块载体和管理器，如果想实现具体的Hook操作，就必须自己编写模块程序，然后激活加载方可生效。在实际过程中，这个框架是非常有用的，可以通过修改系统的一些信息来帮助测试模拟复杂的测试环境，但是这个框架现在用得最广泛的当属破解操作，比如用这个框架可以进行应用的脱壳，编写游戏的外挂等。
第18章 脱壳神器ZjDroid
前面一章介绍了Xposed框架工具的基本使用，本章将继续介绍Xposed框架的另外一个功能即脱壳，主要是利用Xposed的脱壳模块工具ZjDroid实现的，因为它是开源的，所以直接分析源码即可，源码的下载地址：https://github.com/halfkiss/ZjDroid。不过可惜的是现在只公开了Java层的代码，而native层的代码并没有公开，分析源码之后会发现最重要的功能就在native层。
18.1 ZjDroid原理分析
下面就来详细分析一下ZjDroid工具的源码，由Eclipse工程导入，基于之前的Xposed模块编写的经验，找到入口代码，在assets目录下有一个xposed_init文件中就记录了模块的入口类，如图18-1、图18-2所示。
图18-1 xposed_init文件
图18-2 xposed_init入口类
直接进入到这个类即可，代码如下：
遵循统一规则，实现了IXposedHookLoadPackage接口，再实现handleLoadPackage回调方法即可，下面继续分析入口方法ModuleContext，代码如下：
这里开始拦截Application的onCreate方法，而这个方法一般是每个应用程序的启动方法，在这里做拦截操作也是合情合理的，再看拦截之后做了什么，也就是ApplicationOnCreateHook类的实现，代码如下：
在这里开始真正的拦截操作，主要是添加了一个广播，每个应用在启动的时候都会去注册这个广播，而如果后续使用该工具发送这样对应Action广播的话，每个应用程序都会收到。所以这里可以看到，核心工作就在这个广播的接收之后做了，接下来继续去看这个广播的定义，代码如下：