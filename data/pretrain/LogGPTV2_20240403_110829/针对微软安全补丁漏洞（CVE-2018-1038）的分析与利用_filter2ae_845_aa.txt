# 针对微软安全补丁漏洞（CVE-2018-1038）的分析与利用

## 译文声明
本文为翻译文章，原文链接：[https://blog.xpnsec.com/](https://blog.xpnsec.com/)。译文仅供参考，具体内容及含义请以原文为准。

## 概述
早在2018年3月，Ulf Frisk在Windows 7和Windows Server 2008 R2中发现了一个漏洞。该漏洞是由于微软为了缓解Meltdown漏洞而发布的补丁无意中引入的，它允许任意进程访问和修改页表项（Page Table Entries）。有关该漏洞的详细分析，请参阅Ulf Frisk的博客：[原文链接](#)。

本周我有一些空闲时间，决定深入研究这个漏洞，探索其潜在的利用方式。我的目标是找到一种快速提升特权的方法，并在此过程中深入了解Windows内存管理机制。本文将详细介绍如何针对此类漏洞进行利用。

## 分页的基本原理
要理解这个漏洞的工作原理，首先需要了解x86或x64架构上的分页机制。在x64操作系统中，虚拟地址通常如下所示：
```
0x7fffffd6001
```

虚拟地址不仅仅是指向RAM中某个位置的指针，它实际上由多个字段组成，在将虚拟地址转换为物理地址时具有特定用途。我们将上述示例虚拟地址转换成二进制形式：
```
0000000000000000 000001111 111111111 111111111 111010110 000000000001
```

从左到右，前16位可以忽略，因为它们只是虚拟地址第48位的镜像。从偏移量第48位开始：

- 最初的9位 `000001111`（十进制15）是PML4表的偏移量；
- 接下来的9位 `111111111`（十进制511）是PDPT表的偏移量；
- 接下来的9位 `111111111`（十进制511）是PD表的偏移量；
- 接下来的9位 `111010110`（十进制470）是PT表的偏移量；
- 最后的12位 `000000000001`（十进制1）是内存页的偏移量。

接下来的问题是，什么是PML4、PDPT、PD和PT？

## PML4、PDPT、PD和PT
在x64体系结构中，虚拟地址转换为物理地址的过程通过CR3寄存器指向的一组分页表实现：

- PML4 – Page Map Level 4
- PDPT – Page Directory Pointer Table
- PD – Page Directory
- PT – Page Table

每个表负责提供数据存储位置的物理地址以及相关标志。例如，页表中的条目可以提供查找链中的下一个表指针，用于设置内存页的NX位，或者确保内核内存不被应用程序访问。

简化后的虚拟地址查找过程如下图所示：

遍历这些表的过程是由各个条目完成的，最终指向内存中存储数据的物理地址。为了简化这一过程，操作系统开发人员采用了“自引用页表”技术。

## 自引用页表
自引用页表通过引用自身PML4表中的字段来工作。例如，如果我们在PML4表中创建索引为0x100的新条目，并且该条目指向PML4表的物理地址，这就形成了一个“自引用条目”。

这种做法的好处是，我们可以在虚拟地址空间中引用和修改任何页表。例如，如果我们想修改某个进程的PML4表，可以简单地引用虚拟地址0x804020100000：

- PML4索引0x100 – PML4的物理地址；
- PDPT索引0x100 – 同样是PML4的物理地址；
- PD索引0x100 – 依然是PML4的物理地址；
- PT索引0x100 – 还是PML4的物理地址。

最终返回PML4内存中的内容。下面是一个简单的Go代码示例，展示了如何将虚拟地址转换为偏移量：

```go
package main

import (
    "fmt"
)

func VAtoOffsets(va uint64) {
    phy_offset := va & 0xFFF
    pt_index := (va >> 12) & 0x1FF
    pde_index := (va >> (12 + 9)) & 0x1FF
    pdpt_index := (va >> (12 + 9 + 9)) & 0x1FF
    pml4_index := (va >> (12 + 9 + 9 + 9)) & 0x1FF
    fmt.Printf("PML4 Index: %03xn", pml4_index)
    fmt.Printf("PDPT Index: %03xn", pdpt_index)
    fmt.Printf("PDE Index: %03xn", pde_index)
    fmt.Printf("PT Index: %03xn", pt_index)
    fmt.Printf("Page offset: %03xn", phy_offset)
}

func OffsetsToVA(phy_offset, pt_index, pde_index, pdpt_index, pml4_index uint64) {
    var va uint64
    va = pml4_index << (12 + 9 + 9 + 9) | pdpt_index << (12 + 9 + 9) | pde_index << (12 + 9) | pt_index << 12 | phy_offset
    fmt.Printf("Virtual Address: %016Xn", va)
}
```

假设我们要修改虚拟地址的PDPT条目。借助自引用技术，减少递归次数，这个过程变得非常简单。例如，给定PML4索引0x150和0x100中的自引用条目，我们可以返回地址为0xffff804020150000的相应PDPT表。

## 漏洞分析
当我们对基础知识有了足够的了解后，可以转向漏洞本身。如果在Windows 7 x64或Windows Server 2008 R2 x64系统上应用2018年2月的微软安全更新补丁，我们会发现PML4的条目0x1e8已经更新。

在受漏洞影响的操作系统环境中，PML4的条目0x1e8如下所示：
```
007000002d282867
```

这里需要注意的是页表项的第三位。如果设置了第三位，就允许用户模式访问内存页，不再限制在内核模式。更糟糕的是，PML4条目0x1e8被用作Windows 7和Windows Server 2008 R2 x64中的自引用条目，这意味着任何用户模式的进程都可以查看和修改PML4页表。通过修改顶级页表，我们可以查看并修改整个系统的物理内存。

## 漏洞利用
那么，如何利用这个漏洞呢？以下步骤可以帮助我们实现特权升级：

1. 创建一组新的页表，允许访问任何物理内存地址。
2. 创建一组签名，以便在内核内存中搜索_EPROCESS结构。
3. 找到当前执行进程和System进程的_EPROCESS内存地址。
4. 将当前执行进程的token替换为System进程的token，从而将当前进程提升到NT AUTHORITY\SYSTEM权限。

本次研究参考了PCILeech的代码（[代码链接](#)），这是我在操作系统分页级别首次进行的研究。以下是部分代码示例，用于设置页表：

```c
unsigned long long iPML4, vaPML4e, vaPDPT, iPDPT, vaPD, iPD;
DWORD done;

// setup: PDPT @ fixed hi-jacked physical address: 0x10000
// This code uses the PML4 Self-Reference technique discussed, and iterates until we find a "free" PML4 entry
```

通过以上步骤，我们可以成功利用该漏洞实现特权提升。