title:Designing Voting Machines for Verification
author:Naveen Sastry
Designing voting machines for veriÔ¨Åcation
NAVEEN SASTRY‚àó
TADAYOSHI KOHNO‚Ä†
DAVID WAGNER‚Ä°
Abstract
We provide techniques to help vendors, independent test-
ing agencies, and others verify critical security properties
in direct recording electronic (DRE) voting machines.
We rely on speciÔ¨Åc hardware functionality, isolation, and
architectural decision to allow one to easily verify these
critical security properties; we believe our techniques
will help us verify other properties as well. VeriÔ¨Åcation
of these security properties is one step towards a fully
veriÔ¨Åed voting machine, and helps the public gain con-
Ô¨Ådence in a critical tool for democracy. We present a
voting system design and discuss our experience build-
ing a prototype implementation based on the design in
Java and C.
1
Introduction
With a recent Ô¨Çurry of reports criticizing the trustwor-
thiness of direct recording electronic (DRE) voting ma-
chines, computer scientists have not been able to allay
voters‚Äô concerns about this critical infrastructure [17, 29,
33, 38]. The problems are manifold: poor use of cryptog-
raphy, buffer overÔ¨Çows, and in at least one study, poorly
commented code. Given these problems, how can we
reason about, or even prove, security properties of voting
machines?
The ultimate security goal would be a system where
any voter, without any special training, could easily con-
vince themselves about the correctness of all relevant
security properties. Our goal is not so ambitious; we
address convincing those with the ability to understand
‚àónks@cs.berkeley.edu. Supported by NSF CNS-0524252
and by the Knight Foundation under a subcontract through the Cal-
tech/MIT Voting Technology Project.
‚Ä†tkohno@cs.ucsd.edu. Supported by NSF CCR-0208842,
NSF ANR-0129617, and NSF CCR-0093337. Part of this research was
performed while visiting the University of California at Berkeley.
‚Ä°daw@cs.berkeley.edu. Supported by NSF CCR-0093337
and CNS-0524252.
code the correctness of a few security properties. For
clarity, we focus on two important security properties in
the body of this paper. VeriÔ¨Åcation of these properties, as
well as the others we describe elsewhere in this paper, are
a step towards the full veriÔ¨Åcation of a voting machine.
Property 1 None of a voter‚Äôs interactions with the vot-
ing machine, including the Ô¨Ånal ballot, can affect any
subsequent voter‚Äôs sessions1.
One way to understand this property is to consider a
particular voting system design that exhibits the prop-
erty. A DRE can be ‚Äúmemoryless,‚Äù so that after indelibly
storing the ballot, it erases all traces of the voter‚Äôs actions
from its RAM. This way, a DRE cannot use the voter‚Äôs
choices in making future decisions. A DRE that achieves
Property 1 will prevent two large classes of attacks: one
against election integrity and another against privacy. A
DRE that is memoryless cannot decide to change its be-
havior in the afternoon on election day if it sees the elec-
tion trending unfavorably for one candidate. Similarly,
successful veriÔ¨Åcation of this property guarantees that a
voter, possibly with the help of the DRE or election in-
sider, cannot access a prior voter‚Äôs selections.
A second property is:
Property 2 A ballot cannot be cast without the voter‚Äôs
consent to cast.
Property 2 ensures the voter‚Äôs ballot is only cast with
their consent; combined with other security properties,
the property helps ensure the voter‚Äôs ballot is cast in an
unmodiÔ¨Åed form.
In Section 8, we discuss additional target properties
for our architecture, and we discuss strategies for how to
prove and implement those properties successfully.
1Note that we do allow certain unavoidable interactions, e.g., after
the ballot storage device becomes ‚Äúfull,‚Äù a voting machine should not
allow subsequent voters to vote.
USENIX Association
Security ‚Äô06: 15th USENIX Security Symposium
321
Current DREs are not amenable to veriÔ¨Åcation of these
security properties; for instance, version 4.3.1 of the
Diebold AccuVote-TS electronic voting machine con-
sists of 34 7122 lines of vendor-written C++ source code,
all of which must be analyzed to ensure Properties 1
and 2. One problem with current DRE systems, in other
words, is that the trusted computing base (TCB) is sim-
ply too large. The larger problem, however, is the code
simply is not structured to verify security properties.
In this paper, we develop a new architecture that sig-
niÔ¨Åcantly reduces the size of the TCB for veriÔ¨Åcation
of these properties. Our goal is to make voting systems
more amenable to efÔ¨Åcient veriÔ¨Åcation, meaning that im-
plementations can be veriÔ¨Åed to be free of malicious
logic. By appropriate architecture design, we reduce the
amount of code that would need to be veriÔ¨Åed (e.g., using
formal methods) or otherwise audited (e.g., in an infor-
mal line-by-line source code review) before we can trust
the software, thereby enhancing our ability to gain conÔ¨Å-
dence in the software. We stress that our architecture as-
sumes voters will be diligent: we assume that each voter
will closely monitor their interaction with the voting ma-
chines and look for anomalous behavior, checking (for
example) that her chosen candidate appears in the conÔ¨År-
mation page.
We present techniques that we believe are applicable
to DREs. We develop a partial voting system, but we em-
phasize that this work is not complete. As we discuss in
Section 2, voting systems comprise many different steps
and procedures: pre-voting, ballot preparation, audit trail
management, post-election, recounts, and an associated
set of safeguard procedures. Our system only addresses
the active voting phase. As such, we do not claim that our
system is a replacement for an existing DRE or a DRE
system with a paper audit trail system. See Section 7 for
a discussion of using paper trails with our architecture.
Technical elements of our approach. We highlight two
of the key ideas behind our approach. First, we fo-
cus on creating a trustworthy vote conÔ¨Årmation process.
Most machines today divide the voting process into two
phases: an initial vote selection process, where the voter
indicates who they wish to vote for; and a vote conÔ¨Årma-
tion process, where the voter is shown a summary screen
listing their selections and given an opportunity to review
and conÔ¨Årm these selections before casting their ballot.
The vote selection code is potentially the most complex
part of the system, due to the need for complex user inter-
face logic. However, if the conÔ¨Årmation process is easy
to verify, we can verify many important security prop-
erties without analyzing the vote selection process. Our
2Kohno et al. count the total number of lines in their paper [17]; for
a fair comparison with our work, we look at source lines of code, which
excludes comments and whitespace from the Ô¨Ånal number. Hence, the
numbers cited in their paper differ from the Ô¨Ågure we list.
architecture splits the vote conÔ¨Årmation code into a sepa-
rate module whose integrity is protected using hardware
isolation techniques. This simple idea greatly reduces
the size of the TCB and means that only the vote con-
Ô¨Årmation logic (but not the vote selection logic) needs
to be examined during a code review for many security
properties, such as Property 2.
Second, we use hardware resets to help ensure Prop-
erty 1. In our architecture, most modules are designed
to be stateless; when two voters vote in succession, their
execution should be independent. We use hard resets to
restore the state of these components to a consistent ini-
tial value between voters, eliminating the risk of privacy
breaches and ensuring that all voters are treated equally
by the machine.
Our architecture provides several beneÔ¨Åts. It preserves
the voting experience that voters are used to with current
DREs. It is compatible with accessibility features, such
as audio interfaces for voters with visual impairments,
though we stress that we do not implement such features
in our prototype. It can be easily combined with a voter-
veriÔ¨Åed paper audit trail (VVPAT). Our prototype imple-
mentation contains only 5 085 lines of trusted code.
2 Voting overview
DREs. A direct recording electronic (DRE) voting ma-
chine is typically a stand-alone device with storage, a
processor, and a computer screen that presents a voter
with election choices and records their selections so they
can be counted as part of the canvass. These devices
often use an LCD and touch screen to interact with the
voter. Visually impaired voters can generally use alter-
nate input and output methods, which presents a boon to
some voters who previously required assistance to vote.
Pre-election setup. The full election process incorpo-
rates many activities beyond what a voter typically ex-
periences in the voting booth. Although the exact pro-
cesses differ depending on the speciÔ¨Åc voting technol-
ogy in question, Figure 1 overviews the common steps
for DRE-based voting. In the pre-voting stage, election
ofÔ¨Åcials prepare ballot deÔ¨Ånition Ô¨Åles describing the pa-
rameters of the election. Ballot deÔ¨Ånition Ô¨Åles can be
very complex [24], containing not only a list of races and
values indicating how many selections a voter can make
for each race, but also containing copies of the ballots
in multiple languages, audio tracks for visually impaired
voters (possibly also in multiple languages), Ô¨Åelds that
vary by precinct, and Ô¨Åelds that vary by the voter‚Äôs party
afÔ¨Åliation for use in primaries. Election ofÔ¨Åcials gener-
ally use external software to help them generate the ballot
deÔ¨Ånition Ô¨Åles. After creating the ballot deÔ¨Ånition Ô¨Åles,
an election worker will load those Ô¨Åles onto the DRE vot-
322
Security ‚Äô06: 15th USENIX Security Symposium
USENIX Association
Figure 1: Major steps in the voting process when using DREs. The shaded portions are internal to the DREs. In this
work, we mainly address voter authentication, interaction, and vote storage.
ing machines. Before polls open, election ofÔ¨Åcials gen-
erally print a ‚Äúzero tape,‚Äù which shows that no one cast a
ballot prior to the start of the election.
Active voting. When a voter Alice wishes to vote, she
must Ô¨Årst interact with election ofÔ¨Åcials to prove that she
is eligible to vote. The election ofÔ¨Åcials then give her
some token or mechanism to allow her to authenticate
herself to the DRE as an authorized voter. Once the DRE
veriÔ¨Åes the token, the DRE displays the ballot informa-
tion appropriate for Alice, e.g., the ballot might be in Al-
ice‚Äôs native language or, for primaries, be tailored to Al-
ice‚Äôs party afÔ¨Åliation. After Alice selects the candidates
she wishes to vote for, the DRE displays a ‚ÄúconÔ¨Årmation
screen‚Äù summarizing Alice‚Äôs selections. Alice can then
either accept the list and cast her ballot, or reject it and
return to editing her selections. Once she approves her
ballot, the DRE stores the votes onto durable storage and
invalidates her token so that she cannot vote again.
Finalization & post-voting. When the polls are closed,
the DRE ensures that no further votes can be cast and
then prints a ‚Äúsummary tape,‚Äù containing an unofÔ¨Åcial
tally of the number of votes for each candidate. Poll
workers then transport the removable storage medium
containing cast ballot images, along with the zero tape,
summary tape, and other materials, to a central facility
for tallying. During the canvass, election ofÔ¨Åcials accu-
mulate vote totals and cross-check the consistency of all
these records.
Additional steps. In addition to the main steps above,
election ofÔ¨Åcials can employ various auditing and test-
ing procedures to check for malicious behavior. For ex-
ample, some jurisdictions use parallel testing, which in-
volves sequestering a few machines, entering a known set
of ballots, and checking whether the Ô¨Ånal tally matches
the expected tally. Also, one could envision repeating the
vote-tallying process with a third-party tallying applica-
tion, although we are unaware of any instance where this
particular measure has been used in practice. While these
additional steps can help detect problems, they are by no
means sufÔ¨Åcient.
3 Goals and assumptions
Security goals. For clarity, in the body of this paper we
focus on enabling efÔ¨Åcient veriÔ¨Åcation of Properties 1
and 2 (see Section 1), though we hope to enable the efÔ¨Å-
cient veriÔ¨Åcation of other properties as well. Property 1
reÔ¨Çects a privacy goal: an adversary should not be able
to learn any information about how a voter voted besides
what is revealed by the published election totals. Prop-
erty 2 reÔ¨Çects an integrity goal: even in the presence of
an adversary, the DRE should record the voter‚Äôs vote ex-
actly as the voter wishes. Further, an adversary should
not be able to undetectably alter the vote once it is stored.
We wish to preserve these properties against the classes
of adversaries discussed below.
Wholesale and retail attacks. A wholesale attack is one
that, when mounted, has the potential of affecting a broad
number of deployed DREs. A classic example might be a
software engineer at a major DRE manufacturer inserting
malicious logic into her company‚Äôs DRE software. Prior
work has provided evidence that this it is a concern for
real elections [3]. Such an attack could have nationwide
impact and could compromise the integrity of entire elec-
tions, if not detected. Protecting against such wholesale
attacks is one of our primary goals. In contrast, a retail
attack is one restricted to a small number of DREs or a
particular polling location. A classic retail attack might
be a poll worker stufÔ¨Ång ballots in a paper election, or
selectively spoiling ballots for speciÔ¨Åc candidates.
Classes of adversaries. We desire a voting system that:
‚Ä¢ Protects against wholesale attacks by election ofÔ¨Å-
USENIX Association
Security ‚Äô06: 15th USENIX Security Symposium
323
 































 
















 














 










































!


