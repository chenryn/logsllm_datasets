: 0x70 
+0x05c Irql
: 0x7 '' 
+0x05d SynchronizeIrql  : 0x7 ''
+0x05e FloatingSave     : 0 '' 
+0x05f Connected
: 0x1 '' 
+0x060 Number
: 6 
+0x064 ShareVector
: 0 '' 
+0x065 EmulateActiveBoth : 0 ''
+0x066 ActiveCount
: 0 
+0x068 InternalState    : 0n4 
+0x06c Mode
: 1 ( Latched ) 
+0x070 Polarity
: 0 ( InterruptPolarityUnknown ) 
+0x074 ServiceCount     : 0 
+0x078 DispatchCount    : 0 
+0x080 PassiveEvent     : (null)  
+0x088 TrapFrame
: (null)  
+0x090 DisconnectData   : (null)  
+0x098 ServiceThread    : (null)  
+0x0a0 ConnectionData   : 0xffffe50f`9db3bd90 _INTERRUPT_CONNECTION_DATA 
+0x0a8 IntTrackEntry    : 0xffffe50f`9d091d90 Void 
+0x0b0 IsrDpcStats
: _ISRDPCSTATS 
+0x0f0 RedirectObject   : (null)  
+0x0f8 Padding
: [8]  ""
In this example, the IRQL that Windows assigned to the interrupt is 7, which matches the fact 
from the DispatchAddressKiInterruptDispatch-style interrupt with no 
additional optimizations or sharing. 
If you wanted to see which GSIV (IRQ) was associated with the interrupt, there are two ways 
INTERRUPT_CONNECTION_DATA structure embedded in the ConnectionData
dt command to dump the 
pointer from your system as follows:
6: kd> dt 0xffffe50f`9db3bd90 _INTERRUPT_CONNECTION_DATA Vectors[0].. 
nt!_INTERRUPT_CONNECTION_DATA 
+0x008 Vectors
: [0]  
+0x000 Type
: 0 ( InterruptTypeControllerInput ) 
+0x004 Vector
: 0x70 
+0x008 Irql
: 0x7 '' 
+0x00c Polarity     : 1 ( InterruptActiveHigh ) 
+0x010 Mode
: 1 ( Latched ) 
+0x018 TargetProcessors :
+0x018 ServiceRoutine   : 0xfffff804`65e56820  
unsigned char i8042prt!I8042KeyboardInterruptService
+0x020 MessageServiceRoutine : (null)
+0x028 MessageIndex     : 0
+0x030 ServiceContext   : 0xffffe50f`9dfe9040 Void
+0x038 SpinLock
: 0
+0x040 TickCount
: 0
+0x048 ActualLock
: 0xffffe50f`9dfe91a0  -> 0
+0x050 DispatchAddress  : 0xfffff804`565ca320   void  nt!KiInterruptDispatch+0
+0x058 Vector
: 0x70
+0x05c Irql
: 0x7 ''
+0x05d SynchronizeIrql  : 0x7 ''
+0x05e FloatingSave     : 0 ''
+0x05f Connected
: 0x1 ''
+0x060 Number
: 6
+0x064 ShareVector
: 0 ''
+0x065 EmulateActiveBoth : 0 ''
+0x066 ActiveCount
: 0
+0x068 InternalState    : 0n4
+0x06c Mode
: 1 ( Latched )
+0x070 Polarity
: 0 ( InterruptPolarityUnknown )
+0x074 ServiceCount     : 0
+0x078 DispatchCount    : 0
+0x080 PassiveEvent     : (null) 
+0x088 TrapFrame
: (null) 
+0x090 DisconnectData   : (null) 
+0x098 ServiceThread    : (null) 
+0x0a0 ConnectionData   : 0xffffe50f`9db3bd90 _INTERRUPT_CONNECTION_DATA
+0x0a8 IntTrackEntry    : 0xffffe50f`9d091d90 Void
+0x0b0 IsrDpcStats
: _ISRDPCSTATS
+0x0f0 RedirectObject   : (null) 
+0x0f8 Padding
: [8]  ""
In this example, the IRQL that Windows assigned to the interrupt is 7, which matches the fact 
from the DispatchAddressKiInterruptDispatch-style interrupt with no 
additional optimizations or sharing. 
If you wanted to see which GSIV (IRQ) was associated with the interrupt, there are two ways 
INTERRUPT_CONNECTION_DATA structure embedded in the ConnectionData
dt command to dump the 
pointer from your system as follows:
6: kd> dt 0xffffe50f`9db3bd90 _INTERRUPT_CONNECTION_DATA Vectors[0]..
nt!_INTERRUPT_CONNECTION_DATA
+0x008 Vectors
: [0] 
+0x000 Type
: 0 ( InterruptTypeControllerInput )
+0x004 Vector
: 0x70
+0x008 Irql
: 0x7 ''
+0x00c Polarity     : 1 ( InterruptActiveHigh )
+0x010 Mode
: 1 ( Latched )
+0x018 TargetProcessors :
48 
CHAPTER 8 System mechanisms
+0x000 Mask
: 0xff 
+0x008 Group
: 0 
+0x00a Reserved     : [3] 0 
+0x028 IntRemapInfo :
+0x000 IrtIndex     : 0y000000000000000000000000000000 (0) 
+0x000 FlagHalInternal : 0y0
+0x000 FlagTranslated : 0y0
+0x004 u
:  
+0x038 ControllerInput :
+0x000 Gsiv
: 1
The Type indicates that this is a traditional line/controller-based input, and the Vector 
and Irql
ControllerInput
different kind of interrupt, such as a Message Signaled Interrupt (more on this later), you would 
dereference the MessageRequest
Another way to map GSIV to interrupt vectors is to recall that Windows keeps track of this 
translation when managing device resources through what are called arbiters
type, an arbiter maintains the relationship between virtual resource usage (such as an interrupt 
vector) and physical resources (such as an interrupt line). As such, you can query the ACPI IRQ 
arbiter and obtain this mapping. Use the !apciirqarb command to obtain information on the 
ACPI IRQ arbiter:
6: kd> !acpiirqarb 
Processor 0 (0, 0): 
Device Object: 0000000000000000 
Current IDT Allocation: 
... 
  000000070 - 00000070  D  ffffe50f9959baf0 (i8042prt) A:ffffce0717950280 IRQ(GSIV):1 
...
Note that the GSIV for the keyboard is IRQ 1, which is a legacy number from back in the IBM 
PC/AT days that has persisted to this day. You can also use !arbiter 4 (4 tells the debugger to 
    6: kd> !arbiter 4 
    DEVNODE ffffe50f97445c70 (ACPI_HAL\PNP0C08\0) 
Interrupt Arbiter "ACPI_IRQ" at fffff804575415a0 
Allocated ranges: 
0000000000000001 - 0000000000000001
ffffe50f9959baf0  (i8042prt)
note that in either output, you are given the owner of the vector, in the type of a device object (in 
!devobj command to get information on 
the i8042prt device in this example (which corresponds to the PS/2 driver):
6: kd> !devobj 0xFFFFE50F9959BAF0 
Device object (ffffe50f9959baf0) is for: 
 00000049 \Driver\ACPI DriverObject ffffe50f974356f0 
+0x000 Mask
: 0xff
+0x008 Group
: 0
+0x00a Reserved     : [3] 0
+0x028 IntRemapInfo :
+0x000 IrtIndex     : 0y000000000000000000000000000000 (0)
+0x000 FlagHalInternal : 0y0
+0x000 FlagTranslated : 0y0
+0x004 u
: 
+0x038 ControllerInput :
+0x000 Gsiv
: 1
The Type indicates that this is a traditional line/controller-based input, and the Vector
and Irql
Irql
Irql
ControllerInput
ControllerInput
ControllerInput
different kind of interrupt, such as a Message Signaled Interrupt (more on this later), you would 
dereference the MessageRequest
MessageRequest
MessageRequest
Another way to map GSIV to interrupt vectors is to recall that Windows keeps track of this 
translation when managing device resources through what are called arbiters
type, an arbiter maintains the relationship between virtual resource usage (such as an interrupt 
vector) and physical resources (such as an interrupt line). As such, you can query the ACPI IRQ 
arbiter and obtain this mapping. Use the !apciirqarb command to obtain information on the 
ACPI IRQ arbiter:
6: kd> !acpiirqarb
Processor 0 (0, 0):
Device Object: 0000000000000000
Current IDT Allocation:
...
  000000070 - 00000070  D  ffffe50f9959baf0 (i8042prt) A:ffffce0717950280 IRQ(GSIV):1
...
Note that the GSIV for the keyboard is IRQ 1, which is a legacy number from back in the IBM 
PC/AT days that has persisted to this day. You can also use !arbiter 4 (4 tells the debugger to 
    6: kd> !arbiter 4
    DEVNODE ffffe50f97445c70 (ACPI_HAL\PNP0C08\0)
Interrupt Arbiter "ACPI_IRQ" at fffff804575415a0
Allocated ranges:
0000000000000001 - 0000000000000001
ffffe50f9959baf0  (i8042prt)
note that in either output, you are given the owner of the vector, in the type of a device object (in 
device object (in 
device object
!devobj command to get information on 
the i8042prt device in this example (which corresponds to the PS/2 driver):
6: kd> !devobj 0xFFFFE50F9959BAF0
Device object (ffffe50f9959baf0) is for:
 00000049 \Driver\ACPI DriverObject ffffe50f974356f0
CHAPTER 8 System mechanisms
49
Current Irp 00000000 RefCount 1 Type 00000032 Flags 00001040 
SecurityDescriptor ffffce0711ebf3e0 DevExt ffffe50f995573f0 DevObjExt ffffe50f9959bc40 
DevNode ffffe50f9959e670  
ExtensionFlags (0x00000800)  DOE_DEFAULT_SD_PRESENT 
Characteristics (0x00000080)  FILE_AUTOGENERATED_DEVICE_NAME 
AttachedDevice (Upper) ffffe50f9dfe9040 \Driver\i8042prt 
Device queue is not busy.
The device object is associated to a device node-
es. You can now dump these resources with the !devnode
ask for both raw and translated resource information:
6: kd> !devnode ffffe50f9959e670 f 
DevNode 0xffffe50f9959e670 for PDO 0xffffe50f9959baf0 
  InstancePath is "ACPI\LEN0071\4&36899b7b&0" 
  ServiceName is "i8042prt" 
  TargetDeviceNotify List - f 0xffffce0717307b20  b 0xffffce0717307b20 
  State = DeviceNodeStarted (0x308) 
  Previous State = DeviceNodeEnumerateCompletion (0x30d) 
  CmResourceList at 0xffffce0713518330  Version 1.1  Interface 0xf  Bus #0 
    Entry 0 - Port (0x1) Device Exclusive (0x1) 
Flags (PORT_MEMORY PORT_IO 16_BIT_DECODE  
Range starts at 0x60 for 0x1 bytes 
    Entry 1 - Port (0x1) Device Exclusive (0x1) 
Flags (PORT_MEMORY PORT_IO 16_BIT_DECODE  
Range starts at 0x64 for 0x1 bytes 
    Entry 2 - Interrupt (0x2) Device Exclusive (0x1) 
Flags (LATCHED  
Level 0x1, Vector 0x1, Group 0, Affinity 0xffffffff 
... 
  TranslatedResourceList at 0xffffce0713517bb0  Version 1.1  Interface 0xf  Bus #0 
    Entry 0 - Port (0x1) Device Exclusive (0x1) 
Flags (PORT_MEMORY PORT_IO 16_BIT_DECODE  
Range starts at 0x60 for 0x1 bytes 
    Entry 1 - Port (0x1) Device Exclusive (0x1) 
Flags (PORT_MEMORY PORT_IO 16_BIT_DECODE  
Range starts at 0x64 for 0x1 bytes 
    Entry 2 - Interrupt (0x2) Device Exclusive (0x1) 
Flags (LATCHED  
Level 0x7, Vector 0x70, Group 0, Affinity 0xff
The device node tells you that this device has a resource list with three entries, one of which 
is an interrupt entry corresponding to IRQ 1. (The level and vector numbers represent the GSIV 
IRQL as 7 (this is the level number) and the interrupt vector as 0x70.
On ACPI systems, you can also obtain this information in a slightly easier way by reading the 
extended output of the !acpiirqarb command introduced earlier. As part of its output, it displays 
the IRQ to IDT mapping table:
Interrupt Controller (Inputs: 0x0-0x77): 
(01)Cur:IDT-70 Ref-1 Boot-0 edg hi    Pos:IDT-00 Ref-0 Boot-0 lev unk 
(02)Cur:IDT-80 Ref-1 Boot-1 edg hi    Pos:IDT-00 Ref-0 Boot-1 lev unk 
(08)Cur:IDT-90 Ref-1 Boot-0 edg hi    Pos:IDT-00 Ref-0 Boot-0 lev unk 
Current Irp 00000000 RefCount 1 Type 00000032 Flags 00001040
SecurityDescriptor ffffce0711ebf3e0 DevExt ffffe50f995573f0 DevObjExt ffffe50f9959bc40 
DevNode ffffe50f9959e670 
ExtensionFlags (0x00000800)  DOE_DEFAULT_SD_PRESENT
Characteristics (0x00000080)  FILE_AUTOGENERATED_DEVICE_NAME
AttachedDevice (Upper) ffffe50f9dfe9040 \Driver\i8042prt
Device queue is not busy.
The device object is associated to a device node-
es. You can now dump these resources with the !devnode
ask for both raw and translated resource information:
6: kd> !devnode ffffe50f9959e670 f
DevNode 0xffffe50f9959e670 for PDO 0xffffe50f9959baf0
  InstancePath is "ACPI\LEN0071\4&36899b7b&0"
  ServiceName is "i8042prt"
  TargetDeviceNotify List - f 0xffffce0717307b20  b 0xffffce0717307b20
  State = DeviceNodeStarted (0x308)
  Previous State = DeviceNodeEnumerateCompletion (0x30d)
  CmResourceList at 0xffffce0713518330  Version 1.1  Interface 0xf  Bus #0
    Entry 0 - Port (0x1) Device Exclusive (0x1)
Flags (PORT_MEMORY PORT_IO 16_BIT_DECODE 
Range starts at 0x60 for 0x1 bytes
    Entry 1 - Port (0x1) Device Exclusive (0x1)
Flags (PORT_MEMORY PORT_IO 16_BIT_DECODE 
Range starts at 0x64 for 0x1 bytes