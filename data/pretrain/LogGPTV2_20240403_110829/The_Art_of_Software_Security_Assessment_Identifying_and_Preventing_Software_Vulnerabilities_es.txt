The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
1060 
http://test.com/login?sessionid= 
Clicking through this link will bring the victim to a login screen. If the session code 
accepts the embedded key, the victim will log in with a session key already known to 
the attacker. Some session implementations don't accept a key that was not supplied 
by the server, so the attacker may first need to obtain a key by browsing to the site. 
Session Management 
As a security reviewer, seeing in-house code handling session management should 
give you pause. Robust session management has many facets that are very difficult 
to implement securely. You should budget extra time to review any custom session 
code. When you're assessing a custom session implementation, ask questions such as 
the following: 
If the client gives the session ID code an unrecognized session token, does it 
create a new session? If so, does this new session have any security 
consequences? Would it be possible to attack the back-end session store or 
use up enough potential session tokens that you could easily guess the ones 
that will be created? 
Is a new session token issued after the user logs on? If not, is it possible to 
pass a session token in the request string or are there other vulnerabilities 
that allow the session token to be passed as part of a cross-site scripting 
attack? 
If an attacker launches a brute-force attack against the session mechanism by 
trying to guess a valid session token, is there any mechanism that detects this 
behavior or reacts to it? 
Is session data load-balanced or shared between multiple Web servers? Is 
there a potential for security-relevant failure in this mechanism? Are there 
race conditions with modifications to the same variable at the same time? 
How is the session token transmitted? Is it done with a cookie, via hidden 
Form fields, or by modifications of URI strings? Is there any risk of the session 
token being exposed through sniffing attacks, Web server and proxy logs, 
browser histories, and Referer tags? 
Is session access code thread-safe? What happens if two clients try to access 
the session at the same time? Is there any potential for race conditions, or is 
only one Web page allowed to have the session data structure open at a time? 
Is session expiration handled reasonably? Keep in mind that a user's session 
token quite possibly resides on the client machine after the user is done with 
your site. If attackers get access to that token via exploitation or cross-site 
scripting, they could hijack the user's session. Also, if expiration is 
inconsistently enforced or an implementation flaw affects session timeout, a 
few days or weeks of activity could leave hundreds of thousands of dormant 
sessions that attackers could potentially brute-force later. 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
1061 
Can users intentionally destroy their sessions by logging out of the 
application? 
Session Tokens 
As discussed previously, many applications and Web frameworks use a session token 
to track state and uniquely identify a session. In a good implementation, these tokens 
are securely generated, long random numbers that prove effectively impossible to 
predict or reuse after expiration. If session tokens aren't generated by using a solid 
random number algorithm with enough entropy, the entire site's security can be 
jeopardized. 
The simplest, and least secure, scheme for generating session tokens is having a 
global session token and incrementing it each time a new session is created. With the 
proliferation of frameworks and languages that handle sessions, using incremental 
session tokens isn't common now, but they are used occasionally in custom session 
implementations. The impact is usually severe. If you log in to a site and are assigned 
the session token X, you know the next user to log in gets the session token X+1. You 
can then wait around a bit and hijack the next user's session after authentication by 
submitting the predicted next session token. Code auditors can easily recognize this 
scheme by observing the source code or monitoring the session tokens the Web site 
produces. 
People have come up with a vast number of schemes to generate session tokens. The 
worst schemes, and the ones to watch for, use easily recognizable and easily 
predictable information to form the token. If a site uses an e-mail address and a 
username, or an IP address and a username, as the session token, after you've 
observed your own token, you're in a good position to start guessing other users' 
tokens. For example, you could easily brute-force a session token based on 
concatenating the time of day in seconds and the user's account number. Attackers 
could try tens of thousands of accounts while probing for a time period during which 
the site is normally under heavy traffic and has many active users. 
Keep in mind that attackers can usually brute-force potential session tokens at 
extremely high speeds because of the stateless nature of HTTP. Also, attackers might 
be content with getting access to any session at all, not just a particular user they're 
targeting. A given scheme might make it hard for attackers to access a particular 
victim's account, but to be safe, the scheme needs to make it difficult for attackers to 
access any account with a broad-based attack that simply looks for the first success. 
If you have the time and resources, try to launch one of these attacks yourself by 
creating small testing scripts that search for valid tokens in a tight loop. 
Ideally, the session token needs to have a component that's random, unique, and 
unpredictable. This random component also needs to be large enough that attackers 
can't simply try a high percentage of the possible combinations in a reasonable 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
1062 
amount of time. This random component of the session token should be difficult to 
predict. The linear congruential generator (LCG) random number generators in most 
general-purpose programming libraries aren't appropriate for this purpose. For 
example, the numbers generated by the rand() family of functions on a typical UNIX 
standard library and the Java.util.Random class can be predicted easily, as they use 
the last result of the random operation as the seed for the next random operation. 
You might see systems that use sources of data that aren't secure but do 
transformations on it so that ascertaining how tokens are constructed would be 
difficult. For example, take a system that uses the time of day concatenated with the 
user's account number and a random number from a LCG, but MD5 hashes the whole 
string. You would have a hard time figuring out how to brute-force those session 
tokens from a black-box perspective, but it's not impossible. Attackers with enough 
patience and intuition could probably figure this scheme out eventually. Ultimately, 
although these schemes might be reasonably secure against external attackers, they 
aren't worth the potential risk of the obscurity being breached, especially when 
making the system demonstrably secure is simple. 
If a system is based on a cryptographic algorithm that requires a seed or key, you 
should evaluate the possibility of an attacker performing an offline attack and 
discovering the seed or key. For example, if the system generates a secure hash of 
the time of day combined with a global sequence number for each user, that's a weak 
seed that can be brute-forced. Even with limited inside knowledge, an offline search 
could be performed until the attacker figured out the algorithm for constructing the 
seed. 
This issue is explored more in Chapter 18(? [????.]), but for the Web environment, 
you should keep the following points in mind: 
If your session token is too short, attackers can simply brute-force itthat is, try 
every possibility until they hit on an active session. 
Time doesn't provide adequate entropy. Time specified with seconds can be 
brute-forced easily, and HTTP servers usually advertise times with seconds for 
every response in the Date response header. More precise timeswith 
milliseconds, for exampleprovide only a small amount of entropy, as attackers 
likely know the exact second processing occurred. 
Simple random number generators, such as an LCG psuedo-random number 
generator (PRNG), don't offer enough protection. If you seed a typical random 
number function securely and then pull session tokens from it, attackers can 
launch an attack by observing session tokens and using them to predict future 
tokens. Cryptographically random values are needed instead. 
Note 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
1063 
Try to determine how session tokens are generated, and attempt to make sure that 
predicting or guessing a future session token is difficult. If you have the time and 
resources, it can be worth reverse-engineering or auditing any infrastructure 
component that handles sessions on behalf of the application, as they aren't always 
as secure as the developers would hope. 
Session Token Transmission 
Another session security concern is secure transmission of the session token. Watch 
for these issues when you're auditing a Web application: 
If the session token is stored in a cookie, make sure the cookie is marked 
secure and is set only on pages served over SSL. Otherwise, the Web site runs 
the risk of transmitting session tokens in clear text over the network, which 
could be a major exposure, depending on the system's environment. 
Watch for systems that transfer the session token in a GET-style query variable. 
These requests run the risk of being recorded in Web server logs and proxy 
logs, but there's a more subtle problem: If users at your Web site click a link 
to another Web site, the query string, with the session token, is transmitted to 
that third-party Web site via the Referer header field. This could certainly be 
an issue, depending on the Web site's design and whether it can contain links 
to third-party sites. Keep in mind that cross-site scripting attacks could also be 
used to capture tokens via the Referer header field. 
Authentication 
Keep the following areas of inquiry in mind while examining a Web application's 
authentication mechanisms: 
Try to determine every possible resource on the Web site that's accessible 
without authentication. Double-check configuration files for extraneous 
functionality, and make sure there isn't anything accessible that should be 
protected. Any dynamic content that's available before authentication should 
be a priority in your audit because it's the content attackers will most likely 
explore. Any security vulnerabilities in generally accessible content can render 
the rest of the site's security useless. 
Look for simple mistakes in authentication mechanisms. For example, in one 
application, the programmer didn't distinguish between the empty string "" 
and NULL in a Java servlet. This issue could be exploited to log in as an 
unnamed user by providing an empty string for the user name. These kinds of 
simple mistakes are easy to make, so study the actual login and password 
verification code line by line when possible. 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
1064 
Check initial authentication interfaces for SQL injection as well as other types 
of injection issues. If any kind of external authentication system is involved, 
see whether you can get a machine to attempt to authenticate to a device of 
your choosing. For example, try usernames of admin@1.2.3.4 or 
1.2.3.4\admin and see whether you can elicit any kind of response or packets 
destined to the machine you specify. 
Check for account/password pairs commonly used for administrative, default, 
and test accounts, such as admin/admin, guest/, guest/guest, test/test, 
test/test 123, qa/qa, and so on. 
Attempt to find a way to discern a legitimate user from an invalid user, 
perhaps via timing or differences in error messages. If the system allows you 
to discover valid and invalid users, it's probably an unnecessary exposure of 
information. Also, look for error messages for locked-out users or special 
situations that might give out information. 
Review account lockout procedures. Keep in mind that HTTP authentication 
can be performed quickly, so it's susceptible to brute-force attacks. This 
possibility has to be balanced with the possibility of a denial-of-service 
resulting from a wide-scale account lockout attack, which could be equally 
damaging. 
Is any form of password strength checking used in the site? Are these rules so 
strict that they actually make it easier to predict valid passwords? 
Review password storage procedures. How is password data managed and 
stored? Are passwords stored in plain text unnecessarily? 
There are two styles of password brute-forcing attacks: the straightforward 
one, in which attackers attempts to guess user passwords by using a 
dictionary, and a less straightforward one. Say the system has a maximum of 
three bad logins before a lockout. Attackers can pick a likely password that 
someone will have and attempt to try every login with that password. They 
can do this once across all possible accounts, and they might have reasonable 
success, depending on the password policies and the size of the user pool. 
If authentication is handled by a framework, you should feel comfortable 
testing that framework for obvious problems. For example, a WebLogic 
configuration allowed a method of GeT, instead of GET, to completely bypass 
the framework-based form authentication system. Don't be afraid to get your 
hands dirty, and don't trust anything. 
Auditing Tip 
First, focus on content that's available without any kind of authentication because this 
code is most exposed to Internet-based attackers. Then study the authentication 
system in depth, looking for any kind of issue that lets you access content without 
valid credentials. 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
1065 
Authorization and Access Control 
Authorization refers to the application components responsible for ensuring that 
authenticated users have access to only resources and actions to which they're 
entitled. To assess a system's authorization implementation, you want to determine 
which privilege levels the system defines and what the possible user roles are. Then 
you want to figure out what resources each privilege level can access and make sure 
everything is consistent. Mentally assume the role of each type of user, and then 
study the code and the available content to determine which resources you can 
access and whether your access is appropriate. 
Authorization can be performed in a centralized fashion, with all Web components 
sharing code that performs permission checks. It can also be decentralized, with each 
request handler being responsible for making sure the user is authorized to proceed. 
In either style, it's rare for authorization to be applied consistently in every situation, 
as it takes just one oversight, such as the following points, to miss something: 
If authorization isn't centralized, you're likely to find a mistake in not checking 
an action of a particular form. Be on the lookout for any situation in which a 
piece of data is validated in one location but acted on in another location. If 
you can go directly to the location where the action occurs, you can potentially 
evade the authorization check. Refer to "Page Flow" earlier in this chapter, as 
these types of vulnerabilities are related. 
Centralized authorization checks have pitfalls, too. Be on the lookout for 
architectures that have a script that includes an authorization script and a 
separate script to perform the action. You can often request the action script 
directly through the Web tree and bypass the authorization checking. 
If centralized authorization checks are based on filenames, double-check that 
there aren't ways to circumvent the check. Consider extraneous PATH_INFO 
variables, the use of special characters such as %00, or the filename 
canonicalization issues discussed in Chapter 8(? [????.]). 
Again, don't be afraid to test middleware and infrastructure components. It's 
not uncommon for straightforward mistakes to be made in these components, 
even in commercial products. 
Auditing Tip 
When reviewing authorization, you need to ensure that it's enforced consistently 
throughout the application. Do this by enumerating all privilege levels, user roles, and 
privileges in use. 
Encryption and SSL/TLS 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
1066 
SSL has been mentioned previously in this book, and this section offers a brief recap. 
Secure Sockets Layer/Transport Layer Security (SSL/TLS) is an application-layer 
protocol for securing communications between two clients over a socket connection. 
It uses certificates to authenticate the connection endpoints and encrypts 
communications over the socket. SSL allows both connection endpoints to be 
authenticated via the certificate, although most Web applications only authenticate 
the server to the client. TLS is an addition to SSL that primarily allows an active 
plain-text connection to be upgraded to an SSL connection. 
Authentication in SSL is handled entirely by certificates. Each endpoint contains a list 
of certificate authorities (CAs) it trusts. Any certificate presented to a client is checked 
to see whether it's valid and has been signed by one of these authorities. CAs are 
most apparent to Web users when they see an error message displayed while 
attempting to connect to an SSL Web site. The site's certificate might be expired; the 
domain name might not match the certificate exactly (such as www.neohapsis.com 
versus neohapsis.com); or the signing CA might not be trusted by the client. 
SSL is typically used when a server authenticates itself to a client by proving it 
corresponds to the domain name being requested. Additionally, registering a 
certificate with a trusted CA generates a paper trail and varying degrees of 
authentication, depending on the type of certificate. It's intended to make Web 
surfers feel reasonably assured that they're interacting with the correct Web site and 
their communications (such as personal or financial information) can't be intercepted 
by third parties. 
A less typical application of SSL communication is to validate the client to the server. 
However, this use is growing more common in Web services, in which both the client 
and server are automated systems. Both ends of the connection validate each other 
in essentially the same manner described previously. This technique is also useful for 
validating user connections to extremely critical sites, as it reduces most of the noise 
from worms and automated probes. Keep the following points in mind when assessing 
SSL use in Web applications: 
SSL versions before SSLv3/TLSv1 have known cryptographic vulnerabilities. 
U.S. cryptographic restrictions have historically limited key strength to 40 bits 
for any exported software. This key size is currently considered insufficient for 
protection, and the restrictions were lifted in 1996. 
Many applications restrict only the login sequence, not the remainder of the 
session. This practice leaves the session key and all further communications 
vulnerable to eavesdropping and could result in exposing sensitive 
information or allowing the session to be hijacked. 
Many small applications use self-signed certificates, meaning the browser 
doesn't trust the CA by default. This approach is vulnerable to a 
man-in-the-middle attack, as described in Chapter 3(? [????.]), "Operational 
Review." 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
1067 
Phishing and Impersonation 
Attackers tend to follow the path of least resistance. More technical attackers might 
focus on finding intricate vulnerabilities in a Web application through focused black 
box testing, but a newer class of Internet criminal has adopted a simpler approach: 
the phishing attack. 
For each Web site criminals would like to attack, they construct a fake Web site 
resembling their target. They then attempt to lure users to that Web site through 
official-looking e-mails sent to possible users. If users of the site click the e-mail and 
end up at the faked Web site, they might have difficulty distinguishing it from the real 
site. Consequently, users can end up being tricked into surrendering credentials or 