[图 9-1](../img/fig9-1.png) 展示了一个关于体育网站的非线性一致例子【9】。Alice 和 Bob 正坐在同一个房间里，都盯著各自的手机，关注著 2014 年 FIFA 世界杯决赛的结果。在最后得分公布后，Alice 重新整理页面，看到宣布了获胜者，并兴奋地告诉 Bob。Bob 难以置信地重新整理了自己的手机，但他的请求路由到了一个落后的资料库副本上，手机显示比赛仍在进行。
如果 Alice 和 Bob 在同一时间重新整理并获得了两个不同的查询结果，也许就没有那么令人惊讶了。因为他们不知道伺服器处理他们请求的精确时刻。然而 Bob 是在听到 Alice 惊呼最后得分 **之后**，点选了重新整理按钮（启动了他的查询），因此他希望查询结果至少与爱丽丝一样新鲜。但他的查询返回了陈旧结果，这一事实违背了线性一致性的要求。
### 什么使得系统线性一致？
线性一致性背后的基本思想很简单：使系统看起来好像只有一个数据副本。然而确切来讲，实际上有更多要操心的地方。为了更好地理解线性一致性，让我们再看几个例子。
[图 9-2](../img/fig9-2.png) 显示了三个客户端线性一致资料库中同时读写相同的键 `x`。在分散式系统文献中，`x` 被称为 **暂存器（register）**，例如，它可以是键值储存中的一个 **键**，关系资料库中的一 **行**，或文件资料库中的一个 **文件**。
![](../img/fig9-2.png)
**图 9-2 如果读取请求与写入请求并发，则可能会返回旧值或新值**
为了简单起见，[图 9-2](../img/fig9-2.png) 采用了使用者请求的视角，而不是资料库内部的视角。每个横柱都是由客户端发出的请求，其中柱头是请求传送的时刻，柱尾是客户端收到响应的时刻。因为网路延迟变化无常，客户端不知道资料库处理其请求的精确时间 —— 只知道它发生在传送请求和接收响应之间的某个时刻。[^i]
[^i]: 这个图的一个微妙的细节是它假定存在一个全域性时钟，由水平轴表示。虽然真实的系统通常没有准确的时钟（请参阅 “[不可靠的时钟](ch8.md#不可靠的时钟)”），但这种假设是允许的：为了分析分散式演算法，我们可以假设存在一个精确的全域性时钟，不过演算法无法访问它【47】。演算法只能看到由石英振荡器和 NTP 产生的对真实时间的逼近。
在这个例子中，暂存器有两种型别的操作：
* $read(x)⇒v$表示客户端请求读取暂存器 `x` 的值，资料库返回值 `v`。
* $write(x,v)⇒r$ 表示客户端请求将暂存器 `x` 设定为值 `v` ，资料库返回响应 `r` （可能正确，可能错误）。
在 [图 9-2](../img/fig9-2.png) 中，`x` 的值最初为 `0`，客户端 C 执行写请求将其设定为 `1`。发生这种情况时，客户端 A 和 B 反复轮询资料库以读取最新值。A 和 B 的请求可能会收到怎样的响应？
* 客户端 A 的第一个读操作，完成于写操作开始之前，因此必须返回旧值 `0`。
* 客户端 A 的最后一个读操作，开始于写操作完成之后。如果资料库是线性一致性的，它必然返回新值 `1`：因为读操作和写操作一定是在其各自的起止区间内的某个时刻被处理。如果在写入结束后开始读取，则读取处理一定发生在写入完成之后，因此它必须看到写入的新值。
* 与写操作在时间上重叠的任何读操作，可能会返回 `0` 或 `1` ，因为我们不知道读取时，写操作是否已经生效。这些操作是 **并发（concurrent）** 的。
但是，这还不足以完全描述线性一致性：如果与写入同时发生的读取可以返回旧值或新值，那么读者可能会在写入期间看到数值在旧值和新值之间来回翻转。这个系统对 “单一资料副本” 的模拟还不是我们所期望的。[^ii]
[^ii]: 如果读取（与写入同时发生时）可能返回旧值或新值，则称该暂存器为 **常规暂存器（regular register）**【7,25】
为了使系统线性一致，我们需要新增另一个约束，如 [图 9-3](../img/fig9-3.png) 所示
![](../img/fig9-3.png)
**图 9-3 任何一个读取返回新值后，所有后续读取（在相同或其他客户端上）也必须返回新值。**
在一个线性一致的系统中，我们可以想象，在 `x` 的值从 `0` 自动翻转到 `1` 的时候（在写操作的开始和结束之间）必定有一个时间点。因此，如果一个客户端的读取返回新的值 `1`，即使写操作尚未完成，所有后续读取也必须返回新值。
[图 9-3](../img/fig9-3.png) 中的箭头说明了这个时序依赖关系。客户端 A 是第一个读取新的值 `1` 的位置。在 A 的读取返回之后，B 开始新的读取。由于 B 的读取严格发生于 A 的读取之后，因此即使 C 的写入仍在进行中，也必须返回 `1`（与 [图 9-1](../img/fig9-1.png) 中的 Alice 和 Bob 的情况相同：在 Alice 读取新值之后，Bob 也希望读取新的值）。
我们可以进一步细化这个时序图，展示每个操作是如何在特定时刻原子性生效的。[图 9-4](../img/fig9-4.png) 显示了一个更复杂的例子【10】。
在 [图 9-4](../img/fig9-4.png) 中，除了读写之外，还增加了第三种类型的操作：
* $cas(x, v_{old}, v_{new})⇒r$ 表示客户端请求进行原子性的 [**比较与设定**](ch7.md#比较并设定（CAS）) 操作。如果暂存器 $x$ 的当前值等于 $v_{old}$ ，则应该原子地设定为 $v_{new}$ 。如果 $x$ 不等于 $v_{old}$ ，则操作应该保持暂存器不变并返回一个错误。$r$ 是资料库的响应（正确或错误）。
[图 9-4](../img/fig9-4.png) 中的每个操作都在我们认为操作被执行的时候用竖线标出（在每个操作的横柱之内）。这些标记按顺序连在一起，其结果必须是一个有效的暂存器读写序列（**每次读取都必须返回最近一次写入设定的值**）。
线性一致性的要求是，操作标记的连线总是按时间（从左到右）向前移动，而不是向后移动。这个要求确保了我们之前讨论的新鲜度保证：一旦新的值被写入或读取，所有后续的读都会看到写入的值，直到它被再次覆盖。
![](../img/fig9-4.png)
**图 9-4 将读取和写入看起来已经生效的时间点进行视觉化。客户端 B 的最后一次读取不是线性一致的**
[图 9-4](../img/fig9-4.png) 中有一些有趣的细节需要指出：
* 第一个客户端 B 传送一个读取 `x` 的请求，然后客户端 D 传送一个请求将 `x` 设定为 `0`，然后客户端 A 传送请求将 `x` 设定为 `1`。然而，返回给 B 的读取值为 `1`（由 A 写入的值）。这是可以的：这意味著资料库首先处理 D 的写入，然后是 A 的写入，最后是 B 的读取。虽然这不是请求传送的顺序，但这是一个可以接受的顺序，因为这三个请求是并发的。也许 B 的读请求在网路上略有延迟，所以它在两次写入之后才到达资料库。