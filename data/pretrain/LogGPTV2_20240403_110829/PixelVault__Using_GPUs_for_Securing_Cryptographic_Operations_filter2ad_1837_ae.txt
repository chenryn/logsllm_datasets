bit modular exponentiations based on both the radix and RNS ap-
proaches, using an NVIDIA 8800GTS. Harrison et al [25] present
a GPU implementation of a 1024-bit RSA decrypt primitive, out-
performing a comparable CPU implementation by up to 4 times.
Besides performance, little focus has been placed on increas-
ing the security of cryptographic implementations using GPUs, al-
though the potential of modifying the GPU to a minimal secure
computing base is not new. Cook et al [17] presented a mecha-
nism to transfer encrypted video that is only decrypted once on the
GPU. Based on this idea, our key insight is to demonstrate that the
cryptographic operations executed on the GPU cannot only beneﬁt
in terms of performance, but also in terms of security, by keeping
sensitive keys away from the CPU and the host memory.
Privilege separation is a good practice to restrict the number of
operations executed with elevated privileges. Applications should
be designed with the principle of least privilege, i.e., every op-
eration should be executed with the minimum level of privileges.
Provos et al. [50] demonstrate the value of privilege separation in
OpenSSH. Privman [33] provides an API that can be used to inte-
grate privilege separation into existing applications. Privtrans [15]
allows the automatic integration of privilege separation, with the
aid of a few annotations by the programmer. However, it has been
shown that sensitive data or system objects (e.g., memory, the en-
vironment, memory mappings, ﬁle system information, and ﬁle de-
scriptors) may still be leaked when, for instance, a trusted process
of a partitioned application spawns an untrusted child process [54].
Many reseach efforts have recently focused on systems that sup-
port trusted computation in hostile operating systems [16, 26, 29].
These systems are designed towards a generic solution for protect-
ing computation performed by any application, even by non sen-
sitive ones, when the host is compromised.
In such a setting, a
process responsible for cryptographically signing a message would
never expose its keys to the operating system, and therefore encryp-
tion will remain functional even when the operating system is com-
promised. Unfortunately, these systems require applications run-
ning in a hypervisor [16, 26], introducing signiﬁcant performance
overhead, or the addition of extra hardware abstraction layers and
the re-compilation of the operating system [29]. We anticipate
that these approaches will be eventually incorporated in commod-
ity operating systems in the future. Nevertheless, in this paper, we
seek for a less intrusive approach, that requires little modiﬁcations
in current commodity systems, does not allow for trusted system-
wide computation, but allows sensitive information, such as crypto-
graphic keys, to remain secret, even when the host is compromised.
Similar to our purposes, recent work has pursued the idea of
holding the cryptographic key solely in the registers of the CPU,
for AES [41, 56] and RSA [21]. The secret key, then, cannot be
traced in main memory, making cold boot attacks pointless. These
approaches require a trusted and bug-free component for ensuring
that an adversary cannot compromise part of the system and extract
the keys from the CPU registers. Still, a DMA-capable adversary,
with read and write access to the host physical memory, can extract
the secret keys from the CPU into the target system’s memory, from
which they can be retrieved using a normal DMA transfer [12].
On the opposite aspect, many works talk about the danger of
leaking data when ofﬂoading tasks to the GPU, in multi-user or
virtualized environments [37, 49]. Di Pietro et al. [49] talk about
the danger of leaking data from speciﬁc GPU memory hierarchies,
namely the shared memory and global memory. They also mention
that the registers contents can be exposed in cases where the devel-
oper declares more registers than the GPU contains; in such cases
where the GPU runs out of hardware registers, it can transparently
leverage global memory (“register spilling” [39]). To rule out this
possibility, PixelVault declares as many registers as the unterlying
hardware device provides, and force the compiler to explicitly no-
tify if any register spilling occurs. Similarly, Maurice et al. [37] an-
alyze the behavior of GPU global memory and show that an adver-
sary can recover data of a previously executed GPGPU application
from the global device memory. In contrast with these works, we
focus on memory hierarchies that provide a safe house for storing
data, preventing any leakage. Such memories, include the hardware
registers and the instruction caches, that are contained in modern
graphics processors. By carefully leveraging these memory types
in combination with the nonpreemptiveness execution model of the
GPUs (that guarantees that no state will be stored somewhere else
due to context-switching), we have managed to design a prototype
architecture, namely PixelVault that is tamper resistant and also of-
fers a secure environment for storing secrets.
Finally, Intel recently introduced SGX (Software Guard Exten-
sions) [27], a set of new CPU instructions for establishing private
memory regions. SGX allows an application to instantiate a pro-
tected container, which is a protected area in the application’s ad-
dress space that provides conﬁdentiality and integrity even in the
presence of privileged malware. SGX could potentially be used to
implement similar functionality to PixelVault, using an SGX con-
tainer for secure storage, and taking advantage of the CPU’s cryp-
tographic instructions. In the future, it would be interesting to com-
pare the performance and characteristics of the two approaches.
9. CONCLUSION
We have presented the design and implementation of PixelVault,
a GPU-based system that implements AES and RSA in a way that
preserves the secrecy of keys even against attacks that fully com-
promise the host system. By taking advantage of the capabilities of
modern graphics processing units (GPUs), PixelVault safely stores
any sensitive information and ofﬂoads computationally-intensive
cryptographic operations on the GPU. The underlying idea is to
perform cryptographic operations entirely on the GPU, without in-
volving the host or any memory that can be accessed by the host
(even with full administrator permissions). This implies that (a)
no secret key (nor the key schedule or intermediate states) ever
get to host-accessible memory, and (b) GPU memory—where keys
are stored—cannot be inspected while cryptographic operations are
carried out. Our only requirement is that the system is initially
bootstrapped in a trusted environment. Once GPU storage is ini-
tialized with the keys, PixelVault prevents key leakage even in case
of full system compromise. As part of our future work, we plan
to adapt our framework to other ciphers and application domains,
and also to explore the design of a generic GPU-based framework
for facilitating privilege partitioning of existing applications. We
also plan to explore how our techniques could be applied in mobile
and embedded devices. This may be harder to achieve though, as
our design requires a dedicated GPU—otherwise the mobile device
would not be able to render graphics properly.
Acknowledgments
We would like to thank our shepherd Roberto Di Pietro and the
anonymous reviewers for their valuable feedback. This work was
supported in part by the General Secretariat for Research and Tech-
nology in Greece with a Research Excellence grant, by the FP7-
PEOPLE-2010-IOF project XHUNTER No. 273765, and by the
FP7 projects NECOMA and SysSec, funded by the European Com-
mission under Grant Agreements No. 608533 and No. 257007.
10. REFERENCES
[1] Benchmarking TPM-backed SSL. http://blog.
habets.pp.se/2012/02/Benchmarking-TPM-
backed-SSL.
[2] CUDA Binary Utilities. http://docs.nvidia.com/
cuda/cuda-binary-utilities/index.html.
[3] Nouveau: Accelerated Open Source driver for nVidia cards.
http://nouveau.freedesktop.org/.
[4] NVIDIA Developer Forums - CUDA kernel timeout.
https://devtalk.nvidia.com/default/
topic/417276/cuda-kernel-timeout/.
[5] OpenSSL Project. http://www.openssl.org/.
[6] pscnv - PathScale NVIDIA graphics driver. https://
github.com/pathscale/pscnv.
[7] shinpei0208 / gdev. https://github.com/
shinpei0208/gdev.
[8] TCG PC Client Speciﬁc - TPM Interface Speciﬁcation (TIS)
Version 1.2. http://www.
trustedcomputinggroup.org/files/
resource_files/87BCE22B-1D09-3519-
ADEBA772FBF02CBD/TCG_
PCClientTPMSpecification_1-20_1-00_
FINAL.pdf.
[9] The Heartbleed Bug. http://heartbleed.com/.
[10] Who holds the encryption keys? http://www.
computerworld.com/s/article/9225414/Who_
Holds_the_Keys_.
[11] D. J. Bernstein. Cache-timing Attacks on AES, 2004.
[12] E.-O. Blass and W. Robertson. TRESOR-HUNT: Attacking
CPU-bound Encryption. In ACSAC, 2012.
[13] D. Boneh, G. Durfee, and Y. Frankel. An Attack on RSA
Given a Small Fraction of the Private Key Bits. In Lecture
Notes in Computer Science, volume 1514 of Lecture Notes in
Computer Science, pages 25–34. Springer, 1998.
[14] D. Brumley and D. Boneh. Remote Timing Attacks are
Practical. In USENIX Security, 2003.
[15] D. Brumley and D. Song. Privtrans: Automatically
Partitioning Programs for Privilege Separation. In USENIX
Security, 2004.
[16] X. Chen, T. Garﬁnkel, E. C. Lewis, P. Subrahmanyam, C. A.
Waldspurger, D. Boneh, J. Dwoskin, and D. R. Ports.
Overshadow: A Virtualization-based Approach to
Retroﬁtting Protection in Commodity Operating Systems. In
ASPLOS XIII, 2008.
[17] D. Cook, R. Baratto, and A. Keromytis. Remotely Keyed
Cryptographics Secure Remote Display Access Using
(Mostly) Untrusted Hardware. In ICICS, 2005.
[18] D. L. Cook, J. Ioannidis, A. D. Keromytis, and J. Luck.
CryptoGraphics: Secret Key Cryptography Using Graphics
Cards. In CT-RSA, 2005.
[19] J. Daemen and V. Rijmen. AES Proposal: Rijndael, 1998.
[20] Eliseo Hernandez. Accelerate Performance Using OpenCL
with Intel HD Graphics. http://software.intel.
com/en-us/articles/accelerate-
performance-using-opencl-with-intel-hd-
graphics.
[21] B. Garmany and T. Müller. PRIME: Private RSA
Infrastructure for Memory-less Encryption. In ACSAC, 2013.
[22] D. Gullasch, E. Bangerter, and S. Krenn. Cache Games –
Bringing Access-Based Cache Attacks on AES to Practice.
In IEEE S&P, 2011.
[23] J. A. Halderman, S. D. Schoen, N. Heninger, W. Clarkson,
W. Paul, J. A. Calandrino, A. J. Feldman, J. Appelbaum, and
E. W. Felten. Lest We Remember: Cold-boot Attacks on
Encryption Keys. Communications of the ACM, 52(5):91–98,
2009.
[24] O. Harrison and J. Waldron. Practical Symmetric Key
Cryptography on Modern Graphics Hardware. In USENIX
Security, 2008.
[25] O. Harrison and J. Waldron. Efﬁcient Acceleration of
Asymmetric Cryptography on Graphics Hardware. In
AFRICACRYPT, 2009.
[26] O. S. Hofmann, S. Kim, A. M. Dunn, M. Z. Lee, and
E. Witchel. InkTag: Secure Applications on an Untrusted
Operating System. In ASPLOS, 2013.
[27] Intel. Software Guard Extensions Programming Reference.
https://software.intel.com/sites/
default/files/329298-001.pdf.
[28] Y. Ishai, E. Kushilevitz, R. Ostrovsky, and A. Sahai.
Cryptography with Constant Computational Overhead. In
STOC, 2008.
[29] J. Criswell, N. Dautenhahn, and V. Adve. Virtual Ghost:
Protecting Applications from Hostile Operating Systems. In
ASPLOS, 2014.
[30] K. Jang, S. Han, S. Han, K. Park, and S. Moon. SSLShader:
Cheap SSL Acceleration with Commodity Processors. In
NSDI, 2011.
[31] Jon Stokes. AMD reveals Fusion CPU+GPU, to challenge
Intel in laptops. http://arstechnica.com/
business/2010/02/amd-reveals-fusion-
cpugpu-to-challege-intel-in-laptops/.
[32] S. Kato. Implementing Open-Source CUDA Runtime. 2013.
[33] D. Kilpatrick. Privman: A Library for Partitioning
Applications. In FREENIX, 2003.
[34] C. Koc, T. Acar, and J. Kaliski, B.S. Analyzing and
Comparing Montgomery Multiplication Algorithms. Micro,
IEEE, 16(3):26–33, 1996.
[35] P. C. Kocher. Timing Attacks on Implementations of
Difﬁe-Hellman, RSA, DSS, and Other Systems. In CRYPTO
’96, 1996.
[36] Luitjens, Justin and Rennich, Steven. CUDA Warps and
Occupancy. http://on-demand.gputechconf.
com/gtc-express/2011/presentations/cuda_
webinars_WarpsAndOccupancy.pdf, 2011.
[37] C. Maurice, C. Neumann, O. Heen, and A. Francillon.
Conﬁdentiality Issues on a GPU in a Virtualized
Environment. In FC, 2014.
[38] K. Menychtas, K. Shen, and M. L. Scott. Enabling OS
Research by Inferring Interactions in the Black-box GPU
Stack. In USENIX ATC, 2013.
[39] P. Micikevicius. Local Memory and Register Spilling.
http://on-demand.gputechconf.com/gtc-
express/2011/presentations/register_
spilling.pdf.
[40] T. Müller, A. Dewald, and F. C. Freiling. AESSE: A
Cold-boot Resistant Implementation of AES. In EuroSec,
2010.
[41] T. Müller, F. C. Freiling, and A. Dewald. TRESOR Runs
Encryption Securely Outside RAM. In USENIX Security,
2011.
[42] NVIDIA. CUDA Programming Guide, version 4.0.
http://developer.download.nvidia.com/
compute/cuda/4_0/toolkit/docs/CUDA_C_
Programming_Guide.pdf.
[43] NVIDIA. Dynamic Parallelism in CUDA. http://
developer.download.nvidia.com/assets/
cuda/files/CUDADownloads/TechBrief_
Dynamic_Parallelism_in_CUDA.pdf.
[44] NVIDIA. Next Generation CUDA Compute Architecture:
Fermi. http://www.nvidia.com/content/PDF/
fermi_white_papers/NVIDIA_Fermi_Compute_
Architecture_Whitepaper.pdf.
[45] NVIDIA. NVIDIA’s Next Generation CUDA Compute
Architecture: Kepler GK110. http://www.nvidia.
com/content/PDF/kepler/NVIDIA-Kepler-
GK110-Architecture-Whitepaper.pdf.
[46] NVIDIA Developer Zone. Flushing Instruction Cache on
GPU. https://devtalk.nvidia.com/default/
topic/467841/flushing-instruction-cache-
on-gpu/.
[47] NVIDIA Developer Zone. PTX ISA :: CUDA Toolkit
Documentation. http://docs.nvidia.com/cuda/
parallel-thread-execution/index.html.
[48] D. R. Piegdon and L. Pimenidis. Targeting Physically
Addressable Memory. In DIMVA, 2007.
[49] R. D. Pietro, F. Lombardi, and A. Villani. CUDA Leaks:
Information Leakage in GPU Architectures. ArXiv, May
2013.
[50] N. Provos, M. Friedl, and P. Honeyman. Preventing Privilege
Escalation. In USENIX Security, 2003.
[51] R. L. Rivest, A. Shamir, and L. Adleman. A Method for
Obtaining Digital Signatures and Public-key Cryptosystems.
Communications of ACM, 21, February 1978.
[52] C. J. Rossbach, J. Currey, M. Silberstein, B. Ray, and
E. Witchel. PTask: Operating System Abstractions to
Manage GPUs as Compute Devices. In SOSP, 2011.
[53] A. Shamir and N. v. Someren. Playing ’Hide and Seek’ with
Stored Keys. In FC, 1999.
[54] U. Shankar and D. Wagner. Preventing Secret Leakage from
fork(): Securing Privilege-Separated Applications. In ICC,
2006.
[55] M. Silberstein, B. Ford, I. Keidar, and E. Witchel. GPUfs:
Integrating a File System with GPUs. In ASPLOS, 2013.
[56] P. Simmons. Security through Amnesia: A Software-based
Solution to the Cold-boot Attack on Disk Encryption.
Technical report, 2011.
[57] P. Stewin and I. Bystrov. Understanding DMA Malware. In
DIMVA, 2013.
[58] R. Szerwinski and T. Güneysu. Exploiting the Power of
GPUs for Asymmetric Cryptography. In CHES, 2008.
[59] E. Tromer, D. A. Osvik, and A. Shamir. Efﬁcient Cache
Attacks on AES, and Countermeasures. Journal of
Cryptology, 23, 2010.
[60] G. Vasiliadis, L. Koromilas, M. Polychronakis, and
S. Ioannidis. GASPP: A GPU-Accelerated Stateful Packet
Processing Framework. In USENIX ATC, 2014.
[61] G. Vasiliadis, M. Polychronakis, and S. Ioannidis. MIDeA: A
Multi-Parallel Intrusion Detection Architecture. In CCS,
2011.
[62] H. Wong, M.-M. Papadopoulou, M. Sadooghi-Alvandi, and
A. Moshovos. Demystifying GPU Microarchitecture through
Microbenchmarking. In ISPASS, 2010.