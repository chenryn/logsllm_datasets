## GC崩溃
首先谈谈GC崩溃，移植至32位时，在执行到函数rewrite时，会发生崩溃，崩溃现场如下所示：
    eax=05ac8bec ebx=0000f7ff ecx=05ac8bec edx=00000081 esi=00000080 edi=01f083b8
    eip=67a06a6a esp=049ba6cc ebp=049ba6d8 iopl=0         nv up ei pl nz na po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202
    jscript!NameList::ScavengeRoots+0x20:
    67a06a6a 0fb706          movzx   eax,word ptr [esi]       ds:0023:00000080=????
    0:012> k
     # ChildEBP RetAddr  
    00 049ba6d8 67a06941 jscript!NameList::ScavengeRoots+0x20
    01 049ba6ec 67a06dd0 jscript!NameTbl::ScavengeCore+0x42
    02 049ba700 67a06cef jscript!GcContext::CollectCore+0xc6
    03 049ba718 67a5a465 jscript!GcContext::Collect+0x26
    04 049ba71c 67a05950 jscript!JsCollectGarbage+0x1c
    05 049ba784 67a02fe9 jscript!NatFncObj::Call+0xce
    06 049ba80c 67a02c68 jscript!NameTbl::InvokeInternal+0x108
    07 049ba8f4 67a02bbb jscript!VAR::InvokeByDispID+0x70
0x80显然与构造的VAR有关，但直接看也看不出什么，开始逆向NameList::ScavengeRoots  
逆向后发现此处崩溃是在发生在遍历VVAL的过程中，但很难直接判断出是哪一个Object的VVAL遍历出现了问题
因此对NameList::ScavengeRoots设置了断点，并打印ecx的值，查看最后一次造成崩溃的NameList
    bp jscript!NameList::ScavengeRoots "r ecx;g"
    g
    ...
    ecx=08724910
    ecx=087248a0
    (918.cf8): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    eax=06358bec ebx=0000f7ff ecx=06358bec edx=00000081 esi=00000080 edi=0281cd40
    eip=69cb6a6a esp=0547a7c4 ebp=0547a7d0 iopl=0         nv up ei pl nz na po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202
    jscript!NameList::ScavengeRoots+0x20:
    69cb6a6a 0fb706          movzx   eax,word ptr [esi]       ds:0023:00000080=????
    0:012> dd 087248a0
    087248a0  69cb1924 00000004 00000004 08893788
    087248b0  000003d4 00000644 00000100 00004000
    087248c0  0889378c 08893b4c 086888d8 0000000f
    087248d0  00000040 00000004 0000000a 087248e0
    087248e0  0889378c 08893ab0 08893af8 08893b2c
    087248f0  00000000 00000000 00000000 00000000
    08724900  00000000 00000000 6332436f 88000000
    08724910  69cb1924 00000004 00000004 08893e10
    0:012> dd 0889378c
    0889378c  02810003 0541b5a4 00000001 00000000
    0889379c  00000000 00000000 dfd98ab6 000002f0
    088937ac  08893ab0 00000000 00000001 089a7698
    088937bc  00410041 00000080 00000000 06358bec
    088937cc  00000000 00000080 00000000 06358bec
    088937dc  00000000 00000080 00000000 06358bec
    088937ec  00000000 00000080 00000000 06358bec
    088937fc  00000000 00000080 00000000 06358bec
    0:012> dd 08893ab0
    08893ab0  02810003 0541bda4 00000001 00000000
    08893ac0  00000000 00000000 01fe769b 00000016
    08893ad0  088932f8 00000000 00000002 08893ae0
    08893ae0  00410041 00410041 00410041 00410041
    08893af0  00410041 00000041 02810003 0541bda4
    08893b00  00000001 00000000 00000000 08893b10
    08893b10  00000005 00000002 08893b2c 00000000
    08893b20  00000003 00000000 00000005 02810003
    0:012> dd 08893af8
    08893af8  02810003 0541bda4 00000001 00000000
    08893b08  00000000 08893b10 00000005 00000002
    08893b18  08893b2c 00000000 00000003 00000000
    08893b28  00000005 02810003 0541b5a4 00000001
    08893b38  00000000 00000000 00000000 00000061
    08893b48  00000002 00000000 00000000 00000004
    08893b58  089a6818 00000041 00000000 00000000
    08893b68  089a67d8 08893b70 00000000 00000000
以上可以发现是Vval的next域被修改，而根据多次实验发现导致奔溃的第四个Vval的Value都是1，即在overlay中的offset为1的Object导致崩溃，因此对此Object的第二个Vval的next域设置硬件断点，发现不是分配时对该值初始化错误，而是函数CIndexedNameList::ScavengeRoots对其进行了修改。
类似的在创建Vval的时候对next域下硬件断点，然后再在gc时对CIndexedNameList::ScavengeRoots设断，发现第七次命中CIndexedNameList::ScavengeRoots会命中硬件断点，查看此时的CIndexNameList
    0:012> dd 01c04e28 L80
    01c04e28  6cae23c0 00000132 00000002 0557f5f0
    01c04e38  0000007c 00000100 00000100 00004000
    01c04e48  0557f5f4 0557f650 0ba980e8 0000000f
    01c04e58  00000040 00000000 0000000a 01c04e68
    01c04e68  00000000 00000000 00000000 00000000
    01c04e78  00000000 00000000 00000000 00000000
    01c04e88  00000000 00000000 07283458 00000040    --------
    01c04e98  00000003 00000008 062bd880 00000700
    01c04ea8  00002000 00000100 00004000 00000000
    01c04eb8  00000080 00000001 07c0bfe8 6caea771    --------
    01c04ec8  00000000 00000000 00000003 00000000
    01c04ed8  00000080 00000001 07c0bfd8 6caea771    --------
    01c04ee8  00000000 00000000 00000004 00000000
    01c04ef8  00000080 00000001 07c0c008 6caea771    --------
    01c04f08  00000000 00000000 00000005 00000000
    01c04f18  00000080 00000001 07c0bff8 6caea771    --------
    01c04f28  00000000 00000000 00000006 00000000
    01c04f38  00000080 00000001 07c0c028 6caea771    --------
    01c04f48  00000000 00000000 00000007 00000000
    01c04f58  00000080 00000001 07c0c018 6caea771    --------
    01c04f68  00000000 00000000 00000008 00000000
    01c04f78  00000080 00000001 07c0c048 6caea771    --------
    01c04f88  00000000 00000000 00000009 00000000
    01c04f98  00000080 00000001 07c0c038 6caea771    --------
    01c04fa8  00000000 00000000 0000000a 00000000
    01c04fb8  01c04eb8 00000008 00000200 00000130    --------
    01c04fc8  00000132 00000140 0bb90048 0557f5f4
    01c04fd8  00000000 0557f630 00000000 00000000
    01c04fe8  00000001 00000001 00000001 00000002
    01c04ff8  00000001 00000003 00000001 00000004
    01c05008  00000001 00000005 00000001 00000006
    01c05018  00000001 00000007 00000001 00000000
CIndexedNameList是jscript.dll中的数组，CIndexedNameList的详细数据结构可以参考The Art of Leaks:
The Return of Heap Feng
Shui中的p9-p10，这里只需要判断出这个CIndexedNameList对应着total这个数组（根据数组中元素的个数），此时动态调试后发现CIndexedNameList::ScavengeRoots会将数组中的每一个VAR指向的内存都`&0xF7FF`，这就是导致Vval中next域被修改的元凶。
根据前面介绍的GC知识，Scavenge函数是为了找到所有可达的对象，total中保存了304个对象的指针，GC会将这些对象在GcBlock中的type的标记去除，去除的方式就是`&0xF7FF`，但实际上这个GcBlock已经被重占用了，也没有所谓的标记过程，因此这里让total不可达即可，即在rewirte()函数中的GC前执行`total
= new Array();`
## RCE过程中64位与32位的区别
**64位下的RCE**
由于32位和64位的传参方式不同，这样的构造无法将参数传递给NtContinue
**32位下的RCE**
maxpl0it在writeup上提到了stack pivot，32位下也可以使用这一技巧，具体如下图所示：
移植后的poc见[github](https://github.com/wugedz/CVEs/tree/master/CVE-2020-0674)
## reference
  1. 
  2. 
  3. 