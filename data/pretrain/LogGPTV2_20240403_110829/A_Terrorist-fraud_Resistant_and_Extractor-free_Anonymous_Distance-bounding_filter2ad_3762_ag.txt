parameter λ.
MAC.sigsk(m): returns a tag s from the message m and the
key sk.
MAC.versk(s, m): returns a veriﬁcation bit v from the tag s
and the key sk.
A message authentication scheme is said correct if and only
if the equality MAC.versk(m, MAC.sigsk(m)) = 1 holds for any
message m and any key sk generated by MAC.gen.
Definition 15. A digital signature scheme SIG is a triplet
of algorithms (SIG.gen, SIG.sig, SIG.ver) s. t.:
SIG.gen(1λ): returns a key pair (sk, vk) from a global security
parameter λ.
SIG.sigsk(m): returns a signature s from the message m and
the signing key sk.
SIG.vervk(s, m): returns a veriﬁcation bit v from the signa-
ture s and the veriﬁcation key vk.
A digital signature scheme is said correct if and only if the
equality SIG.verpk(m, SIG.sigsk(m)) = 1 holds for any mes-
sage m and any key pair (sk, vk) generated by SIG.gen.
Definition 16. Let MAC : (MAC.gen, MAC.sig, MAC.ver)
be a message authentication code. MAC is said to be unforge-
able against chosen message attack (EUF-CMA) when for
any adversary A, the advantage probability AdvEUF-CMA
A,MAC (1λ)
is negligible:
(cid:20) k ← MAC.gen(1λ)
Pr
(s, m) ← AMAC.signk,MAC.verk (λ)
: MAC.verk(s, m) = 1
in which the oracles MAC.signk, MAC.verk are deﬁned as:
MAC.signk(m): returns (m, MAC.sigk(m)) on input m.
MAC.verk(s, m): if s has been generated by MAC.signk(m)
returns ⊥, while otherwise it returns MAC.verk(m, s).
Definition 17. Let SIG : (SIG.gen, SIG.sig, SIG.ver) be a
digital signature scheme. SIG is said to be unforgeable against
chosen message attack when for any adversary A, the advan-
tage probability AdvEUF-CMA
(1λ) is negligible:
(cid:20) k ← SIG.gen(1λ)
A,SIG
Pr
(s, m) ← ASIG.signsk,SIG.vervk (vk, λ)
: SIG.vervk(s, m) = 1
in which the oracles SIG.signsk, SIG.vervk are deﬁned as:
SIG.signsk(m): returns (m, SIG.sigsk(m)) on message m.
SIG.vervk(s, m): if s has been generated by SIG.signsk(m) re-
turns ⊥, while otherwise it returns SIG.vervk(s, m).
In this case, the veriﬁcation oracle is optional since the ad-
versary knows the veriﬁcation key and can simulate it.
Definition 18. A revocable group signature scheme G-SIG
is deﬁned by six algorithms:
G.gen(1λ): according to a security parameter k, returns a
global group/master key pair (gpk, msk) and two empty
lists: the user list UL and the revoked user list RL.
(cid:21)
(cid:21)
812G.joinmsk(i, gpk, UL): is a protocol between a user Ui (using
gpk) and a group manager GM (using msk and gpk).
Ui interacts with GM to obtain a group signing key
sski. Finally, GM outputs a value regi and adds Ui to
UL.
G.revmsk(i, UL, RL, gpk): computes revocation logs revi for Ui,
using regi, gpk and msk, and moves Ui from UL to RL.
(m): returns a group signature σ for the message m.
G.sigsski
G.vergpk(σ, m, RL): returns 1 if σ is valid for the message m
and the signing key sski of a non-revoked user, while
otherwise it returns 0.
G.opemsk(σ, m, UL, gpk): outputs the identity of the user Ui
who generated the signature σ.
Definition 19. Let G-SIG be a group signature scheme.
The anonymity experiment ExpAnonA,G-SIG(λ) for the adversary
A on G-SIG is deﬁned as follows. A interacts with a chal-
lenger who creates (UL, RL, msk, gpk) using G.gen(1λ), gives
gpk to A, and sets the lists CU and Σ. During this phase A
has access to G-oracles:
G.Joinh(·): on i, creates Pi with G.joinmsk(i, gpk, UL).
G.Joinc(·): on i, creates Pi with G.joinmsk(i, gpk, UL) with A
and adds him to CU.
G.Revoke(·): on i, revokes Pi with G.revmsk(i, RL, UL, gpk),
updates RL and returns it.
G.Corrupt(·): on i, returns the secret information of an ex-
isting Pi. If Pi ∈ UL, it sends sski to A and adds Pi to
CU.
G.Sign(·,·): on i, returns a signature σp on behalf of Pi,
using G.sigsski
(m) and adds the pair (m, σp) to Σ.
G.Open(·,·): on i, opens a signature σ on m and returns Pi
to A, using the algorithm G.opemsk(σ, m, UL, gpk). This
oracle rejects all signatures produced by G.Signb(·,·).
A outputs (i0, i1) to the challenger. If i0 and i1 ∈ CU, the
challenger stops. Otherwise, he picks b $← {0, 1} and sends it
to A. A cannot henceforth use G.Corrupt(·) and G.Revoke(·)
on i0 or i1. Moreover, A has access to the G-oracle:
G.Signb(·,·): On m, returns G.sigsskib
Finally, A returns b(cid:48). If b = b(cid:48), the challenger returns 1,
which means that the guess of A is correct, while otherwise
he outputs 0.
We deﬁne A’s advantage on this experiment as
(m).
(cid:12)(cid:12)(cid:12)(cid:12)Pr[ExpAnonA,G-SIG(λ) = 1] − 1
2
(cid:12)(cid:12)(cid:12)(cid:12)
AdvAnonA,G-SIG(λ) =
and the advantage on the experiment as
AdvAnon
G-SIG(λ) = max
A∈Poly(λ)
{AdvAnonA,G-SIG(λ)}.
A group signature G-SIG is anonymous when if AdvAnon
is negligible.
G-SIG(λ)
B. SECURITY PROOFS
B.1 Distance-hijacking Resistance
1
Proof Proof of Theorem 4. Note that if A uses the
message Prompt as the initial message, i.e., he lets an hon-
est prover send it and then his authentication automatically
fails, as idpub(P ) and/or idprv(P ) do not correspond to the
identity of A.
Hence, consider the case in which A initiated the protocol
with a message e∗ (associated with α∗, β∗). Let e (and α||β)
denote the values picked by a nearby honest prover P . For
each challenge ci, either A uses Prompt to let P respond or
he uses Commit to respond himself before receiving ci.
• If he uses Prompt, his response is valid with probability
2 . This is the probability to have αi = α∗
i (or βi = β∗
i ).
i ⊕ mi, and he can
i (cid:54)=
commit to a correct response with probability 1, or α∗
i ⊕mi, and he must guess the challenge to commit to the
β∗
correct response. Since m is uniformly distributed and
unknown to A when he picks α||β, P r[α∗
i ⊕mi] = 1
2 .
Hence, the probability to commit to the valid response is
P r[α∗
• If he uses Commit, either α∗
i = β∗
i ⊕ mi] · 1
i ⊕ mi] · 1 + P r[α∗
DB(A) is at most(cid:0) 3
It follows that the best strategy for A is to respond by him-
self, as in a classical DF, using Commit. For n challenges,
his advantage AdvDH
ble.
B.2 Privacy Property
(cid:1)n, which is negligi-
i = β∗
i (cid:54)= β∗
i = β∗
2 = 3
4 .
4
(λ) is also non-negligible.
Proof Proof of Theorem 5. Assume that there exists
a polynomial-time adversary A s. t. AdvPrivA,TREADPub (λ) is
non-negligible. We show how to build an adversary B s. .t.
AdvIND-CCA2
B,PKE
Initially, the challenger sends a key pkv to B. Then, B
runs DB.gen(1λ) to generate the setup parameters of the
scheme and sends to A the public set-ups and pkv. Having
access to PKE-oracles from his challenger, B can simulate
the DB-oracles for A as follows.
DB.Joinc(·): on i, B returns a public/secret key pair (pki, ski)
DB.Prover(·): B simulates Pi for A using ski and pkv.
DB.Veriﬁer: B simulates V for A as follows:
of the new prover Pi using DB.join(λ).
Initialization phase B receives e from A and retrieves
the message (α||β||idprv(Pi)||σp) = PKE.decskv (e)
using his oracle. If S.vervki (σp, α||β||idprv(Pi)) = 0
is the veriﬁcation key of Pi), B returns ⊥
(vki
and aborts this simulation. Finally, he picks m $←
{0, 1}n and returns it.
Distance-bounding phase B picks cj ∈ {0, 1}, sends
it to A and waits for the response rj. He repeats
this protocol for all j in {0, . . . , n}.
Veriﬁcation phase If, for all j in {0, . . . , n}, rj = αj
when cj = 0 and rj = βj ⊕ mj when cj = 1 then B
returns 1 to A, while otherwise he returns 0.
A sends (i0, i1) to B. Afterwards, B sets a counter l := 0
and simulates the challenge oracle DB.Proverb as follows.
Initialization phase B picks α||β $← {0, 1}2n and com-
(α||β||idprv(Pi0 ))
(α||β||idprv(Pi1 )). He then sends
putes the two signatures σ0
and σ1
p = S.sigski0
p = S.sigski1
813the messages m0 = (α||β||idprv(Pi0 )||σ0
p) and m1 =
(α||β||idprv(Pi1 )||σ1
p) to his challenge encryption ora-
cle SKE.enck(LRb(·,·)) to obtain e. Afterwards, he sets
Listl = (α, β, e) and increments the counter l by one.
Finally, he returns e and receives m.
Distance-bounding phase B uses α, β and m to correctly
respond to the challenges ci sent by A.
Veriﬁcation phase B receives OutV from A.
After the challenge, DB.Joinc(·) and DB.Prover(·) are sim-
ulated by B as in the ﬁrst phase of the experiment. Hence,
DB.Veriﬁer can be simulated as follows:
Initialization phase B receives e from A. If there is no
0 ≤ d ≤ l s. t. Listd = (α, β, e), B simulates the oracle
as in the ﬁrst phase. Otherwise, B picks m $← {0, 1}n
and returns it.
Distance-bounding phase B picks cj ∈ {0, 1}, sends it
to A and waits for the response rj. He repeats this
protocol for all j in {0, . . . , n}.
Veriﬁcation phase Using Listd = (α, β, e), if for all j ∈
{0, . . . , n}, rj = αj when cj = 0 and rj = βj ⊕ mj
when cj = 1, B returns 1 to A. Otherwise, he simply
returns 0.
Finally, A returns b(cid:48) to B who returns it to the challenger.
The experiment is perfectly simulated for A, and in con-
sequence B wins his experiment with the same probability
that A wins his. Thus, AdvPrivA,TREADPub (λ) = AdvIND-CCA2
(λ),
contradicting the assumption on PKE.
B.3 Anonymity Property
B,PKE
Proof Proof of Theorem 6. Assume that there exists
a polynomial-time adversary A s. t. AdvAnonA,TREADAN O (λ) is
non-negligible. We show how to construct an adversary B
s. t. AdvAnonB,G-SIG(λ) is also non-negligible.
Initially, the challenger sends a key gpk and a revoked
list RL to B. Then, B generates a public/private key pair
pkv, skv for the veriﬁer using PKE.gen(1λ). Thus, B sends
(pkv, gpk, RL) to A and creates the empty list CU. Having
access to G-SIG-oracles from his challenger, B can simulate
the DB-oracles for A as follows:
DB.Joinh(·): on i, creates Pi with G.Joinh(·), and adds Pi
to UL.
DB.Joinc(·): on i, creates a corrupted Pi with G.Joinc(·),
adds Pi to UL and CU and returns sski.
DB.Revoke(·): on i, revokes Pi with G.Revoke(·), which up-
dates RL and returns it.
DB.Corrupt(·): on i, corrupts Pi with G.Corrupt(·) and gets
sski. B adds Pi to CU and returns sski.
DB.Prover(·): B simulates Pi for A as follows.
Initialization phase B picks α||β $← {0, 1}2n and uses
his oracle G.Sign(·,·) to get the corresponding sig-
(α||β). He computes e =
nature σp = G.sigsski
PKE.encpkv (α||β||σp) and returns it. He then gets
m.
Distance-bounding phase B uses α, β and m to cor-
rectly respond to the challenges ci sent by A.
Veriﬁcation phase B receives OutV from A.
DB.Veriﬁer: B simulates V for A as follows:
Initialization phase B receives e from A and retrieves
the message (α||β||σp) = PKE.decskv (e). If the ver-
iﬁcation G.vergpk(σp, α||β, RL) = 0 then B returns
⊥ and aborts this oracle simulation. Finally, he
picks m $← {0, 1}n and returns it.
Distance-bounding phase B picks cj ∈ {0, 1}, sends
it to A and waits the response rj. He repeats this
protocol for all j in {0, . . . , n}.
Veriﬁcation phase If, for all j in {0, . . . , n}, rj = αj
when cj = 0 and rj = βj ⊕ mj when cj = 1 then B
returns 1 to A, while otherwise he returns 0.
A sends (i0, i1) to B. If i0 or i1 ∈ CU, B aborts the experi-
ment. Otherwise, B sends (i0, i1) to the challenger. Then, B
returns ⊥ when he simulates Corrupt(·) and Revoke(·) on in-
puts i0 and i1 . Afterward, B simulates the challenge oracle
DB.Proverb for Pib as follows:
Initialization phase B picks α||β $← {0, 1}2·n, uses his or-
acle G.Signb(·,·) to get the signature σp = G.sigsski
(α||β),
and returns e = PKE.encpkv (α||β||σp). He then gets m.
Distance-bounding phase B uses α, β and m to correctly
respond to the challenges ci sent by A.
Veriﬁcation phase B receives OutV from A.
Finally, A returns b(cid:48) to B who returns it to the challenger.
The experiment is perfectly simulated for A, This im-
plies that B wins his experiment with the same probabil-
ity that A wins his experiment. Thus, AdvAnonB,G-SIG(λ) =
AdvAnonA,TREADAno (λ), contradicting the assumption that an ad-
versary should have a negligible advantage on G-SIG.
814