    00D33C3E B9 15 C0 D3 00       mov         ecx,offset _FA250FC7_源@cpp (0D3C015h)  
    00D33C43 E8 BB D5 FF FF       call        @__CheckForDebuggerJustMyCode@4 (0D31203h)  
         6:     MessageBox(NULL, "hello", "Func", 0);
    00D33C48 8B F4                mov         esi,esp  
    00D33C4A 6A 00                push        0  
    00D33C4C 68 30 7B D3 00       push        offset string "Func" (0D37B30h)  
    00D33C51 68 38 7B D3 00       push        offset string "hello" (0D37B38h)  
    00D33C56 6A 00                push        0  
    00D33C58 FF 15 98 B0 D3 00    call        dword ptr [__imp__MessageBoxA@16 (0D3B098h)]  
    00D33C5E 3B F4                cmp         esi,esp  
    00D33C60 E8 A8 D5 FF FF       call        __RTC_CheckEsp (0D3120Dh)  
         7: }
    00D33C65 5F                   pop         edi  
    00D33C66 5E                   pop         esi  
    00D33C67 5B                   pop         ebx  
    00D33C68 81 C4 C0 00 00 00    add         esp,0C0h  
    00D33C6E 3B EC                cmp         ebp,esp  
    00D33C70 E8 98 D5 FF FF       call        __RTC_CheckEsp (0D3120Dh)  
    00D33C75 8B E5                mov         esp,ebp  
    00D33C77 5D                   pop         ebp  
    00D33C78 C3                   ret  
    #这里函数起始地址为：00D33C20h，函数结束地址为：00D33C78h，俩地址相减00D33C78h-00D33C20h=58h即为这个函数代码块的大小
在加解密函数的下面继续声明一个函数，计算两个函数的起始位置之差，即可得到加解密函数的代码块大小。
> 不过 这种方法我在自己测试时并没有成功实现！两个相邻函数，地址却并没有 **紧密** 相邻！
此外，这种SMC加密方式还有一个问题：
> 但是很多时候，函数名存放的地址，跳过去是一个jmp指令，再跳转一次才能到达函数位置。
识别函数名地址跳过去是否是jmp表，因为jmp对应的字节码是E9，假设指令为`jmp 0xaabbccdd`：
地址 | 字节码 | 操作数  
---|---|---  
0x11223344 | E9 | AABBCCDD  
所以E9的操作数AABBCCDD的计算方法为
> 因为字节码`E9 AABBCCDD`整条指令的大小是5个字节
>
> AABBCCDD = 0xaabbccdd – （0x11223344+5）
>
> 即：E9操作数 = 真实跳转地址 – E9下一条指令的大小
所以我们可以通过jmp的对应字节码E9的操作数，计算出真实跳转的函数地址。
        char *pFuncAddr = (char *)Func;//函数名，强转类型
        if(*((unsigned char*)pFuncAddr) == 0xE9)//判断是否是跳转指令
        {
            pFuncAddr++; //跳过0xE9指令
            i =* (int *)pFuncAddr;//这个jmp指令的操作数，也就是跳转的距离，四个字节的E9操作数
            pFuncAddr = i + (pFuncAddr + 4); //修正到正确的位置。多加4是因为此时pFuncAddr已经自增1了，且此操作数也是4个字节。
            //此时的pFuncAddr即使正确的函数地址了！
        }
> ps：我在测试的时候，一直没遇到函数名存放的地址跳过去是jmp指令，这种问题0.0！！！不过还是记录了这种问题的解决方法！
>
> 注意代码段节区属性，是否可写？
###  ⑤.巧妙：扫描特征码->代码块
这种方法比较巧妙：
> 分别在函数开始和函数结尾构造对应特征码，通过扫描对应特征码，确定SMC自修改代码的开始和结束位置。
解释：利用花指令的原理，通过汇编指令`_emit`在SMC代码块的开始位置嵌入自己定义的 **开始特征码** ，同时在SMC代码块的结束位置嵌入自己定义的
**结束特征码** ，解密函数只需扫描对应的大致内存中 **开始特征码** 确定SMC自修改代码的开始位置，扫描到 **结束特征码**
确定SMC自修改代码的结束位置！
    //利用花指令原理实现特征码定位SMC加密代码块
    void func()
    {
        //添加“开始特征码”:"hElLowoRLd"
        asm
        {
            jz label_1;
            jnz label_1;
            _emit 'h';
            _emit 'E';
            _emit 'l';
            _emit 'L';
            _emit 'o';
            _emit 'w';
            _emit 'o';
            _emit 'R';
            _emit 'L';
            _emit 'd';
            lable_1:
        }
        //*************
        //要加密的代码
        //*************
        //添加“结束特征码”:"dLRowoLlEh"（直接将开“开始特征码”反过来）
            asm
        {
            jz label_2;
            jnz label_2;
            _emit 'd';
            _emit 'L';  
            _emit 'R';
            _emit 'o';    
            _emit 'w';
            _emit 'o';    
            _emit 'L';    
            _emit 'l';
            _emit 'E';
            _emit 'h';       
            lable_2:
        }
    }
中间的二进制数据就是我们要SMC加密的函数代码块！
然后我们只需扫描模块（或代码段节区）中的特征码，获得SMC加密的代码块地址和大小。
搜索算法我这里就不演示了。这种SMC加密方式比较巧妙，同时又较易理解，容易实现，很不错！
## 3.SMC的调整
上面的讲解的都是对函数整体进行SMC解密，破解者一进去反编译，整段代码都不可反编译，难免怀疑函数代码块被SMC加密了。为了隐藏自己，可以对较少的指令进行SMC加密。
或者，我们只对一两个字节码进行加密。
这两种方式，第①种不能静态反编译，第②种能够静态反编译。
简述图中第②种方式：
> 这里+运算对应的字节码是0x03
>
> -运算对应的字节码是0x2b
>
> 0x03 ^ 0x2B = 0x28
我们用+运算字节码0x03 ^ 0x28 = 0x2b，得到-运算字节码
用-运算字节码0x2b ^ 0x28 = 0x03，得到+运算字节码
## 4.SMC原理利用：交替加密
通过 `3.SMC的调整`所述的第②钟方法，可以延伸一种实现 **交替加密** 的方法。
**即将两个相同函数类型但不同加密方式的函数进行异或，得到一串数据，使用这串数据对加密函数的代码块进行异或，即可得到另一个加密函数。**
> **可以在调用加密函数时，任意切换两种加密方法** 。
>
> 当然，加密的方式肯定不止异或，这里只是简单的演示原理，只要能实现切换，任意加密都可以。
利用异或切换加密的过程可以直接主线程完成，也可以利用子线程完成。
这种方式的好处就是： **在一个函数大小的内存里，执行两套代码。**
当然拿到程序能够反编译，不过只能反编译出一套加密加密函数的代码，这样破解者如果只是看静态加密，很容易就被误导。
## 4.SMC重点：避免加密到动态地址及解决方法
动态地址多指头文件提供的函数的地址，此外全局变量的地址，在实现SMC时，都应该尽量避免。
这部分要了解PE结构中的重定位知识：[重定位表的原理](https://blog.csdn.net/qq_35289660/article/details/107107887)
###  地址问题
由于一个exe在执行代码前，是先进行修正重定位，再执行我们的代码。
如果我们把代码给通过SMC给加密了，exe启动时，先根据重定位表把内存中的存储的地址修正，然后再执行我们的代码，到SMC解密代码时，把刚修正的正确的地址也连着解密，结果才修正的地址又错误了。所以就会导致地址错误。
###  解决方法
对于这样的问题，一般的解决方法是尽可能的避免使用此类动态地址。
但是如果遇到很重要的变量涉及到动态地址，又一定要使用，有一个很不错方法，就是将该变量在放在SMC加密函数外部，程序运行时该变量就能正确赋值，
**通过堆栈传入该变量** ，SMC加密的代码调用该变量是通过`[ebp-0x4]`类似这样的方式取值。或者直接通过参数传入动态地址。
这样可以避免这个问题，建议自己实现SMC加密时遇到此类问题，可以试试这种方法。
## 5.SMC易踩雷点
1.注意SMC加解密代码所属的节区是否有可写权限！！！！
2.注意pe结构中的数据，尤其是目录项中的各种表结构。
3.涉及到要重定位的动态地址被加密。
## 6.闲话
感觉SMC加密技术比较考验使用者对内存和地址的理解，挺不错的，可以保护代码加大反调试的难度，也可以用于恶意代码的变形。
## 7.最后
参考文章：[用C/C++实现SMC动态代码加密技术](https://blog.csdn.net/orbit/article/details/1497457#commentBox)