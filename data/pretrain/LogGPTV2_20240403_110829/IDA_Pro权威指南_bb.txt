如前所述，程序的入口点是即将执行的第一条指令的地址。因此，许多熟练的 C 程序员错误地认为这就是 main
 函数的地址，但事实并非如此。程序的文件类型，而不是创建程序所使用的语言，决定了向这个程序提交命令行参数的方式。为了使加载器加载命令行参数的方式与程序预期接收参数的方式（例如，通过向 main
 提交参数）保持一致，程序必须在将控制权转交给 main
 之前执行一段初始化代码。IDA 将这段初始化代码作为程序的入口点，并将其标记为_start
 。
这段初始化代码还负责必须在 main
 运行之前完成的初始化任务。在 C++ 程序中，这段代码负责确保在执行 main
 之前调用全局声明对象的构造函数。同样，为了在程序真正终止前调用所有全局对象的析构函数，必须插入在 main
 之后执行的清理代码（cleanup code）。
如果IDA 能够识别用于创建某个二进制文件的编译器，那么，它会加载对应编译器库的签名文件，并将其应用于该文件的剩余部分。IDA 自带的签名大多与专用编译器有关，如 Microsoft Visual C++或Borland Delphi。这是因为，这些编译器自带的二进制库的数量有限，而与开源编译器（如 GNU gcc ）关联的库却拥有大量的二进制变体，与这类编译器自带的操作系统一样种类繁多。例如，每个版本的 FreeBSD 都自带有一个特殊的 C 标准库。为了获得最佳模式匹配效果，你需要为每一种不同版本的库生成签名文件。想象一下，收集每一个版本的 Linux自带的libc.a1
 的每一个变体，其难度会有多大！这简直是一个无法完成的任务。从某种程度上说，这些差异归结为库源代码的变化（因而导致不同的编译代码）。但是，巨大的差异也是因为使用了不同的编译选项，如优化设置，以及在创建库时使用了不同的编译器版本。结果，IDA 自带的开源编译器库签名文件非常少。不过，如下所述，Hex-Rays 提供了各种工具，用于由静态库生成你自己的签名文件。
1. libc.a 是Unix系统上的静态链接二进制文件所使用的C 标准库。
那么，在什么情况下，你需要手动对数据库应用签名呢？有时候，IDA 能够正确识别创建二进制文件所使用的编译器，但它并没有相关编译器库的签名。在这种情况下，你要么完全不用签名，要么需要获得二进制文件所使用的静态库的副本，并生成你自己的签名。其他情况下，IDA可能根本无法识别一个编译器，因而也无法确定该对数据库应用哪些签名。在分析模糊代码时，你经常会遇到这种情况：为防止编译器识别，混淆代码中的启动例程（startup routine ）经过了非常复杂的改编。这时，你必须首先对二进制文件进行大量的“去模糊”处理，然后才有可能匹配库签名。我们将在第 21 章中讨论处理模糊代码的技巧。
无论出于什么原因，如果希望手动对一个数据库应用签名，可以通过File ▶Load File ▶FLIRT Signature File 打开如图 12-1 所示的选择签名对话框。
图12-1 选择 FLIRT 签名
File 一栏显示IDA 的/sig目录中每个.sig 文件的名称。需要注意的是，你不能为.sig文件指定另外的存储位置。如果你生成了自己的签名，它们也需要和其他.sig 文件一起，存储在/sig目录中。Library name一栏显示嵌入到每个文件中的库名称注释。记住，这些注释的描述性完全取决于签名创建者（可能就是你自己）。
选择一个库模块，IDA 将加载对应的.sig 文件中包含的签名，并将其与数据库中的每一个函数进行比较。你一次只能应用一组签名，因此，如果你希望对一个数据库应用几组不同的签名，需要重复上述过程。如果发现一个函数与签名相匹配，IDA 会将这个函数标记为库函数，并根据与其匹配的签名自动对它进行重命名。
警告
  只有使用 IDA 哑名的函数才能被自动重命名。换言之，如果你已经对一个函数进行了重命名，而后这个函数与一个签名相匹配，那么，这时IDA 不会再对这个函数进行重命名。因此，在分析过程中，你应该尽可能早地应用签名。  
如前所述，静态链接二进制文件模糊了应用程序代码与库代码之间的区别。如果你足够幸运，拥有一个没有去除符号的静态链接二进制文件，那么，你至少拥有有用的函数名（和可信赖的程序员创建的函数名一样有用）来帮助你对代码进行分类。但是，如果二进制文件已经被去除符号，那么，你拥有的仅仅是数百个使用 IDA 生成的名称的函数，至于这些函数的用途，它们的名称无法提供任何信息。在这两种情况下，只要拥有相关签名，IDA 仍然能够识别出库函数（去除符号的二进制文件中的函数名称并不能为 IDA 提供足够的信息，使它准确判定一个函数是否为库函数）。图12-2 是一个静态链接二进制文件的“概况导航栏”。
图12-2 应用签名之前的静态链接二进制文件
在这个窗口中，没有函数被确定为库函数，因此，你需要深入分析代码。在应用一组适当的签名后，“概况导航栏”如图12-3 所示。
图12-3 应用签名之后的静态链接二进制文件
如你所见，“概况导航栏”证实了应用一组特殊签名所产生的效果。由于多数函数都找到与之匹配的签名，IDA 将大部分的代码标记为库代码，并对它们进行了相应的重命名。在图12-3所示的例子中，特定于应用程序的代码很可能集中在导航栏窗口的最左边。
在应用签名时，有两个值得注意的地方。第一，即使是对一个尚未去除符号的二进制文件，签名仍然有用。这时，你更多的是使用签名帮助 IDA 识别库函数，而不是对它们进行重命名。其次，静态链接二进制文件可能由几个单独的库组成，你需要对其应用几组签名才能完全识别所有的库函数。每应用一个签名，“概况导航栏”都会发生变化，以反映你发现的库代码。图12-4显示的就是这样一个例子。在这个图中，你看到的是一个使用 C 标准库和OpenSSL2
 加密库静态链接的二进制文件。
2. 参见http://www.openssl.org/
 。
图12-4 应用前几个签名后的静态二进制文件
具体来说，我们看到，在对二进制文件应用适当的 OpenSSL 签名后，IDA 将一个窄小的代码带（地址范围左侧的浅色代码带）标记为了库代码。通常，要创建静态链接二进制文件，首先应插入应用程序代码，其次附加所需的库，最后得到可执行文件。根据图12-4 ，我们可以得出结论：OpenSSL 库的右侧很可能是其他的库代码，而应用程序代码则位于 OpenSSL 库左侧的一条非常窄小的代码带中。如果我们继续对图 12-4 中的二进制文件应用签名，最终的“概况导航栏”将如图12-5 所示。
图12-5 应用几组签名后的静态二进制文件
在这个例子中，我们应用了 libc 、libcrypto 、libkrb5 、libresolv 及其他库的签名。有时候，我们根据二进制文件中的字符串来选择签名。其他情况下，我们选择与二进制文件中已经确定的其他库关系密切的签名。最终，导航窗口会在导航带的中间显示一个深色的代码带，在导航带的最左边缘显示一个更小的深色代码带。要确定二进制文件中剩下的非库代码的性质，你需要进行更加深入的分析。在这个例子中，我们知道，中间的深色代码带是一种尚未识别的库，而左侧的深色代码带则为应用程序代码。
12.3 创建FLIRT 签名文件
如前所述，IDA 不可能自带现有的每一个静态库的签名文件。为了向IDA 用户提供创建他们自己的签名所需的工具和信息，Hex-Rays 开发了 FLAIR （Fast Library Acquisition for Identification and Recognition ，快速获取库的识别和鉴定）工具集，你可以从 IDA 发行版光盘上获得 FLAIR工具，被授权用户也可以从 Hex-Rays 网站1
 上下载该工具。与IDA 的另外几个附加件一样，FLAIR工具通过一个 Zip文件发布。Hex-Rays 不一定会为每一个版本的 IDA 发布新版的 FLAIR 工具，因此，只需使用最新版本的 FLAIR 工具，只要它不高于你的 IDA 版本即可。
1. 该工具的当前版本为flair61.zip，下载地址为http://www.hex-rays.com/idapro/ida/flair61.zip
 。下载该文件时，你需要输入Hex-Rays 提供的用户名和密码。
安装FLAIR 实用工具的过程非常简单，只需解压相关的 Zip 文件即可。尽管如此，我们仍然强烈建议你创建一个专用的 flair 目录作为目标目录，因为Zip文件可能并不包含一个顶级目录。解压FLAIR 文件后，你会发现几个文本文件，它们是 FLAIR 工具的文档资料。其中特别有用的文件如下所示。
readme.txt
 。这个文件总体概述签名创建过程。
plb.txt
 。这个文件描述静态库解析器 plb.exe 的用法。库解析器将在 12.3.3 节中详细讨论。
pat.txt
 。这个文件详细说明了模式文件的格式，它是签名创建过程的第一步。我们还将在12.3.3 节介绍模式文件。
sigmake.txt
 。这个文件描述 sigmake.exe 文件的用法，该文件用于从模式文件生成.sig 文件。请参阅 12.3.4 节了解详情。
其他顶级目录包括 bin 目录，其中包括 FLAIR 工具的所有可执行文件和 startup 目录，后者包含与各种编译器及其相关的输出文件类型（PE、ELF 等）有关的常见启动顺序的模式文件。对于6.1之前的版本，FLAIR 工具只能在 Windows 命令提示符下运行，但其生成的签名文件可以用在所有的 IDA 版本中（Windows、Linux和OS X）。
12.3.1 创建签名概述
创建签名文件的基本过程听起来并不复杂，可以归结为 4 个看似简单的步骤。
获得一个你希望为其创建签名文件的静态库。
利用其中一个 FLAIR 解析器为该库创建一个模式文件。
运行sigmake.exe 来处理生成的模式文件，并生成一个签名文件。
将新的签名文件复制到/sig目录中，安装这个文件。
遗憾的是，实际上只有最后一个步骤较为简单。在下面几节中，我们将详细讨论前3 个步骤。
12.3.2 识别和获取静态库
生成签名的第一个步骤是确定一个你希望为其生成签名的静态库。由于各种原因，完成这个任务可能需要克服一些挑战。第一个挑战是确定你到底需要哪一个库。如果你足够幸运，你所分析的二进制文件并没有去除符号，那么，你的反汇编代码清单将显示真实的函数名称。这时，你只需要使用因特网搜索，就可以获得一些线索。
与未去除符号的二进制文件相比，已去除符号的二进制文件并不能为我们提供太大的帮助。缺乏函数名称的帮助时，使用 strings
 进行搜索也可以得到足够特殊的字符串，以帮助你识别库，如下面的例子所示，从中你一眼就可以发现相关的库：
OpenSSL 1.0.0b-fips 16 Nov 2010
通常，版权声明和错误字符串已经足够特殊，当然，你同样可以使用因特网来缩小搜索范围。如果你选择从命令行中运行 strings
 ，一定要记得使用-a
 选项，迫使 strings
 扫描整个二进制文件。否则，你可能会遗漏一些有用的字符串数据。
对开源库来说，你很可能会找到它们的源代码。不过，虽然源代码可以帮助你理解二进制文件的行为，但你不能使用它来为你生成签名。不过，你可以使用源代码创建你自己的静态库，然后使用这个库来生成签名。然而，创建过程中出现的变化很有可能会在生成的库与你分析的库之间造成相当大的差异，因此，你生成的签名也不十分准确。
当然，最好的办法还是确定你所分析的二进制文件的真实来源，即具体的操作系统、操作系统版本和发行版本（如果适用）。根据这些信息，创建签名的最佳方法是从一个配置完全相同的系统中复制相关的库。自然，这会导致下一个问题：对任意一个二进制文件来说，如何确定它到底是在什么系统上创建的呢？应对这个问题的第一个步骤是使用 file
 实用工具获得一些与该二进制文件有关的基本信息。在第 2 章中，我们看到了 file
 工具的一些样本输出。有时候，这些输出足以帮助你确定可能的操作系统。下面的例子就是 file
 文件的一个非常特殊的输出：
$  file sample_file_1
sample_file_1: ELF 32-bit LSB executable, Intel 80386, version 1 (FreeBSD),
statically linked, for FreeBSD 8.0 (800107), stripped
从这个例子中，我们可以迅速确定该文件使用的是 FreeBSD 8.0 系统，并追踪到 libc.a 库。下面的例子更加复杂一些：
$  file sample_file_2
sample_file_2: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux),
statically linked, for GNU/Linux 2.6.32, stripped
我们似乎将文件的来源缩小到了 Linux系统，但是，由于 Linux系统存在大量不同的版本，这对我们并没有太大的帮助。运行 strings
 后，我们发现以下信息：
GCC: (GNU) 4.5.1 20100924 (Red Hat 4.5.1-4)
这时，搜索的范围进一步缩小到 gcc 4.5.1 版本自带的Red Hat发行版（或其派生版本）。在使用gcc 编译的二进制文件中，这种 GCC标记并不少见。好在去除符号的过程中，它们并没有被删除，仍然可以被 strings
 搜索到。
需要注意的是，file
 实用工具并不是用于识别文件的决定性因素。下面的输出证实了一种简单的情况，在这种情况下，file
 似乎知道所分析文件的类型，但它的输出并无特殊之处。
$ file sample_file_3
sample_file_3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV),  
dynamically linked (uses shared libs), stripped  
这个例子取自一款 Solaris 10 x86 系统。这里，我们仍然可以使用strings
 实用工具来确定该系统。
12.3.3 创建模式文件
现在，你可能希望为一个或几个库创建签名。下一步是为每个库创建一个模式文件。模式文件是利用合适的 FLAIR 解析器实用工具创建的。和可执行文件一样，库文件也是基于各种文件格式规范而创建的。FLAIR 为解析器提供几种通用的库文件格式。如 FLAIR 的readme.txt 所述，你可以在 FLAIR 的bin目录中找到以下解析器。
plb.exe/plb
 。OMF库的解析器（Borland编译器常用）。
pcf.exe/pcf
 。COFF 库的解析器（微软编译器常用）。
pelf.exe/pelf
 。ELF 库的解析器（许多 Unix 系统常用）。
ppsx.exe/ppsx
 。Sony PlayStation PSX 库的解析器。
ptmobj.exe/ptmobj
 。TriMedia 库的解析器。
pomf166.exe/pomf166
 。Kiel OMF 166 对象文件的解析器。 要为某个库创建一个模式文件，需要指定与库的格式对应的解析器、你希望解析的库的名称以及生成的模式文件的名称。对于FreeBSD 8.0 系统中的 libc.a库，你可以使用以下代码创建模式文件：
$  ./pelf libc.a libc_FreeBSD80.pat
libc.a: skipped 1, total 1089
这里，解析器指出被解析的文件（libc.a）、被忽略的函数2
 的数量（1）及生成的签名模式的数量（1089 ）。每个解析器接受的命令行选项都略有不同，这些差异全部记录在该解析器的使用声明中。若执行解析器时不使用参数，这个解析器所接受的所有命令行选项将显示出来。plb.txt 文件提供了有关 plb解析器所接受的选项的详细信息。这个文件中包含大量基本信息，因为它还描述了其他解析器接受的许多选项。多数情况下，仅仅指出被解析的库及将要生成的模式文件的名称就够了。
2. plb 和pcf解析器可能会根据命令行选项忽略一些函数。
模式文件是一个文本文件，其中包含提取出的、表示被解析库中的函数的模式（每行显示一种模式）。前面创建的模式文件中的几行模式如下所示：
57568B7C240C8B742410FC8B4C2414C1E902F3A775108B4C241483E103F3A675 1E A55D 003E :0000
 _memcmp  
0FBC442404740340C39031C0C3...................................... 00 0000 000D :0000
 _ffs
57538B7C240C8B4C2410FC31C083F90F7E1B89FAF7DA83E20389CB29D389D1F3 12 9E31 0032 :0000
 _bzero
FLAIR 的pat.txt 文件说明各个模式的格式。简单地说，模式的第一部分列举了它所代表的函数的初始字节序列，最长为 32 个字节。一些字节因为重定位的入口而有所不同，这些字节将得到“补偿”，每个字节以两点显示。如果一个函数短于32个字节（例如前面代码中的_ffs
 函数），用点将模式填充到 643
 个字符。除 32 个初始字节外，模式中记录的其他信息专用于提高签名匹配过程的准确性。每个模式行中的其他信息包括由函数的某个部分计算得出的CRC164
 值、函数的字节长度以及函数引用的符号名称列表。一般来说，引用许多其他符号的函数越长，它生成的模式行就越复杂。在前面生成的 libc_FreeBSD80.pat 文件中，一些模式行的长度超过了20 000 个字符。
3. 每个字节需要两个字符。要显示32个字节的内容，需要64 个十六进制字符。
4. 这是一个16位循环冗余校验值。生成模式时使用的CRC16实现包含在FLAIR 工具光盘的crc16.cpp 文件中。
几名第三方程序员开发出了一些实用工具，可用于从现有的 IDA 数据库生成模式。其中一个实用工具为 IDB_2_PAT5
 ，这个 IDA 插件由J. C. Roberts 编写，它能够为现有数据库中的一个或多个函数生成模式。如果你想在其他数据库中遇到与现有数据库中的函数的代码类似的代码，但却无法访问用于创建被分析的二进制文件的原始库文件，就可以用到这些实用工具。
5. 参见http://www.openrce.org/downloads/details/26/IDB_2_PAT
 。
12.3.4 创建签名文件
为某个库创建模式文件后，创建签名过程的下一个步骤是生成一个适合IDA 使用的.sig 文件。IDA 签名文件的格式与模式文件的格式截然不同。签名文件采用一种专用二进制格式，最大限度地减少呈现模式文件中的全部信息所需的空间数量，并且努力根据具体的数据库内容实现高效的签名匹配。Hex-Rays 的网站6
 宏观介绍了签名文件的结构。
6. 参见http://www.hex-rays.com/idapro/flirt.htm
 。
FLAIR 的sigmake 实用工具用于从模式文件创建签名文件。由于模式生成与签名生成被划分成两个不同的阶段，因此，签名生成过程完全独立于模式生成过程，这使得我们可以使用第三方的模式生成工具。使用 sigmake 解析一个.pat 文件并创建一个.sig 文件是生成签名的最简单方法，如下所示：
$ ./sigmake libssl.pat libssl.sig
如果一切正常，你将得到一个.sig 文件，并可将它保存到/sig目录中。但是，你很少能够顺序完成这个过程。
说明
  sigmake的文档文件sigmake.txt 建议在给签名文件取名时，应遵循 MS-DOS 8.3名称长度约定。这并不是一个强制性的要求。如果使用的文件名较长，则“选择签名”对话框仅显示文件名的前 8 个字符。
通常，因为在生成签名的过程中，你必须处理冲突
 ，因此，这个过程是一个不断反复的过程。只要有两个函数的模式相同，就会发生冲突。如果不能解决冲突，在应用签名的过程中，我们就无法确定函数到底与哪一个签名相匹配。因此，sigmake 必须能够将每一个生成的签名解析成一个函数名称。否则，如果一个或几个函数的模式完全相同，sigmake
 生成的不是.sig
 文件，而是一个排斥文件
 （.exc ）。使用 sigmake