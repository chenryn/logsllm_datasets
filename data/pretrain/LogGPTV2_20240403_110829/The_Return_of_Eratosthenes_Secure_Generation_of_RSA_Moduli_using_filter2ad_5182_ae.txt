from all parties, First, compute
ğ‘¦ =ğ›¾ (ğ‘âˆ’ğ‘âˆ’ğ‘+1)/4 mod ğ‘ and send ğ‘¦ to S. Then, receive ğ‘¦â€² from
S and send ğ‘¦â€² to all parties. Finally, if ğ‘¦â€² â‰  Â±1 then send Abort
to all parties.
(4) On receiving Consistency Check from all parties, if ğ‘¦â€² received
during the Jacobi command was not equal to ğ‘¦, then send Abort
to all parties.
compute
from all
ğ‘ = gcd(ğ‘ , (ğ‘ + ğ‘ âˆ’ 1)). If ğ‘ = 1, send (ğ‘, Biprime) to all
parties, otherwise send (ğ‘,Non Biprime).
receiving GCD Test
parties,
(5) On
Figure 11: RSA Modulus Generation Functionality
multiplication is done over Z/(ğ‘€sampleZ), parties set their local
share as ğ‘( ğ‘—) = ğ‘â€²( ğ‘—) +ğ‘Ÿ ( ğ‘—) Â· ğ‘€sample and use this in the CRT Input
procedure, over â„“ğ‘ CRT components, and thus â„“ğ‘ MPC engines.
Once two candidate primes ğ‘ and ğ‘ have been sampled in a secret
shared fashion as described above, the Combine phase begins. First,
the parties sum the contributions of each party into the additive
sharing, over â„“ğ‘CRT components. Then, the candidate biprime is
computed, using an actively secure multiplication over the CRT
representation of the sharings of ğ‘ and ğ‘. Lastly, the parties open the
resulting candidate biprime ğ‘ , and each party ğ‘ƒ ğ‘— locally performs
the CRT reconstruction and obtains the biprime ğ‘ in the standard
form. Each party checks that the biprime respects the bounds in
which it should lie, and that it is not coprime to the upper bound
of the sampling range.
The parties then begin the biprimality testing with the Jacobi test,
which needs to be repeated 128 times. The core of the Jacobi test we
design offers passive security; to achieve active security, should the
Jacobi test pass, we proceed with the Consistency Check phase. This
step ensures that parties cannot go undetected, if they use inconsis-
tentsharingsintheJacobitest.Torealizethis,firstweneedtoincrease
our computing space to avoid potential overflows. We do that by
means of the LevelUp command, which allows us to receive the same
sharings in a CRT representation with additional CRT components
(to accommodate the computations). Concretely, we extend from â„“ğ‘
components of the combine step, to â„“Jac components, which suffice
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea602for the correctness of the consistency check of the Jacobi. Then, us-
ing the Rand2k command, we receive bounded shared randomness
in the CRT form with â„“Jac components. Using this randomness, we
multiplicatively mask (guaranteed without overflow) the exponent
of the Jacobi test, where the partiesâ€™ shares have been contributed.
This latter product is then converted from a CRT sharing with â„“Jac
components to an integer sharing by calling the ConvInt command.
The integer sharing is used to exponentiate the public value ğ›¾ used
in the Jacobi test, and it is then broadcasted. The randomness used
in the masking operation is revealed, so that the parties can perform
the final exponentiation of the Jacobi value computed to the power
of the randomness in the clear. From the broadcasted values, the
parties can also reconstruct again the masked version of the Jacobi
test exponentiation. If the two latter values do not match, then some
parties have input inconsistent shares, and the protocol aborts.
The last phase of our protocol is the GCD test, aiming at detecting
(and discarding) any false positive biprimes that passed the Jacobi
the secret(cid:74)ğ‘+ğ‘âˆ’1(cid:75), and if their GCD equals 1, the test passes. Let
test. The GCD test is performed between the public biprime ğ‘ , and
ğ‘„gcd > ğ‘‰ Â· ğ‘ , where ğ‘‰ = 23ğœ†+4ğœ. The goal is to output the product
$â† [ğ‘], and then perform
ğ‘ Â· (ğ‘ +ğ‘ âˆ’ 1) + ğ‘£ Â· ğ‘ mod ğ‘„gcd, where ğ‘
the gcd computation between ğ‘ and ğ‘Â·(ğ‘+ğ‘âˆ’1)+ğ‘£ Â· ğ‘ on public
values. In our case ğ‘£ needs to statistically mask the product between
ğ‘, which has 2(ğœ†+ğœ) bits length, and ğ‘+ğ‘âˆ’1, which has ğœ†+ğœ bits
length. Hence, log2ğ‘£ =3(ğœ†+ğœ)+ğœ. Next, ğ‘€â„“gcd
is computed, so that
ğ‘£Â·ğ‘ fits ğ‘„gcd, which makes ğ‘€â„“gcd
On a step by step basis, for the GCD test we use again the LevelUp
command to extend the number of CRT components in our sharings
of ğ‘ and ğ‘. For the masking, similarly to the Jacobi test, we sample
bounded randomness in CRT form with â„“gcd components, using
again the Rand2k command. Before we open and reconstruct the
final value Ë†ğ‘§, the gcd of which needs to be checked against the public
biprime ğ‘ , we also perform an additive masking with a bounded
random value ğ‘£. This ensures that no information about the sum
of ğ‘ and ğ‘, involved in the multiplicatively masking, can be factored
out upon opening. Upon opening and reconstuction of the masked
value, the final GCD test is performed, and if the open value is not
coprime to ğ‘ the protocol outputs abort and restarts.
to be 5ğœ†+6ğœ bits long.
Theorem 4.1. The execution of the protocol Î RSAGen UC-securely
realizes the functionality FRSAGen, in the (FABBWithErrors, FMPC,
FAgreeRandom, FBroadcast)-hybrid model with statistical security
against a static, active adversary that corrupts up to ğ‘›âˆ’1 parties.
We refer the reader to Appendix A for the proof of Theorem 4.1.
5 PARAMETERS AND EFFICIENCY ANALYSIS
We generate biprimes of various bit-lengths, and hence security
levels; namely ğœ† ={1024,1536,2048} as in the work of Chen et al. [7].
In the cases where a statistical security parameter ğœ needs to be
considered, such as in the Sampling Phase, Jacobi test, masking and
underlying MPC engines, we make sure to set ğœ =80 to have a fair
comparison with the analysis of Chen et al. [7], since they also used
ğœ =80, when measuring their concrete costs.
Given that our protocol requires several types of MPC engines,
e.g., the ABBWithErrors, or the MPC-CRT, we use the MP-SPDZ
framework [26] to get concrete communication costs for different
adversary structures. In the case of dishonest majority, we instanti-
ate ABBWithErrors using the semi-honest version of the MASCOT
protocol [27], whereas for the malicious case, which we need for
building the MPC-CRT, we use LowGear [28], with TopGear [3] as
the underlying ZK proof. For the 16 parties case, we use the HighGear
protocol with the TopGear ZK-proof, which is also implemented in
MP-SPDZ. The reason for choosing HighGear over LowGear is that
for HighGear communication scales better in the number of parties.
We also give concrete costs for RSA-Sieve in the semi-honest,
dishonest majority model. The only difference with the malicious
case is that MPC-CRT can be instantiated with a cheaper protocol
and no zero-knowledge proofs. For this variant, we use the classical
SPDZ triple generation with no ZK proofs [6, 11], for which we
get concrete costs by running the hemi protocol in MP-SPDZ [26].
The results are given in Table 2 for the two party case, while in
Table 3 we have results for the 16 party case, where we also compare
them with the the protocol of Chen et al. [7]. As it can be inferred
from Table 2, for two parties, our protocol is a factor of 3.3-3.9 more
communication-efficient than the state-of-the-art [7] in the semi-
honest case, and by a factor of 32-37 in the malicious case (ranging
for different bit-lengths of the birprimes generated). For the 16 party
case, the protocol of Chen et al. [7] outperforms ours by a factor of ap-
proximately 2 in the semi-honest case. Then again, for the malicious
case and for 16 parties, our protocol improves the communication
cost over the state-of-the-art [7] by approximately 14-30 times.
In the following, we give an example of how we compute the cost
using ğœ† =1024, in the dishonest majority case with malicious security.
The number of primes used in the distributed sieving is fixed to 130,
as in the work of Chen et al. [7], to achieve the same number of
Sample iterations. Note that the product of the first 130 primes is
1019 bits long. Frankel et al. [16] select ğ‘Ÿ ( ğ‘—) in the sampling phase at
random from [0,2ğ‘›/ğ‘€sample] where ğ‘› was the desired bit-length of ğ‘.
For ğœ† being the bit-length of the candidate primes, we need to
take their product in a space of double the size to avoid wrap around.
Hence, ğ‘€â„“c
, the product of primes in which the biprimes live, needs
to be of length at least 2ğœ†+2ğœ bits, which results in â„“c =18 (i.e., we
need 18 CRT components of 128 bits each). Similarly, we compute
â„“Jac =21 and â„“gcd =46.
(1) Sampling phase. The cost per semi-honest multiplication
per party with ABBWithErrors is (ğ‘›âˆ’1)(128Â·ğ‘˜+ğ‘˜2), where
ğ‘› is the number of parties and ğ‘˜ is the field size [27]. Since
the cost is quadratic in the field size, our ABBWithErrors will
work over all the small primes composing ğ‘€sample.
This brings the communication cost per triple at 17.027
kilobits with a total communication including the Beaver
openings. The Input calls to ABBWithErrors in Step 2
amount to 0.264kbits. This makes steps 2 and 3 having a cost
of 17.291 kbits.
The remaining cost here comes from the Input calls to
FMPC-CRT. This is instantiated using LowGear with TopGear
as ZK proof, where the input tuple cost is 1.35 kbits for a
128-bit prime. This makes Step 7 in the Sampling phase
amount to 48.67 kbits. One iteration of this phase has a total
cost of 65.97 kbits.
(2) Combine. The cost per multiplication triple using FMPC-CRT
amounts to 12.862 kbits per party. This brings the cost of one
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea603Sampling phase. All the steps below are done in parallel for ğ‘ and ğ‘.
Î RSAGen
Combine
(4) If ğ‘¦ â‰ Â±1 Abort.
Consistency Check
shared in ğ‘€â„“Jac
.
GCD test
ğ‘ ) =1.
Jacobi test This is executed ğœ times (Grassi et al. fashion but carefully so that adding shares in the exponents is done over the integers).
ğ‘¦( ğ‘—) =ğ›¾ (âˆ’ğ‘( ğ‘—)âˆ’ğ‘( ğ‘—) )/4 mod ğ‘ and calls FBroadcast(ğ‘¦( ğ‘—)).
ğ‘—=1ğ‘¦( ğ‘—) .
(1) Each party ğ‘ƒ ğ‘— samples a multiplicative share Ë†ğ‘( ğ‘—) , such that gcd(ğ‘€sample, Ë†ğ‘( ğ‘—)) =1.
(2) Each party ğ‘ƒ ğ‘— calls FABBWithErrors.Input( Ë†ğ‘( ğ‘—)).
(3) The parties call FABBWithErrors.Mult(ğ‘â€²â€², Ë†ğ‘(1) ,..., Ë†ğ‘(ğ‘›)).
(4) Parties call FABBWithErrors.Share(ğ‘â€²), such that ğ‘ƒ ğ‘— receives the residues of ğ‘â€²â€²( ğ‘—) for all primes in ğ‘€sample.
(5) Parties reconstruct ğ‘â€²( ğ‘—) =CRTRec([ğ‘â€²( ğ‘—) ,3Â·ğ›¿ ğ‘—,0],[ğ‘€sample,4]) where ğ›¿ ğ‘—,0 is the Kronecker delta.
(6) Each party ğ‘ƒ ğ‘— samples ğ‘Ÿ ( ğ‘—) , and computes ğ‘( ğ‘—) =ğ‘â€²( ğ‘—) +ğ‘Ÿ ( ğ‘—) Â·4Â·ğ‘€sample, such that ğ‘( ğ‘—) âˆˆ [2ğœ†,2ğœ†+ğœ ], for ğœ a statistical security parameter.
(7) Each party ğ‘ƒ ğ‘— calls FMPC-CRT.Input(ğ‘( ğ‘—) ,â„“c).
(1) Parties call FMPC-CRT.Sum((cid:74)ğ‘,â„“c(cid:75),(cid:74)ğ‘(1) ,â„“c(cid:75),...,(cid:74)ğ‘(ğ‘›) ,â„“c(cid:75)) and FMPC-CRT.Sum((cid:74)ğ‘,â„“c(cid:75),(cid:74)ğ‘(1) ,â„“c(cid:75),...,(cid:74)ğ‘(ğ‘›) ,â„“c(cid:75)).
(2) Parties call FMPC-CRT.Mult((cid:74)ğ‘ ,â„“c(cid:75),(cid:74)ğ‘,â„“c(cid:75),(cid:74)ğ‘,â„“c(cid:75)).
(3) Parties call FMPC-CRT.Open((cid:74)ğ‘ ,â„“c(cid:75)).
(4) Each party locally reconstructs ğ‘ =CRTrec(ğ‘ ,â„“c), checks that ğ‘ âˆˆ [22ğœ†,22(ğœ†+ğœ) ], and ğºğ¶ğ·(ğ‘€sample,ğ‘) =1, abort if false.
(1) Parties call FAgreeRandom to sample a public ğ›¾ âˆˆ Zğ‘ . Repeat until Jacobi symbol ( ğ›¾
(2) Using their integer shares of ğ‘ and ğ‘, ğ‘ƒ1 computes ğ‘¦(1) =ğ›¾ (ğ‘âˆ’ğ‘(1)âˆ’ğ‘(1)+1)/4 mod ğ‘ and calls FBroadcast(ğ‘¦(1)), and each party ğ‘ƒ ğ‘— ,ğ‘— â‰ 1 computes
(3) All parties compute ğ‘¦ =ğ‘›
(1) Parties call FAdvMPCâˆ’CRT.LevelUp with input (â„“Jac,(cid:74)ğ‘,â„“ğ‘(cid:75)) and (â„“Jac,(cid:74)ğ‘,â„“ğ‘(cid:75)), receive(cid:74)ğ‘,â„“Jac(cid:75) and(cid:74)ğ‘,â„“Jac(cid:75)
(2) Parties call FAdvMPCâˆ’CRT.Rand2k with input (â„“Jac,ğœ) to get a CRT sharing(cid:74)ğ‘¥,â„“Jac(cid:75) of a random value ğ‘¥, bounded by 2ğœ .
(3) All parties call FMPC-CRT.Mult((cid:74)ğ‘¡,â„“Jac(cid:75),(cid:74)ğ‘¥,â„“Jac(cid:75),(cid:74)((ğ‘ âˆ’ğ‘âˆ’ğ‘+1)/4),â„“Jac(cid:75)), where the multiplication result is actually bounded by ğ‘€â„“c
(4) Parties call FAdvMPCâˆ’CRT.ConvInt((cid:74)ğ‘¡,â„“Jac(cid:75)) to obtain an additive sharing of ğ‘¡ over the integers, denoted as [ğ‘¡]Int.
(5) Each party calls FBroadcast(ğ›¾ğ‘¡ ( ğ‘—)
Int ).
(7) All parties locally check thatğ‘›
(6) All parties call FMPC-CRT.Open((cid:74)ğ‘¥,â„“Jac(cid:75)), and compute ğ‘¥ =CRTrec(ğ‘¥,â„“Jac).
ğ‘—=1ğ›¾ğ‘¡ ( ğ‘—)
(1) Parties call FAdvMPCâˆ’CRT.LevelUp with input (â„“gcd,(cid:74)ğ‘,â„“ğ‘(cid:75)) and (â„“gcd,(cid:74)ğ‘,â„“ğ‘(cid:75)), receive(cid:74)ğ‘,â„“gcd(cid:75) and(cid:74)ğ‘,â„“gcd(cid:75)
(2) Parties call FAdvMPCâˆ’CRT.Rand2k with input (â„“gcd,2ğœ†+2ğœ) to get a CRT sharing(cid:74)ğ‘,â„“gcd(cid:75) of a random value ğ‘, bounded by 22ğœ†+2ğœ .
(3) All parties call FMPC-CRT.Mult((cid:74)ğ‘§,â„“gcd(cid:75),(cid:74)ğ‘,â„“gcd(cid:75),(cid:74)(ğ‘+ğ‘âˆ’1),â„“gcd(cid:75)). Note that this is fine because open ğ‘ = ğ‘ Â· ğ‘ in MPC in the first steps of
(4) Parties call FAdvMPCâˆ’CRT.Rand2k with input (â„“gcd,3ğœ†+4ğœ) to get a CRT sharing(cid:74)ğ‘£,â„“gcd(cid:75) of a random value ğ‘£, bounded by 23ğœ†+4ğœ .
(5) All parties call FMPC-CRT.Add((cid:74)Ë†ğ‘§,â„“gcd(cid:75),(cid:74)ğ‘§,â„“gcd(cid:75),(cid:74)ğ‘£Â·ğ‘ ,â„“gcd(cid:75)).
(6) All parties call FMPC-CRT.Open((cid:74)Ë†ğ‘§,â„“gcd(cid:75)), and compute Ë†ğ‘§ =CRTrec( Ë†ğ‘§,â„“gcd).
(7) Locally check whether gcd(ğ‘ ,Ë†ğ‘§) =1. Otherwise parties output Abort and restart the protocol.
candidate generation to enforce input consistency.
Int = ğ‘¦ğ‘¥ . Abort if equality fails.
and CRT
Figure 12: RSA modulus generation protocol based on distributed sieving
execution of Step 2 to 231 kbits. The opening (Step 3) takes
another 2.176 bits. One iteration of this phase has a total cost
of 233 kbits.
(3) Jacobi test. The cost of this phase is simply log2(ğ‘) Â· ğ‘›,
which is 2ğ‘›Â·ğœ† or about 4 kbits.
(4) Consistency check. This phase begins with a call to LevelUp
from â„“c to â„“Jac. The LevelUp protocol is ran twice, once for
each candidate ğ‘ and ğ‘. Concretely, per run, LevelUp requires
â„“Jac âˆ’ â„“ğ¶ = 3 inputs per party, â„“Jac multiplications and â„“Jac
openings on the CRT components. The more expensive part
of LevelUp generates ğœ†+4Â· ğœ = 1344 maBits which amount
to 22 Mbits, roughly the cost of one iteration of LevelUp. The
entire cost of Step 1 in the consistency check is 44,551 kbits.
Next, parties call Rand2k, which roughly costs ğœ random bit
generations, concretely 2095 kbits. The multiplication cost is
simply â„“JacÂ·12.862 =270.1 kbits. The call to ConvInt requires
a call to Rand2k and one opening, which amounts to 43,222
kbits. Finally, the parties need to broadcast an element in Zğ‘
and then open an element in all the â„“Jac CRT components,
which requires communicating 4.8 kbits. One iteration of
this phase has a total cost of 90,143 kbits.
(5) GCD test. Here again we start with a call to LevelUp, which
costs 56, 558 kbits, and then a call to Rand2k for a cost of
45,477 kbits. Next is a multiplication on â„“gcd CRT components
for a total cost of 591.7 kbits. Second to last, we do a final
call to Rand2k with larger parameters, so the cost this time
is 89,307 kbits. Finally, we open Ë†ğ‘§ for 5.9 kbits. This phase
thus requires a total of 191,940 kbits.
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea604Scheme
ğœ…
SH (MB)
ML (GB)
[7]
1024
139
20.81
Ours
1024
41.68
0.64
[7]
1536
416
43.42
Ours
1536
116.55