205, 24, 15
338, 27, 23
831, 32, 28
781, 32, 27
14, 4, 3
10, 3, 2
15, 5, 3
187, 19, 14
221, 22, 15
209, 21, 15
877, 29, 31
1592, 38, 38
2900, 71, 44
Design
Arbiter w/ 4 cores
and 1 shared unit
338 bits
Arbiter w/ 4 cores
and 3 shared unit
1014 bits
Properties
WISHBONE [32]
WISHBONE w/ priority for core 1
Priority-based access
WISHBONE w/ no access for core 1
TDMA
Non-interference b/w all cores
Non-interference b/w cores 1&2
U1: Non-interference
U2: Non-interference bw/ cores 1&2
U3: WISHBONE
U1: Non-interference
U2: Non-interference bw/ cores 1&3
U3: WISHBONE w/o access for cores 2&3
U1: WISHBONE w/o access for core 3
U2: Priority-based access
U3: WISHBONE
Time
(sec.)
248
162
616
171
128
157
113
312
278
719
different traits of each thread. These traits state if the thread has
hard real-time or soft real-time requirements, whether or not it
carries sensitive information, and if it is active or asleep at the
given cycle.
Sketches and Properties. The scheduler sketch consists of two
FSMs and one combinational function written with seq and comb
syntax, respectively. The first FSM outputs a thread_id based
on the given frequencies freq. The second FSM generates a new
thread_id according to the result of the first FSM and the mode
signal. The combinational function selects between the outputs
of these two FSMs. This implements two interleaving schedulers
where details of the scheduling schemes are unspecified. We have
modeled different properties regarding real-time requirements, fair-
ness, confidentiality, and efficiency as hard and soft constraints. The
real-time properties, borrowed from [55], include timing predictabil-
ity for hard real-time threads, and guaranteed expected frequency
for soft real-time threads. Timing predictability requires the sched-
uler to give the hard real-time the exact frequency that they asked
for. Guaranteed frequency on the other hand, requires the sched-
uler to give the soft real-time threads at least what they asked for.
This enables the scheduler to assign soft real-time threads to any
empty slots (for instance caused by others being asleep). Hence,
the soft real-time threads can have expected frequency of zero and
still get to execute. Both of these properties are modeled as hard
constraints. We also model fairness for the extra quota given to
soft real-time threads as soft constraints. The confidentiality re-
quirement states that activity status of sensitive threads should
not be revealed. We model this as an IFT property by assigning
High labels to active/asleep bit of sensitive threads, and asserting
that the scheduler output should maintain a Low label. Enforcing
this property changes how the scheduler assigns empty slots to
available soft real-time threads. Lastly, an efficiency property – mod-
eled as a soft constraint – synthesizes a scheduler which selects
active threads for execution. If written as a hard constraint, the
problem becomes unsatisfiable due to cases where no active thread
is available for scheduling. This experiment illustrates how soft
and hard constraints are used in property-based program synthesis
frameworks. While security and safety requirements are modeled
as hard constraints since they should be held unconditionally, soft
constraints are helpful for modeling properties regarding system
performance.
Synthesized Designs. In order to show how the sketch size af-
fects synthesis time, we generate the circuitry from three different
templates. We gradually add the sketch constructs and decrease the
manually specified details to observe the effect. Synthesis results
are shown in Table 4 where the property abbreviations are as fol-
lows. V: Valid thread id, C: Confidentiality for sensitive threads, P:
Predictability for hard real-time threads, G: Guaranteed frequency,
E: Only Scheduling available threads, F: Fairness between soft real
time threads. The formal representation of these properties is avail-
able in Table 6 in Appendix B. As shown in Table 4, the synthesis
time increases proportionally to the sketch size mostly due to the
increase in the time spent on synthesis. In the first set of experi-
ments we only leave the combinational select logic unspecified, and
implement everything else manually. For the other two rounds, we
replace the FSMs with sketches as well. For each set, we synthesize
the sketch using various combinations of the discussed properties.
The synthesis time increases as soft constraints are added. This in-
crease is mainly caused by multiple synthesis stages which fail and
are replayed by relaxing the problem. Collecting positive examples
does not contribute much to the overall time. Yices2 [14] is used as
the SMT solver for generating all the designs in these experiments.
6.5 SoC Arbiter
System-on-chip arbiters which mediate accesses in bus architec-
tures have been shown to be vulnerable against timing side channel
attacks [33, 35]. The vulnerability arises as different cores which are
requesting access to a shared unit can infer about each others access
pattern based on the time they are granted access themselves. We
model timing side channel elimination as IFT properties to enforce
non-interference between mutually untrusted cores. We further
specify various functional properties and synthesize multiple SoC
arbiters from generic FSM sketches.
Sketches and Properties. To synthesize the arbiter module, we
have sketched three FSMs where state transitions are left unspeci-
fied. The one-hot encoded req and grant signals indicate the in-
coming requests and the given grant at each clock cycle. The first
two FSMs are defined using seq syntax with different sets of inputs.
The first one takes req and grant as inputs, and the second one
models a smaller FSM where state transitions are independent of
the incoming requests. While the second FSM models designs that
can be generated by the first one, it can more quickly synthesize ar-
biters where the scheduling is independent of the input (e.g., TDMA
policy). The third sketch models an FSM which groups different
cores in disjoint sets. Finally, we sketch a combinational logic which
selects one of the FSMs. We define two sets of sketches modeling
an arbiter module which mediates between four cores sending re-
quests to one and three shared units. We define properties regarding
access control, non-interference, and priority-based scheduling to
synthesize different arbiters. The formal representation of these
properties is available in Table 7 in Appendix B.
Synthesized Designs. Table 5 shows the result of synthesizing
different arbiters by combining different sets of properties. Note
that while the sketch includes multiple FSMs, only one of them is
chosen and synthesized by CEGIS. Using this strategy, the sketch
can be automatically selected from a pool of available sketches
eliminating the need to explicitly determine a single template for
synthesis. The first four designs from Table 5 are synthesized by
the first most generic template. The next two designs are gener-
ated from our second template. Lastly, adding non-interference
properties between two cores results in using the third template
where different cores are appropriately placed in separate groups.
As we can see from the results, adding IFT properties speeds up the
synthesis procedure because these properties constrain the high-
level structure of the design. In the next round of experiments, we
replicated the templates to synthesize an arbiter which mediates
accesses to three shared units with distinct policies. Ui in the table
refers to shared uint number i. The last column of Table 5 shows
the time taken for synthesis using Questa Formal Tool.
7 CONCLUSION
This work presents a semi-automated and security-oriented method-
ology for designing hardware with formal proof of security. The
proposed design framework consists of language support for sketch-
ing digital circuitry, and a set of techniques for translating partially
written HDL codes into complete designs that provably comply with
the designers’ functional and security specifications. The proposed
flow speeds up and simplifies the lengthy process of hardware de-
sign and verification, and acquaints the traditional design flow with
automated enforcement of security properties. We have shown how
combining program synthesis techniques with the model of infor-
mation flow enables generating hardware units which are correct
and secure by construction.
ACKNOWLEDGMENTS
This material is based upon work supported by the National Science
Foundation under grant no. CNS-1527631 and CNS-1563767.
REFERENCES
[1] [n. d.]. The reference community for Free and Open Source gateware IP cores.
https://opencores.org/project,verilog_fixed_point_math_library.
[2] Rajeev Alur, Rastislav Bodik, Garvit Juniwal, Milo MK Martin, Mukund
Raghothaman, Sanjit A Seshia, Rishabh Singh, Armando Solar-Lezama, Emina
Torlak, and Abhishek Udupa. 2013. Syntax-guided synthesis. In Formal Methods
in Computer-Aided Design (FMCAD), 2013. IEEE, 1–8.
[3] Armaiti Ardeshiricham, Wei Hu, and Ryan Kastner. [n. d.]. Clepsydra: Modeling
Timing Flows in Hardware Designs. In International Conference on Computer-
Aided Design (ICCAD), 2017.
[4] Armaiti Ardeshiricham, Wei Hu, Joshua Marxen, and Ryan Kastner. [n. d.]. Reg-
ister Transfer Level Information Flow Tracking for Provably Secure Hardware
Design. In Proceedings of the 2017 Conference on Design, Automation & Test in
Europe.
[5] Clark Barrett, Christopher L Conway, Morgan Deters, Liana Hadarean, Dejan
Jovanović, Tim King, Andrew Reynolds, and Cesare Tinelli. 2011. Cvc4. In
International Conference on Computer Aided Verification. Springer, 171–177.
[6] Andrew Becker, David Novo, and Paolo Ienne. [n. d.]. Automated circuit elabora-
tion from incomplete architectural descriptions. In Signals, Systems and Comput-
ers, 2013 Asilomar Conference on.
[7] Andrew Becker, David Novo, and Paolo Ienne. 2014. SKETCHILOG: Sketching
combinational circuits. In Proceedings of the conference on Design, Automation &
Test in Europe.
[8] Robert Brummayer and Armin Biere. 2009. Boolector: An efficient SMT solver
for bit-vectors and arrays. In International Conference on Tools and Algorithms for
the Construction and Analysis of Systems. Springer, 174–177.
[9] Alan Burns and Robert Davis. 2013. Mixed criticality systems-a review. (2013),
1–69.
[10] Kai-Hui Chang, Igor L Markov, and Valeria Bertacco. [n. d.]. Fixing design errors
with counterexamples and resynthesis. In Design Automation Conference, 2007.
Asia and South Pacific.
[11] Guoxing Chen, Sanchuan Chen, Yuan Xiao, Yinqian Zhang, Zhiqiang Lin, and
Ten H Lai. 2018. SGXPECTRE Attacks: Leaking Enclave Secrets via Speculative
Execution. arXiv preprint arXiv:1802.09085 (2018).
[12] Leonardo De Moura and Nikolaj Bjørner. 2008. Z3: An efficient SMT solver. In
International conference on Tools and Algorithms for the Construction and Analysis
of Systems. Springer, 337–340.
[13] Jordan Dimitrov. 2001. Operational semantics for Verilog. In Software Engineering
Conference, 2001. APSEC 2001. Eighth Asia-Pacific. IEEE, 161–168.
[14] Bruno Dutertre. 2014. Yices 2.2. In International Conference on Computer Aided
Verification. Springer, 737–744.
[15] Niklas Eén and Niklas Sörensson. 2003. Temporal induction by incremental SAT
solving. Electronic Notes in Theoretical Computer Science 89, 4 (2003), 543–560.
[16] Dmitry Evtyushkin, Ryan Riley, Nael CSE Abu-Ghazaleh, Dmitry Ponomarev,
et al. 2018. BranchScope: A New Side-Channel Attack on Directional Branch Pre-
dictor. In Proceedings of the Twenty-Third International Conference on Architectural
Support for Programming Languages and Operating Systems. ACM, 693–707.
[17] Yu Feng, Ruben Martins, Osbert Bastani, and Isil Dillig. 2018. Program synthesis
using conflict-driven learning. In Proceedings of the 39th ACM SIGPLAN Conference
on Programming Language Design and Implementation. ACM, 420–435.
[18] Yu Feng, Ruben Martins, Jacob Van Geffen, Isil Dillig, and Swarat Chaudhuri.
2017. Component-based synthesis of table consolidation and transformation
tasks from examples. ACM SIGPLAN Notices 52, 6 (2017), 422–436.
[19] Michael Ferdman, Almutaz Adileh, Onur Kocberber, Stavros Volos, Mohammad
Alisafaee, Djordje Jevdjic, Cansu Kaynak, Adrian Daniel Popescu, Anastasia
Ailamaki, and Babak Falsafi. 2012. Clearing the Clouds: A Study of Emerging Scale-
out Workloads on Modern Hardware. Proceedings of the Seventeenth International
Conference on Architectural Support for Programming Languages and Operating
Systems (2012). http://infoscience.epfl.ch/record/173764
[20] Matthew Fredrikson, Richard Joiner, Somesh Jha, Thomas Reps, Phillip Porras,
Hassen Saïdi, and Vinod Yegneswaran. 2012. Efficient runtime policy enforcement
using counterexample-guided abstraction refinement. In International Conference
on Computer Aided Verification. Springer, 548–563.
[21] Vinod Ganapathy, Trent Jaeger, and Somesh Jha. 2006. Retrofitting legacy code
for authorization policy enforcement. IEEE.
[22] Sumit Gulwani, Susmit Jha, Ashish Tiwari, and Ramarathnam Venkatesan. 2011.
Synthesis of loop-free programs. ACM SIGPLAN Notices 46, 6 (2011), 62–73.
[23] William R Harris, Somesh Jha, and Thomas Reps. 2010. DIFC programs by