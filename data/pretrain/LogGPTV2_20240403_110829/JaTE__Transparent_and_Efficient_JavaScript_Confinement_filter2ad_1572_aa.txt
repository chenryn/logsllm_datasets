title:JaTE: Transparent and Efficient JavaScript Confinement
author:Tung Tran and
Riccardo Pelizzi and
R. Sekar
JaTE: Transparent and Efﬁcient JavaScript Conﬁnement
Tung Tran
Stony Brook University
PI:EMAIL
Riccardo Pelizzi
Stony Brook University
PI:EMAIL
R. Sekar
Stony Brook University
PI:EMAIL
ABSTRACT
Inclusion of third-party scripts is a common practice, even
among major sites handling sensitive data. The default
browser security policies are ill-suited for securing web sites
from vulnerable or malicious third-party scripts: the choice
is between full privilege () and isolation (),
with nearly all use cases (advertisement, libraries, analyt-
ics, etc.) requiring the former. Previous work attempted to
bridge the gap between the two alternatives, but all the solu-
tions were plagued by one or more of the following problems:
(a) lack of compatibility, causing most existing third-party
scripts to fail (b) excessive performance overheads, and (c)
not supporting object-level policies. For these reasons, con-
ﬁnement of JavaScript code suitable for widespread deploy-
ment is still an open problem. Our solution, JaTE, has none
of the above shortcomings. In contrast, our approach can
be deployed on today’s web sites, while imposing a relatively
low overhead of about 20%, even on web pages that include
about a megabyte of miniﬁed JavaScript code.
1.
INTRODUCTION
A recent study [26] found that nearly 90% of web sites in-
clude third-party scripts. Unfortunately, this practice poses
serious security threats to the ﬁrst-party web site, threaten-
ing its integrity and conﬁdentiality. Vulnerabilities in third-
party code can expose the ﬁrst-party to attacks such as
cross-site scripting, or the third-party server may be out-
right malicious or be compromised. Major web sites such as
Yahoo and New York Times [8, 6] have exposed their users
to malware by including third-party content in the form of
advertisements. As a result, there is a pressing need for ap-
proaches to protect web sites from third-party scripts, while
preserving their functionality.
In order to protect ﬁrst-party code, it is necessary to iso-
late third-party code from accessing (sensitive) ﬁrst-party
data or functions. There are two main approaches in this
regard:
• Frame-based isolation: The browser’s SOP isolates code
running in diﬀerent frames, while providing a controlled
means for communicating through the postMessage API.
AdJail [34], Mashic [17] and Pivot [23] rely on this ap-
proach for isolation. MashupOS [42] also relies on frames
and similar isolation mechanisms. While COWL [32] ex-
tends a browser’s SOP further to support a MAC policy,
†
0831298 and CNS-1319137) and ONR (N00014-07-1-0928).
This work was supported in part by grants from NSF (CNS-
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
ACSAC ’15, December 07 - 11, 2015, Los Angeles, CA, USA
© 2015 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-3682-6/15/12. . . $15.00
DOI: http://dx.doi.org/10.1145/2818000.2818019
it continues to rely on frame-based isolation. The main
drawback of frame-based isolation is that it limits interac-
tions (between ﬁrst- and third-party code) using familiar
means such as passing objects, or calling another party’s
functions. This limits compatibility with existing ﬁrst-
party and third-party code.
• Language-based isolation: This class of techniques aims
at isolating individual objects, so that objects can be
shared between parties, and controlled interactions can
take place through function calls. However, works in
this area must ﬁrst address the challenge of mediating
all of the numerous avenues by which JavaScript pro-
grams can interact. Early works such as Caja [20] and
BrowserShield [29] resorted to rewriting the code to in-
troduce all the necessary runtime checks. Unfortunately,
because of the dynamic nature of JavaScript, most opera-
tions need to be transformed and/or checked at runtime,
often slowing programs down by an order of magnitude or
more. An alternative approach is to develop static analy-
sis techniques that can eliminate the need for most (or all)
runtime checks. ADsafe [11], GateKeeper [13], SES [24],
JSand [9] and others [19] opt for this approach. How-
ever, full JavaScript is not amenable to static analysis,
thus forcing these techniques to impose language restric-
tions. Among these techniques, SES and JSand place the
fewest language restrictions, but these are still too severe
for real-world code: we found that 80% of the Alexa’s Top
500 websites are not supported by them.
Our Goals. We seek a secure object-granularity policy en-
forcement infrastructure compatible with existing browsers
as well as web sites, including all their ﬁrst- and third-party
code. Speciﬁcally, we seek:
• Transparency: The enforcement infrastructure should not
1
. Our so-
change the execution semantics of benign code
lution achieves this goal except for a few rare corner cases,
none of which could be observed on any of the Alexa Top
500 websites. (See Section 6.2.)
• Object-granularity policy: The infrastructure should allow
third-party code to access any subset of objects deemed
safe by a policy developer, while preventing access to oth-
ers. Even on permitted objects, access to individual op-
erations can be sand-boxed.
• Deployability on existing browsers: To facilitate adop-
tion, the approach must not require modiﬁcations to the
browser (speciﬁcally, its JavaScript engine), nor can it
impose unreasonable performance overheads.
Our Approach. We present JaTE, a new approach that
satisﬁes the above requirements. Every object is associated
1Note that the goal of any security policy is to change the ex-
ecution semantics of code that violates the policy. Thus, it is
generally infeasible to ensure transparency in the presence of a
nontrivial security policy. Moreover, since malicious code can
easily detect the presence of a policy framework by simply try-
ing out operations that any sensible policy must deny, we do not
attempt to be transparent to malicious code.
151
with a principal, and this principal has direct access to the
object, while the access of other principals is mediated using
a wrapper object that can enforce a policy. The set of all
objects belonging to a principal is held within the principal’s
compartment [41].
Many of the key challenges in JaTE, including complete
mediation and the realization of a secure multi-principal com-
partment model, arise from the complexity and highly dy-
namic nature of JavaScript. We discuss these challenges in
Section 2, followed by an overview and illustration of how
our design overcomes them in Section 3. The design and
implementation of JaTE is described in Sections 4 and 5 re-
spectively. A detailed experimental evaluation is presented
in Section 6, followed by a discussion of related work (Sec-
tion 7) and concluding remarks (Section 8). Below we sum-
marize the technical contributions of this paper.
Contributions.
• Object-capability environment for full JavaScript. Object
capability ensures that only objects explicitly given to
third-party code can be reached by it.
It provides the
basis for complete mediation. Ours is the ﬁrst work to
realize this feature without placing signiﬁcant restrictions
on the JavaScript language.
• Secure and transparent muti-principal JavaScript conﬁne-
ment without browser modiﬁcations. Our solution is ready
for deployment on any web site because existing code does
not need to be modiﬁed. It can support policies that pro-
tect mutually untrusting principals, e.g., two advertisers.
• Eﬃcient ﬁne-grained object-level access control.
• Large-scale experimental evaluation of compatibility, per-
formance, and functionality. When enforcing an allow-all
policy, our implementation demonstrates full compatibil-
ity with all sites from the Alexa Top 500, while incurring
an average overhead of about 20%.
2. CHALLENGES
Complete mediation. To ensure complete mediation, all
mechanisms for object access must be handled. This is a
diﬃcult task in JavaScript because the language supports
several unusual ways to reference objects:
• Global object access. Securing global object access is crit-
ical because all other objects are reachable from it.
In
addition to the explicit mechanism of accessing the vari-
able window, JavaScript provides implicit access to the
global object via (a) free variables that are interpreted as
property accesses on the global object, and (b) accesses
to the this keyword within a function invoked without
an object argument.
• Native prototype access. JavaScript relies on prototypes
to support object inheritance. Prototypes of native ob-
jects are shared, thus providing a mechanism for third-
party code to aﬀect the semantics of ﬁrst-party’s use of
native objects. Controlling this access is complex because
third-party code can not only rely on direct access (e.g.,
update Object.prototype), but also indirect access. For
instance, even a seemingly “safe” access to a third-party’s
own object x can allow it to update Object.prototype
using the expression x.__proto__.
• Call stack access. JavaScript allows third-party code to
travel up the call stack. This access can be used by a
third-party function to access sensitive ﬁrst-party data
such as the arguments of the ﬁrst-party function that in-
voked it.
Dynamic code. Dynamic code poses a well-recognized
challenge to security. Previous works forbade most dynamic
code (ADSafe, GateKeeper), or replaced eval(s) with a safe
wrapper, say, safeeval(s) (Caja, SES, JSand). Unfortu-
nately, use of a wrapper function might change the semantics
of s: the free variables occurring in s are no longer resolved
in the context where the original eval occurred, possibly
altering the semantics of code such as:
var x =0; eval ( " alert ( x ) " )
2.1 Discussion
Using an object-capability runtime is a well-established
approach for achieving complete mediation [21, 24, 9, 18].
The major eﬀort in this area is Secure ECMAScript (SES)
[24], an object-capability language based on ES5. SES re-
lies on ES5’s strict mode to prevent the use of caller and
implicit accesses to the global object via this. To eliminate
the threat of code injection into native prototypes, it pre-
vents their modiﬁcation by freezing them all. Moreover, it
replaces eval with a safe wrapper. All of these restrictions
tend to break existing code, and indeed, backward compati-
bility wasn’t their focus. As a result, we found that the vast
majority of Alexa Top 500 web sites experience compatibil-
ity problems with SES.
JSand [9] uses the object-capability environment of SES to
build a policy enforcement framework for third-party Java-
Script code. JSand exposes permitted objects to third-party
code using Miller’s membrane pattern [25].
In JSand, a
membrane consists of policy-enforcing wrappers around these
objects. If any operation on a wrapped object returns an-
other object, the membrane is extended to wrap the returned
object as well.
A second major goal of JSand is to achieve compatibil-
ity with existing web sites. In addition to handling implicit
access to window via this, JSand addresses a frequent in-
compatibility posed by SES: it performs a simple analysis to
identify global variables in the third-party code, and trans-
forms the code to explicitly synchronize their values with the
correspondingly named attributes of window. While proper-
ties referenced statically can be synchronized this way, dy-
namic property accesses (e.g., window[p]) pose a challenge.
Moreover, other incompatibilities posed by SES, including
the remaining restrictions of strict mode, the use of an eval
wrapper and the use of native prototype extensions, continue
to aﬀect JSand. We found that over 80% of Alexa Top 500
web sites fail to “compile” because of strict mode violations,
while 30% and 49% violate the other two restrictions.
Instead of ﬁrst denying access to the global object using
SES and then partially mitigating these restrictions, JaTE
is designed from the ground up with a single goal: intercept
every access to protected objects, so that a policy can be
applied to each of those accesses. JaTE exploits the dynamic
and reﬂection features of JavaScript, together with a simple
2
and transformation of third-party code, to
lexical analysis
ensure that all object accesses are mediated at runtime. It
does not place any signiﬁcant restrictions on JavaScript, a
fact conﬁrmed by our evaluation on Alexa top 500 sites. (See
2Unlike JSand, JaTE does not require full parsing of JavaScript,
but only a lexical analysis. All rewriting is done Just-In-Time
and cannot be circumvented through obfuscation.
152
GET index.html
1
window
site.com (HOST)
GET like.js
data
6
2
secret
getSecret
window
5
data
7
getSecret
facebook.com
4
s
index.html
site.com
Add
jate = { … };
like.js
facebook.com
ebook.c
Rewrite
- this
- function
- eval
JaTE Network Module
Direct Object
Primitive
Proxy Object
Mapping from proxy to direct 
facebook.com
site.com
Context Stack
3
createScope
jate
Browser
Figure 1: Example for a malicious Facebook “Like” Button
1
2
3
4
5
6
7
var stolen = data [ " se " + " cret " ];
f u n c t i o n s () {
var stolen = t h i s . d a t a . s e c r e t ;
};
s () ;
stolen = d at a . g e t S e c r e t () ;
eval ( " stolen = t h i s . d a t a . s e c r e t ; " ) ;
Figure 2: Malicious “Like” Script
Section 6.2 for details.)
An important feature of JaTE is that it supports multi-
ple mutually-distrusting principals, which arise in web pages
that integrate content from multiple sources, e.g., several
advertisers.
3. OVERVIEW
This section provides a high-level overview of how the
compartment model conﬁnes third-party scripts using code
transformation and runtime checking. We illustrate this us-
ing an example of ﬁrst-party (also called host) web page that
includes sensitive content in an inline script:
data = { secret: xxx ,
g e t S e c r e t : f u n c t i o n () { return t h i s . s e c r e t }}
Also assume that the page includes a Facebook “Like”-
button, but Facebook’s servers have been compromised to
replace the button with malicious code that attempts to
steal the value of secret.
The scenario begins with an HTTP request (1) in Figure 1
for retrieving the ﬁrst-party web page. The JaTE Network
Module intercepts this request and modiﬁes the page to add
an object jate that contains our conﬁnement library. This
module could be implemented in one of three ways: a client-
3
. Our
side proxy, a browser extension, or a server-side proxy
implementation relies on a browser extension.
In step (2), the “Like”-script included in the page is fetched
from Facebook. It is transformed by the network module to
enable secure policy enforcement (note that a policy can
decide: a) if code from a domain/url will be conﬁned and b)
its corresponding principal). To illustrate the main elements
of this rewriting step, consider the malicious “Like” script
shown in Listing 2. It includes four distinct mechanisms to