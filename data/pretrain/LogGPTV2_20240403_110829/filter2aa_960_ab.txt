Writing the Port Scanner . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
xii   Contents in Detail
9 
WRITING AND PORTING EXPLOIT CODE 
187
Creating a Fuzzer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
Buffer Overflow Fuzzing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
SQL Injection Fuzzing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
Porting Exploits to Go. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
Porting an Exploit from Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
Porting an Exploit from C. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
Creating Shellcode in Go . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
C Transform . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
Hex Transform . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
Num Transform. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
Raw Transform . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
Base64 Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
A Note on Assembly . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
10 
GO PLUGINS AND EXTENDABLE TOOLS 
217
Using Go’s Native Plug-in System. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
Creating the Main Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
Building a Password-Guessing Plug-in . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
Running the Scanner . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
Building Plug-ins in Lua . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
Creating the head() HTTP Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
Creating the get() Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
Registering the Functions with the Lua VM . . . . . . . . . . . . . . . . . . . . . . . . 229
Writing Your Main Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
Creating Your Plug-in Script . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
Testing the Lua Plug-in . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
11 
IMPLEMENTING AND ATTACKING CRYPTOGRAPHY 
233
Reviewing Basic Cryptography Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
Understanding the Standard Crypto Library. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
Exploring Hashing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
Cracking an MD5 or SHA-256 Hash. . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
Implementing bcrypt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
Authenticating Messages. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
Encrypting Data. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
Symmetric-Key Encryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
Asymmetric Cryptography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
Brute-Forcing RC2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
Getting Started . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
Producing Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
Performing Work and Decrypting Data . . . . . . . . . . . . . . . . . . . . . . . . . . 257
Writing the Main Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
Running the Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
Contents in Detail   xiii
12 
WINDOWS SYSTEM INTERACTION AND ANALYSIS 
263
The Windows API’s OpenProcess() Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
The unsafe.Pointer and uintptr Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
Performing Process Injection with the syscall Package . . . . . . . . . . . . . . . . . . . . . . . . 268
Defining the Windows DLLs and Assigning Variables . . . . . . . . . . . . . . . . 270
Obtaining a Process Token with the OpenProcess Windows API. . . . . . . . . 271
Manipulating Memory with the VirtualAllocEx Windows API . . . . . . . . . . . 273
Writing to Memory with the WriteProcessMemory Windows API . . . . . . . . 274
Finding LoadLibraryA with the GetProcessAddress Windows API . . . . . . . . 275
Executing the Malicious DLL Using the CreateRemoteThread  
Windows API. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
Verifying Injection with the WaitforSingleObject Windows API. . . . . . . . . . 276
Cleaning Up with the VirtualFreeEx Windows API. . . . . . . . . . . . . . . . . . . 277
Additional Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278
The Portable Executable File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
Understanding the PE File Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
Writing a PE Parser  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
Additional Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
Using C with Go . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
Installing a C Windows Toolchain. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
Creating a Message Box Using C and the Windows API . . . . . . . . . . . . . . 290
Building Go into C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
13 
HIDING DATA WITH STEGANOGRAPHY 
295
Exploring the PNG Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
The Header . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
The Chunk Sequence. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
Reading Image Byte Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298
Reading the Header Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298
Reading the Chunk Sequence. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
Writing Image Byte Data to Implant a Payload . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
Locating a Chunk Offset. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
Writing Bytes with the ProcessImage() Method . . . . . . . . . . . . . . . . . . . . . 302
Encoding and Decoding Image Byte Data by Using XOR . . . . . . . . . . . . . . . . . . . . . 307
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
Additional Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
14 
BUILDING A COMMAND-AND-CONTROL RAT 
315
Getting Started . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316
Installing Protocol Buffers for Defining a gRPC API. . . . . . . . . . . . . . . . . . . 316
Creating the Project Workspace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 317
Defining and Building the gRPC API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 317
Creating the Server . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
Implementing the Protocol Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
Writing the main() Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322
Creating the Client Implant . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 323
xiv   Contents in Detail
Building the Admin Component . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325
Running the RAT. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 326
Improving the RAT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 326
Encrypt Your Communications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
Handle Connection Disruptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
Register the Implants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
Add Database Persistence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328
Support Multiple Implants. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328
Add Implant Functionality. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329
Chain Operating System Commands. . . . . . . . . . . . . . . . . . . . . . . . . . . . 329
Enhance the Implant’s Authenticity and Practice Good OPSEC . . . . . . . . . . 329
Add ASCII Art . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330
INDEX 
331
FOR E WOR D
Programming languages have always had an impact 
on information security. The design constraints, stan-
dard libraries, and protocol implementations avail-
able within each language end up defining the attack 
surface of any application built on them. Security 
tooling is no different; the right language can sim-
plify complex tasks and make the incredibly difficult 
ones trivial. Go’s cross-platform support, single-binary output, concurrency 
features, and massive ecosystem make it an amazing choice for security tool 
development. Go is rewriting the rules for both secure application develop-
ment and the creation of security tools, enabling faster, safer, and more 
portable tooling.
Over the 15 years that I worked on the Metasploit Framework, the 
project went through two full rewrites, changed languages from Perl to 
Ruby, and now supports a range of multilingual modules, extensions, and 
payloads. These changes reflect the constantly evolving nature of software 
development; in order to keep up in security, your tools need to adapt, and 
xvi    Foreword
using the right language can save an enormous amount of time. But just 
like Ruby, Go didn’t become ubiquitous overnight. It takes a leap of faith to 
build anything of value using a new language, given the uncertainties of the 
ecosystem and the sheer amount of effort needed to accomplish common 
tasks before the standard libraries catch up.
The authors of Black Hat Go are pioneers in Go security tool develop-
ment, responsible for some of the earliest open source Go projects, includ-
ing BlackSheepWall, Lair Framework, and sipbrute, among many others. 
These projects serve as excellent examples of what can be built using the 
language. The authors are just as comfortable building software as tearing 
it apart, and this book is a great example of their ability to combine these 
skills.
Black Hat Go provides everything necessary to get started with Go devel-
opment in the security space without getting bogged down into the lesser-
used language features. Want to write a ridiculous fast network scanner, evil 
HTTP proxy, or cross-platform command-and-control framework? This book 
is for you. If you are a seasoned programmer looking for insight into security 
tool development, this book will introduce the concepts and trade-offs that 
hackers of all stripes consider when writing tools. Veteran Go developers who 
are interested in security may learn a lot from the approaches taken here, as 
building tools to attack other software requires a different mindset than typi-
cal application development. Your design trade-offs will likely be substantially 
different when your goals include bypassing security controls and evading 
detection. 
If you already work in offensive security, this book will help you build 
utilities that are light-years faster than existing solutions. If you work on the 
defense side or in incident response, this book will give you an idea of how 
to analyze and defend against malware written in the Go language.
Happy hacking!
HD Moore
Founder of the Metasploit Project and the Critical Research Corporation 
VP of Research and Development at Atredis Partners
ACK NOW L E DG M E N T S
This book would not be possible had Robert Griesemer, 
Rob Pike, and Ken Thompson not created this awesome 
development language. These folks and the entire core 
Go development team consistently contribute useful 
updates upon each release. We would have never writ-
ten this book had the language not been so easy and 
fun to learn and use.
The authors would also like to thank the team at No Starch Press: 
Laurel, Frances, Bill, Annie, Barbara, and everyone else with whom we 
interacted. You all guided us through the unchartered territory of writing 
our first book. Life happens—new families, new jobs—and all the while 
you’ve been patient but still pushed us to complete this book. The entire 
No Starch Press team has been a pleasure to work with on this project.
I would like to thank Jen for all her support, encouragement, and for keep-
ing life moving forward while I was locked away in my office nights and 
weekends, working on this never-ending book. Jen, you helped me more 
xviii   Acknowledgments
than you know, and your constant words of encouragement helped make 
this a reality. I am sincerely grateful to have you in my life. I must thank 
“T” (my canine quadra-pet) for holding the floor down in my office while I 
hacked away and reminding me that “outside” is a real place I should visit. 
Lastly, and close to my heart, I want to dedicate this book to my pups, Luna 
and Annie, who passed while I was writing this book. You girls were and are 
everything to me and this book will always be a reminder of my love for you 
both. 
Chris Patten
I would like to extend a sincere thank you to my wife and best friend, Katie, 
for your constant support, encouragement, and belief in me. Not a day goes 
by when I’m not grateful for everything you do for me and our family. I’d 
like to thank Brooks and Subs for giving me reason to work so hard. There 
is no better job than being your father. And to the best “Office Hounds” a 
guy could ask for—Leo (RIP), Arlo, Murphy, and even Howie (yes, Howie 
too)—you’ve systematically destroyed my house and periodically made me 
question my life choices, but your presence and companionship mean the 
world to me. I’ll give each of you a signed copy of this book to chew on.
Dan Kottmann
Thank you to the love of my life, Jackie, for your love and encouragement; 
nothing I do would be possible without your support and everything you 
do for our family. Thank you to my friends and colleagues at Atredis 
Partners and to anyone I’ve shared a shell with in the past. I am where 
I am because of you. Thank you to my mentors and friends who have 
believed in me since day one. There are too many of you to name; I am 
grateful for the incredible people in my life. Thank you, Mom, for putting 
me in computer classes (these were a thing). Looking back, those were a 
complete waste of time and I spent most of the time playing Myst, but it 
sparked an interest (I miss the 90s). Most importantly, thank you to my 
Savior, Jesus Christ.
Tom Steele
It was a long road to get here—almost three years. A lot has happened 
to get to this point, and here we are, finally. We sincerely appreciate the 
early feedback we received from friends, colleagues, family, and early-release 
readers. For your patience, dear reader, thank you so, so very much; we are 
truly grateful and hope you enjoy this book just as much as we enjoyed writ-
ing it. All the best to you! Now Go create some amazing code!
IN T RODU C T ION
For about six years, the three of us led 
one of North America’s largest dedicated 
penetration-testing consulting practices. As 
principal consultants, we executed technical 
project work, including network penetration tests, on 
behalf of our clients—but we also spearheaded the 
development of better tools, processes, and methodology. And at some 
point, we adopted Go as one of our primary development languages. 
Go provides the best features of other programming languages, strik-
ing a balance between performance, safety, and user-friendliness. Soon, we 
defaulted to it as our language of choice when developing tools. Eventually, 
we even found ourselves acting as advocates of the language, pushing for 
our colleagues in the security industry to try it. We felt the benefits of Go 
were at least worthy of consideration.
In this book, we’ll take you on a journey through the Go programming 
language from the perspective of security practitioners and hackers. Unlike 
other hacking books, we won’t just show you how to automate third-party or 
commercial tools (although we’ll touch on that a little). Instead, we’ll delve 
xx   Introduction
into practical and diverse topics that approach a specific problem, protocol, 
or tactic useful to adversaries. We’ll cover TCP, HTTP, and DNS communi-
cations, interact with Metasploit and Shodan, search filesystems and data-
bases, port exploits from other languages to Go, write the core functions of 
an SMB client, attack Windows, cross-compile binaries, mess with crypto, 
call C libraries, interact with the Windows API, and much, much more. It’s 
ambitious! We’d better begin . . .  
Who This Book Is For
This book is for anyone who wants to learn how to develop their own hack-
ing tools using Go. Throughout our professional careers, and particularly 
as consultants, we’ve advocated for programming as a fundamental skill 
for penetration testers and security professionals. Specifically, the ability 
to code enhances your understanding of how software works and how it 
can be broken. Also, if you’ve walked in a developer’s shoes, you’ll gain a 
more holistic appreciation for the challenges they face in securing software, 
and you can use your personal experience to better recommend mitigations, 
eliminate false positives, and locate obscure vulnerabilities. Coding often 
forces you to interact with third-party libraries and various application stacks 
and frameworks. For many people (us included), it’s hands-on experience and 
tinkering that leads to the greatest personal development. 
To get the most out of this book, we encourage you to clone the book’s 
official code repository so you have all the working examples we’ll discuss. 
Find the examples at https://github.com/blackhat-go/bhg/.
What This Book Isn’t
This book is not an introduction to Go programming in general but an 
introduction to using Go for developing security tools. We are hackers and 
then coders—in that order. None of us have ever been software engineers. 
This means that, as hackers, we put a premium on function over elegance. 
In many instances, we’ve opted to code as hackers do, disregarding some 
of the idioms or best practices of software design. As consultants, time is 
always scarce; developing simpler code is often faster and, therefore, prefer-
able over elegance. When you need to quickly create a solution to a problem, 
style concerns come secondary. 
This is bound to anger Go purists, who will likely tweet at us that we 
don’t gracefully handle all error conditions, that our examples could be 
optimized, or that better constructs or methods are available to produce 
the desired results. We’re not, in most cases, concerned with teaching you 
the best, the most elegant, or 100 percent idiomatic solutions, unless doing 
so will concretely benefit the end result. Although we’ll briefly cover the 
language syntax, we do so purely to establish a baseline foundation upon 
which we can build. After all, this isn’t Learning to Program Elegantly with 
Go—this is Black Hat Go.
Introduction   xxi
Why Use Go for Hacking?
Prior to Go, you could prioritize ease of use by using dynamically typed 
languages—such as Python, Ruby, or PHP—at the expense of performance 
and safety. Alternatively, you could choose a statically typed language, 
like C or C++, that offers high performance and safety but isn’t very user-
friendly. Go is stripped of much of the ugliness of C, its primary ancestor, 
making development more user-friendly. At the same time, it’s a statically 
typed language that produces syntax errors at compile time, increasing 
your assurance that your code will actually run safely. As it’s compiled, it 
performs more optimally than interpreted languages and was designed 
with multicore computing considerations, making concurrent program-
ming a breeze. 
These reasons for using Go don’t concern security practitioners specifi-
cally. However, many of the language’s features are particularly useful for 
hackers and adversaries:
Clean package management system Go’s package management solu-
tion is elegant and integrated directly with Go’s tooling. Through the 
use of the go binary, you can easily download, compile, and install pack-
ages and dependencies, which makes consuming third-party libraries 
simple and generally free from conflict.
Cross-compilation One of the best features in Go is its ability to 
cross-compile executables. So long as your code doesn’t interact with 
raw C, you can easily write code on your Linux or Mac system but com-
pile the code in a Windows-friendly, Portable Executable format.
Rich standard library Time spent developing in other languages has 
helped us appreciate the extent of Go’s standard library. Many modern 
languages lack the standard libraries required to perform many common 
tasks such as crypto, network communications, database connectivity, 
and data encoding (JSON, XML, Base64, hex). Go includes many of 
these critical functions and libraries as part of the language’s standard 
packaging, reducing the effort necessary to correctly set up your devel-
opment environment or to call the functions.
Concurrency Unlike languages that have been around longer, Go 
was released around the same time as the initial mainstream multicore 
processors became available. For this reason, Go’s concurrency patterns 