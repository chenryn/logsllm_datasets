# 2018-noxCTF-Crypto-RSA
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
2018-noxCTF的密码题中有许多RSA的题目，正好最近在看RSA，于是就做了一下，难度并不是很大
## Chop Suey
题目如下
    Today I ate in a Chinese restaurant and got myself a fortune cookie. These things usually contain a note with a nice sentence or phrase, but mine had numbers in it instead! Can you help me find the meaning of the numbers?
    p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 
    q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 
    dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 
    dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 
    c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852
###  题目分析
还是先摆出已知条件  
我们的目标很简单，如何从这些式子得到答案  
首先根据  
因为  
 __利用中国剩余定理,我们可以得到 由式1可以得到  
我们把这个带入式2  
可以得到  
等式两边同时减去m1,可以得到  
这里因为  
所以可以求p的逆元，得到  
所以这里得到如下两个式子 __我们上下两个式子合并，得到  
最后可以有  
 __那么问题来了  
这里的m1和m2怎么求？  
这时候我们有  
那么分别带入，有  
所以我们有  
###  Payload
推导完成后，写脚本即可
    from Crypto.Util import number
    import gmpy2
    import libnum
    def decrypt(dp,dq,p,q,c):
        InvQ = gmpy2.invert(q, p)
        mp = pow(c, dp, p)
        mq = pow(c, dq, q)
        m = (((mp-mq)*InvQ) % p)*q+mq
        print libnum.n2s(m)
    p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229
    q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469
    dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929
    dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041
    c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852
    decrypt(dp,dq,p,q,c)
得到结果
    noxCTF{W31c0m3_70_Ch1n470wn}
## Decryptor
题目如下
    I created this nice decryptor for RSA ciphertexts, you should try it out!
    nc chal.noxale.com 4242
    Oh, and someone told me to give this to you: 
    N = 140165355674296399459239442258630641339281917770736077969396713192714338090714726890918178888723629353043167144351074222216025145349467583141291274172356560132771690830020353668100494447956043734613525952945037667879068512918232837185005693504551982611886445611514773529698595162274883360353962852882911457919 
    c = 86445915530920147553767348020686132564453377048106098831426077547738998373682256014690928256854752252580894971618956714013602556152722531577337080534714463052378206442086672725486411296963581166836329721403101091377505869510101752378162287172126836920825099014089297075416142603776647872962582390687281063434 
    e = 65537
###  题目分析
我们nc过去后，得到提示
    Please insert your ciphertext to decrypt in hex form:
所以看来服务器是会解密我们input的密文  
那么这里就是一个典型的选择密文攻击，我们现在有  
我们可以构造一个x，使得  
然后我们把k发送过去，得到  
###  Payload
所以这里就很简单了，我们构造`x=2`即可  
即  
所以我们Input k  
    hex((pow(2,e,N)*c)%N)[2:-1]
得到解密结果：
    dcdef086a88cf660ea6ee6da68e46e66c8fa
我们解密即可得到flag
    tmp = 0xdcdef086a88cf660ea6ee6da68e46e66c8fa
    print libnum.n2s((tmp*gmpy2.invert(2,N))%N)
得到`noxCTF{0u7sm4r73d}`
## WTF
题目如下
    Um uhhhhhhhhh WTF IS THIS?! I give up. Now you try to solve this.
    N = lObAbAbSBlZOOEBllOEbblTlOAbOlTSBATZBbOSAEZTZEAlSOggTggbTlEgBOgSllEEOEZZOSSAOlBlAgBBBBbbOOSSTOTEOllbZgElgbZSZbbSTTOEBZZSBBEEBTgESEgAAAlAOAEbTZBZZlOZSOgBAOBgOAZEZbOBZbETEOSBZSSElSSZlbBSgbTBOTBSBBSOZOAEBEBZEZASbOgZBblbblTSbBTObAElTSTOlSTlATESEEbSTBOlBlZOlAOETAZAgTBTSAEbETZOlElBEESObbTOOlgAZbbOTBOBEgAOBAbZBObBTg
    e = lBlbSbTASTTSZTEASTTEBOOAEbEbOOOSBAgABTbZgSBAZAbBlBBEAZlBlEbSSSETAlSOlAgAOTbETAOTSZAZBSbOlOOZlZTETAOSSSlTZOElOOABSZBbZTSAZSlASTZlBBEbEbOEbSTAZAZgAgTlOTSEBEAlObEbbgZBlgOEBTBbbSZAZBBSSZBOTlTEAgBBSZETAbBgEBTATgOZBTllOOSSTlSSTOSSZSZAgSZATgbSOEOTgTTOAABSZEZBEAZBOOTTBSgSZTZbOTgZTTElSOATOAlbBZTBlOTgOSlETgTBOglgETbT
    c = SOSBOEbgOZTZBEgZAOSTTSObbbbTOObETTbBAlOSBbABggTOBSObZBbbggggZZlbBblgEABlATBESZgASBbOZbASbAAOZSSgbAOZlEgTAlgblBTbBSTAEBgEOEbgSZgSlgBlBSZOObSlgAOSbbOOgEbllAAZgBATgEAZbBEBOAAbZTggbOEZSSBOOBZZbAAlTBgBOglTSSESOTbbSlTAZATEOZbgbgOBZBBBBTBTOSBgEZlOBTBSbgbTlZBbbOBbTSbBASBTlglSEAEgTOSOblAbEgBAbOlbOETAEZblSlEllgTTbbgb
###  题目分析
拿到题目，乍一看非常奇怪，因为`(n,e,c)`都是编码过的，我们没有办法直接破解，尝试了一些常见编码方式，都无法破解，于是统计了一下
    for i in (N,e,c):
        print list(collections.Counter(i))
得到结果
    ['A', 'B', 'E', 'g', 'l', 'O', 'S', 'b', 'T', 'Z']
    ['A', 'B', 'E', 'g', 'l', 'O', 'S', 'b', 'T', 'Z']
    ['A', 'B', 'E', 'g', 'l', 'O', 'S', 'b', 'T', 'Z']
发现都一样，并且长度为10，这里就需要开个脑洞了  
将字母象形为`0-9`  
即
    dict = {
    'O' : '0',
    'l' : '1',
    'Z' : '2',
    'E' : '3',
    'A' : '4',
    'S' : '5',
    'b' : '6',