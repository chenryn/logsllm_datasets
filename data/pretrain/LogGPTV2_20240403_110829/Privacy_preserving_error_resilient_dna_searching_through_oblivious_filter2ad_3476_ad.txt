a
c
t
t
g
t
15
a
3
c
a
4
a
g
t
0
t
5
c
g
a
g
c
a
t
a
c
g
g
t
c
a
1
g
2
a
t
7
t
c
g
t
c
6
g
c
t
(b)
14
10
9
t
t
1
t
a
c
g
c
c
t
c
(a)
5
12
8
c
c
7
c
g
a
t
a
a
13
11
6
a
c
g
t
0
Figure 2: State diagram for the Levenshtein automaton accepting all the sequences at distance ≤ 1 of [actg] (a) and its
extension to arbitrary length sequences (b).
and minimizes it. If needed, the number of states can
be partially concealed by adding a random number of
dummy states.
2. In the case of a search, A extends the Levenshtein au-
tomaton by concatenating the Kleene closure of the al-
phabet Σ∗ at the left and at the right (see Section 5.1).
The resulting automaton is then minimized. Again, a
random number of dummy states can be added in or-
der to partially conceal the number of states of the
minimal automaton.
3. Both parties run the protocol presented in Section 4.1
with A’s automaton and B’s sequence xB as inputs,
in order to get a binary answer to the approximate
matching or searching problem.
Regarding the complexity of the resulting protocol, we
can combine the results obtained in Sections 4.2 and 5.1.
By virtue of the latter, the extended Levenshtein automa-
ton usually has a state complexity linear O(n) in the length
n of the sequence xA; the former shows that the private
evaluation of an automaton with |Q| states and an input
alphabet Σ on an input sequence of length N , has a com-
munication complexity of O (N · (|Q| + |Σ|)). Finally, the
application of the developed protocol for the approximate
search of a sequence of length n in another sequence of length
N incurs in a communication complexity of O (N · n). Con-
cerning computational complexity, taking into account that
the automaton transformation can be precomputed, and ap-
plying the same reasoning as for communication overhead,
the total amortized computational complexity for the owner
of the query n-length sequence xA is O(N · n), and for the
owner of the long N -length sequence xB, it is O(N ). This
means that for the party that makes the query, the privacy-
preserving protocol has a computational complexity in the
same order as the one of the non-privacy preserving proto-
col, while the complexity for the other party is linear in her
sequence’s length, and does not depend on the length of the
query string.
We can also make one ﬁnal remark about round complex-
ity. In Section 4.2 we have stated that the round complexity
of the privacy-preserving protocol for the automaton evalu-
ation is linear in the length of the input sequence (xB). In
this particular case, it is known that A′s Levenshtein au-
tomaton will accept only sequences of length smaller than
|xA| + d. Thus, if round complexity is a concern and the
value |xA| + d does not have to be kept secret, we can par-
tition the input sequence xB into several consecutive blocks
with an overlap of |xA| + d − 1 symbols, and run in parallel
one instance of the oblivious automaton protocol per block.
Then, a logical OR can be straightforwardly applied to the
obtained (concealed) outputs. Taking the maximal number
of blocks, the number of rounds of the resulting protocol does
not depend on the length of the input sequence; as a coun-
terpart, the overlaps produce an increase in communication
complexity, which is quadratic in the number of states of the
automaton. Between the two extreme cases, a tradeoﬀ can
be found, with a sublinear round complexity in the length of
the input sequence xB and a subquadratic communication
complexity in the number of states of the automaton.
6. FURTHER APPLICATIONS
As the protocol presented in Section 4 allows the eﬃcient
privacy-preserving execution of an automaton, it can be ap-
plied to any problem with a need of privacy preservation
that can be stated in terms of a regular expression. There
are plenty of applications where regular expressions are com-
monly used, like password format validation or data parsing.
In general, a regular expression can indicate the format that
a given text must conform to in order to be considered valid,
and this is normally the ﬁrst step of a validation process that
protects the validator from entries that are out of domain
and would likely cause errors. Whatever the validated infor-
mation is, the need for privacy in the validator extends also
to the need of privacy for the format checker.
Another typical application of regular expressions is ﬁle
parsing, where some text is erased, substituted or inserted
in some parts of the ﬁle; this can be done through the ap-
plication of a ﬁnite automaton with output. When security
is a concern the input text has to be protected, and the pre-
sented protocol may be applied. A speciﬁc case of the above
is word or pattern ﬁnding in a document, a commonly used
technique in spam checkers for electronic mail or virus an-
alyzers. When dealing with conﬁdential mails or private
software, they must be protected from the party that runs
the checker or analyzer. The application of the protocol for
these scenarios is straightforward.
On the other hand, sequential transducers represent an
eﬃcient approach for large-scale dictionaries [15, 16], used
for computational linguistics, in lexical analysis, morphology
and phonology, syntax, text-to-speech synthesis, or speech
recognition. All these applications can also be handled by
the protocol presented in this work when there is the need
of protecting the recognized sequence.
7. CONCLUSIONS
We have presented a protocol for the secure evaluation of
ﬁnite state machines. Besides showing its security in the
semi-honest setting, the protocol has been proven to be eﬃ-
cient in terms of communication complexity, the latter being
linear in the size of the input alphabet and in the number
of states of the FSM.
As the main application ﬁeld, we have shown a way of us-
ing the developed protocol for secure DNA matching, thereby
overcoming the performance deﬁcits of previous approaches.
Furthermore, we have presented the ﬁrst eﬃcient privacy-
preserving solution for error-resilient DNA searching. Fi-
nally, due to the versatility of ﬁnite state machines, the pre-
sented protocol can also be used for privately solving any
problem that involves matching a string against a regular
expression, such as searching a DNA database with incom-
plete deﬁnitions, oblivious spam checkers and virus analyz-
ers.
Acknowledgments. This work was partially funded by Xunta
de Galicia under projects PGIDT04 TIC322013PR and PGIDT04
PXIC32202PM; MEC project DIPSTICK, reference TEC2004-
02551/TCM and the European Commission through the IST Pro-
grammes under Contract IST-2006-034238 SPEED and IST-2002-
507932 ECRYPT. The information in this paper is provided as
is, and no guarantee or warranty is given or implied that the in-
formation is ﬁt for any particular purpose. The user thereof uses
the information at its sole risk and liability.
8. REFERENCES
[1] Human gemome project.
http://genomics.energy.gov.
[2] M. J. Atallah, F. Kerschbaum, and W. Du. Secure and
private sequence comparisons. In Proceedings of the
2003 ACM Workshop on privacy in the electronic
society, pages 39–44, Washington, DC, 2003. ACM
Press.
[3] M. J. Atallah and J. Li. Secure outsourcing of
sequence comparisons. International Journal of
Information Security, 4(4):23–36, October 2005.
[4] R. E. Bellman. Dynamic Programming. Courier Dover
Publications, 2003.
[5] B. Chor, S. Goldwasser, S. Micali, and B. Awerbuch.
Veriﬁable secret sharing and achieving simultaneity in
the presence of faults. In 25th Annual Symposium on
Foundations of Computer Science FOCS’85, pages
383–395. IEEE Computer Society, 1985.
[6] I. Damg˚ard, M. Fitzi, E. Kiltz, J. B. Nielsen, and
T. Toft. Unconditionally secure constant-rounds
multi-party computation for equality, comparison, bits
and exponentiation. In Proceedings of the third Theory
of Cryptography Conference, TCC 2006, volume 3876
of Lecture Notes in Computer Science, pages 285–304.
Springer-Verlag, 2006.
[7] O. Goldreich. Secure multi-party computation.
Working Draft, 2002.
[8] O. Goldreich, S. Micali, and A. Widgerson. How to
play any mental game. In Proceedings of the nineteenth
annual ACM conference on Theory of Computing,
pages 218–229, New York, U.S.A., 1987. ACM Press.
[9] S. Goldwasser and S. Micali. Probabilistic encryption.
Journal of Computer and System Sciences,
28(2):270–299, April 1984.
[10] A. Hall. Coming soon: Your personal dna map?
http://news.nationalgeographic.com/news/2006/03/0307_060307_dna.html .
[11] J. E. Hopcroft and J. D. Ullman. Introduction to
automata theory, languages, and computation.
Addison Wesley, 1979.
[12] M. Jacobsson and A. Juels. Mix and match: Secure
function evaluation via ciphertexts. In T. Okamoto,
editor, Advances in Cryptology – ASIACRYPT’00,
volume 1976 of Lecture Notes in Computer Science,
pages 162–177. Springer-Verlag, 2000.
[13] L. Kruger, S. Jha, E.-J. Goh, and D. Boneh. Secure
function evaluation with ordered binary decision
diagrams. In Proceedings of the 13th ACM conference
on Computer and communications security CCS’06,
pages 410–420, Virginia, U.S.A., November 2006.
ACM Press.
[14] V. I. Levenshtein. Binary codes capable of correcting
deletions, insertions and reversals. Doklady Akademii
Nauk SSSR, 163(4):845–848, 1965. English translation
at Soviet Physics Doklady 10(8): 707–710, 1966.
[15] M. Mohri. On some application of ﬁnite-state
automata theory to natural language. Natural
Language Engineering, 2(1):1–20, 1996.
[16] M. Mohri. Finite-state transducers in language and
speech processing. Computational Linguistics,
23(2):269–311, 1997.
[17] M. Naor and K. Nissim. Communication complexity
and secure function evaluation. Electronic Colloquium
on Computational Complexity (ECCC), 8(062), 2001.
[18] M. Naor and K. Nissim. Communication preserving
protocols for secure function evaluation. In ACM
Symposium on Theory of Computing, pages 590–599,
2001.
[19] M. Naor and B. Pinkas. Eﬃcient oblivious transfer
protocols. In Proceedings of the twelfth annual
ACM-SIAM symposium on Discrete algorithms, pages
448–457, Washington, D.C., U.S.A., 2001.
[20] S. B. Needleman and C. D. Wunsch. A general
method applicable to the search for similarities in the
amino acid sequence of two proteins. Journal on
Molecular Biology, 48:443–453, 1970.
[21] P. Paillier. Public-key cryptosystems based on
composite degree residuosity classes. In Advances in
Cryptology - EUROCRYPT 1999, volume 1592 of
Lecture Notes in Computer Science, pages 223–238.
Springer, 1999.
[22] K. U. Shulz and S. Mihov. Fast string correction with
levenshtein automata. International Journal of
Document Analysis and Recognition (IJDAR),
5(1):67–85, 2002.
[23] T. K. Vintsyuk. Speech discrimination by dynamic
programming. Kibernetika, 4:52–57, 1968.
[24] A. C. Yao. Protocols for secure computations. In
Proceedings of the IEEE Symposium on Foundations
of Computer Science, pages 160–164, 1982.
[25] S. Yu and Q. Zhuang. The state complexities of some
basic operations on regular languages. Theoretical
Computer Science, 125:315–328, 1994.