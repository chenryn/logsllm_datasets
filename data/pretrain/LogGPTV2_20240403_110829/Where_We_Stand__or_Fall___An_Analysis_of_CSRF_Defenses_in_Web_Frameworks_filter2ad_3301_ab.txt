ing [116]. A similar result can be achieved by cookie jar overflow
attack [97], which floods the browser with HTTP requests to set
cookies and exploit the limited capacity that browsers’ cookie jar
have [51]. When this limit is reached, older cookies get evicted [86]
and can be replaced with attacker-specified values. Examples of
these vulnerabilities are 2016-8615 [21] and CVEs 2019-14998 [30].
5.4 Implementation Mistakes
The final category of threats encompasses improper ways to vali-
date incoming HTTP requests, ranging from incorrect user-token
association to missing checks, as presented next.
Missing Checks on HTTP Methods. A robust CSRF verifica-
tion should enforce CSRF checks on all incoming HTTP requests,
Table1:OverviewofCSRFdefensesandthreats.TheleftpartsummarizesoursurveyofCSRFdefenses.Therightpartshowsthemappingbetweeneachdefenseandpotentialthreats.TokenGen.TokenLeakageCookieInt.ImplementationMistakesCategoryCSRFDefenseDefenseSourceInsecureRandomnessInsuff.TokenRandomnessInsuff.KeyRandomnessVuln.CryptoLibrariesBREACHReferrerLeakageOver-perm.CORSConf.TimingAttacksonCmp.CookieTossingCookieJarOverflowInsec.TokenMappingSafeHTTPMet.CheckUnsafeHTTPMet.CheckHTTPMethodOverrideLogicalErrorsWSHijackingReplayAttackFaultyRef./Orig.CheckOriginChecksReferer/OriginHeaderCheck[63,99,114,129]----------------CustomRequestHeaders[63,99,129]----------------RequestUnguessabilityPlainToken[63,126]----EncryptedToken[3,63]---HMACToken[3,63,99]---DoubleSubmit[63,134]---TripleSubmit[133]--Cookie-lessUserSessions[55]----SOPforCookiesSameSiteCookies[92,95,128,131]-----------------FrequentLogOuts(server-enforced)[74]----------------BrowserExtensions[104,114,115]-----------------Server-sideProxies[112,115,119,123,124]-----------------UserIntentionRe-authentication[63]----------------One-timeToken[63]-------------(re)CAPTCHA[63]-------------FrequentLogOuts(user-enforced)[74]------------------Multi-browserNavigation[3,63,100]------------------Legend:=potentialsecurityrisk;-=notapplicable;encryption,i.e.,insufficientkeyrandomness.Examplesofinsuffi-cientrandomnessvulnerabilitiesareCVEs2012-1598[6],and2021-23127[37].5.2CSRFTokenLeakageandAbuseThesecondcategoryofthreatsthatweconsideredtargetstheex-changeofthetokenbetweentheclientandserver.Thiscategoryincludesattackswheretheadversarycanexploitweaknessesthatallowleakingthetoken.Side-channelAttacks.Anattackercanleakthetokensthroughside-channelsusingattackslikeBREACH[106],whichaffectsap-plicationsthatusedatacompressionsuchasgziporDEFLATEinHTTPresponses.Here,anattackercouldtrickuser’sbrowserintosubmittingmultiplerequestsandobservelengthvariationsduetocompressionandleakthetoken.ExamplesofBREACHvul-nerabilitiesareCVE2015-2206[9]and2014-9720[10].Anotherside-channelcanoriginatefromthewayapplicationscompareto-kens.Forexample,defaultstringcomparisonfunctionssuchasstrcmpstopthecomparisonatthefirstmismatchingcharacter,allowinganexternalobservertomonitorthetimeincreasebe-tweencomparisons,revealingthecorrectcharacter.ExamplesofsuchavulnerabilityareCVEs2015-6728[12],2015-8125[13],2015-8623[14],2016-10535[16],and2018-1000119[25].Cross-DomainReferrerLeakage.Whentransmittingtheto-kentotheclient,developerscanusehiddenHTMLinputforms,JavaScriptvariables,orcustomrequestheaders.However,devel-opersshouldconsidernotincludingtokensasURLparametersastheycanbeleaked.Forexample,URLsmayappearintheRefererHTTPheader,disclosingtokenstoexternalwebsites.ExamplesofthesevulnerabilitiesareH1reportnos.342693[44]and787160[48],andCVEs2016-5739[18]and2019-15515[31].CORSMisconfiguration.Attackerscanalsoexploitserver-sidemisconfigurationstoleaktheCSRFtokens.Forexample,anover-permissiveCORSpolicy[2,102]thatsetsAccess-Control-Allow-Origin(ACAO)HTTPheadertoreflecttherequest’soriginandAccess-Control-Allow-Credentials(ACAC)totrue,allowat-tackerstoreadresponses’bodyofcross-originrequests,whichisforbiddenbydefaultbrowsers’policies.Accordingly,theattackercouldsendacross-originrequesttofetchapagewiththeCSRFtokenanduseitinaCSRFattack.ExamplesofthesevulnerabilitiesareH1reportnos.975983[49],577969[47],and426147[45]or2015-9243[15]andCVEs2016-10549[17].5.3CookieIntegrityToken-basedCSRFdefenses,suchasDoubleandTripleSubmitcookie,relyoncookieswhichanattackermaytrytocorrupt.Forexample,iftheattackercontrolsasubdomainofthetargetwebapplication,theattackercansetoroverwritecookiesoftheparentdomainwithattacker-specifiedvalues[116],knownascookietoss-ing[116].Asimilarresultcanbeachievedbycookiejaroverflowattack[97],whichfloodsthebrowserwithHTTPrequeststosetcookiesandexploitthelimitedcapacitythatbrowsers’cookiejarhave[51].Whenthislimitisreached,oldercookiesgetevicted[86]andcanbereplacedwithattacker-specifiedvalues.Examplesofthesevulnerabilitiesare2016-8615[21]andCVEs2019-14998[30].5.4ImplementationMistakesThefinalcategoryofthreatsencompassesimproperwaystovali-dateincomingHTTPrequests,rangingfromincorrectuser-tokenassociationtomissingchecks,aspresentednext.MissingChecksonHTTPMethods.ArobustCSRFverifica-tionshouldenforceCSRFchecksonallincomingHTTPrequests,6375Where We Stand (or Fall): An Analysis of CSRF Defenses in Web Frameworks
RAID ’21, October 6–8, 2021, San Sebastian, Spain
irrespective of the request method. For example, GET is a safe, idem-
potent HTTP method that should not be used for state-changing
requests [84]. Yet, this does not prevent a developer from perform-
ing state-changing requests using GET which could lead to CSRF
attacks. Similarly, developers may not perform CSRF checks on all
unsafe HTTP methods, e.g., DELETE or PUT [72]. Finally, the prob-
lem is aggravated by the HTTP Method Override feature, which is
used to change the request method. If CSRF checks are only applied
to specific HTTP methods, CSRF validation could be bypassed by
overriding the request method (see, e.g., 2017-16136 [23] and CVEs
2020-35239 [94] ).
Logical Mistakes. Unlike syntactical code errors, logical errors
do not trigger a compilation error and might go unnoticed. A sim-
ple logic error could be using the OR operator instead of AND, thus
accepting a request if only one of the conditions holds (see, e.g.,
CVEs 2017-0894 [22], 2017-9339 [24], and 2019-12659 [28]). A simi-
lar mistake is the incorrect user-token mapping. If each user does
not have a unique CSRF token for each session, an attacker can
obtain the same token as the victim (see, e.g., CVE-2020-11825 [33])
by being a user of the application. Finally, CSRF validation of the
request can be erroneous. For example, a faulty comparison between
the request’s origin and the application’s origin can occur due to
incorrect regular expressions [108]. Examples of this vulnerability
are CVEs 2018-6651 [27], 2018-10899 [26], and 2016-6806 [20].
Replay Attacks. These attacks operate under the assumption that
the attacker has leaked the CSRF token [105, 122]. In such cases,
the attacker can reuse the same token to forge a state-changing
request until the expiration of the session cookie (see, e.g., CVEs
2014-1808 [8], 2016-6582 [19], and 2020-5261 [36]).
Cross-Site WebSocket Hijacking. Another implementation mis-
take exploits the way WebSocket (WS) connections are authenti-
cated. If the authentication solely relies on cookies (as opposed to
TLS/HTTP authentication), the WS connection can be hijacked by
a CSRF attack [125]. Instances of this vulnerability are CVEs 2019-
13209 [29], 2019-17654 [32], 2020-14368 [34], and 2020-25095 [35].
6 SECURITY ANALYSIS OF THE
IMPLEMENTATIONS
We now present the results of our security analysis on the 44 web
frameworks identified in Section 3.1 against the 18 threats of §5.
First, we present an overview of the usage of CSRF defenses (Sec-
tion 6.1), and then we present the discovered security risks (Sec-
tion 6.2).
6.1 Demographics of CSRF Defenses
Built-in Defenses and Defaults. Our analysis uncovered a rami-
fied and rather complex landscape. First, not all frameworks pro-
vide off-the-shelve CSRF defenses. In total, 16 frameworks (about
36%) are shipped without built-in CSRF defenses, including Ex-
press, Flask, and Spring, the most popular frameworks in JavaScript,
Python, and Java, respectively. For 13 of them, we identified ex-
ternal libraries providing CSRF protection. Then, the remaining
28 frameworks provide built-in CSRF defenses; however, in 17 of
them (covering for more than 60% of the frameworks with built-in
defenses), CSRF defenses are disabled by default. Both these cases
Table 2: Frequency of the combination of CSRF defenses.
Each entry in this symmetric table shows the number of
frameworks that use a certain combination.
can be problematic if developers are not security-aware and forget
to install the necessary libraries or enable the defense correctly.
Few but Popular Frameworks with No Defenses. Overall, five
of the 44 frameworks do not have built-in CSRF defenses and the
documentation does not suggest any as well. We point out that two
of them, Bottle and Spark, are among the top five Python and Java
frameworks, respectively.
Implemented Defenses. In total, 39 frameworks can have a CSRF
defense as a built-in feature or via official external libraries. For
Bottle and Spark, who have no defenses, we identified unofficial
libraries via Stack Overflow [50, 75] and internet search [76]. Ac-
cordingly, we extended the testbed of frameworks to 41 frameworks
by including Bottle and Spark. The vast majority of frameworks
implement the Double Submit (i.e., 22) or Plain Token (i.e., 18)
defense. The least frequent CSRF defense is Cookie-less user Ses-
sion, used only by Meteor. This technique is an emerging pattern,
where the web storage and custom client-side JS code replace cook-
ies and cookie management policies, respectively. The number of
frameworks that use the rest of the defenses are as follows: 12
HMAC Token, 10 SameSite Cookies, 4 Encrypted Token, and 4 Ref-
erer/Origin Check. We refer interested readers to Appendix A for a
complete list of defenses implemented by each framework.
Defense in Depth. Web frameworks may implement multiple
CSRF defenses at the same time. For example, almost half of the
frameworks (i.e., 19) enforce two or more defenses in sequence.
Table 2 shows the frequency of combinations of defenses across
web frameworks of our testbed. We observe that Double Submit
and HMAC Token are used together more than any other pair of
defenses, i.e., in 12 frameworks.
6.2 Vulnerabilities and Security Risks
In total, we discovered 157 security risks affecting 37 frameworks,
all of which can be mounted by a web attacker. However, we note
that the exploitability of these risks may vary. For example, out of
irrespectiveoftherequestmethod.Forexample,GETisasafe,idem-potentHTTPmethodthatshouldnotbeusedforstate-changingrequests[84].Yet,thisdoesnotpreventadeveloperfromperform-ingstate-changingrequestsusingGETwhichcouldleadtoCSRFattacks.Similarly,developersmaynotperformCSRFchecksonallunsafeHTTPmethods,e.g.,DELETEorPUT[72].Finally,theprob-lemisaggravatedbytheHTTPMethodOverridefeature,whichisusedtochangetherequestmethod.IfCSRFchecksareonlyappliedtospecificHTTPmethods,CSRFvalidationcouldbebypassedbyoverridingtherequestmethod(see,e.g.,2017-16136[23]andCVEs2020-35239[94]).LogicalMistakes.Unlikesyntacticalcodeerrors,logicalerrorsdonottriggeracompilationerrorandmightgounnoticed.Asim-plelogicerrorcouldbeusingtheORoperatorinsteadofAND,thusacceptingarequestifonlyoneoftheconditionsholds(see,e.g.,CVEs2017-0894[22],2017-9339[24],and2019-12659[28]).Asimi-larmistakeistheincorrectuser-tokenmapping.IfeachuserdoesnothaveauniqueCSRFtokenforeachsession,anattackercanobtainthesametokenasthevictim(see,e.g.,CVE-2020-11825[33])bybeingauseroftheapplication.Finally,CSRFvalidationoftherequestcanbeerroneous.Forexample,afaultycomparisonbetweentherequest’soriginandtheapplication’sorigincanoccurduetoincorrectregularexpressions[108].ExamplesofthisvulnerabilityareCVEs2018-6651[27],2018-10899[26],and2016-6806[20].ReplayAttacks.TheseattacksoperateundertheassumptionthattheattackerhasleakedtheCSRFtoken[105,122].Insuchcases,theattackercanreusethesametokentoforgeastate-changingrequestuntiltheexpirationofthesessioncookie(see,e.g.,CVEs2014-1808[8],2016-6582[19],and2020-5261[36]).Cross-SiteWebSocketHijacking.Anotherimplementationmis-takeexploitsthewayWebSocket(WS)connectionsareauthenti-cated.Iftheauthenticationsolelyreliesoncookies(asopposedtoTLS/HTTPauthentication),theWSconnectioncanbehijackedbyaCSRFattack[125].InstancesofthisvulnerabilityareCVEs2019-13209[29],2019-17654[32],2020-14368[34],and2020-25095[35].6SECURITYANALYSISOFTHEIMPLEMENTATIONSWenowpresenttheresultsofoursecurityanalysisonthe44webframeworksidentifiedinSection3.1againstthe18threatsof§5.First,wepresentanoverviewoftheusageofCSRFdefenses(Sec-tion6.1),andthenwepresentthediscoveredsecurityrisks(Sec-tion6.2).6.1DemographicsofCSRFDefensesBuilt-inDefensesandDefaults.Ouranalysisuncoveredarami-fiedandrathercomplexlandscape.First,notallframeworkspro-videoff-the-shelveCSRFdefenses.Intotal,16frameworks(about36%)areshippedwithoutbuilt-inCSRFdefenses,includingEx-press,Flask,andSpring,themostpopularframeworksinJavaScript,Python,andJava,respectively.For13ofthem,weidentifiedex-ternallibrariesprovidingCSRFprotection.Then,theremaining28frameworksprovidebuilt-inCSRFdefenses;however,in17ofthem(coveringformorethan60%oftheframeworkswithbuilt-indefenses),CSRFdefensesaredisabledbydefault.BoththesecasesTable2:FrequencyofthecombinationofCSRFdefenses.Eachentryinthissymmetrictableshowsthenumberofframeworksthatuseacertaincombination.Ref./Orig.HeaderPlainTokenEncryptedTokenHMACTokenDoubleSubmitTripleSubmitSameSiteCookiesCust.Req.Hdr.Cookie-lessUsrSess.One-timeToken(re)CAPTCHAFrequentLogoutsRe-authenticationBrowserextensionsServer-sideProxiesMulti-browserNav.Ref./Orig.Header4002302000000000PlainToken01800003000000000EncryptedToken0044401000000000HMACToken204121204000000000DoubleSubmit304122206000000000TripleSubmit0000000000000000SameSiteCookies23146010000000000Cust.Req.Hdr.0000000000000000Cookie-lessUsrSess.0000000010000000One-timeToken0000000000000000(re)CAPTCHA0000000000000000FrequentLogOuts0000000000000000Re-authentication0000000000000000BrowserExtensions0000000000000000Server-sideProxies0000000000000000Multi-browserNav.0000000000000000canbeproblematicifdevelopersarenotsecurity-awareandforgettoinstallthenecessarylibrariesorenablethedefensecorrectly.FewbutPopularFrameworkswithNoDefenses.Overall,fiveofthe44frameworksdonothavebuilt-inCSRFdefensesandthedocumentationdoesnotsuggestanyaswell.Wepointoutthattwoofthem,BottleandSpark,areamongthetopfivePythonandJavaframeworks,respectively.ImplementedDefenses.Intotal,39frameworkscanhaveaCSRFdefenseasabuilt-infeatureorviaofficialexternallibraries.ForBottleandSpark,whohavenodefenses,weidentifiedunofficiallibrariesviaStackOverflow[50,75]andinternetsearch[76].Ac-cordingly,weextendedthetestbedofframeworksto41frameworksbyincludingBottleandSpark.ThevastmajorityofframeworksimplementtheDoubleSubmit(i.e.,22)orPlainToken(i.e.,18)defense.TheleastfrequentCSRFdefenseisCookie-lessuserSes-sion,usedonlybyMeteor.Thistechniqueisanemergingpattern,wherethewebstorageandcustomclient-sideJScodereplacecook-iesandcookiemanagementpolicies,respectively.Thenumberofframeworksthatusetherestofthedefensesareasfollows:12HMACToken,10SameSiteCookies,4EncryptedToken,and4Ref-erer/OriginCheck.WereferinterestedreaderstoAppendixAforacompletelistofdefensesimplementedbyeachframework.DefenseinDepth.WebframeworksmayimplementmultipleCSRFdefensesatthesametime.Forexample,almosthalfoftheframeworks(i.e.,19)enforcetwoormoredefensesinsequence.Table2showsthefrequencyofcombinationsofdefensesacrosswebframeworksofourtestbed.WeobservethatDoubleSubmitandHMACTokenareusedtogethermorethananyotherpairofdefenses,i.e.,in12frameworks.6.2VulnerabilitiesandSecurityRisksIntotal,wediscovered157securityrisksaffecting37frameworks,allofwhichcanbemountedbyawebattacker.However,wenotethattheexploitabilityoftheserisksmayvary.Forexample,outof157,17securityrisksaredirectlyexploitablewithoneoftwoHTTP7376RAID ’21, October 6–8, 2021, San Sebastian, Spain
Xhelal Likaj, Soheil Khodayari, and Giancarlo Pellegrino
Table 3: Summary of results on top five frameworks of top
five languages.
Token Gen. Token
Leakage
Cookie
Int.
Implementation Mistakes
s
s
e
n
m
o
d
n
a
R
n
e
k
o
T
s
s
e
n
m
o
d
n
a
R
y
e
K
s
e
i
r
a
r
b
i
L
o
t
p
y
r
C
.
.
ff
u
s
n
I
ff
u
s
n
I
.
l
n
u
V
s
s
e
n
m
o
d
n
a
R
e
r
u
c
e
s
n
Web Framework I
.
f
n
o
C
S
R
O
C
.
m
r
e
p
-
r
e
v
O
.
p
m
C
n
o
s
k
c
a
t
t
A
g
n
m
T
i
i
g
n
i
s
s
o
T
e
i
k
o
o
C
e
g
a
k
a
e
L
r
e
r
r
e
f
e
R
H
C
A
E
R
B
k
c
e
h
C
.
t
e
M
P
T
T
H
e
f
a
s
n
U
e
d
i
r
r
e
v
O
d
o
h
t
e
M
P
T
T
H
k
c
e
h
C
.
t
e
M
P
T
T
H
e
f
a
S
g
n
i
p
p
a
M
n
e
k
o
T
.
c
e
s
n
I
s
r
o
r
r
E
l
a
c
i
g
o
L
g
n
i
k
c
a
j
i
H
S
W
k
c
a
t
t
A
y
a
l
p
e
R
w
o
fl
r
e
v
O
r
a
J
e
i
k
o
o
C
k
c
e
h
C
.
g
i
r
O
/
.
f
e
R
y
t
l
u
a
F
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
l
a
t
o
T
l
a
t
o
T
l
a
t
o
T
6
11
12
2
10 1 4
8 1 6
11
3
12 2 3
10 2 4
11
5
12 1 3
12 1 4
8
6
10 1 5
9 1 4
8 1 7
11
3
4
11
2
12
12
2
8 2 6
11 1 2
3
2
3
2
5
13
14
13
14
11
274
Table 4: Summary of results on less popular frameworks of
top four languages. Only five frameworks were identified
for C#.
Token
Leakage
Cookie
Int.
Implementation
Mistakes
.
p
m
C
n
o
s
k
c
a
t
t
e
g
a
k
a
e
L
r
e
r
r
e
f
e
R
A
d
e
s
a
B
-
g
n
m
T
i
i
g
n
i
s
s
o
T
e
i
k
o
o
C
H
C
A
E
Web Framework B
R
k
c
e
h
C
k
c
e
h
C
.
t
e
M
P
T
T
H
e
f
a
s
n
U
.
t
e
M
P
T
T
H
e
f
a
S
g