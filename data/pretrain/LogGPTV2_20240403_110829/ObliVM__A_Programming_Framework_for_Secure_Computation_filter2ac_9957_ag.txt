on human microbiomes [59].
B. Future Work
In future work, we will implement a C-based Garbled
Circuit back end similar to JustGarble [4], such that we can
exploit hardware AES-NI features of modern processors. We
will also implement the state-of-the-art OT optimizations [8]. It
will also be interesting to provide support for multiple parties
and malicious security. Since ObliVM is designed to be good at
compiling programs to compact circuits, it will be interesting
to extend ObliVM to support other cryptographic back ends
such as fully homomorphic encryption, program obfuscation
and veriﬁable computation.
ACKNOWLEDGMENTS
We are indebted to Michael Hicks and Jonathan Katz for
their continual support of the project. We are especially thank-
ful towards Andrew Myers for his thoughtful feedback during
the revision of the paper. We also gratefully acknowledge Srini
Devadas, Christopher Fletcher, Ling Ren, Albert Kwon, abhi
shelat, Dov Gordon, Nina Taft, Udi Weinsberg, Stratis Ioanni-
dis, and Kevin Sekniqi for their insightful inputs and various
forms of support. We thank the anonymous reviewers for their
insightful feedback. This research is partially supported by
NSF grants CNS-1464113, CNS-1314857, a Sloan Fellowship,
Google Research Awards, and a subcontract from the DARPA
PROCEED program.
REFERENCES
[1] A. C.-C. Yao, “Protocols for secure computations (extended abstract),”
in FOCS, 1982.
[2] O. Goldreich, S. Micali, and A. Wigderson, “How to play any mental
game,” in STOC, 1987.
[3] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank, “Extending Oblivious
Transfers Efﬁciently,” in CRYPTO 2003, 2003.
[4] M. Bellare, V. T. Hoang, S. Keelveedhi, and P. Rogaway, “Efﬁcient
Garbling from a Fixed-Key Blockcipher,” in S & P, 2013.
[5] V. Kolesnikov and T. Schneider, “Improved Garbled Circuit: Free XOR
Gates and Applications,” in ICALP, 2008.
[6] S. G. Choi, J. Katz, R. Kumaresan, and H.-S. Zhou, “On the security
of the “free-xor” technique,” in TCC, 2012.
[7] B. Applebaum, “Garbling xor gates “for free” in the standard model,”
in TCC, 2013.
[8] G. Asharov, Y. Lindell, T. Schneider, and M. Zohner, “More Efﬁcient
Oblivious Transfer and Extensions for Faster Secure Computation,” ser.
CCS ’13, 2013.
[9] D. Bogdanov, S. Laur, and J. Willemson, “Sharemind: A Framework
for Fast Privacy-Preserving Computations,” in ESORICS, 2008.
[10] B. Kreuter, B. Mood, A. Shelat, and K. Butler, “PCF: A portable circuit
format for scalable two-party secure computation,” in Usenix Security,
2013.
[11] B. Kreuter, a. shelat, and C.-H. Shen, “Billion-gate secure computation
with malicious adversaries,” in USENIX Security, 2012.
374
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:08:02 UTC from IEEE Xplore.  Restrictions apply. 
[12] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella, “Fairplay: a secure two-
party computation system,” in USENIX Security, 2004.
[13] W. Henecka, S. K¨ogl, A.-R. Sadeghi, T. Schneider, and I. Wehrenberg,
“Tasty: tool for automating secure two-party computations,” in CCS,
2010.
[14] Y. Zhang, A. Steele, and M. Blanton, “PICCO: a general-purpose
compiler for private distributed computation,” in CCS, 2013.
[15] C. Liu, Y. Huang, E. Shi, J. Katz, and M. Hicks, “Automating Efﬁcient
RAM-model Secure Computation,” in S & P, May 2014.
[16] A. Holzer, M. Franz, S. Katzenbeisser, and H. Veith, “Secure Two-party
Computations in ANSI C,” in CCS, 2012.
[17] A. Rastogi, M. A. Hammer, and M. Hicks, “Wysteria: A Programming
Language for Generic, Mixed-Mode Multiparty Computations,” in S &
P, 2014.
“Partisia,” http://www.partisia.dk/.
“Dyadic security,” http://www.dyadicsec.com/.
[18]
[19]
[20] R. Canetti, “Security and composition of multiparty cryptographic
protocols,” Journal of Cryptology, 2000.
[21] C. Liu, X. S. Wang, M. Hicks, and E. Shi, “Formalizing the ObliVM
language,” Manuscript in preparation, 2015.
J. Agat, “Transforming out timing leaks,” in POPL, 2000.
[43]
[44] A. Russo, J. Hughes, D. A. Naumann, and A. Sabelfeld, “Closing
internal timing channels by transformation,” in ASIAN, 2006.
[45] M. T. Goodrich and M. Mitzenmacher, “Privacy-preserving access of
outsourced data via oblivious RAM simulation,” in ICALP, 2011.
[46] D. Dachman-Soled, C. Liu, C. Papamanthou, E. Shi, and U. Vishkin,
“Oblivious network RAM,” Cryptology ePrint Archive, Report
2015/073, 2015, http://eprint.iacr.org/.
[47] G. Malewicz, M. H. Austern, A. J. Bik, J. C. Dehnert, I. Horn, N. Leiser,
and G. Czajkowski, “Pregel: a system for large-scale graph processing,”
in SIGMOD, 2010.
“Graphlab,” http://graphlab.org.
[48]
[49] M. Blanton, A. Steele, and M. Alisagari, “Data-oblivious graph algo-
rithms for secure computation and outsourcing,” in ASIA CCS, 2013.
[50] A. A. Karatsuba, “The Complexity of Computations,” 1995.
[51] X. S. Wang, Y. Huang, T.-H. H. Chan, A. Shelat, and E. Shi, “SCO-
RAM: Oblivious RAM for Secure Computation,” in CCS, 2014.
[52] V. Nikolaenko, U. Weinsberg, S. Ioannidis, M. Joye, D. Boneh, and
N. Taft, “Privacy-preserving ridge regression on hundreds of millions
of records,” in S & P, 2013.
[22] M. T. Goodrich and J. A. Simons, “Data-Oblivious Graph Algorithms
in Outsourced External Memory,” CoRR, vol. abs/1409.0597, 2014.
J. Brickell and V. Shmatikov, “Privacy-preserving graph algorithms in
the semi-honest model,” in ASIACRYPT, 2005.
[23]
[24] K. Nayak, X. S. Wang, S. Ioannidis, U. Weinsberg, N. Taft, and E. Shi,
“GraphSC: Parallel Secure Computation Made Easy,” in IEEE S & P,
2015.
[25] V. Nikolaenko, S. Ioannidis, U. Weinsberg, M. Joye, N. Taft, and
D. Boneh, “Privacy-preserving matrix factorization,” in CCS, 2013.
[26] X. S. Wang, K. Nayak, C. Liu, T.-H. H. Chan, E. Shi, E. Stefanov, and
Y. Huang, “Oblivious Data Structures,” in CCS, 2014.
[27] M. Keller and P. Scholl, “Efﬁcient, oblivious data structures for MPC,”
in Asiacrypt, 2014.
J. C. Mitchell and J. Zimmerman, “Data-Oblivious Data Structures,” in
STACS, 2014, pp. 554–565.
[28]
[29] X. S. Wang, T.-H. H. Chan, and E. Shi, “Circuit ORAM: On Tightness
of the Goldreich-Ostrovsky Lower Bound,” Cryptology ePrint Archive,
Report 2014/672, 2014.
“Rsa distributed credential protection,” http://www.emc.com/security/
rsa-distributed-credential-protection.htm.
[30]
[31] C. Liu, M. Hicks, and E. Shi, “Memory trace oblivious program
execution,” ser. CSF ’13, 2013, pp. 51–65.
[32] S. D. Gordon, A. McIntosh, J. Katz, E. Shi, and X. S. Wang, “Secure
computation of MIPS machine code,” Manuscript, 2015.
[33] Y. Huang, D. Evans, J. Katz, and L. Malka, “Faster secure two-party
computation using garbled circuits,” in Usenix Security Symposium,
2011.
[34] E. M. Songhori, S. U. Hussain, A.-R. Sadeghi, T. Schneider, and
F. Koushanfar, “TinyGarble: Highly Compressed and Scalable Sequen-
tial Garbled Circuits,” in IEEE S & P, 2015.
[35] A. C.-C. Yao, “How to generate and exchange secrets,” in FOCS, 1986.
[36] M. Naor, B. Pinkas, and R. Sumner, “Privacy preserving auctions and
mechanism design,” ser. EC ’99, 1999.
[37] S. Zahur, M. Rosulek, and D. Evans, “Two halves make a whole: Reduc-
ing data transfer in garbled circuits using half gates,” in EUROCRYPT,
2015.
[38] C. Gentry, “Fully homomorphic encryption using ideal lattices,” in
STOC, 2009.
[39] C. Liu, X. S. Wang, K. Nayak, Y. Huang, and E. Shi, “Oblivm: A
programming framework for secure computation,” 2015, http://www.cs.
umd.edu/∼elaine/docs/oblivmtr.pdf.
[40] O. Goldreich and R. Ostrovsky, “Software protection and simulation on
oblivious RAMs,” J. ACM, 1996.
[41] O. Goldreich, “Towards a theory of software protection and simulation
by oblivious RAMs,” in STOC, 1987.
[42] E. Shi, T.-H. H. Chan, E. Stefanov, and M. Li, “Oblivious RAM with
O((log N )3) worst-case cost,” in ASIACRYPT, 2011.
375
[53] T. Hastie, R. Tibshirani, and J. Friedman, The Elements of Statistical
Learning: Data Mining, Inference, and Prediction, 2001.
“Private communication,” 2014.
[54]
[55] M. Naor and B. Pinkas, “Efﬁcient oblivious transfer protocols,” in
SODA, 2001.
[56] http://humangenomeprivacy.org/2015.
[57] N. A. Jagadeesan, R. Pal, K. Nadikuditi, Y. Huang, E. Shi, and M. Yu,
“A secure computation framework for SDNs,” in HotSDN, 2014.
[58] X. S. Wang, C. Liu, K. Nayak, Y. Huang, and E. Shi, “idash secure
genome analysis competition using oblivm,” Cryptology ePrint Archive,
Report 2015/191, 2015, http://eprint.iacr.org/.
J. Wagner, J. Paulson, X. S. Wang, H. Corrada-Bravo, and B. Bhat-
tacharjee, “Privacy-preserving human microbiome analysis using secure
computation,” Manuscript, 2015.
[59]
[60] E. Kushilevitz, S. Lu, and R. Ostrovsky, “On the (in)security of hash-
based oblivious RAM and a new balancing scheme,” in SODA, 2012.
APPENDIX A
ADDITIONAL OBLIVIOUS ALGORITHM
A. Additional Oblivious Graph Algorithm
It is has been an open question how to construct an Oblivi-
ous Depth First Search (ODFS) algorithm that outperforms one
built on generic ORAMs [22]. Here we answer this question
for dense graphs. We present O((E + V ) log V ) time ODFS
algorithm. In comparison, a generic-ORAM based oblivious
solution would take O((E+V ) log2 V ) time (ignoring possible
log log factors) [29], [60].
The challenge is that in standard DFS, we need to verify
whether a vertex has been visited every time we explore a new
edge. Typically, this is done by storing a bit-array that supports
dynamic access. To make it oblivious would require placing
this bit-array inside an ORAM, thus incurring O(log2 V ) cost
per access, and O(E log2 V ) time over all O(E) accesses.
To solve this problem, instead of verifying if a vertex has
been visited, we maintain a tovisit list of vertexes, which
preserves the same traversal order as DFS. When new vertexes
are added to this list, we guarantee that each vertex appears
in the list at most once using an oblivious sorting algorithm.
Algorithm 3 presents our oblivious DFS algorithm, and deﬁnes
the inputs, outputs, and how they are stored.
Since DFS explores the latest visited vertex ﬁrst, so we
maintain a stack-like tovisit array, where the top of the stack
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:08:02 UTC from IEEE Xplore.  Restrictions apply. 
Algorithm 3 Oblivious DFS
Secret Input: s: starting vertex;
Secret Input: E: adjacency matrix, stored in an ORAM of V
blocks, each block being one row of the matrix.
Output: order: DFS traversal order // not in ORAM
1: tovisit:=[(s, 0), ⊥, ..., ⊥];
2: for i = 1 → |V | do
(u, depth) := tovisit[1];
tovisit[1] := (u,∞); // mark as visited
order[i] := u;
edge := E[u];
for v := 1 → |V | do
// not in ORAM
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13: return order
else
if edge[v] == 1 then // (u, v) is an edge
add[v] := (v, i); // add is not in ORAM
add[v] := ⊥;
// (u, v) is not an edge
tovisit.Merge(add) ;
u.
Algorithm 4 Minimum Spanning Tree with bounded for
Secret Input: s: the source node
Secret Input: e: concatenation of adjacency lists stored in a
single ORAM array. Each vertex’s neighbors are stored
adjacent to each other.
Secret Input: s[u]: sum of out-degree over vertices from 1 to
Output: dis: the shortest distance from source to each node
1: explored := [false, false, ..., false]
2: PQ.push(0, s)
3: res := 0
4: bwhile(V)(!PQ.empty())
5:
6:
7:
8:
9:
10:
11:
res:= res + weight
explored[u] := true
bfor(E)(i := s[u]; i  d(cid:3)) will be combined into (v, d).
• Fixed length. The length of tovisit is exactly V .
) where
1) O-sort and deduplicate. This sorting groups all entries
for the same vertex together, with the depth ﬁeld in
descending order (∞ comes ﬁrst). All ⊥ entries are
moved to the end. Then, for all entries with the same
vertex number (which are adjacent), we keep only the ﬁrst
one (which has the largest depth value) while overwriting
others with ⊥.
2) O-sort and trim. This sorting will (a) push all ⊥ entries to
the end; (b) push all ∞ entries to the end; and (c) sort all
remaining entries in descending order of depth. Discard
everything but the ﬁrst V entries.
Cost analysis. The inner loop (lines 8-11) runs in constant
time, and will run V 2 times. Lines 3-5 also run in constant
time, but will only run V times. Line 6 is an ORAM read,
and it will run V times. Since the ORAM’s block size is
V = ω(log2 V ), each ORAM read has an amortized cost
of O(V log V ). Finally, Line 12, which will run V times,
consists of four oblivious sortings over an O(V )-size array,
thus costs O(V log V ). Hence, the overall cost of our algorithm
is O(V 2 log V ).
B. Oblivious Minimum Spanning Tree
In Algorithm 4, we show the pseudo-code for minimum
spanning tree algorithm written using ObliVM-lang with our
new loop coalescing abstraction. The algorithm is very similar
to the standard textbook implementation except for the an-
notations used for bounded-for loops in Lines 4 and 9. As
described in Section IV-C, the inner loop (Line 9 to Line
11) will only execute O(V + E) times over all iterations
of the outer loop. Further, each execution of the inner loop
requires circuits of size O(log2 V ), using latest oblivious
data structures [26] and Circuit ORAM [29]. So the overall
complexity is O((V +E) log2 V ). We defer further discussions
about minimum spanning tree algorithm to our online full
version [39].
376
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:08:02 UTC from IEEE Xplore.  Restrictions apply.