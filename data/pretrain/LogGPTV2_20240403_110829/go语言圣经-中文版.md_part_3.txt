必须告诉编译器源文件需要哪些包，这就是跟随在 声明后面的 声明扮演的角
package import
色。hello world例子只用到了一个包，大多数程序需要导入多个包。
必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。这
项严格要求避免了程序开发过程中引入未使用的包（译注：Go语言编译过程没有警告信息，
争议特性之一）。
声明必须跟在文件的 声明之后。随后，则是组成程序的函数、变量、常量、
import package
类型的声明语句（分别由关键字 func , var , const , type 定义）。这些内容的声明顺序并
不重要（译注：最好还是定一下规范）。这个例子的程序已经尽可能短了，只声明了一个函
数, 其中只调用了一个其他函数。为了节省篇幅，有些时候, 示例程序会省
略 和 声明，但是，这些声明在源代码里有，并且必须得有才能编译。
package import
一个函数的声明由 关键字、函数名、参数列表、返回值列表（这个例子里的 函数
func main
参数列表和返回值都是空的）以及包含在大括号里的函数体组成。第五章进一步考察函数。
Hello, World 20
gopl
Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会
主动把特定符号后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析（译
注：比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键
字 、 、 或 中的一个、运算符和分隔符 、
break continue fallthrough return ++ -
、 、 或 中的一个）。举个例子, 函数的左括号 必须和 函数声明在同一行上,
- ) ] } { func
且位于末尾，不能独占一行，而在表达式 中，可在 后换行，不能在 前换行（译
x + y + +
注：以+结尾的话不会被插入分号分隔符，但是以x结尾的话则会被分号分隔符，从而导致编
译错误）。
Go语言在代码格式上采取了很强硬的态度。 工具把代码格式化为标准格式（译注：这
gofmt
个格式化工具没有任何可以调整代码格式的参数，Go语言就是这么任性），并且 工具中
go
的 子命令会对指定包, 否则默认为当前目录, 中所有.go源文件应用 命令。本书中的
fmt gofmt
所有代码都被gofmt过。你也应该养成格式化自己的代码的习惯。以法令方式规定标准的代码
格式可以避免无尽的无意义的琐碎争执（译注：也导致了Go语言的TIOBE排名较低，因为缺
少撕逼的话题）。更重要的是，这样可以做多种自动源码转换，如果放任Go语言代码格式，
这些转换就不大可能了。
很多文本编辑器都可以配置为保存文件时自动执行 ，这样你的源代码总会被恰当地格
gofmt
式化。还有个相关的工具， ，可以根据代码需要, 自动地添加或删除 声
goimports import
明。这个工具并没有包含在标准的分发包中，可以用下面的命令安装：
$ go get golang.org/x/tools/cmd/goimports
对于大多数用户来说，下载、编译包、运行测试用例、察看Go语言的文档等等常用功能都可
以用go的工具完成。10.7节详细介绍这些知识。
Hello, World 21
gopl
1.2. 命令行参数
大多数的程序都是处理输入，产生输出；这也正是“计算”的定义。但是, 程序如何获取要处理
的输入数据呢？一些程序生成自己的数据，但通常情况下，输入来自于程序外部：文件、网
络连接、其它程序的输出、敲键盘的用户、命令行参数或其它类似输入源。下面几个例子会
讨论其中几个输入源，首先是命令行参数。
包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从os
os
包的Args变量获取；os包外部使用os.Args访问该变量。
os.Args变量是一个字符串（string）的切片（slice）（译注：slice和Python语言中的切片类
似，是一个简版的动态数组），切片是Go语言的基础概念，稍后详细介绍。现在先把切片s当
作数组元素序列, 序列的长度动态变化, 用 访问单个元素，用 获取子序列(译注：
s[i] s[m:n]
和python里的语法差不多)。序列的元素数目为len(s)。和大多数编程语言类似，区间索引时，
Go言里也采用左闭右开形式, 即，区间包括第一个索引元素，不包括最后一个, 因为这样可以
简化逻辑。（译注：比如a = [1, 2, 3, 4, 5], a[0:3] = [1, 2, 3]，不包含最后一个元素）。比如
s[m:n]这个切片，0 ≤ m ≤ n ≤ len(s)，包含n-m个元素。
os.Args的第一个元素，os.Args[0], 是命令本身的名字；其它的元素则是程序启动时传给它的
参数。s[m:n]形式的切片表达式，产生从第m个元素到第n-1个元素的切片，下个例子用到的
元素包含在os.Args[1:len(os.Args)]切片中。如果省略切片表达式的m或n，会默认传入0或
len(s)，因此前面的切片可以简写成os.Args[1:]。
下面是Unix里echo命令的一份实现，echo把它的命令行参数打印成一行。程序导入了两个
包，用括号把它们括起来写成列表形式, 而没有分开写成独立的 声明。两种形式都合
import
法，列表形式习惯上用得多。包导入顺序并不重要；gofmt工具格式化时按照字母顺序对包名
排序。（示例有多个版本时，我们会对示例编号, 这样可以明确当前正在讨论的是哪个。）
gopl.io/ch1/echo1
命令行参数 22
gopl
// Echo1 prints its command-line arguments.
package main
import (
"fmt"
"os"
)
func main() {
var s, sep string
for i := 1; i < len(os.Args); i++ {
s += sep + os.Args[i]
sep = " "
}
fmt.Println(s)
}
注释语句以 开头。对于程序员来说，//之后到行末之间所有的内容都是注释，被编译器忽
//
略。按照惯例，我们在每个包的包声明前添加注释；对于 ，注释包含一句或几
main package
句话，从整体角度对程序做个描述。
var声明定义了两个string类型的变量s和sep。变量会在声明时直接初始化。如果变量没有显
式初始化，则被隐式地赋予其类型的零值（zero value），数值类型是0，字符串类型是空字
符串""。这个例子里，声明把s和sep隐式地初始化成空字符串。第2章再来详细地讲解变量和
声明。
对数值类型，Go语言提供了常规的数值和逻辑运算符。而对string类型， 运算符连接字符
+
串（译注：和C++或者js是一样的）。所以表达式：
sep + os.Args[i]
表示连接字符串sep和os.Args。程序中使用的语句：
s += sep + os.Args[i]
是一条赋值语句, 将s的旧值跟sep与os.Args[i]连接后赋值回s，等价于：
s = s + sep + os.Args[i]
运算符 是赋值运算符（assignment operator），每种数值运算符或逻辑运算符，
+=
如 或 ，都有对应的赋值运算符。
+ *
命令行参数 23
gopl
echo程序可以每循环一次输出一个参数，这个版本却是不断地把新文本追加到末尾来构造字
符串。字符串s开始为空，即值为""，每次循环会添加一些文本；第一次迭代之后，还会再插
入一个空格，因此循环结束时每个参数中间都有一个空格。这是一种二次加工（quadratic
process），当参数数量庞大时，开销很大，但是对于echo，这种情形不大可能出现。本章会
介绍echo的若干改进版，下一章解决低效问题。
循环索引变量i在for循环的第一部分中定义。符号 := 是短变量声明（short variable
declaration）的一部分, 这是定义一个或多个变量并根据它们的初始值为这些变量赋予适当类
型的语句。下一章有这方面更多说明。
自增语句 给 加1；这和 以及 都是等价的。对应的还有 给 减
i++ i i += 1 i = i + 1 i-- i
1。它们是语句，而不像C系的其它语言那样是表达式。所以 非法，而且++和--都只
j = i++
能放在变量名后面，因此 也非法。
--i
Go语言只有for循环这一种循环语句。for循环有多种形式，其中一种如下所示：
for initialization; condition; post {
// zero or more statements
}
for循环三个部分不需括号包围。大括号强制要求, 左大括号必须和post语句在同一行。
initialization语句是可选的，在循环开始前执行。initalization如果存在，必须是一条简单语句
（simple statement），即，短变量声明、自增语句、赋值语句或函数调用。 是一
condition
个布尔表达式（boolean expression），其值在每次循环迭代开始时计算。如果为 则执
true
行循环体语句。 语句在循环体执行结束后执行，之后再次对 求
post condition
值。 值为 时，循环结束。
condition false
for循环的这三个部分每个都可以省略，如果省略 和 ，分号也可以省
initialization post
略：
// a traditional "while" loop
for condition {
// ...
}
如果连 也省略了，像下面这样：
condition
// a traditional infinite loop
for {
// ...
}
命令行参数 24
gopl
这就变成一个无限循环，尽管如此，还可以用其他方式终止循环, 如一条 或 语
break return
句。
循环的另一种形式, 在某种数据类型的区间（range）上遍历，如字符串或切
for
片。 的第二版本展示了这种形式：
echo
gopl.io/ch1/echo2
// Echo2 prints its command-line arguments.
package main
import (
"fmt"
"os"
)
func main() {
s, sep := "", ""
for _, arg := range os.Args[1:] {
s += sep + arg
sep = " "
}
fmt.Println(s)
}
每次循环迭代， 产生一对值；索引以及在该索引处的元素值。这个例子不需要索引，
range
但 的语法要求, 要处理元素, 必须处理索引。一种思路是把索引赋值给一个临时变量,
range
如 temp , 然后忽略它的值，但Go语言不允许使用无用的局部变量（local variables），因为这
会导致编译错误。
Go语言中这种情况的解决方法是用 空标识符 （blank identifier），即 _ （也就是下划线）。
空标识符可用于任何语法需要变量名但程序逻辑不需要的时候, 例如, 在循环里，丢弃不需要
的循环索引, 保留元素值。大多数的Go程序员都会像上面这样使用 和 写 程
range _ echo
序，因为隐式地而非显式地索引os.Args，容易写对。
的这个版本使用一条短变量声明来声明并初始化 和 ，也可以将这两个变量分开
echo s seps
声明，声明一个变量有好几种方式，下面这些都等价：
s := ""
var s string
var s = ""
var s string = ""
用哪种不用哪种，为什么呢？第一种形式，是一条短变量声明，最简洁，但只能用在函数内
部，而不能用于包变量。第二种形式依赖于字符串的默认初始化零值机制，被初始化为""。第
三种形式用得很少，除非同时声明多个变量。第四种形式显式地标明变量的类型，当变量类
命令行参数 25
gopl
型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。实践中一般使
用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。
如前文所述，每次循环迭代字符串s的内容都会更新。 连接原字符串、空格和下个参数，
+=
产生新字符串, 并把它赋值给 。 原来的内容已经不再使用，将在适当时机对它进行垃圾
s s
回收。
如果连接涉及的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使
用 包的 函数：
strings Join
gopl.io/ch1/echo3
func main() {
fmt.Println(strings.Join(os.Args[1:], " "))
}
最后，如果不关心输出格式，只想看看输出值，或许只是为了调试，可以用 为我们
Println
格式化输出。
fmt.Println(os.Args[1:])
这条语句的输出结果跟 得到的结果很像，只是被放到了一对方括号里。切片都
strings.Join
会被打印成这种格式。
练习 1.1： 修改 程序，使其能够打印 ，即被执行命令本身的名字。
echo os.Args[0]
练习 1.2： 修改 程序，使其打印每个参数的索引和值，每个一行。
echo
练习 1.3： 做实验测量潜在低效的版本和使用了 的版本的运行时间差异。（1.6
strings.Join
节讲解了部分 包，11.4节展示了如何写标准测试程序，以得到系统性的性能评测。）
time
命令行参数 26
gopl
1.3. 查找重复的行
对文件做拷贝、打印、搜索、排序、统计或类似事情的程序都有一个差不多的程序结构：一
个处理输入的循环，在每个元素上执行计算处理，在处理的同时或最后产生输出。我们会展
示一个名为 的程序的三个版本；灵感来自于Unix的 命令，其寻找相邻的重复行。