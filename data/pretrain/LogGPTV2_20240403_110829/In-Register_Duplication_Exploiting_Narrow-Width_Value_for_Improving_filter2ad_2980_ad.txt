gcc
mcf
crafty
parser
eon
perlbmk
gap
vortex
bzip2
twolf
Avg
Total
339
947
399
1716
320
549
372
457
535
246
333
516
560.8
Error Rate: e-5
Active
Inactive
Self-recovery
146
529
123
856
119
262
162
179
288
107
119
213
258.6
43.1%
55.9%
30.8%
49.9%
37.2%
47.7%
43.5%
39.2%
53.8%
43.5%
35.7%
41.3%
43.5%
193
418
276
860
201
287
210
278
247
139
214
303
302.2
0
0
0
0
0
1
0
0
0
0
0
0
0.08
Total
3603
9555
3760
16931
3432
5904
3564
4416
5497
2396
3171
5390
5634.9
Error Rate: e-4
Active
Inactive
Self-recovery
1584
5134
1193
8370
1293
2855
1490
1683
2895
1210
1209
2182
2591.5
44.0%
53.7%
31.7%
49.4%
37.7%
48.4%
41.8%
38.1%
52.7%
50.5%
38.1%
40.5%
43.9%
2019
4421
2567
8561
2139
3049
2074
2733
2602
1186
1962
3208
3043.4
0
10
0
10
0
6
1
0
0
0
8
0
2.9
Table 2. A characterization of soft errors injected into the register ﬁle system.
(a)
(b)
Figure 7. A Characterization of erroneous reads for input operands: (a) distribution of the error
sources, (b) breakdown of erroneous reads with single-bit and multiple-bit errors. (Left bar for e-5
and right bar for e-4)
(a)
(a)
(b)
(b)
Figure 8. Soft error detection in the IRD scheme by (a) duplicate value comparison, and (b) parity
checking. (Left bar for e-5 and right bar for e-4)
Figure 9. (a) Normalized erroneous reads and error detection for narrow-width values in the IRD
scheme, and (b) error recovery rate of detected errors in IRD scheme, under error injection rates of
10−5 (left bar) and 10−4 (right bar) per selected bit per cycle.
the number of erroneous reads of narrow-width values is
reduced to 49% of those presented in Figure 8. Of these
readin erroneous narrow-width values, IRD detects 99.7%
of the errors, which is very encouraging. Once errors are de-
tected, IRD makes the following decision: if the duplicate
in the upper 32-bit half passes the parity check, IRD uses
the duplicate for error recovery; otherwise, IRD generates
an ERROR exception and lets the operating system handle
error recovery. We introduce an additional 1000 cycles for
this ERROR exception handler. Notice that each detected
erroneous regular value will trigger this ERROR exception.
However, during IRD recovery, if the duplicate was also
corrupted but yet succeeded in parity checking (even num-
ber of bit errors), IRD is forced to perform a false recovery
using the corrupted duplicate. Figure 9 (b) shows, that, of
the detected errors in narrow-width input operands, IRD re-
covers 99.7% (99.2%) of the errors with non-corrupted du-
plicates, IRD True Recovery. The false recovery rate,
IRD False Recovery, is 0% (0.1%) at error rates e-5
(e-4). The operating system takes care of the remaining
0.3% (0.7%) of the detected errors. A performance com-
parison was shown early in Figure 6 (b). The performance
overhead due to error recovery is negligible at these two er-
ror rates.
Overall, these results conﬁrm that our in-register dupli-
cation scheme exploiting narrow-width values is very effec-
tive in detecting and recovering soft errors occurring in the
register ﬁle, the bypass network, or the result writeback bus,
while only incurring some minor microarchitectural modi-
ﬁcations.
8. Conclusions and Future Work
We propose in this work to exploit narrow-width reg-
ister values for designing high-performance reliable regis-
ter ﬁles. Instead of allocating an additional copy register
for storing the duplicate, our in-register duplication (IRD)
scheme duplicates a replica of the narrow-width value in its
upper 32-bit half, thus eliminating the hardware complex-
ity required for acquiring and maintaining copy registers in
previous schemes. Evaluation via software error injection,
our IRD scheme has demonstrated superior error detection
and recovery rates at minimum hardware cost, making it a
suitable design in high-performance, highly reliable micro-
processors. For future work, we plan to extend the current
IRD framework to also support hardware recovery for error-
corrupted regular values. We are also working on the power
evaluation of the IRD scheme. Another interesting direction
is to apply the idea of in-register duplication for protecting
the data cache.
References
[1] Hp nonstop himalaya. http://nonstop.compaq.com/.
[2] T. Austin. Diva: A reliable substrate for deep submicron microarchitecture
In Proc. the 32nd Annual IEEE/ACM International Symposium on
design.
Microarchitecture, pages 196–207, November 1999.
[3] E. Borch et al. Loose loops sink chips. In Proc. of HPCA-8, pages 270–281,
February 2002.
[4] D. Brooks and M. Martonosi. Dynamically exploiting narrow width operands
to improve processor power and performance. In Proc. of HPCA-5, January
1999.
[5] D. Burger and T. M. Austin. The simplescalar tool set, version 2.0. Technical
Report 1342, Computer Sciences Department, University of Wisconsin, 1997.
[6] O. Ergin et al. Register packing: Exploiting narrow-width operands for reduc-
ing register ﬁle pressure. In Proc. of MICRO-37, pages 304–315, Portland,
OR, 2004.
[7] M. Gomaa, C. Scarbrough, T. Vijaykumar, and I. Pomeranz. Transient-fault
recovery for chip multiprocessors. In Proc. the International Symposium on
Computer Architecture, pages 98–109, June 2003.
[8] M. Gomaa and T. N. Vijaykumar. Opportunistic transient-fault detection.
In Proceedings of the 32nd Annual International Symposium on Computer
Architecture (ISCA), June 2005.
[9] J. S. Hu, G. M. Link, J. K. John, S. Wang, and S. G. Ziavras. Resource-driven
optimizations for transient-fault detecting superscalar microarchitectures. In
Proc. of Tenth Asia-Paciﬁc Computer Systems Architecture Conference (AC-
SAC 05), Singapore, October 24-26 2005.
[10] G. S. S. J. Adam Butts. Use-based register caching with decoupled index-
ing. In Proceedings of 31st Annual International Symposium on Computer
Architecture (ISCA’04), pages 302–313, 2004.
[11] S. Kim and A. Somani. Area efﬁcient architectures for information integrity
checking in cache memories. In Proceedings of International Symposium on
Computer Architecture (ISCA), pages 246–255, May 1999.
[12] L. Li et al. Soft error and energy consumption interactions: A data cache
perspective. In Proc. of ISLPED’04, pages 132–137, 2004.
[13] M. H. Lipasti et al. Physical register inlining. In Proc. of ISCA-31, pages
325–335, June 2004.
[14] G. H. Loh. Exploiting data-width locality to increase superscalar execution
bandwidth. In Proc. of MICRO-35, 2002.
[15] R. E. Lyons and W. Vanderkulk. The use of tripple-modular redundancy to
improve computer reliability. IBM Journal, April 1962.
[16] G. Memik, M. H. Chowdhury, A. Mallik, and Y. I. Ismail. Engineering
over-clocking: Reliability-performance trade-offs for high-performance reg-
ister ﬁles. In International Conference on Dependable Systems and Networks
(DSN’05), pages 770–779, 2005.
[17] G. Memik et al. Increasing register ﬁle immunity to transient errors. In Proc.
of DATE 2005, Munich, Germany, May 2005.
[18] A. Mendelson and N. Suri. Designing high-performance and reliable super-
scalar architectures: The out of order reliable superscalar (o3rs) approach. In
Proc. of the International Conference on Dependable Systems and Networks,
June 2000.
[19] S. S. Mukherjee, M. Kontz, and S. K. Reinhardt. Detailed design and evalua-
tion of redundant multithreading alternatives. In Proc. the 29th Annual Inter-
national Symposium on Computer Architecture, pages 99–110, May 2002.
[20] S. S. Mukherjee, C. T. Weaver, J. Emer, S. K. Reinhardt, and T. Austin. A
systematic methodology to compute the architectural vulnerability factors for
a high-performance microprocessor.
In Proc. the 36th Annual IEEE/ACM
International Symposium on Microarchitecture, December 2003.
[21] M. Namjoo and E. McCluskey. Watchdog processors and detection of mal-
functions at the system level. Technical Report 81-17, CRC, December 1981.
[22] A. Parashar, S. Gurumurthi, and A. Sivasubramaniam. A complexity-effective
approach to alu bandwidth enhancement for instruction-level temporal redun-
dancy. In Proc. the 31st Annual International Symposium on Computer Ar-
chitecture, June 2004.
[23] R. P. Preston et al. Design of an 8-issue superscalar risc microprocessor with
In Proc. IEEE International Solid-State Cir-
simultaneous multithreading.
cuits Conference, 2002.
[24] J. Ray, J. Hoe, and B. Falsaﬁ. Dual use of superscalar datapath for transient-
fault detection and recovery. In Proc. the 34th Annual IEEE/ACM Interna-
tional Symposium on Microarchitecture, pages 214–224, December 2001.
[25] S. Reinhardt and S.Mukherjee. Transient fault detection via simultaneous
multithreading. In Proc. the 27th Annual International Symposium on Com-
puter Architecture, pages 25–36, June 2000.
[26] E. Rotenberg. Ar-smt: A microarchitectural approach to fault tolerance in
In Proc. the International Symposium on Fault-Tolerant
microprocessors.
Computing, pages 84–91, June 1999.
[27] T. Sherwood et al. Automatically characterizing large scale program behavior.
In Proc. of ASPLOS X, October 2002.
[28] P. Shivakumar et al. Modeling the effect of technology trends on the soft error
rate of combinational logic. In Proc. International Conference on Dependable
Systems and Networks, pages 389–398, June 2002.
[29] T. J. Slegel et al.
IBM’s S/390 G5 microprocessor design.
IEEE Micro,
19(2):12–23, March/April 1999.
[30] J. Smolens, J. Kim, J. C. Hoe, and B. Falsaﬁ. Efﬁcient resource sharing
In ACM/IEEE
in concurrent error detecting superscalar microarchitecture.
International Symposium on Microarchitecture (MICRO), December 2004.
[31] K. Sundaramoorthy, Z. Purser, and E. Rotenburg. Slipstream processors: Im-
proving both performance and fault tolerance. In Proc. the 9th International
Conference on Architectural Support for Programming Languages and Oper-
ating systems, pages 257–268, 2000.
[32] T. Vijaykumar, I. Pomeranz, and K. Cheng. Transient-fault recovery via si-
multaneous multithreading. In Proc. the 29th Annual International Sympo-
sium on Computer Architecture, pages 87–98, May 2002.
[33] C. Weaver et al. Techniques to reduce the soft errors rate in a high-
performance microprocessor. In Proc. of ISCA-31, 2004.
[34] K. C. Yager. The MIPS R10000 superscalar microprocessor. IEEE Micro,
16(2):28–40, April 1996.
[35] J. F. Ziegler et al. IBM experiments in soft fails in computer electronics (1978
IBM Journal of Research and Development, 40(1):3–18, January
- 1994).
1996.