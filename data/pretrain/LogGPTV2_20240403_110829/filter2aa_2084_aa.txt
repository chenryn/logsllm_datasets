The Token Menace
SSO Wars
This Photo by Unknown Author is licensed under CC BY
> whoarewe
§
Alvaro Muñoz
Security Researcher with Micro Focus Fortify team
@Pwntester
§
Oleksandr Mirosh
Security Researcher with Micro Focus Fortify team
@OlekMirosh
Agenda
• Introduction
• Delegated Authentication
• Authentication Tokens
• Arbitrary Constructor Invocation
• Potential attack vectors
• Dupe Key Confusion
• Windows Communication Foundation (WCF)
• Windows Identity Foundation (WIF)
• SharePoint 
• Conclusions
Introduction
This Photo by Unknown Author is licensed under CC BY
Delegated Authentication
Service Provider
Identity Provider
User Agent
1
6
Access protected resource
Redirect to SSO service
Forward Auth token
Redirect to resource
Access resource
Resource
Login into SSO service
Respond with Auth token
2
3
4
5
7
8
Delegated Authentication
Service Provider
Identity Provider
User Agent
1
6
Access protected resource
Redirect to SSO service
Forward Auth token
Redirect to resource
Access resource
Resource
Login into SSO service
Respond with Auth token
2
3
4
5
7
8
Issuer
Audience
Expire Date
Claims
Signature
Delegated Authentication
Service Provider
Identity Provider
User Agent
1
6
Access protected resource
Redirect to SSO service
Forward Auth token
Redirect to resource
Access resource
Resource
Login into SSO service
Respond with Auth token
2
3
4
5
7
8
Issuer
Audience
Expire Date
Claims
Signature
Potential attack vectors
Token parsing vulnerabilities
Normally before signature verification
Attack Token parsing process
Eg: CVE-2019-1083
Signature verification bypasses
The holy grail
Enable us to tamper claims in the token
Eg: CVE-2019-1006
Arbitrary Constructor 
Invocation 
CVE-2019-1083
This Photo by Unknown Author is licensed under CC BY
JWT token
Source: http://jwt.io
System.IdentityModel.Tokens.Jwt library
// System.IdentityModel.Tokens.X509AsymmetricSecurityKey
public override HashAlgorithm GetHashAlgorithmForSignature(string algorithm) {
...
object algorithmFromConfig = CryptoHelper.GetAlgorithmFromConfig(algorithm);
...
}
// System.IdentityModel.CryptoHelper
internal static object GetAlgorithmFromConfig(string algorithm) {
...
obj = CryptoConfig.CreateFromName(algorithm);
...
}
// System.Security.Cryptography.CryptoConfig
public static object CreateFromName(string name, params object[] args) {
...
if (type == null) {
type = Type.GetType(name, false, false);
if (type != null && !type.IsVisible) type = null;
}
...
RuntimeType runtimeType = type as RuntimeType;
...
MethodBase[] array = runtimeType.GetConstructors(BindingFlags.Instance | BindingFlags.Public | 
BindingFlags.CreateInstance);
...
object obj;
RuntimeConstructorInfo runtimeConstructorInfo = Type.DefaultBinder.BindToMethod(BindingFlags.Instance | 
BindingFlags.Public | BindingFlags.CreateInstance, array, ref args, null, null, null, out obj) 
...
object result = runtimeConstructorInfo.Invoke(BindingFlags.Instance | BindingFlags.Public | 
BindingFlags.CreateInstance, Type.DefaultBinder, args, null);
Similar code for SAML
// System.IdentityModel.SignedXml
public void StartSignatureVerification(SecurityKey verificationKey) {
string signatureMethod = this.Signature.SignedInfo.SignatureMethod;
...
using (HashAlgorithm hash = 
asymmetricKey.GetHashAlgorithmForSignature(signatureMethod))
...
...
...
WNKeaE3R....SLMRLfIN/zI=
...
• YAY! We can call public parameterless constructor
• Doesn’t sound too exciting or does it?
• We actually control some data:
• The name of the type to be resolved
• Request’s parameters, cookies, headers, etc.
• In .NET the request is accessed through a static property. E.g.:
// System.Web.Mobile.CookielessData
public CookielessData()
{
string formsCookieName = FormsAuthentication.FormsCookieName;
string text = HttpContext.Current.Request.QueryString[formsCookieName];
...
{
FormsAuthenticationTicket tOld = FormsAuthentication.Decrypt(text);
Potential Attack Vectors (1/2)
• Information Leakage
•
For example: SharePoint server returns different results when Type resolution 
and instantiation was successful or not. These results may enable an attacker to 
collect information about available libraries and products on the target server.
• Denial of Service
• We found gadgets that trigger an Unhandled Exception. They enable an 
attacker to leave SharePoint server unresponsive for a period of time.
Potential Attack Vectors (2/2)
• Arbitrary Code Execution
• We can search for a gadget that installs an insecure assembly resolver on its 
static constructor
• We can then send full-qualified type name (including assembly name) which:
• Not available in the GAC, the system will fall back to resolving it using insecure assembly 
resolver
• Insecure assembly resolver will load the assembly and then instantiate the type
• Downside: 
• May depend on server configurations, e.g. already enabled AssemblyResolvers
• May require ability to upload malicious dll to the server 
// Microsoft.Exchange.Search.Fast.FastManagementClient
static FastManagementClient() {
...
AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(OnAssemblyResolveEvent);
}
// Microsoft.Exchange.Search.Fast.FastManagementClient
private static Assembly OnAssemblyResolveEvent(object sender, ResolveEventArgs args) {
string name = args.Name.Split(new char[]{','})[0];
string path1 = Path.Combine(FastManagementClient.fsisInstallPath, "Installer\\Bin");
string path2 = Path.Combine(FastManagementClient.fsisInstallPath, "HostController");
string[] paths = new string[]   {path1,path2};
for (int i = 0; i 
 … 
…
...
key info elements
Simplified SAML Token
The data to be integrity-checked
Information how to verify signature 
Signature
Key(s) used for signature calculation
Previous vulnerabilities in SAML 
SAML Assertion
• XML Signature Wrapping (XSW):
• Discovered in 2012 by Juraj Somorovsky, Andreas Mayer and others
• Many implementations in different languages were affected
• The attacker needs access to a valid token
• The attacker modifies the contents of the token by injecting malicious data 
without invalidating the signature
• Attacks with XML comments:
• Discovered in 2018 by Kelby Ludwig
• The attacker needs access to a valid token 
• Uses XML comments to modify values without invalidating the signature
SAML Signature Verification in .NET
1.Resolve the signing key
• Obtain key from  or create it from embedded data 
2.Use key to verify signature
3.Identify the signing party 
• Derive SecurityToken from 
4.Authenticate the signing party
• Verify trust on SecurityToken
SAML Signature Verification in .NET
1.Resolve the signing key
• Obtain key from  or create it from embedded data
2.Use key to verify signature
3.Identify the signing party 
• Derive SecurityToken from 
4.Authenticate the signing party
• Verify trust on SecurityToken
• System.IdentityModel.Selectors.SecurityTokenResolver
SecurityTokenResolver
•  section is processed twice by different methods!
• Premise: 
• If we can get each method to return different keys, we may be able to bypass 
validation
A tale of two resolvers
Key Identifier
Clause
Clause
ResolveSecurityKey(kId)