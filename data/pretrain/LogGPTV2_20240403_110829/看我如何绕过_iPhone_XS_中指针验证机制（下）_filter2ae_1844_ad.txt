    TBNZ        W0, #0x1F, loc_FFFFFFF0079B3320
    ORR         X0, X0, #0x80000000                 ;; set bit 31
    ORR         X0, X0, #0x8000000                  ;; set bit 27
    ORR         X0, X0, #0x2000                     ;; set bit 13
    MSR         #0, c1, c0, #0, X0                  ;; SCTLR_EL1
此外，这些位在异常返回时会被有条件地清除
    TBNZ        W1, #2, loc_FFFFFFF0079B3AE8        ;; SPSR_EL1.M[3:0] & 0x4
    ...
    LDR         X2, [X2,#thread.field_460]
    CBZ         X2, loc_FFFFFFF0079B3AE8
    ...
    MRS         X0, #0, c1, c0, #0                  ;; SCTLR_EL1
    AND         X0, X0, #0xFFFFFFFF7FFFFFFF         ;; clear bit 31
    AND         X0, X0, #0xFFFFFFFFF7FFFFFF         ;; clear bit 27
    AND         X0, X0, #0xFFFFFFFFFFFFDFFF         ;; clear bit 13
    MSR         #0, c1, c0, #0, X0                  ;; SCTLR_EL1
虽然 ARM
将这些位记录为保留位(值为0)，但我确实在[osfmk/arm64/proc_reg.h](https://opensource.apple.com/source/xnu/xnu-4903.221.2/osfmk/arm64/proc_reg.h.auto.html)的
XNU 4903.221.2源码中找到了对其中一个位的引用:
    // 13           PACDB_ENABLED            AddPACDB and AuthDB functions enabled
    #define SCTLR_PACDB_ENABLED             (1 );
       extfield = Replicate(ptr, 64);
       if tbi then
           ...
       else
           original_ptr = extfield:ptr;
       PAC = ComputePAC(original_ptr, modifier, K, K);
       // Check pointer authentication code
       if tbi then
           ...
       else
           if ((PAC == ptr) &&
               (PAC == ptr)) then
               result = original_ptr;
           else
               error_code = keynumber:NOT(keynumber);
               result = original_ptr:error_code:original_ptr;
       return result;
同时， 当 PACIZA 为指针添加 PAC 时，它实际上用还原后的扩展位对指针签名，如果扩展位本来无效，则会破坏PAC。
     ext_ptr = extfield:ptr;
    PAC = ComputePAC(ext_ptr, modifier, K, K);
    // Check if the ptr has good extension bits and corrupt the pointer
    // authentication code if not;
    if !IsZero(ptr)
           && !IsOnes(ptr) then
       PAC = NOT(PAC);
重要的是，PAC _指令会通过翻转 PAC 的一个位来破坏具有无效扩展位的指针的PAC。 虽然这肯定会使PAC无效，但这也意味着，如果我们能够读出一个
AUT_ 指令产生的PAC _伪造指针，那么可以重建真正的PAC！  
**_译者注： 在这里这里应该也是指的 PACIZA 会返回一部分合法签名，如果 PACIZA 与 AUTIA
两个返回的部分合法签名对照一下，就可以恢复出全部的合法签名 _*_
因此，即使我们没有一个有效的签名指针，上面那个由 AUTIA 和 PACIZA 组成的序列也可以用作 signing
gadget：我们只需要在伪造的PAC中翻转一个位。
## 一个完整 A 密钥伪造策略
有了基于 PACIZA 的 signing gadget，我们可以开始为A12设备上的 A 密钥构建一个完整的伪造策略。
###  方法 1: 利用 PACIZA 伪造签名
稍微调查一下，发现我们找到的 signing gadget 是函数sysctl_unregister_oid() 的一部分，  
该函数负责从全局 sysctl 树中取消注册 sysctl_oid。  
（再次说明以下，这个函数在公共源代码中没有任何与PAC相关的代码，但这些操作的确存在于启用PAC的设备上。）  
以下是IDA中相关部分的代码：
    void sysctl_unregister_oid(sysctl_oid *oidp)
    {
       sysctl_oid *removed_oidp = NULL;
       sysctl_oid *old_oidp = NULL;
       BOOL have_old_oidp;
       void **handler_field;
       void *handler;
       uint64_t context;
       ...
       if ( !(oidp->oid_kind & 0x400000) )         // Don't enter this if