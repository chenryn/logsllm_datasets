#define COL8_840084 13
#define COL8_008484 14
29
#define COL8_848484 15
/* dsctbl.c */
struct SEGMENT_DESCRIPTOR { /* 5.9, 6.4 */ 30
short limit_low, base_low;
char base_mid, access_right;
char limit_high, base_high;
16
};
struct GATE_DESCRIPTOR { /* 5.9 */
short offset_low, selector;
char dw_count, access_right; 31
short offset_high;
图灵社区会员 metorm 专享 尊重版权
706 …… 第31天：写在开发完成之后
};
void init_gdtidt(void); /* 5.9, 12.1, 20.5, 20.8, 21.5, 21.6, 22.2 */
void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit, int base, int ar); /* 5.9,
6.4 */
void set_gatedesc(struct GATE_DESCRIPTOR *gd, int offset, int selector, int ar); /* 5.9 */
#define ADR_IDT 0x0026f800
#define LIMIT_IDT 0x000007ff
#define ADR_GDT 0x00270000
#define LIMIT_GDT 0x0000ffff
#define ADR_BOTPAK 0x00280000
#define LIMIT_BOTPAK 0x0007ffff
#define AR_DATA32_RW 0x4092
#define AR_CODE32_ER 0x409a
#define AR_LDT 0x0082
#define AR_TSS32 0x0089
#define AR_INTGATE32 0x008e
/* int.c */
void init_pic(void); /* 6.5 */
#define PIC0_ICW1 0x0020
#define PIC0_OCW2 0x0020
#define PIC0_IMR 0x0021
#define PIC0_ICW2 0x0021
#define PIC0_ICW3 0x0021
#define PIC0_ICW4 0x0021
#define PIC1_ICW1 0x00a0
#define PIC1_OCW2 0x00a0
#define PIC1_IMR 0x00a1
#define PIC1_ICW2 0x00a1
#define PIC1_ICW3 0x00a1
#define PIC1_ICW4 0x00a1
/* keyboard.c */
void inthandler21(int *esp); /* 6.6, 7.1, 7.2, 7.3, 7.4, 7.5, 13.4 */
void wait_KBC_sendready(void); /* 7.6 */
void init_keyboard(struct FIFO32 *fifo, int data0); /* 7.6, 13.4 */
#define PORT_KEYDAT 0x0060
#define PORT_KEYCMD 0x0064
/* mouse.c */
struct MOUSE_DEC { /* 8.2, 8.3 */
unsigned char buf[3], phase;
int x, y, btn;
};
void inthandler2c(int *esp); /* 6.6, 7.7 */
void enable_mouse(struct FIFO32 *fifo, int data0, struct MOUSE_DEC *mdec); /* 7.6, 8.2, 13.4 */
int mouse_decode(struct MOUSE_DEC *mdec, unsigned char dat); /* 8.2, 8.3 */
/* memory.c */
#define MEMMAN_FREES 4090 /* 约32KB */
#define MEMMAN_ADDR 0x003c0000
struct FREEINFO { /* 剩余容量信息 */ /* 9.4 */
unsigned int addr, size;
};
图灵社区会员 metorm 专享 尊重版权
9 附录 …… 707
struct MEMMAN { /*内存管理*/ /* 9.4 */
1
int frees, maxfrees, lostsize, losts;
struct FREEINFO free[MEMMAN_FREES];
};
unsigned int memtest(unsigned int start, unsigned int end); /* 9.2 */ 18
void memman_init(struct MEMMAN *man); /* 9.4 */
unsigned int memman_total(struct MEMMAN *man); /* 9.4 */
unsigned int memman_alloc(struct MEMMAN *man, unsigned int size); /* 9.4 */ 3
int memman_free(struct MEMMAN *man, unsigned int addr, unsigned int size); /* 9.4 */
unsigned int memman_alloc_4k(struct MEMMAN *man, unsigned int size); /* 10.1 */
int memman_free_4k(struct MEMMAN *man, unsigned int addr, unsigned int size); /* 10.1 */
20
/* sheet.c */
#define MAX_SHEETS 256
struct SHEET { /* 10.2, 11.3, 23.8 */ 21
unsigned char *buf;
int bxsize, bysize, vx0, vy0, col_inv, height, flags;
struct SHTCTL *ctl;
22
struct TASK *task;
};
struct SHTCTL { /* 10.2, 11.8 */
unsigned char *vram, *map; 7
int xsize, ysize, top;
struct SHEET *sheets[MAX_SHEETS];
struct SHEET sheets0[MAX_SHEETS];
8
};
struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize);
/* 10.2, 11.3, 11.8 */
struct SHEET *sheet_alloc(struct SHTCTL *ctl); /* 10.2, 23.8 */ 9
void sheet_setbuf(struct SHEET *sht, unsigned char *buf, int xsize, int ysize, int col_inv);
/* 10.2 */
void sheet_updown(struct SHEET *sht, int height); /* 10.2, 11.3, 11.7, 11.8 */ 26
void sheet_refresh(struct SHEET *sht, int bx0, int by0, int bx1, int by1); /* 10.2, 10.3, 11.3,
11.7, 11.8 */
void sheet_slide(struct SHEET *sht, int vx0, int vy0); /* 10.2, 10.3, 11.3, 11.7, 11.8 */
void sheet_free(struct SHEET *sht); /* 10.2, 11.3 */ 27
/* timer.c */
#define MAX_TIMER 500 28
struct TIMER { /* 12.4, 13.4, 13.5, 24.8 */
struct TIMER *next;
unsigned int timeout;
29
char flags, flags2;
struct FIFO32 *fifo;
int data;
}; 30
struct TIMERCTL { /* 12.2, 12.3, 12.4, 12.6, 12.7, 13.5 */
unsigned int count, next;
struct TIMER *t0;
16
struct TIMER timers0[MAX_TIMER];
};
extern struct TIMERCTL timerctl;
void init_pit(void); /* 12.1, 12.2, 12.3, 12.4, 12.6, 12.7, 13.6 */ 31
struct TIMER *timer_alloc(void); /* 12.4, 12.7, 24.8 */
图灵社区会员 metorm 专享 尊重版权
708 …… 第31天：写在开发完成之后
void timer_free(struct TIMER *timer); /* 12.4 */
void timer_init(struct TIMER *timer, struct FIFO32 *fifo, int data); /* 12.4, 13.4 */
void timer_settime(struct TIMER *timer, unsigned int timeout); /* 12.4, 12.5, 12.6, 12.7, 13.5,
13.6 */
void inthandler20(int *esp); /* 12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 13.4, 13.5, 13.6, 15.7 */
int timer_cancel(struct TIMER *timer); /* 24.8 */
void timer_cancelall(struct FIFO32 *fifo); /* 24.8 */
/* mtask.c */
#define MAX_TASKS 1000 /* 最大任务数量 */
#define TASK_GDT0 3 /* TSS从GDT的几号开始分配 */
#define MAX_TASKS_LV 100
#define MAX_TASKLEVELS 10
struct TSS32 { /* 15.1, 16.1 */
int backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3;
int eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;
int es, cs, ss, ds, fs, gs;
int ldtr, iomap;
};
struct TASK { /* 16.1, 16.4, 16.5, 17.4, 25.6, 26.7, 27.4, 28.3, 28.4, 28.5, 28.6 */
int sel, flags; /* sel代表GDT编号*/
int level, priority;
struct FIFO32 fifo;
struct TSS32 tss;
struct SEGMENT_DESCRIPTOR ldt[2];
struct CONSOLE *cons;
int ds_base, cons_stack;
struct FILEHANDLE *fhandle;
int *fat;
char *cmdline;
unsigned char langmode, langbyte1;
};
struct TASKLEVEL { /* 16.5 */
int running; /*活动的任务数量*/
int now; /*保存当前活动任务的变量*/
struct TASK *tasks[MAX_TASKS_LV];
};
struct TASKCTL { /* 16.1, 16.5 */
int now_lv; /*当前活动的层级 */
char lv_change; /* 下次切换任务时是否需要改变层级 */
struct TASKLEVEL level[MAX_TASKLEVELS];
struct TASK tasks0[MAX_TASKS];
};
extern struct TASKCTL *taskctl;
extern struct TIMER *task_timer;
struct TASK *task_now(void); /* 16.5 */
struct TASK *task_init(struct MEMMAN *memman); /* 16.1, 16.4, 16.5, 17.1, 27.4 */
struct TASK *task_alloc(void); /* 16.1, 22.3, 27.4 */
void task_run(struct TASK *task, int level, int priority); /* 16.1, 16.4, 16.5 */
void task_switch(void); /* 16.1, 16.4, 16.5 */
void task_sleep(struct TASK *task); /* 16.2, 16.5 */
/* window.c */
图灵社区会员 metorm 专享 尊重版权
9 附录 …… 709
void make_window8(unsigned char *buf, int xsize, int ysize, char *title, char act); /* 11.4, 16.3,
1
17.3 */
void putfonts8_asc_sht(struct SHEET *sht, int x, int y, int c, int b, char *s, int l); /* 13.1,
29.1 */
void make_textbox8(struct SHEET *sht, int x0, int y0, int sx, int sy, int c); /* 14.6 */ 18
void make_wtitle8(unsigned char *buf, int xsize, char *title, char act); /* 17.3 */
void change_wtitle8(struct SHEET *sht, char act); /* 24.5 */
3
/* console.c */
struct CONSOLE { /* 20.1, 23.6 */
struct SHEET *sht;
20
int cur_x, cur_y, cur_c;
struct TIMER *timer;
};
struct FILEHANDLE { /* 28.3 */ 21
char *buf;
int size;
int pos;
22
};
void console_task(struct SHEET *sheet, int memtotal);
/* 17.2, 17.4, 18.2, 18.3, 18.4, 18.5, 18.6, 18.7, 19.1, 19.2, 19.3,
19.5, 20.1, 20.2, 25.6, 25.10, 26.8, 26.10, 27.2, 28.3, 28.4, 28.5, 28.6 */ 7
void cons_putchar(struct CONSOLE *cons, int chr, char move); /* 20.1, 26.10 */
void cons_newline(struct CONSOLE *cons); /* 20.1, 26.10, 28.6 */
void cons_putstr0(struct CONSOLE *cons, char *s); /* 20.8 */
8
void cons_putstr1(struct CONSOLE *cons, char *s, int l); /* 20.8 */
void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, int memtotal);
/* 20.1, 20.6, 20.8, 26.7, 26.9, 26.10, 28.5 */
void cmd_mem(struct CONSOLE *cons, int memtotal); /* 20.1, 20.8 */ 9
void cmd_cls(struct CONSOLE *cons); /* 20.1 */
void cmd_dir(struct CONSOLE *cons); /* 20.1, 20.8 */
void cmd_exit(struct CONSOLE *cons, int *fat); /* 26.7, 26.10 */ 26
void cmd_start(struct CONSOLE *cons, char *cmdline, int memtotal); /* 26.9 */
void cmd_ncst(struct CONSOLE *cons, char *cmdline, int memtotal); /* 26.10 */
void cmd_langmode(struct CONSOLE *cons, char *cmdline); /* 28.5, 28.7 */
int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline); 27
/* 20.6, 21.1, 21.2, 21.4, 21.6, 22.4, 23.8, 24.5, 24.8, 25.6, 25.7, 27.4, 28.3, 28.6, 29.2 */
int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax);
/* 21.6, 22.1, 22.4, 22.5, 22.6, 23.1, 23.2, 23.3, 23.4, 23.5, 23.6, 23.8, 28
24.5, 24.7, 24.8, 25.1, 25.4, 25.6, 26.2, 27.2, 28.3, 28.4, 28.7, 29.2, 29.5 */
int *inthandler0d(int *esp); /* 21.6, 22.2, 25.6 */
int *inthandler0c(int *esp); /* 22.2, 25.6 */
29
void hrb_api_linewin(struct SHEET *sht, int x0, int y0, int x1, int y1, int col); /* 23.4 */
/* file.c */
struct FILEINFO { /* 18.7, 19.1 */ 30
unsigned char name[8], ext[3], type;
char reserve[10];
unsigned short time, date, clustno;
16
unsigned int size;
};
void file_readfat(int *fat, unsigned char *img); /* 19.3 */
void file_loadfile(int clustno, int size, char *buf, int *fat, char *img); /* 19.3 */ 31
struct FILEINFO *file_search(char *name, struct FILEINFO *finfo, int max); /* 20.1 */
图灵社区会员 metorm 专享 尊重版权
710 …… 第31天：写在开发完成之后
char *file_loadfile2(int clustno, int *psize, int *fat); /* 29.2 */
/* tek.c */
int tek_getsize(unsigned char *p); /* 29.2 */
int tek_decomp(unsigned char *p, char *q, int size); /* 29.2 */
/* bootpack.c */
struct TASK *open_constask(struct SHEET *sht, unsigned int memtotal); /* 26.10 */
struct SHEET *open_console(struct SHTCTL *shtctl, unsigned int memtotal); /* 26.5, 26.7, 26.10 */
■■■■■
apilib.h
void api_putchar(int c); /* 21.2, 21.6, 27.5 */
void api_putstr0(char *s); /* 22.4, 27.5 */
void api_putstr1(char *s, int l); /* 27.5 */
void api_end(void); /* 21.6 */
int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title); /* 22.5 */
void api_putstrwin(int win, int x, int y, int col, int len, char *str); /* 22.6 */
void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col); /* 22.6 */
void api_initmalloc(void); /* 23.1 */
char *api_malloc(int size); /* 23.1 */
void api_free(char *addr, int size); /* 23.1 */
void api_point(int win, int x, int y, int col); /* 23.2 */
void api_refreshwin(int win, int x0, int y0, int x1, int y1); /* 23.3 */
void api_linewin(int win, int x0, int y0, int x1, int y1, int col); /* 23.4 */
void api_closewin(int win); /* 23.5 */
int api_getkey(int mode); /* 23.6 */
int api_alloctimer(void); /* 24.7 */
void api_inittimer(int timer, int data); /* 24.7 */
void api_settimer(int timer, int time); /* 24.7 */
void api_freetimer(int timer); /* 24.7 */
void api_beep(int tone); /* 25.1 */
int api_fopen(char *fname); /* 28.3 */
void api_fclose(int fhandle); /* 28.3 */
void api_fseek(int fhandle, int offset, int mode); /* 28.3 */
int api_fsize(int fhandle, int mode); /* 28.3 */
int api_fread(char *buf, int maxsize, int fhandle); /* 28.3 */
int api_cmdline(char *buf, int maxsize); /* 28.4 */
int api_getlang(void); /* 28.7 */
图灵社区会员 metorm 专享 尊重版权
图灵社区会员 metorm 专享 尊重版权