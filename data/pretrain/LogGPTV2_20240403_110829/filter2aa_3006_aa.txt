Page 1 of 1                                 © 2003 Airscanner™ Corp. http://www.Airscanner.com 
Embedded Reverse Engineering: 
Cracking Mobile Binaries 
1. Overview 
Reverse-engineering has long been one of the most popular trouble shooting techniques. 
In fact, long before the first hacker ever laid eyes on a computer screen, technicians, 
engineers, and even hobbyists were busy tearing apart mechanical devices to see if they 
could deduce their seemingly magical operations with the hopes of making it work better, 
or at the very least, hoping they could understanding what made a device tick. Over the 
years, this concept has been passed on to the computer profession, where the concept of 
reverse-engineering evolved into one of the most powerful methods of learning available. 
Ironically, this very useful technique has fallen under attack and is being threatened by 
various nefarious Acts and policy control groups.  
If a computer professional has been in the field for any length of time, they have already 
used reverse-engineering to their benefit. In fact, the open-source community uses 
reverse-engineering as one of their main tools for learning software and figuring out what 
a program does, or in some cases, doesn't do. However, there is one major branch of 
computing that has had little headway in the arena of reverse-engineering. This elusive 
niche is the PocketPC application.  
To help fill this gap, and to increase the awareness of PocketPC reverse-engineering, this 
paper/discussion will provide an overview of what is required, and how one can reverse 
their PocketPC. The following pages will provide an overview of the PocketPC 
environment, the tools required to successfully reverse-engineering Windows CE, and the 
methods by which a person can dig deep inside an application to alter code as they see fit. 
Note, this article/discussion will skirt the borders of many ethical and moral issues. The 
Page 2 of 2                                 © 2003 Airscanner™ Corp. http://www.Airscanner.com 
information in this paper is presented from a researchers point of view for educational 
purposes only. We firmly believe that when a product is purchased, be it a can of soup or 
software program, the owner should be able to do with it as they please, with the arguable 
exception of manipulative EULA in which the software is rented. Please note, the 
 information presented is not meant to promote the theft of software.  
2. Windows CE Architecture 
Windows CE is the operating system of choice for most pocket PC devices. As such, it is 
important to understand the basics of how this operating system works to become 
proficient at reverse engineering on the PPC platform. This segment of the paper will 
outline the particulars of Windows CE, and what it means to you when researching the 
characteristics of a program. Note, this segment will only briefly cover the Windows CE 
architecture, with some deeper looks at sections important to understand when reverse-
engineering a program. For more information about this subject, the Microsoft.com 
provides a wealth of information. Please note that much of this information can be 
applied to any Windows OS; therefore, please feel free to jump ahead if you are familiar 
with this subject. 
2.1 Processors 
In this world of miniature gadgets, only so much is possible. Physical properties often 
determine how far technology can go. In the case of the pocket PC's this is also true. Heat 
generated by high-speed processors in notebook PC's have been known to burn people 
and even has provided enough heat to fry eggs. If the same processor were used in a 
pocket PC, a user would have to wear hot pads to operate just to hold it. 
As a result, Windows CE devices are limited in their choice of processors. The following 
is the list of processors supported by Windows CE. 
ARM: Supported processors include ARM720T, ARM920T, ARM1020T, 
StrongARM, XScale  
MIPS: Supported processors include MIPS II/32 w/FP, MIPS II/32 w/o FP, 
MIPS16, MIPS IV/64 w/FP, MIPS IV/64 w/o FP  
SHx: Supported processors include SH-3, SH-3 DSP, SH-4  
x86: Supported processors include 486, 586, Geode, Pentium I/II/III/IV  
If heat dissipation is a serious issue, the best choice is one of the non-x86 processors that 
use a reduced level of power. The reduction in power consumption will reduce the 
amount of heat that is created during processor operation, but also limits the processor 
speed.  
2.2 Kernel, Processes, and Threads 
The follow section will describe the core of the Windows CE operating system, and how 
it processes information.  
Page 3 of 3                                 © 2003 Airscanner™ Corp. http://www.Airscanner.com 
2.2.1 Kernel 
The kernel is the key component of a Windows CE device. It handles all the core 
functions of the OS, such as process, thread and memory management. In addition, it also 
handles scheduling and interrupt handling. However, it is important to understand that 
Windows CE used parts of the desktop Windows software. This means it has a similar 
threading, processing, and virtual memory model as the other Windows OSes.  
While the similarities are undeniable, there are several items that make this OS a 
completely different beast. These center on the use of memory and the simple fact that 
there is no hard drive (discussed later in the Memory Architecture section). In addition, 
DLLs in Windows CE are not implemented as they are in other Windows operating 
systems. Instead, they are used in such a way as to maximize the amount of available 
memory. By integrating them into the core operating system, DLLs don't take up precious 
space when they are executed. This is an important concept to understand before 
attempting to RVE a program in Windows CE. Due to this small difference, attempting to 
break a program while it is executing a system DLL is not allowed by Microsoft's EVT 
(MVT).  
2.2.2 Processes 
A process in Windows CE represents an executing program. The number of processes is 
limited to 32, but each process can execute a theoretically unlimited number of threads. 
Each thread has a 64k memory block assigned to it, an ID, and a set of registers. It is 
important to understand this concept because when debugging a program, you will be 
monitoring the execution of a particular thread, its registers, and the allotted memory 
space. By doing this, you will be able to deduce hidden passwords, serial numbers, and 
more. 
Processes can run in two modes; kernel and user. A kernel process has direct access to 
the OS and the hardware. This gives it more power, but a crash in a kernel process will 
often crash the whole OS. A user process, on the other hand, operates outside the kernel 
memory, but a crash will only kill the running program, not the whole OS. In Windows 
CE, any 3rd party program will operate in user mode, which means it is protected. In other 
words, if you crash a program while RVEing it, the whole OS wont crash (though you 
still may need to soft boot the device).  
There are two other points that should be understood. First, one process cannot affect 
another processes data. While related threads can interact with each other, a process is 
restricted to its own memory slot. The second point to remember is that each existing 
thread is continuously being stopped and restarted by a scheduler (discussed next). This is 
how multitasking is actually performed. While it may appear that more than one program 
is running at a time, the truth remains that only one thread may execute at any one time.  
2.3 Scheduler 
Page 4 of 4                                 © 2003 Airscanner™ Corp. http://www.Airscanner.com 
The Scheduler is responsible for managing the thread process time. It does this by giving 
each thread a chance to use the processor. By continuously moving from thread to thread, 
the scheduler ensures that each gets a turn. Built into the scheduler are three important 
features that are important to understand. 
The first feature is a method that is used to increase the amount of processor time. The 
secret is found in multi-threading an application. Since the Scheduler assigns processor 
time at the thread level, a process with 10 threads will get ten times the processor time 
than a process with one thread.  
Another method in gaining more processor time is to increase the process priority. 
However, this is not encouraged unless necessary. Changing priority levels can cause 
serious problems in other programs, and will affect the speed of the computer as a whole. 
One priority that needs to be mentioned is the THREAD_PRIORITY_TIME_CRITICAL 
priority that forces the processor to complete the critical thread until it is complete.  
The final interesting fact deals with a problem that can arise when priority threading is 
used. If a low priority thread is executing and it ties up a resource needed by a higher 
priority thread, the system could become instable. In short, this creates a paradox where 
the high thread will wait for the low thread to finish, which is in turn waiting on the high 
to complete. To prevent this from occurring, the scheduler will detect such a paradox and 
boost the lower priorities thread to a higher level allowing it to finish. 
2.4 Memory Architecture 
One of the most obvious properties of a device running Windows CE is that it doesn't 
have a hard drive. Instead of spinning disks, pocket PC's use old fashion RAM (Random 
Access Memory) and ROM (Read Only Memory) to store data. While this may seem like 
a step back in technology, the use of static memory, like ROM, is on the rise and will 
eventually make moving storage devices obsolete. The next few paragraphs will explain 
how memory is used in a Windows CE device to facilitate program execution and use.  
In a Windows CE device, the entire operating system is stored in ROM. This type of 
memory is typically only read from and is not used to store temporary data that can be 
deleted. On the other hand, data in RAM is constantly being updated and changed. This 
memory is used to hold all files and programs that are loaded into the Windows CE-based 
device, as well as the registry and various data files required by CE applications.  
RAM not only stores data, but it is also used to execute programs. When a 3rd party 
program is executed, it is first uncompressed, then copied into another part of RAM, and 
executed from there. This is why having a surplus of RAM is important in a Windows CE 
device. However, the real importance of RAM is found in the fact that its data can be 
written to and accessed by an address. This is necessary because a program will often 
have to move data around. Since a program is allotted a section of RAM to run in when it 
is executed, it must be able to write directly to its predefined area.  
Page 5 of 5                                 © 2003 Airscanner™ Corp. http://www.Airscanner.com 
While ROM is typically only used as a static storage area, in Windows CE  it can be used 
to execute programs, which is know as Execute In Place (XIP). In other words, RAM 
won't be required to hold the ROMs data as a program executes. This allows RAM to be 
used for other important applications. However, this only works with ROM data that is 
not compressed. While compression will allows more data to be stored in ROM, the 
decompression will force any execution to be done via the RAM.  
RAM in a Windows CE device is split between two functions. The first is object store, 
which is used to hold files/data that is used by the programs, but is not stored in the 
ROM. In particular, the object store holds compressed program/user files, database files 
that hold structured data, and the infamous Windows registry file. Though this data is 
stored in RAM, it remains intact when the device is 'turned off'. This is due to the fact 
that the RAM is kept charged by the power supply, which is why it is very important to 
never ever let the charge on a pocket PC completely die. If this happens, the RAM will 
loose power and will reset. This will then dump all installed programs and will basically 
wipe everything on the device except for what is stored in ROM. This is also referred to 
as a hard boot when dealing with a pocket PC device.  
The second function of the RAM is to facilitate program execution. As previously 
mentioned, when a program is running it needs to store information it is using. This is the 
same function that RAM serves on a typical desktop PC. However, this also means that 
any data passing through a program, such as a password or serial number, will be written 
to the RAM at one time or another.  
Windows CE does have a limit on the RAM size. In Windows CE 3.0 it is 256 MB with a 
32 MB limit on each file, but in Windows CE .NET this value has been increased to a 
rather large 4GB. In addition, there is a limit to the number of files that can be stored in 
RAM of 4,000,000. There are other limits, such as the number of programs that can 
operated at the same time, which brings us to multitasking. 
Windows CE was designed to be a multitasking operating system. Just like other 
Windows operating systems, this is important to allow more than one program to be open 
at a time. In other words, you can listen to an MP3 while taking notes, and checking out 
sites on the Internet. Without multitasking, you would be forced to close one program 
before opening another. However, you must be careful opening to many programs in a 
Windows CE device. Since you are limited by the amount RAM in the device and each 
open program takes up a chunk of the RAM, you can quickly run out of space. 
Finally, the limitation of RAM in a pocket PC also has impacted the choice of operating 
system. Since Windows CE devices only have 32-128 MB of internal RAM, they don't 
make good platforms for operating systems that use a lot of memory, such as Embedded 
Windows XP. In this OS, the minimum footprint for a program is 5MB. On the other 
hand, Windows CE only requires 200k; this is a 2500% difference. When RAM is limited 
by space and pricing considerations, the affects are far reaching. 
Page 6 of 6                                 © 2003 Airscanner™ Corp. http://www.Airscanner.com 
2.5 Graphics, Windowing and Event Subsystem (GWES) 
This part of the Windows CE architecture is responsible for handling all the input (e.g. 
stylus) and output (e.g. screen text and images). Since every program uses windows to 
receive messages, this is a very important and key part of Windows CE. As a result, this 
is also one of the key areas you need to understand to successfully RVE a program. 
Without going into too much detail, you should know that every Windows CE process 
created when a program executes is assigned its own windows messaging queue. This 
queue is similar to a stack of papers, which is added to and read from. This queue is 
created when the program calls GetMessage, which is very common in Windows CE 
programs. While the program executes and interacts with the user, messages are placed 
on and removed from the queue. The following is a list and explanation of the common 
commands that you will see while RVE.  
PostMessage 
Places message on queue of target thread, which is returned immediately to the 
process/thread. 
SendMessage 
Places message on queue, but does not return until it is processed. 
|SendThreadMessage 
Sends messages directly to thread instead of the queue 
These Message commands, and others, act as virtual flares when RVE a program. For 
example, if a “Sorry, wrong serial number” warning is flashed to the screen, you can bet 
that some Message command is used. Therefore, by looking for the use of this command 
in a disassembler, you can find the part of the program that needs further research.  
2.6 Summary 
The last few pages have given you an inside look at how Windows CE operates. This 
information is required reading for the rest of this paper. In fact, by understanding how a 
processor deals with threads, the memory architecture, and how Windows CE uses 
messages to communicate with the executing program, you will have an easier time 
understanding how RVE works. Just as a doctor must understand the human body before 
troubleshooting even a head ache, a RVE must understand the platform they are 
dissecting if they going to be successful at making at patch or deciphering a serial 
number. 
3 Reverse Engineering Fundamentals 
3.1 Overview 
When a developer writes a program, they typically use one of several languages. These 
typically include Visual Basic, C++, Java or any one of the other lesser used languages. 
Page 7 of 7                                 © 2003 Airscanner™ Corp. http://www.Airscanner.com 
The choice of language depends on several factors. The most common being space and 
speed considerations. In the infamously bloated Windows environment, Visual Basic is 
arguable the king. This is because the hardware required to run Windows is usually more 
than enough to run any Visual Basic application. However, if the programmer needs a 
higher level of speed and power, they will probably select C++. 
While these upper level languages make programming easier by providing a whole 
selection of Application Program Interfaces (API) and commands that are easy to 
understand, there are many occasions where a programmer must create a program that 
can fit in a very small amount of memory, and operate extremely quickly. To meet this 
goal, they will choose to use a language known as Assembler. This low level language 
allows a coder to write directly to the processor, thus controlling the hardware of the 
computer directly. However, programming in assembler is very tedious and must be done 
within a very explicit set of rules. 
As we have hinted, programming languages exist on several different levels. The lowest 
level languages speak right to the hardware, and typically require little in the way of 
conversion. On the other hand, upper level languages like VB and SQL are often easy to 
write. However, these languages must be compiled one or more times before the 
instructions can be understood by the hardware responsible for executing it. In fact, many 
of these upper level languages don't really have any way of controlling hardware, but 
must make calls to other files and programs that can make hardware calls in proxy. 
Without going to deep into the nuances of programming languages, the point of this 
discussion is to ensure that you understand that almost every program will end up as 
assembler code. Due to this, if you really want to have control over a computer and the 
programs on the computer, you must understand assembler code. Since each and every 
processor type uses its own set of assembler instruction, you need to focus on one device 
(i.e. one processor type) and become fluent in the operation codes (opcodes), instruction 
sets, processor design, and how the processor uses internal memory to read and write to 
RAM. It is only after you have mastered the basics of the processor operation that you 
can start to reverse-engineer a program. Fortunately, most processors operate very similar 
to each other, with slight variations in syntax and use of internal processor memory. 