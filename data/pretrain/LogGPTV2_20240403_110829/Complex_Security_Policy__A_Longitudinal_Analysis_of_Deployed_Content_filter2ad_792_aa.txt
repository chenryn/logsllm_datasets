title:Complex Security Policy? A Longitudinal Analysis of Deployed Content
Security Policies
author:Sebastian Roth and
Timothy Barron and
Stefano Calzavara and
Nick Nikiforakis and
Ben Stock
Complex Security Policy? A Longitudinal Analysis
of Deployed Content Security Policies
Sebastian Roth∗, Timothy Barron†, Stefano Calzavara‡, Nick Nikiforakis†, and Ben Stock∗
∗CISPA Helmholtz Center for Information Security: {sebastian.roth,stock}@cispa.saarland
† Stony Brook University: {tbarron,nick}@cs.stonybrook.edu
‡ Universit`a Ca’ Foscari Venezia: PI:EMAIL
Abstract—The Content Security Policy (CSP) mechanism was
developed as a mitigation against script injection attacks in
2010. In this paper, we leverage the unique vantage point of
the Internet Archive to conduct a historical and longitudinal
analysis of how CSP deployment has evolved for a set of 10,000
highly ranked domains. In doing so, we document the long-
term struggle site operators face when trying to roll out CSP
for content restriction and highlight that even seemingly secure
whitelists can be bypassed through expired or typo domains. Next
to these new insights, we also shed light on the usage of CSP
for other use cases, in particular, TLS enforcement and framing
control. Here, we ﬁnd that CSP can be easily deployed to ﬁt
those security scenarios, but both lack wide-spread adoption.
Speciﬁcally, while the underspeciﬁed and thus inconsistently
implemented X-Frame-Options header is increasingly used on
the Web, CSP’s well-speciﬁed and secure alternative cannot keep
up. To understand the reasons behind this, we run a notiﬁcation
campaign and subsequent survey, concluding that operators have
often experienced the complexity of CSP (and given up), utterly
unaware of the easy-to-deploy components of CSP. Hence, we ﬁnd
the complexity of secure, yet functional content restriction gives
CSP a bad reputation, resulting in operators not leveraging its
potential to secure a site against the non-original attack vectors.
I.
INTRODUCTION
Given the complexity of modern Web applications and the
number of different attacks that Web sites and their users can
be exposed to, browser vendors have long supported a wide
range of additional opt-in security mechanisms (with more
being adopted regularly). These mechanisms attempt to protect
the conﬁdentiality of cookies (e.g., through the secure and
httpOnly ﬂags), to stop malicious sites from framing benign
ones (e.g., through X-Frame-Options), or to ensure users
are protected against SSL stripping attacks (e.g.,
through
HTTP Strict Transport Security). The Content Security Policy
(CSP) is one such mechanism that was introduced in 2010
and was initially designed to grant Web developers more
control over the content loaded by their Web sites [40]. Unlike
other security mechanisms that have a limited number of
conﬁguration options, CSP allows Web developers to author
complex, whitelisting-based policies to precisely specify the
sources that are trusted for a wide range of content including
JavaScript, images, plugins, and fonts.
Network and Distributed Systems Security (NDSS) Symposium 2020
23-26 February 2020, San Diego, CA, USA
ISBN 1-891562-61-4
https://dx.doi.org/10.14722/ndss.2020.23046
www.ndss-symposium.org
Though the (in)effectiveness of CSP has been analyzed and
debated in several research papers [6, 8, 50, 51], CSP is still
under active development and is routinely adopted by more and
more Web sites: the most recent study [8] observed an increase
of one order of magnitude in CSP deployment in the wild
between 2014 and 2016. Notably though, virtually all papers
have focused on CSP as a means to restrict content and have
treated its newly added features (such as TLS enforcement
and framing control) as side notes. To close this research gap
and holistically analyze CSP it is important to take a critical
look at how CSP deployment has evolved over time, so as to
understand for which purposes developers use CSP and how
it affects their sites’ security.
To this end, we leverage the Internet Archive to obtain
the historical CSP headers for 10,000 highly ranked domains
from 2012 to 2018. Leveraging this unique vantage point for
a long-term study, we ﬁrst investigate CSP’s evolution for
content restriction and speciﬁcally highlight numerous case
studies that document the struggle in rolling out a CSP. Among
the insights, we ﬁnd that 56% (251/449) of Web sites that
test CSP for content restriction with report-only, presumably
due to its complexity, refrain from ever enforcing any policy.
Similarly, we ﬁnd numerous examples of sites trying to keep
on top of their whitelists for months, before eventually giving
up. Moreover, we outline the unexpected interactions between
CSP and DNS and discover that over 13% of sites attempting to
control script resources whitelisted domains that have expired,
contain obvious typos, or resolve to private IPs.
Notably though, our longitudinal lens over seven years
allows us to show that CSP’s primary use case is gradually
shifting away from the original goal of content restriction,
with 58% (720/1,233) of Web sites deploying CSP for other
purposes. In particular, we document the increase in adoption
of TLS enforcement and how the security mechanism is used in
practice for utility purposes. Moreover, we ﬁnd that while CSP
is well-equipped to rid the Web of the X-Frame-Options
(XFO) header, many sites still rely on this deprecated header
incapable of providing CSP’s ﬁne-grained framing control. To
understand the reason behind this lack in CSP adoption, we
conduct a notiﬁcation campaign of sites running XFO. Based
on the over 100 responses we received, we ﬁnd that CSP’s full
potential is scarcely documented and the perceived complexity
of CSP shies operators away from even the easy-to-deploy
parts. Furthermore, using an in-depth analysis of violated
policies as well as sites that are either trivially insecure or are
able to sustain a secure policy, we propose CSP extensions to
ease adoption and improve security in practice.
The rest of our paper is structured as follows:
• We leverage the Internet Archive to conduct the longest
study of the CSP mechanism to date (2012–2018), and
discuss how our insights can generalize (Section III).
• We document the evolution of CSP and its use cases
over time, showing its gradual move away from content
restriction to other security goals (Section IV).
• Based on the collected CSPs for content restriction, we
discuss an overlooked attack caused by the interplay of
CSP and DNS, and document the long-term struggles site
operators face in the deployment of CSP (Section V).
• We shed light on the previously dismissed CSP use cases
of TLS enforcement (Section VI) and framing control
(Section VII), and highlight their growing importance.
• To untangle the reasons behind CSP’s failed adoption, we
conduct an in-depth analysis of sites that gave up on CSP,
ran insecure CSPs, and those that managed to run a strict
CSP. Based on this, we identify characteristics which are
blocking sites from CSP deployment (Section VIII).
• Given that the adoption of CSP for framing controls lags
behind the underspeciﬁed XFO header, we conduct a
notiﬁcation of sites at risk, and report on the insights
gathered from the ﬁeld (Section IX).
• Based on the insights gained throughout our analysis, we
highlight how CSP’s evolution has affected its prevalence
and usage, and propose three actionable steps to improve
adoption of CSP (Section X).
II. BACKGROUND ON CSP
Content Security Policy (CSP) is a browser-enforced secu-
rity mechanism ﬁrst proposed in 2010 by Stamm et al. [40].
Its primary purpose was to mitigate the impact of Cross-Site
Scripting (XSS), as well as of other types of content injection
vulnerabilities. However, CSP has undergone several revisions
over the years and evolved to support different use cases.
CSPs can be speciﬁed inside the Content-Security-
Policy header or by including them in  tags inside
an HTML head section. An example CSP is shown in Fig-
ure 1 and used as a running example in this section. Policy
violations can be logged to the URL speciﬁed in the report-
uri/report-to directive (line 5) Alternatively, a Security-
PolicyViolationEvent can be caught by scripts [25]. CSPs sent
using the Content-Security-Policy-Report-Only
header are not enforced by the browser, but their violations are
logged for telemetry. This way, sites can test policies before
their deployment, without affecting their functionality.
A. CSP for Content Restriction
CSP provides directives to bind content types to sets of
source expressions, regular-expression-like constructs used to
represent the Web origins from which resources of a given
type may be included. For example, the policy in Figure 1
whitelists scripts originating from the origin itself (line 1) and
images served from https://b.com (line 2). Resources of
all the other content types can be loaded from any HTTPS
origin, as denoted by the default-src directive (line 3)
whitelisting the entire HTTPS scheme. If a policy lacks both
a t-src directive (for some content type t) and a default-
src directive, content of type t can be loaded from anywhere.
1
2
3
4
5
6
s c r i p t −s r c
img−s r c
d e f a u l t−s r c
frame−a n c e s t o r s h t t p s : / / ∗ . a . com ;
r e p o r t−u r i
upgrade−i n s e c u r e−r e q u e s t s ;
’ s e l f ’ ;
h t t p s : / / b . com ;
h t t p s : ;
h t t p s : / / a . com / csp . php ;
Fig. 1: Example of a Content Security Policy
Our example policy also implicitly forbids the use of in-
line scripts, event handlers, and string-to-code transformations
via eval and its derivatives. These security restrictions can
be relaxed by adding unsafe-inline or unsafe-eval
to the script-src directive (or to default-src when
script-src is missing).
The original CSP design proved to be an inﬂexible security
mechanism, since it required the removal of all the inline
scripts and event handlers to actually provide any security
beneﬁt; hence, its adoption initially lagged behind other secu-
rity headers [51]. To remedy this, the second version of CSP
introduced hashes and nonces to whitelist selected inline script
elements [46]. The former allow one to whitelist inline scripts
matching a given hash, whereas the latter enable execution
of  tags carrying those nonces. However, note that
neither hashes nor nonces allow developers to whitelist event
handlers. For backward compatibility, when nonces or hashes
are present, supporting browsers ignore unsafe-inline.
Since 2016, the third and latest version of CSP further aims
to ease deployment through the strict-dynamic source
expression, used to propagate trust to scripts loaded by other
scripts whitelisted using a valid hash/nonce [47]. In other
words, when strict-dynamic is used in combination with
hashes/nonces, any script with a valid hash/nonce can arbitrar-
ily include additional scripts by programmatically adding script
nodes to the DOM, even when they lack a valid hash/nonce.
B. CSP for TLS Enforcement
A use case not originally intended for CSP is TLS enforce-
ment. While one could already leverage the content restriction
capabilities of CSP to force the use of HTTPS by whitelisting
just HTTPS resources, CSP also introduced new explicit direc-
tives for additional expressiveness. In particular, CSP was ex-
tended to better integrate with the Mixed Content speciﬁcation,
a security policy implemented by all modern browsers which
regulates the use of HTTP resources in HTTPS pages [53].
In particular, modern browsers will refuse to load active
content like scripts over such downgraded connections, but
for passive content, e.g., images, blocking is at the browser’s
discretion. A site can be explicit in forbidding such resources
by using the block-all-mixed-content directive in its
CSP. This effectively instructs browsers to block all mixed
content. Instead of blocking all mixed content, the upgrade-
insecure-requests directive (shown in Figure 1, line 6)
forces the automatic rewriting of all HTTP URLs to HTTPS
upon page loading. This is useful to gracefully implement a
transition from HTTP to HTTPS, while preventing warnings
and breakage due to the use of mixed content.
C. CSP for Framing Control
Moreover, CSP introduced the frame-ancestors di-
rective for framing control, thus providing protection against
2
framing-based attacks like click-jacking [30]. It was intended
to replace the traditional X-Frame-Options header (XFO)
with a more ﬂexible whitelisting mechanism, as well as to
patch underspeciﬁed points of XFO [36]. In particular, XFO
just supports three types of policies: DENY prevents all fram-
ing, SAMEORIGIN restricts framing to the same origin as
the framed page, and ALLOW-FROM u restricts framing to a
single URL u. Note that ALLOW-FROM is not even supported
by all browsers (in particular Chrome and Safari), thus making
XFO particularly problematic [22]. CSP,
instead, may be
used to allow framing from a list of arbitrarily many Web
origins speciﬁed through source expressions. Moreover, the
CSP speciﬁcation mandates that the security enforcement must
be done against the full chain of ancestors of the framed page.
In contrast, XFO delegates the choice to browser vendors.
This enables double framing attacks on browsers which only
compare the origin against the top frame, such as IE and
Edge [30]. As an example of the beneﬁts of CSP over XFO in
terms of framing control, the policy in Figure 1 allows framing
by any subdomain of a.com over HTTPS (line 4), which
cannot be expressed using XFO. Moreover, it ensures that in
case of multiple nested frames, all frames must originate from
subdomains of a.com in order for the content to be shown.
III. ANALYSIS METHODOLOGY
Contrary to prior work that mostly quantiﬁed the insecurity
of CSP with respect to XSS mitigation, our main focus is to
investigate how CSP’s changing role affected its deployment.
To this end, the Internet Archive (IA) [17] provides a glimpse
into the past since, starting from 1996, it archives both content
and headers of popular Web sites and makes the information
publicly available. Here, we describe how we arrive at a
representative dataset of 10,000 popular sites, followed by how
we crawl the IA for data related to CSP’s evolution.
A. Dataset Construction
Since widespread support for CSP landed in browsers in
2012 [9], we focus on analyzing the deployment and usage of
CSP from 2012 to the end of 2018. However, merely using a
current list of highly-ranked domains does not sufﬁce, as many
domains may not have been registered (let alone be popular)
during the entire period of our study. Moreover, the reliability
of lists such as Alexa was recently challenged for exhibiting
massive ﬂuctuations on a day-to-day basis [37]. Therefore, we
used the following selection strategy for sites: using Alexa lists
collected over time [37], for each month between January 2012
and December 2018 we extracted the set of sites that were in
the top 50,000 on at least a single day within that month. We
then calculated the intersection of these monthly sets, sorting
the sites by their average rank (over the entire time).
To limit the overall number of queries to the IA, we opted
to study the 10,000 most proliﬁc sites for the given timeframe.
To arrive at this set [2], for each entry in the sorted list
of sites, we queried the IA to determine if it contained any
archived version of the site. This check is necessary since the
IA removes any previously stored content when a site blocks
the IA crawler through robots.txt [20, 41]. To understand
potential biases towards any period within the seven years,
for each month we computed the average top 10,000 sites,
and compared them to the list we ﬁnally chose. This showed
that at least 4,960 and at most 6,199 entries overlapped for
any given month, averaging at 5,738 domains. Hence, we
argue our dataset is well-balanced, allowing us to draw general
conclusions on the evolution of deployed CSPs over time.
Given this set of sites, we queried the IA for their daily
snapshots from January 1, 2012, until December 31, 2018.
Selecting one snapshot per day (where available), we fol-
lowed any HTTP redirection to reach the ﬁnal landing page
for users accessing the site at archival time. Note that we
only used HEAD requests to reduce the load on the IA.
Once all redirects were followed, we compared the orig-
inally visited site to the ﬁnal URL. In total, we queried
the IA for 10,414,975 snapshots, out of which 10,316,325
yielded ﬁnal URLs still on the same site. For each of the
same-site snapshots, we collected all variants of CSP head-
ers historically used (i.e., Content-Security-Policy,
X-Content-Security-Policy, X-WebKit-CSP, and
Content-Security-Policy-Report-Only), as well
as XFO and Strict-Transport-Security. The IA
preﬁxes archived headers with X- Archive-Orig-, making