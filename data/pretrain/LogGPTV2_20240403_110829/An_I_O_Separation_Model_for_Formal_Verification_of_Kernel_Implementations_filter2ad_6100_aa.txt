title:An I/O Separation Model for Formal Verification of Kernel Implementations
author:Miao Yu and
Virgil D. Gligor and
Limin Jia
1
0
1
0
0
.
1
2
0
2
.
1
0
0
0
4
P
S
/
9
0
1
1
.
0
1
:
I
O
D
|
E
E
E
I
1
2
0
2
©
0
0
.
1
3
$
/
1
2
/
5
-
4
3
9
8
-
1
8
2
7
-
1
-
8
7
9
|
)
P
S
(
y
c
a
v
i
r
P
d
n
a
y
t
i
r
u
c
e
S
n
o
m
u
i
s
o
p
m
y
S
E
E
E
I
1
2
0
2
2021 IEEE Symposium on Security and Privacy (SP)
An I/O Separation Model for Formal Veriﬁcation of
Kernel Implementations
Miao Yu
Virgil Gligor
Limin Jia
ECE Department and CyLab, Carnegie Mellon University
Abstract—Commodity I/O hardware often fails to separate I/O
transfers of isolated OS and applications code. Even when using
the best I/O hardware, commodity systems sometimes trade off
separation assurance for increased performance. Remarkably, de-
vice ﬁrmware need not be malicious. Instead, any malicious driver,
even if isolated in its own execution domain, can manipulate its
device to breach I/O separation. To prevent such vulnerabilities
with high assurance, a formal I/O separation model and its use
in automatic generation of secure I/O kernel code is necessary.
This paper presents a formal I/O separation model, which
deﬁnes a separation policy based on authorization of I/O trans-
fers and is hardware agnostic. The model, its reﬁnement, and
instantiation in the Wimpy kernel design, are formally speciﬁed
and veriﬁed in Dafny. We then specify the kernel implementation
and automatically generate veriﬁed-correct assembly code that
enforces the I/O separation policies. Our formal modeling enables
the discovery of heretofore unknown design and implementation
vulnerabilities of the original Wimpy kernel. Finally, we outline
how the model can be applied to other I/O kernels and conclude
with the key lessons learned.
Index Terms—I/O separation; access control and authoriza-
tion; trustworthy computing; security architectures;
I. INTRODUCTION
An important goal of security architectures is to separate
I/O transfers of isolated applications and retain application
protection from compromised OSes and other applications,
with high assurance. To accomplish this without enlarging
the underlying trusted code base (e.g., without enlarging
micro-kernels, micro-hypervisors, separation kernels), existing
designs rely on dedicated I/O kernels [1], [2], [3], [4]. They de-
privilege device drivers, export them to isolated applications
to separate them from each other, and authorize them to access
only their own devices. This also helps eliminate applications’
exposure to unneeded drivers, and is a major advantage since
driver code continues to comprise a very large portion of
modern OS kernels and accounts for many security ﬂaws.
To ensure that an isolated but malicious driver cannot com-
promise another isolated application by manipulating its own
device, I/O kernels rely on the underlying I/O hardware (e.g.,
I/O controllers and IOMMUs) to enforce the association of an
I/O device with an object of an isolated application/driver and
authorize each I/O transfer. Unfortunately, hardware vendors
have produced commodity hardware that focuses primarily on
improved performance [5], [6], increased connectivity [7], [8],
and lower cost [9], at the expense of ﬁne-grained I/O device as-
sociations with isolated-application/driver objects and transfer
authorization. For example, early PCI buses and more recent
CAN buses allow unauthorized peer-to-peer device transfers,
which can be leveraged by a malicious driver to access device
registers of another isolated application. Other designs can
only associate buses with isolated-application objects and
enforce read-write permissions for buses but not individual
devices. For example, IOMMUs [9], [10] authorize accesses at
the granularity of PCI bus controllers via PCIe-to-PCI bridges
instead of individual PCI devices, again, allowing malicious
drivers to breach isolation. In addition, insecure performance
optimizations, such as deferred IOTLB clearing [11], designed
to counter the signiﬁcant performance degradation caused by
frequent switches between authorized transfers, can also lead
to breaches of application isolation; see Section II.
This shows that
the security guarantees of I/O kernels
are intimately connected to the choice of underlying I/O
hardware: a poor choice often leads to security vulnerabilities.
However, neither a formal model nor a high-assurance design
and implementation of I/O separation exists to date. As a
result, current I/O kernels cannot match the high assurance of
their underlying trusted code base; e.g., micro-kernels, micro-
hypervisors [12], [13], [14], [15] and separation kernels [16],
[17]. This imbalance can lead to isolated-application vulnera-
bilities: a malicious application can exploit ﬂawed I/O transfer
authorization to breach the isolation of other applications1.
Our goal is to formalize I/O separation and develop an
abstract model, which can be used as the blueprint for
high-assurance I/O kernel design and implementations, and
make explicit the assumptions about underlying hardware-
authorization properties. Our model does not preclude hard-
ware designs with inadequate authorization, like PCI, PCIe-
to-PCI bridges or USB host controllers, as they occupy a
large fraction of the marketplace. Instead, it makes explicit
the kernel design and implementation requirements for high
assurance, if such hardware were to be used.
We deﬁne an abstract I/O separation kernel model
in
Dafny [20] (Section IV), after outlining the need for its four-
layer reﬁnement for real system use (Section III). We deﬁne
key components and operations of I/O devices and drivers,
specify transfer authorizations, and formalize two desired
security properties: no transfer across an I/O separation
boundary and no object reuse in on-demand I/O. We prove the
abstract I/O separation model satisﬁes these two properties.
We then deﬁne a concrete I/O model
includes more
detailed notions of separation and I/O transfers (Section V).
that
1 Similar vulnerabilities have already been witnessed when isolated VM ap-
plications rely on isolated drivers [18] to ensure I/O separation. A single driver
could still exploit I/O hardware to bypass device-transfer authorization [19].
© 2021, Miao Yu. Under license to IEEE.
DOI 10.1109/SP40001.2021.00101
572
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:32:26 UTC from IEEE Xplore.  Restrictions apply. 
We construct a mapping to the abstract model and prove the
concrete model sound via reﬁnement. Applying the models
to real I/O kernels, we instantiate the concrete model
to
the Wimpy kernel design [21], and we prove its soundness
via reﬁnement to the concrete model (Section VI). Finally,
we specify and verify the Wimpy kernel implementation in
Vale/Dafny [22] and automatically generate veriﬁed-correct
assembly code that enforces the I/O separation policies—an
unavailable feature of any OS kernel to date (Section VII).
This formal process leads to discovery of vulnerabilities in
the original design (Section VI-B) and code (Section VII-B).
Due to space constraints, the paper focuses on explaining the
high-level concepts. All Dafny and Vale speciﬁcations, from
model to kernel code, and proofs can be downloaded from
https://github.com/superymk/iosep proof/raw/master/proof.zip.
II. COMMON I/O VULNERABILITIES AND THREATS
We review the different ways I/O hardware authorizes
accesses, summarize vulnerabilities caused by inadequate I/O
hardware authorization, and present the threats countered.
A. I/O Transfer Authorization and Separation
An I/O transfer is informally viewed as an ordered associ-
ation of one or more devices to one or more I/O objects of an
isolated application/driver. In the simplest case, the association
is one-to-one; e.g., a USB device can exclusively transfer data
to a buffer of an isolated driver in an application. A single
device can also be associated with objects of several isolated
drivers; e.g., a single GPU device can display output of several
isolated application drivers concurrently. Several devices can
be associated on demand with a single I/O buffer of an isolated
application sequentially shared by several drivers; e.g., several
USB devices. In all cases,
the device-object order of the
association indicates whether the I/O object is read or written.
An I/O transfer is authorized if a driver cannot 1) bypass
or modify its device’s association with the isolated-driver
object, and 2) perform the transfer without the permissions
(i.e., write, read) required by the association order. Failure to
enforce 1) or 2) by inadequate hardware can enable isolated
but malicious drivers to breach I/O separation of isolated
applications. Conversely, high-assurance authorization requires
formal analysis of both 1) and 2).
Note that merely enforcing memory address-space sep-
aration for drivers and applications, while useful [23],
is
insufﬁcient for transfer authorization. For example, on-demand
activation of a device/driver from one isolated application to
another can cause use-after-free violations without breach-
ing address-space separation. Similarly, a peer-to-peer device
transfer crossing different applications can violate their iso-
lation without breaching address space separation. Also, a
malicious driver executing a single instruction that broadcasts
data to the registers of multiple devices can violate application
isolation without breaching address-space separation.
B. Inadequacy of Existing Hardware
Existing hardware that authorizes I/O transfers at different
levels of granularity is summarized in Figure 1.
No 
authorization
• PCI, no ACS
• SMBus
• AHB, no ACS
• early: ASB
Intel
AMD
ARM
IBM
• PCI, no ACS
Non-selective
authorization
• PCIe-to-PCI bridge
with IOMMU
• AXI-to-AHB bridge
with SMMU
• TZ within normal or
within secure world
• PCIe-to-PCI bridge
with IOMMU
External 
buses
• CAN
• I2C
• Firewire (with OHCI)
• USB (with IOMMU)
Selective 
authorization
• PCIe with
IOMMU & ACS
• AXI with SMMU
• TZ normal vs. 
secure world
• PCIe with 
IOMMU/CAPI 
& ACS
Fig. 1. Examples of authorization levels of I/O hardware.






	



	














 




	



