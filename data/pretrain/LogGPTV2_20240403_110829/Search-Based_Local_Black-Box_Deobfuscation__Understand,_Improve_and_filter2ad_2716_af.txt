Performances are similar with 1 s/expr. Syntia, CVC4 and STOKE-
synth find none with 1 h/expr., even on BP1. Actually, Syntia with
12 h/expr. gets only 1/15 success of BP1.
Conclusion. Semantically complex handlers are efficient against
blackbox deobfuscation. While high complexity handlers come with a
cost similar to strong MBA encodings, medium complexity handlers
offer a strong protection at a reasonable cost.
Discussion. Our protection can be bypassed if the attacker focuses
on the good combinations of handlers, rather than on the handlers
themselves. To prevent it, complex handlers can be duplicated (as
in VMProtect, see Section 7.2) to make patterns recognition more
challenging.
t
n
e
l
a
v
i
u
q
E
#
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
0
1 h
10 min
1 min
BP1
BP2
BP3
Figure 7: Xyntia (XyntiaOpt) on BP1,2, 3 ‚Äì varying timeouts
8.3 Merged handlers
We now study another protection, based on conditional expres-
sions and the merging of existing handlers. While block merging is
known for a long time against human reversers, we show that it
is extremely efficient against blackbox attacks. Note that while we
write our merged handlers with explicit if-then-else operators (ITE)
for simplicity, these conditions are not necessarily implemented
with conditional branching (cf. Fig. 8) Hence, we consider that the
attacker sees merged handlers as a unique code fragment.
// if (c == cst ) then h1 (a ,b ,c) else h2 (a ,b ,c);
int32_t res = c - cst ;
res = ( -(( res ^ ( res >> 31) ) - ( res >> 31) ) >> 31) & 1;
return h1 (a , b , c) *(1 - res ) + res * h2 (a , b , c);
Figure 8: Example of a branch-less condition
Datasets. We introduce 5 datasets6 composed of 20 expressions.
Expressions in dataset 1 are built with 1 if-then-else (ITE) exposing 2
basic handlers (among +,‚àí,√ó,‚àß,‚à®, ‚äï); expressions in dataset 2 are
built with 2 nested ITEs exposing 3 basic handlers, etc. Conditions
are equality checks against consecutive constant values (0, 1, 2, etc.).
For example, dataset 2 contains the expression:
ùêºùëá ùê∏(ùëß = 0, ùë• + ùë¶, ùêºùëá ùê∏(ùëß = 1, ùë• ‚àí ùë¶, ùë• √ó ùë¶))
(2)
6Available at : https://github.com/binsec/xyntia
Session 10A: Crypto, Symbols and Obfuscation CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea2523Scenarios. Adding conditionals brings extra challenges (1) the
grammar must be expressive enough to handle conditions; (2) the
sampling phase must be efficient enough to cover all possible be-
haviors. Thus, we consider different scenarios:
Utopian The synthesizer learns expressions over the Mba set of
operators, extended with an ùêºùëá ùê∏(‚òÖ = 0, ‚òÖ, ‚òÖ) operator (Mba+ITE
operator set). Moreover, the sampling is done so that all branches
are traversed the same number of time. This situation, favoring
the attacker, will show that merged handlers are always efficient.
Mba + ITE This situation is more realistic: the attacker does not
know at first glance how to sample. However, its grammar fits
perfectly the expressions to reverse.
Mba + Shifts Here Xyntia does not sample inputs uniformly over
the different behaviors, does not consider ITE operators, but
allows shifts to represent branch-less conditions.
Default. This is the default version of the synthesizer.
In all these scenarios, appropriate constant values are added to
the grammar. For example, to synthesize Eq. (2), 0 and 1 are added.
t
n
e
l
a
v
i
u
q
E
#
20
19
18
17
16
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
0
Xyntia Utopian
Xyntia MBA+ITE
Xyntia MBA+Shifts
Xyntia XyntiaOpt
1
2
3
ITE depth
4
5
Figure 9: Merged handlers: Xyntia (timeout=60s)
Evaluation. Fig. 9 presents Xyntia results on the 5 datasets. As
expected, the Utopian scenario is where Xyntia does best. Still, it
cannot cope with more than 3 nested ITEs. For realistic scenarios,
Xyntia suffers even more. Results for Syntia, CVC4 and STOKE-
synth confirm this result (no solution found for ‚â• 2 nested ITEs).
Note that overhead here is minimal, and depends only on the num-
ber of merged handlers.
Conclusion. Merged handlers are extremely powerful against black-
box synthesis. Even in the ideal sampling scenario, blackbox methods
cannot retrieve the semantics of expressions with more than 3 nested
conditionals ‚Äì while runtime overhead is minimal.
Discussion. Symbolic methods, like symbolic execution, are unhin-
dered by these protections, for they track the succession of handlers
and know which sub parts of merged handlers are executed. To
handle this, our anti-blackbox protections can be combined with
(lightweight) anti-symbolic protections (e.g. [25, 35]).
9 RELATED WORK
Blackbox deobfuscation. Blazytko et al.‚Äôs work [7] has already
been thoroughly discussed. We complete their experimental evalu-
ation, generalize and improve their approach: Xyntia with 1 s/expr.
finds twice more expressions than Syntia with 600 s/expr, some of
which Syntia cannot find within 12h.
White- and greybox deobfuscation. Several recent works lever-
age whitebox symbolic methods for deobfuscation (‚Äúsymbolic deob-
fuscation‚Äù) [5, 10, 22, 28, 30, 36]. Unfortunately, they are sensitive to
code complexity as discussed in Section 7, and efficient countermea-
sures are now available [12, 25, 26, 37] ‚Äì while Xyntia is immune
to them (Section 7.1). David et al. [16] recently proposed QSynth, a
greybox deobfuscation method combining I/O relationship caching
(blackbox) and incremental reasoning along the target expression
(whitebox). Yet, QSynth is sensitive to massive syntactic obfusca-
tion where Xyntia is not (cf. Section 6). Furthermore, QSynth works
on a simple grammar. It is unclear whether its caching technique
would scale to larger grammars like those of Xyntia and Syntia.
Program synthesis. Program synthesis aims at finding a function
from a specification which can be given either formally, in natural
language or as I/O relations ‚Äì the case we are interested in here.
There exist three main families of program synthesis methods [20]:
enumerative, constraint solving and stochastic. Enumerative search
does enumerate all programs starting from the simpler one, pruning
snippets incoherent with the specification and returning the first
code meeting the specification. We compare, in this paper, to one
of such method ‚Äì CVC4 [6], winner of the SyGus ‚Äô19 syntax-guided
synthesis competition [2] ‚Äì and showed that our approach is more
appropriate to deobfuscation. Constraint solving methods [21] on
the other hand encode the skeleton of the target program as a first
order satisfiability problem and use an off-the-shelf SMT solver
to infer an implementation meeting specification. However, it is
less efficient than enumerative and stochastic methods [1]. Finally,
stochastic methods [29] traverse the search space randomly in the
hope of finding a program consistent with a specification. Con-
trary to them, we aim at solving the deobfuscation problem in a
fully blackbox way (not relying on the obfuscated code, nor on an
estimation of the result size).
10 CONCLUSION
Blackbox deobfuscation is a promising recent research area. The
field has been barely explored yet and the pros and cons of such
methods are still unclear. This article deepens the state of search-
based blackbox deobfuscation in three different directions. First,
we define a novel generic framework for search-based blackbox
deobfuscation (encompassing prior works such as Syntia), we iden-
tify that the search space underlying code deobfuscation is too
unstable for simulation-based methods, and advocate the use of
S-metaheuristics. Second, we take advantage of our framework to
carefully design Xyntia, a new search-based blackbox deobfuscator.
Xyntia significantly outperforms Syntia in terms of success rate,
while keeping its good properties ‚Äì especially, Xyntia is completely
immune to the most recent anti-analysis code obfuscation methods.
Finally, we propose the two first protections tailored against search-
based blackbox deobfuscation, completely preventing Xyntia and
Syntia attacks for reasonable cost. We hope that these results will
help better understand search-based deobfuscation, and lead to
further progress in the field.
11 ACKNOWLEDGEMENTS
This research was supported by the Agence National de la Recherche
under grant ANR-20-CE25-0009-TAVA.
Session 10A: Crypto, Symbols and Obfuscation CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea2524REFERENCES
[1] Rajeev Alur, Rastislav Bod√≠k, Garvit Juniwal, Milo M. K. Martin, Mukund
Raghothaman, Sanjit A. Seshia, Rishabh Singh, Armando Solar-Lezama, Emina
Torlak, and Abhishek Udupa. 2013. Syntax-guided synthesis. In Formal Methods
in Computer-Aided Design, FMCAD 2013, Portland, OR, USA, October 20-23, 2013.
IEEE.
[2] Rajeev Alur, Dana Fisman, Saswat Padhi, Rishabh Singh, and Abhishek Udupa.
2019. SyGuS-Comp 2018: Results and Analysis. (2019). http://arxiv.org/abs/1904.
07146
[3] Sebastian Banescu, Christian S. Collberg, Vijay Ganesh, Zack Newsham, and
Alexander Pretschner. 2016. Code obfuscation against symbolic execution attacks.
In Annual Conference on Computer Security Applications, ACSAC 2016.
[4] Boaz Barak, Oded Goldreich, Russell Impagliazzo, Steven Rudich, Amit Sahai,
Salil Vadhan, and Ke Yang. 2012. On the (im) possibility of obfuscating programs.
Journal of the ACM (JACM) (2012).
[5] S√©bastien Bardin, Robin David, and Jean-Yves Marion. 2017. Backward-Bounded
DSE: Targeting Infeasibility Questions on Obfuscated Codes. In 2017 IEEE Sym-
posium on Security and Privacy, SP 2017, San Jose, CA, USA, May 22-26, 2017.
[6] Clark Barrett, Christopher L. Conway, Morgan Deters, Liana Hadarean, Dejan
Jovanovi‚Äôc, Tim King, Andrew Reynolds, and Cesare Tinelli. 2011. CVC4. In
Proceedings of the 23rd International Conference on Computer Aided Verification
(CAV ‚Äô11), Ganesh Gopalakrishnan and Shaz Qadeer (Eds.). Springer.
http:
//www.cs.stanford.edu/~barrett/pubs/BCD+11.pdf
[7] Tim Blazytko, Moritz Contag, Cornelius Aschermann, and Thorsten Holz. 2017.
Syntia: Synthesizing the Semantics of Obfuscated Code. In Usenix Security.
[8] Tim Blazytko, Moritz Contag, Cornelius Aschermann, and Thorsten Holz. 2018.
Syntia: Breaking State-of-the-Art Binary Code Obfuscation via Program Synthesis.
Black Hat Asia (2018).
[9] Cameron B Browne, Edward Powley, Daniel Whitehouse, Simon M Lucas, Peter I
Cowling, Philipp Rohlfshagen, Stephen Tavener, Diego Perez, Spyridon Samoth-
rakis, and Simon Colton. 2012. A survey of monte carlo tree search methods.
IEEE Transactions on Computational Intelligence and AI in games (2012).
[10] David Brumley, Cody Hartwig, Zhenkai Liang, James Newsome, Dawn Xiaodong
Song, and Heng Yin. 2008. Automatically Identifying Trigger-based Behavior in
Malware. In Botnet Detection: Countering the Largest Security Threat. Springer.
[11] C. Collberg, S. Martin, J. Myers, and B. Zimmerman. [n. d.]. The Tigress C
Diversifier/Obfuscator. http://tigress.cs.arizona.edu/
[12] Christian Collberg and Jasvir Nagra. 2009. Surreptitious Software: Obfuscation,
Watermarking, and Tamperproofing for Software Protection.
[13] Christian Collberg, Clark Thomborson, and Douglas Low. 1997. A taxonomy of
obfuscating transformations.
[14] Christian Collberg, Clark Thomborson, and Douglas Low. 1998. Manufacturing
cheap, resilient, and stealthy opaque constructs. In Proceedings of the 25th ACM
SIGPLAN-SIGACT symposium on Principles of programming languages.
[15] Robin David, S√©bastien Bardin, Thanh Dinh Ta, Laurent Mounier, Josselin Feist,
Marie-Laure Potet, and Jean-Yves Marion. 2016. BINSEC/SE: A dynamic sym-
bolic execution toolkit for binary-level analysis. In 2016 IEEE 23rd International
Conference on Software Analysis, Evolution, and Reengineering (SANER). IEEE.
[16] Robin David, Luigi Coniglio, and Mariano Ceccato. 2020. QSynth-A Program
Synthesis based Approach for Binary Code Deobfuscation. In BAR 2020 Workshop.
[17] Leonardo De Moura and Nikolaj Bj√∏rner. 2008. Z3: An efficient SMT solver. In
International conference on Tools and Algorithms for the Construction and Analysis
of Systems. Springer.
[18] Ninon Eyrolles, Louis Goubin, and Marion Videau. 2016. Defeating MBA-based
Obfuscation. In Proceedings of the 2016 ACM Workshop on Software PROtection,
SPRO@CCS 2016, Vienna, Austria, October 24-28, 2016.
[19] Nicolas Falliere, Patrick Fitzgerald, and Eric Chien. 2009. Inside the jaws of trojan.
clampi. Rapport technique, Symantec Corporation (2009).
[20] Sumit Gulwani, Oleksandr Polozov, Rishabh Singh, et al. 2017. Program synthesis.
Foundations and Trends¬Æ in Programming Languages (2017).
[21] Susmit Jha, Sumit Gulwani, Sanjit A Seshia, and Ashish Tiwari. 2010. Oracle-
guided component-based program synthesis. In 2010 ACM/IEEE 32nd International
Conference on Software Engineering. IEEE.
[22] Johannes Kinder. 2012. Towards Static Analysis of Virtualization-Obfuscated
Binaries. In 19th Working Conference on Reverse Engineering, WCRE.
[23] Xavier Leroy, Damien Doligez, Alain Frisch, Jacques Garrigue, Didier R√©my, and
J√©r√¥me Vouillon. 2020. The OCaml system release 4.10. https://caml.inria.fr/pub/
docs/manual-ocaml/
[24] Helena Ramalhinho Louren√ßo, Olivier C Martin, and Thomas St√ºtzle. 2019. Iter-
ated local search: Framework and applications. In Handbook of metaheuristics.
Springer.
[25] Mathilde Ollivier, S√©bastien Bardin, Richard Bonichon, and Jean-Yves Marion.
2019. How to kill symbolic deobfuscation for free (or: unleashing the potential of
path-oriented protections). In Proceedings of the 35th Annual Computer Security
Applications Conference.
[26] Mathilde Ollivier, S√©bastien Bardin, Richard Bonichon, and Jean-Yves Marion.
2019. Obfuscation: where are we in anti-DSE protections?(a first attempt). In
Proceedings of the 9th Workshop on Software Security, Protection, and Reverse
Engineering.
[27] Oreans Technologies. 2020. Themida ‚Äì Advanced Windows Software Protection
System. http://oreans.com/themida.php.
[28] Jonathan Salwan, S√©bastien Bardin, and Marie-Laure Potet. 2018. Symbolic
deobfuscation: from virtualized code back to the original. In 5th Conference on
Detection of Intrusions and malware & Vulnerability Assessment (DIMVA).
[29] Eric Schkufza, Rahul Sharma, and Alex Aiken. 2013. Stochastic superoptimization.
ACM SIGARCH Computer Architecture News (2013).
[30] Sebastian Schrittwieser, Stefan Katzenbeisser, Johannes Kinder, Georg Merz-
dovnik, and Edgar Weippl. 2016. Protecting Software Through Obfuscation: Can
It Keep Pace with Progress in Code Analysis? ACM Comput. Surv. (2016).
[31] Jon Stephens, Babak Yadegari, Christian S. Collberg, Saumya Debray, and Carlos
Scheidegger. 2018. Probabilistic Obfuscation Through Covert Channels. In 2018
IEEE European Symposium on Security and Privacy, EuroS&P 2018.
[32] El-Ghazali Talbi. 2009. Metaheuristics: From Design to Implementation. Wiley
Publishing.
DevirtualizingFinSpy.pdf
[33] Tora. [n. d.]. Devirtualizing FinSpy.
http://linuxch.org/poc2012/Tora,
[34] VM Protect Software. 2020. VMProtect Software Protection. http://vmpsoft.com.
[35] Babak Yadegari and Saumya Debray. 2015. Symbolic Execution of Obfuscated
Code. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Com-
munications Security. Association for Computing Machinery.
[36] Babak Yadegari, Brian Johannesmeyer, Ben Whitely, and Saumya Debray. 2015. A
Generic Approach to Automatic Deobfuscation of Executable Code. In Symposium
on Security and Privacy, SP.
[37] Yongxin Zhou, Alec Main, Yuan X. Gu, and Harold Johnson. 2007. Information
Hiding in Software with Mixed Boolean-arithmetic Transforms. In Proceedings of
the 8th International Conference on Information Security Applications (WISA‚Äô07).
Springer-Verlag.
Session 10A: Crypto, Symbols and Obfuscation CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea2525