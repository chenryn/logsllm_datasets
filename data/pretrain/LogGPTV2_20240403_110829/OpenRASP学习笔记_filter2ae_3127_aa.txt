# OpenRASP学习笔记
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 1.引言
最近看了看OpenRASP（JAVA版），而网上关于OpenRASP已有一些文章，但纸上得来终觉浅，自己阅读一番再另外写篇文章，也还行，算是总结算是笔记。如文中有错误，还望同学们指出，十分感谢。
## 2.阅读前准备工作
一开始还需要将open-rasp安装到Tomcat，这里按照官方文档指引即可。
###  2.1编译
**编译V8引擎**
笔者在这里花了半天时间，一度十分懵逼，不懂C++编译这块的东西，按照官方文档来弄又不得行。
笔者的编译环境
    Debian 4.9.18 (kali)
    OpenJDK 1.8
    gcc version 8.3.0
编译获取v8引擎jar包：
    curl -L  https://github.com/Kitware/CMake/releases/download/v3.15.3/cmake-3.15.3-Linux-x86_64.tar.gz | tar zx -C /tmp
    export PATH=/tmp/cmake-3.15.3-Linux-x86_64/bin:$PATH
    git clone https://github.com/baidu-security/openrasp-v8.git
    ~/openrasp-v8# mkdir -p openrasp-v8/build64 && cd openrasp-v8/build64
    ~/openrasp-v8/openrasp-v8# cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DENABLE_LANGUAGES=java ..
    ~/openrasp-v8/openrasp-v8# make
    ~/openrasp-v8/openrasp-v8# mkdir -p ../java/src/main/resources/natives/linux_64 && cp java/libopenrasp_v8_java.so $_
    ~/openrasp-v8/java# mvn install
**编译项目**
本文使用的是`1.3.4`版本。
Injellij IDEA打开 \openrasp-master\agent\java
Help > Find Action ，输入并打开 `Maven Project`
由于V8是在虚拟机上编译的，不在本地物理机的maven仓库中，需要先将其加入仓库
    mvn install:install-file -Dfile=D:\share\v8-1.0-SNAPSHOT.jar -DgroupId=com.baidu.openrasp -DartifactId=v8 -Dpackaging=jar -Dversion=1.0-SNAPSHOT
编译`rasp-boot`
由于`rasp-engine`依赖`rasp-boot`，所以需要将`rasp-boot`加入到maven仓库中
    mvn install:install-file -Dfile=D:\turn1tup\program_java\RASP\openrasp\agent\java\boot\target\rasp-boot-1.3.4-shaded.jar -DgroupId=com.baidu.openrasp -DartifactId=rasp-boot -Dpackaging=jar -Dversion=1.3.4
同样操作编译`rasp-engine`即可。
**Debug**
Windows下，在Tomcat的catalina.bat的open-rasp配置后添加一行JDWP配置：
    if "%ACTION%" == "start" set JAVA_OPTS="-javaagent:%CATALINA_HOME%\rasp\rasp.jar" %JAVA_OPTS%
    if "%ACTION%" == "start" set JAVA_OPTS=-agentlib:jdwp=transport=dt_socket,address=1043,server=y,suspend=y %JAVA_OPTS%
IDEA中将编译后的JAR包加入到项目Libraries，随后配置远程调试
断点打到程序最开始执行的地方，从最开始的地方看起。
openrasp\agent\java\boot\src\main\java\com\baidu\openrasp\Agent.java
## 3.工作原理
这块技术之前没接触过，笔者翻阅了前辈们写的文章与官方文档，大致了解了一番，这里也简单叙述一下。
###  JVM TI接口
JAVA虚拟机开放了一个叫 JVM Tool Interface (JVM TI) 的接口，通过该接口，对于运行于JVM的程序，我们可以查看和控制。
实现了JVM TI接口的程序，称为agent，agent与jvm运行在同一进程并直接与jvm进行通信。agent能通过三种方式被执行，①Agent
Start-Up (OnLoad phase)：在JAVA程序的main函数执行之前执行agent，java命令中需通过-javaagent参数来指定agent，实现方式为premain ②Agent Start-Up (Live phase)
：对于正在运行的JAVA程序，通过JVM进程间通信，动态加载agent，实现方式为attatch机制 ③Agent
Shutdown：在虚拟机的library 将要被卸载时执行，该方式忽略。
OpenRASP实现了前面两种加载方式，在比较第一种与第二种方式的优劣势时，[浅谈RASP](https://www.anquanke.com/post/id/187415)文中说明到，attatch机制由于JVM本身的进程保护机制，会导致重复字节码的插入问题，造成重复告警，增加业务压力，而解决该问题的方法又另外会带来业务压力。
###  字节码操作
**ASM**
备注：OpenRASp使用的Javaassit。
通过agent，我们可以访问与修改JVM中的JAVA类，这时候获取到的相关的数据为JAVA字节码，通常通过asm字节码操作框架进行字节码操作。
引用[浅谈RASP](https://www.anquanke.com/post/id/187415)中对ASM的说明：
> 通过该图可以清晰的看出调用顺序，对于新手来说可以简单的理解为下面这样的调用顺序：
>
>   * 需要访问类，所以要声明ClassReader，来“获取”类。
>   * 如果需要对类中的内容进行修改，就需要声明ClassWriter它是继承于ClassReader的。
>   * 然后实例化“访问者”ClassVisitor来进行类访问，至此就以“访问者”的身份进入了类，你可以进行以下工作：
>     * 如果需要访问注解，则实例化AnnotationVisitor
>     * 如果需要访问参数，则实例化FieldVisitor
>     * 如果需要访问方法，则实例化MethodVisitro
>
**Javassist**
引用 [字节码增强技术探索](https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html)
>
> ASM是在指令层次上操作字节码的，阅读上文后，我们的直观感受是在指令层次上操作字节码的框架实现起来比较晦涩。故除此之外，我们再简单介绍另外一类框架：强调源代码层次操作字节码的框架Javassist。
>
>
> 利用Javassist实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。其中最重要的是ClassPool、CtClass、CtMethod、CtField这四个类：
>
>   * CtClass（compile-time
> class）：编译时类信息，它是一个class文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个CtClass对象，用来表示这个类文件。
>   *
> ClassPool：从开发视角来看，ClassPool是一张保存CtClass信息的HashTable，key为类名，value为类名对应的CtClass对象。当我们需要对某个类进行修改时，就是通过pool.getCtClass(“className”)方法从pool中获取到相应的CtClass。
>   * CtMethod、CtField：这两个比较好理解，对应的是类中的方法和属性。
>
>
>
> 了解这四个类后，我们可以写一个小Demo来展示Javassist简单、快速的特点。我们依然是对Base中的process()方法做增强，在方法调用前后分别输出”start”和”end”，实现代码如下。我们需要做的就是从pool中获取到相应的CtClass对象和其中的方法，然后执行method.insertBefore和insertAfter方法，参数为要插入的Java代码，再以字符串的形式传入即可，实现起来也极为简单。
>  
>  
>     import com.meituan.mtrace.agent.javassist.*;
>
>     public class JavassistTest {
>        public static void main(String[] args) throws NotFoundException,
> CannotCompileException, IllegalAccessException, InstantiationException,
> IOException {
>            ClassPool cp = ClassPool.getDefault();
>            CtClass cc = cp.get("meituan.bytecode.javassist.Base");
>            CtMethod m = cc.getDeclaredMethod("process");
>            m.insertBefore("{ System.out.println(\"start\"); }");
>            m.insertAfter("{ System.out.println(\"end\"); }");
>            Class c = cc.toClass();
>            cc.writeFile("/Users/zen/projects");
>            Base h = (Base)c.newInstance();
>            h.process();
>        }
>     }
>  
## 4.实现
###  4.1框架逻辑
这里就偷懒不写了，直接上官方链接：
###  4.2 代码逻辑
**manifest**
rasp.jar的MANIFEST.MF文件：
rasp-engine.jar：
**premain**
从premain启动的OnLoad
phase方式，调用了init进行了如下操作：addJarToBootstrap（打破双亲委派机制）、readVersion、启动engine。
    堆栈信息：
    init:92, Agent (com.baidu.openrasp)
    premain:71, Agent (com.baidu.openrasp)
    invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
    invoke:62, NativeMethodAccessorImpl (sun.reflect)
    invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
    invoke:498, Method (java.lang.reflect)
    loadClassAndStartAgent:386, InstrumentationImpl (sun.instrument)
    loadClassAndCallPremain:401, InstrumentationImpl (sun.instrument)
`init:92, Agent (com.baidu.openrasp)`
`premain:71, Agent (com.baidu.openrasp)`
另外没看懂attach方式（agentmain）是怎么实现的，有点奇怪，先放着，后面再回顾。
**1-1 打破双亲委派机制**
将rasp.jar添加到BootstrapClassLoader，这样做是由于双亲委派机制的存在，类加载器在加载类时无法往下委派加载。用户自定义的类使用的类加载器SystemClassLoader。而当被hook的类需要去调用检测方法，如果该hook类为BootstrapClassLoader加载的，则无法成果调用该检测方法。官方文档也有说明：
> 当去 hook 像 java.io.File 这样由 BootstrapClassLoader 加载的类的时候，无法从该类调用非
> BootstrapClassLoader 加载的类中的接口，所以 agent.jar 会先将自己添加到 BootstrapClassLoader
> 的ClassPath下，这样 hook 由 BootstrapClassLoader 加载的类的时候就能够成功调用到 agent.jar 中的检测入口
    addJarToBootstrap:40, JarFileHelper (com.baidu.openrasp)
    init:92, Agent (com.baidu.openrasp)
    premain:71, Agent (com.baidu.openrasp)
`addJarToBootstrap:40, JarFileHelper (com.baidu.openrasp)`
**1-2-1 装载engine**
使用moduleClassLoader（ExtClassLoader）装载rasp-engine.jar，并且将EngineBoot实例化，赋值给module变量，为后续启动rasp模块做准备。
    :54, ModuleContainer (com.baidu.openrasp)