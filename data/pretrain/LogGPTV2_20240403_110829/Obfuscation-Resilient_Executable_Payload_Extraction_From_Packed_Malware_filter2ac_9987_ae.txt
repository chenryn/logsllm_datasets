APIs for some packers due to its hybrid analysis style, we can
see a precipitous decline for the advanced packers that incor-
porate multiple anti-analysis methods. In contrast, API-Xray
succeeds in resolving API names for all tested packers.
5.1.2 Resistance Against API Obfuscation Schemes
Next, we zoom in on the resistance against different API
obfuscation schemes, and the results are shown in Table 5.
BinUnpack’s advantage lies in quickly determining the end
of unpacking, but its API name resolution function is weak.
Our evaluation shows that BinUnpack does not handle any
API obfuscation schemes. For Ugarte-Pedrero et al.’s work
and RePEconstruct, their dynamic analysis style can naturally
defeat “IAT Redirection” and “Rewrite API Callsite.” How-
ever, they can be cheated by the “Stolen Code” as well as two
obfuscation schemes that we ﬁrst unveil in this paper: “ROP
Redirection” and “Anti-debugging Routine.” They capture
the API that they ﬁrst encounter in a loaded DLL instead
of the real API. API-Xray makes a clean sweep in the API
obfuscation resistance comparison.
5.2 LBR vs. IPT vs. BTS
Since for modern Intel processors, there are three mecha-
nisms to trace branch instructions, including Last Branch
Record (LBR), Branch Trace Store (BTS), and Intel Proces-
sor Trace (IPT) (see §2.3). We conduct a separate experiment
USENIX Association
30th USENIX Security Symposium    3461
to compare BTS with another two similar hardware tracing
mechanisms: LBR and IPT.
Table 6 shows our evaluation results. Column 1 lists all of
the packers we tested. Column 2 shows the maximum number
of control ﬂow deviation instructions from an API callsite to
its target API. We can see that some numbers have already
exceeded the limit of LBR stack size (16 or 32), and the peak
value (39,322) comes from Obsidium packer. Column 3 pre-
sents the last branch instruction to the target API. Note that
some packers use “jmp/call immediate” addressing (the in-
struction in bold) to branch to the target API, but IPT does not
record these instructions. Column 4∼6 presents the running
time when API-Xray adopts LBR, IPT, and BTS to monitor
control ﬂow, respectively. For each version, we report two
overhead numbers. The ﬁrst number represents the running
time of hardware tracing mechanism, and the second one is
the total running time for import table reconstruction. The
blank value means this version fails to restore a complete
import table. Note that IPT’s running time includes both on-
line logging and expensive ofﬂine decoding. The overhead
of BTS-based version is between LBR-based and IPT-based
versions, but only BTS-based version succeeds in all cases.
The LBR-based version cannot restore a complete import
table if the “Maximum Branch Times” exceeds 32, and the
IPT-based version fails if the “Last Branch Instruction” is a
direct unconditional jump (e.g., jmp/call immediate). Since
BTS provides a complete branch tracing capability that cannot
be offered by LBR or IPT, we use BTS as our branch tracing
mechanism to defeat API obfuscation. Considering that API-
Xray frees security analysts from the burden of manually
rebuilding import tables, its overhead is moderate.
5.3 Large-Scale Evaluation with Packed Mal-
ware In the Wild
From July 2019 to December 2019, API-Xray has been de-
ployed into an anti-malware company for large-scale evalua-
tion with packed malware in the wild. API-Xray is integrated
into a commercial unpacking tool to assist security professi-
onals in malware ofﬂine analysis. We have collected a total
of 341,269 packed malware binaries in the production envi-
ronment. 74.6% of them are protected by known packers, and
the other (25.4%) are protected by custom packers.
5.3.1 API Obfuscation Distribution
Table 7 shows the distribution of various API obfuscation
types in our large-scale dataset. Similar to our observation
in Table 4, the “IAT Redirection” is the most popular API
obfuscation type (36.5%). The type of “ROP Redirection”
only accounts for less than 7% due to its high development
cost. Considering a packer can combine different API obfus-
cation types, we also count the number of API obfuscation
schemes used in a packer. As shown in Figure 6, 48.1% of
Figure 6: The statistics of API obfuscation types used by
packed malware in the wild.
packed samples do not apply any API obfuscation scheme.
The remaining 51.9% of them (total 177,119) apply at least
one API obfuscation type, and 2.6% of packed samples apply
the maximum four API obfuscation types.
5.3.2 Evaluation Results
For these 177,119 packed malware samples that are also pro-
tected by API obfuscation schemes, we apply API-Xray to
their OEP memory to reconstruct import tables. Figure 7 pre-
sents the cumulative distribution of our analysis results. We
ﬁrst count the number of branches recorded by API-Xray,
as this number reﬂects the complexity of the control ﬂow
between an API callsite and its target API. As shown in Fi-
gure 7(a), about 29.7% of samples (total 52,604) generate
more than 32 branches, which exceed the size of LBR stack.
However, for these packed malware samples, we do not
have their source code or the binary code with no packer
applied as a reference. To evaluate whether API-Xray recon-
structs import tables successfully, we use two heuristics.
Heuristics 1. We use our custom IDA Pro plugin to scan
API-Xray’s outputs to check whether there exists an API call
with an unresolved name. If yes, we consider this sample
has an incomplete import table. In our evaluation, we ﬁnd
that API-Xray succeeds for 98.4% of samples (total 174,285).
We investigate the remaining 1.6% of samples and ﬁnd out
that these samples call some APIs exported from custom
DLLs, but they are absent in the our testing environment.
Figure 7(b) shows the number of APIs restored by API-Xray
and the number of total APIs, respectively. The two lines in
Figure 7(b) are very close to each other, which means API-
Xray only misses a very small portion of custom APIs.
Heuristics 2. We also evaluate the executability of API-
Xray’s outputs. We run each unpacked PE ﬁle in three state-of-
the-art malware sandboxes: SecondWrite [67], Hybrid Ana-
lysis [22], and VMRay Analyzer [78]. We select them for
two reasons: 1) they all report whether a sample is malicious
or not; 2) since these three sandboxes apply different anti-
evasion methods, a malware sample is possible to evade one
of them but hard to evade all of them. As shown in Figure 8,
3462    30th USENIX Security Symposium
USENIX Association
48.1%21.2%18.2%9.9%2.6%No API Obufscation One TypeTwo TypesThree TypesFour TypesTable 6: The comparison of three hardware tracing mechanisms.
Running Time (seconds)
Packers
#Max-Branches Last Branch
jmp imm1
jmp imm
ret
ret
call eax
jmp imm
call dword []
call imm1
jmp imm
jmp imm
ret/call ecx
call imm
Yoda’s Crypter
Yoda’s Protector
TELock
ZProtect
ASProtect
PESpin
Armadillo
Enigma
PEP
Themida
Obsidium
PELock
1 e.g., jmp 0x73dc17c8 and call 0x73dc17c8
14
10
14
10
45
13
28
12
13
60
39,322
92
LBR
IPT
BTS
(0.11, 13.2)
(0.11, 13.8)
(0.12, 9.4)
(0.11, 13.4)
(0.13, 13.6)
(0.13, 10.8)
(0.13, 14.6)
(0.13, 11.0)
(39.4, 52.6)
(37.0, 50.3)
(43.1, 55.4)
(43.4, 54.1)
(130.8, 161.4)
(7.3, 16.7)
(7.2, 17.2)
(7.8, 17.1)
(7.4, 17.0)
(8.6, 16.6)
(8.5,17.7)
(8.6, 15.1)
(10.1, 19.5)
(5.3, 13.5)
(9.2, 18.6)
(26.1, 43.6)
(14.4, 25.6)
(a) The number of branches
(b) The number of APIs
(c) VirusTotal Detection Number
Figure 7: The cumulative distribution results of evaluating large-scale packed malware in the wild.
Table 7: The distribution of API obfuscation types.
API Obfuscation Type
Type 1: IAT Redirection
Type 2: Stolen Code
Type 3: Rewrite API callsite
Type 4: Anti-debugging Routine
Type 5: ROP Redirection
Distribution
36.5%
12.7%
11.8%
7.8%
6.9%
84.4% of unpacked PE ﬁles (total 149,488) are labeled as
“Malicious” by at least one of the three sandboxes.
Two Evaluation Heuristics Comparison. Compared
with the results calculated by Heuristics 1, we know that
24,797 unpacked PE ﬁles do not exhibit malicious behaviors
in any sandbox, even they have complete import tables. Upon
further investigation, we categorize them into three classes.
First, we ﬁnd 16,849 samples crashed at run time. For these
samples, we utilize a “Just-In-Time” debugger [26] to capture
the crash address automatically. We ﬁnd that the crash occurs
at the address around the original entry point (OEP) but not at
any API callsite. It indicates that the unpacking tool does not
accurately identify the unpacked programs’ OEPs. The root
cause is that some custom packers apply heavyweight code
obfuscation around the OEP area to undermine the existing
OEP search heuristics. We leave addressing this problem as
Figure 8: The number of recovered PE ﬁles exhibiting malici-
ous behaviors in three different sandboxes.
our future work. Second, we ﬁnd 7,789 samples are trigger-
based malware. They do not perform any malicious actions
because the trigger condition is not met (e.g., revealing ma-
licious behavior on a particular date). Finally, 159 unpacked
malware samples are able to detect all of the three sandboxes
and then hide their malicious behaviors.
VirusTotal Detection Number. Security analysts also
ﬁnd that, without applying API-Xray, 7,514 pieces of unpac-
ked malware are not well recognized by anti-virus scanners.
We treat these 7,514 samples as unknown or new malware
USENIX Association
30th USENIX Security Symposium    3463
012345050k100k150k200k #Branch=32Number of Packed MalwareNumber of Branch (10X)01234050k100k150k200kNumber of Packed MalwareNumber of API   (10X) Restored Total051015202530354001k2k3k4k5k6k7k8kNumber of Unknow SampleVirusTotal Detection Number without API-Xray with API-Xray177,119 149,488 (84.4%) 95,421 (53.9%) 050k100k150k200kTotal SamplesAt Least One SandboxAll SandboxesTable 8: The case study of an unknown malware sample.
Table 9: Detection & prevention to NX-bit attacks.
#APIs
Sample
Unknown Trojan1
1 MD5: d4f377c849b86d5ca89776bc56eea832.
63
0
Unpacked Code API-Xray Unpacked Code API-Xray
#VirusTotal
2
33
because they meet the following two criteria: 1) less than
10% of anti-virus scanners from VirusTotal [76] label them as
malware; 2) if they have malware labels, the labels are either
“Generic” or “Heuristic”, rather than a speciﬁc malware name
(e.g.,“Zeus” or “WannaCry”). Figure 7(c) shows the VirusTo-
tal detection numbers for these unknown malware before/after
applying API-Xray. As API-Xray recovers the metadata of
imported APIs that can provide valuable insight into the ma-
licious intention, 8 to 32 additional anti-virus scanners (the
average number is 22) are able to recognize the unknown
malware samples.
We take an unknown Trojan sample as an example to de-
monstrate that API-Xray improves the accuracy of unknown
malware detection. This sample stealthily downloads other
malicious ﬁles from a remote server, and then it installs
and executes the ﬁles. It uses “IAT Redirection” and “Anti-
debugging Routine” to hide API names, such as “InternetRe-
adFile” and “WinExec”. The malicious behavior of this sam-
ple hinges on the invocation of particular APIs, but its bi-
nary code exhibits no recognizable signatures, such as unique
strings or byte n-grams. Table 8 shows without the API infor-
mation, only two anti-virus scanners recognize this malware’s
unpacked code. After API-Xray recovers the 63 APIs of this
sample, the detection number of VirusTotal raises to 33.
6 Discussion