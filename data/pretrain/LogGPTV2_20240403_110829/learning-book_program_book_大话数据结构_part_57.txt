increment-increment/3+1;
增量序列*/
8
for（i=increment+l:ilength;i++)
9
10
if（L->z[i]r[i-increment])
11
（/需将L->r[i]插入有序增量子表*/
12
L->r[0]=L->r[i]:/*智存在L->r[0]*/
13
for（j-i-increment/j>06sL->r[0]r[j]j--increment)
14
L->r[j+increment]-L->r[5]:/*记录后移，壹找插入位置*/
15
./[]xl）;
20
1.程序开始运行，此时我们传入的SqList参数的值为kength=9,r[10]=
{0,9,1,5,8,3.7,4,6,2}。这就是我们需要等待排序的序列，如图9-6-4所示。
下标0123456
789
915837462
图9-6-4
2.第4行，变量increment就是那个“增量”，我们初始值让它等于待排序的记
录数。
3.第5~19行是一个d循环，它提终止条件是increment不大于1时，其实也
就是增量为1时就停止循环了。
392
---
## Page 417
第9章排序
4.第7行，这一句很关键，但也是难以理解的地方，我们后面还要谈到它，先放
一放。这里执行完成后，increment=9/3+1=4。
5.第8~17行是一个for循环，i从4+1=5开始到9结束。
6.第10行，判断Lr[i]与Lr[i-increment]大小，Lr[5]=3小于Lr[i-
increment]=Lr[1]=9，满足条件，第12行，将Lr[5]=3暂存入Lr[0]。第
13~14行的循环只是为了将Lr[1]=9的值赋给Lr[5]，由于循环的增量是”
=increment，其实它就循环了一次，此时j=-3。第15行，再将Lr[0]=3赋
值给Lr[j+increment]=Lr[-3+4]=Lr[1]=3。如图9-6-5所示，事实上，这一
段代码就干了一件事，就是将第5位的3和第1位的9交换了位置。
下标0123456789
3915837462
increment-49>3，交换
图9-6-5
7.循环继续，i=6，Lr[6]=7>Lr[i-increment]=Lr[2]=1，因此不交换两者数据。
如图9-6-6所示。
下标0123456789
3315897462
increment=4
L14，交换
图 9-6-7
9.循环继续，i=8，Lr[8]=66.交换
图9-6-8
10.循环继续，i=9，Lr[9]=22，交换
9>2，交换
图9-6-9
最终第一轮循环后，数组的排序结果为图9-6-10所示。细心的同学会发现，我们
的数字1、2等小数字已经在前两位，而8、9等大数字已经在后两位，也就是说，通
过这样的排序，我们已经让整个序列基本有序了。这其实就是希尔排序的精华所在，
它将关键字较小的记录，不是一步一步地往前挪动，而是跳跃式地往前移，从而使得
每次完成一轮循环后，整个序列就朝着有序坚实地迈进一步。
下标012345678
6
图9-6-10
11.我们继续，在完成一轮d循环后，此时由于increment=4>1因此我们需要
继续do循环。第7行得到increment=4/3+1=2。第8~17行for循环，i从
2+1=3开始到9结束。当i=3、4时，不用交换，当=5时，需要交换数
据，如图9-6-11所示。
下标0123456789
3214637589
increment=223，交换
11-9-6 ]
12.此后，i=6、7、8、9均不用交换，如图9-6-12所示。
394
---
## Page 419
第9章排序
下标
0
213647589
increment=2
，不交换
41，再次d循环，第7行得到
increment=2/3+1=1，此时这就是最后一轮do循环了。尽管第8~17行for
循环，1从1+1=2开始到9结束，但由于当前序列已经基本有序，可交换数据
的情况大为减少，效率其实很高。如图9-6-13所示，图中箭头连线为需要交
换的关键字。
下标0123
4
213647
increment=1
图9-6-13
最终完成排序过程，如图9-6-14所示。
下标
012345678
123456789
图9-6-14
9.6.3希尔排序复杂度分析
通过这段代码的剖析，相信大家有些明白，希尔排序的关键并不是随便分组后各
自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得
排序的效率提高。
这里“增量”的选取就非常关键了。我们在代码中第7行，是用increment=
increment/3+1；的方式选取增量的，可究竞应该选取什么样的增量才是最好，目前还
是一个数学难题，迄今为止还没有人找到一种最好的增量序列。不过大量的研究表
明，当增量序列为dlt[k]=2*1-1（01，则其双亲是结点li/2]。那么对于有n个结点的二
叉树而言，它的i值自然就是小于等于ln/2”了。性质5的第二、三条，也是在说明
下标i与2i和2i+1的双亲子女关系。如果完全忘记的同学不妨去复习一下。
如果将图9-7-2的大顶堆和小顶堆用层序遍历存入数组，则一定满足上面的关系
表达，如图9-7-3所示。
注”：详见本书66节。
397
---
## Page 422
大话
下标
大顶堆
90
80
60110
40
下标
小顶堆
k≤ks(i=3)
k≤ks(i=3)
图9-7-3
我们现在讲这个堆结构，其目的就是为了堆排序用的。
9.7.1堆排序算法
堆排序（HeapSort）就是利用堆（假设利用大顶堆）进行排序的方法。它的基本
思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根
结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大
值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小
值。如此反复执行，便能得到一个有序序列了。
例如图9-7-4所示，图①是一个大顶堆，90为最大值，将90与20（末尾元素）
互换，如图②所示，此时90就成了整个堆序列的最后一个元素，将20经过调整，使
得除90以外的结点继续满足大顶堆定义（所有结点都大于等于其子孩子），见图③，
然后再考虑将30与80互换
90
30
30
90
EC
860
---
## Page 423
第9章排序
图③
图9-7-4
相信大家有些明白堆排序的基本思想了，不过要实现它还需要解决两个问题：
1.如何由一个无序序列构建成一个堆？
2.如果在输出堆顶元素后，调整剩余元素成为一个新的堆？
要解释清楚它们，让我们来看代码。
/*对顺序表L进行堆排序*/
void HeapSort（SqList *L）
3
inti:
for（i=L->length/2;i>0i--）/把L中的r构建成一个大项堆*/
5
HeapAdjust（L,i,L->length）;
for（i-L->length:i>1;1--)
8
swap（L,1,1）；/*将堆顶记录和当前未经排序子序列的最后一个记录交换*/
9