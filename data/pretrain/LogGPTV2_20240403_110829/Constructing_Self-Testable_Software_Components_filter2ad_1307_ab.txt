during 
and 
observability  [KBJ+96].  The  built-in  test  (BIT)  approach  is  a 
D F I  technique that introduces  standard test circuits  and pins that 
allows a card or  an  IC to be.  put in test mode, and also to transmit 
test inputs and capture the outputs. An  extension  to that approach 
consists  in  integrate  inside  the  IC  mechanisms  for  test- inputs 
generation, which avoids the use  of  an  external  tester. This is the 
built-in self-test concept, or BIST. 
controllability 
enhancing 
Some  authors  have  proposed  the  use  of  these  hardware 
approaches to improve  software  testability. D.Hoffman  proposes 
an approach  [21] that augments a module’s interface  with  testing 
features - these are the access programs, corresponding  to the test 
in  BIT  approaches  in  hardware. 
access  ports  (TAP)  used 
Integrating  assertions  to  the  source  code  is  also  proposed  to 
improve  controllability  and  observability. Test  suites  can  be  the 
in  previous  testing  (since  the  purpose  is  mainly 
same  used 
regression testing), but  they can also be  manually generated. Test 
suites  should  be  described  in  a  specific  notation  from  which 
drivers  are automatically  generated.  The  advantage  with  respect 
to the hardware is that testing features may not be part of  the final 
version:  its  insertion  can  be  controlled  by  the  use  of  compiler 
directives. 
R.Binder  adapts this  approach  to the  00 context,  proposing 
the construction of self-testing classes [Binder94]. A self-testing 
class  is  composed by  the  class (or component)  under  test  (CUT) 
augmented  with  built-in 
test  (BIT)  capabilities  and  a  test 
specification.  With  the  BIT  capabilities  it  is  possible  to:  access 
test  facilities,  control  and  observe  an  object’s  internal  state  as 
well as monitor intermediate  results by  the use of  assertions. The 
test specification (1-spec) is used  for test generation  and  also as a 
test oracle. 
The  author  proposes  different  architectures  for  a  self-testing 
class.  In  this  study  we  use  the  one  that  is  based  on  a  driver 
generator,  which  uses the information in the t-spec  to generate  a 
specific driver. The specific driver then activates  the CUT, apply 
the  test  inputs  and  analyses  test  results.  Our  aim  was show  the 
feasibility  of  the  approach  .  Next  section  presents  how  we 
implement such approach. 
3.  Proposed Approach 
3. I .   Methodology 
The methodology is composed of  two parts; one is performed 
by the component producer and the other by its consumer. 
The component producer perform three tasks for developing a 
self-testable component: 
Construct the test model. 
Develop  the t-spec from the test  model and insert it into 
the component source code. 
Instrument  component  source code  to introduce  built-in 
test mechanisms. 
To use a self-testable component,  a consumer should perform 
the following tasks: 
Generate test cases based on the t-spec. 
Compile the component in test mode. 
Execute tests. 
Analyze the results obtained, to determine in what extent 
does the component provide the specified services. 
The  Concat  tool  [33]  was  developed  to  provide  the  built-in 
test interface and also to support test generation. Its main purpose 
was  to  demonstrate  the  feasibility  of  the  proposed  approach,  as 
well as to validate  the test  generation  strategy. The remainder  of 
this section details the above tasks. 
3.2.  Test specification construction 
to 
it 
(ii) 
increasing 
testability; 
the  component’s 
In the context of  this work we opted for a specification-based 
testing  technique,  so  the  test  model  represents  a  component’s 
specification. This presents various advantages: (i)  integrating  the 
component’s  specification 
improves  understandability, 
thereby 
the 
specification can serve not only for test case generation, but  also 
for oracle development;  (iii) test  selection  is, to a certain  extent, 
implementation  language  independent,  which  allows  tests  to  be 
later 
generated 
the 
incorporated 
specification  when  the  component  is  modified  becomes  easier 
when the specification is integrated  with the component; (vii) the 
specification  quality  can  be  improved,  since  incompleteness, 
ambiguity  and  inconsistency  can  be  detected  by  the  tester  and 
then removed. 
to  be 
(vi)  updating 
for  abstract  classes, 
to  a  subclass 
for  example, 
test  suite; 
It  is  worth  noting  that  the  fact  that  we  are  concerned  only 
with  specification-based  testing  does not  mean  that  we  consider 
other tests useless. On  the contrary,  we assume that a component 
has been extensively validated before deployment. Embedded test 
facilities  are 
the 
intended  mostly 
component is reused or altered. 
to  facilitate 
tests  when 
According  to  Beugnard  et  al 
[I,  c.5,  31,  a  component 
specification  should  describe  its  interface  and  behavior.  The 
interface description  includes  input  and  output  features and  their 
related  value  space  (domain);  in  00  context,  this  comprises 
methods  signatures:  type  and  order  of  arguments,  return  type). 
Behavior description  comprises  not  only the expected  outputs  in 
response  to  messages  sent  to  an  object  but  also non-functional 
aspects such as time and space efficiency, safety, security, among 
others. 
Different  types  of  specifications  were  used  for  00 testing. 
For  example,  Doong and  Frankl  present  the  ASTOOT approach 
[13],  based on an algebraic specification,  where the operations on 
abstract  data  types  are  described  in  terms  of  axioms.  Another 
model  commonly  used  is  based  on  finite state  machines  [7, 22, 
241,  as  they  are  adequate  to  represent  an  object’s  behavior. 
Barbey  et  al  used  a  language,  COOPN/2  (Concurrent  Object 
Oriented  Petri  Nets),  based  on  a  combination  of  Petri  nets  and 
algebraic  models  [2].  These  models  are  useful  to  describe  the 
functional 
requirements, 
however, less work  has been  done at that  moment. One notation 
developed  to  express  such  requirements  is  NoFun  [17],  which 
requirements.  For  non-functional 
153 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:02:37 UTC from IEEE Xplore.  Restrictions apply. 
allows the representation  of software attributes such as: time and 
space  efficiency, 
reusability,  maintainability,  reliability  and 
usability. 
In  this  work  we  used  the  transaction  flow  model  (TFM), 
defined  by  B.Beizer  for  concurrent  systems  testing  [4;  51,  to 
represent  functional  behavior  aspects.  A  transaction  is  a unit  of 
work  seen  from  a  user's  point  of  view.  A  transaction 
is  a 
sequence  of  operations  (or tasks  or  else,  activities)  that  can  be 
performed by a hum?,  by a system or a device. S.Siege1 adapted 
this model  for the context  of unit testing of a class [29, ch.1 I]:  in 
this  case,  though, a  transaction  describes  an  allowable  sequence 
of  method  invocations  from  creation  to  destruction.  The  TFM 
represents then  the  different  ways  an  object  can be created,  the 
different tasks  it can perform  and  the  different ways  that  can be 
used to destroy  it. A TFM is represented as a directed graph; the 
nodes  represent  public  features  (attributes  or  methods)  of  the 
class,  encapsulating  all  references  to  other  objects  as  well  as 
internal features.  A  link  connect two nodes  A and  B if  task A  is 
task  B.  Therefore  an  individual 
immediately  followed  by 
transaction  is a path  through  the  TFM  from  birth  to death of  an 
object. 
'This model can be obtained from the use cases defined during 
requirements specification phase,  so it is useful  for our validation 
testing purposes. For  objects presenting  a finite  set  of  allowable 
methods sequences, this  model is useful.  Our main  reason  to use 
such  model  is  that  it  scales  up  easier than  finite  state  machine 
in  00  testing. 
models,  which  are  more  commonly  used 
Therefore,  it  can be used  for  components having  more than  one 
object  (or  even  other  sub-components),  as  it  can  show  the 
sequencing  of  activities  performed  by  several  objects  as well. 
Another  strength  of  this  model  is  its  capability  to  represent 
concurrent  behavior,  but  this  feature  was  not  considered  in  our 
studies yet. 
As  an  example,  suppose  the  class  Product  in  Figure  1 
the  stock  control  system  of  a 
representing  a  product 
warehouse,  in  C++  notation.  The  product  is  obtained  from  a 
Provider, which  is  another  class  of  this  system  that  does  not 
matter for  this example, so it is not shown here.  Suppose the  use 
case  scenario  that  follows,  relative  to  the  addition  of  a  new 
product  into the  stock database:  1. Create a a Product object. 
2.  Obtain  data. about  this  product  from  the  database.  3. 
Remove the  product  from  the  database.  4.  Destroy  the 
object. 
Figure  2  shows  the  TFM  for  that  class,  where  the  path 
corresponding to the use case described is highlighted.  After  the 
development  of  the  test  model,  the  t-spec  representing  it  is 
created and integrated to the component under test. 
in 
Figure 1. Example class Product. 
Figure 2 TFM of class Product. The path corresponding to the example scenario is highlighted. 
154 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:02:37 UTC from IEEE Xplore.  Restrictions apply. 
Class ( ‘Product’, 
No, 
, 
) 
Attribute (‘qty’, 
range, 
I ,  
I ,  
99999) 
99999) 
... 
... 
Method ( ml, ‘Product’, 
Method ( ml, ‘Product’, 
, 
, 
constructor, 
constructor, 
0) 
0) 
... 
/I indicates whether the class is abstract or not 
I/ indicate that the class has no superclass 
11 list all source files needed to compile the class 
I/ allowable  types:  range,  set,  string,  object, 
pointer 
/I for range types, indicates the lower limit 
/I for range types, indicates the lower limit 
/I for range types, indicates the upper limit 
/I for range types, indicates the upper limit 
11 method identifier and name 
11 method identifier and name 
11 return type 
II rmtrn I V ~ P  
/I method category relative to test reuse 
/I number of parameters 
Figure 3 -Test  specification ( 1-spec) format. 
class BuiltlnTest { 
public: 
BuiltlnTest ( ) {  ) 
-BuiltlnTest  ( ) (  ) 
virtual void InvariantTest ( ) {  ] 
virtual void Reporter (FILE *logfile) [  ) 
1 
Figure 4 - Format of the BuiltlnTest class. 
The t-spec  corresponding to the example  model  is presented 
in  Figure 3.  This specification  contains also a description  of  the 
component’s interface,  as shown in the figure. 
For  further details concerning this  model,  the  references  [4, 
ch. 4, 5, ch.6,29, ch.1 I ]  can be consulted. Examples from models 
created in the context of this project can be seen in [32,42]. 
3.3. Class instrumentation 
The instrumentation  is extra software  that  is  introduced into 
the class to increase its controllability  and observability (c.f. 2.3). 