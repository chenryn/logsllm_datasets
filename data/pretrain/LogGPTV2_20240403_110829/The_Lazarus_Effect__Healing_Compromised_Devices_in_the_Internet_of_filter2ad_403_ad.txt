UD
22,332
Untrusted
1,640
6 EVALUATION
In this section, we analyze our prototype regarding its code size,
its boot and runtime performance impact, as well as regarding its
networking overhead. In the experiments in which the device com-
municates with the hub, we ran our simple hub prototype on a
Lenovo Thinkpad T490s (with an Intel Core i7-8665U processor,
8 GB of DDR4 RAM and an Intel AC9560 wireless adapter) running
Ubuntu 18.04 LTS and Python 3.6. The hub and the device commu-
nicated via Wi-Fi through a lightly loaded AVM Fritz!Box 7362 SL
wireless router.
Code size: Table 2 shows the size of the Lazarus binaries. Un-
trusted is the part of Lazarus that runs as part of the untrusted
business logic, mainly the fetching of boot and deferral tickets. We
calculated the Untrusted size as the difference between the sizes
of the business logic binaries compiled with and without Lazarus.
In sum, Lazarus takes up about 93 kB, which is about 14% of the
flash memory on the NXP LPC55S69. Lazarus thus leaves enough
resources for business logic. Our prototype has not been subject
to extensive code and binary optimization. Not depicted in Table 2,
Lazarus reserves 8 kB of RAM, i.e., 2.5%, mapped to the secure
world, unavailable to the non-secure world.
Boot time: We measured the boot time overhead as the time that
elapses from the execution of the first instruction of the Lazarus
boot loader to the execution of the first instruction of the business
logic. We measured this time with an attached external device as
our measurement tool. We used a second NXP LPC55S69 MCU.
We added instructions at the start and the end of the execution of
the boot loader to toggle a dedicated GPIO pin to signal the mea-
surement device to take a timestamp. We conducted 100 separate
runs. We present average values only, as the standard deviation
was below 1%.
The results are displayed in Table 3. In the case in which Lazarus
Core boots the business logic directly, we measured a total overhead
of less than 1.5 seconds. Most of this time is spent computing cryp-
tographic primitives, e.g., boot ticket verification, in Lazarus Core
using the RIoT crypto library [27] which does not use the MCU’s
crypto accelerators. We consider this measurement a worst-case
estimate, showing that Lazarus also performs well on MCUs with-
out cryptographic accelerators. Drastic speed-ups can be achieved
using accelerators. For example, according to the documentation
for the NXP LPC55S69, computing ECDSA-secp256r1 Sign + Verify
takes only 116 ms [35].
Without a valid boot ticket, Lazarus Core runs the update down-
loader. In our scenario, the downloader contacts the hub with its
AliasID, retrieves and stages a boot ticket and resets the device.
This takes around 3.4 seconds in total.
The third part of Table 3 displays the total boot time if the hub
requires a firmware update to be installed. We have omitted the
individual stages of this process, as large parts of it are a repetition
Session 1: IoT Security and Privacy ASIA CCS '20, October 5–9, 2020, Taipei, Taiwan14Table 3: Impact on boot time, depending on the presence of
a valid boot ticket in the staging area.
Table 4: Runtime performance impact for ticket fetching
and verification with different deferral intervals.
Boot Path
w. Ticket
Layer
DICE++
LZ Core
w/o Ticket DICE++
LZ Core
UD
DICE++
LZ Core
w. patch
Time Layer (ms) Time Total (ms)
152
1,297
152
1,025
754
152
1,310
152
1,449
152
1,178
1,932
2,084
3,394
15,720
of the second case (i.e., no boot ticket). After booting through
DICE++ and Lazarus Core, the update downloader contacts the
hub and receives instructions to download a firmware update. In
the experiment in Table 3, it downloads and stages a 58 KB update
containing FreeRTOS and several applications. After two more reset
cycles, which install the update and obtain a boot ticket, the device
finally boots into the newly installed firmware. As shown in Table 3,
the entire process takes less than 16 seconds.
Runtime overhead: We measured the runtime overhead of Laza-
rus against a workload consisting of FreeRTOS running our two
apps: the traffic light controller and the ADC sensor app. For the
baseline measurements, we ran this workload unmodified and with-
out the Lazarus TrustZone component interposing between the
workload and the hardware. For example, flash writes performed
by the workload go directly to flash memory.
The Lazarus variant of the experiment runs the Lazarus Trust-
Zone component which disables direct access by FreeRTOS and the
applications to the flash storage controller, the power controller
and the watchdog timer. As an alternative, Lazarus exposes the
TrustZone handler functions described in Section 5. The FreeR-
TOS workload is recompiled with libraries that redirect accesses
to the three devices to the TrustZone handlers. In addition, we
run a TEETrigger service application on FreeRTOS that obtains a
deferral ticket from the hub over the network and passes the ticket
to TEETrigger running in TrustZone.
In each case, we used the FreeRTOS benchmarking feature to
measure the CPU utilization. We compared the CPU idle time of the
bare FreeRTOS app without Lazarus to our Lazarus implementation
to obtain the total overhead.
Our measurements are summarized in Table 4. We measured
a total overhead of 0.8% when acquiring a deferral ticket every
minute with our task in FreeRTOS and verifying it with TEETrigger.
A deferral ticket fetching interval of one or only a few minutes is
unreasonably short and was chosen only to demonstrate that the
overhead remains low even in this extreme case. Fetching deferral
tickets in intervals of multiple hours or days is more realistic for
most IoT use cases and leads to only negligible overhead.
In addition, we measured the overhead of only writing one flash
page (512 kB) with and without Lazarus, i.e. writing to flash via
the handler versus writing to flash directly. This overhead is about
0.19 % and thus negligible.
Ticket Fetch Interval
Perf. Impact (%)
1 min
0.80
5 min
0.16
10 min
0.08
1 h
0.01
24 h
0.001
Table 5: Time required for ticket fetching and verification.
Fetch Time (ms)
Total Non-Secure
455
145
Secure Network
310
737
Table 6: TCP payload sizes in bytes for different messages
exchanged between device and hub.
Message Type
Boot Ticket
Deferral Ticket
Send AliasID (max)
Bytes Total Request Response
288
288
1,003
144
144
1,001
144
144
2
In a second experiment, we measured the (wall clock) time re-
quired for fetching and verifying a single deferral ticket. We used
the same measurement methodology as in the boot time experiment,
using an external device to take time stamps based on GPIO signals.
Once again, we repeated each experiment 100 times. Table 5 shows
the time spent on computing tasks (Total) and the time that elapsed
between sending a ticket request to the hub and receiving the ticket
(Network). The latter time does not affect the overhead, as FreeR-
TOS can assign the processor to other tasks in the meantime. The
table also shows how the total compute time is split between the
TrustZone handler (Secure) and the untrusted service application
(Non-secure).
Networking: Table 6 shows the TCP payload sizes for various
messages exchanged with the hub. Requesting tickets is imple-
mented as sending and receiving a Lazarus authenticated header
containing a type-field, nonce, digest and signature as well as a
payload. In case of a boot ticket, the payload is just a fixed 4 byte
value, in case of a deferral ticket, the payload is the requested de-
ferral time in milliseconds, also as a 4 byte value. This header is
of size 140 bytes, totaling response and reply with payload to 288
bytes. Sending the AliasID certificate to the hub takes less than one
kilobyte, depending on the actual size of the certificate, which can
vary.
The total TCP payload size of a boot in the update downloader
path with subsequent ticket fetching in the business logic is less
than 2,800 bytes, omitted from Table 6. This includes sending the
AliasID and retrieving the boot ticket in the downloader, and sub-
sequent sending of the AliasID and retrieval of both a deferral and
boot ticket in the business logic. After a normal boot with a valid
boot ticket, data of less than 1,600 bytes are exchanged, i.e., sending
the AliasID in the business logic and retrieving a boot and deferral
ticket. Subsequent fetches of deferral tickets require only 288 bytes.
Session 1: IoT Security and Privacy ASIA CCS '20, October 5–9, 2020, Taipei, Taiwan15Summary: To summarize, our evaluation shows that the over-
head in terms of communication, flash and RAM requirements is
modest even for resource-constrained devices. The same holds for
the runtime overhead for the communication with the hub. In con-
trast, the increase in boot times until executing business logic is
not negligible. However, we expect that resetting a device is an
infrequent event, e.g., when a device needs to be serviced, or when
the hub suspects misbehavior. The result is a good tradeoff between
performance and security gain. We seek to improve the required
boot time with a more optimized implementation in future versions,
e.g., using hardware cryptographic accelerators.
7 SECURITY DISCUSSION
Our goal is to ensure recoverability of IoT devices even if the un-
trusted software is completely compromised. We achieve this goal
if the hub is able to enforce the software stack the device executes
within a time bound. This means that soon after the hub decides
to deploy new software, i.e., an update/patch, onto the device, our
recovery TCB must be executed to retrieve and apply a new version.
We must assume that the attacker not only deploys malware that
tries to resist recovery but also tries to permanently render devices
useless. Our attacker with full control over untrusted software and
possibly with access to the communication channel could try to
use the following vectors to attack availability:
A-1 Manipulate or block the communication channel between de-
vice and hub.
A-2 Attempt to tamper with Lazarus by interfering with its execu-
tion, by overwriting it or by forging updates.
A-3 Tamper with peripherals to permanently render devices ir-
recoverable. Examples are wear out of flash storage, shutting
devices down or setting them into irrecoverable low-power
states, or manipulating the firmware of other peripherals.
A-4 Prevent or defer device reset, e.g, by manipulating or turning
off TEETrigger or by forging deferral tickets.
A-5 Inject malware into untrusted software and try to persist it
across resets.
A-6 Deceive the hub about the application of updates to Lazarus.
A-1 is only possible for a limited time. Our attack model states
that attacks on the communication channel can eventually be de-
tected and removed by the Internet Service Provider (ISP). The
effect of Denial of Service (DoS) attacks on ticket fetching or hub
availability were already discussed by Xu et al. [54] who observed
that DoS attacks typically last less than 48 hours [43].
To protect against A-2 and A-3, we isolated the trusted compo-
nents and critical peripherals from untrusted software. We used
a TEE to latch trusted components and to map critical peripher-
als into the secure world. To enforce this, we simply configured
TrustZone-M and the secure AHB controller on our prototype. Thus,
an attacker is unable to misuse critical peripherals, e.g., overwriting
Lazarus in flash, causing flash wear out, deactivating TEETrigger’s
WDT, or by switching into an irrecoverable low power state.
We kept the interface between the untrusted and the trusted
components very simple. The runtime component contains only
TEETrigger and the handlers for critical peripherals. TEETrigger
only verifies a simple, fixed data structure, and the flash write
handler, merely evaluates whether flash writes are excessive or
target a certain area. The runtime component does not process
any secrets. Thus, our system is by design not susceptible to side-
channel attacks. Untrusted input to Lazarus Core processed during
boot time must be located in the staging area. Every structure in
the staging area has a well-defined format and requires a valid
signature from the hub. For the verification of all data structures,
we provisioned the device with public keys in a secure environment.
We prevent A-4 by placing TEETrigger inside the TEE and by
using a simple interface into the TEE. This ensures the correct
execution of TEETrigger which, by construction, will force a device
reset unless regularly provided with a new deferral ticket from the
hub. Deferral tickets are freshness-protected and only valid when
signed with the hub private key.
Regarding A-5, the attacker can compromise the untrusted soft-
ware according to our threat model. The attacker’s code can run
on the device until the next reset. The hub can force such a reset
by refusing to issue TEETrigger deferral tickets (e.g., because it
became aware of the attack).
If the attack was not persistent, the reset will remove it from
the device. The attacker may be able to reinfect the device using
the same method as the first time (e.g., exploiting the same vulner-
ability). Either way, the hub can (and should) deploy a software
update that disables future attacks (e.g., by patching the vulnera-
bility). Lazarus enables the hub to do so irrespective of the state of
the device.
If the attack persisted itself, it must have changed storage. If this
change affected storage that is hashed by DICE (e.g., executable
code), the hash values will also change. Thus, attestation to the
hub will fail, and the hub can force a reset and update as in the
nonpersistent case.
One can also envision data-only vulnerabilities that allow an
attacker to take control by changing data the hashed code will
read (e.g., configuration data read during OS boot) but that are not
included in the hash because they can change over time. While
such persistent changes would not manifest themselves in changed
DICE hashes, the device could still be recovered unconditionally
by using Lazarus to patch the vulnerable code and the exploit data.
If the downloader is free of flaws, it can retrieve updates without
obstacle. However, we did not assume that the downloader is free of
vulnerabilities. Lazarus latches the downloader in flash, such that
malware cannot overwrite it. It also activates TEETrigger before
running the downloader. This ensures that a reset will eventually
occur. A DoS on the downloader is possible as long as it can be
re-compromised after each reset. The hub can detect such attacks
(as it will fail to see device attestations for the software update) and
block the attack with the help of the ISP.
For defending against A-6, we pointed out non-forgeability and
freshness of the relevant cryptographic messages sent between the
device and the hub in Subsection 4.4. This only allows devices that