3) Output (pk, sk)
Algorithm 2. Sign(sk ∈ Zq, m ∈ {0, 1}∗
1) Uniformly choose an instance key k ← Zq
2) Calculate (rx, ry) = R ..= k · G
3) Calculate
):
H(m) + sk · rx
k
sig ..=
4) Output σ ..= (sig mod q, rx mod q)
Algorithm 3. Verify(pk ∈ G, m, σ ∈ (Zq, Zq)):
1) Parse σ as (sig, rx)
2) Calculate
(r(cid:3)
x, r(cid:3)
y) = R(cid:3) ..=
3) Output 1 if and only if (r(cid:3)
G
pk
+
(sig · H(m))
x mod q) = (rx mod q)
(sig · rx)
The initial publication of the ECDSA algorithm did not
include a rigorous proof of security; this proof was later
provided by Brown [37] in the Generic Group Model, based
upon the hardness of discrete logarithms and the assumption
that the hash function H is collision resistant and uniform.
Vaudenay [38] surveys this and other ECDSA security results,
and Koblitz and Menezes provide some analysis and critique
of the proof technique [39]. In this work, we simply assume
that ECDSA is secure as speciﬁed in Deﬁnition 1.
D. Oblivious Transfer
Our construction uses a 1-of-2 Oblivious Transfer (OT)
system, which is a cryptographic protocol evaluated by two
parties: a sender and a receiver. The sender submits as input
two private messages, m0 and m1; the receiver submits a single
bit b, indicating its choice between those two. At the end of the
protocol, the receiver learns the message mb, and the sender
learns nothing. In particular, the sender does not learn the value
of the bit b, and the receiver does not learn the value of the
message m¯b. 1-of-2 OT was introduced by Evan et al. [40],
and is distinct from the earlier Rabin-style OT [41], [42]. For
a complete formal deﬁnition, we refer the reader to Naor and
Pinkas [43]. Beaver [44] later introduced the notion of OT-
extension, by which a few instances of Oblivious Transfer can
be extended to transfer polynomially many messages using
only symmetric-key primitives. For reasons of efﬁciency, many
modern protocols (including our own) use OT-extension rather
than plain OT.
III. TWO FUNCTIONALITIES
As our scheme is a multi-party computation protocol in the
malicious security model, its security will be deﬁned relative to
an ideal functionality. Prior works on threshold ECDSA [2], [3]
present a functionality FECDSA (Functionality 1) that applies
the threshold model directly to the original ECDSA algorithms.
The ECDSA Gen algorithm becomes the ﬁrst phase of FECDSA,
and the ECDSA Sign algorithm becomes the second.
Functionality 1. FECDSA:
This functionality is parameterized by a group G of order
q (represented in κ bits) generated by G, as well as hash
function H : {0, 1}∗ (cid:6)→ Zq. The setup phase runs once with
a group of parties P such that |P| = n, and the signing phase
may be run many times between any two speciﬁc parties
from this group, Alice and Bob.
Setup (2-of-n): On receiving (init) from all parties in P:
1) Sample and store the joint secret key, sk ← Zq.
2) Compute and store the joint public key, pk ..= sk · G.
3) Send (public-key, pk) to all parties in P.
4) Store (ready) in memory.
Signing: On receiving (sign, sigid
(sign, sigid
but (complete, sigid) does not exist in memory:
1) Sample k ← Zq and store it as the instance key.
2) Compute
3) Compute
, B, m) from Alice and
, A, m) from Bob, if (ready) exists in memory
= R ..= k · G
rx, ry
(cid:8)
(cid:9)
H(m) + sk · rx
k
sig ..=
4) Collect the signature, σ ..= (sig mod q, rx mod q)
, σ) to Bob.
5) Send (signature, sigid
6) Store (complete, sigid) in memory.
Our scheme does not realize FECDSA, but instead a new
functionality FSampledECDSA (Functionality 2), which we have
formulated to allow us to build a protocol that requires only
two rounds. Of course, it is well known that generic Multi-party
Computation can compute any function in two rounds [45],
[46] (or even one round, with a complex setup procedure),
but the challenge is to do so efﬁciently. It is natural to use a
Difﬁe-Hellman exchange to compute R, which would otherwise
require expensive secure point multiplication techniques, but
this precludes either a two-round protocol or use of the standard
functionality for an intuitive reason: in the (basic) Difﬁe-
..= kB · G to Alice, who
Hellman exchange, Bob sends DB
..= kA · G. Both Alice and Bob can
replies to Bob with DA
compute R ..= kA· kB· G. While Alice cannot learn the discrete
logarithm of R, she does have the power to determine R itself
due to the fact that she chooses kA after having seen DB.
This conﬂicts with Functionality 1, which requires that the
functionality pick R. It is not obvious how to solve this without
adding rounds or using a much more expensive primitive,
983
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:03 UTC from IEEE Xplore.  Restrictions apply. 
though we conjecture that a more elaborate one-time setup
procedure may provide a resolution.
Instead, we have devised FSampledECDSA. Relative to the pre-
vious variant, we divide the signing phase of the functionality
into three parts, allowing the parties to abort between them. In
the ﬁrst two parts, Alice and Bob initiate a new signature for
a message m, and a random instance key k is chosen by the
functionality, along with R = k · G, which is returned to Alice.
Alice is permitted to request a new sampling of R from the
functionality arbitrarily many times (with a negligible chance
of receiving a favorable value), and to choose from the sampled
set one value under which the signature will be performed.
If neither party aborts, then in the third part the functionality
will return a signature under the chosen R. This accounts for
Alice’s ability to manipulate the Difﬁe-Hellman exchange, and
yet it ensures that she does not know the discrete logarithm
of the value that is eventually chosen, and that the value is
uniform over G.
In Appendix B we prove in the Generic Group Model [47]
that FSampledECDSA is no less secure than ECDSA itself.
However, if reliance on the GGM is undesirable (ECDSA’s
own reliance notwithstanding) we believe it possible that a
three-round variant of our protocol can realize the FECDSA
functionality directly.
Functionality 2. FSampledECDSA:
This functionality is parametrized in a manner identical to
Functionality 1. Note that Alice may engage in the Offset
Determination phase as many times as she wishes.
Setup (2-of-n): On receiving (init) from all parties in P:
1) Sample and store the joint secret key sk ← Zq.
2) Compute and store the joint public key pk ..= sk · G.
3) Send (public-key, pk) to all parties in P.
4) Store (ready) in memory.
Instance Key Agreement: On receiving (new, sigid
, m, B)
from Alice and (new, sigid
, m, A) from Bob, if (ready) exists
,·,·) does not exist in
in memory, and if (message, sigid
memory, and if Alice and Bob both supply the same message
m and each indicate the other as their counterparty, then:
1) Sample kB ← Zq.
2) Store (message, sigid
..= kB · G) to Alice.
3) Send (nonce-shard, sigid
Offset Determination: On receiving (nonce, sigid
from Alice, if (message, sigid
, j,·) for j = i does not exist in memory:
(nonce, sigid
i ← Zq.
nonce, sigid
i,A = kΔ
, i, Ri, kΔ
i
i /kB and send (offset, sigid
, i, Ri)
, m, kB) exists in memory, but
4) Sample kΔ
5) Store
6) Compute kΔ
, m, kB) in memory.
in memory.
, DB
i,A)
, kΔ
(cid:9)
(cid:8)
to Alice.
(cid:8)
Signing: On receiving (sign, sigid
(sign, sigid) from Bob, if (message, sigid
memory and
memory, but (complete, sigid) does not exist in memory:
7) Abort if kA · kB · G (cid:8)= Ri.
, i, kA) from Alice and
, m, kB) exists in
for j = i exists in
nonce, sigid
, j, Ri, kΔ
i
(cid:9)
8) Set k ..= kA · kB + kΔ
9) Compute
i and store (rx, ry) = R ..= k · G.
H(m) + sk · rx
sig ..=
k
(cid:9)
(cid:8)
10) Collect the signature, σ ..= (sig mod q, rx mod q)
11) Send
12) Store (complete, sigid) in memory.
signature, sigid
to Bob.
, R, kΔ
i , σ
IV. A BASIC 2-OF-2 SCHEME
We describe a simpliﬁed 2-of-2 version of our scheme
initially, abstracting away the multiplication protocols for the
sake of clarity. In Section V we extend our scheme to support
2-of-n threshold signing. The fundamental structure of our 2-
of-2 scheme is similar to that of Lindell [2] in that the signing
protocol ingests multiplicative shares of both the private key
and the instance key from each party.
A. Signing
Alice and Bob begin with m, the message to be signed, and
multiplicative shares of a secret key (skA and skB respectively),
as well as a public key pk that is consistent with those shares.
The protocol is divided into four logical steps:
1) Multiplication: The parties transform their multiplica-
tive shares of the instance key into additive shares. A
second multiplication converts multiplicative shares of
the secret key divided by the instance key into additive
shares. Due to the presence of the consistency check,
the multiplication protocols employed are not required
to enforce correctness or consistency of inputs. Although
many multiplication protocols are valid candidates, we
use the custom OT-based multiplication protocol that we
describe in Section VI-C, referred to here as πMul.
2) Instance Key Exchange: The parties calculate R = k· G
using a modiﬁed Difﬁe-Hellman exchange.
3) Consistency Check: The parties verify that the ﬁrst
multiplication uses inputs consistent with the Instance
Key Exchange. This is achieved by adding a random pad
φ to Alice’s input, and then combining the pad with the
multiplication output and the known value R in such
a way that Bob can retrieve the pad only if he acted
honestly. A second check ensures that the multiplications
are consistent with each other and with the public key, by
combining the multiplication outputs with the public key
in the exponent.
4) Signature and Veriﬁcation: The parties reconstruct the
signature, which is given to Bob. Bob veriﬁes the signature
in the usual way, and, if the signature veriﬁes, then he
outputs it.
The instance key exchange component
implements the
second and third phases of the FSampledECDSA functionality
(Functionality 2), and the multiplication, consistency check, and
veriﬁcation components implement the fourth phase. Although
we make a logical distinction between these four components,
in the actual protocol they are intertwined. In particular, we
reorder the messages such that all messages from Bob to Alice
come ﬁrst, followed by all messages from Alice to Bob, which
984
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:03 UTC from IEEE Xplore.  Restrictions apply. 
(cid:8)
results in a two-message protocol. Additionally, rather than
perform the consistency check directly, we use its associated
message as a key to encrypt all subsequent communications,
so that the protocol can only be completed if the consistency
check passes. We give the protocol below, and in Figure 1 we
provide an illustration, along with annotations indicating the
logical component associated with each step.
Protocol 1. Two-party Signing
This protocol is parameterized by the Elliptic curve (G, G, q)
and the hash function H : {0, 1}∗ (cid:6)→ Zq. It relies upon the
subprotocol πMul. Alice and Bob provide their multiplicative
secret key shares skA, skB as input, along with identical copies
of the message m, and Bob receives as output a signature σ.
Multiplication and Instance Key Exchange:
1) Bob chooses his secret instance key, kB ← Zq, and Alice
← Zq. Bob computes
2P-ECDSA
πSign
(cid:9)
:
chooses her instance key seed, k(cid:3)
..= kB · G
DB
and sends DB to Alice.
A
2) Alice computes
A
· DB
R(cid:3) ..= k(cid:3)
..= H(R(cid:3)
kA
R ..= kA · DB
) + k(cid:3)
A
3) Alice chooses a pad φ ← Zq, and then Alice and Bob
run the πMul subprotocol with inputs φ + 1/kA and 1/kB
respectively, and receive shares t1
B of their padded
joint inverse instance key
A and t1
t1
A + t1
B =
φ
kB
+
1
kA · kB
Alice and Bob also run the πMul subprotocol with inputs
skA/kA and skB/kB respectively (that is, their secret key
shares multiplied by their inverse instance key shares).
They receive shares t2
B of their joint secret key
over their joint instance key
skA · skB
kA · kB
A and t2
t2
A + t2
B =
These two protocol instances are interleaved such that
the messages from Bob to Alice are transmitted ﬁrst,
followed by the messages from Alice to Bob.
4) Alice transmits R(cid:3) to Bob, who computes
) · DB + R(cid:3)
For both Alice and Bob let (rx, ry) = R.
R ..= H(R(cid:3)
Consistency Check, Signature, and Veriﬁcation:
5) Alice and Bob both compute m(cid:3)
6) Alice computes the ﬁrst check value Γ 1, encrypts her
pad φ with this value, and then transmits the encryption
ηφ to Bob.
= H(m).
Γ 1 ..= G + φ · kA · G − t1
A
· R
ηφ ..= H(Γ 1
) + φ
7) Alice computes her share of the signature sigA and the
second check value Γ 2. She encrypts sigA with the
second check value and then transmits the encryption
ηsig to Bob
..= (m(cid:3) · t1
sigA
Γ 2 ..= (t1
A
ηsig ..= H(Γ 2
A) + (rx · t2
A)
· G)
· pk) − (t2
A
) + sigA
8) Bob computes the check values and reconstructs the
signature
· R
)
Γ 1 ..= t1
B
φ ..= ηφ − H(Γ 1
− φ/kB
θ ..= t1
B
..= (m(cid:3) · θ) + (rx · t2
sigB
B)
· G) − (θ · pk)
Γ 2 ..= (t2
B
sig ..= sigB + ηsig − H(Γ 2
)
9) Bob uses the public key pk to verify that σ ..= (sig, rx)