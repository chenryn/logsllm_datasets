# CVE-2019-11043 调试复现与分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 一、漏洞介绍
​ CVE-2019-11043漏洞是PHP 7.x版本下FPM配合不恰当的Nginx配置可以导致RCE的一个漏洞，影响的具体版本如下：PHP
7.1版本小于7.1.33；PHP 7.2版本小于7.2.24；PHP
7.3版本小于7.3.11。这个洞是国外安全研究员在做CTF题目时意外发现的，当发送特定的带有`%0a`的URL请求时会造成服务器响应异常。下面通过复现和调试分析来细看这个CVE漏洞。
## 二、浅析与复现
###  1、在详细调试这个漏洞之前，需要对几个重要的前置知识进行简单了解。
**（1、PHP-FPM、Nginx对PATH_INFO的获取。**
CGI的环境变量PATH_INFO的内容是URL中的一部分，例如请求URL为下面所示时，`PATH_INFO`获得的值为
**/yunsle1/yunsle2** ：
    http://10.211.55.6/index.php/yunsle1/yunsle2?a=yunsle
这个漏洞对Nginx的配置有要求，使用`fastcgi_split_path_info`的特定正则形式去匹配带有`%0a`的URL时，`PATH_INFO`会得到空字符串。Nginx配置如下：
    location ~ [^/].php(/|$) {
    ​        fastcgi_split_path_info ^(.+?.php)(/.*)$;
    ​        include fastcgi_params;
    ​        fastcgi_param  PATH_INFO    $fastcgi_path_info;
    ​        fastcgi_param SCRIPT_FILENAME  $document_root$fastcgi_script_name;
    ​        fastcgi_param PATH_TRANSLATED  $document_root$fastcgi_path_info;
    ​        fastcgi_pass 127.0.0.1:9000;
    }
此时构造请求为下面所示时，正则`^(.+?.php)(/.*)$`碰到`%0a`后导致后面括号内获得的PATH_INFO值会为 **空** ：
    http://10.211.55.6/index.php/yun%0asle1/yunsle2?a=yunsle
**（2、PHP-FPM中存储请求相关的环境变量数据结构。**
    1、// 管理fcgi_data_seg等
    typedef struct _fcgi_hash {
        fcgi_hash_bucket  *hash_table[FCGI_HASH_TABLE_SIZE];
        fcgi_hash_bucket  *list;
        fcgi_hash_buckets *buckets;        //存放请求环境变量的哈希表，键值对数据存在下面的data
        fcgi_data_seg     *data;            //存放请求环境变量键值对数据
    } fcgi_hash;
    2、//存放请求环境键值对的数据结构
    typedef struct _fcgi_data_seg {
        char                  *pos;
        char                  *end;
        struct _fcgi_data_seg *next;
        char                   data[1];
    } fcgi_data_seg;
这里需要强调两个重要的数据结构，分别是`fcgi_hash_buckets`和`fcgi_data_seg`，前者保存着请求的环境变量的键值对的哈希表，而后者是存储这些具体键值对数据的地方。可以通过内存图简单看出它们的关系：
**buckets：**
**data：**
###  2、漏洞调试复现
为了对漏洞进行调试分析，在这里没有使用P神的`vulhub`搭建环境。选择虚拟机编译PHP环境并且开启调试信息，方便后续使用gdb进行跟踪：
    ./configure --prefix=/home/php7.2.20 --enable-phpdbg-debug --enable-debug --enable-fpm CFLAGS="-g3 -gdwarf-4"
    1、加了-g3的参数后，gcc编译的时候，会将扩展的debug信息编译进二进制文件里面，包括宏定义信息。
    2、DWARF是一种应用的比较广泛的elf(可执行和链接格式)。这边的-gdwarf-4意思是使用版本4的格式，对dwarf格式感兴趣的，可以看其他相关资料。
并且为了方便调试，将PHP-FPM的工作模式设定为单个work进程。另外安装Nginx，使用前置知识中的配置:
    location ~ [^/].php(/|$) {
    ​        fastcgi_split_path_info ^(.+?.php)(/.*)$;
    ​        include fastcgi_params;
    ​        fastcgi_param  PATH_INFO    $fastcgi_path_info;
    ​        fastcgi_param SCRIPT_FILENAME  $document_root$fastcgi_script_name;
    ​        fastcgi_param PATH_TRANSLATED  $document_root$fastcgi_path_info;
    ​        fastcgi_pass 127.0.0.1:9000;
    }
访问站点进行测试，正常返回内容，一切准备工作就绪：
接着直接使用原作者的Go版本的EXP，但是没有成功。一开始怀疑是版本问题，但是测试7.3.10版本PHP同样没有成功。
碰到这情况，只能进去分析一波漏洞点看看问题在什么地方（函数init_request_info）：[https://github.com/php/php-src/blob/php-7.3.10/sapi/fpm/fpm/fpm_main.c#L1151。](https://github.com/php/php-src/blob/php-7.3.10/sapi/fpm/fpm/fpm_main.c#L1151%E3%80%82)
    int ptlen = strlen(pt);
    int slen = len - ptlen;
    //pilen是env_path_info的长度，env_path_info就是PATH_INFO的值，PATH_INFO为空时pilen为0
    int pilen = env_path_info ? strlen(env_path_info) : 0;
    int tflag = 0;
    char *path_info;
    if (apache_was_here) {
      /* recall that PATH_INFO won't exist */
      path_info = script_path_translated + ptlen;
      tflag = (slen != 0 && (!orig_path_info || strcmp(orig_path_info, path_info) != 0));
    } else {
      //当env_path_info为空时，path_info赋值为env_path_info地址+0-slen，在这slen长度可控，导致path_info下溢
      path_info = env_path_info ? env_path_info + pilen - slen : NULL;
      tflag = (orig_path_info != path_info);
    }
代码中slen是请求中的部分长度，当请求URL为`http://10.211.55.6/index.php/yunsle1/%0ayunsle2?a=yunsle`时，slen是`/yunsle1/%0ayunsle2`的长度：17。
上面注释的地方解释了这个漏洞的本质所在，PATH_INFO为空——》env_path_info为空——》pilen为0且slen可控——》path_info下溢。
紧接着这段代码之后是如下代码：
    if (orig_path_info) {
      char old;
      FCGI_PUTENV(request, "ORIG_PATH_INFO", orig_path_info);
      old = path_info[0];
      path_info[0] = 0;        //<----- 一字节写0 
      if (!orig_script_name ||
          strcmp(orig_script_name, env_path_info) != 0) {
        if (orig_script_name) {
          FCGI_PUTENV(request, "ORIG_SCRIPT_NAME", orig_script_name);//<----写fastcgi环境变量
        }
        SG(request_info).request_uri = FCGI_PUTENV(request, "SCRIPT_NAME", env_path_info);
      } else {
        SG(request_info).request_uri = orig_script_name;
      }
在path_info下溢之后，执行了`path_info[0] =
0;`，向下溢的地址写了一字节的0，这就造成了可控地址写0的能力。但是这个能力有什么用呢？我们继续往下看，下面代码刚好还有 **写fastcgi环境变量**
的操作，这个漏洞的 **利用思路是通过这一字节写0能够达到写环境变量的目的，最终RCE** 。于是这个一字节写0操作需要写特定的地方才能达到目的。
我们前置知识中介绍了`fcgi_hash_buckets`和`fcgi_data_seg`结构体，如果能够在`fcgi_hash_buckets`中写入PHP环境变量的键值对就可以，那么就需要搞清楚数据是怎么写入到fastcgi键值对中。
FCGI_PUTENV函数——》fcgi_hash_set函数——》fcgi_hash_strndup函数