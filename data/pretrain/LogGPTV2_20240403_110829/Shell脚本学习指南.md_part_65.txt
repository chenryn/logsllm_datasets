或最后的手段：
$ ki11 -KILL 25094
转送KILL号给进程25094
大部分的top实例，会允许从top本身里，下达kill命令。
当然，只有你是stevens或root时才能作这样的事。否则，你只能要求系统管理员
删除这个偏离的进程。
小心地使用ki11命令。当程序不正常中止时，可能会在文件系统里留下残余数据，这
些数据本应剧除，除了浪费空间外，可能还会导致在下次执行程序时发生问题。例如：
dacmon、邮件客户端程序、文字编辑器，以及网页浏览器都会产生锁定（lock），其仅
为一个小型文件，记录程序正在执行。如果程序的第二个实例（instance）被起动，而第
一个实例仍在执行时，第二个实例会侦测到已存在的lock，回报该事实并立即中止。否
则，两个实例写人同一个文件，将可能发生难以挽教的局面。精糕的是，这些程序很少
会告诉你lock文件的文件名，并很少将它写人文件里，如果该lock文件为长期执行进程
的残余数据，你可能会发现程序无法执行，直到你找到lock并删除它为止。我们会在13.4
节里告诉你怎么做。
www.TopSage.com
---
## Page 386
374
第13章
有些系统（GNU/Linux、NetBSD，与Sun Solaris）提供了pgrep与pkil1命令，让你
指定名称的进程。以偏离的进程为例：我们会这么做：
Spgrep metscape
寻找netscape工作的进程输号
6052
接着：
S pki11 -80P'netsoape
传P信号予netcape进程
$ pki11 -rgRH netecape
S pki1l -xILl netscspe
传送KILL信号予netscape进程
传送TERM信号予net8cape进程
不过，由于进程名称不是唯一的，因此以名称来删除它们会有风险：可能一次副掉太多，
包括你不想删的，
13.3.2
捕捉进程信号
里，无论信号是否应该被抓取、忽略，或中止进程。为了令大部分程序无须烦恼这些信
号的处理，内核本身即拥有一些信号慰认值。例如，在SunSolaris的系统上，我们发现：
S nan -a signal
查看所有关于信号的手册页
Nane
Default
Event
SIGHUP
SIGIN
1
Exit
Bxit
Hangup(see termlo(71) 
Interrupt (see tezmio(7I))
SIGQUIT
`3
Core
Quit (8ee termio(7I))
SIGABRT
 6
Core
Abort
SIGFPE
8
-Core
Arithmetic Exception
- + 
SIGFIPB
13
Bxit
Broken Pipe
SIGUSR1
16
Bxit-1
Uter Signal 1
SIGUSR2
17
18
Ignore
Exit
SIGCHLD
Chi1d Status Changed
User Signa1. 2
trap可引起Shell注册信号处理器（signalhandler）.抓取指定的信号。trap取得一
个字符串参数，其包含采取捕捉时要被执行的命令列表，紧接着一个要设置描捉的信号
列表，在旧式Shell脚本里，你会常看见以数字表示的信号，这不但无法让人了解它的
用意，也不具可移植性，所以请使用信号名称。
例13-3展示的小型Shell脚本：looper.它的功能是使用trap命令，说明被抓取（caught）
与未被抓取（uncaught）的信号。
www.TopSage.com
---
## Page 387
进程
375
例13-3：休眠循环脚本：looper
#1/bin/sh -
dnR ,*** dnt SuTzouf1 oqoa, de21
trap *echo Terminating on UsR1 ..- 1 exit 1" USR1
while true
do
sleep 2
date >/dev/nul1
done
looper里有两个trap命令，第一个只是回报HUP信号已被收到，而第二个则回报USR1
信号并离开，之后，程序即进入休眠操作的无穷循环。我们将之执行于后台中，然后传
送两个它要处理的信号：
S./looper 
于后台执行looper
[1I
24179
进程ID为24179
S ki11 -8UP 24179
传送HUP信号予LoopeT
Ignoring HUP ...
S ki11 -0SR1 24179
传送USR1倍号予1ooper
Terminating on USR1
[1]:+.Done(1)
/1ooper &
现在来试试其他信号：
S./looper6
再次干后台中执行1ooper
[t]
S xI11 -CHLD 24286
传送CHLD倍号给1ooper
Sjobe
1ooper是否仍在执行中？
+[t]
Running
./1ooper &
S ki11 -FPg 24286
传送PPB信号给1ooper
[1]  + Arithmetic Bxg
redump) , /1ooper &
S./looper &
24395
再次于后台执行1ooper
[1]
S k111 -PIPB 24395
传送 PIPB信号给10oper
[1]  + Broken Pipe
/1ooper &
$./looper &
再次干后台执行1ooper
[11
24622
S ki11 24621
传送默认信号TER给1oopeT
[1] +Done (208)
,/looper&
注意：CHLD信号并未终止进程：它是内核里默认要被忽略的信号之一，相对地，符点
www.TopSage.com
---
## Page 388
376
第13常
起进程中止。
再加人一个trap命令至looper作最后的试验：
trap *echo Chi1d terminated ...' CHLD
我们将修改过的脚本给予新的名称，再执行它：
$./looper-2&
于后台中执行1ooper-2
Child terminated
[1]
24668
Child terminated
Child terminated
Child terminated ...
+ -
S ki11-ABRT 24668
传送ABRT信号给1ooper-2
[1] • Abort (coredump)
./1ooper-2 &
次报告，直到我们传送ABRT（中断）信号才终止循环进程。
除了先前ki11-1所列的标准信号之外，Shell另提供一个额外的信号供trap命令使
用：EXIT。此信号数值恒被指定为零，所以trap...’o语句，在旧式的Shell脚本
里等同于trap'...ExIT。
trap...’EXIT语句的本体，是在做exit（）系统调用之前被引用，不是明确的exit
命令，就是脚本的正常终止。如果为其他信号而设置捕捉，则这些捕捉会在EXIT的捕
捉之前被处理。
执行EXIT捕提时，离开状态$?的值会在捕捉完成时被保留下来，除非捕捉里的exit
重设它的值。
bash、ksh，与zsh另提供两个给trap使用的信号：用以描捉每个语句的DEBUG，以
及捕提在语句之后回传的非零值离开码的ERR。
DEBUG捕捉就有点棘手了：在ksh88下，它是在语句之后捕捉，而后期的Shell，则是
在之前捕捉。公众软件的KornShell实例虽可在很多平台上使用，但完全不支持DEBUG
捕提。我们以下面的简短测试脚本说明它们的不同：
S cat debug-trap
显示测试脚本
pwd
pwd
www.TopSage.com
---
## Page 389
进程
377
在SunSolaris系统下，我们使用几个不同的Shell测试此脚本：
S /bin/eh debug-trap
试试 Bourne She11
test-debag-trap: trap: bad trap
/tmp
This is an gxir trap
/tnp
$/bin/kea debug-trap
试试1988 (1) Korn She11
/tp
This i8 a Dg80G trap
This 18 a D88UG trap
/tnp
This is an zxir trap
S /uer/xpg4/bln/eb debug-trap
试试 P0SIX She11 (1988 (1)Korn She11)
This is a DesuG trap
/p
/tmp
This is a DEBUG trap
This is an gxir trsp
S /usr/dt/bln/dtkeb debug-trep
This is α DEBUG trap
试试 1993 (d) Korn She11
This 1o a DgBUG trap
/tnp
This is a DgBUG trap
/tmp
This is an zxir trap
S /usr/loca1/bin/keb93 debug-trap
This is a DE8UG trap
试试1993 （o+)Korn She11
This 18 a D8BUG trap
/mp
/tnp
This is a DEBUG trap
This is an EXIr trap
$ /usr/loca1/bln/bash debug=trap
This is a DeBUG .trap
试试 GNU Bourne-Again Shel1
This is & DgBUG trap
/tnp
This is a DEBUG trap
/tp
This is an ExIr trap
$/usr/local/bin/pdkahdebug-trap
试试公众软件的.KormShel1
test-debug-trap[2]: trap: bad signal DestG
S /usr/local/bin/zsh debug-trap
This is a DEBUG trap
试试z-Shel1
This is a pEBuG trap
/tmp
This is a DEBUG trap
/tmp
www.TopSage.com
---
## Page 390
378
第13章
This is an EXIT trap