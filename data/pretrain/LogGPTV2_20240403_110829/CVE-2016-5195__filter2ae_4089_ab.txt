`follow_page_mask` 主要用于判断 VMA 是否已经被换入到了物理内存中。
    /**
     * follow_page_mask - look up a page descriptor from a user-virtual address     // 在虚拟内存中寻找指定的 page descriptor
     * @vma: vm_area_struct mapping @address
     * @address: virtual address to look up
     * @flags: flags modifying lookup behaviour
     * @page_mask: on output, *page_mask is set according to the size of the page
     *
     * @flags can have FOLL_ flags set, defined in 
     *
     * Returns the mapped (struct page *), %NULL if no mapping exists, or
     * an error pointer if there is a mapping to something not represented
     * by a page descriptor (see also vm_normal_page()).
     * 如果已经寻找的内存页已经被映射进入物理内存中则返回该页的 page 结构，否则返回 NULL。
     */
根据 `follow_page_mask` 的返回情况，如果 VMA 没有被换入，则触发缺页中断，经由第二个关键函数 `faultin_page`
进行处理。
对 private 的处理正常会经历 三次 `follow_page_mask` 和两次 `faultin_page`，主要完成两件事：缺页处理、COW。
**(1). 三次 follow_page_mask**
**第一次**
第一次调用会因为访问的page不在物理内存中返回 `no_page_table` 函数而引发缺页异常，第一次调用 `faultin_page`
处理，处理完毕后再次进入 `follow_page_mask` 中。
**第二次**
在 `follow_page_pte` 中判断 FOLL_WRITE 被置位且 pte 不可写，因为mmap的时候以 `MAP_PRIVATE`
进行的映射，因此 pte 肯定是不可写的，第二次调用返回值 page 为 0。
因为没有获取到 page，再次进入 `faultin_page` 处理后进行第三次调用
**第三次**
第三次调用完了后才获取到了 page 信息。
**(2). 两次 faultin_page**
**第一次**
第一次调用 `faultin_page` 主要完成了缺页处理的工作
**第二次**
第一次缺页处理完了之后，因为换入物理内存中的 PTE 不可写，因此会再次调用 `faultin_page` 进行 cow
最终会调用 `do_wp_page` 来完成 cow
在cow结束后清除page的 FOLL_WRITE 标记，从而在第三次 `follow_page_mask` 的时候能够正常返回 pte 信息。
###  2\. madvise
    /*
     * The madvise(2) system call.
     *
     * Applications can use madvise() to advise the kernel how it should
     * handle paging I/O in this VM area.  The idea is to help the kernel
     * use appropriate read-ahead and caching techniques.  The information
     * provided is advisory only, and can be safely disregarded by the
     * kernel without affecting the correct operation of the application.
     *
     * behavior values:
     *  MADV_NORMAL - the default behavior is to read clusters.  This
     *        results in some read-ahead and read-behind.
     *  MADV_RANDOM - the system should read the minimum amount of data
     *        on any access, since it is unlikely that the appli-     *        cation will need more than what it asks for.
     *  MADV_SEQUENTIAL - pages in the given range will probably be accessed
     *        once, so they can be aggressively read ahead, and
     *        can be freed soon after they are accessed.
     *  MADV_WILLNEED - the application is notifying the system to read
     *        some pages ahead.
     *  MADV_DONTNEED - the application is finished with the given range,        关键参数
     *        so the kernel can free resources associated with it.
     *  MADV_FREE - the application marks pages in the given range as lazy free,
     *        where actual purges are postponed until memory pressure happens.
     *  MADV_REMOVE - the application wants to free up the given range of
     *        pages and associated backing store.
     *  MADV_DONTFORK - omit this area from child's address space when forking:
     *        typically, to avoid COWing pages pinned by get_user_pages().
     *  MADV_DOFORK - cancel MADV_DONTFORK: no longer omit this area when forking.
     *  MADV_HWPOISON - trigger memory error handler as if the given memory range
     *        were corrupted by unrecoverable hardware memory failure.
     *  MADV_SOFT_OFFLINE - try to soft-offline the given range of memory.
     *  MADV_MERGEABLE - the application recommends that KSM try to merge pages in
     *        this area with pages of identical content from other such areas.
     *  MADV_UNMERGEABLE- cancel MADV_MERGEABLE: no longer merge pages with others.
     *  MADV_HUGEPAGE - the application wants to back the given range by transparent
     *        huge pages in the future. Existing pages might be coalesced and
     *        new pages might be allocated as THP.
     *  MADV_NOHUGEPAGE - mark the given range as not worth being backed by
     *        transparent huge pages so the existing pages will not be
     *        coalesced into THP and new pages will not be allocated as THP.
     *  MADV_DONTDUMP - the application wants to prevent pages in the given range
     *        from being included in its core dump.
     *  MADV_DODUMP - cancel MADV_DONTDUMP: no longer exclude from core dump.
     *
     * return values:
     *  zero    - success
     *  -EINVAL - start + len  ../rootfs.img
用下面的命令启动环境
    qemu-system-x86_64 \
    -kernel [your kernel arch/x86_64/boot/bzImage path] \
    -initrd [your rootfs.img path] \ 
    -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init" \
    -cpu kvm64 \
    --nographic --gdb tcp::1234
###  2\. 单线程 poc
首先创建一个只读文件
运行poc，并根据输出的虚拟地址进行寻址，此时 `follow_page_mask` 和 `faultin_page` 均已执行两回，此时已经完成了 COW
并执行了关键的一步：清除了 `FOLL_WRITE` 属性。
此时我们模拟 `madvise` 的功能，清除pte的信息，会导致 `follow_page_mask` 再次引发缺页，缺页处理后获得的 pte 是没有
`FOLL_WRITE`属性的，进而也就不会有 `FAULT_FALG_WRITE` 引发 COW，从而触发了漏洞修改了只读页面。
    (gdb) x/10xg 0x7fc3a4698de0
    0x7fc3a4698de0:    0x8000000000203865    0x0000000000000000
    0x7fc3a4698df0:    0x0000000000000000    0x0000000000000000
    0x7fc3a4698e00:    0x0000000000000000    0x0000000000000000
    0x7fc3a4698e10:    0x0000000000000000    0x0000000000000000
    0x7fc3a4698e20:    0x0000000000000000    0x0000000000000000
    (gdb) set *0x7fc3a4698de0=0x0
    (gdb) x/10xg 0x7fc3a4698de0
    0x7fc3a4698de0:    0x8000000000000000    0x0000000000000000
    0x7fc3a4698df0:    0x0000000000000000    0x0000000000000000
    0x7fc3a4698e00:    0x0000000000000000    0x0000000000000000
    0x7fc3a4698e10:    0x0000000000000000    0x0000000000000000
    0x7fc3a4698e20:    0x0000000000000000    0x0000000000000000
    (gdb) set *0x7fc3a4698de4=0x0
    (gdb) x/10xg 0x7fc3a4698de0
    0x7fc3a4698de0:    0x0000000000000000    0x0000000000000000
    0x7fc3a4698df0:    0x0000000000000000    0x0000000000000000
    0x7fc3a4698e00:    0x0000000000000000    0x0000000000000000
    0x7fc3a4698e10:    0x0000000000000000    0x0000000000000000
    0x7fc3a4698e20:    0x0000000000000000    0x0000000000000000
    (gdb) c
    Continuing.
调这个经典漏洞着实是花了很长一段时间，中间也是走走停停，不过最终还是搞清楚了原理，在此感谢各位无私分享的师傅们~
## 参考链接