for others, and both reported device reboots.
Fig. 4 presents the exceptions that cause the crashes, broken
down by built-in and third-party apps. The percentage is
calculated taking the two application classes together. It is
noteworthy that built-in apps reported crashes at a higher
rate (64%) than third-party apps (46%). The failures included
those in built-in core AW components aimed to track workout
activity, such as Google Fit and Motorola Body.
During the fuzzing campaigns, the system restarted twice
this manifesta-
due to crashes. We ﬁnd empirically that
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:25:53 UTC from IEEE Xplore.  Restrictions apply. 
415
6
DISTRIBUTION OF BEHAVIORS AMONG FUZZ INTENT CAMPAIGNS
TABLE III
A: Semi-valid Action and Data
B: Blank Action or Data
C: Random Action or Data
D: Random Extra
Health
8%
0%
0%
0%
Reboot
Not Health
0%
0%
0%
3%
Health
23%
31%
31%
15%
DISTRIBUTION OF CRASHES ON ANDROID PHONE PER EXCEPTION TYPE.
”OTHERS” CONTAIN EXCEPTIONS THAT CAUSED FEWER THAN 5 CRASHES.
TABLE IV
Exception
java.lang.NullPointerException
java.lang.ClassNotFoundException
java.lang.IllegalArgumentException
java.lang.IllegalStateException
java.lang.RuntimeException
android.content.ActivityNotFoundException
java.lang.UnsupportedOperationException
Others
#Crashes
54
46
31
10
9
7
6
12
%
30.9%
26.3%
17.7%
5.7%
5.1%
4.0%
3.4%
6.9%
reason of crashes
mary cause of crashes was NullPointerException.
ClassNotFoundException had the
second largest
share, followed by IllegalArgumentException and
IllegalStateException. The
also
major
shown in Sec-
in AW,
tion IV-A. In contrast, ClassNotFoundException and
IllegalArgumentException were more frequent on
the phone. These results indicate that
input validation on
Android has improved over the years, and fewer uncaught
NullPointerException are raised in Android 7.1.1 com-
pared to results from Maji et al. [8].
two are
later
as
D. QGJ-UI Results
In Table V we give the results of our injection into the
UI events and resultant intents through the QGJ-UI, which
was introduced in Section III-E. We only see two of the four
categories introduced earlier, “Crash” and “No effect”. Only
0.05% of the injections lead to app crash with semi-valid
injections, while there is no crash with random injections.
This is despite the fact that 1.5% of the injections lead to
exceptions, but all of these are handled. Reassuringly, we did
not observe any system crash during our UI injections. We
found that compared to QGJ-Master, QGJ-UI showed much
fewer number of exceptions and crashes, thereby showing
better resilience to malformed UI events. We posit that, besides
better input validation at the event handlers, two other factors
contribute to these positive results—(i) QGJ-UI only sends
intents to launcher activities of various applications, therefore,
the set of target components is fewer in QGJ-UI. These
components are also simpler and therefore tend to be more
reliable; (ii) We found that various adb tools (subcommands)
such as shell input, am (ActivityManager shell utility),
pm (PackageManager shell utility) have robust
input vali-
dation and sanitization routines. For example, if an activity
com.android.phone is invoked by QGJ-UI using am
without specifying an action or a category (similar to FIC
B), am automatically sets the action and category values as
{act=action.MAIN cat=category.LAUNCHER}. It is
Crash
Not Health
30%
24%
33%
30%
Health
8%
0%
8%
8%
Hang
Not Health
0%
0%
0%
0%
Health
62%
69%
62%
77%
No Effect
Not Health
70%
76%
67%
67%
DISTRIBUTION OF EXCEPTIONS AND CRASHES DURING QGJ-UI
TABLE V
EXPERIMENTS.
Experiment
Semi-valid
Random
#Injected Events
Exceptions Raised
Crashes
41405
41405
1496 (3.6%)
615 (1.5%)
22 (0.05%)
0 (0%)
encouraging to see that UI event handlers and adb tools
have better input validation and exception handling capabilities
compared to other application components.
During our experiments, we also found that different An-
droid components handle invalid inputs differently. For exam-
ple, if the pm utility is asked to send a random permission
string ’S0me.r@ndom.$trinG’ to some.component,
it rejects the input string saying that no such permission
exists. However,
the am utility would forward the string
’S0me.r@ndom.$trinG’ as an action string to a com-
ponent and relies on the correctness of input validation at the
component. Although this did not lead to crashes, we suggest
that input validation be more stringent, e.g., only permit action
or category strings that are registered on the device.
E. Software engineering techniques for improving robustness
Based on the results, it can be seen that Wear applications
often crash in response to unexpected intents, which cause
uncaught exceptions. Although these results are better com-
pared to [8] where NullPointerExceptions contributed
to 46% of all exceptions, there is still signiﬁcant scope for im-
provement. For example, IllegalArgumentExceptions
are often not handled correctly by apps leading to crashes.
From our insights, we suggest
three software engineering
techniques for improving robustness of Android Wear apps.
Better tool support: In the software engineering community,
there has been signiﬁcant amount of work to analyze exception
handing in Java applications [13]. The high-level idea is to
perform static analysis of the application codes to check how
exception handling codes are linked together. Features like
exception handling warning, the Analyze Stacktrace tool, and
the Lint static code inspection tool in Android Studio IDE are
steps in the right direction. Integration of Android Studio with
dynamic testing tools like QGJ can further help developers to
improve application robustness.
Research on software aging: During our experiments, we
found the Adroid Watch rebooted twice. These reboots were
not due to a single malformed intent, but rather manifested
at certain stages of the experiments. We hypothesize that
such reboot is a manifestation of error accumulation in the
Android watch. We believe that research on software aging
and rejuvenation can help detect and potentially recover from
such accumulated errors. A recent work by Cotroneo et
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:25:53 UTC from IEEE Xplore.  Restrictions apply. 
416
7
al. [14] supports our observation and suggests some metrics
for detetcting software aging in Android.
V. RELATED WORK
Android. Over the years, there have been several projects
on testing of Android applications. At a high level, these can
be broadly classiﬁed into papers that focus on Android security
and those that focus on application robustness or correctness.
In Android security testing, popular themes are—Android
permission model [15], Inter-process communication vulner-
abilities [16], and privilege escalation [17]. Among these,
research related to inter-process communication in Android
is closest
to our work. Although we do not exploit IPC
vulnerabilities, our testing attempts to ﬁnd input validation
errors in intra and inter application messages which may lead
to detection of security vulnerabilities. Non security-related
research can be broadly classiﬁed into two categories: (i)
solutions that focus on testing application GUI in Android
[6], [18], [19], and (ii) solutions that focus on ﬁnding bugs or
design ﬂaws in application components [4], [8], [20].
Our work is closest to the JarJarBinks (JJB) tool presented
by Maji et al. [8]. JJB uses different types of fuzz injection
campaigns (FIC) to detect exception handling errors in stock
Android applications and services. Our paper differs from [8]
in two signiﬁcant aspects: (i) we focus on Android Wear apps
instead of Android mobile apps and (ii) we not only inject
intent messages, but also inject UI events.
Android Wear. Existing research work on AW primar-
ily focuses on the efﬁciency, performance, and correctness
of Wear runtime and applications. Liu et al. examined the
execution of AW apps by proﬁling the OS and discovered
execution inefﬁciencies and OS design ﬂaws [3], [21]. Chen
et al. [22] characterized various properties of smartwatch
usage in the wild. Their study provides a better understanding
of wearables, and characterizes key system aspects, such as
power modeling and network behaviors. More recently, Zhang
et al. presented a testing tool based on modeling the AW
notiﬁcation mechanism, geared to achieve high coverage [19].
However, to the best of our knowledge, our paper presents
the ﬁrst robustness study of AW applications. We found
that in contrast to [8], Android Wear shows fewer crashes
from NullPointerExceptions and more crashes from
IllegalStateExceptions.
VI. CONCLUSION
Here we have done an extensive study of the reliabil-
ity of Android Wear apps through mutating inter-process
communication messages (called intents) and UI events.
We ﬁnd that while NullPointerException handling
has improved over the years on Android,
there is still a
disturbingly high incidence of other exceptions, such as
IllegalStateException. We ﬁnd that built-in apps
crash at a higher rate than popular third-party apps and a con-
ﬂuence of factors—software aging and cascading failures—
can cause the entire device to reboot even through mutating
unprivileged intents. The apps are remarkably resilient
to
mutating UI events with only 0.05% of them causing an app
crash. We shed light on three approaches that can improve
the resilience of AW apps—better IDE support, stronger input
validation, and guarding against software aging.
We acknowledge three primary threats to validity. First, our
study has used a single wearable device and thus is blind to
vendor-speciﬁc customizations. Second, while most AW apps
are two-part, with a mobile device and a wearable component,
we have ignored the inter-device interactions and focused
only on the wearable components. Third, our comparison with
Android error manifestations does not include third-party apps.
Our future work will focus on addressing these concerns.
REFERENCES
[1] Statista, “Statistics & facts on wearable technology,” 2017. [Online].
Available: https://www.statista.com/topics/1556/wearable-technology/
[2] J. Huang, A. Badam, R. Chandra, and E. B. Nightingale, “Weardrive:
Fast and energy-efﬁcient storage for wearables.” in USENIX Annual
Technical Conference, 2015, pp. 613–625.
[3] R. Liu and F. X. Lin, “Understanding the characteristics of android wear
os,” in Mobisys, 2016, pp. 151–164.
[4] A. K. Iannillo, R. Natella, D. Cotroneo, and C. Nita-Rotaru, “Chizpurﬂe:
A gray-box android fuzzer for vendor service customizations,” in ISSRE,
2017.
[5] S. R. Choudhary, A. Gorla, and A. Orso, “Automated test input gener-
ation for android: Are we there yet?(e),” in ASE, 2015, pp. 429–440.
[6] A. Machiry, R. Tahiliani, and M. Naik, “Dynodroid: An input generation
system for android apps,” in FSE, 2013, pp. 224–234.
[7] Android. UI/Application Exerciser Monkey.
[Online]. Available:
https://developer.android.com/studio/test/monkey.html
[8] A. K. Maji, F. A. Arshad, S. Bagchi, and J. S. Rellermeyer, “An empirical
study of the robustness of inter-component communication in android,”
in DSN, 2012, pp. 1–12.
[9] “Qui-Gon Jinn: An Android Wear Benchmarking Tool.” [Online].
Available: https://github.com/ebarsallo/QGJ
[10] R. Sasnauskas and J. Regehr, “Intent fuzzer: crafting intents of death,”
in WODA and PERTEA, 2014, pp. 1–5.
[11] Google. (2017) Android developers. gridviewpager. [Online]. Avail-
able: https://developer.android.com/reference/android/support/wearable/
view/GridViewPager.html
[12] Google. Android developers: Creating custom uis for wear devices.
[Online]. Available: https://developer.android.com/training/wearables/ui/
index.html
[13] C. Fu and B. G. Ryder, “Exception-chain analysis: Revealing exception
handling architecture in java server applications,” in ICSE, 2007, pp.
230–239.
[14] D. Cotroneo, F. Fucci, A. K. Iannillo, R. Natella, and R. Pietrantuono,
“Software Aging Analysis of the Android Mobile OS,” in ISSRE, 2016,
pp. 478–489.
[15] A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner, “Android
permissions demystiﬁed,” in ACM CCS, 2011, pp. 627–638.
[16] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner, “Analyzing inter-
application communication in android,” in Mobisys. ACM, 2011, pp.
239–252.
[17] M. Dietz, S. Shekhar, Y. Pisetsky, A. Shu, and D. S. Wallach, “Quire:
Lightweight provenance for smart phone operating systems.” in USENIX
Security Symposium, vol. 31, 2011.
[18] C. Hu and I. Neamtiu, “Automating gui testing for android applications,”
in Workshop on Automation of Software Test, 2011, pp. 77–83.
[19] H. Zhang and A. Rountev, “Analysis and testing of notiﬁcations in
android wear applications,” in ICSE, 2017, pp. 347–357.
[20] H. Huang, S. Zhu, K. Chen, and P. Liu, “From system services freezing
to system server shutdown in android: All you need is a loop in an app,”
in ACM CCS, 2015, pp. 1236–1247.
[21] R. Liu, L. Jiang, N. Jiang, and F. X. Lin, “Anatomizing system activities
on interactive wearable devices,” in APSys, 2015, pp. 1–7.
[22] X. Liu, T. Chen, F. Qian, Z. Guo, F. X. Lin, X. Wang, and K. Chen,
“Characterizing smartwatch usage in the wild,” in Mobisys, 2017, pp.
385–398.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:25:53 UTC from IEEE Xplore.  Restrictions apply. 
417
8