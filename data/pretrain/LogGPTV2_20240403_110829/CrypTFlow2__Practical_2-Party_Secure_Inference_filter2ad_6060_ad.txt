0 and âŸ¨DReLU(ğ‘)âŸ©ğµ
1 .
Algorithm 2 â„“-bit integer DReLU, Î int,â„“
Input: ğ‘ƒ0, ğ‘ƒ1 hold âŸ¨ğ‘âŸ©ğ¿
0 and âŸ¨ğ‘âŸ©ğ¿
Output: ğ‘ƒ0, ğ‘ƒ1 get âŸ¨DReLU(ğ‘)âŸ©ğµ
1: ğ‘ƒ0 parses its input as âŸ¨ğ‘âŸ©ğ¿
2: ğ‘ƒ0 & ğ‘ƒ1 invoke an instance of F â„“âˆ’1
3: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ sets âŸ¨DReLUâŸ©ğµ
0 = msb0||ğ‘¥0 and ğ‘ƒ1 parses its input as
1 = msb1||ğ‘¥1, s.t. ğ‘ âˆˆ {0, 1}, msbğ‘ âˆˆ {0, 1}, ğ‘¥ğ‘ âˆˆ {0, 1}â„“âˆ’1.
âŸ¨ğ‘âŸ©ğ¿
MILL, where ğ‘ƒ0â€™s input is 2â„“âˆ’1 âˆ’
1 âˆ’ ğ‘¥0 and ğ‘ƒ1â€™s input is ğ‘¥1. For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ learns âŸ¨carryâŸ©ğµ
ğ‘ .
ğ‘ = msbğ‘ âŠ• âŸ¨carryâŸ©ğµ
ğ‘ âŠ• ğ‘.
Algorithm 3 Simple Integer ring DReLU, Î ring,ğ‘›
0 and âŸ¨ğ‘âŸ©ğ‘›
Input: ğ‘ƒ0, ğ‘ƒ1 hold âŸ¨ğ‘âŸ©ğ‘›
Output: ğ‘ƒ0, ğ‘ƒ1 get âŸ¨DReLU(ğ‘)âŸ©ğµ
1: ğ‘ƒ0 & ğ‘ƒ1 invoke an instance of F ğœ‚
1 , respectively, where ğ‘ âˆˆ Zğ‘›.
0 and âŸ¨DReLU(ğ‘)âŸ©ğµ
1 .
DReLUsimple:
MILL with ğœ‚ = âŒˆlog ğ‘›âŒ‰, where
1 . For ğ‘ âˆˆ {0, 1},
and ğ‘ƒ1â€™s input is âŸ¨ğ‘âŸ©ğ‘›
(cid:16)(ğ‘› âˆ’ 1)/2 + âŸ¨ğ‘âŸ©ğ‘›
MILL, where ğ‘ƒ0â€™s input is
. For ğ‘ âˆˆ
(cid:17)
1
and ğ‘ƒ1â€™s input is âŸ¨ğ‘âŸ©ğ‘›
MILL, where ğ‘ƒ0â€™s input is
1 . For ğ‘ âˆˆ {0, 1},
(cid:17)
(cid:16)ğ‘› âˆ’ 1 âˆ’ âŸ¨ğ‘âŸ©ğ‘›
(cid:17)
0
ğ‘ƒ0â€™s input is
ğ‘ƒğ‘ learns âŸ¨wrapâŸ©ğµ
2: ğ‘ƒ0 & ğ‘ƒ1 invoke an instance of F ğœ‚+1
ğ‘ as output.
and ğ‘ƒ1â€™s input is
ğ‘ as output.
{0, 1}, ğ‘ƒğ‘ learns âŸ¨ltâŸ©ğµ
3: ğ‘ƒ0 & ğ‘ƒ1 invoke an instance of F ğœ‚+1
(cid:16)ğ‘› âˆ’ 1 âˆ’ âŸ¨ğ‘âŸ©ğ‘›
(cid:16)ğ‘› + (ğ‘› âˆ’ 1)/2 âˆ’ âŸ¨ğ‘âŸ©ğ‘›
0
0
ğ‘ƒğ‘ learns âŸ¨rtâŸ©ğµ
(cid:17)
ğ‘ as output.
4: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ invokes F 2
MUX with input
ğ‘ to learn âŸ¨ğ‘§âŸ©ğµ
ğ‘ .
5: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ outputs âŸ¨ğ‘§âŸ©ğµ
ğ‘ âŠ• âŸ¨ltâŸ©ğµ
ğ‘ âŠ• ğ‘.
choice âŸ¨wrapâŸ©ğµ
(cid:16)âŸ¨ltâŸ©ğµ
ğ‘ âŠ• âŸ¨rtâŸ©ğµ
ğ‘
and
(cid:17)
3.3 Protocol for DReLU for general Zğ‘›
We describe a protocol for F ring,ğ‘›
0 + âŸ¨ğ‘âŸ©ğ‘›
0 + âŸ¨ğ‘âŸ©ğ‘›
0 and âŸ¨ğ‘âŸ©ğ‘›
1 . Define wrap = 1{âŸ¨ğ‘âŸ©ğ‘›
1 > (ğ‘› âˆ’ 1)/2} and rt = 1{âŸ¨ğ‘âŸ©ğ‘›
DReLU that takes arithmetic shares
of ğ‘ over Zğ‘› as input and returns boolean shares of DReLU(ğ‘). For
integer rings Zğ‘›, DReLU(ğ‘) = 1 if ğ‘  ğ‘› âˆ’ 1}, lt = 1{âŸ¨ğ‘âŸ©ğ‘›
0 +
âŸ¨ğ‘âŸ©ğ‘›
1 > ğ‘› + (ğ‘› âˆ’ 1)/2}. Then,
DReLU(ğ‘) is (1 âŠ• lt) if wrap = 0, else it is (1 âŠ• rt). In Algorithm 3,
steps 1,2,3, compute these three comparisons using FMILL. Final
output can be computed using an invocation of F 2
Optimizations. We describe an optimized protocol for F ring,ğ‘›
DReLU in
Algorithm 4 that reduces the number of calls to FMILL to 2. First,
we observe that if the input of ğ‘ƒ1 is identical in all three invo-
cations, then the invocations of OT in Algorithm 1 (steps 9&10)
can be done together for the three comparisons. This reduces the
communication for each leaf OT invocation in steps 9&10 by an
additive factor of 4ğœ†. To enable this, ğ‘ƒ0, ğ‘ƒ1 add (ğ‘› âˆ’ 1)/2 to their
inputs to F ğœ‚+1
MILL in steps 1,3 (ğœ‚ = âŒˆlog ğ‘›âŒ‰). Hence, ğ‘ƒ1â€™s input to
MUX.
1 , respectively, where ğ‘ âˆˆ Zğ‘›. Let
0 and âŸ¨DReLU(ğ‘)âŸ©ğµ
1 .
ğœ‚ = âŒˆlog ğ‘›âŒ‰.
Algorithm 4 Optimized Integer ring DReLU, Î ring,ğ‘›
DReLU:
Input: ğ‘ƒ0, ğ‘ƒ1 hold âŸ¨ğ‘âŸ©ğ‘›
0 and âŸ¨ğ‘âŸ©ğ‘›
Output: ğ‘ƒ0, ğ‘ƒ1 get âŸ¨DReLU(ğ‘)âŸ©ğµ
(cid:16)
1: ğ‘ƒ0 & ğ‘ƒ1 invoke an instance of F ğœ‚+1
(cid:16)ğ‘› âˆ’ 1 âˆ’ âŸ¨ğ‘âŸ©ğ‘›
3(ğ‘› âˆ’ 1)/2 âˆ’ âŸ¨ğ‘âŸ©ğ‘›
0
ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ learns âŸ¨wrapâŸ©ğµ
ğ‘ as output.
2ğ‘› âˆ’ 1 âˆ’ âŸ¨ğ‘âŸ©ğ‘›
0
.
2: ğ‘ƒ0 sets ğ‘¥ =
if âŸ¨ğ‘âŸ©ğ‘›
(cid:17)
and ğ‘ƒ1â€™s input is (ğ‘› âˆ’ 1)/2 + âŸ¨ğ‘âŸ©ğ‘›
MILL, where ğ‘ƒ0â€™s input is
1 . For
0 > (ğ‘› âˆ’ 1)/2, else ğ‘¥ =
(cid:16)
(cid:17)
(cid:17)
(cid:16)(ğ‘› âˆ’ 1)/2 + âŸ¨ğ‘âŸ©ğ‘›
0
(cid:17)
3: ğ‘ƒ0 & ğ‘ƒ1 invoke an instance of F ğœ‚+1
ğ‘ƒ1â€™s input is
as output.
1
MILL, where ğ‘ƒ0â€™s input is ğ‘¥ and
. For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ learns âŸ¨xtâŸ©ğµ
ğ‘
ğ‘ƒ0 parses ğ‘— as ğ‘—0|| ğ‘—1 and sets ğ‘¡ ğ‘— = 1 âŠ• âŸ¨xtâŸ©ğµ
if âŸ¨ğ‘âŸ©ğ‘›
4: ğ‘ƒ0 samples âŸ¨ğ‘§âŸ©ğµ
$â† {0, 1}.
0
5: for ğ‘— = {00, 01, 10, 11} do
6:
7:
8:
9:
10:
11:
12:
13: end for
0 > (ğ‘› âˆ’ 1)/2 then
ğ‘ƒ0 sets ğ‘ â€²
ğ‘ƒ0 sets ğ‘ â€²
end if
ğ‘ƒ0 sets ğ‘  ğ‘— = ğ‘ â€²
14: ğ‘ƒ0 & ğ‘ƒ1 invoke an instance of (cid:0)4
ğ‘— = ğ‘¡ ğ‘— âˆ§ (âŸ¨wrapâŸ©ğµ
ğ‘— = ğ‘¡ ğ‘— âŠ• ((1 âŠ• ğ‘¡ ğ‘—) âˆ§ (âŸ¨wrapâŸ©ğµ
ğ‘— âŠ• âŸ¨ğ‘§âŸ©ğµ
0
0 âŠ• ğ‘—1).
else
1
0 âŠ• ğ‘—0.
0 âŠ• ğ‘—1))
(cid:1)-OT1 where ğ‘ƒ0 is the
sender with inputs {ğ‘  ğ‘—} ğ‘— and ğ‘ƒ1 is the receiver with input
âŸ¨xtâŸ©ğµ
1 . ğ‘ƒ1 sets its output as âŸ¨ğ‘§âŸ©ğµ
1 .
1 ||âŸ¨wrapâŸ©ğµ
15: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ outputs âŸ¨ğ‘§âŸ©ğµ
ğ‘ .
(cid:17)
(cid:16)
(cid:16)
(cid:17)
(cid:16)ğ‘› âˆ’ 1 âˆ’ âŸ¨ğ‘âŸ©ğ‘›
(cid:17)
,
,
0
2ğ‘› âˆ’ 1 âˆ’ âŸ¨ğ‘âŸ©ğ‘›
0
1 in all invocations and ğ‘ƒ0â€™s inputs are
in steps 1,2,3,
F ğœ‚+1
MILL is (ğ‘› âˆ’ 1)/2 + âŸ¨ğ‘âŸ©ğ‘›
3(ğ‘› âˆ’ 1)/2 âˆ’ âŸ¨ğ‘âŸ©ğ‘›
0
respectively.
Next, we observe that one of the comparisons in step 2 or step 3
0 > (ğ‘› âˆ’ 1)/2, then the result
is redundant. For instance, if âŸ¨ğ‘âŸ©ğ‘›
of the comparison lt = âŸ¨ğ‘âŸ©ğ‘›
0 + âŸ¨ğ‘âŸ©ğ‘›
1 > (ğ‘› âˆ’ 1)/2 done in step 2
is always 1. Similarly, if âŸ¨ğ‘âŸ©ğ‘›
0 â‰¤ (ğ‘› âˆ’ 1)/2, then the result of the
comparison rt = 1{âŸ¨ğ‘âŸ©ğ‘›
0 + âŸ¨ğ‘âŸ©ğ‘›
1 > ğ‘› + (ğ‘› âˆ’ 1)/2} done in step 3 is
always 0. Moreover, ğ‘ƒ0 knows based on her input âŸ¨ğ‘âŸ©ğ‘›
0 which of the
two comparisons is redundant. Hence, in the optimized protocol,
ğ‘ƒ0 and ğ‘ƒ1 always run the comparison to compute shares of wrap
and one of the other two comparisons. Note that the choice of
which comparison is omitted by ğ‘ƒ0 need not be communicated to
ğ‘ƒ1, since ğ‘ƒ1â€™s input is same in all invocations of FMILL. Moreover,
this omission does not reveal any additional information to ğ‘ƒ1 by
shares of DReLU(ğ‘). Here, ğ‘ƒ1 is the receiver and her choice bits
are the shares learnt in the two comparisons. ğ‘ƒ0 is the sender who
sets the 4 OT messages based on her input share, and two shares
learnt from the comparison protocol. We elaborate on this in the
correctness proof below.
security of FMILL. Finally, ğ‘ƒ0 and ğ‘ƒ1 can run a(cid:0)4
(cid:1)-OT1 to learn the
1
1
0 âŠ• ğ‘—âˆ—
1 ) = 1{âŸ¨ğ‘âŸ©ğ¿
(cid:1)-OT1, ğ‘§ =
MILL (step 3), xt = Reconstğµ(âŸ¨xtâŸ©ğµ
1) = (1 âŠ• rt) âˆ§ wrap.
ğ‘—âˆ— = DReLU(ğ‘), and hence, by correctness of(cid:0)4
Correctness and Security. First, by correctness of F ğœ‚+1
MILL (step 1),
wrap = Reconstğµ(âŸ¨wrapâŸ©ğµ
0 , âŸ¨wrapâŸ©ğµ
1 > ğ‘› âˆ’
0 + âŸ¨ğ‘âŸ©ğ¿
1}. Let ğ‘—âˆ— = âŸ¨xtâŸ©ğµ
1 . Then, ğ‘¡ ğ‘—âˆ— = 1 âŠ• xt. We will show
1 ||âŸ¨wrapâŸ©ğµ
that ğ‘ â€²
0 , âŸ¨ğ‘§âŸ©ğµ
Reconstğµ(âŸ¨ğ‘§âŸ©ğµ
1 ) = DReLU(ğ‘). We have the following two
cases.
0 > (ğ‘› âˆ’ 1)/2, lt = 1, and DReLU(ğ‘) = wrapâˆ§ (1 âŠ• rt).
When âŸ¨ğ‘âŸ©ğ¿
Here, by correctness of F ğœ‚+1
0 , âŸ¨xtâŸ©ğµ
1 ) =
rt. Hence, ğ‘ â€²
ğ‘—âˆ— = ğ‘¡ ğ‘—âˆ— âˆ§ (âŸ¨wrapâŸ©ğµ
0 â‰¤ (ğ‘› âˆ’ 1)/2, rt = 0, DReLU(ğ‘) is 1 âŠ• lt if wrap = 0,
When âŸ¨ğ‘âŸ©ğ¿
else 1. It can be written as (1 âŠ• lt) âŠ• (ltâˆ§ wrap). In this case, by cor-
rectness of F ğœ‚+1
MILL (step 3), xt = Reconstğµ(âŸ¨xtâŸ©ğµ
1 ) = lt. Hence,
ğ‘ â€²
ğ‘—âˆ— = ğ‘¡ ğ‘—âˆ— âŠ•((1âŠ•ğ‘¡ ğ‘—âˆ—)âˆ§(âŸ¨wrapâŸ©ğµ
1)) = (1âŠ• lt)âŠ•(ltâˆ§wrap). Since
0 is uniform, security follows in the (F ğœ‚+1
âŸ¨ğ‘§âŸ©ğµ
2ğœ† + 4 (for protocol for(cid:0)4
Communication complexity. With the above optimization, the over-
all communication complexity of our protocol for DReLU in Zğ‘›
is equivalent to 2 calls to Î ğœ‚+1
MILL where ğ‘ƒ1 has same input plus
MILL in this case
2 ğœ†(ğœ‚ + 1) + 28(ğœ‚ + 1) bits. Hence, total com-
(using ğ‘š = 4) cost < 3
2 ğœ†(ğœ‚ + 1) + 28(ğœ‚ + 1) + 2ğœ† + 4. We note that the
munication is < 3
communication complexity of simplified protocol in Algorithm 3 is
MILL, which cost 3(ğœ†ğœ‚+14ğœ‚)
approximately 3 independent calls to Î ğœ‚
bits, plus 2ğœ† + 4 bits for F 2
MUX. Thus, our optimization gives almost