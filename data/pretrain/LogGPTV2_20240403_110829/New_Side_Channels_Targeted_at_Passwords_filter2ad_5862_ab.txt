processing events with the durations observed in the timing
process.
The ﬁrst thing we observed was that the X server and
X client ran consecutively (see Figure 1). In other words,
our timing process did not run in between the X server and
X client. We determined that this was because our timing
process was CPU-intensive, so its scheduling priority was
lowered, preventing it from being scheduled before the X
client when it is ready. Other processes sometimes run in
this X processing window as well, extending the duration
between our timing measurements with unrelated process-
ing. Further, this other processing also caused variability
in X server processing times due to cache conﬂicts. Thus
the amount of noise prevented us from reliably detecting
remapped keys.
4.2. Conﬁrming the Side Channel
4.1. Single Process Experiment
In this section, we show that a single process is unable
to detect remapped keys due to noise on the system. Our
We conducted a second experiment to determine if there
is a detectable timing channel in X key processing. We did
this in two steps. First, we measured XLookupString
directly from within the X client. The idea is that if a tim-
3848
timekeyboardinterruptX serverX clienttiming processRun 1 Run 2 Run 3 Run 4 Run 5
16095
17411
13821
11917
12776
11290
37942
37410
11746
12901
17146
12171
10830
15950
12563
14462
18530
12123
14653
39439
12288
16296
11359
14813
13699
15643
10735
37272
11615
15445
12209
17275
16581
10424
14674
32001
15361
11777
12882
13609
t
r
y
euro
f
i
n
d
Table 1. Five runs containing the cycle
counts for the X client key processing of
XLookupString from an external, unprivi-
leged process where semaphores are used
to synchronize the processes. The euro char-
acter is the remapped character, and its pro-
cessing takes at least 10,000 cycles more
than any other character.
ing channel exists, then the X client processing times for
remapped keys, even measured within the X client, should
be demonstrably longer. We found that it consistently takes
over 15,000 additional cycles to process a remapped char-
acter. Non-remapped characters are processed in 5,000 to
7,000 cycles, while remapped ones would take over 25,000
cycles.
Second, we veriﬁed that we could see this timing delay
from an external process under idealized conditions. In this
case, we have the X client and the attack program share a
semaphore, such that the X client wakes the attack program
to take timing measurements every time that the X client
completes XLookupString processing. Table 1 shows
the resultant times as measured by the timing program over
eight runs. The fourth character in a password try2find
(i.e., the ’2’) is mapped to the euro character. This table
shows that the remapped character processing takes at least
10,000 cycles more than any other character. Further, the
average difference is close to 20,000 cycles. Based on these
experiments, we are encouraged that the timing channel in
X client key processing can be measured by an unprivi-
leged, external process.
4.3. Multithreaded Experiment
In this section, we show that a multithreaded timing pro-
cess is able to detect remapped keys. The reason is that
multiple threads are able to exploit the scheduler in a man-
ner that allows the threads (or tasks) to maintain the highest
interactive priority. Thus, a timing thread will run in be-
tween the X server and the X client and the X client CPU
duration can be accurately measured.
The basic idea of this attack is as follows. We remap
the keyboard prior to user password entry by determining
Figure 2. Scheduler Timeline with Multiple
Timing Processes and X Windows Process-
ing: timing processes run at same priority as
X client victim, so they run both right before
and right after X client.
a password entry program is being run (e.g., su) or that
the screen is locked (e.g., for xscreensaver). Through
maintaining several timing threads 1 at high priority, we
are able to run timing processes both immediately before
and immediately after the X client. The processing timeline
is shown in Figure 2.
In Linux 2.6, the scheduler rewards threads that sleep
over one or more clock ticks. When a thread is awakened
from sleeping, it receives a boost to its dynamic priority
based on the amount of time that it has slept. Thus, if we run
multiple timing threads, where the threads use semaphores
to awaken each other in a synchronous manner, then most of
the time a thread will be sleeping and thus receive a bonus
vs. being decremented.
Thus, at any clock tick, one of the timing threads will be
running, so its dynamic priority will be decremented. The
other timing threads will be asleep, and they will have their
dynamic priority increased, if an increase is possible (see
Fig 3). (An increase will not be possible if the thread has
already received the maximum bonus adjustment to its pri-
ority). Thus we see that if we run n timing threads, then on
average, we expect a given thread to be eligible for a pri-
ority increment n−1
n of the time, and to receive a priority
decrement 1
n of the time.
In Linux 2.6, interactive threads receive a maximum
bonus of -5 to their dynamic priority.
If there are more
than two timing threads, then their dynamic priorities will
tend towards their static priority minus 5 (i.e., a lower pri-
ority is better for scheduling). The X client will also tend
toward the same priority. Thus when the X client awakes
and becomes runnable (due to input from the X server), it
will be placed in a priority queue behind the existing timing
threads. Therefore, a timing thread will run immediately
prior to the X client, and another one will run after the X
client. Thus, we should obtain an accurate indication of the
remap status of the individual keys.
1In Linux, tasks represent both processes and threads, so the sched-
uler treats threads as it would a process. We use the term threads to indicate
that these Linux tasks share an address space, as threads in the same pro-
cess would.
3949
timekeyboardinterruptX serverX clientdistinct timing tasks in Linux 2.6Run 1 Run 2 Run 3 Run 4 Run 5
47572
47147
43398
31598
30639
29026
64316
65099
28793
31195
45323
27953
33041
40314
27704
43798
42468
33740
39900
53888
39115
33941
40005
32707
47223
32462
35825
62909
32239
40367
28643
28644
42488
30385
26788
59987
35956
32694
46316
29866
t
r
y
euro
f
i
n
d
Figure 3. Timing Process Priority Adjust-
ments in Linux 2.6. Only the process that is
interrupted by the timer interrupt has its pri-
ority decremented. Other processes see their
priority incremented. Thus running a large
number of timing processes results in each
maintaining high priority.
4.3.1 Attack Program Design
We describe the design for the Linux 2.6 attack pro-
gram. The idea is to use multiple timing threads that time
the victim X client’s processing. These threads will use
semaphores to hand-off responsibility for timing. The basic
pseudo-code skeleton for each timing thread is as follows:
while() { // timing loop
sem_wait(sem_id1); // block awaiting
// increment of semaphore
time1 = sample_the_timer();
if(time1 is in range of interest)
record time1;
sem_post(sem_id2); // increment the
// semaphore for next timing thread
}
The results for the implementation of this approach are
shown in Table 2. Here again, we entered the string
“try2ﬁnd”, with the character ‘2’ remapped. As we can
see, the remapped character stands out very clearly. Reg-
ular characters are in the range of 30,000 to 45,000 cycles.
The line for the euro character shows that the duration of
the remapped characters ranges between 55,000 and 75,000
cycles.
4.3.2 Solving the Noise Problem
In the above attack, the problem of extraneous process-
ing exists. In particular, other activity can result in addi-
tional time durations that are in the same range as the tim-
ing measurements. Thus, we have a noisy channel where
the main noise component consists of additional measure-
ments. We have largely solved this problem by noting that
the keyboard processing consists of the X server processing
(around 150,000 to 250,000 cycles) immediately followed
Table 2. Timing the keypresses from the mul-
tithreaded attack program (timed in cycles).
X Server Duration X Client Duration Remap Status
Not remapped
228086
Not remapped
157738
Remapped
169017
208754
Not remapped
Not remapped
144332
Not remapped
249284
219884
Not remapped
42068
34192
51962
37976
27710
42095
45322
Table 3. Output Showing Remapped and Non-
Remapped Keys (timed in cycles)
by the X client processing (approximately 30,000 to 80,000
cycles). The use of this signature helps to remove most of
the noise from the channel that would be present if we only
focused on the X client durations.
Table 3 shows a typical output sequence. The left col-
umn contains X server process durations (in cycles), and the
second column contains X client process durations. These
pairs of values are readily identiﬁable in the timed process
durations, and our test results indicate that false positives
(consisting of a pair of values in the same range) occur very
rarely. The same is true for false negatives with the excep-
tion of the ﬁrst character; occasionally we miss (a miss oc-
curs when the X client processing doesn’t immediately fol-
low an X server processing time) the X client processing for
this character since the X client’s priority may not have fully
recovered from it’s initial processing when it handles the
ﬁrst password character. Succeeding characters receive the
beneﬁt of the extra sleep time which allows the X client’s
priority to be as high as the timing threads. Also, the 1st
password character processing is more likely to suffer cache
misses vs. later characters. One of the timing threads runs
before, between, and after each pair of processing durations
in the ﬁgure.
4.3.3 When to Map Back - Identiﬁcation of Return Key
Password entry is often immediately followed by a return
character. If the timing process is able to identify the return
character, then it can remap the keyboard back to the orig-
4050
timetimer interruptfor "clock tick"process whose priority decremented -- interrupted by the timer interruptother processes have their priorities incremented Run 1
Run 2
181469 (X)
178566 (X)
120042
198459
128269
95050
125654
207160
134359
82294
Table 4. Return Key Signature, as seen in two
typical runs starting with X server processing
(X), measured in cycles
inal state at that point. In this way, the timing process will
not be detected since subsequent keyboard output will echo
in the normal manner.
In our Linux 2.6 experiments, we have observed that our
X client has a consistent signature for the return key pro-
cessing. This is partially due to the fact that our X client
prints to the terminal upon reading the return. Many X
clients have similar behaviour upon successful logon. The
signature for two distinct runs is shown in Table 4.
We see an initial X server processing time immediately
followed by several other X processing times.
4.3.4 Test Results
Using the algorithm described above, we ran tests against a
generic X client on a Linux 2.6 system. Each test consists
of entering the same 8 character password. During the test,
the timing program runs and we subsequently analyzed the
results. We remapped a single key per test. Our results are
given in Table 5. The amount of noise was minimal. Our
results for the ﬁrst password character were the most prob-
lematic, but otherwise the results are fairly accurate. In par-
ticular, if we throw out the ﬁrst character as unreliable, then
for 84 characters transmitted, we have one error (in the 2nd
character), 4 not received characters (but we know that we
have missed these particular characters), and 79 characters
transmitted correctly, which is over a 90% success rate.
Upper case characters include both a shift key processing
time in addition to the upper case key time. The upper case
processing time is longer when the key is remapped. Al-
though we tested upper case characters, we did not actually
analyze any passwords that included upper case characters.
We believe such analysis would be straightforward.
We also ran tests over several (up to 6) minutes to exam-
ine the priorities of our timing threads. We conﬁrmed (using
the ps command) that the threads remained at the highest
interactive priority throughout the interval. Thus our multi-
threaded design remains priority stable.
4.3.5 Optimal Remapping Strategy
We also experimented with remapping multiple keys. When
more than one password character is remapped, the 2nd
Test Results
1
2
3
4
5
6
Missed 1st character
No errors
Missed 1st character