Programmer’s Manual, Volume 2: System
Programming, revision 3.22 edition, September 2012.
[5] N. Binkert, B. Beckmann, G. Black, S. K. Reinhardt,
A. Saidi, A. Basu, J. Hestness, D. R. Hower,
T. Krishna, S. Sardashti, R. Sen, K. Sewell,
M. Shoaib, N. Vaish, M. D. Hill, and D. A. Wood. The
gem5 simulator. SIGARCH Comput. Archit. News,
39(2):1–7, Aug. 2011.
[6] Bluespec, Inc. Bluespec SystemVerilog.
[7] J. Brown, J. Grossman, A. Huang, and T. F. Knight,
Jr. A capability representation with embedded address
and nearly-exact object bounds. Technical Report 5,
MIT AI Lab, April 2000. Aries Project.
[8] N. P. Carter, S. W. Keckler, and W. J. Dally.
Hardware support for fast capability-based addressing.
In Proceedings of the international conference on
Architectural support for programming languages and
operating systems, ASPLOS-VI, pages 319–327, 1994.
[9] S. Chen, B. Falsaﬁ, P. B. Gibbons, M. Kozuch, T. C.
Mowry, R. Teodorescu, A. Ailamaki, L. Fix, G. R.
Ganger, B. Lin, and S. W. Schlosser. Log-based
architectures for general-purpose monitoring of
deployed code. In 1st Workshop on Architectural and
System Support for Improving Software Dependability
(ASID), pages 63–65. ACM, 2006.
[10] R. P. Colwell, E. F. Gehringer, and E. D. Jensen.
Performance eﬀects of architectural complexity in the
Intel 432. ACM Trans. Comput. Syst., 6:296–339,
August 1988.
[11] J. Criswell, A. Lenharth, D. Dhurjati, and V. Adve.
Secure virtual architecture: A safe execution
Figure 10: Last two stages of pipeline for BIMA encoding
Execute/Memory stage, and we move the update distance
circuit (Update Distance) to the Validate/Writeback stage.
Fig. 10 shows the resulting pipeline.
First we note that this change does not aﬀect bypasses
or stalls for any non-pointer computations. The number of
pipeline stages stays the same, and any other unit remains
unchanged. Let us now consider an lw-addp pair in this
pipeline. The addp can happen immediately as the value
(pointer) from memory can be bypassed in one cycle (dot-
ted bypass in Fig. 10). While addp is computing the new
address, Decode 2 in the Validate/Writeback will have ﬁn-
ished decoding the distances. Then the distances needed for
addp will be available before the Validate/Writeback stage,
and thus it will need no stall cycles. Similarly, an addp-addp
pair does not cause any stalls either because we can bypass
the Dunder and Dover in the same fashion (dashed bypass
in Fig. 10).
To avoid any stalls for an addp-lw pair, we use speculative
execution. Since the target address is available by the end
of the Execute stage, we bypass the updated address and
load the value assuming the pointer is in bounds. When
the addp distance update completes and the pointer used
was determined to be out-of-bounds, we kill the load result,
ﬂush the pipeline, and trap to the error handler.
As a result, we maintain the same clock rate and stall con-
ditions as the baseline processor without the Pointer Unit.
That is, the BIMA encoding runs just as fast as the base-
line processor without spatial safety checking (0% runtime
overhead).
6. CONCLUSIONS
We have shown how it is possible to support fully me-
diated, ﬁne-grained spatial safety without sacriﬁcing perfor-
mance. An appropriately low-fat pointer encoding keeps the
memory impact small (64b pointers for a 46b address space)
while simultaneously guaranteeing small and fast hardware
decoding and small (<3%) memory fragmentation overhead.
Even with an additional 8b tag on every word, the total
memory overhead is under 16%. Suitable pipelining guar-
antees the extra work for decoding the low-fat pointer en-
coding does not create new stall cycles for the processor
pipeline. Pointer updates are no more complex than addi-
tions, guaranteeing they do not degrade the processor clock
cycle. Since software presents a large attack surface area
(millions of lines of code in modern applications and kernels)
with demonstrated high rates of vulnerability, there is an ad-
730environment for commodity operating systems. In
Proceedings of the Symposium on Operating Systems
Principles, October 2007.
In ATEC ’02: Proceedings of the General Track of the
annual conference on USENIX Annual Technical
Conference, pages 275–288, 2002.
[12] D. Y. Deng and G. E. Suh. High-performance parallel
[28] D. Johnson. The Intel 432: A VLSI Architecture for
accelerator for ﬂexible and eﬃcient run-time
monitoring. In IEEE/IFIP International Conference
on Dependable Systems and Networks (DSN), pages
1–12. IEEE Computer Society, 2012.
Fault-Tolerant Computer Systems. Computer,
17:40–48, August 1984.
[29] H. M. Levy. Capability Based Computer Systems.
Digital Press, 1984.
[13] P. J. Denning and S. C. Schwartz. Properties of the
[30] S. Nagarakatte. Practical Low-overhead Enforcement
working-set model. Communications of the ACM,
15(3):191–198, March 1972.
of Memory Safety for C Programs. PhD thesis,
University of Pennsylvania, 2012.
[14] J. B. Dennis and E. C. Van Horn. Programming
[31] S. Nagarakatte, J. Zhao, M. M. K. Martin, and
semantics for multiprogrammed computations.
Communications of the ACM, 9(3):143–155, March
1966.
[15] J. Devietti, C. Blundell, M. M. K. Martin, and
S. Zdancewic. HardBound: Architectural support for
spatial safety of the C programming language. In
Proceedings of the International Conference on
Architectural Support for Programming Languages and
Operating Systems, pages 103–114, 2008.
[16] U. Dhawan, A. Kwon, E. Kadric, C. Hri¸tcu, B. C.
Pierce, J. M. Smith, A. DeHon, G. Malecha,
G. Morrisett, T. F. Knight, Jr., A. Sutherland,
T. Hawkins, A. Zyxnfryx, D. Wittenberg, P. Trei,
S. Ray, and G. Sullivan. Hardware support for safety
interlocks and introspection. In SASO Workshop on
Adaptive Host and Network Security, Sept. 2012.
[17] R. S. Fabry. Capability-based Addressing.
Communications of the ACM, 17(7):403–412, July
1974.
[18] E. A. Feustel. On the advantages of tagged
architecture. IEEE Transactions on Computers,
C-22(7):644–656, July 1973.
[19] E. F. Gehringer and J. L. Keedy. Tagged architecture:
How compelling are its advantages? In Proceedings of
the 12th International Symposium on Computer
Architecture, pages 162–170, 1985.
[20] R. Greenblatt, T. Knight, Jr., J. Holloway, D. Moon,
and D. Weinreb. The LISP machine. In Interactive
Programming Environments. McGraw-Hill, 1984.
[21] N. Hasabnis, A. Misra, and R. Sekar. Light-weight
bounds checking. In Proceedings of the Tenth
International Symposium on Code Generation and
Optimization, pages 135–144, 2012.
[22] J. L. Henning. SPEC CPU2006 benchmark
descriptions. SIGARCH Comput. Archit. News,
34(4):1–17, September 2006.
[23] M. E. Houdek, F. G. Soltis, and R. L. Hoﬀman. IBM
System/38 Support for Capability-based Addressing.
In Proceedings of the Eighth Annual Symposium on
Computer Architecture, pages 341–348, 1981.
[24] C. Hri¸tcu, M. Greenberg, B. Karel, B. C. Pierce, and
G. Morrisett. All your IFCException are belong to us.
In 34th IEEE Symposium on Security and Privacy,
pages 3–17. IEEE Computer Society Press, May 2013.
[25] IBM. IBM System/360 Principles of Operation. 1968.
[26] Intel Corporation. Intel64 and IA-32 Architectures
Software Developer’s Manual, August 2012.
[27] T. Jim, J. G. Morrisett, D. Grossman, M. W. Hicks,
J. Cheney, and Y. Wang. Cyclone: A safe dialect of C.
S. Zdancewic. Softbound: Highly compatible and
complete spatial memory safety for C. In Proceedings
of the ACM SIGPLAN Conference on Programming
Language Design and Implementation, pages 245–258,
2009.
[32] S. Nagarakatte, J. Zhao, M. M. K. Martin, and
S. Zdancewic. CETS: Compiler enforced temporal
safety for C. In Proceedings of the International
Symposium on Memory Management, pages 31–40,
2010.
[33] G. C. Necula, J. Condit, M. Harren, S. McPeak, and
W. Weimer. CCured: type-safe retroﬁtting of legacy
software. ACM Trans. Program. Lang. Syst.,
27(3):477–526, May 2005.
[34] R. M. Needham and R. D. H. Walker. The Cambridge
CAP computer and its protection system. In
Proceedings of the Symposium on Operating Systems
Principles, pages 1–10, Nov. 1977.
[35] E. I. Organick. The MULTICS System: An
Examination of Its Structure. MIT Press, 1972.
[36] E. I. Organick. Computer System Organization: The
B5700/B6700 Series. Academic Press, 1973.
[37] E. I. Organick. A Programmer’s View of the Intel 432
System. McGraw-Hill, 1983.
[38] A. T. Phillips and J. S. Tan. Exploring security
vulnerabilities by exploiting buﬀer overﬂow using the
MIPS ISA. In Proceedings of the SIGCSE technical
symposium on Computer science education, pages
172–176, New York, NY, USA, 2003. ACM.
[39] O. Ruwase and M. S. Lam. A practical dynamic buﬀer
overﬂow detector. In Proceedings of the 11th Annual
Network and Distributed System Security Symposium,
pages 159–169, 2004.
[40] J. S. Shapiro, J. M. Smith, and D. J. Farber. Eros: a
fast capability system. In Proceedings of the
Symposium on Operating Systems Principles, pages
170–185. ACM, 1999.
[41] R. L. Sites. Alpha AXP Architecture. Digital
Technical Journal, 4(4):1–17, 1992. Special Issue.
[42] R. N. M. Watson, J. Anderson, B. Laurie, and
K. Kennaway. Capsicum: practical capabilities for
UNIX. In Proceedings of the 19th USENIX Security
Symposium, Washington, DC, August 2010.
[43] R. N. M. Watson, P. G. Neumann, J. Woodruﬀ,
J. Anderson, R. Anderson, N. Dave, B. Laurie, S. W.
Moore, S. J. Murdoch, P. Paeps, M. Roe, and
H. Saidi. CHERI: a research platform deconﬂating
hardware virtualization and protection. In Proc.
RESoLVE, March 2012.
731[44] M. V. Wilkes and R. M. Needham. The Cambridge
CAP Computer and Its Operating System. North
Holland, 1979.
[45] W. Wulf, E. Cohen, W. Corwin, A. Jones, R. Levin,
C. Pierson, and F. Pollack. Hydra: The kernel of a
multiprocessor operating system. Communications of
the ACM, 17(6):337–345, June 1974.
[46] W. A. Wulf, R. Levin, and S. P. Harbison.
HYDRA/C.mmp: An Experimental Computer System.
McGraw-Hill, 1981.
[47] Xilinx, Inc. Virtex-6 FPGA ML605 Evaluation Kit.
[48] Xilinx, Inc., 2100 Logic Drive, San Jose, CA 95124.
Virtex-6 FPGA Data Sheet: DC and Switching
Characteristics, September 2011. DS512.
[49] Xilinx, Inc., 2100 Logic Drive, San Jose, CA 95124.
LogiCORE IP Floating-Point Operator v6.0, January
2012.
[50] Y. Younan, P. Philippaerts, L. Cavallaro, R. Sekar,
F. Piessens, and W. Joosen. Paricheck: an eﬃcient
pointer arithmetic checker for C programs. In
Proceedings of the 5th ACM Symposium on
Information, Computer and Communications Security,
pages 145–156, 2010.
APPENDIX
A. DYNAMIC INSTRUCTION IMPACT
Our main focus is to show the beneﬁt of native hardware
support to enforce spatial memory safety on every instruc-
tion. If we were to enforce the same level of checking using a
conventional processor, we would need to replace a number
of primitive operations with instruction sequences like those
shown in Tab. 1 where in the second column we show the
additional operations needed for spatial checking. In reality
the compiler would add these extra instructions in the bi-
nary. However, we use instruction-trace based simulations
to get a crude estimate of the impact on dynamic instruction
count for such an enforcement without modifying any com-
piler. Our estimates illustrate how much work our invest-
ment in parallel checking hardware and compact encoding
is eﬀectively doing. These estimates are necessarily crude
since the instruction sequences can be subverted below the
level of the compiler, and do not account for optimizations
a compiler could do to eliminate redundant checks. Also,
we assume a single-issue in-order pipeline, whereas, on a
superscalar processor, some of the extra instructions would
ﬁt in otherwise unused issue slots. For example, SoftBound
reports only a 67% runtime overhead on 133% instruction
count overhead [31].
Table 1: Spatial Checking for Processors with no Fat Pointer
Hardware Support
Primitive
Operation
pointer arithmetic
$d←$s+$t
(Sec. 4.8.3)
store non-pointer
mem[$s]←$t
(Sec. 4.8.4)
store pointer
mem[$s]←$t
(Sec. 4.8.4)
load non-pointer
$t←mem[$s]
(Sec 4.8.5)
load pointer
$t←mem[$s]
(Sec. 4.8.5)
register target
PC←$s
ALPHA
Operations
addq $d.A, $s.A, $t
cmpult $q,$d.A,$s.base
cmpult $r,$s.bound,$d.A
or $q,$q,$r
blbs $q, bounds error
lda $d.base,$s.base,0
lda $d.bound,$s.bound,0
cmpult $q,$s.A,$s.base
cmpult $r,$s.bound,$s.A
or $q,$q,$r
blbs $q,bounds error
stq $t,0($s)
cmpult $q,$s.A,$s.base
lda $r,$s.A,2
cmpult $r,$s.bound,$r
or $q,$q,$r
blbs $q,bounds error
stq $t.A,0($s.A)
stq $t.base,1($s.A)
stq $t.bound,2($s.A)
cmpult $q,$s.A,$s.base
cmpult $r,$s.bound,$s.A
or $q,$q,$r
blbs $q,bounds error
ldq $t,0($s)
cmpult $q,$s.A,$s.base
lda $r,$s.A,2
cmpult $r,$s.bound,$r
or $q,$q,$r
blbs $q,bounds error
ldq $t.A,0($s.A)
ldq $t.base,1($s.A)
ldq $t.bound,2($s.A)
cmpult $q,$s.A,$s.base
cmpult $r,$s.bound,$s.A
or $q,$q,$r
blbs $q,bounds error
jr $s.A
With all the registers annotated, we can then identify which
operation must be an addp in our fat pointer architecture
and which load and store operations are moving pointers to
and from memory. Once identiﬁed, we perform a weighted
sum of operations using the instruction counts from Tab. 1.
A.1 Methodology
A.2 Overhead
We evaluate the impact of the additional instructions for
performing spatial checks on memory, on the programs from
the SPEC2006 Benchmark Suite [22]. Instruction traces are
produced using the gem5 [5] environment simulating a 64-bit
ALPHA ISA [41]. Since the ALPHA ISA used does not type
pointers diﬀerently from integers, we must determine which
values are actually pointers and require additional pointer
operations. To do this, we ﬁrst perform a pre-pass dataﬂow
analysis that marks all registers used as addresses in load
and store operations as pointers, then propagate that type
information through the lifetime and use of those registers.
Fig. 1 shows the estimated dynamic instructions in a non-
fat pointer hardware ALPHA architecture performing spa-
tial checks in software in comparison to our proposed archi-
tecture (see Sec. 3) with hardware support for fat pointers
for a period of ﬁrst 1 billion cycles. From the ﬁgure, we can
observe that there is a maximum of 300% and on average,
about 220% overhead in the number of dynamic instructions
executed for performing spatial checks in software.
732