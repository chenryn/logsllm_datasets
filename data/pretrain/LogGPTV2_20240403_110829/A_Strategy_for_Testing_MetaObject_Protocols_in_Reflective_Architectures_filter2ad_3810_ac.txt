the 
the 
through 
introspection  mechanisms, 
structural 
intercession  mechanisms  are  controllable 
the 
MetuControl interface. Their role is to allow a metaobject to 
update the state of its base-level object according the current 
needs of  the non-functional requirements implemented  at the 
meta-level: the attribute values have to be forced to the input 
parameter  values  used  in  the  activation  request  sent  to  the 
MetuControl interface. The test objectives are then  to  verify 
that  the  object  state  is  updated  according  to  the  input 
parameter values used in that activation. 
I 
server object 
oracle object 
Figure 5: Testing of the introspection 
mechanisms of the MOP 
First,  the  test driver  object  sends  requests  to  the  Service 
interface  in  order  to  initialize all  the  attributes of  the  server 
object  to  values  supplied  in  the  requests.  The  requests  are 
transmitted to the server object by  way of the reification and 
behavioral mechanisms that have already been tested (step 1). 
The server object notifies the driver object of  the end of the 
initialization process (step 2). Then, the driver object sends a 
request  to  the  MefuControl  interface  for  activating  the 
introspection  mechanisms  (step  3).  The  metaobject  should 
trigger  the  mechanisms  (step  4)  and  return  the  observed 
attribute values (step 5) to the driver object. Finally (step 6), 
the driver object sends these values to the oracle object together 
with  the  values it supplied in  the  initialization requests. The 
oracle procedure compares both sets of values (step 7). 
The requests to be sent by the driver object to initialize the 
state  of  the  server object (step  1)  are strongly dependent on 
the level of  encapsulation defined by  the server object on its 
the tmnaltzanon stale 
server object 
oracle object 
Figure 6: Testing of the structural 
intercession mechanisms of the MOP 
Figure 6 shows the test environment, which makes use of 
all the MOP mechanisms already tested. The metaobject and 
the oracle object are identical to the ones shown in  Figure 5, 
which  may  be  reused.  Here,  the  server  object  must  offer 
appropriate  methcd(s)  for  modifying  the  values  of  its 
attributes.  Steps  1  and  2  correspond  to  the  initialization 
process  defined  in  Section  3.4. Then,  the  test  driver  object 
send  requests  to  execute  methcd(s)  of  the  server object  that 
change  the  values  of  all  its  attributes  (step  3).  After 
notification of the end of the modification process (step 4), it 
sends a  request  to the MetuControl  interface to  activate  the 
'  Another  possibility  consists  in  using  specific  implementation 
language  features  like  the  friend  functions  of C++  or  the  default 
attributes  of  Java  to  break  the  object  encapsulation.  Using  these 
features, the  test driver is able to control (and thus, initialize) the server 
object state directly, i.e., without using the MOP mechanisms in step  I .  
But  this solution  is  language dependent while Figure 5 works  for any 
MOP implementation. 
332 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:26 UTC from IEEE Xplore.  Restrictions apply. 
structural  intercession  mechanisms  (step  5).  The  input 
parameter values  supplied in  the request are identical to the 
ones used in step I  (initialization), and thus are different from 
the current state of  the server object. The metaobject should 
trigger  the  mechanisms  under  test  (step  6). Then,  the  test 
driver activates the  introspection mechanisms (step 7) to get 
the object state after intercession (step 8). Finally (step 9), it 
sends these values to the oracle object together with the values 
it supplied in step 1. The oracle object compares both  sets of 
values (step 10). 
intercession  methods  that  are  used  by  metaobjects  for 
triggering the  execution  of  the  reified  invocations. From  a 
structural  viewpoint, the  protocol  considers  the  state  of  an 
object  as a  list  of  attribute  values  that  can  be  saved  and 
restored 
the 
BuseSaveState  and  Base-Restorestate  operations  of  the 
Object interface. 
the  meta-level  using 
respectively 
from 
Section 4.1  provides  implementation details on  the  code 
under test. Then, Section 4.2 briefly describes the application 
of the strategy and outlines the first results obtained. 
4.  Case Study: The FY(IE@DSMOP 
4.1. MOP Implementation 
The test strategy previously defined is illustrated on a real 
MOP, which is the corner stone of the T!IE@DSarchitecture 
[ 131. The system model defined by  this architecture considers 
both  objects  and  metaobjects  as  being  CORBA  entities 
mapped to independent system processes for fault containment 
reasons. These entities interact through well-known interfaces 
specified using the IDL language. The interfaces of the MOP 
and  the  Service interfaces exported by  server objects are all 
defined using that language (see Figure 7). 
typedef Methodldentifier int; 
typedef Arguments any; 
typedef State any; 
interface MetaObject( 
I/ RElFlCATlON MECHANISMS 
void MetaxStartUp(Method1dentifier constructorlD, in Arguments a): 
void Meta-MethodCall(Method1dentifier  methodlD, inout Arguments a); 
void Meta-Cleanup(  ): 
I/ LINK MANAGEMENT MECHANISMS 
Object Meta-Getobject( ); 
Void Meta-SetObject(Metaobject newMetaobject): 
1; 
interface Object( 
11 INTROSPECTION MECHANISMS 
State Base-Savestate(  ); 
/I STRUCTURAL INTERCESSION MECHANISMS 
void Base-RestoreState(State  new State): 
/I BEHAVIORAL INTERCESSION MECHANISMS 
void Base-StartUp(Method1dentifier constructorlD. in Arguments a); 
void Base-MethodCall(Method1dentifier methodlD,  inout Arguments a); 
void Base-Cleanup(  ); 
//LINK MANAGEMENT MECHANISMS 
Metaobject Base-GetMetaobject(  ); 
void Base-SetMetaobject(Meta0bject  newMetaobject); 
t; 
Figure 7. The z y I ~ % ! Q s  MOP 
This  protocol  is  an  implementation of  the  generic MOP 
presented  in  Section  2.2.  The  execution  model  it  defines 
differentiates between three types of  invocations: constructor 
(Start  Up) invocations, method  invocations (related  to  the 
operations of the Service interface), and destructor (Clean Up) 
invocations. Consequently, the MetaObjecr interface contains 
three  method; 
for  the  reification  of  these  invocations. 
Symmetrically,  the  Object  interface  also  provides  three 
In  the  TXIE?@S  architecture,  IDL  interfaces  defining 
object  services  are  implemented  using  C++  classes.  In 
practice, each  Service interface  is  mapped  to  a  set  of  class 
public methods, which must be  implemented by  each server 
object exporting that service. 
The  code  of  the  MOP  is  automatically generated using 
OpenC++. an open compiler for C++ [ 141. OpenC++ enables 
the definition of a set of transfornlation rules that can be used 
to  customize  the  compilation  of  C++  classes.  In  our  case 
study, these  transformation rules are  specialized in  order  to 
generate  reflective classes  from  non-reflective ones.  These 
reflective  classes  contain  the  non-reflective  code  of  the 
original classes plus the code of the MOP, which is the code 
under test (Figure 8). 
',,  Code  1 
\ 
/I;on-reflectiJ, 
'.-// 
Figure 8. Open compilation process 
-. 
. 
,/Reflee 
t i v h ,  
: 
I (Non-Reflective] 
\,  code + M O ~
\/ 
Code 
Let  us  consider  the  example  of  a  class  whose  service 
consists in counting the number of requests received through 
its  Service  interface.  The  IDL  definition  of  that  service 
interface is shown in  Figure 9.a and its C++ implementation 
in  Figure 9.b.  From  that  code, OpenC++  (v2.5.9)  generates 
in  Figure  10.  This  class 
the  reflective  class  shown 
encapsulates the capabilities provided by the original class and 
also supplies the reflective mechanisms of  the MOP. These 
mechanisms  are  automatically  generated  according  to  the 
code transformation rules associated with the MOP definition. 
It is worth noting that although the code added to the original 
class might appear quite large, its size does not  depend very 
much on the class size: for larger classes the size overhead is 
thus limited. 
333 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:26 UTC from IEEE Xplore.  Restrictions apply. 
interface Countinglnvocations( 
long count( ); 
1; 
class Countinglnvocations-lmpl( 
private: int count; 
public: 
int count( )( return ++count; ) 
-Countinglnvocations-lmpl(  ) 
(a) IDL  Service interface 
(b) C++ implementation 
Figure 9. Non-Reflective source code 
class Countinglnvocatioris-lmpl( 
I/ ORIGINAL CODE 
private: int count; 
public: 
WrappedCountinglnvocations-Imp1 (int i)(count=i;) 
int Wrappedcount( )( ++count; ) 
WrappedDestructor( ){ ) 
/I RElFlCATlON MECHANISMS 
Countinglnvocations-Imp1 (int i)( 
ConstructorArgs args; 
Base-SetMetaObject( MOFactory.CreateMO(object-CORBA-ref)); 
args.i = i; 
BaseGetMetaObject()+Meta-StartUp(const~ctorlD.args); 
1 
int count( )( 
that  get 
separate  CORBA  entities 
interconnection  by 
exchanging their respective CORBA references. Due to space 
limitation,  we  cannot  describe  these  initial  experiments. 
Hence, we focus on the test experiments carried out according 
to the  four testing levels of the generic test strategy. In these 
test  experiments,  we  have  used  a  probabilistic  method  for 
generating the test case input values, called statistical testing 
(see e.g., [ 171). Here, we do not elaborate on the issue of  how 
to  select test  input values, which  is out  of  the  scope of  this 
paper 
I1 STRUCTURAL INTERCESSION MECHANISMS 
void Base-RestoreState(Counting1nvocationsState st)( 
count = st.count; 
1 
I1 BEHAVIORAL INTERCESSION MECHANISMS 
void Base-StartUp(int  methodlD, any args)( 
if (methodlD == constructorlD) 
WrappedCountinglnvocations-lmpl(args.i) ; 
1 
void Base-HandleCall(int  methodlD, any args)( 
if (methodlD == countlD) 
args.return = Wrappedcount(); 
) 
void Base-Cleanup(  )( 
WrappedDestructor( )  ; 
CountArgs args; 
Base-GetMetaObject()+Meta-MethodCall(countlD,args); 
return(args.return) ; 
I 
-Countinglnvocations-Imp1  ( ){ 
Base-GetMetaObject()+Meta-Cleanup(  ); 
/I INTROSPECTION MECHANISMS 
State Base-Savestate(  ){ 
CountinglnvocationsState st; 
skount = count; 
return st; 
I 
I1 LINK MANAGEMENT MECHANISMS 
MetaObject Base-GetMetaObject( )( 
Return mo; 
I 
void Base_SetMetaObject(MetaObject mobj)( 
mobj = duplicate-reference(m0bj); 
private: 
MetaObject mo; 
1 :  
Figure 10. Reflective source code 
The  reflective  classes  generated  by  OpenC++  are 
compiled  using  a regular  C++  compiler  (gcc  v2.5.95 in  our 
case study). The instantiation of these classes is made through 
the  Object  Factories  of  the  system,  which  are  runtime 
services devoted to the creation and destruction of base-level 
objects.  Symmetrically, 
the  existence  of  Mefaobject 
Factories,  which  are  responsible  for  creating  and  deleting 
metaobjects,  is  also  required.  These  factories  are  CORBA 
services running on top of the Solaris release of  the Orbacus 
ORB, which provides the middleware  infrastructure required 
for exercising the code under test. 
Testing  level  1:  Reification  mechanisms  (Figure 
3).  Different  IDL  data  types  were  used  to  define  the 
object Service  interface.  For  instance, Figure  11 shows 
the  interface  defined  for  checking  the  capacity  of  the 
MOP  for  handling  long  data  types.  Three  different 