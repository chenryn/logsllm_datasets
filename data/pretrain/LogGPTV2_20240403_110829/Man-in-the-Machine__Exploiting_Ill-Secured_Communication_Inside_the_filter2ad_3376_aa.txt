title:Man-in-the-Machine: Exploiting Ill-Secured Communication Inside the
Computer
author:Thanh Bui and
Siddharth Prakash Rao and
Markku Antikainen and
Viswanathan Manihatty Bojan and
Tuomas Aura
Man-in-the-Machine: Exploiting Ill-Secured 
Communication Inside the Computer
Thanh Bui and Siddharth Prakash Rao, Aalto University; Markku Antikainen, University of 
Helsinki; Viswanathan Manihatty Bojan and Tuomas Aura, Aalto University
https://www.usenix.org/conference/usenixsecurity18/presentation/bui
This paper is included in the Proceedings of the 
27th USENIX Security Symposium.
August 15–17, 2018 • Baltimore, MD, USA
978-1-939133-04-5
Open access to the Proceedings of the 27th USENIX Security Symposium is sponsored by USENIX.Man-in-the-Machine: Exploiting Ill-Secured Communication
Inside the Computer
Thanh Bui*, Siddharth Rao*, Markku Antikainen†, Viswanathan Bojan*, and Tuomas Aura*
* Aalto University † University of Helsinki, Helsinki Institute for Information Technology
Abstract
Operating systems provide various inter-process commu-
nication (IPC) mechanisms. Software applications typi-
cally use IPC for communication between frontend and
backend components, which run in different processes
on the same computer. This paper studies the security
of how the IPC mechanisms are used in PC, Mac and
Linux software. We describe attacks where a nonprivi-
leged process impersonates the IPC communication end-
points. The attacks are closely related to impersonation
and man-in-the-middle attacks on computer networks but
take place inside one computer. The vulnerable IPC
methods are ones where a server process binds to a name
or address and waits for client communication. Our re-
sults show that application developers are often unaware
of the risks and secure practices in using IPC. We ﬁnd at-
tacks against several security-critical applications includ-
ing password managers and hardware tokens, in which
another user’s process is able to steal and misuse sensi-
tive data such as the victim’s credentials. The vulnera-
bilities can be exploited in enterprise environments with
centralized access control that gives multiple users re-
mote or local login access to the same host. Computers
with guest accounts and shared computers at home are
similarly vulnerable.
1
Introduction
People use personal computers (PC) for storing and pro-
cessing their most critical information, such as sensitive
work documents, private messages, or access credentials
to online accounts. These computers and the software
running on them is designed to be personal, and the fo-
cus of security engineering has therefore been on exter-
nal threats from unauthorized users and from the Inter-
net. Nevertheless, most PCs can be accessed by more
than one authorized user, making them effectively multi-
user computers. In this paper, we analyze threats from
the authorized insiders. They may be coworkers, family
members, or guest users with console access.
Our focus is on the security of inter-process communi-
cation (IPC), i.e. communication channels that are inter-
nal to the computer. Computer software often comprises
multiple components, such as a frontend application and
a backend database, which obviously need to exchange
information. Many modern desktop applications also of-
ten follow the design of web software and have a sepa-
rate UI component, which connects to the business logic
via a RESTful API. The UI may even be implemented in
JavaScript and run in a web browser.
We assume the attacker to have login access as non-
administrator or, at minimum, the ability to keep non-
privileged processes running in the background. The at-
tacker’s goal is to exploit IPC between the processes of
another user. The attacks that we discover are similar to
those on the open networks, but they happen inside one
computer, where application developers often do not ex-
pect adversaries. We therefore use the name man in the
machine (MitMa) to describe these attackers.
During the analysis of case-study applications, we ob-
served that application developers have an ambiguous
attitude towards local attackers and the security of IPC
channels. On one hand, these threats are not given much
consideration. It is quite common to cite opinions of se-
curity experts stating that attempts to defend against local
attackers are futile. On the other hand, the application
implementations often make some attempt to authenti-
cate or encrypt the communication, but rarely with the
same prudence as seen in communication over physical
networks.
Our main contribution is to highlight the importance
of the adversary model where a nonprivileged user inter-
cepts communication inside the computer. We demon-
strate its seriousness with various examples of widely-
deployed applications and compromises of critical data.
We show that the vulnerabilities are common and that
exploiting them is not difﬁcult. We also discuss potential
USENIX Association
27th USENIX Security Symposium    1511
ing [41], that is, leaving login sessions in the background
and resuming them later. Such background sessions con-
tinue to have running processes that can be used in the
attacks. On macOS and Linux, it is also possible to
leave processes running when the user logs out (e.g., with
the nohup command). On Windows, user processes are
killed at the end of the login session, and thus the MitMa
attacker must remain logged in.
Figure 1: MitMa attack
MitMa attacker Method
S
O
c
a
m
x
u
n
i
L
s
w
o
d
n
i
W


Console login

SSH

Remote desktop N/A  N/A
Console login





mitigation techniques. Finally, we believe that the obser-
vations of this paper will be valuable also in the ongoing
efforts to improve isolation between one user’s applica-
tions.
The rest of this paper is structured as follows. Sec-
tion 2 explains our adversary model. Section 3 describes
IPC methods and the basic attack principles. Sections 4–
7 cover the vulnerabilities found in several classes of ap-
plications. Potential solutions are covered in Section 8
while Section 9 discusses the results and Section 10 sur-
veys related work. Finally, Section 11 concludes the pa-
per.
2 The adversary
This section describes the adversary model and explains
its relevance in everyday information systems.
We consider multi-user computers that may have pro-
cesses of two or more users running at the same time.
The attacker is a nonprivileged user who tries to steal
sensitive information from or interfere with another user.
It does this by intercepting communication between the
victim user’s processes, as illustrated in Figure 1. The
malicious process is nonprivileged, and it typically runs
in the background and belongs to a different login ses-
sion than the victim’s processes. The attack is similar
to impersonation or man in the middle in computer net-
works, but since the communication takes place inside
one computer, we call it man in the machine (MitMa).
Shared computers are common both in home and en-
terprise environments. In a Windows domain, users are
centrally registered at the Active Directory (AD) and
they are typically able to log into each other’s worksta-
tions. Linux and macOS workstations are commonly in-
tegrated into AD or other centralized directory services.
In addition to having its own user account, the MitMa
attacker needs to be able to run a process in the back-
ground when the victim user is working on the computer.
Table 1 summarizes ways to achieve this. Personal com-
puters generally have not been designed for multiple si-
multaneous users, but they do support fast user switch-
Authenticated
user
Guest account
Table 1: MitMa attackers on different OSs
The MitMa attacks can also be launched using guest
accounts. The guest user can start the malicious process
and leave the guest session in the background with fast
user switching. We implemented the attacks described
in this paper with macOS High Sierra, Windows 7, and
Windows 8.1. These operating systems have the guest
account enabled by default. Windows 10 does not cur-
rently have a built-in guest account, though creating one
is possible. In enterprise Windows domains, the avail-
ability of the guest account depends on the group policy.
The attacks can also be carried out remotely, for ex-
ample, if SSH [56] has been enabled. On macOS, the
SSH server is started if the administrator chooses “Re-
mote Login” from sharing preferences. Windows 10 in
the developer mode also starts an SSH server. The user
might not realize this because earlier Windows versions
required third-party SSH servers.
Another remote access method is remote desktop.
Non-server versions of Windows allow only one inter-
active session at a time. Thus, the attacker cannot access
the computer at the same time as the local users. How-
ever, the remote desktop session can be left in the back-
ground and resumed later, similar to fast user switching.
The MitMa attack is technically possible also between
remote desktop sessions on a Windows Server. While the
case-study applications considered in this paper are gen-
erally not run on Windows Server, there could be other
vulnerable applications.
3 Client-server communication inside the
computer
Modern operating systems (OS) provide several means
for IPC. The vulnerabilities presented in this paper were
found in IPC methods where a server process or device
1512    27th USENIX Security Symposium
USENIX Association
listens for connections from client processes. Speciﬁ-
cally, we consider network sockets, named pipes, and
Universal Serial Bus (USB) communication. In this sec-
tion, we give a high-level overview of these IPC mech-
anisms. The reader is referred e.g. to [47, 49] for more
details. We also discuss the attack vectors that the MitMa
attacker might exploit against each IPC type.
3.1 Network sockets
Network sockets are widely used in distributed client-
server architectures. The server waits for the incoming
client requests by listening on an IP address and a TCP
or UDP port number. Any client can connect to the server
as long as it knows the IP address and port. While net-
work sockets were originally intended for communica-
tion across a network, they are also used for IPC within
one host. If the server listens only on the loopback in-
terface, i.e. on one of the special localhost addresses
127.0.0.0/8 and ::1/128, only local client processes
can connect to it.
Network sockets have almost the same functionality
across operating systems. Any process, regardless of its
owner, can listen on a port 1024 or higher as long as the
number has not been taken by another process. Also,
any local process can connect as a client to any localhost
port where a server is listening. It is the responsibility
of the client and server processes to authenticate each
other on the application layer, as if the client was on the
other side on the Internet. However, a separate connec-
tion is created for each client, and the OS prevents unau-
thorized processes from snifﬁng the communication. In
that respect, IPC over the loopback interface is more se-
cure than communication over a physical network.
Attack vectors. The malicious process, like any pro-
cess on the computer, can connect to any server port on
the localhost. This makes client impersonation very easy.
Some servers might accept only one client connection,
and in that case the malicious process needs to connect
before the legitimate client.
The network-socket server typically listens for TCP
connections on one or more predeﬁned ports. The at-
tacker can ﬁnd the port numbers from the application
documentation or source code, if available, or with com-
mands such as netstat. In port hijacking, the MitMa
attacker binds to the port (≥ 1024) before the legitimate
process does. The attacker can then receive any connec-
tions that clients open to the port, enabling server imper-
sonation.
The MitMa attacker naturally wants to combine server
and client impersonation to a full man-in-the-middle at-
tack where the attacker passes messages between the le-
gitimate client and server. This is not always easy to
do on the localhost because the legitimate server and at-
tacker cannot both bind to the same port number. Fortu-
nately for the attacker, many applications implement port
agility for IPC: if the primary port is taken, they choose
the next port number from a predeﬁned list. This enables
the attacker to receive client connections on the primary
port and connect itself to a secondary port on the legiti-
mate server.
Even if the application uses one ﬁxed port for IPC, the
attacker may be able to replay messages by alternating
between the client and server roles. It sometimes binds
to the server port and sometimes releases it for the legit-
imate server. The rate of the messages passing through
the attacker will be slow, but we found practical attacks
that only require a small number of such role reversals.
3.2 Windows named pipes
Both Windows and Unix systems support named pipes,
but the implementation details differ signiﬁcantly. We
describe Windows named pipes here because they were
found to create more actual vulnerabilities.
On Windows, the named pipes are placed in the root
directory of the named pipe ﬁlesystem. It is mounted un-
der the special path \\.\pipe\, to which every user of
the system has access, including the guest user. When
no pipe with the given name exists, any process can cre-
ate it. The named pipe can have multiple instances to
support multiple simultaneous connections from clients.
The creator of the ﬁrst instance decides the maximum
number of instances as well as speciﬁes the security de-
scriptor, which includes an access control list (DACL)
that controls access to all the instances of the named pipe.
The default descriptor grants read access to everyone and
full access only to the creator user and the administra-
tors. Some important details are that, if an instance of
the named pipe with the same name already exists, only
processes with the FILE CREATE PIPE INSTANCE access to
the pipe object can create a new instance, and that a pro-
cess can set the FILE FLAG FIRST PIPE INSTANCE ﬂag to
ensure that it is creating the ﬁrst instance.
Attack vectors.
If the named pipe is created with the
default security descriptor, or with open read-write ac-
cess for two-directional communication, the attacker’s
malicious process can connect to it and impersonate the
legitimate client. The pipe server would have to con-
ﬁgure the DACL on the named pipe object carefully to
allow access for only legitimate clients.
The default security descriptor does not allow the at-
tacker to create new pipe instances. The attacker can,
however, hijack the pipe name by creating the ﬁrst pipe
instance and thus becoming the owner of the named-
pipe object. This way, the attacker can impersonate the
USENIX Association
27th USENIX Security Symposium    1513
named-pipe server. Furthermore, the attacker can set the
access control list so that it allows the victim (or anyone)
to create new pipe instances. If the legitimate server is