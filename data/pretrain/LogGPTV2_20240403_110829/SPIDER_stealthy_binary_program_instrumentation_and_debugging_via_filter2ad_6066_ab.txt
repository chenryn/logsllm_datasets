since its current view—code view is not readable, an EPT
violation will occur. Spider will capture the event and ad-
just the mapping and the attribute in the EPT entry to
switch to the data view. It will then resume the guest, and
the data access can proceed. Switching from data view to
code view works in a similar way.
It seems that Spider needs to switch views frequently
when instruction fetching and data access in a split page are
interleaved, which could result in a lot of EPT violations.
However, the problem is greatly mitigated by the separation
of iTLB and dTLB in x86. Given a split page, although the
corresponding EPT entry could only map one of its views
at any given time, the mappings of the two views can exist
simultaneously in the iTLB and dTLB, respectively. For
example, when Spider switches the page from the code view
to data view due to a data access, the mapping in the EPT
Guest Virtual Address-Spaces
Guest Physical Address-Space
Hypervisor
Machine Physical Memory
Program P
……
……
……
Virtual Page A
(Code View)
……
int3
mov ebp, esp
sub esp, 16
……
Virtual Page A 
(Data View)
……
push ebp
mov ebp, esp
sub esp, 16
……
……
……
Guest
Page
Table
Mapping
Changes
Code
Modification
Handler
Code
Modification
……
Machine 
Physical Page 1
……
push ebp
mov ebp, esp
sub esp, 16
……
Physical Page A
(Code View)
……
int3
mov ebp, esp
sub esp, 16
……
Physical Page A 
(Data View)
……
push ebp
mov ebp, esp
sub esp, 16
……
……
Extended
Page
Table
Data Access
Instruction Fetch
Sync
Machine 
Physical Page 2
……
int3
mov ebp, esp
sub esp, 16
……
Split View
Set
BP
Hypervisor
Address Space ID and 
Virtual Address to Set Trap
User
Guest Virtual-to-Physical 
Mapping Monitor
Function to Call
on Trap
Physical Address
to Set Trap
Breakpoint
Manager
User-Provided Functions
BP Triggered
Call
……
Figure 1: Overview of Spider.
is set to mapping its data view. After resuming the guest,
the data access will populate the dTLB with the mapping
for the data view. However, the mapping for its code view
still exists in the iTLB. Further instruction fetching will not
cause EPT violation until the mapping is evicted from iTLB.
4.2 Handling Breakpoints
Spider hides the #BP exceptions generated by invisible
breakpoints and invokes breakpoint handlers at the hyper-
visor level to neutralize side-eﬀects related to breakpoint
handling. Spider sets the hypervisor to intercept all #BP
exceptions generated by the guest. How to deal with the
#BP exceptions depends on their causes: those caused by
invisible breakpoints should not be seen by the guest, while
those caused by traditional software breakpoints set by the
guest should be delivered to the guest transparently.
The breakpoint manager of Spider maintains a list which
stores the guest physical addresses of all invisible break-
points and their associated handlers that should be called
when they are triggered. When Spider intercepts a #BP
exception, it translates the guest instruction pointer to guest
physical address by looking up the guest page table, and
compares the address against the list to see whether the
triggered breakpoint is an invisible breakpoint or a tradi-
tional software breakpoint. If it is a traditional breakpoint,
the #BP exception will be re-injected to the guest to let
the guest handle the breakpoint on its own. Otherwise, if
it is an invisible breakpoint, Spider will call its associated
handler to handle the breakpoint event. After that, Spider
will temporarily clear the breakpoint and restore the ﬁrst
byte of instruction which had been replaced. Then it lets
the guest single-step through the instruction.
Unlike previous work [14, 28, 19] which enables single-
stepping by setting the trap ﬂag in the guest EFLAGS reg-
ister, Spider uses the monitor trap ﬂag (MTF) which is
a ﬂag speciﬁcally designed for single-stepping in hardware
virtualization. When MTF is set, the guest will trigger a
VM Exit after executing each instruction. The reason why
we choose not to use trap ﬂag is that it is visible to the
guest. Despite various techniques used in previous work to
hide the trap ﬂag, the guest could still see it. For exam-
ple, if an interrupt is pending right after the guest resumes
execution, the processor will invoke the corresponding inter-
rupt handler before single-stepping through the instruction.
The EFLAGS register is saved onto the stack, and restored
after the interrupt handler returns. The interrupt handler
could check the EFLAGS on the stack to see if the trap
ﬂag has been set. Compared with the trap ﬂag, MTF is
transparent because it could not be read by the guest. How-
ever, using MTF also causes one problem. Consider the
same scenario of pending interrupt as above: when using
the trap ﬂag, the saving/restoring of the trap ﬂag implicitly
avoids single-stepping through the interrupt handler; but
when using MTF, the processor will single-step through the
interrupt handler before reaching the instruction. Spider
solves this problem by “retrying”:
if it ﬁnds out that the
guest has not executed the instruction after a single-step, it
will clear MTF, set the invisible breakpoint again and re-
sume the guest. The invisible breakpoint will be triggered
again after the interrupt handler returns. This procedure
repeats until the instruction is successfully executed after a
single-step, and Spider will then clear MTF, set the invisi-
ble breakpoint again and resume the execution of the guest.
4.3 Monitoring Virtual-to-Physical Mapping
The invisible breakpoint provides Spider the ability to
trap the execution of program at arbitrary guest physical ad-
dress. However, since paging is enabled in almost all modern
operating systems, the processor usually uses virtual address
instead of physical address to reference memory. Hence, it
is more desirable to have the ability to trap the execution of
program at arbitrary guest virtual address in the program’s
address space. We deﬁne the breakpoint address where we
set a breakpoint using a tuple of the address space identiﬁer
and the guest virtual address. In x86, the physical address
of the base of the top-level paging structure (stored in CR3
register) serves as the address space identiﬁer, so we write
the breakpoint address as BA = (P GB, GV A).
If BA is
mapped to a guest physical address GP A, we denote it as
BA → GP A. If BA is not mapped to any guest physical
address, we denote it as BA → N IL.
292
PGB
GVA
PGB
GVA
PGB
GVA
PGB
GVA
31
22
21
12
11
0
RO
Page Directory
RO
Page Table 1
C
D
GPA1
31
22
21
12
11
0
RO
Page Directory
RO
Page Table 1
GPA1
GPA2
C
D
RO
Page Directory
Page Table 1
GPA1
RO
Page Table 2
C
D
GPA3
RO
N
P
Page Directory
31
22
21
12
11
0
31
22
21
12
11
0
(a) Virtual-to-physical mapping
(b) Page table entry is modified 
(c) Page directory entry is modified 
(d) Page directory entry not present
Read-only paging structure is in grey color and marked with “RO”. Physical page with split code and data view is represented using rectangle 
with a dashed line splitting the code (‘C’) and data (‘D’) view. The area in the code view with a cross inside represents the breakpoint. Arrow 
means  path  that  is  traversed  during  address  translation.  Double  arrow  indicates  memory  mapping.  Dashed  arrow  or  double  arrow  means 
previous path or mapping that is no longer used.
Figure 2: Monitoring guest virtual-to-physical mapping.
To illustrate, assume the user wants to set a breakpoint
at BA1 = (P GB1, GV A1). If BA1 → GP A1, then we could
just set an invisible breakpoint at GP A1 to solve the prob-
lem. However, it is possible that BA1 → N IL when we
set the breakpoint (e.g., the program has not been loaded).
Even if BA1 is mapped, the mapping could change after the
breakpoint is set. If the mapping changes to BA1 → GP A2,
since there is no breakpoint set at GP A2, execution of the
instruction at BA1 will not be trapped as expected. Simi-
larly, when BA1 is no longer mapped to GP A1, the break-
point set at GP A1 will cause problem when another ad-
dress is mapped to GP A1. Such virtual-to-physical map-
ping changes could happen for various reasons. For example,
when the guest OS swaps out a virtual page, its correspond-
ing physical page might be used to map another virtual page;
when a write access happens in a copy-on-write virtual page,
the guest OS will map it to another physical page to per-
form the writing; kernel-level malware could even modify
the guest page table directly to change virtual-to-physical
mappings. Hence, Spider must monitor virtual-to-physical
mapping changes to handle such scenarios correctly.
Monitoring every change of virtual-to-physical mapping
requires heavy-weight techniques such as shadow page ta-
ble. Fortunately, Spider only needs to monitor the change
of virtual-to-physical mapping at each breakpoint address.
In x86, the virtual-to-physical mapping is represented using
multiple levels of paging structures. The number of levels
depends on the operation mode of the processor, for ex-
ample, whether physical address extension (PAE) or long
mode is enabled. Without loss of generality, let us assume
that legacy two-level paging structure is being used. As
shown in Figure 2(a), given a breakpoint address BA =
(P GB, GV A), the processor traverses along a path from the
page directory to the page table to translate it to a guest
physical address. The only way to change the virtual-to-
physical mapping at BA is to modify the paging-structure
entries that is traversed during address translation, which is
shown as the rectangle area in the page directory and the
page table. To capture such modiﬁcations, Spider sets these
paging structures to read-only (shown as grey) in the EPT.
When there is a write access to a paging structure, an EPT
violation will be triggered and captured by Spider. Spider
will record the current values of paging-structure entries,
then temporarily set the paging structure to writable and
let the guest single-step through the instruction that per-
forms the write access. After the single-stepping, Spider
will read the new values of paging-structure entries and see
which ones of them have been modiﬁed. After that, Spider
will set the paging structure back to read-only to capture
future modiﬁcations. The action that Spider performs to
handle the modiﬁcation depends on the type of the paging-
structure entries that get modiﬁed:
Bottom-level paging-structure entries. As shown in
Figure 2(b), when the bottom-level paging-structure entry
used to translate BA is modiﬁed, the mapping changes from
BA → GP A1 to BA → GP A2. As a result, Spider ﬁrst
removes the invisible breakpoint at GP A1. Then Spider
compares the content of the page that contains GP A1 and
the page that contains GP A2. If they are exactly the same
(which is the case we show in the ﬁgure), then it is safe to
move the breakpoint to GP A2. Otherwise, as the code in
the page has changed, it is handled in the same way as a
breakpoint that might no longer be valid due to code modi-
ﬁcation (Section 4.4).
It is worth noting that the ﬁgure only shows the scenario
where the mapping changes from a present one to another
present one. The mapping might also changes from not-
present to present, or oppositely.
If the mapping changes
from BA → N IL to BA → GP A, or from BA → GP A to
BA → N IL, Spider will create/remove invisible breakpoint
at GP A, respectively.
293
Non-bottom-level paging-structure entries. Figure 2(c)
shows the scenario when a non-bottom-level paging-structure
entry used to translate BA is modiﬁed. The virtual-to-
physical mapping changes from BA → GP A1 to BA →
GP A3, so Spider moves the breakpoint from GP A1 to GP A3.
In addition to that, the path which the processor traverses
along to perform address translation is also modiﬁed, so Spi-
der also removes the read-only attribute from the paging
structures in the previous path (Page Table 1) and sets the
paging structures in the new path (Page Table 2) to read-
only. For simplicity, we only show the change of one mapping
and one path in Figure 2(c). In practice, modiﬁcation of a
non-bottom-level paging-structure entry may aﬀect multi-
ple paths and mappings, each of which will be handled by
Spider individually.