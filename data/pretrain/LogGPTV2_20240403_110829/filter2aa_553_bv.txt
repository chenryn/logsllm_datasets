序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代
码。除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。
实际上，递归有时可用循环来代替，循环有时也能用递归来代替。
595
最后，递归函数必须包含能让递归调用停止的语句。通常，递归函数都
使用if或其他等价的测试条件在函数形参等于某特定值时终止递归。为此，
每次递归调用的形参都要使用不同的值。例如，程序清单9.6中的
up_and_down(n)调用up_and_down(n+1)。最终，实际参数等于4时，if的测试
条件(n 
long fact(int n);
long rfact(int n);
int main(void)
{
int num;
printf("This program calculates factorials.\n");
596
printf("Enter a value in the range 0-12 (q to quit):\n");
while (scanf("%d", &num) == 1)
{
if (num  12)
printf("Keep input under 13.\n");
else
{
printf("loop: %d factorial = %ld\n",
num, fact(num));
printf("recursion: %d factorial = %ld\n",
num, rfact(num));
}
printf("Enter a value in the range 0-12 (q to quit):\n");
}
printf("Bye.\n");
return 0;
}
597
long fact(int n)   // 使用循环的函数
{
long ans;
for (ans = 1; n > 1; n--)
ans *= n;
return ans;
}
long rfact(int n)  // 使用递归的函数
{
long ans;
if (n > 0)
ans = n * rfact(n - 1);
else
ans = 1;
return ans;
}
测试驱动程序把输入限制在0~12。因为12!已快接近5亿，而13!比62亿
还大，已超过我们系统中long类型能表示的范围。要计算超过12的阶乘，必
须使用能表示更大范围的类型，如double或long long。
下面是该程序的运行示例：
598
This program calculates factorials.
Enter a value in the range 0-12 (q to quit):
5
loop: 5 factorial = 120
recursion: 5 factorial = 120
Enter a value in the range 0-12 (q to quit):
10
loop: 10 factorial = 3628800
recursion: 10 factorial = 3628800
Enter a value in the range 0-12 (q to quit):
q
Bye.
使用循环的函数把ans初始化为1，然后把ans与从n~2的所有递减整数相
乘。根据阶乘的公式，还应该乘以1，但是这并不会改变结果。
现在考虑使用递归的函数。该函数的关键是n! = n×(n-1)!。可以这样做
是因为(n-1)!是n-1~1的所有正整数的乘积。因此，n乘以n-1就得到n的阶乘。
阶乘的这一特性很适合使用递归。如果调用函数rfact()，rfact(n)是 n*rfact(n-
1)。因此，通过调用 
rfact(n-1)来计算rfact(n)，如程序清单9.7中所示。当
然，必须要在满足某条件时结束递归，可以在n等于0时把返回值设为1。
程序清单9.7中使用递归的输出和使用循环的输出相同。注意，虽然
rfact()的递归调用不是函数的最后一行，但是当n>0时，它是该函数执行的最
后一条语句，因此它也是尾递归。
599
既然用递归和循环来计算都没问题，那么到底应该使用哪一个？一般而
言，选择循环比较好。首先，每次递归都会创建一组变量，所以递归使用的
内存更多，而且每次递归调用都会把创建的一组新变量放在栈中。递归调用
的数量受限于内存空间。其次，由于每次函数调用要花费一定的时间，所以
递归的执行速度较慢。那么，演示这个程序示例的目的是什么？因为尾递归
是递归中最简单的形式，比较容易理解。在某些情况下，不能用简单的循环
代替递归，因此读者还是要好好理解递归。
9.3.4 递归和倒序计算
递归在处理倒序时非常方便（在解决这类问题中，递归比循环简单）。
我们要解决的问题是：编写一个函数，打印一个整数的二进制数。二进制表
示法根据 
2 
的幂来表示数字。例如，十进制数 
234 
实际上是
2×102+3×101+4×100，所以二进制数101实际上是1×22+0×21+1×20。二进制数
由0和1表示。
我们要设计一个以二进制形式表示整数的方法或算法（algorithm）。例
如，如何用二进制表示十进制数5？在二进制中，奇数的末尾一定是1，偶数
的末尾一定是0，所以通过5 % 2即可确定5的二进制数的最后一位是1还是
0。一般而言，对于数字n，其二进制的最后一位是n % 2。因此，计算的第
一位数字实际上是待输出二进制数的最后一位。这一规律提示我们，在递归
函数的递归调用之前计算n % 2，在递归调用之后打印计算结果。这样，计
算的第1个值正好是最后一个打印的值。
要获得下一位数字，必须把原数除以 2。这种计算方法相当于在十进制
下把小数点左移一位，如果计算结果是偶数，那么二进制的下一位数就是
0；如果是奇数，就是1。例如，5/2得2（整数除法），2是偶数（2%2 
得
0），所以下一位二进制数是 0。到目前为止，我们已经获得 01。继续重复
这个过程。2/2得1，1%2得1，所以下一位二进制数是1。因此，我们得到5
的等价二进制数是101。那么，程序应该何时停止计算？当与2相除的结果小
于2时停止计算，因为只要结果大于或等于2，就说明还有二进制位。每次除
以 2 就相当于去掉一位二进制，直到计算出最后一位为止（如果不好理解，
600
可以拿十进制数来做类比：628%10得8，因此8就是该数最后一位；而
628/10得62，而62%10得2，所以该数的下一位是2，以此类推）。程序清单
9.8演示了上述算法。
程序清单9.8 binary.c程序
/* binary.c -- 以二进制形式打印制整数 */
#include 
void to_binary(unsigned long n);
int main(void)
{
unsigned long number;
printf("Enter an integer (q to quit):\n");
while (scanf("%lu", &number) == 1)
{
printf("Binary equivalent: ");
to_binary(number);
putchar('\n');
printf("Enter an integer (q to quit):\n");
}
printf("Done.\n");
return 0;
601
}
void to_binary(unsigned long n) /* 递归函数 */
{
int r;
r = n % 2;
if (n >= 2)
to_binary(n / 2);
putchar(r == 0 ? '0' : '1');
return;
}
在该程序中，如果r的值是0，to_binary()函数就显示字符'0'；如果r的值
是1，to_binary()函数则显示字符'1'。条件表达式r == 0 ? '0' : '1'用于把数值转
换成字符。
下面是该程序的运行示例：
Enter an integer (q to quit):
9
Binary equivalent: 1001
Enter an integer (q to quit):
255
Binary equivalent: 11111111
602
Enter an integer (q to quit):
1024
Binary equivalent: 10000000000
Enter an integer (q to quit):
q
done.
不用递归，是否能实现这种用二进制形式表示整数的算法？当然可以。
但是由于这种算法要首先计算最后一位二进制数，所以在显示结果之前必须
把所有的位数都储存在别处（例如，数组）。第 15 章中会介绍一个不用递
归实现该算法的例子。
9.3.5 递归的优缺点
递归既有优点也有缺点。优点是递归为某些编程问题提供了最简单的解
决方案。缺点是一些递归算法会快速消耗计算机的内存资源。另外，递归不
方便阅读和维护。我们用一个例子来说明递归的优缺点。
斐波那契数列的定义如下：第1 个和第2 个数字都是1，而后续的每个数
字都是其前两个数字之和。例如，该数列的前几个数是：1、1、2、3、5、
8、13。斐波那契数列在数学界深受喜爱，甚至有专门研究它的刊物。不
过，这不在本书的讨论范围之内。下面，我们要创建一个函数，接受正整数
n，返回相应的斐波那契数值。
首先，来看递归。递归提供一个简单的定义。如果把函数命名为
Fibonacci()，那么如果n是1或2， Fibonacci(n)应返回1；对于其他数值，则应
返回Fibonacci(n-1)+Fibonacci(n-2)：
unsigned long Fibonacci(unsigned n)
603
{
if (n > 2)
return Fibonacci(n-1) + Fibonacci(n-2);
else
return 1;
}
这个递归函数只是重述了数学定义的递归。该函数使用了双递归
（double recursion），即函数每一级递归都要调用本身两次。这暴露了一个
问题。
为了说明这个问题，假设调用 Fibonacci(40)。这是第1 级递归调用，将
创建一个变量 n。然后在该函数中要调用Fibonacci()两次，在第2级递归中要
分别创建两个变量n。这两次调用中的每次调用又会进行两次调用，因而在
第3级递归中要创建4个名为n的变量。此时总共创建了7个变量。由于每级递
归创建的变量都是上一级递归的两倍，所以变量的数量呈指数增长！在第 5
章中介绍过一个计算小麦粒数的例子，按指数增长很快就会产生非常大的
值。在本例中，指数增长的变量数量很快就消耗掉计算机的大量内存，很可
能导致程序崩溃。
虽然这是个极端的例子，但是该例说明：在程序中使用递归要特别注
意，尤其是效率优先的程序。
所有的C函数皆平等
程序中的每个C函数与其他函数都是平等的。每个函数都可以调用其他
函数，或被其他函数调用。这点与Pascal和Modula-2中的过程不同，虽然过
程可以嵌套在另一个过程中，但是嵌套在不同过程中的过程之间不能相互调
用。
604
main()函数是否与其他函数不同？是的，main()的确有点特殊。当
main()与程序中的其他函数放在一起时，最开始执行的是main()函数中的第1
条语句，但是这也是局限之处。main()也可以被自己或其他函数递归调用
——尽管很少这样做。
605
9.4 编译多源代码文件的程序
使用多个函数最简单的方法是把它们都放在同一个文件中，然后像编译
只有一个函数的文件那样编译该文件即可。其他方法因操作系统而异，下面
将举例说明。
9.4.1 UNIX
假定在UNIX系统中安装了UNIX C编译器cc（最初的cc已经停用，但是
许多UNIX系统都给cc命令起了一个别名用作其他编译器命令，典型的是gcc
或clang）。假设file1.c和file2.c是两个内含C函数的文件，下面的命令将编译
两个文件并生成一个名为a.out的可执行文件：
cc file1.c file2.c
另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了
file1.c，而file2.c不变，可以使用以下命令编译第1个文件，并与第2个文件
的目标代码合并：
cc file1.c file2.o
UNIX系统的make命令可自动管理多文件程序，但是这超出了本书的讨
论范围。
注意，OS 
X的Terminal工具可以打开UNIX命令行环境，但是必须先下
载命令行编译器（GCC和Clang）。
9.4.2 Linux
假定Linux系统安装了GNU C编译器GCC。假设file1.c和file2.c是两个内
含C函数的文件，下面的命令将编译两个文件并生成名为a.out的可执行文
件：
gcc file1.c file2.c
606
另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了
file1.c，而file2.c不变，可以使用以下命令编译第1个文件，并与第2个文件
的目标代码合并：
gcc file1.c file2.o
9.4.3 DOS命令行编译器
绝大多数DOS命令行编译器的工作原理和UNIX的cc命令类似，只不过
使用不同的名称而已。其中一个区别是，对象文件的扩展名是.obj，而不
是.o。一些编译器生成的不是目标代码文件，而是汇编语言或其他特殊代码