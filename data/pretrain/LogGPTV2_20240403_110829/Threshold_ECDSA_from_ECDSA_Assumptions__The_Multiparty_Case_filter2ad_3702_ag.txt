(16, 32]
(32, 64]
(64, 128]
(128, 256]
1
2
4
8
16
32
16000
8000
4000
2000
1000
500
2000
1000
500
250
125
62
TABLE III: LAN Benchmark Parameters. For signing we varied
t according to these parameters, and for setup we varied n, ﬁxing
t = (cid:2)(n + 1)/2(cid:3).
allocated one node, and the parties communicated via Google’s
internal network. We compiled our code using the nightly
version of Rust 1.28, with the default level of optimization.
Parallelism was provided by the Rayon crate and, as each
node can execute eight threads simultaneously, we limited the
number of threads used in signing to ten (having arrived at
this number empirically). Our hash function implementations
were written in C using compiler intrinsics, and were compiled
with GCC 8.2.0. Our benchmarking programs were designed to
establish insecure connections among the parties one time only,
and then run a batch of setup or signing operations, measuring
the wall clock time for the entire batch. Thus, they record
overhead due to latency and bandwidth constraints, but they do
not record overhead due to private or authenticated channels.
A. LAN Benchmarks
For benchmarks in the LAN setting, we created a set of 256
nodes in Google’s South Carolina datacenter. Among these
nodes, we measured the bandwidth to be generally between 5
and 10 Gbits/sec, and the round-trip latency to be approximately
0.3 ms. Using these nodes, we collected data for both our
setup and signing protocols using combinations of parameters
as speciﬁed in Table III. For signing benchmarks, all costs are
independent of n, the number of parties in the larger group from
whom the signing parties are selected. Consequently, we varied
only t, the number of parties actually participating in signing.
For setup, only computation costs depend upon t, and not
bandwidth; consequently we varied n and set t = (cid:13)(n + 1)/2(cid:14),
which we determined to be the most expensive value relative
to a particular choice of n. Our aim in choosing sample counts
was to ensure each benchmark took ﬁve to ten minutes in
total, in order to smooth out artifacts due to transient network
conditions. Our results for setup are reported in Figure 2, and
our results for signing are reported in Figure 3.
We note that our method only slightly underperforms that
of Doerner et al. [1] for 2-of-n signing in this setting, in
spite of the fact that our protocol implements a somewhat
stronger functionality. Speciﬁcally, we require 9.52 ms, whereas
an evaluation of their protocol (with no parallelism) in our
benchmarking environment requires 5.83 ms. In a similar
benchmark environment, but without parallelism, the 2-of-2
protocol of Lindell [12] was reported to require 36.8 ms to
sign with only two parties. Allowing parallelism, our protocol
Fig. 2: Wall Clock Times for n-Party Setup over LAN. Note that
all parties reside on individual machines in the same datacenter, and
latency is on the order of a few tenths of a millisecond.
Fig. 3: Wall Clock Times for t-Party Signing over LAN. Note that
all parties reside on individual machines in the same datacenter, and
latency is on the order of a few tenths of a millisecond.
is capable of signing with 24 parties in 37.6 ms, or roughly
the same time envelope. The most efﬁcient prior works for
threshold ECDSA signing with arbitrary thresholds are those
of Gennaro et al. [10] and Boneh et al. [11] (who provide an
improved implementation Gennaro et al.’s protocol in addition
to developing new techniques). As with Lindell’s protocol, we
did not benchmark their protocols in our environment, and
so no truly fair comparison is possible. However, Boneh et
al. provide benchmarks for both protocols among groups of
parties ranging in size from 2 to 20, with each party residing
on a single four-core, eight-thread machine, and no network
costs recorded. Gennaro et al.’s protocol is the more efﬁcient
of the two in the case of 2-of-n signing, and requires roughly
350 ms. For 20-of-n signing, Boneh et al.’s protocol is the
more efﬁcient of the two, requiring roughly 1.5 seconds. While
it is true that their benchmark environments differs from ours,
our results are factors of roughly 40 and 50 better than theirs.
We do not believe that environmental differences account for
this.
Among the prior works, only Lindell reports on setup
performance. In the 2-of-2 case, his protocol requires 2435 ms,
whereas in the 2-of-n case our protocol requires only 45 ms.
Even in the 128-of-n case, our setup protocol requires only
(cid:18)(cid:17)(cid:23)(cid:21)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:34 UTC from IEEE Xplore.  Restrictions apply. 
87.1 ms
66.5 ms
348 ms
235 ms
Fig. 4: Map of Datacenter Locations used for WAN Benchmarks,
with latency ﬁgures along a few of the longer routes. The subgroup
of ﬁve zones inside the US are highlighted in red.
2299 ms. It seems that the performance of the setup protocols
of Gennaro et al. and Boneh et al. has never been reported, but
Lindell [12] conjectures that they would require many minutes.
B. WAN Benchmarks
As we have previously noted, our protocol is at a disad-
vantage relative to prior works in terms of round count. In
order to demonstrate the practical implications of this fact, we
ran an additional benchmark in the WAN setting. We chose
16 Google datacenters (otherwise known as zones) that offer
instances with current-generation CPUs; these are located on
a map in Figure 4. Five were located inside the United States,
in South Carolina, Virginia, Oregon, California, and Iowa.
Among these, the longest leg was between Oregon and South
Carolina, with a round-trip latency of 66.5 ms and bandwidth
of 353 Mbits/sec. The remaining 11 were located in Montreál,
London, Frankfurt, Belgium, the Netherlands, Finland, Sydney,
Taiwan, Tokyo, Mumbai, and Singapore. Among the complete
set, the longest leg was between Belgium and Mumbai, with
a round-trip latency of 348 ms and a bandwidth of 53.4
MBits/sec. We tested two conﬁgurations: one with only the
ﬁve US datacenters participating, and another with all 16. For
each conﬁguration, we performed benchmarks with one party
in each participating datacenter, and with eight parties in each
participating datacenter. In all cases, we collected 125 samples.
Results are reported in Table IV, along with comparative data
from our LAN benchmarks.
It is worth noting that Wang et al. [31] recently made the
claim that they performed the largest-scale demonstration of
multiparty computation to date. Their benchmark involves
128 parties split among eight datacenters around the world,
who jointly compute an AES circuit using the actively-secure
multiparty garbling protocol that they developed. Our WAN
benchmark involves 128 parties split among 16 datacenters,
and thus we assert that we have also evaluated one of the
largest secure multiparty protocols to date, at least so far as
party count and geographic distribution are concerned. We also
note that the in the clear setting, AES is generally considered
to have a much lower circuit complexity than ECDSA; this
is reﬂected in the signiﬁcantly lower computation time for a
single AES operation as compared to signing a single message
Parties/Zones
Signing Rounds
Signing Time
Setup Time
5/1
5/5
16/1
16/16
40/1
40/5
128/1
128/16
9
9
10
10
12
12
13
13
13.6
288
26.3
3045
60.8
592
193.2
4118
67.9
328
181
1676
539
743
2300
3424
TABLE IV: Wall-clock Times in Milliseconds over WAN. The
benchmark conﬁgurations used are described in Section VII-B. For
signing we varied t according to these parameters, and for setup we
varied n, ﬁxing t = (cid:2)(n + 1)/2(cid:3). Benchmarks involving only a single
zone are LAN benchmarks, for comparison.
using ECDSA. Interestingly, in the context of evaluating these
primitives securely among multiple parties, our protocol for
realizing F t,n
ECDSA performs considerably better than Wang et
al.’s realization of F n
AES. In the LAN setting with 128 parties
(each much more powerful than the ones we employ), they
report a 17-second wall clock time, including preprocessing,
and in the global WAN setting with 128 parties, their protocol
requires 2.5 minutes. When the setup and signing costs are
combined for our protocol, it requires 2.5 seconds and 7.5
seconds with 128 parties in the LAN and global WAN settings,
respectively. We believe that this serves to demonstrate that
there are multiparty functionalities for which specially tailored
protocols are warranted in practice, as opposed to the blind
use of generic MPC for all tasks.
C. Low-power Benchmarks
Finally, we performed a set of benchmarks on a group of
three Raspberry Pi model 3B+ single-board computers in order
to demonstrate the feasibility of evaluating our protocol (and the
protocols of Doerner et al. [1]) on small, low-powered devices.
Each board has a single, quad-core ARM-based processor
clocked at 1.4 GHz. The boards were loaded with Raspbian
Linux (kernel 4.14) and connected to one another via ethernet.
As an optimization for the embedded setting, we abandoned
SHA-256 (except where required by ECDSA) in favor of the
BLAKE2 hash function [32], using assembly implementations
provided by the BLAKE2 authors. To simulate the setting
wherein an embedded device signs with a more powerful one,
we used a 2013 15" Macbook Pro running Mac OS 10.13
(i.e. one author’s laptop). This machine was engaged in other
tasks at the time of benchmarking, and no attempt was made to
prevent this. We benchmarked 2-of-2 signing and setup between
the Macbook and a single Raspberry Pi, and t-of-n setup and
signing among the group of Pis, with n set as 3 and t as both
2 and 3. When n = 2, we used the slightly more efﬁcient
protocols of Doerner et al. [1] without modiﬁcation, and when
t = 3 we used the protocols presented in this paper. For setup,
we collected 50 samples, and for signing, we collected 250.
Results are presented in Table V. We observe that in spite of
(cid:18)(cid:17)(cid:23)(cid:22)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:34 UTC from IEEE Xplore.  Restrictions apply. 
[19] A. Joux, “A one round protocol for tripartite difﬁe-hellman,” J. Cryptol.,
[20] G. J. Simmons, “The prisoners’ problem and the subliminal channel,” in
2004.
CRYPTO, 1983.
[21] A. Shamir, “How to share a secret,” Commun. ACM, 1979.
[22] O. Goldreich, S. Micali, and A. Wigderson, “How to play any mental
game,” in STOC, 1987.
[23] J. Katz and Y. Lindell, Introduction to Modern Cryptography, Second
Edition. Chapman & Hall/CRC, 2015, ch. Digital Signature Schemes,
pp. 443–486.
[24] R. Canetti, “Universally composable security: A new paradigm for
cryptographic protocols,” in FOCS, 2001.
[25] C.-P. Schnorr, “Efﬁcient identiﬁcation and signatures for smart cards,”
in CRYPTO, 1989.
[26] A. Fiat and A. Shamir, “How to prove yourself: Practical solutions to
identiﬁcation and signature problems,” in CRYPTO, 1986.
[27] M. Fischlin, “Communication-efﬁcient non-interactive proofs of knowl-
edge with online extractors,” in CRYPTO, 2005.
[28] D. Beaver, “Correlated pseudorandomness and the complexity of private
computations,” in STOC, 1996.
[29] M. Keller, E. Orsini, and P. Scholl, “Actively secure OT extension with
optimal overhead,” in CRYPTO, 2015.
[30] T. Chou and C. Orlandi, “The simplest protocol for oblivious transfer,”
[31] X. Wang, S. Ranellucci, and J. Katz, “Global-scale secure multiparty
in LATINCRYPT, 2015.
computation,” in CCS, 2017.
[32] J.-P. Aumasson, S. Neves, Z. Wilcox-O’Hearn, and C. Winnerlein,
“Blake2: simpler, smaller, fast as md5,” https://blake2.net/blake2.pdf,
2013.
Conﬁguration Benchmark
Setup Time
Signing Time
Macbook/RPi
2×RPi
2×RPi
3×RPi
2-of-2
2-of-2
2-of-n
3-of-3
1419
1960
–
2277
52.6
58.5
69.8
162
TABLE V: Wall-clock Times in Milliseconds for Raspberry Pi.
The benchmark conﬁgurations used are described in Section VII-C.
the limitations of the hardware on which these benchmarks
were run, the signing time remains much less than a second,
and setup requires only a few seconds. Thus we expect our
protocol to be computationally efﬁcient enough to run even on
embedded devices such as hardware tokens or smartwatches,
and certainly on more powerful mobile devices such as phones.
VIII. CODE AND FULL VERSION
Our implementation is available under the three-clause BSD
license from https://gitlab.com/neucrypt/mpecdsa. For the full
version of this paper, please visit http://neucrypt.org.
IX. ACKNOWLEDGMENTS
We thank Dennis Giese for providing the hardware used in
our low-power device benchmark.
REFERENCES
[1] J. Doerner, Y. Kondi, E. Lee, and a. shelat, “Secure two-party threshold
ecdsa from ecdsa assumptions,” in IEEE S&P, 2018.
[2] Y. Desmedt, “Society and group oriented cryptography: A new concept,”
in CRYPTO, 1987.
[3] National Institute of Standards and Technology, “FIPS PUB 186-4:
Digital Signature Standard (DSS),” http://nvlpubs.nist.gov/nistpubs/FIPS/
NIST.FIPS.186-4.pdf, 2013.
[4] American National Standards Institute, “X9.62: Public Key Cryptography
For The Financial Services Industry: The Elliptic Curve Digital Signature
Algorithm (ECDSA),” 2005.
[5] D. R. L. Brown, “Sec 2: Recommended elliptic curve domain
parameters,” 2010. [Online]. Available: http://www.secg.org/sec2-v2.pdf
[6] D. Kravitz, “Digital signature algorithm,” jul 1993, uS Patent 5,231,668.
[7] Bitcoin Wiki, “Transaction,” https://en.bitcoin.it/wiki/Transaction, 2017,
accessed Oct 22, 2017.
[8] G. Wood, “Ethereum: A secure decentralised generalised transaction
ledger,” 2017. [Online]. Available: https://ethereum.github.io/yellowpaper/
paper.pdf
[9] P. MacKenzie and M. K. Reiter, “Two-party generation of dsa signatures,”
in CRYPTO, 2001.
[10] R. Gennaro, S. Goldfeder, and A. Narayanan, Threshold-Optimal
DSA/ECDSA Signatures and an Application to Bitcoin Wallet Security,
2016.
[11] D. Boneh, R. Gennaro, and S. Goldfeder, “Using level-1 homomorphic
encryption to improve threshold dsa signatures for bitcoin wallet security,”
in LATINCRYPT, 2017.
[12] Y. Lindell, “Fast secure two-party ecdsa signing,” in CRYPTO, 2017.
[13] P. Paillier, “Public-key cryptosystems based on composite degree
residuosity classes,” in EUROCRYPT, 1999.
[14] N. Gilboa, “Two party rsa key generation,” in CRYPTO, 1999.
[15] W. Difﬁe and M. Hellman, “New directions in cryptography,” IEEE
Trans. Inf. Theor., 1976.
in EUROCRYPT, 1997.
[16] V. Shoup, “Lower bounds for discrete logarithms and related problems,”
[17] D. R. L. Brown, “Generic groups, collision resistance, and ECDSA,”
Des. Codes Cryptography, 2005.
[18] D. Boneh and M. Zhandry, “Multiparty key exchange, efﬁcient traitor
tracing, and more from indistinguishability obfuscation,” in CRYPTO,
2014.
(cid:18)(cid:17)(cid:23)(cid:23)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:34 UTC from IEEE Xplore.  Restrictions apply.