title:Towards SmartFlow: case studies on enhanced programmable forwarding
in OpenFlow switches
author:Felician N&apos;emeth and
&apos;Ad&apos;am Stipkovits and
Bal&apos;azs Sonkoly and
Andr&apos;as Guly&apos;as
Towards SmartFlow: Case Studies on Enhanced
Programmable Forwarding in OpenFlow Switches
Felicián Németh, Ádám Stipkovits, Balázs Sonkoly and András Gulyás∗
HSN Lab, Department of Telecommunications and Media Informatics
Budapest University of Technology and Economics
{nemethf,stipkovits,sonkoly,gulyas}@tmit.bme.hu
ABSTRACT
The limited capabilities of the switches renders the imple-
mentation of unorthodox routing and forwarding mecha-
nisms as a hard task in OpenFlow. Our high level goal
is therefore to inspect the possibilities of slightly smarten-
ing up the OpenFlow switches. As a ﬁrst step in this direc-
tion we demonstrate (with Bloom ﬁlters, greedy routing and
network coding) that a very limited computational capabil-
ity enables us to natively support experimental technologies
while preserving performance. We distribute the demos1 in
source ﬁles and as a ready-to-experiment VM image to pro-
mote further improvements and evaluations.
Categories and Subject Descriptors
C.2.6 [Computer-Communication Networks]: Internet-
working—routers
Keywords
SDN, OpenFlow, Bloom ﬁlters, Greedy routing, Network
Coding
1.
INTRODUCTION
Since its ﬁrst proposition, OpenFlow (OF) [1] has become
the key enabler and driver of innovation in networks. By
now, numerous innovative applications have appeared on
top of OF, targeting mostly the well-known issues of packet
switched networks. The spectrum is spanning over proto-
cols, routing, traﬃc engineering technologies and security.
These sets of applications rely on the standard philosophy
of OF, namely to execute forwarding-related tasks in the
switches and move the control-speciﬁc operations completely
into the controller. While such a scheme is satisfactory for a
whole bunch of applications, we demonstrate that this view
is somewhat limited when the support for unorthodox net-
work technologies are considered.
In our demo we present OF testbeds for experimental tech-
nologies with non-negligible future potential. These testbeds
will require increasingly more functionality from the OF
switches. First we show that Bloom ﬁlter based forward-
ing [2] can be implemented in a standard manner over OF
∗MTA-BME Future Internet Research Group
1Available from http://github.com/nemethf/sigcomm2012
Copyright is held by the author/owner(s).
SIGCOMM’12, August 13–17, 2012, Helsinki, Finland.
ACM 978-1-4503-1419-0/12/08.
version 1.12, if the ﬂow entries of the switches are inter-
preted in an unorthodox way. Secondly, we introduce the
OF implementation of “greedy” or geographical [3] routing
and show that although its implementation can be done
in a standard fashion (using OF controllers), the beneﬁcial
properties of this basically distributed technology can only
be exploited by adding some computational capability to the
switches. Finally we present a testbed for inter session net-
work coding [4] and demonstrate that if we want to apply
this technology in OF then the usage of smarter switches is
imperative. Our case studies support that introducing only
lightweight and low-level enhancements, numerous network-
ing operations may become available in OF. For the univer-
sal treatment of such enhancements we envision a generic
language for switch computations similar to the vertex shad-
ing languages of video cards.
2. CASE STUDIES
Stateless multicast with Bloom ﬁlters: We assign
Bloom IDs to switch ports and put a Bloom ﬁlter contain-
ing the packet’s path into the packet’s destination Ether-
net address ﬁeld. The Bloom ﬁlter is generated by OR-ing
the Bloom IDs of the ports that the packet needs to pass
through.
Our testbed shows that a switch can be “forced” to follow
a Bloom ﬁlter based forwarding mechanism relying solely on
standard OF 1.1 protocol3, however we need to slightly de-
viate from the regular usage of ﬂow entries: normally, ﬂow
entries correspond to speciﬁc set of ﬂows, whereas we proac-
tively conﬁgure a separate ﬂow table for each port as shown
in Table 1. The ﬁrst entry matches if the packet’s Bloom
ﬁlter contains the port’s Bloom ID. In case of a match the
switch forwards the packet via the corresponding port and
independently of the matching result, the packet is matched
against the next port’s ﬂow table hereby providing the state-
less multicast switching capability.
Fix sized ﬂow tables with Greedy routing: Greedy
routing relies on embedding of the switches by assigning
them coordinates in a predeﬁned metric space. A switch
then forwards packets towards its neighbor closest to the
packets’ destination4. Knowing the topology and the coor-
dinates of each node, the controller can conﬁgure the ﬂow
tables of the switches (see Table 2). Afterwards, routing
operates without controller supervision.
2Note that this is not true for OF 1.0
3Currently, commercial OF switches support ver. 1.0 only.
4We store 2-dimensional coordinates in Ethernet addresses.
85Table 1: Bloom ﬁlter in OF. Flow entries in the ith ﬂow
table.
match condition
addr & BloomIDi =BloomIDi
(always match)
associated actions
output(porti)
goto-table(i+1)
goto-table(i+1)
Table 2: A single ﬂow entry implementing greedy routing.
address-n1...nN stands for the coordinates of the switch’s
neighbors.
MPLS label: MPLS label: MPLS label:
data
ﬂow-id
seq.no 1
seq.no 2
Figure 1: NC packet format. If seq. numbers are both non-
zero, then the original packets are xor ed in data.
BF video stream
greedy traffic
NC video streams:
stream 1
stream 2
stream 1    2 mixed
×
NOX BF
controller
NOX GR
controller
NOX NC
controller
control traffic:
only for initial configuration
BF control traffic
GR control traffic
NC control traffic
match
condition
(always
match)
associated actions
greedy coordinates
00:00:01:00:00:03
00:00:02:00:00:03
00:00:03:00:00:03
00:00:04:00:00:03
write-metadata(max. number, invalid port)
update-distance(address-n1, port-to-n1)
update-distance(address-n2, port-to-n2)
. . .
update-distance(address-nN, port-to-nN)
output-by-metadata
00:00:02:00:00:02
00:00:03:00:00:02
00:00:01:00:00:01
00:00:02:00:00:01
00:00:03:00:00:01
00:00:04:00:00:01
For enabling greedy routing we need only two simple extra
actions. These experimenter actions assume that the meta-
data register holds two values: a distance and a port number.
The action update-distance calculates the distance between
its ﬁrst argument and the (geographical) destination address
of the packet being processed. If the distance is smaller than
the one stored in the metadata register, then it saves the dis-
tance and its second argument in the metadata register. Our
second general purpose action, output-by-metadata forwards
packet to the port stored in the metadata.
Obviously, the routing decision can be implemented as a
controller application without any need for protocol exten-
sions. However, controller based greedy routing results in
slower connection setup and error recovery, and more im-
portantly the ﬂow table size is proportional to the actual
number of ﬂows. On the other hand, by using enhanced
switches, the table size is proportional only to the number
of ports and the forwarding speed is independent of the traf-
ﬁc load.
200% link utilization with Network Coding: Net-
work coding (NC) may mix or encode packets before for-
warding, hereby improving resource eﬃciency and robust-
ness [4]. However, implementing NC as an OF controller
logic is practically impossible since every packet would have
to be sent back and forth to the controller for en-/decoding.
We extended the OF protocol with three simple actions to
support XOR-based mixing of two ﬂows. NC metadata is
sent in three MPLS labels following the format proposed
in [5] (Fig. 1). The outermost label is a ﬂow identiﬁer that
can be used as a matching condition in the ﬂow table. Se-
quence numbers can be prepended to packets by the action
set-mpls-label-from-counter and two ﬂows can be combined
with the XOR-encode action. XOR-encode does not alter
the packet in the OF processing pipeline, it creates a copy
of the packet and puts it in the encoding queue or if there
is a pending packet from the other ﬂow, then it mixes them,
replaces the MPLS ﬂow-id, and sends the resulting packet
through the pipeline. This ﬁnal step ensures general ap-
plicability because further processing of the newly created
packet can be speciﬁed with standard ﬂow table entires. The
XOR-decode action works similarly, but it searches match-
Figure 2: Demonstrated topology.
ing sequence numbers when it dequeues a packet from the
decoding queue.
These three new OF actions are quite simple, but in the
meantime they are general enough to support several NC
use-cases deﬁned in [4], e.g., intersession multicasting, delay
or energy minimalization. To the best of our knowledge this
will be the ﬁrst NC implementation in OF and we hope
that our case study will trigger further developments and
discussions about the NC-OF interworking.
3. DEMO SCENARIO
For demonstration we have ported our extensions into
OpenWRT ﬁrmware and built a testbed with TP-Link de-
vices.5 The demo topology shown in Fig. 2 can accommo-
date all of our testbeds. Video streams are sent using diﬀer-
ent forwarding schemes in a conﬁgurable manner. Changing
the active controller results in switching among the three
network operations.
4. REFERENCES
[1] N. McKeown et al. OpenFlow: enabling innovation in
campus networks. ACM SIGCOMM CCR, 38(2), 2008.
[2] P. Jokela et al. LIPSIN: Line speed publish/subscribe
inter-networking. ACM SIGCOMM CCR, 39(4), 2009.
[3] M. Boguna, F. Papadopoulos, and D. Krioukov.
Sustaining the internet with hyperbolic mapping.
Nature Communications, 1(6), 2010.
[4] P. A. Chou and Y. Wu. Network coding for the internet
and wireless networks. IEEE Signal Processing
Magazine, 24(5), 2007.
[5] T. Biermann, A. Schwabe, and H. Karl. Creating
butterﬂies in the core – a network coding extension for
MPLS/RSVP-TE. In Proc. of Networking, 2009.
5Our implementation extends OF 1.1 software switch by
TraﬃcLab, Ericsson Research.
86