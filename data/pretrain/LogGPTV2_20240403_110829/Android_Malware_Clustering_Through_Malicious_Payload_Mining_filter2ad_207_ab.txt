a bit-vector format ﬁngerprint through feature hashing technique using djb2
hash function. During feature hashing process, we use a tuple A(i, j) to represent
a feature position, in which i is the function oﬀset indicating from which function
the particular n-gram feature is extracted, and j is the bytecode oﬀset indicating
the position of the n-gram feature within the corresponding function. Then the
feature-to-bit information is stored in a map, in which the key is the bit index
within the ﬁngerprint indicating where the feature is stored, and the value is the
list of feature tuples that are mapped to the bit location. With increased feature
space, we hope to reduce majority of the random feature collisions, and allow
each bit index to represent the same n-gram feature content.
Similar to the complete Android apps, individual legitimate libraries and the
candidate malicious payloads are also represented in the same size of bit-vector
ﬁngerprints. The concrete n-gram size and the ﬁngerprint size used for clustering
are determined through analyzing the collision rate of random features, which is
discussed in Sect. 6.2.
To measure the similarity between two ﬁngerprints, we use the Jaccard index,
or the Jaccard similarity, which is deﬁned as the size of intersection divided by
the size of union of two sets. Since each ﬁngerprint is a bit-vector, we leverage
cache-eﬃcient bit-wise AND (∧) and bit-wise OR (∨) operations to compute the
intersection and the union. Then, the similarity of two ﬁngerprints fpa and fpb
is deﬁned as follows:
Similarity(fpa, fpb) = S(fpa ∧ fpb)
S(fpa ∨ fpb) ,
where S(·) denotes the number of 1-bits in the input.
(1)
Our ﬁxed-sized bit-vector ﬁngerprint representation also allows us to easily
measure containment ratio in a similar fashion:
Containment(fpa, fpb) = S(fpa ∧ fpb)
S(fpa)
,
(2)
which measures how much of the content of fpa is contained in fpb.
198
Y. Li et al.
3.2 Fingerprint Based Library Code Removal
To precisely remove legitimate library code without excluding a possibly injected
malicious payload, we exclude legitimate library code from an app by removing
the library-mapped bits from the app bit-vector ﬁngerprint. For each legitimate
library, we collect its oﬃcial jar ﬁle and disassemble it into Dalvik bytecode
sequences; then apply the same feature hashing technique to map the n-gram
features of the library code into a bit-vector ﬁngerprint fplib. We then ﬂip all
the bits in the library ﬁngerprint to get fplib. Since the same features contained
in an Android app and the library are mapped to the same bit positions in
their ﬁngerprint representation, we can exclude library-mapped bits from an
app ﬁngerprint by bit-wise ANDing fplib and fpapp. Figure 3 demonstrates the
overall procedure to safely remove legitimate twitter4j library code from a
malware sample.
Malware A1
Twi(cid:425)er4j Lib
fp
1A
Malware A1 ﬁngerprint 
111101110010011
1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
Apf
1
pf
lib
000011110000000
1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
Twi(cid:425)er4j library ﬁngerprint 
fp
lib
Malware-A1 library ﬁltered ﬁngerprint 
fp
'
1A
aa
111100000010011
1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
Malware A1
Malware A2
fp
1A
Malware A1 ﬁngerprint 
011110011100001
1   2   3  4   5   6   7   8   9   10  11  12  13  14   15
pf
pf
A
2
111100000011110
Afp
2
1
Candidate payload “A1-2ﬁngerprint
A
1
011100000000000
1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
Malware A2 ﬁngerprint 
fp
2A
Fig. 3. Example procedure to safely
remove legitimate “twitter4j” library
code
Fig. 4. Extracting a candidate payload
from two malware applications
We ﬁrst conduct statistical analysis for the disassembled apps to identify the
embedded legitimate libraries, and record the years when the target samples
were created. We then obtain2 the oﬃcially released library jar ﬁles to create
the corresponding library ﬁngerprints, and remove the library code from the
analyzed apps. The library code removal process is applied only when an app
contains code snippets that are deﬁned under corresponding library namespaces.
In our implementation, each library is represented with an individual ﬁnger-
print. We encode multiple versions of the same library together in a single library
ﬁngerprint. This aggregated library representation may cause potential feature
collision between the app code and the irrelevant versions of the library code.
However, we empirically demonstrate in Sect. 6.3 that the library code removal
process is precise because diﬀerent versions of the same library typically share
high level of code similarity due to code reuse, and the size of the single library
is often smaller than the entire app.
3.3 Fingerprint Based Candidate Payload Extraction
The next operation is to extract malicious payloads from malware samples. We
consider the shared code segments (after excluding legitimate libraries) between
2 We randomly select one version of library in each year in case there are multiple
versions of libraries released within the same year.
Android Malware Clustering Through Malicious Payload Mining
199
each malware sample pair to be a candidate malicious payload. For a group of
malware samples, we obtain the intersection of every ﬁngerprint pair of library-
excluded samples, and consider the shared 1-bits between the sample ﬁngerprints
as a candidate payload ﬁngerprint.
Figure 4 describes the intersection analysis procedure to extract a candidate
malicious payload at a high level. For two malware samples we ﬁrst build their
ﬁngerprints and exclude the legitimate library bits from the ﬁngerprints. Then we
pinpoint their shared 1-bits (e.g., bits index 2, 3, and 4) as potentially malicious3
bits and construct a candidate payload ﬁngerprint.
During the candidate payload extraction process, we keep track of the asso-
ciation information between the candidate payload (e.g., A1-2) and the corre-
sponding samples (e.g., A1 and A2). We subsequently use the payload-to-app
association information and the malicious payload mining results to group mal-
ware samples.
3.4 Fingerprint Based Malicious Payload Reconstruction
Using the bit-vector ﬁngerprint representation, we can also deﬁne the cluster
ﬁngerprint for a version of the candidate payload cluster as the intersection of
all the candidate payload ﬁngerprints in the cluster. The 1-bits contained in the
resulting cluster ﬁngerprint can be viewed as the shared malicious bits for all
input apps that share the same version of malicious payload.
Using the identiﬁed malicious bits from app ﬁngerprints, we can then recon-
struct the corresponding malicious payload code by checking the feature-to-bit
mapping information that was recorded during feature hashing, which can be
viewed as the reverse procedure of ﬁngerprint generation. Given the identiﬁed
malicious bits, we locate the feature tuples that are mapped to those identiﬁed
malicious bits. We use each retrieved feature tuple to locate the n lines of code
where the n-gram feature is extracted, then reconstruct complete malicious code
sequences by properly stitching the identiﬁed n lines of code segments together.
In practice, feature collision is possible but becomes negligible with appro-
priate n-gram size and ﬁngerprint size, thus we will rarely recover the irrele-
vant code. To certain extent, payload code reconstruction compensates feature
hashing collisions (e.g., resulting in missing n-grams) as far as the missing n-
gram is within the overlapped original code sequences of recovered features.
The reconstructed malicious payload code can be further inspected to verify its
maliciousness.
4 Malicious Payload Mining
Key insights: (a) In practice, when feature hashing is conﬁgured to have a
low collision rate, malware app ﬁngerprints will not contain a large number of
shared 1-bits unless they do share certain common features (e.g., payload code
3 malicious payload mapped.
200
Y. Li et al.
snippets). (b) Likewise, if a target dataset contains malware samples that do
share the same version of the malicious payload, then the candidate payload
ﬁngerprints extracted from those samples will contain similar shared 1-bits and
be automatically clustered into the same group. (c) After removing legitimate
library code from an app, similar malicious payloads have higher chances to form
a larger cluster than the ones related to less popular libraries or coincidentally
shared code segments. (d) Compared to coincidentally shared code segments,
similar malicious payloads will have a larger shared code base because of “legiti-
mate” reason of code reuse in the same malware family, and the ﬁngerprints for
the malicious payloads will have a larger amount of shared 1-bits.
Based on the above key insights, we design the following strategies to itera-
tively select representative candidate payload clusters based on payload popular-
ity, which is determined based on the three criteria: the entry size of a payload
cluster l, the number of distinct apps associated with a payload cluster m, and
1-bits count of a payload cluster ﬁngerprint k.
– We count the number of candidate payload ﬁngerprint entries in each cluster,
and maximize the possibility of extracting core malicious payloads by selecting
the clusters with the largest number of payload ﬁngerprint entries. Payload
cluster size l is a direct indicator for the popularity of the shared code segments
between malware samples, and such popular shared code is a good candidate
for one version of malicious payloads since we have already ﬁltered out popular
legitimate library code.
– We measure the distinct apps m that contribute to generating candidate pay-
load ﬁngerprints of each cluster, and select the clusters with the largest number
of distinct apps if they have the same number of payload entries. Payload clus-
ters that contain a large number of unique payload entries are often associated
with a large number of distinct apps, and we use this app association informa-
tion to break the tie in case the number of cluster entries are the same since
distinct apps can be considered as another sign of comparative popularity.
– We obtain the intersection bits k of payload ﬁngerprint entries in each clus-
ter as the cluster ﬁngerprint. If two clusters are associated with the same
number of distinct apps, we then select the one with the larger number of
1-bits in its cluster ﬁngerprint. In this way, we can extract the payload with
a larger code size, and it helps to increase the likelihood of getting malicious
payloads together with shared libraries, and we subsequently exclude possibly
remaining libraries later.
– During cluster selection, we keep track of which apps have been used to gen-
erate candidate payload ﬁngerprints in the previously selected clusters, and
consider already-selected apps as “inactive”. We update the remaining pay-
load clusters by removing candidate ﬁngerprint entries that are associated
with “inactive” apps. Skipping such ﬁngerprints allows us to extract one ver-
sion of the malicious payload from each app. This helps to merge all the
shared core malicious code together, and only extract the widely shared mali-
cious code between all apps, which also helps to reduce the probability of
extracting non-malicious payload code.
Android Malware Clustering Through Malicious Payload Mining
201
– We omit a payload cluster if the corresponding cluster ﬁngerprint contains
less than the minimum k number of 1-bits, meaning that the extracted code
segments are too small. It forces the algorithm to break the current large pay-
load cluster into smaller clusters with a larger code size, and prevent diﬀerent
malware families from being clustered together. We set the minimum number
of 1-bits k to 70 since the majority of the analyzed Android malware app
ﬁngerprints had more than 70 1-bits.
– We exclude a candidate payload cluster if it becomes empty after the update in
the last step, or if the number of payload ﬁngerprint entries is too small (e.g.,
l = 1). This is because Clusters with only a single candidate payload entry
provide little additional popularity information, and are more likely to contain
less popular libraries or other coincidentally shared code snippets. We consider
malware samples associated with such payload clusters as unclustered, and the
unclustered app is evaluated as a singleton.
The shared payloads between Android samples can be library code seg-
ments, malicious payloads, copy-and-pasted code segments, or other coinciden-
tally shared code segments. The above payload mining strategy enables us to
select the most likely malicious candidate payload groups. Legitimate non-library
reused code may be collected together with malicious payload only if it is shared
across a signiﬁcant number of apps. Otherwise, the less popular legitimate non-
library code will be evidently excluded during the (popularity-based) payload
mining procedure. If the same benign app is indeed used by many malware
apps, we can further exclude original benign app code (i.e., the legitimate non-
library reused code) in a similar way to remove library code using a benign app
ﬁngerprint.
5 Optimize Overall Clustering Eﬃciency
2
According to the previously discussed malicious payload mining procedure, we
will generate n×(n−1)
versions of candidate payload ﬁngerprints given n malware
samples, but the hierarchical clustering algorithm also has a quadratic complex-
ity with respect to the number of analyzing targets. Due to the overall quartic
complexity of the algorithm, directly using it to analyze large number of samples
becomes a time-consuming task. Therefore, we further develop two methods to
improve the scalability of the clustering analysis procedure, and hereafter refer
them as Opt-1, and Opt-2.
5.1 Opt-1: Optimize Each Pairwise Computation
The ﬁrst method to speed up the overall clustering process is to optimize each
pairwise computation. Broder proposed minHash [3] to quickly estimate the
Jaccard similarity of two sets without explicitly computing the intersection and
the union of two sets. By considering our bit-vector ﬁngerprint as a set, we apply
minHash to further transform a large ﬁngerprint into a smaller size signature, and
202
Y. Li et al.
calculate the similarity of minHash signatures to estimate the Jaccard similarity
of the original ﬁngerprints.
To apply minHash, we deﬁne a minHash function output of our bit-vector
ﬁngerprint h(fp) to be the ﬁrst non-zero bit index on a randomly permutated
bits order of the ﬁngerprint. We then apply the same minHash function to two
ﬁngerprint fpa and fpb. This will generate the same minHash value when the
ﬁrst non-zero bit indexes for two ﬁngerprints fpa and fpb are the same. Since
the probability that the ﬁrstly encountered bit is a non-zero bit for fpa and fpb
is conceptually the same as Jaccard similarity Similarity(fpa, fpb) [18], we use
such probability P r[h(fpa) = h(fpb) to estimate the original Jaccard similarity.
The probability estimation becomes more accurate if more independent min-
Hash functions are used together. Formally, we deﬁne a minHash signature
sig(fp) to be a set of k minHash function values extracted from k round of
random permutations over the ﬁngerprint, and represent it as follows: sig(fp) =
[h1(fp), h2(fp), ..., hk(fp)]. We denote the similarity of two minHash signatures as
the ratio of equal elements between sig(fpa) and sig(fpb).
Instead of maintaining k random permutations over the bit-vector, we follow
a common practice for using minHash technique and use k diﬀerent hash func-
tions to simulate k random permutations, where each hash function maps a bit
index to a value. In order to create k hash functions, we ﬁrst generate k random
numbers, then use FNV [9] hash algorithm to produce a basic hash output for
each bit index, and ﬁnally apply XOR operation between each random number
and the hash output to get the k hash outputs. For each hash function, we select
the smallest hash value (to simulate the ﬁrst non-zero bit index) over all of the
bit indexes of the ﬁngerprint as the ﬁnal hash output.
Note that the FNV hash value and the k random numbers are all 32 bits
unsigned integers, and they can be used to safely simulate random permutation
over 512MB bit-vector ﬁngerprint. In practice, the k value usually needs to be
larger than 100 to generate good enough results [18]. We set k to be 256 in our
experiments, and thus convert each bit-vector ﬁngerprint into a 1 KB minHash
signature.
In order to evaluate the potential impact of Opt-1 on accuracy, we conduct
two experiments on the smallest 50 malware families4: one experiment (Exp-1)
with no optimization, and another experiment (Exp-2) using Opt-1. We used the
clustering output from Exp-1 as a reference, and measured the precision and
recall of the clustering output from Exp-2. The precision and recall indicate how
similar the two experiments results are, and are used to check the impact on
accuracy brought by Opt-1.
Our experiments showed that on average Exp-2 took less than 83% time to
complete compared to Exp-1 for the analyzed families, and the average preci-
sion and recall of the clustering output were 0.993 and 0.986. Opt-1 signiﬁcantly
reduce the overall memory consumption with minHash signature representa-
tion and improve the pairwise computation eﬃciency with almost zero accuracy
penalty.
4 We select those families since their family sizes are under 100 and all the experiments
for those families can be ﬁnished within 1 h.
Android Malware Clustering Through Malicious Payload Mining
203
5.2 Opt-2: Employ approximate clustering
The previous optimization is still not suﬃcient for using the algorithm to analyze
large scale malware samples. For instance, when analyzing with 2,000 samples,
the algorithm will create 1,999,000 candidate payloads, and it results in approx-
imately 2.0 × 1012 pairwise comparison. Even 1% of the total comparison still
takes lots of computation resources. To resolve the scalability issue for a large
dataset input, we further adopt prototype-based clustering technique [16,22] to
achieve approximate clustering.
Speciﬁcally, we randomly divide the target samples into small size (e.g., 150)
groups. For each group, we apply hierarchical clustering analysis on the shared
payload within the group, and create a prototype ﬁngerprint for each payload
cluster by applying intersection analysis (to obtain all the shared 1-bit) among
the payload ﬁngerprints in each cluster. We then conduct hierarchical clustering
analysis on all the collected prototype ﬁngerprints. In this way, we represent