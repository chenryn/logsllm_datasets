1,107
69
621
599
1,013
1,222
323
448
264
1,101
909
219
15
16
65
129
58
41
0
0
0
Speed (#/sec)
647.86
902.95
1,318.31
902.31
1,245.03
1,466.71
1,092.41
2,552.81
884.50
837.65
1,443.22
Table III: Accumulated coverage rate in comparison with
HALucinator
Firmware
Halucinator
Para-rehosting
WYCINWYC
Atmel lwIP HTTP (Ethernet)
Atmel lwIP HTTP (TCP)
STM UDP Server
STM UDP Client
STM TCP Server
STM TCP Client
STM ST-PLC
NXP TCP Server
NXP UDP Server
NXP HTTP Server
25.99%
47.65%
6.21%
28.37%
29.55%
40.31%
41.90%
3.19%
27.31%
24.35%
45.83%
27.91%
70.51%
6.26%
32.82%
38.22%
48.60%
56.88%
25.05%
40.66%
24.96%
54.43%
test-case generation,
of three parts,
test-case feeding, and
program execution. Here, we only estimated the overhead of
test-case feeding and program execution, because test-case
generation should be the same for all the approaches. We used
the pyOCD [39] to control an NXP FRDM-K64F development
board and simulated the feeding process. The python script
writes a known test-case into a reserved memory region of
the board 1,000 times. The program on the board terminates
after the iteration is ﬁnished. When transferring a test-case
of 1 KB, it takes about 0.23 seconds for one test-case to be
transferred. We also compared the execution speed of the same
workload with para-rehosting, Zephyr QEMU and the FRDM-
K64F board. We found the execution speed of FRDM-K64F
board is 14 times slower than that of the QEMU and 287 times
slower than that of para-rehosting. In summary, the fuzzing
speed on real devices is much lower than both our approach
and emulation-based approaches.
C. CVE Analysis
We have found 28 previously-unknown bugs as shown in
Table IV. Five of them were conﬁrmed by CVE. For the
rest, we have reported them to the manufacturers or vendors
and 19 of them have been conﬁrmed at the time of writing.
All the bugs were caused by memory errors and captured by
ASAN. Therefore, we argue that existing solutions without
memory checker support, such as emulation-based or on-
device analysis, are less effective in ﬁnding these bugs.
CVE-2019-13120. The MQTT library lacks length checking
for the received publish message. Attackers can manipulate
this ﬁeld so that out-of-range memory access is triggered. The
Table IV: Previously-unknown bugs found
FreeRTOS
FreeRTOS
FreeRTOS
FreeRTOS/Mbed OS
RTOS
ID
1
2
3
4
5 Mbed OS
6 Mbed OS
7 Mbed OS
8 Mbed OS
9 Mbed OS
10
11
12
13
LiteOS
LiteOS
LiteOS
Bare-metal
Library
Bug type
Number
Status
MQTTv1
FATFS
uTasker Modbus
lwip
MQTT
CoAP Parser
CoAP Builder
Client-Cli
Client-Cli
MQTT
LWM2M
LWM2M
STM-PLC
Buffer Overﬂow
Use After Free
Buffer overﬂow
Buffer overﬂow
Null Pointer
Dereference
Buffer Overﬂow
Integer overﬂow
Buffer Overﬂow
Off by one
Buffer Overﬂow
Use after free
Buffer Overﬂow
Buffer Overﬂow
1
1
5
3
1
1
1
2
1
2
1
1
8
CVE-2019-13120
CVE-2019-18178
Conﬁrmed
Conﬁrmed
CVE-2019-17210
CVE-2019-17212
CVE-2019-17211
Conﬁrmed
Conﬁrmed
submitted
submitted
submitted
Conﬁrmed
authorized memory is later sent out through the acknowledge
packet, leading to a two-byte information leakage.
CVE-2019-18178. The ﬁle handler freed by the function
ffconfigFREE() is reused by the function FF_Flush-
Cache(). This bug can be immediately discovered using any
test-case with the help of ASAN. However, this library has
never been executed against ASAN before and thus the bug
had not been identiﬁed for long. This highlights the importance
of the memory checker in analyzing ﬁrmware.
CVE-2019-17210. The MQTT message can be manipulated
so that an if statement is invalided, leaving the default value
of mqttstring->lenstring.data (NULL) unchanged.
Later, this pointer is used.
CVE-2019-17212. The CoAP message is linearly parsed by
the function sn_coap_parser_options_parse() in-
side a while loop. However, inside the loop, the boundary of
the message is not properly checked.
CVE-2019-17211. Two variables of type uint16_t are ad-
ded. The result is used to allocate a buffer. When the addition
wraps around the maximum, less memory is allocated than
expected.
in the Client-Cli
Others. Three bugs exist
library of the
Mbed OS. This library parses the commands sent
to the
device. If the command is manipulated, e.g., by removing the
NULL character or adding too many delimiters, buffer overﬂow
or off-by-one bugs may occur. The library uTasker Modbus
has deﬁned several global arrays with a length deﬁned by
the macro MSG_TIMER_EVENT. However, there is no offset
9
check against the maximum length. The library lwip copies
the data from the data structure pbuf which is implemented
as a linked list. It only copies from one sub payload with the
length of the whole payload. The MQTT library of LiteOS
has an incorrect deﬁnition of an array and does not check
the validity of a pointer to the MQTT topic before accessing
it. The library LWM2M accesses a deallocated memory when
closing the LWM2M session and does not perform boundary
check when traversing the received CoAP packet. The STM-
PLC application does not check the value of an increased or
decreased array index, leading to buffer overﬂows.
D. Identifying the Gap
Due to the architectural gap, we cannot guarantee that our
results obtained on the rehosted program can be reproducible
on real MCU devices. To identify this gap, we developed a
dataset comprised of vulnerable MCU OS libraries, and tested
different behaviors when running them para-rehosted and on
the real device. We want to know if the bugs identiﬁed by
our approach are real bugs that can inﬂuence real devices.
During this experiment, we found that triggering a bug on
the real device rarely crashed the ﬁrmware immediately. This
observation agrees with previous work [43]. Therefore, we
revisited this problem and further measured the different levels
of corruption observability on Linux machines and on real
MCU devices.
1) Dataset: We crafted a corpus of code snippets with both
the real bugs and artiﬁcial bugs. For real bugs, we included
the nine re-producible bugs in the FreeRTOS+TCP library
originally reported by Zlab [26] (part 1), plus the 28 new
bugs discovered in this work (part 2). For artiﬁcial bugs, we
manually inserted eight types classic bugs in an empty RTOS
task (part 3). Note that running code in part 3 should directly
trigger the bugs without inputting any test-case. The dataset is
listed in Table V.
2) Bug Re-producibility: We manually fed the test-cases
that can trigger bugs on rehosted programs to the NXP FRDM-
K64F board, and observed if the bug can be triggered. We
used the on-board CMSIS-DAP debug interface to track the
execution and manually veriﬁed that all the 28 bugs in part
2 of our dataset can inﬂuence the real device. This indicates
that the buggy source code can be easily manifested on any
architecture. However, the ﬁrmware did not crash immediately.
This is because the injected memory errors were not critical
enough to trigger observable hard faults. For these bugs, the
ﬁrmware would crash non-deterministically in a long run,
depending on the execution context. This behavior imposes
negative inﬂuences to bug hunting on real devices. Speciﬁcally,
during fuzzing, since the execution terminates immediately at
exit points, these memory corruptions usually cannot cause
observable crashes.
Regarding exploitability, due to the architecture differences
(e.g., different ISA and stack layout), a working proof of
exploitation (PoE) on the rehosted ﬁrmware might not work
on real devices. Typically, PoE construction is conducted case-
by-case and bug exploitation is orthogonal to this work.
3) Understanding the Bug Observability Gap: The bug
observability issue on embedded systems was ﬁrstly explained
by Muench et. al. [43]. It imposes a huge challenge in fuzzing
Table V: Dataset and bug observability
ID
RTOS
Library
Bug type
Observability
Para-rehosting
Real Board
FreeRTOS+TCP
FreeRTOS+TCP
FreeRTOS+TCP
FreeRTOS+TCP
FreeRTOS+TCP
FreeRTOS+TCP
FreeRTOS+TCP
FreeRTOS+TCP
FreeRTOS+TCP
1
2
3
4
5
6
7
8
9
10
FreeRTOS MQTT
11
FATFS
FreeRTOS
12
FreeRTOS
uTasker Modbus
13
uTasker Modbus
FreeRTOS
14
uTasker Modbus
FreeRTOS
15
uTasker Modbus
FreeRTOS
16
uTasker Modbus
FreeRTOS
17
lwip
FreeRTOS
18
lwip
FreeRTOS
19
FreeRTOS
lwip
20 MbedOS
MQTT
21 MbedOS
CoAP Parser
22 MbedOS
CoAP Builder
23 MbedOS
Client-Cli
24 MbedOS
Client-Cli
25 MbedOS
Client-Cli
26
MQTT
27
MQTT
28
LWM2M
29
LWM2M
30
STM-PLC
31
STM-PLC
32
STM-PLC
33
STM-PLC
34
STM-PLC
35
STM-PLC
36
STM-PLC
37
STM-PLC
38
FreeRTOS
39 MbedOS
40
FreeRTOS
41 MbedOS
42
FreeRTOS
43 MbedOS
44
FreeRTOS
45 MbedOS
46
FreeRTOS
47 MbedOS
48
FreeRTOS
49 MbedOS
50
FreeRTOS
51 MbedOS
52
FreeRTOS
53 MbedOS
LiteOS
LiteOS
LiteOS
LiteOS
Baremetal
Baremetal
Baremetal
Baremetal
Baremetal
Baremetal
Baremetal
Baremetal
FreeRTOS
FreeRTOS
FreeRTOS
FreeRTOS
FreeRTOS
FreeRTOS
FreeRTOS
FreeRTOS
FreeRTOS
n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a
Buffer Overﬂow
Buffer Overﬂow
Integer Underﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Use After Free
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Null Pointer
Buffer Overﬂow
Integer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Off By One
Buffer Overﬂow
Buffer Overﬂow
Use after free
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Div By Zero
Div By Zero
Integer Overﬂow
Integer Overﬂow
Stack Overﬂow
Stack Overﬂow
Heap Overﬂow
Heap Overﬂow
NULL Pointer
NULL Pointer
Double Free
Double Free
Use After Free
Use After Free
Format String
Format String
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
Y
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N