●练习题1-9-1：求所有的缺失编号——NOTEXIST和外连接
正文中提到过，SQL里有很多方法可以实现差集运算。正文里介绍了
使用 EXCEPT和NOT IN实现的方法。请思考一下使用NOT EXISTS 和外
连接实现的方法。
---
## Page 179
●166—第1章神奇的SOL
练习题1-9-2：求序列—面向集合的思想
在“三个人能坐得下吗”部分，我们用NOTEXISTS表达了全称量化，
进而求出了序列。请思考一下如何使用HAVING子句来解决这个问题。
在解决了不考虑换排的情况之后，请再思考一下考虑换排的情况。
练习题1-9-3：求所有的序列——面向集合的思想
这里练习用集合论的方法去完成与谓词逻辑同样的功能。在“最多能
坐下多少人”部分，我们使用NOTEXISTS求出了所有的序列，并将它们
存储在了视图里。请将那条SQL语句用HAVING子句改写。思路和练习题
1-9-2大致相同，只不过特征函数的条件稍微复杂一些。
图灵社区会员 非洲钢(PI:EMAIL) 专享 尊重版权
---
## Page 180
110HAVING子句又B来了
Q：
HAVING子句又回来了
再也不要叫它配角了！
BAVING子句是SQL中的重要功能之一。在1-4节中，我们学习了它的一部分强大功能。在本节中，
我们将继续学习HAVING子句的应用技巧，这些技巧充分体现了HAVING子句“调查集合自身性质”的特长。
我在教SQL课程的时候，最重要的课题之一是让学生们暂时忘摔
（unleam）他们已经习惯了的面向过程语言。我使用的方法是强调SQL的
处理单位不是记录，而是集合。
注0
Joe Celko
2005年。
be Deko,
写在前面
在前面章节中我们曾多次说过，学习SQL时最大的阻碍就是我们己
经习惯了的面向过程语言的思考方式（排序、循环、条件分支、赋值等）。
为了深入理解SQL的本质，我们必须暂时弃已有观念，返璞归真一
这就是Joe Celko 说的 unleam 的意思。Joe Celko 本人最初是从 Fortran 开
始程序员职业生涯的，然后接触了C、Algol、Pascal等面向过程语言之后
才学习的SQL，所以他的话应该是有感而发。
不过说起来容易做起来难。放弃掉长期以来习惯了的思考方式，恐怕
对任何人来说都不是一件简单的事情。笔者认为，学习HAVING子句的用
法是帮助我们顺利地忘掉面向过程语言的思考方式并理解SQL面向集合
特性的最为有效的方法。这是因为，HAVING子句的处理对象是集合而不
是记录，所以只有习惯了面向集合的思考方式，才能真正地学好它。
好了，接下来我们再来感受一下“HAVING子句的力量”吧。这回也
要画很多维恩图，大家准备好纸和笔了吗？
---
## Page 181
168—
—第1章神奇的SQL
各队，全体点名
首先恭喜你被任命为了消防队（或地球保卫队）总负责人。现在你收
到了来自司令部的出勤指示。
你需要做的是查出现在可以出勤的队伍。可以出勤即队伍里所有队员
都处于“待命”状态。我们使用的是下面这张表。
Teams
乔
待命
肯
1
出勤中
米克
1
待命
卡伦
2
出勤中
凯斯
2
休息
简
3
待命
哈特
3
待命
迪克
3
待命
贝斯
4
待命
阿伦
5
出勤中
罗伯特
5
休息
卡根
5
待命
这张示例表中，可以出勤的队伍是3队和4队。4队里虽然只有贝斯
1人，但是确实也是全队都集齐了。我们来思考一下求可以出勤的队伍的
SQL 语句。
“所有队员都处于‘特命”状态”这个条件是全称量化命题，所以可
以用NOTEXISTS来表达。
用请词表达全称量化命题
SELSCT tean_id, menber
T BueaL K0S4
MHERE HOT EXISTS
(SELBCT 
MMERE 71.tean_1d - T2.teas_id
FROM Teara T2
ANID atatua <>待命];
---
## Page 182
110HAVING子句文B末了 
169
■执行结果
tean_id  nember
3
简
哈特
迪克
贝斯
注0
这条SQL语句使用了下面这样的全称量化和存在量化之间的转换·。
如果不知道量化是什么，可以参
考 1-B节中的“理论简”，特势是
“全称量化和存在量化”部分。
“所有队员都处于待命状态”=“不存在不处于待命状态的队员”
这个查询性能很好，而且结果中能体现出队员信息，这些是它好的地
方。但是因为使用了双重否定，所以理解起来不是很容易。而如果使用
HAVING子句，写起来就非常简单了，像下面这样。
--用集合表达全称量化命题（1)
SELECT tean_id
HAVING COUNI(+) - SUM(CASE WHEN statUs = 待命
GROUP BY tean_id
THEN 1
BLSS O END| J
■执行结果
tean_1d
上面这条SQL语句是一个肯定句，理解起来更直观，而且代码很简洁。
接下来我们仔细看一下这条SQL语句具体做了些什么。第一步还是使用
GROUPBY子句将Teams集合以队伍为单位划分成几个子集。
---
## Page 183
●170—
第1章种奇的 SQL
S Teams
S11队伍
S22队伍
待命
出勤中
待命
休息
S33队伍
S44队伍
S55队伍
待命
待命
中用
待命
待命
特命
休息
目标集合是队员全部处于待命状态的S3和S4
目标集合是S3和S4，那么只有这两个集合拥有而其他集合没有的特
征是什么呢？答案是，处于“待命”状态的数据行数与集合中数据总行数
相等。这个条件可以用CASE表达式来表达，状态为“待命”的情况下返
回1，其他情况下返回0。也许大家已经注意到了，这里使用的是特征函
数的方法。
根据是否满足条件分别为表里的每一行数据加上标记1或0，这样更
好理解一些，如下表所示。
mber[队员）
team_id（队伍编号ID}
台山us|状泰丨特征函数标记
1
待命
1
肯
出勤中
0
米克
1
待命
1
卡伦
出勤中
0
凯斯
2
休息
0
简
3
待命
1
哈特
3
待命
1
迪克
3
待命
1
贝斯
4
待命
1
阿伦
5
出勤中
0
罗伯特
5
休息
0
卡根
5
待命
1
顺便说一下，HAVING子句中的条件还可以像下面这样写。
---
## Page 184
1-10HAVING子句又国末了—171
--用集合表达全称量化命题（2）
SELECT tean_id
GROUP BY tean_id
AND MIN(status）待命
这条SQL语句的意思大家明白吗？某个集合中，如果元素最大值和
最小值相等，那么这个集合中肯定只有一种值。因为如果包含多种值，最
大值和最小值肯定不会相等。极值函数可以使用参数字段的索引，所以这
种写法性能更好（当然本例中只有3种值，建立索引也并没有太大的意义）。
当然也可以把条件放在SELECT子句里，以列表形式显示出各个队伍
是否所有队员都在待命，这样的结果更加一目了然。
-列表显示各个队伍是否所有队员都在待命
SELBCT tean_id,
THEN全都在待命
ELSE·队长！人手不够END AS status
FROM Teans
GROUP BY tean_1d;
tean_1d
status
队长！人手不够
队长！人手不够
E
全都在待命
全都在特命
队长！人手不够
需要注意的是，条件移到SELBCT子句后，查询可能就不会被数据库
优化了，所以性能上相比HAVING子句的写法会差一些。至于选择哪种写法，
需要根据我们对信息量和性能的具体需求来判断。
单重集合与多重集合
在1-7节中我们也说过，关系数据库中的集合是允许重复数据存在的
多重集合。与之相反，通常意义的集合论中的集合不允许数据重复，被称
为“单重集合”（这是笔者自己造的词，并非公认的术语）。
允许循环插入和频繁读写的表中有可能产生重复数据。在定义表时加
---
## Page 185
172—第1章神奇的SQL
入唯一性约束可以预防表中产生重复数据，但是有些情况下根据具体的业
务需求不同，产生重复数据也是合理的。
例如，有下面这样一张管理各个生产地的材料库存的表。
Materials
[eoaine_dabe （入库目期]
malerial（材料）
东京
2007401
锡
东京
2007412
锌
东京
2007517
铝
东京
2007520
锌
大阪
2007420
大阪
2007422
镍
大阪
2007429
铅