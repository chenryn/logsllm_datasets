each run, we delete the ﬁle and synchronize the ﬁle system
to reliably capture the overhead of PFS. Figure 4 shows the
PFS performance for different payload sizes up to 1MB. The
runtime includes enclave as well as OCALL computation.
The simple standard deviation is shown as area around the
curves.
The maximum overhead for protecting PFS with SGXJail
is roughly around 20%. There is almost constant runtime
up to 2 kB payloads for SGXJail and the unprotected vanilla
enclave with a sudden increase at 4 kB payloads. The reason
is that the PFS library caches smaller chunks of data and
defers actual ﬁle writing to closing the ﬁle with sgx_fclose
with 8 OCALLs in total. When exceeding the internal buffer
of 3072 bytes, the PFS library ﬂushes data to the ﬁle system
using 7 more OCALLs, resulting in the sudden increase of
the absolute runtimes for SGXJail and the vanilla enclave.
For larger payloads (4 kB and more), the overall overhead
does not increase but falls below 20%. This suggests that argu-
ment copying itself is not the bottleneck of PFS. We veriﬁed
this by manually removing argument copying in the sand-
box for the actual ﬁle write OCALL. Using 1 MB payloads,
the overhead dropped by roughly 3%. Rather than argument
copying, the runtime overhead of SGXJail is dominated by
the OCALL overhead since the PFS implementation chops
360          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX AssociationKA
KE
WRPKRU KE
CEENTER
WRPKRU KA|KE
G
C
Application
data
E/OCALL
arguments
Argument pages
Enclave
G
C
EEXIT
Figure 5: HSGXJail conﬁnes the enclave to pages marked
with memory protection key KE . Thus, the application
can protect its pages via a disjoint memory protection key
KA . ECALL/OCALL interaction is constrained to non-
enclave KE pages (dashed lines). Moreover, EEXIT can
only target a single exit point, namely the instruction fol-
lowing a CEENTER (a new conﬁned EENTER instruction).
larger payloads into a sequence of smaller OCALLs. In fact,
for 1 MB payloads we observed 313 OCALLs in total.
We have shown that SGXJail does not impede pure en-
clave computation (0% overhead). For real-world workloads
up to 10 000 OCALLs/Esec, the overhead is below 3% (cf.
Figure 3). Even for uncommonly high OCALL frequencies
(100 000 OCALLs/Esec), the overhead of SGXJail is still be-
low 20%, whereas plain writing of protected ﬁles with high
OCALL interaction comes at only 20% overhead. To fur-
ther improve performance, SGXJail could use HotCalls for
faster enclave communication [61]. Alternatively, we propose
a lightweight hardware extension (HSGXJail) which provides
SGXJail isolation at virtually no overhead.
Memory overhead. SGXJail requires one additional process
for the sandbox. As for site isolation in browsers [47], this
incurs only a slight (constant) increase in used memory for
the sandbox and the shared memory used for communication.
5.4 HSGXJail via Hardware Conﬁnement
In this section, we propose a more efﬁcient defense mech-
anism via a minimal change to the SGX speciﬁcation with
respect to Intel memory protection keys (MPK), i.e., disallow-
ing one MPK instruction in SGX.
To prevent an enclave from accessing host application mem-
ory, we propose a stricter page access policy. To that end,
HSGXJail introduces two extensions: ﬁrst, data conﬁnement
and second, control conﬁnement. First, memory regions that
are not supposed to be used by the enclave shall be inacces-
sible to the enclave. Data conﬁnement limits memory pages
an enclave can read or write, thus breaking the arbitrary read
and write primitives. Second, EEXIT shall be only allowed
on well-deﬁned exit points. Control conﬁnement prevents
the enclave from misusing EEXIT to jump to arbitrary host
application code, thus breaking the arbitrary EEXIT primitive.
Data Conﬁnement with Intel Memory Protection Keys.
The central issue of enclave malware is an asymmetry in
the memory access policy, granting enclaves unrestricted
access to host-application memory. Data conﬁnement uses
a recent protection mechanism called memory protection
keys (MPK) [26] to partition virtual memory into enclave-
accessible memory and protected application memory. If the
enclave attempts to access protected application memory, the
CPU raises a page fault. To prevent the enclave from reconﬁg-
uring MPK, HSGXJail disallows certain MPK instructions in
enclave execution mode. Similar to SGXJail (cf. Section 5.1),
we use this mechanism to conﬁne enclave execution to a
narrow ECALL/OCALL interface, as shown in Figure 5.
Memory protection keys work as follows: they augment
page-based read, write and execute permissions with addi-
tional access policies. Each application page can be assigned
one particular memory protection key. This protection key is
stored directly in the corresponding page table entry (PTE).
By assigning different protection keys to different pages, MPK
allows to partition virtual memory pages into 16 disjoint pro-
tection domains. The PKRU CPU register controls which
access policy is applied to those protection domains. For each
of the 16 protection keys, PKRU allows to selectively disable
write and read access for the current execution thread. The
PKRU register can be updated via the unprivileged WRPKRU in-
struction, enabling frequent switching of protection domains
within the application. Since each CPU thread maintains its
own local PKRU register, MPK supports multithreading.
For HSGXJail, we partition the application into protection
key KA comprising all application pages and KE , covering
enclave memory as well as argument pages, as shown in Fig-
ure 5. Immediately before entering an enclave, the application
conﬁgures PKRU to conﬁne memory accesses to the enclave
only (WRPKRU KE). During enclave operation, the enclave can
only access argument pages for ECALL/OCALL arguments.
After leaving the enclave, the application re-enables full ac-
cess to the application itself ( KA ) as well as the argument
pages ( KE ) via WRPKRU KA|KE.
To prevent the enclave from manipulating MPK by re-
conﬁguring the PKRU register, HSGXJail demands a slight
modiﬁcation to the SGX speciﬁcation. Whenever HSGXJail
is active, the WRPKRU instruction is disallowed for the enclave
and raises an invalid opcode exception instead. This change
should be easily adaptable via a microcode update to the CPU.
HSGXJail poses no limit on the number of applications
using third-party enclaves, however, the number of enclaves
within a single application is restricted. Since MPK supports
up to 16 different protection domains, HSGXJail can natively
secure applications utilizing up to 15 distinct enclaves. Note
that one protection domain is needed for the application itself.
To support more enclaves per application, one can follow var-
ious approaches: First, in many cases enclaves provide simple
functionality, e.g., ECALLs without OCALLs, or OCALLs
for issuing syscalls but not towards other enclaves. In these
cases, enclaves are never called in an interleaved way and
thus, are never concurrently active. Hence, the application can
safely share the same argument pages and also the same pro-
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 361tection key among those enclaves. This increases the number
of supported enclaves by the degree of enclaves which are not
interleaved with other enclaves. Second, memory protection
keys can be dynamically updated and scheduled among dif-
ferent enclaves. While this supports an arbitrary large number
of enclaves per application, it incurs additional performance
penalty in updating protection keys in the PTEs.
Control Conﬁnement. Whenever leaving enclave execution
(via ECALLs and OCALLs), the enclave jumps into the host
application via an EEXIT instruction. However, since the en-
clave can freely choose the jump target of EEXIT, a variety of
code-reuse attacks become possible (cf. Section 4).
Data conﬁnement already limits an enclave’s read and write
access by means of MPK. While MPK protects data accesses,
it does not prevent fetching code from other protection do-
mains. This design choice is intentional to enable application
code to update protection domains without accidentally re-
moving access to its own code. Hence, data conﬁnement does
nothing to protect an application from rogue EEXITs.
To break the arbitrary EEXIT primitive, HSGXJail restricts
EEXIT to a single valid exit point. In particular, EEXIT can
only target the instruction immediately following a so-called
CEENTER instruction. This exit point is similar to the enclave
entry points used to protect an enclave from malicious applica-
tions, both of which are shown as call gates (CG) in Figure 5.
Control conﬁnement can be easily implemented via small
changes to SGX. We propose to extend the semantics of
EENTER via a novel conﬁned CEENTER instruction. From the
enclave’s perspective, CEENTER behaves exactly as EENTER.
EENTER already stores the exit point (i.e., the address of the
instruction immediately following EENTER) in register RCX.
However, SGX leaves it up to the enclave to store this exit
point and later on pass it to EEXIT. In contrast, our CEENTER
instruction additionally stores the exit point in a protected,
thread-local CPU register called OEXIT which is inaccessible
to the enclave. To make use of this exit point, we propose
to adapt the semantics of the EEXIT instruction, as follows:
Instead of jumping to a target provided by the enclave via reg-
ister RBX, our EEXIT ignores RBX and instead directly jumps
to the address stored in the protected OEXIT register. Both,
CEENTER and EEXIT can be implemented in CPU microcode.
Compatibility. To be fully compatible with existing enclave
software, we activate HSGXJail only on demand. If the appli-
cation issues a normal EENTER instruction, HSGXJail is inac-
tive and SGX behaves as usual. When entering the enclave via
our new conﬁned CEENTER instruction, HSGXJail is active
until EEXIT. Moreover, HSGXJail’s slim design is fully com-
patible with advanced SGX features such as multithreading,
dynamic memory management and virtualization [26]. Avail-
ability of HSGXJail can be indicated via a model-speciﬁc
register.
Software Considerations. HSGXJail protects applications
from existing, unmodiﬁed third-party enclaves. HSGXJail can
be integrated entirely within the SGX SDK [25], thus being
fully transparent to existing application code. This allows to
use HSGXJail by recompiling applications, without the need
to rewrite any application code.
To use HSGXJail, the SDK needs the following slight adap-
tations. First, the SDK replaces EENTER with CEENTER in the
untrusted urts library. The urts library already uses a sin-
gle exit point, which is the address immediately following
EENTER. The corresponding trusted trts library belonging
to the enclave performs EEXIT only towards this single exit
point. Since our modiﬁed EEXIT instruction enforces the same
exit point, it does not change the behavior of benign enclaves.
No changes to the trts library are required. Benign enclaves
compiled under the original trts library work out of the box.
For data conﬁnement, the SGX SDK needs to establish
enclave-accessible argument pages reﬂecting the ECALL/O-
CALL interface and conﬁgure memory protection keys ac-
cordingly. By default, all application code runs with protec-
tion key zero. Thus, the SDK assigns protection keys starting
with one to all enclave pages as well as the corresponding ar-
gument pages. Similar to the software-only variant, SGXJail,
the SDK can do this once when loading a new enclave.
When doing an ECALL, the SDK additionally copies all
input arguments from application memory to an enclave-
accessible argument page. In the same way, the SGX copies
back any output arguments from the argument page to appli-
cation memory at the end of an ECALL. The same applies to
OCALLs. While argument copying causes some overhead, it
is deemed necessary to generically prevent TOCTOU attacks
and guarantee the security of the application. For the same
reason, the enclave copies untrusted application arguments to
enclave memory before operating on it.
Before entering the enclave, the SDK saves all necessary
CPU registers in application memory, clears sensitive con-
tent from the registers and conﬁgures the application’s stack
pointer RSP to point to one of the argument pages. Conﬁgur-
ing RSP in that way causes the enclave to read and write any
OCALL arguments directly from/to the argument page, which
is enclave-accessible, without additional copying overhead.
After leaving the enclave, the SDK restores the application’s
CPU registers, including the stack pointer.
Performance Estimates. The only functionally necessary
change for HSGXJail is disallowing the WRPKRU instruction on
CEENTER, which can be easily implemented in the CPU. The
microcode changes we propose to CEENTER and EEXIT for
control conﬁnement are minimal and only comprise register
operations rather than memory accesses, resulting in negli-
gible performance overhead. Second, data conﬁnement via
MPK requires no change and shows the same performance as
for MPK without HSGXJail. Hence, it is reasonable to expect
a negligible overhead of HSGXJail in every aspect, far lower
than the overhead of the software-based SGXJail variant.
362          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Association6 Related Work
Defense by Detection. Researchers proposed to detect en-
clave malware by monitoring their I/O behavior [13, 16].
However, this is believed to be infeasible in practice [38].
Others proposed analyzing enclave code before actually run-
ning it [13], which is not feasible for generic loaders. Generic
loaders can remotely fetch arbitrary malicious code at runtime.
Refusing such generic loaders would annihilate all use cases
for protecting intellectual property. Instead, Costan et al. [13]
proposed to force generic loader enclaves to embed malware
analysis code within the enclave. However, it is unclear how
effective this technique is in detecting malicious code. It also
raises the question who decides which analysis code to embed
and to ensure the analysis code does not leak enclave secrets.
Also, analysis code cannot be easily updated, and enclaves
without analysis code cannot be executed without risk.
Defense by Prevention. While applying control-ﬂow in-
tegrity (CFI) to the host application sounds appealing, it
does not close all attack vectors outlined in Section 4. Al-
though hardware-assisted CFI can prevent some control-ﬂow
attacks [27], they are not yet available and might miss rogue
EEXIT attacks. Software CFI schemes like [31, 39] can sim-
ply be bypassed by leaking secrets and corrupting CFI meta-
data via the arbitrary read and write primitives. Moreover, no
CFI scheme can prevent data-only attacks.
Readactor [15], Heisenbyte [57], and NEAR [62] severely
limit the arbitrary read primitive necessary for many attacks by
forcing page faults when trying to access sensitive code. How-
ever, they have signiﬁcantly larger overhead than SGXJail,
and blind ROP attacks might still be possible [4]. Ryoan [23]
executes malicious enclaves inside a software sandbox using
software fault isolation (SFI). However, Ryoan demands re-
compilation of the enclave with SFI, which cannot be applied
in our setting. Also, Ryoan severely restricts the enclave life
cycle to a single stateless invocation, which is incompatible
to generic third-party enclaves.
7 Discussion
Since the very ﬁrst blog post in 2013 [48], the enclave mal-
ware threat has been discussed at a high level but was mostly
disregarded by the research community. With recent attacks
showing powerful and practical enclave malware, research on
proper defense mechanisms becomes pressing.
In this work, we identiﬁed three enclave primitives, namely
arbitrary memory reads, writes and EEXITs, which lie at the
heart of the enclave malware threat by exposing an application
to a variety of runtime attacks originating from misbehaving
enclaves. Although these primitives help support different
SGX programming models, they not only give rise to enclave
malware but they are unnecessary in practice, as enclaves
ought to strictly comply with the deﬁned ECALL/OCALL
interface. In particular, the enclave runtime services offered by
the SGX SDK demand precise EDL speciﬁcation of the data
exchanged, and bypassing this speciﬁcation is considered bad
practice. Moreover, the SDK uses only a single enclave exit
point, from which all ECALLs and OCALLs are dispatched.
Based on these observations, we proposed (H)SGXJail to
conﬁne enclave primitives to the narrow interface speciﬁed
by the EDL. This applies the principle of least privileges [49]
also to enclaves and closes a entire class of runtime attacks,
including information disclosure, control-ﬂow attacks, as well
as data-only attacks. Even more, by automatically copying
ECALL/OCALL arguments from and to application memory,
(H)SGXJail prevents double-fetch bugs [58] by design.
Furthermore, SGXJail paves the way for reasoning about
application security based on application code only (i.e., with-
out trusting any enclave code), and the ECALL/OCALL in-
terface in particular. While SGXJail defeats a entire class of
runtime attacks, it cannot solve the problem of too permis-
sive host interfaces, e.g., a syscall proxy [38] which allows