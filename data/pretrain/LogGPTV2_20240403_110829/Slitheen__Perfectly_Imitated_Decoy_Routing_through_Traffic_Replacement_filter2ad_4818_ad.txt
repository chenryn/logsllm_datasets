seeded input to determine whether the decoy session has been es-
tablished. If it has, the client proceeds to include X-Slitheen head-
ers with upstream data. If it has not, the client will verify the Fin-
ished message the traditional way and continue with a regular (non-
decoy) fetch of the page. A man-in-the-middle capable of viewing
the plaintext will therefore detect no unusual behaviour from the
client. This modiﬁcation also serves to notify the client of a failure
in the tagging procedure due to route asymmetry.
Server Collusion. In previous systems, the censor could collude
with or set up an overt destination server to entrap clients that use
that server for decoy routing purposes. In Slitheen, the client’s be-
haviour from the overt site’s perspective will be identical to regular
use with the exception of an X-Ignore header containing garbage
bytes. If the existence of the X-Ignore header is a concern, the re-
lay station can instead replace it with a common but mostly unused
header. However, a censor that monitors information leaving the
overt destination can compare ciphertexts to detect content replace-
ment.
In fact, no existing decoy routing system can completely
defend against an adversary that has a complete view of packets
entering and leaving both the client and the overt site. Our system
increases the work of the adversary from previous systems by re-
quiring the colluding parties to compare ciphertexts as opposed to
metadata.
4.4 Routing-Capable Attacks
Routing-capable attacks were introduced by Schuchard et al. [18]
and rely on the censor’s ability to route packets through either a
tainted path (i.e., one on which a Slitheen station resides between
the client and the overt destination), or a clean path (i.e., a path with
no Slitheen station between the client and the overt site). While a
censor may not always be able to ﬁnd a clean path to the overt desti-
nation, our system defends against an adversary that does have this
Table 1: Slitheen is the ﬁrst decoy routing system to defend against latency analysis and website ﬁngerprinting attacks. Our method provides
strong defenses against both active and passive attacks, at the cost of requiring symmetric ﬂows and in-line blocking. Although the latter
requirements have been previously thought to be barriers to deployment, we argue that increasingly popular trafﬁc shaping tools provide ISPs
with an easy way to block and redirect trafﬁc, opening avenues for easier deployments. The half-circle indicates that while Rebound stores a
queue of downstream data at the relay to decrease latency, it also increases the latency of their system by sending unusually high amounts of
upstream data.
Telex [26] Cirripede [12] Decoy Routing [14] TapDance [25] Rebound [7]
Slitheen
No inline blocking
Handles asymmetry
Resistant to replay attacks
Resistant to latency analysis
Website ﬁngerprinting defense
Protocol ﬁngerprinting defense
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:32)
(cid:72)(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
ability. We also note that, as in Telex, the location of relay stations
can be public knowledge, and therefore routing-capable attacks to
determine whether a network path contains a relay station (as op-
posed to whether a particular ﬂow is using a relay station) do not
affect the security of our system.
upstream bandwidth, the server will respond to such a request sent
down a clean path with an HTTP error messages, raising the sus-
picion of the censor. To defend against this attack, the client can
replace or compress only non-essential headers, taking a loss to
upstream bandwidth.
TCP Replay Attack. In a TCP replay attack, the censor attempts
to identify the use of decoy routing by testing whether the client
has a TCP connection with the overt site. The censor can replay
a TCP packet sent by the client on a clean path. In TapDance and
ﬁrst-generation decoy routing systems, the connection between the
client and the overt site has been severed or abandoned and the
overt site will issue a TCP RST packet or a stale TCP sequence
number, signaling to the censor the usage of decoy routing. Note
that in TapDance, the adversary does not need to ﬁnd a clean path,
but can inject a TCP packet into the stream. Since the TapDance
station does not perform in-line blocking, the packet will be for-
warded to the overt destination despite the fact that it traverses a
tainted path.
Our system maintains a TCP connection to the overt destination,
providing a defense against this type of replay attack. Every TCP
packet sent by the client is received by the overt site throughout
the duration of the decoy-routed connection. Upon the receipt of a
replayed packet, the server will send a duplicate acknowledgement
in an identical manner to a regular connection.
Crazy Ivan. The Crazy Ivan attack involves a censor with the abil-
ity to control the path a client’s packets take to their destination to
detect the usage of, or deny availability to, decoy routing. The cen-
sor allows a client to connect to the overt site through a tainted path,
and waits until the TLS session has been established to redirect the
ﬂow down a clean path.
In previous systems, this attack gives the censor overwhelm-
ing evidence of decoy routing. Systems such as Telex, Cirripede,
Curveball, and TapDance that sever or abandon the connection be-
tween the client and the overt destination will be unable to block
packets sent down the new clean path, resulting in TCP RST pack-
ets from the overt site. By keeping the connection between the
client and the overt site active, both Slitheen and Rebound offer a
defense against this type of detection attack. Packets sent down
a clean path will be received by the overt destination in the usual
manner, prompting the server to send the requested resource (in
Slitheen) or an HTTP error message with the invalid request (in
Rebound). The TCP sequence and acknowledgement numbers will
match those that the censor expects. The censor, unable to de-
crypt these packets, will see no difference in the trafﬁc. However,
if the client is compressing HTTP GET requests to provide more
Forced Clean Paths. An adversary with the ability to chose be-
tween clean and tainted paths may route around a Slitheen station
altogether. This would prevent the client from ever coming into
contact with a participating ISP. Although the consequences of this
attack would result in a complete loss of availability to the decoy
system, Houmansadr et al. [13] show that this attack is too expen-
sive for realistic censors, and very unlikely. We also note that this
attack is only a denial of service, and will not leak information
about whether the client is using or has used Slitheen.
4.5 Comparison to Existing Systems
A large advantage of Slitheen over existing systems is its resis-
tance to latency analysis and website ﬁngerprinting attacks. We not
only eliminate the ability to use latencies to ﬁngerprint the censored
webpage accessed through a decoy routing session, but also mini-
mize the latencies caused by the station itself. We give an overview
of the comparison between Slitheen and previous systems in Ta-
ble 1.
While Rebound also takes steps to minimize latency by stor-
ing a queue of downstream data from the covert destination, the
use of their system is trivial to detect by a minimally capable pas-
sive adversary. Rebound trafﬁc differs radically from typical web-
browsing trafﬁc in both the amount of upstream data sent by the
client to provide space for inserted downstream data, and also the
amount of HTTP error messages. Slitheen relays information to
and from the covert destination in a way that does not deviate at all
from a typical access to the speciﬁc overt site in use, providing a
much more secure defense against passive attacks.
Our system defends against active attacks as well as, or better,
than all existing decoy routing systems. Rebound is the only other
system that actively maintains the connection between the client
and the overt site, defending against the routing-capable attacks
meant to unveil the true TCP state between the client and the overt
site. Rebound, of course, requires the client to send upstream data
in an equal amount to the downstream data she wishes to receive
in order to maintain a consistent TCP state. In addition to being
unusual web-browsing behaviour, this approach is also extremely
inefﬁcient. ISPs often offer clients much lower bandwidth for up-
stream than downstream data.
Although Slitheen does not allow asymmetric ﬂows, and con-
tinues to require in-line blocking of downstream data, we argue
that these requirements are growing less prohibitive towards the
deployment of decoy routing stations as the popularity of special-
ized trafﬁc shaping tools increases. Companies such as Sandvine2
have developed highly efﬁcient DPI boxes that would allow a par-
ticipating ISP to detect tagged ﬂows and easily redirect them to a
Slitheen relay. They also provide service providers with the abil-
ity to force ﬂow symmetry or share a ﬂow’s state between multiple
DPI boxes [17], as long as the trafﬁc in both directions crosses their
area of inﬂuence. We note that this is very likely if the stations are
deployed in close proximity to the overt sites. Furthermore, the
modiﬁcations to the Telex tagging procedure to detect man-in-the-
middle attacks described in Section 4.3 also serves to detect route
asymmetry. In the case of an asymmetric route, the TLS Finished
message hash to the client will not contain the additional tag-seeded
input, allowing the client to terminate the ﬂow or complete it with-
out leaking their usage of the system.
5.
IMPLEMENTATION
We developed a proof-of-concept implementation of our system
and tested the relay station and client on desktop machines running
Ubuntu 14.04. This implementation serves to demonstrate that our
design behaves as expected, and provides a basis for our evaluations
in the following section. Our code is available online for reuse and
analysis.3
5.1 Client
Our implementation of the client consists of two distinct parts:
the overt user simulator (OUS) that repeatedly connects to overt
sites, and a SOCKS proxy frontend that relays SOCKS connec-
tion requests and data between the client’s browser and the OUS.
The OUS takes data from the SOCKS frontend and inserts it into
X-Slitheen headers of outgoing HTTP requests. It then takes down-
stream data from the received resources of content type “slitheen”
and returns this to the SOCKS frontend, which then sends this data
to the browser. To allow the browser to send multiple simultaneous
requests, we assign a stream ID to each connection. When the relay
station receives downstream data for a particular stream, it includes
the stream ID along with the data in the replaced resource, allowing
the SOCKS frontend at the client side to demultiplex streams from
the data received from the OUS.
For the tagging procedure, we modiﬁed OpenSSL4 to allow the
client to specify the value of the random nonce in the ClientHello
message, as well as supply a given value for the client DH param-
eter. Although there are many algorithms available to negotiate a
TLS master secret, our proof-of-concept implementation only al-
lows the use of the DH key exchange methods (including the pop-
ular ECDHE). Other methods could easily be added to our system
to expand the range of overt sites used by the client. Our modiﬁ-
cations to OpenSSL take the form of user-deﬁned callbacks, mini-
mizing both the lines of code we had to alter in the source, as well
as reducing any unintended consequences from our modiﬁcations.
To send an untagged ﬂow, the client can simply refrain from setting
the provided callbacks, resulting in OpenSSL’s default behaviour.
Our modiﬁcations consisted of additions only, introducing 46 lines
of code to OpenSSL. The callback functions and helper code for
generating the Telex-style tags are about 2200 lines of C code.
2https://www.sandvine.com/
3The code is currently available at https://crysp.uwaterloo.ca/
software/slitheen.
4http://openssl.org/
We used the PhantomJS headless browser5 as the basis for our
OUS, although more common browsers such as Firefox6 or Chrome7
could be adapted for use as an OUS as well. To tag the TLS sessions
established by the OUS, we made a few modiﬁcations to the Phan-
tomJS source code to add options that set the OpenSSL ClientHello
and ClientKeyExchange callbacks to the previously described func-
tions. Our modiﬁcations consisted only of additions and introduced
43 lines of C++ code to PhantomJS and 56 lines of code to its ver-
sion of Qtbase. We wrote a PhantomJS script consisting of 55 lines
of Javascript to read data from the SOCKS frontend and add it to
outgoing request headers. When the script receives a resource, it
sends the contents of all resources of content type “slitheen” to the
SOCKS frontend through a WebSocket [8].
The SOCKS frontend receives connection requests and data from
the browser and writes it to a named pipe for the OUS to process.
It assigns each new connection a stream ID and sends that along
with the data to the OUS to send to the relay station. The SOCKS
frontend reads downstream data from the OUS and ﬁrst demulti-
plexes it by stream ID before sending it to the browser. We wrote
the SOCKS frontend in approximately 500 lines of C code.
5.2 Slitheen Relay Station
We implemented the Slitheen station in approximately 3200 lines
of C code. The station is responsible for recognizing and pro-
cessing tagged TLS handshakes, proxying data to censored sites,
and monitoring and replacing upstream and downstream applica-
tion data to overt sites. When the station detects a tagged ﬂow, it
saves the source and destination addresses and ports in a ﬂow ta-
ble, to later identify packets in the same decoy routing session. The
station continues to passively observe the remainder of the TLS
handshake and then uses the tag-derived client secret and observed
server handshake messages to compute the TLS master secret for
the session, saving it in the ﬂow table.
After verifying the TLS Finished message from both sides of the
connection, the Slitheen station begins to monitor HTTP GET re-
quests from the client for upstream data, and stores any downstream
response from the blocked server in a censored content queue. Once
the station receives the client’s Slitheen ID, it saves this informa-
tion in the ﬂow table in order to later identify the stream IDs that
can replace downstream resources. As Slitheen reuses the TCP/IP
headers from the overt site, we have no need to modify kernel code
to set up a forged TCP state (as Telex requires). Application data is
simply swapped into TCP segments as they are read from the inter-