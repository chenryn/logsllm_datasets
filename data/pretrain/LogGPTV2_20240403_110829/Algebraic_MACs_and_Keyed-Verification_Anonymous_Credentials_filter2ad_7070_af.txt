and return (σw, σx, σy, σz)
x ; σz ← BzC−t
1 (k) or GA
0 (k) respectively.
Procedure Verifysk ( (cid:126)m, σ)
return ((σyσs
x)z = (σxσt
w)Hy( (cid:126)m)) ∧ (σw (cid:54)= 1)
First, note that (p, G, g, h), iparams is distributed exactly as in HA
i,1(k). To see that B
successfully simulates the Mac oracle in both cases, observe that if we implicitly use r = b then, if
C = gab, we have
i−1(k) and HA
σw = gab = hb = hr
σx = gbHx( (cid:126)m)gabHv( (cid:126)m) = (gHx( (cid:126)m)hHv( (cid:126)m))r
σy = gbHy( (cid:126)m)σ−s
σz = gbzg−abt = (gzh−t)r,
x = grHy( (cid:126)m)σ−s
x
20
which are distributed identically to the values in HA
we can write it as C = hω for some ω $←− Fp. In this case
i−1(k). If instead C is random, then in particular
σw = hω
σx = grHx( (cid:126)m)hωHv( (cid:126)m)
σy = grHy( (cid:126)m)σ−s
σz = gzrh−ωt,
which are distributed identically to the values in HA
x
i,1(k).
i,2(k)) or griHx( (cid:126)mi)hωHv( (cid:126)mi) (in HA
$←− Fp. The i-th query then uses either griHx( (cid:126)mi)hχi (in HA
To prove Equation 4.2, we remind ourselves of the transition: in both games, the ﬁrst i− 1 queries
$←− Fp and the last qm − i queries are answered using (gHx( (cid:126)mj )hHv( (cid:126)mj ))rj
are answered using hχj for χj
for rj
i,1(k));
if we can argue that the value of Hv( (cid:126)mi) is independent of any other values in the game, then in
particular Hv( (cid:126)mi) could take on any value and the distribution over these two values is identical.
To do this, we ﬁrst observe that SimVerify, and thus Verify, is independent of (cid:126)v. The ﬁrst i − 1
Mac responses are also independent of (cid:126)v, so we must prove only two properties: (1) the value of
(gHx( (cid:126)mj )hHv( (cid:126)mj ))rj in the last qm − i Mac responses is independent of (cid:126)v, and (2) the value of Hv( (cid:126)mi)
is independent of the value of Hv( (cid:126)m∗), and thus changing the i-th query does not aﬀect the distribution
at the end of the game.
To ﬁrst prove this latter property, we observe that Hv(·) is a pairwise independent function. As
the winning conditions of the game require that m∗ /∈ Q and thus (cid:126)mi (cid:54)= (cid:126)m∗, this means that for any
α1, α2 ∈ Fp, Pr[Hv( (cid:126)mi) = α1 ∧ Hv( (cid:126)m∗) = α2] = 1/p2, which in turn implies that the values of Hv( (cid:126)mi)
and Hv( (cid:126)m∗) are independent as desired.
consider a modiﬁed game in which xi = x(cid:48)
To prove the former property, we perform a similar argument to that in the proof of Equation 3:
i − βvi; then for the last qm − i queries,
σx = (g(Hx( (cid:126)mj )hHv( (cid:126)mj ))rj = grj (Hx( (cid:126)mj )+βHv( (cid:126)mj ))) = grj (Hx(cid:48) ( (cid:126)mj )−βHv( (cid:126)mj )+βHv( (cid:126)mj )) = grj Hx(cid:48) ( (cid:126)mj ),
so these values information-theoretically hide (cid:126)v. For the i-th query, however, we have
σx = griHx( (cid:126)mi)hωiHv( (cid:126)mi) = gri(Hx(cid:48) ( (cid:126)mi)−βHv( (cid:126)mi))gβωiHv( (cid:126)mi) = griHx(cid:48) ( (cid:126)mi)h(ωi−ri)Hv( (cid:126)mi),
which, given that as we have argued Hv( (cid:126)mi) is independent of all other values, will be distributed
identically to griHx(cid:48) ( (cid:126)mi)hχ = griHx( (cid:126)mi)hriHv( (cid:126)mi)+χ for χ ← Fp. Thus, this is identical to the value in
HA
i,2(k).
To prove Equation 4.3, we consider a modiﬁed version of HA
i (k) in which, rather than pick χ $←− Fp,
we pick χ(cid:48) $←− Fp and set χ := rHx( (cid:126)m)/β + rHv( (cid:126)m) + χ(cid:48). Then the distribution over χ is still uniformly
random and thus identical to the distribution in HA
i (k), and
hχ = hrHx( (cid:126)m)/β+rHv( (cid:126)m)+χ(cid:48)
= gβ(rHx( (cid:126)m)/β+rHv( (cid:126)m)+χ(cid:48))
= grHx( (cid:126)m)hrHv( (cid:126)m)+χ(cid:48)
,
so the distribution over σx in the modiﬁed game is identical to that in HA
Equation 5.
Finally, we prove Equation 5. If A outputs a forgery ( (cid:126)m∗, σ∗) such that b = 1, then (σ
σx)Hy( (cid:126)m∗)
xσy)Hx( (cid:126)m∗) by deﬁnition. Since x0 and v0 are not used in any values given to A and thus Hx( (cid:126)m∗)
= (σs
and Hv( (cid:126)m∗) are information-theoretically hidden, however, A has a negligible probability of producing
( (cid:126)m∗, σ∗) such that this equality holds and σw (cid:54)= 1, meaning the probability that it wins the game is
bounded by ν(k) = 2−k.
−Hv( (cid:126)m∗)
w
i,2(k).
21
B Formal Security Deﬁnitions for Keyed-Veriﬁcation Credentials
In this section we formally deﬁne the security properties of keyed-veriﬁcation credential schemes,
introduced in Section 4.
To simplify the deﬁnition somewhat, we ﬁrst consider the setting where the issuer sees all of the
user’s attributes when it issues the credential, and deﬁne correctness, unforgeability, and anonymity
in this setting. Then we require the existence of a blind issuing protocol, which is a secure two party
computation allowing the user to obtain credentials identical to those generated by Issue, while keeping
a subset of his attributes private.
We also include two algorithms which are used to deﬁne security for the system:
Issue(sk , (m1, . . . , mn)) uses the secret key to generate a credential for attributes (m1, . . . , mn). This
can be run directly, if the issuer is trusted to behave honestly and knows all the user’s attributes,
otherwise BlindIssue and BlindObtain should be used, as these allow the user to guarantee that
the credential received is valid, and to hide some of his attributes.
CredVerify(sk , (m1, . . . , mn), cred ) uses the secret key to verify a credential. This is never run (because
it reveals the attributes (m1, . . . , mn) as well as cred which may compromise the user’s privacy),
but is used to deﬁne the set of valid credentials for attributes (m1, . . . , mn) under the sk .
For security, we require the following ﬁve properties to hold.
Deﬁnition 5 (Correctness). Let Φ be the set of statements supported by a credential system, and U be
the universe of attribute sets. Then a keyed-veriﬁcation credential system (CredKeygen, Issue, CredVerify,
Show, ShowVerify) is correct for Φ,U if for all (m1, . . . , mn) ∈ U, for all suﬃciently large k,
Pr(cid:2)params $←− Setup(1k); (sk , iparams) $←− CredKeygen(params);
cred $←− Issue(sk , (m1, . . . , mn)) : CredVerify(sk , (m1, . . . , mn), cred ) = 0(cid:3) = 0
and for all φ ∈ Φ, (m1, . . . , mn) ∈ U such that φ(m1, . . . , mn) = 1, for all suﬃciently large k,
Pr(cid:2)params $←− Setup(1k); (sk , iparams) $←− CredKeygen(params); cred $←− Issue(sk , (m1, . . . , mn));
Show(iparams, cred , (m1, . . . , mn), φ) ↔ ShowVerify(sk , φ) → b : b = 0(cid:3) = 0
The unforgeability property ensures an adversary cannot produce an accepting proof for a state-
ment φ unless at least one of the attribute sets that he requested a credential for satisﬁes φ.
Deﬁnition 6 (Unforgeability). A presentation protocol Show, ShowVerify for keyed-veriﬁcation cre-
dentials scheme deﬁned by CredKeygen, Issue is unforgeable if for all PPT adversaries A, there exists
a negligible function ν such that for all k,
Pr(cid:2)params $←− Setup(1k);
(iparams, sk ) $←− CredKeygen(params);
(state, φ) $←− A(params, iparams)Issue(sk ,·),ShowVerify(sk ,·)
A(state) ↔ ShowVerify(sk , φ) → b
such that b = 1 ∧ (∀(m1, . . . , mn) ∈ Q, φ(m1, . . . , mn) = 0)(cid:3) = ν(k)
where Q is the list of all attribute sets (m1, . . . , mn) queried to the Issue(sk ,·) oracle, and all executions
of ShowVerify are required to be sequential.2
2Note that in the case that Show is non-interactive (as is the case with our construction when we instantiate the proof
systems using the Fiat-Shamir heuristic), all interactions are automatically sequential.
22
Deﬁnition 7 (Anonymity). A presentation protocol Show, ShowVerify for keyed-veriﬁcation credentials
scheme CredKeygen, Issue is anonymous if for all PPT adversaries A, there exists an eﬃcient algorithm
SimShow, and a negligible function ν such that for all k, for all φ ∈ Φ and (m1, . . . , mn) ∈ U such that
φ(m1, . . . , mn) = 1, and for all params $←− Setup(1k) and all (iparams, sk ) $←− KeyGen(params), for all
cred such that CredVerify(sk , (m1, . . . , mn), cred ) = 1:
{Show(iparams, cred , (m1, . . . , mn), φ) ↔ A → state} ≈ {SimShow(iparams, sk , φ)},
i.e., the adversary’s view given the proof can be simulated by SimShow given only φ and a valid secret
key corresponding to iparams.
Note that the statement φ is known to A and may contain information about the attribute values,
which may identify the user. Deﬁnition 7 ensures that the keyed-veriﬁcation credential scheme’s
protocols are anonymous, modulo information revealed in φ.
Deﬁnition 8 (Blind issuance). Here we consider a setting where the user wishes to obtain cre-
dentials for attributes (m1, . . . , mn), and the issuer knows only some subset S of those attributes.
Then we consider the following function: f ((S, params, iparams), (sk , r), (m1, . . . , mn)) on shared in-
put (S, params, iparams), issuer input (sk , r), and user input (m1, . . . , mn), returns ⊥ to the issuer
and returns to the user “params error” if (iparams, sk ) are not in the range of CredKeygen(params),
“attribute error” if S does not agree with (m1, . . . , mn),and cred $←− Issue(sk , (m1, . . . , mn); r) if neither
of these errors occurs.3
We say that an issuance protocol BlindIssue, BlindObtain is a blind issuance protocol for Issue if
it is a secure two-party computation (against malicious adversaries) for the above function. See [21,
Chapter 7] for a deﬁnition of secure two-party computation.
Deﬁnition 9 (Key-parameter consistency). The key generation algorithm CredKeygen satisﬁes key-
parameter consistency if for any PPT adversary A, the probability that A given params $←− Setup(1k)
can produce (iparams, sk 1, sk 2) such that (iparams, sk 1) and (iparams, sk 2) are both in the range of
CredKeygen(params) is negligible (where the probability is over the choice of params and the random
coins of A).
Note that correctness, blind issuance, and key-parameter consistency guarantee that if the user
receives a credential through BlindObtain, then the resulting credential will be accepted by CredVerify
for the one secret key that the issuer knows corresponding to iparams. Then anonymity guarantees
that Show will not allow the issuer to learn any information beyond φ.
Deﬁnition 10 (Secure keyed-veriﬁcation credential system). We say that (CredKeygen, CredVerify, Issue,
BlindIssue, BlindObtain, Show, ShowVerify) is a secure keyed-veriﬁcation credential system if these algo-
rithms satisfy correctness, unforgeability, anonymity, blind issuance, and key-parameter consistency
as deﬁned above.
C A Proof of Theorem 4
We present the following algorithms, which we use to specify the form of valid credentials when we
prove security of the scheme.
Issue(sk , (m1, . . . , mn)): Output cred $←− MACDDH(sk , (m1, . . . , mn), ).
3Here Issue(sk , (m1, . . . , mn); r) means running Issue(sk , (m1, . . . , mn)) with randomness r.
23
CredVerify(sk , (m1, . . . , mn), cred ): Output the result of VerifyDDH(sk , (m1, . . . , mn), cred ).
Proof. We show that these algorithms satisfy correctness, unforgeability, anonymity, and blind is-
suance.
Correctness. For correctness we need to show two properties. The ﬁrst follows directly from cor-
rectness of the MAC. To see the second, consider the following:
Issue(sk , (m1, . . . , mn)) generates credentials of the form (u, ux0+(cid:80)n
1 yimi, uz). Then if
both Show and ShowVerify are executed honestly, then the proof π is accepted by completeness of the
proof system. Also, the honest Show computes:
1 ximi, uy0+(cid:80)n
Vx =
1 Cmi
xi
=
σw
σw
Cσx
x0(cid:81)n
x0(cid:81)n
x0(cid:81)n
ux0(cid:81)n
grxux0+(cid:80)n
n(cid:89)
= g−rx
σw
=
=
X wi
i
mixihxiwi
1 σw
σxgrx
1 σw
σxgrx
mixi
1 umixi
1 ximi
n(cid:89)
n(cid:89)
i=1
i=1
X wi
i
X wi
i
so the veriﬁer’s check on Vx succeeds. A similar equality holds for Vy. Finally, since Issue produces
σz = uz, the veriﬁer’s ﬁnal check succeeds and the veriﬁer will accept.
i=1
Unforgeability. Here we prove unforgeability when A is given credentials generated by Issue. Blind
issuance then shows that this also holds with the blind issuance protocol. We have shown (Theorem 3)
that MACDDH is unforgeable under DDH. Suppose there exists an adversary A who can break the
unforgeability property of our credential system. Then we can construct an algorithm B that breaks
unforgeability of MACDDH as follows:
$←− Fp.
It then sends params,
B receives params, iparams DDH and chooses random Cx0, Cy0, Cz
iparams = (iparams DDH, Cx0, Cy0, Cz) to A.
When A queries the Issue oracle, B forwards the query to its MAC oracle and returns the resulting
tag.
When A queries the ShowVerify oracle: A sends σw, σz, Cm1, . . . Cmn, Vx, Vy, Cσx, Cσy , and gives a
proof π. If the proof π is invalid, B returns ⊥. Otherwise B runs the proof of knowledge extractor
to extract {mi}n
1 , rx, ry.4 Then it computes σx = Cσxg−rx and σy = Cσy g−ry . Finally, it queries its
Verify oracle with (m1, . . . mn), (σw, σx, σy, σz), and outputs the result.
1 , rx, ry and outputs (m1, . . . mn), (σw, Cσxg−rx,
Cσy g−ry , σz) as its forgery.
In the ﬁnal show protocol, B again extracts {mi}n
First, note that B ’s response to Issue queries are identical to the honest Issue algorithm. Then, we
argue that its response to ShowVerify queries are also with overwhelming probability identical to the
output of the honest algorithm. To see this, note that the proof of knowledge property guarantees that
4Note that this requires the special proof of knowledge property, so that B can extract (cid:126)m, σ, and use it to obtain the
veriﬁcation response to give to A.
24
the extractor succeeds in producing a valid witness with all but negligible probability. Furthermore,
if the extractor gives valid {mi}n
1 , rx, ry then
x0(cid:81)n
1 Cmi
Cσx
σw
Xi
wi =
Vx =