dence supported by QuackyDucky. They also provide tooling,
like QuackyDucky, to automatically extract message format
descriptions from RFCs and have applied their work to net-
work message formats like IMAP, the popular mail protocol.
While the input language of their framework is signiﬁcantly
more expressive than ours, EverParse, in contrast, produces
provably safe, secure and functionally correct parsers. Jim
and Mandelbaum also do not address message formatting.
8 Limitations and Future Work
Trusted computing base: we statically guarantee at the F(cid:63)
source level memory safety, functional correctness, and non-
malleability for all code generated by QuackyDucky. Pre-
serving non-malleability down to machine code requires only
preserving functional correctness, since non-malleability is
a speciﬁcation-level guarantee. All our veriﬁcation results,
including preservation of memory safety and functional cor-
rectness down to machine code, relies on a trusted computing
base (TCB) that includes:
• the F(cid:63) proof assistant and the Z3 theorem prover, al-
though work by Swamy et al. [48] provides a model of a
subset of F(cid:63) and proves its soundness;
• the KReMLin compiler from Low(cid:63) to C, although work
by Protzenko et al. [38] provides a model of a sub-
set of Low(cid:63), its compilation to CompCert Clight, and
proofs (on paper) that compilation to C preserves mem-
ory safety and functional correctness;
• the C compiler, although one can use the CompCert [28]
veriﬁed C compiler, which ensures the preservation of
memory safety and functional correctness, at the expense
of some performance.
This trusted base is comparable to Coq-based veriﬁed imple-
mentations, which trust Coq, the Coq extraction to OCaml,
and the OCaml compiler and runtime. Ongoing research aims
to reduce this TCB by verifying Coq extraction; similar efforts
could, in principle, be applied to F(cid:63) and KReMLin.
Conversely, neither LowParse nor QuackyDucky are in the
TCB. LowParse is fully veriﬁed. The input format speciﬁ-
cation of QuackyDucky is trusted for liveness, but not for
security: if there is a mistake in the format speciﬁcation, the
worse that can happen is that the generated messages are in-
compatible with implementations of the correct format. We
rely on interoperability testing to detect such mistakes. Con-
versely, EverParse can be used during the standardization of
a new message format, as it can prove that the speciﬁcation is
secure regardless of the generated implementation.
Expressiveness QuackyDucky currently focuses on sup-
porting tag-length-value encodings of non-malleable data
formats. We show that the message formats of several im-
portant protocols and standards, including TLS, PKCS #1
signature payloads and Bitcoin, fall into this class. LowParse,
1480    28th USENIX Security Symposium
USENIX Association
being the target language of QuackyDucky’s translation, is
also currently restricted to supporting non-malleable data
formats. However, it would be straightforward to make non-
malleability conditional on a ﬂag set in the parser metadata
in order to deﬁne combinators for zero-copy malleable for-
mats, including MessagePack, CBOR, Apache Arrow, Cap’n
proto, and Protocol Buffers which are malleable at least by de-
fault (some have canonical representation rules). Generalized
to support malleable formats, LowParse, being a library of
veriﬁed monadic parser combinators, would support parsing
with arbitrary data dependence and lookahead, beyond the
class of context-free languages—however, coming up with
efﬁcient veriﬁed implementations of parsers for such language
classes is an open question. In the future, we will also consider
generalizing QuackyDucky to target the class of languages
supported by LowParse.
Side-channel attacks: the implementation produced by
EverParse branches on values read from the input buffer,
which may leak (through timing side-channels) information
when used on conﬁdential data. We may in principle verify
properties such as constant-time execution for the process-
ing of simple message formats, reusing F(cid:63) and KReMLin
techniques and libraries for side-channel protection of crypto-
graphic algorithms. For example, we may provide constant-
time combinators for ﬁxed-length secret bytestrings. We leave
such extensions for future work.
Fuzzing: since we expect our extracted C code to be com-
piled by unveriﬁed toolchains (such as GCC and LLVM, with
optimizations), fuzz testing can provide additional assurance
that the compilation from F(cid:63) to binary does not break our
veriﬁed safety properties. We started using fuzzers optimized
for parsers, such as SAGE [19], to fuzz the generated bitcoin
block validator; we plan to extend their use to fuzz application
code that uses generated validators and accessors.
Integration: we have integrated the high-level implemen-
tation of EverParse TLS parsers into MITLS, but our goal
is to transition to the low-level implementation, thus avoid-
ing many unnecessary heap allocations and copies. This is a
major step towards making MITLS practical in performance-
sensitive deployments.
9 Conclusion
Developers should prefer the convenience and robustness of
writing high-level format speciﬁcations compiled by parser
generation tools to programming tedious and error-prone cus-
tom parsers, although the latter is sometimes required for
performance reasons. EverParse offers a unique combination
of high performance, zero-copy implementations and high-
assurance formal veriﬁcation of the generated parsers.
Acknowledgments We thank the anonymous reviewers and
Prateek Saxena for their helpful comments, which improved
the writing of this paper. We thank Barry Bond, Christoph
Wintersteiger and the Everest team for their help in test-
ing EverParse. We thank Clément Pit-Claudel and Benjamin
Delaware for insightful discussions on the goals of veriﬁed
parsing. Tej Chajed and Nadim Kobeissi completed their work
during internships at Microsoft Research.
References
[1] The Coq proof assistant. http://coq.inria.fr, 1984–2019.
[2] A. Barenghi, N. Mainardi, and G. Pelosi. Systematic parsing
of X.509: eradicating security issues with a parse tree. CoRR,
abs/1812.04959, 2018.
[3] A. Barthwal and M. Norrish. Veriﬁed, executable parsing.
In European Symposium on Programming, pages 160–174.
Springer, 2009.
[4] D. Benjamin. Applying GREASE to TLS extensibility. IETF
Draft, 2016.
[5] B. Beurdouche, A. Delignat-Lavaud, N. Kobeissi, A. Pironti,
and K. Bhargavan. FLEXTLS: A tool for testing TLS imple-
mentations. In Usenix Workshop on Offensive Technologies
(WOOT15), 2015.
[6] K. Bhargavan, B. Bond, A. Delignat-Lavaud, C. Fournet,
C. Hawblitzel, C. Hritcu, S. Ishtiaq, M. Kohlweiss, R. Leino,
J. R. Lorch, K. Maillard, J. Pan, B. Parno, J. Protzenko, T. Ra-
mananandro, A. Rane, A. Rastogi, N. Swamy, L. Thompson,
P. Wang, S. Z. Béguelin, and J. K. Zinzindohoue. Everest: To-
wards a veriﬁed, drop-in replacement of HTTPS. In 2nd Sum-
mit on Advances in Programming Languages, SNAPL 2017,
May 7-10, 2017, Asilomar, CA, USA, pages 1:1–1:12, 2017.
https://project-everest.github.io.
[7] K. Bhargavan, C. Fournet, and M. Kohlweiss. miTLS: Ver-
ifying protocol implementations against real-world attacks.
IEEE Security & Privacy, 14(6):18–25, Nov 2016. https:
//github.com/project-everest/mitls-fstar.
[8] D. Bleichenbacher, T. Duong, E. Kasper, and Q. Nguyen.
Project Wycheproof: Scaling crypto testing. In Real World
Crypto Symposium, New York, USA, 2017.
[9] S. Y. Chau. The OID parser in the ASN.1 code in GMP allows
any number of random bytes after a valid OID. Available from
MITRE CVE-2018-16151, 2018.
[10] P. Cousot and R. Cousot. Grammar Analysis and Parsing
by Abstract Interpretation, pages 175–200. Springer Berlin
Heidelberg, Berlin, Heidelberg, 2007.
[11] P. Cuoq, F. Kirchner, N. Kosmatov, V. Prevosto, J. Signoles,
and B. Yakobowski. Frama-C. In International Conference
on Software Engineering and Formal Methods, pages 233–247.
Springer, 2012.
[12] C. Decker and R. Wattenhofer. Bitcoin transaction malleability
and MtGox. In European Symposium on Research in Computer
Security, pages 313–326. Springer, 2014.
[13] A. Delignat-Lavaud. RSA signature forgery attack in NSS due
to incorrect parsing of ASN.1 encoded DigestInfo. MITRE
CVE-2014-1569, 2014.
[14] T. Dierks and C. Allen. The TLS 1.0 protocol. IETF RFC
2246, 1999.
[15] T. Dierks and E. Rescorla. The transport layer security (TLS)
protocol version 1.2. IETF RFC 5246, 2008.
USENIX Association
28th USENIX Security Symposium    1481
[16] K.-G. Doh, H. Kim, and D. A. Schmidt. Abstract LR-Parsing,
pages 90–109. Springer Berlin Heidelberg, Berlin, Heidelberg,
2011.
[17] Z. Durumeric, F. Li, J. Kasten, J. Amann, et al. The Matter of
Heartbleed. In Proceedings of the 2014 Internet Measurement
Conference, pages 475–488. ACM, 2014.
[18] H. Finney. Bleichenbacher’s RSA signature forgery based on
implementation error, 2006.
[19] P. Godefroid, M. Y. Levin, and D. Molnar. SAGE: whitebox
fuzzing for security testing. Queue, 10(1):20, 2012.
[20] Google. Protocol buffers. github.com/protocolbuffers.
[21] R. D. Graham and P. C. Johnson. Finite state machine parsing
for internet protocols: Faster than you think. In Security and
Privacy Workshops (SPW), 2014 IEEE, pages 185–190. IEEE,
2014.
[22] G. Hutton. Higher-order functions for parsing. Journal of
functional programming, 2(3):323–343, 1992.
[23] T. Jim and Y. Mandelbaum. Efﬁcient earley parsing with
regular right-hand sides. Electr. Notes Theor. Comput. Sci.,
253(7):135–148, 2010.
[24] T. Jim and Y. Mandelbaum. A new method for dependent pars-
ing. In Programming Languages and Systems - 20th European
Symposium on Programming (ESOP), pages 378–397, 2011.
[25] J.-H. Jourdan, F. Pottier, and X. Leroy. Validating LR(1)
In Proceedings of the 21st European Conference
parsers.
on Programming Languages and Systems, ESOP’12, pages
397–416, Berlin, Heidelberg, 2012. Springer-Verlag.
[26] A. Koprowski and H. Binsztok. TRX: A formally veriﬁed
parser interpreter. In European Symposium on Programming,
pages 345–365. Springer, 2010.
[27] D. Leijen and E. Meijer. Parsec: Direct style monadic parser
combinators for the real world. 2001.
[28] X. Leroy. Formal certiﬁcation of a compiler back-end, or:
programming a compiler with a proof assistant. In 33rd ACM
symposium on Principles of Programming Languages, pages
42–54. ACM Press, 2006.
[29] O. Levillain. Parsifal: A pragmatic solution to the binary pars-
ing problems. In 2014 IEEE Security and Privacy Workshops,
pages 191–197, May 2014.
[30] A. Madhavapeddy and D. J. Scott. Unikernels: the rise of the
virtual library operating system. Communications of the ACM,
57(1):61–69, 2014.
[31] G. Martínez, D. Ahman, V. Dumitrescu, N. Gian-
narakis, C. Hawblitzel, C. Hritcu, M. Narasimhamurthy,
Z. Paraskevopoulou, C. Pit-Claudel, J. Protzenko, T. Ra-
mananandro, A. Rastogi, and N. Swamy. Meta-F*: Proof
In 28th
automation with SMT, tactics, and metaprograms.
European Symposium on Programming, 2019.
[32] N. Mavrogiannopoulos, F. Vercauteren, V. Velichkov, and
B. Preneel. A cross-protocol attack on the TLS protocol. In
Proceedings of the ACM Conference on Computer and Com-
munications Security, pages 62–72, 10 2012.
[33] MongoDB. BSON. http://bsonspec.org/.
[34] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system.
2008.
[35] N. Nethercote and J. Seward. Valgrind: a framework for heavy-
weight dynamic binary instrumentation. In ACM Sigplan no-
tices, volume 42, pages 89–100. ACM, 2007.
[36] G. Neufeld and S. Vuong. An overview of ASN.1. Computer
Networks and ISDN Systems, 23(5):393–415, 1992.
[37] Y. Oiwa, K. Kobara, and H. Watanabe. A new variant for
an attack against RSA signature veriﬁcation using parameter
ﬁeld. In J. Lopez, P. Samarati, and J. L. Ferrer, editors, Public
Key Infrastructure, pages 143–153, Berlin, Heidelberg, 2007.
Springer Berlin Heidelberg.
[38] J. Protzenko, J.-K. Zinzindohoué, A. Rastogi, T. Ramananan-
dro, P. Wang, S. Zanella-Béguelin, A. Delignat-Lavaud,
C. Hri¸tcu, K. Bhargavan, C. Fournet, and N. Swamy. Ver-
iﬁed low-level programming embedded in F*. PACMPL,
1(ICFP):17:1–17:29, Sept. 2017.
[39] A. Razaghpanah, A. Akhavan Niaki, N. Vallina-Rodriguez,
S. Sundaresan, J. Amann, and P. Gill. Tls handshake data col-
lected by Lumen, Sept. 2017. https://haystack.mobi/datasets.
[40] E. Rescorla. The transport layer security (TLS) protocol ver-
sion 1.3. IETF RFC 8446, 2018.
[41] J. Salowey, H. Zhou, P. Eronen, and H. Tschofenig. Transport
layer security (TLS) session resumption without server-side
state. IETF RFC 5077, 2008.
[42] N. Schirmer. Veriﬁcation of sequential imperative programs in
Isabelle/HOL. PhD thesis, Technische Universität München,
2006.
[43] K. Serebryany. OSS-Fuzz: Google’s continuous fuzzing ser-
vice for open source software. 2017.
[44] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov.
In Usenix
Addresssanitizer: A fast address sanity checker.
Annual Technical Conference (ATC12), pages 309–318, 2012.
[45] J. Somorovsky. Systematic fuzzing and testing of TLS libraries.
In Proceedings of the 2016 ACM SIGSAC Conference on Com-
puter and Communications Security, pages 1492–1504. ACM,
2016.
[46] R. Srinivasan. XDR: External data representation. IETF RFC
1832, 1995.
[47] S. Suriyakarn, B. Delaware, A. Chlipala, et al. Narcissus:
Deriving correct-by-construction decoders and encoders from
binary formats. arXiv preprint arXiv:1803.04870, 2018.
[48] N. Swamy, C. Hri¸tcu, C. Keller, A. Rastogi, A. Delignat-
Lavaud, S. Forest, K. Bhargavan, C. Fournet, P.-Y. Strub,
M. Kohlweiss, J.-K. Zinzindohoue, and S. Zanella-Béguelin.
Dependent types and multi-monadic effects in F*. In ACM
Symposium on Principles of Programming Languages, pages
256–270, 2016. https://www.fstar-lang.org.
[49] F. Valsorda. Bleichenbacher’06 signature forgery in Python-
RSA, 2016.
[50] P. Wuille et al. BIP62: Dealing with malleability, 2014.
[51] Q. Ye and B. Delaware. A veriﬁed protocol buffer compiler.
In Proceedings of the 8th ACM SIGPLAN International Con-
ference on Certiﬁed Programs and Proofs, CPP 2019, pages
222–233, 2019.
1482    28th USENIX Security Symposium
USENIX Association