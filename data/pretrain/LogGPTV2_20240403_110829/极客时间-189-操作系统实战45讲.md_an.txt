# 15 \| Linux初始化（下）：从_start到第一个进程你好，我是 LMOS。今天我们继续来研究 Linux 的初始化流程，为你讲解如何解压内核，然后讲解Linux 内核第一个 C 函数。最后，我们会用 Linux的第一个用户进程的建立来收尾。如果用你上手去玩一款新游戏做类比的话，那么上节课只是新手教程，而这节课就是更深入的实战了。后面你会看到很多熟悉的"面孔"，像是我们前面讲过的CPU 工作模式、MMU页表等等基础知识，这节课都会得到运用。解压后内核初始化下面，我们先从 setup.bin 文件的入口 \_start开始，了解启动信息结构，接着由 16 位 main 函数切换 CPU到保护模式，然后跳入 vmlinux.bin 文件中的 startup_32函数重新加载段描述符。如果是 64 位的系统，就要进入 startup_64 函数，切换到 CPU到长模式，最后调用 extract_kernel 函数解压 Linux 内核，并进入内核的startup_64 函数，由此 Linux内核开始运行。为何要从 \_start 开始通过上节课对 vmlinuz 文件结构的研究，我们已经搞清楚了其中的vmlinux.bin 是如何产生的，它是由 linux/arch/x86/boot/compressed目录下的一些目标文件，以及 piggy.S 包含的一个 vmlinux.bin.gz的压缩文件一起生成的。vmlinux.bin.gz 文件则是由编译的 Linux 内核所生成的 elf 格式的 vmlinux文件，去掉了文件的符号信息和重定位信息后，压缩得到的。CPU 是无法识别压缩文件中的指令直接运行的，必须先进行解压后，然后解析elf 格式的文件，把其中的指令段和数据段加载到指定的内存空间中，才能由 CPU执行。 这就需要用到前面的 setup.bin 文件了，\_start 正是 setup.bin文件的入口，在 head.S文件中定义，代码如下。    #linux/arch/x86/boot/head.S      .code16      .section ".bstext", "ax"      .global bootsect_start    bootsect_start:      ljmp  $BOOTSEG, $start2    start2:    #……    #这里的512字段bootsector对于硬盘启动是用不到的    #……      .globl  _start    _start:        .byte  0xeb    
# short (2-byte) jump        .byte  start_of_setup-1f #这指令是用.byte定义出来的，跳转start_of_setup-1f    #……    #这里是一个庞大的数据结构，没展示出来，与linux/arch/x86/include/uapi/asm/bootparam.h文件中的struct setup_header一一对应。这个数据结构定义了启动时所需的默认参数    #……    start_of_setup:      movw  %ds, %ax      movw  %ax, %es   #ds = es      cld               #主要指定si、di寄存器的自增方向，即si++ di++      movw  %ss, %dx      cmpw  %ax, %dx  