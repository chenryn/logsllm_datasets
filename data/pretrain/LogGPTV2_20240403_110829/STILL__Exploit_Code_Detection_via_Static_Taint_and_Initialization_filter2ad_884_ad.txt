### Detection Results

Our detection results are as follows. First, STILL did not raise any alarms on the HTTP requests to servers. Second, STILL raised warnings on 30 HTTP binary replies received by client-side web browsers. Since none of these contained malicious exploit code, all 30 were false positives, resulting in a false positive rate of 0.0079%. Table 1(b) shows the number of false positives classified by MIME types in the HTTP headers of the input. 

Although there were 30 false positives, most can be easily excluded through further manual or automatic analysis. For example, nine of the files were indeed Win32 executables in PE (Portable Executable) format. As STILL's purpose is to detect whether a request contains code (malicious or otherwise) rather than to discern between malicious and legitimate code, we can let end users decide whether to block these executables. Additionally, some Type 2 warnings were clearly false positives because the `eax` register was set to a number much larger than 256, which is not a valid system call number in Linux or Windows. Finally, we can reduce false positives by checking the context. For instance, if we trust that there are no vulnerabilities in a Shockwave Player (based on other reliable tools), we can ignore the two false positives where the MIME type is "application/x-shockwave-flash".

### Performance Evaluation

The standalone prototype was written in C++ and compiled with Borland C++ version 5.5.1 at optimization level -O2. The experiments were conducted in a Windows XP Professional SP2 environment running on a Pentium CPU operating at 3.0GHz, equipped with 1GB of 533MHz DDR2-SDRAM ECC main memory.

We measured the throughput of the standalone prototype over real traffic datasets, as summarized in Table 2. To eliminate overhead specific to the test environment, we loaded the input files into main memory first and measured the time for our detection algorithm to scan the files. The average processing speed was 1.95 Mbits/sec, with 83% of the elapsed time spent on disassembly. The instruction decoder part of our disassembler, borrowed from Ollydbg debugger [30], was originally designed for offline decoding. We believe optimizing this component could significantly increase overall throughput, which we will investigate in future work. For the 1.77 GB of input processed, our analyzer processed disassembled sequences at 11.62 Mbits/sec.

**Table 2: Experiment Results**

| Input Data | Elapsed Time (sec) | Disassembly (sec) | Analysis (sec) | Analysis Throughput (Mbps) |
|------------|--------------------|-------------------|----------------|---------------------------|
| Dataset1   | 855.785467         | 267.055825        | 588.729642     | 9.503267                  |
| Dataset2   | 1075.931188        | 179.813182        | 896.118006     | 12.836709                 |
| Dataset3   | 1373.455207        | 167.464756        | 1205.990451    | 17.00598                  |
| Dataset4   | 1047.691866        | 233.835534        | 813.856332     | 10.978939                 |
| Dataset5   | 483.113477         | 82.381132         | 400.732345     | 12.567039                 |
| Dataset6   | 825.120756         | 228.234238        | 596.886518     | 8.325504                  |
| Dataset7   | 493.956068         | 85.463046         | 408.493022     | 14.816603                 |

### Related Work

This paper is primarily relevant to the following research areas:

#### Exploit Code Detection by Static Analysis
Kruegel et al. [15] used control flow structures to detect polymorphic shellcode and worms. Chinchani and Berg [8] employed pattern-matching and data flow analysis techniques to detect exploit code within network flows. SigFree [28] blocks attacks by detecting the presence of code in data requests using a technique called code abstraction. These static analysis approaches can detect both known and zero-day exploit codes and are generally more resilient to polymorphism and metamorphism. However, Polychronakis et al. [23] demonstrated that anti-static-analysis techniques like self-modifying and indirect jumps can easily thwart these methods.

#### Exploit Code Detection by Emulation
Polychronakis et al. [23] proposed a NIDS-embedded CPU emulator to detect polymorphic shellcode. Zhang et al. [31] introduced another emulator with a static analysis method to identify the start point of polymorphic shellcode, potentially faster than [23]. While emulators are immune to most anti-static-analysis techniques, they are vulnerable to anti-emulation techniques, such as random worms that execute only under specific conditions. Additionally, emulators must use heuristics to determine when to stop analyzing a program, which experienced attackers can bypass. We note that the emulators in [23, 31] detect only polymorphic shellcode, so plain exploit code, such as worm Code Red, would evade detection. Motivated by [23], we developed STILL, which is robust to both anti-static-analysis and anti-emulation techniques and can detect both polymorphic and plain exploit code.

#### Disassembly
The first step in static analysis for executables is disassembly, which translates machine code to assembly code and generates a Control Flow Graph (CFG). Linn and Debray [18] introduced obfuscations that can thwart the disassembly process. Kruegel et al. [16] investigated disassembly of obfuscated binaries, and Balakrishnan and Reps analyzed memory access obfuscation in x86 executables [7].

### Conclusion

We developed STILL, a novel static taint and initialization analysis approach, to address code obfuscation. Our static taint analysis technique enables STILL to collect strong evidence of self-modifying and/or indirect jump code obfuscation behaviors. Experimental results show that STILL detected all 12,000 exploit codes generated by 10 well-known shellcode generation engines and achieved a false positive rate of 0.0079% in analyzing 378,158 HTTP requests/replies.

### Acknowledgment

We thank the members of Penn State Cyber Security Lab for collecting real traces. The work of Xinran Wang and Sencun Zhu was supported in part by the National Science Foundation (CAREER NSF-0643906). The work of Yoon-Chan Jhi and Peng Liu was supported in part by NSF CNS-0716479, AFOSR MURI: Automatic Recovery of Enterprise-wide Systems after Attack or Failure with Forward Correction, and AFRL award FA8750-08-c-0137.

### References

[1] Computer Emergency Response Team (CERT). http://www.cert.org.
[2] Intel IA-32 Architecture Software Developerâ€™s Manual Volume 1: Basic Architecture. Intel Corporation.
[3] Jempiscodes - A Polymorphic Shellcode Generator. http://www.shellcode.com.ar/en/proyectos.html.
[4] The Metasploit Project. http://www.metasploit.com.
[5] Microsoft Security Bulletin. http://www.microsoft.com/technet/security/current.aspx.
[6] Snort - The de facto standard for intrusion detection/prevention. http://www.snort.org.
[7] G. Balakrishnan and T. Reps. Analyzing Memory Accesses in x86 Executables. In 13th International Conference on Compiler Construction, 2004.
[8] R. Chinchani and E. Van Den Berg. A Fast Static Analysis Approach to Detect Exploit Code Inside Network Flows. In RAID, 2005.
[9] C. Cifuentes and A. Fraboulet. Intraprocedural Static Slicing of Binary Executables.
[10] C. Collberg, C. Thomborson, and D. Low. A Taxonomy of Obfuscating Transformations. Technical Report 148, University of Auckland, July 1997.
[11] Solar Designer. Non-Executable Stack Getting (and Getting Around the Fix). http://seclists.org/bugtraq/1997/Aug/0063.html.
[12] T. Detristan, T. Ulenspiegel, Y. Malcom, M. Superbus Von Underduk. Polymorphic Shellcode Engine Using Spectrum Analysis. http://www.phrack.org/show.php?p=61&a=9.
[13] C. Ionescu. Getpc Code. http://www.securityfocus.com/archive/82/327348/2006-01-03/1.
[14] J. C. King. Symbolic Execution and Program Testing. Communications of the ACM, 19(7), 1976.
[15] C. Kruegel, E. Kirda, D. Mutz, W. Robertson, and G. Vigna. Polymorphic Worm Detection Using Structural Information of Executables. In RAID, 2005.
[16] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna. Static Disassembly of Obfuscated Binaries. In Proceedings of USENIX Security 2004, August 2004.
[17] Z. Li, M. Sanghi, Y. Chen, M. Y. Kao, and B. Chavez. Hamsa: Fast Signature Generation for Zero-Day Polymorphic Worms with Provable Attack Resilience. In IEEE Symposium on Security and Privacy, May 2006.
[18] C. Linn and S. Debray. Obfuscation of Executable Code to Improve Resistance to Static Disassembly. In ACM CCS, 2003.
[19] S. Macaulay. Admmutate: Polymorphic Shellcode Engine. http://www.ktwo.ca/security.html.
[20] A. Moser, C. Kruegel, and E. Kirda. Limits of Static Analysis for Malware Detection. In Proceedings of the 23rd ACSAC, 2007.
[21] J. Newsome, B. Karp, and D. Song. Polygraph: Automatic Signature Generation for Polymorphic Worms. In IEEE Security and Privacy Symposium, May 2005.
[22] Noir. Getpc Code. http://www.securityfocus.com/archive/82/327100/2006-01-03/1.
[23] M. Polychronakis, K. G. Anagnostakis, and E. P. Markatos. Network-Level Polymorphic Shellcode Detection Using Emulation. In DIMVA, 2006.
[24] S. Singh, C. Estan, G. Varghese, and S. Savage. Earlybird System for Real-Time Detection of Unknown Worms. Technical report, Univ. of California at San Diego, 2003.
[25] SK. History and Advances in Windows Shellcode. Phrack, vol. 11, no. 62, July 2004.
[26] P. Szor. The Art of Computer Virus Research and Defense. Addison-Wesley, 2005.
[27] G. Vigna, W. Robertson, and D. Balzarotti. Testing Network-Based Intrusion Detection Signatures Using Mutant Exploits. In ACM CCS, 2005.
[28] X. Wang, C. Pan, P. Liu, and S. Zhu. SigFree: A Signature-Free Buffer Overflow Attack Blocker. In 15th Usenix Security Symposium, July 2006.
[29] X. F. Wang, Z. Li, J. Xu, M. K. Reiter, C. Kil, and J. Y. Choi. Packet Vaccine: Black-Box Exploit Detection and Signature Generation. In ACM Conference on CCS, 2006.
[30] O. Yuschuk. Ollydbg Disassembler, 2006.
[31] Q. Zhang, D. S. Reeves, P. Ning, and S. Purushothaman Iyer. Analyzing Network Traffic to Detect Self-Decrypting Exploit Code. In AsiaCCS, 2007.