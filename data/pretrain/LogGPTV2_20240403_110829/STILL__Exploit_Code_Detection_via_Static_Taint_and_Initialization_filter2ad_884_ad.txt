0
0
0
0
0
0
0
0
0
ﬂv-application/octet-stream
video/ﬂv
video/x-ﬂv
Total
4
0
0
0
0
0
0
0
2
1
2
5
servers and bank servers, and HTTPS requests. The overall
size of the traces is about 1.77 GB.
Our detection results are as follows. First, STILL raised
no alarms on the HTTP requests to servers. Second, STILL
raised warnings on 30 HTTP binary replies coming into
client-side web browsers. Because none of them contain
malicious exploit code, they all are false positives and the
false positive rate is 0.0079%. Table 1(b) shows the number
of false positives classiﬁed by mime-types in HTTP head-
ers of input. We note that although there are 30 false posi-
tives, most of them can be easily precluded by further man-
ual or automatic analysis. First, by checking these ﬁles, we
found that nine of them were indeed Win32 executable in
PE (Portable Executable) ﬁle format. Because the purpose
of STILL is to detect if a request contains code/mailicous
code rather than to discern malicious code from legitimate
code, we could let end users to decide whether or not to
block these executables. Second, some Type2 warnings
are obviously false positives because register eax is set to
a number much larger than 256, which is not a valid system
call number in Linux and Windows. Finally, we can re-
duce false positives by checking the context. For example,
if we believe there are no vulnerabilities in a Shockwave
Player (because of other reliable tools), we may ignore the
two false positives where the mime type is “application/x-
shockwave-ﬂash”.
5.3 Performance Evaluation
The stand-alone prototype was written in C++ program-
ming language in Win32 environment, and compiled with
Borland C++ version 5.5.1 at optimization level -O2. The
experiments were performed in a Windows XP Professional
296296
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:00:28 UTC from IEEE Xplore.  Restrictions apply. 
SP2 environment running on a Pentium CPU operating
at 3.0GHz, equipped with 1GB 533MHz DDR2-SDRAM
ECC main memory.
We measured the throughput of the stand-alone proto-
type over the real trafﬁc datasets shown in Table 1(a). The
results are summarized in Table 2. To remove the over-
head speciﬁc to the test environment, we loaded the input
ﬁles into main memory ﬁrst and measured the time for our
detection algorithm to scan the ﬁles. Also, the time spent
by the loader was deliberately excluded when we mea-
sured the elapsed time. The average processing speed was
1.95Mbits/sec; however, 83% of elapsed time was spent on
disassembly. Since the instruction decoder part of our dis-
assembler, borrowed from Ollydbg debugger [30], was orig-
inally used for ofﬂine decoding, we believe optimizing the
instruction decoder could dramatically increase the overall
throughput. We will investigate it in our future work. For
the 1.77 GB of input processed, our analyzer processed dis-
assembled sequences at 11.62Mbits/sec.
Table 2. Experiment results
Input data
Elapsed time (sec)
Disassembly
Analysis
Dataset1
Dataset2
Dataset3
Dataset4
Dataset5
Dataset6
Dataset7
855.785467
1075.931188
1373.455207
1047.691866
483.113477
825.120756
493.956068
267.055825
179.813182
167.464756
233.835534
82.381132
228.234238
85.463046
Analysis
throughput
(Mbps)
9.503267
12.836709
17.00598
10.978939
12.567039
8.325504
14.816603
6 Related Work
This paper is mainly relevant to the following work.
Exploit Code Detection by Static Analysis Kruegel et
al. [15] exploited control ﬂow structures to detect polymor-
phic shellcode and worms. Chinchani and Berg [8] used
pattern-matching and data ﬂow analysis techniques to de-
tect exploit code inside network ﬂows. SigFree [28] blocks
attacks by detecting the presence of code in data requests.
It uses a new technique called code abstraction to differen-
tiate code and data. One beneﬁt of these static analysis ap-
proaches is that they can detect both foreseen exploit code
exploiting known vulnerabilities and zero-day exploit code
exploiting unknown vulnerabilities. In addition, they are in
general more resilient to polymorphism and metamorphism
(than string-matching signatures). However, Polychronakis
et al. [23] demonstrated that some anti-static-analysis tech-
niques such as self-modifying and indirect jump can easily
thwart these existing static analysis techniques.
Exploit Code Detection by Emulation Polychronakis
et al. [23] ﬁrstly proposed a NIDS-embedded CPU emulator
to detect polymorphic shellcode. Zhang et al. [31] proposed
another emulator to detect polymorphic shellcode. In addi-
tion, they use a static analysis method to identify the start
point of polymorphic shellcode which is potentially faster
than [23]. The emulators, being a dynamic analyzer, are im-
mune to most anti-static-analysis techniques. However, dy-
namic analysis is vulnerable to several anti-emulation tech-
niques, which have existed in virus writer community for
many years [26]. For example, it may be thwarted by ran-
dom worms that only execute on a speciﬁc condition such
as a randomly generated date or time. Another example is
that it must use some heuristics to determine when to stop
analyzing a program, because execution may not terminate.
An experienced attacker may bypass the stopping heuristics
by introducing a delay loop that simply wastes cycles. We
note that the emulators in [23, 31] detect only polymorphic
shellcode, thus plain (with or without metamorphism) ex-
ploit code such as worm Code Red will evade its detection.
Motivated by [23], we proposed STILL, which is robust to
both anti-static-analysis and anti-emulation techniques. In
addition, STILL is a comprehensive solution, which can de-
tect both polymorphic and plain (with or without metamor-
phism) exploit code.
Disassembly The ﬁrst step of static analysis for exe-
cutables is disassembly, which translates machine code to
assembly code and generates CFG. Linn and Debray [18]
introduced some obfuscations that can thwart the disassem-
bly process. Kruegel et al. [16] investigated disassembly of
obfuscated binaries. Balakrishnan and Reps analyzed mem-
ory accesses obfuscation in x86 executables [7].
7 Conclusion
We developed STILL, a novel static taint and initializa-
tion analysis approach, to address code obfuscation. Our
static taint analysis technique enables STILL to collect
strong evidence of self-modifying and/or indirect jump code
obfuscation behaviors. As a result, while self-modifying
code or indirect jumps may avoid the detection of other
static analysis approaches, STILL can detect them with a
high accuracy. Our experiment results show that STILL de-
tected all the 12,000 exploit codes generated by 10 well-
known shellcode generation engines and STILL achieves
0.0079% false positive rate in analyzing 378,158 HTTP re-
quests/replies.
Acknowledgment
We would like to thank the members of Penn State Cyber
Security Lab for collecting real traces. The work of Xinran
Wang and Sencun Zhu was supported in part by the Na-
tional Science Foundation (CAREER NSF-0643906); the
work of Yoon-Chan Jhi and Peng Liu was supported in part
by NSF CNS-0716479, AFOSR MURI: Automatic Recov-
ery of Enterprise-wide Systems after Attack or Failure with
Forward Correction, and AFRL award FA8750-08-c-0137.
297297
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:00:28 UTC from IEEE Xplore.  Restrictions apply. 
References
[1] Computer
emergency
response
team (cert).
http://www.cert.org.
[2] Intel ia-32 architecture software developer’s manual
volume 1: Basic architecture. Intel Corporation.
[3] Jempiscodes - a polymorphic shellcode generator.
http://www.shellcode.com.ar/en/proyectos.html.
[4] The metasploit project. http://www.metasploit.com.
[5] Microsoft
security
bulletin.
http://www.microsoft.com/technet/security/current.aspx.
[6] the
de
facto
standard
for
intrusion
deetec-
tion/preventions. http://www.snort.org.
[7] G. Balakrishnan and T. Reps. Analyzing memory ac-
cesses in x86 executables. In 13th International Con-
ference on Compiler Construction, 2004.
[8] R. Chinchani and E. Van Den Berg. A fast static anal-
ysis approach to detect exploit code inside network
ﬂows. In RAID, 2005.
[9] C. Cifuentes and A. Fraboulet. Intraprocedural static
slicing of binary executables.
[10] C. Collberg, C. Thomborson, and D. Low. A taxon-
omy of obfuscating transformations. Technical Report
148, University of Auckland, July 1997.
[11] Solar
Designer.
non-executable
http://seclists.org/bugtraq/1997/Aug/0063.html.
stack
Getting
(and
around
ﬁx).
[12] T. Detristan, T. Ulenspiegel, Y. Malcom,
M. Superbus Von Underduk.
shellcode
http://www.phrack.org/show.php?p=61&a=9.
engine
using
and
Polymorphic
spectrum analysis.
[13] C.
Ionescu.
Getpc
code.
http://www.securityfocus.com/archive/82/327348/2006-
01-03/1.
[14] J. C. King. Symbolic execution and program testing.
Communications of the ACM, 19(7), 1976.
[15] C. Kruegel, E. Kirda, D. Mutz, W. Robertson, and
G. Vigna. Polymorphic worm detection using struc-
tural information of executables. In RAID, 2005.
[16] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna.
Static disassembly of obfuscated binaries. In Proceed-
ings of USENIX Security 2004, August 2004.
298298
[17] Z. Li, M. Sanghi, Y. Chen, M. Y. Kao, and B. Chavez.
Hamsa: Fast signature generation for zero-day poly-
morphic worms with provable attack resilience.
In
IEEE Symposium on Security and Privacy, May 2006.
[18] C. Linn and S. Debray. Obfuscation of executable
In
code to improve resistance to static disassembly.
ACM CCS, 2003.
[19] S. Macaulay. Admmutate: Polymorphic shellcode en-
gine. http://www.ktwo.ca/security.html.
[20] A. Moser, C. Kruegel, and E. Kirda. Limits of static
analysis for malware detection. In Proceedings of the
23rd ACSAC, 2007.
[21] J. Newsome, B. Karp, and D. Song. Polygraph: Au-
tomatic signature generation for polymorphic worms.
In IEEE Security and Privacy Symposium, May 2005.
[22] Noir.
Getpc
code.
http://www.securityfocus.com/archive/82/327100/2006-
01-03/1.
[23] M. Polychronakis, K. G. Anagnostakis, and E. P.
Markatos. Network-level polymorphic shellcode de-
tection using emulation. In DIMVA, 2006.
[24] S. Singh, C. Estan, G. Varghese, and S. Savage.
Earlybird system for real-time detection of unknown
worms. Technical report, Univ. of California at San
Diego, 2003.
[25] sk. History and advances in windows shellcode.
Phrack, vol. 11, no. 62, July 2004.
[26] P. Szor. The Art of Computer Virus Research and De-
fense. Addison-Wesley, 2005.
[27] G. Vigna, W. Robertson, and D. Balzarotti. Test-
ing network-based intrusion detection signatures us-
ing mutant exploits. In ACM CCS, 2005.
[28] X. Wang, C. Pan, P. Liu, and S. Zhu. Sigfree: A
signature-free buffer overﬂow attack blocker. In 15th
Usenix Security Symposium, July 2006.
[29] X. F. Wang, Z. Li, J. Xu, M. K. Reiter, C. Kil, and J. Y.
Choi. Packet vaccine: Black-box exploit detection and
In ACM Conference on CCS,
signature generation.
2006.
[30] O. Yuschuk. Ollydbg disassembler, 2006.
[31] Q. Zhang, D. S. Reeves, P. Ning, and S. Pu-
rushothaman Iyer. Analyzing network trafﬁc to detect
self-decrypting exploit code. In AsiaCCS, 2007.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:00:28 UTC from IEEE Xplore.  Restrictions apply.