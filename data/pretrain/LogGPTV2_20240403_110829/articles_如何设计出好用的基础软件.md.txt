### 如何设计出好用的基础软件

#### 作者简介
**黄东旭**
- **PingCAP 联合创始人兼 CTO**
- 工程师，专注于分布式系统和数据库
- 主要项目：TiDB, TiKV, Codis
- 兴趣爱好：编程、绘画、弹琴
- 邮箱：PI:EMAIL

#### 引言
你能够熟练使用 `gdb` 吗？（不借助 Google）
这个问题或许会让很多系统程序员感到困扰。我们常常对复杂的工具有一种特殊的情感，但这些工具真的好用吗？在21世纪，为什么程序员不能把东西做得更易用一些呢？

#### 系统软件的痛点
- **系统软件斯德哥尔摩综合症候群**：系统程序员可能对复杂性有特别的感情，但这些工具确实难用。
- **灵魂拷问**：你能熟练使用 `gdb` 或 `vim` 吗？如果不能，这是否意味着你的智商有问题？其实，这些工具应该向我们道歉。

#### 认知外部世界的模式
为了设计出好用的软件，我们需要跨越两条鸿沟：
1. **执行的鸿沟**
2. **评估的鸿沟**

### 跨越执行的鸿沟：可交互性

#### 概念模型：No Surprise!
- **例子：汽车**  
  人对事物通常有预设的心理模式。当我们看到 `$ _` 或者 `> _` 时，会想到什么？简单且自洽的概念最容易被记住（自然映射）。

#### 好的例子
- **UNIX 的概念模型**  
  - 一切皆是文件
  - 数据是流
  - 使用 `Pipe` 来串联流
- **TiUP**  
  - 一切皆是组件
- **Telegram Botfather**  
  - 对话式交互
- **Redis CLI**  
  - 映射到 Redis 的概念模型：一切皆是 KV
  - 交互命令操作模式（甚至修改配置也是）
- **MySQL**  
  - SQL 本身就是一个很好的模型

#### 控制器与控制对象
- **控制器 - 控制对象**  
  一个电视机应该只有一个遥控器。控制器的对应关系混乱是大忌。

#### 探索式学习
- **开发者的心态**  
  文档约等于字典。接触新东西时，开发者的内心活动通常是寻找“Quick start”和“install script”。

#### Quick Start 的重要性
- **第一行 shell 命令**  
  心理接受度排序：`apt / yum / pacman / brew … > curl xxx | sh >= pip / go get / cargo > Docker >>>> npm`
- **引导用户**  
  第一行顺利成功后，最好引导用户到一个可交互环境，并告诉他们下一步该做什么。

#### 补全的重要性
- **例子：Telegram Botfather**

#### 多想一步
- **重要决定不要代替用户做**  
  提供 DryRun 模式，让用户自己走半步。

#### 正确的反馈
- **反应时间**  
  正常人的反应时间为0.15秒-0.4秒。超过这个时间就会有明显的延迟感。
- **反馈三定律**  
  - 不要暴露内部概念！
  - 用精简的人话暴露进展和状态。
  - 反馈必须即时。

#### 反馈的例子
- **坏例子**  
  TiDB 的报错信息：
  ```sql
  MySQL [test]> SELECT COUNT(1) AS count, SUM(account_balance) AS amount, trade_desc AS type FROM b_test WHERE member_id = "22792279001" AND detail_create_date >= "2019-11-19 17:00:00" AND detail_create_date < "2019-11-28 17:00:00" group by trade_desc;
  ERROR 9005 (HY000): Region is unavailable
  ```
- **好例子**  
  提供清晰、具体的错误信息和建议。

#### 关于配置
- **修改配置文件**  
  是一个慢反馈过程。配置文件需要在正确的位置，并在启动时检查和告诉用户配置信息。
- **热更新**  
  热更新优于重启。提供可交互式工具用于配置检查和热更新。
- **心智负担**  
  从环境变量到配置文件，心智负担逐渐增加。

#### 不要重新发明轮子
- **好的例子**  
  Docker CLI, kubectl, Redis CLI, tiup 等。

### 跨越评估的鸿沟：可观测性

#### 观测的对象
- **人**  
  我们真的做到以人为本了吗？曾经的一个“卖点”是我们有几千个监控项，但人同一时间大概只能跟踪4个对象。

#### 区分噪音和信息
- **关键资源**  
  - CPU：哪些线程在工作？它们在做什么？消耗了多少 CPU 时间？
  - 内存：当前内存中存储了哪些东西？命中率如何？
  - 网络 I/O：QPS/TPS 有异常吗？主要的网络 I/O 请求是什么？带宽够吗？请求延迟如何？
  - 磁盘 I/O：读写哪些文件？读写模式是什么？吞吐量多大？I/O 延迟多大？
  - 关键日志：只有包含特定关键字的日志才会被关心。

#### 利用人的直觉
- **结合业务上下文**  
  把“噪音”变成有用信息。

#### 例子
- **TiDB Key Viz**
- **Golang pprof**
- **练习：TiDB TopSQL**  
  试着在不告诉你具体功能的前提下，从界面上提取信息。

#### 周期
- **贴近业务周期**  
  脱离周期谈可观测性都是耍流氓。全链路监控是一个很好的例子。

#### 事后观测
- **什么时候能救命**  
  Profile 在何时是有用的？持续 Profiling。

### 参考资料
- **《The Design of Everyday Things》** - Don Norman
- **《Don't Make Me Think》** - Steve Krug
- **《产品故事地图》** - Donna Lichaw
- **《UNIX 编程艺术》** - Eric Raymond

谢谢！🙏