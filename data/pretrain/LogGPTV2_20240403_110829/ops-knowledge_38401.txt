User: 请回答以下安全问题存储在内存中的密码是否安全？我刚刚意识到，在任何语言中，当你将密码保存在变量中时，它都会以纯文本的形式存储在内存中。
我认为操作系统完成了它的工作，禁止进程访问彼此分配的内存。但我也认为这在某种程度上是可以绕过的。因此，我想知道它是否真的安全，是否有更安全的方法来存储密码，以确保外国进程无法访问它们。
我没有具体说明操作系统或语言，因为我的问题很笼统。这与其说是一个特定目的的问题，不如说是个计算机知识问题。

Assistant: 你正在触及一个痛点。。。
历史上，计算机是大型机，许多不同的用户在同一台物理机器上启动会话和处理。类Unix系统（例如Linux），以及VMS及其相关系统（该系列包括NT系列的所有Windows，因此包括2000、XP、Vista、7、8…），都是为了支持大型机模型而构建的。
因此，硬件提供了特权级别。操作系统的核心部分是以最高特权级别运行（是的，我知道虚拟化有一些微妙之处）并管理特权级别的内核。应用运行在较低级别，并且被内核强制阻止读取或写入彼此的内存。应用通过页面（通常为4或8kB）从内核获得RAM。试图访问属于另一个应用的页面的应用会被内核阻止，并受到严重惩罚（“分段故障”、“一般保护故障”…）。
当应用不再需要页面时（特别是当应用退出时），内核会控制页面，并可能将其交给另一个进程。现代操作系统在归还页面之前先“清空”页面，其中“清空”的意思是“用零填充”。这样可以防止数据从一个进程泄漏到另一个进程。请注意，Windows 95/98/Millenium没有空白页面，并且可能会发生泄漏。。。但这些操作系统是为每台机器的单个用户设计的。
当然，有一些方法可以逃脱内核的愤怒：有“足够特权”（与上述特权不同）的应用可以使用一些入口。在Linux系统上，这是ptrace（）。内核允许一个进程通过ptrace（）读取和写入另一个进程的内存，前提是两个进程在相同的用户ID下运行，或者执行ptrace的进程是“根”进程。Windows中也有类似的功能。
归根结底，RAM中的密码并不比操作系统允许的更安全。根据定义，通过在进程的内存中存储一些机密数据，您就相信操作系统不会将其泄露给第三方。操作系统是你的朋友，因为如果操作系统是敌人，那么你就完全输了。
现在是有趣的部分。由于操作系统强制流程分离，许多人试图找到突破这些防御的方法。他们发现了一些有趣的事情。。。
应用看到的“RAM”不一定是真正的“内存”。内核是一个幻想大师，它给出的页面并不一定存在。这种错觉是通过将RAM内容与磁盘上的专用空间交换来维持的，在磁盘上有大量的可用空间；这被称为虚拟内存。应用不需要意识到这一点，因为内核会在需要时带回页面（当然，磁盘比RAM慢得多）。一个不幸的后果是，一些据称保存在RAM中的数据会被转移到物理介质中，直到被覆盖。特别是，如果断电，它会留在那里。这允许进行攻击，坏人抓住机器逃跑，以便稍后检查数据。或者，当机器退役并在易趣上出售时，系统管理员忘记清除磁盘内容，可能会发生泄漏。
Linux提供了一个名为mlock（）的系统，它可以防止内核向交换空间发送一些特定的页面。由于锁定RAM中的页面可能会耗尽其他进程的可用RAM资源，因此您需要一些权限（再次为root）才能使用此功能。
一个更严重的情况是，跟踪你的密码在RAM中的真实位置并不一定容易。作为一名程序员，您可以通过编程语言提供的抽象来访问RAM。特别是，使用垃圾回收的编程语言可以透明地复制RAM中的对象（因为它确实有助于许多GC算法）。大多数编程语言都受到了影响（例如Java、C#/.NET、Javascript、PHP……不胜枚举）。
冬眠带来了同样的问题，并带来了报复。从本质上讲，休眠必须将整个RAM写入磁盘——这可能包括多锁的页面，甚至CPU寄存器的内容。为了避免休眠时的泄漏，你必须采取严厉的措施，比如加密整个磁盘——这自然意味着每当你唤醒机器时都要键入解锁密码。
大型机模型假设它可以运行几个相互敌对的进程，同时保持完美的和平与孤立。现代化的硬件使这变得非常困难。当两个进程在同一CPU上运行时，它们共享一些资源，包括缓存；缓存中的内存访问比其他地方快得多，但缓存大小非常有限。这被用来从另一个进程恢复一个进程使用的加密密钥。已经开发了使用其他类似缓存的资源的变体，例如CPU中的分支预测。虽然对这一主题的研究集中在加密密钥上，这是一种高价值的秘密，但它实际上只适用于任何数据。
同样，视频卡也可以直接访问内存。DMA是否不能被滥用来从其他进程读取或写入内存，取决于未记录的硬件、封闭源代码驱动程序和内核协作执行适当访问控制的程度。我不会把我最后一件衬衫押在上面。。。
结论：是的，当你将密码存储在RAM中时，你相信操作系统会对其保密。是的，这项任务很艰巨，甚至在现代系统中几乎不可能完成。如果某些数据是高度机密的，那么您确实不应该使用大型机模型，也不应该允许潜在的敌对实体在您的机器上运行其代码。
（顺便说一句，这意味着托管虚拟机和云计算最终不可能是安全的。如果你认真考虑安全问题，请使用专用硬件。）