0
or，或，两端有一个为真，则结果为真
！
1
not，非，两端相反，则结果为真
对于上述操作符，有如下提示：
口逻辑操作符前后的表达式是否成立，一般用真假来表示。
口“！”的中文意思是反，即与一个逻辑值相反的逻辑值。
口-a的中文意思是“与”（and或&&），前后两个逻辑值都为“真”，综合返回值才
为“真”，反之为“假”。
回。√“（10），中0-
为“真”。
连接两含[]、test或[I]的表达式可用&&或。
逻辑操作符运算规则
-a和&&的运算规则：只有逻辑操作符两端的表达式都成立时才为真；真（true）
表示成立，对应的数字为1：假（false）表示不成立，对应的数字为0，这一点相当于如
---
## Page 127
第6章Shell脚本的条件测试与比较
下表达式：
[rooteoldboy -]#[-f/etc/hosts-a -f/etc/services]k echo1 11echo0
3））&kecho111echo0
1
1
-0或的运算规则为：
当左边为真，右边为假的时候，相加结果为1+0=1，总结果为真（1）。
当左边为假，右边为真的时候，相加结果为0+1=1，总结果依然为真（1）。
当左边为真，右边也为真的时候，相加结果为1+1-2，总结果为真（1），非0即真。
当左边为假，右边也为假的时候，相加结果为0+0=0，总结果为假（0）。
简单表示为：
or结果1+0=1真
or结果1+1=2真（非0即为真）
or结果0+1=1真
or结果0+0=0假
结论：or（Ⅱ）也称为或，它的两端表达式的结果都是0时才为假，不为0就是真。
相当于对前后表达式结果取并集。
---
## Page 128
眼老男孩学Linux运维：Shell编程实战
6.5.2逻辑操作符实践示例
范例6-28：口里的逻辑操作符配合文件测试表达式使用的示例。
[root@oldboy -]# f1=/etc/rc.local;f2=/etc/services
20&&n>30））&6echo111echo030））&echo 111echo 0
[root@o1dboy -]#（（m）[aqodpouq/x--eoou,=]as.]
102:
-[]==>u.=1.-o.u-]
170:
u..-.-]
u=1.e-.-1
229 :
提示：可见中使用-a或-0更常见，[1]中使用&&或l不常见，使用&&或
连接两个口的多表达式判断也不常见。
范例6-33：系统启动脚本中有关[]的用法和与或非判断的使用案例。
在操作系统中，[]的用法不是很多，并且大多数情况都用于与通配符匹配的场景。
这里不得不通过大海捞针的方法（遍历/etc/init.d/下的所有脚本）来帮助大家查找
[]的用法：
Snjdone
119：if[（“Sdst*/dev/mapper*]]/dev/nul1/dev/nu11.oo
exit0
#no4
F
[Sa-eqSb]&（2
[root8oldboy scripts]# sh 6_35_1.sh
Pls input two num:6 6
/dev/nu11
/dev/nu11
 2
[root8oldboy scripts]sh 6_35_2.sh 6 6