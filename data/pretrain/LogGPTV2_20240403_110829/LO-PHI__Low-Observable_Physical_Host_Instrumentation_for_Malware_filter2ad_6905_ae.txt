On the contrary, when executed in our physical analysis
environment, the only artifacts that paﬁsh detected were:
hi sandbox physicalmemory less 1Gb
hi sandbox drive size2
In this instance, we were using a 750 GB hard drive
with a 10 GB partition on it and 1 GB of physical memory.
These artifacts are very easily removed by simply adding more
hardware to the SUT. However, this will have a direct effect
on the time per sample in an automated environment, as a
larger disk image will have to be restored, and larger memory
snapshots will require more time and space. Nevertheless, LO-
PHI is able to analyzing paﬁsh without detection.
2) Labeled Malware: To evaluate LO-PHI’s ability to an-
alyze real malware samples, we obtained a set of coarsely-
labeled evasive malware samples, generated by Kirat et al. [44]
in their previous work. Because these samples were speciﬁcally
labeled as evasive, we only present the ﬁndings from executing
them in our physical environment. While we had ground truth
that these samples employed evasion techniques, capable of
evading most popular analysis frameworks, we were not given
the intended effect or target operating system of the samples,
as we were with the samples in Section VII-C2. Similarly,
because of our aforementioned networking restriction, we ex-
pect that numerous samples will produce uninteresting behav-
ior without access their command-and-control infrastructure.
Thus, we are unable to make any deﬁnitive claims as to speciﬁc
intent of the malware. We present our aggregated ﬁndings
below, which indicate that our framework successfully avoided
their evasive behaviors. The dataset consisted of malware
labeled as using the evasion techniques outlined in Table V.
A summary of our ﬁndings is presented in Table VI.
TABLE IV: Description of Volatility modules used for evaluating
evasive malware.
psscan
envars
ssdt
netscan
ldrmodules
driverirp
psxview
Enumerates processes using pool tag scanning. (Capable of
ﬁnding processes that have previously terminated (inactive)
and processes that have been hidden or unlinked)
Extracts environment variables from processes in memory.
Lists the functions in the Native and GUI SSDTs.
Enumerates network sockets using pool tag scanning.
Enumerates modules in the Virtual Address Descriptor
(VAD) and cross-references them with three unique PEB
lists: InLoad, InInit, and InMem.
Enumerates all DRIVER OBJECT structures in memory
Helps detect hidden processes by enumerating PsAc-
tiveProcessHead using the following methods: PsAc-
tiveProcessHead linked list, EPROCESS pool scanning,
ETHREAD pool scanning, PspCidTable, Csrss.exe handle
table, and Csrss.exe internal linked list.
11
TABLE V: Evasive malware dataset.
Technique Employed
Wait for keyboard
Bios-based
Hardware id-based
Processor feature-based
Exception-based
Timing-based
# Samples
3
6
28
62
79
251
a) Wait
for keyboard: Due to the small number of
samples employing this type of technique, we were not able to
draw any interesting conclusions from these samples, however
all of them appeared to execute successfully. One presented
an error dialog window that our framework was able to locate
and click, which appeared to kill the sample. This particular
sample also made a DNS query to goldcentre.ru. The
other two had no notable effects on our system.
b) BIOS-based: All of the examples in this category
appeared to trigger their payload. That is, they were unsuccess-
ful in detecting our analysis framework, and exhibited some
interesting behaviors. Every sample attempted to create an
output network connections to smtp.mail.ru. Two of them
attempted to determine their IP addresses using “whatismyip”
services. The samples also spawned new processes that per-
sisted throughout our analysis, most masquerading as existing
Windows services. The psxscan module indicated that the
processes 122.exe and 123.exe were spawned in two
cases, explorer.exe was also spawned by two of the
samples. Most
interestingly, one of the samples created a
hidden svchost.exe which was invisible to every process
enumeration method except psscan.
c) Hardware-id-based: These samples also exhibited
interesting behaviors. Most notably, 23 of
them started
TrustedInstaller.exe, while 25 of the original pro-
cesses continued running for the duration of our analysis,
and the others appeared to spawn new processes. All of the
samples also attempted to reach out to network resources:
24 of them attempted to connect to 219.235.1.127:80,
1 attempted to connect to 62.75.235.238:443, and 2
attempted TCP connections to either 8.8.8.8 or 8.8.4.4,
both Google-owned DNS servers, on port 53, which is the
DNS port for UDP communications. All of the samples
imported at least 32 modules, with the most active sample
importing 156 unique modules. Finally, 11 of them appeared
to present buttons that were detected and clicked by LO-PHI,
and 2 of them set particularly interesting environment variables
9Yy9Y9YYy9YYy and YYY9YYY9YYY99, which both had
the value of E4EC4E2160D8E128C919C56915BFED6C.
d) Processor feature-based: These samples produced
the least compelling ﬁndings. While most of them persisted,
or installed new processes, 11 had no new processes in
memory. Those that did spawn new processes had ﬁle-
names similar to before, with 4 of them once again load-
ing TrustedInstaller.exe, 3 starting a more stealthy
netsh.exe, 1 spawning a malicious taskhost.exe, and,
perhaps the least stealthy sample, launching trojan.exe.
Most of
them also exhibited network activity, primarily
DNS trafﬁc, with 8 of the samples querying a variation of
TABLE VI: Summary of anomalies detected in Volatility modules
and GUI buttons found in our evasive dataset when executed in our
physical environment on Windows 7 (64-bit).
envars
0
3
28
53
76
229
netscan
3
6
27
54
79
247
e
b
a
L
l Keyboard
Bios
Hardware
Processor
Exception
Timing
e
r
a
w
l
a
M
Volatility Module
ldr m od ules
psxvie w
0
6
26
51
76
239
b uttons
1
0
11
7
7
4
1
6
28
59
77
231
boxonline, and 7 of the samples attempting reach port
8 on various IP addresses. More interestingly, one of the
samples attempted to contact 219.235.1.127, and then opened
a local listening socket. A single sample in this set also set the
SEE_MASK_NOZONECHECKS environment variable to “1”,
which is a variable that will hide security warnings in Windows
XP. This leads us to believe that at least some of the malware
in this set was targeting an older version of windows, and
likely explains why some of the samples appeared to have no
effect. Two of samples also presented dialog boxes and the
button “OK” was clicked.
e) Exception-based: The
exception-based malware
samples also exhibited similar behavior, with all but 3 of the
samples spawning new processes or continuing to execute for
the duration of our analysis. Unsurprisingly, many of these
samples also attempted to engage the network. There appeared
to be two distinct clusters that reached out to various domains
with the strings boxonline (31 samples) and backupdate
(26 samples), with the others calling out to unique domains.
The “boxonline” samples indicate that these may be the same
class of malware that was previously observed in the processor-
feature-based samples. Again, a few of the samples appeared
to present a graphical interface with the text “OK,” which was
successfully clicked.
f) Timing-based: This was our largest dataset, and thus
yielded the most diverse ﬁndings. Again, a majority of the
samples (193 out of 251) spawned new processes or persisted
throughout our analysis. The most interesting process names
being: skype.exe, which was launched by one process
and also hidden from normal windows process enumeration;
taskhost.exe, which was spawned in a hidden state by
22 processes and a less-stealthy manner by 10 other samples;
conhost.exe, which was also spawned in a stealthed state;
and one sample spawned facebook.exe. Once more, we
saw 4 samples set the SEE_MASK_NOZONECHECKS environ-
ment variable, indicating that Windows XP was likely their
intended target. This dataset also had a signiﬁcant number of
samples (156) making boxonline DNS queries, and 5 of
the samples querying backupdate. None of these samples
produced network trafﬁc aside from DNS.
While our analysis did not indicate malicious behavior in
all of the samples in this dataset, we were able to detect typical
malware behavior from a large majority. Some of ﬁndings
indicate that at
least some of the samples were targeting
Windows XP, which could explain the lack of anomalies for
12
the few that appeared benign. Nevertheless, we feel that our
ﬁndings are more that sufﬁcient to showcase LO-PHI’s ability
to analyze evasive malware, without being subverted, and sub-
sequently produce high-ﬁdelity results for further analysis. In
fact, behaviors like unlinked EPROCESS entries and listening
sockets can be exceptionally difﬁcult to detect with software-
based methodologies. Because LO-PHI has a complete view
of the entire memory space and disk activity, the ability for
the malware to hide its presence is greatly hindered.
VIII. RELATED WORK
VAMPiRE [69] is a software breakpoint framework run-
ning within the operating system. It runs in kernel mode,
meaning it is safe for debugging ring 3 (user mode) malware.
Rootkits can gain kernel-level privileges to circumvent VAM-
PiRE. However, as LO-PHI does not rely on the operating
system, it can be used to safely debug rootkits.
Ether [25] is a malware analysis framework based on
hardware virtualization extensions (e.g., Intel VT). It runs
outside of the guest operating systems, i.e., in the hypervisor,
by relying on underlying hardware features. BitBlaze [64] and
Anubis [7] are QEMU-based malware analysis systems. They
focus on understanding malware behavior, instead of achiev-
ing better transparency. V2E [74] combines both hardware
virtualization and software emulation. HyperDbg [30] uses
the hardware virtualization that allows the late launching of
VMX modes to install a virtual machine monitor, and run
the analysis code in the VMX root mode. SPIDER [24] uses
Extended Page Tables to implement invisible breakpoints and
hardware virtualization to hide its side-effects. Compared to
our system, Ether, BitBlaze, Anubis, V2E, HyperDbg and
SPIDER all rely on easily detected emulation or virtualization
technology [20], [57], [59], [60] and make the assumption
that virtualization or emulation is transparent from guest-OSes.
In contrast, LO-PHI provides memory access directly from
the PCI bus, greatly reducing the potential attack surface. In
addition, traditional debugging techniques often add varying
degrees of execution overhead. LO-PHI employs specialized
hardware that is fast enough to decrease visible timing artifacts
otherwise introduced by emulation.
BareBox [43] is a malware analysis framework based on
a bare-metal machine without any virtualization or emulation
techniques. However, it only targets the analysis of user-mode
malware, while LO-PHI can be used for debugging hypervi-
sor rootkits and kernel-mode device drivers. BareCloud [44]
is more similar to our approach, as it utilizes mostly un-
instrumented machines and executes the binaries with a small
software-based loader. Nevertheless, BareCloud requires a
network-based storage device and only has information about
the disk state before and after execution of the binary, whereas
we are able to reconstruction the entire stream of ﬁle-system
operations. Futhermore, BareCloud has no memory instrumen-
tation and presents numerous detectable artifacts (e.g., malware
loader software, networked-drive). Willems et al. [73] used
branch tracing to record all the branches taken by a program
execution. As pointed out in the paper, the data obtainable by
branch tracing is rather coarse, and this approach still suffers
from a CPU register attack against branch tracing settings.
However, LO-PHI provides ﬁne-grained memory access over
the PCI bus, and is thus resistant to CPU register mutation.
Virt-ICE [58] is a remote debugging framework. It lever-
ages virtualization technology to debug malware in a VM and
communicates with a debugging client over a TCP connection.
However, since it uses a VM, a malware may refuse to unpack
itself in the VM. LO-PHI accesses the raw host memory
very rapidly, so we can transparently detect when this type
of execution occurs.
There is a vast array of popular debugging tools. For
instance, IDA Pro [40] and OllyDbg [3] are popular debuggers
running within the operating system that focus on ring 3
malware. DynamoRIO [17] is a process virtualization system
implemented using software code cache techniques. It executes
on top of the OS and allows users to build customized dynamic
instrumentation tools. Similar to LO-PHI, WinDbg [4] uses a
remote machine to connect to the target machine using serial
or network communications. However, these options require
special booting conﬁguration or software running within the
operating system, which is easily detected by malware. LO-
PHI requires a PCI slot, but is intended to run on out-of-the-
box consumer hardware, where debugging facilities may not
be desirable.
IX. FUTURE WORK
We have identiﬁed numerous areas that we feel are critical
to eventually achieve a more transparent and robust framework.
As previously discussed, our current approach has numerous
limitations with smearing and incomplete views of the system
state. CPU debuggers could alleviate these pains by either
completely halting the system during memory acquisition or
simply providing more insight into the internal register values.
We have been experimenting with Intel’s eXtended Debug
Port (XDP) and ARM’s DSTREAM debugger and found
them to extremely powerful devices. Utilizing these hardware