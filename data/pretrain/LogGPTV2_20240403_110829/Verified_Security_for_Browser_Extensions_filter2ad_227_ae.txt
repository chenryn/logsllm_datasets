also makes it possible to deﬁne polymorphic propositions. For
example, the FlowsFrom proposition at line 8 relates a value 
of any type  to another value   of some other type  , to
indicate that  was derived from  ; CanFlowTo is similar.
The DOM API (partial)
1module DOM
2type doc (ࢩ abstract type of documents ࢩ)
3type elt (ࢩ abstract type of DOM element nodes ࢩ)
4 (ࢩ DOM metadata predicates ࢩ)
5type DocDomain :: doc  string  
6type EltDoc :: elt  doc  
7type EltTagName :: elt  string  
8type EltAttr :: elt  string  string  
9type FlowsFrom :: ::ਭ  ::ਭ      
10 (ࢩ DOM permission predicates ࢩ)
11type CanAppend :: elt  elt  
12type CanEdit :: elt  
13type CanReadAttr :: elt  string  
14type CanWriteAttr :: elt  string  string  
15type CanFlowTo ::  ::ਭ   ::ਭ      
16 (ࢩ Metadata queries ࢩ)
17val getChild : p:elt࢐ int࢐
18
19val parentNode: ch:elt ࢐ p:eltEltParent p ch
20val getEltById: d:doc࢐ x:string࢐ c:eltEltDoc c d && EltAttr c ”id” x
21val tagName : ce:elt ࢐ r:stringEltTagName ce r
22 (ࢩ Protected access to data ࢩ)
23val getAttr : e:elt ࢐ k:stringCanReadAttr e k ࢐
24
25val setAttr : e:elt࢐ k:string࢐ v:stringCanWriteAttr e k v࢐
26
27val getValue : e:eltCanReadValue e ࢐ s:stringEltTextValue ce s
28val createElt : d:doc ࢐ t:string ࢐
29
30val appendChild : p:elt ࢐ c:eltCanAppend c p ࢐ :unitEltParent p c
r:stringEltAttr e k r && FlowsFrom r e
:unitEltAttr e k v
r:option elt࢘ ch. r=Some ch EltParent p ch && FlowsFrom r p
e:eltEltDoc e d && EltTagName e t && CanEdit e
Lines 16-21 show a sampling of functions that extensions
can use to inspect the structure of a page. Each of these
functions is given a reﬁned type, where the reﬁnement on the
return value corresponds to a post-condition established by
124
the function. At lines 24-31 we show functions that provide
extensions with access to security sensitive data, e.g., the
attributes of an element. The types of these functions are
reﬁned with both pre- and post-conditions, where the pre-
conditions correspond to authorization privileges that the caller
must possess in order to access, say, an attribute; while the
post-conditions, as with the metadata queries, record properties
of the page structure.
At one level, one can understand pre- and post-conditions
as predicates that relate the arguments and return value of
each function. However, a more precise reading is in terms
of the dynamic semantics of BX. To illustrate, consider the
primitive operator CAJ)JJH of Figure 7. In our formal model,
the reduction rule for CAJ)JJH   was guarded by a
premise that required the proposition +=4A=@)JJH  
to be derivable from the policy and the facts in the log.
We capture this requirement by giving getAttr a type that
records the corresponding CanReadAttr e k predicate as a pre-
condition. Going back to the formal model, if the policy check
succeeds +=4A=@)JJH   reduces to an attribute ,
and. importantly, records the facts -J)JJH    and
.MI.H   in the log. We capture this effect on the log
by giving getAttr a type that includes the corresponding version
of these predicates in its post-condition.
With the understanding that log effects correspond to post-
conditions, and that policy checks in the premises of our
reduction rules correspond to pre-conditions, we discuss the
remaining functions in our DOM API. The function getChild is
the analog of the operator CAJ+DE@HA of our formal semantics,
adapted for use with a more realistic DOM. At the moment,
our logical model of the DOM ignores the relative ordering
among the children of a node—we simply record the fact that
a pair of nodes are in a parent/child relationship. Enhancing
this model to include ordering constraints is certainly possible,
however, our examples have so far not required this degree of
precision on the structure of a page to state useful security
policies. Extensions can traverse the DOM in both directions,
using getChild and parentNode. The DOM also includes a
function, getEltById, which provides random access to nodes
using node identiﬁers—notice that the post-condition of this
function is relatively weak, since the exact placement of the
returned nodes in the DOM is undetermined.
Our API also provides functions that allow extensions to
mutate the DOM. For example, using createElt and appendChild,
a suitably privileged extension can alter the structure of a
web page. The observant reader may wonder how such side-
effecting operations can be soundly modeled using reﬁnement
types in a functional language. The key point here is that we
model such mutation effects purely in terms of their effects
on the dynamic log. Since the log grows monotonically, a
property that was once true of an elt remains valid in the logic
even after the element is mutated.
Concretely, for the example below, suppose we have a pair
of elt values e1 and e2. Then, in a context where CanAppend e2
is derivable, the predicates derivable at each line are shown in
comments.
let p1 = getParent e1 in (ࢩ EltParent p1 e1 ࢩ)
appendChild e2 e1 (ࢩ EltParent p1 e1 && EltParent e2 e1 ࢩ)
Importantly, even after e1 has been added as a child of e2
on the second line, the predicate EltParent p1 e1 continues to be
derivable, since it remains as a ground fact in the dynamic log.
This behavior reveals two subtleties, which we discuss next.
First, this model of side-effects rules out the possibility of
strong updates, or, equivalently, dynamic revocation. Despite
this weakness, as discussed earlier, the monotonic nature of
our model lends itself to verifying properties of extensions that
are interleaved with arbitrary JavaScript code. By ensuring that
all log effects are strictly positive formulas, we ensure that the
effects of unveriﬁed JavaScript cannot undo properties estab-
lished by extensions. This strict positivity condition and its
corresponding monotonic behavior is a characteristic feature
of ࡀ-safety, and our model of side effects is set up to
precisely model this property. Additionally, the robustness of
ࡀ-safety with regard to the effects of JavaScript allows
extension authors (at least from a security standpoint) to be
largely unconcerned with the interleavings of extension code
and JavaScript, which is a signiﬁcant simpliﬁcation of the
programming model.
Second, when programming against this model, intuitions
about the meaning of certain predicates, like EltParent, have to
be adjusted slightly. Speciﬁcally, we must view EltParent as a
many-to-many relation, since, as the example above illustrates,
the element e1 can have more than one parent. As such, our
logical model of the DOM is a graph recording the history of
parent/child relationships between nodes.
C. Safety by typing
The listing below shows a highly simpliﬁed fragment from
FacePalm, code that was presented informally in Section III.
We discuss how this code is veriﬁed against the DOM API.
A simpliﬁed fragment of FacePalm
1prop EltAncestor :: elt  elt  
2assume ࢘e1, e2. EltParent e1 e2  EltAncestor e1 e2
3assume ࢘e1, e2, e3. EltParent e1 e2 && EltParent e2 e3  EltAncestor e1 e3
4assume ࢘(e:elt). CanReadAttr e ‘‘class’’
5assume ࢘(e:elt), (p:elt). (EltAncestor e p && EltTagName p ”div” &&
EltAttr p ”class” ”website”)  CanReadValue e
6
7let extensionCode e =
8
9
10
11
12
13
14
let t = tagName e ‘‘div’’ in
let a = getAttr e ‘‘class’’ in
if t = "div" && a = "website"
then match getChild e 0 with
ࢯ Some c ࢐ Some (getValue c)
ࢯ None ࢐ None
else None
Lines 1–6 above show the policy used with the extension
written in Fine using a collection of assumptions. The policy
deﬁnes a relation EltAncestor, the transitive closure of EltParent,
and at lines 4 and 5, grants the extension the privilege to
1) read the “class” attribute of every element on the page; and
2) to read the contents of any sub-tree in the page rooted at a
div node whose class attribute is “website”.
Lines 7–14 show the code of the extension. At line 8,
the post-condition
the tag t of the element e;
we extract
125
of this function allows the Fine type checker to conclude,
after line 8, that the proposition EltTagName e p is in the dy-
namic log. In order to check the call at line 9, we have to
prove that the pre-condition CanReadAttr e ‘‘class’’ is derivable—
this follows from the top-level assumptions. After line 9,
we can conclude that the fact EltAttr e ‘‘class’’ a is in the dy-
namic log. At line 11, in the then-branch of the conditional,
the type checker uses the types of the equality operation
(=):x: ࢐ y: ࢐ b:boolb=true  x=y and of the boolean operator
(&&):x:bool ࢐ y:bool ࢐ z:boolz=true  x=true && y=true to reﬁne its
information about the contents of the dynamic log. In particu-
lar, the type checker concludes that if control passes to line 11,
then both EltTagName e ‘‘div’’ and EltAttr e ‘‘class’’ ‘‘website’’ are in the
dynamic log, and, using similar reasoning, it concludes that
if control passes to line 12, EltParent e c is in the dynamic log.
Finally, at the call to getValue c at line 12, we need to show
that the pre-condition CanReadValue c is derivable. Given the top-
level assumptions, and all the accumulated information about
the contents of the dynamic log, the theorem prover Fine uses
can establish this fact.
The main formal result of this section is the theorem
below. It states that a program  that is well-typed against an
interface Ɖ (representing the type and value signatures
in the module DOM listing), a set of assumptions representing
a Datalog policy , and a set of ground facts in an abstract
dynamic log ࡀ, is guaranteed to be ࡀ-safe.
Theorem 1 (Type-correct programs are ࡀ-safe): Given
a policy  and its translation to a signature   ;
a dynamic log ࡀ and its translation to an environment
Ɖ  ࡀ; such that  Ɖ  Ɖ is well-formed (i.e.,
  Ɖ  Ɖ). Then, for any assumption-free program 
and type , if  Ɖ  Ɖ    , then  is ࡀ-safe.
Proof: A straightforward extension of the main soundness
result of Fine, as described by Swamy et al. [31], wherein
a reduction relation for Fine is given while accounting for a
dynamic log of assumptions. We extend the core reduction
rules with four additional cases corresponding to (E-StrEq),
(E-GetAttr), (E-SetAttr), and (E-GetCh). In each case, we
show that reduction preserves typing, according the types
given to the primitive operations in Ɖ . Finally, we appeal
to a relation between ﬁrst-order and Datalog derivability,
showing that the former subsumes the latter.
VII. EXPERIMENTAL EVALUATION
We have, to date, written 17 extensions to evaluate our
framework. Some of these extensions are prototypes written
from scratch; others are third-party extensions that we partially
ported and veriﬁed. This section summarizes these exten-
sions, their security policies, and discusses our experience
programming and verifying them in Fine. Our experience
suggests that while authoring extension code is relatively
easy and veriﬁcation times reasonably fast, stating precise
security policies for extensions still demands a non-trivial
amount of work from the programmer. We plan future work to
Name
LOC
# Assumes
Compile (s)
#Z3 q’s
Veriﬁed for access control properties
Magniﬁer
PrintNewYorker
Dictionary lookup
FacePalm
Bib Parser
23
45
70
142
262
1
2
3
5
2
6.0
6.2
6.6
10.7
5.9
Veriﬁed for access control and data ﬂow properties
Password Manager
Twitter Miner
Bing Miner
Netﬂix Miner
Glue Miner
News Personalizer
Search Personalizer
52
36
35
110
101
124
382
2
2
4
17
11
7
12
Partially ported Chrome extensions
Bookmarking
Gmail Checker Plus
JavaScript Toolbox
Short URL Expander
Typography
TOTAL
(6K) 19
(7K) 43
(2K) 19
(494) 22
(20K) 44
1,529
1