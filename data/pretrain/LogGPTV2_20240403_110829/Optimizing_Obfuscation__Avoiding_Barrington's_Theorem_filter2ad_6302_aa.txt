title:Optimizing Obfuscation: Avoiding Barrington's Theorem
author:Prabhanjan Vijendra Ananth and
Divya Gupta and
Yuval Ishai and
Amit Sahai
Optimizing Obfuscation:
Avoiding Barrington’s Theorem
†
Prabhanjan Ananth
†
Divya Gupta
Department of Computer Science and
Center for Encrypted Functionalities,
Department of Computer Science and
Center for Encrypted Functionalities,
UCLA, USA
PI:EMAIL
Yuval Ishai∗
Department of Computer Science,
Technion, Israel
PI:EMAIL
UCLA, USA
PI:EMAIL
Amit Sahai†
Department of Computer Science and
Center for Encrypted Functionalities,
UCLA, USA
PI:EMAIL
Abstract
In this work, we seek to optimize the eﬃciency of secure general-purpose obfuscation schemes.
We focus on the problem of optimizing the obfuscation of Boolean formulas and branching
programs – this corresponds to optimizing the “core obfuscator” from the work of Garg, Gen-
try, Halevi, Raykova, Sahai, and Waters (FOCS 2013), and all subsequent works constructing
general-purpose obfuscators. This core obfuscator builds upon approximate multilinear maps,
where eﬃciency in proposed instantiations is closely tied to the maximum number of “levels” of
multilinearity required.
The most eﬃcient previous construction of a core obfuscator, due to Barak, Garg, Kalai,
Paneth, and Sahai (Eurocrypt 2014), required the maximum number of levels of multilinearity
to be O((cid:96)s3.64), where s is the size of the Boolean formula to be obfuscated, and (cid:96) is the number
of input bits to the formula. In contrast, our construction only requires the maximum number of
levels of multilinearity to be roughly (cid:96)s, or only s when considering a keyed family of formulas,
namely a class of functions of the form fz(x) = φ(z, x) where φ is a formula of size s. This
results in signiﬁcant improvements in both the total size of the obfuscation and the running
time of evaluating an obfuscated formula.
Our eﬃciency improvement is obtained by generalizing the class of branching programs that
can be directly obfuscated. This generalization allows us to achieve a simple simulation of
∗Research supported by the European Union’s Tenth Framework Programme (FP10/2010-2016) under grant agree-
ment no. 259426 ERC-CaC, ISF grant 1361/10, and BSF grant 2012378. Research done in part while visiting UCLA
and the Center for Encrypted Functionalities.
†Research supported in part from a DARPA/ONR PROCEED award, NSF grants 1228984, 1136174, 1118096,
and 1065276, a Xerox Faculty Research Award, a Google Faculty Research Award, an equipment grant from Intel,
and an Okawa Foundation Research Grant. This material is based upon work supported by the Defense Advanced
Research Projects Agency through the U.S. Oﬃce of Naval Research under Contract N00014-11- 1-0389. The views
expressed are those of the author and do not reﬂect the oﬃcial policy or position of the Department of Defense, the
National Science Foundation, or the U.S. Government.
1
formulas by branching programs while avoiding the use of Barrington’s theorem, on which all
previous constructions relied. Furthermore, the ability to directly obfuscate general branching
programs (without bootstrapping) allows us to eﬃciently apply our construction to natural
function classes that are not known to have polynomial-size formulas.
1
Introduction
The goal of general-purpose program obfuscation is to make an arbitrary computer program
“unintelligible” while preserving its functionality. Obfuscation allows us to achieve a powerful
capability: software that can keep a secret. That is, software that makes use of secrets to perform
its computations, but with the additional property that these secrets remain secure even if the
code of the software is captured in its entirety by an adversary. At least as far back as the
work of Diﬃe and Hellman in 1976 [24]1, researchers have contemplated applications of general-
purpose obfuscation. Indeed, if secure general-purpose obfuscation could be cryptographically
achieved eﬃciently, the implications to computer security would be profound [5].
To understand why obfuscation can be so useful, it is instructive to contemplate what kinds
of secrets we might want to hide within our software code. An important instance of such secrets
is hiding the existence and nature of rare input/output behavior that our software may exhibit.
This leads to several interesting motivating scenarios:
• Our software may be a control algorithm that is programmed to enter a failsafe mode
on certain rare and hard-to-predict inputs. We would not want an adversary that gains
access to the code of the control software to be able to learn these rare inputs. By securely
obfuscating the control software, the existence of the failsafe mode itself would be hidden
from the adversary.
• We may modify software to introduce such rare input/output behavior to suit our goals.
Consider the problem of software watermarking, where we want to add an undetectable
imprint to our software that we can later identify. We may do so by modifying the behavior
of our software, so that on several rare and hard-to-predict inputs, it outputs a watermark
code instead of performing its usual computation. An obfuscated version of this modiﬁed
software would hide the existence of these imprints, and thereby also prevent an adversary
from removing them unless the adversary rewrites from scratch almost all of the software.
• So far our examples have dealt with hiding known rare input/output behavior. But ob-
fuscation could also be used to hide the existence of unknown and unintentional rare
input/output behavior: Consider software bugs that are particularly resistant to good-
faith software testing, because the input/output behavior that is aﬀected by these bugs
only arises from inputs that are rare and hard to predict given only the functionality of
the software. Then, obfuscation can be used to hide the existence of such software bugs
(and the vulnerabilities they introduce), even from an attacker that has the code of the
software.
• Finally, turning the previous example around, obfuscation can also be used to hide which
of these software bugs are being ﬁxed by a software patch, thereby preventing adversaries
from learning vulnerabilities from software patches and using this knowledge to attack
unpatched software.
As these motivating scenarios illustrate, secure obfuscation would greatly expand the scope
of security problems addressable through cryptographic means. However, eﬃcient and secure
obfuscation would also have powerful applications to data security, speciﬁcally to protecting
1Diﬃe and Hellman suggested the use of general-purpose obfuscation to convert private-key cryptosystems to
public-key cryptosystems.
2
against data breaches by low-level insiders. Low-level insiders can cause data breaches if they
go rogue, or if their computing systems are compromised through theft or malware attack. As
a result, a critical problem arises when such insiders hold decryption keys – indeed even low-
level insiders may need such keys to perform basic functions. For example, an employee tasked
with generating summaries of ﬁnancial statistics may need decryption keys in order to decrypt
sensitive ﬁnancial spreadsheets. If this decryption key is captured by an adversary, however, it
can be used to steal vast quantities of sensitive information, even though the decryption key
was only meant to allow the insider to generate low-value statistical summaries. Obfuscation,
however, provides a powerful solution to this problem: The decryption keys can be safely hidden
within the statistical summary generation software that is entrusted to the low-level insider.
Then, even if the insider turns rogue, the only power he can derive from his software is the
ability to generate statistics2; he cannot abuse his position to directly decrypt the underlying
ﬁnancial ﬁles.
The above examples provide only a fractional view of the applicability that eﬃcient secure
obfuscation would have to computer security. However, until 2013, even heuristic constructions
for secure general-purpose obfuscation were not known.
This changed with the work of Garg, Gentry, Halevi, Raykova, Sahai, and Waters [28], which
gave the ﬁrst candidate cryptographic construction for a general-purpose obfuscator. Formal
exploration of the applications of general-purpose obfuscation began shortly thereafter [28, 49].
Since then, the ﬂoodgates have opened, and many new applications of general-purpose obfusca-
tion have been explored [10, 13, 44, 12, 1, 42, 7, 34, 9, 45, 29, 32, 3, 17, 39, 30, 35, 14, 15, 27, 21].
Eﬃciency of General-Purpose Obfuscation. This great interest in the utility of obfuscation
leads to a natural and pressing goal: to improve the eﬃciency of general-purpose obfuscation.
Up to this point, the simplest and most eﬃcient proposed general-purpose obfuscator was given
by [4], building upon [28, 15]. However, the general-purpose obfuscator presented in [4] (see
below for more details) remains extremely ineﬃcient.
Our work aims to initiate a systematic research program into improving the eﬃciency of
general-purpose obfuscation. Tackling this important problem will no doubt be the subject of
many research papers to come. We begin by recalling the two-stage approach to general-purpose
obfuscation outlined in [28] and present in all subsequent work on constructing general-purpose
obfuscators:
1. At the heart of their construction is the “core obfuscator” for Boolean formulas (equiv-
alently, NC1 circuits), building upon a simpliﬁed subset of the Approximate Multilinear
Maps framework of Garg, Gentry, and Halevi [26] that they call Multilinear Jigsaw Puzzles.
(We will defer discussion of security to later.)
2. Next, a way to bootstrap from the core obfuscator for Boolean formulas to general cir-
cuits is used. The works of [28, 15, 4] all adopt a method for bootstrapping using Fully
Homomorphic Encryption. This bootstrapping method works provably with the security
deﬁnition of indistinguishability obfuscation, and can rely on well-studied cryptographic
assumptions such as the LWE assumption. Alternatively, the earlier work of Goyal et
al. [33] constructed a universal stateless hardware token for obfuscation that can be im-
plemented by polynomial-size boolean formulas using a pseudorandom function in NC1.
Applebaum [2] gives a simpler alternative construction that has the disadvantage of re-
quiring the size of the Boolean formulas to be polynomial in the input size and the security
parameter (rather than only in the security parameter in [33]). Using either of these alter-
native approaches [33, 2], however, requires an ad-hoc (but arguably plausible) assumption
to bootstrap from obfuscation for Boolean formulas to obfuscation for general circuits.
2Of course, the statistical software itself must be carefully written to avoid vulnerabilities that allow a user to
extract speciﬁc sensitive information by making unexpected statistical queries.
3
Our work focuses on improving the eﬃciency of the ﬁrst of these steps: namely, the core obfus-
cator for Boolean formulas. We give one set of results for the setting of boolean formulas over
the {and, not, or}-basis, and another set of results for general basis.
Previous constructions of a core obfuscator [28, 15, 4] ﬁrst apply Barrington’s theorem [6]
to convert the Boolean formula into an equivalent “matrix branching program,” which is then
obfuscated. Roughly speaking, a matrix branching program computes an iterated product of
n full-rank matrices, where each matrix in the product is determined by one of the input bits,
and the result of the product should be either the identity matrix (corresponding to an output
of 1) or some other ﬁxed full-rank matrix (corresponding to an output of 0). The length of the
program is n and its width is the matrix dimension.
For any circuit or formula of depth d, Barrington’s theorem gives a constant-width matrix
branching program of length 4d. Since the length is exponential in the formula depth, it is
crucial to balance the depth of the formula in order to avoid the exponential blowup. Hence,
the ﬁrst step would be to balance the formula to get a depth which is logarithmic in the size and
then apply Barrington’s theorem. For general formulas of size s, the best known depth obtained
by balancing them is 1.73 log s + d0 by Khrapchenko [37, 36] where d0 is a constant. However,
the constant d0 is quite large, which can have an adverse eﬀect on concrete eﬃciency.3 Instead,
one can balance the formula using a method by Preparata and Muller [48]. The depth of the
balanced formula obtained by this method is 1.82 log s. There have been other works which try
to optimize the size of balanced formulas [11], but the depth of the formula obtained by these
works is worse.
The matrix branching program obtained by applying Barrington’s theorem to a formula of
depth 1.82 log s has length s3.64. This is a major source of ineﬃciency. In particular, the bound
of s3.64 on the length of the branching program not only aﬀects the number of elements given out
as the ﬁnal obfuscation, but also the number of levels of multilinearity required by the scheme.
Since the size of each multilinear encoding grows with the number of levels of multilinearity
required in known realizations of approximate multilinear maps [26, 22], this greatly aﬀects the
size of the ﬁnal obfuscated program and also the evaluation time. Hence, in order to optimize
the size of obfuscation it is critical to ﬁnd an alternative approach.
Our Contributions. In our work, we posit an alternative strategy for obfuscation that avoids
Barrington’s theorem, as well as the need to balance Boolean formulas at all.
In fact, this
strategy can be eﬃciently applied to general (deterministic or even non-deterministic) branching
programs, which are not known to be simulated by polynomial-size formulas. Our strategy
employs variants of randomization techniques that were used in the context of secure multiparty
computation [25, 23], adapting them to the setting of obfuscation.
A crucial ﬁrst step is to formulate a notion of a “relaxed matrix branching program” (RMBP)
which relaxes some of the requirements of matrix branching programs needed in [28, 15, 4]. The
relaxation replaces permutation matrices by general full-rank matrices over a ﬁnite ﬁeld and,
more importantly, determines the output by testing whether some ﬁxed entry in the matrix
product is nonzero. (See Section 2.3 for a formal deﬁnition.) We show how to adapt the con-
struction and security proofs of [4] to work with RMBPs. The eﬃciency of this obfuscation will
be discussed in more detail below. Roughly speaking, given the eﬃciency of current candidate
multilinear encodings, the complexity of obfuscating RMBPs grows quadratically with the width
and cubicly with the length. For now, we will measure eﬃciency in terms of the length and
width of the RMBP.
Armed with the ability to obfuscate RMBPs, we look for simple and eﬃcient ways to convert
Boolean formulas and traditional types of branching programs into RMBPs without invoking
Barrington’s theorem. For this, we can use a previous transformation implicit in [25] towards
3Note that once we apply Barrington’s theorem, d0 goes into the exponent and hence the size of the resulting
obfuscation scheme will incur a factor of 4d0 .
4
converting any ordinary graph-based non-deterministic branching program4 of size s into an
RMBP of length s and width 2(s + 1). We also provide more eﬃcient variants of this trans-
formation that apply to classes of layered branching programs that satisfy certain technical
conditions and arise in natural applications.
The above is already enough for eﬃciently obfuscating functions that are represented by
small branching programs. However, in many cases functions are more naturally represented
by Boolean formulas.
In order to eﬃciently obfuscate formulas, we turn to the (abundant)
literature on simulating formulas by branching programs. In the case of formulas consisting of
only and, or, and not gates, we can use a simple transformation of any such formula of size s
into a branching program of the same size (cf. Theorem 6 in [43] and Appendix B).
The above simple transformation is limited in that it does not directly apply to formulas
with xor gates, and even without such gates its eﬃciency leaves much to be desired. Concretely,
a formula of size s is transformed into an RMBP whose length and width are roughly s and
2s, respectively, leading to a total of O(s3) matrix elements. To get around both limitations
we rely on the work of Giel [31], which builds on previous results of [11, 20] to eﬃciently
transform a formula over the full basis to a layered branching program of constant width. The
layered branching program described in [31] satisﬁes our conditions and can be used to obfuscate
formulas over the full set of binary gates. Concretely, a formula of size s can be transformed
into an RMBP of length O(s1+), for an arbitrarily small constant  > 0, and constant width
(depending only on ).
As in previous obfuscation techniques [28, 15, 4], a direct application of the above methods
reveals the order in which input variables are read. Thus, to obfuscate a class of branching
programs or formulas which may read the inputs in a varying order, we (as well as previous
works) need to apply an additional step to make the RMBP family input-oblivious. This incurs