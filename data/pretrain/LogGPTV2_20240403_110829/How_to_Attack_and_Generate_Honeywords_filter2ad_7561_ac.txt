TABLE II
Language When leaked Total PWs With PII
BASIC INFO ABOUT OUR 10 PASSWORD DATASETS.†
Web service
Dataset
Chinese Dec., 2011 30,901,241
Social forum
Tianya
Chinese Dec., 2011 16,258,891
E-commerce
Dodonew
Chinese Dec., 2011 6,428,277
Programmer
CSDN
July, 2015 1,074,742
Chinese
Mango
E-commerce
English Dec., 2009 32,581,870
Social forum
Rockyou
Oct., 2015 15,251,073
English
000webhost Web hosting
442,834
English
July, 2012
Web portal
Yahoo
129,303 X
Chinese Dec., 2014
Train ticketing
12306
Sep., 2016 2,222,045 X
ClixSense
Paid task platform English
69,418 X
Rootkit
English
Hacker forum
Feb., 2011
79,580 X
QNB∗
English April, 2016
E-bank
†PW stands for password, PII for personally identiﬁable information.
∗QNB passwords are from e-Bank and used as high-value targets.
TABLE III
Types of PII useful for this work
BASIC INFORMATION ABOUT OUR PII DATASETS.†
Language
Items num
20,051,426 Name, Birthday, Phone, NID∗
Chinese
Email, Name, Birthday, Phone
2,327,571
Chinese
Email, User name, Name, Birthday,
Chinese
129,303
Phone, NID
Email, User name, Name, Birthday
2,222,045
English
Email, User name, Name, Birthday
79,580
English
Email, User name, Name, Birthday,
English
77,799
Phone, NID
Dataset
Hotel
51job
12306
ClixSense
Rootkit
QNB
† NID=National identiﬁcation number, e.g., social security number.
Generating honeywords. Since probabilistic password mod-
els can produce a set of passwords (usually called guesses)
with probabilities, honeywords can be generated by uniformly
sampling from this probability space. For the List model,
we directly sample from this set of guesses; For other more
complex models, it is computationally prohibitive to explicitly
generate this set of guesses and then directly sample from it.
Instead, we sample from the interim probabilistic products
by using inverse CDF. Take PCFG [58] for an example.
We ﬁrst use the inverse CDF to (uniformly) sample from
Pr(S→·) to obtain the base structure L7D3, and then similarly
obtain segments wanglei from Pr(L7→·) and 123 from
Pr(D3→·), respectively. For hybrid models, we ﬁrst determine
which password model to be used according to their weights,
and then perform inverse CDF sampling on the selected model.
For targeted models (e.g., TarPCFG [56]), we ﬁrst similarly
obtain samples which contain PII tags, and then substitute
the tags with user PII. For example, for user “John Smith”,
sampling from TarPCFG may ﬁrst produce the interim item
N2123. Then, by replacing the family name tag N2 with
his family name Smith, we obtain the ﬁnal honeyword
Smith123. For concrete examples of generated honeywords,
see the bottom of Fig. 1. Our constructions in Sec. IV follow
this basic idea, but further address a number of challenges.
E. Our datasets and ethics consideration
We evaluate the existing honeyword methods and our pro-
posed ones based on 11 large real password datasets (see
Table II and Table III), a total of 105.44 million passwords.
Our password datasets include four from English sites and
ﬁve from Chinese sites. For better comparison, these datasets
except Mango are the same with [53].
Particularly, four of our password datasets (i.e., 12306,
ClixSense, Rootkit and QNB) are associated with various
kinds of PII. To enable extensive targeted attacks, we ob-
tain nine PII-associated password datasets (see Table IV) by
matching the non-PII-associated password datasets with these
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:19:56 UTC from IEEE Xplore.  Restrictions apply. 
970
BASIC INFO OF OUR NINE PII-ASSOCIATED PASSWORD DATASETS THAT ARE CONSTRUCTED BY MATCHING EMAIL.
TABLE IV
Dataset name
Size
PII-Dodonew
161,517
PII-12306
129,303
PII-CSDN
77,216
PII-Rootkit
69,330
PII-000webhost
153,390
PII-ClixSense
2,222,045
PII-Yahoo
16,307
PII-QNB
77,799
PII-associated ones through email. As the canonical dataset
Rockyou only consists of passwords (with no user names or
emails), it will not be used when evaluating targeted threats.
For more information about our datasets, see Appendix A.
For ethical considerations, we only present the aggregated
statistical information and protect each individual account as
conﬁdential. All our datasets are stored and processed on
computers not linked to the Internet. In addition, recovered
password hashes are deleted once the data analysis is com-
pleted, though it is likely that attackers would have already
cracked most of them [8], [29]. Our measures can secure the
recovered passwords just in case when we have cracked some
hashes that attackers have not, ensuring that no new risks is
brought to victim users. While attackers may exploit these
datasets for misconduct, our use is both beneﬁcial for the
academic community to understand honeyword choices and
for security administrators to timely detect password leaks.
As our datasets are all publicly available from the Internet,
this work is reproducible.
III. OUR ATTACKING THEORIES
We now propose a series of theoretic models for charac-
terizing the attacker A’s best attack strategies in telling apart
the real password from a set of honeywords. Each of these
models is based on varied kinds of information available to
A (Table I). Particularly, we are the ﬁrst to consider quite
realistic attackers who know user registration order. These
models guide us to design effective experiments with real
datasets to evaluate a given honeyword method.
A. Theoretical attacking models
As implied in Sec. II-B, there are two main goals of the dis-
tinguishing attacker A: (1) Global goal—identifying real pass-
words from a given password ﬁle F composed of n sweetword
lists {SW1, SW2, . . . , SWn}, where SWi=(swi;1, . . . , swi;k),
1 ≤ i ≤ n; and (2) Local goal—identifying the real password
from a given sweetword list SWi of user Ui. Since A can at
most make T2 overall failed attempts for the system and T1
failed attempts per user, to achieve each goal she needs to try
these most probable sweetwords ﬁrst.
Basic idea. We ﬁrst show that A’s two goals can be best
achieved by using the same attacking strategy. Next, by ana-
lyzing and exploiting various properties of the two categories
of honeyword methods, we formulate what a basic attacker
A1’s optimal strategy is. Finally, we extend the best attacking
strategy for A1 to the other three types of attackers A2∼A4.
Theorem 1: Let pwi;j (1 ≤ j ≤ k) denote the event that Ui
selects swi;j as her real password, and hwi;t denote the event
that swi;t is produced as a honeyword for Ui. We have
l̸=t Pr(hwi;l|pwi;t)
∏
l̸=j Pr(hwi;l|pwi;j)
Pr(pwi;j)
k
t=1 Pr(pwi;t)
|SWi) =
∑
∏
Pr(pwi;j
(1)
,
under the assumption that hwi;1, . . . , hwi;j−1, hwi;j+1, . . . ,
hwi;k are mutually independent under the event pwi;j.1
The detailed proof can be found in Appendix C. This
|SWi) can be computed if
theorem indicates that Pr(pwi;j
and Pr(hwi;t|pwi;j)
are known. Fortunately,
Pr(pwi;j)
Pr(pwi;j) can be obtained by using various password models
(e.g.,
the List model—directly from a leaked password
dataset), and Pr(hwi;t|pwi;j) can be obtained by analyzing
the properties of a given honeyword method.
that
the ﬁle F is
produced as the password-ﬁle for all users, and the other
deﬁnitions comply with those in Theorem 1. We have
Theorem 2: Let F denote the event
|F ) = Pr(pwi;j
|SWi),
Pr(pwi;j
(2)
under the assumptions that users independently create pass-
words, and the assumptions of Theorem 1.
The detailed proof can be found in Appendix C. This
theorem indicates that, ﬁnding the most probable password
in SW1, . . . , SWn can be reduced into ﬁrst ﬁnding the most
probable password within each sweetword list and then ranking
these candidate passwords. In this light, attacker A’s two goals
can be essentially achieved using the same attacking strategy.
We now summarize four properties that a honeyword
method may have. These properties can be used to classify
existing honeyword methods into two cases, and then we
simplify the computation of Eq. 1 for each case. The domain
of sweetwords is by default Dpw, the entire password space.
Let T (x) denote the sweetword space of x, that is, the set of
sweetwords obtainable from password x. We deﬁne:
P1: ∀sw1∀sw2, sw1 ∈ T (sw2) =⇒ T (sw1) = T (sw2).
This property states that any sweetword can generate
any other sweetword in a sweetword list. This is a
desirable property to achieve, because suppose swi;j ∈
SWi cannot generate some sweetwords that appear in
the list SWi, then it is certain that swi;j will not be the
real password. Otherwise, a paradox arises. The attacker
A can thus easily eliminate some non-real passwords
like swi;j without trying to log in. To formalize, this
property indicates that ∀t, T (swi;t) = T (swi;1), and
∀t,∀l ̸= t, Pr(hwi;l|pwi;t) ̸= 0.
Pr(hw3|pw1) = Pr(hw3|pw2).
This property states that every sweetword can be gener-
ated by any candidate password with equal probability.
All honeyword-generation methods we discuss satisfy
P1 and P2. For example, under t = 2 tweaking-
tail method, the probabilities of sweetword lovea0
conditioned on password being respectively loveu1
and lovee0 are the same.
P2: ∀sw1∀sw2,∀sw3 ∈ T (sw1) ∩ T (sw2),
1Note that, the assumptions in Theorem 1 comply with the fact that
the events hwi;1, . . . , hwi;j−1, hwi;j+1, . . . , hwi;k may be dependent
or independent on the event pwi;j.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:19:56 UTC from IEEE Xplore.  Restrictions apply. 
971
P3: 8sw1,8sw28sw3 2 T (sw1), Pr(hw2jpw1) = Pr(hw3jpw1).
This property states that every sweetword generates
all sweetwords in its sweetword space with the same
probability. All non-password-model based methods we
discuss here (e.g., tweaking-tail) satisfy this property.
P4: ∀sw1∀sw2∀sw3, Pr(hw3|pw1) = Pr(hw3|pw2).
This property states that honeywords are unrelated with
the real password; when combined with property P1, it
indicates that ∀pw, T (pw) = Dpw.
Case 1. For these methods (i.e., all of non-password-model
based methods, like tweaking-tail [35]) that satisfy the prop-
erties P1∼P3, it follows that ∀i∀j,∀l ̸= j, Pr(hwi;l|pwi;j) ≡ c,
where c > 0 is a constant. Now, we can derive
Pr(pwi;j
|SWi) =
Pr(pwi;j)
k
t=1 Pr(pwi;t)
,
(3)
∑
where both Pr(pwi;j) and Pr(pwi;t) can be obtained by using
various password models (e.g., List, PCFG-based [58]).
Eq. 3 fundamentally explains why the “normalized top-
PW” attacking strategy in Sec. 3.2 of [53] is effective: This
strategy accords with our above theory and is the optimal one
against Juels-Rivest’s four methods [35]. It in turn suggests
that, for these honeyword methods in [35] to achieve 1
k -ﬂat
(i.e., to be perfect), all k sweetwords in the list SWi shall
have an equal probability to be selected as Ui’s real password
PWi. In other words, given the real password PWi, a real-
password related method needs to produce k − 1 honeywords
with equal probability to be Ui’s password as P Wi a priori.
This is inherently unachievable due to the fact that user-chosen
passwords follow the Zipf’s law [52]: pr = C · rs- C · (r− 1)s
≈ C · s · rs−1, where pr denotes the probability of the rth
popular password, and s∈[0.15, 0.30] and C∈[0.001, 0.1] are
constants. As pr decreases sharply with r when r is small, it is
difﬁcult to ﬁnd suitable honeywords for relatively popular real
passwords. This outlines the need for new design techniques
beyond the real-password related ones.
Case 2. For methods (e.g., Honeyindex [24] and all our meth-
ods) that comply with the properties P1, P2 and P4, it follows
that ∀sw1, sw2, sw3 ∈ Dpw, Pr(hw3|pw1) = Pr(hw3|pw2).
For simplicity, we write Pr(hw3|pw1) as PrHW(sw3), which
means that the probability of producing sw3 as a sweetword
only depends on the underlying honeyword method HW . Sim-
ilarly, we use PrPW(sw1) to denote Pr(pw1): The probability
of selecting the string sw1 as a real password. Now, we can
simplify Eq. 1 to be:
Pr(pwi;j
|SWi) =
,
(4)
∑
PrPW(swi;j )
PrHW(swi;j )
k
t=1
PrPW(swi;t)
PrHW(swi;t)
where both PrPW(swi;j) and PrPW(swi;t) can be obtained by
using various password models (e.g., List and Markov-based
[40]), and both PrHW(swi;j) and PrHW(swi;t) can be com-
puted by the corresponding honeyword-generation method.
Eq. 4 points out how to best attack all our honeyword-
generation methods, in which honeywords are independent
of the user’s real password. It