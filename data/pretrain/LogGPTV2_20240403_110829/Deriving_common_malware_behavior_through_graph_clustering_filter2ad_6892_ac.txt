### 注入无关系统调用

注入无关的系统调用不会影响恶意软件的恶意行为，但会试图掩盖其行为。为了测量这些注入的系统调用对所提方法检测恶意软件能力的影响，我们进行了一项实验。

在该实验中，从良性（非恶意）应用程序执行过程中获取了不同长度的系统调用跟踪，并将这些复制的跟踪随机插入到恶意软件实例的系统调用跟踪中。复制的系统调用量从原始恶意软件系统调用跟踪长度的0%到100%不等。随后，训练集中的显著修改后的（注入的）恶意软件系统调用跟踪与预生成的加权公共行为图 (WCBG) 进行匹配。

**图5：针对系统调用注入攻击的检测率。（(cid:2)=0.5, (cid:13) = 0.7）**

图5展示了实验结果。只有实际受到系统调用攻击影响的家族被显示在图中。除了Allaple家族外，Bagle、Netsky和Mytob家族未受系统调用攻击的影响，因此未在图中展示。对于受影响的家族，检测率随着攻击率的增加而下降。然而，当注入率达到50%时，检测率的下降趋于平稳；即使注入率进一步增加至100%，检测率也不再变化。在40%的注入率下，这些家族的检测率大约降低了30%。

### 阈值选择

所提方法有两个参数：(cid:2)（影响共同行为图的大小）和(cid:13)（控制恶意软件检测的敏感度）。由于HotPath在不同的(cid:2)值下保持不变，系统的性能不受(cid:2)值的显著影响。(cid:13)的值是通过实验选定的，在这个值处，检测率的变化不大。根据第3节的实验结果，(cid:2)应位于0.2到0.5之间，而(cid:13)应在0.5到0.9之间。

### 其他特性

我们还进行了一项实验，以研究用于构建共同行为图的二进制文件数量对其大小的影响。这表明了共同行为图的可扩展性取决于添加的二进制文件数量。结果显示，无论是共同行为图的大小还是HotPath的大小，几乎没有变化。此外，系统调用跟踪的开销主要取决于恶意软件分析框架，本例中使用的是Ether。与其他基于动态行为的恶意软件检测方法相比，如果仅检查系统调用跟踪，则系统开销可以忽略不计[17, 27]。行为图构建的开销非常小（0.1秒或更少）。由于篇幅限制，详细信息省略。

### 相关工作

行为基恶意软件检测可以通过静态分析或动态分析实现。

多年来，已经提出了使用静态反汇编进行恶意软件分析和检测的方法。通过静态分析恢复的行为被解释为程序的“语义”。现有方法使用控制流和数据流分析、语义、抽象模型和描述恶意程序行为的模板[13, 25, 7, 14, 18, 29]。静态分析的有效性取决于正确反汇编二进制文件的能力，这对于打包代码来说是一个问题[11, 26]。

通过监控运行程序的执行来检测恶意软件是一种克服静态分析局限性的有效解决方案[5, 22]。为此，最近开发了几个分析平台[26, 11, 28]。Panorama[28]通过模拟恶意代码来捕获基于网络接口或键盘污染源的系统级信息流。Malspecs[6]通过使用系统调用调用来提取不同于良性程序的恶意行为。基于指令跟踪和内存日志中的污染信息，Inspector Gadget[16]利用动态程序切片提取当前在恶意软件中使用的域生成算法。

尽管这些方法通过污染跟踪有效地检测恶意软件，但它们需要执行模拟，并导致显著的性能开销[17]。Kolbitsch等人[17]提出了一种基于系统调用行为图的有效且高效的恶意软件检测方法，该方法使用动态程序切片。该模型捕获感兴趣系统调用之间的数据流依赖关系。通过使用精心设计的模型，他们的方法可以在终端主机上进行检测，而无需进行污染分析。此外，操作系统级别的内核对象也被用于分析恶意行为以进行恶意软件分类[2, 1]。相比之下，我们的方法仅使用系统调用跟踪来表示内核对象之间的关系。这种关系以共同图的形式展示，这是一种全新的低开销且高可扩展性的恶意软件检测方法。

### 结论

本文提出了一种新的基于内核对象行为图 (KOBG) 检测恶意软件实例的方法。该方法使用内核对象行为来指定恶意软件的行为，而不是依赖于系统调用。同一家族的多个恶意软件实例的KOBGs被合并成一个加权公共行为图 (WCBG)，其中包括一个特殊子图HotPath，该子图出现在所有家族实例中。所提方法实现了高检测率和非常低的误报率。

这项工作的局限性与其他使用动态分析的方法相同，即只能观察可执行文件的部分行为。使用各种技术探索大多数或所有可能的执行路径[4, 21]可以提高这种方法的准确性，但代价是更大的开销。

### 参考文献

[此处省略具体参考文献，详见原文]

希望优化后的文本更加清晰、连贯和专业。如果有任何进一步的问题或需要更多的修改，请告诉我！