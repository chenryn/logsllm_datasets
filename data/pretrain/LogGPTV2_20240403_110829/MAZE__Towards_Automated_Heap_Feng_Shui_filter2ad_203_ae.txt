are reduced to about 10 symbolized paths, as shown in column
3. The average rate of path simpliﬁcation is 98.4%.
Among these symbolized reentrant paths, MAZE further
analyzes these primitives’ dependency. Some primitives are
independent from others, as shown in column 4. Column 5
shows the number of primitives that depend on others and can
be analyzed by MAZE.
Primitive
Count
Noise
Count
Constraint
Count
D.a.F
Time
Program
sword
hacknote
fheap
main
cat
asvdb
note3
stkof
Table 4: Result of primitives assembly on CTF programs.
Solve
Time
1109
406
3945
1046
1013
3105
2600
1143
2805
7646
4974
1676
946
2034
2779
375
POC
Time
26
14
38
26
42
22
29
33
24
8
31
22
80
33
198
21
babyheap
secret...
Mem0
Secure...
quotes...
freenote
RNote2
databank
4
32
17
24
3
3
2
4
9
10
10
5
3
6
8
2
5
58
26
41
30
6
9
19
14
18
16
6
15
12
14
2
0
1
1
1
2
2
0
0
0
0
0
0
0
0
1
0
1
1
1
1
1
1
2
3
2
3
2
2
2
1
2
1
The last column shows the total time interval used for ex-
tracting and analyzing these primitives. MAZE could ﬁnish
analyzing all 16 programs in several minutes. The average
time cost is 9.4 minutes (562.7 seconds).
6.2.4 Efﬁciency of Primitives Assembly
Table 4 shows the evaluation result of the heap layout prim-
itives assembly process. Column 2 shows the total number of
available primitives, different from the number of symbolized
paths listed in Table 3. MAZE will analyze the semantics of
each symbolized path, and remove paths that cannot be used
as primitives. It also analyzes the size of heap operations, and
may yield multiple primitives for one symbolized path (with
different allocation size). As shown in the table, MAZE could
ﬁnd at least 2 primitives for all 16 programs.
Some primitives may have more than one allocations and
deallocations. The extra noise (de)allocations could cause
trouble for heap layout manipulation, as argued in previous
work, e.g., SHRIKE and Gollum. Column 3 shows the average
number of noises in these primitives.
Column 4 shows the number of heap layout constraints
to satisfy. There are 8 programs with one constraint. All of
them have UAF or double free vulnerabilities, requiring to
place one object at one location. Another 8 programs with two
constraints all have buffer overﬂow vulnerabilities, requiring
to place the vulnerable objects as well as the victim objects at
proper locations. The other 2 programs requires three object
constraints to facilitate unlink attacks.
The last three columns are the time cost, including the time
used by the Dig & Fill algorithm (distance evaluation and
equation solving), by POC analysis (vulnerability analysis and
instrumentation points analysis), and by constraint solving
(satisfying the ﬁnal edited path). All steps are relatively fast,
except the last constraint solving step, due to challenges to
symbolic execution (e.g., loops and symbolic addresses).
6.3 PHP Benchmarks
To compare with existing solutions Shrike[8] and
Gollum[9], we chose PHP as a real world target to evalu-
USENIX Association
30th USENIX Security Symposium    1657
Table 5: Evaluation results of different solutions on PHP.
POC analysis time(s)
Solution
922s
Maze
Not Supported
Shrike
Gollum
Not Supported
Solve time(s)
100% in 68s
25% in 300s, 60% in 3000+s
75% in 300s, 85% in 2500+s
Succ
100%
60%
85%
ate. To trigger all the 5 vulnerabilities, we selected version
7.0.4. The evaluation result is shown in Table 5.
As shown in the second column, MAZE is much faster than
Shike and Gollum. MAZE has solved all the benchmarks in 68
seconds. The average time consumption is only 27 seconds.
Shrikes spent 300 seconds to solve 25% of them, and spent
more than 3000 seconds to solve 60% of the benchmarks.
Gollum solved 75% in 300 seconds and took more than 2500
seconds to solve 85%.
Further, MAZE can solve all the benchmarks. As a compar-
ison, Shrike can only solve 60% of them, and Gollum solved
85%. After a more in-depth analysis, we ﬁgured out SHRIKE
and Gollum failed mostly because of noises in heap primitives.
Speciﬁcally, for CVE-2016-7126, the source buffer for this
vulnerability is of size 0x20. There are many objects of size
0x20 in PHP, causing many noises in the POC path and the
heap primitives and lowering the success rate of SHRIKE and
Gollum. MAZE utilizes Linear Diophantine Equation to
bypass the noise problem, regardless of the fact that all primi-
tives have at least one noise.
Thirdly, both Shrike and Gollum need a template provided
by security experts, to guide where to insert memory alloca-
tions and deallocations, as well as the allocation size. But
MAZE is fully automated. It can analyze the POC and deter-
mine the layout state, as well as whether ﬁll or dig operations
are needed and where are the suitable instrumentation points.
Table 6: Evaluation results on Python and Perl.
Target
Python
Perl
Vulnerabilities
24094
CVE-2007-4965, 2014-1912, Issue24105, 24095,
Issue132544, 130703, 130321, 129024, 129012
Average time(s)
100% in 118s
100% in 141s
6.4 Python and Perl Benchmarks
To further evaluate the effectiveness, we also evaluated
MAZE on Python and Perl. We chose 10 vulnerabilities in
Python and Perl, and showed the evaluation result in Table 6.
Compared with Gollum [9], MAZE supports both Python
and Perl. It demonstrates that MAZE broadly extends the
application scope of Gollum. What’s more, as shown in the
third column, MAZE can generate expected heap layouts for
all the vulnerabilities, and is much faster than Gollum.
6.5 Synthetic Benchmarks
We further utilize synthetic benchmarks to perform ﬂexi-
ble and scalable evaluation of the Dig & Fill algorithm, to
discover factors that can inﬂuence its performance.
To compare with other algorithms, we extended SHRIKE’s
benchmark with some modiﬁcations so that it can be adapted
Figure 6: Inﬂuences of different number of noises.
to MAZE. First, MAZE generates heap layout primitives ran-
domly, each primitive contains variable amount of allocation
or deallocation operations (i.e., noises). Then, MAZE com-
bines these primitives randomly to derive the initial heap
layout. Third, MAZE randomly selects some memory holes
and allocation operations, expecting a layout that the selected
allocation operation takes the selected memory hole. Finally,
MAZE utilizes Dig & Fill algorithm to calculate a heap
interaction sequence to yield the expected layout.
6.5.1 Benchmark Setup
Besides the layout noise, we also tested other parameters
that may affect the success rate of heap layout manipulation.
• Noise number: It’s the minimum amount of noise opera-
tions placed in each primitive. Primitives could have more
noises than this threshold.
• (De)allocation primitives count: It’s the number of ran-
domly generated primitives for heap (de)allocation. This
factor represents the diversity of primitives.
• Size list: It represents the diversity of the size of allocation
operations in a primitive. Allocation operations in each
primitive will select one size from this list. The probability
of selecting each size is also adjustable.
• Mix of allocation and deallocation: It indicates that the
relative rate of heap allocation and deallocations in one
primitive. If this factor is None, each primitive can only
contain allocations or deallocations, but not both.
6.5.2 Evaluation of One-Object Layout Constraint
As aforementioned, a multi-object layout constraint can be
transformed into multiple one-object layout constraints. So
we will fully evaluate one-object layout constraint at ﬁrst.
Factors Inﬂuencing Success Rate. SHRIKE demon-
strated that the noise impacts the success rate. For instance,
a single noisy allocation can make the success rate drop to
50% across all allocators. But as discussed in Section 5, the
diversity of heap layout primitives is the major factor that
inﬂuences the success rate of Dig & Fill, not the number of
noise. We will prove this with a concrete experiment.
Inﬂuence of noise count. First, we evaluated the success
rate of Dig & Fill using primitives with different noise
count. In this evaluation, the noise number ranges from 2
1658    30th USENIX Security Symposium
USENIX Association
234567Noise number0.980.991.00Success ratedl_malloc_succ_ratept_malloc_succ_ratedl_malloc_timept_malloc_time5090130170Time interval(s)Table 8: Results of multi-object layout constraint evaluation.
Target
PT
PT
PT
PT
Object count
2
3
4
5
Time (s)
73.1
95.2
145.6
238.8
Success rate
98.0%