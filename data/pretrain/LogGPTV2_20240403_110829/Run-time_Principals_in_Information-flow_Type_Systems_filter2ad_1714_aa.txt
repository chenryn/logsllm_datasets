title:Run-time Principals in Information-flow Type Systems
author:Stephen Tse and
Steve Zdancewic
Run-time Principals in Information-ﬂow
Type Systems
STEPHEN TSE and STEVE ZDANCEWIC
University of Pennsylvania
Information-ﬂow type systems are a promising approach for enforcing strong end-to-end conﬁ-
dentiality and integrity policies. Such policies, however, are usually speciﬁed in terms of static
information—data is labeled high or low security at compile time. In practice, the conﬁdentiality
of data may depend on information available only while the system is running.
This paper studies language support for run-time principals, a mechanism for specifying security
policies that depend on which principals interact with the system. We establish the basic property
of noninterference for programs written in such language, and use run-time principals for specifying
run-time authority in downgrading mechanisms such as declassiﬁcation.
In addition to allowing more expressive security policies, run-time principals enable the inte-
gration of language-based security mechanisms with other existing approaches such as Java stack
inspection and public key infrastructures. We sketch an implementation of run-time principals
via public keys such that principal delegation is veriﬁed by certiﬁcate chains.
Categories and Subject Descriptors: D.3.3 [Programming Languages]: Language Constructs
and Features
General Terms: Design, Languages, Security
Additional Key Words and Phrases: decentralized label model, dynamic principals, information-
ﬂow, noninterference, run-time principals, security-typed language, soundness, type systems
Stephen Tse (PI:EMAIL) and Steve Zdancewic (PI:EMAIL).
Authors’ address: 3330 Walnut Street, Computer and Information Science Dept., University of
Pennsylvania, Philadelphia, PA 19104, US.
An earlier version of this paper with the same title appears in IEEE Symposium on Security and
Privacy, 2004 [Tse and Zdancewic 2004].
Permission to make digital/hard copy of all or part of this material without fee for personal
or classroom use provided that the copies are not made or distributed for proﬁt or commercial
advantage, the ACM copyright/server notice, the title of the publication, and its date appear, and
notice is given that copying is by permission of the ACM, Inc. To copy otherwise, to republish,
to post on servers, or to redistribute to lists requires prior speciﬁc permission and/or a fee.
c(cid:13) 2004 ACM 0164-0925/99/0100-0111 $0.75
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year, Pages 1–44.
·
2
Contents
Stephen Tse and Steve Zdancewic
1 Introduction
2 Decentralized label model
2.1 Principals and labels . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Acts-for hierarchy . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Label lattice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3 Run-time principals
3.1 Dynamic semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Static semantics
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 Noninterference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4 Declassiﬁcation and authority
4.1 Run-time authority and capabilities
. . . . . . . . . . . . . . . . . .
4.2 Endorsement and delegation . . . . . . . . . . . . . . . . . . . . . . .
4.3 Acquiring capabilities
. . . . . . . . . . . . . . . . . . . . . . . . . .
5 Type-safety
5.1 Progress . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2 Preservation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6 PKI and application
6.1 Public key infrastructures . . . . . . . . . . . . . . . . . . . . . . . .
6.2 Application to distributed banking . . . . . . . . . . . . . . . . . . .
7 Discussion
7.1 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.2 Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A Full syntax of λRP
2
4
4
5
6
7
9
12
13
20
21
27
28
29
29
32
35
35
37
39
39
41
43
INTRODUCTION
1.
Information-ﬂow type systems are a promising approach for enforcing strong end-
to-end conﬁdentiality and integrity policies [Sabelfeld and Myers 2003]. However,
most previous work on these security-typed languages has used simplistic ways of
specifying policies: the programmer speciﬁes during program development what
data is conﬁdential and what data is public. These information-ﬂow policies con-
strain which principals have access either directly, or indirectly, to the labeled data.
In practice, however, policies are more complex—the principals that own a piece
of data may be unknown at compile time or may change over time, and the security
policy itself may require such run-time information to downgrade conﬁdential data.
This paper addresses these shortcomings and studies run-time principals in the
context of information-ﬂow policies.
Run-time principals are ﬁrst-class data values representing users, groups, etc.
During its execution, a program may inspect a run-time principal to determine
policy information not available when the program was compiled. The key problem
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
Run-time Principals in Information-ﬂow Type Systems
·
3
is designing the language in such a way that the dynamic checks required to imple-
ment run-time principals introduce no additional covert channels. Moreover, while
adding run-time principals permits new kinds of security policies, the new policies
should still interact well with the static type checking.
Run-time principals provide a way of integrating the policies expressed by the
type system with external notions of principals such as those found in public key
infrastructures (PKI). This integration allows language-based security mechanisms
to interoperate with existing machinery such as the access control policies enforced
by a ﬁle system or the authentication provided by an OS.
This paper makes the following three contributions:
—We formalize run-time principals in a simple security-typed language based on
the λ-calculus and show that the type system enforces noninterference, a strong
information-ﬂow guarantee. This type system is intended to serve as a the-
oretical foundation for realistic languages such as Jif [Myers et al. 1999] and
FlowCaml [Simonet 2003].
—We consider the problems of downgrading and delegation in the presence of run-
time principals and propose the concept of run-time authority to temper their use.
Declassiﬁcation, and other operations that reveal information owned by a run-
time principal, may only be invoked when the principal has granted the system
appropriate rights. These capabilities must be veriﬁed at runtime, leading to a
mechanism reminiscent of (but stronger than) Java’s stack inspection [Wallach
and Felten 1998; Wallach et al. 2000].
—We investigate the implementation of run-time principals via public key infras-
tructures. Run-time principals are represented by public keys, run-time authority
corresponds to digitally signed capabilities, and the delegation relation between
principals can be determined from certiﬁcate chains.
As an example of an information-ﬂow policy permitted by run-time principals,
consider this program that manipulates data conﬁdential to both a company man-
ager and to less privileged employees:
1
2
3
4
5
6
7
8
class C {
final principal user = Runtime.getUser();
void print(String{user:} s) {...}
void printIfManager(String{Manager:} s) {
actsFor (user, Manager) {
}
print(s);
}}
This program, written in a Java-like notation, calls the print routine to display
a string on the terminal. The run-time principal user, whose value is determined
dynamically (Runtime.getUser), represents the user that initiated the program.
Note that, in addition to ordinary datatypes such as Java’s String objects, there
is a new basic type, principal; values of type principal are run-time principals.
Lines 3-4 illustrate how information-ﬂow type systems constrain information-
ﬂows using labels. The argument to the print method is a String object s that
has the security label {user:}. In the decentralized label model [Myers and Liskov
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
·
4
Stephen Tse and Steve Zdancewic
1998; 2000], this annotation indicates that s is owned by the principal user and
principals that act for user, and that the policy of user is that no other principals
can read the contents of s. This policy annotation might be appropriate when the
Strings passed to the print method are output on a terminal visible to the princi-
pal user. More importantly, conﬁdential information such as Manager’s password,
which user is not permitted to see, cannot be passed to the print method (either
directly or indirectly). Here, Manager is a principal constant (a ﬁxed value deter-
mined at compile time), and user is a principal variable (a dynamic value to be
determined at run time). The type system of the programming language enforces
such information-ﬂow policies at compile time without run-time penalty.
The printIfManager method illustrates how run-time principals can allow for
more expressive security policies. This method also takes a String as input but,
unlike print, requires the string to have the label {Manager:}, meaning that the
data is owned and readable only by the principal Manager and principals that act for
Manager. The body of this method performs a run-time test to determine whether
the user principal that has initiated the program is in fact acting for the Manager
principal. If so, then s is printed to the terminal, which is secure because the user
has the privileges of Manager. Otherwise s is not printed. Without such a run-time
test, an information-ﬂow type system would prevent a String{Manager:} object
from being sent to the print routine because it expects a String{user:} object.
Run-time principals allow such security policies that depend on the execution en-
vironment.
Although this example has been explained in terms of Java-like syntax, we carry
out our formal analysis of run-time principals in terms of a typed λ-calculus. This
choice allows us to emphasize the new features of run-time principals and to use
established proof techniques for noninterference [Heintze and Riecke 1998; Abadi
et al. 1999; Pottier and Simonet 2002; Zdancewic and Myers 2002]. It should be
possible to extend our results to Java-like languages by using the techniques of
Banerjee and Naumann [2002; 2003].
The rest of the paper is organized as follows. The next section introduces the
decentralized label model as the background of our development. Section 3 de-
scribes our language with run-time principals, including its type system and the
noninterference proof. Section 4 considers adding declassiﬁcation in the context of
run-time principals. Section 5 contains the detailed proof of type-safety for the full
language. Section 6 suggests how the security policies admitted by our language
can be integrated with traditional public key infrastructures and gives an extended
example. The last section discusses related work and conclusions.
2. DECENTRALIZED LABEL MODEL
The security model considered in this paper is a version of the decentralized label
model (DLM) developed by Myers and Liskov [1998; 2000]. However, the labels in
this paper include integrity constraints in addition to conﬁdentiality constraints,
because integrity constraints allow robust declassiﬁcation (see Section 4).
2.1 Principals and labels
Policies in the DLM are described in terms of a set of principal names. We use
capitalized words like Alice, Bob, Manager, etc., to distinguish principal names
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
Run-time Principals in Information-ﬂow Type Systems
·
5
from other syntactic classes of the language. We use meta-variable X to range over
such names.
To accommodate run-time principals, it is necessary to write policies that refer to
principals whose identities are not known statically. Thus, the policy language in-
cludes principal variables, ranged over by α. Principal variables may be instantiated
with principal names, as described below. In the example from the introduction,
Manager is a principal name and the use of user in the label is a principal variable.
We also need sets of principals, s, written as (unordered) comma-separated lists of
principals. The empty set (of principals and other syntactic classes), written ‘·’,
will often be elided. In summary:
p ::= X | α
s ::= ·
| p, s
Using principals and principal sets, the DLM builds labels that describe both
conﬁdentiality policies, which restrict the principals that may read the data, and
integrity policies, which restrict which principals trust the data.
The conﬁdentiality policies of the DLM are composed of reader policy components
of the form p:s, where p is the owner of the permissions and s is a set of principals
permitted by p to read the data. For example, the component Alice:Bob, Charles
says that Alice’s policy is that only Bob and Charles (and implicitly Alice) may
read data with this label. The conﬁdentiality part of a label consists of a set of
policy components, each of which must be obeyed—the principals able to read the