## 创建 CompletableFuture 对象创建 CompletableFuture 对象主要靠下面代码中展示的这 4个静态方法，我们先看前两个。在烧水泡茶的例子中，我们已经使用了`runAsync(Runnable runnable)`和`supplyAsync(Supplier supplier)`，它们之间的区别是：Runnable接口的 run() 方法没有返回值，而 Supplier 接口的 get() 方法是有返回值的。前两个方法和后两个方法的区别在于：后两个方法可以指定线程池参数。默认情况下 CompletableFuture 会使用公共的 ForkJoinPool线程池，这个线程池默认创建的线程数是 CPU 的核数（也可以通过 JVMoption:-Djava.util.concurrent.ForkJoinPool.common.parallelism 来设置ForkJoinPool 线程池的线程数）。如果所有 CompletableFuture共享一个线程池，那么一旦有任务执行一些很慢的 I/O操作，就会导致线程池中所有线程都阻塞在 I/O操作上，从而造成线程饥饿，进而影响整个系统的性能。所以，强烈建议你要**根据不同的业务类型创建不同的线程池，以避免互相干扰**。    // 使用默认线程池static CompletableFuture   runAsync(Runnable runnable)static  CompletableFuture   supplyAsync(Supplier supplier)// 可以指定线程池  static CompletableFuture   runAsync(Runnable runnable, Executor executor)static  CompletableFuture   supplyAsync(Supplier supplier, Executor executor)  创建完 CompletableFuture 对象之后，会自动地异步执行 runnable.run()方法或者 supplier.get()方法，对于一个异步操作，你需要关注两个问题：一个是异步操作什么时候结束，另一个是如何获取异步操作的执行结果。因为CompletableFuture 类实现了 Future 接口，所以这两个问题你都可以通过Future 接口来解决。另外，CompletableFuture 类还实现了 CompletionStage接口，这个接口内容实在是太丰富了，在 1.8 版本里有 40个方法，这些方法我们该如何理解呢？
## 如何理解 CompletionStage 接口我觉得，你可以站在分工的角度类比一下工作流。任务是有时序关系的，比如有**串行关系、并行关系、汇聚关系**等。这样说可能有点抽象，这里还举前面烧水泡茶的例子，其中洗水壶和烧开水就是串行关系，洗水壶、烧开水和洗茶壶、洗茶杯这两组任务之间就是并行关系，而烧开水、拿茶叶和泡茶就是汇聚关系。![](Images/cd90e09d864209195d2623c63420602d.png){savepage-src="https://static001.geekbang.org/resource/image/e1/9f/e18181998b82718da811ce5807f0ad9f.png"}```{=html}```串行关系]{.reference}```{=html}```![](Images/0e01bc4362b9b677026dcf3e1ec8ba67.png){savepage-src="https://static001.geekbang.org/resource/image/ea/d2/ea8e1a41a02b0104b421c58b25343bd2.png"}```{=html}```并行关系]{.reference}```{=html}```![](Images/61727821e6993a508b7cac74c3500d29.png){savepage-src="https://static001.geekbang.org/resource/image/3f/3b/3f1a5421333dd6d5c278ffd5299dc33b.png"}```{=html}```汇聚关系]{.reference}```{=html}```CompletionStage 接口可以清晰地描述任务之间的这种时序关系，例如前面提到的`f3 = f1.thenCombine(f2, ()->{})`描述的就是一种汇聚关系。烧水泡茶程序中的汇聚关系是一种 AND聚合关系，这里的 AND指的是所有依赖的任务（烧开水和拿茶叶）都完成后才开始执行当前任务（泡茶）。既然有AND 聚合关系，那就一定还有 OR 聚合关系，所谓 OR指的是依赖的任务只要有一个完成就可以执行当前任务。在编程领域，还有一个绕不过去的山头，那就是异常处理，CompletionStage接口也可以方便地描述异常处理。下面我们就来一一介绍，CompletionStage 接口如何描述串行关系、AND聚合关系、OR 聚合关系以及异常处理。
### 1. 描述串行关系CompletionStage 接口里面描述串行关系，主要是thenApply、thenAccept、thenRun 和 thenCompose 这四个系列的接口。thenApply 系列函数里参数 fn 的类型是接口 Function\，这个接口里与CompletionStage 相关的方法是`R apply(T t)`，这个方法既能接收参数也支持返回值，所以 thenApply系列方法返回的是`CompletionStage`。而 thenAccept 系列方法里参数 consumer的类型是接口`Consumer`，这个接口里与 CompletionStage 相关的方法是`void accept(T t)`，这个方法虽然支持参数，但却不支持回值，所以thenAccept 系列方法返回的是`CompletionStage`。thenRun 系列方法里 action 的参数是 Runnable，所以 action既不能接收参数也不支持返回值，所以 thenRun系列方法返回的也是`CompletionStage`。这些方法里面 Async 代表的是异步执行 fn、consumer 或者action。其中，需要你注意的是 thenCompose系列方法，这个系列的方法会新创建出一个子流程，最终结果和 thenApply系列是相同的。    CompletionStage thenApply(fn);CompletionStage thenApplyAsync(fn);CompletionStage thenAccept(consumer);CompletionStage thenAcceptAsync(consumer);CompletionStage thenRun(action);CompletionStage thenRunAsync(action);CompletionStage thenCompose(fn);CompletionStage thenComposeAsync(fn);通过下面的示例代码，你可以看一下 thenApply() 方法是如何使用的。首先通过supplyAsync()启动一个异步流程，之后是两个串行操作，整体看起来还是挺简单的。不过，虽然这是一个异步流程，但任务①②③却是串行执行的，②依赖①的执行结果，③依赖②的执行结果。    CompletableFuture f0 =   CompletableFuture.supplyAsync(    () -> "Hello World")      //①  .thenApply(s -> s + " QQ")  //②  .thenApply(String::toUpperCase);//③ System.out.println(f0.join());// 输出结果HELLO WORLD QQ
### 2. 描述 AND 汇聚关系CompletionStage 接口里面描述 AND 汇聚关系，主要是thenCombine、thenAcceptBoth 和 runAfterBoth系列的接口，这些接口的区别也是源自 fn、consumer、action这三个核心参数不同。它们的使用你可以参考上面烧水泡茶的实现程序，这里就不赘述了。    CompletionStage thenCombine(other, fn);CompletionStage thenCombineAsync(other, fn);CompletionStage thenAcceptBoth(other, consumer);CompletionStage thenAcceptBothAsync(other, consumer);CompletionStage runAfterBoth(other, action);CompletionStage runAfterBothAsync(other, action);
### 3. 描述 OR 汇聚关系CompletionStage 接口里面描述 OR 汇聚关系，主要是applyToEither、acceptEither 和 runAfterEither系列的接口，这些接口的区别也是源自 fn、consumer、action这三个核心参数不同。    CompletionStage applyToEither(other, fn);CompletionStage applyToEitherAsync(other, fn);CompletionStage acceptEither(other, consumer);CompletionStage acceptEitherAsync(other, consumer);CompletionStage runAfterEither(other, action);CompletionStage runAfterEitherAsync(other, action);下面的示例代码展示了如何使用 applyToEither() 方法来描述一个 OR汇聚关系。    CompletableFuture f1 =   CompletableFuture.supplyAsync(()->{    int t = getRandom(5, 10);    sleep(t, TimeUnit.SECONDS);    return String.valueOf(t);}); CompletableFuture f2 =   CompletableFuture.supplyAsync(()->{    int t = getRandom(5, 10);    sleep(t, TimeUnit.SECONDS);    return String.valueOf(t);}); CompletableFuture f3 =   f1.applyToEither(f2,s -> s); System.out.println(f3.join());
### 4. 异常处理虽然上面我们提到的 fn、consumer、action它们的核心方法都**不允许抛出可检查异常，但是却无法限制它们抛出运行时异常**，例如下面的代码，执行`7/0` 就会出现除零错误这个运行时异常。非异步编程里面，我们可以使用try{}catch{}来捕获并处理异常，那在异步编程里面，异常该如何处理呢？    CompletableFuture   f0 = CompletableFuture.    .supplyAsync(()->(7/0))    .thenApply(r->r*10);System.out.println(f0.join());CompletionStage 接口给我们提供的方案非常简单，比try{}catch{}还要简单，下面是相关的方法，使用这些方法进行异常处理和串行操作是一样的，都支持链式编程方式。    CompletionStage exceptionally(fn);CompletionStage whenComplete(consumer);CompletionStage whenCompleteAsync(consumer);CompletionStage handle(fn);CompletionStage handleAsync(fn);下面的示例代码展示了如何使用 exceptionally()方法来处理异常，exceptionally() 的使用非常类似于 try{}catch{}中的catch{}，但是由于支持链式编程方式，所以相对更简单。既然有try{}catch{}，那就一定还有 try{}finally{}，whenComplete() 和 handle()系列方法就类似于 try{}finally{}中的 finally{}，无论是否发生异常都会执行whenComplete() 中的回调函数 consumer 和 handle() 中的回调函数fn。whenComplete() 和 handle() 的区别在于 whenComplete()不支持返回结果，而 handle() 是支持返回结果的。    CompletableFuture   f0 = CompletableFuture    .supplyAsync(()->7/0))    .thenApply(r->r*10)    .exceptionally(e->0);System.out.println(f0.join());
## 总结曾经一提到异步编程，大家脑海里都会随之浮现回调函数，例如在 JavaScript里面异步问题基本上都是靠回调函数来解决的，回调函数在处理异常以及复杂的异步任务关系时往往力不从心，对此业界还发明了个名词：**回调地狱**（CallbackHell）。应该说在前些年，异步编程还是声名狼藉的。不过最近几年，伴随着[ReactiveX](http://reactivex.io/intro.html)的发展（Java语言的实现版本是RxJava），回调地狱已经被完美解决了，异步编程已经慢慢开始成熟，Java语言也开始官方支持异步编程：在 1.8 版本提供了 CompletableFuture，在 Java9 版本则提供了更加完备的 FlowAPI，异步编程目前已经完全工业化。因此，学好异步编程还是很有必要的。CompletableFuture已经能够满足简单的异步编程需求，如果你对异步编程感兴趣，可以重点关注RxJava 这个项目，利用 RxJava，即便在 Java 1.6版本也能享受异步编程的乐趣。
## 课后思考创建采购订单的时候，需要校验一些规则，例如最大金额是和采购员级别相关的。有同学利用CompletableFuture实现了这个校验的功能，逻辑很简单，首先是从数据库中把相关规则查出来，然后执行规则校验。你觉得他的实现是否有问题呢？    // 采购订单PurchersOrder po;CompletableFuture cf =   CompletableFuture.supplyAsync(()->{    // 在数据库中查询规则    return findRuleByJdbc();  }).thenApply(r -> {    // 规则校验    return check(po, r);});Boolean isOk = cf.join();欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。![](Images/f2ae29f2a91a0266d9d86db774df526d.png){savepage-src="https://static001.geekbang.org/resource/image/cf/aa/cf393cd748a4f0e6451807c4b61843aa.jpg"}