 。
28
 但是，一旦攻击者修改了用户的密码，就有可能窃取该用户的个人信息。
因此，为了预防 CSRF 漏洞，就需要在执行关键处理前确认请求确实是由用户自愿发起的。详情请参考本节的“对策”。
CSRF 漏洞总览
攻击手段与影响
首先让我们来看一下针对 CSRF 漏洞实施的两种典型的攻击模式。即“输入－执行”这种简单模式下的攻击手段以及中途包含确认页面时的攻击方法。
“输入－执行”模式的 CSRF 攻击
此处用更改密码页面作为“输入－执行”模式下关键处理的例子。以下 PHP 脚本展示了更改密码处理的概要。
代码清单 /45/45-001.php（登录脚本）
已登录 (id:)
 更改密码 
代码清单 /45/45-002.php（密码输入页面）
新密码 
代码清单 /45/45-003.php（执行更改密码）
 ○○的密码已更改为△△
这些脚本的运行示例如图 4-41 所示。
图 4-41 脚本运行示例
可见，密码在最后的 45-003.php 中被更改。然而，通过此脚本更改密码，还需要满足以下 3 个条件。
使用 POST 方法请求 45-003.php
保持登录状态
使用 POST 参数中的 pwd
 指定新密码
而使浏览器发送满足以上条件的请求的攻击即为 CSRF 攻击。下面就是用来实施 CSRF 攻击的 HTML 文件。
代码清单 /45/45-900.html
这段代码为实施 CSRF 攻击的恶意网页的 HTML 源代码。攻击者将其置于互联网上，并在其中添加攻击对象网站用户可能感兴趣的内容，以引诱网站的用户前来浏览。
用户浏览此 HTML 时的情形如图 4-42 所示。
图 4-42 通过 CSRF 攻击变更密码
这种情况下，因为先前列举的变更密码所需条件都已满足，所以正规用户的密码就被成功更改为了 cracked。
图 4-43 CSRF 攻击成功
攻击者在实际发动攻击时，为了使攻击显得隐蔽，通常会采用不可见的 iframe 来布置恶意网页（45-901.html）。
图 4-44 隐藏 iframe 以进行暗中攻击
此时，根据同源策略，从 iframe 的外层（恶意网页）无法读取到内层（攻击对象）的内容，因此，CSRF 攻击虽然能够以正规用户的权限恶意使用攻击对象网站中的关键处理，却无法获取网页中显示的内容。
密码被更改也会导致信息泄漏
由于 CSRF 攻击者不能获取攻击对象页面，因此便无法窃取信息。但是，在使用 CSRF 攻击成功更改用户密码后，攻击者就知道了更改后的密码，从而也就能够登录应用来窃取被害人的信息了。
CSRF 攻击与 XSS 攻击
CSRF 与（反射型）XSS 不仅名称相似，攻击流程也如出一辙，甚至连攻击的影响也有相同之处，因此将两者混淆的人不在少数。而为了区分两者，我们可以看一下图 4-45 所展示的 CSRF 和反射型 XSS 的攻击流程。根据此图可以看出，CSRF 和 XSS 在步骤①到③时大体相似，之后便产生了分歧。
图 4-45 CSRF 与反射型 XSS 的比较
CSRF 是指恶意使用服务器对步骤③中请求的处理，恶意使用的内容仅限于服务器端提供的处理。
而 XSS 的情况下，③的请求中包含的脚本则被原封不动地以响应④的形式返回，随后该恶意脚本在用户的浏览器中被执行。由于攻击者能够在用户的浏览器上执行自己准备的 HTML 或 JavaScript，因此只要是浏览器能做到的事都可以被用作攻击手段。攻击者甚至还能够通过 JavaScript 恶意使用服务器端的功能（显示在图中的话就是步骤⑤——向服务器发出恶意请求）。
由此可见，就攻击范围来说，XSS 的威胁更大，但针对 CSRF 漏洞则特别需要注意如下两点。
CSRF 需要在设计阶段就考虑防范策略
开发者对 CSRF 的认知度要低于 XSS，CSRF 对策方面也没有太大进展
存在确认页面时的 CSRF 攻击
接下来就让我们来看一下第二种攻击模式，即输入页面与执行页面之间包含确认页面时的情况。有人觉得有了确认页面后 CSRF 攻击就行不通了，但遗憾的是这是个普遍的误解。
下面以更改邮箱地址的操作为例进行说明。一旦能够随意更改他人的邮箱地址，就可以使用重置密码等功能窃取用户密码。
确认页面将数据传递给执行页面的方法大体上有两种。一种是使用 hidden 参数（type 属性为 hidden 的 input 元素），另一种是使用会话变量。首先来看使用 hidden 参数的情况。
使用 hidden 参数传递参数
下图展示了更改邮箱地址操作时的页面跳转情况。输入页面中输入的邮箱地址被以 hidden 参数的形式嵌入在确认页面中，然后又被传递给了执行页面。
图 4-46 使用 hidden 参数传递参数
此模式下的 CSRF 攻击手段与没有确认页面时的情况相同。这是因为执行页面从输入（HTTP 请求）中取得邮箱地址信息这一点与之前的例子一样。所以，上面介绍的恶意 HTML 几乎是被直接用来攻击的。
使用会话变量传递参数
针对在确认页面和执行页面之间利用会话变量传递参数的网站，CSRF 将如何展开攻击呢？如图 4-47 所示，确认页面将接收到的邮箱地址保存至会话变量，然后再转递给执行页面。
图 4-47 使用会话变量传递参数
针对上述模式的应用程序发动攻击，需要以下两个阶段。
1. 向确认页面发送 POST 请求，使邮箱地址保存到会话变量中
2. 伺机打开执行页面
实现上述两个阶段的攻击的方法如下图所示，需要用到 2 个 iframe 元素。
图 4-48 使用 2 个 iframe 元素的两个阶段的攻击
iframe1 与恶意网页同时打开，并向确认页面发送含有邮箱地址的 POST 请求。这样一来邮箱地址就被保存到了会话变量中。
在恶意网页打开 10 秒钟后，iframe2 打开执行页面并完成 CSRF 攻击。这时，由于邮箱地址已被设置到会话变量中，因此邮箱地址就被更改为了攻击者所指定的邮箱地址。攻击成功。
有些应用采取向导的形式，要经过多个步骤才到达最后的执行页面，这种情况下，只需增加 iframe 的数量就照样能够实施攻击。
专栏：针对内部网络的 CSRF 攻击
CSRF 攻击的攻击目标并不仅限于发布到互联网上的网站。内部网络（局域网）的服务器同样也会成为攻击目标。例如，路由器或防火墙的配置页面中存在的 CSRF 漏洞就是典型案例。路由器或防火墙的管理员终端如果浏览了恶意网站，就有可能导致机器被非法设置，从而允许外部的访问入侵。
然而，实施该攻击的前提是必须要知道攻击目标中安全隐患的详细信息（URL、参数名、功能等）。而为了获取攻击所需的信息，一般可采取如下途径。
调查市面上贩卖的软件或仪器的安全隐患
退职员工等有过访问内部网络经验的人实施攻击
内部人员佯装外人实施攻击
由此可见，针对内部网络的 Web 系统发动 CSRF 攻击是可行的。同样，内部网络也有可能遭受 XSS 等其他被动攻击。因此，即使是内部系统，如果对安全隐患置之不理的话同样也很危险。
安全隐患的产生原因
CSRF 漏洞之所以能够产生，是因为 Web 应用存在以下特性。
（1）form 元素的 action 属性能够指定任意域名的 URL
（2）保存在 Cookie 中的会话 ID 会被自动发送给对象网站
（1）的问题在于，即便是恶意网站，也能够向攻击目标网站发送请求。而（2）的问题则在于，即便请求经过了恶意网站，会话 ID 的 Cookie 值也照样会被发送，从而导致攻击请求在认证的状态下被发送。
下图展示了常规的请求（正规用户自愿发送的请求）与 CSRF 攻击的请求（非正规用户自愿发送的请求）的区别（仅列出了主要项目）。
用户自愿发送的 HTTP 请求
POST /45/45-003.php HTTP/1.1
Referer: http://example.jp/45/45-002.php
Content-Type: application/x-www-form-urlencoded
Host: example.jp
Cookie: PHPSESSID=isdv0mecsobejf2oalnuf0r1l2
Content-Length: 9
pwd=pass1
CSRF 攻击发送的 HTTP 请求
POST /45/45-003.php HTTP/1.1
Referer: http://trap.example.com/45/45-900.html
Content-Type: application/x-www-form-urlencoded
Host: example.jp
Cookie: PHPSESSID=isdv0mecsobejf2oalnuf0r1l2
Content-Length: 9
pwd=pass1
比较两者后可以得知，HTTP 请求的内容几乎一模一样，只有 Referer 字段存在差异。用户自愿发送的请求中 Referer 指向密码输入页面的 URL，而 CSRF 攻击的 HTTP 请求中 Referer 却指向了恶意网页的 URL。
而 HTTP 请求中 Referer 以外的部分则全部相同。由于通常情况下，Web 应用中并不会检验 Referer 的值，所以，如果开发者没有意识去确认该请求是否由正规用户自愿发送，就无法区分两者。这时就会引入 CSRF 漏洞。
另外，虽然我们目前为止所说的都是使用 Cookie 进行会话管理的网站的情况，而事实上使用其他自动发送的参数进行会话管理的网站，同样也会受到 CSRF 攻击。具体来说，像使用 HTTP 认证、SSL 客户端认证、手机的移动 ID（i-modeID、EZ 号、终端序列号等）等进行认证的网站，都有可能受到 CSRF 攻击的影响。
对策
前面已经强调过，防御 CSRF 的关键为确认关键处理的请求确实是由正规用户自愿发送的。因此，作为 CSRF 的防范策略，需执行以下两点。
筛选出需要防范 CSRF 攻击的页面
使代码有能力辨认是否是正规用户的自愿请求
下面我们就来详细地解说以上两点。
筛选出需要防范 CSRF 攻击的页面
并非所有页面都需要实施 CSRF 防御策略，事实上无需防范 CSRF 的页面居多。通常情况下，Web 应用的入口并非只有一处，通过搜索引擎、社交书签、其他链接等方式都能进入到 Web 应用中的各种页面。比如 EC（电子商务）网站一般就非常欢迎通过外部链接进入到它的商品展示页面。而像这种页面就不用实施 CSRF 对策。
而另一方面，EC 网站中的购买商品、更改密码或确认个人信息等页面，就不能够任由其他网站随意执行。这样的页面就应当实施 CSRF 防范策略。
以下为 EC 网站的简易的页面跳转图。图中需要防范 CSRF 的页面为“购买”和“更改”页面 29
 。需要防范 CSRF 的页面添加了阴影。
图 4-49 EC 网站的页面跳转图
鉴于上述这种情况，开发者在开发过程中，应当执行以下流程。
在需求分析阶段制作功能一览表，标记出需要执行 CSRF 防范策略的功能
在概要设计阶段制作页面跳转图，标记出需要执行 CSRF 防范策略的页面
在开发阶段实施 CSRF 防范策略
接下来我们就来看一下具体的开发方法。
确认是正规用户自愿发送的请求
确认请求由正规用户自愿发送是 CSRF 防御策略中必需的步骤。
下图中，假设将用户点击“执行”按钮后发送的请求作为用户自愿发送的请求，而非自愿的请求，即为从恶意网站发出的请求。两者的对比如下。
图 4-50 正规用户自愿发送的请求·非自愿发送的请求