with a disassembler must be used to determine 
the addresses of the first instruction of every 
block. Once a list of addresses to instrument has 
been determined, they must be mapped from the 
global address to the offset within their function 
so that they can be used with DTrace probes.   
We use a combination of technologies to 
connect DTrace with IDA Pro to visualize our 
code coverage in real time. Ruby-dtrace is used 
to wrap libdtrace, allowing programmatic 
responses to be coded in Ruby and executed 
when particular probes fire [4].  IDArub is used 
to allow a remote interface to the IDA Pro API 
[5].  IDA Pro is run on a Windows system and 
the Ruby environment sends commands to IDA 
over the network. When a probe fires, indicating 
that an instruction is executing in the traced 
application, that instruction is colored in IDA 
Pro.  The comment field for that instruction can 
also be updated to indicate the number of times 
the instruction has executed.  Figure 11 shows 
how the code coverage is represented.  Red 
blocks indicate code that has been executed 
while white block have not been executed. 
9 
Figure 11. Code coverage representation in 
IDA  
The code coverage visualization makes it easy 
to see when large portions of code are not being 
executed.  Manual analysis can be carried out to 
determine what conditions are necessary to 
cause the missed code to be executed.  
RE:Trace: DTrace/Ruby Framework 
for Reverse Engineering 
As noted earlier, Chris Andrew’s Ruby-DTrace 
adds flexibility to the already powerful DTrace 
framework enabling reverse engineer’s to write 
scripts that would not be possible in the D 
language alone. Yet there are indeed many 
pieces of boiler plate functionality (i.e. CPU 
Context, memory dump/search, etc..) that 
normal reverse engineering activities require.  
We have packaged together this functionality, 
along with additional features into a framework 
we call RE:Trace.  Integrating the power of 
Ruby and DTrace, RE:Trace is the framework 
which powers the aforementioned Stack Pin 
Point, Heap Smash, and Code Coverage scripts.   
Bundling features reverse engineers need into an 
object oriented framework with many helper 
functions, allows RE:Trace to become the basis 
for many powerful tools.  RE:Trace is being 
actively developed and will soon be released 
with features such as command line interaction 
via Ruby’s IRB, and the ability to enabled 
probes without using D syntax. 
Using DTrace Defensively 
The fact that DTrace instruments nearly the 
entire 
system 
makes 
DTrace 
extremely 
extensible and applicable to a number of tasks.  
While we have mainly looked at DTrace from a 
reverse engineering perspective there are ways 
to use DTrace’s feature set to defend a system. 
Commercial 
HIDS 
(Host-Based 
Intrusion 
Detection Systems) have become fairly common 
place on win32 systems. Vendors have put out 
products like McAfee’s “Entercept” and Cisco’s 
“Security Agent”.  According to McAfee’s 
white paper “System Call Interception,” the 
“Entercept” technology works by altering the 
function pointers in the system call table within 
the kernel.  The function pointers are altered so 
that the “Entercept” kernel driver can hook any 
system call and apply its security method to 
determine whether or not the call made by the 
user land process is valid.  Cisco’s “Security 
Agent” has essentially the same architecture. 
By design, DTrace allows a user to do 
essentially the same type of system call 
intercept as McAfee and Cisco’s commercial 
offerings in an almost completely unobtrusive 
way.  A custom host-based intrusion detection 
system based on system call introspection would 
be simple to implement in the D Language.  
Using Subreption’s publicly available exploit 
for the QuickTime 7.3 RTSP stack based buffer-
overflow as an example we can see how a quick 
custom HIDS can be created easily with a D 
Script. [10] 
The Subreption exploit for QuickTime 7.3 on 
10 
Leopard OS X 10.5.1 uses a classic ‘return-to-
libc’ attack to exploit the stack overflow.  A 
‘return-to-libc’ exploit leverages a buffer 
overflow to setup arbitrary arguments on the 
targets stack before returning into the System() 
function to execute a system call.  This is 
probably the most popular exploit technique on 
platforms that have non-executable stacks.  The 
payload of many of these attacks rely on a series 
of system calls which usually involve a call to 
“/bin/sh”, or “/bin/bash”. If we are looking at 
protecting a vulnerable QuickTime 7.3 from a 
“return-to-libc” exploit we would first profile 
QuickTime’s normal operation through system 
calls. DTrace can be used to do this profiling 
with the script shown in figure 12. 
Once we have established a profile or average 
system calls made, we can begin to create 
signatures for possible attacks that will not 
create “false positives” Clearly blacklisting 
known attacks based on or one two public 
exploits will not suffice for an ‘Enterprise’ 
HIDS but it will serve to illustrate how a HIDS 
could be built on DTrace.  (for further details 
take a look at Sun’s DTrace based HIDS patent 
application # 20070107058) 
By comparing the output of system calls from 
the short D script shown during normal 
operation and operation while being exploited, 
we can determine which system calls can be 
used as ‘signatures’ for our HIDS D script.  
After analyzing the ‘return-to-libc’ attack 
system calls, it is obvious that QuickTime 
Player would not normally make a system call 
to execute ‘/bin/sh’ during everyday operation 
(of course this is a trivial example).  Using the 
DTrace predicate “/execname == "QuickTime 
Player" & args[0] == "/bin/sh"/” would suffice 
to create a generic D script which would detect 
the  default payload for the Subreption 
QuickTime exploit and its variants. After 
detecting the exploit with the syscall probe it is 
trivial to trigger an action which logs, prints out, 
or stop()’s the process under attack.  The entire 
script, shown in figure 13, is a just a few lines. 
Although the above example is extremely basic, 
it could certainly be improved upon with the 
addition of attack signatures.  There are several 
advantages to implementing a ‘custom’ HIDS.  
The first is that attacks cannot test the 
effectiveness of a custom HIDS without 
attacking the target.  Commercial off-the-shelf 
HIDS 
can 
be 
profiled 
in 
a 
controlled 
environment to ensure that exploits evade 
detection.  The second, is that for a custom 
application, the HIDS can be tailored to avoid 
false positives.  Generic system call monitoring 
can often mislabel normal operation.  Using 
Ruby-DTrace to implement a HIDS could allow 
a developer to create a much more advanced 
database complete with signatures stored in a 
relational 
database 
and 
a 
Ruby-On-Rails 
interface. 
#!/usr/sbin/dtrace  -q -s 
proc:::exec 
/execname == "QuickTime Player" 
&&  args[0] == "/bin/sh"/  
{ 
printf("\n%s Has been p0wned! 
it spawned %s\n", execname, 
args[0]); 
} 
Figure 13. Trivial QuickTime HIDS D script 
#!/usr/sbin/dtrace  -q –s 
proc:::exec 
/execname == "QuickTime 
Player"/ 
{ 
printf("%s execs %s\n", 
execname, args[0])  
} 
Figure 12. Profiling QuickTime System Calls 
11 
Hiding Applications From DTrace 
In    a 
blog posting dated January 18, 
2008, DTrace core developer Adam Leventhal 
came across some surprising behavior while 
using DTrace to monitor system-wide behavior: 
“Apple is explicitly preventing DTrace from 
examining or recording data for processes which 
don't permit tracing. This is antithetical to the 
notion of systemic tracing, antithetical to the 
goals of DTrace, and antithetical to the spirit of 
open source.” [11]   
To accomplish this, Apple is using the same 
method it uses to keep GDB from attaching to 
certain software. As explained by Landon Fuller 
“PT_DENY_ATTACH 
is 
a 
non-standard 
ptrace() request type that prevents a debugger 
from attaching to the calling process.”  [10] 
Both Apple’s version of GDB and DTrace 
check to see if this flag is set before a process 
can be debugged or instrumented. Landon Fuller 
is also the author of a kext or Kernel Extension 
for XNU that allows any process to be 
instrumented by DTrace.  By altering the ptrace 
function pointer in the sysent struct within the 
XNU kernl with a pointer to a custom PTrace 
wrapper, Fuller enables anyone to use DTrace in 
its intended form. 
In his presentation at the Chaos Computer 
Congress  entitled “B.D.S.M The Solaris 10 
way” Archim reports significant work that gives 
his rootkit “SInAR” the capability to hide from 
DTrace on the Solaris platform. The problem 
from a rootkit writer’s perspective is that 
DTrace’s fbt provider keeps a list of all modules 
loaded in the kernel.  So if even if you have 
found a way to hide your process from mbd, ps, 
etc., a clever admin with DTrace may still detect 
a kernel-based rootkit.  One problem Archim 
came across is that even modules which have 
mod_loaded and mod_installed set to 0 will still 
be discovered by DTrace.  Archim describes the 
method he uses to hide from DTrace: 
 “When you combine a call to 
dtrace_sync() and then 
dtrace_condense(&fbt_provider), you will 
be removed from the list of providing 
modules in DTrace.”   
This will force DTrace to remove the rootkit 
from DTrace’s internal link list of providers and 
have its probes set on inactive.  At the present 
time, the 0.3 version of SInAR on vulndev.org 
only works on SPARC.  There is currently no 
known rootkit for OS X Leopard or Solaris 10 
x86 capable of hiding from DTrace 
Conclusion 
DTrace is a powerful tool that allows us to 
collect an enormous range of information about 
a running program. Like any tool, it is important 
to understand its strength and weakness. In 
general, DTrace is very well suited for 
collecting and reporting statistics or specific 
values at a given point in time.  This turns out to 
be very useful for reverse engineers, who are 
interested 
in 
pinpointing 
very 
specific 
conditions, such as copy a large value into a 
small space, as well as understanding general 
behavior, such as the growth patterns of heaps. 
The introduction of DTrace to the reverse 
engineering world invites many opportunities 
for improving related techniques. We have 
shown how DTrace can be used to detect and 
pinpoint stack and heap overflows, and visualize 
code coverage. We have also discussed DTrace 
as an intrusion detection tool, and issues related 
to subverting DTrace. There are many more 
interesting areas to explore for future work.  
These include implementing automated fuzzer 
feedback based on code coverage results or 
parameter values; detection of rootkits using 
DTrace timing calculations; and kernel bug 
pinpointing. 
12 
References 
[1] Bryan Cantrill, Mike Shapiro and Adam Leventhal, 
Advanced DTrace – Tips, Tricks and Gotchas, slide 43. 
[2] Sun Microssystems, Inc., Solaris Dynamic Tracing 
Guide, pp.  
[3] Pedram Amini, Pin Pointing Stack Smashes, 
http://dvlabs.tippingpoint.com/blog/2007/05/02/pin-
pointing-stack-smashes 
[4] 
Chris 
Andrews, 
Ruby-DTrace, 
http://rubyforge.org/projects/ruby-dtrace/ 
[5] spoonm, IdaRub, REcon 2006 
[6] Amit Singh, Mac OS X Internals A Systems Approach, 
Addison-Wesley,  2006 
[7] Landon Fuller, Fixing ptrace(pt_deny_attach, ...) on 
Mac 
OS 
X 
10.5 
Leopard, 
http://landonf.bikemonkey.org/code/macosx/Leopard_PT
_DENY_ATTACH.20080122.html, 2008 
[8]Adam Leventhal, Mac OS X and the missing probes, 
http://blogs.sun.com/ahl/entry/mac_os_x_and_the, 2008 
[9]Archim, “SUN – Bloody Daft Solaris Mechanisms.”,  
Chaos Computer Congress,  2004 
[10] Subreption, LLC., QuickTime RTSP Redux, 
http://static.subreption.com/public/exploits/qtimertsp_red
ux.rb 
[11]Nemo, “Exploiting OS X Heap Overflows”, Phrack 
Magazine, Issue 63 
[12]Richard McDougall, 
Jim Mauro, 
Brendan Greg, 
“Solaris™ Performance and Tools: DTrace and MDB 
Techniques for Solaris 10 and OpenSolaris” Prentice Hall, 
2006 
[13] Stefan Parvu, “DTrace & DTraceToolkit-0.96”, 
http://www.nbl.fi/~nbl97/solaris/dtrace/dtt_present.pdf 
[14] Various, “The Shellcoder's Handbook: Discovering 
and Exploiting Security Holes”, Wiley and Sons, 2007