成功获取之后，还会调用GetTickCount获取时间以生成一个随机数。
随机数生成成功，存放到esi中，传到后面的_sprintf_s与DstBuf(上面获取网卡存储的地址)进行格式化。
所以sub_381580的功能很简单，就是获取网卡和硬盘信息并与随机数拼接。
sub_381770
00381770函数一进来就可以看到程序在通过GetVersion和GetNativeSystemInfo获取计算机的操作系统版本和位数。
同样的，将获取到的信息格式化成新的字符串：
最后传入到sub_381950做运算，函数结束。
所以sub_381580和sub_381770都是用于获取操作系统的一些基本信息
现在只剩下sub_382790
###  sub_382790
sub_382790进来之后，可以看到程序调用ReName_DecodeSrings解密了两个字符串，然后调用了RegOpenKeyEx
我们还是直接在003827E5这里设置断点，运行过来，然后在内存窗口中跟随edx，F8执行之后，解密得到ScreenRibbonsDomain
继续F8单步往下走，解密第二个字符串得到：
SOFTWAREMicrosoftWindowsCurrentVersionScreensavers
通过查询资料可得知，SOFTWAREMicrosoftWindowsCurrentVersionScreensavers跟Windows操作系统的屏保相关。目前还不知道攻击者设置键值到这里做什么。
所以在这里我们可以在调试器里接着往后走，然后看到如下的内容：
这个请求地址，就是我们最开始在行为分析里面看到的地址，看来攻击者尝试将改地址写入到注册表地址中，不知道是为了后面方便取C2地址还是有其他高级的操作，要继续往后看才知道。
我们可以在IDA中找到对应的地址：0038286D:
我们双击来到qword_39A620：
点在绿色的十六进制数据上，按下R键：
这里是倒序显示的
反过来刚好就是
general-second.org-help.com
我们在qword_39A620上交叉引用，回到调用的地方，接着看接下来会干什么：
成功赋值之后，会将域名赋值给xmm0，然后赋值给szServerName。
接着通过RegOpenKeyEx打开之前打开过的SOFTWAREMicrosoftWindowsCurrentVersionScreensavers
在最下面，通过RegSetValueEx的方式，将szServerName写入到键值中。
我们在调试器中单步往下走，走到设置注册表键值的地方：
我们单步往下走，执行完成该函数，然后查看该注册表键值：
于是sub_382790的功能我们也搞清楚了，我们回到WinMain中对其进行标注。
这里可以看到，四个函数执行完之后，程序会将szServerName赋值给ecx，然后ecx传入到下面进行操作。此时ecx存放的就是C2地址。
首先一个一个小循环来判断ecx是否有值，然后通过CreateThread创建了一个新线程。新线程地址在StartAddress。
到这里，原始WinMain函数分析完毕，接下来的功能将会在新线程中执行。
###  新线程分析
StartAddress开始的地方，就给[ebp+SubStr] 赋值了word 39A72C的内容
我们这里并不能直接看出来复制的数据是什么，可以在调试器中设置断点跑过来，可以看到是rn
跳转过来之后，程序通过_memset给[ebp+Str]赋值，然后作为参数传递到了sub_382F30中
且我们可以看到，sub_382F30调用完成之后，会检查eax(返回值)是否为1，如果不等于1，则跳转到loc_3835DB
在loc_3835DB处休眠1分钟，然后又通过jmp跳转到上面loc_383410执行。说明此处是一个大循环。
我们回到sub_382F30的调用处，先通过调试器在此上设置断点，看看参数到底是什么。
通过调试器我们可以看到，此时eax指向0252F7DC，是一片空内存。
由于这样直接看不出什么，我们还是在IDA中跟进到sub_382F30：sub_382F30开头的部分是一堆赋值操作，在00382FA5的地方，可以看到一个硬编码的请求头部：Mozilla/5.0
(Windows NT 10.0; Win64; x64….
继续往下看，程序将dl_ex1.png赋值给了al，然后通过al不断的进行循环操作
一大堆循环操作完成之后，程序会call dword_xxxx
在IDA中查看这些地址，是无数据的，所以很明显，上面的循环会解密数据到这些地方，然后在后面通过call指令调用。
所以我们可以直接在调试器中F7进入到这个函数，单步往下走，看看情况。
将鼠标点到00382FE0(dl_ex1.png赋值的地方)这一行，然后F4跑过来，F8往下单步执行：
这里红色表示会跳转上去，我们直接点到下一行的位置(00382FF4),然后F4跑完该循环，接着继续单步往下走，遇到循环就通过F4的方式跑完这个循环，直到在00383068这一行看到call
381770
381770我们之前分析过，是获取网卡和磁盘信息的函数，所以这里不用再F7跟进进去，直接F8单步执行完该函数。
同样的，这里通过循环处理381770的返回值，我们F4跑完循环，继续F8.
在003830B7的地方看到了call InternetOpen
我们在IDA中按G跳转到003830B7，就是我们刚才看到的call dwrd_xxxx
回到调试器中，往下滑动，发现这几个dword都已经成功解密出了对应的API。
程序通过一系列API对指定的general-second.org-help.com发起网络请求。
请求方式为GET ,参数为：dl_ex1.png?m=9AC9AA87&NOTE=Ni4xIDogOS45fDV8djEuMAo=
这里参数的值就是先前手机到的磁盘信息和网卡信息组合的base64编码。
如果数据成功通过HttpSendRequest发送成功，程序则还会调用InertnetReadFile读取数据
如果发送失败，则会通过jmp跳转到最后关闭网络请求，退出函数。
这里肯定是访问失败的，我们可以手动修改jzn为jz，使得请求失败也会跳转过去。
跳转过来之后，发现程序还会在00383188处call call 0x388268
我们在IDA里面看一下00383188所对应的的call是什么内容
这里发现是_malloc用于开辟内存，所以我们就不用F7跟进到这个函数了，直接F8运行过，这里可以看到，如果InternetReadFile读取成功，则会跳转下去循环解密，如果读取失败则通过jmp跳转到最后关闭请求句柄，结束函数
至此，sub_382F30函数功能分析完毕，我们回到StartAddress对sub_382F30进行标注：
按道理来说，sub_382F30执行完成之后，会将[ebp+Str]赋值，然后下面将[ebp+Str]作为参数调用sub_381890。
在sub_381890函数中，是标准的base64解码函数：
所以我们这里也可以对sub_381890进行标注。
sub_381890调用结束之后，按道理来讲，读取回来的数据会经过base64解码存放到[ebp+String]
从图中可以看到，sub_381890之后会通过lstrlenA以及MultiByteToWideChar实现Unicode与UTF8相互转化。
计算完之后，又是一大堆循环计算，最后调用sub_381AA0
###  sub_381AA0
首先是通过_memset给变量赋值
然后通过SHGetFolderPathA获取环境变量路径，并且对wzsiqq873j}j进行解密。
由于上面的判定条件在运行的时候会失败，所以此时直接在调试器中对这个地址下断点是过不来的。
我们可以胆子大点，直接在调试器中CTRL+G跳转到00381AA0的首地址（就是00381AA0）
然后右键，选择设置新的运行点。
然后EIP就会设置到381AA0处了
此时我们直接跳转到解密函数调用的地方然后F4跑过来：
执行之后edx就被成功赋值：
这里解密了一个rundll32.exe 说明程序后面可能会下载一个dll文件到本地，然后通过rundll32.exe调用启动dll。
接着解密了一个路径：%temp%tmp.LOG，暂时不知道该文件用于干什么，反正不是从服务器下载文件保存到这里就是收集本地数据保存到这里然后上传。
回到IDA中接着往后看，样本会将传进来的参数通过 | 分割，然后比较分割后的字符串是否有tiger标志。
如果包含了tiger标志，则通过cmd执行指令，这里的指令是服务器下发的。
这里很明显，到了样本的远控模块了。
除了tiger，在后面的代码中我们还能看到一些其他动物的标志，如wolf、snake、bear、monkey等。至此，我们基本已经将这个样本的功能分析完成，该样本属于KimSuky的远控木马，下发的远控指令为一些动物名称。由于目前服务器已经无法响应，不能正常返回数据了，我们分析到这里，该木马基本可以告一段落。
如果对后面远控指令这部分代码有兴趣，也可以继续对每个指令进行深入分析。
## 0x03 总结
本次分析的样本其实难度并不大，但是篇幅却比较长，但是相信现在大家对汇编指令都比较熟悉了。  
由于篇幅较长，关于该样本的一些补充知识，将放在下一篇的开头讲解，在下一节的内容中，也将跳过讲解一些基础的汇编代码，看看如何更快的去分析恶意样本。