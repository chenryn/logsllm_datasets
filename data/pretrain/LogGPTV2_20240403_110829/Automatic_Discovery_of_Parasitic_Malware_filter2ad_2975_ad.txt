444.3 5.14
0.41 1496.0 0.32
1494.7
4.20 0.24
2.82 1072.3 2.81
126.5
468.4
1500.9
4.21
1103.3
4.19 0.48
1072.2
Table 4. Results of memory performance tests for unmonitored execution and for
Pyren´ee’s monitoring with and without parasitic behaviors present; higher absolute
measurements are better. Percentages indicate performance loss.
Operations
Allocate Small Block (MB/sec)
Write (MB/sec)
Unmonitored Present % Absent %
2322.3 14.22 2704.1 0.12
1.83 1942.9 1.23
1931
2707.4
1967.0
Parasitic Behavior
execution in a VM with and without Pyren´ee’s monitoring. For executions in-
cluding Pyren´ee, we measured performance both during execution of a DLL
injection attack against an unrelated process and during benign system opera-
tion. Our system’s performance in the absence of parasitic behavior is excellent
and largely reﬂects the cost of system-call tracing. Experiments including the
execution of an injection attack show diminished performance that ranges from
inconsequential to a more substantial performance loss of 27%. The additional
overhead measured during the attack occurred when Pyren´ee’s host sensor identi-
ﬁed injection behavior and harvested state information for its log. This overhead
is infrequent and occurs only when parasitic behaviors actually occur.
that
consisted of many objects
Next, we measured Pyren´ee’s performance during network operations. Us-
ing the IBM Page Detailer, we measured the time to load a complex webpage
(http://www.cnn.com)
spread across
multiple servers. The page load caused the browser to make numerous network
connections—an important test because Pyren´ee’s network attribution sensor
intercepts each packet and performs introspection on SYN packets. The result,
shown in Table 5, demonstrates that the overhead of the network attribution
sensor is low. We next executed a network ﬁle transfer by hosting a 174 MB ﬁle
on a local networked server running thttpd and then downloading the ﬁle over
HTTP using wget from the untrusted VM. Table 5 shows that Pyren´ee incurred
less than 3% overhead on the network transfer; we expect that this strong per-
formance is possible because its packet interception design does not require it to
queue and delay packets.
Finally, we measured the cost of our driver isolation strategy by isolating a
heavily-used driver in the UPT, forcing a high volume of page faults handled
114
A. Srivastava and J. Giﬃn
Table 5. Results of the network performance tests for unmonitored execution and for
Pyren´ee’s monitoring without parasitic behaviors present; smaller measurements are
better. Percentages indicate performance loss.
Operations
Page Loading (sec)
Network File Copy (sec)
Unmonitored Pyren´ee %
3.82 4.95
39.00 2.63
3.64
38.00
Table 6. Eﬀect of isolating the tcpip.sys driver on CPU operations for unmonitored
execution and for Pyren´ee’s monitoring without parasitic behaviors present; higher
measurements are better. Percentages indicate performance loss.
Operations
Integer Math (MOps/sec)
Floating Point Math (MOps/sec)
Compression (KB/sec)
Encryption (MB/sec)
String Sorting (Thousand strings/sec)
Unmonitored Pyren´ee %
122.0 3.55
434.8 7.17
1467.5 2.23
4.11 2.38
1060.8 3.85
126.5
468.4
1500.9
4.21
1103.3
Table 7. Eﬀect of isolating the tcpip.sys driver on memory performance for unmon-
itored execution and for Pyren´ee’s monitoring without parasitic behaviors present;
higher measurements are better. Percentages indicate performance loss.
Operations
Allocate Small Block (MB/sec)
Write (MB/sec)
Unmonitored Pyren´ee %
2649.8 2.12
1922.0 2.29
2707.4
1967.0
Table 8. Eﬀect of isolating the tcpip.sys driver on network performance for unmon-
itored execution and for Pyren´ee’s monitoring without parasitic behaviors present;
smaller measurements are better. Percentages indicate performance loss.
Operations
Unmonitored Pyren´ee %
Network File Copy (sec)
38.00
51.00 34.21
by our hypervisor-level code. We isolated the networking driver tcpip.sys and
repeated our previous CPU, memory, and network performance measurements
in the new setting without active parasitic behaviors. We anticipated that CPU
and memory overheads would remain similar, but that network operations would
experience decreased performance. Tables 6, 7, and 8 provide evidence that our
intuition was correct. Given that the moderate performance cost of isolating a
driver in the UPT is borne only by operations invoking that driver’s functionality,
we believe that it represents a feasible deployment strategy for unknown and
untrusted drivers. The clear performance gain to be had by relocating known-
benign drivers in the TPT provides an incentive for driver authors to produce
veriﬁably-safe drivers acceptable to a driver-signing authority.
Automatic Discovery of Parasitic Malware
115
6.4 False Positive Analysis
Pyren´ee ﬁnds malicious code present on an infected system whenever it receives
an alert from a NIDS; it does not detect attacks directly on its own. Hence, false
positives will be exhibited by Pyren´ee only when it identiﬁes a benign processes’
binary or a driver as malicious. We see two possible reasons for such behavior.
First, a NIDS may have false positives when distinguishing between benign
and malicious traﬃc, and it may mis-characterize benign traﬃc as malicious. In
this case, when the NIDS sends an alert along with the network-related informa-
tion, the network attribution sensor will identify the process that is bound to the
connection, and the correlation engine will mark that process as malicious. Cer-
tainly, this is a false positive. Fortunately, this problem will diminish over time as
NIDS’ false positive rates decrease [11]. Even in the case of such false positives,
Pyren´ee helps an administrator meaningfully look into the actual problem by
locating the endpoint of the network traﬃc. We feel that this design is stronger
than an alternative that stores a whitelist of benign parasitic applications and
considers malicious parasitic behaviors to be those initiated by non-whitelisted
applications. The alternative design requires a whitelist that may not be feasible
to generate.
Second, Pyren´ee could identify a benign process as malicious when a NIDS
correctly generates an alert. Absent implementation bugs, this could only be
possible if the network attribution sensor or the host attribution sensor collect
incorrect information. Benign parasitic behaviors, such as injections caused by
debugging, will not appear to be malicious unless the debugged process is using
the network in a way that appears to the NIDS as an attack.
7 Conclusions
We demonstrated the usefulness of identifying malicious code present on an
infected system during attacks. We presented techniques and a prototype sys-
tem, Pyren´ee, for the automatic discovery of unknown malicious code. Pyren´ee
correlates network-level events to host-level activities with the help of multi-
ple sensors and the correlation engine. When alerted by a NIDS, our system
discovered malicious code, even in the presence of parasitic malware, by corre-
lating information gathered from the host and network attribution sensors. Real
malware samples showed that Pyren´ee correctly identiﬁed malicious code. Our
performance analysis demonstrated that our solution was suitable for real world
deployment.
Acknowledgment of Support and Disclaimer. We thank our shepherd,
Davide Balzarotti, and our anonymous reviewers for their extremely helpful
comments. This material is based upon work supported by National Science
Foundation contract number CNS-0845309. Any opinions, ﬁndings, and conclu-
sions or recommendations expressed in this material are those of the authors
and do not reﬂect the views of the NSF or the U.S. Government.
116
A. Srivastava and J. Giﬃn
References
1. Baliga, A., Ganapathy, V., Iftode, L.: Automatic inference and enforcement of
kernel data structures invariants. In: ACSAC, Anaheim, CA (December 2008)
2. Christodorescu, M., Jha, S., Seshia, S.A., Song, D., Bryant, R.E.: Semantics-aware
malware detection. In: Proceedings of the IEEE Symposium on Security and Pri-
vacy, Oakland, CA (May 2005)
3. Christodorescu, M., Sailer, R., Schales, D., Sgandurra, D., Zamboni, D.: Cloud
security is not (just) virtualization security. In: Cloud Computing Security Work-
shop, Chicago, IL (November 2009)
4. Community Developers. Ebtables, http://ebtables.sourceforge.net/ (last ac-
cessed April 15, 2010)
5. Dinaburg, A., Royal, P., Sharif, M., Lee, W.: Ether: Malware analysis via hardware
virtualization extensions. In: ACM CCS, Alexandria, VA (October 2008)
6. Dunlap, G., King, S., Cinar, S., Basrai, M., Chen, P.: Revirt: Enabling intrusion
analysis through virtual-machine logging and replay. In: OSDI, Boston, MA (De-
cember 2002)
7. Forrest, S., Hofmeyr, S.A., Somayaji, A., Longstaﬀ, T.A.: A sense of self for UNIX
processes. In: IEEE Symposium on Security and Privacy, Oakland, CA (May 1996)
8. Garﬁnkel, T., Rosenblum, M.: A virtual machine introspection based architecture
for intrusion detection. In: NDSS, San Diego, CA (February 2003)
9. Giﬃn, J., Jha, S., Miller, B.: Detecting manipulated remote call streams. In: 11th
USENIX Security Symposium, San Francisco, CA (August 2002)
10. Giﬃn, J.T., Jha, S., Miller, B.P.: Eﬃcient context-sensitive intrusion detection. In:
NDSS, San Diego, CA (February 2004)
11. Gu, G., Porras, P., Yegneswaran, V., Fong, M., Lee, W.: BotHunter: Detecting mal-
ware infection through IDS-driven dialog correlation. In: USENIX Security Sym-
posium, Boston, MA (August 2007)
12. Hofmeyr, S.A., Forrest, S., Somayaji, A.: Intrusion detection using sequences of
system calls. Journal of Computer Security 6(3), 151–180 (1998)
13. IBM. Ibm page detailer,
http://www.alphaworks.ibm.com/tech/pagedetailer/download (last accessed
April 15, 2010)
14. Jiang, X., Wang, X., Xu, D.: Stealthy malware detection through VMM-based
‘out-of-the-box’ semantic view. In: ACM CCS, Alexandria, VA (November 2007)
15. Jones, S.T., Arpaci-Dusseau, A.C., Arpaci-Dusseau, R.H.: VMM-based hidden pro-
cess detection and identiﬁcation using Lycosid. In: ACM VEE, Seattle, WA (March
2008)
16. Kasslin, K.: Evolution of kernel-mode malware,
http://igloo.engineeringforfun.com/malwares/
Kimmo Kasslin Evolution of kernel mode malware v2.pdf (last accessed April
15, 2010)
17. Kephart, J., Arnold, W.: Automatic extraction of computer virus signatures. In:
Virus Bulletin, Jersey, Channel Islands, UK (1994)
18. Kim, G.H., Spaﬀord, E.H.: The design and implementation of tripwire: a ﬁle system
integrity checker. In: ACM CCS, Fairfax, VA (November 1994)
19. King, S.T., Chen, P.M.: Backtracking intrusions. In: ACM SOSP, Bolton Landing,
NY (October 2003)
20. Litty, L., Lagar-Cavilla, H.A., Lie, D.: Hypervisor support for identifying covertly
executing binaries. In: USENIX Security Symposium, San Jose, CA (August 2008)
Automatic Discovery of Parasitic Malware
117
21. Martignoni, L., Stinson, E., Fredrikson, M., Jha, S., Mitchell, J.C.: A layered archi-
tecture for detecting malicious behaviors. In: Lippmann, R., Kirda, E., Trachtenberg,
A. (eds.) RAID 2008. LNCS, vol. 5230, pp. 78–97. Springer, Heidelberg (2008)
22. MSDN. Asynchronous procedure calls,
http://msdn.microsoft.com/en-us/library/ms681951VS.85.aspx (last accessed
April 15, 2010)
23. OﬀensiveComputing. Storm Worm Process Injection from the Windows Kernel,
http://www.offensivecomputing.net/?q=node/661 (last accessed April 15, 2010)
24. Passmark Software. PassMark Performance Test,
http://www.passmark.com/products/pt.htm (last accessed April 15, 2010)
25. Paxson, V.: Bro: A system for detecting network intruders in real-time. In: Usenix
Security, San Antonio, TA (January 1998)
26. Payne, B.D., Carbone, M., Sharif, M., Lee, W.: Lares: An architecture for secure
active monitoring using virtualization. In: IEEE Symposium on Security and Pri-
vacy, Oakland, CA (May 2008)
27. Petroni Jr., N.L., Fraser, T., Walters, A., Arbaugh, W.A.: An architecture for
speciﬁcation-based detection of semantic integrity violations in kernel dynamic
data. In: USENIX Security Symposium, Vancouver, BC, Canada (August 2006)
28. Petroni Jr., N.L., Hicks, M.: Automated detection of persistent kernel control-ﬂow
attacks. In: ACM CCS, Alexandria, VA (November 2007)
29. Richter, J.: Load your 32-bit DLL into another process’s address space using injlib.
Microsoft Systems Journal 9(5) (May 1994)
30. Riley, R., Jiang, X., Xu, D.: Guest-transparent prevention of kernel rootkits with
VMM-based memory shadowing. In: Lippmann, R., Kirda, E., Trachtenberg, A.
(eds.) RAID 2008. LNCS, vol. 5230, pp. 1–20. Springer, Heidelberg (2008)
31. Roesch, M.: Snort - lightweight intrusion detection for networks. In: Proceedings
of USENIX LISA, Seattle, WA (November 1999)
32. Sekar, R., Bendre, M., Dhurjati, D., Bollineni, P.: A fast automaton-based method
for detecting anomalous program behaviors. In: IEEE Symposium on Security and
Privacy, Oakland, CA (May 2001)
33. Sharif, M., Lee, W., Cui, W., Lanzi, A.: Secure in-vm monitoring using hardware
virtualization. In: ACM CCS, Chicago, IL (November 2009)
34. Srivastava, A., Erete, I., Giﬃn, J.: Kernel data integrity protection via memory
access control. Technical Report GT-CS-09-05, Georgia Institute of Technology,
Atlanta, GA (2009)
35. Srivastava, A., Giﬃn, J.: Tamper-resistant, application-aware blocking of malicious
network connections. In: Lippmann, R., Kirda, E., Trachtenberg, A. (eds.) RAID
2008. LNCS, vol. 5230, pp. 39–58. Springer, Heidelberg (2008)
36. Staniford, S., Paxson, V., Weaver, N.: How to 0wn the internet in your spare time.
In: USENIX Security Symposium, San Francisco, CA (August 2002)
37. Swift, M.M., Bershad, B.N., Levy, H.M.: Improving the reliability of commodity
operating systems. In: ACM SOSP, Bolton Landing, NY (October 2003)
38. ThreatExpert. Conﬁcker/downadup: Memory injection model.
http://blog.threatexpert.com/2009/01/
confickerdownadup-memory-injection.html (last accessed April 15, 2010)
39. Valdes, A., Skinner, K.: Probabilistic alert correlation. In: Lee, W., M´e, L., Wespi,
A. (eds.) RAID 2001. LNCS, vol. 2212, p. 54. Springer, Heidelberg (2001)
40. Wang, Z., Jiang, X., Cui, W., Ning, P.: Countering kernel rootkits with lightweight
hook protection. In: ACM CCS, Chicago, IL (November 2009)
41. Willems, C., Holz, T., Freiling, F.: Toward automated dynamic malware analysis
using cwsandbox. IEEE Security & Privacy 5(2) (March 2007)