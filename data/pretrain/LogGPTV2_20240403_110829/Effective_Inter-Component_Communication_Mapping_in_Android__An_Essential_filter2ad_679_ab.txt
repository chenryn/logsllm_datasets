well as all the previously analyzed applications.
Let us consider the example in Figure 3, which
is part of our example banking application.
The
startActivity(i) instruction is an exit point for the
application. Our analysis outputs the value of i at this in-
struction as well as all the possible targets. These targets
can be components of our banking application itself or
components of previously analyzed applications.
Figure 4 shows an overview of our component match-
ing process. It can be divided into three main functions:
• Finding target components that can be started by
other components (i.e. “entry points”) and identify-
ing criteria for a target to be activated.
of targets can be activated at these program points.
• Finding characteristics of exit points, i.e. what kind
• Matching exit points with possible targets.
Given an application, we start by parsing its manifest
ﬁle to extract package information, permissions used and
a list of components2 and associated intent ﬁlters (1).
These components are the potential targets of ICC. We
match these possible entry points with the pool of already
computed exit points (2). We then add the newly com-
puted entry points to our database of entry points (3).
This database and the exit points database grow as we
analyze more applications. Then we proceed with the
string analysis, which identiﬁes key API method argu-
ments such as action strings or component names (4).
Next, the main Interprocedural Distributive Environment
(IDE) analysis precisely computes the values of Intent
used at ICC API calls (5).
It also compute the values
of Intent Filters that select Intents received by dynami-
cally registered Broadcast Receivers. These exit points
are matched with entry points from the existing pool of
entry points (6). The newly computed exit points are
stored in the exit point database to allow for later match-
ing (7). The values associated with dynamically reg-
istered Broadcast Receivers are used for matching with
exit points in the database (8). Finally, these values are
stored in the entry point database (9).
One of the inputs to our analysis is a set of class ﬁles.
These classes are in Java bytecode format, since our anal-
ysis is built on top of Soot [34], an existing Java analysis
framework. Android application code is distributed in
a platform-speciﬁc Dalvik bytecode format that is opti-
mized for resource-constrained devices, such as smart-
phones and tablets. Therefore, we use Dare [29], an ex-
isting tool that efﬁciently and accurately retarget Dalvik
bytecode to Java bytecode. While other tools such as
dex2jar3 and ded [28] are available, Dare is currently
the only formally deﬁned one and other tools’ output is
sometimes not reliable.
The manifest parsing step is trivial and we use a sim-
ple string analysis (see Section 6). Also, the matching
process matches exit points with entry points. It can be
made efﬁcient if properly organized in a database. Thus,
we focus our description on the main IDE analysis.
It is important to distinguish between what is com-
puted by the string analysis and by the IDE analysis. In
the example from Figure 2, the string analysis computes
the values of the arguments to the API calls setAction()
and addCategory(). The IDE analysis, on the other
hand, uses the results from the string analysis along with
a model of the Android ICC API to determine the value
of the Intent.
In particular, in Figure 2, it determines
that, at the call to startActivity(), Intent intent has action
a.b.ACTION and category a.b.CATEGORY. In Figure 3,
the IDE analysis tells us that i has two possibles values
at the call to startActivity() and determines exactly what
the two possible values are.
Reducing the Intent ICC problem to an IDE prob-
lem [32] has important advantages. Our analysis is scal-
able (see Section 6). Further, it is a precise analysis, in
the sense that it generates few false positives (links be-
tween two components which may not communicate in
reality). Thus, security analyses using our ICC analysis
will not be plagued by ICC-related false positives. This
precision is due to the fact that the IDE framework is
ﬂow-sensitive, inter-procedural and context-sensitive.
The ﬂow-sensitivity means that we can distinguish In-
tent values between different program points.
In the
example from Figure 3, if Intent i was used for ICC
right before the call to modi f yIntent(), we would accu-
rately capture that this value is different from the one at
startActivity(). The context-sensitivity means that the
analysis of the call to modi f yIntent() is sensitive to the
method’s calling context. If modi f yIntent() is called at
another location with a different argument i2, the analy-
sis will precisely distinguish between the values returned
by the two calls. Otherwise, in a context-insensitive anal-
ysis, the return value would summarize all possible val-
ues given all contexts in which modi f yIntent() is called
in the program. The value of i computed by a context-
insensitive analysis would be inﬂuenced by the value of
i2, which is not the case in reality. That would be signif-
icantly less precise, resulting in more false positives.
2Broadcast Receivers can be registered either statically in the man-
ifest ﬁle or dynamically using the registerReceiver() methods.
3Available at http://code.google.com/p/dex2jar/.
546  22nd USENIX Security Symposium 
USENIX Association
Manifest
(1) Parsing
Components, Intent 
Filters & permissions
(6) Matching
ICC 
links
Intent 
values
(7) Populating 
database
Exit 
points
(8) Matching
(3) Populating 
database
(2) Matching
Entry 
points
ICC 
links
ICC 
links
(4) String 
analysis
Key string 
values
Class 
ﬁles
(5) IDE 
analysis
Dynamic receivers (Intent 
Filters & permissions)
(9) Populating 
database
Figure 4: Connecting Application Components
onClick(View v)
START
i = new Intent();
i.putExtra("Balance", 
this.mBalance);
if 
(this.mCondition)
(p)
modifyIntent(Intent in)
intent = new Intent(in);
i.setClassName("a.
b", "a.b.MyClass");
i.setAction("a.b.
ACTION");
intent.setAction("a.b.
NEW_ACTION");
i.addCategory("a.
b.CATEGORY");
intent.addCategory("a.
b.NEW_CATEGORY");
(c)
(r)
i = modifyIntent(i); 
(CALL)
i = modifyIntent(i); 
(RETURN)
return intent;
startActivity(i);
END
Normal ﬂow edge
Call edge
Return edge
Call-to-return edge
Figure 5: Supergraph G∗ for the program from Figure 3
4 The IDE Framework: Background
The main part of our analysis is based on the IDE frame-
work [32]. In this section, we summarize the main ideas
and notations of the IDE framework. A complete de-
scription is available in [32]. The IDE framework solves
a class of interprocedural data ﬂow analysis problems. In
these problems, an environment contains information at
each program point. For each program idiom, environ-
ment transformers are deﬁned and modify the environ-
ment according to semantics. The solution to this class
of problems can be found efﬁciently.
4.1 Supergraphs
A program is represented using a supergraph G∗. G∗ is
composed of the control ﬂow graphs of the procedures
in the program. Each procedure call site is represented
by two nodes, one call node representing control right
before the callee is entered and one return-site node to
which control ﬂows right after exiting the callee. Fig-
ure 5 shows the supergraph of the program in Figure 3.
(r).
The nodes of a supergraph are program statements.
There are four kinds of edges between these nodes.
Given a call to procedure (p) with call node (c) and
return-site (r), three kinds of edges are used to model
the effects of the procedure call on the environment:
• A call edge between (c) and the ﬁrst statement of (p).
• A return edge between the last statement of (p) and
• A call-to-return edge between (c) and (r).
All other edges in the supergraph are normal intrapro-
cedural ﬂow edges. Informally, the call edge transfers
symbols and associated values from the calling method
to the callee when a symbol of interest is a procedure ar-
gument. The return edge transfers information from the
return value of the callee to the environment in the call-
ing procedure. Finally, the call-to-return edge propagates
data ﬂow information that is not affected by the callee,
“in parallel” to the procedure call (e.g., local variables).
4.2 Environment transformers
Let D be a ﬁnite set of symbols (e.g., program variables).
D contains at least a symbol Λ that represents the absence
of a data ﬂow fact. Let L = (V,(cid:29)) be a join semilattice
with bottom element ⊥, where V is a set of values4. An
environment e is a function from D to L. The set of envi-
ronments from D to L is denoted by Env(D,L).
Operator (cid:29) is deﬁned over Env(D,L) as a natural ex-
tension of (cid:29) in semilattice L: for e1,e2 ∈ Env(D,L), e1 (cid:29)
e2 is such that, for all d ∈ D, (e1(cid:29)e2)(d) =e 1(d)(cid:29)e2(d).
transformer is a function from
The algorithms from [32]
Env(D,L) to Env(D,L).
4A join semilattice is a partially ordered set in which any two ele-
An environment
ments have a least upper bound.
USENIX Association  
22nd USENIX Security Symposium  547
Constructor
b = new Bundle()
e.e[b 7! ?]
⇤
b
B.B
B.?
⇤
b
d
d
Adding int key-value pair
b.putInt("MyInt", mInt)
({MyInt},?,0,())(e(b))i
λe.ehb 7! βb
⇤
b
B.B
B.B
λB.βb
({MyInt},?,0,())(B)
d
d
B.B
1 public C o m p o n e n t N a m e
m a k e C o m p o n e n t N a m e () {
C o m p o n e n t N a m e c ;
if ( this . m C o n d i t i o n ) {
c = new C o m p o n e n t N a m e ( " c . d " ,
2
3
4
" a . b . MyClass " ) ;
} else {
" a . b . M y S e c o n d C l a s s " ) ; }
c = new C o m p o n e n t N a m e ( " c . d " ,
5
6
7
8
9
10 public Bundle m a k e B u n d l e ( Bundle b ) {
11
12
Bundle bundle = new Bundle () ;
bundle . p u t S t r i n g ( " F i r s t N a m e " ,
return c ; }
Copy constructor
b = new Bundle(d)
e.e[b 7! e(d)]
⇤
b
Clearing extra data keys
d.clear()
λe.ehd 7! βb
(?,?,1,())(e(d))i
⇤
b
d
⇤
B.B
B.B
B.B
B.B
B.B
⇤
b
d
⇤
b
b
λB.βb
(?,?,1,())(B)
d
d
Figure 6: Pointwise environment transformers for com-
mon Bundle operations
transformer t
the environment
require that
transformers be dis-
tributive. An environment
is said to
be distributive if for all e1,e2, . . . ∈ Env(D,L), and
d ∈ D, (t((cid:30)iei))(d) = ((cid:30)it(ei))(d).
It is denoted by
t : Env(D,L) −→d Env(D,L). Environment transform-
ers have a pointwise representation. We show an exam-
ple on Figure 6. Given environment e ∈ Env(D,L), trans-
former λ e.e is the identity, which preserves the value of
e. Given symbol b ∈ D and value B ∈ L, λ e.e[b (cid:27)→ B]
transforms e to an environment where all values are the
same as in e, except that symbol b is associated with
value B. The functions from L to L (represented next
to each arrow in Figure 6) are called micro-functions.
The environment transformer for the copy constructor
call b = new Bundle(d) is λ e.e[b (cid:27)→ e(d)]. It means
that the value associated with b after the instruction is the
same as d’s value before the instruction. In the pointwise
representation, this is symbolized by an arrow between d
and b with an identity function next to it.
We are trying to determine the value associated with
each symbol at program points of interest, which is done
by solving an Interprocedural Distributive Environment
(IDE) problem. An instance IDE problem is deﬁned as a
tuple (G∗,D,L,M), where:
• G∗ = (N∗,E∗) is the supergraph of the application be-
• D is the set of symbols of interest.
• L is a join semilattice (V,(cid:30)) with least element ⊥.
distributive
• M
the
edges
environment
i.e.
transformers
M : E∗ −→ (Env(D,L) −→d Env(D,L)).
ing studied.
of G∗,
assigns
to
this . m F i r s t N a m e ) ;
bundle . putAll ( b ) ;