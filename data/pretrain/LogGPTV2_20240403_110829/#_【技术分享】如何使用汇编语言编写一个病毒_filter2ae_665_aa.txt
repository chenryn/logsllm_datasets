# 【技术分享】如何使用汇编语言编写一个病毒
|
##### 译文声明
本文是翻译文章，文章来源：cranklin.wordpress.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
**翻译：**[ **维一零** ****](http://bobao.360.cn/member/contribute?uid=32687245)
**预估稿费：300RMB（不服你也来投稿啊！）**
******投稿方式：发送邮件至**[ **linwei#360.cn**](mailto:PI:EMAIL) **，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿******
**  
**
**前言**
病毒编写的艺术似乎丢失了似的。我们不要将恶意软件，特洛伊木马，蠕虫等等混淆成病毒。你可以使用任何友好的脚本语言去编写那些垃圾程序并且拍着自己的后背嘚瑟一下，但这并不能让你成为一个病毒作者。编写计算机病毒并不一定就是你所看到的关于破坏，还得要看你的病毒可以传播多广泛同时避免被检测，也得要比杀毒软件公司更为聪明。这事关创新和创造力。一个计算机病毒在很多方面就像一个纸飞机。你需要使用聪明和具有创造性的方式去折飞机，并试图使它在不可避免的着陆前尽可能长久的飞翔。在万维网之前，传播病毒是一种挑战。运气好的话，它会感染除了你自己之外的任何电脑。如果运气更好点，你的病毒将获得像鲸鱼病毒或米开朗基罗病毒一样的名声。
如果你想被视为一个“病毒作者”，你必须获得这类称号。在地下黑客组织里，在黑客/破解者/入侵者之中，我最尊重的是病毒作者。因为不是任何人都能做到，那是真的能够表现出他比别人拥有更深的、关于系统和软件方面的知识。你不能指望简单地遵循常规就能成为一个病毒作者。编写一个真正的病毒需要比一般“黑客”拥有更多的技能。多年以来，我没有成功的写出一个可以运行良好的二进制文件感染病毒。一直就是报错、报错、报错。这是一件令人沮丧的事情。因此我坚持编写蠕虫、木马炸弹和ANSI炸弹。我坚持编写BBS的漏洞利用，也去逆向视频游戏软件以破解其版权保护。每当我以为我的汇编技术终于足够，试图编写出一个病毒的时候，失败再次地落到我的脸上。我花了好几年的时间才能够编写出一个真正可运行的病毒。这就是为什么我着迷于病毒并且想找出一些真正的病毒作者。在瑞安“elfmaster”奥尼尔传奇的书籍《学习Linux二进制程序分析》中，他指出：
这是一个超越常规编程约定的伟大挑战工程，它要求开发人员跳出传统模式，去操纵代码、数据和环境使其以某种方式表现，在与AV杀毒软件开发者的交流时，令我吃惊的是，他们旁边没有人有任何真正关于如何逆向一个病毒的想法，更不用说去设计什么真正的启发式来识别它们（除了签名）。事实上，病毒编写是非常困难的，并且需要标准比较严格的技能。
**使用汇编语言编写一个病毒**
病毒是一种艺术。汇编和C（不使用代码库）将是你的画笔。今天，我将帮助你经历一些我面临过的挑战。让我们开始吧，看看你是否拥有成为一个艺术家的潜能！
与我之前的“源代码感染”病毒教程不同，这是更先进且具有挑战性的经历/运用（即使对经验丰富的开发人员）。但是，我鼓励你继续阅读并尽你所能地汲取。
让我们先描述一下我认为的、一个真正病毒应该有的特点：
——病毒会感染二进制可执行文件
——病毒代码必须是独立的，它独立于其他文件、代码库、程序等
——被感染的宿主文件能够继续执行并且传播病毒
——病毒在不损害宿主文件的情况下表现得像一只寄生虫。受感染的宿主应继续像它被感染之前一样执行
因为我们要感染二进制可执行文件，所以简要列表介绍几个不同的可执行文件类型。
**ELF**
-（可执行和链接的文件格式）Unix和类Unix系统标准的的二进制文件格式。这也被许多手机，游戏机（Playstation，任天堂）等等使用。
**Mach-O** -（Mach对象）被NeXTSTEP，macOS，iOS等等，所使用的二进制可执行文件格式，你其实在用它，因为所有的苹果手机都是这。
**PE** -（便携式可执行程序）用于32位和64位微软操作系统
**MZ** （DOS）- DOS支持的可执行文件格式…所有的微软32位及以下操作系统使用
**COM** （DOS）- DOS支持的可执行文件格式…所有的微系32位及以下操作系统使用
微软的病毒教程有许多，但是ELF病毒似乎更具挑战性并且教程稀缺，所以我将主要关注的是32位ELF程序的感染。
我将假设读者至少对病毒复制的方式有一个常规的理解。如果没有，我推荐你阅读我以前的博客文章主题：
第一步是找到要感染的文件。DOS指令集可以方便寻找文件。 **AH:4Eh INT 21** 指令能够基于给定的文件描述找到第一个匹配的文件，而
**AH:4Fh INT 21**
指令可以找到下一个匹配的文件。不幸的是，对于我们却不会这么简单。使用Linux汇编来检索文件列表，这相关的文档并不是很多。少数的几个回答中我们发现它依赖于POSIX系统的readdir()函数。但是我们是黑客，对么？让我们做黑客应该做的事情来实现它。你应该熟悉的工具是strace。通过运行strace
ls，我们看到了当运行ls命令时，跟踪到的系统调用和信号。
你感兴趣的调用是getdents。所以下一步是在查找”getdents”。这将给我们一个小小的提示，关于我们应该怎样使用它以及我们如何得到一个目录列表。下面就是我所发现的东西：
          mov eax, 5      ; sys_open
        mov ebx, folder ; 目录名称
        mov ecx, 0
        mov edx, 0
        int 80h
        cmp eax, 0      ; 检测在eax中的fd是否 > 0 （ok） 
        jbe error       ; 不能打开文件，  以错误状态退出 
        mov ebx, eax    
        mov eax, 0xdc   ; sys_getdents64 
        mov ecx, buffer 
        mov edx, len 
        int 80h 
        mov eax, 6  ; 关闭
        int 80h
现在，我们指定的缓冲区里已经有了目录的内容，我们必须去解析它。出于某种原因，每个文件名的偏移量似乎并没有一致，但也可能是我错了。不过我只对那些原始的文件名字符串感兴趣。我所做的是打印缓冲区到标准输出，然后保存它到另一个文件，再使用十六进制编辑器来打开它。我发现的规律是每个文件名都带有一个前缀，前缀由十六进制值0x00（null）后紧跟一个十六进制0x08构成。文件名是以null为终止的（后缀为一个十六进制0x00）。
    find_filename_start:
        ; 寻找在一个文件名开始前的序列0008
        add edi, 1
        cmp edi, len 
        jge done 
        cmp byte [buffer+edi], 0x00 
        jnz find_filename_start 
        add edi, 1
        cmp byte [buffer+edi], 0x08 
        jnz find_filename_start 
        xor ecx, ecx    ; 清空ecx，其将作为文件的偏移 
    find_filename_end:
        ; 清空ecx，其将作为文件的偏移 
        add edi, 1 
        cmp edi, len    
        jge done
        mov bl, [buffer+edi]    ; 从缓冲区里移动文件名字节
        mov [file+ecx], bl 
        inc ecx                 ; 增加保存在ecx的偏移量
        cmp byte [buffer+edi], 0x00 ; 代表文件名的结尾
        jnz find_filename_end
        mov byte [file+ecx], 0x00 ; 到这我们就拿到文件名了，在其尾部添加一个0x00
        ;; 对该文件做一些操作 
        jmp find_filename_start ; 找下一个文件
其实有更好的方法来做这些事。你所需要做的只是去匹配目录条目结构的字节：
    struct linux_dirent {
                   unsigned long  d_ino;     /* Inode number */
                   unsigned long  d_off;      /* 下一个linux_dirent的偏移 */
                   unsigned short d_reclen;  /* 这个linux_dirent的长度 */
                   char           d_name[];  /* 文件名 （null结尾） */
                                     /* length is actually (d_reclen - 2 -                                        offsetof(struct linux_dirent, d_name)) */
                   /*
                   char           pad;       // Zero padding byte
                   char           d_type;    // File type (only since Linux
                                             // 2.6.4); offset is (d_reclen - 1)
                   */
               }
    struct linux_dirent64 {
                   ino64_t        d_ino;    /* 64位inode number */
                   off64_t        d_off;    /* 64位下个structure的偏移 */
                   unsigned short d_reclen; /* 这个dirent的长度 */
                   unsigned char  d_type;   /* 文件类型 */
                   char           d_name[]; /*文件名 （null结尾） */
               };
但我正在使用的是我发现的一种模式，它没有使用到结构体中的偏移量。
下一步是检查文件，看看是否：
——这是一个ELF可执行文件
——它是不是已经被感染
早些时候，我介绍了一些关于不同操作系统使用的不同类型的可执行文件。这些文件类型在其文件头部都有不同的标志。例如，ELF文件总是从7f45
4c46开始。45-4c-46是ASCII字母E-L-F的十六进制表示。
如果你转储windows可执行文件十六进制数据，你会看到它开头是4D5A，代表字母M-Z。
十六进制转储OSX可执行文件显示了标记字节CEFA EDFE，也是小端的“FEED FACE”。
你可以在这里看到更多关于可执行文件格式和各自的标记：
在我的病毒中，我要把自己的标记写在了ELF文件头中第9 –
12字节里未使用的地方。这是一个不错的位置，可以用来存放一个双字“0edd1e00”——我的名字。
我需要这个来标记我已经感染的文件，这样我就不会再次感染已经感染过的文件。不然受感染文件的长度将像雪球一样越滚越大，耶路撒冷病毒第一次就因此被检测到。
通过简单读取前12个字节，我们可以确定该文件是否是一个好的感染对象然后再继续下一个目标。我打算将每一个潜在的目标存储在一个单独的缓冲区，称之为“目标”。
现在它开始要变得困难了。为了感染ELF文件，你需要了解一切关于ELF文件结构的知识。这里是一个很好的学习起点：。
不同于简单的COM文件，ELF存在一些不同的挑战问题。简单来说，ELF文件包括：ELF头，程序头，节头，和指令操作码。
ELF头告诉我们关于程序头和节头的信息。它也告诉我们程序在内存中的入口点位置（首先执行的指令操作码）。