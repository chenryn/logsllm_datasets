超长也会报错。最后总结一
你会看到它又以一种新的形式冒出来了。现在请思考一下为什么加上检查非法字符的代码之后输入
似乎是两个Bug一起解决掉了，
然后你会惊喜地发现，不仅输入字母会报错，输入超长也会报错：
，但只要没有找到根本原因就不可能真的解决掉，
表10.3.gdb基本命令3
加上判断条件检查非法字符：
界这一点，
修正这个Bug对初学者来说有一定难度。如果你发现了这个Bug却没想到数组访问越
单元，换句话说，i的存储单元是紧跟在input数组后面的。
×
watchpoints
info（或i）
watch
加1，而循环变量i正是在每次回到循环开头之前加1,
已经很明显了，
input=23
23
input=-
Invalid
input=-1
Invalid input!
234567890abcdef
u
234578
2
nvalid input!
nput=-
命令
while (1)
L
 input!
1
input!
。也许一时想不出原因，
每次都是回到ror循环开头的时候改变了input[5]的值，
printf("input=d\n"， sum);
for
sum = 0i
从某个位置开始打印存储单元的内容，全部当成字节来看，而不区
查看当前设置了哪些观察点
设置观察点
一下本节用到的gdb命令：
但这是治标不治本的解决方法。看起来输入超长的错误是不出现
if’(input[i]
,O.- [landuT + Olxwns = uns
%s"
 input
 input)!
break;
sum
-1;
 等到条件一变，
'o
描述
原来input[5]就是变量i的存储
?
它可能又冒出来了，
而且是每次
在下一节
---
## Page 172
2.断点
[22] 打印结果最左边的一长串数字是内存地址，
果，那这一节您就凑合着看吧。
关的问题，
[21] 不得不承认，
，在有些平台和操作系统上也未必得到这个结果，
分哪个字节属于哪个变量
全国嵌入式人才培训基地
起始页
，在第1节“内存与地址"详细解释，
级
，产生Bug的往往都是一些平台相
，目前可以无视。
4.段错误
---
## Page 173
在gdb中运行,
调试过程如下:
如果程序运行时出现段错误，
4.段错误 请点评
论怎么运行都不出错了，
就报错退出,
继续调试上-
段错误出现在 
上一页
例10.5.段错误调试实例二
例10.4.段错误调试实例一
0xb7e1404b in _I0_vfscanf () from /lib/tls/i686/cmov/libc.so.6
Program received signal SIGSEGV,
#2
#0
(gdb)
 gdb main
一行代码引发的段错误。
不仅输入字母可以报错退出，输入超长的字符串也会报错退出。表面上看这个程序无
一节的程序,
0xb7e1dd2b
，遇到段错误会自动停下来，这时可以用命令查看当前执行到哪一行代码了。
0x0804839f
0xb7e1404b in.
#include 
bt
r
int main(void)
#include 
，但假如我们把while（1)循环去掉，每次执行程序只转换一个数：
return 0;
int man.= 0;
上一节最后提出修正Bug的方法是在循环中加上判断条件，
5
 scanf
用gdb可以很容易定位到究竟是哪一行引发的段错误，例如这个小程
'%d"
。仔细观察程序发现是man前面少了个&。
用bt命令可以看到这个函数是被我们的scanf 函数调用的，所以
'， man);
全国嵌入式人才培训基地
from.
第10章gdb
4.段错误
/lib/tls/i686/cmov/libc.s0.6
 Segmentation fault.
如果不是数字
下一页
---
## Page 174
数返回时产生段错误。
以算是-
gdb指出，
又出段错误了。我们按同样的方法用gdb调试看看：
看起来正常。再来一次，这次输个更长的:
然后输入一个超长的字符串，
一条规律，如果某个函数的局部变量发生访问越界，
Invalid input!
19
（gdb）
$ gdb main
Segmentation fault
Invalid input!
Invalid input!
68
5６
（gdb） 1
input=-1
1234567890
段错误发生在第19行。可是这一行什么都没有啊，
./main
r
int main(void)
1
return 0;
scanf("%s",
int sum = 0,
return 0;
printf("input=%d\n", sum);
 /home/akaedu/main
，看看会发生什么:
,O.- [landuT + Oluns = wns
if(input[i]
at main.c:19
0;
,0.- []anduT + Olxuns = uns
 SIGSEGV,
break;
printf("Invalid input!\n");
 Segmentation fault.
-1;
!=
o.
‘.o.
有可能并不立即产生段错误，而是在函
只有表示main函数结束的}括号。这可
174
---
## Page 175
3.观察点
个scanf函数都没办法用好，更没有办法保证写出正确的程序。
出有用的租
数
错误在函数返回时才出现？还有最基本的问题，
藏着各种各样的错误，
想要写出Bug-free的程序是非常不容易的,
为时过
错误，
页
而输入字符串就不要加&？这些问题在后续章节中都会解释清楚。
一
程序了
百
读者还不具备充足的基础知识。但还是有必要讲的，
，然而一个只有输出而没有输入的程序算不上是有用的程序，
，有些错误现象是我们暂时没法解释的：为什么变量i的存储单元紧跟
全国嵌入式人才培训基地
，有时出段错误有时不出段错误？为什么访问越界的段
即使scanf读入字符串这么-
起始页
为什么scanf输入整型变量就必须要加&，否则就
 学完这一阶段之后读者应该能写
一个简单的函数调用都会隐
其实现在讲scanf这个
另一方面也让读者认
第11章排序与查找
1.5
函
出
---
## Page 176
6.折半查找
5.线性查找
4.归并排序
3.算法的时间复杂度分析
2.插入排序
目录
第 11 章 排序与查找 请点评
4.段错误
1.算法的概念
全国嵌入式人才培训基地
第11章排序与查找
全国嵌入式人才培训基地
部分I.C语言入门
起始页
1.算法的概念
下一页
---
## Page 177
进一步学习，可以参考一些全面系统地介绍算法的书，例如[IAOCP]和[算法导论]
本章介绍几种典型的排序和查找算法，并围绕这几种算法做时间复杂度分析。学完本章之后如果想
实际意义的。例如有时候寻找最优解的开销很大，往往会选择能给出次优解的算法。
个不正确的算法可以在有限时间内终止，
是错误的结果。有时候不正确的算法也是有用的，
某些输入，
能输出正确的排序结果，
一类问题中的任何-
这显然不叫算法，
序，如果只需要对这一组数据排序可以写这样一个函数来做：
应该能对任意一组数据进行排序,
算法是用来解决一类计算问题的，
包括比较、移动数据等操作。
么？）。再比如将一组数从小到大排序，
间内完成。比如第3节“递归"习题1中的Euclid算法,
算法（Algorithm）是将一组输入转化成一组输出的一系列计算步骤，
第11章排序与查找
1.算法的概念 请点评
上一页
void sort(void)
 该算法会无限计算下去，
因为不具有通用性。由于算法是用来解决一类问题的，
一个实例，
１２３4５
 这个排序算法才是正确的。不正确的算法有两种可能，
123456
注意是一类问题，而不是一个特定的问题。例如，
全国嵌入式人才培训基地
全国嵌入式人才培训基地
，输入是一组原始数据，输出是排序之后的数据，计算步骤
第11章排序与查找
 并且能把误差控制在一
1.算法的概念
起始页
二是对于该问题的某些输入，
，如果对于某个问题寻求正确的算法很困难，而某
 输入是两个正整数,
一定范围内，
，任意输入一组数据，
，其中每个步骤必须能在有限时
，它必须能够正确地解决这
 输出是它们的最大公约
，那么这样的算法也是有
 该算法终止时输出的
一是对于该问题的
一个排序算法
2.插入排序
它必须都
三
下一页
下一页
---
## Page 178
储单元之间再插入一
2.插入排序 请点评
编程对一
在我插了7之后，手里的牌仍然是排好序的，
置？为什么不用再比较左边的4和2呢？因为这里有一个重要的前提：手里的牌已经是排好序的。现
次比较，
也许你没有意识到，
小到大排好序。例如（该图出自[算法导论]）
插入排序算法类似于玩扑克时抓牌的过程，
上一页
例11.1.插入排序
图11.1.扑克牌的插入排序
一个数组进行插入排序也是同样道理，
，7比10小，
void insertion_sort(void)
int a[LEN] 
#include 
一个单元，
应该再往左插，
，但其实你的思考过程是这样的：现在抓到一张7，把它和手里的牌从右到左依
“={ 10，5，2，4，7 };
因此要将插入点之后的数据依次往后移动一
7比5大，
全国嵌入式人才培训基地
<LEN; j++),{
第11章排序与查找
 a[0],
1;
 玩家每拿到一张牌都要插入到手中已有的牌里，使之从
2.插入排序
 但和插入扑克牌有一点不同，
下次再抓到的牌还可以用这个方法插入。
好，
a[1], a[2], a[3], a[4]);
，就插这里。
%d,
%d,
。为什么比较了10和5就可以确定7的位
%d\n",
一个单元。排序算法如下:
，不可能在两个相邻的存
178
下一页
---
## Page 179
结果中，我把子序列a[0..j-1]加粗表示。下面我们验证一
Invariant的概念和数学归纳法来理解循环结构的算法，假如某个判断条件满足以下三条准则，它就
如何严格证明这个算法是正确的？换句话说，
程序运行结果是：
只要我们找到这个Loop Invariant,
称为Loop Invariant:
一定能把数组a排好序，
为了更清楚地观察排序过程，我们在每次循环开头插了打印语句，在排序结束后也插了打印语句。
1．第一次执行循环之前，j=1，子序列a[0.j-1]只有一个元素a[0］，
3．如果在所有循环结束后该判断条件为真，那么就有办法证明该算法正确地解决了问题。
3
2i
1．第一次执行循环体之前该判断条件为真。
。如果“第N-1次循环之后（或者说第N次循环之前）该判断条件为真"这个前提可以成立，那么
1是排好序的，
当循环结束时，
找到合适的位置给key插入，
第j次循环之前，
排好序的。
就有办法证明第N次循环之后该判断条件仍为真。
样。
后也是排好序的。
，“手中已有的牌是排好序的"这个前提很重要，如果没有这个前提，就不能证明再插一张牌
5
55
int main(void)
10,
44
也就是说整个数组a的LEN个元素都排好序了。
j=LEN,
如果“子序列a[0.j-1]是排好序的"这个前提成立,
而不管数组a的原始数据是什么，
return 0;
insertion_sort();
printf("%d, %d, %d, %d, %d\n",
如果子序列a[0.j-1]是排好序的"这个前提成立，那就是说a[0.LEN-
‘([]e ‘[ε] ‘[] '[]e ‘[o]e
a[i+l] = key; 
就能证明循环结束时子序列a[0..]是排好序的。就像插扑克牌一
，就可以证明一个循环结构的算法是正确的。
 i--;
，只要反复执行该算法的for循环体，执行LEN-1次，就
只有一个元素的序列显然是
，现在要把key=a[j]插进去
上述插入排序算法
个
179
直到
---
## Page 180
系。这再次说明了递归和循环是等价的。
正确性的思想是一
1.算法的概念
可见，
有了这三条，
一致的，
 就可以用数学归纳法证明这个循环是正确的。这和第3节“递归"证明递归程序
这里的第-
一条就相当于递归的BaseCase，
全国嵌入式人才培训基地
起始页
级
第二条就相当于递归的递推关
3.算法的时间复杂度分析
180
---
## Page 181
表示成an2+bn+c的形式，是n的二次函数（Quadratic Function）。
换掉算一下执行时间是多少。最后的结论应该是：在最坏情况和平均情况下，总的执行时间都可以
时间，而我没有设一个常数来表示，这不影响我们的粗略估计。
语句的执行时间分别是c1、c2、c3、c4、c5这样五个常数[23]：
度。现在研究一下插入排序算法的执行时间，按照习惯，输入长度LEN以下用n表示。设循环中各条
3.算法的时间复杂度分析 请点评
在分析算法的时间复杂度时，我们更关心最坏情况而不是最好情况，理由如下：
数组a的原始数据属于最好和最坏情况的都比较少见，
者想一想为什么这是最坏情况，然后把上式中的m替换掉算一
(c1+c2+c5)，可以表示成an+b的形式，
况下，数组a的原始数据已经排好序了
这里有一个问题，m不是个常数，
显然外层for循环的执行次数是n-1次，
（Average Case）
解决同一个问题可以有很多种算法，
2．对于某些算法，
1．最坏情况给出了算法执行时间的上界，
上一页
不会超过这个上界，这样为比较和分析提供了便利。
在数据库中存在不存在。