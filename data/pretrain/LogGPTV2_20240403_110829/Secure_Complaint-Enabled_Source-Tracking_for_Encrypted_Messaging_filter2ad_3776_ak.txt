openings of ğ¶ğ´ and ğ¶â€²
ğ¹ are encrypted with the message plain-
text in ğ‘’, and so the receive function will always fail when
the receiver checks the openings against the commitments
that the platform provides.
G2: Consider the contents of the platform data (ğ¶ğ´, ğ‘ ğ‘Ÿğ‘, ğ¶â€²
We have ensured that the platform must act honestly and pass
the correct information between protocols. We now show that it
cannot act dishonestly during either of the interactive protocols
getUser or RecMsg.
G3: We modify G2 to immediately abort if the platform gives the
user an invalid MAC for the expected attributes in goodRec,
malSend, or getUser.
By the blind issuance properties of the MAC (with no hidden
attributes in the case of NewUser), the adversary can achieve
this and still create a correct issuance proof with only negli-
gible probability, and so this game is indistinguishable from
Game 2.
Weâ€™ve now ensured that the platform interacts with the user
according to the expected protocol.
G4: We modify Game 3 so that each ğ‘’ sent between honest users
is just an encryption of a default value of all zeroes, and the
oracle passes the actual information between the two users.
Since the adversary has non of the secrete keys for these
interactions, this game is indistinguishable from Game 3 by
the authenticated encryption properties of E.
G5: We modify G4 so that during calls to goodSend and goodRec
on an unrevealable message, i.e. one with ğ‘¡ğ‘–ğ‘‘ set to âŠ¥, we
replace the receiving proof output by redeem and the re-
randomization proof ğœ‹ğ‘Ÿ output by present with the outputs
of the zero-knowledge simulator for the proofs. By the zero-
knowledge properties of the proof system, this is indistin-
guishable from a real proof, and so the game is indistinguish-
able from G4.
G6: We alter each call to goodSend with ğ‘¡ğ‘–ğ‘‘ = âŠ¥ to use the
authoring data for the currently sending user as the MAC
that gets presented to the platform when the message is sent
rather than the correct forwarding data for the message (if it
is a forward). The commitments ğ¶ğ´ and ğ¶â€²
ğ¹ still commit to
the same values that would have been used in the standard
game. By the anonymity of the MAC, the platform cannot
distinguish between a presentation of the authoring data and
the forwarding data, because both are valid MACs. Therefore
this game is indistinguishable from G5.
G7: We modify the ciphertexts (ğ´1, ğ´2), (ğµ1, ğµ2), (ğ¶1, ğ¶2) to just
be encryptions of the default valuesâŠ¥, ğºâŠ¥, ğºâŠ¥ when goodRec
is called on a message with ğ‘¡ğ‘–ğ‘‘ = âŠ¥. By the blind-issuance
property of the keyed-verification anonymous credentials
scheme [5], this is indistinguishable to the platform from
issuing a MAC on the expected values.
ğ¹ in calls to goodSend with ğ‘¡ğ‘–ğ‘‘ =
âŠ¥ so that they commit to the default message âŠ¥ and default
source ğºâŠ¥, ğºâŠ¥. By the hiding properties of the commitment,
this is indistinguishable from commitments for the actual
message and source values.
G8: Finally, we change ğ¶ğ´ and ğ¶â€²
We now note that applying the same hybrids described in Games
1-8 starting from the ğ‘ƒğ¶ğ‘‚ğ‘ ğ¹ game where ğ‘ = 1 instead of 0 are
each indistinguishable by the same arguments, and result in a game
identically distributed to Game 8, because all message interactions
with ğ‘¡ğ‘–ğ‘‘ â‰  âŠ¥ are identically distributed in both games by definition,
and we have altered the ğ‘¡ğ‘–ğ‘‘ = âŠ¥ case to use the same authoring
data, commit to the same attributes, and receive a MAC on the
same values. Therefore we have shown that both ğ‘ƒğ¶ğ‘‚ğ‘ ğ¹ 1
ğ‘†ğ‘‡ ,E and
ğ‘ƒğ¶ğ‘‚ğ‘ ğ¹ 0
ğ‘†ğ‘‡ ,E are indistinguishable from Game 8 to an efficient ad-
versary, and so they are also indistinguishable from each other.
This means an efficient adversary can gain at most negligible
advantage in the PCONF game, and so Scheme 2 satisfies platform
confidentiality.
â–¡
C.2 Accountability â€“ Proof of Theorem 5.2
Intuitively, because the receiver of a message has complete control
over what commitments and attributes it receives a MAC on, our
scheme satisfies perfect accountability.
Proof. As a reminder, the ğ‘ ğ‘Ÿğ‘ğµğ¼ ğ‘ ğ· game challenges an adver-
sary with the ability to send messages with content of their choice
between any two users and completely control some set of malicious
users to create a message and associated content that is successfully
received by an honest user, but then cannot be reported.
The tree-unlinkable schemeâ€™s definition of Report provides five
opportunities for failure. We list these in order of occurrence:
(1) The platformâ€™s call to blindVf fails to verify the validity of ğœ‹ğ‘,
the proof that the reporter has a valid MAC for the message
that they are reporting.
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1503(2) The platformâ€™s call to Vf fails to verify the validity of ğœ‹ğ‘Ÿ ,
the proof that the commitments provided by the reporter
contain correct re-randomizations of the original credentials.
ğ‘¦2ğ¸2).
In other words, the opening ğ‘œ ğ‘“ is not a valid opening for the
commitment ğ¶â€²
(3) The first equality check fails (ğ¶â€²
ğ‘“ â‰  (ğºğ‘§
ğ‘¦1ğ¸1, ğºğ‘§
ğ‘¦3ğºğ‘‘
ğ‘‘
, ğºğ‘§
.
(4) The second equality check fails (ğ‘‘ â‰  ğ‘‘â€²).
(5) The third and final equality check fails (ğ‘‘ = âŠ¥).
Weâ€™ll show that assuming the platform and reporter honestly
received the message being reported, each of these failures can
happen with zero probability.
ğ‘“
ğœ‹ğ‘ fails to verify. Because the platform and user honestly fol-
lowed the receipt protocol, a successful receipt guarantees that the
reporter has a valid MAC on the attributes being reported. If a user
was unable to create a valid presentation proof for this MAC, it
would contradict the correctness of the MAC presentation of [5].
We conclude that this failure happens with zero probability.
ğœ‹ğ‘Ÿ fails to verify. All of the relationships proved in ğœ‹ğ‘Ÿ are con-
structed by the user during the present protocol. Because the user
is honest and follows the protocol, they ensure that all of these
relationships are valid, and so an incorrect proof would violate the
completeness of the proof scheme, so this failure also happens with
zero probability.
The opening to the commitment ğ¶â€²
ğ‘“ is invalid. By definition of
the scheme, the reporting user must have received a valid opening
(ğ‘§ğ¹ , ğ‘‘, ğ¸1, ğ¸2) for ğ¶ğ¹ , meaning that
ğ¶ğ¹ = (ğ¶ğ‘‘, ğ¶ğ¸1, ğ¶ğ¸2) = (ğºğ‘§ğ¹
ğ‘¦1 ğ¸1, ğºğ‘§ğ¹
ğ‘¦2ğ¸2).
ğ‘‘ , ğºğ‘§ğ¹
ğ‘¦3ğºğ‘‘
When the honest reporter follows the present protocol, ğ¶â€²
ğ¹ and
ğ‘œğ¹ are computed as
ğ¶â€²
ğ‘¦3, ğ¶ğ¸1ğºğ‘§â€²
ğ¹ = (ğ¶ğ‘‘ğºğ‘§â€²
ğ‘‘ ğºğ‘§â€²
= (ğºğ‘§ğ¹
ğ‘¦3, ğºğ‘§ğ¹
ğ‘¦3ğºğ‘‘
= (ğºğ‘§ğ¹+ğ‘§â€²
ğ‘‘ , ğºğ‘§ğ¹+ğ‘§â€²
ğ‘¦3 ğºğ‘‘
ğ‘¦1
ğ‘¦2ğ‘Œ ğ‘Ÿğ‘›ğ‘‘)
ğ‘¦1ğºğ‘Ÿğ‘›ğ‘‘, ğ¶ğ¸2ğºğ‘§â€²
ğ‘¦1 ğ¸1ğºğ‘§â€²
ğ‘¦1ğºğ‘Ÿğ‘›ğ‘‘, ğºğ‘§ğ¹
ğ¸1ğºğ‘Ÿğ‘›ğ‘‘, ğºğ‘§ğ¹+ğ‘§â€²
ğ‘¦2ğ¸2ğºğ‘§â€²
ğ‘¦2ğ‘Œ ğ‘Ÿğ‘›ğ‘‘)
ğ¸2ğ‘Œ ğ‘Ÿğ‘›ğ‘‘)
ğ‘¦2
and ğ‘œğ¹ = (ğ‘§ğ¹ + ğ‘§â€², ğ‘‘, (ğ¸1ğºğ‘Ÿğ‘›ğ‘‘, ğ¸2ğ‘Œ ğ‘Ÿğ‘›ğ‘‘)), so ğ‘œğ¹ is guaranteed to be
the correct opening for ğ¶â€²
ğ¹ , so this check fails with zero probability
because the reporter honestly follows the protocol and successfully
received the original commitment.
ğ‘‘ â‰  ğ‘‘â€². This condition only occurs if the reporter presents a cre-
dential for a message other than the one being reported. This will
never happen because the reporter is honest.
ğ‘‘ = âŠ¥. During a message receipt, the user checks that the message
being received is not equal to âŠ¥, and aborts otherwise, so this will
never happen because the message being reported was successfully
received.
In conclusion, weâ€™ve shown that assuming a message was re-
ceived successfully by an honest user, a report of that message can
fail with zero probability, so the scheme satisfies perfect account-
ability.
â–¡
C.3 Unforgeability â€“ Proof of Theorem 5.2
Proof. The unforgeability of our scheme will depend on the
extractability of the proofs used. Note that the blind issuance prop-
erties and unforgeability of the anonymous credentials used in [5]
assume that the system used for proofs of knowledge satisfies a
strong extractability property, in particular, that we can extract
the opening (ğ‘§, ğ‘‘, ğ¸1, ğ¸2) of the commitments ğ¶ğ‘‘, ğ¶ğ¸1, ğ¶ğ¸2 used
in the MAC presentation proof ğœ‹ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘’ğ‘›ğ‘¡, which can be used to
re-compute the attributes of the MAC being presented. Since we
use their scheme, whose security relies on the random oracle and
generic group models, we inherit their use of these models in our
scheme. Other possibilities for instantiating such a proof system
are discussed in Appendix D of [4].
The proof is a bit long, so we will first lay out the high-level
intuition. Suppose an adversary wins the game and presents a report
to the platform on an (ğ‘š, ğ‘ˆ , md) tuple that was never actually sent
by the honest user ğ‘ˆ .
We have two possibilities. On one hand, the adversary could have
achieved this by acting dishonestly during the last report interaction
in order to report a message that it didnâ€™t actually have forwarding
credentials for. On the other hand, the adversary may have correctly
followed the standard report protocol, but was able to succeed
because it had valid credentials that were created dishonestly earlier
in the game.
In this second case, we can then look at the point in time when
the adversary received these credentials earlier in the game. Once
again, these could have been obtained by the adversary acting
dishonestly to create credentials that it didnâ€™t actually have, or this
receipt could have been performed honestly because the necessary
credentials were created earlier in the game.
In this way, we can trace back through the adversaryâ€™s interac-
tions with the oracle to identify the first interaction that resulted
in a set of forwarding credentials with an honest source user that
didnâ€™t originate from a call to goodAuth.
We consider all the places where this could have happened, and
then in the actual proof, remove these opportunities in a series of
game hops:
(1) While the adversary was sending a message.
If the incorrect credentials are created when an adversary is
sending a message (i.e., during a call to malSend), this could
happen because either the adversary is able to prove owner-
ship of a MAC that was never created by the platform (ad-
dressed in G1 in the proof below), fake a proof that the new
commitments stored in ğ¶â€²
ğ¹ are correct re-randomizations of
the original attributes (G3), or find an alternate opening of
the commitments it used to prove the validity of its forward-
ing credentials, ğ¶ğ¹ and ğ¶â€²
If the incorrect credentials are created when an adversary re-
ceives a message, this means that either the adversary found
alternate openings to the commitments of the attributes it
can receive credentials from, ğ¶ğ¹ and ğ¶ğ´ (Games G4 and G5,
respectively), it faked a proof that the attribute ciphertexts
were a valid re-randomization of ğ¶ğ´ or ğ¶ğ¹ (G2), or it received
a valid MAC on different values by acting dishonestly during
the blind issuance protocol for the MAC (G1).
ğ¹ (G4).
(2) While the adversary was receiving a message.
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1504(3) While the adversary was reporting the message.
A valid report follows the same approach as a send, so it has
the same opportunities for dishonest action, which we cover
above.
(4) While the adversary was creating a new adversary-controlled
user.
The last potential place where incorrect credentials could
have been created is during a call to getUser. However, the
newUser function is non-interactive, so the adversary cannot