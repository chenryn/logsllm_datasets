编号为`0x77`（`119`）的DHCP选项可以让服务器设置客户端的DNS后缀，但这不适用于搭载Windows操作系统的计算机。之前的微软系统会忽略这个选项，因此之前在必要时，系统会使用组策略来应用DNS后缀名。然而，在Windows
10 version 1803发布后，Windows已经可以处理Domain
Search选项。由于`dhcpcore.dll`中的函数名已经改变，因此可以判断系统添加的处理函数中包含错误。
现在我们可以开始分析。稍微梳理代码后，我们发现`DecodeDomainSearchListData`函数会解码来自服务端消息中Domain
Search选项所包含的数据，输入数据满足前面描述的数组格式，输出以`null`结尾的一个字符串，字符串中包含由逗号分隔的结尾域名列表。比如，如果输入上述示例中的数据，那么该函数会得到如下字符串：
    eng.apple.com,marketing.apple.com
系统会在`UpdateDomainSearchOption`过程中调用`DecodeDomainSearchListData`，将返回的列表写到注册表的`DhcpDomainSearchList`参数中：
    HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces\{INTERFACE_GUID}\
该注册表键值中保存特定网络接口的主要参数：
`DecodeDomainSearchListData`函数包含两大步骤，第一步是执行所有的必要操作，但并没有分配输出缓冲区。因此第一步该函数会计算保存返回数据所需的内存空间大小。第二步将分配内存空间，使用该数据填充已分配的内存。该函数代码量并不大，大约只有250条指令，主要功能是处理输入流中可能出现的3种类型：
`0x00`、`0xc0`以及其他值。DHCP漏洞补丁在第二步开头处添加了针对结果缓冲区大小的一个检查步骤，如果该大小为0，那么就不会为该缓冲区分配内存，函数就会结束运行，返回一个错误：
因此只有当目标缓冲区大小为0时，才会触发该漏洞。并且该函数在一开始也会检查输入参数，输入数据大小不能小于2字节。因此，如果想成功利用漏洞，我们需要找到一个非空的域名后缀，使其输出缓冲区大小等于0.
## 0x05 漏洞利用
我首先想到的第一件事就是使用重解析点来确保非空输入数据会生成一个空的输出字符串：
如果我们设置服务器，使其返回的响应包中带有精心构造的这个选项，那么没有打补丁的客户端的确会出现访问access
violation（非法访问）错误，接下来我们解释具体原因。在每个步骤中，当函数因此解析部分域名时，就会将这部分域名拷贝至目标缓冲区中，然后添加一个点号。对于RFC给出的这个示例，如下数据会被依次拷贝到缓冲区中：
    1). eng.
    2). eng.apple.
    3). eng.apple.com.
然后，当在输入数据中遇到大小为0的域名时，该函数就会修改目标缓冲区数据，将前一个符号从点号改成逗号：
    4). eng.apple.com,
然后继续解析：
    5). eng.apple.com,marketing.
    6). eng.apple.com,marketing.apple.
    7). eng.apple.com,marketing.apple.com.
    8). eng.apple.com,marketing.apple.com,
当输入数据结束时，函数最后只需要将最后一个逗号替换为`null`字符，此时待写入注册表中的字符串如下所示：
    9). eng.apple.com,marketing.apple.com
那么当攻击者发送前面构造的缓冲区时会发生什么情况呢？在这个例子中，我们可以看到列表中只包含一个元素：一个空字符串。在第一步处理中，函数会计算输出缓冲数据大小。由于数据并没有包含任何非零域名，因此该缓冲区大小为0。
在第二步处理中，函数会为该数据分配一个堆内存块，然后拷贝数据。然而由于解析函数会立刻碰到一个`null`字符，表明已经到达域名结尾处，因此如前所述，函数会将前一个字符从点号更改为逗号，此时我们就会碰到一个问题。目标缓冲区迭代器被设置为0，没有前一个字符。前一个字符属于堆内存块头，该字符会被修改为`0x2c`（逗号）。
然而这种情况只有在32位系统上才会发生。使用unsigned
int来存储目标缓冲区迭代器的当前位置在64位系统上会有所不同。让我们仔细研究负责将逗号写入缓冲区的部分代码片段：
系统会使用32位`eax`寄存器从当前位置减去1，然而在缓冲区寻址时，代码会使用完整的64位`rax`来寻址。在AMD64架构上，使用32位寄存器的任何操作都会将寄存器的高半字（high
halfword）置零。这意味着原来值位0的`rax`寄存器在经过减法操作后，得到的值将会变成`0xffffffff`，而不是`-1`。因此，在64位系统上，`0x2c`这个值将会被写入`buf[0xffffffff]`处，位于为缓冲区分配的内存区域之外。
这些信息与微软对该漏洞的可利用评级紧密相关。为了利用该漏洞，攻击者必须知道如何在DHCP客户端上执行远程堆喷射操作，也需要具备堆内存分布的足够控制权，才能确保预设值（即逗号和点号）会被写入已准备好的地址处，从而实现可控的漏洞触发效果。
否则，将数据写入未经检查的地址将导致`svchost.exe`进程出现错误，可能也会影响该进程当前托管的所有服务，随后操作系统可能会重新启动这些服务。如果条件允许，攻击者也可能利用这一点。
关于这个漏洞，目前这似乎是我们能得到的所有研究结果，但我们感觉不应当这么草草结束，毕竟我们还没有考虑所有选项，肯定还有我们尚未发现的点。
## 0x06 CVE-2019-0726
如果我们详细查看导致错误发生的数据类型，将其与出现错误的具体成因进行对比，可以看到系统可能会修改域名列表，导致生成的缓冲区大小不等于0，并且系统还会尝试将其写入缓冲区外。为了促成这种情况，列表第一个元素必须是一个空字符串，剩下的其他元素可能包含一些象征性域名，比如：
该选项包含两个元素。第一个域名后缀为空，使用`null`字节结尾。第二个后缀为`.ru`。此时计算出的输出字符串大小为3字节，因此能通过1月份补丁引入的针对空缓冲区的检查过程。与此同时，数据开头处为0，这样导致该函数在生成字符串中将逗号作为前一个字符写入，但如前文所述，字符串迭代器的当前位置为0，因此函数会在已分配的缓冲区之外写入数据。
现在我们需要通过实际测试来验证我们的理论。我们模拟一个DHCP服务器，当客户端发送请求时，返回包含该选项的一个消息。系统已经为结果字符串分配了一个缓冲区，当系统尝试往缓冲区的`0xffffffff`写入一个逗号时，我们立刻就能观察到一次异常：
这里`r8`寄存器包含指向传入选项的一个指针，`rdi`包含已分配目标缓冲区的地址，`rax`包含待写入字符在该缓冲区的具体位置。这些值都来自于我们在已安装所有补丁的系统上所观察到的结果（补丁截至2019年1月）。
我们向微软反馈了这个问题，大家猜结果如何？他们竟然搞丢了我们提供的信息。是的，即使对于最好且信誉度最高的厂商来说，有时候也会出现这种情况。没有任何一个系统是十全十美的，在这种情况下我们需要找到其他的沟通渠道。直到一周以后，我们还没有收到自动回复，因此我们决定直接通过推特联系。经过几天的分析后，我们发现我们反馈的漏洞实际上与CVE-2019-0547毫无关联，这是一个单独的漏洞，因此我们也收获了一个新的CVE编号。一个月之后（3月份），微软公布了新的补丁，也分配了一个新的编号：[CVE-2019-0726](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2019-0726)。
以上就是在分析1day漏洞时的一个过程，有时候大家可能会凭自己直觉，从这个过程中找到另一个0day漏洞。