data tuples requested by access operations (op(b)
observed by server Sb, respectively. op(b)
to op(b)
, data(b)
if the probability that ⟨(u(b)
represent the same item being accessed is 1
number of distinct items stored in Sb.
j ) ∈ −→σb
is called unlinkable
i ), (u(b)
, data(b)
j )⟩
N , where N is the
j
j
i
i
i
j ) be address-
, op(b)
Note that this is the upper bound of linkability probability
that one can infer from two arbitrary tuples. The unlinkabil-
ity in Deﬁnition 3 implies the DOD-DSSE security deﬁnition,
which is comparable to that of ORAM as follows:
D e f i n i t i o n 4. DOD-DSSE on the server Sb leaks no
information beyond ORAM (Deﬁnition 2) with the exception
of one-time repetition of an unknown and unlinkable query
on the other server S¬b, to which Sb does not have access.
We will give a detailed security analysis in Section 4.3 after
presenting the construction of DOD-DSSE in the following
section.
4. THE PROPOSED SCHEME
We ﬁrst describe the encrypted data structure used in
DOD-DSSE , followed by several newly proposed algorithms.
4.1 DOD-DSSE Encrypted Data Structure
An encrypted data structure enables encrypted search and
update operations for a keyword w or a ﬁle fid. In this paper,
we adopt a keyword-ﬁle incidence matrix to be the DSSE data
structure I due to its security and performance advantages,
compared with other typical types such as multi-linked list
[13], dictionary [17], and tree [12]. For the sake of simplicity,
we assume that keywords are assigned to row indices while
ﬁle IDs are assigned to column indices. We assume our ﬁle
collection f consists of m′ ≤ N unique keywords and n′ ≤ N
ﬁle IDs, where N is the maximum number of unique keywords
and ﬁles that our I can support. We construct the encrypted
index I(0) for server S0 and I(1) for S1 as follows:
First, we assign each item x, where x is a keyword or ﬁle
$← Lb for each
ID, to a unique random address in I(b) as u(b)
x
b ∈{ 0, 1}, where Lb is the set of unassigned row or column
indices in I(b). For security reasons which will be analyzed
in Section 4.3, |L|= 2N . In other words, I is a square matrix
of size 2N × 2N to cover N keywords and ﬁles.
We represent the relationship between a keyword and a
ﬁle by a cell value in I(b). I(b)[i, j] = 1 means the keyword
w assigned to row i appears in the ﬁle assigned to column
j in server Sb and I(k)[i, j] = 0 otherwise. We can consider
the data I(b)
ux of item x as a row or column data which is
a binary string of length 2N representing the relationship
between x and its object in server Sb. A search or update
query of x will correspond with retrieving a whole row or
column respectively.
τ (b)
i
(I(b)[i, j], c(b)
j ), where c(b)
Finally, we encrypt every cell in I(b) using bit-by-bit IND-
CPA encryption scheme with a counter and a key as I(b)[i, j] ←
E.Enc
is a counter derived from
column index j and a value a(b)
is a row
key derived from the row index i and a secret key generated
for server Sb. We store the information of a(b)
in global
j
counter arrays C(b) of length 2N which can be retrieved as
a(b)
j ← C(b)[j], for each b ∈{ 0, 1}. We describe detailed
constructions of I(0), I(1) in Algorithm 2. Figure 3 depicts
the structure and content of I(0) and I(1).
j
in server Sb and τ (b)
j
i
We create data structures Tw, Tf stored on the client-side
for keywords and ﬁles, respectively which are deﬁned as:
T : (H(x),⟨u(0)
x , u(1)
x , bx⟩).
(Tw, Tf ) are used to keep track of the assigned addresses
(u(0)
x , u(1)
x ) of each item x on servers (S0, S1), respectively,
as well as the server ID (i.e., bx ∈{ 0, 1}) where it was last
accessed. We deﬁne functions for T as follows:
• T.insert(key, value):
insert hash of x (i.e., H(x)) as
key and x’s information ⟨u(0)
x , bx⟩ as value into
T . It can accept null as key, in which the value (i.e,
null, u(1)
⟨u(0)
null, bnull⟩) will be inserted into empty slots in T .
• jx ← T.get(H(x)): ﬁnd the index jx of x in T using its
x , u(1)
hash value H(x).
• jx ← T.lookup(u(b)
its address ux on the server Sb.
x , b): ﬁnd the index jx of x in T using
2
3
1
. . .
. . .
4
0
1
. . .
2N
1
1
1
. . .
. . .
1
fid1
1
(1)
0
3
fid2
1
(0)
1
Encrypted data structure I(0) Encrypted data structure I(1)
uf
2N
uw
fid4
1
0
wi1
...
2
1
(0)
1
(1)
0
(1)
...
1
21 22 23 24
fid2
1
...
0
(1)
0
(0)
1
(0)
...
1
6
5
fid4
fid3
0
0
(1) (1)
0
0
0
1
1
0
(1) (1)
1
0
...
...
1
0
(0)
(0)
0
0
0 1
(0)
1
0
...
...
1
0
(1)
uf
uw
1
...
41
wi3
42
wi2
43
wi1
...
2N
fid1
0
...
1
(1)
1
(0)
1
(1)
...
0
1
1
(0)
1
...
1
(1)
4
wi2
5
...
2N
wi3
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
1
...
0
1
1
0
...
1
0
...
0
1
0
0
...
1
1
...
0
. . .
. . .
. . .
. . .
. . .
. . .
1
1
1
0
1
...
1
1
...
0
1
...
0
. . .
! i
wk": keyword wk assigned to row i.
fidk": ﬁle fidk assigned to column j.
!
j
1
(0)
: dummy row/column.
encrypted(cid:1) bit(cid:1) generated(cid:1) by(cid:1) bit-by-bit(cid:1) encryption(cid:1) (cid:62)(cid:21)(cid:25)(cid:64)(cid:15)(cid:1)
actual(cid:1) ( i.e.,(cid:1) un-encrypted)(cid:1) bit(cid:1) t hat(cid:1) s hows(cid:1) t he(cid:1) r elation
between(cid:1)keyword(cid:1)and(cid:1)ﬁle.
Figure 3: Two encrypted instances of an incidence matrix
data structure generated from the same ﬁle collection f.
x , u(1)
x , bx⟩) ← T [jx].
Information about x can be retrieved via its index jx in T
as (H(x),⟨u(0)
We can see that I is a 2N × 2N matrix storing the rela-
tionship between N unique keywords and N ﬁles. There are
at least N empty rows and N empty columns in I. We also
include in Tw, Tf sets of such “dummy” addresses in I(0), I(1),
denoted as Tw.L0, Tw.L1, for keywords and Tf .L0, Tf .L1
for ﬁles respectively. This is to achieve the consistency of
DOD-DSSE data structure and security (see Section 4.3).
4.2 Proposed DOD-DSSE Algorithms
We present detailed implementations of DOD-DSSE in
three main algorithms with four subroutines. We provide
in Subroutine 3 the decryption procedure for a row/column
data of I. The encryption procedure DOD-DSSE .Enc() is
not explicitly deﬁned and it works similarly to Subroutine 3
by substituting in lines 4 and 8 E.Dec() for E.Enc().
The main operation of DOD-DSSE is presented in Algo-
rithm 3. First, the client generates for each server one search
and one update queries including two row indices (one is
dummy) and two column indices (one is dummy) using Sub-
routine 2 (step 1). The client reads data in such addresses
from the servers and decrypts only data in non-dummy ad-
dresses (steps 2 – 7). After that, the client can perform an
actual search or update operation over the decrypted data
(steps 8–11). Finally, the decrypted data are re-encrypted
with new counters and written back to addresses in the server
from where they were read as well as the dummy addresses
in the other server (steps 17–21). Notice that such data need
to be updated before re-encryption to preserve keyword-ﬁle
relations (steps 15–16), and their new addresses in the other
server are updated in hash tables (steps 12–16) so that they
can be retrieved correctly in subsequent operations.
# Generate keys to encrypt two data structures
Algorithm 1 K ← DOD-DSSE .Gen(1κ)
1: k0 ←E .Gen(1κ), k1 ←E .Gen(1κ)
2: return K ← (k0, k1)
306
Algorithm 2 (K, Tw, Tf , I(0), I(1)) ← DOD-DSSE .Init(κ, f)
1: Initialization: Set Tw, Tf to be empty
I′(b)[i, j] ← 0 and C(b)[j] ← 1, for all 1 ≤ i ≤ 2N , 1 ≤ j ≤ 2N and for each b ∈{ 0, 1}
Tx.Lb ←{ 1, 2, . . . ,2 N} for each x ∈{ w, f} and b ∈{ 0, 1}
2: K ← DOD-DSSE .Gen(1κ)
3: Extract unique keywords w = (w1, . . . , wm′ ) from ﬁles f = (fid1 , . . . , fidn′ )
# Create unecnrypted data structureI ′(0) for server S0, I′(1) for server S1
4: for each wi ∈{ w1, . . . , wm′} do
i
i
, u(1)
(u(0)
for each idj ∈{ id1, . . . , idn′} do
, Tw) ← DOD-DSSE .Assign(H(wi), Tw)
, v(1)
, Tf ) ← DOD-DSSE .Assign(H(idj), Tf )
(v(0)
if wi appears in fidj then
j
j
I′(0)[u(0)