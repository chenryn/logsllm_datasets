### 优化后的文本

#### 数据元组和访问操作
数据元组由访问操作 `op(b)` 请求，这些操作由服务器 `Sb` 观察到。如果 `⟨(u(b)_i, data(b)_i), (u(b)_j, data(b)_j)⟩` 表示相同的项被访问的概率为1，则称其为不可链接的。这里，`N` 是 `Sb` 中存储的不同项的数量。请注意，这是从任意两个元组中可以推断出的最大链接概率。

在定义3中的不可链接性意味着DOD-DSSE的安全性定义与ORAM（定义2）相当，除了在一个未知且不可链接的查询在另一个服务器 `S¬b` 上的一次重复之外，`Sb` 无法访问该服务器。我们将在下一节详细讨论DOD-DSSE的构造之后，在第4.3节进行详细的安全分析。

#### 提出的方案
首先描述DOD-DSSE中使用的加密数据结构，然后介绍几种新提出的算法。

##### DOD-DSSE加密数据结构
加密数据结构支持对关键词 `w` 或文件 `fid` 的加密搜索和更新操作。本文采用关键词-文件关联矩阵作为DSSE数据结构 `I`，因为它在安全性和性能方面优于其他典型类型，如多链表 [13]、字典 [17] 和树 [12]。为了简化起见，假设关键词分配给行索引，而文件ID分配给列索引。假设我们的文件集合 `f` 包含 `m′ ≤ N` 个唯一的关键词和 `n′ ≤ N` 个文件ID，其中 `N` 是 `I` 可以支持的最大唯一关键词和文件数量。我们为服务器 `S0` 构建加密索引 `I(0)`，为 `S1` 构建 `I(1)`，如下所示：

1. 我们将每个项 `x`（`x` 是一个关键词或文件ID）分配给 `I(b)` 中的一个唯一随机地址 `u(b)_x`，其中 `Lb` 是 `I(b)` 中未分配的行或列索引集合。出于安全考虑（将在第4.3节中分析），`|L|= 2N`。换句话说，`I` 是一个大小为 `2N × 2N` 的方阵，以覆盖 `N` 个关键词和文件。

2. 我们通过 `I(b)` 中的单元格值表示关键词和文件之间的关系。`I(b)[i, j] = 1` 表示分配给行 `i` 的关键词 `w` 出现在分配给列 `j` 的文件中，否则 `I(k)[i, j] = 0`。我们可以将项 `x` 的数据 `I(b)_ux` 视为一个长度为 `2N` 的二进制字符串，表示 `x` 与其对象在服务器 `Sb` 之间的关系。对 `x` 的搜索或更新查询将分别对应于检索整个行或列。

3. 最后，我们使用逐位IND-CPA加密方案加密 `I(b)` 中的每个单元格，并使用计数器和密钥生成加密后的单元格值 `I(b)[i, j] ← E.Enc(c(b)_j, τ(b)_i(I(b)[i, j], c(b)_j))`，其中 `c(b)_j` 是从列索引 `j` 派生的计数器，`τ(b)_i` 是从行索引 `i` 和为服务器 `Sb` 生成的秘密密钥派生的行密钥。我们将 `a(b)_j` 存储在全局计数器数组 `C(b)` 中，长度为 `2N`，可以通过 `a(b)_j ← C(b)[j]` 检索，对于每个 `b ∈ {0, 1}`。我们在算法2中详细描述了 `I(0)` 和 `I(1)` 的构造。图3描绘了 `I(0)` 和 `I(1)` 的结构和内容。

##### 客户端数据结构
我们创建客户端存储的数据结构 `Tw` 和 `Tf`，分别用于关键词和文件，定义如下：
- `T : (H(x), ⟨u(0)_x, u(1)_x, bx⟩)`
- `(Tw, Tf)` 用于跟踪每个项 `x` 在服务器 `(S0, S1)` 上的分配地址 `(u(0)_x, u(1)_x)` 以及它最后访问的服务器ID（即 `bx ∈ {0, 1}`）。我们定义以下函数：
  - `T.insert(key, value)`：插入 `x` 的哈希值 `H(x)` 作为键，`x` 的信息 `⟨u(0)_x, bx⟩` 作为值。它可以接受 `null` 作为键，在这种情况下，值 `⟨u(0)_null, u(1)_null, b_null⟩` 将被插入 `T` 中的空槽。
  - `jx ← T.get(H(x))`：使用 `x` 的哈希值 `H(x)` 查找 `x` 在 `T` 中的索引 `jx`。
  - `jx ← T.lookup(u(b)_x, b)`：使用 `x` 在服务器 `Sb` 上的地址 `u(b)_x` 查找 `x` 在 `T` 中的索引 `jx`。

通过索引 `jx`，可以从 `T` 中检索关于 `x` 的信息 `(H(x), ⟨u(0)_x, u(1)_x, bx⟩)`。可以看到，`I` 是一个 `2N × 2N` 矩阵，存储 `N` 个唯一关键词和 `N` 个文件之间的关系。在 `I` 中至少有 `N` 个空行和 `N` 个空列。我们还在 `Tw` 和 `Tf` 中包括 `I(0)` 和 `I(1)` 中的“虚拟”地址集，分别表示为 `Tw.L0, Tw.L1` 和 `Tf.L0, Tf.L1`。这是为了实现DOD-DSSE数据结构的一致性和安全性（见第4.3节）。

##### 提出的DOD-DSSE算法
我们详细介绍了DOD-DSSE的三个主要算法及其四个子程序。子程序3提供了 `I` 中行/列数据的解密过程。加密过程 `DOD-DSSE .Enc()` 未明确定义，但其工作方式类似于子程序3，只需在第4行和第8行用 `E.Dec()` 替换 `E.Enc()` 即可。

DOD-DSSE的主要操作在算法3中呈现。首先，客户端为每个服务器生成一个搜索查询和一个更新查询，包括两个行索引（一个是虚拟的）和两个列索引（一个是虚拟的），使用子程序2（步骤1）。客户端从服务器读取这些地址中的数据，并仅解密非虚拟地址中的数据（步骤2-7）。之后，客户端可以在解密数据上执行实际的搜索或更新操作（步骤8-11）。最后，解密数据用新的计数器重新加密，并写回到从中读取的服务器地址以及另一个服务器中的虚拟地址（步骤17-21）。需要注意的是，这些数据在重新加密之前需要更新以保持关键词-文件关系（步骤15-16），并且它们在另一个服务器中的新地址会在哈希表中更新（步骤12-16），以便在后续操作中正确检索。

```algorithm
# 生成用于加密两个数据结构的密钥
Algorithm 1 K ← DOD-DSSE .Gen(1κ)
1: k0 ← E.Gen(1κ), k1 ← E.Gen(1κ)
2: return K ← (k0, k1)

# 初始化DOD-DSSE
Algorithm 2 (K, Tw, Tf, I(0), I(1)) ← DOD-DSSE .Init(κ, f)
1: 初始化：将Tw, Tf设置为空
   对所有1 ≤ i ≤ 2N, 1 ≤ j ≤ 2N 和每个 b ∈ {0, 1}，设置 I′(b)[i, j] ← 0 和 C(b)[j] ← 1
   对每个 x ∈ {w, f} 和 b ∈ {0, 1}，设置 Tx.Lb ← {1, 2, ..., 2N}
2: K ← DOD-DSSE .Gen(1κ)
3: 从文件 f = (fid1, ..., fidn′) 中提取唯一关键词 w = (w1, ..., wm′)
# 为服务器 S0 创建未加密数据结构 I′(0)，为服务器 S1 创建 I′(1)
4: 对每个 wi ∈ {w1, ..., wm′}，执行
   (u(0)_i, u(1)_i, Tw) ← DOD-DSSE .Assign(H(wi), Tw)
   对每个 idj ∈ {id1, ..., idn′}，执行
   (v(0)_j, v(1)_j, Tf) ← DOD-DSSE .Assign(H(idj), Tf)
   如果 wi 出现在 fidj 中，则
   I′(0)[u(0)_i, v(0)_j] ← 1, I′(1)[u(1)_i, v(1)_j] ← 1
```

希望这些改进使您的文档更加清晰、连贯和专业。如果有进一步的需求，请随时告知！