which is inspired by the one posted in [30]. The regex is in-
tended to accept a non-nested XML tag, i.e., a tag that appears
as a leaf in an XML document. For example, it should ac-
cept  and text, but it should
reject , , and
. Unfortunately,
the regex is both
incorrect and vulnerable. It is incorrect because it accepts tags
such as . It is vulnerable because it
takes quadratic time to match strings such as <><>
where ··· repeats > and ab and negative examples
, , and .
REMEDY explores a regex that is consistent with the exam-
ples and has real-world strong 1-unambiguity (RWS1U). Also,
REMEDY looks for regexes that are syntactically close to the
given one to bias toward synthesizing regexes that are close
to the user’s intention. The assumption is that the given regex
may not be correct but is close to the one user intended.
RWS1U ensures the invulnerability of the synthesized regex.
Roughly, it makes the behavior of the matching algorithm
backtrack-free thus ensuring linear running time. The regex
·∗ violates the RWS1U condition because there
are two ways to match > in the input string after the first .
Likewise, after : \1 if it refers to a string that starts with > or the
second >. There are also multiple ways to match ·∗. Since the regex is vulnerable and
does not satisfy the RWS1U condition, REMEDY replaces the
subexpressions with holes and expands the holes by replacing
∗, (?=(cid:50)), and \i.
2.
∗
1)1>(cid:50)
Searching assignments. Next, REMEDY checks if the tem-
plate can be instantiated to a regex that satisfies the re-
quired conditions by replacing its holes with some sets of
characters. For this, REMEDY generates two types of con-
straints: consistency-with-examples constraint that ensures that
the regex is consistent with the examples, and linear-time
constraint that asserts RWS1U. REMEDY looks for a regex
that satisfies the constraints by using an SMT solver. If
the constraints are unsatisfiable, then REMEDY backtracks to
explore more templates. We give the details of the constraint
generation in Section V-A. REMEDY also performs template
pruning to filter out templates that can be efficiently detected
impossible to be instantiated to a regex that is consistent with
the examples. The details are presented in Section V-A.
Using an SMT solver, REMEDY finds that the constraints are
satisfiable, and replaces (cid:50)1 and (cid:50)2 with [ˆ>] and [ˆ]∗)1>[ˆ as the
repaired regex which is invulnerable and matches the user’s
intention.
III. REAL-WORLD REGULAR EXPRESSIONS
In this section, we give the definition of real-world regexes.
We also present the novel formal model of the backtracking
matching algorithm for real-world regexes, and with it, we
formally define their ReDoS vulnerability.
Notations. Throughout this paper, we use the following no-
tations. We write Σ for a finite alphabet; a,b,c,∈ Σ for a
character; w,x,y,z ∈ Σ∗ for a sequence of characters; ε for
the empty sequence; r for a real-world regex; N for the set of
natural numbers. For the string x = x[0]...x[n− 1], its length
is |x| = n. For 0 ≤ i ≤ j < |x|, the string x[i]...x[ j] is called a
substring of x. We write x[i.. j] for the substring. In addition,
we write x[i.. j) for the substring x[i]...x[ j−1]. We assume that
x[i.. j) = $, where $ /∈ Σ, when i < 0 or |x| < j. For f a (partial)
f [α (cid:55)→ β ] denotes the (partial) function that maps
function,
α to β and behaves as f for all other arguments. We write
f (α) = ⊥ if f is undefined at α. We define ite(true,A,B) = A
and ite(false,A,B) = B.
A. Syntax and Informal Semantics
The syntax of real-world regexes (simply regexes or expres-
sions henceforth) is given below:
::= [C] | ε | rr | r|r | r∗
|
r
(r)i | \i | (?=r) | (?!r) | (?<=x) | (?<!x)
Here, C ⊆ Σ and i ∈ N. A set of characters [C] exactly matches
a character in C. We sometimes write a for [{a}], and write ·
for [Σ]. The semantics of empty string ε, concatenation r1r2,
union r1|r2 and repetition r∗ are standard. Many convenient
notations used in practice such as options, one-or-more rep-
etitions, and interval quantifiers can be treated as syntactic
sugars: r? = r|ε, r+ = rr∗, and r{i, j} = r1...riri+1?...r j? where
rk = r for each k ∈ {1, . . . , j}.
The remaining constructs, that is, capturing groups, backref-
erences, (positive and negative) lookaheads and lookbehinds,
comprise the real-world extensions. In what follows, we will
explain the semantics of the extended features informally in
terms of the standard backtracking matching algorithm which
attempts to match the given regex with the given (sub)string
and backtracks when the attempt fails. The formal definition
is given later in the section.
A capturing group (r)i attempts to match r, and if suc-
cessful, stores the matched substring in the storage identified
by the index i. Otherwise, the match fails and the algorithm
backtracks. A backreference \i refers to the substring matched
to the corresponding capturing group (r)i, and attempts to
match the same substring if the capture had succeeded. If the
capture had not succeeded or the matching against the captured
substring fails, then the algorithm backtracks. For example,
let us consider the regex ([0-9])1([A-Z])2\1\2. Here,
\1 and \2 refer to the substring matched by [0-9] and
[A-Z], respectively. The language represented by the regex
is {abab | a ∈ [0-9] ∧ b ∈ [A-Z]}. Capturing groups in
practice often do not have explicit indexes, but we write them
here for clarity. We assume without loss of generality that each
capturing group always has a corresponding backreference and
vice versa. We assume that capturing group indexes are always
distinct in a regex.
A positive (resp. negative) lookahead (?=r) (resp. (?!r))
attempts to match r without any character consumption, and
proceeds if the match succeeds (resp. fails) and backtracks
otherwise. A fixed-string positive (resp. negative) lookbehind
(?<=x) (resp. (?<!x)) looks back (i.e., toward the left), at-
tempts to match x without any character consumption, and
proceeds if the match succeeds (resp. fails) or otherwise
backtracks. Fixed-string lookbehinds are supported by major
regex engines such as those in Perl and Python [33]. Note that
most regex engines do not support general lookbehinds [25].
B. Formal Semantics and Vulnerability
We now formally define the semantics of regexes. Tradi-
tionally, the language of pure regexes is defined by induc-
tion on the structure of the expressions. However, such a
definition would be difficult for real-world regexes because
of the extended features and also unsuitable for formalizing
vulnerability because the notion concerns the complexity of
backtracking matching algorithms. To this end, we define the
semantics by the matching relation(cid:59) that models the behavior
of backtracking matching algorithms.
A matching relation is of the form (r,w, p,Γ)(cid:59) N where
p is a position on the string w such that 0 ≤ p ≤ |w|, Γ is
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
32062
((r) j,w, p,Γ)(cid:59) {(pi,Γi[ j (cid:55)→ w[p..pi)]) | (pi,Γi) ∈ N }
Γ(i) ̸= ⊥
(CAPTURING GROUP)
(BACKREFERENCE)
(r,w, p,Γ)(cid:59) N
(Γ(i),w, p,Γ)(cid:59) N
(\i,w, p,Γ)(cid:59) N
Γ(i) = ⊥
(\i,w, p,Γ)(cid:59) /0
(BACKREFERENCE FAILURE)
(r,w, p,Γ)(cid:59) N
(NEGATIVE LOOKAHEAD)
N ′ = ite(N ̸= /0,{(p,Γ)}, /0)
N ′ = ite(N ̸= /0, /0,{(p,Γ)})
((?=r),w, p,Γ)(cid:59) {(p,Γ′) | ( ,Γ′) ∈ N } (POSITIVE LOOKAHEAD)
(r,w, p,Γ)(cid:59) N
(x,w[p−|x|..p),0,Γ)(cid:59) N
(x,w[p−|x|..p),0,Γ)(cid:59) N
Fig. 1: Selected rules of the matching relation (cid:59)
((?!r),w, p,Γ)(cid:59) N ′
((?<=x),w, p,Γ)(cid:59) N ′
((?<!x),w, p,Γ)(cid:59) N ′
N ′ = ite(N ̸= /0, /0,{(p,Γ)})
(NEGATIVE LOOKBEHIND)
(POSITIVE LOOKBEHIND)
a function that maps each capturing group index to a string
captured by the corresponding capturing group, and N is a set
of matching results. A matching result is a pair of a position
and a capturing group function. Roughly, (r,w, p,Γ) is read: a
regex r tries to match the string w from the position p, with
the information about capturing groups Γ. For example, for
the regex a on the strings a and b, the matching relations are
(a,a,0, /0) (cid:59) {(1, /0)} and (a,b,0, /0) (cid:59) /0, respectively. From
these, the matching relation of the regex (a|b) on the string a
is ((a|b),a,0, /0)(cid:59) {(1, /0)}.
Figure 1 shows some rules for deducing the matching
relation. For space, we show only the rules for handling the
extended features, deferring the full rules to the Appendix. The
rules are inspired by [34] who have given natural-semantics-
style rules for pure regexes and parsing expression grammars.
However, to our knowledge, we are the first to give the formal
semantics of real-world regexes in this style and use it to
formalize vulnerability.
In the rule (CAPTURING GROUP), we first get the matching
result N from matching w against r at the current position p.
And for each matching result (pi,Γi) ∈ N (if any), we record
the matched substring w[p..pi) in the corresponding capturing
group map Γi at the index i. The rule (BACKREFERENCE)
looks up the captured substring and tries to match it with
the input at
the current position. The match fails if the
corresponding capture has failed as stipulated by the rule
(BACKREFERENCE FAILURE).
In the rule (POSITIVE LOOKAHEAD), the expression r is
matched against the given string w at the current position
p to obtain the matching results N . Then, for every match
result (p′,Γ′) ∈ N (if any), we reset the position from p′
to p. This models the behavior of lookaheads which does
not consume the string. The rule (NEGATIVE LOOKAHEAD)
is similar, except that we reset and proceed when there is no
match. Note that captures made inside of a negative lookahead
cannot be referred outside of the lookahead, which agrees with
the behavior of regex engines in practice. The rules (POSITIVE
LOOKBEHIND) and (NEGATIVE LOOKBEHIND) for handling
fixed-string lookbehinds are self-explanatory.
Definition III.1 (Language). The language of a regex r is
defined as L(r) = {w | (r,w,0, /0)(cid:59) N ∧∃Γ.(|w|,Γ) ∈ N }.
We show some examples of matchings. For brevity, we omit
capturing group information from Examples III.1 and III.2
because it is not used there, i.e., it is always /0.
Example III.1. The matching of the regex (a∗)∗ on the string
ab is as follows:
1 < |ab| b /∈ {a}
(a,ab,1)(cid:59) /0
(a∗,ab,1)(cid:59) {1}
((a∗)∗,ab,0)(cid:59) {0,1}
0 < |ab| a ∈ {a}
(a,ab,0)(cid:59) {1}
The regex rejects the string because |ab| = 2 /∈ {0,1}.
Example III.2. The matching of ((?=a)∗)∗ on ab is:
(a∗,ab,0)(cid:59) {0,1}
1 < |ab| b /∈ {a}
(a,ab,1)(cid:59) /0
((a∗)∗,ab,1)(cid:59) {1}
0 < |ab| a ∈ {a}
(a,ab,0)(cid:59) {1}
((?=a),ab,0)(cid:59) {0}
((?=a)∗,ab,0)(cid:59) {0}
((((?=a)∗)∗),ab,0)(cid:59) {0}
The regex rejects the string because |ab| = 2 /∈ {0}.
Example III.3. The matching of (a∗)1\1 on aa is:
A B0 B1 B2
(a∗)1\1(cid:59) {(0,Γ0), (2,Γ1)}
where Γ0 = {(1,ε)}, Γ1 = {(1,a)}, Γ2 = {(1,aa)} and the
subderivation A is:
0 < |aa| a ∈ {a}
(a,aa,0, /0)(cid:59) {(1, /0)}
C1
C0
(a∗,aa,2, /0)(cid:59) /0
(a∗,aa,1, /0)(cid:59) {(1, /0), (2, /0)}
(a∗,aa,0, /0)(cid:59) {(0, /0), (1, /0), (2, /0)}
((a∗)1,aa,0, /0)(cid:59) {(0,Γ0), (1,Γ1), (2,Γ2)}
of
the
roots
are,
and
the
C0, C1
subderivations B0, B1, B2,
respectively,
(\1,aa,0,Γ0) (cid:59) {(0,Γ0)},
(\1,aa,1,Γ1) (cid:59) {(2,Γ1)},
(\1,aa,2,Γ2) (cid:59) /0,
(a,aa,1, /0) (cid:59) {(2, /0)}, (a,aa,2, /0) (cid:59) /0. The regex accepts