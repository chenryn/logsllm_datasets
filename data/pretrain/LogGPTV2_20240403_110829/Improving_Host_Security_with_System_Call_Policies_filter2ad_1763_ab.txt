creating good policies increases with the complexity of
the policy language.
Our deﬁnition of a good policy is a policy that allows
only those actions necessary for the intended function-
260
12th USENIX Security Symposium 
USENIX Association
Policy: /usr/sbin/named, Emulation: native
native- sysctl: permit
native-accept: permit
native-bind: sockaddr match "inet-*:53" then permit
native-break: permit
native-chdir: filename eq "/" then permit
native-chdir: filename eq "/namedb" then permit
native-chroot: filename eq "/var/named" then permit
native-close: permit
native-connect: sockaddr eq "/dev/log" then permit
...
Figure 1: Partial policy for the name daemon. Policies can be improved iteratively by appending new policy statements.
The policy statement for bind allows the daemon to listen for DNS requests on any interface.
ality of the application but that denies everything else.
Clearly, we can construct a policy that matches our
deﬁnition by enumerating all possible actions that an
application needs for correct execution. If an action is
not part of that enumeration, it is not allowed.
In the following, we show how our policy language
facilitates policy construction. The policy language is
designed to be simple. Each policy statement can be
evaluated by itself, thus it is possible to extend a policy
by appending new policy statements. The major ben-
eﬁt of this approach is that a policy can be generated
iteratively.
We create policies automatically by running an ap-
plication and recording the system calls that it exe-
cutes. We translate the system call arguments and
canonically transform them into policy statements for
the corresponding system calls. When an application
attempts to execute a system call during the training
run, it is checked against the existing policy and if not
covered by it, a new policy statement that permits this
system call is appended to the policy. Unlike intrusion
detection systems that analyze only sequences of sys-
tem call names [16, 21], our policy statements capture
the complete semantics of a system call and are not
subject to evasion attacks [36].
On subsequent runs of the application, the auto-
matically created policy is used. For some applications
that create random ﬁle names, it is necessary to edit
the policies by hand to account for nondeterminism.
When generating policies automatically, we assume
that the application itself does not contain malicious
code and that it operates only with benign data. Oth-
erwise, the resulting policies might permit undesirable
actions.
To address cases for which our assumptions do not
hold or for which it is impossible to exercise all code
paths in a training run, we use interactive policy gener-
ation. Interactivity implies a user needs to make pol-
icy decisions when the current policy does not cover
the attempted system call. When a policy decision is
required by the user, she is presented with a graphical
notiﬁcation that contains all relevant information; see
Figure 2. She then either improves the current policy
by appending a policy statement that covers the cur-
rent system call, terminates the application, or decides
to allow or deny the current system call invocation.
Figure 2: A graphical notiﬁcation assists the user when a
policy decision is required. A user may decide to allow or
deny the current system call or to reﬁne the policy.
If we do not exercise all possible code paths, au-
tomatic policy generation does not enumerate all le-
gitimate actions of an application and by itself is not
suﬃcient to create a good policy. However, it provides
a base policy that covers a subset of necessary actions.
In conjunction with interactive policy generation, we
iteratively reﬁne the policy by enumerating more valid
actions until the policy is good.
The system assists the user by oﬀering generic policy
templates that can be used as a starting point. Once
an initial policy has been created, policy notiﬁcations
appear only when an attempted operation is not cov-
ered by the conﬁgured policy. This might indicate that
USENIX Association
12th USENIX Security Symposium 
261
a new code path is being exercised, or that a security
compromise is happening. The user may either permit
the operation or deny and investigate it.
Once a security policy for an application has been
ﬁnalized, automatic policy enforcement may be em-
ployed. In that case, the user is not asked for a pol-
icy decision when an application attempts to execute a
system call that is not covered by the policy. Instead,
the system call is denied and an error code returned to
the application. The errant attempt is logged by the
operating system.
changing the uid and gid of a process. The change is
permanent and the process cannot recover those privi-
leges later. If an application occasionally needs special
privileges throughout its lifetime dropping privileges is
not an option. In this case, privilege elevation becomes
especially useful. For example, the ntpd daemon syn-
chronizes the system clock. Changing system time is
a privileged operation and ntpd retains root privileges
for its whole lifetime. A recent remote root vulnerabil-
ity [17] could have been prevented with single system
call privilege elevation.
4.3 Privilege Elevation
Beyond restricting an application to its expected be-
havior, there are situations in which we would like to
increase its privilege. In Unix, there are many system
services and applications that require root privilege to
operate. Often, higher privilege is required only for a
few operations. Instead of running the entire applica-
tion with special privilege, we elevate the privilege of a
single system call. The motivation behind privilege ele-
vation is the principle of least privilege: every program
and every user should operate using the least amount
of privilege necessary to complete the job [33].
To specify that certain actions require elevated priv-
ilege, we extend the policy language to assign the de-
sired privilege to matching policy statements. Systrace
starts the program in the process context of a less priv-
ileged user and the kernel raises the privilege just be-
fore the speciﬁed system call is executed and lowers it
directly afterwards.
As every user may run their own policy daemon,
privilege elevation is available only when the Systrace
policy daemon runs as root. Otherwise, it would be
possible for an adversary to obtain unauthorized privi-
leges by creating her own policies. Identifying the priv-
ileged operations of setuid or setgid applications allows
us to create policies that elevate privileges of those op-
erations without the need to run the whole application
at an elevated privilege level. As a result, an adversary
who manages to seize control of a vulnerable applica-
tion receives only very limited additional capabilities
instead of full privileges.
The ping program, for example is a setuid appli-
cation as it requires special privileges to operate cor-
rectly. To send and receive ICMP packets, ping cre-
ates a raw socket which is a privileged operation in
Unix. With privilege elevation, we execute ping with-
out special privileges and use a policy that contains a
statement granting ping the privilege to create a raw
socket.
Unix allows an application to discard privileges by
5 Implementation
We now give an overview of the Systrace imple-
mentation. Systrace is currently available for Linux,
Mac OS X, NetBSD, and OpenBSD; we concentrate
on the OpenBSD implementation.
To help reason about the security of our implemen-
tation, simplicity is one of our primary goals. We keep
the implementation simple by introducing abstractions
that separate diﬀerent functionalities into their own
components. A conceptual overview of the system call
interception architecture is shown in Figure 3.
When a monitored application executes a sys-
tem call, the kernel consults a small in-kernel policy
database to check if the system call should be denied
or permitted without asking the user space daemon.
At this point, policy decisions are made without in-
specting any of the system call arguments. Usually,
system calls like read or write are always permitted.
The kernel communicates via the /dev/systrace de-
vice to request policy decisions from the daemon.
While processes may have diﬀerent policies, the ini-
tial policy for all system calls defers policy decisions to
a corresponding user space daemon. When the kernel
is waiting for an answer, it suspends the process that
requires a policy decision. If the process is awakened by
a signal before a policy decision has been received, the
kernel denies the current system call and returns an er-
ror. To enforce synchronization, each message from the
kernel carries a sequence number so that answers from
user space can be matched against the correct message.
The sequence number ensures that a user space policy
decision is not applied to a system call other than the
one that caused the message.
When the user space policy daemon receives a re-
quest for a decision, it looks up the policy associated
with the process and translates the system call argu-
ments. To translate them, we register translators for
262
12th USENIX Security Symposium 
USENIX Association
Sandbox
Application
System Call
System Call
Result
System Call
Gateway
Entry
Exit
Notification
Policy decision
by user 
Policy
Systrace
Evaluate
Ask
Permit
Deny
Answer
Translate
Policy
 Decision
Userland
Kernel
Systrace
In-Kernel Policy
Permit
Ask
Deny
Figure 3: Overview of system call interception and policy decision. For an application executing in the sandbox, the
system call gateway requests a policy decision from Systrace for every system call. The in-kernel policy provides a fast
path to permit or deny system calls without checking their arguments. For more complex policy decisions, the kernel
consults a user space policy daemon. If the policy daemon cannot ﬁnd a matching policy statement, it has the option
to request a reﬁned policy from the user.
each argument in a system call. The translation of the
socket(AF INET, SOCK RAW, IPPROTO ICMP);
system call takes the following form:
socket: sockdom: AF INET, socktype: SOCK RAW
The third argument has not been translated because it
is irrelevant on the supported Unix systems.
While many argument translators are fairly simple,
translating ﬁlenames is more complicated. Filenames
in Unix are relative to the current working directory of
a process. In order to translate a ﬁlename into an un-
ambiguous absolute path name, we need to know the
current working directory of the monitored application
even if it is working in a chroot environment. Addition-
ally, all symbolic links in components of the ﬁlename
need to be resolved so that access restrictions imposed
by policy cannot be circumvented by an adversary1.
The translators also act as argument normalizers.
The argument replacement framework is used to re-
place the original arguments with their translation. As
the kernel sees only normalized arguments, an adver-
sary cannot use misleading arguments to circumvent a
security policy. The kernel makes the rewritten argu-
ments available to the monitored process via a look-
aside buﬀer before resuming execution of the system
1 For system calls like lstat or readlink, we resolve all but the
last component which may be a symbolic link as the operating
system does not follow it.
call. Furthermore, we disallow the process to follow
any symbolic links because no component of a normal-
ized ﬁlename contains symbolic links that should be
followed.
A policy statement that permits the creation of raw
sockets might look like this:
socket: socktype eq "SOCK RAW" then permit
The operators in the boolean expression use the
translated human-readable strings as input arguments.
We currently support eq, match, re and sub as op-
erators:
(cid:127) The eq operator evaluates to true only if the sys-
tem call argument matches the text string in the
policy statement exactly.
(cid:127) The match operator performs ﬁle name globbing
as found in the Unix shell. It can be used to match
ﬁles in directories for ﬁle name arguments.
(cid:127) The re operator uses regular expressions to match
system call arguments.
It is very versatile but
more expensive to evaluate than other operators.
(cid:127) The sub operator evaluates to true only if the sys-
tem call argument contains the speciﬁed substring.
If evaluating the policy for the current system call
results in either deny or permit, the policy daemon re-
USENIX Association
12th USENIX Security Symposium 
263
turns the answer to the kernel which then awakens the
sleeping process. Otherwise, the user monitoring the
applications is asked for a policy decision. The notiﬁ-
cation mechanism can be implemented independently
from the rest of the system and is currently either a
graphical user interface or a text prompt on the termi-
nal. At this point, the user can add new policy state-
ments to the policy.
Policies for system calls accessing the ﬁlesystems
tend to be similar. For example, the access, stat, and
lstat system calls all fulﬁll similar functionality. In or-
der to avoid duplication of policy, we introduce system
call aliasing to map system calls with similar function-
ality into a single virtual system call which is then used
for policy evaluation. Currently, fsread is used for sys-
tem calls that grant read access to ﬁlesystem objects,
and fswrite for system calls that cause change in the
ﬁlesystem. The open system call is mapped to fsread
or fswrite depending on the kind of ﬁlesystem access
that is indicated by its arguments. System call alias-
ing reduces the size of policies and simpliﬁes policy
generation.
It is possible to make policies more ﬂexible by us-
ing predicates. Policy statements are only evaluated if
their predicate matches. For example, to prevent root
access via the SSH daemon, a policy statement that
permits the execution of a shell could be predicated so
that it applies only to non-root users. In order to keep
track of a process’ uid and gid, the kernel sends infor-
mational messages to the policy daemon when those
values change.
The execve system call is treated specially. When
a process executes another application, its in-memory
image is replaced with the one of the executed pro-
gram. To support more ﬁne-grained policies, we can
set a new policy for the process. The policy is obtained
from the name of the executed application. As a re-
sult, one Systrace daemon may concurrently enforce
multiple policies for multiple processes.
Policies for diﬀerent applications are stored in a pol-
icy directory as separate ﬁles. Users may store their
own policies in a user speciﬁc policy directory. The
system administrator may also provide global policies
for all users. To sandbox applications, users start them
with the Systrace command line tool. Administrators
may assign a Systrace login shell to users to enforce
policy for all their applications.
6 Analysis
An adversary who takes control of a sandboxed ap-
plication may try to escape the sandbox by confusing
the policy enforcement tool and tricking it into allowing
actions that violate policy. Although many sandboxing
tools share common problems, we present novel solu-
tions to some of them and discuss inherent limitations
of policy systems based on system call interposition.
6.1 Security Analysis
To enforce security policies eﬀectively by system call
interposition, we need to resolve the following chal-
lenges:
incorrectly replicating OS semantics, resource
aliasing, lack of atomicity, and side eﬀects of denying
system calls [18, 34, 37]. We brieﬂy explain their nature
and discuss how we address them.
The sandboxing tool must track operating system
state in order to reach policy decisions. Systrace, for
example, must keep track of process uids and the ﬁle-
name of the program binary the monitored process is
executing. To avoid incorrectly replicating OS seman-
tics, our kernel-level implementation informs the Sys-
trace daemon about all relevant state changes.
Resource aliasing provides multiple means to ad-
dress and access the same operating system resource.
For example, on some Unix systems, it is possible to
gain access to ﬁles by communicating with a system
service or by using symbolic links in the ﬁlesystem to
create diﬀerent names for the same ﬁle. An adversary
may use these indirections to circumvent policy and
obtain unauthorized access. The system call interposi-
tion mechanism is unaware of system services that al-
low proxy access to operating system resources. When
creating policies that allow a sandboxed application to
contact such system services, we need to be aware of
the consequences. However, we can prevent aliasing
via symbolic links or relative pathnames as discussed
below.
Another problem is the lack of atomicity between
the time of check and the time of use that may cause
the mapping of name to resource to change between
policy decision and system call execution. An adver-
sary may cause such a state change that allows a pro-
cess to access a diﬀerent resource than the one origi-
nally approved, for example a cooperating process shar-
ing memory may rewrite system call arguments be-
tween policy check and execution.
Systrace solves both aliasing and atomicity problems
by normalizing the system call arguments. We provide
the normalized values to the operating system in such
a way that the name to resource mapping cannot be
changed by an adversary. For ﬁlenames, this includes
resolving all symbolic links and all relative paths. The
only exception are system calls like readlink, for which
we do not resolve the last component. As resolved ﬁle-
264
12th USENIX Security Symposium 
USENIX Association
names do not contain any symbolic links that should be
followed, the kernel denies the monitored process to fol-
low any symbolic links. Instead of placing the rewritten
arguments on the stack as done in MAPbox [1], we pro-
vide a read-only look-aside buﬀer in the kernel. Oth-
erwise, multi-threaded applications can change system
call arguments after the policy check.
As a result, evasion attacks [35, 36] are no longer
possible. System calls are allowed only if their argu-
ments match a statement in the policy and are denied
otherwise.
However, we need to take side eﬀects of denying sys-
tem calls into consideration. If we assume correct se-
curity policy, system calls are denied only if an appli-
cation attempts to do something that it should not.
As the behavior of many applications depends on the
error code returned to them, we can specify the error
code as part of the Systrace policy. Every system call
has its own set of valid return codes which does not
always include EINTR or EPERM. To avoid confusing ap-
plications, we allow policies to set their own error codes
instead of mandating a ﬁxed value2. For example, we
let the kernel return EACCESS for the stat system call
if the application should think that it is not permitted
to access a certain ﬁle. On the other hand, return-
ing ENOENT causes the application to think that the ﬁle
does not exist.
Furthermore, we address secure process detaching
and policy switching, problems that are often over-
looked. When an application executes a new program,
the operating system replaces the code that the pro-
cess is running with the executed program. If the new
program is trusted, we may wish to stop monitoring
the process that runs it. On the other hand, a new
program also implies new functionality that could be
conﬁned better with a diﬀerent, more suitable policy.