为了得到一个不重复的随机数，我们使用了一个内循环来生成选择，并测试它
属组pick 中。
进行取整。这个脚本的核心部分是一个循环运行NUM次，
这里只有一个数组pick，用于保存已选择的随机数。每个数确保在希望的范围
个数。主例程首先检查是否提供了这些数据，如果没有提供则赋默认值。
和前面的例子不同，
下面是脚本lotto 的代码：
经被挑选的数。
们必须考虑重复性。换句话说，有可能重复挑选一个数，因此我们必须跟踪已
以设计一个循环按需要的次数来执行rand（）函数，其中困难的一个原因是我
使用lotto脚本必须执行多次“挑选一个”才能选出多个数。实际上，我们可
# 循环访问数组并打印挑选的结果
#
#利用时间和日期作为种子数，只执行一次
#
#测试命令行参数，NUM=$1,挑选多少个数
if (TOPNUM <= 0)
if (NUM <= 0)
BEGIN{
#主例程
# lotto - 
awk -v NUM=$1 -v TOPNUM=$2 ′
循环到有NUM个选择时
打印“Pick x of y"
srand()
printf("Pick %d of %d\n", NUM, TOPNUM)
NUM = 6
#TOPNUM=$2，一系列数中的最后一个
printf("\n")
 for (j in pick) 
for （j = 1; j <= NUM; ++j）
TOPNUM = 30
printf("%s ",pick[j])
QQ群：
pick[select] = select
#用循环寻找一个还没有被发现的数
 从y个数中挑选x个随机数
} while (select in pick)
do 1 
select = 1 + int(rand() * TOPNUM)
，这个程序需要两个命令行参数，
50192241
-217-
表示从y个数据中选择×
，并将 NUM个元素插入
乘以 TOPNUM 然后
第九章
函数
---
## Page 218
index (s, t)
gsub(r, s, t)
awk函数
表9-2：awk 的内置字符串函数
串处理语言，它的很多功能都起源于这些函数。表9-2 列出了awk中的字符串
内置字符串函数比算术函数更重要且更有趣。因为 awk 实质上是被设计成字符
字符串函数
个脚本使其能从文件中读入姓名列表，
是有序的数据。我们将不得不建立一个单独的数组以便用排序函数来排序：
函数。
lotto 程序在 BEGIN 块中处理每件事。
注意，pick 数组没有为排序做好准备，
写一个函数来排序数组中的元素。
能处理更普遍的问题，并将这种解决方案用于其他的程序。在后面，我们将编
select 赋给数组pick 中的一个元素。这将使将来的 in测试为真，使 do循环
是重复的，于是丢弃这个选择。如果 select in pick 为假，那么我们将把
们是否在数组pick内（使用in操作符比用循环在数组中比较下标要快）。当
对
问
最
继续。
（selectin pick）条件成立时，
管没必要把排序代码编写成一个函数，但这样做有许多意义。一个原因是你
了，数据没有排序。在我们讨论完用户定义函数时将显示排序例程的代码
# 创建用于排序的下标为数值的数组
521930２920２
Pick 7 of
$lotto 7 35
for
程序循环访问数组 pick 并打印它的元素。这个版本的lotto 程序有一个
你是否能看出重新运行它将得到什么结果：
(j in pick)
sortedpick[i++]= pick[j]
35
QQ群：
50192241
返回子串t在字符串s 中的位置，如果没有指定
的所有字符串。返回替换的个数。如果没有给出
在字符串t中用字符串s替换和正则表达式r匹配
S，
t，
描述
则返回0
默认$0
，说明已经找到相应的元素，
-218 -
，并为每个名字生成一个“快速挑选”
没有输入被处理。然而，
因为它的索引和它的值是相同的、而不
所以当前的选择
，你可以修订这
第九章
函数
---
## Page 219
下面将讨论3个基本的内置字符串函数：index（）、substr（）和丨ength 
行特殊处理，例如执行字符转换。
sprint（）函数使用和printf（）相同的格式说明，
toupper (s)
tolower (s)
substr (s, p, n)
sub(r, s,t)
intf(“fmt ”,expr)
split(s, a, sep)
以上循环给出的数从97到122，
一个数字转换为-个ASCII字符。
出来，
match(s, r)
spr
length(s)
C
”中讨论过。
for （i = 97; i <= 122; ++i）
而是返回一个字符串并可以赋给一个变量。
 nextletter = sprintf("%c", 
QQ群：
它允许你对字符串应用格式说明。Sprintf（）不是将结果打印
50192241
将字符串s 中的小写字符转换为大写，并返回新
将字符串s 中的所有大写字符转换为小写，并返回
返回字符串
如果成功则返回1，否则返回0，如果没有给出
在字符串t中用s 替换正则表达式r的首次匹配。
对 expr 使用 printf 格式说明 
用 FS。数组分隔和字段分隔采用同样的方式
使用字段分隔符 sep 将字符串 s 分解到数组 a 的元
位置；如果在s 中没有发现r，则返回0.设置
如果正则表达式r在s中出现，
返回字符串s 的长度，当没有给出 s 时，返回$0
新
素
RSTART 和RLENGTH 的值。
的长度 
默认为$0
中
这些数产生从a 到z的 ASCll字符。
例如，
-219.
二
s中从位置p开始最大长度为n的子
下面的例子使用 sprintf（）函数将
，它可以对输入记录或字段进
返回从p 开始剩余的字符
，在第七章“编写 awk脚
则返回出现的起始
第九章 
函数
---
## Page 220
以确定那个字母是否能在lower 中找到。如果CHAR不是O，那么可以用 CHAR
一个语句提取了第一个字段的第一个字母。条件语句使用index（）函数测试
这段程序创建了两个变量：upper 和丨ower，
这两个函数可以一期使用而且经常被一起使用，
还可以提供第三个参数来表示返回字符的个数。
给
pos 的值为 2.如果没有发现子串，函数index（）返回0。
语言不同的，在C语言中字符串的开始位置是0）。参见下面的例子：
（s，t）返回t在s中出现的最左边的位置。字符串的开始位置是1（这是和C
index（）和 substr（）函数都用于处理子串。给定字符串s，函数index
子串
没有区
定字符
#打印记录
#获取FIRSTCHAR在小写字母数组中的位置，如果为O，忽略
#初始化字符串
area_code = substr("707-555-1111", 1, 3)
 phone = substr ("707-555-1111", 5) 
pos = index("Mississippi", "is")
#
#
得到第一个单词的首字母
对于每个输入行
号的电话号码。
邮
FIRSTCHAR = substr ($1， 1， 1)
if (CHAR = index(lower, 
s，substr（s，p）返回从位置p开始的字符。下面的例子生成一
lower = "abcdefghijklmnopqrstuvwxyz"
 print $0
QQ群：
－将第一个单词的首字母改为大写
#
#
1 = substr(upper, CHAR, 1) substr($1, 2)
大写字母
改变 $1，
50192241
用位置来检索
220
FIRSTCHAR))
分别包含大写字母和小写字母。
想下一个例子一样，这个例子
，下一个例子只返回区号：
第九章 函数
我
---
## Page 221
三个可选的参数指定的字符串是将被替换的目标。如果没有第三个参数，将
的字符串。正则表达式可以用一个变量来给出，
这两个函数都至少需要两个参数。第一个参数是一个正则表达式（用斜杠包围
替换。这使 gsub（）和 sed 中用g（全局的）标志的替换命令相同。
可以实现输入字符串中所有位置的替换，而 sub（）函数只实现第一个位置的
awk 提供了两个替换函数：sub（）和 gsub（）。
替换函数
length（）产生断行。
在第十三章“脚本的汇总”中包含一个程序，当行的宽度超过80列时使用函数
的数据时，
一种处理断行的方法就是使用length（）函数得到每个字段的长度，
函数length（）经常用于计算当前输入记录的长度，以决定是否需要断行。
着）：
度)。
（$O）（正巧，如果函数length（）被调用时没有给出参数，它将返回$O的长
串中有多少个字符。例如，要计算当前输入记录的长度，
观察在前面章节中出现的 awkro程序，我们会注意到程序有可能产生超过 80 个
效
字
字符串长度
大写字母，或者反过来转换。
稍
的其他字段）。Printf语句打印出了变化了的记录。我们来看执行情况：
可以被正常输出（如果对一个变量赋值，则必须输出这个变量并输出这个记
像这里这样，
开始剩余的所有字母。两个 substr（）函数的返回值被连接在一期并赋给$1.
个字段的大写字母而第二个得到第一个字段的剩余部分，即提取从第二个字母
从upper 中提取大写字母。这里调用了两个 substr（）函数：第一个检索第一-
率更高，
符的行。毕竟描述都非常长，
Dale
dale
Root
root user
$ caps
Tom
用于和一个模式匹配；而第二个参数是一个字符串，
 user
我们就可以指定一个换行。
通过累计这些长度，
 为一个字段赋值是一种新的手法，
QQ群：
50192241
当一个新的字段使得行的总长度超多某个特定
-221-
在这种情况下将省略斜杠。
但是这有额外的好处，即记录
两者之间的区别是 gsub（）
我们可以使用丨ength
用来替换模式匹i
第九章 
这样可能
函数
宗
录
---
## Page 222
现在用替换函数重写上面的程序：
do. out l ine。
在第四章“编写 sed脚本”中，我们给出了下面的 sed 脚本，命名为
operating system"
如果输入是“the UNIX operating system”，
达式。
一个反斜杠“\”
匹配的字符串代替。用“\&”将输出一个字符“&”（记住，要在字符串中加入
和 sed 一样，
条件语句测试 gsub（）返回的值，只有发生变化时当前输入行才被打印。
例如，下面的例子使用 gsub（）将所有出现的“UNIX”用“POSIX”替代。
个结果来确定是否执行了替换操作。
运行成功时总是返回1，在不成功时两个函数都返回0.因此，
换后函数返回替换后的新串。
替换函数直接改变指定的字符串。
前的输入记录（$O）作为被替换的字符串。
“记住”
if (sub(/^\. Bh /, 
gsub(/ "/,
s/^\.Bh /··B. /p'
if (sub(/~\. Ah /,
awk
s/~\. Se
s/ "//g
if (gsub(/UNIX/，
sed
gsub (/UNIX/,
-n
”前面的正则表达式，
print
/Chapter /p
如果在替换字符串中出现了一个“&”字符，它将被与正则表达式
QQ群：
则必须输入两个反斜杠）
"\\fB&\\fR")
"\t\tB.")） print
"POSIX"))
"\tA.")）print 
"Chapter ")） print
50192241
，因此我们不能用语法“\”来引用最后的正则表
但替换函数实际上返回替换的数量。
，假设函数能正常工作，
-222
。注意，awk 和 sed 不一样，不能
，输出将是“the\fBUNIX\Fr
你或许希望当发生替
，可以通过测试这
第九章函数
在sub（）
---
## Page 223
串和变量串连接在一起作为函数 sub（）的一个参数的。
数器初始化为0.显然，你可以按需要设立任意多个层。注意我们是如何将字符
的标题计数器初始化为零。和顶层标题“.Ah”相关的操作将第二层标题的计
通过在每次做替换时递增一个变量来完成。
章编号作为“.se”宏的第一个参数被读取，也就是行的第二个字段。编号方案
必要的，
在这个版本中，我们为每个标题编写了它们自己的模式匹配规则。这虽然不是
经过修订的 awk 脚本：
做更多的事。例如，我们可以给标题编号来代替使用字母表中的字母。下面)
二版中，再次确定运行时间表明使用不同的实现工具其性能不同，
Dale 比较了这两个脚本的运行时间，
这两个脚本完全等价的，都仅打印出那些变化了的行。在这本书的第一版中，
Chapter 2 Understanding Basic Operations
$ do.outline ch02 
/~\. Se/ {
gsub(/ “/, "")
awk ′ # do. outline -- number headings in chapter.
^\.Ah/ {
但好像更高效，
print
（"… yq++" ye " yo\\“/ ua\/)qns 
next
print
sub(/^\.Ah /, "\t " ch "." ++ah " ")
next
print
bh =
ch =
￥好
$*
bh = 0 
$2
0
QQ群：
因为一旦应用了一个规则，
50192241
- 223 -
和他预期的相同，
和章一级标题相关的操作将下一级