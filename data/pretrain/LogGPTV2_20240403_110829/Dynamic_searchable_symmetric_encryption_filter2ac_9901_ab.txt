and return the appropriate encrypted ﬁles.
The data can be viewed as a sequence of n ﬁles f =
(f1, . . . , fn), where ﬁle fi is a sequence of words (w1, . . . , wm)
from a universe W . We assume that each ﬁle has a unique
identiﬁer id(fi). The data is dynamic, so at any time a ﬁle
may be added or removed. We note that the ﬁles do not
have to be text ﬁles but can be any type of data as long as
there exists an eﬃcient algorithm that maps each document
to a ﬁle of keywords from W . Given a keyword w we denote
by fw the set of ﬁles in f that contain w. If c = (c1, . . . , cn)
is a set of encryptions of the ﬁles in f , then cw refers to the
ciphertexts that are encryptions of the ﬁles in fw.
A limitation of all known SSE constructions (including
ours) is that the tokens they generate are deterministic, in
the sense that the same token will always be generated for
the same keyword. This means that searches leak statisti-
cal information about the user’s search pattern. Currently,
it is not known how to design eﬃcient SSE schemes with
probabilistic trapdoors.
Recall that we consider dynamic SSE so the scheme must
allow for the addition and removal of ﬁles. Both of these
operations are handled using tokens. To add a ﬁle f , the
client generates an add token τa and given τa and γ, the
provider can update the encrypted index γ. Similarly, to
delete a ﬁle f , the client generates a delete token τd, which
the provider uses to update γ.
Definition 3.1
(Dynamic SSE). A dynamic index-based
SSE scheme is a tuple of nine polynomial-time algorithms
SSE = (Gen, Enc, SrchToken, AddToken, DelToken, Search, Add,
Del, Dec) such that:
K ← Gen(1k): is a probabilistic algorithm that takes
as input a security parameter k and outputs a secret
key K.
(γ, c) ← Enc(K, f ):
is a probabilistic algorithm that
takes as input a secret key K and a sequence of ﬁles
f . It outputs an encrypted index γ, and a sequence of
ciphertexts c.
τs ← SrchToken(K, w): is a (possibly probabilistic) al-
gorithm that takes as input a secret key K and a key-
word w. It outputs a search token τs.
(τa, cf ) ← AddToken(K, f ): is a (possibly probabilistic)
algorithm that takes as input a secret key K and a ﬁle
f . It outputs an add token τa and a ciphertext cf .
τd ← DelToken(K, f ): is a (possibly probabilistic) al-
gorithm that takes as input a secret key K and a ﬁle
f . It outputs a delete token τd.
Iw := Search(γ, c, τs): is a deterministic algorithm that
takes as input an encrypted index γ, a sequence of ci-
phertexts c and a search token τs. It outputs a sequence
of identiﬁers Iw ⊆ c.
(γ ′, c′) := Add(γ, c, τa, c): is a deterministic algorithm
that takes as input an encrypted index γ, a sequence
of ciphertexts c, an add token τa and a ciphertext c.
It outputs a new encrypted index γ ′ and sequence of
ciphertexts c′.
(γ ′, c′) := Del(γ, c, τd):
is a deterministic algorithm
that takes as input an encrypted index γ, a sequence of
ciphertexts c, and a delete token τd. It outputs a new
encrypted index γ ′ and new sequence of ciphertexts c′.
f := Dec(K, c): is a deterministic algorithm that takes
as input a secret key K and a ciphertext c and outputs
a ﬁle f .
A dynamic SSE scheme is correct if for all k ∈ N, for all
keys K generated by Gen(1k), for all f , for all (γ, c) output
by Enc(K, f ), and for all sequences of add, delete or search
operations on γ, search always returns the correct set of
indices.
Intuitively, the security guarantee we require from a dy-
namic SSE scheme is that (1) given an encrypted index γ
and a sequence of ciphertexts c, no adversary can learn any
967partial information about the ﬁles f ; and that (2) given, in
addition, a sequence of tokens τ = (τ1, . . . , τn) for an adap-
tively generated sequence of queries q = (q1, . . . , qn) (which
can be for the search, add or delete operations), no adversary
can learn any partial information about either f or q.
This exact intuition can be diﬃcult to achieve and most
known eﬃcient and non-interactive SSE schemes [15, 5, 8]
reveal the access and search patterns.2 We therefore need
to weaken the deﬁnition appropriately by allowing some lim-
ited information about the messages and the queries to be
revealed to the adversary. To capture this, we follow the ap-
proach of [8] and [6] and parameterize our deﬁnition with a
set of leakage functions that capture precisely what is being
leaked by the ciphertext and the tokens.
As observed in [8], another issue with respect to SSE secu-
rity is whether the scheme is secure against adaptive chosen-
keyword attacks (CKA2) or only against non-adaptive cho-
sen keyword attacks (CKA1). The former guarantees se-
curity even when the client’s queries are based on the en-
crypted index and the results of previous queries. The lat-
ter only only guarantees security if the client’s queries are
independent of the index and of previous results.
In the following deﬁnition, we extend the notion of CKA2-
security from [8] to the dynamic setting.
Definition 3.2
(Dynamic CKA2-security). Let SSE
= (Gen, Enc, SrchToken, AddToken, DelToken, Search, Add, Del,
Dec) be a dynamic index-based SSE scheme and consider the
following probabilistic experiments, where A is a stateful ad-
versary, S is a stateful simulator and L1, L2, L3 and L4 are
stateful leakage algorithms:
RealA(k): the challenger runs Gen(1k) to generate a key
K. A outputs f and receives (γ, c) such that (γ, c) ←
EncK (f ) from the challenger. The adversary makes
a polynomial number of adaptive queries {w, f1, f2}
and, for each query q, receives from the challenger ei-
ther a search token τs such that τs ← SrchTokenK (w),
an add token and ciphertext pair (τa, cf1 ) such that
(τa, cf1 ) ← AddTokenK(f1) or a delete token τd such
that τd ← DelTokenK(f2). Finally, A returns a bit b
that is output by the experiment.
IdealA,S (k): A outputs f . Given L1(f ), S generates and
sends a pair (γ, c) to A. The adversary makes a poly-
nomial number of adaptive queries q ∈ {w, f1, f2} and,
for each query q, the simulator is given either L2(f , w),
L3(f , f1) or L4(f , f2). The simulator returns an appro-
priate token τ and, in the case of an add operation, a
ciphertext c. Finally, A returns a bit b that is output
by the experiment.
We say that SSE is (L1, L2, L3, L4)-secure against adaptive
dynamic chosen-keyword attacks if for all ppt adversaries
A, there exists a ppt simulator S such that
|Pr [ RealA(k) = 1 ] − Pr [ IdealA,S (k) = 1 ]| ≤ negl(k).
Note that in addition to our inclusion of dynamic opera-
tions the diﬀerences between our deﬁnitions and the deﬁni-
tions of [8] are stylistic: we employ leakage functions in the
style of [6] rather than the history in the style of [8].
4. OUR CONSTRUCTION
Our scheme is an extension of the SSE-1 construction from
[8, 9] which is based on the inverted index data structure.
Though SSE-1 is practical (it is asymptotically optimal with
small constants), it does have limitations that make it un-
suitable for direct use in cryptographic cloud storage sys-
tems:
(1) it is only secure against non-adaptive chosen-
keyword attacks (CKA1) which, intuitively, means that it
can only provide security for clients that perform searches
in a batch; and (2) it is not explicitly dynamic, i.e., it can
only support dynamic operations using general and ineﬃ-
cient techniques.
Before discussing how we address these issues, we ﬁrst
recall a variant of the SSE-1 construction at a high level.
The construction is essentially the same as SSE-1 except that
the lookup table managed by indirect addressing is replaced
with a dictionary 3. The scheme makes use of a private-
key encryption scheme SKE = (Gen, Enc, Dec), two pseudo-
random functions F and G, an array As we refer to as the
search array and a dictionary Ts we refer to as the search
table. Here we assume SKE is anonymous in the sense that,
given two ciphertexts, one cannot determine whether they
were encrypted unders the same key 4.
The SSE-1 construction. To encrypt a collection of ﬁles
f , the scheme constructs for each keyword w ∈ W a list Lw.
Each list Lw is composed of #fw nodes (N1, . . . , N#fw ) that
are stored at random locations in the search array As. The
node Ni is deﬁned as Ni = hid, addrs(Ni+1)i, where id is the
unique ﬁle identiﬁer of a ﬁle that contains w and addrs(N)
denotes the location of node N in As. To prevent the size
of As from revealing statistical information about f , it is
recommended that As be of size at least |c|/8 and the unused
cells be padded with random strings of appropriate length.
For each keyword w, a pointer to the head of Lw is then
inserted into the search table Ts under search key FK1 (w),
where K1 is the key to the PRF F . Each list is then en-
crypted using SKE under a key generated as GK2 (w), where
K2 is the key to the PRF G.
To search for a keyword w, it suﬃces for the client to send
the values FK1 (w) and GK2 (w). The server can then use
FK1 (w) with Ts to recover the pointer to the head of Lw, and
use GK2 (w) to decrypt the list and recover the identiﬁers of
the ﬁles that contain w. As long as T supports O(1) lookups
(which can be achieved using a hash table), the total search
time for the server is linear in #fw, which is optimal.
Making SSE-1 dynamic. As mentioned above, the lim-
itations of SSE-1 are twofold: (1) it is only CKA1-secure
and (2) it is not explicitly dynamic. As observed in [6], the
ﬁrst limitation can be addressed relatively easily by requir-
ing that SKE be non-committing (in fact the CKA2-secure
SSE construction proposed in that work uses a simple PRF-
based non-committing encryption scheme).
The second limitation, however, is less straightforward to
2Two exceptions are the work of Goldreich and Ostrovsky
[16] which does not leak any information at all, and the SSE
construction described in [6] which leaks only the access and
the intersection patterns.
3This was ﬁrst used in [6] to avoid the use of FKS dictio-
naries [14].
4This allows us to encrypt each node of a list using a single
key as opposed to using unique keys as done in [8].
968Index
w1
w2
w3
f1
f2
f2
f2
f3
Search Table Ts
Deletion Table Td
FK1 (w1) −→ (4 || 1) ⊕ GK2 (w1)
FK1 (f1) −→ 1 ⊕ GK2 (f1)
FK1 (w2) −→ (0 || 2) ⊕ GK2 (w2)
FK1 (f2) −→ 5 ⊕ GK2 (f2)
FK1 (w3) −→ (5 || 0) ⊕ GK2 (w3)
FK1 (f3) −→ 4 ⊕ GK2 (f3)
f3
free −→ 6
0
1
2
3
4
5
6
7
w2
f2
f2
w3
w3
f3
free
Ad[7]
w1
f3
f1
w1
f2
w2
0
w1
f1
f3
w3
w3
f2
free
Ad[3]
w1
f2
Search Array As
f2
w1
f3
w1
0
Deletion Array Ad
Figure 1: A small example of a dynamic encrypted index.
overcome. The diﬃculty is that the addition, deletion or
modiﬁcation of a ﬁle requires the server to add, delete or
modify nodes in the encrypted lists stored in As. This is
diﬃcult for the server to do since: (1) upon deletion of a ﬁle
f , it does not know where (in A) the nodes corresponding to
f are stored; (2) upon insertion or deletion of a node from a
list, it cannot modify the pointer of the previous node since
it is encrypted; and (3) upon addition of a node, it does not
know which locations in As are free.
At a high level, we address these limitations as follows:
1. (ﬁle deletion) we add an extra (encrypted) data struc-
ture Ad called the deletion array that the server can
query (with a token provided by the client) to recover
pointers to the nodes that correspond to the ﬁle being
deleted. More precisely, the deletion array stores for
each ﬁle f a list Lf of nodes that point to the nodes
in As that should be deleted if ﬁle f is ever removed.
So every node in the search array has a correspond-
ing node in the deletion array and every node in the
deletion array points to a node in the search array.
Throughout, we will refer to such nodes as duals and
write N⋆ to refer to the dual of a node N.
2. (pointer modiﬁcation) we encrypt the pointers stored
in a node with a homomorphic encryption scheme.
This is similar to the approach used by van Liesdonk et
al in [23] to modify the encrypted search structure they
construct. By providing the server with an encryption
of an appropriate value, it can then modify the pointer
without ever having to decrypt the node. We use the
“standard” private-key encryption scheme which con-
sists of XORing the message with the output of a PRF.
This simple construction also has the advantage of be-
ing non-committing (in the private-key setting) which
we make use of to achieve CKA2-security.
3. (memory management) to keep track of which loca-
tions in As are free we add and manage extra space
comprising a free list that the server uses to add new