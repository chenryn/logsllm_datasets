The approach in this paper applies only to trusted pro-
grams. We make no assumptions about the relationship
between untrusted program and the system data. In fact,
we are certain that there is system data that should not
be accessed by most, if not all, untrusted programs. Note
that there is no advantage to verifying the compliance of
untrusted program, because the system does not depend
on untrusted programs to enforce its security goals. Such
programs have no special authority.
7 Related Work
Policy Analysis. Policies generally contain a consider-
able number of rules that express how elements in a given
USENIX Association  
17th USENIX Security Symposium 
331
SELinux
Label
etc t
etc t
etc t
passwd t,
groupadd t,
useradd t, chfn t
updfstab t,
ricci modstorage t,
ﬁrstboot t
postgresql t,kudzu t
Integrity
Integrity
Resolution
Method
ADD
ADD
Integrity
APP LABELS
The conﬂicting labels require access to the
the same ﬁle /etc/passwd
The ﬁrst two labels have legitimate rea-
sons to modify /etc/fstab. The last
type modiﬁes multiple ﬁles in /etc
The conﬂicting types need access to appli-
cation ﬁles labeled with system labels
crond does not need to write manual pages
Conﬂicting Labels
Type of Exception
Comment
system crond t
man t
ADD: Add conﬂicting types to the set of trusted readers (conﬁdentiality) or writers (integrity).
APP LABELS: The associated application requires access to a ﬁle that is application speciﬁc but was labeled using system
labels. Adding application speciﬁc labels to handle those ﬁles solves the conﬂict.
REMOVE: The permission requested is not required
Integrity
REMOVE
Table 4: Compliance Exceptions and Resolutions. This table details the exceptions to tamperproof compliance
presented in Table 3. It shows the list of conﬂicting, untrusted subjects and the resolution method, per case.
environment must be controlled. Because of the size of
a policy and the relationships that emerge from having
a large number of rules, it is difﬁcult to manually eval-
uate whether a policy satisﬁes a given property or not.
As a consequence, tools to automatically analyze pol-
icy are necessary. APOL [35], PAL [29], SLAT [10],
Gokyo [16] and PALMS [15] are some of the tools de-
veloped to analyze SELinux policies; however, each of
these tools focuses on the analysis of single security poli-
cies. Of these, only PALMS offers mechanisms to com-
pare policies; in particular it addresses compliance eval-
uation, but our approach to compliance is broader and
allows the compliance problem to be automated.
Policy Modeling. We need a formal model to reason
about the features of a given policy. Such a model should
be largely independent of particular representation of the
targeted policies and should enable comparisons among
different policies. Multiple models have been proposed
and each one of them deﬁnes a set of components that
need to be considered when translating a policy to an
intermediate representation. Cholvy and Cuppens [6] fo-
cus on permissions, obligations, prohibitions and provide
a mechanism to check regulation consistency. Bertino et
al. [3] focus on subjects, objects and privileges, as well
as the organization of these components and the set of
authorization rules that deﬁne the relationships among
components and the set of derived rules that may be gen-
erated because of a hierarchical organization. Kock et
al. [18] represent policies as graphs with nodes that rep-
resent components(processes, users, objects) and edges
that represent rules and a set of constraints that globally
applied to the system. In any case, policy modeling be-
comes a building block in the process of evaluating com-
pliance. Different policies must be translated to an inter-
mediate representation (a common model) so they can be
compared and their properties evaluated.
Policy Reconciliation. Policy compliance problems
may resemble policy reconciliation problems. Given two
policies A and B that deﬁne a set of requirements, a rec-
onciliation algorithm looks for a speciﬁc policy instance
C that satisﬁes the stated requirements. Policy compli-
ance in a general sense, i.e. ‘Given a policy A and a pol-
icy B, is B compliant with A?’ means ‘is any part of A
in conﬂict with B?’. Previous work [21] shows that rec-
onciliation of three or more policies is intractable. Com-
pliance is also a intractable problem since this would re-
quire to checking all possible paths in B against all possi-
ble paths in A. Although both of these problems are sim-
ilar in that they both test policy properties and are non-
tractable in general cases (no restrictions), they differ in
their inputs and expected outputs. While in the case of
reconciliation, an instance that satisﬁes the requirements
has to be calculated, in the case of compliance, policy
instances are given and one is evaluated against the other
one.
The
Policy Compliance.
security-by-contract
paradigm resembles our policy compliance model. It is
one of the mechanisms proposed to support installation
and execution of potentially malicious code from a third
party in a local platform. Third party applications are
expected to come with a security contract that speciﬁes
application behavior regarding security issues. The ﬁrst
step in the veriﬁcation process is checking whether the
behaviors allowed by the contract are also allowed by
the local policy [8]. In the most recent project involving
contract matching, contract and policy are security au-
tomatons and the problem of contract matching becomes
a problem of testing language inclusion for automatons.
While there is no known polynomial technique to test
language inclusion for non-deterministic automatons,
determining language inclusion for deterministic au-
tomatons is known to be polynomial [9]. One main
advantage of our representation is that we are verifying
policies that are actually implemented by the enforcing
332 
17th USENIX Security Symposium 
USENIX Association
mechanism, not high level statements that may not
be actually implemented because of the semantic gap
between speciﬁcation and implementation. In addition,
the enforcing mechanism is part of the architecture.
8 Conclusion
This work is driven by the idea of unifying application
and system security policies. Since applications and sys-
tems policies are independently developed, they use dif-
ferent language syntax and semantics. As a consequence,
it is difﬁcult to prove or disprove that programs enforce
system security goals. The emergence of mandatory ac-
cess control systems and security typed languages makes
it possible to automatically evaluate whether applications
and systems enforce common security goals. We reshape
this problem as a veriﬁcation problem: we want to eval-
uate if applications are compliant with system policies.
We found that compliance veriﬁcation involves two
tasks: we must ensure that the system protects appli-
cation from being tampered with, as well as verify that
the application enforces system security goals.
In or-
der to automate the mapping between the program pol-
icy and the system policy, we proposed the PIDSI (Pro-
gram Integrity Dominates System Data Integrity) ap-
proach. The PIDSI approach relies on the observation
that in general program objects are higher integrity than
system objects. We tested the trusted program core of the
SELinux system to see if its policy was compatible with
the PIDSI approach. We found that our approach accu-
rately represents the SELinux security design with a few
minor exceptions, and requires little or no feedback from
administrators in order to work.
Notes
1The program veriﬁcation (e.g., STL compilation) enforces the
complete mediation guarantee.
2At present, module policies are not included in Linux packages,
but RedHat, in particular, is interested in including SELinux module
policies in its rpm packages in the future [36].
3SELinux uses the term type for its labels, as it uses an extended
Type Enforcement policy [5].
4As described above,
this must be done manually now, via
semodule, but the intent is that when you load a package contain-
ing a module policy, someone will install the module policy.
5In this case, violating the conﬁdentiality of SSH keys enables a
large class of integrity attacks. This phenomenon has been discussed
more generally by Sean Smith [31].
References
[1] ANDERSON, J. P. Computer security technology planning study.
Tech. Rep. ESD-TR-73-51, The Mitre Corporation, Air Force
Electronic Systems Division, Hanscom AFB, Badford, MA,
1972.
[3] BERTINO, E., CATANIA, B., FERRARI, E., AND PERLASCA, P.
A logical framework for reasoning about access control models.
In Proceedings of SACMAT (2001).
[4] BIBA, K. J.
Integrity considerations for secure computer sys-
tems. Tech. Rep. MTR-3153, MITRE, April 1977.
[5] BOEBERT, W. E., AND KAIN, R. Y. A practical alternative to
heirarchical integrity policies. In Proceedings of the 8th National
Computer Security Conference (1985).
[6] CHOLVY, L., AND CUPPENS, F. Analyzing Consistency of Se-
curity Policies. In Proceedings of the 1997 IEEE Symposium on
Security and Privacy (Oakland, CA, USA, May 1997), pp. 103–
112.
[7] CLARK, D. D., AND WILSON, D. A comparison of military
and commercial security policies. In 1987 IEEE Symposium on
Security and Privacy (May 1987).
[8] DESMET, L., JOOSEN, W., MASSACCI, F., NALIUKA, K.,
PHILIPPAERTS, P., PIESSENS, F., AND VANOVERBERGHE, D.
A ﬂexible security architecture to support third-party applications
on mobile devices. In Proceedings of the ACM Computer Secu-
rity Architecture Workshop (2007).
[9] DRAGONI, N., MASSACCI, F., NALIUKA, K., SEBASTIANI, R.,
SIAHAAN, I., QUILLIAN, T., MATTEUCCI, I., AND SHAEFER,
C. Methodologies and tools for contract matching. Security of
Software and Services for Mobile Systems.
[10] GUTTMAN, J. D., HERZOG, A. L., RAMSDELL, J. D., AND
SKORUPKA, C. W. Verifying information ﬂow goals in Security-
Enhanced Linux. J. Comput. Secur. 13, 1 (2005), 115–134.
[11] HANSON, C. SELinux and MLS: Putting the pieces together. In
Proceedings of the 2nd Annual SELinux Symposium (2006).
[12] HICKS, B., KING, D., MCDANIEL, P., AND HICKS, M. Trusted
declassiﬁcation: High-level policy for a security-typed language.
In Proceedings of the 1st ACM SIGPLAN Workshop on Program-
ming Languages and Analysis for Security (PLAS ’06) (Ottawa,
Canada, June 10 2006), ACM Press.
[13] HICKS, B., RUEDA, S., JAEGER, T., AND MCDANIEL, P. From
trusted to secure: Building and executing applications that en-
force system security.
In Proceedings of the USENIX Annual
Technical Conference (2007).
[14] HICKS, B., RUEDA, S., JAEGER, T., AND MCDANIEL, P. Inte-
grating SELinux with security-typed languages. In Proceedings
of the 3rd SELinux Symposium (Baltimore, MD, USA, March
2007).
[15] HICKS, B., RUEDA, S., ST. CLAIR, L., JAEGER, T., AND MC-
DANIEL, P. A logical speciﬁcation and analysis for SELinux
MLS policy. In Proceedings of the ACM Symposium on Access
Control Models and Technologies (SACMAT) (Antipolis, France,
June 2007).
[16] JAEGER, T., EDWARDS, A., AND ZHANG, X. Managing access
control policies using access control spaces.
In SACMAT ’02:
Proceedings of the Seventh ACM Symposium on Access Control
Models and Technologies (2002), ACM Press, pp. 3–12.
[17] JAEGER, T., EDWARDS, A., AND ZHANG, X. Consistency anal-
ysis of authorization hook placement in the Linux security mod-
ules framework. ACM Transactions on Information and System
Security (TISSEC) 7, 2 (May 2004), 175–205.
[18] KOCK, M., MACINI, L., AND PARISI-PRESICCE, F. On the
In Pro-
speciﬁcation and evolution of access control policies.
ceedings of SACMAT (2001).
[19] LI, N., MAO, Z., AND CHEN, H. Usable mandatory integrity
protection for operating systems. In IEEE Symposium on Security
and Privacy (2007).
[20] MAYER, F., MACMILLAN, K., AND CAPLAN, D. SELinux by
Example. Prentice Hall, 2007.
[2] BELL, D. E., AND LAPADULA, L. J. Secure computer systems:
Uniﬁed exposition and multics interpretation. Tech. rep., MITRE
MTR-2997, March 1976.
[21] MCDANIEL, P., AND PRAKASH, A. Methods and limitations of
security policy reconciliation. ACM Transactions on Information
and System Security V, N (May 2006), 1–32.
USENIX Association  
17th USENIX Security Symposium 
333
[22] MCGRAW, G., AND FELTEN, E. Java Security. Wiley Computer,
1997.
[23] MYERS, A. C. JFlow: Practical mostly-static information ﬂow
control. In POPL ’99, pp. 228–241.
[24] MYERS, A. C., AND LISKOV, B. A decentralized model for
information ﬂow control. In Proceedings of the 16th ACM Sym-
posium on Operating System Principles (October 1997).
[25] MYERS, A. C., AND LISKOV, B. Protecting privacy using the
decentralized label model. ACM Transactions on Software Engi-
neering and Methodology 9, 4 (2000), 410–442.
[26] MYERS, A. C., NYSTROM, N., ZHENG, L., AND ZDANCEWIC,
S. Jif: Java + information ﬂow. Software release. Located at
http://www.cs.cornell.edu/jif, July 2001.
[27] Security-enhanced Linux. Available at http://www.nsa.
gov/selinux.
[28] POTTIER, F., AND SIMONET, V. Information Flow Inference for
ML. In Proceedings ACM Symposium on Principles of Program-
ming Languages (Jan. 2002), pp. 319–330.
[29] SARNA-STAROSTA, B., AND STOLLER, S. Policy analysis for
Security-Enhanced Linux. In Proceedings of the 2004 Workshop
on Issues in the Theory of Security (WITS) (April 2004), pp. 1–12.
Available at http://www.cs.sunysb.edu/˜stoller/WITS2004.html.
[30] SHANKAR, U., JAEGER, T., AND SAILER, R. Toward auto-
mated information-ﬂow integrity veriﬁcation for security-critical
applications. In Proceedings of the 2006 ISOC Networked and
Distributed Systems Security Symposium (NDSS’06) (San Diego,
CA, USA, Feb. 2006).
[31] SMITH, S. W. Outbound authentication for programmable secure
coprocessors. In European Symposium on Research in Computer
Security (ESORICS) (2002), pp. 72–89.
[32] STONY BROOK UNIVERSITY. COMPUTER SCIENCE DEPART-
MENT.
XSB: Logic programming and deductive database
system for Unix and Windows. Available at http://xsb.
sourceforge.net.
[33] SWAMY, N., CORCORAN, B., AND HICKS, M. Fable: A lan-
guage for enforcing user-deﬁned security policies. In In Proceed-
ings of the IEEE Symposium on Security and Privacy (Oakland),
May 2008. To appear.
[34] TRESYS TECHNOLOGY. SELinux Policy Server. Available at
http://www.tresys.com/selinux/selinux policy server.
[35] TRESYS TECHNOLOGY. SETools - policy analysis tools for
SELinux. available at http://oss.tresys.com/projects/setools.
[36] WALSH, D.
SELinux Mailing List. http://www.
engardelinux.org/modules/index/list_
archives.cgi?list=selinu%x&page=0609.
html&month=2007-12, December 2007.
[37] The X Foundation: http://www.x.org.
334 
17th USENIX Security Symposium 
USENIX Association