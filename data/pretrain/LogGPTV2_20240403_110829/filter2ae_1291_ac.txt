攻击的基本思想是将包含目标地址从内存加载的间接分支的受害代码作为目标，并将包含目标地址的缓存行清除到主内存。
然后，当CPU到达间接分支时，它不会知道跳转的真正目的地，并且它将不能计算真正的目的地，直到它将高速缓存行加载回CPU为止，这通常需要花费几百个周期。
因此，通常有超过100个周期的时间窗口，其中CPU将基于分支预测推测性地执行指令。
## Haswell分支预测内部
英特尔处理器实施的分支预测内部部分已经发布; 然而，让这种攻击正常工作需要进一步的实验来确定更多细节。
本节重点介绍从Intel Haswell Xeon CPU实验派生的分支预测内部结构。
Haswell似乎有多种分支预测机制，工作方式非常不同：
  * 通用分支预测器，每个源地址只能存储一个目标; 用于各种跳转，如绝对跳转，相对跳转等。
  * 专门的间接调用预测器，可以为每个源地址存储多个目标; 用于间接呼叫。
  * （根据英特尔的优化手册，还有一个专门的返回预测器，但是我们还没有详细分析，如果这个预测器可以用来可靠地转储出一部分虚拟机进入的调用栈，非常有趣。）
### 通用预测器
正如先前研究中所记录的，通用分支预测器仅使用源指令最后一个字节地址的低31位进行预测。
例如，如果跳转从0x4141.0004.1000到0x4141.0004.5123存在分支目标缓冲区（BTB）条目，通用预测器也将使用它来预测从0x4242.0004.1000跳转。  
当源地址的较高位如此不同时，预测目标的较高位与它一起改变，在这种情况下，预测的目的地址将是0x4242.0004.5123，显然这个预测器不会存储完整的绝对目标地址。
在使用源地址的低31位查找BTB条目之前，使用XOR将它们折叠在一起。 具体而言，以下几位被折叠在一起：  
换句话说，如果一个源地址与这个表的一行中的两个数字异或，那么在执行查找时，分支预测器将无法将结果地址与原始源地址区分开来。  
例如，分支预测器可以区分源地址0x100.0000和0x180.0000，也可以区分源地址0x100.0000和0x180.8000，但不能区分源地址0x100.0000和0x140.2000
或源地址0x100.0000和0x180.4000。 在下文中，这将被称为别名源地址。
当使用别名源地址时，分支预测器仍然会预测与未混淆源地址相同的目标。 这表明分支预测器存储截断的绝对目标地址，但尚未验证。
根据观察到的不同源地址的最大前向和后向跳转距离，目标地址的低32位可以存储为绝对32位值，并附加一个bit，指定从源跳转到目标是否跨越2^32边界;
如果跳转跨越这样的边界，则源地址的31 bit确定指令指针的高位一半是应该递增还是递减。
### 间接调用预测器
该机制的BTB查找的输入似乎是：
  * 源指令地址的低12位（我们不确定它是第一个还是最后一个字节的地址）或它们的一个子集。
  * 分支历史缓冲区状态。
如果间接调用预测器无法解析分支，则由通用预测变量解析。英特尔的优化手册暗示了这种行为：“间接调用和跳转，它们可能被预测为具有单调目标或具有根据最近程序行为而变化的目标。”
分支历史缓冲区（BHB）存储关于最后29个采取分支的信息（基本上是最近控制流程的指纹）并用于更好地预测可能有多个目标的间接调用。
BHB的更新功能的工作原理如下（伪代码; src 是源指令最后一个字节的地址，dst 是目标地址）：
    void bhb_update(uint58_t *bhb_state, unsigned long src, unsigned long dst) {
    *bhb_state > 6;
    *bhb_state ^= (src & 0xc00) >> (10 - 2);
    *bhb_state ^= (src & 0xc000) >> (14 - 4);
    *bhb_state ^= (src & 0x30) > (12 - 10);
    *bhb_state ^= (src & 0x30000) >> (16 - 12);
    *bhb_state ^= (src & 0xc0000) >> (18 - 14);
    }
当用于BTB访问时，BHB状态的某些位似乎用XOR进一步折叠在一起，但精确的折叠功能尚未被理解。
BHB很有趣，有两个原因。 首先，需要关于其近似行为的知识，以便能够准确地引起间接调用预测器中的冲突。
但它也允许在任何可重复的程序状态下抛出BHB状态，攻击者可以在超级调用后直接执行代码 - 例如攻击管理程序时。
然后可以使用转储的BHB状态来指导管理程序，或者如果攻击者可以访问管理程序二进制文件，则确定管理程序加载地址的低20位（在KVM的情况下：加载低20位
的kvm-intel.ko地址）。
### 逆向工程分支预测器内部
本小节描述了我们如何逆向Haswell分支预测器的内部结构。有些内容是从内存中写下来的，因为我们没有详细记录我们做的事情。
我们最初尝试使用通用预测器对内核执行BTB注入，使用先前研究中的知识，即通用预测器仅查看源地址的下半部分，并且仅存储部分目标地址。 这种工作 -然而，注射成功率非常低，低于1％。 （这是我们在方法2的初始PoC中使用的方法，针对在Haswell上运行的修改后的虚拟机监控程序。）
我们决定编写一个用户空间测试用例，以便能够更轻松地测试不同情况下的分支预测器行为。
基于分支预测器状态在超线程之间共享的假设[10]，我们编写了一个程序，其中两个实例分别固定到在特定物理内核上运行的两个逻辑处理器中的一个，其中一个实例尝试执行分支注入，而另一个实例测量分支注入成功的频率。
这两个实例都是在禁用ASLR的情况下执行的，并且具有相同地址的相同代码。  
注入过程对访问（每个进程）测试变量的函数执行间接调用;测量过程对函数进行间接调用，该函数根据时序测试每个进程的测试变量是否被缓存，然后将其逐出
使用CLFLUSH。 这两个间接呼叫都是通过相同的呼叫站点执行的。
在每次间接调用之前，使用CLFLUSH将存储在内存中的函数指针刷新到主内存以扩大推测时间窗口。  
此外，由于英特尔优化手册中提及“最近的程序行为”，因此总是采用的一组条件分支插入到间接调用之前。
在这个测试中，注入成功率高于99％，为我们今后的实验奠定了基础。  
然后我们试图找出预测方案的细节。 我们假设预测方案使用某种全局分支历史缓冲区。
为了确定分支信息保持在历史缓冲区中的持续时间，仅在两个程序实例中的一个中采用的条件分支被插入在一系列始终采用的条件跳转的前面，则总是采用的条件跳转（N）的数量是变化的。
结果是，对于N = 25，处理器能够区分分支（误预测率低于1％），但是对于N = 26，它没有这样做（错误预测率超过99％）。  
所以分支历史缓冲区必须至少能存储最后的26个分支的信息。
两个程序实例之一的代码随后在内存中移动。 这表明只有源地址和目标地址的低20位对分支历史缓冲区有影响。
在两个程序实例中使用不同类型的分支进行测试表明，静态跳转，条件跳转，调用和返回以同样的方式影响分支历史缓冲区; 未采取有条件的跳跃不会影响它;
源指令的最后一个字节的地址是计数的地址; IRETQ不会影响历史缓冲区状态（这对测试很有用，因为它允许创建历史缓冲区不可见的程序流）。
在间接调用内存之前，移动最后的条件分支多次显示分支历史缓冲区内容可用于区分最后一个条件分支指令的许多不同位置。 这表明历史缓冲区不存储小历史值列表;
相反，它似乎是历史数据混合在一起的更大的缓冲区。
然而，为了对分支预测有用，历史缓冲区在需要一定数量的新分支之后会“忘记”过去的分支。
因此，当新数据混合到历史缓冲区中时，不会导致历史缓冲区中已经存在的位中的信息向下传播 - 并且考虑到向上组合的信息可能不会非常有用。
考虑到分支预测也必须非常快，我们认为，历史缓冲区的更新功能可能左移旧历史缓冲区，然后XOR处于新状态（参见图）。  
如果这个假设是正确的，那么历史缓冲区包含大量关于最近分支的信息，但只包含与每个历史缓冲区更新有关的最后一个含有任何数据的分支所移动的信息位数。因此，我们测试了翻转跳转的源地址和目标地址中的不同位，然后是带有静态源和目标的32个始终采用的跳转，允许分支预测消除间接调用的歧义。[11]
中间有32个静态跳转，似乎没有位翻转被影响，所以我们减少了静态跳转的次数，直到可以观察到差异。28次跳转的结果是目标的0x1和0x2
bits以及源的0x40和0x80 bits被影响。但是翻转目标中的0x1和源中的0x40或目标中的0x2和源的0x80不允许消除歧义。  
这表明历史缓冲区每次插入的移位是2位，并显示哪些数据存储在历史缓冲区的最低有效位中。然后，我们在跳转位后通过减少固定跳转次数来确定哪些信息存储在剩余位中。
#### 篇幅所限，下篇继续