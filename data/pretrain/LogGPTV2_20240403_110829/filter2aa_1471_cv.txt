Credential store, for retrieving the credential used to start the task, and then
processes the list of all actions and triggers (stored in an internal list),
converting them in a format that UBPM can understand. Finally, it calls the
UbpmTriggerConsumerRegister API exported from UBPM.dll. The task is
ready to be executed when the right conditions are verified.
Unified Background Process Manager (UBPM)
Traditionally, UBPM was mainly responsible in managing tasks’ life cycles
and states (start, stop, enable/disable, and so on) and to provide notification
and triggers support. Windows 8.1 introduced the Broker Infrastructure and
moved all the triggers and notifications management to different brokers that
can be used by both Modern and standard Win32 applications. Thus, in
Windows 10, UBPM acts as a proxy for standard Win32 Tasks’ triggers and
translates the trigger consumers request to the correct broker. UBPM is still
responsible for providing COM APIs available to applications for the
following:
■    Registering and unregistering a trigger consumer, as well as opening
and closing a handle to one
■    Generating a notification or a trigger
■    Sending a command to a trigger provider
Similar to the Task Scheduler’s architecture, UBPM is composed of
various internal components: Task Host server and client, COM-based Task
Host library, and Event Manager.
Task host server
When one of the System brokers raises an event registered by a UBPM
trigger consumer (by publishing a WNF state change), the
UbpmTriggerArrived callback function is executed. UBPM searches the
internal list of a registered task’s triggers (based on the WNF state name) and,
when it finds the correct one, processes the task’s actions. At the time of this
writing, only the Launch Executable action is supported. This action supports
both hosted and nonhosted executables. Nonhosted executables are regular
Win32 executables that do not directly interact with UBPM; hosted
executables are COM classes that directly interact with UBPM and need to be
hosted by a task host client process. After a host-based executable
(taskhostw.exe) is launched, it can host different tasks, depending on its
associated token. (Host-based executables are very similar to shared Svchost
services.)
Like SCM, UBPM supports different types of logon security tokens for
task’s host processes. The UbpmTokenGetTokenForTask function is able to
create a new token based on the account information stored in the task
descriptor. The security token generated by UBPM for a task can have one of
the following owners: a registered user account, Virtual Service account,
Network Service account, or Local Service account. Unlike SCM, UBPM
fully supports Interactive tokens. UBPM uses services exposed by the User
Manager (Usermgr.dll) to enumerate the currently active interactive sessions.
For each session, it compares the User SID specified in the task’s descriptor
with the owner of the interactive session. If the two match, UBPM duplicates
the token attached to the interactive session and uses it to log on the new
executable. As a result, interactive tasks can run only with a standard user
account. (Noninteractive tasks can run with all the account types listed
previously.)
After the token has been generated, UBPM starts the task’s host process.
In case the task is a hosted COM task, the UbpmFindHost function searches
inside an internal list of Taskhostw.exe (task host client) process instances. If
it finds a process that runs with the same security context of the new task, it
simply sends a Start Task command (which includes the COM task’s name
and CLSID) through the task host local RPC connection and waits for the
first response. The task host client process and UBPM are connected through
a static RPC channel (named ubpmtaskhostchannel) and use a connection
protocol similar to the one implemented in the SCM.
If a compatible client process instance has not been found, or if the task’s
host process is a regular non-COM executable, UBPM builds a new
environment block, parses the command line, and creates a new process in a
suspended state using the CreateProcessAsUser API. UBPM runs each task’s
host process in a Job object, which allows it to quickly set the state of
multiple tasks and fine-tune the resources allocated for background tasks.
UBPM searches inside an internal list for Job objects containing host
processes belonging to the same session ID and the same type of tasks
(regular, critical, COM-based, or non-hosted). If it finds a compatible Job, it
simply assigns the new process to the Job (by using the
AssignProcessToJobObject API). Otherwise, it creates a new one and adds it
to its internal list.
After the Job object has been created, the task is finally ready to be started:
the initial process’s thread is resumed. For COM-hosted tasks, UBPM waits
for the initial contact from the task host client (performed when the client
wants to open a RPC communication channel with UBPM, similar to the way
in which Service control applications open a channel to the SCM) and sends
the Start Task command. UBPM finally registers a wait callback on the
task’s host process, which allow it to detect when a task host’s process
terminates unexpectedly.
Task Host client
The Task Host client process receives commands from UBPM (Task Host
Server) living in the Task Scheduler service. At initialization time, it opens
the local RPC interface that was created by UBPM during its initialization
and loops forever, waiting for commands to come through the channel. Four
commands are currently supported, which are sent over the
TaskHostSendResponseReceiveCommand RPC API:
■    Stopping the host
■    Starting a task
■    Stopping a task
■    Terminating a task
All task-based commands are internally implemented by a generic COM
task library, and they essentially result in the creation and destruction of
COM components. In particular, hosted tasks are COM objects that inherit
from the ITaskHandler interface. The latter exposes only four required
methods, which correspond to the different task’s state transitions: Start,
Stop, Pause, and Resume. When UBPM sends the command to start a task to
its client host process, the latter (Taskhostw.exe) creates a new thread for the
task. The new task worker thread uses the CoCreateInstance function to
create an instance of the ITaskHandler COM object representing the task and
calls its Start method. UBPM knows exactly which CLSID (class unique ID)
identifies a particular task: The task’s CLSID is stored by the Task store in
the task’s configuration and is specified at task registration time.
Additionally, hosted tasks use the functions exposed by the
ITaskHandlerStatus COM interface to notify UBPM of their current
execution state. The interface uses RPCs to call UbpmReportTaskStatus and
report the new state back to UBPM.
EXPERIMENT: Witnessing a COM-hosted task
In this experiment, you witness how the task host client process
loads the COM server DLL that implements the task. For this
experiment, you need the Debugging tools installed on your
system. (You can find the Debugging tools as part of the Windows
SDK, which is available at the https://developer.microsoft.com/en-
us/windows/downloads/windows-10-sdk/.) You will enable the task
start’s debugger breakpoint by following these steps:
1. 
You need to set up Windbg as the default post-mortem
debugger. (You can skip this step if you have connected a
kernel debugger to the target system.) To do that, open an
administrative command prompt and type the following
commands:
Click here to view code image
cd "C:\Program Files (x86)\Windows 
Kits\10\Debuggers\x64"
windbg.exe /I
Note that C:\Program Files (x86)\Windows
Kits\10\Debuggers\x64 is the path of the Debugging tools,
which can change depending on the debugger’s version and
the setup program.
2. 
Windbg should run and show the following message,
confirming the success of the operation:
3. 
After you click on the OK button, WinDbg should close
automatically.
4. 
Open the Task Scheduler applet (by typing taskschd.msc in
the command prompt).
5. 
Note that unless you have a kernel debugger attached, you
can’t enable the initial task’s breakpoint on noninteractive
tasks; otherwise, you won’t be able to interact with the
debugger window, which will be spawned in another
noninteractive session.
6. 
Looking at the various tasks (refer to the previous
experiment, “Explore a task’s XML descriptor” for further
details), you should find an interactive COM task (named
CacheTask) under the \Microsoft\Windows\Wininet path.
Remember that the task’s Actions page should show
Custom Handler; otherwise the task is not COM task.
7. 
Open the Registry Editor (by typing regedit in the
command prompt window) and navigate to the following
registry key: HKLM\SOFTWARE\Microsoft\Windows
NT\CurrentVersion\Schedule.
8. 
Right-click the Schedule key and create a new registry
value by selecting Multi-String Value from the New menu.
9. 
Name the new registry value as
EnableDebuggerBreakForTaskStart. To enable the initial
task breakpoint, you should insert the full path of the task.
In this case, the full path is
\Microsoft\Windows\Wininet\CacheTask. In the previous
experiment, the task path has been referred as the task’s
URI.
10. 
Close the Registry Editor and switch back to the Task
Scheduler.
11. 
Right-click the CacheTask task and select Run.
12. 
If you have configured everything correctly, a new WinDbg
window should appear.
13. 
Configure the symbols used by the debugger by selecting
the Symbol File Path item from the File menu and by
inserting a valid path to the Windows symbol server (see
https://docs.microsoft.com/en-us/windows-
hardware/drivers/debugger/microsoft-public-symbols for
more details).
14. 
You should be able to peek at the call stack of the
Taskhostw.exe process just before it was interrupted using
the k command:
Click here to view code image
0:000> k
 # Child-SP          RetAddr           Call Site
00 000000a7`01a7f610 00007ff6`0b0337a8 
taskhostw!ComTaskMgrBase::
[ComTaskMgr]::StartComTask+0x2c4
01 000000a7`01a7f960 00007ff6`0b033621 
taskhostw!StartComTask+0x58
02 000000a7`01a7f9d0 00007ff6`0b033191 
taskhostw!UbpmTaskHostWaitForCommands+0x2d1
3 000000a7`01a7fb00 00007ff6`0b035659 
taskhostw!wWinMain+0xc1
04 000000a7`01a7fb60 00007ffa`39487bd4 
taskhostw!__wmainCRTStartup+0x1c9
05 000000a7`01a7fc20 00007ffa`39aeced1 
KERNEL32!BaseThreadInitThunk+0x14
06 000000a7`01a7fc50 00000000`00000000 
ntdll!RtlUserThreadStart+0x21
15. 
The stack shows that the task host client has just been
spawned by UBPM and has received the Start command
requesting to start a task.
16. 
In the Windbg console, insert the ~. command and press
Enter. Note the current executing thread ID.
17. 
You should now put a breakpoint on the CoCreateInstance
COM API and resume the execution, using the following
commands:
Click here to view code image
bp combase!CoCreateInstance
g
18. 
After the debugger breaks, again insert the ~. command in
the Windbg console, press Enter, and note that the thread ID
has completely changed.
19. 
This demonstrates that the task host client has created a new
thread for executing the task entry point. The documented
CoCreateInstance function is used for creating a single
COM object of the class associated with a particular
CLSID, specified as a parameter. Two GUIDs are
interesting for this experiment: the GUID of the COM class
that represents the Task and the interface ID of the interface
implemented by the COM object.
20. 
In 64-bit systems, the calling convention defines that the
first four function parameters are passed through registers,
so it is easy to extract those GUIDs:
Click here to view code image
0:004> dt combase!CLSID @rcx
 {0358b920-0ac7-461f-98f4-58e32cd89148}
   +0x000 Data1            : 0x358b920
   +0x004 Data2            : 0xac7
   +0x006 Data3            : 0x461f
   +0x008 Data4            : [8] "???"
0:004> dt combase!IID @r9
 {839d7762-5121-4009-9234-4f0d19394f04}
   +0x000 Data1            : 0x839d7762
   +0x004 Data2            : 0x5121
   +0x006 Data3            : 0x4009
   +0x008 Data4            : [8] "???"
As you can see from the preceding output, the COM server
CLSID is {0358b920-0ac7-461f-98f4-58e32cd89148}. You can
verify that it corresponds to the GUID of the only COM action
located in the XML descriptor of the “CacheTask” task (see the
previous experiment for details). The requested interface ID is
“{839d7762-5121-4009-9234-4f0d19394f04}”, which correspond
to the GUID of the COM task handler action interface
(ITaskHandler).
Task Scheduler COM interfaces
As we have discussed in the previous section, a COM task should adhere to a
well-defined interface, which is used by UBPM to manage the state transition
of the task. While UBPM decides when to start the task and manages all of its
state, all the other interfaces used to register, remove, or just manually start
and stop a task are implemented by the Task Scheduler in its client-side DLL
(Taskschd.dll).
ITaskService is the central interface by which clients can connect to the
Task Scheduler and perform multiple operations, like enumerate registered
tasks; get an instance of the Task store (represented by the ITaskFolder COM
interface); and enable, disable, delete, or register a task and all of its
associated triggers and actions (by using the ITaskDefinition COM interface).
When a client application invokes for the first time a Task Scheduler APIs
through COM, the system loads the Task Scheduler client-side DLL
(Taskschd.dll) into the client process’s address space (as dictated by the
COM contract: Task Scheduler COM objects live in an in-proc COM server).
The COM APIs are implemented by routing requests through RPC calls into
the Task Scheduler service, which processes each request and forwards it to
UBPM if needed. The Task Scheduler COM architecture allows users to
interact with it via scripting languages like PowerShell (through the
ScheduledTasks cmdlet) or VBScript.
Windows Management
Instrumentation
Windows Management Instrumentation (WMI) is an implementation of Web-
Based Enterprise Management (WBEM), a standard that the Distributed
Management Task Force (DMTF—an industry consortium) defines. The
WBEM standard encompasses the design of an extensible enterprise data-
collection and data-management facility that has the flexibility and
extensibility required to manage local and remote systems that comprise
arbitrary components.
WMI architecture
WMI consists of four main components, as shown in Figure 10-27:
management applications, WMI infrastructure, providers, and managed
objects. Management applications are Windows applications that access and
display or process data about managed objects. A simple example of a
management application is a performance tool replacement that relies on
WMI rather than the Performance API to obtain performance information. A
more complex example is an enterprise-management tool that lets
administrators perform automated inventories of the software and hardware
configuration of every computer in their enterprise.
Figure 10-27 WMI architecture.
Developers typically must target management applications to collect data
from and manage specific objects. An object might represent one component,
such as a network adapter device, or a collection of components, such as a
computer. (The computer object might contain the network adapter object.)
Providers need to define and export the representation of the objects that
management applications are interested in. For example, the vendor of a
network adapter might want to add adapter-specific properties to the network
adapter WMI support that Windows includes, querying and setting the
adapter’s state and behavior as the management applications direct. In some
cases (for example, for device drivers), Microsoft supplies a provider that has
its own API to help developers leverage the provider’s implementation for
their own managed objects with minimal coding effort.
The WMI infrastructure, the heart of which is the Common Information
Model (CIM) Object Manager (CIMOM), is the glue that binds management
applications and providers. (CIM is described later in this chapter.) The
infrastructure also serves as the object-class store and, in many cases, as the
storage manager for persistent object properties. WMI implements the store,
or repository, as an on-disk database named the CIMOM Object Repository.
As part of its infrastructure, WMI supports several APIs through which
management applications access object data and providers supply data and
class definitions.
Windows programs and scripts (such as Windows PowerShell) use the
WMI COM API, the primary management API, to directly interact with
WMI. Other APIs layer on top of the COM API and include an Open
Database Connectivity (ODBC) adapter for the Microsoft Access database
application. A database developer uses the WMI ODBC adapter to embed
references to object data in the developer’s database. Then the developer can
easily generate reports with database queries that contain WMI-based data.
WMI ActiveX controls support another layered API. Web developers use the
ActiveX controls to construct web-based interfaces to WMI data. Another
management API is the WMI scripting API, for use in script-based
applications (like Visual Basic Scripting Edition). WMI scripting support
exists for all Microsoft programming language technologies.
Because WMI COM interfaces are for management applications, they
constitute the primary API for providers. However, unlike management
applications, which are COM clients, providers are COM or Distributed
COM (DCOM) servers (that is, the providers implement COM objects that
WMI interacts with). Possible embodiments of a WMI provider include
DLLs that load into a WMI’s manager process or stand-alone Windows
applications or Windows services. Microsoft includes a number of built-in
providers that present data from well-known sources, such as the
Performance API, the registry, the Event Manager, Active Directory, SNMP,
and modern device drivers. The WMI SDK lets developers develop third-
party WMI providers.
WMI providers
At the core of WBEM is the DMTF-designed CIM specification. The CIM
specifies how management systems represent, from a systems management
perspective, anything from a computer to an application or device on a
computer. Provider developers use the CIM to represent the components that
make up the parts of an application for which the developers want to enable
management. Developers use the Managed Object Format (MOF) language
to implement a CIM representation.
In addition to defining classes that represent objects, a provider must
interface WMI to the objects. WMI classifies providers according to the
interface features the providers supply. Table 10-14 lists WMI provider
classifications. Note that a provider can implement one or more features;
therefore, a provider can be, for example, both a class and an event provider.
To clarify the feature definitions in Table 10-14, let’s look at a provider that
implements several of those features. The Event Log provider supports
several objects, including an Event Log Computer, an Event Log Record, and
an Event Log File. The Event Log is an Instance provider because it can
define multiple instances for several of its classes. One class for which the
Event Log provider defines multiple instances is the Event Log File class
(Win32_NTEventlogFile); the Event Log provider defines an instance of this
class for each of the system’s event logs (that is, System Event Log,
Application Event Log, and Security Event Log).