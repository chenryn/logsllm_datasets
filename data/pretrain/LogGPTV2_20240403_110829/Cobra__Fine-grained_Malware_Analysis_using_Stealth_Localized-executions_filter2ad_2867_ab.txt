for SM-SC code and code obfuscations. Further these tools do
not carry adequate support for multithreading and cannot han-
dle code in kernel-mode. Hypervisors such as VMWare [52],
QEmu [2] etc. are able to handle multithreading in both user-
and kernel-mode efﬁciently, but do not carry support for SM-
SC code. Also, they are not tailored towards malware and can
be detected and countered [48].
In comparison Cobra is a dynamic ﬁne-grained malware
analysis framework that overcomes the shortcomings of cur-
rent research in dynamic ﬁne-grained malware analysis by pro-
viding a stealth supervised code execution environment that
can handle multihreading, SM-SC code and any form of code
obfuscation in both user- and kernel-mode. Cobra cannot be
detected or countered in any fashion and supports both man-
ual and automated code tracing, providing insight into execut-
ing malware code-streams at runtime. The framework supports
selective isolation whereby one can deploy ﬁne-grained anal-
ysis of malware speciﬁc code-streams while co-existing with
normal code-streams in real-time.
3. Framework Overview
Fine-grained malware analysis using Cobra is facilitated by
a technique that we call stealth localized-executions. The basic
idea involves decomposing a code-stream into several groups
of instructions — which we call blocks — that are then exe-
cuted, one at a time, in a fashion so as to mimic the normal
execution of the target code-stream. Each block is implanted
with various invisible Cobra speciﬁc code constructs (as appli-
cable), ensuring that the framework has complete control over
the executing code-stream while remaining stealthy.
Figure 1 illustrates the current architecture of Cobra. The
framework core consists of a Block Create and eXecute Engine
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply. 
Code
Stream
1
1
Code
Stream
5
l
s
i
s
y
a
n
A
l
o
o
T
2
4
5
3
Cobra
API
m
e
t
s
y
S
g
n
i
t
a
r
e
p
O
n
o
i
t
c
a
r
t
s
b
A
Disassembler
(Processor Abstraction)
Block
Monitor
(BM)
Block Create &
eXecute Engine
(BCXE)
Block
Repository
Code
Stream
T
o
o
l
5
A
n
a
y
s
i
s
l
5
1
1
Code
Stream
2
4
3
User-Mode
Kernel-Mode
Figure 1. Architecture of Cobra
(BCXE), a disassembler, a block repository, a block-monitor,
and a framework API. The BCXE is responsible for decom-
posing a target code-stream into blocks and executing them.
The target code-stream can be a regular or a malware spe-
ciﬁc code-stream. An architecture speciﬁc disassembler is em-
ployed to construct blocks corresponding to the target code-
stream, in a dynamic fashion. The block repository functions
as a local cache for storage of blocks. Only code from the
block repository is executed and never any code from the tar-
get code-stream. Localized-executions on a target code-stream
begin at an overlay point and stop at a release point, a user-
deﬁned range where ﬁne-grained analysis is desired. This al-
lows Cobra to be deployed and removed in a dynamic fashion
on a given code-stream while allowing other code-streams to
execute as is, a technique we call selective isolation. As an ex-
ample, the W32/Ratos trojan and its variants employ several
kernel-mode threads for their functioning. An overlay point in
this case could be KiSwitchContext (a Windows OS internal
kernel function responsible for thread pre-emption) and a re-
lease point could be the return from this function. The block-
monitor employs subtle techniques involving virtual memory
to protect critical memory regions during localized-executions
and is responsible for maintaining coherence between the tar-
get code-stream and its blocks in case of self-modifying code.
As Figure 1 shows, there are typically three binary elements
present during an analysis session: the target code-streams (re-
siding in either user- and/or kernel-mode), the analysis tool
employing Cobra (typically some sort of debugger), and Co-
bra itself. The analysis tool, for each overlay point in a target
code-stream, invokes the framework for ﬁne-grained analysis
over a speciﬁed range of the code-stream (Steps 1 and 2, Fig-
ure 1). The analysis tool then performs the required actions
(processing) for speciﬁed events during the execution of the
blocks. An event can be: block creation, execution of instruc-
tions within a block, acesss to critical memory regions within a
block etc. (Step 3, Figure 1). Cobra stops localized-executions
at the speciﬁed release point and transfers control back to the
analysis tool which then resumes normal execution of the tar-
get code-stream (Steps 4 and 5, Figure 1).
Cobra resides in kernel-mode and can capture multi-
threaded, SM-SC code and any form of code obfuscation in
both user- and kernel-mode with ease. The framework is com-
pletely re-entrant, as it does not make use of any OS speciﬁc
routines during localized-executions and uses shared mem-
ory with its own isolation primitives for interprocess commu-
nication. The framework employs techniques such as skipping
(where standard and/or non-standard code-streams are ex-
cluded from localized-executions)
and block-coalescing
(where multiple blocks are composed together) for efﬁ-
ciency. The Cobra API is simple yet powerful to allow a
tool writer to harness the complete power of the frame-
work.
4. Design and Implementation
Our goal
code-streams,
in designing and implementing Cobra was
twofold. First, it should be able to provide a stealth su-
for ﬁne-grained analysis of exe-
pervised environment
cuting malware
supporting multithread-
ing, self-modifying code and any form of code obfuscation
in both user- and kernel-mode on commodity OSs. Sec-
ond, one must be able to deploy the framework dynamically
and selectively on malware speciﬁc code-streams while allow-
ing other code-streams to execute as is. This section describes
how Cobra achieves these capabilities.
4.1. Localized-executions
Cobra decomposes a target code-stream into several groups
of instructions and executes them in a fashion so as to mimic
the code-stream’s normal execution. This process is what we
call localized-executions and the instruction groups are called
blocks. A block is nothing but a straight-line sequence of in-
structions that terminates in either of these conditions: (1) an
unconditional control transfer instruction (CTI), (2) a condi-
tional CTI, or (3) a speciﬁed number of non-CTIs. A block-
repository contains a subset of the recently constructed blocks
and acts as a framework local cache. Only blocks residing in
the block-repository are executed — never the instructions in
the target code-stream (hence the term localized-executions).
Cobra’s BCXE is responsible for creating blocks from the tar-
get code-stream and executing them.
4.1.1. Block Creation The BCXE employs an architecture
speciﬁc disassembler on the target code-stream, to discover in-
structions one at a time, and create the corresponding blocks.
Figure 2a shows part of a code-stream of the W32/Ratos tro-
jan and a typical block creation process. The code-fragment
has been modiﬁed to remove details not pertinent to our dis-
cussion and the instructions are shown in the 32-bit assem-
bly language syntax of the IA-32 (and compatible) processors
[25].
Every block ends with a framework speciﬁc set of instruc-
tions — which we call a Xfer-stub — that transfers control to
the BCXE. Xfer-stubs ensure that Cobra is always under con-
trol of the target code-stream being analyzed. When a block is
executed, the BCXE gets control at the end of the block exe-
cution via the block xfer-stub, determines the target memory-
address to create the next block from, dynamically generates a
new block for the corresponding code-stream if it has not done
before, and resumes execution at the newly generated block.
Thus, execution of blocks follows a path which is the same
as the normal execution of the target code-stream in absence
of the framework. Figure 2b shows the blocks created by the
BCXE for the code-stream shown in Figure 2a.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply. 
           ...
01. 8d003fe0h: mov eax, [edi+3ah]
02. 8d003fe3h: xor eax, [edi+2bh]
03. 8d003fe5h: mov [edi+2ch], eax
04. 8d003fe8h: call 8d003ff0h
05. 8d003ff0h: pop ebp
06. 8d003ff1h: mov ebx, [edi+1ah] 
07. 8d003ff4h: mov [ebp+eax], ebx
08. 8d003ff6h: mov esi, ebp
09. 8d003ff8h: call d[edi+0bh]
10. 8d003ffch: jne 8d003ff1h
11. 8d003ffeh: add eax, ebp
12. 8d004001h: call eax
13. 8d004003h: cmp [edi+1ah], 7ch
14. 8d004006h: jne 8d00400Ah
15. 8d004008h: mov eax, 1B02EB02h
16. 8d00400eh: mov eax, E105EE3ch
17. 8d004015h: call 8d00505fh
           ...
(a)
block-1
block-2
block-3
block-4
block-5
block-6
block-7
block-1:
 mov eax, [edi+3ah]
 xor eax, [edi+2bh]
 mov [edi+2ch], eax
mov PIB, entry0
 jmp bcxe
block-2:
 pop ebp
 mov ebx, [edi+1ah]
 mov [ebp+eax], ebx
 mov esi, ebp
mov PIB, entry1
 jmp bcxe 
block-3:
mov PIB, entry2
 jne bcxe
 mov PIB, entry3
 jmp bcxe
block-4:
 add eax, ebp
mov PIB, entry4
 jmp bcxe
(b)
block-5:
 cmp [edi+1ah], 7ch
mov PIB, entry5
 jne bcxe
 mov PIB, entry6
 jmp bcxe
block-6:
 xor eax, [edi+2bh]
mov PIB, entry7
 jmp bcxe
block-7:
mov PIB, entry8
 jmp bcxe
Figure 2. Block Creation: (a) Target Code-stream, and (b) Corresponding Blocks
The BCXE differs from VMs employed in current hyper-
visors [52, 2] and ﬁne-grained instrumentation frameworks
[34, 8, 40, 44, 36] in that: (a) it employs special treatment for
CTIs thereby supporting SM-SC code and any form of code
obfuscation (see Section 4.1.3), (b) it employs special treat-
ment on privileged instructions and instructions that betray the
real state of a code-stream and hence cannot be detected or
countered in any fashion (see Section 4.2), (c) it achieves efﬁ-
ciency without recompiling the instructions of the target code-
stream (see Section 4.3), and (d) it is completely re-entrant
supporting multithreading under both user- and kernel-mode
and allows tuning the level of ﬁne-grained analysis desired.
4.1.2. Xfer-stubs Xfer-stubs, Cobra speciﬁc code constructs
that terminate every block, can be abstracted as a function that
takes a single parameter (Figure 3a). The parameter is an index