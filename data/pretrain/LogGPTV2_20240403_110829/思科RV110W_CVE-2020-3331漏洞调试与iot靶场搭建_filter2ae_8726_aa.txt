# 思科RV110W CVE-2020-3331漏洞调试与iot靶场搭建
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
作者：lxonz@白帽汇安全研究院
此次分析是基于轩哥的文章https://xuanxuanblingbling.github.io/iot/2020/10/26/rv110w/，同时因为轩哥用的是实机，很多师傅可能不想入手路由器，因此我这篇文章是针对路由器的httpd进行hook在通过qemu-system模拟启动，我整理好的环境已经上传至https://hub.docker.com/r/vulshare/cve-2020-3331，有需要的师傅可以自行下载，并且如果想一键生成环境的话，可以来http://vulfocus.fofa.so/，启动过程可能会比较长，估摸着6分钟以内，耐心等一下~
    docker pull vulshare/cve-2020-3331:lxonz
    docker run -itd -P vulshare/cve-2020-3331:lxonz
## 本地环境部署
**本地环境搭建遇到的几点问题：**
**1.因为没有nvram所以不能成功启动，因此需要hook**
**2.建立交叉编译环境，将代码作为共享库编译**
从调试到封装成docker的周期比较长，有些技术细节记得不太清了，可能文章思路有点跳跃，有问题的地方读者指出就好，我这边修正。
本次调试环境：1.vmlinux-3.2.0-4-4kc-malta
​ 2.debian_wheezy_mipsel_standard.qcow2
下载地址：
    qemu启动参数：
    qemu-system-mipsel -M malta \ 
    -kernel vmlinux-3.2.0-4-4kc-malta  \
    -hda debian_wheezy_mipsel_standard.qcow2 \
    -append "root=/dev/sda1 console=tty0 nokalsr" \
    -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic
因为实际环境也是没有aslr的，所以在这里我们直接关掉，否则没有办法泄露libc。
关于基本的环境搭建的具体部分可以去参考我之前的一篇文章
    chroot squashfs-root sh
    mount -o bind /dev ./dev/
    mount -t proc /proc/ ./proc/
这里如果我们单纯的启动./http是起不来的，因为我们没有nvram，过不了他的检查，所以在这里我采取的hook的方法，将他的nvram_get
hook掉，即可启动，目标平台是mipsel所以我们需要使用buildroot来搭建一个交叉编译的环境。
    sudo apt-get update
    sudo apt-get install libncurses5-dev patch
    git clone https://github.com/buildroot/buildroot.git
    cd buildroot
    make clean
    make menuconfig
进到Target options这里面之后我们需要选他的架构和大小端序
在toolchain里选择kernel版本uname -a看一下可以了，然后保存退出
然后直接make -j8编译即可然后会生成一个output文件夹，进去找output/host/bin 运行mipsel-linux-gcc
—version
    mipsel-linux-gcc --version
    mipsel-linux-gcc.br_real (Buildroot 2020.08-947-ga2b344a) 9.3.0
    Copyright (C) 2019 Free Software Foundation, Inc.
    This is free software; see the source for copying conditions.  There is NO
    warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
有版本回显就可以了，我们一会通过这个交叉编译我们的nvram_get。
最后将这个路径写入.bashrc
    export PATH=~/buildroot/buildroot/output/host/bin:$PATH
后面就可以愉快的调用了
## hook nvram_get
       v34 = (char *)nvram_get("lan_ifname");
        if ( !v34 )
          v34 = "";
        v35 = (char *)nvram_get("lan_ipaddr");
        if ( !v35 )
          v35 = "";
        v36 = (char *)nvram_get("http_client_ip");
        if ( !v36 )
          v36 = "";
        v37 = (char *)nvram_get("lan_hwaddr");
        if ( !v37 )
嵌入式应用程序通常通过共享库与NVRAM交互。该库又与包含设备当前配置设置的MTD分区接口交互。如果没有NVRAM配置数据，许多程序将无法正常运行，
**需要我们拦截NVRAM库调用并返回有效数据** ，以便在Qemu中正确执行应用程序
如果我们不进行hook的话，到达漏洞触发点，会发现V0-T9没有任何值
    0x77fb2a84 in ?? ()
    LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
    ──────────────────────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────────────────────────
     V0   0x0
     V1   0x0
     A0   0x0
     A1   0x0
     A2   0x0
     A3   0x0
     T0   0x0
     T1   0x0
     T2   0x0
     T3   0x0
     T4   0x0
     T5   0x0
     T6   0x0
     T7   0x0
     T8   0x0
     T9   0x0
     S0   0x77aa7050
     S1   0x61616161 ('aaaa')
     S2   0x61616161 ('aaaa')
     S3   0x61616161 ('aaaa')
     S4   0x61616161 ('aaaa')
     S5   0x61616161 ('aaaa')
     S6   0x61616161 ('aaaa')
     S7   0x61616161 ('aaaa')
     S8   0x61616161 ('aaaa')
     FP   0x0
     SP   0x7fff6f40 ◂— 0x1
     PC   0x77fb2a84 ◂— bal    0x77fb2a8c
    ───────────────────────────────────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────────────────────────────────
       0x77fb2a80    move   $t9, $ra
     ► 0x77fb2a84    bal    0x77fb2a8c
        ↓
       0x77fb2a8c    lui    $gp, 5
       0x77fb2a90    addiu  $gp, $gp, -0x3a7c
       0x77fb2a94    addu   $gp, $gp, $ra
       0x77fb2a98    move   $ra, $t9
       0x77fb2a9c    lw     $a0, -0x7fe8($gp)
       0x77fb2aa0    sw     $a0, -0x7ff0($gp)
       0x77fb2aa4    move   $a0, $sp
       0x77fb2aa8    addiu  $sp, $sp, -0x10
       0x77fb2aac    lw     $t0, -0x7fe4($gp)
    ────────────────────────────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────────────────────────────
    00:0000│ sp  0x7fff6f40 ◂— 0x1
    01:0004│     0x7fff6f44 —▸ 0x7fff6fea ◂— '//bin/sh'
    02:0008│     0x7fff6f48 ◂— 0x0
    ... ↓
    04:0010│     0x7fff6f50 ◂— 0x10
    05:0014│     0x7fff6f54 ◂— 0x0
    06:0018│     0x7fff6f58 ◂— 0x6
    07:001c│     0x7fff6f5c ◂— 0x1000
    ──────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────────────────────
     ► f 0 77fb2a84
    ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
    gdb-peda$
https://blog.csdn.net/qq_21063873/article/details/103037515这篇文章有大致介绍基于qemu的nvram仿真
通过ida看它的httpd，nvram_get在获取各种环境的值，如果我们给它lan_ipaddr写死了是不是就可以了？nvram_get只传了一个参数
    #include 
    #include 
    char *nvram_get(char *key)
    {
            char *value = NULL;
            if(strcmp(key, "lan_ipaddr") == 0)
            {
                    value = strdup("127.0.0.1");
            }
            printf("nvram_get(%s) == %s\n", key, value);
            return value;
    }
    mipsel-linux-gcc -shared -fPIC nvram.c -o nvram.so
我们将此代码作为共享库进行编译
回到qemu里执行命令
    chroot squashfs-root sh 
    export LD_PRELOAD="./nvram.so" && ./httpd
    nvram_get(http_settimeouts) == (null)
    nvram_get(http_settimeouts_usec) == (null)
    nvram_get(http_debug) == (null)
    出现这三个代表启动成功
还有一种思路是通过nvram_faker启动
它提供了编译不同架构的脚本，hook思路大同小异，也可以拿这个来进行启动
## 漏洞分析
漏洞点在guest_logout.cgi的sscanf
    v10 = (const char *)get_cgi((int)"cip");
      v11 = (const char *)get_cgi((int)"submit_button");
      if ( !v11 )
        v11 = "";
      if ( v5 && v10 )
      {
        memset(v29, 0, 0x40u);
        memset(v28, 0, sizeof(v28));
        v12 = fopen("/dev/console", "w");
        v13 = v12;
        if ( v12 )
        {
          fprintf(v12, "\n  mac=[%s], ip=[%s], submit_button=[%s]\n", v5, v10, v11);
          fclose(v13);
        }
        if ( VERIFY_MAC_17(v5) && VERIFY_IPv4(v10) )
        {
          if ( !strstr(v11, "status_guestnet.asp") )
            goto LABEL_31;
          sscanf(v11, "%[^;];%*[^=]=%[^\n]", v29, v28);
          v17 = fopen("/dev/console", "w");
          v18 = v17;
          if ( v17 )
          {
            fprintf(
              v17,
              "\n%s(%d),submit_button = [%s] url=[%s], session_id=[%s]\n",
              "guest_logout_cgi",
              5449,
              v11,
              v29,
              v28);
            fclose(v18);
          }
    sscanf这里起到了一个正则的作用，v11是我们需要匹配的字符串，%[^;];%*[^=]=%[^\n]是匹配规则，V29存的是%[^;]匹配到的值，V28存的是%*[^=]=%[^\n]
    %[^;]：分号前的所有字符都要
    ;%*[^=]：分号后，等号前的字符都不要
    =%[^\n]：等号后，换行符前的所有字符都要
    v11 = (const char *)get_cgi((int)"submit_button");
     v5 = (const char *)get_cgi((int)"cmac");
     v6 = (const char *)get_cgi((int)"cip")
断点下在已经覆盖了ra的位置
    b *0x431b60
     V0   0x0
     V1   0x73
     A0   0x4d81f0 (post_buf+64) ◂— 0x75746174 ('tatu')
     A1   0x47f785 ◂— 'ogin_guest.asp'
     A2   0x0