# 六、分布式应用架构
在前一章中，我们学习了如何使用 Docker 卷来保持已创建或已修改的状态，以及如何在容器中运行的应用之间共享数据。我们还学习了如何处理 Docker 守护程序生成的事件，并清理未使用的资源。
在本章中，我们介绍了分布式应用架构的概念，并讨论了成功运行分布式应用所需的各种模式和最佳实践。最后，我们将讨论在生产中运行这样的应用需要满足的附加要求。
在本章中，我们将涵盖以下主题:
*   什么是分布式应用架构？
*   模式和最佳实践
*   投入生产
完成本章后，您将能够执行以下操作:
*   说出分布式应用架构的至少四个特征
*   说出至少四种需要为生产就绪的分布式应用实现的模式
# 什么是分布式应用架构？
在本节中，我们将详细解释当我们谈论分布式应用架构时，我们的意思是什么。首先，我们需要确保我们使用的所有单词或首字母缩略词都有意义，并且我们都在说同一种语言。
# 定义术语
在这一章和随后的章节中，我们将谈论很多可能不是每个人都熟悉的概念。为了确保我们都使用相同的语言，让我们简要介绍和描述其中最重要的概念或单词:
| **虚拟机** | 虚拟机的缩写。这是一台虚拟计算机。 |
| **节点** | 用于运行应用的单个服务器。这可以是物理服务器，通常称为**裸机**，也可以是虚拟机。节点可以是大型机、超级计算机、标准业务服务器，甚至是树莓 Pi。节点可以是公司自己的数据中心或云中的计算机。通常，节点是集群的一部分。 |
| **集群** | 由网络连接的一组节点，用于运行分布式应用。 |
| **网络** | 集群的各个节点和这些节点上运行的程序之间的物理和软件定义的通信路径。 |
| **港口** | 应用(如 web 服务器)监听传入请求的通道。 |
| **服务** | 不幸的是，这是一个非常超载的术语，它的真正含义取决于它的使用环境。如果我们在应用(如应用服务)的上下文中使用术语*服务*，那么它通常意味着这是一个实现一组有限功能的软件，然后由应用的其他部分使用。随着本书的深入，我们将讨论定义略有不同的其他类型的服务。 |
天真地说，分布式应用架构是单片应用架构的对立面，但先看看这种单片架构并不是没有道理的。传统上，大多数业务应用都是以这样一种方式编写的，即结果可以被视为一个单一的、紧密耦合的程序，运行在数据中心某处的命名服务器上。它的所有代码都被编译成一个二进制文件或几个紧密耦合的二进制文件，这些文件在运行应用时需要位于同一位置。在这种情况下，运行应用的服务器(或者更一般的主机)具有定义明确的名称或静态 IP 地址也很重要。让我们看下面的图表来更清楚地说明这种类型的应用架构:
![](img/bc8eaa59-637d-419a-97e4-1e00a8916435.png)
Monolithic application architecture
在上图中，我们看到一个名为**的蓝色盒子-12a** 的服务器，其 IP 地址为`172.52.13.44`，运行一个名为**宠物店**的应用，该应用由一个主模块和几个紧密耦合的库组成。
现在，让我们看看下图:
![](img/6414105c-56f4-43d1-ba34-b8fbdaafdb23.png)
Distributed application architecture
在这里，突然之间，我们不再只有一个命名服务器，而是有很多，它们没有人性化的名称，而是一些唯一的标识，可以是类似于**通用唯一标识符** ( **UUID** )的东西。突然之间，宠物店应用不再由单一的整体块组成，而是由大量交互但松散耦合的服务组成，例如**宠物 api** 、**宠物网络**和**宠物库存**。此外，每个服务都在服务器或主机群集中的多个实例中运行。
你可能想知道为什么我们在一本关于 Docker 容器的书中讨论这个，你问得对。虽然我们将要研究的所有主题都同样适用于容器尚不存在的世界，但重要的是要认识到容器和容器编排引擎有助于以更高效、更直接的方式解决所有问题。过去在分布式应用架构中很难解决的大多数问题在容器化的世界中变得非常简单。
# 模式和最佳实践
分布式应用架构有许多引人注目的好处，但与单一应用架构相比，它也有一个非常显著的缺点——前者要复杂得多。为了驯服这种复杂性，业界提出了一些重要的最佳实践和模式。在接下来的章节中，我们将更详细地探讨一些最重要的问题。
# 松散耦合的组件
解决一个复杂问题的最好方法一直是把它分成更容易处理的小问题。举个例子，一步建成一所房子是极其复杂的。用简单的部件建造房子要容易得多，然后再组合成最终的结果。
这同样适用于软件开发。如果我们将一个非常复杂的应用划分成互操作的更小的组件，并一起组成整个应用，那么开发这个应用会容易得多。现在，如果这些组件只是松散地相互耦合，那么单独开发它们就容易得多。这意味着组件 A 对组件 B 和 C 的内部工作方式不做任何假设，而只对如何通过定义良好的接口与这两个组件进行通信感兴趣。如果每个组件都有一个定义良好且简单的公共接口，通过该接口可以与系统中的其他组件和外部世界进行通信，那么这就使我们能够单独开发每个组件，而不会隐含地依赖于其他组件。在开发过程中，系统中的其他组件可以被存根或模拟代替，以允许我们测试我们的组件。
# 有状态与无状态
每个有意义的业务应用都创建、修改或使用数据。数据也称为状态。创建或修改持久数据的应用服务称为有状态组件。典型的有状态组件是数据库服务或创建文件的服务。另一方面，不创建或修改持久数据的应用组件称为无状态组件。
在分布式应用架构中，无状态组件比有状态组件更容易处理。无状态组件可以很容易地放大和缩小。它们还可以在群集的完全不同的节点上快速、轻松地拆除和重新启动，所有这些都是因为它们没有与之关联的持久数据。
考虑到这一事实，以一种大多数应用服务都是无状态的方式来设计系统是有帮助的。最好将所有有状态组件推到应用的边界，并限制它们的数量。管理有状态组件很难。
# 服务发现
当我们构建由许多相互通信的独立组件或服务组成的应用时，我们需要一种机制来允许独立组件在集群中找到彼此。找到对方通常意味着需要知道目标组件在哪个节点上运行，以及在哪个端口上监听通信。大多数情况下，节点由一个 IP 地址和一个端口来标识，这只是一个定义明确的范围内的数字。
技术上，我们可以告诉**服务 A** ，它想和一个目标**服务 B** 通信，目标的 IP 地址和端口是什么。例如，这可能通过配置文件中的一个条目发生:
![](img/e524a406-27c6-4d99-9f49-dea2a3845caf.png)
Components are hardwired