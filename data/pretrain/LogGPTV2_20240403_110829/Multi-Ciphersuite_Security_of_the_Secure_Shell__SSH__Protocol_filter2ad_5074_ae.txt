collision resistant, and that the concatenation of the two hash values (session id computation
and key derivation) must form a pseudorandom function. The pseudorandomness property
guarantees that no bits from the input leak when computing the hash function.
Session IDs vs. matching conversations. A secure authentication protocol can, loosely
speaking, be deﬁned as a protocol where the success probabilities of active and passive adversaries
are equal, up to a negligible diﬀerence. There are two main possible formalizations of this
concept: session IDs and matching conversations. We initially tried to base our proof that SSH
is a secure authentication protocol on the classical notion of matching conversations (when the
two parties have the same transcript of communication), in order to make our result comparable
to previous work. However, SSH itself makes this impossible, because of a special option to
negotiate keys more quickly: the SSH client may choose to start an abbreviated handshake, by
guessing which cryptographic parameters the server would accept, sending messages KEXINIT
and KEXDH INIT simultaneously. The SSH server however may refuse this option, and in this
case, the KEXDH INIT message is discarded, and replaced by a new message KEXDH INIT(cid:48) to the
server. In such a scenario, an adversary may simply change the original value of KEXDH INIT
arbitrarily, thus breaking the matching conversations condition, and nevertheless make both
sessions accept. Instead, the SSH speciﬁcation itself suggests the use of a protocol-speciﬁc session
ID, a hash value H over the initial handshake messages. This hash value is then used to generate
and verify the signatures both on client and server side.
PRF-ODH. Readers may wonder why we do not need the PRF-Oracle-Diﬃe–Hellman (PFR-
ODH) assumption used in the analysis of signed-DH in TLS [20, 26]. In TLS, a hypothetical
adversary who can solve the CDH problem can make a client oracle accept maliciously by
intercepting all messages after ServerKeyExchange, and then faking a valid ServerFinished
message. At the same time, this adversary can refuse to cooperate in breaking DDH by testing
if the DDH challenge was embedded in the current session. All this may not happen in SSH:
here, acceptance directly depends on signature veriﬁcation.
SHA-1 collisions exist. For any unique hash function, we know that collisions exist due to
the pigeonhole principle. Thus there are algorithms that output a collision in constant time:
it is just hardwired into their code. So we do not show that if SSH is insecure then we could
output some SHA-1 collision; instead we give an algorithm that, if SSH is insecure, helps us in
computing new SHA-1 collisions.
5.2 Server-only-authentication mode
In this section we drop subscripts for ciphersuites: SSH denotes a single ciphersuite of the signed-
Diﬃe–Hellman SSH protocol described in Section 4, with signature scheme SIG, Diﬃe–Hellman
group of prime order q generated by g, and hash function H, and the BSAE scheme StE.
The following theorem shows that, if the hash function H is collision-resistant, the signature
scheme SIG is suf-cma-secure, the DDH problem for (g, q) is hard, the PRF is a secure PRF,
and the symmetric encryption is a secure BSAE scheme, then the (single ciphersuite) signed-
Diﬃe–Hellman SSH protocol is a secure server-only ACCE protocol.
Theorem 1 (SSH is server-only-ACCE-secure). Let µ be the length of the nonces in KEXINIT
and KEXREPLY (µ = 128), nP the number of participating parties and nS the maximum number
of sessions per party. The algorithms B1, . . . , B5 given in the proof of the theorem are such that,
16
for all algorithms A,
Advacce-so-auth
SSH
(A) ≤ (nP nS)2
2µ
+ Advcr
H(BA
1 ) + nP Advsuf-cma
SIG
(BA
2 )
(2)
and
Advacce-so-aenc
SSH
(A) ≤ Advacce-so-auth
SSH
(cid:16)
(A)
g,q (BA
Advddh
PRF(BA
5 have approximately the same running time as A.
3 ) + Advprf
+ nP nS
4 ) + Advbsae
StE (BA
5 )
and BA
1 , . . . , BA
(cid:17)
In order to prove the theorem, we will proceed as follows. In Lemma 1 we show that the
SSH protocol is secure according to the single ciphersuite version of Deﬁnition 5 (i.e. there exists
no client session that accepts maliciously except with some small probability). Lemma 2 proves
that the single ciphersuite version of Deﬁnition 6 is also fulﬁlled (i.e. there exists no adversary
that is able to answer the encryption/integrity-challenge correctly, except with small advantage).
Lemma 1 (Server-only auth.). The algorithms B1 and B2 explicitly given in the proof of the
lemma, are such that, for all algorithms A,
Advacce-so-auth
SSH
(A) ≤ (nP nS)2
2µ
+ Advcr
H(BA
where nP , nS, and µ are as in the statement of Theorem 1, and BA
the same running time as A.
(BA
1 ) + nP Advsuf-cma
1 and BA
SIG
2 ) ,
2 have approximately
(3)
Proof. The essence of the proof is the observation that acceptance of a client session is the result
of a successful signature veriﬁcation. To be able to use this fact, we have to make sure that all
session IDs are diﬀerent (by aborting if a nonce is chosen twice or if a collision occurs in the
hash computation of the session ID).
Let break(0)
the sense of Deﬁnition 5.
δ be the event that occurs when a client session accepts maliciously in Game δ in
Game 0. The game equals the ACCE security experiment described in Section 3.2. Thus,
Advacce-so-auth
SSH
(A) = Pr(break(0)
0 ) .
(4)
Game 1. In this game we add an abort rule for non-unique nonces ri. Speciﬁcally the
challenger collects a list L of all cookies ri sampled by the challenger during the simulation. If
one cookie appears twice, we abort the simulation. Thus
Pr(break(0)
0 ) ≤ Pr(break(0)
1 ) +
(nP nS)2
2µ
.
(5)
Game 2. In this game we exclude hash collisions. Note that in this game we can compute
all session keys and session identiﬁers honestly, and we maintain a list Coll, where all the
input/output pairs of all executions of the hash function H are recorded. We abort if at any
time a pair (in, H(in)) is added to Coll such that there already exists an entry (in(cid:48), H(in(cid:48)))
in Coll with H(in) = H(in(cid:48)) but in (cid:54)= in(cid:48). Now we construct BA
1 as follows: B1 simulates the
SSH protocol and interacts with A. Whenever A wins the acce-so-auth game, B1 inspects the
recorded simulation to see if a hash collision occured. If it did, B1 outputs this collision. Since
B1 ﬁnds a collision, we have that
Pr(break(0)
1 ) ≤ Pr(break(0)
2 ) + Advcr
H(BA
1 ) .
(6)
17
Technically, we construct an algorithm BA
Game 3. In this game we exclude signature forgeries. We abort the simulation if some
session πs∗
i∗ accepts after it receives a signature which was never output of a session with a
matching session identiﬁer. Note that we have excluded nonce and hash collisions, so from now
on all values to be signed are diﬀerent. Thus any abort event is related to a signature forgery.
2 which simulates the SSH protocol as in Game 1.
B2 interacts with A. B2 receives a public key pk from an suf-cma signature challenger for SIG,
guesses which public key pkj∗ the session will use to verify the signature (which costs us a factor
nP in the reduction) and sets pkj∗ = pk. Since the signing key has to be uncorrupted it is no
problem for the reduction that the secret signing key is unknown. If B2 needs to sign a message
on behalf of party Pj∗, it makes a signing query to the suf-cma challenger. If the session πs∗
i∗
maliciously accepts in the sense of deﬁnition 5 in Game 3, we know from the discussion above
that the maliciously accepting session has veriﬁed a signature σ(cid:48) over a session ID H where there
is no session πt
j∗ with the same session ID, thus this signature was not generated with a call to
the signature challenger. Thus B2 has found (H, σ(cid:48)) as a signature forgery, so
Pr(break(0)
2 ) ≤ Pr(break(0)
3 ) + nP Advsuf-cma
SIG
(BA
2 ) .
(7)
Final analysis. Now all signatures are computed by legitimate parties only, and are all
computed for diﬀerent session IDs. Thus there is no way for a session to accept maliciously, and
we have
Pr(break(0)
3 ) = 0 .
(8)
Lemma 2 (Channel security, server-only auth. mode). The algorithms B3, B4, and B5, explicitly
given in the proof of the lemma, are such that, for all algorithms A,
SSH
(A) ≤ Advacce-so-auth
3 )+Advprf
Advacce-so-aenc
where nP , nS, and µ are as in the statement of Theorem 1, and BA
the same running time as A.
(A)+nP nS(Advddh
g,q (BA
PRF(BA
4 , BA
3 , BA
SSH
4 )+Advbsae
StE (BA
5 ))
(9)
5 have approximately
Proof. Let break(1)
in Game δ in the sense of Deﬁnition 6.
δ be the event that occurs when A answers the encryption challenge correctly
Pr(break(1)
0 ) ≤ Pr(break(1)
Game 0. This game equals the ACCE security experiment described in Section 3.2.
Game 1. This game is identical to Game 3 of Lemma 1 and we abort if some session accepts
maliciously. With the previous sequence of games we ensured unique nonces, excluded hash
collisions and signature forgeries. Thus, in this game any session that accepts non-maliciously in
the sense of Deﬁnition 5 has a unique uncorrupted partner session. From the previous proof, we
have
(A) .
From now on, we always have a matching session for the session πs∗
i∗ where the adversary tries
to guess the random bit: for server sessions through Deﬁnition 5, and for client sessions through
this game.
Game 2. In this game, we guess the session for which the adversary outputs the bit b(cid:48).
We guess two indices (i∗, s∗) ∈ [nP ] × [nS] and abort if the adversary outputs (i, s, b(cid:48)) with
(i∗, s∗) (cid:54)= (i, s). This happens with probability
. We then exploit that no client session
maliciously accepts due to Game 1, so we have that there exists a unique partner session πt∗
j∗
which can be easily determined by the simulator. Thus we have:
1 ) ≤ nP nS · Pr(break(1)
1 ) + Advacce-so-auth
Pr(break(1)
2 ) .
(11)
(10)
nP nS
SSH
1
18
Game 3. In this game we replace the value K = gxy computed by πs∗
i∗ and πt∗
j∗ with a
random value K∗. Since we have excluded maliciously accepting sessions, and since πs∗
i∗ fulﬁlls
all conditions from Deﬁnition 6, the adversary cannot inﬂuence these values. Any adversary
A that can distinguish this game from the previous game can directly be used to construct an
adversary BA
3 that can break the DDH assumption: let (g, gu, gv, gw) be the DDH challenge.
We set gx := gu and gy := gv, and K∗ := gw. If w = uv, then we have K∗ = K, and we are in
Game 2, otherwise we are in Game 3. Thus
Pr(break(1)
2 ) ≤ Pr(break(1)
3 ) + Advddh
g,q (BA
3 ) .
(12)
Game 4.
In this game we replace the values H, k1, ..., k6 computed by πs∗
j∗ as
6. Any adversary A that can distinguish this
PRF(K∗, sid) with random values H∗, k∗
game from the previous game can directly be used to construct an adversary BA
4 that can break
1||...||k∗
the PRF assumption: let S = H||k1||...||k6 be the output of PRF, and let S∗ = H∗||k∗
6
be a random string of the same length. For S we are in Game 3, and for S∗ in Game 4. Thus
i∗ and πt∗
1, ..., k∗
Pr(break(1)
3 ) ≤ Pr(break(1)
Final analysis. We now have that the keys k∗
6 are information-theoretically indepen-