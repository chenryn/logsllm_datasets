branch BRANCHd is the smallest distance from each
basic block on the input’s execution trace to BRANCHd
evaluated based on the call graph and function CFGs of
(cid:2) (c.f. Section III-A). We adopt a greedy fuzzing mech-
P
anism that prioritizes mutations for inputs with shorter
distances to BRANCHd, places them at the head of the
fuzzing queue and assigns more mutation opportunities
to them. For the example shown in Listing 1, inputs in
jpg format get priorities in both chances and frequencies
of mutation. When fuzzing failed to generate test inputs
with smaller distance to BRANCHd within a speciﬁed
time threshold, the control is transferred to the directed
symbolic execution engine.
• Interaction Strategy. 1) When transferring from directed
fuzzing to directed symbolic execution, the previously
generated test inputs are ordered by their distances to the
target. They will then be handled in order by the directed
symbolic execution engine. Recall the example shown in
Listing 1. Suppose the directed fuzzing engine gets stuck
by the check in line 13, then the ﬁrst test input transferred
to the directed symbolic execution engine will be such an
input that could reach line 13 but make the check fails. 2)
When the control is transferred back to directed fuzzing,
new inputs generated by the symbolic execution engine
will also be inserted into the fuzzing engine’s queue by
distance. Since the new generated inputs can reach deeper
paths leading to the target, they will be placed at the head
of the queue in order to get mutated as early as soon.
• Directed Symbolic Execution Engine. When the fuzzing
the symbolic execution engine is
engine gets stuck,
invoked to deal with the so far generated test inputs.
For each input and the corresponding execution trace,
we ﬁrst
identify a sequence of dominators on paths
from the stuck branch to BRANCHd. The dominators
are control branches that should be get through before
reaching BRANCHd. The goal of symbolic execution
is to discover new inputs that could reach at least one
of the dominators. Once such inputs are generated, the
control is transferred back to the fuzzing engine. In this
way, a path exploration problem is decomposed into a
group of dominator exploration problems, avoiding taking
607
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:57:01 UTC from IEEE Xplore.  Restrictions apply. 
unnecessary paths into consideration. Moreover, each
time the control transferred from one engine to the other,
we get new inputs with shorter distance to BRANCHd
and ﬁnally converge at BRANCHd.
Step 3: Vulnerability Veriﬁcation. Once we ﬁnd an input
(cid:2), we runP with I. If
I that could reach BRANCHd in P
P crashes, then the patch is proven to be security-related.
Otherwise, we perform a speciﬁc fuzzing on P with I as the
initial input. During fuzzing, only test inputs that could reach
(cid:2) are saved for further mutation. The process
BRANCHd in P
continue until P crashed or time expired.
III. TECHNICAL DETAILS
In this section, we present our ToIG solution in details,
especially the distance-based directed fuzzing mechanism, the
dominator-based directed symbolic execution mechanism, and
the interaction strategy between the directed fuzzing engine
and the directed symbolic execution engine.
A. Directed Fuzzing
The directed fuzzing engine of 1dVul, named 1dVul-Fuzzer,
takes a binary program P, a speciﬁc target branch T in P,
and a set of initial inputs Iθ for P as inputs. 1dVul-Fuzzer
is designed on the foundation of AFL which is a popular
coverage-directed fuzzer. AFL relies on input mutation and
instrumentation to obtain the coverage information, so as
to determine the subsequent fuzzing order and frequency of
generated inputs. 1dVul-Fuzzer extends AFL to take advantage
of the distance between each test input and the target branch to
guide mutation and fuzzing. Algorithm 1 describes the process
of 1dVul-Fuzzer and the grey lines in the algorithm show how
it differs from AFL. Details are explained as follow.
1) Evaluating distance (line 4, 13-15): To kick off the
fuzzing process, 1dVul-Fuzzer applies each initial input I in
Θ to program P and records the corresponding execution trace.
The trace is further used to calculate the distance between each
input and the target branch T (line 4). Line 13-15 performs
the same process on each mutation input Iθ and adds Iθ to the
set H if its execution trace reaches T, i.e. the distance between
Iθ and T is equal to zero.
The distance between Iθ and T is evaluated based on the
interprocedural CFG of P. As previously mentioned in Section
II, the distance is deﬁned as the minimum distance between
each basic block in the execution trace of Iθ and T on the
CFG of P. This is reasonable as the minimum distance show
the closest site where the input can get around the target
branch. Note that, each target branch corresponds to an edge
between two basic blocks on the CFG, marked as s → d.
When calculating the distance between Iθ and T, we only
consider the distance from each basic block on the execution
trace to the source node s of T.
Recovering an accurate interprocedural CFG from binary
is time-consuming and challenging, especially when there are
plenty of indirect jumps between different functions [13]. To
provide distance-based guidance for fuzzing in a reasonable
time, 1dVul-Fuzzer evaluates distance between Iθ and T based
Algorithm 1 Workﬂow of 1dVul-Fuzzer
Input: P, a binary program
Θ, a set of initial inputs
T, a target branch of P
d ← run_target(P, T, I)
Output: H, a set of inputs that could reach T in P
1: H ← φ
2: Q ← Θ
3: for I in Q do
4:
5: end for
6: repeat
7:
8:
9:
10:
11:
12:
13:
n ← calculate_score(θ)
for i = 1 → n do
Iθ ← mutate_input(θ)
d ← run_target(P, T, Iθ)
if d == 0 then
Q ← sort_by_dist(Q)
θ ← choose_f irst(Q)
repeat
end if
if is_interesting(Iθ) then
Q ← insert_by_dist(Q, Iθ, d)
add Iθ to H
14:
15:
16:
17:
18:
19:
20:
21:
22:
23: until timeoutreached
24: return H
end if
end for
θ ← choose_next(Q, θ)
until θ is None or timeout reached
on the call graph (CG) of the whole program and the CFG
of each function. Distance calculated based on CG is called
function-level distance. Distance calculated based on CFG of
a certain function is called basic-block-level distance.
a) basic-block-level distance evaluation: Given a basic
block Bi from the execution trace of Iθ, the basic-block-level
distance evaluation considers only the length of path from Bi
to each call site node in function Fi’s CFG and the length of
path from function entry block to basic block Bs in function
Fs’s CFG, where Fi and Ft are functions that Bi and Bt
locate, respectively, and Bs refers to the source node of T in
function Fs’s CFG.
b) function-level distance evaluation: Given a basic
block Bi from the execution trace of Iθ, the function-level
distance evaluation consider the length of shortest path from
each function called by Fi and the target function Fs on the
call graph of program P.
Equation 1 shows how the distance between Bi and Bs is
calculated, where CSFi represents the set of call site nodes in
Fi, Fcsk denotes the function called at call site csk in function
Fi. db and df refer to basic-block-level distance evaluation
and function-level distance evaluation, respectively. Note that
Equation 1 evaluates harmonic mean [14] of distances for all
possible paths from Bi to Bs. A constant factor α is set to
608
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:57:01 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 1. Framework of 1dVul.
magnify the weight of function-level distance. Based on our
empirical study about the average length of path from entry
block to exit block on each function’s CFG, we set a constant
value 20 to the factor.
new mutation frequency unchanged. Overall, the new mutation
frequency increases along with the decrease of the normalized
distance.
(cid:3)
n(Iθ, T) =
nori × 2−4.64×( (cid:2)d−0.5))
nori × 2−2.64×( (cid:2)d−0.5))
(cid:2)
d = dist(Iθ, T) − min_d
max_d − min_d
min_d = min
λ
max_d = max
λ
{λ|λ = dist(Ii, T), Ii ∈ Q}
{λ|λ = dist(Ii, T), Ii ∈ Q}
0 ≤ (cid:2)
0.5 ≤ (cid:2)
d ≤ 0.5
d ≤ 1.0
(2)
(3)
⎧⎪⎪⎪⎨
⎪⎪⎪⎩
(db(Bi, csk) +α ∗ df (Fcsk , Fs)
Avg
csk∈CSFi
+db(B
db(Bi, s),
Fs
entry, s)),
d(Bi, Bs) =
Bi /∈ Fs
Bi ∈ Fs
(1)
Once we get the distance between each basic block for the
execution trace of Iθ and T, the minimum one is regarded
as the distance between Iθ and T, which is denoted by
dist(Iθ, T). If dist(Iθ, T) is zero, it means that the current
input Iθ can reach the target branch T.
2) Sorting input queue Q by distance (line 7): At the
beginning of the fuzzing process, 1dVul-Fuzzer sorts inputs
in queue Q by their distances to the target branch T in order
to make sure that inputs with shorter distance to T can get
mutated earlier. The sorting process will be performed each
time the queue is traversed to the tail, as the insert action
perform in line 18 (described later) only guarantee that the
newly generated inputs are inserted behind their parent-inputs
by distance. As a result, the whole queue may be unordered.
3) Computing mutation frequency for each input (line
10): To make the fuzzing process approaching the target
branch more quickly, 1dVul-Fuzzer also assign inputs with
smaller distance to the target more opportunities to get mu-
tated. Similar to AFL, 1dVul-Fuzzer evaluates a score for
each input in queue Q. Inputs with higher score get more
frequencies to make non-deterministic mutations. Equation 2
shows how the mutation frequency for a certain input Iθ is
d refers
to the normalized value of dist(Iθ, T), which is illustrated by
Equation 3.
generated. nori is the mutation frequency set by AFL. (cid:2)
Note that the coefﬁcients 4.64 and 2.64 is determined based
on the following strategy. If the normalized distance of an
input is 0 (minimum), the new mutation frequency will be 5
times larger than the original one of AFL. If the normalized
distance is 1 (maximum), the new mutation frequency will be
0.4 times. If the normalized distance is 0.5 (middle), keep the
4) Inserting mutation inputs into queue Q (line 18): AFL
will insert a new mutation input into queue Q if it is considered
to be interesting, i.e. its execution trace covers new branches
or hit some branch with different times. To ensure that inputs
with smaller distance to the target branch are earlier mutated,
1dVul-Fuzzer adjusts the insert action. Each new generated
and interesting mutation input Iθ is inserted into Q in the
ascending order of dist(Iθ, T) behind θ. This insert action
make sure that Iθ can soon be chosen to get mutated in later
iterations of the inner loop.
B. Directed Symbolic Execution
When 1dVul-Fuzzer gets stuck, i.e. no test input with shorter
distance to the target branch is generated within a speciﬁc
time threshold, 1dVul transfers control from 1dVul-Fuzzer
to our directed symbolic execution engine, which is called
1dVul-Explorer. As mentioned in Section II-B, 1dVul-Explorer
utilizes a dominator-based symbolic execution mechanism for
path exploration and input generation. Its inputs come from the
input Queue Q of 1dVul-Fuzzer. Among the inputs, the one
with the shortest distance to T will be explored ﬁrst. Suppose
the basic block which has the shortest distance from itself to
T on the execution trace of the current input is denoted by
BBi, the goal of 1dVul-Explorer is to discover new inputs
that could reach at least one of the dominators of T from the
BBi to T.
609
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:57:01 UTC from IEEE Xplore.  Restrictions apply. 
Symbolic execution is a classic program analysis technique
which symbolizes the input and simulates the execution of pro-
gram with states and constraints. Concolic execution [15, 16]
is a hybrid technique that performs symbolic execution on the
execution path. By symbolically re-executing the trace of a
given input, concolic execution generates a set of symbolic
constraints, accompanying with a set of uncovered branches
to be explored. 1dVul-Explorer performs concolic execution
on program P with inputs generated by 1dVul-Fuzzer. For a
given input I, traditional concrete execution will try to explore
branches that are not taken on the execution trace of I. We
call these branches as missing branches. However, not all
of the missing branches lead paths to the target. In order
to avoid exploring such branches, 1dVul-Explorer employs a
dominator-sequence based-branch selection startegy.
A
m1
B
m2
m3
E
C
m4
T
D
G
F
m5
Fig. 2. Example of directed symbolic execution.
Take the CFG shown in Fig. 2 as an example, where each
node refers to a basic block and the edges refers to control
ﬂow. Suppose T is the basic block that involves the target
branch and the bold edges make up the execution trace of the
current input: A → B → C → D → F → G. m1-m5 denotes
missing branches that are not taken by the current trace. As
one can see, in order to make the execution reach T, we should
ﬁrst get through A, B and C, successively. In this example, A,
B and C are dominators of T that each path from the entry of
CFG to T should get through them ﬁrst. The sequence of A →
B → C forms a Dominator Sequence [17] of T. Traditional
concolic execution will explore all missing branches shown in
Fig. 2. However, generating inputs for m1, m2 and m5 make no
contribution to the goal of ToIG. In order to avoid unnecessary
path exploration and generate inputs with shorter distances to
T than I effectively, 1dVul-Explorer only explores branches
that could lead paths to the target, i.e. missing branches that
belong to the dominator sequence of T.
Algorithm 2 describes how 1dVul-Explorer works. It takes
a binary program P, a speciﬁed target branch T in P, and a
test input selected from the input queue Q of 1dVul-Fuzzer.
The algorithm is supposed to generate new inputs with shorter
distance to T than I. Details of the algorithm is explained as
Algorithm 2 Workﬂow of 1dVul-Explorer
Input: P, a binary program