505
557
609
661
714
765
818
876
949
977
1029
1083
1136
304
575
840
1112
1395
1648
1929
2196
3267
2774
3011
3284
3572
3852
4144
4385
4636
5061
5194
Table 3: Comparison of signing times (in milliseconds) between [18] and our protocol. The times
for [18] are of local computation only (without communication), whereas the times for our protocol
are in AWS with real communication.
5.3 Proof of Security of Protocol 5.1
Theorem 5.2 Protocol 5.1 securely computes Fecdsa with abort in the Fmult-hybrid model, in the
presence of a malicious adversary corrupting any t  q/2 with probability 1/2 (see
Step 9 in the simulation description). We therefore have to show that this is also the same in a
real execution. Nevertheless, this follows immediately from the fact that for every k ∈ Zq resulting
in s(cid:48) = k−1 · (m(cid:48) + r · x) it follows that −k results in s(cid:48) = −k−1 · (m + r · x) = q − k−1 · (m + r · x);
in both cases r is the same since if k · G = (rx, ry) then −k · G = (rx,−ry). This implies that the
probability of receiving s(cid:48)  q/2. This
completes the proof.
5.4 Extending the Protocol to Threshold (and General) Access Structures
Our protocol is described using n-out-of-n additive sharing of the ECDSA private key x. This
therefore yields a protocol that is secure for any t < n corruptions, but also requires all n parties
to sign. For a full custody solution, it must be possible to deﬁne a more general access structure.
This is due to the fact that when currency needs to be transferred, not all parties may be available.
Using known techniques, it is possible for the n parties to generate a Shamir sharing of x with
threshold t, in order to enable a subset of any t parties to sign while preserving security for any
t(cid:48) < t corruptions. Once the private key x is shared in this way, our protocol for ECDSA signing
proceeds in almost exactly the same way as described in Protocol 5.1, with the sole change being
that the aﬃne operation called to generate shares of β includes the appropriate Lagrange coeﬃcients
so that β equals ρ· (m(cid:48) + x· r). (Note that inside Fmult each party must hold a simple additive share
23
βi of β, but this is achieved by including the Lagrange coeﬃcients) Of course, it is also necessary
to generate a Shamir sharing of d (as in the init phase of Fmult), to enable computing FcheckDH,
which requires shares of the private ElGamal key associated with P.
(t − 1) polynomial p(·) where the ECDSA private key is x = p(0). Denote p(z) = (cid:80)t−1
The above requires a modiﬁcation to the key generation phase in order to generate these shares.
Fortunately, it is not diﬃcult to generate t-out-of-n shares in a robust way for ECDSA, as described
in [13] (although their signing protocol only works for 2-out-of-n). We sketch this now, using
the Fmult functionality. The idea is for the parties to generate a sharing of a random degree-
(cid:96)=0 c(cid:96) · z(cid:96);
note that x = p(0) = c0. This polynomial is generated by the parties calling (input, sid(cid:107)(cid:96)) for
(cid:96) = 0, . . . , t − 1, to deﬁne the coeﬃcients (c(cid:96) is the coeﬃcient with identiﬁer sid(cid:107)(cid:96)). Next, the
parties call (element-out, sid(cid:107)0) to obtain the ECDSA public key Q = c0 · G = x · G. Finally,
each party Pi needs to obtain its Shamir share p(i) of the private key. This can be achieved by a
variant of the aﬃne operation, for the parties to compute ElGamal encryptions and shares of p(i)
for i = 1, . . . , n; this is just computing a local linear combination of the shares of the coeﬃcients
and the appropriate value i0, i1, i2, . . . , it−1. Once the parties hold these shares and the associated
ElGamal encryptions, they can run a variant of element-out that provides the value to only one
party, in order for each Pi to receive p(i) · G. Finally, the parties can all send their shares of p(i)
to Pi, who sums them and veriﬁes that the result is correct by multiplying G by the sum and
comparing the result to the value received in element-out. This prevents any party from providing
an incorrect share. In order to ensure that Pi learns nothing but the sum, each Pj can randomly
mask its share and send shares of the mask to all other parties.
The above can be generalized to any linear secret sharing scheme for any access structure, as
long as such a scheme has an eﬃcient method of robustly sharing x (and obtaining Q).
An important access structure. One speciﬁc access structure that is of practical interest
for cryptocurrency custody is the following. Deﬁne (cid:96) sets of users A1, . . . , A(cid:96) of sizes n1, . . . , n(cid:96),
respectively, and deﬁne authorized thresholds t1, . . . , t(cid:96) for each set. Then, deﬁne the access
structure to be any combination of AND/OR over these sets. For example, one could deﬁne
(A1 ∨ A2) ∧ (A3 ∨ A4) ∧ A5, which means that in order to sign, an appropriate threshold is needed
in A1 or A2, and in A3 or A4 and in A5. To be concrete, A5 could denote a set of servers at a
trustee (that rely on automatic authorization and not human veriﬁcation), A3 and A4 could be two
sets of shift workers at the ﬁnancial institution oﬀering the custody solution, and A1 and A2 could
be analogous workers at the customer who owns the cryptocurrency. Each of the sets may have
its own threshold which trades oﬀ security and the diﬃculty of contacting a large enough set when
funds need to be transferred. Our protocol easily supports such an access structure by using the
well-known method of traversing the circuit from the output to the input, and additively sharing
the key at an AND gate while replicating the key at an OR gate. Finally, Shamir sharing is used
to split the key shares at each node amongst the deﬁned subset with the deﬁned threshold.
6 Private Multiplication Instantiations
6.1 Private Multiplication Using OT
A multiplication protocol that achieves the above properties can be eﬃciently constructed using
the well-known oblivious-transfer based approach for multiplication. This approach was introduced
by [20] but suﬀers from selective-bit attacks. This problem can be overcome by encoding the
24
receiver’s inputs, as was recently shown in [13] also in the context of ECDSA. When running this
protocol with oblivious transfer that is secure in the presence of malicious adversaries, the corrupted
parties’ inputs to the oblivious are actually explicitly deﬁned (and can be extracted). Thus, when
correct inputs are used, this protocol can be simulated, implying input indistinguishability.
In
contrast, if the adversary inputs incorrect values to the OTs that do not deﬁne any real input (i.e.,
(cid:96)=1 c(cid:96) except with
are inconsistent between the OTs), then the result will not be the valid c =(cid:80)n
negligible probability. Thus, in such a case, we merely need the ﬁrst privacy requirement.
Complexity. When using OT extension [26], private multiplication requires the parties to carry
out a setup step, where a public key is established which is used to compute seeds for the sender and
receiver. Then, these seeds are expanded by a PRG (pseudo-random generator) to generate random
correlated pads to mask the transmitted messages. The setup step involves each party sending
40KiB and carrying out 320 elliptic-curve multiplications. (We have 320 multiplications since [26]
requires running κ base OTs, that cost 3 multiplications for the sender and 2 for the receiver, and
thus 2.5 on average. In practice, we take κ = 128, thereby requiring 320 multiplications.) The
extension part is cheap in terms of computation but requires each party to transmit 97KiB to each
of the other parties for each multiplication.
6.2 Private Multiplication Using Paillier
6.2.1 The Multiplication Protocol
We now present an alternative method of achieving private multiplication which has much lower
communication complexity but higher computation (but still very reasonable). This protocol is
based on the folklore multiplication protocol based on additively homomorphic encryption, with