但是在储存的时候，将会先进行压缩后再储存（看来对于大文件似乎蛮有用的！）
d ：当 dump 程序被执行的时候，设置 d 属性将可使该文件（或目录）不会被 dump 备份
i ：这个 i 可就很厉害了！他可以让一个文件“不能被删除、改名、设置链接也无法写入或新增数据！”
对于系统安全性有相当大的助益！只有 root 能设置此属性
s ：当文件设置了 s 属性时，如果这个文件被删除，他将会被完全的移除出这个硬盘空间，
所以如果误删了，完全无法救回来了喔！
u ：与 s 相反的，当使用 u 来设置文件时，如果该文件被删除了，则数据内容其实还存在磁盘中，
可以使用来救援该文件喔！
注意1：属性设置常见的是 a 与 i 的设置值，而且很多设置值必须要身为 root 才能设置
注意2：xfs 文件系统仅支持 AadiS 而已
范例：请尝试到/tmp下面创建文件，并加入 i 的参数，尝试删除看看。
[root@study ~]# cd /tmp
[root@study tmp]# touch attrtest <==创建一个空文件
[root@study tmp]# chattr +i attrtest <==给予 i 的属性
[root@study tmp]# rm attrtest <==尝试删除看看
rm: remove regular empty file `attrtest'? y
rm: cannot remove `attrtest': Operation not permitted
# 看到了吗？呼呼！连 root 也没有办法将这个文件删除呢！赶紧解除设置！
范例：请将该文件的 i 属性取消！
[root@study tmp]# chattr -i attrtest
这个指令是很重要的，尤其是在系统的数据安全上面！由于这些属性是隐藏的性质，所以需要以 lsattr 才能看到该属性呦！其中，个人
认为最重要的当属 +i 与 +a 这个属性了。+i 可以让一个文件无法被更动，对于需要强烈的系统安全的人来说， 真是相当的重要的！里头还有相
当多的属性是需要 root 才能设置的呢！
此外，如果是 log file 这种的登录文件，就更需要 +a 这个可以增加，但是不能修改旧有的数据与删除的参数了！怎样？很棒吧！ 未来提
到登录文件 （十八章） 的认知时，我们再来聊一聊如何设置他吧！
lsattr （（显显示示文文件件隐隐藏藏属属性性））
[root@study ~]# lsattr [-adR] 文文件件或或目目录录
选项与参数：
-a ：将隐藏文件的属性也秀出来；
-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；
-R ：连同子目录的数据也一并列出来！
[root@study tmp]# chattr +aiS attrtest
[root@study tmp]# lsattr attrtest
--S-ia---------- attrtest
使用 chattr 设置后，可以利用 lsattr 来查阅隐藏的属性。不过， 这两个指令在使用上必须要特别小心，否则会造成很大的困扰。例如：
某天你心情好，突然将 /etc/shadow 这个重要的密码记录文件给他设置成为具有 i 的属性，那么过了若干天之后， 你突然要新增使用者，却一
直无法新增！别怀疑，赶快去将 i 的属性拿掉吧！
我们前面一直提到关于文件的重要权限，那就是 rwx 这三个读、写、执行的权限。 但是，眼尖的朋友们在第五章的目录树章节中， 一
定注意到了一件事，那就是，怎么我们的 /tmp 权限怪怪的？ 还有，那个 /usr/bin/passwd 也怪怪的？怎么回事啊？看看先：
[root@study ~]# ls -ld /tmp ; ls -l /usr/bin/passwd
drwxrwxrwt. 14 root root 4096 Jun 16 01:27 /tmp
-rwsr-xr-x. 1 root root 27832 Jun 10 2014 /usr/bin/passwd
不是应该只有 rwx 吗？还有其他的特殊权限（ s 跟 t ）啊？啊.....头又开始昏了～ @_@ 因为 s 与 t 这两个权限的意义与系统的帐号 （第
十三章）及系统的程序（process, 第十六章）较为相关， 所以等到后面的章节谈完后你才会比较有概念！下面的说明先看看就好，如果看不懂
也没有关系， 先知道s放在哪里称为SUID/SGID以及如何设置即可，等系统程序章节读完后，再回来看看喔！
Set UID
当 s 这个标志出现在文件拥有者的 x 权限上时，例如刚刚提到的 /usr/bin/passwd 这个文件的权限状态：“-rwsr-xr-x”，此时就被称为 Set
UID，简称为 SUID 的特殊权限。 那么SUID的权限对于一个文件的特殊功能是什么呢？基本上SUID有这样的限制与功能：
SUID 权限仅对二进制程序（binary program）有效；
执行者对于该程序需要具有 x 的可执行权限；
本权限仅在执行该程序的过程中有效 （run-time）；
执行者将具有该程序拥有者 （owner） 的权限。
讲这么硬的东西你可能对于 SUID 还是没有概念，没关系，我们举个例子来说明好了。 我们的 Linux 系统中，所有帐号的密码都记录在
/etc/shadow 这个文件里面，这个文件的权限为：“---------- 1 root root”，意思是这个文件仅有root可读且仅有root可以强制写入而已。 既然这个
文件仅有 root 可以修改，那么鸟哥的 dmtsai 这个一般帐号使用者能否自行修改自己的密码呢？ 你可以使用你自己的帐号输入“passwd”这个指
令来看看，嘿嘿！一般使用者当然可以修改自己的密码了！
唔！有没有冲突啊！明明 /etc/shadow 就不能让 dmtsai 这个一般帐户去存取的，为什么 dmtsai 还能够修改这个文件内的密码呢？ 这就
是 SUID 的功能啦！借由上述的功能说明，我们可以知道
1. dmtsai 对于 /usr/bin/passwd 这个程序来说是具有 x 权限的，表示 dmtsai 能执行 passwd；
2. passwd 的拥有者是 root 这个帐号；
3. dmtsai 执行 passwd 的过程中，会“暂时”获得 root 的权限；
4. /etc/shadow 就可以被 dmtsai 所执行的 passwd 所修改。
但如果 dmtsai 使用 cat 去读取 /etc/shadow 时，他能够读取吗？因为 cat 不具有 SUID 的权限，所以 dmtsai 执行 “cat /etc/shadow” 时，
是不能读取 /etc/shadow 的。我们用一张示意图来说明如下：
图6.4.1、SUID程序执行的过程示意图
另外，SUID 仅可用在binary program 上， 不能够用在 shell script 上面！这是因为 shell script 只是将很多的 binary 可执行文件叫进来执
行而已！所以 SUID 的权限部分，还是得要看 shell script 调用进来的程序的设置， 而不是 shell script 本身。当然，SUID 对于目录也是无效的
～这点要特别留意。
Set GID
当 s 标志在文件拥有者的 x 项目为 SUID，那 s 在群组的 x 时则称为 Set GID, SGID 啰！是这样没错！^_^。 举例来说，你可以用下面的
指令来观察到具有 SGID 权限的文件喔：
[root@study ~]# ls -l /usr/bin/locate
-rwx--s--x. 1 root slocate 40496 Jun 10 2014 /usr/bin/locate
与 SUID 不同的是，SGID 可以针对文件或目录来设置！如果是对文件来说， SGID 有如下的功能：
SGID 对二进制程序有用；
程序执行者对于该程序来说，需具备 x 的权限；
执行者在执行的过程中将会获得该程序群组的支持！
举例来说，上面的 /usr/bin/locate 这个程序可以去搜寻 /var/lib/mlocate/mlocate.db 这个文件的内容 （详细说明会在下节讲述），
mlocate.db 的权限如下：
[root@study ~]# ll /usr/bin/locate /var/lib/mlocate/mlocate.db
-rwx--s--x. 1 root slocate 40496 Jun 10 2014 /usr/bin/locate
-rw-r-----. 1 root slocate 2349055 Jun 15 03:44 /var/lib/mlocate/mlocate.db
与 SUID 非常的类似，若我使用 dmtsai 这个帐号去执行 locate 时，那 dmtsai 将会取得 slocate 群组的支持， 因此就能够去读取
mlocate.db 啦！非常有趣吧！
除了 binary program 之外，事实上 SGID 也能够用在目录上，这也是非常常见的一种用途！ 当一个目录设置了 SGID 的权限后，他将具
有如下的功能：
使用者若对于此目录具有 r 与 x 的权限时，该使用者能够进入此目录；
使用者在此目录下的有效群组（effective group）将会变成该目录的群组；
用途：若使用者在此目录下具有 w 的权限（可以新建文件），则使用者所创建的新文件，该新文件的群组与此目录的群组相同。
SGID 对于专案开发来说是非常重要的！因为这涉及群组权限的问题，您可以参考一下本章后续情境仿真的案例，应该就能够对于 SGID
有一些了解的！^_^
Sticky Bit
这个 Sticky Bit, SBIT 目前只针对目录有效，对于文件已经没有效果了。SBIT 对于目录的作用是：
当使用者对于此目录具有 w, x 权限，亦即具有写入的权限时；
当使用者在该目录下创建文件或目录时，仅有自己与 root 才有权力删除该文件
换句话说：当甲这个使用者于 A 目录是具有群组或其他人的身份，并且拥有该目录 w 的权限， 这表示“甲使用者对该目录内任何人创建
的目录或文件均可进行 "删除/更名/搬移" 等动作。” 不过，如果将 A 目录加上了 SBIT 的权限项目时， 则甲只能够针对自己创建的文件或目录
进行删除/更名/移动等动作，而无法删除他人的文件。
举例来说，我们的 /tmp 本身的权限是“drwxrwxrwt”， 在这样的权限内容下，任何人都可以在 /tmp 内新增、修改文件，但仅有该文件/目
录创建者与 root 能够删除自己的目录或文件。这个特性也是挺重要的啊！你可以这样做个简单的测试：
1. 以 root 登陆系统，并且进入 /tmp 当中；
2. touch test，并且更改 test 权限成为 777 ；
3. 以一般使用者登陆，并进入 /tmp；
4. 尝试删除 test 这个文件！
由于 SUID/SGID/SBIT 牵涉到程序的概念，因此再次强调，这部份的数据在您读完第十六章关于程序方面的知识后，要再次的回来瞧瞧
喔！ 目前，你先有个简单的基础概念就好了！文末的参考数据也建议阅读一番喔！
SUID/SGID/SBIT 权权限限设设置置
前面介绍过 SUID 与 SGID 的功能，那么如何设置文件使成为具有 SUID 与 SGID 的权限呢？ 这就需要第五章的数字更改权限的方法
了！ 现在你应该已经知道数字体态更改权限的方式为“三个数字”的组合， 那么如果在这三个数字之前再加上一个数字的话，最前面的那个数字
就代表这几个权限了！
4 为 SUID
2 为 SGID
1 为 SBIT
假设要将一个文件权限改为“-rwsr-xr-x”时，由于 s 在使用者权限中，所以是 SUID ，因此， 在原先的 755 之前还要加上 4 ，也就是：“
chmod 4755 filename ”来设置！此外，还有大 S 与大 T 的产生喔！参考下面的范例啦！
Tips
注意：下面的范例只是练习而已，所以鸟哥使用同一个文件来设置，你必须了解 SUID 不是用在目录上，而 SBIT 不是用在文件上的喔！
[root@study ~]# cd /tmp
[root@study tmp]# touch test <==创建一个测试用空档
[root@study tmp]# chmod 4755 test; ls -l test <==加入具有 SUID 的权限
-rwsr-xr-x 1 root root 0 Jun 16 02:53 test
[root@study tmp]# chmod 6755 test; ls -l test <==加入具有 SUID/SGID 的权限
-rwsr-sr-x 1 root root 0 Jun 16 02:53 test
[root@study tmp]# chmod 1755 test; ls -l test <==加入 SBIT 的功能！
-rwxr-xr-t 1 root root 0 Jun 16 02:53 test
[root@study tmp]# chmod 7666 test; ls -l test <==具有空的 SUID/SGID 权限
-rwSrwSrwT 1 root root 0 Jun 16 02:53 test
最后一个例子就要特别小心啦！怎么会出现大写的 S 与 T 呢？不都是小写的吗？ 因为 s 与 t 都是取代 x 这个权限的，但是你有没有发现
阿，我们是下达 7666 喔！也就是说， user, group 以及 others 都没有 x 这个可执行的标志（ 因为 666 嘛 ），所以，这个 S, T 代表的就是“空
的”啦！怎么说？ SUID 是表示“该文件在执行的时候，具有文件拥有者的权限”，但是文件 拥有者都无法执行了，哪里来的权限给其他人使用？
当然就是空的啦！ ^_^
而除了数字法之外，你也可以通过符号法来处理喔！其中 SUID 为 u+s ，而 SGID 为 g+s ，SBIT 则是 o+t 啰！来看看如下的范例：
# 设置权限成为 -rws--x--x 的模样：