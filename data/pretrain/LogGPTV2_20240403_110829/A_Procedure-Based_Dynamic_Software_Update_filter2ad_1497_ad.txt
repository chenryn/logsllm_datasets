larger 
instructions 
than  65536. 
However, this is not something that programmers can do; a 
compiler may help. 
that  use  constants  smaller 
There  are  ways  to  avoid  the  correction  of  external 
symbol  references  and  thus  simplify  the  update.  For 
example, we can design software such that each procedure 
has some extra space in it. Then we can make the apparent 
size  of new  and  old  version  procedures  identical  even  if 
the size of the  meaningful  code in  new version  procedure 
is actually larger than that of old version. Alternatively, we 
can add some dummy procedures that have sufficient sizes 
when  we design software. While both  of these approaches 
can make the address correction step unnecessary and thus 
greatly  simplify  the  update,  using  the  approaches  will 
increase the  program  size and  require changes to existing 
software. 
3.4. Dynamic update environment 
Figure  8  shows  the  dynamic  update  environment. 
Consider that a user runs an old version executable file that 
includes the signal handler  library  we developed. Now the 
software vendor  changes the  software and  releases  a  new 
version of executable file along with change notes. While a 
new  release  may  include  lots  of  changes,  such  a  major 
release is not  frequent, and many changes are small. Such 
small  changes  (e.g.,  changing  a  procedure  to  add  a 
functionality  or  fix  a  defect)  are  released  as  interim 
versions. 
Suppose  that  the  user  decided  to  install  an  interim 
version  using  our  method.  Before  the  actual  update,  the 
user  can  look  at  the  process  map  information,  version 
information,  and  the  history  of previous  dynamic  updates 
277 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:05:53 UTC from IEEE Xplore.  Restrictions apply. 
- 1 nrsrt I'IV 
- Pro'rdurc  namc 
-Path to cxe  file\ 
_____ 
Result  of update  1- -- 
Update tool 
Symbol tablc info 
its  functionality  constantly  evolves.  Dynamic  software 
update  can  help  to resolve this dilemma.  Since a  wireless 
Internet  gateway  is  fairly  complex,  we  build  a  relatively 
small  piece  of software  that  mimics  a  contents  converter 
Mobile Device info 
if  any.  (Whether  a  dynamic  update  is  possible  for  a 
software  change  may  be  specified  in  the  change  note 
released  from  the  vendor.)  Given  the  target  process 
identification,  the target procedure name,  and the  paths  to 
the  old  and  new  version  executable  files,  the  update  tool 
takes  care  of  all  necessary  actions  for  an  update.  All 
relevant  information about  a  dynamic  update, such  as the 
procedure  version  number,  update  time  and  executables 
files  involved, is  stored  in  the  unmapped  area during the 
update. 
the 
is  successful, 
If the update  is  unsuccessful, the tool  logs the cause of 
the failure and  prompts the  undo  of the  current update. If 
an  update 
tool  displays  detailed 
information  about  the  update,  such  as  the  location  of 
mapped  new version procedure, the size of the procedure, 
and corrected external  symbols. In  this study, the software 
tool  (which  is  marked  as  "Update  tool"  in  Figure  8) was 
written  in the C. We used Tcl/Tk to provide a graphic user 
interface. The size of the software tool  is about 2000 lines 
of source. 
4. Illustration of Dynamic Procedure Update 
This  section  illustrates  our  method  using  simulated 
wireless  Internet  gateway  software.  A  wireless  Intemet 
gateway  allows  wireless  users  to  access the  Internet.  For 
example, given  a request from  a wireless user, the  service 
manager  in  the  gateway  refers  to  the  user  profile  in  the 
database and  serves the request.  If  the service manager  is 
to return  any data to the user,  it  converts the format of the 
data  according  to  the  user's  device  characteristics before 
returning the data. A wireless Internet gateway is a typical 
application  that  requires  continuous  operation.  However, 
Fig 9: Contents convert process 
278 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:05:53 UTC from IEEE Xplore.  Restrictions apply. 
Change  1 
Change 2 
Fig 10: Examples  of dynamic update 
module of wireless Internet  gateway  and  use this  software 
to illustrate our method. 
a 
on 
based 
user’s  wireless 
contents  converter 
The  contents  converter  module 
reformats  HTML 
documents 
device 
characteristics, such  as  the  size  of display  panel  and  the 
mark-up  languages and scripts supported by the browser in 
the device. Suppose that a user’s device  supports cHTML 
(compact HTML;  refer to NTT DoCoMo “i-mode”). Then 
the  gateway’s 
translates  HTML 
documents to cHTML documents  for this  user  (Figure 9). 
The  converter  consists  of  several  procedures,  such  as 
remove-tags,  change-to-cHTML,  reform-docu,  and  so on. 
Given  a  HTML  document  and  the  information  of  a 
wireless device  (or user),  the  convert-to-chtml  procedure 
performs 
the  conversion.  Given  a  script  that  is  not 
the  remove-scripts 
supported  by  a  wireless  device, 
procedure executes the  script and  hands the  result  over to 
the  device. The remove-tags  procedure removes tags  that 
are not supported by  cHTML and  keeps  only the text part. 
The change-to-cHTML  procedure converts the attribute of 
a  tag  based  on  the  value  of  the  tag.  The  reform-docu 
procedure  converts  large contents  into a  series  of smaller 
contents to fit the display of a wireless device. 
Now  consider  the  dynamic  update  of  the  contents 
converter  module.  Suppose  that  the  software  vendor 
releases a new version  of cHTML to support new features. 
Let’s  consider two  examples.  The  first  example  (“Change 
1”  in  Figure  IO)  illustrates the dynamic update of a single 
procedure  in  the  contents  converter  module.  Specifically, 
the change-to-cHTML  procedure is changed, and the new 
version  (i.e.,  cHTML 2.0)  supports the    tag;  in 
the  previous  version,  cHTML  did  not  support  BLINK 
(which  means  the  attribute  part  will  be  blinking  on  the 
screen)  and  used  STRONG  (which  means  the  boldface 
display)  instead. 
Also,  we  allow  additional  options  in 
 tag so that  we can  describe the background  and 
text colors  in  more  detail.  The  second  example  illustrates 
the  dynamic  update  of  two  procedures.  Here, 
two 
procedures  are  changed  to  support  the  FONT tag;  in  the 
previous version, the FONT tag is removed  in remove-tags 
and only its attribute (i.e., the text part) is kept. Our update 
tools successfully update both examples while the software 
is running. 
the 
result  of 
the  update  of 
Figure 11 shows the user  interface of our update tool; it 
the 
actually  shows 
change-to-cHTML  procedure  (“Change  I  ” in  Figure  IO). 
The  figure shows that  the  PID  of the  target  process  (i.e., 
the  contents  converter)  is  14791.  A  new  version  of  the 
change-to-cHTML  procedure  is  extracted  from  the  new 
version  executable  file  (i.e., converter-vOl),  and  the  new 
version  procedure 
location  of 
OxFF380000. The size of the new version procedure ( I  560 
bytes) is bigger than that of the old version  (972 bytes). 
is  mapped 
the 
to 
5. Conclusions 
two  key 
This paper  presented  a method  to dynamically  update a 
single  or  multiple  procedures  of  running  software. 
Specifically,  the  paper  addressed 
issues  for 
procedure-based dynamic software update. First, the paper 
presented  a  well-defined  sequence  to  perform  an  update 
while  ensuring  correct  operation  and  small  performance 
loss.  Second,  the  paper  provided  a  solution  for  how  to 
make  the  new  version  procedure  work  correctly  in  the 
address space of the old  version  process. The method  was 
illustrated  in  the  SUN  Solaris  environment  running  on  a 
SPARC machine. 
In  contrast  to  most  previous  works,  which  rely  on 
279 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:05:53 UTC from IEEE Xplore.  Restrictions apply. 
f i l e   yiew 
I 
f i c t i o n   m t i a n  
P I D   o f   t a r q e t   D ~ O C B S S  . 14791 
T a r g e t   p i a '  e d u r e   name 
<hange-to_cHTML 
1 
P a t h   of  o l d   exe 
f i l e  
C o n v e r t e r  
P a t h   o f   new  e x 8  
f i l e  
i ~ n v r r t e r ~ ~ O 1  
G e t   o l d   v e r s i o n   procedure  i n f o  
G e t   new  v e r s i o n   ~ r o c e d u r e  i n f o  
E x t r a c t   new  v e r s i o n   p r o c s d u r s  
Map  new  procedure 
M o d i f y   e x t e r n a l   r e f e r e w e  
Trace  S t a c k   &  S e t   WetChDoint  t r a p  
M o d i f y   o l d   v e r s i o n   p r o c e d u r e  
M d i f y   o l d   "er  p r o c   on  d i s k  
m o d i f y   o l d   " e r   p r o c   o n  memory 
S y n c h r o n i z e   c a c h e  
O l d   v e r s i o n   P r O C e d U r e   v i r t u a l   a d d r e s s   . 1 1 3 6 8  
R e l e a s e   watched  a r e a  
o l d   C9721  . new  [15601  ( b y t e s )  
l o c a t i o n   7 "   a d d r e s s   s m c e  . f f 3 8 0 0 0 0  
New  v e r 5 i o n   p r o c e d u r e   v i r t u a l   a d d r e s s  
p r o c e d u r e   5 1 2 8  
Mapped  new  p r o ' .  
I  o k  
I  o k  
I  o k  
I  o k  
I  O k  
I  o k  
I  o k  
I  o k  
I 
ok 
I  o k  
I  o k  
1 1 3 6 8  
I . ~ _ _  
lllll__""_-_ 
~- 
"I_  I_- I 
Fig 11: lJser interface 
indirection, our method  directly modifies a part  of process 
address  space  to  perform  an  update.  Also,  the  method 
supports  a  small,  procedure-based  software  update.  As  a 
result, our method is relatively  simple and user-transparent. 
The  method  can  be  implemented  by  using  only  those 
services provided  by  an existing operating system. We can 
make  existing  programs  dynamically  changeable  by  only 
adding  signal  handling  routines  to  the  programs.  The 
method  can  deal  with  changes  in  the  target  procedure's 
external  interface  and  can  be  used  to  add  or  delete 
procedures.  Using  the  method  can  reduce  the  downtime 
caused  by  software upgrade  when  changes  are  limited  to 
the text and  local data. 
A  procedure-based  method  is  a  low-level approach that 
deals  with  internals of a  running  process.  As  a  result,  the 
method is, to a certain degree, dependent on the underlying 
operating system and the processor architecture. However, 
we speculate that the core concepts are applicable to other 
UNIX-like operating systems running on RlSC machines. 
A  limitation  of the method  is that we cannot use  a large 
constant. A compiler can help to remove this limitation. If 
the  operating  system  allows  some  freedom  in  using  the 
mmap, memcntl, and sync-instruction-memory,  we do not 
need  to  insert  the  signal-handling  library  to  the  target 
software. Areas  of future research  include the application 
of  the  method  for  maintaining  practical  large  software 
systems,  development  of  methods 
to  support  update 
granularities other than  procedure, and the investigation of 
the effects of compiler optimization. 
References 
[I]  M.  E.  Segal  and  0. Frieder,  "On-The-Fly  Program 
Modification: Systems for Dynamic Updating," IEEE 
Software, Mar.  1993. 
[2]  R.  S.  Fabry,  "How  to  Design  a  System  in  Which 
Modules  Can  Be Changed  on  the Fly," Proc. 2nd Int'l 
Conf  Software Eng., 1976. 
[3]  H.  Goullon,  R. 
Isle,  and  K.  Lohr,  "Dynamic 
Restructuring  in  an  Experimental  Operating  System," 
IEEE Trans. Software Eng., Vol. 4, No. 4, July  1978. 
[4]  B.  Liskov,  "Distributed  Programming 
in  Argus," 
Comm. ACM, Mar.  1988. 
[5]  T.  Bloom,  "Dynamic  Module  Replacement 
Distributed 
Dissertation, MIT Press, Cambridge, Mass.  1983. 
Programming 
System," 
in  A 
Doctoral 
[6]  J.  Magee,  J.  Kramer,  and  M.  Sloman,  "Constructing 
Distributed  Systems  in  Conic,"  IEEE  Trans. Sofmare 
Eng., Vol. 15, No. 6, June  1989. 
[7] J.  Kramer  and  J.  Magee,  "Dynamic  Configuration  for 
Distributed Systems," IEEE Trans. Software Eng., Vol. 
1 1, No. 4, Apr.  1985. 
[8] 0. Frieder and M. E. Segal, "On Dynamically Updating 
a  Computer  Program:  from  Concept  to  Prototype," J. 
System Software, Vol. 14, No.2, Sep. 1991. 
[9]  D.  Gupta  and  P.  Jalote,  "On-Line  Software  Version 
Change  Using  State  Transfer  Between  Processes," 
Sofbvare Practice and Experience, Vol. 23, No. 9, Sep. 
1993. 
[IO] Linkers and Libraries Guide, SUN Microsystems, Inc., 
[ 1 I ]   M. J .  Bach, The Design of the  Unix Operating System, 
Prentice Hall, 1990. 
[ 121  UNIX  Reference  Manuhl,  SUN  Microsystems,  Inc., 
1997. 
1997. 
1997. 
[13] W. R.  Stevens, Advanced  Programming  in the  Unix 
Environment, Addison  Wesley, 1992. 
[ 141  System  Interface  Guide,  SUN  Microsystems,  Inc., 
[15]  R.  P.  Paul,  Sparc  Architecture,  Assembly  Language 
Programming, &C, Prentice Hall,  1994. 
280 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:05:53 UTC from IEEE Xplore.  Restrictions apply.