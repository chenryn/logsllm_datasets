![
](https://images.seebug.org/content/images/2020/05/20aa11ad-b9ff-42fe-8e72-b2172fe48bec.png-w331s)
![
](https://images.seebug.org/content/images/2020/05/1f32b100-cec6-4e7f-8870-594bb257efe9.png-w331s)
此时锁和所有者的关系是这样的：
![
](https://images.seebug.org/content/images/2020/05/a8d7470e-28a7-4d92-966a-b26d9a4fa7ce.png-w331s)
接下来我们通过SetWindowsHookEx给窗口添加了WH_CBT钩子，并让窗口进入消息循环中。
![
](https://images.seebug.org/content/images/2020/05/1f316fbf-0fea-40c2-aa8d-042866c69d36.png-w331s)
SendMessage操作为g_hMenuOwner添加一个临时锁，由于后续的所有攻击都是在message的回调中进行，所以对于g_hMenuOwner来说这个临时锁是无法释放的，如果想要构造一个漏洞利用环境首先需要用一些方法来绕过它。
![
](https://images.seebug.org/content/images/2020/05/d24565f4-5c0d-4d1c-9c2c-3559a7459e4d.png-w331s)
现在的情况变成了下图所示：
![
](https://images.seebug.org/content/images/2020/05/d1d6cad8-d16f-4e06-b283-bba85443d6ff.png-w331s)
当消息为HCBT_CREATEWND时，我们第一次到达xxxMNOpenHierarchy函数内部的xxxCreateWindowEx。
![
](https://images.seebug.org/content/images/2020/05/e3d1b0d7-a3fe-4c87-8eca-a0fe9375fb65.png-w331s)
这里可以通过定义关于HCBT_CREATEWND消息的处理得到执行用户层回调代码的机会，这一步的主要目的是为了获取Menu的Wnd。
当接收到的消息为WM_ENTERIDLE时，我们在窗口的消息回调中通过PostMessage下发消息。
![
](https://images.seebug.org/content/images/2020/05/6ac8d4ef-5fb3-4d30-8400-a9eedc91ef6b.png-w331s)
发送消息后，驱动程序来到了xxxMNKeyDown函数内部调用xxxSendMessage处。
![
](https://images.seebug.org/content/images/2020/05/7caac08c-ce2d-46d7-802c-fbda0680f968.png-w331s)
通过WM_NEXTMENU消息的回调函数开始为LPARAM赋值，赋值操作是为了修改hMenu的Owner，这样就可以将Owner的临时锁绕过。
![
](https://images.seebug.org/content/images/2020/05/c4423eaf-1d24-439f-af4c-d1ee4bb48ec2.png-w331s)
此时内核会接到销毁menu的消息，通过用户层的回调函数返回1阻止menu的销毁。
![
](https://images.seebug.org/content/images/2020/05/9e88173a-2687-4e51-b978-df23edaecb9f.png-w331s)
xxxMNKeyDown函数通过UnlockPopupMenu将g_hMenuOwner身上的永久锁被去掉。
![
](https://images.seebug.org/content/images/2020/05/e2ffe654-8312-4925-a537-ad4a3c5ceee9.png-w331s)
取而代之的是g_hNewOwner加上了一个锁，hMenu的Owner也从g_hMenuOwner变 成了g_hNewOwner。
![
](https://images.seebug.org/content/images/2020/05/42912d5e-0708-43be-b432-04535804bf52.png-w331s)
这时，锁的关系变成了：
![
](https://images.seebug.org/content/images/2020/05/353c3ae4-ac2c-4624-a69e-d0aceff0712e.png-w331s)
接下来程序第二次进入到xxxMNOpenHierarchy函数并通过xxxSendMessage发送了消息。
![
](https://images.seebug.org/content/images/2020/05/d9af677a-f189-4800-b6a9-b9dfbd95901c.png-w331s)
此时通过设置WM_INITMENUPOPUP回调来获得用户层执行的机会，WM_INITMENUPOPUP回调函数通过SetWindowsHookEx函数设置了一个新的hook，目的是为了在xxxMnOpenHierarchy函数创建子窗口的时候获得用户层执行权限。
![
](https://images.seebug.org/content/images/2020/05/7e36ee3c-6a61-4947-8f9e-cd2a50ed5c81.png-w331s)
xxxMnOpenHierarchy函数继续向下执行，再次来到xxxCreateWindowEx处。
xxxCreateWindowEx调用了刚刚设置的回调函数childMenuHookProc。
![
](https://images.seebug.org/content/images/2020/05/632990d7-4b2d-4150-8cd1-2fb8c9ceb09b.png-w331s)
在回调函数childMenuHookProc中，SendMessage发送了WM_NEXTMENU消息，通过该定义该消息的回调函数再次修改参数LPARAM，这是为了去掉g_hNewOwner身上的永久锁。
![
](https://images.seebug.org/content/images/2020/05/003addfd-15f2-4859-a4d6-45af0c549718.png-w331s)
Menu的Owner关系再次被改变，xxxMNKeyDown通过函数UnlockPopMenu去掉g_hNewOwner身上的永久锁。并将这个锁重新加在了g_hMenuOwner上。
![
](https://images.seebug.org/content/images/2020/05/e52f5a37-6572-447c-b108-559b9dfafd65.png-w331s)
![
](https://images.seebug.org/content/images/2020/05/7f10819a-34c8-4b78-a079-c16d15d43fec.png-w331s)
这个时候，所有的锁都已经转移到了g_hMenuOwner身上，而由于WH_CBT钩子已经被移除，menu将被弃用，g_hNewOwner将把新创建的窗口link到自己身上。这个时候情况变成了下面的样子，g_hNewOwner身上已经没有需要绕过的锁了。
![
](https://images.seebug.org/content/images/2020/05/a1716585-5a15-4da1-80fb-b76e96ef3e18.png-w331s)
接着childMenuHookProc通过SetWindowsHookEx函数又一次设置了回调函数并通过SetWindowLongPtr函数来调用它，回调函数销毁了g_hNewOwner和xxxCreateWindowEx生成的新窗口。
![
](https://images.seebug.org/content/images/2020/05/c2fc34e3-a738-4a51-a2c3-62f4a80d534b.png-w331s)
xxxCreateWindowEx返回的值为ffff871b80239130，这就是xxxCreateWindowEx创建的子窗口。
![
](https://images.seebug.org/content/images/2020/05/dda8ef22-e3d3-4517-bd11-b27d7fbb8020.png-w331s)
接下来就可以通过ThreadUnlock来销毁g_hNewOwner和其新创建的子窗口来得到一个UAF漏洞。
![
](https://images.seebug.org/content/images/2020/05/76a42a24-ac66-4dea-8e9a-58960b489322.png-w331s)
### 4 总结
本文对win32k漏洞挖掘新思路进行了详细解读，其中包括将unlock函数和对象的Destroy函数的特性关联在一起，并把对象的子资源作为攻击目标寻找新的攻击面的漏洞挖掘思路。另外，如何通过对象内部的特性去绕过锁对对象的锁定的思路和技巧，也非常具有借鉴意义。
* * *