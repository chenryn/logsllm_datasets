multiple traffic classes and traffic class mixes seen in modern content
caching scenarios. Further, they lack a provable guarantee that the
generated traces have the same caching properties as the original
ones. They also do not support traffic mix scenarios that are common
in content caching, an important requirement since a CDN cache
is shared across multiple diverse traffic classes. Further, prior work
assume a fixed object catalogue which is not true in practice, since
new content is continually generated, and old content fall out of use,
e.g., the news story on the front page of CNN. In particular, as we
show in Section 5.3, the prior work that use the LRUSM algorithm
[5, 40] do not produce traces that have the same caching properties
as the original trace. Finally, the prior work often consider caches
of small size (in MBs) that do not scale to modern caches that are
many magnitudes larger (in TBs).
Roadmap. In Section 2, we describe the Traffic Modeler that cap-
tures the cache properties of the production traces. In Section 3, we
describe the Traffic Mixer that computes a model for a user specified
traffic mix. In Section 4.1, we describe our Trace Generator and
provide formal guarantees for its correctness and in Section 4.2 we
describe our tool that implements the Trace generator and will be
made available for public use. In Section 5, we provide empirical
results and also show that alternate approaches for trace generation
do not perform well. We end with related work in Section 6 and
conclude in Section 7.
2 Traffic modeler
In this section, we describe traffic classes and the footprint de-
scriptor model that is used to capture the caching properties of a
given traffic class. To model the RHR we leverage the tool of Foot-
print Descriptor (FD) from the work in [50] and extend the model
to a byte-weighted Footprint Descriptor (bFD) to capture the BHR.
The output of the traffic modeler is a model of the original produc-
tion trace that is a three-tuple consisting of its FD, bFD, and its
object size distribution. The model is a succinct representation of the
caching characteristics of the voluminous original trace from which
it is derived.
2.1 Traffic classes
The content accessed by users on the Internet is very diverse,
each with a unique set of characteristics. For the purposes of cache
management, the content is usually bucketed into traffic classes.
A traffic class is a type of content from a content provider and is
treated as a unit in the cache provisioning process [51], for example,
media (i.e., videos) from Hulu, software downloads from Microsoft,
images from Amazon, and web pages from CNN. Each traffic class
has a distinct set of characteristics such as its object size distribution,
specific access patterns, and its popularity distribution. Further, each
traffic class may need a different cache size in order to provide a
minimum hit rate guarantee. The request HRCs (rHRC) and byte
HRCs (bHRC) of the traffic classes Download, Media, Web and
Images is depicted in Figure 2a and Figure 2b, respectively. The
rHRC for the image traffic shows that despite providing a large
cache space we cannot obtain a RHR of above 0.6. This may be
attributed to the fact that a significant number of image objects are
accessed only once and the cache incurs a compulsory miss on a
request for these objects. Such an access pattern may arise with a
large product catalog where a significant fraction of products are
unpopular and their images are seldom accessed. Thus, the caching
properties of each traffic class is different from the other. Figure 2c
shows the variability in the object sizes for the various traffic classes.
As expected, objects in the Media traffic class tend to be larger as
compared those in the Web traffic class.
2.2 Footprint descriptors (FD)
A footprint descriptor (FD) is a succinct space-time representa-
tion of a trace from which its rHRC and other caching properties
can be derived. A traffic class can be characterized by collecting
typical original traces of that class from the production system and
computing their FDs. FDs were first proposed in [50] and are now
used in production CDNs to provision traffic classes to servers [51].
Our definition and presentation of FDs closely follows [50]. Let
trace Î  = {ğ‘Ÿ1, . . . , ğ‘Ÿğ‘›}, be a sequence of requests, where each request
ğ‘Ÿğ‘– is a tuple âŸ¨ğ‘¡ğ‘–, ğ‘œğ‘–ğ‘‘, ğ‘§ğ‘–âŸ© of timestamp, object identifier and object size.
Now, let ğœƒ = {ğ‘Ÿğ‘–, . . . , ğ‘Ÿ ğ‘—}, where ğ‘– < ğ‘—, be a request subsequence con-
sisting of consecutive requests in Î . The subsequence ğœƒ is denoted
as a reuse request subsequence if the requests ğ‘Ÿğ‘– and ğ‘Ÿ ğ‘— are made for
the same object that is not requested elsewhere in ğœƒ.
A FD of a trace Î  is a tuple âŸ¨ğœ†, ğ‘ƒğ‘Ÿ (ğ‘ , ğ‘¡), ğ‘ƒğ‘(ğ‘ , ğ‘¡)âŸ© where (i) ğœ† is the
request rate (number of requests per second) of Î  ; (ii) ğ‘ƒğ‘Ÿ (ğ‘ , ğ‘¡) is the
368
IMC â€™21, November 2â€“4, 2021, Virtual Event, USA
Anirudh Sabnis and Ramesh K. Sitaraman
(a)
(b)
(c)
Figure 2: For the different traffic classes in TC trace (Table 2) (a) Variability in request HRCs; (b) Variability in the byte HRCs; (c) Variability in
object size distribution (SZ)
reuse-subsequence descriptor function that captures the probability
that a reuse request subsequence ğœƒ of Î  contains ğ‘  unique bytes and
is of duration ğ‘¡ seconds. (iii) ğ‘ƒğ‘(ğ‘ , ğ‘¡) is the all-sequence descriptor
function that captures the probability that any request subsequence
ğœƒ of Î  contains ğ‘  unique bytes and is of duration ğ‘¡ seconds. Note
that ğ‘ƒğ‘Ÿ (ğ‘ , ğ‘¡) considers only the reuse subsequences, whereas ğ‘ƒğ‘(ğ‘ , ğ‘¡)
considers all possible subsequences of Î . The number of unique
bytes ğ‘  in ğœƒ is the sum of the sizes of the unique objects in ğœƒ, and the
duration ğ‘¡ is the difference in the timestamp (ğ‘¡ ğ‘—âˆ’ğ‘¡ğ‘–) of the last request
ğ‘Ÿ ğ‘— and the first request ğ‘Ÿğ‘–. Note that the request sequence ğœƒ that starts
at the beginning of the trace and ends in the first request for an object
is considered a reuse subsequence with infinite unique bytes and
infinite duration. The number of unique bytes in a reuse request
subsequence is also known as stack distance [41]. The following
theorem is from [50].
THEOREM 1. Let rHRC(s) be the request hit rate of trace Î  for
an LRU cache of size ğ‘ . The rHRC(s) is computed from the FD of Î 
as follows.
ğ‘Ÿğ»ğ‘…ğ¶(ğ‘ ) =
ğ‘ƒğ‘Ÿ (ğ‘ â€², ğ‘¡).


ğ‘¡
ğ‘ â€²â‰¤ğ‘ 
Observe that the expression in RHS sums the reuse sequence
distribution function (ğ‘ƒğ‘Ÿ (ğ‘ â€², ğ‘¡)) across all possible time durations.
In essence, the RHS captures the probability that a reuse request
subsequence, ğœƒ = {ğ‘Ÿğ‘–, . . . , ğ‘Ÿ ğ‘—}, contains at most ğ‘  unique bytes, thus
incurring a cache hit on the request ğ‘Ÿ ğ‘— . Note that if ğœƒ contained more
than ğ‘  bytes, the LRU policy would have evicted the object requested
by ğ‘Ÿğ‘– when the request ğ‘Ÿ ğ‘— is made, resulting in a miss.
FD calculus. A key property of FDs is that there is an efficient
calculus to evaluate the cache properties of any traffic class mix. For
instance, given footprint descriptors of two traces Î 1 and Î 2, the
calculus can be used to compute the FD of the traffic mix of Î 1 and
Î 2 obtained by interleaving the two traces by their timestamps. The
computation of the FD of the traffic mix uses convolution and can
be computed quickly using a Fast Fourier Transform [50]. When
synthetic traces are generated for a traffic mix, TRAGEN uses the
FD calculus to compute the FD of traffic class mix and then uses
this FD to generate a synthetic trace for the mix.
2.3 Byte-weighted footprint descriptor (bFD)
RHR can be derived from FD as shown in Theorem 1, but the
BHR cannot be derived from it. However, we know from practice
that the RHR and BHR can be significantly different. Consider the
following scenario. Let the smaller objects in a trace exhibit higher
temporal locality as compared to the large objects, thus incurring
more cache hits as compared to the larger objects. We can then expect
the BHR of the trace to be smaller than the RHR. In fact, we observe
a similar difference in the rHRC and bHRC of the VIDEO trace
(Table 1) in Figure 3. Thus, to capture the BHR properties of a trace,
we define a new type of footprint descriptor called Byte-weighted
Footprint Descriptor (bFD).
A bFD operates on a byte sequence as opposed to a request
sequence. Let Î ğµ = {ğ‘11, . . . , ğ‘1ğ‘§1, . . . , ğ‘ğ‘›1, . . . , ğ‘ğ‘›ğ‘§ğ‘›} be the byte
sequence that is obtained from a request trace Î  = {ğ‘Ÿ1, . . . , ğ‘Ÿğ‘›} by
replacing each request ğ‘Ÿğ‘– by the sequence of bytes ğ‘ğ‘–1, . . . , ğ‘ğ‘–ğ‘§ğ‘– in
its requested object, where byte ğ‘ğ‘– ğ‘— corresponds to the ğ‘—ğ‘¡â„ byte of
request ğ‘Ÿğ‘– âˆˆ Î  and ğ‘§ğ‘– is the size of the requested object. Now, let
ğ›½ = {ğ‘ğ‘– ğ‘— , . . . , ğ‘ğ‘˜ğ‘™}, where ğ‘– < ğ‘˜, correspond to a byte subsequence
in Î ğµ. The byte subsequence ğ›½ is called a reuse byte subsequence if
the first byte (ğ‘ğ‘– ğ‘— ) and the last byte (ğ‘ğ‘˜ğ‘™ ) in ğ›½ correspond to the same
byte that does not occur elsewhere in ğ›½.
A bFD is a tuple âŸ¨ğœ†, ğ‘ƒğ‘Ÿğ‘(ğ‘ , ğ‘¡), ğ‘ƒğ‘Ÿğ‘(ğ‘ , ğ‘¡)âŸ© where (i) ğœ† is the traffic
rate i.e., the number of bytes requested per second. (ii) ğ‘ƒğ‘Ÿğ‘(ğ‘ , ğ‘¡) is
the reuse byte subsequence descriptor function that captures the joint
probability that a reuse byte subsequence consists of ğ‘  unique bytes
and is for a duration ğ‘¡ seconds, and, (iii) ğ‘ƒğ‘Ÿğ‘(ğ‘ , ğ‘¡) is the all byte
subsequence descriptor function that captures the joint probability
that a byte subsequence consists of ğ‘  unique bytes and is for a
duration ğ‘¡ seconds.
The computation of ğ‘ƒğ‘Ÿğ‘(ğ‘ , ğ‘¡) is done as follows. We maintain a
counter ğ¶(ğ‘ , ğ‘¡) that counts the number of reuse byte subsequences
Figure 3: The rHRC and bHRC for the VIDEO trace
369
0.00.51.01.5Cache size (TB)0.00.20.40.60.81.0Request hit rate (RHR)DownloadImageMediaWeb0.00.51.01.5Cache size (TB)0.00.20.40.60.81.0Byte hit rate (BHR)DownloadImageMediaWeb101103105Object size (Bytes)0.00.20.40.60.81.0CDFDownloadImageMediaWeb0.02.55.07.510.0Cache size (TB)0.00.20.40.60.81.0Hit rate RHRBHRTRAGEN: A Synthetic Trace Generator for Realistic Cache Simulations
IMC â€™21, November 2â€“4, 2021, Virtual Event, USA
that contain ğ‘  unique bytes and is of duration ğ‘¡ seconds. We can ob-
tain ğ¶(ğ‘ , ğ‘¡) by enumerating all reuse byte subsequences ğœƒ of Î  and
incrementing the appropriate counters. To understand the computa-
tion of ğ¶(ğ‘ , ğ‘¡), consider a reuse byte subsequence ğ›½ = {ğ‘ğ‘–1, . . . , ğ‘ ğ‘—1}
that corresponds to a reuse request subsequence ğœƒ = {ğ‘Ÿğ‘–, . . . , ğ‘Ÿ ğ‘—}. If
the number of unique bytes in ğœƒ is ğ‘ , and the duration of ğœƒ is ğ‘¡, then
counter ğ¶(ğ‘ , ğ‘¡) is incremented ğ‘§ğ‘– times, where ğ‘§ğ‘– is the size of request
ğ‘Ÿğ‘–. Thus, the computation accounts for all the bytes of request ğ‘Ÿğ‘–, i.e.,
all reuse byte sequences of the form ğ›½ = {ğ‘ğ‘–ğ‘˜, . . . , ğ‘ ğ‘—ğ‘˜}, 1 â‰¤ ğ‘˜ â‰¤ ğ‘§ğ‘–.
By updating counter ğ¶(ğ‘ , ğ‘¡) for all possible reuse sequences ğœƒ of Î 
we obtain ğ‘ƒğ‘Ÿğ‘(ğ‘ , ğ‘¡) = ğ¶(ğ‘ ,ğ‘¡)
|Î ğµ | , where |Î ğµ| is the total number of bytes
in Î ğµ.
The following theorem applies to LRU whose variants are widely
used in many production systems like Akamai [38].
THEOREM 2. Let bHRC(s) be the byte hit rate of trace Î  for an
LRU cache of size ğ‘ . The bHRC(s) is computed from the bFD of Î 
as follows.


ğ‘¡
ğ‘ â€²â‰¤ğ‘ 
ğ‘ğ»ğ‘…ğ¶(ğ‘ ) =
ğ‘ƒğ‘Ÿğ‘(ğ‘ â€², ğ‘¡).
PROOF. Our proof is similar to the proof of Theorem 1 in [50].
Consider a byte reuse sequence ğ›½ = {ğ‘ğ‘– ğ‘— , . . . , ğ‘ğ‘˜ğ‘™}, where ğ‘ğ‘– ğ‘— and
ğ‘ğ‘˜ğ‘™ are requests for the same byte. For a cache size ğ‘  running
LRU, the request for the byte ğ‘ğ‘˜ğ‘™ is a hit if and only if the num-
ber of unique bytes accessed in ğ›½ is less than the cache size ğ‘ .
The probability of the occurrence is obtained by the expression
â–¡
ğ‘ğ»ğ‘…ğ¶(ğ‘ ) =ğ‘¡ğ‘ â€²â‰¤ğ‘  ğ‘ƒğ‘Ÿğ‘(ğ‘ â€², ğ‘¡).
Time complexity. Using efficient data structures and stack based
algorithms FD and bFD can be computed in O(ğ‘ log ğ‘š), where ğ‘
is the length of the trace and ğ‘š is the number of unique objects in
the trace [3].
3 Traffic mixer
We describe the component that computes the model of a user-
specified traffic mix from the models of the individual traffic classes.
A traffic mix is specified as a list of traffic classes Î“ = {ğœ1, . . . , ğœğ‘›}
and a weight vector W = {ğ‘¤1, . . . , ğ‘¤ğ‘›} that describes the traffic
contribution of each traffic class. The traffic contribution can be
specified using the required request-rate (requests/second) or the
required byte-rate (GBps) for each traffic class. The traffic mixer
uses the footprint descriptor calculus [50] to compute the ğ¹ ğ·ğ‘šğ‘–ğ‘¥
(resp. ğ‘ğ¹ ğ·ğ‘šğ‘–ğ‘¥ ), i.e., FD (resp., bFD) of the traffic mix. Further, the
traffic mixer also computes the object size distribution of the traffic
mix.
3.1 Footprint descriptor calculus
2(ğ‘ , ğ‘¡), ğ‘ƒğ‘
We will now describe the FD calculus that is described in [50] and
show that it extends to bFD as well. Consider two traces Î 1 and Î 2
and their respective footprint descriptors ğ¹ ğ·1 = âŸ¨ğœ†1, ğ‘ƒğ‘Ÿ
1 (ğ‘ , ğ‘¡)âŸ©
and ğ¹ ğ·2 = âŸ¨ğœ†2, ğ‘ƒğ‘Ÿ
2 (ğ‘ , ğ‘¡)âŸ©. Let Î  be the trace that is formed
by interleaving Î 1 and Î 2 by time. A key observation that facili-
tates the calculus is that for a subsequence ğœƒ of Î , of duration ğ‘¡ and
unique bytes ğ‘ , some ğ‘ 1 bytes could be from Î 1 and the rest ğ‘  âˆ’ ğ‘ 1
bytes from Î 2, assuming Î 1 and Î 2 contain disjoint objects (The
disjoint object assumption holds in many common situations, includ-
ing when Î 1 and Î 2 are different traffic classes). Thus, to compute a
1(ğ‘ , ğ‘¡), ğ‘ƒğ‘
descriptor function ğ‘ƒ(ğ‘ |ğ‘¡) for Î  from the descriptor functions ğ‘ƒ1(ğ‘ |ğ‘¡)
and ğ‘ƒ2(ğ‘ |ğ‘¡) for Î 1 and Î 2 respectively, the convolution operator is
used to enumerate and add the probabilities of all possible ways of
obtaining ğ‘ 1 unique bytes from Î 1 and the remaining ğ‘  âˆ’ ğ‘ 1 unique
bytes from Î 2. Thus,
ğ‘ƒ(ğ‘ |ğ‘¡) = ğ‘ƒ1(ğ‘ |ğ‘¡) âˆ— ğ‘ƒ2(ğ‘ |ğ‘¡)
ğ‘†âˆ’ğ‘ 1
ğ‘ 1=0
=
ğ‘ƒ1(ğ‘ 1|ğ‘¡)ğ‘ƒ2(ğ‘† âˆ’ ğ‘ 1|ğ‘¡),
where * is the convolution operator. We can see that the same ar-
gument follows for the byte sequence Î ğµ and hence the footprint
descriptor calculus that works for a FD also works for a bFD. We
will briefly describe the basic operations in the calculus using byte
sequences.
1 and Î ğµ
(i) Addition. Given two byte sequences Î ğµ
2 and their
bFDs, ğ‘ğ¹ ğ·1 and ğ‘ğ¹ ğ·2, if Î ğµ represents a sequence with Î ğµ
1 and
Î ğµ
2 interleaved by time, then the addition operator provides the byte
footprint descriptor ğ‘ğ¹ ğ·ğ‘šğ‘–ğ‘¥ of the interleaved sequence Î ğµ. By
using the Fourier transform to evaluate the convolution operator, the
addition operator runs in ğ‘‚(ğ‘‡ ğ‘† log ğ‘†) time, where T and S are the
number of time and stack distance buckets in ğ‘ƒğ‘Ÿğ‘(ğ‘ , ğ‘¡).
(ii) Subtraction. Given a byte sequence Î ğµ and its corresponding