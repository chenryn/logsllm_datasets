guest to sPA.
To exchange data between the hypervisor and the guest VMs, a
data structure dubbed the virtual machine control block (VMCB)
is located on a shared memory page. VMCB stores the guest VM’s
register values and some control bits during VMEXIT. The VMCB
is under the control of the hypervisor to configure the behaviors of
the guest VM.
Secure Encrypted Virtualization (SEV). SEV combines AMD-
V architecture with SME to allow individual VMs to have their
own VM Encryption Key (VEK) [2]. Each VEK is generated by
the processor and assigned to an SEV VM when launched by the
hypervisor. All VEKs are stored in the AMD-SP and are never
exposed to DRAM during their entire life cycle. SEV distinguishes
different VEKs using ASIDs. When a memory request is made, the
AMD-SP determines which key to be used with the current ASID,
achieving page-granular memory encryption with different keys.
3 DEMYSTIFYING ASID-BASED ISOLATION
ASID was initially designed by AMD to tag TLB entries so that
unnecessary TLB flushes can be avoided when switching between
guest VMs and the host. SEV reuses ASID as the indices of VEKs
stored in AMD-SP. Cache tags are also extended accordingly to iso-
late cache lines with different ASIDs. As a result, ASID becomes the
de-facto identifier used by SEV processors to control the software’s
accesses to virtual memory, caches, and TLBs (Figure 1).
Figure 1: ASID-based memory isolation in SEV.
this capability to breach ASID-based isolation. Interestingly, AMD
adopts a “security-by-crash” principle and assumes if “the wrong
ASID is used for a guest”, the execution of the instruction will “likely
cause a fault” [14]. In this section, we set off to understand and
demystify how ASIDs are used to isolate memory, cache, and TLBs
in SEV, and how ASIDs are managed by the hypervisor.
3.1 ASID-based Isolation
3.1.1 ASID-based Memory Isolation ASIDs are used by the
AMD-SP to index VEKs of SEV VMs. The SEV hardware ensures the
data and code of an SEV VM is encrypted in the DRAM and only
decrypted when loaded into the SOC. Specifically, each memory
read from an SEV VM consists of memory fetches by the memory
controller of a 128-bit aligned memory block, followed by an AES
decryption by AMD-SP using the VEK corresponding to the current
ASID. The current ASID is an integer stored in a hidden register
of the current CPU core, which cannot be accessed by software in
the guest VM.
SEV allows the guest OS to decide, by setting or clearing the C-bit
of the PTE, whether each virtual memory page is (treated as) private
(encrypted with the guest’s VEK) or shared (either encrypted with
the host’s VEK or unencrypted). For instance, when the C-bit of
a page is set, memory reads from this virtual-physical mapping is
considered encrypted with the guest VM’s VEK, regardless of its
true encryption state, and thus a memory read in that page will be
decrypted using the VEK of the current ASID. By default, the guest
VM sets the guest C-bits for private pages during the boot period.
However, the hypervisor is able to manipulate the nested C-bit
(nC-bit) in nPT. When the gC-bit (the C-bit of the gPT) conflicts
with the nC-bit, AMD-SP encrypts the memory pages according
to the following rules: When gC-bit=0 and nC-bit=1, the page is
encrypted with the hypervisor’s VEK; when gC-bit=1, regardless of
the nC-bit, the page is encrypted with the guest VM’s VEK; when
gC-bit=0 and nC-bit=0, the page is not encrypted. Following SME,
the code pages are always considered private to the guest VM and
thus is always encrypted regardless of the guest C-bits. Similarly,
the gPT is also always encrypted with the guest’s VEK.
3.1.2 ASID-based TLB Isolation ASID was originally intro-
duced to avoid TLB flushes when the execution context switches
between the guest VM and the hypervisor, which is achieved by
extending each TLB tag with ASID. With the ASID capability, when
observing activities like MOV-to-CR3, context switches, updates of
CR0.PG/CR4.PGE/CR4.PAE/CR4.PSE, the hardware does not need
HostASIDCacheAMDSPTLBAMDSOCKeyassignmentTLBtagCachetagEncryptedDRAMVEKs[ASID]DECENCASIDmanagementAssignSession 11A: Attestation and Firmware Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2939to flush the entire TLB, but only the TLB entries tagged with the cur-
rent ASID [4]. However, to properly isolate TLB, the management
of ASIDs for non-SEV VMs and SEV VMs is slightly different.
Non-SEV VMs. Each VCPU of a non-SEV VM may have different
ASIDs, which can be assigned dynamically before each VMRUN.
More specifically, before the hypervisor is about to resume a VCPU
with VMRUN, it checks if the VCPU was the one running on this
CPU core before the control was trapped into the hypervisor. If so,
the hypervisor keeps the ASID of the VCPU unchanged and resumes
the VCPU directly; if not, the hypervisor selects another ASID
(from the ASID pool) and assign it to the VCPU. In the former case,
TLB entries can be reused by the VCPU as its ASID is unchanged.
However, in the latter case, the residual TLB entries (tagged with
ASID of the hypervisor or the previous VCPU) should not be reused.
SEV VMs. SEV processors rely on a similar strategy to isolate
entries in the TLBs with ASID. However, instead of dynamically
assigning an ASID to a VCPU before VMRUN, all VCPUs of the
same SEV VM are assigned the same ASID at launch time, which
remains the same during the entire life cycle of the SEV VM.
3.1.3 ASID-based Cache Isolation On platforms that support
SEV, cache lines are tagged with the VM’s ASID indicating to which
VM this data belongs, thus preventing the data from being misused
by entities other than its owner [14]. When data is loaded into
cache lines, according to the current ASID, AMD-SP automatically
decrypts the data with the corresponding VEK and stores the ASID
value into the cache tag. When a cache line is flushed or evicted,
AMD-SP uses the ASID in the cache tag to determine which VEK
to use when encrypting this cache line before writing it back to
DRAM. The cache tag is also extended to include the C-bit [14].
Because the cache is now tagged with ASID and C-bit, cache co-
herence of the same physical address is not maintained if the two
virtual memory pages do not have the same ASID and C-bit.
3.2 ASID Management
3.2.1 ASID Life Cycle The hypervisor reserves a pool (i.e., a
range of integers) of available ASIDs for all VMs (we call all-ASID
pool for simplicity), and a separate pool of ASIDs for SEV VMs
(SEV-ASID pool). The maximum ID number of the all-ASID pool
is determined by CPUID 0x8000000a[EBX] (e.g., 32768, thus the
available ASIDs are whole numbers between 1 and 32767). The
maximum ID number of the SEV-ASID pool is determined by CPUID
0x8000001f[ECX] (e.g., 15, which suggests the legal ASIDs for SEV
VMs are 1 to 15). Note that ASID 0 is reserved for the host OS (i.e.,
hypervisor), and is also not allowed to be assigned to a VCPU for
processors with or without SEV extensions [4].
On SEV platforms, the hypervisor uses ACTIVATE command to
inform AMD-SP that a given guest is bound with an ASID and
uses DEACTIVATE command to de-allocate an ASID from the guest.
DEACTIVATE also uninstalls the guest VM’s VEK. After a successful
DEACTIVATE, if there is no available ASID in the SEV-ASID pool,
the hypervisor may re-allocate the ASID to another VM [2].
At runtime, when the processor runs under the guest mode, the
guest VM’s ASID is stored in the ASID register that is hidden from
software; when the processor runs under the host mode, the register
is set to 0, which is the hypervisor’s ASID. The guest VM’s ASID is
stored at the VMCB during VMEXIT. After VMRUN the processor
restores the ASID in the VMCB. The VMCB State Cache allows the
processor to cache some guest register values between VMEXIT
and VMRUN for performance enhancement. The physical address
of the VMCB is used to perform access control of the VMCB State
Cache. However, the VMCB clean field controlled by the hypervisor
can be used to force the processor to discard selected cached values.
For example, bit-2 of the VMCB clean field indicates that an ASID
reload is needed; bit-4 of the clean field indicates fields related to
nest pages are dirty and needed to be reloaded from the VMCB.
Some VMCB fields are strictly not cached and the corresponding
register values will be reloaded from the VMCB every time. For
example, offset 058h of the VMCB is a TLB control field to indicate
whether the hardware needs to flush TLB after VMRUN; this field
is always uncached.
3.2.2 ASID Restrictions SEV implements both launch-time and
run-time restrictions about ASID.
Launch-time restrictions. On processors supporting SEV, the hy-
pervisor cannot bind a current active ASID in the SEV-ASID pool
to an SEV VM during launch time [2]. However, an adversary is
able to deactivate the victim SEV VM and then activate an attacker
SEV VM with the same ASID. The hardware requires the hyper-
visor to execute a WBINVD instruction and a DF_FLUSH instruction
after deactivating an ASID and before re-activating it. The WBINVD
flushes all modified cache lines and invalidates all cache lines. The
DF_FLUSH instruction flushes data fabric write buffers of all CPU
cores. If these instructions are not executed before associating the
ASID with a new VM, a WBINVD_REQUIRED or DFFLUSH_REQUIRED
error will be returned by the AMD-SP and the VM launch process
will be terminated.
This restriction is critical to the isolation of cache lines. Other-
wise, victim VM’s residual cache data can be read by subsequent
attacker VM. In particular, the attacker VM can use the WBINVD
instruction to flush the cache data to memory. Cache lines belong-
ing to victim VM will thus be encrypted with the attacker VM’s
VEK and then flushed into the memory. Subsequent reads to those
memory data will return plaintext and thus allow the adversary to
extract the data.
Run-time restrictions. After a VM is launched, the hypervisor
can change its ASID during VMEXITs, by changing the ASID field of
its VMCB, which will take effect when the VM is resumed. There is
no additional hardware restriction at runtime. As such, it is possible
to have two SEV VMs with the same ASID on the same machine,
though the one with an incorrect ASID will crash very soon.
Moreover, the VMCB also contains a field (090h) to indicate if the
VM is an SEV VM or a non-SEV VM. Therefore, it is possible to first
launch an SEV VM and a non-SEV VM with the same ASID, and
then, during VMEXITs of the non-SEV VM, change the non-SEV
VM into an SEV VM by setting the corresponding bit in the VMCB.
We have experimentally confirmed this possibility on our testbed
(as shown in Section 6.4). It suggests that the hardware trusts the
values of VMCB to determine (1) if the VM to be resumed is an
SEV VM and (2) what ASID is associated with it. The hardware
does not store this information to a secure memory region and
use it for validation. The only additional validation performed by
Session 11A: Attestation and Firmware Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2940the AMD-SP is that the ASIDs of SEV VMs must fall into the valid
ranges2. Therefore, while a VM was launched as a non-SEV VM,
we can effectively (though momentarily) make it an SEV VM with
the same ASID as another SEV VM.
3.2.3 “Security-by-Crash” As the hypervisor has the liberty of
changing the ASIDs of both SEV VMs and non-SEV VMs, security
concerns arise when the hypervisor is not considered a trusted
party. However, AMD believes that when an SEV VM is resumed
with an ASID different from its own, its subsequent execution will
lead to unpredictable results and eventually crash the VM [14].
Specifically, to change the ASID of a VM (either an SEV or non-
SEV VM), the hypervisor can directly edit the ASID field of the
VMCB, set the VMCB clean-field to inform the hardware to bypass
the VMCB State Cache, and then resume the VM with VMRUN.
After the VM is resumed, if the RFLAGS.IF bit in the VMCB is
set, the virtual address specified by the interrupt descriptor-table
register (IDTR) will be accessed, because the guest OS will try to
handle interrupts immediately; if the RFLAGS.IF bit is cleared, the
instruction pointed to by nRIP—the next sequential instruction
pointer—is going to be fetched and executed. However, in either
case, the virtual address translation will cause problems.
First, any TLB entries remaining due to its previous execution
becomes invalid because its ASID has been changed; the ASID tag
in the TLB entries would not match. Second, a page table walk is
unlikely to succeed, as its own page tables are encrypted using the
VEK indexed by its own ASID. As a result, the top-level page table
will be decrypted into meaningless bit strings. References to a page
table entry of this page will trigger an exception to be handled by
the guest OS. Finally, a handler of the guest OS is to be invoked to
handle the exception. However, any reference of this handler will
be decrypted using an incorrect VEK, leading to a triple fault that
eventually crashes the VM.
3.3 Summary
We highlight a few key points of SEV’s “security-by-crash” based
memory isolation mechanisms.
• ASID is used for access control. ASID is the only identifier
used for controlling accesses to virtual memory, caches, and TLBs.
Once a VM is successfully resumed from VMEXIT, the CPU and
AMD-SP only rely on the ASID (loaded from its VMCB) to validate
memory requests.
• ASID is managed by the hypervisor. The hypervisor may as-
sign any ASID (including the ASID of another active SEV VM)
to an SEV or non-SEV VM during VMEXIT. The only restriction
enforced by the hardware is that the ASID must fall into the range
in accordance with the VM’s SEV type.
• Security is achieved by VM crash. The security of the mech-
anism relies solely on the faults triggered during the execution
of the VM if its ASID has been changed. The faults can be caused
by memory decryption with an incorrect VEK during instruction
fetches or page table walks.
2The lower portion of the valid ASID range of SEV VMs are reserved for SEV-ES VMs.
CPUID Fn8000_001F[ECX] specifies valid SEV ASIDs and CPUID Fn8000_001F[EDX]
specifies the minimum ASID values used for SEV (but non-SEV-ES) VMs.
• Cache/TLB entries are flushed by the hypervisor. The hy-
pervisor controls whether and when to flush TLB and cache entries
associated with a specific ASID. Only limited constraints are en-
forced by the hardware during ASID activation. Misuse of these
resources is possible.
4 CROSSLINE ATTACKS
The goal of our CrossLine attacks is to extract the memory content
of the victim VM that is encrypted with the victim VM’s VEK. We
make no assumption of the adversary’s knowledge of the victim VM,
including its kernel version, the applications running in it, etc. The
common steps of the CrossLine attacks are the following: (1) the
adversary who controls the hypervisor launches a carefully crafted
attacker VM; (2) the hypervisor alters the ASID of the attacker
VM to be the same as that of the victim VM during VMEXITs; (3)
the hypervisor prepares a desired execution environment for the
attacker VM by altering its VMCB and/or its nPT; (4) the attacker
VM resumes after VMRUN, allowing a momentary execution before
it crashes. During the momentary execution, memory accesses from
the attacker VM will trigger memory decryption using the victim
VM’s VEK.
Although the attacker VM crashes shortly—due to the ASID-
based isolation in TLB, caches, and memory—we show that this mo-