 **Stefan Gybas** opened **SPR-8434** and commented
We are migrating a project from Java 5 to Java 6 and noticed that one
integration test was failing because a dependency was not injected any longer.
The problem can be reproduced with a simple scenario: We have a package-
visible base class for some services with an autowired dependency and a public
getter and setter:
    abstract class AbstractService {
        private Dependency dependency;
        public Dependency getDependency() {
            return dependency;
        }
        @Autowired
        public void setDependency(Dependency dependency) {
            this.dependency = dependency;
        }
    }
Then he have a public sub class that gets component-scanned:
    @Component
    public class Service extends AbstractService {
    }
Our test basically looks like this:
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(locations = { "/applicationContext.xml" })
    public class DependencyInjectionTest {
        @Autowired
        private Service underTest;
        @Test
        public void testDependencyInjected() {
            // this test passes when Service.java was compiled with Java 5
            // but fails when compiled with Java 6
            assertNotNull(underTest.getDependency());
        }
    }
with a very simple application context that just enables annotation-config and
does a package scan (see the attachment for a complete Maven/Eclipse project).
When we compile the project with Java 5 the test passes when run with Java 5
or Java 6. But when we compile the project with Java 6 ("-source 1.5 -target
1.5") the test fails both under Java 5 and Java 6.
After investigating the byte code in Service.class we noticed that two bridge
methods are generated by the Java 6 compiler. These methods are not generated
by the Java 5 compiler:
    public com.example.Dependency com.example.Service.getDependency() (bridge: true)
    public void com.example.Service.setDependency(com.example.Dependency) (bridge: true)
AutowiredAnnotationBeanPostProcessor.buildAutowiringMetadata(Class clazz) uses
ClassUtils.getMostSpecificMethod() in line 346 (current SVN) to determine if
the method is defined in the class that is investigated (AbstractService in
the example). The most specific method is the bridge method in Service.class
when compiled with Java 6 but this method does not have the `@Autowired`
annotation so the setter is never called.
A fix would be to replace ClassUtils.getMostSpecificMethod() with
AopUtils.getMostSpecificMethod() to get the same results on Java 5 and Java 6.
But this would cause a circular dependency between spring-aop and spring-beans
and is probably not a high-performance solution.
We will change the visibility of AbstractService to public in our project to
work around the problem. But I suggest to change Spring to deliver the same
results on Java 5 and Java 6.
* * *
**Affects:** 3.0.5, 3.1 M2
**Attachments:**
  * DependencyTest.zip ( _6.13 kB_ )
**Issue Links:**
  * #12555 Annotation based injection into non public base classes does not work ( _ **"duplicates"**_ )