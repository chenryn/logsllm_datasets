title:No Loitering: Exploiting Lingering Vulnerabilities in Default COM
Objects
author:David Dewey and
Patrick Traynor
No Loitering: Exploiting Lingering Vulnerabilities in Default COM Objects
David Dewey†‡
PI:EMAIL
Patrick Traynor‡
PI:EMAIL
†Advanced Technology Group
IBM Security
‡Converging Infrastructure Security (CISEC) Lab
Georgia Institute of Technology
Abstract
The Component Object Model (COM) facilitates the
creation of software plugins for applications running in
Microsoft Windows. ActiveX is a common instantiation
of this infrastructure, and uses COM to create plugins
for Internet Explorer. As vulnerabilities in COM ob-
jects included in the installation of Windows have been
found, Microsoft has responded by blacklisting their use
by speciﬁc applications. In this paper, we demonstrate
that the defense mechanisms protecting vulnerable COM
objects can be easily circumvented. Speciﬁcally, our at-
tack exploits systemic transitive trust among COM ob-
jects and allows for the instantiation and exploitation
of any of several hundred known ﬂawed controls. After
demonstrating this weakness on fully patched Windows
XP, Windows Vista and Windows 7 machines, we design
and implement a system-wide enforcement architecture
called COMBlocker, which checks the instantiation of
COM objects against a global policy. We then show that
COMBlocker is an effective mitigation for such attacks
while imposing minimal overhead (approximately 0.5ms
per policy check). In so doing, our techniques make the
exploitation of default COM objects signiﬁcantly more
difﬁcult.
1
Introduction
The Component Object Model (COM) is a language-
neutral design philosophy allowing for the creation of
discrete software components that can be integrated into
other applications. Every COM object exposes a stan-
dard interface, allowing developers to create extensible
applications that provide a well-deﬁned plugin architec-
ture. Others developers can leverage these standard in-
terfaces to create COM objects that can themselves be
consumed by additional applications, allowing for more
creative and enhanced solutions to user demands. Ac-
tiveX extends this architecture to browsers and allows
for such extensible design to be expanded to web-based
applications. Through ActiveX, a web developer can
force the execution of native code in the context of the
browser through the COM-based plugin infrastructure in
Internet Explorer.
Such extensible functionality has frequently been tar-
geted for malicious purposes [19, 20, 22–24]. To aid in
securing ActiveX, a conﬁguration policy known as the
“killbit” list was added to Internet Explorer. This allows
users and vendors to manage a list of controls that should
never be loaded by this particular browser. In the event
that a vulnerability is discovered in a control, the kill-
bit list can be used to prevent its instantiation in IE. By
adding vulnerable controls to this list, a popular attack
vector used by hackers can be mitigated. The killbit list
also serves as the basis for other security policies in a
small number of additional applications. For instance,
Microsoft Ofﬁce applications will prompt the user if a
document has a COM object embedded in it that is listed
in the killbit list.
In this paper, we demonstrate that this mitigation
mechanism is insufﬁcient to protect systems against the
exploitation of vulnerable COM objects. Speciﬁcally,
implementing and enforcing security policies through
the killbit list on a per-application basis is an inadequate
means of mitigating attacks against vulnerable COM ob-
jects that are part of the default operating system instal-
lation. We show that individual applications do not have
a broad enough view into the behavior of the COM ob-
jects they load to effectively enforce a security policy.
In this paper, we make the following contributions:
• Discover and characterize a systemic weakness
in the COM security infrastructure: We demon-
strate that the existing killbit list security poli-
cies governing the instantiation of COM objects
can easily be circumvented. We show that due to
a weakness in the underlying COM architecture,
many COM objects that are part of the default in-
stallation of the operating system can load other ob-
jects without ever consulting a policy of any kind.
We demonstrate that this attack is possible through
virtually every application that is commonly in-
stalled on Windows.
• Conﬁrm the ability to exploit several hundred
known ﬂawed and vulnerable COM objects in-
stalled by default in Windows: Over the past sev-
eral years, the common response to security vulner-
abilities reported in COM objects has been to use
existing policy mechanisms to prevent their instan-
tiation in a few discrete applications. Because the
COM objects themselves are often not corrected,
our circumvention identiﬁes a signiﬁcant security
risk. It is important to note that the attack described
in this paper takes advantage of controls that are al-
ready installed on Windows and does not require
the victim to install or load a control created by the
adversary.
• Design and implement a prototype policy en-
forcement infrastructure for COM objects: We
design and implement a prototype infrastructure for
the system-wide COM instantiation policy enforce-
ment, which we call COMBlocker. In this system,
we are able to quickly compare (average lookup
time of 554µs) the instantiation of COM objects
against a global policy. Our approach is effective as
it uses binary rewriting to force all COM object in-
stantiations to be compared against the global pol-
icy, thus mitigating the above attack. We then com-
pare our proposed solution to the patch recently is-
sued by Microsoft (Security Bulletin MS10-036),
which was created in response to our private dis-
closure of the vulnerability.
Through the security weakness documented in this
paper, we demonstrate that Windows is susceptible to
attack against several hundred known ﬂawed controls,
which are already resident on the system. Many of the
vulnerabilities that are left “loitering” on Windows due
to unpatched COM objects, when exploited, allow ad-
versaries to execute arbitrary code. These vulnerabili-
ties can potentially be exploited to install malware. In
demonstrating the weaknesses of the existing security
mechanisms associated with COM, we show that adver-
saries have a large number of existing vulnerabilities to
target that can provide them with complete control of a
system.
The remainder of this paper is organized as follows:
Section 2 discusses important related research efforts;
Section 3 provides background information related to
COM objects and their extensibility; Section 4 illustrates
the process by which the killbit list can be bypassed,
thereby reenabling the ability to exploit hundreds of pre-
viously documented vulnerabilities; Section 5 describes
our mitigation architecture, which creates a centralized
point for COM object policy enforcement; Section 6 of-
fers experimental results and discussion; Section 7 pro-
vides concluding remarks.
2 Related Work
ActiveX has garnered signiﬁcant attention from secu-
rity experts over the past several years. Attacks against
these controls range in severity from downloading ﬁles
to an adversary-supplied location to arbitrary code ex-
ecution [19, 20, 22–24]. As a variety of vulnerabilities
have been found in COM objects included with the de-
fault installation of their operating systems, Microsoft
has generally prevented the exploitation of the objects
by adding them to the killbit list. Dowd, Smith, and
Dewey demonstrated that it was possible to bypass the
killbit settings in Internet Explorer using a vulnerabil-
ity for ActiveX controls [4]. However, while this weak-
ness was patched for Internet Explorer [25], the general
susceptibility of the COM architecture and applications
relying upon it has not previously been investigated.
The issue of securing the execution of content pub-
lished by potentially untrusted third parties is not unique
to COM or Windows. Java applets, for example, expose
a web browser to similar classes of threats encountered
by ActiveX [1, 16]. Security of Java applets has been
studied extensively with several solutions proposed to
verify the publisher of the content and enforce access
rights on the content as it executes. Jaeger, et al. [14]
and Islam, et al. [12] developed systems based on public
key cryptography to verify the publisher of dynamically
downloadable executable content. They both then go on
to propose solutions for the enforcement of access con-
trols on the code as it executes.
Security policies have been developed to address
whether COM objects should be loaded by Internet Ex-
plorer. The killbit list attempts to prevent the instanti-
ation of known bad controls [21]. As documented by
Loscocco et al., ActiveX controls can be signed similar
to the way that was proposed for Java [15]. Addition-
ally, ActiveX supports the concept of “Safe for Script-
ing” [17]. This allows a control to tell Internet Explorer
whether it can be safely loaded by the script engine.
Microsoft has implemented additional security policies
governing the instantiation of COM objects in other ap-
plications including the MS Ofﬁce suite [26]. However,
policies governing the instantiation of COM objects are
implemented by the COM container itself.
Security retroﬁts to well-established software infras-
tructures such as COM generally require signiﬁcant ef-
fort. A number of researchers have investigated the
1. COM objects
Figure
the
IPersistStream::Load() and IPersistStream::Save() API calls, as illustrated here
by the MSVidAnalogTunerDevice object.
information
save
their
load
and
state
using
problem of retroﬁtting legacy systems with security in-
frastructure. These efforts use a range of approaches in-
cluding static analysis of code [3, 7, 27, 29, 30] and the
monitoring of program behavior to determine security
sensitive operations [10,13]. The work by Ganapathy, et
al. demonstrates the injection of authorization policy en-
forcement code into existing legacy applications includ-
ing web and proxy servers [9] and the Linux Security
Module infrastructure [8]. Fraser, et al. perform a sim-
ilar deployment of authorization hooks in MINIX [7].
This builds on the concept of inlined reference monitor-
ing as described by Bauer, et al. [2], Erlingsson [5], and
Evans and Twyman [6]. Each of these demonstrates how
an existing application can be modiﬁed to perform func-
tions not originally designed into the code. The closed
nature of the COM architecture requires that our solu-
tion rely on binary rewriting techniques rather than those
used on source code.
3 COM Background
To understand the attack outlined in this paper and
our proposed solution,
it is necessary to understand
the architecture of COM. This section provides a brief
overview of COM and how it is implemented.
3.1
Introduction to COM
The Component Object Model (COM) is a language-
neutral design philosophy for the creation of soft-
ware components in the Microsoft Windows operat-
ing system [28]. Each COM object must extend the
IUnknown interface as it is documented by Microsoft.
This base interface allows a developer to query an object
to learn more about its behavior and how it can be im-
plemented. There are several other interfaces available
that can be extended by objects depending on their in-
tended use. One such interface is IDispatch. This
provides generic methods allowing for the interaction
with object-speciﬁc methods and properties. This pro-
vides functionality similar to the interaction one would
expect in other object-oriented architectures.
Each COM object that is installed on the system is
listed in the windows registry under a unique identiﬁer
called a Class ID (CLSID). On an average Windows sys-
tem, there are tens of thousands of COM objects reg-
istered. An application choosing to instantiate one of
these objects simply needs to supply the corresponding
CLSID and the desired type of interface to one of the ap-
propriate Win32 APIs. Each of these APIs simply looks
up the CLSID in the registry, loads the library listed in
the registry for that object, and returns a handle to the
object. Whichever interface was speciﬁed will allow ac-
cess to a set of methods and properties corresponding to
that interface.
An interesting feature of COM is its ability to persist
object state across instantiations. There are a number
of interfaces which, if implemented by an object, can
be used to save the runtime state and/or resurrect saved
state during instantiation. Some examples of these inter-
faces are IPersistStorage, IPersistStream,
and IPersistStreamInit. In each of these cases,
the state of the object
is serialized and written to
disk. Conversely, the serialized data can be read from
disk at instantiation time and used to resurrect the ob-
ject state.
It is up to the developer of the object
to determine which object properties are to be per-
sisted and their data type. As shown in Figure 1, an
object called MSVidAnalogTunerDevice contains the
properties Channel and CountryCode. The values of
these properties can be set at instantiation using the
IPersistStream::Load() method or saved to a
binary stream using IPersistStream::Save().
MSVidAnalogTunerDevice    IMSVidAnalogTuner2        Channel        Channel Available        Country Code        IsViewable        View-DWORDBYTEDWORDBYTEDWORDHeaderVT_I4ChannelVT_I4CountryCodeIPersistStream::Load()IPersistStream::Save()Figure 2. Pop-up Warning from Microsoft Word When Attempting to Instantiate an Out-of-Policy
Control
3.2 COM Security
COM exposes some limited information that an ap-
plication can use in making the determination about
an object’s security. Applications can instantiate the
IObjectSafety interface of a COM object if one is
supplied by the object. This interface allows the ap-
plication to determine whether the object deﬁnes itself
as being “Safe for Scripting” and/or “Safe for Initializa-
tion” [17]. Safe for Scripting indicates whether a COM
object deems itself safe to be interoperated with through
the Internet Explorer scripting engines. Safe for Initial-
ization indicates whether a COM object deems itself safe
to be initialized from persisted object state data using the
methods described above. In addition to the COM inter-
face, an object can register the same information in the
Windows registry. Speciﬁcally, two subkeys can be cre-
ated under the Implemented Categories key under the
CLSID for the object The main problem with this in-
terface is that the object itself informs the application
about its own security properties. In the absence of any
other security-related information, an application has no
choice but to believe what the object tells it.
There are several applications on an average Win-
dows installation that allow a third party to determine
which COM objects should be instantiated. Internet Ex-
plorer, for example, can be told to load a speciﬁc COM
object that is required for the operation of the page it
is displaying.
In the context of IE, this is called Ac-
tiveX. Another example is Microsoft Ofﬁce, which al-
lows document authors to embed rich content such as
images, movies, or even other documents in the body of
a Word document or Excel spreadsheet. In each of these
cases, a potentially untrusted third party makes a deter-
mination about which COM objects should be loaded by
applications on an end user’s workstation.
The IObjectSafety interface and its registry-
based equivalent are not sufﬁcient to provide any rea-
sonable level of protection. Due to the widespread use
of Internet Explorer and the ease with which a user
can be redirected to malicious content, IE has received
the majority of the focus with regard to security from
Microsoft. Speciﬁcally, a security conﬁguration option
known as the “killbit” list was created. The killbit list is
a blacklist maintained in the Windows registry that con-