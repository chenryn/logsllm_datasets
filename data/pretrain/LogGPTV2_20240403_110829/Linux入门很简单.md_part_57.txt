重新链接一下，新的rubbish
31号就完成了。这样就省去了重新编译那些没有改动过的文件的时间。
8.3.3 make的机制
不过这样编译虽然节省了编译的时间，但是敲起命令来也挺麻烦的。有没有更方便的方法呢？当然有。
【大项目需要规划】
其实用户完全不必每次都敲一大长串的gcc命令来编译程序。如果是那样，我们Linux内核有上千个文件，要是编译一次，光敲命令就得敲一上午。
那个GCC施工队毕竟只是个施工队，你要是盖个小厨房，垒个猪圈，这样的小东西直接找他们没问题。直接一编译："gcc砖头-o猪圈"就出来了。可如果要盖个CBD商圈，里边什么银行、商场、写字楼、炸油条的、卖臭豆腐的、修理自行车的等，一应俱全，这么大的一个工程，你光叫个施工队来肯定搞不定。这得有人进行合理的统筹规划，设计施工方案，然后再让施工队去具体施工。这个规划的人谁呢？按照懒蜗牛现在的做法，这个规划人就是懒蜗牛自己，但他自己又没这本事，怎么办呢？这时候他就需要专业的规划人，能够指挥施工队的包工头------make。
【make的重要作用】
make也是一个程序，像上面说的一样，他就是负责控制整个施工过程的（也就是编译过程）。对于比较小的程序，就一两个.c文件，根本用不着make出马，GCC施工队去编译就行了，因为源文件的结构关系不是很复杂。可是对于稍大一点的程序，像狐狸妹妹、心有灵犀、星爷啊，基本上所有常用的软件，都足够复杂到需要make来对编译过程进行管理。
如果软件大了，编译的时候就不能简单地把一大堆.c的源文件统统一次性编译成一个二进制文件，这种方法太粗鲁了。应该像上面介绍的那样，把一堆.c文件编译成一堆.o文件，然后再把.o文件链接成一个成品的二进制文件。有改动的时候只更新单个的.o文件就可以。
![alt](images/00011.jpeg){.tpzz}**提示：**[不一定非要把每一个.c文件编译出对应的.o文件，可以几个.c文件生成一个.o，一切根据具体代码的需求来设计。]{.kai1}
但是这个过程如果由人类来负责，就不那么靠谱了。他们的大脑不可靠，不一定能记清楚这次改了哪些文件，应该更新哪个.o文件。于是，make就义无反顾地挑起了这个重要的担子。当然make也不能靠凭空的想象就来指导包工队干活，什么事情总得有个规划，make也需要一份施工的规划书，这份规划书就是Makefile。
8.3.4 Makefile的基本格式
Makefile，顾名思义，就是make用的file。这就相当于一份施工的规划，上面写着整个工程分为几个模块，先用哪几个文件编译成一个什么什么.o，再用哪几个文件编译出一个.o，再怎么怎么一链接，最后得到编译好的二进制程序。
make就根据这份文件来指导GCC他们进行施工。当有某个.c文件被修改之后，make能够根据文件的修改时间智能地判断出哪些模块需要重新编译，重新链接，然后就去让GCC重新编译那些改过的文件，最终生成新的二进制程序。
有了make，写好了Makefile文件，就省去了用户敲一大堆编译命令的烦恼。只要敲一个make命令，其他的，就交给make去做吧。他办事，你放心。
【简单的Makefile示例】
比如说，有这么一个工程，包含了3个文件（咱就不拿懒蜗牛同学的rubbish系列打比方了，源文件太多，还乱）。分别是：main.c、part1.c、part2.c。那么我们就可以试着写出一个用于编译这个工程的Makefile如下：
![alt](images/00467.jpeg){.calibre3}
乍一看可能您不太明白，没关系，咱们慢慢说。当用户运行make命令的时候，make就会来到当前目录下，首先在这个目录里查找Makefile文件，如果没有，就找makefile文件（Linux区分大小写嘛）。如果都没找到，就报错。如果找到了，那就打开Makefile看看该干些什么。
【Makefile中的基本书写格式】
首先我们看到，这个Makefile大致分成了4段，每段的格式都差不多。我们把它总结为这样的格式：
![alt](images/00468.jpeg){.calibre3}
对照着来看，先看第1段：
![alt](images/00469.jpeg){.calibre3}
这段的"目标"是all，all是一个make的关键字，当用户运行make并不加任何参数的时候，make就会来Makefile里找到目标为all的这一段，并且从这里开始干活。
然后，这段的"原料"是main.o、part1.o、part2.o这3个文件。也就是说，要想达到all目标，需要先有这3个文件。于是make就会查找现在是否有这3个文件，一看------没有！
没有没关系，make会继续往下找，这回的目标，就是查找怎么才能搞到main.o文件，结果一找，还真有，第2段就是：
![alt](images/00470.jpeg){.calibre3}
这段的"目标"就是make正要找的main.o，于是赶紧看看原料，是main.c文件。这个文件已经有了。那么怎么用这个原料加工成main.o？看方法：gcc
--c
main.c。哦，原来运行这条命令就行了啊，于是make就会去调用gcc，来编译出main.o。
![alt](images/00011.jpeg){.tpzz}**提示：**["加工方法"一行的前面有且必须有一个Tab制表符，不能顶格写，也不能用空格代替Tab。]{.kai1}
有了main.o，make再回去看第1段，发现还需要part1.o，part2.o，跟main.o的处理方法一样，根据3、4两段就可以编译出来了。原料都齐全了之后，make就再根据第1段的"加工方法"运行"gcc
main.o part1.o part2.o -o mybin"，生成了最终的目标。
另外，刚才说了，如果不加参数，make就去找"目标"是all的段落。其实用户也可以通过参数指定make的目标，比如用户运行：
![alt](images/00471.jpeg){.calibre3}
意思就是去完成Makefile里面，"目标"是main.o的那段任务。于是make就根据Makefile里的记录，只编译出一个main.o来。
![alt](images/00011.jpeg){.tpzz}**提示：**[如果Makefile中没有"目标"为all的段落，并且运行make没有指定参数，则make会执行Makefile中的第1个段落，无论目标是什么。]{.kai1}
【根据时间决定动作】
当某一个.c被修改了之后，用户应该如何编译呢？简单，还是只执行make就可以了。剩下的事情，就交给make去做吧。
make会检查每一个"目标"和"原料"的最后修改时间。比如part1.c文件被修改了，那么make就会发现，part1.o的创建时间要早于part1.c的最后修改时间，这说明part1.o需要被重新编译。于是他就会按照这一段的"加工方法"，再次运行gcc
-c part1.c，来编译出新的part1.o。
那么现在part1.o的创建时间又比最终的mybin新了，于是make又根据第1段的加工方法执行了gcc
main.o part1.o part2.o -o
mybin，把新的part1.o和没有变动的main.o、part2.o链接成了新的mybin文件。
【多种多样的"加工方法"】
上面的例子里，加工方法一行基本都是编译或链接命令。其实，宪法里并没有规定"加工方法"必须是跟gcc有关的。其实加工方法这一行写任何命令都可以，并且不一定只写一行，写几行都可以，只要是挨着就行。比如一般的Makefile里都会有类似下面这样一段，用于清理编译结果：
![alt](images/00472.jpeg){.calibre3}
这一段的目标是clean，没有原料。用户执行：make
clean的时候，make就会找到这一段，并且发现不需要原料，于是直接执行"加工方法"，于是就删除了所有.o文件和最终的编译目标文件。于是整个源代码的目录里恢复到了编译之前的样子。
与此类似的还有make install，一般就是下面这个样子：
![alt](images/00473.jpeg){.calibre3}
也就是在确认当前目录下有mybin这个编译好的文件后，把这个文件复制到系统中的相应目录，就完成了安装。
[8.4 分析师]{.kai}
一说到make，很多人都记得编译源码包的时候，经常在进行make之前还要运行"./configure"命令，这个命令又是干什么的呢？
8.4.1 懒蜗牛的日记D
"2010年11月15日 晴
这个make工具果然方便啊。听说Windows下的VC其实也使用了类似的东西，只不过把它们都用图形界面封装了起来，所以我看不到了。看来还是在Linux下学习编程才能了解到一些本质的东西呀。
我还看到很多以源码包发布的软件，都会有一个configure脚本，成功地运行了这个脚本以后才能去运行make命令。这个脚本又是干什么的呢？"
8.4.2 源码软件的平台依赖
懒蜗牛同学最近是越来越不着调了，竟然想把他最新写的那个rubbish
1115号发布到网上去！祸害我们一个系统还不够，还要残害多少青春懵懂的Ubuntu啊。
【rubbish 1115号------放到哪都是个祸害】
其实那个rubbish
1115号也干不了啥正经事，主要就是能陪懒蜗牛同学玩"猜拳"的游戏，所以才这么受宠。说来也怪，我们软件源里面有那么多游戏，懒蜗牛都没兴趣，不知道为什么就对这么个石头、剪子、布的随机函数情有独钟。不过也难说，毕竟是他自己编的嘛，谁的孩子谁不爱呢。可是您自己喜欢那就偷偷摸摸自己玩就行了，干嘛非要发布到网上让他去祸害别的电脑呢？
这家伙经常申请了内存不释放，有时候还假死，如果是不明所以的人用了这个程序，没准还抱怨我们Linux系统不稳定呢。当然，发牢骚归发牢骚，懒蜗牛的命令我们还是得执行，Firefox就正忙着把rubbish
1115号传到网上去呢。
过了一会儿，狐狸妹妹忍着笑就过来了："你知道懒蜗牛怎么发布他那个程序么？懒蜗牛直接把编译出来的二进制文件贴到了论坛里面。哈哈，他以为这样直接就能运行呢。笑死了。"
【二进制程序------不是放到哪都能运行】
嗯，看来懒蜗牛同学还有很长的路要走啊。这个二进制文件看上去就是单一的文件，但其实他运行起来是需要很多库文件来协助的，不是拿到哪都能运行的。在他们Windows界其实也是这样：Windows
98的程序直接拿到Windows XP下不一定能运行；Windows
XP的程序也有很多装不到Windows
7上。但是由于他们的版本比较少，而且系统的各种库和接口等都比较统一，所以也有不少的绿色程序直接复制到系统里就能运行。因此很多人觉得程序就是一个EXE文件，复制到哪里都可以运行。
懒蜗牛写的这个程序，如果复制到一个和我们相同的系统上，肯定可以运行（也肯定可以造成内存泄漏和假死，哼哼）。可是不一定别人的系统就跟你的系统一模一样啊！尤其我们Linux，发行版五花八门，就算相同的发行版，版本不一样，也不一定能行。如果系统里没有这个程序所依赖的那些库，这个程序肯定是运行不起来的。要想知道一个程序依赖于哪些库，可以用ldd命令来查看。
【查看依赖关系------看他到底在哪能运行】