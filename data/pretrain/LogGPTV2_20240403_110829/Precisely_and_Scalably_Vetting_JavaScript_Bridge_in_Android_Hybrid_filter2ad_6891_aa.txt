title:Precisely and Scalably Vetting JavaScript Bridge in Android Hybrid
Apps
author:Guangliang Yang and
Abner Mendoza and
Jialong Zhang and
Guofei Gu
Precisely and Scalably Vetting JavaScript Bridge
in Android Hybrid Apps
Guangliang Yang(B), Abner Mendoza, Jialong Zhang, and Guofei Gu
SUCCESS LAB, Texas A&M University, College Station, USA
{ygl,abmendoza}@tamu.edu, {jialong,guofei}@cse.tamu.edu
Abstract. In this paper, we propose a novel
system, named
BridgeScope, for precise and scalable vetting of JavaScript Bridge secu-
rity issues in Android hybrid apps. BridgeScope is ﬂexible and can be
leveraged to analyze a diverse set of WebView implementations, such as
Android’s default WebView, and Mozilla’s Rhino-based WebView. Fur-
thermore, BridgeScope can automatically generate test exploit code to
further conﬁrm any discovered JavaScript Bridge vulnerability.
We evaluated BridgeScope to demonstrate that it is precise and eﬀec-
tive in ﬁnding JavaScript Bridge vulnerabilities. On average, it can vet
an app within seven seconds with a low false positive rate. A large scale
evaluation identiﬁed hundreds of potentially vulnerable real-world pop-
ular apps that could lead to critical exploitation. Furthermore, we also
demonstrate that BridgeScope can discover malicious functionalities that
leverage JavaScript Bridge in real-world malicious apps, even when the
associated malicious severs were unavailable.
Keywords: Android security · WebView security · Javascript Bridge
1 Introduction
Android apps (i.e., hybrid apps) increasingly integrate the embedded web
browser component, “WebView”, to render web pages and run JavaScript code
within the app for seamless user experience. App developers can select from
a variety of WebView implementations, such as Android’s default WebView1,
Mozilla’s rhino-based WebView2, Intel’s XWalkView3, and Chromeview4.
The power of WebView extends beyond the basic browser-like functionality
by enabling rich interactions between web (e.g., JavaScript) and native (e.g.,
Java for Android) code within an app through a special interface known as
1 https://developer.android.com/reference/android/webkit/WebView.html.
2 https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino.
3 https://crosswalk-project.org/.
4 https://github.com/pwnall/chromeview.
Electronic supplementary material The online version of this chapter (doi:10.
1007/978-3-319-66332-6 7) contains supplementary material, which is available to
authorized users.
c(cid:2) Springer International Publishing AG 2017
M. Dacier et al. (Eds.): RAID 2017, LNCS 10453, pp. 143–166, 2017.
DOI: 10.1007/978-3-319-66332-6 7
144
G. Yang et al.
a “JavaScript Bridge” [8,14,22,23,26,27,31,32]. The JavaScript Bridge feature
eases the development of hybrid apps. However, it also introduces critical security
risks, such as sensitive information leakage, and local resource access (Sect. 2.2).
Recent research work [8,14,22,23] has highlighted the problems rooted in the use
of JavaScript Bridge. However, an automated and ﬁne-grained solution that can
precisely and scalably detect JavaScript Bridge security issues is still missing.
In this paper, we present a precise and scalable static detection framework
named “BridgeScope”. BridgeScope can automatically vet JavaScript Bridge
usage in Android hybrid apps, and generate test exploit code to validate prob-
lematic JavaScript Bridge usage. Our approach is four-fold. First, BridgeScope
ﬁlls the semantic gap between diﬀerent core WebView implementations using a
generalized WebView model. Second, using the generalized code, BridgeScope is
able to precisely discover all available WebView components and bridges in an
app. Third, BridgeScope reconstructs the semantic information of all JavaScript
Bridges and identiﬁes the sensitive bridges that contain data ﬂows to sensitive
API invocations (such as getLastLoction()). Finally, BridgeScope generates test
exploit code using the analysis results (such as the UI event sequences to trigger
WebView components and data ﬂow inside sensitive bridges).
To achieve high precision and scalability, BridgeScope applies ﬁne-grained
type, taint, and value analysis, which is implemented based using a novel “shad-
owbox” data structure. We refer to our analysis technique as “shadowbox analy-
sis”. Compared with state-of-the-art static approaches such as data ﬂow tracking
[4,33], shadowbox analysis is path- and value-sensitive, while preserving preci-
sion and scalability. We evaluated our shadowbox analysis technique using a
generic benchmark (DroidBench5), and found that it achieved 94% precision.
Finally, we evaluated BridgeScope with 13,000 of the most popular free
Android apps, gathered from Google Play across 26 categories. BridgeScope
found a total of 913 potentially vulnerable apps that may enable various types
of attacks such as stealing sensitive information, gaining privileged access by
bypassing security checks (such as Same Origin Policy6 in the web context),
and other serious attacks that may result in monetary loss to device users.
Furthermore, our evaluation on real-world malware apps also demonstrated
that BridgeScope could identify malicious functionalities hidden in sensitive
JavaScript Bridges, even when the associated malicious servers were unavailable.
In summary, we highlight our key contributions:
– We conduct a systematic study on how WebView and JavaScript Bridge are
used by both benign apps and malware with diverse WebView implementa-
tions.
– We design a precise and scalable static detection system to automatically
detect vulnerabilities caused by JavaScript Bridge.
– We evaluate our detection system BridgeScope with real-world popular apps
and ﬁnd 913 potentially vulnerable apps that could be exploited by attackers.
On average, our system can vet an app within 7 s with a low false positive
rate.
5 https://github.com/secure-software-engineering/DroidBench.
6 https://en.wikipedia.org/wiki/Same-origin policy.
Precisely and Scalably Vetting JavaScript Bridge in Android Hybrid Apps
145
2 Problem Statement
2.1 Background: WebView and JavaScript Bridge
To understand the fundamental components of WebView, irrespective of any
speciﬁc implementation, we devise a model, shown in Fig. 1, based on Android’s
default WebView which we ﬁnd to be representative of most key properties that
are important for our JavaScript Bridge analysis.
Sensitive 
Info.
M
m1
.
.
mn
Native Mobile Code
Jm
Web Code
Jw
E
v
e
n
t
H
a
n
d
e
r
s
l
Configuration Settings
WebView Instance W
Hybrid Mobile Application
Fig. 1. Major modules in Android default WebView. In the example, Bridge Jm enables
interaction between web code Jw and native code M .
JavaScript Bridge. The bridge Jm, shown in Fig. 1, allows interactions between
the embedded web content Jw and the mobile native code implemented in M
(the Bridge Object). Through its access to M, the web code in Jw inherits access
to the local resources and sensitive information in the mobile framework.
To enable bridges in WebView, all bridges must be registered by the API add-
JavascriptInterface(BridgeObject, BridgeName) in advance, where BridgeObject
is a native object (i.e., an instance of a Java class such as M in Fig. 1) that is
being imported into the WebView instance W , and BridgeName is the object’s
reference name that can be used to directly access BridgeObject in the web
context through Jw.
Annotation. In Android 4.2+, an annotation mechanism is introduced to
restrict bridge access. In BridgeObject, only the methods that are explicitly
annotated by ‘@JavaScriptInterface’ can be invoked by JavaScript code.
Conﬁguration Settings. Developers can conﬁgure a WebView component
through its setting property. For instance, developers can enable/disable
JavaScript in WebView. JavaScript is generally disabled by default requiring
explicit activation by developers.
Event Handler. This mechanism allows developers to handle diﬀerent events
after WebView runs, which can be further utilized to provide additional secu-
rity checks. For instance, the two event handlers shouldOverrideU rlLoading()
and shouldInterceptRequest(), which are designed to handle URL and resources
loading events, can be further used to restrict new web content loaded in Web-
View.
146
G. Yang et al.
Same Origin Policy (SOP). In WebView, SOP is enabled to enforce access
control on local data in the web layer between mutually distrusting parties.
However, SOP is not extended to resources in the native layer, such as users’
contact list.
2.2 Security Issues Caused by JavaScript Bridge and Their Impacts
To illustrate the general problem with JavaScript Bridges, consider an Android
app that exposes several methods {m1...mn} ∈ M through a bridge Jm in an
embedded WebView W , as shown in Fig. 1. Consider that m1 provides privileged
access to sensitive APIs and/or functionality in the mobile framework. The web
platform dictates that any code Jw that executes in the context of the embedded
WebView W will also have access to the exposed interface Jm since Jm ∈ Jw.
In other words, all JavaScript code Jw executed in the context of the WebView,
even in embedded iFrames, can invoke all methods exposed by the app in M.
We consider two general approaches attackers may use to exploit JavaScript
Bridge’s:
– Direct Access To Sensitive APIs: Attackers who can inject code into W can
then directly invoke sensitive functionality exposed through Jm. Attackers
can also combine the use of multiple methods in M for more stealthy attacks
that may use one method to read data, and another method to write data to
a remote server. This is a variant of the classic confused deputy access control
problem [16]. In this scenario, the WebView W , as the deputy, will diligently
allow access to both exposed methods m1 and m2, allowing an attacker to
ﬁrst invoke the request for sensitive information through m1, and then append
the returned data to another request to the communication-enabled exposed
interface m2. Additionally, even if M does not include a method such as m2,
if the app has INTERNET permissions, then data from m1 can still be leaked
by Jw through a JavaScript HTTP method.
– Cross-Origin DOM Manipulation: A more interesting attack scenario emerges
when mn exposes an API that allows manipulation of the DOM in W , such
as using loadU RL() or loadDataW ithBaseU RL(). As a result, an embedded
iFrame in W can inject cross origin JavaScript code to eﬀectively circumvent
the same origin policy (SOP) and execute cross-site-scripting-like attacks in
W ’s web origin. This is a violation of the same origin policy assumption, and
can result in client-side XSS attacks using JavaScript Bridges. The root cause
here is that the origin information is lost when JavaScript causes content to
be loaded via a Bridge Object.
2.3 Sensitive APIs
We consider three type of ‘sensitive’ system APIs, which we categorize as source
(i.e., reading data from Android), sink (i.e., sending data out of mobile devices),
and danger (i.e., dangerous operations) APIs. Speciﬁcally, we deﬁne “source
Precisely and Scalably Vetting JavaScript Bridge in Android Hybrid Apps
147
API” and “sink API” using a comprehensive categorization developed in a pre-
vious work [25]. Additionally, we treat any API that can access local hardware
(such as camera), and cause charges on the user’s device (e.g. SMS, phone calls),
as a “danger API”.
2.4 Threat Model
We focus on hybrid apps that enable JavaScript and JavaScript Bridge. We
assume that the code written in C/C++ and implicit data ﬂow inside apps have
minimal inﬂuence for our analysis. Generally, we consider attack scenarios in the
context of benign and malicious apps:
Benign Apps. In this scenario, we assume that HTML/Javascript code loaded
in WebView of benign apps is untrusted. We also assume that web attackers
cannot directly access the native context, but can inject malicious HTML/-
JavaScript code to WebView through code injection attacks. We consider two
ways for attackers to launch such attacks. Attackers can either compromise third-
party websites, or inject/hijack network traﬃc (e.g., MITM attack) [3], such as
the HTTP communication within WebView or third party Java libraries (e.g.,
ad libs [26]).
A much stronger assumption is that attackers may also hijack HTTPS traﬃc.
Although this type of attack is diﬃcult, it is still feasible, particularly considering
how poorly/insecurely HTTPS is implemented/used in mobile apps [11,13].
Malicious Apps. We assume that an attacker writes a malicious app using
WebView and JavaScript Bridge, and submits it to app marketplaces, such as
Android oﬃcial market ‘Google Play’. To evade security vetting systems in app
marketplaces, such as Google Bouncer7, the app is designed in such a way that (1)
WebView loads a remote web page, whose content is controlled by the attacker;
(2) the malware’s sensitive behaviors are conducted in JavaScript Bridge, while
its command & control (CC) logic is implemented by JavaScript code in Web-
View; (3) initially, the CC code is not injected into the loaded web page, and
it only becomes available at a speciﬁc time, such as after the app bypasses the
security checks and is published.
3 Shadowbox Analysis
In this section, we present details about our shadowbox analysis technique. First,
we highlight the advantages of our approach, compared with other state-of-the-
art approaches. Then, we present deﬁnitions and concepts related to shadowbox.
We also discuss more details about type, taint and value analysis respectively.
Finally, we show how to apply shadowbox analysis to solve diﬀerent challenges,
such as the problem caused by common data structures.
7 http://googlemobile.blogspot.com/2012/02/android-and-security.html.
148
G. Yang et al.
3.1 Challenges
Type, taint, and value/string analysis are frequently used program analysis tech-
niques [4,7,15,33]. However, the state-of-the-art approaches fall short of (1) pre-
cisely handling common data structures, such as list, hashmap, Android Bundle8,
Parcel9, etc.; (2) maintaining path- and value-sensitivity while also remaining
precise and scalable. These shortcomings may cause false negatives and false
positives in analysis results.
Path- And Value-Sensitivity. To achieve high precision, it is critical to main-
tain path- and value-sensitivity. However, state-of-the-art work (such as Flow-
droid [4] and Amandroid [33]) do not thoroughly maintain these properties. For
instance, Listing 1.1 shows a snippet of a test case (from DroidBench) designed
to test false positives of alias analysis. In this test case, sensitive information
saved in ‘deviceId’ is transferred to a ﬁeld of an instance of the class ‘A’ (Line
14), and then a sink API is called (Line 15), which merely sends out a constant
string rather than the sensitive information. However, existing approaches, such
as Flowdroid [4] and Amandroid [33], erroneously ﬁnd a path from source to
sink in this scenario due to path-insensitivity.
1 c l a s s A{ p u b l i c S t r i n g b =”Y” ;}
2 c l a s s B{ p u b l i c A a t t r ;}
3 . . .
4 A b , q , y ; B a , p , x ;
5 a = new B( ) ; p = new B ( ) ;
6 b = new A( ) ;
7 i f
8 e l s e {x = p ; y = q ;}
9 x . a t t r = y ;
10 q . b = d e v i c e I d ; / / s o u r c e
11 sms . sendTextMessage ( ”+49 1234 ” , n u l l , a . a t t r . b , n u l l , n u l l ) ; / / s i n k
( Math . random ( )  a r r a y = new A r r a y L i s t () ;
2 S t r i n g s = s o u r c e ( ) ;
3 a r r a y . add ( s ) ;
4 a r r a y . add ( 0 , ” e l e m e n t 0 ” ) ;
/ / a r r a y : [ s o u c e ]
/ / a r r a y : [ " e l e m e n t 0 " , s o u r c e ( ) ]
Listing 1.2. An Example abstracted from real apps
BridgeScope solves this problem by performing ﬁne-grained type, taint and
value analysis using a ‘shadowbox’ data structure as discussed in the following
sections.
8 https://developer.android.com/reference/android/os/Bundle.html.
9 https://developer.android.com/reference/android/os/Parcel.html.
Precisely and Scalably Vetting JavaScript Bridge in Android Hybrid Apps
149
3.2 Concepts Related to Shadowbox
We deﬁne a shadowbox as the representation of an object (e.g. WebView). Gen-
erally, only tainted ‘primitive variables’ (e.g., integers), whose data type is prim-
itive, and all ‘non-primitive variables’ (e.g., string and array) are boxed. The
relevant concepts are deﬁned as follows: (note that v and s represent a variable