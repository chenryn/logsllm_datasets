ePrint Archive (2019).
[43] Jun Furukawa, Yehuda Lindell, Ariel Nof, and Or Weinstein. 2017. High-
Throughput Secure Three-Party Computation for Malicious Adversaries and
an Honest Majority. In EUROCRYPT. 225–255.
[44] Martin Geisler. 2007. Viff: Virtual ideal functionality framework. http://viff.dk.
[45] Rosario Gennaro, Yuval Ishai, Eyal Kushilevitz, and Tal Rabin. 2002. On 2-Round
Session 7C: Secure Computing VCCS ’19, November 11–15, 2019, London, United Kingdom1588[46] Oded Goldreich, Silvio Micali, and Avi Wigderson. 1987. How to Play any Mental
Game or A Completeness Theorem for Protocols with Honest Majority. In STOC.
218–229.
[47] S. Dov Gordon, Feng-Hao Liu, and Elaine Shi. 2015. Constant-Round MPC with
Fairness and Guarantee of Output Delivery. In CRYPTO. 63–82.
[48] Thomas Holenstein, Robin Künzler, and Stefano Tessaro. 2011. The equivalence
of the random oracle model and the ideal cipher model, revisited. In STOC. 89–98.
[49] Yuval Ishai, Ranjit Kumaresan, Eyal Kushilevitz, and Anat Paskin-Cherniavsky.
2015. Secure Computation with Minimal Interaction, Revisited. In CRYPTO.
359–378.
[50] Mitsuru Ito, Akira Saito, and Takao Nishizeki. 1989. Secret sharing scheme
realizing general access structure. Electronics and Communications in Japan (Part
III: Fundamental Electronic Science) (1989).
[51] John Launchbury, Dave Archer, Thomas DuBuisson, and Eric Mertens. 2014.
Application-Scale Secure Multiparty Computation. In Programming Languages
and Systems. 8–26.
[52] Yehuda Lindell, Benny Pinkas, Nigel P. Smart, and Avishay Yanai. 2015. Effi-
cient Constant Round Multi-party Computation Combining BMR and SPDZ. In
CRYPTO. 319–338.
[53] Eleftheria Makri, Dragos Rotaru, Nigel P. Smart, and Frederik Vercauteren. 2017.
PICS: Private Image Classification with SVM. IACR Cryptology ePrint Archive
2017 (2017), 1190.
[54] Payman Mohassel and Peter Rindal. 2018. ABY3: A Mixed Protocol Framework
[55] Payman Mohassel, Mike Rosulek, and Ye Zhang. 2015. Fast and Secure Three-
for Machine Learning. IACR Cryptology ePrint Archive 2018 (2018), 403.
party Computation: The Garbled Circuit Approach. In CCS. 591–602.
(1991), 151–158.
[56] Moni Naor. 1991. Bit Commitment Using Pseudorandomness. J. Cryptology 4, 2
[57] Jesper Buus Nielsen, Peter Sebastian Nordholt, Claudio Orlandi, and Sai Sheshank
Burra. 2012. A New Approach to Practical Active-Secure Two-Party Computation.
In CRYPTO.
[58] Peter Sebastian Nordholt and Meilof Veeningen. 2018. Minimising Communica-
tion in Honest-Majority MPC by Batchwise Multiplication Verification. In ACNS.
321–339.
[59] Rafael Pass, Elaine Shi, and Florian Tramèr. 2017. Formal Abstractions for Attested
[60] Arpita Patra and Divya Ravi. 2018. On the Exact Round Complexity of Secure
[61] Tal Rabin and Michael Ben-Or. 1989. Verifiable Secret Sharing and Multiparty
Execution Secure Processors. In EUROCRYPT. 260–289.
Three-Party Computation. In CRYPTO. 425–458.
Protocols with Honest Majority (Extended Abstract). In STOC. 73–85.
[62] Phillip Rogaway and Thomas Shrimpton. 2004. Cryptographic Hash-Function Ba-
sics: Definitions, Implications, and Separations for Preimage Resistance, Second-
Preimage Resistance, and Collision Resistance. In FSE. 371–388.
Technical Journal 28, 4 (1949), 656–715.
Multiparty Computation. In CCS. 39–56.
Abstract). In FOCS. 160–164.
[63] C. E. Shannon. 1949. Communication theory of secrecy systems. The Bell System
[64] Xiao Wang, Samuel Ranellucci, and Jonathan Katz. 2017. Global-Scale Secure
[65] Andrew Chi-Chih Yao. 1982. Protocols for Secure Computations (Extended
A FUNCTIONALITIES AND SECURITY
MODEL
A function negl(κ) is said to be negligible in κ if for every posi-
tive polynomial p(·), there exists an n0 such that for all n > n0, it
holds that negl(n) <
p(n). A probability ensemble X = {X(a, n)}
1
a∈{0,1}∗;n∈N is an infinite sequence of random variables indexed
by a and n ∈ N. Two ensembles X = {X(a, n)}a∈{0,1}∗;n∈N and
Y = {Y(a, n)}a∈{0,1}∗;n∈N are said to be computationally indistin-
c≈ Y, if for every PPT algorithm D, there
guishable, denoted by X
exists a negligible function negl(.) such that for every a ∈ {0, 1}∗
and n ∈ N, | Pr[D(X(a, n)) = 1] − Pr[D(Y(a, n)) = 1]| ≤ negl(n).
The security of our protocols is proven based on the standard
real/ideal world paradigm i.e. it is examined by comparing the ad-
versary’s behaviour in a real execution to that of an ideal execution
considered to be secure by definition (in presence of an incorruptible
trusted third party (TTP)). In an ideal execution, each participating
party sends its input to TTP over a perfectly secure channel, the
TTP computes the function using these inputs and sends respective
output to each party. Informally, a protocol is said to be secure if an
adversary’s behaviour in the real protocol (where no TTP exists)
can be simulated in the above described ideal computation.
Below we present the ideal functionalities in the standard secu-
rity model for unanimous abort, fair and GOD in Figs 16,17 and 18
respectively.
Each honest party Pi (i ∈ [5]) sends its input xi to the functionality. Cor-
rupted parties may send arbitrary inputs as instructed by the adversary.
When sending the inputs to the trusted party, the adversary is allowed to
send a special abort command as well.
Input: On message (Input, xi ) from Pi , do the following: if (Input, ∗)
message was received from Pi , then ignore. Otherwise record x′
= xi
internally. If x′
= abort.
i
Output to the adversary: If there exists i ∈ [5] such that x′
= abort,
i
send (Output, ⊥) to all the parties. Else, send (Output, y) to the adversary,
where y = f (x′
Output to honest parties: Receive either continue or abort from the
adversary. In case of continue, send y to all honest parties. In case of
abort send ⊥ to all honest parties.
is outside of the domain for Pi , consider x′
5).
4, x′
1, x′
2, x′
3, x′
i
i
Figure 16: Ideal Functionality FuAbort
Each honest party Pi (i ∈ [5]) sends its input xi to the functionality. Cor-
rupted parties may send arbitrary inputs as instructed by the adversary.
When sending the inputs to the functionality, the adversary is allowed to
send a special abort command as well.
Input: On message (Input, xi ) from Pi , do the following: if (Input, ∗)
message was received from Pi , then ignore. Otherwise record x′
= xi
internally. If x′
i
Output: If there exists i ∈ [5] such that x′
= abort, send (Output, ⊥) to
i
all the parties. Else, send (Output, y) to party Pi for every i ∈ [5], where
y = f (x′
is outside of the domain for Pi , consider x′
= abort.
5).
4, x′
3, x′
Figure 17: Ideal Functionality Ffair
1, x′
2, x′
i
i
Each honest party Pi (i ∈ [5]) sends its input xi to the functionality.
Corrupted parties may send arbitrary inputs.
Input: On message (Input, xi ) from a party Pi (i ∈ [5]), do the following:
if (Input, ∗) message was already received from Pi , then ignore. Else
is outside of the domain for Pi , set x′
record x′
= xi internally. If x′
to
i
i
be some predetermined default value.
5) and send (Output, y) to
Output: Compute y = f (x′
2, x′
1, x′
party Pi for every i ∈ [5].
3, x′
4, x′
i
Figure 18: Ideal Functionality Fgod
B PRIMTIVES
B.1 Non-Interactive Commitment Scheme
We use Non-Interactive Commitment Scheme (NICOM) character-
ized by two PPT algorithms (Com, Open) and are defined as:
– Com outputs commitment c and corresponding opening in-
formation o, given a security parameter κ, a common public
parameter pp, message x and random coins r.
– Open outputs the message x given κ, pp, a commitment c and
corresponding opening information o.
The commitment scheme should satisfy the following properties:
– Correctness: For all values of public parameter pp, message
x ∈ M and randomness r ∈ R, if (c, o) ← Com(x; r) then
Open(c, o) = x.
Session 7C: Secure Computing VCCS ’19, November 11–15, 2019, London, United Kingdom1589– Hiding: For all PPT adversaries A, all values of pp, and all
′ ∈ M, the difference |Pr(c ,o)←Com(x)[A(c) = 1] −
x, x
Pr(c ,o)←Com(x
′) such that
′)}
Open(c, o) (cid:44) Open(c, o
with negligible probability over uniform choice of pp and
random coins of A.
– Binding: A PPT adversary A outputs (c, o, o
′) and ⊥ (cid:60) {Open(c, o), Open(c, o
′)[A(c) = 1]| is negligible.
(x||r).
Instantiations. In the random oracle model, the commitment
scheme is:
– Com(x; r) sets c = H(x||r), o = (x||r) where c, o refer to the
commitment and opening respectively. The pp can be empty.
– Open(c, o = (x||r)) returns x if H(o) = c and ⊥ otherwise.
We provide bit
For the purpose of all empirical results, the random oracle can be
instantiated using a hash function. Alternatively, based on one-way
permutation, we present an instantiation of NICOM(Com, Open)
used theoretically in our protocols as: Let f : {0, 1}n → {0, 1}n
be a one-way permutation and h : {0, 1}n → {0, 1} be a hard-core
predicate for f . Then the bit-commitment scheme for x is:
– Com(x, r) sets c = (f (r), x ⊕ h(r)) where r ∈R {0, 1}n and o =
– Open(c, o = (x||r)) returns x if c = (f (r), x ⊕ h(r)), else ⊥.
and string based instantiations
for
NICOM(Com, Open) [25] based on block ciphers that are
secure in the ideal cipher model [19, 48, 63] and are used in our
AOTs for efficiency. The bit commitment scheme is as follows:
– Com(b, r) sets c = Fk(r) ⊕ r ⊕ bn where bn = ||i∈[n]b and
F : {0, 1}n × {0, 1}n → {0, 1}n is a random permutation
parametrized by key k. Also, o = (r||b).
– Open(c, o = (r||b)) returns b if c = Fk(r)⊕r⊕bn and ⊥ otherwise.
However, this bit commitment scheme is not secure for string com-
mitments. Hence we describe the following secure instantiation:
– Com(m, r) sets c = Fk(r)⊕r⊕Fk(m)⊕m s.t F : {0, 1}n×{0, 1}n →
{0, 1}n is a random permutation parametrized by key k and
o = (r||m).
– Open(c, o = (r||m)) returns b if c = Fk(r) ⊕ r ⊕ Fk(m) ⊕ m, else
⊥.
B.2 Equivocal Commitment Scheme
For the fair protocol, we use an Equivocal Non-Interactive Com-
mitment Scheme (eNICOM) characterized by four PPT algorithms
(eCom, eOpen, eGen, Equiv). The algorithms eCom, eOpen are as
defined in NICOM. The algorithms eGen, Equiv are defined as:
– eGen(1κ) returns a public parameter and a corresponding trap-
door (epp, t). The parameter epp is used by both eCom and
eOpen and trapdoor t is used for equivocation.
– Equiv(c, o′, x, t) returns an o s.t x ← eOpen(epp, c, o) when in-
voked on commitment c, its opening o′, the desired message
x (to which equivocation is required) and the trapdoor t.
An eNICOM should satisfy the following properties:
– Correctness: For all pairs of public parameter and trapdoor,
(epp, t) ← eGen(1κ), message x ∈ M and randomness
r ∈ R, if (c, o) ← eCom(x; r) then eOpen(c, o) = x.
– Hiding: For all (epp, t) ← eGen(1κ), all PPT adversaries A and
all x, x′ ∈ M, the difference |Pr(c ,o)←eCom(x)[A(c, o) = 1]−
Pr(c ,o)←eCom(x ),o←Equiv(c ,x ,t)A(c, o) = 1| is negligible
– Binding: For all (epp, t) ← eGen(1κ), a PPT adversary A
′) and ⊥ (cid:60)
outputs (c, o, o
{eOpen(c, o), eOpen(c, o
′) s.t eOpen(c, o) (cid:44) eOpen(c, o
′)} with negligible probability.
sets
(epp, t1, t2, t3, t4)
Instantiation: We can use the equivocal bit commitment scheme
of [34] in the standard model, based on Naor’s commitment scheme
[56] for bits. Let G : {0, 1}n → {0, 1}4n be a pseudorandom gener-
ator. The commitment scheme for bit b is:
– eGen(1κ)
((σ, G(r1), G(r2),
G(r3), G(r4)), r1, r2, r3, r4), where σ = G(r1) ⊕ G(r2) ⊕
G(r3) ⊕ G(r4). t = ||i∈[4]ti is the trapdoor.
– eCom(x; r) sets c = G(s1) ⊕ G(s2) if x = 0, else c = G(s1) ⊕
G(s2) ⊕ σ and sets o = (x||r) where r = s1||s2.
– eOpen(c, o = (x||r)) returns x if c = G(s1) ⊕ G(s2) ⊕ x · σ (where
(·) denotes multiplication by a constant), else returns ⊥.
– Equiv(c = G(r1) ⊕ G(r2),⊥, x,(t1, t2, t3, t4)) returns o = (x||r)
where r = t1||t2 if x = 0, else r = t3||t4. The entire trapdoor
t = (t1, t2, t3, t4) is required for equivocation.
=
For empirical purposes, we rely on the random oracle based
scheme presented before with the property of equivocation and is
realized using a hash function.
B.3 Collision Resistant Hash [62]
Consider a hash function family H = K × L → Y. The hash
function H is said to be collision resistant if for all probabilis-
tic polynomial-time adversaries A, given the description of Hk
where k ∈R K, there exists a negligible function negl() such that
Pr[(x1, x2) ← A(k) : (x1 (cid:44) x2) ∧ Hk(x1) = Hk(x2)] ≤ negl(κ),
where m = poly(κ) and x1, x2 ∈R {0, 1}m.
Session 7C: Secure Computing VCCS ’19, November 11–15, 2019, London, United Kingdom1590