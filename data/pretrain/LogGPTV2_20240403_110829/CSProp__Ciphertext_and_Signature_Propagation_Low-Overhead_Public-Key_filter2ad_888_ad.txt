### Security Libraries and Development Tools

Our implementation leverages the security library, dnsjava [42], and Bouncy Castle [72], a widely used library for cryptography. The dnsjava library is a Java-based implementation of DNS and is utilized by several major Android applications, including Netflix, Skype, Samsung Email, and Dailyhunt. For programming the Arduino platform, we use the official Arduino-IDE [12] release/v1.8.12, which is the standard development framework for Arduino devices. The Arduino prototype is based on the Cryptographic-Protocols-Arduino-and-PC [34] library, previously used to measure RSA performance on IoT devices [66, 90]. We employ an Arris router [15] as the gateway communication device. Desktop machines and Raspberry Pis (excluding the Raspberry Pi Zero W) are connected via 1Gbps Ethernet, while the Arduino and Raspberry Pi Zero W use Wi-Fi.

### Energy Consumption Measurement

To measure energy consumption, we use the Watts Up? Pro AC meter [80], which supports multiple displays, computer software, and PC interfaces. Its data logger function records all data into non-volatile memory, allowing us to collect and analyze power consumption.

### Testbed Configuration

We use a desktop machine running Ubuntu 16.04.6 LTS as the origin server, which acts as DNS servers in DNSSEC, web servers in TLS, and the default gateway in IoT environments. For backward compatibility with middleboxes, we use the recommended key size of 2048-bit and the hashing algorithm SHA-256 [68, 83]. Key distribution issues, which can be challenging at scale, are not considered. We assume that RSA keys are generated by the origin server rather than the end device. The problem of vulnerable keys generated by resource-constrained devices [55] is treated as an orthogonal issue. Our propagator is a desktop machine running Windows 10. Figure 4 illustrates the main components of the testbed.

### Performance Comparison

We compare CSProp with traditional implementations of DNSSEC validation, TLS handshakes, and RSA public-key operations. Additionally, we compare CSProp with current real-world configurations where the public exponent is 216 + 1 = 65537.

### CSProp over DNSSEC

#### Latency and Energy Consumption

In this section, we present measurement results for CSProp over DNSSEC, focusing on two metrics: latency and energy consumption. We configure a private network to simulate the DNS hierarchy, including the Root (.), TLD (.com), and Auth (example) name servers internally in the origin server. The target domain name in our experiments is www.example.com. The DNSKEYRootKSK record (i.e., the trust anchor) is pre-installed at the DNS resolver and all four end devices used in the prototype. To optimize the DNSSEC resolution process, the DNS resolver supports caching.

We performed measurements with and without caching enabled at the DNS resolver, repeating each experiment 10 times to bound confidence intervals. Figure 5 shows the latency breakdown for CSProp over DNSSEC, including the time consumed by end devices and the network. The results demonstrate a significant reduction in latency compared to traditional DNSSEC validation, with a minor impact when the cache is disabled. Device specifications also affect performance; for example, CSProp reduces latency by 91x, 21x, 35x, and 10x on Raspberry Pi Zero W, Raspberry Pi 3 Model B, Raspberry Pi 3 Model B+, and Surface Pro 6, respectively, when e = 65463 and the cache is disabled. These reductions are approximately the same when DNS caching is enabled. We also compared CSProp with current DNSSEC implementations using a public exponent of 65537.

Figure 6 shows a significant reduction in energy consumption when CSProp is used, with energy reduced by 53x, 10x, 9x, and 4x on Raspberry Pi Zero W, Raspberry Pi 3 Model B, Raspberry Pi 3 Model B+, and Surface Pro 6, respectively.

### CSProp over TLS

#### Latency and Energy Consumption

Similar to the DNSSEC setup, we configure a private network for TLS, where the origin server is a destination web server. We use TLS 1.3 for the handshake phase, with the web server's certificate being of type X.509 and signed by a root CA. The pre-master secret key (K) is generated using the Advanced Encryption Standard (AES) algorithm with a key size of 128 bits, as recommended in [83].

The latency of TLS operations is shown in Figure 7, focusing on the "Client Hello," "Server Hello," and "Client Finished" messages. CSProp provides 8x, 4x, 3x, and 2x reductions in latency on Raspberry Pi Zero W, Raspberry Pi 3 Model B, Raspberry Pi 3 Model B+, and Surface Pro 6, respectively. These numbers include full handshake latency, including network delays, which are not affected by CSProp.

For energy consumption, Figure 8 shows that CSProp, on average, reduces the consumed energy by a factor of 8x, 3x, 3x, and 2x on Raspberry Pi Zero W, Raspberry Pi 3 Model B, Raspberry Pi 3 Model B+, and Surface Pro 6, respectively.

### Comparison with Elliptic Curve Cryptography (ECC)

When power and latency are critical, Elliptic Curve Cryptography (ECC) is often considered due to its shorter key sizes and faster signing. However, ECC has slower signature validation compared to RSA. RFC 6605 [57] and Rijswijk-Deij et al. [96] highlight that even with optimized OpenSSL implementations, ECDSA remains slower than RSA for signature validation. The actual adoption of ECC by DNSSEC operators is very low [59, 95], raising concerns about backward compatibility.

For TLS, Gupta et al. [53] found that RSA outperforms ECC in SSL on resource-constrained devices. Our experimental measurements (Table 4) show that TLS handshake using CSProp is faster by a factor of ≈ 2.7x than ECC. This advantage is particularly important for resource-constrained devices, as increased CPU load from ECC can be burdensome.

### Performance on Arduino IoT Board

We evaluate CSProp on an Arduino MKR WiFi 1010 board, a true IoT class system. Due to the lack of cryptographic library support for full integration with DNSSEC and TLS, we focus on RSA public-key operations: verification for signature propagation and encryption for ciphertext propagation. We implement and evaluate CSProp and traditional RSA for these operations with key lengths of 512, 1024, and 2048 bits. The code size is ≈ 8 KB, and the message size is 128 bytes for all test cases. We consider basic mathematical operations without optimizations.

Table 5 summarizes the results, showing that CSProp outperforms traditional RSA in all scenarios. CSProp significantly reduces latency, power consumption, and memory footprint. For instance, CSProp-encryption and CSProp-verification are 57 and 61 times faster, respectively, and reduce energy consumption by 36x and 42x, respectively. CSProp's modular exponentiation requires less memory, making it more efficient for resource-constrained devices.

### Importance of Public Key Operations

Public key operations are common in IoT devices, especially for verifying signatures and encrypting data. To validate this, we analyzed traffic on a Wyze Cam V2, a smart home camera, connected to a wireless home network via an Arris router. The network uses WPA2-AES-128-bit protocol for encryption. Our client is a Wyze app on an iPhone X running iOS 13.3.1. The results show that the camera uses cryptographic operations continuously, with RSA public-key operations accounting for 4.2% of packet exchanges during a 2-hour live-streaming event. Although this percentage is small, these operations are computationally expensive and consume a significant amount of energy.

### Related Work

Lightweight cryptography is an active research area, focusing on low-overhead cryptographic algorithms for energy- or computation-constrained machines, especially in IoT environments. Most work focuses on symmetric cryptography due to its lower overheads. Symmetric lightweight cryptography is well-studied, but public key operations remain a challenge due to their computational cost.

### Conclusion

CSProp significantly improves the performance of public key operations, making them more practical for resource-constrained IoT devices. The results show substantial reductions in latency, energy consumption, and memory footprint, making CSProp a promising solution for enhancing the efficiency of cryptographic operations in IoT environments.