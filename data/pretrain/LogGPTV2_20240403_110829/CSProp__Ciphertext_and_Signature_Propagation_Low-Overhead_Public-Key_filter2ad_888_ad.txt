on the security library, dnsjava4, and Bouncy Castle [72],
which is a widely used library for cryptography. The dns-
java library is an implementation of DNS in Java and is used
by a number of major android applications, such as Netﬂix,
Skype, Samsung Email, and Dailyhunt [42]. For program-
ming the Arduino platform, we use the Arduino-IDE [12]
release/v1.8.12, which is the ofﬁcial development framework
for Arduino devices. The Arduino prototype is implemented
based on the Cryptographic-Protocols-Arduino-and-PC [34]
library which has been used by previous work to measure
the performance of RSA on IoT devices [66, 90]. We use an
Arris router [15] as the gateway communication device. The
desktop machines and the Raspberry pis, except Raspberry
Pi Zero W, are connected using 1Gbps Ethernet, while the
Arduino and the Raspberry Pi Zero W use WiFi.
To measure energy consumption, we use the Watts Up? Pro
AC meter [80]. This power meter supports several displays,
computer software, and PC interfaces. Its data logger function
records all data into non-volatile memory, which we collect
to measure the consumed power.
We use a desktop machine running Ubuntu 16.04.6 LTS
operating system as an origin server (i.e., DNS servers in
DNSSEC, web servers in TLS, and default gateway in IoT
environments). For reasons of backward compatibility with
middleboxes, we use the recommended key size of 2048-bit
and hashing algorithm SHA-256 [68, 83]. We do not consider
key and distribution issues which can be difﬁcult at scale. We
assume that RSA keys are generated by the origin server and
not the end device. We consider the problem of vulnerable
keys that are generated by resource-constrained devices [55]
to be an orthogonal problem. Our propagator is a desktop
machine running Windows 10. Figure 4 shows the main
components of the testbed.
We compare CSProp with traditional implementations of
DNSSEC validation, TLS handshakes, and RSA public-key
operations. We also compare CSProp with current real-world
conﬁgurations where the public exponent is 216 + 1 = 65537.
5.2 CSProp over DNSSEC
In this section, we show measurement results of CSProp over
DNSSEC based on two metrics: (1) Latency; and (2) Energy
consumption. We conﬁgure a private network (simulating
the topology in Figure 1a) to represent the DNS hierarchy.
More precisely, we conﬁgure the Root (.), the T LD (.com),
4Available at: http://www.xbill.org/dnsjava/
USENIX Association
30th USENIX Security Symposium    617
110V1Gbps Ethernet1Gbps EthernetVCCArduino MKR WiFi1010End DeviceWi-Fi Router/APWindows 10 PCPropagatorUbuntu 16.04 LTS PCOrigin ServerWi-Fi5V Power SupplyWatts UP? Pro AC MeterGND110VFigure 5: CSProp over DNSSEC — Latency
CSProp outperforms this setting, reducing latency by 78x on
Raspberry Pi Zero compared to conventional DNSSEC when
e = 65537. The results are marginally better than those when
e = 65463 in the case of traditional DNSSEC validation, since
65537 is a Fermat number (2n + 1 primes). Fermat numbers
are recommended [85] since only the ﬁrst and last bits of their
binary representation are ones (100...001) which minimizes
computation cost. Figure 6 shows a signiﬁcant reduction in
energy consumption when CSProp is used; energy is reduced
by 53x, 10x, 9x, and 4x on Raspberry Pi Zero W, Raspberry
Pi 3 Model B, Raspberry Pi 3 Model B+, and Surface Pro 6,
respectively.
5.3 CSProp over TLS
Similar to the setup phase with DNSSEC, we conﬁgure a
private network (with the topology in Figure 1b) where the
origin server is a destination web server.We use TLS 1.3 for
the handshake phase. The web server’s certiﬁcate is of type
X.509 and is signed by a root CA which its certiﬁcate is al-
ready pre-installed at the default gateway and end devices. The
pre-master secret key (K) is generated using the Advanced En-
cryption Standard (AES) algorithm as recommended in [83]
with 128-bit as the key size.
The latency of the TLS operations are shown in Figure 7.
We show the latency incurred by CSProp over TLS but based
on the handshake messages: "Client Hello", "Server Hello",
and "Client Finished". We use this approach to clearly under-
stand the advantage of our protocol over the existing imple-
mentations; speciﬁcally when e = 65537. CSProp provides
8x, 4x, 3x, and 2x reductions in latency (vs. traditional TLS
handshake) on Raspberry pi Zero W, Raspberry Pi 3 Model B,
Raspberry Pi 3 Model B+, and Surface Pro 6, respectively. We
note that these numbers are the full handshake numbers, in-
cluding the network delays (which are not helped by CSProp).
For energy consumption measurements, we measured the
rate at which power is being used at a speciﬁc moment in
watts (as shown in Figure 8). We found that CSProp, on
average, reduces the consumed energy by a factor of 8x, 3x,
3x, and 2x on Raspberry Pi Zero W, Raspberry Pi 3 Model
B, Raspberry Pi 3 Model B+, and Surface Pro 6, respectively.
Figure 6: CSProp over DNSSEC — Energy Consumption
and the Auth (example) name servers internally in the origin
server. We use www.example.com as the target domain name
in our experiments. In addition, the DNSKEYRootKSK record
(i.e., the trust anchor) is pre-installed at the DNS resolver
and all four end devices used in the prototype. To optimize
DNSSEC resolution process, the DNS resolver supports the
caching property.
We performed the measurements when caching is enabled
and disabled at the DNS resolver to get an insight of the im-
pact of caching on the protocol (each experiment is repeated
10 times to bound conﬁdence intervals).
Figure 5 shows a break down of the latency incurred by
CSProp over DNSSEC. The latency is broken down into the
time consumed by end devices and by the network. The latter
time includes: (1) the network overhead caused by sending
and receiving packets between the communicated parties; and
(2) the time required by the DNS resolver to compute the
propagated signature. The results show a signiﬁcant reduction
in latency compared to traditional DNSSEC validation, with
a minor impact on latency when the cache is disabled at the
DNS resolver. Additionally, we see how device speciﬁcations
affect performance. For example, in case e = 65463 and cache
is disabled, we ﬁnd that CSProp reduces latency by 91x, 21x,
35x, and 10x on Raspberry Pi Zero W, Raspberry Pi 3 Model
B, Raspberry Pi 3 Model B+, and Surface Pro 6, respectively,
compared to traditional DNSSEC validation. Note that the
reductions are approximately the same when DNS cache is
enabled. We also compared CSProp with current DNSSEC
implementations where the used public exponent is 65537.
618    30th USENIX Security Symposium
USENIX Association
Figure 7: CSProp over TLS — Latency
Table 4: Comparing CSProp with Elliptic Curve Cryptography
(ECC) for TLS handshake latency (in µ-seconds)
CSProp e = 65463, elow = 3
ECDH-ECDSA P-256
Raspberry Pi 3 B+ Raspberry Pi B Raspberry Pi Zero W
1063.24
2658.18
1093.56
3171.32
1066
2984.66
Figure 8: CSProp over TLS — Energy Consumption
Again, these numbers include the energy consumed across
the full handshake, with long periods of time taken up for
network communication in which the energy consumed is not
affected by CSProp.
We note that the less resources the embedded device has,
the larger the advantage from CSProp. We conjecture that
this occurs since deeply embedded devices are likely not to
have energy saving features such as Dynamic Voltage and
Frequency Scaling (DVFS) [88], which can help optimize
energy efﬁciency.
5.4 Comparison with Elliptic Curve Cryptog-
raphy (ECC) Cipher Suites
When power and latency are a consideration, Elliptic Curve
Cryptography (ECC) is often considered: it has an approxi-
mate equivalent strength to RSA and, in fact, has some ad-
vantages relative to using RSA. In particular, key sizes are
much shorter: e.g., Elliptic Curve Digital Signature Algorithm
(ECDSA) with curve P-256 (which is the standard curve by
NIST [7]) has a key size of 256 bits, whereas RSA commonly
uses key sizes of 1024 or 2048 bits. Additionally, ECC sig-
natures are much shorter than RSA signatures. However, as
mentioned by RFC 6605 [57], even though signing is signiﬁ-
cantly faster when using ECC than RSA, the opposite is true
for signatures validation (RSA is (cid:39) 5 times faster in some
implementations). For DNSSEC, this is apparently the most
serious challenge when using ECC due to the latency of sig-
nature validation. Interestingly, Rijswijk-Deij et al. [96] show
that even when using the optimized version of OpenSSL by
CloudFlare5 (in which ECDSA and RSA are sped up by a fac-
tor of 8 and 2, respectively), ECDSA is still 6.6 and 3.4 times
slower than 1024-bit RSA and 2048-bit RSA, receptively, in
terms of signatures validation. More importantly, the actual
adoption of ECC by DNSSEC operators is very low [59, 95],
raising concerns in regards to backward compatibility if ECC
were to be proposed for IoT devices.
For TLS, Gupta et al. [53] conducted a study to analyze
the performance of ECC and RSA for SSL (Secure Socket
Layer) on resource constrained devices. Their experiments
show that TLS handshake using RSA outperform ECC. For
completeness, we conducted experimental measurements to
compare ECC with CSProp. In our experiments, we used
ECDHE-ECDSA (Ephemeral Elliptic Curve Difﬁe-Hellman
key agreement with ECDSA signatures) [79] cipher suite with
curve P-256. We run our experiments on three different IoT
devices: Raspberry Pi 3 B+, Raspberry Pi B, and Raspberry
Pi Zero W (see Table 3 for devices speciﬁcations). As shown
in Table 4, TLS handshake using CSProp is faster by a fac-
tor of (cid:39) 2.7x than when using ECC. This will impose an
additional burden on end devices with the increased CPU
load, especially if deployment of ECC-based TLS handshake
accelerates. In 2014, Bos et al. [29] surveyed the adoption
of ECC and found that only 10% of hosts supported ECC-
5https://ripe70.ripe.net/presentations/85-Alg-13-support.pdf
USENIX Association
30th USENIX Security Symposium    619
based TLS. On a larger-scale study, the International Com-
puter Science Institute (ICSI) Certiﬁcate Notary [60] reported
that 11.5% and 2.4% of observed SSL\TLS connections used
ECDHE-ECDSA with curves P-256 and P-384, respectively,
in June/July 2018. We note also that a variety of attacks on
ECC cipher exist [94].
5.5 Performance on Arduino IoT board
Next, we evaluate CSProp on an Arduino MKR WiFi 1010
board, which is a true IoT class system. We were not able
to ﬁnd cryptographic library support to implement the full
integration with DNSSEC and TLS. Since we are particularly
interested in two RSA public-key operations: veriﬁcation for
signature propagation and encryption for ciphertext propaga-
tion, we implement and evaluate the performance for CSProp
and traditional RSA public-key operations for these two op-
erations. The measurements reﬂect the performance of three
different RSA key lengths: 512, 1024, and 2048 bits. The code
size is ≈ 8 KB while the message size (for encryption or veri-
ﬁcation) is 128 Bytes for all test cases. It is also worth noting
that in our implementation we considered basic mathematical
operations (e.g., exponentiation and multiplication) without
using any optimizations (e.g., montgomery multiplication and
optimized squaring as described in [67]). All results are from
50 runs each consisting of 1000 veriﬁcations/encryptions in a
row to eliminate the code launch/startup effects.
Table 5 summarizes the results of the experiments. For
all RSA key sizes, CSProp outperforms the traditional RSA
public-key operations in all scenarios. The results show sub-
stantial differences in latency, power consumption, and mem-
ory footprint; for the same security level, CSProp is clearly
a more efﬁceint alternative for resource-constrained devices.
For instance, the execution time for CSProp-encryption and
CSProp-veriﬁcation is 57 and 61 times faster, respectively,
compared to traditional RSA encryption for all key sizes.
CSProp reduces energy consumption by 36x and 42x for
encryption and veriﬁcation, respectively. Modular exponen-
tiation of CSProp requires little memory (a crucial design
decision in designing lightweight cryptosystems) compared
to a traditional RSA implementation. More importantly, the
results also present interesting ﬁndings when different key
sizes of the same algorithm are compared. The results show
consistent advantage comparing with traditional RSA, mak-
ing PKI cryptography more practical on resource-constrained
environments at all key sizes we considered.
5.6
CSProp can be used to optimize the performance of public
key operations. Intuitively, these operations should be com-
mon in IoT devices: as a client, rather than a server, it is often
verifying signatures of responses from servers. Moreover, as
a producer of data, it is often encrypting data that is sent up-
stream rather than decrypting data. To validate this intuition
and study the prevalence of these operations in IoT devices,
Importance of Public Key Operations
we analyzed the trafﬁc on an IoT device used in a home envi-
ronment. Our testbed consists of Wyze Cam V2 (an Amazon
choice smart home camera [4]) connected to a wireless home
network via an Arris router [15]. The wireless network uses
WPA2-AES-128-bit protocol [70] (know as WPA2-Personal)
for encryption and a Pre Shared Key (e.g., an 8-character
password) for authentication. Our client is a Wyze app down-
loaded to an iPhone X running iOS 13.3.1. Our results show
that the camera uses cryptographic operations continuously.
Table 6 shows a trace of collected packets obtained during a
live-streaming event for a period of 2-hours, which included
more than 60K (i.e., ≈ 4.2% of packets exchanges) of RSA
public-key operations. Almost exclusively, all operations are
public key operations. Although this percentage is small, these
operations are substantially more expensive than symmetric
key operations and therefore account for a much larger share
of the computational power and energy consumed to support.
According to benchmarking numbers reported by the eBACS
project [2, 3], RSA encryption (a public key operation) re-
quires 2-3 orders of magnitude more time compared to AES
encryption; making public key operations cost dominate.
Furthermore, to support end-to-end data protection, we
found that transmitted data packets between the camera and
the app were frequently encrypted and decrypted using the
AES protocol. However, since it is a WPA2-Personal network,
this setting secures the network only against outsiders. In
particular, this network is vulnerable to Man-in-the-Middle
(MitM) attacks if an adversary is an insider who already
knows the PSK key. Consequently, she would be able to derive
the same secret keys —i.e., Paiwise Transient Key (PTK) and
Group Temporal Key (GTK) used to encrypt/decrypt unicast
and multicast data packets, respectively, between clients and
their associated access point (AP)—that are shared among
all users and generated during the 4-Way Handshake proto-
col [51]6. We found that ≈ 87.5 of data packets are vulnerable
to this type of attack. What is worse, in case Domain Name
System SECurity Extension (DNSSEC) [13] validation is en-
abled, more cryptographic operations are required; increasing
the computational burden on the IoT camera since chains of
DNS RRsets signatures need validation.
6 Related Work
Lightweight cryptography is a term that refers to low
overhead cryptographic algorithms designed for energy- or
computationally-constrained machines, specially in IoT envi-
ronments. This is an active area of research in both academia
and industry [17, 23, 25, 30, 31, 43, 48, 64, 84, 89].
Symmetric Lightweight Cryptography. With few excep-
tions, most lightweight cryptography work focuses on sym-
metric cryptography due to its lower overheads. Lim et al.
6Note that using 802.1X [35] for authentication, which is used in WPA2-
Enterprise networks, closes this vulnerability. This is because each user is
assigned a unique PSK key.
620    30th USENIX Security Symposium
USENIX Association
Table 5: Comparison of CSProp VS. traditional RSA public-key operations. Latency is measured in ms, memory footprint in
bytes, and energy consumption in mJ. Memory usages for SRAM and ROM are summed for total memory footprint.
Encryption
Veriﬁcation
CSProp
Key Size (bits) Latency (ms) Memory Footprint (bytes) EC (mJ) Latency (ms) Memory Footprint (bytes) EC (mJ)
512
1024
2048
11
29
61
42
69
125
Encryption
15
15
35
23
39
71
Traditional RSA
49
82
134
Veriﬁcation
21