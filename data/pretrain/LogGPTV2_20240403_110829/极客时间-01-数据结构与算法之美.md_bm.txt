# 31 \| 深度和广度优先搜索：如何找出社交网络中的三度好友关系？上一节我们讲了图的表示方法，讲到如何用有向图、无向图来表示一个社交网络。在社交网络中，有一个[六度分割理论](https://zh.wikipedia.org/wiki/%E5%85%AD%E5%BA%A6%E5%88%86%E9%9A%94%E7%90%86%E8%AE%BA)，具体是说，你与世界上的另一个人间隔的关系不会超过六度，也就是说平均只需要六步就可以联系到任何两个互不相识的人。一个用户的一度连接用户很好理解，就是他的好友，二度连接用户就是他好友的好友，三度连接用户就是他好友的好友的好友。在社交网络中，我们往往通过用户之间的连接关系，来实现推荐"可能认识的人"这么一个功能。今天的开篇问题就是，**给你一个用户，如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系？]{.orange}**这就要用到今天要讲的深度优先和广度优先搜索算法。
## 什么是"搜索"算法？我们知道，算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于"图"这种数据结构的。这是因为，图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成"图"。图上的搜索算法，最直接的理解就是，在图中找出从一个顶点出发，到另一个顶点的路径。具体方法有很多，比如今天要讲的两种最简单、最"暴力"的深度优先、广度优先搜索，还有A\*、IDA\* 等启发式搜索算法。我们上一节讲过，图有两种主要存储方法，邻接表和邻接矩阵。今天我会用邻接表来存储图。``{=html}我这里先给出图的代码实现。需要说明一下，深度优先搜索算法和广度优先搜索算法，既可以用在无向图，也可以用在有向图上。在今天的讲解中，我都针对无向图来讲解。    public class Graph { // 无向图  private int v; // 顶点的个数  private LinkedList adj[]; // 邻接表   public Graph(int v) {    this.v = v;    adj = new LinkedList[v];    for (int i=0; i();    }  }   public void addEdge(int s, int t) { // 无向图一条边存两次    adj[s].add(t);    adj[t].add(s);  }}
## 广度优先搜索（BFS）广度优先搜索（Breadth-First-Search），我们平常都把简称为BFS。直观地讲，它其实就是一种"地毯式"层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。理解起来并不难，所以我画了一张示意图，你可以看下。![](Images/f2f5c17149586020924ca952e0ed827e.png){savepage-src="https://static001.geekbang.org/resource/image/00/ea/002e9e54fb0d4dbf5462226d946fa1ea.jpg"}尽管广度优先搜索的原理挺简单，但代码实现还是稍微有点复杂度。所以，我们重点讲一下它的代码实现。这里面，bfs() 函数就是基于之前定义的，图的广度优先搜索的代码实现。其中 s表示起始顶点，t 表示终止顶点。我们搜索一条从 s 到 t的路径。实际上，这样求得的路径就是从 s 到 t 的最短路径。    public void bfs(int s, int t) {  if (s == t) return;  boolean[] visited = new boolean[v];  visited[s]=true;  Queue queue = new LinkedList<>();  queue.add(s);  int[] prev = new int[v];  for (int i = 0; i t 的路径  if (prev[t] != -1 && t != s) {    print(prev, s, prev[t]);  }  System.out.print(t + " ");}这段代码不是很好理解，里面有三个重要的辅助变量visited、queue、prev。只要理解这三个变量，读懂这段代码估计就没什么问题了。**visited**是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点q 被访问，那相应的 visited\[q\] 会被设置为 true。**queue**是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。因为广度优先搜索是逐层访问的，也就是说，我们只有把第k 层的顶点都访问完成之后，才能访问第 k+1 层的顶点。当我们访问到第 k层的顶点的时候，我们需要把第 k 层的顶点记录下来，稍后才能通过第 k层的顶点来找第 k+1 层的顶点。所以，我们用这个队列来实现记录的功能。**prev**用来记录搜索路径。当我们从顶点 s 开始，广度优先搜索到顶点 t后，prev数组中存储的就是搜索的路径。不过，这个路径是反向存储的。prev\[w\存储的是，顶点 w 是从哪个前驱顶点遍历过来的。比如，我们通过顶点 2的邻接表访问到顶点 3，那 prev\[3\] 就等于2。为了正向打印出路径，我们需要递归地来打印，你可以看下 print()函数的实现方式。为了方便你理解，我画了一个广度优先搜索的分解图，你可以结合着代码以及我的讲解一块儿看。![](Images/a3614f9b8c589f721f931f3439559781.png){savepage-src="https://static001.geekbang.org/resource/image/4f/3a/4fea8c4505b342cfaf8cb0a93a65503a.jpg"}![](Images/59661be1177b308ea86043f7b6cf1607.png){savepage-src="https://static001.geekbang.org/resource/image/ea/23/ea00f376d445225a304de4531dd82723.jpg"}![](Images/7482714d0d8807809d126fbf5c1131f7.png){savepage-src="https://static001.geekbang.org/resource/image/4c/39/4cd192d4c220cc9ac8049fd3547dba39.jpg"}掌握了广优先搜索算法的原理，我们来看下，广度优先搜索的时间、空间复杂度是多少呢？最坏情况下，终止顶点 t 离起始顶点 s很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是O(V+E)，其中，V 表示顶点的个数，E表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E肯定要大于等于 V-1，所以，广度优先搜索的时间复杂度也可以简写为 O(E)。广度优先搜索的空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是O(V)。
## 深度优先搜索（DFS）深度优先搜索（Depth-First-Search），简称 DFS。最直观的例子就是"走迷宫"。假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。走迷宫的例子很容易能看懂，我们现在再来看下，如何在图中应用深度优先搜索，来找某个顶点到另一个顶点的路径。你可以看我画的这幅图。搜索的起始顶点是 s，终止顶点是t，我们希望在图中寻找一条从顶点 s 到顶点 t的路径。如果映射到迷宫那个例子，s 就是你起始所在的位置，t 就是出口。我用深度递归算法，把整个搜索的路径标记出来了。这里面实线箭头表示遍历，虚线箭头表示回退。从图中我们可以看出，深度优先搜索找出来的路径，并不是顶点s 到顶点 t 的最短路径。![](Images/fd8d1d91d4e77746d0ffb9e8b97ee053.png){savepage-src="https://static001.geekbang.org/resource/image/87/85/8778201ce6ff7037c0b3f26b83efba85.jpg"}实际上，深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现。回溯思想我们后面会有专门的一节来讲，我们现在还回到深度优先搜索算法上。我把上面的过程用递归来翻译出来，就是下面这个样子。我们发现，深度优先搜索代码实现也用到了prev、visited 变量以及 print()函数，它们跟广度优先搜索代码实现里的作用是一样的。不过，深度优先搜索代码实现里，有个比较特殊的变量found，它的作用是，当我们已经找到终止顶点 t之后，我们就不再递归地继续查找了。    boolean found = false; // 全局变量或者类成员变量 public void dfs(int s, int t) {  found = false;  boolean[] visited = new boolean[v];  int[] prev = new int[v];  for (int i = 0; i `{=html}在开始讲解这个算法之前，我先定义两个概念，方便我后面讲解。它们分别是**主串**和**模式串**。这俩概念很好理解，我举个例子你就懂了。比方说，我们在字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B就是模式串。我们把主串的长度记作 n，模式串的长度记作m。因为我们是在主串中查找模式串，所以 n\>m。作为最简单、最暴力的字符串匹配算法，BF算法的思想可以用一句话来概括，那就是，**我们在主串中，检查起始位置分别是0、1、2...n-m 且长度为 m 的 n-m+1个子串，看有没有跟模式串匹配的**。我举一个例子给你看看，你应该可以理解得更清楚。![](Images/4770fdfee08bf3a90bf864797f19c1cd.png){savepage-src="https://static001.geekbang.org/resource/image/f3/a2/f36fed972a5bdc75331d59c36eb15aa2.jpg"}从上面的算法思想和例子，我们可以看出，在极端情况下，比如主串是"aaaaa...aaaaaa"（省略号表示有很多重复的字符a），模式串是"aaaaab"。我们每次都比对 m 个字符，要比对 n-m+1次，所以，这种算法的最坏情况时间复杂度是 O(n\*m)。尽管理论上，BF 算法的时间复杂度很高，是O(n\*m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法。为什么这么说呢？原因有两点。第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把m 个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是O(n\*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。第二，朴素字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有bug也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。这也是我们常说的[KISS（Keepit Simple andStupid）设计原则](https://zh.wikipedia.org/wiki/KISS%E5%8E%9F%E5%88%99)。所以，在实际的软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了。
## RK 算法RK 算法的全称叫 Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp的名字来命名的。这个算法理解起来也不是很难。我个人觉得，它其实就是刚刚讲的BF 算法的升级版。我在讲 BF 算法的时候讲过，如果模式串长度为 m，主串长度为n，那在主串中，就会有 n-m+1 个长度为 m 的子串，我们只需要暴力地对比这n-m+1 个子串与模式串，就可以找出主串与模式串匹配的子串。但是，每次检查主串与子串是否匹配，需要依次比对每个字符，所以 BF算法的时间复杂度就比较高，是O(n\*m)。我们对朴素的字符串匹配算法稍加改造，引入哈希算法，时间复杂度立刻就会降低。RK 算法的思路是这样的：我们通过哈希算法对主串中的 n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面我们会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。![](Images/1b3517980e29df4a82f8cd20bcff41d6.png){savepage-src="https://static001.geekbang.org/resource/image/01/ee/015c85a9c2a4adc11236f9a40c6d57ee.jpg"}不过，通过哈希算法计算子串的哈希值的时候，我们需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是，算法整体的效率并没有提高。有没有方法可以提高哈希算法计算子串哈希值的效率呢？这就需要哈希算法设计的非常有技巧了。我们假设要匹配的字符串的字符集中只包含K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K进制数转化成十进制数，作为子串的哈希值。表述起来有点抽象，我举了一个例子，看完你应该就能懂了。比如要处理的字符串只包含 a～z 这 26个小写字母，那我们就用二十六进制来表示一个字符串。我们把 a～z 这 26个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z表示 25。在十进制的表示法中，一个数字的值是通过下面的方式计算出来的。对应到二十六进制，一个包含a 到 z 这 26 个字符的字符串，计算哈希的时候，我们只需要把进位从 10 改成26 就可以。![](Images/b257d369718144c2eab6eb55dc672ede.png){savepage-src="https://static001.geekbang.org/resource/image/d5/04/d5c1cb11d9fc97d0b28513ba7495ab04.jpg"}这个哈希算法你应该看懂了吧？现在，为了方便解释，在下面的讲解中，我假设字符串中只包含a～z 这 26个小写字符，我们用二十六进制来表示一个字符串，对应的哈希值就是二十六进制数转化成十进制的结果。这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系。我这有个个例子，你先找一下规律，再来看我后面的讲解。![](Images/23799a7ae13be4f277882e46e4f89afc.png){savepage-src="https://static001.geekbang.org/resource/image/f9/f5/f99c16f2f899d19935567102c59661f5.jpg"}从这里例子中，我们很容易就能得出这样的规律：相邻两个子串 s\[i-1\] 和s\[i\]（i 表示子串在主串中的起始位置，子串的长度都为m），对应的哈希值计算公式有交集，也就是说，我们可以使用 s\[i-1\的哈希值很快的计算出 s\[i\的哈希值。如果用公式表示的话，就是下面这个样子：![](Images/a1398f7dfd23bd172e65524485aafe7a.png){savepage-src="https://static001.geekbang.org/resource/image/f2/ee/f298f1e5c93b205345b9cd6d9c53fbee.jpg"}不过，这里有一个小细节需要注意，那就是 26\^(m-1)这部分的计算，我们可以通过查表的方法来提高效率。我们事先计算好26\^0、26\^1、26\^2......26\^(m-1)，并且存储在一个长度为 m的数组中，公式中的"次方"就对应数组的下标。当我们需要计算 26 的 x次方的时候，就可以从数组的下标为 x的位置取值，直接使用，省去了计算的时间。![](Images/a925ce0a9c8efd232786f5172d948b3d.png){savepage-src="https://static001.geekbang.org/resource/image/22/2f/224b899c6e82ec54594e2683acc4552f.jpg"}我们开头的时候提过，RK 算法的效率要比 BF算法高，现在，我们就来分析一下，RK 算法的时间复杂度到底是多少呢？整个 RK算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。第一部分，我们前面也分析了，可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是O(n)。模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共需要比较n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 O(n)。所以，RK算法整体的时间复杂度就是 O(n)。这里还有一个问题就是，模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整型数据可以表示的范围，那该如何解决呢？刚刚我们设计的哈希算法是没有散列冲突的，也就是说，一个字符串与一个二十六进制数一一对应，不同的字符串的哈希值肯定不一样。因为我们是基于进制来表示一个字符串的，你可以类比成十进制、十六进制来思考一下。实际上，我们为了能将哈希值落在整型数据范围内，可以牺牲一下，允许哈希冲突。这个时候哈希算法该如何设计呢？哈希算法的设计方法有很多，我举一个例子说明一下。假设字符串中只包含 a～z这 26 个英文字母，那我们每个字母对应一个数字，比如 a 对应 1，b 对应2，以此类推，z 对应26。我们可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。这种哈希算法产生的哈希值的数据范围就相对要小很多了。不过，你也应该发现，这种哈希算法的哈希冲突概率也是挺高的。当然，我只是举了一个最简单的设计方法，还有很多更加优化的方法，比如将每一个字母从小到大对应一个素数，而不是1，2，3......这样的自然数，这样冲突的概率就会降低一些。那现在新的问题来了。之前我们只需要比较一下模式串和子串的哈希值，如果两个值相等，那这个子串就一定可以匹配模式串。但是，当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。实际上，解决方法很简单。当我们发现一个子串的哈希值跟模式串的哈希值相等的时候，我们只需要再对比一下子串和模式串本身就好了。当然，如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身了。所以，哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致RK算法的时间复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成O(n\*m)。但也不要太悲观，一般情况下，冲突不会很多，RK 算法的效率还是比BF 算法高的。
## 解答开篇 & 内容小结今天我们讲了两种字符串匹配算法，BF 算法和 RK 算法。BF算法是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。所以，时间复杂度也比较高，是O(n\*m)，n、m表示主串和模式串的长度。不过，在实际的软件开发中，因为这种算法实现简单，对于处理小规模的字符串匹配很好用。RK 算法是借助哈希算法对 BF算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。所以，理想情况下，RK算法的时间复杂度是 O(n)，跟 BF算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为O(n\*m)。