代码清单 set_non_secure_cookie.php
会话已经开始 
PXPSESID =
此页面被托管在笔者所在企业的主页上，为了防止被恶意使用，这里采取了限定 Cookie 的路径和更改默认会话 ID 名称等方法。
接下来，我们就来体验一下如何使用这个页面窃听不带安全属性的 Cookie。
1. 启动 Fiddler
2. 用户浏览上述页面后，浏览器中就被设置了 Cookie（PXPSESID）
3. 访问恶意网页
4. 在 Fiddler 中能看到恶意网站发送的请求中附带了 Cookie 信息
下面我们来讲解具体的流程。在 http://example.jp/48/
 的菜单（下记为“/48/ 菜单”）中点击“1.HTTPS 中设置 Cookie（无安全属性）”链接，进入设置 Cookie 的页面。如图 4-72 所示。
图 4-72 设置 Cookie 的页面
此时，浏览器中就被设置了不带安全属性的 Cookie。
接着返回到 /48/ 菜单，点击“2.48-900: 浏览恶意网站”链接。也可以直接输入 URL http://trap.example.com/48/48-900.html
 进入。此页面上有一个看不见的图像（高度和宽度都设置为 0），它的引用地址为 http://www.hash-c.co.jp:443/wasbook/
 。下面是 HTML 代码。
恶意网页
URL 中的端口号 443 是 HTTPS 的默认端口，但由于指定的协议为 http:，因此该请求在被发送时并没有进行加密。另外，虽然此 URL 指定的目标中不存在图像，但由于目的是让浏览器发送 Cookie，所以就算没有图像，攻击也照样能成功。
浏览恶意网页后，Fiddler 会弹出警告（下图），这里不用管它直接点击 OK 按钮 49
 。
49
 使用 Wireshark 确认数据包后，Host 消息头中的端口号（:443）设置没有问题，因此该警告或许是 Fiddler 的 Bug。
图 4-73 Fiddler 弹出警告后点击 OK 按钮
通过下图就能够查看发向目标网站的 HTTP 消息。
图 4-74 从恶意网站发出的请求中附带了 Cookie
在恶意网站使用 443 端口发送 HTTP 请求（明文）之后，原本应该使用 HTTPS 进行传输的 Cookie 值在未经加密的情况下开始在网络上传输。其情形如下图所示。
图 4-75 针对 Cookie 的安全属性不完善实施攻击
而一旦攻击者成功窃取未经加密的 Cookie 值，就能用它来实施会话劫持。
关于抓包方法的注意点
此处讲述的监听方法中网络传输经过了代理，这与不经过代理时的条件略有不同。
没有经过代理时，浏览器与 Web 服务器直接通信，因此要让浏览器发送请求，就需要指定 Web 服务器上开放的端口。就像上面的试验中指定了端口号 443。
而通信经过代理时，浏览器的所有请求都会先发送到代理服务器。因此，使用身为代理的 Fiddler 观测时，可以发现指定 443 以外的端口号也能够发送请求。具体情形如下图所示。
图 4-76 有代理和无代理时的 HTTP 请求观测
不经过代理的 HTTP 请求无法通过 Fiddler 等代理工具进行观测，观测时可以使用 Wireshark 等嗅探器（抓包软件）。使用嗅探器进行数据包解析的技术方法请参考 Chris Sanders 著的《Wireshark 数据包分析实战》[1]。
安全隐患的产生原因
Cookie 的安全属性设置不完善的直接原因显而易见，就是没有给 Cookie 设置安全属性，以笔者多年来诊断安全隐患的经验来看，不给 Cookie 设置安全属性的主要原因有如下两类。
开发者对安全属性毫不知情
设置安全属性后应用无法运行
经过本书的学习后，相信第一类原因就能够得到解决。因此，下面我们来主要讲述设置安全属性后应用无法运行的情况。
什么样的应用程序不能在 Cookie 中设置安全属性
有些 Web 应用同时使用 HTTP 和 HTTPS，典型例子为电子商务网站。多数电子商务网站中，用户浏览商品页面时使用的是 HTTP 传输，而当用户选择完商品进入支付阶段时使用的则是 HTTPS。图 4-77 即展示了同时使用 HTTP 和 HTTPS 的电子商务网站的页面跳转情况。
图 4-77 同时使用 HTTP 和 HTTPS 的网站的页面跳转
Web 应用中同时使用 HTTP 和 HTTPS 时，为保存会话 ID 的 Cookie 设置安全属性是非常困难的。因为设置了安全属性后，HTTP 传输的页面就无法接收到 Cookie 中的会话 ID，因此也就无法利用会话管理机制。由于使用 HTTP 的网页为了实现购物车等功能也需要利用会话管理机制，因此当前很多使用 HTTPS 的网站都没有设置 Cookie 的安全属性。
这种情况下，使用令牌是一种行之有效的对策。详情会在稍后讲述。
对策
为了解决 Cookie 的安全属性设置不完善这一问题，最直接的对策就是要设置 Cookie 的安全属性。
给保存会话 ID 的 Cookie 设置安全属性的方法
在 PHP 中给保存会话 ID 的 Cookie 设置安全属性，只需在 php.ini 中设置如下。
session.cookie_secure = On
Apache Tomcat 中使用 HTTPS 传输请求时，会自动给保存会话 ID 的 Cookie 设置安全属性。
而使用 ASP.NET 时，则需要如下编辑 web.config 文件。
 检验令牌，确认通过认证。  
为了确认上面的脚本，接下来我们使用以下 URL 来浏览页面。
https://example.jp/48/48-001.php
或者在 /48/ 菜单中点击“3.48-001: 生成令牌（SSL）”链接。这时页面显示如下。
图 4-78 试验环境中即使出现证书错误也依然可以选择继续访问
由于虚拟机中无法附带正规证书，因此便导入了自签名证书，这也是出现上图错误信息的原因。而考虑到是虚拟机环境，因此请选择“继续浏览此网站”。关于自签名证书的风险请参考 7.2.3 节。
图 4-79 校验令牌方式的页面跳转
下面我们就来在 HTTP（非 SSL）中尝试此页面跳转。在 /48/ 菜单中点击“4.48-001: 生成令牌（非 SSL）”链接。结果为，48-001.php 中显示“认证成功”后，48-002.php 中显示了如下错误消息。
图 4-80 非 SSL 状态下无法收到令牌
这是因为，48-001.php 中生成的令牌值被保存到了设置了安全属性的 Cookie 中，因此非 SSL 传输时 48-002.php 就没有收到令牌。也就是说，可以确认安全属性运作正常。
使用令牌能确保安全性的原因
即使没有设置安全属性的会话 ID 被窃听，但只要令牌值设置了安全属性并被加密，HTTPS 页面就不会遭到会话劫持。原因如下。
服务器输出令牌的时机只有一次，即认证成功的时候
令牌在 HTTPS 的页面被生成（服务器→浏览器）
令牌被加密后由浏览器发送出去（浏览器→服务器）
浏览 HTTPS 的页面必须要有令牌
换言之，令牌值在服务器和浏览器之间传输时都进行了可靠的加密，而浏览 HTTPS 页面时需要的令牌值不可能被第三方得知，因此便确保了安全性。
除安全属性外其他属性值需要注意的地方
除了安全属性之外，Cookie 中还有其他会影响安全性的属性。第 3 章中已经介绍了 Cookie 的属性，因此这里将主要介绍保存会话 ID 的 Cookie 的属性。
Domain 属性
Domain 属性的默认状态（即不指定的状态）是最安全的。只有在多台服务器中共享 Cookie 时才需要指定 Domain 属性，而一般来说在多台服务器间共享会话 ID 是没有意义的。
虽然 PHP 中能够指定会话 ID 的 Domain 属性，但是在没有特殊理由的情况下，最好不要指定 Domain 属性。
Path 属性
PHP 的会话 ID 默认生成 path=/ 的属性。一般情况下这种设置不会有问题，而如果要针对每个路径生成不同的会话 ID，则可以指定 Path 属性。
需要注意的是，即使指定了 Path 属性也不会提高安全性。因为 JavaScript 的同源策略是以域名为单位的，而不是以路径为单位。这在 3.2 节中已经做过讲解。
Expires 属性
会话 ID 的 Cookie 通常不指定 Expires 属性，即浏览器被关闭的同时 Cookie 也会被删除。设置 Expires 属性后，关闭浏览器后也照样能维持认证状态。详细的使用方法将在 5.1.4 节中讲述。
HttpOnly 属性
设置了 HttpOnly 属性的 Cookie 无法通过 JavaScript 访问。但由于 JavaScript 访问会话 ID 并没有什么意义，因此建议每次都给 Cookie 加上 HttpOnly 属性。正如 4.3 节中所介绍的那样，HttpOnly 属性有助于减轻跨站脚本攻击造成的损害，但这并不是根本性的防范策略。
PHP 中给会话 ID 的 Cookie 设置 HttpOnly 属性，只需如下编辑 php.ini。
session.cookie_httponly = On
总结
本节讲述了 Cookie 输出的相关问题。其中有两点非常重要的是，原则上仅将 Cookie 用于保存会话 ID，以及使用 HTTP 传输的应用中给 Cookie 设置安全属性。
参考文献
[1] Chris Sanders（著）. 诸葛建伟等（译）（2013）.《Wireshark 数据包分析实战》. 人民邮电出版社
4.9 发送邮件的问题
Web 应用通常使用邮件的方式来向用户进行确认或发送通知。而如果邮件发送功能不完善，就可能会导致开放转发第三方邮件，或者邮件内容被篡改等问题。本节就将讲述邮件发送功能中产生的安全隐患。
4.9.1 发送邮件的问题概要
与发送邮件相关的问题有如下三项。
邮件头注入漏洞
使用 hidden 参数保存收件人信息
邮件服务器的开放转发（参考）
邮件头注入漏洞
邮件头注入是指，通过在邮件消息中的收件人或标题等字段中插入换行符，从而添加新的邮件头字段或篡改邮件正文的攻击手段。招致此类攻击的漏洞即称为邮件头注入漏洞。
邮件头注入漏洞将于 4.9.2 节详细讲述。
使用 hidden 参数保存收件人信息
在一些用来免费发送邮件的表单中，为了便于自定义，有时会将邮件的收件人等信息指定为 hidden 参数（图 4-81）。
图 4-81 将收件人保存在 hidden 参数中的表单
通过将 hidden 参数中的收件人更改为任意的邮箱地址，此类表单就能够被用于发送垃圾邮件。因此，收件人邮箱地址等信息不应该被保存在 hidden 参数中，而是应该硬编码在源代码中，或者被保存在服务器上的安全场所（如文件或数据库等）。