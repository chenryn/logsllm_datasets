# CVE-2018-8631 IE jscript JsArrayFunctionHeapSort 堆溢出漏洞分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
CVE-2018-8631 Microsoft Internet Explorer jscript JsArrayFunctionHeapSort
堆溢出漏洞分析
## 前言
最近IE又爆出一个高危漏洞，根据微软官方描述，该漏洞可以实现远程代码执行，编号CVE-2019-1367。受影响的系统版本包括：Windows
10、Windows 8.1、Windows 7、Windows Server 2012/R2、Windows Server 2008、Windows
Server 2016、Windows Server 2019的IE11版本，Windows Server 2012的IE10版本以及Windows
Server 2008的IE9版本。  
从描述信息来看，该漏洞威力巨大，但目前尚未公开可利用的EXP，给广大用户时间及时更新安全补丁。  
经初步分析，攻击者可利用该漏洞诱使用户访问恶意网页触发漏洞从而获得当前用户的所有权限，进而安装恶意程序，增加、删除、更改或查看数据，可造成业务瘫痪、敏感数据泄漏等。  
漏洞详细信息及修复地址为：  
本着温旧知新的态度，找到了一个2018年的IE漏洞，简单分析一下，等新漏洞的EXP出来就可以分析新的了。
## 漏洞简述
CVE-2018-8631，微软IE浏览器的一个jscript解析错误导致堆溢出的一个漏洞，利用难度低，危害大，而且影响面广，值得关注。  
官方给出的描述：  
Microsoft Internet Explorer中存在一个堆缓冲区溢出漏洞。 此漏洞是由于在处理HTML和脚本代码时处理某些对象时出错。  
远程攻击者可以通过诱使目标用户打开特制的网页或文档来利用此漏洞。 在最坏的情况下，成功的利用可能在目标用户的安全上下文中导致任意代码执行。
## 漏洞影响软件版本及系统
IE浏览器：
  * Microsoft Internet Explorer 9
  * Microsoft Internet Explorer 10
  * Microsoft Internet Explorer 11
操作系统：
  * Microsoft Windows 7
  * Microsoft Windows 8.1
  * Microsoft Windows RT 8.1
  * Microsoft Windows 10
  * Microsoft Windows Server 2008
  * Microsoft Windows Server 2008 R2
  * Microsoft Windows Server 2012
  * Microsoft Windows Server 2012 R2
  * Microsoft Windows Server 2016
  * Microsoft Windows Server 2019
基本是通杀了当下流行的所有系统版本。
## 信息搜集
漏洞触发文件：jscript.dll动态连接库文件
漏洞触发函数：jscript!JsArrayFunctionHeapSort
漏洞触发数据对象：一个基于堆的缓冲区
## 漏洞分析
###  知识背景
Microsoft Internet
Explorer（IE）是一个Web浏览器应用程序，能够呈现静态和动态Web内容，例如显示HTML页面，下载文件，解析各种图像格式，运行不同类型的多媒体内容以及使用各种插件打开不同的文件格式。IE包含对脚本语言JavaScript（可用于与DOM交互）的支持。  
文档对象模型（DOM）是一种跨平台，独立于语言的约定，用于表示HTML，XHTML和XML文档中的对象并与之交互。可以根据用于操作DOM的对象的语法和规则来指定和寻址DOM下的对象。在DOM应用程序API中指定了用于编程和与DOM交互的规则。可以在IE中使用JavaScript来访问和修改网页的基础DOM。
HTML，CSS和“编写” DOM的功能一起构成了动态HTML（DHTML）。  
在JavaScript中，函数是一流的对象，因为它们可以像其他任何对象一样具有属性和方法。它们与其他对象的区别在于可以调用/调用功能。函数声明的示例如下：
    x = function myFunc(theObject) {
      theObject.brand = "Toyota";
    }
Function.prototype属性表示Function原型对象[1]。 所有JavaScript对象都从原型继承属性和方法。
Function.prototype的属性包括Function.prototype.arguments，Function.prototype.caller，Function.prototype.length，Function.prototype.name和Function.prototype.constructor。  
函数调用可以通过多种方式来完成[2]。 如果函数调用前面带有new关键字，则它是构造函数调用。
看起来是创建了一个新函数，但是由于JavaScript函数是对象，因此实际上是创建了一个新对象：
    function myFunction(arg1, arg2) {
      this.firstName = arg1;
      this.lastName  = arg2;
    }
    var x = new myFunction("John", "Doe");
函数的call()方法使用给定的值和参数调用该函数：
    func.call(obj, arg1, arg2); //effectively does obj.func(arg1, arg2)
    func.call(null, arg1, arg2); //effectively does func(arg1, arg2)
apply()方法类似于call()方法，不同之处在于，参数是以数组格式提供[3]：
    func.apply(obj, [arg1, arg2]); //effectively does obj.func(arg1, arg2)
    func.apply(null, [arg1, arg2]); //effectively does func(arg1, arg2)
Array对象用于将多个值存储在单个变量中，例如：
    var cars = ["Saab", "Volvo", "BMW"];
数组对象实现了许多可以在数组上调用的方法，包括sort()方法[4]。 sort()方法对数组中的元素进行适当排序并返回该数组。
默认的排序顺序是基于将元素转换为字符串，然后比较其UTF-16代码单元值的序列而建立的。 sort()方法的语法如下：
    arr.sort([compareFunction])
其中compareFunction参数指定一个定义排序顺序的函数。
如果省略，则根据每个字符的Unicode代码点值，以及每个元素的字符串转换，对数组进行排序。  
arguments是函数内部可访问的类似数组的对象，其中包含传递给该函数[5]的参数的值，例如：
    function func1(a, b, c) {
      console.log(arguments[0]);
      // expected output: 1
      console.log(arguments[1]);
      // expected output: 2
    }
    func1(1, 2);
###  漏洞复现
我们首先构造一个受害主机，此处使用Windows7 x64 sp1，然后IE版本为  
IE8。然后直接使用浏览器打开我们的POC，发现浏览器直接崩溃。（对于POC的分析和模拟攻击后续会介绍）
这里需要注意，在使用IE打开poc时，会提示是否启用ActiveX。
一般情况下对于安全性未知的控件是不要打开的。但根据实际情况，大部分人是直接无视该提示，直接选择启用。
在启用ActiveX控件后，IE直接崩溃：
###  漏洞分析
Microsoft Internet
Explorer的Javascript引擎中存在一个堆缓冲区溢出漏洞。处理具有以下特征的JavaScript代码时，将发生此漏洞：
  1. 定义了函数A，该函数利用apply()或call()方法调用sort()方法，并提供“compare”函数作为sort()方法的输入。
  2. 函数A的原型设置为另一个函数B中的arguments对象。
  3. 使用功能B中的“new”关键字来调用功能A。
  4. 函数被调用时带有2个或3个参数。
在这种情况下，将在jscript!JsArrayFunctionHeapSort函数中分配基于堆的缓冲区，其中缓冲区的大小将基于输入数组中元素的数量。如果将函数A原型分配给函数B的arguments对象，则将在jscript！JsArrayFunctionHeapSort函数中输入一个循环，其中将该arguments对象的属性复制到先前分配的基于堆的缓冲区中。如果使用2或3个参数调用功能B，则进入循环。  
在循环中，由于输入数组和参数对象的属性数量不匹配，指向分配缓冲区的指针将越界移动，并且在jscript!NameTbl::GetValCore中发生越界写入，导致堆缓冲区溢出。  
远程攻击者可以通过诱使目标用户打开特制的网页来利用此漏洞。成功的利用可能导致攻击者在受害用户的安全上下文中执行任意代码，危险性很大。