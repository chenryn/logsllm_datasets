(i=0; ii<3; i++) {
for
为预取数据而修改的代码
for
 (j=0; j<6: j+=2)
第11章
在
口
C1
---
## Page 585
并行性和局部性优化
?
好的高速缓存利用率。
每个循环分成两个循环。这么做的好处是一个多维数组被一条一条地访问，从而得到最
条状挖掘。和分块技术类似，这个技术只把一个循环嵌套结构中的--部分循环分解开，
提高了程序的局部性，使处理单个块时需要的数据都在高速缓存中。
点在于可以使得我们在一个多维数组的小段(块)上进行计算，每次处理一个块。这么做
分块。这个技术把一个循环嵌套结构中的每个循环都分割成为两个循环。这个技术的优
表达时间分划约束的线性不等式公式替换成为它的对偶系统。
访问的给定循环嵌套结构所允许的所有仿射时间分划映射。这个技术实质上是把原来的
求解时间分划约束。Farkas 引理提供了一个有力的求解技术。它可以找出一个带有数组
访问所分配到的流水线阶段不得晚于第二个访问所分配的流水线阶段。
说只要两个数组访问会触及同一个数组元素，那么在此流水线中，首先发生的迭代中的
时间分划约束。为了找到流水线化的机会，我们要求出时间分划约束的解。这些约束是
所访问数据的局部性。
流水线化。这个并行化技术允许处理器共享数据，方法是把某些数据(通常是数组元素）
个循环之间的同步运算可以使得各个循环被单独并行化。
多的并行性。比如，相邻的两个循环嵌套结构之间可能具有数据依赖关系，但是在这两
并行运算的同步。有时，如果我们在一个程序的步骤之间插入同步运算，就可以获得更
环使得迭代空间中的扫描线不再和某个坐标轴同向）。
标乘以--个常量)、反置(倒转-个循环的下标)、交换(交换循环的顺序）和倾斜(改写循
们
基本代码转换。用来并行化具有仿射数组访问的程序的转换是七个基本转换的组合，它
就可以把这个问题用矩阵－向量的方式表示出来。
么它们必须被映射到同一个处理器上。只要这个从迭代到处理器的映射是仿射的，我们
如果不同迭代中的两个访问之间具有数据依赖关系（即它们访问了同一个数据元素），那
映射到一个处理器空间。这个处理器空间可能具有一个或多个维度。空间分划约束是说
空间分划约束。为了并行化一个循环嵌套结构的执行过程，我们需要把这个循环的迭代
最大公约数能够整除常量项时，方程才可能存在整数解。
解丢番图线性方程。关键技术是计算各个变量的系数的最大公约数（GCD)。只有当这个
否存在数据依赖关系，我们必须求一个丢番图方程（只要整数解)的解。
过某些元素。比如，一个访问读写偶数号元素，另一个访问读写奇数号元素。为了确定是
--区域，我们并不能判定它们是否真的访问了某个公共元素。原因是每个访问都可能跳
数据依赖关系和丢番图方程。如果我们仅仅知道对同一数组的两个访问触及该数组的同
局部性，即单个高速缓存线中的元素被几乎同时访问。
那么删除掉最后(最前)一行后得到的矩阵的秩可以告诉我们这个访问是否具有良好的
循环迭代运行时，数据访问不会两次触及同一个元素。如果数组是按行(列)存放的，
重要信息。如果该矩阵的秩达到最大值(即矩阵的行数和列数的最小值)，那么当这个
矩阵的秩和数据复用。用来描述--个数组访问的矩阵可以给出多个关于该数组访问的
从
多面体中的解。
人一个处理器同步传递到处理器空间中的相邻的处理器。这个方法可以提高每个处理器
是：循环融合、循环裂变、重新索引（给循环下标加上一个常量）、比例变换（将循环下
569
---
## Page 586
使预取数据的开销降到最小，并在整体上提高了性能。
Feautrier[8]提出。本章描述的仿射转换算法基于 Lim 等人的工作[15，14，16］。
映射到空间和时间坐标上。仿射调度方案的概念以及在仿射转换中使用 Farkas 引理首先由
实现在VLSI上的并行算法，心跳阵列要求在并行化的同时最小化通信量。代数技术用于把计算
来为多处理器系统寻找并行性。仿射转换的最原始出处是心跳阵列算法的设计[11]。作为直接
优化技术。
和 Lam[27]使用线性代数技术来计算循环中的数据复用。Sarkar 和Gao[24］引人了数组收缩
bert 和 Wolf[12]率先在现代体系结构的高速缓存上对分块技术进行了深人的实验分析。Wolf
Rice 大学的 Kennedy 领导的 PFC 项目[4］和在 IBM 研究院由 Allen 领导的 PTRAN 项目[2］。
行化/向量化项目：在 Illinois Urbana-Champaingn 大学由Kuck 领导的 Parafrase 项目［21］,
合[3]、循环裂变[1]、条状挖掘[17]和循环互换[28]。在当时进行了三个主要的实验性的并
Motzkin 消除算法［7］和 Shostak的算法［25］。
Maydan、Hennessy、Lam[18］和 Pugh 及Wonnacott［23］的工作。这些分析技术使用了Fourier 
的形式，并证明这个问题在实践中可以精确高效地求解。本章描述的数据依赖关系分析基
是否独立：［5，6，26］。Maydan、Hennessy 和Lam［18］把数据依赖关系测试写成了整数线性规
析测试使用启发式规则，通过确定丢番图方程和线性实数不等式系统是否无解来确定一对引用
11.13第11章参考文献
Porterfield 提出了第一个预取数据的编译器算法。Mowry、Lam 和 Gupta[20］应用复用分析来
Lamport[13］首先把循环建模为选代空间，并使用混合规划技术（仿射转换的一个特殊情况
McKellar和Coffman[19］最先讨论了使用分块技术来提高数据局部性的理论。Lam、Roth-
570
在 20 世纪 70 年代和 80 年代早期已经有人利用循环转换来改进向量化和并行化：循环融
Lamport[13］和 Kuck、Muraoka 及 Chen[10］引人了数据依赖分析的概念。早期的数据依赖分
要得到关于多处理器体系结构的详细讨论，读者可参阅 Hennessy 和Patlerson 的教科书[9］。
 of Computer Science, University of Ilinois Urbana-Champaign, 1979.
Banerjee, U., Speedup of Ordinary 
paign, 1976.
Department of Computer Science, University of Ilinois Urbana-Cham-
Banerjee, U., Data Dependence in Ordinary Programs, Master's thesis,
9:4 (1987), pp. 491-542.
 Allen, R. and K. Kennedy, “Automatic translation of Fortran programs to
Prentice-Hall, 1972.
Allen, F. E. and J. Cocke, “A Catalogue of optimizing transformations,
and Distributed Computing 5:5 (1988), pp. 617-640.
 Abu-Sufah, W., D. J. Kuck, and D. H. Lawrie, “On the performance
vector form,'
第11章
，由
划
---
## Page 587
并行性和局部性优化
20. Mowry, T. C., M. S. Lam, and A. Gupta, “Design and evaluation of a com-
6
12.
11.
0
6
8.1
piler algorithm for prefetching,’ Proc. Fifth International Conference on.
McKeller, A. C. and E. G. Coffman, “"The organization of matrices and
tion,” J. ACM 24:1 (1977), pp. 121-145.
(1974), p. 83-93.
Lam, M. S., E. E. Rothberg, and M. E. Wolf, “The cache performance and
Kuck, D., Y. Muraoka, and S. Chen, “On the number of operations
(1992), Pp. 313-348,
I. One-dimensional time, International J. Parallel Programming 21:5
 Feautrier, P., “Some effcient solutions to the affine scheduling problem:
matrix operations in a paged multiprogramming environment," Comm.
exact dependence analysis,"
ming (2001), pp. 103-112.
SIGPL
i0n
201-214.
Lamport, L.,
optimization of blocked algorithms,” Proc. Sicth International Conference
I. S.
1310.
-shs bugoiado pun sabonbuog buzuunbosd uof pioddns joanpoaoty 
.."The parallel execution of DO loops,” Comm. ACM 17:2
Proc. ACM SIGPLAN
I1991Conference on
Proc. 13th
571
---
## Page 588
572
28. Wolfe, M. J., Techniques for Improving the Inherent Parallelism in Pro-
24.
23.
7
21. Padua, D. A. and M. J. Wofe, “Advanced compiler optinziations for
27.1
Illinois Urbana-Chaimpaign, 1978.
Implementation, pp. 30-44.
Wolf, M. E. and M. S. Lam, "A data locality optinizing algorithm,"
Towle, R. A., Control and Data Dependence for Programn Transforma-
ACM, 28:4 (1981), pp. 769-779.
(1991), pPp. 194-205.
transformations,"
 Sarkar, V. and G. Gao, "Optimization of array accesses by collective loop
ence, Rice University, 1989.
Supercomputer Applications, Ph.D. Thesis, Department of Computer Sci-
Porterfeld, A., Software Methods for Improving Cache Performance on
superco1mputers," Comm. ACM, 29:12 (1986), pp. 1184-1201.
test,"
Architectural Support for Programming Languages and Operating Systems
“Eliminating false positives using the omega
C
第11章
---
## Page 589
程序使用了过程参数或函数指针，一般来说，需要到程序运行时刻才能知道调用目标，而且实际
静态地确定。在这种情况下，调用图中的每个调用点都恰好有一条边指向一个过程。但是，如果
位置。
12.1.1调用图
活动记录的序列(或其大纲)。
上下文相关分析在区分程序中的不同“位置”时，它不仅考虑当前的程序点，还考虑当前栈中的
“上下文相关”的思想，即进行数据流分析时需要认识到过程调用的序列是什么。也就是说，当
能直接内联递归的过程，并且即使没有递归，内联转换也可能指数级地增加代码的大小。
程内联方法。
指针或引用的分析有时可以确定这个间接调用的目标。如果目标是唯一的，那么就可以应用过
的目标后才可以应用这个方法。
在替换时需要考虑参数传递和返回值，因此需要进行适当修改。只有当我们知道这个过程调用
个相对简单但有用的技术是过程内联(inline），就是把一个过程调用替换为被调用过程的过程体。
不需要过程间分析，而有些优化不借助过程间分析几乎不会产生有用的信息。
程
执行的。我们把这样的分析称为过程内分析。这些分析保守地假设被调用的过程有可能改变过
BDD)来高效地实现这个算法。
我们描述一个用于指针别名分析的算法，并说明如何使用二分决策图（Binary Decision Diagram,
我们先给出 Datalog 的描述，这种表示方法极大地隐藏了一个高效指针分析技术的复杂性。然后
间分析技术的关键之处。因此本章将用大量篇幅讨论获取程序中的指针别名信息所需要的技术。
程间分析的应用。对于诸如C和Java 这样广泛使用的程序设计语言，指针别名分析是所有过程
12. 1
析的重要性。我们将首先描述过程间分析的常见形式，并解释实现它们的难点。然后将描述过
星可见的所有变量的状态，并且它们还可能产生某种副作用，比如改变此过程可见的任何变量的
即使确定了每个过程调用只有一个调用目标，仍然必须谨慎使用内联转换。一般来说，不可
如果过程是通过一个指针或面向对象编程中常见的过程分发机制间接调用的，那么对程序
很多用诸如C或 Fortran 语言编写的程序直接进行过程调用，因此每个调用的调用目标可以
一个过程间分析处理的是整个程序，它将信息从调用者传送到被调用者，或者反向传送。
 大部分编译器优化技术，包括那些在第9、10、11章中描述的技术，都是每次在一个过程中
3）如果调用点c调用了过程p，就存在一条从c的结点到 p的结点的边。
2）对于每个调用点(call site)都有--个结点。所谓调用点就是程序中调用某个过程的--个
1）对程序中的每个过程都有一个结点。
一个程序的调用图(call graph)是一个结点和边的集合，并满足
在本节中，我们将介绍调用图，就是告诉我们哪个过程调用了哪个过程的图。我们也会介绍
在这一章中，我们讨论一些不能使用过程内分析技术解决的优化问题，由此引出了过程间分
基本概念
第12章过程间分析
---
## Page 590
要根据上下文而定。
分别返回常量1和244。因此，在各个上下文中函数f 的实在参数都是常量，但是常量的具体值