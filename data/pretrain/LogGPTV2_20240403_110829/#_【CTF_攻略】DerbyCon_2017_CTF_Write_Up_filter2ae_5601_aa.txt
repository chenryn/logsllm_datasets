# 【CTF 攻略】DerbyCon 2017 CTF Write Up
|
##### 译文声明
本文是翻译文章，文章来源：nettitude.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
译者：[shan66](http://bobao.360.cn/member/contribute?uid=2522399780)
预估稿费：300RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**  
**
**前言**
在本文中，我们将为读者详细介绍我们团队在Derbycon 2017“夺标大赛”中夺魁的具体过程。
**Facespace**
浏览这台机器时，我们发现了一个新的社交媒体应用程序。这时，我们试图创建一个帐户并登录。此外，在页面的左侧可以查看已经创建帐户的用户的个人资料。
于是，我们创建了一个帐户并登录，这时我们被重定向到如下所示的页面。有趣的是，它允许上传tar.gz文件，大家知道tar文件有一些有趣的属性…通过考察该网站，我们发现上传的tar文竟然可以是untar的，并且这些文件将会写入/users/path。
tar的一个更有趣的属性是，默认情况下，它不允许使用符号链接。相反，它会将符号链接添加到归档。为了确保对文件而不是符号链接进行存档，可以使用–h或–dereference标志，具体如下所示。
Symlinks可以指向文件和目录，因此要测试页面是否易受攻击，我们创建了以下归档文件：
**/root目录**
**/etc**
**/root/.ssh中的known_hosts文件**
上传成功，该tar文件被提取了出来。
现在来确定是否有实际可访问的东西。 导航到/ users / zzz / root / etc / passwd，以查看passwd文件。
真棒——我们竟然有访问权限。我们将rcvryusr的哈希值直接插入到哈希表中，不久之后，备份的密码已经返回，现在我们可以通过SSH登录了。
然后，我们花了大量时间尝试在这个Slackware 14.2主机上升级特权。不过主办方告诉我们，在CTF完成之后，没有任何特权升级。
**  
**
**JitBit**
需要说的是，在这次挑战赛的过程中，实际上Rob
Simon发现的是一个0day漏洞！完成比赛后，我们已经就各方进行了磋商，现在Rob决定披露这个漏洞，并且是在完全符合相关流程的情况下披露的。
当然，这个0day是我们事后才确认的。当时，我们导航至.299网站后，被重定向到/KB页面。下面是我们得到该应用程序的供应商和版本号方面的信息。
在获取供应商和版本号后，外面首先尝试找到源代码以及任何版本说明信息。
由于这是一个0day漏洞，自然没有发现与它有关的任何信息。源代码也没有找到，但是可以下载试用版软件。
我们下载了zip文件并将其解压缩，发现它是一个.NET应用程序。既然是.NET，当然要找一个相应的反编译器了，于是选中了来自https://JetBrains.com的dotPeek。当然，除了dotPeek之外，还有许多不同的.NET反编译器，例如dnSpy等，我们建议您可以分别尝试一下，以便找到自己顺手的那一个。
将HelpDesk.dll加载到dotPeek中，单击右键，选中export to
Project选项，就可以从.dll中提取所有的源代码。这样的话，就可以将所有能够提取的源代码都放入指定的文件夹中了。
导出源代码后，我们使用Visual Code Grepper（https://github.com/nccgroup/VCG）快速浏览了一遍：
“我们应该关注那些任何人都能对其进行安全审查的代码，特别是在时间很宝贵的时候”
比赛中，时间绝对是非常宝贵的，所以我们都奔着源代码去了。
虽然我们找到了一些问题，但是在进一步研究之后，发现它们都是假阳性的。
其中LoadXML引起了我们特别的关注，尽管XMLDocument在最新版本的.NET之外的所有版本中都容易受到XXE注入的影响，但是供应商已经正确地使XMLResolver作废，从而缓解了这个威胁。
对源代码进行了深入审查之后，并没有发现真正的漏洞。
之后，我们继续审查应用程序附带的所有其他文件。是的，我们同意我们应该首先阅读自述文件，但当时已经到了深夜了！
无论如何，都应该先看自述文件。目录中有一些非常有趣的条目。 我们来看看AutoLogin功能。
从文字表明看，它意味着通过创建用户名+ email +共享密钥的MD5哈希值，就可以以该用户身份登录。 那很酷，但共享密钥是什么？
然后，一个tweet引起了我们的兴趣。
我们尝试通过提交问题来注册一个帐户，但没有成功。然后，又一个tweet到了。 也许这里要有事情发生。
所以，我们创建了一个帐户，然后触发该帐户的忘记密码功能，我们收到了这封电子邮件。
有趣——这就是自动登录功能啊。我们确实需要研究一下这个哈希是如何创建的。
此时，我们开始研究如何生成URL，并找到了HelpDesk.BusinessLayer.VariousUtils类中的GetAutoLoginUrl（）函数，其来源如下所示。
如readme文件所述，这就是AutoLogin哈希值得生成方式；通过附加用户名、电子邮件地址以及月和日。但是，这里真正的关键是SharedSecret。这一点，当时我们也是很怀疑，因为获得这个哈希值的唯一方法是通过电子邮件。
下一步是尝试了解这一切的运作方式。 此时，我们启动了Rubber Ducky
Debugging（https://en.wikipedia.org/wiki/Rubber_duck_debugging）。 我们也在本地安装了该软件。
看看我们的本地版本，我们注意到不能在试用版中更改共享密钥。不同的版本，情况是否完全相同呢？
现在，我们也开始意识到之前的一个tweet的含义了。
实际上，前面的KB页面已经泄露了管理员用户的用户名和电子邮件地址。有趣的是，虽然可以从发件人处获取电子邮件地址，但是用户名是admin …
我们尝试使用本地服务器的共享密码构建一个AutoLoginUrl。是的，是时候来找出这个密钥的正确生成方式了。
我们最终发现AutoLoginSharedSecret是使用以下代码初始化的。
这看起来很有前途。虽然此代码生成的共享密钥的长度足够长，但它也产生了一些允许恢复秘密的关键错误。第一个错误是限制了密钥空间；大写A-Z和2-9的空间还不够大。第二个错误是使用Random类：
https://msdn.microsoft.com/en-us/library/system.random(v=vs.110).aspx#Same
这不是随机的，当然供应商想要的是随机的。 如下文所述，通过提供相同的seed将意味着会得到相同的序列。
seed是一个32位有符号整数，很明显这意味着只有2,147,483,647种组合。
为了恢复密钥，可以将下列C＃写入（你猜到了！）LinqPad（https://www.linqpad.net/）。
代码以0的计数器开始，然后将相应的值作为“Random”类的seed来生成每个可能的秘密。
然后，利用用户名、电子邮件、日期和月份求出所有可能的哈希值，看看它是否与从忘记密码电子邮件中恢复的哈希值相匹配。
运行上述代码，就可以爆破出这个密钥了。需要说明的是，在这个阶段，CTF只提供了20分钟左右的时间。 这时，空气中弥漫着略显紧张的气氛。
这可以用于为管理员用户生成哈希值和自动登录链接。我们成功了！
我们在资产部分内拿下了一个flag。 我们提交了该flag，赢得了8000点（连同另一个挑战的得分，巩固了第一名的成绩）。
**海龟**
浏览172.30.1.231 Web服务器上的Web根目录（启用了目录列表功能）时，我们遇到了一个名为jacked.html的文件。
当在浏览器中呈现时，该页面引用了一个名为turtles.png的图像，但是在查看页面时并没有显示。 在页面标题“I Like
Turtles”中倒是有一点线索…我们猜想有人喜欢贝壳（shell）！
当查看页面的客户端的源代码时，我们看到有一个数据uri为turtle.png图像标签，但它看起来很可疑。
使用我们最喜爱的瑞士军队选择的工具，LinqPad（https://www.linqpad.net/——我们保证绝对不是他们的员工！），对数据（即uri字符串）进行Base64解码，我们看到这显然是转义序列。进一步解码为ASCII字符，我们得到了一个很大的线索——看起来很像是shellcode。
换码序列看起来就是x86指令，所以回到LinqPad去运行它。我们建立了一个简单的shellcode运行器，因为我们需要用到它。本质上，它会打开记事本（或您选择的任何其他应用程序）来建立一个进程，然后继续在该进程中分配内存。然后将shellcode写入相应的内存，之后线程被启动，并指向shellcode的顶部。可以在脚本中写入一个中断，以便在记事本启动后，您有时间附加一个调试器。最后两个字节是CD
80，实际上就是Int 80（Linux中的系统调用处理程序中断）。
使用WinDbg附加到该进程，然后进入LinqPad，int
80被触发，在WinDbg中触发了一个访问冲突。然后抓住这个异常，现在让我们来检查一下相关的内存。
一旦运行WinDbg，我们立即发现了一个问题，这里是int
80h而非Linux系统调用处理程序。这显然被设计为在不同的操作系统下运行。哎呀，好吧，让我们看看有什么挽救措施。
重要的一点是，在Linux中进行系统调用时，是通过寄存器将值从用户地址传递到内核。EAX保存系统调用号码，然后EBX，ECX，EDX，ESX和EDI依次存放调用参数。对shellcode进行转换，结果如下图所示。这里使用寄存器的值与本身进行异或运算，以便快速对寄存器进行清零。
    03f50000 xor eax,eax ; zero eax register
    03f50002 xor ebx,ebx ; zero eax register
    03f50004 xor edx,edx ; zero eax register
    03f50006 xor ecx,ecx ; zero eax register
    03f50008 mov al,4 ; Set syscall(ECX) to 4 for sys_write
    03f5000a mov bl,1 ; Set fd(EBX) to 1 for std out
    03f5000c push 0A37h ; push 7n onto stack
    03f50011 push 35634B4Fh ; push Okc5 onto stack
    03f50016 push 4C4F5965h ; push eYOL onto stack
    03f5001b push 646F636Ch ; push lcod onto stack
    03f50020 push 6C656853h ; push Shel onto stack
    03f50025 mov ecx,esp ; set buf(ECX) to top of stack
    03f50027 mov dl,12h ; set length(EDX) to be 12h
    03f50029 int 80h ; sys call
我们在这里看到，立即值4被移动到EAX寄存器的第一个字节（即AL）。这样实际上就是转换为系统调用syswrite。
根据上面的寄存器顺序，这个原型代码和汇编程序将认为EBX的值为1（即标准输出），ECX包含的是堆栈指针，即旗标所在的位置，EDX的值为12h（或18）这对应于字符串的长度。
所以，如果这是在一个Linux操作系统上运行的话，我们将把这个旗标写入控制台，而不是一个访问冲突，但是一切都不会丢失。我们知道堆栈包含了旗标，所以我们需要做的就是检查ESP寄存器（堆栈指针）中存储的内容。在WinDbg中，您可以使用d来转储不同格式的内存，然后使用第二个字母表示格式。例如在下面的截图中，屏幕截图中的第一个命令是dd
esp，它将以DWORD或4字节格式转储内存（默认为32个，返回128个字节的内存）。显示的第二个命令是da
esp，它以ASCII格式开始转储内存，直到它遇到空字符或读取48个字节为止。
**  