percentile from 75.6 s to 12.3 s. We do this by involving more
users than just the original sender in the process of dissem-
inating a message to group members. This also reduces the
asymptotic growth of the expected delay to O(log m). A key
ingredient for this is the deterministic GENSCHEDULE algo-
rithm that allows users to share plans for message distribution
using a single nonce.
Faced with the challenge of unreliable and ofﬂine nodes,
we have introduced a variant of our algorithm that allows
acknowledgement and retry of message delivery as well as
reassignment of tasks from ofﬂine to online users. In the
failure-free case, it adds a constant message overhead that
does not worsen the results measured. When nodes are ofﬂine
it signiﬁcantly improves reliability and delays.
Our simulation tool enabled us to obtain reproducible and
inspectable performance measurements. The low cost of simu-
lation enabled us to efﬁciently explore the behaviour of many
system conﬁgurations with a large number of users.
In future work we plan to implement and run collaborative
applications and group messaging protocols on a network
using Rollercoaster. We also hope to extend Rollercoaster
with facilities to add or remove members of a group.
USENIX Association
30th USENIX Security Symposium    3445
Acknowledgements
We thank Steven J. Murdoch, Killian Davitt, and our anony-
mous reviewers for the helpful discussions and their valu-
able input. Daniel Hugenroth is supported by a Nokia Bell
Labs Scholarship and the Cambridge European Trust. Martin
Kleppmann is supported by a Leverhulme Trust Early Ca-
reer Fellowship, the Isaac Newton Trust, Nokia Bell Labs,
and crowdfunding supporters including Ably, Adrià Arcarons,
Chet Corcos, Macrometa, Mintter, David Pollak, RelationalAI,
SoftwareMill, Talent Formation Network, and Adam Wiggins.
Alastair R. Beresford is partially supported by EPSRC [grant
number EP/M020320/1].
References
[1] R. Dingledine, N. Mathewson, and P. Syverson, “Tor:
The second-generation onion router,” tech. rep., Naval
Research Lab Washington DC, 2004.
[9] J. Huang, F. Qian, A. Gerber, Z. M. Mao, S. Sen, and
O. Spatscheck, “A close examination of performance
and power characteristics of 4G LTE networks,” in 10th
International Conference on Mobile Systems, Applica-
tions, and Services, pp. 225–238, 2012.
[10] D. Chaum, “Untraceable electronic mail, return ad-
dresses, and digital pseudonyms,” Communications of
the ACM, vol. 24, no. 2, 1981.
[11] G. Danezis and I. Goldberg, “Sphinx: A compact and
provably secure mix format,” in 30th IEEE Symposium
on Security and Privacy, pp. 269–282, IEEE, 2009.
[12] A. Serjantov, R. Dingledine, and P. Syverson, “From a
trickle to a ﬂood: Active attacks on several mix types,” in
International Workshop on Information Hiding, pp. 36–
52, Springer, 2002.
[13] S. Deering, “Host extensions for IP multicasting,”
http://www.
STD 5, RFC Editor, August 1989.
rfc-editor.org/rfc/rfc1112.txt.
[2] S. J. Murdoch and G. Danezis, “Low-cost trafﬁc analy-
sis of Tor,” in 2005 IEEE Symposium on Security and
Privacy, pp. 183–195, IEEE, 2005.
[14] M. Kleppmann and H. Howard, “Byzantine eventual
consistency and the fundamental limits of peer-to-peer
databases,” arXiv preprint arXiv:2012.00472, 2020.
[3] A. M. Piotrowska, J. Hayes, T. Elahi, S. Meiser, and
G. Danezis, “The Loopix anonymity system,” in 26th
USENIX Security Symposium, pp. 1199–1216, 2017.
[4] M. Kleppmann, S. A. Kollmann, D. A. Vasile, and A. R.
Beresford, “From secure messaging to secure collab-
oration,” in 26th International Workshop on Security
Protocols, pp. 179–185, Springer, 2018.
[5] M. Ahmed-Nacer, C.-L. Ignat, G. Oster, H.-G. Roh, and
P. Urso, “Evaluating CRDTs for real-time document
editing,” in 11th ACM Symposium on Document Engi-
neering, pp. 103–112, ACM, Sept. 2011.
[6] A. Pﬁtzmann and M. Hansen, “A terminology
for talking about privacy by data minimization:
Anonymity, unlinkability, undetectability, unobservabil-
ity, pseudonymity, and identity management,” Aug.
2010.
v0.34, http://dud.inf.tu-dresden.de/
literatur/Anon_Terminology_v0.34.pdf.
[7] C.-L. Ignat, G. Oster, O. Fox, V. L. Shalin, and F. Charoy,
“How do user groups cope with delay in real-time collab-
orative note taking,” in 14th European Conference on
Computer Supported Cooperative Work, pp. 223–242,
Springer, Sept. 2015.
[15] F. Beato, K. Halunen, and B. Mennink, “Improving
the Sphinx mix network,” in International Conference
on Cryptology and Network Security, pp. 681–691,
Springer, 2016.
[16] C. Kuhn, M. Beck, and T. Strufe, “Breaking and (par-
tially) ﬁxing provably secure onion routing,” arXiv
preprint arXiv:1910.13772, 2019.
[17] D. T. Wagner, A. Rice, and A. R. Beresford, “Device
analyzer: Understanding smartphone usage,” in Inter-
national Conference on Mobile and Ubiquitous Sys-
tems: Computing, Networking, and Services, pp. 195–
208, Springer, 2013.
[18] D. Chaum, “Security without identiﬁcation: Transaction
systems to make Big Brother obsolete,” Communica-
tions of the ACM, vol. 28, no. 10, pp. 1030–1044, 1985.
[19] S. Dolev and R. Ostrobsky, “Xor-trees for efﬁcient
anonymous multicast and reception,” ACM Transactions
on Information and System Security, vol. 3, no. 2, pp. 63–
84, 2000.
[20] D. I. Wolinsky, H. Corrigan-Gibbs, B. Ford, and A. John-
son, “Dissent in numbers: Making strong anonymity
scale,” in 10th USENIX Symposium on Operating Sys-
tems Design and Implementation, pp. 179–182, 2012.
[8] J. Nielsen, “The 90-9-1 rule for participation in-
equality in social media and online communi-
ties,” 2006. https://www.nngroup.com/articles/
participation-inequality/.
[21] G. Danezis and A. Serjantov, “Statistical disclosure or
intersection attacks on anonymity systems,” in Interna-
tional Workshop on Information Hiding, pp. 293–308,
Springer, 2004.
3446    30th USENIX Security Symposium
USENIX Association
[22] A. Mislove, G. Oberoi, A. Post, C. Reis, P. Druschel, and
D. S. Wallach, “AP3: Cooperative, decentralized anony-
mous communication,” in 11th ACM SIGOPS European
workshop, p. 30, ACM, 2004.
[23] G. Perng, M. K. Reiter, and C. Wang, “M2: Multicast-
ing mixes for efﬁcient and anonymous communication,”
in 26th IEEE International Conference on Distributed
Computing Systems, pp. 59–59, IEEE, 2006.
[24] D. Lin, M. Sherr, and B. T. Loo, “Scalable and anony-
mous group communication with MTor,” Proceedings
on Privacy Enhancing Technologies, vol. 2016, no. 2,
pp. 22–39, 2016.
[25] S. Roos, M. Beck, and T. Strufe, “Anonymous addresses
for efﬁcient and resilient routing in F2F overlays,” in
35th Annual IEEE International Conference on Com-
puter Communications, pp. 1–9, IEEE, 2016.
[26] S. Roos, M. Beck, and T. Strufe, “Voute-virtual
overlays using tree embeddings,” arXiv preprint
arXiv:1601.06119, 2016.
[27] J. Van Den Hooff, D. Lazar, M. Zaharia, and N. Zel-
dovich, “Vuvuzela: Scalable private messaging resistant
to trafﬁc analysis,” in 25th Symposium on Operating
Systems Principles, pp. 137–152, 2015.
[28] S. Angel and S. Setty, “Unobservable communication
over fully untrusted infrastructure,” in 12th USENIX
Symposium on Operating Systems Design and Imple-
mentation, pp. 551–569, 2016.
[29] R. Cheng, W. Scott, E. Masserova, I. Zhang, V. Goyal,
T. Anderson, A. Krishnamurthy, and B. Parno, “Talek:
Private group messaging with hidden access patterns,”
arXiv preprint arXiv:2001.08250, 2020.
[30] R. Jansen and N. Hopper, “Shadow: Running Tor in a
box for accurate and efﬁcient experimentation,” in 19th
Symposium on Network and Distributed System Security,
Internet Society, February 2012.
[31] I. B. Guirat, D. Gosain, and C. Diaz, “Mixim: A gen-
eral purpose simulator for mixnet,” Privacy Enhancing
Technologies Symposium – HotPETs Workshop, 2020.
[32] M. Hosseini, D. T. Ahmed, S. Shirmohammadi, and
N. D. Georganas, “A survey of application-layer multi-
cast protocols,” IEEE Communications Surveys & Tuto-
rials, vol. 9, no. 3, pp. 58–74, 2007.
[33] A. Popescu, D. Constantinescu, D. Erman, and D. Ilie,
“A survey of reliable multicast communication,” in Con-
ference on Next Generation Internet Networks, NGI,
pp. 111–118, IEEE, 2007.
[34] C. K. Yeo, B.-S. Lee, and M. H. Er, “A survey of appli-
cation level multicast techniques,” Computer Communi-
cations, vol. 27, no. 15, pp. 1547–1568, 2004.
[35] J. Leitão, J. Pereira, and L. Rodrigues, “Epidemic broad-
cast trees,” in 26th IEEE International Symposium on
Reliable Distributed Systems, SRDS 2007, pp. 301–310,
IEEE, Oct. 2007.
[36] J. Leitão, J. Pereira, and L. Rodrigues, “Gossip-based
broadcast,” in Handbook of Peer-to-Peer Networking,
pp. 831–860, Springer, Oct. 2009.
A MultiSphinx Construction
In this Appendix we provide detailed algorithms for con-
structing and processing both the regular Sphinx messages
(A.1) and our MultiSphinx messages (A.2). The regular con-
struction is based on the original Sphinx paper [11] and the
proposed improvement using authenticated encryption [15].
For both schemes we will use three hops n0, n1, n2 for the mix
nodes and a ﬁnal hop n for the recipient3 that extracts the
payload from the inner-most encryption (see Figure 10).
A Sphinx header M consists of a group element α for deriv-
ing shared secrets, authenticated data β, and an authentication
tag γ. In the original Sphinx paper β is used to store the ad-
dress of the next hop. For the ﬁnal hop the distinguished
element ∗ is used to signal that the payload reached its in-
tended destination. Loopix adds per-hop delays to this routing
information.
We assume that all nodes ni have access to the public keys
of all other nodes without us passing these explicitly. We
assume the existence of a method PROCESSHEADER that
takes a header of a Sphinx packet and returns all metadata
contained in β (next hop identiﬁer, delay) and the header for
the next hop. We assume the existence of a method COM-
PUTESECRETS that takes a list of hops n0, n1, . . . and outputs
3We omit the provider nodes here to improve readability.
s
s
REGULAR SPHINX
(M0, δ0)
(M1, δ1)
(M2, δ2)
(M3, δ3)
δ
n
n2
n1
n0
p-RESTRICTED MULTISPHINX (p = 2)
(M0, δ0)
(M1, δ1)
n0
)
2 , A
, δ
( M 2 , A
n1
(M
2,B,δ
2,B)
n2,A
(M3,A , δ3,A )
δA
nA
n2,B
(M3,B , δ3,B )
δB
nB
(M1,A, δ1,A )
(M1,B, δ1,B )
∗
∗
∗
Figure 10: Schematic of messages (header, payload) for
Sphinx and MultiSphinx.
USENIX Association
30th USENIX Security Symposium    3447
a list of shared secrets s0, s1, . . . . We assume the existence
of a method CREATEHEADER that takes a shared secret si,
the next hop identiﬁer ni+1, and (optionally) a header Mi+1
to wrap. The details of these operations can be found in the
Sphinx paper [11, §3.2 and §3.6]. In line with Loopix the
sender chooses a random per-hop delay for each hop and in-
cludes it in the authenticated metadata in the header. This
happens transparently in the CREATEHEADER method.
We assume the existence of an authenticated encryption
(AE) scheme as required by the improved Sphinx format [15].
An AE scheme provides an encryption function AEenc that
takes a secret key s, a message msg, and optional metadata
meta and outputs a ciphertext ctext and an authentication
tag auth. It also provides a decryption function AEdec that
takes a secret key s, a ciphertext ctext, an authentication tag
auth, and metadata meta. It returns the decrypted message if
the authentication tag veriﬁes the integrity of ciphertext and
metadata or ⊥ otherwise.
We assume that the AE scheme is based on an encrypt-
then-mac regime using a stream cipher C (e.g. AES-CTR),
a message authentication code MAC (e.g. HMAC), and a
keyed key derivation function KDF (e.g. HKDF). Stream
ciphers have the property that changing a given bit of the
ciphertext/plaintext only changes the bit at the same position
in the plaintext/ciphertext after decryption/encryption. Arbi-
trary changes will lead to an invalid auth tag – but we might
intentionally ignore this during our constructions and recal-
culate the auth tags later. Since Sphinx uses fresh secret keys
for every message and hop, we can leave the nonce for the
stream cipher constant. We show our construction of AEenc
and AEdec in Algorithm 3.
Algorithm 3 The authenticated encryption scheme AE based
on stream cipher C, a MAC, and a keyed KDF.
1: procedure AEenc(s, msg, meta)
2:
scipher, smac ← KDF(s, cipher), KDF(s, mac)
ctext ← C(scipher) ⊕ msg
auth ← MAC(smac, ctext k meta)
return (ctext, auth)
6:
7: procedure AEdec(s, ctext, auth, meta)
8:
scipher, smac ← KDF(s, cipher), KDF(s, mac)
if MAC(smac, ctext k meta) 6= auth then
return ⊥
msg ← C(scipher) ⊕ ctext
return msg
3:
4:
5:
9:
10:
11:
12:
A.1 Normal Sphinx (existing solution)
The algorithms in this section summarise the existing liter-
ature [11, 15], but we have adapted the notation to be more
concise. Algorithm 4 shows the creation of the a regular
Sphinx message by the sender. While the original Sphinx pa-
pers can create all headers before encrypting the payload, the
improved variant with AE requires us to do these operations
simultaneously as the encryption affects the authentication
tag γ of this and the following message headers.
Algorithm 4 Creating a packet to be routed through hops
n0, n1, n2 to node n.
1: procedure CREATE(δ, n0, n1, n2, n)
2:
assert|δ| = MAXMSGLEN
s0, s1, s2, s3 ← COMPUTESECRETS(n0, n1, n2, n)
M3 ← CREATEHEADER(s3, ∗)
δ3, M3.γ ← AEenc(s3, δ, M3.β)
M2 ← CREATEHEADER(s2, n, M3)
δ2, M2.γ ← AEenc(s2, δ3, M2.β)
M1 ← CREATEHEADER(s1, n2, M2)
δ1, M1.γ ← AEenc(s1, δ2, M1.β)
M0 ← CREATEHEADER(s0, n1, M1)
δ0, M0.γ ← AEenc(s0, δ1, M0.β)
return (M0, δ0)
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
Algorithm 5 shows how a mix node processes a message it
has received. First the message is unpacked into the header
and the payload. Then the tag is derived and compared against
previously seen tags to protect against replay attacks. Af-
terwards, the decryption veriﬁes that the authentication tag
matches the message and header metadata. Finally the header