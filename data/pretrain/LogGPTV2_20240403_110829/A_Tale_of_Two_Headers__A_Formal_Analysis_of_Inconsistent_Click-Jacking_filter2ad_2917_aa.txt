# A Tale of Two Headers: A Formal Analysis of Inconsistent Click-Jacking Protection on the Web

**Authors:**
- Stefano Calzavara, Università Ca’ Foscari Venezia
- Sebastian Roth, CISPA Helmholtz Center for Information Security and Saarbrücken Graduate School of Computer Science
- Alvise Rabitti, Università Ca’ Foscari Venezia
- Michael Backes, CISPA Helmholtz Center for Information Security
- Ben Stock, CISPA Helmholtz Center for Information Security

**Publication:**
Proceedings of the 29th USENIX Security Symposium, August 12–14, 2020. Open access sponsored by USENIX.
[Link to the paper](https://www.usenix.org/conference/usenixsecurity20/presentation/calzavara)

## Abstract
Click-jacking protection on the modern web is commonly enforced via client-side security mechanisms for framing control, such as the X-Frame-Options (XFO) header and Content Security Policy (CSP). Although these mechanisms are useful and successful, delegating protection to web browsers can lead to inconsistencies in the security guarantees offered to users of different browsers. These inconsistencies may arise due to the lack of support for CSP and the varying implementations of the underspecified XFO header.

In this paper, we formally study the problem of inconsistencies in framing control policies across different browsers and implement an automated policy analyzer based on our theory. Our analysis reveals that 10% of distinct framing control policies in the wild are inconsistent, often failing to provide any level of protection for at least one browser. We propose recommendations for web developers and browser vendors to mitigate this issue. Additionally, we design and implement a server-side proxy to retrofit security in web applications.

## 1. Introduction
The web is the largest distributed system in the world, characterized by incredible variety and complexity. Unfortunately, complexity is where attackers thrive. To assist developers in securing their applications, the web platform has evolved to support more and more server-sent, yet client-enforced security mechanisms. This approach offers uniform and well-thought-out defenses to as many web developers as possible. Examples of popular client-side security mechanisms include Content Security Policy (CSP), cookie security attributes, and HTTP Strict Transport Security (HSTS).

Although client-side security mechanisms are undoubtedly useful and successful, delegating protection to web browsers can introduce inconsistencies in the security guarantees offered to users of different browsers. The most obvious case is when legacy browsers access web applications, but problems can also arise when the same defense is implemented differently across modern browsers. In this paper, we focus on inconsistencies in framing control, a critical aspect of web application security that pioneered the adoption of client-side security mechanisms.

Framing control restricts the inclusion of web content inside iframes (sub-documents) opened by malicious pages, which is particularly useful in preventing click-jacking attacks. The original defense against click-jacking was the use of JavaScript-based frame busters. These scripts, placed in pages where framing should be forbidden, checked conditions like `self == top` to determine if they were loaded in the top-most frame. If not, they would navigate the top frame away. However, researchers showed that this solution was often ineffective. In 2009, Internet Explorer introduced the X-Frame-Options (XFO) header as a simple, browser-based mechanism to control framing without relying on JavaScript. This header gained extensive popularity and was quickly adopted by other major browsers. Unfortunately, since XFO was not standardized a priori, different browser vendors provided different implementations, leading to differing support of its directives and attacks like double framing in some browsers. In 2014, the second iteration of the CSP specification introduced the `frame-ancestors` directive to control framing, with the goal of obsoleting XFO and offering a comprehensive, uniform protection mechanism for all CSP-compliant browsers.

Given the evolution of the web platform, the state of click-jacking protection on the web is fragile. Most browsers provide two different defenses in the form of XFO and CSP, possibly with different implementations, and developers may choose to use either or both to protect their web applications. This complexity and the diverse levels of support for framing control can give rise to inconsistencies. In this paper, we conduct a comprehensive study of the differing behavior of major browsers and introduce and apply a simple formal framework to study the problem in the wild.

## 2. Contributions
We make the following contributions:

1. **Formal Framework**: We introduce a formal framework to rigorously study the problem of inconsistencies in framing control, based on existing work on the CSP semantics. We use this framework to formalize the notion of policy consistency and observe that not every inconsistency is equally dangerous. We propose more relaxed definitions that admit limited types of inconsistencies, justified by the evolution of the web platform (Section 3).
2. **Policy Analyzer**: We develop a policy analyzer (dubbed FRAMECHECK) based on the proposed theory, which enables an automated security assessment of the state of click-jacking protection on a given web page. Our implementation leverages a comprehensive set of test cases designed to understand how existing browsers implement the loosely specified XFO header. The test cases highlight potentially dangerous practices in major browsers (Section 4).
3. **Empirical Analysis**: We run FRAMECHECK on policies collected from 10,000 popular websites from the Tranco list and assess their effectiveness. Our experiments show that 10% of de-duplicated policies are inconsistent. We conduct a systematic analysis of the main causes of inconsistency and their practical impact. We also discuss the impact of the selected browsers on the results of our study and the future of click-jacking protection (Section 5).
4. **Recommendations and Proxy**: We present recommendations for developers and browser vendors to mitigate the dangers of framing control inconsistencies currently affecting the web. We also design and implement a server-side proxy to retrofit security in existing web applications, which we release as open-source software (Section 6).

## 3. Background
### 3.1 Framing-Based Attacks
HTML and CSS allow fine-grained control over how elements are placed and shown in the browser. This feature, while essential for the web's success, can be abused by attackers. For example, an attacker can trick victims into clicking elements in another web application, such as in a "like-jacking" attack on social networks. Here, an attacker creates a page with an element a user is likely to click, adds an iframe pointing to a page with a Like button at the same coordinates, and uses CSS to make the iframe fully transparent. When the user tries to click the button, they unknowingly click into the frame, inadvertently invoking the like functionality. Such attacks, where the adversary lures the victim into unknowingly clicking a link on a different page, are referred to as click-jacking.

### 3.2 X-Frame-Options
Starting in 2009, browser vendors recognized the increasing danger of click-jacking and similar attacks, and Internet Explorer was the first to implement the X-Frame-Options (XFO) header. This header allows a site to control which origins may frame it. At that time, Firefox and Internet Explorer supported three directives: `SAMEORIGIN` to allow framing only from pages with the same origin, `ALLOW-FROM origin` to selectively allow framing from a single origin, and `DENY` to block framing completely. Although an XFO specification exists (RFC 7034), it was written after various browsers had implemented XFO and notes that “not all browsers implement X-Frame-Options in exactly the same way, which can lead to unintended results.” Specifically, the `ALLOW-FROM` directive is not universally supported, and browsers might implement `SAMEORIGIN` (and `ALLOW-FROM`) differently. According to the specification, the origin check for framing can be based on the origin of the framed page and the top-level browsing context, the framed page and the framing page, or the whole chain of nested frames in between. The first practice, though common, is potentially insecure because it opens the way to double framing attacks.

Overall, XFO is inconsistently implemented across browsers. We delve deeper into the actual inconsistencies and their impact in Section 4.2.

### 3.3 Content Security Policy
Given the problems with the underspecified XFO header, the web security community proposed incorporating framing control into Content Security Policy (CSP). Initially meant to mitigate injection attacks, CSP now supports framing control and TLS enforcement. As a recent study has shown, CSP is widely used for these purposes. Framing control in CSP can be enforced through the `frame-ancestors` directive, which has several advantages over XFO. First, it performs the origin check for framing based on the whole chain of nested frames, offering the strongest security guarantees. Second, CSP is more expressive than XFO, allowing administrators to whitelist an arbitrary list of origins. For example, the `DENY` directive of XFO can be simulated by setting the `frame-ancestors` directive to `none`, and `SAMEORIGIN` can be simulated by setting it to `self`. CSP can also easily whitelist all subdomains of given domains, which cannot be expressed through XFO. Administrators have an easier job maintaining a whitelist of sites through CSP; achieving the same through XFO is only possible by checking the `Referer` header of incoming HTTP requests, a process known as Referer sniffing.

In this paper, we refer to browsers supporting framing control via CSP as modern browsers and all others as legacy browsers. According to the CSP specification, modern browsers must ignore XFO headers in the presence of a CSP that includes a `frame-ancestors` directive. However, XFO is still the only way for a site to control framing in legacy browsers. Given the difference in expressiveness between the two mechanisms, this can cause inconsistencies when visiting the same page with different browsers.

## 4. Formal Framework
### 4.1 Policy Semantics
Since CSP is more expressive than XFO, every XFO policy can be translated into an equivalent CSP policy. We define the semantics of every framing control policy using the CoreCSP framework, which provides a simple denotational semantics for the content restriction fragment of CSP. One can interpret the set of origins from which framing is allowed using source expressions, a sort of regular expressions representing a set of origins. The semantics of a framing control policy is then given by a directive value, a set of source expressions defining the origins where framing is allowed. The productions in Table 1 define the main syntactic categories of CoreCSP used in this section.

For example, if `http://www.foo.com` deploys the following CSP:
```csp
frame-ancestors *.foo.com https://*
```
The semantics of the policy is formalized by the directive value `{(http,*.foo.com), (https,*)}`. However, this assumes the use of a modern browser. Any legacy browser that does not support CSP will ignore the policy and enforce no framing restriction, which can be modeled by the more liberal directive value `{(http,*), (https,*)}`.

More generally, since the same policy might be enforced differently by different browsers and the same web page may send different policies to different user agents, we let \(\langle w \rangle_b\) stand for the directive value representing the framing restrictions enforced on the page \(w\) by the browser \(b\).

### 4.2 Formal Definitions
We build on CoreCSP because directive values can be ordered by a relation \(\leq\) such that \(v_1 \leq v_2\) if and only if the set of origins represented by \(v_1\) is contained in the set of origins represented by \(v_2\). This ordering allows us to define the notion of policy consistency. A policy is consistent if the directive values for all browsers are the same. We also propose more relaxed definitions that admit limited types of inconsistencies, which are justified by the current state of the web platform and its evolution.