title:A Tale of Two Headers: A Formal Analysis of Inconsistent Click-Jacking
Protection on the Web
author:Stefano Calzavara and
Sebastian Roth and
Alvise Rabitti and
Michael Backes and
Ben Stock
A Tale of Two Headers: A Formal Analysis of 
Inconsistent Click-Jacking Protection on the Web
Stefano Calzavara, Università Ca’ Foscari Venezia; Sebastian Roth, CISPA Helmholtz 
Center for Information Security and Saarbrücken Graduate School of Computer 
Science; Alvise Rabitti, Università Ca’ Foscari Venezia; Michael Backes and 
Ben Stock, CISPA Helmholtz Center for Information Security
https://www.usenix.org/conference/usenixsecurity20/presentation/calzavara
This paper is included in the Proceedings of the 29th USENIX Security Symposium.August 12–14, 2020978-1-939133-17-5Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX.A Tale of Two Headers: A Formal Analysis of
Inconsistent Click-Jacking Protection on the Web
Stefano Calzavara
Università Ca’ Foscari
Sebastian Roth
CISPA Helmholtz Center for Information Security
Saarbrücken Graduate School of Computer Science
Alvise Rabitti
Università Ca’ Foscari
Michael Backes
Ben Stock
CISPA Helmholtz Center for Information Security
CISPA Helmholtz Center for Information Security
Abstract
Click-jacking protection on the modern Web is commonly
enforced via client-side security mechanisms for framing
control, like the X-Frame-Options header (XFO) and Con-
tent Security Policy (CSP). Though these client-side security
mechanisms are certainly useful and successful, delegating
protection to web browsers opens room for inconsistencies in
the security guarantees offered to users of different browsers.
In particular, inconsistencies might arise due to the lack of
support for CSP and the different implementations of the un-
derspeciﬁed XFO header. In this paper, we formally study
the problem of inconsistencies in framing control policies
across different browsers and we implement an automated
policy analyzer based on our theory, which we use to assess
the state of click-jacking protection on the Web. Our analysis
shows that 10% of the (distinct) framing control policies in
the wild are inconsistent and most often do not provide any
level of protection to at least one browser. We thus propose
recommendations for web developers and browser vendors
to mitigate this issue. Finally, we design and implement a
server-side proxy to retroﬁt security in web applications.
1 Introduction
The Web is the largest distributed system in the world, and it
boasts an incredible variety and complexity. Unfortunately,
complexity is where attackers lurk. To assist developers in
securing their applications, the Web platform has evolved to
support more and more server-sent, yet client-enforced se-
curity mechanisms. This approach is appealing because it
offers uniform and well-thought defenses to as many Web
developers as possible. Examples of popular client-side secu-
rity mechanisms include Content Security Policy (CSP) [25],
cookie security attributes [3], and HSTS [11].
Although client-side security mechanisms are undoubt-
edly useful and successful [23], delegating protection to Web
browsers might introduce inconsistencies in the security guar-
antees offered to users of different browsers. The most obvi-
ous case is when legacy browsers access Web applications,
but problems might also arise when the same defense is imple-
mented differently across modern browsers [21]. In this paper,
we are concerned about inconsistencies in framing control, a
cornerstone of Web application security, which pioneered the
adoption of client-side security mechanisms.
Framing control constrains the inclusion of Web content
inside iframes (sub-documents) opened by malicious pages
and it is particularly useful to prevent click-jacking attacks [7].
The original defense against click-jacking back in the days
was the use of JavaScript-based frame busters. These scripts,
placed in pages for which framing should be forbidden, merely
checked conditions like self == top to assess whether they
were loaded in the top-most frame. If not, they would navigate
the top frame away. Unfortunately, researchers showed that
this solution was often ineffective [20]. In 2009, Internet Ex-
plorer introduced the X-Frame-Options header (XFO) as a
simple, browser-based mechanism to control framing without
relying on JavaScript. This header gained extensive popularity
and was quickly adopted by all the other major browsers. Un-
fortunately, since XFO was not standardized a priori, different
browser vendors provided different implementations, leading
to differing support of its directives and attacks like double
framing in some browsers [20]. In 2014, the second iteration
of the CSP speciﬁcation introduced the frame-ancestors
directive to control framing, with the goal of obsoleting XFO
and to offer a comprehensive, uniform protection mechanism
for all CSP-compliant browsers.
The way in which the Web platform evolved hints at the fact
that the state of click-jacking protection on the Web is brittle.
Most browsers provide two different defenses in the form of
XFO and CSP, possibly with different implementations, and
developers may choose to use any of these two mechanisms,
or a combination thereof, to protect their Web applications.
Given such complexity and the diverse levels of support for
framing control, this potentially gives rise to inconsistencies.
In this paper, we conduct a comprehensive study of the dif-
fering behavior of major browsers and introduce and apply a
simple formal framework to study the problem in the wild.
USENIX Association
29th USENIX Security Symposium    683
Contributions. We make the following contributions:
1. we introduce a formal framework designed to rigorously
study the problem of inconsistencies in framing control,
based on existing work on the CSP semantics [4]. We
use this framework to formalize the notion of policy
consistency and to observe that not every inconsistency
is equally dangerous. We thus propose more relaxed
deﬁnitions which admit limited types of inconsistencies
and might be justiﬁed by how the Web platform has been
evolving (Section 3);
2. we develop a policy analyzer (dubbed FRAMECHECK)
based on the proposed theory, which enables an auto-
mated security assessment of the state of click-jacking
protection on a given Web page. Our implementation
leverages a comprehensive set of test cases designed to
understand how existing browsers implement the loosely
speciﬁed XFO header. The test cases are of indepen-
dent interest since they highlight potentially dangerous
practices in major browsers (Section 4);
3. we run FRAMECHECK on policies collected from 10,000
popular websites from the Tranco list [18] and we assess
their effectiveness. Our experiments show that 10% of
the (de-duplicated) policies are inconsistent. Hence we
carry out a systematic analysis of the main causes of
inconsistency and their practical import. We also discuss
the impact of the selected browsers on the results of our
study, reasoning on the road forward for click-jacking
protection (Section 5);
4. we present recommendations for developers and browser
vendors to mitigate the dangers of the framing control
inconsistencies that are currently affecting the Web. We
also design and implement a server-side proxy to retroﬁt
security in existing Web applications, which we release
as open-source software (Section 6).
Artifact Availability.
In the interest of open science, we
make both our server-side proxy and the FRAMECHECK core
available online.1,2
2 Background
In this section, we review framing-based attacks and the most
popular client-side defense mechanisms against them.
2.1 Framing-based Attacks
The nature of HTML and CSS allows the developers of a
Web site ﬁne-grained control over how elements are placed
and shown in the browser. This feature, which is one of the
1https://github.com/cispa/framing-control-proxy
2https://github.com/cispa/framing-control-analytics
core pillars of the Web’s success, can, however, be abused by
attackers to their advantage. In particular, an attacker can trick
their victims into clicking elements in another Web applica-
tion. One popular example is the so-called like-jacking attack
on social networks. Here, an attacker creates a page with an
element a user is likely to click, e.g., a button promising some
premium content. Then, the attacker adds an iframe pointing
to a page with a Like button (e.g., from Facebook) at the same
coordinates, and use CSS to make the iframe fully transpar-
ent. When the user tries to click the button for the premium
content, she unknowingly clicks into the frame, inadvertently
invoking the like functionality. In general, we refer to such
attacks where the adversary lures the victim into unknowingly
clicking a link on a different page as click-jacking.
2.2 X-Frame-Options
Starting from 2009, browser vendors picked up on the increas-
ing danger of click-jacking and similar attacks, and Internet
Explorer was the ﬁrst browser to implement the so-called
X-Frame-Options (XFO) header [9]. This header allows a
site to control which other origins may frame it. At that time,
Firefox and Internet Explorer supported three different direc-
tives for the XFO header: SAMEORIGIN to allow framing
only from pages with the same origin (i.e., protocol, host,
and port), ALLOW-FROM origin to selectively allow framing
from a single origin or DENY to block framing completely.
Importantly, although an XFO speciﬁcation exists in the
form of RFC 7034 [9], that speciﬁcation was written after
various browsers had implemented XFO and notes that “not
all browsers implement X-Frame-Options in exactly the same
way, which can lead to unintended results”. In particular, the
ALLOW-FROM directive is not universally supported by all
browsers: most importantly, all Chromium derivates do not
understand this directive. Additionally, browsers might im-
plement SAMEORIGIN (and ALLOW-FROM) differently
because the origin check for framing can be performed in dif-
ferent ways. According to the speciﬁcation, the check can be
based “on the origin of the framed page and the top-level
browsing context”, on “the framed page and the framing
page”, or on “the whole chain of nested frames in between”.
When the XFO speciﬁcation was originally written, the ﬁrst
practice was the most common, yet such implementation is po-
tentially insecure because it opens the way to double framing
attacks, where the attacker relies on multiple nested frames to
circumvent existing defense mechanisms [20].
Overall, we ﬁnd that XFO is indeed inconsistently imple-
mented across browsers. We dive deeper into the actual incon-
sistencies and their impact in Section 4.2.
2.3 Content Security Policy
Given the problems of the underspeciﬁed XFO header, the
Web security community proposed to incorporate framing
684    29th USENIX Security Symposium
USENIX Association
control into Content Security Policy (CSP). While initially
meant as a means of mitigating injection attacks, CSP nowa-
days offers support for framing control and TLS enforcement
as well. As a recent study has shown, CSP is equally widely
used for these use cases as it is for its original purpose [19].
In particular, framing control in CSP can be enforced
through the frame-ancestors directive. This solution has
a clear advantage over XFO due to its standardized support
and additional expressiveness. First, as the name suggests, the
frame-ancestors directive performs the origin check for
framing based on the whole chain of nested frames (ances-
tors) between the top-level browsing context and the framed
page, which offers the strongest security guarantees by ruling
out double framing. Moreover, CSP is strictly more expres-
sive than XFO, since it can take advantage of the full CSP
syntax, which allows one to whitelist an arbitrary (possibly
empty) list of origins. For example, the DENY directive of
XFO can be simulated by setting the frame-ancestors di-
rective to ’none’, while the SAMEORIGIN directive can be
simulated by setting it to ’self’. Even better, CSP can be
easily used to whitelist all subdomains of given domains, e.g.,
frame-ancestors *.foo.com *.bar.com, which cannot
be expressed through XFO. Hence, administrators have an
easier job at maintaining a whitelist of sites through CSP;
achieving the same through XFO is only possible by checking
the Referer header of incoming HTTP requests. This header is
sent by browsers and indicates the document which initiated
the loading of a speciﬁc resource (in this case, an iframe).
Hence, this can be combined with server-side logic to check
the transmitted header against a whitelist, and respond with
a corresponding ALLOW-FROM header. We refer to this
mechanism as Referer snifﬁng.
In this paper, we refer to browsers supporting framing con-
trol via CSP as modern browsers; we deem all the other
browsers as legacy. According to the CSP speciﬁcation, mod-
ern browsers must ignore the XFO headers in the presence
of a CSP, which includes a frame-ancestors directive. At
the same time, however, XFO is still the only way for a site to
control framing in legacy browsers. Given the difference in
expressiveness between the two types of security mechanisms,
this can cause inconsistencies when visiting the same page
with different browsers.
3 Formal Framework
In this section, we lay the theoretical grounds for our research
by formalizing the notion of policy consistency. We then
observe that not every inconsistency is equally dangerous and
propose more relaxed deﬁnitions which admit limited types
of inconsistencies. We also argue why these deﬁnitions are of
practical interest by taking into account the current state of
the Web platform and its evolution.
Schemes
Host Expressions
Source Expressions
Directive Values
s
h
e
v
::= http | https
::= * | *.string | string
::= ’self’ | s | h | (s,h)
::= {e1, . . . ,en}
Table 1: Syntax of CoreCSP
3.1 Policy Semantics
Since CSP is more expressive than XFO, it is straightforward
to translate every XFO policy into an equivalent CSP policy.
Hence, we can deﬁne the semantics of every framing control
policy on top of the CoreCSP framework, which provides
a simple denotational semantics for the content restriction
fragment of CSP [4]. In particular, one can interpret the set
of origins from which framing is allowed using source ex-
pressions, i.e., a sort of regular expressions representing a
set of origins. The semantics of a framing control policy is
then given by a directive value, i.e., a set of source expres-
sions deﬁning the origins where framing is allowed. The
productions in Table 1 deﬁne the main syntactic categories
of CoreCSP used in the present section. Note that, though
relatively close to the original CSP syntax, CoreCSP abstracts
from several details, which can still be easily modeled. For
example, the ’none’ source expression of CSP is represented
by the directive value /0 (framing is not allowed anywhere).
To understand how the CoreCSP denotational semantics
is deﬁned, assume that http://www.foo.com deploys the
following CSP:
frame-ancestors *.foo.com https://*
Since the protected page is served over HTTP, the seman-
tics of the policy is formalized by the directive value
{(http,∗.foo.com), (https,∗)}. However, note that this as-
sumes the use of a modern browser since any legacy browser
which does not support CSP will ignore the policy and enforce
no framing restriction. This can be modeled by giving the
semantics of the policy in terms of the more liberal directive
value {(http, *), (https,∗)}.
More generally, since the same policy might be enforced
differently by different browsers and the same Web page may
also send different policies to different user agents, we let
(cid:74)w(cid:75)b stand for the directive value representing the framing
postpone to Section 4 the deﬁnition of(cid:74)·(cid:75)· for the browsers of
restrictions enforced on the page w by the browser b. We
interest and develop a general theory in the present section.
3.2 Formal Deﬁnitions
We build on CoreCSP because directive values can be ordered
by a relation (cid:118) such that v1 (cid:118) v2 if and only if the set of
origins represented by v1 is contained in the set of origins