• The AndroidManifest.xml file in the Android Developers Reference guide at
http://developer.android.com/guide/topics/manifest/manifestintro.html.
● The Context class in the Android Developers Reference guide at http:/developer.
android.com/reference/android/content/Context.html。
● The Activity class in the Android Developers Reference guide at http:/developer.
android.com/reference/android/app/Activity.html.。
5.3
通过定制权限保护组件
Android平台定义了一系列用于保护系统服务和app组件的默认权限，大多数情
况下，这些权限还是能适用于大多数一般场景的，但是，通常在app间需要共享一些
预定的功能或组件时，就需要对这一权限框架进行一些调整了。通过定义定制的权
限，可以很容易地做到这一点。
这个实验演示了你该如何定义你自己的定制权限。
怎么做···
让我们开始！
1.在添加定制的权限之前，你先得声明表示permission 标签的字符串，你可以
通过编辑位于你的app项目文件夹中的res/values/strings.xml文件来完成这一
任务。
Custom Permlssion
2.在你的app 中添加保护级别为normal的定制权限，你可以通过在
AndroidManifest.xml文件中加入下列字符串来完成这一任务。
149
---
## Page 168
Android安全攻防实战
3.为了让这个权限能和其他权限一样工作，你需要把它添加到app中某个组件
的android:pemmission 属性中去，如果这个组件是个 activity：
cactivity ...
android:permission=*android.permission.CUSTOM_PERMISSION">
如果这个组件是个content provider:
cprovider
android:permission=*android.permission. CUSTOM_PERMISSION">
+ - *
如果这个组件是个service：
Cservice ...
如果这个组件是个receiver：
4.你也可以通过在其他 app 的 AndroidManifestLxml文件中添加
标签的方式，让其他app也能请求这一权限：
定义一个权限组
定制的权限还可以在逻辑上分组，通过分配语法，告知请求一个给定权限的aPPp
或者请求某几个权限的组件。给权限分组，可以通过定义一个权限组，然后在定义
你的权限时，把它们分配到这个组中的方式完成，如刚才所示。下面是你如何定义
一个权限组。
1.添加一个表示权限组标签（label）的字符串，和上面那个例子一样，可以在
res/values/strings.xml文件中添加下列文字来完成这一任务。
Cstring name=*my_permissions_group_label*>Personal Data Access
2.在你的 app 的 AndroidManifest.xml 文件中添加下列这几行代码。
150
---
## Page 169
第5章保护app
3.之后你就可以把你定义的权限分配到这个组里去了，如下所示。
工作原理
上述步骤演示了如何使用AndroidManifest.xml文件中的元素来定
义定制的权限，以及如何使用manifest中的来定义一个权限组。
现在，我们谈一谈它们的细节，并详细说明各个不同元素及其属性的区别。
元素很容易理解，下面是这个属性的细节信息。
·android：name：它定义了权限的名称，也就是用来表示这一权限的字符串值。
·android:protectionLevel:它定义了该权限的保护级别，以及控制用户是否会被
提示同意授予这一权限。在第4章中，我们已经讨论过这一点了，但是这里
还是概述一下保护级别。
口normal:这个permission是用来定义非危险的权限的，该权限不会被提
示，可以被自动赋予。
口dangerous:这个permission 是被用来定义那些会使用户暴露在财务、名
誉或法律风险下权限的。
口signature:这个权限会被自动赋予那些由定义该权限的app 相同签名的
app
口signatureOrSystem:该权限会被自动赋予那些作为系统镜像的一部分，
或者有定义该权限的app相同签名的app。
如果你关心的只是在由你自已开发的app 间共享组件，就应该选用signature 权
限。举一些这方面的实际应用：有某个免费app，不过它的解锁器app却是要付费下
载的。或者某个app有几个可选的插件，这些插件间需要共享一些功能，被标记为
dangerous 的权限不会被自动赋予app，在安装时，android:description 属性可能会被
显示出来，要求用户确认，如果当其他app要访问你的app中的数据时，你想要提示
用户的话，这就非常有用。被标记为normal 的权限，在安装时会被自动赋予app，
不会提示给用户。
拓展阅读
· The  tag in the Android Developers Referencc guide at
http://developer.android.com/guide/topics/manifest/permission-element.html.
151
---
## Page 170
Android安全攻防实战
● The  tag in the Android Developers Reference guide at
http://developer.android.com/guide/topics/manifest/usespermission-clement.html.
° The  tag in the Android Developers Reference guide at
http://developer.android.com/guide/topics/manifest/permissiongroup-element.html.
• The Manifestpermission class in the Android Developers Reference guide at
https:/developer.android.com/reference/android/Manifest.permission.html.
5.4保护contentprovider的路径（path）
由于其中经常会记录与用户登录活动密切相关的数据，所以在app的各类组件
中，content provider 可能是最容易被黑客町上的目标了。content provider 中经常会含
有许多用户的敏感数据，而且它们也与SQL注入攻击和信息泄露密切相关。这一节
中将会详细讨论一些保护你的content provider免受那些由于常见的contentprovider
权限配置错误面导致的普通信息泄露问题的措施。此外，我们也会讨论保护数据库
和 content provider 免受 SQL注入攻击的方法。
这个实验里，将讨论如何在你的AndroidManifest.xml文件中加入特定的配置，
对你的 content provider 甚至于在URI的路径（path）级别上进行访问保护。同时也
会讨论滥用URI授权（grantURI）机制会造成哪些安全风险，使你不会把你的content
provider中的太多路径暴露给未经授权的或潜在的恶意app。
统一资源定位符（Uniform resource identifiers，URI）是content provider用来
标识给定数据库的，比如，content:/com.myprovider.android/email/inbox。
怎么做
加固任何组件的先决条件都是：确保你已经为之注册了适当的权限。加固一个
content provider 不光要为 content provider的一般交互操作，也要为相关的URI 路径
设置权限。
1.为了加固你的content provider，需要设置一个用于管理所有与你的认证相关
路径的读和写权限的permission，你可以在你的 android manifest 添加下面这
个provider元素。
其中的[permission name]是其他 app 在读或写任何 content provider 路径时必须
拥有的权限。把相关权限添加在这一级别上确实是个好主意，这能保证当它
被用来保护路径时不会漏掉什么东西。
2.显然，content provider应该有一些它们存放相关数据的content 的路径，你可
以像下面这样，给它们加上读和写的权限。
cprovider
android:writePermission=" [wzite permission name]*
上面的 android:writePermission 和 android:readPermission标签是用来声明当其
所必须拥有的特定权限的。
一个常见的误解是：被赋予了写访问权限之后，也就拥有了读访
问权限。但是这可不是默认的行为。Android恰当地遵循了最佳
实践，并且需要对读和写访问分别进行独立的权限声明。
下面是来自Android 谷歌Chrome app 的一个实例。
元素，为每个
单独的路径设置不同的权限，下面是你该怎么做。
你或许会感到困惑：如果你同时使用两个不同的权限级别，会发生什么情况。
153
---
## Page 172
Android安全攻防实战
在和级别上，app 会需要把所有的权限在这两个
级别上都注册一遍吗？答案是：不，pat级的读、写和读/写权限的优先级更高。
3.另一件值得提及的事是URI授权（grant URI）机制。你可以在provider级
别上配置它，把它应用到所有路径上去，也可以在path级别上使用它—这
样的话，就只会影响相应的路径。不过为什么在path级别上设置了特定的权
限之后，在要在provider级别上进行URI授权呢？这真的是有点奇怪—因
为这实际上就是不设置任何权限！我们强烈建议开发者无论如何不要在
provider上使用URI授权，只能在各个path 级上使用它。所以当且仅当在你
操作，同时又要让你的其他路径获得权限保护时，你才能做下面这种事。
你也可以用pathPrefix或者pathPattem属性来指定一定范围内的路径获得
URI授权。pathPrefix会让URI授权应用到所有以给定的字符串开头的路径
上去。而pathPattem则让URI授权应用到匹配给定模式的所有路径上去。
去，比如
 content://com.myprovider,android/unsecuredstuff.
 content://com.myprovider android/unsecured/fi1es,
口
 content://com.myprovider. android/unsecuredsomemorestuff,
 content://com.myprovider, android/unsecured/f1les/mus1c.
对于上面这个例子，对上述所有路径中任何数据的查、改、查、删操作都适
用于URI授权。
拓展阅读
android.com/guide/topics/manifest/provider-clement.html.
/ e on sa sadoao pnopy  u e  ou 
developer.android.com/guide/topics/manifest/path-permission-clement.html.
154
---
## Page 173
第5章保护app
5.5防御SQL注入攻击
第4章中介绍了一些针对content provider的常见攻击类型，其中之一就是臭名
昭著的SQL注入攻击。这种攻击利用了攻击者可以通过提交精心构建的数据，把恶
意内容混入他们选定的参数、投影或其他有效SQL语句组件的这一事实，使攻击者
能够通过content provider 提取到比正常情况下能拿到的更多的信息。
要确保攻击者不能把来路不明的SQL内容注入到你的查询语句中去，最好的办
法就是：避免使用SQLiteDatabasc.rawQueryO，而改用一个参数化的语句。使用一个
预先编译好的语句，比如 SQLiteStatement，提供对参数的绑定（binding）和转换
（escaping），以防御SQL注入攻击。这样做还会有一些性能上的提升—因为这样，
数据库就不必在每次执行时都要对语句进行一番解析了。可以代替SQLiteStatement
的另一个方法是使用 SQLiteDatabase 类中的 query, insert,update 和 delete 方法，这些
方法通过他们使用的字符串数组，提供了参数化的语句。
当我们描述参数化的语句时，我们就是在描述一个SQL语句，而在要插入或绑
定值的地方，用问号代替它们。下面就是一个参数化的SQL插入语句。
INSERT VALUES INTO [table name](7, ?, ?, ?, ...)
其中[table name]是将要被插入数据的相关表的名称。
怎么做
在这个例子里，我们使用一个简单的数据访问对象（Data Access Object，DAO）
模式。在这里，所有RSS项的数据库操作，都被包含在了RssltemDAO类中。
1.当我们实例化一个RssItemDAO对象时，我们把insertStatement对象编译成
了一个参数化的 SQLinsert语句字符串。这一操作只需要做一次，就能在多
个插入操作中反复使用了。
public class RssItemDAO [
private SQLiteStatement insertStatement;
private static String CoL_rITLE = *title*:
private Static String TABLE_NAME = *RSS_ITEMS";
" (content, 1ink, title) values (7, 7, 7)*;
1nto * + TABLE_NAME +
pub1ic RssItemDAO (SQLiteDatabase db)[
155
---
## Page 174
Android安全攻防实战
thi8,db = db;
InsertStatement = db.
ompileState
ent (INSERT_SQL) ;
INSERT_SQL变量中列的顺序是很重要的，因为在绑定值的时候，它会直接
被映射成索引。在上面这个例子中，content会被映射成索引o，link会被映
射成索引1，面title会被映射成索引2。
2.现在，当我们要把一个新的RssItem对象插入到数据库中去时，我们可以按
它们在语句中出现的顺序，绑定各个属性。
)(wT weIe) 9ee buot oTtqnd
InsertStatement ,bindString (1, item,getContent ()) 
InsertStatement ,bindString (2, item.getLink ()) 
insertStatement ,bindString (3, item, getTitle ())