在已知M的情况下，由于LCG的生成式为一个简单的线性关系式，若能获取连续的2个x，便可建立-
个关于A和6的方程，获取多个x：则可获得方程组
xi+1=(Ax+B)modM
xj+1=(Ax+B)modM
求解此方程组，即可解出参数A和B。
若M未知，则需要较多已知的输出序列。由于通过线性同余方法得到的数值一定小于M，且对于满足
周期为M的序列是在0~M1范围内均匀分布，通过观察所有的输出可以得到M的最小值，枚举大于
这个数值的M。选取几个连续的x解上述方程，对于有解的情况，再将其他x代入进行验证，直到所有
的输出通过验证。因为均匀分布，枚举量不会太大。
【例7-4-1】VolgaCTFQuals2015，题目提供了一个加密脚本和一个被加密的PNG文件。加密脚本
如下：
ieset snet
ndt_(seif, s2:
'
gsa[:4ngth)
csOeyE 13)
https:/weread.q.com/web/reader/77d32500721a485577d8eeek66f3299023a66f041e16858
---
## Page 396
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
rh'3 as f
.erite(ent_data)
可以看到，脚本中对于flag.png进行了流密码加密，由
可知，对于密钥流的使用是每次产生的数字以小端序打包为2字节整数，再与明文进行异或后加密。
使用的密钥流由LCG产生，其中模数M已经给出，为65521，而系数A和常数B研没有给出，需要通过
攻击来获取。
已知被加密的为一张PNG图片，而PNG图片的起始8字节是确定的：
89504E470D0A1A0A
便可以进行已知明文攻击。读取flag.enc.bin的前8字节，得到以下数据：
99CE83E95DE0D8E0
将数据分别拆成2字节小端序数，便可获得以下明密文对：
(0x5089,0xCE99)
(0x474E,0xE983)
(0x0A0D,0xE05D)
(0x0A1A,0xE0D8)
分别进行异或，可以获得密钥流中的前4个值：
40464,44749,59984,60098
由于未知量有A、B，可以选取3个连续的密钥数值进行计算。选取x=40464，x2=44749，x3=
5998
，代入生成式，得到
44749 = (.4×40464 + 8)mod65521
(7-3)
59984  (4×44749 + B)mod65521
(7-4)
式（7-4）-式（7-3），得
15235=(4×4285)mod65521
(7-5)
https:/weread.qq.com/web/reader/77d32500721a485577d8eeek66f3299023a66f041e16858
---
## Page 397
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
对式（7-5）求解同余方程，得
A=44882mod65521
代入式（7-3），解得
B=50579mod65521
将A和B代入首个生成式
40464=(44882×xo+50579) mod65521
解得
x=37388mod65521
化为2字节小端序数，得到6字节的key为：
52AF93C50C92
将密钥替换进源程序，由于加密采用异或操作，故只需再进行一次异或即可解密。
+ se (-4, *,re
hey 1*Iafed
l
解密获得如图7-4-2所示的flag图片，即解密成功。
{[linear_congruential_generator_isn't_good_for_crypto)
图7-4-2
一般情况下，式（7-5）的方程不一定有解。本例中的模数M=65521为一个素数，即对于任意正整数
1~65520，均存在对M的逆元。若遇到逆元不存在的情况，我们需要重新选取已知明文进行攻击。
7.4.1.2攻破LinuxGlibc的rand0函数-1
LinuxGNUClibrary中的randO函数的实现如下：
If (bf  ML 11 reslt = NLL)
aGata tuf, Lntn_t *resatt) 
https:/weread.q.com/web/reader/77d32500721a485577d8eeek66f3299023a66f041e16858
---
## Page 398
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
可以看到，当使用rand_type_O时，采用的是标准的LCG算法，生成公式为
S/=(1103515245×5/1+12345) m0d2147483648
显然，当捕获到一个其产生的随机数时，便可通过递推式预测出后产生的所有随机数。因为
1103515
与2147483648互素，可求得逆元1857678181，有
Si1=(s12345)×1857678181mod2147483648
从而实现随机数序列的向前恢复。
3。TYPE_3攻破的方法将在7.4.2节中介绍。
7.4.2线性反馈移位寄存器（LFSR）
移位寄存器（ShiftRegister）是数字电路中常见的一种器件，可以并行输入若干位进行初始化，并
可进行移入、移出等操作，常被用于产生序列信号。当产生的序列信号随机性足够强时，即可满足流
密码中产生密钥流的需求。密码学中常用的是线性反馈移位寄存器（LFSR），它由一个移位寄存器、
一个反馈函数组成，反馈函数为一个线性函数。进行密钥流生成时，每次从移位寄存器中移出一位作
为当前的结果，而移入的位由反馈函数对寄存器中的某些位进行计算来确定。LFSR的基本结构见图7
4-3。
图7-4-3
取GF（2）上的一个n次的本原多项式，当n=32时，选取
x32+x7+x5+x3+x²+x+1
那么可以得到F函数为
F=S32ΦS7S5S3S2①S1
https:/weread.qq.com/web/reader/77d32500721a485577d8eeek66f3299023a66f041e16858
---
## Page 399
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
即移入位由寄存器中第32、7、5、3、2、1位异或而成。这种周期最大的序列被称为m序列
7.4.2.1由已知序列破译LFSR
设LFSR长度为n位，当已知其长度为2n的输出时，若方程组有解，即可通过解线性方程组来完全获得
LFSR的反馈函数，从而破译LFSR。例如，考虑4位某未知LFSR，获取输出序列为10001010，由于异
或等价于模2加法，即可列出下列线性方程组：
1a+0a+0a+0a=1mod2
0a+0a+0a+1a=1mod 2
0a+0a+1a+0a=1mod 2
0a+1a+0a+1a=1mod 2
解方程组，可得
a=0
a=1
a=1
a3=0
那么，即可求得反馈函数为：
F=S0①S2
即可完全预测此LFSR的序列。
7.4.2.2攻破Linuxglibc的rand0函数-2
rand0函数的另一部分实现如下：
 MLL II restlt = SAL)
pets fail;
1f (bsf
type * TYPE_4) (
/* IJ TYPE_ f4 */
https:/weread.qq.com/web/reader/77d32500721a485577d8eeek66f3299023a66f041e16858
---
## Page 400
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
int32,t *end,tr * buf-rend,ptr)
val * *fgtr * (ulnt32,t) *rptr
*result * vat  1;
 Chuck
*rptr,
etse (
rptr = state
turs 4;
fail:
-st_srrre (EDWL);
returs -1;
类似线性反馈的生成方法。在TYPE_3的情况下，这个状态数组的长度为344，而fptr和rptr分别为当
前下标减31和当前下标减3，那么产生下一个随机数的函数实际上是如下线性反馈式：
X=
2
注意，移入状态数组中的数并不是产生的随机数，而是在右移1位前的数，未位存在0和1两种情况，
这样我们获取32组随机数后，向下预测的下一个数会以25%的概率存在1的误差，且误差会随着预测
数的增多而增大。不过，大部分情况下并不需要预测太多，1的误差已经足够使用，而且如果能够继
续获取随机数，那么可以一边预测一边修正，减少误差。
以下为一个一边预测一边修正随机数的简单Demo：
Sint sain3 (54
，,
s1-
7.4.3 RC4
RC4是一种特殊的流加密算法，1987年由RonaldRivest提出。RC4是有线等效加密（WEP）中采用
https:/weread.qq.com/web/reader/77d32500721a485577d8eeek66f3299023a66f041e16858
7/8
---
## Page 401
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
的加蜜算法曾经是TLS可采用的算法之-。RC4使用0~255位的密钥来生成流密钥然后将流密钥
写明支异或来产生密文。由于极高的计算效率和较强的强度，RC4算法得到了非常产泛的运角
RC4算法的伪代码（来自维基百科）如下。首先，根据输入的密钥初始化S盒。
Yalars ef S(1]e s51
ylesyth]) s 25
然后每输入1字节，就做一次S盒替换操作，并输出1字节流密钥与明文异或：
:=（1 +5[31}mo256
显然，RC4算法作为一种流密码算法，也易受到已知明文攻击的影响。如果使用某一密钥加密了n字
节的数据，并知道明文，即可恢复n字节的流密钥：如果同一密钥被重复使用，那么截获密文即可解
得相应的明文。实际攻击的过程中，经常通过一些可预测的内容来尝试已知明文攻击，如HTTP报文
的头部等。
特别地，当输入的key为[0，0，255，254，253，，2]时，由模的运算性质可以发现S盒替换过
程相当于没有替换，那么输出的流密钥即确定的S[（2*i）%256]，重复周期非常短。另外，有些密
钥属于弱密钥，也会在很短的长度内产生重复的密钥流，所以在实际使用RC4算法时，需要事先对密
钥进行测试。
下一章
https:/weread.qq.com/web/reader/77d32500721a485577d8eeek66f3299023a66f041e16858
---
## Page 402
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
7.5公钥密码
7.5.1公钥密码简介
自从科克霍夫原则和对称加密体制被提出后，密码学进入了现代密码阶段。成熟的分组密码、流密码
的加密强度和加密效率都非常优秀，然而对称密码体系存在着一个不可忽略的问题一密钥的传输需
要一个安全的信道，否则一旦密钥被截获，对称加密就毫无安全性可言。另外，对称加密体制并没有
解决信息的认证与不可否认性的问题。基于以上事实，1976年，WhitfieldDiffie和MartinHellman
发表了Newdirectionsincryptography这篇划时代的文章，奠定了公钥密码系统的基础，而在
年，RonRivest,AdiShamir和LeonardAdleman发明了一种直到今天还被广泛运用的公钥密码
算法RSA
公钥密码（PublicKeyCryptography）。又称为非对称密码，其最大特征是加密和解密不再使用
相同的密钥，而使用不同的密钥。使用者会将一个密钥公开。而将另一个密钥私人持有，这时这两个
密钥被称为公钥和私钥。一般来说，公钥和私钥是滩以互相计算的，但它们可以互相分别作为加密密
钥和解密密钥。当信息发送者选择采用接收者的公钥加密时，接收者收到信息后使用自己的私钥解
密，这样便可保持信息的机密性：若信息发送者使用自己的私钥对信息摘要进行加密，接收者使用发
送者的公钥对摘要进行验证，即可起到签名的作用，可以保证信息的认证性和不可否认性。
在CTF中常见的公钥密码算法为RSA算法，这是CTF参赛者必须掌握的基础知识，还会涉及一些关于
离散对数和椭圆曲线的算法。
7.5.2 RSA
7.5.2.1RSA简介
RSA算法是目前工程中使用最广泛的公钥密码算法，算法的安全性基于一个简单的数学事实：对于大
素数p和q，计算r=pxq非常简单，但是在已知/的情况下分解因子得到p和q则相当困难。
RSA的基本算法如下：选取较大的素数p和q（一般大于512bit，且p不等于q），计算
n=pxq
求/的欧拉函数
(n)=qd(p)×q(q)=(p-1)×(q-1)
选取一个与p（n）互质的整数e，求得e模p（n）的逆元d，即
exdli1modp(n)
则为公钥，u≥0)
m =c mod n