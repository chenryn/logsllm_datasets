表示一个括在花括号中的表达式，该表达式是可选的。A.13 节对语法进行了总结。 说明:与本书第  1  版给出的语法所不同的是，此处给出的语法将表达式运算符的优先级
和结合性显式表达出来了。
A.4 标识符的含义
标识符也称为名字，可以指代多种实体:函数、结构标记、联合标记和枚举标记;结构 成员或联合成员;枚举常量;类型定义名;标号以及对象等。对象有时也称为变量，它是一 个存储位置。对它的解释依赖于两个主要属性:存储类和类型。存储类决定了与该标识对象 相关联的存储区域的生存期，类型决定了标识对象中值的含义。名字还具有一个作用域和一 个连接。作用域即程序中可以访问此名字的区域，连接决定另一作用域中的同一个名字是否
指向同一个对象或函数。作用域和连接将在 A.11 节中讨论。
A.4.1               存储类
存储类分为两类:自动存储类(automatic)和静态存储类(static)。声明对象时使用的一 些关键字和声明的上下文共同决定了对象的存储类。自动存储类对象对于一个程序块(参见 A.9.3 节)来说是局部的，在退出程序块时该对象将消失。如果没有使用存储类说明符，或者 如果使用了 auto 限定符，则程序块中的声明生成的都是自动存储类对象。声明为 register 的对象也是自动存储类对象，并且将被存储在机器的快速寄存器中(如果可能的话)。
静态对象可以是某个程序块的局部对象，也可以是所有程序块的外部对象。无论是哪一 种情况，在退出和再进入函数或程序块时其值将保持不变。在一个程序块(包括提供函数代 码的程序块)内，静态对象用关键字 static 声明。在所有程序块外部声明且与函数定义在 同一级的对象总是静态的。可以通过 static 关键字将对象声明为某个特定翻译单元的局部 对象，这种类型的对象将具有内部连接。当省略显式的存储类或通过关键字 extern 进行声 明时，对象对整个程序来说是全局可访问的，并且具有外部连接。
A.4.2              基本类型
基本类型包括多种。附录 B 中描述的标准头文件中定义了本地实现中每种 类型的最大值和最小值。附录 B 给出的数值表示最小的可接受限度。
声明为字符(char)的对象要大到足以存储执行字符集中的任何字符。如果字符集中的 某个字符存储在一个 char 类型的对象中，则该对象的值等于字符的整型编码值，并且是非负 值。其它类型的对象也可以存储在 char 类型的变量中，但其取值范围，特别是其值是否带符 号，同具体的实现有关。
以 unsigned char 声明的无符号字符与普通字符占用同样大小的空间，但其值总是非 负的。以 signed char 显式声明的带符号字符与普通字符也占用同样大小的空间。
说明:本书的第 1 版中没有 unsi gned char 类型，但这种用法很常见。si gned char 是新 增加的。
除 char 类型外，还有 3 种不同大小的整型类型:short int、int 和 long int。普 通 int 对象的长度与由宿主机器的体系结构决定的自然长度相同。其它类型的整型可以满足 各种特殊的用途。较长的整数至少要占有与较短整数一样的存储空间;但是具体的实现可以 使得一般整型(int)与短整型(short int)或长整型(long int)具有同样的大小。 除非特别说明，int 类型都表示带符号数。
以关键字 unsigned 声明的无符号整数遵守算术模 2
n
 的规则，其中，n 是表示相应整数 的二进制位数，这样，对无符号数的算术运算永远不会溢出。可以存储在带符号对象中的非 负值的集合是可以存储在相应的无符号对象中的值的子集，并且，这两个集合的重叠部分的 表示是相同的。
单精度浮点数(float)、双精度浮点数(double)和多精度浮点数(long double) 中的任何类型都可能是同义的，但精度从前到后是递增的。
说明:l ong doubl e 是新增加的类型。在第 1 版中，l ong f l oat 与 doubl e 类型等价，但 现在是不相同的。
枚举是一个具有整型值的特殊的类型。与每个枚举相关联的是一个命名常量的集合(参 见 A.8.4 节)。枚举类型类似于整型。但是，如果某个特定枚举类型的对象的赋值不是其常量 中的一个，或者赋值不是一个同类型的表达式，则编译器通常会产生警告信息。
因为以上这些类型的对象都可以被解释为数字，所以，可以将它们统称为算术类型。char 类型、各种大小的 int 类型(无论是否带符号)以及枚举类型都统称为整型类型(integral type)。 类型 float、double 和 long double 统称为浮点类型(floating type)。
void 类型说明一个值的空集合，它常被用来说明不返回任何值的函数的类型。
A.4.3              派生类型
除基本类型外，我们还可以通过以下几种方法构造派生类型，从概念来讲，这些派生类 型可以有无限多个:
             给定类型对象的数组
             返回给定类型对象的函数
             指向给定类型对象的指针
             包含一系列不同类型对象的结构
             可以包含多个不同类型对象中任意一个对象的联合
一般情况下，这些构造对象的方法可以递归使用。
A.4.4             类型限定符
对象的类型可以通过附加的限定符进行限定。声明为 const 的对象表明此对象的值不可 以修改;声明为 volatile 的对象表明它具有与优化相关的特殊属性。限定符既不影响对象 取值的范围，也不影响其算术属性。限定符将在 A.8.2 节中讨论。
A.5 对象和左值
对象是一个命名的存储区域，左值(lvalue)是引用某个对象的表达式。具有合适类型与 存储类的标识符便是左值表达式的一个明显的例子。某些运算符可以产生左值。例如，如果 E 是一个指针类型的表达式，*E 则是一个左值表达式，它引用由 E 指向的对象。名字"左值” 来源于赋值表达式 E1=E2，其中，左操作数 E1 必须是一个左值表达式。对每个运算符的讨论 需要说明此运算符是否需要一个左值操作数以及它是否产生一个左值。
A.6 转换
根据操作数的不同，某些运算符会引起操作数的值从某种类型转换为另一种类型。本节 将说明这种转换产生的结果。A.6.5 节将讨论大多数普通运算符所要求的转换，我们在讲解每
个运算符时将做一些补充。
A.6.1               整型提升
在一个表达式中，凡是可以使用整型的地方都可以使用带符号或无符号的字符、短整型 或整型位字段，还可以使用枚举类型的对象。如果原始类型的所有值都可用 int 类型表示， 则其值将被转换为 int 类型;否则将被转换为 unsigned int 类型。这一过程称为整型提 升(integral    promotion)。
A.6.2              整型转换
将任何整数转换为某种指定的无符号类型数的方法是:以该无符号类型能够表示的最大 值加 1 为模，找出与此整数同余的最小的非负值。在对二的补码表示中，如果该无符号类型 的位模式较窄，这就相当于左截取;如果该无符号类型的位模式较宽，这就相当于对带符号 值进行符号扩展和对无符号值进行 0 填充。
将任何整数转换为带符号类型时，如果它可以在新类型中表示出来，则其值保持不变， 否则它的值同具体的实现有关。
A.6.3              整数和浮点数
当把浮点类型的值转换为整型时，小数部分将被丢弃。如果结果值不能用整型表示，则 其行为是未定义的。特别是，将负的浮点数转换为无符号整型的结果是没有定义的。
当把整型值转换为浮点类型时，如果该值在该浮点类型可表示的范围内但不能精确表示， 则结果可能是下一个较高或较低的可表示值。如果该值超出可表示的范围，则其行为是未定 义的。
A.6.4              浮点类型
将一个精度较低的浮点值转换为相同或更高精度的浮点类型时，它的值保持不变。将一 个较高精度的浮点类型值转换为较低精度的浮点类型时，如果它的值在可表示范围内，则结 果可能是下一个较高或较低的可表示值。如果结果在可表示范围之外，则其行为是未定义的。
A.6.5              算术类型转换
许多运算符都会以类似的方式在运算过程中引起转换，并产生结果类型。其效果是将所 有操作数转换为同一公共类型，并以此作为结果的类型。这种方式的转换称为普通算术类型 转换。
首先，如果任何一个操作数为 long double 类型，则将另一个操作数转换为 long double 类型。
否则，如果任何一个操作数为 double 类型，则将另一个操作数转换为 double 类型。
否则，如果任何一个操作数为 float 类型，则将另一个操作数转换为 float 类型。 否则，同时对两个操作数进行整型提升;然后，如果任何一个操作数为 unsigned long
int 类型，则将另一个操作数转换为 unsigned long int 类型。
否则，如果一个操作数为 long int 类型且另一个操作数为 unsigned int 类型，则 结果依赖于 long int 类型是否可以表示所有的 unsigned int 类型的值。如果可以，则 将 unsigned int 类型的操作数转换为 long int;如果不可以，则将两个操作数都转换为 unsigned long int 类型。
否则，如果一个操作数为 long int 类型，则将另一个操作数转换为 long int 类型。 否则，如果任何一个操作数为 unsigned int 类型，则将另一个操作数转换为 unsigned
int 类型。
否则，将两个操作数都转换为 int 类型。
说明:这里有两个变化。第一，对 float 类型操作数的算术运算可以只用单精度而不是 双精度;而在第  1  版中规定，所有的浮点运算都是双精度。第二，当较短的无符号类型与较
长的带符号类型一起运算时，不将无符号类型的属性传递给结果类型;而在第 1 版中，无符 号类型总是处于支配地位。新规则稍微复杂一些，但减少了无符号数与带符号数混合使用情 况下的麻烦，当一个无符号表达式与一个具有同样长度的带符号表达式相比较时，结果仍然 是无法预料的。
A.6.6              指针和整数
指针可以加上或减去一个整型表达式。在这种情况下，整型表达式的转换按照加法运算 符的方式进行(参见 A.7.7 节)。
两个指向同一数组中同一类型的对象的指针可以进行减法运算，其结果将被转换为整型; 转换方式按照减法运算符的方式进行(参见 A.7.7 节)。
值为 0 的整型常量表达式或强制转换为 void *类型的表达式可通过强制转换、赋值或比 较操作转换为任意类型的指针。其结果将产生一个空指针，此空指针等于指向同一类型的另 一空指针，但不等于任何指向函数或对象的指针。
还允许进行指针相关的其它某些转换，但其结果依赖于具体的实现。这些转换必须由一 个显式的类型转换运算符或强制类型转换来指定(参见 A.7.5 节和 A.8.8 节)。
指针可以转换为整型，但此整型必须足够大;所要求的大小依赖于具体的实现。映射函 数也依赖于具体的实现。
整型对象可以显式地转换为指针。这种映射总是将一个足够宽的从指针转换来的整数转 换为同一个指针，其它情况依赖于具体的实现。
指向某一类型的指针可以转换为指向另一类型的指针，但是，如果该指针指向的对象不 满足一定的存储对齐要求，则结果指针可能会导致地址异常。指向某对象的指针可以转换为 一个指向具有更小或相同存储对齐限制的对象的指针，并可以保证原封不动地再转换回来。
"对齐"的概念依赖于具体的实现，但 char 类型的对象具有最小的对齐限制。我们将在 A.6.8
节的讨论中看到，指针也可以转换为 void *类型，并可原封不动地转换回来。
一个指针可以转换为同类型的另一个指针，但增加或删除了指针所指的对象类型的限定 符(参见 A.4.4 节和 A.8.2 节)的情况除外。如果增加了限定符，则新指针与原指针等价，不 同的是增加了限定符带来的限制。如果删除了限定符，则对底层对象的运算仍受实际声明中 的限定符的限制。
最后，指向一个函数的指针可以转换为指向另一个函数的指针。调用转换后指针所指的 函数的结果依赖于具体的实现。但是，如果转换后的指针被重新转换为原来的类型，则结果 与原来的指针一致。
A.6.7              void
void 对象的(不存在的)值不能够以任何方式使用，也不能被显式或隐式地转换为任一 非空类型。因为空(void)表达式表示一个不存在的值，这样的表达式只可以用在不需要值 的地方，例如作为一个表达式语句(参见 A.9.2 节)或作为逗号运算符的左操作数(参见 A.7.18 节)。
可以通过强制类型转换将表达式转换为 void 类型。例如，在表达式语句中，一个空的强 制类型转换将丢掉函数调用的返回值。
说明:void 没有在本书的第 1 版中出现，但是在本书第 1 版出版后，它一直被广泛使用 着。
A.6.8              指向 void 的指针
指向任何对象的指针都可以转换为 void *类型，且不会丢失信息。如果将结果再转换为 初始指针类型，则可以恢复初始指针。我们在 A.6.6 节中讨论过，执行指针到指针的转换时， 一般需要显式的强制转换，这里所不同的是，指针可以被赋值为 void *类型的指针，也可以 赋值给 void *类型的指针，并可与 void *类型的指针进行比较。
说明:对 void *指针的解释是新增加的。以前，char *指针扮演着通用指针的角色。 ANSI 标准特别允许 void *类型的指针与其它对象指针在赋值表达式和关系表达式中混用， 而对其它类型指针的混用则要求进行显式强制类型转换。
A.7 表达式
本节中各主要小节的顺序就代表了表达式运算符的优先级，我们将依次按照从高到低的 优先级介绍。举个例子，按照这种关系，A.7.1 至 A.7.6 节中定义的表达式可以用作加法运算 符+(参见 A.7.7 节)的操作数。在每一小节中，各个运算符的优先级相同。每个小节中还将 讨论该节涉及到的运算符的左、右结合性。A.13 节中给出的语法综合了运算符的优先级和结 合性。
运算符的优先级和结合性有明确的规定，但是，除少数例外情况外，表达式的求值次序
没有定义，甚至某些有副作用的子表达式也没有定义。也就是说，除非运算符的定义保证了 其操作数按某一特定顺序求值，否则，具体的实现可以自由选择任一求值次序，甚至可以交 换求值次序。但是，每个运算符将其操作数生成的值结合起来的方式与表达式的语法分析方 式是兼容的。
说明:该规则废除了原先的一个规则，即:当表达式中的运算符在数学上满足交换律和 结合律时，可以对表达式重新排序，但是，在计算时可能会不满足结合律。这个改变仅影响 浮点数在接近其精度限制时的计算以及可能发生溢出的情况。
C 语言没有定义表达式求值过程中的溢出、除法检查和其它异常的处理。大多数现有 C 语言的实现在进行带符号整型表达式的求值以及赋值时忽略溢出异常，但并不是所有的实现 都这么做。对除数为 0 和所有浮点异常的处理，不同的实现采用不同的方式，有时候可以用 非标准库函数进行调整。
A.7.1               指针生成
对于某类型 T，如果某表达式或子表达式的类型为“ T 类型的数组"，则此表达式的值是 指向数组中第一个对象的指针，并且此表达式的类型将被转换为"指向 T 类型的指针"。如果 此表达式是一元运算符&或 sizeof，则不会进行转换。类似地，除非表达式被用作&运算符 的操作数，否则，类型为"返回 T 类型值的函数"的表达式将被转换为"指向返回 T 类型值 的函数的指针"类型。
A.7.2              初等表达式
初等表达式包括标识符、常量、字符串或带括号的表达式。
初等表达式:
标识符 常量 字符串
(表达式)
如果按照下面的方式对标识符进行适当的声明，该标识符就是初等表达式。其类型由其 声明指定。如果标识符引用一个对象(参见 A.5 节)，并且其类型是算术类型、结构、联合或 指针，那么它就是一个左值。
常量是初等表达式，其类型同其形式有关。更详细的信息，参见 A.2.5 节中的讨论。 字符串字面值是初等表达式。它的初始类型为“    char 类型的数组"类型(对于宽字符字
符串，则为“ wchar_t 类型的数组"类型)，但遵循 A.7.1 节中的规则。它通常被修改为"指
向 char 类型(或 wchar_t 类型)的指针"类型，其结果是指向字符串中第一个字符的指针。
某些初始化程序中不进行这样的转换，详细信息，参见 A.8.7 节。
用括号括起来的表达式是初等表达式，它的类型和值与无括号的表达式相同。此表达式 是否是左值不受括号的影响。
A.7.3              后缀表达式
后缀表达式中的运算符遵循从左到右的结合规则。
后级表达式:
初等表达式 后级表达式[表达式] 后级表达式(参数表达式表 
o
p
t
 ) 后级表达式.标识符 后级表达式•>标识符 后级表达式++ 后缎表达式••
参数表达式表: 赋值表达式
参数表达式表, 赋值表达式
1 数组引用 带下标的数组引用后缀表达式由一个后缀表达式后跟一个括在方括号中的表达式组成。
方括号前的后缀表达式的类型必须为"指向 T 类型的指针"，其中 T 为某种类型;方括号中表
达式的类型必须为整型。结果得到下标表达式的类型为 T。表达式 E1[E2]在定义上等同于
*((E1) + (E2))。有关数组引用的更多讨论，参见 A.8.6 节。
2 函数调用
函数调用由一个后缀表达式(称为函数标志符，function designator)后跟由圆括号括起来 的赋值表达式列表组成，其中的赋值表达式列表可能为空，并由逗号进行分隔，这些表达式 就是函数的参数。如果后缀表达式包含一个当前作用域中不存在的标识符，则此标识符将被 隐式地声明，等同于在执行此函数调用的最内层程序块中包含下列声明:
extern int 标识符()
该后缀表达式(在可能的隐式声明和指针生成之后，参见 A.7.1 节)的类型必须为"指向返回
T 类型的函数的指针"，其中 T 为某种类型，且函数调用的值的类型为 T。
说明:在第 1 版中，该类型被限制为"函数"类型，并且，通过指向函数的指针调用函 数时必须有一个显式的*运算符。ANSI 标准允许现有的一些编译器用同样的语法进行函数调 用和通过指向函数的指针进行函数调用。旧的语法仍然有效。
通常用术语"实际参数"表示传递给函数调用的表达式，而术语"形式参数"则用来表 示函数定义或函数声明中的输入对象(或标识符)。
在调用函数之前，函数的每个实际参数将被复制，所有的实际参数严格地按值传递。函 数可能会修改形式参数对象的值(即实际参数表达式的副本)，但这个修改不会影响实际参数 的值。但是，可以将指针作为实际参数传递，这样，函数便可以修改指针指向的对象的值。
可以通过两种方式声明函数。在新的声明方式中，形式参数的类型是显式声明的，并且 是函数类型的一部分，这种声明称为函数原型。在旧的方式中，不指定形式参数类型。有关 函数声明的讨论，参见 A.8.6 节和 A.10.1 节。
在函数调用的作用域中，如果函数是以旧式方式声明的，则按以下方式对每个实际参数 进行默认参数提升:对每个整型参数进行整型提升(参见  A.6.l  节);将每个  float 类型的参 数转换为 double 类型。如果调用时实际参数的数目与函数定义中形式参数的数目不等，或 者某个实际参数的类型提升后与相应的形式参数类型不一致，则函数调用的结果是未定义的。 类型一致性依赖于函数是以新式方式定义的还是以旧式方式定义的。如果是旧式的定义，则 比较经提升后函数调用中的实际参数类型和提升后的形式参数类型;如果是新式的定义，则 提升后的实际参数类型必须与没有提升的形式参数自身的类型保持一致。
在函数调用的作用域中，如果函数是以新式方式声明的，则实际参数将被转换为函数原 型中的相应形式参数类型，这个过程类似于赋值。实际参数数目必须与显式声明的形式参数 数目相同，除非函数声明的形式参数表以省略号(,  ...)结尾。在这种情况下，实际参数 的数目必须等于或超过形式参数的数目;对于尾部没有显式指定类型的形式参数，相应的实 际参数要进行默认的参数提升，提升方法同前面所述。如果函数是以旧式方式定义的，那么， 函数原型中每个形式参数的类型必须与函数定义中相应的形式参数类型一致(函数定义中的 形式参数类型经过参数提升后)。
说明:这些规则非常复杂，因为必须要考虑新旧式函数的混合使用。应尽可能避免新旧 式函数声明混合使用。
实际参数的求值次序没有指定。不同编译器的实现方式各不相同。但是，在进入函数前， 实际参数和函数标志符是完全求值的，包括所有的副作用。对任何函数都允许进行递归调用。
3 结构引用 后缀表达式后跟一个圆点和一个标识符仍是后缀表达式。第一个操作数表达式的类型必
须是结构或联合，标识符必须是结构或联合的成员的名字。结果值是结构或联合中命名的成
员，其类型是对应成员的类型。如果第一个表达式是一个左值，并且第二个表达式的类型不 是数组类型，则整个表达式是一个左值。
后缀表达式后跟一个箭头(由•和>组成)和一个标识符仍是后缀表达式。第一个操作数 表达式必须是一个指向结构或联合的指针，标识符必须是结构或联合的成员的名字。结果指 向指针表达式指向的结构或联合中命名的成员，结果类型是对应成员的类型。如果该类型不 是数组类型，则结果是一个左值。
因此，表达式 E1•>MOS 与(*E1).MOS 等价。结构和联合将在 A.8.3 节中讨论。 说明:在本书的第  1  版中，规定了这种表达式中成员的名字必须属于后级表达式指定的
结构或联合，但是，该规则并没有强制执行。最新的编译器和 ANSI 标准强制执行了这一规则。
4 后缀自增运算符与后缀自减运算符 后缀表达式后跟一个++或••运算符仍是一个后缀表达式。表达式的值就是操作数的值。
执行完该表达式后，操作数的值将加 1(++)或减 1(••)。操作数必须是一个左值。有关操
作数的限制和运算细节的详细信息，参见加法类运算符(A.7.7 节)和赋值类运算符(A.7.17
节)中的讨论。其结果不是左值。
A.7.4              一元运算符