余下的为25%
用#define定义符号常量。不用在意是否符合当前的税法。
8.修改练习7的假设a，让程序可以给出一个供选择的工资等级菜单。使
用switch完成工资等级选择。运行程序后，显示的菜单应该类似这样：
*****************************************************************
Enter the number corresponding to the desired pay rate or action:
1) $8.75/hr              2) $9.33/hr
3) $10.00/hr             4) $11.20/hr
5) quit
*****************************************************************
如果选择 1～4 其中的一个数字，程序应该询问用户工作的小时数。程
序要通过循环运行，除非用户输入 5。如果输入 1～5 以外的数字，程序应
提醒用户输入正确的选项，然后再重复显示菜单提示用户输入。使用#define
创建符号常量表示各工资等级和税率。
9.编写一个程序，只接受正整数输入，然后显示所有小于或等于该数的
素数。
10.1988年的美国联邦税收计划是近代最简单的税收方案。它分为4个类
别，每个类别有两个等级。
下面是该税收计划的摘要（美元数为应征税的收入）：
495
例如，一位工资为20000美元的单身纳税人，应缴纳税费
0.15×17850+0.28×（20000−17850）美元。编写一个程序，让用户指定缴纳
税金的种类和应纳税收入，然后计算税金。程序应通过循环让用户可以多次
输入。
11.ABC 邮购杂货店出售的洋蓟售价为 2.05 美元/磅，甜菜售价为 1.15
美元/磅，胡萝卜售价为 
1.09美元/磅。在添加运费之前，100美元的订单有
5%的打折优惠。少于或等于5磅的订单收取6.5美元的运费和包装费，5磅～
20磅的订单收取14美元的运费和包装费，超过20磅的订单在14美元的基础上
每续重1磅增加0.5美元。编写一个程序，在循环中用switch语句实现用户输
入不同的字母时有不同的响应，即输入a的响应是让用户输入洋蓟的磅数，b
是甜菜的磅数，c是胡萝卜的磅数，q 
是退出订购。程序要记录累计的重
量。即，如果用户输入 4 磅的甜菜，然后输入 5磅的甜菜，程序应报告9磅
的甜菜。然后，该程序要计算货物总价、折扣（如果有的话）、运费和包装
费。随后，程序应显示所有的购买信息：物品售价、订购的重量（单位：
磅）、订购的蔬菜费用、订单的总费用、折扣（如果有的话）、运费和包装
费，以及所有的费用总额。
496
第8章 字符输入/输出和输入验证
本章介绍以下内容：
更详细地介绍输入、输出以及缓冲输入和无缓冲输入的区别
如何通过键盘模拟文件结尾条件
如何使用重定向把程序和文件相连接
创建更友好的用户界面
在涉及计算机的话题时，我们经常会提到输入（input）和输出
（output）。我们谈论输入和输出设备（如键盘、U盘、扫描仪和激光打印
机），讲解如何处理输入数据和输出数据，讨论执行输入和输出任务的函
数。本章主要介绍用于输入和输出的函数（简称I/O函数）。
I/O函数（如printf()、scanf()、getchar()、putchar()等）负责把信息传送
到程序中。前几章简单介绍过这些函数，本章将详细介绍它们的基本概念。
同时，还会介绍如何设计与用户交互的界面。
最初，输入/输出函数不是C定义的一部分，C把开发这些函数的任务留
给编译器的实现者来完成。在实际应用中，UNIX 系统中的 C 实现为这些函
数提供了一个模型。ANSI C 库吸取成功的经验，把大量的UNIX I/O函数囊
括其中，包括一些我们曾经用过的。由于必须保证这些标准函数在不同的计
算机环境中能正常工作，所以它们很少使用某些特殊系统才有的特性。因
此，许多C供应商会利用硬件的特性，额外提供一些I/O函数。其他函数或函
数系列需要特殊的操作系统支持，如Winsows或Macintosh OS提供的特殊图
形界面。这些有针对性、非标准的函数让程序员能更有效地使用特定计算机
编写程序。本章只着重讲解所有系统都通用的标准 I/O 函数，用这些函数编
写的可移植程序很容易从一个系统移植到另一个系统。处理文件输入/输出
的程序也可以使用这些函数。
497
许多程序都有输入验证，即判断用户的输入是否与程序期望的输入匹
配。本章将演示一些与输入验证相关的问题和解决方案。
498
8.1 单字符I/O：getchar()和putchar()
第 7 章中提到过，getchar()和 putchar()每次只处理一个字符。你可能认
为这种方法实在太笨拙了，毕竟与我们的阅读方式相差甚远。但是，这种方
法很适合计算机。而且，这是绝大多数文本（即，普通文字）处理程序所用
的核心方法。为了帮助读者回忆这些函数的工作方式，请看程序清单8.1。
该程序获取从键盘输入的字符，并把这些字符发送到屏幕上。程序使用
while 循环，当读到#字符时停止。
程序清单8.1 echo.c程序
/* echo.c -- 重复输入 */
#include 
int main(void)
{
char ch;
while ((ch = getchar()) != '#')
putchar(ch);
return 0;
}
自从ANSI 
C标准发布以后，C就把stdio.h头文件与使用getchar()和
putchar()相关联，这就是为什么程序中要包含这个头文件的原因（其实，
getchar()和 
putchar()都不是真正的函数，它们被定义为供预处理器使用的
宏，我们在第16章中再详细讨论）。运行该程序后，与用户的交互如下：
Hello, there. I would[enter]
499
Hello, there. I would
like a #3 bag of potatoes.[enter]
like a
读者可能好奇，为何输入的字符能直接显示在屏幕上？如果用一个特殊
字符（如，#）来结束输入，就无法在文本中使用这个字符，是否有更好的
方法结束输入？要回答这些问题，首先要了解 C程序如何处理键盘输入，尤
其是缓冲和标准输入文件的概念。
500
8.2 缓冲区
如果在老式系统运行程序清单8.1，你输入文本时可能显示如下：
HHeelllloo,, tthheerree..II wwoouulldd[enter]
lliikkee aa #
以上行为是个例外。像这样回显用户输入的字符后立即重复打印该字符
是属于无缓冲（或直接）输入，即正在等待的程序可立即使用输入的字符。
对于该例，大部分系统在用户按下Enter键之前不会重复打印刚输入的字
符，这种输入形式属于缓冲输入。用户输入的字符被收集并储存在一个被称
为缓冲区（buffer）的临时存储区，按下Enter键后，程序才可使用用户输入
的字符。图8.1比较了这两种输入。
图8.1 缓冲输入和无缓冲输入
为什么要有缓冲区？首先，把若干字符作为一个块进行传输比逐个发送
这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错
501
误。当最后按下Enter键时，传输的是正确的输入。
虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例
如，在游戏中，你希望按下一个键就执行相应的指令。因此，缓冲输入和无
缓冲输入都有用武之地。
缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲
区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入
中。缓冲区的大小取决于系统，常见的大小是 512 字节和 4096字节。行缓
冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所
以在按下Enter键后才刷新缓冲区。
那么，使用缓冲输入还是无缓冲输入？ANSI C和后续的C标准都规定输
入是缓冲的，不过最初K&R把这个决定权交给了编译器的编写者。读者可
以运行echo.c程序观察输出的情况，了解所用的输出类型。
ANSI 
C决定把缓冲输入作为标准的原因是：一些计算机不允许无缓冲
输入。如果你的计算机允许无缓冲输入，那么你所用的C编译器很可能会提
供一个无缓冲输入的选项。例如，许多IBM PC兼容机的编译器都为支持无
缓冲输入提供一系列特殊的函数，其原型都在conio.h头文件中。这些函数包
括用于回显无缓冲输入的getche()函数和用于无回显无缓冲输入的getch()函数
（回显输入意味着用户输入的字符直接显示在屏幕上，无回显输入意味着击
键后对应的字符不显示）。UNIX系统使用另一种不同的方式控制缓冲。在
UNIX系统中，可以使用ioctl()函数（该函数属于UNIX库，但是不属于C标
准）指定待输入的类型，然后用getchar()执行相应的操作。在ANSI C中，用
setbuf()和setvbuf()函数（详见第13章）控制缓冲，但是受限于一些系统的内
部设置，这些函数可能不起作用。总之，ANSI没有提供调用无缓冲输入的
标准方式，这意味着是否能进行无缓冲输入取决于计算机系统。在这里要对
使用无缓冲输入的朋友说声抱歉，本书假设所有的输入都是缓冲输入。
502
8.3 结束键盘输入
在echo.c程序（程序清单8.1）中，只要输入的字符中不含#，那么程序
在读到#时才会结束。但是， 
#也是一个普通的字符，有时不可避免要用
到。应该用一个在文本中用不到的字符来标记输入完成，这样的字符不会无
意间出现在输入中，在你不希望结束程序的时候终止程序。C 的确提供了这
样的字符，不过在此之前，先来了解一下C处理文件的方式。
8.3.1 文件、流和键盘输入
文件（file）是存储器中储存信息的区域。通常，文件都保存在某种永
久存储器中（如，硬盘、U盘或DVD等）。毫无疑问，文件对于计算机系统
相当重要。例如，你编写的C程序就保存在文件中，用来编译C程序的程序
也保存在文件中。后者说明，某些程序需要访问指定的文件。当编译储存在
名为 echo.c 文件中的程序时，编译器打开echo.c文件并读取其中的内容。当
编译器处理完后，会关闭该文件。其他程序，例如文字处理器，不仅要打
开、读取和关闭文件，还要把数据写入文件。
C 是一门强大、灵活的语言，有许多用于打开、读取、写入和关闭文件
的库函数。从较低层面上，C可以使用主机操作系统的基本文件工具直接处
理文件，这些直接调用操作系统的函数被称为底层 I/O （low-level I/O）。
由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库，
ANSI 
C也不打算这样做。然而从较高层面上，C还可以通过标准I/O包
（standard I/O package）来处理文件。这涉及创建用于处理文件的标准模型
和一套标准I/O函数。在这一层面上，具体的C实现负责处理不同系统的差
异，以便用户使用统一的界面。
上面讨论的差异指的是什么？例如，不同的系统储存文件的方式不同。
有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处；有些
系统在文件中创建一份文件描述。在处理文件方面，有些系统使用单个换行
符标记行末尾，而其他系统可能使用回车符和换行符的组合来表示行末尾。
有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡
503
量。
如果使用标准 I/O 包，就不用考虑这些差异。因此，可以用 if (ch ==
)检查换行符。即使系统实际用的是回车符和换行符的组合来标记行
末尾，I/O函数会在两种表示法之间相互转换。
从概念上看，C程序处理的是流而不是直接处理文件。流（stream）是
一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的
输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相
关联，而且读写都通过流来完成。
第13章将更详细地讨论文件。本章着重理解C把输入和输出设备视为存
储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的
文件。stdin流表示键盘输入，stdout流表示屏幕输出。getchar()、putchar()、
printf()和scanf()函数都是标准I/O包的成员，处理这两个流。
以上讨论的内容说明，可以用处理文件的方式来处理键盘输入。例如，
程序读文件时要能检测文件的末尾才知道应在何处停止。因此，C 的输入函
数内置了文件结尾检测器。既然可以把键盘输入视为文件，那么也应该能使
用文件结尾检测器结束键盘输入。下面我们从文件开始，学习如何结束文
件。
8.3.2 文件结尾
计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的
一种方法是，在文件末尾放一个特殊的字符标记文件结尾。CP/M、IBM-
DOS和MS-DOS的文本文件曾经用过这种方法。如今，这些操作系统可以使
用内嵌的Ctrl+Z字符来标记文件结尾。这曾经是操作系统使用的唯一标记，
不过现在有一些其他的选择，例如记录文件的大小。所以现代的文本文件不
一定有嵌入的Ctrl+Z，但是如果有，该操作系统会将其视为一个文件结尾标
记。图8.2演示了这种方法。
504
图8.2 带文件结尾标记的文件
操作系统使用的另一种方法是储存文件大小的信息。如果文件有3000字
节，程序在读到3000字节时便达到文件的末尾。MS-DOS 及其相关系统使用
这种方法处理二进制文件，因为用这种方法可以在文件中储存所有的字符，
包括Ctrl+Z。新版的DOS也使用这种方法处理文本文件。UNIX使用这种方法
处理所有的文件。
无论操作系统实际使用何种方法检测文件结尾，在C语言中，用
getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF（end 
of
file的缩写）。scanf()函数检测到文件结尾时也返回EOF。通常， 
EOF定义
在stdio.h文件中：
#define EOF (-1)
为什么是-1？因为getchar()函数的返回值通常都介于0～127，这些值对
应标准字符集。但是，如果系统能识别扩展字符集，该函数的返回值可能在
0～255之间。无论哪种情况，-1都不对应任何字符，所以，该值可用于标记
文件结尾。
某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符
所产生的返回值不同。如果包含stdio.h文件，并使用EOF符号，就不必担心
EOF值不同的问题。这里关键要理解EOF是一个值，标志着检测到文件结
尾，并不是在文件中找得到的符号。
505
那么，如何在程序中使用EOF？把getchar()的返回值和EOF作比较。如
果两值不同，就说明没有到达文件结尾。也就是说，可以使用下面这样的表
达式：
while ((ch = getchar()) != EOF)
如果正在读取的是键盘输入不是文件会怎样？绝大部分系统（不是全
部）都有办法通过键盘模拟文件结尾条件。了解这些以后，读者可以重写程
序清单8.1的程序，如程序清单8.2所示。
程序清单8.2 echo_eof.c程序
/* echo_eof.c -- 重复输入，直到文件结尾 */
#include 
int main(void)
{
int ch;
while ((ch = getchar()) != EOF)
putchar(ch);
return 0;
}
注意下面几点。
不用定义EOF，因为stdio.h中已经定义过了。
不用担心EOF的实际值，因为EOF在stdio.h中用#define预处理指令定
义，可直接使用，不必再编写代码假定EOF为某值。
506
变量ch的类型从char变为int，因为char类型的变量只能表示0～255的无
符号整数，但是EOF的值是-1。还好，getchar()函数实际返回值的类型是
int，所以它可以读取EOF字符。如果实现使用有符号的char类型，也可以把
ch声明为char类型，但最好还是用更通用的形式。
由于getchar()函数的返回类型是int，如果把getchar()的返回值赋给char类
型的变量，一些编译器会警告可能丢失数据。
ch是整数不会影响putchar()，该函数仍然会打印等价的字符。
使用该程序进行键盘输入，要设法输入EOF字符。不能只输入字符
EOF，也不能只输入-1（输入-1会传送两个字符：一个连字符和一个数字
1）。正确的方法是，必须找出当前系统的要求。例如，在大多数UNIX和
Linux系统中，在一行开始处按下Ctrl+D会传输文件结尾信号。许多微型计算
机系统都把一行开始处的Ctrl+Z识别为文件结尾信号，一些系统把任意位置
的Ctrl+Z解释成文件结尾信号。
下面是在UNIX系统下运行echo_eof.c程序的缓冲示例：