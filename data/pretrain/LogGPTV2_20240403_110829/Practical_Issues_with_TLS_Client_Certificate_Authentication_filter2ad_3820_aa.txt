title:Practical Issues with TLS Client Certificate Authentication
author:Arnis Parsovs
Practical Issues with TLS Client Certiﬁcate
Authentication
Software Technology and Applications Competence Center, Estonia
Arnis Parsovs
University of Tartu, Estonia
PI:EMAIL
Abstract—The most widely used secure Internet communication
standard TLS (Transport Layer Security) has an optional client
certiﬁcate authentication feature that in theory has signiﬁcant
security advantages over HTML form-based password authenti-
cation. In this paper we discuss practical security and usability
issues related to TLS client certiﬁcate authentication stemming
from the server-side and browser implementations. In particular,
we analyze Apache’s mod_ssl implementation on the server
side and the most popular browsers – Mozilla Firefox, Google
Chrome and Microsoft Internet Explorer on the client side. We
complement our paper with a measurement study performed in
Estonia where TLS client certiﬁcate authentication is widely used.
We present our recommendations to improve the security and
usability of TLS client certiﬁcate authentication.
I.
INTRODUCTION
Use of the TLS protocol is a standard way to secure an
Internet connection between a client’s browser and HTTP
web servers. Most commonly, TLS is used to authenticate the
server, in order to assure the client that the communication is
being performed with a legitimate party and that the secrecy
and the integrity of all data exchanged between the client
and the server is ensured. To authenticate oneself to the
server, the client usually has to submit some identiﬁcation data
(such as a username) and secret information that is shared
between the client and the server (such as a password) over an
already established server-authenticated secure channel. There
are various ways in which this process can fail, ending up with
the client disclosing his shared secret to an attacker rather
than to a legitimate server. As a consequence, the attacker
can access the victim’s account on a legitimate server, obtain
the victim’s private information stored on the server, and
perform actions on the server with the privileges of the victim.
The attacker can obtain a shared secret in various ways, for
example: by phishing attacks; by compromising another web
service where the victim might have reused the same secret; by
tricking the victim into sending the secret over a channel that
is not protected by TLS; by compromising a trusted certiﬁcate
authority (CA), or by, in any other way, fraudulently obtaining
the certiﬁcate of a legitimate server signed by a trusted CA and
then using it in a man-in-the-middle (MITM) attack.
Permission(cid:1) to(cid:1) freely(cid:1) reproduce(cid:1) all(cid:1) or(cid:1) part(cid:1) of(cid:1) this(cid:1) paper(cid:1) for(cid:1) noncommercial(cid:1)
purposes(cid:1)is(cid:1)granted(cid:1)provided(cid:1)that(cid:1)copies(cid:1)bear(cid:1)this(cid:1)notice(cid:1)and(cid:1)the(cid:1)full(cid:1)citation(cid:1)
on(cid:1)the(cid:1)ﬁrst(cid:1)page.(cid:1)Reproduction(cid:1)for(cid:1)commercial(cid:1)purposes(cid:1)is(cid:1)strictly(cid:1)prohibited(cid:1)
without(cid:1)the(cid:1)prior(cid:1)written(cid:1)consent(cid:1)of(cid:1)the(cid:1)Internet(cid:1)Society,(cid:1)the(cid:1)ﬁrst-named(cid:1)author(cid:1)
(for(cid:1) reproduction(cid:1) of(cid:1) an(cid:1) entire(cid:1) paper(cid:1) only),(cid:1) and(cid:1) the(cid:1) author’s(cid:1) employer(cid:1) if(cid:1) the(cid:1)
paper(cid:1)was(cid:1)prepared(cid:1)within(cid:1)the(cid:1)scope(cid:1)of(cid:1)employment.
NDSS(cid:1)’14,(cid:1)23-26(cid:1)February(cid:1)2014,(cid:1)San(cid:1)Diego,(cid:1)CA,(cid:1)USA
Copyright(cid:1)2014(cid:1)Internet(cid:1)Society,(cid:1)ISBN(cid:1)1-891562-35-5
http://dx.doi.org/(cid:18)(cid:17)(cid:15)(cid:18)(cid:21)(cid:24)(cid:19)(cid:19)(cid:16)(cid:79)(cid:69)(cid:84)(cid:84)(cid:15)(cid:19)(cid:17)(cid:18)(cid:21)(cid:15)(cid:19)(cid:20)(cid:17)(cid:20)(cid:23)
Active security research is being conducted to improve
password security, educate users on how to resist phishing
attacks, and to ﬁx CA trust issues [1], [2]. However, the attacks
mentioned above can be prevented or their impact can be
greatly reduced by using TLS client certiﬁcate authentication
(CCA), since the TLS CCA on the TLS protocol level protects
the client’s account on a legitimate server from a MITM
attacker even in the case of a very powerful attacker who has
obtained a valid certiﬁcate signed by a trusted CA and who
thus is able to impersonate the legitimate server. We believe
that TLS CCA has great potential for improving Internet
security, and therefore in this paper we discuss current issues
with TLS CCA and provide solutions that will improve the
security of TLS CCA and enable its usage on a larger scale.
With this paper, we make the following contributions:
• We provide the ﬁrst systematic analysis of previously
known and less known issues that are related to deploy-
ing TLS CCA in practice.
• We present a detailed report of a measurement study in
which the TLS CCA deployments of 87 Estonian service
providers are analyzed.
• We give a list of recommendations on how to solve the
problems identiﬁed to improve and facilitate the use of
TLS CCA.
The rest of the paper is organized as follows. Section II
provides a description of the TLS protocol
in a server-
authenticated and client-authenticated setting, and gives a brief
security analysis of the protocol. Section III discusses TLS
CCA-related issues. Section IV analyzes the measurement
study of Estonian service providers who provide the TLS CCA
option. Our recommendations for both the client and server
side are provided in Section V. The related work is discussed
in Section VI. Section VII concludes the paper.
II. TLS OVERVIEW
The TLS protocol and its predecessor, SSL (Secure Sockets
Layer), have several versions. In this paper, when referring to
the TLS protocol we mean the most widely supported TLS
version 1.0 [3]. The description given here applies also to the
latest protocol versions 1.1 and 1.2 since they do not introduce
any changes related to TLS CCA. Previous versions SSL 2.0
and SSL 3.0 differ only by their behavior when the client does
not want to perform CCA (no_certificate alert message
is sent instead of an empty client Certificate message).
A. Server-authenticated TLS Handshake
Fig. 1 shows protocol messages exchanged between a client
and server during TLS protocol negotiation (for simplicity, we
cover only RSA key exchange mechanism). Before encrypted
and integrity protected application data can be exchanged, the
TLS handshake has to be completed to negotiate commonly
supported cipher suites and other protocol parameters.
A TLS connection is initiated by the client’s ClientHello
message, which contains a list of cipher suites that
the
client supports and the client’s randomness which is unpre-
dictable for every TLS connection. The server replies with
the ServerHello message, which contains the server’s
randomness and one cipher suite selected from the client’s
ClientHello message. This cipher suite will be used for the
TLS session key exchange, encryption and integrity protection.
Then, in the Certificate message the server provides one
or more X.509 certiﬁcates that should be used by the client
to build the certiﬁcate chain. The ﬁrst certiﬁcate given in the
server’s Certificate message is assumed to be the server’s
certiﬁcate to which a corresponding private key is in the
server’s possession. The server ﬁnishes its round by sending
a ServerHelloDone message. In turn, the client generates
a random value – the pre-master secret which should be used
by both parties to derive symmetric keys used for the chosen
cipher suite – and encrypts it with the server’s public key
obtained from the server’s certiﬁcate. The encrypted pre-master
secret is sent to the server in the ClientKeyExchange
message. Then the client sends a ChangeCipherSpec mes-
sage which signals to the other party that all further messages
coming from the client will be protected by the negotiated
cipher suite and symmetric keys. The last handshake message
Finished is sent already encrypted and contains a hash
of all previous messages exchanged between the client and
the server. The server compares the decrypted hash with the
hash of all previous handshake messages. The client performs
a similar veriﬁcation with the server’s Finished message
and the exchange of encrypted application data can now be
performed.
Since the client encrypts the pre-master secret with the
public key of the server, only the server which possesses
the corresponding private key can decrypt the content of the
ClientKeyExchange message and thus obtain symmetric
keys which are used to protect further communication. In
general, TLS is secure against passive and active network
attacks as long as the client uses a public key that really
belongs to the server he is willing to communicate with.
In practice, public-key infrastructure (PKI) is used to verify
the authenticity of the public key provided in the server’s
Certificate message.
B. Client-authenticated TLS Handshake
In the client-authenticated TLS handshake the server ad-
ditionally requests
the client’s certiﬁcate by sending a
CertificateRequest message. This message contains a
list of distinguished names (DNs) of CAs that the server trusts.
This list may be used by the client to choose an appropriate
certiﬁcate that should be sent to the server in the client’s
Certificate message. The client’s Certificate mes-
sage, similarly to the server’s Certificate message, may
contain several certiﬁcates that may be used by the server to
build the certiﬁcate chain up to the CA that the server trusts.
If a client does not have a certiﬁcate or does not want to
ClientHello
ServerHello, Certiﬁcate, CertiﬁcateRequest, ServerHelloDone
Certiﬁcate, ClientKeyExchange, CertiﬁcateVerify
Client
[ChangeCipherSpec], Finished
[ChangeCipherSpec], Finished
Application Data
Server
Fig. 1: TLS handshake involving CCA and using RSA as key
exchange mechanism. The messages related to optional client
certiﬁcate authentication are emboldened.
perform CCA, the client can send an empty Certificate
message and then the server can decide whether to complete
the handshake without the client’s certiﬁcate.
The proof that the client has access to the private key that
corresponds to the public key in the client’s certiﬁcate is
given by calculating the hash of all the previous handshake
messages exchanged between the client and the server so far
and signing it with the client’s private key. This signature
is sent in the client’s CertificateVerify message. The
CertificateVerify message is omitted if the client has
sent an empty Certificate message.
The main advantage of TLS CCA compared to authentica-
tion methods in which a shared secret is disclosed to the server,
is that in the TLS CCA process a client proves to the server
that he has access to the private key, but the private key itself
is never disclosed to the server.
As can be seen, the signature given using the client’s private
key is bound to the client’s and the server’s randomness, the
server’s certiﬁcate and the encrypted pre-master secret sent by
the client. This means that even an attacker that has obtained
the signature in a MITM attack, cannot reuse the signature
in any other TLS handshake either with the legitimate server
or any other server. As a result, in cases where TLS CCA
is used, the attacker cannot impersonate the victim to the
legitimate server even if the attacker is able to impersonate
the legitimate server. A server impersonation attack is still
a problem if the attacker’s goal is to obtain sensitive data
from the user and not from the server, for example, in a
scenario where a user submits sensitive data to the server right
away, without being able to detect the impersonation attack in
another way (e.g., by visually noticing that the authenticated
environment provided by the attacker does not fully replicate
the personalized environment of the legitimate server).
Therefore, we see that, at least in theory, TLS CCA is
secure even against a very powerful attacker that is able to
successfully impersonate the legitimate server.
C. Renegotiation
The TLS server at any time can send the client a
HelloRequest message, thereby requesting the client to
initiate a new TLS handshake. In the renegotiation process the
messages of the new handshake are cryptographically protected
by the cipher suite negotiated in the previous handshake.
The practical use of renegotiation could be, for example, to
negotiate a stronger cipher suite or to perform CCA if the
client at the application level wants to access server resources
that must be protected by such security measures according to
the server’s local security policy.
2
The client can also initiate renegotiation by sending a
ClientHello message at any time, but there is no practical
reason for the client
therefore client-initiated
renegotiations are usually disabled by the servers.
D. Session Resumption
to do that;
The TLS session resumption feature allows an abbreviated
TLS handshake to be performed by skipping the key agreement
phase. The client can resume a TLS session by specifying
a session identiﬁer in the ClientHello message from the
TLS session negotiated previously. If the TLS server is willing
to resume the session, the server will reply with the same
session identiﬁer in the ServerHello message, otherwise a
new session identiﬁer will be included and a full handshake
will be performed. The abbreviated handshake saves time by
avoiding one round-trip across the network, plus one private
key operation on the server side (and one on the client side
if CCA has to be performed). Note that instead of storing the
session state on the server side, the TLS extension [4], which
is becoming widely supported, allows it to be stored encrypted
on the client side.
Session resumption is especially important when the private
key used for CCA is stored in a cryptographic token such as
a smart card. If session resumption is not used, the smart card
would have to perform a signing operation on every HTTP
request that initiates a new TLS connection. That would add
a signiﬁcant delay to the TLS handshake process and would
rapidly use up the private key use limit that is often enforced
by smart cards.
Note that the effectiveness of the TLS session resumption
also depends on the particular browser used and browsing
characteristics. For example, if the user navigates to another
page before a page has been fully loaded, the current TLS
session might be aborted and therefore would become non-
resumable.
III. PRACTICAL ISSUES
In this section we will summarize already known problems
and describe some new ones we have discovered. We follow
the convention that the issues described here, except when
explicitly described as our ﬁndings, are publicly known or have
been identiﬁed by others.
To enable TLS CCA on the server side, most service
providers use an Apache HTTP server with the module
mod_ssl [5], which relies on OpenSSL library to implement
TLS functionality. In this section we will analyze server side
issues considering only Apache mod_ssl and in particular
legacy branch 2.2 (version 2.2.22), which is currently shipped
with most operating systems. All CCA-related aspects de-
scribed here also apply to the latest stable branch 2.4 (with the
exception of client certiﬁcate revocation checking). Analysis of
less popular TLS CCA implementations such as IIS, Oracle-
AS, BigIP and Nginx we leave for future work.
On the client side we will analyze TLS CCA support as
implemented in the three most popular browsers – Mozilla
Firefox version 19.0 on Linux and Windows 7, Google Chrome
version 25.0 on Linux and Windows 7, and Microsoft Internet
Explorer (IE) version 9.0 on Windows 7.
A. Apache mod_ssl Conﬁguration
There are several mod_ssl conﬁguration directives that
help to conﬁgure CCA on the server side. However, we
found that the ofﬁcial mod_ssl documentation might give
an incorrect understanding of the behavior these directives
introduce; therefore, we will give a brief but clear description
here.
SSLVerifyClient is the main conﬁguration directive
regulating TLS CCA. This directive can be speciﬁed in a
server-wide context or per-directory context. When speciﬁed
in a server wide context, the setting applies to the initial TLS
handshake. If speciﬁed in a directory context, the server will
request TLS renegotiation after receiving an HTTP request for
resources in that directory. If the renegotiation is successful,
the request will be processed and the response will be sent
back over the renegotiated session.
require CCA, and thus
therefore the server will not
The default value none of SSLVerifyClient does
not require CCA;
include a
CertificateRequest message in the TLS handshake.
The value require will
the
CertificateRequest message will be included in the
handshake. If the client does not provide any certiﬁcate in
the client’s Certificate message or mod_ssl fails to
verify the certiﬁcate provided, the TLS handshake will be
aborted and a fatal TLS alert message will be sent to the
client. The value optional is the same as require, but
an empty client’s Certificate message will be tolerated.
The last possible value optional_no_ca is the same as
optional, but in addition it allows a client’s certiﬁcate to be
submitted that does not chain up to the CA trusted by the server
(because of a bug in OpenSSL [6] not yet valid or expired
non-self-signed client certiﬁcates will also be accepted). The
value optional_no_ca can be used to perform certiﬁcate
veriﬁcation at an application level or to implement PKI-less
public-key authentication that uses X.509 certiﬁcates as a
public-key transport (see Section III-J).
The SSLCACertificateFile directive speciﬁes a loca-
tion where self-signed root CA certiﬁcates trusted by the server
and their intermediate CA certiﬁcates are located.
The SSLVerifyDepth directive sets a limit for the length
that a certiﬁcate chain built in veriﬁcation process may have.
The SSLCADNRequestFile directive speciﬁes a location
of certiﬁcates which will be used to build a list of DNs that will
be sent in the server’s CertificateRequest handshake
message. If this directive is not set, the DNs of certiﬁcates in
SSLCACertificateFile will be used for this purpose.
After a successful TLS handshake, the mod_ssl will set
environment variables that can be used by the server-side
application to perform further authorization based on the
data from CCA. For example, variable SSL_CLIENT_CERT
will contain the PEM-encoded client certiﬁcate, and variable
SSL_CLIENT_VERIFY will contain the value:
• NONE: if the client certiﬁcate was not provided.
• SUCCESS:
• GENEROUS:
if client certiﬁcate veriﬁcation using the
SSLCACertificateFile trust store was successful.
to
certiﬁcate
optional_no_ca
did not
chain up to the CA speciﬁed in the
(because
SSLCACertificateFile
of mod_ssl bug [7] and [8] this is not always the
case).
if SSLVerifyClient is
client
store
trust
and
the
set
• FAILED:reason: contrary to the ofﬁcial documenta-
tion this value is not used.
3
B. Veriﬁcation
Certiﬁcate veriﬁcation is performed by OpenSSL using the
veriﬁcation algorithm described in [9]. Certiﬁcates speciﬁed in
SSLCACertificateFile are loaded into OpenSSL trust
store. It is important to emphasize here that for a successful
veriﬁcation the client certiﬁcate chain must not only build up
to a certiﬁcate found in the trust store, but this certiﬁcate
must also be self-signed. In addition, note that OpenSSL will
use extra certiﬁcates provided in the client’s Certificate
message in building the certiﬁcate chain. As a result, the
conﬁguration options provided by mod_ssl are not sufﬁcient
to implement CCA securely in an advanced public-key infras-
tructure setting without performing additional veriﬁcation at
the application level.
For instance, the Estonian CA “AS Sertiﬁtseerimiskeskus”
(SK) has a root certiﬁcate and several intermediate CA cer-
tiﬁcates, but only one particular intermediate CA issues au-
thentication certiﬁcates for natural persons that are loaded into
an Estonian ID card (a smart card storing corresponding RSA
keys). A straightforward approach, as instructed by SK [10], to
put into SSLCACertificateFile the SK root certiﬁcate
and the certiﬁcate of an intermediate CA issuing ID card
authentication certiﬁcates, will actually not guarantee that
in the case of successful authentication the accepted client
certiﬁcate will be signed by that particular intermediate CA.
The veriﬁcation process will also be successful in the case
where a client certiﬁcate is issued by SK root CA directly or
by any other intermediate CA issued by the SK root CA.
This can be exploited in practice by, for example, compro-
mising some other intermediate CA that is used for other pur-
poses (e.g., testing) and therefore has weaker protection, or by
fraudulently obtaining a certiﬁcate from another intermediate
CA that is meant to be used in a different context and thereby
has a lower assurance level and less stringent requirements for
identity veriﬁcation in the registration process. Finally, it might
hold that intermediate CAs are operated by mutually hostile