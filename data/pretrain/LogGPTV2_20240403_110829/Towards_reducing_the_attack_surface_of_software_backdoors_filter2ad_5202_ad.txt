access bypassing the authentication process.
Y5 Credentials stealing 1 : validated credentials are stored
and made available via a hidden command.
Y6 Credentials stealing 2 : validated credentials are sent
via DNS requests to a remote server.
Y7 Self-modifying authentication: in case of a certain pro-
cess ID, the central authentication function is rewrit-
ten on startup of the application to accept arbitrary
passwords.
Y8 Authentication module: a malicious auth. module.
We analyzed a version of ProFTPD containing this back-
doors on Weasel’s supported platforms x86, x64 and MIPS-
32. Since the high-level results were identical for all plat-
forms, we discuss them together (concrete numbers apply at
least to the x64 version). We demonstrate that it is possible
to reliably detect or to disable backdoors Y1–Y6, substanti-
ating our approach to reduce the attack surface.
We cannot cope with backdoors Y7 and Y8: Backdoor Y7
can only be detected when during testing by chance a case
is encountered where the authentication function is actually
being overwritten (i.e., the backdoor triggers on a certain
process ID). Backdoor Y8 can not be identiﬁed as Weasel
currently does not evaluate dynamically loaded modules.
Authentication.
The decision tree computed from the valid-pw and invalid-
pw protocol runs is depicted in Figure 6. On the function
level, four deciders are identiﬁed, with auth_pass() with
78 deciders on basic block level, 25 handler functions for
valid-pw and the 1st scoring rank being clearly dominant.
Though, three of the eleven backdoors are located in the de-
cider function pr_auth_authenticate(), which only leads
to a single handler function (do_back()) for valid-pw. This
handler function belongs to backdoor Y6 and stores cre-
dentials once they are successfully validated. The function
can automatically be identiﬁed as highly suspicious, as it
(among other activities) statically calls the standard func-
tions mmap(), shm_open(), socket(), and sendto(). Two of
the nine cold decider basic blocks in pr_auth_authenticate()
lead to the implementations of backdoors Y2 and Y3, respec-
tively. Thus cutting cold edges in the identiﬁed deciders
would eﬀectively render these backdoors non-functional.
In the x86 version of our modiﬁed ProFTPD server the
code implementing the “happy hour” backdoor (Y2) in pr_au-
th_authenticate() uses the conditional instruction CMOVZ
to manipulate the outcome of the function. This underlines
the need to consider implicit edges when examining a func-
tion’s CFG since we would otherwise overlook this case.
Figure 6: Decision tree of the authentication process
of ProFTPD.
Command Dispatching.
Weasel’s protocol description of FTP was modelled ac-
cording to RFC 959 [29] and contains 34 commands (e.g.,
HELP and MKD). The function level decision tree consists of
six deciders (of which pr_cmd_dispatch_phase() ranks 1st)
and 60 handlers. Out of those handlers, 43 are exclusive to
a single protocol run. By manual analysis it can be veriﬁed
that these exclusive handlers indeed implement each of the
34 commands. For the majority of commands there exists
exactly one exclusive handler. Subsequently, it is easily pos-
sible to automatically identify the backdoor of our running
example (Y1): among the external functions reachable from
HELP command’s only exclusive handler core_help() in the
static CFG are the aforementioned in this context highly
suspicious ones setegid(), seteuid() and system(). Ac-
cordingly, the corresponding HELP command can be iden-
tiﬁed as suspicious and further defensive measures can be
applied.
Weasel automatically and correctly identiﬁes the address-
es and sizes of exactly ﬁve function pointer tables in the ad-
dress space of the respective ProFTPD process: core_cmdtab,
xfer_cmdtab, auth_cmdtab, ls_cmdtab, and delay_cmdtab.
The ﬁrst one is the largest and contains 35 entries describ-
ing the core set of the commands supported by ProFTPD.
Eight entries in core_cmdtab contain function pointers that
are not contained in any of the recorded traces. By exam-
ining the respective entries in the table in the binary pro-
gram, they can already be identiﬁed to be corresponding to
the following commands: EPRT, EPSV, MDTM, SIZE, DOWNLOAD,
UPLOAD, GSM and RSLV. While the ﬁrst four are known benign
FTP commands that are simply not deﬁned in RFC 959, the
last four belong to the backdoors Y4, Y5 and Y6. The other
four identiﬁed function pointer tables also partly contain
pointers to functions that were not encountered during test-
ing. These functions correspond either to known commands
(e.g., xfer_log_stor()) or the benign FTP command PROT,
which is not deﬁned in RFC 959 as well.
do_back()auth_pass()rank: 1stdecider BBs: 78handler BBs: 4pr_auth_authenticate()rank: 4thdecider BBs: 10handler BBs: 1backdoor 1backdoor 2backdoor 8record_failed_login()pw_auth()rank: 3rddecider BBs: 11handler BBs: 2pr_auth_check()rank: 5thdecider BBs: 6handler BBs: 125 functions_dispatch()rank: 2nddecider BBs: 16handler BBs: 78 functions2 functions8606. CONCLUSIONS
In this paper, we presented an approach towards the auto-
matic detection and disabling of certain types of backdoors
in server applications by carefully examining runtime traces
for diﬀerent protocol runs. Our implementation of the ap-
proach in the form of a tool called Weasel automatically
captures these traces by repeatedly invoking a server appli-
cation under test according to a formal, block-based speciﬁ-
cation of the respective protocol. As Weasel only relies on
gdbserver for the recording of traces, it is widely applicable
to a variety of platforms and we discussed several empirical
analysis results that demonstrate how Weasel can be used
to precisely detect relevant code parts and data structures
within a given binary application.
7. ACKNOWLEDGMENTS
We thank Andreas Maaß and Martin Steegmanns for im-
plementing the discussed artiﬁcial backdoors, Moritz Con-
tag for assisting with the development of our tool, and the
anonymous reviewers for helpful comments. This work has
been supported by the German Federal Ministry of Educa-
tion and Research (BMBF) under support code 16BP12302;
EUREKA-Project SASER.
8. REFERENCES
[1] GDB Remote Serial Protocol.
http://sourceware.org/gdb/onlinedocs/gdb/
Remote-Protocol.html.
[2] ProFTPD Backdoor Unauthorized Access
Vulnerability, 2010.
http://www.securityfocus.com/bid/45150.
[3] Backdoor Found In Arcadyan-based Wi-Fi Routers,
2012. http://it.slashdot.org/story/12/04/26/
1411229/backdoor-found-in-arcadyan-based-wi-
fi-routers.
[4] RuggedCom - Backdoor Accounts in my SCADA
network? You don’t say..., 2012. http:
//seclists.org/fulldisclosure/2012/Apr/277.
[5] Samsung printers contain hidden, hard-coded
management account, 2012. http://www.zdnet.com/
samsung-printers-contain-hidden-hard-coded-
management-account-7000007928/.
[6] D. Agrawal, S. Baktir, D. Karakoyunlu, P. Rohatgi,
and B. Sunar. Trojan Detection using IC
Fingerprinting. In IEEE Symposium on Security and
Privacy, 2007.
C. Wang, and D. Dagon, editors, Botnet Detection,
volume 36 of Advances in Information Security, pages
65–88. Springer, 2008.
[11] D. Brumley and D. Song. Privtrans: automatically
partitioning programs for privilege separation. In
USENIX Security Symposium, 2004.
[12] S. Dai, T. Wei, C. Zhang, T. Wang, Y. Ding, Z. Liang,
and W. Zou. A framework to eliminate backdoors
from response-computable authentication. In IEEE
Symposium on Security and Privacy, 2012.
[13] M. Dalton, C. Kozyrakis, and N. Zeldovich. Nemesis:
preventing authentication & access control
vulnerabilities in web applications. In USENIX
Security Symposium, 2009.
[14] L. Duﬂot. CPU Bugs, CPU Backdoors and
Consequences on Security. In European Symposium on
Research in Computer Security (ESORICS), 2008.
[15] S. Duquette. Linux/SSHDoor.A Backdoored SSH
daemon that steals passwords, jan 2013.
http://www.welivesecurity.com/2013/01/24/linux-
sshdoor-a-backdoored-ssh-daemon-that-steals-
passwords/.
[16] H. Flake. Structural comparison of executable objects.
In Conference on Detection of Intrusions and Malware
& Vulnerability Assessment (DIMVA), 2004.
[17] D. Gao, M. K. Reiter, and D. Song. Binhunt:
Automatically ﬁnding semantic diﬀerences in binary
programs. In Information and Communications
Security, pages 238–255. Springer, 2008.
[18] D. Geneiatakis, G. Portokalidis, V. P. Kemerlis, and
A. D. Keromytis. Adaptive defenses for commodity
software through virtual application partitioning. In
ACM Conference on Computer and Communications
Security (CCS), 2012.
[19] Y. L. Gwon, H. T. Kung, and D. Vlah. DISTROY:
detecting integrated circuit Trojans with compressive
measurements. In USENIX Workshop on Hot Topics
in Security, 2011.
[20] J. S. Havrilla. Borland/Inprise Interbase SQL
database server contains backdoor superuser account
with known password, 2001.
http://www.kb.cert.org/vuls/id/247371.
[21] M. Hicks, M. Finnicum, S. T. King, M. M. K. Martin,
and J. M. Smith. Overcoming an untrusted computing
base: Detecting and removing malicious hardware
automatically. In IEEE Symposium on Security and
Privacy, 2010.
[7] D. Aitel. An Introduction to SPIKE, the Fuzzer
[22] D. Kilpatrick. Privman: A library for partitioning
Creation Kit. www.blackhat.com/presentations/bh-
usa-02/bh-us-02-aitel-spike.ppt, 2002. Presented
at Black Hat US.
[8] P. Amini and A. Portnoy. Fuzzing Sucks! Introducing
Sulley Fuzzing Framework. pentest.cryptocity.net/
files/fuzzing/sulley/introducing_sulley.pdf,
2007. Presented at Black Hat US.
[9] A. Bittau, P. Marchenko, M. Handley, and B. Karp.
Wedge: Splitting Applications into Reduced-privilege
Compartments. In USENIX Symposium on Networked
Systems Design and Implementation, 2008.
[10] D. Brumley, C. Hartwig, Z. Liang, J. Newsome, D. X.
Song, and H. Yin. Automatically identifying
trigger-based behavior in malware. In W. Lee,
applications. In USENIX Annual Technical
Conference, FREENIX Track, 2003.
[23] J. C. King. Symbolic execution and program testing.
Communications of the ACM, 19(7):385–394, 1976.
[24] S. T. King, J. Tucek, A. Cozzie, C. Grier, W. Jiang,
and Y. Zhou. Designing and implementing malicious
hardware. In USENIX Workshop on Large-Scale
Exploits and Emergent Threats (LEET), 2008.
[25] J. Lee, T. Avgerinos, and D. Brumley. Tie: Principled
reverse engineering of types in binary programs. In
Symposium on Network and Distributed System
Security (NDSS), 2011.
861[26] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,
2 For each trace, determine the set of exclusive functions:
G. Lowney, S. Wallace, V. J. Reddi, and
K. Hazelwood. Pin: building customized program
analysis tools with dynamic instrumentation. In ACM
SIGPLAN Conference on Programming Language
Design and Implementation (PLDI), 2005.
[27] H. D. Moore. Shiny Old VxWorks Vulnerabilities,
2010. https://community.rapid7.com/community/
metasploit/blog/2010/08/02/shiny-old-vxworks-
vulnerabilities.
[28] D. G. Murray and S. Hand. Privilege separation made
easy: trusting small libraries not big processes. In
European Workshop on System Security (EuroSec),
2008.
[29] J. Postel and J. Reynolds. File Transfer Protocol.
RFC 959 (INTERNET STANDARD), Oct. 1985.
Updated by RFCs 2228, 2640, 2773, 3659, 5797.
[30] N. Provos, M. Friedl, and P. Honeyman. Preventing
privilege escalation. In USENIX Security Symposium,
2003.
[31] A. Slowinska, T. Stancescu, and H. Bos. Howard: A
dynamic excavator for reverse engineering data
structures. In Symposium on Network and Distributed
System Security (NDSS), 2011.
[32] S. Sparks, S. Embleton, and C. C. Zou. A chipset level
network backdoor: bypassing host-based ﬁrewall &
ids. In ACM Symposium on Information, Computer
and Communications Security (ASIACCS), 2009.
[33] C. Sturton, M. Hicks, D. Wagner, and S. T. King.
Defeating UCI: Building Stealthy and Malicious
Hardware. In IEEE Symposium on Security and
Privacy, 2011.
[34] M. Tehranipoor and F. Koushanfar. A Survey of
Hardware Trojan Taxonomy and Detection. IEEE
Design & Test of Computers, 27(1), 2010.
[35] K. Thompson. Reﬂections on trusting trust. Commun.
ACM, 27(8), Aug. 1984.
[36] A. Waksman and S. Sethumadhavan. Silencing
hardware backdoors. In IEEE Symposium on Security
and Privacy, 2011.
[37] C. Wysopal, C. Eng, and T. Shields. Static detection
of application backdoors - detecting both malicious
software behavior and malicious indicators from the
static analysis of executable code. Datenschutz und
Datensicherheit, 34(3):149–155, 2010.
[38] T. Ylonen and C. Lonvick. The Secure Shell (SSH)
Authentication Protocol. RFC 4252 (Proposed
Standard), Jan. 2006.
[39] S. Zdancewic, L. Zheng, N. Nystrom, and A. C.
Myers. Secure program partitioning. ACM Trans.
Comput. Syst., 20(3):283–328, Aug. 2002.
[40] A. Zeller. Isolating cause-eﬀect chains from computer
programs. In ACM SIGSOFT Symposium on
Foundations of Software Engineering, 2002.
Appendix A. A-WEASEL ALGORITHM
Given a set of n traces on function level the A-WEASEL
algorithm recursively performs the following steps:
1 Determine the set of functions present in all n traces:
Scommon,f uncs = ST0,f uncs∩ST1,f uncs∩...∩STn−1,f uncs
STi,ex,f uncs = STi,f uncs\Scommon,f uncs
3 For each exclusive function in each set STi,ex,f uncs, de-
termine the minimum number of call stack levels needed
to distinguish between all of its invocations in the call
graph (CG) of Ti. We denote the minimum call stack
needed for distinction the signature call stack of an in-
vocation. A new set STi,ex,f uncs,callstack containing all
invocations with diﬀerent signature call stacks of all
functions in STi,ex,f uncs is created:
STi,ex,f uncs,callstack = δ(STi,ex,f uncs)
4 For each set STi,ex,f uncs,callstack, remove those invoca-
tions of exclusive functions from the set that are dom-
inated by other exclusive functions in the call graph of
the corresponding trace Ti:
STi,ex,f uncs,top = ϕ(STi,ex,f uncs,callstack)
Thus only top-level invocations of exclusive functions
of Ti are contained in the set.
5 Group all remaining invocations in all sets STi,ex,f uncs,top
according to their signature call stacks.
Invocations
with compatible signature call stacks are grouped to-
gether. Two signature call stacks are compatible if both
are equal or are equal up to the end of one of the two
call stack. Note how each group only corresponds to
one speciﬁc exclusive function and can at most contain
one speciﬁc invocation from each trace.
6 The immediate parent function in the common call
stack of a group’s exclusive function is necessarily in
set Scommon,f uncs and is added as decider to the de-
cision tree. Note that several groups can also share a
common decider function. In case a group consists of
only a single invocation from a single trace, the corre-
sponding exclusive function is added as handler to the
decision tree. Recursion ends in this case.
7 For each group, dynamically trace the corresponding
decider function for the group’s common signature call
stack for all applicable protocol runs on basic block
level. From the recorded basic block traces, the inter-
nal decision tree of the decider function for the signa-
ture call stack is generated by a similar but simpler
algorithm.
8 For each group recursively execute A-WEASEL. For
each invocation belonging to the group, a self-contain-
ed and minimal sub-trace T (cid:48)
i is cut from the original
trace Ti that starts with the corresponding signature
call stack. A-WEASEL is executed on the set of all
such sub-traces corresponding to the group.
I.e., A-
WEASEL is executed on the sub-CGs of the decider
identiﬁed for the group for all applying traces.
9 In case a decider function is found to be a leaf in the
resulting decision tree and does not exhibit any con-
trol ﬂow diﬀerences on basic block level for applicable
protocol runs, it is transformed into a common handler
function.
862