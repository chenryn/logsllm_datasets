使用二进位制编码格式的自定义 RPC 协议可以实现比通用的 JSON over REST 更好的效能。但是，RESTful API 还有其他一些显著的优点：方便实验和除错（只需使用 Web 浏览器或命令列工具 curl，无需任何程式码生成或软体安装即可向其请求），能被所有主流的程式语言和平台所支援，还有大量可用的工具（伺服器、快取、负载平衡器、代理、防火墙、监控、除错工具、测试工具等）的生态系统。
由于这些原因，REST 似乎是公共 API 的主要风格。RPC 框架的主要重点在于同一组织拥有的服务之间的请求，通常在同一资料中心内。
#### 资料编码与RPC的演化
对于可演化性，重要的是可以独立更改和部署 RPC 客户端和伺服器。与透过资料库流动的资料相比（如上一节所述），我们可以在透过服务进行资料流的情况下做一个简化的假设：假定所有的伺服器都会先更新，其次是所有的客户端。因此，你只需要在请求上具有向后相容性，并且对响应具有向前相容性。
RPC 方案的向后和向前相容性属性是从它使用的编码方式中继承而来：
* Thrift、gRPC（Protobuf）和 Avro RPC 可以根据相应编码格式的相容性规则进行演变。
* 在 SOAP 中，请求和响应是使用 XML 模式指定的。这些可以演变，但有一些微妙的陷阱【47】。
* RESTful API 通常使用 JSON（没有正式指定的模式）用于响应，以及用于请求的 JSON 或 URI 编码 / 表单编码的请求引数。新增可选的请求引数并向响应物件新增新的栏位通常被认为是保持相容性的改变。
由于 RPC 经常被用于跨越组织边界的通讯，所以服务的相容性变得更加困难，因此服务的提供者经常无法控制其客户，也不能强迫他们升级。因此，需要长期保持相容性，也许是无限期的。如果需要进行相容性更改，则服务提供商通常会并排维护多个版本的服务 API。
关于 API 版本化应该如何工作（即，客户端如何指示它想要使用哪个版本的 API）没有一致意见【48】）。对于 RESTful API，常用的方法是在 URL 或 HTTP Accept 头中使用版本号。对于使用 API 金钥来标识特定客户端的服务，另一种选择是将客户端请求的 API 版本储存在伺服器上，并允许透过单独的管理介面更新该版本选项【49】。
### 讯息传递中的资料流
我们一直在研究从一个过程到另一个过程的编码资料流的不同方式。到目前为止，我们已经讨论了 REST 和 RPC（其中一个程序透过网路向另一个程序传送请求并期望尽可能快的响应）以及资料库（一个程序写入编码资料，另一个程序在将来再次读取）。
在最后一节中，我们将简要介绍一下 RPC 和资料库之间的非同步讯息传递系统。它们与 RPC 类似，因为客户端的请求（通常称为讯息）以低延迟传送到另一个程序。它们与资料库类似，不是透过直接的网路连线传送讯息，而是透过称为讯息代理（也称为讯息伫列或面向讯息的中介软体）的中介来临时储存讯息。
与直接 RPC 相比，使用讯息代理有几个优点：
* 如果收件人不可用或过载，可以充当缓冲区，从而提高系统的可靠性。
* 它可以自动将讯息重新发送到已经崩溃的程序，从而防止讯息丢失。
* 避免发件人需要知道收件人的 IP 地址和埠号（这在虚拟机器经常出入的云部署中特别有用）。
* 它允许将一条讯息传送给多个收件人。
* 将发件人与收件人逻辑分离（发件人只是释出邮件，不关心使用者）。
然而，与 RPC 相比，差异在于讯息传递通讯通常是单向的：传送者通常不期望收到其讯息的回复。一个程序可能传送一个响应，但这通常是在一个单独的通道上完成的。这种通讯模式是非同步的：传送者不会等待讯息被传递，而只是传送它，然后忘记它。
#### 讯息代理
过去，**讯息代理（Message Broker）** 主要是 TIBCO、IBM WebSphere 和 webMethods 等公司的商业软体的秀场。最近像 RabbitMQ、ActiveMQ、HornetQ、NATS 和 Apache Kafka 这样的开源实现已经流行起来。我们将在 [第十一章](ch11.md) 中对它们进行更详细的比较。
详细的交付语义因实现和配置而异，但通常情况下，讯息代理的使用方式如下：一个程序将讯息传送到指定的伫列或主题，代理确保将讯息传递给那个伫列或主题的一个或多个消费者或订阅者。在同一主题上可以有许多生产者和许多消费者。
一个主题只提供单向资料流。但是，消费者本身可能会将讯息释出到另一个主题上（因此，可以将它们连结在一起，就像我们将在 [第十一章](ch11.md) 中看到的那样），或者传送给原始讯息的传送者使用的回复伫列（允许请求 / 响应资料流，类似于 RPC）。
讯息代理通常不会执行任何特定的资料模型 —— 讯息只是包含一些元资料的位元组序列，因此你可以使用任何编码格式。如果编码是向后和向前相容的，你可以灵活地对释出者和消费者的编码进行独立的修改，并以任意顺序进行部署。
如果消费者重新发布讯息到另一个主题，则可能需要小心保留未知栏位，以防止前面在资料库环境中描述的问题（[图 4-7](../img/fig4-7.png)）。
#### 分散式的Actor框架
Actor 模型是单个程序中并发的程式设计模型。逻辑被封装在 actor 中，而不是直接处理执行绪（以及竞争条件、锁定和死锁的相关问题）。每个 actor 通常代表一个客户或实体，它可能有一些本地状态（不与其他任何角色共享），它透过传送和接收非同步讯息与其他角色通讯。不保证讯息传送：在某些错误情况下，讯息将丢失。由于每个角色一次只能处理一条讯息，因此不需要担心执行绪，每个角色可以由框架独立排程。
在分散式 Actor 框架中，此程式设计模型用于跨多个节点伸缩应用程式。不管传送方和接收方是在同一个节点上还是在不同的节点上，都使用相同的讯息传递机制。如果它们在不同的节点上，则该讯息被透明地编码成位元组序列，透过网路传送，并在另一侧解码。
位置透明在 actor 模型中比在 RPC 中效果更好，因为 actor 模型已经假定讯息可能会丢失，即使在单个程序中也是如此。尽管网路上的延迟可能比同一个程序中的延迟更高，但是在使用 actor 模型时，本地和远端通讯之间的基本不匹配是较少的。
分散式的 Actor 框架实质上是将讯息代理和 actor 程式设计模型整合到一个框架中。但是，如果要执行基于 actor 的应用程式的滚动升级，则仍然需要担心向前和向后相容性问题，因为讯息可能会从执行新版本的节点发送到执行旧版本的节点，反之亦然。
三个流行的分散式 actor 框架处理讯息编码如下：
* 预设情况下，Akka 使用 Java 的内建序列化，不提供向前或向后相容性。但是，你可以用类似 Prototol Buffers 的东西替代它，从而获得滚动升级的能力【50】。
* Orleans 预设使用不支援滚动升级部署的自定义资料编码格式；要部署新版本的应用程式，你需要设定一个新的丛集，将流量从旧丛集迁移到新丛集，然后关闭旧丛集【51,52】。像 Akka 一样，可以使用自定义序列化外挂。
* 在 Erlang OTP 中，对记录模式进行更改是非常困难的（尽管系统具有许多为高可用性设计的功能）。滚动升级是可能的，但需要仔细计划【53】。一个新的实验性的 `maps` 资料型别（2014 年在 Erlang R17 中引入的类似于 JSON 的结构）可能使得这个资料型别在未来更容易【54】。
## 本章小结
在本章中，我们研究了将资料结构转换为网路中的位元组或磁碟上的位元组的几种方法。我们看到了这些编码的细节不仅影响其效率，更重要的是也影响了应用程式的体系结构和部署它们的选项。
特别是，许多服务需要支援滚动升级，其中新版本的服务逐步部署到少数节点，而不是同时部署到所有节点。滚动升级允许在不停机的情况下发布新版本的服务（从而鼓励在罕见的大型版本上频繁释出小型版本），并使部署风险降低（允许在影响大量使用者之前检测并回滚有故障的版本）。这些属性对于可演化性，以及对应用程式进行更改的容易性都是非常有利的。
在滚动升级期间，或出于各种其他原因，我们必须假设不同的节点正在执行我们的应用程式程式码的不同版本。因此，在系统周围流动的所有资料都是以提供向后相容性（新程式码可以读取旧资料）和向前相容性（旧程式码可以读取新资料）的方式进行编码是重要的。