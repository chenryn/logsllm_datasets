The 11,170,883 distinct RSA moduli yielded 2,314
distinct prime divisors, which divided 16,717 distinct
public keys. This allowed us to obtain private keys for
23,576 (0.40%) of the TLS certiﬁcates in our scan data,
which were served on 64,081 (0.50%) of the TLS hosts,
and 1,013 (0.02%) of the RSA SSH host keys, which were
served on 2,459 (0.027%) of the RSA SSH hosts.
The vast majority of the vulnerable keys appeared to be
system-generated certiﬁcates and SSH host keys used by
routers, ﬁrewalls, remote administration cards, and other
types of headless or embedded network devices. Only
two of the factorable TLS certiﬁcates had been signed by
a browser trusted authority and both have expired. Some
devices generated factorable keys both for TLS and SSH,
and a handful of devices shared common factors across
SSH and TLS keys.
We classiﬁed these factorable keys in a similar manner
to the repeated keys. We found that, in all but a small
number of cases, the TLS certiﬁcates and SSH host keys
divisible by a common factor all belonged to a particular
manufacturer, which we were able to identify in most
cases using the techniques described in Section 3.2.
We identiﬁed devices from 41 manufacturers in this
way, which constituted 99% of the hosts that generated
RSA keys we could factor. The devices range from 100%
(576 of 576 devices) vulnerable to 0.01% vulnerable
(2 out of 10,932). As with repeated keys, we would
not expect to see well-generated cofactorable keys; any
device model observed generating factorable keys should
be treated as potentially vulnerable.
The majority of the devices serving factorable keys
were Juniper ﬁrewalls. We identiﬁed 46,993 of these
devices in our dataset, and we factored the keys for 12,688
(27%). Of these keys, 7,510 (59%) share a single common
divisor. The distribution of common factors among its
moduli is shown in Figure 3a.
The most remarkable devices were IBM Remote Server
Administration cards and BladeCenter devices, which
displayed a distribution of factors unlike any of the other
vulnerable devices we found. There were only 9 distinct
prime factors that had been used to generate the keys for
576 devices. Each device’s key was the product of two
100101102103Modulusfrequency050100Modulusfrequencyture collisions appeared to be from ADTran Total Access
business-grade phone/network routers and revealed pri-
vate keys for 62,807 (73%) out of 86,301 such hosts. Sev-
eral vulnerable device models, including the IBM RSA II
remote administration cards and Juniper NetScreen, also
generated factorable RSA keys.
While we collected multiple signatures from some SSH
hosts, 3,917 (89.7%) out of 4,365 of the collisions were
from different hosts that had generated the same long-
term key and also used the same ephemeral key during
the key exchange protocol. This problem compounds the
danger of the repeated key vulnerability: a single signa-
ture collision between any pair of hosts sharing the same
key at any point during runtime reveals the private key for
every host using that key. In our dataset we observed tens
of thousands of hosts using the same public key. While a
single host may never repeat an ephemeral key, two hosts
sharing a private key due to poor entropy can put each
others’ keys at risk.
We note that any estimation of vulnerability based on
our data is an extreme lower bound, as we gathered at
most two signatures from each host in our scans. It is
likely that many more private keys would be revealed if
we collected additional signatures.
5 Experimental Investigation
Based on the results the previous section, we conjectured
that the problems we observed were an implementational
phenomenon. To more deeply understand the causes, we
augmented our data analysis with experimental investiga-
tion of speciﬁc implementations. While there are many
independently vulnerable implementations, we chose to
examine three open-source cryptographic software com-
ponents that appeared frequently in the vulnerable popu-
lations.
5.1 Weak entropy and the Linux RNG
We conjectured that the cause for many of the entropy
problems we observed began with insufﬁcient random-
ness provided by the operating system. This led us to take
an in-depth look at the Linux random number generator
(RNG). We note that not every vulnerable key was gen-
erated on Linux; we also observed vulnerable keys on
FreeBSD and Windows systems, and similar vulnerabil-
ities to those we describe here have been reported with
BSD’s arc4random [36].
The Linux RNG maintains three entropy pools, each
with an associated counter that estimates how much
fresh entropy it has available. Fresh entropy from un-
predictable kernel sources is periodically mixed into the
Input pool. When processes read from /dev/random or
/dev/urandom, the kernel extracts the requested amount
Figure 4: Vulnerable DSA keys for one SSH device —
We identiﬁed 18,684 SSH DSA keys that appeared to
have been generated by Gigaset DSL routers, of which
16,575 were repeated at least once. Shown in red in this
log-log plot are 12,378 keys further compromised due to
repeated DSA signature values.
different primes from this list. The 36 possible moduli
that could be generated with this process were roughly
uniformly distributed, as shown in Figure 3b. In addition,
this was the only device we observed to generate RSA
moduli where both prime factors were shared with other
keys.
4.3 DSA signature weaknesses
The third class of entropy-related vulnerability that we
searched for was repeated ephemeral keys in DSA signa-
tures. As explained in Section 2.2, if a DSA key is used
to sign two different messages using the same ephemeral
key, then the long-term private key is immediately com-
putable from the public key and the signatures. The pres-
ence of this vulnerability indicates entropy problems at
later phases of operation, after initial key generation. We
searched for signatures from identical keys containing re-
peated r values. Then we used the method in Section 2.2
to compute the corresponding private keys.
Our combined SSH DSA scans collected 9,114,925
signatures (in most cases, two from each SSH host serving
a DSA-based key) of which 4,365 (0.05%) contained the
same r value as at least one other signature. 4,094 of
these signatures (94%) used the same r value and the
same public key. This allowed us to compute the 281
distinct private keys used to generate these signatures.
These compromised keys were served by 105,728 (1.6%)
of the SSH DSA hosts in our combined scans.
We clustered the vulnerable signatures by r values
and manufacturer. 2,026 (46%) of the colliding r val-
ues appeared to have been generated by Gigaset SX762
consumer-grade DSL routers and revealed private keys
for 17,349 (66%) of the 26,374 hosts we identiﬁed as
this device model (see Figure 4). Another 934 signa-
100101102103100102104PrivatekeyindexFrequencyKeyscompromisedbyrepeatedsignaturerandomnessFigure 5: Linux urandom boot-time entropy hole — We instrumented an Ubuntu Server 10.04 system to record its
estimate of the entropy contained in the Input entropy pool during a typical boot. Linux does not mix Input pool
entropy into the Nonblocking pool that supplies /dev/urandom until the Input pool exceeds a threshold of 192 bits
(blue horizontal line), which occurs here at 66 seconds post-boot. For comparison, we show the cumulative number
of bytes generated from the Nonblocking entropy pool; the vertical red line marks the time when OpenSSH seeds its
internal PRNG by reading from urandom, well before this facility is ready for secure use.
of entropy from the Input pool and mixes it into the Block-
ing or Nonblocking pool, respectively, and then extracts
bytes from the respective pool to return. If the input pool
does not contain enough entropy to satisfy the request,
the read from the Blocking pool blocks; the Nonblocking
pool read is satisﬁed immediately.
Entropy sources We experimented with the Linux
2.6.35 kernel to exhaustively determine the sources of
entropy used by the RNG. To do this, we traced through
the kernel source code and systematically disabled en-
tropy sources until the RNG output was repeatable. All of
the entropy sources we found are greatly weakened under
certain operating conditions.
The explicit entropy sources we observed are the unini-
tialized contents of the pool buffers when the kernel starts,
the startup clock time in nanosecond resolution, input
event and disk access timings, and entropy saved across
boots to a local ﬁle. Surprisingly, modern Linux systems
no longer collect entropy from IRQ timings.
The ﬁnal and most interesting entropy source was one
that we have not seen documented elsewhere. The devel-
opers chose not to put a lock around the mixing procedure
when entropy is extracted from the pool, and, as a re-
sult, if two threads extract entropy concurrently, the pool
contents may change anywhere in the middle of the hash
computation, resulting in the introduction of signiﬁcant
(but uncredited) entropy to the pool.
The removal of IRQs as an entropy source has likely
exacerbated RNG problems in headless and embedded
devices, which often lack human input devices, disks, and
multiple cores. If they do, the only source of entropy—if
there are any at all—may be the time of boot.
Experiment
To test whether Linux’s /dev/urandom
can produce repeatable output in conditions resembling
the initial boot of a headless or embedded networked de-
vice, we modiﬁed the 2.6.35 kernel to add instrumentation
to the RNG and disable certain entropy sources to simu-
late a cold boot on a low-end machine without a working
clock.
We experimented with this kernel on a Dell Optiplex
980 system using a fresh installation of Ubuntu server
10.04.4. The machine was conﬁgured with a Core i7 CPU,
4 GB RAM, a 32 GB SSD, and a USB keyboard. It was
attached to a university ofﬁce LAN and obtained an IP ad-
dress using DHCP. With this conﬁguration, we performed
1,000 unattended boots. Each time, we read 32 bytes
from urandom at the point in the initialization process
where the SSH server would normally start. Under these
conditions, we found that the output of /dev/urandom
was entirely predictable and repeatable.
The kernel maintains a reserve threshold for the Input
pool, and no data is copied into the Nonblocking pool un-
til the Input pool has been credited with at least that much
entropy (192 bits, for our kernel). Figure 5 shows the
cumulative amount of entropy credited to the Input pool
during a typical bootup from our tests. (Note that none
of the entropy sources we disabled would have resulted
in more entropy being credited to the pool.) The credited
entropy does not cross this reserve threshold until more
than a minute after boot, well after the SSH server and
other startup processes have launched. Although Ubuntu
tries to restore entropy saved during the last shutdown,
this happens slightly after the point when sshd ﬁrst reads
from urandom. With no entropic inputs, urandom pro-
duces a deterministic output stream.
0510152025303540455055606570050100150200250SSHurandomread(32)ThresholdtoaddkernelrandomnessTimesinceboot(s)Inputpoolentropy(bits)05,00010,00015,00020,00025,000BytesreadfromnonblockingpoolInputpoolentropyestimateInputthresholdtoupdateentropypoolBytesreadfromnonblockingpoolSSHprocessseedsfrom/dev/urandomFigure 6: OpenSSL generating factorable keys — We hypothesized that OpenSSL can generate factorable keys under
low-entropy conditions due to slight asynchronicity between the key generation process and the real-time clock, we
generated 14 million RSA keys using controlled entropy sources for a range of starting clock times. Each square in the
plot indicates the fraction of 100 generated keys that could we could factor. In many cases (white), keys are repeated
but never share primes. After a sudden phase change, factorable keys occur during a range leading up to the second
boundary, and that range increases as we simulate machines with slower execution speeds.
Boot-time entropy hole
The entropy sources we dis-
abled would likely be missing in some headless and em-
bedded systems, particularly on ﬁrst boot. This means that
there is a window of vulnerability—a boot-time entropy
hole—during which Linux’s urandom may be entirely
predictable, at least for single-core systems. If processes
generate long-term cryptographic keys or maintain their
own entropy pools seeded only with entropy gathered
during this window, those keys are likely to be vulnerable.
The risk is particularly high for unattended systems that
ship with preconﬁgured operating systems and generate
SSH or TLS keys the ﬁrst time the respective daemons
start during the initial boot.
On stock Ubuntu systems, these risks are somewhat
mitigated: TLS keys must be generated manually, and
OpenSSH host keys are generated during package installa-
tion, which is likely to be late in the install process, giving
the system time to collect sufﬁcient entropy. However, on
the Fedora, Red Hat Enterprise Linux (RHEL), and Cen-
tOS Linux distributions, OpenSSH is installed by default,
and host keys are generated on ﬁrst boot. We experi-
mented further with RHEL 5 and 6 to determine whether
host keys on these systems might be compromised, and
observed that sufﬁcient entropy had been collected at the
time of key generation by a slim margin. We believe
that most server systems running these distributions are
safe, particularly since they likely have multiple cores
and gather additional entropy from physical concurrency.
However, it is possible that other distributions and cus-
tomized installations do not collect sufﬁcient entropy on
startup and generate weak keys on ﬁrst boot.
5.2 Factorable RSA keys and OpenSSL
One interesting question raised by our vulnerability re-
sults is why factorable RSA keys occur at all. A naïve
implementation of RSA key generation would simply
seed a PRNG from the operating system’s entropy pool
and then use it to generate p and q. In this approach, we
would expect to see duplicate keys if the OS provided
the same seed, but factorable keys would be extremely
unlikely. What we see instead is that some devices seem
prone to generating keys with common factors. Another
curious feature is that although some of the most common
prime factors divided hundreds of different moduli, in
nearly all of these cases the second prime factor did not
divide any other keys.
One explanation for this pattern is that implementa-
tions updated their entropy pools in the middle of key
generation. In this case, the entropy pool states might
be identical as distinct key generation processes generate
the ﬁrst prime p and diverge while generating the second
prime q. In order to explore this theory, we studied the
source code of OpenSSL [14], one of the most widely
used open-source cryptographic libraries. OpenSSL is not
the only software library responsible for the problems we
observed, but we chose to examine it because the source
code is freely available and because of its popularity.
OpenSSL RSA key generation OpenSSL’s built-in
RSA key generator relies on an internal entropy pool main-
tained by OpenSSL. The entropy pool is seeded on ﬁrst
use with (on Linux) 32 bytes read from /dev/urandom,
the process ID, user ID, and the current time in seconds.
00.10.20.30.40.50.60.70.80.98162432Startingclocktimet0(seconds)Timedilationfactor(slower→)Fractionofkeysgeneratedthatwecouldfactor00.20.40.6clocktickOpenSSL provides a function named bnrand() to gen-
erate cryptographically-sized integers from the entropy
pool, which, on each call, mixes into the entropy pool the
current time in seconds, the process ID, and the possibly
uninitialized contents of a destination buffer.
The RSA key generation algorithm generates the
primes p and q using a randomized algorithm. During this
process, OpenSSL extracts entropy from the entropy pool
dozens to hundreds of times. Since we observed many
keys with one prime factor in common, we can conjecture
that multiple systems are starting with urandom and the
time in the same state and that the entropy pool states
diverge due to the addition of time during intermediate
steps of the key generation process.
We hypothesized that this process is hypersensitive to
small variations in where the boundary between seconds
falls. Slight variations in execution speed might cause the
wall clock tick to fall between different calls to bnrand(),
resulting in different execution paths. This can result in
several different behaviors, with three simple cases:
If the second never changes while
computing p and q, every execu-
tion will generate identical keys.
p
t
t+1
If the clock ticks while generating
p, both p and q diverge, yielding
distinct keys with no shared factors.
p
t+1
t
q
q
If instead the clock advances to the next second during the
generation of the second prime q, then two executions will
generate identical primes p but can
generate distinct primes q based on
exactly when the second changes.
q