gram. Then it randomly selects system calls from across
all program traces, distributing them evenly across the
synthetic programs, until it has pulled as many system
calls as Moonshine(I+E).
Lastly, we use the term default Syzkaller to describe
Syzkaller fuzzing without any seeds, using only it’s hard-
coded rules to generate input programs.
5.2 Can MoonShine discover new vulnera-
bilities? (RQ1)
Table 1 shows the vulnerabilities in the Linux kernel that
were discovered using MoonShine. Each vulnerability
was triggered during a fuzzing experiment that lasted 24
hours. Each experiment consisted of the following steps.
First, we generate two sets of distilled seeds using Moon-
shine(I+E) and MoonShine(E) on traces gathered from
all our seed programs. For each set of seeds, we fuzz
the latest kernel release candidate for 24 hours 3 times
each and do the same using the default Syzkaller. For
a vulnerability to be considered as caused by one set of
seeds, it must be triggered in at least two of the three
experiments and not by default Syzkaller. During each
experiment, we restricted Syzkaller to only fuzz the calls
contained in our traces to more accurately track the im-
pact of our seeds. We note that default Syzkaller was un-
able to ﬁnd any vulnerabilities during these experiments
but when using seeds generated by MoonShine it found
17.
Vulnerabilities Results. Of the 17 new vulnerabilities
we discovered, 10 of them were only discovered when
using seeds generated by Moonshine(I+E) and the av-
erage age of each was over 9 months. Two of the vul-
nerabilities we found in fs/iomap.c and iomap_dio_rw
were over 4 years old. We also note that each of the
bugs discovered using Moonshine(I+E) alone were con-
currency bugs that were triggered by Syzkaller schedul-
ing calls on different threads. We also note that our bugs
were found in core subsystems of the kernel, namely VFS
and net/core. We have reported all vulnerabilities to the
appropriate maintainers and 9 have already been ﬁxed.
Result 1: MoonShine found 17 new vulnerabilities
that default Syzkaller cannot ﬁnd out of which 10 vul-
nerabilities can only be found using implicit depen-
dency distillation.
Figure 4: Coverage achieved using Moonshine(I+E) and
MoonShine(E) and default Syzkaller in 24 hours of fuzzing.
Seed traces were obtained from the LTP, Kselftest, Glibc, and
Posix sources.
USENIX Association
27th USENIX Security Symposium    735
Subsystem
Module
Operation
Impact
Version
Introduced
Distill.
Method
BPF
bpf/devmap.c
BTRFS
fs/btrfs/ﬁle.c
dev_map_alloc()
btrfs_fallocate()
Illegal allocation size
Assert Failure
move_expired_inodes()
Use After Free
__jfs_setxattr()
Memory Corruption
net/ipv4/inet_connection_sock.c
inet_child_forget()
Use after Free
fs/fs-writeback.c
fs/jfs/xattr.c
net/core/stream.c
net/core/dst.c
net/nfc/nfc.h
net/socket.c
net/netﬁlter/nf_conntrack_core.c
init_conntrack()
Memory Leak
4.6
sk_kill_stream_queues()
Memory Corruption
dst_release()
NULL Pointer Deref
4.15-rc8
nfc_device_iter_exit()
NULL Pointer Deref
4.17-rc4
socket_setattr()
NULL Pointer Deref
Posix-timers
kernel/time/posix-cpu-timers.c
posix_cpu_timer_set()
Integer Overﬂow
fs/reiserfs/inode.c,
fs/reiserfs/ioctl.c,
fs/direct-io.c
Multiple
Deadlock
4.0
4.14
4.6
2.6
4.4
4.4
4.10
4.4
4.10
(I+E) & (E)
(I+E)
(I+E)
(I+E) & (E)
(I+E)
(I+E)
(I+E)
(I+E)
(I+E)
(I+E) & (E)
(I+E) & (E)
(I+E)
Ext4
JFS
Network
Network
Network
Network
Network
Network
Reiserfs
TTY
VFS
VFS
VFS
VFS
tty/serial/8250/8250_port.c
serial8250_console_putchar()
Kernel Hangs Indeﬁnitely
4.14-rc4
(I+E)
fs/iomap.c
lib/iov_iter.c
fs/pipe.c
iomap_dio_rw()
iov_iter_pipe()
pipe_set_size()
Data Corruption
Data Corruption
Integer Overﬂow
inotify_fsnotify.c
inotify_handle_event()
Memory Corruption
3.10
3.10
4.9
3.14
(I+E) & (E)
(I+E) & (E)
(I+E) & (E)
(I+E)
Table 1: List of previously unknown vulnerabilities found by MoonShine. The rightmost, Distill. Method column reports which
distillation methods produced the seeds that led Syzkaller to ﬁnd said vulnerability. (I+E) is shorthand for Moonshine(I+E), and
(E) for MoonShine(E). No vulnerabilities were found by the undistilled traces or default Syzkaller.
Figure 5: Coverage breakdown by system call after twenty four hours of fuzzing. The dark blue bars are for Moonshine(I+E) and
white bars are for default Syzkaller.
5.3 Can MoonShine improve code cover-
age? (RQ2)
Figure 4 shows the coverage achieved by our Moon-
shine(I+E) and MoonShine(E) algorithms compared to
Syzkaller using only its manual rules over 24 hours of
fuzzing. The seeds used in this experiment are generated
from all our seed programs described in Section 5.1. For
a fair comparison, we restrict Syzkaller to only fuzz the
system calls that were present in our traces.
Overall Coverage Results.
For edge coverage,
Moonshine(I+E) covered 53,270 unique basic blocks,
MoonShine(E) covered 51,920 and default Syzkaller
covered 47,320. This shows Syzkaller’s coverage im-
proves noticeably when it starts with either of Moon-
Shine’s generated seeds; however, when seeded with pro-
grams that have been distilled with both explicit and im-
plicit dependencies, Syzkaller achieves 13% coverage
improvement compared to the 9% when using explicit
dependencies alone.
Breakdown By System Call. Figure 5 shows the
breakdown of the coverage achieved by Moonshine(I+E)
compared to default Syzkaller by system call. The height
of each bar represents the union of all unique basic
736    27th USENIX Security Symposium
USENIX Association
blocks hit by that system call across all fuzzer programs
(both seed and generated) over 24 hours of fuzzing. We
see that the system calls where Moonshine(I+E) outper-
formed default Syzkaller were among standard system
calls such as read, write, fsync and mmap. This fact
that Moonshine(I+E) noticeably outperformed Syzkaller
on these standard system calls suggests that Syzkaller’s
hard coded rules are insufﬁcient to capture dependencies
for common calls.
Coverage and Bugs Found. Although 10 out of 17
bugs found were concurrency related we observed that
all our concurrency bugs were found in the ﬁle and net-
working subsystems. Similarly, the calls which pro-
duced the most new coverage under our distilled seeds
were also ﬁle or networking related, for example fsync
and sockpair. This correlation is not arbitrary. Since
Syzkaller is a coverage-guided, evolutionary fuzzer, it
will continually stress the programs and system calls
which are returning the most new coverage. The test
suites we used for source programs contain programs
which especially exercise functionality in the networking
and ﬁlesystem kernel subsystems. Of the 17 bugs found
by MoonShine, 6 were from the network subsystem, and
8 from ﬁle systems. These ﬁndings imply that the com-
position of seed programs is able to inﬂuence Syzkaller
to focus on fuzzing particular regions of the kernel it oth-
erwise would not, and in extension discover bugs in these
regions.
Result 2: MoonShine achieves 13% higher edge cov-
erage than default Syzkaller
5.4 How effectively can MoonShine distill
traces? (RQ3)
Tracking Dependencies. To evaluate how effectively
MoonShine can track dependencies, we ﬁrst measured
the coverage achieved by our seed programs during trace
generation. Afterwards, we distilled these traces using
Moonshine(I+E) and MoonShine(E) and measured the
coverage achieved by Syzkaller due to these seeds alone,
i.e. with mutation and seed generation disabled. We then
compared the intersection of the coverage achieved by
our traces and the coverage achieved by Syzkaller. Table
2 shows the result of this experiment as we expanded our
seed program sources.
The left column indicates the seed programs used in
the experiment. As we expanded the number of seed
programs, Syzkaller recovered 86.8% and 78.6% of the
original trace coverage using seeds generated by Moon-
shine(I+E) and MoonShine(E). To understand the impact
of tracking dependencies, we repeated this experiment
using seeds generated by RANDOM. As we see in Col-
umn 3, the coverage recovered is at most 23%, nearly
four times worse than when using seeds generated by
Moonshine(I+E) and MoonShine(E).
To understand the impact of the coverage we could
not recover, we repeated our experiments but allowed
Syzkaller to mutate and generate seeds. After 30 min-
utes, we recompared the coverage intersection. The re-
sults are summarized in Table 3. When using Moon-
shine(I+E) and MoonShine(E), Syzkaller can recover
95% and 91.6% of the original traces but when using
RANDOM it achieves minimal improvement over default
Syzkaller. This suggests that capturing dependencies is
crucial to improving Syzkaller’s performance and that
MoonShine is able to do so effectively.
Result 3: MoonShine distills 3220 traces consisting
of 2.9 million calls into seeds totaling 16,442 calls that
preserve 86% of trace coverage.
5.5 How efﬁcient is MoonShine? (RQ4)
To evaluate the efﬁciency of MoonShine, we measured
the execution time of each of MoonShine components
across our different sources. These results are summa-
rized in Table 4. The last row shows the time required
to process all our sources at once through MoonShine’s
workﬂow.
Trace Generation. Prior to benchmarking our com-
ponents, we preloaded all seed programs on a custom
Google Cloud image running linux-4.13-rc7 compiled
with kcov. During trace generation, we launched 4 n1-
standard-2 machines and captured the traces in paral-
lel. Our results show that our modiﬁcations to Strace
result in a 250% slowdown during trace generation uni-
formly across sources. However, this is to be expected
because after each system call we must capture the cov-
erage recorded by kcov and write it to a ﬁle. Further-
more, the kcov api does not deduplicate the edge cov-
erage achieved by a call during its execution. We found
that without deduplication, the average size of our traces
were 33MB. By deduplicating the instructions during
trace generation we are able to reduce the average trace
size from 33MB to 102KB.
Distillation. Our results for distillation show that the
time required to distill a source was proportional to the
size of the source. As Table 4 demonstrates, it took only
18 minutes to distill 3220 traces that contained over 2.9
million calls. We also found that over 90% of the execu-
tion time in distillation was spent reading the traces. The
time required to build the dependency graph and track
implicit dependencies was only 30 seconds. This sug-
gests that MoonShine is able to distill efﬁciently.
USENIX Association
27th USENIX Security Symposium    737
Source
Coverage
Number of Distilled Calls
Traced
RANDOM (E)
(I+E)
Traced
RANDOM (E)
(I+E)
L+K
19,500
P+L+K
23,381
P+G+L+K 25,240
3,460
(17.7%)
5,532
(23.7%)
5,449
(21.6%)
13,320
(68.3%)
18,288
(78.2%)
19,840
(78.6%)
16,400
(84.1%)
21,432
(91.6%)
21,920
(86.8%)
283,836
1,863,474
2,953,402
12,712
(4.47%)
15,333
(0.82%)
16,442
(0.56%)
10,200
(3.6%)
11,455
(.61%)
11,590
(.39%)
12,712
(4.47%)
15,333
(0.82%)
16,442
(0.56%)
Table 2: Seed source breakdown by distillation algorithm. The Traced columns report numbers from the original system call traces,
prior to any distillation. (I+E) is short for Moonshine(I+E) and (E) for MoonShine(E). The numbers show the breakdown for our
seed programs gathered from LTP (L), Posix Test Suites (L), Glibc Tests (G), Kselftests (K).
Distillation
Method
Coverage
Recovered
Percentage