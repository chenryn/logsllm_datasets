## 描述
[官方](https://github.com/SECCON/SECCON2018_online_CTF/tree/master/Pwn/q-escape)的描述如下：
    q-escape
    We developed a new device named CYDF :)
    Ubuntu 16.04 latest
    nc q-escape.pwn.seccon.jp 1337
将文件下下来，目录如下：
    $ ll
    -rw-rw-r--  1 raycp raycp 1.7M Aug 21 08:03 initramfs.igz
    drwxr-xr-x  6 raycp raycp 4.0K Oct 22  2018 pc-bios
    -rwxr-xr-x  1 raycp raycp  28M Oct 22  2018 qemu-system-x86_64
    -rwxr-xr-x  1 raycp raycp  256 Oct 22  2018 run.sh
    -rw-------  1 raycp raycp 7.9M Oct 22  2018 vmlinuz-4.15.0-36-generic
run.sh中的内容是：
    #!/bin/sh
    ./qemu-system-x86_64 \
            -m 64 \
            -initrd ./initramfs.igz \
            -kernel ./vmlinuz-4.15.0-36-generic \
            -append "priority=low console=ttyS0" \
            -nographic \
            -L ./pc-bios \
            -vga std \
            -device cydf-vga \
            -monitor telnet:127.0.0.1:2222,server,nowait
可以知道设备名称是`cydf-vga`以及在本地的2222端口开启了qemu monitor。
## 分析
首先仍然是`sudo ./run.sh`把虚拟机跑起来，我的环境是ubuntu18，报了下面的错误：
    ./qemu-system-x86_64: error while loading shared libraries: libcapstone.so.3: cannot open shared object file: No such file or directory
解决方案：
    sudo apt-get install libcapstone3
虚拟机跑起来的同时把`qemu-system-x86_64`拖进ida进行分析，查找`cydf-vga`相关函数：
查看`cydf_vga_class_init`函数，知道了它的`device_id`为`0xB8`、`vendor_id`为`0x1013`，`class_id`
为`0x300`。同时根据字符串`Cydf CLGD 54xx VGA`去搜索，进行相应比对，找到了该设备是`Cirrus CLGD 54xx VGA
Emulator`改过来的。`Cirrus`在qemu中源码路径为[`./hw/display/cirrus_vga.c`](https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga.c)。
先在虚拟机中查看设备信息，根据设备id等信息，可以知道它是最后一个`00:04.0 Class 0300: 1013:00b8`：
    / # lspci
    00:00.0 Class 0600: 8086:1237
    00:01.3 Class 0680: 8086:7113
    00:03.0 Class 0200: 8086:100e
    00:01.1 Class 0101: 8086:7010
    00:02.0 Class 0300: 1234:1111
    00:01.0 Class 0601: 8086:7000
    00:04.0 Class 0300: 1013:00b8
由于它里面的lspci不支持`-v`等参数，所以要看它的内存以及端口空间，可以去读取它的`resource`文件，可以看到它有三个mmio空间：
    / # cat /sys/devices/pci0000\:00/0000\:00\:04.0/resource
    0x00000000fa000000 0x00000000fbffffff 0x0000000000042208
    0x00000000febc1000 0x00000000febc1fff 0x0000000000040200
    0x0000000000000000 0x0000000000000000 0x0000000000000000
    0x0000000000000000 0x0000000000000000 0x0000000000000000
    0x0000000000000000 0x0000000000000000 0x0000000000000000
    0x0000000000000000 0x0000000000000000 0x0000000000000000
    0x00000000febb0000 0x00000000febbffff 0x0000000000046200
另一个方法是`telnet 127.0.0.1
2222`连上它的[monitor](https://www.xuebuyuan.com/3206943.html)，可以看到相应的地址空间：
    info pci
    ...
    Bus  0, device   4, function 0:
        VGA controller: PCI device 1013:00b8
          BAR0: 32 bit prefetchable memory at 0xfa000000 [0xfbffffff].
          BAR1: 32 bit memory at 0xfebc1000 [0xfebc1fff].
          BAR6: 32 bit memory at 0xffffffffffffffff [0x0000fffe].
          id ""
一个奇怪的问题是在`cydf_init_common`函数中看到了三个注册I/O函数：
    memory_region_init_io(&s->cydf_vga_io, owner, &cydf_vga_io_ops, s, "cydf-io", 0x30uLL);
    ...
    memory_region_init_io(&s->low_mem, owner, &cydf_vga_mem_ops, s, "cydf-low-memory", 0x20000uLL);
    ...
    memory_region_init_io(&s->cydf_mmio_io, owner, &cydf_mmio_io_ops, s, "cydf-mmio", 0x1000uLL);
可以看到函数中注册了`0x30`大小的PMIO，`0x20000`大小的MMIO以及`0x1000`大小的MMIO。但是为啥在设备中只看到了`BAR1`中`0x1000`大小的MMIO空间，其余两个去哪里了？
在`cirrus_vga.c`中有下面两行注释：
    /* Register ioport 0x3b0 - 0x3df */
    ...
    /* memory access between 0xa0000-0xbffff */
`cat /proc/iomem`和`cat /proc/ioports`查看相应的MMIO和PMIO：
    / # cat /proc/iomem
    ...
    000a0000-000bffff : PCI Bus 0000:00
    ...
    04000000-febfffff : PCI Bus 0000:00
    ...
      febc1000-febc1fff : 0000:00:04.0
    / # cat /proc/ioports
    ...
      03c0-03df : vga+
    ...
因此另外两个0x30大小的PMIO空间以及0x20000大小的MMIO空间看起来似乎是vga的地址空间，根据师傅们的writeup以及[Mapping of
Display Memory into CPU Address Space
](http://www.osdever.net/FreeVGA/vga/vgamem.htm)和[Addressing
details](https://en.wikipedia.org/wiki/Video_Graphics_Array#Addressing_details)可以知道，地址`000a0000-000bffff`确实是vga的空间。
有了源码的参考看起来会方便很多，接下来对比二者，以找到题目中什么地方被修改了。经过比对，最主要的变化是在`cydf_vga_mem_write`函数，同时在`CydfVGAState`结构体中加入了两个字段：
    000133D8 vs              VulnState_0 16 dup(?)
    000134D8 latch           dd 4 dup(?)
`VulnState`的定义为：
    00000000 VulnState_0     struc ; (sizeof=0x10, align=0x8, copyof_4201)
    00000000                                         ; XREF: CydfVGAState/r
    00000000                                         ; CydfVGAState_0/r
    00000000 buf             dq ?                    ; offset
    00000008 max_size        dd ?
    0000000C cur_size        dd ?
    00000010 VulnState_0     ends
接下来看`cydf_vga_mem_write`函数存在区别的部分主要的内容是什么（漏洞是什么）：
    void __fastcall cydf_vga_mem_write(CydfVGAState *opaque, hwaddr addr, uint64_t mem_value, uint32_t size)
    {
      ...
      if ( !(opaque->vga.sr[7] & 1) )
      {
        vga_mem_writeb(&opaque->vga, addr, mem_value);
        return;
      }
      if ( addr vga.sr[0xCC];
        LOWORD(v6) = opaque->vga.sr[0xCC] / 5u;
        cmd = opaque->vga.sr[0xCC] - 5 * v6;
        if ( *(_WORD *)&opaque->vga.sr[0xCD] )      // cmd = sr[0xcc]%5
          LODWORD(mem_value) = (opaque->vga.sr[0xCD] vga.sr[0xCE] vga.vram_ptr + 2 * (idx + 0x133D));
            if ( v25 )
              __printf_chk(1LL, v25);
          }
        }
        else
        {
          if ( (unsigned __int8)cmd <= 2u )