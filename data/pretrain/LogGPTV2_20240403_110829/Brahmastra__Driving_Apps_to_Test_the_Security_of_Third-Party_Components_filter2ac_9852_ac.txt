We implement Brahmastra for analyzing Android apps,
and use the tool to perform two security analyses which
we will describe in §7 and §8. This section describes
several highlights of the tool, along with practical chal-
lenges that we faced in the implementation process and
how we resolved them.
5.1 Execution Planner
Static analyses for constructing a call graph and ﬁnd-
ing transition paths to target methods are performed us-
ing Redexer [24], a general purpose bytecode rewriting
framework for Android apps. Redexer takes as input
an Android app binary (APK ﬁle) and constructs an in-
memory data structure representing DEX ﬁle for various
analyses. Redexer offers several utility functions to ma-
nipulate such DEX ﬁle and provides a generic engine to
perform data-ﬂow analysis, along with call graph and
control-ﬂow graph.
For special APIs that trigger activity transitions, e.g.,
Context.startActivity(), we perform constant propa-
gation analysis (see Appendix A for details) and identify
a target activity stored inside the intent. Figure 6 de-
picts example bytecode snippets that create and initial-
ize an intent (lines 2 and 6), along with the target activ-
ity (line 4), and starts that activity via startActivity()
(line 8). Mappings between each bytecode show how
we accumulate data-ﬂow information, from empty intent
through class name to intent with the speciﬁc target ac-
tivity. We apply the same analysis to bindings between
views and listeners.
5.2 App Rewriting
We use the Soot framework [29] to perform the byte-
code rewriting that enables self execution. Dexpler [7]
converts an Android app binary into Soot’s intermedi-
ate representation, called Jimple, which is designed to
1 // { v3 → this }
2 new-instance v0, Landroid/content/Intent;
3 // { v0 → Intent(), ... }
4 const-class v1, ...AboutBox;
5 // { v1 → Clazz(AboutBox), ... }
6 invoke-direct {v0, v3, v1}, ...Intent;.
7 // { v0 → Intent(AboutBox), ... }
8 invoke-virtual {v3, v0}, ...;.startActivity
9 // { ... }
Figure 6: An example bytecode of activity transition ex-
cerpted from ch.smalltech.battery.free. Mappings be-
tween bytecode represent data-ﬂow information, which
shows what values registers must have. Only modiﬁed or
newly added values are shown.
ease analysis and manipulation. The re-writing tool is
composed of Soot’s class visitor methods and an An-
droid XML parser. Given an app binary and an execution
path, the rewriter generates a rewritten binary which ar-
tiﬁcially invokes a callback method upon the completion
of the exercising the current activity, triggering the next
activity to be launched. The inserted code depends on the
type of the edge found by the Planner (Recall three kinds
of asynchronous edges described in §4.1). For program-
matic and XML-based registrations, the rewriter ﬁnds the
view attached to it — by parsing the activity code, and
the manifest respectively — and invokes the appropri-
ate UI interaction on it after it has completed loading.
Lifetime methods are invoked by the Android framework
directly, and the rewriter skips code insertion for these
cases. In other cases, the rewriter inserts a timed call to
the transition method directly, to allow the activity and
any dependencies of the method to load completely.
5.3
Jump start requires starting an activity even if it is not de-
ﬁned as the Launcher activity in the app. To achieve that,
we manipulate the manifest ﬁle of the Android app. The
Intent.ACTION MAIN entry in the manifest ﬁle declares
activities that Android activity manager can start directly.
To enable jump start, we insert an ACTION MAIN entry for
each activity along the path speciﬁed, so that it can be
started by the Execution Engine. Manifest ﬁle also de-
clares an intent ﬁlter, which determines the sources from
which an activity may be started, which we modify to
allow the Execution Engine to launch the activity. The
Engine then invokes desired activity by passing an intent
to it. We use the Android Debug Bridge (ADB) [4] for
performing jump start. ADB allows us to create an intent
with the desired parameters and target, and then passes
it to the Android Activity Manager. The activity man-
ager in turn loads the appropriate app data and invokes
the speciﬁed activity. Starting the (jump started) activ-
Jump Start
USENIX Association  
23rd USENIX Security Symposium  1027
ity immediately activates self execution from that activ-
ity onwards.
6 Evaluation of Brahmastra
We evaluate Brahmastra in terms of two key metrics: (1)
hit rate, i.e., the fraction of apps for which Brahmastra
can invoke any of target methods, and (2) speed, i.e.,
time (or number of activity transitions) Brahmastra takes
to invoke a target method in an app for which Brahmas-
tra has a hit. Since we are not aware of any existing tool
that can achieve the same goal, we compare Brahmas-
tra against a general Android app exploration tool called,
PUMA [23]. This prototype is the best-performing Mon-
key we were able to ﬁnd that is amenable to experimen-
tation.
In terms of speed and coverage, PUMA is far
better than a basic “random” Monkey. PUMA incorpo-
rates many key optimizations in existing Monkeys such
as AppsPlayground [26], A3E [14], and VanarSena [27]
and we expect it to perform at least on a par with them.
6.1 Experiment Methodology
Target method: For the experiments in this section, we
conﬁgure Brahmastra to invoke authentication methods
in the Facebook SDK for Android.1 We choose Face-
book SDK because this is a popular SDK and its meth-
ods are often invoked only deep inside the apps. Using
the public documentation for the Facebook SDK for An-
droid, we determined that it has two target methods for
testing. Note that apps in our dataset use the Facebook
SDK version 3.0.2b or earlier2
Lcom/facebook/android/Facebook;->authorize
Lcom/facebook/android/Facebook;->dialog
Figure 7: Target methods for evaluation
Apps: We crawled 12,571 unique apps from the Google
Play store from late December 2012 till early January
2013. These apps were listed as 500 most popular free
apps in each category provided by the store at the time.
Among them, we ﬁnd that 1,784 apps include the Face-
book SDK for Android. We consider only apps that in-
voke the authentication method—Over 50 apps appear to
have no call sites to Facebook APIs, and over 400 apps
use the API but do not invoke any calls related to autho-
rization. We also discard apps that do not work with our
tool chain, e.g., crash on the emulator or have issues with
apktool [1] since our analysis depends on the disassem-
bled code of an apk ﬁle. This leaves us with 1,010 apps.
1https://developers.facebook.com/docs/
android/login-with-facebook
2The later version of Facebook SDK was released in the middle
of data collection and appears to use different methods to display a
login screen. However, we ﬁnd that almost no apps in our data set had
adapted the new version yet.
(cid:1)
(cid:22)
(cid:20)
(cid:20)
(cid:2)
(cid:35)
(cid:1)
(cid:32)(cid:26)(cid:1)
(cid:31)(cid:26)(cid:1)
(cid:30)(cid:26)(cid:1)
(cid:29)(cid:26)(cid:1)
(cid:28)(cid:26)(cid:1)
(cid:27)(cid:26)(cid:1)
(cid:26)(cid:1)
(cid:6)(cid:8)(cid:5)(cid:2)(cid:1)
(cid:3)(cid:21)(cid:9)(cid:13)(cid:17)(cid:9)(cid:22)(cid:23)(cid:21)(cid:9)(cid:1)
(cid:7)(cid:14)(cid:17)(cid:11)(cid:19)(cid:24)(cid:23)(cid:1) (cid:3)(cid:16)(cid:19)(cid:10)(cid:15)(cid:14)(cid:18)(cid:12)(cid:1)(cid:20)(cid:9)(cid:12)(cid:11)(cid:1)
(cid:4)(cid:21)(cid:9)(cid:22)(cid:13)(cid:1)
(cid:4)(cid:24)(cid:22)(cid:23)(cid:19)(cid:17)(cid:1)
(cid:4)(cid:19)(cid:18)(cid:23)(cid:21)(cid:19)(cid:16)(cid:1)
Figure 8: Failure causes of Brahmastra and PUMA.
App execution: In order to determine if Brahmastra or
PUMA is able to reach a program point that invokes the
target method, we instrument apps. The instrumentation
detects when any of the target methods are invoked dur-
ing runtime, by comparing signatures of executing meth-
ods with signatures of target methods. For Brahmastra,
we consider only 5 of all paths generated by the Execu-
tion Planner. For PUMA, we explore each app for up to
250 steps; higher timeouts signiﬁcantly increase overall
testing time for little gain in hit rate.
6.2 Hit Rate
In our experiments, PUMA was able to successfully in-
voke a target method in 127 apps (13%). Note that
PUMA’s hit rate is signiﬁcantly lower than its activity
coverage (> 90% compared to humans) reported in [23],
highlighting the difﬁculty in invoking speciﬁc program
points deep inside an app. In contrast, Brahmastra was
successfully able to invoke a target method in 344 (34%)
apps, a 2.7× improvement over PUMA. A closer exam-
ination of our results, as shown in Table 1, reveals that
Brahmastra’s technique can help circumventing all the
root causes for PUMA’s poor hit rate as mentioned in §3.
We now investigate why PUMA and Brahmastra
sometimes fail to invoke the target method. For PUMA,
this is due to the aforementioned four cases. Figure 8
shows the distribution of apps for which PUMA fails due
to speciﬁc causes. As shown, all the causes happen in
practice. The most dominant cause is the failure to ﬁnd
UI controls to interact with, which is mostly due to com-
plex UI layouts of the popular apps we tested. Figure 8
also shows the root causes for Brahmastra’s failure. The
key reasons are as follows:
Blocking page: Even if jump start succeeds, successive
activity transition may fail on a blocking page. Brah-
mastra fails for 20% of the apps due to this cause. We
would like to emphasize that Brahmastra experiences
more blocking pages than PUMA only because Brah-
mastra explores many paths that PUMA does not (e.g.,
because those paths are behind a custom control that
1028  23rd USENIX Security Symposium 
USENIX Association
Case
R1: Timeout in PUMA, success in Brahmastra
R2: Blocking page in PUMA, success in Brahmastra
R3: Unknown control in PUMA, success in Brahmastra
R4: Crash in PUMA, success in Brahmastra
Apps
62%
48%
43%
30%
Table 1: % of apps for which Brahmastra succeeds but
PUMA fails due to various reasons mentioned in §3.
PUMA cannot interact with, but Brahmastra can ﬁnd and
invoke the associated callback) and many of these paths
contain blocking pages. If PUMA tried to explore those
paths, it would have failed as well due to these blocking
pages.
Crash: Jump start can crash if the starting activity ex-
pects speciﬁc parameters in the intent and Brahmastra
fails to provide that. Brahmastra fails for 7% of the apps
due to this cause.
Custom components: Execution Planner may fail to
ﬁnd useful paths if the app uses custom components3,
which can be used to override standard event handlers,
thus breaking our model of standard Android apps. With-
out useful paths, Brahmastra can fail to invoke the target
methods. In our experiments, this happens with 16% of
the apps. We leave as future work a task to extend Execu-
tion Planner to handle custom components. We ﬁnd that
PUMA also failed 91% on these apps, proving the dif-
ﬁculty of navigating apps with custom components. In
fact, PUMA suffers much more than Brahmastra due to
custom components.
Improving the hit rate: There are several ways we can
further improve the hit rate of Brahmastra. First, 16%
failures of Brahmastra come because the static analysis
fails to identify useful paths. A better static analysis that
can discover more useful paths can improve Brahmas-
tra’s hit rate. Second, in our experiments, Brahmastra
tried only up to 5 randomly selected useful paths to in-
voke the target method and gave up if they all failed. In
many apps, our static analysis found many tens of use-
ful paths, and our results indicate that the more paths we
tried, the better was the hit rate. More speciﬁcally, Brah-
mastra succeeded for 207 apps after considering only
one path, and for 344 apps after considering up to ﬁve
paths. This suggests that considering more paths is likely
to improve the hit rate. Additionally, we should select
the paths to avoid any nodes or edges for which explo-
ration failed in previously considered paths instead of
choosing them randomly. In 72 apps, Brahmastra was
unable to ﬁnd the binding between a callback method
and the UI element associated with it, causing it to fall
back on a direct invocation of the callback method. A
better static analysis can help in this case as well. In 22
3http://developer.android.com/guide/topics/
ui/custom-components.html
(cid:1)
(cid:27)
(cid:6)
(cid:5)
(cid:4)
(cid:26)
(cid:1)
(cid:19)
(cid:17)
(cid:17)
(cid:2)
(cid:39)
(cid:1)
(cid:32)(cid:31)(cid:31)(cid:1)
(cid:36)(cid:31)(cid:1)
(cid:35)(cid:31)(cid:1)
(cid:34)(cid:31)(cid:1)
(cid:33)(cid:31)(cid:1)
(cid:31)(cid:1)
(cid:31)(cid:1)
(cid:33)(cid:31)(cid:1)
(cid:3)(cid:18)(cid:10)(cid:12)(cid:14)(cid:10)(cid:19)(cid:20)(cid:18)(cid:10)(cid:1)
(cid:8)(cid:9)(cid:7)(cid:2)(cid:1)
(cid:34)(cid:31)(cid:1)
(cid:35)(cid:31)(cid:1)
(cid:28)(cid:1)(cid:10)(cid:11)(cid:21)(cid:23)(cid:13)(cid:20)(cid:24)(cid:1)(cid:20)(cid:18)(cid:10)(cid:15)(cid:19)(cid:13)(cid:21)(cid:16)(cid:15)(cid:19)(cid:1)
(cid:36)(cid:31)(cid:1)
(cid:32)(cid:31)(cid:31)(cid:1)
Figure 9: Test speed comparison of Brahmastra and
PUMA
apps, Brahmastra deemed a page blocked due to UI el-
ements in the Android SDK (e.g., list elements) whose
behavior was not encoded in the instrumentation engine.
An engineering effort in special-case handling of these
and more views would increase hit rate. We plan to ex-
plore such optimizations in future. Finally, PUMA (and
other Monkeys) and Brahmastra use fundamentally dif-
ferent techniques to navigate between app pages and it
might be possible to combine them in a single system
where PUMA is used if Brahmastra fails (or vice versa).
In our experiments, such a hybrid approach would give
an overall hit rate of 39% (total 397 apps).
6.3 Speed
We use the number of activity transitions required to
reach the target activity as a proxy for speed, since the
actual time will vary depending on a variety of com-
putational factors (e.g., network speed, device speciﬁ-
cations). In Figure 9, we plot the CDF of the number
of transitions required to reach the target activity for the
apps which are successfully tested by both Brahmastra
and PUMA. Since Brahmastra prunes away many un-
necessary paths using static analysis, it runs faster than
PUMA that suffers from uninformed activity transitions
and large fanout in the activity transition graphs. On av-
erage, PUMA requires 18.7 transitions per app, while
Brahmastra requires 2.5 transitions per app, resulting in
7 fold speedup.
7 Analysis of Ads in Kids Apps
Our ﬁrst scenario is to use Brahmastra to study whether
ad libraries for Android apps meet guidelines for protect-
ing the online privacy of children. We give results for two
popular ad components embedded in 220 kids apps. Our
analysis shows that 80% of the apps displayed ads with a
link to landing pages that have forms for collecting per-
sonal information, and 36% apps displayed ads deemed
inappropriate to children.
USENIX Association  
23rd USENIX Security Symposium  1029
7.1 Motivation and Goals
The Children’s Online Privacy Protection Act (COPPA)
lays down a variety of stipulations that mobile app de-
velopers must follow if their apps are directed at children
under 13 years old [6]. In particular, COPPA disallows
the collection of personal information by these apps un-
less the apps have ﬁrst obtained parental consent.
COPPA holds the app developer responsible for the
personal information collected by the embedded third
party components as well as by the app’s code [6]. Since
it is common to see ad components included in free apps,
we aim to measure the extent of potentially non-COPPA-