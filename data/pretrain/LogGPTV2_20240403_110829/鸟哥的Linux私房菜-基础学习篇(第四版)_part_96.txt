基本上 history 的用途很大的！但是需要小心安全的问题！尤其是 root 的历史纪录文件，这是 Cracker 的最爱！因为不小心的 root 会将
很多的重要数据在执行的过程中会被纪录在 ~/.bash_history 当中，如果这个文件被解析的话，后果不堪呐！无论如何，使用 history 配合“ ! ”曾
经使用过的指令下达是很有效率的一个指令下达方法！
同同一一帐帐号号同同时时多多次次登登陆陆的的 history 写写入入问问题题
有些朋友在练习 linux 的时候喜欢同时开好几个 bash 接口，这些 bash 的身份都是 root 。 这样会有 ~/.bash_history 的写入问题吗？想一
想，因为这些 bash 在同时以 root 的身份登陆， 因此所有的 bash 都有自己的 1000 笔记录在内存中。因为等到登出时才会更新记录文件，所
以啰， 最后登出的那个 bash 才会是最后写入的数据。唔！如此一来其他 bash 的指令操作就不会被记录下来了 （其实有被记录，只是被后来
的最后一个 bash 所覆盖更新了） 。
由于多重登陆有这样的问题，所以很多朋友都习惯单一 bash 登陆，再用工作控制 （job control, 第四篇会介绍） 来切换不同工作！ 这
样才能够将所有曾经下达过的指令记录下来，也才方便未来系统管理员进行指令的 debug 啊！
无无法法记记录录时时间间
历史命令还有一个问题，那就是无法记录指令下达的时间。由于这 1000 笔历史命令是依序记录的， 但是并没有记录时间，所以在查询
方面会有一些不方便。如果读者们有兴趣，其实可以通过 ~/.bash_logout 来进行 history 的记录，并加上 date 来增加时间参数，也是一个可以
应用的方向喔！ 有兴趣的朋友可以先看看情境仿真题一吧！
Tips
鸟哥经常需要设计线上题目给学生考试用，所以需要登陆系统去设计环境，设计完毕后再将该硬盘分派给学生来考试使用。 只是，经常很担心同
学不小心输入 history 就会得知鸟哥要考试的重点文件与指令，因此就得要使用 history -c; history -w 来强迫更新纪录档了！ 提供给您参考！
是否记得我们登陆主机的时候，屏幕上头会有一些说明文字，告知我们的 Linux 版本啊什么的， 还有，登陆的时候我们还可以给予使用
者一些讯息或者欢迎文字呢。此外， 我们习惯的环境变量、命令别名等等的，是否可以登陆就主动的帮我设置好？ 这些都是需要注意的。另
外，这些设置值又可以分为系统整体设置值与各人喜好设置值， 仅是一些文件放置的地点不同啦！这我们后面也会来谈一谈的！
我们在第五章与第六章都曾谈过“相对路径与绝对路径”的关系， 在本章的前几小节也谈到了 alias 与 bash 的内置命令。现在我们知道系
统里面其实有不少的 ls 指令， 或者是包括内置的 echo 指令，那么来想一想，如果一个指令 （例如 ls） 被下达时， 到底是哪一个 ls 被拿来运
行？很有趣吧！基本上，指令运行的顺序可以这样看：
1. 以相对/绝对路径执行指令，例如“ /bin/ls ”或“ ./ls ”；
2. 由 alias 找到该指令来执行；
3. 由 bash 内置的 （builtin） 指令来执行；
4. 通过 $PATH 这个变量的顺序搜寻到的第一个指令来执行。
举例来说，你可以下达 /bin/ls 及单纯的 ls 看看，会发现使用 ls 有颜色但是 /bin/ls 则没有颜色。 因为 /bin/ls 是直接取用该指令来下达，
而 ls 会因为“ alias ls='ls --color=auto' ”这个命令别名而先使用！ 如果想要了解指令搜寻的顺序，其实通过 type -a ls 也可以查询的到啦！上述的
顺序最好先了解喔！
例题：
设置 echo 的命令别名成为 echo -n ，然后再观察 echo 执行的顺序
答：
[dmtsai@study ~]$ alias echo='echo -n'
[dmtsai@study ~]$ type -a echo
echo is aliased to `echo -n'
echo is a shell builtin
echo is /usr/bin/echo
瞧！很清楚吧！先 alias 再 builtin 再由 $PATH 找到 /bin/echo 啰！
虾密！ bash 也有进站画面与欢迎讯息喔？真假？真的啊！ 还记得在终端机接口 （tty1 ~ tty6） 登陆的时候，会有几行提示的字串吗？
那就是进站画面啊！ 那个字串写在哪里啊？呵呵！在 /etc/issue 里面啊！先来看看：
[dmtsai@study ~]$ cat /etc/issue
\S
Kernel \r on an \m
鸟哥是以完全未更新过的 CentOS 7.1 作为范例，里面默认有三行，较有趣的地方在于 \r 与 \m。 就如同 $PS1 这变量一样，issue 这个
文件的内容也是可以使用反斜线作为变量取用喔！你可以 man issue 配合 man agetty 得到下面的结果：
issue 内的各代码意义
\d 本地端时间的日期；
\l 显示第几个终端机接口；
\m 显示硬件的等级 （i386/i486/i586/i686...）；
\n 显示主机的网络名称；
\O 显示 domain name；
\r 操作系统的版本 （相当于 uname -r）
\t 显示本地端时间的时间；
\S 操作系统的名称；
\v 操作系统的版本。
做一下下面这个练习，看看能不能取得你要的进站画面？
例题：
如果你在 tty3 的进站画面看到如下显示，该如何设置才能得到如下画面？
CentOS Linux 7 （Core） （terminal: tty3）
Date: 2015-07-08 17:29:19
Kernel 3.10.0-229.el7.x86_64 on an x86_64
Welcome!
注意，tty3 在不同的 tty 有不同显示，日期则是再按下 [enter] 后就会所有不同。
答：
很简单，用 root 的身份，并参考上述的反斜线功能去修改 /etc/issue 成为如下模样即可（共五行）：
\S （（terminal: \l））
Date: \d \t
Kernel \r on an \m
Welcome!
曾有鸟哥的学生在这个 /etc/issue 内修改数据，光是利用简单的英文字母作出属于他自己的进站画面， 画面里面有他的中文名
字呢！非常厉害！也有学生做成类似很大一个“囧”在进站画面，都非常有趣！
你要注意的是，除了 /etc/issue 之外还有个 /etc/issue.net 呢！这是啥？这个是提供给 telnet 这个远端登陆程序用的。 当我们使用 telnet
连接到主机时，主机的登陆画面就会显示 /etc/issue.net 而不是 /etc/issue 呢！
至于如果您想要让使用者登陆后取得一些讯息，例如您想要让大家都知道的讯息， 那么可以将讯息加入 /etc/motd 里面去！例如：当登
陆后，告诉登陆者， 系统将会在某个固定时间进行维护工作，可以这样做 （一定要用 root 的身份才能修改喔！）：
[root@study ~]# vim /etc/motd
Hello everyone,
Our server will be maintained at 2015/07/10 0:00 ~ 24:00.
Please don't login server at that time. ^_^
那么当你的使用者（包括所有的一般帐号与 root）登陆主机后，就会显示这样的讯息出来：
Last login: Wed Jul 8 23:22:25 2015 from 127.0.0.1
Hello everyone,
Our server will be maintained at 2015/07/10 0:00 ~ 24:00.
Please don't login server at that time. ^_^
你是否会觉得奇怪，怎么我们什么动作都没有进行，但是一进入 bash 就取得一堆有用的变量了？ 这是因为系统有一些环境设置文件的
存在，让 bash 在启动时直接读取这些配置文件，以规划好 bash 的操作环境啦！ 而这些配置文件又可以分为全体系统的配置文件以及使用者
个人偏好配置文件。要注意的是， 我们前几个小节谈到的命令别名啦、自订的变量啦，在你登出 bash 后就会失效，所以你想要保留你的设
置， 就得要将这些设置写入配置文件才行。下面就让我们来聊聊吧！
login 与与 non-login shell
在开始介绍 bash 的配置文件前，我们一定要先知道的就是 login shell 与 non-login shell！ 重点在于有没有登陆 （login） 啦！
login shell：取得 bash 时需要完整的登陆流程的，就称为 login shell。举例来说，你要由 tty1 ~ tty6 登陆，需要输入使用者的帐号与密
码，此时取得的 bash 就称为“ login shell ”啰；
non-login shell：取得 bash 接口的方法不需要重复登陆的举动，举例来说，（1）你以 X window 登陆 Linux 后， 再以 X 的图形化接口启
动终端机，此时那个终端接口并没有需要再次的输入帐号与密码，那个 bash 的环境就称为 non-login shell了。（2）你在原本的 bash 环
境下再次下达 bash 这个指令，同样的也没有输入帐号密码， 那第二个 bash （子程序） 也是 non-login shell 。
为什么要介绍 login, non-login shell 呢？这是因为这两个取得 bash 的情况中，读取的配置文件数据并不一样所致。 由于我们需要登陆系
统，所以先谈谈 login shell 会读取哪些配置文件？一般来说，login shell 其实只会读取这两个配置文件：
1. /etc/profile：这是系统整体的设置，你最好不要修改这个文件；
2. ~/.bash_profile 或 ~/.bash_login 或 ~/.profile：属于使用者个人设置，你要改自己的数据，就写入这里！
那么，就让我们来聊一聊这两个文件吧！这两个文件的内容可是非常繁复的喔！
/etc/profile （（login shell 才才会会读读））
你可以使用 vim 去阅读一下这个文件的内容。这个配置文件可以利用使用者的识别码 （UID） 来决定很多重要的变量数据， 这也是每
个使用者登陆取得 bash 时一定会读取的配置文件！ 所以如果你想要帮所有使用者设置整体环境，那就是改这里啰！不过，没事还是不要随便
改这个文件喔 这个文件设置的变量主要有：
PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录；
MAIL：依据帐号设置好使用者的 mailbox 到 /var/spool/mail/帐号名；
USER：根据使用者的帐号设置此一变量内容；
HOSTNAME：依据主机的 hostname 指令决定此一变量内容；
HISTSIZE：历史命令记录笔数。CentOS 7.x 设置为 1000 ；
umask：包括 root 默认为 022 而一般用户为 002 等！
/etc/profile 可不止会做这些事而已，他还会去调用外部的设置数据喔！在 CentOS 7.x 默认的情况下，下面这些数据会依序的被调用进
来：
/etc/profile.d/*.sh
其实这是个目录内的众多文件！只要在 /etc/profile.d/ 这个目录内且扩展名为 .sh ，另外，使用者能够具有 r 的权限， 那么该文件
就会被 /etc/profile 调用进来。在 CentOS 7.x 中，这个目录下面的文件规范了 bash 操作接口的颜色、 语系、ll 与 ls 指令的命令别名、vi
的命令别名、which 的命令别名等等。如果你需要帮所有使用者设置一些共享的命令别名时， 可以在这个目录下面自行创建扩展名为 .sh
的文件，并将所需要的数据写入即可喔！
/etc/locale.conf
这个文件是由 /etc/profile.d/lang.sh 调用进来的！这也是我们决定 bash 默认使用何种语系的重要配置文件！ 文件里最重要的就是
LANG/LC_ALL 这些个变量的设置啦！我们在前面的 locale 讨论过这个文件啰！ 自行回去瞧瞧先！
/usr/share/bash-completion/completions/*
记得我们上头谈过 [tab] 的妙用吧？除了命令补齐、文件名补齐之外，还可以进行指令的选项/参数补齐功能！那就是从这个目录里
面找到相对应的指令来处理的！ 其实这个目录下面的内容是由 /etc/profile.d/bash_completion.sh 这个文件载入的啦！
反正你只要记得，bash 的 login shell 情况下所读取的整体环境配置文件其实只有 /etc/profile，但是 /etc/profile 还会调用出其他的配置文
件，所以让我们的 bash 操作接口变的非常的友善啦！ 接下来，让我们来瞧瞧，那么个人偏好的配置文件又是怎么回事？
~/.bash_profile （（login shell 才才会会读读））
bash 在读完了整体环境设置的 /etc/profile 并借此调用其他配置文件后，接下来则是会读取使用者的个人配置文件。 在 login shell 的
bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是：
1. ~/.bash_profile