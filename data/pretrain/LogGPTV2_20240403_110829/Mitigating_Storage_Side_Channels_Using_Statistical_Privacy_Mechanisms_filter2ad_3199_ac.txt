When a ﬁle in procfs is read by a userspace process, a ker-
nel function is invoked to serve the request, and the return
values are sent to the process as if it is reading a ﬁle. The
values reported by procfs are computed from ﬁelds in cer-
tain kernel data structures. To generate d∗-private outputs,
a kernel extension privfs computes noised versions of those
protected ﬁelds for use by the kernel function computing the
procfs output.
Speciﬁcally, privfs introduces a kernel data structure of
type privfs_struct per kernel data-structure ﬁeld x that is
protected (rendered d∗-private) by dpprocfs. This structure
includes two arrays of ﬂoating-point values. After access i
to the data-structure ﬁeld x to which the privfs_struct
structure is associated, position log2 D(i) in these arrays
are updated to hold x[i] − x[G(i)] and ri, respectively. To-
gether with xh2⌊log2 i⌋i and ˜xh2⌊log2 i⌋i, which the struc-
ture also stores, these arrays permit the eﬃcient computa-
tion of ˜x[i + 1]. Also to speed up this computation, the
privfs_struct structure maintains a buﬀer of 32B to store
precomputed random values ri+1, ri+2,
. . . following the
speciﬁed Laplace distributions. Buﬀer reﬁlling is imple-
mented as a tasklet, a type of software IRQ in Linux kernels.
The arrays in privfs_struct in our present implementa-
tion are of ﬁxed length, speciﬁcally 32 ﬂoating-point values,
which limits the number of queries to the protected data-
structure ﬁeld to 232 − 1. These arrays might instead be
made arbitrarily extensible so as to allow an unlimited num-
ber of queries. That said, as the query count i grows, the
accuracy of the returned ˜x[i] value decays. As such, alterna-
tive designs might limit (or rate-limit) the number of queries
to any protected data-structure ﬁeld by each userspace pro-
cess or its associated user. Another implementation choice
might be to maintain separate arrays for each user of the
system, so that queries from one user would not decrease
the utility of queries from other users.
1http://www.ibm.com/software/commerce/
optimization/cplex-optimizer/
privfs does not return ˜x[i] directly for use in computing
the procfs output. Instead, it sends this value to privfsd
for enforcing invariants across all noised values. privfsd will
be discussed in Sec. 5.3, after we discuss how data-structure
invariants are identiﬁed in Sec. 5.2.
5.2 Invariant Generation
Kernel data-structure invariants are generated by a com-
ponent called invgen. invgen generates two types of in-
variants, namely one-ﬁeld and multiple-ﬁeld invariants as
discussed in Sec. 4.4. One-ﬁeld invariants are relationships
between a ﬁeld’s current and previous values. Multiple-ﬁeld
invariants are relationships between diﬀerent variables when
accessed at the same time.
As discussed in Sec. 4.4, our system generates invariants
from traces of data-structure values captured during exe-
cution. Speciﬁcally, invgen does so by collecting execution
traces of all numerical data-structure ﬁelds that are relevant
to procfs outputs. To do so, we patch an OS kernel by
adding one more ﬁle in the procfs to directly export all nu-
meric kernel data-structure ﬁelds of interest. invgen then
repeatedly reads the extended procfs ﬁle, sampling the val-
ues of these ﬁelds frequently and writing them into trace
ﬁles. For this paper, traces were collected by monitoring
the data-structure ﬁelds during the execution of a variety of
software programs, including Google Chrome and a set of
benchmark applications from Phoronix Test Suite2. By exe-
cuting each benchmark application three times, we collected
22.6MB of trace ﬁles.
We then used Daikon [22] to extract invariants from these
trace ﬁles. To use Daikon, we ﬁrst conﬁgured it with in-
variant templates, or ﬁlters, that the tool uses to search
for invariants. For one-ﬁeld invariants, Daikon was conﬁg-
ured with ﬁlters to locate ﬁelds that do not change, that are
monotonically nonincreasing, or that are monotonically non-
decreasing. For multiple-ﬁeld invariants, we implemented a
ﬁlter that Daikon uses to search for linear invariants among a
set X of ﬁelds, i.e., a property of the form Px∈X cx ×x[i] ≥ 0
that holds for all i, for some constant cx ∈ {−1, 0, 1}. We
ran Daikon with this ﬁlter for two sets X , one for memory-
related ﬁelds and one for scheduler-related ﬁelds. After using
Daikon to extract likely invariants in this way, we manually
inspected the outputs and discarded those that were either
implied by others or that we believed to be spurious.
The invariants produced in this way are shown in Table 2.
(We also include invariants that all ﬁelds are integral, but
we do not show those, for brevity.) The right half of the ta-
ble shows the invariants expressed using the labels for kernel
data-structure ﬁelds indicated in the left half of the table.
The ﬁelds marked “Protected” in the left half of the table
are those that dpprocfs renders d∗-private in our present
implementation. Those ﬁelds marked with a “z” were se-
lected based on their use in existing attacks (see Sec. 3.1),
and those marked with a “checkmark” were selected for pro-
tection because they are included in invariants with such
ﬁelds. One ﬁeld, namely uptime, is not protected in our
present implementation despite being included in invariants,
simply because the information it carries (the time since the
machine was booted) seems unlikely to carry information
useful to a side-channel attack. That said, it could also be
protected with minimal additional cost.
2http://www.phoronix-test-suite.com
1587Data-structure ﬁeld
Protected
Label
Invariants
z
mm_struct.total_vm
mm_struct.shared_vm
mm_struct.stack_vm
X
mm_struct.exec_vm
mm_struct.rss_stat.count[MM_FILEPAGES] z
mm_struct.rss_stat.count[MM_ANONPAGES] z
mm_struct.rss_stat.count[MM_SWAPENTS] X
X
mm_struct.hiwater_rss
mm_struct.hiwater_vm
z
X
X
task_struct.utime
task_struct.stime
task_struct.gtime
task_struct.signal->cstime
task_struct.signal->cutime
task_struct.real_start_time
task_struct.nvcsw
task_struct.nivcsw
get monotonic boottime()
z
X
X
X
X
X
z
z
totalVM
sharedVM
stackVM
execVM
ﬁlePages
anonPages
swapEnts
hiwaterRSS
hiwaterVM
utime
stime
gtime
cstime
cutime
starttime
nvcsw
nivcsw
uptime
swapEnts ≥ 0
cstime ≥ 0 utime[i] ≥ utime[i − 1]
totalVM ≥ 0
sharedVM ≥ 0 hiwaterRSS ≥ 0 cutime ≥ 0 stime[i] ≥ stime[i − 1]
hiwaterVM ≥ 0 nvcsw ≥ 0 gtime[i] ≥ gtime[i − 1]
stackVM ≥ 0
utime ≥ 0
execVM ≥ 0
ﬁlePages ≥ 0
stime ≥ 0
anonPages ≥ 0 gtime ≥ 0
nivcsw ≥ 0 cstime[i] ≥ cstime[i − 1]
cutime[i] ≥ cutime[i − 1]
nvcsw[i] ≥ nvcsw[i − 1]
nivcsw[i] ≥ nivcsw[i − 1]
starttime[i] = starttime[i − 1]
hiwaterRSS /status ﬁle of the bash process every second5
to obtain the voluntary context switch counter nvcsw, yield-
ing six readings (a vector in N6).
Invariant enforcement
(Sec. 5.3) provided the nearest solution to the needed in-
variants. To allow for a powerful attacker, we provided to it
the underlying normal distribution imposed on the keystroke
timing. The attacker used this distribution to estimate the
true (unnoised) nvcsw value corresponding to each vector el-
ement (adapting [34, Eqn. 10]), yielding an estimated true
vector per collected vector. We repeated this experiment
440 times to get 440 estimated true vectors. When training
and testing the SVM classiﬁer, we used 75% of the vectors
from each class for training and 25% for testing.
The accuracy of the resulting classiﬁer on the testing ex-
amples is shown in Fig. 1(a). The horizontal axis shows var-
ious values of ǫ; the vertical axis shows classiﬁer accuracy.
Because of the form of the distribution imposed on keystroke
4http://scikit-learn.org/dev/index.html
5This interval is much longer than in the demonstrated at-
tack of Jana et al. [25], but we lengthened this interval to
minimize ambiguity regarding the class i ∈ {1 . . . 5} to which
each vector should be assigned for training. By increasing
this interval, we believe we produced classiﬁcation results
that are conservative (i.e., advantageous for the attacker).
y
c