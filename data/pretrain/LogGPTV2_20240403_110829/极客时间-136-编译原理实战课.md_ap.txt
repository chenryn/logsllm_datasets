# 14 \| Java JIT编译器（二）：Sea of Nodes为何如此强大？你好，我是宫文学。这一讲，我们继续来研究 Graal编译器，重点来了解一下它的 IR的设计。 在上一讲中，我们发现 Graal在执行过程中，创建了一个图的数据结构，这个数据结构就是 Graal 的IR。之后的很多处理和优化算法，都是基于这个 IR 的。可以说，这个 IR 是Graal 编译器的核心特性之一。**那么，为什么这个 IR采用的是图结构？它有什么特点和优点？编译器的优化算法又是如何基于这个 IR来运行的呢？**今天，我就带你一起来攻破以上这些问题。在揭晓问题答案的过程中，你对真实编译器中IR的设计和优化处理过程，也就能获得直观的认识了。基于图的 IRIR对于编译器非常重要，因为它填补了高级语言和机器语言在语义上的巨大差别。比如说，你在高级语言中是使用一个数组，而翻译成最高效的x86 机器码，是用间接寻址的方式，去访问一块连续的内存。所以 IR的设计必须有利于实现这种转换，并且还要有利于运行优化算法，使得生成的代码更加高效。在上一讲中，通过跟踪 Graal编译器的执行过程，我们会发现它在一开始，就把字节码翻译成了一种新的IR，这个 IR是用图的结构来表示的。那这个图长什么样子呢？非常幸运的是，我们可以用工具来直观地看到它的结构。你可以从 Oracle 的网站上，下载一个**idealgraphvisualizer**的工具。下载之后，解压缩，并运行它：    export PATH="//idealgraphvisualizer/bin:$PATH"    idealgraphvisualizer &这时，程序会启动一个图形界面，并在 4445 端口上等待 GraalVM发送数据过来。接着，还是运行 Foo示例程序，不过这次你要增加一个参数"`-Dgraal.Dump`"，这会让 GraalVM输出编译过程的一些中间结果。并且在这个示例程序当中，我还增加了一个"`-Xcomp`"参数，它能让 JIT编译器在第一次使用某个方法的时候，就去做编译工作。    mx vm \      -XX:+UnlockExperimentalVMOptions \      -XX:+EnableJVMCI \      -XX:+UseJVMCICompiler \      -XX:-TieredCompilation \      -XX:CompileOnly=Foo \      -Dgraal.Dump \      -Xcomp \    FooGraalVM 会在终端输出"`Connected to the IGV on 127.0.0.1:4445`"，这表明它连接上了idealgraphvisualizer。接着，在即时编译之后，idealgraphvisualizer就接收到了编译过程中生成的图，你可以点击显示它。这里我展示了其中两个阶段的图，一个是刚解析完字节码之后（Afterparsing），一个是在处理完中间层之后（After midtier）。 ![](Images/77624b7ec2d3764db8370b9e17ed8734.png)savepage-src="https://static001.geekbang.org/resource/image/28/2b/28a6cd4180b3a28ce59098a2f5a4c82b.jpg"}图 1：After parsingslate-object="mark"}![](Images/89c8b512da339792c34738f7c79eb73f.png)savepage-src="https://static001.geekbang.org/resource/image/94/77/9448a684d1b3e04b695bc0761a6b7c77.jpg"}图 2：After mid tierslate-object="mark"}Graal IR其实受到了"程序依赖图"的影响。我们在第 6 讲slate-object="inline"中提到过程序依赖图（PDG），它是用图来表示程序中的数据依赖和控制依赖。并且你也知道了，这种IR 还有一个别名，叫做**节点之海（Sea ofNodes）**。因为当程序稍微复杂一点以后，图里的节点就会变得非常多，我们用肉眼很难看得清。基于 Sea of Nodes 的 IR 呢，算是后起之秀。在 HotSpot的编译器中，就采用了这种 IR，而且现在 Java 的 Graal 编译器和 JavaScript的 V8 编译器中的 IR 的设计，都是基于了 Sea of Nodes结构，所以我们必须重视它。这也不禁让我们感到好奇了：**Sea of Nodes到底强在哪里？**我们都知道，数据结构的设计对于算法来说至关重要。IR的数据结构，会影响到算法的编写方式。好的 IR的设计，会让优化算法的编写和维护都更加容易。**而 Sea of Nodes最大的优点，就是能够用一个数据结构同时反映控制流和数据流，并且尽量减少它们之间的互相依赖**。怎么理解这个优点呢？在传统的编译器里，控制流和数据流是分开的。控制流是用控制流图（Control-flowGraph，CFG）来表示的，比如 GNU 的编译器、LLVM，都是基于控制流图的。而 IR本身，则侧重于表达数据流。以 LLVM 为例，它采用了 SSA 格式的 IR，这种 IR可以很好地体现值的定义和使用关系，从而很好地刻画了数据流。而问题在于，采用这种比较传统的方式，控制流和数据流会耦合得比较紧，因为IR 指令必须归属于某个基本块。举个例子来说明一下吧。在下面的示例程序中，"`int b = a*2;`"这个语句，会被放到循环体的基本块中。    int foo(int a){        int sum = 0;        for(int i = 0; i  > 关闭内联优化: -XX:-Inlining。JDK8> 缺省是打开的。> > >>>  > 显示内联优化详情：-XX:+PrintInlining。> > >>>  > 关闭逃逸分析：-XX:-DoEscapeAnalysis。JDK8> 缺省是打开的。> > >>>  > 显示逃逸分析详情：-XX:+PrintEscapeAnalysis。> > >>>  > 关闭标量替换：-XX:-EliminateAllocations。JDK8> 缺省是打开的。> > >>>  > 显示标量替换详情：-XX:+PrintEliminateAllocations。> > >参考资料1.       多态内联：        [Inlining of Virtual    Methods         slate-object="inline"    。        2.       逃逸分析：        [Escape Analysis for    Java         slate-object="inline"    。        3.       部分逃逸分析：        [Partial Escape Analysis and Scalar Replacement for    Java         slate-object="inline"    。        