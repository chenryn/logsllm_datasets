CB2
CB2
CA2
CA3
CA4
CB2
CB5
CB2
{CB5 ← f alse}
prunedenial
R
R
R
CB1
CA1
CB1
CB2
CB1
CA4
CB2
CB1
CB2
pruneredundant
CA4
CB2
CB2
(c) Example of denial pruning and redun-
dancy pruning
Sd = {CA2, CB4,
R ← (CB1 ∧ CB2) ∨ (CB3 ∧ CB4) ∨ CB5,
CB1 ← CA1 ∨ (CA2 ∧ CA3),
CB3 ← CA2, CB5 ← CA6 ∧ CA7,
CA1 ← CB1, CA3 ← CB4, CA6 ← f alse}
view(Sd) contains the following derivation trees:
R
R
CB2
CB3
CB1
CA3
(d) Example of a view
Figure 5: Examples of operations on disclosure trees
a disclosure tree should have at least one leaf node that is
a credential that the other party wants P to disclose. We
have the following deﬁnition:
Definition 6.7. Disclosure tree T ’s evolvable leaves for
PA, denoted evolvable(T,PA), are the set of leaf nodes C of
T such that either C = R and PA is the server, or C appears
in a policy that PB disclosed to PA. If evolvable(T,PA) (cid:9)= ∅,
T is evolvable for PA.
The disclosure tree in ﬁgure 6 is evolvable for both PA
and PB.
If a negotiation reaches a point where every leaf node of
some disclosure tree is unlocked, then the tree is a full tree
and corresponds to a safe disclosure sequence.
Definition 6.8. Let PA be a negotiation party, T be a
disclosure tree, and S be a set of policies and credentials. If
every resource in evolvable(T,PA) is unlocked by credentials
in S, then we say T is semi-full with S for PA. Further, we
say T is f ull with S iﬀ every leaf node of T is unlocked by
credentials in S.
ators
6.2 Strategy Caution and Strategy Set Gener-
If F is a strategy family, then intuitively, every strategy
in F always discloses enough information to keep the nego-
tiation moving towards success, if success is possible. If F is
also closed, then F must also contain those strategies that
disclose only the minimal amount of information needed to
continue negotiations. Therefore it is helpful to formally
deﬁne a relationship between strategies based on the infor-
mation they disclose.
Definition 6.9. Given two negotiation strategies f1 and
f2, if for all possible inputs G, L, and R to f1 and f2, we
have
152R
view(Sd) :
CB1
CB2
CA1
CA2
Figure 6: view(Sd) where Sd = {R ← CB1 ∧ CB2, CB1 ← CA1 ∧ CA2}
∀m ∈ f2(G, L, R) ∃m(cid:2) ∈ f1(G, L, R) m(cid:2) ⊆ m
then we say f1 is at least as cautious as f2, denoted f1 (cid:19) f2
or f2 (cid:20) f1.
Caution deﬁnes a partial order between strategies. Intu-
itively, if f2 (cid:20) f1 then f2 always discloses at least as much
information as f1 does.
Definition 6.10. Given a strategy f , the set of strategies
generated by f , denoted StraSet(f ), is the set F = {f(cid:2)|f(cid:2) (cid:20)
f}. f is called the generator of F .
As we discussed in section 6.1, during a trust negotia-
tion, evolvable trees give guidance on what a party needs to
disclose in the next message so that the whole negotiation
advances towards potential success. If there is no evolvable
tree, then a cautious party will choose to end the negoti-
ation even if the policies of the two parties allow success.
Therefore, a strategy must ensure that the other party will
have an evolvable tree when the other party needs to make
its next disclosure. The only exception is when the strategy
knows that no disclosure tree can evolve into a full tree.
7. THE DTS FAMILY
sent unless there is no disclosure tree at all, in which case
the negotiation cannot succeed anyway. Formally, we have
the following theorems:
Theorem 7.1. The set of strategies generated by DTS is
a family.
Theorem 7.2. If a strategy f and DT S are compatible,
then f (cid:20) DT S.
We call the family generated by DTS the DTS family. By
theorems 7.1 and 7.2, we get the following corollary imme-
diately.
Corollary 7.1. The DTS family is closed.
As we mentioned in section 5, one advantage of a strategy
family can be the ability to adopt diﬀerent strategies from a
family in diﬀerent phases of the negotiation. Correct inter-
operability is guaranteed as long as both parties’ strategies
are from the same family.
Definition 7.2. Let f1 and f2 be two strategies. A strat-
(G, L, R) ⊆
is a hybrid of f1 and f2 if ∀G, L, R, f(cid:2)
egy f(cid:2)
f1(G, L, R) ∪ f2(G, L, R) and f(cid:2) (cid:9)= f1 and f(cid:2) (cid:9)= f2.
We present the disclosure tree strategy (DTS), then prove
that DTS generates a closed family. Throughout this sec-
tion, we assume that G = (m1, . . . , mk) is a sequence of
messages such that mi (cid:9)= ∅ and R /∈ mi for 1 ≤ i ≤ k.
We assume LA and LB are the local policies of parties PA
and PB respectively, and Sd =
1≤i≤k mi. Without loss of
generality, we assume PA will send the next message to PB.
Definition 7.1. The Disclosure Tree Strategy is a strat-
(cid:1)
egy DT S(G, LA, R) such that:
1) DT S(G, LA, R) = {∅} if and only if view(Sd ∪ LA) = ∅
or view(Sd) has no evolvable tree for PA.
2) Otherwise, DT S(G, LA, R) contains all messages m(cid:2)
such
that one of the following conditions holds:
• m(cid:2)
• m(cid:2)
= {R}, if credentials in Sd unlock R;
is a non-empty set of credentials and poli-
cies such that view(Sd ∪ m(cid:2)
) contains at least one
evolvable tree for PB, and no non-empty proper
subset of m(cid:2)
has this property.
Condition 1) tells when DTS will terminate the negotia-
tion. Condition 2) guarantees that the other party will have
an evolvable tree, so the other party can send a message
that further evolves a tree. Thus, no failure message will be
Theorem 7.3. Let f1 and f2 be strategies in the DTS
is also
be a hybrid of f1 and f2. Then f(cid:2)
family and let f(cid:2)
in the DTS family.
If a security agent adopts diﬀerent DTS family strategies
in diﬀerent phases of trust negotiation, it is equivalent to
adopting a hybrid of those strategies. Therefore, as long
as both parties use strategies from the DTS family, they
can switch between diﬀerent practical strategies as often as
they like, and trust negotiation will still succeed whenever
possible.
Although disclosure trees are a useful tool for understand-
ing strategy properties, it would require exponential time
and space to materialize all the disclosure trees during a ne-
gotiation. Fortunately, many strategies in the DTS family
are quite eﬃcient. We present two eﬃcient strategies, Trust-
Builder-Simple and TrustBuilder-Relevant, which are both
in the DTS family.
TrustBuilder-Simple (ﬁgure 7(a)) puts all undisclosed poli-
cies and unlocked credentials in the next message to the
other party. If all the policies and unlocked credentials have
already been disclosed, it fails.
We say a credential C is syntactically relevant to resource
R iﬀ C appears in R’s policy, or C appears in the pol-
icy of a credential C(cid:2)
In contrast
to TrustBuilder-Simple, the TrustBuilder-Relevant strategy
that is relevant to R.
153TrustBuilder-Simple Strategy
Input:
G = (m1, . . . , mk): a sequence of safe disclosure
messages.
L: the local resources and policies of this party.
R: the resource to which access was originally
requested.
TrustBuilder-Relevant Strategy
Input:
G = (m1, . . . , mk): a sequence of safe disclosure
messages.
L: the local resources and policies of this party.
R: the resource to which access was originally
requested.
Output:
Pre-condition:
A set containing a single disclosure message m.
R has not been disclosed and mk (cid:9)= ∅.
Let PA be the local party and PB the remote party.
(cid:1)
Sd =
m = ∅;
For every local credential C that is unlocked by Sd
1≤i≤k mi;
m = m ∪ {C};
For every local locked credential C
if (C’s policy P is not a denial policy)
For every policy P (cid:2) ∈ Sd such that P (cid:2) /∈ L
then m = m ∪ {P};
For every credential that C appears in P (cid:2)
has a denial policy
m = m ∪ {C ← f alse};
and
m = m − Sd;
return {m};
Output:
Pre-condition:
A set containing a single disclosure message m.
R has not been disclosed and mk (cid:9)= ∅.
Let PA be the local party and PB the remote party.
(cid:1)
Sd =
m = ∅;
For every local credential C syntactically relevant to R
1≤i≤k mi;
if (C is unlocked by Sd)
then m = m ∪ {C};
else m = m ∪ {C(cid:2)s policy};
For every policy P (cid:2) ∈ Sd such that P (cid:2) /∈ L
For every credential C that appears in P (cid:2)
has a denial policy
m = m ∪ {C ← f alse};
m = m − Sd;
return {m};
and
(a)
(b)
Figure 7: Pseudocode for two strategies in the DTS family
(ﬁgure 7(b)) discloses a credential C’s policy only if C is syn-
tactically relevant to R. Similarly, TrustBuilder-Relevant
only discloses syntactically relevant unlocked credentials.
Proposition 7.1. If a credential C appears in a disclo-
sure tree for R, then C is relevant to R.
Theorem 7.4. TrustBuilder-Simple and TrustBuilder-Re-
levant belong to the DTS family.
Theorem 7.5. The computation costs of TrustBuilder-
Simple and TrustBuilder-Relevant in the whole process of
trust negotiation are bounded by O(nm), where n is the total
number of credentials and m is the total size of the policies
of both parties.
The worst-case behavior of TrustBuilder-Simple and Trust-
Builder-Relevant occurs when every credential belonging to
one party appears in every policy belonging to the other
party, and each disclosure message discloses a single creden-
tial or policy.
8. SUMMARY AND FUTURE WORK
This paper focused on guaranteeing interoperability be-
tween diﬀerent strategies. We ﬁrst proposed a very simple
trust negotiation protocol for the TrustBuilder trust negotia-
tion architecture. Then we studied strategies that adhere to
this protocol. We introduced the concepts of strategy fami-
lies and closed sets of strategies. If two strategies are in the
same strategy family, then they will always correctly interop-
erate with each other. Closure expresses the maximality of
a strategy family, i.e., if we add another strategy to a closed
family, the resulting set of strategies is no longer a family.
In practice, we want to identify closed families of strategies
because they give negotiation participants maximum free-
dom in choosing the strategies appropriate for them. We
introduced the concept of disclosure trees and identiﬁed the
natural mapping between full disclosure trees and safe cre-
dential disclosure sequences. We then proposed the disclo-
sure tree strategy (DTS), and proved that all the strategies
that are no more cautious than DTS form a closed strategy
family. Finally we gave examples of practical strategies from
the DTS family.
In this paper, we assume a credential’s policy is freely
available, which means it can be shown to others whenever
requested. However, some policies contain sensitive informa-
tion that should be protected from arbitrary disclosure. We
are currently investigating strategy families for use in this
situation and with non-propositional policy languages. We
are also implementing TrustBuilder for testbed experimen-
tation in e-commerce applications, and investigating more
sophisticated deﬁnitions of “minimal” disclosure for use with
practical policies.
9. ACKNOWLEDGEMENTS
This research was supported by DARPA, via AFRL F30602-
97-C-0336 (NAI Labs), AFRL F33615-01-C-1805 (BYU),
154and SPAWAR SCSD N66001-01-1-8908 (BYU). We also thank
Shanghua Teng and Jim Gray for their constructive discus-
sions and suggestions.
[9] http://www.ietf.org/html.charters/spki-charter.html.
Simple Public Key Infrastructure (SPKI).
[10] International Telecommunication Union. Rec. X.509 -
10. REFERENCES
[1] K. R. Apt, D. S. Warren, and M. Truszczynski
(editor). The Logic Programming Paradigm: A
25-Year Perspective. Springer-Verlag, 1999.
[2] M. Blaze, J. Feigenbaum, J. Ioannidis, and
A. Keromytis. The KeyNote Trust Management
System Version 2. In Internet Draft RFC 2704,
September 1999.
[3] M. Blaze, J. Feigenbaum, and A. D. Keromytis.
KeyNote: Trust Management for Public-Key
Infrastructures. In Security Protocols Workshop,
Cambridge, UK, 1998.
[4] P. Bonatti and P. Samarati. Regulating Service Access
and Information Release on the Web. In Conference
on Computer and Communications Security, Athens,
November 2000.
[5] T. Dierks and C. Allen. The TLS Protocol Version 1.0.
In http://www.ietf.org/rfc/rfc2246.txt, January 1999.
[6] S. Farrell. TLS Extension for Attribute Certiﬁcate
Based Authorization. In http://www.ietf.org/internet-
drafts/draft-ietf-tls-attr-cert-01.txt, August
1998.
[7] A. Frier, P. Karlton, and P. Kocher. The SSL 3.0
Protocol. Netscape Communications Corp., November
1996.
[8] A. Herzberg, J. Mihaeli, Y. Mass, D. Naor, and
Y. Ravid. Access Control Meets Public Key
Infrastructure, Or: Assigning Roles to Strangers. In
IEEE Symposium on Security and Privacy, Oakland,
CA, May 2000.
Information Technology - Open Systems
Interconnection - The Directory: Authentication
Framework, August 1997.
[11] W. Johnson, S. Mudumbai, and M. Thompson.
Authorization and Attribute Certiﬁcates for Widely
Distributed Access Control. In IEEE International
Workshop on Enabling Technologies: Infrastructure
for Collaborative Enterprises, 1998.
[12] K. Seamons, M. Winslett, and T. Yu. Limiting the
Disclosure of Access Control Policies during
Automated Trust Negotiation. In Network and
Distributed System Security Symposium, San Diego,
CA, April 2001.
[13] W3C,
http://www.w3.org/TR/WD-P3P/Overview.html.
Platform for Privacy Preferences (P3P) Speciﬁcation.
[14] W. Winsborough, K. Seamons, and V. Jones.
Automated Trust Negotiation. In DARPA
Information Survivability Conference and Exposition,
Hilton Head, SC, January 2000.
[15] T. Yu, X. Ma, and M. Winslett. PRUNES: An
Eﬃcient and Complete Strategy for Automated Trust
Negotiation over the Internet. In Conference on
Computer and Communication Security, Athens,
Greece, November 2000.
[16] T. Yu, M. Winslett, and K. Seamons. Interoperable
Strategies in Automated Trust Negotiation. In
http://drl.cs.uiuc.edu/pubs/ccs2001-long.ps.
[17] P. Zimmerman. PGP User’s Guide. MIT Press, 1994.
155