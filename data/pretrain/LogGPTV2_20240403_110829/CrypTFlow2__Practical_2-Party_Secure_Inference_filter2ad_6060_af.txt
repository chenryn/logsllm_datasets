non-trivial term to compute is ğ¶ that involves three signed compar-
isons over Z. We emulate these comparisons using calls to F int,ğ›¿
DReLU
where ğ›¿ is large enough to ensure that there are no overflows or
underflows. It is not too hard to see that âˆ’2ğ‘‘ + 2 â‰¤ ğ´ â‰¤ 2ğ‘‘ âˆ’ 2
and hence, âˆ’3ğ‘‘ + 2 â‰¤ ğ´ âˆ’ ğ‘‘, ğ´, ğ´ + ğ‘‘ â‰¤ 3ğ‘‘ âˆ’ 2. Hence, we set
ğ›¿ = âŒˆlog 6ğ‘‘âŒ‰. Now, with this value of ğ›¿, the term ğ¶ can we re-written
as (DReLU(ğ´ âˆ’ ğ‘‘) âŠ• 1) + (DReLU(ğ´) âŠ• 1) + (DReLU(ğ´ + ğ‘‘) âŠ• 1),
which can be computed using three calls to F int,ğ›¿
DReLU (Step 19) and
F ğ‘›
B2A (Step 20) each. Finally, note that to compute ğ¶ we need arith-
metic shares of ğ´ over the ring ZÎ”, Î” = 2ğ›¿. And this requires shares
of corr over the same ring. Hence, we compute shares of corr over
both Zğ‘› and ZÎ” (Step 15). Due to space constraints, we describe
the protocol formally in Appendix D along with its communication
complexity. Also, Table 3 provides theoretical and concrete com-
munication numbers for division in both Zğ¿ and Zğ‘›, as well as a
comparison with garbled circuits.
4.2.3 Truncation in rings with special structure. It is easy to
see that truncation by ğ‘  in general rings can be done by performing
a division by ğ‘‘ = 2ğ‘ . However, we can omit a call to F int,ğ›¿
DReLU and
F ğ‘›
B2A when the underlying ring and ğ‘‘ satisfy a relation. Specifically,
if we have 2 Â· ğ‘›0 â‰¤ ğ‘‘ = 2ğ‘ , then ğ´ is always greater than equal
to âˆ’ğ‘‘, where ğ‘›0, ğ´ âˆˆ Z are as defined in Theorem 4.1. Thus, the
third comparison (ğ´  0 and ğ‘§ = ğ‘¦, if ğ‘¤ â‰¤ 0.
Define ğ‘§1 = ğ‘1 and ğ‘§ğ‘– = gt(ğ‘ğ‘–, ğ‘§ğ‘–âˆ’1), recursively for all 2 â‰¤ ğ‘– â‰¤ ğ‘‘.
Now, Maxpoolğ‘‘(ğ‘1, Â· Â· Â· , ğ‘ğ‘‘) = ğ‘§ğ‘‘.
We now describe a protocol such that parties begin with arith-
metic shares (over Zğ¿) of ğ‘ğ‘–, for all ğ‘– âˆˆ [ğ‘‘] and end the protocol with
arithmetic shares (over Zğ¿) of Maxpoolğ‘‘(ğ‘1, Â· Â· Â· , ğ‘ğ‘‘). For simplic-
ity, we describe how ğ‘ƒ0 and ğ‘ƒ1 can compute shares of ğ‘§ = gt(ğ‘¥, ğ‘¦)
(beginning with the shares of ğ‘¥ and ğ‘¦). It is easy to see then how
on inputs âŸ¨ğ‘¤âŸ©ğ¿
ğ‘–=1âŸ¨ğ‘ğ‘–âŸ©ğ¿
DIV
DIV
ğ‘ . Finally, parties output âŸ¨ğ‘§âŸ©ğ¿
ğ‘ = âŸ¨ğ‘¥âŸ©ğ¿
DReLU with input âŸ¨ğ‘¤âŸ©ğ¿
MUX with input âŸ¨ğ‘¤âŸ©ğ¿
ğ‘ = âŸ¨ğ‘¦âŸ©ğ¿
they can compute Maxpoolğ‘‘. First, parties locally compute shares
ğ‘ âˆ’ âŸ¨ğ‘¦âŸ©ğ¿
ğ‘ , for ğ‘ âˆˆ {0, 1}).
of ğ‘¤ = ğ‘¥ âˆ’ ğ‘¦ (i.e., ğ‘ƒğ‘ computes âŸ¨ğ‘¤âŸ©ğ¿
ğ‘ to learn output âŸ¨ğ‘£âŸ©ğµ
Next, they invoke F int,â„“
ğ‘ .
ğ‘ and âŸ¨ğ‘£âŸ©ğµ
Now, they invoke F ğ¿
ğ‘ to learn output
âŸ¨ğ‘¡âŸ©ğ¿
ğ‘ + âŸ¨ğ‘¡âŸ©ğ¿
ğ‘ . The correctness
and security of the protocol follows in a straightforward manner.
Computing Maxpoolğ‘‘ is done using ğ‘‘ âˆ’ 1 invocations of the above
sub-protocol in ğ‘‘ âˆ’ 1 sequential steps.
Argmaxğ‘‘(ğ‘1, Â· Â· Â· , ğ‘ğ‘‘) is defined similar to Maxpoolğ‘‘(ğ‘1, Â· Â· Â· , ğ‘ğ‘‘),
except that its output is an index ğ‘–âˆ— s.t. ğ‘ğ‘–âˆ— = Maxpoolğ‘‘(ğ‘1, Â· Â· Â· , ğ‘ğ‘‘).
Argmaxğ‘‘ can be computed securely similar to Maxpoolğ‘‘(ğ‘1, Â· Â· Â· , ğ‘ğ‘‘).
6 IMPLEMENTATION
1
1
We implement our cryptographic protocols in a library and inte-
grate them into the CrypTFlow framework [1, 45] as a new crypto-
graphic backend. CrypTFlow compiles high-level TensorFlow [3]
inference code to secure computation protocols using its frontend
Athos, that are then executed by its cryptographic backends. We
modify the truncation behavior of Athos in support of faithful fixed-
point arithmetic. We start by describing the implementation of our
cryptographic library, followed by the modifications that we made
to Athos.
6.1 Cryptographic backend
To implement our protocols, we build upon the(cid:0)2
mentation from EMP [62] and extend it to(cid:0)ğ‘˜
Oblivious Transfer. (cid:0)ğ‘˜
(cid:1)-OTâ„“ imple-
(cid:1)-OTâ„“ using the proto-
(cid:1)-OTâ„“ requires a correlation robust func-
col from [44]. Our linear-layer implementation in SCIHE is based on
SEAL/Delphi [2, 58] and in SCIOT is based on EMP. All our protocol
implementations are multi-threaded.
(cid:1)-OT8).
(cid:1)-OTâ„“ (e.g.
tion to mask the senderâ€™s messages in the OT extension protocol,
256 (re-keyed AES with 256-bit key)9 to instantiate
and we use AESRK
it as in [23, 25]. We incorporated the optimizations from [33, 34]
256 calls. This leads
for AES key expansion and pipelining these AESRK
to roughly 6Ã— improvement in the performance of AESRK
256 calls,
considerably improving the overall execution time of(cid:0)ğ‘˜
2.7Ã— over LAN for(cid:0)16
the computational cost. Our protocol makes â„“/ğ‘š calls to(cid:0)ğ‘€
(cid:1)-OT2
techniques, generating an instance of(cid:0)ğ‘€
(cid:1)-OT2 requires 6 AESFK
Millionairesâ€™ protocol. Recall that ğ‘š is a parameter in our proto-
col Î â„“,ğ‘š
MILL. While we discussed the dependence of communication
complexity on ğ‘š in Section 3.1.2, here we discuss its influence on
(after merging steps 9&10), where ğ‘€ = 2ğ‘š. Using OT extension
256
and (ğ‘€+1) AESRK
256 evaluations. Thus, the computational cost grows
super-polynomially with ğ‘š. We note that for â„“ = 32, even though
communication is minimized for ğ‘š = 7, empirically we observe
that ğ‘š = 4 gives us the best performance under both LAN and
WAN settings (communication in this case is about 30% more than
when ğ‘š = 7 but computation is â‰ˆ 3Ã— lower).
1
1
1
1
1
9There are two types of AES in MPC applications - fixed-key (FK) and re-keyed (RK) [10,
35]. While the former runs key schedule only once and is more efficient, the latter
generates a new key schedule for every invocation and is required in this application.
10
Implementing linear layers in SCIHE. To implement the linear
layers in SCIHE, we build upon the Delphi implementation [2, 49],