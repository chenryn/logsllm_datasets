2
are computed. Next, a hash function H is chosen from the
family of UOWHFs. Further, an Universal Hash function H
is chosen so that H : Gq ‚Üí {0, 1}2k. Finally, the public
key of Pi is P Ki = (c, d, H, H) and the secret key is SKi =
(x1, x2, y1, y2). The public information is the collection of
the information on the underling group and of all the public
keys:
I0 = p, q, g1, g2, P K1, . . . , P Kn
The Pi‚Äôs private information consists of only its secret key:
Ii = SKi.
Next, when activated, within party Pi and with external
request to send message m to party Pj, protocol ŒªDDH in-
vokes a two-party sub-protocol ÀÜŒªDDH between Pi and Pj .
Since the sub-protocol ÀÜŒªDDH involves only two parties, we
use the names A and B instead of Pi and Pj for simplic-
ity. Going into details: Ô¨Årst, A sends ‚Äòmessage:m‚Äô to B (A
also outputs ‚ÄòA sent message m to B‚Äô). Upon receipt of
‚Äòmessage:m‚Äô from A, party B creates a challenge for A as
follows: a random r ‚àà Zq is chosen and then the following
values are computed
u1 = gr
1 , u2 = gr
2 , Œ± = H(m, B) , v = crdrŒ± , h1 = dHe(v)
13These values could also be speciÔ¨Åc to a user‚Äôs public key,
rather than common to all users.
‚Ä¢ checks the validity of the received challenge computing
and
the values Œ± = H(m, B) , v = ux1+Œ±y1
checking that h1 = dHe(v);15
ux2+Œ±y2
2
1
‚Ä¢ replies to the challenge with ‚Äòreply:m, h2‚Äô where h2 =
bHc(v).
Finally, when B receives the message ‚Äòreply:m, h2‚Äô from
A he proceeds as follows:
if h2 = bHc(v) (using its copy
of v) then B accepts m and outputs ‚ÄòB received m from
A‚Äô. Otherwise, B rejects this message and terminates this
invocation of ÀÜŒªDDH. A pictorial representation of a complete
invocation of ÀÜŒªDDH for a message m can be seen in Ô¨Ågure 3.
Theorem 5. Assume that the DDH assumption holds on
the group Gq then protocol ŒªDDH is a secure message au-
thenticator.
4.1 Deniability for ŒªDDH
As in the previous case, protocol ŒªDDH can be proven to
be a deniable authenticator if the receiver is honest. Indeed
simulator can be deÔ¨Åned by choosing at random r‚ààRZq and
computing the appropriate values, like an honest receiver
would.
The case of a dishonest receiver is more complicated. Here
we do not have an attack, but a black box simulation of
the receiver fails (once the dishonest simulator sends us
‚Äòchallenge:m, u1, u2, h1, how are we going to simulate the
answer h2?)16.
We introduce a challenge-response mechanism where A
commits to the answer h2 and then reveals it only after B
shows that he knows h2 as well. However at this point it is
redundant to split H(v) in two pieces and we can just use v
alone.
The protocol appears in Figure 4. We assume that A‚Äôs
public key includes an unconditionally binding commitment
scheme COM (i.e.
a commitment scheme that can be
opened in only one way even if you have inÔ¨Ånite computing
power, but on the other hand its secrecy is computational).
Theorem 6. Protocol Den-ŒªDDH is a forward deniable
authenticator if used sequentially.
Remark: The Ô¨Årst step is malleable. The above protocol
shows how far we have gone from the CCA paradigm. We
can think of u1, u2 as the ‚Äúencryption‚Äù of a key, and of v as
the MAC of the message. But if we do that, then we do not
know how to prove the encryption step to be CCA-secure.
Remarks: Concurrent Executions. As in the previous sec-
tion, the unforgeability property of this authenticator holds
in a concurrent setting (as in all the authenticators in the
CCA paradigm). If we use timing assumptions to force only
a logarithmic number of executions to be open at any time,
we achieve deniability in the concurrent setting as well.
14Note that the values Œ±, v are computed but they aren‚Äôt part
of the challenge message; in this way we are also reducing
the used bandwidth.
15It‚Äôs easy to see that if the challenge is correctly created
then the value v computed by B is the same than A‚Äôs one;
this for the way c, d are generated.
16An answer to this question has been recently found [8] as-
suming no-standard properties on the encryption function.
In the full version, we discuss a generalization of this method
using Projective Hash Functions.
5. REFERENCES
[1] Y. Aumann and M. Rabin, Authentication, enhanced
security and error correcting codes, Advances in
Cryptology ‚Äì proc. of CRYPTO ‚Äô98, LNCS 1462,
Springer-Verlag, pp. 299‚Äì303, 1998.
[2] Y. Aumann and M. Rabin, EÔ¨Écient deniable
authentication of long messages, in International
Conference on Theoretical Computer Science in honor
of Professor Manuel Blum‚Äôs 60th birthday, April 20-24,
1998. Available from:
http://www.cs.cityu.edu.hk/dept/video.html.
[3] M. Bellare, R. Canetti and H. Krawczyk, A Modular
Approach to the Design and Analysis of
Authentication and Key Exchange Protocols, proc. of
30th Symposium on Theory of Computing (STOC),
ACM, pp. 419‚Äì428, 1998.
[4] R. Canetti, U. Feige, O. Goldreich and M. Naor,
Adaptively Secure Multi-Party Computation, proc. of
28th Symposium on Theory of Computing (STOC),
ACM, pp. 639‚Äì648, 1996.
[5] L. Carter and M.N. Wegman, Universal Classes of
Hash Functions, Journal of Computer and System
Sciences, vol. 18, n. 2, pp. 143‚Äì154, 1979.
knowledge complexity of interactive proof-systems,
SIAM Journal on Computing, vol. 18, n. 1,
pp. 186‚Äì208, February 1989.
[16] S. Goldwasser, S. Micali and R. Rivest, A digital
signature scheme secure against adaptive
chosen-message attacks, SIAM Journal on Computing,
vol. 17, n. 2, pp. 281‚Äì308, April 1988.
[17] O. Goldreich, S. Micali and A. Wigderson, Proofs that
yield nothing but their validity or all languages in NP
have Zero-Knowledge Proof Systems, in proc. of 27th
IEEE Annual Symposium on the Foundations of
Computer Science, vol. 38, n. 1, pp. 691‚Äì729, July
1991.
[18] P. Gutman, Secure Deletion of Data from Magnetic
and Solid-State Memory, Sixth USENIX Security
Symposium Proceedings, San Jose, California, July
22-25, 1996.
[19] D. Harkins and D. Carrel, ed., ‚ÄúThe Internet Key
Exchange (IKE)‚Äù, RFC 2409, Nov. 1998.
[20] M. Jakobsson, K. Sako and R. Impagliazzo,
Designated VeriÔ¨Åer Proofs and Their Applications,
Advances in Cryptology ‚Äì proc. of EUROCRYPT ‚Äô96,
LNCS 1070, Springer-Verlag, pp. 143‚Äì154, 1996.
[21] J. Katz, EÔ¨Écient and Non-Malleable Proofs of
Plaintext Knowledge and Applications, Advances in
Cryptology ‚Äì proc. of EUROCRYPT ‚Äô03, LNCS 2656,
Springer-Verlag, pp. 211‚Äì228, 2003.
[6] R. Cramer and V.Shoup, Universal Hash Proofs and a
[22] H. Krawczyk. SKEME: a versatile secure key exchange
Paradigm for Adaptive Chosen Ciphertext Secure
Public-Key Encryption, Advances in Cryptology ‚Äì
proc. of EUROCRYPT ‚Äô02, LNCS 2332,
Springer-Verlag, pp. 45‚Äì64, 2002.
[7] W. DiÔ¨Ée and M.E. Hellman, New Directions in
Cryptography, IEEE Transactions on Information
Theory, vol. 22, n. 6, pp. 644‚Äì654, 1976.
[8] M. Di Raimondo, R. Gennaro, and H. Krawczyk,
Deniable authentication and plaintext awareness,
Manuscript.
[9] D. Dolev, C. Dwork, and M. Naor, Non-Malleable
cryptography, SIAM Journal on Computing, vol. 30,
n. 2, pp. 391‚Äì437, April 2000.
[10] C. Dwork, M. Naor and A. Sahai, Concurrent
Zero-Knowledge, proc. of 30th Symposium on Theory
of Computing (STOC), ACM, pp. 409‚Äì418, 1998. Full
version on http://www.wisdom.weizmann.ac.il/
~naor/onpub.html.
[11] J. Garay, P. MacKenzie and K. Yang, Strengthening
Zero-Knowledge Protocols Using Signatures, Advances
in Cryptology ‚Äì proc. of EUROCRYPT ‚Äô03,
LNCS 2656, Springer-Verlag, pp. 177‚Äì194, 2003.
[12] R. Gennaro, Multi-trapdoor Commitments and their
Applications to Proofs of Knowledge Secure under
Concurrent Man-in-the-middle Attacks, Advances in
Cryptology ‚Äì proc. of CRYPTO ‚Äô04, LNCS 3152,
Springer-Verlag, 2004.
[13] R. Gennaro and V. Shoup, A Note on An Encryption
Scheme of Kurosawa and Desmedt,
http://eprint.iacr.org/2004/194/.
[14] S. Goldwasser and S. Micali, Probabilistic Encryption,
Journal of Computer and System Sciences, vol. 28,
n. 2, pp. 270‚Äì299, 1984.
[15] S. Goldwasser, S. Micali, and C. RackoÔ¨Ä, The
mechanism for Internet. 1996 IEEE Symposium on
Network and Distributed System Security (SNDSS
‚Äô96).
[23] K. Kurosawa and Y. Desmedt, A New Paradigm of
Hybrid Encryption Scheme, Advances in Cryptology ‚Äì
proc. of CRYPTO ‚Äô04, LNCS 3152, Springer-Verlag,
pp. 426‚Äì442, 2004.
[24] P. MacKenzie and K. Yang, On Simulation-Sound
Commitments, Advances in Cryptology ‚Äì proc. of
EUROCRYPT ‚Äô04, LNCS 3027, Springer-Verlag,
pp. 382‚Äì400, 2004.
[25] W. Mao and K.G. Paterson. On the plausible
deniability feature of Internet protocols. Manuscript.
[26] M. Naor and M. Yung, Public-key cryptosystems
provably secure against chosen ciphertext attacks,
proc. of 22nd Symposium on Theory of Computing
(STOC), ACM, pp. 427‚Äì437, 1990.
[27] M. Naor, Deniable Ring Authentication, Advances in
Cryptology ‚Äì proc. of CRYPTO ‚Äô02, LNCS 2442,
Springer-Verlag, pp. 481‚Äì498, 2002.
[28] R. Pass, On Deniability in the Common Reference
String and Random Oracle Model, Advances in
Cryptology ‚Äì proc. of CRYPTO ‚Äô03, LNCS 2729,
Springer-Verlag, pp. 316‚Äì337, 2003.
[29] R. Rivest, A. Shamir and Y. Tauman, How to Leak a
Secret, Advances in Cryptology ‚Äì proc. of
ASIACRYPT ‚Äô01, LNCS 2248, Springer-Verlag,
pp. 552‚Äì565, 2001.
[30] V. Shoup, Using hash functions as a hedge against
chosen ciphertext attack, Advances in Cryptology ‚Äì
proc. of EUROCRYPT ‚Äô00, LNCS 1807,
Springer-Verlag, pp. 275‚Äì288, 2000.
A
pk = H(m, B)
a, r at random
C = Com(PK, pk, a, r)
protocol ÀÜŒªAMTC
B
m , C
-
r0 = Equiv(PK, pk, C, a, r, c, TK)

m , c
m , r0
c at random
-
pk = H(m, B)
C
?= Com(PK, pk, c, r0)
Figure 1: Authenticator ÀÜŒªAMTC between A and B
protocol Den-ÀÜŒªAMTC
A
pk = H(m, B)
a, r at random
C = Com(PK, pk, a, r)
?= T Ct(c, œÅ)
Œ≥
r0 = Equiv(PK, pk, C, a, r, c, TK)


m , Œ≥
m , C
m , c, œÅ
m , r0
-
-
B
c, œÅ at random
Œ≥ = T Ct(c, œÅ)
pk = H(m, B)
C
?= Com(PK, pk, c, r0)
Figure 2: Deniable Authenticator Den-ÀÜŒªAMTC between A and B
protocol ÀÜŒªDDH
A

Œ± = H(m, B)
v = ux1+Œ±y1
?= dHe(v)
h1
1
ux2+Œ±y2
2
m , u1 = gr
1 , u2 = gr
2 , h1 = dHe(v)
B
r‚ààRZq
Œ± = H(m, B)
v = crdrŒ±
m , h2 = bHc(v)
h2
?= bHc(v)
-
Figure 3: Authenticator ÀÜŒªDDH between A and B
A
Œ± = H(m, B)
v = ux1+Œ±y1
œÅ at random
1
ux2+Œ±y2
2
v0 ?= v
protocol Den-ÀÜŒªDDH
m , u1 = gr
1 , u2 = gr
2
B
r‚ààRZq
Œ± = H(m, B)
v0 = crdrŒ±
m , h = COM (v, œÅ)
-
m , v0
m , œÅ
- h
?= COM (v0, œÅ)


Figure 4: Deniable Authenticator ÀÜŒªDDH between A and B