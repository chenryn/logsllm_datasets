89–143. 01 2010.
25. Christian Cachin, Klaus Kursawe, Anna Lysyanskaya, and Reto Strobl. Asynchronous veriﬁable secret sharing
and proactive cryptosystems. In ACM Conference on Computer and Communications Security, pages 88–97, 2002.
26. Christian Cachin, Klaus Kursawe, Anna Lysyanskaya, and Reto Strobl. Asynchronous veriﬁable secret sharing
and proactive cryptosystems. In Proceedings of the 9th ACM Conference on Computer and Communications
Security, CCS ’02, pages 88–97, New York, NY, USA, 2002. ACM.
27. B. Chor, S. Goldwasser, S. Micali, and B. Awerbuch. Veriﬁable secret sharing and achieving simultaneity in the
presence of faults. In 26th Annual Symposium on Foundations of Computer Science (sfcs 1985), pages 383–395,
Oct 1985.
28. V´eronique Cortier, Constantin Catalin Dragan, Fran¸cois Dupressoir, and Bogdan Warinschi. Machine-checked
proofs for electronic voting: privacy and veriﬁability for belenios. In 2018 IEEE 31st Computer Security Foundations
Symposium (CSF), pages 298–312. IEEE, 2018.
29. Morten Dahl and Ivan Damg˚ard. Universally composable symbolic analysis for two-party protocols based on
homomorphic encryption. In EUROCRYPT, 2014.
30. Ivan Damg˚ard, Kasper Damg˚ard, Kurt Nielsen, Peter Sebastian Nordholt, and Tomas Toft. Conﬁdential
benchmarking based on multiparty computation. In Proceedings of the 20th International Conference on Financial
Cryptography and Data Security, pages 169–187. Springer, 2016.
31. Daniel Demmler, Thomas Schneider, and Michael Zohner. ABY - A framework for eﬃcient mixed-protocol secure
two-party computation. In 22nd Annual Network and Distributed System Security Symposium, NDSS 2015, San
Diego, California, USA, February 8-11, 2015, 2015.
32. Shlomi Dolev, Karim Eldefrawy, Joshua Lampkins, Rafail Ostrovsky, and Moti Yung. Proactive secret sharing with
a dishonest majority. In Vassilis Zikas and Roberto De Prisco, editors, Security and Cryptography for Networks,
pages 529–548, Cham, 2016. Springer International Publishing.
33. Shlomi Dolev, Karim Eldefrawy, Joshua Lampkins, Rafail Ostrovsky, and Moti Yung. Proactive secret sharing
with a dishonest majority. In SCN, volume 9841 of LNCS, pages 529–548. Springer, 2016.
34. Yael Ejgenberg, Moriya Farbstein, Meital Levy, and Yehuda Lindell. Scapi: The secure computation application
programming interface. Cryptology ePrint Archive, Report 2012/629, 2012. https://eprint.iacr.org/2012/629.
35. Karim Eldefrawy, Rafail Ostrovsky, Sunoo Park, and Moti Yung. Proactive secure multiparty computation with a
dishonest majority. In Proceedings of the Eleventh Conference on Security and Cryptography for Networks, pages
200–215, 01 2018.
36. Karim Eldefrawy and Vitor Pereira. A high-assurance evaluator for machine-checked secure multiparty computation.
Cryptology ePrint Archive, Report 2019/922, 2019. https://eprint.iacr.org/2019/922.
37. P. Feldman. A practical scheme for non-interactive veriﬁable secret sharing. In 28th Annual Symposium on
Foundations of Computer Science (sfcs 1987), pages 427–438, Oct 1987.
38. Jean-Christophe Filliˆatre. One logic to use them all. In 24th International Conference on Automated Deduction
(CADE-24), volume 7898 of Lecture Notes in Artiﬁcial Intelligence, pages 1–20, Lake Placid, USA, June 2013.
Springer.
39. Jean-Christophe Filliˆatre and Andrei Paskevich. Why3 — where programs meet provers. In Matthias Felleisen
and Philippa Gardner, editors, Proceedings of the 22nd European Symposium on Programming, volume 7792 of
Lecture Notes in Computer Science, pages 125–128. Springer, March 2013.
40. Matthias Fitzi, Juan Garay, Shyamnath Gollakota, C. Pandu Rangan, and Kannan Srinathan. Round-optimal and
eﬃcient veriﬁable secret sharing. In Shai Halevi and Tal Rabin, editors, Theory of Cryptography, pages 329–342,
Berlin, Heidelberg, 2006. Springer Berlin Heidelberg.
41. C´edric Fournet, Markulf Kohlweiss, and Pierre-Yves Strub. Modular code-based cryptographic veriﬁcation. In
ACM CCS, 2011.
42. Matthew Franklin and Moti Yung. Communication complexity of secure computation (extended abstract). In
Proceedings of the Twenty-fourth Annual ACM Symposium on Theory of Computing, STOC ’92, pages 699–710,
New York, NY, USA, 1992. ACM.
29
43. Rosario Gennaro, Yuval Ishai, Eyal Kushilevitz, and Tal Rabin. The round complexity of veriﬁable secret sharing
and secure multicast. In Proceedings of the Thirty-third Annual ACM Symposium on Theory of Computing, STOC
’01, pages 580–589, New York, NY, USA, 2001. ACM.
44. Rosario Gennaro, Michael O. Rabin, and Tal Rabin. Simpliﬁed vss and fast-track multiparty computations with
applications to threshold cryptography. In Proceedings of the Seventeenth Annual ACM Symposium on Principles
of Distributed Computing, PODC ’98, pages 101–111, New York, NY, USA, 1998. ACM.
45. Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or a completeness theorem for
protocols with honest majority. In STOC, pages 218–229, 1987.
46. Helene Haagh, Aleksandr Karbyshev, Sabine Oechsner, Bas Spitters, and Pierre-Yves Strub. Computer-aided
proofs for multiparty computation with active security. pages 119–131, 07 2018.
47. Helene Haagh, Aleksandr Karbyshev, Sabine Oechsner, Bas Spitters, and Pierre-Yves Strub. Computer-aided
proofs for multiparty computation with active security. In 31st IEEE Computer Security Foundations Symposium,
CSF 2018, Oxford, United Kingdom, July 9-12, 2018, pages 119–131. IEEE Computer Society, 2018.
48. Wilko Henecka, Stefan K ¨ogl, Ahmad-Reza Sadeghi, Thomas Schneider, and Immo Wehrenberg. Tasty: Tool
for automating secure two-party computations. In Proceedings of the 17th ACM Conference on Computer and
Communications Security, CCS ’10, pages 451–462, New York, NY, USA, 2010. ACM.
49. Wilko Henecka, Stefan K ˜A¶gl, Ahmad-Reza Sadeghi, Thomas Schneider, and Immo Wehrenberg. Tasty: Tool for
automating secure two-party computations. volume 2010, pages 451–462, 01 2010.
50. Amir Herzberg, Stanislaw Jarecki, Hugo Krawczyk, and Moti Yung. Proactive secret sharing or: How to cope
with perpetual leakage. In CRYPTO, pages 339–352, 1995.
51. Amir Herzberg, Stanis(cid:32)law Jarecki, Hugo Krawczyk, and Moti Yung. Proactive secret sharing or: How to cope
with perpetual leakage. In Don Coppersmith, editor, Advances in Cryptology — CRYPT0’ 95, pages 339–352,
Berlin, Heidelberg, 1995. Springer Berlin Heidelberg.
52. Martin Hirt, Christoph Lucas, and Ueli Maurer. A dynamic tradeoﬀ between active and passive corruptions in
secure multi-party computation. In CRYPTO (2), volume 8043 of LNCS, pages 203–219. Springer, 2013.
53. Jonathan Katz, Chiu-Yuen Koo, and Ranjit Kumaresan. Improving the round complexity of vss in point-to-point
networks. In Luca Aceto, Ivan Damg˚ard, Leslie Ann Goldberg, Magn´us M. Halld´orsson, Anna Ing´olfsd´ottir,
and Igor Walukiewicz, editors, Automata, Languages and Programming, pages 499–510, Berlin, Heidelberg, 2008.
Springer Berlin Heidelberg.
54. Hugo Krawczyk. The order of encryption and authentication for protecting communications (or: How secure is
ssl?). In Joe Kilian, editor, Advances in Cryptology — CRYPTO 2001, pages 310–331, Berlin, Heidelberg, 2001.
Springer Berlin Heidelberg.
55. Ranjit Kumaresan, Arpita Patra, and C. Pandu Rangan. The round complexity of veriﬁable secret sharing: The
statistical case. In Masayuki Abe, editor, Advances in Cryptology - ASIACRYPT 2010, pages 431–447, Berlin,
Heidelberg, 2010. Springer Berlin Heidelberg.
56. Baiyu Li and Daniele Micciancio. Symbolic security of garbled circuits. pages 147–161, 07 2018.
57. Dahlia Malkhi, Noam Nisan, Benny Pinkas, and Yaron Sella. Fairplay - secure two-party computation system. In
Matt Blaze, editor, Proceedings of the 13th USENIX Security Symposium, August 9-13, 2004, San Diego, CA,
USA, pages 287–302. USENIX, 2004.
58. Ueli M. Maurer. Secure multi-party computation made simple. Discrete Applied Mathematics, 154(2):370–381,
2006.
59. Rafail Ostrovsky and Moti Yung. How to withstand mobile virus attacks (extended abstract). In PODC, pages
51–59. ACM, 1991.
60. M´ario Jos´e Parreira Pereira. Tools and Techniques for the Veriﬁcation of Modular Stateful Code. PhD thesis,
Paris Saclay, 2018.
61. Arpita Patra, Ashish Choudhary, Tal Rabin, and C. Pandu Rangan. The round complexity of veriﬁable secret
In Shai Halevi, editor, Advances in Cryptology - CRYPTO 2009, pages 487–504, Berlin,
sharing revisited.
Heidelberg, 2009. Springer Berlin Heidelberg.
62. Torben Pryds Pedersen. A threshold cryptosystem without a trusted party. In Proceedings of the 10th Annual
International Conference on Theory and Application of Cryptographic Techniques, EUROCRYPT’91, pages
522–526, Berlin, Heidelberg, 1991. Springer-Verlag.
63. Torben Pryds Pedersen. Non-interactive and information-theoretic secure veriﬁable secret sharing. In Joan
Feigenbaum, editor, Advances in Cryptology — CRYPTO ’91, pages 129–140, Berlin, Heidelberg, 1992. Springer
Berlin Heidelberg.
64. Aseem Rastogi, Nikhil Swamy, and Michael Hicks. Wys*: A veriﬁed language extension for secure multi-party
computations. CoRR, abs/1711.06467, 2017.
65. David Schultz. Mobile Proactive Secret Sharing. PhD thesis, Massachusetts Institute of Technology, 2007.
30
66. Adi Shamir. How to share a secret. Commun. ACM, 22(11):612–613, 1979.
67. Adi Shamir. How to share a secret. Commun. ACM, 22(11):612–613, November 1979.
68. Alley Stoughton and Mayank Varia. Mechanizing the proof of adaptive, information-theoretic security of
cryptographic protocols in the random oracle model. In 30th IEEE Computer Security Foundations Symposium,
CSF 2017, Santa Barbara, CA, USA, August 21-25, 2017, pages 83–99. IEEE Computer Society, 2017.
69. Xiao Wang, Alex J. Malozemoﬀ, and Jonathan Katz. Faster secure two-party computation in the single-execution
setting. In Jean-S´ebastien Coron and Jesper Buus Nielsen, editors, Advances in Cryptology - EUROCRYPT
2017 - 36th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Paris,
France, April 30 - May 4, 2017, Proceedings, Part III, volume 10212 of Lecture Notes in Computer Science, pages
399–424, 2017.
70. Xiao Wang, Samuel Ranellucci, and Jonathan Katz. Global-scale secure multiparty computation. In Bhavani M.
Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, Proceedings of the 2017 ACM SIGSAC
Conference on Computer and Communications Security, CCS 2017, Dallas, TX, USA, October 30 - November 03,
2017, pages 39–56. ACM, 2017.
71. Theodore M. Wong, Chenxi Wang, and Jeannette M. Wing. Veriﬁable secret redistribution for archive system. In
IEEE Security in Storage Workshop, pages 94–106. IEEE Computer Society, 2002.
72. Andrew Chi-Chih Yao. Protocols for secure computations (extended abstract). In FOCS, pages 160–164. IEEE
Computer Society, 1982.
73. Lidong Zhou, Fred B. Schneider, and Robbert van Renesse. Apss: proactive secret sharing in asynchronous systems.
ACM Trans. Inf. Syst. Secur., 8(3):259–286, 2005.
31
32
Appendix A Reasoning About Polynomials
We had to formalize a veriﬁed library to reason about polynomials because several protocols rely heavily
on polynomials and operations over them. This was a critical step in our proofs, otherwise we would have
needed to use a non-veriﬁed polynomial library to perform the desired operations, which would increase our
trusted code base.
We are interested in polynomials over ﬁnite ﬁelds in this work. However, we developed a general polynomials
library, that could be reused to deﬁne multiple instances of polynomials. We started the development of our
polynomials library by ﬁrst deﬁning an abstract deﬁnition for it. This abstract deﬁnition provides an interface
for concrete realizations of polynomials and deﬁnes the coeﬃcient type, polynomial evaluation, the zero and
one polynomials, polynomial degree, addition, multiplication, unary minus and interpolation. We ﬁx the
type of the polynomials to be a list of monomials, which induces a possible equality class to be the equality
between lists. Such equality class is too strong and would force the deﬁnition of complicated operators to
perform addition and multiplication, thus inducing a signiﬁcant performance penalty. We ﬁx the equality
class to be the equality of the evaluation of two polynomials in the same points, and use this equality class to
deﬁne the subsequent axioms and lemmas around the polynomial operations mentioned above. This abstract
polynomial interface is reusable and can be applied to other domains.
We then instantiate the type of the coeﬃcients to be the same type of elements in a ﬁnite ﬁeld and deﬁne
all polynomial operations in the expected, classical way. Properties such as commutativity and associativity
of polynomial addition and multiplication were easily proven by relying on the same properties veriﬁed in
ﬁnite ﬁeld operations. We also provide a formalization for polynomial interpolation based on the Lagrange
interpolation, which makes use of a linear combination of Lagrange basis polynomials. Note that polynomial
interpolation is important in our work, since it allows secret reconstruction inside the reconstruct protocol
and also recovering parties to successfully recover shares.
In order to deﬁne polynomials, we make use of EasyCrypt’s record system as shown in Figure 25. We see
polynomials as lists of monomials, which are a record with two ﬁelds: a coeﬃcient (an element of a ﬁnite
ﬁeld) and an exponent (an integer).
type coefficient = t.
type exponent = int.
type monomial = {
coef : coefficient;
expo : exponent
}.
type polynomial = monomial list.
Fig. 25: Polynomial type deﬁnition
Next, our polynomial library deﬁnes evaluation functions, one for monomial evaluation and other for
polynomials that is basically multiple applications of the ﬁrst one. Polynomial evaluation deﬁnes our equality
class. All this deﬁnitions can be found in Figure 26. We also include in this Figure a polynomial membership
test: a point is the polynomial if the evaluation of the polynomial at the abscissa is equal to the value of the
ordinate.
We are also interested in having a zero (i.e. a polynomial that always evaluate to zero) and a one
polynomial (i.e. a polynomial that always evaluate to one) so that we are able to deﬁne algebraic properties
around polynomial operations. Those polynomials are depicted in Figure 27. Note that zero could also be
deﬁned based on mzero but deﬁning it as an empty list simpliﬁes proofs because it allows one to prove
polynomial properties based on list induction.
Figure 28 sketches the EasyCrypt deﬁnition of polynomial arithmetic. Every arithmetic operation is deﬁned
in the same, mechanical way: 1) we start by deﬁning that operation in terms of monomials (madd, mmul
33
op meval (x:coefficient) (m : monomial) = m.‘coef * (x ^ m.‘expo).
op eval (x:coefficient) p =
with p = [] => F.zero
with p = m :: p’ => meval x m + (eval x p’).
op (==) p1 p2 = forall x, eval x p1 = eval x p2.
op mem (pt : (coeficient * coeficient)) p = eval (fst pt) p = (snd pt).
Fig. 26: Polynomial evaluation and equality class
op mzero = {| coef = F.zero; expo = 1 |}.
op zero : polynomial = [].
op mone = {| coef = F.one; expo = 0 |}.
op one = [mone].
Fig. 27: Zero and one polynomials
and mumin); 2) then we deﬁne it in terms of a monomial and a polynomial (mpadd and mpmul); and ﬁnally
3) we deﬁne the polynomial operation based on the previous two (add, mul and umin) The reason why
we implement polynomial operations as such lies with proof simpliﬁcation. Proving properties related to
monomial operations is much more easy than proving them applied to polynomials. Yet, since polynomial
operations are deﬁned based on the monomials’ ones, it is easy to propagate results obtained at monomial
level to polynomials. Additionally, interesting arithmetic properties (such as commutativity or associativity)
of polynomial operations are easily proven by relying on the same properties of their underlying coeﬃcients.
The last operations delivered by our polynomial interface is Lagrange interpolation. Lagrange interpolation
allows to reconstruct a d − 1 degree polynomial based on d points. Brieﬂy, it works by computing bases based
on the abscissa values, which are then multiplied by the ordinate values. As part of this project, we provide
two diﬀerent interpolation functions:
– interpolate - taking as input a set of points and a some x value, returns the evaluation of the interpolated
polynomial on x
– interpolate poly - taking as input a set of points, returns the interpolated polynomial.
EasyCrypt polynomial interpolation is presented in Figure 29.
Appendix B Secret sharing security deﬁnitions
Figure 30 deﬁnes passive security for a secret sharing scheme. Theory HBCSecretSharingSchemeSecurity is
parameterized by a secret sharing scheme, making it modular enough to be reused when representing security
for multiple secret sharing schemes. It starts by ﬁrst deﬁning an abstract random generator type that will be
used to feed the explicit randomness needed to execute probabilistic algorithms such as share. This random
generator is abstract because the secret sharing scheme is also abstract and thus there is no information
about the type of randomness involved. Notwithstanding, the instantiation step will make it concrete. Next,
there is the deﬁnition of oracles. For the particular case of semi-honest security, we are only interested in
providing the adversary with an oracle to corrupt parties. An adversary attacking the scheme (parameterized
by the oracles) should, therefore, have two procedures:
– choose - that creates a query of two secrets
– guess - that tries to guess which secret was the origin of the received shares
The security experience follows naturally. The adversary chooses two secrets and tries to distinguish
between the set of shares he receives. He wins the game if he is able to do some with probability 1.
34
op madd m1 m2 = {| coef = m1.‘coef + m2.‘coef; expo = m1.‘expo |}.
op mpadd (m : monomial) p =
with p = [] => [m]
with p = m’ :: p’ =>
if m.‘expo = m’.‘expo then madd m m’ :: p’
else
if m’.‘expo  []
with p1 = m1 :: p1’, p2 = [] => p1
with p1 = [], p2 = m2 :: p2’ => p2
with p1 = m1 :: p1’, p2 = m2 :: p2’ =>
if m1.‘expo = m2.‘expo then madd m1 m2 :: add p1’ p2’
else
if m1.‘expo  []
with p = m’ :: p’ => mpadd (mmul m m’) (mpmul m p’).
op mul p1 p2 =
with p1 = [] => []
with p1 = m :: p1’ => add (mpmul m p2) (mul p1’ p2).
op mumin m = {| coef = - m.‘coef; expo = m.‘expo |}.
op umin p =
with p = [] => []
with p = m :: p’ => mumin m :: umin p’.
Fig. 28: Polynomial arithmetic
op basis_loop (x : t) (xmx : t) (xm : t list) : t list =
with xm = [] => []
with xm = y :: ys =>
if y <> xmx then