看下面的SQL语句。
--找出需要的空位（2）：考虑座位的换排
SEL&CT S1.seat  AS start_seat,  , S2.seat AS end_seat
MHERE S2.seat-S1.seat +1:head_cnt-1)--决定起点和热点
FR0M Seats2 S1, Seats2 S2
AND NOT EXISTS
SELECT *
MHERE S3-seat BSIWEEN S1.seat AND S2.seat
FROM Seat82 S3
AND[S3.BtatuB<>未预订
08 S3.rom_id ca 81.rov_id)),
■执行结果
start_seat i-' end_seat
1 a =
........
5
10
11
13
序列内的点需要满足的条件是，“所有座位的状态都是‘未预订’，且
号相同”（当然，与终点的行编号相同也可以）。把这个条件直接写成SQL
语句的话，就是像下面这样。
S3.status = *未预iJ+ AND S3.rov_id = S1.row_1d
但是前面也说了，由于SQL中不存在全称量词，所以我们必须使用
这个条件的否定，即改成下面这样的否定形式。
---
## Page 172
19用 SOL 处理数列 —
—159
NOT (S3.status -*未预订' AND S3.rom_id = S1.row_id)
- S3.status <> *未预i订* oR S3.rom_id <> S1.rov_id
必备技巧，请一定熟练掌握。
最多能坐下多少人
接下来的例题和上一道刚好相反。这次要查询的是“按现在的空位状
况，最多能坐下多少人”换句话说，要求的是最长的序列。我们使用下
面这张表Seats3
Seats3
s[状资]
已预订
未预订
3
未预订
未预订
未预订
已预订
未预订
已预订
未预订
10
未预订
就这张表而言，长度为4的序列“2～5”就是我们的答案。为了便
于解答这道例题，我们可以先生成一张存储了所有可能序列的视图。有了
这个视图之后，我们只需从中查找出最长的序列就可以了。
针对表Seats3中的数据，要想保证从座位A到另一个座位B是一个
序列，则下面的3个条件必须全部都满足。
条件1：起点到终点之间的所有座位状态都是“未预订”。
条件2：起点之前的座位状态不是“未预订”。
条件3：终点之后的座位状态不是“未预订”。
例如从条件1来说，如果像下面这样中间出现了“已预订”的座位，
那么很显然，这个区间已经不符合序列的条件了。
---
## Page 173
●160-
第1章神奇的 SQL
■不符合条件1的情况
起点
点
序列中途断了
同样，对于起点和终点还能继续延伸的区间，我们也要排除掉（因为
由延伸后的起点和终点构成的区间更符合条件）。
■不符合条件2的情况
起点
大预
起点还能往前延伸
■不符合条件3的情况
预1
终点还能往后延伸
这里也与前面的例题一样，分两个步骤来解决。我们可以先生成一张
下面这样的视图。
--第一阶段：生成存储了所有序列的视图
CREATE vIEN Sequences (start_seat, end_seat, Beat_cnt) AS
sEL&CT S1.seat  AS start_seat,
S2.seat As end_seat,
S2.seat - S1.seat + 1 AS seat_cnt
FROM Seats3 S1, Seat83 S2
MHERE S1.seat 未预订--条件1的否定
--条件2的否定
OR(S3.seat = S1.seat
t-1ANDS3.Btatu-未预订）
--条件3的否定
这个视图包含以下的内容。
staxt_seat
end_seat
seat_cnt
2
7
5
10
1
9
2
把长度为1的“7～7”称为序列（连续编号）可能会有点语义上的
矛盾，但是我们暂时还是保留这种情况（如果想要去除，请去掉WHERE
子句里 S1.seat=S4.price描述了过去的股价更高（或者持平）
的条件。通过这样的分析，我们可以明白虽然上面这条SQL语句看起来
比较长，但是每个谓词都具有明确的意义。
顺便说一下，这个查询的结果里包含像2007-01-14～2007-01-17或
2007-01-16～2007-01-17这样的子集。最后，我们要把这些不需要的子集
排除掉。使用极值函数很容易就能实现。
---
## Page 177
164—第1章神奇的SQL
--排除掉子集，只取最长的时间区间
sSL&cr MIN(start_date) AS start_date,
-量大限度地向前延仲起点
end_date
FROM  ISELBCT S1.deal_date AS start_date,
FROM MyStock S1, MyStock S2
MAK (S2.deal_datel AS end_date
--最大限度地向后延神热点
WHERE S1.deal_date = S4.price)
aseppua xg d0080
■执行结果
start_date
end_date
I.......
2007-01-06
2007-01 08
2007-01-14
2007-0117
这段代码的关键在于最大限度地延伸起点和终点。如果想包含持平（广
义的单调递增）的区间，只需去掉子查询里s3-price>=S4-price里的
等号就可以了。因为子查询里是相反的条件，所以结果里想要包含持平区
间时，要反过来把等号从条件里去掉。
本节小结
本节主要介绍了以数列为代表的有序集合的处理方法，不只列举出了
解决问题的Tips，还试着挖掘出了隐藏在解法背后的SQL的原理。
如果之前从来没有想过所有的问题都能用集合论和谓词逻辑的方法来
解决，那么本节的内容可能会让人感觉到有点不可思议。这是因为我们对
这两个相对较新的概念（两个都才诞生了100年多一点）还不是很了解，
还不能灵活地掌握。可能也是因为相对较新，所以我们在学校里也并没有
认真地学习，这进一步导致了对它们理解的匮乏。但是，熟练掌握这两个
概念的用法，对于提升SQL技能来说是必不可少的。
---
## Page 178
19用SOL处理数列16.5
下面是本节要点。
1.SQL处理数据的方法有两种。
2.第一种是把数据看成忽略了顺序的集合。
3.第二种是把数据看成有序的集合，此时的基本方法如下。
a.首先用自连接生成起点和终点的组合
b.其次在子查询中描述内部的各个元素之间必须满足的关系
4.要在SQL中表达全称量化时，需要将全称量化命题转换成存在量
化命题的否定形式，并使用NOTEXISTS谓词。这是因为SQL只实现了
谓词逻辑中的存在量词。
如果大家想了解更多关于用SQL处理数列或有序集合的方法，请参
考下面的资料。
1.JoeCelko，《SQL权威指南（第4版》（人民邮电出版社，2013年）
用SQL处理数列的方法请参考第32章“子序列、区域、顺串、间隙及
岛屿”。本节中的间题很多都源于这里。
2.JoeCelko，《SQL解惑（第2版）》（人民邮电出版杜，2008年）
使用序列视图求缺失编号的方法请参考“谜题57间隔一—版本1”。Joe
Celko假定两张表中都没有重复的数据，从而使用EXCEPTALL来提高
性能。这种做法是不错，但是几乎没有数据库支持这种写法，所以本书
注0
中只是简单地使用了EXCEPT
支持 BICEBPP ALL 这种写法的数
报本B的只 [82  PostgreSOL
练习题