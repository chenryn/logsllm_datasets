Embedded System Design:
From Electronics
to Microkernel Development
Rodrigo Maximiano Antunes de Almeida
E-mail: PI:EMAIL
Twitter: @rmaalmeida
Universidade Federal de Itajubá
Creative Commons License
The work ”Embedded System Design: From Electronics to Microkernel 
Development” of Rodrigo Maximiano Antunes de Almeida was licensed 
with Creative Commons 3.0 – Attribution – Non Commercial – Share Alike 
license.
Additional permission can be given by the author through direct contact 
using the e-mail: PI:EMAIL
Workshop schedule
● Electronic building
● Board programming
● Kernel development
Electronic building
● Electronics review
● Schematics
● Protoboard/breadboard
● System design
● Basic steps
● Microcontroller
● LCD
● Potentiometer
Electronics review
● http://xkcd.com/730/
Schematics
● Way to represent 
the components 
and its connections
● Each component 
has its own symbol
● Crossing wires only 
are connected if 
joined with a dot
Protoboard/Breadboard
System design
● Steps on a generic electronic system design
● Define the objective(s)
● Choose the main components needed to 
achieve the objective
● Get the use example and recommendations 
from component datasheet
● Build the schematics
● Simulation of HW elements
● Board layout
Datasheets
● The main source of information concerning 
electronics
● Presents
● Electrical characteristics
● Simplified schematics
● Use example
● Opcodes/API
System design
● Objective
● Build digital voltage reader
● Main components
● Microcontroller
● LCD text display
● Potentiometer
Microcontroller
● System-on-a-chip
● Processor
● Memory
● Input/Output 
peripherals
● Communication
● Safety components
Microcontroller
● Xtal configuration
● Reset pin
● DC needs
● Many peripherals 
on the same pin
LCD Display
LCD Display
● Data connection
● Backlite
● Current 
consumption
● Power on 
time/routine
Potentiometer
● Linear/Log
● Used as voltage 
divisor
● Need an analog 
input
● Filter
System design
● Cad tool: Fritzing (fritzing.org)
1
● Hands On!
Board programming
● Programmer
● IDE
● Basic concepts
● CPU Architecture
● HW configuration
● Memory access
● First program (He110 DEFC0N)
● Peripheral setup
● Second program (ADC read)
Board programming
● Programmer
● PICkit3
● Can use ICSP
● Can program a lot 
of Microchip 
products
● Also a debugger
Board programming
● IDE
● MPLABX
– Based on Netbeans
● Compiler
● SDCC
– Based on GCC
● GPUtils
Basic concepts
● PIC architecture
Basic concepts
● Memory segmentation
Basic concepts
● HW configuration
Basic concepts
● HW configuration
● Some options must be set before the program 
start
● This can only be accomplished by special 
instructions
● Compiler datasheet
//CONFIG.H
  // No prescaler used
__code char __at 0x300000 CONFIG1L = 0x01;
  // HS: High Speed Cristal
__code char __at 0x300001 CONFIG1H = 0x0C;
  // Disabled-Controlled by SWDTEN bit 
__code char __at 0x300003 CONFIG2H = 0x00;
  // Disabled low voltage programming
__code char __at 0x300006 CONFIG4L = 0x00;
Basic concepts
Basic concepts
Basic concepts
● Build a pointer to a specific memory 
address:
void main (void){
    char *ptr;
    //pointing to the port D
    ptr = 0xF83; 
    //changing all outputs to high
    *ptr = 0xFF;
}
 //this is not an infinite loop!
while(PORTD==PORTD);
Basic concepts
● Building a header with all definitions
● __near = sfr region
● Volatile = can change without program 
acknowledge
//BASIC.H
#define PORTD   (*(volatile __near unsigned char*)0xF83)
#define TRISC   (*(volatile __near unsigned char*)0xF94)
First program
● Open MPLABX IDE
● configure SDCC and PICkit
● Create a project to:
● Initialize LCD
● Print "He110 DEFC0N"
LCD communication
● The data is always an 8 bit information
● It may be split in two 4 bit "passes"
● The data may represent a character or a 
command
● They are distinguished by RS pin
● The data must be stable for "some time"
● In this period the EN pin must be set
void LCD_comm(unsigned char data, char cmd){
    if (cmd)
        BitClr(PORTE,RS);
    else
        BitSet(PORTE,RS);
    BitClr(PORTE,RW); // writing
    PORTD = cmd;
    BitSet(PORTE,EN); //enable read
    Delay40ms();
    BitClr(PORTE,EN); //finish read
}
LCD communication
void LCD_init(void){
    char i;
    for (i=0; iage);
printf("Name:   %s\n", myself->name);
printf("Weight: %f\n", myself->weight);
return 0;
}
concepts(2);
concepts(2);
circular_buffers(2.3);
concepts(2);
● Circular Buffers
● “Endless” memory spaces
● Use FIFO aproach
● Store temporary data
● Can implemented using vectors or linked-lists
concepts(2);
● Vector implementation
● Uses less space
● Need special caution when cycling
● Problem to differentiate full from empty
#define CB_SIZE 10
int circular_buffer[CB_SIZE];
int index=0;
for(;;){
//do anything with the buffer
circular_buffer[index] = index;
//increment the index
index = (index+1)%CB_SIZE;
}
concepts(2);
concepts(2);
#define CB_SIZE 10
int circular_buffer[CB_SIZE];
int start=0, end=0;
char AddBuff(int newData)
{
  //check if there is space to add a number
  if ( ((end+1)%CB_SIZE) != start)
  {
    circular_buffer[end] = newData;
    end = (end+1)%CB_SIZE;
    return SUCCESS;
  }
  return FAIL;
}
concepts(2);
temporal_conditions(2.4);
concepts(2);
In the majority part of embedded systems, we 
need to guarantee that a function will be 
executed in a certain frequency. Some 
systems may even fail if these deadlines are 
not met.
concepts(2);
● To implement temporal conditions:
1)There must be a tick event that occurs with a 
precise frequency
2)The kernel must be informed of the execution 
frequency needed for each process.
3)The sum of process duration must “fit” within 
the processor available time.
concepts(2);
● 1st condition:
● Needs an internal timer that can generate an 
interrupt.
● 2nd condition:
● Add the information for each process when 
creating it
● 3rd condition:
● Test, test and test.
● If fail, change chip first, optimize only on last 
case
concepts(2);
● Scheduling processes:
● Using a finite timer to schedule will result in 
overflow
● Example: scheduling 2 processes for 10 and 50 
seconds ahead.
concepts(2);
● And if two process are to be called in the 
same time?
concepts(2);
● Question:
● From the timeline above (only the timeline) is 
P2 late or it was scheduled to happen 55(s) 
from now?
concepts(2);
● Solution:
● Use a downtime counter for each process 
instead of setting a trigger time.
● Problem:
● Each counter must be decremented in the 
interrupt subroutine.
● Is it a problem for your system?
concepts(2);
void_pointers(2.5);
concepts(2);
● Void pointers
● Abstraction that permits to the programmer to 
pass parameters with different types to the 
same function.
● The function which is receiving the parameter 
must know how to deal with it
● It can not be used without proper casting!
concepts(2);
char *name = "Paulo";
double weight = 87.5;
unsigned int children = 3;
void main (void){
   //its not printf, yet.
   print(0, &name);
   print(1, &weight);
   print(2, &children);
}
concepts(2);
void print(int option; void *parameter){
  switch(option){
     case 0:
        printf("%s",(char*)parameter);
     break;
     case 1:
        printf("%f",*((double*)parameter));
     break;
     case 2:
        printf("%d",*((unsigned int*)parameter));
     break;