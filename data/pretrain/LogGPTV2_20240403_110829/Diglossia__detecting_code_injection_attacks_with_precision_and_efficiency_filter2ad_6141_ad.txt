non-string-literal terminal in the shadow language must be ex-
pressed entirely in original characters, or else entirely in shadow
characters. For instance, if the query language L contains a “SE-
LECT” terminal, the shadow grammar will accept “map(SELECT)
* FROM table”, but not “SELEmap(CT) * FROM table”. This re-
striction immediately rules out some injection attacks even before
the security checks described below. For example, keywords that
contain both original and shadow characters will not even parse.
For each production rule ∈ R, SG has a corresponding
rules ∈ Rs. Formally, rule has the form:
rule : n → v1v2...vl where n ∈ N, v ∈ N ∪ Σ
In rules, all non-terminals are the same as in rule, while the ter-
minals s are deﬁned as above. Consider the following example,
where rules are the rules from the original grammar, and ruless
are the corresponding rules from the shadow grammar.
rules :
→SELECT _term list_exp table_exp
select_stmt
SELECT _term→SELECT
→{a|b| . . .}
identiﬁer
. . .
→SELECT _term list_exp table_exp
SELECT _term→SELECT | map(SELECT )
→{a|b| . . .|map(a)|map(b)| . . .}
identiﬁer
. . .
ruless : select_stmt
The example shows one non-terminal rule and two terminal rules.
Since select_stmt ∈ G is a non-terminal rule, it is exactly the
same in both grammars. The terminal rule for SELECT _term ∈
SG accepts both SELECT and map(SELECT ), a superset of
the original language, since SELECT is a keyword. The termi-
nal rule for identiﬁer ∈ SG accepts strings with an arbitrary mix
of original characters c and the corresponding shadow characters
map(c).
Applying these simple transformations to the original language
and parser, we create a shadow language and parser. Shadow pro-
duction rules deﬁned in this fashion do not add conﬂicts, thus the
parser for SG produces a deterministic parse tree.
Each character map requires its own shadow grammar. Since a
fresh map is dynamically generated for each page request (i.e., each
invocation of a PHP application), automatically building a new
parser for each execution would be expensive. Instead, DIGLOS-
SIA takes advantage of the fact that the non-terminals are the same
in G and SG, and there is a one-to-one correspondence between
the terminals. This enables DIGLOSSIA to re-use the parser for G
when parsing SG.
A parser is a function that chooses the next parsing state based on
the current state and the input token. If a particular token t triggers
a production rule in G (e.g., SELECT _term ∈ G in the example
above), then the remapped token ts triggers the corresponding rule
in SG (e.g., SELECT _term ∈ SG in the example above). This
feature enables DIGLOSSIA to use the same internal handle for both
t and ts, while extending the set of accepted characters. With this
1188optimization, DIGLOSSIA can use the same parsing tables for all
dynamically generated shadows of a given query language.
Using the dual parser to detect injected code. Let DP be the dual
parser that can parse query strings according to either the original
grammar G, or the shadow grammar SG deﬁned above.
Otherwise, DP compares the terminal nodes in the two parse
Given the actual query q issued by the application, DP parses
it using G and generates a parse tree T . DP then parses the cor-
responding shadow query q(cid:48) and generates a parse tree T (cid:48). If DP
cannot produce a parse tree for either q or q(cid:48), it rejects the query
and reports a code injection attack.
trees, T and T (cid:48), and checks the following two conditions:
1. For each node ti ∈ T , there exists a one-to-one mapping to t(cid:48)
i ∈
i is the shadow of ti. For example, if ti
i is the same code operator.
2. If ti parses to a code terminal, then for every character tij ∈
C, there exists a one-to-one mapping from tij to the correct
shadow character t(cid:48)
ij = map(tij), where
map is the shadow character map.
T (cid:48) and, furthermore, t(cid:48)
is a particular code operator, then t(cid:48)
ij ∈ SC such that t(cid:48)
If either condition is violated, DIGLOSSIA reports a code injection
attack.
The actual query q may only use the original characters c ∈ C
for code, whereas its shadow q(cid:48) may only use the shadow charac-
ters sc ∈ SC for code. For example, if an identiﬁer terminal  ∈ q
is generated by merging a string constant with user input, the iden-
tiﬁer terminal s ∈ q(cid:48) will contain original characters. This case is
an instance of code injection because the code of the query depends
on user input. DIGLOSSIA makes sure that all code terminals in q
come entirely from the application itself and not a single character
comes from user input.
On the other hand, the non-code in q(cid:48) may use any combination
of original and shadow characters, reﬂecting the fact that non-code
may be derived from strings originating from user input or the ap-
plication itself. For example, if the query q contains a string literal
“ab”, then “map(a)map(b)”, “amap(b)” or ‘map(a)b” can all occur
in the shadow query q(cid:48).
In summary, given the parse tree for the actual query q and the
parse tree for the shadow query q(cid:48), DIGLOSSIA checks whether
the two queries agree on code and non-code. Since all code in q(cid:48)
that comes from the application itself is in shadow characters and
all code in q(cid:48) that comes from user input is in original characters,
DIGLOSSIA checks whether q(cid:48) contains any code in original char-
acters and, if so, reports a code injection attack.
5. LIMITATIONS
DIGLOSSIA follows Ray and Ligatti’s strict deﬁnition of code and
non-code [17] which does not permit any user input to be used as
part of code in the query. If the application developer intention-
ally incorporates user input into the query code (a dangerous and
ill-advised programming practice), DIGLOSSIA will report a code
injection attack when the application is executed.
The ability to recognize and separate code and non-code in the
query string generated by the application critically depends on us-
ing the correct grammar for the query language. If the language
accepted by the database’s query parser differs from the language
accepted by DIGLOSSIA’s parser during its analysis, DIGLOSSIA
may generate both false positives (mistakenly parse a tainted part
of the query as code, even though it will not be parsed as code by
the database) and false negatives (mistakenly parse a tainted part of
the query as non-code, even though it will be parsed as code by the
database).
Applications
MongoPress
mongodb-admin
mongodb_php_basic
rockmongo
MongoTinyURL
simple-user-auth
faqforge
schoolmate
webchess
MyBB with
MyYoutube(1.0)
Database
MongoDB
MySQL
LoC Attacks Detected
0
2
1
0
1
1
1
6
12
1
35,231
555
209
11,218
60
236
1,520
7,024
5,780
108,267
0
2
1
0
1
1
1
6
12
1
Table 2: Benchmark PHP applications.
If the application passes an input-tainted string to a third-party
PECL extension or some other built-in function that is not im-
plemented in PHP, value shadowing can be incomplete because
DIGLOSSIA cannot observe the string operations inside these func-
tions.
Incomplete value shadowing may lead to false negatives
(missed attacks). Fortunately, unlike Java and C applications, PHP
applications do not use third-party libraries heavily. For example,
we did not observe any calls to third-party libraries that perform
string or array operations on user inputs in our benchmarks.
6. EVALUATION
To evaluate DIGLOSSIA, we created a test suite of ten Web ap-
plications implemented in PHP (see Table 2). Four of our bench-
mark applications use MongoDB and contain NoSQL injection vul-
nerabilities, which we found by manual inspection of the appli-
cations’ source code: mongodb_php_basic, mongodb-admin,
M ongoT inyU RL, and simple-user-auth. Two, M ongoP ress
and rockmongo, were chosen to demonstrate the performance of
DIGLOSSIA on relatively large applications. The remaining four
applications were chosen because they contain known SQL injec-
tion vulnerabilities [7, 12].
We implemented concrete attacks exploiting the known vulnera-
bilities in the benchmark applications. We also implemented con-
crete instances for all of Ray and Ligatti’s canonical cases listed in
Table 1. All experiments were performed on an Intel(R) dual core
3.30 GHz machine with 8G of RAM.
Table 2 summarizes the results of our evaluation on the ten
benchmark Web applications. The ﬁrst column lists the applica-
tions, the second column shows the back-end database each ap-
plication uses, the third column shows the size of the application.
The fourth column shows the number of different code injection
attacks we attempted against the application, while the last column
demonstrates that DIGLOSSIA successfully detected all attacks.
Figure 8 shows the time it took to build the front page of each
application, measured as the average of 50 runs with the database
cache disabled. Range bars represent 95% conﬁdence intervals.
Most interval ranges overlap, thus the performance overhead of
DIGLOSSIA is unnoticeable to the users of the application. The
numbers at the top of each bar represent overhead percentages,
computed by taking the time it took to build the page with DIGLOS-
SIA deployed and dividing it by the original page-building time.
The maximum overhead is 13%, but the actual time difference is
less than 2 ms, within the variance of the original page-building
time.
Figure 9 shows the performance overhead of DIGLOSSIA with
the database cache enabled. The overall response times are lower,
thus the overhead percentages are bigger than those in Figure 8.
However, most overhead is not statistically signiﬁcant compared to
the variation in the page-loading time.
1189servers, or Web browsers. It can be easily added to the PHP envi-
ronment and is ready to deploy today.
Acknowledgments. We are very grateful to Venkat Venkatakrish-
nan for his insightful critique of an early version of this research,
and to Jay Ligatti for his comments on a draft of this paper. This
work was partially supported by the NSF grants CNS-0746888,
CNS-0905602, SHF-0910818, CCF-1018271, and CNS-1223396.
8. REFERENCES
[1] S. Bandhakavi, P. Bisht, P. Madhusudan, and V. N.
Venkatakrishnan. CANDID: Preventing SQL injection
attacks using dynamic candidate evaluations. In CCS, 2007.
[2] S. Boyd and A. Keromytis. SQLrand: Preventing SQL
injection attacks. In ACNS, 2004.
[3] E. Chin and D. Wagner. Efﬁcient character-level taint
tracking for Java. In SWS, 2009.
[4] CVE Details.
http://www.cvedetails.com/vulnerabilities-by-types.php.
[5] W. Halfond, A. Orso, and P. Manolios. Using positive
tainting and syntax-aware evaluation to counter SQL
injection attacks. In FSE, 2006.
[6] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: A static
analysis tool for detecting Web application vulnerabilities. In
S&P, 2006.
[7] A. Kie˙zun, P. Guo, K. Jayaraman, and M. Ernst. Automatic
creation of SQL injection and cross-site scripting attacks. In
ICSE, 2009.
[8] A. Liu, Y. Yuan, D. Wijesekera, and A. Stavrou. SQLProb: A
proxy-based architecture towards preventing SQL injection
attacks. In SAC, 2009.
[9] V. Livshits and M. Lam. Finding security vulnerabilities in
Java applications with static analysis. In USENIX Security,
2005.
[10] mongoDB production deployments.
http://www.mongodb.org/about/production-deployments/.
[11] R. Mui and P. Frankl. Preventing web application injections
with complementary character coding. In ESORICS, 2011.
[12] MyYoutube MyBB Plugin 1.0 SQL Injection.
http://www.exploit-db.com/exploits/23353.
[13] A. Nguyen-Tuong, S. Guarnieri, D. Greene, and D. Evans.
Automatically hardening Web applications using precise
tainting. In SEC, 2005.
[14] NoSQL. http://nosql-database.org/.
[15] NoSQL injection attack on Diaspora.
http://www.kalzumeus.com/2010/09/22/security-lessons-
learned-from-the-diaspora-launch/.
[16] T. Pietraszek and C. Berghe. Defending against injection
attacks through context-sensitive string evaluation. In RAID,
2006.
[17] D. Ray and J. Ligatti. Deﬁning code-injection attacks. In
POPL, 2012.
[18] R. Sekar. An efﬁcient black-box technique for defeating Web
application attacks. In NDSS, 2009.
[19] S. Son and V. Shmatikov. SAFERPHP: Finding semantic
vulnerabilities in PHP applications. In PLAS, 2011.
[20] Z. Su and G. Wassermann. The essence of command
injection attacks in Web applications. In POPL, 2006.
[21] B. Sullivan. Server-side JavaScript injection.
http://media.blackhat.com/bh-us-
11/Sullivan/BH_US_11_Sullivan_Server_Side_WP.pdf,
2011.
Figure 8: Performance overhead of DIGLOSSIA with the database
cache disabled.
Figure 9: Performance overhead of DIGLOSSIA with the database
cache enabled.
These experimental results show that DIGLOSSIA accurately de-
tects SQL and NoSQL code injection attacks with virtually unno-
ticeable performance overhead.
7. CONCLUSION
To the best of our knowledge, DIGLOSSIA is the ﬁrst tool capable
of accurately detecting both SQL and NoSQL injection attacks on
server-side PHP applications at runtime, without any modiﬁcations
to applications or back-end databases.
DIGLOSSIA follows Ray and Ligatti’s deﬁnition of code and
non-code, combined with very precise character-level taint track-
ing, and thus avoids the false positives and false negatives of prior
tools for detecting code injection attacks. In tandem with the exe-
cution of the application, DIGLOSSIA remaps all characters intro-
duced into the query by the application itself into a shadow charac-
ter set, while leaving the characters that originate from user input
intact. The resulting query and its shadow are then analyzed using
a dual parser that can parse both the original and shadow query
languages. Dual parsing is the main technical innovation of this
work. Any discrepancy between the parse trees of the query and its
shadow, or the presence of any original characters in the code of the
shadow query indicate that the code of the actual query is tainted
by user input and thus a code injection attack has occurred.
DIGLOSSIA imposes negligible performance overhead and does
not require any changes to the existing applications, databases, Web
1.93.32.85.70.10.46.20.43.1256.86.17.34.18.713.512.58.52.80 ms10 ms20 ms30 ms40 ms50 ms60 ms70 msmongodb-adminmongo_php_basicMongoPressrockMongoMongoTinyURLsimple-user-authfaqforgeschoolmatewebchessMyBBFull ( parsing + value shadowing)Value shadowing without parsingOriginalPage buildingtime (ms)11.94.31.11.39.512.5913.211.80.312.622.535.512.623.322.118.819.21.40 ms10 ms20 ms30 ms40 ms50 ms60 msmongodb-adminmongo_php_basicMongoPressrockMongoMongoTinyURLsimple-user-authfaqforgeschoolmatewebchessMyBBFull ( parsing + value shadowing)Value shadowing without parsingOriginalPage buildingtime (ms)1190[22] The BNF grammar for SQL-99. http://savage.net.au/SQL/.
[23] J. Vijayan. TJX data breach: At 45.6M card numbers, it’s the
biggest ever. http://www.computerworld.com/s/article/
9014782/TJX_data_breach_At_45.
6M_card_numbers_it_s_the_biggest_ever, 2007.
[24] G. Wassermann and Z. Su. Sound and precise analysis of
Web applications for injection vulnerabilities. In PLDI, 2007.
[25] WhiteHat website security statistics report.
https://www.whitehatsec.com/resource/stats.html, 2012.
[26] W. Xu, S. Bhatkar, and R. Sekar. Taint-enhanced policy
enforcement: A practical approach to defeat a wide range of
attacks. In USENIX Security, 2006.
1191