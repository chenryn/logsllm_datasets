content attributes and could be based on the prices they
paid. In these application scenarios, the issue of key revo-
cation also exists. Fig. 2. shows such an example, in which
a user currently is allowed to access any series with name
“Hero”, “Lost”, or “Dexter”’ provided by channel 4. The sys-
tem administrator now wants to disable the user’s access
privilege on series with name “Lost” for some reason (maybe
late payment). For this purpose, it is necessary to revoke
the corresponding component of the user’s secret key.
AND
AND
OR
OR
Channel: 4
Channel: 4
Name: Hero
Name: Dexter
Name: Hero Name: Dexter
Name: Lost
Figure 2: An example application scenario of KP-
ABE.
Similar to CP-ABE, the basic construction of current KP-
ABE scheme [12] also deﬁnes a system master key compo-
nent ti for each attribute i. The corresponding public key
component is deﬁned as Ti = gti . Encrypting a message
with attribute i means including a component T s
into the
i
ciphertext, where s is a random number for this ciphertext.
In user secret key, the component for attribute i has the
qx(0)
ti
form of g
, where qx(·) is a polynomial uniquely deﬁned
for the user. Therefore, we can revoke a secret key com-
ponent in the same way as we did for CP-ABE, i.e., the
authority redeﬁnes the master key component as t′
i and give
t′
to proxy servers as the proxy re-key. In the same way
i
ti
as our CP-ABE scheme, proxy servers, which are honest by
our assumption, will use these proxy re-key’s to re-encrypt
ciphertexts stored on them and update secret keys for all but
the user for revocation. Proof of the new KP-ABE scheme
is similar to that of our CP-ABE scheme.
Large Universe Construction In addition to the ba-
sic construction, [12] also provides a KP-ABE construction
for large universe cases. One signiﬁcant advantage of this
construction is that the number of public parameter compo-
nents is constant, no matter how many attributes the system
may have. In this construction, however, our technique of
generating proxy re-key’s for CP-ABE and the basic KP-
ABE scheme is not applicable any more. This is because
the deﬁnitions of public parameter components and user se-
cret key components are no longer in the same format as
before. In this construction, it selects n + 1 random points
4 and deﬁnes a function T to calculate the public
from G1
key component for attribute X 5 as:
· Qn+1
i=1 t
T (X) = gXn
∆i,N (X)
i
,
2
where g2 is another group element in G1, N = {1, 2, · · · , n+
1}, and ∆i,N (X) is the Lagrange coeﬃcient. Ciphertext
component for each attribute i is still in the form of T s
i as
before. Each attribute has two components in user secret
key:
Di = gqx(0)
2
· T (i)ri , and Ri = gri ,
where ri ∈ Zp is a random number of attribute i in the
user secret key. We refer to [12] for the detailed construction.
In this construction, we can not simply redeﬁne the sys-
tem master key component ti to update the attribute i for
key revocation as before.
Instead, we need to change the
construction of the Setup() algorithm of the original scheme
as follows. We assume the bit string for each attribute is
deﬁned in a ﬁxed format “(attribute description, version j)”.
The version number j of each attribute in the universe will
be published.
Setup(n) Choose a random number y ∈ Zp and let g1 =
gy. Next, choose a random element g2 from G1. Then, select
random numbers w1, w2, · · · , wn+1 from Zp. Deﬁne ti = gwi
2
for 1 ≤ i ≤ n + 1. Deﬁne function T as:
∆i,N (X)
i
= gXn+p(X)
T (X) = gXn
· Qn+1
i=1 t
where p(·) is a n degree polynomial deﬁned by points
(1, w1), (2, w2), · · · , (n + 1, wn+1). The public parameters
are output as: P K = (g1, g2, t1, · · · , tn+1). The master key
M K = (y, w1, w2, · · · , wn+1).
,
2
2
Algorithms Encryption, Key Generation, and Decryption
are deﬁned exactly the same as the original scheme. To en-
able the authority to generate proxy re-key’s, we deﬁne al-
gorithm ReKeyGen as follows.
ReKeyGen(γ, M K) γ is the set of attributes needing re-
deﬁnition. For each attribute X ∈ γ, assuming its pre-image
is a bit string “(attribute description, version j)”, now rede-
ﬁne it as bit string “(attribute description, version j + 1)”.
We hence obtain H(attribute name, version j + 1) = X ′
6, where H() is a cryptographic hash function. Since hash
function H(·) is collision free, X ′ can not be used for any
other attributes. The proxy re-key for attribute X will be
output as rkX = (X ′)n+p(X ′)
. The set of proxy re-key’s rk
Xn+p(X)
for attributes in γ are sent to proxy servers.
Proxy servers, on receiving the proxy key’s, re-encrypt ex-
isting ciphertexts stored on them as follows.
4Following the deﬁnition of [12], we assume the bilinear map
is from G1 to G2, i.e., e : G1 × G1 → G2.
5X is generated by applying a collision resistant hash func-
tion H : {0, 1}∗ → Z∗
p on the bit string representation of the
attribute.
6When the new version j +1 is published, encryptors will use
T (X ′) as the public component for encryption thereafter.
ReEnc(E, rk, β) For each attribute i ∈ β, update Ei as
Erki
i
.
To update user secret key, proxy servers update Ri com-
ponents for users as follows.
ReKey(Ri, rki) Update Ri as R(rki)−1
i
.
It is easy to verify that the updated user secret key will
be able to decrypt ciphertexts encrypted with updated at-
tributes if the ciphertext attributes satisfy the access struc-
ture of the secret key. Formal security reduction of this
scheme will be presented in the extended version of this pa-
per.
As compared to [4], our scheme places a minimal compu-
tation overhead on the authority, and is more suitable for ap-
plication scenarios in which the content provider, e.g., an in-
dividual person who himself/herself serves as the authority,
outsources contents on powerful but semi-trustable servers
such as cloud servers, and would like to manage his/her re-
sources via resource constrained devices, e.g., iPhone, any-
where and at any time. On the other hand, [4] is more
eﬃcient in terms of the overall system overhead and is more
suitable for traditional applications in which most compu-
tational tasks are executed locally.
6.2 Application Considerations
Our scheme considers application scenarios of data shar-
ing in which data are encrypted and stored on semi-trustable
servers for sharing. In this scheme, the authority generates
proxy re-key’s whenever an attribute revocation event oc-
curs. Proxy re-key’s are then transmitted to proxy servers,
who will re-encrypt existing ciphertexts stored on them and
update user secret key components if necessary. For sim-
plicity of description, our scheme just considers one revoca-
tion event. Multiple revocation events are assumed to be
handled by repeatedly executing these operations. When
this assumption is convenient for theoretical analysis of the
scheme, it will cause eﬃciency issue in practice since proxy
servers have to re-encrypt ciphertexts stored upon each re-
vocation event. In practical systems, there could be a huge
number of ﬁles stored on servers, and the computation load
for re-encrypting them could be extremely heavy. On the
other hand, users are not necessary available for key update
upon each revocation event.
In practical scenarios, users
may have missed many revocation events before they come
back to access the servers. To deal with attribute revocation
eﬃciently, we propose to enable proxy servers to handle re-
vocation events in an aggregative way, which further makes
lazy re-encryption [14] possible. For this purpose, proxy
servers keep a copy of a table for proxy re-key’s of historical
events as shown in Fig.3.
Version #
k
k − 1
· · ·
k − N
att 1
rk(k)
rk(k−1)
1
1
att 2
rk(k)
rk(k−1)
2
2
· · ·
· · ·
rk(k−N )
1
rk(k−N )
2
· · ·
· · ·
· · ·
· · ·
· · ·
att n
rk(k)
n
rk(k−1)
n
· · ·
rk(k−N )
n
Figure 3: Proxy re-key list
With this table, proxy servers do not need to re-encrypt
data ﬁles upon each revocation event.
Instead, they can
just re-encrypt the data ﬁles when the ﬁles are accessed by
some user, i.e., in the fashion of lazy re-encryption. As-
suming the version number associated with the ciphertext
of a data ﬁle is k − i, updating it to the latest version k
just needs to call the ReEnc algorithm once with proxy re-
key (Qi−1
). Unac-
cessed data ﬁles will never get re-encrypted. This modiﬁca-
tion can aggregate operations for multiple revocation events
into one and save a lot of computation overload for proxy
servers from statistical point of view. One issue with this
method is that the storage overhead could be high if proxy
servers keep all the proxy re-key’s. In practical systems, we
can just keep the list for a reasonable time period and release
the storage burden on proxy servers.
j=0 rk(k−j)
j=0 rk(k−j)
, Qi−1
, · · · , Qi−1
j=0 rk(k−j)
n
1
2
User secret key update can be addressed in the same way.
However, proxy servers need to keep a revoked user identity
list for each attribute since a user may come back asking
for update of secret key components of attributes that were
previously revoked. Having these lists, proxy servers will
just update secret key components of attributes that are
still associated with the user. Recovering an attribute for a
user can also be realized by removing the user’s ID from the
list.
Att i
IDi
IDj
· · ·
IDk
Figure 4: Revoked user ID list of attribute i
7. CONCLUSION AND FUTURE WORK
In this paper we addressed an important issue of attribute
revocation for attribute based systems.
In particular, we
considered practical application scenarios in which semi-
trustable proxy servers are available, and proposed a scheme
supporting attribute revocation. One nice property of our
proposed scheme is that it places minimal load on author-
ity upon attribute revocation events. We achieved this by
uniquely combining the proxy re-encryption technique with
CP-ABE and enabled the authority to delegate most labori-
ous tasks to proxy servers. Our proposed scheme is provably
secure against chosen ciphertext attacks.
In addition, we
also showed the applicability of our method to the KP-ABE
scheme. One interesting future work is to combine a secure
computation technique with our construction to guarantee
the honesty of proxy servers. Another direction for future
work is to allow proxy servers to update user secret key
without disclosing user attribute information.
8. ACKNOWLEDGMENTS
This work was supported in part by the US National Sci-
ence Foundation under grants CNS-0716306, CNS-0831628,
CNS-0746977, and CNS-0831963.
9. REFERENCES
[1] J. Anderson. Computer Security Technology Planning
Study. Air Force Electronic Systems Division, Report
ESD-TR-73-51, 1972.
http://seclab.cs.ucdavis.edu/projects/history/.
[2] J. Bethencourt, A. Sahai, and B. Waters.
Ciphertext-Policy Attribute-Based Encryption. In
Proc. of SP’07, Washington, DC, USA, 2007.
[3] M. Blaze, G. Bleumer, and M. Strauss. Divertible
Protocols and Atomic Proxy Cryptography. In Proc.
of EUROCRYPT ’98, Espoo, Finland, 1998.
[4] A. Boldyreva, V. Goyal, and V. Kumar. Identity-based
Encryption with Eﬃcient Revocation. In Proc. of
CCS’08, Alexandria, Virginia, USA, 2008.
[5] D. Boneh and M. Franklin. Identity-Based Encryption
from The Weil Pairing. In Proc. of CRYPTO’01,
Santa Barbara, California, USA, 2001.
[6] S. Yu, K. Ren, W. Lou, and J. Li. Defending Against
Key Abuse Attacks in KP-ABE Enabled Broadcast
Systems. In Proc. of Securecomm’09, Athens, Greece,
2009.
[7] R. Canetti, S. Halevi, and J. Katz. Chosen Ciphertext
Security from Identity Based Encryption. In Proc. of
EUROCRYPT’04, Interlaken, Switzerland, 2004.
[8] R. Canetti and S. Hohenberger. Chosen-Ciphertext
Secure Proxy Re-Encryption. In Proc. of CCS’07, New
York, NY, USA, 2007.
[9] L. Cheung and C. Newport. Provably Secure
Ciphertext Policy ABE. In Proc. of CCS’07, New
York, NY, USA, 2007.
[10] R. H. Deng, J. Weng, S. Liu, and K. Chen.
Chosen-Ciphertext Secure Proxy Re-encryption
without Pairings. In Proc. of CANS’08, Berlin,
Heidelberg, 2008.
[11] S. D. C. di Vimercati, S. Foresti, S. Jajodia,
S. Paraboschi, and P. Samarati. Over-encryption:
Management of Access Control Evolution on
Outsourced Data. In Proc. of VLDB’07, Vienna,
Austria, 2007.
[12] V. Goyal, O. Pandey, A. Sahai, and B. Waters.
Attribute-Based Encryption for Fine-grained Access
Control of Encrypted Data. In Proc. of CCS’06,
Alexandria, Virginia, USA, 2006.
[13] S. Yu, K. Ren, and W. Lou. Attribute-Based
On-Demand Multicast Group Setup with Membership
Anonymity. In Proc. of SecureComm’08, Istanbul,
Turkey, 2008.
[14] M. Kallahalla, E. Riedel, R. Swaminathan, Q. Wang,
and K. Fu. Plutus: Scalable Secure File Sharing on
Untrusted Storage. In Proc. of FAST’03, Berkeley,
California, USA, 2003.
[15] J. Li, K. Ren, B. Zhu, and Z. Wan. Privacy-Aware
Attribute-Based Encryption with User Accountability.
In Proc. of ISC’09, Pisa, Italy, 2009.
[16] X. Liang, Z. Cao, H. Lin, and J. Shao. Attribute Based
Proxy Re-encryption with Delegating Capabilities. In
Proc. of ASIACCS’09, Sydney, Australia, 2009.
[17] S. Yu, K. Ren, and W. Lou. Attribute-Based Content
Distribution with Hidden Policy. In Proc. of
NPSEC’08, Orlando, Florida, USA, 2008.
[18] M. Pirretti, P. Traynor, P. McDaniel, and B. Waters.
Secure Atrribute-Based Systems. In Proc. of CCS’06,
New York, NY, USA, 2006.
[19] A. Sahai and B. Waters. Fuzzy Identity-Based
Encryption. In Proc. of EUROCRYPT’05, Aarhus,
Denmark, 2005.