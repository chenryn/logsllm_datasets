title:Efficient and Secure Multiparty Computation from Fixed-Key Block Ciphers
author:Chun Guo and
Jonathan Katz and
Xiao Wang and
Yu Yu
2020 IEEE Symposium on Security and Privacy
Efﬁcient and Secure Multiparty Computation from Fixed-Key Block Ciphers
Chun Guo
Jonathan Katz
Universit´e Catholique de Louvain
PI:EMAIL
University of Maryland
PI:EMAIL
Xiao Wang
Northwestern University
PI:EMAIL
Yu Yu
Shanghai Jiao Tong University
PI:EMAIL
Abstract—Many implementations of secure computation use
ﬁxed-key AES (modeled as a random permutation); this results
in substantial performance beneﬁts due to existing hardware
support for AES and the ability to avoid recomputing the AES
key schedule. Surveying these implementations, however, we ﬁnd
that most utilize AES in a heuristic fashion; in the best case this
leaves a gap in the security proof, but in many cases we show it
allows for explicit attacks.
Motivated by this unsatisfactory state of affairs, we initiate a
comprehensive study of how to use ﬁxed-key block ciphers for
secure computation—in particular for OT extension and circuit
garbling—efﬁciently and securely. Speciﬁcally:
• We consider several notions of pseudorandomness for hash
functions (e.g., correlation robustness), and show provably
secure schemes for OT extension, garbling, and other ap-
plications based on hash functions satisfying these notions.
in the (non-
programmable) random-permutation model, of hash func-
tions satisfying the different notions of pseudorandomness
we consider.
• We provide provably secure constructions,
Taken together, our results provide end-to-end security proofs for
implementations of secure-computation protocols based on ﬁxed-
key block ciphers (modeled as random permutations). Perhaps
surprisingly, at the same time our work also results in noticeable
performance improvements over the state-of-the-art.
I. INTRODUCTION
Over the past few years, secure computation has transitioned
from the realm of pure theory to the point where it is imple-
mented in multiple software libraries (see [26] for a recent
survey), funded by various government agencies, marketed by
many startup companies, and used in several real-world appli-
cations [10, 9, 32, 27]. This makes it critical to understand the
security provided by implementations1 of secure-computation
protocols. Indeed, although published protocols typically come
with proofs of security that can be independently veriﬁed
by the community, published protocol descriptions often omit
or ignore important low-level details, and researchers often
apply performance optimizations in a haphazard way when
implementing those protocols.
In this work we study the use of ﬁxed-key AES (or ﬁxed-key
block ciphers more generally) in implementations of secure
computation. Using ﬁxed-key AES in this context can be
traced back to the work of Bellare et al. [5], who consider
ﬁxed-key AES for circuit garbling as part of their JustGar-
ble framework. Prior to that point, most
implementations
of garbled circuits used a hash function such as SHA-256,
modeled as a random oracle. Bellare et al. design several
1We stress that we are not referring to general software-security issues such
as improper input handling or buffer-overﬂow attacks (though these are also
important). Rather, the focus of this work is on cryptographic issues that arise
in the course of implementation.
provably secure garbling schemes based on a ﬁxed-key block
cipher, and in doing so demonstrated signiﬁcant performance
improvements; in particular, they show that using ﬁxed-key
AES can be up to 50× faster than using a cryptographic
hash function due to the hardware support for AES provided
by modern processors. (While it is also possible to garble
circuits using AES with different keys at each gate, the added
overhead of key scheduling is substantial.) Prior to their work
CPU time was the main bottleneck for protocols based on
circuit garbling; after the introduction of JustGarble, network
throughput became the dominant factor. For this reason, ﬁxed-
key AES has been almost universally adopted in subsequent
implementations of garbled circuits.
Bellare et al. prove security of their constructions when the
ﬁxed-key block cipher is modeled as a random permutation.
This random-permutation model (RPM) is analogous to the
random-oracle model, and assumes that all parties have oracle
access to a public, random permutation π : {0, 1}k → {0, 1}k
and its inverse. Modeling a ﬁxed-key block cipher as a random
permutation is weaker than modeling the block cipher as an
ideal cipher (which is also common); in particular, related-
key attacks do not apply in the ﬁxed-key setting. Inspired
by the work of Bellare et al., many subsequent works on
efﬁcient secure computation have relied on ﬁxed-key AES for
the purposes of both garbling (e.g., [53]) and oblivious-transfer
(OT) extension (e.g., [46]), two important building blocks for
secure-computation protocols. Unfortunately, however, end-
to-end proofs of security are often missing. For example,
published OT-extension protocols may be based on a hash
function H and are proven secure by modeling H as a random
oracle. When the protocols are implemented, however, H is
not instantiated using a cryptographic hash function but is
instead instantiated haphazardly from a ﬁxed-key block cipher.
At best this leaves a gap in the security proofs, but at worst—
as we show in Section II—it leaves the implemented protocols
vulnerable to explicit attacks.
Even the work of Bellare et al. has the drawback that
it is not modular. That is, they do not prove security of
their garbling schemes based on some assumption about the
“encryption scheme” used for each gate; instead, they prove
security directly in the random-permutation model. This makes
it difﬁcult to apply their ideas to new garbling schemes that
are developed, as any changes in the scheme require re-doing
the entire proof. This was done, for example, in the analysis
of the subsequent half-gates garbling scheme [53]. In their
paper introducing the scheme, Zahur et al. follow a more
modular approach: they construct their garbling scheme based
on a hash function H and then prove that their scheme is
© 2020, Xiao Wang. Under license to IEEE.
DOI 10.1109/SP40000.2020.00016
825
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:42:34 UTC from IEEE Xplore.  Restrictions apply. 
secure if H satisﬁes a certain property speciﬁc to their scheme.
They also claim without proof that when H is instantiated in
a particular way based on a ﬁxed-key cipher, then H satisﬁes
their deﬁnition. This is a step forward, but still leaves a gap
in the overall security proof.
We believe this state of affairs is unsatisfactory. In a
nutshell, the problem is that protocols are generally analyzed
by cryptographers based on a hash function H viewed as
a random oracle, but when these protocols are implemented
then H is instantiated from a ﬁxed-key block cipher in some
unprincipled (and often insecure) way. In this paper, we
attempt to resolve this mismatch as described next.
A. Our Contributions
Deﬁciencies of current implementations. As already hinted
at above, our ﬁrst contribution is merely identifying the
problem. We examined all state-of-the-art platforms for secure
computation2 and found that most of those using ﬁxed-key
AES were using it incorrectly; of those, some are vulnerable
to explicit attacks. We refer to Section II for details.
Faced with this chaotic status quo, we initiate a compre-
hensive study of how to securely and efﬁciently use ﬁxed-
key block ciphers for secure computation. We propose a
modular approach: we ﬁrst identify various properties that
hash functions need to satisfy in order to prove different
protocols secure, and then show how to efﬁciently construct
hash functions provably satisfying those properties in the
random-permutation model. In more detail:
Identifying abstract security properties. We consider several
notions of pseudorandomness3 for hash functions, some that
were identiﬁed in previous work (e.g., correlation robust-
ness [28] and circular correlation robustness [14]) and others
that are new. We then show how hash functions realizing
these different notions can be used in a provably secure way
for various ﬂavors of OT extension (Section IV) as well
as for circuit garbling (Section V) and other applications
(Section VI).
Realizations from ﬁxed-key block ciphers. We show prov-
ably secure constructions, in the non-programmable RPM, of
hash functions meeting the notions we consider (Section VII).
Importantly, in our analyses we also provide concrete security
bounds, something that is often lacking in prior work. We also
discuss how to efﬁciently implement our constructions utiliz-
ing existing CPU instruction sets and pipelining (Section VIII).
Taken together, our work provides end-to-end security
proofs for secure-computation protocols based on ﬁxed-key
block ciphers (in the OT-hybrid4 model). Somewhat surpris-
ingly, at the same time our work also results in performance
2See https://github.com/rdragos/awesome-mpc.
3The properties we consider are incomparable to traditional security deﬁ-
nitions for hash functions such as collision-resistance; in fact, in some cases
we do not even need the hash function to be compressing. Nevertheless, we
use the term “hash function” since the properties we need would traditionally
be achieved using a hash function modeled as a random oracle.
4We cannot hope to construct the “base” oblivious transfers from ﬁxed-key
block ciphers, as it is known that this requires stronger assumptions.
improvements of up to 3–4× over the current state-of-the-
art for OT extension and various other protocols; we refer to
Section VIII for further discussion.
B. Alternate Approaches
Recall that the problem we are addressing is that protocols
are proven secure assuming access to a random oracle H,
but then implemented with H instantiated improperly from a
ﬁxed-key block cipher. The approach we advocate, outlined in
the previous section, is to prove protocols secure using weaker
assumptions on H (in particular, falsiﬁable assumptions) and
then to provably realize these assumptions in the random-
permutation model. But one could imagine other ways of
trying to solve the problem; these are discussed brieﬂy here.
One option is to simply instantiate H using a cryptographic
hash function like SHA-256 or SHA-3,
treating those as
random oracles. The drawback of this approach is that such
hash functions are 15–50× slower than using ﬁxed-key AES;
see Table III.
Alternately, one could hope to instantiate H based on a
ﬁxed-key block cipher such that H is indifferentiable [38]
from a random oracle. This problem has attracted a lot of
attention [35, 18, 37, 39, 16, 33, 6] but, as we now discuss,
existing solutions are unsatisfactory.
(cid:2)
We are aware of only two approaches to constructing a
random oracle H in the random-permutation model: the ﬁrst
corresponds roughly to letting H(x) be the (k − O(k))-bit
truncation of π(0O(k)(cid:3)x) (where we view k as a security
parameter), and the second—called the XORP approach—
i πi(x) where the {πi} represent indepen-
deﬁnes H(x) =
dent random permutations. The ﬁrst approach results in a hash
function whose domain and range are much shorter than the
domain/range of π, and would result in impractically poor
security bounds if applied to AES with a block length of 128
bits. The second approach can be used to construct a random
oracle mapping k-bit inputs to k-bit outputs given multiple
random permutations on {0, 1}k, and thus could in principle
be used to realize some of the security deﬁnitions we consider.
Drawbacks of this approach, however, include:
• Some of our deﬁnitions require compression, and it is
unknown how to obtain a compressing random oracle
that is both efﬁcient and has acceptable concrete-security
bounds starting from a random permutation on {0, 1}k.
• The XORP approach requires calls to (at
least) two
independent permutations; in some sense, this is inher-
ent [8, 36]. The constructions we show here use only
a single random permutation (and in some cases just a
single call to that permutation), and are more efﬁcient
than XORP; we defer further discussion to Section VIII.
C. Outline of the Paper
In Section II we survey existing implementations of secure-
computation protocols, focusing in particular on how they in-
stantiate the underlying hash function based on ﬁxed-key AES,
and show that
in some cases they allow for an explicit
attack. We introduce in Section III various security deﬁnitions
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:42:34 UTC from IEEE Xplore.  Restrictions apply. 
826
Platform
Implementation
H(x, i) = π(x)
H(x, i) = π(x)
APRICOT [46]
APRICOT [46]
SPDZ-2 [47]
libOTe [44]
libOTe [44]
Security
Malicious
Semi-honest
Malicious
Malicious
Malicious
Unbound Tech [45] Malicious H(x, i) = π(x ⊕ i) ⊕ x ⊕ i
Malicious H(x, i) = π(2x ⊕ i) ⊕ 2x ⊕ i
TABLE I: Insecure instantiations of the hash function in existing
H(x, i) = π(x) ⊕ x
H(x, i) = π(x) ⊕ x
H(x, i) = SHA-256(x)
EMP [49]
implementations of OT extension. π(·) denotes AES-128 with a ﬁxed key.
for hash functions, some of which have been considered
before (e.g., correlation robustness) and some of which have
not (e.g., tweakable correlation robustness). In the following
sections we explore applications of hash functions satisfying
these deﬁnitions to OT extension (Section IV), the half-gates
garbling scheme (Section V), and other protocols (Section VI).
We address in Section VII the question of constructing hash
functions satisfying the various deﬁnitions from a ﬁxed-key
block cipher, when that block cipher is modeled as a random
permutation. Finally, in Section VIII we evaluate the perfor-
mance of our constructions and compare them to prior work.
II. THE CURRENT STATE OF AFFAIRS
As discussed in Section I, while many of the existing
platforms for secure computation rely on ﬁxed-key AES, very
few of them utilize it properly. Here we discuss some of
the problems we found. Before making our results public,
we contacted the authors of the affected works to inform
them of the problems we found, to conﬁrm our analysis, and
to allow them time to patch their implementations. (Some
platforms [49, 45] adopted the constructions we propose later
in the paper, while others [44] found alternate solutions.)
A. Oblivious-Transfer Extension
Oblivious transfer (OT), introduced by Rabin in 1981 [43],
is a key component of protocols for secure two-party compu-
tation [52] and, more generally, secure computation without
an honest majority [24]—even in the semi-honest setting. In
standard (one-out-of-two) OT, there is a sender who begins
holding two messages m0, m1, and a receiver who holds a
bit b; by running the protocol, the receiver learns mb. Security
the sender learns nothing about b while the
requires that
receiver learns nothing about m1−b.
Oblivious transfer requires public-key cryptography and
thus was, for a long time, a bottleneck in secure-computation
protocols. This changed with the introduction of efﬁcient OT
extension [4, 28], which enables a small number (say, 128)
of “base” OTs to be leveraged to give an unbounded number
of OTs using only symmetric-key techniques. At a high level,
state-of-the-art OT-extension protocols work in two phases:
1) A receiver with choice bits x1, ..., xm runs a protocol with
a sender, after which the sender obtains a uniform k-bit
string Δ and uniform k-bit strings (a1, . . . , am) while
the receiver obtains k-bit strings (b1, . . . , bm) such that
ai ⊕ bi = xiΔ. (Here, k is a security parameter.)
A malicious receiver is able to inﬂuence the randomness