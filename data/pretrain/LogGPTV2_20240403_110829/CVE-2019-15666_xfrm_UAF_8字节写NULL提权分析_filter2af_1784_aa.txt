# CVE-2019-15666 xfrm UAF 8字节写NULL提权分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
CVE-2019-15666是个被低估的漏洞，NVD给的评分只有4.4分。但是2020年5月份，据外媒报道，英国、德国、瑞士和西班牙等国超级计算机中心纷纷报告被加密货币恶意软件感染，导致多个高性能计算集群关闭。根据英国网络安全公司Cado
Secutiry调查分析，黑客很有可能是通过利用非法得来的SSH凭证获得了超级计算机集群的权限，然后利用CVE-2019-15666漏洞进行了提权，然后部署了恶意挖矿程序。这次受影响的超级计算机有不少都是用于新冠肺炎研究的，因此这个时候尝试利用这些超级计算机来挖矿真的是非常不道德的。
**影响版本** ：Linux v5.0.19 以前。v5.0.19已修补，v5.0.18未修补。 4.4分。
**测试版本** ：Ubuntu 18.04（4.15.0-20-generic #21）
[exploit及测试环境下载地址](https://github.com/bsauce/kernel-exploit-factory)—
**编译选项** ： **CONFIG_USER_NS=y** **CONFIG_SLAB=y** 所有含`NETLINK`和`XFRM`的配置全部选上。
`General setup` —-> `Choose SLAB allocator (SLUB (Unqueued Allocator))` —->
`SLAB`
在编译时将`.config`中的`CONFIG_E1000`和`CONFIG_E1000E`，变更为=y。[参考](https://blog.csdn.net/qq_16097611/article/details/104965045)
    CONFIG_USER_NS=y
    CONFIG_USERFAULTFD=y
    CONFIG_DEBUG_INFO=y
    // debug on running kernel with gdb
    CONFIG_GDB_SCRIPTS=y
    CONFIG_FRAME_POINTER=y
    CONFIG_KGDB=y
    CONFIG_KGDB_SERIAL_CONSOLE=y
    CONFIG_KDB_KEYBOARD=y
**漏洞描述** ：`net/xfrm/xfrm_user.c`中的
[verify_newpolicy_info()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_user.c#L1379)
错误处理了`dir`验证，导致[__xfrm_policy_unlink()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_policy.c#L2202)中出现
**越界访问**
。dir的范围本来是0~2，但从index计算dir时错误（policy2），导致dir超过3，后续将所有policy重新加入`bydst`
list时漏掉该policy2，释放`bydst`后但该policy2上的`pprev`指针仍指向释放后的policy1，将该policy2进行unlink时会导致
**空闲块8字节写null** （`*policy1->next = 0`），见`[12]`。
如果不构造policy1，直接对policy2进行unlink，只会导致 **越界减1** ，见`[8]`。
**补丁**
：[patch](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b805d78d300bcf2c83d6df7da0c818b0fee41427)
这里检查过后，后续还会通过`p->index`来计算`p->dir`（`p->dir = xfrm_policy_id2dir(p->index)` ->
`p->dir = p->index & 7`），`p->dir`前后不一致，导致未正确处理。
    diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c
    index a131f9ff979e1..8d4d52fd457b2 100644
    --- a/net/xfrm/xfrm_user.c
    +++ b/net/xfrm/xfrm_user.c
    @@ -1424,7 +1424,7 @@ static int verify_newpolicy_info(struct xfrm_userpolicy_info *p)
         ret = verify_policy_dir(p->dir);
         if (ret)
             return ret;
    -    if (p->index && ((p->index & XFRM_POLICY_MAX) != p->dir))        // p->index=4, p->dir=0即可绕过该检查。 
    +    if (p->index && (xfrm_policy_id2dir(p->index) != p->dir))
             return -EINVAL;
         return 0;
**保护机制** ：开启KASLR/SMEP/SMAP。
**利用总结**
：漏洞原本是个越界减1，可以利用别的路径来构造UAF，可以往空闲块上的8字节写null。漏洞对象`xfrm_policy`位于`kmalloc-1024`，cred结构位于`kmalloc-192`。首先利用`setxattr+userfaultfd`在`policy0`周围都喷射`kmalloc-1024`堆块，释放`policy0`后同时释放喷射块，促使该slab释放后被c子进程的red复用，然后触发UAF
空闲块8字节NULL写来修改cred中的`gid/suid`，再将当前用户添加到sudoers，即可提权。
* * *
## 1\. 漏洞分析
###  1.1 越界访问漏洞
**创建`xfrm_policy`**：用户采用特定的index和timer set来创建policy，参数是`XFRM_MSG_NEWSA`。
**漏洞链**
：[xfrm_add_policy()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_user.c#L1636)
->
[verify_newpolicy_info()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_user.c#L1379)
**`xfrm_policy`创建链**：[xfrm_add_policy()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_user.c#L1636)
->
[xfrm_policy_construct()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_user.c#L1602)
->
[xfrm_policy_alloc()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_policy.c#L379)
    static int xfrm_add_policy(struct sk_buff *skb, struct nlmsghdr *nlh,
            struct nlattr **attrs)
    {
        struct net *net = sock_net(skb->sk);
        struct xfrm_userpolicy_info *p = nlmsg_data(nlh);
        struct xfrm_policy *xp;
        struct km_event c;
        int err;
        int excl;
        err = verify_newpolicy_info(p);                                // [1] 检查用户参数—xfrm_userpolicy_info结构
        if (err)
            return err;
        err = verify_sec_ctx_len(attrs);
        if (err)
            return err;
        xp = xfrm_policy_construct(net, p, attrs, &err);
        if (!xp)
            return err;
        /* shouldn't excl be based on nlh flags??
         * Aha! this is anti-netlink really i.e  more pfkey derived
         * in netlink excl is a flag and you wouldnt need
         * a type XFRM_MSG_UPDPOLICY - JHS */
        excl = nlh->nlmsg_type == XFRM_MSG_NEWPOLICY;
        err = xfrm_policy_insert(p->dir, xp, excl);                    // [2] 检查通过则将新的policy对象插入到全局policy list中
        xfrm_audit_policy_add(xp, err ? 0 : 1, true);
        ... ...
        return 0;
    }
    // [1] verify_newpolicy_info() 参数检查
    static int verify_newpolicy_info(struct xfrm_userpolicy_info *p)
    {
      ... ...
        ret = verify_policy_dir(p->dir);                            // [3] 检查 p->dir，保证其值只能是0,1,2
        if (ret)
            return ret;
        if (p->index && ((p->index & XFRM_POLICY_MAX) != p->dir))     // [4] XFRM_POLICY_MAX=3，设置p->index=4 p->dir=0即可绕过本限制
            return -EINVAL;
        return 0;
    }
如果policy插入时包含timer set，则触发OOB后、超时后会执行以下timer函数：
[xfrm_policy_timer()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_policy.c#L305)
->
[xfrm_policy_delete()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_policy.c#L2233)
->
[__xfrm_policy_unlink()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_policy.c#L2202)
    static void xfrm_policy_timer(struct timer_list *t)
    {
        struct xfrm_policy *xp = from_timer(xp, t, timer);
        time64_t now = ktime_get_real_seconds();
        time64_t next = TIME64_MAX;
        int warn = 0;
        int dir;
        read_lock(&xp->lock);
        if (unlikely(xp->walk.dead))
            goto out;
        dir = xfrm_policy_id2dir(xp->index);            // [5] 根据用户提供的index重新计算： return index & 7 ->  dir=4&7=4     dir之前是用 XFRM_POLICY_MAX 来限制的，本应该小于3，现在却用7来计算，导致取值超过3。
        ... ...
    expired:
        read_unlock(&xp->lock);
        if (!xfrm_policy_delete(xp, dir))                    // [6]    
            km_policy_expired(xp, dir, 1, 0);
        xfrm_pol_put(xp);
    }
    // [6] xfrm_policy_delete()
    int xfrm_policy_delete(struct xfrm_policy *pol, int dir)
    {
        struct net *net = xp_net(pol);
        spin_lock_bh(&net->xfrm.xfrm_policy_lock);
        pol = __xfrm_policy_unlink(pol, dir);         // [7]    
        spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
        if (pol) {
            xfrm_policy_kill(pol);
            return 0;
        }
        return -ENOENT;
    }
    EXPORT_SYMBOL(xfrm_policy_delete);
    // [7] __xfrm_policy_unlink()
    static struct xfrm_policy *__xfrm_policy_unlink(struct xfrm_policy *pol,
                            int dir)
    {
        struct net *net = xp_net(pol);
        if (list_empty(&pol->walk.all))
            return NULL;
        /* Socket policies are not hashed. */
        if (!hlist_unhashed(&pol->bydst)) {
            hlist_del_rcu(&pol->bydst);
            hlist_del_init(&pol->bydst_inexact_list);
            hlist_del(&pol->byidx);
        }
        list_del_init(&pol->walk.all);
        net->xfrm.policy_count[dir]--;                // [8] dir=4, 导致越界减一
        return pol;
    }
###  1.2 构造UAF 空闲块8字节写NULL
**步骤** ：
  * （1）插入`policy1`对象，index=0, direction=0, priority=0
  * （2）插入`policy2`对象，index=4, direction=0, priority=1 (>0), a timer set
  * （3）请求`XFRM_SPD_IPV4_HTHRESH`，触发 policy rehashing
  * （4）请求`XFRM_FLUSH_POLICY`，触发释放`policy1`
  * （5）`policy2` 超时，触发 `policy1` 的UAF
第（1）（2）步后，两个policy对象被插入到同一list（direction 0），第（3）步执行以下函数，将已有的policy逆序重新插入
`bydst`
list。[xfrm_hash_rebuild()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_policy.c#L1201)
    static void xfrm_hash_rebuild(struct work_struct *work)
    {
      ... ...
        /* re-insert all policies by order of creation */
        list_for_each_entry_reverse(policy, &net->xfrm.policy_all, walk.all) {
            if (policy->walk.dead)
                continue;
            dir = xfrm_policy_id2dir(policy->index);                            // [9] 将 policy1 重新插入到 bydst list，由于 policy2 的index>=3，所以跳过不插入。
            if (dir >= XFRM_POLICY_MAX) {
                /* skip socket policies */
                continue;
            }
            newpos = NULL;
            chain = policy_hash_bysel(net, &policy->selector,
                          policy->family, dir);
            hlist_del_rcu(&policy->bydst);
            if (!chain) {
                void *p = xfrm_policy_inexact_insert(policy, dir, 0);
                WARN_ONCE(IS_ERR(p), "reinsert: %ld\n", PTR_ERR(p));