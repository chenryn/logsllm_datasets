β,Λβ
uv])(cid:9)
j(cid:54)=i Mi[rj
i(cid:54)=1.
, γ) ⊕ Λβ(Gi
γ,1 ⊕ Li
α,Λα
)⊕
(cid:8)Mj[r1
(cid:8)Mj[ri
(cid:8)Li
uv] := Λα · Mj[λ1
α,Λα, Li
uv] := H(Li
α,Λα, γ) ⊕ H(Li
Observe that for each i (cid:54)= 1, we have:
, γ) ⊕ ΛαGi
γ,Λγ := H(Li
β,Λβ
:=
Li
γ,Λγ
(cid:16)
Λβ((cid:76)
H(Li
α,Λα
j(cid:54)=i Mi[λj
j(cid:54)=1,
γ](cid:9)
α,Λα) ⊕ ((cid:76)
(cid:17)
H(Li
β,Λβ
j(cid:54)=i Mi[λj
γ]
.
β] ⊕ Λβ · Mj[λ1
, γ, j) ⊕ Gi,j
(cid:9)
α] ⊕ Mj[λ1
γ,uv
αβ] ⊕ Mj[λ1
, γ) ⊕ ΛαGi
β,Λβ
i(cid:54)=1,j(cid:54)=i,1,
γ,0 ⊕ Λβ(Gi
γ,1 ⊕ Li
(cid:17) ⊕(cid:16)
(cid:17) ⊕(cid:16)(cid:76)
β])
j(cid:54)=i Mi[λj
j(cid:54)=i Mi[λj
αβ]
α])
γ,0 ⊕ Λα((cid:76)
(cid:17) ⊕(cid:16)(cid:76)
γ,0 ⊕ Λα((cid:76)
(cid:0)H(Li
j(cid:54)=i Mi[λj
α,0, γ) ⊕ H(Li
It is easy to verify that the following holds:
H(Li
α,Λα
= H(Li
, γ) ⊕ ΛαGi
, γ) ⊕ Λα
α,Λα
α,0, γ) ⊕ Λαλβ∆i
= H(Li
and
H(Li
) ⊕ Λβ((cid:76)
β,Λβ
= H(Li
⊕Λβ((cid:76)
β,Λβ
α,Λα
γ,1 ⊕ Li
(cid:0)H(Li
α] ⊕(cid:76)
, γ) ⊕ Λβ(Gi
, γ) ⊕ Λβ
j(cid:54)=i Ki[λj
β,0, γ) ⊕ H(Li
j(cid:54)=i Mi[λj
β,0, γ) ⊕ ΛαΛβ∆i ⊕ Λβλα∆i.
= H(Li
j(cid:54)=i Mi[λj
β,1, γ)(cid:1) ⊕ Λβ(Li
α])
α] ⊕ λi
α∆i)
β])
α,1, γ)(cid:1) ⊕ Λα((cid:76)
β∆i ⊕(cid:76)
j(cid:54)=i Ki[λj
β] ⊕ λi
j(cid:54)=i Mi[λj
β])
α,0 ⊕ Li
)
α,Λα
Each garbler Pi locally computes the 0-label Li
γ,0 as:
Li
γ,0 := H(Li
α,0, γ) ⊕ H(Li
γ,0 ⊕ Li
Thus, we conclude that Li
β,0, γ) ⊕(cid:16)(cid:76)
j(cid:54)=i Ki[λj
αβ]
j(cid:54)=i Ki[λj
γ]
γ∆i.
αβ∆i ⊕(cid:16)(cid:76)
(cid:17) ⊕ λi
αβ] ⊕(cid:76)
j(cid:54)=i Mi[λj
αβ] ⊕ λi
(cid:17) ⊕ λi
(cid:17)
αβ∆i
γ,Λγ
is equal to:
γ] ⊕(cid:76)
= ΛαΛβ∆i ⊕ Λαλβ∆i ⊕ Λβλα∆i ⊕(cid:16)(cid:76)
⊕(cid:16)(cid:76)
=(cid:0)(Λα ⊕ λα) ∧ (Λβ ⊕ λβ) ⊕ λγ
(cid:17)
(cid:1)∆i = Λγ∆i,
= ΛαΛβ∆i ⊕ Λαλβ∆i ⊕ Λβλα∆i ⊕ λαβ∆i ⊕ λγ∆i
= ΛαΛβ∆i ⊕ Λαλβ∆i ⊕ Λβλα∆i ⊕ λαλβ∆i ⊕ λγ∆i
j(cid:54)=i Mi[λj
j(cid:54)=i Ki[λj
j(cid:54)=i Ki[λj
γ] ⊕ λi
γ∆i
where it is easy to verify that λαβ = λα · λβ according to the Beaver triples. This means that according
to Pi’s deﬁnition of Lγ,Λγ , the label evaluated by P1 is always correct. The public value is correct, since
lsb(∆2) = 1 and bγ ⊕ lsb(L2
) is equal to:
γ,Λγ
lsb(L2
γ,0) ⊕ lsb(L2
γ,Λγ ) = lsb(L2
γ,0 ⊕ L2
γ,Λγ ) = lsb(Λγ∆2) = Λγ.
45
w,01, Gi,j
w,00, Gi,j
(cid:8)Gi,j
w,10, Gi,j
w,11
α,u, Li
Lemma 9. Let A be a PPT adversary who corrupts a subset of parties such that P1 ∈ A is corrupted.
Either the execution of protocol Πmpc aborts, or A learns at most one of two garbled labels for any wire
and honest party, except with probability at most q/2κ−1, where q is the number of H queries.
Proof. Clearly, adversary A learns both garbled labels from some honest party Pi /∈ A for some wire if and
only if A learns the global key ∆i. Thus, we only need to prove the probability that the protocol execution
does not abort and A learns ∆i is at most q/2κ−1. If A succeeds to guess ci bits of ∆i for some ci ∈ [κ]∪{0}
via the (leak) command of Fprep, then the real protocol execution will abort except with probability 1/2ci.
Note that all the MACs received by A from Fprep do not include any information on ∆i, as the local
keys are uniformly random. Therefore, only the garbled tables generated by Pi may include the infor-
(cid:9)
mation of ∆i. In the half-gates garbled rows, ∆i is encrypted by both garbled labels, and thus is known
by A if and only if A has queried both garbled labels to random oracle H. Besides, in the garbled rows
j(cid:54)=i,1 for w ∈ W computed by Pi, the information of ∆i is only available in
β,v, γ, j) for (u, v) ∈ {0, 1}2\{(Λα, Λβ)}, γ ∈ W and j (cid:54)= i, 1, and thus A can
the computations H(Li
only obtain ∆i if and only if it makes the queries including both garbled labels for some wire to random
oracle H.
In both cases, the only way that A learns ∆i is to make queries to random oracle H. As a result, the
probability, that both garbled labels for some wire have been queried to H by A (i.e., ∆i is learned by A),
is bounded by q/2κ−1−ci. Overall, with probability at most 1/2ci · q/2κ−1−ci = q/2κ−1, the protocol does
not abort and A learns ∆i (thus both garbled labels for some wire).
Lemma 10. For each i ∈ [n], let xi
def= Λw ⊕ λw for each w ∈ Ii, where Λw is what Pi sends in
Step 9a of protocol Πmpc and λw is from Fprep. If any PPT adversary A corrupts a set of parties such
that P1 /∈ A is honest, then either P1 aborts, or P1 outputs y1 = f1(x1, . . . , xn) with probability at least
1 − (|C| + q + 2)/2κ, where H is |C|/2κ-almost universal, A makes at most q queries to H and f1 denotes
the P1’s output on multi-output function f.
Proof. After Step 10, P1 obtains a set of public values for all wires in the circuit C. In the following, we
will prove that if these public values are not correct, then P1 will abort with probability 1 − (|C| + 1)/2κ,
where recall that we use a polynomial hash to instantiate almost universal hash function H.
We ﬁrst prove that for each w ∈ W, we have tw = 0. For each AND gate (α, β, γ,∧), from the
w
deﬁnition of ti
(cid:76)
γ for i ∈ [n], we have
γ = Λα · Λβ ⊕ Λγ ⊕ Λα ·(cid:16)(cid:76)
i∈[n] ti
(cid:17) ⊕ Λβ ·(cid:16)(cid:76)
(cid:17) ⊕(cid:16)(cid:76)
i∈[n] λi
β
i∈[n] λi
α
i∈[n] λi
αβ
i∈[n] λi
γ
(cid:17) ⊕(cid:16)(cid:76)
(cid:17)
= Λα · Λβ ⊕ Λγ ⊕ Λα · λβ ⊕ Λβ · λα ⊕ λα · λβ ⊕ λγ
= (Λα ⊕ λα) ∧ (Λβ ⊕ λβ) ⊕ (Λγ ⊕ λγ) = tγ.
According to the deﬁnition of {M1[ti
w]}i(cid:54)=1 and M1[t1
w] for w ∈ W, we have the following:
n(cid:88)
i=1
i(cid:54)=1
(cid:88)
(cid:88)
n(cid:88)
i(cid:54)=1
M1[ti
w] =
=
=
(cid:88)
K1[ti
w] + t1
w∆1 +
M1[ti
w]
(K1[ti
w] + M1[ti
i(cid:54)=1
w]) + t1
w∆1
ti
w∆1 = tw∆1.
to denote the value sent by a malicious party Pi. Thus,(cid:80)
For each i (cid:54)= 1, we use zi to denote the correct value computed with H and the MACs held by Pi, and ˆzi
i(cid:54)=1 zi + e, where e is an adversarily
i(cid:54)=1 ˆzi =(cid:80)
i=1
46
(cid:17)
(cid:33)
w∈W
n(cid:88)
i=1
zi =
H
i=1