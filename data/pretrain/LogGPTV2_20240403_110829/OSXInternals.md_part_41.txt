used by the remote kernel-debugging protocol.
maxmem Setting maxmem=N limits the available physical
memory to N (in mega-bytes). N must be less than or
equal to the actual amount of physical memory
installed.
mcklog Specifies machine check flags.
mcksoft Setting mcksoft=1 enables machine check software
recovery.
novmx Setting novmx=1 disables AltiVec.
_panicd_ip Specifies the IP address of a remote kernel-core-dump
server machine, which is expected to be running the
kdumpd daemon on UDP port 1069.
pcata Setting pcata=0 disables the onboard PC ATA driver.
This may be useful during developmentfor example, if
a polled-mode driver is to be loaded.
platform Specifies a string to be used as the platform name in
the fake device tree on the x86. The default platform
name used is ACPI.
pmsx Setting pmsx=1 enables the experimental Power
Management Stepper (PMS) mode introduced in Mac
OS X 10.4.3.
romndrv Setting romndrv=1 allows a native graphics driver
(ndrv) to be used even if its creation date is older than
a predefined minimum date, which is March 1, 2001.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh3C8.htm 20.08.2007
Chapter 4. The Firmware and the Bootloader Page 72 of 86
_router_ip Specifies the router through which the remote kernel-
debugging protocol is to be routed while transmitting
kernel core dumps to a remote machine.
serial Setting serial=1 enables the serial console.
serialbaud Specifies the baud rate for the serial port. The
initialization routine for the kprintf() function
checks this argument.
smbios Setting smbios=1 enables detailed log messages in the
SMBIOS driver. An x86-only argument.
srv Setting srv=1 indicates a server boot. The kernel may
check the value of this variable to alter its behavior.
tb The kernel supports event tracing to a circular in-
memory buffer. A nondefault trace buffer size can be
specified through the tb argument. By default, the
kernel uses 32 pages in debug mode and 8 pages in
nondebug mode. The minimum and maximum values
are 1 and 256 pages, respectively.
vmdx, pmdx Cause the kernel to attempt to create a memory disk at
boot time. Used as vmdx=base.size, where x is a
single-digit hexadecimal number (0f), base is a page-
aligned memory address, and size is a multiple of the
page size. The v specifies virtual memory. A p can be
used instead to specify physical memory. If the
creation is successful, device nodes /dev/mdx
and /dev/rmdx will appear after boot.
vmmforce Specifies virtual machine monitor (VMM) features as
a logical OR of feature bits. The features so specified
are enforced for all virtual machine instances.
wcte Setting wcte=1 enables the write combine timer (or
store gather timer) in the PowerPC noncacheable unit
(NCU). By default, this timer is disabled.
Table 413 lists the various bits that can be set in the kernel's debug argument, which is perhaps the most
versatile and useful argument available for kernel-level debugging.
Table 413. Details of the debug Kernel Argument
Bit Name Description
0x1 DB_HALT Halt at boot time and wait for a debugger
connection.
0x2 DB_PRT Send kernel-debugging output generated by
the kernel's printf() function to the console.
0x4 DB_NMI Enable the kernel-debugging facility,
including support for generating a
nonmaskable interrupt (NMI) without a
physical programmer's switch. On a Power
Mac, an NMI can be generated by briefly
pressing the power button. On a notebook
computer, the command key must be held
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh3C8.htm 20.08.2007
Chapter 4. The Firmware and the Bootloader Page 73 of 86
down while pressing the power button. If the
power button is held down for more than five
seconds, the system will power off. The
DB_NMI bit is cleared if you use System
Preferences to change the startup disk.
0x8 DB_KPRT Send kernel-debugging output generated by
kprintf() to the remote output device, which
is typically a serial port (if one is available).
Note that kprintf() output is synchronous.
0x10 DB_KDB Use KDB instead of GDB as the default
kernel debugger. Unlike GDB, KDB must be
explicitly compiled into the kernel. Moreover,
KDB-based debugging requires native serial
port hardware (as opposed to, say, USB-based
serial port adapters).
0x20 DB_SLOG Enable logging of miscellaneous diagnostics
to the system log. For example, the
load_shared_file() kernel function logs
extra information if this bit is set.
0x40 DB_ARP Allow the kernel debugger nub to use ARP,
allowing debugging across subnets.
0x80 DB_KDP_BP_DIS Deprecated. Used for supporting old versions
of GDB.
0x100 DB_LOG_PI_SCRN Disable the graphical panic screen so that
panic data can be logged to the screen. It is
also useful for monitoring the progress of a
kernel core dump transmission.
0x200 DB_KDP_GETC_ENA Prompt for one of the c, r, and k characters to
continue, reboot, or enter KDB, respectively,
after a kernel panic.
0x400 DB_KERN_DUMP_ON_PANIC Trigger core dump on panic.
0x800 DB_KERN_DUMP_ON_NMI Trigger core dump on NMI.
0x1000 DB_DBG_POST_CORE Wait for a debugger connection (if using
GDB) or wait in the debugger (if using KDB)
after an NMI-induced core dump. If
DB_DBG_POST_CORE is not set, the kernel
continues after the core dump.
0x2000 DB_PANICLOG_DUMP Send only a panic lognot a full core dumpon
panic.
4.16. The Extensible Firmware Interface
In this section, we look at the Extensible Firmware Interface (EFI), which is a specification for an
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh3C8.htm 20.08.2007
Chapter 4. The Firmware and the Bootloader Page 74 of 86
interface between operating systems and platform firmware. x86-based Macintosh computers use EFI
instead of Open Firmware. EFI is conceptually very similar to Open Firmware. Although it is platform
independent in theory, EFI is primarily intended for the IA-32 and IA-64 architectures.
4.16.1. Legacy Pains
The primitive nature of the PC BIOS had long been an industry-wide problem even as the twenty-first
century arrived. One reason for the longevity of the BIOS, and for its sustained primitivity, is the
extremely successful MS-DOS (and clones), which was built on top of the BIOS. DOS programs call
BIOS routines via software interrupts. For example, the BIOS disk routine corresponds to interrupt
number 0x13 (INT 0x13). This is similar to many erstwhile Apple systems where the Macintosh ROM
contained both low-level code and the higher-level Toolbox.
Although the BIOS has seen numerous tweaks, improvements, extensions, and additions over the years, a
traditional BIOS in a modern environment still has numerous severe limitations, such as the following.
x86 computers always come up in the IA-32 real modean emulation of the ancient 8086/8088 Intel
processors. The BIOS executes in this mode, which is severely limited, especially for an ambitious
BIOSsay, one that wishes to provide a powerful preboot environment. Effective memory addresses
in the x86 real mode are calculated by multiplying the segment (a 16-bit number) by 16 and adding
an offset (another 16-bit number) to it. Thus, a segment is 16 bits widerestricted to 65,536 bytes
(64KB)and a memory address is 20 bits widerestricted to 1,048,576 bytes (1MB). In particular, the
instruction pointer (the IP register) is also 16 bits wide, which places a 64KB size limit on the code
segment. Memory is a very limited resource in real mode. Moreover, a BIOS may require static
reservation of resourcesespecially memory ranges.
The BIOS is inefficient at providing detailed information about the system hardware to its client
programs (such as bootloaders).[28]
[28] Modern BIOSs support a mechanism called E820 to report any memory present in
the system at POST. The report is in the form of a table of memory segments along
with the purpose each segment is used for.
Extended Memory
A small range of extended memory addresses can be accessed in real mode.[29] The 386 and
higher x86 processors can be switched from protected mode to real mode without a reset,
which allows them to operate in the big real mode: a modified real mode in which the
processor can access up to 4GB of memory. BIOSs can put the processor in this mode during
POST to make access to extended memory easier.
[29] This is known as the Gate A20 option.
A BIOS usually has hardcoded knowledge of supported boot devices. Support for booting from
newer devices typically is added to most BIOSs very slowly, if at all.
An option ROM is firmware typically residing on a plug-in card. It may also live on the system
board. Option ROMs are executed by the BIOS during platform initialization. The legacy option
ROM space is limited to 128KB, which is shared by all option ROMs. An option ROM typically
compacts itself by jettisoning some initialization code, leaving behind a smaller runtime code.
Nevertheless, this is a severe limitation.
Legacy BIOSs depend on VGA, which is a legacy standard and is unnecessarily complicated to
program for.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh3C8.htm 20.08.2007
Chapter 4. The Firmware and the Bootloader Page 75 of 86
The traditional PC partitioning scheme, which is the de facto scheme used with the BIOS, is rather
inadequate, particularly when it comes to multibooting or having a large number of partitions. PC
partitions may be primary, extended, or logical, with at most four primary partitions allowed on a
disk. The first 512-byte sector of a PC diskthe master boot record (MBR)has its 512 bytes divided
as follows: 446 bytes for bootstrap code, 64 bytes for four partition table entries of 16 bytes each,
and 2 bytes for a signature. The rather limited size of a PC partition table limits the number of
primary partitions. However, one of the primary partitions may be an extended partition. An
arbitrary number of logical partitions may be defined within an extended partition.
Even with standard network boot protocols such as Preboot Execution Environment (PXE) and
related security enhancements such as Boot Integrity Services (BIS), it is rather difficult, and often
impossible, to deploy and manage computers in a "zero-touch" fashion. In particular, the BIOS is
extremely difficult to work with when it comes to remote management at the system firmware level
or management of the system firmware itself.
Regardless of their nature, modern operating systems running on the x86 platform must interact with the
BIOS via legacy interfaces at system startup. The processor starts up in real mode and typically remains in
real mode even as an operating system kernel gains control, after which the kernel eventually switches the
processor into protected mode.
A representative legacy BIOS could be visualized as containing three sets of procedures: those that are the
same on all BIOSs (the core procedures), those that are specific to chips on the platform (the silicon
support procedures), and those that are specific to a system board. There are many "secret-sauce" elements
in the BIOS. The BIOS APIs are very limited, and in general it is very hard to extend the BIOSit is a black
box both to end users and to those wishing to develop preboot applications. Even if such developers
license the BIOS source, the environment is expensive to develop for and deploy in.
Preeminence of Preboot
As PC hardware and software vendors attempt to differentiate their offerings, the preboot
environment is becoming increasingly important. A computer with preboot functionality for
backup and restore, disk maintenance, data recovery, virus scanning, and so on is expected to
have more value than one without. In some cases, an application must be prebooted because
it cannot rely on the operating system. Examples of such applications include those for
performing low-level diagnostics, for recovering the operating system, and for updating
certain firmware. In some other cases, an application may not need the full operating system
and may explicitly wish to run without the operating system, perhaps to make the computer
behave like an appliancefor example, as a DVD or MP3 player, mail client, or web browser.
With legacy BIOS, such preboot applications are rather expensive to develop, deploy, and
run. EFI strives to simplify this domain greatly and includes specifications for creating
preboot software. Even a high-level application developer could create a preboot application
using familiar development tools.
4.16.2. A New Beginning
The PC world was rather late to adopt 64-bit computing. With the advent of 64-bit PCsthose based on
Intel's Itanium Processor Family, or IA-64, for examplea better solution to the BIOS problem was sought.
Even though the x86 real mode can be emulated in the IA-64 architecture, 64-bit PCs were introduced
without the legacy BIOS. The IA-64 firmware was divided into three primary components: the Processor
Abstraction Layer (PAL), the System Abstraction Layer (SAL), and the Extensible Firmware Interface
(EFI).
PAL abstracts the processor hardware implementation from the point of view of SAL and the operating
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh3C8.htm 20.08.2007
Chapter 4. The Firmware and the Bootloader Page 76 of 86
system. Different processor models with potential implementation differences appear uniformly via PAL.
Examples of the PAL layer's functionality include the following:
Interruption entry points including those invoked by hardware events such as processor reset,
processor initialization, and machine checks
Procedures that can be invoked by the operating system or higher-level firmware, such as
procedures for obtaining processor identification, configuration, and capability information; for
initializing the cache; and for enabling or disabling processor features
PAL has no knowledge of platform implementation details. Note, however, that PAL is part of the IA-64
architecture. The processor vendor supplies the firmware implementation of PAL, which resides in OEM
flash memory.
SAL provides an abstraction for the platform implementation, without any knowledge of processor
implementation details. SAL is not part of the IA-64 architectureit is part of the Developer's Interface
Guide for 64-bit Intel Architecture (DIG64). The OEM provides the firmware implementation of PAL.
As on IA-32 systems, Advanced Configuration and Power Interface (ACPI) exists on IA-64 as an
interface for allowing the operating system to direct configuration and power management on the
computer. ACPI is also a part of the firmwareit could be listed as the fourth primary component besides
PAL, SAL, and EFI. Note that since EFI also exists for IA-32, only PAL and SAL are the parts of IA-64
firmware that are specific to IA-64.
The remaining componentEFIcould be thought of as the grand solution to the PC BIOS problem.
4.16.3. EFI
EFI can be traced back to the Intel Boot Initiative (IBI) program that started in 1998, based on a white
paper by Intel engineer Andrew Fish. The EFI specificationdeveloped and maintained by a consortium of
companiesdefines a set of APIs and data structures that are exported by a system's firmware and used by
clients such as the following:
EFI device drivers
EFI system and diagnostic utilities
EFI shell
Operating system loaders
Operating systems
In a representative EFI system, a thin Pre-EFI Initialization Layer (PEI) might do most of the POST-
related work traditionally done by the BIOS POST. This includes operations such as chipset initialization,
memory initialization, and bus enumeration. EFI prepares a Driver Execution Environment (DXE) to
provide generic platform functions that EFI drivers may use. The drivers themselves provide specific
platform capabilities and customizations.
4.16.3.1. EFI Services
There are two classes of services available in the EFI environment: boot services and runtime services.
Boot Services
Applications that run only within the preboot environment make use of boot services, which include
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh3C8.htm 20.08.2007
Chapter 4. The Firmware and the Bootloader Page 77 of 86
services for the following:
Events, timers, and task priority
Memory allocation
Handling of EFI protocols
Loading of various types of images such as EFI applications, EFI boot services drivers, and EFI
runtime drivers
Miscellaneous purposes such as setting a hardware watchdog timer, stalling execution on the
processor, copying or filling memory, manipulating EFI System Table entries, and computing data-
buffer checksums
An operating system loader also uses boot services to determine and access the boot device, to allocate
memory, and to create a functional environment for the operating system to start loading. At this point, an
operating system loader could call the ExitBootServices() function, after which boot services are not
available. Alternatively, an operating system kernel could call this function.
Runtime Services
Runtime services are available both before and after ExitBootServices() is called. This category
includes the following types of services:
Management of variables (key-value pairs) used for sharing information between the EFI
environment and the applications that run within it
Management of hardware time devices
Virtual memoryfor example, to allow an operating system loader or an operating system to invoke
runtime services with virtual memory addressing instead of physical addressing
Retrieval of the platform's monotonic counter
Resets of the platform
Although EFI was designed for IA-64-based computers, its scope was widened to include the next
generation of IA-32 computers, with provisions for legacy BIOS compatibility through a Compatibility
Support Module (CSM). The CSM consists of a series of drivers that cooperate with a legacy BIOS
runtime component. It loads into memory in well-known legacy areas (below 1MB). Standard BIOS
memory areas such as the BIOS Data Area (BDA) and the Extended BDA are initialized. The Boot
Device Selection (BDS) mechanism appropriately selects either EFI or legacy BIOS.
Figure 420 shows a conceptual view of the EFI architecture.