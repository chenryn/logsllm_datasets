7
让我们用图 8-20 的树翻译方案来为图 8-19 中的输入树生成代码。假设第一个规则用
Ru
Ro←
Ca
RSR
·
{ADD RO, RO, SP }
{LDRO，#a }
ind
Ci"
ind
ind
AI.
RsP
RsP
W
C'
361
---
## Page 378
SP。最后，终结符c表示常量。
SP引人终结符 SP，并增加产生式 R→
M和m 匹配。类似地，我们为寄存器
使用涉及 M的某个模板之前首先要把
么理解规则（10)中的产生式M→m：在
例 8.18 中全局变量b 的位置。可以这
终结符号m表示特定的内存位置，比如
例8.21
应的上下文无关文法的产生式。对于一个树重写规则，相应的产生式的右部就是其指令模板的
示为：
析器来完成模式匹配。输人树可以用前缀方式表示为一个串。比如，图8-19中的树的前缀表
8.9.3通过扫描进行模式匹配
前缀表示方式。
来实现。我们进一步假设存在足够多的寄存器用于计算树的每个结点。那么，不管树匹配过程
或者无穷多个加载、保存指令。
出现某个单个结点被重写无穷多次的可能性。这种情况会产生无穷多个寄存器之间的移动指令，
树归约成为单一结点的过程中，我们生成了下列代码序列：
剩下的这棵树和规则(4)匹配，从而把这棵树归约为单个结点，并生成指令 ST＊RO，R1。在把
并生成增量指令 INC R1。至此，输人树已经被归约成为:
口何进行，剩下的树总能够被翻译成为目标机器指令序列。
相应文法的非终结符号是 R和 M。
在考虑通用的树匹配方法之前，我们先考虑一个特殊的匹配方法。这个方法使用LR语法分
为了避免阻塞，我们假设中间代码中的每个运算符都能够使用一个或多个目标机器的指令
362
如果没有匹配的模板，那么代码生成过程就无法继续了。在另一种极端情况下，我们要防止
?如何完成树模式匹配？代码生成过程(在编译时刻）的效率依赖于树匹配算法的
为了实现对例8.18中的树的归约过程，我们必须解决一些和树模式匹配相关的问题;
一个树翻译方案可以转换为一个语法制导的翻译方案，
些代码之间的效率是不同的。
效率依赖于模板被匹配的顺序，因为不同的匹配序列通常将产生不同的目标机代码，这
如果在某个给定时刻有多个模板可以匹配，我们该做什么？生成的代码(在运行时刻）的
效率。
图 8-21 中的语法制导翻译方案是基于图 8-20 中的树翻译方案构造的。
，SP
i(SP)
5
图8-21B
6
L
C
B23
2
BRMN
↑
↓
↑↑
↑
↑
由图 8-20 构造得到的语法制导翻译方案
+
+
，方法是把每个树重写规则替换为相
3
SS
LD
Ri,a(Rj) }
第
8章
口
---
## Page 379
个前缀表示 op E,E2中，有限向前看的 LR 语法分析方法中有关扫描动作的决定必须依据 E，的
8.9.5通用的树匹配方法
这个问题。
验证该翻译方案是否可靠地描述了目标机器。当然，所有的代码生成器都会或多或少地碰到
不同的上下文中使用不同的选择策略。因为目标机体系结构的某些方面(比如寻址模式)可以
情况选择指令。比如，两种不同的加法指令可以用同一个模板来表示：
足。实阴
定范围之内，或者两个属性的取值之间有一定关系。
性常
8.9.4用于语义检查的例程
候通过状态分裂技术来解决。
作)。造成阻塞的原因可能是该文法不能处理某些运算符的模式，也可能是语法分析器在解决某
须注意不要让得到的语法分析器在对表达式树进行语法分析的时候被阻塞（即无法进行下一步
得异常庞大。其结果是人们不得不使用特殊技术对描述机器的文法进行编码和处理。我们还少
易
>
外，对于某些具有很多种寻址模式的机器来说，描述机器的文法和由此得到的语法分析器可能变
生成高效的代码。
容
被
人
约，而不是较小的规约。这意味着在一个归约－归约冲突中，优先选择较长的归约；在一个移
析动作冲突的问题要多加小心。在没有指令代价信息的时候，总体处理规则是偏向于执行较大的！
一个 LR 语法分析器。目标代码通过每一步归约中发出的机器指令来生成。
地对代码生成器加以描述。可以使用通用模板来描述各类指令，然后使用语义动作来为特定
停地使用右部只有单个符号的产生式进行归约。无限循环问题可以在生成语法分析器表的时
语法分析动作冲突的时候做出了错误的选择。我们必须保证语法分析器不会进人无限循环
一个针对新机器的代码选择器。第三，可以通过增加特殊产生式来利用机器特有的指令，从而
易为所得代码生成器重新确定目标。只要写出描述新机器的指令集合的语法，就可以构造
人们理解。因此，使用第4章中描述的算法可以构造出可靠和高效的代码生成器。第二，比转
代码生成
基于前缀表示的用于模式匹配的 LR 语法分析方法优先处理双目运算符的左运算分量。在-
可以通过特定的断言来消除二义性，解决语法分析－动作的冲突问题。这些断言允许在
常带有关于该属性下标的取值的限制。比如，一个机器指令可能要求某个属性的值位于特
在一个代码生成翻译方案中出现的属性和输入树中的属性是一样的。但是翻译方案中的属
但使用这个方法也存在着一些挑战。语法分析方法确定了求值过程必须是从左到右的。
在代码生成中使用LR语法分析方法有多个好处。第一，语法分析方法是高效的，并且容
一个用于代码生成的语法具有很大的二义性。在构造语法分析器的时候，对于如何处理语法分
根据这个翻译方案的产生式，我们可以使用第4章中的某个LR语法分析器构造技术来构建
使用这些终结符，图8-19中的输人树对应的串是：
际上，相对于纯文法描述的方式而言，语义动作和断言的普遍使用能够更加灵活、更加容
《些关于属性值的限制可以用断言来描述。在进行归约之前需要判断相应的断言是否被消
R←
Ri
i qu + ds ! + pu ds " + + pu! = 
363
在
满
长
得
较
易
1
口
---
## Page 380
8.9.68.9节的练习
求值的顺序。
如此，动态规划算法使得代码生成器的设计者不需要再去解决匹配冲突的问题，或者决定
使用这个方法，可以根据一个树重写方案快速地构造出一个小而高效的代码生成器。不仅
最优的匹配序列。我们要在各个候选序列的代价值都确定之后再决定使用哪个匹配序列。
合使用的动态规划算法。
式匹配程序，并且在最后一次访问这个结点的时候进行归约。
配多个串的技术。
示以+为根的两个模板中的+号和它的左运算分量R。
结点的串集合：
属性，而不考虑它们的值。
例8.22
中（从左到右地)为每个子结点加人位置编号，我们平等地处理每个运算分量。
板表示成一个串的集合，其中每个串对应于模板中的一条从根到某个叶结点的路径。通过在串
中介绍的串模式匹配技术，我们可以开发出一个高效的自顶向下算法。其基本思想是把每个模
则如果根的标号是+，那么可能匹配的是规则6～8的模式。
门的匹配程序。比如，如果输人树的根的标号是ind，那么唯一能够匹配的是规则5 的模式；否
法会优先处理右运算分量。
中选择较好指令的机会。但是模式匹配方法可能会错失这些机会。
通过并发地运行该动态规划算法，我们可以使用各个规则相关的代价信息来选择一个
使用例8.22中的串集合可以构造出一个树模式匹配程序。该程序使用了可以高效地并行匹
我们也可以弃用前缀表示方式而使用后缀表示。但是，一个用于模式匹配的 LR 语法分析方
如果要考虑指令代价的问题，可以给每个树重写规则关联一个代价值。这个值等于应用这
在实践中，树重写过程可以按照如下方法实现：对输人树进行深度优先遍历的同时运行树模
图8-22中的模板有如下的从根到叶子
对于一个可以生成代码生成器的生成器，我们需要一个通用的树匹配算法。通过扩展第3章
对于一个手写的代码生成器，我们可以使用图8-20 中所示的树模板作为指南，编写一个专
364
！练习8.9.3：扩展图8-20 中的树重写方案，使之可应用于 while 语句。
练习8.9.2：使用图8-21中的语法制导翻译方案来替代树翻译方案，重复练习8.9.1。
使用图8-20 中的树重写方案来为每个语句生成代码。
3)x= x+ 1; 
2) x[i] = y[j] * z[k];
l)x=ab+c* d;
练习8.9.1：为下面的语句构造抽象语法树。假设所有不是常量的运算分量都存放在内存中。
串C表示以C 为根的模板。串+1 R表 
十
练习8.9.4：扩展树重写技术使之应用于 DAG。
1R
在为一个指令集构建串集合的时候，我们将去掉下标。因为进行模式匹配时只考虑
1
图8-22
CaR.
一个用于树匹配的指令集
R:
Q
R.
第8章
口
---
## Page 381
果存回内存的指令，而这个代码所使用的寄存器数目就是根结点的标号。
回内存的指令。对这个断言的证明包含在下面的算法中。这个算法生成的代码不包含将临时结
的中间结果，所以，造成生成代码不是最优代码的唯-一可能是我们使用了不必要的将临时结果存
在这个机器模型中，我们必须把每个运算分量加载到寄存器中，且必须计算每个内部结点所对
内存，那么一个结点的标号就等于计算该结点对应的表达式时需要的最少的寄存器个数。因为
某个运算的运算分量和结果。可以证明，如果在计算表达式的过程中不允许把中间结果保存！
8. 10.2
的结点。它的两个子结点的标号都是2，因此它的标号是3。
据规则3，t3 对应结点的标号是其中的较大值，即2。最后计算根结点，即对应于 t4=t1+t3
的结点的标号的计算方式与此类似。
结点加上标号，因为它的两个子结点都已经被加
1。然后，我们可以给对应于 tl =a-b 的内部
根据规则(1)，该树的五个叶子结点的标号都是
是表达式(α－b）+e×（c+d)的树，或者说是下面的三地址代码的树：
例8.23在图8-23中，我们可以看到一个表达式树（其中的运算符已经被省略)。这个树可能
们的机器模型而言，计算 Ershov数的规则如下：
number）。这是根据A.Ershov 命名的，他为只有--个算术寄存器的机器使用了类似的方案。对我