return 0;
printf ("x=%d\n",
printf("%d:%d in main\n", hour, minute);
print
int hour = 0,minute = 30;
，设想整个源文件是一张大纸，
因为大纸（全局变量的作用域）被盖住了，
，也就是main函数局部变量的作用域。在小纸上用到标识符hour和minute时应
time ();
return 0;
printf(
print_time();
x);
"%d:%d in main\n", hour, minute);
所以比较容易找到Bug。因此，虽然全局变量用起来很方便，
第二次直接调用printf打印的则是main函数局部
，如果代码规模很大，
也就是全局变量的作用域，
，而main函数局部变量的作用域仅限于main函数
，其实也可以用表达式做lnitializer,
而全局变量只能用常量表达式
如果在小纸上用到某个标识符却
这种错误是很难找到的。而
 而main函数是盖在这
从函数的源代码很容
但
---
## Page 65
不是像我们分析的这样：
部变量的存储空间在每次函数调用时分配，在函数返回时释放”。分析完了，我们运行程序看看是
量i的存储空间，
第一次调用foo函数，
语法规则时，可以查教材，也可以查C99，
如何证明“局部变量的存储空间在每次函数调用时分配，在函数返回时释放"？当我们想要确认某些
如果全局变量在定义时不初始化则初始值是0，如果局部变量在定义时不初始化则初始值是不确定
定，所以编译器不必想办法去算这个初始值。
虽然在编译时计算出hour的初始值是可能的,
量表达式来初始化，因此下面这种全局变量初始化是不合法的：
区分编译时和运行时这两个概念。
种Initializer的值必须在程序运行时调用acos 函数才能得到，所以不能用来初始化全局变量。请注意
值必须保存在编译生成的可执行文件中，因此初始值在编译时就要计算出来，
然而局部变量这样初始化却是可以的。程序开始运行时要用适当的值来初始化全局变量，
但这样初始化是不合法的：
不确定的值，
的。所以，
Bug。
例3.7.验证局部变量存储空间的分配和释放
int minute = 360;
double pi = acos(-l.0);
134518128
局部变量在使用之前一定要先赋值，如果基于-
，然后把i赋值为777，函数返回，
hour 
int main(void)
void foo(void)
 #include 
然后打印i的值,
，分配变量i的存储空间，
minute / 60;
return
foo();
int i;
777;
0;
由于i未初始化,
，为了简化编译器的实现,
但最快捷的办法就是编个小程序验证一下：
，然后打印i的值，由于i未初始化，打印的应该是一个
 释放i的存储空间。
但是minute／60不是常量表达式，不符合语法规
，如果打印的又是一个不确定的值，
，C语言从语法上规定全局变量只能用常
一个不确定的值做后续计算肯定会引
。第二次调用foo函数，分配变
然而上面第二
，就证明了“局
，所以初始
8
---
## Page 66
如：
从第2节“自定义函数"介绍的语法规则可以看出，非定义的函数声明也可以写在局部作用域中，例
什么这个不确定的值刚好是777，或者刚好是0，等学到例19.1“研究函数的调用过程"就能解释这
在Debug时尤其重要,
注意，不要把必要条件（Necessary Condition）当充分条件（Sufficient Condition）
关键的一点是，
不是说“局部变量不初始化则初值不确定"吗？
结果是：
用之间插一个别的函数调用，结果就大不相同了：
断胡乱给问题定性，
些现象了。
则初值为0",
果
结
上次调用赋的值？在这里"不确定"的准确含义是：每次调用这个函数时局部变量的初值可能不-
配
这
这
有可能被干扰得不能正确运行。
我记错了
就
原本就没有把这条语法规则记牢，
是初学者最常见的两种心态。
是该结论的必要条件，
论倒是能推出777这个结果，
一回，
是错了
论者或不可知论者
时使用它
果出乎意料,
 每次函数调用时使用它，
运行环境不同，
，在函数返回时释放"这个结论似乎对了，
连C99也这么写的啊，C99也是人写的，也难免出错，或者C99也许没错，
例如，
第二次调用foo打印的i值又不是777了而是0，“局部变量的存储空间在每次函数调用时分
134518200
int main(void)
，在函数返回时释放",
int main(void)
，不要看到第二次调用打印777就下结论"函数中的局部变量具有一
，计算机这东西真靠不住，
改过来记吧，
，0这个结果是该结论的必要条件，但也不是充分条件。至于为什么会有这些现象，
返回时也不释放,
，我说"初值不确定",
第二次调用打印的i值正是第-
print_time(23,
return
，函数的调用次序不同，都会影响到局部变量的初值。在运用逻辑推理时一定要
“说你有罪你就有罪”。先不要胡乱怀疑，我们再做一次实验，在两次foo函数调
看到错误现象不要轻易断定原因是什么，
，看到这个结果就会想：教材上明明说"局部变量的存储空间在每次函数调用
，但不是充分条件。也不要看到第二次调用打印0就断定“局部变量未初始化
0;
应该是“函数中的局部变量具有一直存在的固定的存储空间，每次函数调
，返回时也不释放，
，但反过来由777这个结果却不能推出这样的结论。
，那一定是教材写错了，
 不从客观事实和逻辑推理出发分析问题的真正原因，
再次调用函数时它应该还能保持上次的值”。还有一种初学者是怀
，或者对自己的记忆力没信心，看到这个结果就会想：哦那肯定是
59);
，有没有说这个不确定值不能是0？有没有说这个不确定值不能是
，太容易受电磁干扰和宇宙射线影响了，我的程序写得再正确也
int);
，但另一个结论又不对了：全局变量不初始化才是0啊，
一次调用末尾赋给i的值777。
，再次调用函数时它应该还能保持上次的值"，
，教材也是人写的，
一定要考虑再三，找出它的真正
是人写的就难免出错,
一直存在的固定的存储
有
一种初学者是这样
但是反正运行结果
，所以说777这个结
，而仅凭主观臆
，这个
8
为
空
原
也
是
---
## Page 67
[5] 但gcc 的扩展特性允许嵌套定义函数，本书不做详细讨论。
3.形参和实参
许嵌套定义函数[5]。
指令。另外注意，
int);,
写非定义的函数声明时参数可以只写类型而不起名，
存在print_time这个标识符了。
这样声明的标识符print_time具有局部作域，
只要告诉编译器参数类型是什么，
虽然在一
return 0;
一个函数体中可以声明另一个函数，但不能定义另一
全国嵌入式人才培训基地
，编译器就能为print_time(23，
，只在main函数中是有效的函数名，出了main函数就不
起始页
一级
：59)函数调用生成正确的
一个函数，C语言不允
第4 章分支语句
9
---
## Page 68
4.全局变量、局部变量和作用域
3.布尔代数
2. if/else语句
1.if语句
目
第 4 章 分支语句 请点评
上一页
全国嵌入式人才培训基地
全国嵌入式人才培训基地
部分I.C语言入门
第4章分支语句
起始页
上一级
1.if语句
---
## Page 69
注意以下几点：
句，这种控制流程称为分支（Branch）。上例中的!=号表示“不等于”,
序的控制流程（Control Flow）
其中x！=0表示"x不等于0"的条件，
分支语句（Selection Statement）实现，比如：
件成立，
外，有时候我们需要检查一个条件，
目前我们写的简单函数中可以有多条语句，
1. if语句 请点评
4.这些运算符的两个操作数应该是相同类型的，两边都是整型或者都是浮点型可以做比较，
 3．在数学中a0这个表达式的值为0，x>-2这个表达式的
把==写成=，在C语言中=号是赋值运算符，两者的含义完全不同。
页
值为1。
运算符
表4.1.关系运算符和相等性运算符
>=
1l 
则中的语句被执行，
if (x!=0）
小于或等于
大于或等于
小于
大于
不等于
等于
printf("x is nonzero.\n");
含义
，否则凸中的语句不执行，
，不再是从前到后顺序执行,
、然后根据检查的结果执行不同的后续代码，在C语言中可以用
全国嵌入式人才培训基地
 相当于数学中的=号，
第4章分支语句
但这些语句总是从前到后顺序执行的。除了顺序执行之
但作为C语言表达式却不是这样。以上几种运算符都是
1. if语句 
，直接跳到}后面。ir和控制表达式改变了程
否则为假（False），
而是根据不同的条件执行不同的语
，初学者常犯的错误是在控制表达式中
”，像这样的运算符有：
，在C语言中分别
69
下一
但
贝
---
## Page 70
习题 请点评
块可以用在任何允许出现语句的地方，不一定非得用在i语句中，单独使用语句块通常是为了定义
量j在退出语句块之后就没有了
块中的变量i和函数的局部变量i是两个不同的变量，因此两次打印的i值是不同的；语句块中的变
大纸，foo函数是盖在上面的一张小纸，
量的存储空间。语句块也构成一个作用域，
和函数的局部变量同样道理，
语句块中也可以定义局部变量，例如:
成语句块，可以简单地写成：
一个单独的;号表示一条空语句（Null Statement）。上例的语句块中只有一条语句，其实没必要写
语句块的}后面不需要加;号。
条语句或声明组成的语句块（Statement Block）
在C语言中，
语句→；
语句→{语句列表}
语句 →if(控制表达式)语句
和if语句相关的语法规则如下:
}是等价的，如果x的值是2，则x！=0的值是1，但对于i来说不管是2还是1都表示真值。
为0，就跳过凸中的语句直接执行后面的语句，
义
的语句。事实上控制表达式取任何非0值都表示真值，
总结一下，
1、
一些比函数的局部变量更"局部"的变量。
5．==和!=称为相等性运算符（Equality Operator）
，这是一个语义错误），请分析一下哪里错了。还有，既然错了为什么编译能通过呢？
以下程序段编译能通过，执行也不出错，
Operator）
两个字符串不能做比较,
int x = -1;
if (x != 0)
void foo(void)
 if (x != o） {
，任何允许出现语句的地方既可以是由;号结尾的一条语句，
printf("i=%d\n", i); /* cannot access j here */ 
int i = 0;
 printf("x is nonzero.\n");
，相等性运算符的优先级低于关系运算符。
int
。如果}后面加了;号，
，每次进入语句块时为变量j分配存储空间，
}这个语句的计算顺序是：
在第1.5节“比较字符串"我们会介绍比较字符串的方法。
因此最后一行的printf不能打印变量j，
=
，则函数中的语句块是盖在小纸上面的一张更小的纸。语句
但是执行结果不正确（根据第3节“程序的调试"的定
，和例3.6“作用域"的分析类似，
如果值为1,
，则这个;号本身又是一条新的语句了，
 语句块和上一章介绍的函数体的语法相同。注意
其余四个称为关系运算符（Relational
：首先求x！=o这个表达式的值，
，就先执行中的语句，然后再执行后面
，每次退出语句块时释放变
也可以是由括起来的若干
 否则编译器会报错。语
如果整个源文件是一张
...........
在C语言中
如果值
义
---
## Page 71
第4 章分支语句
if (x > 0);
printf("x is positive.\n");
全国嵌入式人才培训基地
起始页
上一级
2. if/else语句
了
---
## Page 72
条if或if/else语句。根据组合规则，if或if /else可以嵌套使用。例如可以这样：
if/else语句的语法规则如下：
查一个数的奇偶性只需调用这个函数而不必重复写这条语句了，例如：
把语句封装成函数的基本步骤是：把语句放到函数体中，把变量改成函数的参数。这样，以后要检
if语句还可以带一个else子句（Clause），例如：
2. if/else语句 请点评
右边的"语句"既可以是一条语句，
语句 →if (控制表达式)语句 else 语句
让这条语句更有用，可以把它封装（Encapsulate）成一个函数：
是0，如果是O则打印x is even·，
取模运算在程序中是非常有用的，
果和除数同号的，也有不做明确规定的。
结果总是与被除数同号（想一想为什么）。
是正是负呢？C99规定，
算符的两个操作数必须是整型的。两个正数相除取余数很好理解，
这里的%是取模（Modulo）运算符，
二
页
print_parity(18);
.............................
void print_parity(int x)
else
if (x % 2 
printf("x is even.\n");
else
if (x  2 == 0)
printf("x is odd.\n");
 如果a和b是整型，
printf("x is odd.\n");
printf("x is even.\n");
，也可以是由括起来的语句块。
如果不是0则打印x isodd.，读者应该能看出else在这里的作用
，例如上面的例子判断x的奇偶性（Parity）
子语句可以是任何语句或语句块，
x°2表示x除以2所得的余数（Remainder）
全国嵌入式人才培训基地
。其它编程语言对取模运算的规定各不相同，
第4章分支语句
2. if/else语句
一条if语句中包含一条子语句，
可以得到一个结论：%运算符的
，如果操作数中有负数，结果应
 当然也可以是另外-
看x除以2的余数是不
C语言规定%运
，也有规定结
乙
再
结
---
## Page 73
顺便提一下，浮点型的精度有限，不适合用==运算符做精确比较。以下代码可以说明问题：
明确加上：
危险了：你看到的是这样，而编译器理解的却是那样。如果你希望编译器按第一种方式理解，应
应该理解成else和if (B)配对,
都有这个问题，称为Dangling-else问题。C语言规定，
按哪种方式理解呢？也就是说，else到底是和if (A)配对还是和if(B)配对？很多编程语言的语法
在第1节“继续Hello World"讲过，C代码的缩进只是为了程序员看起来方便，实际上对编译器不起
也可以理解成
现在有一个问题，类似if（A）if（B）C；élse D;形式的语句怎么理解呢？可以理解成
也可以这样：
任何作用，
double.
if (A)
if (A)
else
if (A)
} else {
else
else if "
if (x> 0).
else
if
 else
你的代码不管写成上面哪一种缩进格式，
printf("Unequal.\n");
printf("Equal.\n");
if (B)
if (B)
if (B)
‘if (x< 0).
printf("x is positive.\n");