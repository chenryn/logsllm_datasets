         48 | (4280,1)  |      16 | f     | f    | 07 00 00 00 03 00 00 00  
         49 | (4565,1)  |      16 | f     | f    | 07 00 00 00 03 00 00 00  
         50 | (4850,1)  |      16 | f     | f    | 08 00 00 00 01 00 00 00  
         51 | (5135,1)  |      16 | f     | f    | 08 00 00 00 03 00 00 00  
         52 | (5420,1)  |      16 | f     | f    | 09 00 00 00 03 00 00 00  
(52 rows)  
```  
索引的非leaf节点，data表示这个PAGE的最小边界值，最左边的页没有最小值  
如何快速找到c1=1 and c2=2，通过以上信息，可以知道1,2在575号数据块中。  
```  
         19 | (575,1)   |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         20 | (8866,1)  |      16 | f     | f    | 01 00 00 00 03 00 00 00  
```  
继续查看575号索引页的内容。这个页是第一层（不是最后一层），分支节点  
第一条表示与当前页右边的相邻页，data是它的最小值。第二条表示当前页左边的相邻页，data为空。  
```  
postgres=# SELECT * FROM bt_page_items('idx_tab1', 575);   
 itemoffset |   ctid   | itemlen | nulls | vars |          data             
------------+----------+---------+-------+------+-------------------------  
          1 | (8712,1) |      16 | f     | f    | 01 00 00 00 03 00 00 00  
          2 | (572,1)  |       8 | f     | f    |   
          3 | (573,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
          4 | (574,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
          5 | (576,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
          6 | (577,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
          7 | (578,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
          8 | (579,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
          9 | (580,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         10 | (581,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         11 | (582,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         12 | (583,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         13 | (584,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         14 | (585,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         15 | (586,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         16 | (587,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         17 | (588,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         18 | (589,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         19 | (590,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         20 | (591,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         21 | (592,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         22 | (593,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         23 | (594,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         24 | (595,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         25 | (596,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         26 | (597,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         27 | (598,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         28 | (599,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         29 | (600,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         30 | (601,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         31 | (602,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         32 | (603,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         33 | (604,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         34 | (605,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         35 | (606,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         36 | (607,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         37 | (608,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         38 | (609,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         39 | (610,1)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         40 | (5488,1) |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         41 | (8961,1) |      16 | f     | f    | 01 00 00 00 03 00 00 00  
         42 | (8960,1) |      16 | f     | f    | 01 00 00 00 03 00 00 00  
。。。。。。。。。。。。。。  
```  
通过这两行，找到了c1=1.c2=2应该在5488号索引页中。  
```  
         40 | (5488,1) |      16 | f     | f    | 01 00 00 00 01 00 00 00  
         41 | (8961,1) |      16 | f     | f    | 01 00 00 00 03 00 00 00  
```  
继续搜索索引也，第二层（最后一层），叶子节点   
```  
postgres=# SELECT * FROM bt_page_items('idx_tab1', 5488);   
 itemoffset |    ctid     | itemlen | nulls | vars |          data             
------------+-------------+---------+-------+------+-------------------------  
          1 | (16215,25)  |      16 | f     | f    | 01 00 00 00 03 00 00 00  
          2 | (5398,127)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
          3 | (5398,137)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
          4 | (5398,156)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
          5 | (5398,172)  |      16 | f     | f    | 01 00 00 00 01 00 00 00  
.....  
        130 | (5405,10)   |      16 | f     | f    | 01 00 00 00 01 00 00 00  
        131 | (5405,15)   |      16 | f     | f    | 01 00 00 00 01 00 00 00  
        132 | (5405,17)   |      16 | f     | f    | 01 00 00 00 01 00 00 00  
        133 | (5405,35)   |      16 | f     | f    | 01 00 00 00 01 00 00 00  
        134 | (5405,59)   |      16 | f     | f    | 01 00 00 00 01 00 00 00  
        135 | (10810,151) |      16 | f     | f    | 01 00 00 00 02 00 00 00  
        136 | (16216,41)  |      16 | f     | f    | 01 00 00 00 03 00 00 00  
        137 | (16216,40)  |      16 | f     | f    | 01 00 00 00 03 00 00 00  
        138 | (16216,39)  |      16 | f     | f    | 01 00 00 00 03 00 00 00  
...  
```  
找到记录  
HEAP PAGE  
```  
        135 | (10810,151) |      16 | f     | f    | 01 00 00 00 02 00 00 00  
```  
因为是叶子节点，所以ctid表示的是HEAP的偏移值，直接在HEAP PAGE中查看  
```  
postgres=# select * from tab1 where ctid='(10810,151)';  
 id | c1 | c2   
----+----+----  
  1 |  1 |  2  
(1 row)  
```  
在了解了多列索引的内部结构后，可以来看一下几种查询场景的优化  
### 例子 - 范围+等值查询  
驱动列使用范围条件，第二列使用等值条件  
虽然走了索引，但是扫描了第一列的所有索引页。  
性能不佳  
```  
postgres=# explain (analyze,verbose,timing,costs,buffers) select * from tab1 where c1 between 1 and 9 and c2=2;  
                                                         QUERY PLAN                                                            
-----------------------------------------------------------------------------------------------------------------------------  
 Index Scan using idx_tab1 on public.tab1  (cost=0.43..60757.38 rows=1 width=12) (actual time=0.027..106.362 rows=1 loops=1)  
   Output: id, c1, c2  
   Index Cond: ((tab1.c1 >= 1) AND (tab1.c1 = 1) AND (tab1.c1 <= 9))  
   Buffers: shared hit=4  
 Planning time: 0.095 ms  
 Execution time: 0.040 ms  