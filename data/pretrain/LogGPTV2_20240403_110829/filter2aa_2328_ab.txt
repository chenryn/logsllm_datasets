the Surface object header. The header is increased by 8 bytes, which must be considered, else the 
allocation alignment fails. The second is the randomization of the HAL Heap, this means that a pointer into 
ntoskrnl.exe can no longer be found at the address 0xFFFFFFFFFD00448. 
14 
Revival of Kernel Read and Write Primitives Take 2 
With the changes in Windows 10 Creators Update, both kernel-mode read and write primitives break, 
however the changes to the bitmap primitive are minimal and may be rectified in a matter of minutes by 
simple decreasing the size of each bitmap to ensure it takes of 0x1000 bytes. The changes for the tagWND 
kernel-mode read and write primitive are much more substantial. 
The Win32ClientInfo structure from the TEB has also been modified, previously offset 0x28 of the structure 
was the ulClientDelta, which describes the delta between the user-mode mapping and the actual Desktop 
Heap. Now the contents are different: 
A user-mode pointer has taken its place, inspecting that pointer reveals it to be the start of the user-mode 
mapping directly, which can be seen below: 
In this example, the content of the two memory areas are the same, and that the Desktop Heap starts at 
0xFFFFBD2540800000. While the UserHandleTable is removed and the metadata to perform a search for 
the handle has been removed, the actual data is still present through the user-mode mapping. By 
performing a manual search in the user-mode mapping it is possible to locate the handle and from that 
calculate the kernel-mode address. First the user-mapping is found and the delta between it and the real 
Desktop Heap as seen below. 
Next the kernel-mode address of the tagWND object can be located from the handle: 
15 
This overcomes the first part of the mitigation introduced in Creators Update. While the address of the 
tagWND object can be found, it still does not solve all the problems, since SetWindowLongPtr cannot 
modify the strName of the following tagWND object, it is still not possible to perform read and write 
operations of arbitrary kernel memory. 
The size of ExtraBytes for a tagWND object denoted by cbWndExtra is set when the window class is 
registered by the API RegisterClassEx. While creating the WNDCLASSEX structure used by RegisterClassEx 
another field called cbClsExtra is noted as seen below 
This field defines the size of ExtraBytes for the tagCLS object which is associated with a tagWND object. The 
tagCLS object is also allocated to the Desktop Heap and registering the class just prior to allocating the 
tagWND makes the tagCLS object to be allocated just before the tagWND object. Allocating another 
tagWND object after that brings about a layout as seen below 
By overwriting the cbClsExtra field of the tagCLS object instead of the cbWndExtra field of the tagWND1 
object we obtain an analogous situation to before. Using the API SetClassLongPtr instead of 
SetWindowLongPtr allows for modification of the ExtraBytes of the tagCLS object. This API has not been 
modified and still writes its ExtraBytes to the Desktop Heap, which once again allows for modifying the 
strName field of tagWND2. 
tagCLS 
tagWND2 
tagWND1 
16 
An arbitrary write function can be implemented as shown below 
A similar arbitrary read primitive can be created as well, thus completely bypassing the mitigations 
introduced in Creators Update against kernel-mode read and write primitives. 
17 
Kernel ASLR Bypass 
The mitigations introduced in Windows 10 Anniversary Update and Creators Update have eliminated all 
publicly known leaks of kernel drivers. Often kernel-mode information leak vulnerabilities are found, but 
these are patched by Microsoft, of more interest are the kernel driver information leaks which are due to 
design issues. The last two known KASLR bypasses were due to the non-randomization of the HAL Heap and 
the SIDT assembly instruction, both have been mitigated in Windows 10 Creators Update and Anniversary 
Update respectively. 
Often kernel driver memory addresses are needed to complete exploits, so discovering new design issues 
which lead to kernel driver information leaks are needed. The approach used is to make KASLR bypasses 
which relate to the specific kernel-mode read primitive. So, one KASLR bypass is created for the bitmap 
primitive and one for the tagWND primitive. 
The first one to be discussed is the one related to the bitmap primitive. Looking at the kernel-mode Surface 
object in the structures reversed engineered from Windows XP and written on REACTOS shows the Surface 
object to have the following elements 
Reading the description of the field called hdev yields 
This gives the question of what is the PDEVOBJ, luckily that structure is also given on REACTOS and contains 
18 
The fields of type PFN are function pointers and will give us a kernel pointer. The method for leaking is then 
to read the hdev field and use that to read out the function pointer. Inspecting the Surface object in 
memory shows the value of hdev to be empty 
Creating the bitmap object with the CreateBitmap API does not populate the hdev field, however other 
API’s exist to create bitmaps. Using the CreateCompatibleBitmap API also creates a bitmap and a kernel-
mode Surface object, inspecting that object in memory shows it to contain a valid hdev pointer 
Using this pointer and dereferencing offset 0x6F0 gives the kernel-mode address of DrvSynchronizeSurface 
in the kernel driver cdd.dll.  
19 
To leverage this, the following method is employed. First locate the handle to the bitmap which has its 
Surface object at an offset 0x3000 bytes past the one found with the pool leak. Then free that Surface 
object by destroying the bitmap and reallocate multiple bitmap objects using the CreateCompatibleBitmap 
API. This is implemented below 
The hdev pointer is then at offset 0x3030 from the pool leak, which in turn gives the pointer to 
DrvSynchronizeSurface. DrvSynchronizeSurface contains a call to the function 
ExEnterCriticalRegionAndAcquireFastMutexUnsafe in ntoskrnl.exe at offset 0x2B as shown below 
From this pointer into ntoskrnl.exe it is possible to find the base address by checking for the MZ header and 
searching backwards 0x1000 bytes at a time until it is found. The complete ntosknl.exe base address leak 
function is shown below 
While the above explained KASLR bypass works best while used in conjunction with the bitmap read and 
write primitive, the tagWND read and write primitive can also make use of a similar idea. By looking at 
structures documented on REACTOS from Windows XP, the header of a tagWND object is a structure called 
THRDESKHEAD, which contains another structure called THROBJHEAD, which in turn contains a pointer to a 
structure called THREADINFO. This is shown below, first the tagWND structure header 
20 
Followed by the THRDESKHEAD and the THROBJHEAD 
Finally, the header of the THREADINFO structure, which contains a structure called W32THREAD 
The W32THREAD structure contains a pointer to the KTHREAD object as its first entry 
While this is a lot of structure transversal of very old documented structures it is worth noticing that even 
in Windows 10 Creators Update the KTHREAD contains a pointer into ntoskrnl.exe at offset 0x2A8. Thus 
given the kernel-mode address of a tagWND object it is possible to gain a pointer to ntoskrnl.exe. By 
translating the 32-bit Windows XP structures to 64-bit Windows 10 and inspecting memory it becomes 
clear that dereferencing offset 0x10 of the tagWND object gives the pointer to the THREADINFO object. 
Dereferencing that pointer gives the address of the KTHREAD, this is shown in memory below 
21 
It is possible to wrap this KASLR bypass in a single function, where the base address of ntoskrnl.exe is found 
from the pointer into notoskrnl.exe in the same fashion as explained for the bitmap primitive. 
22 
Dynamic Function Location 
In the following sections, it becomes important to locate the address of specific kernel driver functions, 
while this could be done using static offsets from the header, this might not work across patches. A better 
method would be to locate the function address dynamically using the kernel-mode read primitive. 
The read primitives given so far only read out 8 bytes, but both the bitmap and the tagWND primitive can 
be modified to read out any given size buffer. For the bitmap primitive this depends on the size of the 
bitmap, which can be modified allowing for arbitrary reading size. The arbitrary size bitmap read primitive 
is shown below 
The only difference is the modification of the size values and the size of the data buffer to retrieve in the 
final GetBitmapBits call. This one read primitive will dump the entire kernel driver, or the relevant part of it 
into a buffer ready for searching inside user-mode memory. 
The next idea is using a simple hash value of the function to locate it. The hash function used is simply 
adding four QWORDS offset by 4 bytes together. While no proof of collision avoidance will be made, it has 
turned out to be very effective. The final location function is shown below 
23 
Page Table Randomization 
As previously mentioned the most common way of achieving executable kernel memory in Windows 10 is 
by modifying the Page Table Entry of the memory page where the shellcode is located. Prior to Windows 10 
Anniversary Update the Page Table Entry of a given page can be found through the algorithm shown below 
In Windows 10 Anniversary Update and Creators Update the base address value of 0xFFFFF68000000000 
has been randomized. This makes it impossible to simply calculate the Page Table Entry address for a given 
memory page. While the base address has been randomized the kernel must still look up Page Table Entries 
often, so kernel-mode API’s for this must exist. One example of this is MiGetPteAddress in ntoskrnl.exe. 
Opening MiGetPteAddress in Ida Pro shows that the base address is not randomized 
However, looking at it in memory shows the randomized base address 
The idea is to find the address of MiGetPteAddress and read the randomized base address and use that 
instead of the previously static value. The first part can be achieved by leveraging the read primitive and 
locating the function address as described in the previous section. Having found the address of 
MiGetPteAddress, the base address of the Page Table Entries are at an offset of 0x13 bytes. This can be 
implemented as shown below 
24 
Next the address of the Page Table Entry of a given memory page can be found by the original method, only 
using the randomized base address 
This may also be verified directly in memory, as shown in the example below for the memory address 
0xFFFFF78000000000 
If the shellcode is written to offset 0x800 of the KUSER_SHARED_DATA structure, which is still static in 
memory at the address 0xFFFFF78000000000, the updated method can be used to locate the Page Table 
Entry. Then the memory protection can be modified by overwriting the Page Table Entry to remove the NX 
bit, which is the highest bit. 
Execution of the shellcode can be performed with known methods like overwriting the HalDispatchTable 
and then calling the user-mode API NtQueryIntervalProfile 
This technique de-randomizes the Page Tables and brings back the Page Table Entry overwrite technique. 
25 
Executable Memory Allocation 
While modifying the Page Table Entry of an arbitrary memory page containing shellcode works, the method 
from Windows 7 of directly allocating executable kernel memory is neat. This section explains how this is 
still possible to obtain on Windows 10 Creators Update. 
Many kernel pool allocations are performed by the kernel driver function ExAllocatePoolWithTag in 
ntoskrnl.exe. According to MSDN the function takes three arguments, the type of pool, size of the 
allocation and a tag value. 
Just as importantly on success the function returns the address of the new allocation to the caller. While 
NonPagedPoolNX is the new standard pool type for many allocations, the following pool types exist even 
on Windows 10. 
Specifying the value 0 as pool type will force an allocation of pool memory which is readable, writable and 
executable. Calling this function from user-mode can be done in the same way as shellcode memory pages 
are through NtQueryIntervalProfile. Sadly, to reach the overwritten entry in the HalDispatchTable specific 
arguments must be supplied, rendering the call to ExAllocatePoolWithTag invalid. 
Another way of calling ExAllocatePoolWithTag is needed, the technique used by overwriting the 
HalDispatchTable could work for other user-mode functions if different function tables can be found. One 
such function table is gDxgkInterface which is in the kernel driver win32kbase.sys, the start of the function 
table is seen below 
26 
Many functions use this function table, the requirements for the function we need is the following; it needs 
to be callable from user-mode, it must allow at least three user controlled arguments without modifications 
and it must be called rarely by the operating system or background processes to avoid usage after we 
overwrite the function table. 
One function which matches these requirements is the user-mode function NtGdiDdDDICreateAllocation, 
which in dxgkrnl is called DxgkCreateAllocation and seen above at offset 0x68 in the function table. The 
user-mode function is not exportable, but only consists of a system call in win32u.dll. It is possible to 
implement the system call directly when using it, this is shown below 
When the system call is invoked it gets transferred to the kernel driver win32k.sys which dispatches it to 
win32kfull.sys, which in turn dispatches it to win32kbase.sys. In win32kbase.sys the function table 
gDxgkInterface is referenced and a call is made to offset 0x68. The execution flow can be seen below 
All the involved drivers only implement very thin trampolines around the system call. The consequence is 
that no arguments are modified, which was the second requirement for. When performing testing an 
overwrite of the DxgkCreateAllocation function pointer does not cause any unintended problems due to 
additional calls, which was the third and final requirements. 
To use NtGdiDdDDICreateAllocation and the gDxgkInterface function table, the latter must be writable. 
Inspecting the Page Table Entry is seen below 
27 
While the content of the Page Table Entry may be hard to interpret directly, it can be printed according to 
the structure _MMPTE_HARDWARE and shows the function table to be writable 
In principle, all the elements needed are in place, the idea is to overwrite the function pointer 
DxgkCreateAllocation at offset 0x68 in the function table gDxgkInterface with ExAllocatePoolWithTag 
followed by a call to NtGdiDdDDICreateAllocation specifying NonPagedPoolExecute as pool type. The 
remaining practical issue is locating the gDxgkInterface function table. We have several KASLR bypasses to 
locate the base address of ntoskrnl.exe, but so far, no ways to find other drivers. 
The structure PsLoadedModuleList in ntoskrnl.exe contains the base address of all loaded kernel modules, 
thus finding other kernel drivers in memory is possible. The structure of the doubly-link list given by 
PsLoadedModuleList is shown below 
Thus, iterating through the linked list until the correct name in offset 0x60 is found will allow for reading 
the base address at offset 0x30. 
Locating the PsLoadedModuleList structure directly using the previously mentioned algorithm to find 
function addresses does not work since this is not a function, but just a pointer. A lot of functions use the 
structure so it is possible to find the pointer from one of these. 
KeCapturePersistentThreadState in ntoskrnl.exe uses PsLoadedModuleList which can be seen below 
28 
It is possible to use the function finding algorithm to locate KeCapturePersistentThreadState and then 
dereference PsLoadedModuleList, which in turn will give the base address of any loaded kernel module. 
While getting the base address of win32kbase.sys is possible, the problem of locating the function table 
gDxgkInterface is the same as finding the PsLoadedModuleList pointer. A better approach is finding a 
function which uses the function table and then read the address of gDxgkInterface from that. 
One viable function is DrvOcclusionStateChangeNotify in the kernel driver win32kfull.sys, which has the 
disassembly shown below 
From this function pointer, the function table can be found, which allows for overwriting the 
DxgkCreateAllocation function pointer with ExAllocatePoolWithTag. 
29 
Following the pool allocation, the shellcode can be written to it using the kernel-mode write primitive. 
Finally, the gDxgkInterface function table can be overwritten again with the pool address followed by an 
additional call to NtGdiDdDDICreateAllocation. 
The arguments for the NtGdiDdDDICreateAllocation function call is the address of DxgkCreateAllocation 
and its original place in the function table. This allows the shellcode to restore the function pointers in the 
function table, thus preventing any future calls to NtGdiDdDDICreateAllocation crashing the operating 
system.