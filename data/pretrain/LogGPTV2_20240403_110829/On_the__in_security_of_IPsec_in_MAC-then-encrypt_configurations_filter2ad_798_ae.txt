### Introduction

In the context of IPsec, TFC (Traffic Flow Confidentiality) padding is used to ensure that packets do not reveal information about their content through their size. To process a packet of the form oIP–AH–iIP–ULP (outer IP header, Authentication Header, inner IP header, Upper Layer Protocol), it is necessary to remove the TFC padding before submitting the packet to AH processing. If the padding is not removed, the extra bytes will cause the AH MAC (Message Authentication Code) verification to fail. This requires the ESP (Encapsulating Security Payload) implementation at the gateway (GB) to support TFC padding for transport mode ESP and to be able to inspect the AH and iIP length fields to calculate the number of bytes that should remain after TFC padding has been removed. This places greater expectations on the IPsec implementation, though [15, Section 2.7] states that an IPsec implementation SHOULD be capable of this behavior.

### AH Transport + ESP Transport

In this configuration, the format of the IPsec-protected packets is:
```
IP ESPh AH ULP TFC ESPt
```
where only a single IP header is present. This configuration was explicitly ruled out in the previous IPsec architecture [13] and is not supported by some implementations (e.g., OpenSolaris) but is supported by others (e.g., Linux). In this setup, Attack 2 fails because there is no inner IP header to manipulate, and Attack 3 does not work since ESP is in transport mode. For Attack 1 to work, the NH (Next Header) byte in ESPt must have a value of 51, and the attacker must rely on the ESP processing at GB to accurately handle TFC padding. This requires the ESP implementation at GB to support TFC padding for transport mode ESP and the upper layer protocol to include an explicit length field, ruling out the use of TCP in the payload of the carrier packet. Thus, we are restricted to using ICMP or perhaps some kind of UDP packet that always produces a response. Otherwise, the attack works as described previously.

### Experimental Results

Having described how our attacks should operate for an RFC-compliant implementation of the RFCs, we now turn to their experimental validation.

Our experimental setup consists of two desktop machines acting as the stand-alone gateways, a laptop acting as the attacker’s platform, and a 10 Mbit Hub. The gateways run OpenSolaris build 134, while the attacker’s platform runs Linux 2.6. We implemented our attacks in Python 2.6.4 and used Scapy 2.0 to intercept and manipulate IP packets and to re-inject them into the network. We chose OpenSolaris because it can be configured to perform full padding checks on ESP-protected packets as recommended by [15].

In our experiments, the two gateways were configured to protect their communications using AH in transport mode followed by ESP in tunnel mode, as in the example configuration of Section 3.1. We have not tested our attacks on other MAC-then-encrypt configurations, but we see no reason why they should not be successful.

We successfully implemented Attacks 1 and 3 on the aforementioned configuration, with the AH replay protection service both disabled and enabled. In OpenSolaris, when keys are set up manually, replay protection is disabled and cannot be enabled (in conformance with [14]). Thus, we used manual keying for the scenario where replay protection is disabled and enabled automated key exchange using IKE to turn on the replay protection service.

Attack 2 works by generating an ICMP message at the point where the IPsec gateway is about to forward the decrypted packet to the end host in the protected network. However, in OpenSolaris, it is not possible to forward packets that are protected by AH in transport mode, preventing us from testing Attack 2 in our experimental setup. This seems to be a design decision by the OpenSolaris developers, although such configurations are perfectly in line with the IPsec RFCs.

All of our attacks rely on the production of ICMP messages, so one might be concerned about the effects of ICMP rate limitation. However, this is not an issue in practice due to the relatively slow speed at which the ICMP packets are produced. The main complication that arises in practice is distinguishing the desired response packets from other IPsec-protected traffic on the VPN. As a first step, if the attacker can predict the length of the response packet, they can filter out all packets whose length does not match this value, significantly reducing the rate of false positives. If length filtering is not enough or not possible, the attacker can filter based on "causation": assuming no network congestion, a response is expected to be seen almost instantly after the packet that caused it was received by the gateway. With sufficiently high probability, the attacker can expect to observe the response within a short time interval of the packet having a correct ESP trailer being sent. The time interval should be short enough that the probability of a false positive appearing within the interval is low. Thus, the attacker allows a time interval \( \delta t \) between each attack packet. Once the attacker has detected what they suspect to be a response packet, they can confirm this by retesting and checking whether a response is again sent within time \( \delta t \) (this will require the use of a fresh carrier packet whenever replay protection is enabled). This can be repeated multiple times to boost the confidence of the detection procedure. In scenarios with high network traffic levels, the attacks may still be realized at the expense of efficiency. Alternatively, if replay protection is disabled or Attack 3 based on fragmentation is used, the attacker can simply capture the packets of interest and wait for a period of low network traffic to carry out the attack.

In our setup, we had minimal spurious network traffic, and thus basic filtering based on packet lengths was sufficient. The most computationally intensive part of each attack is to extract the rightmost two bytes of the target ciphertext block. Given that we could distinguish a response packet from other traffic accurately enough, we adopted the following strategy to speed up Attack 1: we transmitted all \( 2^{16} \) packets at a rate almost equal to the network's capacity. As soon as a response packet was detected, we replayed the last few packets spaced at a greater interval to pinpoint the exact packet that generated the response. We also followed this approach to extract the rest of the bytes. On a 10 Mbit hub, Attack 1 took on average 70 seconds to recover a 128-bit block of plaintext using a 140-byte carrier packet. It should be noted that if replay protection is enabled, Attack 1 needs 30 fresh packets to recover a block of plaintext in the manner just described. On the other hand, it is possible to sacrifice the attack's time efficiency by transmitting packets at a lower rate such that a packet generating a response can be immediately identified, thereby requiring only 15 fresh packets per 128-bit block of plaintext.

For Attack 3, a similar strategy was adopted. The oracle response is only output after the IP fragment reassembly has timed out. In OpenSolaris, the default timeout value is 15 seconds. To match a response to the packet that generated it, we keep a list of the time instants at which each packet was sent. Then, if a response is seen at some time \( t \), we search our list for packets that were sent near to the time \( t - t_{\text{timeout}} \). This scheme was combined with the method described above where packets are initially sent in a burst, and then two replies are required to accurately locate the packet generating the response. In our experiments, we could locate the packet to lie within a range of roughly 20 packets with the first response, and then replay each packet at intervals of 0.2 seconds and use the second response to locate the desired packet exactly. Following this approach with our experimental setup, Attack 3 recovered a 128-bit block of plaintext in roughly 10 minutes.

### Conclusions

In this paper, we have demonstrated attacks against all MAC-then-encrypt configurations of IPsec, showing that such configurations should be avoided in IPsec deployments. We have not found any attacks against encrypt-then-MAC configurations of IPsec.

Support for AH is no longer required in IPsec implementations "because experience has shown that there are very few contexts in which ESP cannot provide the requisite security services" [13]. Our work shows that the only configurations where ESP alone cannot easily mimic what can be done using AH and ESP in combination, namely those using AH followed by ESP, are actually insecure. So not only is AH not very useful, it could actually be considered harmful. The removal of AH from the IPsec standards is already underway: support for AH is not required in the current IPsec architectural RFC [13], whereas it was in the previous version [10]. Our results should provide motivation to accelerate this process.

Our attacks demonstrate the dangers inherent in exposing cryptographic flexibility to users. IPsec, in particular, places a significant burden on network administrators, requiring them to have sufficient cryptographic expertise to select secure configurations. Nothing prevents curious administrators from going "off piste" or protects them from bad advice, such as that found in [6, 7, 21]. We hope that the attacks given here will illustrate some of the dangers in an accessible form.

Our view of IPsec echoes that expressed in [6]: IPsec, in attempting to be "all things to all men," ends up compromising on security. It would be helpful to standardize IPsec profiles addressing particular application scenarios rather than allowing a set of components that can be combined and configured in different ways to achieve arbitrary goals. This is because predicting the combined security of distinct cryptographic primitives is quite difficult and requires thorough analysis. While theoretical cryptography has much that is useful to say on this subject [2, 16], it currently falls short of being able to give truly meaningful security guarantees for cryptographic primitives as they are deployed in real protocols. Recent work [19, 20] has started to address this gap, but there is much still to be done to bridge theory and practice in this area.

### References

[1] S. Bellovin, “Problem Areas for the IP Security Protocols.” In Proceedings of the Sixth Usenix Unix Security Symposium, pp. 1–16, San Jose, CA, July 1996.
[2] M. Bellare and C. Namprempre, “Authenticated Encryption: Relations Among Notions and Analysis of the Generic Composition Paradigm.” In T. Okamoto, ed., Asiacrypt 2000, LNCS Vol. 1976, Springer, 2000, pp. 531-545.
[3] R. Braden, editor, “Requirements for Internet Hosts – Communication Layers”, RFC 1122, Oct. 1989.
[4] B. Canvel, A.P. Hiltgen, S. Vaudenay and M. Vuagnoux, “Password Interception in a SSL/TLS Channel.” In D. Boneh (ed.), CRYPTO 2003, LNCS Vol. 2729, Springer, 2003, pp. 583-599.
[5] J.P. Degabriele and K.G. Paterson, “Attacking the IPsec Standards in Encryption-only Configurations.” In IEEE Symposium on Privacy and Security, IEEE Computer Society, 2007, pp. 335-349.
[6] N. Ferguson and B. Schneier, “A Cryptographic Evaluation of IPsec”, 2003. Available from http://www.schneier.com/paper-ipsec.pdf
[7] N. Ferguson, B. Schneier and T. Kohno. Cryptography Engineering. John Wiley & Sons, 2010.
[8] R. Housely, “Using Advanced Encryption Standard (AES) Counter Mode With IPsec Encapsulating Security Payload (ESP)”, RFC 3686, Jan. 2004.
[9] C. Kaufman, editor, “Internet Key Exchange (IKEv2) Protocol”, RFC 4306, Dec. 2005.
[10] S. Kent and R. Atkinson, “Security Architecture for the Internet Protocol”, RFC 2401, Nov. 1998.
[11] S. Kent and R. Atkinson, “IP Authentication Header”, RFC 2402 (obsoletes RFC 1826), Nov. 1998.
[12] S. Kent and R. Atkinson, “IP Encapsulating Security Payload (ESP)”, RFC 2406, Nov. 1998.
[13] S. Kent and K. Seo, “Security Architecture for the Internet Protocol”, RFC 4301 (obsoletes RFC 2401), Dec. 2005.
[14] S. Kent, “IP Authentication Header”, RFC 4302 (obsoletes RFC 2402), Dec. 2005.
[15] S. Kent, “IP Encapsulating Security Payload (ESP)”, RFC 4303 (obsoletes RFC 2406), Dec. 2005.
[16] H. Krawczyk. The Order of Encryption and Authentication for Protecting Communications (or: How Secure is SSL?). In J. Kilian, ed., CRYPTO 2001, LNCS Vol. 2139, Springer, 2001, pp. 310-331.
[17] V. Manral, “Cryptographic Algorithm Implementation Requirements for Encapsulating Security Payload (ESP) and Authentication Header (AH)”, RFC 4835, April 2007.
[18] K.G. Paterson and A.K.L. Yau, “Cryptography in Theory and Practice: The Case of Encryption in IPsec.” In S. Vaudenay (ed.), EUROCRYPT 2006, LNCS Vol. 4004, Springer, 2006, pp. 12-29.
[19] K.G. Paterson and G.J. Watson, “Plaintext-Dependent Decryption: A Formal Security Treatment of SSH-CTR.” In H. Gilbert (ed.), EUROCRYPT 2010, LNCS Vol. 6110, Springer 2010, pp. 345-361. Full version available from http://eprint.iacr.org/2010/095.
[20] P. Rogaway and T. Stegers, “Authentication without Elision: Partially Specified Protocols, Associated Data, and Cryptographic Models Described by Code.” In CSF 2009, IEEE Computer Society, pp. 26-39.
[21] W. Stallings. Network Security Essentials: Applications and Standards, 3rd edition. Pearson Education, 2008.
[22] S. Vaudenay, “Security Flaws Induced by CBC Padding – Applications to SSL, IPSEC, WTLS...” In L.R. Knudsen (ed.), EUROCRYPT 2002, LNCS Vol. 2332, Springer, 2002, pp. 534-545.
[23] D. Wagner and B. Schneier, “Analysis of the SSL 3.0 Protocol.” In The Second USENIX Workshop on Electronic Commerce, USENIX press, 1996.