i as being TFC padding, and to
be able to remove these bytes before submitting a packet of
the form oIP–AH–iIP–ULP to AH processing. For, other-
wise, the packet would contain extra bytes and these would
cause the AH MAC veriﬁcation to fail. This requires the
ESP implementation at GB to support TFC padding for
transport mode ESP, and to know how to inspect the AH
and iIP length ﬁelds to calculate how many bytes of data
should remain after TFC padding has been removed. This
places greater expectations on the IPsec implementation,
though [15, Section 2.7] states that an IPsec implementa-
tion SHOULD be capable of this behaviour.
AH Transport + ESP Transport.
Here the format of the IPsec-protected packets is:
IP ESPh AH ULP TFC ESPt
where now only a single IP header is present. This conﬁgu-
ration was explicitly ruled out in the previous IPsec architec-
ture [13], and so is not supported by some implementations
(e.g. OpenSolaris) but is by others (e.g. Linux). Here Attack
2 fails because there is no inner IP header to manipulate, and
Attack 3 does not work, since ESP is in transport mode.
Attack 1 requires some modiﬁcation in order to work. As
with the previous attack, the NH byte in ESPt is now ex-
pected to have value 51, and the attacker must rely on ESP
processing at GB to accurately handle TFC padding. This
requires the ESP implementation at GB to support TFC
padding for transport mode ESP and the upper layer proto-
col to include an explicit length ﬁeld, ruling out the use of
TCP in the payload of the carrier packet. This means that
we are restricted to using ICMP (or perhaps some kind of
UDP packet that always produces a response). Otherwise,
the attack works as described previously.
4. EXPERIMENTAL RESULTS
Having described how our attacks should operate for an
RFC-compliant implementation of the RFCs, we now turn
to their experimental validation.
Our experimental set-up is composed of two desktop ma-
chines acting as the two stand-alone gateways, a laptop act-
ing as the attacker’s platform, and a 10 Mbit Hub. The
gateways run OpenSolaris build 134, whereas the attacker’s
platform runs Linux 2.6. We implemented our attacks in
Python 2.6.4 and used Scapy 2.0 to intercept and manipu-
late IP packets and to re-inject them into the network. We
decided to use OpenSolaris because it can be conﬁgured to
perform full padding checks on ESP-protected packets as
recommended by [15].
In our experiments, the two gate-
ways were conﬁgured to protect their communications using
AH in transport mode followed by ESP in tunnel mode, as in
the example conﬁguration of Section 3.1. We have not tested
our attacks on the other MAC-then-encrypt conﬁgurations,
but we see no reason why they should not be successful.
We successfully implemented Attacks 1 and 3 on the afore-
mentioned conﬁguration, with the AH replay protection ser-
vice both disabled and enabled. In OpenSolaris, when keys
are set up manually, then replay protection is disabled and
there is no way of enabling it (in conformance with [14]).
Thus we used manual keying for the scenario where replay
protection is disabled, and enabled automated key exchange
using IKE in order to turn on the replay protection service.
Attack 2 works by generating an ICMP message at the point
where the IPsec gateway is about to forward the decrypted
packet to the end host in the protected network. As men-
tioned above, this attack works only when AH is applied in
transport mode followed by ESP in tunnel mode. However
we discovered that in OpenSolaris, it is not possible to for-
ward packets that are protected by AH in transport mode,
502preventing us from testing Attack 2 in our experimental set-
up. This seems to be a design decision by the OpenSolaris
developers: such conﬁgurations are perfectly in line with the
IPsec RFCs.
All of our attacks rely on the production of ICMP mes-
sages, so one might be concerned about the eﬀects of ICMP
rate limitation. However, this is not an issue in practice be-
cause of the relatively slow speed at which the ICMP packets
are produced. In fact the main complication that arises in
practice for our attacks is the problem of distinguishing the
desired response packets from other IPsec-protected traﬃc
on the VPN. This of course depends on the amount of traﬃc
present on the network. As a ﬁrst step, if the attacker is able
to predict the length of the response packet, then he can ﬁl-
ter out all packets whose length does not match this value,
and thereby signiﬁcantly reduce the rate of false positives.
If length ﬁltering is not enough or not possible, then one can
ﬁlter on the basis of “causation”: assuming no network con-
gestion, a response is expected to be seen almost instantly
after the packet that caused it was received by the gateway.
That is, with suﬃciently high probability, the attacker can
expect to observe the response within a short time interval
of the packet having a correct ESP trailer being sent. The
time interval should be short enough that the probability of
a false positive appearing within the interval is low. Thus
the attacker allows a time interval δt between each attack
packet that he sends. Once the attacker has detected what
he suspects to be a response packet, he can conﬁrm that
this was indeed the case by retesting and checking whether
a response is again sent within time δt (this will require the
use of a fresh carrier packet whenever replay protection is
enabled). This can be repeated multiple times in order to
boost the conﬁdence of the detection procedure. Thus in
scenarios with high network traﬃc levels, the attacks may
still be realised at the expense of eﬃciency. Alternatively, if
replay protection is disabled or Attack 3 based on fragmen-
tation is used, the attacker can simply capture the packets
that are of interest to him and wait for a period of low net-
work traﬃc in order to carry out his attack.
In our set-up we had minimal spurious network traﬃc
and thus basic ﬁltering based on packet lengths was suﬃ-
cient. The most computationally intense part of each attack
is to extract the rightmost two bytes of the target ciphertext
block. Given that we could distinguish a response packet
from other traﬃc accurately enough, we adopted the follow-
ing strategy in order to speed up the Attack 1: we transmit-
ted all 216 packets at a rate almost equal to the network’s
capacity. As soon as a response packet was detected, we
replayed the last few packets spaced at a greater interval,
in order to pinpoint the exact packet which generated the
response. We also followed this approach in order to extract
the rest of the bytes. On a 10Mbit hub, Attack 1 took on
average 70 seconds to recover a 128-bit block of plaintext
using a 140-byte carrier packet. It should be noted that if
replay protection is enabled, then Attack 1 needs 30 fresh
packets to recover a block of plaintext in the manner just
described. On the other hand it is possible to sacriﬁce the
attack’s time eﬃciency by transmitting packets at a lower
rate such that a packet generating a response can be im-
mediately identiﬁed, thereby requiring only 15 fresh packets
per 128-bit block of plaintext.
For Attack 3, a similar strategy was adopted. Now the or-
acle response is only output after the IP fragment reassembly
has timed out. In OpenSolaris the default time-out value is
15 seconds. In order to match a response to the packet that
generated it, we keep a list of the time instants at which
each packet was sent. Then if a response is seen at some
time t we search our list for packets that were sent near to
the time t − ttime-out. This scheme was combined with the
method described above where packets are initially sent in a
burst, and then two replies are required to accurately locate
the packet generating the response. In our experiments, we
could locate the packet to lie within a range of roughly 20
packets with the ﬁrst response, and then replay each packet
at intervals of 0.2 seconds and use the second response to
locate the desired packet exactly. Following this approach
with our experimental set-up Attack 3 recovered a 128-bit
block of plaintext in roughly 10 minutes.
5. CONCLUSIONS
In this paper, we have demonstrated attacks against all
MAC-then-encrypt conﬁgurations of IPsec. These show that
such conﬁgurations should be avoided in IPsec deployments.
We have not found any attacks against encrypt-then-MAC
conﬁgurations of IPsec.
Support for AH is no longer required in IPsec implemen-
tations “because experience has shown that there are very few
contexts in which ESP cannot provide the requisite security
services” [13]. Our work shows that the only conﬁgurations
where ESP alone cannot easily mimic what can be done us-
ing AH and ESP in combination, namely those using AH
followed by ESP, are actually insecure. So not only is AH
not very useful, it could actually be considered harmful. The
removal of AH from the IPsec standards is already under
way: support for AH is not required in the current IPsec ar-
chitectural RFC [13], whereas it was in the previous version
[10]. Our results should provide motivation to accelerate
this process.
Our attacks demonstrate the dangers inherent in expos-
ing cryptographic ﬂexibility to users.
IPsec in particular
places a signiﬁcant burden on network administrators, re-
quiring them to have suﬃcient cryptographic expertise in
order to select secure conﬁgurations. Nothing prevents cu-
rious administrators from going “oﬀ piste” or protects them
from bad advice, such as that to be found in [6, 7, 21] for
example. We hope that the attacks given here will illustrate
some of the dangers in an accessible form.
Our view of IPsec echoes that expressed in [6]: IPsec, in
attempting to be “all things to all men” ends up compromis-
ing on security. It would be helpful to standardise IPsec pro-
ﬁles addressing particular application scenarios rather than
allowing a set of components that can be combined and con-
ﬁgured in diﬀerent ways to achieve arbitrary goals. This is
because predicting the combined security of distinct cryp-
tographic primitives is quite diﬃcult and requires thorough
analysis. While theoretical cryptography has much that is
useful to say on this subject [2, 16], it currently falls short of
being able to give truly meaningful security guarantees for
cryptographic primitives as they are deployed in real proto-
cols. Recent work [19, 20] has started to address this gap,
but there is much still to be done to bridge theory and prac-
tice in this area.
5036. REFERENCES
[1] S. Bellovin, “Problem Areas for the IP Security
Protocols.” In Proceedings of the Sixth Usenix Unix
Security Symposium, pp. 1–16, San Jose, CA, July
1996.
[2] M. Bellare and C. Namprempre, “Authenticated
Encryption: Relations Among Notions and Analysis of
the Generic Composition Paradigm.” In T. Okamoto,
ed., Asiacrypt 2000, LNCS Vol. 1976, Springer, 2000,
pp. 531-545.
[3] R. Braden, editor, “Requirements for Internet Hosts –
Communication Layers”, RFC 1122, Oct. 1989.
[4] B. Canvel, A.P. Hiltgen, S. Vaudenay and
M. Vuagnoux, “Password Interception in a SSL/TLS
Channel.” In D. Boneh (ed.), CRYPTO 2003, LNCS
Vol. 2729, Springer, 2003, pp. 583-599.
[5] J.P. Degabriele and K.G. Paterson, “Attacking the
IPsec Standards in Encryption-only Conﬁgurations.”
In IEEE Symposium on Privacy and Security, IEEE
Computer Society, 2007, pp. 335-349.
[6] N. Ferguson and B. Schneier, “A Cryptographic
Evaluation of IPsec”, 2003. Available from
http://www.schneier.com/paper-ipsec.pdf
[7] N. Ferguson, B. Schneier and T. Kohno. Cryptography
Engineering. John Wiley & Sons, 2010.
[8] R. Housely, “Using Advanced Encryption Standard
(AES) Counter Mode With IPsec Encapsulating
Security Payload (ESP)”, RFC 3686, Jan. 2004.
[9] C. Kaufman, editor, “Internet Key Exchange (IKEv2)
Protocol”, RFC 4306, Dec. 2005.
[10] S. Kent and R. Atkinson, “Security Architecture for
the Internet Protocol”, RFC 2401, Nov. 1998.
[11] S. Kent and R. Atkinson, “IP Authentication Header”,
RFC 2402 (obsoletes RFC 1826), Nov. 1998.
[12] S. Kent and R. Atkinson, “IP Encapsulating Security
Payload (ESP)”, RFC 2406, Nov. 1998.
[13] S. Kent and K. Seo, “Security Architecture for the
Internet Protocol”, RFC 4301 (obsoletes RFC 2401),
Dec. 2005.
[14] S. Kent, “IP Authentication Header”, RFC 4302
(obsoletes RFC 2402), Dec. 2005.
[15] S. Kent, “IP Encapsulating Security Payload (ESP)”,
RFC 4303 (obsoletes RFC 2406), Dec. 2005.
[16] H. Krawczyk. The Order of Encryption and
Authentication for Protecting Communications (or:
How Secure is SSL?). In J. Kilian, ed., CRYPTO
2001, LNCS Vol. 2139, Springer, 2001, pp. 310-331.
[17] V. Manral, “Cryptographic Algorithm Implementation
Requirements for Encapsulating Security Payload
(ESP) and Authentication Header (AH)”, RFC 4835,
April 2007.
[18] K.G. Paterson and A.K.L. Yau, “Cryptography in
Theory and Practice: The Case of Encryption in
IPsec.” In S. Vaudenay (ed.), EUROCRYPT 2006,
LNCS Vol. 4004, Springer, 2006, pp. 12-29.
[19] K.G. Paterson and G.J. Watson,
“Plaintext-Dependent Decryption: A Formal Security
Treatment of SSH-CTR.” In H. Gilbert (ed.),
EUROCRYPT 2010, LNCS Vol. 6110, Springer 2010,
pp. 345-361. Full version available from
http://eprint.iacr.org/2010/095.
[20] P. Rogaway and T. Stegers, “Authentication without
Elision: Partially Speciﬁed Protocols, Associated
Data, and Cryptographic Models Described by Code.”
In CSF 2009, IEEE Computer Society, pp. 26-39.
[21] W. Stallings. Network Security Essentials:
Applications and Standards, 3rd edition. Pearson
Education, 2008.
[22] S. Vaudenay, “Security Flaws Induced by CBC
Padding – Applications to SSL, IPSEC, WTLS...” In
L.R. Knudsen (ed.), EUROCRYPT 2002, LNCS Vol.
2332, Springer, 2002, pp. 534-545.
[23] D. Wagner and B. Schneier, “Analysis of the SSL 3.0
Protocol.” In The Second USENIX Workshop on
Electronic Commerce, USENIX press, 1996.
504