然后使用CRT计算满足和的唯一值.
得到的满足等式。关键点在于虽然和很小，但是的值可以很大，大约在的数量级上。因此，定理2的攻击不再适用。我们注意到，如果给定了，则存在一种攻击能够使攻击者能够在时间内对进行因子分解。因此，和不能太小。
我们不知道这些方法中是否都安全。我们所知道的是，Wiener攻击对它们无效。最近由Boneh和Durfee改进的定理2证明了只要，攻击者就可以从中有效地算出。这些结果表明Wiener的界限并不固定。正确的界限可能是。截至撰写本文时，还是一个尚未解决的问题。
**开放性问题2**
令，，如果Marvin知道和及关系，他能有效算出吗？
### 4 低公钥指数
为了减少加密或签名验证时间，通常会使用一个小的公钥指数。的最小可能值为3，但为防止某些攻击，建议使用。当使用值时，签名验证需要17次乘法，而使用随机的时则需要大约1000次乘法。与上一节的攻击不同，当使用一个小时，针对的攻击不只是攻破而已。
#### 4.1 Coppersmith定理
针对RSA低公钥指数最有力的攻击基于Copper-smith的一个定理，Coppersmith定理有很多应用，这里我们只讨论其中的一些应用，证明使用LLL格基约化算法如下。
**定理3（Coppersmith）**
令为一个整数，是次的一元多项式，设其中，在给定之后Marvin能够有效找到所有满足的整数，运行时间由在维数且的格上运行LLL算法所需的时间决定。
该定理为有效地求模的所有小于的根提供了一种算法，当越小，算法的运行时间越短。这个定理的强大之处在于它能够找到多项式的小根。当模数为素数时，就目前而言，找不到比使用Coppersmith定理更好的求根算法了，没有理由不使用Coppersmith定理。
我们概述了Coppersmith定理证明背后的主要思想，我们采用由Howgrave-Graham提出的简化方法，给定一个多项式，定义，证明依赖于下面的观察。
**引理4**
令为次多项式，为正整数，假设，如果满足，那么成立。
**证明** 从Schwarz不等式观察到：
因为,我们得出结论。
引理指出，如果是一个低范数多项式，则的所有小根也是在整数上的根。引理表明，要找到的一个小根，我们需要寻找另一个与模有相同根的低范数多项式，这样就能容易找到在整数上的根。为此，我们可以寻找一个多项式，使得具有低范数，即范数小于。这相当于寻找具有低范数多项式的整数线性组合。不过，大多数情况下，并不存在具有足够小的范数的非平凡线性组合。
Coppersmith找到了解决这个问题的窍门：如果成立，那么对于任意则有。更一般地，定义以下多项式：
对于一些预定义的，则是模的一个根，其中和。要使用引理4，我们必须找到多项式的一个整数线性组合，使得的范数小于
(回想一下是满足的上界)。由于范数（是而不是）的松弛上界，我们可以证明，对于足够大的，总是存在一个线性组合满足所要求的界。一旦被找到，引理4就意味着它有作为整数的根,因此,可以很容易地找到。
如何有效地找到还有待证明，要做到这一点，我们必须说明一些关于格的基本事实。
设是线性独立的向量。由构成的(满秩)格是的所有整数线性组合的集合。的行列式定义为方阵的行列式，它的行列式是向量。
在我们的例子中，我们把多项式看作向量，并研究了它们所构成的格。设，，则格的维数。例如，当是二次一元多项式且时，得到的格由以下矩阵的行构成：
![
](https://images.seebug.org/content/images/2018/10/42118568-22eb-4150-95d4-12e28aafc510.png-w331s)
元对应于我们忽略其值的多项式的系数，所有空元为零。由于矩阵是三角形的，它的行列式是对角线上元素的乘积(如上所示)，我们的目标是在这个格中找到短向量。
Hermite的一个经典结论表明：任意维数为的格包含一个非零向量，它的范数满足，其中是只依赖于的常数。Hermite的界可以用来证明，对于足够大的，我们的格包含需求小于的范数向量。问题是我们能否有效地在中构造长度小于Hermite界的短向量。LLL算法是一种有效的算法，恰好可以做到。
**事实5（LLL）**
设是由所构成的格。当作为输入时，LLL算法输出一个向量满足：
LLL算法的运行时间是输入长度的四分之一。
LLL算法（以其发明者L. Lovasz、A. Lenstra和H. Lenstra
Jr的名字命名）在计算数论和密码学中有许多应用。它在1982年的发现为整数上多项式的因式分解提供了一种有效的算法，更广泛地说，为数环上的多项式的因式分解提供了一种有效的算法。LLL算法经常被用来攻击各种密码系统，例如，许多基于"背包问题"的密码系统都是使用LLL算法破解的。
利用LLL算法，我们可以完成Coppersmith定理的证明。为了保证LLL算法产生的向量满足引理4的界，我们需要满足：
其中是的维数。常规计算表明，对于足够大的，能满足约束条件。实际上，当时，取和就足够了。因此，运行时间主要由在维数为的格上运行LLL算法所决定。
一个自然而然的问题，Coppersmith定理能否应用于二元和多元多项式。如果有根且有适当的界，Marvin能有效地找到吗？尽管相同的技术似乎适用于某些二元多项式，但目前还是一个有待证明的开放性问题。随着越来越多的结果依赖于Coppersmith定理的二元扩张，所以严密的算法将会非常有用。
**开放性问题3**
找出Coppersmith定理可以推广到二元多项式的一般条件。
#### 4.2 Hastad广播攻击
作为Coppersmith定理第一个应用，我们对由Hastad提出的旧攻击进行了改进。假设Bob希望将加密消息发送给多方。每一方都有自己的RSA密钥。我们假定比所有都小。Bob为了发送，天真地使用每个公共密钥对其进行加密，并将第个密文发送给。攻击者Marvin可以窃听Bob对外的连接，并收集传输的个密文。
为了简单起见，假设所有公钥指数为3。一个简单的论证表明，当时，Marvin可以计算出。实际上，Marvin得到，其中：
对于所有的，我们可以假设，否则Marvin可以因式分解一些。因此，将中国剩余定理(CRT)应用于，给出的满足。由于小于所有的，我们有，那么在整数上成立，因此，Marvin可以通过计算的实数立方根来得到。更一般的情况是，如果所有的公钥指数都等于，则只要，Marvin就可以计算出。不过这种攻击只有使用较小的值时才是可行的。
Hastad提出了一种更强的攻击方法。为了抵御Hastad的攻击，考虑一下对上述攻击做一下天真防御。Bob可能在加密之前"填充"消息，而不是广播加密的。例如，如果是位长的，Bob可以将发送给。由于Marvin获得了不同消息的加密，他无法发起攻击。然而，Hastad证明了这种线性填充是不安全的，事实上，他证明了在加密之前对消息应用任何固定多项式都不能阻止攻击。
假设对于每个参与者，Bob有一个固定的公用多项式。为了广播消息，Bob将的加密发送给。Marvin通过窃听知道了，其中。Hastad表明，如果有足够的参与方，Marvin可以从所有的密文中计算出明文。下面的定理是Hastad原始结论的一个更强的版本。
**定理6 (Hastad)** 设是成对的相对素数，集合。设是个次多项式。假设存在唯一的满足：
假设，给定，我们可以有效地找到的。
**证明**
令，我们假定所有的都是一元的。(实际上，对于某些，的首项系数在中是不可逆的，那么的因式分解就会显现出来。通过将每个乘以的适当幂，假定它们都有次。构造多项式：
其中是整数，被称为中国剩余系数。那么一定是一元的，因为它首项模了所有的，且次数为。此外，我们还知道。定理6现在便可由定理3推导而来，因为。
该定理表明，如果提供了足够多的方程，可以有效地求解以相对素数复合模的一元方程组。令，我们可以知道，当参与方数至少为时，Marvin可以从给定的密文中计算出，其中是在所有上的最大值。特别地，如果所有的都等于，并且Bob发送线性相关的消息，那么Marvin只要就可以算出明文。
Hastad的原始定理比上述定理更弱。与次多项式不同，Hastad定理需要次多项式。Hastad定理的证明类似于上一节中提到的Coppersmith定理证明。由于Hastad定理没有在格中使用的幂，从而得到了一个较弱的界。
总结这一节，我们注意到，要正确地防御上述广播攻击，必须使用随机填充方法，而不是使用固定填充方法。
#### 4.3 Franklin-Reiter相关消息攻击
当Bob用相同的模数发送与Alice相关的加密消息时，Franklin和Reiter发现了一种聪明的攻击。是爱丽丝的公钥，假设是两个不同的消息，对于某些已知的多项式，满足。为了将和发送给Alice，Bob可能会天真地对消息进行加密，并传输得到的密文。我们通过证明可以知道，在给定的情况下，Marvin可以很容易地计算出。虽然攻击对任意小都有效，但为了简化证明，我们给出了的引理。
**引理7(FR)**
令，为RSA公钥。设对于的线性多项式满足。然后，给定，Marvin可以在的平方时间内计算出。
**证明**
为了保证这部分证明的一般性，我们使用任意来表示它（而不是限制为）。由于，我们知道是多项式的根。同样，也是的根。线性因子是两个多项式的除法。因此，Marvin可以使用欧几里德算法来计算和的最大公约数(Greatest
Common Divisor, GCD)。如果GCD是线性的，则可以找到。GCD可以在和的平方时间内算出。
我们证明了当时，GCD一定是线性的。多项式因子将和都模成一个线性因子和一个不可约二次因子(因为，所以在中只有一个根)。因为不能整除，所以GCD一定是线性的。对于情况，GCD几乎总是线性的。然而，对于一些罕见的和，有可能得到一个非线性的GCD，在这种情况下攻击会失败。
对于情况，攻击所需时间是的平方时间。因此，只有在使用小的公钥指数时才能应用这种攻击。对于大型电子计算机来说，计算GCD的工作令人望而却步。一个有趣的问题(尽管可能很难)，为任意的设计这样的攻击，尤其是能否在的多项式时间中找到上述和的GCD？
#### 4.4 Coppersmith短填充攻击
Franklin-Reiter的攻击可能看起来有点人为。毕竟，为什么Bob要给Alice发送相关消息的加密呢？Coppersmith加强了攻击，并证明了一个关于填充攻击的重要的结论。