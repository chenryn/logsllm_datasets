}
Figure 9: Measuring Array.push timings
Attack Methodology. We begin by measuring the timings
of Array.push using the code presented in Figure 9. We start
with an empty array array (Line 1). We then append data to
the end of the array using the JavaScript Array.push method
(Line 6). On every such element addition we measure the time
taken to add an element (Lines 5 and 7). While most of these
additions are fast, at the point where the memory allocated for
the current size of array is exhausted, V8 performs additional
work by allocating new memory using Equation 1 and copying
the old content to the newly-allocated space.
Figure 10: Push timings with native Chrome (top), and with
Chrome Zero at High level (bottom).
Figure 10 shows the insertion times for elements, using both
a high resolution timer (top) and Chrome Zero’s fuzzy timer
(bottom). As can be seen, some array insertions are slower
than others. We verify that these additional time costs hap-
pened at a point where the buffer allocated by V8 to support
the array array was exhausted, forcing V8 to allocate a new
memory space using using Equation 1.
Observing Figure 10, the time required to handle the ele-
ment addition at the point of buffer exhaustion increases as
the size of the array grows. This is expected as more elements
need to be copied by V8 as the buffer grows. However, as the
number of elements added to the array is attacker-controlled,
we can make Array.push take an arbitrary amount of time.
We exploit this property to mount an attack against Chrome
Zero’s Buffer ASLR policy despite Chrome Zero’s attempts
at reducing the resolution of JavaScript timers. More specif-
ically, after a sufﬁcient number of iterations of the loop in
Line 4, the time taken to handle the re-allocation of array
during the insertion of an additional element in Line 6 be-
comes visible despite Chrome Zero’s low resolution timer.
To deduce the buffer’s offset generated by Chrome Zero, we
apply Chrome Zero’s buffer ASLR policy to Equation 1 to
obtain the following equation.
new_size +offset = (size +offset) + (size +offset) (cid:29) 1 +16.
(2)
Observing the spikes in Figure 10, an attacker can detect when
the memory of array is exhausted. From that, to recover the
value of offset, we rearrange Equation 2 as
offset = 2× new_size− 3× size− 2× 16,
(3)
where size and new_size are the size’s of array before and
after resizing. Finally, to detect resizing events, an attacker
can observe spikes in Figure 10. Thus, Chrome Zero’s buffer
ASLR policy can be defeated using two sequential resizing
events and applying Equation 3 to solve for offset.
5.5 Attacking Chrome Zero
We now present the classiﬁcation results of the attacks de-
scribed in Section 3 across different Chrome Zero policies,
starting with the closed-world scenario. Table 6 summarizes
the accuracy of our technique, using the Intel i5-3470 setup
outlines in Section 3.1.
Cache Occupancy and Sweep Counting. As we can see,
for the basic cache occupancy attack, Chrome Zero policies
have varying impact on the attack accuracy. Low has some
impact, but the accuracy is still high. Medium almost com-
pletely blocks the attack, with the accuracy being slightly
more than the base rate. Surprisingly, High is less effective
than the two lower policy levels, possibly because of its sim-
pler code design, resulting only in a slight decrease in the
accuracy compared to no protection at all. For the sweep
counting attack, we see that the accuracy is lower than that
of the basic cache occupancy channel. However, the Medium
policy no longer breaks the attack. Furthermore, while lower
than that of the cache occupancy attack, the accuracy is still
signiﬁcantly higher than the base rate. Finally, because these
attacks require Worker threads, which are blocked in Paranoid,
they both fail in this policy.
USENIX Association
30th USENIX Security Symposium    2875
Attack Technique
Cache Occupancy
Sweep Counting
DNS Racing
String and Sock
CSS Prime+Probe
Temporal
Resolution
2.9 ms
100.0 ms
20.3 ms
1.5 ms
2.8 ms
Top-1 Accuracy (%)
Top-5 Accuracy (%)
None
Low Medium High
Paranoid
None
Low Medium High
Paranoid
71.1
24.1
20.9
51.3
87.5
45.8
50.8
72.0
(with the NoScript extension) 50.1
81.8
60.1
37.2
58.4
2.2
32.2
61.1
46.2
N/A
N/A
16.2
59.9
87.4
50.1
48.9
80.0
97.0
74.3
78.5
90.6
(with the NoScript extension) 78.6
6.1
59.0
86.0
75.9
96.5
88.3
67.7
85.3
N/A
N/A
40.1
82.8
Table 6: Closed-world accuracy (percent) with different API restriction levels (Intel i5-3470).
DNS Racing. The DNS Racing technique achieves a mod-
erate accuracy in the range 20% to 61%. As expected for a
technique that requires neither timers nor threads, the attack
also works with Paranoid policy.
String and Sock. The results with the String and Sock tend
to be better than DNS Racing. In fact, the results tend to only
be slightly inferior to those of the cache occupancy attack,
despite not requiring timers, arrays, or threads. We further
observe that because the attack uses no protected API, the
various Chrome Zero policies have only a marginal effect on
attack success.
CSS Prime+Probe. As mentioned in Section 3.4, our CSS
Prime+Probe technique does not require JavaScript and is ef-
fective even if the attacker’s website is banned from executing
any JavaScript code (e.g., due to the NoScript extension [51]).
In particular, Chrome Zero’s focus on JavaScript does not
effect our CSS Prime+Probe technique, leaving CSS Prime+
Probe completely unmitigated.
Discussion. Examining the results in Table 6, we see that
restricting browser APIs such as threads, timers, and array
access can thwart the standard Cache Occupancy and Sweep
Counting attacks, and can signiﬁcantly degrade the effective-
ness of the DNS Racing attack. Nevertheless, the two remain-
ing attacks, String and Sock and CSS Prime+Probe, are not
affected by this browser-based countermeasure, since they do
not use any API which is receiving protection. While there is
some variation in accuracy between the different protection
modes for String and Sock, this is likely due to the usability
and site loading side-effects related to our fortiﬁed version of
Chrome Zero, and not due to any intrinsic protection offered
the API limiting approach. We thus argue that preventing side
channels in today’s browsers using API modiﬁcations is prac-
tically impossible. Properly preventing leakage would require
a more systematic approach which considers the sources of
leakage, and not merely the means for measuring it.
6 Attacking Hardened Browsers
Having established the feasibility of mounting cache side
channel attacks while only having limited (or no) access to
the JavaScript API, in this section we proceed to demonstrate
the effectiveness of our techniques on two privacy enhanced
browsers: Tor [71] and DeterFox [14].
6.1 Attacking the Tor Browser
The Tor Browser [71] is a highly-modiﬁed version of Firefox,
designed to offer a high level of privacy even at the cost of
usability and performance. At a high level, the Tor Browser
combines two elements to achieve a higher level of protection
compared to other browsers. First, it hides the user’s browsing
habits from network adversaries by using the Tor network as
an underlying transport layer. Second, it provides a highly
restrictive browser conﬁguration, designed to limit or disable
convenience features that may have a security impact. In the
context of side channel attacks, the Tor Browser limits the
resolution of the timer API to only 100 milliseconds.
In this section we evaluate our attack techniques from
within the Tor Browser and demonstrate that they are pos-
sible even within this restricted environment. We note that
Shusterman et al. [69] have already demonstrated the Sweep
Counting attack in the Tor Browser. We extends that result,
demonstrating that making the environment more restrictive
by disabling JavaScript feature does not guarantee protection.
Negative Result: DNS Racing and CSS Prime+Probe. We
begin with a negative result, that the CSS Prime+Probe attack
we designed is not effective in the Tor Browser. The cause is
that for security reasons, the Tor Browser does not directly
resolve DNS requests. Instead, it asks a Tor exit relay to
resolve the name on its behalf. This extra redirection step
adds a very large delay to DNS requests, on the order of
hundreds of milliseconds, as well as a high degree of jitter,
well beyond what the attack can handle. This issue also affects
the DNS Racing attack, making it inapplicable.
Adapting String and Sock to Tor.
The String and Sock
technique described in Section 3.3 uses a high bandwidth
WebSockets connection to ofﬂoad timing measurements to a
remote server. Unfortunately, due to the high round-trip delay
of a Tor connection, the bandwidth available to a WebSockets
connection over the Tor transport is signiﬁcantly lower than
a connection made over a regular TCP transport. Effectively
the connection operates in a stop-and-wait mode, buffering
outgoing packets as long as not all previously transmitted
2876    30th USENIX Security Symposium
USENIX Association
packets are acknowledged. This buffering removes the timing
information that the attack needs.
To avoid buffering, we reduce the communication of our
String and Sock attack by sending a probe packet only once
every n sweeps over the cache, instead of after every sweep.
We experimentally ﬁnd that n = 72 provides the best accuracy.
Figure 11: String and Sock Probe latency distribution on Tor
Browser using an Intel i5-3470 target (6MB LLC).
Observing the Distribution of Probe Times.
Figure 11
shows the probe time distribution using the Intel i5-3470
target. As the ﬁgure shows, there are three main elements to
this distribution. First, we note a large subset of the probes
have a ﬁxed latency of around 120 ms. These are buffered by
Tor’s network layer, as described above, and sent immediately
after all previously sent packets are acknowledged. Thus,
these packets do not measure contention of the cache, but
instead measure the round-trip delay of the Tor connection.
Next, a large number of probes have a near-zero latency. These
are packets which are sent together with other packets, and
similarly do not encode any cache information. The ﬁnal
subset of the probes has a more diverse set of values, with an
estimated mean of between 150 and 250 milliseconds. These
probes encode cache contention information.
Website Fingerprinting. To demonstrate that these probes
indeed contain cache information, we collect a dataset of
10,000 traces of Alexa Top 100 websites on the i5-3470 tar-
get running Tor Browser, using our adapted String and Sock
method described above. Using this data, we can correctly
ﬁngerprint websites, obtaining a Top-1 accuracy of 20% and
a Top-5 accuracy of 49%. Well above base rates of 1% and
5%, respectively. This demonstrates that completely eliminat-
ing access to timer and array APIs in the Tor Browser does
prevent cache attacks.
6.2 Attacking DeterFox
DeterFox is a Firefox fork aiming to provably prevent timing
attacks from within browser executed code [14]. Its authors
argue that when using DeterFox, “an observer in a JavaScript
reference frame will always obtain the same ﬁxed timing in-
formation, so that timing attacks are prevented”. To achieve
this, DeterFox splits its execution context into multiple de-
terministic reference frames, and uses a priority-based event
queue for communication between these reference.
However, we note that our CSS Prime+Probe technique
does not require any JavaScript, with the colluding DNS
server providing time measurement remotely. Thus, our tech-
niques effectively sidestep all of the side channel protections
offered by DeterFox. To demonstrate the effectiveness of our
attacks on DeterFox, we collect one more dataset of 10,000
traces of Alexa Top 100 websites, using the CSS Prime+Probe
method while using DeterFox. As expected, DeterFox’s prov-
ably secure deterministic timing countermeasure did not pre-
vent our attack, giving us a Top-1 accuracy of 66% and a
Top-5 accuracy of 88%.
7 Conclusion
This paper shows that defending against JavaScript-based
side-channel attacks is more difﬁcult than previously consid-
ered. We show that advanced variants of the cache contention
attack allow Prime+Probe attacks to be mounted through the
browser in extremely constrained situations. Cache attacks
cannot be prevented by reduced timer resolution, by the abo-
lition of timers, threads, or arrays, or even by completely dis-
abling scripting support. This implies that any secret-bearing
process which shares cache resources with a browser connect-
ing to untrusted websites is potentially at risk of exposure.
We also show that the reduced requirements of our attack
make it agnostic across a variety of microarchitectures with
no modiﬁcations. This allows us to present the ﬁrst end-to-end
side-channel attack which targets Apple’s new M1 processors.
So, how can security-conscious users access the web? One
complicating factor to this concept is the fact that the web
browser makes use of additional shared resources beyond
the cache, such as the operating system’s DNS resolver, the
GPU and the network interface. Cache partitioning seems a
promising approach, either using spatial isolation based on
cache coloring [40], or by OS-based temporal isolation [23].
Acknowledgements
This work was supported the Air Force Ofﬁce of Scientiﬁc Re-
search (AFOSR) under award number FA9550-20-1-0425; an
ARC Discovery Early Career Researcher Award (project num-
ber DE200101577); an ARC Discovery Project (project num-
ber DP210102670); the Defense Advanced Research Projects
Agency (DARPA) and Air Force Research Laboratory (AFRL)
under contracts FA8750-19-C-0531 and HR001120C0087;
Israel Science Foundation grants 702/16 and 703/16; the Na-
tional Science Foundation under grant CNS-1954712; the
Research Center for Cyber Security at Tel-Aviv University
established by the State of Israel, the Prime Minister’s Ofﬁce
and Tel-Aviv University; and gifts from Intel and AMD.
The authors thank Jamil Shusterman for his assistance in
bringing up the measurement setup.
USENIX Association
30th USENIX Security Symposium    2877
 0 0.05 0.1 0.15 0.2 0 50 100 150 200 250 300Probability DensityProbe latency (ms)References
[1] Martín Abadi, Ashish Agarwal, Paul Barham, Eugene Brevdo, Zhifeng
Chen, Craig Citro, Greg S. Corrado, Andy Davis, Jeffrey Dean,
Matthieu Devin, Sanjay Ghemawat, Ian Goodfellow, Andrew Harp, Ge-
offrey Irving, Michael Isard, Yangqing Jia, Rafal Jozefowicz, Lukasz
Kaiser, Manjunath Kudlur, Josh Levenberg, Dandelion Mané, Rajat
Monga, Sherry Moore, Derek Murray, Chris Olah, Mike Schuster,
Jonathon Shlens, Benoit Steiner, Ilya Sutskever, Kunal Talwar, Paul
Tucker, Vincent Vanhoucke, Vijay Vasudevan, Fernanda Viégas, Oriol
Vinyals, Pete Warden, Martin Wattenberg, Martin Wicke, Yuan Yu, and
Xiaoqiang Zheng. TensorFlow: Large-scale machine learning on het-
erogeneous systems, 2015. URL https://www.tensorflow.org/.
Software available from tensorﬂow.org.
[2] Onur Acıiçmez and Jean-Pierre Seifert. Cheap hardware parallelism
implies cheap security. In FDTC. IEEE Computer Society, 2007.
[3] Onur Acıiçmez, Çetin Kaya Koç, and Jean-Pierre Seifert. Predicting
secret keys via branch prediction. In CT-RSA, pages 225–242, 2007.
[4] Array.prototype.pop.
Array.prototype.pop().
https:
//developer.mozilla.org/en-US/docs/Web/JavaScript/
Reference/Global_Objects/Array/pop, 2020.
[5] Array.prototype.push.
Array.prototype.push().
https:
//developer.mozilla.org/en-US/docs/Web/JavaScript/
Reference/Global_Objects/Array/push, 2020.
[6] Jo M. Booth. Not so incognito: Exploiting resource-based side channels
in JavaScript engines. Bachelor thesis, Harvard, April 2015.