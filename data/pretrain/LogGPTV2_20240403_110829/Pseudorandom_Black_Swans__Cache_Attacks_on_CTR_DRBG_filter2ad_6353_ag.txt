[39]
[40] H. Jungheim, 2019.: henric.org/random/#nistrng.
[41] B. Kaliski, “PKCS #1: RSA encryption version 1.5,”
RFC 2313, 1998.
[42] W. Kan, Analysis of underlying assumptions in NIST
DRBGs, IACR ePrint archive 2007/345, 2007.
[43] N. Karimi, A. K. Kanuparthi, X. Wang, O. Sinanoglu,
and R. Karri, “MAGIC: Malicious aging in circuits/-
cores,” TACO, vol. 12, no. 1, p. 5, 2015.
Authorized licensed use limited to: University of New South Wales. Downloaded on October 18,2020 at 16:24:55 UTC from IEEE Xplore.  Restrictions apply. 
1254
[44] C. F. Kerry and P. D. Gallagher, FIPS PUB 186-4:
[63]
Digital signature standard (DSS), 2013.
[45] Y. Kim, R. Daly, J. Kim, C. Fallin, J. H. Lee, D. Lee,
C. Wilkerson, K. Lai, and O. Mutlu, “Flipping bits
in memory without accessing them: An experimental
study of DRAM disturbance errors,” in ACM SIGARCH
Computer Architecture News, 2014.
[46] A. Klyubin, Some SecureRandom thoughts, 2013.: a
ndroid - developers . googleblog . com / 2013 / 08 / some -
securerandom-thoughts.html.
[47] P. Kocher, D. Genkin, D. Gruss, W. Haas, M. Ham-
burg, M. Lipp, S. Mangard, T. Prescher, M. Schwarz,
and Y. Yarom, “Spectre attacks: Exploiting speculative
execution,” in IEEE SP, 2019.
[48] A. Kurmus, N. Ioannou, N. Papandreou, and T. P.
Parnell, “From random block corruption to privilege
escalation: A ﬁlesystem attack vector for Rowhammer-
like attacks,” in WOOT, 2017.
[49] A. Kwong, D. Genkin, D. Gruss, and Y. Yarom, “RAM-
Bleed: Reading bits in memory without accessing them,”
in IEEE SP, 2020.
[50] S. Lee, M.-W. Shih, P. Gera, T. Kim, H. Kim, and M.
Peinado, “Inferring ﬁne-grained control ﬂow inside SGX
enclaves with branch shadowing,” in USENIX Security,
2016.
[51] H.-T. Leung, Redhat bug 1150286 - rdrand instruction
fails after resume on AMD CPU, 2019.: bugzilla.kernel.
org/show_bug.cgi?id=85911.
[52] M. Lipp, M. Schwarz, D. Gruss, T. Prescher, W. Haas,
A. Fogh, J. Horn, S. Mangard, P. Kocher, D. Genkin,
Y. Yarom, and M. Hamburg, “Meltdown: Reading kernel
memory from user space,” in USENIX Security, 2018.
[53] K. Michaelis, C. Meyer, and J. Schwenk, “Randomly
failed! the state of randomness in current Java imple-
mentations,” in CT-RSA, 2013.
[54] P. R. Mihir Bellare, PSS: Provably secure encoding
method for digital signatures, 1998.
[55] A. Moghimi, G.
Irazoqui,
“CacheZoom: How SGX ampliﬁes
cache attacks,” in CHES, 2017.
and T. Eisenbarth,
the power of
[56] K. Moriarty, B. Kaliski, J. Jonsson, and A. Rusch,
“PKCS #1: RSA cryptography speciﬁcations version 2.2,”
RFC 8017, 2016.
[57] K. Mowery, S. Keelveedhi, and H. Shacham, “Are AES
x86 cache timing attacks still feasible?” In CCSW, 2012.
[58] M. Neve and J.-P. Seifert, “Advances on access-driven
cache attacks on AES,” in SAC, 2007.
[59] NIST, “Announcing issuance of federal
information
processing standard (FIPS) 140-3, security requirements
for cryptographic modules,” 2019.
[60] OpenSSL, SSL/TLS Client, 2018.: wiki . openssl . org /
index.php/SSL/TLS_Client.
[61] OpenSSL software failure for RSA 16K modulus, 2016.:
mta.openssl.org/pipermail/openssl- users/2016- July/
004056.html.
[62] OpenSSL Software Foundation, User guide for the
OpenSSL FIPS object module v2.0, 2013.
[openssl.org #4063] re: Client hello longer than 214
bytes are rejected, 2015.: mta.openssl.org/pipermail/
openssl-dev/2015-September/002860.html.
[64] D. A. Osvik, A. Shamir, and E. Tromer, “Cache attacks
and counter-measures: The case of AES,” in CT-RSA,
2006.
[65] C. Percival, “Cache missing for fun and proﬁt,” BSDCan,
2005.
[66] C. Pereida García and B. B. Brumley, “Constant-time
callees with variable-time callers,” in USENIX Security,
2017.
[67] N. Perlroth, Government announces steps to restore
conﬁdence on encryption standards, 2013.: bits.blogs.
nytimes.com/2013/09/10/government-announces-steps-
to-restore-confidence-on-encryption-standards.
[68] P. Pessl, L. Groot Bruinderink, and Y. Yarom, “To
BLISS-B or not to be: Attacking strongSwan’s imple-
mentation of post-quantum signatures,” in CCS, 2017.
[69] R. Poddar, A. Datta, and C. Rebeiro, “A cache trace
attack on CAMELLIA,” in InfoSecHiComNet, 2011.
[70] T. Pornin, “Deterministic usage of the digital signature
algorithm (DSA) and elliptic curve digital signature
algorithm (ECDSA),” RFC 6979, 2013.
[71] Quarkslab SAS, OpenSSL security assessment, 2019.:
ostif . org / wp - content / uploads / 2019 / 01 / 18 - 04 - 720 -
REP_v1.2.pdf.
[72] E. Rescorla, “The transport layer security (TLS) protocol
version 1.3,” RFC 8446, 2018.
[73] T. Roche, V. Lomné, and K. Khalfallah, “Combined fault
and side-channel attack on protected implementations
of AES,” in CARDIS, 2011.
[74] E. Ronen, A. Shamir, A. O. Weingarten, and C. Oﬂynn,
“IoT goes nuclear: Creating a Zigbee chain reaction,” in
IEEE SP, 2018.
[75] S. Ruhault, “SoK: Security models for pseudo-random
number generators,” FSE, 2017.
[76] T. Shrimpton and R. S. Terashima, “Salvaging weak
security bounds for blockcipher-based constructions,” in
ASIACRYPT, 2016.
[77] D. Shumow and N. Ferguson, “On the possibility of a
back door in the NIST SP800-90 dual EC PRNG,” in
CRYPTO, 2007.
[78] R. Spreitzer and T. Plos, “Cache-access pattern attack
on disaligned AES T-Tables,” in COSADE, 2013.
[79] The OpenSSL Project, OpenSSL: The open source
toolkit for SSL/TLS, 2003.
[81]
[80] E. Tromer, D. A. Osvik, and A. Shamir, “Efﬁcient
cache attacks on AES, and countermeasures,” Journal
of Cryptology, no. 1, 2010.
J. Van Bulck, F. Piessens, and R. Strackx, “SGX-Step,”
in SysTEX, 2017.
J. Van Bulck, M. Minkin, O. Weisse, D. Genkin, B.
Kasikci, F. Piessens, M. Silberstein, T. F. Wenisch, Y.
Yarom, and R. Strackx, “Foreshadow: Extracting the
keys to the Intel SGX kingdom with transient out-of-
order execution,” in USENIX Security, 2018.
[82]
Authorized licensed use limited to: University of New South Wales. Downloaded on October 18,2020 at 16:24:55 UTC from IEEE Xplore.  Restrictions apply. 
1255
[83] S. Van Schaik, A. Milburn, S. Österlund, P. Frigo, G.
Maisuradze, K. Razavi, H. Bos, and C. Giuffrida, “RIDL:
Rogue in-ﬂight data load,” in IEEE SP, 2019.
[84] M. Vanhoef and E. Ronen, “Dragonblood: A security
analysis of WPA3’s SAE handshake.,” in IEEE SP, 2020.
[85] W. Wang, G. Chen, X. Pan, Y. Zhang, X. Wang, V.
Bindschaedler, H. Tang, and C. A. Gunter, “Leaky
cauldron on the dark land: Understanding memory side-
channel hazards in SGX,” in CCS, 2017.
[86] O. Weisse, J. Van Bulck, M. Minkin, D. Genkin, B.
Kasikci, F. Piessens, M. Silberstein, R. Strackx, T. F.
Wenisch, and Y. Yarom, Foreshadow-NG: Breaking the
virtual memory abstraction with transient out-of-order
execution, 2018.
J. Woodage and D. Shumow, “An analysis of the NIST
SP 800-90A standard.,” in EUROCRYPT, 2019.
[87]
[88] Wtdrog, Systemd issue #11810 - can’t suspend again
after suspending one time, 2019.: github.com/systemd/
systemd/issues/11810.
[89] Y. Xiao, M. Li, S. Chen, and Y. Zhang, “Stacco:
Differentially analyzing side-channel traces for detecting
SSL/TLS vulnerabilities in secure enclaves,” in CCS,
2017.
[90] Y. Xu, W. Cui, and M. Peinado, “Controlled-channel
attacks: Deterministic side channels for untrusted oper-
ating systems,” in IEEE SP, 2015.
[91] M. Yan, C. Fletcher, and J. Torrellas, Cache telepathy:
Leveraging shared resource attacks to learn DNN archi-
tectures, arxiv:1808.04761, 2018.
[92] Y. Yarom and N. Benger, Recovering OpenSSL ECDSA
nonces using the Flush+Reload cache side-channel
attack, IACR ePrint archive 2014/140, 2014.
[93] Y. Yarom and K. Falkner, “F L U S H + R E L O A D: A high
resolution, low noise, L3 cache side-channel attack,” in
USENIX Security, 2014.
[94] K. Q. Ye, M. Green, N. Sanguansin, L. Beringer, A.
Petcher, and A. W. Appel, “Veriﬁed correctness and
security of mbedTLS HMAC-DRBG,” in CCS, 2017.
[95] S. Yilek, E. Rescorla, H. Shacham, B. Enright, and S.
Savage, “When private keys are public,” in IMC, 2009.
[96] F. Zhang, mbedtls-SGX, 2018.: github.com/bl4ck5un/
mbedtls-SGX.
[97] N. Zhang, K. Sun, D. Shands, W. Lou, and Y. T. Hou,
TruSpy: Cache side-channel information leakage from
the secure world on ARM devices, IACR ePrint archive
2016/980, 2016.
[98] Y. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart,
“Cross-tenant side-channel attacks in PaaS clouds,” in
CCS, 2014.
A P P E N D I X A
C A C H E AT TA C K D E TA I L S
In this section, we present the details of our state recovery
attack. In the synchronous model of Osvik et al. [64], an
attacker observes the plaintext and is able to probe the cache
state immediately before triggering an encryption with an
unknown key. The attacker is also able to probe the cache
state immediately after each encryption. Observing the cache
access patterns caused by the ﬁrst round of AES during a few
encryption operations is sufﬁcient to recover the key [64].
Attacking the Last Round of AES.
Working in the
synchronous model of [10, 58, 64] we target the ﬁnal round of
AES, with attacker-observed ciphertext, rather than plaintext.
Implementations commonly use a different T-Table for the
ﬁnal round of encryption, allowing us to measure last round
table accesses independently of earlier round accesses. Let qi
be the ith byte within the T-table, ci be the ith ciphertext byte,
and let ki be the ith byte of the last round key. From the
deﬁnition of T-table AES we know that ci = T [qi] ⊕ ki where
T is the ﬁnal round table. Thus, an attacker who observes ci
and determines qi by monitoring the cache for accesses can
solve this equation for the key byte, yielding ki = ci ⊕ T [qi].
Handling Missing Information. While the attack outlined
above works when the attacker has perfect visibility over qi
and i, on a real system the attacker does not directly observe
qi. Instead, she identiﬁes a contiguous set of bytes that are
fetched into the cache together (a cache line, typically 64 bytes)
and thus loses information about some of the least signiﬁcant
bits of qi. On our machine, each access corresponded to 16
different possible values for qi, as each ﬁnal T-Table byte is
stored four times, in a 4-byte integer, 16 of which are in each
cache line. Further, the attacker does not know i, as she does
not know which cache access produced which ciphertext byte.
Thus, in order to obtain a candidate key byte ki, the attacker
must somehow guess the value of qi from the table indexes
accessed in the last round as well as guess the missing 4 bits
from qi. As we expect about 11 distinct indexes to be accessed
in the last round [58], this results in about 11 · 24 = 176
candidate values for each ki, out of 256 possible candidates.
We notice however, that across many independent encryp-
tions of different plaintexts under the same key, the correct
value for every ki, i = 0, . . . , 16 should always appear in the list
of candidates. In contrast, we expect incorrect candidates to be
uniformly distributed. Thus, if an attacker sees a large number
of encryptions, she can combine the information obtained from
them to retrieve the AES key. Let
(cid:5)
hit(q, j) =
1 if q-th cache line accessed in j-th trace
0 otherwise
.
Following [58],
the attacker counts cache hits that could
correspond to each possible key byte value k from 0x00 to
0xFF for each position i and stores the count in a table S:
n
(cid:2)
m
S [i] [k] =
j=0
q=0
b=0
T [2m ·q+b]⊕ci =k
hit(q, j)
with (cid:4) the number of cache lines, m the number of bytes per
cache line, and n the number of traces. As analyzed by [10,
58], the i-th byte of the last round key is then the value of k
such that S [i] [k] is maximal.
A. Obtaining Trace Data
We describe how we mount Flush+Reload against
CTR_DRBG. We begin by recalling that the attack of [58] out-
Authorized licensed use limited to: University of New South Wales. Downloaded on October 18,2020 at 16:24:55 UTC from IEEE Xplore.  Restrictions apply. 
1256
lined in Section V-B requires the attacker to gather ciphertexts
paired with corresponding traces of the cache state following
the encryption operation that produced that ciphertext.
Matching PRG Output.
To recover the AES key, an
attacker must match each ciphertext to a trace taken in the
interval following the encryption that produced it, but before
the subsequent encryption. In the synchronous model of [64]
where the attacker triggers encryption operations directly, this
matching is trivial. However, in our setting, a request for
random bytes initiates a rapid series of encryptions. If the
attacker’s probes take a long time compared to an encryption
operation, the attacker cannot easily interleave probes. This
difﬁculty is exacerbated by the fact that encryptions vary in
duration due to other system activity, making the naïve strategy
of probing at evenly spaced intervals fail to produce matching
traces and ciphertext pairs.
Tickers.
In order to use the synchronous setting analysis
of [64], we align traces and ciphertexts by using what we