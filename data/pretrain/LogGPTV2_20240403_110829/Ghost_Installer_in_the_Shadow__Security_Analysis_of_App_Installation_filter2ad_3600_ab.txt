internal storage space compared to using the SD-Card: 1)
space for installing the app and 2) that for temporarily storing
the APK ﬁle until installation is ﬁnished. Due to such space
requirement, app installation fails when devices have insufﬁ-
cient internal storage left; low-end devices with small internal
space has a higher chance to suffer from such problem. For ex-
ample, if the Amazon appstore used the internal storage to in-
stall Gabriel-Knight-Sins-Fathers-Anniversary
(1.6GB [2]), the attempt would not succeed on a Galaxy J5
(the 8GB model with only 2.5GB left for third party apps). Ac-
tually, the low-end devices with small internal memory (4GB
or 8GB) are popular1 as much as the ﬂagship devices; during
the ﬁrst half of year 2016, 13 million Galaxy J2 (8GB) and
11.8 million Galaxy S7 (ﬂagship device from Samsung) were
sold [19]. Also, in Feb 2016, Gartner reported that basic and
lower-end devices will account for two-thirds of smartphone
sales by 2019 [7]. Most importantly, low-end device users are
only left with a fraction of internal storage because system
memory and pre-installed apps also takes space.
Under such circumstances, compatibility with low-end
devices becomes important to appstores, which are consis-
tently under the competitions from their peers. An exception
here is Google Play, which is not only dominating the app
market but also is pre-installed on most devices. During our
study, we found APKPure, an interesting appstore that became
popular (Alexa Ranking as of Aug 14, 2016: Global:2,674,
India:895 [1]) by just providing Google Play apps so that
users can install them through the SD-Card; APKPure has
been recommended to those who are suffering from limited
internal storage [15]. This gives us a reason to believe that 3rd
party appstores and users may prefer to leverage the SD-Card
to increase the chance of successful installations, even though
its security risks are well-known.
Understanding SD-Card usage of ordinary developers.
Interestingly, most (83.7%, see Section IV) apps from Google
Play also use the SD-Card for app installation. While appstore
app owners have some protection in place to secure the SD-
Card based installation, ordinary app developers may choose
the SD-Card due to the simplicity of implementation and the
lack of proper secure programming training. To install an
APK using internal storage, the access-control permission of
the APK’s ﬁle needs to be set to global readable. Otherwise,
PackageManager cannot read it. Searching the error caused
130 devices with 4GB and 78 with 8GB are sold at bestbuy.com
TABLE I: Summary of AIT problems
Attack Name
AIT steps [Step No]
Installation Trigger[3]
APK Install[4]
APK Download[2]
AIT Invocation[1]
Hijacking Installation
Hijacking Installation
Exploiting DM
Attacking Installer Interfaces
Section
3.2
3.2
3.3
3.4
by this read failure on stackoverﬂow, multiple answers suggest
storing the APK to the SD-Card instead. However, while this
will allow PackageManager to access the APK, it will
also enable any app with the WRITE_EXTERNAL_STORAGE
permission to tamper with the ﬁle. The tendency of developers
to apply suggestions from websites without understanding the
potential risks has created severe security issues before [33].
III. GHOST INSTALLER ATTACKS
In this Section, we elaborate our analysis on real-world AIT
implementations, which has led to the discovery of unexpected,
security-critical vulnerabilities throughout different AIT steps.
The consequences are serious: we show that a malicious app,
with very limited privilege (discussed later), can install any
apps, gaining any dangerous level permissions without user’s
consent and even access to system resources. The problem
affects hundreds of device models and hundreds of millions of
Android users worldwide (Section IV).
A. Overview
Surprisingly, every AIT step turns out to be vulnerable:
AIT invocation (Step 1) is subject
to code injection and
redirect Intent attacks (Section III-D), APK download (Step
2) is under a threat aiming at a subtle weakness within the
AOSP download manager (Section III-C), installation trigger
(Step 3) of most popular app stores (e.g., Amazon, Xiaomi,
Baidu) and pre-installed apps (e.g., DTIgnite) are all exposed
to a TOCTOU attack that swaps the packages to be installed
(Section III-B) and APK install (Step 4) is also vulnerable
due to the way the PMS and PIA verify target apk. The rest
of the section is presented by following the complexity of the
problems: Step 3, 4, 2 and 1 (See Table I).
Adversary model. We consider an adversary that places
a malicious app on a user’s device, which is a common
requirement for Android-based attacks [27, 22, 37, 42]. For
some targets (Section III-B),
the malicious app requires
WRITE_EXTERNAL_STORAGE permission, a common per-
mission used by many apps (see Section IV). From Android
4.4, private storage directory on /sdcard is supported.
However, such directories are not actually private and are
writable by any app with WRITE_EXTERNAL_STORAGE
permission [5]. Note that even with the advent of the runtime
permission request model introduced on Android 6.0, granting
this permission can be made unnoticeable to the user: the WR
ITE_EXTERNAL_STORAGE and READ_EXTERNAL_STORA
GE permissions belong to the same permission group, i.e.
STORAGE; if an app requests a permission in the group with
an already granted permission, the requested new permission
will be given silently by the system [13]. So, the adversary
can request one of the permissions in the STORAGE group
for a legitimate purpose and then silently acquire the others.
B. Hijacking Installation (AIT Step 3 and 4)
Most app installers (for app stores) today use the external
storage to install apps (new apps or updates). More speciﬁcally,
the installer initiates the AIT by downloading the target apk
405
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:04:31 UTC from IEEE Xplore.  Restrictions apply. 
and metadata (e.g. the hash of the apk) from its server and
storing it to the SD-Card. After verifying the hash of the
package, APIs are called or Intents are sent by the installer
the target apk. The
to invoke the PMS or PIA to install
use of the SD-Card is considered necessary for most apps,
including almost all major appstore apps (e.g., Amazon, Baidu,
etc.) except manufacturers like Google and Samsung. The
manufacturers can always pre-install their apps on the devices
they control, while the third-party installers are under peer
pressure and need to make use of every bit of storage available
to install or update their apps on their customers’ devices. This
becomes particularly important when the installer is designed
to work on the devices with different internal storage sizes,
including those with very small space (see Section II).
TOCTOU exploit. External storage is well known to be
insecure, readable and writable by the app with READ_EXTER
NAL_STORAGE and WRITE_EXTERNAL_STORAGE permis-
sions. However, an attack on the storage to tamper with
the installation process is more complicated than it ap-
pears to be. Speciﬁcally, system app developers and app-
store owners are well aware of the security risks and they
perform integrity checks to ensure that packages are not
improperly modiﬁed before installation. A direct attempt to
replace the ﬁles downloaded will be defeated if it does
not happen within the right
time window (right after the
integrity check and before installation). Actually, some in-
stallers have already made an effort to minimize such time
window. Particularly, Amazon and Xiaomi appstores call the
PackageManager.installPackage API immediately
after the hash veriﬁcation is completed. Also, Amazon ran-
domizes the names of the packages downloaded to avoid
being identiﬁed by an attacker. To safeguard the installation
process, Android also provides a hidden API PackageMan
ager.installPackageWithVerification (AIT Step
4) for the PMS to verify the integrity of an app’s manifest
(AndroidManifest.xml) provided by the installer.
In spite of such protection, our research shows that a
TOCTOU attack replacing a target apk with a malicious one
can still be reliably executed. Particularly, any app with the
above SD-Card permission can use the FileObserver class
to monitor the ﬁle access events under a given directory.
Even though some appstores randomize the names of the
packages to be installed, the directory path turns out to be less
convenient to change, given the practice that many appstores
pre-download some apps the phone user might want to install
in the future on her SD-Card and the difﬁculty in managing
random directories for all these apps on the card. Actually,
even when this indeed happens, the attack app can simply keep
track of all such directories and ﬁnd the right targets under the
directories according to their types. In our study, we found that
the attacker, with nothing but the SD-Card permission, can
register with the FileObserver and can be notiﬁed with
ﬁle-access events such as CREATE, ACCESS, CLOSE_WRITE
and CLOSE_NOWRITE. As a result, it can catch the window
based on how ﬁles under the directory are used.
Speciﬁcally, our attack app waits until the target apk is
created and its integrity check is done and then substitute a
malicious APK for the ﬁle. Completion of the ﬁle download
can be easily known by observing the CLOSE_WRITE event.
A bit tricky here is to detect the integrity check. Different
appstores may read from the ﬁle different number of times,
depending on the implementation of the check. The strategy
used in our attack is to analyze the target appstore beforehand,
ﬁguring out its access pattern. For example, for the Amazon
app, as soon as 7 CLOSE_NOWRITE events are observed right
after the completion of the download, we know that the check
is done and it is time to do the replacement; for Qihoo360,
we found that 3 CLOSE_NOWRITE events need to be seen
before the attack can be executed. This approach was very
effective, enabling us to successfully attack most appstores and
the updating process of popular apps.
Note that FileObserver is by no means the only
channel for capturing the attack window. Even when it is
closed (e.g., requiring new permissions to monitor events),
there are other ways to determine the timings for the attack.
For example, we can determine whether the target apk is fully
downloaded by looking for the presence of its end of central
directory record located at the end of the ﬁle, and then wait
for a short period of time, as measured beforehand on the
device of the same model, before start replacing the ﬁle (by
moving a pre-stored ﬁle to the directory). In practice, this
simple “wait-and-see” strategy works very well. Note that even
when the window is missed and the corrupted ﬁle is detected,
many appstores and apps re-download the target apk, a process
transparent to the user, which enables the attacker to try again.
Once the target apk is replaced, only protection left is the
manifest veriﬁcation which is done by PMS during installation.
This defense can be circumvented by a malicious app utilizing
the original app’s manifest, which typically happens in app
repackaging. Following we present few attacks on popular
appstores and apps.
Attack on DTIgnite (Step 3). DTIgnite is a pre-installed
system app used by major carriers (Verizon, T-Mobile, etc.) to
push (post-sale) bloatware to their customers (Section IV). For
this purpose, it is capable of silently installing apps on Android
devices. The APKs of such apps are stored on the external
storage (/sdcard/DTIgnite) by the DM and veriﬁed
against their hash values before installation. In our research,
we successfully attacked DTIgnite using our attack app (with
only SD-Card permission) through both the FileObserver
monitoring and the “wait-and-see” strategy (by waiting for 2
seconds after download) on Galaxy S6 Edge (Verizon). Given
that the system app is used by over 20 carriers, the attack
affects hundreds of millions of Android users (Section IV).
Attacks on Appstore apps (Step 3). Amazon, Xiaomi and
Baidu are popular Android application stores, which have been
pre-installed on a large number of devices. For example, Ama-
zon app (com.amazon.venezia) routinely appears on Android
phones with Verizon and USCellular (see Section IV). All
these appstores utilize the same approach as DTIgnite to install
an app, except that they immediately activate the PMS once
the download and the integrity check are complete. However,
the protection does not work at all in the presence of the
FileObserver monitoring: our attacker successfully caught
the attack window after observing 7 CLOSE_NOWRITE events
for Amazon and 1 for Xiaomi and 2 for Baidu. Alternatively,
we found that Amazon and Baidu can be attacked in the
same way as DTIgnite, with the only difference that
the
replacement needs to be done 500ms after the download is
completed. For Xiaomi appstore, its download completion can
be easily identiﬁed from the installer’s behavior that changes
406
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:04:31 UTC from IEEE Xplore.  Restrictions apply. 
the temporary name of the target apk to its ofﬁcial name.
Appstore apps can also be side-loaded by users as a non-
system app. In this case, unless the appstore app is signed by
the platform key, the app installation goes through the PIA,
which pops up a user consent dialogue during installation
with the target apk’s package name and package icon. This
protection is defeated in our study by embedding within the
malicious APK (for replacing the target apk) the original app’s
name and icon. Note that the target apk replacement time
window can be detected using the same FileObserver
approach as above. Like installation of a new app, updating
existing apps can also be attacked in the same way.
Attack on new Amazon appstore (Step 4). Of particular
interest here is the upgrade of the Amazon appstore from May
7th, 2015 to version−17.0000.893.3C 64 7000010. This ver-
sion includes protection under the installPackageWith
Verification API (AIT Step 4), which takes the path
of target apk and the checksum of target apk’s manifest
(AndroidManifest.xml) as a parameter and veriﬁes the check-
sum before installation within the PMS, and Digital Right
Management (DRM) features that self-check whether it has
been tampered with. All such protection is defeated in our
research through repackaging an Amazon app with attack code,
removing its DRM code but keeping its manifest. Note that this
version has two hash veriﬁcation protection in place, one done