0
0
0
0
0
0
Table 1: List of test applications. Type abbreviations: (S)tack overﬂow, (H)eap overﬂow and (F)ormat string.
~~http.c:~~
119: int read_header(int sid)
120: {
121: 
122:
char line[2048];
char *pTemp;
...
do {
Create
127:
128:
129:
130:
memset(line, 0, sizeof(line));
sgets(line, sizeof(line)-1, conn[sid].socket);
striprn(line);
...
~~server.c~~
202: int sgets(char *buffer, int max, int fd)
203: {
209:
210:
211:
212:
...
conn[sid].atime=time((time_t*)0);
while (nout_headdone=1;
...
Taint
151:
strncpy(conn[sid].dat->in_Connection, (char *)&line+12,
152:
153:
154:
169:
170;  
171:
sizeof(conn[sid].dat->in_Connection)-1);
if (strncasecmp(line, "Content-Length: ", 16)==0) 
conn[sid].dat->in_ContentLength=atoi((char *)&line+16);
if (strncasecmp(line, "Cookie: ", 8)==0)
...
if (conn[sid].dat->in_ContentLengthin_ContentLength+1024, sizeof(char));
if (conn[sid].PostData==NULL) {
...
/* reading beyond PostContentLength is required 
for IE5.5 and NS6 (HTTP 1.1) */
98:
99:
100:
101:
106:
107:
108:
109:
do {
...
rc=recv(conn[sid].socket, pPostData, 1024, 0);
if (rc==-1) {
Memory Region:
Type: heap 
Taint
**Corruption Point**
Figure 6: A graphical representation of the vulnerability in Null HTTP
Incomplete Library Speciﬁcation: Our testing al-
lowed us to observe certain properties of the C library which
require a more expressive speciﬁcation than the one our cur-
rent implementation uses. strtok(char *str, char *delim)
is a C library function that tokenizes a given string. It tra-
verses the string until a delimiter character is reached and
returns the pointer to the beginning of the token. The orig-
inal string can be parsed further by calling strtok with a
NULL argument. These subsequent calls are not included
in the WS of the original string, since the string does not
appear as an argument. This results in the memory write
being interpreted as illegal during debugging.
Certain library functions modify global variables as side
eﬀects. For example, the function that parses the program
argument getopt returns the argument through the global
variable optarg. The statements issuing the function calls
are not in optarg’s WS, causing false positives during de-
bugging. Another example is errno, which is used to return
the error number throughout the C library.
Finally, some library functions return pointers to global
variables that are hidden from the client program through
the use of attribute-hidden. Examples include getdatetime,
gmtime in time.h and gethostbyaddr, gethostbyname in
socket.h. When the returned value is assigned to a pro-
gram variable, MemSherlock fails to ﬁnd a corresponding
MemoryRegion and raises a false alarm.
The false positives due to library functions can be pre-
vented by the use of a more expressive library speciﬁcation.
struct Pointers: MemSherlock relies on type informa-
tion as little as possible. Unfortunately, struct pointers is
one of the few instances where MemSherlock requires type
information supplied through ﬂagging the variable. As men-
tioned earlier, this allows the debugger to determine if the
pointer is pointing to a ﬁeld or the entire struct. Two of our
test applications use void * type pointers to refer to struct
variables using explicit type casting. When the struct vari-
able is modiﬁed through the use of this pointer, MemSher-
lock raises an error upon the modiﬁcation of the second and
later ﬁelds. These false positives can be prevented by check-
ing for such type casting during static analysis and commu-
nicating this information to the debugger either through the
input ﬁle or client calls at debugging time.
6.3 False Negative Analysis
The MemSherlock debugging agent is implemented as a
Valgrind skin. Unfortunately, Valgrind is unable to trace
into kernel instructions. As a result, our current implemen-
tation cannot detect memory region modiﬁcations done by
kernel instructions. This case is diﬀerent from system calls
which are handled successfully. While experimenting with
Prozzilla, we noticed that vfprintf makes a call to mempcpy,
which is identical to memcpy except that it returns the desti-
nation pointer instead of the number of bytes copied. When
copying large chunks of memory that span multiple virtual
memory pages, mempcpy uses kernel functions to modify the
page table. The current implementation of MemSherlock
debugging agent is not able to see such memory writes, and
failed to detect the memory corruption.
It is easy to prevent such false negatives by writing wrap-
pers for library functions that modify memory without using
client program instructions. Newer versions of Valgrind sup-
port wrapper functions which can intercept calls to library
functions. Such a wrapper function simply would check if
the write is legitimate before the actual call to the library
is made and perform any pointer related assignments once
the function returns.
Although we have not encountered any other false nega-
tives during our experiments, we are aware that the current
implementation can cause several types of false negatives.
The most obvious one is the use of structs within arrays
or unions. Since we currently handle such memory regions
as single blocks, we cannot distinguish writes to individual
ﬁelds. In the case of arrays, it is possible to subdivide the
memory region and monitor each element. The problem is
that arrays can be quite large, and increasing the number
of memory regions to monitor can degrade performance to
an unacceptable level. We observe that this problem can be
solved by using compressed data structures; however, due
to time limitations, we did not include this functionality in
our proof of concept implementation.
Another type of false negatives can occur when dealing
with chained dereferencing expressions such as var[i].f ield[j]
= some exp. SrcRewrite would convert the l-value into a
temporary variable temp = var[i].f ield. Our current imple-
mentation fails to detect an illegal write when the index i is
out of bounds. Bounds checking on these indices can remove
the possibility of false negatives. Inserting bounds checking
for arrays can be done during source code rewriting, since
the bounds are known. For heap buﬀers, the bounds check-
ing can be deferred to the debugger via client calls.
Ideally, we would have liked to perform ﬁne-grained moni-
toring on library regions as well. However, in our current im-
plementation, we treat dynamically linked libraries as grey
boxes, in which they are only deﬁned by their speciﬁcations.
Even though this could potentially cause a false negative, an
attack that exploits this shortcoming would have to modify
library data alone to succeed.
7. RELATED WORK
MemSherlock is related closely to intrusion detection sys-
tems that perform memory level monitoring [20, 25, 30]. Mi-
nos [6] and TaintCheck [20] can detect the improper use
of tainted data by tracking the propagation of untrusted
data. MemSherlock also incorporates taint tracking; how-
ever, it relies on completely diﬀerent detection mechanisms,
and thus can provide vulnerability information that Minos
and TaintCheck cannot oﬀer.
Brumley et al. [1] recently investigated automatic gener-
ation of vulnerability-based signatures. A precondition of
their approach is the speciﬁcation of vulnerability point and
vulnerability condition. Moreover, Newsome et. al. pro-
posed self-hardening programs [9], which can remove vul-
nerabilities from the program to make it immune to exploits
attacking the vulnerability. MemSherlock can complement
these approaches by providing vulnerability information.
A few address space randomization techniques, such as
PaX ASLR [21], TRR [28] and ASLP [10], have been pro-
posed to detect memory corruption attacks. Such approaches
can be used to trigger the MemSherlock debugging phase.
Network based IDSs such as [11, 12, 24] can automatically
generate signatures for unknown attacks. These systems do
not provide vulnerability information, rather extract com-
mon syntax from the network packets. However, IPSs re-
lying on such syntactic signatures have been shown to be
vulnerable to attacks [26].
8. CONCLUSION AND FUTURE WORK
In this paper, we presented the development of MemSh-
erlock, a security debugging tool that can identify unknown
memory corruption vulnerabilities automatically upon the
detection of malicious payloads that exploit such vulnera-
bilities. MemSherlock provides critical information for un-
known memory corruption vulnerabilities, including (1) the
corruption point in the source code, (2) the slice of source
code that helps the malicious input to reach the corruption
point, and (3) the description of how the malicious input ex-
ploits the unknown vulnerability. We evaluated MemSher-
lock with a set of 11 real-world applications that have buﬀer
overﬂow, heap overﬂow, and format string vulnerabilities.
Our results demonstrated that MemSherlock is a useful tool
to facilitate the vulnerability analysis process.
Our future work is two-fold. First, we will improve the
implementation of MemSherlock to address its implementa-
tion oriented limitations, such as the inability to deal with
assembly code and the coarse-grained monitoring of mem-
ory regions allocated by shared libraries. Second, we will
improve the automated analysis and the presentation of the
analysis results so that the analysis results are more intuitive
and easier to use.
9. REFERENCES
[1] D. Brumley, J. Newsome, D. Song, H. Wang, and
S. Jha. Towards automatic generation of
vulnerability-based signatures. In Proceedings of the
IEEE Symposium on Security and Privacy, May 2006.
[2] H. Chen, D. Dean, and D. Wagner. Model checking
one million lines of c code. In Proceedings of the 11th
Annual Network and Distributed System Security
Symposium (NDSS), February 2004.
[3] H. Chen and D. Wagner. MOPS: an infrastructure for
examining security properties of software. In
Proceedings of the 9th ACM Conference on Computer
and Communications Security (CCS’02), November
2002.
[4] S. Chen, J. Xu, and E. C. Sezer. Non-control-data
attacks are realistic threats. In Proceedings of 14th
USENIX Security Symposium, 2005.
[5] CodeSurfer.
http://www.grammatech.com/products/codesurfer/.
[6] J. R. Crandall and F. T. Chong. Minos: Control data
attack prevention orthogonal to memory model. In
Proceedings of the 37th Annual IEEE/ACM
International Symposium on Microarchitecture, pages
221–232, December 2004.
[7] J. R. Crandall, Z. Su, S. F. Wu, and F. T. Chong. On
deriving unknown vulnerabilities from zero-day
polymorphic and metamorphic worm exploits. In
Proceedings of the 13th ACM Conference on Computer
and Communications Security, pages 235–248, 2005.
[8] H. Feng, J. Giﬃn, Y. Huang, S. Jha, W. Lee, and
B. Miller. Formalizingsensitivity in static analysis for
intrusion detection. In Proceedings of the 2004 IEEE
Symposium on Security and Privacy, May 2004.
[9] D. S. James Newsome, David Brumley.
Vulnerability-speciﬁc execution ﬁltering for exploit
prevention on commodity software. In Proceedings of
the 13th Annual Network and Distributed System
Security Symposium (NDSS ’06), Feb 2006.
[10] C. Kil, J. Jun, C. Bookholt, J. Xu, and P. Ning.
Address space layout permutation (ASLP): Towards
ﬁne-grained randomization of commodity software. In
Proceedings of the 22st Annual Computer Security
Applications Conference (ACSAC ’06), pages 339–348,
December 2006.
[11] H. Kim and B. Karp. Autograph: Toward automated,
distributed worm signature detection. In Proceedings
of the 13th USENIX Security Symposium, August
2004.
[12] C. Kreibich and J. Crowcroft. Honeycomb - creating
intrusion detection signatures using honeypots. In
Proceedings of the Second Workshop on Hot Topics in
Networks (HotNets-II), November 2003.
[13] W. Landi. Undecidability of static analysis. ACM
Letters on Programming Languages and Systems,
1(4):323–337, December 1992.
[14] D. Larochelle and D. Evans. Statically detecting likely
buﬀer overﬂow vulnerabilities. In Proceedings of the
10th USENIX Security Symposium, August 2001.
[15] Z. Liang and R. Sekar. Fast and automated generation
of attack signatures: a basis for building
self-protecting servers. In Proceedings of the 13th
ACM Conference on Computer and Communications
Security, pages 213–222, 2005.
[16] Z. Liang and R. Sekar. Fast and automated generation
of attack signatures: A basis for building
self-protecting servers. In Proceedings of 12th ACM
Conference on Computer and Communication Security
(CCS ’05), pages 213–222, 2005.
[17] G. Necula, J. Condit, M. Harren, S. McPeak, and
W. Weimer. CCured: Type-safe retroﬁtting of legacy
software. ACM Transaction on Programming
Languages and Systems, 27(3):477–526, May 2005.
[18] G. Necula, S. McPeak, and W. Weimer. CCured:
Type-safe retroﬁtting of legacy software. In
Proceedings of the 29th ACM SIGPLAN-SIGACT
symposium on Principles of Programming Languages,
pages 128–139, 2002.
[19] N. Nethercote. Dynamic binary analysis and
instrumentation, 2004.
valgrind.org/docs/phd2004.pdf.
[20] J. Newsome and D. Song. Dynamic taint analysis for
automatic detection, analysis, and signature
generation of exploits on commodity software. In
Proceedings of The 12th Annual Network and
Distributed System Security Symposium (NDSS ’05),
February 2005.
[21] PaX Team.
http://pax.grsecurity.net/docs/aslr.txt.
[22] G. Ramalingam. The undecidability of aliasing. ACM
Transactions on Programming Languages and
Systems, 16(5):1467–1471, September 1994.
[23] S. Sidiroglou, M. Locasto, S. Boyd, and A. Keromytis.
Building a reactive immune system for software
services. In Proceedings of USENIX Annual Technical
Conference, pages 149 – 161, April 2005.
[24] S. Singh, C.Estan, G. Varghese, and S. Savage.
Automated worm ﬁngerprinting. In Proceedings of the
6th ACM/USENIX Symposium on Operating System
Design and Implementation (OSDI), December 2004.
[25] A. Smirnov and T. Chiueh. DIRA: Automatic
detection, identiﬁcation, and repair of
control-hijacking attacks. In Proceedings of The 12th
Annual Network and Distributed System Security
Symposium (NDSS ’05), February 2005.
[26] G. Vigna, W. Robertson, and D. Balzarotti. Testing
network-based intrusion detection signatures using
mutant exploits. In CCS ’04: Proceedings of the 11th
ACM conference on Computer and communications
security, pages 21–30, New York, NY, USA, 2004.
ACM Press.
[27] H. Wang, C. Guo, D. Simon, and A. Zugenmaier.
Shield: Vulnerability-driven network ﬁlters for
preventing known vulnerability exploits. In
Proceedings of ACM SIGCOMM, August 2004.
[28] J. Xu, Z. Kalbarczyk, and R. K. Iyer. Transparent
runtime randomization for security. In Proceedings of
22nd Symposium on Reliable Distributed Systems -
SRDS 2003, pages 260–269, 2003. IEEE Computer
Society, Oct.
[29] J. Xu, P. Ning, C. Kil, Y. Zhai, and C. Bookhold.
Automatic diagnosis and response to memory
corruption vulnerabilities. In Proceedings of the 13th
ACM Conference on Computer and Communications
Security, pages 223–234, 2005.
[30] P. Zhou, W. Liu, L. Fei, S. Lu, F. Qin, Y. Zhou,
S. Midkiﬀ, and J. Torrellas. Accmon: Automatically
detecting memory-related bugs via program
counter-based invariants. In MICRO 37: Proceedings
of the 37th annual International Symposium on
Microarchitecture, pages 269–280, Washington, DC,
USA, 2004. IEEE Computer Society.
[31] P. Zhou, F. Qin, W. Liu, Y. Zhou, and J. Torrellas.
iWatcher: Eﬃcient architectural support for software
debugging. In Proceedings of the 31st International
Symposium on Computer Architecture (ISCA), 2004.