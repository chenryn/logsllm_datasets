padding=0000000000000000F851D6CC68FC9537然后看图
还是一样的步骤，程序解密密文得到中间值，然后和初始化向量异或得到明文，然后程序再判断填充位是否正确。
我们知道0和数异或的结果都是该数本身
所以中间值和0异或的结果还是中间值本身，我们可以从图中看到异或的结果是3D，此时我们是不可能知道这个异或出来的结果是3D的，但是此时服务端会报一个错，那就是填充位错误，为什么会报这个错，因为之前说了，填充文在8个字节为分组的情况下，最多只可能填到8个0x08，所以怎么可能会有0x3D呢？
那怎么样才能不报这个错呢？以最后一位为例
如果此时异或出来的结果为
“39732322076a2601”也就是异或出来的结果最后一位为0x01时就不会报填充位错误了。但是后续还会在爆一个错误，那就是业务判断你这个解密出来的明文数据也就是“39732322076a2601”不正确，因为我们初始化向量都制为零的，所以这个明文当然是错误的，不过这都不重要。
此时我们知道了，当最终解除出来的明文的最后一位位0x01时，我们的程序就不会报填充位错误，那一次类推如果解出来为“39732322076a0202”“
3973232207030303”…… “ 0808080808080808”时也不会报填充位错误。
所以我们从假如最后一位为0x01开始，由于中间是是固定不变的，我们就需要变化初始化向量的最后一个字节让其和中间值的最后一个字节异或的结果为0x01,
所以此时我们需要用到穷举的方法，一个字节的范围为，0x00-0xFF,最多也就是需要尝试256次，
此时我们根据上图可以看出，当最后一位异或结果为0x01时，我们此时的初始化向量为
‘’0000000000000066‘’
又已知0x01是中间值和初始化向量异或得出的结果，所以我们将此时我们用来爆破的初始化向量的最后一位，也就是“0x66”与0x01向异或，就可以得出真正的中间值的最后一个字节，也就是0x67。
以此类推，直到异或结果为“0808080808080808”，我们多需要尝试的次数，最多也不过256*8次也就是2048次，这样我们就可以绕过加密，从而直接获得密文的明文。
## 6、CBC字节翻转攻击
以上的手段可以让我们绕过加解密从而直接获得明文，不知道大家有没有发现一个问题，来我们再次观察一下解密过程
解密的第一步，首先用后台用密钥，将密文解密然后将解密得出的中间值与初始化向量IV做异或操作，得到第一段密文的明文。
解密的第二步，首先用后台用密钥，将密文解密然后将解密得出的中间值与上一段密文做异或操作，得到第二段密文的明文。
不难看出，下一段明文的内容是受到上一段密文的影响的，那么是否存在我们通过修改前一段密文或者初始化向量来达到修改下一段密文的明文的效果
打个比方说我们明文是“admin”然后加密传输到后端，后端解密出来的结果是“bdmin”
可不可以实现呢？当然是可以的
首先我们再理一下这个过程，“admin”首先和初始化向量异或得到一个8字节的密文，然后由于按照8字节来划分，所以初始化向量自然也是8字节，为了方便传递给后台识别，初始化向量转化成8字节大小的十六进制数放在加密好的密文开头，然后发送给后台。
后台受到密文后，将前八字节的十六进制出提取出来作为初始化向量，然后将剩下的密文，使用密钥解密后然后和初始化向量做异或操作，得出最终的明文。
问题还是出在了解密过程中的异或操作，这个初始化向量是我们可控的
我们想要的结果就是密文和我们修改过后的初始化向量
此时我们要清楚一个基本的异或运算
我们使用“qwerasdf”来作为我们的初始化向量 “admin”作为要加密传输的明文，也就是说我们首先进行异或操作时是有“q”和“a”来进行异或的
所以有“q” xor “a” 来作为第一步，这个异或的结果会在后台用密钥解密出来后再与初始化向量“q”来异或得出明文“a”
所以此时有“q” xor “a” xor “q” == “a”这么一个式子
我们将“q” xor “a”的结果设为X
既X = “q” xor “a”
，X就是作为中间值被加密然后传到后台的
此时我们将X 作为参数再与我们的目标值“b”进行一次异或
也就是说 X xor “b” 这个结果我们设为Y
此时得到Y == X xor “b”
再根据上一个式子可以得到，Y = “q” xor "a" xor " b"
已知X是未经修改的IV与明文异或的结果也就是所谓的中间值，也就说解密时X时作为解密时的中间值同样要参与到解密时的异或步骤，但是如果我们在传递数据时将“q”更改为我们的Y。让Y去和X进行异或操作，最终得到的结果就变成了”b“
，这样我们就实现了更改明文的第一个字节，接下来的同样是进行重复操作。
这就是所谓的CBC字节翻转攻击的原理，下面贴出实现代码。
    from pyDes import des, CBC, PAD_PKCS5
    import binascii
    # 秘钥
    KEY = 'mHAxsLYz'
    #初始化向量
    KEY2 = "qwerasdf"
    def des_encrypt(s):
        """
        DES 加密
        :param s: 原始字符串
        :return: 加密后字符串，16进制
        """
        secret_key = KEY
        iv = KEY2
        k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5)
        en = k.encrypt(s, padmode=PAD_PKCS5)
        return binascii.b2a_hex(en)
    def des_descrypt(s,iv):
        """
        DES 解密
        :param s: 加密后的字符串，16进制
        :return:  解密后的字符串
        """
        secret_key = KEY
        iv = iv
        k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5)
        de = k.decrypt(binascii.a2b_hex(s), padmode=PAD_PKCS5)
        return de
    str = des_encrypt("admin")
    cipher = bytes(KEY2,encoding='utf-8')
    print(cipher)
    x = bytes([ord(chr(cipher[0]))^ord('a')^ord('b')])+cipher[1:]
    x2 = cipher[0]
    print(x)
    str3 = des_descrypt(str,x)
    print(str3)
下面是执行结果
* * *