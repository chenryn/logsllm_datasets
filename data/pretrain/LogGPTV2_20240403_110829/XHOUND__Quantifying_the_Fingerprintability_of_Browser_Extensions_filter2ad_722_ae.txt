extensions. Given these inputs, we identify two different ways
to architect an extension-ﬁngerprinting script. First, the script
may deliver a page with all the content necessary for triggering
ﬁngerprintable extensions of interest, extract
the resulting
DOM, and send the entire DOM to the tracking server,
for further ofﬂine analysis. Later, the comparator module of
XHOUND can match the modiﬁed DOM to speciﬁc browser
extensions and combine them into a ﬁngerprint. Second, in
addition to including the extension-triggering content,
the
tracking script can also include logic that immediately ana-
lyzes the page searching for extension-speciﬁc changes.
In both scenarios, the attacker needs a way to generate
DOM content which triggers the detectable functionality of
ﬁngerprintable browser extensions. We argue that, to a large
Listing 3 Examples of DOM contents retrieved by XHOUND,
which trigger on-page changes from extensions (underlined)
// HoverZoom inserts special class attribute
// Skype removes the following script
// Google Calendar adds a link
extent, this can be done automatically using the information
already provided by XHOUND. Depending on each speciﬁc
case, an extension may need as little as an ad or a web form
to reveal itself (XHOUND discovers these types of extensions
through its static honey pages) or as much as a speciﬁcally-
named DOM element or a series of elements in parent-child
relationships. These latter changes are recovered by XHOUND
through the use of dynamic honeypages and on-the-ﬂy DOM
generation.
For
the
recorded
while
all
elements
instance,
extension,
for
queries
analyzing
XHOUND
ﬁnding
popular
Hov-
HoverZoom
erZoom’s
like
“a[data-expanded-url*="nstagram.com/p/"]”,
“img[src*="gravatar.com/avatar/"]” and created
mock elements that satisﬁed the requirements. Listing 3
shows the created mock content and introduced changes after
HoverZoom ﬁnds it (new “hoverZoomLink” class name).
In most of the cases,
this mock content can immediately
serve as extension-triggering content. Similarly, XHOUND
identiﬁed and created a mock script
that was queried by
the Skype extension in order to remove it, and created the
necessary complicated hierarchy so that the Google Calendar
extension inserts a link into it, as shown in the Listing 3.
Given such triggering content, the actual in-page detection
consist of simple DOM queries and if-checks, such as the
ones illustrated in the Listing 4.
Finally, it is worth noting that, for most extensions, an
attacker can use a single ﬁngerprinting script
to identify
extensions since, according to our results, more than 86%
of extensions are uniquely identiﬁable regardless of possible
overlapping on-page changes. If one would still want to isolate
951
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:21:24 UTC from IEEE Xplore.  Restrictions apply. 
Listing 4 Examples of DOM queries that are sufﬁcient to
detect triggered extensions
if (document.querySelector(".hoverZoomLink") !== null) {
// HoverZoom is present
}
if (document.getElementById(’skype_script’) === null) {
// Skype is present
}
if (document.querySelector(’a[href*="https://calendar.
google.com/calendar/event"]’) !== null || document.
querySelector(’img[src*="chrome-extension://
gmbgaklkmjakoegficnlkhebmhkjfich"]’) !== null) {
// Google Calendar is present
}
.
s
m
,
e
m
i
t
d
a
o
L
1000
750
500
250
0
0
5
10
# Extensions
15
20
the effects of extensions, one strategy would be to use iframes
where each extension would manifest itself in a separate DOM.
To analyze the performance of our proof-of-concept
extension-ﬁngerprinting script, we automatically retrieved
the XHOUND-detected triggering content for 30 universally-
ﬁngerprintable extensions and implemented the corresponding
checks. These checks could, in principle, be automatically
generated by parsing XHOUND’s output but we leave this
automation for future work. Our sample of extensions includes
popular ﬁngerprintable extensions based on the number of
active users, which we found in the market and during our user
study, as well as randomly selected lower-ranked extensions.
Our non-minimized script together with the triggering content
has a size of less than 16 Kb. For testing, we run our
script on random subsets of up to 20 extensions, taking the
average of ten runs per subset. The testbed was automated
with Selenium’s ChromeDriver on a MacBook Air laptop (1.7
GHZ Intel Core i5, 4 GB RAM, other applications open).
All ﬁngerprintable extensions were correctly identiﬁed by
our script. Apart from the time that we need to wait so
that extensions manifest themselves (discussed in the next
paragraph), the actual checks take less than 5 ms.
The part
that “delays” the ﬁngerprinting process is the
fact that, unlike traditional ﬁngerprinting which, for the most
part, just reads out existing properties, such as screen size
or a list of plugins, most extensions introduce their changes
after a web page is loaded (window.onload event ﬁres).
An extension-ﬁngerprinting script must
therefore wait, or
keep polling the DOM, until a page has loaded and until
each extension has had a chance to introduce its changes.
To quantify this delay, we run our extension-ﬁngerprinting
script 21 times in increments of one extension, starting with
a browser with no extensions and ending with a browser
with 20 installed extensions. If our script could not ﬁnd the
appropriate number of extensions, it restarted itself after a
few tens of milliseconds. Figure 8 present the necessary load
time (after the window.onload event ﬁres) as a function of
the number of installed extensions (whiskers represent 95%
conﬁdence intervals). One can see a wave-shaped growth of
the extension load time which increases as the number of
installed extensions increase. We suspect that these changes
are because of multi-threading and non-overlapping processing
Fig. 8. Load time of extensions before on-page changes appear. The blue
vertical line signiﬁes the number of extension that an average user installs, as
discovered by our Mechanical Turk experiment.
of particular on-page changes. We attribute the presence of
spikes to our system load, as well as recurrent additional
delays from the use of ChromeDriver. Overall, despite these
“delays”, our results show that even for as many as twenty
installed extensions, the entire ﬁngerprinting process takes
less than one second. Note that this delay is not affected
by checking for extensions that are not present. Therefore, a
tracker can try to trigger multiple hundreds of extensions and
still wait for less than a second, under the assumption that the
vast majority of them will not be present and will therefore not
delay the manifestation of the ones that are present (our results
from Section IV-B indicate that the average user utilizes ﬁve
extensions).
The reader can view a video demonstration of our
extension-ﬁngerprinting script by visiting this URL: https:
//vimeo.com/178330178 (password is SP2017). The
script waits for a few seconds after the window.onload
the page’s DOM.
event ﬁres and proceeds to ﬁngerprint
As one can notice, a few extensions reveal
that
they performed an action (coaxed by the XHOUND-extracted
triggering conditions) by adding visual elements in a page’s
DOM (such as Avira which informs the user that it blocked a
suspicious resource). Since these visual elements are part of a
page’s DOM, the tracking script can immediately delete them
and hence, even for these “verbose” extensions, hide the fact
that the user’s browser is being ﬁngerprinted.
the fact
VI. DISCUSSION AND FUTURE WORK
In this section we ﬁrst discuss the implications of our
ﬁndings with regard to user privacy and then sketch two pos-
sible countermeasures against tracking facilitated by browser
extensions.
A. Privacy Implications
As described in Section IV-A, XHOUND was able to auto-
matically ﬁngerprint 9.2% to 23% of all evaluated extensions,
with the exact percentage depending on the popularity of the
extension, and the considered threat model. Moreover, by col-
lecting extension proﬁles from 854 real users (Section IV-B),
952
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:21:24 UTC from IEEE Xplore.  Restrictions apply. 
we discovered that not only do most users utilize ﬁngerprint-
able extensions, but that many of them use different sets of
ﬁngerprintable extensions, allowing trackers to use extensions
as a way of uniquely, or near-uniquely identifying them. It
is worth pointing out that, given the current architecture of
browser-extension frameworks, we do not assign blame to the
developers of the extensions that XHOUND can ﬁngerprint.
The functionality of the majority of extensions that modify
the DOM depends on the same modiﬁcations that make them
ﬁngerprintable. To quantify this dependence, we manually
examined a random sample of 100 ﬁngerprintable extensions
and discovered that 75% of them were modifying the DOM
in accordance with the stated purpose of the extension.
Our ﬁndings demonstrate that extension-based ﬁngerprint-
ing is a real and credible threat that further complicates online
browsing. By utilizing an XHOUND-like system, advertising
companies and online trackers can,
in bulk, discover the
side-effects of browser extensions and incorporate extension-
detection code in their existing tracking scripts. As we showed
in Section IV-B, the amount of entropy that browser-extensions
provide is higher than many ﬁngerprintable attributes, such as,
canvas, that are already adopted by ﬁngerprinting scripts [6].
Moreover, since the extensions of Google Chrome users can
be synced between different machines, extension-based ﬁnger-
printing can be used for cross-device tracking.
Interestingly, our results are also likely applicable to mobile
browsers. Most mobile browsers do not support plugins (such
as Flash or Java) and hence are less susceptible to standard
ﬁngerprinting practices, than desktop and laptop browsers. At
the same time, many popular mobile browsers, like Firefox
Mobile and Dolphin Browser for Android, and Google Chrome
for iOS [32], are extendable, i.e., they allow users to install
browser extensions, much like their desktop counterparts.
Therefore, the ability to ﬁngerprint browser extensions can,
in principle, allow trackers to extract entropy from a platform
that has been long-considered, from a tracking point of view,
“problematic.”
A more subtle implication of ﬁngerprinting browser exten-
sions is that extensions, unlike plugins and other existing ﬁn-
gerprintable features, capture, to a certain extent, the interests
of users. That is, in addition to offering bits of entropy that
can be used to uniquely identify them, browser extensions
can give away the income-level of a user (e.g., extensions
that automatically search and apply coupons to various online
shops), the fact that they are not located where their browser
claims to be (e.g., VPN and geolocation-bypass extensions),
whether they are tech-savvy or not (e.g. extensions that block
ads and trackers, or those that show the security status of a
website), and even their political inclinations (e.g. extensions
that automatically remove or replace text and links that contain
keywords associated with speciﬁc political ﬁgures). All of this
information can be extracted and made part of a user’s proﬁle,
allowing further deanonymization and targeting.
B. Countermeasures
It
important
to note that
is done
is
extensions
since the ﬁngerprinting
through benign-looking DOM
of
queries, “easy” solutions, such as,
limiting access to the
navigator.plugins object [1], will not be of help for
combatting extension-based ﬁngerprinting. In this section,
we brieﬂy sketch two possible countermeasures that could
be used to combat extension-based ﬁngerprinting based on
encapsulation and namespace pollution.
Encapsulation
The idea of enhancing only the appearance of web pages is
close to the concept of Shadow DOM, which gives the ability
to web developers to encapsulate presentational widgets from
other JavaScript and CSS on the page [2]. With Shadow DOM,
a subtree of DOM elements can be rendered as a part of
a document while not being a part of the main document’s
DOM tree. For instance, to change the appearance of a web
form, a shadow subtree can be created on the top of the
form with new CSS styles, additional labels and graphics,
and also with special content elements that project original
input ﬁelds to the rendered DOM. These shadow elements
are invisible to queries from the main DOM. Indeed, there
exist examples of Chrome extensions that plan or already
adopt such techniques, e.g., Adblock Plus and AdBlock to
hide non-blocking ads without breaking a page’s layout [4].
However, since Shadow DOM is designed with the aim of
mainly separating presentation from content, it is not possible
to implement all on-page changes from extensions in the
same fashion. Although adding additional control elements
can be effectively achieved with shadow elements, particular
extensions would still require altering the main DOM tree in
order to perform the desired changes, which would require
synchronization between shadow and main elements:
• to set or update functional attributes on the original nodes,
which change the logic ﬂow of original scripts on a page
(e.g., the global document.title property)
• to change parts of the internal text, which is further
processed by a web page as an input, or to integrate
additional control elements inside the text
• to actually block or delete existing DOM nodes, such as,
ads or tracking scripts
Therefore, even though the Shadow DOM is a step in
the right direction for achieving an architecture offering
undetectable on-page changes, there are multiple challenges
that need to be overcome before this mechanism can be
effective. We plan to research these directions along with
alternative designs for encapsulation and isolation in future
work.
Namespace Pollution
Even though the results of a system like XHOUND could be
used to identify browser extensions and therefore to reduce a
user’s online privacy, they could also be used in a constructive
fashion. Namely, given a list of extensions and their DOM
953
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:21:24 UTC from IEEE Xplore.  Restrictions apply. 
side-effects, a user could pretend to have a certain number
of extensions installed by populating these side effects in a
page, without actually installing any extensions. In addition, a
dedicated anti-ﬁngerprinting extension could, for every page
load, select a random sample of DOM modiﬁcations and
apply them to the newly loaded page. This will signiﬁcantly
complicate the task of simple extension-based ﬁngerprinting
which will now have to distinguish between extensions that
are really installed, from extensions whose side-effects are
merely mimicked. A tracking script that fails to account for
these mimicries, will be computing a different ﬁngerprint for