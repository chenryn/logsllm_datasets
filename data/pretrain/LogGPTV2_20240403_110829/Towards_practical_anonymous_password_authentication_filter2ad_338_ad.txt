i=j+1
1185duction from the IND-ET security of PE. The reduction is
completed via a hybrid argument. For each j ∈ [N ] ∪ {0},
let game G4,j be the same as G4, except that replacing
[Ri]pwi with a random ciphertext Ci ∈ C for each i ∈ [j],
and rejecting any client message (X, σC ) produced by A if
(m, σ) ← CredExt(parmac, σC , (cid:96)) and m ∈ {mi}j
i=1, where
(cid:96) = (X, Y, σS). Clearly, G4,0 and G4,N are the same as
If A behaves diﬀerently between
G4 and G5 respectively.
G4,j−1 and G4,j for some j ∈ [N ] with probability j, then
we can construct an algorithm B5,j that breaks the IND-
ET security of PE via interacting with A with almost the
same probability. Speciﬁcally, B5,j is given a challenge ci-
phertext C and an equality test oracle Oet(M,·), where M
$← C for
is a random message in Me. Then B5,j picks Ci
$← Me for each i ∈ [N ]\[j]. B5,j
each i ∈ [j − 1] and Ri
executes just as in game G4, with the following exceptions:
• For each i ∈ [N ], B5,j sets the ciphertext in credi as Ci if
i ∈ [j − 1], C if i = j, and [Ri]pwi if i ∈ [N ]\[j].
• For each (m, σ) ← CredExt(parmac, σC , (cid:96)) such that m =
mi for some i ∈ [N ] where σC is produced by A, B5,j
rejects σC if i ∈ [j − 1], or i = j ∧ Oet(M, σ) = 0, or
i ∈ [N ]\[j] ∧ σ (cid:54)= Ri, and accepts σC otherwise.
If C = Encpw(M ) where pw acts as the password pwj of client
IDj, then B5,j behaves exactly as in game G4,j−1. Otherwise
(i.e., C is uniform at random in C), Oet(M,·) returns 0 for all
queries with probability at least 1 − (|D| + 1)/|Me|, since C
is independent from M and the probability that there exists
a pw(cid:48) ∈ D such that Decpw(cid:48) (C) = M is at most |D|/|Me|.
Thus, B5,j behaves exactly as in game G4,j with probability
at least 1 − (|D| + 1)/|Me|. As a result, we have
Adv4(A) − Adv5(A) =
(Adv4,j−1(A) − Adv4,j(A)) ≤
N(cid:88)
(cid:19)
(cid:18)
N(cid:88)
j=1
Advind-etPE,D(B5,j) +
j=1
|D| + 1
|Me|
≤ qse|D| + O
(cid:19)
(cid:18) N|D|
|Me|
,
where the total number of queries to Oet is bounded by qse.
Game G6 (Signature Forgery). This game is the same
as G5, except for aborting if the event abort3 that the ﬁrst
time some client instance accepts after receiving a signature
S on Y ∗ that was not output by a server instance occurs.
σ∗
Analysis. Game G6 has the same distribution as G5 if
abort3 does not occur. Thus, the diﬀerence between G5
and G6 can be bounded by a reduction from the EUF-
CMA security of DS. Let B6 be an algorithm that break-
s the EUF-CMA security of DS via interacting with A.
B6 is given a public key pk∗, and sets pk∗ as the serv-
er’s public key. B6 simulates the protocol execution as in
G5, except that B6 generates signatures for all server in-
If abort3 occurs,
stances by querying the signing oracle.
B6 outputs (Y ∗, σ∗
S) as its forgery for DS. Thus, we have
Adv5(A) = Adv6(A) + Adveuf-cma
Game G7 (Randomize Session Key). This game is the
same as G6, except for replacing session key in test session
˜U ˜δ and its partner ˜V ˜ρ with an independently random string.
Analysis. In this game, all client messages created by A are
rejected, and A cannot replay presentation proofs from client
instances since a message (Y, σS) from any server instance
(B6).
DS
could act as a nonce and collision of the nonces is excluded in
game G3. Thus, we can bound the decrease in A’s advantage
from G6 to G7 using a reduction from the DDH assumption
as follows. We construct an algorithm B7 that breaks the
DDH assumption by interacting with A. B7 is given an
instance (g, gu, gv, W ) of DDH and aims to distinguish W =
guv from a random element W ∈ G∗. B7 simulates the
protocol execution as in G6 with the following exceptions.
B7 distinguishes two cases. For case 1 that the test session
is a server session, B7 picks i∗ $← [qs] and aborts if i∗ (cid:54)= ˜δ.
If B7 does not abort, it sets Y = gv and X = gu as the
ephemeral Diﬃe-Hellman (DH) values for ˜U ˜δ and its partner
˜V ˜ρ respectively. For case 2 that the test session is a client
session, B7 picks ( ˆU , ˆδ, j∗) $← [N ] × [qc] × [qs], and aborts
if ( ˆU , ˆδ) (cid:54)= ( ˜U , ˜δ) or client instance ˜U ˜δ receives the message
that is not the output of the j∗-th session of the server. If B7
does not abort, it sets X = gu as the ephemeral DH value
for ˆU ˆδ and Y = gv as the one for the j∗-th server session.
In both cases, B7 can respond all Reveal queries (including
the sessions for Y = gv) by computing the session keys using
ephemeral DH exponents at the client side, since all accepted
messages from clients are generated by B7. For both cases,
B7 returns H2(Y, σS, X, σC , W ) as the session key of the test
session. If B7 does not abort, then B7 behaves exactly as
in G6 if W = guv, and behaves exactly as in G7 if W is
uniformly random in G∗ since H2 is a random oracle. Thus,
Adv6(A) = Adv7(A) + O
N qcqsAdvDDHG
(B7)
.
(cid:16)
(cid:17)
Overall, we obtain the bound claimed in the theorem.
Theorem 2
(Client authentication). Our APAKE
protocol P obtains clients-to-server authentication, provided
that MAC is suf-rmva secure and weak pseudorandom, the
tag-randomization is simulatable, SPK is a labeled SE-NIZK,
PE is IND-ET secure, and H1 is modeled as a random ora-
cle. In particular, we have
AdvC2SP,D(A) ≤ qse/|D| + O
+ Advsuf-rmvaMAC
+ O (N|D|/|Me|) .
(cid:17)
SPK (B2)
s /p + N AdvwprMAC(B4)
Advuzk
(B3) + N 2/|Mc| + q2
SPK(B1) + Advss-ext
(cid:16)
Proof. (Sketch) This proof is proceeded by a series of
games G0, G1, . . . , G5, where G0 is the real game for client
authentication, and G1, . . . , G5 are essentially the same as
that in the proof of Theorem 1. In game G5, all client mes-
sages produced by A are rejected, and A cannot replay pre-
sentation proofs from client instances since a message (Y, σS)
from any server instance could act as a nonce and collision
of the nonces is excluded in game G3. Thus, A cannot au-
thenticate itself to the server in game G5.
Theorem 3
(A) = Advsound
(Anonymity). If NIZK is sound, SPK is
unbounded zero-knowledge, the tag-randomization is simu-
latable, and KeyGen satisﬁes key-parameter consistency, then
our protocol P is anonymous. In particular, we have
SPK(B2).
AdvanonP
NIZK is the advantage for the soundness of NIZK.
Proof. Let A be an adversary that breaks anonymi-
ty of P. This proof will proceed via a series of games
G0, G1, G2, G3, where G0 is the real game. By Advi(A) we
denote A’s advantage in Gi, and AdvanonP
NIZK (B1) + Advuzk
(A) = Adv0(A).
where Advsound
1186Game G1 (Soundness). This game is the same as G0, ex-
cept for aborting if the ﬁrst time some client accepts a proof
π on a statement (parmac, m, σ) such that Verify(sk, m, σ) = 0.
Analysis. Since KeyGen satisﬁes key-parameter consistency,
there exists the unique secret key sk such that (parmac, sk) ∈
KeyGen(1λ). Thus, if Verify(sk, m, σ) = 0, then (parmac, m, σ)
is a false statement on NIZK. Then, we can construct an
algorithm B1 that breaks the soundness of NIZK by inter-
acting with A.
If A behaves diﬀerently between G0 and
G1, then B1 can ﬁnd a valid proof π on a false statement
(parmac, m, σ) such that Verify(sk, m, σ) = 0. Thus, we have
Adv0(A) = Adv1(A) + Advsound
Game G2 (Simulate Proofs). This game is the same as
G1, except for using the zero-knowledge simulator Sim to
generate a proof w.r.t. SPK for each challenge query.
NIZK (B1).
Analysis. G2 behaves exactly like G1, except for the sim-
ulation of the proofs for SPK. From the unbounded zero-
knowledge property of SPK, we have Adv1(A) = Adv2(A) +
SPK(B2), where B2 is an algorithm that breaks the un-
Advuzk
bounded zero-knowledge of SPK by interacting with A.
Game G3 (Simulate Tag-Randomization). This game
is the same as G2, except that for each challenge query re-
placing (T, V ) with (T (cid:48), V (cid:48)) ← TVSim(parmac).
Analysis. In G3, any message-tag pair (m, σ) accepted by
any client ID satisﬁes Verify(sk, m, σ) = 1 where m = H1(ID).
Thus, (T (cid:48), V (cid:48)) simulated by TVSim has the same distribu-
tion as real (T, V ). Then, we have Adv2(A) = Adv3(A).
Overall, we obtain the bound claimed in the theorem.
5.
INSTANTIATION OF APAKE
In this section, we instantiate the building blocks used
in our APAKE construction. In particular, we give an ex-
ample of suf-rmva secure and weak pseudorandom algebraic
MACs with eﬃcient labeled SE-NIZKs, which is a pairing-
free variant of the weak Boneh-Boyen signature scheme [11].
We denote the algebraic MAC scheme by MACSDH. The
password-based encryption scheme PE is instantiated with
an example recommended by Bellare and Rogaway [5] for
the AuthA mechanism of IEEE P1363.2 standard [39], which
satisﬁes the IND-ET security in the ROM. We use ECDSA
to instantiate digital signature scheme DS. Our instantia-
tion assumes that MACSDH, PE, DS and key exchange use
the same domain parameters par = (G, p, g).
When applying the instantiations of the building blocks to
the APAKE construction described in Section 4, we obtain a
highly-eﬃcient APAKE protocol, which is denoted by APAKE.
5.1 An SDH-based Algebraic MAC
The construction of MACSDH is described as follows.
KeyGen(1λ) takes as input a security parameter 1λ, chooses
the group parameters (G, p, g) such that p is a 2λ-bit prime,
picks γ $← Z∗
p, computes w ← gγ, and outputs sk = γ
and parmac = (G, p, g, w). We assume that (G, p, g) is an
implicit input in all the following algorithms.
MAC(sk, m) takes as input sk = γ and a message m ∈
Zp\{−γ}, computes A ← g1/(γ+m), and outputs σ ← A.
Verify(sk, m, σ) takes as input sk = γ, a message m and a
tag σ = A, and outputs 1 if Aγ+m = g and 0 otherwise.
Using the techniques in [11], we can prove that MACSDH
is suf-rmva secure under the q-SDH assumption. Using the
techniques in [11, 30], we can also prove that MACSDH is
weak pseudorandom under the q-DDHI assumption. The
detailed proofs can be found in Appendix A.
It is easy to see that KeyGen satisﬁes the key-parameter
consistency, as (g, w) uniquely determines the secret key γ.
The MACSDH allows an eﬃcient proof system NIZK{(γ) :
Aγ = A−mg ∧ gγ = w}, which is constructed using the Fiat-
Shamir heuristic [33] to transform the corresponding Sigma
protocol, and is shown as follows.
• On input a statement (g, w, m, A) and a witness γ, the
prover picks r $← Zp, computes R1 ← Ar, R2 ← gr, c ←
H3(g, w, m, A, R1, R2) and s ← r + cγ mod p. Finally, it
outputs a proof π = (c, s).
• The veriﬁcation algorithm VerifyNIZK takes as input a state-
ment (g, w, m, A) and a proof π = (c, s), and calculates
c(cid:48) ← H3(g, w, m, A, As+cmg−c, gsw−c). Then it outputs 1
if c = c(cid:48) and 0 otherwise.
Using the techniques in [50], one can prove that the NIZK is
sound and unbounded zero-knowledge in the ROM.
Credential Presentation. The credential presentation al-
gorithms Show and ShowVerify for MACSDH are constructed
by SPK{(m, a) : T −mga = V }((cid:96)) for T = Aa, and the SPK
is instantiated by Fiat-Shamir transformed Sigma protocol.
• Show(m, σ, (cid:96)) : On input a message m, a credential σ = A
and a label (cid:96), Show picks a $← Z∗
p and computes T ← Aa.
$← Zp, computes R ← T −rm gra , c ←
Then it picks rm, ra
H4(g, T, R, (cid:96)), sm ← rm + cm mod p and sa ← ra + ca
mod p, and sets Σ = (c, sm, sa). Finally, Show outputs a
presentation proof σC = (T, Σ).
• ShowVerify(σC , (cid:96), sk) : On input a presentation proof σC =
(T, (c, sm, sa)), a label (cid:96) and sk = γ, ShowVerify computes
V ← T γ, R(cid:48) ← T −sm gsa V −c and c(cid:48) ← H4(g, T, R(cid:48), (cid:96)).
ShowVerify returns 1 if T (cid:54)= 1 and c = c(cid:48), and 0 otherwise.
It is easy to see that Rerand, Derand, fp and fv are spec-
iﬁed as follows: Rerand(A) picks a $← Z∗
p, computes T ←
Aa, and outputs (T, a); Derand(T, a) outputs A ← T 1/a;
fp(parmac, T, m, a) = T −mga and fv(T, sk) = T γ.
The simulator TVSim is constructed as follows: given
parmac = (G, p, g, w), TVSim chooses t
p, computes
T (cid:48) ← gt and V (cid:48) ← wt, and outputs (T (cid:48), V (cid:48)). Note that
V (cid:48) = wt = (T (cid:48))γ and T (cid:48) has the same distribution as T
generated by Rerand(A).
$← Z∗
To obtain better eﬃciency, we do not involve V to σC
following [24]. The reason behind this is that an online ex-
tractor Ext for SPK without knowing V can be obtained in
the combined random oracle and generic group model fol-
lowing along the lines of [53, 56, 24]. The zero-knowledge
simulator Sim for SPK can be constructed as follows: giv-
en a statement (g, T, V ) and a label (cid:96), Sim randomly picks
c, sm, sa ← Zp and programs the random oracle H4 such
that H4(g, T, R, (cid:96)) = c with R = T −sm gsa V −c, and outputs
Σ ← (c, sm, sa). Overall, the SPK is a labeled SE-NIZK.
Eﬃciency of Credential Presentation. For anonymous
credentials, a presentation proof is usually generated using
1187Table 1: Comparison of APAKE Protocols
APAKE
[60]
[54]
[62]
APAKE
Computation overhead
Server
Client
4EG
5EG + 1Dec
8EG1 + 1E2G1
1E5G1
+ 2P
3EG + 2E2G