是否有 DDL，如果有还是需要特别注意的。
自动提交事务。所以后续的操作就直接无法回滚了。由此我们需要注意的就是在脚本中
策略4：剔除脚本里面的 DDL，分开单独执行，脚本只保留了那3条 insert，然后我
小结：在开启事务部署的方式中需要注意是否存在DDL语句，如果存在，尽管存在
Query OK, 1 row affected (0.01 sec)
mysql> begin;
mysql> select*from test_abc;
很不幸，没有任何反应。
Query OK, 0 rows affected (0.00 sec)
mysql> rollback;
我们来尝试回滚。
2 rows in set (0.00 sec)
对于事务的完整性，还有两点需要验证：第一个是事务正常退出，事务是回滚还是
所以还是尽可能在事务里来控制吧，毕竟MySQL 是默认自动提交的，后悔了都来不及。
mysqi> select
Query OK,
mysql> rollback;
果断回滚，会发现数据可以达到我们的预期了。
2 rows in set
mysql> select *from test_abc;
这个时候查看数据，id为1和3 的结果都在。
ERROR 1366(HY000):Incorrect integer
Query OK,
Query OK,
id|name
没有反应的主要原因是什么呢，其实是第一句是一个create 语句，是DDL 语句，会
 rows in set
ee
sourcetest
row affected (0.00 sec)
(0.00 sec)
(0.00 sec)
 affected (0.09 sec)
r value: 'aa' for column 'id' at row 1
---
## Page 197
高效完成，但是 DDL 会锁表，影响业务流程；同时在变更过程中系统负载和空间都是一
5.1.2
更的条目有几百个，如果明白了这些，在具体业务的操作中至少会长个心。
显，事务做了回滚。
数据库的DDL操作非常多，如添加索引，添加字段等等，我们都希望这个工作能够
通过上面的测试我们可以很清晰地知道这些可能的场景和具体的应对策略，假设变
Empty set(0.00 sec)
mysql> select *from t1;
重新登录来验证，会发现事务已经回滚了。
mysql> exit
Query OK, 1 row affected,
小结：在部署脚本中只含有DML语句，推荐这种部署方式，相对来说可控。
mysql>
mysql> begin;
正常退出。
另外一个则是正常退出情况下的，如下：
No connection. Trying to reconnect..
查询的时候，会发现原来的会话其实已经杀掉了，会自动开启一个新的会话。很明
然后打开另外一个窗口，kill掉当前执行的会话。然后继续观察。
mysql>
Query OK，
mysql> begin;
row in set (0.00 sec)
col1丨co12
我们一
通过对比来了解 online DDL
1lffl
select
insert
个
一个来测试，先来看 kill会话的部分，如下。
0rows affected (0.00 sec)
0 rows affected (0.00 sec)
*from t1;
intc
639
test
: MysQL server has gone away
abc
0 warning (o.o0 sec)
abc
valu
第5章MySQL运维管理实践丨175
---
## Page 198
176丨MySQL DBA工作笔记：数据库管理、架构优化与运维开发
作，不好意思，这类操作就会阻塞，持续时间会很长。
做数据的复制，而且这个过程中是全程阻塞的。
上的重大突破会逐步降低维护的复杂度，所以水涨船高，各行各业都有相似之处。
展的很不错了，如此一来，pt-osc 的支持算是一种可选的方式。而由此也可以看出，技术
功能全面，支持的完善，现在基本上成了标准的行业工具，简称 pt-osc。
面不断权衡，online DDL 的方案就是一剂良药。
种潜在的挑战，所以对于 DBA来说这是一种两难的状态，DBA 需要在在性能和稳定性方
tate
早期是Facebook 来做的这件事情，后来 Percona 进行了改变，使用 Perl实现，因为
insert into newtest (game_type,login_time,login_account,cn_ master,
在MySQL5.6版本开始推出的online DDL中，已经原生支持，在5.7版本中已经发
在 MySQL 5.7版本中差别就很大了。
当然这个阻塞的时长还是很不乐观的，可能几分钟，甚至数十分钟，这取决于表的大小。
如果查看 show engine innodb status\G 的结果，会发现一些很细致的锁信息。
如果查看 show processist 的结果，就会发现临时表复制的信息和锁的信息，如图 5-4。
在 MySQL 5.5版本中，如果在 DDL 执行过程中，在另外一个窗口中做一个insert 操
-rw-rw--
MySQL 原生的操作就是创建一个临时的表，开始表数据的复制。
alter table newtest add column newcol varchar(10) default '';
-rw-rw-
-rw-rw----
比如我们添加一个字段，添加默认值。
案例5-3：MySQL5.7版本原生的DDL代价测试
为什么 MySQL 5.5 版本中很多 DDL 操作的代价很高呢。因为很多场景的处理都是在
案例5-2：MySQL5.5版本原生的DDL代价测试
我们先来看一下 online DDL 的一个案例，再来分析 pt-osc。
一模一样的操作，在 MySQL 5.7版本中还是创建一个临时数据表的数据复制。
oh
1 mysql mysql
mysql
mysql
mysql
mysql
NULL
Info
58720256Dec
3162505216
150581500032
8840 0ct 13 17:04 newtest.frm
图5-4
Oct
511:25 #sql-2931
13
4807af.frm
ibd
---
## Page 199
实现的差异。
old_alter_table 参数默认为 OFF，表示采用 inplace 的算法。
copy、inplace 和 default 可选，3个选项的含义如下：
5.1.3
量数据，然后更新数据字典，使得 schema 配置生效。
能保持同步。在commit 阶段会升级为EXCLUSIVE-MDL 锁，禁止读写，
降级EXCLUSIVE-MDL锁，这个时候允许读写，同时不断处理增量数据，使得数据尽可
生成相应的.frm，.ibd文件，同时持有EXCLUSIVE-MDL 锁，禁止读写。在DDL阶段会
row-log，在基线变更结束后，回放 row-log，实现增量同步。
了基线和增量两个部分。其中会开启一个线程来变更基线数据，同时将增量数据写入
DDL的实现原理。
我们测试的数据有2000多万，数据量足够大，会把操作中的差异效果放大，便于对比。
在实现中是分成了三个阶段：prepare，ddl和commit。其中 prepare阶段会获取快照
在 online DDL 中，是官方在内部自定义线程来实现的。主要原理是把整个过程分为
假设我们有表 newtest，然后对这个表进行 DDL 操作，来通过不同的操作选项来对比
案例5-4：对比测试online DDL的两种算法（copy 和 inplace）
我们使用一个案例来说明下。
（3） default 表示根据参数 old_alter_table 来判断是通过 inplace 还是 copy 的算法,
（2）inplace 表示不需要创建临时表，对当前的数据文件进行修改。
（1）copy 表示执行 DDL 时会创建临时表。
其实有一个很关键的点没提到，那就是 online DDL 的算法，目前有3个操作选项：
ALTER TABLE的补充语法如下：
以上测试的场景都是使用了默认的选项 copy 而非 inplace，我们接下来看一下 online
但是基于online DDL的处理策略，同样的 DML 语句全然没有压力。
-rw-r--
rw-r-
-rw-r-
Online DDL 的两种算法
1mysqlmysql
mysql
Au
46137344 Dec 5 17:33 #sql-ib276-3638407390.ibd
：3900702720
8840
8874 Dec 5 16:47 newtest.frm
t
Dec
Dec
517:33
5
#sql
第5章MySQL运维管理实践丨177
9989e.frm
，处理最新的增
---
## Page 200
178
Command
会有 table metadata lock的字样。
塞，如下：
数据是平行复制一份。
|MySQL DBA工作笔记：数据库管理、架构优化与运维开发
|Id
这个时候查看 show processlist 的结果，相比就显得有些简单了，不像之前的版本中
values(1, '2017-02-27 16:22:10
> insert into newtest (game_type,login_time,login_account,cn_master, client_ip)
+--
因为使用了主键自增，所以我可以用同样的语句再插入一条记录，也是全然没有阻
> insert into newtest (game_type,login_time, login_account,cn _master,
在这个变更的过程中，是运行 DML 操作的，而且没有任何阻塞。
这个变更过程会生成两个临时的文件.frm 和.ibd。
alter table newtest add column newcol varchar(10) default '';
比如我们运行下面的 SQL 语句，添加一个字段，默认情况下是使用copy 的算法，即
（1）默认的copy选项
Create Table: CREATE TABLE
*show create table newtest\G.
-rw-r-
-rw-r-
-rw-r-----
V
表结构信息如下：
row in set (0.00 sec)
22681426
cn_master
gametype
ogin
Table: newtest
Lent
ind
Time
account
User
1 mysql mysql
1 mysql mysql
1 mysql mysql
1p
login
mysql mysql 4353687552 Dec
(45.76 sec)
varchar(100)
varchar(100)
datetime NOT
time
IState
NOT
16:22:10
enewtest
DEFAULT
NOT
Host
NULL
150581500032'，572031626′,183.128.143.113)
8874 Feb 27 22:25 #sql-6273_2980ab.frm
NULL DEFAULT
DEFAULT
INCREMENT,
.ogin
518:45 newtest.ibd
db
---
## Page 201
为10分钟左右。
来对比它们的差异。
信息，#sql-6273_2980ab.frm 是临时生成的表结构信息，我们使用如下表5-1所示的表格
Query
Records: 0 Duplicates:0
Query
我们换一个角度来看，例如我们删除一个字段，如下：
可以看到修改后的.ibd文件大小相比要大了一些。
Records: 0 Duplicates:0
Query OK,
> alter table newtest add column newcol varchar(10) default '';
-rw-r-----
可以通过 strings 的方式看到一个基本的结构信息，newtest.frm 文件是原本的表结构
对比临时文件和现有配置文件，我们简单看看上面列举出来的配置文件.frm。
rw-r--
2719915 丨 root
OK,
ind_login_time_newtest
# strings newtest.frm
ind_tmp_account1
1mysql mysql
login_account
login_account
cn_master
login_time
game_type
cn_master
login_time
game_type
PRIMARY
rows
rows
client_ip
client_ip
InnoDB
75丨 altering table
Warnings:0
(9 min 54.18 sec)
Warnings:0
8874 Feb 27 22:25 newtest.frm
localhost
表5-1
sec)
# strings "#sql-6273_2980ab.frm"
ALGORITHM=INPLACE;
ind_login_time_newtest
ind_tmp_accountl
login_account
login_account
cn_master
game_type
login_time
game_type
PRIMARY
client_ip
login_time
client_ip
cn_master
newcol
newcol
InnoDB
第5章MySQL运维管理实践丨179
Itest
---
## Page 202
180丨MySQL DBA工作笔记：数据库管理、架构优化与运维开发
结合具体的场景和需求来考量。
分钟，差别已然非常明显。
创建一个索引，即可得到一个基本的对比情况。
字段是一个数据重组的过程，所以相比而言，这个操作的代价也是昂贵的。
整个过程中因为.ibd 文件较大，持续时间也会增加很多，这个环境中执行时间是 29
 alter table newtest add index (client_ip)
小结：Online DDL 还是存在着一些限定情况的，很多场景还没有完全测试到，需要
Records: 22681430
而如果我们为了对比同样的 inpalce 和 copy 操作场景下的代价，可以使用 copy 显示