“handed off” to another, supporting expression of the delegation of
authority. The Says modality is typically taken to ascribe beliefs to
principals and can be used to express authorized credentials among
others, but the precise interpretation of Says is a subtle matter with
significant consequences. We discuss this issue here as it is relevant
to our proof representations.
2.1.1 Monadic Interpretation of Says. The Says modality has
historically been related to classical modalities. The interpretation
of Says in the original presentation of Nexus Authorization Logic
[35] (NAL) can formally be said to be lax and in particular can be
embedded in the logic S4 [16]. Intuitively, the lax interpretation
allows a more liberal ascription of beliefs to principals. Formally,
a lax system includes the axiom ∀X .X ⇒ A Says X (whereas in
CCS ’19, November 11–15, 2019, London, United Kingdom
Skalka et al.
Syntax
F, G, H
::=
|
|
|
|
|
|
|
|
|
f (t, ...)
true
false
F Says F
X
F ∧ F
F ∨ F
F ⇒ F
∀X .F
∃X .F
Proof Derivation Rules
True
∆ ⊢ true
Assume
∆, F ⊢ F
∨-IntroL
∆ ⊢ G
∆ ⊢ F ∨ G
∀-Intro
∆ ⊢ F
∨-IntroR
∆ ⊢ F
∆ ⊢ F ∨ G
X (cid:60) fv(∆)
∆ ⊢ ∀X .F
∆ ⊢ F
Unit
∆ ⊢ A Says F
∨-Elim
∆ ⊢ F ∨ G
Bind
∆ ⊢ A Says F
∆, F ⊢ A Says G
∆ ⊢ A Says G
⇒-Intro
∆, F ⊢ G
∆ ⊢ F ⇒ G
⇒-Elim
∆ ⊢ F ⇒ G
∆ ⊢ G
∆ ⊢ F
∆, F ⊢ H
∆ ⊢ H
∆, G ⊢ H
∧-Intro
∆ ⊢ F
∆ ⊢ G
∆ ⊢ F ∧ G
∧-ElimL
∆ ⊢ F ∧ G
∆ ⊢ F
∧-ElimR
∆ ⊢ F ∧ G
∆ ⊢ G
∀-Elim
∆ ⊢ ∀X .F
∆ ⊢ F[G/X]
∃-Intro
∆ ⊢ F[G/X]
∆ ⊢ ∃X .F
∃-Elim
∆ ⊢ ∃X .F
∆, F ⊢ G
∆ ⊢ G
X (cid:60) (fv(∆) ∪ fv(G))
Figure 2: NALlight syntax and proof derivation rules.
a non-lax system we can only deduce X ⇒ A Says X if X is a
theorem). While the lax interpretation of Says has been assumed
by other systems, various authors have suggested that it can lead
to dangerous consequences [1, 17, 19]. This includes the authors of
a more recent version of Nexus Authorization Logic, called FOCAL,
who refer to the lax interpretation of Says in NAL as a “bug” [19]. A
thorough formal study of lax vs. non-lax interpretations identifies
the core issue as the axiom of escalation [3] which results from
extending classical logic with a lax interpretation of Says:
∀X , Y .(A Says X) ⇒ (X ∨ A Says Y)
However, since NAL is not classical—in particular it lacks negation
and the law of excluded middle—it does not exhibit escalation. Fur-
thermore, it enjoys the properties of Says transparency and handoff,
which are desirable in any authorization logic. The former means
that any principle can be trusted to assert their own worldview,
whereas the latter supports delegation of authority in distributed
settings. The use of NAL also has implementation benefits—lax
logic can be interpreted monadically, and a monadic interpreta-
tion of Says readily supports a Curry-Howard isomorphism with
typed monadic structures in a functional calculus (as we show in
Section 2.1.4).1 Thus terms in the calculus can constitute proof wit-
nesses, which enables optimization techniques (e.g., certain types
of reduction).
Another important point is that in a proof checking system, be-
liefs relevant to a judgment are explicitly provided as a component
of the judgment. And in the PCNC implementation (see Section 5.1),
beliefs provided to support a proof are always cryptographically
signed and thus ascribed to a principal (i.e. the signer). Therefore,
problems with “importing beliefs” as a consequence of laxity noted
by Hirsch et al. [19] are ameliorated in our setting. For these reasons,
in PCNC we build on NAL.
2.1.2
Syntax and Proof Theory of NALlight. In Figure 2 we present
the syntax and proof theory of the logic NALlight in a judgmental
style. The logic NALlight is a simplified fragment of NAL with a
streamlined set of atomic principals A rather than the more com-
plex principals used by Schneider et al. [35]. These principals are
encoded using a subset of nullary atomic formulas (rather than
introducing a new kind of term in the grammar)—an approach that
simplifies our encoding of formulas as types. In particular, we do
1Though it should be noted that a Curry-Howard isomorphism with non-lax modalities
can be formulated, as demonstrated in [31].
not need two forms of universal quantification (i.e., over first- and
higher-order constructs) as in the original system [35].
Our proof theory also differs slightly from the original formu-
lation but captures the same principles of deduction. Aside from
the judgmental presentation, we define Unit and Bind rules which
are known to be inter-derivable with the rule forms in the original
definition (including idempotence, distribution, and necessitation).
Also, we allow higher-order (vs. first-order) existential quantifi-
cation. These design choices yield a tighter Curry-Howard cor-
respondence with the system we present in Section 2.1.4. Note
that negation and the law of excluded middle is not supported in
NALlight, hence it is not classical and not subject to escalation [3].
We will use letters A, B, C to refer to principals, while F, G, H
refer to formulas. Formulas include universal (∀) and existential
(∃) quantification, and standard logical connectives (∧, ∨, and ⇒).
Predicates f on terms t are left abstract and represent application-
level assertions. In PCNC, we will be concerned with assertions
about behavioral policies, so this logic allows verification of autho-
rization and behavioral policy components to be synergized. We
only require that variable X are allowed to appear in term position
in predicates, thus supporting first-order quantification.
The logic includes a Says modality as a primitive. However the
SpeaksFor modality is defined as syntactic sugar in terms of higher-
order quantification:
A SpeaksFor B
≜
∀X .(A Says X) ⇒ (B says X)
A restricted form of delegation is also supported,
A SpeaksFor B on (X1 · · · Xn : F)
∀X1. . . . .∀Xn .(A Says F) ⇒ (B says F)
≜
where X1 · · · Xn only occur in term positions in F—i.e. they are
first-order variables.
2.1.3 Complexity of Proof Inference and Verification. Because
NALlight subsumes a higher-order constructive logic it is highly
expressive. At the low end of expressiveness, intuitionistic proposi-
tional logic is PSPACE-complete [38], while intuitionistic predicate
logic is undecidable—and these are first-order. Both can be embed-
ded in NALlight, which is a higher-order constructive predicate
logic, so in general NALlight proof inference is also undecidable.
But checking NALlight proofs is linear in the size of the proof term,
since each deduction step involves only simple syntactic checks.
Proof-Carrying Network Code
CCS ’19, November 11–15, 2019, London, United Kingdom
τ (cid:70) unit | τ + τ | τ × τ | τ → τ | X | ∀X .τ | ∃X .τ |
τ Says τ | reconfig(τ) | extend(τ) | τ ≼ τ | p | A
e (cid:70) tt |
inl(e) as · + τ | inr(e) as τ + · | case(e){x .e }{x .e } |
⟨e, e⟩ | projl(e) | projr(e) |
x | let x (cid:66) e in e | λ(x : τ).e | e(e) |
ΛX .e | e[τ] | ⟨∗τ , e⟩ as ∃X .τ | let ⟨∗X, x⟩ (cid:66) e in e |
retA(e) | x ← e ; e | e ≼ e | p
Bind
S, Γ ⊢ e1 : A Says τ1
S, Γ[x (cid:55)→ τ1] ⊢ e2 : A Says τ2
S, Γ ⊢ x ← e1 ; e2 : A Says τ2
TypeApply
S, Γ ⊢ e : ∀X .τ
S ⊢ τ ′
S, Γ ⊢ e[τ ′] : [τ ′/X]τ
Syntax
types
terms
Typing
Ret
S, Γ ⊢ e : τ
S, Γ ⊢ retA(e) : A Says τ
Figure 3: Selected System FSays syntax and typing rules.
2.1.4 Proof Representation: System FSays. Judgments are of the
form ∆ ⊢ F, where ∆ is a list of assumptions, considered equivalent
up to reordering. Validity of judgments is defined as derivability by
inductive application of the derivation rules defined in Figure 2. If
∆ is empty (and hence F is a tautology) we write ⊢ F.
To represent proofs in a compact and verifiable manner, we
introduce the language System FSays which enjoys a Curry-Howard
types-as-formulas correspondence with NALlight. This approach
has been explored previously for a different authorization logic [2].
The syntax of System FSays is presented in Figure 3, where x
and X are type and term variables respectively. The language is
an extension of System F with a Says monad to represent the Says
modality in NALlight, and other features to represent NALlight con-
nectives. Types τ of System FSays have a tight correspondence with
NALlight formulas F. The System F fragment of System FSays is ad-
equate to represent implication and higher order quantification as
in NALlight, and the addition of sum (+) and product (×) types are
adequate to represent disjunction and conjunction. The Says monad
is realized using return and bind terms. Existential quantification
is realized using standard pack and unpack terms.
We introduce System FSays here specifically for PCNC, so we
only include three atomic predicate forms: reconfig, extend, and
≼. The first two of these are parameterized by NetKAT programs
and are unary, while the latter is binary. The predicate reconfig(p)
asserts the intent to install configuration program p, extend(p)
asserts the intent to extend the current configuration with program
p, and p ≼ q asserts semantic containment of p in q.
Type validity is defined in terms of judgments are of the form
S, Γ ⊢ e : τ. Here, Γ is an environment binding free term variables
to types, and S is the set of type variables in scope. Considering
the type τ as a NAL formula analogue, the term e is referred to as a
witness. The type derivation rules have a tight correspondence with
the NALlight natural deduction rules shown in Figure 2. These rules
are mostly standard and include System F-style polymorphism,
existential quantification, etc. As shown in Figure 3, to support
judgments involving the Says modality, we include monadic typing
rules for return and bind constructs. See the appendix for the full
typing rules.
f (cid:70) f1 | · · · | fk
h (cid:70) pk::⟨⟩ | pk::h
Syntax
Field
Packet pk (cid:70) {f1 = v1, · · · , fk = vk }
History
Predicate a, b (cid:70) 1
Id
| 0
Drop
| f = n Test
| a + b Or
| a · b And
| ¬a
Not
Policy p, q (cid:70) a
Filter
| f ← n Modify
| p + q Union
| p · q Sequence
| p∗
| dup
Iterate
Duplicate
Denotational Semantics
{}
otherwise
(cid:74)p(cid:75) ∈ H → P(H)
(cid:74)1(cid:75) h ≜ {h}
(cid:26){pk::h} if pk.f = n
(cid:74)0(cid:75) h ≜ {}
(cid:74)f = n(cid:75) (pk::h) ≜
(cid:74)¬a(cid:75) h ≜ {h} \ ((cid:74)a(cid:75) h)
(cid:74)f ← n(cid:75) (pk::h) ≜ {pk[f (cid:66) n]::h}
(cid:74)p + q(cid:75) h ≜(cid:74)p(cid:75) h ∪(cid:74)q(cid:75) h
(cid:74)p∗(cid:75) h ≜
(cid:74)p · q(cid:75) h ≜ ((cid:74)p(cid:75) •(cid:74)q(cid:75)) h
where F 0 h ≜ {h}
and F i +1 h ≜ ((cid:74)p(cid:75) • F i) h
(cid:74)dup(cid:75) (pk::h) ≜ {pk::(pk::h)}
i∈N F i h
Figure 4: NetKAT: syntax and denotational semantics.
2.1.5 Types-as-Formulas Correspondence. Our main result for
System FSays is soundness of the representation—i.e., we show that
if a System FSays term is typeable at type τ, the formula correspond-
ing to τ is derivable. The issue of completeness is left as an inter-
esting topic for future work—note that we do not support arbitrary
atomic formulas in System FSays nor an explicit false term.
Since the syntax of types and formulas used in System FSays and
NALlight respectively do not match up, we define an interpretation
of types as formulas denoted ⟨τ⟩:
⟨τ1 ≼ τ2⟩ = ⟨τ1⟩ ≼ ⟨τ2⟩
⟨τ1 + τ2⟩ = ⟨τ1⟩ ∨ ⟨τ2⟩
⟨τ1 → τ2⟩ = ⟨τ1⟩ ⇒ ⟨τ2⟩
...
and so on. We extend this interpretation pointwise to type environ-
ments, which translate to lists of assumptions in NALlight. Then we
can state the types-as-formulas correspondence isomorphism as
follows, using this translation. The results follow by induction on
derivations, and is straightforward due to the tight correspondence