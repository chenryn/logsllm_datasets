# CVE-2018-15982漏洞详细分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
好久没分析漏洞了，趁着最近Flash 0day的热度再来玩一波。
## 0x1 提取内嵌swf
拿到的样本是个docx文档，解压后发现内嵌有一个activeX控件，根据控件的classid能够判断出是一个Flash动画相关：
分析activeX1.bin文件，在其偏移0xa08位置发现了flash动画文件的标志头：
直接将该位置到文件尾部的数据截取下来，然后用010edit的swf文件模版修正一下格式去掉多余数据后可以提取出被插入的原swf文件：
## 0x2 样本攻击流程分析
攻击样本是个docx文档，一开始可能会以为是利用的office漏洞，其实从上文的分析也能看出实际是利用flash漏洞，文档打开并不会自动运行，需要诱导选择播放flash漏洞后才能触发。
仔细分析后才知道作者是在页眉处插入了上文提取出来的swf文件：
这里啰嗦一下如何在word文档中插入这类动画，首先在开发工具中点击插入其他类型的控件，然后选择“Shockwave Flash Object”类型：
插入控件后右键设置一下属性，主要将其中“EmbedMovie”（内嵌影像）设置为True，并指定一下要插入的swf动画文件路径保存即可。
然后只要受害者打开word文档后选择播放动画就会运行swf漏洞文件，之后的任务主要由该文件独立来完成，当然该文件最终的功能是执行两条CMD命令来运行外部程序（攻击时打包在同一个压缩包里）：
其实Flash漏洞与浏览器组合更经典，直接打开url链接就能中招：
## 0x3 Flash调试环境配置
近些年来Flash漏洞频繁爆出，主要和其产品Flash
Player有关，swf文件正是该产品使用的动画载体文件，和PE文件类似，这种文件也是将动画脚本（Action
Script，一种类似java的脚本语言，目前发展到版本3，简称AS3）编译成二进制，然后供Flash
Player引擎解析执行。既然是编译的，也就能够反汇编和反编译，本文直接使用一款工具“AS3
Sorcerer”对swf漏洞文件进行反编译，可以看到该swf程序没有进行代码混淆，反编译出来的代码和源码非常接近，这使得分析工作相对轻松了不少。
既然伪源码都出来了，那我们当然希望能够直接通过该代码来从源码级别分析这个漏洞，因此需要先搭建一下Flash的编译和调试环境，本小节主要介绍一下大概的安装配置步骤，已熟悉的可直接跳过到下一章节。
首先，贴出Flash开发环境的官方链接。
引导页：
产品：
Flash Player：
Air SDK下载：
AS文档：
编译Flash动画一般使用两种软件：Adobe Flash Builder或Adobe Flash
Professional，本文主要介绍的是第一种。从上述产品链接中找到Flash Builder下载安装，windows平台分32位和64位版本。
安装过程需要注册，具体可自行网上找按照教程，嘿嘿~
安装完成后，主要还需要搭配一下Flash Player和Air
SDK的版本，让IDE可对指定版本Flash文件进行调试，也能支持编译指定版本的Flash文件。
先说Air SDK吧，下载指定版本的SDK（SDK and
Compiler）后，分别在安装目录下的“sdks\4.6.0”（最新）和“\eclipse\plugins\com.adobe.flash.compiler_4.7.0.349722\AIRSDK”这两个目录解压覆盖SDK包即可。
再来说说Flash
Player的版本，依然是下载指定版本的FP包，比如本漏洞环境要求版本为31.0.0.153及之前版本（太早的也不行，某些包库不支持），就下载个31.0.0.108的包为例吧，一般其中会包含Debug和Release两种版本的环境包，并且每种版本还分位多种运行环境的程序，我们进行编译和调试主要使用Debug中的ax和sa两种程序，将之放置到Flash
Builder安装目录的对应位置如下，其中ax需要运行安装：
sa版本其实本文用不到，其路径设置也可以直接在IDE中指定：
还有IDE也可以设置Flash项目调试使用的浏览器：
一切配置好后就可以开始进行调试分析了，以下为IDE调试配合OD观察对象内存，从IDE中可以看到的对象地址为该对象的实际内存地址加1：
## 0x4 漏洞成因分析
开始进入本文的主角——Flash漏洞的分析，下文展示代码是对反编译出来的伪源码分析理解后重新命名了变量、函数等符号的结果，也是为增加可读性方便理解。
首先分配和释放多次内存，为后续控制内存分配做好准备，此为漏洞利用的常用步骤。
其中触发垃圾回收的函数“gc_clean()”，内部实现如下，实现原理是连续两次connect同一个连接将引发异常，自动运行垃圾回收器，将未被引用的空闲内存进行回收。
接着就到达引发本次漏洞的关键代码了，主要发生对象是Metadata。这种对象有点类似python中的字典，用于存储一系列的“键——值”对。漏洞则发生在该对象增加键值的方法函数“SetObject”中，该函数在存储“键”对象的时候，没有对该对象进行所谓的“DRCWB”，这里可以先简单理解为没有给“键”对象加个引用计数（如下代码中“键”对象引用计数为0），导致攻击者可以利用此点通过执行“gc_clean()”来强制回收“键”对象的内存，从而获得垂悬指针，进而可以进行“UAF”漏洞利用。