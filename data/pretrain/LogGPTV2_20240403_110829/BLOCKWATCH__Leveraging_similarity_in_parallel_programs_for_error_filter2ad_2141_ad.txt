LOC in
parallel
section
Total
number
of
branches
continuous
ocean
FFT
FMM
non-
continuous
ocean
radix
raytrace
water-
nsquared
5329
4217
1086
4772
3549
1112
10861
2564
561
3246
2487
441
7709
1474
876
110
395
543
99
726
144
Number
of
branches
in
parallel
section
785
44
321
478
35
268
103
Performance Evaluation: We evaluate the performance
overhead of BLOCKWATCH on a 32-core processor that con-
tains four 8-core AMD Opteron 6128 processors running at 2
Ghz each. In order to study the performance overhead and the
scalability of BLOCKWATCH, we vary the number of threads
from 1 to 32 and measure the time spent in the parallel section
of the program, both with and without BLOCKWATCH. We
do not measure the checking time of monitor thread, as the
monitor thread is executed asynchronously and hence does not
have a signiﬁcant effect on the execution time of the program’s
parallel section. The SPLASH-2 programs can scale to at least
64 threads [13].
To measure the performance with 32 threads, we disable the
monitor thread during the execution of the main program so as
not to interfere with it. This is because our machine has only
32 cores and we need 33 threads to execute the program with
the monitor 7. We have veriﬁed that the difference in execution
times is negligible under this scenario for the 16 thread case.
Note that the threads still send the branch information to the
front-end queues of the monitor - the only difference is that
the monitor does not do anything with the information.
False Positives: To verify there are no false positives, we
perform 100 error-free runs for each program instrumented
by BLOCKWATCH and check if there are errors reported by
it. The results show that BLOCKWATCH does not report any
errors, i.e., there are no false positives.
Coverage Evaluation: We evaluate the error detection
coverage of BLOCKWATCH through fault injection studies.
Specially, we focus on detections of Silent Data Corruptions
(SDCs). SDCs are failures in which the program ﬁnishes
7We cannot set the thread number to 31 because the SPLASH-2 benchmarks
require the number of threads to be a power of 2.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:48:23 UTC from IEEE Xplore.  Restrictions apply. 
executing but the output deviates from the golden result in
an error-free run. In this paper, we focus on SDCs because
crashes and hangs can be easily detected through other means
(e.g., heartbeats). Further, the program can be restarted from
a checkpoint upon a crash or a hang, and continued.
We build a fault
injector with the PIN tool [19]. PIN
is a dynamic instrumentation framework for programs on
X86 processors. The goal of the fault injector is to simulate
transient hardware faults that propagate to a branch instruction
in exactly one thread of the program. We focus on branch
instructions because BLOCKWATCH targets hardware faults
that propagate to the control data of programs (i.e., data used
by branches) in this study.
The fault injection procedure consists of three steps. First,
we instrument an m-thread program using PIN and record the
number of branches executed by each thread of the program
at runtime (say ni where 0 < i < m). In the second step,
we randomly pick a thread from 1 to m, say j, and choose
the jth thread to inject faults. Then we select a number from
1 to nj, say k, and choose the kth branch of jth thread
at runtime to inject. Thirdly, we ﬂip a single bit in either
the ﬂag register or condition variable of the chosen branch
instruction of jth thread. The former fault leads to the branch
being ﬂipped, i.e., going the wrong (but legal) way. This
is to verify the correctness of BLOCKWATCH in detecting
branch runtime behavior deviations. The latter fault may or
may not lead to the branch being ﬂipped. For example, a
fault in a branch condition that ﬂips the least signiﬁcant bit of
the condition variable, may not affect the comparison being
performed by the branch. However, the corruption introduced
in the condition variable will persist even after the execution
of the branch, and is more representative of hardware faults
in the control data. This is to verify that the effectiveness of
BLOCKWATCH in detecting control-data errors. Only one fault
is injected in each run of the program to ensure controllability.
Because PIN can monitor all executed instructions in the
injection considers all branches in the
program,
program, and is not restricted to those that are instrumented by
BLOCKWATCH. However, we do not consider the instrumen-
tation added by BLOCKWATCH for injection, as errors that
affect these branches can at worst lead to additional crashes
or hangs, but not to SDCs, as they do not affect the program.
After injecting the fault, we track its activation and whether
it is detected by the monitor. If not, we let the program execute
to completion (if it does not crash/hang), and compare the
results with the golden result to measure the SDC percentage.
For each experiment, we inject 1000 faults of each type
and count how many faults are activated (over 75% of the
injected faults are activated in our experiments). We calculate
the coverage as the probability that an activated fault will not
lead to an SDC [20]. In other words, coverage = 1− SDCf ,
where SDCf is the fraction of activated faults that lead to an
SDC. Thus the coverage includes faults that lead to program
crashes or hangs as well as masked faults. In reality, even
an unprotected program will typically have non-zero coverage
due to natural redundancies and memory protections provided
by the operating system, and hence we measure the coverage
of the program both with and without BLOCKWATCH.
the fault
V. RESULTS
In this section, we ﬁrst present the relative frequencies of the
branch similarity categories in the benchmark programs as dis-
covered by BLOCKWATCH. Then we present the performance
overheads and error detection coverage of BLOCKWATCH.
A. Similarity Category Statistics of Branches
We run the static analysis part of BLOCKWATCH on the
seven SPLASH-2 programs. Table V shows the number of
branches in each program that fall into the similarity cate-
gories in Table I, as discovered by the static analysis phase
of BLOCKWATCH. We also calculate the percentage of the
branches that belong to each similarity category based on the
total number of branches in the program’s parallel section.
SIMILARITY CATEGORY STATISTICS OF THE BRANCHES IN 7 PROGRAMS
TABLE V
Total No.(%) of branches of each category
785
Program
continuous
ocean
FFT
FMM
non-
continuous
ocean
radix
raytrace
water-
nsquared
44
321
478
35
268
103
shared
30
(4%)
14
(32%)
51
(16%)
22
(5%)
threadID partial
12
(2%)
11
(25%)
8
(2%)
116
(24%)
723
(92%)
18
(41%)
98
(31%)
329
(69%)
none
20
(2%)
1
(2%)
164
(51%)
11
(2%)
11
(31%)
12
(4%)
34
(33%)
9
(26%)
4
(1%)
12
(12%)
7
(20%)
117
(44%)
26
(25%)
8
(23%)
135
(51%)
31
(30%)
The results in Table V are as follows. In general, between
49% to 98% of the branches fall into the shared, threadID and
partial categories. This means the BLOCKWATCH is able to
statically identify at least 50% of the branches as similar across
the seven programs. FMM and raytrace have relatively fewer
similar branches, as many branches in these programs have
both variables in the branch conditions to be local variables.
These branches are identiﬁed as belonging to category none
according to the propagation rules in Section III-A.
Thus we see that a signiﬁcant fraction of branches in each
program are identiﬁed as similar by the static analysis phase
of BLOCKWATCH, and are hence eligible for checking in
the runtime phase. This shows that BLOCKWATCH can be
applied to commonly used parallel programs. Note that our
static analysis is rather conservative and hence these are lower
bounds on the number of similar branches in a program.
B. Performance Overheads
Figure 6 shows the execution times of the seven SPLASH-2
programs with BLOCKWATCH for 4 threads and 32 threads.
The results are normalized to the execution time of the
program without BLOCKWATCH (for the same number of
threads), and hence the baseline is 1.0.
From Figure 6, the geometric mean of the performance
overhead of BLOCKWATCH is 2.15X with 4 threads, and
1.16X with 32 threads. Thus the performance overhead of
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:48:23 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 6. Execution time of program with BLOCKWATCH/ execution time of program without BLOCKWATCH. Lower is better
BLOCKWATCH with 32 threads is only 16%, and is lower
than that for 4 threads (see below for why).
Scalability: We study the scalability of BLOCKWATCH by
considering the variation of the geometric mean of the perfor-
mance overheads (across all 7 programs) with the number of
threads. The results are shown in Figure 7 as the number of
threads is varied from 1 to 32.
Fig. 7. Geometric mean of BLOCKWATCH overhead (baseline is program
without BLOCKWATCH) Vs. number of threads
In Figure 7, we ﬁnd that the overhead of BLOCKWATCH
ﬁrst increases as the number of threads increases from 1 to
2, and then decreases as the number of threads increases
from 2 to 32. The reason for the overhead increase from 1
to 2 threads is that the machine we use consists of four 8-
core processors and is not fully symmetric. This asymmetry
causes the memory access time to depend on where the threads
execute. When we increase the number of threads from 1 to 2,
the operating system assigns the 2 threads to cores in different
processors. Thus, the threads cannot share data at the cache
level and the memory access time increases. This hurts the
program with BLOCKWATCH more than the original program,
and the overhead of BLOCKWATCH increases.
The reason for the decrease of overhead from 2 to 32
threads is that when the number of threads doubles,
the
work done by each thread reduces by half and so does the
number of branches executed by each thread. However, due to
communication and waiting among threads, the reduction in
execution time of the program is less than 2X. Nonetheless,
when the number of threads increases, the relative time spent
by BLOCKWATCH reduces and so does the overhead of
BLOCKWATCH (up to 32 threads in Figure 7).
C. Error Detection Coverage
We study the coverage of BLOCKWATCH under two kinds
of faults: branch-ﬂip faults and branch-condition faults. The
former type of fault is guaranteed to ﬂip the branch but does
not corrupt any program data directly. The latter type of fault
corrupts the branch’s condition data but does not necessarily
lead to branch ﬂip.
The results are shown in Figure 8 and Figure 9. Note that
the coverage of y axis in both ﬁgures start from 50%. In
the ﬁgures, coverageoriginal is the coverage of the original
program, and coverageBLOCKWATCH is the coverage of the
program protected by BLOCKWATCH.
1) Coverage results
for branch-ﬂip faults: Figure 8
shows the coverage with and without BLOCKWATCH for
all programs under branch ﬂip faults. Across the pro-
grams, the average coverageoriginal is 83%, while average
coverageBLOCKWATCH is 97% for the 4-thread program, and
98% for the 32-thread program. Other than raytrace, all pro-
grams have a coverage value between 99% - 100% when pro-
tected with BLOCKWATCH, whereas without BLOCKWATCH,
their coverage value is between 60% (radix) and 98% (FMM).
In other words, BLOCKWATCH detects almost all branch-ﬂip
faults that cause SDCs for six of the seven programs.
For raytrace, the coverage with BLOCKWATCH is about
85%, which is comparable to the coverage obtained without
BLOCKWATCH (for both 4 and 32 threads). Thus, the cov-
erage beneﬁt provided by BLOCKWATCH for this program is
negligible. There are two main reasons for this result. First,
raytrace makes extensive use of function pointers, that may