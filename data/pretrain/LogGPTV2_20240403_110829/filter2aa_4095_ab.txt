num = 1                 # 初始化num
myloop do
  puts "num is #{num}"  # 输出num
  break if num > 100    # num 超过 100 时跳出循环
  num *= 2              # num 乘2
end
```
这里第一次出现了 `yield`，`yield` 是定义带块的方法时最重要的关键字。调用方法时通过块传进来的处理会在 `yield` 定义的地方执行。
执行该程序后，`num` 的值就会像 1、2、4、8、16……这样 2 倍地增长下去，直到超过 100 时程序跳出 `myloop` 方法。
```ruby
> ruby myloop.rb
num is 1
num is 2
num is 4
num is 8
num is 16
num is 32
num is 64
num is 128
```
本例的程序中没有参数，如果 `yield` 部分有参数，程序就会将其当作块变量传到块里。块里面最后的表达式的值既是块的执行结果，同时也可以作为 `yield` 的返回值在块的外部使用。
**参数个数不确定的方法**
像下面的例子那样，通过用“`*` 变量名”的形式来定义参数个数不确定的方法，Ruby 就可以把所有参数封装为数组，供方法内部使用。
```ruby
def foo(*args)
  args
end
p foo(1, 2, 3)    #=> [1, 2, 3]
```
至少需要指定一个参数的方法可以像下面这样定义：
```ruby
def meth(arg, *agrs)
  [arg, args]
end
p meth(1)        #=> [1, []]
p meth(1, 2, 3)  #=> [1, [2, 3]]
```
所有不确定的参数都被作为数组赋值给变量 args。“* 变量名”这种形式的参数，只能在方法定义的参数列表中出现一次。只确定首个和最后一个参数名，并省略中间的参数时，可以像下面这样定义：
```ruby
def a(a, *b, c)
  [a, b, c]
end
p a(1, 2, 3, 4, 5)    #=> [1, [2, 3, 4], 5]
p a(1, 2)             #=> [1, [], 2]
```
**关键字参数**
关键字参数是 Ruby 2.0 中的新特性。
在目前为止介绍过的方法定义中，我们都需要定义调用方法时的参数个数以及调用顺序。而使用关键字参数，就可以将参数名与参数值成对地传给方法内部使用。
使用关键字参数定义方法的语法如下所示：
```ruby
def 方法名 (参数 1: 参数 1 的值, 参数 2: 参数 2 的值, …)
 希望执行的处理
end
```
除了参数名外，使用“参数名 : 值”这样的形式还可以指定参数的默认值。用关键字参数改写计算立方体表面积的 `area` 方法的程序如下所示：
```ruby
def area2(x: 0, y: 0, z: 0)
  xy = x * y
  yz = y * z
  zx = z * x
  (xy + yz + zx ) * 2
end
p area2(x: 2, y: 3, z: 4)    #=> 52
p area2(z: 4, y: 3, x: 2)    #=> 52 （改变参数的顺序）
p area2(x: 2, z: 3)          #=> 12 （省略y）
```
这个方法有参数 `x`、`y`、`z`，各自的默认值都为 `0`。调用该方法时，可以像 `x: 2` 这样，指定一对实际的参数名和值。在用关键字参数定义的方法中，每个参数都指定了默认值，因此可以省略任何一个。而且，由于调用方法时也会把参数名传给方法，所以参数顺序可以自由地更改。
不过，如果把未定义的参数名传给方法，程序就会报错，如下所示：
```ruby
area2(foo: 0)    #=> 错误：unknown keyword: foo（ArgumentError）
```
为了避免调用方法时因指定了未定义的参数而报错，我们可以使用“** 变量名”的形式来 接收未定义的参数。下面这个例子的方法中，除了关键字参数 `x`、`y`、`z` 外，还定义了 `**arg` 参数。参数 `arg` 会把参数列表以外的关键字参数以散列对象的形式保存。
```ruby
def meth(x: 0, y: 0, z: 0, **args)
  [x, y, z, args]
end
p meth(z: 4, y: 3, x: 2)        #=> [2, 3, 4, {}]
p meth(x: 2, z: 3, v: 4, w: 5)  #=> [2, 0, 3, {:v=>4, :w=>5}]
```
- 关键字参数与普通参数的搭配使用
    关键字参数可以与普通参数搭配使用。
    ```ruby
    def func(a, b: 1, c:2)
    ┊
    end
    ```
    上述这样定义时，`a` 为必须指定的普通参数，`b`、`c` 为关键字参数。调用该方法时，可以像下面这样，首先指定普通参数，然后是关键字参数。
    ```ruby
    func(1, b: 2, c: 3)
    ```
- 用散列传递参数
    调用用关键字参数定义的方法时，可以使用以符号作为键的散列来传递参数。这样一来，程序就会检查散列的键与定义的参数名是否一致，并将与散列的键一致的参数名传递给方法。
    ```ruby
    def area2(x: 0, y: 0, z: 0)
    xy = x * y
    yz = y * z
    zx = z * x
    (xy + yz + zx ) * 2
    end
    args1 = {x: 2, y: 3, z: 4}
    p area2(args1)            #=> 52
    args2 = {x: 2, z: 3}      #=> 省略y
    p area2(args2)            #=> 12
    ```
**关于方法调用的一些补充**
- 把数组分解为参数
    将参数传递给方法时，我们也可以先分解数组，然后再将分解后的数组元素作为参数传递给方法。在调用方法时，如果以“* 数组”这样的形式指定参数，这时传递给方法的就不是数组本身，而是数组的各元素被按照顺序传递给方法。但需要注意的是，数组的元素个数必须要和方法定义的参数个数一样。
    ```ruby
    def foo(a, b, c)
    a + b + c
    end
    p foo(1, 2, 3)    #=> 6
    args1 = [2, 3]
    p foo(1, *args1)  #=> 6
    args2 = [1, 2, 3]
    p foo(*args2)     #=> 6
    ```
- 把散列作为参数传递
    我们用 `{ ～ }` 这样的形式来表示散列的字面量（literal）。将散列的字面量作为参数传递给方法时可以省略 `{}`。
    ```ruby
    def foo(arg)
    arg
    end
    p foo({"a"=>1, "b"=>2})    #=> {"a"=>1, "b"=>2}
    p foo("a"=>1, "b"=>2)      #=> {"a"=>1, "b"=>2}
    p foo(a: 1, b:2)           #=> {:a=>1, :b=>2}
    ```
    当虽然有多个参数，但只将散列作为最后一个参数传递给方法时，可以使用下面的写法：
    ```ruby
    def bar(arg1, arg2)
    [arg1, arg2]
    end
    p bar(100, {"a"=>1, "b"=>2})    #=> [100, {"a"=>1, "b"=>2}]
    p bar(100, "a"=>1, "b"=>2)      #=> [100, {"a"=>1, "b"=>2}]
    p bar(100, a: 1, b: 2)          #=> [100, {:a=>1, :b=>2}]
    ```
    第 3 种形式是把符号作为键的散列传递给方法，与使用关键字参数调用方法的形式一模一样。其实，关键字参数就是模仿这种将散列作为参数传递的写法而设计出来的。使用关键字参数定义方法，既可以对键进行限制，又可以定义参数的默认值。因此建议大家在实际编写程序的时候多尝试使用关键字参数。
# 如何书写简明易懂的程序
程序不只是为了让计算机理解、执行而存在的，还要能便于人们读写。即使是实现相同功能的程序，有的可能通俗易懂，有的却晦涩难懂。程序是否易懂，除了与程序的设计和架构有关外，程序的外观也起着很重要的作用。而通过注意下面列举的 3 点，就可以使程序变得更漂亮。
- 换行和;
- 缩进（indent）
- 空白
**换行和;**
Ruby 语法的特征之一就是换行可作为语句结束的标志使用。
除了可以使用换行表示语句结束外，我们还可以使用 `;`。这样一来，一行程序里就可以写多条语句，例如，
```ruby
str = "hello"; print str
```
这样的写法与下面的写法具有一样的效果。
```ruby
str = "hello"
print str
```
使用该语法时，把换行看作是一种自然的语句间隔，会更加便于我们读写程序。比起把多个操作都写在一行里，适当的换行是书写简明易懂的程序的第一步。
然而，过多地使用 `;`，往往会使程序变得难以读懂。因此，在使用 `;` 之前，应问问自己是不是非使用不可。经过仔细的考量，如果觉得使用后会使程序变得易懂的话再使用也不迟。顺便说一下，笔者平时也很少会用到 `;`。
**缩进**
缩进，也就是使文字“后退”。这是在程序行的开头输入适当的空白字符来强调程序整体感的一种书写方法。在本书中，我们用两个空白表示一个缩进。
在下面的例子中，为了表示 `print` 方法的那两行程序是 `if ～ end` 的内部处理，程序进行了缩进。
```ruby
if a == 1
    print message1
    print message2
end
```
插入循环等的时候，会使用更深的缩进。这样一来，语句和循环的对应关系就会变得一目了然。
```ruby
while a < 100
    while b < 20
        b = b + 1
        print b
    end
    a = a + 1
    print a
end
```
下面列举了一些需要使用缩进的情况。
- 条件分支
- 循环
- 块
- 方法、类等的定义
使用缩进时，需要遵守以下事项。
- 不要突然使用缩进
- 确保缩进的整齐
**空白**
空白存在于程序的各个角落。使用空白时，我们需要注意以下事项。
- 确保空白长度整齐，保持良好的平衡感
    特别是，如果在运算符前后使用的空白长度不一样，程序就很可能出现莫名其妙的错误。例如，计算 a 加 b 时，不同的空白写法，得到的可能是完全不一样的结果。
    ```
    a+b    ○好的写法
    a + b  ○好的写法
    a +b   ×不好的写法
    a+ b   ×不好的写法
    a +b 表示调用参数为 +b 的方法 a，整个表达式容易被误认为 a(+b)，因此不是好的写法。可见，在 + 前后书写空白时，要确保平衡。
    ```
- 良好的编码风格