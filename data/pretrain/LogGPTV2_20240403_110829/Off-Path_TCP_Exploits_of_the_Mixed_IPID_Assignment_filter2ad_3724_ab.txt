assignment policy is considered to be more secure and can avoid
being observed from off-path attackers. Since the DF flag of TCP
packets is be default set to TRUE to enable the path MTU discovery
mechanism, TCP packets follow this per-socket assignment policy.
Through studying the IPID assignment in Linux, we find that if
the DF flag of TCP packets can be cleared (i.e., set to FALSE), then
the IPID assignment to TCP packets will be downgraded from using
the per-socket-based policy to the hash-based policy.
2.2 Path MTU Discovery
To avoid IP fragmentation, RFC 1191 [35] and RFC 1981 [34] pro-
pose a mechanism to discover path MTU (PMTU) between two end
hosts, i.e., the minimum of all hops’ MTUs in the entire packet trans-
mission path. PMTUD relies on the DF flag. Before sending a packet,
the originator sets the DF flag of the packet to TRUE, indicating that
the packet is not allowed to be fragmented by intermediate routers.
If the packet exceeds a router’s next-hop MTU, the intermediate
router discards it and issues an ICMP Destination Unreachable mes-
sage (type 3) to the originator with the code Fragmentation Needed
and DF set (code 4) in IPv4 or an ICMPv6 Packet Too Big message
in IPv6, along with the router’s next-hop MTU value carried in
the ICMP message. After receiving the ICMP message, if the em-
bedded packet in the message passes the originator’s check, then
the originator reduces the size of subsequent packets according to
the carried next-hop MTU value in the message. The originator
repeats the sending process until a packet with certain size could
be forwarded to the destination, and it then sets the size as PMTU.
However, during this procedure, if an intermediate router’s next-
hop MTU is smaller than the originator’s acceptable minimum
PMTU min_pmtu that is a system variable in PMTUD implementa-
tions, the originator will resize the packet size to min_pmtu, clear
the DF flag of subsequent packets, and then send them out. In RFC
1191 [35], min_pmtu is recommended as 576 octets. However, it
varies in different implementations, e.g., 256 octets in FreeBSD, 296
octets in Mac OS, 552 octets in Linux, and 596 octets in Windows.
In most PMTUD implementations, hosts do not validate the
source and transmission path of ICMP “Fragmentation Needed”
messages (e.g., Linux kernel version 3.9 and beyond). Therefore, an
off-path attacker can pretend to be a router and forge such an ICMP
message specified with an extremely small next-hop MTU value.
Actually the specified next-hop MTU value can be even set to 68
octets, the minimum of PMTU value on the Internet. After sending
such a forged ICMP message to the originator, if the embedded
packet in the forged ICMP message can pass the originator’s check,
the originator will be tricked into clearing the DF flag, thus down-
grading the IPID assignment for TCP packets. According to RFC
792 [39], the forged ICMP message should embed at least 28 octets
data to pass the originator’s check. We will show that an ICMP
echo reply packet can be embedded in the forged ICMP message to
deceive the originator’s check.
2.3 Challenge ACK Mechanism
To defeat blind in-window attacks on TCP, the challenge ACK mech-
anism was proposed as RFC 5961 [44]. In a nutshell, the challenge
ACK mechanism requires that the sender of packets triggering the
challenge conditions replies with the exact sequence number, not
just one within the receive window. Thus, it can prevent an off-path
attacker’s blind injection unless the attacker is extremely lucky to
be able to guess the exact sequence number with a probability of
1/232. The challenge ACK mechanism is designed to enhance the
security of TCP; however, we show that it can be abused to infer
the state of a victim TCP connection.
Our attack exploits the challenge conditions in three aspects.
First, if a receiver sees an incoming SYN segment, regardless of
the sequence number in the segment, it sends back an challenge
ACK to the sender to confirm the loss of the previous connection.
Only the legitimate remote peer will send a RST segment with
the correct sequence number (derived from the ACK field of the
challenge ACK packet) to prove that the previous connection is
indeed terminated. Off-path attackers cannot answer this challenge
with correct sequence number. We will show that this challenge
condition can be abused to detect victim TCP connections.
Second, when a receiver sees an incoming RST segment, if the
sequence number of the segment is outside the receive window,
the receiver simply discards the segment. Instead, if the sequence
number is in-window but does not exactly match the expected
next sequence number (i.e., RCV .N XT ), the receiver will send a
challenge ACK to the sender to confirm the reset action. We will
show that this challenge condition can be abused to judge the
correctness of the guessed sequence number.
Third, if a receiver sees an incoming ACK segment, it validates
the acknowledgment number of the segment (SEG.ACK) with a win-
dow of SN D.U N A−SN D.MAX .W N D <= SEG.ACK <= SN D.N XT ,
where SN D.U N A is the sequence number of the first unacknowl-
edged octet, SN D.MAX .W N D is the maximum window size that
the receiver has ever seen from its peer. The receiver considers that
the acknowledgment number is legal and accepts it if the acknowl-
edgment number is in this range. If SEG.ACK is in the range of
[SN D.U N A − (231 − 1), SN D.U N A − SN D.MAX .W N D], i.e., the
challenge ACK window, the receiver responds with a challenge ACK
packet. We will show this challenge condition can be abused to
judge the correctness of guessed acknowledgment number.
3 ATTACK OVERVIEW
3.1 Threat Model
Figure 2 illustrates the threat model of our off-path TCP exploit.
It involves three hosts, i.e., a victim client, a victim server, and an
off-path attacker. The server and the client communicate based
on a TCP connection, while the off-path attacker aims to hijack
the connection. The off-path attacker cannot eavesdrop the traffic
3
transferred between the server and the client as the man-in-the-
middle attacker does. However, the attacker is capable of sending
spoofed packets with the IP addresses of the server and the client.
This capability assumption is practical, since at least a quarter of the
Autonomous Systems (ASes) on the Internet do not filter packets
with spoofed source addresses leaving their networks [33].
Figure 2: Threat model
3.2 Attack Procedure
Our off-path TCP exploit consists of three main steps to hijack a
victim TCP connection.
Step 1: Detecting Victim Clients. The attacker first downgrades
the server’s IPID assignment from the per-socket-based policy to
the hash-based policy. Then, through hash collisions, the attacker
detects victim clients who share the same IPID counter with the
attacker on the server side, i.e., the server uses the same hash-based
IPID counter to assign IPID for TCP packets to the victim client
and for packets to the attack machine.
Step 2: Detecting TCP Connections. Once a potential victim
client is detected, the attacker impersonates the victim client and
sends spoofed SYN/ACK packets to the server. Then, by observing
the change of the shared IPID counter, the attacker can determine
the correctness of the specified source port number in the spoofed
SYN/ACK packets and thus detect the presence of the TCP connec-
tion between the server and the victim client.
Step 3: Inferring Sequence and Acknowledgment Numbers.
After a victim TCP connection is identified, the attacker sends
spoofed RST packets and ACK packets to the connection, and triggers
challenge ACK mechanism on the connection. By observing the
changes of the shared IPID counter, the attacker can determine the
correctness of the specified sequence number and acknowledgment
number in the forged packets.
After correctly identifying the sequence numbers and acknowl-
edgment numbers of the victim connection, the attacker can forge
malicious TCP segments with the identified values and inject the
segments into the victim connection to either reset the connection
or poison the data stream. In the next three sections, we will detail
the above three steps.
4 DETECTING VICTIM CLIENTS
In this section, we present the method of building the IPID side
channel to detect potential victim clients. First, we present the
method of downgrading the IPID assignment from the per-socket-
based policy to the hash-based policy. Second, we describe how to
detect potential victim clients who share the same IPID counter
with the attacker on the server side.
4.1 Downgrading the IPID Assignment
Linux assigns IPID for packets based on the DF flag. If the DF flag
is set to TRUE, Linux will assign IPID for the packet based on a
per-socket IPID counter; otherwise, based on a hash IPID counter.
However, we observe that the DF flag can be maliciously cleared
by off-path attackers, thus downgrading the IPID assignment. The
attacker pretends to be a router and sends a forged ICMP “Frag-
mentation Needed” message to the victim server, indicating that
a router between the server and the client has a smaller next-hop
MTU and the packet is not allowed to be fragmented.
In order to trick the server into accepting the forged ICMP “Frag-
mentation Needed” message and clearing the DF flag of TCP packets
sent to the client, the forged ICMP message needs to satisfy two
conditions. First, the server does not validate the source of the ICMP
message, i.e., the forged ICMP message from off-path attackers will
not be discarded by the server. In practice, the validation requires
extra functionality support from hardware devices [52], since ma-
jor OSes, e.g., Linux 3.9 and beyond, do not perform the validation
but directly accept the message. Second, the data embedded in the
forged ICMP message must be able to evade the server’s checks.
RFC 792 [39] states that ICMP error messages should be embedded
at least 28 octets (i.e., the IP header plus at least the first 8 octets) of
the triggering packet, which is used by the server to match the mes-
sage to the appropriate process. Moreover, according to the newer
standard RFC 1812 [4], ICMP error messages should be embedded
as much of the triggering packet as possible, but not exceeding 576
octets. Hence, the attacker has to craft and embed feasible data into
the forged ICMP error message to evade the server’s check.
Figure 3: Structure of the forged ICMP error message.
To evade the server’s check, we can embed the ICMP echo reply
data into the forged ICMP “Fragmentation Needed” message, as
shown in Figure 3. When servers equipped with Linux 3.9 and
beyond receive such an ICMP “Fragmentation Needed” message
embedded with an echo reply, the server does not check whether
it sent the embedded echo reply data earlier. Instead, it directly
responds to the forged ICMP error message and clears the DF flag of
subsequent packets sent to the client whose IP address is specified in
the embedded echo reply. Even if the server checks on the embedded
echo reply data, it is easy for attackers to circumvent this checking.
For example, the attacker can impersonate the client and initiate
an ICMP echo request to the server, triggering the server to send
an echo reply message. Then, the attacker pretends to be a router
4
InternetVictim serverVictim clientAttackerOff-pathProtocol = ICMPSource address        = AttackerDestination address = ServerType = 3Code = 4Next-hop MTU = 68Protocol = ICMPSource address        = ServerDestination address = ClientType = 0Code = 0‘0’ * 520V4IHL = 20TOSTotal Length = 576IPIDX|DF|MFFrag OffsetTTLIPHeaderChecksumICMPChecksumUnused= 0V4IHL = 20TOSTotal LengthIPIDX|DF|MFFrag OffsetTTLIPHeaderChecksumICMPChecksumIdentifierSequencenumberIP headerICMP headerEmbedded echo reply(a) No hash collisions with the client
(b) Hash collisions with the client
Figure 4: Detecting potential victim clients through hash collisions.
and sends an ICMP “Fragmentation Needed” message embedded
with the known echo reply data to the server, tricking the server
into accepting the forged message. Note the next-hop MTU value
specified in the forged ICMP “Fragmentation Needed” message
should be smaller than the server’s acceptable minimum PMTU
min_pmtu, as described in Section 2.2. Actually, the value can be
set to 68 octets, which is always smaller than the system variable
of min_pmtu in various IP implementations. Besides, we find that
a forged ICMP error message embedded with a GRE data [18] can
also be used to trick the server into clearing the DF flag.
In a nutshell, it is difficult to verify the legitimacy of ICMP error
messages on the Internet. Therefore, an attacker can forge an ICMP
message and trick the server into accepting it. The forged ICMP
error messages can force the server to clear the DF flag of packets
sent to the victim client. Thus, the IPID assignment can be easily
downgraded by attackers.
4.2 Constructing Hash Collisions
The server will assign IPID to the packets by using one of 2048 hash
counters once the TCP packet’s DF flag is cleared. The counter is
selected based on four factors, i.e., source IP address, destination IP
address, protocol number (e.g., 1 represents ICMP protocol, 6 repre-
sents TCP protocol) of the packet, and a random value generated on
system boot. A hash index computed from the four factors is used
to select one counter from the 2048 hash IPID counters. Hence, if
the TCP packets sent to the victim client have the same hash value
as the packets sent to the attacker, the server will use the same IPID
counter to assign IPID for those packets to different destinations.
Therefore, by constructing hash collisions using Equation 1, the
attacker can detect the victim clients who share the same IPID
counter on the server side. In other words, the shared IPID counter
forms a side channel, which can be exploited to infer TCP connec-
tions between the server and the detected client. Our attack uses
the ICMP protocol to detect hash collisions due to its simplicity
and observability.
hash(server_IP, client_IP,TCP, Boot_key) =
hash(server_IP, attacker_IP, ICMP, Boot_key)
(1)
to the server, who will be tricked into clearing the DF flag and
downgrading the IPID assignment of packets to the client whose
IP address is specified in the forged ICMP message. Second, the
attacker initiates ICMP echo requests to the server and observes
the IPID of the reply packets. Then the attacker impersonates the
client and sends a spoofed SYN packet to the server’s listening port
(e.g., 80). Following the three-way handshake process of TCP, the
server will respond an SYN/ACK packet to the client. Here, the key
difference is that if the attacker’s IP address collides with the client
(i.e., the attacker and the client share the same hash-based IPID
counter at the server side), the IPID assignment for the SYN/ACK
packet will incur an additional increment to the shared IPID counter,
which can be observed by the attacker 1. Otherwise, if there is no
collision, the IPID observed by the attacker will be continuous
distribution, i.e., without additional increment. Using this method,
the attacker can identify victim clients who collide with its IP
address and share the same IPID counter.
The hash-based IPID counter does not increase linearly. Instead,
the increment is a random value in a uniform distribution between
1 and the number of system ticks since the last packet transmission
that used the same counter. Hence, if the attacker wants to force the
counter to increase linearly and facilitate the observation, it needs
to restrict the increment of system ticks related to the IPID counter.