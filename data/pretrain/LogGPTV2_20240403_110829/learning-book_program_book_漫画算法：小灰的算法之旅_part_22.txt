选择。
让我们假设一下，如果最后一个金矿注定不被挖掘，那么问题会转化成
什么样子呢？
显然，问题简化成了10个工人在前4个金矿中做出最优选择。
10人5金矿的
最优选择
400kg黄金/5人
500kg黄金/5人
10工人
200kg黄金/3人
300kg黄全/4人
350kg黄金/3人
10人4金矿的
最优选择
400kg黄金/5人
500kg金/5人
101A
200kg黄金/3人
300kg金/4人
350kg黄金/3人
相应地，假设最后一个金矿一定会被挖掘，那么问题又转化成什么样子
---
## Page 405
呢？
由于最后一个金矿消耗了3个工人，问题简化成了7个工人在前4个金矿
中做出最优选择。
10人5金矿的
晶优选择
400kg金/5人
500kg懿金/5人
10名工人
200kg黄金/3人
300kg金/4人
350kg茜金/3人
7人4金矿的
400kg金/5人
500kg金/5人
7名工
200kg黄金/3人
300kg菌金/4人
350kg黄金/3人
一
一
这两种简化情况，被称为全局问题的两个最优子结构。
究竞哪一种最优子结构可以通向全局最优解呢？换句话说，最后一个金
矿到底该不该挖呢？
那就要看10个工人在前4个金矿的收益，和7个工人在前4个金矿的收益
+最后一个金矿的收益谁大谁小了。
---
## Page 406
V5
同样的道理，对于前4个金矿的选择，我们还可以做进一步简化。
首先针对10个工人4个金矿这个子结构，第4个金矿（300kg黄金/4人）
可以选择挖与不挖。根据第4个金矿的选择，问题又简化成了两种更小
的子结构。
1.10个工人在前3个金矿中做出最优选择。
2.6（10-4=6）个工人在前3个金矿中做出最优选择。
相应地，对于7个工人4个金矿这个子结构，第4个金矿同样可以选择挖
与不挖。根据第4个金矿的选择，问题也简化成了两种更小的子结构。
1.7个工人在前3个金矿中做出最优选择。
2.3（7-4=3）个工人在前3个金矿中做出最优选择。
就这样，问题一分为二，二分为四，一直把问题简化成在0个金矿或0个
工人时的最优选择，这个收益结果显然是0，也就是问题的边界。
---
## Page 407
这就是动态规划的要点：确定全局最
优解和最优子结构之间的关系，以及问题的边界。这个关系用数学
公式来表达的话，就叫作状态转移方程式。
好像有点明白了....那这个所谓的状态
转移方程式是什么样子？
我们把金矿数量设为n，工人数量设
为w，金矿的含金量设为数组gl，金矿所需开采人数设为数组p]，
设F（n，w）为n个金矿、w个工人时的最优收益函数，那么状态转
移方程式如下。
F(n,w)=0(n=0或w=0)
问题边界，金矿数为0或工人数为0的情况。
---
## Page 408
F(n,w) = F(n-1,w) (n≥1, w1, w1,
w≥p[n-1]);
带入求解：
F(1,5) = max(F(1-1,5), F(1-1,5-5)+400) = max(F(0,5),
F(0,0)+400) =max(0,400) = 400
F(1,6) = max(F(1-1,6), F(1-1,6-5)+400) = max(F(0,6)
F(0,1)+400) = max(0, 400) = 400
---
## Page 415
F(1,10) = max(F(1-1,10), F(1-1,10-5)+400) = max(F(0,10),
F(0,5)+400) = max(0, 400) = 400
对于第2行的前4个格子，和第1行同理，由于w1, w1,
w≥p[n-1])
带入求解：
---
## Page 416
F(2,5) = max(F(2-1,5), F(2-1,5-5)+500) = max(F(1,5),
F(1,0)+500) = max(400,500) = 500
F(2,6)= max(F(2-1,6),F(2-1,6-5)+500) =max(F(1,6),
F(1,1)+500)=max(400,500)=500
F(2,10) = max(F(2-1,10), F(2-1,10-5)+500) = max(F(1,10),
F(1,5)+500) = max(400,400+500) = 900
工人工
00kg金/5人
500kgR全/5人
209g黄全/3人
00g周全/4人
第3行的计算方法如出一辙。
再接再厉，计算出第4行的答案。
美金/3
最后，计算出第5行的结果。
---
## Page 417
业/5
500%g黄含/5人
200kgR含/3人
300kgR含/4
YE/EWPEOSE
此时，最后1行最后1个格子所填的900就是最终要求的结果，即5个金
矿、10个工人的最优收益是900kg黄金。
好了，这就是动态规划自底向上的求
解过程。
哇，这个方式还真有意思！那么，怎
么用代码来实现呢？
在程序中，可以用二维数组来代表所
填写的表格，让我们看一看代码吧。
---
## Page 418
1. /**
*获得金矿最优收益
3.
*@param w
工人数量
4.
@paramp
金矿开采所需的工人数量
5.
@param g
金矿储量
6.
*/
7.
public static int getBestGoldMiningV2(int w, int[] p, int[]
{
8.
//创建表格
9.
int[][] resultTable = new int[g.length+1][w+1];
10.
//填充表格
11.
for(int i=1; i=1; j--){
13.
if(j>=p[i-1]){
14.
results[j] = Math.max(results[j],
results[j-p[i-1]]+ g[i-1]);
15.
16.
17.
18.
//返回最后1个格子的值
19.
return results[w];
20.}
哇，优化后的代码真的好简洁呀！
---
## Page 422
是呀，而且空间复杂度降低到了0(m)
。好了，关于金矿问题我们就讲解到这里，咱们下一节再会！
5.12
寻找缺失的整数
5.12.1
“五行”缺一个整数
小灰，我给你最后一
次机会，你要是再挂
掉的话，我就再也不
让你来面试啦1
好的，最后一次我
定会全力以赴。
---
## Page 423
下面考你一道算法题：在一个无序数组
里有99个不重复的正整数，范围从1到100...
题目
在一个无序数组里有99个不重复的正整数，范围是1～100，唯独缺少1
个1～100中的整数。如何找出这个缺失的整数？
哦，让我想想..
有了！创建一个哈希表，以1到100这
100个整数为Key，然后遍历数组。
解法1：
创建一个哈希表，以1到100这100个整数为Key。然后遍历整个数组，每
---
## Page 424
读到一个整数，就定位到哈希表中对应的Key，然后删除这个Key。
由于数组中缺少1个整数，哈希表最终一定会有99个Key被删除，从而剩
下1个唯一的Key。这个剩下的Key就是那个缺失的整数。
假设数组长度是n，那么该解法的时间复杂度是O(n)，空间复杂度是
O(n)。
OK，这个解法在时间上是最优的，但额
外开辟了内存空间。那么，有没有办法降低空间复杂度呢？
哦，让我想想...
有了！首先给原数组排序，然后...