title:Design, Implementation and Verification of an eXtensible and Modular
Hypervisor Framework
author:Amit Vasudevan and
Sagar Chaki and
Limin Jia and
Jonathan M. McCune and
James Newsome and
Anupam Datta
2013 IEEE Symposium on Security and Privacy
Design, Implementation and Veriﬁcation of an
eXtensible and Modular Hypervisor Framework*
Amit Vasudevan∗, Sagar Chaki†, Limin Jia∗, Jonathan McCune‡, James Newsome§ and Anupam Datta∗
∗CyLab, Carnegie Mellon University (PI:EMAIL, PI:EMAIL, PI:EMAIL)
†SEI, Carnegie Mellon University (PI:EMAIL)
‡Google Inc. (PI:EMAIL)
§Independent Consultant (PI:EMAIL)
the design,
Abstract— We present
implementation, and
veriﬁcation of XMHF– an eXtensible and Modular Hypervisor
Framework. XMHF is designed to achieve three goals – modu-
lar extensibility, automated veriﬁcation, and high performance.
XMHF includes a core that provides functionality common
to many hypervisor-based security architectures and supports
extensions that augment the core with additional security or
functional properties while preserving the fundamental hyper-
visor security property of memory integrity (i.e., ensuring that
the hypervisor’s memory is not modiﬁed by software running
at a lower privilege level). We verify the memory integrity of
the XMHF core – 6018 lines of code – using a combination of
automated and manual techniques. The model checker CBMC
automatically veriﬁes 5208 lines of C code in about 80 seconds
using less than 2GB of RAM. We manually audit the remaining
422 lines of C code and 388 lines of assembly language code that
are stable and unlikely to change as development proceeds. Our
experiments indicate that XMHF’s performance is comparable
to popular high-performance general-purpose hypervisors for
the single guest that it supports.
Keywords-Hypervisor Framework, Memory Integrity, Veriﬁ-
cation, Hypervisor Applications (“Hypapps”)
I. INTRODUCTION
Hypervisor-based architectures for improving system se-
curity have been extensively explored in recent years [1]–
[16]. These systems are designed to provide interesting se-
curity and functional properties including secrecy of security
sensitive application code and data [7], trusted user and
application interfaces [2], [4], [13], application integrity and
privacy [3], [5], [10], [11], [17], debugging support [8],
malware analysis, detection and runtime monitoring [6],
[9], [14]–[16] and trustworthy resource accounting [1]. A
majority of these hypervisor-based solutions are designed
and written from scratch with the primary goal of achieving
a low Trusted Computing Base (TCB) while providing a
speciﬁc security property and functionality in the context
of an operating system or another (more traditional) hyper-
visor [2]–[10]. Other hypervisor-based approaches leverage
existing general-purpose virtualization solutions (e.g., Xen,
VMware, Linux KVM) for convenience, but generally don’t
require such functionality [1], [11], [13]–[17].
∗ XMHF is open-source software and is available at: http://xmhf.org
1081-6011/13 $26.00 © 2013 IEEE
DOI 10.1109/SP.2013.36
430
This paper describes the design, implementation and ver-
iﬁcation of an open-source eXtensible and Modular Hyper-
visor Framework (XMHF) that can serve as a platform for
performing security-oriented hypervisor research and devel-
opment. Observing that hypervisor-based security solutions
often rely on a common core functionality given a particular
CPU architecture, XMHF is designed to provide this core
functionality while at the same time supporting extensions
that can provide custom hypervisor-based solutions (“hyp-
ervisor applications” or “hypapps”) for speciﬁc functional
and security properties. The core of XMHF thus has a small
TCB. All extensions reuse the core, avoiding the need to
re-implement it correctly. Furthermore, the XMHF design
enables automated veriﬁcation of relevant security properties
of its core and ensures that the properties are preserved as
extensions (hypapps) are added as long as the extensions ma-
nipulate security-sensitive state using prescribed interfaces
provided by the core. At the same time XMHF’s performance
is comparable to popular high-performance general-purpose
hypervisors for the single guest that it supports.
XMHF supports a single full-featured commodity guest
OS (“rich” guest). We make this design decision in order
to achieve our design goals—modular extensibility, au-
tomated veriﬁcation, and high performance. Speciﬁcally,
XMHF leverages hardware virtualization primitives to allow
the guest direct access to all performance-critical system
devices and device interrupts. This model results in re-
duced hypervisor complexity (since all devices are directly
controlled by the OS) and consequently TCB, as well as
promising high guest performance (since device interrupts
do not trap to the hypervisor). Further, the single-guest
model allows XMHF to be designed for sequential execution
(e.g., no interrupts within the hypervisor) while allowing the
guest to use multiple CPUs, be multi-threaded and handle
device interrupts. As a result, the automated component
of our veriﬁcation only requires model checking sequential
programs, rendering it more tractable.
The focus of our veriﬁcation efforts is memory integrity, a
fundamental hypervisor security property. Roughly, memory
integrity denotes that hypervisor memory regions can only
be modiﬁed by instructions that are an intended part of
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:54:03 UTC from IEEE Xplore.  Restrictions apply. 
the hypervisor. Without memory integrity, portions of the
hypervisor that manage the isolation of memory pages
are open to malicious modiﬁcations, thereby allowing one
guest to modify the code or data of another guest or the
hypervisor itself. Memory integrity is therefore essential for
realizing other important security goals of the hypervisor
and hypapps, such as data secrecy and availability of the
hypervisor as well as guests.
We call our design methodology DRIVE – “Designing
hypervisors for Rigorous Integrity VEriﬁcation”. DRIVE is
composed of a set of hypervisor properties and system
invariants. The hypervisor properties entail the invariants,
which in turn imply the hypervisor’s memory integrity.
Some of the properties and invariants are guaranteed by
the hardware and the system architecture, while others are
discharged via automated veriﬁcation. DRIVE makes explicit
which (properties and invariants) must be veriﬁed, which are
assumed and which are guaranteed. Thus, DRIVE enables
a synergy between architecture and automated analysis to
ensure hypervisor memory integrity.
There have been several efforts to verify security-relevant
properties of hypervisor systems [18]–[21]. However, these
approaches rely on theorem proving, and are less automated.
In addition, they are not focused on designing the target
hypervisor in a way that reduces re-veriﬁcation efforts upon
changes to its implementation. XMHF is architected such
that the portions requiring manual re-auditing are small,
stable and unlikely to change as development proceeds.
We emphasize automated veriﬁcation of the portions of the
XMHF code base that are subject to change as development
proceeds, e.g., guest event handling and new hypapps. Com-
pared to existing efforts, XMHF allows veriﬁcation during its
development. This fulﬁlls the design goal of XMHF to serve
as a framework on which developers build their speciﬁc
hypapp(s) without sacriﬁcing memory integrity.
The XMHF implementation currently supports both Intel
and AMD x86 hardware virtualized platforms and is ca-
pable of running unmodiﬁed legacy multiprocessor capable
OSes such as Windows and Linux. The XMHF core has a
TCB of 6018 SLoC, and its performance is comparable
to popular high-performance general-purpose hypervisors.
We verify memory integrity of XMHF following the DRIVE
methodology. Most of the DRIVE veriﬁcation conditions are
discharged using the software model checker CBMC [22].
Out of the 6018 lines of code that comprise the XMHF core,
CBMC automatically veriﬁes 5208 lines in about 80 seconds
using less than 2GB of RAM. We manually audit the remain-
ing 422 lines of C code and 388 lines of assembly language
code which we anticipate to remain mostly unchanged as
development proceeds. The manual audits include constructs
that CBMC cannot verify, including loops that iterate over
entire page tables, platform hardware initialization and inter-
action, and concurrent threads coordinating multiple CPUs
that are challenging for current model-checkers.
We list the contributions below, which also serves as a
roadmap to the paper:
• We present the DRIVE methodology for designing, devel-
oping, and verifying hypervisor memory integrity (§III).
• We design and implement XMHF, a hypervisor framework
based on DRIVE which supports modular development of
future hypapps (§IV).
• We verify the memory integrity of the XMHF runtime
implementation using DRIVE, and show how to discharge
the DRIVE veriﬁcation conditions on XMHF using the
software model checker CBMC [22] (§V).
• We carry out a comprehensive performance evaluation of
XMHF (§VI).
II. GOALS, BACKGROUND AND ATTACKER MODEL
A. Modular Development and Veriﬁcation
Our overarching goal is to create a hypervisor framework
that promotes development of custom hypapps, while simul-
taneously allowing veriﬁcation of security properties. We
focus on verifying memory-integrity – a fundamental secu-
rity property and a major component of the tamperproofness
of any hypapp. This enables the development of hypapps
without having to worry about the low-level infrastructure
grunge or the hypervisor’s memory integrity.
We strive for a minimal TCB hypervisor design that
enables automatic veriﬁcation of its implementation. Ac-
cordingly, we propose a rich single-guest execution model
(§IV-A). Thus, XMHF supports only a single-guest
that
directly accesses and manages platform devices after ini-
tialization. XMHF consists of a core and small supporting
libraries. These are extended, and leveraged, by each hypapp
to implement its functionality. Our speciﬁc design goals are:
1) Modular Core and Modular Extensibility: The XMHF
core is built in a modular way. It handles a set of events from
the guest (e.g., hypercall, nested page-faults) using distinct
event handlers. Each event is handled in a sequential manner,
either directly by the XMHF core or handed over to a hypapp
handler, which then performs the desired functionality by
leveraging a set of APIs exposed by XMHF (§IV-B1). This
modular extensibility allows a hypapp to extend XMHF to
offer custom features and desired properties.
2) Veriﬁability: The rich single-guest model results in
reduced hypervisor complexity (since all devices are directly
controlled by the guest) and consequently TCB. Further,
XMHF’s modular core design allows independent automated
analysis of the event handlers, which constitute the runtime
attack surface. In particular, it enables a software model
checker to ignore irrelevant code (e.g., via slicing) when
verifying a particular property (§V).
3) Performance: The rich single-guest model promises
high guest performance as all performance-critical system
devices and device interrupts are directly handled by the
guest without the intervention of XMHF (§VI-B).
431
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:54:03 UTC from IEEE Xplore.  Restrictions apply. 
B. Hardware Virtualization Primitives
III. THE DRIVE METHODOLOGY
We focus on the following hardware virtualization prim-
itives offered by the system platform. These primitives are
supported by current x86 platforms [23], [24], and are also
making their way on embedded ARM architectures [25].
• The CPU executes in two modes, each with a separate
address space: (a) host-mode (or privileged mode) –
where the hypervisor executes, and (b) guest-mode (or
unprivileged mode) – where the guests execute.
• At system boot time, the hypervisor is able to execute a
designated piece of code in complete isolation.
• At system runtime, the hardware provides mechanisms to
ensure that all accesses to system memory are subjected
to an access control mechanism.
• The execution state of the guest is maintained in a data
structure that is inaccessible and/or access controlled from
unprivileged mode.
• The hypervisor is able to associate intercept handlers
with certain events caused by a guest (e.g., instructions,
I/O operations, exceptions and interrupts). The hardware
ensures that upon the occurrence of an event e,
the
following sequence of actions occur: (1) the execution
state of the guest is saved, (2) execution is switched to
host mode, (3) the intercept handler for e is executed,
(4) execution is switched back to guest mode, and (5) the
execution state of the guest is restored and guest execution
is resumed.
C. Attacker Model
We consider attackers that do not have physical access
to the CPU, memory and the chipset (our hardware TCB).
Other system devices and the guest constitute the attacker.
This is a reasonable model since a majority of today’s attacks
are mounted by malicious software or system devices. An
attacker can attempt to access memory either (i) during
hypervisor initialization; or (ii) from within the guest and
by using system devices; or (iii) via hypervisor intercept
handlers triggered by the guest.
D. System Assumptions
We assume that
the our hardware TCB provides the
correct functionality and that the hypervisor has control ﬂow
integrity [26], i.e., the control ﬂow during the execution of
the hypervisor respects its source code. Ensuring CFI for
systems software is an orthogonal challenge to verifying
memory integrity. As future work, we plan to reinforce
XMHF with CFI and verify its correctness. We also assume
that a hypapp built on top of XMHF uses the prescribed
XMHF core APIs (e.g., changing guest memory protections
and performing chipset I/O) and that it does not write to ar-
bitrary code and data. In fact, these are the only assumptions
required of any new hypapp to ensure the memory integrity
property of XMHF. We plan to explore modular veriﬁcation
of the XMHF core composed with hypapps as future work.
We model
the virtualized system as a tuple V =
(H, G, D, M), where H is the hypervisor, G represents
the guest, D represents devices, and M is the hypervisor
memory containing both hypervisor code and data. Both G
and D are attacker controlled. We omit the guest memory,
which is separate from M and irrelevant to memory in-
tegrity, from the model. DRIVE consists of a set of properties
about H, system invariants, and a proof that if H satisﬁes
those properties then the invariants hold on all executions of
V . This, in turn, implies the memory integrity of H in V .
A. Hypervisor Properties Required by DRIVE
DRIVE identiﬁes the following six properties that restrict
the hypervisor design and implementation, response to the
attacker’s actions, and writes to memory.
Modularity (MOD). Upon hypervisor initialization, control
is transferred to a function init(). When an intercept is
triggered,
to one of the
intercept handlers ih 1(), . . . , ih k().
the hardware transfers control
Atomicity (ATOM). This property ensures the atomicity
of initialization and intercept handling on the CPU(s). It
consists of two sub-properties: ATOMinit – at the start of
V ’s execution, init ( ) runs completely in a single-threaded
environment before any other code executes; ATOMih –
the intercept handlers ih 1(), . . . , ih k() always execute in a
single-threaded environment.
Memory Access Control Protection (MPROT). H uses
a memory access control mechanism MacM. All MacM
related state is stored in M. MacM consists of two parts: (1)
MacMG – for the guest, and (2) MacMD – for the devices.