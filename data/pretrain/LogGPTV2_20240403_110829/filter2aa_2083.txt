WEAPONIZING HYPERVISORS 
 TO FIGHT & BEAT  
CAR & MEDICAL DEVICE 
 ATTACKS 
Ali Islam – CEO Numen Inc 
Dan Regalado – DanuX – CTO Numen Inc 
 AGENDA 
Basic&Concepts&
Q&A&
Embedded&Environment&
Demo&–&Attacks&&&Use&cases&
 Hypervisors & Strong Trending 
Confidential 
Agent-less vs Agent (AV) 
•  Sophisticated Invisibility (VMI) - Cat and mouse 
game 
•  No messing up the actual device functionality 
•  Helps with regulations and certifications 
Let’s start the Journey 
Setting up the Environment on a  
Zynq UltraScale+ MPSoC ZCU 102 
Src: https://www.digikey.com/product-detail/en/xilinx-inc/EK-U1-ZCU102-G/122-2035-ND/7035245#images-1 
SD Card 
UART 
JTAG 
Zynq UltraScale+ MPSoC ZCU 102 
ETHERNET 
-  DDR4 – 4 GB 
-  Quad-core Cortex A-53 
-  Dual-core Cortex R5F 
Booting the board with JTAG 
•  Using Xilinx System Debugger CLI (xsdb) which reads a tcl file 
PMUFW – Setup clock and platform management 
FSBL – First Stage Bootloader – Initializes U-Boot 
U-Boot – Boots the Hypervisor, Kernel and rootfs 
Bl31 – ARM Trusted Firmware 
U-Boot Configuration 
•  Preparing Device Tree Blob (DTB) xen.dtb file (dts below): 
ZynqMP> tftpb 0x1380000 xen.dtb 
ZynqMP> tftpb 0x80000 Image-2018.3 
ZynqMP> tftpb 0x1400000 xen.ub 
ZynqMP> bootm 0x1400000 - 0x1380000 
# mkimage -A arm64 -T kernel -a 0x1400000 -e 0x1400000 -C none -d xen-zcu102-zynqmp xen.ub 
•  Preparing the hypervisor: 
Building the rootfs 
•  PetaLinux: Xilinx-based and therefore not universal 
•  Yocto: Universal but builds a Busybox limited rootfs 
ü  Real pain to compile new libraries 
•  Debootstrap: Way to go, Debian-based FileSystem J 
Dev environment 
•  You do not want to make changes directly on the board 
•  Schroot to the rescue 
ü  Chroot into the rootfs but from a mounting point via QEMU 
Let’s get the damn ARM Syscalls out! 
VMI & Semantic Gap 
Understand 
meaning using 
OS specific 
knowledge 
https://notes.shichao.io/lkd/ch3/ 
linux_name = 0x4f0; 
linux_tasks = 0x280; 
linux_mm = 0x2d0; 
linux_pid = 0x334; 
linux_pgd = 0x40; 
Kernel Symbol Value Example 
http://libvmi.com/docs/gcode-intro.html 
status_t vmi_read_ksym( 
    vmi_instance_t vmi, 
    const char *sym, 
    size_t count, 
    void *buf, 
    size_t *bytes_read 
); 
Single Stepping 
•  Hardware Breakpoints 
•  Software Breakpoints - CPU assisted 
•  Software breakpoints – No CPU 
Assistance 
http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html  
Extended Page table(s) 
https://de.wikipedia.org/wiki/Datei:X86_Paging_4K.svg 
p2m Translation 
Machine Physical 
Address 
VM Virtual Address 
VM Physical 
Address 
EPTP 
Virtual to VM PA 
EPT pointer (EPTP) is stored in the 
Virtual Machine Control Structure 
(VMCS)  - A per VM data struct in the 
memory and managed by VMM 
Multiple p2m Translations 
  Machine Physical 
Address 
VM Virtual Address 
VM Physical 
Address 
Virtual to VM PA 
EPTP 2 
EPTP 1 
Extend Page Table Entry (epte) struct from Xen code 
Multiple p2m Translations (continued) 
Machine Physical 
Address (MPA) 
VM Virtual Address 
VM Physical 
Address 
Virtual to VM PA 
MPA in second 
memory copy 
VM PA  to Machine PA 
Single Stepping on ARM 
0xD4000003 (BP) 
Instruction 2 
Instruction 3 
Default Memory View 
Instruction 1 
0xD4000003 (BP) 
Instruction 3 
Single Stepping View 
https://dl.acm.org/citation.cfm?id=3274698 
Instruction n 
Instruction n 
BP = Breakpoint = SMC 
Hooking and Syscall Monitoring on ARM 
Singlestep 
Make sure to singlestep in order 
to execute the original functionality 
Clean 
After you are done, make sure 
to remove all hooks and exit 
VMI. Otherwise the VM might 
crash or become unstable 
vmi_destroy(); 
Add & Register Hook 
vmi_register_event() 
& 
Write to memory 0xD4000003 
(SMC) at the start of each API 
function . 
Callback 
Do you analysis  when the 
control gets  to your registered 
callback.  
Syscalls Monitoring in ARM 
(ARM-Syscalls.mp4) 
Attacks and Detection scenarios 
Memory corruption attack 
Shell spawn at the end 
Exit gracefully 
Easy sequence-based detection 
Shellcode execution delay 
•  Syscall monitoring cannot be on all the time 
•  Not using syscall (sleep) to delay execution 
•  Traditional AV challenge 
Solution approach 
•  Create a “triggered memory view” hooking 
only suspicious syscalls: execve, connect, 
clone, etc all the time 
•  As soon as the shellcode spawns, full hooking 
on that process is enabled! 
Malware hypervisor-aware 
•  The malware is able to read kernel memory 
and identify SMC hooks 
ü  Stops running or wipes the system! 
•  Even in some conditions is able to remove the 
hooks! 
ü  Worst scenario, detection bypass! 
 Stealthiness using memory views 
Execute Only View 
Read/Write Only View 
Policy Enforcement – Network Use Case 
Once you have a good handle on Virtual Machine Introspection, 
there are many possibilities.  
1) Traverse a task list and see if there is any socket handle for a 
particular task struct 
 1.1) A socket is a special type of file. So check if there is 
any additional file handle 
2) Hook the network related APIs (e.g. connect).  
 2.1) More active approach vs the passive one in step 1.   
Policy Enforcement – Network Use Case 
Our patent pending Numen Adaptive Monitoring (NAM) is a combination of different 
techniques to achieve exceptional performance 
Remediation 
•  Its not easy to remediate from outside without  putting 
any agent inside. Lets say kill a process. 
•  How about manipulating with one of the frequently called 
APIs? 
•  Maybe make one of the string parameter NULL?  
•  Just a basic way. There can be other more mature ways. 
PRACTICAL RECOMMENDATIONS FOR END TO END SYSTEM 
•  Software Breakpoints 
•  Efficient Single Stepping Mechanism 
•  Event Mechanism 
•  Efficient translations caching 
•  Multiple mappings support for p2m (physical to machine) 
•  Memory page permissions management 
Releasing tool to the public 
•  Tool to perform syscall monitoring for ARM & Intel J 
•  All files needed to setup a working environment: 
ü  Booting the board: zynqmp_fsbl.elf, u-boot.elf, 
bl31.elf, pmufw.elf 
ü  Environment: xen.dtb, Kernel-Image, Xen-Hypervisor 
(version 11.0), DomU-Configuration files, xen startup 
scripts. 
ü  Test: ARM64-based malware and exploit samples. 
•  Dropbox link: xxxxxxxxxxxxxxxxxxxxxx 
Takeaways 
•  “Smart” Hypervisors on ARM are needed, not only for 
isolation 
•  ARM Syscall Hooking is great achievement but just the 
beginning, the detection strategies is what makes the 
difference 
•  Switching between memory views for detection strategies is a 
new way to detect maliciousness from VMI 
Special Thanks 
•  Stefano Stabellini: For his great help on Xen troubleshooting 
•  Matt Leinhos: For his great features on ARM/Intel VMI 
•  For those 3 of you guys, you know who you are J 
Without you, no way to complete this effort 
Q & A 
@Ali_Islam_Khan 
@danuxx