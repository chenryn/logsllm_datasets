title:Statically Detecting Likely Buffer Overflow Vulnerabilities
author:David Larochelle and
David Evans
USENIX Association
Proceedings of the
10th USENIX Security
Symposium
Washington, D.C., USA
August 13–17, 2001
© 2001 by The USENIX Association
Phone: 1 510 528 8649
FAX: 1 510 548 5738
THE ADVANCED COMPUTING SYSTEMS ASSOCIATION
All Rights Reserved
Email: PI:EMAIL
For more information about the USENIX Association:
WWW: http://www.usenix.org
Rights to individual papers remain with the author or the author's employer.
 Permission is granted for noncommercial reproduction of the work for educational or research purposes.
This copyright notice must be included in the reproduced paper. USENIX acknowledges all trademarks herein.
Statically Detecting Likely Buffer Overflow Vulnerabilities 
David Larochelle 
PI:EMAIL 
University of Virginia, Department of Computer Science 
University of Virginia, Department of Computer Science 
David Evans 
PI:EMAIL 
Abstract 
Buffer overflow attacks may be today’s single most important security threat.  This paper presents a new approach to 
mitigating buffer overflow vulnerabilities by detecting likely vulnerabilities through an analysis of the program source 
code.    Our  approach  exploits  information  provided  in  semantic  comments  and  uses  lightweight  and  efficient  static 
analyses.   This paper describes an implementation of our approach that extends the LCLint annotation-assisted static 
checking tool.  Our tool is as fast as a compiler and nearly as easy to use.  We present experience using our approach to 
detect buffer overflow vulnerabilities in two security-sensitive programs. 
recent 
security  problem  at  a 
1.   Introduction 
Buffer overflow attacks are an important and persistent 
security  problem. 
  Buffer  overflows  account  for 
approximately  half  of  all  security  vulnerabilities 
[CWPBW00,  WFBA00].    Richard  Pethia  of  CERT 
identified buffer overflow attacks as the single most im-
portant 
software 
engineering  conference  [Pethia00];  Brian  Snow  of  the 
NSA predicted that buffer overflow attacks would still 
be a problem in twenty years [Snow99].     
Programs  written  in  C  are  particularly  susceptible  to 
buffer  overflow  attacks.    Space  and  performance  were 
more important design considerations for C than safety.  
Hence,  C  allows  direct  pointer  manipulations  without 
any bounds checking.  The standard C library includes 
many  functions  that  are  unsafe  if  they  are  not  used 
carefully.    Nevertheless,  many  security-critical  pro-
grams are written in C. 
Several  run-time  approaches  to  mitigating  the  risks 
associated  with  buffer  overflows  have  been  proposed.  
Despite their availability, these techniques are not used 
widely 
the 
effectiveness  of  buffer  overflow  attacks.    The  next 
section  describes  representative  run-time  approaches 
and speculates on why they are not more widely used.  
We propose, instead, to tackle the problem by detecting 
likely  buffer  overflow  vulnerabilities  through  a  static 
analysis of program source code.  We have implement-
substantially  mitigate 
enough 
to 
ed a prototype tool that does this by extending LCLint 
[Evans96].  Our work differs from other work on static 
detection of buffer overflows in three key ways: (1) we 
exploit  semantic  comments  added  to  source  code  to 
enable local checking of interprocedural properties; (2) 
we focus on lightweight static checking techniques that 
have  good  performance  and  scalability  characteristics, 
but  sacrifice  soundness  and  completeness;  and  (3)  we 
introduce 
loop  heuristics,  a  simple  approach  for 
efficiently  analyzing  many  loops  found  in  typical 
programs.   
The  next  section  of 
this  paper  provides  some 
background  on  buffer  overflow  attacks  and  previous 
attempts  to  mitigate  the  problem.    Section  3  gives  an 
overview of our approach.  In Section 4, we report on 
our experience using our tool on wu-ftpd and BIND, two 
security-sensitive  programs.    The  following  two  sec-
tions provide some details on how our analysis is done.  
Section 7 compares our work to related work on buffer 
overflow detection and static analysis.   
2.  Buffer Overflow Attacks and Defenses 
The  simplest  buffer  overflow  attack,  stack  smashing 
[AlephOne96],  overwrites  a  buffer  on  the  stack  to 
replace the return address.  When the function returns, 
instead  of  jumping  to  the  return  address,  control  will 
jump to the address that was placed on the stack by the 
attacker.  This gives the attacker the ability to execute 
arbitrary  code.    Programs  written  in  C  are  particularly 
safe 
implementations; 
susceptible  to  this  type  of  attack.    C  provides  direct 
low-level  memory  access  and  pointer  arithmetic 
without  bounds  checking.      Worse,  the  standard  C 
library  provides  unsafe  functions  (such  as  gets)  that 
write  an  unbounded  amount  of  user  input  into  a  fixed 
size  buffer  without  any  bounds  checking  [ISO99].  
Buffers  stored  on  the  stack  are  often  passed  to  these 
functions.    To  exploit  such  vulnerabilities,  an  attacker 
merely has to enter an input larger than the size of the 
buffer  and  encode  an  attack  program  binary  in  that 
input.  The Internet Worm of 1988 [Spafford88, RE89] 
exploited  this  type  of  buffer  overflow  vulnerability  in 
fingerd.    More  sophisticated  buffer  overflow  attacks 
may  exploit  unsafe  buffer  usage  on  the  heap.    This  is 
harder,  since  most  programs  do  not  jump to addresses 
loaded  from  the  heap  or  to  code  that  is  stored  in  the 
heap. 
Several  run-time  solutions  to  buffer  overflow  attacks 
have  been  proposed.    StackGuard  [CPMH+98]  is  a 
compiler  that  generates  binaries  that  incorporate  code 
designed to prevent stack smashing attacks.  It places a 
special  value  on  the  stack  next  to  the  return  address, 
and  checks  that  it  has  not  been  tampered  with  before 
jumping.    Baratloo,  Singh  and  Tsai  describe  two  run-
time  approaches:  one  replaces  unsafe  library  functions 
with 
the  other  modifies 
executables  to  perform  sanity  checking  of  return  ad-
dresses on the stack before they are used [BST00]. 
Software fault isolation (SFI) is a technique that inserts 
bit  mask  instructions  before  memory  operations  to 
prevent  access  of  out-of-range  memory  [WLAG93].  
This  alone  does  not  offer  much  protection  against 
typical  buffer  overflow  attacks  since  it  would  not 
prevent  a  program  from  writing  to  the  stack  address 
where the return value is stored.  Generalizations of SFI 
can insert more expressive checking around potentially 
dangerous  operations 
the  behavior  of 
programs  more  generally.    Examples  include  Janus, 
which  observes  and  mediates  behavior  by  monitoring 
system calls [GWTB96]; Naccio [ET99, Evans00a] and 
PSLang/PoET  [ES99,  ES00]  which  transform  object 
programs  according  to  a  safety  policy;  and  Generic 
Software  Wrappers  [FBF99] which wraps system calls 
with security checking code.   
Buffer overflow attacks can be made more difficult by 
modifications to the operating system that put code and 
data  in  separate  memory  segments,  where  the  code 
segment 
instructions  cannot  be 
executed  from  the  data  segment.    This  does  not 
eliminate  the  buffer  overflow  problem,  however,  since 
an attacker can still overwrite an address stored on the 
stack  to  make  the  program  jump  to  any  point  in  the 
code segment.  For programs that use shared libraries, it 
is  read-only  and 
to  restrict 
(StackGuard 
is often possible for an attacker to jump to an address in 
the  code  segment  that can be used maliciously (e.g., a 
call to system).  Developers decided against using this 
approach in the Linux kernel since it did not solve the 
real  problem  and  it  would  prevent  legitimate  uses  of 
self-modifying code [Torvalds98, Coolbaugh99].  
Despite  the  availability  of  these  and  other  run-time 
approaches, buffer overflow attacks remain a persistent 
problem.  Much of this may be due to lack of awareness 
of  the  severity  of  the  problem  and  the  availability  of 
practical  solutions.    Nevertheless,  there  are  legitimate 
reasons why the run-time solutions are unacceptable in 
some  environments.    Run-time  solutions  always  incur 
some  performance  penalty 
reports 
performance overhead of up to 40% [CBDP+99]).  The 
other problem with run-time solutions is that while they 
may  be  able  to  detect  or  prevent  a  buffer  overflow 
attack,  they  effectively  turn  it  into  a  denial-of-service 
attack.  Upon detecting a buffer overflow, there is often 
no way to recover other than terminating execution.   
Static checking overcomes these problems by detecting 
likely  vulnerabilities  before  deployment.    Detecting 
buffer  overflow  vulnerabilities  by  analyzing  code  in 
general is an undecidable problem.1  Nevertheless, it is 
possible to produce useful results using static analysis.  
Rather than attempting to verify that a program has no 
buffer  overflow  vulnerabilities,  we  wish 
to  have 
reasonable  confidence  of  detecting  a  high  fraction  of 
likely  buffer  overflow  vulnerabilities.    We  are  willing 
to  accept  a  solution 
is  both  unsound  and 
incomplete. 
that  our  checker  will 
sometimes generate false warnings and sometimes miss 
real  problems.    Our  goal  is  to  produce  a  tool  that 
produces  useful  results  for  real  programs  with  a 
reasonable  effort.    The  next  section  describes  our 
approach.    We  compare  our  work  with  other  static 
approaches  to  detecting buffer overflow vulnerabilities 
in Section 7. 
that 
  This  means 
3.  Approach 
Our static analysis tool is built upon LCLint [EGHT94, 
Evans96, Evans00b], an annotation-assisted lightweight 
static checking tool.  Examples of problems detected by  
LCLint 
information  hiding, 
inconsistent modifications of caller-visible state or uses 
of  global  variables,  misuses  of  possibly  NULL 
references,  uses  of  dead  storage,  memory  leaks  and 
problems  with  parameters  aliasing.   LCLint is actually 
include  violations  of 
1  We  can  trivially  reduce  the  halting  problem  to  the  buffer 
overflow  detection  problem  by  inserting  code  that  causes  a 
buffer overflow before all halt instructions. 
is 
function 
exclusively  on 
annotation  /*@notnull@*/ 
used  by  working  programmers,  especially  in  the  open 
source development community [Orcero00, PG00]. 
Our  approach 
to  exploit  semantic  comments 
(henceforth called annotations) that are added to source 
code  and  standard  libraries.    Annotations  describe 
programmer  assumptions  and  intents.  They  are  treated 
as regular C comments by the compiler, but recognized 
as  syntactic  entities  by  LCLint  using  the  @  following 
the  /*  to  identify  a  semantic  comment.    For  example, 
can  be  used 
the 
syntactically  like  a  type  qualifier.    In  a  parameter 
declaration,  it  indicates  that  the  value  passed  for  this 
parameter may not be NULL.  Although annotations can 
be used on any declaration, for this discussion we will 
focus 
and  parameter 
declarations.  We can also use annotations similarly in 
declarations  of  global  and  local  variables,  types  and 
type fields. 
Annotations  constrain  the  possible  values  a  reference 
can  contain  either  before  or  after  a  function  call.    For 
example,  the  /*@notnull@*/  annotation  places  a 
constraint  on  the  parameter  value  before  the  function 
body  is  entered.    When  LCLint  checks  the  function 
body, it assumes the initial value of the parameter is not 
NULL.    When  LCLint  checks  a  call  site,  it  reports  a 
warning unless it can determine that the value passed as 
the corresponding parameter is never NULL. 
Prior to this work, all annotations supported by LCLint 
classified references as being in one of a small number 
of  possible  states. 
  For  example,  the  annotation 
/*@null@*/  indicated that a reference may be  NULL, 
and  the  annotation  /*@notnull@*/  indicated  that  a 
reference is not NULL.  In order to do useful checking 
of buffer overflow vulnerabilities, we need annotations 
that are more expressive.  We are concerned with how 
much  memory  has  been  allocated  for  a  buffer, 
something  that  cannot  be  adequately  modeled  using  a 
finite  number  of  states.    Hence,  we  need  to  extend 
LCLint to support a more general annotation language.  
The annotations are more expressive, but still within the 
spirit of simple semantic comments added to programs. 
The  new  annotations  allow  programmers  to  explicitly 
state  function  preconditions  and  postconditions  using 
requires  and  ensures  clauses.2    We  can  use  these 