### 优化后的文本

**图5. 约束构建过程**

在约束构建过程中，我们不是一次性检查所有断言 [6] [7]，而是每次只检查一个断言，并生成该断言的所有反例。对于每个断言，我们生成一个公式 \( B \) 并检查其可满足性。如果 \( B \) 是可满足的，我们将获得一个反例，并通过否定该反例使 \( B \) 更加严格。我们重复这个循环，直到 \( B \) 不可满足，即收集到所有反例为止。

在为断言 `asserti` 生成公式时，我们将它及其前面的所有命令视为一个整体 `c;asserti`。然后，构造相应的公式 \( Bi \)，并将这些命令串联起来。

---

**图6. PHP代码到布尔公式的转换示例**

```php
if (Nick) {
    $tmp = $_GET["nick"];
    echo htmlspecialchars($tmp);
} else {
    $tmp = "You are the " . $GuestCount . " guest";
    echo $tmp;
}
```

转换后的布尔公式如下：

- 如果 `bNick` 为真：
  - \( T_{\text{nick}} \)
  - \( T_{\text{tmp}} \leftarrow T_{\text{nick}} \)
  - \( U_{\text{tmp}} \leftarrow F \)
  - 断言：\( \text{assert}(T_{\text{tmp}}) \)

- 否则：
  - \( T_{\text{tmp}} \leftarrow \text{tmp} \cdot \text{GuestCount} \)
  - \( U_{\text{tmp}} \leftarrow F \)
  - 断言：\( \text{assert}(T_{\text{GuestCount}} \cdot T_{\text{tmp}}) \)

---

**约束生成过程**

1. **初始化**：对于每个断言 `asserti`，生成公式 \( B_i \)。
2. **检查可满足性**：将 \( B_i \) 转换为合取范式（CNF），使用高效的SAT求解器zChaff [19] 进行求解。
3. **生成反例**：如果 \( CNF(B_i) \) 可满足，zChaff 将提出一个违反 `asserti` 的真值赋值 \( \hat{\sigma}_i \)。根据 \( \hat{\sigma}_i \) 中非确定性布尔变量的值，可以跟踪抽象解释并生成一个单个赋值序列，表示一个反例轨迹。
4. **迭代更新**：为了收集所有可能的反例，我们逐步使 \( B_i \) 更加严格，直到它变得不可满足。具体来说，在第 \( j \) 次迭代中，如果得到真值赋值 \( \hat{\sigma}_{i,j} \)，则生成否定子句 \( N_{i,j} \)。在第 \( j+1 \) 次迭代中，新的公式 \( B_{i,j+1} \) 定义为 \( B_{i,j} \land N_{i,j} \)。
5. **终止条件**：一旦公式变得不可满足，继续约束生成过程，直到处理完所有断言。

---

**参考文献**

[6] [7] 相关文献引用

---

**版权信息**

本文档来源于2004年国际依赖系统和网络会议（DSN’04）论文集。版权所有 © 2004 IEEE。授权许可仅限于清华大学。下载时间为2021年3月20日UTC 11:49:16。限制适用。

---

希望优化后的文本更加清晰、连贯和专业。如果有任何进一步的需求或修改，请告知我。