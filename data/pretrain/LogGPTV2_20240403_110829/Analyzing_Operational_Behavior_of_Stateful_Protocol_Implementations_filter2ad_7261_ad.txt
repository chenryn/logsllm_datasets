that TLS OP violates OP1. The realizable CEX reported by
CHIRON demonstrates that there exists an execution path
where the client accepts and processes ServerCCS received (in
out of order) right after receiving ServerHello. Along this
execution path, the client accepts another ServerCCS received
(in the correct order) right before receiving ServerFinished
and eventually completes the handshake successfully.
A close inspection of the source of TLS OP reveals that the
client must receive ServerCCS right before ServerFinished
to complete the handshake. However, TLS OP does not re-
strict the client from accepting and processing ServerCCS
received in out of order anytime after ServerHello. The
implication of this semantic bug exacerbates because TLS OP
calculates the new keys upon receiving the ﬁrst ServerCCS
and does not recalculate the keys for any ServerCCS received
later. A man-in-middle attacker can easily exploit this vulner-
ability to trigger the client calculate the new keys based on an
empty master secret. As a result, the attacker can successfully
break the guarantees of TLS (e.g., conﬁdentiality). This was
ﬁrst reported by Masashi Kikuchi as CVE-2014-0224 and later
ﬁxed in the following release of OpenSSL.
Bug 2 (Accepting multiple Telnet client connections si-
multaneously). According to the Telnet server documentation
in Contiki, the server must not accept any new connection
from a (possibly new) Telnet client during an ongoing session,
which we denote as property TP1. In our tests, CHIRON
generates a realizable CEX for Telnet C24 demonstrating that
the Telnet server accepts a new connection from a client even
if there is an ongoing session. In fact, this semantic bug
can manifest upon receiving any additional connection. This
bug was, however, already reported [4] and later ﬁxed in the
following release of Contiki.
After a close inspection, we discovered that this semantic
bug can have critical
implications: (a) incorrect protocol
behavior as the server re-initializes variables and (b) security
issues as the server leaks data to the unauthorized client(s).
Bug 3 (No reply with appropriate Telnet command). Both
Telnetd implementations from Contiki (Telnet C24 and Tel-
net C27) violate properties TP2 and TP3, which require that
the Telnet server must reply the appropriate Telnet command if
it receives WILL (for TP2) or DO (for TP3) from the connected
Telnet client. The realizable CEX generated by CHIRON
demonstrates that there exists an execution path in the corre-
TABLE II: Properties for TLS client and the report on violations (✗-mark signiﬁes violation)
Property
OP1
OP2
OP3
OP4
OP5
OP6
Property Description
The client must not accept any change cipher spec message from the server (ServerCCS) received in out
of order during a handshake
The client must not complete a handshake without receiving a ServerCCS from the server
The client must not complete a handshake if the server skips the ServerHelloDone message
The client must not complete a handshake when the ServerFinished message is received early (even
before ServerHelloDone)
The client must not accept a ServerCertificate message after accepting a ServerKeyExchange
message
The client must not accept a ServerKeyExchange message after accepting a CertificateRequest
message
TLS OP
✗
Total:
1
TABLE III: Properties for Telnet server and the report on violations (✗-mark signiﬁes violation)
Property
Property Description
Telnet C24
Telnet C27
Telnet F
TP1
TP2
TP3
TP4
TP5
TP6
TP7
TP8
TP9
TP10
TP11
The server must not accept any new connections during an on-going session
If receive WILL after IAC, must send DO or DONT
If receive DO after IAC, must send back WILL or WONT
If receive IAC IAC, must consume the 2nd IAC as regular data
If receive IAC in NORMAL state, must go to IAC state and eventually go
back to NORMAL state
If receive DO after IAC, must go to DO state
If receive WILL after IAC, must go to WILL state
For NVT, if receive DONT after IAC, must NOT send WONT
For NVT, if receive WONT after IAC, must NOT send DONT
For NVT, never send DONT request
For NVT, never send WONT request
Total:
✗
✗
✗
✗
✗
5
✗
✗
✗
✗
4
0
TABLE IV: Properties for DHCP client and the report on violations (✗-mark signiﬁes violation)
Property
DP1
DP2
DP3
DP4
DP5
DP6
DP7
Property Description
If receive DHCPNAK in REQUESTING state, must immediately start over DHCP negotiation
If receive DHCPOFFER in SELECTING state, must immediately send out DHCPREQ and move
to REQUESTING state
If receive no DHCPOFFER in SELECTING state and response timer expired, must resend
DHCPDISCOVER
If receive DHCPOFFER in REQUESTING state, must discard, change no state, take no actions
If receive DHCPACK in REQUESTING state, must immediately move to BOUND state
receive no DHCPACK in REQUESTING state and response timer expired,
If
DHCPREQUEST
If receive no DHCPACK in REQUESTING state and state timer expired, start over DHCP
negotiation
resend
DHCP C
DHCP F
✗
Total:
1
0
sponding implementation where the Telnet server fails to send
back its response while the buffer (named telnetd_buf in the
source) is full. In both implementations, the Telnet server uses
this buffer to temporarily store all outgoing data including the
Telnet command responses and sends the data over the network
from time to time.
A careful inspection of the source reveals that the sendopt
function of the Telnetd implementation does not check if it
has failed to append the response command to the buffer; as a
result, the server never sends back the response to the client.
This semantic bug can cause an interoperability issue since
the client would keep waiting for the reply from the server.
Bug 4 (Potential endless acknowledgment loops). Both
Telnetd implementations from Contiki (Telnet C24 and Tel-
net C27) violate properties TP8 and TP9. According to the
the protocol must acknowledge a DONT
Telnet RFC [12],
(resp., WONT) command by sending out a WONT (resp., DONT)
only if the received DONT (resp., WONT) command causes a
change in the current enabled options; otherwise, it must not
acknowledge. This is needed to prevent potential endless ac-
knowledgment loops where each party considers the incoming
commands as new commands rather than acknowledgments.
Since both Telnet C24 and Telnet C27 implement the Telnet
server as NVT, they must not acknowledge any DONT/WONT
command requests. For both implementations, CHIRON gen-
erates a realizable CEX, which demonstrates that the Telnet
server actually replies back WONT (resp., DONT) when it re-
ceives a DONT (resp., WONT) command request from the client.
There are two possible scenarios where such endless ac-
knowledgment loops can occur: (a) when the client allows
multiple new requests about an option that is currently under
negotiation and (b) if the server connects with a (possibly
TABLE V: Extracted E-FSMs by CHIRON. (EM1 corresponds to the re-
stricted event model described in § IV, and EM2 considers all possible events
with an arbitrary order.)
TABLE VI: Execution time (in Seconds) required by
each component of CHIRON. (‘–’ means CHIRON
found no CEX to replay.)
Event Model 1 (EM1)
Event Model 2 (EM2)
States Transitions Propositions States Transitions Propositions
Protocol
Notation
FSM Ex-
traction
Property
Checking
CEX
Replay
Protocol
Notation
Telnet C24
Telnet C27
Telnet F
DHCP C
DHCP F
TLS OP
6
12
7
4
8
35
84
162
18
46
80
669
19
21
11
17
45
58
6
12
7
4
8
35
114
306
34
47
140
669
19
21
11
17
45
58
Telnet C24
Telnet C27
Telnet F
DHCP C
DHCP F
0.98
6.29
0.16
7.01
15.09
TLS OP
103.15
0.26
0.57
0.15
0.17
0.55
2.05
6.81
122.26
Experi-
ment
Time
4.85
13.65
1.91
8.41
18.96
0.21
0.28
–
0.24
–
that
initiates a DONT/WONT request and also
faulty) client
acknowledges the received DONT and WONT commands. Such
loops can impair the performance of the IoT devices running
either of these implementations.
Bug 5 (No immediate start over of DHCP conﬁguration).
According to the RFC [13], a DHCP client receiving a
DHCPNAK message from the DHCP server as a response to
its previously sent DHCPREQUEST message must immediately
restart the DHCP conﬁguration process by sending a new
DHCPDISCOVER message (property DP1). In our analysis of
implementation for Contiki (DHCP C),
the DHCP client
CHIRON generates a realizable CEX demonstrating an exe-
cution path of the implementation that violates this property.
A close inspection of the source reveals that DHCP C
does not handle the reception of DHCPNAK messages. Instead,
it keeps on retransmitting its DHCPREQUEST upon timeout
for multiple times before giving up and then starts over
the conﬁguration process. Though this does not lead to any
inconsistencies, it hinders the performance by continuing inef-
fective retransmissions, which can drain power constrained IoT
devices as switching the radio on is a power-hungry operation.
C. Performance
Our experiments were run on a commodity machine
equipped with an Intel Core i7-2620M CPU and 8GB of RAM,
running Ubuntu 14.04 with Linux kernel 3.13.
Size of E-FSM. In Table V, we demonstrate the advantage of
the optimization about enforcing the feasible order of network
events (see §IV) by comparing the E-FSMs extracted for two
event models: (a) Event Model 1 (EM1) corresponds to the
user-provided restricted event model that considers only the
feasible order of the occurrence of the network events in an
actual execution of the protocol, and (b) Event Model 2 (EM2)
represents the less restrictive event model where an event from
the set of all possible network events can occur in any arbitrary
order. For both models, the E-FSMs contain the same number
of FSM states and propositions. However, the E-FSMs for EM2
have more transitions as expected. Most of them are spurious
since they can never actually occur. In case of TLS OP, the
E-FSMs for both the event models have the same number of
transitions since there is only one relevant network event (i.e.,