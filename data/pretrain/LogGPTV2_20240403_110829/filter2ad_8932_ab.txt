而该项目的实现本质无疑是分析整个Apk工程的 **Dalvik操作码**
,为操作码分配相应的句柄以具体处理操作码的操作对象,并依据处理结果进一步分析Apk内各个类的成员与方法,生成对应的分析报告用以联动JADX.(关于Dalvik操作码,可以参考[
**Gabor Paller**](http://pallergabor.uw.hu/index.en.html "Gabor
Paller")于2009年提供的[ **Dalvik
Opcodes**](http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html "Dalvik
Opcodes")).
## 像Dalvik虚拟机一样思考
分析Apk无不分析其Dex,分析Dex无不Dump其IR, **得其IR** ,何如?  
正如前文所述,该项目旨在通过分析成员间关系与DataFlow以辅助逆向工程,然则不论如何分析,深入到Dex文件其操作码总是必要的.虽从Dex中获取Dalvik操作码的方法有千百种,但论如何处理操作码及其
**处理思想**
,固然是要引Google之鉴的.然则自Android5.0开始,Google就弃用Dalvik转而以ART虚拟机处理Dex,但ART绝大情况下使用AOT技术,
**仅于技术需求而言,该项目对操作码的处理思想必然要取JIT之鉴** ,故该部分将分析Dalvik虚拟机处理字节码的部分实现, **进以指导项目实现**.  
以[
**Android-4.0.1_r1**](https://android.googlesource.com/platform/dalvik/+/refs/tags/android-4.0.1_r1
"android-4.0.1_r1")分支下的Dalvik虚拟机源码为例,Dex实例将流入`Frontend.cpp`文件下`dvmCompileTrace`函数,该函数正是将Dalvik字节码转换为机器码的入口函数.  
该函数不断遍历包含字节码的基本块,最终将携带Dalvik字节指令的`cUnit`成员引用传入`compileLoop`函数下,而`compileLoop`函数最终将引用传入`CodegenDriver.cpp`文件下的关键函数
**`dvmCompilerMIR2LIR`** ,顾名思义, **此函数将Dalvik字节指令处理为LIR** ,最终由其他方法处理LIR为机器码.  
`dvmCompilerMIR2LIR`函数下`cUnit`成员引用中携带的Dalvik字节码被传入`dexGetFormatFromOpcode`函数下处理为`dalvikFormat`成员,最终该成员被传入一个巨大的switch-case块中进行处理,该switch-case块根据`dalvikFormat`成员为`cUnit`成员分配对应的处理句柄(handle)以具体处理其携带的Dalvik字节码即其操作对象(即寄存器).  
至此, **Android4.0 Dalvik虚拟机**
处理字节码的大致流程已经分析完毕,如上图流程图所示,该流程及其Dalvik字节码处理思想将被运用到接下来的项目结构中.
## 项目实现
> **项目已经开源** ,可至[ **AntiProguard-> KRSFinder**](https://github.com/MG1937/AntiProguard-KRSFinder "AntiProguard-> KRSFinder")下查看项目具体代码.
基于前文对Dalvik虚拟机处理字节码的流程分析,基于Dalvik思想绘制如上流程图,该图所示流程在项目正式开始前被作为 **理想流程框架**
用以指导项目进行,并且在已经完成的项目中其对字节码的大致处理流程也接近该理想流程框架.
由Dalvik虚拟机源码下[docs](https://android.googlesource.com/platform/dalvik/+/refs/tags/android-4.0.1_r1/docs/
"docs")文件夹中文档的部分描述可知Dalvik虚拟机是 **基于寄存器**
的.故项目也需要一个组件用以储存寄存器,该组件即为项目中`TempRegisterMap.cs`文件下的`TempRegisterMap`类.而该组件本质上是一个`Dictionary`对象,该组件其键为Dalvik操作码具体操作的
**寄存器其名** (即p0,v0...),其值为`TempRegister`对象,该对象即代表一个具体的寄存器,此寄存器
**目前仅需要储存字符串与方法**.下图为该组件大致结构.  
下面部分为项目对单个Dalvik字节码处理部分,该部分模仿了Dalvik虚拟机处理字节码的模式.  
上图为项目下`MethodCodeAnalyseModule.cs`文件中`MethodCodeAnalyseModule`类的
**`methodAnalyse`**
函数,该函数为项目处理操作码的正式入口,可以看到该部分我效仿Dalvik虚拟机处理单个字节码的流程模式,为即将处理的操作码分类,并为之分配处理句柄以具体解析操作码及其携带的寄存器,值得一提的是该函数的实现
**并不完全** 与Dalvik虚拟机处理操作码的形式相同,在正式为操作码分配处理句柄前,我将操作码的处理优先级以
**`MUST`,`CHECK`,`PASS`**
划分,被赋予`MUST`优先级的操作码将被优先分配处理句柄,赋予`CHECK`优先级的操作码将在检查其具体操作的寄存器 **是否有必要处理**
后再为操作码分配处理句柄,赋予`PASS`优先级的操作码将不进行任何解析,以此略去部分不必要解析的操作码,以加快整个流程的处理速度.
在正式进入下个部分前,有必要阐述清楚函数中 **方法区块** (以下称为 **块** )的含义.  
Dex中以MIR形式储存的函数不仅以多个字节码组成的串形式保存,单个函数也可被分为多个 **块** ,即以多个块组成一个函数,欲简单理解 **块**
,可以[ **ASM**](https://en.wikipedia.org/wiki/Assembly_language "ASM")中的 **JMP**
指令为参考,JMP指令可以跳跃到内存中的任意地址,而在Dalvik中则以 **块** 为跳跃对象,即在Dalvik中以 **块**
为基本单位组成执行流程.以市面上常见的工具抽离Dex其操作码串,输出的结果中大多以高级语言中 **Label**
的形式表示函数中的块,如下图为带有多个块的函数片段.  
下面部分为项目对单个函数的处理部分.  
先假设项目即将对一个函数进行处理,且该函数被分为数量未知的多个 **块** ,而上图所示流程即为项目在该情况下的大致处理流程, **假设一个理想情况**
,此时块与块之间没有任何指令使得程序跨块跳跃,即执行流程从块顶部向下执行直到方法结束,那么项目将在每个块执行结束时,立刻截取当前块的寄存器集(即`TempRegisterMap`组件)快照,并且记录当前的执行路线,以寄存器集快照为引索保存每次执行路线,那么在该执行流程下,寄存器集将以如下图情况保存.  
那么此时假设块与块之间出现了一个或多个流程控制指令(如 **if,goto** ).
  * 若流程控制指令为 **`goto`** 指令,项目将标记其操作对象为 **强行跳转目标** ,并继续向下执行,但不具体解析非强行跳转目标的块, **直到目标块被找到** 才具体对块中操作码进行解析.
  * 若为 **`if`** 类指令,项目将仅对其操作对象进行标记,而 **不令项目强行寻找目标块** ,正常向下执行 **并解析** 块.
以如上两种流程控制方法尽可能覆盖到大多数由流程控制指令导致的未知数量的解析路线.
假设块与块之间出现了数量未知的`goto`指令,此时处理流程将为下图所示.  
从流程上来看似乎处理过程没有太大变化,但此时构造一个在Dalvik执行流程上能够影响寄存器内容的函数片段,此时且看下图处理结果.  
项目对流程的控制及寄存器集快照保存的作用就在此体现,从上图给出的函数片段可知块`L1`中的`v1`寄存器为执行流程所改变,若不保存寄存器集快照,就不能够完全记录寄存器的前后变化.  
上文即为项目对单个函数的大致处理流程,该部分也是项目最核心的部分,不论是成员关系分析还是DataFlow分析,其结果的精确度都依赖于此,更多细节不再在此文写出,至此,本文完结.