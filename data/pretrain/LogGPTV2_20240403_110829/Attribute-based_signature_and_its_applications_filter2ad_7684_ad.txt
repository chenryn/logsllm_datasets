to enable attribute-based messaging. In ACSAC, pages 403–413. IEEE Computer Society, 2006.
14
[6] R. Bobba, O. Fatemieh, F. Khan, A. Khan, C. Gunter, H. Khurana, and M. Prabhakaran. Attribute
based messaging: Access control and conﬁdentiality. Manuscript (under submission), 2008.
[7] D. Boneh and X. Boyen. Secure identity based encryption without random oracles. In M. K. Franklin,
editor, CRYPTO, volume 3152 of Lecture Notes in Computer Science, pages 443–459. Springer, 2004.
[8] D. Boneh and X. Boyen. Short signatures without random oracles. In C. Cachin and J. Camenisch,
editors, EUROCRYPT, volume 3027 of Lecture Notes in Computer Science, pages 56–73. Springer,
2004.
[9] D. Boneh, X. Boyen, and H. Shacham. Short group signatures. In M. K. Franklin, editor, CRYPTO,
volume 3152 of Lecture Notes in Computer Science, pages 41–55. Springer, 2004.
[10] D. Boneh and M. K. Franklin. Identity-based encryption from the Weil pairing. SIAM J. Comput.,
32(3):586–615, 2003.
[11] X. Boyen. Mesh signatures.
In M. Naor, editor, EUROCRYPT, volume 4515 of Lecture Notes in
Computer Science, pages 210–227. Springer, 2007.
[12] X. Boyen and B. Waters. Compact group signatures without random oracles. In S. Vaudenay, editor,
EUROCRYPT, volume 4004 of Lecture Notes in Computer Science, pages 427–444. Springer, 2006.
[13] J. Camenisch and T. Groß. Eﬃcient attributes for anonymous credentials. In P. Ning, P. F. Syverson,
and S. Jha, editors, ACM Conference on Computer and Communications Security, pages 345–356. ACM,
2008.
[14] M. Chase. Multi-authority attribute based encryption. In S. P. Vadhan, editor, TCC, volume 4392 of
Lecture Notes in Computer Science, pages 515–534. Springer, 2007.
[15] M. Chase and S. S. M. Chow.
Improving privacy and security in multi-authority attribute-based
In E. Al-Shaer, S. Jha, and A. D. Keromytis, editors, ACM Conference on Computer
encryption.
and Communications Security, pages 121–130. ACM, 2009.
[16] D. Chaum. Security without identiﬁcation: Transaction systems to make big brother obsolete. Commun.
ACM, 28(10):1030–1044, 1985.
[17] D. Chaum and E. van Heyst. Group signatures. In EUROCRYPT, pages 257–265, 1991.
[18] A. De Santis and G. Persiano. Zero-knowledge proofs of knowledge without interaction. In 33rd FOCS,
pages 427–436. IEEE Computer Society Press, 1992.
[19] K. B. Frikken, J. Li, and M. J. Atallah. Trust negotiation with hidden credentials, hidden policies, and
policy cycles. In NDSS. The Internet Society, 2006.
[20] V. Goyal, O. Pandey, A. Sahai, and B. Waters. Attribute-based encryption for ﬁne-grained access control
of encrypted data. In A. Juels, R. N. Wright, and S. D. C. di Vimercati, editors, ACM Conference on
Computer and Communications Security, pages 89–98. ACM, 2006.
[21] J. Groth. Simulation-sound NIZK proofs for a practical language and constant size group signatures. In
X. Lai and K. Chen, editors, ASIACRYPT, volume 4284 of Lecture Notes in Computer Science, pages
444–459. Springer, 2006.
[22] J. Groth and A. Sahai. Eﬃcient non-interactive proof systems for bilinear groups. In N. P. Smart,
editor, EUROCRYPT, volume 4965 of Lecture Notes in Computer Science, pages 415–432. Springer,
2008.
[23] S. Guo and Y. Zeng. Attribute-based signature scheme. In International Conference on Information
Security and Assurance, pages 509–511. IEEE, 2008.
[24] J. Katz, R. Ostrovsky, and M. O. Rabin. Identity-based zero knowledge. In C. Blundo and S. Cimato,
editors, SCN, volume 3352 of Lecture Notes in Computer Science, pages 180–192. Springer, 2004.
[25] D. Khader. Attribute based group signature with revocation. Cryptology ePrint Archive, Report
2007/241, 2007. http://eprint.iacr.org/2007/241.
15
[26] D. Khader. Attribute based group signatures. Cryptology ePrint Archive, Report 2007/159, 2007.
http://eprint.iacr.org/2007/159.
[27] J. Li, M. H. Au, W. Susilo, D. Xie, and K. Ren. Attribute-based signature and its applications. In
D. Feng, D. A. Basin, and P. Liu, editors, ASIACCS, pages 60–69. ACM, 2010.
[28] J. Li and K. Kim. Attribute-based ring signatures. Cryptology ePrint Archive, Report 2008/394, 2008.
http://eprint.iacr.org/2008/394.
[29] N. Li, W. Du, and D. Boneh. Oblivious signature-based envelope. Distributed Computing, 17(4):293–302,
2005.
[30] R. L. Rivest, A. Shamir, and Y. Tauman. How to leak a secret. In C. Boyd, editor, ASIACRYPT,
volume 2248 of Lecture Notes in Computer Science, pages 552–565. Springer, 2001.
[31] J. Rompel. One-way functions are necessary and suﬃcient for secure signatures. In Proc. 22nd STOC,
pages 387–394. ACM, 1990.
[32] A. Sahai. Non-malleable non-interactive zero knowledge and adaptive chosen-ciphertext security. In
FOCS, pages 543–553, 1999.
[33] A. Sahai and B. Waters. Fuzzy identity-based encryption. In R. Cramer, editor, EUROCRYPT, volume
3494 of Lecture Notes in Computer Science, pages 457–473. Springer, 2005.
[34] S. F. Shahandashti and R. Safavi-Naini. Threshold attribute-based signatures and their application to
anonymous credential systems. In B. Preneel, editor, AFRICACRYPT, volume 5580 of Lecture Notes
in Computer Science, pages 198–216. Springer, 2009.
[35] A. Shamir. Identity-based cryptosystems and signature schemes. In CRYPTO, pages 47–53, 1984.
[36] B. Waters. Eﬃcient identity-based encryption without random oracles.
In R. Cramer, editor,
EUROCRYPT, volume 3494 of Lecture Notes in Computer Science, pages 114–127. Springer, 2005.
[37] B. Waters. Ciphertext-policy attribute-based encryption: An expressive, eﬃcient, and provably secure
realization. Cryptology ePrint Archive, Report 2008/290, 2008. http://eprint.iacr.org/2008/290.
A Using ABS
Attribute-based signatures are just a cryptographic primitive fully deﬁned by the above described
algorithms and the security and correctness guarantees. To be useful in a system, ABS has to be
used appropriately. Here we describe the typical usage scenario for ABS.
For the sake of expositional clarity, in this section we consider a setting with a single authority
who sets up the system parameters and public keys, and also issues private keys for each user, for
each of the user’s attributes.7
Mapping Attributes Before describing the operation of the system, we need to relate the
attributes as used in ABS with the attributes that occur in a real-life system. In a typical system
one encounters attributes which have a name and optionally a value. For instance a user may
possess an attribute named age, with a numerical value 25. On the other hand, some attributes
may not have any value attached to them; for instance a user could possess an attribute named
student. ABS, as described above, supports only the latter kind of attributes. Nevertheless, since
the names supported by ABS are free-form strings, one could encode a (name, value) pair into a
single string using an appropriate (standardized) encoding scheme.
7We do not consider the technical issues of how the authority establishes the identity of a user before handing
it any keys. Also, we consider it the authority’s prerogative to determine which attributes should be given to each
requesting user.
16
But it is not enough to encode the attributes; one must also translate the predicates involving the
(name, value) pair into predicates in terms of the encoded string. The above encoding is suﬃcient
if the predicates involve only equality conditions. But for numerical attributes, other comparisons
(like “≥”, “≤”) are also important. This can be taken care of by representing a single numerical
attribute by a few value-less attributes, as has been already pointed out in [20, 4]. We remark that
at the cost of increasing the number of value-less attributes used (thereby increasing private-key
size of the user), one can reduce the size of the predicate representing a comparison condition,
leading to faster operations (signing and veriﬁcation, in our case).
Another issue regarding mapping real-life attributes to ABS attributes relates to attribute
expiry and revocation issues. As discussed below, the collusion-resistance property of ABS provides
suitable ﬂexibility to support revocation. But the exact manner in which this ﬂexibility is used is
a design decision that trades oﬀ eﬃciency and security parameters.
Typical System with ABS In a typical institutional setting, the signature trustee and attribute-
issuing authority coincide.
In that case, the authority runs the ABS.TSetup and ABS.ASetup
routines to generate a global key pair for the scheme, and publishes the public key P K. This
public-key will be picked up by all users who need to create or verify signatures in the system.
Later, each user visits the authority to obtain private keys corresponding to her attributes. Let
A ⊆ A be the set of attributes that the authority wants to give to this user. Then the authority
runs ABS.AttrGen to generate a signing key SKA corresponding to the set of attributes possessed
by that user.
After this, parties can sign and verify messages without further interaction with the authority.
As long as the authority is uncorrupted, the unforgeability guarantee holds. Further, even if the
authority is corrupt, the perfect privacy guarantee holds for the signer.8
In the scenario above the authority issued a single key SKA for the set
Changing Attributes
of attributes A. Once issued this attribute set is never changed. This is usually not satisfactory.
There are two possible solutions that ABS oﬀers.
When a user’s attribute set changes, the authority can reissue an entire new set of signing keys,
generated via ABS.AttrGen. This is akin to establishing a new user with new set of attributes. By
the collusion-resistance the user cannot combine keys in the new set with keys in the old set (or
any other set for that matter). The user can of course still create signatures using the old set of
attributes, so the attributes should be designed to include expiry information if the system requires
revoking the old attributes.
Alternately, if the user simply acquires new attributes, it is not necessary to issue a totally
new key set. Though not apparent from the syntax presented above, in fact our ABS construction
allows the authority to augment a key SKA to SKA∪A(cid:48). (The syntax for this operation is made
explicit in our deﬁnitions for multi-authority ABS in the full-version, where keys are issued for one
attribute at a time.) To allow for augmenting signing keys with new attributes, the authority could
either maintain some state per user (to remember the randomness used to generate the key SKA),
or provide a signed certiﬁcate of some public randomness that the user can keep and must bring
back when requesting each new attribute, or more practically use a pseudorandom function such as
AES to obtain this randomness as a function of the user’s identity. In the latter case, the authority
only needs to remember just one additional pseudorandom function seed (or AES key).
8Of course, if the authority wishes to reveal the user’s attributes, it can; but irrespective of what the authority
reveals, the signer has the guarantee that creating a signature reveals no further information about its attributes
(beyond the fact that its attributes satisﬁed the claim-predicate).
17
B Comparison with Anonymous Credentials
It is useful to compare and contrast ABS with the widely studied notion of anonymous credentials
(AC) [16]. Like ABS, anonymous credential systems allow users to anonymously demonstrate
posession of attributes. Further, a recent AC scheme [1] uses similar basic tools as a couple of our
ABS schemes, namely Groth-Sahai NIZK schemes. However, the goals of AC diﬀer from ABS in
several important ways.
To understand the diﬀerence between AC and ABS, consider using a multi-authority ABS
system to approximate an AC scheme: a user will use an attribute each from the diﬀerent attribute
authorities as her credentials from them. The user can then use signatures from an ABS scheme to
prove the possession of credential from any authority, in an anonymous manner (for instance, by
signing a challenge nonce and a signature key used for further communication).
On the positive side, the ABS approach extends to using an unbounded number of attributes
from each authority, and further revealing only a predicate of the attributes possessed, rather
than the individual attributes themselves. Note that the former requires that with a small, ﬁxed
amount of public key material, the attribute-issuing authority in an ABS scheme can manage an
unbounded universe of attributes. In contrast, an authority in an AC scheme (including the one
in [1]) is typically considered to be responsible for only a single attribute. Put diﬀerently, in
AC schemes, the public key material scales linearly with the number of attributes in the system,
whereas in ABS the public key scales with the number of authorities, but is independent of the
number of attributes in the system. More recently, [13] considers allowing an unbounded universe
of attributes, without suﬀering a corresponding blowup in the public key, but their construction
allows only a single level of disjunctions or conjunctions of attributes.
On the ﬂip side, ABS does not provide the kind of anonymity against authorities that an
AC system provides. Indeed, a signiﬁcant complication that arises in constructing an AC scheme
has to do with ensuring that when the same user registers with multiple authorities, her multiple
registrations cannot be linked with each other. However, multi-authority ABS, as we have proposed,
does not provide this kind of anonymity against the authorities;
it allows colluding attribute
authorities to ﬁnd out which attributes a particular user has. Nevertheless, this information from
the registration phase is the only information that an ABS system leaks; in particular, when a
user proves the possession of credentials, even colluding authorities cannot identify the user. This
provides suﬃcient anonymity in many access control applications, especially if anonymity is required
against entities who do not themselves issue credentials.
The simpler anonymity guarantee in an ABS scheme comes with the advantage that an ABS
scheme is signiﬁcantly more eﬃcient during attribute acquisition. In particular, AC schemes involve
a zero-knowledge proof protocol during this phase, whereas for ABS, this phase can be implemented
using little more than standard digital signatures.
Finally, ABS is a signature scheme as opposed to AC. While a signature scheme can be used
for proving credentials and setting up an authenticated channel based on that, it has many more
applications, and perhaps has a more intuitive semantics than an AC scheme.
In short, ABS is in some ways a simpler primitive compared to AC, with less demanding
anonymity requirements, but with a richer and more expressive functionality, more eﬃcient
implementations, and several new applications.
18
C Proofs and Details of our ABS Constructions
C.1 General Framework
Proof of Theorem 1. Perfect privacy follows directly from the perfect witness hiding of the NIWI
scheme, which our ABS scheme instantiates using the perfectly hiding setup.
Assuming that the NIWI scheme is sound, we show that any adversary A that violates ABS
unforgeability can be converted into an adversary A∗ that violates the security of the underlying
credential bundle scheme, with comparable advantage. Let A∗ simulate a copy of A, and perform
one of the following two simulations in the bundle security experiment:
Simulator 1: Receive from the experiment tvk and run (crs, ψ) ← NIWI.SimSetup. Give
T P K = (crs, tvk) to A as the simulated result of ABS.TSetup. Run (AP K, ASK) ← ABS.ASetup
honestly and give AP K to A. Whenever A makes a query A ⊆ A to the ABS.AttrGen oracle,
compute the response honestly.
Whenever A makes a query (m, Υ) to the ABS.Sign oracle, request from the CB.Gen oracle a
singleton bundle for the pseudo-attribute associated with (m, Υ). Use the result as a witness to
generate a NIWI proof of Φ[vk, m, Υ] to use as the simulated ABS signature.
Whenever A outputs a valid forgery (m∗, Υ∗, π∗), use NIWI.Extract with the trapdoor ψ to
extract a witness for Φ[vk, m∗, Υ∗]. Extraction succeeds with overwhelming probability, thus we
obtain a bundle that contains the pseudo-attribute associated with (m∗, Υ∗) or suﬃcient attributes
to satisfy Υ∗.
If the bundle contains the pseudo-attribute, then it represents a forgery against
tvk from the external forgery experiment, since A∗ has never requested (m∗, Υ∗) from its CB.Gen
oracle.
Simulator 2: Similar to above, except receive a bundle signature veriﬁcation key from the
experiment and treat it as avk instead of tvk. Then generate tvk honestly, and give simulated
ABS signatures to A by generating bundle signatures on the pseudo-attribute. Relay all of A’s
queries on its ABS.AttrGen oracle to the external CB.Gen oracle. Then when A outputs an ABS
forgery, extract it. If the extracted bundle satisﬁes Υ∗ (rather than contains the associated pseudo-
attribute), then the bundle is a forgery in the external experimant.
Both simulations induce identical views for A, and the key observation is that any valid forgery
by A must be extracted to give a forgery suitable for one of the two simulations.
By applying the security of the NIWI scheme in a straight-forward series of hybrids (ﬁrst replace
legitimate signatures with simulated signatures, then replace NIWI.Setup with NIWI.SimSetup), we
see that the advantage of one of the two simulations in its unforgeability game is comparable to
that of A in the ABS forgery game (losing only a factor of 1/2).
From this theorem and the constructions in [31, 18], we see that polynomial-time ABS schemes
exist if enhanced trapdoor permutations exist.
C.2 Eﬃciency of Instantiation 1
We simplify the following eﬃciency analysis by noting that n ≤ (cid:96).
The proof requires (cid:96)(5 + 4k) variables:
for each i ∈ [(cid:96)], the prover must commit to