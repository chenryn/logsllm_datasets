(v1.2) in IDA Pro [2] for static analysis setting.
TIE outputs an upper and lower bound on the inferred
type. We use this to measure the conservativeness of TIE.
For precision, we translate the bound output by TIE into a
single C type by translating the lower bound unless it is ⊥.
If the lower bound is ⊥, we output the upper bound. We
found this heuristic to provide the most accurate results.
 1 1.5 2 2.5 3 0 10 20 30 40 50 60 70 80Type interval lengthNumber of programsTIE w/ inter-procedural analysisTIE w/o inter-procedural analysis-0.4-0.2 0 0.2 0.4 0 10 20 30 40 50 60 70 80Position of real types within type intervalNumber of programsTIE w/ inter-procedural analysisTIE w/o inter-procedural analysis(a) Conservativeness for structural types.
(b) Distance for structural types.
Figure 11. Conservativeness and distance for structural types
Caveats. Hex-rays and REWARDS have an inherently
less informative type system than ours since they are re-
stricted to only C types. For example, REWARDS guesses
that a register holds an uint32 t with no additional
information for 32-bit registers, while Hex-rays guesses
int32 t in the same situation. Our reg32 t reﬂects in
the same situation that we do not know whether the register
is a signed number, unsigned number or pointer.
Thus, we must either convert their types to ours, or vice-
versa. We’ve experimented with both. In order to provide
the most conservative setting for REWARDS and Hex-rays,
we translated each type output as τ by them as the range
[⊥, τ].
8.2 Static analysis
However,
Figure 10 shows the overall results for TIE. Figure 10(a)
shows the type intervals with and without inter-procedural
analysis are roughly correlated.
the inter-
procedural analysis has shorter type intervals because it has
more chance to reﬁne types. Figure 10(b) represents the
position of real types within the type interval normalized
as [−0.5, 0.5]. As the position is closer to the bottom, the
real types are closer to the lower bound in type lattice. As
shown in Figure 10(b), for the both cases, the real types are
closer to the lower bound, which is the most speciﬁc type
in the type interval. However, the inter-procedural analy-
sis has the real types closer to the middle of type interval.
Thus, Figure 10 tells the inter-procedural analysis provides
tighter type interval from the real types at center.
Figure 12 shows the per-program breakdown on conser-
vativeness and precision for TIE and Hex-rays on the test
suite. In the intra-procedural case our inferred type is 28%
more precise than Hex-rays, and with inter-procedural anal-
ysis we are 38% better. While Hex-rays algorithm is pro-
prietary, it appears that in many cases Hex-rays seems to
be guessing types, e.g., any local variable moved to eax is
a signed integer. TIE, on the other hand, is a signiﬁcantly
more principled approach.
We investigated manually cases where TIE inferred an
incorrect bound. We found that one of the leading causes
was typing errors in the original program. For instance,
in the function decimal ascii add of getlimits, a
variable of signed inter stores the return value of strlen,
but the type signature for strlen is unsigned.
Structures. Structure are challenging to infer because we
must identify the base pointer, that ﬁelds are being accessed,
the number of ﬁelds, and the type for each one. Figure 11
breaks out the conservativeness and precision for only struc-
tural types. TIE’s accuracy is conservative 90% on struc-
tural types, while Hex-rays is less than 45%. TIE’s preci-
sion of about 1.5 away from the original C type, which is
about 200% better than Hex-rays. We conclude that TIE
identiﬁes structural types signiﬁcant more conservatively
and precisely than Hex-rays.
8.3 Dynamic analysis
Table 2 shows the result of TIE and REWARDS with
dynamic analysis. The coverage column measures how
many variables are typed. As expected, a dynamic ap-
proach only infers a few variables since only a single path
is executed. Unlike TIE, REWARDS guesses a variable
has type uintn t when no type information is available,
which reduced overall precision since REWARDS would
mis-classify signed integers, pointers, etc. as unsigned inte-
gers. We modiﬁed REWARDS to more conservatively use
type regn t to get a best case scenario for REWARDS
(called REWARDS-c in the table). However, in all cases
TIE is more precise (i.e., has a lower distance to the true
type) and is more conservative than REWARDS.
 0 0.2 0.4 0.6 0.8 1 0 10 20 30 40 50 60 70 80Cumulative average rate of consevative typesNumber of programsHex-raysTIE w/ inter-procedural analysisTIE w/o inter-procedural analysis 0 0.5 1 1.5 2 2.5 3 0 10 20 30 40 50 60 70 80Cumulative average distanceNumber of programsHex-raysTIE w/o inter-procedural analysisTIE w/ inter-procedural analysisFigure 12. Overall results summary for precision measured by distance of inferred type to real type
(left) and conservativeness (right).
 0 0.5 1 1.5 2 2.5 3base64basenamecatchconchgrpchmodchownchrootcksumcommcpcsplitcutdatedddfdircolorsdirnameduechoenvexpandexprfactorfalsefmtfoldgetlimitsgroupshostididjoinkilllinklnlognamelsmd5summkdirmknodmktempmvnicenlnohupodpastepathchkpinkyprprintenvprintfptxpwdreadlinkrmrmdirrunconseqsetuidgidshredshufsleepsortsplitstatstdbufsttysusumteetesttimeouttouchtrtruetruncatetsortttyunameunexpanduniqunlinkuptimeuserswhoamiyesAverage distanceHex-raysTIE w/o inter-procedural constraints generationTIE w/ inter-procedural constraints generation 0 0.2 0.4 0.6 0.8 1base64basenamecatchconchgrpchmodchownchrootcksumcommcpcsplitcutdatedddfdircolorsdirnameduechoenvexpandexprfactorfalsefmtfoldgetlimitsgroupshostididjoinkilllinklnlognamelsmd5summkdirmknodmktempmvnicenlnohupodpastepathchkpinkyprprintenvprintfptxpwdreadlinkrmrmdirrunconseqsetuidgidshredshufsleepsortsplitstatstdbufsttysusumteetesttimeouttouchtrtruetruncatetsortttyunameunexpanduniqunlinkuptimeuserswhoamiyesRate of consevative typesHex-raysTIE w/o inter-procedural constratins generationTIE w/ inter-procedural constraints generationTIE (dynamic)
REWARDS
REWARDS-c
TIE (static w/ 100% coverage)
Program Coverage Conserv. Distance Conserv. Distance Conserv. Distance Conserv.
chroot
Distance
1.76
1.42
1.52
1.63
1.51
1.57
df
groups
hostid
users
average
9.23 %
6.9 %
11.11 %
6.89 %
9.52 %
8.73 %
1.0
1.0
1.0
1.0
1.0
1.0
0.88
1.39
1.47
0.92
1.09
1.15
0.56
0.46
0.48
0.71
0.73
0.59
2.3
2.73
2.22
1.82
1.87
2.19
1.0
1.0
0.96
1.0
0.95
0.98
1.42
1.62
1.7
1.25
1.64
1.53
0.87
0.942
0.93
0.97
0.97
0.93
Table 2. TIE vs. REWARDS with dynamic analysis. TIE is both more precise and more conservative.
A more interesting metric is comparing TIE using static
analysis of the entire program against REWARDS using dy-
namic analysis of a single path. This is interesting because
one of the main motivations for REWARDS dynamic ap-
proach is the hypothesis that static analysis would not be
accurate [12]. We show that in our test cases static anal-
ysis is about as precise as REWARDS but can type 100%
of all variables. We conclude that a static-based approach
can provide results comparable to dynamic analysis, while
offering the advantages of working on multiple paths and
handling control ﬂow.
9 Related Work
Type reconstruction. Our approach to reverse engineer-
ing using type reconstruction is founded upon a long history
of work in programming languages. Using type inference to
aid decompilation has previously been proposed by others,
e.g,. [16, 10, 19]. However, previous work typically tries
to infer C types directly, while we use a type range and a
type system speciﬁcally designed to reﬂect the uncertainty
of reconstruction on binary code. Further, to the best of our
knowledge previous work has not been implemented and
tested on real programs.
As mentioned, the REWARDS system [12] takes a dy-
namic approach to reverse engineering data types. We com-
pare TIE to REWARDS [12] because it is among the latest
and most modern work in the area. We also compare our
system against the Hex-rays decompiler, which is widely
considered the industry standard in decompilation includ-
ing data abstraction reverse engineering.
Semantic Types. REWARDS [12] calls the types printed
by their system “semantic types”. A semantic type in
REWARDS is a manually speciﬁed name for a type sig-
nature, e.g., a structure may have the semantic type
sockaddr t instead of the complete type signature for
the structure. Type ascriptions are useful for printing out
complex types, e.g., printing out sockaddr t as the type
of variable is less cumbersome than printing out the full
type signature struct {short, ushort, ushort
char[14], char[8]}.
REWARDS has code that ascribes their pre-deﬁned
types to the arguments of pre-deﬁned common library func-
tions. The ascribed types are propagated like any other
type. For example, the type signature for open has return
type int. Whenever REWARDS sees a call to open, RE-
WARDS assigns the return variable the ascribed type name
file d instead of the actual type int. If the return vari-
able is then assigned to another variable the new variable
also gets the ascribed type. REWARDS has manually de-
ﬁned about 150 different type names and manually ascribed
those types to about 84 standard library calls.
Type ascription is simple to add as part of type infer-
ence, e.g., the rules can be found in standard type theory
textbooks such as Pierce [17]. While ascribing manually-
deﬁned type names to function arguments as in REWARDS
would certainly make TIE a better tool, it adds no power to
the overall type system thus is left outside the scope of this
work.
Variable Recovery. Our approach for recovering vari-
ables is based upon Balakrishnan et al.
[6, 7]. However,
their work only recovers variable locations, and does not
infer types. While TIE could plug in DIVINE [7] to recover
variables, we use our own algorithm based upon data ﬂow
lattices. BAP and the BIL language are redesigns of the
Vine [3] changed to follow the formal semantics from [1].
Typed Assembly Language. Despite the similarity in
name, Typed Assembly Language (TAL) [14, 15, 9] ad-
dresses a different challenge that ours. The idea of TAL is to
maintain user-provided types for type-safe programs down
through code generation in the compiler in order to ﬁnd
program bugs. After code generation the types are thrown
away. Our problem is to infer types on unsafe programs
(e.g., C types) from binary code. However, type reconstruc-
tion for TAL types is an open, related, and interesting prob-
lem [18].
10 Conclusion
In this paper we presented an end-to-end system for re-
verse engineering data abstractions in binary code called
[11] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna. Static
disassembly of obfuscated binaries. In Proceedings of the
USENIX Security Symposium, 2004.
[12] Z. Lin, X. Zhang, and D. Xu. Automatic reverse engineering
In Proceedings
of data structures from binary execution.
of the Network and Distributed System Security Symposium,
2010.
[13] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,
G. Lowney, S. Wallace, V. J. Reddi, and K. Hazelwood. Pin:
Building customized program analysis tools with dynamic
instrumentation. In Proceedings of the ACM Conference on
Programming Language Design and Implementation, June
2005.
[14] G. Morrisett, K. Crary, N. Glew, and D. Walker. Stack-based
typed assembly language. Journal of Functional Program-
ming, 12(1):43–88, 2002.
[15] G. Morrisett, D. Walker, K. Crary, and N. Glew. From sys-
tem F to typed assembly language. ACM Transactions on
Programming Language Systems, 21(3):527–568, 1999.
[16] A. Mycroft. Type-based decompilation. In European Sym-
posium on Programming, Mar. 1999.
[17] B. C. Pierce. Types and Programming Languages. The MIT
Press, 2002.
[18] B. C. Pierce, editor. Advanced Topics in Types and Program-
ming Languages. The MIT Press, 2005.
[19] G. Ramalingam, J. Field, and F. Tip. Aggregate structure
identiﬁcation and its application to program analysis.
In
Proceedings of the Symposium on Principles of Program-
ming Languages, 1999.
TIE. At the core of our system was a novel type recon-
struction algorithm for binary code. Unlike previous ap-
proaches in research such as REWARDS [12], which are
limited to dynamic analysis of a single execution trace, we
handle control ﬂow and thus are amenable to both a static
and dynamic analysis setting. We do so while providing a
more precise yet conservative type than REWARDS. Our
implementation also shows that TIE is about signiﬁcantly
more precise than the leading industry product (the Hex-
rays decompiler). We conclude that our type reconstruction
techniques and approach is a promising alternative over cur-
rent methods in research and practice.
11 Acknowledgements
We thank Zhiqiang Lin and Dongyan Xu for the RE-
WARDS code and their helpful comments. We also thank
William Lovas for his advise and our anonymous review-
ers for their useful comments and suggestions. This work
was supported by the National Research Foundation of Ko-
rea Grant funded by the Korean Government [NRF-2009-
352-D00282]. This material is also based upon work sup-
ported by the National Science Foundation under Grant No.
0953751. Any opinions, ﬁndings, and conclusions or rec-
ommendations expressed in this material are those of the
authors and do not necessarily reﬂect the views of the Na-
tional Science Foundation.
References
[1] Binary analysis platform (BAP). http://bap.ece.
cmu.edu.
[2] The IDA Pro disassembler and debuger. http://www.
hex-rays.com/idapro/.
[3] BitBlaze binary analysis project. http://bitblaze.
cs.berkeley.edu, 2007.
[4] A. Appel. Modern Compiler Implementation in ML. Cam-
bridge University Press, 1998.
[5] G. Balakrishnan. WYSINWYX: What You See Is Not What
You eXecute. PhD thesis, Computer Science Department,
University of Wisconsin at Madison, Aug. 2007.
[6] G. Balakrishnan and T. Reps. Analyzing memory accesses
in x86 executables. In Proceedings of the International Con-
ference on Compiler Construction, 2004.
[7] G. Balakrishnan and T. Reps. DIVINE: Discovering vari-
In Proceedings of the International
ables in executables.
Conference on Veriﬁcation Model Checking and Abstract In-
terpretation, Jan. 2007.
[8] D. Brumley. Carnegie mellon university security group.
http://security.ece.cmu.edu.
[9] K. Crary. Toward a foundational typed assembly language.
In Symposium on Principles of Programming Languages,
2003.
[10] E. Dolgova and A. Chernov. Automatic reconstruction of
data types in the decompilation problem. Programming and
Computer Software, 35(2):105 – 119, Mar. 2009.