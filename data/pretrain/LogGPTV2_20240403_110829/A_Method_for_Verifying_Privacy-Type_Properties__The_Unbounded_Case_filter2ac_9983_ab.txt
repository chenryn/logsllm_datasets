Example 2: To reﬂect
the algebraic properties of the
exclusive or operator, we may consider the equational theory
generated by the following equations:
566566
x⊕ 0 = x
x⊕ x = 0
(x⊕ y)⊕ z = x⊕(y⊕ z)
(x⊕ y) = (y⊕ x)
In such a case, we have that enc(a⊕(b⊕ a), k)=E enc(b, k).
We may also want to give a meaning to destructor symbols.
For this, we consider the notion of computation relation.
Deﬁnition 1: A computation relation is a relation over
● for any term t, messages u and v, and context t′ (i.e.
T (Σ,N)×T (Σc,N), denoted ⇓, such that:
● n⇓ n for any n∈N ;
● f(t1, . . . , tk)⇓ f(u1, . . . , uk) for f ∈ Σc of arity k and
ti ⇓ ui for all 1≤ i≤ k,
● if t⇓ u then tρ⇓ uρ for any bijective ρ∶N →N ;
a term with a hole) built from Σ and N , if t ⇓ u and
t′[u]⇓ v then t′[t]⇓ v;
● if t′ is a context built from Σ and N , and t1, t2 are
terms such that t1 =E t2 and t′[t1] ⇓ u1 for some u1,
then t′[t2]⇓ u2 for some u2 such that u1 =E u2.
The relation ⇓ associates, to any ground term t, at most one
exists, we say that the computation fails; this is noted t⇓̸. As
a slight abuse of notation, we may sometimes use directly t⇓
message up to the equational theory E. When no such message
as a message, when we know that the computation succeeds
and the choice of representative is irrelevant.
A computation relation is often obtained from a rewriting
system, i.e. a set of rewriting rules g(u1, . . . , un)→ u where g
is a destructor, and u, u1, . . . , un ∈T (Σc,X). A ground term t
rewriting rule g(u1, . . . , un)→ u such that t∣p = g(v1, . . . , vn)
and v1 =E u1θ, . . . , vn =E unθ for some substitution θ, and
t′ = t[uθ]p (i.e. t in which the sub-term at position p has been
can be rewritten into t′ if there is a position p in t and a
replaced by uθ). Moreover, we assume that u1θ, . . . , unθ as
well as uθ are messages.
Example 3: The properties of symbols in Σd (see Exam-
ple 1) are reﬂected through the following rewriting rules:
dec(enc(x, y), y)→ x
πi(⟨x1, x2⟩)→ xi
eq(x, x)→ ok
for i∈{1, 2}.
This rewriting system is convergent modulo the equational the-
ory E given in Example 2, and therefore induces a computation
relation as deﬁned in Deﬁnition 1. For instance, we have that
dec(enc(c, a⊕ b), b⊕ a)⇓ c, whereas dec(enc(c, a⊕ b), b)⇓̸,
and dec(a, b)⊕ dec(a, b)⇓̸.
neq(u, v) ⇓ ok if, and only if, u and v can be reduced to
Our generic notion of computation relation gives us enough
ﬂexibility to deﬁne a destructor symbol neq, and consider that
messages that are not equal modulo E.
For modeling purposes, we split the signature Σ into two
parts, namely Σpub and Σpriv. An attacker builds his own
messages by applying public function symbols to terms he
already knows and that are available through variables in W.
a term in T (Σpub,W). Recipes will be denoted by R, M, N.
Formally, a computation done by the attacker is a recipe, i.e.
Note that, although we do not give the attacker the ability to
generate fresh names to use in recipes, we obtain essentially
the same capability by assuming an inﬁnite supply of public
constants in Σc∩ Σpub.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:14:24 UTC from IEEE Xplore.  Restrictions apply. 
B. Process algebra
We consider a set C of channel names that are assumed to
be public. Protocols are modeled through processes using the
grammar in Figure 1.
P, Q ∶= 0
in(c, x).P
out(c, u).P
let x= v in P else Q
∣
∣
∣
∣ P ∣ Q
∣
∣
!P
νn.P
null
input
output
evaluation
parallel
replication
restriction
where c∈C, x∈X , n∈N , u∈T (Σc,N ∪X) is a constructor
term, x (resp. v) is a sequence of variables in X (resp. terms
in T (Σ,N ∪X)) both of the same length.
Fig. 1. Syntax of processes
Most of the constructions are rather standard. We may note
the special construct let x = v in P else Q that combines
the sequence of terms v and in case of success, i.e. when v ⇓ u
several standard constructions, allowing to write computations
and conditionals compactly. Such a process tries to evaluate
for some messages u, the process P in which x are replaced
by u is executed; otherwise the process Q is executed. The goal
of this construct is to avoid nested let instructions to be able to
deﬁne our class of protocols in a simple way later on. Note also
that the let instruction together with the eq theory as deﬁned
in Example 3 can encode the usual conditional construction.
Indeed, “let x = eq(u, v) in P else Q” will execute P only if
the computation succeeds on eq(u, v), that is only if u ⇓ u′,
v ⇓ v′, and u′ =E v′ for some messages u′ and v′.
after outputs. We write fv(P) for the set of free variables
input or a let construct. A process P is ground if fv(P)=∅.
of P , i.e. the set of variables that are not in the scope of an
For brevity, we sometimes omit “else 0” and null processes
Example 4: We consider the RFID protocol due to Feld-
hofer et al. as described in [24] and which can be presented
using Alice & Bob notation as follows:
1.
I → R ∶ nI
2. R → I ∶ {nI , nR}k
I → R ∶ {nR, nI}k
3.
∶= νk.(νnI .PI ∣ νnR.PR)
The protocol is between an initiator I (the reader) and a
responder R (the tag) that share a symmetric key k. We con-
sider the term algebra introduced in Example 3. The protocol
is modeled by the parallel composition of the processes PI
and PR, corresponding respectively to the roles I and R.
PI
PFh
where PI and PR are deﬁned as follows, with u= dec(x1, k):
∶= out(cI , nI).in(cI , x1).
let x2, x3 = eq(nI , π1(u)), π2(u) in
out(cI , enc(⟨x3, nI⟩, k))
let y3 = eq(y2, enc(⟨nR, y1⟩, k)) in 0
PR ∶= in(cR, y1).out(cR, enc(⟨y1, nR⟩, k)).in(cR, y2).
C. Semantics
are implicitly removed;
The operational semantics of processes is given by a labeled
transition system over conﬁgurations (denoted by K) which
are pairs (P; φ) where:
● P is a multiset of ground processes where null processes
● φ = {w1 ↦ u1, . . . , wn ↦ un} is a frame,
substitution where w1, . . . , wn are variables in W, and
We often write P ∪ P instead of {P} ∪ P. The terms
Given a conﬁguration K, φ(K) denotes its second component.
cases, the corresponding frame is ∅.
in φ represent the messages that are known by the attacker.
Sometimes, we consider processes as conﬁgurations, in such
u1, . . . , un are messages.
i.e. a
The operational semantics of a process is given by the
α(cid:18)→ deﬁned in Figure 2. The rules are quite standard
relation
and correspond to the intuitive meaning of the syntax given
in the previous section. The ﬁrst rule allows the attacker to
send on channel c a message as soon as it is the result of
a computation done by applying public function symbols on
messages that are in his current knowledge. The second rule
corresponds to the output of a term: the corresponding term
is added to the frame of the current conﬁguration, which
means that the attacker gains access to it. The third and fourth
rules correspond to the evaluation of a sequence of terms
v = v1, . . . , vn; if this succeeds, i.e. if there exist messages
u1, . . . un such that v1 ⇓ u1, . . . vn ⇓ un then variables x are
bound to those messages, and P is executed; otherwise the
process will continue with Q. The three remaining rules allow
one to execute a restriction, unfold a replication, and split a
parallel composition. The two ﬁrst rules are the only observ-
able actions. However, for reasons that will become clear later
on, we make a distinction when a process evolves using LET
or LET-FAIL. The relation
(where α1 . . . αn is a sequence of actions) is deﬁned as the
transitive closure of
α1...αn(cid:18)(cid:18)(cid:18)(cid:18)→ between conﬁgurations
α(cid:18)→.
Example 5: Continuing Example 4. We have that:
tr(cid:18)→(∅; φ0)
PFh
where tr and φ0 are as follows, for fresh names k′, n′
tr ={ τ.τ.τ.τ.out(cI , w1).in(cR, w1).out(cR, w2)
φ0 ={w1 ↦ n′
in(cI , w2).τthen.out(cI , w3).in(cR, w3).τthen
I , w2 ↦ enc(⟨n′
I⟩, k′)}.
R⟩, k′),
w3 ↦ enc(⟨n′
I and n′
R, n′
I , n′
R:
This execution corresponds to a normal execution of one
session of the protocol.
D. Trace equivalence
We are concerned with trace equivalence, which is com-
monly used [9], [25] to express many privacy-type properties
such as anonymity, unlinkability, strong secrecy, etc. Intu-
itively, two conﬁgurations are trace equivalent if an attacker
567567
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:14:24 UTC from IEEE Xplore.  Restrictions apply. 
IN
OUT
LET
LET-FAIL
NEW
REPL
PAR
(in(c, x).P ∪P; φ) in(c,R)(cid:18)(cid:18)(cid:18)(cid:18)→ (P{x↦ u}∪P; φ) where R is a recipe such that Rφ⇓ u for some message u
with w a fresh variable in W
(out(c, u).P ∪P; φ) out(c,w)
(cid:18)(cid:18)(cid:18)(cid:18)(cid:18)→ (P ∪P; φ∪{w ↦ u})
(let x= v in P else Q∪P; φ) τthen(cid:18)(cid:18)→ (P{x↦ u}∪P; φ)
when v ⇓ u for some u
(let x= v in P else Q∪P; φ) τelse(cid:18)(cid:18)→ (Q∪P; φ)
when vi ⇓̸ for some vi ∈ v
(νn.P ∪P; φ) τ(cid:18)→ (P ∪P; φ)
where n is a fresh name from N
(!P ∪P; φ) τ(cid:18)→ (P ∪ !P ∪P; φ)
({P1 ∣ P2}∪P; φ) τ(cid:18)→ ({P1, P2}∪P; φ)
Fig. 2. Semantics for processes
cannot tell whether he is interacting with one or the other. Be-
fore deﬁning formally this notion, we ﬁrst introduce a notion
of equivalence between frames, called static equivalence.
Deﬁnition 2: A frame φ is statically included in φ′ when
dom(φ)= dom(φ′), and
● for any recipe R such that Rφ ⇓ u for some u, we have
that Rφ′ ⇓ u′ for some u′;
● for any recipes R1, R2 such that R1φ ⇓ u1, R2φ ⇓ u2,
and u1 =E u2, we have that R1φ′ ⇓=E R2φ′ ⇓, i.e. there
exist v1, v2 such that R1φ′ ⇓ v1, R2φ′ ⇓ v2, and v1 =E v2.
Two frames φ and φ′ are in static equivalence, written φ∼ φ′,
if the two static inclusions hold.
Intuitively, an attacker can distinguish two frames if he is
able to perform some computation (or a test) that succeeds
in φ and fails in φ′ (or the converse).
Example 6: Consider the frame φ0 as given in Example 5,
we have that φ0 ⊔{w4 ↦ k′} /∼ φ0 ⊔{w4 ↦ k′′}. Indeed, the
attacker may observe that the computation R = dec(w2, w4)
succeeds in φ⊔{w4 ↦ k′} but fails in φ⊔{w4 ↦ k′′}.
that
the fact
Then, trace equivalence is the active counterpart of static
equivalence taking into account
the attacker
may interfere during the execution of the process in order
to distinguish between the two situations.
Given a conﬁguration K =(P; φ), we deﬁne trace(K):
trace(K)={(tr, φ′) ∣ (P, φ) tr(cid:18)→(P ′; φ′)
for some conﬁguration (P ′; φ′)}.
We deﬁne obs(tr) to be the subsequence of tr obtained by
that K is trace included in K ′, written K ⊑ K ′, when, for any
(tr, φ) ∈ trace(K) there exists (tr′, φ′) ∈ trace(K ′) such that
obs(tr) = obs(tr′) and φ ∼ φ′. They are in trace equivalence,
written K ≈ K ′, when K ⊑ K ′ and K ′ ⊑ K.
K =(!PFh;∅) and K ′ = (!νk.(!νnI .PI ∣ !νnR.PR);∅) are in
Deﬁnition 3: Let K and K ′ be two conﬁgurations. We say
Example 7: We may be interested in checking whether
erasing all the τ actions (i.e. τ, τthen, τelse).
trace equivalence. Intuitively, this equivalence models the fact
that PFh is unlinkable: each session of the protocol appears to
an attacker as if it has been initiated by a different tag, since
a given tag can perform at most one session in the idealized
scenario K. This equivalence actually holds. It is non-trivial,
and cannot be established using existing veriﬁcation tools such
as ProVerif or Tamarin. The technique developed in this paper
will notably allow one to establish it automatically.
III. OUR CLASS OF PROTOCOLS AND PROPERTIES
We aim to propose sufﬁcient conditions to ensure unlinka-
bility and anonymity for a generic class of 2-party protocols.
In this section, we deﬁne formally the class of protocols and
the security properties we are interested in.
A. A generic class of 2- party protocols
As already mentioned, we consider 2-party protocols that
are therefore made of two roles called the initiator and
responder role respectively. We assume a set L of labels that
will be used to name output actions in these roles, allowing
us to identify outputs that are performed by a same syntactic