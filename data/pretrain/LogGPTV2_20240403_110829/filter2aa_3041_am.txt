声明新的用户定义的类型
使用方法，为类型增加新的行为
了解何时使用指针，何时使用值
通过接口实现多态
通过组合来扩展或改变类型
公开或者未公开的标识符
Go 语言是一种静态类型的编程语言。这意味着，编译器需要在编译时知晓程序里每个值的
类型。如果提前知道类型信息，编译器就可以确保程序合理地使用值。这有助于减少潜在的内存
异常和 bug，并且使编译器有机会对代码进行一些性能优化，提高执行效率。 
值的类型给编译器提供两部分信息：第一部分，需要分配多少内存给这个值（即值的规模）；
第二部分，这段内存表示什么。对于许多内置类型的情况来说，规模和表示是类型名的一部分。
int64 类型的值需要 8 字节（64 位），表示一个整数值；float32 类型的值需要 4 字节（32 位），
表示一个 IEEE-754 定义的二进制浮点数；bool 类型的值需要 1 字节（8 位），表示布尔值 true
和 false。
有些类型的内部表示与编译代码的机器的体系结构有关。例如，根据编译所在的机器的体系
结构，一个 int 值的大小可能是 8 字节（64 位），也可能是 4 字节（32 位）。还有一些与体系结
构相关的类型，如 Go 语言里的所有引用类型。好在创建和使用这些类型的值的时候，不需要了
解这些与体系结构相关的信息。但是，如果编译器不知道这些信息，就无法阻止用户做一些导致
程序受损甚至机器故障的事情。 
5.1  用户定义的类型 
Go 语言允许用户定义类型。当用户声明一个新类型时，这个声明就给编译器提供了一个框
5
第 5 章 Go 语言的类型系统 
架，告知必要的内存大小和表示信息。声明后的类型与内置类型的运作方式类似。Go 语言里声
明用户定义的类型有两种方法。最常用的方法是使用关键字 struct，它可以让用户创建一个结
构类型。 
结构类型通过组合一系列固定且唯一的字段来声明，如代码清单 5-1 所示。结构里每个字段
都会用一个已知类型声明。这个已知类型可以是内置类型，也可以是其他用户定义的类型。 
代码清单 5-1 声明一个结构类型 
01 // user 在程序里定义一个用户类型 
02 type user struct { 
03 
 name 
 string 
04 
 email 
 string 
05 
 ext 
 int 
06 
 privileged bool 
07 } 
在代码清单 5-1 中，可以看到一个结构类型的声明。这个声明以关键字 type 开始，之后是
新类型的名字，最后是关键字 struct。这个结构类型有 4 个字段，每个字段都基于一个内置类
型。读者可以看到这些字段是如何组合成一个数据的结构的。一旦声明了类型（如代码清单 5-2
所示），就可以使用这个类型创建值。 
代码清单 5-2 使用结构类型声明变量，并初始化为其零值 
09 // 声明 user 类型的变量 
10 var bill user 
在代码清单 5-2 的第 10 行，关键字 var 创建了类型为 user 且名为 bill 的变量。当声明
变量时，这个变量对应的值总是会被初始化。这个值要么用指定的值初始化，要么用零值（即变
量类型的默认值）做初始化。对数值类型来说，零值是 0；对字符串来说，零值是空字符串；对
布尔类型，零值是 false。对这个例子里的结构，结构里每个字段都会用零值初始化。
任何时候，创建一个变量并初始化为其零值，习惯是使用关键字 var。这种用法是为了更明
确地表示一个变量被设置为零值。如果变量被初始化为某个非零值，就配合结构字面量和短变量
声明操作符来创建变量。 
代码清单 5-3 展示了如何声明一个 user 类型的变量，并使用某个非零值作为初始值。在第
13 行，我们首先给出了一个变量名，之后是短变量声明操作符。这个操作符是冒号加一个等号
（:=）。一个短变量声明操作符在一次操作中完成两件事情：声明一个变量，并初始化。短变量
声明操作符会使用右侧给出的类型信息作为声明变量的类型。 
代码清单 5-3 使用结构字面量来声明一个结构类型的变量 
12 // 声明 user 类型的变量，并初始化所有字段 
13 lisa := user{ 
14 
 name: 
 "Lisa", 
15 
 email: 
 "PI:EMAIL", 
16 
 ext: 
 123, 
17 
 privileged: true, 
18 } 
既然要创建并初始化一个结构类型，我们就使用结构字面量来完成这个初始化，如代码清
单 5-4 所示。结构字面量使用一对大括号括住内部字段的初始值。 
代码清单 5-4 使用结构字面量创建结构类型的值 
13 user{ 
14 
 name: 
 "Lisa", 
15 
 email: 
 "PI:EMAIL", 
16 
 ext: 
 123, 
17 
 privileged: true, 
18 } 
结构字面量可以对结构类型采用两种形式。代码清单 5-4 中使用了第一种形式，这种形式在
不同行声明每个字段的名字以及对应的值。字段名与值用冒号分隔，每一行以逗号结尾。这种形
式对字段的声明顺序没有要求。第二种形式没有字段名，只声明对应的值，如代码清单 5-5 所示。 
代码清单 5-5 不使用字段名，创建结构类型的值 
12 // 声明 user 类型的变量 
13 lisa := user{"Lisa", "PI:EMAIL", 123, true} 
每个值也可以分别占一行，不过习惯上这种形式会写在一行里，结尾不需要逗号。这种形式
下，值的顺序很重要，必须要和结构声明中字段的顺序一致。当声明结构类型时，字段的类型并
不限制在内置类型，也可以使用其他用户定义的类型，如代码清单 5-6 所示。 
代码清单 5-6 使用其他结构类型声明字段 
20 // admin 需要一个 user 类型作为管理者，并附加权限 
21 type admin struct { 
22 
 person user 
23 
 level  string 
24 } 
代码清单 5-6 展示了一个名为 admin 的新结构类型。这个结构类型有一个名为 person 的
user 类型的字段，还声明了一个名为 level 的 string 字段。当创建具有 person 这种字段
的结构类型的变量时，初始化用的结构字面量会有一些变化，如代码清单 5-7 所示。 
代码清单 5-7 使用结构字面量来创建字段的值 
26 // 声明 admin 类型的变量 
27 fred := admin{ 
28 
 person: user{ 
29 
 name:  
 "Lisa", 
30 
 email: 
 "PI:EMAIL", 
31 
 ext: 
 123, 
32 
 privileged: true, 
33 
 }, 
34 
 level: "super", 
35 } 
为了初始化 person 字段，我们需要创建一个 user 类型的值。代码清单 5-7 的第 28 行就
是在创建这个值。这行代码使用结构字面量的形式创建了一个 user 类型的值，并赋给了 person
字段。 
另一种声明用户定义的类型的方法是，基于一个已有的类型，将其作为新类型的类型说明。
当需要一个可以用已有类型表示的新类型的时候，这种方法会非常好用，如代码清单 5-8 所示。
标准库使用这种声明类型的方法，从内置类型创建出很多更加明确的类型，并赋予更高级的功能。 
代码清单 5-8 基于 int64 声明一个新类型
type Duration int64 
代码清单 5-8 展示的是标准库的 time 包里的一个类型的声明。Duration 是一种描述时间
间隔的类型，单位是纳秒（ns）。这个类型使用内置的 int64 类型作为其表示。在 Duration
类型的声明中，我们把 int64 类型叫作 Duration 的基础类型。不过，虽然 int64 是基础
类型，Go 并不认为 Duration 和 int64 是同一种类型。这两个类型是完全不同的有区别的
类型。 
为了更好地展示这种区别，来看一下代码清单 5-9 所示的小程序。这个程序本身无法通过
编译。 
代码清单 5-9 给不同类型的变量赋值会产生编译错误 
01 package main 
02 
03 type Duration int64 
04 
05 func main() { 
06 
 var dur Duration 
07 
 dur = int64(1000) 
08 } 
代码清单 5-9 所示的程序在第 03 行声明了 Duration 类型。之后在第 06 行声明了一个类型
为 Duration 的变量 dur，并使用零值作为初值。之后，第 7 行的代码会在编译的时候产生编
译错误，如代码清单 5-10 所示。 
代码清单 5-10 实际产生的编译错误 
prog.go:7: cannot use int64(1000) (type int64) as type Duration 
 in assignment 
编译器很清楚这个程序的问题：类型 int64 的值不能作为类型 Duration 的值来用。换句
话说，虽然 int64 类型是基础类型，Duration 类型依然是一个独立的类型。两种不同类型的
值即便互相兼容，也不能互相赋值。编译器不会对不同类型的值做隐式转换。 
5.2  方法 
方法能给用户定义的类型添加新的行为。方法实际上也是函数，只是在声明时，在关键字
func 和方法名之间增加了一个参数，如代码清单 5-11 所示。
代码清单 5-11 listing11.go 
01 // 这个示例程序展示如何声明 
02 // 并使用方法 
03 package main 
04 
05 import ( 
06 
 "fmt" 
07 ) 
08 
09 // user 在程序里定义一个用户类型 
10 type user struct { 
11 
 name  string 
12 
 email string 
13 } 
14 
15 // notify 使用值接收者实现了一个方法 
16 func (u user) notify() { 
17 
 fmt.Printf("Sending User Email To %s\n", 
18 
 u.name, 
19 
 u.email) 
20 } 
21 
22 // changeEmail 使用指针接收者实现了一个方法 
23 func (u *user) changeEmail(email string) { 
24 
 u.email = email 
25 } 
26 
27 // main 是应用程序的入口 
28 func main() { 
29 
 // user 类型的值可以用来调用 
30 
 // 使用值接收者声明的方法 
31 
 bill := user{"Bill", "PI:EMAIL"} 
32 
 bill.notify() 
33 
34 
 // 指向 user 类型值的指针也可以用来调用 
35 
 // 使用值接收者声明的方法 
36 
 lisa := &user{"Lisa", "PI:EMAIL"} 
37 
 lisa.notify() 
38 
39 
 // user 类型的值可以用来调用 
40 
 // 使用指针接收者声明的方法 
41 
 bill.changeEmail("PI:EMAIL") 
42 
 bill.notify() 
43 
44 
 // 指向 user 类型值的指针可以用来调用 
45 
 // 使用指针接收者声明的方法 
46 
 lisa.changeEmail("PI:EMAIL") 
47 
 lisa.notify() 
48 } 
代码清单 5-11 的第 16 行和第 23 行展示了两种类型的方法。关键字 func 和函数名之间的
参数被称作接收者，将函数与接收者的类型绑在一起。如果一个函数有接收者，这个函数就被称
为方法。当运行这段程序时，会得到代码清单 5-12 所示的输出。 
代码清单 5-12 listing11.go 的输出 
Sending User Email To Bill 
Sending User Email To Lisa 
Sending User Email To Bill 
Sending User Email To Lisa 
让我们来解释一下代码清单 5-13 所示的程序都做了什么。在第 10 行，该程序声明了名为 user
的结构类型，并声明了名为 notify 的方法。
代码清单 5-13 listing11.go：第 09 行到第 20 行 
09 // user 在程序里定义一个用户类型 
10 type user struct { 
11 
 name  string 
12 
 email string 
13 } 
14 
15 // notify 使用值接收者实现了一个方法 
16 func (u user) notify() { 
17 
 fmt.Printf("Sending User Email To %s\n", 
18 
 u.name, 
19 
 u.email) 
20 } 
Go 语言里有两种类型的接收者：值接收者和指针接收者。在代码清单 5-13 的第 16 行，使
用值接收者声明了 notify 方法，如代码清单 5-14 所示。
代码清单 5-14 使用值接收者声明一个方法 
func (u user) notify() { 
notify 方法的接收者被声明为 user 类型的值。如果使用值接收者声明方法，调用时会使
用这个值的一个副本来执行。让我们跳到代码清单 5-11 的第 32 行来看一下如何调用 notify 方
法，如代码清单 5-15 所示。 
代码清单 5-15 listing11.go：第 29 行到第 32 行 