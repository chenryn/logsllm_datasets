翻译： **k0shl**
论文地址：http://www.cs.vu.nl/~herbertb/download/papers/anc_ndss17.pdf
作者博客：http://whereisk0shl.top
* * *
## 前言
这个关于侧信道攻击很有意思，也是颠覆一些传统观念的研究，非常值得研究，anc_ndss17.pdf是一个非常好的论文，我对这篇论文进行了翻译，同时也对AnC的源码进行了编译，初步测试，下一步打算仔细研究源码，目前C源码支持x86-64，ARM，以及AMD，平台主要在Linux，VUSec没有公开Javascript代码，因为js的实现可能对于浏览器，adobe系列等等来说还是存在很大危害的，因为这个厂商无法缓解。
但是对C源码的学习有利于我们熟悉这个漏洞，同时也有可能能将其用js实现，我将分享论文的整体框架和其中关于AnC实现部分。
首先我们来看一下整个源码的运行情况，通过测试，这个源码并非每次都能够跑出最后结果，可能受缓存噪声等因素的影响，导致有时候是失败的。
失败的情况：
成功的情况：
## AnC论文梗概
**第二章我们将提出威胁模型**
**第三章我们将讲解地址转换的细节**
这一章我们将讲解在AnC利用过程中碰到的问题，以及如何解决的
**第四五章我们将讲解解决每一个问题的细节**
**第六章我们会讲解AnC攻击最新Linux上运行的Chrome浏览器和火狐浏览器的细节**
我们将会展示AnC成功对浏览器堆的ASLR和火狐浏览器的JIT代码的ASLR进行去随机化，同时和现在的绕过ASLR的方法相比速度更快，需求更低。
**第七章我们将讨论AnC对于基于浏览器的漏洞利用和对于依赖于在地址空间中的信息隐藏或泄露对抗ASLR的安全防御的影响**
**第八章我们将讨论缓解攻击的方法**
**最后一章作为结束部分。**
首先我们需要了解AnC攻击的基本原理，实际上就是要了解物理地址和虚拟地址的转换，页表级之间的转换规则，相关的内容，在安全客上有一篇关于这个基础原理的翻译。
http://bobao.360.cn/learning/detail/3520.html
对于这种攻击方式的理解，重要的就是下面两幅图：
我们重点关注第五章 AnC的实施
## 第五章 AnC实施
安装我们的TTT和SMC计时器，我们现在继续执行第三章D节中描述的AnC。
首先在第五章A节中，我们将展示我们如何在访问目标堆以及的目标JIT区域上执行代码时触发MMU遍历。
然后我们将在第五章的B、C、D节中讨论如何识别存储目标虚拟地址的页表项的页偏移。
在第五章的E、F节中，我们将讲解我们用于观察信号并唯一地识别存储它们的缓存行内的页表项的位置的技术。
在第五章G、H节中，我们讨论了通过激活页表缓存和消除噪声来清理MMU信号的技术。
### A.触发MMU页表遍历
为了观察CPU缓存上的MMU活动，我们需要确保1）当我们访问目标时，我们知道缓冲区中页偏移，2）我们能够驱逐TLB以触发MMU 在目标内存位置上遍历。
我们讨论如何从堆内存和JIT代码中实现这些目标。
堆：我们使用ArrayBuffer类型来回退我们试图去随机化的堆内存。
ArrayBuffer总是页对齐的，这使我们能够预测目标ArrayBuffer中任何索引的相对页偏移量。 最近Intel处理器有两个级别的TLB。
第一级包括指令TLB（iTLB）和数据TLB（dTLB），而第二级是更大的统一的TLB缓存。
为了同时使用数据TLB和已定义的TLB，我们访问TLB驱逐缓冲区（应该是被驱逐行所保存的缓冲区）中的每个页面，其大小大于已定义的TLB。
我们后面将展示该TLB驱逐缓冲区也可以用于在期望的偏移处驱逐LLC高速缓存集合。
代码：为了分配足够大的JIT代码区域，我们在一个asm.js模块中喷射2的17次方个JavaScript函数。我们可以通过改变由JIT引擎编译的语句的数量来调整这些函数的大小。这些函数的机器码从一个依赖于浏览器的但是在页面中已知的偏移开始，并且在内存中彼此跟随，并且由于我们可以在目标浏览器上预测它们（机器码）的大小，我们知道每个函数从asm.js对象开始位置的偏移。为了最小化这些函数对缓存的影响但不影响它们的大小，我们在所有函数的入口添加一个if语句，以便我们可以不执行函数的逻辑。为了不遮蔽页表缓存行信号，我们的目标是一旦执行就击中单个高速缓存行，但这样做仍然会让功能之间存在大块偏移。为了在执行我们的一个功能时触发页表遍历，我们需要使用iTLB和已定义的TLB。为了使用iTLB，我们使用一个单独的asm.js对象，并执行一些功能，这些功能跨越了超过iTLB大小的页面。为了使用统一的TLB，我们使用我们用于堆的相同的TLB驱逐缓冲区。
正如我们稍后将讨论的，AnC将会在每一轮中观察到一个页偏移量。
这允许我们以不会干扰测量中的页偏移的方式为统一的TLB驱逐缓冲区选择iTLB驱逐函数和页偏移。
### B.PRIME+PROBE和MMU信号
AnC的主要思想是我们可以观察MMU的页偏移对LLC的影响。 我们可以为此目的实现两种攻击[49]：PRIME + PROBE或EVICT + TIME。
要实施PRIME + PROBE攻击，我们需要遵循以下几个步骤：
###### 1、为所有可用的页颜色构建最佳LLC驱逐集。
最佳驱逐集是被接收的内存位置的精确数目（取决于LLC设置的相关性），确保目标缓存行从托管目标缓存行的LLC缓存集合中被驱逐。
###### 2、通过访问所有驱逐集合来引导LLC。
###### 3、访问我们想要去随机化的目标虚拟地址，使其页表项进入LLC。
###### 4、通过访问所有驱逐集并测试其中哪个执行需要更长时间来探测LLC。
需要较长时间执行的驱逐集可能需要从内存中提取一个（或者多个）项，由于在初始阶段，驱逐集中的条目已经被传入LLC，并且唯一的内存引用（除了TLB驱逐集之外）是目标虚拟地址，因此，
这些“被探测的”驱逐集合中的四个已经托管了用于目标虚拟地址的页表项。 如前所述，这些缓存组唯一地标识每个页表级的页表项偏移的高6位。
然而，这种方法有两个问题。首先，从JavaScript建立最优的LLC驱逐集，PRIME +
PROBE是必需的，而最近已经被证明可能需要花费时间，特别是没有精确的计时器。第二，执行PRIME +
PROBE攻击可能存在误差，因为我们试图测量的目标将在测量中产生噪声。更确切地说，我们需要在访问目标虚拟地址之前清除TLB。我们可以在启动步骤之前或之后这样做，但是在任一情况下，驱逐TLB将导致MMU执行一些我们不想要的页表遍历。假设我们在主要步骤之前执行TLB驱逐。在执行初期步骤期间访问LLC驱逐集的中间，很有可能会发生许多TLB未命中，导致页表遍历可能在我们不知情的情况下填充已经被引导的缓存集，在探测步骤中会产生许多错误信息。现在假设我们在完成步骤之后执行TLB驱逐的步骤。类似的情况可能会发生：TLB驱逐集中的一些页面将导致页表遍历，导致填充已经被引导的缓存集，并且再次在探测中产生错误信息。
我们使用PRIME + PROBE在最开始实现AnC。 它花费了很长时间来建立最佳驱逐集，并且最终由于噪声很高而不能识别MMU信号。
为了解决这些问题，我们利用我们的目标的独特属性，这样可以不建立最佳驱逐集（第五章C节），从而不会产生大量噪声，并且由于能够控制触发器（MMU的页表遍历），我们可以选择一个更奇特的EVICT+TIME
攻击，允许我们避免PRIME + PROBE（第五章D节）的缺点。
### C.缓存颜色对AnC来说不重要
基于缓存的边信道攻击受益于在后端操作之后的缓存状态中可用的整合信息 - 受害者访问的缓存集。 缓存集由颜色（即页颜色）和页（缓存行）偏移量唯一标识。
例如，具有8192个缓存集的LLC中的缓存集可以由（颜色，偏移）元组标识，其中0≤color<128并且0≤offset <64。
ASLR对页偏移中的指针（即，随机化指针）进行编码。
我们可以为页面内的64个缓存行偏移量中的每一个构建一个驱逐集合，驱逐每个集合的该缓存行偏移量的所有颜色。
唯一的问题是不同页表级的页表项可能使用不同的页面颜色，因此，我们就会看到重叠的偏移信号。
但是考虑到我们可以控制观察到的虚拟地址相对于我们的目标虚拟地址的偏移，我们可以控制不同页表级内的页表项的偏移，如第三章D节所述，来解决这个问题。
在下面的描述中，我们的EVICT + TIME攻击不依赖驱逐集的执行时间。 这意味着我们不需要构建最佳驱逐集。
加上ASLR对颜色不可知的事实，我们可以使用任何页面作为驱逐集合的一部分。