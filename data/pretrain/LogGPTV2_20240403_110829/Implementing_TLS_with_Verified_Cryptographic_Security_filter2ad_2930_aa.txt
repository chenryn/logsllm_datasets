title:Implementing TLS with Verified Cryptographic Security
author:Karthikeyan Bhargavan and
C&apos;edric Fournet and
Markulf Kohlweiss and
Alfredo Pironti and
Pierre-Yves Strub
2013 IEEE Symposium on Security and Privacy
Implementing TLS with
Veriﬁed Cryptographic Security
Karthikeyan Bhargavan∗, C´edric Fournet†, Markulf Kohlweiss†, Alfredo Pironti∗, Pierre-Yves Strub‡
∗INRIA Paris-Rocquencourt, {karthikeyan.bhargavan,alfredo.pironti}@inria.fr
†Microsoft Research, {fournet,markulf}@microsoft.com
‡IMDEA Software, PI:EMAIL
Abstract—TLS is possibly the most used protocol for secure
communications, with a 18-year history of ﬂaws and ﬁxes,
ranging from its protocol logic to its cryptographic design, and
from the Internet standard to its diverse implementations.
We develop a veriﬁed reference implementation of TLS 1.2.
Our code fully supports its wire formats, ciphersuites, sessions
and connections, re-handshakes and resumptions, alerts and
errors, and data fragmentation, as prescribed in the RFCs; it
interoperates with mainstream web browsers and servers. At the
same time, our code is carefully structured to enable its modular,
automated veriﬁcation, from its main API down to computational
assumptions on its cryptographic algorithms.
Our implementation is written in F# and speciﬁed in F7. We
present security speciﬁcations for its main components, such as
authenticated stream encryption for the record layer and key
establishment for the handshake. We describe their veriﬁcation
using the F7 typechecker. To this end, we equip each crypto-
graphic primitive and construction of TLS with a new typed
interface that captures its security properties, and we gradually
replace concrete implementations with ideal functionalities. We
ﬁnally typecheck the protocol state machine, and obtain precise
security theorems for TLS, as it is implemented and deployed.
We also revisit classic attacks and report a few new ones.
I. INTRODUCTION
Transport layer security (TLS) is possibly the most used
security protocol; it is widely deployed for securing web trafﬁc
(HTTPS) and also mails, VPNs, and wireless communica-
tions. Reﬂecting its popularity, the security of TLS has been
thoroughly studied, with a well-documented, 18-year history
of attacks, ﬁxes, upgrades, and proposed extensions [e.g.
28, 21–23, 53, 43]. Some attacks target the protocol logic,
for instance causing the client and server to negotiate the
use of weak algorithms even though they both support strong
cryptography [42]. Some exploit cryptographic design ﬂaws,
for instance using knowledge of the next IV to set up adaptive
plaintext attacks [47]. Some, such as padding-oracle attacks,
use a combination of protocol logic and cryptography, taking
advantage of error messages to gain information on encrypted
data [56, 17, 57]. Others rely on various implementation
errors [14, 44, 38] or side channels [16]. Further attacks
arise from the usage or conﬁguration of TLS, rather than the
protocol itself, for instance exploiting poor certiﬁcate manage-
ment or gaps between TLS and the application logic [52, 30].
Overall, the mainstream implementations of TLS still require
several security patches every year.
1081-6011/13 $26.00 © 2013 IEEE
DOI 10.1109/SP.2013.37
445
Meanwhile, TLS security has been formally veriﬁed in
many models, under various simplifying assumptions [51, 20,
32, 49, 48, 29, 36, 33]. While all these works give us better
conﬁdence in the abstract design of TLS, and sometimes reveal
signiﬁcant ﬂaws, they still ignore most of the details of RFCs
and implementations.
To achieve provable security for TLS as it is used, we
develop a veriﬁed reference implementation of the Internet
standard. Our results precisely relate application security at
the TLS interface down to cryptographic assumptions on the
algorithms selected by its ciphersuites. Thus, we address soft-
ware security, protocol security, and cryptographic security in a
common implementation framework. In the process, we revisit
known attacks and discover new ones: an alert fragmentation
attack (§II), and a ﬁngerprinting attack based on compression
(§IV). Our two main goals are as follows:
(1) Standard Compliance Following the details of the RFCs,
we implement and verify the concrete message parsing and
processing of TLS. We also support multiple versions (from
SSL 3.0 to TLS 1.2) and ciphersuites, protocol extensions, ses-
sions and connections (with re-handshakes and resumptions),
alerts and errors, and data fragmentation.
The TLS standard speciﬁes the messages exchanged over
the network, but not its application programming interface
(API). Since this is critical for using TLS securely, we design
our own API, with an emphasis on precision—our API is
similar to those provided by popular implementations, but
gives more control to the application, so that we can express
stronger security properties: §IV explains how we reﬂect frag-
mentation and length-hiding, to offer some protection against
trafﬁc analysis; §VI explain how we report warnings, changes
of ciphersuites, and certiﬁcate requests.
We illustrate our new API by programming and verifying
sample applications. We also implement .NET streams on
top of it, and program minimal web clients and servers,
to conﬁrm that our implementation interoperates with main-
stream implementations, and that it offers reasonable usability
and performance. (In contrast, most veriﬁed models are not
executable, which precludes even basic functionality testing.)
Experimentally, our implementation also provides a convenient
platform for testing corner cases, trying out potential attacks,
and analyzing proposed extensions and security patches. In the
course of this work, we submitted errata to the IETF.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:52:05 UTC from IEEE Xplore.  Restrictions apply. 
(2) Veriﬁed Security Following the provable security ap-
proach of computational cryptography, we show the privacy
and integrity of bytestreams sent over TLS, provided their
connection keys were established using a strong ciphersuite
between principals using secure long-term keys. Unavoidably,
an active adversary may observe and disrupt encrypted net-
work trafﬁc below TLS. In brief, our main results show that
a probabilistic, polynomial adversary cannot achieve more,
except with a negligible probability: even with chosen adaptive
plaintext and ciphertext bytestreams, it learns nothing about
the content of their communication, and cannot cause them to
accept any other content. These results are expressed using in-
distinguishability games, whereby the communication content
is replaced with zeros before sending, and restored by table
lookups after receiving. Thus, we achieve the kind of cryp-
tographic results traditionally obtained for secure channels,
but on an unprecedented scale, for an executable, standard-
compliant, 5,000-line functionality, rather than an abstract
model of TLS—dozens of lines in pseudocode in Jager et al.
[33, ﬁg. 3] and Gajek et al. [29, p. 4].
In the rest of this section, we summarize the challenges
involved in achieving our goals, namely accounting for the
complexity of TLS, and automatically verifying a large im-
plementation with precise cryptographic guarantees.
A. Transport Layer Security
TLS is an assembly of dynamically-conﬁgured protocols,
controlled by an internal state machine that calls into a large
collection of cryptographic algorithms. (§II reviews the TLS
architecture.) This yields great ﬂexibility for connecting clients
and servers, potentially at the cost of security, so TLS appli-
cations should carefully conﬁgure and review their negotiated
connections before proceeding. Accordingly, we prove security
relative to the choice of protocol version, ciphersuite, and
certiﬁcates of the two parties.
Versions, Ciphersuites, and Algorithms Pragmatically, TLS
must maintain backward compatibility while providing some
security. Indeed, 5 years after the release of TLS 1.2, which
ﬁxes several security weaknesses, RC4 remains the most
popular cipher, most browsers still negotiate TLS 1.0, and
many still accept SSL2 connections! It
to
assess the security of TLS as a whole, even if its usage of
cryptography is outdated. As most implementations do, our
codebase supports all protocol versions from SSL 3.0 till
TLS 1.2 [28, 21–23]. We decided not to support SSL2 at all,
since its usage is unsafe and now prohibited [55].
is thus crucial
Many algorithms, such as MD5, DES, or PKCS#1, are
eventually broken or subsumed by others, so TLS features
cryptographic agility, enabling users to choose at runtime be-
tween different methods and algorithms for similar purposes.
Ciphersuites and extensions are its main agility mechanisms;
together with the protocol version, they control the method
and algorithms for the key exchange and the transport layer.
Older ciphersuites can be very weak, but even the latest
ciphersuites may not guarantee security: as a cautionary tale,
Brumley et al. [15] report, exploit and ﬁx a “bug attack”
in the implementation of elliptic-curve multiplication within
OpenSSL, which left many advanced ciphersuites exposed
to attacks for years. Accordingly, our formal development
fully supports cryptographic agility,
in the spirit of Acar
et al. [1], and provides security relative to basic cryptographic
assumptions (say, IND-CPA or PRF) on the algorithms chosen
by the ciphersuite. Thus, we obtain security for connections
with strong ciphersuites running side-by-side with insecure
connections with weak ciphersuites.
Side Channels and Trafﬁc Analysis Our API provides ﬁne-
grained control for fragmentation and padding; this enables
applications to control the amount of information they leak
via network trafﬁc analysis. Our veriﬁcation also explicitly
handles many runtime errors, thus reﬂecting their potential use
to leak secret information. Thus, our veriﬁcation catches the
padding oracle attack of TLS 1.0 [56, 17] as a type-abstraction
error. We also independently caught the truncated-MAC attack
reported by Paterson et al. [50].
On the other hand, our veriﬁcation does not account for
timing. Following the standard, we only try to mitigate known
timing channels by having a uniform ﬂow, for instance ensur-
ing that the same cryptographic operations are performed, both
in normal execution and in error conditions.
B. Compositional, Automated Veriﬁcation
To cope with the complexity of TLS and prove security on
a large amount of code, we rely both on compositionality and
on automation. We extend the cryptographic veriﬁcation by
typing approach of Fournet et al. [27]. The main technical
novelty is to keep track of conditional security using type
indexes (see §III). For instance, the index of a TLS connection
includes the algorithms and certiﬁcates used to establish the
connection, so that we can specify the security of each
connection relative to this context. Cryptographically, indexes
are similar to session identiﬁers in the universal composability
(UC) framework. Another central idea is to rely on type
abstraction to specify conﬁdentiality and integrity, enabling
us to express our main security properties in just a few lines
of typed declarations.
Our presentation focuses on the main API and the interfaces
of two core internal modules. The stateful authenticated en-
cryption module (StAE), explained in §IV, implements record-
layer cryptography. The handshake module (HS) implements
the key exchange mechanisms of TLS. We specify ideal typed
interfaces for StAE and HS that sufﬁce to prove application-
level security for TLS. Our main formal contributions are
to verify that the record layer securely implements the StAE
interface for a range of authenticated encryption mechanisms
(Theorem 3 in §IV);
implements
the HS interface, with security guarantees when using RSA
and DH (Theorem 4 in §V); and the TLS protocol logic,
dealing with application data, alerts, and multiple connections,
securely implements our main API, given any secure imple-
mentations of StAE and HS (Theorem 5 in §VI).
Prior Veriﬁcation Work on TLS Implementations. We limit
our discussion of related work to the veriﬁcation of implemen-
the handshake protocol
446
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:52:05 UTC from IEEE Xplore.  Restrictions apply. 
tations; other works on formal aspects of TLS are discussed
through the paper. To our knowledge, Bhargavan et al. [11]
present the only prior computational security theorems for a
TLS implementation. They conduct extensive veriﬁcation of
the protocol logic by model extraction from F# to ProVerif [12]
and CryptoVerif [13]. On the other hand, their Dolev-Yao
models do not cover binary formats (excluding any bytestream,
fragmentation and padding issue), nor the properties of the
underlying algorithms, and their computational models cover
only the cryptographic core of one ciphersuite. Their results
are less precise than ours (notably as regards secrecy) and
blind to the cryptographic weaknesses of TLS 1.0.
Chaki and Datta [18] verify the SSL 2.0/3.0 handshake
implementation in OpenSSL by model checking. Their anal-
ysis ﬁnds rollback attacks but applies only to ﬁxed conﬁgu-
rations, and they assume a symbolic model of cryptography.
Others [35, 3] verify Java implementations of the handshake
protocol using logical provers, also in the symbolic model.
Contents The paper is organized as follows. §II informally
presents and evaluates our modular reference implementation.
§III explains cryptographic veriﬁcation by typing. §IV handles
stream encryption. §V deals with the handshake. §VI presents
our main API and theorems for TLS. §VII discusses limitations
of our approach and future work.
TLS is large and complicated, and so is any formal security
statement on its implementation. We strive to give a precise
description of our results using sample code and interfaces, but
we necessarily omit many details. We refer to the standard for
a complete protocol description, and to our full development
at http://mitls.rocq.inria.fr/ for the annotated
source code, a companion paper with additional cryptographic
assumptions and proofs, and a discussion of attacks.
II. A MODULAR IMPLEMENTATION OF TLS
A. API Overview
Our application interface (see Fig. 4 in §VI) is inspired by
typical APIs for TLS libraries and provides similar functional-
ities. It is thread safe, and does not allocate any TLS-speciﬁc
thread, essentially leaving scheduling and synchronization in
the hands of the application programmer. Cryptographically,
we can thus treat our whole implementation as a probabilistic
polynomial time (p.p.t.) module, to be composed with a main
p.p.t. program representing the adversary.
Our reference implementation consists of a dynamically
linked library (DLL) with an interface TLSInfo that declares
various types and constants, e.g. for ciphersuites, and a main
interface TLS for controlling the protocol. To use it,
the
application programmer provides a DataStream module that
uses TLSInfo and deﬁnes the particular streams of plaintext
application data he intends to communicate over TLS, and a
main program that calls TLS.
In addition, application code
may use any other libraries and export its own interfaces.
Application code may create any number of TLS connec-
tions, as client or server, by providing some TCP connection
and some local conﬁguration that indicates versions, cipher-
suites and certiﬁcates to use, and sessions to re-use. Our API
returns a stateful connection endpoint (with an abstract type)
that can then be used by the application to issue a series of
commands, such as read and write to communicate data once
the connection is opened, rekey and rehandshake to trigger
a new handshake, and shutdown to close the connection.
Each command returns either a result, for instance the data
fragment