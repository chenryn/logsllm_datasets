#### 队列
**队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。**
对列的添加       insert  			append 
队列的取值      列表[-1]			列表[0]
队列的删除 	  pop()			pop(0)
___
#### 栈
**栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。**
只允许在栈的栈顶来操作。
添加元素用append(push)，称作是进栈，入栈或者压栈
取值列表[-1]，因为它只能从栈顶来取值，相当于取列表的最后一个值，所以用索引-1.
删除元素pop()从后端开始删除。称作是出栈或者退栈。
___
## 1. 两个栈实现一个队列：[^本题考点 队列 栈]
**用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。**
……解析：
定义一个类，首先这个类要具备两个属性，一个是压栈，一个是出栈。
因为要两个栈来实现一个队列：进行插入操作的端称为队尾，进行删除操作的端称为队头。
那么如何用：两个栈实现一个队列？
栈： 先进后出
队列：先进先出
![](两个栈实现一个队列.png)
#### 如图所示：
队列从一头添加数据，从一头删除数据。
所以我们需要让两个栈
一个栈实现添加数据 
​	即：`self.acceptStack=[] `它拥有一个` push `的方法，用来作为队列的一端的添加数据 功能 用append来实现
​		`self.acceptStack.append(node)`
另一个栈实现删除数据：
​	即：`self.outputStack = [] `它拥有pop 的方法，用来作为队列的另一端的删除数据的功能 用pop 来实现
​	但是我们要实现的是队列的先进先出，也就意味着 如果说我们添加数据的栈中添加了一个数据，那么我们另一个删除数据的栈中，也要相应的删除这个数据，所以说这两个栈中的数据的顺序是相反的。
以上的需求我们通过，删除`acceptStack`栈中的数据，在`outputStack`中添加这个数据，那么先在`acceptStack`中删除的数据，就会进入到`outputStack`的栈底，后在`acceptStack`中删除的数据，会后进入`outputStack`，那么它就会先出来。
那么两个栈，这样来合作，就会实现队列的先进先出，如图：1 是先进的（栈1） 那么1 就会先出来（栈2）。
进而实现了 题目的需求。
在pop 的方法中，如果说 `self.outputStack `是空 没有数据，那么 就给它 while 循环我们的 作为添加数据的栈 
`acceptStack`，删除这个栈中的内容，它会弹出，然后把它添加到 `栈2 outputStack`  中，它就会有数据，有数据的话就返回 （如果 调用了 删除 数据的这个方法的话）。如果说 做了循环，我们的`栈2 outputStack` 中还没有数据，就明 `acceptStack `中，没有数据压入，也就说明这个 队列 没有添加数据，也就不会有删除的数据，所以返回一个None。
___
```python
class Solution:
    def init(self):
        #添加数据栈
        self.acceptStack=[]
        #删除数据栈
        self.outputStack = []
    def push(self, node):
        #向添加数据的栈中添加数据
        self.acceptStack.append(node)
    def pop(self):
        #判断删除数据的栈中是否有数据，没有的话，就添加数据，添加数据时，要添加栈1 中删除的数据
        if not self.outputStack:
            while self.acceptStack:
            self.outputStack.append(self.acceptStack.pop())
        #如果有数据的话，就返回
        if self.outputStack:
            return self.outputStack.pop()
        #如果没有数据，说明没有数据添加进去，也就不需要删除数据，所以返回none
        else:
            return None
```
### 二分查找法
##### **分析查找：首先快速的查找方法 有二分查找法，那么什么是二分查找法？**
```
二分查找法什么情况下用。有序的数组中。首先 肯定是在有序的 数组中的！！！！！
```
算法：二分法查找适用于数据量较大时，但是数据需要先排好顺序。主要思想是：（设查找的数组区间为array[low, high]）
（1）确定该区间的中间位置K（2）将查找的值T与array[k]比较。若相等，查找成功返回此位置；否则确定新的查找区域，继续二分查找。区域确定如下：a.array[k]>T 由数组的有序性可知array[k,k+1,……,high]>T;故新的区间为array[low,……，K-1]b.array[k] 10 = 2
        #1100 = 12 => 110 = 6
        #一下用了 向右 移一位， 那么上面是解释，它就相当于 除以2 。
        mid = (left + right) >> 1
        #如果中间的数等于我们要找的数，那么就返回。
        if  array[mid] == target:
            return mid
        #如果说中间的数  目标的数，那么就说明，我们要找的数在左侧，所以左侧取值的索引需要改变为中间的索引-1； 因为越往左索引值越小
        else:
            right = mid-1
    return None
```
把数组内的数据一分为二，然后计算出中间数据的 索引值。
数组中 最左侧的  索引为 0  ；最右侧的索引为 len(array)-1，数组的长度 减 1 就是 最后一个数的索引。
先判断中间索引的所对应的数组中的数值，是否与我们要查找的数字 target 相等，如果相等那么就返回，如果不相等，那么就继续判断。如果说我们找到的 array[mid] 小于  target 这个数; 那么 就说明 我们要查找的数在右侧的一半数据中，那么这个时候我们就需要改变我们左边的索引值，不在从0 开始，而是从我们中间 mid 的下一个开始，left = mid + 1，继续查找。如果说我们找到的 array[mid]  大于 target 这个数 ，那么就说明我们要查找的数据在左侧，这个时候就需要改变右侧的索引，为 right = mid-1，越往左侧走，索引值越小。直到找的的数 与target 相等为止。
以上为二分法的原理。
___
## 2. 旋转数组的最小数字 [^本题考点 查找]
**把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。**
```python
class Solution:
    def minNumberInRotateArray(self, rotateArray):
        #最小值 一定比前面的要小
        # 二分法查找数据  找左右的方法是：
        #右边的值大于中值，就说明最小值在左边
        if not rotateArray:
            return 0
        left = 0
        right = len(rotateArray) - 1
        while left > 1
            #如果说中间的数的上一个数 > 中间数，那么就说明，我们要找的数就是这个中间的数，返回这个数。
            if rotateArray[mid - 1] > rotateArray[mid]:
                return rotateArray[mid]
            #如果说中间的数 = 0:
            #根据两个索引下标可以取到 对应的在数组中的值