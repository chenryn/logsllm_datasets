            if opcode_a2==0x400:
                print('reg_3 > 4) | ((flag[i * 2] & 0xf) > 4) | ((flag[(i * 2) + 
1] & 0xf) << 4);
        flag[(i * 2) + 1] ^= a;
        a = flag[(i * 2) + 1];
    }
}
Finally get the ﬂag
chinese version：https://github.com/125e591/wp/blob/main/n1ctf2020_easyRE
Auth
This is a Windows internal related challenge. Congrats to NESE_Y&G  for being the only team that 
solved the challenge. As it's already stated in the description this challenge is the most 
"contrived" one as you will see below.
Basically auth.exe  creates an ALPC-port  and listens for incoming requests. It provides two 
opcodes : 0x1337  for checking the token and getting the flag , 0  for exiting. Normally you 
won't be able to pass the check because you have no access to the token.txt , but if you looked 
carefully, you can see that the handle of token.txt  is truncated to 16-bits before calling the 
check function. So it's possible to ﬂood the auth.exe  with handles and get our ﬁle handle to be 
passed to the check function. Now, because of the sandboxing, you can't get a handle to the 
auth.exe  to DuplicateHandle  into the process. But since we're communicating on an ALPC  
channel, we can send messages with handle attributes to inject them into the server, and now we 
get all the pieces we need to get the ﬂag.
In order to get familiar with ALPC  I suggest you read the slides. The source code and solution can 
be found at here.
BabyCompiler
I am studying compiler recently, and I had learned some basic knowlege about Lex and Yacc, so  
this problem is based on lex and yacc.
The BabyComiler is a simple program generated by lex and yacc, it recvs some tokens and then 
process them.
To reverse this program, you can compile some lex and yacc examples to ﬁnd the common things 
like symbols and the code templates.
In lex, each token could hava a process function. when the lex recved target token, the function 
will be called. And all process functions will be arrange to a switch.
Each token will genernate a yy_act, yy_act is from yy_accept.....To understand the detailed work, 
you need to learn some basic compiler  principles, such as NFA.
The template code as blows
n1ctf{ThE_X64_StRuCtUrEd_eXcEpTiOn_hAnDlInG_Is_sO_InTeReStInG.}
do_action:  /* This label is used only to access EOF actions. */
        switch ( yy_act )
    { /* beginning of action switch */
            case 0: /* must back up */
            /* undo the effects of YY_DO_BEFORE_ACTION */
            *yy_cp = (yy_hold_char);
            yy_cp = (yy_last_accepting_cpos);
            yy_current_state = (yy_last_accepting_state);
            goto yy_find_action;
case 1:
So we can work out from the lex's code that the lex recv these tokens:
n1ctf, {,},YACC,LEX,CTF,FUN,+,-,*,^ and Numbers.
you can use angr, set the target address at each case's entry to work out their corresponding 
tokens.
The yacc has the same structure too, each rule has a process function and all process function's 
code will be put into a switch.
The template as blow:
you can easily ﬁnd the switch struct in the ida
if you are using ida7.0 you may can't get switch properly recognized.
You can set a breakpoint on each case entry, and then use n1ctf{xxx} as input to test xxx's 
process function.(xxx is a token)
a b c d e is global varibles.
rule: TopExp    addr: 36A1
YY_RULE_SETUP
#line 7 "1.l"
return EQ;
    YY_BREAK
case 2:
YY_RULE_SETUP
#line 8 "1.l"
return POW;
    YY_BREAK
case 3:
................
    Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];
  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 2:
        。。。。。。。。。
.text:000000000000310D                 lea     rdi, dword_4960
.text:0000000000003114                 movsxd  rdx, dword ptr [rdi+rdx*4]
.text:0000000000003118                 add     rdx, rdi
.text:000000000000311B                 db      3Eh
.text:000000000000311B                 jmp     rdx
require:
a == 0x3F9D72D4
rule:YACC  addr:36D7
require:
b == 0
c == 0
d == 0
e == 0
set: b = 0xAABB
rule:LEX addr:3724
.text:000000000000369E                 jmp     rax
.text:00000000000036A1                 mov     eax, cs:a
.text:00000000000036A7                 cmp     eax, 
.text:00000000000036AC                 jnz     short wrong
.text:00000000000036AE                 lea     rdi, aYesYouAreRight ; "yes you 
are right."
.text:00000000000036B5                 mov     eax, 0
.text:00000000000036BA                 call    sub_1200
.text:00000000000036BF                 jmp     short loc_36CD
.text:00000000000036D7                 mov     eax, cs:b
.text:00000000000036DD                 test    eax, eax
.text:00000000000036DF                 jnz     short wrong1
.text:00000000000036E1                 mov     eax, cs:c
.text:00000000000036E7                 test    eax, eax
.text:00000000000036E9                 jnz     short wrong1
.text:00000000000036EB                 mov     eax, cs:d
.text:00000000000036F1                 test    eax, eax
.text:00000000000036F3                 jnz     short wrong1
.text:00000000000036F5                 mov     eax, cs:e
.text:00000000000036FB                 test    eax, eax
.text:00000000000036FD                 jz      short loc_3715
.text:00000000000036FF
.text:00000000000036FF wrong1:                                 ; CODE XREF: 
sub_31CF+510↑j
.text:00000000000036FF                                         ; sub_31CF+51A↑j 
...
.text:00000000000036FF                 lea     rdi, aYouAreWrong ; "you are 
wrong!"
.text:0000000000003706                 call    sub_11A0
.text:000000000000370B                 mov     edi, 0
.text:0000000000003710                 call    exit_0
.text:0000000000003715 ; -------------------------------------------------------
--------------------
.text:0000000000003715
.text:0000000000003715 loc_3715:                               ; CODE XREF: 
sub_31CF+52E↑j
.text:0000000000003715                 mov     cs:b, 0AABBh
.text:000000000000371F                 jmp     loc_391D
require:
b == 0xAABB
c == 0
d == 0
e == 0
set:d = 0xCCDD
rule:CTF addr:3774
.text:0000000000003724                 mov     eax, cs:b
.text:000000000000372A                 cmp     eax, 0AABBh
.text:000000000000372F                 jnz     short loc_374F
.text:0000000000003731                 mov     eax, cs:c
.text:0000000000003737                 test    eax, eax
.text:0000000000003739                 jnz     short loc_374F
.text:000000000000373B                 mov     eax, cs:d
.text:0000000000003741                 test    eax, eax
.text:0000000000003743                 jnz     short loc_374F
.text:0000000000003745                 mov     eax, cs:e
.text:000000000000374B                 test    eax, eax
.text:000000000000374D                 jz      short loc_3765
.text:000000000000374F
.text:000000000000374F loc_374F:                               ; CODE XREF: 
sub_31CF+560↑j
.text:000000000000374F                                         ; sub_31CF+56A↑j 
...
.text:000000000000374F                 lea     rdi, aYouAreWrong ; "you are 
wrong!"
.text:0000000000003756                 call    sub_11A0
.text:000000000000375B                 mov     edi, 0
.text:0000000000003760                 call    exit_0
.text:0000000000003765 ; -------------------------------------------------------
--------------------
.text:0000000000003765
.text:0000000000003765 loc_3765:                               ; CODE XREF: 
sub_31CF+57E↑j
.text:0000000000003765                 mov     cs:d, 0CCDDh
.text:000000000000376F                 jmp     switch1
.text:0000000000003774                 mov     eax, cs:b
.text:000000000000377A                 cmp     eax, 0AABBh
.text:000000000000377F                 jnz     short loc_37A2
.text:0000000000003781                 mov     eax, cs:c
.text:0000000000003787                 test    eax, eax
.text:0000000000003789                 jnz     short loc_37A2
.text:000000000000378B                 mov     eax, cs:d
.text:0000000000003791                 cmp     eax, 0CCDDh
.text:0000000000003796                 jnz     short loc_37A2
.text:0000000000003798                 mov     eax, cs:e
.text:000000000000379E                 test    eax, eax
.text:00000000000037A0                 jz      short loc_37B8
.text:00000000000037A2
.text:00000000000037A2 loc_37A2:                               ; CODE XREF: 
sub_31CF+5B0↑j
require:
b == 0xAABB
c == 0
d == 0xCCDD
e == 0
set: c = 0x123
rule: FUN addr:37C7
.text:00000000000037A2                                         ; sub_31CF+5BA↑j 
...
.text:00000000000037A2                 lea     rdi, aYouAreWrong ; "you are 