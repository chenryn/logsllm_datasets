# 08 \| 作用域和生存期：实现块作用域和函数目前，我们已经用 Antlr重构了脚本解释器，有了工具的帮助，我们可以实现更高级的功能，比如函数功能、面向对象功能。当然了，在这个过程中，我们还要克服一些挑战，比如：-   如果要实现函数功能，要升级变量管理机制；-   引入作用域机制，来保证变量的引用指向正确的变量定义；-   提升变量存储机制，不能只把变量和它的值简单地扔到一个 HashMap    里，要管理它的生存期，减少对内存的占用。本节课，我将借实现块作用域和函数功能，带你探讨作用域和生存期及其实现机制，并升级变量管理机制。那么什么是作用域和生存期，它们的重要性又体现在哪儿呢？**"作用域"和"生存期"**是计算机语言中更加基础的概念，它们可以帮你深入地理解函数、块、闭包、面向对象、静态成员、本地变量和全局变量等概念。而且一旦你深入理解，了解作用域与生存期在编译期和运行期的机制之后，就能解决在学习过程中可能遇到的一些问题，比如：-   闭包的机理到底是什么？-   为什么需要栈和堆两种机制来管理内存？它们的区别又是什么？-   一个静态的内部类和普通的内部类有什么区别？了解上面这些内容之后，接下来，我们来具体看看什么是作用域。
## 作用域（Scope）作用域是指计算机语言中变量、函数、类等起作用的范围，我们来看一个具体的例子。``{=html}下面这段代码是用 C 语言写的，我们在全局以及函数 fun 中分别声明了 a 和 b两个变量，然后在代码里对这些变量做了赋值操作：    /*scope.c测试作用域。 */#include  int a = 1; void fun(){    a = 2;    //b = 3;   // 出错，不知道 b 是谁    int a = 3; // 允许声明一个同名的变量吗？    int b = a; // 这里的 a 是哪个？    printf("in fun: a=%d b=%d \n", a, b);} int b = 4; //b 的作用域从这里开始 int main(int argc, char **argv){    printf("main--1: a=%d b=%d \n", a, b);     fun();    printf("main--2: a=%d b=%d \n", a, b);     // 用本地变量覆盖全局变量    int a = 5;    int b = 5;    printf("main--3: a=%d b=%d \n", a, b);     // 测试块作用域    if (a > 0){        int b = 3; // 允许在块里覆盖外面的变量        printf("main--4: a=%d b=%d \n", a, b);    }    else{        int b = 4; // 跟 if 块里的 b 是两个不同的变量        printf("main--5: a=%d b=%d \n", a, b);    }     printf("main--6: a=%d b=%d \n", a, b);}这段代码编译后运行，结果是：    main--1: a=1 b=4 in fun: a=3 b=3 main--2: a=2 b=4 main--3: a=5 b=5 main--4: a=5 b=3 main--6: a=5 b=5 我们可以得出这样的规律：-   变量的作用域有大有小，外部变量在函数内可以访问，而函数中的本地变量，只有本地才可以访问。-   变量的作用域，从声明以后开始。-   在函数里，我们可以声明跟外部变量相同名称的变量，这个时候就覆盖了外部变量。下面这张图直观地显示了示例代码中各个变量的作用域：![](Images/861a47a38fa97b61b4f0a23d0ad229e8.png){savepage-src="https://static001.geekbang.org/resource/image/2e/fc/2ea46e1b2d1a6c863f6830a7af5fd3fc.jpg"}另外，C 语言里还有块作用域的概念，就是用花括号包围的语句，if 和 else后面就跟着这样的语句块。块作用域的特征跟函数作用域的特征相似，都可以访问外部变量，也可以用本地变量覆盖掉外部变量。你可能会问："其他语言也有块作用域吗？特征是一样的吗？"其实，各个语言在这方面的设计机制是不同的。比如，下面这段用Java 写的代码里，我们用了一个 if 语句块，并且在 if 部分、else部分和外部分别声明了一个变量 c：    /** * Scope.java * 测试 Java 的作用域 */public class ScopeTest{     public static void main(String args[]){        int a = 1;        int b = 2;         if (a > 0){            //int b = 3; // 不允许声明与外部变量同名的变量            int c = 3;        }        else{            int c = 4;   // 允许声明另一个 c，各有各的作用域        }                int c = 5;  // 这里也可以声明一个新的 c    }}你能看到，Java 的块作用域跟 C语言的块作用域是不同的，它不允许块作用域里的变量覆盖外部变量。那么和C、Java 写起来很像的 JavaScript 呢？来看一看下面这段测试 JavaScript作用域的代码：    /** * Scope.js * 测试 JavaScript 的作用域 */var a = 5;var b = 5;console.log("1: a=%d b=%d", a, b); if (a > 0) {    a = 4;    console.log("2: a=%d b=%d", a, b);    var b = 3; // 看似声明了一个新变量，其实还是引用的外部变量    console.log("3: a=%d b=%d", a, b);}else {    var b = 4;    console.log("4: a=%d b=%d", a, b);} console.log("5: a=%d b=%d", a, b); for (var b = 0; b#include  int * fun(){    int * b = (int*)malloc(1*sizeof(int)); // 在堆中申请内存    *b = 2;  // 给该地址赋值 2       return b;} int main(int argc, char **argv){    int * p = fun();    *p = 3;     printf("after called fun: b=%lu *b=%d \n", (unsigned long)p, *p);     free(p);}类似的情况在 Java 里也有。Java的对象实例缺省情况下是在堆中生成的。下面的示例代码中，从一个方法中返回了对象的引用，我们可以基于这个引用继续修改对象的内容，这证明这个对象的内存并没有被释放：    /** * Extent2.java * 测试 Java 的生存期特性 */public class Extent2{     StringBuffer myMethod(){        StringBuffer b = new StringBuffer(); // 在堆中生成对象实例        b.append("Hello ");        System.out.println(System.identityHashCode(b)); // 打印内存地址        return b;  // 返回对象引用，本质是一个内存地址    }     public static void main(String args[]){        Extent2 extent2 = new Extent2();        StringBuffer c = extent2.myMethod(); // 获得对象引用        System.out.println(c);        c.append("World!");         // 修改内存中的内容        System.out.println(c);         // 跟在 myMethod() 中打印的值相同        System.out.println(System.identityHashCode(c));    }}因为 Java对象所采用的内存超出了申请内存时所在的作用域，所以也就没有办法自动收回。所以Java 采用的是自动内存管理机制，也就是垃圾回收技术。那么为什么说作用域和生存期是计算机语言更加基础的概念呢？其实是因为它们对应到了运行时的内存管理的基本机制。虽然各门语言设计上的特性是不同的，但在运行期的机制都很相似，比如都会用到栈和堆来做内存管理。好了，理解了作用域和生存期的原理之后，我们就来实现一下，先来设计一下作用域机制，然后再模拟实现一个栈。
## 实现作用域和栈在之前的 PlayScript脚本的实现中，处理变量赋值的时候，我们简单地把变量存在一个哈希表里，用变量名去引用，就像下面这样：    public class SimpleScript {    private HashMap variables = new HashMap();    ...}但如果变量存在多个作用域，这样做就不行了。这时，我们就要设计一个数据结构，区分不同变量的作用域。分析前面的代码，你可以看到作用域是一个树状的结构，比如Scope.c 的作用域：![](Images/91bd462278663096c4e341638dec71d6.png){savepage-src="https://static001.geekbang.org/resource/image/2d/c8/2d3fc83aba7fe2fd7b29227e97184fc8.jpg"}面向对象的语言不太相同，它不是一棵树，是一片树林，每个类对应一棵树，所以它也没有全局变量。在我们的playscript 语言中，我们设计了下面的对象结构来表示 Scope：    // 编译过程中产生的变量、函数、类、块，都被称作符号public abstract class Symbol {    // 符号的名称    protected String name = null;     // 所属作用域    protected Scope enclosingScope = null;     // 可见性，比如 public 还是 private    protected int visibility = 0;     //Symbol 关联的 AST 节点    protected ParserRuleContext ctx = null;} // 作用域public abstract class Scope extends Symbol{    // 该 Scope 中的成员，包括变量、方法、类等。    protected List symbols = new LinkedList();} // 块作用域public class BlockScope extends Scope{    ...} // 函数作用域public class Function extends Scope implements FunctionType{    ...  } // 类作用域public class Class extends Scope implements Type{    ...}目前我们划分了三种作用域，分别是块作用域（Block）、函数作用域（Function）和类作用域（Class）。我们在解释执行 playscript 的 AST的时候，需要建立起作用域的树结构，对作用域的分析过程是语义分析的一部分。也就是说，并不是有了AST，我们马上就可以运行它，在运行之前，我们还要做语义分析，比如对作用域做分析，让每个变量都能做正确的引用，这样才能正确地执行这个程序。解决了作用域的问题以后，再来看看如何解决生存期的问题。还是看 Scope.c的代码，随着代码的执行，各个变量的生存期表现如下：-   进入程序，全局变量逐一生效；-   进入 main 函数，main 函数里的变量顺序生效；-   进入 fun 函数，fun 函数里的变量顺序生效；-   退出 fun 函数，fun 函数里的变量失效；-   进入 if 语句块，if 语句块里的变量顺序生效；-   退出 if 语句块，if 语句块里的变量失效；-   退出 main 函数，main 函数里的变量失效；-   退出程序，全局变量失效。通过下面这张图，你能直观地看到运行过程中栈的变化：![](Images/7f1fc8c970c0726bd254e909182439cf.png){savepage-src="https://static001.geekbang.org/resource/image/51/06/51f278ccd4fc7f28c6840e1d6b20bd06.jpg"}代码执行时进入和退出一个个作用域的过程，可以用栈来实现。每进入一个作用域，就往栈里压入一个数据结构，这个数据结构叫做**栈桢（StackFrame）**。栈桢能够保存当前作用域的所有本地变量的值，当退出这个作用域的时候，这个栈桢就被弹出，里面的变量也就失效了。你可以看到，栈的机制能够有效地使用内存，变量超出作用域的时候，就没有用了，就可以从内存中丢弃。我在ASTEvaluator.java 中，用下面的数据结构来表示栈和栈桢，其中的 PlayObject通过一个 HashMap 来保存各个变量的值：    private Stack stack = new Stack(); public class StackFrame {    // 该 frame 所对应的 scope    Scope scope = null;     //enclosingScope 所对应的 frame    StackFrame parentFrame = null;     // 实际存放变量的地方    PlayObject object = null;} public class PlayObject {    // 成员变量    protected Map fields = new HashMap();}目前，我们只是在概念上模仿栈桢，当我们用 Java 语言实现的时候，PlayObject对象是存放在堆里的，Java的所有对象都是存放在堆里的，只有基础数据类型，比如 int和对象引用是放在栈里的。虽然只是模仿，这不妨碍我们建立栈桢的概念，在后端技术部分，我们会实现真正意义上的栈桢。要注意的是，栈的结构和 Scope的树状结构是不一致的。也就是说，栈里的上一级栈桢，不一定是 Scope的父节点。要访问上一级 Scope 中的变量数据，要顺着栈桢的 parentFrame去找。我在上图中展现了这种情况，在调用 fun函数的时候，栈里一共有三个栈桢：全局栈桢、main() 函数栈桢和 fun()函数栈桢，其中 main() 函数栈桢的 parentFrame 和 fun() 函数栈桢的parentFrame 都是全局栈桢。
## 实现块作用域目前，我们已经做好了作用域和栈，在这之后，就能实现很多功能了，比如让 if语句和 for 循环语句使用块作用域和本地变量。以 for 语句为例，visit方法里首先为它生成一个栈桢，并加入到栈中，运行完毕之后，再从栈里弹出：    BlockScope scope = (BlockScope) cr.node2Scope.get(ctx);  // 获得 ScopeStackFrame frame = new StackFrame(scope);  // 创建一个栈桢pushStack(frame);    // 加入栈中 ... // 运行完毕，弹出栈stack.pop();当我们在代码中需要获取某个变量的值的时候，首先在当前桢中寻找。找不到的话，就到上一级作用域对应的桢中去找：    StackFrame f = stack.peek();       // 获取栈顶的桢PlayObject valueContainer = null;while (f != null) {    // 看变量是否属于当前栈桢里    if (f.scope.containsSymbol(variable)){         valueContainer = f.object;        break;    }    // 从上一级 scope 对应的栈桢里去找      f = f.parentFrame;}运行下面的测试代码，你会看到在执行完 for循环以后，我们仍然可以声明另一个变量 i，跟 for 循环中的 i互不影响，这证明它们确实属于不同的作用域：    String script = "int age = 44; for(int i = 0;i parameters = new LinkedList();     // 返回值    protected Type returnType = null;        ...}在调用函数时，我们实际上做了三步工作：-   建立一个栈桢；-   计算所有参数的值，并放入栈桢；-   执行函数声明中的函数体。我把相关代码放在了下面，你可以看一下：    // 函数声明的 AST 节点FunctionDeclarationContext functionCode = (FunctionDeclarationContext) function.ctx; // 创建栈桢functionObject = new FunctionObject(function);StackFrame functionFrame = new StackFrame(functionObject); // 计算实参的值List paramValues = new LinkedList();if (ctx.expressionList() != null) {    for (ExpressionContext exp : ctx.expressionList().expression()) {        Object value = visitExpression(exp);        if (value instanceof LValue) {            value = ((LValue) value).getValue();        }        paramValues.add(value);    }} // 根据形参的名称，在栈桢中添加变量if (functionCode.formalParameters().formalParameterList() != null) {    for (int i = 0; i `{=html}-   **从类型角度**类型处理是语义分析时的重要工作。现代计算机语言可以用自定义的类来声明变量，这是一个巨大的进步。因为早期的计算机语言只支持一些基础的数据类型，比如各种长短不一的整型和浮点型，像字符串这种我们编程时离不开的类型，往往是在基础数据类型上封装和抽象出来的。所以，我们要扩展语言的类型机制，让程序员可以创建自己的类型。-   **从作用域角度**首先是类的可见性。作为一种类型，它通常在整个程序的范围内都是可见的，可以用它声明变量。当然，一些像Java的语言，也能限制某些类型的使用范围，比如只能在某个命名空间内，或者在某个类内部。对象的成员的作用域是怎样的呢？我们知道，对象的属性（"属性"这里指的是类的成员变量）可以在整个对象内部访问，无论在哪个位置声明。也就是说，对象属性的作用域是整个对象的内部，方法也是一样。这跟函数和块中的本地变量不一样，它们对声明顺序有要求，像C 和 Java 这样的语言，在使用变量之前必须声明它。-   **从生存期的角度**对象的成员变量的生存期，一般跟对象的生存期是一样的。在创建对象的时候，就对所有成员变量做初始化，在销毁对象的时候，所有成员变量也随着一起销毁。当然，如果某个成员引用了从堆中申请的内存，这些内存需要手动释放，或者由垃圾收集机制释放。但还有一些成员，不是与对象绑定的，而是与类型绑定的，比如 Java中的静态成员。静态成员跟普通成员的区别，就是作用域和生存期不同，它的作用域是类型的所有对象实例，被所有实例共享。生存期是在任何一个对象实例创建之前就存在，在最后一个对象销毁之前不会消失。你看，我们用这三个语义概念，就把面向对象的封装特性解释清楚了，无论语言在顶层怎么设计，在底层都是这么实现的。了解了面向对象在语义上的原理之后，我们来实际动手解析一下代码中的类，这样能更深刻地体会这些原理。
## 设计类的语法，并解析它我们要在语言中支持类的定义，在 PlayScript.g4中，可以这样定义类的语法规则：    classDeclaration    : CLASS IDENTIFIER      (EXTENDS typeType)?      (IMPLEMENTS typeList)?      classBody    ; classBody    : '{' classBodyDeclaration* '}'    ; classBodyDeclaration    : ';'    | memberDeclaration    ; memberDeclaration    : functionDeclaration    | fieldDeclaration    ; functionDeclaration    : typeTypeOrVoid IDENTIFIER formalParameters ('[' ']')*      (THROWS qualifiedNameList)?      functionBody    ;我来简单地讲一下这个语法规则：-   类声明以 class    关键字开头，有一个标识符是类型名称，后面跟着类的主体。-   类的主体里要声明类的成员。在简化的情况下，可以只关注类的属性和方法两种成员。我们故意把类的方法也叫做    function，而不是 method，是想把对象方法和函数做一些统一的设计。-   函数声明现在的角色是类的方法。-   类的成员变量的声明和普通变量声明在语法上没什么区别。你能看到，我们构造像 class这样高级别的结构时，越来越得心应手了，之前形成的一些基础的语法模块都可以复用，比如变量声明、代码块（block）等。用上面的语法写出来的 playscript脚本的效果如下，在示例代码里也有，你可以运行它：    /*ClassTest.play 简单的面向对象特性。*/class Mammal{  // 类属性  string name = "";   // 构造方法  Mammal(string str){    name = str;  }   // 方法  void speak(){    println("mammal " + name +" speaking...");  }} Mammal mammal = Mammal("dog"); //playscript 特别的构造方法，不需要 new 关键字mammal.speak();                          // 访问对象方法println("mammal.name = " + mammal.name); // 访问对象的属性 // 没有构造方法，创建的时候用缺省构造方法class Bird{  int speed = 50;    // 在缺省构造方法里初始化   void fly(){    println("bird flying...");  }} Bird bird = Bird();              // 采用缺省构造方法println("bird.speed : " + bird.speed + "km/h");bird.fly();接下来，我们让 playscript解释器处理这些看上去非常现代化的代码，怎么处理呢？做完词法分析和语法分析之后，playscript 会在语义分析阶段扫描AST，识别出所有自定义的类型，以便在其他地方引用这些类型来声明变量。因为类型的声明可以在代码中的任何位置，所以最好用单独的一次遍历来识别和记录类型（类型扫描的代码在TypeAndScopeScanner.java 里）。接着，我们在声明变量时，就可以引用这个类型了。语义分析的另一个工作，就是做变量类型的消解。当我们声明"Birdbird = Bird(); "时，需要知道 Bird对象的定义在哪里，以便正确地访问它的成员（变量类型的消解在TypeResolver.java 里）。在做语义分析时，要把类型的定义保存在一个数据结构中，我们来实现一下：    public class Class extends Scope implements Type{    ...} public abstract class Scope extends Symbol{    // 该 Scope 中的成员，包括变量、方法、类等。    protected List symbols = new LinkedList(} public interface Type {    public String getName();    // 类型名称     public Scope getEnclosingScope();}在这个设计中，我们看到 Class 就是一个 Scope，Scope里面原来就能保存各种成员，现在可以直接复用，用来保存类的属性和方法，画成类图如下：![](Images/3216a7f09a0e8e071e26e007b8ee579f.png){savepage-src="https://static001.geekbang.org/resource/image/8d/63/8d41eae6ab678ad6128d76854fe27463.jpg"}图里有几个类，比如 Symbol、Variable、Scope、Function 和BlockScope，它们是我们的符号体系的主要成员。在做词法分析时，我们会解析出很多标识符，这些标识符出现在不同的语法规则里，包括变量声明、表达式，以及作为类名、方法名等出现。在语义分析阶段，我们要把这些标识符一一识别出来，这个是一个变量，指的是一个本地变量；那个是一个方法名等。变量、类和函数的名称，我们都叫做符号，比如示例程序中的Mammal、Bird、mammal、bird、name、speed等。编译过程中的一项重要工作就是建立符号表，它帮助我们进一步地编译或执行程序，而符号表就用上面几个类来保存信息。在符号表里，我们保存它的名称、类型、作用域等信息。对于类和函数，我们也有相应的地方来保存类变量、方法、参数、返回值等信息。你可以看一看示例代码里面是如何解析和记录这些符号的。解析完这些语义信息以后，我们来看运行期如何执行具有面向对象特征的程序，比如如何实例化一个对象？如何在内存里管理对象的数据？以及如何访问对象的属性和方法？
## 对象是怎么实例化的首先通过构造方法来创建对象。在语法中，我们没有用 new 这个关键字来表示对象的创建，而是省略掉了new，直接调用一个跟类名称相同的函数，这是我们独特的设计，示例代码如下：    Mammal mammal = Mammal("dog"); //playscript 特别的构造方法，不需要 new 关键字Bird bird = Bird();            // 采用缺省构造方法但在语义检查的时候，在当前作用域中是肯定找不到这样一个函数的，因为类的初始化方法是在类的内部定义的，我们只要检查一下，Mammal和 Bird 是不是一个类名就可以了。再进一步，Mammal 类中确实有个构造方法 Mammal()，而 Bird类中其实没有一个显式定义的构造方法，但这并不意味着变量成员不会被初始化。我们借鉴了Java的初始化机制，就是提供缺省初始化方法，在缺省初始化方法里，会执行对象成员声明时所做的初始化工作。所以，上面的代码里，我们调用Bird()，实际上就是调用了这个缺省的初始化方法。无论有没有显式声明的构造方法，声明对象的成员变量时的初始化部分，一定会执行。对于Bird 类，实际上就会执行"int speed = 50;"这个语句。在 RefResolver.java中做语义分析的时候，下面的代码能够检测出某个函数调用其实是类的构造方法，或者是缺省构造方法：    // 看看是不是类的构建函数，用相同的名称查找一个 classClass theClass = at.lookupClass(scope, idName);if (theClass != null) {    function = theClass.findConstructor(paramTypes);    if (function != null) {        at.symbolOfNode.put(ctx, function);    }    // 如果是与类名相同的方法，并且没有参数，那么就是缺省构造方法    else if (ctx.expressionList() == null){        at.symbolOfNode.put(ctx, theClass); // TODO 直接赋予 class    }    else{        at.log("unknown class constructor: " + ctx.getText(), ctx);    }     at.typeOfNode.put(ctx, theClass); // 这次函数调用是返回一个对象}当然，类的构造方法跟普通函数还是有所不同的，例如我们不允许构造方法定义返回值，因为它的返回值一定是这个类的一个实例对象。对象做了缺省初始化以后，再去调用显式定义的构造方法，这样才能完善整个对象实例化的过程。不过问题来了，我们可以把普通的本地变量的数据保存在栈里，那么如何保存对象的数据呢？
## 如何在内存里管理对象的数据其实，我们也可以把对象的数据像其他数据一样，保存在栈里。![](Images/e3ef9557e21a8cc6b4d239c582409d53.png){savepage-src="https://static001.geekbang.org/resource/image/57/1b/572da99aeee859f8b7cbcf6ebfe9ea1b.jpg"}C 语言的结构体 struct 和 C++语言的对象，都可以保存在栈里。保存在栈里的对象是直接声明并实例化的，而不是用new 关键字来创建的。如果用 new关键字来创建，实际上是在堆里申请了一块内存，并赋值给一个指针变量，如下图所示：![](Images/6f17c51576a3dc1ead89ff1d64bf17d2.png){savepage-src="https://static001.geekbang.org/resource/image/15/72/15313f8205fa80912e72718685755072.jpg"}当对象保存在堆里的时候，可以有多个变量都引用同一个对象，比如图中的变量 a和变量 b 就可以引用同一个对象object1。类的成员变量也可以引用别的对象，比如 object1 中的类成员引用了object2 对象。对象的生存期可以超越创建它的栈桢的生存期。我们可以对比一下这两种方式的优缺点。如果对象保存在栈里，那么它的生存期与作用域是一样的，可以自动的创建和销毁，因此不需要额外的内存管理。缺点是对象没办法长期存在并共享。而在堆里创建的对象虽然可以被共享使用，却增加了内存管理的负担。所以在 C 语言和 C++语言中，要小心管理从堆中申请的内存，在合适的时候释放掉这些内存。在 Java语言和其他一些语言中，采用的是垃圾收集机制，也就是说当一个对象不再被引用时，就把内存收集回来。分析到这儿的时候，我们其实可以帮 Java语言优化一下内存管理。比如我们在分析代码时，如果发现某个对象的创建和使用都局限在某个块作用域中，并没有跟其他作用域共享，那么这个对象的生存期与当前栈桢是一致的，可以在栈里申请内存，而不是在堆里。这样可以免除后期的垃圾收集工作。分析完对象的内存管理方式之后，回到 playscript 的实现。在 playscrip 的Java 版本里，我们用一个 ClassObject 对象来保存对象数据，而 ClassObject是 PlayObject 的子类。上一讲，我们已经讲过PlayObject，它被栈桢用来保存本地变量，可以通过传入 Variable来访问对象的属性值：    // 类的实例public class ClassObject extends PlayObject{     // 类型    protected Class type = null;    ... } // 保存对象数据public class PlayObject {    // 成员变量    protected Map fields = new HashMap();     public Object getValue(Variable variable){        Object rtn = fields.get(variable);        return rtn;    }     public void setValue(Variable variable, Object value){        fields.put(variable, value);    }}在运行期，当需要访问一个对象时，我们也会用 ClassObject来做一个栈桢，这样就可以像访问本地变量一样访问对象的属性了。而不需要访问这个对象的时候，就把它从栈中移除，如果没有其他对象引用这个对象，那么它会被Java 的垃圾收集机制回收。