more complex applications. Consequently, depending on the func-
tionality of the shellcode or ROP payload and the needs of the
targeted application, code stripping may not be able to block some
exploits. Indeed, as we later show in our experimental evaluation
(second column of Table 2) the number of remaining critical system
functions after code stripping for the same set of applications is
quite high. For the purposes of this work, we consider as critical a
set of 51 functions from kernel32.dll, ws2_32.dll, wininet.dll,
msvcrt.dll, urlmon.dll, and ntdll.dll, which we found in use
by a collection of 251 shellcode and 30 ROP payload samples (about
which more details are provided in Section 5). Our set is very simi-
lar to the set of critical API functions protected by other runtime
exploit prevention systems like ROPGuard [29] and kBouncer [55].
Based on the above, we are motivated to explore whether further
attack surface reduction is possible by neutralizing parts of the logic
of the critical functions that cannot be removed by code stripping.
As we show in the rest of this paper, the needs of malicious code
and user applications when it comes to those remaining critical
functions are quite divergent, allowing us to enforce strict policies
that break the functionality of exploit code without a(cid:29)ecting the
normal operation of the protected application.
Threat Model
Our aim is to protect user applications that may contain exploitable
memory corruption vulnerabilities. We assume that the attacker is
able to hijack the control (cid:30)ow of the process and execute malicious
ROP code (and possibly second-stage shellcode), which interacts
with the OS to achieve the attacker’s end goal (e.g., remote control,
DLL injection, malware installation). In that sense, data-only attacks
(e.g., modifying a user authentication variable in memory [17]),
which do not result in the invocation of system calls, are out of the
scope of this work.
We also assume that common exploit mitigations, such as non-
executable memory and ASLR, have been deployed on the system.
Although Shredder o(cid:29)ers the same defense capabilities irrespec-
tive of these defenses, as a defense-in-depth approach, it is mostly
meant to be used in combination with other defenses to collectively
raise the bar for successful exploitation, and prevent circumven-
tion. As a defense based on API hooking, Shredder’s policy checks
must be protected so that an attacker cannot simply bypass them
(e.g., by jumping over the check, or even invoking system calls
directly). This can be achieved through various means, such as API
checkpointing [55] or CFI [2]—we discuss in detail such possible
safeguards in Section 4.2.
3 API SPECIALIZATION
The main idea behind API specialization is to create application-
speci(cid:27)c versions of the critical system API functions that a given
application needs to use (and which cannot be simply removed by
code stripping [50]). Especially in Windows, many critical system
API functions have rich and complex interfaces that allow for in-
creased versatility in carrying out a broad set of operations. By
restricting this interface to the absolutely necessary functionality,
and neutralizing any provided capabilities that are not needed, API
specialization can be an e(cid:29)ective last-resort defense for blocking
crucial system interactions that exploit code needs to perform.
The specialization of a given API function requires a thorough
analysis of how that function is used by the application, i.e., what
are its expected argument values across all possible invocations.
This information is then used to derive a policy that will be enforced
34Shredder: Breaking Exploits through API Specialization
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
the analyzed critical functions. More importantly, many of these
arguments have clearly disparate value sets for the needs of benign
and malicious code, allowing us to derive e(cid:29)ective policies.
After the end of our analysis for the whole program, a given ar-
gument is classi(cid:27)ed as either known or unknown. Known arguments
belong to one of the following types:
(1) Flag Argument: Each (cid:30)ag value has a special meaning, and
multiple (cid:30)ags can be combined through a logic OR operation.
(2) Range Argument: A numeric range speci(cid:27)es an upper and
lower limit on the expected values (these often correspond
to memory address ranges).
(3) Distinct Value Argument: A set of possible distinct values that
this argument may take (e.g., numbers or strings). Arguments
such as allocation sizes (of which we observe only a few
distinct values) often fall into this category.
An argument is considered unknown, if a constant value cannot be
determined for each and every call site of its function. We follow this
conservative approach despite the fact that we can often determine
the values of a given argument for the majority of a function’s call
sites, and just miss a few. In such cases, API specialization is coupled
with CFI to restrict further the set of attacker-controllable invoca-
tion points, by enforcing call-site-speci(cid:27)c policies. Although our
prototype currently supports call-site-speci(cid:27)c policies (the design
and implementation of which we present in the appendix), given
that only a few Windows applications are currently CFI-enabled,
we leave the evaluation of such a scheme as part of our future work.
As we demonstrate in Section 5, our current more coarse-grained
approach using a single program-wide policy per function is still
quite e(cid:29)ective in thwarting real exploits.
In some cases, even if some arguments are unknown, they can
still take part in policy speci(cid:27)cation by considering relationships
across two or more arguments that are re(cid:30)ected in the argument
preparation code of call sites. For instance, from an instruction se-
quence like push eax; push eax; push ebx; call ,
we can infer that the (cid:27)rst two arguments have the same value, even
if the actual value is unknown. If this invariant holds for all call sites
of a given function, then it can be captured as part of the enforced
policies for that function.
Example policies generated by our backward data (cid:30)ow analysis
algorithm are:
(1) VirtualProtect(): (arg3 = 0x20 AND arg2 = 0x1000)
OR (arg3 = 0x104)
(2) VirtualAlloc(): (arg1 == arg2)
3.2 Runtime Policy Enforcement
After the preprocessing phase is completed, the resulting policies
are ready to be used for runtime protection. Shredder relies on
library interposition to check the arguments of a sensitive API func-
tion invocation before permitting it to proceed. A call is permitted
to proceed only if its arguments are in accordance with the policy
for the given function. If not, the call is dropped.
Although we assume that code stripping [50] has already been
applied to the target application, even if this is not the case, Shredder
does partly provide equivalent protection by also blocking the
invocation of any function that is not present in the import table of
the protected application. This provides the same level of protection
when it comes to whole-function reuse, but does not help with ROP
gadget reuse from the code sections of the non-imported functions,
as their code is still present in the address space of the process—this
code removal feature could of course be incorporated into Shredder
with some engineering e(cid:29)ort, as we further discuss in Section 6.
4 IMPLEMENTATION
To demonstrate the e(cid:29)ectiveness of API specialization, we have
developed Shredder, a prototype protection tool for Windows PE bi-
naries (both main executables and dynamic link libraries). Shredder
has been developed and tested on the 64-bit version of Windows 10,
and consists of two main components: an o(cid:31)ine static policy extrac-
tor, and a user-space thin interposition layer between applications
and Windows API functions. We have also developed a shellcode
and ROP payload analysis framework to evaluate the e(cid:29)ectiveness
of the derived policies in blocking existing exploits.
4.1 Static Policy Extraction
Our policy extraction pass has been implemented on top of the IDA
Pro disassembler through its IDAPython scripting environment.
Our IDAPython tool reads each input executable and initially scans
it to (cid:27)nd all call sites of critical API functions (we assume that the
complete set of an application’s modules is available in advance
for analysis). Note that call sites can be accurately pinpointed even
without any debug or symbolic information (e.g., PDB (cid:27)les), by
identifying the respective references through the import table.
For each identi(cid:27)ed call site, the tool then performs backwards
inter-procedural data (cid:30)ow analysis to derive the function argu-
ment values used in that particular call site. Due to the inherent
imprecision of code disassembly and control (cid:30)ow graph extraction,
unfortunately we cannot rely on existing sophisticated data (cid:30)ow
analysis frameworks that operate at the source code or intermediate
representation (IR) layers. Although we initially explored the use
of IR-lifting tools (e.g., McSema [1]) that would enable data (cid:30)ow
analysis at the IR level, we found that the analysis results were not
signi(cid:27)cantly better (from a policy extraction perspective) for our
purposes, compared to our custom, argument-focused data (cid:30)ow
analysis implementation.
Of particular usefulness is IDA pro’s stack variables window data
structure, which contains local variables and function arguments
extracted during static analysis. If a value is derived by an input
from a previous function, we leverage the computed control (cid:30)ow
graph to perform backwards data (cid:30)ow tracking and attempt to
identify its source. For our current implementation, we have set
a limit of three functions for the recursion depth to keep analysis
time low. Based on our experimentation, higher recursion values
provided only diminishing returns.
If the value of an argument is not found within these iterations,
the value is considered unknown. As reported in Section 5, despite
the best-e(cid:29)ort nature of our approach and the limitations of our
data (cid:30)ow analysis, it still achieves good coverage for the particu-
lar arguments of critical functions, providing high discriminatory
capacity between benign and malicious code.
5ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Shachee Mishra and Michalis Polychronakis
4.2 Runtime Interposition Layer
Our current implementation uses Microsoft Detours [30] frame-
work to selectively intercept protected API calls. During initial-
ization, the extracted policies are loaded from its respective (cid:27)le,
and are veri(cid:27)ed at runtime against each intercepted invocation. If
there is no policy violation, the actual API function is then called,
otherwise an alert message is displayed and the process then ter-
minates. Due to the conservative nature of our policy extraction
phase, there is no false positive issue, as the policies rely only on
statically-derived argument values observed through the whole
application code.
As any other defense based on function hooking, if no other
precautions are taken, attack code could bypass Shredder’s policy
check by either jumping over Detour’s hook, or by invoking the
respective system call directly (e.g., through ntdll.dll).1 In the
context of code-reuse attacks, which is our primary focus, this
issue can be addressed by ensuring that system calls can be solely
invoked through Windows API functions, and not directly. This can
be achieved in several ways. If the protected application employs
CFI, then the enforced CFI policy will prohibit arbitrary control
transfers to the middle of API functions or even straight to system
call wrapper functions.
Even if CFI is not an option, previous systems (e.g., kBouncer [55])
have proposed a checkpointing mechanism that relies on the kernel
to perform the policy enforcement at the entry point of the API
function, and set a checkpoint that is checked upon system call
entry. Tying the checkpointing code after the policy check ensures
that exploit code cannot fake a checkpoint without violating the
enforced policy. We refer the interested reader to description of
this mechanism by Pappas et al. [55] for more details. More light-
weight hook protection mechanisms, such as those employed by
Microsoft’s EMET [49], could also be employed. As hooking pro-
tection is an orthogonal issue for which solutions already exist, we
have left its implementation as part of our future work.
5 EVALUATION
In this section, we present the results of our experimental evaluation
of Shredder in terms of runtime overhead and e(cid:29)ectiveness against
real-world exploits. All experiments were performed on a system
equipped with an Intel Core i7-5650U CPU, 8GB RAM, 256GB SSD,
running the 64-bit version of Windows 10 Education.
5.1 Data Set
To evaluate the e(cid:29)ectiveness of Shredder against real-world exploits,
we gathered a diverse set of 251 shellcode and 30 ROP code samples
from Metasploit, Exploit DB, and individual real-world and proof-
of-concept exploits. We consider both shellcode and ROP payload
samples, as in modern exploits ROP code is typically used just
to enable the execution of a second-stage shellcode, by giving it
execute memory permission. The shellcode then performs further
malicious activities, and typically invokes many more system API
functions. However, although ROP code is much more complex to
construct, sophisticated exploits may avoid the use of second-stage
1Although direct system call invocation is much more challenging in Windows com-
pared to Linux [64], this is still an option for highly targeted exploit code constructed
for a particular victim system [3].
)
c
e
s
n
i
(
e
m
T
i
0
5
1
0
0
1
0
5
0
GetProcAddress
CloseHandle
DeleteFile
CreateFile
ReadFile
LoadLibrary
VirtualAlloc
VirtualProtect
Original
Shredder
Figure 2: Worst-case runtime overhead of Shredder’s run-
time policy enforcement, for arti(cid:27)cial stress-test cases that
repeatedly invoke critical API functions.
shellcode altogether, and implement the whole functionality using
reused code [9]. In either case, the exploit code unavoidably has
to invoke several system API calls. To get a better insight about
which stage Shredder is more e(cid:29)ective in blocking, we present our
results separately for shellcode and ROP payloads.
To evaluate the e(cid:29)ectiveness of our policy extraction against
these payloads, we use a set of 10 popular Windows applications
that are typically targeted by in-the-wild attacks. As the choice of
payload used in a given exploit depends on the attacker’s goal, the
characteristics of the vulnerability, and the protections deployed on
the victim system, we make the conservative assumption that any
shellcode or ROP payload from our data set can be potentially used
as part of exploits against any of the considered applications. That
is, we do not make any assumptions about the actual functionality
of the exploit code (e.g., creating sockets, writing (cid:27)les, allocating
memory), but conservatively assume that any of these operations
may be performed. Similarly, only a subset of ROP payloads will
be applicable for a given application, depending on the available
gadgets in its code image. Still, we assume that all ROP payloads
may be applicable, as we care only about the API functions they
use, and not about the speci(cid:27)c gadgets they rely on to invoke them.
Full details and sources for the particular ROP payloads used in our
evaluation are provided in Section B and Table 6 in the appendix.
5.2 Runtime Overhead
Measuring the performance impact of defenses based on API hook-
ing on real world applications like media players, text editors, and
web browsers, i.e., such as the ones we have included in our set, is a
challenging task due to their interactive nature. Instead, to measure
the runtime overhead of Shredder’s API call interception and policy
checking, we used a set of custom programs that repeatedly invoke
critical (hooked) API functions with various sets of argument values
and enforced policies—although this is a worst-case behavior that
is not encountered in real-world applications, it provides an upper
bound on what can be expected in practice.
6Shredder: Breaking Exploits through API Specialization
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
To measure API call overhead, each invocation is performed
with a di(cid:29)erent set of arguments, a check is made against 10 dif-
ferent policies (a larger number than needed in practice), and each
test case invokes a given function 100 million times, which is or-
ders of magnitude more than the average number of calls made
by the applications we tested for typical workloads. As shown in
Figure 2, for all tested API functions, the total execution time when
using Shredder compared to the original test cases is only slightly
increased.
Using further micro-benchmarks, we found that the per-call
overhead on average is less than 20ns. We also applied Shredder
on the SPEC2006 benchmarks, and found no measurable over-
head. The main reason is that the benchmarks are designed for
CPU performance evaluation, and thus invoke very few API calls
that need protection (ExitProcess(), WriteFile(), ReadFile(),
CloseHandle(), CreateFileW()).
5.3 Policy Generation
The entire premise of Shredder’s protection is that we can often
di(cid:29)erentiate between legitimate and malicious invocations of criti-
cal API functions, due to the disparate set of argument values used
in each case. To evaluate the extent to which Shredder is capable of
generating restrictive policies regarding the expected values of crit-
ical API function arguments, we used a set of 10 popular—and often
targeted by in-the-wild exploits—Windows applications, listed in
Table 2. The results of this section focus only on the remaining
critical API functions after the application of code stripping [50],
the arguments of which Shredder can restrict further.
5.3.1 Analysis Time. Each application is (cid:27)rst analyzed with IDA
Pro using its standard code disassembly and control (cid:30)ow extraction
settings (we refrain from using any optional more aggressive dis-
assembly heuristics). Then Shredder’s o(cid:31)ine analysis phase takes
place to identify all critical API function call sites, and perform
backwards data (cid:30)ow analysis to derive their known argument val-