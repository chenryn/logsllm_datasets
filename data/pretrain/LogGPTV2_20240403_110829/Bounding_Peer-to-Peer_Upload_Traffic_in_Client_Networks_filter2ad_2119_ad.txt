### 2. Mathematical Formulation

The number of marked bits in the bit vector should be proportional to the number of active connections \( c \) within a time unit \( T_e \). Assuming that hash function collisions are rare when the utilization of the bit vector is low, Equation (2) can be rewritten as:

\[
p = \left(1 - \left(1 - \frac{c \cdot m}{N}\right)^m\right)
\]

Given a bit vector size \( N \) and the expected maximum number of active connections \( c \), to minimize the desired penetration probability \( p \), we differentiate Equation (3) and obtain:

\[
\frac{d p}{d m} = \left(1 - \frac{c \cdot m}{N}\right)^{m-1} \cdot \left(\frac{c \cdot m}{N} \cdot \ln\left(1 - \frac{c \cdot m}{N}\right) + \frac{c}{N}\right)
\]

Setting the derivative to zero, we solve for \( m \):

\[
1 + \ln\left(\frac{c \cdot m}{N}\right) = 0
\]

Thus, the value of \( m \) that minimizes the penetration probability \( p \) is:

\[
m = e^{-1} \cdot \frac{N}{c}
\]

where \( e \) is the base of the natural logarithm. By substituting \( m \) in Equation (3) with \( e^{-1} \cdot \frac{N}{c} \), the ratio of the expected maximum number of active connections \( c \) should satisfy:

\[
\frac{c}{N} \leq -\frac{1}{e} \ln p
\]

For example, if we use a bitmap filter of size \( N = 2^{20} \) (approximately 1 million bits) with \( k = 4 \) and \( \Delta t = 5 \) seconds, and set the desired penetration probability to be approximately 10%, 5%, and 1%, the number of active connections within a time unit \( T_e = 20 \) seconds should be less than 167K, 125K, and 83K, respectively. Compared to our trace data, which has an average of only 15K active connections within a 20-second time unit, these upper bounds are significantly higher than the actual traffic. The number of hash functions \( m \) used in the setup can be 3, and the memory space required by the bitmap filter is only \( \frac{k \times N}{8} = 512 \) KB.

### 5. Performance Analysis

The bitmap filter is efficient because almost all operations can be performed in constant time. The processing time for an outbound packet is \( O(m \times t_h) + O(m \times k \times t_m) \), where \( m \) is the number of hash functions, \( t_h \) is the time taken to execute a hash function, \( k \) is the number of bit vectors to be marked, and \( t_m \) is the processing time to mark a bit. Processing inbound packets is simpler, requiring \( O(m \times t_h) + O(m \times t_c) \), where \( t_c \) is the processing time needed to check whether a bit on a bit vector is marked or not. Inbound packet processing is also a constant-time operation. When an inbound packet is considered to be dropped, the bitmap filter drops the packet according to the dropping probability \( P_d \). Computing \( P_d \) requires only the knowledge of the current bandwidth throughput, which is an essential component in off-the-shelf network devices.

The most time-consuming operation may be the `b.rotate` algorithm, which executes every \( \Delta t \) seconds. The algorithm first advances the current index `idx` to set the next bit vector and then resets all bits in the last bit vector to zero. Thus, the operation is proportional to the size of a bit vector, which is \( O(n) \). However, since the memory space of a bit vector is fixed and continuous, implementing such an algorithm in software is simple and efficient. As all the components used in the algorithm already have corresponding hardware implementations, it is also easy to accelerate the algorithm using hardware coprocessors.

### 5.3 Simulation with Packet Trace

We conducted several simulations to verify the effectiveness of the bitmap filter. Both a bitmap filter and an SPI-based filter were implemented. The input to both filters was the packet trace used in Section 3.3. First, we compared the packet drop rates of the two filters. The SPI filter was set to delete idle connections after 240 seconds, which is the default TIME_WAIT timeout in the Microsoft Windows operating system. The bitmap filter was configured as follows: \( N = 2^{20} \), \( k = 4 \), \( T_e = 20 \), \( \Delta t = 5 \), and all inbound packets without states were dropped. This configuration constructs a 512 KB bitmap filter that handles out-in packet latency shorter than 20 seconds. As shown in Figure 8, the filters have similar packet drop rates, and the gray-dashed line has a slope of 1.0. The SPI filter has an average drop rate of 1.56% compared to 1.51% for the bitmap filter. This is because the SPI filter knows the exact time of closed connections and can therefore drop packets more precisely than the bitmap filter.

The second simulation demonstrates the effectiveness of the bitmap filter on the same packet trace data. The bitmap filter now monitors the bandwidth throughput of upstream traffic and blocks incoming connections when the uplink bandwidth throughput is high. The dropping probability \( P_d \) is generated by Equation 1 with an upper bound bandwidth limit \( H \) of 100 Mbps and a lower bound bandwidth limit \( L \) of 50 Mbps. To simulate a blocked connection, when an inbound packet is decided to be dropped by the bitmap filter, the socket pair \( \sigma \) of that packet is stored, and all future packets that match any stored \( \sigma \) or \( \sigma \) are dropped without checking the bitmap. The configuration of the bitmap filter aims to control peer-to-peer upload traffic below an upper bound of 100 Mbps. Figures 9-a and 9-b show the original and filtered bandwidth throughput, respectively. In the figures, the black line indicates the downlink throughput, and the gray part indicates the uplink throughput. It should be noted that both parts of the downlink and uplink traffic are limited. This is because some download peer-to-peer traffic is transferred in different inbound connections. Since the simulation is done with replayed packet traces, the simulation cannot block the outbound connections that may be triggered by previously blocked inbound requests, limiting the effect of the traffic filtering. We believe that the filter can perform better in a real network environment. The simulation results also show that the 512 KB {4Ã—2^20}-bitmap filter with 3 hash functions can properly limit uplink traffic for small- or medium-scale client networks.

### 6. Conclusions

The core spirit of peer-to-peer applications is to share with the public. Therefore, a client host running peer-to-peer applications always generates a considerable amount of upload traffic, which should be limited in a client network. However, with randomly selected port numbers and the use of protocol encryption, peer-to-peer traffic is difficult to identify and manage. Since upload traffic is usually triggered by inbound requests, this paper proposes a bitmap filter to bound peer-to-peer upload traffic by controlling inbound requests. The proposed algorithm requires only constant storage and computation power. Analyses and simulations show that with a small amount of resources, an ISP can efficiently prevent peer-to-peer traffic from affecting other network services.