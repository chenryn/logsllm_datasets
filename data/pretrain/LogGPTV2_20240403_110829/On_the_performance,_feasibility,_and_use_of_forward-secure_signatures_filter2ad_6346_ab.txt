signature size, are very efﬁcient in this scheme – the same as in
the underlying base scheme. Still, this trivial scheme is clearly
impractical, because it requires public and secret key sizes which
are linear in T , the number of periods the schemes can be used.
Some improvements to the above scheme were suggested al-
ready in the ﬁrst works in the area [2, 4, 26]. For example, Krawczyk [26]
proposes a method where the total storage of the signer is still lin-
ear in T , but the public key and the secret key themselves are both
short (proportional to the security parameter). That is, the bulk of
the keying material stored is needed by the signer, but even if com-
promised by an adversary, forgery is still not possible.
While these improvements are better than the trivial scheme above,
for a practical scheme it is desirable not to have such a linear de-
pendence on T , in any of the parameters. We further discuss the
efﬁciency requirements below.
2.2 Efﬁciency Requirements
What are the efﬁciency requirements when designing a forward-
secure signature scheme? We cannot hope to beat standard signa-
ture schemes, since forward-secure signature schemes are a strictly
stronger construct. Thus, we would like a forward-secure signature
scheme to perform not much worse than a standard one, in terms
of time (for key generation, signing and verifying), and space (key
size and signature size). In particular, it is not desirable for these
parameters to grow with the number of time periods T .
One might be tempted to require that there is no dependency
whatsoever on T . But note that, as pointed out by [27], signature
schemes already depend on some security parameters, which must
be super-logarithmic in T . If this were not the case, by the time pe-
riod T is reached, the scheme could have been broken by exhaustive
search. Therefore, a logarithmic asymptotic dependence on T is no
worse (and possibly better) than the required linear dependence on
the security parameters.
Indeed, to evaluate the performance of a forward-secure sig-
nature scheme, it is necessary to examine the actual performance
more closely. The only type of analysis of forward-secure schemes
to date involves a theoretical analysis, estimating the asymptotic
performance of the schemes as a function of T and two security pa-
rameters (representing the key-sizes for private-key operations such
as hashing, and public-key operations such as RSA signatures). In
this work we suggest the ﬁrst experimental performance evaluation,
for the forward-secure signatures described below.
We next turn to reviewing the main features of known forward-
secure signature schemes. These can be divided into two main cat-
egories, as detailed below.
2.3 Generic Provably-Secure Schemes
This category includes schemes that can use any arbitrary base
signature scheme, and their security is provable as long as the base
signature scheme is secure. For example, the trivial solutions dis-
cussed above fall under this category. Efﬁcient generic provably
secure schemes (without a linear dependence on T ) are the ones
implemented in this work, and surveyed below (we refer the reader
to the original papers for more details on the schemes).
Bellare-Miner Tree
Bellare and Miner [4] suggest a forward-secure scheme based on
a binary certiﬁcation tree. Roughly speaking, a binary tree is con-
structed with T leaves, where each leaf corresponds to a time pe-
riod. An instance ((secret-key,public-key) pair) of a base (standard)
signature scheme is associated with each node in the tree. The pub-
lic key of the forward-secure scheme is the public key of the root,
and the secret key consists of all the base key pairs associated with
nodes on the path from the root to the current time period. A sig-
nature for time period j consists of a certiﬁcation chain from the
appropriate leaf to root, where the leaf key is used to sign the ac-
tual message, and each node is used to sign the public key of its
child. Veriﬁcation veriﬁes each signature on the chain, up to the
top level (root) signature which is veriﬁed against the public key.
In this scheme, all performance parameters (size and time) are
poly(k, l)O(log T ), where k, l are the security parameters (the ac-
tual dependence on k, l depends on the performance of the under-
lying base scheme). As explained above, this logarithmic depen-
dence on T is very good, and, at least from a theoretical point of
view, this scheme is satisfactory. Still, this is not competitive with
standard signature schemes, as signing a message involves log T
signatures (which are expensive public-key operations) in the un-
derlying base scheme. Allowing a high number of possible time
periods T , this factor can be prohibitive. On the other hand, key
update is very efﬁcient, roughly consisting of two (amortized) key
generations in the underlying base scheme (since each key in the
tree is only generated once).
Product Construction
Malkin, Micciancio, and Miner [27] suggest two composition op-
erations, taking any two forward-secure schemes with T1, T2 time
periods, respectively,2 and constructing a new forward-secure sig-
nature scheme with more time periods. These constructions are
suggested as tools in constructing ﬂexible forward-secure scheme
by applying them repeatedly in different combinations, possibly
with other known schemes. The constructions are also used toward
the main [27] scheme.
Their ﬁrst composition operation is the product construction, re-
sulting in a scheme with T1 · T2 periods. Here, an instance of the
2Note that a standard signature scheme can be viewed as a forward-
secure scheme with one time period.
ﬁrst scheme (with T1 periods) is generated, and for each time pe-
riod, a new instance of the second scheme (with T2 periods) is gen-
erated underneath it. The public key is the public key of the top
(ﬁrst) scheme, and a signature operation signs the message with
the key of the second scheme (in that time period), and signs the
public key of the second scheme with the key of the ﬁrst scheme.
The product construction can be viewed as making explicit the
main building block that was already used by the Bellare-Miner tree
(as well as Anderson’s original scheme [2], and other certiﬁcation
based constructions).
Indeed, when iterated recursively, starting
from any standard base scheme, the product construction results in
a scheme which is essentially the same as the Bellare-Miner tree. In
this work we evaluate both the Bellare-Miner tree (iterated product
construction), and an application of the product construction on two
schemes resulting from iterated sum construction, described below.
Sum and Iterated Sum Constructions
The second composition operation suggested in [27] is the sum
construction, combining two schemes with T1, T2 time periods, re-
spectively, to a scheme with T1+T2 time periods. Here, an instance
of each of the two schemes is generated, and the public key is the
hash of both public keys. A signature consists of the two public
keys, and a signature of the message according to the ﬁrst (if it is
within the ﬁrst T1 time periods), or the second (if it is within the
next T2 periods). Taking the secret key to consist of the (secret and
public) keys of both schemes would allow the right functionality
for the signer, but result in an inefﬁcient key size. Instead, a more
efﬁcient way to generate and maintain the secret keys is proposed,
and the reader is referred to [27] for details.
When iterated recursively, starting from any standard base scheme,
the iterated sum construction results in a binary tree, with each time
period associated to a leaf, similar to the Bellare-Miner tree. How-
ever, each node in the tree is the hash of its two children (in the
same spirit of Merkle trees [28]), rather than being used to sign its
children. This means that signing (and verifying) is much more ef-
ﬁcient, as log T hashes (private key operations) are extremely fast
to compute, compared with log T signatures, which are slow. On
the other hand, key update is much slower here, since the signer
must generate all the public keys in a bottom-up fashion, in order
to compute their hash which is the public key; since the signer does
not keep all keys (or else the key size would be very large), re-
generation of keys is necessary during the life time of the scheme,
resulting in (amortized) log T key generations per update. In con-
trast, in the Bellare-Miner scheme, the tree is built top down, with
new keys generated only when needed, resulting in 2 key genera-
tions per update.
In sum, the asymptotic performance of the iterated sum construc-
tion is also poly(k, l) log T ; when explored more carefully, signing
and verifying is extremely efﬁcient, consisting of one signature in
the base scheme plus log T hashes, while key generation and up-
dates take about log T key generations of the base scheme, which
may be slow ([27] suggests that this may be improved using one-
time signatures[13, 7]).
MMM Tree
The main scheme suggested in [27] is one using both the sum and
product constructions, starting from any underlying base signature
schemes. The idea is to use an iterated sum construction with a
polynomial number of time periods, where for each time period,
another iterated sum construction is attached, using the product
construction. The number of periods for each iterated sum con-
struction on the lower level keeps increasing as time progresses,
starting from a 2-period scheme attached to the ﬁrst time period of
the top level, then a 4-period scheme attached to the second period,
an 8-period scheme for the third period, and so on.
The MMM construction achieves a new feature that previous
schemes did not, namely that the maximal number of time peri-
ods, T , need not be ﬁxed in advance, and thus does not inﬂuence
the performance. Rather, more time periods are added as needed,
for an arbitrarily large polynomial number of time periods. The
performance slowly degrades, proportional to log t, where t is the
number of time periods elapsed so far.
In terms of performance, signing consists of two signatures plus
log t hashes in the underlying base scheme (which is very efﬁcient),
while key update consists of log T key generations in the base
scheme (which may be expensive). The main performance advan-
tage of [27], namely that of efﬁcient signing and verifying, is due
to the fact that the iterated sum construction is prominently used.
The use of product construction may in principle make MMM a
little less efﬁcient than iterated sum, but it allows for unbounded
number of time periods, which also makes the performance better,
as it only depends on the number of time periods elapsed so far, and
not on the maximum T . This is what the theoretical analysis of the
schemes indicates. An experimental performance analysis is con-
ducted in this paper, and compares MMM, iterated sum, product,
and Bellare-Miner tree in different settings.
2.4 Speciﬁc, Random Oracle Based Schemes
Another category of forward-secure schemes consists of con-
structions built upon speciﬁc standard signature schemes, which in
turn (in all the known schemes) are built from speciﬁc identiﬁca-
tion protocols using the Fiat-Shamir methodology [17]. These FSS
schemes (as well as the underlying standard signatures) are proven
secure in the random-oracle model.
The ﬁrst proposed FSS in this category are the main scheme of
Bellare and Miner [4] (based on the Ong-Schnorr [32] scheme), op-
timizing key and signature sizes, followed by a scheme of Abdalla
and Reyzin [1], which improves the time parameters at the expense
of longer key and signature sizes. However, these schemes have
signing and veriﬁcation times which are linear in T .
Itkis and Reyzin [21] propose a FSS (based on the
Guillou-Quisquater [18] scheme), which does not have linear de-
pendence on T in any of its parameters, and optimized signing and
verifying time.
In particular, signing and verifying in their FSS
scheme is comparable to (about twice as expensive as) the underly-
ing [18] standard signature scheme.
Kozlov and Reyzin [25] propose a FSS with a very fast update
operation, which signiﬁcantly improves upon all other forward-
secure signatures (generic or speciﬁc). However, the performance
of other parameters (such as signing and verifying time) are not as
good for this scheme, and so it is only useful for speciﬁc applica-
tions where update time is the important parameter to optimize.
2.5 Comparison
The main advantage of the generic schemes is that they have
provable security (assuming any signature schemes exist, or equiva-
lently, assuming one-way functions exist). This is in contrast to the
speciﬁc schemes which can only be proven secure in the random-
oracle model, a weakness they inherit from the underlying standard
signatures they are based on. Proven security in the random-oracle
model is very valuable as a heuristic for security, but provides a sig-
niﬁcantly weaker security guarantee. In particular, it does not even
guarantee the existence of an instantiation of the random oracle for
which the scheme is secure [8].
Another advantage of generic schemes stems from the fact that
they can be used with any underlying base signature schemes. This
again provides a stronger security guarantee (as it requires a weaker
assumption – any implementation of one-way functions sufﬁces).
Furthermore, this allows for ﬂexibility in optimizing and trading
off the time and space parameters of the FSS scheme, by using base
schemes with different performance characteristics, rather than be-
ing bound to the properties of a speciﬁc base scheme. Finally, the
generic MMM scheme has the advantage of an unbounded number
of time periods, as discussed above.
The main advantage of the speciﬁc schemes, is that they achieve
better dependence on T and the security parameters in some of
their time or space measures. For example, the main scheme of
Bellare and Miner [4] achieves key and signature sizes which are
completely independent of T . Moreover, the performance of each
of these speciﬁc schemes is typically signiﬁcantly better, at least
in some of the parameters, than the best generic schemes that were
known at the time the speciﬁc scheme was introduced. In particu-
lar, Itkis and Reyzin [21] were the ﬁrst to propose a FSS scheme
with signing and verifying which is comparable to standard signa-
ture schemes, while maintaining reasonably good performance (in
particular, not linearly dependent on T ) in all other time and space
parameters. (The MMM generic scheme described above, which
also achieves this, was proposed later.)
Finally, speciﬁc schemes, and in particular that of [21], were the
basis for several extensions to other models [16, 22], as well as the
fast update FSS scheme of [25].
Comparing a generic scheme with a speciﬁc scheme in terms
of asymptotic performance (as done by the authors of the various
schemes), is difﬁcult. This is because the different instantiations of
the generic scheme give different results, typically trading off im-
provements in different parameters. For a most informative general
comparison, it is probably best to instantiate the generic scheme
with the same base signature scheme as the speciﬁc scheme un-
der consideration. For a comparison geared toward a particular ap-
plication, the generic scheme should be instantiated with the best
possible base scheme for that application.
With this in mind, the asymptotic performance of the best (con-
sidering all parameters) speciﬁc scheme [21] and the best generic
scheme [27] are quite close (and neither is better than the other in
all parameters simultaneously). For both, the theoretical analysis
predicts that they should be feasible (and our experimental results
in Section 3 conﬁrms this).
2.6 Schemes Implemented in This Work
In this paper we focus on the generic Bellare-Miner tree, iterated
sum, product, and MMM constructions. In several places we refer
to these schemes by short names, BMTree, ISum, Prod, and MMM
respectively. We chose the generic schemes due to the advantages
outlined above. Moreover, the modular nature of these tree based
constructions, together with the possibility of using different stan-
dard signatures as a base, provides much ﬂexibility in constructing
the ﬁnal scheme. It is thus important to evaluate performance of
particular choices in order to determine the feasibility and appli-