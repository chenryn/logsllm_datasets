### Signature Size and Efficiency in Forward-Secure Schemes

In the context of forward-secure signature schemes, the trivial scheme maintains the same signature size as the underlying base scheme. However, this trivial scheme is impractical because it requires public and secret key sizes that are linear in \( T \), the number of time periods over which the scheme can be used.

### Improvements to the Trivial Scheme

Several improvements have been proposed to address the limitations of the trivial scheme. For example, Krawczyk [26] suggests a method where the total storage for the signer remains linear in \( T \), but the public and secret keys themselves are short (proportional to the security parameter). This means that even if the keying material is compromised by an adversary, forgery remains infeasible.

While these improvements are better than the trivial scheme, a practical forward-secure signature scheme should not have a linear dependence on \( T \) in any of its parameters. We will discuss the efficiency requirements in more detail below.

### 2.2 Efficiency Requirements

When designing a forward-secure signature scheme, the efficiency requirements are crucial. Since forward-secure signature schemes are a strictly stronger construct than standard signature schemes, we aim for performance that is not significantly worse than a standard scheme in terms of time (for key generation, signing, and verifying) and space (key size and signature size). Specifically, it is undesirable for these parameters to grow with the number of time periods \( T \).

One might argue that there should be no dependency on \( T \) at all. However, as pointed out by [27], signature schemes already depend on security parameters that must be super-logarithmic in \( T \). If this were not the case, the scheme could be broken by exhaustive search by the time period \( T \) is reached. Therefore, a logarithmic asymptotic dependence on \( T \) is no worse, and possibly better, than the required linear dependence on the security parameters.

To evaluate the performance of a forward-secure signature scheme, a detailed analysis is necessary. The only type of analysis available so far involves theoretical estimates of the asymptotic performance as a function of \( T \) and two security parameters (representing the key-sizes for private-key operations such as hashing, and public-key operations such as RSA signatures). In this work, we propose the first experimental performance evaluation for the forward-secure signatures described below.

### 2.3 Generic Provably-Secure Schemes

This category includes schemes that can use any arbitrary base signature scheme and whose security is provable as long as the base signature scheme is secure. Efficient generic provably-secure schemes (without a linear dependence on \( T \)) are the ones implemented in this work, and surveyed below.

#### Bellare-Miner Tree

Bellare and Miner [4] suggest a forward-secure scheme based on a binary certification tree. A binary tree with \( T \) leaves is constructed, where each leaf corresponds to a time period. An instance ((secret-key, public-key) pair) of a base (standard) signature scheme is associated with each node in the tree. The public key of the forward-secure scheme is the public key of the root, and the secret key consists of all the base key pairs associated with nodes on the path from the root to the current time period. A signature for time period \( j \) consists of a certification chain from the appropriate leaf to the root, where the leaf key is used to sign the actual message, and each node is used to sign the public key of its child. Verification verifies each signature on the chain, up to the top-level (root) signature, which is verified against the public key.

In this scheme, all performance parameters (size and time) are \( \text{poly}(k, l) O(\log T) \), where \( k, l \) are the security parameters. This logarithmic dependence on \( T \) is very good, and, at least theoretically, this scheme is satisfactory. However, it is not competitive with standard signature schemes, as signing a message involves \( \log T \) signatures (which are expensive public-key operations) in the underlying base scheme. Allowing a high number of possible time periods \( T \), this factor can be prohibitive. On the other hand, key update is very efficient, roughly consisting of two (amortized) key generations in the underlying base scheme.

#### Product Construction

Malkin, Micciancio, and Miner [27] suggest two composition operations, taking any two forward-secure schemes with \( T_1 \) and \( T_2 \) time periods, respectively, and constructing a new forward-secure signature scheme with more time periods. These constructions are suggested as tools for building flexible forward-secure schemes by applying them repeatedly in different combinations, possibly with other known schemes.

Their first composition operation is the product construction, resulting in a scheme with \( T_1 \cdot T_2 \) periods. Here, an instance of the first scheme (with \( T_1 \) periods) is generated, and for each time period, a new instance of the second scheme (with \( T_2 \) periods) is generated underneath it. The public key is the public key of the top (first) scheme, and a signature operation signs the message with the key of the second scheme (in that time period) and signs the public key of the second scheme with the key of the first scheme.

The product construction can be viewed as making explicit the main building block that was already used by the Bellare-Miner tree (as well as Anderson’s original scheme [2], and other certification-based constructions). When iterated recursively, starting from any standard base scheme, the product construction results in a scheme essentially the same as the Bellare-Miner tree. In this work, we evaluate both the Bellare-Miner tree (iterated product construction) and an application of the product construction on two schemes resulting from the iterated sum construction, described below.

#### Sum and Iterated Sum Constructions

The second composition operation suggested in [27] is the sum construction, combining two schemes with \( T_1 \) and \( T_2 \) time periods, respectively, to a scheme with \( T_1 + T_2 \) time periods. Here, an instance of each of the two schemes is generated, and the public key is the hash of both public keys. A signature consists of the two public keys and a signature of the message according to the first (if it is within the first \( T_1 \) time periods) or the second (if it is within the next \( T_2 \) periods). Taking the secret key to consist of the (secret and public) keys of both schemes would allow the right functionality for the signer but result in an inefficient key size. Instead, a more efficient way to generate and maintain the secret keys is proposed, and the reader is referred to [27] for details.

When iterated recursively, starting from any standard base scheme, the iterated sum construction results in a binary tree, with each time period associated with a leaf, similar to the Bellare-Miner tree. However, each node in the tree is the hash of its two children (in the same spirit of Merkle trees [28]), rather than being used to sign its children. This means that signing (and verifying) is much more efficient, as \( \log T \) hashes (private key operations) are extremely fast to compute compared with \( \log T \) signatures, which are slow. On the other hand, key update is much slower here, since the signer must generate all the public keys in a bottom-up fashion to compute their hash, which is the public key. Since the signer does not keep all keys (or else the key size would be very large), regeneration of keys is necessary during the life of the scheme, resulting in (amortized) \( \log T \) key generations per update. In contrast, in the Bellare-Miner scheme, the tree is built top-down, with new keys generated only when needed, resulting in 2 key generations per update.

In summary, the asymptotic performance of the iterated sum construction is also \( \text{poly}(k, l) \log T \). When explored more carefully, signing and verifying is extremely efficient, consisting of one signature in the base scheme plus \( \log T \) hashes, while key generation and updates take about \( \log T \) key generations of the base scheme, which may be slow. [27] suggests that this may be improved using one-time signatures [13, 7].

#### MMM Tree

The main scheme suggested in [27] uses both the sum and product constructions, starting from any underlying base signature schemes. The idea is to use an iterated sum construction with a polynomial number of time periods, where for each time period, another iterated sum construction is attached using the product construction. The number of periods for each iterated sum construction on the lower level keeps increasing as time progresses, starting from a 2-period scheme attached to the first time period of the top level, then a 4-period scheme attached to the second period, an 8-period scheme for the third period, and so on.

The MMM construction achieves a new feature that previous schemes did not, namely that the maximal number of time periods, \( T \), need not be fixed in advance and thus does not influence the performance. More time periods are added as needed, for an arbitrarily large polynomial number of time periods. The performance slowly degrades, proportional to \( \log t \), where \( t \) is the number of time periods elapsed so far.

In terms of performance, signing consists of two signatures plus \( \log t \) hashes in the underlying base scheme (which is very efficient), while key update consists of \( \log T \) key generations in the base scheme (which may be expensive). The main performance advantage of [27], namely that of efficient signing and verifying, is due to the prominent use of the iterated sum construction. The use of the product construction may in principle make MMM a little less efficient than the iterated sum, but it allows for an unbounded number of time periods, which also makes the performance better, as it only depends on the number of time periods elapsed so far, and not on the maximum \( T \). This is what the theoretical analysis of the schemes indicates. An experimental performance analysis is conducted in this paper, comparing MMM, iterated sum, product, and Bellare-Miner tree in different settings.

### 2.4 Specific, Random Oracle Based Schemes

Another category of forward-secure schemes consists of constructions built upon specific standard signature schemes, which in turn (in all the known schemes) are built from specific identification protocols using the Fiat-Shamir methodology [17]. These FSS schemes (as well as the underlying standard signatures) are proven secure in the random-oracle model.

The first proposed FSS in this category are the main scheme of Bellare and Miner [4] (based on the Ong-Schnorr [32] scheme), optimizing key and signature sizes, followed by a scheme of Abdalla and Reyzin [1], which improves the time parameters at the expense of longer key and signature sizes. However, these schemes have signing and verification times that are linear in \( T \).

Itkis and Reyzin [21] propose an FSS (based on the Guillou-Quisquater [18] scheme), which does not have a linear dependence on \( T \) in any of its parameters and optimizes signing and verifying time. Specifically, signing and verifying in their FSS scheme are comparable to (about twice as expensive as) the underlying [18] standard signature scheme.

Kozlov and Reyzin [25] propose an FSS with a very fast update operation, which significantly improves upon all other forward-secure signatures (generic or specific). However, the performance of other parameters (such as signing and verifying time) is not as good for this scheme, and it is only useful for specific applications where update time is the important parameter to optimize.

### 2.5 Comparison

The main advantage of the generic schemes is that they have provable security (assuming any signature schemes exist, or equivalently, assuming one-way functions exist). This is in contrast to the specific schemes, which can only be proven secure in the random-oracle model, a weakness they inherit from the underlying standard signatures they are based on. Proven security in the random-oracle model is valuable as a heuristic for security but provides a significantly weaker security guarantee. In particular, it does not even guarantee the existence of an instantiation of the random oracle for which the scheme is secure [8].

Another advantage of generic schemes is that they can be used with any underlying base signature schemes. This provides a stronger security guarantee (as it requires a weaker assumption—any implementation of one-way functions suffices). Furthermore, this allows for flexibility in optimizing and trading off the time and space parameters of the FSS scheme by using base schemes with different performance characteristics, rather than being bound to the properties of a specific base scheme. Finally, the generic MMM scheme has the advantage of an unbounded number of time periods, as discussed above.

The main advantage of the specific schemes is that they achieve better dependence on \( T \) and the security parameters in some of their time or space measures. For example, the main scheme of Bellare and Miner [4] achieves key and signature sizes that are completely independent of \( T \). Moreover, the performance of each of these specific schemes is typically significantly better, at least in some of the parameters, than the best generic schemes that were known at the time the specific scheme was introduced. In particular, Itkis and Reyzin [21] were the first to propose an FSS scheme with signing and verifying that is comparable to standard signature schemes, while maintaining reasonably good performance (in particular, not linearly dependent on \( T \)) in all other time and space parameters. (The MMM generic scheme described above, which also achieves this, was proposed later.)

Finally, specific schemes, and in particular that of [21], were the basis for several extensions to other models [16, 22], as well as the fast update FSS scheme of [25].

Comparing a generic scheme with a specific scheme in terms of asymptotic performance (as done by the authors of the various schemes) is difficult. This is because the different instantiations of the generic scheme give different results, typically trading off improvements in different parameters. For a most informative general comparison, it is probably best to instantiate the generic scheme with the same base signature scheme as the specific scheme under consideration. For a comparison geared toward a particular application, the generic scheme should be instantiated with the best possible base scheme for that application.

With this in mind, the asymptotic performance of the best (considering all parameters) specific scheme [21] and the best generic scheme [27] are quite close (and neither is better than the other in all parameters simultaneously). For both, the theoretical analysis predicts that they should be feasible (and our experimental results in Section 3 confirm this).

### 2.6 Schemes Implemented in This Work

In this paper, we focus on the generic Bellare-Miner tree, iterated sum, product, and MMM constructions. In several places, we refer to these schemes by short names: BMTree, ISum, Prod, and MMM, respectively. We chose the generic schemes due to the advantages outlined above. Moreover, the modular nature of these tree-based constructions, together with the possibility of using different standard signatures as a base, provides much flexibility in constructing the final scheme. It is thus important to evaluate the performance of particular choices to determine the feasibility and applicability of the schemes.