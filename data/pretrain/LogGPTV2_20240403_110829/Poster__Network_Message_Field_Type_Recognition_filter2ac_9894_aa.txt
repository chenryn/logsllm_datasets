title:Poster: Network Message Field Type Recognition
author:Stephan Kleber and
Frank Kargl
Poster: Network Message Field Type Recognition
Stephan Kleber
PI:EMAIL
Frank Kargl
PI:EMAIL
Institute of Distributed Systems, Ulm University
Institute of Distributed Systems, Ulm University
Ulm, Germany
Ulm, Germany
ABSTRACT
Existing approaches to reverse engineer network protocols based
on traffic traces lack comprehensive methods to determine the data
type, e. g. float, timestamp, or addresses, of segments in messages
of binary protocols. We propose a novel method for the analysis
of unknown protocol messages to reveal the data types contained
in these messages. Therefore, we split messages into segments of
bytes and interpret these as vectors of byte values. Based on the
vector interpretation, we can determine similarities and character-
istics of specific data types. These can be used to classify segments
into clusters of the same type and to identify their data type for
previously trained data types. We performed first evaluations of
different applications of our method that show promising results
up the a data-type-recognition precision of 100 %.
CCS CONCEPTS
• Security and privacy → Network security; • Networks →
Protocol testing and verification; • Computing methodolo-
gies → Cluster analysis.
ACM Reference Format:
Stephan Kleber and Frank Kargl. 2019. Poster: Network Message Field Type
Recognition. In 2019 ACM SIGSAC Conference on Computer and Communi-
cations Security (CCS ’19), November 11–15, 2019, London, United Kingdom.
ACM, New York, NY, USA, 3 pages. https://doi.org/10.1145/3319535.3363261
1 INTRODUCTION
Protocol reverse engineering based on traffic traces infers the be-
havior of unknown network protocols by analyzing observable
network messages. It is often applied to understand malware com-
munication [2], or to validate the correct and secure implementation
of network services [12]. Existing approaches either concentrate
on textual protocols or apply byte-wise multiple sequence align-
ment. Textual protocol analysis is well understood since natural
language processing (NLP, e.g., Latent Dirichlet Allocation [11]
or Apriori [8]) is applicable to it. For binary protocols, a typical
approach is to byte-wise align messages using sequence alignment
(e. g., Needleman-Wunsch [1, 3]). While sequence alignment infers
probable field candidates, it does not characterize the content of
the field candidates.
Characterizing the contents of message fields is valuable to de-
termine the data type and to reveal the meaning of binary data
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
CCS ’19, November 11–15, 2019, London, United Kingdom
© 2019 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-6747-9/19/11.
https://doi.org/10.1145/3319535.3363261
segments of network messages. For example, recognizing a seg-
ment of a message as being a counter, timestamp, or checksum field
adds semantic interpretation to the message that hitherto was an
unintelligible sequence of bytes. Neither existing approaches based
on NLP nor on sequence alignment provide a method to accomplish
a semantic interpretation on this level. Thus, the type of inferred
fields cannot be distinguished beyond binary and textual segments
of messages by supporting manual introspection [6].
Our approach recognizes fine-grained field data types of binary
protocols from the analysis of segments of network messages. We
quantify the similarity of message segments across all messages.
This similarity is the input to classify groups of similar segments
into field data types. Finally, we use this classification to label similar
segments from unknown protocols with the according data type.
2 APPROACH
The messages we use to train and test our approach are collected
from traces of real network protocols. The traces we analyze are
publicly available1. We pre-process each raw trace by filtering for
only the desired protocol, removing duplicates of the payload, and
truncating them to 1 000 messages each.
For each individual message from these traces, we first obtain
subsequences of messages by tshark and NEMESYS as detailed
below. The obtained subsequences are used as atomic segments
that approximate protocol fields. For the analysis, we interpret each
of these segments as a vector of byte values. To calculate a similarity
value for each pair of segments, we defined a dissimilarity measure
from the Canberra distance [7]. The pairwise dissimilarities of
segments are used as affinity values for clustering by DBSCAN.
DBSCAN [4] determines clusters of similar segments by identifying
cores of high density within noisy data. The density is high in a
neighborhood of segments that have a low dissimilarity to each
other. Each cluster finally constitutes a group of similar segments
and thus, with high probability, a field data type. We utilize this
approach in three modes of application:
Mode 1. First we generate segments that perfectly represent true
fields from the knowledge of true field boundaries obtained from
tshark2 dissectors. We label the segments with their true data type,
which we also determine from the tshark dissectors. We cluster
the segments that were generated in the described manner. In this
first mode of application, we can use the ground truth known from
tshark to validate our approach and to prepare the second mode of
application. This mode of application can only be performed with
known protocols for which a tshark dissector exists.
1NTP, NBNS, SMB, and DHCP filtered from http://download.netresec.com/pcap/smia-
2011/; DNS filtered from https://ictf.cs.ucsb.edu/archive/2010/dumps/ictf2010pcap.
tar.gz; all URLs accessed 19 Sept 2019
2Terminal interface of Wireshark, see https://www.wireshark.org
PosterCCS ’19, November 11–15, 2019, London, United Kingdom2581Mode 2. From the clusters of segments from application mode 1,
we determine templates of common field data types using ground
truth obtained from multiple protocols. Such a data-type template
represents typical features of a field data type. The templates need
to be generated just once and can then be applied in all future
protocol analyses. The templates are used to recognize sufficiently
similar segments in hitherto unseen messages. A data type template
is defined by the mean of all feature vector components and their
covariance matrix from the cluster of a data type. To recognize
segments in traces of unknown network protocols, we iterate a
sliding window of the template’s byte-length over all message bytes
from the unknown trace. Comparing the respective subsequence
of message bytes to the template via the Mahalanobis distance [9]
enables us to quantify the confidence of whether the subsequence
is similar to a learned template. A subsequence that is sufficiently
similar to a template is interpreted as new segment and its type is
recognized as the one represented by the matching template.
Mode 3. The third mode of application is independent of the
first two and also works in case that no known templates match in
messages of an unknown network protocol. Naturally, for unknown
protocols, no dissector is available to generate segments from mes-
sages. Therefore, we resort to a heuristic to generate segments:
NEMESYS [5] obtains message segments from unknown protocols.
We then cluster these segments in the same way as in mode 1 for
the tshark output. Despite that the original kind of data type cannot
be recognized in this mode of application, our approach groups
segments into clusters that represent the same kind of data. Further
analysis can reveal the data type, e. g., by correlation [10].
3 EVALUATION
We show the validity of our approach for each of the described ap-
plication modes by cluster visualization and recognition statistics.
We visualize the dissimilarity of segments compared to the clus-
tering results in Figure 1 and Figure 2 to rationalize the clustering
and recognition approaches. For this purpose, the figures show the
topology of the high-dimensional feature vectors as the dissimilari-
ties between the segments. To plot the relative dissimilarities of the
high-dimensional feature vectors, they must be represented in a
two-dimensional plane. We accomplish this by Multi-dimensional
Scaling (MDS)3. MDS arranges the segments of the analysis in these
topology plots to represent the dissimilarities relative to each other4.
3.1 Clustering Ground Truth Segments
As described in application mode 1, we classify segments into clus-
ters of their field type. As an example showing the analysis of NTP,
Figure 1 is the MDS-plot of the dissimilarity of segments from this
application mode. In this figure, the true field types of each segment
are color-coded, so it can visually be verified that segments of the
same data type are close in terms of their dissimilarity. Thus, the
plot illustrates that areas of low dissimilarity fit to data types and
that these areas are dense in the of sense of DBSCAN’s definition,
making this clustering approach applicable. The resulting clusters
3using the Python module sklearn.manifold.MDS, see https://scikit-learn.org/
4The absolute values of the positions in the plot are insignificant, which is the reason
why we omitted any ax labels in these figures.
Cluster #0
Cluster #1
Cluster #2
Cluster #3
Cluster #4
Cluster #5
Cluster #6
Cluster #7
Cluster #8
Cluster #9
True Segment Types
checksum
float
id
ipv4