primitive than RBC as it does not require totality.
The framework is given in Figure 4. Let Î ğ‘ğ‘ğ‘ ğ‘’ be the underlying
base protocol parameterized by (ğ›½â€²
ğ‘ ). Similar to the RBC
protocol in Section 3.2, we use a quorum-based design with a quo-
rum size of ğ‘›âˆ’ğ›¾â€²
ğ‘ for consistent broadcast. Such a quorum
contains at least one honest replica in the presence of ğ›¾â€²
ğ‘  faults
or ğ›½â€²
ğ‘ faults. Thus, when the sender is honest, no certificate can
be formed for any value other than the senderâ€™s input. Therefore,
ğ‘  > ğ›¾â€²
ğ‘  + ğ›½â€²
ğ‘, ğ›¾â€²
ğ‘, ğ›½â€²
ğ‘ , ğ›¾â€²
Session 6A: Consensus and Attacks CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1695validity and integrity hold. Consistency under synchrony is easily
achieved by a similar synchronous equivocation check mechanism.
As in Section 4, a quorum of âŸ¨commit, ğµğ‘˜âŸ©âˆ— messages serves as
proof for the log up to block ğµğ‘˜.
5.2 Correctness of the Framework
We prove the correctness of the our framework. Let Î ğ‘ğ‘ğ‘ ğ‘’ be the
given base protocol with threshold parameters of (ğ›½â€²
ğ‘ , ğ›¾â€²
ğ‘, ğ›¾â€²
ğ‘ ).
We prove that the converted protocol achieves the optimal ğ›½ğ‘  =
ğ‘› âˆ’ ğ›¾â€²
ğ‘, and ğ›¾ğ‘  = ğ›¾â€²
ğ‘, ğ›¾ğ‘ = ğ›¾â€²
ğ‘ .
Note that the base protocol assumes either an asynchronous or a
partially synchronous network. We will use the asynchronous case
for convenience. The proof below directly applies to the partially
synchronous case.
ğ‘  âˆ’ 1 while tolerating the same ğ›½ğ‘ = ğ›½â€²
ğ‘, ğ›½â€²
Lemma 5.1 (Safety). If the network is asynchronous and there are
at most ğ›½â€²
ğ‘ faults, then safety holds.
Proof. In order for the converted protocol to commit two con-
flicting blocks, they first need to be committed by the base protocol
Î ğ‘ğ‘ğ‘ ğ‘’, which will not happen under the said condition.
â–¡
Lemma 5.2 (Safety). If the network is synchronous and there are
at most ğ‘› âˆ’ ğ›¾â€²
ğ‘  âˆ’ 1 faults, then safety holds.
ğ‘˜
Proof. Suppose for the sake of contradiction that these two
distinct blocks ğµğ‘˜ and ğµâ€²
are committed at the same height by the
converted protocol. There must be a quorum of ğ‘›âˆ’ğ›¾â€²
ğ‘  âŸ¨commit, ğµğ‘˜âŸ©âˆ—
messages and one of them must be from an honest replica. For
the same reason, there must be a âŸ¨commit, ğµâ€²
ğ‘˜âŸ©âˆ— message from an
honest replica. Let ğ‘¡ be the time when the first honest replica ğ‘Ÿ sent
âŸ¨commit, ğµğ‘˜âŸ©ğ‘Ÿ , and ğ‘¡â€² be the time when the first honest replica ğ‘Ÿâ€²
sent âŸ¨commit, ğµâ€²
ğ‘˜âŸ©ğ‘Ÿâ€². Without loss of generality, we assume ğ‘¡ â‰¤ ğ‘¡â€².
Then, ğ‘Ÿ must have received and broadcast a certificate C(ğµğ‘˜) at
ğ‘¡âˆ’Î”. It will be received by ğ‘Ÿâ€² by time ğ‘¡ â‰¤ ğ‘¡â€². It would have prevented
ğ‘Ÿâ€² from sending âŸ¨commit, ğµâ€²
â–¡
Lemma 5.3 (Liveness). If the network is asynchronous and there
ğ‘˜âŸ©ğ‘Ÿâ€² at ğ‘¡â€², a contradiction.
are at most ğ›¾â€²
ğ‘, then liveness holds.
Proof. Due to the liveness of Î ğ‘ğ‘ğ‘ ğ‘’ in the presence of ğ›¾â€²
ğ‘ faults,
all honest replicas keep committing new blocks in Î ğ‘ğ‘ğ‘ ğ‘’. Let ğµğ‘˜ be
a new block committed in Î ğ‘ğ‘ğ‘ ğ‘’. Then, all honest replicas broadcast
âŸ¨vote, ğµğ‘˜âŸ©, and a certificate C(ğµğ‘˜) is created. Due to the safety of
Î ğ‘ğ‘ğ‘ ğ‘’ in the presence of ğ›¾â€²
ğ‘ faults, no honest replica votes for a
conflicting block ğµâ€²
ğ‘˜) cannot be formed.
Therefore, all honest replicas broadcast âŸ¨commit, ğµğ‘˜âŸ© and receive a
quorum of âŸ¨commit, ğµğ‘˜âŸ©âˆ—. Thus, all honest replicas commit ğµğ‘˜. â–¡
The proof of liveness of the protocol under synchrony is similar.
, and thus a certificate C(ğµâ€²
ğ‘ â‰¤ ğ›½â€²
ğ‘˜
5.3 Discussions
Overheads added by the framework. In terms of latency, the
framework adds two extra rounds plus a Î” waiting time. In terms
of communication complexity, the framework introduces 3ğ‘›2 addi-
tional messages; some messages are linear-sized certificates, which
can again be reduced to a constant size using threshold signatures.
Responsiveness. As seen above, our framework (and the protocol
in Sections 3 and 4) is non-responsive, i.e., the latency depends on
a pre-defined estimated bound Î”. We next show that the lack of
responsiveness is inherent if we want higher synchronous safety.
It is well known that any BFT protocol that is safe with ğ‘¡ faults
cannot commit responsively, i.e., faster than the delay bound Î”, in
the presence of ğ‘›âˆ’ğ‘¡
faults, even if designated sender or the leader
2
is honest [42, 43]. This bound can be easily generalized to MT-BFT:
no MT-BFT protocol can commit responsively in the presence of
ğ‘›âˆ’ğ›½ğ‘ 2
Theorem 5.4. There does not exists a MT-BFT RBC protocol that
is safe under ğ›½ğ‘  Byzantine faults under synchrony, and responsive in
the presence of ğ‘›âˆ’ğ›½ğ‘ 2 Byzantine faults.
faults. We prove the bound using RBC as an example.
Proof. Suppose for the sake of contradiction that there exists
an MT-BFT RBC protocol that is responsive in the presence of ğ‘›âˆ’ğ›½ğ‘ 2
Byzantine faults. We consider a network with three partitions ğ‘ƒ,
ğ‘„ and ğ‘…, with sizes |ğ‘ƒ| = |ğ‘…| = ğ‘›âˆ’ğ›½ğ‘ 2
and |ğ‘„| = ğ›½ğ‘ . The designated
sender ğ‘Ÿğ‘  is in ğ‘„. Consider the three executions below.
In the first execution (W1), all messages are instantly delivered
and all replicas in ğ‘ƒ crash. The sender ğ‘Ÿğ‘  has an input value ğ‘1.
Since the protocol is responsive in the presence of ğ‘›âˆ’ğ›½ğ‘ 2 Byzantine
faults, all replicas in ğ‘… commit ğ‘1 within Î” time.
The second execution (W2) is symmetric to the first one. All
messages are instantly delivered and all replicas in ğ‘… crash. The
sender ğ‘Ÿğ‘  has an input value ğ‘2 â‰  ğ‘1. Since the protocol is responsive
in the presence of ğ‘›âˆ’ğ›½ğ‘ 2 Byzantine faults, all replicas in ğ‘ƒ commit
ğ‘2 within Î” time.
In the third execution (W3), all replicas in ğ‘„ are Byzantine. ğ‘„
behave towards ğ‘… and ğ‘ƒ as in W1 and W2, respectively. All messages
between ğ‘ƒ and ğ‘… are delivered with delay Î”, but all other messages
are instantly delivered. Then, replicas in ğ‘… receive no messages from
ğ‘ƒ by time Î” and cannot distinguish W1 and W3 by time Î”. Thus,
they commit ğ‘1 before Î” as in W1. Similarly, replicas in ğ‘ƒ cannot
distinguish W2 and W3 before Î”, and they commit ğ‘2 â‰  ğ‘1 before
Î” as in W2. This violates the supposition that the protocol achieves
consistency in the presence of |ğ‘„| = ğ›½ğ‘  Byzantine faults.
â–¡
Existing partially synchronous protocols such as PBFT, when
viewed as MT-BFT, tolerate ğ›½ğ‘ = ğ›½ğ‘   ğ›½ğ‘, it is inevitable
that the protocol (while live) cannot be responsive in the presence
of ğ‘›/3 faults. Nonetheless, our protocols can still be made optimisti-
cally responsive [43], i.e., responsive when the number of actual
faults is less than ğ‘›âˆ’ğ›½ğ‘ 2
, using techniques in the literature [39, 46].
Higher safety after GST. However, our upgrading framework
actually provides a stronger guarantee than the MT-BFT psync-
sync model defined in Section 2.2. In our definition in Section 2.2,
if the network is partially synchronous, a protocol does not need to
provide higher safety tolerance even after GST. In other words, a MT-
BFT protocol only needs to provide higher safety of ğ›½ğ‘  only if the
network is synchronous at all time. In comparison, the upgrading
framework in this section provides safety in the presence of ğ›½ğ‘  faults
after GST in a partially synchronous network. Let us briefly prove
this. Let ğ‘¡1 be the first time after GST ğ‘‡ğ‘” that an honest replicas
commits a block ğµğ‘˜ of height ğ‘˜. Then all honest replicas receive
Session 6A: Consensus and Attacks CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1696Let Î ğ‘ğ‘ğ‘ ğ‘’ be the given base protocol parameterized by (ğ›½â€²
protocol Î ğ‘ğ‘ğ‘ ğ‘’. A quorum is |C| = ğ‘› âˆ’ ğ›¾â€²
ğ‘ .
ğ‘, ğ›¾â€²
ğ‘, ğ›½â€²
ğ‘ , ğ›¾â€²
ğ‘ ). A replica ğ‘Ÿ runs the following steps in addition to running the base
(1) Vote. Upon committing a block ğµğ‘˜ at height ğ‘˜ in Î ğ‘ğ‘ğ‘ ğ‘’, broadcast âŸ¨vote, ğµğ‘˜âŸ©ğ‘Ÿ .
(2) Pre-commit. Upon receiving a quorum of âŸ¨vote, ğµğ‘˜âŸ©ğ‘Ÿ denoted C(ğµğ‘˜), broadcast it and wait for Î”. Then, broadcast âŸ¨commit, ğµğ‘˜âŸ©ğ‘Ÿ .
(3) Commit. Upon receiving a quorum of âŸ¨commit, ğµğ‘˜âŸ©âˆ— and Î ğ‘ğ‘ğ‘ ğ‘’ has committed ğµğ‘˜, then commit ğµğ‘˜.
Upon receiving C(ğµğ‘˜) and C(ğµâ€²
ğ‘˜) for conflicting blocks ğµğ‘˜ and ğµâ€²
ğ‘˜
, stop all operations above for height ğ‘˜ immediately.
Figure 4: A framework to convert a MT-BFT SMR protocol with ğ›¾â€²
optimal synchronous safety ğ›½ğ‘  = ğ‘› âˆ’ ğ›¾â€²
ğ‘  âˆ’ 1.
ğ‘  synchronous liveness into a MT-BFT SMR protoocl with
C(ğµğ‘˜) by ğ‘¡1. Therefore, no honest replicas commit any other block
ğµâ€²
of height ğ‘˜ after that.
ğ‘˜
6 RELATED WORKS
Byzantine fault-tolerance is a forty-year-old research field in dis-
tributed computing and cryptography. Starting from the celebrated
work of Lemport et al. [34, 44], it has been studied mostly in a
single timing model with one fault threshold. The synchronous
model has been mainly the target of theoretical research, assuming
perfectly synchronized rounds across all parties [1, 20, 23, 30]. Only
recently, following the introduction of Bitcoin, a.k.a., Nakamoto
Consensus [40], which is perhaps the first practical synchronous
protocol, a couple of works have presented synchronous BFT proto-
cols under the non-lockstep model towards practical use [2, 4, 46].
Yet, it seems there remains strong reluctance in the community
to rely on synchrony due to concerns for more severe network
failures. Classic studies of practical BFT have mainly focused on
the partially synchronous protocols favoring their ease of design
and asynchronous safety. Numerous works studied improvements
over PBFT [25, 31, 47]. Other works assume the fully asynchronous
model [3, 21, 26, 36, 38]. However, these protocols tolerate only
ğ‘“ < ğ‘›/3 faults even when the network is under synchrony. Our pri-
mary motivation is to resolve this long-standing dilemma between
the timing assumption and fault tolerance.
Weakly synchronous model. Some recent works have consid-
ered an intermediate model between the synchronous and asyn-
chronous models. Guo et al. [27] introduced the weakly synchronous
model, where a majority of the participants are honest and syn-
chronous, but the remaining minority may be Byzantine or suffer
from a network failure. They presented a Byzantine agreement
protocol in this setting and some other works applying it to BFT
SMR protocols [2, 4, 15]. However, these works still break down if
a majority of the participants experience asynchrony. In contrast,
our protocols are safe against one-third faults even under complete
asynchrony.
Multiple fault thresholds. There have been previous works that
consider different thresholds for different correctness properties in
a single timing model. UpRight [18] is a BFT SMR protocol allowing
different thresholds for safety and liveness in the partially synchro-