18988 dhclient
18988 dhclient
18988 dhclient
18988 dhclient
18988 dhclient
18988 dhclient
18988 dhclient
18988 dhclient
FD T
FLAGS CAPABILITIES PRO NAME
0 v rw-------
1 v rw-------
2 v rw-------
3 s rw-------
5 s rw-------
6 p rw-------
7 v -w-------
8 v rw-------
9 s rw-------
/dev/null
/dev/null
/dev/null
- -
- -
- -
- UDD /var/run/logpriv
- ?
- -
- -
- -
- IP? 0.0.0.0:0 0.0.0.0:0
-
/var/db/dhclient.leas
/dev/bpf
Figure 10: Capabilities held by dhclient before Capsicum changes: several unnecessary rights are present.
olution, addressing both ﬁle system and network address
namespace concerns. Despite these limitations, this ex-
ample of capability mode and capability APIs shows that
even minor code changes can lead to dramatic security
improvements, especially for a critical application with a
long history of security problems.
4.2 dhclient
FreeBSD ships the OpenBSD DHCP client, which in-
cludes privilege separation support. On BSD systems,
the DHCP client must run with privilege to open BPF
descriptors, create raw sockets, and conﬁgure network
interfaces. This creates an appealing target for attackers:
network code exposed to a complex packet format while
running with root privilege. The DHCP client is afforded
only weak tools to constrain operation: it starts as the
root user, opens the resources its unprivileged compo-
nent will require (raw socket, BPF descriptor, lease con-
ﬁguration ﬁle), forks a process to continue privileged ac-
tivities (such as network conﬁguration), and then con-
ﬁnes the parent process using chroot and the setuid
family of system calls. Despite hardening of the BPF
ioctl interface to prevent reattachment to another in-
terface or reprogramming the ﬁlter, this conﬁnement is
weak; chroot limits only ﬁle system access, and switch-
ing credentials offers poor protection against weak or in-
correctly conﬁgured DAC protections on the sysctl and
PID namespaces.
Through a similar two-line change to that in tcpdump,
we can reinforce (or, through a larger change, replace)
existing sandboxing with capability mode. This instantly
denies access to the previously exposed global names-
paces, while permitting continued use of held ﬁle de-
scriptors. As there has been no explicit ﬂush of address
space, memory, or ﬁle descriptors, it is important to ana-
lyze what capabilities have been leaked into the sandbox,
the key limitation to this approach. Figure 10 shows a
procstat -fC analysis of the ﬁle descriptor array.
The existing dhclient code has done an effective job
at eliminating directory access, but continues to allow the
sandbox direct rights to submit arbitrary log messages to
syslogd, modify the lease database, and a raw socket on
which a broad variety of operations could be performed.
The last of these is of particular interest due to ioctl;
although dhclient has given up system privilege, many
network socket ioctls are deﬁned, allowing access to
system information. These are blocked in Capsicum’s
capability mode.
It is easy to imagine extending existing privilege sep-
aration in dhclient to use the Capsicum capability fa-
cility to further constrain ﬁle descriptors inherited in the
sandbox environment, for example, by limiting use of
the IP raw socket to send and recv, disallowing ioctl.
Use of the libcapsicum API would require more sig-
niﬁcant code changes, but as dhclient already adopts a
message passing structure to communicate with its com-
ponents, it would be relatively straight forward, offer-
ing better protection against capability and memory leak-
age. Further migration to message passing would pre-
vent arbitrary log messages or direct unformatted writes
to dhclient.leases.em by constraining syntax.
gzip
4.3
The gzip command line tool presents an interesting tar-
get for conversion for several reasons:
it implements
risky compression/decompression routines that have suf-
fered past vulnerabilities, it contains no existing com-
partmentalisation, and it executes with ambient user
(rather than system) privileges. Historic UNIX sandbox-
ing techniques, such as chroot and ephemeral UIDs are
a poor match because of their privilege requirement, but
also because (unlike with dhclient), there’s no expecta-
tion that a single sandbox exist—many gzip sessions
can run independently for many different users, and there
can be no assumption that placing them in the same sand-
box provides the desired security properties.
The ﬁrst step is to identify natural fault lines in the ap-
plication: for example, code that requires ambient priv-
ilege (due to opening ﬁles or building network connec-
tions), and code that performs more risky activities, such
as parsing data and managing buffers. In gzip, this split
is immediately obvious:
the main run loop of the ap-
plication processes command line arguments, identiﬁes
streams and objects to perform processing on and send
results to, and then feeds them to compress routines that
accept input and output ﬁle descriptors. This suggests a
partitioning in which pairs of descriptors are submitted to
a sandbox for processing after the ambient privilege pro-
cess opens them and performs initial header handling.
We modiﬁed gzip to use libcapsicum, intercept-
ing three core functions and optionally proxying them
using RPCs to a sandbox based on policy queried from
libcapsicum, as shown in Figure 11. Each RPC passes
two capabilities, for input and output, to the sandbox, as
well as miscellaneous ﬁelds such as returned size, orig-
inal ﬁlename, and modiﬁcation time. By limiting capa-
bility rights to a combination of CAP READ, CAP WRITE,
and CAP SEEK, a tightly constrained sandbox is created,
preventing access to any other ﬁles in the ﬁle system, or
other globally named resources, in the event a vulnera-
bility in compression code is exploited.
These changes add 409 lines (about 16%) to the size of
the gzip source code, largely to marshal and un-marshal
RPCs. In adapting gzip, we were initially surprised to
see a performance improvement; investigation of this un-
likely result revealed that we had failed to propagate the
Function
gz compress
gz uncompress
unbzip2
RPC
PROXIED GZ COMPRESS
PROXIED GZ UNCOMPRESS
PROXIED UNBZIP2
Description
zlib-based compression
zlib-based decompression
bzip2-based decompression
Figure 11: Three gzip functions are proxied via RPC to the sandbox
compression level (a global variable) into the sandbox,
leading to the incorrect algorithm selection. This serves
as reminder that code not originally written for decompo-
sition requires careful analysis. Oversights such as this
one are not caught by the compiler: the variable was cor-
rectly deﬁned in both processes, but never propagated.
Compartmentalisation of gzip raises an important de-
sign question when working with capability mode: the
changes were small, but non-trivial:
is there a better
way to apply sandboxing to applications most frequently
used in pipelines? Seaborn has suggested one possi-
bility: a Principle of Least Authority Shell (PLASH),
in which the shell runs with ambient privilege and
pipeline components are placed in sandboxes by the
shell [21]. We have begun to explore this approach on
Capsicum, but observe that the design tension exists here
as well: gzip’s non-pipeline mode performs a number of
application-speciﬁc operations requiring ambient privi-
lege, and logic like this may be equally (if not more)
awkward if placed in the shell. On the other hand, when
operating purely in a pipeline, the PLASH approach of-
fers the possibility of near-zero application modiﬁcation.
Another area we are exploring is library self-
compartmentalisation. With this approach, library code
sandboxes portions of itself transparently to the host ap-
plication. This approach motivated a number of our de-
sign choices, especially as relates to the process model:
masking SIGCHLD delivery to the parent when using pro-
cess descriptors allows libraries to avoid disturbing ap-
plication state. This approach would allow video codec
libraries to sandbox portions of themselves while exe-
cuting in an unmodiﬁed web browser. However, library
APIs are often not crafted for sandbox-friendliness: one
reason we placed separation in gzip rather than libz is
that gzip provided internal APIs based on ﬁle descrip-
tors, whereas libz provided APIs based on buffers. For-
warding capabilities offers full UNIX I/O performance,
whereas the cost of performing RPCs to transfer buffers
between processes scales with ﬁle size. Likewise, his-
toric vulnerabilities in libjpeg have largely centred on
callbacks to applications rather than existing in isolation
in the library; such callback interfaces require signiﬁcant
changes to run in an RPC environment.
4.4 Chromium
Google’s Chromium web browser uses a multi-process
architecture similar to a Capsicum logical application to
improve robustness [18]. In this model, each tab is as-
sociated with a renderer process that performs the risky
and complex task of rendering page contents through
page parsing, image rendering, and JavaScript execution.
More recent work on Chromium has integrated sandbox-
ing techniques to improve resilience to malicious attacks
rather than occasional instability; this has been done in
various ways on different supported operating systems,
as we will discuss in detail in Section 5.
The FreeBSD port of Chromium did not include sand-
boxing, and the sandboxing facilities provided as part of
the similar Linux and Mac OS X ports bear little resem-
blance to Capsicum. However, the existing compartmen-
talisation meant that several critical tasks had already
been performed:
• Chromium assumes that processes can be converted
into sandboxes that limit new object access
• Certain services were already forwarded to render-
ers, such as font loading via passed ﬁle descriptors
• Shared memory is used to transfer output between
renderers and the web browser
• Chromium contains RPC marshalling and passing
code in all the required places
The only signiﬁcant Capsicum change to the FreeBSD
port of Chromium was to switch from System V shared
memory (permitted in Linux sandboxes) to the POSIX
shared memory code used in the Mac OS X port
(capability-oriented and permitted in Capsicum’s capa-
bility mode). Approximately 100 additional lines of code
were required to introduce calls to lc limitfd to limit
access to ﬁle descriptors inherited by and passed to sand-
box processes, such as Chromium data pak ﬁles, stdio,
and /dev/random, font ﬁles, and to call cap enter.
This compares favourably with the 4.3 million lines of
code in the Chromium source tree, but would not have
been possible without existing sandbox support in the de-
sign. We believe it should be possible, without a signif-
icantly larger number of lines of code, to explore using
the libcapsicum API directly.
Operating system
Windows
Linux
Mac OS X
Linux
Linux
FreeBSD
Model
ACLs
chroot
Seatbelt
SELinux
seccomp
Capsicum
Line count
22,350
605
560
200
11,301
100
Description
Windows ACLs and SIDs
setuid root helper sandboxes renderer
Path-based MAC sandbox
Restricted sandbox type enforcement domain
seccomp and userspace syscall wrapper
Capsicum sandboxing using cap enter
Figure 12: Sandboxing mechanisms employed by Chromium.
5 Comparison of sandboxing technologies
We now compare Capsicum to existing sandbox mecha-
nisms. Chromium provides an ideal context for this com-
parison, as it employs six sandboxing technologies (see
Figure 12). Of these, the two are DAC-based, two MAC-
based and two capability-based.
5.1 Windows ACLs and SIDs
On Windows, Chromium uses DAC to create sand-
boxes [18]. The unsuitability of inter-user protections for
the intra-user context is demonstrated well:
the model
is both incomplete and unwieldy. Chromium uses Ac-
cess Control Lists (ACLs) and Security Identiﬁers (SIDs)
to sandbox renderers on Windows. Chromium creates a
modiﬁed, reduced privilege, SID, which does not appear
in the ACL of any object in the system, in effect running
the renderer as an anonymous user.
However, objects which do not support ACLs are not
protected by the sandbox. In some cases, additional pre-
cautions can be used, such as an alternate, invisible desk-
top to protect the user’s GUI environment. However, un-
protected objects include FAT ﬁlesystems on USB sticks
and TCP/IP sockets: a sandbox cannot read user ﬁles di-
rectly, but it may be able to communicate with any server
on the Internet or use a conﬁgured VPN! USB sticks
present a signiﬁcant concern, as they are frequently used
for ﬁle sharing, backup, and protection from malware.
Many legitimate system calls are also denied to the
sandboxed process. These calls are forwarded by the
sandbox to a trusted process responsible for ﬁltering and
serving them. This forwarding comprises most of the
22,000 lines of code in the Windows sandbox module.
5.2 Linux chroot
Chromium’s suid sandbox on Linux also attempts to
create a privilege-free sandbox using legacy OS access
control; the result is similarly porous, with the additional
risk that OS privilege is required to create a sandbox.
In this model, access to the ﬁlesystem is limited to a
directory via chroot: the directory becomes the sand-
box’s virtual root directory. Access to other namespaces,
including System V shared memory (where the user’s
X window server can be contacted) and network access,
is unconstrained, and great care must be taken to avoid
leaking resources when entering the sandbox.
Furthermore, initiating chroot requires a setuid bi-