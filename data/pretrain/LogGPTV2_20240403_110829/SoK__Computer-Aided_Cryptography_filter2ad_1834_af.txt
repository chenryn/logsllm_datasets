### Access Pattern Leakage
**Leakage Model:** The leakage model for access pattern leakage includes the memory addresses accessed during program execution. This type of leakage can reveal sensitive information about the data being processed, such as the structure or content of the data.

### Variable-Time Operation Leakage
**Leakage Model:** The leakage model for variable-time operation leakage includes inputs to operations that vary in execution time based on the input values. Examples include floating-point operations, division, and modulus operations on certain architectures. These operations are classified according to timing-equivalent ranges, which can be exploited by attackers to infer sensitive information.

### C. Discussion

#### Achievements
- **Automatic Verification of Constant-Time Code:** Several tools have been developed to automatically verify constant-time code, both at high-level and low-level code. These tools have been applied to real-world libraries. For instance:
  - **Vale [103]:** Used to verify portions of the assembly code in OpenSSL.
  - **Jasmin [102]:** Verified high-speed implementations of SHA-3 and TLS 1.3 ciphersuites.
  - **FlowTracker [137]:** Analyzed various off-the-shelf libraries.

#### Takeaway
- **Target Level Importance:** The choice of the target level (e.g., C code, LLVM assembly, or machine code) is crucial for obtaining a faithful correspondence with the executable program under an attacker's scrutiny. Analysis should be performed as close as possible to the executed machine code. Mainstream compilers like GCC and Clang can optimize away defensive code and introduce new side-channels, which can interfere with countermeasures deployed and verified at the source level.

#### Challenges
1. **Secure, Constant-Time Preserving Compilation:**
   - **Issue:** Mainstream compilers can interfere with side-channel countermeasures, leading many cryptography engineers to implement cryptographic routines directly in assembly, sacrificing the benefits of high-level languages.
   - **Solution:** Secure compilers that carry source-level countermeasures down to machine code. For example, Barthe et al. [150] laid the theoretical foundations for constant-time preserving compilation, and these ideas were realized in the verified CompCert C compiler [157]. However, CompCert-generated assembly code is not as efficient as that generated by GCC and Clang, which in turn lags behind hand-optimized assembly.

2. **Protecting Against Micro-Architectural Attacks:**
   - **Issue:** The constant-time policy is designed for a simple hardware model, but modern microarchitectural features like speculative and out-of-order execution can be exploited for devastating side-channel attacks, as seen in Spectre [148] and Meltdown [149].
   - **Challenge:** Develop notions of constant-time security and associated verification methods that account for microarchitectural features.

3. **Rethinking the Hardware-Software Contract:**
   - **Issue:** Current Instruction Set Architectures (ISAs) do not capture hardware features that affect the temporal behavior of programs, making it difficult to carry side-channel countermeasures from software to hardware.
   - **Solution:** New ISA designs that expose the temporal behaviors of hardware, allowing for better reasoning about them in software. This poses challenging and competing requirements for hardware architects but can lead to a sound, formal treatment of micro-architectural attacks.

### D. Further Reading
Due to space constraints, we omitted several relevant works, including those on verifying side-channel resistance in hardware [161]–[165] and verifying masked implementations aimed at protecting against differential power analysis attacks [166]–[171].

### V. CASE STUDY I: CONSOLIDATING GUARANTEES

This case study focuses on unifying approaches that combine specific guarantees: design-level security, functional correctness, efficiency, and side-channel resistance. This is a crucial step towards achieving comprehensive, computer-aided cryptographic guarantees.

#### Table VI: Verified Cryptographic Implementations and Their Formal Guarantees
| Implementation(s) | Target(s) | Tool(s) Used | Computational Security | Functional Correctness | Efficiency | Side-Channel Resistance |
|-------------------|-----------|--------------|------------------------|------------------------|------------|-------------------------|
| [172] C           | RSA-OEAP  | EasyCrypt, Frama-C, CompCert | Partially Verified | Target-Level | Comparable to C ref | Target-Level |
| [114] asm         | Curve25519 scalar mult. loop | Coq, SMT | Not Verified | Source-Level | Comparable to asm ref | Source-Level |
| [131] asm         | SHA-1, SHA-2, HMAC, RSA | Dafny, BoogieX86 | Not Verified | Target-Level | Comparable to C ref | Target-Level |
| [173] C           | HMAC-SHA-2 | FCF, VST, CompCert | Not Verified | Source-Level | Slower than C ref | Source-Level |
| [174] C           | MEE-CBC | F∗, Sage | Not Verified | Source-Level | Comparable to C ref | Source-Level |
| [175] Java, C     | Salsa20, AES, ZUC, FFS, ECDSA, SHA-3 | Jasmin | Not Verified | Target-Level | Comparable to C ref | Target-Level |
| [176] OCaml       | Curve25519 | F∗, Vale | Not Verified | Source-Level | Comparable to C ref | Source-Level |
| [102] asm         | SHA-2, Poly1305, AES-CBC | Fiat Crypto | Not Verified | Target-Level | Comparable to asm ref | Target-Level |
| [103] asm         | HMAC-DRBG | CryptoLine | Not Verified | Target-Level | Comparable to asm ref | Target-Level |
| [177] C           | HACL∗1 | F∗ | Partially Verified | Source-Level | Comparable to C ref | Source-Level |
| [5] C             | HACL∗1 | F∗, Vale | Partially Verified | Source-Level | Comparable to C ref | Source-Level |
| [178] C           | HMAC-DRBG | F∗ | Not Verified | Source-Level | Comparable to C ref | Source-Level |
| [69] asm          | SHA-3 | EasyCrypt, Jasmin | Veriﬁed | Target-Level | Comparable to asm ref | Target-Level |
| [117] asm         | ChaCha20, Poly1305 | EasyCrypt, Why3 | Not Verified | Target-Level | Comparable to asm ref | Target-Level |
| [179] OCaml       | BGW multi-party computation protocol | F∗ | Not Verified | Source-Level | Comparable to C ref | Source-Level |
| WHACL∗1, LibSignal∗, EverCrypt2, EverCrypt3 | Curve25519, P-256, Poly1305, AES-GCM, Bignum code4 | F∗, Vale, Cryptol, SAW | Not Verified | Source-Level | Comparable to C ref | Source-Level |

#### Takeaways
- **Grand Slam of Guarantees:** Existing tools can achieve the "grand slam" of guarantees for complex cryptographic primitives, including computational security, functional correctness, efficiency, and side-channel resistance. Almeida et al. [69] formally verified an efficient implementation of the sponge construction from the SHA-3 standard, connecting proofs of random oracle (RO) indifferentiability, functional correctness, and side-channel resistance.
- **Integration for Strong and Intuitive Guarantees:** Interpreting verification results that cover multiple requirements can be challenging. Almeida et al. [174] provide a modular methodology to connect different verification efforts, simplifying their interpretation.
- **Broad Scope and Efficiency:** Many implementations target either C or assembly, involving trade-offs between portability and verification effort. EverCrypt [7] targets both, combining the advantages of each and covering a broad scope of algorithms.

### VI. CASE STUDY II: LESSONS LEARNED FROM TLS

The Transport Layer Security (TLS) protocol is widely used to establish secure channels on the Internet. Before TLS version 1.3, the protocol's design phases did not involve substantial academic analysis, resulting in an endless cycle of attacks and patches. The proactive design process of TLS 1.3 involved active consultation with the academic community, leading to more robust and secure protocols.

#### Lessons Learned
- **Formal Specification and Verification:** The process of formally specifying and verifying a protocol can reveal flaws. Efforts in verifying TLS 1.3 [1], [3] and using tools to analyze symbolic [2]–[4] and computational [3] models of TLS have shown the importance of this process.

By addressing these challenges and integrating the lessons learned, we can move closer to the goal of delivering strong, elegant, and comprehensive guarantees for cryptographic implementations.