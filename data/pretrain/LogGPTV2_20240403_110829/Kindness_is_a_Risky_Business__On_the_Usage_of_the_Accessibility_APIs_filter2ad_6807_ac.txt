events. The assistive app extracts the event properties (like
6DS#1 for short. Similarly, we have DS#2 and DS#3.
EventType, ClassName, PackageName) and further judges
what happens in the foreground. However, the information
contained in the events cannot provide a strong guarantee to
the integrity of event processing. The current design cannot
guarantee that two events with the same properties are deﬁ-
nitely generated by the same view, i.e., uniqueness guarantee.
In the accessibility framework, the event receivers (assistive
apps) do not communicate with the event senders (topmost
app) directly. Such a design ensures the centralized manage-
ment and efﬁcient event dispatching. On the other hand, the
integrity of event processing ﬂow only relies on the checkings
implemented by the assistive apps themselves. The unreliable
provenance information may confuse the checkings.
Design Shortcoming #3. Android allows zero-permission
apps to inject custom AccessibilityEvents into the sys-
tem. This function is provided to developers to make their
custom view components accessible [12]. However, there
is no restriction on how to set the properties of a custom
AccessibilityEvent, which brings the possibility of con-
structing fraudulent events. Also, though Android OS requires
the AccessibilityEvent only could be sent by the topmost
view in the view tree [3], this restriction is not enforced.
Any app could implement the following code to construct
and inject a custom AccessibilityEvent:
1 AccessibilityManager manager = (
AccessibilityManager ) getSystemService
( ACCESSIBILITY_SERVICE );
2 AccessibilityEvent event =
AccessibilityEvent . obtain ();
3
4 event . setEventType (. . .);
5 event . setClassName (. . .);
6 event . setSource (...) ;
7 event . setParcelableData (...) ;
8 . . . // Other properties are omitted
9
10 manager . sendAccessibilityEvent ( event );
Listing 3: Inject custom AccessibilityEvent.
6 Attack Case Studies
In this section, we discuss how to exploit the discovered
design shortcomings to launch real-world attacks. Speciﬁ-
cally, we present installation hijacking and notiﬁcation phish-
ing as showcases. The attack demos are available at https:
//sites.google.com/site/droidaccessibility/.
6.1 Case Study: Installation Hijacking
In this case, a malicious app without sensitive permission
could hijack the execution logic of assistive apps to install
arbitrary apps silently.
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 267Table 1: Bypassed permissions through the accessibility APIs.
Usage
Obtain notiﬁcation
Kill processes
Execute auto-actions
Auto-ﬁll text
Detect the foreground app
Install / Uninstall apps
Bypassed Permission
BIND_NOTIFICATION_LISTENER_SERVICE†
FORCE_STOP_PACKAGES
INJECT_EVENTS
BIND_AUTOFILL_SERVICE†
REAL_GET_TASKS
INSTALL_PACKAGES
DELETE_PACKAGES
Protection Level
Signature
Not for third-party apps
Not for third-party apps
Signature
Not for third-party apps
Not for third-party apps
Not for third-party apps
†: The corresponding service must be protected by this permission to ensure that only the system can bind to it.
The popularity of Android is primarily due to a wide vari-
ety of apps provided by Google Play – the ofﬁcial Android
app store. However, due to the policy restriction, the Google
service framework (including Google Play) is not available in
some countries. Also, some apps on Google Play are region-
locked. Therefore, third-party app stores (store app for short)
become an alternative choice, such as 1Mobile [1], Amazon
Appstore [6], and APKPure [8].
In Android, the INSTALL_PACKAGES permission is designed
to prevent the apps from unknown sources to be installed
silently. Also, it is a system-level permission and not avail-
able for third-party apps. As a result, third-party store apps
have to work as APK downloaders and ask the user to click
the “INSTALL” button of the Installer by themselves, as shown
in Figure 7(a). However, with the accessibility APIs, store
apps can achieve the automatic installation by clicking the
“INSTALL” button programmatically, which saves user clicks
and bypasses the INSTALL_PACKAGES permissions. Such im-
plementation improves the user experience but disobeys the
mission of the accessibility APIs [DS#1].
Logic Analysis. Here we describe the logic implementation
of the automated installation of store apps, as illustrated in
Figure 7(c). After the target APK ﬁle has been downloaded
to the device, the store app utilizes the Intent mechanism [13]
to load this APK ﬁle. Then Android OS will invoke a proper
program (i.e., PackageInstaller [16] in this case) to process it.
After that, the Installer requests the user to conﬁrm the instal-
lation and required permissions. Note that, during this process,
the store app continuously monitors the change of foreground
UI through ﬁltering AccessibilityEvents. When it ﬁnds
that the PackageInstaller is launched to process the APK ﬁle
just downloaded, it will invoke the accessibility service to
click the "INSTALL" button automatically.
However, we ﬁnd that, before deciding whether to click
the "INSTALL" button, the checking logic (Step 3(cid:13) in Fig-
ure 7(c)) of the store app is vulnerable. This step checks four
parameters of incoming AccessibilityEvents:
1. SourceNode != null? (If null, the store app cannot re-
trieve the window content, locate the "INSTALL" button,
and execute the clicking action.)
2. EventType == TYPE_WINDOW_CONTENT_CHANGED?
(This type of events is usually triggered by adding or
removing views.)
3. PackageName == com.android.packageinstaller?
(This ensures that the app running in the foreground is
the PackageInstaller.)
4. Text is the name of the downloaded app (e.g.,
“WhatsApp” in Figure 7(a))? (This ensures that the app
being installed is the one just downloaded.)
If all four conditions pass, the store app will believe the Pack-
ageInstaller is processing the downloaded APK ﬁle [DS#2].
Unfortunately, this AccessibilityEvent-based checking is
not complete, and a malicious app installed on the same phone
can construct a scenario passing the checking conditions to
hijack the work-ﬂow of store apps.
Attack. In this attack, the malicious app only declares the
READ_EXTERNAL_STORAGE permission, a very common per-
mission. Its payload contains a repackaged Trojan APK ﬁle
disguised as a popular app, like WhatsApp. This Trojan app
can execute various malicious operations with many danger-
ous permissions, like Figure 7(b).
First, the malicious app running in the background monitors
the download folder of the victim store app. In general, since
the downloaded APK ﬁles are not sensitive data, this folder is
usually located in the public storage of the device [19]. There-
fore, any app with the READ_EXTERNAL_STORAGE permission
could access it. Note that, if the store app keeps the down-
loaded APK ﬁles in its private folder, the malicious app will
not be able to monitor the ﬁle downloading status and further
launch the hijacking attack. (Un)fortunately, using the public
storage for saving temporary data is a widespread operation
in Android apps [34, 40], including at least 11 popular store
apps as listed in Table 2.
During the monitoring, if a new cache ﬁle appears in
this folder, it means the store app starts to download a new
APK ﬁle. The code implementation could be based on the
Runnable interface [18] for periodic ﬁle existing checking.
Through identifying the name of the cache ﬁle, the malicious
app could know what app is being downloaded because the ﬁle
268          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Association(a) Installer - WhatsApp
(b) Installer - Trojan
(c) Attack overview
Figure 7: Installation hijacking attack.
name is usually the hash value (MD5 or SHA-1) of the being
downloaded APK ﬁle or contains the package name. Taking
APKPure as an example, the default path for saving APK ﬁles
is /Download on the external storage, and the format of the
cache ﬁle name is WhatsApp_Messenger_[xxx].apk.tmp,
e.g., WhatsApp_Messenger_2a1417b0.apk.tmp.
Next, if the malicious app ﬁnds the store app is down-
loading the target app (i.e., WhatsApp in our case), the
hijacking attack will be launched. When the download-
ing completes (WhatsApp_Messenger_[xxx].apk.tmp be-
comes WhatsApp_Messenger_[xxx].apk), the malicious
app utilizes the same Intent mechanism as the store app to load
its Trojan APK ﬁle immediately, as shown in Figure 7(b). The
PackageInstaller pointing to the Trojan APK ﬁle (Installer-A)
will happen to cover the PackageInstaller pointing to the down-
loaded APK ﬁle (Installer-B), as illustrated in Figure 7(c).
Note that, this step creates a race condition (Installer-A vs.
Installer-B), and the attack may fail if the Intent from the
malicious app is not processed by the OS at the right time.
In practice, the success rate of attacks could be signiﬁcantly
improved through adjusting the point in time of launching
Installer-A. For example, on Motorola Moto G3 (the device
used in our attack demo), when the downloading completes,
the malicious app will wait 400ms before launching Installer-
A. Following this trail, in experiments, we achieved nearly
100% success rate (Installer-A covering Installer-B). Also,
it is an empirical time value and may be different on other
devices with varying computing performance.
At this moment, the AccessibilityEvent from the
Installer-A is almost the same as the one from Installer-B,
which meets all four conditions listed previously. As a result,
the store app will be deceived into thinking the Installer-A is
processing the APK ﬁle it just downloaded, so it decides to
click the "INSTALL" button. Finally, the repackaged Trojan
app prepared by the attacker is installed on the phone.
Summary. The checking logic of store apps entirely de-
pend on the information contained in AccessibilityEvents.
Table 2: Vulnerable third-party app stores.
Store
APKPure
1Mobile Market
360 Mobile Assistant
Baidu Mobile Assistant
Sogou Mobile Assistant
MoboMarket
PP Assistant
AppChina
Lenovo Le Store
2345 Mobile Assistant
Wandoujia
Version
Package Name
com.apkpure.aegon
2.12.2
me.onemobile.android
6.8.0.1
com.qihoo.appstore
7.1.90
com.baidu.appsearch
8.5.1
com.sogou.androidtool
6.7.2
com.baidu.androidstore 4.1.9.6222
com.pp.assistant
6.0.8
com.yingyonghui.market
2.1.62716
com.lenovo.leos.appstore 9.8.0.88
com.market2345
5.6
com.wandoujia.phoenix2
5.74.21
However, the veriﬁed factors cannot guarantee which APK
ﬁle is being processed, which results in the possibility of
creating a race condition.
Scope of Attacks. We checked popular third-party store
apps and found at least 11 of them (with tens of millions
of users [23, 24]) suffer from the security risk of installation
hijacking, as listed in Table 2.
6.2 Case Study: Notiﬁcation Phishing
In this case, a zero-permission malicious app could exploit the
execution logic of assistive apps to send phishing notiﬁcations
to users. Also, this attack is different from the direct notiﬁca-
tion abuse attack [47]. Even the attack app has been blocked
for sending system notiﬁcations, this attack still works.
Here we consider the apps with the function of notiﬁcation
management, such as status bar app. On Android, the system
default status bar could be replaced by third-party status bar
apps for a better experience. They could provide several ad-
vanced features, like replaceable theme styles, customized
fonts, spams ﬁltering, and so forth. On Google Play, there
are several popular status bar apps with over one million in-
2018/8/7install_attack - 副本.svgfile:///E:/Dropbox/Projects/[Under%20Review]%20AccessibilityService/pic/install_attack%20-%20%E5%89%AF%E6%9C%AC.svg1/1AccessibilityManagerServiceAndroid OSSystem ServiceAccessibilityServiceThird-party Market AppInstaller(pointing to the downloaded APK file)Event CheckingDiscardPass③①②④Installer(pointing to a malicious APK file)AccessibilityEventsFail③USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 269and inject a custom AccessibilityEvent with the following
properties [DS#3]:
1. EventType = TYPE_NOTIFICATION_STATE_CHANGED.
2. ClassName = android.app.Notification.
3. PackageName = com.hangseng.rbmobile, notiﬁcation
sender, a bank app.
4. SourceNode = null, there is no source for the type of
TYPE_NOTIFICATION_STATE_CHANGED [DS#2].
5. ParcelableData is set as a Notification [14] in-
stance which contains the phishing message and an In-
tent pointing to a phishing Activity (prepared by the
malicious app) disguised as the bank app.
When Super Status Bar receives the custom (phishing)
AccessibilityEvent, it will think the bank app just posts a
new notiﬁcation to the system. Then it parses the properties
of this event and displays the phishing notiﬁcation in its status
bar, like Figure 8(b). After the user notices this new notiﬁca-
tion and clicks it, the status bar app will load the contained
Intent. Finally, the phishing Activity is launched and induces
the user to ﬁll her credentials, as shown in Figure 8(c).
Summary. As mentioned in Section §2, different types of ac-
cessibility events may have different properties. To some spe-