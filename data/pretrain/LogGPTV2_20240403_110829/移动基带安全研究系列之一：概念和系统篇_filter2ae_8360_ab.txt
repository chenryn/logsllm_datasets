0x00 – 0x10 partition name (0:FSBL)
0x10 – Partition start block information (0x0f)
0x14 – Partition block length (0x2)
这里定义的每个页是0x800字节，每个块block有64个页，所以每个block的长度是0x20000字节，所以根据这个信息我们就可以定位这些分区的物理偏移信息。
例如FSBL的物理偏移为0x20000*0xf=0x1e0000
AMSS的物理偏移为0x20000*0x16=0x2c0000
### 基带系统内存管理
当基带系统的安全信任启动链验证完成后，最后系统被AMSS系统代码接管，
AMSS系统定义了代码执行的内核特权模式以及AMSS应用模式，设置页表（映射硬件外设地址到页表中）并且开启MMU(内存管理单元)，在某些敏感的内存地址区域通过MPU的特性来进行保护，只有特定权限的应用的可以访问，应用模式的代码想要进入内核态（例如IPC消息发送），可以通过设置的特权中断指令SVC进入内核态，下图就是进入特权syscall的中断向量表入口。
通过初始化页表完成内核地址空间和外设硬件地址映射，开启mmu，创建第一个rootTask后切入用户态空间，初始化用户态需要创建的应用与驱动，这里主要介绍应用层堆内存结构以及内存分配和回收算法。
REX系统堆内存分两种类型：
Big chunk（大堆）
small heap（小堆）
大堆在不同应用初始化的时候指定内存的起始地址与长度，而且根据应用功能的不同，分配方式也不同，小堆将会在大堆上进行分配使用，大堆由于给使用的应用不同，分配小堆的方式有所不同。
  1. 大堆类型1,内存连续，分配小堆的方式是顺序分配，前面是分配好的小堆，后面是连续的空闲堆块，分配小堆只会在连续的空闲块上进行分配，例如前面多个分配好的小堆其中一个需要被释放后，只是把这个小堆的属性标记为freed，但由于它后面的小堆到连续的空闲块中间有标记为已经分配属性，所以后续在分配小堆的过程中不会考虑这块已经被释放的内存，除非要释放的小堆内存和连续的空闲块紧挨着，下一次分配内存时才会从这个已经标记为释放的内存上进行分配，而是直接到后面的连续空闲块上进行分配，这样做的目的是为了分配和释放内存更高效，虽然牺牲了一些空间，结构如下图。
下图是这种chunk上分配小堆的状态信息示例
  2. 大堆类型2,（modem chunk）,也是一个连续内存区域，但是chunk header在内存的底部，上部为分配小堆区域，分配顺序也是从上往下分配，小堆的头部数据结构中会指向上一个已经分配好的小堆，通过单向链表进行小堆内存的回溯，最上面的小堆回溯指针为空，但是它的内存分配算法跟上面的不同，就算要被释放的小堆内存和空闲块不挨着，但是它任能在下一次的堆内存申请中被重用，只要它的大小合适，而且小堆数据结构与类型1也不同，基本结构如下图。
Modem使用大堆结构示例
我们可以看到chunk类型1和chunk类型2上面分配的小堆内存结构稍有不同，数据结构如下：
    Small heap1{
    Uint32 size;//+0 分配内存空间的长度加上头部长度0xc字节
    Uint8  mem_flag;//+0x4 内存属性标志，0表示已分配，0xff表示释放掉的内存
    Uint8  extr_mem_flag;//+0x5 扩展内存属性标志，0表示内存分配过，0xff表示
    //内存空间，没有被使用过
    Uint8  mem_extra_size;//+0x6 额外分配的内存长度，为了内存0x10字节对齐
    //所额外增加的申请内存长度，必须小0x10字节
    Uint8  mem_pad_char;//+0x7 填充字节0xaa
    Uint16 crc16_cookie;//+0x8  对传入的第三个参数的crc16计算的值
    Uint16 mem_id;//0x0a   内存标识,第四个参数传入
    Uint8 mem_buffer[size-0x0c];//+0xc 用户使用内存buffer
    }
    Small modem heap{
      Uint32 size;// +0 分配内存空间的长度加上头部长度0x10字节
      Uint32 *pre_alloc_ptr;//+4 指向上一个分配好的小堆内存头部指针
      Uint8 client_id;//+8 申请内存的应用id值，modem功能中定义了
    //RRC/CM/SM/RLC/gstk/wms等多个应用，这个id来标识申请内
    //存的应用来自于哪里
      Uint8  mem_flag;//+0x9 内存属性标志，0表示分配了，1表示释放了，
    //3表示未使用
      Uint8  unknown_byte;//+0xa
      Uint8  mem_guard_bits;//+0xb modem内存保护标志0x6a
      Uint32  alloc_ret_addr;//+0xc 分配内存函数的下一条指令地址，目的是为了
    //确定执行内存分配行为的精确地址
      Uint8  mem_buf[0xsize-0x10]; //+0x10 供用户使用的内存buffer
    }
### 基带系统文件系统
由于篇幅问题，我会对Qualcomm基带的文件系统EFS单独写一篇详细的分析文章。
### 高通基带芯片定时器（Timer）
定时器是嵌入式芯片非常重要的组成部分，它在嵌入式操作系统的CPU调度和定时任务执行，以及精确的延时等待等操作中扮演着非常重要的角色，高通的基带芯片的定时器调度算法大体都差不太多，我们基于ARM1136架构的MDM6600基带芯片对定时器算法进行了深入分析。
MDM6600的定时器是通过Sleep
Timer控制器来实现的，它包含两个16位的Timer0和Timer1，以及一个32位的TimeTick的计数器(counter)，它们的功能用途如下.
1．Timer0 供watchdog使用
2．Timer1 供3G的wcdma的功能模块使用
3．TimeTick 系统计数器，服务于系统的子任务模块创建的定时器任务的执行以及延时功能的使用
Timer0应用于watchdog功能中，Watchdog在实时嵌入式系统中扮演着非常重要的角色，它监控任务的正常运行，监控的任务必须定时喂狗（feed
dog），watchdog才认为你在正常工作，要不然就可能会直接reset系统，后续也会介绍它在基带里面具体监控的应用。
Timer1将会在3G WCDMA应用中收发相关的定时中断中会详细介绍。
TimeTick是一个32位的系统计数器，初始化后会从0开始计数，计数到0xfffffff后溢出到0后重新开始计数，主要功能如下：
  1. 执行定时任务
  1. 执行一次
  2. 周期性执行
  2. 执行延时功能
  1. 延时等待
TimeTick的时钟源为32768Hz，这意味着这个计数器1秒钟会计数32768次，通过这个信息我们可以大致计算出从0计数到0xffffffff需要36个小时。
定时任务功能特性：
  1. 通过设置TimeTick的match value来决定计数器计数到这个值后产生一个中断，中断里面可以处理相应的定时任务，以及设置新的TimeTick match value。
  2. 所有的定时任务都会存储在定时任务列表中，提供定时任务的插入，删除，暂停，唤醒执行等功能。
下图描绘了定时器任务执行的基本过程
在基带系统中存在多个应用任务，每个任务的执行都是依赖内核的CPU调度，常见的方式就是时间片和优先级切换让各个不同的任务有机会得到执行，而某些任务在运行过程中的某个时机可能会创建一个或者多个定时器任务，例如上图所示的任务Task1创建的定时器任务Timer1，Task2创建的定时器任务Timer2和Timer3，处理这些任务的算法如下：
  1. 创建定时任务时，获取当前TimeTick的计数
  2. 把延时换算法成计数，比如1秒等于32768次计数
  3. 把当前timetick计数加上延时的计数值作为该定时任务中断触发的match value
  4. 遍历所有定时任务，根据任务设置的定时任务中断触发的match value大小排序插入到定时任务列表
  5. 当timetick的计数到达某个定时任务的Match value的时候产生中断，中断处理例程ISR会通过向DPC（Deferred Procedure Calls）发送执行定时任务的消息去执行该定时任务的例程函数，如果只是延时任务就不需要执行了，同时更新timetick的下一次中断产生的match value，并把这个定时任务从定时任务列表中移除
如上图举例：
应用任务 定时任务/MV
|
|  
---|---|---  
Task1
|
Timer1/M1
|  
Task2