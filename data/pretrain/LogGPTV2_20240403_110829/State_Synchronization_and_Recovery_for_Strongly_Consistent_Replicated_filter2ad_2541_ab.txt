by  the application programmer.  Of the three kinds of  state, the 
application-level state is possibly the most visible, and the easi- 
est to identify, retrieve and restore. 
To enable application-specific state to be captured, in  accor- 
dance  with  the  Fault-Tolerant  CORBA  standard,  every  repli- 
cated  CORBA  object  must  inherit  the  OMG-IDL  Check- 
pointable interface, shown in Figure 3. 
This  inherited  IDL  interface  has  two  methods,  get-stateo 
and s e t s t a t e ( ) ,  both of which are intended to be implemented 
by  the application programmer.  The get-stateo method, when 
invoked on a  CORBA  object,  returns  the  current  application- 
level  state of the  object.  The set-state() method  with  specific 
state as its parameter, when  invoked on a CORBA object, over- 
writes the object’s current application-level state with  the value 
of this parameter. 
Because it is not possible to anticipate, or standardize on, the 
format of the application-level state of every application object, 
the application-level state is defined to be of the  CORBA type, 
any.  A  variable of  type any can “hold” any primitive,  struc- 
tured and user-defined  CORBA type. 
For active replication,  recovery of application-level state in- 
volves  the  retrieval  of  the  current  consistent  application-level 
state via  a get-stateo invocation on an existing active replica, 
and  a  transfer  of  the  retrieved  state  via  a  s e t s t a t e ( )  invo- 
cation  on  a  new  or  recovering  replica.  For  passive  replica- 
tion,  application-level  state  is  periodically  retrieved  through  a 
get-stateo invocation on the primary replica, with the returned 
checkpoint either  logged  (cold  passive  replication),  or  trans- 
ferred  to  the  backup  replicas  (warm  passive replication).  The 
263 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:04:13 UTC from IEEE Xplore.  Restrictions apply. 
I/ Generic dejriiriori  (if Iippliciiriiiri-leL.el .wire 
typedef any State; 
I/ E.rceptioiis irswciored  ~ + i / r  crpplic[iriiri-level  sfrite  rriiris/er 
exception NoStateAvailable  {): 
exception InvalidState  { }; 
I/ IDL Itrrerfiice r o  be itrheriwd 1.. ever!  replieured  06ject 
interface Checkpointable 
t 
I1 Rerirrns cippliccirion-le~el mire 
State getstate0 raiscs(NoStateAvailable); 
I/ Arsrjiris rippliciitiott-le~el .clcue 
void set-stnte(in State s) raises(lnvalidStnte): 
1: 
Figure  3: The Checkpointable IDL interface  that  must be 
inherited  by  every CORBA object in  the application  to enable 
the checkpointing and transfer of application-level  state. 
three  phases  of  recovery - state  retrieval  (using get_state()), 
state  transfer,  and  state assignment (using set-state()) - must 
also  occur  in  the  totally-ordered  message  sequence  to  ensure 
replica consistency. 
4.2  ORBPOA-Level State 
Ideally,  ORBs  should  be  viewable  as  “black-boxes’’ that  are 
stateless.  In  reality,  because  the  ORB and  the  Portable Object 
Adapter (POA) handle  all  connection-level and  transport-level 
information  on  behalf  of  a  CORBA  object  that  they  support, 
the ORB and  the  POA  necessarily maintain  some information 
for the object.  The existence  of  ORBIPOA-level  state implies 
that  there  really  are no  “stateless” objects from  the  viewpoint 
of recovery  - a replicated CORBA object with  no application- 
level  state  will  nevertheless  have  ORB/POA-level  state  asso- 
ciated  with  it.  ORBPOA-level  state  is  modified  as the  ORB 
creates objects, establishes connections and processes incoming 
messages. 
The  ORBIPOA-level  state  for  a  CORBA  object  consists of 
the values of various data structures (last-seen request identifier, 
threading policy, etc.) stored by the ORB, at runtime, on behalf 
of the object.  Unfortunately, these “pieces” of ORBPOA-level 
state are not visible at the level of the CORBA object.  The in- 
ternal  ORBPOA-level  state  is  not  standardized, and  thus,  not 
identical  across  ORBs  from  different  vendors. 
Indeed,  such 
standardization  would  be  contrary  to  the  Object  Management 
Group’s philosophy of  standardizing ORB  interfaces, and  not 
their implementations. 
The vendor-specific  form  of  the  ORBPOA-level  state  ren- 
ders it  a source of  non-determinism  if different replicas of  the 
same object  are hosted on different vendors’ ORBs.  Thus, for 
all  practical  purposes and  for the  rest  of  this paper,  a  strongly 
consistent replicated  object has all  of  its  replicas running over 
an ORB from the same ORB vendor. 
When a CORBA object is replicated, each replica has its own 
ORB on a distinct processor.  For active  replication  under nor- 
mal operation, if the object and the ORB are deterministic, both 
the application-level  and the ORBPOA-level state will be auto- 
matically consistent across all replicas at the end of every opera- 
tion.  However, under recovery, consistent state is more difficult 
to achieve.  Even  if the  application-level  state of the recovering 
active replica is synchronized with that of an operational active 
replica, the two replicas (the existing replica and the recovering 
replica) will differ in their respective ORBIPOA-level  states, un- 
less these are also synchronized. 
Similarly,  for  passive  replication,  under  recovery,  consis- 
tent  replication  cannot  be  ensured  through  the  transfer  of 
application-level state  (from  the  old  primary  replica’s  logged 
application-level  checkpoints to the new primary replica) alone; 
unless  they  are  also  synchronized, the  respective  ORBPOA- 
level states of the old and the new primary replicas will differ. 
In  this paper,  we describe how Eternal handles the recovery 
of ,ORB/POA-level state, in particular, GIOP request identifiers 
and information negotiated between the client and the server. 
4.2.1  GIOP Request Identifiers 
CORBA’s General Internet  Inter-ORB  Protocol (GIOP) incor- 
porates the notion of a request identifier, a number that uniquely 
identifies  a request-reply  pair exchanged  between  a client and 
a server over a connection. The client-side ORB generates this 
request-id on a per-connection  basis,  and  inserts  it into the 
standard GIOP header of every outgoing request from the client 
to  the  server over the  connection.  On  its part,  the  server-side 
ORB retrieves  the  request-id,’and inserts  it  into the  GIOP 
header of the corresponding IIOP reply message from the server. 
Typically, the  client-side ORB  increments the  per-connection 
r e q u e s t - i d  as the number of requests sent by the client over 
the connection increases. The reques t - i d  allows the client- 
side ORB to  match  a received  IIOP reply  with  an  outstanding 
IIOP request.  Replies whose reques L i d s  do not  match are 
discarded by the client-side ORB. 
The example  of  Figure 4 demonstrates the  replica inconsis- 
tency  that  ensues  if  ORBPOA-level  state,  such  as  the  r e -  
ques t-id, is not synchronized during recovery. 
Figure 4(a) shows an existing replica of an actively replicated 
client’  object A  that  issues an invocation (say, of method X  of 
object B). This request carries a request-id of 350, assigned 
by  the  client-side ORB hosting  this  replica.  Assume  that  this 
replica receives the response to this 350th invocation, and that a 
new replica of the same object, A, is now launched, and that its 
application-level state (but not  the ORBIPOA-level  state, such 
as the  reques t - i d  stored  by  the ORB) is synchronized with 
that of the existing replica. 
The  last  outgoing  invocation  from  any  existing  replica  of 
‘-1  carried  a  request-id of  350, which  its  client-side ORB 
“remembers.”  Unfortunately,  the  new  replica’s  ORB does not 
“know”  this  current  value  of  the  request-id counter  held 
by  an existing replica’s  ORB. Thus, the new  replica’s ORB as- 
signs an initial value, typically 0, to its equivalent reques t - i d  
counter.  If both  replicas now  dispatch their next  invocation  on 
object B ,  as  shown in  Figure 4(c), the  existing replica’s ORB 
assigns the correct  reques t - i d  of  35 1 to  its  outgoing  invo- 
cation, while the newly-recovered replica’s ORB assigns a r e -  
quest-id of 0 to  its outgoing invocation.  Thus,, although the 
two  invocations are  identical  in  content,  their  reques k i d s  
differ. 
’For  multi-tiered  CORBA  applications,  the  middle-tier  plays  the  roles  of 
both  client  and  server:  replication  of  the  middie-tier  objects  involves  replicat- 
ing both the client-side and the server-side code. 
264 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:04:13 UTC from IEEE Xplore.  Restrictions apply. 
Existing replica 
of obiecr A 
InMruon "I 
method X 
ofohlea B 
1  Etemal's Mechanisms 
1 
~ ~ u ~ c y ; y s t  mmsrge 
Exisring replica 
of objecl A 
kcovenng replica 
of objecr A 
The first of the two invocations to reach B  will be delivered, 
and the other will be discarded as a duplicate.  If the invocation 
delivered  to B has a request-id of 0, B's server-side ORB 
will  insert a request-id of 0 in  its outgoing IIOP reply.  Un- 
fortunately, when  this reply reaches the ORBs hosting the  two 
replicas of A, only the ORB that assigned the request-id of 
0 (which,  in  this  case,  is  the  newly-recovered  replica's  ORB) 
will  deliver the response to its replica.  The ORB that hosts the 
existing replica (and that assigned a request-id of 35 1) will 
detect a mismatch between its expected reques t - i d  (35 1) and 
the received request-id (0). Thus, this ORB will not deliver 
the  otherwise correct reply  to its replica,  which  will  now  wait 
forever for a reply from the server. 
To avoid this, a new replica's ORB must hold the same value 
for request-id counter as that  held  by  ORBs hosting oper- 
ational replicas of  the  same  object.  Otherwise,  the  mismatch 
between  the returned  request-id (from the  server) and  the 
transmitted request-id (from the client) will cause one or the 
other of the client-side ORBs to discard a perfectly  valid  reply 
from the server. 
This request-id information is  buried  within  the  client- 
side ORB, and there are no "hooks"  in today's ORBs to retrieve 
this information. Fortunately, the  reques t - i d  information is 
visible from outside the ORB, in the IIOP request and response 
messages that are sent by the ORB. 
By  parsing every  outgoing IIOP request  message  sent  by  a 
client-side ORB, Eternal can discover, and store, the ORB's cur- 
rent setting for the r e q u e s t i d  for each of the ORB's connec- 
tions. Furthermore, by transferring this stored value for the re- 
quest-id, at the point of recovery, from the Recovery Mech- 
anisms hosting an existing replica to the Recovery Mechanisms 
hosting  a  new  replica,  Eternal  system  ensures  that  the  GIOP 
headers of  all  outgoing IIOP request messages  from both new 
and existing replicas are consistent. 
. 
.................... 
Reluhie multicast mesrrgc lor 
rpplrurllon-l~vcl S t I C  lrmr1cr 
: 
. . . . .  . . . . . . . . .  
Existing rephca 
of object A 
Recownng replica 
of objecr A 
request-id 
ClOP Herder 
Figure  4: Replica  inconsistency  due  to  different  GIOP  r e -  
ques t-ids assigned by  client-side  ORBs hosting  an  existing 
and a recovering replica. In this example, only application-level 
state is being synchronized. 
265 
4.2.2  Client-Server Handshake 
CORBA allows client-side and  server-side ORBs to  exchange 
vendor-specific information with each other.  This does not de- 
tract from CORBA's  interoperability because  vendor X's  ORB 
will  not understand vendor Y's ORB-specific information, and 
can ignore it. 
CORBA's GIOP allows vendor-specific information to propa- 
gate  from the  client to the server through the  Servicecon- 
t e x t  field  of  IIOP request  messages.  The server-side  ORB 
can examine, modify, and return this Servicecontext in its 
replies to the client.  Servicecontexts can be encapsulated 
into every client and server message, but are particularly used in 
the initial "handshake" between the client and the server. 
Vendor-specific shortcuts.  The Servicecontext in- 
formation may enable the client-side ORB and the server- 
side ORB to "recognize"  that they are from the same ven- 
dor,  and  to  use  this  awareness  for more efficiency using 
vendor-specific  shortcuts.  For  example,  client-side  and 
server-side VisiBroker 4.0 ORBs can  initially  negotiate a 
shorter object key  for use,  instead of the  complete object 
key, in subsequent IIOP requests from the client. 
Code set negotiation. A transmission code set is the com- 
monly agreed-upon encoding used  for character and wide- 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:04:13 UTC from IEEE Xplore.  Restrictions apply. 
character  data  transfer  ,between  the  client’s  and  server’s 
ORBs. The client-side ORB can determine a server’s code 
setsfrom the code set component that the server-side ORB 
inserts  into  its  server’s  published  IOR.3 The  client-side 
ORB uses this  information  to choose character and  wide- 
character  transmission code  sets  for  its  subsequent com- 
munication .with the server. Codeset negotiation  is not per- 
formed on a per-request  basis,  but only  when  a client ini- 
tially connects to a server. 
Regardless. of  the  purpose that the  initial  client-server hand- 
shake  serves,  both  the  client-side and  server-side  ORBs store 
the results  of  their  initial  negotiation,  on  a per-connection  ba- 
sis.  This constitutes ORBPOA-level state that  must be appro- 
priately handled during recovery. 
Consider a client A communicating with  a replicated  server 
B with a replica  B1. Assume that .-I and B1  have already com- 
pleted their initial handshake, and that A’s ORB now stores the 
negotiated  information, and  encapsulates it  (e.g.,  in  the  Ser- 
vicecontext field) in every request that it sends to B. When 
a  new  replica  Bz  of  object  B  is  launched, the  client  ’4  does 
not (and indeed, should not, in the interests of replication  trans- 
parency) detect the  addition of  a new  server replica  and, thus, 
will not reenact this negotiation  with B2. 
Unfortunately,  Bz’s server-side ORB, having missed the  ini- 
tial client-server  handshake, is  unable to  interpret  the  already- 
negotiated  information  in  -4’s  requests.  Thus,  -4’s requests, 
when delivered to Bz’s ORB, will be discarded. Thus, although 
Bz’s application-level  state might be recovered,  its ORBPOA- 
level state is not sufficiently restored as to allow it to process A’s 
requests and function normally, as the existing replica B1 does. 
Eternal  restores the  negotiated  ORB/POA-level  state to  the 
ORB of a new  server replica  by  storing the client’s handshake 
message (that initiated the client-server negotiation), and by de- 
livering this message to the new server replica’s ORB ahead of 
any other IIOP request from the client. ,This artificial  injection 
of the client’s handshake message into the new  server replica’s 
ORB  causes  the  server-side  ORB  to  initialize  its  ORBPOA- 