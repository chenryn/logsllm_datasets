                                   }
第二，将TCP报文的实际荷载设置8字节（mss设置为最小值48，TCP选项头设置为40字节，48-40=8）。此步实际情况是不默认，正常情况下是无法协商成功，客户端发起的mss协商，默认情况下服务端将不会认可，默认发行版linux系统都开启TSO（TCP
Segment
Offload）技术，为了尽可能发挥网卡性能，网卡会不断尝试扩大mss的值，当我们将mss协商成功为48时，很快TSO会将mss恢复为1460.所以实际攻击链条在此时已经被打断。
而且在我们测试将服务端发给我们的TCP数据包的TCP选项头设为40，通过要求服务端数据包附带时间戳选项，可以使TCP选项头拥有12字节选项长度，如果需要更长的选项头，需要一些特殊的TCP选项，如md5选项，但TCP的md5选项需要重新编译内核，发行版不带md5选项
在默认情况下我们只做到了通过客户端设置服务端报文12字节长度的TCP选项头长度设置
  * 对服务端发送sack报文，指定特定报文重传。我们在对服务端进行指定字节序列的报文重传时发现，我们无法做到累加重传报文，在漏洞分析中，我们提到，我们需要使重传报文累计到超过65535导致整数溢出，但是实际测试过程中发现，TCP的重传实在过于迅速，我们的发包速度根本不够服务端的gso机制生效累计积累超过65535个报文，我的最大累计此时30余次，服务端收到sack后累积重传报文，收到ack后或其余机制释放累积。请注意下图的报文序号，第27个报文请求指定重传，第28个报文重传指定报文，29个报文立刻发送正确顺序的报文，第27个报文和第29个报文直接的时间实在过于短暂，可以通过并发分布式攻击可以做到重传报文累计超过65535次。
其他尝试：
由于此漏洞的主要瑕疵在于mss协商机制启用非默认，我们曾经尝试绕过linux
kernel的mss协商机制对服务端发起进攻，尝试使用sack报文告诉服务端我们只缺少8字节长度（报文原长48字节情况下），此时服务端回复的报文并没有只给我们8个字节长度的报文，而是把所缺少的报文所属的报文（48字节长度）发回给我们，绕过尝试失败。
最终我们认定此漏洞实际危害不大。
测试代码：
我们使用的是python的scapy库进行伪造客户端与服务端进行通信
Sack部分测试代码：
    from scapy.all import *
    import time
    i=IP()
    i.dst="192.168.124.144"
    t=TCP()
    t.dport=8887
    t.flags="S"
    t.options=[('MSS',18),('SAckOK', '')]
    #sr1(i/t)
    SYNACK=sr1(i/t)
    seq_num=int(SYNACK.seq)
    # ACK
    ACK=TCP( dport=8887, flags='A', seq=SYNACK.ack, ack=SYNACK.seq + 1)
    send(i/ACK)
    print seq_num
    #SACK=TCP(dport=8887,flags='A',seq=SYNACK.ack, ack=SYNACK.seq + 1)
    time.sleep(1)
    SACK=TCP(dport=8887,flags='A',seq=SYNACK.ack , ack=SYNACK.seq + 1+0x30*2)
    #print SACK.seq
    num=3
    SACK.options=[('SAck',(SYNACK.seq+1+0x30*3 ,SYNACK.seq+1+0x30*4 ))]
    send(i/SACK)
    #while num=4.14需要打第二个补丁
https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-001/PATCH_net_1a.patch
（2）禁用SACK处理
echo 0 > /proc/sys/net/ipv4/tcp_sack
（3）使用过滤器来阻止攻击
https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-001/block-low-mss/README.md
此缓解需要禁用TCP探测时有效（即在/etc/sysctl.conf文件中将net.ipv4.tcp_mtu_probingsysctl设置为0）
（4）RedHat用户可以使用以下脚本来检查系统是否存在漏洞
https://access.redhat.com/sites/default/files/cve-2019-11477–2019-06-17-1629.sh
**关于奇安信代码卫士**
“奇安信代码卫士”
是奇安信集团旗下专注于软件源代码安全的产品线，能力涵盖了源代码缺陷检测、源代码合规检测、源代码溯源检测三大方向，分别解决软件开发过程中的安全缺陷和漏洞问题、代码编写的合规性问题、开源代码安全管控问题。“代码卫士”系列产品可支持
Windows、Linux、Android、Apple iOS、IBM AIX 等平台上的源代码安全分析，支持的编程语言涵盖
C、C++、C#、Objective-C、Java、JSP、JavaScript、PHP、Python、Go、区块链智能合约 Solidity
等。目前代码卫士已应用于上百家大型机构，帮助用户构建自身的代码安全保障体系，消减软件代码安全隐患。