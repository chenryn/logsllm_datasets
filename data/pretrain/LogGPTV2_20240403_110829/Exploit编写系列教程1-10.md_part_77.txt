是一种有价值的技术。
然而将栈放在一起来成功调用WinExec()也需要一些ROP，它跟其他绕过DEP的技术不同，
因为我们不是执行自定义shellcode。因此我们不需要改变执行标志或者禁用DEP。我们只
要调用一个windows函数然后用一个指向一系列OS命令作为参数的指针。
http://msdn.microsoft.com/en-us/library/ms687393(VS.85).aspx
第一个参数是指向执行命令的指针，第二个参数指示window行为。一些例子：
●0=隐藏窗口
●1=正常显示
●10=默认显示
●11=强制最小化
为了使它能成功，你将需要加一个返回值到参数上（精确地说第一个参数）。这可能是任意
一个地址，但是需要在那里有点东西。因此，这是栈情况：
●返回地址
●指向命令的指针
●0x00000000（隐藏）
在XP SP3，WinExec在0x7C86250D
看下这个例子：
首先，0x00000000放入EBX（POP 0xFFFFFFFF到ebx，然后INC EBX被调用），然后寄存器
通过一个pushad调用被设置（基本上我把返回地址放入EBP，WinExec()的指针放入ESI，
RET放入EDI）。
上面的命令只在XP机器上的防火墙服务停了才会成功。如果你的PC不是运行windows防火
墙，你不得不去掉“net stop SharedAccess”块。
$evilIP是你的攻击者机器，运行一个包含meterpreter.exe的ftp服务器，用下面的
Metasploit命令来创建：
（将所有的放在一行然后复制文件到FTP服务器的根目录下）
在攻击者机器上，设置一个Metasploit mutihandler监听者：
结果：
（正如你看到的，甚至一个简单的指向WinExec的指针会允许你绕过DEP（所有情况都成
功!）然后给你一个meterpretershell。
基于 SSSSEEEEHHHH--------RRRROOOOPPPP 版本--------WWWWrrrriiiitttteeeePPPPrrrroooocccceeeessssssssMMMMeeeemmmmoooorrrryyyy(((())))
为了示范基于SEH的exploit能转换为一个ROP版本，我将用一个最近发现的漏洞
http://www.corelan.be:8800/index.php/forum/security-advisories/10-050-sygate-personal-firewall-
5-6-build-2808-activex/，Lincoln发现的，目标是在SygatePersonalFirewall5.6中的ActiveX
控件缓冲区溢出。我们能看到在公告中，sshelper.dll中的SetRegString()函数受缓冲区溢出的
影响，会覆盖掉异常处理函数。
你可以在这里得到exploit的拷贝：http://www.exploit-db.com/exploits/13834/
这个函数有5个参数。第三个参数是会产生缓冲区溢出的：
在IE6和IE7中，SEH记录在3348字节后被覆盖。（因此3348字节是对nseh，3352字节是
对seh）
在一个典型的（non-ROP）的exploit中，我们可能用一个短的向前跳转（\xeb\x06\x90\x90）
来覆盖nseh然后用一个指向pop/pop/ret的指针来覆盖seh。正如早些时解释的，这个方法在
DEP启用时不会成功，因为我们在禁用/绕过DEP前不能执行代码。
无论如何，有一种简单的方法来克服这个问题。当异常处理函数（我们已经覆盖的）运行时
，我们只需要转回到栈中。
因此基本上，我们不需要关心nseh（4字节），因此我们将创建一个会在3352字节后覆盖
SEH处理函数小脚本。
我们感兴趣的是当SEH处理函数调用时，我们的缓冲区有多远。因此我们需要用一个无效
指针来覆盖SEH处理函数。在这种类型，只要看我们的缓冲区在哪里，任意一个指令都行，
因为我们只要看当我们跳转到那个指令时，我们的缓冲区有多远。
触发漏洞
我将放一个指向RET的指针到SEH处理函数中（我们将从sshelper.dll取出一个：
0x0644110C），然后加上25000字节（来触发访问违例）。我们的exploit测试脚本目前看起
来是这样的：
保存html文件到C:驱动器并且在InternetExplorer中打开。附加ImmunityDebugger到
iexplore.exe中。允许ActiveX组件运行（你可能不得不点击OK两次）然后让Immunity捕
捉异常。
当你观察SEH链时，你应该确保我们已经用指向RET的指针覆盖SEH处理函数：
如果你得到的SEH链视图跟上面的截屏（2个SEH记录）一样，按ShiftF9一次。那么当
你只看到一个SEH记录时，你因该看到同样的寄存器/栈视图。
在栈视图中滚下来直到你看到你的覆盖过的SEH处理函数：
在0x0644110C处设断然后忽略程序的异常（按ShiftF9）。寄存器现在包含这个：
并且栈顶是这样的：
滚下来直到你看到你的缓冲区的第一部分（A）：
绕栈旋转
因此，我们发现我们的缓冲区在ESP后面（01A6E34C+1032字节）。这意味着，如果我们想
从SEH处理函数返回到我们的缓冲区中，我们不得不用至少1032字节（0x408或者更多）
来旋转回栈中。我的好朋友Lincoln产生他的rop文件并在sshelper.dll中的0x06471613处找
到一个指向ADDESP，46C+RET的指针。
这意味着，如果我们用一个指向ADDESP，46C+RET的指针覆盖掉我们的SEH创建处理
函数，那么会使它回到我们控制的缓冲区并开始我们的rop链。
修改脚本并且用下面的替换“seh=...”这行
在InternetExplorer中打开文件（ImmunityDebugger附加进去），然后让ActiveX组件运行。
当崩溃发生时，观察SEH链并且核查它是否被正确的指针覆盖掉。
在0x06471613处设置断点。忽略程序的异常（如果需要的话两次），直到碰到断点。
在这时，ESP指向01A5E330
然后按F7单步执行指令。当“ADDESP，46C”指令被执行时，检查ESP（和栈顶的内容）：
可怕，这意味着我们要绕栈旋转然后返回到一个我们能初始化rop链的位置。
从这里往前，这个exploit可以像其它的基于rop 的exploit一样打造：
●设置你的策略（这个例子中是WriteProcessMemory()，但是你明显也可以用另一个技术）
●得到你的rop小配件（!Pvefindaddr rop）
●打造链
但是首先，你将需要明白我们要在一连串的A的哪里登录，我们才能在正确的地方开始rop
链。
你将注意到，当你试着定位偏移量时（IE6，IE7），偏移量可能会变。它可能在72字节到
100字节之间变动（最多100字节）
这意味着我们不能100%确认我们将在缓冲区中登录。
我们怎么解决？我们知道nop的思想，当跳到shellcode时允许弹簧垫有点远。但是有没有
一个似兼容rop的nop的东西？
ROP NOP
当然有。记得“direct RET exploit 版本3”？我们已经用滑梯来走到栈上的下一个地址。
为了能是exploit通用（在单独的一个exploit中没有创建许多的rop链），你可以简单地
用ROP NOP来spray一些区域（代表指向RET的指针）。每次RET被调用时，在没有做一个
坏事的情况下，它会滑到/跳到下一个ret。
因此它很像一个nop。
一个指针是由4字节组成的，因此对齐这些指针很重要。确保当EIP返回到栈上
时，它会登录在指针上（而不是登录在指针的中间，破坏了链），或者会直接登录在你的rop
链的第一个小配件。
找rop nop不难。任意一个指向RET的指针都行。
返回到我们的exploit中。
打造 ROP 链--WriteProcessMemory()
为一个给定的函数精巧布置栈有很多种方法。我将简单地解释Lincoln是怎样打造他的rop
链并且将bug变成一个成功的DEP绕过exploit。
重要注意：我们要处理坏字节：在80和9f之间的字节要避免。
在他的exploit中，Lincoln决定用PUSHAD来将参数在正确的地方入栈，然后调用函数（这
个例子中是WriteProcessMemory()）。
首先，为了确保rop链被执行，虽然我们登录在ADD ESP，46C指令后的位置不一样，他用
很多RET指针（0x06471619）作为nop：
然后他将0x064BC001放入ebp（在0x0644B633处用一个popebp+ret小配件），然后用一连
串pop指令（在0x0647B965）来将5个“参数”放入寄存器中：
在这5个POP执行后，寄存器是这样的：
接下来，他将产生shellcode的长度。他用3个ADDEAX，80指令然后再在EBX上加上
EAX的值。
结果：
因此shellcode的长度现在放入ebx中。
我们用来完成这个的rop小配件是POPEAX（从栈中取出0xCCD0731F），然后做SUBEAX，
EAX。最后，这个值放入EBP。
注意：Lincoln没有将7C9022CF放入EBP的原因是那个特殊的地址包含一个“坏
字节”。我们不能用字节0x80。ECX已经包含50505050，因此他用一个sub指令（eax中有
个重新计算的值）来重新产生那个指针。聪明的想法！
这个rop子链已经将7C9022CF放入EBP中。这个地址将是写入我们的shellcode的目标位
置。基本上，我们将补丁WriteProcessMemory()函数自身，如果你认真地读了关于
WriteProcessMemory()这节的话，因这个地址看起来很熟悉。
最后的小配件没有用一个RET来结尾。它做一个callESI操作。
ESI怎么来的？记得我们早些时候做的5个POP？好的，我们简单地放一个从ESI弹出的值
到栈上。然后那个值是下面指令的指针：
因此CALLESI将会跳到那个位置，ESP增加4字节，将一个值（06454ED5）放入EAX中
然后返回。我们简单地返回到栈上，我们的下一个rop小配件在的位置：
用这个小配件，ESI被设成FFFFFFFF。这会是后面用作hProcess参数的值。
接下来，CCD07263被弹入eax，之后，一个SUBEAX，ECX指令被执行。
执行这些指令之后，EAX中的结果会是7C802213（是kernel32.WriteProcessMemory的指针）
最后，一个PUSHAD指令被执行：
这会使栈顶看起来是这样的：
当pushad函数返回时，它会执行在0x0647BD7C处的指令（源于EDI，放入早些用5个POP
操作的寄存器中）
这个指令将只是做一个CALLEAX。在EAX中，我们依然有一个指向
kernel32.WriteProcessMemory()的指针。当CALLEAX被调用时，下面的参数会从栈中取出：
第一个参数无关紧要。代码会补丁WPM()，因此它不会返回。然后，可以找到hProcess参
数（FFFFFFFF）和Address（目的地，写入shellcode的地方），紧接着Buffer（shellcode的
位置。这个指针从ESP中取出。由于PUSHAD会移动ESP（并且由于我们已经将我们的
shellcode直接放在rop链之后），这个指针现在指向shellcode。
BytesToWrite值是早些时候产生的。最后，最后一个参数指向一个可写的位置。
首先，dump出0x78022CF处的内容：
按F7单步执行。在ntdll.ZwWriteVirtualMemory调用之后（在7C8022C9），在RETN14指
令执行之前，我们可以看到我们的shellcode被复制到7C8022CF：
当RETN14指令执行时，我们登录在7C8022CF，就是WriteProcessMemory()指令流的下一
条指令。
由于这个位置现在包含shellcode，shellcode会被执行。
结果：
结论：在这个ROPexploit中，一个不同的将参数入栈的技术被用到。参数首先被产生（用
ADD和SUB指令）然后弹出到寄存器中，最终，一个PUSHAD指令将指令放入正确的位
置，然后API就被调用。
EEEEgggggggghhhhuuuunnnntttteeeerrrrssss
在教程8中，我已经讨论了egghunters的内部机理。总结了egghunter的思想，你将会执
行小数量的代码，它会寻找真正的shellcode（在栈上或堆里）然后执行。
你应该已经知道了怎样使一个egg hunter运行，用rop。一个egghunter只是一些小的
shellcode，因此你应该应用一个rop序列来使egg hunter运行。
当egg hunter已经找到shellcode，它会跳到shellcode的基地址。当然，当DEP启用时，
这很可能不会成功。
这意味着我们需要插入另一个rop链来确保我们能使shellcode标记为可执行。
有两种方法：
●附加一个rop例程到egg hunter自身
●用一个rop例程预先考虑最后的shellcode
让我们看下这两种方案是怎样用一个常用的egg hunter实现的（用
NtAccessCheckAndAuditAlarm）：
同时，我假设你已经知道了怎样用rop来使egg hunter运行。
正如你能看到的，在egg hunter的末尾（当shellcode被找到时），shellcode的地址会存
入edi。egg hunter的最后一条指令会跳到edi然后尝试执行shellcode。当DEP启用时，
跳转会被执行，但是shellcode的执行会失败。
我们怎么修理这个？
方案 1：给 egg hunter 打补丁
在第一个方案，我会修改egg hunter来确保shellcode在的位置被首先标记为可执行。
“jmp edi”指令需要去掉。
接下来，我们要将shellcode在的内存位置改为可执行。我们可以调用VirtualProtect()
来实现。幸运地，我们这次不要用ROP，我们只要把代码写到asm中然后将它附加到egg
hunter中。它会执行得很好（因为当前的位置是可执行）
需要写入的额外代码要精巧布置下面的值在栈上：
●返回地址：在edi中的地址--指向shellcode。这会确保shellcode在VirtualProtect()
函数调用完自动执行。
●lpAddress：和“返回地址”一样的地址
●size：shellcode的大小
●flNewProtect：设成0x40
●lpflOldProtect：指向可写位置
最后它需要调用VirtualProtect()函数（确保第一个参数在栈顶），就这样：
asm样本代码：
或者，用机器码：
因此，基本上，整个egghunter是这样的：