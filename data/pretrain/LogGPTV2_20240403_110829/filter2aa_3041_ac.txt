据传给已经在等待的第二个 goroutine。在两个 goroutine 间传输数据是同步的，一旦传输完
成，两个 goroutine 都会知道数据已经完成传输。当第二个 goroutine 利用这个数据完成其任
务后，将这个数据传给第三个正在等待的 goroutine。这次传输依旧是同步的，两个 goroutine
都会确认数据传输完成。这种在 goroutine 之间安全传输数据的方法不需要任何锁或者同步
机制。 
需要强调的是，通道并不提供跨 goroutine 的数据访问保护机制。如果通过通道传输数据的
一份副本，那么每个 goroutine 都持有一份副本，各自对自己的副本做修改是安全的。当传输的
是指向数据的指针时，如果读和写是由不同的 goroutine 完成的，每个 goroutine 依旧需要额外的
同步动作。 
1.1.3  Go 语言的类型系统 
Go 语言提供了灵活的、无继承的类型系统，无需降低运行性能就能最大程度上复用代码。
这个类型系统依然支持面向对象开发，但避免了传统面向对象的问题。如果你曾经在复杂的 Java
和 C++程序上花数周时间考虑如何抽象类和接口，你就能意识到 Go 语言的类型系统有多么简单。
Go 开发者使用组合（composition）设计模式，只需简单地将一个类型嵌入到另一个类型，就能
复用所有的功能。其他语言也能使用组合，但是不得不和继承绑在一起使用，结果使整个用法非
常复杂，很难使用。在 Go 语言中，一个类型由其他更微小的类型组合而成，避免了传统的基于
继承的模型。 
另外，Go 语言还具有独特的接口实现机制，允许用户对行为进行建模，而不是对类型进行
建模。在 Go 语言中，不需要声明某个类型实现了某个接口，编译器会判断一个类型的实例是否
符合正在使用的接口。Go 标准库里的很多接口都非常简单，只开放几个函数。从实践上讲，尤
其对那些使用类似 Java 的面向对象语言的人来说，需要一些时间才能习惯这个特性。 
1．类型简单 
Go 语言不仅有类似 int 和 string 这样的内置类型，还支持用户定义的类型。在 Go 语言
中，用户定义的类型通常包含一组带类型的字段，用于存储数据。Go 语言的用户定义的类型看
起来和 C 语言的结构很像，用起来也很相似。不过 Go 语言的类型可以声明操作该类型数据的方
法。传统语言使用继承来扩展结构——Client 继承自 User，User 继承自 Entity，Go 语言与此不同，
Go 开发者构建更小的类型——Customer 和 Admin，然后把这些小类型组合成更大的类型。图 1-4
展示了继承和组合之间的不同。 
2．Go 接口对一组行为建模 
接口用于描述类型的行为。如果一个类型的实例实现了一个接口，意味着这个实例可以执行
6 
第 1 章 关于 Go 语言的介绍 
一组特定的行为。你甚至不需要去声明这个实例实现某个接口，只需要实现这组行为就好。其他
的语言把这个特性叫作鸭子类型——如果它叫起来像鸭子，那它就可能是只鸭子。Go 语言的接
口也是这么做的。在 Go 语言中，如果一个类型实现了一个接口的所有方法，那么这个类型的实
例就可以存储在这个接口类型的实例中，不需要额外声明。 
图 1-4  继承和组合的对比 
在类似 Java 这种严格的面向对象语言中，所有的设计都围绕接口展开。在编码前，用户经
常不得不思考一个庞大的继承链。下面是一个 Java 接口的例子： 
interface User { 
 public void login(); 
 public void logout(); 
} 
在 Java 中要实现这个接口，要求用户的类必须满足 User 接口里的所有约束，并且显式声
明这个类实现了这个接口。而 Go 语言的接口一般只会描述一个单一的动作。在 Go 语言中，最
常使用的接口之一是 io.Reader。这个接口提供了一个简单的方法，用来声明一个类型有数据
可以读取。标准库内的其他函数都能理解这个接口。这个接口的定义如下： 
type Reader interface { 
 Read(p []byte) (n int, err error) 
} 
为了实现 io.Reader 这个接口，你只需要实现一个 Read 方法，这个方法接受一个 byte
切片，返回一个整数和可能出现的错误。 
这和传统的面向对象编程语言的接口系统有本质的区别。Go 语言的接口更小，只倾向于
定义一个单一的动作。实际使用中，这更有利于使用组合来复用代码。用户几乎可以给所有包
含数据的类型实现 io.Reader 接口，然后把这个类型的实例传给任意一个知道如何读取
io.Reader 的 Go 函数。 
Go 语言的整个网络库都使用了 io.Reader 接口，这样可以将程序的功能和不同网络的
实现分离。这样的接口用起来有趣、优雅且自由。文件、缓冲区、套接字以及其他的数据源
都实现了 io.Reader 接口。使用同一个接口，可以高效地操作数据，而不用考虑到底数据
来自哪里。 
1.1.4  内存管理 
不当的内存管理会导致程序崩溃或者内存泄漏，甚至让整个操作系统崩溃。Go 语言拥有现
代化的垃圾回收机制，能帮你解决这个难题。在其他系统语言（如 C 或者 C++）中，使用内存
前要先分配这段内存，而且使用完毕后要将其释放掉。哪怕只做错了一件事，都可能导致程序崩
溃或者内存泄漏。可惜，追踪内存是否还被使用本身就是十分艰难的事情，而要想支持多线程和
高并发，更是让这件事难上加难。虽然 Go 语言的垃圾回收会有一些额外的开销，但是编程时，
能显著降低开发难度。Go 语言把无趣的内存管理交给专业的编译器去做，而让程序员专注于更
有趣的事情。 
1.2  你好，Go 
感受一门语言最简单的方法就是实践。让我们看看用 Go 语言如何编写经典的 Hello 
World!应用程序：
package main 
import "fmt" 
func main() { 
 fmt.Println("Hello world!") 
} 
运行这个示例程序后会在屏幕上输出我们熟悉的一句话。但是怎么运行呢？无须在机器上安
装 Go 语言，在浏览器中就可以使用几乎所有 Go 语言的功能。 
介绍 Go Playground 
Go Playground 允许在浏览器里编辑并运行 Go 语言代码。在浏览器中打开 http://play.golang.org。
浏览器里展示的代码是可编辑的（见图 1-5）。点击 Run，看看会发生什么。 
可以把输出的问候文字改成别的语言。试着改动 fmt.Println()里面的文字，然后再次点
击 Run。 
分享 Go 代码  Go 开发者使用 Playground 分享他们的想法，测试理论，或者调试代码。你也可以
这么做。每次使用 Playground 创建一个新程序之后，可以点击 Share 得到一个用于分享的网址。任
何人都能打开这个链接。试试 http://play.golang.org/p/EWIXicJdmz。 
Go 程序都组
织成包。 
import 语句用于导入外部代码。标准
库中的 fmt 包用于格式化并输出数据。 
像 C 语言一样，main 函
数是程序执行的入口。 
图 1-5  Go Playground 
要给想要学习写东西或者寻求帮助的同事或者朋友演示某个想法时，Go Playground 是非常
好的方式。在 Go 语言的 IRC 频道、Slack 群组、邮件列表和 Go 开发者发送的无数邮件里，用户
都能看到创建、修改和分享 Go Playground 上的程序。 
1.3  小结 
Go 语言是现代的、快速的，带有一个强大的标准库。
Go 语言内置对并发的支持。
Go 语言使用接口作为代码复用的基础模块。
第 2 章 快速开始一个 Go 程序 
本章主要内容 
学习如何写一个复杂的 Go 程序
声明类型、变量、函数和方法
启动并同步操作 goroutine
使用接口写通用的代码
处理程序逻辑和错误
为了能更高效地使用语言进行编码，Go 语言有自己的哲学和编程习惯。Go 语言的设计者们
从编程效率出发设计了这门语言，但又不会丢掉访问底层程序结构的能力。设计者们通过一组最
少的关键字、内置的方法和语法，最终平衡了这两方面。Go 语言也提供了完善的标准库。标准
库提供了构建实际的基于 Web 和基于网络的程序所需的所有核心库。 
让我们通过一个完整的 Go 语言程序，来看看 Go 语言是如何实现这些功能的。这个程序实
现的功能很常见，能在很多现在开发的 Go 程序里发现类似的功能。这个程序从不同的数据源拉
取数据，将数据内容与一组搜索项做对比，然后将匹配的内容显示在终端窗口。这个程序会读取
文本文件，进行网络调用，解码 XML 和 JSON 成为结构化类型数据，并且利用 Go 语言的并发
机制保证这些操作的速度。 
读者可以下载本章的代码，用自己喜欢的编辑器阅读。代码存放在这个代码库： 
https://github.com/goinaction/code/tree/master/chapter2/sample 
没必要第一次就读懂本章的所有内容，可以多读两遍。在学习时，虽然很多现代语言的概念
可以对应到 Go 语言中，Go 语言还是有一些独特的特性和风格。如果放下已经熟悉的编程语言，
用一种全新的眼光来审视 Go 语言，你会更容易理解并接受 Go 语言的特性，发现 Go 语言的优雅。 
2.1  程序架构 
在深入代码之前，让我们看一下程序的架构（如图 2-1 所示），看看如何在所有不同的数据
2
第 2 章 快速开始一个 Go 程序 
源中搜索数据。 
图 2-1  程序架构流程图 
这个程序分成多个不同步骤，在多个不同的 goroutine 里运行。我们会根据流程展示代码，
从主 goroutine 开始，一直到执行搜索的 goroutine 和跟踪结果的 goroutine，最后回到主 goroutine。
首先来看一下整个项目的结构，如代码清单 2-1 所示。 
代码清单 2-1 应用程序的项目结构 
cd $GOPATH/src/github.com/goinaction/code/chapter2 
- sample 
 - data 
    data.json   -- 包含一组数据源 
 - matchers 
    rss.go      -- 搜索 rss 源的匹配器 
 - search 
 default.go  -- 搜索数据用的默认匹配器 
 feed.go     -- 用于读取 json 数据文件 
 match.go    -- 用于支持不同匹配器的接口 
 search.go   -- 执行搜索的主控制逻辑 
 main.go         -- 程序的入口 
这个应用的代码使用了 4 个文件夹，按字母顺序列出。文件夹 data 中有一个 JSON 文档，其
内容是程序要拉取和处理的数据源。文件夹 matchers 中包含程序里用于支持搜索不同数据源的代
码。目前程序只完成了支持处理 RSS 类型的数据源的匹配器。文件夹 search 中包含使用不同匹
配器进行搜索的业务逻辑。最后，父级文件夹 sample 中有个 main.go 文件，这是整个程序的入口。 
现在了解了如何组织程序的代码，可以继续探索并了解程序是如何工作的。让我们从程序的
入口开始。 
2.2  main 包
程序的主入口可以在 main.go 文件里找到，如代码清单 2-2 所示。虽然这个文件只有 21 行代
码，依然有几点需要注意。 
代码清单 2-2 main.go 
01 package main 
02 
03 import ( 
04 
 "log" 
05 
 "os" 
06 
07 
 _ "github.com/goinaction/code/chapter2/sample/matchers" 
08 
 "github.com/goinaction/code/chapter2/sample/search" 
09 ) 
10 
11 // init 在 main 之前调用 
12 func init() { 
13 
 // 将日志输出到标准输出 
14 
 log.SetOutput(os.Stdout) 
15 } 
16 
17 // main 是整个程序的入口 
18 func main() { 
19 
 // 使用特定的项做搜索 
20 
 search.Run("president") 
21 } 
每个可执行的 Go 程序都有两个明显的特征。一个特征是第 18 行声明的名为 main 的函数。
构建程序在构建可执行文件时，需要找到这个已经声明的 main 函数，把它作为程序的入口。第
二个特征是程序的第 01 行的包名 main，如代码清单 2-3 所示。
代码清单 2-3 main.go：第 01 行 
01 package main 
可以看到，main 函数保存在名为 main 的包里。如果 main 函数不在 main 包里，构建工
具就不会生成可执行的文件。 
Go 语言的每个代码文件都属于一个包，main.go 也不例外。包这个特性对于 Go 语言来说很
重要，我们会在第 3 章中接触到更多细节。现在，只要简单了解以下内容：一个包定义一组编译
过的代码，包的名字类似命名空间，可以用来间接访问包内声明的标识符。这个特性可以把不同
包中定义的同名标识符区别开。 
现在，把注意力转到 main.go 的第 03 行到第 09 行，如代码清单 2-4 所示，这里声明了所有
的导入项。 
代码清单 2-4 main.go：第 03 行到第 09 行 
03 import ( 
04 
 "log" 
05 
 "os" 
06 
07 
 _ "github.com/goinaction/code/chapter2/sample/matchers" 
08 
 "github.com/goinaction/code/chapter2/sample/search" 
09 ) 
顾名思义，关键字 import 就是导入一段代码，让用户可以访问其中的标识符，如类型、函
数、常量和接口。在这个例子中，由于第 08 行的导入，main.go 里的代码就可以引用 search
包里的 Run 函数。程序的第 04 行和第 05 行导入标准库里的 log 和 os 包。
所有处于同一个文件夹里的代码文件，必须使用同一个包名。按照惯例，包和文件夹
同名。就像之前说的，一个包定义一组编译后的代码，每段代码都描述包的一部分。如果
回头去看看代码清单 2-1，可以看看第 08 行的导入是如何指定那个项目里名叫 search 的
文件夹的。 
读者可能注意到第 07 行导入 matchers 包的时候，导入的路径前面有一个下划线，如代码
清单 2-5 所示。 
代码清单 2-5 main.go：第 07 行 
07 
 _ "github.com/goinaction/code/chapter2/sample/matchers" 
这个技术是为了让 Go 语言对包做初始化操作，但是并不使用包里的标识符。为了让程序的
可读性更强，Go 编译器不允许声明导入某个包却不使用。下划线让编译器接受这类导入，并且
调用对应包内的所有代码文件里定义的 init 函数。对这个程序来说，这样做的目的是调用
matchers 包中的 rss.go 代码文件里的 init 函数，注册 RSS 匹配器，以便后用。我们后面会展
示具体的工作方式。 
代码文件 main.go 里也有一个 init 函数，在第 12 行到第 15 行中声明，如代码清单 2-6 所示。 
代码清单 2-6 main.go：第 11 行到第 15 行 
11 // init 在 main 之前调用 
12 func init() { 
13 
 // 将日志输出到标准输出 
14 
 log.SetOutput(os.Stdout) 
15 } 
程序中每个代码文件里的 init 函数都会在 main 函数执行前调用。这个 init 函数将标准库
里日志类的输出，从默认的标准错误（stderr），设置为标准输出（stdout）设备。在第 7 章，
我们会进一步讨论 log 包和标准库里其他重要的包。
最后，让我们看看 main 函数第 20 行那条语句的作用，如代码清单 2-7 所示。
代码清单 2-7 main.go：第 19 行到第 20 行 
19 
 // 使用特定的项做搜索 
20 
 search.Run("president") 
可以看到，这一行调用了 search 包里的 Run 函数。这个函数包含程序的核心业务逻辑，
需要传入一个字符串作为搜索项。一旦 Run 函数退出，程序就会终止。
现在，让我们看看 search 包里的代码。
2.3  search 包
这个程序使用的框架和业务逻辑都在 search 包里。这个包由 4 个不同的代码文件组成，
每个文件对应一个独立的职责。我们会逐步分析这个程序的逻辑，到时再说明各个代码文件的
作用。 
由于整个程序都围绕匹配器来运作，我们先简单介绍一下什么是匹配器。这个程序里的匹配
器，是指包含特定信息、用于处理某类数据源的实例。在这个示例程序中有两个匹配器。框架本
身实现了一个无法获取任何信息的默认匹配器，而在 matchers 包里实现了 RSS 匹配器。RSS
匹配器知道如何获取、读入并查找 RSS 数据源。随后我们会扩展这个程序，加入能读取 JSON
文档或 CSV 文件的匹配器。我们后面会再讨论如何实现匹配器。 
2.3.1  search.go 
代码清单 2-8 中展示的是 search.go 代码文件的前 9 行代码。之前提到的 Run 函数就在这个
文件里。 
代码清单 2-8 search/search.go：第 01 行到第 09 行 
01 package search 
02 
03 import ( 
04 
 "log" 
05 
 "sync" 
06 ) 
07 
08 // 注册用于搜索的匹配器的映射 
09 var matchers = make(map[string]Matcher) 
可以看到，每个代码文件都以 package 关键字开头，随后跟着包的名字。文件夹 search 下的
每个代码文件都使用 search 作为包名。第 03 行到第 06 行代码导入标准库的 log 和 sync 包。
与第三方包不同，从标准库中导入代码时，只需要给出要导入的包名。编译器查找包的时候，
总是会到 GOROOT 和 GOPATH 环境变量（如代码清单 2-9 所示）引用的位置去查找。
代码清单 2-9 GOROOT 和 GOPATH 环境变量
GOROOT="/Users/me/go" 
GOPATH="/Users/me/spaces/go/projects" 
log 包提供打印日志信息到标准输出（stdout）、标准错误（stderr）或者自定义设备的
功能。sync 包提供同步 goroutine 的功能。这个示例程序需要用到同步功能。第 09 行是全书第
一次声明一个变量，如代码清单 2-10 所示。 