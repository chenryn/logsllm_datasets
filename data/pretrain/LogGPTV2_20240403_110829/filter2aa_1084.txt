Fuzzing Linux with Xen
DEF CON 29  
Tamas K Lengyel
2
don’t microwave your pets
Performance varies by use, configuration and other factors. Learn more at www.Intel.com/PerformanceIndex​.  
Performance results are based on testing as of dates shown in configurations and may not reflect all publicly available ​updates.  
See backup for configuration details.  No product or component can be absolutely secure.
No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document.
Intel does not control or audit third-party data. You should consult other sources to evaluate accuracy.
Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a 
particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade.
Your costs and results may vary. 
Intel technologies may require enabled hardware, software or service activation.
© Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names 
and brands may be claimed as the property of others.  ​
# whoami
4
tl;dr
We fuzzed the device-facing input points of several Linux drivers
We built new tools to get it done
We open-sourced them
We found a bunch of bugs & fixed them
Showing you how it was done
5
feedback fuzzers
Not “just” about feeding random input to your target
Feedback fuzzers monitor the target execution
Collect execution log (aka. coverage)
Compare execution from run-to-run
New code discovered? Focus on that input!
6
feedback fuzzers
Need determinism
If your target code behaves differently between executions not due 
to the fuzzer, the feedback will be just noise
7
xen vm forking
Add determinism to kernel-code execution
Reset vCPU registers and free copied pages for better speed
Parent VM
…
Page X
Page Y
Page Z
…
Fork VM
…
Shared Page X
Copied Page Y
Shared Page Z
…
R
W
X
8
vm forking speed
VM fork creation time:
~745 μs ~= 1300 VM/s
VM fork reset time:
~111 μs ~= 9000 reset/s
Measured on i5-8350U
9
xen vmi
Xen VM introspection is natively supported
• Read/write/translate guest memory
Pause vCPU & get notification in dom0 of various hw events
• CPUID
• Int3
• MTF
• EPT faults
• register writes (mov-to-cr, MSRs)
• etc.
10
xen vmtrace
Upstreamed in Xen 4.15
• In collaboration with CERT.pl & Citrix
Use Intel® Processor Trace to record VM execution
• CPU itself stores info in memory about execution, low overhead
• Stores only enough detail to allow for post-execution reconstruction
Can record execution of the whole VM
11
fuzzing on xen
Parent
VM
Magic 
CPUID
Fork
Sink 
VM
panic()
kasan_report()
ubsan_prologue()
…
Fuzz 
VM
Add 0xCC
Read input from AFL
Write it to VM’s mem
Reset
Catch a breakpoint
Report crash
Catch Magic CPUID
Report no-crash
Neither: timeout
Analyze
Decode IPT log
Report coverage
Fork
Run
Fuzz
12
13
14
15
16
17
there is more to fuzzing
analysis
fuzzing
triaging
18
dma
Memory made accessible to a device
• Facilitates fast I/O operations
• IOMMU can restrict device to access only DMA pages
Finding where Linux reads from DMA isn’t trivial
• __iomem, be{16/32/64}_to_cpu, le{16/32/64}_to_cpu, dma_addr_t
• Cross-reference with ftrace output
19
let’s just read the spec
https://www.intel.com/content/www/us/en/products/docs/io/universal-serial-bus/extensible-host-controler-interface-usb-xhci.html
20
21
22
triaging
Can’t just “log in and gather logs”
• No network
• No disk
• No console
The dmesg buffer of Linux is in RAM
• We can carve it out!
23
xen gdbsx
It’s been shipping with Xen since 2009
Minimal gdb bridge
Build Linux with:
CONFIG_DEBUG_INFO=y
CONFIG_GDB_SCRIPTS=y
CONFIG_FRAME_POINTER=y
CONFIG_UNWINDER_FRAME_POINTER=y
CONFIG_RANDOMIZE_BASE=n
24
25
26
27
28
29
triaging beyond the basics
Gathering the dmesg log has been sufficient to triage most bugs
Not all of them
Sink may get triggered by code far away from the driver
30
31
32
Bug triggers in net/core/dev.c, NOT in IGB itself:
33
34
35
36
37
38
39
40
41
Both src and dst in the memcpy is corrupted
Anything else we can do?
42
43
44
45
Buggy code:
Fixed code:
46
can you spot the bug?
47
what can go wrong here?
48
what we found & fixed
• 9 NULL-pointer derefs
• 3 array index out-of-bounds
• 2 infinite loops in IRQ handler
• 2 user-memory accesses
49
doublefetch detection
Remove R/W EPT permission of DMA page
•
Byte-granularity
•
Look for PF with read access at the same page & offset 2x
•
Report crash to AFL
We thought it would be rare
•
Happens all over the place
•
Happens because of different bits used of the same byte
•
Doesn’t make sense to stop execution at the first detection
50
mission accomplished!!
Or is it?
• Did we discover all DMA input points?
• We got bogged down by documenting all the bugs
• Staring at the code is only productive up to a point
Let’s do better!
51
dmamonitor
Standalone EPT fault monitoring
Linux allocates DMA pages through its internal DMA API
• dma_alloc_attrs()
• Hook function entry & ret with int3 
Remove EPT permission on-the-fly
• Log all code-sites that read from any DMA!
52
53
54
55
56
57
58
still some problems
Sometimes the data isn’t used where DMA is accessed
• Where is it used and is it safe?
¯\_(ツ)_/¯
We don’t want to go back to reading the source
• Very hard to follow data-flow by eye
• Error-prone, manual, annoying
59
full-vm taint analysis
Track tainted data propagation in the kernel
• Record kernel execution using VMtrace
• Replay recorded instruction stream in Triton DBI’s taint engine
• Check where RIP gets tainted
Can find code-locations affected by DMA input anywhere
60
61
62
63
64
65
Code released as open-source (MIT)
https://github.com/intel/vmtaint
66
vm transplantation
Getting some targets working in a Xen VM is difficult
No problem!
• VM forks need only CPU-state and memory
• Take snapshot on QEMU/KVM/Simics
• Load it up on Xen
• Fuzz away!
67
what’s next
Automation
Capture system state using Intel® DCI
• Fuzz BIOS/SMM
• Fuzz bare-metal systems
Sandsifter ring0
Nested virt-support
68
things we didn’t cover here
Fuzzing other OS’s
Fuzzing Xen
Fuzzing userspace
Fuzzing black-box binaries
Fuzzing malware
69
thanks
Questions? Comments?
@tklengyel
Thanks goes to a whole lot of people who contributed & made this 
work possible!
Intel IAGS & CCG, Google ChromeOS team, Citrix, CERT.pl & the wider open-source 
security community releasing tools for everyone's benefit
https://github.com/intel/kernel-fuzzer-for-xen-project
https://github.com/intel/vmtaint