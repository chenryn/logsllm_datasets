from a variety of aspects. In particular, buffer overflows, and use-
after-free bugs are commonly believed to be exploitable, whereas
V-Shuttle found 12 bugs and 1 bug, respectively. V-Shuttle also
Session 7B: Fuzzing CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2207detected 5 assertion failures from QEMU, which indicate that the
executions reach unexpected states.
Case Study 1: QEMU OHCI Out-of-bounds Access (CVE-
2020-25624) V-Shuttle uncovered an out-of-bounds (OOB)
read/write access vulnerability in QEMU’s USB OHCI controller
emulator. The issue occurs while servicing the isochronous trans-
fer descriptors (ITD), which describes the isochronous endpoint’s
data packets and is linked into the endpoint list. OHCI controller
derives variables start_addr, end_addr from iso_td supplied by
the guest user via DMA transfer. The device calculates the length of
the transmission according to the start_addr and end_addr. The
problem here is that the device does not check the negative length
when end_addr is less than start_addr, which could cause OOB
read and write due to integer overflow vulnerability. A guest user
using this flaw could crash the QEMU process resulting in a denial
of service.
It is difficult to trigger this bug by traditional fuzzing, as it re-
quires prior knowledge about the layout of the endpoint linked list
to avoid invalid memory access due to randomly generated pointer
values. However, V-Shuttle was able to trigger this vulnerability
by intercepting the device’s DMA read operations and supplying
fuzzed structure iso_td to the device regardless of the pointer. In
this way, len can be fuzzed enough to cause overflow; otherwise,
this field may remain unfuzzed.
Case Study 2: VirtualBox BusLogic Heap-based Buffer
Overflow (CVE-2021-2074) V-Shuttle identified a heap-based
buffer overwrite vulnerability in VirtualBox’s BusLogic SCSI em-
ulator, which has 8.2 CVSS Score according to CVE Details [7].
Successful attacks of this vulnerability can result in the takeover
of Oracle VM VirtualBox. The BusLogic device parses the com-
mand buffer and processes the command parameters from the guest.
When initializing a new command, the device gets the number of
bytes cbCommandParametersLeft for the command code param-
eters. cbCommandParametersLeft is subtracted by one each time
while filling the buffer with parameters. Then the device starts
execution of command if there are no parameters left. However,
cbCommandParametersLeft is not checked against 0 at the start.
This allows an attacker to first set the number to 0 and then issue a
command initialization, causing it to underflow. This will lead to an
arbitrary heap out-of-bounds write up to the size of the uint8_t,
which can be exploited to escape virtual machine.
In the fuzzing process, V-Shuttle continuously generated I/O
operations that could let the execution run towards the command
process function and finally trigger the vulnerability.
Table 5: Eifficiency of V-Shuttle in finding previously known vulnerabil-
ities. We measured the total number of executions and the time required. V-
Shuttle found all of the known vulnerabilities within a reasonable amount
of time.
Bug
CVE-2020-25625
CVE-2020-25085
CVE-2021-20257
CVE-2020-25084
CVE-2020-11869
Description
Exec
40.5M 2h16m50s
SDHCI Heap buffer overflow 8.88M 26m19s
OHCI infinite loop
Time
E1000 inifinite loop
EHCI use-after-free
ATI-VGA integer overflow
Found
✓
✓
✓
✓
✓
40s
235k
79.4M 4h37m22s
35.6M 2h22m40s
5.4.2 Rediscover Old Vulnerabilities Ability. To demonstrate
practicality, we also present some of the publicly known vulnera-
bilities we could find using our framework. We picked a set of pre-
viously known security vulnerabilities on a vulnerable QEMU (ver-
sion 5.0.0). Additionally, we tried to rediscover three high-impact
CVEs found by Nyx (CVE-2020-25085, CVE-2020-25084, and CVE-
2021-20257). In total, we analyzed five known bugs, and we mea-
sured the number of executions required to discover these bugs. As
shown in Table 14, V-Shuttle found all of these previously known
bugs within a reasonable number of executions (i.e., from 235 K to
79.4 M) as well as within a reasonable amount of time (i.e., from 40
sec to around 4 hrs).
6 DEPLOYMENT AND APPLICATION OF
V-SHUTTLE
(a) UHCI
(b) EHCI
Figure 8: Ant Group-QEMU’s branch coverage results found by V-
Shuttle during a 24-hours run. The line indicates averages while the
shaded area represents the 95% confidence intervals across 10 runs.
Now there are many open-source hypervisor solutions. Many
enterprises customize their cloud services based on open source
hypervisors. This fact introduces additional risk, complexity, and
costs for fuzz testing and bug fixing. Consequently, cloud computing
development presents us strongly with a need to establish a general
hypervisor fuzzing platform. By collaborating with the worldwide
leading Internet company Ant Group, we have an opportunity to
deploy and examine V-Shuttle on its commercial platform.
We choose two USB devices, UHCI and EHCI, which are deployed
in the production environment and perform the experiments to
discover branch coverage. The results are shown in Figure 8. As
expected, V-Shuttle-S achieves higher coverage than V-Shuttle-
M in the early time and converges to almost the same coverage
in the long term. This experiment shows similar performance as
in QEMU as described in Section 5.2. By experimenting with Ant
Group’s QEMU, we also show that our framework can be ported to a
variety of hypervisors with little effort. Specifically, when deploying
V-Shuttle to a new hypervisor, what a professional needs to do
is to perform a static analysis on the target device to collect DMA
objects, integrate the fuzzing agent into the hypervisor by some
simple configurations, instrument and compile the source code.
This process is very lightweight, e.g., it only takes about an hour
for a professional in related fields to implement V-Shuttle into a
new hypervisor. V-Shuttle’s scalability allows it able to be quickly
ported to various hypervisor implementations. The deployment
and application of V-Shuttle on Ant Group’s commercial platform
further demonstrates that V-Shuttle is not just an academic tool
but also a meaningful tool in the real world.
Session 7B: Fuzzing CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea22087 RELATED WORK
Fuzzing Techniques. In the past few years, fuzzing has proven to
be a very successful technique for discovering software vulnera-
bilities [14, 16, 19, 25, 32, 49]. AFL is one of the most well-known
fuzzers [5]. Later, many advanced fuzzers were developed based on
AFL [15, 29, 41]. Some research combined fuzzing with other bug
detection technologies [18, 44, 62]. Other approaches focused on
improving the scheduling algorithms [21, 40] and feedback mecha-
nisms [61]. Recently, hybrid fuzzing methods have been researched
extensively [24, 57, 60, 65, 66]. Additionally, some research focused
on evaluating fuzzers [38, 39]. Manès et al.’s survey [42] provides
an in-depth discussion in fuzzing.
Hypervisor Fuzzing. Most previous research on fuzzing hyper-
visors used blind fuzzing [9, 13, 20, 22, 31, 43]. Later, some security
researchers try to combine the hypervisor fuzzing with coverage
guidance [4, 8, 58]. In academia, VDF [34] is the first hypervisor
fuzzing platform that applies coverage-guided fuzzing to hypervi-
sors, which utilizes AFL toolchain to instrument QEMU source code
to collect the coverage information. However, VDF does not take
device protocol into account and only generates rough seed input,
which limits its performance. Hyper-Cube [50] leverages a custom
OS to provide multi-dimensional fuzzing, which is high-throughput.
However, Hyper-Cube struggles to explore complex devices due
to its black-box design. Nyx [51] proposes to fuzz hypervisors by
using fast snapshots and coverage guidance, which increases the
ability to test interesting behavior. However, its nested virtualiza-
tion design makes it more complex to setup the environment, as
the target hypervisor needs to run inside KVM-PT. Additionally,
Nyx still needs a lot of manual work put into specific generators,
not automatically enough.
Other Fuzzing Techniques. There are some similar fuzzing
tools focusing on device-driver interactions. PeriScope [55] hooks
into the kernel’s page fault handling mechanism to apply coverage-
guided fuzzing on WiFi drivers. Agamotto [56] accelerates the ker-
nel driver fuzzing with virtual machine checkpoints. USBFuzz [47]
uses an emulated device in the VM to fuzz USB drivers. Different
from hypervisor fuzzing, they target at the kernel driver side. Addi-
tionally, more and more researchers adopt fuzzing to a wider set
of targets ranging from kernel [27, 30, 33, 36, 37, 45, 52, 63, 64] to
IoT [23, 26, 67].
8 DISCUSSION
PoC Reconstruction. V-Shuttle requires some human resources
to help reconstruct PoC. Because our core fuzzing engine is inte-
grated into the hypervisor’s host process instead of running in the
guest system, we need to recover the PoC from the seed sequences.
If the hypervisor crashes when fuzzing the target device, we will
restart fuzzing another instrumented hypervisor which enables
recording all the MMIO/PIO and DMA access logs. Given the crash
backtrace and all access logs, then we construct the PoC driver
manually. We intend to find a more automatic way as future work.
Supporting Closed-Source Hypervisors. V-Shuttle re-
quires hypervisor modifications in order to redirect a device’s data
requests to the guest system via the MMIO/PIO and DMA inter-
face. A few components of V-Shuttle are deployed before the
compilation phase. Meanwhile, we use AFL’s compile-time instru-
mentation to obtain the coverage information. For this reason, for
now, V-Shuttle does not support closed-source hypervisors such
as VMware Workstation. We believe this could be overcome by
adopting a sort of binary patching and dynamic binary instrumen-
tation techniques with extra effort in the future.
Hypervisor Internal States. Due to the heavy costs involved
in hypervisor restarts, V-Shuttle continuously fuzzes the hypervi-
sor without restarting it between fuzzing iterations. This can limit
the effectiveness of fuzzing because the internal states of the tar-
get system persist across iterations. Changing the target device’s
internal states can also lead to instability in the coverage guidance,
as the same input can exercise different code paths depending on
the hypervisor state. Worse, when changes to the persisting states
accumulate, the device may eventually lock itself up.
9 CONCLUSION
The virtual device represents an attack surface, through which soft-
ware vulnerabilities in the hypervisor can be exploited. However, ex-
isting hypervisor fuzzers are inefficient (e.g., VDF), and meanwhile
not scalable or automatically extendable (e.g., Nyx). To address the
limitations of existing hypervisor fuzzing techniques, in this paper,
we propose V-Shuttle, a scalable and semantics-aware framework
to fuzz virtual devices in hypervisors. V-Shuttle is portable to
fuzz devices on different hypervisors, leveraging coverage-guided
fuzzing. Furthermore, V-Shuttle can effectively enable a broad
fuzzing, which can target a wide range of devices. To examine the
performance of V-Shuttle, we apply it on QEMU and VirtualBox,
two of the most popular hypervisor platforms. Via extensive evalua-
tion, we show V-Shuttle is very effective and efficient. It discovers
26 new memory bugs in QEMU and 9 new bugs in VirtualBox, with
17 bugs received official CVEs. Furthermore, by collaborating with
a worldwide leading Internet company, we also deploy V-Shuttle
on its commercial platform. The results again demonstrate the supe-
riority of V-Shuttle. To facilitate future related research, we will
open source V-Shuttle at https://github.com/hustdebug/v-shuttle.
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their insightful comments
on our work. This work is partly supported by the National
Key R&D Program of China (2020YFB1804705), NSFC under No.
U1936215, the Key R&D Program of Zhejiang Province (2021C01036,
2020C01021), the Fundamental Research Funds for the Central Uni-
versities (Zhejiang University NGICS Platform: ZJUNGICS2021021),
State Key Laboratory of Computer Architecture (ICT, CAS) under
Grant No. CARCHA202001, and the Major Scientific Project of Zhe-
jiang Lab (2018FD0ZX01). This work is also partly supported by
the Ant Group through the Ant Research Intern Program.
REFERENCES
[1] 2020. CVE-2020-14364 QEMU: usb: out-of-bounds r/w access issue while process-
ing usb packets, 2020. https://bugzilla.redhat.com/show_bug.cgi?id=1869201.
[2] 2020. Pwn2Own 2020: Oracle VirtualBox Escape, 2020. https://starlabs.sg/blog/
2020/09/pwn2own-2020-oracle-virtualbox-escape/.
[3] 2020. Pwning VMware, Part 2: ZDI-19-421, a UHCI bug, 2020. https://nafod.net/
blog/2020/02/29/zdi-19-421-uhci.html.
[4] 2021. Adventures in Hypervisor: Oracle VirtualBox Research. https://starlabs.sg/
blog/2020/04/adventures-in-hypervisor-oracle-virtualbox-research/.
Session 7B: Fuzzing CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2209[5] 2021. American Fuzzy Lop. http://lcamtuf.coredump.cx/afl/.
[6] 2021. CodeQL for research. https://securitylab.github.com/tools/codeql/.
[7] 2021. CVE details. https://www.cvedetails.com/.
[8] 2021. Fuzzing QEMU Device Emulation. https://qemu.readthedocs.io/en/latest/
devel/fuzzing.html.
[9] 2021. Microsoft Security Research and Defense. Fuzzing para-virtualized
https://blogs.technet.microsoft.com/srd/2019/01/28/
devices in Hyper-V.
fuzzing-para-virtualized-devices-in-hyper-v/.
PWN2OWN.
https://www.zerodayinitiative.com/blog/2021/4/2/
[10] 2021.
pwn2own-2021-schedule-and-live-results.
[11] 2021. Tianfu Cup International Cybersecurity Contest. http://tianfucup.com/.
[12] 2021. Universal Host Controller Interface. https://wiki.osdev.org/Universal_
Host_Controller_Interface.
Fuzzing
[13] 2021. Viridian Fuzzer. https://github.com/mwrlabs/ViridianFuzzer.
[14] Cornelius Aschermann, Tommaso Frassetto, Thorsten Holz, Patrick Jauernig,
Ahmad-Reza Sadeghi, and Daniel Teuchert. 2019. NAUTILUS: Fishing for Deep
Bugs with Grammars.. In NDSS.
[15] Cornelius Aschermann, Sergej Schumilo, Ali Abbasi, and Thorsten Holz. 2020.
Ijon: Exploring deep state spaces via fuzzing. In 2020 IEEE Symposium on Security
and Privacy (SP). IEEE, 1597–1612.
[16] Cornelius Aschermann, Sergej Schumilo, Tim Blazytko, Robert Gawlik, and
Thorsten Holz. 2019. REDQUEEN: Fuzzing with Input-to-State Correspondence..
In NDSS, Vol. 19. 1–15.
[17] Domagoj Babić, Stefan Bucur, Yaohui Chen, Franjo Ivančić, Tim King, Markus
Kusano, Caroline Lemieux, László Szekeres, and Wei Wang. 2019. Fudge: fuzz
driver generation at scale. In Proceedings of the 2019 27th ACM Joint Meeting on
European Software Engineering Conference and Symposium on the Foundations of
Software Engineering. 975–985.
[18] William Blair, Andrea Mambretti, Sajjad Arshad, Michael Weissbacher, William
Robertson, Engin Kirda, and Manuel Egele. 2020. HotFuzz: Discovering Algo-
rithmic Denial-of-Service Vulnerabilities Through Guided Micro-Fuzzing. arXiv
preprint arXiv:2002.03416 (2020).
[19] Tim Blazytko, Matt Bishop, Cornelius Aschermann, Justin Cappos, Moritz
Schlögel, Nadia Korshun, Ali Abbasi, Marco Schweighauser, Sebastian Schinzel,
Sergej Schumilo, et al. 2019. {GRIMOIRE}: Synthesizing structure while fuzzing.
In 28th {USENIX} Security Symposium ({USENIX} Security 19). 1985–2002.
[20] Sören Bleikertz. 2021. XenFuzz. https://www.openfoo.org/blog/xen-fuzz.html.
[21] Marcel Böhme, Van-Thuan Pham, Manh-Dung Nguyen, and Abhik Roychoudhury.
2017. Directed greybox fuzzing. In Proceedings of the 2017 ACM SIGSAC Conference
on Computer and Communications Security. 2329–2344.
MWR-Labs: Ventures
into Hyper-
V -
https://labs.mwrinfosecurity.com/blog/
ventures-into-hyper-v-part-1-fuzzing-hypercalls/.
[22] Amardeep Chana.
2021.
hypercalls.
[23] Jiongyi Chen, Wenrui Diao, Qingchuan Zhao, Chaoshun Zuo, Zhiqiang Lin,
XiaoFeng Wang, Wing Cheong Lau, Menghan Sun, Ronghai Yang, and Kehuan
Zhang. 2018. IoTFuzzer: Discovering Memory Corruptions in IoT Through App-
based Fuzzing.. In NDSS.
[24] Yaohui Chen, Mansour Ahmadi, Boyu Wang, Long Lu, et al. 2020. {MEUZZ}:
Smart Seed Scheduling for Hybrid Fuzzing. In 23rd International Symposium on
Research in Attacks, Intrusions and Defenses ({RAID} 2020). 77–92.
[25] Yuanliang Chen, Yu Jiang, Fuchen Ma, Jie Liang, Mingzhe Wang, Chijin Zhou,
Xun Jiao, and Zhuo Su. 2019. Enfuzz: Ensemble fuzzing with seed synchronization
among diverse fuzzers. In 28th {USENIX} Security Symposium ({USENIX} Security
19). 1967–1983.
[26] Abraham A Clements, Eric Gustafson, Tobias Scharnowski, Paul Grosen, David
Fritz, Christopher Kruegel, Giovanni Vigna, Saurabh Bagchi, and Mathias Payer.
2020. HALucinator: Firmware re-hosting through abstraction layer emulation.
In 29th {USENIX} Security Symposium ({USENIX} Security 20). 1201–1218.
[27] Jake Corina, Aravind Machiry, Christopher Salls, Yan Shoshitaishvili, Shuang
Hao, Christopher Kruegel, and Giovanni Vigna. 2017. Difuze: Interface aware
fuzzing for kernel drivers. In Proceedings of the 2017 ACM SIGSAC Conference on
Computer and Communications Security. 2123–2138.
[28] Nelson Elhage. 2011. Virtunoid: A kvm guest! host privilege escalation exploit.
Black Hat USA 2011 (2011).
[29] Shuitao Gan, Chao Zhang, Xiaojun Qin, Xuwen Tu, Kang Li, Zhongyu Pei, and
Zuoning Chen. 2018. Collafl: Path sensitive fuzzing. In 2018 IEEE Symposium on
Security and Privacy (SP). IEEE, 679–696.
[30] Google. 2021. syzkaller - kernel fuzzer, 2019. https://github.com/google/syzkaller..
[31] Mikhail Gorobets, Oleksandr Bazhaniuk, Alex Matrosov, Andrew Furtak, and
Yuriy Bulygin. 2015. Attacking hypervisors via firmware and hardware. Black
Hat USA (2015).
[32] Emre Güler, Philipp Görz, Elia Geretto, Andrea Jemmett, Sebastian Österlund,
Herbert Bos, Cristiano Giuffrida, and Thorsten Holz. 2020. Cupid: Automatic
Fuzzer Selection for Collaborative Fuzzing. In Annual Computer Security Applica-
tions Conference. 360–372.
[33] HyungSeok Han and Sang Kil Cha. 2017. Imf: Inferred model-based fuzzer. In
Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications
Security. 2345–2358.