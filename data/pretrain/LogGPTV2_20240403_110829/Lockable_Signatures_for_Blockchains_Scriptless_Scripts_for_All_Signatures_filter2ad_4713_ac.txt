ing the payment setup phase.
i
∗
i ) of party Pi (Pi+1).
• The transaction tx pay,i−1 (analogously tx pay,i) spends v
coins from pk i−1 or 3-PCi−1 (pk i or 3-PCi) to some key
∗
i−1 (pk
pk
• The signature σi−1 (analogously σi) is the signature on
the transaction tx pay,i−1 (tx pay,i) under the public key pk i−1
or 3-PCi−1 (pk i or 3-PCi).
The recipient ﬁnally obtains (cid:96)kn−1 generated with the help
of P0, Pn−1 and Pn+1 (which is again impersonated by the
sender). Notice the expiry times of the payment transactions
are set such that tx pay,i−1 expires ∆ time units after tx pay,i
expires. This is to ensure Pi has sufﬁcient time (∆ units) to
get paid from tx pay,i−1 after it pays Pi+1 using tx pay,i.
The payment release phase is triggered when the sender
(P0, Pn+1) jointly generates σn along with the receiver Pn.
The receiver can unlock (cid:96)kn−1 using Unlock to obtain σn−1
and returns it to Pn−1. This procedure continues until party
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:30:49 UTC from IEEE Xplore.  Restrictions apply. 
941
 P2 who unlocks (cid:96)k1 and learns σ1. Every party Pi (except
the sender) has two transactions tx Setup,i−1 and tx pay,i−1 (that
spends from tx Setup,i−1) along with valid signatures on both,
concluding one payment of v coins from P1 to Pn.
For subsequent payments between the same sender and the
receiver via the same payment path P1, . . . , Pn, the parties can
re-use the setup phase and only overwrite the lock information
by re-running the lock phase.
Security. Intuitively, the unlockability of the lockable signatures
guarantees that no adversary can return a valid signature σ(cid:48)
i
on tx pay,i under pk i to an honest party Pi, such that when Pi
tries to unlock (cid:96)ki−1 with σ(cid:48)
i, he gets an invalid signature. This
ensures the adversary cannot steal the funds of an honest Pi,
no matter how many other parties it corrupts.
The hiding property of the lockable signatures ensures that no
adversary can unlock (cid:96)ki (for any i) to reveal a valid signature
σi on tx pay,i, before the sender initiates the release phase. This
ensures that no adversary corrupting an intermediate party
in the payment path can steal the funds of the sender. Our
construction is secure against wormhole attacks [3] following
a similar argument.
It is important to notice that we consider the standard notion
of MPC where the adversary can abort at any time and deny
the honest parties from seeing their output (i.e., we do not
assume fairness). This means that some extra care is needed to
ensure that adversarial aborts do not cause the honest parties
to lose coins. To convey some intuition, consider two cases.
• Abort before all locks are established: the participants
will also abort the execution. The hiding property of the locks
guarantees that the signatures on the transactions remain hidden
and the honest parties do not lose money.
• Abort after all locks are established: the honest parties
can “unlock” their signatures by just accessing the blockchain
(and using some local information). The unlockability property
guarantees that this process never fails.
Efﬁcient BLS-Based PCN. We obtain an efﬁcient BLS-based
PCN protocol by exploiting the structure of the keys and the
signature. In the setup phase, we substitute the usage of a
general purpose MPC with a non-interactive protocol where
the shared public key is set to be the aggregate of individual
public keys of the parties. That is,
· pk (i)
· pk (i+1)
i
i
pk i := pk (0)
and pk (i+1)
i
i
, pk (i)
i
where pk (0)
are the keys of P0, Pi and Pi+1,
respectively. Each key has an associated NIZK proof, proving
knowledge of the corresponding secret key, to prevent rogue
key attacks [39].
i
, σ(i)
Since BLS signatures are aggregatable, we have that the
is just an aggregate of
signature σi on tx pay,i under pk i
σ(0)
, where each of these are themselves
i
signatures on tx pay,i generated by the respective parties using
their respective secret key shares. As discussed above, signatures
are locked by simply computing a chain of aggregates
and σ(i+1)
i
i
(σ1 · σ2, σ2 · σ3, . . . , σn−1 · σn)
i.e., (cid:96)ki := σi · σi+1, (i ∈ [n − 1]), whose well-formedness can
be readily tested using the aggregate veriﬁcation algorithm of
BLS. This allows us to forego entirely the usage of general
purpose MPC, thus obtaining a concretely efﬁcient protocol.
I I I . P R E L I M I N A R I E S
We denote by λ ∈ N the security parameter and by x ←
A(in; r) the output of the algorithm A on input in using r ←
{0, 1}∗ as its randomness. We often omit this randomness
and only mention it explicitly when required. The notation
[n] denotes a set {1, . . . , n} and [i, j] denotes the set {i, i +
1, . . . , j}. We consider probabilistic polynomial time (PPT)
machines as efﬁcient algorithms.
A. Universal Composability
To model security and privacy in the presence of concurrent
executions we resort to the universal composability framework
from Canetti [40] extended to support a global setup [41]. We
refer the reader to [40] for a comprehensive discussion. We
consider the setting of static corruptions, where the adversary
must declare ahead of time which parties he wish to corrupt.
We denote the environment by E. For a real protocol Π
and an adversary A we write EXEC τ,A,E to denote the
ensemble corresponding to the protocol execution. For an ideal
functionality F and an adversary S we write EXEC F ,S,E to
denote the distribution ensemble of the ideal world execution.
Deﬁnition 1 (Universal Composability): A protocol τ UC-
realizes an ideal functionality F if for any PPT adversary A
there exists a simulator S such that for any environment E the
ensembles EXEC τ,A,E and EXEC F ,S,E are computationally
indistinguishable.
We require the cryptographic primitives with UC security.
Digital Signatures. A digital signature scheme allows one to
authenticate a message with respect to a public key. Formally,
it consists of the following triple of efﬁcient algorithms: A
key generation algorithm KGen(1λ) that takes as input the
security parameter 1λ and outputs the public/secret key pair
(pk , sk ). The signing algorithm Sign(sk , m) inputs a secret
key and a message m ∈ {0, 1}∗ and outputs a signature σ.
The veriﬁcation algorithm Vf(pk , m, σ) outputs 1 if σ is a
valid signature on m under the public key pk, and outputs
0 otherwise. We require standard notions of correctness and
unforgeability for the signature scheme [42]. Unforgeability is
formally referred to as existential unforgeability under chosen
message attack (EUF-CMA), says that a PPT adversary cannot
forge a fresh signature on a fresh message of its choice given
only the public key and access to a signing oracle (that returns
a valid signature on a message of his choice). A stronger
notion is that of strong unforgeability (sEUF-CMA) that says
the forgery can consist only of a fresh signature, irrespective
of whether the message was previously queried to the signing
oracle or not. Such a notion is known to be equivalent to the
UC formulation of security [43].
In this work we only consider signature schemes with a
deterministic signing algorithm. This is however without loss
of generality, as shown by the following (well known) lemma.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:30:49 UTC from IEEE Xplore.  Restrictions apply. 
942
, Vf) where Sign
∗ is deterministic.
Proof 1 (Sketch): The new signing algorithm Sign
Lemma 1: Let (KGen, Sign, Vf) be a signature scheme with
probabilistic Sign algorithm. Then there exists a signature
∗
scheme (KGen, Sign
∗ is deﬁned
to be Sign(sk , m; PRF(sk , m)), where PRF is a cryptographic
pseudorandom function.
Commitment Schemes. A commitment scheme is a digital
analogue of sealing a message inside an envelope. Formally,
it consists of the following tuple of efﬁcient algorithms: A
commitment generation algorithm Commit(1λ, m) that takes
as input a security parameter and a message m to commit
to, and outputs a commitment c and a corresponding opening
information d. The opening algorithm Open(c, d) takes as
input a commitment c and a opening information d and outputs
the committed message m or outputs a special symbol ⊥ if
d is not the valid opening information for the commitment
c. In addition to the standard binding and hiding properties
(who’s UC formalization can be found in [40]), we require
that the commitment scheme has unique openings. I.e. for all
commitments there exists a single valid message that causes
the Open algorithm to accept.
Non-Interactive Zero Knowledge Proofs. Let R : {0, 1}∗ ×
{0, 1}∗ → {0, 1} be a n NP-witness-relation with correspond-
ing NP-language L := {x : ∃w s.t. R(x, w) = 1}. A non-
interactive zero-knowledge proof (NIZK) [44] system for the
relation R is initialized with a setup algorithm Setup(1λ) that,
on input the security parameter, outputs a common reference
string crs and a trapdoor td. A prover can show the validity of a
statement x with a witness w by invoking P(crs, x, w), which
outputs a proof π. The proof π can be efﬁciently checked by the
veriﬁcation algorithm V(crs, x, π). We require a NIZK system
to be (1) zero-knowledge, where the veriﬁer does not learn more
than the validity of the statement x, and (2) simulation sound
extractable, if there exists an extractor algorithm E that on input
the common reference string crs, a trapdoor information td,
the statement x and the proof π, and outputs a witness w such
that (x, w) ∈ R with high probability. For formal UC-style
deﬁnition of security we refer the reader to [45].
Multi-Party Computation. The aim of a secure multi-party
computation (MPC) protocol is for the participating parties
to securely compute some function f of their private inputs.
In terms of properties, we require correctness that states that
the parties’ output is that which is deﬁned by the function.
We then require privacy that states that the only information
learned by the parties in the computation is that speciﬁed by
the function output. For a comprehensive treatment of the UC
deﬁnition of MPC we refer the reader to [46]. In this work we
require the existence of MPC protocols that are:
• Secure against an active adversary corrupting up to n−1 of
the n players, where the set of corrupted parties is determined
ahead of time (static corruption).
• Secure with aborts, i.e. the deﬁnition allows the adversary
to decide which of the honest parties obtain the output of the
computation.
The latter requirement implies that we do not assume that the
MPC protocol achieves any form of fairness or guaranteed
output delivery. These is arguably the most common ﬂavor of
MPC, for which many general-purpose efﬁcient protocols are
known (see e.g. [47] and follow-up works).
Synchrony and Communication. We assume synchronous
communication between users, where the execution of the
protocol happens in rounds. We model this via an ideal
functionality Fclock as it is done in [37], [48], where all honest
parties are required to indicate that are ready to proceed to the
next round before the clock proceeds. The clock functionality
that we consider is fully described in [41]. This means that all
entities are always aware of the given round. We also assume
the existence of secure message transmission channels between
users modelled by Fsmt.
Blockchain. We assume the existence of a blockchain B (just as
in [2], [3], [36]) that we model as a trusted append-only bulletin
board: The corresponding ideal functionality FB maintains the
chain B locally and updates it according to the transactions
between users. The functionality is also parameterized by a
transaction scheme which also speciﬁes a signature scheme, that
lets any user generate key pairs and can post a signed transaction
transferring coins from one user to another. We use the notation
tx := tx (A, B, v) to denote a transaction that sends v coins
from address A to address B. At any point in the execution,
any user U can send a distinguished message read to FB, who
sends the whole transcript of B to U. We refer the reader
to [36] for a formal deﬁnition of this functionality. Our FB
functionality also offers a timelock interface, where a particular
transaction can be assigned a expiry time t. If the global clock
is past the expiry time t, it means that the transaction has
expired and its effect on user balances, is revoked.
B. Bilinear Maps
Let (G0, G1, Gt) be three groups of order q, where q is a
λ bit prime. A pairing function e is an efﬁciently computable
function e : G0×G1 → GT , where g0 and g1 are generators of
G0 and G1 respectively. The pairing operation is bilinear if for
all u ∈ G0, v ∈ G1, a, b ∈ Z, we have e(ua, vb) = e(u, v)ab.
The pairing operation is non-degenerate if e(g1, g2) (cid:54)= 1.
BLS Signature Scheme. Let H be a hash function H :
{0, 1}∗ → G0. We brieﬂy recall the BLS aggregatable
signature [17] in Figure 3. It is well known that the scheme has
unique signature and it is strongly unforgeable in the random
oracle model if the computational Difﬁe-Hellman (CDH)
problem is hard over the bilinear group. In Appendix B, we
recall the aggregate extraction assumption from [38] (Deﬁnition
4.3), which in a later work, Coron and Naccache [49] showed
is equivalent to the CDH assumption.
We introduce a new hard problem that we call chained
aggregate extraction problem, that says that an adversary who
is given a chain of aggregate values, cannot extract any of
the aggregated values in polynomial time. This assumption
signiﬁcantly simpliﬁes our security analysis of our BLS based
PCN protocol. We formally deﬁne the problem below.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:30:49 UTC from IEEE Xplore.  Restrictions apply. 
943
KGen(1λ)
α ← Zq
h ← gα
pk := h, sk := α
1 ∈ G1
return (pk , sk )
Vf(pk , m, σ)
return 1
else return 0
Sign(sk , m)
σ := H(m)sk
return σ
σ ← (cid:89)
Agg({σi}i∈[t])
σi
i∈[t]
return σ
VfAgg({pk i}i∈[t],{mi}i∈[t], σ)
(cid:89)
i∈[t]
if (e(σ, g1) = e(H(m), pk ))
if (e(σ, g1) =
e(H(mi), pk i))
return 1
else return 0
Fig. 3: BLS signature scheme
ExpChAgExtA,G0,G1,Gt (1λ, n)
xi, yi ← Zq,∀i ∈ [n]
σi ← g
(xiyi+xi+1yi+1)
0
(σ, j) ← A({gxi
b0 := (j ∈ [n])
b1 := (σ = gxj yj
return b0 ∧ b1
1 , gyi
)