262 (0.037%)
216 (0.030%)
185 (0.026%)
163,834
160,009
151,185
Figure 11: Accuracy and false negative rate of BlackMirror’s visibility testing
Figure 12: The time taken to prepare a depth map (per frame)
while varying its resolution
testing depth resolution. Overall, for all different cases we believe
the visibility testing time is negligible (all cases are less than 0.50
millisecond), suggesting very little impact on user experience. Fur-
thermore, the precise geometry takes more time than the bounding
box geometry, as expected since it has more vertices to check. Sim-
ilarly, as the number of sensitive entities increases, the visibility
testing takes more time because it has to enumerate all of them.
Figure 13: A comparison of the depth testing performance
while varying i) the number of sensitive entities to test and
ii) testing resolution. The time is measured with a per-frame
depth testing time.
9.2 End-to-End Performance Evaluation
To understand end-to-end performance impact of BlackMirror,
we run our fully-functional BlackMirror-protected Quake II with
two participants. In particular, we evaluate if client and server over-
head are acceptable to determine if BlackMirror has low impact
on client experience and is scalable for the server to implement.
Client-side Overhead. We partition the client application into
three parts: update, predict and render, and measure average execu-
tion time of these periods, with three different settings. In particular,
the client updates the game states with server messages during the
update period, and it predicts the player state using local inputs dur-
ing the predict period. Then, for the render period, the client render
the scene on the GPU or with the software renderer. Note that for
BlackMirror, update and predict take places in the enclave and
it also performs trusted visibility testing in advance to rendering
on the GPU, which are the source of the overhead presented by
BlackMirror. For the baseline, we run unmodified game client,
which runs non-enclave update and prediction, and renders the
Figure 14: A comparison of the overhead to run a frame. (a)
Baseline runs updates and predictions without an enclave,
and renders the scene on the GPU. (b) BlackMirror runs
updates and predictions within the enclave, and performs
trusted visibility testing before rendering the scene on the
GPU. (c) Software renderer is identical to the baseline, except
that it renders the scene with a software renderer.
scene on the GPU (a). BlackMirror runs update and prediction
within the enclave, and performs trusted visibility testing before ren-
dering the scene on the GPU (b). Lastly, we run non-enclave client
with a software renderer, SwiftShader [37] (utilizing 12 threads), to
give the sense of performance overhead incurred by adopting one
of the straw man designs discussed in §5 (c). (See D2)
The result is shown on Figure 14, and overall, the evaluation
result show that that BlackMirror adds in total 0.57 ms overhead
per each frame on average. Therefore, if the native game operates
at 60 frames-per-second, i.e., takes 16ms to render each scene (com-
mon setting for modern games), BlackMirror demonstrates 58-59
frames-per-second on average, which is negligible and acceptable.
The performance overhead of BlackMirror is mainly caused by
running updates and predictions within the enclave, and perform-
ing the trusted visibility testing before rendering on the GPU. On
the other hand, software-rendering with SwiftShader [37] exhibits
34× slowdown than BlackMirror, even when running without
enclave and utilizing 12 threads.
Server-side Overhead. Since BlackMirror-based Quake II re-
quires secure channel to communicate, server performs encryption
over all packets sent to and received from clients, unlike native
Quake II. Figure 15 measures the time taken to encrypt a packet
while varying the size of packets. As shown in the figure, the en-
cryption overhead is always less than 0.23 ms (0.06 ms on average),
which should not interfere the gaming experience for 60 fps games.
10 DISCUSSIONS
Applicability to a broader range of games. Although we pro-
totype BlackMirror on Quake II, we expect that our approaches
be applicable to a broader range of games for two main reasons: (i)
its interface is general enough to be adopted by most multiplayer
Figure 15: The overhead of packet encryption at server
shooter games, and (ii) modern game engines are equipped with
features, which can be retrofitted to realize our design.
First, we investigate the client applications of latest open-source
3D multiplayer shooter games, Xonotic [56] and Red Eclipse [57]
to show that they also share the same game architecture (refer
to §2) with Quake II. In particular, within the main processing loop,
all of them performs the following operations: (a) updating the
game state with server messages, (b) predict the player state with
inputs (optionally run a physics engine), and (c) render the scene
with updated view values. From the observation, we conclude the
interfaces of BlackMirror can be smoothly integrated to these
games without intrusive changes to their architecture. Furthermore,
we expect closed-source games also follow the same architectural
footprint; therefore, BlackMirror can be applied to them, as well.
Second, we find that modern game engines including Unreal
Engine already provide in-CPU visibility testing features [58, 59],
one of the core requirements for BlackMirror, therefore the game
engine developers can easily adopt our approaches. However, note
that their goal for testing visibility on CPU is to improve the per-
formance rather than preventing wallhacks.
Advanced Rendering Techniques. Although we successfully
demonstrate a prototype of BlackMirror using nontrivial game,
it may require further efforts to be integrated to games with more
complex rendering pipelines. Firstly, modern game engines often
transform the shape of entities on GPU, e.g., geometry and tessella-
tion shaders. In order to apply BlackMirror to games, the game
developers have to use conservative trusted geometry, so that it can
tolerate possible updates to the shapes on the GPU. Secondly, an
entity behind the wall may affects the scene with complex graphics
engines. For example, the shadow of a hidden entity may appear
to the scene, or it may be a light source, so that the neighboring
pixels are enlightened. We can modify BMTest take account of
these effects when making decisions on the visibility, but we leave
specific implementations as future works.
11 LIMITATIONS
Aimbots. Aimbots automatically generates inputs (e.g., moving
mouses) to move cursors on the enemy at will, so that the attacker
can make more accurate shots. BlackMirror does not prevent
these attacks since it does not protect visible enemy states that
can be used to calculate required fake inputs, and without trusted
input devices [15, 16], it is hard to distinguish between artificial
inputs from the genuine user inputs. That said, current version
of BlackMirror will not obsolete the entire existing anti-cheat
techniques due to lacking support for other types of cheats, namely
the aimbots. Nevertheless, we believe BlackMirror is an important
step towards bringing TEE technologies to cheat prevention in
online game, and therefore eliminating over-privileged current
anti-cheat software.
Noticeability vs. visibility. In some game, the vision of a player
is hindered by environmental objects (e.g., bush or foliage) and par-
ticle effects (e.g., explosion), which partly covers sensitive entities,
or has similar colors with them. Attackers may attempt to nullify
these features by leaking their position (as far as the entities are
only partly covered) or modifying the textures so that the entities
can be easily noticed. It is hard for BlackMirror to prevent these
attacks, since the state of the entities would be declassified, unless
the entire object is hidden behind the wall, and due to lack of trusted
memory region on the GPU (for tamper-evident textures).
12 RELATED WORKS
OpenConflict [34] invents an multi-party computation (MPC) pro-
tocol for preventing maphacks in 2D RTS games. In OpenConflict,
each client computes its current visible area, and it is obliviously
sent as a query to its opponents who return a list of their units that
are overlapping with requested visible area. However, such MPC
schemes are not suitable for 3D games, where testing visibility is
much more complex. In particular, in 3D world, the visible area
is typically larger than the 2D world (imagine visible area span-
ning to almost infinity in 3D games, but cut by a certain distance
in 2D games), thus the query should be very large. Additionally,
the view is obstructed by various objects, which further compli-
cates computing visible volume itself in advance to MPC protocol.
Therefore, such an MPC protocol will likely be inefficient in 3D
games. AVM [60] provides accountability to the execution of vir-
tual machine by tamper-evident logging and deterministic replay.
Watchmen [49] uses distributed proxies for cheat prevention in
multi-player games. Watchmen focuses more on distributed proxy
architecture, instead of specific visibility testing mechanisms, e.g.,
how to precisely compute a vision set. Bauman et al. [61] show-
cased how to leverage Intel SGX technology for protecting games.
However their work mainly focus on DRM, while leaving solutions
for cheat prevention as a future work.
13 CONCLUSION
Online game cheating, particularly wallhacks, is a critical issue
for a competitive game, and anti-cheat solutions by far are funda-
mentally flawed because it is deployed on a machine where the
attacker has absolute control. This paper presented BlackMirror,
a new game design with a trusted execution environment, Intel
SGX. It leverages strong data isolation guarantees provided by SGX
to prevent wallhacks. The implementation and evaluation with
BlackMirror-protected Quake II demonstrate that BlackMirror
can enable fully functional and secure games while meeting user
experience requirements on games.
ACKNOWLEDGMENTS
We thank the anonymous reviewers and our shepherd, Yan Shoshi-
taishvili, for the insightful and thoughtful feedback which guided
the final version of this paper. This work was partly supported by
National Research Foundation (NRF) of Korea grant funded by the
Korean government MSIT (NRF-2019R1C1C1006095). The Institute
of Engineering Research at Seoul National University provided
research facilities for this work.
2020-01-03.
2019, 2019.
LA, 2018.
REFERENCES
[1] Global games market report. https://newzoo.com/products/reports/global-games-
market-report/.
[2] Report: Cheating is becoming a big problem in online gaming.
https://www.forbes.com/sites/nelsongranados/2018/04/30/report-cheating-is-
becoming-a-big-problem-in-online-gaming.
[3] Battleye: The anti-cheat gold standard. https://www.battleye.com. Accessed:
[4] Valve anti-cheat system (vac). https://support.steampowered.com/kb/7849-
RADZ-6869/#whatisvac. Accessed: 2020-01-03.
[5] Easy anti-cheat. https://www.easy.ac/en-us/. Accessed: 2020-01-03.
[6] Joel Noguera. Unveiling the underground world of anti-cheats. Recon Montreal
[7] Cheat engine. https://www.cheatengine.org/. Accessed: 2020-01-02.
[8] Joel Noguera. Creating your own wallhack. https://niemand.com.ar/2019/01/13/
creating-your-own-wallhack/, January 2019.
[9] Carl Schou. Hooking the graphics kernel subsystem. https://secret.club/2019/10/
18/kernel_gdi_hook.html, October 2019.
[10] Peter Andreasen. Deep dive into networking for unity’s fps sample game. Unite
[11] Quake 2 gpl release. https://github.com/id-Software/Quake-2.
[12] Frank McKeen, Ilya Alexandrovich, Alex Berenzon, Carlos V. Rozas, Hisham
Shafi, Vedvyas Shanbhogue, and Uday R. Savagaonkar. Innovative instructions
and software model for isolated execution. In Proceedings of the 2Nd International
Workshop on Hardware and Architectural Support for Security and Privacy, HASP
’13, pages 10:1–10:1, New York, NY, USA, 2013. ACM.
[13] Ittai Anati, Shay Gueron, Simon P Johnson, and Vincent R Scarlata. Innovative
technology for cpu based attestation and sealing.
[14] Samuel Weiser and Mario Werner. Sgxio: Generic trusted i/o path for intel sgx.
In Proceedings of the Seventh ACM on Conference on Data and Application Security
and Privacy, CODASPY ’17, 2017.
[15] S. Eskandarian, J. Cogan, S. Birnbaum, P. C. W. Brandon, D. Franke, F. Fraser,
G. Garcia, E. Gong, H. T. Nguyen, T. K. Sethi, V. Subbiah, M. Backes, G. Pellegrino,
and D. Boneh. Fidelius: Protecting user secrets from compromised browsers. In
Proceedings of the 40th IEEE Symposium on Security and Privacy (Oakland), San
Francisco, CA, May 2019.
[16] Aritra Dhar, Enis Ulqinaku, Kari Kostiainen, and Srdjan Capkun. Protection
Root-of-trust for io in compromised platforms. In Proceedings of the 2020 Annual
Network and Distributed System Security Symposium (NDSS), San Diego, CA,
February 2020.
[17] Stavros Volos, Kapil Vaswani, and Rodrigo Bruno. Graviton: Trusted execution
environments on gpus. In Proceedings of the 13th USENIX Symposium on Operating
Systems Design and Implementation (OSDI), Carlsbad, CA, October 2018.
[18] Insu Jang, Adrian Tang, Taehoon Kim, Simha Sethumadhavan, and Jaehyuk Huh.
Heterogeneous isolated execution for commodity gpus. In Proceedings of the
24th ACM International Conference on Architectural Support for Programming
Languages and Operating Systems (ASPLOS), Providence, RI, April 2019.
[19] Y. Xu, W. Cui, and M. Peinado. Controlled-channel attacks: Deterministic side
channels for untrusted operating systems. In 2015 IEEE Symposium on Security
and Privacy, San Jose, CA, May 2015.
[20] Jo Van Bulck, Nico Weichbrodt, Rüdiger Kapitza, Frank Piessens, and Raoul
Strackx. Telling your secrets without page faults: Stealthy page table-based
attacks on enclaved execution. In Proceedings of the 26th USENIX Security Sym-
posium (Security), Vancouver, Canada, August 2017.
[21] Ferdinand Brasser, Urs Müller, Alexandra Dmitrienko, Kari Kostiainen, Srdjan
Capkun, and Ahmad-Reza Sadeghi. Software grand exposure: SGX cache attacks
are practical. In 11th USENIX Workshop on Offensive Technologies (WOOT 17),
Vancouver, BC, August 2017. USENIX Association.
[22] Jo Van Bulck, Frank Piessens, and Raoul Strackx. Sgx-step: A practical attack
In Proceedings of the 2nd
framework for precise enclave execution control.
Workshop on System Software for Trusted Execution, SysTEX’17, 2017.
[23] Jo Van Bulck, Marina Minkin, Ofir Weisse, Daniel Genkin, Baris Kasikci, Frank
Piessens, Mark Silberstein, Thomas F. Wenisch, Yuval Yarom, and Raoul Strackx.
Foreshadow: Extracting the keys to the intel SGX kingdom with transient out-of-
order execution. In Proceedings of the 27th USENIX Security Symposium (Security),
Baltomore, MD, August 2018.
[24] Paul Kocher, Jann Horn, Anders Fogh, , Daniel Genkin, Daniel Gruss, Werner
Haas, Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas Prescher, Michael
Schwarz, and Yuval Yarom. Spectre attacks: Exploiting speculative execution. In
Proceedings of the 40th IEEE Symposium on Security and Privacy (Oakland), San
Francisco, CA, May 2019.
[25] Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas,
Anders Fogh, Jann Horn, Stefan Mangard, Paul Kocher, Daniel Genkin, Yuval
Yarom, and Mike Hamburg. Meltdown: Reading kernel memory from user space.
In Proceedings of the 27th USENIX Security Symposium (Security), Baltomore, MD,
August 2018.
2020-01-03.
[26] Jaehyuk Lee, Jinsoo Jang, Yeongjin Jang, Nohyun Kwak, Yeseul Choi, Changho
Choi, Taesoo Kim, Marcus Peinado, and Brent ByungHoon Kang. Hacking in
darkness: Return-oriented programming against secure enclaves. In Proceedings
of the 26th USENIX Security Symposium (Security), Vancouver, Canada, August
2017.
[27] Andrea Biondo, Mauro Conti, Lucas Davi, Tommaso Frassetto, and Ahmad-Reza
Sadeghi. The guard’s dilemma: Efficient code-reuse attacks against intel SGX. In
Proceedings of the 27th USENIX Security Symposium (Security), Baltomore, MD,
August 2018.
[28] Jaebaek Seo, Byounyoung Lee, Seongmin Kim, Ming-Wei Shih, Insik Shin, Dongsu
Han, and Taesoo Kim. Sgx-shield: Enabling address space layout randomization
for sgx programs. In Proceedings of the 2017 Annual Network and Distributed
System Security Symposium (NDSS), San Diego, CA, February 2017.
[29] Dmitrii Kuvaiskii, Oleksii Oleksenko, Sergei Arnautov, Bohdan Trach, Pramod
Bhatotia, Pascal Felber, and Christof Fetzer. Sgxbounds: Memory safety for
shielded execution. In Proceedings of the Twelfth European Conference on Computer
Systems, EuroSys ’17. ACM, 2017.
[30] Nicilas Guigo and Joel St. John. Next level cheating and leveling up mitigations.
Black Hat Europe 2014, 2014.
[31] Osiris. https://github.com/danielkrupinski/Osiris.
[32] Charlatano. https://github.com/Jire/Charlatano.
[33] Onebytewallhack. https://github.com/danielkrupinski/OneByteWallhack.
[34] E. Bursztein, M. Hamburg, J. Lagarenne, and D. Boneh. Openconflict: Preventing
real time map hacks in online games. In Proceedings of the 32nd IEEE Symposium
on Security and Privacy (Oakland), Oakland, CA, May 2011.
[35] imgui. https://github.com/ocornut/imgui.
[36] Chia che Tsai, Donald E. Porter, and Mona Vij. Graphene-sgx: A practical library
OS for unmodified applications on SGX. In Proceedings of the 2017 USENIX Annual
Technical Conference (ATC), Santa Clara, CA, July 2017.
[37] Swiftshader. https://github.com/google/swiftshader.
[38] Xigncode3. https://www.wellbia.com/home/en/pages/xigncode3/. Accessed:
[39] Riot’s approach to anti-cheat. https://technology.riotgames.com/news/riots-
approach-anti-cheat. Accessed: 2019-12-28.
[40] Carl Schou. Battleye anticheat: analysis and mitigation. https://vmcall.github.io/
reversal/2019/02/10/battleye-anticheat.html/, February 2019.
[41] Youren Shen, Hongliang Tian, Yu Chen, Kang Chen, Runji Wang, Yi Xu, Yubin
Xia, and Shoumeng Yan. Occlum: Secure and efficient multitasking inside a single
enclave of intel sgx. In Proceedings of the 25th ACM International Conference
on Architectural Support for Programming Languages and Operating Systems
(ASPLOS), Lausanne, Switzeland, April 2020.
[42] Guoxing Chen, Yinqian Zhang, and Ten-Hwang Lai. Opera: Open remote attes-
tation for intel’s secure enclave. In Proceedings of the 26th ACM Conference on
Computer and Communications Security (CCS), London, UK, November 2018.
[43] Adil Ahmad, Kyungtae Kim, Muhammad Ihsanulhaq Sarfaraz, and Byoungyoung
Lee. OBLIVIATE: A data oblivious filesystem for intel SGX. In Proceedings of the
2018 Annual Network and Distributed System Security Symposium (NDSS), San
Diego, CA, February 2018.
[44] Meni Orenbach, Pavel Lifshits, Marina Minkin, and Mark Silberstein. Eleos:
Exitless os services for sgx enclaves. In Proceedings of the 12th European Conference
on Computer Systems (EuroSys), Belgrade, Serbia, April 2017.
[45] Surenthar Selvaraj. Overview of protected file system library using software
guard extensions, 2016.
[46] Timothy Ford. Overwatch gameplay architecture and netcode. GDC 2017, 2017.
[47] Daniel Lupei, Bogdan Simion, Don Pinto, Matthew Misler, Mihai Burcea, William
Krick, and Cristiana Amza. Transactional memory support for scalable and trans-
parent parallelization of multiplayer games. In Proceedings of the 5th European
Conference on Computer Systems (EuroSys), Paris, France, April 2010.
[48] Vladimir Gajinov, Ferad Zyulkyarov, Osman S. Unsal, Adrian Cristal, Eduard
Ayguade, Tim Harris, and Mateo Valero. Quaketm: parallelizing a complex
sequential application using transactional memory. In Proceedings of the 23rd
International Conference on Supercomputing (ICS), Yorktown Heights, NY, June
2009.
[49] A. Yahyavi, K. Huguenin, J. Gascon-Samson, J. Kienzle, and B. Kemme. Watchmen:
Scalable cheat-resistant support for distributed multi-player online games. In
Proceedings of the 33st International Conference on Distributed Computing Systems
(ICDCS), 2013.
[50] Ferad Zyulkyarov, Vladimir Gajinov, Osman S. Unsal, Adrián Cristal, Eduard
Ayguadé, Tim Harris, and Mateo Valero. Atomic quake: using transactional
memory in an interactive multiplayer game server. In Proceedings of the 14th
ACM Symposium on Principles and Practice of Parallel Programming (PPOPP),
Releigh, USA, February 2009.
[51] Q2RTX. https://github.com/NVIDIA/Q2RTX.
[52] Q2PRO. https://github.com/skullernet/q2pro.
[53] Masked software occlusion culling.
maskedocclusionculling.
https://github.com/gametechdev/
[54] J. Hasselgren, M. Andersson, and T. Akenine-Möller. Masked software occlusion
culling. In Proceedings of High Performance Graphics, HPG ’16, 2016.
[55] ARB_occlusion_query. https://www.khronos.org/registry/OpenGL/extensions/
ARB/ARB_occlusion_query.txt.
[56] Xonotic. https://github.com/xonotic/xonotic.
[57] Red eclipse 2. https://github.com/redeclipse/base.
[58] Visibilty and occlusion culling. https://docs.unrealengine.com/en-US/Engine/
Rendering/VisibilityCulling/index.html.
[59] Michal Valient. Practical occlusion culling in killzone 3: Will vale — second
intention limited — contract r&d for guerrilla bv. In ACM SIGGRAPH 2011 Talks,
SIGGRAPH ’11, 2011.
[60] Andreas Haeberlen, Paarijaat Aditya, Rodrigo Rodrigues, and Peter Druschel.
Accountable virtual machines.
In Proceedings of the 9th USENIX Symposium
on Operating Systems Design and Implementation (OSDI), Vancouver, Canada,
October 2010.
[61] Erick Bauman and Zhiqiang Lin. A case for protecting computer games with
sgx. In Proceedings of the 1st Workshop on System Software for Trusted Execution,
SysTEX ’16, 2016.