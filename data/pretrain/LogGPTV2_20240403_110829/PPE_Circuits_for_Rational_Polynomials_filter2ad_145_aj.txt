to use the AutoRationalPPE tool.
D.1 Boneh Boyen IBE
In this scheme, a central authority uses its master secret key msk to
generate a secret key for a user with identity id. The user would like
to verify whether the central authority gave him a well-formed key.
We want to use AutoRationalPPE to verify whether the secret key
for user id is well-formed. Here Trusted is the set of elements in the
master public key mpk and identity id. The non-trusted elements
are the elements in the secret key skid. For the sake of completeness,
we first present the Boneh Boyen IBE scheme [25].
• Setup(1λ ) → (mpk, msk): Sample a Type-I pairing group
(G1, GT , e) of prime order p. Select a random group gen-
erator д ← G1, and random elements x, y ← Z∗
p. Output
mpk = (д, дx , дy ), msk = (x, y).
• KeyGen(msk, id) → skid: Pick a random value r ← Zp and
1/(id+x +r∗y ) )). In case (id +x +r ∗y) = 0 mod p,
output (r , д
try again with a different r.
We now describe the input to our tool in Figure 10.
We present the output generated by our tool in Figure 11. Note
that the trusted set contains 2 elements (id, r ) in Zp. We input these
elements using Zp_vars[id,r]. syntax. We describe the gates of
the final circuit at the end using Gxx notation. For PPE gates, we
mention the PPE computed by the gate. For boolean gates, we
describe the boolean logic performed by the gate.
D.2 Custom Example
In this section, we describe our custom test case 5 mentioned in Ta-
ble 1. We design the test case so that all the four rules are invoked
here. We describe the input to our tool in Figure 12, and then de-
scribe the output generated by our tool in Figures 13 to 15. For
each recursive invocation of the QSearch algorithm, the output
file describes the set of trusted and untrusted polynomials and the
rule that is applied to the problem. The gates of the final optimized
circuit are described at the end in Figure 15 using Gxx notation. For
PPE gates, we mention the PPE computed by the gate. For boolean
gates, we mention the boolean logic performed by the gate.
E ON PERFECT VERSUS SUFFICIENT
VERIFICATION
Recall that the goal of our tool is to verify U with respect to T .
As in [46, 47], we define a PPE Circuit that must achieve perfect
verification where it outputs one if and only if all input elements of
U are exactly as specified. That is, if some element F is supposed
to have the form дa+b, then it must. Perfect verification gives total
F0 = 1 in G1
F2 = y in G1
F0^id = id in G1
F0^r = r in GT
F2^id = id*y in G1
Output File Example
F0 = 1 in GT
F3 = 1/id + x + r*y in G1
F1 = x in G1
F0^r = r in G1
F1^id = id*x in G1
F0^id = id in GT
F1^r = r*x in G1
F2^r = r*y in G1
Trusted in G1: F1 = x, F2 = y, F0^id = id, F0^r = r, F1^id = id*x, F1^r = r*x,
F2^id = id*y, F2^r = r*y,
Trusted in GT: F0^id = id, F0^r = r,
Untrusted in G1: F3 = 1/id + x + r*y,
Rule 2 applied on F3 = 1/id + x + r*y. isidentity := F2^r*F0^id*F1 = I C :=
(e(F3,F2^r*F0^id*F1) = F0 AND (NOT F2^r*F0^id*F1 = I))
Execution time : 11.597542s
The circuit output by QSearch:
(((NOT F2^r*F0^id*F1 = I) AND (e(F3,F2^r*F0^id*F1) = F0 AND (NOT
F2^r*F0^id*F1 = I))) AND ACC)
Optimized Circuit:
G1 : F2^r*F0^id*F1 = I
G3 : NOT G1
G4 : G3 AND G2
G2 : e(F3,F2^r*F0^id*F1) = F0
Figure 11: Output file for Boneh Boyen IBE scheme.
Input File Example
maps G1 * G2 ->GT.
trusted_polys [F1 = a, F2 = b] in G1.
trusted_polys [F3 = b] in G2.
untrusted_polys [F4 = a*c] in G1.
untrusted_polys [F5 = a*b, F6 = c, F7 = d, F8 = d/(b + a), F9 = x, F10 = y,
F11 = (x*a + y*b), F12 = 1/(s+a)] in G2.
Figure 12: Input file for the custom example.
confidence that the untrusted elements are as they should be. It
helps applications like accountable authority IBE [40, 41] or oblivi-
ous transfer from blind IBE [42], where a malicious authority with
a master secret key might be trying to fool a user. In some cases,
the perfect verification is necessary, and thus, it is good that we
can achieve it.
However, not all applications require perfect verification: sig-
natures are a prime example. The verification equation for many
signature schemes in the literature (e.g., see Section 5 of [2]) does
not guarantee that the purported signature comes from the space
of signatures output by the signing algorithm. Instead, in some
cases, it is enough to argue that even if the purported signature
is outside of this space, an adversary could not have computed
it without knowledge of the secret key. (Some of these schemes
verify a signature with, say, five elements using a single PPE. Thus,
they do not verify that each element of the signature is correct, but
rather that all five elements – whatever they are – have the proper
relationship to each other.) We might call this concept sufficient
verification, where the requirements on the PPE Circuit are relaxed
to output one if and only if the elements of U have some special
relationship that can be verified using T . If sufficient verification
is enough for an application, it is likely to offer better efficiency.
Now that this work establishes how to automate perfect verification
for large classes of prime-order pairing-based systems, we view
Session 10C: Foundations CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2755studying how to model, search for and apply sufficient verification
as a rich area for future research.
Output File Example
F6 = c in G2
F9 = x in G2
F10 = y in G2
F12 = 1/a + s in G2
F1 = a in G1
F0 = 1 in G2
F3 = b in G2
F0 = 1 in GT
F4 = a*c in G1
F7 = d in G2
F0 = 1 in G1
F2 = b in G1
F5 = a*b in G2
F8 = d/a + b in G2
F11 = a*x + b*y in G2
Trusted in G1: F1 = a, F2 = b
Trusted in G2: F3 = b
Untrusted in G1: F4 = a*c, F5 = a*b, F6 = c, F7 = d, F8 = d/a + b, F9 = x, F10
= y, F11 = a*x + b*y, F12 = 1/a + s,
Rule 1 applied to F5 = a*b/1. C := e(F5,F0) = e(F1,F3)
Trusted in G1: F1 = a, F2 = b
Trusted in G2: F3 = b, F5 = a*b
Untrusted in G1: F4 = a*c, F6 = c, F7 = d, F8 = d/a + b, F9 = x, F10 = y, F11
= a*x + b*y, F12 = 1/a + s,
Rule 3a applied on F4 = a*c/1 and variable c. isidentity := e(F1,F0) = I, C :=
(NOT REJ)
Trusted in G1: F1 = a, F2 = b, F4 = a*c
Trusted in G2: F3 = b, F5 = a*b,
Untrusted in G1: F6 = c, F7 = d, F8 = d/a + b, F9 = x, F10 = y, F11 = a*x +
b*y, F12 = 1/a + s,
Rule 2 applied on F6 = c/1. isidentity := F1 = I C := e(F6,F1) = e(F4,F0)
Trusted in G1: F1 = a, F2 = b, F4 = a*c
Trusted in G2: F3 = b, F5 = a*b, F6 = c
Untrusted in G1: F7 = d, F8 = d/a + b, F9 = x, F10 = y, F11 = a*x + b*y, F12
= 1/a + s,
Rule 3a applied on F7 = d/1 and variable d. isidentity := REJ, C := (NOT REJ)
Trusted in G1: F1 = a, F2 = b, F4 = a*c
Trusted in G2: F3 = b, F5 = a*b, F6 = c, F7 = d,
Untrusted in G1: F8 = d/a + b, F9 = x, F10 = y, F11 = a*x + b*y, F12 = 1/a +
s,
Rule 2 applied on F8 = d/a + b. isidentity := F2*F1 = I C := (e(F8,F2*F1) =
e(F0,F7) AND (NOT F2*F1 = I))
Trusted in G1: F1 = a, F2 = b, F4 = a*c
Trusted in G2: F3 = b, F5 = a*b, F6 = c, F7 = d, F8 = d/a + b,
Untrusted in G1: F9 = x, F10 = y, F11 = a*x + b*y, F12 = 1/a + s,
Rule 3a applied on F9 = x/1 and variable x. isidentity := REJ, C := (NOT REJ)
Trusted in G1: F1 = a, F2 = b, F4 = a*c
Trusted in G2: F3 = b, F5 = a*b, F6 = c, F7 = d, F8 = d/a + b, F9 = x,
Untrusted in G1: F10 = y, F11 = a*x + b*y, F12 = 1/a + s,
Rule 3a applied on F10 = y/1 and variable y. isidentity := REJ, C := (NOT
REJ)
Trusted in G1: F1 = a, F2 = b, F4 = a*c
Trusted in G2: F3 = b, F5 = a*b, F6 = c, F7 = d, F8 = d/a + b, F9 = x, F10 = y,
Untrusted in G1: F11 = a*x + b*y, F12 = 1/a + s,
Rule 1 applied to F11 = a*x + b*y/1. C := e(F11,F0) = e(F2,F10)*e(F1,F9)
Figure 13: Output file for the custom example.
Output File Example
Trusted in G1: F1 = a, F2 = b, F4 = a*c
Trusted in G2: F3 = b, F5 = a*b, F6 = c, F7 = d, F8 = d/a + b, F9 = x, F10 = y,
F11 = a*x + b*y,
Untrusted in G1: F12 = 1/a + s,
Rule 3b applied on F12 = 1/a + s and variable s. isidentity := REJ, C := ACC
Trusted in G1: F1 = 0, F2 = b, F4 = 0,
Trusted in G2: F3 = b, F5 = 0,
Untrusted in G1: F6 = c, F7 = d, F8 = d/b, F9 = x, F10 = y, F11 = b*y, F12 =
1/s,
Rule 3a applied on F6 = c/1 and variable c. isidentity := REJ, C := (NOT REJ)
Trusted in G1: F1 = 0, F2 = b, F4 = 0,
Trusted in G2: F3 = b, F5 = 0, F6 = c,
Untrusted in G1: F7 = d, F8 = d/b, F9 = x, F10 = y, F11 = b*y, F12 = 1/s,
Rule 3a applied on F7 = d/1 and variable d. isidentity := REJ, C := (NOT REJ)
Trusted in G1: F1 = 0, F2 = b, F4 = 0,
Trusted in G2: F3 = b, F5 = 0, F6 = c, F7 = d,
Untrusted in G1: F8 = d/b, F9 = x, F10 = y, F11 = b*y, F12 = 1/s,
Rule 2 applied on F8 = d/b. isidentity := F2 = I C := (e(F8,F2) = e(F0,F7)
AND (NOT F2 = I))
Trusted in G1: F1 = 0, F2 = b, F4 = 0,
Trusted in G2: F3 = b, F5 = 0, F6 = c, F7 = d, F8 = d/b,
Untrusted in G1: F9 = x, F10 = y, F11 = b*y, F12 = 1/s,
Rule 3a applied on F9 = x/1 and variable x. isidentity := REJ, C := (NOT REJ)
Trusted in G1: F1 = 0, F2 = b, F4 = 0,
Trusted in G2: F3 = b, F5 = 0, F6 = c, F7 = d, F8 = d/b, F9 = x,
Untrusted in G1: F10 = y, F11 = b*y, F12 = 1/s,
Rule 3a applied on F10 = y/1 and variable y. isidentity := REJ, C := (NOT
REJ)
Trusted in G1: F1 = 0, F2 = b, F4 = 0,
Trusted in G2: F3 = b, F5 = 0, F6 = c, F7 = d, F8 = d/b, F9 = x, F10 = y,
Untrusted in G1: F11 = b*y, F12 = 1/s,
Rule 1 applied to F11 = b*y/1. C := e(F11,F0) = e(F2,F10)
Trusted in G1: F1 = 0, F2 = b, F4 = 0,
Trusted in G2: F3 = b, F5 = 0, F6 = c, F7 = d, F8 = d/b, F9 = x, F10 = y, F11
= b*y,
Untrusted in G1: F12 = 1/s,
Rule 3b applied on F12 = 1/s and variable s. isidentity := REJ, C := ACC
Trusted in G1: F1 = 0, F2 = b,
Trusted in G2: F3 = b, F5 = 0,
Untrusted in G1: F4 = 0, F6 = c, F7 = d, F8 = d/b, F9 = x, F10 = y, F11 = b*y,
F12 = 1/s,
Rule 1 applied to F4 = 0/1. C := F4 = I
Figure 14: Output file for the custom example (Cont’d).
Session 10C: Foundations CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2756Output File Example
Trusted in G1: F1 = 0, F2 = b, F4 = 0,
Trusted in G2: F3 = b, F5 = 0,
Untrusted in G1: F6 = c, F7 = d, F8 = d/b, F9 = x, F10 = y, F11 = b*y, F12 =
1/s,
Rule 3a applied on F6 = c/1 and variable c. isidentity := REJ, C := (NOT REJ)
Trusted in G1: F1 = 0, F2 = b, F4 = 0,
Trusted in G2: F3 = b, F5 = 0, F6 = c,
Untrusted in G1: F7 = d, F8 = d/b, F9 = x, F10 = y, F11 = b*y, F12 = 1/s,
Rule 3a applied on F7 = d/1 and variable d. isidentity := REJ, C := (NOT REJ)
Trusted in G1: F1 = 0, F2 = b, F4 = 0,
Trusted in G2: F3 = b, F5 = 0, F6 = c, F7 = d,
Untrusted in G1: F8 = d/b, F9 = x, F10 = y, F11 = b*y, F12 = 1/s,
Rule 2 applied on F8 = d/b. isidentity := F2 = I C := (e(F8,F2) = e(F0,F7)
AND (NOT F2 = I))
Trusted in G1: F1 = 0, F2 = b, F4 = 0,
Trusted in G2: F3 = b, F5 = 0, F6 = c, F7 = d, F8 = d/b,
Untrusted in G1: F9 = x, F10 = y, F11 = b*y, F12 = 1/s,
Rule 3a applied on F9 = x/1 and variable x. isidentity := REJ, C := (NOT REJ)
Trusted in G1: F1 = 0, F2 = b, F4 = 0,
Trusted in G2: F3 = b, F5 = 0, F6 = c, F7 = d, F8 = d/b, F9 = x,
Untrusted in G1: F10 = y, F11 = b*y, F12 = 1/s,
Rule 3a applied on F10 = y/1 and variable y. isidentity := REJ, C := (NOT
REJ)
Trusted in G1: F1 = 0, F2 = b, F4 = 0,
Trusted in G2: F3 = b, F5 = 0, F6 = c, F7 = d, F8 = d/b, F9 = x, F10 = y,
Untrusted in G1: F11 = b*y, F12 = 1/s,
Rule 1 applied to F11 = b*y/1. C := e(F11,F0) = e(F2,F10)
Trusted in G1: F1 = 0, F2 = b, F4 = 0,
Trusted in G2: F3 = b, F5 = 0, F6 = c, F7 = d, F8 = d/b, F9 = x, F10 = y, F11
= b*y,
Untrusted in G1: F12 = 1/s,
Rule 3b applied on F12 = 1/s and variable s. isidentity := REJ, C := ACC
G2 : e(F1,F0) = I
G3 : F1 = I
G8 : F2 = I
Optimized Circuit:
G1 : e(F5,F0) = e(F1,F3)
G4 : e(F6,F1) = e(F4,F0) G5 : F2*F1 = I G6 : e(F8,F2*F1) = e(F0,F7)
G7 : e(F11,F0) = e(F2,F10)*e(F1,F9)
G9 : e(F8,F2) = e(F0,F7) G10 : e(F11,F0) = e(F2,F10) G11 : F4 = I
G12 : NOT G2 G13 : NOT G3 G14 : G13 AND G4 G15 : NOT G5
G16 : G15 AND G6 G17 : G16 AND G7 G18 : G14 AND G17
G19 : NOT G8
G21 : G20 AND G10
G22 : G3 AND G21
G25 : G11 AND G21
G28 : G1 AND G27
G23 : G18 OR G22
G26 : G2 AND G25
G20 : G19 AND G9
G24 : G12 AND G23
G27 : G24 OR G26
Figure 15: Output file for the custom example (Cont’d).
Session 10C: Foundations CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2757