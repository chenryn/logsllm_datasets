title:Robustness Testing and Hardening of CORBA ORB Implementations
author:Jiantao Pan and
Philip Koopman and
Daniel P. Siewiorek and
Yennun Huang and
Robert Gruber and
Mimi Ling Jiang
Robustness Testing and Hardening of CORBA ORB Implementations 
Jiantao Pan, Philip Koopman 
& Daniel Siewiorek 
ECE Department  & ICES 
Carnegie Mellon  University 
Pittsburgh, PA, USA 
dps@cs. cmu. edu 
PreCache Inc. 
555 Madison Ave. 
New York, NX  USA 
Yennun Huang* 
Robert Gruber 
Mimi Ling Jiang 
AT&T Labs - Research  4733 Maripoe St. 
I80 Park Ave. 
Florham Park, NJ, USA 
Pittsburgh, 
PA, USA 
fipan, koopman}@cmu, edu  yennunhuang@yahoo. com gruber@research.att. com PI:EMAIL 
Abstract 
testing 
to 
test 
software 
technique 
Before using CORBA (Common Object Request Broker 
Architecture)  applications  in mission-critical  scenarios,  it 
is  important  to understand  the  robustness  of  the  Object 
Request  Broker  (ORB)  being  used,  which  forms  the 
platform for CORBA applications.  We have extended the 
Ballista 
the 
exception-handling  robustness  of  C++  ORB  client-side 
application interfhces, and have tested two major versions 
of three  ORB implementations  on  two operating systems, 
yielding robustness failure rates ranging from 26% to 42%. 
To improve  ORB robustness,  we  also propose  a probing 
method  to harden object  and pseudo-object related  data 
types  against  exceptional  inputs.  Using  these probes  on 
omniORB 2.8 has proven to be effective in eliminatingsome 
cases  of  robustness failures found  during  testing.  These 
results  suggest  that  CORBA  implementations  currently 
have significant  robustness  vulnerabilities,  but  that  some 
important classes ofproblems can be overcome with better 
exception-handling approaches. 
1.  Introduction 
The development of CORBA (Common Object Request 
Broker Architecture) has advanced the concept of compo- 
nent  software: diverse  software  modules  implemented  in 
different programming languages can be integrated as a dis- 
tributed system using the CORBA interface, and interact in 
a plug-and-play  manner.  Using this new component soft- 
ware model, an application can be built by assembling leg- 
acy  software  modules,  third-party  software modules, and 
custom-made  software  modules  on  a  common  CORBA 
platform connected by ORBs (Object Request Brokers), in- 
stead of developing a totally custom-made monolithic  ap- 
plication, saving both development cost and time to market. 
Many  mission-critical  systems,  such  as  aerospace/de- 
fense, banking/finance, healthcarehnsurance, e-commerce 
and telecommunication applications [ 151, have  selected a 
distributed  architecture based  upon  CORBA.  Enterprises 
This work was complctcd whcn thc author was in AT&T Labs 
and government agencies from all over the world, including 
NASA,  Boeing,  Chase  Manhattan  bank,  Motorola, 
Ericsson, and Independence Blue-Cross, are using CORBA 
in various applications, from Web-based online banking to 
cellular phone management, patient care and even applica- 
tions for the Hubble Space Telescope. Recently, the Object 
Management Group (OMG) initiated a Space Domain Task 
Force to encourage the Space and Satellite industry to fos- 
ter  the emergence of cost  effective, timely, commercially 
available and interoperable space, satellite, and ground sys- 
tem domain  software components through CORBA  tech- 
nology [ 171. While cost and development time is a common 
consideration for general purpose systems, the robustness 
of the software -the  degree to which a software component 
fimctions  correctly  in  the  presence  of  invalid  inputs  or 
stressful environmental conditions [5] - is almost always a 
major concern for mission-critical applications as the ex- 
amples listed above. It is important that these applications 
are resistant to failures caused by abnormal inputs. 
CORBA applications used in critical scenarios must be 
robust. But, the heterogeneous environment; the use and re- 
use  of  commercial  off-the-shelf,  third-party  and  legacy 
software modules; and their complex  interactions will  all 
be likely to trigger exceptions. Thus, the graceful handling 
of expected and unexpected exceptions is critical for the ro- 
bustness of CORBA-based systems. 
CORBA applications are built upon an Object Request 
Broker (ORB) interface. The ORB accepts requests from 
CORBA applications, processes the requests, and manages 
the  communication  among  different objects, applications 
and ORBs.  The robustness of the ORB is very  important 
since the ORB is the operating platform of CORBA appli- 
cations and the venue for a CORBA software component to 
communicate and interact with the rest  of the system and 
the outside world. Developers of critical  applications will 
often need to know the robustness of candidate ORB imple- 
mentations prior  to deciding which  one to  use. However, 
methods  to  evaluate  CORBA  ORB  robustness  are  rare. 
0-7695-1101-5/01 $10.00 0 2001 IEEE 
14 1 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:01:43 UTC from IEEE Xplore.  Restrictions apply. 
to  evaluate  the  robustness  of  ORB 
implementations. 
Robust behaviors 
This paper makes three contribu- 
tions. First, this paper quantitatively 
measures  and  compares  the  excep- 
tion-handling robustness of CORBA 
ORB implementations using the Bal- 
lista robustness testing methodology 
[9].  Second,  some  common  excep- 
tion-handling  robustness  problems 
of  the  ORB  implementations  under  test  are  identified. 
Third, methods to improve the robustness of ORB excep- 
tion-handling  robustness  are  proposed  and  evaluated.  A 
version of the Ballista testing tool has been  implemented 
for testing C++ ORBS and used to study two major versions 
of three ORB products on two operating systems. The oper- 
ations tested  are selected from CORBA 2.1  standard  [ 181. 
In the text that follows, Section 2 details the testing meth- 
odology, Section 3 discusses the experimental setup, Sec- 
tion 4 gives results, analysis and suggestions on improving 
ORB robustness, and Section 5 lists related work. Conclu- 
sions can be found in Section 6. 
2. Methodology 
Many factors can contribute to the robustness of a soft- 
ware component. Although stressful environmental condi- 
tions are important, we focus on measuring how gracefully 
a software module under test behaves under exceptional in- 
puts.  Typically, two methods  are  used  to  handle  excep- 
tional  input  situations:  retuming  error-retum  codes  and 
raising exceptions. Error-return codes are used extensively 
in  software  implemented  using  the  C  language,  such  as 
POSIX standard [6] functions and system calls in many op- 
erating systems. Raising exceptions is used as the standard 
reporting and handling  mechanism  for exceptional inputs 
in the CORBA standard [ 181 for C++ and Java mappings. In 
this study, we test and measure the exception-handling ro- 
bustness of c + +  ORB implementations. 
2.1 Metric 
Previous Ballista work  [9] proposed a way to measure 
the robustness of software modules. In this work we extend 
the same approach to measure CORBA ORB robustness by 
testing API calls. 
The CORBA standard defines a common API for ORB 
vendors to implement. This API defines a collection of op- 
erations that a client or server object can request the ORB to 
perform on behalf of a user program. The CORBA standard 
has no restrictions on how the vendors should implement 
the operations specified in the standard. However, it does 
Successful return (no exceptions) 
Raise CORBA exception 
Computer crash (Catastrophic failure) 
Thread hang (Restart failure) 
Thread abort (Abort failure) 
Raise unknown exception 
False success (Silent failure) 
Misleading error information (Hindering failure) 
have requirements on how an ORB should perform under 
abnormal input situations: 
“The ORB manages the control transfer and data 
transfer to the object implementation and back to the 
client. In the event that the ORB cannot complete the 
invocation, an exception response is provided.” [ 181 
“If an abnormal condition occurs during the per- 
formance of a request, an exception is returned.” [ 181 
The above excerpts from the CORBA standard clearly 
state that an ORB operation is robust under exceptional in- 
puts if the operation can identify the exceptional inputs and 
raise  exceptions.  However,  the  exceptions  should  be  de- 
fined and reflect the actual exceptional situations. We con- 
sider raising unknown exceptions to be non-robust, because 
no useful information is given for error recovery and there 
is no guarantee that the ORB is in a consistent state when an 
unknown exception is thrown. 
lists 
Table  1 
the  possible  robust  behaviors  and 
non-robust behaviors that may occur in testing ORB imple- 
mentations, and maps them to the existing Ballista CRASH 
scale metric [9]. Among the listed robustness failures, com- 
puter crashes, thread hangs, thread aborts and unknown ex- 
ceptions can be  automatically  detected by  Ballista. False 
successes and misleading  error retums  cannot be  discov- 
ered in an automated manner using the Ballista hamess and 
are not measured in this study. More discussion about false 
successes (i.e. silent failures) and how to estimate them can 
be found in [9]. In summary, the items highlighted in bold- 
face in Table 1  are the responses that we expect to find in 
testing the robustness of CORBA ORE3 implementations. 
2.2 CORBA ORB robustness testing architecture 
We  adapted  the  Ballista  software  robustness  testing 
methodology to evaluate ORB implementation robustness. 
The Ballista testing framework  is designed  to test  COTS 
(Commercial Off-The-Shelf) software modules for excep- 
tion-handling robustness problems triggered by invalid in- 
puts. 
Figure  1  shows the  CORBA ORB testing architecture 
using  Ballista.  The  Ballista  server  performs  client  code 
generation and test case generation. The test manager of the 
Ballista client iterates through test  cases and manages test 
142 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:01:43 UTC from IEEE Xplore.  Restrictions apply. 
I 
I 
I 
I 
I 
I 
I 
I I 
I 
I 
I 
I 
I ;I 
ballista.ece.cmu.edu 
I 
Figure 1.  CORBA testing architecture using Ballista. 
test 
Exceptions  thrown  by  the  ORB operation 
during testing are caught and analyzed by 
the exception-handling()  section. 
The  different  levels  of  exception  han- 
dling are shown in Figure 3. Based on the 
CORBA standard, CORBA-defined excep- 
tions  are  caught  and  categorized  into 
C0RBA::SystemException 
and 
CORBA: :Exception. Ifthe ORB opera- 
tion  under 
these 
CORBA-defined  exceptions,  it  is  consid- 
ered robust. The low-level exception catch- 
ing  makes 
sure  all  other  unknown 
exceptions  which  are  not  defined 
in 
CORBA  standard  are  caught,  which  are 
classified as robustness failures. 
raises 
only 
case set-up, response monitoring and test case cleanup. The 
module-under-test in the Ballista architecture is in this case 
a CORBA client. In testing, the module-under-test commu- 
nicates and interacts as necessary with the CORBA server 
object via the CORBA ORB interface. 
For  each  test  case,  the  test  manager  spawns a  corre- 
sponding module-under-test thread, and monitors the status 
of  this  child  thread.  Figure  2  shows  a  generic  mod- 
ule-under-test  in  pseudo-code  form.  The  initialization() 
part initiates the ORB and creates necessary variables to be 
used  during 
testing  process.  The  parame- 
ter-instantiation(parameter-list) procedure  creates an  in- 
stance of each parameter from the values specified in the 
test case database. The actual call to the operation under test 
in  ORB-operation-invocation(parameter-list). 
appears 
the 
module-under-test( 
initialization ( )  ; 
parameter - instantiation(parameter-list); 
ORB-operation_invocation(parameter-list); 
. . .  
exception-handlingo ; 
1 
Figure 2.  module-under-test pseudo-code. 
//usercatches 
catch  (const CORBA::SystemException& se) 
catch  (const CORBA::Exception& e) 
//low-level exception catches 
catch  ( .  . . )  
2.3 Test case inheritance 
A test case inheritance scheme is used to maximize the 
reuse of test cases. Most ORB operations use CORBA spe- 
cific  data  types  as  parameters.  For  c + +   mappings,  the 
CORBA specific data types are eventually mapped to C++ 
language data structures. CORBA : : Flags, for example, is 
mapped  to  unsigned long in  the  C++  language.  We 
have  designed  an  inheritance  hierarchy  to  structure 
CORBA data types. A child data type inherits test cases de- 
fined  in its parent  data type  and expands the parent  data 
type by providing test cases specific to the child. As a gen- 
eral rule, a child data type usually expands its parent data 
type in value range or semantics. In the example inheritance 
tree shown in Figure 4, data type CORBA : : Flags inherits 
all test cases (e.g. MAX-UNS IGNED-LONG) defined in the 
parent  data type  unsigned long (which also inherits 
test cases from its parent data type unsigned int), and 
adds ARG-IN, ARG-OUT, ARG-INOUT, etc., as its spe- 
cific test  cases. These test  cases for CORBA related  data 
types have been selected based  on the CORBA specifica- 
tion. 
unsigned short 1 
[unsignedint] 
I  unsignedlong  I 
Figure 3.  Exception catching levels. 
Figure 4.  Sample test case inheritance. 
143 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:01:43 UTC from IEEE Xplore.  Restrictions apply. 
3. Experimental setup 
The Ballista CORBA client has been  implemented  for 
two major versions of three ORB implementations for the 
C++ language mapping on Solaris and Linux platforms. 
3.1 ORB platforms under test 
There are many ORB implementations available, form- 
ing  a  potential  rich  set  of  candidates  to  conducting  our 
study. We  chose Orbix, omniORB  and VisiBroker  as the 
candidate platforms  based  on popularity  and availability. 
Specifically, the following ORBs were tested: 
Orbix 3.0.1 and Orbix 2000 
omniORB 2.8 and omniORB 3.0 
VisiBroker 3.3 and VisiBroker 4.0 
Orbix and VisiBroker are commercial implementations, 
while omniORB is freely available under GNU public li- 
cense.  Orbix 2000  and VisiBroker  4.0 were  tested  using 
evaluation downloads from the vendor web sites, while ear- 
lier versions were tested using existing licensed copies. All 
ORBs were tested on a Sparc workstation running Solaris 
5.6 to  facilitate  fair comparisons.  Orbix 2000, omniORB 
3.0 and VisiBroker 4.0 were also tested on a Pentium ma- 
chine 
(kernel  version 
2.2.14-5.0smp). The earlier versions of ORBS are not tested 
on the  Linux platform  because VisiBroker  3.3 and Orbix 
3.0.1 do not have publicly available Linux releases. 
running  RedHat  Linux  6.2 
3.2 Test set 
in 
interfaces 
A subset  of basic ORB operations defined  in CORBA 
standard 2.1 [ 181 was chosen as the test set. The test set in- 
cludes operations defined in basic interfaces, such as most 
CORBA: :Request, 
operations 
CORBA::NVList,CORBA::Context,CORBA::ORB 
and CORBA: :Object, which appear in Chapter 4,5, and 