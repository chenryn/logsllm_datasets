### 第13章

#### 13.2.8 随机数的选择
随机数的具体内容通常是不透明的，并且与具体实现有关。然而，性能、安全性和便捷性都取决于明智的选择。

RFC 2617建议使用以下假想的随机数公式：
```
BASE64(time-stamp H(time-stamp ":" ETag ":" private-key))
```
其中，`time-stamp`是服务器生成的时间戳或其他唯一值，`ETag`是请求实体相关的HTTP `ETag`头部值，`private-key`是只有服务器知道的数据。

通过这种形式的随机数，服务器可以在接收到客户端的认证头部后重新计算散列部分。如果计算结果与头部中的随机数不符，或者时间戳不够新，则拒绝请求。这种方式可以限制随机数的有效持续时间。

包含`ETag`可以防止对已更新资源版本的重放攻击。需要注意的是，虽然在随机数中包含客户端IP地址可能有助于限制特定客户端重用随机数，但这会破坏代理集群的工作。在代理集群中，来自同一用户的多个请求可能会经过不同的代理传输，而IP地址欺骗也相对容易实现。

实现可以选择不接受以前使用过的随机数或摘要，以防止重放攻击。对于POST或PUT请求，可以使用一次性随机数或摘要；而对于GET请求，则可以使用基于时间戳的随机数。更多关于随机数选取的实际安全问题请参见第13.5节。

#### 13.2.9 对称认证
RFC 2617扩展了摘要认证机制，允许客户端对服务器进行认证。这是通过提供客户端随机值来实现的，服务器根据其对共享保密信息的正确理解生成正确的响应摘要，并将此摘要返回给客户端。

这种对称认证方式被标准化为RFC 2617。为了与原有RFC 2069标准保持后向兼容性，它是可选的，但由于它提供了重要的安全提升，强烈建议所有现代客户端和服务器实现完整的RFC 2617特性。特别是当提供了`qop`指令时，必须执行对称认证；而没有`qop`指令时则不要求执行对称认证。

响应摘要的计算方法类似于请求摘要，但由于响应中没有方法且报文实体数据不同，因此只有`A2`部分有所不同。表13-6和表13-7对比了请求和响应摘要中`A2`的计算方法。

**表13-6 算法中A2的定义（请求摘要）**
| qop | A2 |
| --- | --- |
| 未定义 | `:` |
| auth | `:` |
| auth-int | `::H()` |

**表13-7 算法中A2的定义（响应摘要）**
| qop | A2 |
| --- | --- |
| 未定义 | `:` |
| auth | `:` |
| auth-int | `::H()` |

`cnonce`值和`nc`值必须是本报文所响应的客户端请求中的相应值。如果指定了`qop="auth"`或`qop="auth-int"`，就必须提供响应`auth`、`cnonce`和`nonce`计数指令。

#### 13.3 增强保护质量
可以通过三种摘要头部提供`qop`字段：`WWW-Authenticate`、`Authorization`和`Authentication-Info`。通过`qop`字段，客户端和服务器可以协商不同类型及质量的保护。例如，某些事务可能需要检查报文主体的完整性，即使这会显著降低传输速度。

服务器首先在`WWW-Authenticate`头部输出由逗号分隔的`qop`选项列表。然后客户端从中选择一个支持且满足需求的选项，并将其放在`Authorization`的`qop`字段中回送给服务器。

`qop`字段是可选的，但仅在后向兼容原有RFC 2069规范的情况下才是可选的。现代所有的摘要实现都应该支持`qop`选项。

RFC 2617定义了两种保护质量的初始值：表示认证的`auth`和带有报文完整性保护的认证`auth-int`。将来可能还会出现其他`qop`选项。

##### 13.3.1 报文完整性保护
如果使用了完整性保护（`qop="auth-int"`），`H（实体的主体部分）`是对实体主体部分的散列，而不是报文主体部分的散列。对于发送者，在应用任何传输编码之前计算；对于接收者，在去除所有传输编码之后计算。注意，对于任何多部分的内容类型，多部分边界和每部分中嵌入的头部都要包含在内。

##### 13.3.2 摘要认证首部
基本认证和摘要认证协议都包含了`WWW-Authenticate`首部承载的授权质询和`Authorization`首部承载的授权响应。摘要认证还添加了可选的`Authentication-Info`首部，这个首部在成功认证后发送，用于实现三步握手机制并传送下一个随机数。表13-8给出了基本认证和摘要认证的首部。

**表13-8 HTTP认证首部**
| 阶段 | 基本认证 | 摘要认证 |
| --- | --- | --- |
| 质询 | `WWW-Authenticate: Basic realm=""` | `WWW-Authenticate: Digest realm="" nonce="" [domain=""] [opaque=""] [stale=] [algorithm=] [qop=""] []` |
| 响应 | `Authorization: Basic username=""` | `Authorization: Digest username="" realm="" nonce="" uri= response="" [algorithm=] [opaque=""] [cnonce=""] [qop=] [nc=] []` |
| Info | n/a | `Authentication-Info: nextnonce="" [qop=""] [rspauth=""] [cnonce=""] [nc=]` |

摘要认证首部比基本认证复杂得多。详细说明请参见附录F。

#### 13.4 应该考虑的实际问题
使用摘要认证时需要考虑几个实际问题。本节讨论了一些关键点。

##### 13.4.1 多重质询
服务器可以对某个资源发起多重质询。例如，如果服务器不了解客户端的能力，可以同时提供基本认证质询和摘要认证质询。客户端面对多重质询时，必须以支持的最强质询机制应答。

质询本身可能包含由逗号分隔的认证参数列表。如果`WWW-Authenticate`或`Proxy-Authenticate`首部包含多个质询，或者提供了多个`WWW-Authenticate`首部，用户代理在解析这些首部字段值时需特别小心。许多浏览器只支持基本认证，要求这是提交给它的第一种认证机制。

在提供认证选项范围的情况下，安全性上存在明显的“最薄弱环节”。只有当基本认证是最低可接受的认证方式时，服务器才应该包含它，管理员还应警告用户，即使运行了不同层次的安全措施，系统间使用相同密码也存在一定危险性。

##### 13.4.2 差错处理
在摘要认证中，如果某个指令或其值使用不当，或者缺少必要指令，应使用`400 Bad Request`响应。

如果请求的摘要不匹配，应记录一次登录失败。某客户端连续多次失败可能表明有攻击者正在猜测密码。

认证服务器必须确保`URI`指令指定的资源与请求行中指定的资源相同。如果不一致，服务器应返回`400 Bad Request`错误。这可能是攻击迹象，因此服务器设计者可能需要记录此类错误。这个字段的内容与请求URL中的内容重复，以应对中间代理可能对客户端请求进行的修改。修改后的请求计算出的摘要可能与客户端计算的摘要不同。

##### 13.4.3 保护空间
`域`值与被访问服务器的标准根URL结合在一起，定义了保护空间。通过域可以将服务器上的受保护资源划分为一组保护空间，每个空间都有自己的认证机制和/或授权数据库。`域`值是一个字符串，通常由原始服务器分配，可能具有认证方案特有的附加语义。可能存在多个授权方案相同但域不同的质询。

保护空间确定了可以自动应用证书的区域。如果前面的某条请求已被授权，在一段时间内，该保护空间中的所有其他请求都可以重用同一个证书，时间的长短由认证方案、参数和/或用户喜好决定。除非认证方案另有定义，否则单个保护空间不能扩展到其服务器范围之外。

对保护空间的具体计算取决于认证机制：
- **基本认证**：客户端假设请求URI中或其下的所有路径都与当前质询处于同一个保护空间内。客户端可以预先提交对此空间中资源的认证，无需等待来自服务器的另一条质询。
- **摘要认证**：质询的`WWW-Authenticate: domain`字段对保护空间作了更精确的定义。`domain`字段是一个用引号括起来的、中间由空格分隔的URI列表。通常认为，`domain`列表中的所有URI和逻辑上处于这些前缀之下的所有URI都在同一个保护空间中。如果没有`domain`字段，或者此字段为空，质询服务器上的所有URI都在保护空间内。

##### 13.4.4 重写URI
代理可以通过改变URI语法而不改变所描述的实际资源的方式来重写URI。例如：
- 可以对主机名进行标准化，或用IP地址取代；
- 可以用“%”转义形式取代嵌入的字符；
- 如果某类型的一些附加属性不会影响从特定原始服务器获取资源，可以将其附加或插入到URI中。

由于代理可以修改URI且摘要认证会检查URI值的完整性，如果进行了任意一种修改，摘要认证就会被破坏。更多信息参见13.2.4节。

##### 13.4.5 缓存
共享缓存收到包含`Authorization`首部的请求和转接该请求产生的响应时，除非响应中提供了下列两种`Cache-Control`指令之一，否则一定不能将该响应作为对任何其他请求的应答使用：
- 如果原始响应中包含`Cache-Control: must-revalidate`，缓存可以在应答后续请求时使用该响应的实体部分，但必须先用新请求的请求首部与原始服务器再次进行验证，以便原始服务器对新请求进行认证。
- 如果原始响应中包含`Cache-Control: public`，在对任意后续请求的应答中都可以返回响应的实体部分。

#### 13.5 安全性考虑
RFC 2617总结了HTTP认证方案固有的一些安全风险。本节描述了其中的部分风险。

##### 13.5.1 首部篡改
为了提供一个简单明了的防首部篡改系统，要么进行端到端加密，要么对首部进行数字签名——最好是两者的结合！摘要认证的重点在于提供一种防篡改认证机制，但并不一定要将这种保护扩展到数据上去。具有一定保护级别的首部只有`WWW-Authenticate`和`Authorization`。

##### 13.5.2 重放攻击
在当前上下文中，重放攻击指的是有人将从某个事务中窃取的认证证书用于另一个事务。尽管对GET请求来说这也是个问题，但为POST和PUT请求提供一种简单的方式来避免重放攻击是非常必要的。在传输表单数据的同时，成功重放原先用过的证书会引发严重的安全问题。

为了使服务器能够接受“重放的”证书，还必须重复发送随机数。缓解这个问题的方法之一是让服务器生成的随机数包含根据客户端IP地址、时间戳、资源`ETag`和私有服务器密钥算出的摘要。这样，IP地址和一个短小超时值的组合会给攻击者造成很大的障碍。

但这种解决方案有一个重要缺陷。我们之前讨论过，用客户端IP地址创建随机数会破坏经过代理集群的传输。在这类传输中，来自单个用户的多个请求可能会穿过不同的代理。而且，IP欺骗也并不难实现。

完全避免重放攻击的方法是为每个事务使用唯一的随机数。在这种实现方式中，服务器会为每个事务发布唯一的随机数和一个超时值。发布的随机数只对指定的事务有效，且只在超时值的持续区间内有效。这种方式会增加服务器的负担，但这种负担可忽略不计。

##### 13.5.3 多重认证机制
服务器支持多重认证机制（如基本认证和摘要认证）时，通常会在`WWW-Authenticate`首部提供选项。由于没有要求客户端选择功能最强的认证机制，所以得到的认证效果就和功能最弱的认证方案差不多。

要避免这个问题，最直接的方法是让客户端总是选择可用认证方案中功能最强的那个。如果无法实现（因为大部分人使用的都是商业化客户端），唯一的选择就是使用一个只维护最强认证方案的代理服务器。但只有在已知所有客户端都支持所选认证方案的区域中才能采用这种方式——比如，在公司网络中。

##### 13.5.4 词典攻击
词典攻击是典型的密码猜测型攻击方式。恶意用户对某个事务进行窃听，并对随机数/响应对使用标准的密码猜测程序。如果用户使用的是相对简单的密码，且服务器使用的也是简单的随机数，很可能会找到匹配项。如果没有密码过期策略，只要有足够的时间和破解密码所需的一次性费用，就很容易搜集到足够多的密码，造成实质性的破坏。

除了使用复杂的难以破译的密码和合适的密码过期策略外，确实没有什么好方法可以解决这个问题。

##### 13.5.5 恶意代理攻击和中间人攻击
现在很多互联网流量都会在某个地方流经代理。随着重定向技术和拦截代理的出现，用户甚至可能意识不到他们的请求穿过了某个代理。如果这些代理中有一个是恶意的或容易被入侵的，就会使客户端置于中间人攻击之下。