314 ｜ 第13章
13.2.8 随机数的选择
随机数的内容不透明，而且与实现有关。但性能、安全性和便捷性的优劣都取决于
明智的选择。
RFC 2617建议采用这个假想的随机数公式：
BASE64(time-stamp H(time-stamp ":" ETag ":" private-key))
其中time-stamp是服务器产生的时间或其他不会重复的值，ETag是与所请求实
体有关的HTTP ETag首部的值，private-key是只有服务器知道的数据。
有了这种形式的随机数，服务器就可以在收到客户端的认证首部之后重新计算散列
部分，如果结果与那个首部的随机数不符，或者时间戳的值不够新，就拒绝请求。
服务器可以通过这种方式来限制随机数的有效持续时间。
包含Etag可以防止对已更新资源版本的重放请求。（注意，在随机数中包含客户端
的IP地址，服务器好像就可以限制原来获得此随机数的客户端重用这个随机数了，
但这会破坏代理集群的工作。使用代理集群时，来自单个用户的多条请求通常会经
过不同的代理进行传输，而且IP地址欺骗实现起来也不是很难。）
实现可以选择不接受以前使用过的随机数或摘要，以防止重放攻击。实现也可以选
择为POST或PUT请求使用一次性的随机数或摘要，为GET请求使用时间戳。
会影响到随机数选取的一些实际安全问题参见13.5节。
13.2.9 对称认证
RFC 2617扩展了摘要认证机制，允许客户端对服务器进行认证。这是通过提供客户
端随机值来实现的，服务器会根据它对共享保密信息的正确了解生成正确的响应摘
要。然后，服务器在Authorization-Info首部中将此摘要返回给客户端。
这种对称认证方式被标准化为RFC 2617。为了与原有RFC 2069标准后向兼容，它
是可选的，但由于它提供了一些重要的安全提升机制，强烈推荐现今所有的客户端
和服务器都要实现全部RFC 2617特性。特别是，只要提供了qop指令，就要求执
行对称认证，而没有qop指令时则不要求执行对称认证。
响应摘要的计算方法与请求摘要类似，但由于响应中没有方法，而且报文实体数据
有所不同，所以只有报文主体信息A2不同。表13-6和表13-7对比了请求和响应摘
要中A2的计算方法。 298
摘要认证 ｜ 315
表13-6 算法中A2的定义（请求摘要）
qop A2
未定义 :
auth :
auth-int ::H()
表13-7 算法中A2的定义（响应摘要）
qop A2
未定义 :
auth :
auth-int ::H()
cnonce值和nc值必须是本报文所响应的客户端请求中的相应值。如果指定了
qop="auth"或qop="auth-int"，就必须提供响应auth、cnonce和nonce计数指令。
13.3 增强保护质量
可以在三种摘要首部中提供qop字段：WWW-Authenticate、Authorization和
Authentication-Info。
通过qop字段，客户端和服务器可以对不同类型及质量的保护进行协商。比如，即
便会严重降低传输速度，有些事务可能也要检查报文主体的完整性。
服务器首先在WWW-Authenticate首部输出由逗号分隔的qop选项列表。然后客
户端从中选择一个它支持且满足其需求的选项，并将其放在Authorization的
qop字段中回送给服务器。
qop字段是可选的，但只是在后向兼容原有RFC 2069规范的情况下才是可选的。
现代所有的摘要实现都应该支持qop选项。
RFC 2617定义了两种保护质量的初始值：表示认证的auth，带有报文完整性保护
的认证auth-int。将来可能还会出现其他qop选项。
13.3.1 报文完整性保护
如果使用了完整性保护（qop="auth-int"），H（实体的主体部分）就是对实体主
体部分，而不是报文主体部分的散列。对于发送者，要在应用任意传输编码方式之
前计算；而对于接收者，则应在去除所有传输编码之后计算。注意，对于任何含有
299 多部份的内容类型来说，多部分的边界和每部分中嵌入的首部都要包含在内。
316 ｜ 第13章
13.3.2 摘要认证首部
基本认证和摘要认证协议都包含了WWW-Authenticate首部承载的授权质询、
Authorization首部承载的授权响应。摘要认证还添加了可选的Authorization-
Info首部，这个首部是在成功认证之后发送的，用于实现三步握手机制，并传送下
一个随机数。表13-8给出了基本认证和摘要认证的首部。
表13-8 HTTP认证首部
阶段 基 本 摘 要
质询 WWW-Authenticate: Basic WWW-Authenticate: Digest
realm="" realm=""
nonce=""
[domain=""]
[opaque=""]
[stale=]
[algorithm=]
[qop=""]
[]
响应 Authorization: Basic Authorization: Digest
 username=""
realm=""
nonce=""
uri=
response=""
[algorithm=]
[opaque=""]
[cnonce=""]
[qop=]
[nc=]
[]
Info n/a Authentication-Info:
nextnonce=""
[qop=""]
[rspauth=""]
[cnonce=""]
[nc=]
摘要认证首部要复杂得多。详细介绍参见附录F。
13.4 应该考虑的实际问题
使用摘要认证时需要考虑几件事情。本节讨论了其中一些问题。 300
摘要认证 ｜ 317
13.4.1 多重质询
服务器可以对某个资源发起多重质询。比如，如果服务器不了解客户端的能力，就
可以既提供基本认证质询，又提供摘要认证质询。客户端面对多重质询时，必须以
它所支持的最强的质询机制来应答。
质询自身可能会包含由逗号分隔的认证参数列表。如果WWW-Authenticate或
Proxy-Authenticate首部包含了多个质询，或者提供了多个WWW-Authenticate
首部，用户Agent代理在解析WWW-Authenticate或Proxy-Authenticate首部
字段值时就要特别小心。注意，很多浏览器只支持基本认证，要求这是提交给它的
第一种认证机制。
在提供了认证选项范围的情况下，安全问题上就会存在明显的“最薄弱环节”。只有
当基本认证是最低可接受认证方式时，服务器才应该包含它，而且管理员还应该警
告用户，即使运行了不同层次安全措施，系统间使用相同密码也存在一定危险性。
13.4.2 差错处理
在摘要认证中，如果某个指令或其值使用不当，或者缺少某个必要指令，就应该使
用响应400 Bad Request。
如果请求的摘要不匹配，就应该记录一次登录失败。某客户端连续多次失败可能说
明有攻击者正在猜测密码。
认证服务器一定要确保URI指令指定的资源与请求行中指定的资源相同。如果不
同，服务器就应该返回400 Bad Request错误。（这可能是一种攻击的迹象，因此服
务器设计者可能会考虑将此类错误记录下来。）这个字段包含的内容与请求URL中
的内容是重复的，用来应对中间代理可能对客户端请求进行的修改。这个经过修改
（但估计语义是等价的）的请求计算后得到的摘要可能会与客户端计算出的摘要有所
不同。
13.4.3 保护空间
域值，与被访问服务器的标准根URL结合在一起，定义了保护空间。
通过域可以将服务器上的受保护资源划分为一组保护空间，每个空间都有自己的认
301 证机制和/或授权数据库。域值是一个字符串，通常由原始服务器分配，可能会有
认证方案特有的附加语义。注意，可能会有多个授权方案相同，而域不同的质询。
保护空间确定了可以自动应用证书的区域。如果前面的某条请求已被授权，在一段
318 ｜ 第13章
时间内，该保护空间中所有其他请求都可以重用同一个证书，时间的长短由认证方
案、参数和/或用户喜好来决定。除非认证方案进行了其他定义，否则单个保护空
间是不能扩展到其服务器范围之外的。
对保护空间的具体计算取决于认证机制。
• 在基本认证中，客户端会假定请求URI中或其下的所有路径都与当前的质询处
于同一个保护空间内。客户端可以预先提交对此空间中资源的认证，无需等待来
自服务器的另一条质询。
• 在摘要认证中，质询的WWW-Authenticate:domain字段对保护空间作了更精
确的定义。domain字段是一个用引号括起来的、中间由空格分隔的URI列表。
通常认为，domain列表中的所有URI和逻辑上处于这些前缀之下的所有URI，
都位于同一个保护空间中。如果没有domain字段，或者此字段为空，质询服务
器上的所有URI就都在保护空间内。
13.4.4 重写URI
代理可以通过改变 URI 语法，而不改变所描述的实际资源的方式来重写 URI。
比如：
• 可以对主机名进行标准化，或用IP地址来取代；
• 可以用“%”转义形式来取代嵌入的字符；
• 如果某类型的一些附加属性不会影响从特定原始服务器上获取资源，就可以将其
附加或插入到URI中。
代理可修改URI，而且摘要认证会检查URI值的完整性，所以如果进行了任意一种
修改，摘要认证就会被破坏。更多信息参见13.2.4节。
13.4.5 缓存
共享的缓存收到包含Authorization首部的请求和转接那条请求产生的响应时，
除非响应中提供了下列两种Cache-Control指令之一，否则一定不能将那条响应
作为对任何其他请求的应答使用。
• 如果原始响应中包含有Cache-Control指令must-revalidate，缓存可以在
应答后继请求时使用那条响应的实体部分。但它首先要用新请求的请求首部，与
原始服务器再次进行验证，这样原始服务器就可以对新请求进行认证了。
• 如果原始响应中包含有Cache-Control指令public，在对任意后继请求的应 302
答中都可以返回响应的实体部分。
摘要认证 ｜ 319
13.5 安全性考虑
RFC 2617总结了HTTP认证方案固有的一些安全风险，这是很令人钦佩的。本节描
述了其中的部分风险。
13.5.1 首部篡改
为了提供一个简单明了的防首部篡改系统，要么就得进行端到端的加密，要么就得
对首部进行数字签名——最好是两者的结合！摘要认证的重点在于提供一种防篡改
认证机制，但并不一定要将这种保护扩展到数据上去。具有一定保护级别的首部只
有WWW-Authenticate和Authorization。
13.5.2 重放攻击
在当前的上下文中，重放攻击指的就是有人将从某个事务中窃取的认证证书用于另
一个事务。尽管对GET请求来说这也是个问题，但为POST和PUT请求提供一种
简单的方式来避免重放攻击才是非常必要的。在传输表单数据的同时，成功重放原
先用过的证书会引发严重的安全问题。
因此，为了使服务器能够接受“重放的”证书，还必须重复发送随机数。缓解这个
问题的方法之一就是让服务器产生的随机数包含（如前所述）根据客户端IP地址、
时间戳、资源Etag和私有服务器密钥算出的摘要。这样，IP地址和一个短小超时值
的组合就会给攻击者造成很大的障碍。
但这种解决方案有一个很重要的缺陷。我们之前讨论过，用客户端IP地址来创建随
机数会破坏经过代理集群的传输。在这类传输中。来自单个用户的多条请求可能会
穿过不同的代理。而且，IP欺骗也并不难实现。
一种可以完全避免重放攻击的方法就是为每个事务都使用一个唯一的随机数。在这
种实现方式中，服务器会为每个事务发布唯一的随机数和一个超时值。发布的随机
数只对指定的事务有效，而且只在超时值的持续区间内有效。这种方式会增加服务
器的负担，但这种负担可忽略不计。
13.5.3 多重认证机制
服务器支持多重认证机制（比如基本认证和摘要认证）时，通常会在WWW-Authenticate
303 首部提供选项。由于没有要求客户端选择功能最强的认证机制，所以得到的认证效
果就和功能最弱的认证方案差不多。
要避免出现这个问题，最直接的方法就是让客户端总是去选择可用认证方案中功能
320 ｜ 第13章
最强的那个。如果无法实现（因为大部分人使用的都是商业化客户端），唯一的选择
就是使用一个只维护最强认证方案的代理服务器。但只有在已知所有客户端都支持
所选认证方案的区域中才能采用这种方式——比如，在公司网络中。
13.5.4 词典攻击
词典攻击是典型的密码猜测型攻击方式。恶意用户对某个事务进行窃听，并对随机
数/响应对使用标准的密码猜测程序。如果用户使用的是相对比较简单的密码，而
且服务器使用的也是简单的随机数，它很可能会找到匹配项。如果没有密码过期策
略，只要有足够的时间和破解密码所需的一次性费用，就很容易搜集到足够多的密
码，造成实质性的破坏。
除了使用复杂的相对难以破译的密码和合适的密码过期策略之外，确实没有什么好
的方法可以解决这个问题。
13.5.5 恶意代理攻击和中间人攻击
现在很多因特网流量都会在这个或那个地方流经某个代理。随着重定向技术和拦截
代理的出现，用户甚至都意识不到他的请求穿过了某个代理。如果这些代理中有一
个是恶意的或者容易被入侵的，就会使客户端置于中间人攻击之下。