-rw-r--r--. 1 root root 524 3月月 6 13:48 multi-user.target
drwxr-xr-x. 2 root root 4096 5月 4 17:52 multi-user.target.wants
lrwxrwxrwx. 1 root root 17 5月 4 17:52 runlevel2.target -> multi-user.target
lrwxrwxrwx. 1 root root 17 5月 4 17:52 runlevel3.target -> multi-user.target
lrwxrwxrwx. 1 root root 17 5月 4 17:52 runlevel4.target -> multi-user.target
-rw-r--r--. 1 root root 171 6月月 10 2014 vsftpd.service
-rw-r--r--. 1 root root 184 6月 10 2014 vsftpd@.service
-rw-r--r--. 1 root root 89 6月 10 2014 vsftpd.target
# 比较重要的是上头提供的那三行特殊字体的部份！
所以我们可以知道 vsftpd 与 crond 其实算是系统服务 （service），而 multi-user 要算是执行环境相关的类型 （target type）。根据这些
扩展名的类型， 我们大概可以找到几种比较常见的 systemd 的服务类型如下：
扩展名 主要服务功能
一般服务类型 （service unit）：主要是系统服务，包括服务器本身所需要的本机服务以及网络服务都是！比较经常被使
.service
用到的服务大多是这种类型！ 所以，这也是最常见的类型了！
内部程序数据交换的插槽服务 （socket unit）：主要是 IPC （Inter-process communication） 的传输讯息插槽档
（socket file） 功能。 这种类型的服务通常在监控讯息传递的插槽档，当有通过此插槽档传递讯息来说要链接服务时，
就依据当时的状态将该用户的要求传送到对应的 daemon， 若 daemon 尚未启动，则启动该 daemon 后再传送用户的要
求。
.socket
使用 socket 类型的服务一般是比较不会被用到的服务，因此在开机时通常会稍微延迟启动的时间 （因为比较没有
这么常用嘛！）。一般用于本机服务比较多，例如我们的图形界面很多的软件都是通过 socket 来进行本机程序数据交换
的行为。 （这与早期的 xinetd 这个 super daemon 有部份的相似喔！）
执行环境类型 （target unit）：其实是一群 unit 的集合，例如上面表格中谈到的 multi-user.target 其实就是一堆服务的集
.target
合～也就是说， 选择执行 multi-user.target 就是执行一堆其他 .service 或/及 .socket 之类的服务就是了！
.mount 文件系统挂载相关的服务 （automount unit / mount unit）：例如来自网络的自动挂载、NFS 文件系统挂载等与文件系统
.automount 相关性较高的程序管理。
侦测特定文件或目录类型 （path unit）：某些服务需要侦测某些特定的目录来提供伫列服务，例如最常见的打印服务，
.path
就是通过侦测打印伫列目录来启动打印功能！ 这时就得要 .path 的服务类型支持了！
循环执行的服务 （timer unit）：这个东西有点类似 anacrontab 喔！不过是由 systemd 主动提供的，比 anacrontab 更加
.timer
有弹性！
其中又以 .service 的系统服务类型最常见了！因为我们一堆网络服务都是通过这种类型来设计的啊！接下来，让我们来谈谈如何管理这
些服务的启动与关闭。
基本上， systemd 这个启动服务的机制，主要是通过一只名为 systemctl 的指令来处理的！跟以前 systemV 需要 service / chkconfig /
setup / init 等指令来协助不同， systemd 就是仅有 systemctl 这个指令来处理而已呦！所以全部的行为都得要使用 systemctl 的意思啦！有没有
很难？其实习惯了之后， 鸟哥是觉得 systemctl 还挺好用的！ ^_^
在开始这个小节之前，鸟哥要先来跟大家报告一下，那就是：一般来说，服务的启动有两个阶段，一个是“开机的时候设置要不要启动
这个服务”， 以及“你现在要不要启动这个服务”，这两者之间有很大的差异喔！举个例子来说，假如我们现在要“立刻取消 atd 这个服务”时，正
规的方法 （不要用 kill） 要怎么处理？
[root@study ~]# systemctl [command] [unit]
command 主要有：
start ：立刻启动后面接的 unit
stop ：立刻关闭后面接的 unit
restart ：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思
reload ：不关闭后面接的 unit 的情况下，重新载入配置文件，让设置生效
enable ：设置下次开机时，后面接的 unit 会被启动
disable ：设置下次开机时，后面接的 unit 不会被启动
status ：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机默认执行否、登录等信息等！
is-active ：目前有没有正在运行中
is-enable ：开机时有没有默认要启用这个 unit
范例一：看看目前 atd 这个服务的状态为何？
[root@study ~]# systemctl status atd.service
atd.service - Job spooling tools
Loaded: loaded （（/usr/lib/systemd/system/atd.service; enabled））
Active: active （（running）） since Mon 2015-08-10 19:17:09 CST; 5h 42min ago
Main PID: 1350 （atd）
CGroup: /system.slice/atd.service
└─1350 /usr/sbin/atd -f
Aug 10 19:17:09 study.centos.vbird systemd[1]: Started Job spooling tools.
# 重点在第二、三行喔～
# Loaded：这行在说明，开机的时候这个 unit 会不会启动，enabled 为开机启动，disabled 开机不会启动
# Active：现在这个 unit 的状态是正在执行 （running） 或没有执行 （dead）
# 后面几行则是说明这个 unit 程序的 PID 状态以及最后一行显示这个服务的登录文件信息！
# 登录文件信息格式为：“时间” “讯息发送主机” “哪一个服务的讯息” “实际讯息内容”
# 所以上面的显示讯息是：这个 atd 默认开机就启动，而且现在正在运行的意思！
范例二：正常关闭这个 atd 服务
[root@study ~]# systemctl stop atd.service
[root@study ~]# systemctl status atd.service
atd.service - Job spooling tools
Loaded: loaded （/usr/lib/systemd/system/atd.service; enabled）
Active: inactive （（dead）） since Tue 2015-08-11 01:04:55 CST; 4s ago
Process: 1350 ExecStart=/usr/sbin/atd -f $OPTS （code=exited, status=0/SUCCESS）
Main PID: 1350 （code=exited, status=0/SUCCESS）
Aug 10 19:17:09 study.centos.vbird systemd[1]: Started Job spooling tools.
Aug 11 01:04:55 study.centos.vbird systemd[1]: Stopping Job spooling tools...
Aug 11 01:04:55 study.centos.vbird systemd[1]: Stopped Job spooling tools.
# 目前这个 unit 下次开机还是会启动，但是现在是没在运行的状态中！同时，
# 最后两行为新增加的登录讯息，告诉我们目前的系统状态喔！
上面的范例中，我们已经关掉了 atd 啰！这样作才是对的！不应该使用 kill 的方式来关掉一个正常的服务喔！否则 systemctl 会无法继续
监控该服务的！ 那就比较麻烦。而使用 systemtctl status atd 的输出结果中，第 2, 3 两行很重要～因为那个是告知我们该 unit 下次开机会不会
默认启动，以及目前启动的状态！ 相当重要！最下面是这个 unit 的登录文件～如果你的这个 unit 曾经出错过，观察这个地方也是相当重要的！
那么现在问个问题，你的 atd 现在是关闭的，未来重新开机后，这个服务会不会再次的启动呢？答案是？当然会！ 因为上面出现的第二
行中，它是 enabled 的啊！这样理解所谓的“现在的状态”跟“开机时默认的状态”两者的差异了吗？
好！再回到 systemctl status atd.service 的第三行，不是有个 Active 的 daemon 现在状态吗？除了 running 跟 dead 之外， 有没有其他的
状态呢？有的～基本上有几个常见的状态：
active （running）：正有一只或多只程序正在系统中执行的意思，举例来说，正在执行中的 vsftpd 就是这种模式。
active （exited）：仅执行一次就正常结束的服务，目前并没有任何程序在系统中执行。 举例来说，开机或者是挂载时才会进行一次的
quotaon 功能，就是这种模式！ quotaon 不须一直执行～只须执行一次之后，就交给文件系统去自行处理啰！通常用 bash shell 写的小型
服务，大多是属于这种类型 （无须常驻内存）。
active （waiting）：正在执行当中，不过还再等待其他的事件才能继续处理。举例来说，打印的伫列相关服务就是这种状态！ 虽然正在
启动中，不过，也需要真的有伫列进来 （打印工作） 这样他才会继续唤醒打印机服务来进行下一步打印的功能。
inactive：这个服务目前没有运行的意思。
既然 daemon 目前的状态就有这么多种了，那么 daemon 的默认状态有没有可能除了 enable/disable 之外，还有其他的情况呢？当然
有！
enabled：这个 daemon 将在开机时被执行
disabled：这个 daemon 在开机时不会被执行
static：这个 daemon 不可以自己启动 （enable 不可），不过可能会被其他的 enabled 的服务来唤醒 （相依属性的服务）
mask：这个 daemon 无论如何都无法被启动！因为已经被强制注销 （非删除）。可通过 systemctl unmask 方式改回原本状态
服服务务启启动动/关关闭闭与与观观察察的的练练习习
问题：
找到系统中名为 chronyd 的服务，观察此服务的状态，观察完毕后，将此服务设置为： 1）开机不会启动 2）现在状况是关闭的
情况！
回答：
我们直接使用指令的方式来查询与设置看看：
# 1. 观察一下状态，确认是否为关闭/未启动呢？
[root@study ~]# systemctl status chronyd.service
hronyd.service - NTP client/server
Loaded: loaded （/usr/lib/systemd/system/chronyd.service; enabled）
Active: active （（running）） since Mon 2015-08-10 19:17:07 CST; 24h ago
.....（下面省略）.....
# 2. 由上面知道目前是启动的，因此立刻将他关闭，同时开机不会启动才行！
[root@study ~]# systemctl stop chronyd.service
[root@study ~]# systemctl disable chronyd.service
rm '/etc/systemd/system/multi-user.target.wants/chronyd.service'
# 看得很清楚～其实就是从 /etc/systemd/system 下面删除一条链接文件而已～
[root@study ~]# systemctl status chronyd.service
chronyd.service - NTP client/server
Loaded: loaded （/usr/lib/systemd/system/chronyd.service; disabled）
Active: inactive （（dead））
# 如此则将 chronyd 这个服务完整的关闭了！
上面是一个很简单的练习，你先不要知道 chronyd 是啥东西，只要知道通过这个方式，可以将一个服务关闭就是了！好！那再来一个练
习， 看看有没有问题呢？
问题：
因为我根本没有打印机安装在服务器上，目前也没有网络打印机，因此我想要将 cups 服务整个关闭，是否可以呢？
回答：
同样的，眼见为凭，我们就动手作看看：
# 1. 先看看 cups 的服务是开还是关？
[root@study ~]# systemctl status cups.service
cups.service - CUPS Printing Service