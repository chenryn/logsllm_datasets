title:Practical Non-Malleable Codes from l-more Extractable Hash Functions
author:Aggelos Kiayias and
Feng-Hao Liu and
Yiannis Tselekounis
Practical Non-Malleable Codes from (cid:96)-more Extractable Hash
Functions
Aggelos Kiayias∗†, Feng-Hao Liu§, and Yiannis Tselekounis∗‡
†Univ. of Edinburgh, email: PI:EMAIL
§Florida Atlantic University, email: PI:EMAIL
‡Univ. of Edinburgh, email: PI:EMAIL
May 20, 2018
Abstract
In this work, we signiﬁcantly improve the eﬃciency of non-malleable codes in the split
state model, by constructing a code with codeword length |s| + O(k), where |s| is the length
of the message, and k is the security parameter. This is a substantial improvement over
previous constructions, both asymptotically and concretely.
Our construction relies on a new primitive which we deﬁne and study, called (cid:96)-more
extractable hash functions. This notion, which may be of independent interest, guaran-
tees that any adversary that is given access to (cid:96) ∈ N precomputed hash values v1, . . . , v(cid:96),
and produces a new valid hash value ˜v, then it must know a pre-image of ˜v. This is a
stronger notion that the one by Bitansky et al. (Eprint ’11) and Goldwasser et al. (ITCS
’12, Eprint ’14), which considers adversaries that get no access to precomputed hash values
prior to producing their own value. By appropriately relaxing the extractability requirement
(without hurting the applicability of the primitive) we instantiate (cid:96)-more extractable hash
functions under the same assumptions used for the previous extractable hash functions by
Bitansky et al. and Goldwasser et al. (a variant of the Knowledge of Exponent Assumption).
Keywords. Non-malleable codes, hash functions, split-state model.
∗Research partly supported by ERC project CODAMODA (# 259152) and H2020 project PANORAMIX (#
653497).
Contents
1 Introduction
1.1 Our Results
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Technical Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 Preliminaries
3 (cid:96)-more extractable hash function families
4 A non-malleable code against split-state tampering
5 Constructing 1-more extractable hash functions
1-more extractable hash functions from RSS-NM codes against aﬃne functions .
5.1
5.2 Constructing RSS-NM codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3 Our resulting instantiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6 Constructing (cid:96)-more extractable hash
7 Instantiating authenticated encryption
A Preliminaries and Deﬁnitions
A.1 Basic notions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.2 Randomness extractors and universal hash function families . . . . . . . . . . . .
A.3 Instantiating authenticated, semantically secure symmetric encryption, against
one time leakage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.4 Multi-codeword Randomness Simulatable NMC . . . . . . . . . . . . . . . . . . .
B Proofs
B.1 Proof of Lemma 3.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
B.2 Proof of Lemma 3.5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
B.3 Proof (sketch) of Lemma 6.2
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
3
5
7
8
10
11
17
17
20
22
22
22
26
26
28
29
31
31
31
32
33
1
Introduction
Non-malleable codes were introduced by Dziembowski et al. [35] as a relaxation of error cor-
rection and error detection codes. They provide security in the following sense: any modiﬁed
codeword decodes to the original message or to a completely unrelated one, with overwhelming
probability. Non-malleability is deﬁned through a simulation-based deﬁnition, which informally
states that, for any tampering function f , we require the existence of a simulator that simu-
lates the tampering eﬀect, by only inspecting f , i.e., without making any assumptions on the
distribution of the encoded message.
Various applications of non-malleable codes have been proposed, such as CCA secure encryp-
tion schemes [23], non-malleable commitments [5], and most notably, their application against
malicious modiﬁcation attacks, also known as tampering attacks. Indeed, using non-malleable
codes to secure implementations against tampering attacks was the motivation in the original
work by Dziembowski et al. [35]. Due to their important application, constructing non-malleable
codes has drawn a lot of attention, as we elaborate below.
The split-state model [35, 51].
Ideally, we would like to achieve non-malleability against
arbitrary function classes, yet, this task is not achievable, as it is also not achievable in the
case of error correction/detection codes. As discussed in [35], assuming a tampering function f
that computes the decoding of the codeword c = Enc(s), where s is the private message, and
computes ˜c = Enc(s + 1), we receive a tampered codeword, ˜c, that decodes to a message, highly
2
related to the original one. Therefore, no secure construction can exist against any function
class that contains f , which concludes that, restricting the function class, is inherent.
Motivated by the above, various function classes have been studied, and in particular, the
split-state function class has been identiﬁed and extensively studied in the literature. Brieﬂy
speaking, in the split-state model, private memory is split in two parts, L, R, and the attacker
may apply any function f = (f1, f2) that results in a tampered memory equal to (f1(L), f2(R)).
This is a plausible model since in many cases sensitive data may be split in two storage devices
that are physically separated. Note that the model can generalize to multiple split states, with
the two-state variant being the hardest to achieve; we only consider the two state variant in this
paper.
Broadly speaking, (explicit) constructions of non-malleable codes in the split-state model can
be categorized into information-theoretic and computational.1 In a recent breakthrough result
[4], Aggarwal et al. provide the ﬁrst polynomial-time, information-theoretic, non-malleable code
for multi-bit messages, thus signiﬁcantly improving over the work of [34], which only supports
single-bit messages. The encoder produces codewords of length O((|s| + k)7), where |s| denotes
the length of the encoded message, s, and k is the security parameter.2 Later Aggarwal et al. [3]
proposed another construction that achieves codeword length roughly O(|s|) (for suﬃciently
large |s|).3
In the computational setting, Liu and Lysyanskaya [51] construct a non-malleable code us-
ing cryptographic tools such as leakage resilient public-key encryption [54], and robust non-
interactive zero-knowledge (NIZK) proofs [31]. The rate of their construction is not given in the
original paper and a textbook instantiation with public-key encryption combined with NIZKs,
would not yield a rate 1 code; however, using state of the art tools, we can provide a better
instantiation of [51], with codeword length |s| + O(k2), see Table 1.1. Recently, Aggarwal et
al. [2] presented a compiler that transforms any low rate, non-malleable code, to a rate 1, com-
putationally secure, non-malleable code. The underlying encoding must satisfy a notion, strictly
stronger than non-malleability, called augmented non-malleability, which, as it is stated in [2],
can be satisﬁed by the construction of [4]. Thus, by instantiating the compiler of [2] with the
construction of [4], the codeword’s length becomes |s| + O(k7).
Although the above constructions achieve “rate 1” asymptotically, i.e., the ratio of message
to codeword length is 1, as the message length, |s|, goes to inﬁnity, in practice, the induced
overhead can still be too large, when considering short messages (e.g., a 160-bit cryptographic
key), even without counting the potentially large hidden constants in the asymptotic notation.
Thus, even though the problem of “optimal-rate” has been solved in theory, it is still unclear
what the practical implications of those constructions are. Given the current state of the art,
as discussed above, constructing codes with very small overhead, including the hidden constant,
remains still one of the most important open questions in the area. Note, that the natural lower
bound for code length is merely |s| + k, and none of the known, computational or information-
theoretic, constructions, match it, even asymptotically.
1.1 Our Results
In this work, we tackle the challenge to construct truly eﬃcient non-malleable codes in the
split-state model. To achieve this goal, we introduce a new cryptographic primitive, called (cid:96)-
more extractable hash function family, and then we construct an eﬃcient code, using our new
tool. Our approach is modular: ﬁrst we propose and formalize (cid:96)-more extractable hash function
families, and then we demonstrate their application to non-malleable codes.
1The work of [35] showed that in the random oracle model, there exist eﬃcient non-malleable codes against
split-state tampering functions. However, their approach uses a probabilistic argument thus providing only a
proof of existence and not an explicit construction. Therefore, their random oracle result does not count as an
explicit construction. Currently, there is no known explicit constructions in the random oracle model to our
knowledge. We note that in this work we do not consider the random oracle model as we model the tampering
function to have non-black box access to the hash function.
2The result of [4] can be further improved assuming speciﬁc conjectures.
3 The hidden constants might be “astronomical” as they depend on results in additive combinatorics, as
pointed out in the conclusion of their work [3].
3
Brieﬂy speaking, (cid:96)-more extractable hash function families capture the idea that, if an ad-
versary, given (cid:96) hash values v1, . . . , v(cid:96), produces a new valid hash value ˜v, then it must know a
pre-image of ˜v. This is a generalization of the notion of extractable hash functions by Bitansky
et al. [11] and Goldwasser et al. [61], which corresponds to the (cid:96) = 0 case (i.e., the adversary gets
no access to valid hash values, prior to producing its own value), and is somewhat reminiscent
of the strengthening of simulation-soundness in the context of zero-knowlege proofs [60]. Our
generalization is strict: we prove the following (informally stated):
Theorem 1.1 (Informal). Extractable hash
(cid:54)=⇒ 1-more extractable hash.
The subtlety comes from the fact that the (cid:96)-more attacker might get an “unfair advantage”
in producing a valid hash value, for which it does not possess a pre-image, because of the (cid:96)
additional inputs; e.g., by modifying the vi’s in some suitable way. Indeed, we show that the
extractable hash function family of Bitansky et al. [11] is easily malleable, and thus exploitable
by “1-more” attackers. This demonstrates that our new notion of (cid:96)-more extractability might
be diﬀerent than the previous one.
Our next step is to achieve this notion. We show that, by requiring the attacker not only to
produce a valid hash ˜v but also to come up with a valid pre-image for ˜v, (cid:96)-more extractability
can be achieved under the same assumptions used by the construction of Bitansky et al. [11], i.e.,
a variant of the Knowledge of Exponent Assumption (KEA) and DLog. Thus, we conclude
that KEA and DLog are still suﬃcient to achieve (cid:96)-more extractable hash functions with a
weaker form of extractability.
Theorem 1.2 (Informal). DLog and (a variant of ) KEA imply (cid:96)-more extractable hash.
We remark that KEA is non-falsiﬁable (cf. [53]), and it is indeed a strong assumption.
However, one can argue that non-falsiﬁability might be inherent for extractable hash functions,
and thus (cid:96)-more extractability. We recall that Bitansky et al. [11] showed that, extractable
hash function families imply succinct non-interactive argument of knowledge (SNARK), and
Gentry and Wichs [43] showed that SNARK is unlikely to be constructed based on falsiﬁable
assumptions. Thus, non-falsiﬁable assumptions are likely to be inherent for achieving ((cid:96)-more)
extractability. We note that some variants of KEA were shown to contradict (public-coin)
diﬀering-inputs obfuscation and indistinguishability obfuscation [13, 14]; the variant we use is
suitably deﬁned to circumvent this contradiction.
Next, we construct non-malleable codes using (cid:96)-more extractable hash functions. The crux of
our methodology is to adapt the “public-key-encrypt-and-prove” method of [51], using our new
(cid:96)-more extractable hash, yielding eﬀectively a “(one-time-symmetric-key-encrypt)-and-hash” ap-
proach for obtaining non-malleable codes.
In particular, we prove the following (informally
stated):
Theorem 1.3 (Informal). (cid:96)-more extractable hash (with some additional properties) implies
non-malleable codes in the split-state model.
Our scheme produces codewords of length |s| + 9· k + 2· log2(k) (or |s| + 18k depending on the
instantiation, cf. Sections 7, A.3). In Table 1.1 we compare our construction with the current
state of the art on the split-state setting. Our scheme is truly eﬃcient in terms of codeword
length, and it is one order of magnitude better than the combination of [51] + [2] + [54] + [45],
which is the most competitive scheme that can be constructed,4 based on the current state of
the art. We note that, existing constructions in the information-theoretic setting, such as [3, 4],
and the work built on top of them, e.g., [2], might require very large constants, inherited by the
results in additive combinatorics (cf. conclusion of the work [3]).
4For the sake of this comparison, we instantiate [51] with the eﬃcient zero-knowledge proofs of [45] and the
leakage resilient public-key encryption of [54]; moreover we observe that the resulting code is compatible with the
compiler of [2] (it satisﬁes “augmented non-malleability”, a property deﬁned in the latter paper) and thus we can
make the resulting system rate 1. This provides codeword length |s| + O(k2), cited in Table 1.1.
Section 4. CRS size is independent of |s|.