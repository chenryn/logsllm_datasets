**作者：Zhiniang Peng from Qihoo 360 Core Security、Yuki Chen of Qihoo 360 Vulcan
Team  
博客：**
2008年，中本聪提出了一种完全通过点对点技术实现的电子现金系统（比特币）。该方案的核心价值在于其提出了基于工作量证明的解决方案，使现金系统在点对点环境下运行，并能够防止双花攻击。如今比特币已经诞生十年，无数种数字货币相应诞生，但人们对双花攻击的讨论似乎仍然停留在比特币51%攻击上。实际上，我们的研究发现，实用的数字货币双花攻击还有很多种其他形式。在本文中，我们通过介绍我们发现的针对EOS、NEO等大公链平台的多个双花攻击漏洞，总结出多种造成数字货币双花攻击的多种原因，并提出一种高效的减缓措施。
### 1\. 工作量证明和双花攻击
2008年，中本聪提出了一种完全通过点对点技术实现的电子现金系统，它使得在线支付能够直接由一方发起并支付给另外一方，中间不需要通过任何的金融机构。虽然数字签名部分解决了这个问题，但是如果仍然需要第三方的支持才能防止双重支付的话，那么这种系统也就失去了存在的价值。比特币的工作量证明机制(PoW)的本质，就是要使现金系统在点对点的环境下运行，并防止双花攻击。
工作量证明机制的原理如下：
网络中每一个区块都包含当前网络中的交易和上一个区块的区块头哈希。新区块产生，其区块头哈希必须满足工作量证明条件（需要进行大量的哈希计算）。整个网络将满足工作量证明的哈希链连接起来，从而形成区块链。除非攻击者重新完成全部的工作量证明，否则形成的交易记录将不可更改。最长的区块链不仅将作为被观察到的交易序列的证明，而且被看做是来自算力最大的群体的共识。只要整个网络中大多数算力都没有打算合作起来对全网进行攻击，那么诚实的节点将会生成最长的、超过攻击者的链条，从而实现对双花攻击的抵抗。
双花攻击实际上是一个结果。如果一个攻击者A将同一个比特币同时支付给B和C两个用户，并且B和C两个用户都认可了这笔交易。那么我们说A将该比特币花了两次，A实现了一次双花攻击。针对工作量证明机制的双花攻击中，51%攻击是被讨论的最多的一种攻击形式。但针对工作量证明机制的双花攻击实际上有多种形式，包括芬妮攻击、竞争攻击、Vector76攻击等。这些攻击实际上也得到了充分的关注和讨论，本文中不做赘述。实际上，实用的数字货币双花攻击还有很多种其他形式。下文中，我们将通过多个我们发现的多个安全漏洞，讨论多种数字货币双花攻击的多种原因，并提出一种高效的减缓措施。
### 2\. 双花攻击的新分类
智能合约平台，本质上是要在全网共享一个账本。这可以看成是一个分布式状态机复制问题。当前的账本状态，我们可以认为是State_n。当一个新交易Tx_{n+1}产生的时候，Tx_{n+1}将对State_n产生一个作用。从而使State_n状态过渡到State_{n+1}状态。这个过程我们可以用公式表示：
State_n × Tx_{n+1} -->State_{n+1}
智能合约平台共识机制，本质上是将所有的交易【Tx_1 Tx_2 …….
Tx_n】按顺序作用到初始State_0上，使全网始终保持相同的状态。区块链中的每一个区块，实际上将交易序列【Tx_1 Tx_2 …….
Tx_n】按顺序拆分成不同的区块
Block1{Tx_1,Tx_2},Block2{Tx_3,Tx_4}并按顺序链接起来。在全网状态机复制的过程中，如果一旦因为某些原因产生了全网状态不一致，则我们可以认为全网产生了一个分叉。分叉被攻击者利用，可进一步实现双花攻击。
本文中，我们将我们发现的这些双花攻击漏洞分成3类：
  1. 验证不严格造成的双花攻击。
  2. 状态机State_n × Tx_{n+1} --> State_{n+1}不一致执行造成的双花攻击。 共识机制造成的双花攻击。
  3. 验证不严格造成的双花攻击，主要原因在于具体实现逻辑校验问题。比特币的漏洞CVE-2018-17144实际上就是这样一个漏洞。 状态机不一致执行造成的双花攻击，主要是由于智能合约虚拟机因为各种原因导致直接结果不一致，从而在整个网络中创造分叉，造成双花攻击。 共识机制漏洞可能产生整个网络的分叉，从而进一步造成双花攻击。人们常说的51%攻击，实际上就是PoW共识机制的分叉漏洞。
### 3\. 验证不严格造成的双花攻击
验证不严格造成的双花攻击，主要原因在于具体实现逻辑校验问题。这里我们介绍两个关于区块与交易绑定时校验不严格，从而产生双花攻击的漏洞。
在区块链项目中，一笔交易Tx_1被打包的某个区块Block_1中的方式如下：首先计算交易Tx_1的哈希值Hash_1，然后用Hash_1与其他交易的哈希值Hash_2…Hash_n组合构成Merkle
Hash
Tree。计算出哈希树的根节点root，然后将root打包到Block_1中。这样即形成一笔交易与区块的绑定。一般来讲，除非攻击者能够攻破哈希函数的抗碰撞性，否则无法打破一笔交易与区块的绑定。如果攻击者能够打包交易与区块的绑定，则攻击者能通过造成全网的分叉从而实现双花攻击。下面我们介绍两个我们在NEO上发现的双花攻击漏洞：
#### 3.1 NEO虚拟机GetInvocationScript双花攻击漏洞
区块链项目中，一个交易一般是由未签名的部分（UnsignedTx，交易要执行的内容）和签名的部分（交易的witness）构成的。在如比特币之类的区块链项目中，交易的hash计算实际上是包含了该交易的签名部分的。而在如NEO、ONT等多种区块链平台中，交易的计算公式为hash=SHA256(UnsignedTx)。即交易的哈希是由未签名的部分计算得来的，与交易的witness无关。而NEO智能合约在执行的时候，能够通过Transaction_GetWitnesses方法，从一个交易中获得该交易的witnesses。其具体实现如下：
![
](https://images.seebug.org/content/images/2018/11/114239cc-c735-4622-90f2-b2b0355f32c9.png-w331s)
某个合约交易获得自己的witness之后，还能够通过Witness_GetVerificationScript方法获得该witness中的验证脚本。如果攻击者针对同一个未签名交易UnsignedTx1，可以构造两个不同的验证脚本,则可以造成该合约执行的不一致性。正常情况下，合约的VerificationScript是由合约的输入等信息决定的，攻击者无法构造不同的验证脚本并通过验证。但是我们发现在VerifyWitness方法中，当VerificationScript.length=0的时候，系统会调用EmitAppCall来执行目标脚本hash。
![
](https://images.seebug.org/content/images/2018/11/2d4908b6-6441-4ac5-b19c-3e3c70e5d8ba.png-w331s)
所以当VerificationScript=0，或者VerificationScript等于目标脚本的时候，均可满足witness验证条件。即攻击者可以对于同一个未签名的交易UnsignedTx_1，构造两个不同的VerificationScript。攻击者利用这个性质，可以对NEO智能合约上的所有代币资产进行双花攻击，其具体攻击场景如下：
  * 步骤1：攻击者构造智能合约交易Tx_1（未签名内容UnsignedTx_1,验证脚本为VerficationScript_1）。在UnsignedTx_1的合约执行中，合约判断自己的VerficationScript是否为VerficationScript_1。如果为VerficationScript_1，则发送代币给A用户。如果VerficationScript为空，则发送代币给B用户。
  * 步骤2：Tx_1被打包到区块Block_1中。
  * 步骤3: 攻击者收到Block_1后，将Tx_1替换成Tx_2(Tx_1具有与Tx_1相同的未签名内容UnsignedTx_1，但验证脚本为空)从而形成Block_2。攻击者将Block_1发送给A用户，将Block_2发送给B用户。
  * 步骤4：当A用户收到Block_1时，发现自己收到攻击者发送的代币。当B用户收到Block_2时，也会发现自己收到了攻击者发送的代币。双花攻击完成。
可见，该漏洞的利用门槛非常低，且可以对NEO智能合约上的所有代币资产进行双花攻击。危害非常严重。
#### 3.2 NEO MerlkeTree绑定绕过造成交易双花攻击漏洞：
智能合约交易与区块的绑定，通常通过MerkleTree来完成。如果攻击者能绕过该绑定，则能实现对任意交易的双花。这里我们看看NEO的MerkleTree的实现如下：
![
](https://images.seebug.org/content/images/2018/11/67c7a588-af21-4e19-bbf9-a46aa8e52004.png-w331s)
在MerkleTreeNode函数中，NEO进行了MerkleTree叶节点到父节点的计算。但这里存在一个问题，当leaves.length为奇数n的时候。NEO的MerkleTree会将最后一个叶节点复制一次，加入到MerkleTree的计算中。也就是说当n为奇数时，以下两组交易的MerkleRoot值会相等：
【Tx_1 Tx_2 …… Tx_n】
【Tx_1 Tx_2 …… Tx_n Tx_{n+1}】， 其中 Tx_{n+1}= Tx_n
利用这个特性，攻击者可以实现对任意NEO资产的双花攻击。其具体攻击场景如下：
  * 步骤1：假设正常的一个合法Block_1，包含的交易列表为【Tx_1 Tx_2 … Tx_n】。攻击者收到Block_1后，将交易列表替换为【Tx_1 Tx_2 … Tx_n Tx_{n+1}】，形成 Block_2。然后将Block_2发布到网络中去。
  * 步骤2：一个普通节点收到Block_2后，会对Block_2的合法性进行校验。然而因为【Tx_1 Tx_2 … Tx_n Tx_{n+1}】与【Tx_1 Tx_2 … Tx_n】具有相同的MerkleRoot。所以Block_2能够通过区块合法性校验，从而进如区块持久化流程。NEO本地取消了普通节点对合法区块中交易的验证（信任几个共识节点）。则Tx_n交易可以被普通节点执行两次，双花攻击执行成功。