），它的加密算法默认选择是XSalsa20/20(Salsa20的一个变形)。
## Message authentication code
消息验真，不同于摘要，要求的是拦截者无法伪造，其前提条件是发送者和验证者有一个共同的秘密p。本质上看，这个就是签署(sign)，但是一般我们讲sign都是指非对称的sign，MAC是对称式的，对称签署为两个函数，签署为S，校验为V，对任意数据d和密钥p。
  1. 对于签署获得的v=S(d, p)，可以用V(d, v, p)来检验d和v是否成对；
  2. 攻击者在得知S，V，v，d的情况下，无法反推p。
签署算法经常和摘要算法合用，即对数据d先使用摘要H得到摘要，再计算签署，即v=S(H(d), p)，验证时使用V(H(d), v, p)来验证。
主流消息验证算法往往会使用hash或加密算法来完成。
## HMAC签署算法
HMAC（
）算法是对称签署中最著名的一个系列，HMAC不是一个算法，而是一类算法，这个算法基于一个hash函数（而且显然，要求是安全的hash函数），根据hash选择不同，HMAC也会有所不同。HMAC的基本想法是，将p拼接在数据d前面，做hash。根据安全的hash函数的性质，攻击者无法从v反推原始数据，即使他们拥有部分的明文（被签署数据d），而在不知道p的前提下，也无法构造出签名v。细节来说，HMAC要求对密钥p进行变形，得到两个密钥，并重复“拼接-hash”过程两次。
## CMAC系列
MAC系列的介绍可以看这里：
。这里我们特别介绍一下CBC-MAC这种算法。这种算法是使用加密算法来完成验证的典型代表，拥有很多衍生，例如OMAC/CMAC/XMAC等。
上面我们简要介绍过CBC，这个模式循环使用前面块的数据来扰乱下一个块，然后再完成加密，而CBC-MAC通过密钥构造一个k1，配合IV=0来计算输出，取最后一个块输出，再用密钥构造一个k2，加密最后一个块，形成MAC数据。基于基本知识我们知道，对任意一个数据输入改变，最后的输出会发生变化，并且在没有密钥时无法构造MAC数据。
## 最佳实践
首先，最普及的算法是HMAC，有条件的话尽量选择这种。
既然MD5和SHA1不安全了，那么尽量不要选择HMAC-MD5和HMAC-SHA1，尽管我只看到了SHA1碰撞的实例报告，还没见过HMAC-SHA1的。但是还是尽量不要冒险，使用HMAC-SHA2。
另一个就是，不要试图自己实现MAC算法，这类算法实现的难度比你想象的要高很多，如果你需要的话，推荐使用NaCl。
## AEAD
AEAD是近代的一个密码模式，主力解决这么一个问题。我们上面介绍了加密和MAC，但是在日常使用中，我们既需要加密，也需要MAC，例如Alice可能写了一封情书给Bob，那么，她同时需要保证情书不会被第三方看到(加密)，又要保证Bob不会以为她写了一堆乱码(签署验真)，虽然听起来很愚蠢，正常人看到一堆乱码的时候，当然知道是被人替换了，但我们就当作Bob是一个智商不足的傻瓜（恋爱中的人都是傻瓜）。
解决这个需求，我们有三种模式。
Encrypt-then-MAC (EtM)，首先加密，然后用另一个密钥对密文进行签署；
Encrypt-and-MAC (E&M)，首先加密，同时用同一个密钥对明文进行签署；
MAC-then-Encrypt (MtE)，首先签署，然后用同一个密钥对总和数据进行加密。
然后，据说这些模式都是有缺陷的。缺陷具体笔者未参透。有兴趣的朋友，这里有本九阳神功（
）送给你，欢迎交流。
总之，为了解决上面的问题，产生了一个新的概念，AEAD（
）。在一个算法中进行加密和验证。
## GCM
GCM是一种CTR算法。CTR是一种密码模式，这种模式利用数据的块计数作为扰动变量，来使得同样的输入不产生同样输出。这样做的最大好处在于，每个块的计算彻底变成了互相不关联的过程，因而可以在分布式系统上进行计算。其他模式，即便是OFB，其输出流也是串行的。当输入速度高于mask流时，就会出现算法无法利用CPU的问题。
###
## 最佳实践
AEAD的选择不算太多，这份推介（
）上推荐的是使用AES-GCM或Chacha20-Poly1305。NaCl的默认选择是XSalsa20-Poly1305。预订要有AES256GCM，但是目前未实现。
Public-key cryptography
公钥密码体系是一个非常复杂的系统，这个系统基本涵盖以下几个领域：
key exchange
public key encryption
public key signature
## Key exchange
密钥协商，也叫密钥交换 ，简称Kx，为一个过程。假设Alice和Bob可以通讯，此时算法需要确定一个协商序列同时满足：
  1. Alice和Bob能够得到一个共享的秘密s；
  2. 可以监听通讯内容的监听者Eve无法通过监听内容推算出s；
  3. 前向安全。所谓前向安全，指未来的密钥泄漏不会泄漏之前的通讯内容(可选要求)。
注意，虽然被动式的Eve并不一定能够躲避序列，但是主动攻击者Mallory是一定可以截听内容的，无论协商算法如何复杂，Mallory可以分别和Alice和Bob进行协商过程，使得Alice相信自己是Bob，Bob相信自己是Alice。（MITM
attack）这个攻击无法通过密钥协商机制进行躲避，需要在密钥协商之上进行身份交叉认证才行。
Public-key encryption
公钥加解密为三个函数：生成为G，加密为E，解密为D。对任意数据d，满足下面要求1-3：
  1. G可以生成私钥和公钥，即s,p=G()，其中s为私钥，p为公钥。公钥可以公开；
  2. 加密为e=E(d, p)，解密为d=D(e, s)；
  3. 攻击者在得知G，E，D，p，e的情况下，无法反推s和d。
注意，关于p和s只是说，p无法推出s，并没有说，通过s可以推出p，只要通过函数G能够生成成对的s和p即可。ECC和DH体系中可以用s推导出p，但是RSA中单有s是不行的，实际是通过另两个数(质数pq)生成，两者无法互相推导。
* * *
【It works,why?】系列更多内容，请见饿了么SRC微信公众号！