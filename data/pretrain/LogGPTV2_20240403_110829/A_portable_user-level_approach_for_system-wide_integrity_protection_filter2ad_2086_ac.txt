Aho-Corasick algorithm [4] for efﬁcient string matching.
Inferred type
read and
write
Preference
Action
Redirect
Implicitly accessed by benign
other
Code and
conﬁguration
Deny
Explicitly
accessed
Data
Deny
Figure 3: Untrusted Sandbox policy on writing benign ﬁles
4.2 Benign Code Policy
Policies can also be inferred for benign programs, although some
of the aspects are too complex to resolve entirely automatically.
Logical isolation.
The default policy for benign code is to prevent consumption of
untrusted inputs, while returning a “permission denied” error code.
Untrusted execution.
Requiring users to explicitly invoke uudo has the beneﬁt that
users know in advance whether they can trust the outputs or not.
However, it is an inconvenience for users to make this decision all
the time. Hence, our system can also automatically infer the use of
uudo. The idea is as follows: if an execution will fail without uudo
but may succeed with it, we automatically invoke uudo. Currently,
we have implemented this for the simple cases of benign applica-
tions invoked with untrusted input ﬁles. This technique works well
when applications are launched by a ﬁle manager when the user
double-clicks a ﬁle, or uses a “open with” dialog. It also works for
simple commands that take a ﬁle name argument. Handling more
general cases, e.g., pipelines, is a topic of future work.
Trust-conﬁned execution.
There does not seem to be a practical way to automatically de-
cide which applications are trustworthy. However, it is possible to
identify where trust is inappropriate: given the critical role played
by implicitly accessed ﬁles, it does not seem appropriate to trust ap-
plications to defend themselves from untrusted data in these ﬁles.
In this manner, the inference procedure described earlier is helpful
for determining trust conﬁnement policies.
5.
Implementation and Evaluation
Our primary implementation was performed on Ubuntu 10.04.
Fifteen assembly instructions were inserted around each system
call invocation sites in system libraries (libc and libpthread).
This allows us to intercept all system calls. Our implementation
then modiﬁes the behavior of these system calls as needed to real-
ize the sandboxes described in Section 2 and 3. We also modiﬁed
the loader to refuse loading untrusted libraries for benign processes.
When our system is installed, existing ﬁles are considered as be-
nign. We found no world-writable regular ﬁles, so no permission
changes were needed for them. There were 26 world-writable de-
vices, but we did not change their permissions because they do not
behave like ﬁles. We also left permissions on sockets unchanged
because some OSes ignore their permissions. Instead, we perform
checking within the accept system call. World-writable directory
with sticky-bit set were left unmodiﬁed because OSes enforce a
policy that closely matches our requirement. Half of the 48 world-
executable setuid programs were modiﬁed to group-executable by
Gb. The rest were setgid programs and were protected using ACLs.
There are a few pivotal benign applications such as web browsers,
email readers and word processors that are exposed to a wide range
of inputs. One way to use them safely is to run them as benign
or untrusted process, based on the integrity of the input ﬁles. This
works well for applications such as editors or document viewers.
However, some applications need to simultaneously process mes-
224
Shared Ubuntu
PCBSD
Require no instrumentation
Benign Sandbox
Untrusted Sandbox
118
49
55
170
6
7
205
29
40
Figure 4: Number of system calls
C
Ubuntu
2208
703
68
811
451
944
5185
Shared
uudo
helper UH
BL ∩ UL
BL only
UL only
Total
LOC
header
+PCBSD Ubuntu
+PCBSD
130
16
52
15
67
81
361
737
106
492
1335
27
30
57
Other
Both
39
74
113
Document
Readers
Games
Editor/
Ofﬁce/
Document
Processor
Internet
Media
Shell-like
Other
Audacity, Abiword, cdcover, eclipse, ewipe, gambas2,
gedit, GIMP, Gnumeric, gwyddion, Inkscape, labplot, lyx,
OpenOfﬁce, Pitivi, pyroom, R Studio, scidavis, Scite,
texmaker, tkgate, wxmaxima
cbm, evolution, dailystrips, Firefox, ﬂickcurl, gnome-rdp,
httrack, jdresolve, kadu, lynx, Opera, rdiff, scp,
SeaMonkey, subdownloader, Thunderbird, Transmission,
wbox, xchat
Adobe Reader, dhelp, dissy, dwdiff, evince, F-spot,
FoxitReader, Geegle-gps, jparse, naturaldocs, nfoview,
pdf2ps, webmagick
asc, gbrainy, Kiki-the-nano-bot, luola, OpenTTD,
SimuTrans, SuperTux, supertuxkart, Tumiki-ﬁghters,
wesnoth, xdemineur, xtux
aqualung, banshee, mplayer, rhythmbox, totem, vlc
bochs, csh, gnu-smalltalk, regina, swipl
apoo, arbtt, cassbeam, clustalx, dvdrip, expect, gdpc,
glaurung, googleearth, gpscorrelate-gui, grass, gscan2pdf,
jpilot, kiki, otp, qmtest, symlinks, tar, tkdesk, treil,
VisualBoyAdvance, w2do, wmmon, xeji, xtrkcad, z88
Figure 5: Code complexity on Ubuntu and PCBSD
Figure 6: Software tested
sages from benign and untrusted sources, e.g., browsers and ﬁle
utilities. We have experimented with two approaches for such ap-
plications: (a) expect the application to protect its integrity from
certain untrusted inputs, thus allowing it to have unrestricted inter-
actions on those speciﬁc interfaces, and (b) use separate instances
of the application when interacting with untrusted or benign data.
We experimented with both choices for Firefox and Thunderbird.
Many ﬁle utilities (mv, cp, tar, find, grep, and rm) represent ma-
ture programs, so we used option (a).
A key requirement for using option (a) is that applications need
to label their outputs accordingly, instead of always labeling them
as benign. For most ﬁle utilities, this is done by using appropriate
ﬂags. For Firefox and Thunderbird, we developed add-ons for
this purpose.
Installation of untrusted software represents another key chal-
lenge, as administrative privileges are needed during installation,
yet many components executed at install time are from untrusted
sources. To address this challenge, we have developed an approach
based on SSI [24] to secure this phase.
We also limited the privileges of untrusted X-clients with X-
security extensions or nested X-server to protect other benign clients.
5.1 Portability and Complexity
To further establish the simplicity and practicality of our ap-
proach, we ported our system to PCBSD (version 8.2), one of the
best known desktop versions of BSD. Similar to the implementa-
tion on Ubuntu, we modiﬁed the library by inserting assembly in-
structions at each system call invocation site.
Figure 4 shows the number of system calls we instrumented to
enforce policies. On i386 Linux, some calls are multiplexed using a
single system call number (e.g., socketcall). We demultiplexed
them so that the results are comparable to BSD. Most of the system
calls require no instrumentation. A large number of system calls
that require instrumentation are shared between the OSes. Note that
some calls, e.g., open, need to be instrumented in both sandboxes.
A large portion of the PCBSD speciﬁc system calls are never in-
voked: e.g., NFS, access control list, and mandatory access control
related calls. Of those 59 (10 overlaps in both sandboxes) sys-
tem calls that require instrumentation, 29 are in the benign sand-
box. However, only 4 (nmount, kldload, fexecve, eaccess)
out of the 29 calls are actually used in our system. Hence, we
only handle these 4 calls. For the rest of the calls, we warn about
the missing implementation if there is any invocation. The other
40 calls in untrusted sandbox are for providing transparency. We
found that implementing only a subset of them (futimes, lchmod,
lutimes) is sufﬁcient for the OS and applications like Firefox
and OpenOffice to run. Note that incomplete implementation in
the transparency library UL does not compromise security.
Figure 5 shows the code size for different components for sup-
porting Ubuntu, and the additional code for PCBSD. The overall
size of code is not very large. Moreover, a signiﬁcant fraction of the
code is targeted at application transparency. We estimate that the
code that is truly relevant for security is less than half of that shown,
and hence the additions introduced to the TCB size are modest. At
the same time, our system reduces the size of the TCB by a much
larger amount, because many programs that needed to be trusted to
be free of vulnerabilities don’t have to be trusted any more.
5.2 Preserving Functionality of Code
We performed compatibility testing with about 100 applications
shown in Figure 6. 70 of them were chosen randomly, the rest were
hand-picked to include some widely used applications.
5.2.1 Benign mode
First, we installed all 100 packages as benign software. As ex-
pected, all of them worked perfectly when given benign inputs.
To use these applications with untrusted inputs, we ﬁrst ran them
with an explicit uudo command.
In this mode, they all worked
as expected. When used in this mode, most applications modiﬁed
their preference ﬁles, and our approach for redirecting them worked
as expected.
We then used these applications with untrusted inputs, but with-
out an explicit uudo. In this case, our uudo inference procedure
was used, and it worked without a hitch when benign applications
were started using a double-click or a “open-with” dialog on the
ﬁle manager nautilus. The inference procedure also worked well
with simple command-lines without pipelines and redirection. Fur-
ther reﬁnements to this procedure to handle pipelines and more
complex commands is a topic of ongoing work.
5.2.2 Untrusted mode
We then conﬁgured the software installer to install these applica-
tions as untrusted. Remarkably, all of the packages shown in Fig-
ure 6 worked without any problems or perceptible differences. We
discuss our experience further for each category shown in Figure 6.
Document Readers.
All of the document readers behave the same when they are used
to view benign ﬁles. In addition, they can open untrusted ﬁles with-
out any issues. They can perform “save as” operations to create new
ﬁles with untrusted label.
225
Games.
By default, we connect untrusted applications as untrusted X-
clients, which are restricted from accessing some advanced features
of the X-server such as the OpenGL GLX extensions. As a result,
only 8 out of 12 games worked correctly in this mode. However,
all 12 applications worked correctly when we used (the some what
slower) approach of using a nested X-server (Xephyr).
Editors/Ofﬁce/Document Processors.
These applications typically open ﬁles in read/write mode. How-
ever, since our system does not permit untrusted processes to mod-
ify benign ﬁles, attempts to open benign ﬁles would be denied.
Most applications handle this denial gracefully: they open the ﬁle
in read-only mode, with an appropriate message to the user, or
prompt the user to create a writable copy before editing it.
Internet.
This category includes web browsers, email clients, instant mes-
sengers, ﬁle transfer tools, remote desktop clients, and information
retrieval applications. All these applications worked well when run
as untrusted processes. Files downloaded by applications are cor-
rectly labeled as untrusted. Any application opening these down-
loaded ﬁles will hence be run in untrusted mode, ensuring that they
cannot damage system integrity.
Media Player.
These are music or video players. Their functions are similar
to document readers, i.e., they open their input ﬁles in read-only
mode. Hence, they do not experience any security violations.
Shell-like application.
This category includes shells or program interpreters that can
be executed interactively like a shell. Once started in untrusted
mode, all the subsequent program executions will automatically be
performed in untrusted mode.
Other Programs.
We tested a system resource monitor (wmmon), ﬁle manager
(tkdesk), some personal assistant applications (jpilot, w2do,
arbtt), googleearth and some other applications. We also tested
a number of specialized applications: molecular dynamic simula-
tion (gdpc), DNA sequence alignment (clustalx), antenna ray
tracing (cassbeam), program testing (qmtest, expect), computer-
aided design (xtrkcad) and an x86 emulator (bochs). While we
are not conﬁdent that we have fully explored all the features of
these applications, we did observe the same behavior in our tests
in benign as well as untrusted modes. The only problem expe-
rienced was with the application gpscorrelate-gui, which did
not handle permission denial (to write a benign ﬁle) gracefully, and
crashed.
5.3 Experience with Malicious Software
Here we illustrate scenarios involving stealthy attacks that are
stopped by our system.
Real world malware.
Malware can enter systems during installation of untrusted soft-
ware or via data downloads. As secure installation is not our focus,
we assumed that attacks during installation are prevented by sys-
tems like [24] and untrusted ﬁles are labeled properly.
We tested our system with malware available on [1]. These mal-
ware were mainly rootkits: patched system utilities like ps and ls,
kernel modules, and LD_PRELOAD based libraries. Speciﬁc pack-
ages tested include: JynxKit, ark, BalaurRootkit, Dica, and
Flea. All of them tried to overwrite benign (indeed, root-owned)
ﬁles, and were hence stopped.
KBeast (Kernel Beast) requires tricking root process to load a
kernel module. The benign sandbox prevents root processes from
loading the kernel module since the module is labeled as untrusted.
Real world exploit.
We tested an Adobe Flash Player exploit (CVE-2008-5499) which
allows remote attackers to execute arbitrary code via a crafted SWF
ﬁle. If the browser is simply trusted to be free of vulnerabilities,
then this attacks would obviously succeed. Our approach was based
on treating the web-site as untrusted, and opening it using an un-
trusted instance of the browser. In this case, the payload may ex-
ecute, but its actions are contained by the untrusted sandbox. In
particular, it cannot damage system integrity.
Simulated Targeted Attacks.
We also simulated a targeted attack via compromising a docu-
ment viewer. A user received a targeted attack email from an at-
tacker, which contained a PDF that can compromise the viewer.
When the user downloaded the ﬁle, the email client labeled the
attachment as untrusted automatically since the sender cannot be
veriﬁed. Our system, however, did not prevent the user from using
the document. User could still save the ﬁle along with other ﬁles.
When she opened the ﬁle, the document viewer got compro-
mised. On an unprotected system, the attacker controlled viewer