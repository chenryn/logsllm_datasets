title:Ambiguity Resolution via Passive OS Fingerprinting
author:Greg Taleck
Ambiguity Resolution
via Passive OS Fingerprinting
Greg Taleck
NFR Security, Inc.,
5 Choke Cherry Rd, Suite 200,
Rockville, MD 20850
PI:EMAIL
http://www.nfr.com/
Abstract. With more widespread use of tools (such as fragrouter and
fragroute[11]) that exploit diﬀerences in common operating systems to
evade IDS detection, it has become more important for IDS sensors to
accurately represent the variety of end hosts’ network stacks. The ap-
proach described in this paper uses the passively detected OS ﬁngerprint
of the end host in an attempt to correctly resolve ambiguities between
diﬀerent network stack implementations. Additionally, a new technique
is described to increase the conﬁdence level of a ﬁngerprint match by
looking more extensively at TCP connection negotiations.
1 Introduction
Ptacek and Newsham[3] describe “a fundamental problem for network intrusion
detection systems (IDS) that passively monitor a network link is the ability of a
skilled attacker to evade detection by exploiting ambiguities in the traﬃc stream
as seen by the NIDS.” [4] These ambiguites on the wire arise from the fact that
ambiguities exist in common Internet protocols which led to diﬀering protocol
implementations by diﬀerent operating system vendors.
This paper describes a new approach to the problem of passively providing a
IDS sensor knowledge of an end host’s network stack implementation to prevent
the aforementioned attackers from evading detection or inserting false alerts. We
also describe our implementation of this approach in version 4 of the NFR IDS
Sensor.
1.1 Motivation
Correctly resolving network protocol ambiguities has long been a thorn in the
side of network intrusion detection systems. Exploitable ambiguities show them-
selves in three scenarios[4]: incomplete analysis on the part of the IDS sensor;
lack of detailed knowledge of the end host’s protocol implementation; lack of
detailed topology knowledge to determine whether a host sees any given packet.
This solution mainly deals with the problem arising from the second scenario.
G. Vigna, E. Jonsson, and C. Kruegel (Eds.): RAID 2003, LNCS 2820, pp. 192–206, 2003.
c(cid:1) Springer-Verlag Berlin Heidelberg 2003
Ambiguity Resolution via Passive OS Fingerprinting
193
That is, how can the IDS gain more detailed information about the end host in
a passive environment?
The ambiguity of the Internet Protocol[16] with respect to fragmentation
leads to numerous problems. The most serious of these is to accurately deter-
mine exactly what a given end host would see in the presence of overlapping
fragments, to properly detect network intrusions, when, and only when they
actually happen.
Implementations of the Transmission Control Protocol[17] also vary with
respect to handling TCP segments with overlapping TCP data. The specﬁcation
states that segments should be trimmed to only contain new data, but in practice,
network stacks handle this condition in diﬀerent ways.
These two problems present two common exploitable conditions for current
IDS sensors. We attempt to minimize these opportunities for attackers with the
approach described in this paper.
The rest of the paper is organized as follows: Section 2 looks at related
work and research in this area. Section 3 looks at existing, state-of-the-art ﬁn-
gerprinting technology. In Section 4, we describe how we build the ﬁngerprint
databases and show new techniques for accurately identifying host operating
systems. Section 5 shows our current implementation and 6 expands on the re-
source consumption of our implementation, including methods to reduce it. Our
results and measurements are presented in Section 7 and other areas of possible
research and future work are described in Section 8.
2 Related Work
2.1 Active Mapping
Inspiration for this work is drawn mainly from the research done on Active
Mapping[1]. This method relies on a separate system, the Mapper, to actively
map hosts within a network to determine its ambiguity resolution policies. That
is, how does a host interpret ambiguous packets. The Mapper builds a Host
Proﬁle Table by sending diﬀerent combinations of overlapping, fragmented IP
packets and overlapping TCP segments. It then feeds that host proﬁle informa-
tion, or ambiguity resolution policies, to an IDS sensor. When the IDS detects an
ambiguity on the wire, it looks up the IP in the Host Proﬁle Table for instruction
on how to resolve it.
Unfortunately, there are drawbacks to this type of setup for many network
installations. By deﬁnition, Active Mapping requires that the mapper actively
send out anomalous traﬃc that may be rejected by ﬁrewalls or routers within the
network. Clients that are dynamically assigned IP addresses via DHCP would
fail to be mapped properly, and could potentially be mapped to a diﬀerent proﬁle
of another machine. These handcrafted packets could also potentially harm hosts
on a network.
194
G. Taleck
2.2 Traﬃc Normalization
Traﬃc normalization[5] solves the problem of ambiguity by mostly (or com-
pletely) eliminating it. A traﬃc normalizer acts as a gateway for all ingress,
and possibly egress, traﬃc and removes any ambiguities when it detects them.
However, traﬃc normalization cannot always scale to large networks because of
the process overhead per packet, and can also break connectivity between hosts
when they rely on un-normalized traﬃc. Normalizers must also be extremely
fault tolerant, as any traﬃc that is to enter the network must ﬁrst pass the
normalizer.
2.3
nmap, queso, ettercap, p0f, prelude-ids
Active and passive OS ﬁngerprinting tools have been around for quite some time.
These tools identify hosts by taking advantage of subtle variations in network
stack implementations. Mainly ICMP and TCP packets are used to remotely
deduce operating system type. Fyodor’s nmap[7] tool, ﬁrst released in 1997,
makes extensive use of variations in reply packets from hosts when sent invalid,
unusual, or non-conforming payloads, as does queso[12]. The p0f [13] tool uses
the unique variations of TCP SYN Segments to passively identify hosts on a
network. Similarly, ettercap [14], a multi-purpose network sniﬀer, attempts to
identify hosts in the same fashion as p0f. Recently, a patch was submitted to
the Prelude IDS Development [15] (prelude-devel) mailing list that can extract
pertinent ﬁngerprint information from a TCP SYN or SYNACK segment and
save it to a database in the ettercap signature style. This allows Prelude-IDS
users the ability to attempt to identify either an attacker’s or victim’s host
operating system.
These tools implement valuable approaches to identifying hosts on a network
that have not yet been widely integrated into available IDS solutions. However,
the information they provide can only be used to forensically investigate an
attack. In other words, these approaches collect data from TCP SYN/SYNACK
segments that can then be used later to assess the host.
3 OS Fingerprinting
Two methods exist for remotely ﬁngerprinting hosts on a network: active and
passive.
3.1 Active Fingerprinting
Active ﬁngerprinting requires one to send interesting, malformed, and unique
payloads to a remote host and examine the values returned by the host. Both
the nmap and queso tools do this. The common tests send special combinations
of TCP ﬂags, such as FIN—PSH—URG, with a NULL TCP payload to both
open and closed ports on the host.
Ambiguity Resolution via Passive OS Fingerprinting
195
3.2 Passive Fingerprinting
Passive ﬁngerprinting attempts to determine the host type by passively monitor-
ing a network link, and not sending any traﬃc onto the wire. Existing passive
OS ﬁngerprinting tools examine the values of ﬁelds in the IP and TCP headers
of initial TCP SYN segments sent from clients. Common ﬁelds used are:
– Initial Window Size (WS)
– Time To Live (TTL)
– Maximum Segment Size (MSS)
– Don’t Fragment (DF) Bit
– Window Scale Value
– SackOK option presence
– Nop option presence
This technique also relies on requiring an exact match of all the ﬁelds used
in the ﬁngerprint1.
Other techniques[20] look at how to detect network stack implementations
by examining TCP segments throughout the connection, or by examining the
timing of TCP segments traveling back and forth[24].
3.3 Defeating OS Fingerprinting
As accurate as both active and passive OS ﬁngerprinting may be, there are meth-
ods to prevent a potential attacker from guessing a host’s operating system[9].
For example, a host can fool p0f, in the simplest case, by changing any one of
the values enumerated above. Fooling nmap or queso requires a little more eﬀort,
since these tools send multiple tests. In order to avoid detection, one must ensure
that a majority of the tests sent fail to provide enough intelligence to make a
guess.
3.4 Exploitation of the TCP Three-Way Handshake
Existing passive ﬁngerprinting tools work by looking at the ﬁrst SYN segment of
a TCP connection. However, the replying SYNACK from the server can also yield
pertinent information that can be used to identify the host. Since the servers are
typically within the same network as the deployed IDS, this information is much
more important. Most attacks are initiated by the client side of the connection.
Additionally, if a person or program were to try to evade an IDS, they would
do so in order to push an attack through without the IDS detecting it. Since
the server side that will be accepting the ambiguous traﬃc, it is this side we are
more interested in ﬁngerprinting.
During the three-way handshake to initialize the TCP connection, a client
connects to a server within the network by sending a TCP SYN segment, and
1 Exceptions to this are the p0f tool, which will incrementally alter the TTL ﬁeld to
obtain a match since a packet in ﬂight can have a variable TTL value depending on
the network path taken, and Xprobe, which can use a best-match algorithm.
196
G. Taleck
Client
SYN
IDS
Server
SYNACK
fragment 1 (24 bytes at offset 0)
AAAABBBBCCCC_attack_code
fragment 2 (20 bytes at offset 12)
            DDDDEEEEFFFFGGGGHHHH
?
2 possible resolutions of ambiguity by the IDS:
AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH
(Last Policy)
AAAABBBBCCCC_attack_codeGGGGHHHH
(First Policy)
Fig. 1. Network packets from a potential attacker and its victim as seen by an IDS.
the server replies with a SYNACK segment. Consider the example shown in
Figure 1, where packets are sent between a client (potential attacker) and server
(potential victim) as seen by an IDS sensor.
In this scenario, the only information seen on the wire that can be used to
identify the server is the SYN from the client and the corresponding SYNACK
reply from the server to open the connection. However, depending on the values
within the TCP header and the options present within the SYN from the attacker
and how the server negotiates those options, it is possible to make a guess at the
operating system of both the client and the server. If an accurate guess is made
for the operating system type of the server, then we can attempt to resolve the
ambiguity in the subsequent fragmented packets sent by the client to the server
and have a better chance of determining whether an attack occurred.
Another example can be an attack from a server to a client, where we can
lookup the client via its TCP SYN segment and possibly determine the operating
system type. Consider the case where a web browser within the network connects
to a malicious server outside of the network in an attempt to gain control of the
client.
Ambiguity Resolution via Passive OS Fingerprinting
197
It should be noted the the ettercap tool mentioned in Section 2 does have an
entry for the ACK bit in its signature database. However, it does not correlate
the formation of the SYNACK response to the SYN request.
The next section describes how we can build a collection of ﬁngerprints and
their corresponding ambiguity resolution policies.
4 Building TCP SYN/SYNACK Fingerprint Tables
In order to passively map hosts on a network to a particular operating system,
we need to deploy IDS sensors with a pre-built table containing mappings of
TCP SYN/SYNACK ﬁngerprints to ambiguity resolution policies. Two tables
are necessary: one table for identifying TCP SYN segments and another, more
important, table for identifying TCP SYNACK segments. We use the existing
active ﬁngerprinting techniques, as well as some new ones, to build these policy
tables.
4.1 Eliciting TCP SYNs
The p0f tool contains a reasonably robust table of ﬁngerprints to map TCP SYN
segments, but it requires human intervention to keep it up-to-date. To automate