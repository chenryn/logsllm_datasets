# 深耕保护模式（五）
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 2-9-9-12分页
在10-10-12分页方式下，物理地址最多可达4GB。但随着硬件发展，4GB的物理地址范围已经无法满足要求，Intel在1996年就已经意识到这个问题了，所以设计了新的分页方式。也就是2-9-9-12分页,又称为PAE（物理地址扩展）分页.
> 在了解2-9-9-12分页之前，应该先明确10-10-12分页到底是怎么来的，这样更有助于理解2-9-9-12分页。
###  为什么是10-10-12分页
intel实际上是先确定了页的大小，为4KB。那么物理页要求的索引应该是4096，也就是2的12次方，这个12次方实际上就是最后的12。
当初的物理内存比较小，所以4个字节的PTE就够了，又因为页的尺寸是4K，所以一个页能存储1024个 PTE ，也就是2的10次方 第二个10也就确定了。
第一个10同理，四字节的PDE，而页是4096，所以能储存1024个PDE，也就是2的10次方。
###  为什么是2-9-9-12分页
页的大小是4K，这点是不能动的。那么最后12位依旧是12位。
如果想增大能访问的物理页，需要增大PTE，而考虑到对齐效率高的问题，直接扩展到8个字节，也就是64位。
那么一个PTE有8个字节64位，一个PTT表还是4K，所以这里2的9次方 512即可索引到每一项。第三个9就是这个2的9次方。
同理是第二个9，一个PDE有8个字节64位，一个PDT表还是4K，也是2的9次方可以索引到每一项。
第一个2则是多出来的，做成了新的一级。
###  2-9-9-12分页结构(PAE,物理地址扩展)
2位2进制数最多就有四个索引，称为PDPTE（Page-Directory-Point-Table Entry）：页目录指针表项。每项占8个字节。
###  在2-9-9-12分页模式下，通过线性地址找到物理地址
在boot.ini文件中修改execute为noexecute。
执行这样一段代码：
    #include "stdafx.h"
    int main(int argc, char* argv[])
    {
        char x = 'a';
        printf("x的地址:%x\n",&x);
        getchar();
        return 0;
    }
获取到x的线性地址。并进行拆分：
可以看到进程的cr3已经是0x20这样增长，10-10-12的cr3是0x1000增长。
只是多了一层偏移，与10-10-12分页寻址大体差不多。
    kd> !dq 09e40300 + 0 
    kd> !dq 1a781000 + 0
    kd> !dq 1a8a4000 + 978
    kd> !dq 1aaa9000 + F7C
###  PDPTE(Page-Directory-Point-Table Entry)
36-63位是保留位，保留位并不意味着填0就行了，而是cpu要用的，但是我们不能用，并且cpu用了还不会告诉我们怎么用的。
12-35位是PDT的基址，把低12位补0，那么0-35位，共36位为PDT基址。
9-11位是拿给操作系统用的，反正cpu不用。
0-11位都是属性。
###  PDE结构
在2-9-9-12分页模式下，PDE的结构有两种，一种是PS位为1的情况，一种是PS位为0的情况。
####  PS=1
当PS=1时是大页，35-21位是大页的物理地址，这样36位的物理地址的低21位为0，这就意味着页的大小为2MB，且都是2MB对齐。
2MB哪里来的呢？2-9-9-12，后面的9和12合并成了一个大页，所以是21位，也就是2的21次方，所以是2MB。
PAT位为Page Attribute Table，页属性表，可以看到下面PS为0的时候就有没这一项，原因就是这个位是针对页的，目录当然没有。
####  PS=0
当PS=0时，35-12位是页表基址,低12位补0，共36位。
###  PTE结构
PTE中35-12是物理页基址，24位，低12位补0
物理页基址+后12位的页内偏移指向具体数据
###  XD标志位
AMD中称为NX位,即No Excetion。
在上面说到保留位是cpu自己在用的，并且不会跟我们说怎么用的。在保留位的最高位，也就是63位，实际上是一个标明是否可执行的位。
细心的同学已经发现了，在PDE和PTE结构中，无论是10-10-12分页还是2-9-9-12分页都只有R/W位，也就是可读可写，但是并没有可执行的概念，之前在段的学习中，是有可读可写可执行的概念的，这里显然是不科学的。所以在2-9-9-12分页模式中的最高位标明该物理页的可执行属性。
Intel就做了硬件保护，做了一个不可执行位，XD=1时，表明该物理页是不可执行的，实际上是为了保护数据段，数据就是数据，是不能被当作代码执行的。
这里做一个呼应，在上面的2-9-9-12实验中可以看到，当找到PTE时，他的最高位已经变成了8。
这表明我们存储的’a‘就是a，而不能被执行。有一定的程度预防缓冲区溢出漏洞。
在PAE分页模式下，PDE与PTE的最高位为XD/NX位。
###  线性地址0xc0600000
在学习10-10-12分页的时候我们知道：PTE的基址是0xc0000000，PDE的基址是0xc0300000。在这两个线性地址能直接找到PTE和PDE，无需依靠Cr3。
但是在2-9-9-12分页模式下，没有指向Cr3的线性地址。但是仍然有一个特殊的线性地址：0xc0600000。
这个线性地址可以通过反编译`ntkrnlpa.exe`中的`MmIsAddressValid`函数找到。这个函数的作用就是判断线性地址可不可用。
他这里是sub，其实等同于add 0xC0600000
虽然没有线性地址指向cr3，那么有什么对应关系呢？
获取PDPTE指针。
    kd> !dq 0ac40340
    # ac40340 00000000`18733001 00000000`18674001
    # ac40350 00000000`18675001 00000000`185b2001
获取0xc0600000线性地址的PDE
    kd> !dq 0ac40340  + 3*8
    kd> !dq 185b2000 + 3*8
    kd> !dq 185b2000
    #185b2000 00000000`18733063 00000000`18674063
    #185b2010 00000000`18675063 00000000`185b2063
可以发现c0600000对应的PDE重新指回了PDPTT四个指针。
第三个PDPTE指向了一个PDT表，此表的前四项 指向了PDPTE的每一个元素。
## TLB
假设我们有如下代码：
    mov eax,dword ptr ds:[12345678]
这行代码会通过线性地址12345678和当前进程的cr3一起去找到对应的物理地址，而整个过程，实际上要访问PDE和PTE甚至是PDPTE，显然不只是四个字节。在2-9-9-12会读24个字节，如果跨页可能更多。
再看下面一段代码:
    mov eax,dword ptr ds:[12345ffe]
在0x12345ffe位置下读取4字节的数据，那么实际上会读取到下一个页的地址，那么这里又会牵扯到PDE和PTE的访问和读取数据，这显然是非常损耗效率的。
为了提高效率，只能用一块缓存来做记录。
于是CPU内部做了一个表，来记录这些东西，这个表格是CPU内部的，和寄存器一样快，这个表格叫：TLB（Translation Lookaside
Buffer）。
###  TLB结构
LA存储的是线性地址，PA是对应的物理地址，ATTR是属性，如果是10-10-12分页， ~~那么是PDE和PTE的属性AND起来~~ 。
如果是2-9-9-12分页， ~~属性是PDPTE PDE PTE三个属性AND起来的~~ 。
实际上有些属性是or起来的，比如XD位，G位。
LRU是用来统计这个线性地址的读写情况的，这是因为TLB这个表在CPU内部，那么他就不会很大，当线性地址存储满了的时候，他就会看LRU的统计情况，把读写的次数比较少的项删除，然后再把新的线性地址项添上。
不同的CPU 这个表的大小不一样。
只要Cr3变了，TLB立马刷新，一核一套TLB。这个也比较好理解，Cr3切换代表进程的切换，进程变了自然线性地址与物理地址的对应关系也失去了意义。
>
> 但有这样一个需求：在4GB虚拟空间内，低2G是用户自己的数据，高2G是系统的数据，高2G的内容对于每个进程来说，几乎都是相同的，那么当进程切换的时候，也意味着Cr3变化了，我们不希望TLB中所有的数据都被删除，重建的话耗费很多时间并影响效率，希望有一些高2G空间的线性地址所指引的物理地址项被保留，如何做到这一点呢？
这实际上与PDE和PTE属性中G位相关，G位表明该物理页为全局的，当Cr3切换时，TLB不会清空ATTR(属性)中G位为1的项，这也是为什么很多高线性地址属性的G位都为1的原因。
###  TLB种类
TLB在X86体系的CPU里的实际应用最早是从Intel的486CPU开始的，在X86体系的CPU里边，一般都设有如下4组TLB（也就是上面说的一套TLB）:
第一组：缓存一般页表（4K字节页面）的指令页表缓存（Instruction-TLB）。
第二组：缓存一般页表（4K字节页面）的数据页表缓存（Data-TLB）。
第三组：缓存大尺寸页表（2M/4M字节页面）的指令页表缓存（Instruction-TLB）。
第四组：缓存大尺寸页表（2M/4M字节页面）的数据页表缓存（Data-TLB）。
> TLB有多大这个没说，不同cpuTLB的大小不同。
###  TLB是确实存在的
TLB看不见摸不着，我们怎么知道他是否真实存在呢？
看如下一段代码：
    #include "stdafx.h"
    #include 
    unsigned int g_value=0;
    __declspec(naked) void test()
    {
        __asm
        {
            push 0x30;
            pop fs;
            pushad;
            pushfd;