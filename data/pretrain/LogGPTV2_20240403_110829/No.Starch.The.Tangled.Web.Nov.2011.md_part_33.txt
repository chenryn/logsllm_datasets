x.send();
Borrowing from W3C’s proposal, the resulting request will bear an Origin
header, and the response data will be revealed to the caller only if a match-
ing Access-Control-Allow-Origin header is present in the response.* Preflight
requests and permission caching are not a part of the design.
For all intents and purposes, Microsoft’s solution is far more reasonable
than CORS: It is simpler, safer, and probably just as functional in all the plau-
sible uses. That said, it is also unpopular. It is supported only in Internet
Explorer 8 and up, and owing to W3C backing CORS, others have no reason
to embrace XDomainRequest anytime soon.
In the meantime, a separate group of researchers have proposed a third
solution, again acting under the auspices of W3C. Their design, known as Uni-
form Messaging Policy (complete with a corresponding UniformRequest API),4
embraces an approach nearly identical to Microsoft’s. It is not supported in
any existing browser, but there is some talk of unifying it with CORS.
Other Uses of the Origin Header
The Origin header is an essential part of CORS, XDomainRequest, and UMP,
but it actually evolved somewhat independently with other uses in mind. In
their 2008 paper, Adam Barth, Collin Jackson, and John C. Mitchell5 advo-
cated the introduction of a new HTTP header that would offer a more reli-
able and privacy-conscious alternative to Referer. It would also serve as a way
toprevent cross-site request vulnerabilities by providing the server with the
information needed to identify the SOP-level origin of a request, without
disclosing the potentially more sensitive path or query data.
Of course, it was unclear whether the subtle improvement between
Referer and its proposed successor would actually make a difference for the
small but nonnegligible population of users who block that first header on
privacy grounds. The proposal consequently ended up in a virtual limbo,
not being deployed in any existing browsers but also discouraging others
from pursuing other solutions such as XSRF or XSSI.6 (To be fair, the con-
cept was very recently revived under the new name of From-Origin and may
not be completely dead yet.)7
* The reason for this check, even if the response is not authenticated, is to prevent the use of the
browser as a proxy (for example, to crawl internal networks or send out spam).
240 Chapter 16
The fate of the original idea aside, the utility of the Origin header in spe-
cialized cases such as CORS was pretty clear. Around 2009, this led to Barth
submitting an IETF draft specifying the syntax of the header,8 while shying
away from making any statements about when the header should be sent, or
what specific security problems it might solve:
The user agent MAY include an Origin header in any HTTP
request.
[…]
Whenever a user agent issues an HTTP request from a “privacy-
sensitive” context, the user agent MUST send the value “null” in
the Origin header.
NOTE: This document does not define the notion of a privacy-
sensitive context. Applications that generate HTTP requests can
designate contexts as privacy-sensitive to impose restrictions on
how user agents generate Origin headers.
The bottom line of this specification is that whatever the decision pro-
cess is, once the client chooses to provide the header, the value is required to
accurately represent the SOP origin from which the request is being made.
For example, when a particular operation takes place from http://www
.bunnyoutlet.com:1234/bunny_reports.php, the transmitted value should be
Origin: http://www.bunnyoutlet.com:1234
For origins that do not meaningfully map to a protocol-host-port tuple,
the browser must send the value of null instead.
Despite all of these plans, as of this writing only one browser includes the
Origin header on non-CORS navigation: WebKit-based implementations send
it when submitting HTML forms. Firefox seems to be considering a different
approach, but nothing specific seems to have been implemented yet.
Security Model Restriction Frameworks
Designs that extend the bounds of the same-origin policy are fairly simple to
understand and typically fail securely. If the proposed change is not accounted
for in one of the possible code paths, or is simply not supported in a particu-
lar browser, the previously implemented, more restrictive logic will kick in.
Compared with this, it is far more dangerous to try to erect new boundaries
on top of the existing browser security model. That’s because every security-
sensitive code path must be tweaked to recognize the new scheme and every
browser must comply right away, or unexpected problems will arise.
In this section, we will take a quick look at some of the more accomplished
attempts to take this dangerous but potentially rewarding path—and explore
where they come apart.
New and Upcoming Security Features 241
Content Security Policy
Content Security Policy (CSP) is an unusually comprehensive security frame-
work first proposed by Brandon Sterne of Mozilla in 2008.9 The framework
was originally envisioned as an all-encompassing way to mitigate the impact
of common web vulnerabilities, from XSRF to XSS, and as a tool for website
owners to perform a variety of non-security content-policing tasks.
In the years that followed, CSP evolved rapidly, and on several occasions,
its scope changed in major ways. (For example, the author quickly abandoned
the plan to address XSRF vulnerabilities, delegating the job to the yet unreal-
ized extensions of the Origin header.) In fact, as of this writing, the canonical
Mozilla specification is being rewritten as a W3C draft,10 resulting in substantial
differences in the implementation shipped in Firefox and the partial support
implemented in WebKit by Adam Barth. (Internet Explorer and Opera do not
support CSP and have not announced any specific plans to embrace it.)
Primary CSP Directives
At its core, Sterne’s design permits site owners to specify per-document poli-
cies that constrain the ability of the subject document to perform actions that
would normally be permitted under the same-origin policy. For example, CSP
may prevent a page from loading any external subresources except for images
and restrict image sources to only a set of trusted origins, like so:
X-Content-Security-Policy: default-src 'none'; img-src http://*.example.com
As should be evident from this example, the policies may be encoded in
an HTTP header. Under the W3C draft, it is also possible to embed them in
the document itself (using  tags) or host the policy at an external URL
and point to it with policy-uri.
For every content source directive, the author of the policy may specify
any number of fully qualified origins or wildcard expressions that match mul-
tiple hosts, protocols, or ports. Three special keywords (none, self, and data:)
correspond to an empty set, the origin associated with the policy-bearing
page, or all inline data: URLs, in corresponding order.
As of today, the following behaviors can be controlled with CSP directives:
 Script execution A script-src directive can be used to specify the proto-
col, host, and port for permissible  URLs. Normally, the CSP
disables the ability to embed scripts inline in the document (whether
through standalone  blocks or via event handlers) and of existing
scripts to carelessly pass strings to functions such as eval(...), setTimeout(...),
setInterval(...), and so on. Because of this, the script-src directive is useful
for limiting the impact of XSS vulnerabilities: Any markup injected by
the attacker will be limited to loading scripts legitimately hosted in one
of the approved origins.*
* CSP offers several ways to shoot yourself in the foot here. For one, it is possible to re-enable script
execution with settings such as inline-script (Mozilla’s naming, changed to disable-xss-protection in
W3C draft) or eval-script. Perhaps less obviously, it is also possible to make the mistake of permit-
ting data: or * as a permissible origin or allowing an HTTP origin on an HTTPS site.
242 Chapter 16
 Plug-in content This is controlled through object-src. Because plug-ins
such as Java or Flash may have unconstrained access to the embedding
page, the directive should be considered largely analogous to script-src,
and the two directives must be restricted in a comparable way to achieve
any security benefits.
 Stylesheets and fonts This is controlled by style-src and font-src. Unlike its
handling of scripts, CSP originally did not prevent inline  blocks
or style= parameters from appearing on the page. Therefore, any attacker
exploiting an XSS flaw could dramatically alter the appearance and func-
tion of the vulnerable page (or worse),* and these two directives only served
nonsecurity goals, with the possible exception of limiting mixed-content
bugs. Only moments before the publication of the book, the specifica-
tions have been amended to include a more robust approach to CSS.
 Passive multimedia Directives such as img-src or media-src control the
ability to embed multimedia content from specific origins. As with the
original design of CSS controls, this could not have been considered a
security feature. For example, in the case of an XSS bug, CSP would not
have prevented the attacker from leveraging stylesheets to draw arbitrary
shapes on the vulnerable page or even animating them to some extent.
 Subframes The frame-src directive specifies the acceptable destinations
for any  tags encountered on the page; the policy of the parent
page is not inherited by the framed document. To preserve the value of
other XSS mitigations, steps must be taken not to allow data: URLs here
(see Chapter 10).
 Default policy Known as default-src in the W3C draft, and under a more
cryptic name (allow) in Mozilla documentation, the directive specifies fall-
back behavior for any content not covered by a more specific directive.
The directive is required, even in cases where it is technically unnecessary.
NOTE It may be unfortunate that CSP directives are selected to map very closely to individual
HTML tags, instead of grouping functionally similar behaviors. Because of this, it is dif-
ficult to appreciate the tricky interactions among settings such as script-src, frame-src,
and object-src. Also, the approach is simply not very future-safe: There already are
some peripheral classes of subresources (such as “favicons”) that are excluded from
CSPaltogether, and that list will probably unintentionally grow.
In an unusual departure from the subresource-driven model outlined thus
far, CSP also features an oddball directive called frame-ancestors. This parameter
is meant to mitigate the impact of clickjacking by specifying the allowed ances-
tors for the current document in a manner similar to the better-established
X-Frame-Options header (outlined in Chapter 11). The frame-ancestors logic is
completely independent of default-src or any other parts of CSP; its default
value is “*”.
* Remember advanced selectors in CSS3? By cleverly leveraging them in injected stylesheets,
some information about the strings appearing on the page may be conveniently relayed to a
third-party server without the use of JavaScript.
New and Upcoming Security Features 243
Many other possible extensions of the policy are being discussed as of
this writing. These include a script-nonce directive that could be used to more
securely embed inline scripts (every script block must begin with a policy-
specified, unpredictable token, often making XSS exploitation harder) and
asandbox directive, which offers an alternative interface to another security
mechanism, discussed in “Sandboxed Frames” on page245.
Policy Violations
The policy specified according to these rules constrains the behavior of the
underlying document. Violations normally result in a failed subresource load,
the failure to execute an inline script, or the inhibition of page rendering
(inthe special case of frame-ancestors).
Because CSP controls a wide range of content behaviors, and because the
default failure mode is fairly brutal, the authors perceived a need to ease the
worries of webmasters. To make CSP more user-friendly, and perhaps also in
a naïve attempt to offer exploit detection, an optional feature of CSP allows
the browser to report all policy violations immediately back to the owner of the
site. This feature can be enabled through the report-uri keyword in the policy.
To further simplify deployment, it is also possible to roll out any policy—or
part thereof—in a “soft” mode, where violations result only in an HTTP noti-
fication but do not actually break the page. This is achieved by specifying the
policy inside a header named X-Content-Security-Policy-Report-Only.*
Criticisms of CSP
CSP is a remarkably sensible and consistent design compared to most of the
one-off security features proposed or deployed in the browser world. Never-
theless, from its inception, the proposal has been haunted by recurring
design and implementation concerns.
Perhaps the most prosaic complaint about CSP is a nonsecurity one: In
order to benefit from the XSS defenses offered by the framework, webmasters
have to move all inline scripts on the page (often hundreds of individual snip-
pets of code) to a separately requested document; in the new drafts of CSP, the
same will be required for all stylesheets. The complexity of retrofitting exist-
ing pages to work with CSP and the performance penalty of an additional
HTTP request are often prohibitive. (It may be possible to resolve this prob-
lem with the script-nonce extension proposed in the most recent drafts.)
A more fundamental concern with the design of CSP is that the currently
envisioned origin-level granularity of the rulesets may not offer a sufficiently
robust defense against XSS. Consider the fact that any complex, real-life
domain may well host a dozen largely separate web applications, each consist-
ing of hundreds of possibly unrelated static scripts and JavaScript APIs. Attack-
ers exploiting an XSS vulnerability in a CSP-protected site are prevented from
directly executing a malicious script, but they may be able to put the applica-
tion into an inconsistent and possibly dangerous state by loading the existing
* As a side note, this feature is useful not only for short-term experiments but also for detecting
noncritical issues on an ongoing basis. For example, the owner of a site may leverage it to detect
mixed-content issues by creating a report-only policy for HTTPS pages that will be violated by
any HTTP scripts.
244 Chapter 16
scripts in the wrong context or in an incorrect sequence. The history of vul-
nerabilities in nonweb software suggests that such state corruption condi-
tions are exploitable more often than we may think.
An even more troubling prospect is that an attacker can load a sub-
resource that is not truly a script but that might be mistaken for one. An
extreme example of this may be a browser supporting E4X (see Chapter 6):
Any valid XHTML document in which the attacker can place a nominally
harmless string—say, {alert("Hi mom!")}—may result in code execution when
loaded via . Recognizing this problem, the developers decided
to require whitelisted Content-Type values for any scripts loaded under CSP,
but even this approach is often insufficient.
To understand what may go wrong, consider the exceedingly common
practice of hosting public JSONP APIs in which the client can specify the
name of the callback function:
GET /store_locator_api.cgi?zip=90210&callback=myResultParser HTTP/1.0
...
HTTP/1.0 200 OK
Content-Type: application/x-javascript
...
myResultParser({ "store_name": "Spacely Space Sprockets",
"street": … });
Such an API anywhere within a CSP-permitted origin may be leveraged
by an attacker to call arbitrary existing functions in the client-side code, per-
haps together with attacker-controlled parameters. And if the callback string
is not constrained to alphanumerics (and why should it be?), specifying
callback=alert(1);// will lead to straightforward code injection.
Issues with granularity aside, CSP deserves some gentle criticism for its
sometimes puzzling and detrimental lack of focus. On one hand, through
the inclusion of directives such as frame-descendants or sandbox, it seems to be
flirting with the idea of building a single, unifying browser security frame-
work—only to unexpectedly exclude XSRF flaws from its scope without offer-
ing a viable alternative beyond a vague mention of Origin. On the other hand,
the proposal often aspires to be just a “Content Policy,” with no special atten-
tion paid to offering sufficiently robust and intuitive security properties. The
ease of creating dangerous script policies, coupled with the originally ineffec-
tive policing of stylesheets and images, is a testament to this trend.
Sandboxed Frames
Sandboxed frames11 are an extension of the normal  behavior.
Theyallow the owner of the top-level page to place certain additional restric-
tions on the embedded document along with any of that document’s sub-
frames. The goal is to make it safer for web applications to embed potentially
New and Upcoming Security Features 245
untrusted advertisements, gadgets, or preformatted HTML documents on an
otherwise sensitive site. The refinement of the design and the initial imple-
mentation of this feature in WebKit (which is currently the only engine sup-
porting it) was driven by Adam Barth.
NOTE Curiously, sandboxed frames are not exactly a novel idea: Microsoft came up with a
similar proposal almost a decade earlier. Since version 6, Internet Explorer has sup-
ported a proprietary security=restricted parameter, which forces the target frame to be
rendered in the Restricted Zone, effectively removing its ability to execute scripts, navi-
gate to other locations, and so on. However, no one seemed interested in using this fea-
ture for anything other than bypassing certain client-side JavaScript security mechanisms
(most notably, anticlickjacking checks). We will soon know whether the HTML5 succes-
sor fares any better.
The design of sandboxed frames is fairly simple: Any frame embedded in
a document may be constrained by specifying the sandbox parameter on the
appropriate  tag. By default, the document subject to this restriction
is prevented from executing scripts and performing certain types of naviga-
tions. The permissions may be fine-tuned with one or more whitespace-
delimited keywords, specified as a value for the sandbox parameter itself:
 Allow-scripts In the absence of this keyword, the document displayed
inside the frame will be unable to execute JavaScript code. The primary
function of this feature is to prevent the embedded document from per-
forming DoS attacks, opening browser dialogs, or employing any other
complex automation of the page.
 Allow-forms When this keyword is absent, any HTML forms encountered
in the embedded document will not work. This mechanism is designed
to prevent the framed content from exploiting its placement on a trusted
website to phish for sensitive information. (Note that with allow-scripts
enabled, there is little or no point in allow-forms. Scripts may easily con-
struct form-like controls and automatically relay the collected informa-
tion to another site without the need for a functioning  tag.)
 Allow-top-navigation This keyword re-enables the ability of the embed-
ded page to navigate the top-level window. This type of navigation is nor-
mally permitted as one of the exceptions to the same-origin policy (see
Chapter 11), and it may be abused simply to prevent the user from inter-
acting with the embedding site or to carry out phishing attacks.
 Allow-same-origin Without this flag, the content inside a sandboxed
frame is assigned a unique, randomly selected, synthetic origin. This
prevents the page from accessing any origin-bound content that would
normally be available to scripts executing in the domain it is nominally
hosted in. The inclusion of allow-same-origin removes the synthetic origin
and permits same-origin data access.
246 Chapter 16
Scripting, Forms, and Navigation
The first three restrictions available to sandboxed frames—scripting, forms,