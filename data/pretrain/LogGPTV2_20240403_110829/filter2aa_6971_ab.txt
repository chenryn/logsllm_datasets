PI	| 圆周率（3.141592653589793）
E	| 自然对数的底数（2.718281828459045）
# 数值类型转换
将 `Integer` 对象转换为 `Float` 对象时，可以使用 `to_f` 方法。相反，使用 `to_i` 方法则可以将 `Float` 对象转换为 `Integer` 对象（`Integer.to_i` 方法和 `Float.to_f` 方法返回与接收者一样的值）。另外，也可以把字符串转换为数值。
```ruby
p 10.to_f       #=> 10.0
p 10.8.to_i     #=> 10
p -10.8.to_i    #=> -10
p "123".to_i    #=> 123
p "12.3".to_f   #=> 12.3
```
`Float.to_i` 方法返回的结果会把小数点以后的值去掉。我们用 `round` 方法对小数进行四舍五入的处理。
```ruby
p 1.2.round    #=> 1
p 1.8.round    #=> 2
p -1.2.round   #=> -1
p -1.8.round   #=> -2
```
返回比接收者大的最小整数用 `ceil` 方法，返回比接收者小的最大整数用 `floor` 方法。
```ruby
p 1.5.ceil     #=> 2
p -1.5.ceil    #=> -1
p 1.5.floor    #=> 1
p -1.5.floor   #=> -2
```
我们还可以将数值转换为 `Rational` 对象和 `Complex` 对象，分别使用 `to_r` 和 `to_c` 方法，如下所示。
```ruby
p 1.5.to_r     #=> (3/2)
p 1.5.to_c     #=> (1.5+0i)
```
# 位运算
`Integer` 类的位运算符
运算符	| 运算
-       | -
`~`	    | 按位取反（一元运算符）
`&`	    | 按位与
`|`	    | 按位或
`^`	    | 按位异或 ((a&~b|~a&b))
`>>`	| 位右移
` 11110000
pb(~b)             #=> 00001111
pb(b & 0b00010001) #=> 00010000
pb(b | 0b00010001) #=> 11110001
pb(b ^ 0b00010001) #=> 11100001
pb(b >> 3)         #=> 00011110
pb(b  10000000
```
# 随机数
有时候随机性可能会帮助我们解决一些问题。随机性一般有以下特质。
- 没有规则和法则依据
- 一定范围内的数会均等地出现
    拿掷骰子为例，我们不能预测下一个投出的是哪一面，但骰子各个面投出的几率都是一样的。我们把这样的情况称为随机，随机得到的数值称为随机数。在掷骰子或者洗扑克牌那样需要偶然性的情况下，或者像加密后的密码那样希望得到一些难以被预测的数据时，一般都会用到随机数。
    我们可以用 `Random.rand` 方法得到随机数。不指定参数时，`Random.rand` 方法返回比 1 小的浮点小数。参数为正整数时，返回 0 到该正整数之间的数值。
    ```ruby
    p Random.rand        #=> 0.13520495197709
    p Random.rand(100)   #=> 31
    p Random.rand(100)   #=> 84
    ```
    程序不能生成真正的随机数，只能通过某种算法生成看起来像随机数的值，这样的随机数称为模拟随机数。生成模拟随机数需要以某个值为基础，这个值称为随机数的种子。模拟随机数终究只是通过计算得到的数值，只要随机数的种子一样，那么得到值就有可能重复出现。使用 `Random.new` 方法初始化随机数生成器，然后再使用 `Random.rand` 方法，就可以对 `Random` 对象指定随机数种子，从而生成随机数。
    ```ruby
    r1 = Random.new(1)    # 初始化随机数组
    p [r1.rand, r1.rand]
    #=> [0.417022004702574, 0.7203244934421581]
    r2 = Random.new(1)    # 再次初始化随机数组
    p [r2.rand, r2.rand]
    #=> [0.417022003702574, 0.7203244934421581]
    ```
    `Random.new` 方法不指定参数的情况下，则会用随机生成的随机数种子初始化 `Random` 对象，因此每次得到的随机数组也会不一样。
    ```ruby
    r1 = Random.new
    p [r1.rand, r1.rand]
    #=> [0.49452535392946817, 0.34141702823098863]
    r2 = Random.new
    p [r2.rand, r2.rand]
    #=> [0.9464262066747281, 0.01911968591048996]
    ```
    在信息安全领域中，“优质的随机”是一个重要的课题。生成用于加密 key 的随机数时，不能重复出现是非常重要的，因此就需要我们慎重地选择难以被预测的随机种子。在一些特殊的情况下可能会需要初始化 `Random` 对象，而一般情况下直接用最开始介绍的 `Random.rand` 方法就足够了。
# 计数
除了数值计算外，`Integer` 类还能计算处理的次数、数组的元素个数等。接下来介绍的方法就是按照数值指定的次数执行循环处理的迭代器。
- `n.times{|i| … }`
    循环 n 次，从 0 到 n-1 的值会被依次赋值给块变量。
    ```ruby
    ary = []
    10.times do |i|
    ary  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    ```
- `from.upto(to){|i| … }`
    从 from 开始循环对 i 进行加 1 处理，直到 i 等于 to。from 比 to 大时不会执行循环处理。
    ```ruby
    ary = []
    2.upto(10) do |i|
    ary  [2, 3, 4, 5, 6, 7, 8, 9, 10]
    ```
- `from.downto(to){…}`
    从 from 开始循环对 i 进行减 1 处理，直到 i 等于 to。from 比 to 小时不会执行循环处理。
    ```ruby
    ary = []
    10.downto(2) do |i|
    ary  [10, 9, 8, 7, 6, 5, 4, 3, 2]
    ```
- `from.step(to, step){…}`
    从 from 开始循环对 i 进行加 step 处理，直到 i 等于 to。step 为正数时，from 比 to 大时不会执行循环处理。step 为负数时，from 比 to 小时不会执行循环处理。
    ```ruby
    ary = []
    2.step(10, 3) do |i|
    ary  [2, 5, 8]
    ary = []
    10.step(2, -3) do |i|
    ary  [10, 7, 4]
    ```
    如果不对 `times`、`upto`、`downto`、`step` 的各方法指定块，则会返回 `Enumerator` 对象。这样，之前通过 `step` 方法的块获取的一连串数值，就同样也可以通过 `Enumerator.collect` 方法获取。
    ```ruby
    ary = 2.step(10).collect{|i| i * 2}
    p ary    #=> [4, 6, 8, 10, 12, 14, 16, 18, 20]
    ```
# 近似值误差
处理浮点小数时很容易因误差产生问题。这里我们来看看具体的例子，执行下面的程序后会产生意想不到的结果。
```ruby
a = 0.1 + 0.2
b = 0.3
p [a, b]    #=> [0.3, 0.3]
p a == b    #=> false
```
虽然我们期待 0.1 + 0.2 与 0.3 的比较结果为 `true`，但实际结果却是 `false`。为什么会这样呢？
在 10 进制中，就像 1/10、1/100、1/1000……这样，我们会用 10 取幂后的倒数来表示数值。而另一方面，`Float` 类的浮点小数则是用 2 取幂后的倒数来表示，如 1/2、1/4、1/8……。因此，在处理 1/5、1/3 这种用 2 进制无法正确表示的数值时，结果就会产生误差。而如果要用 2 进制的和来表示这类数值的话，计算机就必须在适当的位置截断计算结果，这样就产生了近似值误差。
如果可以把小数转换为两个整数相除的形式，那么通过使用 `Rational` 类进行运算，就可以避免近似值误差。
```ruby
a = Rational(1, 10) + Rational(2, 10)
b = Rational(3, 10)
p [a, b]    #=> [(3/10), (3/10)]
p a == b
```
另外，Ruby 还提供了 `bigdecimal` 库，可以有效处理拥有更多小数位的 10 进制数。
**Comparable 模块**
Ruby 的比较运算符（`==`、``
- `==`
- `>=`
- `>`
- `between?`
Comparable 模块中的各运算符都会使用 `` 运算符的结果。`` 运算符如果能像下表那样定义的话，上表中的各个方法就都可以使用。
状态        | 结果
- | -
a <> 时	    | -1（比 0 小）
a == b 时	| 0
a > b 时	| 1（比 0 大）
下面的 `Vector` 类表示拥有 x 和 y 两个坐标的向量。为了比较向量间的坐标，这里定义了 `` 运算符。然后，通过包含（include）`Comparable` 模块，就可以实现上表中的比较方法。
```ruby
class Vector
  include Comparable
  attr_accessor :x, :y
  def initialize(x, y)
    @x, @y = x, y
  end
  def scalar
    Math.sqrt(x ** 2 + y ** 2)
  end
  def  (other)
    scalar  other.scalar
  end
end
v1 = Vector.new(2, 6)
v2 = Vector.new(4, -4)
p v1  v2    #=> 1
p v1  false
p v1 > v2      #=> true
```