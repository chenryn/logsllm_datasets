https://datatracker.ietf.org/doc/html/draft-ietf-tls-hybrid-design-00
Force.
Work in Progress.
https://
openquantumsafe.org
[107] the Open Quantum Safe project. [n.d.]. Open Quantum Safe.
[108] William Whyte, Zhenfei Zhang, Scott Fluhrer, and Oscar Garcia-Morchon. 2017.
Quantum-Safe Hybrid (QSH) Key Exchange for Transport Layer Security (TLS)
version 1.3. Internet-Draft draft-whyte-qsh-tls13-06. Internet Engineering Task
Force. https://datatracker.ietf.org/doc/html/draft-whyte-qsh-tls13-06 Work in
Progress.
[109] Yuval Yarom, Daniel Genkin, and Nadia Heninger. 2017. CacheBleed: a timing
attack on OpenSSL constant-time RSA. Journal of Cryptographic Engineering 7,
2 (June 2017), 99–112. https://doi.org/10.1007/s13389-017-0152-y
[110] Zhenfei Zhang, Cong Chen, Jeffrey Hoffstein, William Whyte, John M. Schanck,
Andreas Hulsing, Joost Rijneveld, Peter Schwabe, and Oussama Danba. 2019.
NTRUEncrypt. Technical Report. National Institute of Standards and Technology.
available at https://csrc.nist.gov/projects/post-quantum-cryptography/round-
2-submissions.
[111] Zhengyu Zhang, Puwen Wei, and Haiyang Xue. 2019. Tighter Security Proofs
for Post-quantum Key Encapsulation Mechanism in the Multi-challenge Setting.
In CANS 19 (LNCS, Vol. 11829), Yi Mu, Robert H. Deng, and Xinyi Huang (Eds.).
Springer, Heidelberg, 141–160. https://doi.org/10.1007/978-3-030-31578-8_8
A CRYPTOGRAPHIC DEFINITIONS
KEMTLS depends on several cryptographic primitives and standard
security definitions thereof.
H,A = Pr(cid:2)(𝑚, 𝑚′) ←$ A : (𝑚 ̸= 𝑚′) ∧ (H(𝑚) = H(𝑚′))(cid:3)
Definition A.1 (Hash function and collision resistance). A hash
function H : {0, 1}∗ → {0, 1}𝜆 maps arbitrary-length messages
𝑚 ∈ {0, 1}∗ to a hash value H(𝑚) ∈ {0, 1}𝜆 of fixed length 𝜆 ∈ N.
The collision resistance of a hash function H measures the ability
of an adversary A to find two distinct messages that hash to the
same output:
AdvCOLL
Definition A.2 (Pseudorandom function). A pseudorandom func-
tion PRF : K × L → {0, 1}𝜆 maps a key 𝑘 ∈ K and a label ℓ ∈ L
to an output of fixed length in {0, 1}𝜆. The PRF-security of a pseu-
dorandom function PRF measures the ability of an adversary A to
distinguish the output of PRF from random:
PRF,A =(cid:12)(cid:12)(cid:12)Pr(cid:104)𝑘 ←$ K : APRF(𝑘,·) ⇒ 1(cid:105) − Pr(cid:104)A𝑅(·) ⇒ 1(cid:105)(cid:12)(cid:12)(cid:12)
AdvPRF-sec
.
where 𝑅 : L → {0, 1}𝜆 is a truly random function.
A pseudorandom function satisfies dual-PRF-security [4] if it is a
pseudorandom function with respect to either of its inputs 𝑘 or ℓ
being the key, i.e., if both PRF and PRF′ : (𝑥, 𝑦) ↦→ PRF(𝑦, 𝑥) have
PRF-security.
Definition A.3 (Message authentication code and existential un-
forgeability under chosen message attack). A message authentication
code MAC : K ×{0, 1}∗ → {0, 1}𝜆 maps a key 𝑘 ∈ K and a message
𝑚 ∈ {0, 1}∗ to an authentication tag of fixed length in {0, 1}𝜆. The
existential unforgeability under chosen message attack (EUF-CMA)
measures the ability to forge an authentication tag on a new mes-
sage, given access to a tag-generation oracle, as shown in Fig. 5:
AdvEUF-CMA
MAC,A = Pr(cid:104)𝐺EUF-CMA
MAC,A ⇒ 1(cid:105).
Key encapsulation mechanisms.
A key encapsulation mechanism KEM is 𝛿-correct [53] if
Pr[ KEM.Decapsulate(sk, ct) ̸= ss | (pk, sk) ←$ KEM.Keygen();
(ss, ct) ←$ KEM.Encapsulate(pk) ] ≤ 𝛿.
The IND-CPA, IND-1CCA, and IND-CCA experiments for KEMs
are shown in Figure 6. The advantage of A in breaking IND-atk
CCS ’20, November 9–13, 2020, Virtual Event, USA
Schwabe, Stebila, Wiggers
𝐺EUF-CMA
MAC,A
1: 𝑘 ←$ K
2: 𝐿 ←$ ∅
3: (𝑚, 𝑡) ←$ AO
4: return ⟦(𝑡 = MAC(𝑘, 𝑚)) ∧ (𝑚 ̸∈ 𝐿)⟧
Oracle O(𝑧)
1: 𝐿 ← 𝐿 ∪ {𝑧}
2: return
MAC(𝑘, 𝑧)
stage aims to establish a key. Let M ∈ N denote the number of
stages.
For each session, each participant maintains the following collec-
tion of session-specific information. Many of the values are vectors
of length M, with values for each stage.
Figure 5: Security experiment for existential unforgeability
under chosen message attack (EUF-CMA-security) of a mes-
sage authentication code MAC.
)
𝐺IND-atk
KEM,A
1: (pk★, sk★) ←$ KEM.Keygen()
2: 𝑏 ←$ {0, 1}
0 , ct★) ←$ KEM.Encapsulate(pk★)
3: (ss★
1 ←$ K
4: ss★
5: 𝑏′ ←$ AO(pk★, ct★, ss★
6: return ⟦𝑏′ = 𝑏⟧
Oracle O(ct) for IND-CPA
1: return ⊥
Oracle O(ct) for IND-1CCA and IND-CCA
1: if ct ̸= ct★ (for IND-1CCA: and this is first O query) then
2:
3: else
4:
return KEM.Decapsulate(sk★, ct)
return ⊥
𝑏
Figure 6: Security experiments for indistinguishability (IND)
of KEMs under chosen plaintext (atk = CPA), single chosen
ciphertext (atk = 1CCA), and (multiple) chosen ciphertext
(atk = CCA) attacks.
security of KEM, for atk ∈ {CPA, 1CCA, CCA}, is AdvIND-atk
KEM,A =
(cid:12)(cid:12)(cid:12)Pr(cid:104)𝐺IND-atk
KEM,A ⇒ 1(cid:105) − 1
2
(cid:12)(cid:12)(cid:12).
B REDUCTIONIST SECURITY ANALYSIS OF
KEMTLS
Our approach adapts the security model and reductionist security
analysis of the TLS 1.3 handshake by Dowling, Fischlin, Günther,
and Stebila [38, 39] for KEMTLS.
B.1 Model syntax
The set U denotes the set of identities of honest participants in
the system. Identities 𝑆 ∈ U can be associated with a certified
long-term KEM public key pk𝑆 and corresponding private key sk𝑆.
In the server-only authentication version of KEMTLS, participants
that only act as clients do not have a long-term key.
Each participant can run multiple instances of the protocol, each
of which is called a session. Sessions of a protocol are, for the
purposes of modelling, uniquely identified by some administrative
label, 𝜋 ∈ U × N, which is a pair (𝑈 , 𝑛), such that it identifies
the 𝑛th local session of 𝑈 . In a multi-stage protocol, each session
consists of multiple stages, run sequentially with shared state; each
• id ∈ U: the identity of the session owner,
• pid ∈ U ∪ {∗}: the identity of the intended communication
partner. This partner may be unknown, which we indicate
by the wildcard symbol ‘∗’.
• role ∈ {initiator, responder}
• status ∈ {⊥, running, accepted, rejected}M: the status of
each stage key. We set status𝑖 ← accepted when a session
accepts the 𝑖th stage key. When rejecting a key, status𝑖 ←
rejected and the protocol does not continue. Initially set to
(running,⊥×5).
• stage ∈ {0, 1, . . . , M}: the last accepted stage. Initially set to
0, it is incremented to 𝑖 when status𝑖 reaches accepted.
tially set to ⊥, it is updated when reaching acceptance in
that stage.
• sid ∈(cid:0){0, 1}∗ ∪ {⊥}(cid:1)M: the session identifier in stage 𝑖. Ini-
• cid ∈(cid:0){0, 1}∗ ∪ {⊥}(cid:1)M: the contributive identifier in stage 𝑖.
Initially set to ⊥ and updated until reaching acceptance in
that stage.
• key ∈ (K ∪ {⊥})M: the key established in stage 𝑖, which is
set on acceptance. Initially ⊥.
• revealed ∈ {true, false}M: records if the 𝑖th-stage key has
been revealed by the adversary. Initially all false.
• tested ∈ {true, false}M: records if key𝑖 has been tested by
the adversary. Initially all false.
• auth ∈ {1, . . . , M,∞}M: indicates by which stage a stage
key is considered to be explicitly authenticated: if auth𝑖 = 𝑗,
then, once stage 𝑗 has accepted, the key established in stage
𝑖 is considered to be explicitly authenticated. Some keys
may be considered authenticated right away (auth𝑖 = 𝑖),
whereas other keys may only be considered authenticated
retroactively (auth𝑖 > 𝑖), after some additional confirmation
message has been received; some may never be authenticated
(auth𝑖 = ∞).
• FS ∈ {wfs1, wfs2, fs}M×M: for 𝑗 ≥ 𝑖, FS𝑖,𝑗 indicates the type
of forward secrecy expected of stage key 𝑖, assuming stage 𝑗
has accepted.
• use ∈ {internal, external}M: use𝑖 indicates if a stage-𝑖 key
is used internally in the key exchange protocol. (Internally
used keys require a little bit of extra care when testing them,
while externally used keys may only be used outside the
handshake protocol.)
For a session identified by 𝜋, we may write 𝜋 .𝑋 as shorthand to
refer to that session’s element 𝑋.
We define the partner of 𝜋 at stage 𝑖 to be the 𝜋′ such that 𝜋 .sid𝑖 =
𝜋′.sid𝑖 ̸= ⊥ and 𝜋 .role ̸= 𝜋′.role; the contributive partner is defined
analogously using contributive identifiers cid. Correctness requires
that, in a honest joint execution of the protocol, this equality holds
for all stages on acceptance.
Post-Quantum TLS Without Handshake Signatures
CCS ’20, November 9–13, 2020, Virtual Event, USA
B.2 Adversary interaction
Following DFGS [38, 39], our two security properties, Match secu-
rity and Multi-Stage security, take place within the same adversary
interaction model. The adversary A is a probabilistic algorithm
which controls the communication between all parties and thus
can intercept, inject or drop any message. In this type of model,
even two honest parties require A to facilitate communication to
establish a session.
Some combinations of queries will be restricted; for example,
allowing the adversary to both reveal and test a particular session
key would allow the adversary to trivially win the test challenge in
Multi-Stage security, and thus does not model security appropri-
ately. Such a session will be declared unfresh.
The first two queries the adversary has access to model honest
protocol functionality:
• NewSession(𝑈 , 𝑉 , role): Creates a new session 𝜋 with owner
𝜋 .id ← 𝑈 , intended peer 𝜋 .pid ← 𝑉 , with 𝜋 .role ← role. 𝑉
may be left unspecified (𝑉 = ∗).
• Send(𝜋, 𝑚): Sends message 𝑚 to session 𝜋. If 𝜋 has not been
created by NewSession, return ⊥. Otherwise, Send runs the
protocol on behalf of 𝜋 .id. It will record the updated state,
and return both the response message and 𝜋 .status𝜋 .stage.
To initiate a session, the adversary may submit the special
symbol 𝑚 = init if 𝜋 .role = initiator.
Special handling of acceptance. The adversary may not test
any keys that have already been used. Because internal keys
may be used immediately, Send will pause execution when-
ever any key is accepted, and immediately return accepted
to the adversary. The adversary may choose to test the ses-
sion (or do other operations in other sessions). Whenever
the adversary decides to continue this session, they may
submit Send(𝜋, continue). This will continue the protocol as
specified. We set 𝜋 .status𝜋 .stage+1 ← running (except when
having accepted the last stage) and return the next protocol
message and 𝜋 .status𝜋 .stage.
Whenever stage 𝑖 accepts, if there exists a partner 𝜋′ of 𝜋 at
stage 𝑖 with 𝜋′.tested𝑖 = true, we set 𝜋 .tested𝑖 ← true. If the
stage is furthermore an internal-use stage (𝜋 .use𝑖 = internal),
we also set 𝜋 .key𝑖 ← 𝜋′.key𝑖 to ensure session keys are used
consistently.
The next two queries model the adversary’s ability to compro-
mise participants and learn some secret information:
• Reveal(𝜋, 𝑖): Reveals the session key 𝜋 .key𝑖 to the adversary,
and records 𝜋 .revealed𝑖 ← true. If the session does not exist
or the stage has not accepted, returns ⊥.
• Corrupt(𝑈 ): Provides the adversary with the long-term se-
cret key sk𝑈 of 𝑈 . We record the time of party 𝑈 ’s corruption.
The final query models the challenge to the adversary of breaking
a key that was established by honest parties:
• Test(𝜋, 𝑖): Challenges the adversary on the indistinguisha-
bility of stage key 𝜋 .key𝑖 as follows. If the stage has not
accepted (𝜋 .status𝑖 ̸= accepted), or the key has already been
tested (𝜋 .tested𝑖 = true), or there exists a partner 𝜋′ to 𝜋 at
stage 𝑖 such that 𝜋′.tested𝑖 = true, return ⊥.
If the stage 𝑖 key use is internal (𝜋 .use𝑖 = internal), a partner
𝜋′ to 𝜋 at stage 𝑖 must exist and also have 𝜋′.status𝑖+1 = ⊥
(this ensures that any partnered session has also not yet used
the key). If this does not hold, return ⊥.
Set 𝜋 .tested𝑖 ← true.
The Test oracle has a uniformly random bit 𝑏, which is fixed
throughout the game. If test bit 𝑏 = 0, we sample a uniformly
random key 𝐾 ←$ K. If test bit 𝑏 = 1, we set 𝐾 ← 𝜋 .key𝑖.
To make sure that the selected 𝐾 is consistent with any later
internally used keys, we set 𝜋 .key𝑖 = 𝐾 if 𝜋 .use𝑖 = internal.
We then ensure consistency with partnered sessions: for ses-
sions 𝜋′ that are partner to 𝜋 at stage 𝑖 for which 𝜋′.status𝑖 =
accepted, set 𝜋′.tested𝑖 ← true, and, if 𝜋 .use𝑖 = internal,
set 𝜋′.key𝑖 ← 𝐾.
Return 𝐾 to the adversary.
B.3 Specifics of KEMTLS in the model
For the proofs in the subsequent subsections, KEMTLS is as spec-
ified in Fig. 4, with M = 6 stages. The session identifiers sid𝑖 and
contributive identifiers cid𝑖 for each stage are defined as follows.
Whenever a stage is accepted, its session identifier is set to consist
of a label and all handshake messages up to that point:
sid1 = (“CHTS”, ClientHello . . . ServerHello) ,
sid2 = (“SHTS”, ClientHello . . . ServerHello) ,
sid3 = (“CAHTS”, ClientHello . . . ClientKemCiphertext) ,
sid4 = (“SAHTS”, ClientHello . . . ClientKemCiphertext) ,
sid5 = (“CATS”, ClientHello . . . ClientFinished) ,
sid6 = (“SATS”, ClientHello . . . ServerFinished) .
For the contributive identifiers cid𝑖 we need special care for
the first stage. In stage 𝑖 = 1, the client and server set, upon
sending (client) or receiving (server) the ClientHello message,
cid1 = (“CHTS”, ClientHello). When they next send (server)
or receive (client) the ServerHello response, they update this to
cid1 = sid1. All other contributive identifiers are set to cid𝑖 = sid𝑖
whenever sid𝑖 is set.
(internal×4, external×2), and
Every client session of KEMTLS uses auth = (6, 6, 6, 6, 6, 6), use =
Every server session of KEMTLS uses auth = (∞×6), use =
(internal×4, external×2), and FS𝑖,𝑗 = wfs1 for all 𝑗 ≥ 𝑖.
B.4 Match security
Match security models sound behaviour of session matching: it en-
sures that, for honest sessions, the session identifier 𝜋 .sid matches
the partnered 𝜋′.sid. (Separately treating the session matching
property of AKE protocols is the approach of [25, 26, 38, 39, 41].)
Definition B.1. Match Security
FS =
wfs1 wfs1 wfs1 wfs1 wfs1
wfs1 wfs1 wfs1 wfs1
wfs2 wfs2 wfs2
wfs2 wfs2
wfs2
(cid:169)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:171)
(cid:170)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:172)
fs
fs
fs
fs
fs