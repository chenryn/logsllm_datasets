https://datatracker.ietf.org/doc/html/draft-ietf-tls-hybrid-design-00
Force.
Work in Progress.
https://
openquantumsafe.org
[107] the Open Quantum Safe project. [n.d.]. Open Quantum Safe.
[108] William Whyte, Zhenfei Zhang, Scott Fluhrer, and Oscar Garcia-Morchon. 2017.
Quantum-Safe Hybrid (QSH) Key Exchange for Transport Layer Security (TLS)
version 1.3. Internet-Draft draft-whyte-qsh-tls13-06. Internet Engineering Task
Force. https://datatracker.ietf.org/doc/html/draft-whyte-qsh-tls13-06 Work in
Progress.
[109] Yuval Yarom, Daniel Genkin, and Nadia Heninger. 2017. CacheBleed: a timing
attack on OpenSSL constant-time RSA. Journal of Cryptographic Engineering 7,
2 (June 2017), 99â€“112. https://doi.org/10.1007/s13389-017-0152-y
[110] Zhenfei Zhang, Cong Chen, Jeffrey Hoffstein, William Whyte, John M. Schanck,
Andreas Hulsing, Joost Rijneveld, Peter Schwabe, and Oussama Danba. 2019.
NTRUEncrypt. Technical Report. National Institute of Standards and Technology.
available at https://csrc.nist.gov/projects/post-quantum-cryptography/round-
2-submissions.
[111] Zhengyu Zhang, Puwen Wei, and Haiyang Xue. 2019. Tighter Security Proofs
for Post-quantum Key Encapsulation Mechanism in the Multi-challenge Setting.
In CANS 19 (LNCS, Vol. 11829), Yi Mu, Robert H. Deng, and Xinyi Huang (Eds.).
Springer, Heidelberg, 141â€“160. https://doi.org/10.1007/978-3-030-31578-8_8
A CRYPTOGRAPHIC DEFINITIONS
KEMTLS depends on several cryptographic primitives and standard
security definitions thereof.
H,A = Pr(cid:2)(ğ‘š, ğ‘šâ€²) â†$ A : (ğ‘š Ì¸= ğ‘šâ€²) âˆ§ (H(ğ‘š) = H(ğ‘šâ€²))(cid:3)
Definition A.1 (Hash function and collision resistance). A hash
function H : {0, 1}âˆ— â†’ {0, 1}ğœ† maps arbitrary-length messages
ğ‘š âˆˆ {0, 1}âˆ— to a hash value H(ğ‘š) âˆˆ {0, 1}ğœ† of fixed length ğœ† âˆˆ N.
The collision resistance of a hash function H measures the ability
of an adversary A to find two distinct messages that hash to the
same output:
AdvCOLL
Definition A.2 (Pseudorandom function). A pseudorandom func-
tion PRF : K Ã— L â†’ {0, 1}ğœ† maps a key ğ‘˜ âˆˆ K and a label â„“ âˆˆ L
to an output of fixed length in {0, 1}ğœ†. The PRF-security of a pseu-
dorandom function PRF measures the ability of an adversary A to
distinguish the output of PRF from random:
PRF,A =(cid:12)(cid:12)(cid:12)Pr(cid:104)ğ‘˜ â†$ K : APRF(ğ‘˜,Â·) â‡’ 1(cid:105) âˆ’ Pr(cid:104)Ağ‘…(Â·) â‡’ 1(cid:105)(cid:12)(cid:12)(cid:12)
AdvPRF-sec
.
where ğ‘… : L â†’ {0, 1}ğœ† is a truly random function.
A pseudorandom function satisfies dual-PRF-security [4] if it is a
pseudorandom function with respect to either of its inputs ğ‘˜ or â„“
being the key, i.e., if both PRF and PRFâ€² : (ğ‘¥, ğ‘¦) â†¦â†’ PRF(ğ‘¦, ğ‘¥) have
PRF-security.
Definition A.3 (Message authentication code and existential un-
forgeability under chosen message attack). A message authentication
code MAC : K Ã—{0, 1}âˆ— â†’ {0, 1}ğœ† maps a key ğ‘˜ âˆˆ K and a message
ğ‘š âˆˆ {0, 1}âˆ— to an authentication tag of fixed length in {0, 1}ğœ†. The
existential unforgeability under chosen message attack (EUF-CMA)
measures the ability to forge an authentication tag on a new mes-
sage, given access to a tag-generation oracle, as shown in Fig. 5:
AdvEUF-CMA
MAC,A = Pr(cid:104)ğºEUF-CMA
MAC,A â‡’ 1(cid:105).
Key encapsulation mechanisms.
A key encapsulation mechanism KEM is ğ›¿-correct [53] if
Pr[ KEM.Decapsulate(sk, ct) Ì¸= ss | (pk, sk) â†$ KEM.Keygen();
(ss, ct) â†$ KEM.Encapsulate(pk) ] â‰¤ ğ›¿.
The IND-CPA, IND-1CCA, and IND-CCA experiments for KEMs
are shown in Figure 6. The advantage of A in breaking IND-atk
CCS â€™20, November 9â€“13, 2020, Virtual Event, USA
Schwabe, Stebila, Wiggers
ğºEUF-CMA
MAC,A
1: ğ‘˜ â†$ K
2: ğ¿ â†$ âˆ…
3: (ğ‘š, ğ‘¡) â†$ AO
4: return âŸ¦(ğ‘¡ = MAC(ğ‘˜, ğ‘š)) âˆ§ (ğ‘š Ì¸âˆˆ ğ¿)âŸ§
Oracle O(ğ‘§)
1: ğ¿ â† ğ¿ âˆª {ğ‘§}
2: return
MAC(ğ‘˜, ğ‘§)
stage aims to establish a key. Let M âˆˆ N denote the number of
stages.
For each session, each participant maintains the following collec-
tion of session-specific information. Many of the values are vectors
of length M, with values for each stage.
Figure 5: Security experiment for existential unforgeability
under chosen message attack (EUF-CMA-security) of a mes-
sage authentication code MAC.
)
ğºIND-atk
KEM,A
1: (pkâ˜…, skâ˜…) â†$ KEM.Keygen()
2: ğ‘ â†$ {0, 1}
0 , ctâ˜…) â†$ KEM.Encapsulate(pkâ˜…)
3: (ssâ˜…
1 â†$ K
4: ssâ˜…
5: ğ‘â€² â†$ AO(pkâ˜…, ctâ˜…, ssâ˜…
6: return âŸ¦ğ‘â€² = ğ‘âŸ§
Oracle O(ct) for IND-CPA
1: return âŠ¥
Oracle O(ct) for IND-1CCA and IND-CCA
1: if ct Ì¸= ctâ˜… (for IND-1CCA: and this is first O query) then
2:
3: else
4:
return KEM.Decapsulate(skâ˜…, ct)
return âŠ¥
ğ‘
Figure 6: Security experiments for indistinguishability (IND)
of KEMs under chosen plaintext (atk = CPA), single chosen
ciphertext (atk = 1CCA), and (multiple) chosen ciphertext
(atk = CCA) attacks.
security of KEM, for atk âˆˆ {CPA, 1CCA, CCA}, is AdvIND-atk
KEM,A =
(cid:12)(cid:12)(cid:12)Pr(cid:104)ğºIND-atk
KEM,A â‡’ 1(cid:105) âˆ’ 1
2
(cid:12)(cid:12)(cid:12).
B REDUCTIONIST SECURITY ANALYSIS OF
KEMTLS
Our approach adapts the security model and reductionist security
analysis of the TLS 1.3 handshake by Dowling, Fischlin, GÃ¼nther,
and Stebila [38, 39] for KEMTLS.
B.1 Model syntax
The set U denotes the set of identities of honest participants in
the system. Identities ğ‘† âˆˆ U can be associated with a certified
long-term KEM public key pkğ‘† and corresponding private key skğ‘†.
In the server-only authentication version of KEMTLS, participants
that only act as clients do not have a long-term key.
Each participant can run multiple instances of the protocol, each
of which is called a session. Sessions of a protocol are, for the
purposes of modelling, uniquely identified by some administrative
label, ğœ‹ âˆˆ U Ã— N, which is a pair (ğ‘ˆ , ğ‘›), such that it identifies
the ğ‘›th local session of ğ‘ˆ . In a multi-stage protocol, each session
consists of multiple stages, run sequentially with shared state; each
â€¢ id âˆˆ U: the identity of the session owner,
â€¢ pid âˆˆ U âˆª {âˆ—}: the identity of the intended communication
partner. This partner may be unknown, which we indicate
by the wildcard symbol â€˜âˆ—â€™.
â€¢ role âˆˆ {initiator, responder}
â€¢ status âˆˆ {âŠ¥, running, accepted, rejected}M: the status of
each stage key. We set statusğ‘– â† accepted when a session
accepts the ğ‘–th stage key. When rejecting a key, statusğ‘– â†
rejected and the protocol does not continue. Initially set to
(running,âŠ¥Ã—5).
â€¢ stage âˆˆ {0, 1, . . . , M}: the last accepted stage. Initially set to
0, it is incremented to ğ‘– when statusğ‘– reaches accepted.
tially set to âŠ¥, it is updated when reaching acceptance in
that stage.
â€¢ sid âˆˆ(cid:0){0, 1}âˆ— âˆª {âŠ¥}(cid:1)M: the session identifier in stage ğ‘–. Ini-
â€¢ cid âˆˆ(cid:0){0, 1}âˆ— âˆª {âŠ¥}(cid:1)M: the contributive identifier in stage ğ‘–.
Initially set to âŠ¥ and updated until reaching acceptance in
that stage.
â€¢ key âˆˆ (K âˆª {âŠ¥})M: the key established in stage ğ‘–, which is
set on acceptance. Initially âŠ¥.
â€¢ revealed âˆˆ {true, false}M: records if the ğ‘–th-stage key has
been revealed by the adversary. Initially all false.
â€¢ tested âˆˆ {true, false}M: records if keyğ‘– has been tested by
the adversary. Initially all false.
â€¢ auth âˆˆ {1, . . . , M,âˆ}M: indicates by which stage a stage
key is considered to be explicitly authenticated: if authğ‘– = ğ‘—,
then, once stage ğ‘— has accepted, the key established in stage
ğ‘– is considered to be explicitly authenticated. Some keys
may be considered authenticated right away (authğ‘– = ğ‘–),
whereas other keys may only be considered authenticated
retroactively (authğ‘– > ğ‘–), after some additional confirmation
message has been received; some may never be authenticated
(authğ‘– = âˆ).
â€¢ FS âˆˆ {wfs1, wfs2, fs}MÃ—M: for ğ‘— â‰¥ ğ‘–, FSğ‘–,ğ‘— indicates the type
of forward secrecy expected of stage key ğ‘–, assuming stage ğ‘—
has accepted.
â€¢ use âˆˆ {internal, external}M: useğ‘– indicates if a stage-ğ‘– key
is used internally in the key exchange protocol. (Internally
used keys require a little bit of extra care when testing them,
while externally used keys may only be used outside the
handshake protocol.)
For a session identified by ğœ‹, we may write ğœ‹ .ğ‘‹ as shorthand to
refer to that sessionâ€™s element ğ‘‹.
We define the partner of ğœ‹ at stage ğ‘– to be the ğœ‹â€² such that ğœ‹ .sidğ‘– =
ğœ‹â€².sidğ‘– Ì¸= âŠ¥ and ğœ‹ .role Ì¸= ğœ‹â€².role; the contributive partner is defined
analogously using contributive identifiers cid. Correctness requires
that, in a honest joint execution of the protocol, this equality holds
for all stages on acceptance.
Post-Quantum TLS Without Handshake Signatures
CCS â€™20, November 9â€“13, 2020, Virtual Event, USA
B.2 Adversary interaction
Following DFGS [38, 39], our two security properties, Match secu-
rity and Multi-Stage security, take place within the same adversary
interaction model. The adversary A is a probabilistic algorithm
which controls the communication between all parties and thus
can intercept, inject or drop any message. In this type of model,
even two honest parties require A to facilitate communication to
establish a session.
Some combinations of queries will be restricted; for example,
allowing the adversary to both reveal and test a particular session
key would allow the adversary to trivially win the test challenge in
Multi-Stage security, and thus does not model security appropri-
ately. Such a session will be declared unfresh.
The first two queries the adversary has access to model honest
protocol functionality:
â€¢ NewSession(ğ‘ˆ , ğ‘‰ , role): Creates a new session ğœ‹ with owner
ğœ‹ .id â† ğ‘ˆ , intended peer ğœ‹ .pid â† ğ‘‰ , with ğœ‹ .role â† role. ğ‘‰
may be left unspecified (ğ‘‰ = âˆ—).
â€¢ Send(ğœ‹, ğ‘š): Sends message ğ‘š to session ğœ‹. If ğœ‹ has not been
created by NewSession, return âŠ¥. Otherwise, Send runs the
protocol on behalf of ğœ‹ .id. It will record the updated state,
and return both the response message and ğœ‹ .statusğœ‹ .stage.
To initiate a session, the adversary may submit the special
symbol ğ‘š = init if ğœ‹ .role = initiator.
Special handling of acceptance. The adversary may not test
any keys that have already been used. Because internal keys
may be used immediately, Send will pause execution when-
ever any key is accepted, and immediately return accepted
to the adversary. The adversary may choose to test the ses-
sion (or do other operations in other sessions). Whenever
the adversary decides to continue this session, they may
submit Send(ğœ‹, continue). This will continue the protocol as
specified. We set ğœ‹ .statusğœ‹ .stage+1 â† running (except when
having accepted the last stage) and return the next protocol
message and ğœ‹ .statusğœ‹ .stage.
Whenever stage ğ‘– accepts, if there exists a partner ğœ‹â€² of ğœ‹ at
stage ğ‘– with ğœ‹â€².testedğ‘– = true, we set ğœ‹ .testedğ‘– â† true. If the
stage is furthermore an internal-use stage (ğœ‹ .useğ‘– = internal),
we also set ğœ‹ .keyğ‘– â† ğœ‹â€².keyğ‘– to ensure session keys are used
consistently.
The next two queries model the adversaryâ€™s ability to compro-
mise participants and learn some secret information:
â€¢ Reveal(ğœ‹, ğ‘–): Reveals the session key ğœ‹ .keyğ‘– to the adversary,
and records ğœ‹ .revealedğ‘– â† true. If the session does not exist
or the stage has not accepted, returns âŠ¥.
â€¢ Corrupt(ğ‘ˆ ): Provides the adversary with the long-term se-
cret key skğ‘ˆ of ğ‘ˆ . We record the time of party ğ‘ˆ â€™s corruption.
The final query models the challenge to the adversary of breaking
a key that was established by honest parties:
â€¢ Test(ğœ‹, ğ‘–): Challenges the adversary on the indistinguisha-
bility of stage key ğœ‹ .keyğ‘– as follows. If the stage has not
accepted (ğœ‹ .statusğ‘– Ì¸= accepted), or the key has already been
tested (ğœ‹ .testedğ‘– = true), or there exists a partner ğœ‹â€² to ğœ‹ at
stage ğ‘– such that ğœ‹â€².testedğ‘– = true, return âŠ¥.
If the stage ğ‘– key use is internal (ğœ‹ .useğ‘– = internal), a partner
ğœ‹â€² to ğœ‹ at stage ğ‘– must exist and also have ğœ‹â€².statusğ‘–+1 = âŠ¥
(this ensures that any partnered session has also not yet used
the key). If this does not hold, return âŠ¥.
Set ğœ‹ .testedğ‘– â† true.
The Test oracle has a uniformly random bit ğ‘, which is fixed
throughout the game. If test bit ğ‘ = 0, we sample a uniformly
random key ğ¾ â†$ K. If test bit ğ‘ = 1, we set ğ¾ â† ğœ‹ .keyğ‘–.
To make sure that the selected ğ¾ is consistent with any later
internally used keys, we set ğœ‹ .keyğ‘– = ğ¾ if ğœ‹ .useğ‘– = internal.
We then ensure consistency with partnered sessions: for ses-
sions ğœ‹â€² that are partner to ğœ‹ at stage ğ‘– for which ğœ‹â€².statusğ‘– =
accepted, set ğœ‹â€².testedğ‘– â† true, and, if ğœ‹ .useğ‘– = internal,
set ğœ‹â€².keyğ‘– â† ğ¾.
Return ğ¾ to the adversary.
B.3 Specifics of KEMTLS in the model
For the proofs in the subsequent subsections, KEMTLS is as spec-
ified in Fig. 4, with M = 6 stages. The session identifiers sidğ‘– and
contributive identifiers cidğ‘– for each stage are defined as follows.
Whenever a stage is accepted, its session identifier is set to consist
of a label and all handshake messages up to that point:
sid1 = (â€œCHTSâ€, ClientHello . . . ServerHello) ,
sid2 = (â€œSHTSâ€, ClientHello . . . ServerHello) ,
sid3 = (â€œCAHTSâ€, ClientHello . . . ClientKemCiphertext) ,
sid4 = (â€œSAHTSâ€, ClientHello . . . ClientKemCiphertext) ,
sid5 = (â€œCATSâ€, ClientHello . . . ClientFinished) ,
sid6 = (â€œSATSâ€, ClientHello . . . ServerFinished) .
For the contributive identifiers cidğ‘– we need special care for
the first stage. In stage ğ‘– = 1, the client and server set, upon
sending (client) or receiving (server) the ClientHello message,
cid1 = (â€œCHTSâ€, ClientHello). When they next send (server)
or receive (client) the ServerHello response, they update this to
cid1 = sid1. All other contributive identifiers are set to cidğ‘– = sidğ‘–
whenever sidğ‘– is set.
(internalÃ—4, externalÃ—2), and
Every client session of KEMTLS uses auth = (6, 6, 6, 6, 6, 6), use =
Every server session of KEMTLS uses auth = (âˆÃ—6), use =
(internalÃ—4, externalÃ—2), and FSğ‘–,ğ‘— = wfs1 for all ğ‘— â‰¥ ğ‘–.
B.4 Match security
Match security models sound behaviour of session matching: it en-
sures that, for honest sessions, the session identifier ğœ‹ .sid matches
the partnered ğœ‹â€².sid. (Separately treating the session matching
property of AKE protocols is the approach of [25, 26, 38, 39, 41].)
Definition B.1. Match Security
FS =
wfs1 wfs1 wfs1 wfs1 wfs1
wfs1 wfs1 wfs1 wfs1
wfs2 wfs2 wfs2
wfs2 wfs2
wfs2
(cid:169)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:171)
(cid:170)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:172)
fs
fs
fs
fs
fs