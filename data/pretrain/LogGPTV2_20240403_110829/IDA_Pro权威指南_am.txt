 指令执行时，栈指针正确地指向所保存的返回地址。这个特殊函数的“尾声”如下所示：
add     esp, 76     ; adjust esp to point to the saved return address  
ret                 ; return to the caller
由于专门使用一个寄存器作为帧指针，并通过一段代码在函数入口点配置了帧指针，因此，计算局部变量偏移量的工作变得更加轻松。在x86程序中，EBP （extended base pointer ，扩展基址指针
 ）寄存器通常专门用作栈帧指针。默认情况下，多数编译器会生成代码以使用帧指针，而无视规定应使用栈指针的选项。例如，GNU gcc/g++ 提供了-fomit-frame-pointer
 编译器选项，可生成不依赖于固定帧指针寄存器的函数。
为了解使用专用帧指针的demo_stackframe
 栈帧的结构，我们以下面这段“序言”代码为例：
➌  push    ebp        ; save the caller's ebp value  
➍  mov     ebp, esp   ; make ebp point to the saved register value  
➎  sub     esp, 76    ; allocate space for local variables  
➌ 处的push
 指令保存当前调用方使用的EBP 的值。遵循用于Intel 32 位处理器的系统V 应用程序二进制接口（System V Application Binary Interface）2
 的函数可以修改EAX、ECX和EDX寄存器，但需要为所有其他寄存器保留调用方的值。因此，如果希望将EBP 作为帧指针，那么，在修改它之前，必须保存EBP 的当前值，并且在返回调用方时恢复EBP 的值。如果需要为调用方保存其他寄存器（如ESI或EDI ），编译器可能会在保存EBP 的同时保存这些寄存器，或者推迟保存操作，直到局部变量已经得到分配。因此，栈帧中并没有用于存储被保存寄存器的标准位置。
2. 参见http://www.sco.com/developers/devspecs/abi386-4.pdf
 。
EBP 被保存后，就可以对其进行修改，使它指向当前的栈位置。这由➍处的mov
 指令来完成，它将栈指针的当前值复制到EBP 中。最后，和在非基于EBP 的栈帧中一样，局部变量的空间在➎处分配。得到的栈帧布局如图6-4所示。
图6-4 基于EBP 的栈帧
使用一个专用的帧指针，所有变量相对于帧指针寄存器的偏移量都可以计算出来。许多时候（尽管并无要求），正偏移量用于访问函数参数，而负偏移量则用于访问局部变量。使用专用的帧指针，我们可以自由更改栈指针，而不至影响帧内其他变量的偏移量。现在，对函数bar
 的调用可以按以下方式执行：
➏  push   dword [ebp-72]  ; push y  
    push   dword [ebp-76]       ; push z  
    call   bar  
    add    esp, 8               ; cdecl requires caller to clear parameters
在执行➏处的push
 指令后，栈指针已经发生改变，但这不会影响到随后的push
 指令对局部变量z
 的访问。
最后，函数完成其操作后，使用帧指针需要一段稍有不同的“尾声”代码，因为在返回前，必须恢复调用方的帧指针。在检索帧指针的初始值之前，必须从栈中清除局部变量。不过，由于当前的帧指针指向最初的帧指针，这个任务可轻松完成。在使用EBP 作为帧指针的x86 程序中，下面的代码是一段典型的“尾声”代码：
mov    esp, ebp      ; clears local variables by reseting esp  
pop    ebp           ; restore the caller's value of ebp  
ret                  ; pop return address to return to the caller
由于这项操作十分常见，因此，x86体系结构提供了leave
 指令，以轻松完成这个任务。
leave                ; copies ebp to esp AND then pops into ebp  
ret                  ; pop return address to return to the caller
其他处理器体系结构使用的寄存器和指令肯定会有所不同，但构建栈帧的基本过程并无明显差异。无论是何种体系结构，你都需要熟悉典型的“序言”和“尾声”代码，以便迅速开始分析函数中你更感兴趣的代码。
6.2.4 IDA 栈视图
很明显，栈帧是一个运行时概念，没有栈和运行中的程序，栈帧就不可能存在。话虽如此，但这并不意味着你在使用IDA 之类的工具进行静态分析时，就可以忽略栈帧的概念。二进制文件中包含配置每个函数的栈帧所需的全部代码。通过仔细分析这段代码，我们可以深入了解任何函数的栈帧的结构，即使这个函数并未运行。实际上，IDA 中的一些最复杂的分析，就是为了专门确定IDA 反汇编的每个函数的栈帧的布局。在初始分析过程中，IDA 会记住每一项push
 或pop
 操作，以及其他任何可能改变栈指针的算术运算，如增加或减去常量，尽其所能去监控栈指针在函数执行过程中的行为。这项分析的第一个目标是确定分配给函数栈帧的局部变量区域的具体大小。其他目标包括：确定某函数是否使用一个专用的帧指针（例如，通过识别push ebp/mov ebp, esp
 序列），以及识别对函数栈帧内变量的所有内存引用。例如，如果IDA 在demo_stackframe
 的正文中发现以下指令：
mov    eax, [ebp+8]
它就知道，函数的第一个参数（此时为a
 ）被加载到EAX寄存器中（见图6-4）。通过仔细分析栈帧的结构，IDA 能够区分访问函数参数（位于被保存的返回地址之下）的内存引用及访问局部变量（位于被保存的返回地址之上）的引用。IDA 还会采取额外的步骤，确定栈帧内的哪些内存位置被直接引用。例如，虽然图6-4中栈帧的大小为96字节，但我们只会看到7 个变量（4 个局部变量和3个参数）被引用。
了解函数的行为通常归结为了解该函数操纵的数据的类型。在阅读反汇编代码清单时，查看函数的栈帧细目，是你了解函数所操纵的数据的第一个机会。IDA 为任何函数栈帧都提供了两种视图：摘要视图和详细视图。为了解这两种视图，我们以下面使用gcc编译的demo_stackframe
 函数为例：
void demo_stackframe(int a, int b, int c) {  
   int x = c;  
   char buffer[64];  
   int y = b;  
   int z = 10;  
   buffer[0] = 'A';  
   bar(z, y);  
}
在这个例子中，我们分别为变量x
 和y
 提供了初始值c
 和b
 。为变量 z
 提供了初始值常量10。另外，64字节局部数组buffer
 的第一个字符被初始化为字母'A'
 。这个函数对应的IDA 反汇编代码如下：
  .text:00401090 ; ========= S U B R O U T I N E ===========================
  .text:00401090  
  .text:00401090 ; Attributes:  ➊ bp-based frame  
  .text:00401090  
  .text:00401090 demo_stackframe proc near      ; CODE XREF: sub_4010C1+41↓ p  
  .text:00401090  
➍ .text:00401090 var_60          = dword ptr -60h  
  .text:00401090 var_5C          = dword ptr -5Ch  
  .text:00401090 var_58          = byte ptr -58h  
  .text:00401090 var_C           = dword ptr -0Ch  
  .text:00401090 arg_4           = dword ptr  0Ch  
  .text:00401090 arg_8           = dword ptr  10h  
  .text:00401090  
  .text:00401090 push    ebp  
  .text:00401091 mov     ebp, esp  
  .text:00401093 sub     esp, ➋ 78h  
  .text:00401096 mov     eax, [ebp+ ➎ arg_8]  
  .text:00401099 ➏ mov     [ebp+var_C], eax  
  .text:0040109C ➐ mov     eax, [ebp+arg_4]  
  .text:0040109F ➐ mov     [ebp+var_5C], eax  
  .text:004010A2 ➑ mov     [ebp+var_60], 0Ah  
  .text:004010A9 ➒ mov     [ebp+var_58], 41h  
  .text:004010AD                 mov     eax, [ebp+var_5C]  
  .text:004010B0 ➌ mov     [esp+4], eax  
  .text:004010B4                 mov     eax, [ebp+var_60]  
  .text:004010B7 ➌ mov     [esp], eax  
  .text:004010BA                 call    bar  
  .text:004010BF                 leave  
  .text:004010C0                 retn  
  .text:004010C0 demo_stackframe endp  
下面我们介绍以上代码中的许多内容，以逐步熟悉IDA 的反汇编代码。首先从➊开始，基于对函数“序言”代码的分析，IDA 认为这个函数使用EBP 寄存器作为栈指针。从位置➋得知，gcc在栈帧中分配了120字节（78h等于120）的局部变量空间，这包括用于向➌处的bar
 传递两个参数的8 字节；但是，它仍然远大于我们前面估算的76 字节，这表示编译器有时会用额外的字节填补局部变量空间，以确保栈帧内的特殊对齐方式。从➍开始，IDA 提供了一个摘要栈视图，列出了栈帧内被直接引用的每一个变量，以及变量的大小和它们与帧指针的偏移距离。
IDA 会根据变量相对于被保存的返回地址的位置，为变量取名。局部变量位于被保存的返回地址之上，而函数参数则位于被保存的返回地址之下。局部变量名称以var_
 为前缀，后面跟一个表示变量与被保存的帧指针之间距离（以字节为单位）的十六进制后缀。在本例中，局部变量var_C
 是一个4 字节（dword ）变量，它位于所保存的帧指针之上，距离为12字节（[ebp-oCh]
 ）。函数参数名则以arg_
 为前缀，后面跟一个表示其与最顶端的参数之间的相对距离的十六进制后缀。因此，最顶端的4字节参数名为arg_0
 ，而随后的参数则分别为arg_4
 、arg_8
 、arg_C
 ，以此类推。在这个特例中，arg_0
 并未列出，因为函数没有使用参数a
 。由于IDA 无法确定任何对[ebp+8]
 （第一个参数的位置）的内存引用，所以arg_0
 并未在摘要栈视图中列出。迅速浏览一下摘要栈视图即可发现，许多栈位置都没有命名，因为在程序代码中找不到对这些位置的直接引用。
说明
  IDA只会为那些在函数中直接引用的栈变量自动生成名称。
IDA 反汇编代码清单与我们前面执行的栈帧分析之间的一个重要区别在于，在反汇编代码清单中无法找到类似于[ebp-12]
 的内存引用。相反，IDA 已经用与栈视图中的符号对应的符号名称，以及它们与栈帧指针的相对偏移量替代了所有常量偏移量。这样做是为了确保IDA 生成更高级的反汇编代码。与处理数字常量相比，处理符号名称更容易一些。实际上，为方便我们记忆栈变量的名称，IDA 允许任意修改任何栈变量的名称，稍后介绍这一点。摘要栈视图则是从IDA 生成的名称到它们对应的栈帧偏移量之间的一个“地图”。例如，在反汇编代码清单中出现内存引用[ebp+arg_8]
 的地方，可以使用[ebp+10h]
 或[ebp+16]
 代替。如果你更希望看到数字偏移量，IDA会乐于为你显示。右击➎处的arg_8
 ，将会出现如图6-5所示的上下文菜单，它提供了几个可用于更改显示格式的选项。
图6-5 选择一种替代的显示格式
在这个特例中，由于可以对照源代码，我们可以利用反汇编窗口中的一系列线索，将IDA 生成的变量名称与源代码中使用的名称对应起来。
首先，demo_stackframe
 使用了3个参数：a
 、b
 和c
 。它们分别与变量arg_0
 、arg_4
 和arg_8
 对应（尽管arg_0
 因没有被引用而被反汇编代码清单忽略了）。
局部变量x
 由参数c
 初始化。因此，var_C
 与x
 对应，因为x
 由➏处的 arg_8
 初始化。
同样，局部变量y
 由参数b
 初始化。因此，var_5C