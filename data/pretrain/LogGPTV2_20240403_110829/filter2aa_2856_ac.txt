  VectorObject	
03d60438	
  and	
  eax,0FFFFFFF8h	
03d6043b	
  mov	
  dword	
  ptr	
  [ebp-­‐94h],eax	
03d60447	
  mov	
  ecx,dword	
  ptr	
  [eax+18h]	
Arg3	
  is	
  the	
  3rd	
  argument	
  of	
  endCoerce	
  and	
  _implGPR.	
Atom	
  BaseExecMgr::endCoerce(MethodEnv*	
  env,	
  int32_t	
  argc,	
  uint32_t	
  *ap,	
MethodSignaturep	
  ms)	
(*env-­‐>method-­‐>_implGPR)(env,	
  argc,	
  ap); 
Real	
  JIT-­‐ed	
  Code	
  Entrance 
VT 
array 
vector length 
Structure	
  of	
  ap 
All	
  of	
  data	
  used	
  in	
  JIT-­‐ed	
  code:	
  object,	
  variable,	
  etc 
[ClassClosure::constructObject()]	
  -­‐>[1064a7ed][ClassClosure::construct	
  or	
  ClassClosure::construct_Na=ve]	
  -­‐>ScriptObject*	
  obj	
  =	
  newInstance()	
  -­‐>jmp	
  102afa16	
  [102afa5a]	
  105f3950	
  new	
  Script_Env	
  and	
  set	
  args	
  buﬀer	
  and	
  length	
  afribute	
  -­‐>[102AFA7D]	
  1027CA36	
  init	
  ap/args	
  structure	
  ...	
  -­‐>ivtable-­‐>init-­‐>coerceEnter(argc,	
  argv)	
  -­‐>verifyInvoke	
  -­‐>[106ae2ee](*env-­‐>method-­‐>_invoker)(env,	
  argc,	
  args)	
  -­‐-­‐	
  jitInvokeNext	
  -­‐>[106d7292]invokeGeneric	
  -­‐>[106ae805]endCoerce	
  -­‐>[106adb21](*env-­‐>method-­‐>_implGPR)(env,	
  argc,	
  ap)	
A  Typical  JIT  Procedure  in  Flash 
Focus	
  on	
  it!	
  Get	
  Args	
  address	
  and	
  buﬀer	
length	
  from	
  Script_Env,	
  and	
  Create	
  a	
  Thread	
to	
  monitor	
  possible	
  vector.,	
  vectorBuﬀer,	
array,	
  etc	
  in	
  Args	
  buﬀer.	
Use	
  vtable	
  to	
  dis=nguish	
  them. 
Memory  Dump  of  Script_Env  and  Args 
Script_Env	
0543e0f8	
  10c7d3c8	
  03a51000	
  03a51000	
  00000000	
0543e108	
  00000000	
  03a510b0	
  00000000	
  00000007	
0543e118	
  00000230	
  00000007	
  00000230	
  00000009	
0543e128	
  00000008	
  00000022	
  1d420001	
  01010016	
0543e138	
  00000001	
  04796000	
  10c7d3c8	
  00000000	
0543e148	
  00000000	
  00000000	
  00000000	
  00000000	
0543e158	
  00000007	
  00000007	
  00000230	
  00000007	
0543e168	
  00000000	
  00000009	
  00000008	
  00000022 
Args	
  [length	
  =	
  0x230]	
03a510b0	
  10bb7240	
  20000003	
  03bb6478	
  03a37a78	
03a510c0	
  00000000	
  00000000	
  03a4b480	
  00000000	
03a510d0	
  00000000	
  06158060	
  0000003b	
  061702b8	
03a510e0	
  00000000	
  03e70040	
  00000000	
  00000000	
03a510f0	
  00000000	
  00000000	
  00000000	
  00000000	
03a51100	
  00000000	
  00000000	
  ﬀﬀﬀﬀ	
  00000000	
03a51110	
  00000000	
  00000000	
  00000001	
  feedface	
03a51120	
  00002000	
  bbbbbbbb	
  00002000	
  00000000	
...	
03a51270	
  00000000	
  00000000	
  03d63f50	
  03a374c0	
03a51280	
  056f0880	
  056f0df8	
  03a1db28	
  00000000	
03a51290	
  056e4fe8	
  03a20160	
  03a201c0	
  00000000	
  03a512a0	
  00000000	
  40440000	
  00000000	
  00000000	
VectorBuﬀer	
062ca020	
  40000000	
  06144000	
  feedbabe	
  00001680	
062ca030	
  babeface	
  00000000	
  00000000	
  00000000	
062ca040	
  00000000	
  00000000	
  00000000	
  00000000	
vectorObject	
03a1db28	
  10c99918	
  00000002	
  03e8b1f0	
  03d46d78	
03a1db38	
  056e2150	
  00000000	
  062ca020	
  00000000	
03a1db48	
  00000000	
  00000000	
Create	
  a	
  thread	
  to	
  monitor	
  this	
  buﬀer	
  of	
  Args	
  and	
ﬁnd	
  *bad*	
  vector 
Whole  process  of  detec4ng  *bad*  vector  
opera4on  in  JIT-­‐ed  Code 
•  Find	
  and	
  hook	
  “new	
  Script_Env”	
•  Get	
  Args	
  buﬀer	
  and	
  length,	
  Create	
  a	
  thread	
  to	
  monitor	
  this	
  buﬀer	
•  Use	
  vtable	
  to	
  dis=nguish	
  possible	
  exploit	
  object[vector.,	
  array,	
etc]	
Turn  on  God  Mode  of  Detec4on 
Exploit	
  Process	
  -­‐	
  exploit.as	
1.	
  Heap	
  Spray	
  and	
  Feng	
  Shui	
2.	
  Trigger	
  the	
  bug	
  and	
  corrupt	
  the	
  length	
  of	
  vector	
3.	
  Find	
  this	
  *bad*	
  vector	
  and	
  use	
  it	
  to	
  do	
  arbitrary	
  Read/Write	
  to	
  build	
  ROP	
  and	
  overwrite	
  v-­‐table	
4.	
  Trigger	
  controlled	
  EIP	
5.	
  Restore	
  and	
  clean 
Hook	
  VectorBaseObject::VectorBaseObject	
  to	
  Record	
  all	
  of	
  allocated	
  Vectors.//	
Create	
  a	
  Thread	
  to	
  Monitor	
  every	
  length	
  change	
  of	
  vectors	
  at	
  the	
  beginning	
  of	
  Ac=onScript	
  was	
parsed 
Hook  Where  1# 
•  Find	
  VectorBaseObject::VectorBaseObject(Simplest	
  Way	
  –	
  AVM.sig)	
Hook  Where  2# 
•  Find	
  DoABCTag	
  Func=on	
  which	
  is	
  responsible	
  for	
  parse	
  DoABC	
  Tag.	
Life  cycle  of  *bad*  vector 
•  Why	
  do	
  we	
  have	
  to	
  monitor	
  the	
  every	
  length	
  change,	
  not	
  check	
  all	
  of	
vectors	
  once	
  at	
  the	
  end	
  of	
  swf	
  ﬁnish	
  ?	
Exploit	
  Process	
  -­‐	
  exploit.as	
1.	
  Heap	
  Spray	
  and	
  Feng	
  Shui	
2.	
  Trigger	
  the	
  bug	
  and	
  corrupt	
  the	
  length	
  of	
  vector	
3.	
  Find	
  this	
  *bad*	
  vector	
  and	
  use	
  it	
  to	
  do	
  arbitrary	
  Read/Write	
  to	
  build	
  ROP	
and	
  overwrite	
  c_cleaner	
  of	
  bad	
  vector	
  itself	
4.	
  Trigger	
  controlled	
  EIP	
  with	
  “bad_vector.length	
  =	
  new_length”	
5.	
  Restore	
  0and	
  clean 
Exploiters	
  can	
  make	
  the	
  life	
  cycle	
  of	
  *bad*	
  vector	
very	
  short	
  ! 
Bad_vector	
  will	
  be	
  free	
  and	
  reallocate.	
  The	
  length	
  of	
  this	
  bad	
  vector	
  will	
  be	
  set	
to	
  new_length,	
  if	
  we	
  check	
  a>er	
  all	
  this	
  happened,	
  everything	
  will	
  be	
  normal.	
Life  cycle  of  *bad*  vector 
•  Why	
  do	
  we	
  have	
  to	
  monitor	
  the	
  every	
  length	
  change,	
  not	
  check	
  all	
  of	
vectors	
  once	
  at	
  the	
  end	
  of	
  swf	
  ﬁnish	
  ?	
Length 
C_Cleaner Data[0] 
Data[1] 
Data[2] 
Data[3] 
Data[4] 
Data[5] 
… 
VectorBuﬀer	
  structure 
*bad*	
  VectorBuﬀer	
  with	
  normal	
  c_cleaner 
40000000 
ABCDEFGH data 
data 
data 
data 
data 
data 
data 
*bad*	
  VectorBuﬀer	
  with	
  *bad*	
  c_cleaner	
bad_vector[3ﬀﬀﬀf]	
  =	
  bad_vector[base+3ﬀﬀﬀf*4+8]	
  =	
  bad_vector[base+4]	
  =	
  DEADBEEF	
40000000 
DEADBEEF data 
data 
data 
data 
data 
data 
data 
Bad_vector.length	
  =	
  0x72,	
  bad	
  c_cleaner[DEADBEEF]	
  will	
  trigger	
  controlled	
  EIP,	
  and	
  bad	
  vector	
  change	
  to	
  normal	
  vector	
00000072 
DEADBEEF data 
data 
data 
data 
data 
data 
data 
Details	
  about	
  how	
  c_cleaner[DEADBEEF]	
  trigger	
  controlled	
  EIP	
  -­‐-­‐	
  hfp://researchcenter.paloaltonetworks.com/2015/05/
the-­‐latest-­‐ﬂash-­‐uaf-­‐vulnerabili=es-­‐in-­‐exploit-­‐kits/ 
Exploit  Mi4ga4on  in  ﬂash_18_0_0_209 
•  Kill	
  the	
  vector-­‐like	
  object	
  with	
  length	
  valida=on	
  and	
  isolated	
  heap	
•  Raise	
  the	
  *bar*	
  of	
  exploit	
Summary 
•  Dissect	
  and	
  unclose	
  some	
  undocumented	
  and	
  uncovered	
  internals	
inside	
  ﬂash	
  for	
  detec=ng	
  ﬂash	
  exploits.	
•  Mul=ple	
  Dimensional	
  Exploit	
  Detec=on	
  Based	
  on	
  the	
  Deep	
Understanding	
  of	
  Exploit	
  Essence	
•  Find	
  Other	
  Possible/Poten=al	
  Exploit	
  Object	
  in	
  Flash	
  In	
  the	
  future	
Thanks 
•  Thanks	
  to	
  Yamata	
  Li	
  and	
  others	
  in	
  IPS	
  Team	
•  Special	
  thanks	
  to	
  @guhe120,	
  @promised_lu	
Ques4ons  ?