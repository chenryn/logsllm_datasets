SLEIGH 看起来参考了其中的一些设计，特别是 SLED 语言的一些基本要素，官方文档并没有太多介绍其思路来源，所以结合上文提到的思路来源会更加容易理解
SLEIGH 语言的一些设计决定，在必要时可以参阅。
### 设计目标
SLEIGH 语言的设计主要考虑到了反汇编和 IR （Intermediate
Representation，中间语言）提升的两个功能，所以可以用于进行生成解码器，同时可以将二进制机器码提升到 IR。提升到 IR
的部分需要对指令的语义进行描述，也就是说明具体某条指令所做的事情。
一种简单暴力的方式用来达到描述指令与机器码对应关系以及指令语义就是直接列举 **所有的指令**
，然后分别列出其语义。但是不用想也知道，这样的方法非常低效，所以在设计时，需要考虑到可以复用的部分。
举例来讲，在汇编中，取址的部分就是可复用的，因为很多指令可能都会采用相同的取址方式。类似的还有寄存器索引，也就是指明指令中所用到的寄存器，在汇编中，很多指令采用了相同的寄存器索引方式，也就是对于指令中特定的几个二进制位，将其翻译为数字，作为一个数组的索引，而这个数组里的内容就是寄存器。这个数组对于很多指令来说是一样的，所以没有必要单独指明每一条指令可能出现的所有情况（所以没有必要将一条指令采用不同寄存器列作不同的指令，这样太繁琐了）。
SLEIGH 的设计，包括其前辈 SLED ，就是考虑了这些情况，然后提出了一些概念，从而更加容易生成解码器。  
不过，SLEIGH 的设计并没有在意汇编部分，虽然这不意味着无法生成指令编码器（事实上 SLEIGH
自己有一个实验性的指令编码器），但是会导致生成过程不如指令解码器容易（这一部分在 Ghidra 的实验性编码器生成过程中也提到了）。
下面我们通过理解 SLEIGH 语言中的几个概念，来理解这种架构描述语言。
### 符号（Symbol）
符号，用我自己的理解，就是 SLEIGH 中用到的各种标识符。如果换到其他常规编程语言中，例如 C 语言中，下面这一句定义：
    int a = 1;
其中的 a 是 _标识符_ ，同时是一个 _变量_ 。如果用我的理解，换到 SLEIGH
中，这里的标识符就对应符号，变量的概念对应后文中的其他概念。（这里其实并不严谨，标识符属于语法概念，变量属于语义概念，而符号在 SLEIGH
中和其他部分一样都属于语义概念，只是便于理解所以如此举例）
符号在 SLEIGH 中主要有两个作用：
  * 显示作用：这个符号在反汇编中应该如何显示？
  * 语义作用：这个符号在生成 IR 的时候应该如何使用？
举例来讲，一个寄存器，就是一个符号。以 x86 架构 rax 寄存器为例，显示作用决定了在反汇编显示的时候， rax 寄存器将被显示为字符串
“rax”，而语义作用决定了生成 IR 的时候，会编码为一个寄存器。
在 SLEIGH 中将符号分为两类：
  * 具体符号（Specific Symbol）
  * 组符号（Family Symbol）
这里的 rax
寄存器，就是一个具体符号，组符号描述指令编码与具体符号之间的对应关系。事实上在我第一次查看文档的时候，这一部分让我非常困扰，难以理解。后来我将这两者的关系当做面向对象中，对象和类的关系，具体符号就是一个对象，而组符号是一个类，这样就容易理解了许多。
至于“组符号决定指令编码与具体符号对应关系”这句话，主要是针对 SLEIGH
作为解码器使用的时候。举例来讲，如果我们将“寄存器”这个概念认为是组符号，将具体的寄存器，例如 rax 寄存器，rbx
寄存器等等认为是具体符号，在编写规范的时候，我们指定指令中某一个位置是寄存器，但具体解码的时候，需要根据具体指令将位于“寄存器”所在位置的部分翻译为具体的某个寄存器。所以这就体现了组符号将指令编码对应到具体符号上。
### 标记（Token）和域（Field）
这两个概念与符号有一定交叉，并不冲突，一个标记或是域也可以被认为是某类型的符号。
标记的概念在 SLED 语言中就提及了，在 SLEIGH 中也基本上延用了。SLED
中将二进制机器码认为是标记的流，解码就是识别各个标记的过程，域则是标记中的一部分，是标记中的一些二进制位。
在 SLEIGH 语言中，标记被限定为 8 个二进制位对齐，也就是以字节（又不是 defcon ，干嘛考虑一个字节不是 8
个二进制位的情况，是吧？对，我就是针对 defcon 25。不过，真有这种情况，应该可以利用修改 SLEIGH
语言对反汇编过程的控制进行模拟）为单位对齐，域则是标记的一部分。
只要我们记住标记和域的概念和符号是有交叉的（并不冲突），其用途也就不难理解了。
举例来讲，我们可以将一条完整的指令当做一个标记，域就是组成这条指令的各个部分，例如其操作码（opcode），第一个操作数，等等。
如果结合符号的概念，域就是一个组符号，因为域将标记中的一部分（一部分二进制位）映射到了具体的符号上（例如具体的某个寄存器，具体的操作数等等）。
在默认情况下，域通通被当做数字处理，SLEIGH 语言通过 attach 关键字，改变域的语义。例如可以将一个域的数字当做寄存器的索引，这种情况下的
SLEIGH 语言：
    attach variables fieldlist registerlist;
其中 fieldlist 是一系列 field 名，这些 field 将被认为是寄存器，而不再被当做简单的数字。 registerlist
则是寄存器的列表，以后这些 field 的含义就会变为这个寄存器列表当中的索引。
### 构造器（Constructor）和表（Table）
对于熟悉编译的同学，以下内容更加便于理解：
构造器用于构造新的符号，如果用上下文无关语法中的概念来对比，这就像是语法中的规则（Rule）。构造器在指明如何构造新的符号的同时，也指出了这个过程的语义（是不是想到了语法制导翻译？）。表则是构造器的一个集合，同样用上下文无关语法来对比，表就像是语法中的非终结符。
我觉得这一部分几乎就是从编译中解析器部分抄过来的，大概也就是改了个名字。不过由于这个名字在 SLED
中就开始用了，所以就由他去吧。。只要大家可以理解就行了。
不过构造器和语法中的规则相比，还多了一个前提要求，也就是 _指令模式_ （Instruction
Pattern），因为只有在符合特定情况下的时候，才能够应用这个规则。例如如果要应用 add 指令对应的构造器，就需要操作码满足要求。
由于 SLEIGH 语言的设计目标是指令解码，所以存在一个提前定义好的”根表“，名为
instruction，这一点非常类似语法解析中的根，也没有什么太特别的，就不再赘述了。
### 解码过程
在 Ghidra 中，解码的过程是自顶向下的，也就是先匹配将要应用的构造器，然后逐步向下直到整个指令被确定。
例如某个 SLEIGH 规范定义如下（只保留了条件，省略了语义、显示等内容）
寄存器：
reg1 和 reg2 为寄存器，列表 [ r0 r1 r2 r3 r4 r5 r6 r7 ]
标号 instr 共 16 位：
  * 域 op 10 到 15 位
  * 域 mode 6 到 9 位
  * 域 reg1 3 到 5 位
  * 域 imm 0 到 2 位
  * 域 reg2 0 到 2 位
instruction表（根）：
  * and reg1,op2 需要满足 op = 0x10，且存在 reg1，op2
  * xor reg1, op2 需要满足 op = 0x11，且存在 reg1，op2
  * or reg1, op2 需要满足 op = 0x12，且存在 reg1，op2
op2 表：
  * reg2，满足 mode = 0，且存在 reg2
  * imm，满足 mode = 1，且存在 imm
  * [reg2]，满足 mode = 2，且存在 reg2
假设一条指令如下:
(10, 15): 0x10  
(6, 9): 0x2  
(3, 5): 0x3  
(0, 2): 0x4
其解析过程，首先通过 instruction 表，确定 op 为 0x10，reg1 为 0x3，对应寄存器为 r2，此时满足 and
对应的构造器（事实上构造器没有名字，这里的 and 是显示部分的内容）。该表使用到了 op2 表，所以接下来解析 op2 表， op2 表中，mode 为
2，满足 [reg2] 构造器，reg2 再根据寄存器，对应到 r4。
最终指令被解析为：`and r2, [r4]`。显示形式可以通过解析后的显示部分推导出来，而具体如何翻译为 IR，可以通过其语义部分进行推导。
## 总结
本文首先对逆向工具进行了简要介绍，主要关注其重点的几个功能，之后介绍了逆向工具中架构规范的相关内容，最后通过 SLEIGH
实例介绍了架构规范，或是架构描述语言的一种形式。
就我个人而言，我认为 SLEIGH 语言还有一定改进的空间。经过思考，我认为 SLEIGH
语言在一定程度上借鉴了上下文无关语法的内容，主要是构造器和表的部分，但是其语法和上下文无关语法的常用形式差距较大，这样就增大了学习成本，所以这是一个可改进的点，通过采用更贴近上下文无关语法的表示形式对
SLEIGH 语法进行改进。这一点比较容易，可以通过翻译到 SLEIGH
语言进行，只是需要一定量的设计，使得语法更加浅显易懂（尽量避免引入难以理解的概念）。