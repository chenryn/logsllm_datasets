我们再用gzip程序对它进行数据压缩，缩短其长度。如下所示：
$g2ip myapp-1.0.tar
S 1s -1 *.gz
- w -r
1rick
users
1580 Feb 11 15:30 myapp-1.0.tar.gz
文件长度的压缩幅度给人以深刻印象。然后，我们把“.tar.gz”后缀名改为一个简单点的
.tgz”后缀名。具体命令如下所示：
$ mv myapp-1.0.tar.gz myapp_v1.tgx
这种以一个句号和三个字符结尾的文件命名方式有点儿象MS-DOS和某些MS-Windows软件
的做法，它们与UNIX的重大区别之一就是前者对后级名正确与否的依赖性非常强。为了取回我
们的文件，我们需要先执行解压缩操作，再从tar文件里把它们释放出来。如下所示：
5mv myapp_v1.tgs ayapp-1.0.tar.gz
s tar xvf myapp-1.0.tar
main.c
2 .C
3.C
a .h
b.h
c.h
xyapp.1
Makefile6
GNU版本的tar命令更方便一些、它只用一个操作就能创建出压缩文档来：如下所示：
S tar zevf myapp_v1.tgz main.c2.c 3.c *.h myapp.1 Makefile6
2 .c
main, c
3.c
a.h
b. h
c .h
myapp.1
Makefile6
$
解压缩操作也比较简单，如下所示：
S tar xxvt myapo_v1.tgx
2.C
nain.c
3 . c
a .h
b.h
c.h
myapp.1
Makefile6
$
tar命令
在上面的例子单我们使用了tar命令，但对它选项的介绍只限于我们曾经用过的那些。在这
里，我们将对这个命令和它的几个常用选项做一个简单的说明。从例子里我们可以看出，它的
加入jaVa编程群：524621833
---
## Page 291
第8章开发工具273
基本语法是：
tar[options ][ list of files]
文件清单里的第一项是该命令的操作目标，虽然我们一直是对文件进行的操作，但它也可
档或现有文档里去，具体操作要视命令选项的设置情况而定。文件清单可以包含子目录，此时
的缺省操作是把所有的下级子目录也添加到文档里。如果执行的是文件释故操作，就没有必要
给出文件的名字，因为tar命令能够在对文件进行归档时保留其完整的路径
在这一小节里，我们使用了下面六个不同选项的组合：
c创建一个新档案。
f指定目标是一个文件而非一个设备。
列出档案的内容，但并没有把它们实际提取出来。
V操作步骤说明状态：随程序的执行显示信息。
X从档案中提取文件。
z从GNU的tar命令里用gzip对档案进行过滤。
tar命令还有许多其他的选项，这些选项允许对命令的操作情况和它将要创建的文档进行细
致的调控。详细资料请参考tar命令的使用手册页。
8.6本章总结
在这一章里，我们向大家介绍了一些UNIX开发工具，它们使程序的设计开发和发行传播工
作更容易管理。最先介绍的make命令和制作文件可以用来管理多个源文件，这可以说是本章最
重要的内容。然后，我们学习了源代码控制方面的知识，它可以让我们在代码开发过程中对各
种修改做跟踪记录。最后，我们学习了patch、tar和gzip等命令的使用方法，它们在程序的发行
和升级方面用处很大。
加入jaVa编程群：524621833
---
## Page 292
第9章调试与纠错
不管多么出色的软件代码也会有小缺陷，一般说来，每100行代码就会有2到3个缺陷。这些
错误将导致程序或函数库无法完成预定的功能，造成实际执行情况与预期执行情况的不一致。
在软件的开发过程中，查找和改正这些缺陷将耗费程序员大量的时间。
在这一章里，我们将对软件的缺陷进行研究，并介绍一些查排程序特定错误行为的工具和
技巧。这与程序测试（以各种可能出现的条件检验程序操作情况的工作）是不一样的，虽然测
试和纠错是密切相关的，并且许多错误正是在测试阶段被发现的。
9.1错误的分类
造成程序缺陷的原因并不是很多、并目它们都可以通过适当的办法进行查找和纠正。
9.1.1功能定义错误
如果程序的功能没有被正确定义，那它肯定不能完成预定的工作。在这种情况下，即使是
世界上最优秀的程序员写出来的程序也是错误的。在开始程序设计（规划阶段）之前，我们必
须确保自己知道和理解要用这个程序干些什么。通过认真研究程序设计要求并加强与该程序使
用者之间的沟通能够纠正许多（即使不是全部）功能定义方面的漏洞。
9.1.2设计规划错误
程序的规模有大有小。在计算机键盘前面坐下来，把源代码直接敲进去，然后程序一次通
过，这种机会虽不能说没有，但确实很少很难遇到。一定要多花点时间对程序的流程和结构进
行分析，看看都需要用到哪些数据结构。尽量把细节问题提前确定下来，这样就能节省许多反
复改写程序的时间。
9.1.3代码编写错误
当然，每个人都有他最容易犯的错误。根据程序规划来创建源代码的过程并不是一个不会
出错的完美过程。大部分程序缺陷都是在这一阶段里产生的。根据以往的经验，当你的程序里
隐藏着缺陷的时候，重新阅读程序或者与其他人进行探讨，这个办法虽然因为过于简单而往往
被人忽视，但它的确很有效。你肯定会对自己通过与他人探讨程序的具体实现而能找出的漏洞
之多感到惊讶。
像C这祥带有编译器的程序设计语言有这样一个优点，那就是语法错误能够在编译
阶段被检查出来，而解释型程序设计语宫，比如UNIX中的shell，就只能在你运行程序
加入java编程群：524621833
---
## Page 293
第9章调试与纠错275
的时候才能检查出语法错误.如果问题出在程序本身的错误处理代码部分里，要想通过
程序测试来找出它们可就太不容易了。
可以试着在纸上执行程序的核心部分，这个过程通常被称为“干运行”。对那些重要的例程，
应该记下它们的输人值，然后一步一步地手工计算出输出结果来。对程序进行调试并不见得非
用计算机不可，有时候，问题可能正是因为计算机本身的原因才出现的。即使那些编写函数库、
编译器和操作系统的人们也会出错！可话又说回来，也不要一出现问题就抱怨是工具的问题，
新程序单出现缺陷的概率要比编译器大的多。
9.2常用调试技巧
对典型UNIX程序的调试和测试工作来说，现在已经有了几种固定的办法。一般的做法是先
运行程序看看会发生哪些事情。如果它根本就不工作，我们再来决定需要采取哪些措施。我们
可以修改程序并重新进行尝试（代码检查-试运行-出错法），也可以在程序里增加一些语句以获
得更多程序内部运行情况的资料（取样法）.还可以直接监测程序的操作情况（受控执行法）。
程序调试可以分为五个阶段，它们是：
·测试：找出都有哪些缺陷和漏洞。
·固化：让缺陷反复出现。
·定位：确定应该对此负责的代码行。
·改正：对代码进行修改。
·复查：确定修改解决了问题。
9.2.1一个有漏洞的程序
我们先来看一个带有缺陷和漏洞的示例程序，在本章的学习过程中，我们将对它进行调试
纠错。这个程序是在某个大型软件系统的开发过程中编写出来的。它的作用是对一个名为sort的
函数进行测试，该函数准备通过管泡排序算法对一个类型为item的结构数组进行排序。数据项将
以其成员之一的key为对象进行递增排序。程序对一个测试用数组调用sort以测试它的工作情况。
在现实世界里，我们可能永远也不会使用这个算法，因为它的执行效率实在是太低了。我们之
所以在这里使用这个算法，原因就在于它比较短小，相对来说简单易懂，但也更容易出现错误。
事实上，标准的C语言库里已经有一个这样的函数了，它的名字是qsort。
这段代码读起来稍微有点儿费劲，里面没有注释，也不知道最初的程序员是哪一位。只能
靠我们自已了，我们先从最基本的例程debug1.c人手。下面是它的程序清单：
3
char 'data;
4/item:
int key:
5
*/
8
* /
(*bi11-
i*neil*,
31,
("john*.
4)
10
('riek". 5),
加入jaVa编程群：524621833
---
## Page 294
276
Linux程序设计
1 1
(*alex', 11,
/*
12
* /
}：
/*
13
* /
1. 4
* /
item *a;
sort (a,n)
15
*/
/*
16
*/
f*
17
int 1 = 0. j =0:
18
/
*/
int s = 1:
/*
19
*
20
} *
for(: i a[j+l].key){
/ *
25
2 4
·/
a[j] = a[j+1]
iten t s a[]:
· /
92
*/
 = 1▪[]
27
* /
5++ :
/*
28
→ /
/*
30
*/
31
+ /
* /
*
32
* /
* /
34
*/
main()
SC
*/
36
* /
sort (array.5) :
我们米编译这个程序。
S cc -o debug1 debug1.c
编译进行的很顺利，既没有报告出错也没有警告信息。
在我们运行这个程序之前，先在其中添加一些代码把它的结果打印出来。要不然我们连这
个程序是否在工作都不会知道。我们额外增加一些语句把排序后的数组打印出来。我们把这个
新版本称为debug2.c。新增加的代码如下所示：
/*34
/*
main()
36
35
*/
int i;
/*
38
*/
for（i=0;i<5:i++)
sort(array.5):
/*
6