## Page 127
因此二叉查找树还有另一个名字—二叉排序树（binarysorttree）。
新插入的节点，同样要遵循二叉排序树的原则。例如插入新元素5，由
于53，5>4，所以5最终会插入到节点4的右孩子位置。
3
8
6
5
再如插入新元素10，由于10>6，10>8，10>9，所以10最终会插入到节点
9的右孩子位置。
6
3
8
9
10
这一切看起来很顺利，然而却隐藏着一个致命的问题。什么问题呢？下
面请试着在二叉查找树中依次插入9、8、7、6、5、4，看看会出现什么
结果。
---
## Page 128
10
9
11
8
哈哈，好好的一个二叉树，变成“跋
脚"啦！
不只是外观看起来变得怪异了，查询
---
## Page 129
节点的时间复杂度也退化成了0(n)。
怎么解决这个问题呢？这就涉及二叉树的自平衡了。二叉树自平衡的
方式有多种，如红黑树、AVL树、树堆等。由于篇幅有限，本书就不一
一详细讲解了，感兴趣的读者可以查一查相关资料。
除二叉查找树以外，二叉堆也维持着相对的顺序。不过二叉堆的条件
要宽松一些，只要求父节点比它的左右孩子都大，这一点在后面的章节
中我们会详细讲解。
好了，有关树和二叉树的基本知识，
我们就讲到这里。
本节所讲的内容偏于理论方面，没有
涉及代码。但是下一节讲解二叉树的遍历时，会涉及大量代码，大
家要做好准备哦！
3.2
二叉树的遍历
3.2.1
为什么要研究遍历
---
## Page 130
小东，上一节我们讲了二叉
树的基础知识，接下来我们
来探讨一下二叉树的遍历，
不就是遍历吗？有什么
好探讨的呢？
apdus oo} Bunof 001
二叉树是非线性数据结构.
它的遍历过程可没你想象得
那么简单
当我们介绍数组、链表时，为什么没有着重研究他们的遍历过程呢？
二叉树的遍历又有什么特殊之处？
在计算机程序中，遍历本身是一个线性操作。所以遍历同样具有线性结
构的数组或链表，是一件轻而易举的事情。
---
## Page 131
2
3
8
遍历序列：9、2、3、8、4、7
遍历序列：6、3、4、5、1
反观二叉树，是典型的非线性数据结构，遍历时需要把非线性关联的节
点转化成一个线性的序列，以不同的方式来遍历，遍历出的序列顺序也
不同。
2
3
G
那么，二叉树都有哪些遍历方式呢？
从节点之间位置关系的角度来看，二叉树的遍历分为4种。
1.前序遍历。
2.中序遍历。
3.后序遍历。
4.层序遍历。
从更宏观的角度来看，二叉树的遍历归结为两大类。
---
## Page 132
1.深度优先遍历（前序遍历、中序遍历、后序遍历）。
2.广度优先遍历（层序遍历）。
下面就来具体看一看这些不同的遍历方式。
3.2.2深度优先遍历
深度优先和广度优先这两个概念不止局限于二叉树，它们更是一种抽象
的算法思想，决定了访问某些复杂数据结构的顺序。在访问树、图，或
其他一些复杂数据结构时，这两个概念常常被使用到。
所谓深度优先，顾名思义，就是偏向于纵深，“一头扎到底"的访问方
式。可能这种说法有些抽象，下面就通过二叉树的前序遍历、中序遍
历、后序遍历，来看一看深度优先是怎么回事吧。
1.前序遍历
二叉树的前序遍历，输出顺序是根节点、左子树、右子树。
5
2
5
6
上图就是一个二叉树的前序遍历，每个节点左侧的序号代表该节点的输
出顺序，详细步骤如下。
1.首先输出的是根节点1。
---
## Page 133
6
2.由于根节点1存在左孩子，输出左孩子节点2。
2
3
G
3.由于节点2也存在左孩子，输出左孩子节点4。
9
---
## Page 134
4.
，节点4既没有左孩子，也没有右孩子，那么回到节点2，输出节点2的
右孩子节点5。
5
5.节点5既没有左孩子，也没有右孩子，那么回到节点1，输出节点1的
右孩子节点3。
2
3
力
6.节点3没有左孩子，但是有右孩子，因此输出节点3的右孩子节点6
---
## Page 135
2
3
4
5
6
到此为止，所有的节点都遍历输出完毕。
2.中序遍历
二叉树的中序遍历，输出顺序是左子树、根节点、右子树。
5
3
6
5
上图就是一个二叉树的中序遍历，每个节点左侧的序号代表该节点的输
出顺序，详细步骤如下。
1.首先访问根节点的左孩子，如果这个左孩子还拥有左孩子，则继续深
入访问下去，一直找到不再有左孩子的节点，并输出该节点。显然，第
一个没有左孩子的节点是节点4。
---
## Page 136
2.依照中序遍历的次序，接下来输出节点4的父节点2。
2
3
G
3.再输出节点2的右孩子节点5。
---
## Page 137
5
6
4.以节点2为根的左子树已经输出完毕，这时再输出整个二叉树的根节
点1。
3
C
5.由于节点3没有左孩子，所以直接输出根节点1的右孩子节点3。
---
## Page 138
2
3
5
6
6.最后输出节点3的右孩子节点6。
3
2
5
G
到此为止，所有的节点都遍历输出完毕。
3.后序遍历
二叉树的后序遍历，输出顺序是左子树、右子树、根节点。
---
## Page 139
3
5
2
3
6
上图就是一个二叉树的后序遍历，每个节点左侧的序号代表该节点的输
出顺序。
由于二叉树的后序遍历和前序、中序遍历的思想大致相同，相信聪明的
读者已经可以推测出分解步骤，这里就不再列举细节了。
那么，二叉树的前序、中序、后
序遍历的代码怎么写呢？
二叉树的这3种遍历方式，用递归的
思路可以非常简单地实现出来，让我们看一看代码。
---
## Page 140
1. /**
2.*构建二叉树
3.* @param inputList
输入序列
4.*/
5. public static TreeNode createBinaryTree(LinkedList
inputList){
6.
TreeNode node = null;
7.
if(inputList==null 1l inputList.isEmpty()){
8.
return null;
9.
10.
Integer data = inputList.removeFirst();
11.
if(data != null){
12.
node = new TreeNode(data);
13.
node.leftchild = createBinaryTree(inputList);
14.
node.rightchild = createBinaryTree(inputList);
15.
16.
return node;
17.}
18.
19./**
20.
二叉树前序遍历
21.
@param node
二叉树节点
22.
*/
23. public static void pre0rderTraveral(TreeNode node){
---
## Page 141
24.
if(node == null){
25.
return;
26.
27.
System.out.println(node.data);
28.
pre0rderTraveral(node.leftchild);
29.
pre0rderTraveral(node.rightchild);
30.}
31.
32./**
33.
二叉树中序遍历
34.
@param node
二叉树节点
35.
*/
36.
public static void inOrderTraveral(TreeNode node){
37.
if(node == null){
38.
return;
39.
40.
in0rderTraveral(node.leftchild);
41.
System.out.println(node.data);
42.
inorderTraveral(node.rightchild);
43.}
44.
45.
46. /**
47.
*二叉树后序遍历
---
## Page 142
48.
*@param node
二叉树节点
49.
*/
50.
public static void postorderTraveral(TreeNode node){
51.
if(node == null){
52.
return;
53.
54.
postorderTraveral(node.leftchild);
55.
postorderTraveral(node.rightChild);
56.
System.out.println(node.data) ;
57.}
58.
59.
60.
/ **
61.
二叉树节点
62.
*/
63.
private static class TreeNode {
64.
int data;
65.
TreeNode leftChild;
66.
TreeNode rightChild;
67.
68.
TreeNode(int data) {
69.
this.data = data;
70.
{
71.}
---
## Page 143
72.
73. public static void main(String[] args) {
LinkedList inputList = new LinkedList
(Arrays.
asList(new Integer[]{3, 2,9,null, null, 10, nul1,
nu11, 8, nu11, 4})) ;
75.
TreeNode treeNode = createBinaryTree(inputList);
76.
System.out.println（”前序遍历：")；
77.
preorderTraveral(treeNode);
78.
System.out.println("中序遍历：");
79.
in0rderTraveral(treeNode);
80.
System.out.println（"后序遍历：");
81.
postorderTraveral(treeNode);
82.}
二叉树用递归方式来实现前序、中序、后序遍历，是最为自然的方式
因此代码也非常简单。
这3种遍历方式的区别，仅仅是输出的执行位置不同：前序遍历的输出
在前，中序遍历的输出在中间，后序遍历的输出在最后。
代码中值得注意的一点是二义树的构建。二义树的构建方法有很多，这
里把一个线性的链表转化成非线性的二叉树，链表节点的顺序恰恰是二
叉树前序遍历的顺序。链表中的空值，代表二叉树节点的左孩子或右孩
子为空的情况。
在代码的main函数中，通过{3,2,9,null,null,10,null,null,8,null,4}这样一个
线性序列，构建成的二义树如下。
---
## Page 144
3
8
10
null
null
null
null
null
除使用递归以外，二叉树的深度
优先遍历还能通过其他方式实现吗？
当然也可以用非递归的方式来实现，
不过要稍微复杂一些。
绝大多数可以用递归解决的问题，其实都可以用另一种数据结构来解
决，这种数据结构就是栈。因为递归和栈都有回溯的特性。
如何借助栈来实现二叉树的非递归遍历呢？下面以二叉树的前序遍历为
---
## Page 145
例，看一看具体过程。
1.首先遍历二叉树的根节点1，放入栈中。
5
2.遍历根节点1的左孩子节点2，放入栈中。
12
3.遍历节点2的左孩子节点4，放入栈中。
---
## Page 146
12
4
4.节点4既没有左孩子，也没有右孩子，我们需要回溯到上一个节点2。
可是现在并不是做递归操作，怎么回溯呢？
别担心，栈已经存储了刚才遍历的路径。让旧的栈顶元素4出栈，就可
以重新访问节点2，得到节点2的右孩子节点5。
此时节点2已经没有利用价值（已经访问过左孩子和右孩子），节点2出
栈，节点5入栈。
5
15
5.节点5既没有左孩子，也没有右孩子，我们需要再次回溯，一直回溯
到节点1。所以让节点5出栈。
根节点1的右孩子是节点3，节点1出栈，节点3入栈。
---
## Page 147
S
6.节点3的右孩子是节点6，节点3出栈，节点6入栈
5
6
7.节点6既没有左孩子，也没有右孩子，所以节点6出栈。此时栈为空，
遍历结束。
2