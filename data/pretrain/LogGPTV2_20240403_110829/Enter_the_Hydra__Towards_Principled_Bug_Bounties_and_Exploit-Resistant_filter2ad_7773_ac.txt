for bounties. Note that a bug in all heads (i.e., a full
exploit) cannot be detected and rewarded by the meta-
contract f ∗. We thus let λH be the rate at which honest
parties ﬁnd bugs that affect 1 ≤ k  1 ⇐⇒ $bounty >
1
· $balance .
α · gap + 1
payoutH
payoutM
We may assume that λM = λH (i.e., A’s work rate is
equal to the combined work rate of honest parties). Then,
for independent program failures (see Equation (3)) the
bounty decays exponentially in the number of heads N.
Thus, given estimates of α and gap, we get a prin-
cipled bounty pricing that incentivizes bug disclosure.
For example, in the experiment of Eckhardt et al. [21],
a three-headed Hydra could sustain a bounty 3 to 4 or-
ders of magnitude below an exploit’s value.
This analysis also provides insight into why boun-
ties are paid when bugs are not necessarily actively ex-
ploitable against the target system.
If $bounty is too
small, all economically rational players will attempt to
privately weaponize any partial exploits they develop.
Traditional bounties operate off similar intuition, with
tiers of exploit values to boost participation (e.g. [24]).
5 The Bug-Withholding Problem
Our analysis in Section 4 assumed that a bounty is paid
immediately when a bug is claimed. Hereafter, we reﬁne
our analysis by modeling bounty smart-contract execu-
tion with respect to a powerful adversary, that can cheat
users by exploiting blockchain network protocols. We
highlight the bug-withholding attack and propose and an-
alyze a solution called Submarine Commitments.
Front-running. The issue is that transactions may not
be ordered in blocks by network submission time. When
a user sends a bounty-claim transaction τ to the network,
an adversary may front-run the user, and insert its own
bounty-claim τ(cid:48) earlier in the chain [51]. It does this by
ensuring faster network propagation of τ(cid:48) or by causing
a miner to order τ(cid:48) before τ, e.g., by paying a higher fee
(more gas in Ethereum) or corrupting the miner.
Front-running opens up a bug bounty system to bug-
withholding attacks. Suppose an adversary has found a
bug in one or more heads in a Hydra contract, and aims
to ﬁnd a stronger exploit against all heads.
If another
party in the meantime claims the bounty, the adversary’s
progress is wiped out: It loses all potential payoff on its
already discovered bugs. By front-running, though, the
adversary can ensure it claims the bounty ﬁrst, thus nul-
lifying any economic incentives for early disclosure.
We propose a formal model for blockchain security,
expressed as an ideal functionality Fwithhold. It captures
front-running, but is far stronger than previous models
(e.g., Hawk [35]). We present a basic bug-bounty con-
tract BountyContract in Fwithhold. Reﬁning our analy-
sis of Section 4, we show how bug withholding breaks
incentives for bug disclosure in BountyContract. We
show that commit-reveal schemes are an insufﬁcient de-
fense, and therefore introduce Submarine Commitments.
We prove, in an Fwithhold-hybrid world, that using Sub-
marine Commitments for BountyContract drastically re-
duces the payoff of a bug-withholding adversary.
5.1 Adversarial Model
We model an adversary A that can front-run a victim. In
our model, A can mount strong history-revision attacks,
overwriting blocks at the head of the blockchain, and can
delay any transaction by a bounded number of blocks.
This reﬂects an adversary’s ability to monitor trans-
actions, mount network-level attacks, control client ac-
counts, and even corrupt or bribe miners to alter legit-
imate blocks. Previous models, e.g., [35], considered
weaker attacks in which A can arbitrarily reorder trans-
actions in a pending block. They are equivalent to weak
history-revision attacks with only a single block.
In our model, A itself constructs the blockchain. A
controls all but one honest player, denoted P0. (P0 models
the collective behavior of all honest players.) A can re-
order P0’s transactions by: (1) Rewinding the blockchain
from its head, i.e., mounting a history-revision attack, for
a sequence of up to ρ blocks ; and (2) Delaying the post-
ing on the blockchain of a transaction by P0 by up to δ
blocks. We call such an adversary A a (δ ,ρ)-adversary.
Our adversarial model takes the form of an ideal func-
tionality Fwithhold characterizing an (δ ,ρ)-adversary A.
We give details on Fwithhold in the extended version of
this paper [13].
Notation. Let B = {B1, . . . ,BB.Height} be a blockchain,
i.e., an ordered sequence of blocks. Here, B.Height is the
USENIX Association
27th USENIX Security Symposium    1341
BountyContract with B, P = {P0,P1, . . . ,Pm}, ∆, $deposit, $bounty
Init: CommitList, RevealList ← /0
On receive τ = (“commit”, comm,$val) from Pi:
if $val ≥ $deposit then CommitList.append(comm,B.Height;Pi)
On receive τ = (“reveal”, (comm, height), (witness, bug)) from Pi:
// Pi commits to bug
if (comm, height;Pi) ∈ CommitList then
// Pi reveals commitment
assert (B.Height− height) ≤ ∆
assert Decommit(comm; (witness, bug)) ∧ IsValidBug(bug)
RevealList.append(height;Pi)
On receive τ = (“claim”, height) from Pi:
// Pi tries to claim bounty
assert (height;Pi) ∈ RevealList
assert B.Height− height > ∆
assert (cid:64)(height(cid:48);Pi(cid:48) ) ∈ RevealList s.t. height(cid:48)  δ + ρ, $deposit and $bounty.
It takes
as input a commitment to a bug in some block Bi (via
transaction “commit”), which must be revealed before
block Bi+∆ (via transaction “reveal”). After a delay ∆, the
player with the ﬁrst validly revealed commitment may
claim the bounty (via transaction “claim”). A “commit”
incurs a cost of $deposit, to prevent A from committing
in every block and revealing only if P0 also reveals.
We assume a function isvalidbug that determines
whether a submitted bug is valid. In the Fwithhold-hybrid
model, BountyContract is fed a height-n blockchain B,
which is replayed after being generated by Fwithhold, i.e.,
transactions are executed as ordered by Fwithhold in B.
Bug withholding in BountyContract. The contract in
Figure 3 uses a cryptographic commit-reveal scheme,
a simple folklore solution to certain front-running at-
tacks [31]. This works if A cannot post a valid com-
mitment itself until it sees a victim’s reveal. For in-
stance, BountyContract prevents A from trying to learn
and steal the committed bug from an honest player P0.
Unfortunately, this approach does not protect against
front-running in the Fwithhold-hybrid model if A is with-
holding a bug it already knows. Here, A waits until P0
sends a “commit”. A then knows that P0 is trying to
claim a bounty, and can front-run P0’s commitment by
posting her own “commit” ahead in the blockchain.
This problem arises in many other scenarios, e.g., to-
ken sales or auctions, where a user must send funds to
place her bid, thus exposing the bid on the blockchain.
Impact of bug withholding.
In our analysis of Hydra
bug bounties in Section 4.2, we assumed that A risks for-
feiting a payout of $bounty if she conceals a bug. How-
ever, front-running has the potential of removing incen-
tives for early disclosure, as A can ensure a payout of
$bounty by front-running the honest bounty hunter.
If A conceals a bug, she ﬁnds a full exploit before
the bounty is claimed with probability q := Pr[TM  $balance, as in a
standard bounty with no exploit gap. We now show a so-
lution that thwarts bug-withholding attacks in Ethereum,
thus re-instantiating positive incentives to disclose bugs.
5.3 Submarine Commitments
We present a bug-withholding defense called a Subma-
rine Commitment. This is a powerful, general solution
to the problem of front-running that may be of indepen-
dent interest, as it can be applied to smart-contract-based
auctions, exchange transactions, and other settings.
As the name suggests, a Submarine Commitment is
a transaction whose existence is temporarily concealed,
but can later be surfaced to a target smart contract. It may
be viewed as a stronger form of a commit-reveal scheme.
Achieving Submarine Commitments is challenging in
systems like Ethereum, however, because message con-
tents and currency in all transactions are in the clear.
Brieﬂy, in Ethereum, to commit in a Submarine Com-
mitment scheme, P posts a transaction τ that sends (non-
refundable) currency $val ≥ $deposit to an address (cid:100)addr.
(cid:100)addr = H(addr(Contract),H(addr(P), key),data) ,
This address is itself a commitment of the form
for H a commitment scheme (e.g., hash function in the
ROM), key a randomly selected witness (e.g., 256-bit
string), and data other ancillary information. P’s address
is included in the commitment to prevent replay by A.
To reveal, P sends key to Contract. A Submarine Com-
mitment scheme includes an operation DepositCollec-
tion that permits Contract to recover $val using addr(P)
and key. This scheme has these key properties:
1. Commit: As key is randomly selected, (cid:100)addr is indis-
tinguishable from random in the view of A. Thus
1342    27th USENIX Security Symposium
USENIX Association
τ has no ascertainable connection to Contract, and
looks to A like an ordinary send to a fresh address.
2. Reveal: After learning key, Contract can compute
(cid:100)addr as above and verify that $val was sent correctly.
Via DepositCollection, Contract recovers $val thus
avoiding unnecessary burning of funds.
Thus if A does not know P’s address (honest bounty
hunters could use a mixer), and $val is sampled from
an appropriate distribution of values $val ≥ $deposit, A
cannot distinguish transaction τ from other sends to fresh
addresses. As we show in Appendix B.2, such sends
are common in Ethereum and, for a reasonable commit-