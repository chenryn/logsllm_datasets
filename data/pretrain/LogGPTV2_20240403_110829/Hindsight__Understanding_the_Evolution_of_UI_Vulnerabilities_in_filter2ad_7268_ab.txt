13
14
15–16
17–18
19
20
21–22 When rendering an HTTPS page, is the address bar displayed the same in the
[30, 38]
[16]
23
24
25
26
27
presence of mixed content (image and JavaScript) as in its absence?
Is a webpage with self-signed certificate rendered without warnings?
Can an iframe expand its size past the one defined by its parent frame?
Is a mixed-content image resource loaded?
Is a mixed-content JavaScript script executed?
Is JavaScript code included in a self-signed website executed before the warn-
ing is accepted?
Potential Attacks
Clickjacking, CSRF
Phishing, malware/scam delivery
Phishing, malware/scam delivery
Phishing, malware/scam delivery
Phishing, malware/scam delivery
Phishing, malware/scam delivery
Phishing, malware/scam delivery
Phishing, malware/scam delivery
Phishing, malware/scam delivery
Phishing, malware/scam delivery
[4, 5, 14, 37] MITM attack, Phishing
[9]
MITM attack
[4, 5, 14, 37] MITM attack, Phishing
[3, 6]
[9]
[9]
Novel
Phishing
MITM attack
MITM attack
Phishing, MITM attack
domain-verified vs. extended-verification certificates [4, 5, 14, 38].
In our work, we develop ABBs for identifying the confusable place-
ment of a favicon next to the place where the SSL-lock appears
(ABB #20), lack of warnings for mixed content (ABBs #21–22), and
lack of warnings for self-signed certificates (ABB #23).
Next to security indicators, we also develop four additional ABBs
that quantify a mobile browser’s risk to dangerous content. Specifi-
cally, we gauge whether an iframe can expand its dimensions past
what is specified by the parent frame (ABB #24, originally described
by Amrutkar et al. [3]), whether a browser renders mixed-content
images and JavaScript (ABBs #25–26), and whether JavaScript code
located on a self-signed page would execute before a user accepts
the certificate warning (ABB #27).
Automatic Vulnerabilities. During pilot experiments with Hind-
sight and our 27 ABBs, we realized that not all browsers behave as
one would expect. That is, there exist browsers that constantly hide
their URL bars, or browsers that always give preference to showing
the title of a page, instead of its URL. We take advantage of this
behavior by adding an extra test that quantifies whether a browser
shows, by default, its URL and/or title bars, and whether both are
present or the browser gives preference to one over the other. Using
the results of these tests, we may be able to immediately consider
the browser vulnerable to some of ABBs in Table 1. For example,
if a browser constantly hides its URL bar, building blocks that de-
termine which part of the URL a browser shows (ABBs #7–9) are
automatically labeled as vulnerable, because an attacker, if he so
chooses, can draw a fake address bar showing an arbitrary URL.
Similarly, for such a browser, tests that determine whether an ad-
dress bar is hidden when a user turns her phone to Landscape mode
(ABB #14), or scrolls (ABBs #15–16), or types into a text box (ABBs
#17–19) are also marked as vulnerable.
3 DATA COLLECTION
The app markets of modern smartphones offer a significantly larger
set of browser choices, compared to traditional desktop browsers.
The Google Play store houses hundreds of different mobile browsers,
each one advertising its own differentiating features including voice-
control [18], reduction of data usage [21, 22], increased perfor-
mance [19], and ad-block/anti-tracker integration [17, 20].
At the same time, while the Google Play store is the authoritative
market for up-to-date apps, it does not provide older versions of
apps which are necessary for studying the evolution of vulnerabili-
ties across time and mobile browsers. Past work in mobile browser
security did not have such requirements since researchers used the
most recent browser versions at the time of their experiments. In
the following sections, we describe our methodology for collect-
ing current and past versions of mobile browsers (together with
important metadata), allowing us to compile a dataset compris-
ing thousands of mobile browser APKs spanning more than a 120
different browser families.
3.1 Mobile Browsers Dataset
To obtain a comprehensive set of mobile browsers we performed
the following data collection and processing steps:
Table 2: Browser ranks
Rank
1
2
3
.
.
.
13
# Installations
1,000–5,000 MM
100–500 MM
50–100 MM
.
.
.
500–1,000
# browsers
1
3
4
.
.
.
2
Example Browser
com.android.chrome
org.mozilla.firefox
mobi.mgeek.TunnyBrowser
.
.
.
com.shark.sharkbrowser
Table 3: Filtering and processing the browser APKs
Dataset
Raw dataset
Browser duplicates
Non-modern browsers
Installation failure
Crash on launch
Failed splash bypass
Unrecognizable address bar
Final dataset
# of APKs
4,612
1,416
152
76
135
498
11
2,324
Table 4: Number of APKs and browser families per year
Year
Browser APKs
Browser families
2011
5
4
2012
89
21
2013
367
41
2014
505
54
2015
755
94
2016
603
77
Collecting browser families. Using Selenium [34] we automati-
cally searched for the keyword “browser” in the Google Play Store
and recorded the results. Through manual analysis, we filtered out
non-web browsers (e.g., file browsers). Table 2 shows a small sam-
ple of browser families that we collected, ranging from browsers
with billions of installations (e.g. Google Chrome) to ones with less
than 1K installations (e.g. Shark Browser). The browser families are
divided into 13 ranks according to their number of installations.
Crawling browser versions. To obtain older browser versions,
we resorted to third-party websites and alternative app markets.
Specifically, we build website-specific crawlers and collected as
many APKs as possible from the following six online sources: An-
droidapps, Apkhere, Apkmirror, Apkpure, Uptodown, and Aptoide.
In some cases, such as Aptoide, collecting older versions meant
installing third-party market apps and then reverse-engineering the
way with which they downloaded older APKs from their servers.
Through this process we collected a total of 4,612 individual APKs.
Our data collection process for both the Google Play Store and the
alternative sources was conducted in August 2016.
Filtering. To arrive at a representative set of mobile browsers, we
performed rounds of filtering on the raw dataset of 4,612 APKs. As
shown in Table 3, we first removed duplicates of the same browsers
collected from different data sources. We identify a unique APK as a
tuple of (Package Name, Version Name, MD5sum), where the Package
Name defines a browser family and the Version Name indicates a
particular version of that browser. Each APK file was additionally
labeled with its MD5 hash to remove even more duplicates that
represent builds of the same browser but with different Android
targets. Specifically, we used the MD5 hash of the .SF file under
META-INF/ subdirectory that already contains the hashes of various
inner resources. Through this duplicate filtering, we removed 1,416
repeated APK files.
Next, we attempted to install a browser and subsequently visit a
simple HTML page showing images and using JavaScript. We argue
that rendering images and executing JavaScript are the bare mini-
mum requirements for a modern browser that aspires to be used to
browse today’s web. This process allowed us to eliminate browser
apps that would not install, browsers that would crash while launch-
ing, and niche, text-only browsers (e.g. com.weejim.app.lynx)
which are not going to be used by everyday web users.
In our final step, we had to filter the APKs which our browser-
agnostic vulnerability testing framework, Hindsight, was unable to
evaluate. For 498 APKs, Hindsight was unable to bypass a mobile
browser’s splash screen. One must remember that browser devel-
opers are free to show an arbitrary number of menus and dialogues
(e.g., the features of the browser, terms and conditions, choice of
language, etc.) before allowing users to utilize their browser. De-
spite our Splash Bypass Algorithm (Section 4.2.3), Hindsight is not
always able to identify the series of actions necessary for bypassing
the splash screen. Next to splash screens, Hindsight also needs to
automatically identify the placement and contents of a browser’s
address bar, a complicated process which, despite our techniques
described in Section 4.2.1, can occasionally fail (11 APKs). Overall,
we could reliably evaluate 2,324 APK files belonging to 128 browser
families, which represent modern and working mobile browsers. On
average, our dataset includes 18 versions for each browser family.
Figure 2 shows how the number of APKs grows with the fraction
of browser families. All statistics presented in the rest of this paper
are based on this set of browsers.
3.2 Metadata Extraction
To be able to evaluate each mobile browser against our attack
building blocks (ABBs) and to study the evolution of vulnerabilities
through time, we need to extract information about the platform
on which any given APK can run, its release date, and any intent
metadata necessary for executing it.
App usage metadata. To identify the appropriate device on which
an APK can be installed and run, we extract APK properties, such
as, native-code, sdkVersion and targetSdkVersion. The native-code
indicates which architecture and instruction set an app depends
on, whereas the sdkVersion and targetSdkVersion work in tandem to
set compatible Android API levels. Our goal is to run an APK on a
device having an Android API level closest to the targetSdkVersion
and greater than sdkVersion. Section 4.2.2 describes our methodol-
ogy in greater detail. We also extract the activities necessasry for
the ADB-based launching of the browser.
App release date metadata. For our longitudinal study of UI vul-
nerabilities, we need to be able to provide a release timestamp
for each APK in our dataset with sufficient accuracy. Through ex-
perimentation, we discovered that a relatively accurate way of
obtaining this information is by extracting the modification time of
Figure 2: ECDF for the number of browser APKs vs. fraction of
browser families
.RSA or .DSA file under META-INF/ subdirectory. These timestamps
are good proxies for the time of signing an Android app and thus
its release. To avoid errors, we limit ourselves to extracting the
year of each release and cross-validate our findings, when possible,
with the dates provided on the AppBrain website for some of the
collected APKs. We show the distribution of the collected APKs
from 2011 to 2016 in Table 4.
Table 5 shows the ranges of versions and distribution of APKs for
six popular browser families. For instance, we evaluated a total of 41
different versions of Google Chrome collected by August 2016. The
oldest one is in year 2013 with version 29.0.1547.72 and the latest is
in August of year 2016 with version 51.0.2704.81. This version was
the newest one at the time of our data collection. On average, we
have at least 10 different versions per year for Google Chrome.
4 TESTING FRAMEWORK AND
METHODOLOGY
Manually testing tens of ABBs on thousands of browsers is a non-
starter. For each browser, one has to install it, bypass the splash
screen that many browsers display upon the first use, and then test
the ABBs on that browser. Each test involves loading a webpage,
mimicking a user’s interaction with that page, and then analyzing
the final rendered output to identify vulnerabilities. Moreover, this
process of “input then analyse” may often have to be repeated
multiple times in a single test. It would take human analysts many
months to complete a single round of tests, and even then they
are bound to make numerous mistakes in the course of testing.
Therefore, one needs an automated framework to run the tests.
4.1 Hindsight Framework Architecture
We have designed and implemented an automated vulnerability
testing framework called Hindsight. Figure 3 shows the main com-
ponents and processing steps of the framework. In Hindsight, each
input APK goes through four general processing steps: (1) SDK
assignment, (2) installation and splash-screen bypassing, (3) ABB
testing, and (4) results evaluation.
In step (1), Hindsight decides on a suitable version of Android
capable of running the browser. In step (2), it installs the APK on
an Android device running that version. It then checks that the
installed browser is ready for testing by pointing it to a simple
webpage. Some APKs crash at this stage and are excluded from