带一元运算符的表达式遵循从右到左的结合性。
一元表达式:
后级表达式
++一元表达式
••一元表达式
一元运算符 强制类型转换表达式
sizeoff 一元表达式
sizeof(类型名)
一元运算符:one of
& * + • ~ !
1 前缀自增运算符与前缀自减运算符 在一元表达式的前面添加运算符++或••后得到的表达式是一个一元表达式。操作数将被
加 1(++)或减 1(••)，表达式的值是经过加 1、减 1 以后的值。操作数必须是一个左值。
有关操作数的限制和运算细节的详细信息，参见加法类运算符(参见  A.7.7  节)和赋值类运算
符(参见 A.7.17 节)。其结果不是左值。
2 地址运算符 一元运算符&用于取操作数的地址。该操作数必须是一个左值(不指向位字段、不指向声
明为 register 类型的对象)，或者为函数类型。结果值是一个指针，指向左值指向的对象或
函数。如果操作数的类型为 T，则结果的类型为指向 T 类型的指针。
3 间接寻址运算符 一元运算符*表示间接寻址，它返回其操作数指向的对象或函数。如果它的操作数是一个
指针且指向的对象是算术、结构、联合或指针类型，则它是一个左值。如果表达式的类型为
"指向 T 类型的指针"，则结果类型为 T。
4 一元加运算符 一元运算符+的操作数必须是算术类型，其结果是操作数的值。如果操作数是整型，则将
进行整型提升，结果类型是经过提升后的操作数的类型。
说明:一元运算符+是 ANSI 标准新增加的，增加该运算符是为了与一元运算符•对应。 5 一元减运算符 一元运算符•的操作数必须是算术类型，结果为操作数的负值。如果操作数是整型，则将
进行整型提升。带符号数的负值的计算方法为:将提升后得到的类型能够表示的最大值减去
提升后的操作数的值，然后加 1;但 0 的负值仍为 0。结果类型为提升后的操作数的类型。
6 二进制反码运算符 一元运算符~的操作数必须是整型，结果为操作数的二进制反码。在运算过程中需要对操
作数进行整型提升。如果操作数为无符号类型，则结果为提升后的类型能够表示的最大值减
去操作数的值而得到的结果值。如果操作数为带符号类型，则结果的计算方式为:将提升后 的操作数转换为相应的无符号类型，使用运算符~计算反码，再将结果转换为带符号类型。结 果的类型为提升后的操作数的类型。
7 逻辑非运算符
运算符!的操作数必须是算术类型或者指针。如果操作数等于 0，则结果为 1，否则结果 为 0。结果类型为 int。
8 sizeof 运算符
sizeof 运算符计算存储与其操作数同类型的对象所需的字节数。操作数可以为一个未求 值的表达式，也可以为一个用括号括起来的类型名。将 sizeof 应用于 char 类型时，其结 果值为 1;将它应用于数组时，其值为数组中字节的总数。应用于结构或联合时，结果为对象 的字节数，包括对象中包含的数组所需要的任何填充空间:有 n 个元素的数组的长度是一个 数组元素长度的 n 倍。此运算符不能用于函数类型和不完整类型的操作数，也不能用于位字 段。结果是一个无符号整型常量，具体的类型由实现定义。在标准头文件(参 见附录 B)中，这一类型被定义为 size_t 类型。
A.7.5              强制类型转换
以括号括起来的类型名开头的一元表达式将导致表达式的值被转换为指定的类型。
强制类型转换表达式: 一元表达式 (类型名)强制类型转换表达式
这种结构称为强制类型转换。类型名将在 A.8.8 节描述。转换的结果已在 A.6 节讨论过。包含 强制类型转换的表达式不是左值。
A.7.6              乘法类运算符
乘法类运算符&、/和%遵循从左到右的结合性。
来法类表达式: 强制类型转换表达式
来法类表达式*强制类型转换表达式 来法类表达式/强制类型转换表达式 来法类表达式%强制类型转换表达式
运算符*和/的操作数必须为算术类型，运算符&的操作数必须为整型。这些操作数需要进 行普通的算术类型转换，结果类型由执行的转换决定。
二元运算符*表示乘法。 二元运算符/用于计算第一个操作数同第二个操作数相除所得的商，而运算符%用于计算
两个操作数相除后所得的余数。如果第二个操作数为 0，则结果没有定义。并且，(a/b)*b+a%b
等于 a 永远成立。如果两个操作数均为非负，则余数为非负值且小于除数，否则，仅保证余
数的绝对值小于除数的绝对值。
A.7.7              加法类运算符
加法类运算符+和•遵循从左到右的结合性。如果操作数中有算术类型的操作数，则需要 进行普通的算术类型转换。每个运算符可能为多种类型。
加法类表达式: 来法类表达式
加法类表达式+来法类表达式 加法类表达式•来法类表达式
运算符+用于计算两个操作数的和。指向数组中某个对象的指针可以和一个任何整型的值 相加，后者将通过乘以所指对象的长度被转换为地址偏移量。相加得到的和是一个指针，它 与初始指针具有相同的类型，并指向同一数组中的另一个对象，此对象与初始对象之间具有 一定的偏移量。因此，如果 P 是一个指向数组中某个对象的指针，则表达式 P+1 是指向数组 中下一个对象的指针。如果相加所得的和对应的指针不在数组的范围内，且不是数组末尾元 素后的第一个位置，则结果没有定义。
说明:允许指针指向数纽末尾元素的下一个元素是 ANSI 中新增加的特征，它使得我们可 以按照通常的习惯循环地访问数纽元素。
运算符•用于计算两个操作数的差值。可以从某个指针上减去一个任何整型的值，减法运 算的转换规则和条件与加法的相同。
如果指向同一类型的两个指针相减，则结果是一个带符号整型数，表示它们指向的对象 之间的偏移量。相邻对象间的偏移量为 1。结果的类型同具体的实现有关，但在标准头文件
中定义为 ptrdiff_t。只有当指针指向的对象属于同一数组时，差值才有意义。 但是，如果 P 指向数组的最后一个元素，则(P+1)•P 的值为 1。
A.7.8              移位运算符
移位运算符>遵循从左到右的结合性。每个运算符的各操作数都必须为整型，并且 遵循整型提升原则。结果的类型是提升后的左操作数的类型。如果右操作数为负值，或者大 于或等于左操作数类型的位数，则结果没有定义。
移位表达式:
加法类表达式 移位表达式>加法类表达式
E1>E2 的值为 E1 向右移 E2 位得到的结果。如果 E1 为无符号 数或为非负值，则右移等同于 E1 除以 2
E
2
 。其它情况下的执行结果由具体实现定义。
A.7.9              关系运算符
关系运算符遵循从左到右的结合性，但这个规则没有什么作用。a移位表达式 关系表达式=移位表达式
当关系表达式的结果为假时，运算符(大于)、=(大于等于) 的结果值都为 0;当关系表达式的结果为真时，它们的结果值都为 1。结果的类型为 int 类型。 如果操作数为算术类型，则要进行普通的算术类型转换。可以对指向同一类型的对象的指针 进行比较(忽略任何限定符)，其结果依赖于所指对象在地址空间中的相对位置。指针比较只 对相同对象才有意义:如果两个指针指向同一个简单对象，则相等;如果指针指向同一个结 构的不同成员，则指向结构中后声明的成员的指针较大;如果指针指向同一个联合的不同成 员，则相等;如果指针指向一个数组的不同成员，则它们之间的比较等价于对应下标之间的 比较。如果指针 P 指向数组的最后一个成员，尽管 P+1 已指向数组的界外，但 P+1 仍比 P 大。 其它情况下指针的比较没有定义。
说明:这些规则允许指向同一个结构或联合的不同成员的指针之间进行比较，与第  1  版 比较起来放宽了一些限制。这些规则还使得与超出数纽末尾的第一个指针进行比较合法化。
A.7.10          相等类运算符
相等类表达式: 关系表达式
相等类表达式==关系表达式 相等类表达式!=关系表达式
运算符==(等于)和!=(不等于)与关系运算符相似，但它们的优先级更低。(只要     a>= &= ^= !=
所有这些运算符都要求左操作数为左值，且该左值是可以修改的:它不可以是数组、不完整 类型或函数。同时其类型不能包括 const 限定符;如果它是结构或联合，则它的任意一个成 员或递归子成员不能包括 const 限定符。赋值表达式的类型是其左操作数的类型，值是赋值 操作执行后存储在左操作数中的值。
在使用运算符=的简单赋值中，表达式的值将替换左值所指向的对象的值。下面几个条件 中必须有一个条件成立:两个操作数均为算术类型，在此情况下右操作数的类型通过赋值转 换为左操作数的类型;两个操作数为同一类型的结构或联合;一个操作数是指针，另一个操 作数是指向 void 的指针;左操作数是指针，右操作数是值为 0 的常量表达式;两个操作数都 是指向同一类型的函数或对象的指针，但右操作数可以没有 const 或 volatile 限定符。
形式为 E1 op= E2 的表达式等价于 E1 = E1 op (E2)，惟一的区别是前者对 E1 仅求 值一次。
A.7.18          逗号运算符
表达式:
赋值表达式
表达式, 赋值表达式
由逗号分隔的两个表达式的求值次序为从左到右，并且左表达式的值被丢弃。右操作数的类 型和值就是结果的类型和值。在开始计算右操作数以前，将完成左操作数涉及到的副作用的 计算。在逗号有特别含义的上下文中，如在函数参数表(参见 A.7.3 节)和初值列表(A.8.7 节)中，需要使用赋值表达式作为语法单元，这样，逗号运算符仅出现在圆括号中。例如， 下列函数调用:
f(a, (t=3, t+2), c)
包含 3 个参数，其中第二个参数的值为 5。
A.7.19          常量表达式
从语法上看，常量表达式是限定于运算符的某一个子集的表达式:
常量表达式:
条件表达式
某些上下文要求表达式的值为常量，例如，switch 语句中 case 后面的数值、数组边界和位 字段的长度、枚举常量的值、初值以及某些预处理器表达式。
除了作为 sizeof 的操作数之外，常量表达式中可以不包含赋值、自增或自减运算符、 函数调用或逗号运算符。如果要求常量表达式为整型，则它的操作数必须由整型、枚举、字 符和浮点常量组成;强制类型转换必须指定为整型，任何浮点常量都将被强制转换为整型。 此规则对数组、间接访问、取地址运算符和结构成员操作不适用。(但是，sizeof 可以带任 何类型的操作数。)
初值中的常量表达式允许更大的范围:操作数可以是任意类型的常量，一元运算符&可以 作用于外部、静态对象以及以常量表达式为下标的外部或静态数组。对于无下标的数组或函 数的情况，一元运算符&将被隐式地应用。初值计算的结果值必须为下列二者之一:一个常量; 前面声明的外部或静态对象的地址加上或减去一个常量。
允许出现在#if 后面的整型常量表达式的范围较小，它不允许 sizeof 表达式、枚举常 量和强制类型转换。详细信息参见 A.12.5 节。
A.8 声明
声明(declaration)用于说明每个标识符的含义，而并不需要为每个标识符预留存储空间。 预留存储空间的声明称为定义(definition)。声明的形式如下:
声明
声明说明符 初始化声明符表 opt;