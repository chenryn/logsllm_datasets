After isolating and translating sensitive keystrokes, we
should commit them to the targeted user app. Obviously, as a
pre-IME defense, we cannot use untrusted IME apps to commit
sensitive string. So we have to ﬁnd another data path isolated
from IME apps. Our main idea here is to add an independent
system service that can commit sensitive string from secure
world to a user app for the trusted path.
Normally, the edit box of a user app uses a local binder
named IInputContext.Stub to receive char strings. And
the client of IInputContext.Stub is initialized in the
IMMS at the start of input. In light of the above fact, we add
some code in the IMF to make the IMMS create an extra binder
client for our newly added service commit-proxy. And then
the commit-proxy is capable of committing sensitive string
to the user app. Because the new IPC and new service are
independent of an IME app, sensitive string in this data path
cannot be accessed by any IMEs.
Create a New IPC. Figure 6 shows how the commit-proxy
creates a new IPC with a user app. When a user taps on
the edit box, the user app asks IMMS to callback functions
in the current active IME app. Hooks in startInput will
be invoked. The pre-IME Guard creates a token to IMMS,
which contains a unique id to identify the current user app.
Then IMMS requests the commit-proxy to bind the user app
with two parameters (token, InputConnection). When the
commit-proxy receives this bind request, it makes a SMC call
to check whether the id in token is valid. If it is valid, the
commit-proxy will add the new connection. Otherwise the bind
request will be refused. If any sensitive string is found, the
pre-IME Guard sends sensitive string to the commit-proxy by
a shared memory, and then the commit-proxy will commit it
with the above new IPC.
Fig. 5: STIE initialization. Hooks in the IMF and event
subsystem are invoked to notify the pre-IME Guard in secure
world to initialize the STIE. In modern mobile devices with a
touch screen, we assume that a user intends to type text when
he or she taps on touch screen after a soft keyboard has been
shown up.
information: touch coordinates and the current soft keyboard
layout. The touch screen driver in secure world provides a
secure way to obtain touch coordinates. Now we explain how
the pre-IME Guard gets the soft keyboard layout securely. The
soft keyboard layout is a piece of display data in normal world
that an IME app puts in framebuffer. And framebuffer
is a region of memory which is allocated by a Linux display
driver. The display controller is a peripheral to generate the
necessary control signals for data display. To obtain the soft
keyboard layout on which a user is typing, the pre-IME Guard
takes two steps. Step 1) The display controller is reconﬁgured
as secure by TrustZone TZPC so that normal world cannot
change it. This is important because display controller provides
information about the start region of framebuffer. If the
display controller is not controlled by secure world, normal
world software can deceive the pre-IME Guard into a wrong
framebuffer and translating in a wrong soft keyboard
layout. Step 2) After a touch event happened, the pre-IME
Guard reads framebuffer and checks correctness of the
layout. As a proof-of-concept prototype, IM-Visor preloads
the layout information of popular IME apps and determines
whether the layout is correct by comparing the hash of the
current layout with the preloaded standard one. As a future
work, in step 2, instead of the “preload&check” way, we
will obtain the current layout by an efﬁcient optical character
recognition (OCR).
Leaving framebuffer in normal world is not a secure
concern as it seems. Supposing an untrusted IME app intends
to ﬁgure out which keystroke a user types, it also needs the
above two pieces of information. But sensitive touch coordi-
nates only stay in secure world. So an IME app cannot succeed
in ﬁnding sensitive keystrokes without touch coordinates.
After identifying a keystroke,
the pre-IME Guard will
translate it
into a character. Now we give an example of
keystroke translation. For Latin language, every keystroke can
directly correspond to a character, but for non-Latin languages
candidate words often need to be shown. Here, we only discuss
Latin language translation with a qwerty keyboard. Supposing
the user types “a” in the soft keyboard, then secure touch
150
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:02:20 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 6: How a user app binds the commit-proxy. Note that a
token is necessary to detect the legitimacy of a user app for
the binding.
D. Address Challenge 3: Beneﬁts Retaining
To retain the extra beneﬁts of IME apps (e.g., auto correct-
ing and word association), one possible way is to implement
the value added feature in IM-Visor. However, this way makes
all IME apps useless and means a lot of extra coding works for
IM-Visor (e.g., cloud-based word association and local trusted
GUI lib). We look for a more efﬁcient and elegant approach.
Our key idea here is to design a replay mechanism and
let IME apps work for non-sensitive keystrokes. We designed
a daemon thread named replay executor running in System
Server process to replay touch events. If some touch events
need to be replayed, the pre-IME Guard puts them in a shared
memory and then the Replay Executor reads and replays them.
We explain the detail as follows.
In Android system, every activity or service maintains a
thread loop to receive touch events or other input events by
an input channel. If the Replay Executor intends to replay a
touch event directly, it needs to maintain the input channels
and selects which activity or service will receive the touch
event. The selection is based on not only touch coordinates
but also window layouts and the current window focus.
The key point is that the Replay Executor only receives
touch events from the pre-IME Guard and then triggers event
subsystem to complete the “maintain&selection”. As men-
tioned in Section II-A, an input dispatch thread in Window-
ManagerService is responsible for touch events dispatching.
In most cases, the input dispatch thread sleeps on an input
event queue. When a touch event needs to be dispatched,
it wakes up and dequeues an event, then selects an activity
or service for dispatching. If we can handle this input event
queue and wake up the thread when a replay is needed,
we can let the event subsystem do the “maintain&selection”
work. This is exactly how the Replay Executor works. The
context of WindowManagerService provides the event queue of
input dispatch thread. The Replay Executor encapsulates non-
sensitive keystrokes as required Android touch event format
and enqueues them. Then it simply wakes up the dispatch
thread to do the rest work for our replay. As a related issue,
non-keystroke touch events also can be replayed by this way.
E. Minor Challenge 4: Buffer Revisiting Threat
As discussed in Section III-A, we discover a new data
leakage path from a user app to an IME app by some revisit
APIs. To prevent this threat, we hook all revisit APIs (see
Listing.1) and analyze the revisited char string again to detect
and block sensitive text when a third-party IME app revisits
the buffer of a user app.
F.
Implementation
We have implemented IM-Visor on Samsung 4412 devel-
opment board equipped with ARM TrustZone. Android and
kernel version on the board are 4.0 and 3.0.2 respectively.
Pre-IME Guard and Services. Speciﬁcally, the pre-IME
Guard runs as a trustlet in secure world and Android runs
in normal world. The commit-proxy is a system service in
Android System Server process. The Replay Executor is a
daemon thread running in System Server process. Both of them
are passively waiting to receive data from the pre-IME Guard.
When a user types in the STIE, the pre-IME Guard receives
keystrokes from touch screen and translates them into a char
string. Corresponding to its sensitiveness, we return it through
green path or red path. (see Figure 4)
been
Hooks
hooked:
in the
IMF and Event Subsystem. To
minimize system overhead, we have to hook as
less
as possible. Speciﬁcally, only three classes in Android
InputMethodManagerService,
has
TouchInputMapper.
BaseInputConnection
In order to jump into secure world, a TrustZone driver is
installed in Linux kernel. Hooks make SMC calls through the
newly installed driver. When these hooks are invoked, the
pre-IME Guard can intervene the data-ﬂows in Android IMF.
Listing 1 shows all the hooks we put in Android.
and
Listing 1: Hooks in the IMF and event subsystem
1
2 // hooks in TouchInputMapper
3 // Callback received by IM−Visor for interception .
4 void sync(nsecs_t when);
5
6 // hooks in InputMethodManagerService
7 // Callback to create token for the new IPC binding
8 // and text ﬁelds of context−based policy.
9 InputBindResult startInput(
10
IInputMethodClient client,
IInputContext inputContext,
EditorInfo attribute,
int controlFlags);
14
15 // Callback to notify IM−Visor, about soft keyboard showing.
16 boolean showSoftInput(
17
IInputMethodClient client,
int flags,
ResultReceiver resultReceiver);
20
21 // Callback to notify IM−Visor, about soft keyboard hiding
22 boolean hideCurrentInputLocked(
23
int flags,
ResultReceiver resultReceiver);
24
11
12
13
18
19
25
26 // Callback to destroy token .
27 void finishInput(IInputMethodClient client);
28
29 // hooks in BaseInputConnection
30 // Callback received by IM−Visor for buffer
31 CharSequence getTextBeforeCursor(
32
revisiting
threat
int length,
int flags);
33
151
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:02:20 UTC from IEEE Xplore.  Restrictions apply. 
35 // Callback received by IM−Visor for buffer
revisiting
36 CharSequence getSelectedText(int flags);
38 // Callback received by IM−Visor for buffer
37
39 CharSequence getTextAfterCursor(
40
revisiting
threat
threat
34
41
int length,
int flags);
Secure Touch Screen and Display Controller Reconﬁgu-
ration. When a user intends to type in an IME soft keyboard,
some reconﬁguration should be done for the STIE initial-
ization. We reconﬁgure Interrupt Security Register(ICDISR),
Priority Mask Register (ICCPMR) and Enable Set Register
(ICDISER) to make the touch input as a secure interrupt
and mask all non-secure intterupt. In CPU Interface Control
Register (ICCICR), FIQEn, EnableS are set to 1 to enable
FIQ interrupt. FIQ bit in Secure Conﬁguration Register (SCR)
is also set to 1 to ensure FIQ interrupt routing to TrustZone
monitor mode. Besides, touch screen and display controller are
set to be secure peripherals with TZPC. As a proof-of-concept
prototype, we only implement single-touch in the separate
touch driver and leave multi-touch as a future work.
VI. EVALUATION
A. Security Evaluation
Malicious IME apps and PHAs will upload user sensitive
data to remote servers, causing harm to users. To evaluate
the defense effectiveness of IM-Visor against malicious IME
apps, we construct malicious IME apps by repackaging some
popular ones to make them send sensitive keystrokes to a
remote server. We want to see whether they can still leak
out sensitive keystrokes during the IM-Visor protection. To
evaluate the defense effectiveness of IM-Visor against PHAs,
we analyze the commonly used IME apps’ network packets. As
we can see, without IM-Visor, these IME apps may send user
sensitive keystrokes outside, and with IM-Visor, user sensitive
keystrokes won’t be found in their network packets.
1) Defense against Malicious IME Apps: We use repack-
aging to design malicious IME apps and the targets of repack-
aging are the popular third party IME apps. As many IME
apps have their own different defenses against repackaging, the
difﬁculty of repackaging on different IME apps is different.
Some IME apps just design simple defense which are not
difﬁcult to be cracked, and some construct complex solutions
which will cost much time to be repackaged. We repackaged
three IME apps, one is Sogou IME which is the most popular
third party IME, and the other two are QQ IME and TouchPal
IME which are also very popular third party IME apps. We
can get the smali code for each app after decompiling the APK
ﬁle and then add some code in several critical locations in the
smali ﬁle. For example, as most of IME apps use the Android
IMF which provides various classes and APIs, we can hook the
API commitText to intercept all the user input. The added
code is inserted into the location of commitText and the
functionality of the added code is to upload each user keystroke
to a remote server by socket connections. Finally, the modiﬁed
code is recompiled, signed and installed in the terminal. After
installation, the repackaged IME can be set as the default IME
by modifying the system settings. Now we open an app which
needs a user to type user name and password, and we ﬁnd that
Fig. 8: The analysis on Sogou IME app’s network packets. The
leaked data “password” appears in one of Sogou IME app’s
packets.
the entered user name and password are sent to the remote