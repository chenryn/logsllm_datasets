may be easily broken by attackers. Furthermore, rather than using
498
1. NtCreateFile ( Out FileHandle A, (cid:171).. , ObjectAttributes -> C:\Netsky.exe)2. (cid:171)(cid:171)(cid:171)(cid:171)..3. NtCreateFile ( Out FileHandle B, (cid:171). , ObjectAttributes -> C:\WINDOWS\AVprotect9x.exe)4. (cid:171)(cid:171)(cid:171)(cid:171).5. NtCreatSection ( In FileHandle A, (cid:171)(cid:3)Out SectionHandle C, ObjectAtrribtue->XXX)NtMapViewOfSection ( In SectionHandle C, (cid:171).)6. (cid:171)(cid:171)(cid:171)(cid:171)(cid:171).7. NtWriteFile ( In FileHandle B, (cid:171).)8. (cid:171)(cid:171)(cid:171)(cid:171)..denoted W M inCS(G), if there exist no other weighted common
supergraph of G that has fewer nodes than g. Let fi : Vi ! V be
an isomorphism between gi and a subgraph of g. Let (u; v) be a
pair of vertexes of V . The weight (w) of each edge e = (u; v)
is k=n if there exist exactly k distinct isomorphisms fj(eil) =
(fj(ui); fj(vl)) such that fj(eil) = e. The weight of the vertex
is simply set to 1.
The computation of a WMinCS is a NP-complete problem. More-
over, the complexity of computing WMinCS of a set of graphs is
exponential in the number of graphs. Consequently, the proposed
method uses an algorithm that approximates the WMinCS of a set
of graphs G.
The approximate WMinCS algorithm is derived from the weight-
ed maximum common subgraph (wmcs) of a pair of weighted
graphs. The computation of wmcs(g1; g2) is based on the compu-
tation of the mcs of two graphs. To generate wmcs between two
weighted behavioral graphs, the McGregor algorithm [8] is used a-
mong various known efﬁcient algorithms in the literature[8]. The
WMinCS between two weighted behavioral graphs is generated by
Eq.(2) as follows.
W M inCS(gi; gj) = wmcs(gi; gj) [ (gi (cid:0) wmcs(gi; gj))
[ (gj (cid:0) wmcs(gi; gj)):
(2)
The approximate WMinCS equation between the two graphs is
extended to a set of graphs, G = fg1; g2; :::; gng. In other words,
after ordering a set of behavioral graphs randomly, W M inCS(g; gi)
(2 (cid:20) i (cid:20) n) is iterated n (cid:0) 1 times to compute an approximate
W M inCS(G) (Note that g is the ﬁrst behavioral graph in the set
after ordering G). The weights of W M inCS(g; gj) are repeatedly
computed for the edges as deﬁned in Eq.(2). Speciﬁcally, for the
edges in WMinCS, the weight is equal to the sum of the weights of
the isomorphic edges, divided by the number of behavioral graph-
s in the set (n). The weight of vertexes in the resulting WMinCS
is simply set to 1, and is not used. Furthermore, the wmcs of G
after clustering all the graphs, which is shared by all of the behav-
ioral graphs, is a particularly important subgraph which is called
the HotPath. The weight of all edges in the HotPath is 1, since all
behavioral graphs have this subgraph in common.
Finally, the approximately derived WMinCS for the set is re-
duced into one weighted common behavioral graph (W CBG(cid:2)(G))
after pruning with a predeﬁned threshold ((cid:2)), as in the previous
section. In other words, edges whose weight is less than (cid:2) are re-
moved, as well as vertexes isolated by their removal. The result is
the Weighted Common Behavioral Graph (WCBG), a representa-
tive graph for each family of malware. The WCBG contains only
edges or dependencies occurring in at least a speciﬁed fraction of
the malware binaries. The WCBG summarizes all and only those
properties shared by most of the malware instances, and the Hot-
Path representing behavior demonstrated by all malware execution-
s. The resulting WCBG is used for malware detection, as described
in the next section. We now describe how WCBGs are used to de-
tect new instances of malware in the second step of the method.
2.3 Malware Detection
We ﬁrst generate a KOBG for a program suspected of being ma-
licious. This KOBG of the new suspicious instance is compared
with the WCBG for one malware family. An edge Ei in a WCBG
is matched with an edge ej in a behavior graph if the vertex and
edge attributes of Ei and ej are the same. The weights of all such
matched edges are summed. This sum is then divided by the mini-
mum of the number of edges in the WCBG, or in the kernel object
behavior graph. The resulting measure of similarity is guaranteed
(a) An example of kernel object behavioral
graph (Our approach)
(b) An example of system call behavioral
graph
Figure 2: An illustration of kernel object behavioral graph
from the exemplar code in Figure 1. Note that Figure 2(b)
shows a typical system call behavioral graph based on the de-
pendency of system calls.
original individual graph, the proposed work will use one common
graph from a set of many graphs, as discussed in the next section.
2.2 Weighted Common Behavioral Graph Gen-
eration based on an Approximate Algo-
rithm
For the execution of one malware instance, a KOBG is derived
in the way just described. For malware identiﬁcation purposes, the
KOBGs of a family of malware instances are clustered into a single
behavioral graph. Let G = fg1; :::; gng be a set of n kernel object
behavioral graphs constructed from the system call traces collected
during the execution of n binaries, where these binaries are classi-
ﬁed as belonging to the same malware family.
To cluster behavioral graphs, we make use of existing methods
of clustering graphs, as in Deﬁnition 1. The Weighted Minimum
Common Supergraph (WMinCS) is a clustering method formally
described in [3]. Based on some well-known concepts in graph the-
ory [9], including graph isomorphism, the maximum common sub-
graph(mcs), and the weighted minimum common subgraph (wmcs).
The Minimum Common Supergraph (M inCS) of G and H is de-
ﬁned as Eq.(1). Note that G (cid:0) mcs(G; H) and H (cid:0) mcs(G; H)
are the graphs obtained by removing the mcs of G and H from G
and H, respectively.
M CS(G; H) = mcs(G; H) [ (G (cid:0) mcs(G; H))
[ (H (cid:0) mcs(G; H))
(1)
The Minimum Common Supergraph for a set of graphs is similarly
the union of mcs of those graphs and the edges and vertexes in
those graphs that are not included in the mcs.
DEFINITION 1. Let G = fg1; g2; :::; gng be a set of weight-
ed directed graphs; a Weighted Common Supergraph of G, is a
weighted directed graph g = (V; E; (cid:11); (cid:12); (cid:21); !) such there exist
subgraph isomorphisms from gi to g 8 i 2 f1; :::; ng. We call g a
Weighted Minimum Common Supergraph of the set of graphs G,
499
ProcessFile_C:\Netsky.exeFile_C:\Windows\AVprotect9x.exeSection_XXXNtCreateFileNtWriteFileNtCreateSectionNtMapViewOfSectionFileHandleFileHandleSectionHandleto be between 0 and 1, since all weights are also between 0 and 1.
A decision D as to whether a suspected program is malicious is
made as shown in Eq.(3).
D = (HotP ath (cid:18) gnew) ^ ((cid:14)(W CBG; gnew) (cid:21) (cid:13))
(3)
In other words, to decide that the suspicious instance is malware,
the KOBG must necessarily include the HotPath of the resulting
WCBG, and the similarity between the KOBG and the WCBG must
exceed a predeﬁned threshold (cid:13).
3. EVALUATION
This section presents the results of evaluating the proposed method.
The method was implemented and used to detect a number of mal-
ware samples taken from “the wild”, also used by other researchers
to evaluate their work. The detection and false positive rates, and
robustness of the proposed method are examined in detail.
3.1 Experiment Setup
Real-world malware samples were executed in a “sandbox” en-
vironment. Some malware instances (the training set) were used to
construct WCBGs, while others (the test set) were tested to evaluate
the detection and false positive rates.
As shown in Figure 3, two data sets were used in order to test
the sensitivity of the method to differing inputs. The ﬁrst data
set, DATASET_1, consisted of 563 binaries. This set was obtained
from the Anubis Project1; it was also used for the evaluation of the
method described in [17]. In our work, the classiﬁcation of bina-
ries into malware families, and size of and assignment to training
set and test set, are exactly as in [17]. DATASET_2 was collect-
ed from several well-known public websites2, and consisted of 520
binaries. By using the Kaspersky anti-virus scanner, malware in-
stances in the second data set were classiﬁed into malware families,
as shown in Figure 3. All the binaries in the data set have Windows
ﬁle format, and most of them were packed.
Figure 3: Summary of malware families for experiment
One hundred popular Windows XP applications were used to e-
valuate the false positive rate of the proposed method. These in-
cluded applications such as Notepad, Winzip, Winscp, Internet Ex-
plorer, Media Player, ICQ, MSN, Alzip, Emule, etc. The imple-
mentation of the proposed method was based on Ether [11], and
the experimental system was a 3 GHz Intel dual core processor
with 2GB of main memory.
3.2 Performance of Malware Detection
The detection and false positive rates of the proposed method
were evaluated ﬁrst. For the training set of each malware family,
the weighted common behavior graph (WCBG) was constructed
1http://anubis.iselab.org
2http://vx.netlux.org,
http://www.malwaredomainlist.com
http://www.offensivecomputing.net,
500
according to the method described in section 2. The WCBG for
each training set was constructed with a threshold (cid:2) equal to 0.5.
The detection threshold for this purpose was set to (cid:13) = 0:7.
Figure 4: Detection rates (Dt) and false positive rates (Fp) for
the proposed method ((cid:2)=0.5, (cid:13) = 0.7)
Detection Capability: Figure 4 shows detection and false posi-
tive rates of the proposed method. First, the ability of the WCBG
to detect malware in the training set (from which the WCBG was
constructed) was tested. The KOBG of each member of a training
set was matched with the WCBG of its family. The detection rate
for malware in the training set of DATASET_1 was more than 95%
except for the Agent family. For this family, we could not collect
system call traces completely, since most of the malware instances
crashed the system; this was also reported in [17].
For the training set of DATASET_2, more than 90% of the bina-
ries in the Mytob and the Mydoom family were correctly identiﬁed,
with detection rates for other families ranging from 76-88%.
This same ﬁgure shows the effectiveness of the proposed method
when applied to unknown malware instances (the test set) not in-
cluded in the training set. In other words, these experiments were
run to investigate how effective each WCBG was at detecting mal-
ware. In general, the detection rates for these test set members are
somewhat lower than for members of the training set, as may be
expected. Except for the Agent family of DATASET_1, the detec-
tion rates were over 80%. However, with the same data set in [17],
this method for the test sets achieved higher detection rates than
the previous work. For the test sets of DATASET_2, the proposed
method showed similar performance to the results of [17]. Based
on the information of kernel objects and their attributes, the method
effectively detects malware variants.
The detection rates for each malware family vary from around
70% to 100%.
It is possible that malware instances were often
misclassiﬁed into a distinct family, as discussed in [17]. For in-
stance, 11 of 30 malware instances classiﬁed in the Bagle family
in DATASET_2 by the Kaspersky A/V product were classiﬁed into
the Allaple or Trojan families by the Anubis project, and 3 samples
in the set could not be classiﬁed. As discussed in [1], it is doubt-
ful any anti-virus tool correctly classiﬁes all instances of a malware
family. Better malware classiﬁcation techniques will improve the
effectiveness of the proposed method.
To evaluate false positive rates for the proposed method, each bi-
nary in the set of 100 Windows application executables was tested
against the WCBG of each malware family. Results are also shown
in Figure 4. Only the Agobot family showed a non-zero false pos-
itive rate, while the other WCBGs all produced 0% false positive
rates. The false positive rate for the Agobot family is caused by the
very small number of the edges in the HotPath. That means that the
binaries in the training set show a higher variety of behaviors.
The results demonstrate that the proposed method effectively and
correctly identiﬁes malware, since the common properties are very
different from those of benign applications.
Comparison: DATASET_1 was also used in [17] for evaluation
Training SetTest SetTraining SetTest SetAllapleExploit-based worm5050N/AN/AAgentTrojan50505030MytobMass-mailing worm50505030BagleMass-mailing worm50505030MydoomMass-mailing worm50505040NetskyMass-mailing worm50135040AgobotIRC WormN/AN/A5050Total Number N/AFamily NameMalware TypeDATASET_1DATASET_2563520Training SetTest SetTraining SetTest SetAllaple1.000.90N/A N/A 0.00Agent0.600.380.820.830.00Mytob0.980.920.920.730.00Bagle1.000.800.760.670.00Mydoom1.000.901.000.880.00Netsky0.940.770.860.750.00AgobotN/A N/A 0.880.760.08False Positve Family NameDATASET_1DATASET_2purposes. Their work used system call traces with instruction logs
to identify data ﬂow dependencies, while the method proposed here
aims to cluster a behavioral graph by using kernel objects. From
this information, the method can effectively identify malware vari-
ants. The detection rates of the method proposed here were equal
or higher to that of [17] for every family except the Agent family.
With only system call traces, the proposed method achieved better
performance with the new common kernel object graph shared in a
family. It is simple, but it is robust and accurate enough to detect
any variant. Details are omitted due to space limitations.
Robustness: Since the proposed method relies on system calls
for identiﬁcation purposes, attacks that target system call behavior
may have an effect. A prime example would be the addition or in-