下面的虚构例子中，产品会有很多的调用日志函数使用这样的结构：
第二个参数通常是很有帮助的，因为在没有调式符号的情况下，它能够被用来恢复被调用的函数/类
名。因此，通过为Ghidar写一个Python脚本，能够自动执行这个，从而更好的了解类结构。
HKLM\SYSTEM\CrowdStrike\{9b03c1d9-3138-44ed-9fae-d9f4c034b88d}\{16e0423f-7058-
48c9-a204-725362b67639}\Default\AFLAGS` ⟶ `03 00 00 00
HKLM\SOFTWARE\Cylance\Desktop\LogLevel` ⟶ `3
HKLM\Software\Wow6432Node\Tanium\Tanium Client\LogVerbosityLevel` ⟶ `91
// prototype
void
logger(int   log_level,
       char* function_name,
       char* file_name,
       char* format_str,
       ...);
// example call
logger(3,
       "EventLogger::VerifyConfigurationData",
       "EventLogger.cpp",
       "Config data cannot be found (User[%ls], System[%ls])",
       L"HKEY_CURRENT_USER\\Software\\FancyEDR",
       L"HKEY_LOCAL_MACHINE\\Software\\FancyEDR");
这是很不错的，因为它允许我们在一个更高的抽象层面推理代码进而加速这个反向过程。点击 here来
阅读Ghidra脚本在github上。
内核驱动
许多产品在它们的传感器上包含一个内核驱动零件，它被用来从操作系统上收集遥测。它也能被用来其
他的目的例如决策和发送遥测，但是它依赖于产品。在Windows上，驱动能够注册很少的收集遥测的回
调函数。. @dotslashroot and @sbousseaden已经发布了它们怎么使用Sysmon。
下面，在基于windows的传感器平添，你将看到一个高层级的遥测。在这个流上，如果一个用户启动了
一个calc,这将触发一个回调 PsSetCreateProcessNotifyRoutine . 这个驱动会从它接收到的数据产生
一个事件，用户模式的服务器将从驱动收到它，以便它能够发送到产品服务器。
你应该花点时间来验证下被服务和驱动组件公开的IPC进程间通信机制。也就是说，这儿没有增加更多
专门使用于AV/EDR产品的东西。IPC机制能够广泛地跨产品和操作系统。在Windows上，某些例子如：
custom service control codes, COM objects, and IOCTL dispatch functions.
总结
从传感器侦察程序，你可以获取很多信息，是否它影响进一步研究或者在目标上访问OPSEC。当处于目
标系统上时，检测使用的产品然后解析它配置，提供一些有用的东西能够影响你下一步。站在研究角
度，日志和字符串一直提供了一个好的切入点供调查的途径。在后续文章中太露技术时，推断传感器的
架构和IPC机制会给你带来坚实的基础。
下一篇： next post 将会讨论如何转义EDR的遥测到专用基础设施，以便你可以看到在开发bypass传感
器时看到的内容（没有引起defenders注意。）
第三部分
转移EDR遥测到私有基础设施
正如我在介绍中提及到的，在这个系列中对象之一就是在实验室环境下不需要使用产品控制台就能够访
问到遥测。对于我来说，这是个改变游戏，因为我们能够使用事件数据作为一个回溯来进行“排练”攻击
然后开发bypasses--并没有给防守者小费（解释bypass含义）。它就像拥有一个私有的VT但是是为EDR
而不是AV。(Telemetry遥测只有EDR具备，AV没有那么自动化或者智能化)。
这个想法并不是完全的小说化。它已经有可能拥有一个相似的实验建设，遥测从免费的工具（像
Sysmon和osquery）收集数据，但是能够从你使用的具体的EDR产品中私密的收集遥测，从而提供了
无法比较的更高额外的精准度。例如，某些产品内置了检测，如果某个行为触发了警报，它将能够提前
知道。
值得强调的是获取传感器遥测访问没有必要告诉你什么会被检测到。尽管一些产品对传感器建立了一定
程度的检测逻辑（像上述展示的），但是很多的检测规则将在服务端被应用。例如，如果PowerShell 
被IE派生，传感器将产生子进程创建遥感数据，并且如果它考虑了这个行为，服务端/云可能会产生一次
检测。通过在本文中这种方法，基于服务端检测你不需要获取权限，但是你将获取流入检测的每个产生
的事件的权限。
一般的做法
在传感器外部检测EDR事件数据时，涉及一些编码并且这有多种方法来实现这个任务。这取决于你想要
你的代码和EDR保持兼容的程度，反之，就是EDR应该和你的代码保持兼容的程度。
一方面，你可以写一个模仿产品服务器功能的模拟服务器。如此，你可以简单的更改传感器的配置来指
向你的模拟服务器而不是原来那个，从那收集事件。另一方面，你可以添加插件/补丁给传感器代码来
dump你期望的格式的事件。有时，这两者都涉及。
我推荐开始使用这种方法，这是最简单的方法就是写POC。(proof of concept)。好处就是在项目管道
中其他相关的任务不会被阻止。之后，你就可以回来看性能提升和稳定性是在哪里实现的。我更喜欢的
是写一个模拟服务器，因为，虽然前期需要花费更多的事件，但是长期来看，涉及到更少的补丁在一些
脆弱性的产品上，它更容易保持。
捕获和解析原始的遥测
一个共同的起点是发现获取原始事件的地点和如何解析它们。一些产品在磁盘上以数据库文件或者临时
档案存储了事件的缓存，而其他的仅仅在内存中存储那些缓冲。如何事件在磁盘上是可访问的，然后值
得调查的是不通过传统的步骤来写一个模拟服务器或者更改传感器你是否能够获取数据。从一个非预期
的进程访问事件缓冲区，可以加密存储或者触发篡改警报，因此可能要注意这些潜在的障碍--尤其是在
研究阶段，你可能处于“被发现”的位置时。
一旦你有权访问事件缓冲区，下一步就是反序列化它们。事件能够被序列化，人类可读的格式（例如 
JSON）或者二进制（例如 ProtoBuf）,但是我注意到通常大多数是后者。模式丰富的二进制格式可提高
效率，但是当字段名称丢失时，它们来带来了一个附加的模糊层。如果一个公共的二进制格式正在被使
用，可执行传感器可能将会有关于那一个正在被使用的线索。关于它们怎样在字节层被结构化是值得读
的。 reading up
此阶段会严重延迟资源匮乏的开发者的工作，它们无法访问事件模式。记录原始序列化缓存到私有的
SIEM
将无法进行有效的分析，因此这种模式在某种程度上需要被覆盖。依赖产品，你可能变得很幸运然后发
现这个在线模式online，或者能够从传感器的二级制里面提取他们，或者使用文档手册 documentation
手动重建它们。在那个例子中，OSSEM 项目有几种产品的 数字字典
案例和回顾
这有一组虚构的场景来说明被捕获并且解析EDR遥测的步骤。
场景1：
通过一个 HTTPS本地服务器，传感器被配置定期地每分钟检测。每次它发送事件，包含遥测的文件被拖
放到磁盘上，上传的请求接收到一个200响应码之后，然后删除。
文件结构表示一系列的ProtoBuf 对象，但是没有架构是公开可用的。幸运的是，ProtoBuf文件描述符
仍然嵌入在二进制中，使用 PBTK工具仍然能够提取出来。随着事件结构恢复，在它们被删除之前通过
读拖到磁盘上的文件，或者通过指定传感器到一个模拟服务器记录下接收被上传的文件，事件本身能够
被取回。
场景2：
这个传感器通过一个安全的WebSocket连接到一台基于云硬编码的端点，然后事件被持续的流向它。他
们也被缓存在一台加密的SQLite数据库。关于事件架构和重建它们繁琐的手工过程，一些文件资料是可
用的。
随着大多数架构恢复，从先前的情况，一个类似的决策点是接收事件缓冲。一个可选的是决定怎样解密
数据库，然后轮询新的事件。另一个选项是写一个模拟WebSocket服务器来接收事件。看到正如默认传
感器连接是硬编码的，做些修改指向它到你的服务器然后绕过证书校验。
回顾下，你应该问问你自己下列这些问题什么时候捕获原始的EDR遥测。
这些可以帮助你决定下一行动或者其他调查途径：
遥测被缓存到磁盘上还是内存中？
如果在磁盘上，它可能是数据库文件，临时文件，或者“无文件”？
如果在内存中，怎么从内存中提取或者写到模拟服务器？
产品提供了一个对话框机制来查询遥测吗？
在被反序列化之前，缓冲需要被解密或者反混淆吗？
它们是怎样序列化的？(例如 ProtoBuf,JSON,Bond,custom)
事件类型的架构是否可用？如果没有，它们能否被恢复？
实施一个模拟服务器
所有的EDR产品都会发送事件到一台服务器，然后写一台模拟服务器能够允许你以这种方式（它们更倾
向于被产品本身的服务器端组件接收）接收事件。这个方法可能不值得没有给产品，但是我很喜欢讨论
它，因为在某些情况下更有意义。
从传感器接收一个连接
实施一个模拟服务器的第一步就是考虑EDR是否允许连接到本地服务器(on-premise servers)或者严格
的仅仅限于云管理。本地服务器本身就允许改变配置，指向你的模拟服务器而不是通过更改配置文件或
者使用诊断工具。云管理服务器通常需要更多的精力。在云场景中，可以选择修改主机文件--假设传感
器检测到异常(anomaly)没有退回到一个硬编码地址的IP列表。
一些传感器也强制执行证书固定。如果一台服务器细节是可配置的，然后这可能可以选择来替换存储的
证书然后使用你自己的。如果没有配置选项存在（例如云管理传感器），那么值得自信阅读二进制中关
于如何验证证书信息的。一些产品可能只验证CN，因此你可以调整自签名来使其适配。其他产品可能
验证完整的证书，能够通过破解二进制来解决。例如，执行验证的函数能够被破解，总是返回true.
协议认证和分析
现在你可以建立一个连接了，你能够执行分析被导入的APIs或者库来考虑是否有一个正在被使用的公共
的网络协议（例如 HTTP,WebSocket）或者自定义协议。
如果HTTPS被使用了，你可以写一个小的python脚本来请求了idea 这样：
这些请求的内容类型也应该被考虑。（例如 JSON，ProtoBuf）如果一个二进制序列化格式被使用，你
可以进一步分析传感器来看看是否有嵌入式描述符能够解析缓冲区数据，成为人类可以读懂的格式。