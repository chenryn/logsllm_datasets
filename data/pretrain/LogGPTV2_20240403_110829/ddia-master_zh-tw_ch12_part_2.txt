最大的不同之处在于事务系统通常提供 [线性一致性](ch9.md#线性一致性)，这包含著有用的保证，例如 [读己之写](ch5.md#读己之写)。另一方面，衍生资料系统通常是非同步更新的，因此它们预设不会提供相同的时序保证。
在愿意为分散式事务付出代价的有限场景中，它们已被成功应用。但是，我认为 XA 的容错能力和效能很差劲（请参阅 “[实践中的分散式事务](ch9.md#实践中的分散式事务)”），这严重限制了它的实用性。我相信为分散式事务设计一种更好的协议是可行的。但使这样一种协议被现有工具广泛接受是很有挑战的，且不是立竿见影的事。
在没有广泛支援的良好分散式事务协议的情况下，我认为基于日志的衍生资料是整合不同资料系统的最有前途的方法。然而，诸如读己之写的保证是有用的，我认为告诉所有人 “最终一致性是不可避免的 —— 忍一忍并学会和它打交道” 是没有什么建设性的（至少在缺乏 **如何** 应对的良好指导时）。
在 “[将事情做正确](#将事情做正确)” 中，我们将讨论一些在非同步衍生系统之上实现更强保障的方法，并迈向分散式事务和基于日志的非同步系统之间的中间地带。
#### 全序的限制
对于足够小的系统，构建一个完全有序的事件日志是完全可行的（正如单主复制资料库的流行所证明的那样，它正好建立了这样一种日志）。但是，随著系统向更大更复杂的工作负载伸缩，限制开始出现：
* 在大多数情况下，构建完全有序的日志，需要所有事件汇集于决定顺序的 **单个领导者节点**。如果事件吞吐量大于单台计算机的处理能力，则需要将其分割槽到多台计算机上（请参阅 “[分割槽日志](ch11.md#分割槽日志)”）。然后两个不同分割槽中的事件顺序关系就不明确了。
* 如果伺服器分布在多个 **地理位置分散** 的资料中心上，例如为了容忍整个资料中心掉线，你通常在每个资料中心都有单独的主库，因为网路延迟会导致同步的跨资料中心协调效率低下（请参阅 “[多主复制](ch5.md#多主复制)”）。这意味著源自两个不同资料中心的事件顺序未定义。
* 将应用程式部署为微服务时（请参阅 “[服务中的资料流：REST 与 RPC](ch4.md#服务中的资料流：REST与RPC)”），常见的设计选择是将每个服务及其持久状态作为独立单元进行部署，服务之间不共享持久状态。当两个事件来自不同的服务时，这些事件间的顺序未定义。
* 某些应用程式在客户端储存状态，该状态在使用者输入时立即更新（无需等待伺服器确认），甚至可以继续离线工作（请参阅 “[需要离线操作的客户端](ch5.md#需要离线操作的客户端)”）。对于这样的应用程式，客户端和伺服器很可能以不同的顺序看到事件。
在形式上，决定事件的全域性顺序称为 **全序广播**，相当于 **共识**（请参阅 “[共识演算法和全序广播](ch9.md#共识演算法和全序广播)”）。大多数共识演算法都是针对单个节点的吞吐量足以处理整个事件流的情况而设计的，并且这些演算法不提供多个节点共享事件排序工作的机制。设计可以伸缩至单个节点的吞吐量之上，且在地理位置分散的环境中仍然工作良好的的共识演算法仍然是一个开放的研究问题。
#### 排序事件以捕获因果关系
在事件之间不存在因果关系的情况下，全序的缺乏并不是一个大问题，因为并发事件可以任意排序。其他一些情况很容易处理：例如，当同一物件有多个更新时，它们可以透过将特定物件 ID 的所有更新路由到相同的日志分割槽来完全排序。然而，因果关系有时会以更微妙的方式出现（请参阅 “[顺序与因果关系](ch9.md#顺序与因果关系)”）。
例如，考虑一个社交网路服务，以及一对曾处于恋爱关系但刚分手的使用者。其中一个使用者将另一个使用者从好友中移除，然后向剩余的好友传送讯息，抱怨他们的前任。使用者的心思是他们的前任不应该看到这些粗鲁的讯息，因为讯息是在好友状态解除后传送的。
但是如果好友关系状态与讯息储存在不同的地方，在这样一个系统中，可能会出现 **解除好友** 事件与 **传送讯息** 事件之间的因果依赖丢失的情况。如果因果依赖关系没有被捕捉到，则传送有关新讯息的通知的服务可能会在 **解除好友** 事件之前处理 **传送讯息** 事件，从而错误地向前任传送通知。
在本例中，通知实际上是讯息和好友列表之间的连线，使得它与我们先前讨论的连线的时序问题有关（请参阅 “[连线的时间依赖性](ch11.md#连线的时间依赖性)”）。不幸的是，这个问题似乎并没有一个简单的答案【2,3】。起点包括：
* 逻辑时间戳可以提供无需协调的全域性顺序（请参阅 “[序列号顺序](ch9.md#序列号顺序)”），因此它们可能有助于全序广播不可行的情况。但是，他们仍然要求收件人处理不按顺序传送的事件，并且需要传递其他元资料。
* 如果你可以记录一个事件来记录使用者在做出决定之前所看到的系统状态，并给该事件一个唯一的识别符号，那么后面的任何事件都可以引用该事件识别符号来记录因果关系【4】。我们将在 “[读也是事件](#读也是事件)” 中回到这个想法。
* 冲突解决演算法（请参阅 “[自动冲突解决](ch5.md#自动冲突解决)”）有助于处理以意外顺序传递的事件。它们对于维护状态很有用，但如果行为有外部副作用（例如，给使用者传送通知），就没什么帮助了。
也许，随著时间的推移，应用开发模式将出现，使得能够有效地捕获因果依赖关系，并且保持正确的衍生状态，而不会迫使所有事件经历全序广播的瓶颈）。
### 批处理与流处理
我会说资料整合的目标是，确保资料最终能在所有正确的地方表现出正确的形式。这样做需要消费输入、转换、连线、过滤、聚合、训练模型、评估、以及最终写出适当的输出。批处理和流处理是实现这一目标的工具。
批处理和流处理的输出是衍生资料集，例如搜寻索引、物化检视、向用户显示的建议、聚合指标等（请参阅 “[批处理工作流的输出](ch10.md#批处理工作流的输出)” 和 “[流处理的应用](ch11.md#流处理的应用)”）。
正如我们在 [第十章](ch10.md) 和 [第十一章](ch11.md) 中看到的，批处理和流处理有许多共同的原则，主要的根本区别在于流处理器在无限资料集上执行，而批处理输入是已知的有限大小。处理引擎的实现方式也有很多细节上的差异，但是这些区别已经开始模糊。
Spark 在批处理引擎上执行流处理，将流分解为 **微批次（microbatches）**，而 Apache Flink 则在流处理引擎上执行批处理【5】。原则上，一种型别的处理可以用另一种型别来模拟，但是效能特征会有所不同：例如，在跳跃或滑动视窗上，微批次可能表现不佳【6】。
#### 维护衍生状态
批处理有著很强的函式式风格（即使其程式码不是用函式式语言编写的）：它鼓励确定性的纯函式，其输出仅依赖于输入，除了显式输出外没有副作用，将输入视作不可变的，且输出是仅追加的。流处理与之类似，但它扩充套件了运算元以允许受管理的、容错的状态（请参阅 “[失败后重建状态”](ch11.md#失败后重建状态)）。
具有良好定义的输入和输出的确定性函式的原理不仅有利于容错（请参阅 “[幂等性](ch11.md#幂等性)”），也简化了有关组织中资料流的推理【7】。无论衍生资料是搜寻索引、统计模型还是快取，采用这种观点思考都是很有帮助的：将其视为从一个东西衍生出另一个的资料管道，透过函式式应用程式码推送一个系统的状态变更，并将其效果应用至衍生系统中。
原则上，衍生资料系统可以同步地维护，就像关系资料库在与索引表写入操作相同的事务中同步更新次级索引一样。然而，非同步是使基于事件日志的系统稳健的原因：它允许系统的一部分故障被抑制在本地。而如果任何一个参与者失败，分散式事务将中止，因此它们倾向于透过将故障传播到系统的其余部分来放大故障（请参阅 “[分散式事务的限制](ch9.md#分散式事务的限制)”）。
我们在 “[分割槽与次级索引](ch6.md#分割槽与次级索引)” 中看到，次级索引经常跨越分割槽边界。具有次级索引的分割槽系统需要将写入传送到多个分割槽（如果索引按关键词分割槽的话）或将读取传送到所有分割槽（如果索引是按文件分割槽的话）。如果索引是非同步维护的，这种跨分割槽通讯也是最可靠和最可伸缩的【8】（另请参阅 “[多分割槽资料处理](#多分割槽资料处理)”）。
#### 应用演化后重新处理资料