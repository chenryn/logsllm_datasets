attack under coarse-grained and ﬁne-grained CFI.
Table VI shows the number of available SMoTher Gadgets
from several standard libraries. Using the constraints for the
TABLE VI: Available SMother Gadgets in Standard Libraries
CFI Implementation
Coarse-grained
Fine-grained
Standard Libraries
glibc-2.29
libssl-1.1
libcrypto-1.1
ld-2.29
libstdc++
314
21
98
64
47
1
1
4
0
0
SMother Gadget identiﬁed by Bhattacharyya et al. [13], we
scanned for valid SMoTHer gadgets in the ﬁrst 70 instruc-
tions after label instructions (endbr64 and cfi_lbl). For
SPECCFI, we used a function signature based approach for
generating labels [53], [54]. As we can see, although ﬁne-
grained CFI still permits some gadgets, the number is much
smaller than that available under coarse-grained CFI.
It is worth mentioning that we only use SMoTHer gadget
constraints as an example of practical gadgets. There are no
clear systematic approaches to locate generic Spectre gadgets
that are exploitable in practice, further analysis is required in
order to ﬁnd more speciﬁc constraints. We hope to pursue this
question in our future work.
VIII. RELATED WORK
Since the initial announcement of Spectre and Meltdown in
January of 2018, several Spectre variants have appeared [27],
[30], [42], [43], [45], [47]. Spectre attacks are characterized by
manipulating the prediction mechanisms to trigger speculation
to an attacker chosen gadget. They differ in what they exploit
to trigger speculation: branch direction predictor (variant 1,
variant 1.1) [27], [42], [43], branch target predictor (or branch
target buffer) for variant 2 [43], return stack buffer for Spectre-
RSB (also called variant 5) [45], [47], or load-store aliasing
predictor for variant 4 [30]. To mitigate these attacks, several
software and hardware defenses ranging from programming
guidelines for cryptographic software developers [18] to ar-
chitectural changes [40], [77] have been proposed. In this
section, we will overview these defenses categorized into the
Spectre attack variants that they defend against. Table VII
shows the Spectre attacks defenses and which attacks they
mitigate and Table VIII shows the Spectre attacks defenses and
their impact on hardware complexity, software modiﬁcations,
and performance. SPECCFI is the only defense that provides
complete protection against all Spectre attacks with little
impact on performance and implementation overhead. Note
that we are not considering Meltdown style attacks [46], [50],
[61], [62], [70], [73] since they rely on speculation within a
single instruction and therefore do not rely on manipulating
the branch prediction structures.
A. Spectre-PHT Defenses
Spectre-PHT exploits the directional predictor (also called
the Pattern History Table or PHT) to perform the attack. To
defend against this attack, Intel, AMD, and ARM proposed
to use instructions that serialize the execution (e.g. lfence)
to stop speculation around conditional branches [6], [9], [34].
49
Authorized licensed use limited to: University of New South Wales. Downloaded on October 18,2020 at 09:22:13 UTC from IEEE Xplore.  Restrictions apply. 
Train_BTB:
0x1:mov rax, 0x20
0x2:call *rax
foo:
0x10: endbr64
0x11: nop
main: //BTI gadget
0x0:mov rdx,[secret]
0x1:mov rax,0x10
0x2:call *rax //baz()
baz: //Smother free
0x10: endbr64
Train_BTB:
0x1:mov rax, 0x20
0x2:call *rax, L1
foo:
0x20: cfi_lbl, L1
0x21: nop
main: //BTI gadget
0x0:mov rdx,[secret]
0x1:mov rax,0x10
0x2:call *rax, L1//baz()
baz: //Smother free
0x10: cfi_lbl, L1
...
0x14: nop
bar://Smother Gadget
0x20:endbr64
0x24:cmp $0, rdx
0x25:je <>
...
0x14: nop
bar://Smother Gadget
0x20:cfi_lbl, L2
0x21:cmp $0, rdx
0x22:je <>
Attacker
Victim
Attacker
Victim
(a) Coarse-grained enforcement of CFI (e.g. CET)
(b) Fine-grained enforcement of CFI (e.g, SPECCFI)
TABLE VII: Spectre defenses and the attacks they mitigate. Symbols show if an attack is mitigated ((cid:2)), not mitigated ((cid:3)), or
partially mitigated ((cid:4)(cid:3)).
Fig. 10: Speculative control-ﬂow bending attack example.
Side-channel prevention
SafeSpec [40],
InvisiSpec [77]
Attacks
Spectre-PHT
Spectre-BTB
Spectre-RSB
SmotherSpectre
DAWG [41]
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:3)
LFENCE
[6], [9], [34]
(cid:4)
(cid:3)
(cid:3)
(cid:3)
IRBS, IBPB,
STIBP [6], [36]
(cid:3)
(cid:4)
(cid:3)
(cid:3)
(SLH) [19],
(YSNB) [55]
(cid:4)
(cid:3)
(cid:3)
(cid:3)
(cid:3)
(cid:4)
(cid:3)
(cid:2)(cid:3)
Speculation prevention
Retpoline [69]
RSB Stufﬁng [35]
(cid:3)
(cid:3)
(cid:4)
(cid:2)(cid:3)
CSF [67]
(cid:4)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
ConTExT [63]
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
(cid:2)(cid:3)
SPECCFI
(cid:4)a
(cid:4)
(cid:4)
(cid:4)
aCombined with any Spectre-PHT defense
TABLE VIII: Spectre defenses and their overhead in terms of hardware complexity, software modiﬁcation, and performance.
Symbols show if overhead is high (↑), low (↓), or no overhead (-). The performance overhead results are based on what was
reported in the studies; Please note that these values are not based on experiments on identical benchmarks and are only
reported to provide a general sense of performance.
Side-channel prevention
Overhead
Hardware
Software modiﬁcation
Performance
DAWG [41]
↑
–
1 - 5 %
SafeSpec [40],
InvisiSpec [77]
↑
–
SafeSpec: -3%
InvisiSpec: 22%
LFENCE
[6], [9], [34]
–
↑
IRBS, IBPB,
STIBP [6], [36]
–
–
62 - 74.8 %
20 - 50 %
(SLH) [19],
(YSNB) [55]
–
↑
SLH: 29 - 36.4 %
YSNB: 60 %
Speculation prevention
Retpoline [69]
RSB Stufﬁng [35]
–
↓
5 - 10 %
–
↓
↓
CSF [67]
↓
↓
ConTExT [63]
↓
↓
SPECCFI
↓
↓
2.7 - 15.2 %
1 - 71.14 %
1.9 %
Although aggressive serialization (e.g., at every branch instruc-
tion) can mitigate Spectre-PHT, it hurts performance substan-
tially [34]: serializing all branch instructions will eliminate
the performance beneﬁt of the branch predictor (e.g., up to
10x slowdown [55]). Therefore, multiple proposals tried to
reduce the number of serialization points introduced using
static analysis to identify and serialize exploitable gadgets
only [33], [34], [49], [74]. However, these approaches miss
some of the gadgets that can be exploited [44]. Another
weakness of these defenses is that even though they stop
speculative execution around exploitable gadgets, they do not
stop speculative code fetches and other micro-architectural
behaviors before execution (e.g., instruction cache and iTLB
ﬁlls) which can also leak data [64].
Speculative Load Hardening (SLH) [19] and You Shall
Not Bypass (YSNB) [55] try to reduce the high overhead by
identifying Spectre gadgets, then injecting artiﬁcial dependen-
cies between branches and these identiﬁed gadgets. Although
this results in performance advantages over liberal fencing,
they still have 36%-60% performance overhead [67]. Context-
Sensitive Fencing (CSF) [67] is a micro-code mitigation tech-
nique where serialization instructions are added dynamically
based on run-time conditions that identify potential exploit ex-
ecution. Although CSF focuses primarily on Spectre-PHT, the
authors propose to defend against Spectre-BTB and Spectre-
RSB using a special fence that would ﬂush the BTB/RSB when
transferring control to higher domains. However, ﬂushing BTB
and RSB hurts performance since it results in mis-predictions.
In addition, in a simultaneous multithreading (SMT) processor,
ﬂushing the BTB/RSB after control transfer is not enough to
protect against Spectre-BTB and Spectre-RSB since structures
can be polluted after a control transfer using other threads.
B. Spectre-BTB and Spectre-RSB Defenses
Spectre-BTB exploits the BTB and Spectre-RSB exploit the
RSB to perform the attack. Google proposed Return Trampo-
line (retpoline) [69] as a software mitigation technique that
defends against Spectre-BTB by replacing indirect branches
with push+return instruction sequences that prevent BTB poi-
soning. However, this solution has high performance overhead
since it stops speculation (similar to serialization). In addition,
it can be bypassed using ret instructions since they cause
mis-speculation through the BTB in some processors (e.g.,
Intel’s core i7 processors starting from Skylake). In particular,
Authorized licensed use limited to: University of New South Wales. Downloaded on October 18,2020 at 09:22:13 UTC from IEEE Xplore.  Restrictions apply. 
50
those processors predict the address of a ret instruction from
the BTB when the RSB is empty (which can be forced by
executing unmatched returns). To solve this exploit, RSB
stufﬁng [35] was proposed to intentionally ﬁll the RSB with
the address of a benign delay gadget to avoid misspeculation
on context switches. Although this technique can partially
mitigate Spectre-BTB (when using ret to trigger speculation
through BTB), it can also defend against SpectreRSB cross-
domains attack. However, since we are ﬁlling the RSB on
context switch, stored entries for the currently running process
will be lost when execution is switched back to the current
process (i.e. performance loss due to losing speculation infor-
mation). In contrast, SPECCFI saves committed RSB entries
per process in case of a context switch out of the process
and restores them when execution returns to the process,
which results in improving the prediction performance of ret
instructions.
Intel and AMD added new instructions to their instruction
set architecture (ISA) that can control indirect branches to
defend against Spectre-BTB [6], [36]. The addition consists
of three controls:
• Indirect Branch Restricted Speculation (IBRS): allows
processors to enter IBRS mode (privileged mode) and
execute indirect branches that are not inﬂuenced by less
privileged mode.
• Single Thread Indirect Branch Prediction (STIBP): will
not allow a hyperthread running on a core to use branch
predictor entries inserted by the other thread running on
the same core.
• The Indirect Branch Predictor Barrier (IBPB): allows
processors to ﬂush BTB and clear their state. This way,
the code executed before the barrier cannot impact branch
prediction of the code executed after this instruction.
These new ISA instructions defend only against Spectre-
BTB. In addition, they have a high performance overhead; up
to 24% on Skylake and up to 53% on Haswell [23].
C. Spectre All Variants Defenses
Several mitigations were proposed to defend against all
variants of Spectre. Dynamically Allocated Way Guard
(DAWG) [25], [41] was proposed to provide isolation between
protection domains by partitioning the cache at the cache
way granularity. Although this method can prevent leakage
of the data through a cache side-channel, it requires domains
enforcement management in the software, defending cache as
leakage source only, and it can not protect against attacks
that are performed within the same address space or isolation
domain. In addition, since it is a cache speciﬁc defense, other
micro-architectural structures can be used for communication
(e.g. branch predictor).
SafeSpec [40] and InvisiSpec [77] are hardware mitigation
techniques that are similar to DAWG in the way that they are
both trying to prevent side-channel communication from spec-
ulative instructions. Therefore, they propose to mitigate the
side-effect of speculative execution on the micro-architectural
state; shadow micro-architectural structures for caches and
51
Translation Lookaside Buffers (TLBs) were added to store
transient effect of speculative instructions. These effects will
be committed to caches and TLBs only when speculation
is deemed correct and ﬂush the changes from the shadow
structures otherwise. Although these solutions outperform soft-
ware solutions, they require making disruptive changes to the
processor/memory architecture and consistency models.
ConTExT [63] introduced protection for secret data from
speculative execution. Speciﬁcally, the technique introduces a
new memory mapping (called non-transient mapping) which
tracks data that must not be accessed by speculative instruc-
tions. Nevertheless, this solution requires changes to the archi-
tecture and the operating system, and developer involvement
to annotate the secret data. It also incurs high performance
overhead for security-critical applications.
IX. CONCLUDING REMARKS
In this paper, we presented a new defense that protects
speculative processors against misspeculation targeting the
branch target buffer (BTB) and the return stack buffer (RSB).