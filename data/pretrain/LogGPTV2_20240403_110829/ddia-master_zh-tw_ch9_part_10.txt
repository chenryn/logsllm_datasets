>
> 答案是 FLP 结果是在 **非同步系统模型** 中被证明的（请参阅 “[系统模型与现实](ch8.md#系统模型与现实)”），而这是一种限制性很强的模型，它假定确定性演算法不能使用任何时钟或超时。如果允许演算法使用 **超时** 或其他方法来识别可疑的崩溃节点（即使怀疑有时是错误的），则共识变为一个可解的问题【67】。即使仅仅允许演算法使用随机数，也足以绕过这个不可能的结果【69】。
>
> 因此，虽然 FLP 是关于共识不可能性的重要理论结果，但现实中的分散式系统通常是可以达成共识的。
在本节中，我们将首先更详细地研究 **原子提交** 问题。具体来说，我们将讨论 **两阶段提交（2PC, two-phase commit）** 演算法，这是解决原子提交问题最常见的办法，并在各种资料库、讯息伫列和应用伺服器中被实现。事实证明 2PC 是一种共识演算法，但不是一个非常好的共识演算法【70,71】。
透过对 2PC 的学习，我们将继续努力实现更好的一致性演算法，比如 ZooKeeper（Zab）和 etcd（Raft）中使用的演算法。
### 原子提交与两阶段提交
在 [第七章](ch7.md) 中我们了解到，事务原子性的目的是在多次写操作中途出错的情况下，提供一种简单的语义。事务的结果要么是成功提交，在这种情况下，事务的所有写入都是持久化的；要么是中止，在这种情况下，事务的所有写入都被回滚（即撤消或丢弃）。
原子性可以防止失败的事务搅乱资料库，避免资料库陷入半成品结果和半更新状态。这对于多物件事务（请参阅 “[单物件和多物件操作](ch7.md#单物件和多物件操作)”）和维护次级索引的资料库尤其重要。每个次级索引都是与主资料相分离的资料结构 —— 因此，如果你修改了一些资料，则还需要在次级索引中进行相应的更改。原子性确保次级索引与主资料保持一致（如果索引与主资料不一致，就没什么用了）。
#### 从单节点到分散式原子提交
对于在单个数据库节点执行的事务，原子性通常由储存引擎实现。当客户端请求资料库节点提交事务时，资料库将使事务的写入持久化（通常在预写式日志中，请参阅 “[让 B 树更可靠](ch3.md#让B树更可靠)”），然后将提交记录追加到磁碟中的日志里。如果资料库在这个过程中间崩溃，当节点重启时，事务会从日志中恢复：如果提交记录在崩溃之前成功地写入磁碟，则认为事务被提交；否则来自该事务的任何写入都被回滚。
因此，在单个节点上，事务的提交主要取决于资料持久化落盘的 **顺序**：首先是资料，然后是提交记录【72】。事务提交或终止的关键决定时刻是磁碟完成写入提交记录的时刻：在此之前，仍有可能中止（由于崩溃），但在此之后，事务已经提交（即使资料库崩溃）。因此，是单一的装置（连线到单个磁碟的控制器，且挂载在单台机器上）使得提交具有原子性。
但是，如果一个事务中涉及多个节点呢？例如，你也许在分割槽资料库中会有一个多物件事务，或者是一个按关键词分割槽的次级索引（其中索引条目可能位于与主资料不同的节点上；请参阅 “[分割槽与次级索引](ch6.md#分割槽与次级索引)”）。大多数 “NoSQL” 分散式资料储存不支援这种分散式事务，但是很多关系型资料库丛集支援（请参阅 “[实践中的分散式事务](#实践中的分散式事务)”）。
在这些情况下，仅向所有节点发送提交请求并独立提交每个节点的事务是不够的。这样很容易发生违反原子性的情况：提交在某些节点上成功，而在其他节点上失败：
* 某些节点可能会检测到违反约束或冲突，因此需要中止，而其他节点则可以成功进行提交。
* 某些提交请求可能在网路中丢失，最终由于超时而中止，而其他提交请求则透过。
* 在提交记录完全写入之前，某些节点可能会崩溃，并在恢复时回滚，而其他节点则成功提交。
如果某些节点提交了事务，但其他节点却放弃了这些事务，那么这些节点就会彼此不一致（如 [图 7-3](../img/fig7-3.png) 所示）。而且一旦在某个节点上提交了一个事务，如果事后发现它在其它节点上被中止了，它是无法撤回的。出于这个原因，一旦确定事务中的所有其他节点也将提交，节点就必须进行提交。
事务提交必须是不可撤销的 —— 事务提交之后，你不能改变主意，并追溯性地中止事务。这个规则的原因是，一旦资料被提交，其结果就对其他事务可见，因此其他客户端可能会开始依赖这些资料。这个原则构成了 **读已提交** 隔离等级的基础，在 “[读已提交](ch7.md#读已提交)” 一节中讨论了这个问题。如果一个事务在提交后被允许中止，所有那些读取了 **已提交却又被追溯宣告不存在资料** 的事务也必须回滚。
（提交事务的结果有可能透过事后执行另一个补偿事务（compensating transaction）来取消【73,74】，但从资料库的角度来看，这是一个单独的事务，因此任何关于跨事务正确性的保证都是应用自己的问题。）
#### 两阶段提交简介
**两阶段提交（two-phase commit）** 是一种用于实现跨多个节点的原子事务提交的演算法，即确保所有节点提交或所有节点中止。它是分散式资料库中的经典演算法【13,35,75】。2PC 在某些资料库内部使用，也以 **XA 事务** 的形式对应用可用【76,77】（例如 Java Transaction API 支援）或以 SOAP Web 服务的 `WS-AtomicTransaction` 形式提供给应用【78,79】。
[图 9-9](../img/fig9-9.png) 说明了 2PC 的基本流程。2PC 中的提交 / 中止过程分为两个阶段（因此而得名），而不是单节点事务中的单个提交请求。
![](../img/fig9-9.png)
**图 9-9 两阶段提交（2PC）的成功执行**
> #### 不要把2PC和2PL搞混了
>
> 两阶段提交（2PC）和两阶段锁定（请参阅 “[两阶段锁定](ch7.md#两阶段锁定)”）是两个完全不同的东西。2PC 在分散式资料库中提供原子提交，而 2PL 提供可序列化的隔离等级。为了避免混淆，最好把它们看作完全独立的概念，并忽略名称中不幸的相似性。
2PC 使用一个通常不会出现在单节点事务中的新元件：**协调者**（coordinator，也称为 **事务管理器**，即 transaction manager）。协调者通常在请求事务的相同应用程序中以库的形式实现（例如，嵌入在 Java EE 容器中），但也可以是单独的程序或服务。这种协调者的例子包括 Narayana、JOTM、BTM 或 MSDTC。
正常情况下，2PC 事务以应用在多个数据库节点上读写资料开始。我们称这些资料库节点为 **参与者（participants）**。当应用准备提交时，协调者开始阶段 1 ：它传送一个 **准备（prepare）** 请求到每个节点，询问它们是否能够提交。然后协调者会跟踪参与者的响应：
* 如果所有参与者都回答 “是”，表示它们已经准备好提交，那么协调者在阶段 2 发出 **提交（commit）** 请求，然后提交真正发生。
* 如果任意一个参与者回复了 “否”，则协调者在阶段 2 中向所有节点发送 **中止（abort）** 请求。
这个过程有点像西方传统婚姻仪式：司仪分别询问新娘和新郎是否要结婚，通常是从两方都收到 “我愿意” 的答复。收到两者的回复后，司仪宣布这对情侣成为夫妻：事务就提交了，这一幸福事实会广播至所有的参与者中。如果新娘与新郎之一没有回复 “我愿意”，婚礼就会中止【73】。
#### 系统承诺
这个简短的描述可能并没有说清楚为什么两阶段提交保证了原子性，而跨多个节点的一阶段提交却没有。在两阶段提交的情况下，准备请求和提交请求当然也可以轻易丢失。2PC 又有什么不同呢？