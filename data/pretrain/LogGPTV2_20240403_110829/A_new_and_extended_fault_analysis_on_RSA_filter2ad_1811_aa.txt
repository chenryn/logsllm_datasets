title:A new and extended fault analysis on RSA
author:Cai-Sen Chen and
Tao Wang
A New and Extended Fault Analysis on RSA(cid:3)
Engineering,Mechanical Engineering College
Engineering,Mechanical Engineering College
Caisen Chen
Department of Computer
Shijiazhuang,China
PI:EMAIL
Tao Wang
Department of Computer
Shijiazhuang,China
PI:EMAIL
ABSTRACT
As the preceding fault analysis on RSA Square-and-Multiple
implementation which is based on modifying the public mod-
ulus N , is di(cid:14)cult to be executed in practice. This paper
proposes a new method to execute fault analysis by regu-
lating the voltage supply of the system to inject transient
faults into multiplication operation instead of modifying the
modulus N .
In order to improve the feasibility of attack,
we suggest an extension of fault analysis with recovering the
key segment by segment instead of bit by bit. In the end,
the complexity of the algorithm is analyzed. The expansibil-
ity and feasibility of algorithm are proved by demonstrating
in theory and simulation experiments. The results of exper-
iment show that the new fault analysis algorithm is more
e(cid:11)ective in practice.
Categories and Subject Descriptors
E.3 [DATA ENCRYPTION]: Public key cryptosystems;
K.6.5 [Security and Protection]: Physical security
General Terms
Security, Algorithms, Experimentation
Keywords
Side Channel Attack, Fault Analysis, Square-and-Multiple
Algorithm, Fixed-Windows Exponentiation
1.
INTRODUCTION
The side channel attack(SCA) was (cid:12)rst proposed by Paul
Kocher in 1996[6]. This attack amplify and evaluate leaked
information with the help of statistical methods, and is often
(cid:3)
This research was supported by the National Natural Sci-
ence Foundation of China under Grant No. 60772082; the
Natural Science Foundation of Hebei Province under Grant
No. 08M010.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIACCS ’11, March 22–24, 2011, Hong Kong, China.
Copyright 2011 ACM 978-1-4503-0564-8/11/03 ...$10.00.
much more powerful than classical cryptanalysis. Fault anal-
ysis is one of the most powerful ways in SCA to recover secret
key, which was (cid:12)rst proposed by Boneh et al[3],who applied
fault analysis application on smart card with RSA-CRT suc-
cessfully. And then, Di(cid:11)erential Fault Analysis (DFA) was
published by Biham and Shamir with application to secret
key cryptosystems[2]. Arjen Lenstra proposed an improved
method, only using the faulty signature and plaintext[7].
These attacks are based on modifying the behavior of an ex-
ecution, however, the di(cid:14)culty are growing more and more
popular in the last decade, as the countermeasures are more
e(cid:11)ective.
The core of RSA is mainly modular exponentiation which
can be realized through some algorithms, including Square-
and-Multiply algorithm, Chinese Remainder Theorem, Fixed-
Windows exponentiation (FWE) and so on. Most fault at-
tacks on RSA concentrate on the Chinese Remainder The-
orem implementation. However, because the Square-and-
Multiply algorithm can be realized easily, it is popularly
used in hardware, such as smartcard, FPGA and micro-
processor. A few other attacks on RSA which do not use
speed-up technique have been published. The (cid:12)rst one deal-
ing with the perturbation of public elements was consid-
ered as a real threat when JP.Seifert published an attack on
the RSA signature check mechanism[11]. He (cid:12)rst mentioned
the possibility of modifying the public modulus N . Then,
E.Brier et al. extended this work to the full recovery of the
private exponent d for various RSA implementations[4]. In
FDTC 2008, Jorn-Marc Schmidt et al proposed a practi-
cal fault analysis on Square-and-Multiply by modifying the
modulus during the exponentiation[10]. Then in RSA 2009,
Alexandre Berzati extended this work, proving that the RSA
Left-To-Right implementations were also vulnerable to fault
analysis[1]. Recently, Andrea Pellegrini proved that a sin-
gle bit error in one multiplication result is enough to fully
compromise the key of RSA FWE implementation[9]. Nev-
ertheless, these attacks require a quite precise fault injection
like a bit (cid:13)ip or target a special operation without any pos-
sibility to check if the fault is injected in the intended way.
This paper also focuses on the fault analysis against square-
and-multiply algorithm. But we inject random fault into the
multiplication operation during the exponentiation, instead
of modifying the modulus N , we propose a new fault anal-
ysis algorithm on RSA Left-to-Right implementation. Fur-
thermore, we extend this attack to the FWE implementation
used in the popular OpenSSL library. The extension of fault
analysis can recover the key segment by segment instead of
bit by bit. The expansibility and feasibility of algorithm are
466
proved by demonstrating in theory and simulation experi-
ments, the complexity of algorithm is analyzed. Our results
in this study will also be bene(cid:12)cial to the analysis of the
same type of other public cryptography.
This paper is organized as follows: RSA algorithm and the
base fault attack model are introduced in Section 2, followed
by presentation of our analysis algorithm and the extension
of attack on RSA in Section 3. Section 4 shows the exper-
iment results and analysis of complexity, and discusses the
analysis method. Finally section 5 concludes the paper.
2. RSA AND FAULT ATTACK MODEL
2.1 RSA Algorithm
RSA is still the most widely used signature scheme in
practical applications, which requires a suitable pair of pub-
lic key (N; e) and private key (N; d). Encryption is exe-
cuted using e with the following computation: C = me
(mod N ), corresponding decryption with computation: m =
C d (mod N ). The core of these computations is modular
exponentiation which can be realized using square and mul-
tiply algorithm, including "Left-to-Right"(LRE) and "Right-
to-Left"(RLE) modular exponentiation algorithms. In LRE
algorithm, let d = (dn−1; dn−2; : : : ; d1; d0)2, if dk = 1, it
takes an additional operation of S = S (cid:1) m (mod N ), so we
can get the signature S = (: : : ((m2 (cid:1) mdn(cid:0)2 )2 (cid:1) mdn(cid:0)3 )2 : : : (cid:1)
md0 (mod N ) = m
n(cid:0)1
i=0 2i·di (mod N ).
∑
The RSA-CRT algorithm has been proved that it is vul-
nerable to fault analysis[12], so OpenSSL library has taken
some countermeasures to defend this attack[8].
It checks
the correctness of the result, by verifying it with the public
key when computing RSA private key signatures using CRT-
based algorithm. If a mismatch is observed, it resorts to the
more time consuming "Left-to-Right" algorithm. And the
FWE algorithm used in OpenSSL (v 0.9.8i) is guaranteed to
compute the modular exponentiation function in constant
time. It is described as follows.
Algorithm 1 FWE algorithm
Input: m; N; and d = (dn−1; dn−2; : : : ; d1; d0)2; win size
Output: S = md (mod N )
1: win num = bits(d)=win size
2:S = 1
3:For k from win num (cid:0) 1 to 0 dof
3.1:For(i = 0; i  671,
win size=6, when bit size(d) > 239,win size=5. More-
over, to ensure a constant execution time, independent from
the special values of exponent d, all the powers of m from
∏
0 to 2win size (cid:0) 1 are precomputed and stored aside in a ta-
ble. S = (: : : ((md[k−1])2w (cid:1) md[k−2])2w
: : : (cid:1) md0 (mod N ) =
(mod N ), where k is the win num.
k−1
i−0 md[i]2iw
2.2 Fault Attack Model
467
Figure 1: Fault Attack Model on RSA Square-and-
Multiply implementation.
Some di(cid:11)erent fault attacks published in literature di(cid:11)er
in the fault location, time, the number of bits a(cid:11)ected, and
the e(cid:11)ect of attack (the fault type).
In addition to fault
injection, we must know how to get useful information from
the faulty result, so it is necessary to make a reasonable
fault attack model which associates fault with private key
information. There are three types of fault: transient fault,
permanent fault and destructive fault. We construct a fault
attack model against RSA Square-and-Multiply implemen-
tation as follows.
In Fig.1, the fault may occur at the four locations which
are tagged with broken line frames during the exponentia-
tion. Literature[10] and [1] have proposed the fault analysis
algorithm on RSA "Right-to-Left" and "Left-to-Right" im-
plementations respectively, their attack models are all based
on the assumption that the public modulus N is modi(cid:12)ed
during the execution. However, in this paper, we focus on
the fault analysis on the assumption that fault occurs in the
multiplier during the square or multiply operation.
3. FAULT ANALYSIS ON RSA BASED ON
THE FAULT IN MULTIPLIER
3.1 Fault Injection
To make this attack possible, faults with the described
characteristics must be injected into the attacked target. For
this purpose, we exploit a circuit-level vulnerability common
in microprocessor design:
in order to develop high perfor-
mance, the multipliers of microprocessor are designed using
short critical path delays[5]. However, if environmental con-
ditions, such as high temperatures or voltage manipulation,
slow down the signal propagation, it is possible that signals
through the critical path do not reach their corresponding
registers before the next clock cycle begins. That could re-
sult in the faulty output of the multiplier.
In order to simplify our attack, we only focus on the fault
injection which a(cid:11)ects a single bit of the output of multipli-
cation operation. On the assumption that the cryptosystem
is injected with a sequence of fault by changing the supply
voltage manipulation using programmable power supply.
According to the attack model, we suppose that a tran-
sient fault has occurred at jth step before the end of the
exponentiation, during the computation of a square or a
multiply, since the error manifests as a single-bit (cid:13)ip, the
corrupted result will be modi(cid:12)ed by (cid:6)2f , where f is the
position of the bit (cid:13)ipped in the partial result, that is, the lo-
cation of the corrupted bit is in the range of 0 (cid:20) f < bits(d).
The transition induced by the (cid:13)ip decides whether the er-
ror amount is added or subtracted. When the fault occurs
CryptographicDevicemSS = S*S mod NS =  S*m mod NFault injectionSat jth steps before the end of the exponentiation, the out-
put result of the multiplier is supposed to be a transient (cid:13)ip
bit modi(cid:12)cation. The corrupted signature (cid:22)S is generated as
follows (following, the (mod N ) notation is omitted):
) (cid:1) mdj (cid:6) 2f )2j (cid:1) j−1∏
mdi2i
(1)
(cid:22)S = ((
mdi2(i(cid:0)j)
i=j+1
i=0
And the corrupted signature (cid:22)S for the modi(cid:12)cation of the
output of the jth squaring operation is generated as follow:
) (cid:6) 2f ) (cid:1) mdj )2j (cid:1) j−1∏
mdi2i
(2)
(cid:22)S = (((
mdi2(i(cid:0)j)
i=j+1
i=0
n−1∏
n−1∏
Figure 2: The (cid:13)ow of the private key recovery.
k−1∏
k−1∏
For the fault injection to Algorithm 2 (FWE), if a single-
bit (cid:13)ip fault occurs during the pth square operation in the
computation for the ith window of the exponent d, the cor-
rupted signature (cid:22)S is generated as follow:
)(cid:1)md[j]2p(cid:6)2f )2jw(cid:0)p(cid:1)j−1∏
(cid:22)S = ((
md[i]2(i(cid:0)j)w
i=j+1
i=0
If the fault was injected at the jth window of the expo-
nent d, during the multiplying operation instead of square
operation, the corrupted signature (cid:22)S will have the following
form:
) (cid:1) md[j] (cid:6) 2f )2jw (cid:1) j−1∏
md[i]2iw
(4)
(cid:22)S = (((
md[i]2(i(cid:0)j)w
i=j+1
i=0
3.2 Analysis Algorithm of Key
We analyze the situation of Eq.(1), the other three situa-
tions can be analyzed in the same way. From both correct
signature S and faulty one (cid:22)S which was obtained from the
same message m, we try to recover the value of dj on the
assumption that the top n(cid:0) j + 1 bits of d have been recov-
ered. Supposing that we can control the time, location and
length of the fault, by a bit-(cid:13)ip fault, we could recover the
value of dj as follows.
∏
Both sides of Eq.(1) are multiplied by
n−1
i=j mdi2i
) (cid:1) mdj (cid:6) 2f )2j (cid:1) S
:
(5)
mdi2i
= ((
mdi2(i(cid:0)j)
If the correct signature is not known, we raise both sides
of Eq.(5) to the public exponent e and obtain:
mdi2i
)e = ((
mdi2(i(cid:0)j)
) (cid:1) mdj (cid:6) 2f )e2j (cid:1) m (6)
As we have known the top n (cid:0) j + 1 bits of d, and the
fault location f can assume any value in 0 (cid:20) f < bits(d), we
can (cid:12)nd dj which satis(cid:12)es Eq.(6) by using exhaustive search
for f . Then, the other subsequent secret key bits will be
found by repeating this attack using the knowledge of the
most signi(cid:12)cant bits of d already found and the parameter
of fault. Finally, the whole signature key can be recovered.
In the same way, we can apply a fault analysis on RSA
FWE implementation with the similar analysis algorithm.
(cid:22)S (cid:1) n−1∏
( (cid:22)S (cid:1) n−1∏
i=j
i=j
n−1∏
i=j+1
n−1∏
i=j+1
md[i]2iw