ful authentication trace, obtaining nC, aC and aT .
2. then, she writes 0x0000 on memory block 9 which
contains key bits k80 . . . k95.
3. The adversary then increments the observed nC
value and attempts an authentication for each
nC + inc (mod 256), where 0 ≤ inc < 216.
4. Repeating step 3) at most 216 times, the transponder
will accept one aC value for a particular increment
value inc and give an answer. Then A knows that
k80 . . . k95 = inc.
5. The adversary proceeds similarly for blocks 8 and
7. At this point the adversary has recovered key bits
k48 . . . k95.
6. Next, the adversary guesses 15 key bits k33 . . . k47.
7. Having k33 . . . k95 the adversary is now able to ini-
tialize the cipher, obtain the initial state s0 and run
it forward up to state s7. At this point the adversary
has 215 candidates for state s7.
8. For each of these candidates, she runs the cipher for-
ward 33 steps up to state s40. While running the
cipher forward the adversary is able to determine
input bits k32 . . . k0 by comparing the output bits to
aC and aT from the trace.
9. Then, forward each candidate state at s40 to s55 and
produce another 15 output bits to test on, although
this time, with the known input of 15 zero bits. On
average only one candidate survives this test. The
adversary has now recovered the complete key.
Attack complexity This attack requires only one suc-
cessful authentication trace. In total, we need to write
three times on the memory of the transponder and per-
form 3 × 216 authentications with the transponder. This
can be done within 30 minutes using a Proxmark III. The
computational complexity of the last three steps is 215
encryptions which takes less than a second on a laptop.
USENIX Association  
22nd USENIX Security Symposium  713
11
7 Weak-Key Attack
During our experiments we executed the previous attack
on several cars of different make and model. Many of the
keys we recovered were of the form k0 = · · · = k31 = 0
and more or less random looking bits for k32 . . . k96 (al-
though we have found keys where only ten of the 96 bits
were ones). In the remainder of this paper we call such a
key weak. Figure 9 shows some examples of weak keys
we found during our experiments (on the vehicles indi-
cated in Figure 2). To avoid naming concrete car models
we use A, B,C . . . to represent car makes. We write num-
bers X.1, X.2, X.3 . . . to represent different car models of
make X .
Car
A.1
A.2
B.1
Secret key
00000000d8 b3967c5a3c3b29
00000000d9 b79d7a5b3c3b28
0000000000 00010405050905
Figure 9: Recovered keys from our own cars. Besides
the evident 32 leading zero bits, every second nibble
seems to encode a manufacturer dependant value, which
further reduces the entropy of the key.
Apparently, the automotive industry has decided to use
only 64 bits of the secret key, probably due to compati-
bility issues with legacy immobilizer systems. If a Meg-
amos Crypto transponder uses such a weak key it is pos-
sible to recover this key quickly, even when the memory
of the transponder is locked with a PIN code. To be con-
crete, a weak secret key with the bits k0 . . . k31 ﬁxed by
the car manufacturer allows an adversary know the input
bits of the cipher states s8 . . . s55.
With known input to the cipher at states s8 . . . s55, it
is possible to pre-compute and sort on a 47 contiguous
output bits for each internal state at s8. However, such a
table with 256 entries requires a huge amount of storage.
There are many time-memory tradeoff methods proposed
in the literature over the last decades [2–5, 10, 33, 34, 49].
For example, a rainbow table shrinks the storage signiﬁ-
cantly, while requiring only a modest amount of compu-
tation for a lookup.
Concretely, in order to mount such an attack, an ad-
versary A proceeds as follows.
1. Pre-computation: only once, the adversary com-
putes the following rainbow table.
First, she
chooses n random permutations R0 . . . Rn−1 of
2 → F56
F56
2 which she uses as reduction functions
(colors). To compute a chain, the intermediate states
are generated by
si+1 = R j(output(si, 056)).
12
The chain begins with the ﬁrst reduction function
R0. When a distinguished point (i.e., a state with a
speciﬁc pattern like a preﬁx of z zero bits) is reached
then the next reduction function R j+1 is used, in or-
der to prevent chain merges. The chain is completed
once a distinguished point is reached while using
the last reduction function Rn−1, see Figure 10. The
start and end values of each chain are stored in the
rainbow table which is sorted on end values.
R0(·)
sp0 !
...
R0(·)
spm !
R1(·)
d1 !
Rn−2(·)
· · · !
dn = ep0
Rn−1(·)
dn−1 !
...
R1(·)
d′
1 !
Rn−2(·)
· · · !
Rn−1(·)
d′
n−1 !
d′
n = epm
Figure 10: Construction of the rainbow table
2. As before A ﬁrst eavesdrops one authentication
trace between a legitimate transponder and an im-
Thus A learns the car nonce nC
mobilizer.
and 47 output bits o0 . . . o46 = output(s7, k32 . . . k5) ·
output(s35, k4 . . . k0 · 015).
3. For each value of u0 . . . u8 ∈ F9
2 and each reduction
function R j the adversary looks up o0 . . . o46u0 . . . u8
in the Rainbow table. In order to look up such a
value she sets it as a state and runs the chain until
the last distinguished point is reached at the last re-
duction function. Then, it performs n lookups in the
rainbow table (one for each reduction function) to
ﬁnd the corresponding end point ep.
4. When the end point is found then the correspond-
ing start point sp is used to ﬁnd the previous inter-
nal state which generates o0 . . . o46u0 . . . u8 as out-
put. Since we guessed the last 9 bits u0 . . . u8, we
should consider this as a candidate state.
5. Then, the adversary rolls back each of those states
seven steps, guessing the input k32 . . . k39. This pro-
duces 28 candidate states for s0. As before, for each
candidate s0 she undoes the initialization of the ci-
pher and recovers the remaining key bits k40 . . . k95.
These need to be tested with another trace.
6. If the test is passed then we have recovered the se-
cret key. Otherwise the next u0 . . . u8 should be con-
sidered at step 3).
Attack complexity This attack requires two success-
ful authentication traces. This attack allows for a trade-
off between memory and computational complexity. The
longer the chains the smaller the table gets but more com-
putation is needed for each lookup. Just to give an im-
pression of the feasibility of the attack we consider the
following conﬁguration. Take z to be 10 bits, therefore
our distinguished states have 10 zero bits followed by
714  22nd USENIX Security Symposium 
USENIX Association
2
other 46 bits. We also take 64 = 26 random permutations
R0 . . . R63. Then, following the computations of Oech-
slin [49], we get that the size of the rainbow table is
3 ≈ 237 entries of 12 bytes which is 1.5 TB. Regard-
(256)
ing its computational complexity, we need to compute
at step 3) 29 candidates for which we compute, for all
26 reduction functions and for all offsets, the end point.
Since a chain has length at most 216, this takes at most
29 × 26 × 26 × 216 = 237 encryptions. This can be com-
puted within a few minutes on a laptop.
For building the rainbow table (needed only once),
computation of the chains is sped up considerably by us-
ing FPGAs. Recently Kalenderi et. al. showed in [37]
that a single FPGA (similar to the ones used in the CO-
PACOBANA) computes chains 2824 times faster than a
single 3GHz processor. They computed rainbow tables
for the A5/1 cipher, which is reasonably similar to the
Megamos Crypto cipher. Although the internal state of
A5/1 is with 64 bits considerably larger than the 56 bits
of Megamos Crypto, they are both designed for hardware
implementation and both embed a non-linear component
that causes some internal states to merge. Their experi-
mental setup generates 345 chains for A5/1 in 830 mil-
liseconds, which is roughly 345
0.830 ≈ 415 chains per sec-
ond. If we compute an estimate with respect to the differ-
ence in complexity, the COPACOBANA with a 120 FPGA-
3 × 120 ≈ 218.3 chains per
array can compute 415 × (28)
second. That means it takes only 237−18.3 ≈ 218.7 sec-
onds, which is less than 5 days, to build the complete
rainbow table.
1
8 Practical considerations and mitigation
Our attacks require close range wireless communication
with both the immobilizer unit and the transponder. It is
not hard to imagine real-life situations like valet parking
or car rental where an adversary has access to both for
a period of time. It is also possible to foresee a setup
with two perpetrators, one interacting with the car and
one wirelessly pickpocketing the car key from the vic-
tims pocket.
As mitigating measure, car manufacturers should set
uniformly generated secret keys and for the devices
which are not locked yet, set PIN codes and write-lock
their memory after initialization. This obvious measures
would prevent a denial of service attack, our partial key-
update attack from Section 6 and our weak-key attack
from Section 7.
Car owners can protect their own vehicles against a
denial of service and the partial key-update attack, de-
scribed in Section 6. These attacks only work if the ad-
versary has write access to the memory of the transpon-
der, which means that the lock-bit l0 is set to zero. It
is possible for a user to test for this property with any
compatible RFID reader, like the Proxmark III, using
our communication library. If l0 = 0, then you should set
the lock-bit l0 to one. It is possible to set this bit with-
out knowing the secret key or the PIN code. When deal-
ing with the more recent version of the Megamos Crypto
transponder (EM4170), users should also update the PIN
code to a random bit-string before locking the transpon-
der.
On the positive side, our ﬁrst (cryptographic) attack
is more computationally intensive than the attacks from
Section 6 and 7 which makes it important to take the
aforementioned mitigating measures in order to prevent
the more inexpensive attacks. Unfortunately, our ﬁrst at-
tack is also hard to mitigate when the adversary has ac-
cess to the car and the transponder (e.g., Valet and car
rental). It seems infeasible to prevent an adversary from
gathering two authentication traces. Furthermore, this
attack exploits weaknesses in the core of the cipher’s
design (e.g., the size of the internal state).
It would
require a complete redesign of the cipher to ﬁx these
weaknesses. To that purpose, lightweight ciphers like
Grain [32], Present [7] and KATAN [15] have been pro-
posed in the literature and could be considered as suit-
able replacements for Megamos Crypto. Also, immobi-
lizer products implementing AES are currently available
in the market.
9 Conclusions
The implications of the attacks presented in this paper
are especially serious for those vehicles with keyless ig-
nition. At some point the mechanical key was removed
from the vehicle but the cryptographic mechanisms were
not strengthened to compensate.
We want to emphasize that it is important for the au-
tomotive industry to migrate from weak proprietary ci-
phers like this to community-reviewed ciphers such as
AES [14] and use it according to the guidelines. For a
few years already, there are contactless smart cards on
the market [48, 50] which implement AES and have a
fairly good pseudo-random number generator. It is sur-
prising that the automotive industry is reluctant to mi-
grate to such transponders considering the cost differ-
ence of a better chip (≤ 1 USD) in relation to the prices
of high-end car models (≥ 50, 000 USD). Since most car
keys are actually fairly big, the transponder design does
not really have to comply with the (legacy) constraints of
minimal size.
Following the principle of responsible disclosure, we
have notiﬁed the manufacturer of our ﬁndings back in
November 2012. Since then we have an open commu-
nication channel with them. We understand that mea-
sures have been taken to prevent the weak-key and partial
key-update attacks when the transponder was improperly
conﬁgured.
USENIX Association  
22nd USENIX Security Symposium  715
13
10 Acknowledgments
The authors would like to thank Bart Jacobs for his ﬁrm
support.
References
[1] Embedded avr microcontroller including rf trans-
mitter and immobilizer lf functionality for remote
keyless entry - ATA5795C. Product Datasheet,
November 2011. Atmel Corporation.
[2] AVOINE, G., JUNOD, P., AND OECHSLIN, P.
Characterization and improvement of time-memory
trade-off based on perfect tables. ACM Transac-
tions on Information and System Security (TISSEC
2008) 11, 4 (2008), 1–22.
[3] BABBAGE, S. A space/time tradeoff in exhaustive
search attacks on stream ciphers. In European Con-
vention on Security and Detection (1995), vol. 408
of Conference Publications, IEEE Computer Soci-
ety, pp. 161–166.
[4] BIRYUKOV, A., MUKHOPADHYAY, S., AND
SARKAR, P.
Improved time-memory trade-offs
with multiple data. In 13th International Workshop
on Selected Areas in Cryptography (SAC 2006)
(2006), vol. 3897 of Lecture Notes in Computer Sci-
ence, Springer-Verlag, pp. 110–127.
[5] BIRYUKOV, A., AND SHAMIR, A. Cryptanalytic
time/memory/data tradeoffs for stream ciphers. In
6th International Conference on the Theory and
Application of Cryptology and Information Secu-
rity, Advances in Cryptology (ASIACRYPT 2000)
(2000), vol. 1976 of Lecture Notes in Computer Sci-
ence, Springer-Verlag, pp. 1–13.
[6] BOGDANOV, A. Linear slide attacks on the KeeLoq
block cipher.
In 3rd International Conference on
Information Security and Cryptology (INSCRYPT
2007) (2007), vol. 4990 of Lecture Notes in Com-
puter Science, Springer, pp. 66–80.
[7] BOGDANOV, A., KNUDSEN, L. R., LEAN-