口
口
口
口
---
## Page 53
(2) traces(F+i(STOPA))
出L5，因此只要证明对所有n都有
证明
这里F（X)=（x:A→X)，我们要证明
X1回忆--下进程RUNA在1.1.3节X8中被定义为
然后，假设F是卫式，我们可定义
的解。首先，我们用归纳法定义函数F的选代式
一个递归定义的进程是方程
(1）对n=0
就可以了。这一步要对Ⅱ进行归纳。
3
对递归定义的进程来说，要找到其迹的集合就更困难些了。
举例
traees(STOP)={}
={t|t=<>V(to∈AAt'∈traces(F"(STOPA)))} L4
=traces(x:A→F'(STOPA))
V(ta∈BAt'∈traces(P(to))))
traces(F*(STOPA))={s|s∈A*A#s≤n}
F+1(X)=F(F*(X))
F"(X) = X
traces(RUN)= A*
μX:A.F(X)
={s|sEA*A#s≤0}
=F(.·.(F(F(X)))..)
=F*(F(X))
X = F(X)
F和F*+1的定义
---
## Page 54
内。这三个事实我们用法则正式给出。
时刻为止的一个迹。最后，发生的每一事件一定在进程的字母表
（s^t）是进程到某一时刻的迹，则&一定是这个进程到前面某--
到它开始执行第一个事件那--时刻为止的迹。更进一步说，如果
程P到某一时刻为止已执行过的亨件。由此得出<>是每个进程
再由L5即得结论。
(2) traces(coin-→choc-→F(STOP))
(1)traces(STOP)={} ={s|s≤}
这里 F(X)=(coin→choe→X)
证明
X2我们要证1.8节中的X4，即证
在1.5节中，我们说迹是一个符号序列，这个序列记录了进
stEtraces(P)→s∈traces(P)
<>∈traces(P)
归纳假设为
={s|s≤+1}
={ss=<>Vs=
={<>,}U{t|t≤}
={<>,}U{^
V3t,s=^tAt≤"}
|t∈traces(F"(STOP)))
traces(F*(VMS))= {t|t≤"}
={t|t∈A*A#t≤n+1}
{+u#V((.V)A<>=}=
={t|t=<>V（t∈AA（t'∈A*A#t'≤n))}归纳假设
1.6.1L6
1.6.4节L4
归纳假设
#的特性
口
L2
---
## Page 55
个迹。则通过函数
1.8.2
方便且实用的数学表示式，在该类树形图中由-·个节点不会引出
条路径。这样，满足L6和L7的迹的集合就成了一类树形图的
径，更形式的叙逃为上述L7。客迹定义了由树根到其本身的空路
节点沿途遇到的标记的序列。譬如，在图1.1中所示的VMC树形
两个标记相同的分支。
所以进程的每个迹也就唯一地确定了由树根到某--具体节点的
任何节点来说，进程走到该节点时刻行为的迹就是它从树根到该
L8 
32
假设进程已被当作LISP 函数P实施了，且&为此进程的一
反之，因为从每个节点引出的分支都用不同事件做了标记，
进程的迹和进程行为的树状示意图是紧密相关的，对树上的
很显然，树上一条路径的所有初始子路径还是这棵树上的路
traces(P)≤(aP)*
实施
large!
inlp
120
in2p
olp
图
inip
1.1
JWA
inlp
Q
inlp
inlp
11
1
Jmulf
Ainlp
一
---
## Page 56
执行完后，
是不会变动的，因此
色节点以下的子树就记为
树，子树的根就是用s所标记的路径的终点。因此，图1.1中黑
货机的主人决定自己吃第一块巧克力，则有
的行为。如果&不是P的一个迹，则(PIs)无意义。
L1 P{<>=P
是一个进程，这个进程表示P在执行完迹8所记录的所有动作后
1.8.3后继
其结果仍为一个函数，这个结果函数的结果还是个函数…。
才能把进程定义为一个无劣的客体，也就是说，进程是个面数，
节之后，就会终止。正是因为我们不对进程作无穷的探究，我们
由于是有限的，所以这个递归式在处理完进程P行为的有限前
X4
：为避免由VMCRED(1.1.3节X5,X6）可能引起的损失，售
以下儿项法则将说明算子/的含义。什么事部还没做的进程
在进程P的树形图上（如图1.1），（P/s)就表示一棵完整的子
如果s∈ traces(P)，财
举例
tstrace(s,P) = if s= NIL then true
(V MC /) =STOP
(VMS{) = VMS
(VMS /) = (choc-→VMS)
else if P(so) = "BLEEP then false
P的行为就跟Pis执行完后的行为完至·样，
(VMCRED) =VMS2
 Pis 
VMC /
（P中s的后继)
else istrace(s',P(so))
3
口
00
---
## Page 57
注意：如果在递归定义的进程里使用/，会使其失去卫式特性，
节中X2，1.1.3节中X3，1.1.3节中X2)，即
节中X3，1.1.4节中X2)，即
其它循环进程都是永远不停止动作的。
我们就称这个进程P是循环的。STOP 明显地是循环的；但任何
在任何情况下，进程P都能回到它的初始状态，
就够了。我们想得到的进程的另一个性质就是它的循环性：如果
证明
(PIs)的迹定义为
下面这条推论说明Kc>是前缀算子c→的逆运算。
L3 (x:B→P(x))/=P(c)
了，即
执行完单个事件：c后，进程的行为就要由这个初始选择来确定
L2 P/(s^t)=(P|s)/t
不会与初始状态相同了。
以后，choo和toffee总是同时可供选择；因此这些后续状态就
劈如，
X2
L4 traces(P/s)={t|s^t∈traces(P)}
L3A
34
要证明进程P永远不停止动作，只要能对所有s∈traces（P)
以下进程不是循环的，因为无法使它们回到初始状态（1.1.2
举例
(c→P)/=P
在（choc→VMCT)的初始状态下，只能拿到巧党力，但是
(coin-→VMS), (choc-→VMCT),
RUNA:
Vs:traces(P).3t.(P{(s^t)=P)
VMS, (choe-VMS), VMCT, CT,
P/s+STOP
(around→CT,)
要求 sE traces(P)
即
要求C∈B
口
---
## Page 58
这里f（A)={f(x)x∈A}。我们举-个最简单的反例，有这样
但下逑法则看上去很“显然”，却不是一壳成立的
标星号的函数很显然是服从分配律的，因而也是严格的，故有
列。例如，设double 为一-函数，使其整数白变量增为两倍，则
1.9.1符号变换
看，在以后章节中用到这些运算时，我们还会注明出处的。
由于这个原因，我们在递归进程的定义中不使用算子/。
证明(a→((a-→P) /))=(a-→P)
的进程郡是它的解，其中P可为任一进程。
不是卫式，作何形式为
并出此导致递归方程有多解。例如
L5#f*（s)=#
另有明显的法则
.4
L1
出一个山1A*至B*的新函数f*，即用f分别作用于A*中符号
f*(s)=
f*()=
f*(<>)=<>
假设两数为集合A到集合B的符号映象。由”我们还可导
f*(s*t）=f*(s)^f*(t)
这节主要讲诚一下迹的其它运算。这部分目 前可以跳过不
double*()=
f*(s A)=f*(s) f(A)
1.9迹的其它运算
X=(a→(X))
Q-+P
若s≠<>
根据L3A
---
## Page 59
就是由和u穿插而构成，这里
1.9.3穿插
这个算子有分配律
一个函数f，满足
替地为序列和u的子序列，我们就说&是和Ⅱ的穿插。例如
L1
所有元素按原序连接起来的结果记为^1s，例如
1.8.2连接
L6f*(sA)=f*(s)f(A)
即有
然而，
这里b≠，
L3
36
如果一序列s可被拆成一系列的子序列，并且这些子序列交
{<>=<>
设s为一序列，这个序列的每个元素本身还是一序列。则将
f*(↑{c})=f*(<>)
穿插算子的递归定义可由下述法则给出
(11v)v(s/v)=（vs)!v
=s
当函数了是1-1对应（单射）函数时，这项法则是成立的，
^/,<>,>=^<>
，于是有
1=,
=f*() {f({e})
={o}
+<>
=<>
8=
f(b)= f(c)=c
=
当为单射函数时
由于f(c)=c
L1
---
## Page 60
素对挑选出来，然后用各自的第二个元素取代这些元素对，所得
1.9.6
L5s[]=s[#s-i-1]
是，&。是序列s的最后一个元素，且一般有
遵置的其它性质我们留给读者去推导。还有一个很有用的事实
逆置还具备几个简单的代数性质，包括
13=1
1 <>=
逆置的完整定义由以下法则给出
来。例如
1.9.5逆置
1.9.4 下标
L4&=S
7
5
第；个元素，其定义见L1。