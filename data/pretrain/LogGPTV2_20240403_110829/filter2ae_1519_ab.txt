imgdecrypt比较有趣，他会根据自身文件名来判断执行镜像的解密或加密操作。
在 **decrypt_firmare** 函数头部，首先会将 **0123456789ABCDEF** 字符串写入到栈中。
随后调用 **sub_40266C** 函数计算用于解密镜像的key。
通过对在 **sub_40266C** 函数进行分析后，可以发现改函数主要从地址 **0x403010**
处开始获取用于aes解密的key，iv等一系列的数据。随后调用 **decryptData** 函数进行解密。
**0x403010** 地址处的数据如下图所示，成功利用下列数据解密后的key为 **C05FBF1936C99429CE2A0781F08D6AD8**
。
后续的代码会将计算完的key在终端进行打印。
打印出的key和aes解密结算的结果与之前计算的一致。
随后程序会调用 **verify_image** 对镜像进行解密操作，相关的参数如下图所示。
**verify_image** 函数首先会判断镜像的头部是否为SHRS。
通过对 **verify_image** 头部的代码进行分析后发现，该函数首先会判断image头部的magic是否为SHRS，
随后从镜像中的第8~12个字节读取用于解密数据的长度字段，接着在镜像文件偏移量0x6dc开始获取加密的数据内容进行sha512校验，将结果与镜像偏移量0x9C处的sha512值进行比对。
镜像头部的部分结构如下图所示。
在 **0x9C** 处存储了加密数据的sha512校验值。
在 **0x5C** 处存储了原始数据的sha512校验值。
当加密数据的SHA512值校验通过后，将会对加密数据调用 **decryptData** 进行解密， **decryptData** 函数的参数如下图所示。
**decryptData** 函数调用的参数值如下。
解密完成后，将会计算解密后数据的SHA512值并从镜像 **0x5C** 处读取SHA512值并进行校验。
在完成了全部的校验值计算后会调用 **verifyMD** 对解密和加密的数据进行RSA签名验证。
当签名全部验证通过后，将会把解密后的镜像保存到 **/var/.firmware.orig** 文件中。
随后回到upload.cgi中，调用 **/bin/mtd_write** 命令将解密后的镜像文件写入到flash中。
至此固件升级的流程就分析完毕了，由于固件升级包使用了RSA签名校验，因此直接伪造固件升级包的难度很大，只能与其他漏洞相结合的方式实现写入自定义固件的效果。
### 5\. 自定义固件写入研究
D-Link DIR-816 A2路由器的文件系统是直接加载在内存中的，每次重启后都会从flash中的kernel
image里重新读取加载。这样的设计方式可以提升系统的健壮性，在避免异常断电造成的文件损坏的同时，也使得传统恶意程序无法驻留在路由器中。本章节主要为了方便后续的研究及对植入驻留型恶意程序的可行性进行探索，对该路由器刷写自定义固件的方法进行了探索及研究。
#### 5.1 防砖准备工作
为了能够安全的进行固件写入测试，首先我们需要对flash中的固件进行备份，可以直接从flash中提取或是利用上一章节的方法从固件升级包中进行解密提取。下面是通过使用dd命令将MTD设备中的Kernel部分导出到web目录后进行下载备份的方法。
PS: 有Flash编程器的可以免去后续这些麻烦，直接通过编程器从Flash中读取备份。
    # 使用DD命令直接从MTD设备中导出到路由器的web目录，随后即可通过网页http://192.168.0.1/mtd4_Kernel.dump直接下载
    cat /proc/mtd 
    ------------------output------------------    dev:    size   erasesize  name
    mtd0: 00400000 00010000 "ALL"
    mtd1: 00030000 00010000 "Bootloader"
    mtd2: 00010000 00010000 "Config"
    mtd3: 00010000 00010000 "Factory"
    mtd4: 003b0000 00010000 "Kernel"
    ------------------------------------------    
    /home/busybox.mipsel dd if=/dev/mtd4 of=/etc_ro/web/mtd4_Kernel.dump
    ------------------output------------------    7552+0 records in
    7552+0 records out
    3866624 bytes (3.7MB) copied, 1.412360 seconds, 2.6MB/s
    ------------------------------------------
备份完固件后若测试中出现系统异常，只要uboot部分没有被破坏，即可使用路由器uboot引导界面的第二个菜单功能，进行固件的刷写还原。通过配置tftp服务器及文件名称后即可通过tftp进行固件的还原。
#### 5.2 linux kernel image分析
由于我们的目的是修改路由器内核中打包的文件，实现篡改数据或植入恶意程序的目的，因此首先要对封装的Linux kernel image进行分析。
首先使用binwalk对备份的kernel image进行分析可以发现这是一个uimage封装并使用lzma压缩的linux kernel image文件。
下面的代码用于手动从uimage封装的文件中提取lzma压缩的kernel image文件。
    根据uimage中image size字段的大小3772774字节。
    dd if=mtd4_Kernel.dump of=kernel_image.lzma bs=1 skip=64 count=3772774
此处遇到了一个坑，一定不能使用新版本的lzma去压缩，必须要使用特定版本的lzma工具才能正常解压和压缩。通过观察设备的启动过程可以发现设备是基于ralink的sdk进行开发的，因此我们也需要编译对应sdk中的lzma和xz等工具对镜像文件进行处理，否则再重打包镜像时会出现如下图所示的错误信息。
可以在网上搜索 **MediaTek_ApSoC_SDK_4320_20150414.tar.bz2**
这个版本的SDK，经测试该SDK中的工具可以用于成功处理我们的这个镜像文件。
使用编译好的lzma工具即可成功的解压该镜像文件，使用binwalk对解压后的文件进行分析可以看到该kernel
image中有一个使用xz压缩的文件。基本上在linux kernel
image中使用xz压缩的大多都是rootfs文件，也就是我们实际在路由器中看到的那些文件。
由于linux kernel
image本身是一个可执行文件，使用binwalk自动解压会导致提取出不属于xz部分的数据。根据xz文件格式的特征可以知道xz压缩文件有其特定的起始标识
**\xFD\x37\x7A\x58\x5A\x00** 和结束标识 **\x59\x5A** ([xz-file-format](https://github.com/addaleax/xz/blob/master/doc/xz-file-format.txt))
通过对文件进行分析后，即可得到xz文件在镜像中的正确起始及结束地址，提取和解压的命令如下。
    dd if=kernel_image of=root_fs.xz bs=1 skip=4763648 count=2384780
    # 查看xz文件的内容
    ~/IoT/tool/bin/xz -l root_fs.xz 
    ------------------output------------------    Strms  Blocks   Compressed Uncompressed  Ratio  Check   Filename
        1       1  2,328.9 KiB  9,294.0 KiB  0.251  CRC32   root_fs.xz
    ------------------------------------------    
    # 解压xz文件
    ~/IoT/tool/bin/xz -d root_fs.xz
通过使用file命令可以得知解压后的xz数据是一个cpio归档文件，进一步查看后可以确认这个文件就是我们所需要修改的root_fs文件。
    \# 确认解压后的文件类型
    file root_fs
    ------------------output------------------    root_fs: ASCII cpio archive (SVR4 with no CRC)
    \------------------------------------------    
    \# 使用cpio命令查看归档的文件列表
    cpio -tv -F root_fs|more
    ------------------output------------------    drwxrwxr-x 2 541 541 0 Aug 24 19:30 /sys
    drwxrwxr-x 2 541 541 0 Aug 24 19:30 /mnt
    drwxrwxr-x 2 541 541 0 Aug 24 19:30 /dev
    crw--w--w- 1 root 541 240, 0 Aug 24 19:30 /dev/ac0
    crw-rw---- 1 root 541 90, 8 Aug 24 19:30 /dev/mtd4
    crw--w--w- 1 root 541 217, 0 Aug 24 19:30 /dev/spiS0
    crw--w--w- 1 root 541 4, 64 Aug 24 19:30 /dev/ttyS0
    brw-rw---- 1 root 541 31, 1 Aug 24 19:30 /dev/mtdblock1
    brw-rw---- 1 root 541 31, 6 Aug 24 19:30 /dev/mtdblock6
    crw--w--w- 1 root 541 251, 0 Aug 24 19:30 /dev/nvram
    crw-rw-rw- 1 root 541 5, 2 Aug 24 19:30 /dev/ptmx
    crw-rw-rw- 1 root 541 1, 3 Aug 24 19:30 /dev/null
    crw--w--w- 1 root 541 218, 0 Aug 24 19:30 /dev/i2cM0
    crw-rw---- 1 root 541 90, 1 Aug 24 19:30 /dev/mtd0ro
    crw-rw-rw- 1 root 541 1, 2 Aug 24 19:30 /dev/kmem
    crw--w--w- 1 root 541 253, 0 Aug 24 19:30 /dev/rdm0
    brw-rw---- 1 root 541 31, 2 Aug 24 19:30 /dev/mtdblock2
    \------------------------------------------
下一步就是提取cpio中的文件了，提取命令如下。
    创建目录rootfs
    mkdir rootfs
    cd rootfs
    \# 解压root_fs归档中的文件到rootfs目录中
    cat ../root_fs | cpio -idmvH newc --no-absolute-filenames
    \# 成功解压后即可在目录中看到归档中的文件了。
    ls -la
    ------------------output------------------    total 64