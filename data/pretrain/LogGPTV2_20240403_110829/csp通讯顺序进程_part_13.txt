口
---
## Page 92
USER进程内，由
这个进程可用在数组中模拟小整数的集合的行为
X4进程EL 的作用是记录事作 in是否已经发生了。第一次发生
其中ADD递归地定义为
数9。我们还需要确保当9的自变量超出了f的值域时，9会给
时，EL的回答是no，以后发生时，
组UP;再把这个初值分别如到m和！上,这样既恢复了！的初随，
将其恢复为原值。在下一例中，恢复原值的过程要更繁琐些。
2.6.3
可取得以下效用，
在α（m:SET3）中的每个事件是一个三元组，例如m.2.in。在
整个数组在使用前还可再加一次标记，得到
程用它们在数组中的下标做为标记。
而且还把该值加到了m上。
进程组DOWN：把1逐步减到0从而发现！的初值。然后由进程
用一组并发的进程可以等效实现-一个数组变量，这些并发进
UP。=P
要实施一般符号变换，我们需要知道符号变换函数f的反函
DOWN;=(l.down-DOWN;+1l.around--UP;)
ADD = DOWN。
实施
SET3 =(0:EL)(1:EL)(2:EL)I(3:EL)
if 2∈m then P else (m:=m U[2};Q)
m.2,in->(m:2.yes-=P|m.2,no-=Q)
αEL = {in,no, yes}
(m:=m+l;P)
EL=in-→no-→μX.(in-→yes-→X)
m:SET3[USER
EL 回答是yes。合
由ADD 实施
口
口.
---
## Page 93
因此，当那位男仆（2.5.3节）去度假时，这个共享的男仆可以被
我们定义
要教会LACKEY为五个主人服务（但每次只为其中一个服务）。
离座，主人吃饭时他要站在身后，于是有
每次选择均由（L:P）的环境独立完成。
μP执行c时，（L:P）即执行事件I.c（l∈L且c∈aP)。标记I的
P是一进程，定义（L:P）是行为与P完全相同的进程，只是一
2.6.4多重标记
用原子对cons（"l,"x）代表复合事件I.x。则（l:P）的实施如下
出回答"BLEEP。符号变换的实施以2.6.1节L4为依据。合
X1
70
标记的定义可以护展到允许事件在集合L中任取标记！。设
label(l,P)=Ay.if null(y)\ atom(y) then."BLEEP
进程标记，作为一-种特殊情况，它的实施就更简单了。我们
778=(x) x=()
一个年轻的男仆LACKEY，
举例
SHARED LACKEY =(L:LACKEY)
aLACKEY = {sits down,gets up)
else if car(y)≠l then "BLEEP
else if P(cdr(y))="BLEEP then "BLEEP
else if P(g(x)) ="BLEEP then "BLEEP
L={0,1,2,3,4}
这个男仆服侍他的主人人座、
else change(g,P(g(x)))
P(cdr(y)))
else label(l,
---
## Page 94
因而它也满足S，即
设tr为(PIQ)的一个迹。由2.3.3节L1可知（traP)是P的迹，
术将在第六章中更充分地加以讨论。
个进程的服务，但要这个进程预先知道服务对象的标记。共享技
LACKEY的示意图就更复杂了。
的示意图则是--个二叉树（图2.10)。SHARED
的树于没有树权（图2.9）。而{0,1}：LACKEY
茂盛些。如LACKEY 的示意图是一根光秃秃
分支增多了，从这一意义上说，L:P的树要更
与P的树形图尽管类似，但从-个节点引出的
为每次他们中只能有·--个人可以上桌就餐。
当然，在这段时间里，哲学家们更要埃饿了，
雁来为就餐的哲学家服务，不至于出现死锁。
如果L中的标记不止一个，L:P的树形图
总之，有了多重标记，就能使多个做了标记的进程共享某一
假设P和Q为并发运行的进程，并已证明
0.gets up
PsatS(tr)及 Qsat T(tr)
0.sirs down
2.7功能描述
l.gets up
S(trfaP)
图2.10
0.gers up
1.sits down
1.gets up
邮？.9
sits down
gets up
sits dowrr
2
---
## Page 95
轴L1就有
对1.10,2节中X1的证明加以修改，容易证得
我们要证
设aP={a,0}， aQ={b,0}
X1（参见2.3.1节X1)
L1如果 Psat S(tr)
归纳成法则即有
是我们可以推出，
理，tr卜aQ为Q的迹。这一论证对（PQ）的每个迹都成立。丁
用并行组合子定义的进程与没有用这个组合子定义的非停止进程
无死锁，另一个办法是如在2.3.1节X1中我们所做的那样，证明
个办法是如2.5.4节中我们所做的那样，逐步地认真证明进程的
们将给出更为有力的法则来。而在目前，要消灭死锁的危险，一
基于这些法则的推理就无法证明死锁的不存在性。在3.7节中我
2
(0141)=0
由于sat的法则允许STOP满足一切能够被满足的描越，因此
P=(a-→c→P)
举例 
则
(PlQ) sat (0≤(traP)ja-(traP)to≤1
(PIQ) sat (S(tr}aP)AT(tr}aQ))
Qsat T(tr)
(PIQ) sat (S(taP)AT(traQ))
Q sat (0≤tr↓c-tr↓b≤1)
.P sat (0≤tr↓a-trle(001) -0↑(0|)≥0V
当aA，有（trA)↓=t↓
---
## Page 96
2.8.1基本定义
深入的数学研究才能找到这类问题的答案。
则？或者，它们是否完全，即有了这些法则就可证明有关进程的
法则是否真的成立？它们会不会相互矛盾？还有没有更多的法
来说，那些解释也就够了，但还免不了要提些问题，譬如，这些
望它们成立的理由。对于一位有应用数学或工程师的直觉的读者
话，证明的过程也仅限于非形式的解释，说明为什么我们应该希
还将它们用于某些命题的证明。如果说这些法则是经过证明了的
f-1*(tr)满足S，这正是L3的结论。
为P的迹。L3中的前提说明P的每个述都满足S，由此可得
法结论中的f-*可能要解释一下.设tr为f（P）的迹，则f-I*（tr）
L3
X2在X1中定义的进程（PIQ)永不停止，因为
一·切事实？是否能用更少的法则证同样多的事实呢？只有经过更
（PIQ）也永不停止。
L2设P和Q永不停止，且（αP∩aQ)最多包含-·个事件，赠
此只要可能，我们还是应该用一般成立的法则来证明，如
等价。可是这类证明总要牵扯到一大串长乏味的代数变换。因
在刻画进程的过程中，我们已经陈述了很多法则，并且有时
(()*)ss()
在建立某一实体系统的数学模型时，用实体的可直接或间接
如果PsatS(tr）
符号变换的证明规则是
举例
2.8确定性进程的数学理论
αP∩aQ={o}
口
---
## Page 97
而另一个最极端的例子是任何时刻动作都不定的进程
9
CO <>ES
而且S是满足以下两个条件的A*的任意子集合
其中A是符号的任意集合
D0·一个确定性进程就是一个集合对
等同的，因为可以用其中一个概念定义另一个概念。
对应的关系。在数学上，有了这种关系就足以证明这两个概念是
进而集合对（A,S)也可被下列方程式还原出来
且 αP=A 
则合 P=（x:P→P(x))
且对所有x∈P,P(x)的迹为{t∈S}的进程
设P={x|∈S}
一决定了一个进程P，它的迹集是S，如下构成
意集合对(A,S)，它们也满足这三个法则。则这个集合对也就唯
已解释过它们为何必须满足1.8.1节中的法则L6,L7,L8。考虑任
进程P，它的两个比较熟悉的属性是
b1
观察或测量的属性定义其基本概念，是一种好的对策。对确定性
74
现在可以形式地定义有关进程的各种算子了，即通过说明运
STOPA=(A,f<>})
traces（P）P能实际参加的所有事件序列的集合
ap
满足这个定义的最简单的例子就是不动作的进程，即
S,t,st∈SsS
P原则上能执行的事件集合
S =traces(x: P→P(x))
A=aP
(A,S)
---
## Page 98
证明的方法遵从Scott的不动点理论。
这个基本定理是：一个递归定义的进程（2.8.1节D5）是相应递
2.8.2
从某些其它的法则，倒如
定性进程的一切法则对确定性进程也都成立。但确定性进程还遵
现比来。所以我们还需要一个更普逼，更复杂的进程定义。非确
章：中将越来越明显，因为D0没有把进程可能具有的非确定性体
很容易的。
D7f(A,S)=(f(A),{f*(s)|s∈S})
D3.(x:B-=(A,S(x)))=(A,{<>}U{^s1x∈BAs∈S(x)})
全适用于非确定性进程。
所有引越的法则不仅可以万无一失地应用于确定性进程，而且完
为了避免引起混乱，在本书中我们没有引述这类法则：因此书中
是说证明它们满足D0的条件C0和C1。幸运的是，要证明这些是
当然我们还有必要证明这些定义中的等式右侧确实足进程，也就
6
D4
的。形式定义如下
归方程的一-个解，即
但是D0还不是进程概念的完美无缺的定义，这一点在第三
() V+()s))=()()
首先我们需要描述进程之间的·种次序关系
这一节的目的是要给品递归式基本定理的证明的一个轮，
μX:A.F(X) =(A, U traces(F"(STOPA)))
(A,S)/s=(A,{|(st)∈S})
不动点理论
μX,F(X) =F(μX,F(X))
 PP=P
A(s↑B)∈T})
为1-1雨数
F为卫式
B二A
SES
15
---
## Page 99
L7 μX:A.F(X)=JFi(STOPA)
更进一步，#算子（2.8.1节D5）可用极限重新正式定义
0.0.)，因为它满足以下法则
L4
就说这个偏序是完全的。
以后我们只对链式进程序列使用极限算子L”。
我们定义这样·一个键的极限（最小上界）为
5
满足
因此这个次序关系是偏序关系。
小。由于有
每件事—一也许还能做得更多一
两个进程如果字母表相同，而且其中之一可以做另-进程做过的
D1 (A,S)≤(B,T)=(A=BAS≤T)
3
G
76
STOPA=P
如果一个偏序有最小元，而且所有的键均有最小上界，我们
字母表为A的所有进程的集合形成一个完全序（缩写为
由一个c.p.0.到另一个c.p.0.（或到其自身）的函数F，如果
P= P;
在序关系里，链是元素的一个无穷序列
PEQAQ=R>PER
PEQAQ=P→P=Q
PEP
LP;=(aP。, Utraces(P))
P,Pi+1
只要αP=A
[P。,P.,P...}
一则它们可以按这种次序比较大
对一切
---