wants the scanner to look for. Moreover, as a network may include several deviations, the user should also configure the number of 
simultaneous deviations the scanner is intended to look for. At the end of this process, taking into account the deviations the user requested 
the scanner to check, if a payload appears to be a valid one, the security policy is considered to be found and the corresponding 
transmission instance is updated with both the ids of the discovered deviations and the setting of the security-found attribute to true. 
However, if the security policy could not have been retrieved, no parameters are added in the corresponding instance (the security-found 
attribute already set to false). 
Deviations regarding the IEEE 802.15.4-2003 standard 
(CTR) The nonce used is the 2006 standard’s one (Source Address + Frame Counter + Security level rather than Source Address 
+ Frame Counter + Key Sequence Counter).  
(CTR) Flag octets of input blocks are not set to 0b10000010 but to another value; 
(CTR) The first block counter used for encryption is equal to 0x0001 and not 0x0000; 
(CBC-MAC) Tag T is obtained by keeping the rightmost M bytes of the last computed CBC-MAC value rather than the leftmost 
M bytes; 
(CBC-MAC) The length field of the first input block used to generate the key streams is not equal to (n + m) but to (n + m + 1); 
(CCM Authentication)  The nonce used is the 2006 standard’s one; 
(CCM Authentication) Flag octet of the first input block B0 is not set to the value specified in the standard; 
(CCM Authentication) The string encoding the additional string a is formed by concatenating l(a) (the length in octet of a) within 
2 octets with a itself, but is not padded with zeros so that its length is divisible by 16; 
(CCM Authentication) The authentication tag T is not obtained by keeping the first-M-octet of the last output block but by 
keeping the last M-octet; 
(CCM Encryption) The nonce used is the 2006 standard’s one; 
(CCM Encryption) Flag octet of the input counter blocks is not formatted as specified in the standard;  
(CCM Encryption) First counter block used to generate the first key stream block (to encrypt/decrypt message) is not A1 but A0; 
(CCM Encryption) Encrypted tag U is generated by XORing the authentication tag T with the last key stream blocks (Sn) rather 
than the first key stream blocks (S0); 
(CCM Encryption) Encrypted tag U is generated by XORing the authentication tag T with the key stream blocks S1 rather than 
S0; 
Deviation regarding the IEEE 802.15.4-2006 standard 
(CCM*) Security policy is not the same as indicated in the auxiliary security header; 
(CCM*) When transforming inputs before performing the CCM* mechanism, the encoded a data is not right-concatenated with 
zeros so that the octet string has length divisible by 16; 
(CCM* Authentication) Flag octet of the first input block B0 is not set to the value specify  in the standard; 
(CCM* Authentication) Tag T is obtained by keeping the rightmost M bytes of the last computed CBC-MAC value rather than 
the leftmost M bytes; 
(CCM* Encryption) Flag octets of the input counter blocks are not formatted as specified in the standard; 
(CCM* Encryption) The counter block used to generate the first key stream block (to encrypt/decrypt message) is not A1 but A0; 
(CCM* Encryption) Encrypted tag U is generated by XORing the authentication tag T with the last key stream blocks (Sn) rather 
than the first key stream blocks (S0); 
(CCM* Encryption) Encrypted tag U is generated by XORing the authentication tag T with the key stream blocks S1 rather than 
S0; 
Deviation regarding the version of the standard itself 
The Frame version subfield of the frame specifies a 2006 frame but is a 2003 one; 
The Frame version subfield of the frame specifies a 2003 frame but is a 2006 one; 
The frame is a 2003-frame but is secured with a 2006 standard’s security policy; 
The frame is a 2006-frame but is secured with a 2003 standard’s security policy; 
4. THE 6LOWPAN BORDER ROUTER 
The role of the border router is to translate incoming and outgoing frames from and to the 6LoWPAN format. Moreover, it must be able to 
do so while adapting to the specificities of the underlying IEEE 802.15.4 infrastructure. In the following sections, we assume that such 
specificities are provided by the IEEE 802.15.4 scanner but that is not a mandatory step: it might as well be manually provided based on 
some other source of information. 
4.1 IEEE 802.15.4 AND 6LOWPAN 
6LoWPAN is an IPv6-based low-power wireless personal area network which is composed of devices compliant with the IEEE 802.15.4 
standard. Before ensuring IPv6 transmission over such a wireless protocol, several issues need to be solved, and among them the very 
limited size of IEEE 802.15.4 packets. Indeed, while the MAC MTU size of an IEEE 802.15.4 packet is 127, the MTU size of an IPv6 
packet is 1280. Adding a maximum frame overhead of 25 bytes leaves only 102 bytes available for handling IPv6. Moreover, the use of 
security introduces further overhead, up to 21 bytes in IEEE 802.15.4-2003 and up to 30 bytes in IEEE 802.15.4-2006. Furthermore, as the 
IPv6 header is 40 octets long, the remains payload for higher protocol such as UDP and TCP are very limited.  
To solve the exposed issues, an adaptation layer has been specified between the MAC layer and the IP network layer and is part of the 
6LoWPAN protocol. It handles both fragmentation and reassembly of IPv6 packets, while providing a header compression scheme to 
reduce the size of the IPv6 header and, when necessary, the UDP header.  Also, as described later, the specification supports mesh routing 
mechanisms.  
4.2 VIRTUAL NETWORK INTERFACE 
To allow communications between our border router and the host, we used a virtual network kernel device known as TUN. It operates on 
layer 3 and delivers all the packets sent by an operating system to attached user-space programs. Conversely, user-space packets passed to 
the TUN are forwarded to the operating system. Actually, our router has been implemented as a user-space program while the operating 
system represents the IP-based tools a security auditor would use (nmap, telnet, ping, etc.). Thus, in the operating system point of view, our 
tool is considered as an external source. 
As TUN interfaces operate on layer 3, only the IPv6 layer of packets are forwarded, allowing our tool to not care about Ethernet. It thus 
does not have to deal with MAC addresses when communicating with the host. Note that it still needs an IEEE 802.15.4 MAC address to 
communicate with the wireless network. 
4.3 NETWORK CONFIGURATION 
In this section we just provide details about how the router’s addressing information are handled when wishing to transmit frame over the 
air. We assume that the user would like to either spoof an existing device or act as a third device on the network.  
In the former case, the user will be invited to enter both an IPv6 address and a link-layer address (a 16-bit short address and/or a 64-bit 
extended address). It is worth noting that, some established network will not allow a new device to communicate on the PAN if not 
associated. To solve this issue, we implemented a procedure which handles association procedure within a PAN. However, as a PAN could 
maintain a kind of ACL, it is possible that association procedures will be rejected. In this case, we advise the user to user the spoofing 
method. 
In the latter case, namely the spoofing method, user will be requested by the router to provide both the IPv6 address and at least one link 
layer address of the existing device he wants to spoof.  
To ensure efficient communications within the network, we also recommend the user to use the IEEE 802.15.4 scanner we developed in 
order to configure the router such as it uses the proper transmission scheme as well as the proper security policy. Note that for the security 
policy, the user will be requested by the scanner to provide one or several encryption key for each pair of devices communicating on the 
network. 
Please refer to section 4.4.4 to know how to deal with recipient link layer addressing information.  
4.4 IPV6 TO 6LOWPAN 
Here we explain how incoming IPv6 packets are handled by the router before being transmitted over the air.  
4.4.1 IPV6 HEADER COMPRESSION 
PDU size of an incoming IPv6 packet is checked to ensure it is not greater than the MTU size of IEEE 802.15.4 packets. If it exceeds this 
limit, the IPv6 header is compressed following the encoding scheme specified in the RFC 6282. The result is known as the 
LOWPAN_IPHC, a 13-bit field IPv6 compressed header. This field is always preceded by a 5-octets flag indicating that the following field 
is actually the LOWPAN_IPHC field itself.  
By relying on several common rules, the encoding mechanism tries to elide, either literally or partially, the IPv6 header fields which can be 
inferred by the recipient device. Each field that could not have been elided is carried in-line right after the LOWPAN_IPHC header, either 
in a compressed form if it has been partially elided or literally. Note that, in this case, they appear in the same order as they do in the 
uncompressed IPv6 header.  
The rules that the encoding mechanism relies on are assumed to be common on the 6LoWPAN network and are listed below: 
Version is 6; 
Traffic class and Flow label are both zero; 
Payload length can be inferred from lower layers; 
Hop limit is set to a well-known value (1,64 or 255); 
IPv6 addresses are formatted using the link-local prefix or a small set of well-known routable prefixes; 
IPv6 addresses are partly constructed from either the 64-bit extended or the 16-bit short IEEE 802.15.4 addresses; 
When Multicast IPv6 addresses are used, a special scheme is to be performed. A multicast address is formatted as the combination of an all 
‘1’ 8-bit prefix, indicating that the address is actually a multicast address, a 4-bit flag field, giving multiple information about the address, a 
4-bit scope field, indicating the scope in which the address is valid and a 112-bit group ID, indicating a group within the given scope. All 
IPv6 multicast addresses where the upper layer of the multicast group identifier are zero may be compressed down to 48 or 32 bits. In such 
cases, only the flag, the scope and the least-significant bits of the multicast group identifier are carried in-line. Another special multicast 
address known as Solicited-Node Multicast address may be compressed down to 8-bit. Its format is such as only its least-significant group 
ID is to be carried in-line. Furthermore, when dealing with multicast addresses, two LoWPAN headers also have to be added, the LoWPAN 
Mesh addressing and the Broadcast/Multicast headers. This is discussed on specific sections. 
Moreover, the mechanism allows network’s devices to use up to 16 context identifiers to encode source addresses and up to 16 others 
context identifiers to encode destination addresses. When contexts are used, the LOWPAN_IPHC is extended with a further Context ID 
field formatted as a 4-bit source Context ID and a 4-bit destination Context ID.  
RFC 6282 also defines a compression format for IPv6 extensions and UDP headers. However, we only focused on UDP header 
compression, handling IPv6 extensions by carrying them in-line. When the next header field of the IPv6 header specifies the UDP protocol, 
it is fully elided. Furthermore, as stated before, the header of such a protocol shall be compressed according to the encoding scheme 
specified in the RFC 6282. A special section is dedicated to the UDP header compression.  
In the best case, i.e. every IPv6 header fields could have been fully elided and no context are used, the IPv6 header can be compressed 
down to 2-octets formatted as the 5-bits flag octet and the 13 bits LOWPAN_IPHC compressed header, without any further field carried in-
line.  
Note that, to perform the IPv6 header compression, the router needs to retrieve the IEEE 802.15.4 addressing information of the device the 
user wants to communicate with. We discuss this process in a special section (NDP TABLE).  
If at the end of the compression process the IPv6 packet meets the IEEE 802.15.4 MTU size constraint (taking into account the use of the 
security), the packet can be encapsulated and sent over the air. Otherwise, the packet will need to be fragmented. The mechanism is 
described in a specific section. 
4.4.2 UDP HEADER COMPRESSION 
RFC 6282 states that UDP header, when present, shall be compressed. The result is known as the LOWPAN_NCH compressed header 
formatted as a 5-bit pattern specifying an UDP header compression and 3 others bits used for UDP checksum and UDP ports compression.  
The UDP checksum can be fully elided on condition that another integrity check mechanism providing at least the same information than 
the UDP checksum is contained in the UDP payload (IPSec when using IP over UDP tunneling or MIC within UDP payload). Additionally, 
another lower-layer integrity check mechanism (i.e. IEEE 802.15.4 Message Integrity Code (MIC)) must be provided to ensure the 
detection of pseudo header corruption. If these conditions are not meet, the checksum cannot be compressed.  
To ensure a device will not reject our frames because of the absence of the UDP checksums, the router never elides this field.  
The UDP ports can also be partially elided if they are contained in small ranges of values. A specific compression scheme is applied when 
both the source and the destination ports are contained in the range 0xf0b0 – 0xf0bf while another one is applied for each port if it is 
contained in the range 0xf000 – 0xf0ff. In the former case, first 12 bits of both source and destination ports are elided while the remaining 4 
bits of both ports are carried in-line. In the latter case, the first 8-bits of each port meeting the constraint are elided while the remaining 8 
bits are carried in-line. When neither the first nor the second case is met, ports are fully carried in-line. 
For UDP ports compression, we simply followed the scheme we described above.  
Fields or subfields which are to be carried in-line are placed right after the LOWPAN_NCH header, in the order in which they appear in the 
uncompressed UDP header.  
4.4.3 FRAGMENTATION 
If an IPv6 packet does not fit within a single IEEE 802.15.4 frame, it shall be fragmented according to the process specified in the RFC 
4944. The IPv6 frame could be either a frame whose header compression did not reduce the frame size enough to meet the IEEE 802.15.4’s 
MTU size constraint or an uncompressed IPv6 frame.  
The fragmentation process consists of breaking the IPv6 frame into multiple link-layer fragments. The first fragment is called the first 
fragment while the others are called the subsequent fragments. The first one shall be formatted as the combination of a 5-bits flag, 
indicating that the following fields are part of the first fragment, an 11-bits datagram size, encoding the size of the entire IPv6 frame before 
fragmentation, and a 16-bits datagram tag, a unique identifier of the IPv6 packet being fragmented. The subsequent fragments are formatted 
as the combination of a 5-bits flag, indicating that the following fields are part of a subsequent fragment, the datagram size, the datagram 
tag and the datagram offset, specifying the offset, in increments of 8-octets, from the beginning of the IPv6 payload before fragmentation.  
As the fragment offset can only express multiples of eight bytes, the size of all link fragments for a given Ipv6 packet except the last one 
shall be multiples of eight bytes. 
Our router performs fragmentation just as it is specified in the RFC 4944. Once the IPv6 frame has been fragmented and all the fragments 
have been encapsulated, they are sent over the air in the proper order such as the recipient can reconstruct the original frame. 
4.4.4 NPD TABLE 
When wishing to send an IPv6 frame over the air, the router needs to know which link layer destination address to use, especially when 
dealing with IPv6 addresses compression.  
If the user chose to use the IEEE 802.15.4 scanner we introduced in the very first part of this document, the router would be able, at a 
certain extent, to retrieve this information in the database automatically generated by the scanner. Otherwise, the router will send a NDP 
request frame in broadcast and wait for response. As remote devices may not always support the NDP protocol, if at the end of this process 
the addressing information could not have been retrieved, the IPv6 destination address will not be compressed and the frame will be sent 
over the air using the broadcast IEEE 802.15.4 address (0xffff).  
Note that, when starting the router, user can also provide the router with a python dictionary in which the keys are the IPv6 addresses and 
the values are the corresponding link-layer addresses.  
Once the IEEE 802.15.4 addresses are retrieved, whatever how, they are stored in a kind of NDP table that aims at helping the router in 
future communications.  
4.4.5 MESH ROUTING 