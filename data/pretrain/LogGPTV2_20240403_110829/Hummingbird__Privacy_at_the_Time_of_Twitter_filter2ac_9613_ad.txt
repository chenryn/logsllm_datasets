guarantees privacy of tweeters and followers at minimal
costs for both and at virtually no cost for the server. In
particular, cryptographic overhead incurred by tweeters and
followers is negligible and arguably not perceivable by end-
users. Table I summarizes the overhead incurred by each
operation in Hummingbird. On the user side, experiments
were conduced on a 2011 Macbook Pro with a 2.3 GHz
Intel Core i5 CPU. Whereas, HS was running on an Intel
Harpertown platform with a 2.5GHz Xeon CPU (HS). Per-
formance analysis is discussed below.
Follow. Following a user requires executing the three-step
protocol of Figure 2. (Once again, since messages are routed
through HS, this protocol is asynchronous and does not re-
quire users to be simultaneously online.) It requires an OPRF
invocation, thus, two modular multiplications, one (short)
exponentiation, two hash evaluations, one RSA signature
and one modular inversion in the RSA setting. Therefore,
computational overhead is clearly dominated by tweeter’s
computation of one RSA signature per each requested hash-
tag. According to our experiments, an RSA signature with
a 1024-bit modulus takes less than 1ms using Java and
Chinese Remainder Theorem, while modular multiplications
take less than 0.01ms. Thus, we conclude that the user-side
cryptographic overhead stemming from the Follow protocol
is dominated by the time to perform the web transaction
itself. Total communication overhead amounts to 2 integers
in the RSA group for each hashtag of interest.
Tweeting. This operation requires one hash and one RSA
signature for each hashtag associated with the tweet and the
293
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:50:17 UTC from IEEE Xplore.  Restrictions apply. 
Operation
Request to Follow
Approve Request
Finalize Request
Tweet
Read
Match
Computation Overhead
User
1 exp, 1 mult, 1 hash
1 exp
1 mult, 1 inv, 1 hash
1 exp, 1 hash 1 AES enc
1 AES dec
–
HS
None
None
None
None
None
O(log(n))
Communication
Overhead
1024 bits
1024 bits
1024 bits
160 bits
160 bits
–
[Notation: n denotes the total number of follow requests; AES enc/dec’ use 128-bit symmetric keys; ’hash’ designates SHA-1
invocations; ’exp’, ’mult’, and ’inv’ denote, resp., modular exponentiations, multiplications, and inverses of 1024-bit integers.]
Table I: Overhead of all Hummingbird operations per-hashtag.
computation of one symmetric key encryption (e.g., AES).2
Hence, computation overhead is once again negligible com-
pared to that required to complete the web transaction.
Communication overhead only amounts to one output of a
cryptographic hash function (e.g., SHA1) for each hashtag.
Also, reading a tweet only requires one AES decryption,
which can be considered negligible.
Server Overhead. HS is not saddled with any crypto-
graphic operations. Besides storing/relaying messages, HS
simply matches tweets to followers by matching pseudo-
random values. For any incoming pair (encrypted tweet,
cryptographic token), HS only needs to lookup the token
against those uploaded by corresponding followers (and,
if needed, forward the ciphertext). In our implementation,
tokens are outputs of SHA1 hash function, computed over
OPRF evaluations on hashtags. Thus, complexity of the
matching function depends only on the efﬁciency of the
lookup algorithm. Although we ignore details of the Twitter
“search” algorithm for matching tweets to subscription, we
consider that matching hashtags in Twitter is conceptually
similar to matching tokens in HS. In other words, if we were
to implement a non-private baseline that matches tweets to
followers in the clear, matching operation would actually
incur comparable complexity. Also, HS lookup performance
can be enhanced using, for example, binary search tech-
niques, replication and load-balancing.
VII. DISCUSSION AND EXTENSIONS
To the best of our knowledge, Hummingbird is one of
the ﬁrst attempts to construct a privacy-enhanced micro-
blogging OSN architecture. Tweeters control who can access
their tweets while enforcing ﬁne-grained access control. That
is, a tweeter authorizes followers to read only tweets with
speciﬁc hashtags. We believe this offers beneﬁts to both
tweeters and followers. For example, Alice can subscribe
to CNN tweets with the hashtag #CNNTonight and avoid
receiving all other CNN tweets that are not of interest.
Furthermore, a tweeter’s control over followers enables new
2Signatures for recurring hashtags can be cached so that each new tweet
would only require one encryption operation.
revenue possibilities. For example, Financial Times might
require followers to pay a subscription fee for accessing pre-
mium and time-critical content, e.g., stock market forecasts.
Moreover, followers can follow arbitrary tweets without
disclosing their interests. For example, if Alice subscribes
to tweets with hashtag #Caucus from NYT, no one learns
her subject of interest.
A. Information Disclosure
As argued in Section III, operational requirements of HS
impose a (minimal) privacy leakage. Any time a follow
request is issued, HS learns who are the involved parties;
later, when the request is ﬁnalized, HS also learns that
the request has been accepted. In other words, HS always
knows who follows whom and can build a full graph of
tweeter-follower relations. Also, HS learns whenever: (1) a
tweet matches a follow request, (2) two follow requests for
the same tweeter are based on the same hashtag, and (3)
two tweets by the same tweeter contain the same hashtag.
However, (3) is avoidable, as discussed in Section VII-C
below.
B. User Anonymity
Our focus is mainly on privacy; user anonymity is largely
beyond the scope of this paper. In Hummingbird, all user
identities are assumed to be known to everyone. However,
pseudonymous or anonymization techniques could be used
to protect identities of both followers and tweeters.
As far as followers, pseudonymity is perhaps the best
achievable degree of privacy, since HS forwards all tweets
matching a follower’s interests to that follower. Thus, even
if a follower’s real identity is unknown, at the very least,
there must be some persistent identiﬁer or an account.
The same does not hold for tweeters: they can actually
attain real anonymity, however, not without system modi-
ﬁcations. In current OSNs, followers and tweeters are one
and the same: they are all users. Suppose that we decouple
the two roles and create follower-users and tweeter-users.
The former would still create accounts much like they do
today and would continue depositing tokens corresponding
to hashtags of interest. However, tweeter-users would have
294
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:50:17 UTC from IEEE Xplore.  Restrictions apply. 
no accounts at all. Instead, each time Bob has a tweet
to post, he would connect
to HS via some anonymous
means (e.g., Tor) and communicate the tweet, same as in
Hummingbird. This way, whenever Bob produces two tweets
with different hashtags, HS would be unable to link them
to the same author. If we employ this approach in tandem
with the mechanism described below (for unlinking same-
hashtag tweets) privacy would increase even further. Finally,
we note that anonymity of tweeter-users would necessitate
a change in our Follow protocol: instead of using HS as a
store-and-forward conduit, Alice and Bob would need to run
this protocol directly, away from HS.
We conclude that many aspects of achieving anonymity
in a Twitter-like OSNs remain open and more work is
clearly needed. In its current form, Hummingbird does not
provide anonymity nor does it hide relationships between
tweeters and followers. Greater privacy would be achieved
if the central server could be oblivious of user identities and
tweeter-follower relationships.
C. Unlinking Same-Hashtag Tweets
We sketch out a simple method for preventing HS from
learning whether multiple tweets by the same tweeter contain
the same hashtag.
The OPRF-based Follow protocol between Alice and
Bob remains the same. But, instead of the token t cor-
responding to ht, Alice now deposits a temporary token:
tseq = H3(seq, t) at HS, where seq is the current sequence
identiﬁer and H3(·) is yet another suitable cryptographic
hash function. For his part, Bob now labels its tweets in
the same manner. Periodicity of seq can be arbitrary: time-
based (e.g., a week, a day or an hour) or volume-based, e.g.,
100 or 1, 000 tweets. (The former makes more sense as it
would not require ﬁne-grained synchronization. Whenever
the epoch changes – due to either time or volume – both
tweeters and followers update seq, recompute tseq and each
follower deposits it at HS. Although increased frequency of
re-depositing tokens at HS might be considered undesirable,
we note that users tend to be connected most of the time
and bandwidth involved in re-depositing is rather low; linear
in the number of tokens for each follower.
Clearly, within the same seq epoch, all tweets by the
same tweeter with the same ht would remain linkable by
HS. However, consider two tweets from different epochs
containing the same hashtag: they are labeled with tseq =
H3(seq, t) and tseq(cid:3) = H3(seq(cid:3), t),
respectively, where
seq (cid:8)= seq(cid:3). Linking them is computationally infeasible
due to the properties of H3(·). On the other hand, as
pointed out in Section III, the privacy gain obtained from
this modiﬁcation is of dubious value. The main reason is
that HS retains its central role and sees all tokens updates
by all followers. This allows it to perform very effective
trafﬁc analysis. For example, if Alice follows Bob on a
given ht, HS would trivially see when both Alice’s current
token tseq starts matching Bob’s counterpart. HS would thus
easily infer the periodicity of seq and, with high probability,
link Bob’s tweets with the same ht. On the other hand,
there might still be some value in this method if followers
subscribe to many hashtags by many tweeters. We defer
further investigation of this topic to future work.
D. Collusions
As discussed in Section III, our HS adheres to the honest-
but-curious (HbC) adversarial model. In particular, though
it diligently follows all Hummingbird protocols, HS can
attempt to violate privacy of either (or both) tweeters or
followers. The former entails HS learning the hashtag ht∗
used to derive the token t∗ that accompanies a tweet.
Whereas, HS violates follower privacy if it learns ht used to
derive t previously deposited by a follower. We claim that,
since HS is an HbC adversary, it does not create spurious
(or phantom) followers. If HS were to be treated as a fully
malicious adversary, it is easy to see that creating phantom
followers would allow it to obtain cryptographic tokens on
arbitrary hashtags and match them to existing tweets or
follow requests.
On the other hand, HS might still try to collude with
other users. In particular, a collusion between HS and a
tweeter would immediately disclose all interests of sub-
scribers pertaining to that tweeter. Similarly, a collusion with
a follower, would allow HS to learn all subscribers who
have any common interests with the colluding subscriber.
Nevertheless, we claim that users (tweeters or followers)
who collude with HS necessarily lose some of their own
privacy. Suppose that Alice is one of Bob’s followers on
hashtag ht who has previously deposited the corresponding
token t at HS during the Finalize Request protocol. In order
to learn ht corresponding to t, HS must collude with (1) any
Bob’s follower on ht, e.g., Alice, or (2) Bob himself.
In the former case, Alice could reveal to HS ht that was
used as secret OPRF input in the Issue Request protocol. By
doing so, Alice clearly looses her own privacy with respect
to ht. Whereas, HS learns the identities of all other Bob’s
followers on ht. This is a serious breach of privacy. However,
this “feature” unfortunately appears to be unavoidable, since,
as discussed in Section III-A, HS’s ability to simultaneously
match a given token to all of is followers is a fundamental
component of Twitter and any similar OSN.
Now, suppose that HS colludes with Bob with the goal
of learning ht corresponding to some t deposited at HS by
one or more Bob’s followers. As part of colluding with HS,
Bob could compute its PRF over arbitrary hashtags until
the output matches t. However, in general, this might be
computationally infeasible if the hashtag of interest – ht –
is not easily predictable by Bob, i.e., not in Bob’s usual
repertoire. We also note that, by revealing to HS that ht
corresponding to t, Bob would give up privacy of all of his
295
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:50:17 UTC from IEEE Xplore.  Restrictions apply. 
past and future tweets containing the same ht. We therefore
consider that Bob has a low incentive to collude with HS.
E. Handling Retweets
Twitter allows forwarding other tweeter’s tweets to one’s
own followers. Hummingbird has been designed with pri-
vacy in mind and one of its main goals is to allow tweeters
to control who can access their data. For this reason, we
do not allow retweets at this stage. Nevertheless, followers
in Tweeter, Hummingbird or any other messaging system
can always redistribute the content of the messages they
decrypt. Effective means of addressing this issues are beyond
this paper’s scope. Similarly, Hummingbird does not allow
followers to reply to a tweet. As Alice follows Bob on
“private” hashtags, replying to a tweet would immediately
sacriﬁce Alice’s privacy.
F. Extending Hummingbird to Mobile Applications.
One of Twitter’s most attractive features is its perva-
siveness. User can tweet and follow others from virtually
any computing device, e.g., a laptop, a tablet, a PDA or a
smartphone. Our current prototype only supports Firefox 3.x.
However, Hummingbird’s low overhead makes it perfectly
suitable for resource-constrained devices, such as smart-
phones. In fact, even in a smartphone setting, the overhead
of most CPU-demanding operation in Hummingbird (i.e.,
RSA signatures) is still quite low. For example, on a 2010
HTC Nexus One, running Android 2.3.6, it takes less than
20ms to generate an RSA signature.
G. Support for Multiple Hashtags
The description of Hummingbird in Section IV assumes
that all tweets and follow requests contain a single hashtag.
We now describe how to efﬁciently extend our protocol for
tweeting or issuing follow requests on multiple hashtags.
Tweeting with multiple hashtags: Bob tweets a message
M and associates it with n hashtags, ht∗
n. Anyone
with a follow request accepted on any of these hashtags
should be able to read the message. We modify the tweeting
protocol in Figure 3 as follows: Bob selects k∗ ←R {0, 1}τ1,
and computes ct∗ = Enck∗(M). He then computes:
1, . . . , ht∗
{δ∗
i }n
i=1,← {H(ht∗
i )db mod Nb}n
i=1
(cid:8)
(cid:7)
Finally, Bob sends to HS:
ct∗,{EncH1(δ∗
i )(k)}n
i=1,{H2(δ∗
i )}n
i=1
The rest of the protocol involving matching at HS, as well
as Alice’s decryption, is straightforward and we omit it.
Following on multiple Hashtags: Alice follows Bob on
any hashtags: (ht1, . . . , htl). The Follow Request protocol
in Figure 2 needs to be trivially extended to include l
parallel Blind-RSA executions, one for each hashtag in
(ht1, . . . , htl). Thus, Alice obtains (δ1, . . . , δl), i.e., Bob’s
296
RSA signatures on hashtags of interest. She then deposits at
HS: (t1, . . . , tl) ← (H2(δ1), . . . , H2(δl)).
H. Oblivious AES as OPRF
Another possibility for realizing OPRFs is to use Oblivi-
ous AES. An Oblivious AES construction involves a sender,
on input a secret AES key s, and a receiver on input a
message x. Using an oblivious evaluation of the AES circuit
(about 30, 000 gates), e.g., relying on Yao’s garbled circuits
for secure two-party computation [54],
the receiver can
obtain AES.Encs(x) without disclosing x to the sender, and
without learning s. Therefore, assuming that AES is secure
pseudorandom permutation, one could securely realize, in
ROM, the OPRF fs(ht) as H(cid:3)(AES.Encs(ht)). Use of
Oblivious AES would remove virtually any overhead during
tweeting as the tweeter would no longer need to perform
any public-key operation. However, overhead incurred by
the oblivious evaluation of the AES garbled circuit (e.g.,
see [45]) is still relatively high compared to the Blind-RSA
protocol. Therefore, we do not use it as it would signiﬁcantly
slow down the follow requests. Nonetheless, as improved
constructions become available, we can replace Blind RSA
based techniques with Oblivious AES with no architectural
change.
VIII. RELATED WORK
This section reviews related work: we distinguish be-