    ![{%}](Image00026.jpg)
    **图 3-14 浏览器显示了变更后的信息**
    以上试验说明，在 HTTP 层面，文本框、单选框的选择项，以及 hidden
    参数都被同等对待，在浏览器上无法改变的值（如单选框的选择项和 hidden
    参数）也能够被更改。
    > **要点**  浏览器发送的值都能够被变更
    通过实际体验 hidden 参数的变更可以得知，一旦处理 hidden
    参数的地方存在安全隐患，就会有被 Fiddler
    等代理工具实施篡改和攻击的风险。
-   **将 hidden 参数的更改比作对话**
    接下来让我们以对话的形式来再现一下刚才变更 hidden 参数的情形。
    **顾客与店员的对话**
    > 顾客：我想要申请会员。
    >
    > 店员：请提供您的姓名、邮箱地址、性别（男或女）。
    >
    > 顾客：姓名为德丸浩，邮箱地址为 PI:EMAIL，性别为男。
    >
    > 店员：好的。姓名为德丸浩，邮箱地址为
    > PI:EMAIL，性别为男。请您确认。
    >
    > 顾客：**不对。姓名为德丸玛利亚，邮箱地址为
    > PI:EMAIL，性别为女。请注册。**
    >
    > 店员：姓名为德丸玛利亚，邮箱地址为
    > PI:EMAIL，性别为女。您的会员身份已注册完毕。
-   **hidden 参数的优点**
    前面介绍了 hidden 参数的一些隐患，那么 hidden 参数有什么优点呢？虽然
    hidden
    参数的值能被用户自己改写，但在面对信息泄漏以及被第三方篡改等危险时，hidden
    参数却坚不可摧。
    与 hidden 参数形成鲜明对比的是后面将要介绍的 Cookie
    和会话（Session）变量。Cookie
    和会话变量的缺点是容易招致会话固定攻击。尤其是在尚未登录、并且又使用了地域型域名的情况下，受到
    Cookie Monster Bug
    的影响，根本就没有有效的办法来防止会话变量的泄漏（参考 4.6.4 节）。
    因此，像认证和授权信息这样需谨防被用户自己更改的信息，应当保存在会话变量中（参考
    5.1 节和 5.3 节）。而除此以外的信息，则首先应考虑能否保存在 hidden
    参数中。特别是在登录前的状态下，由于不存在与认证、授权相关的信息，因此，原则上要避免使用会话变量，而是应该使用
    hidden 参数，从而来防止信息泄漏等。
[3]{.注释编号下} 百分号编码属于
URL（URI）的规范，application/x-www-form-unlencoded 属于 HTML
的规范，所以两者存在细微差别。
[4]{.注释编号下} 关于使用 Fiddler 来改变参数，后面讲 hidden
参数时会进行详述。
[5]{.注释编号下} 
[6]{.注释编号下} 虽然 RFC2616、RFC1738 及 RFC3986 中并未规定 URL
的长度上限，但各个浏览器都存在上限值。
[7]{.注释编号下} 与此相反，像 FTP 和 telnet
这种能够记忆当前状态的特性，叫作有状态性。
#### **无状态的 HTTP 认证** {line-num="338 339"}
HTTP 支持认证功能。HTTP 认证根据实现方式可细分为 Basic 认证、NTLM 认证和
Digest 认证等。正如 HTTP 是无状态的协议一样，HTTP 认证同样也是无状态的。
下面让我们看一下 HTTP 认证中最简单的 Basic 认证。
-   **体验 Basic 认证**
    Basic 认证的概要如图 3-15 所示。Basic
    认证下，当浏览器请求一个需要认证的网页时，服务器会先向浏览器返回"401
    Unauthorized（未认证）"状态码。浏览器收到此状态码后，会显示要求输入
    ID 和密码的画面，然后再将输入的 ID
    和密码添加到请求信息中，再次向服务器发送。
    ![{%}](Image00027.jpg)
    **图 3-15 Basic 认证的概要**
    Basic 认证大多通过设置 Web 服务器来实现，而也能通过 PHP
    来编写代码。以下为使用 PHP 的 Basic 认证的例子。
    > **代码清单 /31/31-010.php**
    ``` 代码无行号
    已通过认证 
    用户名 :
    密码 : 
    ```
    以上代码仅用于试验，所以 ID 和密码输入任意值都能通过认证，而 ID
    或密码任意一方为空白就会认证失败。认证失败时，按照 Basic
    认证的规定会输出以下头信息。
    ``` 代码无行号
    HTTP/1.1 401 Unauthorized
    WWW-Authenticate: Basic realm="Basic Authentication Sample"
    ```
    如果要在虚拟机上运行，可以点击 /31/ 菜单的"31-010：Basic
    认证试验"。第一次请求时浏览器没有发送 ID 和密码，所以 31-010.php
    返回了 401 状态码。这时，HTTP 信息的截图如图 3-16 所示。浏览器收到
    401 状态码后，就会显示要求输入 Basic 认证的 ID 和密码的对话框（图
    3-17）。
    ![{%}](Image00028.jpg)
    **图 3-16 返回 401 状态码的 HTTP 消息**
    ![{%}](Image00029.jpg)
    **图 3-17 Basic 认证的 ID 和密码输入对话框**
    这次我们来尝试一下输入 ID"user1"和密码"pass1"，输入完毕后点击 OK
    按钮，HTTP 请求消息再次被发送。这次会附带以下的 Authorization
    头信息。
    ``` 代码无行号
    Authorization: Basic dXNlcjE6cGFzczE=
    ```
    Basic 后面的字符串内容，是 ID 和密码以冒号相隔组成的字符串、再经过
    Base64 编码后的结果。可以使用 Fiddler 的 Encoder
    功能进行解码确认。在 Fiddler 的 Tools 菜单中选择"Text
    Encode/Decode"，就会显示出 TextWizard 对话框，然后将
    dXNlcjE6cFGzczE= 复制进去，点击对话框左边的"From Base64"单选按钮（图
    3-18），就能在画面中央的文本框中看到"user1:pass1"字符串。
    ![{%}](Image00030.jpg)
    **图 3-18 使用 Fiddler 附带的 TextWizard 来解码 Base64**
    而这时，浏览器上显示的就是下图所示的画面。可以看出，PHP
    脚本成功读取了 Basic 认证的 ID 和密码。
    ![{%}](Image00031.jpg)
    **图 3-19 认证成功**
    Basic 认证成功一次以后，再向 
    下面的目录发送请求时，浏览器就会自动附带 Authorization
    消息头。因此，认证对话框只在最初的时候显示一次，看上去认证状态似乎被记住了，但实际上每次请求时都会发送
    ID 和密码，认证状态并没有被保存在任何地方。换言之，Basic
    认证也是无状态的。而正是因为 Basic
    认证的无状态性，所以也就不存在注销（Logout）的概念。
    Basic 认证可以被比喻为银行业务柜台的对话。
    > 顾客：请帮我查一下账户余额。
    >
    > 柜员：请提供您的银行卡号和密码。
    >
    > 顾客：请帮我查一下账户余额。卡号为 12345，密码为 9876。
    >
    > 柜员：余额为 5 万元。
    >
    > 顾客：请向卡号 23456 转账 3 万元。卡号为 12345，密码为 9876。
    >
    > 柜员：转账完毕。
    顾客和柜员之间的交流是无状态的。无关上下文，顾客每一次都要提供所有必要的信息。因此，就算一开始就进行转账也能正常处理。
    > **专栏：认证与授权**
    >
    > 至此我们未经特别说明就一直使用着"认证"（Authentication）这个术语。认证是指，通过一些方法手段来确认操作者确实是其本人。Web
    > 应用常见的认证方法除了 Basic 认证，还有通过 HTML 表单使用户填写 ID
    > 和密码的表单认证，以及使用 SSL 客户端证书的客户端认证等。
    >
    > 与认证相对的术语是"授权"（Authorization）。授权是指，授予已经通过认证的用户一些权限。具体表现为，让用户能够对数据进行阅览
    > / 更新 / 删除、在线转账、在线购物等。
    >
    > 由于页面上并不会特意区分认证与授权，所以用户很容易将两者混为一谈。Web
    > 应用的普遍流程为，在用户输入 ID
    > 和密码通过认证以后，立刻就会被授予一些权限。但是，在开发应用及考虑安全性时，最好能明确认证与授权这两者的区别，并养成区别使用的习惯。
    >
    > 关于认证和授权，5.1 节和 5.3 节会分别进行详述。
#### **Cookie 与会话管理** {line-num="432 433"}
前面我们已经提到，由于 HTTP
协议的无状态性，服务器端不能保存客户端的状态。但是，在应用程序中，保持客户端的状态却是相当常见的需求。
比如，在线购物网站中的"购物车"就是一个典型的案例。购物车记住了用户在哪些商品上点击了"购买"按钮。
另外，记住用户登录后的认证状态也是一种常见的需求。虽然使用 HTTP
认证就能使浏览器记住 ID 和密码，但不使用 HTTP
认证时，记忆认证状态的任务就落在了服务器身上。而像这种记忆应用程序状态的功能就叫作"会话管理"。
为了实现会话管理，HTTP 引入了名为 Cookie 的机制。Cookie
相当于服务器下达给浏览器的命令，让其记住发送给它的"名称 =
变量"这种格式的值。由于 Cookie
会被用于实现会话管理，因此，下面就让我们结合 PHP
中的会话管理来对其进行说明。
下面的示例应用是用户认证和用户信息显示的简化版。由以下 3 个页面构成：ID
和密码输入页面（31-020.php）、ID
和密码认证页面（31-021.php）、个人信息（ID）显示页面（31-022.php）。在虚拟机上执行时，可在
/31/ 菜单中点击"31-020: 使用 Cookie 的会话管理"。
> **代码清单 /31/31-020.php**
``` {.代码无行号 line-num="446 447 448 449 450 451 452 453 454 455 456 457 458 459"}
 请登录 
用户名 
密码 
```
> **代码清单 /31/31-021.php**
``` {.代码无行号 line-num="462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479"}
 登录 
登录成功
 我的账号 
```
> **代码清单 /31/31-022.php**
``` {.代码无行号 line-num="482 483 484 485 486 487 488 489 490 491 492 493 494 495"}
<?php
  session_start();  // 会话开始
  $id = $_SESSION['ID'];
  if ($id == '') {
    die(' 请登录 ');