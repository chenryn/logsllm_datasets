	



	

Fig. 8. Wimpy kernel design vulnerability 2.





   
   


 




	
	

At time (1), malicious driver i writes to an external TD,
with a value deÔ¨Åning a write transfer to the TD itself.
At time (2) the same driver writes to its device i‚Äôs (USB
HC i‚Äôs) transfer descriptor TDi enabling it to read the external
TD. WK allows driver i to perform both operations because all
direct transfers deÔ¨Åned in the modiÔ¨Åed TDs reference objects
in the local green partition 1, and their new values enable only
local-partition transfers.
At time (3), the USB HC device i reads the value of the
external TD. Because driver i modiÔ¨Åed the TD and deÔ¨Åned a
write transfer to the TD itself at time (1), device i can then
write new conÔ¨Åguration values to this TD, under the control
of malicious driver i. Next, device i overwrites the external
TD thereby enabling transfers to driver j and device USB HC
j. The WK allows USB HC device i to write the conÔ¨Åguration
values to external TD since this operation is direct and local
to the green partition 1. Note that WK does not ensure that
the values written by the device prevent indirect transfers.
At time (4), the USB HC i issues an indirect transfer to
device USB HC j and/or driver j of partition 2 via the external
TD, which violates the green-green partition separation. This
transfer is similar to the Indirect Transfer 2 of Figure 2(b).
To remove this vulnerability, the sound WK design specs
prevent all direct TD write transfers by devices in their local
green partition. Again, computing the TD state transitive
closure would have removed this vulnerability. For perfor-
mance concerns, the sound WK enforces a stronger and more
conservative policy: WK design prevents all direct TD write
transfers by devices in their local green partition. This type of
check is not included in the original WK design [21].
VII. GENERATION OF FORMALLY VERIFIED WK CODE
We use Vale/Dafny [22] to specify and verify a new, sound
Wimpy kernel (WK) implementation, following the general
approach used in prior work [15]. Comparing the new imple-
mentation with the original, we identify additional implemen-
tation errors in the original code.
A. WK API SpeciÔ¨Åcations and VeriÔ¨Åcation
All the WK APIs are speciÔ¨Åed in Vale, using the speciÔ¨Åcations
of 15 CPU instructions. To generate assembly code, we
implement an assembly printer to print the abstract-syntax-tree
(AST) of APIs generated by Vale into GNU assembly format.
Then, a new WK implementation is achieved by replacing the
APIs with the newly generated ones in the original WK code.
To verify the Wimpy kernel APIs, Vale speciÔ¨Åcations are
converted into Dafny (by Vale); and we discharge proof
obligations in Dafny, by a simulation (reÔ¨Ånement) proof that
connects the implementation to the design.
System State. The WK implementation deÔ¨Ånes the detailed
machine state, including CPU register state and stack state,
and reÔ¨Ånes the design speciÔ¨Åcations as follows:
IdentiÔ¨Åers. The implementation must use device, driver,
and object identiÔ¨Åers established on x86 platforms instead of
abstract identiÔ¨Åers of the design speciÔ¨Åcations. For example,
USB peripheral device identiÔ¨Åers use USB hierarchy addresses
(i.e., USB bus ID, USB address, connected hub‚Äôs USB address,
and hub port) and I/O objects in memory use physical memory
addresses; and PIO registers use PIO addresses.
Ephemeral USB Host Controller Objects. The implementa-
tion must use designated registers of ephemeral USB HCs to
instantiate the abstract objects in the design.
USB Interface Data Structures (IDSes). The implementation
must use the designated Ô¨Åelds of USB IDSes, which map to
abstract objects in the design.
We deÔ¨Åne mappings between the concrete implementation
on the x86 platform and their abstract deÔ¨Ånitions in the design
speciÔ¨Åcations.
Operations. WK implementation code deÔ¨Ånes 21 APIs and
23 direct I/O accesses, each of which maps to exactly one op-
eration of the design speciÔ¨Åcations (Table III of Appendix B).
We specify direct I/O accesses of drivers and devices to
physical memory and device registers of x86 platforms in
Dafny to provide a complete list of read and write accesses
that hardware can perform (Section IV-A). If we missed
some access patterns, for instance, memory accesses by green
drivers, we would have been able to prove an insecure kernel
secure. WK code also includes auxiliary foreign function
interfaces (FFIs) such as APIs provided by the underlying
micro-hypervisor (Appendix C).
Axioms. WK APIs and direct I/O accesses rely on 107
axioms, 105 of which are independent of I/O hardware autho-
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:32:26 UTC from IEEE Xplore.  Restrictions apply. 
582
rization and are used to reduce proof effort. A further break
down is in Appendix C. Only the following two axioms deÔ¨Åne
I/O hardware authorizations.
Ax1I If OS devices can only reference I/O objects outside
the untrusted OS partition by memory addresses, then
IOMMUs prevent
these devices from accessing any
objects outside that partition.
Ax2I Only USB IDS queue headers may deÔ¨Åne transfers to
USB peripheral devices.
Ax1I holds because IOMMU authorizes all memory ac-
cesses by devices. Sound WK implementation of moving a
device between red and green partitions invokes the mHV to
Ô¨Çush the IOTLB, just as any OS kernel would context switch
an IOMMU. Other cached entries of the mHV hardware
authorization mechanisms are also invalidated to prevent stale
access permissions from being used to breach isolation. Ax2I
holds because queue-element transfer descriptors are always
linked by a queue header [8].
State Invariants. The implementation maintains 88 state
invariants, 36 of which are reÔ¨Ånements of the state invariants
of WK design. Among the rest of the 52 new invariants
introduced in the WK implementation, 34 invariants refer to
the CPU registers, stack, and global variables used by the
WK APIs. These invariants deÔ¨Åne valid values that can be set
in these registers and memory; e.g., the ESP register always
points to WK‚Äôs stack; global variables containing identiÔ¨Åers
of isolated drivers‚Äô partitions cannot contain the identiÔ¨Åer of
the untrusted OS partition. 13 invariants deÔ¨Åne valid mappings
between identiÔ¨Åers used in code and abstract identiÔ¨Åers used
by design speciÔ¨Åcations. Another invariant ensures that the I/O
objects of OS drivers and devices have valid memory regions.
Only 4 invariants are related to the I/O hardware used by WK.
SI1I The physical address spaces of OS drivers and devices,
isolated drivers, physical USB HCs, and WK code, stack,
global variables must not overlap.
SI2I USB IDSes in WK code, I/O objects of isolated drivers,
physical and ephemeral USB HCs, and USB peripheral
devices must not have PIO addresses; and I/O objects
of USB peripheral devices must not have memory ad-
dresses.
SI3I All ephemeral USB host controllers‚Äô interrupts must be
disabled.
SI4I USB IDSes referenced by ephemeral USB HCs must be
either a queue header (QH) or a queue-element transfer
descriptor (QTD) of those IDSes.
Transition Constraints. In addition to the reÔ¨Ånements of the
WK-design transition constraints, the implementation enforces
the following constraint.
TC1I All mappings between identiÔ¨Åers used in WK code and
identiÔ¨Åers used in design speciÔ¨Åcations are not modiÔ¨Åed
by APIs or direct I/O accesses.
The Vale/Dafny speciÔ¨Åcations of the WK implementation
support I/O separation since their correspondence to the sound
WK design speciÔ¨Åcations is already proven.
B. Vulnerabilities of the Original WK code
We re-examined the original WK code [21] and found that it
fails to satisfy the Vale/Dafny speciÔ¨Åcations of the veriÔ¨Åed WK
implementation in four areas. This shows that careful but infor-
mal implementation of the original kernel code can still lead to
exploitable vulnerabilities without formal veriÔ¨Åcation. The Ô¨Årst
three vulnerabilities arise from violations of implementation-
speciÔ¨Åc state invariants and transition constraints, whereas
the fourth arises from incomplete kernel mediation of IDS
modiÔ¨Åcations by drivers. These are low-level implementation
errors, unrelated to the design vulnerabilities of Section VI-B.
Vulnerability 1: Isolated application drivers can modify
their devices‚Äô USB addresses. In the original WK implemen-
tation, a rogue isolated driver could conÔ¨Ågure its device to
overlap its address with another isolated driver‚Äôs USB device.
Hence, the rogue driver could access the latter device and
break I/O separation between isolated application drivers. This
vulnerability violates TC1I.
Vulnerability 2: Physical and ephemeral USB HCs can
have PIO addresses. This enables untrusted OS applications
to access both the ephemeral USB HCs owned by isolated
application drivers and their mapped physical USB HCs,
despite selective authorization of all memory accesses. This
vulnerability violates state invariant SI2I.
Vulnerability 3: WK fails to clear a physical USB HC‚Äôs
I/O objects when releasing it to untrusted OS/applications.
The original kernel code fails to prevent unauthorized object
reuse. Note that isolated drivers cannot clear these objects
since they do not have direct I/O access to them, as these
USB HCs are shared. Hence, I/O separation between untrusted
OS/Apps and isolated drivers does not hold. This vulnerability
violates the reÔ¨Ånement of the concrete model‚Äôs TC1c in the
implementation.
Vulnerability 4: Isolated drivers can modify USB IDSes after
veriÔ¨Åcation by WK. This enables time-of-check-to-time-of-use
attacks and violates I/O separation between isolated drivers,
and between untrusted OS/applications and isolated drivers.
C. Current Limitations
This WK implementation is unoptimized: only one USB
IDS can be used in one API invocation by green applica-
tions, whereas the original implementation takes multiple USB
IDSes. For now, this implementation does not support USB
device interrupts and assumes that WK disables them.
VIII. DISCUSSION
A. Future Use for Other I/O Kernel Designs
Our I/O model can be instantiated to other I/O kernels. We
informally discuss those shown by dashed lines in Figure 5.
The GPU separation kernel (GSK) [38] is a special I/O
kernel that separates ephemeral GPUs to create separate screen
areas for trusted and untrusted applications to coexist on the
same display. This allows both applications to perform concur-
rent I/O operations securely on these GPUs. Informally, GSK
design can be generated from the same concrete model used
for Wimpy kernel (WK). In contrast to WK, GSK‚Äôs ephemeral
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:32:26 UTC from IEEE Xplore.  Restrictions apply. 
583
GPUs can be active in green and red partitions at the same
time, even though they map to the same physical GPU. GSK
ensures the separation of ephemeral GPUs. More concretely,
the state of GSK design needs one additional variable: the ID
of the ephemeral GPU used by the untrusted OS. Ephemeral
GPUs in isolated applications can be active at the same time,
and thus concurrent I/O operations are allowed on the same
physical GPUs. To satisfy the ephemeral device policy of
the concrete model, GSK needs to maintain additional state
invariants and transition constraints for ephemeral GPUs; e.g.,
ephemeral GPUs must be inactive when its mapped physical
GPU is active. The informal analysis shows that the original
GSK design fails to enforce I/O separation when the physical
GPU shares the same PCI bus with a red device; i.e., it has the
vulnerability 1 of the WK design. The solution is to enforce
GSK use of only PCIe GPUs. GSK does not have vulnerability
2 of the WK design because isolated applications only need
to provide display contents (data object values) and window
geometry conÔ¨Ågurations (function descriptor values) without
accessing any TDs.
Traditional separation kernels [17], [16] can also be formal-
ized in our framework. However, they would have a different
I/O separation policy from the concrete model for WK and
GSK, and thus require a new concrete model. First, I/O parti-
tions are separation-kernel partitions, and thus there is no dis-
tinction between red and green I/O partitions. Second, the new
concrete model leverages the unidirectional communication
channels provided by separation kernels to authorize transfers
issued by drivers. Isolated applications use these channels to
communicate with I/O kernels in different partitions. Third, the
allocation of devices to these I/O kernels is static and cannot
be modiÔ¨Åed on demand, because devices cannot move between
partitions. I/O kernels instantiating such a concrete model
can enforce all policies as traditional separation kernels; in
addition, they can support DMA accesses that were excluded
by traditional separation kernels [44], [17].
Low-assurance OS kernels, such as the Linux kernel, can
also Ô¨Åt into our framework. However, another concrete model
is necessary to capture the intra-OS I/O separation policies
that prevent devices from accessing non-DMA memory. This
new model would have two I/O partitions, one comprising
all active subjects and objects, and the other the NULL I/O
partition for inactive ones. The kernel would ensure that Non-
DMA memory areas contain only inactive I/O objects (i.e.,
unmapped in DMA memory), and thus active devices cannot
access them. Unlike previous I/O separation designs [11], the
new concrete-model instantiation in OS kernels could support
device P2P communications, with early authorization.
B. Lessons Learned
Several practical lessons arise from the process of designing
and applying the models to the veriÔ¨Åcation of I/O kernels.
Three of these lessons are summarized below.
First, the application of our models to systems with in-
adequate I/O hardware clearly shows the signiÔ¨Åcant extra
veriÔ¨Åcation cost and limited scalability of these systems; see
Section III. This suggests that inadequate I/O hardware should
be deprecated for use in large commodity systems.
Second, formal design and implementation force rigorous
reasoning beyond careful but informal development. Without
formal speciÔ¨Åcations and veriÔ¨Åcation, security assurance is
difÔ¨Åcult to obtain even for small I/O kernels (e.g., fewer than
4K SLoC) that use the best I/O hardware. Subtle I/O kernel
design and implementation vulnerabilities can be easily missed
by informal development; viz., Sections VI-B and VII-B. Also,
simply using the best I/O authorization hardware to separate
address spaces is insufÔ¨Åcient; e.g., separation of ephemeral
devices (viz., Section V-A), which are multiplexed on the same
physical device, must be formally veriÔ¨Åed.
Third, the performance of formally veriÔ¨Åed I/O separation
need not incur any penalty beyond that of secure IOMMU
context switches in existent OS kernels [11]. Just the opposite:
use of non-shared, de-privileged drivers and buffers in isolated
applications, which don‚Äôt rely on shared buffer pools in
OS kernels, and of small and simple, dedicated I/O kernels
naturally offer added performance beneÔ¨Åts [21]. In contrast,
substantial performance improvements that preserve intra-OS
kernel I/O separation by selective authorization can still incur
up to 25% throughput overhead and 20% increased CPU
utilization by using shared buffer pools [11].
IX. RELATED WORK
Low assurance and limited I/O functions.. Device virtual-
ization [3], [45] can support separate I/O transfers to different
virtual machines. However, this yields a much larger trusted
code base hence lowers assurance signiÔ¨Åcantly. To minimize
trusted code bases, some isolation kernels [46], and micro-
hypervisors [47], [19], [48] support I/O separation for only a
limited set of I/O devices and functions. Other micro-kernels
(e.g., Nexus RVM [2]) are incompatible with commodity
OSes. They fail to authorize P2P device transfers (viz. the
vulnerability 2 in Section VI-B) and support multiple-device
broadcasts on a bus controller. Finally, since no commodity I/O
devices can encrypt/decrypt trafÔ¨Åc with secret keys of crypto
enclaves, they cannot transfer to/from encrypted memory; i.e.,
SGX [41]. Instead,
they separate I/O transfers to isolated
drivers, which establish crypto channels with enclaves [49].
VeriÔ¨Åed kernels. The SELinux security kernel [50] enforces
MAC policies but assumes that unveriÔ¨Åed kernel mechanisms
support I/O separation. The seL4 micro-kernel can ensure
static I/O separation when it implements a separation ker-
nel [51], as described in Section VIII-A. The ExpressOS [52]
micro-kernel provides formally veriÔ¨Åed application security
properties without trusting system services. However, it does
not enforce I/O separation for isolated applications; e.g., an
application can read I/O buffers of other applications and I/O
separation for general devices is not enforced.
Acknowledgment
We thank the reviewers for their thoughtful comments and
suggestions. The research reported herein was supported in
part by the Department of the Navy, OfÔ¨Åce of Naval Research,
under Grant No. N00014-17-1-2892.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:32:26 UTC from IEEE Xplore.  Restrictions apply. 
584
REFERENCES
[1] D. R. Engler, M. F. Kaashoek, and J. O‚ÄôToole, Jr., ‚ÄúExokernel: An op-
erating system architecture for application-level resource management,‚Äù
in ACM SOSP, 1995.
[2] D. Williams, P. Reynolds, K. Walsh, E. G. Sirer, and F. B. Schneider,
‚ÄúDevice driver safety through a reference validation mechanism,‚Äù in
USENIX OSDI, 2008.
[3] L. Xia, J. Lange, P. Dinda, and C. Bae, ‚ÄúInvestigating virtual passthrough
i/o on commodity devices,‚Äù SIGOPS Oper. Syst. Rev., vol. 43, no. 3, pp.
83‚Äì94, Jul. 2009.
[4] S. Boyd-Wickizer and N. Zeldovich, ‚ÄúTolerating malicious device drivers
in linux,‚Äù in USENIX ATC, 2010.
[5] PCI-SIG, ‚ÄúMulticast, https://pcisig.com/speciÔ¨Åcations,‚Äù May 2008.
[6] NXP Semiconductors, ‚ÄúI2C-bus SpeciÔ¨Åcation and User Manual,
https://www.nxpcom/docs/en/user-guide/UM10204.pdf,‚Äù April 2014.
[7] ‚ÄúThe Linux Documentation Project,‚Äù http://www.tldp.org/HOWTO/
Plug-and-Play-HOWTO-7.html [Accessed on Jun. 20, 2019], 2007.
[8] Intel, ‚ÄúEnhanced Host Controller Interface SpeciÔ¨Åcation for Universal
Serial Bus,‚Äù 2002.
[9] Intel, ‚ÄúIntel virtualization technology for directed I/O architecture spec-
iÔ¨Åcation,‚Äù Intel Pub. no. D51397-006 rev. 2.2, 2013.
[10] F. L. Sang, ¬¥E. Lacombe, V. Nicomette, and Y. Deswarte, ‚ÄúExploiting an