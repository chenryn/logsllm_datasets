(e.g., routers) to reply with “time-to-live (TTL) expired”
ICMP messages (See §VI-B for measurement results) to
inform the source of a discarded packet due to the TTL
ﬁeld reaching zero. Thus, an attacker can craft packets with
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:48:32 UTC from IEEE Xplore.  Restrictions apply. 
^zE
ƐĞƋсy͕ĂĐŬсϬ
;yͲt/E͕yнt/EͿ
^zEͲ<
ƐĞƋсz͕ĂĐŬсyнϭ
;zͲt/E͕zнt/EͿ
;ĂͿ͘^ĞƋƵĞŶĐĞͲŶƵŵďĞƌͲĐŚĞĐŬŝŶŐĨŝƌĞǁĂůů
Ϭ͍Ϯt/E͍ϰt/E͍͘͘͘
;
;zͲt/E͕zнt/EͿ
;ďͿ͘ƚƚĂĐŬŵŽĚĞů
WŚŽŶĞ
sŝĐƚŝŵ
ƉƉ
hŶͲƉƌŝǀŝůĞŐĞĚ
ŵĂůǁĂƌĞ
&ŝƌĞǁĂůů
ŵŝĚĚůĞďŽǆ
;
ϭ͘^ƉŽŽĨĞĚƉĂĐŬĞƚƐ
;ŽƵƚͲŽĨͲǁŝŶĚŽǁͿ
KĨĨͲƉĂƚŚ
ĂƚƚĂĐŬĞƌ
н
н
ƚ
Ŷ
Ƶ
Ž
Đ
ͺ
ƚ
Ğ
Ŭ
Đ
Ă
W
Ϯ͘^ƉŽŽĨĞĚƉĂĐŬĞƚƐ;/ŶͲǁŝŶĚŽǁͿ
͘
͘
͘
͘
͘
͘
;ϯ͘^ƉŽŽĨĞĚƉĂĐŬĞƚƐ
;ŽƵƚͲŽĨͲǁŝŶĚŽǁͿ
ϰ͘WĂĐŬĞƚͺĐŽƵŶƚннĨĞĞĚďĂĐŬ
͘
͘
͘
d
ƌ
Ǉ
ŝ
Ŷ
Ő

΀
Ϯ
'
ʹ
ϰ
'


΁
ϭ
Ϯ'
Ϯ'
ηŽĨƉĂĐŬĞƚƐ͗
͙͘͘͘
ϭ
ϭ
ϭ
ϭ
Ϯt/E
;Ϳ
ηŽĨƉĂĐŬĞƚƐ͗
ϭ
ϭ
;yͲt/E͕yнt/EͿ
;ĂͿ͘&ŝƌƐƚŝƚĞƌĂƚŝŽŶ
ϭ͙
ϭ
ϯ'
;ďͿ͘^ĞĐŽŶĚŝƚĞƌĂƚŝŽŶ
;Ϳ
;yͲt/E͕yнt/EͿ
ϰ'
ϰ'
Figure 1: Sequence number checking
stateful ﬁrewall and attack model
Figure 2: An attacker tries to infer
sequence number
Figure 3: Sequence number space search
illustration
TTL values large enough to reach the ﬁrewall middlebox,
but small enough that they will terminate at an intermediate
middlebox instead of the end-host,
triggering the TTL-
expired messages. By reading the IPID values generated by
the intermediate hop before and after sending the spoofed
probing packets, an attacker can infer if probing packets
went through the ﬁrewall.
Both side-channels can serve the same purpose. An
attacker can decide which to use depending on their avail-
ability and how noisy the side-channels are.
D. Sequence Number Inference
4G
Now that we know how to obtain the target four-tuple
and feedback regarding which packets are allowed, we need
an efﬁcient way to infer the sequence number. A naive
approach is to test out each individual window sequentially.
In particular, one can check if 0 is in-window, if 2WIN
is in-window, etc. as shown in Figure 1(b). However, that
requires
2W IN round trips to determine which window the
sequence number falls in, which can take too long to ﬁnish.
In Figure 2, we illustrate a much faster approach – a
binary-search-like inference that tries half of the sequence
number space at a time (e.g., 0 to 2G) and iteratively narrow
down the sequence number. Here we assume the ﬁrst threat
model where an unprivileged malware runs on the client
that colludes with an attack server. We also assume that
the attacker has prior knowledge of the ﬁrewall behavior
(e.g., window size), which can be easily obtained ofﬂine.
Figure 2 illustrates the procedure where the attack server
ﬁrst tries the upper half of the sequence number space
[2G,4G). As shown in the ﬁgure, packets at time 1 and 3
are dropped and only a single in-window packet at time 2 is
allowed. Upon receiving the packet, the phone will increase
the packet counter. At time 4, after the attack server ﬁnishes
probing [2G,4G), it can query the malware for the delta of
packet counter before and after the probing. Based on the
incremented packet counter, the attack server knows that
[2G,4G) is the correct range. Otherwise, it is likely that the
other half [0,2G) is the correct one.
In Figure 3, we illustrate this example again via the
sequence number space view. In the ﬁrst iteration trying out
[2G,4G), a series of packets are sent with sequence numbers
on equally spaced interval of 2WIN (with
2W IN number
2G
of packets sent). Given every 2WIN range is covered by
a packet, one and only one packet will be allowed to go
through if the current sequence number kept on the ﬁrewall
indeed falls in [2G,4G). In the second iteration, it continues
to try [3G,4G) to further narrow down the sequence number.
Even though the number of packets sent at each iteration
can be large (especially at the beginning iterations), it is not
hard to see that: 1). the search algorithm takes log2 4G = 32
iterations to complete, which is the same complexity as a
standard binary search algorithm; 2). the larger the WIN
is,
the fewer probing packets are required. We discuss
further optimizations to improve the number of iterations
and inference time in §V.
Note that this example assumes window-advancing ﬁre-
walls. In the case of window-shifting ﬁrewall, similar
procedure still applies yet it only allows an attacker to
determine a range of possible sequence numbers instead
of narrowing down to the exact value. It is because the ﬁrst
in-window packet already erases the original state of the
sequence number by shifting the center of the window away.
Nevertheless, it still can allow an attacker to narrow down
the sequence number to a much smaller range, which in
many cases can be inferred using brute force by the attacker.
We omit the details here and focus on window-advancing
ﬁrewalls given the latter is most commonly observed.
E. Timing of Inference and Injection — TCP Hijacking
For the TCP sequence number inference and subsequent
data injection to be successful, a critical challenge is timing.
If a user is in the middle of a session, injected TCP packets
may not be “meaningful” at all. Speciﬁcally, since the
sequence number inference takes time to ﬁnish, the server
could already send part or all of the response (e.g., HTTP
response). The injected packets then will likely just corrupt
the original response, which may or may not achieve the
attacker’s goal.
To address the challenge, we design and implement a
number of TCP hijacking attacks (described in §IV-B)
where injection can happen at deterministic timing, e.g.,
right after the TCP three-way handshake. This can, for
instance, allow an attacker to inject a complete HTTP re-
sponse without any interference from the original response.
In contrast, TCP Injection is a general term that does not
350
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:48:32 UTC from IEEE Xplore.  Restrictions apply. 
Table I: Summary of identiﬁed TCP sequence number inference attacks and their requirements
Reset-the-server
Packet count IPID Packet count IPID Packet count IPID phishing
Preemptive-SYN
Hit-and-run
Off-site injection Spoofed
URL
conns
Conn
infer
On-site TCP hijacking
Requirement explanation
Malware can read packet counters
Req.
ID
C1 Malware on client with Internet access
C2
C3 Malware can read active TCP four tuples
C4
N1
N2
N3 Client network has NAT boxes deployed
N4 Predictable external port if NAT deployed
N5 Additional ﬁrewall middlebox deployed
S1
Legitimate server has stateful ﬁrewall
S2
Client has coarsely predictable ISNs
A client can spoof another client’s IP
A shared responsive intermediate hop
Attack server closer to client
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
assume any speciﬁc timing of the injection.
IV. TCP ATTACK ANALYSIS AND DESIGN
Applying the basic TCP sequence number inference as
a building block, we detail the design of a number of
TCP attacks, each associated with a list of corresponding
requirements. We show that they are widely applicable and
feasible under many client/server/network combinations.
A. Attack Requirements
We ﬁrst introduce two base requirements for all attacks:
1) the ability to spoof legitimate server’s IP on the Internet,
and 2) a sequence-number-checking ﬁrewall deployed in
the client’s network or anywhere in the network observing
trafﬁc ﬂows in both directions. The former is a known
problem and still widely prevalent on today’s Internet [13],
and the latter is required for the sequence number inference.
Besides the base requirements, we provide a complete
list of requirements in Table I, only a subset of which
are required for any speciﬁc attack. We use “C”, “N”,
and “S” to represent client-side, network, and server-side
requirements.
Client-side requirements mainly have to do with mal-
ware’s capability. For instance, C1 speciﬁes that the mal-
ware needs Internet access. C2 requires access to the ﬁrst
side-channel (i.e., packet counter) to obtain feedback. C3
speciﬁes that the malware can run in the background and
continuously monitor the creation of any new TCP connec-
tion. C1–C3 are common capabilities that an unprivileged
program has in modern OSes. To be more stealthy, the
malware could hide its monitoring activity until the target
app (e.g., browser app) is launched. C4 is a byproduct of the
design decision made in many UNIX-like OSes (e.g., Linux
3.0.1 and earlier) where the ISN for different connections
are not completely independent. Instead, the high 8 bits for
all ISNs is a global number that increments slowly (every
ﬁve minutes) and only the low 24 bits are produced as
random numbers. The design is to balance across security,
reliability, and performance, and it is long perceived as a
good optimization (more details discussed in [7], [2]). The
result of this design is that the ISN of two back-to-back
connections will be at most 224 = 16, 777, 216 apart.
Network requirements relate to policies in the network.
For instance, N1 speciﬁes that client-side IP spooﬁng is
allowed. As discussed, this is fairly common on the Inter-
net [13] and also observable in cellular networks according
to a recent study [32]. N2 corresponds to the second side
channel to obtain feedback as described in §III-C. The
requirement further states that such an intermediate hop
must be on the path for both the attacker connection and
the victim connection for the feedback to be useful (§VI-B
shows more than half of the networks that have sequence-
number-checking ﬁrewalls satisfy this requirement). N3
simply describes that a standard NAT is deployed in the
client’s network. N4 says that the NAT-mapped external
port has to be predictable which is a typical requirement
for P2P applications [28]. The requirement is necessary for
on-site attacks that need externally-mapped four tuples (as
described in the next section). A recent measurement study
on NAT mapping type in cellular networks [32] shows that
the majority of the networks satisfy the requirement. N5
states that there is an additional sequence-number-checking
ﬁrewall deployed in the network, which is actually what we
observe in the nation-wide cellular network. Except for N1,
other requirements are mostly network design decisions and
cannot be classiﬁed as “vulnerabilities.”
Server-side requirement S1 states that
the legitimate
server has to deploy host-based stateful ﬁrewall that drops