requested  a  deadline  of  200 milliseconds  in  each  run  and 
specified that this deadline  be met with  a probability  2 0. 
The second client requested a different deadline in each run. 
For each of these  deadline values  of the  second client, we 
computed the probability  of timing failures in a run of fifty 
requests by measuring the  number of responses  in  the run 
that had failed to arrive by the deadline specified by the sec- 
ond client.  In  order to  study  the  behavior of  the  dynamic 
selection algorithm for different values of the probability of 
timely responses specified by a client, we repeated these ex- 
periments for three different probability  values specified by 
the second client:  1) a probability  value of 0.9, 2) a proba- 
bility value of 0.5, and 3) a probability value of 0. We chose 
a probability  value of 0 because this represents the case in 
which  the dynamic selection  algorithm  would  achieve  the 
highest timing failure rates. Hence, this case would provide 
a perspective on the worst-case behavior of the algorithm. 
Figure 4 shows the expected number of replicas selected 
by  the  dynamic selection  algorithm  to  service  the  second 
client for each of its QoS specifications. The first observa- 
tion  from  this  figure  is  that  as the  deadline  increases,  the 
algorithm chooses, on the average, fewer replicas to service 
the client.  The second observation from this  figure is  that 
the  algorithm  chooses  a  lower  redundancy level  when  the 
client requests a lower probability of timely responses.  For 
114 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:03:31 UTC from IEEE Xplore.  Restrictions apply. 
--. 
-.__ 
-.._ 
I-.... 
- 
0 0 5  
0 
--+----- .._____ 
’.\.\ 
+ ............._.... + ................. 
I.____ 
...,, 
x 
..__.... 
,.__.. 
-. 
,  ---___ 
Client Deadline [milliseconds) 
Figure 5. Validation of the probabilistic model 
example, in the first case in which the client specifies that at 
least 90% of  its responses should be timely, the algorithm 
chooses a redundancy value as high as 6 to meet some of the 
client’s requests.  However,  in  the  third  case in  which  the 
client is  willing  to  tolerate  any  number of timing  failures, 
the algorithm chooses only a redundancy level of 2, which 
is the minimum number of replicas selected by Algorithm  1. 
The reason for these observations is that our algorithm never 
selects more than  the minimum number of  replicas  neces- 
sary to meet a client’s QoS requirement. The less stringent 
a client’s QoS specification,  the higher the probability  that 
a chosen replica will meet the client’s specification.  There- 
fore, as the client’s QoS requirements become more flexi- 
ble, the algorithm can satisfy them with fewer replicas. 
Figure 5 shows how successful the selected set of repli- 
cas, shown  in  Figure 4, were  in  meeting the  QoS specifi- 
cations of the second client.  Figure 5  shows that when the 
client specifies that the probability of timely responses must 
be at least 0.9, the maximum probability  of timing failures 
we observe experimentally is only 0.08, which is lower than 
the  0.1 timing  failure probability  that  the  client is  willing 
to tolerate.  Similarly,  for the  cases in  which  the  client is 
willing  to accept a failure probability  up to 0.5 and  1, we 
observe a maximum timing  failure probability  of 0.32 and 
0.36, respectively, for the deadline values we used.  These 
results  show that,  in  each case, the set of replicas  selected 
by  Algorithm  1 was  able to successfully meet  the  client’s 
QoS requirements by maintaining the timing failure proba- 
bility well below the failure probability  that was acceptable 
to the client. Thus, for the experimental runs we conducted, 
the model we used  was able to accurately predict the set of 
replicas that would be able to meet the client’s deadline with 
at least the probability requested by the client. 
The above results show that at the expense of some com- 
putational  overhead, the dynamic selection scheme we have 
described makes  effective  use  of  the  available  replicas to 
meet the QoS specifications  and thereby reduce the occur- 
rence  of  timing  failures,  even  when  multiple  clients  ac- 
cess  a  service at  the  same  time.  We  believe  that  such  a 
replica selection scheme would be useful in an environment 
in which time-critical clients access compute-bound service 
providers that display  variability  in their response times. 
7. Related Work 
We now briefly mention  a few of the related efforts that 
address the problem of detecting and preventing timing fail- 
ures for clients in a distributed  system. 
The DREAM project  [ 1 11 provides an integrated  object 
based  framework for  tolerating  crash  faults,  value  faults, 
and timing faults in a real-time, distributed system by using 
a primaryhackup replication  scheme.  While the DREAM 
approach tries to prevent timing failures from occurring as 
a  result  of  replica  crashes, it  does not  handle timing  fail- 
ures occurring due to the load induced when multiple clients 
concurrently access a service. Our research goals are related 
to the  work  done by Wolfe  [22], which  also addresses the 
problem of  meeting the  time  constraints when  a CORBA 
service  is  accessed  by  multiple  clients.  Their  approach, 
however,  uses  a  global  scheduling  service that  assigns  a 
global CORBA priority  to a  request,  based  on  the  timing 
requirements expressed  by  the client.  This priority  is then 
used to determine the order in which a server services the re- 
quest. The work done by Wolfe does not, however, address 
replica crashes.  Verissimo  and Casimiro have  proposed  a 
general architectural construct called the Timely Conpiring 
Base  (TCB) [21] that can verify timeliness and detect time 
failures,  properties  that  are essential for building  depend- 
able and timely services.  The timing fault handler we have 
implemented realizes  some of  these properties for a repli- 
cated service. 
8. Concluding Remarks 
We  have  presented  a  new  approach  that  tolerates  tim- 
ing faults in replicated  services.  This approach uses an al- 
gorithm that chooses replicas  dynamically at request  time, 
based  on their ability to meet  a client’s time constraints in 
the presence of delays and  replica crashes.  An  important 
contribution of  this  paper  is the definition  of  a probabilis- 
tic model  to predict, at runtime, the probability  that the re- 
sponse from a replica  will arrive by a given time, based  on 
the performance updates the model receives from the replica 
as  inputs.  This prediction  made  by  a  scheduler, which  is 
part  of  the  timing  fault  handler, is  used  to  select a  set of 
replicas that  can  meet  a  client’s timing  constraint with  at 
115 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:03:31 UTC from IEEE Xplore.  Restrictions apply. 
least the probability  requested by  the  client.  We have im- 
plemented the selection algorithm in AQuA, an infrastruc- 
ture  for building  dependable distributed  applications,  and 
obtained  experimental results  that  show its  efficacy.  Our 
model and selection algorithm can be easily extended to any 
environment that provides replicated  services and supports 
a mechanism for tracking and recording the recent  history 
of the performance of its replicas. 
We now mention a few extensions to our work.  First, in 
this  work,  we  have assumed that the  servers export a sin- 
gle method interface to  the  client.  It is possible to  extend 
our work to support the case in which a server exports mul- 
tiple  service  interfaces.  We  can  do this  by  modifying the 
information  repository  to classify  performance data based. 
on the method interfaces.  The selection algorithm can then 
use the performance information appropriate to the method 
invoked.  Second, in a system in which the middleware has 
knowledge about an application’s request semantics, our se- 
lection  algorithm  can  be  extended  to  distinguish  between 
requests  made to  the  same server based on the arguments 
passed by the clients.  Our infrastructure currently does not 
support this feature. Finally, our work can also be extended 
to use active probes [5] when a replica’s performance infor- 
mation is obsolete. 
Acknowledgments:  We are thankful to the anonymous 
reviewers for their careful feedback, which helped us to im- 
prove our work. We would like to thank Mouna Seri and the 
rest of the AQuA team for their contributions to the AQuA 
project.  We are also grateful to Jenny Applequist for help- 
ing us to improve the readability of the paper. 
References 
111  K. Birman. Replication and Fault Tolerance in the ISlS Sys- 
tem.  In  Proc.  of  the  10th ACM  Symp.  Operating Systems 
Principles, pages 79--86, December 1985. 
[2]  R. Carter and  M. Crovella.  Dynamic  Server Selection us- 
ing Bandwidth Probing in Wide Area Networks.  Technical 
report, Boston  University, BU-CS-96-007, 1996. 
[3]  M.  Cukier, J.  Ren, C.  Sabnis, et  al.  AQuA: An  Adaptive 
Architecture that Provides Dependable Distributed Objects. 
In IEEE Symposium on Reliable Distributed Systems, pages 
245-253,  October 1998. 
[4]  C.  Fegg,  K.  Moore,  J.  Dongarra,  and  A.  Geist. 
Scal- 
Information  Processing  Environ- 
netlib2.cs.utk.edu/utk/people/ 
able  Networked 
ment. 
JackDongarra/PAPERS/snipe.html. 
[5]  Z. Fei, S. Bhattachajee, E. W.  Zegura, and  M.  H. Ammar. 
A  Novel  Server Selection Technique for Improving the Re- 
sponse Time of  a Replicated Service. In Proceedings of IN- 
FOCOM  ’98, March  1998. 
[6]  P. Felber, X. DCfago, P. Eugster, and A. Schiper. Replicating 
CORBA Objects:  A  Marriage between Active  and Passive 
Replication.  In Second  IFIP International Working Confer- 
[I21  M. C. Little.  Object Replication  in  a  Distributed System. 
PhD thesis, University of  Newcastle upon Tyne, September 
1991.  ftp: //arjuna.ncl .ac .uk/pub/Arjuna/ 
Docs/Theses/TR-376-9-9l~EuropeA4.tar.Z. 
[ 131  Microsoft.  Microsoft  Windows  Active  Directory:  An 
Introduction  to 
the  Next  Generation  Directory  Ser- 
vices.  Technical  report,  Microsoft  Corporation,  1999. 
msdn.microsoft.com/library/backgrnd/ 
html/msdn-actdirintro.htm. 
141  L. E. Moser, P.  M. Melliar-Smith, and P.  Narasimhan.  A 
Fault Tolerance Framework for CORBA.  In Proceedings of 
the IEEE International Symposium on Fault-Tolerant  Com- 
puting, pages 150-157,  June 1999. 
151  OMG.  CORBA Object Request Broker Architecture-Version 
ence on Distributed Applications and Interoperable Systems 
(DAIS’99), pages 375-387,  Helsinki, Finland, June 1999. 
[7]  R. Guerraoui and  A. Schiper.  Software-Based Replication 
for Fault Tolerance.  IEEE  Computer, pages  68-74,  April 
1997. 
[8]  M. Hayden. The Ensemble System. PhD thesis, Cornell Uni- 
versity, January  1998.  www. cs. cornell. edu/Info/ 
Projects/Horus/Papers.html. 
[9]  J. Heidemann and  V.  Visweswaraiah.  Automatic Selection 
of  Nearby  Web  Servers.  Technical  report,  University  of 
Southern California, USC TR 98-688, 1998. 
[IO]  E.  Katz,  M.  Butler, and  R.  McGrath.  A  Scalable HTTP 
Server  :  The  NCSA  Prototype.  Computer Networks  and 
ISDN Systems, 27: 155-1 64, 1994. 
[ l l ]   K.  Kim  and  C.  Subburaman.  ROAFTS:  A  Middleware 
Architecture for Real-Time Object-Oriented Adaptive Fault 
Tolerance Support. In IEEE High Assurance Systems Engi- 
neering, pages 50-57,  Nov  1998. 
2.2.  www. omg. org/docs/orbos. 
[I61  J. Ren, M.  Cukier, and  W.  H.  Sanders.  An Adaptive Algo- 
rithm for Tolerating Value Faults and Crash Failures.  IEEE 
Transactions on Parallel  and  Distributed  Systems.  Special 
Issue on Dependable Network  Compi4ting, To appear. 
[ 171  P. Rubel. Passive Replication in the AQuA System. Master’s 
thesis, University  of  Illinois at  Urbana-Champaign, 2000. 
www.crhc.uiuc.edu/PERFORM. 
[18]  C.  Sabnis,  M.  Cukier,  J.  Ren,  et  al.  Proteus:  A  Flexi- 
ble Infrastructure to Implement Adaptive Fault Tolerance in 
AQuA.  In IFIP International  Working  Conference on De- 
pendable  Computing for Critical Applications, pages  149- 
168, January 1999. 
[I91  M.  Sayal, Y. Breitbart, P.  Scheuermann, and  R. Vingralek. 
Selection Algorithms for Replicated Web Servers. In  Work- 
shop on Internet Server Performance, June 1998. 
[20]  A.  Vaysburd.  Building  Reliable  Interoperable Distributed 
Applications  with  Maestro  Tools.  PhD  thesis,  Cornell 
University, May  1998. www. cs. cornell. edu/Info/ 
Projects/Horus/Papers.html. 
[21]  P.  Verissimo  and  A.  Casimiro.  The  Timely  Comput- 
ing  Base.  Technical  Report  TR-99-2,  Univ.  of  Lisboa, 
May  1999. www.navigators.di. fc.ul.pt/docs/ 
abstracts/tcbmodel.html. 
[22]  V.  Wolfe, L. Dipippo, R. Ginis, M.  Squadrito, S. Wohlever, 
and 1. Zykh.  Expressing and Enforcing Timing Constraints 
in a  Dynamic Real-Time CORBA System.  Real  Time Sys- 
tems, 16:253-280,  1999. 
116 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:03:31 UTC from IEEE Xplore.  Restrictions apply.