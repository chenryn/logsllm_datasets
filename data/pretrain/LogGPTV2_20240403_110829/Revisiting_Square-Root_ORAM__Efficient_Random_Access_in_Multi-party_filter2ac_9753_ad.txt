corresponding Waksman control bits. This is then used
to jointly permute the elements of the secret permutation
π−1, producing π−1·πa = πb. Next, πb is revealed to the
second party, Bob (but not to Alice). Bob does not learn
anything about π−1 because it is masked by πa. Bob now
locally computes π−1
b , and the two parties jointly execute
another Waksman network to compute πa · π−1
b = π.
V. EVALUATION
To evaluate our design, we implemented our Square-
Root ORAM design and Circuit ORAM,
the best-
performing previous ORAM design, using the same
state-of-the-art MPC frameworks, and measured their
performance on a set of microbenchmarks. We also
wanted to understand the impact of different ORAM
designs on application performance, and how close we
are to enabling general-purpose MPC. To this end, we
implemented several application benchmarks represent-
ing a wide range of memory behaviors and evaluated
their performance with different ORAM designs.
A. Experimental Setup
We implemented and benchmarked RAM-SC proto-
cols based on our ORAM as well as Circuit ORAM,
using the Obliv-C [40] framework executing a Yao’s
garbled circuit protocol. Obliv-C provides a C-like lan-
guage interface, and it incorporates many recent opti-
mizations [3, 17, 41].
All code was compiled using gcc version 4.8.4, with
the -O3 ﬂag enabled. Unless otherwise speciﬁed, all
reported times are wall-clock time for the entire pro-
tocol execution. Our benchmarks were performed with
commercially available computing resources from Ama-
zon Elastic Compute Cloud (EC2). We used compute-
optimized instances of type C4.2xlarge running Ama-
zon’s distribution of Ubuntu 14.04 (64 bit). These notes
provide four physical cores (capable of executing eight
simultaneous threads in total), partitioned from an In-
tel Xeon E5-2666 v3, and 15 GiB of memory Our
benchmarks are all single-threaded and cannot saturate
the processing power available. We selected C4.2xlarge
nodes on the basis of the greater bandwidth and memory
they offer. Each benchmark was executed between two
separate nodes within the same datacenter. We used iperf
to measure the inter-node bandwidth, and found it to be
about 1.03 Gbps.
In addition to square-root ORAM, we benchmarked
a simple linear scan and an implementation of Circuit
ORAM, the best previously reported ORAM construc-
tion for MPC. Our implementation of Circuit ORAM
Fig. 8: Per-access cost crossover points between
ORAM schemes. Below the green line, linear scan is
most efﬁcient. Above the red line, Circuit ORAM is most
efﬁcient. Between the two, Square-Root ORAM is most
efﬁcient.
is much more efﬁcient than the original implementa-
tion described in Wang et al. [34]. For example, while
executing benchmarks on an Amazon C4.8xlarge EC2
instance for an ORAM of one million 32-bit blocks,
they reported an access time of two seconds. On a less
powerful, more bandwidth-constrained C4.2xlarge EC2
instance, our implementation requires only 0.16 seconds
per access for an ORAM with the same parameters. This
reduction by a factor of roughly twelve is mostly due
to the efﬁciency advantages of the Obliv-C framework
over the ObliVM [24] framework used by Wang et
al.’s implementation. For all performance reported in the
following, we let Circuit ORAM and square-root ORAM
pack 8 entries in each recursive level. Circuit ORAM
stops recursion when there are fewer than 28 entries.
B. Microbenchmarks
We performed several microbenchmarks to assess the
granular performance of different ORAM designs. We
observed single-access execution time for block counts
varying from 4 to 1024 and block sizes varying from
4 to 1024 bytes. This is the region of parameter space
where the efﬁciencies of Square-Root ORAM and linear
scan overlap. Figure 8 shows the efﬁciency crossover
points derived from this data, ignoring initialization cost.
Due to the nature of the Square-Root ORAM algorithm,
each access is more expensive than the previous one,
until a shufﬂe occurs and resets the cycle. To ensure our
averages truly are representative, we collected a number
of samples for each ORAM conﬁguration equal to a
228228
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:11:03 UTC from IEEE Xplore.  Restrictions apply. 
2223242526272829210211212Block Size (bytes)242628210212214216218220Number of BlocksLinear Scan FasterSquare-Root ORAM FasterCircuit ORAM FasterFig. 9: Cost per access omitting initialization. Solid
lines are for block size of 16 bytes, dashed lines are for block
size of 32 bytes. We collected a number of samples for each
ORAM conﬁguration equal to a multiple of the Square-Root
ORAM shufﬂe period that is greater than thirty, except in the
case of linear scan, for which exactly thirty samples were
collected.
multiple the shufﬂe period that is greater than thirty,
except in the case of linear scan, for which exactly thirty
samples were collected.
Breakeven points. Linear scan is preferred to Square-
Root ORAM only for very small numbers of blocks.
Circuit ORAM is orders of magnitude more expensive
for similar parameters, due to its high ﬁxed access cost.
Our Square-Root ORAM implementation achieves a very
low break-even point with linear scan. When using 4096
or fewer blocks, Circuit ORAM never wins over. And
at a block size of 4 bytes, Circuit ORAM remains a
suboptimal choice until we have more than 500,000
blocks. But that, in turn, increases initialization cost.
Comparison to Circuit ORAM. In comparing our
Square-Root ORAM scheme to Circuit ORAM, we con-
sider initialization and access costs separately since the
number of accesses per initialization will vary across
applications. Figure 9 shows the per-access wall-clock
time for both designs, as well as for linear scan, ignoring
initialization.
As expected, Circuit ORAM has the best asymptotic
performance, but it also has a very high ﬁxed cost per
access, independent of the number of blocks. As a result,
Square-Root ORAM performs better than Circuit ORAM
for all block counts up to 216, even ignoring initialization
costs. In fact, for block counts less than ~211 linear
scan also outperforms Circuit ORAM. These results are
Fig. 10: Cost of initialization. Solid lines are for block
size of 16 bytes, dashed lines are for block size of 32 bytes.
consistent with our analysis in Section III-D that Square-
Root ORAM has worse asymptotic behavior, but smaller
hidden constants.
For any application where the number of accesses is
not signiﬁcantly larger than the number of blocks in the
ORAM, initialization cost must be considered. Figure 10
shows the initialization wall-clock times for Square-Root
and Circuit ORAM, with parameters matching those
in our access-time comparison. For this benchmark,
we assume each ORAM must be populated using data
already stored in an array of oblivious variables. In such
a scenario, a linear scan ORAM requires only that the
data be copied; the reported linear scan initialization
speed is therefore equivalent to the time required to copy
the data.
Initializing Square-Root ORAM is approximately 100
times faster than initializing Circuit ORAM, regardless
of block count or block size. The standard way to
populate Circuit ORAM is to insert each data element
individually, using standard ORAM access operations;
thus, the cost scales linearly with the number of blocks
to be populated. We hypothesize that most of this speed
improvement comes from having fewer network round
trips in our initialization process. Circuit ORAM there-
fore requires Θ(N logN) round trips for initialization,
while our scheme requires only Θ(logN).
C. Oblivious Binary Search
Unlike our other application benchmarks, binary
search performs very few accesses relative to the ORAM
size. An equivalent search can be performed using a sin-
gle linear scan, and if only one search is to be performed,
the linear scan is always more efﬁcient. Consequently,
229229
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:11:03 UTC from IEEE Xplore.  Restrictions apply. 
23252729211213215217219Number of Blocks10-410-310-210-1100101102Running Time per Access (seconds)Linear ScanCircuit ORAMSquare-Root ORAM23252729211213215217219Number of Blocks10-710-610-510-410-310-210-1100101102103104105Running Time per Init (seconds)Linear ScanCircuit ORAMSquare-Root ORAMBenchmark
Binary Search
Parameters
1 search
25 searches
210 searches
Breadth-First Search
Gale-Shapley
Scrypt
n = 22
n = 25
n = 210
23 pairs
26 pairs
29 pairs
N = 25
N = 210
N = 214
Litecoin
Linear Scan
Square-Root ORAM Circuit ORAM
1.00
31.87
1019.77
0.09
4.77
4569.31
-
-
-
10.41
26.25
824.81
0.34
4.08
679.63
0.51
145.13
3228.69
3282.40
5040.82
4.28
42.66
3750.57
6.57
1328.50
119405.
188972.
4.11
1678.16
about 7 days
210.92
3.43
293.79
1919.92
40.29
34.47
1453.85
2846.51
247.29
TABLE I: Summary of benchmark results. All benchmark results are average measured wall-clock time in seconds
for full protocol execution (see individual benchmark sections for details).
we varied the number of searches performed for this
benchmark, rather than the block size or block count.
We benchmarked binary search using a block size of
16 bytes and element counts of 210 and 215. For arrays
of 210 elements, we averaged the running time over 30
samples, and for 215 elements we use 3 samples. A few
representative combinations for 215 elements are reported
in Table I.
Initialization dominates execution time unless many
searches are performed on the same data. As a result,
Square-Root ORAM is more than two orders of magni-
tude better than Circuit ORAM when only one search is
performed. For searches of 210 elements, the linear scan
method is more efﬁcient than a binary search regardless
of the ORAM type or the number of searches performed.
Linear scan is initially faster for searches of 215 elements
as well, but Square-Root ORAM becomes more efﬁcient
than the linear scan method at 25 searches. Accesses to
a Circuit ORAM of 215 elements are more expensive
than accesses to a Square-Root ORAM of the same size,
so at this array size, Circuit ORAM will never be more
efﬁcient regardless of the number of searches performed.
D. Oblivious Breadth-First Search
formulations
Natively-oblivious
of Breadth-First
Search (BFS) and other graph algorithms have been
explored in the past [5]; however, we use a variant of
the standard algorithm optimized for use in an oblivious
context. It has complexity in Θ((V + E)CAccess), where
CAccess is the complexity of accessing an element in
the underlying ORAM construction. We allow our
ORAM implementations to apply arbitrary functions
to modify the blocks they access, as opposed to the
simple read and write functions shown in Figure 2.
This reduces the total number of ORAM accesses by,
for example, permitting combined read and update
operations. Rather than use an ORAM to house the
queue, we use the oblivious queue data structure from
Zahur and Evans [39].
We benchmarked our BFS implementation using linear
scan, Circuit ORAM, and Square-Root ORAM. We took
30 samples for experiments of n vertices and γ × n
edges, with n ranging from 4 to 1024 and γ as 8.
For each sample, a fresh set of edges were generated
randomly among the chosen number of vertices. A few
representative combinations are shown in Table I.
The results of the BFS benchmark roughly follow
the pattern established by the microbenchmarks in Sec-
tion V-B. Small numbers of vertices and edges yield
small ORAMs, and linear scan proves to be best in these
cases. As the number of vertices or edges begins to rise,
Square-Root ORAM quickly becomes more efﬁcient
than linear scan. Our BFS implementation uses blocks
of only a few bytes each; as a result, Circuit ORAM
eventually becomes more efﬁcient than linear scan, but
it does not approach the efﬁciency of Square-root ORAM
before the upper bound of our testing range is reached at
n = 210. Beyond that point the benchmarks would have
required several hours to complete.
E. Oblivious Stable Matching
To explore a benchmark representative of a com-
plex algorithm, we implemented an oblivious version
of the Gale-Shapley stable matching algorithm [8]. We
230230
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:11:03 UTC from IEEE Xplore.  Restrictions apply. 
followed the textbook algorithm closely. Although we
believe there are signiﬁcant optimizations available in
adapting the algorithm for use in MPC, they are beyond
the scope of this work.
As a result, our implementation requires Θ(n2) ac-
cesses of an ORAM with n2 elements. It also uses of sev-
eral ORAMs of length n. The most efﬁcient arrangement
may be to mix ORAM schemes, but we have not done
this. As in our BFS implementation, we used function
application to reduce the number of ORAM accesses.
We benchmarked our implementation of Gale-Shapley
with both Circuit and Square-Root ORAMs as the under-
lying structure, but not linear scan since it is clear linear
scan cannot be competitive for this benchmark and the
expense of executing it on non-trivial sizes would be
considerable. The number of pairs to be matched ranged
from 4 to 512. When the pair count was less than 128,
we collected 30 samples; for pair counts of 128 and 256
we collected 3 samples; for 512 pairs, we collected one
sample. Results for few representative conﬁgurations are
included in Table I.
Square-root ORAM proved more efﬁcient over the