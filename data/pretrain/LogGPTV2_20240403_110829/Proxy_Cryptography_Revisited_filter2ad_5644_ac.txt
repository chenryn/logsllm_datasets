FDec) be an unidirectional El Gamal encryption scheme.
E 0 is CPA secure against (1) the proxy P, (2) the user F,
and (3) any user U.
4.3 Unidirectional RSA Encryption Scheme
Let’s assume we have the RSA encryption scheme E =
(Enc-Gen; Enc; Dec). The RSA key generation algorithm
outputs the public key EK = (e; N ) and the secret key
SK = (d; N; ’(N )), where ed = 1 mod ’(N ), N = pq, p,
q are two large primes and ’ is the Euler totient function.
The encryption is deﬁned as EncEK(m) = me mod N = c.
The decryption algorithm is DecEK(c) = cd mod N = m.
The unidirectional key generation algorithm E 0 =
(UniGen, UniEnc, UniDec, PDec, FDec). For each user
U, the key generation algorithm UniGen(1k) generates a
public-key pair (EK; DK) and splits the secret key into two
parts d1 and d2 such that d = d1d2 mod ’(N ). The proxy
P gets DKP = d1 and the user F gets DKF = d2. The
encryption UniEnc and the UniDec algorithms are iden-
tical to the original algorithms Enc and Dec. The trans-
formation functions PDec and FDec execute the Dec de-
cryption algorithm with keys d1 and respectively d2. The
correctness of unidirectional RSA is given by the equality
FDecd2(PDecd1(Ence(m))) = m.
The original RSA scheme is OW-CPA secure. Thus,
we will prove in the next theorem that unidirectional RSA
is also OW-CPA secure. The proofs are in Appendix A.3.
Theorem 3 Let E 0 = (UniGen, UniEnc, UniDec, PDec,
FDec) be an unidirectional RSA encryption scheme. E 0 is
ONE-WAY secure against (1) the proxy P, (2) the user F,
and (3) any user U.
4.4 Unidirectional
Scheme
Identity-Based Encryption
Our speciﬁc IBE scheme is a slightly modiﬁcation of the
original IBE scheme introduced by [5]. The original IBE
scheme uses a bilinear map ^e deﬁned as ^e : G1(cid:2)G1 ! G2,
where G1 and G2 are two groups of order q and q is a large
prime number. This means that ^e(aP; bQ) = ^e(aQ; bP ) =
^e(P; Q)ab, where P; Q 2 G1 and a; b 2 Zq. The origi-
nal scheme bases its security on the computational Bilinear
Difﬁe-Hellman problem.
In order to obtain a homomor-
phic scheme, we make a stronger assumption (decisional
Bilinear Difﬁe-Hellman problem), eliminate the use of a
hash function, require that the messages are m 2 G2, and
replace the XOR operation by multiplication.
Our
scheme
is
deﬁned as
=
The key generation al-
(Enc-Gen; Extract; Enc; Dec).
gorithm creates the master secret key s and the master
public key Ppub = sP . For every user U, the Extract
tuple E
the
algorithm takes as input the user’s ID and returns a secret
key DK = sID and a public key equal to the ID. The
user’s ID is actually deﬁned to be the hash value of the
“real” ID. The encryption algorithm Enc takes the message
m and the public key ID as the input and creates the
ciphertext hU; V i = hrP; m^e(rID; sP ))i. The decryption
algorithm Dec computes V =^e(sID; U )) = m. The IBE
scheme is CPA secure if the Bilinear Difﬁe-Hellman
(BDH) problem is hard.
Decisional Bilinear Difﬁe-Hellam Problem (dBDH).
Let G1 and G2 be two groups of prime order q. Let ^e : G1(cid:2)
G1 ! G2 be a bilinear map and let P be a generator for
G1. The decisional BDH problem hG1; G2; ^ei is deﬁned
as follows: Given hP; aP; bP; cP i for some a; b; c 2 Z(cid:3)
q,
it is hard to differentiate ^e(P; P )abc 2 G2 from a random
g 2 G2.
Based on our speciﬁc IBE scheme E, we will build
an unidirectional IBE scheme E 0 = (UniGen, UniEnc,
UniDec, PDec, FDec).
The key generation algo-
rithm UniGen uses the original key generation algorithm
Enc-Gen to create the master secret key s and the master
public key Ppub = sP . The master secret key is split in
two parts s1 and s2, and each part is given to the proxy P
and the user F. The encryption and decryption algorithms
are identical with the original ones. PDec is deﬁned as
PDec(U; V ) = hU; V =^e(rP; s1ID)i = (U; V 0). The user
F uses the ciphertext generated by PDec and the function
FDec to compute the cleartext message m by computing
V 0=^e(rP; s2ID).
Theorem 4 Let E 0 = (UniGen, UniEnc, UniDec, PDec,
FDec) be an unidirectional IBE encryption scheme. E 0 is
CPA secure against (1) the proxy P, (2) the user F, and (3)
any user U.
In all the other unidirectional schemes, the proxy P
has the increased space problem because it needs to save
one key for every user. Our modiﬁed homomorphic IBE
scheme solves this problem by allowing the proxy agent P
to save only a single share of the master key for the entire
system.
5 Unidirectional Signature Primitives
Deﬁnition 3 A unidirectional
signature scheme consists
of ﬁve algorithms: S = (UniGen, UniSig, UniVer, PSig,
FSig).
The generation algorithm UniGen(1k) outputs a tuple
of keys (SK,VK) for each user U. VK is the veriﬁcation
key and SK is the signing key. SK is used to generate
the keys SKP and SKF given to the proxy P, respectively
the user F. The signature algorithm UniSig signs a mes-
sage m 2 M (e.g. f1; 0gk), s = UniSigSK(m) using
the secret key SK. The signature is formed by the tuple
(m; s). The veriﬁcation algorithm UniVer uses the pub-
lic key to verify that a signature (m; s) is valid. The ver-
iﬁcation algorithm output succeed if the signature is cor-
rect and fail otherwise. The correctness property requires
that UniVer(UniSig(m)) = succeed. The proxy P uses the
function PSig to generate a partial signature of a message
m 2 M based on SKP. The user F uses FSig to generate
a partial signature of a message m 2 M based on SKF.
PSig(FSig(m)) form a complete signature of the message
m.
We deﬁne the unidirectional signature scheme to be safe
if neither entity (proxy P, user F, user U) can generate alone
valid signatures under key SK, even if they know SKP or
SKF and any of the available public information. The for-
mal deﬁnitions are given in table 3.
5.1 Unidirectional Generic Signature Scheme
This generic scheme transforms any given signature
primitive into a unidirectional generic signature scheme.
Let’s assume that S = (Sig-Gen; Sig; Ver) is a standard
signature scheme. The new unidirectional generic sig-
nature scheme is S 0 = (UniGen, UniSig, UniVer, PSig,
FSig). The generation algorithm UniGen generates two
pairs of keys (SK1; VK1; SK2; VK2) for each user U. The
secret key for the unidirectional signature scheme is SK =
(SK1; SK2). The proxy P gets (VK1; VK2; SKP = SK1)
and the user F gets (VK1; VK2; SKF = SK2). The sig-
nature algorithm UniSig generates a valid signature for a
message m 2 M by applying the signature Sig twice:
s = (s1; s2) = Sig1(m)Sig2(m). Similarly, the veriﬁca-
tion algorithm UniVer veriﬁes whether the signatures gen-
erated by UniSig are valid by applying the original veriﬁ-
cation algorithm Ver algorithm twice: Ver1(s1)Ver2(s2).
The proxy P uses PSig to generate part of the total
unidirectional signature: Sig1(m), while the user F uses
FSig = Sig2(m) to generate the entire signature together
with PSig.
According to our deﬁnitions, the generic unidirectional
signature scheme is secure if the following theorem is
proved to be true. The actual proofs are contained in Ap-
pendix B.1.
Deﬁnition 4 Let S = (UniGen, UniSig, UniVer, PSig, FSig) be an unidirectional signature scheme.
1. S is UF-CMA against the proxy P if jSuccP;S(1k)j is negligible, SuccP;S is deﬁned as below, and the proxy P
is not allowed to ask the FSig oracle for UniSig(m).
SuccP;S
def
(SK; VK)   UniGen(1k); (m; s)   PFSig(SKP; VK) i
2. S is UF-CMA against the user F if jSuccF;S (1k)j is negligible, SuccF;S is deﬁned as below, and the user F is
= Pr h UniVer(m; s) = succeed (cid:12)(cid:12)(cid:12)
not allowed to ask the signature oracle for UniSig(m).
SuccF;S
(SK; VK)   UniGen(1k); (m; s)   FUniSig(SKF; VK) i
3. S is UF-CMA against any user U if jSuccU;S(1k)j is negligible for any PPT adversary U, SuccU;S is deﬁned
def= Pr h UniVer(m; s) = succeed (cid:12)(cid:12)(cid:12)
as below, and the user U is not allowed to ask the signature oracle for UniSig(m).
SuccU;S
def= Pr h UniVer(m; s) = succeed (cid:12)(cid:12)(cid:12)
(SK; VK)   UniGen(1k); (m; s)   UUniSig(VK) i
Table 3. Online signature deﬁnitions.
Theorem 5 Let S = (Sig-Gen; Sig; Ver) be a standard
signature scheme. Let’s consider S 0 = (UniGen, UniSig,
UniVer, PSig, FSig) a unidirectional signature scheme
constructed as described above, based on S. If S is UF-
CMA , than S 0 is UF-CMA against (1) the proxy P, (2) the
user F, and (3) any user U.
The unidirectional generic signature scheme has two
main performance disadvantages. First, the size of the se-
cret key increases. Each user no longer has one, but two
keys. Second, the number of operations performed when
signing and verifying doubles. In order to improve these
numbers, we developed an efﬁcient unidirectional signa-
ture scheme based on RSA-Hash.
5.2 Unidirectional RSA-Hash Signature Scheme
Let’s assume that we have S = (Sig-Gen; Sig; Ver)
a standard RSA-Hash(Full Domain Hash) [1] signature.
Sig-Gen generates the public key VK = (e; N ) and the
secret key SK = (d; ’(N )). The signature function is de-
ﬁned as Sig = hash(m)d mod N = s, where hash is a
hash function associated with Sig. The veriﬁcation returns
succeed if se = hash(m) mod N. Otherwise, it returns
fail.
for all users U by executing Sig-Gen and then splits each
secret key d in two parts d = d1 + d2 mod’(n). d1 be-
comes the key SKP of the proxy P and d2 becomes the
key SKF of the user F. The signature and veriﬁcation al-
gorithms UniSig and UniVer are identical with the original
algorithms Sig and Ver. The user F uses the FSig function
to generate one part of the unidirectional RSA-Hash sig-
nature by computing s0 = Sigd2(m). The proxy P uses
the PSig function to generate the other part of the unidi-
rectional RSA signature by computing s = Sigd1(m). The
signature is formed by s and s0.
The standard RSA-Hash signature scheme is existen-
tially unforgeable against chosen message attacks. Thus,
we formally prove in the next theorem that the unidirec-
tional RSA-Hash scheme holds the same level of security.
The actual proofs are in Appendix B.2.
Theorem 6 Let S = (Sig-Gen; Sig; Ver; ) be a classic
RSA-Hash signature scheme. Let’s consider that S 0 =
(UniGen, UniSig, UniVer, PSig, FSig) is an unidirectional
RSA-Hash signature scheme constructed as above. S 0 is
UF-CMA against (1) the proxy P, (2) the user F, and (3)
all users U.
The standard RSA-Hash signature scheme S is trans-
formed into a unidirectional signature scheme S 0 =
(UniGen, UniSig, UniVer, PSig, FSig) by the following
steps. The key generation algorithm UniGen generates keys
The probabilistic RSA-Hash described by [7] has better
security that the RSA-Hash function used above, and can
be transformed into an unidirectional primitive if we allow
the user F to generate the necessary randomness.
6 Bidirectional Encryption Primitives
Deﬁnition 5 A bidirectional encryption scheme consists of
four algorithms: E = (BiGen, BiEnc, BiDec, (cid:5)).
The key generation algorithm BiGen outputs one pair of
keys (EKU,DKU) for each user U. In addition, it generates
keys for the user F, (EKF,DKF). After that, it creates one
bidirectional key (cid:25) for each user U. The bidirectional keys
(cid:25) are given to proxy P. The encryption algorithm BiEncEK
takes as input a message m to be encrypted and a public key
EK and outputs the ciphertext e = BiEncEK(m). BiDecDK
is the deterministic decryption algorithm that takes the ci-
phertext e, the secret key DK corresponding to the pub-
lic key, and produces m 2 M (or invalid in case e was
an improper ciphertext). The correctness property of en-
cryption states that BiDec(BiEnc(m)) = m, for any m and
(EK; DK). (cid:5) is the bidirectional function and transforms
ciphertexts encrypted with one key (EKU) into ciphertexts
encrypted with another key (EKF).
We deﬁne the bidirectional encryption schemes to be
secure if neither the third party (proxy P) nor the users