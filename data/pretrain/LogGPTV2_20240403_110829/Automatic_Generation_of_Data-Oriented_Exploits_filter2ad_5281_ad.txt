vsprintf 
 Attack  
100 
3 
0 
5 
%X$n  
0 
time 
7 
(b) 
Figure 7: Stitch by complete memory address reuse of sudo. The
dashed line is the new edge (single-edge stitch). An address of ud.uid
exists on ancestor’s stack frame, which is reused to overwrite ud.uid.
the stack base address. Figure 7 shows the 2D-DFGs for
the benign execution and the attack. This attack works
even if the ﬁne-grained ASLR is deployed.
Identifying Stitch by Address Reuse. Memory error in-
structions for address reuse stitch should match the pat-
terns we discuss above. For partial address reuse, the
memory error exploit corrupts variable offsets, while for
complete address reuse, the memory error exploit can re-
trieve addresses from memory. Our approach intersects
the memory error inﬂuence I with the source ﬂow and
the target ﬂow. Then we search from the new source ﬂow
and the new target ﬂow to identify matched instructions,
from which we can build stitch by address reuse with
methods discuss above.
4 The FLOWSTITCH System
We design a system called FLOWSTITCH to system-
atically generate data-oriented attacks using data-ﬂow
stitching. As shown in Figure 8, FLOWSTITCH takes
three inputs: a program with memory errors, an error-
exhibiting input, and a benign input of the program. The
two inputs should drive the program execution down the
same execution path until the memory error instruction,
with the error-exhibiting input causing a crash. FLOW-
STITCH builds data-oriented attacks using the memory
errors in ﬁve steps. First, it generates the execution trace
for the given program. We call the execution trace with
the benign input the benign trace, and the execution trace
with the error-exhibiting input the error-exhibiting trace.
Second, FLOWSTITCH identiﬁes the inﬂuence of the
memory errors from the error-exhibiting trace and gen-
erates constraints on the program input to reach memory
errors. Third, FLOWSTITCH performs data-ﬂow anal-
ysis and security-sensitive data identiﬁcation using the
benign trace. Fourth, FLOWSTITCH selects stitch can-
didates from the identiﬁed security-sensitive data ﬂows
with the methods discussed in Section 3. Finally, FLOW-
STITCH checks the feasibility of creating new edges with
the memory errors and validates the exploit.
It ﬁnally
outputs the input to mount a data-oriented attack.
USENIX Association  
24th USENIX Security Symposium  185
9
                                       FlowStitch 
error-exhibiting  
input 
vuln.  
program 
  benign 
input 
r
e
g
g
o
l
e
c
a
r
T
error-
exhibiting 
trace 
Influence 
Analysis 
constraints, 
influence 
benign 
trace 
Flow  
Analysis 
data flows, 
sec. data 
Candidate 
Generation 
Single-
edge 
Multi-
edge 
Address
-reuse 
Determi
nistic-
address 
candidate 
exploits 
Filtering 
DOA 
exploits 
Figure 8: Overview of FLOWSTITCH. FLOWSTITCH takes a vulnerable program, an error-exhibiting input and a benign input of the program as
inputs. It builds data-oriented attacks against the given program using data-ﬂow stitching. Finally it outputs the data-oriented attack exploits.
FLOWSTITCH requires that the error-exhibiting input
and the benign input make the program follow the same
code path until memory error happens. Such pairs of in-
puts can be found by existing symbolic execution tools,
like BAP [16] and SAGE [25], which explore multiple
execution paths with various inputs. Before detecting
one error-exhibiting execution, these tools usually have
explored many matched benign executions.
4.1 Memory Error Inﬂuence Analysis
FLOWSTITCH analyzes the error-exhibiting trace to un-
derstand the inﬂuence I of the memory errors. It identi-
ﬁes two aspects of the memory error inﬂuence: the time
when the memory errors happens during the execution
(temporal inﬂuence) and the memory range that can be
written to in the memory error (spatial inﬂuence). From
the error-exhibiting trace, FLOWSTITCH detects instruc-
tions whose memory dereference addresses are derived
from the error-exhibiting input. We call these instruc-
tions memory error instructions. Note that data ﬂows
ending before such instructions or starting after them
cannot be affected by the memory error, therefore they
are out of the temporal inﬂuence.
Attackers get access to unintended memory locations
with memory error instructions. However, the program’s
logic limits the total memory range accessible to attack-
ers. To identify the spatial inﬂuence of the memory er-
ror instruction, we employ dynamic symbolic execution
techniques. We generate a symbolic formula from the
error-exhibiting trace in which all the inputs are sym-
bolic variables and all the path constraints are asserted
true. Inputs that satisfy the formula imply that the execu-
tion to memory error instructions with an unintended ad-
dress3. The set of addresses that satisfy these constraints
and can be dereferenced at the memory error instruction
constitute the spatial inﬂuence.
3This is true if the symbolic formula constructed is complete [26].
4.2 Security-Sensitive Data Identiﬁcation
As we discuss in Section 2.3, FLOWSTITCH synthesizes
ﬂows of security-sensitive data. There are four types of
data that are interesting for stitching:
input data, out-
put data, program secret and permission ﬂags. To iden-
tify input data, FLOWSTITCH performs taint analysis at
the time of trace generation, treating the given input as
an external taint source. For output data, FLOWSTITCH
identiﬁes a set of program sinks that send out the pro-
gram data, like send() and printf(). The parame-
ters used in sinks are the output data. Further, we classify
program secret and permission ﬂags into two categories:
the program-speciﬁc data and the generic data. FLOW-
STITCH accepts user speciﬁcation to ﬁnd out program-
speciﬁc data. For example, user can provide addresses of
security ﬂags. For the generic data, FLOWSTITCH uses
the following methods to automatically infer it.
• System call parameters. FLOWSTITCH identi-
ﬁes all system calls from the trace, like setuid,
unlink. Based on the system call convention,
FLOWSTITCH collects the system call parameters.
• Conﬁguration data. To identify conﬁguration data,
FLOWSTITCH treats the conﬁguration ﬁle as a taint
source and uses taint analysis to track the usage of
the conﬁguration data.
• Randomized data. FLOWSTITCH identiﬁes stack
canary based on the instructions that set and check
the canary, and identiﬁes randomized addresses if
they are not inside the deterministic memory region.
Deterministic Memory Region Identiﬁcation. FLOW-
STITCH identiﬁes the deterministic memory region for
stitch with deterministic addresses (Section 3.3.1).
It
ﬁrst checks the program binary to identify the memory
regions that will not be randomized at runtime.
If the
program is not position-independent, all the data sec-
tions shown in the binary headers will be at deterministic
addresses. FLOWSTITCH collects loadable sections and
gets a deterministic memory set D. FLOWSTITCH fur-
ther scans benign traces to ﬁnd all the memory writing
instructions that write data into the deterministic mem-
ory set to identify data stored in such region.
186  24th USENIX Security Symposium 
USENIX Association
10
Note that based on the functionality of the security-
sensitive data, we predeﬁne goals of the attacks. For ex-
ample, the attack of setuid parameter is to change it
to the root user’s id 0. For a web server’s home directory
string, the goal is to set it to system root directory.
4.3 Stitching Candidate Selection
For identiﬁed security-sensitive data, FLOWSTITCH gen-
erates its data ﬂow from the 2D-DFG. FLOWSTITCH se-
lects the source ﬂow originated from the source vertex VS
and the target ﬂow ended at the target vertex VT . It then
uses the stitching methods discussed in Section 3 to ﬁnd
stitching solutions. Although any combination of stitch-
ing methods can be used here, FLOWSTITCH uses the
following policy in order to produce a successful stitch-
ing efﬁciently.
1. FLOWSTITCH tries the single-edge stitch technique
before the multi-edge stitch technique. After the
single-edge stitch’s search space is exhausted, it
moves to multi-edge stitch. FLOWSTITCH stops
searching at four-edge stitch in our experiments.
2. FLOWSTITCH considers stitch with deterministic
addresses before stitch by address reuse. After ex-
hausting the search space of deterministic address
and address reuse space, FLOWSTITCH continues
searching stitches with concrete addresses shown in
benign traces, for cases without ASLR.
4.4 Candidate Filtering
To overcome challenge C3, FLOWSTITCH checks the
feasibility of each selected stitch edge candidate. We
deﬁne the stitchability constraint to cover the following
constraints.
• Path conditions to reach memory error instructions;
• Path conditions to continue to the target ﬂow;
• Integrity of the control data;
FLOWSTITCH generates the stitchability constraint
using symbolic execution tools. The constraint is sent
to SMT solvers as an input.
If the solver cannot ﬁnd
any input satisfying the constraint, FLOWSTITCH picks
the next candidate stitch edge. If it exists, the input will
be the witness input that is used to exercise the execu-
tion path in order to exhibit the data-oriented attack. Due
to the concretization in symbolic constraint generation
in the implementation, the constraints might not be com-
plete [26], i.e., it may allow inputs that results in different
paths. FLOWSTITCH concretely veriﬁes the input gener-
ated by the SMT solver to check if it successfully mounts
the data-oriented attack on the program.
5
Implementation
We prototype FLOWSTITCH on Ubuntu 12.04 32 bit sys-
tem. Note that as the ﬁrst step the trace generation tool
can work on both Windows and Linux systems to gener-
ate traces. Although the following analysis steps are per-
formed on Ubuntu, FLOWSTITCH works for both Win-
dows and Linux binaries.
Trace Generation. Our trace generation is based on
the Pintraces tool provided by BAP [16]. Pintraces is
a Pin [28] tool that uses dynamic binary instrumentation
to record the program execution status.
It logs all the
instructions executed by the program into the trace ﬁle,
together with the operand information.
In our evalua-
tion, the traces also contain dynamic taint information to
facilitate the extraction of data ﬂows.
Data Flow Generation. For input data and conﬁgura-
tion data, FLOWSTITCH uses the taint information to get
the data ﬂows. To generate the data ﬂow of the security-
sensitive data, FLOWSTITCH performs backward and
forward slicing on the benign trace to locate all the re-
lated instructions.
It is possible for one instruction to
have multiple source operands. For example, in add
%eax, %ebx, the destination operand %ebx is derived
from %eax and %ebx. In this case, one vertex has mul-
tiple parent vertices. As a result, the generated data ﬂow
is a graph where each node may have multiple parents.
Constraint Generation and Solving. The generation of
the stitchability constraint required in Section 4.4 is im-
plemented in three parts: path constraints, inﬂuence con-
straints, and CFI constraints.The stitchability constraint
is expressed as a logical conjunction of these three parts.
We use BAP to generate formulas which capture the path
conditions and inﬂuence constraints. For control ﬂow in-
tegrity constraint, we implement a procedure to search
the trace for all the indirect jmp or ret instruction.
Memory locations holding the return addresses or indi-
rect jump targets are recorded. The control ﬂow integrity
requires that at runtime, the memory location contain-
ing control data should not be corrupted by the memory
errors. The stitchability constraint is checked for satisﬁ-
ability using the Z3 SMT-solver [22], which produces a
witness input when the constraint is satisﬁable.
6 Evaluation
In this section, we evaluate the effectiveness of data-
ﬂow stitching using FLOWSTITCH,
including single-
edge stitch, multi-edge stitch, stitch with deterministic
addresses and stitch by address reuse. We also measure
the search space reduction using FLOWSTITCH and the
performance of FLOWSTITCH.
6.1 Efﬁcacy in Exploit Generation
Table 2 shows the programs used in our evaluation, as
well as their running environments and vulnerabilities.
The trace generation phase is performed on different
USENIX Association  
24th USENIX Security Symposium  187
11
Table 2: Experiment environments and benchmarks. # of Data-Oriented Attacks gives the number of attacks generated by FLOWSTITCH, includ-
ing privilege escalation attacks and information leakage attacks. FLOWSTITCH generates 19 data-oriented attacks from 8 vulnerable programs.
ID
CVE-2013-2028
CVE-2012-0809
CVE-2009-4769
bugtraq ID: 41956
CVE-2002-1496
CVE-2001-0820
CVE-2001-0144
CVE-2000-0573
Total
Vul. Program Vulnerability
nginx
sudo
httpdx
orzhttpd
null httpd
ghttpd
SSHD
wu-ftpd
8 programs
stack buffer overﬂow
format string
format string
format string
heap overﬂow
stack buffer overﬂow
integer overﬂow
format string
Environment (32b)
Ubuntu 12.04
Ubuntu 12.04
Windows XP SP3
Ubuntu 9.10
Ubuntu 9.10
Ubuntu 12.04
Ubuntu 9.10
Ubuntu 9.10
1
1
4
1
2
1
2
2
14
1
0
1
1
0
0
1
1
5
# of Data-Oriented Attacks
Escalation
Leakage
Table 3: Evaluation of FLOWSTITCH on generating data-oriented attacks. In the Attack Description column, Li stands for information leakage
attack, while Mi represents privilege escalation attack. The third column indicates whether the built attack can bypass ASLR or not. The “CP”
column shows the number of memory error instructions. Trace size is the number of instructions inside the trace. The last four columns show the
number of stitch sources and stitch targets before and after our selection. SrcFlow means source ﬂow, while TgtFlow stands for target ﬂow.
ASLR
Bypass
Error-exhibiting
Trace Size
Benign
Trace Size
# of nodes before
# of nodes after
SrcFlow
TgtFlow
SrcFlow
TgtFlow
Vul. Apps
nginx