device, the Goji Go Activity Tracker, whose firmware we had ex-
tracted from its companion mobile application. The tracker had
two SIG services, as well as the Nordic firmware update service and
a developer-defined service. Comparing the results obtained using
argXtract with those we obtained from manual analysis (via a
combination of device interaction using the nRF Connect app [56]
and profiling using the ATT-Profiler tool [71]), we found that
argXtract accurately extracted the configuration of the device.
5 CASE STUDY: BLE SECURITY AND
PRIVACY (NORDIC)
BLE is a predominant communications technology within the IoT,
installed on billions of endpoint devices [14]. In this section we
present a case study for the identification of BLE configuration
vulnerabilities in binaries that target Nordic chipsets. The Nordic
BLE stack accepts configuration requests via supervisor calls.
Building the firmware dataset: BLE peripherals typically in-
terface with a mobile application, many of which enable a firmware
upgrade and/or factory reset procedure. The firmware used for this
purpose is either included within the mobile application itself or
is downloaded from a server. The firmware for Nordic chipsets is
identifiable due to its specific structure and included files.
We programmatically extract Nordic BLE binaries from a dataset
of 35,000+ BLE-enabled mobile apps, obtained from Androzoo [1]
and Google Play. We describe here the results obtained by executing
argXtract against 243 unique7 binaries. To additionally check for
the possibility of cloned firmware (which can result in the same
output for slightly different binaries), we use ssdeep [44], with a
threshold of 70% to account for the fact that a lot of the Nordic
baseline code will be the same across files. Seven clusters are present
within our dataset, with an average of 3 files per cluster. We account
for these, where relevant, when presenting our results.
Execution environment: We executed argXtract on a VM
running Ubuntu 18.04.3 LTS with 64GB RAM and 10 processor cores,
with 8 parallel processes, taking RAM usage into consideration.
Section outline: The remainder of this section describes our
findings. We first review the (lack of) protection applied to BLE
data across the binaries for the link and application layers (§5.1). We
6Configurations were dependent on the options made available by the vendor.
7Determined by the SHA256 computed over the file bytes.
then analyse instances of weakened pairing due to the use of fixed
passkeys (§5.2). Finally, we examine privacy concerns identified for
our dataset due to the use of static addresses (§5.3) and device/man-
ufacturer names (§5.4). Each subsection provides an overview of the
relevant aspect of the BLE technology, describes the extracted data,
and discusses the results and the security or privacy implications.
The supervisor calls that are targeted are provided in Table 2.
5.1 Security of BLE Data
BLE data is stored in discrete structures known as attributes. Char-
acteristics are a type of attribute that hold the data of interest, e.g.,
heart rate readings. Multiple characteristics are grouped into a
service, which is also a type of attribute. A third type of attribute,
descriptors, describes a characteristic value. Restricting access to
attributes is facilitated via attribute permissions, which are a com-
bination of the following: Access permissions control whether the
attribute can be read and/or written; Authentication/encryption per-
missions indicate whether the link between the two devices must
be authenticated/encrypted before the attribute can be accessed;
Authorisation permissions require developer-specific checks and can
be used to implement end-to-end (i.e., application layer) security.
When link layer protection is required (i.e., via authentication
permissions), three security modes can be applied. We discuss only
Mode 1 in this study as we have not observed Modes 2 and 3 in
real-world devices. The Bluetooth specification defines four levels
of protection for Mode 1: Level 1 - No security; Level 2 - Unauthenti-
cated pairing with encryption, i.e., encryption with no requirement
for Man-in-the-Middle (MitM) protection. This can be achieved
using the Just Works pairing model, which uses an all-zero key
as an input to the key derivation algorithm and requires no user
interaction; Level 3 - Authenticated pairing with encryption, i.e.,
encryption with MitM protection. This requires either the Passkey
Entry or Numeric Comparison pairing models, both of which require
user interaction; Level 4 - Authenticated LE Secure Connections
pairing with encryption using a 128-bit strength key.
Services are freely readable but not writable. Characteristics and
specific descriptors can have authentication and authorisation per-
missions. Characteristics also have certain properties, to determine
how their data can be accessed. For example, a characteristic value
can be read. It can also be obtained via notifications or indications,
by writing to a descriptor called the Client Characteristic Configu-
ration Descriptor (CCCD), whereby the BLE peripheral informs the
connected device of changes in the characteristic value. While the
outcome is somewhat similar (i.e., the connected device obtains the
characteristic value), the security requirements for the two mech-
anisms are different. A read request requires that the connected
device satisfy the read permissions for the characteristic value it-
self, while subscribing to notifications requires that the connected
device satisfy the write permissions of the characteristic’s CCCD.
Extracting characteristic security configurations: We exe-
cuted argXtract against our dataset with a maximum execution
time of 1.5 hours per trace. This returned 199 valid output files.8
8We perform stringent validity checks and consider a characteristic data structure to be
valid only if applicable characteristic permissions (based on characteristic properties)
have correct values, as described by the BLE specification. Further, we reject any
characteristic that cannot be uniquely tied to a service, even if the characteristic
structure is otherwise complete and correct. See Appendix B for more details.
868argXtract: Automated Analysis of Stripped IoT Binaries
ACSAC ’21, December 6–10, 2021, Virtual Event, USA
Table 2: Calls Of Interest used in case studies.
Case Study
Nordic BLE
Security Metric
Security of BLE Data (§5.1)
BlueNRG
Use of Fixed Passkeys (§5.2)
User Tracking due to Fixed Ad-
dresses (§5.3)
Manufacturer/Device Names
and Privacy (§5.4)
BLE Address Privacy (§6.1.1)
BLE Pairing Security (§6.1.2)
Nordic ANT
ANT Channel Security (§6.2.1)
Calls Of Interest
Characteristic security is defined when the characteristic is added using sd_ble_gatts_characteristic_add. A characteristic
is tied to a service via a service_handle field output by sd_ble_gatts_service_add.
Fixed passkeys are set via the sd_ble_opt_set svc with an opt_id (first argument) of 34.
Address type can be changed via sd_ble_gap_address_set (older stacks); sd_ble_gap_addr_set and sd_ble_gap_privacy_-
set (newer versions). Default is random static address set at time of manufacture and unchanging during device lifetime.
Device name is set using sd_ble_gap_device_name_set. Manufacturer Name String is included within the Device Information
Service (obtained in §5.1).
Public addresses are configured using aci_hal_write_config_data [77], which internally calls HAL_Write_ConfigData with
same arguments. Validation is performed via the extracted 2nd argument, which is a length field (value must be 6 for addresses).
Privacy is configured via aci_gap_init. The function performs several tasks, most of which require runtime information.
We exploit the fact that the function adds the BLE GAP service to the database when generating our test sets.
Two function calls to enable BLE security: (i) aci_gap_set_io_capability, to set the device’s input-output capability, and (ii)
aci_gap_set_authentication_requirement, to set the pairing requirements (such as bonding, MitM protection, etc) [77].
Authorisation permissions are set using the aci_gap_set_authorization_requirement function.
ANT is enabled using the sd_ant_enable supervisor call. Within this call, the number of required channels and the number
(out of those created) that should be encrypted are specified.
Analysis times were < 2 minutes for half the binaries, 2-10 min-
utes for 25% of the binaries, and more than 10 minutes for the
remaining binaries. The 199 binaries contained 6 of the previously
mentioned clusters (identified using ssdeep). Examination of the
corresponding output files showed that files within each cluster
had the same service configurations. We therefore consider only
188 unique outputs.
Insufficient protection for BLE data. In this section, we discuss
5.1.1
the protection applied to BLE data for the binaries in our dataset.
Because BLE characteristics can either be defined by the Bluetooth
Special Interest Group (SIG), with SIG-specified security configura-
tions, or defined by the device developer with developer-specified
security, we analyse the two instances separately.
(i) Protection for SIG-defined BLE data argXtract extracted
SIG-defined characteristics from 103 binaries. We found that all
devices follow SIG specifications regarding security configurations.
While most SIG-defined characteristics have no security require-
ments, the results revealed an interesting observation for the SIG-
defined characteristics that do have security requirements. In many
such cases, the SIG specifies a choice of protection levels, normally
Mode 1 Level 2 or Mode 1 Level 3. These can be achieved using
Just Works or Passkey Entry pairing, respectively. While both Just
Works and Passkey Entry are known to be vulnerable to passive
eavesdropping attacks [15], Passkey Entry should be the choice
for greater security, as it provides MitM protection. However, our
results show that device developers have invariably opted for the
lower security level, i.e., Mode 1 Level 2. We believe this may be
due to lack of a user interface on the devices precluding the use of
Passkey Entry. Note that, even if the BLE device does have a user
interface, as long as the data only specifies a security requirement
of Mode 1 Level 2, an attacker can often manipulate the pairing
process by specifying no input-output capabilities, downgrade the
pairing model to Just Works, and thereafter access the data.
(ii) Protection for developer-defined BLE data argXtract ex-
tracted at least one developer-defined characteristic from 170 bi-
naries. Table 3 summarises the link layer and application layer
protection applied to the developer-defined characteristics, broken
down into readable and writable characteristics. From the table,
we conclude that protection for reads is virtually non-existent at
the link layer, with only five firmware binaries specifying Mode 1
Level 2 authentication requirements. Authorisation requirements
are also not prevalent among readable characteristics, with only
seven binaries specifying protection at higher layers. Writable char-
acteristics fare similarly to readable characteristics in terms of link
layer protection, with only four binaries specifying Mode 1 Level 2
authentication requirements. App-layer protection is slightly better
for writable characteristics, but a significant proportion of binaries
apply no protection at all to their writable characteristics (apart
from those provided by Nordic itself, for firmware upgrades).
Security implications: The security of BLE data is strongly
associated with authentication and authorisation permissions. Hav-
ing freely accessible BLE characteristics means any user in the vicinity
of the BLE peripheral will be able to read and write the data, subject
to the characteristic being readable/writable. For that matter, even if
the characteristic is protected by Just Works pairing, an attacker in
the vicinity can pair with the device and access its data. We verified
this with a fitness tracker, from which we were able to access
characteristic values without pairing. Further, even if strong link
layer protection is present, absence of application layer protection
makes the data vulnerable to access by unauthorised apps [70]. We
verified this with a custom Android app and emulated BLE device.
» Implications for readable data within the dataset: Among the bi-
naries that had no protection for readable characteristics, we found
(through the device name extracted in §5.4) numerous fitness track-
ers and healthcare devices, all of which potentially store detailed
information regarding a user’s activity or health. No protection or
only Just Works protection means this personal and sensitive data
is vulnerable to unauthorised access, via local and remote attacks.
» Implications for writable data within the dataset: Within the
binaries that had writable characteristics, we found one that con-
tained the SIG-defined Human Interface Device (HID) service. This
only had Mode 1 Level 2 link layer protection applied to its charac-
teristics. Again, this security requirement can be satisfied by Just
Works pairing, which means that an attacker could transmit unso-
licited messages to the HID device, and also read and modify the
keyboard characters that are transmitted between the HID device
and host via a MitM attack. This has been demonstrated in [43].
We have informed the developer of this vulnerability.
869ACSAC ’21, December 6–10, 2021, Virtual Event, USA
Pallavi Sivakumaran and Jorge Blasco
Table 3: Protection applied to developer-defined data.
Reads† Writes
Description
Binaries with characteristics that have appropriate property
169
167
Binaries with Mode 1 Level 2 link layer protection
4
5
Binaries with Mode 1 Level 3 link layer protection
0
0
Binaries with application layer security
69*
7
All entries refer to developer-defined characteristics. †Including notifications/indications. *24
excluding Nordic DFU control point, from Nordic DFU library.
The vast majority of devices applied no protection to any of their
writable characteristics. Among these were smart switches, medical
respiratory devices and ECG monitors. Writing random bytes to
characteristics on such devices could cause the devices to function
improperly or cease to function entirely. If the behaviour of the
device corresponding to the written values is known to an attacker,
then they can write carefully chosen values in order to modify the
expected behaviour, possibly with harmful consequences.
5.1.2 Different permissions for read vs. notify. As mentioned in §5.1,
the value held within a characteristic can be accessed in different
ways, either using a direct read request or via notifications/indica-
tions, and even though the mechanisms of access differ, the ultimate
outcome is similar. Our results indicated that one binary within our
dataset contained characteristics that had both read and notify
properties, but with different security properties set for the two
types of access. Mode 1 Level 2 security was required to be able
to read the characteristics’ values, while the values could be freely
accessed via notifications (their CCCDs were writable without the
need for any pairing or higher-layer protection).
Security implications: Different security levels for different
value acquisition methods implies that the data can always be ac-
cessed using the less secure mechanism. In addition, there may be a
false sense of security, as the protection will be assumed to be higher
than it actually is. This shows that developers may unintentionally
leave “gaps” in security, particularly when incorporating different
functionalities. We have informed the developer about this issue.
5.2 Use of Fixed Passkeys
As mentioned in §5.1, Passkey Entry is a BLE pairing model which
provides MitM protection by requiring that a user manually key in a
passkey that is displayed on the BLE peripheral. However, some de-
velopers program a fixed passkey into the peripheral. This might be
because many BLE peripherals don’t have input/output capabilities
(i.e., keypad or display), but could also originate from bad practices
when programming devices that do have these capabilities.
Identifying fixed passkeys: argXtract identified a smartwatch
binary within the dataset that called sd_ble_opt_set with an
opt_id of 34, setting a fixed passkey of 0x303030303030, i.e. “000000”.
Security implications: Fixed passkeys undermine the security
of the Passkey Entry model, particularly if the same passkey is used
for all devices of a certain brand. In such a scenario, an attacker
would only need to know the passkey for one device in order to
be able to covertly connect to any device of the same brand. This
effectively removes the MitM protection afforded by the Passkey Entry
model. With the binary we identified, a fixed passkey of “000000”
equates Passkey Entry to the Just Works model.
Table 4: Address types used in BLE peripherals.
Address Type #Bins Address Type
Public
Random static
Private nonresolvable
Private resolvable
29
208
#Bins Address Type #Bins
Unknown
4
1
1
5.3 User Tracking due to Fixed Addresses
BLE peripherals periodically transmit messages on advertising chan-
nels in order to enable incoming connections. These messages con-
tain the peripheral’s hardware address and could be used to track
the device. To overcome this, the BLE specification defines resolvable
private addresses, which enable a device to change its advertising
address while still allowing for reconnections from bonded peers.
There are in fact four types of addresses that can be used with
BLE: Public, Random Static, Private Resolvable, and Private Non-
resolvable. Public addresses do not change during the lifetime of
a device; Random Static addresses do not change during a single
power cycle and may not change for the lifetime of the device;
Private Resolvable addresses change periodically in such a way as
to enable reconnections by a bonded peer; Private Non-resolvable
addresses change periodically, but do not allow for reconnections.
Extracting advertising address type: argXtract identified
that 35 out of the 243 firmware files included one of the svc numbers
for performing address type selection/setting, which meant that
the remaining 208 files used the default setting of a random static
address. Table 4 depicts a breakdown of the address types used
within the BLE peripherals in our dataset. Out of the 243 binaries in
our dataset, only a single binary used resolvable private addresses.
The device name (obtained in §5.4) revealed that the binary was for
a personal protection device. One binary within the dataset used
non-resolvable addresses, which means it will not be vulnerable to
tracking but will also not be able to form bonds with other devices.
Its device name did not reveal its functionality. We found that
overall, the results indicated that at least 95% of the BLE binaries
use static (random or public) addresses.
Privacy implications: Because BLE peripherals tend to adver-
tise constantly when not in a connection, the use of public or random
static addresses in advertising messages opens the BLE device, and by
extension (depending on the device) its owner, to tracking. In crowded
locations such as shopping centres, repeated visits by a user can be
covertly tracked simply by monitoring BLE advertisements and log-
ging the device addresses. This has been previously demonstrated
in [27]. It has also been shown to be feasible to set up a botnet