each suspicious function pointer, we use a tuple includ-
ing “FUNCPTR” (indicating this tuple is about function
pointers), function pointer ﬁeld name, and data struc-
ture name. To differentiate the cases when different
known drivers are hooked, we replaced the data struc-
ture name (“nt! DRIVER OBJECT”) with a driver name
(e.g., “\Driver \disk”) for known drivers. For each code
hook, we use a tuple including “CODEHOOK”, mod-
ule name, function name, offset, and the number of
11
1101001000100001000001511011510.0%5.0%10.0%15.0%20.0%25.0%30.0%35.0%40.0%45.0%50.0%010203040506070Figure 10: Sizes of clusters of samples with identical
MAS footprints.
Figure 11: The numbers of different sized drivers loaded
by samples of each cluster.
bytes that were modiﬁed. For hidden modules or pro-
cesses, we simply used a tuple “HIDDEN MODULE”
or “HIDDEN PROC”. We handled other behaviors sim-
ilarly. Note that we carefully chose not to include any
names or values that are easily modiﬁable by malware
(e.g., a malicious driver’s name or a hidden module’s
name). The tuples in each sample’s footprint are sorted
so that we can easily compare two samples’ signatures.
We assigned samples into the same cluster if they had
identical footprints. This mapped the 89,474 samples
into 414 clusters whose sizes ranged from 1 to 30,411.
A total of 272 clusters contained at least two samples.
Figure 10 shows the distribution of cluster sizes.
To understand whether all samples in a cluster used
a single kernel driver, we counted the number of differ-
ent sized drivers loaded by samples in each cluster (see
Figure 11). A total of 209 clusters have at least two dif-
ferent sized drivers loaded. This indicates that different
malicious kernel drivers have shown identical MAS foot-
prints. Thus we can potentially use MAS’s footprints to
automatically detect new malware samples. We leave the
investigation of this approach to future work.
9 Crash Dump Study
In this section we report our experience in using MAS to
detect kernel rootkits in real-world crash dumps. Since
the white list of trusted code is incomplete for the end
user machines from which the crash dumps were col-
lected, we cannot automate the process of rootkit detec-
tion entirely. However, we can leverage the ﬁndings from
our kernel malware study to identify suspicious crash
dumps before manually inspecting them.
From Table 2 we can see that the three most common
behaviors of rootkits are hooking function pointers, hid-
ing modules, and placing code hooks. Since many suspi-
cious function pointers reported by MAS point to benign
third-party drivers that are not on our white list, simply
using the existence of suspicious function pointers is not
an effective way to identify suspicious crash dumps. For
rootkits that hook both function pointers and hide mod-
ules, the hooked function pointers usually do not point to
a loaded module but either a pool block, a hidden module
or some other memory region. We used this observation
to ignore function pointers whose targets fall into loaded
modules. We are aware that this may cause us to miss
non-stealthy kernel malware that simply installs a driver.
To handle such cases, we would need to either grow the
white list or do more manual analysis. We also ignore
function pointers whose targets do not appear to be the
beginning of a function since they do not allow us to dif-
ferentiate reliably between buggy rootkits and memory
corruptions. In our study we used these conditions to do
initial ﬁltering to identify suspicious dumps. This initial
ﬁltering was done automatically.
For the eleven Windows Vista SP1 crash dumps, we
found seven of them to be suspicious after the ini-
tial ﬁltering. Our manual investigation conﬁrmed that
ﬁve crash dumps contain rootkits (e.g., hooking sev-
eral driver’s dispatch routines, hiding its own driver).
The other two were benign because the code hooks
were placed by two anti-virus systems. Each of them
hooked one of two very frequently called functions,
KiFastCallEntry and SwapContext. We concluded that a
code hook was placed by anti-virus software if the hook’s
target falls into a module and internet search results in-
dicated that the module belongs to an anti-virus vendor
based on the module’s name.
For the 837 Windows 7 crash dumps, we found 177
suspicious dumps after the initial ﬁltering. We quickly
veriﬁed that 85 dumps that contain hidden modules were
12
110100100010000100000151101151201251301351401010203040506070151101151201251301351401all infected by kernel rootkits. Out of the remaining 92
crash dumps, 82 dumps only contain code hooks, and the
other ten contain suspicious function pointers that do not
point to a loaded module. We manually analyzed these
ten dumps and found that ﬁve of them contain rootkits
and the other ﬁve have corrupted global function tables
which let them pass the initial ﬁltering. We cannot decide
if the corruptions were due to a rootkit or a kernel bug.
The 82 dumps with only code hooks have 37 different
hooking patterns. For each hooking pattern, we picked
one dump and manually inspected it with MAS’s report.
Surprisingly, all the code hooks appeared to be placed by
anti-virus software.
In summary, with the process described above, we
were able to quickly identify ﬁve Windows Vista SP1
dumps and 90 Windows 7 dumps that contain kernel
rootkits. All the manual inspections described in this sec-
tion took a total of less than one hour. This demonstrates
that MAS is an effective tool for identifying rootkit foot-
prints in real-world systems.
10 Related Work
MAS is not the ﬁrst system that attempts to identify a
kernel rootkit’s footprint in a memory snapshot. But it is
the ﬁrst practical system that can do so with high accu-
racy, robustness and performance.
Our work was inspired by KOP [3]. While KOP is
the ﬁrst system to type dynamic data in a kernel memory
snapshot with very high coverage, it lacks in robustness
and performance. Our evaluation has shown that MAS is
an order of magnitude faster than KOP in both static anal-
ysis and memory traversal. More importantly, when ana-
lyzing real-world crash dumps of systems running Win-
dows Vista SP1, we observed no errors in MAS’s output.
In contrast, up to 40% of the function pointers reported
by KOP appeared to be incorrect.
Kernel integrity checking has been studied in a large
body of work. SBCFI [19] and Gibraltar [2] both lever-
age type deﬁnitions and manual annotations to traverse
memory and inspect function pointers. Both fall short in
data coverage as a result of not handling generic point-
ers [3]. A recent system called OSck [7] also discovers
kernel rootkits by detecting modiﬁcations to kernel data.
Instead of memory traversal, OSck identiﬁes kernel data
and their types by taking advantage of the slab allocation
scheme used in Linux. It provides per-type allocations
and enables direct identiﬁcation of kernel data types. The
slab allocator is unavailable on Windows operating sys-
tems, which makes Osck less useful for Windows. This
problem cannot be solved by the mapping between pool
tags and data types since it is not a one-to-one mapping.
Worse, a pool tag may correspond to different types, and
several data structures may be stored in one pool block.
MAS leverages source code and program-deﬁned
types to identify dynamic data and their types. Several
other systems have tried to solve this problem without ac-
cess to source code and type deﬁnitions. Laika [4] uses
Bayesian unsupervised learning to infer data structures
and their instances. REWARDs [11] recognizes dynamic
data and their types when they are passed as parame-
ters to known APIs at runtime. TIE [10] reverse engi-
neers data type abstractions from binary programs based
on type reconstruction theory and is not limited to a sin-
gle execution trace. These reverse engineering tools are
more effective for analyzing small to medium scale pro-
grams than for large-scale programs like the Windows
kernel. Both MAS and KOP demonstrate that source
code is critical for achieving high data coverage when
analyzing kernel memory snapshots.
WhatsAt [20] is a tool for dynamic heap type in-
ference.
It uses type information embedded in debug
symbols and attempts to assign a compatible program-
deﬁned type to each heap block by checking type con-
straints.
If a block is untypable, WhatsAt uses it as a
hint for heap corruptions and type safety violations. The
main difference between WhatsAt and MAS is that what-
sat cannot scale to large programs such as the Windows
kernel.
MAS leverages a new demand-driven pointer analysis
algorithm to enable precise but fast analysis for identi-
fying type candidates for generic pointers in large-scale
C/C++ programs. The key idea behind the demand-
driven analysis is to formulate the pointer analysis prob-
lem as a Context-Free Language (CFL) reachability
problem, which was explored in previous work [21,
24, 23, 27]. In [21], Reps ﬁrst introduced the concept
of transforming program analysis problems to graph-
reachability problems. In [24], Sridharan et. al. apply
this idea to demand-driven points-to analysis for Java.
In [23], Sridharan and Bodik present a reﬁnement-based
algorithm for demand-driven context-sensitive analysis
for Java. In [27], Zheng and Rugina describe a demand-
driven alias analysis algorithm for C. We adopt their al-
gorithm and extend it to support ﬁeld-sensitivity. We also
achieve context-sensitivity in a way similar to [23]. In
KOP [3], Carbone et. al. extend the algorithm presented
in [6] to be context- and ﬁeld-sensitive. The key advan-
tage of MAS over KOP is that MAS’s static analysis can
run in parallel.
MAS works on memory snapshots to analyze kernel
rootkit behavior. Several other systems [9, 22, 26] have
used virtualization-based dynamic tracing for the same
purpose. Soft-timer based attacks [25] are detectable by
MAS since the callback function pointer injected by the
malware is always in memory and can potentially be de-
tected by MAS.
13
11 Limitations
A key limitation faced by MAS is that an attacker who is
familiar of MAS’s design can potentially disrupt MAS’s
memory traversal by manipulating the kernel memory.
MAS checks several constraints (see Section 4) before
adding a new data object. If an attacker were able to ﬁnd
some pointer or enum ﬁelds in a data structure that may
take arbitrary values without crashing the OS, he could
potentially mislead MAS to reject instances of such a
data structure by changing them to violate the pointer or
enum constraints. The impact of this limitation remains
unclear because we are not aware of such data structures.
Moreover, even when such data structures exist, it is un-
clear if they will affect the identiﬁcation of security sen-
sitive data (e.g., hooked function pointers).
Another limitation of MAS is due to the existing im-
plementation in Windows. Currently an attacker can
modify the tag of a pool block without crashing Win-
dows, and thus use it to mislead MAS. However, this lim-
itation can be eliminated if the pool manager checks the
tag of a pool block against the expected pool tag passed
as a function argument when the pool block is freed.
12 Conclusions
We have presented MAS, a practical memory analy-
sis system that can accurately and quickly identify a
rootkit’s memory footprint. We applied MAS to analyze
848 crash dumps collected from end user machines and
154,768 potential malware samples obtained from a ma-
jor anti-virus vendor. Our experiments show that MAS
was able to quickly analyze all memory snapshots with
typical running times between 30 and 160 seconds per
snapshot and with near perfect accuracy. With MAS, we
were able to quickly identify 95 crash dumps that con-
tain rootkits. Our kernel malware study shows that rootk-
its hooked 191 different function pointers in 31 different
data structures. Furthermore, it demonstrates that many
malware samples installed different kernel drivers but
had identical memory footprints, which suggests a fu-
ture research direction on leveraging memory footprints
to automatically detect new malware samples.
Acknowledgments
We would like to thank the anonymous reviewers
for their helpful feedback. We are very grateful to
many colleagues for their valuable feedback, sugges-
tions and help throughout the effort of making MAS
real: Alex Moshchuk, Anil Francis Thomas, Barry Bond,
Bryan Parno, Chris Hawblitzel, David Molnar, Dennis
Batchelder, Eddy Hsia, Galen Hunt, Gloria Mainar-Ruiz,
14
Helen Wang, Jay Stokes, Jeffrey Chung, Jen-Lung Chiu,
Jim Jernigan, Pat Winkler, Randy Treit, Reuben Olinsky,
Rich Draves, Ryan Kivett, Scott Lambert, Tim Shoultz,
YongKang Zhu.
References
[1] The Alureon rootkit.
Alureon.
http://en.wikipedia.org/wiki/
[2] BALIGA, A., GANAPATHY, V., AND IFTODE, L. Automatic in-
ference and enforcement of kernel data structure invariants.
In
Proceedings of the 24th Annual Computer Security Applications
Conference (2008).
[3] CARBONE, M., CUI, W., LU, L., LEE, W., PEINADO, M., AND
JIANG, X. Mapping kernel objects to enable systematic integrity
checking. In Proceedings of the 16th ACM Conference on Com-
puter and Communications Security (CCS) (November 2009).
[4] COZZIE, A., STRATTON, F., XUE, H., AND KING, S. T. Dig-
In Proceedings of the 8th USENIX
ging for data structures.
Conference on Operating Systems Design and Implementation
(Berkeley, CA, USA, 2008), OSDI’08, USENIX Association,
pp. 255–266.
[5] DINABURG, A., ROYAL, P., SHARIF, M., AND LEE, W. Ether:
Malware analysis via hardware virtualization extensions. In Pro-
ceedings of the 15th ACM Conference on Computer and Commu-
nications Security (CCS 2008) (October 2008).
[6] HEINTZE, N., AND TARDIEU, O. Ultra-fast aliasing analysis us-
ing CLA - a million lines of C code in a second. In SIGPLAN
Conference on Programming Language Design and Implementa-
tion (2001).
[7] HOFMANN, O. S., DUNN, A. M., KIM, S., ROY, I., AND
WITCHEL, E. Ensuring operating system kernel integrity with
OSck. In Proceedings of the 16th International Conference on
Architectural Support for Programming Languages and Operat-
ing Systems (New York, NY, USA, 2011), ASPLOS ’11, ACM,
pp. 279–290.
[8] KOLBITSCH, C., KIRDA, E., AND KRUEGEL, C. The power
of procrastination: Detection and mitigation of execution-stalling
malicious code. In Proceedings of the 18th ACM Conference on
Computer and Communications Security (CCS 2011) (October
2011).
[9] LANZI, A., SHARIF, M., AND LEE, W. K-tracer: A system
In Proceedings of the
for extracting kernel malware behavior.
16th Annual Network and Distributed System Security Sympo-
sium (2009).
[10] LEE, J., AVGERINOS, T., AND BRUMLEY, D. Tie: Principled
reverse engineering of types in binary programs. In Proceedings
of the 18th Annual Network and Distributed System Security Sym-
posium (Feb. 2011), pp. 251–268.
[11] LIN, Z., ZHANG, X., AND XU, D. Automatic reverse engineer-
ing of data structures from binary execution. In Proceedings of
the 17th Annual Network and Distributed System Security Sym-
posium (NDSS’10) (San Diego, CA, February 2010).
[12] MICROSOFT. Debug interface access SDK. http://msdn.
microsoft.com/en-us/library/x93ctkx8(VS.71).aspx.
[13] MICROSOFT.
Debugging Tools for Windows.
http:
//www.microsoft.com/whdc/devtools/debugging/
default.mspx.
[14] MICROSOFT.
PREfast.
en-us/library/ff550543(v=vs.85).aspx.
http://msdn.microsoft.com/
[15] MICROSOFT.
Symbols
and symbol ﬁles.
http:
//msdn.microsoft.com/en-us/library/windows/
hardware/ff558825(v=vs.85).aspx.
[16] MICROSOFT. Windows driver kit. http://msdn.microsoft.
com/en-us/windows/hardware/gg487428.aspx.
[17] MICROSOFT. Windows HPC Server 2008 R2. http://www.
microsoft.com/hpc.
[18] MICROSOFT.
Windows kernel pool
tags.
http:
//msdn.microsoft.com/en-us/windows/hardware/
gg463213.aspx.
[19] NICK L. PETRONI, J., AND HICKS, M. Automated detection
of persistent kernel control-ﬂow attacks. In Proceedings of the
14th ACM Conference on Computer and Communications Secu-
rity (CCS) (October 2007).
[20] POLISHCHUK, M., LIBLIT, B., AND SCHULZE, C. W. Dynamic
heap type inference for program understanding and debugging. In
Proceedings of the 34th Annual ACM SIGPLAN-SIGACT Sympo-
sium on Principles of Programming Languages (New York, NY,
USA, 2007), POPL ’07, ACM, pp. 39–46.
[21] REPS, T. Program analysis via graph reachability. In Proceed-
ings of the 1997 International Logic Programming Symposium
(October 1997).
[22] RILEY, R., JIANG, X., AND XU, D. Multi-aspect proﬁling
In Proceedings of the 4th ACM
of kernel rootkit behavior.
SIGOPS/EuroSys Conference on Computer Systems (April 2009).
[23] SRIDHARAN, M., AND BODIK, R. Reﬁnement-based context-
sensitive points-to analysis for java. In Proceedings of the 2006
ACM SIGPLAN Conference on Programming Language Design
and Implementation (PLDI) (June 2006).
[24] SRIDHARAN, M., GOPAN, D., SHAN, L., AND BODIK, R.
Demand-driven points-to analysis for Java. In Proceedings of the
20th ACM SIGPLAN Conference on Object-Oriented Program-
ming, Systems Languanges, and Applications (OOPSLA) (Octo-
ber 2005).
[25] WEI, J., PAYNE, B. D., GIFFIN, J., AND PU, C. Soft-timer
driven transient kernel control ﬂow attacks and defense.
In
Proceedings of the 24th Annual Computer Security Applications
Conference (ACSAC 2008) (December 2008).
[26] YIN, H., SONG, D., MANUEL, E., KRUEGEL, C., AND KIRDA,
Panorama: Capturing system-wide information ﬂow for
E.
In Proceedings of the 14th
malware detection and analysis.
ACM Conferences on Computer and Communication Security
(CCS’07) (October 2007).
[27] ZHENG, X., AND RUGINA, R. Demand-driven alias analysis for
C. In Proceedings of the 35th ACM SIGPLAN-SIGACT Sympo-
sium on Principles of Programming Languages (POPL) (January
2008).
15