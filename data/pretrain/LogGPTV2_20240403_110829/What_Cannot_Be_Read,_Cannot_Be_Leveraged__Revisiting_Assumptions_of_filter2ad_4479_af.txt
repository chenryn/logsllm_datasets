gadgets in IE. Therefore, this attack will be further lim-
ited against the 32-bit version of Chakra, which is a de-
fault JIT compiler, even for 64-bit IE. In addition, there
are by now known defenses, such as constant blinding,
that protect against explicit constants.
7.2 Hidden or Non-Readable Code
In reaction to JIT-ROP, researchers started to propose a
great number of defensive schemes that try to hide code
or function pointers.
In Oxymoron, Backes et al. [3]
aim to defend against JIT-ROP by hiding code pointers
from direct calls. However, the attacker can still ﬁnd in-
direct code pointers (e.g., return addresses on the stack
or code pointers on the heap), and follow them to read
the code. Davi et al. [13] thus proposed Isomeron, an
improved defense. They keep two versions of the code
at the same time, one original and another diversiﬁed us-
ing ﬁne-grained ASLR. At each function call, they ﬂip
a coin to decide which version of the code to execute.
This gives a 50% chance of success for each gadget in
the chain, making it unlikely to guess correctly for long
gadgets.
Gionta et al. [15] proposed HideM, which utilizes a
split TLB to serve read and execute accesses separately,
thus forbidding the attacker to read code pages. Apart
from requiring hardware support, HideM also has a limi-
tation that it does not protect function pointers, allowing
the attacker to use them in code reuse attacks.
Backes et al. [2] and Crane et al. [11] proposed
two independent defense techniques, XnR and Readac-
tor, respectively, based on the same principle: mak-
ing executable regions of the memory non-readable.
XnR does this in software, marking executable pages
non-present and checking the validity of the accesses
in a custom page-fault handler. This leaves only a
small window of (currently executing) readable code
pages, signiﬁcantly reducing the surface of gadgets an
attacker can learn. Readactor uses Extended Page Tables
(EPT), hardware-assisted virtualization support for mod-
ern CPUs. EPTs allow keeping all executable pages non-
readable throughout the entire program execution. In ad-
dition, Readactor diversiﬁes the static code of the pro-
gram and hides addresses of the functions by introduc-
ing call/jump trampolines, making it impossible to guess
the address of any existing code. While being effective
against ROP attacks, Readactor left some pointers, such
as function addresses in import tables and vtable point-
ers, intact, thus leaving the programs vulnerable against
USENIX Association  
25th USENIX Security Symposium  153
function-wise code reuse attacks like return-to-libc [22]
or COOP [27]. The ﬁxes to these problems have been
proposed by Crane et al. in their followup work Readac-
tor++ [12]. We have demonstrated how an adversary
can undermine these proposals if code pointer in JIT-
compiled code are not hidden. As an orthogonal defense
to hiding code pointer in JIT code, we proposed to elim-
inate implicit constants from JIT-compiled code to pre-
serve XnR’s security guarantees.
Pereira et al. [26] designed a similar defense technique
via a software-only approach for the ARM architecture.
They propose Leakage-Resilient Layout Randomization
(LR2), which achieves non-readability of code in ARM
by splitting the memory space in data and code pages and
instrumenting load instructions to forbid code reading.
Furthermore, LR2 proposed to reduce the size overhead
caused by trampolines by using a single trampoline for
each callee and encoding the return address with secret
per-function keys.
7.3 Defending JIT Against Attacks
Finally, we discuss research that aims to protect JIT
compilers against exploitation. In JITDefender, Chen et
al. [9] remove executable rights from the JIT-compiled
code page until it is actually called by the compiler, and
remove the rights when it is done executing. In this way
they try to limit the time during which attackers can jump
to JIT-sprayed shellcode. Although this was effective
against some existing JIT-spraying attacks, JITDefender
can be tricked by the attacker to keep the needed pages
always executable, e.g., by keeping the executed code
busy. Wu et al. [35] proposed RIM (Removing IMme-
diate), in which they rewrite instructions containing im-
mediate values such that they cannot be used as a NOP
sled. Later, Chen et al. [10] proposed to combine RIM
and JITDefender, i.e., remove the executable rights from
JIT-compiled code pages when not needed and also re-
place instructions containing immediate values.
In INSeRT, Wei et al. [34] propose ﬁne-grained ran-
domizations for JIT-compiled code. Their technique
combines (i) removing immediate values via XORing
them with random keys (i.e., constant blinding); (ii) reg-
ister randomization; and (iii) displacement randomiza-
tion (e.g., changing the order of parameters and local
variables). Furthermore, INSeRT randomly inserts trap-
ping instruction sequences, trying to catch attackers di-
verting the control ﬂow. Still, its randomization neither
affects call/jump displacements, nor would randomiza-
tion without hiding code actually hinder our approach.
Most related to our attack are the defensive JIT ran-
domization approaches proposed by Homescu et al. [17].
They propose librando, a library that uses NOP insertions
to randomize the code offsets of JIT-compiled code. We
have demonstrated that even browsers leveraging NOP
insertion (like IE) are susceptible to our proposed attack
and thus proposed a non-probabilistic defense.
8 Conclusion
We have shown that commodity browsers do not protect
against code reuse in attacker-generated, JIT-compiled
code. Our novel attack challenges the assumption of
XnR schemes in that we demonstrate that an attacker
can create predictable ROP gadgets without the need
to read them prior to use. To close this gap, we sug-
gested to extend XnR schemes with our proposed coun-
termeasure that eliminates all critical implicit constants
in JIT-compiled code, effectively defending against our
attack. Our defense evaluation shows that such practical
defenses impose little performance overhead.
Acknowledgment
The authors would like to thank the anonymous review-
ers for their valuable comments. Moreover, we are grate-
ful for the guidance from our shepherd, Ben Livshits,
during the process of ﬁnalizing the paper. We also
want to thank Stefan N¨urnberger, Dennis Andriesse, and
David Pfaff for their comments during the writing pro-
cess of the paper.
This work was supported by the German Federal Min-
istry of Education and Research (BMBF) through fund-
ing for the Center for IT-Security, Privacy and Account-
ability (CISPA) and for the BMBF project 13N13250.
References
[1] ATHANASAKIS, M., ATHANASOPOULOS, E., POLYCHRON-
AKIS, M., PORTOKALIDIS, G., AND IOANNIDIS, S. The Devil
is in the Constants: Bypassing Defenses in Browser JIT Engines.
In Proceedings of the Network and Distributed System Security
(NDSS) Symposium (February 2015).
[2] BACKES, M., HOLZ, T., KOLLENDA, B., KOPPE, P.,
N ¨URNBERGER, S., AND PEWNY, J. You Can Run but You Can’T
Read: Preventing Disclosure Exploits in Executable Code.
In
Proceedings of the 2014 ACM SIGSAC Conference on Computer
and Communications Security (New York, NY, USA, 2014), CCS
’14, ACM, pp. 1342–1353.
[3] BACKES, M., AND N ¨URNBERGER, S. Oxymoron: Making Fine-
grained Memory Randomization Practical by Allowing Code
Sharing. In Proceedings of the 23rd USENIX Conference on Se-
curity Symposium (Berkeley, CA, USA, 2014), SEC’14, USENIX
Association, pp. 433–447.
[4] BHATKAR, E., DUVARNEY, D. C., AND SEKAR, R. Address
Obfuscation: an Efﬁcient Approach to Combat a Broad Range
of Memory Error Exploits. In Proceedings of the 12th USENIX
Security Symposium (2003), pp. 105–120.
[5] BHATKAR, S., AND SEKAR, R. Data Space Randomization. In
Proceedings of the 5th International Conference on Detection of
Intrusions and Malware, and Vulnerability Assessment (Berlin,
Heidelberg, 2008), DIMVA ’08, Springer-Verlag, pp. 1–22.
154  25th USENIX Security Symposium 
USENIX Association
16
[6] BHATKAR, S., SEKAR, R., AND DUVARNEY, D. C. Efﬁcient
Techniques for Comprehensive Protection from Memory Error
Exploits.
In Proceedings of the 14th Conference on USENIX
Security Symposium - Volume 14 (Berkeley, CA, USA, 2005),
SSYM’05, USENIX Association, pp. 17–17.
[7] BLAZAKIS, D. Interpreter Exploitation. In Proceedings of the
4th USENIX Conference on Offensive Technologies (Berkeley,
CA, USA, 2010), WOOT’10, USENIX Association, pp. 1–9.
[8] CHECKOWAY, S., DAVI, L., DMITRIENKO, A., SADEGHI, A.-
R., SHACHAM, H., AND WINANDY, M. Return-oriented Pro-
gramming Without Returns.
In Proceedings of the 17th ACM
Conference on Computer and Communications Security (New
York, NY, USA, 2010), CCS ’10, ACM, pp. 559–572.
[9] CHEN, P., FANG, Y., MAO, B., AND XIE, L. JITDefender: A
Defense against JIT Spraying Attacks. In Future Challenges in
Security and Privacy for Academia and Industry, J. Camenisch,
S. Fischer-Hbner, Y. Murayama, A. Portmann, and C. Rieder,
Eds., vol. 354 of IFIP Advances in Information and Communica-
tion Technology. Springer Berlin Heidelberg, 2011, pp. 142–153.
[10] CHEN, P., WU, R., AND MAO, B. JITSafe: a Framework against
IET Information Security 7, 4
Just-in-time Spraying Attacks.
(2013), 283–292.
[11] CRANE, S., LIEBCHEN, C., HOMESCU, A., DAVI, L.,
LARSEN, P., SADEGHI, A.-R., BRUNTHALER, S., AND
FRANZ, M. Readactor: Practical Code Randomization Resilient
to Memory Disclosure. In 36th IEEE Symposium on Security and
Privacy (Oakland) (May 2015).
[12] CRANE, S., VOLCKAERT, S., SCHUSTER, F., LIEBCHEN, C.,
LARSEN, P., DAVI, L., SADEGHI, A.-R., HOLZ, T., SUTTER,
B. D., AND FRANZ, M. It’s a TRAP: Table Randomization and
Protection against Function Reuse Attacks.
In Proceedings of
22nd ACM Conference on Computer and Communications Secu-
rity (CCS) (2015).
[13] DAVI, L., LIEBCHEN, C., SADEGHI, A.-R., SNOW, K. Z., AND
MONROSE, F. Isomeron: Code Randomization Resilient to (Just-
In-Time) Return-Oriented Programming.
In 22nd Annual Net-
work & Distributed System Security Symposium (NDSS) (Feb.
2015).
[14] DAVI, L. V., DMITRIENKO, A., N ¨URNBERGER, S., AND
SADEGHI, A.-R. Gadge Me if You Can: Secure and Efﬁcient
Ad-hoc Instruction-level Randomization for x86 and ARM.
In
Proceedings of the 8th ACM SIGSAC Symposium on Information,
Computer and Communications Security (New York, NY, USA,
2013), ASIA CCS ’13, ACM, pp. 299–310.
[15] GIONTA, J., ENCK, W., AND NING, P. Hidem: Protecting the
contents of userspace memory in the face of disclosure vulnera-
bilities. In Proceedings of the 5th ACM Conference on Data and
Application Security and Privacy (New York, NY, USA, 2015),
CODASPY ’15, ACM, pp. 325–336.
[16] HISER, J., NGUYEN-TUONG, A., CO, M., HALL, M., AND
DAVIDSON, J. W.
In Pro-
ceedings of the 2012 IEEE Symposium on Security and Privacy
(Washington, DC, USA, 2012), SP ’12, IEEE Computer Society,
pp. 571–585.
ILR: Where’D My Gadgets Go?
[17] HOMESCU, A., BRUNTHALER, S., LARSEN, P., AND FRANZ,
M. Librando: Transparent Code Randomization for Just-in-time
Compilers. In Proceedings of the 2013 ACM SIGSAC conference
on Computer & communications security (New York, NY, USA,
2013), CCS ’13, ACM, pp. 993–1004.
[18] HUKU, A. Exploiting VLC. A Case Study on Jemalloc Heap
Overﬂows. http://www.phrack.org/issues/68/13.html.
[19] JACKSON, T., SALAMAT, B., HOMESCU, A., MANIVANNAN,
K., WAGNER, G., GAL, A., BRUNTHALER, S., WIMMER, C.,
In
AND FRANZ, M. Compiler-Generated Software Diversity.
Moving Target Defense, S. Jajodia, A. K. Ghosh, V. Swarup,
C. Wang, and X. S. Wang, Eds., vol. 54 of Advances in Infor-
mation Security. Springer New York, 2011, pp. 77–98.
[20] KIL, C., JUN, J., BOOKHOLT, C., XU, J., AND NING, P. Ad-
dress Space Layout Permutation (ASLP): Towards Fine-Grained
Randomization of Commodity Software.
In Proceedings of
the 22Nd Annual Computer Security Applications Conference
(Washington, DC, USA, 2006), ACSAC ’06, IEEE Computer So-
ciety, pp. 339–348.
[21] LARSEN, P., HOMESCU, A., BRUNTHALER, S., AND FRANZ,
M. SoK: Automated Software Diversity. In Proceedings of the
2014 IEEE Symposium on Security and Privacy (Washington,
DC, USA, 2014), SP ’14, IEEE Computer Society, pp. 276–291.
The Advanced Return-into-lib(c) Exploits.
[22] NERGAL.
http://phrack.org/issues/58/4.html.
[23] NOVARK, G., AND BERGER, E. D. DieHarder: Securing the
Heap. In Proceedings of the 17th ACM Conference on Computer
and Communications Security (New York, NY, USA, 2010), CCS
’10, ACM, pp. 573–584.
[24] ONARLIOGLU, K., BILGE, L., LANZI, A., BALZAROTTI, D.,
AND KIRDA, E. G-Free: Defeating Return-oriented Program-
ming Through Gadget-less Binaries. In Proceedings of the 26th
Annual Computer Security Applications Conference (New York,
NY, USA, 2010), ACSAC ’10, ACM, pp. 49–58.
[25] PAPPAS, V., POLYCHRONAKIS, M., AND KEROMYTIS, A. D.
Smashing the Gadgets: Hindering Return-Oriented Programming
Using In-place Code Randomization. In Proceedings of the 2012
IEEE Symposium on Security and Privacy (Washington, DC,
USA, 2012), SP ’12, IEEE Computer Society, pp. 601–615.
[26] PEREIRA, O., STANDAERT, F.-X., AND VIVEK, S. Leakage-
resilient authentication and encryption from symmetric crypto-
graphic primitives.
In Proceedings of the 22Nd ACM SIGSAC
Conference on Computer and Communications Security (New
York, NY, USA, 2015), CCS ’15, ACM, pp. 96–108.
[27] SCHUSTER, F., TENDYCK, T., LIEBCHEN, C., DAVI, L.,
SADEGHI, A.-R., AND HOLZ, T. Counterfeit Object-oriented
Programming: On the Difﬁculty of Preventing Code Reuse At-
tacks in C++ Applications. In 36th IEEE Symposium on Security
and Privacy (Oakland) (May 2015).
[28] SCHWARTZ, E. J., AVGERINOS, T., AND BRUMLEY, D. Q: Ex-
ploit Hardening Made Easy. In Proceedings of the 20th USENIX
Conference on Security (Berkeley, CA, USA, 2011), SEC’11,
USENIX Association, pp. 25–25.
[29] SHACHAM, H. The Geometry of Innocent Flesh on the Bone:
Return-into-libc Without Function Calls (on the x86).
In Pro-
ceedings of the 14th ACM Conference on Computer and Commu-
nications Security (New York, NY, USA, 2007), CCS ’07, ACM,
pp. 552–561.
[30] SHACHAM, H., PAGE, M., PFAFF, B., GOH, E.-J.,
MODADUGU, N., AND BONEH, D. On the Effectiveness of
Address-space Randomization. In Proceedings of the 11th ACM
Conference on Computer and Communications Security (New
York, NY, USA, 2004), CCS ’04, ACM, pp. 298–307.
[31] SNOW, K. Z., MONROSE, F., DAVI, L., DMITRIENKO, A.,
LIEBCHEN, C., AND SADEGHI, A.-R.
Just-In-Time Code
Reuse: On the Effectiveness of Fine-Grained Address Space Lay-
out Randomization. In Proceedings of the 2013 IEEE Symposium
on Security and Privacy (Washington, DC, USA, 2013), SP ’13,
IEEE Computer Society, pp. 574–588.
[32] TEAM, P. Address Space Layout Randomization (ASLR).
http://pax.grsecurity.net/docs/aslr.txt.
USENIX Association  
25th USENIX Security Symposium  155
17
[33] WARTELL, R., MOHAN, V., HAMLEN, K. W., AND LIN, Z. Bi-
nary Stirring: Self-randomizing Instruction Addresses of Legacy
x86 Binary Code.
In Proceedings of the 2012 ACM Confer-
ence on Computer and Communications Security (New York, NY,
USA, 2012), CCS ’12, ACM, pp. 157–168.
[34] WEI, T., WANG, T., DUAN, L., AND LUO, J. INSeRT: Protect
Dynamic Code Generation against Spraying. In Information Sci-
ence and Technology (ICIST), 2011 International Conference on
(March 2011), pp. 323–328.
[35] WU, R., CHEN, P., MAO, B., AND XIE, L. RIM: A Method
to Defend from JIT Spraying Attack. In Proceedings of the 2012
Seventh International Conference on Availability, Reliability and
Security (Washington, DC, USA, 2012), ARES ’12, IEEE Com-
puter Society, pp. 143–148.
156  25th USENIX Security Symposium 
USENIX Association
18