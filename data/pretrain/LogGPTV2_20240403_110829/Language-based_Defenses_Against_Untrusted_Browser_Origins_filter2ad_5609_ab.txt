(encrypted) password or credit card number for u
from S and uses it to ﬁll in a form on W .
Host-Proof Cloud Storage: (e.g. ConﬁChair, Mega)
A privacy-sensitive website W loads a client-side
encryption library from S that retrieves an encrypted
ﬁle from the cloud, decrypts it with a user-speciﬁed
key (or passphrase) and releases the ﬁle to W .
We conjecture that other security components that ﬁt our
threat model, such as payment processing APIs and so-
cial sharing widgets, would have similar security goals
and solutions, and suffer from similar weaknesses.
Methodology. Our method for studying each compo-
nent is as follows. We ﬁrst study the source code of
each component and run it in various environments to
discover the core protection mechanisms that it depends
on. For example, in order to protect the integrity of their
JavaScript code from the hosting webpage, some com-
ponents require users to install them as bookmarklets
(e.g. LastPass) or browser extensions (e.g. 1Password),
whereas others rely on their code being downloaded
within frames (e.g. Facebook), within signed Java ap-
plets (e.g. Wuala) or as signed JavaScript (e.g. Mega). In
order to protect the conﬁdentiality of data, many compo-
nents rely on cryptography, implemented either in Java
or in JavaScript. We anticipate that many of these will
eventually use the native HTML Web Cryptography API
when it becomes widely available.
USENIX Association  
22nd USENIX Security Symposium  655
3
Product
Facebook
Category
Single Sign-On Provider
Protection Mechanism Attack Vectors Found
Frames
Helios, Yahoo, Bitly
WordPress, Dropbox
Firefox
Single Sign-On Clients
OAuth Login
Web Browser
Same-Origin Policy
1Password, RoboForm
Password Manager
Browser Extension
LastPass, PassPack
Verisign, SuperGenPass
SpiderOak
Password Manager
Encrypted Cloud Storage
Bookmarklet, Frames,
JavaScript Crypto
Server-side Crypto
Origin Spooﬁng,
URL Parsing Confusion
HTTP Redirector,
Hosted Pages
Malicious JavaScript,
CSP Reports
URL Parsing Confusion,
Metadata Tampering
Malicious JavaScript
URL Parsing Confusion
CSRF
Wuala
Encrypted Cloud Storage
Java Applet, Crypto
Client-side Exposure
Mega
ConﬁChair, Helios
Encrypted Cloud Storage
Crypto Web Applications
JavaScript Crypto
Java Applet, Crypto
XSS
XSS
Table 1: Survey: Representative Attacks on Security Components
Secrets Stolen
Login Credential,
API Access Token
Login Credential,
API Access Token
Login Credential,
API Access Token
Password
Bookmarklet Secret,
Encryption Key
Files,
Encryption Key
Files,
Encryption Key
Encryption Key
Password,
Encryption Key
Next, we investigate whether any of these protection
mechanisms make assumptions about the browser, or the
security of the host website, or component server, that
could be easily broken. We found a variety of bugs
in speciﬁc JavaScript components and in the Firefox
browser, and we found standard web vulnerabilities in
various websites (CSRF, XSS, Open Redirectors).
Finally, the bulk of the analysis consists in converting
these bugs and vulnerabilities to concrete exploits on our
target JavaScript components. Table 1 only reports the
exploits that resulted in a complete circumvention of the
component’s security, that is, attacks where long-term se-
crets like encryption keys and user ﬁles are leaked. We
also found other, arguably less serious, attacks not noted
here, such as CSRF and login CSRF attacks on the data
server and attacks that enable user tracking and ﬁnger-
printing.
In this section, we detail two illustrative examples of
our analysis. For details on our other attacks, see [11].
2.1 Login with Facebook
Hosting Webpage (W) 
0. login() 
Facebook	
  JavaScript	
  SDK	
 token 
Facebook	
API	
1. cookie, W 
2. token 
Facebook	
  OAuth	
IFrame	
/oauth/?origin=W	
login	
3. token 
4. token 
Facebook	
  Proxy	
IFrame	
/proxy?parent=W	
When a website W wants to incorporate single-sign on
with Facebook (S) on one of its pages, it can simply in-
clude the Facebook JavaScript SDK and call FB.login().
Behind the scene, this kicks off a three-party authoriza-
tion protocol called OAuth 2.0 [23], where an authoriza-
tion server on Facebook issues an access token to W if
the currently logged-in user has authorized W for single
sign-on; otherwise, the user is asked to log in and autho-
rize W . W may then call FB.getAccessToken to obtain the
raw token, but more commonly, it calls FB.api to make
speciﬁc calls to Facebook’s REST API (with the token
attached). Hence, W can read the current user’s veri-
ﬁed identity at Facebook or other social data. Google,
Live, and Twitter provide a similar experience with their
JavaScript SDKs.
When W calls FB.login, two iframes are created.
The ﬁrst OAuth iframe is sourced from Facebook’s au-
thorization server with W ’s client id (IW ) as parameter:
https://www.facebook.com/dialog/oauth?client id=IW
This page authenticates the user (with a cookie), veriﬁes
that she has authorized W, issues a fresh access token (T)
and redirects the iframe to a Facebook URL with the to-
ken as fragment identiﬁer:
https://static.ak.facebook.com/connect/xd arbiter.php#token=T
Meanwhile, the second Proxy iframe is loaded from:
https://static.ak.facebook.com/connect/xd arbiter.php#origin=W
where the fragment identiﬁer indicates the origin W of
the host page. Since both frames are now on the same
origin, they can directly read each other’s variables and
call each other’s functions. The OAuth iframe calls a
function on the Proxy iframe with the access token T, and
this function forwards T in a postMessage event to the par-
ent frame (with target origin set to W ). The token is then
received by a waiting FB.login callback function, and to-
ken retrieval is complete. W can call FB.api to verify the
user’s identity and access token.
656  22nd USENIX Security Symposium 
USENIX Association
4
Protection Mechanisms. The main threat to the above
exchange is from a malicious website M pretending to be
W . The Facebook JavaScript SDK relies on the following
browser security mechanisms:
• Both iframes are sourced from origins distinct from
M, so scripts on M cannot interfere with these
frames, except to set their source URIs;
the page; M cannot read the redirection URI;
• The redirection of the OAuth frame is transparent to
• Scripts on M cannot directly access Facebook be-
cause the browser and the web server will prevent
such cross-origin accesses;
event, since it is set to target origin W .
• Scripts on M will not be able to read the postMessage
All four mechanisms are variations of the SOP (ap-
plied to iframes, redirection URIs, XmlHttpRequest, and
postMessage). The intuition is that if M and W are dif-
ferent origins, their actions (even on the same page) are
opaque to each other. However, many aspects of the SOP
are not standard but browser-speciﬁc and open to inter-
pretation [43]. For example, we show bugs in recent ver-
sions of Firefox that break redirection transparency.
Writing JavaScript code to compose browser mecha-
nisms securely is not easy. We demonstrate several bugs
in the Facebook SDK that enable M to bypass origin au-
thentication. Moreover, the SOP does not distinguish be-
tween same-origin pages or scripts. Hence, a hidden as-
sumption in the above exchange is that all scripts loaded
on all pages of W have access to the token and must be
trusted. We show how sub-origin attacks on Facebook’s
client can steal tokens.
Breaking Redirection Transparency on Firefox. We
found two bugs in how Firefox enforced the same origin
policy for redirection URIs.
First, we found that recent versions of the Firefox
browser failed to isolate frame locations. If a script opens
an iframe and stores a pointer to its document.location ob-
ject, then it continues to have access to this object even if
the URL of the frame changes, because of a user action
or a server redirection.
A second bug was in Firefox’s implementation of Con-
tent Security Policy (CSP) [38], a new mechanism to re-
strict loading of external contents to a authorized URIs.
In its CSP, a website can ask for a report on all policy
violations. If M sets its CSP to block all access to W , a
frame on M gets redirected to W , M would be notiﬁed of
this violation by the browser. A bug in Firefox caused
the violation report to include the full URL (including
fragment identiﬁer) of the redirection, despite W and M
being different origins.
By themselves, these bugs do not seem very seri-
ous; they only allow adversaries to read URIs, not even
page contents, on frames that the adversary himself has
created. However, when combined with protocols like
OAuth that use HTTP redirection to transmit secret to-
kens in URIs, these bugs become quite serious. For ex-
ample, a malicious website M can steal a user’s Facebook
token by creating an OAuth iframe with W ’s client id and
reading the token in the redirected Facebook URI.
We reported these bugs and they are now ﬁxed, but
they highlight the difﬁculty of implementing a consistent
policy across an increasing number of browser features.
Breaking Origin Authentication in FB.login.
Al-
though the OAuth iframe only obtains access tokens for
an authorized origin W and the Proxy iframe only re-
leases access tokens to the origin in its fragment identi-
ﬁer, there is no check guaranteeing that these origins are
the same. Suppose a malicious website M opened the
OAuth iframe with W ’s client id, but a Proxy iframe with
M’s origin. The OAuth iframe duly gets the token for W
and passes it to the Proxy iframe that forwards the token
to M. Hence, M has stolen the user’s access token for an
arbitrary W .
We reported this bug and Facebook quickly addressed
the attack by adding code for origin agreement between
the two frames. However, we found two other ways to
bypass this origin comparison by exploiting bugs in the
component’s URL parsing functions.
Sub-origin Attacks on Facebook Clients. The design
of the Facebook login component protects against cross-
origin attackers (e.g. an unauthorized host website) but
not provide any protections against untrusted content and
ordinary web vulnerabilities on authorized host websites.
We found that Wordpress and Dropbox both allow
users to host HTML pages on subdomains; we were able
to exploit this feature to write user content that obtained
access tokens meant for the main website. We also found
an open redirector on the electronic voting site Helios
that allowed any malicious website to steal a user’s ac-
cess token for Helios; the website could then vote in the
user’s name. This was a bug, but similar redirectors ap-
pear by design on Yahoo search and Bitly, leading to to-
ken theft, as shown in previous work [6].
These attacks were reported and are now prevented by
either moving user content to a different domain or by
ensuring that Facebook only releases tokens to a distinct
subdomain (e.g. open.login.yahoo.com). However, pages
on the main website still need to be given the token so
that they can access the Facebook proﬁle of the user.
We found that websites like Wordpress and Hulu leave
their Facebook access tokens embedded in their web-
pages, where they may be read by any number of other
scripts, including competing social plugins from Twitter,
framework libraries like jQuery, and advertising and an-
alytics libraries from Google and others. At their most
benign, these scripts could read the access token to track
USENIX Association  
22nd USENIX Security Symposium  657
5
Facebook users; if they were malicious, they could im-
personate the user and read her Yahooo mail or exﬁltrate
her full social proﬁle for advertising use.
2.2 Client-side Decryption for Cloud Data
Web applications often use cryptography to protect sen-
sitive user data that may be stored on untrusted servers
or may pass through untrusted browsers. A typical ex-
ample is a cloud-based ﬁle storage service, where both
users and server owners would prefer the cloud server
not to be able to read or modify any user ﬁle. To be host-
proof in this way, all user ﬁles are stored encrypted in the
cloud, using keys that are known only to the user or her
browser, but not to the storage service. All plaintext data
accesses are performed in the browser, after downloading
and decrypting ciphertext from the cloud. This architec-
ture has also been adopted by password managers and
other privacy conscious applications such as electronic
voting, encrypted chats, and conference management.
There are many challenges in getting browser-based
cryptographic solutions right, but the two main design
questions are how to trust the cryptographic library and
protect its execution, and how to store encryption keys
securely. Our survey found a variety of choices:
Browser Extensions. Password managers are often im-
plemented as browser extensions so that they can read
and write into login forms on webpages while being iso-
lated from the page. Communication between the web-
site and the page uses a browser-speciﬁc messaging API.
We found attacks on the 1Password and RoboForm ex-
tensions where a malicious website could use this API
to steal user passwords for trusted websites by exploiting
buggy URL parsing and the lack of metadata integrity in
the encrypted password database format.
Bookmarklets. Some password managers offer login
bookmarklets that contain JavaScript code with an em-