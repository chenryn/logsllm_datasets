return O;
self->ob_size
深度探索动态语言核心技术
ailocated=10
obitem
b=7
ob
ob.rofom
图4-4
newsize;
通过insert向PyListObject对象中插入元素
扩展的空间
NULL
NULL
NULL
TON
NULL
NULL
NULL
NULL
NOT
向下移
NULL
NULL
NULL
NULL
100
NULL
NULL
NULL
NULL
插入99
NULL
NULL
NULL
NULL
NULL
TION
NULL
NULL
100
99
---
## Page 101
元素101之后的PyListobject对象：
述的插入操作非常类似：
allocated已经变成10了，而ob_size却只有7。
[listobjeet.cl
statie int appl(PyListobject
//PytHon提供的CAP1
与append对盘的c晶数
nt
只是需要注意的是，在进行append动作的时候，添加的元素是添加在第ob_aize+1
在Python中，1st还有另一个被广泛使用的插入操作append。这个操作与上面所描
EyLiat_SETITEM（BelE,n，V）://这里是设置操作
return-1;
PyList_Append(PyObjectopPyObject*newitem)
值得注意的是，
Py_INCREF(V);
intn=PyList_GET_SIzE(selE）
return NULL;
return-i;
(appl(self,
return appl(（PyListobject *)op,newitem）;
BY
RETURN_NONE:
图4-5
通过append向PyListObject对象中插入元素
altocmed=10
ob_tom
ob8
obtype
ob_rifent
（newitem4=NULE）)
*seif,Pyobject*v)
4.2
Python源码剖析
PyListObject对象的创建与维护
NULL
NULL
101
NULL
NULL
NULL
NULL
TInN
100
一深度探索动态语言核心技术
v)
---
## Page 102
Python源码剖析
4.2.4
2
其函数原形如下：
素匹配。一旦在列表中发现匹配的元素，Python将立即调用1ist_ass_slice删除该元素。
RichCompareBool完成的，如果其返回值大于0，则表示列表中的某个元素与待删除的元
除的元素与PyListobject 中的每个元素一一进行比较，比较操作是通过Pyobject
整。倘若不然，只有插入元素的话，再大的容器迟早有一天会被撑爆的，PyListObject
static Pyobject
[liatobjeat.c]
自然也不会例外。图4-6展示了一个使用PyListobjecE中删除元素功能的例子。
分配内存空间。直接将101放置在第8个位置上即可。
Pyobject*v)
list_ass_slice实际上并非是一个专用于删除操作函数，它的完整功能如下：
Python会对整个列表进行遍历，在遍历PyListObject中所有元素的过程中，将待删
return NULL:
PyErr_SeEString(EyExc_ValueExror,list.remove(x): x not in list")
for
int
当Python执行1st.remove（3）时，PyListobject 中的1istremove操作会被激活：
对于一个容器而言，除了创建、
删除元素
在app1中调用1istresize时，由于newsize（8）在5和10之间，所以不需要再
第4章
//比较1sL中的元素与待删除的元素V
一深度探索动态语言核心技术
return NULL:
Python中的List对象
Py_REIURN_NONE,
(llst
listremove(PyListobject*self,PyobjecE*)
0)
ass_slice（self,fi+1,（Pyobject*）NULL）==0)
22
、设置、插入这些操作，至少还应该有删除操作才算完
18t
删除元素的例子
++>
---
## Page 103
的1ist则完全不同。
时，一定会触发内存搬移的动作，这一点跟C++中的vector是完全一致的，而与C++中
Python的源代码。在1ist_ass_slice中，当进行元素删除动作时，实际上是通过memmove
4-7中，我们通过1[1：2]=口1的执行看到了这一点，对于这个表达式语句，Pyhon内部
remove语义，删除[ilow，ihigh]范围内的元素，这正是listremove期望的动作。同样，在图
最后一个参数v。图47展示了当Pyhon内部调用这个函数时，会发生的动作。
简单地搬移内存来实现的。这就意味着，当调用list的remove操作删除1ist中的元素
调用的正是1ist_ass_slice（1,1，2，NULL）。
对于list_ass_slice的具体实现，这里就不过多地深入了，有兴趣的读者可以参考
可见，这个家伙实际上有着replace和remove两种语义，决定使用哪种语义的，正是
图48展示了删除元素100的过程。
而当1ist_ass_s1ice的参数v为NULL时，Python就会将默认的replace语义替换为
当执行1[1:3]=['a'b]时，Pyhon内部就调用了1ist_ass_slice，而其参数
dela[ilow:ihigh]ifv==NULL.
a[ilow：ihigh]=vif vI=NULL
allocated=10
ob_item
ob_sie=7
ob_rype
obrefent
图4-8在PyListObject中删除100
图4-7
[D2T]=Tob_type->tp_free((Pyobject*)op)
free_lists[num_free_lists++]=opi
(um_free_
PyMem_FRBE（op->ob_1tem）;
一深度探索动态语言核心技术
：销双PyLiBtObjeot对象维护的元素列表
Py_xDECREF(op->ob_itemti]):
并没有什么特别之处。而到了代码清单44的[21处，有趣的东西出现了，
op
，然后在代码清单44的[2]处释放PyListobject对象自身。
ob_size;
lists
em
<MAXFRBELISTS&& PyList_CheakExaCt(Op))
NULL)
---
## Page 105
4.4
ob_size和allocatea两个变量的变化情况，从中窥见PyListobject对内存的使用和管
人非事事休，欲语泪先流”的感慨呢？
对象，有的已经容颜苍老，有的已经烟消云散，身为它们曾经的头儿，是否有一种“物是
HackPyListObject
配pyObject*元素列表占用的内存，重新拥抱新的对象。放眼四周，曾经所拥有过的那些
意图。
素列表的内存归还给系统堆的做法，以时间换取空间。
list时免去创建元素列表的开销，但是Py山on为了避免过多消耗系统内存，采取了将元
除了PyListObject对象自身，没有人能再使用这些内存。虽然保留元素列表可以在创建
表的内存空间。但是如此一来，
44的[1]处仅仅调整引用计数，并将列表中的各个元素都设置为NLL，却并不释放元素列
所以，yobject列表所占用的空间必须归还给系统。
PyListobject如果继续维护一个指向这些对象指针的列表，就可能产生悬空指针的问题。
奔前程，或生存，或毁灭，不再被pyListobject所给予的那个引用计数所束缚。
元素列表，因为这些Pyobject*指针的引用计数已经减少了，这些指针所指的对象都要各
在pyListobject的输出操作1ist_print中，我们添加了如下代码，以观察pyList=
首先我们来观察在pyListobject中维护的元素数量变化时，PyListobject中
在Python下一次创建新的1ist时，这个Pytistobject对象将重新被唤醒，重新分
当然，我们实际上可以将ryListobject对象所维护的元素列表保留，即在代码清单
图49显示了如果删除我们在前面创建的那个1ist，PyListobject对象缓冲池的示
free_lists
图4-9PyListObject对象缓冲池
这些已经被释放的内存并不会归还给系统堆，这就意味着
Python源码剖析一
allocated=0
0=92190
ob_type
ob_refont
NULL
4.4HackPyListObject
一深度探索动态语言核心技术
---
## Page 106
Python源码剖析
16
PyListobject对象时，确实将这个对象放到了缓冲池中。
Object对象缓冲池的影响。
空间又被使用完了，下一次再追加或插入元素时，内存空间调整的动作又会再一次发生。
中vector一样的内存缓冲池策略。
变成了5，而ob_size则变成了2，
空间了。
list中拥有的所有内存空间都已被使用完，所以下次插入元素时就一定会调整list的内存
Object对内存的管理：
果缓冲池中有可用的DyListobject对象，则会使用缓冲池中的对象：而在销毁一个
执行py脚本文件来观察。从图4-11中可以看到，当创建新的PyListObject对象时，如
则不发生变化，
printf("\nallocated=od,
接下来我们观察一下PyListObject对象的创建和删除对于Pyhon维护的PyList-
如果在追加元素3之后就删除元素2，可以看到，ob_size发生了变化，而allocated
第4章
这次为了消除Pyton交互环境执行时对pyListObject对象缓冲池的影响，我们通过
如果继续向11st末尾追加元素3、4、5，在追加了元素5之后，11st所拥有的内存