title:Transparent ROP Exploit Mitigation Using Indirect Branch Tracing
author:Vasilis Pappas and
Michalis Polychronakis and
Angelos D. Keromytis
Transparent ROP Exploit Mitigation Using  
Indirect Branch Tracing
Vasilis Pappas, Michalis Polychronakis, and Angelos D. Keromytis, Columbia University
Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Transparent ROP Exploit Mitigation using Indirect Branch Tracing
Vasilis Pappas, Michalis Polychronakis, Angelos D. Keromytis
Columbia University
Abstract
Return-oriented programming (ROP) has become the
primary exploitation technique for system compromise
in the presence of non-executable page protections. ROP
exploits are facilitated mainly by the lack of complete
address space randomization coverage or the presence
of memory disclosure vulnerabilities, necessitating ad-
ditional ROP-speciﬁc mitigations.
In this paper we present a practical runtime ROP ex-
ploit prevention technique for the protection of third-
party applications. Our approach is based on the detec-
tion of abnormal control transfers that take place during
ROP code execution. This is achieved using hardware
features of commodity processors, which incur negli-
gible runtime overhead and allow for completely trans-
parent operation without requiring any modiﬁcations to
the protected applications. Our implementation for Win-
dows 7, named kBouncer, can be selectively enabled for
installed programs in the same fashion as user-friendly
mitigation toolkits like Microsoft’s EMET. The results of
our evaluation demonstrate that kBouncer has low run-
time overhead of up to 4%, when stressed with specially
crafted workloads that continuously trigger its core de-
tection component, while it has negligible overhead for
actual user applications. In our experiments with in-the-
wild ROP exploits, kBouncer successfully protected all
tested applications, including Internet Explorer, Adobe
Flash Player, and Adobe Reader.
1 Introduction
Despite considerable advances in system protection and
exploit mitigation technologies, the exploitation of soft-
ware vulnerabilities persists as one of the most common
methods for system compromise and malware infection.
Recent prominent examples include in-the-wild exploits
against Internet Explorer [7], Adobe Flash Player [2],
and Adobe Reader [19, 1], all capable of successfully
bypassing the data execution prevention (DEP) and ad-
dress space layout randomization (ASLR) protections of
Windows [49], even on the most recent and fully updated
(at the time of public notice) systems.
Data execution prevention and similar non-executable
page protections [55], which prevent the execution of in-
jected binary code (shellcode), can be circumvented by
reusing code that already exists in the vulnerable pro-
cess to achieve the same purpose. Return-oriented pro-
gramming (ROP) [62], the latest advancement in the
more than a decade-long evolution of code reuse at-
tacks [30, 51, 50, 43], has become the primary exploita-
tion technique for achieving arbitrary code execution in
the presence of non-executable page protections.
Although DEP is complemented by ASLR, which
is meant to prevent code reuse attacks by randomiz-
ing the load addresses of executables and DLLs, its de-
ployment is problematic. A few code segments left in
static locations can be enough for mounting a robust
ROP attack, and unfortunately this is quite often the
case [35, 75, 40, 54]. More importantly, even if a process
is fully randomized, it might be possible to calculate the
base address of a DLL at runtime [19, 61, 44, 69, 37, 66],
or infer it in a brute-force way [63].
This situation has prompted active research on ad-
ditional defenses against return-oriented programming.
Recent proposals can be broadly classiﬁed in static
software hardening and runtime monitoring solutions.
Schemes of the former type include compiler extensions
for the protection of indirect control transfers [45, 52],
which break the chaining of the “gadgets” that comprise
a return-oriented program, and code diversiﬁcation tech-
niques based on static binary rewriting [70, 53], which
randomize the locations or the outcome of the available
gadgets. The lack of source code for proprietary software
hinders the deployment of compiler-based approaches.
Depending on the applied code transformations, static
binary rewriting approaches may be applied on stripped
binaries, but their outcome depends on the accuracy
USENIX Association  
22nd USENIX Security Symposium  447
of code disassembly and control ﬂow graph extraction,
while the rewriting phase is time-consuming. Depending
on the vulnerable program, ﬁne-grained code randomiza-
tion may be circumvented by dynamically building the
ROP payload at the time of exploitation [66, 16]. Run-
time solutions monitor execution at the instruction level
to apply various protection approaches, such as perform-
ing anomaly detection by checking for an unusually high
frequency of
instructions [24, 28], ensuring the in-
tegrity of the stack [29], or randomizing the locations of
code fragments [36]. The use of dynamic binary instru-
mentation allows these systems to be transparent to the
protected applications, but is also their main drawback,
as it incurs a prohibitively high runtime overhead.
Transparency is a key factor for enabling the practi-
cal applicability of techniques that aim to protect pro-
prietary software. The absence of any need for modiﬁ-
cations to existing binaries ensures an easy deployment
process, and can even enable the protection of applica-
tions that are already installed on end-user systems [47].
At the same time, to be practical, mitigation techniques
should introduce minimal overhead, and should not af-
fect the proper execution of the protected applications
due to incompatibility issues or false positives.
Aiming to fulﬁll the above requirements, in this pa-
per we present a fully transparent runtime ROP exploit
mitigation technique for the protection of third-party ap-
plications. Our approach is based on monitoring the ex-
ecuted indirect branches at critical points during the life-
time of a process, and identifying abnormal control ﬂow
transfers that are inherently exhibited during the execu-
tion of ROP code. The technique is built around Last
Branch Recording (LBR), a recent feature of Intel pro-
cessors. Relying mainly on hardware for instruction-
level monitoring allows for minimal runtime overhead
and completely transparent operation, without requiring
any modiﬁcations to the protected applications.
or
Inspired by application hardening toolkits like Mi-
crosoft’s EMET [47], our prototype implementation for
Windows 7, named kBouncer, can be selectively enabled
for the protection of already installed applications. Be-
sides typical ROP code, kBouncer can also identify the
execution of “jump-oriented” code that uses gadgets end-
ing with indirect
instructions. To mini-
mize context switching overhead, branch analysis is per-
formed only before critical system operations that could
cause any harm. To verify that kBouncer introduces min-
imal overhead, we stress-tested our implementation with
workloads that trigger excessively the protected system
functions. In the worst case, the average measured over-
head was 1%, and it never exceeded 4%. As the protected
operations occur several orders of magnitude less fre-
quently in regular applications, the performance impact
of kBouncer in practice is negligible. We evaluated the
effectiveness and practical applicability of our technique
using publicly available ROP exploits against widely
used software, including Internet Explorer, Adobe Flash
Player, and Adobe Reader. In all cases, kBouncer blocks
the exploit successfully, and notiﬁes the user through a
standard error message window.
The main contributions of our work are:
• We present a practical and transparent ROP exploit
mitigation technique based on runtime monitoring
of indirect branch instructions using the LBR fea-
ture of recent CPUs.
• We have implemented the proposed approach as a
self-contained toolkit for Windows 7, and describe
in detail its design and implementation.
• We provide a quantitative analysis of the robust-
ness of the proposed ROP code execution preven-
tion technique against potential evasion attempts.
• We have experimentally evaluated the performance
and effectiveness of kBouncer, and demonstrate that
it can prevent in-the-wild exploits against popular
applications with negligible runtime overhead.
2 Practical Indirect Branch Tracing for
ROP Prevention
The proposed approach uses runtime process monitor-
ing to block the execution of code that exhibits return-
oriented behavior. In contrast to typical program code,
the code used in ROP exploits consists of several small
instruction sequences, called gadgets, scattered through
the executable segments of the vulnerable process. Gad-
gets end with an indirect branch instruction that transfers
control to the following gadget according to a sequence
of gadget addresses contained in the “payload” that is in-
jected during the attack. As the name of the technique
implies, gadgets typically end with a
instruction, al-
though any combination of indirect control transfer in-
structions can be used [23].
The key observation behind our approach is that the
execution behavior of ROP code has some inherent at-
tributes that differentiate it from the execution of legit-
imate code. By monitoring the execution of a process
while focusing on those properties, kBouncer can iden-
tify and block a ROP exploit before its code accom-
plishes any critical operation.
In this section, we discuss in detail how kBouncer
leverages the Last Branch Recording feature of recent
processors to retrieve the sequence of the most recent in-
direct branch instructions that took place right before the
invocation of a system function. In the following sec-
tion, we discuss how kBouncer uses this information to
identify the execution of ROP code. As the vast major-
ity of in-the-wild ROP exploits target Windows software,
448  22nd USENIX Security Symposium 
USENIX Association
Table 1: Qualitative comparison of alternative techniques
for runtime branch monitoring.
our design focuses on achieving transparent operation for
existing Windows applications without raising any com-
patibility issues or false alerts.
2.1 Branch Tracing vs. Other Approaches
Execution monitoring at the instruction level usually
comes with an increased runtime overhead. Even when
tracking only a particular subset of instructions, e.g., in
our case only indirect control transfer instructions, the
overhead of interrupting the normal ﬂow of control and
updating the necessary accounting information is pro-
hibitive for production systems. There are several dif-
ferent approaches that can be followed for monitoring
the execution of indirect branch instructions, each of
them having different requirements, performance over-
head, transparency level, and deployment effort.
Extending the compiler to generate and embed run-
time checks in the executable binary at compile time is
one of the simplest techniques [52]. However, the high
frequency of control transfer instructions in typical code
means that a lot of additional instrumentation code must
be added. Also, deployment requires a huge effort as all
programs have to be recompiled. Another option is static
binary rewriting. Its main advantage over compiler-level
techniques is that no source code is required, but only
debug symbols (e.g., PDB ﬁles) [17]. Still, all control
transfers need to be checked. Even worse, it breaks self-
checksumming or signed code and cannot be applied to
self-modifying programs. Dynamic binary instrumenta-
tion is another alternative that can handle even stripped
binaries (no need for source code or debug symbols), but
the runtime performance overhead of existing binary in-
strumentation frameworks slows down the normal exe-
cution of an application by a factor of a few times [29].
In contrast to the above approaches, our system moni-
tors the executed indirect branch instructions using Last
Branch Recording (LBR) [39, Sec. 17.4], a recent fea-
ture of Intel processors introduced in the Nehalem archi-
tecture. When LBR is enabled, the CPU tracks the last
N (16 for the CPU model we used) most recent branches
in a set of 64-bit model-speciﬁc registers (MSR). Each
branch record consists of two MSR registers, which hold
the linear addresses of the branch instruction and its
target instruction, respectively. Records from the LBR
stack can be retrieved using a special instruction (
)
from privileged mode. The processor can be conﬁgured
to track only a subset of branches based on their type:
relative/indirect calls/jumps, returns, and so on.
Table 1 shows a summarized comparison of the alter-
native strategies discussed above. For our particular case,
the use of LBR has several advantages:
it incurs zero
overhead for storing the branches; it is fully transparent
to the running applications; is does not cause any incom-
patibility issues as it is completely decoupled from the
actual execution; it does not require source code or debug
symbols; and it can be dynamically enabled for already
installed applications—there is no need for recompila-
tion or instruction-level instrumentation.
2.2 Using Last Branch Recording for ROP
Prevention
Although the CPU continuously records the most recent
branches in the LBR stack with zero overhead, accessing
the LBR registers and retrieving the recorded informa-
tion unavoidably adds some overhead. Considering the
limited size (16 entries) of the LBR stack, and that it can
be accessed only from kernel-level code, checking the
targets of all indirect control transfer instructions would
incur a prohibitively high performance overhead. Indi-
rect branches occur very frequently in typical programs,
and a monitored process should be interrupted once ev-
ery 16 branches with a context switch. In fact, the im-
plementation of such a scheme is not facilitated by the
current design of the LBR feature, as it does not provide
any means of interrupting execution whenever the stack
gets full after retrieving its previous 16 records.
Fortunately, when considering the actual operations of
a ROP exploit, it is possible to dramatically reduce the
number of control transfer instructions that need to be in-
spected. The typical end goal of malicious code is to give
the attacker full control of the victim system. This usu-
ally involves just a few simple operations, such as drop-
ping and executing a malicious executable on the victim
system, which unavoidably require interaction with the
OS through the system call interface. Based on this ob-
servation, we can reﬁne the set of indirect branches that
need to be inspected to only those along the ﬁnal part
of the execution path that lead to a system call invoca-
tion. (Depending on the vulnerable program, exploita-
tion might be possible without invoking any system call,
e.g., by modifying a user authentication variable [25], but
such attacks are rarely found in the client-side applica-
tions that are typically targeted by current ROP exploits,
and are outside the scope of this work.)
Figure 1 illustrates this approach. Vertical bars corre-
spond to snapshots of the address space of a process, and
arrows correspond to indirect control transfers. The ver-
USENIX Association  
22nd USENIX Security Symposium  449
LBR check
kernel
user
space
time
system call
Figure 1: Illustration of a basic scheme for ROP code de-
tection. Whenever control is transferred from user to ker-
nel space (vertical line), the system inspects the most re-
cent indirect branches to decide whether the system call
was invoked by ROP code or by the actual program.
tical line denotes the point at which the ﬂow of control
is transferred from user space to kernel space through a
system call. At this point, by interposing at the OS’s sys-
tem call handler, the system can access the LBR stack
and retrieve the targets of the indirect branches that led
to the system call. It can then check the control ﬂow path
for abnormal control transfers and distinctive properties
of ROP-like behavior using the techniques that will be
described in Sec. 3, and decide whether the system call
is part of malicious ROP code, or it is being invoked le-
gitimately by the actual program.
2.2.1 System Calls vs. API Calls
User-level programs interact with the underlying system
mainly through system calls. Unix-like systems provide
to applications wrapper functions for the available sys-
tem calls (often using the same name as the system call
they invoke) as part of the standard library. In contrast,
Windows does not expose the system call interface di-
rectly to user-level programs. Instead, programs inter-
act with the OS through the Windows API [13], which
is organized into several DLLs according to different
kinds of functionality. In turn, those DLLs call functions
from the undocumented Native API [59], implemented
in
, to invoke kernel-level services.
Exploit code rarely relies on the Native API for sev-
eral reasons. One problem is that system call numbers
change between Windows versions and service pack lev-
els [18, 14], reducing the reliability of the exploit across
different targets (or increasing attack complexity by hav-
ing to adjust the exploit according to the victim’s OS ver-
sion). Most importantly, the desired functionality is often
not conveniently exposed at all through the Native API,
as for example is the case with the socket API [65]. Typi-
cally, the purpose of ROP code is to give execute permis-
sion to a second-stage shellcode using
or a similar API function [31, 27, 1, 6, 7, 2]. The
s
n
o
i
t
c
n
u
f
I
P
A
f
o
n