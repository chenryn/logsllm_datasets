52
21
21
52
21
52
21 118
21 118
164
167
167
179
179
179
179
212
212
170
173
173
183
183
185
185
212
212
6
6
6
6
6
6
6
327
327
6
6
6
6
6
6
6
327
327
36
36
36
36
36
36
36
3
3
36
36
36
46
46
46
46
3
3
19
19
19
18
18
18
18
19
19
19
19
19
18
18
18
18
19
19
13
13
13
13
13
13
13
34
34
13
13
13
13
13
13
13
34
34
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
3
3
3
3
3
3
3
4
4
3
3
3
3
3
3
3
4
4
6
6
6
6
6
6
6
8
8
6
6
6
7
7
7
7
8
8
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
9
9
9
9
9
9
9
1
1
9
9
9
9
9
9
9
1
1
Functional† Memory-related
E1 E2 E3 E4 E5 E6‡E7 E8‡ E9
✓ ✓ ✓ ✓ ✓ ✓ · ✓ ✓
✓ ✓ ✓ ✓ ✓ ✓ · ✓ ✓
✓ ✓ ✓ ✓ ✓ ✓ · ✓ ✓
✓ ✓ ✓ ✓ ✓ ✓ · ✓ ✓
✓ ✓ ✓ ✓ ✓ ✓ · ✓ ✓
✓ ✓ ✓ ✓ ✓ ✓ · ✓ ✓
✓ ✓ ✓ ✓ ✓ ✓ · ✓ ✓
· ✓ ✓ ·
· ✓ ✓
· ✓ ✓ ·
· ✓ ✓
✓ ✓ ✓ ✓ ✓ ✓ · ✓ ✓
✓ ✓ ✓ ✓ ✓ ✓ · ✓ ✓
✓ ✓ ✓ ✓ ✓ ✓ · ✓ ✓
✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓
✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓
✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓
✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓
· ✓ ✓ ·
· ✓ ✓ ✓
· ✓ ✓ ·
· ✓ ✓ ✓
·
·
·
·
·
·
Common Mismatch: mismatches that are discovered by both comparisons in common. {Syntactic, Semantic}-only Mismatch: mismatches from only one comparison,
i-IE: imperative IEs. n-IE: non-imperative IEs,
† Confirmed to be non-compliant to the Release 15 specification, ‡ 0-day vulnerabilities that lead to remote code execution (RCE).
VII. EVALUATION
matches? (§VII-B)
To evaluate BASESPEC, we answer the following questions:
• How effectively can BASESPEC discover specification mis-
• How effective is the approach of BASESPEC in discovering
• How applicable is BASESPEC to inspect various firmware
• How applicable is BASESPEC to firmware images from other
versions and device models? (§VII-D)
new bugs of baseband? (§VII-C)
vendors? (§VII-E)
A. Experimental Setup
Dataset. We collected firmware images from a third-party
website [62], as described in §IV-A. We downloaded the latest
and oldest firmware images from Vendor1, which is one of the
top 3 baseband chipset vendors. Note that the device models of
these firmware images are officially supported by the vendor
at the time of writing (July 1, 2020), as listed in Table IV.
We chose the latest and oldest ones because they have the
largest differences; thus, analyzing them can effectively show
the applicability of BASESPEC on diverse versions/models
(§VII-D). Further, we applied BASESPEC to another one of the
top 3 vendors, Vendor2 (§VII-E).
Specification. Among the various releases of the specification,
we chose Release 15 as its freeze point was on March 22, 2019.
Therefore, the development for this specification was finished,
and it was stable [2].3 The detailed specification versions that
we referred to are listed in Table I.
Machine. We ran all experiments on a server equipped with
Intel Core i7-6700K at 4.00 GHz, 64 GB DDR4 RAM, and 2
TB SSD, operated on a Windows 10 operating system.
B. Comparative Analysis Results
Table IV shows the mismatches identified by BASESPEC.
In summary, BASESPEC successfully discovered hundreds of
3Release 16 is just frozen at July 3rd, 2020.
11
mismatches in the firmware, which shows that its decoder does
not comply with the specifications. In particular, BASESPEC
extracts 277 standard L3 messages from the specification and
compares them with messages implemented in the binary (the
# of msgs column). For each message, BASESPEC checks three
types of mismatches: Missing, Unknown, and Invalid. We count
the number of mismatches separately for the imperative IEs
(i.e., i-IE) and for non-imperative IEs (i.e., n-IE) because such
IEs differentiate implications of mismatches as below.
Missing & Unknown IEs. BASESPEC found several missing
IEs, which remain as unimplemented in the firmware binaries
(Missing in Table IV). Theoretically, the baseband firmware
should implement every IE in the specification to support
complete functionalities defined in the specification. As non-
imperative IEs are literally optional, they can be ignored in
a message. However, imperative IEs must be present in a
message; otherwise, the baseband cannot properly decode
benign messages, thereby degrading the cellular service quality.
Further, BASESPEC discovered numerous unknown IEs that
are not defined in the specification (Unknown in Table IV). The
unknown IEs may be caused by incorrect implementations by
developers. For example, if a developer incorrectly enters an
IEI (i.e., IE identifier), BASESPEC will consider the originally
intended IE as missing, and the IE with the incorrect IEI as
unknown. Therefore, these mismatches can locate functional
errors that break compliance with the specification.
Invalid IEs. BASESPEC showed that hundreds of IEs are
incorrect with the specification (the Invalid column). An IE
consists of three parts: IEI, LI, and value. The decoder function
uses only IEI and LI to validate a message and propagates the
message to a message-specific handler. BASESPEC has already
identified incorrect usages of IEIs as unknown mismatches, and
it reports an IE with incorrect LI as invalid mismatches. Such
invalid IEs imply that an improper message can be delivered to
the handler function; therefore, if the handler fails to address this
message properly, it can lead to a critical memory corruption
vulnerability. For instance, the E6 bug, which will be described
in §VIII, incorrectly assumes the maximum length of an IE,
thereby resulting in buffer overflow for RCE.
Syntactic vs Semantic mismatches. BASESPEC employs
syntactic and semantic methods for comparison, and both
methods are complementary and essential. In particular, the
syntactic comparison can find more missing/unknown IEs, while
the semantic comparison can discover more invalid IEs (see the
Syntactic-only Mismatch and Semantic-only Mismatch columns);
the unusual number of mismatches in the Model H and I
firmware will be described below. Both methods help us identify
different error cases and their explicit causes. For example,
mismatches in the syntactic comparison helped us pinpoint
developers’ mistakes regarding imperative IEs without LIs.
Recall that such imperative IEs cannot be supported by semantic
analysis (§V-D). Moreover, the numerous invalid IEs in the
semantic comparison helped us discover the abnormal handling
of IE lengths in the decoder function, which is inconsistent with
the binary-embedded structures for syntactic comparison. This
leads us to discover overflow vulnerabilities in handler functions.
Consequently, these two methods are mutually complementary.
False positives. BASESPEC shows false positive results for
two main reasons: limited support of the ARM architecture
in angr and exceptional message structures in the baseband
implementation. First, BASESPEC’s semantic analysis could
not fully process the Model H and I firmware, resulting in
an unusual number of mismatches (see their results in the
Semantic-only Mismatch column). We noticed that their binaries