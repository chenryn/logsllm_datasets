      char *locale_path;
      size_t locale_path_len;
      const char *locpath_var;
      char *composite;
      /* Sanity check for CATEGORY argument.  */
      if (__builtin_expect (category, 0) = __LC_LAST)
        ERROR_RETURN;
      /* Does user want name of current locale?  */
      if (locale == NULL)
        return (char *) _nl_global_locale.__names[category];
###  3.3 setlocale(LC_ALL,”C”)
先申明一下”C”是`_nl_global_locale.__names`的默认值或者说是初始值，在代码中以`_nl_C_name`表示。`setlocale(LC_ALL,"C")`执行结果是将`_nl_global_locale.__names`的值都变成指向字符串`"C"`的指针。
    //glibc-2.31\locale\findlocale.c
    struct __locale_data *
    _nl_find_locale (const char *locale_path, size_t locale_path_len,
         int category, const char **name)
    {
      int mask;
      /* Name of the locale for this category.  */
      const char *cloc_name = *name;
      const char *language;
      const char *modifier;
      const char *territory;
      const char *codeset;
      const char *normalized_codeset;
      struct loaded_l10nfile *locale_file;
      if (cloc_name[0] == '\0') //此时if条件不满足，因为cloc_name[0]='C'
        {
          /* The user decides which locale to use by setting environment
       variables.  */
          cloc_name = getenv ("LC_ALL");
          if (!name_present (cloc_name))
      cloc_name = getenv (_nl_category_names_get (category));
          if (!name_present (cloc_name))
      cloc_name = getenv ("LANG");
          if (!name_present (cloc_name))
      cloc_name = _nl_C_name;
        }
      /* We used to fall back to the C locale if the name contains a slash
         character '/', but we now check for directory traversal in
         valid_locale_name, so this is no longer necessary.  */
      if (__builtin_expect (strcmp (cloc_name, _nl_C_name), 1) == 0 //cloc_name==_nl_C_name，条件满足
          || __builtin_expect (strcmp (cloc_name, _nl_POSIX_name), 1) == 0)
        {
          /* We need not load anything.  The needed data is contained in
       the library itself.  */
          *name = _nl_C_name;
          return _nl_C[category];
        }
再看一下设置`_nl_global_locale.__names`的代码，此处的name与上述代码的name不是同一个变量，但是指向的字符串内容是一样的，并且setname函数中的name是指向堆的（例外就是指向`_nl_C_name`，是个全局变量），每次修改`_nl_global_locale.__names`的值，会将原先的chunk进行free。
    //glibc-2.31\locale\setlocale.c
    static void
    setname (int category, const char *name)
    {
      if (_nl_global_locale.__names[category] == name)
        return;
      if (_nl_global_locale.__names[category] != _nl_C_name)
        free ((char *) _nl_global_locale.__names[category]);
      _nl_global_locale.__names[category] = name;
    }
###  3.4 setlocale(LC_ALL,”xxx”)
如果”xxx”是一个正常值，那么就是会分析出xxx是否存在 **分号** 来判断是设置全部LC_的值为同一个还是各自设置的不一样。  
如果存在`;`，那么”xxx”的结构应该是如`LC_CTYPE=.....;LC_NUMERIC=...;....LC_IDENTIFICATION=....`。  
看下setlocale函数中的代码
    //in function setlocale
          if (__glibc_unlikely (strchr (locale, ';') != NULL)) //locale等于传入的“xxx”，比如“LC_CTYPE=c.utf8”
      {
        /* This is a composite name.  Make a copy and split it up.  */
        locale_copy = __strdup (locale);
        if (__glibc_unlikely (locale_copy == NULL))
          {
            __libc_rwlock_unlock (__libc_setlocale_lock);
            return NULL;
          }
        char *np = locale_copy;
        char *cp;
        int cnt;
        while ((cp = strchr (np, '=')) != NULL) //此时np指向"L",cp指向"="
          {
            for (cnt = 0; cnt next = this;
        else
          result->entry = this;
        last = this;
      }
        }
      while (!__feof_unlocked (fp));
      free (line); //释放line，会释放一个0x80的chunk，在大于glibc-2.25的情况下，大概率放入tcachebins
      fclose (fp);
      return result;
    }
###  4.2 nss_getline
    //glibc-2.31\nss\nsswitch.c
    static name_database_entry *
    nss_getline (char *line)
    {
      const char *name;
      name_database_entry *result;
      size_t len;
      /* Ignore leading white spaces.  ATTENTION: this is different from
         what is implemented in Solaris.  The Solaris man page says a line
         beginning with a white space character is ignored.  We regard
         this as just another misfeature in Solaris.  */
      while (isspace (line[0]))
        ++line;
      /* Recognize ` ":"'.  */
      name = line;
      while (line[0] != '\0' && !isspace (line[0]) && line[0] != ':')//line指到空格或者":"
        ++line;
      if (line[0] == '\0' || name == line)
        /* Syntax error.  */
        return NULL;
      *line++ = '\0';//以第一行为例，此时*name="passwd"
      len = strlen (name) + 1;
      result = (name_database_entry *) malloc (sizeof (name_database_entry) + len);//sizeof(name_database_entry)=0x10，最后申请到chunk的大小根据len的长度确定。