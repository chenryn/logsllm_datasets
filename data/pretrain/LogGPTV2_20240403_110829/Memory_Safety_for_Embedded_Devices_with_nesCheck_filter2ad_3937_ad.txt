of the TelosB platform chosen for this experiment.
Checks Reduction. As part of our experimental anal-
ysis, we collected statistics about the number of runtime
checks added to the programs during the instrumentation,
together with the checks that are removed as part of nesCheck’s
Figure 9: Checks added and checks skipped in the
instrumented TinyOS sample apps benchmark.
check reduction. This metric includes the reduction both
due to pointer kind classiﬁcation and our additional anal-
ysis of pointer usage, which leads to removing additional
checks whenever memory accesses can be statically veriﬁed
as safe. As shown in Figure 9, the complete analysis and in-
strumentation of nesCheck for all the TinyOS applications
overall reduces, on average, the required checks by 20% of
the total potentially vulnerable locations, greatly reducing
the performance overhead in enforcing memory safety. For
the whole benchmark suite, an average of 452 checks are
added, and 110 are skipped.
Energy Overhead. The power consumption for the vari-
ous operations – such as computation, radio communication,
standby or sleep – varies across the diﬀerent sensor mote
hardware platforms. However, on all platforms, the majority
of the power consumption is always caused by wireless trans-
mission and reception, as well as the transitions between the
on and oﬀ states of the radio. Shnayder et al., for example,
806619338111381111116690.443022124627625252632.33020406080100120140160180200BaseStationBlinkMultihopOscilloscopeNullOscilloscopePowerupRadioCountToLedsRadioSenseToLedsSenseAverageMetadata lookupsEntries181856365064906356456132774.44120884962410824100100104129.330200400600800100012001400160018002000BaseStationBlinkMultihopOscilloscopeNullOscilloscopePowerupRadioCountToLedsRadioSenseToLedsSenseAverageOriginal RAMOverhead3692731451139490143465463279452.448349397301343011210749110.11BaseStationBlinkMultihopOscilloscopeNullOscilloscopePowerupRadioCountToLedsRadioSenseToLedsSenseAverageChecks AddedChecks SkippedFigure 10: Fault injection results on TinyOS bench-
mark.
Figure 11: Naive vs. optimized instrumentation on
TinyOS benchmark.
quantitatively measure that, in many cases, active CPU cy-
cles in WSN applications are very small, and have negligible
eﬀect on total power consumption [30]. The instrumenta-
tion of nesCheck in TinyOS programs does not introduce
any additional radio communication, while instead adding
some runtime computation for the dynamic checks. There-
fore, the energy overhead is, intuitively, proportional to the
performance overhead that we measured in our experiments
by a factor of CPU energy consumption.
Since measuring the energy consumption directly on the
motes’ hardware is diﬃcult [33], to quantify this metric we
leverage the energy model proposed by Polastre et al. [28].
We refer to the MicaZ motes hardware platform datasheet [22]
(being the platform simulated by TOSSIM), and multiply
the battery voltage by current draw and time. With those
calculations, the energy overhead for nesCheck amounts on
average to 0.84%, a negligible quantity that supports our
analytical expectations.
Fault Injection. To evaluate the eﬀectiveness of nesCheck
in preventing all memory errors, we randomly injected mem-
ory vulnerabilities and bugs in the TinyOS applications.
We injected 500 random faults in each applications in the
TinyOS benchmark, for a total of 4, 500 faults. In partic-
ular, each time we selected one random memory access, al-
tered its indices to produce a memory error, and included
an extra printing instruction to mark the moment when the
memory fault occurs; we then instrumented the application
and executed it. We expected nesCheck to correctly ﬁnd
the fault, either statically or at runtime, and prevent the
out-of-bounds access. Figure 10 shows our results. On av-
erage, 22% of the injected faults were statically caught at
compile time. 37% of the faults were injected in areas of the
code that were not executed at runtime. For the injected
faults that were executed at runtime (41% on average), 100%
were correctly caught by the dynamic checks placed by the
nesCheck’s instrumentation, i.e., no fault occurred and went
uncaught.
Naive vs. Optimized Approach. While a direct com-
parison of nesCheck with traditional techniques such as Soft-
Bound or CCured is infeasible due to (i) constraints of em-
bedded systems, and (ii) the missing implementation of Soft-
Bound or CCured for embedded systems, we measure the
performance beneﬁts of nesCheck’s check reduction to get
an estimate of the improvement over those traditional tech-
niques. We run nesCheck with (“optimized”) and without
(“naive”) check reduction optimizations, and run it on all the
applications in the benchmark (excluding those that did not
yield events in our performance overhead evaluation) Fig-
ure 11 shows a comparison of the overhead of the naive and
optimized executions of the instrumented programs. We ob-
serve an overhead reduction of 41.13% on average, showing
how nesCheck’s check reduction eﬀectively leads to signiﬁ-
cant performance improvements.
7. LIMITATIONS
Currently, a sensor node instrumented with nesCheck is
rebooted when a dynamic check fails. Since this might not
always be the best option, in the future, we plan to work on
more advanced, programmer-guided recovery mechanisms,
with the goal of maintaining the network as functional as
possible even in the presence of memory errors.
An attacker could attempt to repeatedly trigger a mem-
ory error, which nesCheck’s protection would counter by re-
booting the software, to achieve DoS. However, nesCheck’s
memory safety guarantees ensure that a memory safety error
cannot be used for malicious intents (except for DoS).
More powerful computing platforms (e.g., Raspberry PI)
are becoming increasingly available. However, they are im-
practical for common WSN application purposes, with sig-
niﬁcantly higher cost, energy requirements, and size, as com-
pared to low-power WSN nodes. The latter have the advan-
tages of being cheap, easily replaceable, deployable in bulk,
and in need of little energy. Even when such more advanced
devices will become suﬃciently cost-eﬀective for large de-
ployments, eﬃciency would still remain a critical concern
for memory safety techniques, as the number and scale of
applications deployed on them would consequently increase
as well. We plan to work in this direction to investigate
how nesCheck can be ported to more powerful platforms,
and leverage the additional capabilities of these platforms
to further improve performance.
19.3%19.1%17.9%21.2%25.8%22.2%21.2%23.3%24.3%21.6%44.1%40.6%40.8%42.4%25.0%44.9%28.6%26.0%33.8%36.8%36.6%40.3%41.4%36.5%49.2%32.9%50.1%50.7%41.9%41.5%0%10%20%30%40%50%60%70%80%90%100%BaseStationBlinkMultihopOscilloscopeNullOscilloscopePowerupRadioCountToLedsRadioSenseToLedsSenseAverageStatic bugsNot ExecutedExecuted and CaughtExecuted and Not Caught10.88%3.56%2.78%2.90%1.54%7.04%8.39%0.47%0.90%1.17%0.82%5.14%0%1%2%3%4%5%6%7%8%9%10%11%12%BlinkMultihopOscilloscopeOscilloscopeRadioCountToLedsRadioSenseToLedsSenseNaïvenesCheckOur evaluation did not ﬁnd instances of memory bugs in
TinyOS – a reasonable outcome since the code base is small
and has been widely used for several years (i.e., bugs were
ﬁxed), while at the same time seeing very few modiﬁcations
(i.e., no new bugs). Also, at runtime, nesCheck evaluates
only the executed code paths, not all possible code paths.
The current prototype of nesCheck enforces spatial mem-
ory safety. Our approach could, however, be extended to
also enforce temporal memory safety. Note that most WSN
applications do not use dynamic memory allocation, and are
therefore fully protected by spatial safety alone. Neverthe-
less, we plan to extend our implementation of nesCheck to
explicitly address temporal safety, and design mechanisms
tailored for embedded platforms to enforce it.
When determining the set of vulnerable pointers, (a) false
negatives (i.e., pointers marked as Safe when they are not)
cannot occur, as nesCheck is conservative in case of ambigu-
ity, and (b) false positives (i.e., pointers not marked as Safe
when they are) do not compromise the security invariants
but only cause performance degradation. Our experimental
analysis shows that nesCheck’s overall overhead is small.
Lastly, the scalability of the system, and further overhead
reduction, are of great importance. We plan to investigate
whether the integration of Bounded Model Checking tech-
niques [2] in nesCheck helps in that direction, as it would en-
able the use of formal veriﬁcation techniques for proving the
safety of seemingly dangerous memory accesses, therefore
further reducing the overhead. Note that there are several
issues that make formal veriﬁcation on embedded software
hard. Several patterns – such as direct communication with
hardware registries for sensing, network packets, frequent in-
terrupts, or the use of bit ﬁelds – cause the search space for
formal veriﬁcation to quickly explode. Dynamic checks are
able to cope with these patterns, at the price of performance.
8. RELATED WORK
Memory safety is an ongoing research topic [34]. Attacks
to WSN software through memory vulnerabilities have been
widely investigated. Against common belief that Harvard-
architecture devices would prevent code injection attacks,
Francillon et al. [11] showed a detailed exploit for code in-
jection without size limitation through carefully crafted net-
work packets. Giannetsos et al. carried out a similar study [15],
targeting Von Neumann-architecture devices. These two
works cover most common architectures for WSNs, able to
exploit, for example, both MicaZ and TelosB motes.
From the defense point of view, research work has typ-
ically taken three diﬀerent directions: runtime protection,
formal analysis and symbolic execution. nesCheck uses an
approach that enhances the runtime protection class of mech-
anisms with static analysis techniques.
Runtime protection. Necula et al.
introduce an ex-
tended type system for CCured [26]. CCured uses pointer
classiﬁcation as a static analysis technique to infer safe point-
ers that do not need bounds checks; however, it instruments
all non-safe pointers in the code with runtime checks, poten-
tially generating many unnecessary checks. nesCheck over-
comes this issue by leveraging more extensive static anal-
ysis techniques to conservatively detect whether some of
the sequence pointers can be left unchecked too, as well as
detecting statically-recognizable memory violations. Soft-
Bound [24] is a compile-time approach that instruments C
code to enforce spatial memory safety by (i) keeping track
of the properties of each the pointed memory area, and (ii)
wrapping each memory access with a bounds check.
Its
design is geared towards platforms with large amounts of
memory and virtual memory mechanisms, as it needs to
maintain metadata about each pointer at runtime. Such re-
sources are not available on constrained embedded devices.
nesCheck leverages static analysis (see Section 4.1) to mini-
mize the number of pointers whose metadata is managed in-
memory at runtime, replacing the global metadata with lo-
cal stack variables or conservatively removing the metadata
completely (for speciﬁc pointers). While nesCheck too lever-
ages dynamic runtime checking to enforce memory safety, it
tailors and optimizes this approach to the speciﬁc character-
istics of nesC applications in order to improve performance.
Compared to the notable solutions just discussed, as well as
other traditional ones, nesCheck works for embedded soft-
ware, being designed speciﬁcally for their constraints, chal-
lenges, and advantages. One of the most relevant approaches
for memory protection in WSN applications – and TinyOS in
particular – is Safe TinyOS [8]. Cooprider et al. investigate
issues related to the implementation of memory protection
for TinyOS programs by formalizing the problem and the
requirements, and developing optimizations that make run-
time checks more viable under the strict performance con-
straints of WSN software. Safe TinyOS relies on the Deputy
source-to-source compiler [7] to infer necessary information
for the code instrumentation. Note that the Deputy project
is no longer maintained. Safe TinyOS, however, puts much
of the analysis burden on the programmers, requiring them
to either annotate the code with speciﬁc type deﬁnitions
and safety guidelines, or to declare entire components as
“trusted” and therefore skipped by the tool. nesCheck, on
the other hand, automates the entire process, with no need
for source code modiﬁcations. Also, nesCheck reduces the
potential runtime overhead by removing unnecessary checks
before the instrumentation.
Formal analysis. Bucur et al. [4] propose a source-to-
source transformation tool to make TinyOS code processable
by the CBMC [6] bounded model checking [2] proving tool.
The well-known limitations of formal veriﬁcation, in particu-
lar the search space explosion, are inherited by this approach
too. Even though Bucur et al. propose several optimizations
to reduce the complexity to be handled, large-scale applica-
tions can still suﬀer by long times for analysis and potential
undecidability if the state becomes too big to be handled.
Symbolic execution. Sasnauskas et al. [29] build an
approach on top of the Klee symbolic execution framework
to debug TinyOS applications before deployment. Just like
for the formal analysis-based approaches, the bottlenecks for
these designs are: (i) the need for a good model deﬁnition
of the application to be tested, and (ii) the rapid explosion
of the search state. If either part of the design results in a
non-complete coverage of every possible vulnerability, then
not all the bugs can be eﬀectively identiﬁed. Conversely,
since nesCheck leverages runtime checks for all the memory
accesses that cannot be statically proven as safe, in a conser-
vative way, nesCheck is guaranteed to always catch all the
potential vulnerabilities and prevent memory corruption.
Hardware. Francillon et al. [12] propose a hardware
modiﬁcation to split the stack in a control ﬂow stack and
a data stack. While this is an interesting idea, it would re-
quire hardware manufacturers to change the platform (an
economically burdensome path unlikely to be pursuable).
nesCheck’s software-only approach does not require changes
to the hardware platform, nor to the source code.
9. CONCLUSIONS
We presented nesCheck, an approach that combines whole-
program static analysis and dynamic checking techniques to
eﬃciently enforce memory safety on nesC programs, with-
out requiring any source modiﬁcation. nesCheck implements
techniques to determine the presence of static memory bugs
in the code, as well as to instrument it with the required set
of runtime checks. It focuses on minimizing the overhead for
the dynamic checks, considering the strict constraints of em-
bedded systems. Through extensive evaluation benchmarks
– both on speciﬁcally constructed programs and the stan-
dard TinyOS applications – we showed the eﬀectiveness of
nesCheck in enforcing memory protection while minimizing
the runtime performance overhead (0.84% on energy, 5.3%
on code size, up to 8.4% on performance, and 16.7% on
RAM).
Acknowledgments
We thank our shepherd Lucas Davi and the anonymous re-
viewers for their insightful comments, as well as Scott A.
Carr, Nathan Burow, and Gregory Essertel for helpful dis-
cussions about diﬀerent aspects of the work. The work re-
ported in this paper has been supported, in part, by the Na-
tional Science Foundation under grants CNS-1547358, CNS-
1513783, and CNS-1657711, and by Purdue PLM Center.
10. REFERENCES
[1] T. M. Austin, S. E. Breach, and G. S. Sohi. Eﬃcient
detection of all pointer and array access errors. In
ACM PLDI, 1994.
[2] A. Biere, A. Cimatti, E. Clarke, and Y. Zhu. Symbolic
model checking without BDDs. Springer, 1999.
[3] D. Bucur. Intelligible tinyos sensor systems:
Explanations for embedded software. In Modeling and
Using Context, pages 54–66. Springer, 2011.
[4] D. Bucur and M. Kwiatkowska. On software
veriﬁcation for sensor nodes. Journal of Systems and
Software, 84(10):1693–1707, 2011.
[5] Clang. clang: a C language family frontend for LLVM.
http://clang.llvm.org/.
[6] E. Clarke, D. Kroening, and F. Lerda. A tool for
checking ansi-c programs. In TACAS. Springer, 2004.
[7] J. Condit, M. Harren, Z. Anderson, D. Gay, and G. C.
Necula. Dependent types for low-level programming.
In Progr. Languages and Systems. Springer, 2007.
[8] N. Cooprider, W. Archer, E. Eide, D. Gay, and
J. Regehr. Eﬃcient memory safety for tinyos. In
SenSys. ACM, 2007.
[9] R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman,
and F. K. Zadeck. Eﬃciently computing static single
assignment form and the control dependence graph.
ACM TOPLAS, 1991.