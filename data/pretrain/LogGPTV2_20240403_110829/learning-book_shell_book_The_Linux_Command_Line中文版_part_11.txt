7.5处理不需要的输出
错误和状态信息。系统通过重定向输出结果到一个叫做“/dev/null”的特殊文件，为我们提供
了解决问题的方法。这个文件是系统设备，叫做位存储桶，它可以接受输入，并且对输入不做
任何处理。为了隐购命令错误信息，我们这样做：
T[nu/nap/ sovie-npeg
因为通配符总是以有序的方式展开，所以这些参数会以正确顺序安排
这很好，但是这和标准输入有什么关系呢？没有任何关系，让我们试着做些其他的工作。如
果我们输入不带参数的“cat”命令，会发生什么呢：
[ne@linuxbox -]$ cat
没有发生任何事情，它只是坐在那里，好像挂掉了一样。看起来是那样，但是它正在做它该
做的事情：
如果cat没有给出任何参数，它会从标准输入读入数据，又因为标准输入默认情况下连接到
键盘，它正在等待我们输入数据！试试这个：
74
---
## Page 76
[ne@linuxbox -]$ cat
The quick brown fox junped over the lazy dog
下一步，输入Ctrl-d（按住Ctrl键同时按下“d"），来告诉cat，在标准输入中，它已经到
达文件末尾（EOF）：
[ne@linuxbox -]$ cat
The quick brown fox junped over the lazy dog
由于没有文件名参数，cat复制标准输入到标准输出，所以我们看到文本行重复出现。我们
可以使用这种行为来创建简短的文本文件。比方说，我们想创建一个叫做“lazy_dog.txt”的文
件，这个文件包含例子中的文本。我们这样做：
[ne@linuxbox -]$ cat > lazy_dog.txt
The quick brown fox junped over the lazy dog
输入命令，其后输入要放入文件中的文本。记住，最后输入Ctrl-d。通过使用这个命令，我
们实现了世界上最低能的文字处理器！看一下运行结果，我们使用cat来复制文件内容到标准
输出：
[neglinuxbox -]$ cat lazy_dog.txt
The quick brown fox junped over the lazy dog.
现在我们知道cat怎样接受标准输入，除了文件名参数，让我们试着重定向标准输入：
[nedlinuxbox -]$ cat < lazy_dog.txt
The quick brown fox junped over the lazy dog.
使用“<”重定向操作符，我们把标准输入源从键盘改到文件lazy_dog.tx。我们看到结果
和传递单个文件名作为参数的执行结果一样。把这和传递一个文件名参数作比较，不是特别有
75
---
## Page 77
意义，但它是用来说明把一个文件作为标准输入源。有其他的命令更好地利用了标准输入，我
们不久将会看到。
在我们继续之前，查看cat的手册页，因为它有几个有趣的选项。
7.8管道线
命令从标准输人读取数据并输送到标准输出的能力被一个称为管道线的shell1特性所利用。使
用管道操作符“”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入：
cormand1 Icosnand2
为了全面地说明这个命令，我们需要一些命令。是否记得我们说过，我们已经知道有一个命
令接受标准输入？它是less命令。我们用less来一页一页地显示任何命令的输出，命令把它的
运行结果输送到标准输出：
[ne@linuxbox -]$ 1s -1 /usr/bin 1  less
这极其方便！使用这项技术，我们可以方便地检测会产生标准输出的任一命令的运行结果。
7.9过滤器
管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。通常，
以这种方式使用的命令被称为过滤器。过滤器接受输人，以某种方式改变它，然后输出它。第
一个我们想试验的过滤器是sort。想象一下，我们想把目录/bin和/usr/bin中的可执行程序都
联合在一起，再把它们排序，然后浏览执行结果：
[ne@linuxbox -]$ ls /bin /usr/bin 1  sort 1  less
因为我们指定了两个目录（/bin和/usr/bin），ls命令的输出结果由有序列表组成，各自针
对一个目录。通过在管道线中包含sort，我们改变输出数据，从而产生一个有序列表。
76
---
## Page 78
7.10uniq－报道或忽略重复行
uniq命令经常和sort命令结合在一起使用。uniq从标准输入或单个文件名参数接受数据有序
列表（详情查看unig手册页），默认情况下，从数据列表中删除任何重复行。所以，为了确信
我们的列表中不包含重复句子（这是说，出现在目录/bin和/usr/bin中重名的程序），我们添
加unig到我们的管道线中：
[neglinuxbox -]$ ls /bin /usr/bin 1 sort 1 uniq 1 less
在这个例子中，我们使用uniq从sort命令的输出结果中，来删除任何重复行。如果我们想
看到重复的数据列表，让unig命令带上“-d”选项，就像这样：
ssoT 1 p- btum 1 4xos 1 utq/xsm/ urq/ st s[- xoqxnuttgou]
7.11wc一打印行数、字数和字节数
wc（字计数）命令是用来显示文件所包含的行数、字数和字节数。例如：
[nellinuxbox -]$ vc 1s-output.txt
7902 64566 503634 1s-output.txt
在这个例子中，wc打印出来三个数字：包含在文件ls-output.txt中的行数，单词数和字节
数，正如我们先前的命令，如果wc不带命令行参数，它接受标准输入。“-1”选项限制命令输出
只能报道行数。添加wc到管道线来统计数据，是个很便利的方法。查看我们的有序列表中程
序个数，我们可以这样做：
[neglinuxbox -]$ ls /bin /usr/bin 1 sort 1 uniq 1 wc -1
2728
77
---
## Page 79
7.12
2grep一打印匹配行
grep是个很强大的程序。用来找到文件中的匹配文本。这样使用grep命令：
grep pattern [file...]
当grep遇到一个文件中的匹配“模式"，它会打印出包含这个类型的行。grep能够匹配的
模式可以很复杂，但是现在我们把注意力集中在简单文本匹配上面。在后面的章节中，我们将
会研究高级模式，叫做正则表达式。
搜索，可能让我们了解系统中的一些程序与文件压缩有关系·这样做：
[neglinuxbox -]$ ls /bin /usr/bin 1 sort 1 uniq 1 grep zip
bunzip2
bzip2
gunzip
grep有一些方便的选项：“-”使得grep在执行搜索时忽略大小写（通常，搜索是大小写敏
感的），“-v"选项会告诉grep只打印不匹配的行。
7.13head/tail一打印文件开头部分/结尾部分
有时候你不需要一个命令的所有输出。可能你只想要前几行或者后几行的输出内容。head命
令打印文件的前十行，而tail命令打印文件的后十行。默认情况下，两个命令都打印十行文本
但是可以通过“-n”选项来调整命令打印的行数。
[ne@linuxbox -]$ head =n 5 1s=output.txt
tota1343496
4xs*μndqno-st g u- trea $[- xoqxnustoou]
78
---
## Page 80
它们也能用在管道线中：
[ne@linuxbox -]$ ls /usr/bin 1 tail -n 5
zneu
tail有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为它们同
时在被写入。在以下的例子里，我们要查看目录/var/log里面的信息文件。在一些Linux发行
版中，要求有超级用户权限才能阅读这些文件，因为文件/var/log/messages可能包含安全信
息。
soesson/Bot/xe -[te s[-xoqxmuou]
Feb 8 13:40:05 tvin4 dhclient: DBCPACK fron 192.168.1.1
使用“-f”选项，tail命令继续监测这个文件，当新的内容添加到文件后，它们会立即出现在
屏幕上。这会一直继续下去直到你输入Ctrl-c。
7.14tee一从Stdin读取数据，并同时输出到Stdout和文件
为了和我们的管道隐喻保持一致，Linux提供了一个叫做tee的命令，这个命令制造了一个
tee"，安装到我们的管道上。tee程序从标准输入读入数据，并且同时复制数据到标准输出（允
许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的
内容时，这很有帮助。这里，我们重复执行一个先前的例子，这次包含tee命令，在grep过滤
管道线的内容之前，来捕捉整个目录列表到文件ls.txt：
[ne@linuxbox -]$ 1s /usr/bin 1 tee 1s.txt 1 grep zip
bunzip2
bzip2
6L
---
## Page 81
7.15总结归纳
一如既往，查看这章学到的每一个命令的文档。我们已经知道了他们最基本的用法。它们还有
很多有趣的选项。随着我们Linux经验的积累，我们会了解命令行重定向特性在解决特殊问题
时非常有用处。有许多命令利用标准输入和输出，而几乎所有的命令行程序都使用标准错误来
显示它们的详细信息。
Linux可以激发我们的想象
当我被要求解释Windows与Linux之间的差异时，我经常拿玩具来作比喻。
Windows就像一个游戏机。你去商店，买了一个包装在盒子里面的全新的游戏
机。你把它带回家，打开盒子。开始玩游戏。精美的画面，动人的声音。玩了一段
时间之后，你厌倦了它自带的游戏，所以你返回商店，又买了另一个游戏机。这个
过程反复重复。最后，你玩腻了游戏机自带的游戏，你回到商店，告诉售货员，“我
想要一个这样的游戏！”但售货员告诉你没有这样的游戏存在，因为它没有“市场
需求”。然后你说，“但是我只需要修改一下这个游戏！”售货员又告诉你不能修改
它。所有游戏都被封装在它们的存储器中。到头来，你发现你的玩具只局限于别人
为你规定好的游戏。
另一方面，Linux就像一个全世界上最大的建造模型。你打开它，发现它只是一
个巨大的部件集合。有许多钢支柱、螺钉、螺母、齿轮、滑轮、发动机和一些怎样
来建造它的说明书。然后你开始摆弄它。你建造了一个又一个样板模型。过了一会
儿，你发现你要建造自己的模型。你不必返回商店，因为你已经拥有了你需要的一
切。建造模型以你构想的形状为模板，搭建你想要的模型。
当然，选择哪一个玩具，是你的事情，那么你觉得哪个玩具更令人满意呢？
80
---
## Page 82
8”从shell眼中看世界
在这一章我们将看到，当你按下enter键后，发生在命令行中的一些“魔法”。尽管我们会深入
研究几个复杂而有趣的shell特性，但我们只需要使用一个新命令：
·echo一显示一行文本
8.1（字符）展开
每当你输入一个命令并按下enter键，bash会在执行你的命令之前对输入的字符完成几个步骤
的处理。我们已经见过几个例子：例如一个简单的字符序列*”，对shell来说有着多么丰富的
涵义。这背后的的过程叫做（字符）展开。通过展开，你输入的字符，在shell对它起作用之
前，会展开成为别的字符。为了说明这一点，让我们看一看echo命令。echo是一个shell内建
命令，可以完成非常简单的任务。它将它的文本参数打印到标准输出中。
[ne@linuxbox-]$ echo this isatest
this 1s a test
这个命令的作用相当简单明了。传递到echo命令的任一个参数都会在（屏幕上）显示出
来。让我们试试另一个例子：
[ne@linuxbox -]$ echo *
Desktop Docunents ls-output.txt Music Pictures Public Tenplates Videos
那么刚才发生了什么事情呢？为什么echo不打印“*”呢？如果你回忆起我们所学过的关于
通配符的内容，这个“*字符意味着匹配文件名中的任意字符。但在原先的讨论中我们并不知
道shell是怎样实现这个功能的。简单的答案就是shell在echo命令被执行前把“*”展开成了
81
---
## Page 83
另外的东西（在这里，就是在当前工作目录下的文件名字）。当回车键被按下时，shell在命令
被执行前在命令行上自动展开任何符合条件的字符，所以echo命令的实际参数并不是“*”，而
是它展开后的结果。知道了这个以后，我们就能明白echo的行为符合预期。
8.2路径名展开
通配符所依赖的工作机制叫做路径名展开。如果我们试一下在之前的章节中使用的技巧，我们
会看到它们实际上是展开。给定一个家目录，它看起来像这样：
[ne@linuxbox -]$ 1s
Desktop1s-output.txt
Pictures
Tenplates
我们能够执行以下的展开：
[ne@linuxbox -]$ echo D+
Desktop Docusents
和：
[ne@linuxbox -]$ echo *s
Docunents Pictures Tenplates Videos
甚至是：
[ne@linuxbox -]$ echo [[:upper:]]*
Desktop Docunents Music Pictures Public Tenplates Videos
查看家目录之外的目录：
82
---
## Page 84
[ne@linuxbox -]$ echo /usr/*/share
/usr/lkerberos/share /usr/local/share
隐藏文件路径名展开
正如我们知道的，以圆点字符开头的文件名是隐藏文件。路径名展开也尊重这种
行为。像这样的展开：
echo *
不会显示隐藏文件
直觉告诉我们，如果展开模式以一个圆点开头，我们就能够在展开中包含隐藏文
件，就像这样：
echo . *
它几乎要起作用了。然而，如果我们仔细检查一下输出结果，我们会看到名字
"”和“”也出现在结果中。由于它们是指当前工作目录和父目录，使用这种模式可
能会产生不正确的结果。我们可以通过这个命令来验证：
s -d .* /les8
为了在这种情况下正确地完成路径名展开，我们应该使用一个更精确的模式。这
个模式会正确地工作：
ls -d -!.,/?*
这种模式展开成所有以圆点开头，第二个字符不包含圆点，再包含至少一个字
符，并且这个字符之后紧接着任意多个字符的文件名。这个命令将正确列出大多数
的隐藏文件（但仍不能包含以多个圆点开头的文件名）。带有-A选项（“几乎所有”）
的1s命令能够提供一份正确的隐藏文件清单：
l8 -.A
8.3波浪线展开
可能你从我们对cd命令的介绍中回想起来，波浪线字符（“~"）有特殊的含义。当它用在一个
单词的开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则展开成当前用户的
家目录：
8
---
## Page 85
[nedlinuxbox -]$ echo 
/hcne/ze
如果有用户“foo”这个帐号，那么：
[ne@linuxbox -]$ echo ~foo
/home/foo
8.4算术表达式展开