applications that isolate them from the DBMS.
are
The list of tasks performed by a database administrator
is very long. Thus, we have decided to analyze the
database administrator tasks and group them in classes
related to the major groups of database administration
operations. This analysis was based on the study of core
functions available in all DBMS [10], interviews with
database administrators of real databases installations, and
examination of database scripts used to help some
database administration tasks. Table 1 shows the proposed
classes of DBMS operator faults (each class of faults
corresponds to many types of mistakes) and gives some
examples of faults for each class.
These major groups of operations can be found in any
commercial DBMS, as they are related to core functions
available in all DBMS [10]. Although the details of some
administrator operations are specific to each DBMS, the
standard SQL used by the vast majority of DBMS greatly
simplifies the establishment of equivalent administrator
mistakes
in different DBMS implementation. Some
operator faults, however, are intimately related to specific
features of a given DBMS and those ones may have no
counterparts in other DBMS.
easily
availability
damage DBMS
As we can see from the groups of operations used to
define each fault class in Table 1, database administrators
manage all aspects of DBMS. Obviously, administrator
mistakes
and
performance, which shows the interest of benchmarking
the behavior of DBMS in the presence of these faults.
The injection of operator faults in a DBMS can be easily
achieved by reproducing common database administrator
mistakes. That is, operator faults can be injected in the
system by using exactly the same means used in the field
by the real database administrator (i.e., we do not emulate
faults as it is usual in traditional fault injection: we really
reproduce operator faults). In order to make the procedure
fully automatic, faults can be injected by a set of scripts
that perform the wrong operation at a given moment (the
fault
trigger). As usually happens in traditional fault
injection, the fault trigger can be defined in such a way
that operator faults can be uniformly distributed over time
or can be synchronized with a specific event or command
of the workload.
Classes
Description
&
y
r
o
m
e
M
s
e
s
s
e
c
o
r
p
.
n
i
m
d
a
Mistakes in the administration of processes and memory
structures. Incorrectly define the memory allocation and
processes initialization parameters are typical faults related
to processes and memory administration. Another typical
fault is the accidental database shutdown that causes the
loss of service.
y
t
i
r
u
c
e
S
e
g
a
r
o
t
S
.
n
i
m
d
a
. Mistakes in the attribution of passwords, access privileges,
g
and disk space to users. These are very problematic faults
a
n
in database administration, as their effects are difficult to
a
m
detect.
Mistakes in the administration of the physical and logical
storage structures. Common examples of this class of faults
are:
the
incorrect distribution of files by several disks, and letting
the storage structures run out of space.
Errors related to the management of the user objects. The
removal of a user object (e.g.,
the
incorrect configuration of
the user objects, and the
incorrect use of the optimization structures are common
faults related to the database schema administration.
the removal or corruption of database files,
index, etc.),
n
i
m
d
a
table,
.
e
s
a
b
a
t
a
D
t
c
e
j
b
o
y
r
e
v
o
c
e
R
.
n
a
h
c
e
m
. Mistakes in the configuration and administration of the
n
database recovery mechanisms. Some typical examples
i
m
are: the inexistence of backups, the removal or corruption
d
a
of a log file, and the inexistence of archive logs.
Table 1. Classes of DBMS operator faults.
3.1. Example of operator faults in Oracle DBMS
Table 2 shows an instantiation of the operator fault
classes proposed in Table 1 for the case of Oracle 8i
DBMS, where each line represents specific types of
operator faults. The right column indicates whether each
type of faults is likely be found in other DBMS or not,
based on the analysis of fault characteristics and their
relation with general architectural features of DBMS [10].
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:16:58 UTC from IEEE Xplore.  Restrictions apply. 
these
faults
analysis
of
s
e
s
s
e
c
o
r
p
.
n
i
m
d
a
types of
Other
DBMS
&
y
r
o
m
e
M
comparative
A simplified
actual
implementations of DBMS for some major vendors
(Oracle, Microsoft, and Sybase) has also been done. The
notation used is the following: “Yes” means that exactly
the same type of fault can be found in other DBMS;
“Equivalent” means that the type of fault needs to be
translated to take into account implementation details but
a fault with equivalent effects can be found in other
DBMS; “Oracle” means that the type of fault is specific of
Oracle 8i DBMS. As we can see, most of the faults are
expected to be found in other DBMS. Although a more
comprehensive study is required to evaluate the portability
of
across different DBMS
implementations, this simplified analysis adds a flavor of
generality to the data presented in Table 2, and suggests
that a faultload based on a subset of these types of
operator faults could be fairly general.
Type of operator fault
Making a database instance shutdown
Removing or corrupting the initialization file
Incorrect configuration of the SGA parameters
Incorrect config. max. number of user sessions
Killing a user session
Database access level faults (passwords)
Incorrect attrib. of system and object privileges Equivalent
Equivalent
Attribution of incorrect disk quotas to users
Attribution of incorrect profiles to users
Equivalent
Incorrect attribution of tablespaces to users
Delete a controlfile, tablespace or rollback seg.
Delete a datafile
Incorrect distribution of datafiles through disks
Insufficient number of rollback segments
Set a tablespace offline
Set a datafile offline
Set a rollback segment offline
Allow a tablespace to run out of space
Allow a rollback segment to run out of space
Delete a database user
Delete any user’s database object
Incorrect config. object’s storage parameters
Set the NOLOGGING option in tables
Incorrect use of optimization structures
Delete a redo log file or group
Equivalent
Store all redo log group members in same disk Equivalent
Equivalent
Insufficient redo log groups to support archive
Equivalent
Inexistence of archive logs
Delete a archive log file
Equivalent
Store archive files in the same disk as data files Equivalent
Equivalent
Backups missing to allow recovery
Table 2. Example of concrete types of DBMS operator
Oracle
Oracle
Oracle
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Oracle
Oracle
n
o
i
t
a
r
t
s
i
n
i
m
d
a
Oracle
Oracle
m
s
i
n
a
h
c
e
m
Oracle
Yes
m
e
g
a
n
a
m
n
o
i
t
a
r
t
s
i
i
n
m
d
a
t
c
e
j
b
o
.
n
i
m
d
a
e
s
a
b
a
t
a
D
y
r
e
v
o
c
e
R
.
y
t
i
r
u
c
e
S
Equivalent
Equivalent
e
g
a
r
o
t
S
s
Equivalent
faults for Oracle 8i.
3.2. Operator faults emulation and recovery
As mentioned before, the injection of operator faults in
a DBMS can be easily achieved by reproducing common
database administrator mistakes. However,
in order to
emulate an operator fault in a way similar to what happens
in real world the set of steps represented in Figure 1 must
be followed. A very important aspect concerning the fault
emulation is the instant of activation of the faults (fault
trigger). The same fault activated in different moments
may cause different behaviors according to the system
state, which means that different instants for the injection
of faults must be chosen.
it
Figure 1. Steps in the injection of an operator fault.
Another relevant aspect to automate the experiments is
that
is necessary to evaluate the type of recovery
procedure that may be required after each fault. This
means that the scripts used to inject each type of fault
must also include all
the
adequate recovery procedure, which is much more
complex than the actual reproduction of the operator
faults. The starting instant of the recovery depends on the
time needed to detect the error. Due to the fact that in real
situations that time is highly human-dependent, a typical
detection time (for experiment purposes) has to be
established for each type of operator fault.
the steps required to start
4. Experimental setup
The basic platform used in the experiments presented
in this paper consists of two Intel Pentium III servers with
256MB of memory, four 20GB hard disks, running the
Windows 2000 operating system and connected through a
dedicated fast-Ethernet network.
in the paper,
As mentioned earlier
is used as case study for
the TPC-C
performance benchmark [1] running on top of Oracle 8i
database server
this joint
evaluation of performance and recoverability. The TPC-C
performance benchmark represents a typical database
installation. This workload includes a mixture of read-
only and update intensive transactions that simulate the
activities found in many complex OLTP application
environments. The performance metric for this benchmark
is expressed in transactions-per-minute-C (tpmC).
2
of
the
key
shows
Figure
components
the
experimental setup. The two basic configurations used in
the experiments consist of a single database server (which
is the standard configuration) and a configuration with a
stand-by database to study the benefits of using a spare
server to speed up recovery. The TPC-C specification also
includes an external driver system that emulates all the
client applications and respective users during the
benchmark run. This driver system has been extended to
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:16:58 UTC from IEEE Xplore.  Restrictions apply. 
lost
handle the insertion of the operator faults. Additionally,
the driver system also records the base data needed to get
the recovery and integrity measures, which consist of
recovery time,
transactions, and detection of
integrity violations. It is worth noting that these measures
are taken from the end-user point of view, which means
that, for example, the recovery time includes all the time
needed to recover the Oracle server plus the time needed
to reestablish the transaction execution at
the client
application level (i.e., as it would be seen by the end-user).
Figure 2. Experimental setup layout.
The operator faults are injected through a set of scripts
and following the steps represented in Figure 1. In order
to make it easy to reproduce the experiments we have
decided to inject the faults in three specific moments
(instead of using a random distribution for the fault
triggers), respectively after 150, 300, and 600 seconds
from the TPC-C start. The faults injected in the first
instant (150 seconds) affect the system when it is speeding
up to reach the nominal transaction performance. The
faults injected in the second instant (300 seconds) affect
the system when it
is on its maximum processing
throughput. Finally, the faults injected in the third instant
(600 seconds) affect the system when a large amount of
transactions has already been processed. The duration of
each individual experiment was 20 minutes and the
execution of all the experiments is fully automatic.
Considering the types of faults presented in Table 2,
we have excluded from this first study the classes of faults
“security management”, because the security issues are
out of scope of this work, and “recovery mechanisms
administration”, as most of these faults just affect database
performance and would require two consecutive faults to
affect the system in other visible ways. In fact, after a first
fault affecting the recovery mechanisms we would need a
second fault of other type to activate the recovery and
reveal the effects of the first fault.
and
From the three operator
processes
faults classes considered
(“memory
administration”,
“storage
administration”, and “database object administration”
faults) we have selected six main types of fault. These
faults have been chosen based on their ability to emulate
the effects of other types of faults (to minimize the
number of experiments needed), on the diversity of impact
in the system, and on the complexity of required recovery.
The basic six types of faults include: Shutdown abort,
Delete a datafile, Delete a tablespace, Set a datafile
offline, Set a tablespace offline, and Delete user’s object.
A total of 146 faults have been injected from the six
types of faults mentioned above, covering all the tested
configurations. The scripts to emulate the operator faults
were programmed in Perl and SQL and can easily be
ported to other DBMS.
5. Experimental results and discussion
Three sets of experiments have been conducted. The
first set of experiments evaluates the effectiveness of
different configurations of the basic recovery mechanism
(online redo logs). The second set of experiments
evaluates different configurations of
the archive log
mechanism. The last set of experiments assesses the
effectiveness of the stand-by database mechanism. The
following sub-sections present and discuss these results.
5.1. Results with basic recovery mechanism
When the online redo log mechanism is used alone it
only guarantees the recovery of Shutdown Abort type of
faults, due to the redo log files reuse. However, some
other
the last
database backup was made after the last reuse of any redo
log file.
faults can be recovered provided that
The frequency of checkpoints
is one important
recovery factor affecting the database performance.
Obviously, very frequent checkpoints tend to reduce the
recovery time. Other
to reduce the
recovery time is to minimize the time a given data block
marked as dirty remains in the database cache (because
this reduces the amount of data to be recovered).
relevant
factor
The
frequency
and