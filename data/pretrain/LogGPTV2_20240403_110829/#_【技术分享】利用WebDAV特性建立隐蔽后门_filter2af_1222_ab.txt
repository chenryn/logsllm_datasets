请求看起来像这样：
    PROPFIND / HTTP/1.1
    Connection: Keep-Alive
    User-Agent: Microsoft-WebDAV-MiniRedir/10.0.14393
    Depth: 0
    translate: f
    Content-Length: 0
    Host: 10.211.55.2
重要的是要注意，在这一点上，客户端的硬盘驱动器上没有传输实际的文件，也没有缓存。
然后，如果WebDAV客户端要求远程目录中所有文件的列表，它将发出一些PROPFIND请求，其中一个标题为“Depth: 1”，如下所示：
    PROPFIND / HTTP/1.1
    Connection: Keep-Alive
    User-Agent: Microsoft-WebDAV-MiniRedir/10.0.14393
    Depth: 1
    translate: f
    Content-Length: 0
    Host: 10.211.55.2
WebDAV服务器将回复当前目录中存在的所有文件的XML格式列表，以及一些元数据信息（大小，创建日期等）。 每个 
块对应一条文件信息：
    HTTP/1.1 207 Multi-Status
    Server: nginx/1.6.2
    Date: Thu, 07 Sep 2017 10:27:23 GMT
    Content-Length: 8084
    Proxy-Connection: Keep-Alive
    Connection: Keep-Alive
    /
    2017-09-07T10:27:23Z
    filename
    4096
    Thu, 07 Sep 2017 10:27:23 GMT
    HTTP/1.1 200 OK
    [...]
在这一点上，仍然没有实际的文件传输，客户端硬盘上没有缓存文件。
最终，当WebDAV客户端想要访问文件时，它将发出实际传输文件的请求，如下所示：
    GET /calc.hta HTTP/1.1
    Cache-Control: no-cache
    Connection: Keep-Alive
    Pragma: no-cache
    User-Agent: Microsoft-WebDAV-MiniRedir/10.0.14393
    translate: f
    Host: 10.211.55.2
WebDAV服务器使用包含请求文件的十分标准的HTTP响应进行回复。
在这一点上，文件被传输并缓存在客户端的驱动器上（C:WindowsServiceProfilesLocalServiceAppDataLocalTempTfsStoreTfs_DAV）。
我们可以看到，上述两个缺点仅在文件实际从服务器传输到客户端时发生。但是事实证明，用于列出目录中的文件的PROPFIND请求也拥有可用于传输任意数据的大量信息。
**  
**
**仅使用PROPFIND请求**
所以我们想要实现的只是使用PROPFIND请求传输任意数据。我提出了以下想法：
1\. 文件名本身就是在列出具有PROPFIND请求的目录时传送的信息。
2\. 目录中可能需要/需要的文件数量尽可能多（可能会有一个限制，但仍然可以处理）。
3\. 虽然这取决于WebDAV客户端和服务器实现，但每个文件名可以大致为250个字符。
4\. 文件名只能支持一定数量的字符（例如'/'和''不支持）
这就让我产生了以下想法，假设给定一个我想传递的Payload，可通过如下步骤处理：
1\. 先对其进行base64编码
2\. 替换文件名中不支持的所有字符（用'_'替换'/'，这似乎是常见的做法）
3\. 将其切成250个字符的块
4\. 使其可用作目录名
在远端，我需要找到一种方法：
1\. 只列出虚拟目录上的文件（不GET任何东西）
2\. 重组那些块
3\. 将替换的字符替换回来
4\. 将base64结果解码回初始Payload
所有这些都需要付出代价：大量的性能和通信浪费。但它可以让我们摆脱上述两个缺点！
为了实现这一点，我创建了一个（快速并且写的很差的）python脚本，它的行为就像一个非常非常简约的WebDAV服务器（仅支持OPTIONS和PROPFIND请求）。但这只是足以满足我们的需求。使用有效载荷文件作为参数调用此脚本，以及要使用的base64编码类型（与powershell兼容或不兼容），并将在端口80上启动WebDAV服务器：
[](https://camo.githubusercontent.com/53fe8a5dda093f939acc0c0226bdecc4d22561ef/68747470733a2f2f646c2e64726f70626f7875736572636f6e74656e742e636f6d2f732f6b76656175666b30366a6c376333622f7765626461765f30322e706e673f646c3d30)
在客户端，有很多方法可以执行适当的请求，所以我创建了一些例子，使用VBA宏或Powershell脚本，它们都只依赖于WebClient服务，这样我们以前讨论的所有其他好处仍然存在：
1\. 网络外围防御系统（IPS，杀毒软件）没有检测到传输的Payload。
2\. 没有文件写在WebDAV客户端缓存中，也就是磁盘上。
WebDav传输工具和一些客户端stager示例托管在此gist页面上：  
[https://gist.github.com/Arno0x/5da411c4266e5c440ecb6ffc50b8d29a](https://gist.github.com/Arno0x/5da411c4266e5c440ecb6ffc50b8d29a)
**  
**
**进一步使用完整的C &C通信**
基于相同的原因，为什么只提供有效载荷？为什么不通过WebDAV PROPFIND请求/响应创建一个完整的C&C双向通信通道？
所以我创建了一个极简代理和C&C服务器，作为一个PoC。代理方是一个.Net程序集可执行文件，可以独立执行，也可以加载到一个powerhell进程的内存中。所有通信来回使用仅基于UNC路径的PROPFIND请求，因此利用WebClient服务和前面提到的所有好处。
主要特点是：
1\. 创建各种stager，试图避免杀毒软件检测，这将下载Agent，然后加载到一个powershell进程内存中。
2\. 在v0.1中，代理程序只需执行本地“cmd.exe”子进程，并通过WebDAV
PROPFIND请求代理来自C2服务器的stdin/stdout/stderr。
[](https://camo.githubusercontent.com/c44e8a6b64a497637227021b91b7666834295f27/68747470733a2f2f646c2e64726f70626f7875736572636f6e74656e742e636f6d2f732f737775637639697872376261756d622f7765626461765f30332e706e673f646c3d30)
WebDavC2可以从这里下载：[https://github.com/Arno0x/WebDavC2](https://github.com/Arno0x/WebDavC2)
该代理是从我的另一个工具DBC2启发的，将这个代理的功能扩展到DBC2代理能力的程度很容易。